---
title: "Codehorses T-shirts"
layout: "post"
diff: 普及-
pid: CF1000A
tag: []
---

# Codehorses T-shirts

## 题目描述

**题目大意：**

$n$个字符串和$n$个模板串，在$1s$的时间内你可以选择一个字符串（不是模板串）修改任意多的字符，但是不能删除或增加字符，问至少需要多少s使得字符串变为模板串，注意不考虑串的顺序，即最后每个字符串出现次数=这个串在模板串中的出现次数

## 输入格式

第一行一个整数，$n$，$n<=100$

以下$n$行每行一个字符串

再$n$行每行一个模板串

## 输出格式

一个整数，即最少时间

感谢@守望 提供翻译

## 样例 #1

### 输入

```
3
XS
XS
M
XL
S
XS

```

### 输出

```
2

```

## 样例 #2

### 输入

```
2
XXXL
XXL
XXL
XXXS

```

### 输出

```
1

```

## 样例 #3

### 输入

```
2
M
XS
XS
M

```

### 输出

```
0

```



---

---
title: "Turn the Rectangles"
layout: "post"
diff: 普及-
pid: CF1008B
tag: []
---

# Turn the Rectangles

## 题目描述

There are $ n $ rectangles in a row. You can either turn each rectangle by $ 90 $ degrees or leave it as it is. If you turn a rectangle, its width will be height, and its height will be width. Notice that you can turn any number of rectangles, you also can turn all or none of them. You can not change the order of the rectangles.

Find out if there is a way to make the rectangles go in order of non-ascending height. In other words, after all the turns, a height of every rectangle has to be not greater than the height of the previous rectangle (if it is such).

## 输入格式

The first line contains a single integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the number of rectangles.

Each of the next $ n $ lines contains two integers $ w_i $ and $ h_i $ ( $ 1 \leq w_i, h_i \leq 10^9 $ ) — the width and the height of the $ i $ -th rectangle.

## 输出格式

Print "YES" (without quotes) if there is a way to make the rectangles go in order of non-ascending height, otherwise print "NO".

You can print each letter in any case (upper or lower).

## 说明/提示

In the first test, you can rotate the second and the third rectangles so that the heights will be \[4, 4, 3\].

In the second test, there is no way the second rectangle will be not higher than the first one.

## 样例 #1

### 输入

```
3
3 4
4 6
3 5

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
2
3 4
5 5

```

### 输出

```
NO

```



---

---
title: "Stages"
layout: "post"
diff: 普及-
pid: CF1011A
tag: []
---

# Stages

## 题目描述

Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $ n $ stages available. The rocket must contain exactly $ k $ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $ 26 $ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.

## 输入格式

The first line of input contains two integers — $ n $ and $ k $ ( $ 1 \le k \le n \le 50 $ ) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $ s $ , which consists of exactly $ n $ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.

## 输出格式

Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.

## 说明/提示

In the first example, the following rockets satisfy the condition:

- "adx" (weight is $ 1+4+24=29 $ );
- "ady" (weight is $ 1+4+25=30 $ );
- "bdx" (weight is $ 2+4+24=30 $ );
- "bdy" (weight is $ 2+4+25=31 $ ).

Rocket "adx" has the minimal weight, so the answer is $ 29 $ .

In the second example, target rocket is "belo". Its weight is $ 2+5+12+15=34 $ .

In the third example, $ n=k=2 $ , so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.

## 样例 #1

### 输入

```
5 3
xyabd

```

### 输出

```
29
```

## 样例 #2

### 输入

```
7 4
problem

```

### 输出

```
34
```

## 样例 #3

### 输入

```
2 2
ab

```

### 输出

```
-1
```

## 样例 #4

### 输入

```
12 1
abaabbaaabbb

```

### 输出

```
1
```



---

---
title: "Points in Segments"
layout: "post"
diff: 普及-
pid: CF1015A
tag: []
---

# Points in Segments

## 题目描述

有n条线段在数轴Ox上，每条线段有介于1到m之间的整数端点。线段之间可以重合、覆盖甚至相同。每条线段由两个整数li和ri描述（1<=li<=ri<=m）--对应左、右端点。

考虑1到m之间的所有整数点。要求你输出所有的不属于任何线段的点。

当且仅当点l<=x<=r时，点x属于这条线段。

## 输入格式

第一行包括两个整数n，m（1<=n,m<=100）--线段数量和数轴最大值。

下面n行每行包括两个整数li和ri--第i条线段的端点。

注：li可能==ri，即一个线段可能退化成一个点

## 输出格式

第一行输出一个整数 k--不属于任何线段的点的数量。

第二行以任意顺序输出k个整数--不属于任何线段的点数。

如果根本没有这样的点，第一行输出一个整数0并留空第二行或者根本不输出第二行。

## 样例 #1

### 输入

```
3 5
2 2
1 2
5 5

```

### 输出

```
2
3 4 

```

## 样例 #2

### 输入

```
1 7
1 7

```

### 输出

```
0


```



---

---
title: "Songs Compression"
layout: "post"
diff: 普及-
pid: CF1015C
tag: []
---

# Songs Compression

## 题目描述

Ivan has $ n $ songs on his phone. The size of the $ i $ -th song is $ a_i $ bytes. Ivan also has a flash drive which can hold at most $ m $ bytes in total. Initially, his flash drive is empty.

Ivan wants to copy all $ n $ songs to the flash drive. He can compress the songs. If he compresses the $ i $ -th song, the size of the $ i $ -th song reduces from $ a_i $ to $ b_i $ bytes ( $ b_i < a_i $ ).

Ivan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most $ m $ . He can compress any subset of the songs (not necessarily contiguous).

Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to $ m $ ).

If it is impossible to copy all the songs (even if Ivan compresses all the songs), print "-1". Otherwise print the minimum number of songs Ivan needs to compress.

## 输入格式

The first line of the input contains two integers $ n $ and $ m $ ( $ 1 \le n \le 10^5, 1 \le m \le 10^9 $ ) — the number of the songs on Ivan's phone and the capacity of Ivan's flash drive.

The next $ n $ lines contain two integers each: the $ i $ -th line contains two integers $ a_i $ and $ b_i $ ( $ 1 \le a_i, b_i \le 10^9 $ , $ a_i > b_i $ ) — the initial size of the $ i $ -th song and the size of the $ i $ -th song after compression.

## 输出格式

If it is impossible to compress a subset of the songs in such a way that all songs fit on the flash drive, print "-1". Otherwise print the minimum number of the songs to compress.

## 说明/提示

In the first example Ivan can compress the first and the third songs so after these moves the sum of sizes will be equal to $ 8 + 7 + 1 + 5 = 21 \le 21 $ . Also Ivan can compress the first and the second songs, then the sum of sizes will be equal $ 8 + 4 + 3 + 5 = 20 \le 21 $ . Note that compressing any single song is not sufficient to copy all the songs on the flash drive (for example, after compressing the second song the sum of sizes will be equal to $ 10 + 4 + 3 + 5 = 22 > 21 $ ).

In the second example even if Ivan compresses all the songs the sum of sizes will be equal $ 8 + 4 + 1 + 4 = 17 > 16 $ .

## 样例 #1

### 输入

```
4 21
10 8
7 4
3 1
5 4

```

### 输出

```
2

```

## 样例 #2

### 输入

```
4 16
10 8
7 4
3 1
5 4

```

### 输出

```
-1

```



---

---
title: "New Building for SIS"
layout: "post"
diff: 普及-
pid: CF1020A
tag: []
---

# New Building for SIS

## 题目描述

你正在研究夏季信息学院新建筑的楼层设计。因为你担任着英国秘密情报局的后勤物流任务，所以你十分在乎去往不同位置的路程耗时：了解从演讲室到食堂，或者从健身房到服务器机房的耗时是很重要的。



这个建筑由 $n$ 个塔楼组成，标号为 $1 - n$ ；每个塔楼有 $h$ 层，标号为 $1 - h$ 。任意两个相邻的塔楼间有一条通道（当 $1 \le i \le n - 1$ 时，塔楼 $i$ 与 $i - 1$ 相连）。在第 $x ( a \le x \le b)$ 层上，你可以在与第 $x$ 层相邻的2层移动，或如果第 $x$ 层与相邻的塔楼有通道连通也可移动至其上。离开建筑是不被允许的。



![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1020A/f837e8e8bdf323146303fdec0eaae175f05c2066.png)



这个图片解释了 **输入 #1**



你将被给予 $k$ 对位置 $(t_a, f_a), (t_b, f_b)$ ：代表塔楼 $t_a$ 上的第 $f_a$ 层，塔楼  $t_b$ 上的第 $f_b$ 层。



对于每一对位置，你需要确定它们之间的最短耗时。

## 输入格式

输入的第一行包含以下整数：



- $n$ : 建筑中塔楼的个数 $(1 \le n \le 10^8)$

- $h$ : 塔楼的层数 $( 1 \le h \le 10^8)$

- $a$ 和 $b$ : 可以在相邻塔楼间移动的最低与最高楼层限制 $(1 \le a \le b \le h)$ 

- $k$ : 给予的位置个数 $ (1 \le k \le 10^4) $



接下来 $k$ 行，是每对位置的详细数据，每对数据包括四个整数 $t_a, f_a, t_b, f_b (1 \le t_a, t_b \le n, 1 \le f_a, f_b \le h)$ 你需要确定它们间的最短耗时。

## 输出格式

对于每对位置，回应一个整数，为两地之间最短路程耗时。

## 样例 #1

### 输入

```
3 6 2 3 3
1 2 1 3
1 4 3 4
1 2 2 3

```

### 输出

```
1
4
2

```



---

---
title: "Badge"
layout: "post"
diff: 普及-
pid: CF1020B
tag: []
---

# Badge

## 题目描述

在一所学校，如果一个学生表现不好，老师就会在他的徽章上打一个洞。今天，老师逮到了n名学生在搞恶作剧。

这些学生从1到n编号。老师先逮到了a学生然后在他的徽章上打了个洞。但是这个学生说带头的是另一个学生pa。

于是老师又抓住学生pa在他的徽章上也打了个洞。这个学生又说其实是学生ppa在带头搞恶作剧。

这个过程一直持续了好一会儿，不过因为这些学生是有限的，最后老师抓住了一个徽章上已经有一个洞的学生。

在给这个倒霉孩子的徽章上又打了个洞以后，老师觉得有点累，需要蒸个桑拿于是他就不再继续了。

你不知道谁是老师逮到的第一个学生，但是你知道所有的数字pi。对于每一个a，如果第一个被逮到的学生是a，你的任务是找到谁会是徽章上面有两个洞的学生。

## 输入格式

第一行只有一个数字 n (1 <= n <=1000) ，表示搞恶作剧的学生的人数。

第二行有n个数字，p1, ..., pn (1<= pi <= n), pi表示被学生i指认是带头搞恶作剧的学生的编号。

## 输出格式

对从1 到 n之间的每个学生 a，如果a是第一个被抓到的学生，输出谁会是徽章上面有两个洞的学生。

## 说明/提示

![图片](http://codeforces.com/predownloaded/e6/2f/e62f6279b291a91d10dcf8b13b483a9dc5659758.png)

当a = 1, 老师的打洞顺序是1->2->3->2，输出2（2的徽章上会有俩洞）；

当a = 2, 老师的打洞顺序是 2->3->2，输出2； 当a = 3，老师的打洞顺序是3->2->3，输出3。

对于第二个样例，不管老师先逮到谁，这个第一个被老师逮到的倒霉孩子将会得到两个洞。

## 样例 #1

### 输入

```
3
2 3 2

```

### 输出

```
2 2 3 

```

## 样例 #2

### 输入

```
3
1 2 3

```

### 输出

```
1 2 3 

```



---

---
title: "Palindromic Twist"
layout: "post"
diff: 普及-
pid: CF1027A
tag: []
---

# Palindromic Twist

## 题目描述

You are given a string $ s $ consisting of $ n $ lowercase Latin letters. $ n $ is even.

For each position $ i $ ( $ 1 \le i \le n $ ) in string $ s $ you are required to change the letter on this position either to the previous letter in alphabetic order or to the next one (letters 'a' and 'z' have only one of these options). Letter in every position must be changed exactly once.

For example, letter 'p' should be changed either to 'o' or to 'q', letter 'a' should be changed to 'b' and letter 'z' should be changed to 'y'.

That way string "codeforces", for example, can be changed to "dpedepqbft" ('c' $ \rightarrow $ 'd', 'o' $ \rightarrow $ 'p', 'd' $ \rightarrow $ 'e', 'e' $ \rightarrow $ 'd', 'f' $ \rightarrow $ 'e', 'o' $ \rightarrow $ 'p', 'r' $ \rightarrow $ 'q', 'c' $ \rightarrow $ 'b', 'e' $ \rightarrow $ 'f', 's' $ \rightarrow $ 't').

String $ s $ is called a palindrome if it reads the same from left to right and from right to left. For example, strings "abba" and "zz" are palindromes and strings "abca" and "zy" are not.

Your goal is to check if it's possible to make string $ s $ a palindrome by applying the aforementioned changes to every position. Print "YES" if string $ s $ can be transformed to a palindrome and "NO" otherwise.

Each testcase contains several strings, for each of them you are required to solve the problem separately.

## 输入格式

The first line contains a single integer $ T $ ( $ 1 \le T \le 50 $ ) — the number of strings in a testcase.

Then $ 2T $ lines follow — lines $ (2i - 1) $ and $ 2i $ of them describe the $ i $ -th string. The first line of the pair contains a single integer $ n $ ( $ 2 \le n \le 100 $ , $ n $ is even) — the length of the corresponding string. The second line of the pair contains a string $ s $ , consisting of $ n $ lowercase Latin letters.

## 输出格式

Print $ T $ lines. The $ i $ -th line should contain the answer to the $ i $ -th string of the input. Print "YES" if it's possible to make the $ i $ -th string a palindrome by applying the aforementioned changes to every position. Print "NO" otherwise.

## 说明/提示

The first string of the example can be changed to "bcbbcb", two leftmost letters and two rightmost letters got changed to the next letters, two middle letters got changed to the previous letters.

The second string can be changed to "be", "bg", "de", "dg", but none of these resulting strings are palindromes.

The third string can be changed to "beeb" which is a palindrome.

The fifth string can be changed to "lk", "lm", "nk", "nm", but none of these resulting strings are palindromes. Also note that no letter can remain the same, so you can't obtain strings "ll" or "mm".

## 样例 #1

### 输入

```
5
6
abccba
2
cf
4
adfa
8
abaazaba
2
ml

```

### 输出

```
YES
NO
YES
NO
NO

```



---

---
title: "Find Square"
layout: "post"
diff: 普及-
pid: CF1028A
tag: []
---

# Find Square

## 题目描述

一块矩形有n × m个白色格子，把其中的一些格子涂成黑色，形成一大块黑色的正方形格子，正方形的边长为奇数。找出这个正方形的中心点。

## 输入格式

第1行包括两个整数n , m（ 1≤ _n_ , _m_ ≤ 115 ）表示矩形的行和列。
接下来第2到n+1行，每行m个字符，s_i1_ , s_i2_ ... s_im_（ s_ij_ 为 ‘ W ’ 时表示白色格子，为 ‘ B ’ 时表示黑色格子， _i_ 表示矩形第 _i_ 行）。

## 输出格式

输出包括两个整数r , c（ 1 ≤ _r_ ≤ _n_ , 1 ≤ _c_ ≤ _m_ ），用空格隔开，表示正方形的中心点在矩形中的坐标。

## 样例 #1

### 输入

```
5 6
WWBBBW
WWBBBW
WWBBBW
WWWWWW
WWWWWW

```

### 输出

```
2 4

```

## 样例 #2

### 输入

```
3 3
WWW
BWW
WWW

```

### 输出

```
2 1

```



---

---
title: "Sum of Digits"
layout: "post"
diff: 普及-
pid: CF102B
tag: []
---

# Sum of Digits

## 题目描述

Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number $ n $ . How many times can Gerald put a spell on it until the number becomes one-digit?

## 输入格式

The first line contains the only integer $ n $ ( $ 0<=n<=10^{100000} $ ). It is guaranteed that $ n $ doesn't contain any leading zeroes.

## 输出格式

Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.

## 说明/提示

In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number $ 10 $ . After one casting of a spell it becomes $ 1 $ , and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number $ 991 $ . As one casts a spell the following transformations take place: $ 991→19→10→1 $ . After three transformations the number becomes one-digit.

## 样例 #1

### 输入

```
0

```

### 输出

```
0

```

## 样例 #2

### 输入

```
10

```

### 输出

```
1

```

## 样例 #3

### 输入

```
991

```

### 输出

```
3

```



---

---
title: "Golden Plate"
layout: "post"
diff: 普及-
pid: CF1031A
tag: []
---

# Golden Plate

## 题目描述

You have a plate and you want to add some gilding to it. The plate is a rectangle that we split into $ w\times h $ cells. There should be $ k $ gilded rings, the first one should go along the edge of the plate, the second one — $ 2 $ cells away from the edge and so on. Each ring has a width of $ 1 $ cell. Formally, the $ i $ -th of these rings should consist of all bordering cells on the inner rectangle of size $ (w - 4(i - 1))\times(h - 4(i - 1)) $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1031A/347cd2ee781d01fc5a8212010a9a488ef250ad46.png)The picture corresponds to the third example.Your task is to compute the number of cells to be gilded.

## 输入格式

The only line contains three integers $ w $ , $ h $ and $ k $ ( $ 3 \le w, h \le 100 $ , $ 1 \le k \le \left\lfloor \frac{min(n, m) + 1}{4}\right\rfloor $ , where $ \lfloor x \rfloor $ denotes the number $ x $ rounded down) — the number of rows, columns and the number of rings, respectively.

## 输出格式

Print a single positive integer — the number of cells to be gilded.

## 说明/提示

The first example is shown on the picture below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1031A/8ef68100f0e4d74d121ee779a666ca2b2a0d0fdf.png)The second example is shown on the picture below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1031A/22b59cf41d139cb0bc1ae7e108eb90b4ef24521f.png)The third example is shown in the problem description.

## 样例 #1

### 输入

```
3 3 1

```

### 输出

```
8

```

## 样例 #2

### 输入

```
7 9 1

```

### 输出

```
28

```

## 样例 #3

### 输入

```
7 9 2

```

### 输出

```
40

```



---

---
title: "Personalized Cup"
layout: "post"
diff: 普及-
pid: CF1032B
tag: []
---

# Personalized Cup

## 题目描述

At many competitions that have a word «cup» in its official name the winner is presented with an actual cup. This time the organizers of one unusual programming competition have decided to please the winner even more and to add a nameplate to the cup with the handle of the winner.

The nameplate is to be rectangular and the text on it will be printed as a table of several rows and columns. Having some measurements done, the organizers have found out that the number $ a $ of rows cannot be greater than $ 5 $ while the number $ b $ of columns cannot exceed $ 20 $ . Every cell of the table will contain either an asterisk («\*») or a letter of user's handle.

Furthermore, the organizers want the rows of the table to be uniform, which means that the number of asterisks used in different rows should differ by at most one (i.e. you can't have two asterisks in the first row and none in the second). The main goal, however, is to obtain the winner's handle precisely when reading the table from top to bottom and from left to right in every row (skipping asterisks).

The organizers want for the nameplate to have as few rows as possible and among all valid tables with the minimum number of rows they want to choose the one that has the minimum number of columns.

The winner is not yet determined so your task is to write a program that, given a certain handle, generates the necessary table.

## 输入格式

The only line contains one string $ s $ ( $ 1 \le |s| \le 100 $ ), comprised of uppercase and lowercase Latin letters, — the handle of the winner.

## 输出格式

In the first line output the minimum number $ a $ of rows in the table and the minimum number $ b $ of columns in an optimal table with rows.

The following $ a $ lines should contain $ b $ characters each — any valid table.

## 样例 #1

### 输入

```
tourist

```

### 输出

```
1 7
tourist

```

## 样例 #2

### 输入

```
MyNameIsLifeIAmForeverByYourSideMyNameIsLife

```

### 输出

```
3 15
MyNameIsLifeIAm
ForeverByYourSi
deMyNameIsL*ife

```



---

---
title: "King Escape"
layout: "post"
diff: 普及-
pid: CF1033A
tag: []
---

# King Escape

## 题目描述

艾丽丝和鲍勃正在一个n*n大棋盘上下棋。爱丽丝只剩下一个皇后，位于(a_x，a_y)，而鲍勃只有一个国王，位于(b_x，b_y)。爱丽丝认为，她的皇后是主宰棋盘的，所以胜利是属于她的。但是鲍勃已经制定了一个计划来赢得胜利，他需要移动国王到(c_x，c_y)，以便为自己争取胜利。当爱丽丝被她的自信所分心时，她将不会移动他的皇后，只有鲍勃才能进行移动。如果鲍勃能把他的国王从(b_x，b_y)移到(c_x，c_y)，他就会赢。请记住，国王可以移动到任何8个相邻的棋格。如果国王与皇后处于同一行、同一列或同一对角线，则将所到攻击。看看鲍勃能不能赢。

## 输入格式

第一行：一个数:棋盘的行数和列数n（3<=n<=1000）

第二行：两个数:a_x,a_y（1<=a_x,a_y<=n）

第三行：两个数:b_x,b_y（1<=b_x,b_y<=n）

第四行：两个数:c_x,c_y（1<=c_x,c_y<=n）

## 输出格式

能赢输出"YES",否则输出"NO"
### （样例解析请看图）

## 样例 #1

### 输入

```
8
4 4
1 3
3 1

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
8
4 4
2 3
1 6

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
8
3 5
1 2
6 1

```

### 输出

```
NO

```



---

---
title: "Square Difference"
layout: "post"
diff: 普及-
pid: CF1033B
tag: []
---

# Square Difference

## 题目描述

Alice has a lovely piece of cloth. It has the shape of a square with a side of length $ a $ centimeters. Bob also wants such piece of cloth. He would prefer a square with a side of length $ b $ centimeters (where $ b < a $ ). Alice wanted to make Bob happy, so she cut the needed square out of the corner of her piece and gave it to Bob. Now she is left with an ugly L shaped cloth (see pictures below).

Alice would like to know whether the area of her cloth expressed in square centimeters is [prime.](https://en.wikipedia.org/wiki/Prime_number) Could you help her to determine it?

## 输入格式

The first line contains a number $ t $ ( $ 1 \leq t \leq 5 $ ) — the number of test cases.

Each of the next $ t $ lines describes the $ i $ -th test case. It contains two integers $ a $ and $ b~(1 \leq b < a \leq 10^{11}) $ — the side length of Alice's square and the side length of the square that Bob wants.

## 输出格式

Print $ t $ lines, where the $ i $ -th line is the answer to the $ i $ -th test case. Print "YES" (without quotes) if the area of the remaining piece of cloth is prime, otherwise print "NO".

You can print each letter in an arbitrary case (upper or lower).

## 说明/提示

The figure below depicts the first test case. The blue part corresponds to the piece which belongs to Bob, and the red part is the piece that Alice keeps for herself. The area of the red part is $ 6^2 - 5^2 = 36 - 25 = 11 $ , which is prime, so the answer is "YES".

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1033B/26aa17f955334a29eef8994b7c5af8ed29b66689.png)In the second case, the area is $ 16^2 - 13^2 = 87 $ , which is divisible by $ 3 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1033B/bb700dc40c3e1b73968059e8f9c3fba6a4d8a953.png)In the third case, the area of the remaining piece is $ 61690850361^2 - 24777622630^2 = 3191830435068605713421 $ . This number is not prime because $ 3191830435068605713421 = 36913227731 \cdot 86468472991  $ .

In the last case, the area is $ 34^2 - 33^2 = 67 $ .

## 样例 #1

### 输入

```
4
6 5
16 13
61690850361 24777622630
34 33

```

### 输出

```
YES
NO
NO
YES

```



---

---
title: "Function Height"
layout: "post"
diff: 普及-
pid: CF1036A
tag: []
---

# Function Height

## 题目描述

You are given a set of $ 2n+1 $ integer points on a Cartesian plane. Points are numbered from $ 0 $ to $ 2n $ inclusive. Let $ P_i $ be the $ i $ -th point. The $ x $ -coordinate of the point $ P_i $ equals $ i $ . The $ y $ -coordinate of the point $ P_i $ equals zero (initially). Thus, initially $ P_i=(i,0) $ .

The given points are vertices of a plot of a piecewise function. The $ j $ -th piece of the function is the segment $ P_{j}P_{j + 1} $ .

In one move you can increase the $ y $ -coordinate of any point with odd $ x $ -coordinate (i.e. such points are $ P_1, P_3, \dots, P_{2n-1} $ ) by $ 1 $ . Note that the corresponding segments also change.

For example, the following plot shows a function for $ n=3 $ (i.e. number of points is $ 2\cdot3+1=7 $ ) in which we increased the $ y $ -coordinate of the point $ P_1 $ three times and $ y $ -coordinate of the point $ P_5 $ one time:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1036A/04a4a03c886e714b20b2d32a2aa307f64861219c.png)Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).

Let the height of the plot be the maximum $ y $ -coordinate among all initial points in the plot (i.e. points $ P_0, P_1, \dots, P_{2n} $ ). The height of the plot on the picture above is 3.

Your problem is to say which minimum possible height can have the plot consisting of $ 2n+1 $ vertices and having an area equal to $ k $ . Note that it is unnecessary to minimize the number of moves.

It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $ 10^{18} $ .

## 输入格式

The first line of the input contains two integers $ n $ and $ k $ ( $ 1 \le n, k \le 10^{18} $ ) — the number of vertices in a plot of a piecewise function and the area we need to obtain.

## 输出格式

Print one integer — the minimum possible height of a plot consisting of $ 2n+1 $ vertices and with an area equals $ k $ . It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $ 10^{18} $ .

## 说明/提示

One of the possible answers to the first example:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1036A/9b7ffb43d6497943731f35d46eb19664771e1698.png)The area of this plot is 3, the height of this plot is 1.

There is only one possible answer to the second example:

 ![](/predownloaded/87/0e/870ecd0db34c7f6d9c82c27dbd8add2b8f3f537c.png)The area of this plot is 12, the height of this plot is 3.

## 样例 #1

### 输入

```
4 3

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4 12

```

### 输出

```
3

```

## 样例 #3

### 输入

```
999999999999999999 999999999999999986

```

### 输出

```
1

```



---

---
title: "Gambling"
layout: "post"
diff: 普及-
pid: CF1038C
tag: []
---

# Gambling

## 题目描述

### 题目大意：
两个人$A,B$玩游戏，每个人有1个长度为$n$的序列，每次一个人可以从序列中拿一个数并加入自己的分数，或者把对手序列中没选的数中去掉一个，这两个人都足够聪明，求$A$分数与$B$分数的差

## 输入格式

第一行一个整数$n$

第二行$n$个整数，表示A的序列

第三行$n$个整数，表示B的序列

第一行一个整数$n$

第二行$n$个整数，表示A的序列

第三行$n$个整数，表示B的序列

## 输出格式

一个整数，表示$A$分数与$B$分数的差

```
### 题目大意：
两个人$A,B$玩游戏，每个人有1个长度为$n$的序列，每次一个人可以从序列中拿一个数并加入自己的分数，或者把对手序列中没选的数中去掉一个，这两个人都足够聪明，求$A$分数与$B$分数的差

一个整数，表示$A$分数与$B$分数的差
```

## 样例 #1

### 输入

```
2
1 4
5 1

```

### 输出

```
0
```

## 样例 #2

### 输入

```
3
100 100 100
100 100 100

```

### 输出

```
0
```

## 样例 #3

### 输入

```
2
2 1
5 6

```

### 输出

```
-3
```



---

---
title: "Palindrome Dance"
layout: "post"
diff: 普及-
pid: CF1040A
tag: []
---

# Palindrome Dance

## 题目描述

### 题目大意
给你一个序列，里面的元素只能是 $0,1$ 或 $2$，$2$ 可以通过代价换成 $1$ 或者 $0$，问形成**仅包含 $0,1$** 的回文串的最小代价。

## 输入格式

第一行 $3$ 个整数 $n,a,b$，分别代表了序列长度，换成 $0$ 的代价，换成 $1$ 的代价。

第二行 $n$ 个整数，表示序列。

## 输出格式

如果能构成回文串，输出最小代价，否则输出 $-1$。

## 样例 #1

### 输入

```
5 100 1
0 1 2 1 2

```

### 输出

```
101

```

## 样例 #2

### 输入

```
3 10 12
1 2 0

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
3 12 1
0 1 0

```

### 输出

```
0

```



---

---
title: "Elections"
layout: "post"
diff: 普及-
pid: CF1043A
tag: []
---

# Elections

## 题目描述

Awruk is taking part in elections in his school. It is the final round. He has only one opponent — Elodreip. The are $ n $ students in the school. Each student has exactly $ k $ votes and is obligated to use all of them. So Awruk knows that if a person gives $ a_i $ votes for Elodreip, than he will get exactly $ k - a_i $ votes from this person. Of course $ 0 \le k - a_i $ holds.

Awruk knows that if he loses his life is over. He has been speaking a lot with his friends and now he knows $ a_1, a_2, \dots, a_n $ — how many votes for Elodreip each student wants to give. Now he wants to change the number $ k $ to win the elections. Of course he knows that bigger $ k $ means bigger chance that somebody may notice that he has changed something and then he will be disqualified.

So, Awruk knows $ a_1, a_2, \dots, a_n $ — how many votes each student will give to his opponent. Help him select the smallest winning number $ k $ . In order to win, Awruk needs to get strictly more votes than Elodreip.

## 输入格式

The first line contains integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of students in the school.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 100 $ ) — the number of votes each student gives to Elodreip.

## 输出格式

Output the smallest integer $ k $ ( $ k \ge \max a_i $ ) which gives Awruk the victory. In order to win, Awruk needs to get strictly more votes than Elodreip.

## 说明/提示

In the first example, Elodreip gets $ 1 + 1 + 1 + 5 + 1 = 9 $ votes. The smallest possible $ k $ is $ 5 $ (it surely can't be less due to the fourth person), and it leads to $ 4 + 4 + 4 + 0 + 4 = 16 $ votes for Awruk, which is enough to win.

In the second example, Elodreip gets $ 11 $ votes. If $ k = 4 $ , Awruk gets $ 9 $ votes and loses to Elodreip.

## 样例 #1

### 输入

```
5
1 1 1 5 1

```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
2 2 3 2 2

```

### 输出

```
5
```



---

---
title: "Cover Points"
layout: "post"
diff: 普及-
pid: CF1047B
tag: []
---

# Cover Points

## 题目描述

现在有 $n$ 个点在飞机上，分别是 $(x_{1},y_{1}),(x_{2},y_{2}),\ldots,(x_{n},y_{n})$。

你需要在坐标轴上放置一个等腰三角形，以覆盖所有的点（一个点在三角形内或三角形的边上被覆盖），然后计算三角形较短边的最小长度。

## 输入格式

第一行包含一个整数 $n$（$1\leq n\leq 10^{5}$）。

接下来的 $n$ 行包含两个整数 $x_{i}$ 和 $y_{i}$（$1\leq x_{i},y_{i} \leq 10^{9}$）。

## 输出格式

打印三角形的边的最小长度，数据保证它总是一个整数。

## 样例 #1

### 输入

```
3
1 1
1 2
2 1

```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
1 1
1 2
2 1
2 2

```

### 输出

```
4
```



---

---
title: "Blackjack"
layout: "post"
diff: 普及-
pid: CF104A
tag: []
---

# Blackjack

## 题目描述

Blackjack是一个扑克牌游戏。

Blackjack使用除了两张王以外的全部52张卡牌，也就是$2,3,4,5,6,7,8,9,10,J,Q,K,A$。其中规定$2,3,4,5,6,7,8,9,10$的点数为$2,3,4,5,6,7,8,9,10$，$J,Q,K$的点数均为$10$，$A$的点数同时为$1$或$11$，这取决于玩家的意愿。虽然扑克牌有花色，但是一张卡牌的点数与其花色无关。这个游戏的规则很简单：拿两张牌，如果这两张牌的点数之和等于$n$，玩家就赢了，否则玩家就输了。

现在玩家已经拿了一张黑桃$Q$，求在其他牌中再抽一张，能使玩家赢得游戏的方案数。

## 输入格式

一个整数$n(1<=n<=25)$，表示要求的点数。

## 输出格式

一个整数，表示能使玩家赢得游戏的方案数。

## 样例 #1

### 输入

```
12

```

### 输出

```
4
```

## 样例 #2

### 输入

```
20

```

### 输出

```
15
```

## 样例 #3

### 输入

```
10

```

### 输出

```
0
```



---

---
title: "Vasya And Password"
layout: "post"
diff: 普及-
pid: CF1051A
tag: []
---

# Vasya And Password

## 题目描述

Vasya came up with a password to register for EatForces — a string $ s $ . The password in EatForces should be a string, consisting of lowercase and uppercase Latin letters and digits.

But since EatForces takes care of the security of its users, user passwords must contain at least one digit, at least one uppercase Latin letter and at least one lowercase Latin letter. For example, the passwords "abaCABA12", "Z7q" and "3R24m" are valid, and the passwords "qwerty", "qwerty12345" and "Password" are not.

A substring of string $ s $ is a string $ x = s_l s_{l + 1} \dots s_{l + len - 1} (1 \le l \le |s|, 0 \le len \le |s| - l + 1) $ . $ len $ is the length of the substring. Note that the empty string is also considered a substring of $ s $ , it has the length $ 0 $ .

Vasya's password, however, may come too weak for the security settings of EatForces. He likes his password, so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions. This operation should be performed exactly once, and the chosen string should have the minimal possible length.

Note that the length of $ s $ should not change after the replacement of the substring, and the string itself should contain only lowercase and uppercase Latin letters and digits.

## 输入格式

The first line contains a single integer $ T $ ( $ 1 \le T \le 100 $ ) — the number of testcases.

Each of the next $ T $ lines contains the initial password $ s~(3 \le |s| \le 100) $ , consisting of lowercase and uppercase Latin letters and digits.

Only $ T = 1 $ is allowed for hacks.

## 输出格式

For each testcase print a renewed password, which corresponds to given conditions.

The length of the replaced substring is calculated as following: write down all the changed positions. If there are none, then the length is $ 0 $ . Otherwise the length is the difference between the first and the last changed position plus one. For example, the length of the changed substring between the passwords "abcdef" $ \rightarrow $ "a7cdEf" is $ 4 $ , because the changed positions are $ 2 $ and $ 5 $ , thus $ (5 - 2) + 1 = 4 $ .

It is guaranteed that such a password always exists.

If there are several suitable passwords — output any of them.

## 说明/提示

In the first example Vasya's password lacks a digit, he replaces substring "C" with "4" and gets password "abcD4E". That means, he changed the substring of length 1.

In the second example Vasya's password is ok from the beginning, and nothing has to be changed. That is the same as replacing the empty substring with another empty substring (length 0).

## 样例 #1

### 输入

```
2
abcDCE
htQw27

```

### 输出

```
abcD4E
htQw27

```



---

---
title: "Metro"
layout: "post"
diff: 普及-
pid: CF1055A
tag: []
---

# Metro

## 题目描述

Alice今天过生日，所以她邀请了她的好朋友Bob。现在Bob需要找到一种方法前去Alice家。
在Alice和Bob住的城市里，第一条地铁线正在施工中，仍处于试运行阶段。现在的地铁线有n个车站，编号从1至n。Bob住在1号站附近，Alice住在s号站附近。这条地铁线有两条轨道。第一条从1至n行驶，另一条则反之。当一辆车到达终点后，它会直接前去车辆段（停车场），所以Bob不可以坐到头后继续坐在车上。
有一些车站只是部分打开，而某些车站则完全没有打开。Bob取到了他要去拜访Alice时所有车站的开关情况。如果一个车站在某轨道上是关闭的，则列车在经过此车站时，会不加停靠的直接开过去。
在Bob研究了一会时间表后，他发现去参加Alice的Party可能会不一般的困难。请帮助Bob确定他应该坐地铁还是换一种交通方式去拜访Alice。

## 输入格式

第一行： n和s。意义同上。
第二行： n个整数，对应a111,a222,...,annn。即第i个车站在轨道1（从1至n）上的开关情况（0是关，1是开）
第二行： n个整数，对应b111,b222,...,bnnn。即第i个车站在轨道2（从n至1）上的开关情况（0是关，1是开）

## 输出格式

如果Bob可以用地铁达到Alice家，输出```Yes```。否则输出```No```。（大小写爱咋搞咋搞）

## 样例 #1

### 输入

```
5 3
1 1 1 1 1
1 1 1 1 1

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
5 4
1 0 0 0 1
0 1 1 1 1

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
5 2
0 1 1 1 1
1 1 1 1 1

```

### 输出

```
NO

```



---

---
title: "Transmigration"
layout: "post"
diff: 普及-
pid: CF105A
tag: []
---

# Transmigration

## 题目描述

In Disgaea as in most role-playing games, characters have skills that determine the character's ability to use certain weapons or spells. If the character does not have the necessary skill, he cannot use it. The skill level is represented as an integer that increases when you use this skill. Different character classes are characterized by different skills.

Unfortunately, the skills that are uncommon for the given character's class are quite difficult to obtain. To avoid this limitation, there is the so-called transmigration.

Transmigration is reincarnation of the character in a new creature. His soul shifts to a new body and retains part of his experience from the previous life.

As a result of transmigration the new character gets all the skills of the old character and the skill levels are reduced according to the $ k $ coefficient (if the skill level was equal to $ x $ , then after transmigration it becomes equal to $ [kx] $ , where $ [y] $ is the integral part of $ y $ ). If some skill's levels are strictly less than $ 100 $ , these skills are forgotten (the character does not have them any more). After that the new character also gains the skills that are specific for his class, but are new to him. The levels of those additional skills are set to $ 0 $ .

Thus, one can create a character with skills specific for completely different character classes via transmigrations. For example, creating a mage archer or a thief warrior is possible.

You are suggested to solve the following problem: what skills will the character have after transmigration and what will the levels of those skills be?

## 输入格式

The first line contains three numbers $ n $ , $ m $ and $ k $ — the number of skills the current character has, the number of skills specific for the class into which the character is going to transmigrate and the reducing coefficient respectively; $ n $ and $ m $ are integers, and $ k $ is a real number with exactly two digits after decimal point ( $ 1<=n,m<=20 $ , $ 0.01<=k<=0.99 $ ).

Then follow $ n $ lines, each of which describes a character's skill in the form " $ name $ $ exp $ " — the skill's name and the character's skill level: $ name $ is a string and $ exp $ is an integer in range from $ 0 $ to $ 9999 $ , inclusive.

Then follow $ m $ lines each of which contains names of skills specific for the class, into which the character transmigrates.

All names consist of lowercase Latin letters and their lengths can range from $ 1 $ to $ 20 $ characters, inclusive. All character's skills have distinct names. Besides the skills specific for the class into which the player transmigrates also have distinct names.

## 输出格式

Print on the first line number $ z $ — the number of skills the character will have after the transmigration. Then print $ z $ lines, on each of which print a skill's name and level, separated by a single space. The skills should be given in the lexicographical order.

## 样例 #1

### 输入

```
5 4 0.75
axe 350
impaler 300
ionize 80
megafire 120
magicboost 220
heal
megafire
shield
magicboost

```

### 输出

```
6
axe 262
heal 0
impaler 225
magicboost 165
megafire 0
shield 0

```



---

---
title: "Phone Numbers"
layout: "post"
diff: 普及-
pid: CF1060A
tag: []
---

# Phone Numbers

## 题目描述

Let's call a string a phone number if it has length 11 and fits the pattern "8xxxxxxxxxx", where each "x" is replaced by a digit.

For example, "80123456789" and "80000000000" are phone numbers, while "8012345678" and "79000000000" are not.

You have $ n $ cards with digits, and you want to use them to make as many phone numbers as possible. Each card must be used in at most one phone number, and you don't have to use all cards. The phone numbers do not necessarily have to be distinct.

## 输入格式

The first line contains an integer $ n $ — the number of cards with digits that you have ( $ 1 \leq n \leq 100 $ ).

The second line contains a string of $ n $ digits (characters "0", "1", ..., "9") $ s_1, s_2, \ldots, s_n $ . The string will not contain any other characters, such as leading or trailing spaces.

## 输出格式

If at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.

## 说明/提示

In the first example, one phone number, "8000000000", can be made from these cards.

In the second example, you can make two phone numbers from the cards, for example, "80123456789" and "80123456789".

In the third example you can't make any phone number from the given cards.

## 样例 #1

### 输入

```
11
00000000008

```

### 输出

```
1

```

## 样例 #2

### 输入

```
22
0011223344556677889988

```

### 输出

```
2

```

## 样例 #3

### 输入

```
11
31415926535

```

### 输出

```
0

```



---

---
title: "Maximum Sum of Digits"
layout: "post"
diff: 普及-
pid: CF1060B
tag: []
---

# Maximum Sum of Digits

## 题目描述

You are given a positive integer $ n $ .

Let $ S(x) $ be sum of digits in base 10 representation of $ x $ , for example, $ S(123) = 1 + 2 + 3 = 6 $ , $ S(0) = 0 $ .

Your task is to find two integers $ a, b $ , such that $ 0 \leq a, b \leq n $ , $ a + b = n $ and $ S(a) + S(b) $ is the largest possible among all such pairs.

## 输入格式

The only line of input contains an integer $ n $ $ (1 \leq n \leq 10^{12}) $ .

## 输出格式

Print largest $ S(a) + S(b) $ among all pairs of integers $ a, b $ , such that $ 0 \leq a, b \leq n $ and $ a + b = n $ .

## 说明/提示

In the first example, you can choose, for example, $ a = 17 $ and $ b = 18 $ , so that $ S(17) + S(18) = 1 + 7 + 1 + 8 = 17 $ . It can be shown that it is impossible to get a larger answer.

In the second test example, you can choose, for example, $ a = 5000000001 $ and $ b = 4999999999 $ , with $ S(5000000001) + S(4999999999) = 91 $ . It can be shown that it is impossible to get a larger answer.

## 样例 #1

### 输入

```
35

```

### 输出

```
17

```

## 样例 #2

### 输入

```
10000000000

```

### 输出

```
91

```



---

---
title: "Coins"
layout: "post"
diff: 普及-
pid: CF1061A
tag: []
---

# Coins

## 题目描述

You have unlimited number of coins with values $ 1, 2, \ldots, n $ . You want to select some set of coins having the total value of $ S $ .

It is allowed to have multiple coins with the same value in the set. What is the minimum number of coins required to get sum $ S $ ?

## 输入格式

The only line of the input contains two integers $ n $ and $ S $ ( $ 1 \le n \le 100\,000 $ , $ 1 \le S \le 10^9 $ )

## 输出格式

Print exactly one integer — the minimum number of coins required to obtain sum $ S $ .

## 说明/提示

In the first example, some of the possible ways to get sum $ 11 $ with $ 3 $ coins are:

- $ (3, 4, 4) $
- $ (2, 4, 5) $
- $ (1, 5, 5) $
- $ (3, 3, 5) $

It is impossible to get sum $ 11 $ with less than $ 3 $ coins.

In the second example, some of the possible ways to get sum $ 16 $ with $ 3 $ coins are:

- $ (5, 5, 6) $
- $ (4, 6, 6) $

It is impossible to get sum $ 16 $ with less than $ 3 $ coins.

## 样例 #1

### 输入

```
5 11

```

### 输出

```
3
```

## 样例 #2

### 输入

```
6 16

```

### 输出

```
3
```



---

---
title: "A Prank"
layout: "post"
diff: 普及-
pid: CF1062A
tag: []
---

# A Prank

## 题目描述

JATC and his friend Giraffe are currently in their room, solving some problems. Giraffe has written on the board an array $ a_1 $ , $ a_2 $ , ..., $ a_n $ of integers, such that $ 1 \le a_1 < a_2 < \ldots < a_n \le 10^3 $ , and then went to the bathroom.

JATC decided to prank his friend by erasing some consecutive elements in the array. Since he doesn't want for the prank to go too far, he will only erase in a way, such that Giraffe can still restore the array using the information from the remaining elements. Because Giraffe has created the array, he's also aware that it's an increasing array and all the elements are integers in the range $ [1, 10^3] $ .

JATC wonders what is the greatest number of elements he can erase?

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of elements in the array.

The second line of the input contains $ n $ integers $ a_i $ ( $ 1 \le a_1<a_2<\dots<a_n \le 10^3 $ ) — the array written by Giraffe.

## 输出格式

Print a single integer — the maximum number of consecutive elements in the array that JATC can erase.

If it is impossible to erase even a single element, print $ 0 $ .

## 说明/提示

In the first example, JATC can erase the third and fourth elements, leaving the array $ [1, 3, \_, \_, 6, 9] $ . As you can see, there is only one way to fill in the blanks.

In the second example, JATC can erase the second and the third elements. The array will become $ [998, \_, \_] $ . Because all the elements are less than or equal to $ 1000 $ , the array is still can be restored. Note, that he can't erase the first $ 2 $ elements.

In the third example, JATC can erase the first $ 4 $ elements. Since all the elements are greater than or equal to $ 1 $ , Giraffe can still restore the array. Note, that he can't erase the last $ 4 $ elements.

## 样例 #1

### 输入

```
6
1 3 4 5 6 9

```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
998 999 1000

```

### 输出

```
2
```

## 样例 #3

### 输入

```
5
1 2 3 4 5

```

### 输出

```
4
```



---

---
title: "Make a triangle!"
layout: "post"
diff: 普及-
pid: CF1064A
tag: []
---

# Make a triangle!

## 题目描述

Masha有三根长度分别为a,b,c厘米的小棒。每一分钟，Masha可以选择一根小棒并将它的长度增加一厘米，但他不可以折断小棒。
现在他要你求出他最少需要多少时间使得这三根小棒可以构成一个三角形。

## 输入格式

三个数，分别为a,b,c

## 输出格式

一个数，为Masha最少需要的时间

## 样例 #1

### 输入

```
3 4 5

```

### 输出

```
0

```

## 样例 #2

### 输入

```
2 5 3

```

### 输出

```
1

```

## 样例 #3

### 输入

```
100 10 10

```

### 输出

```
81

```



---

---
title: "Vova and Train"
layout: "post"
diff: 普及-
pid: CF1066A
tag: []
---

# Vova and Train

## 题目描述

## 题意描述：

$Vova$先生要乘火车去旅行，火车一开始位于$1$点，以每秒1个单位的速度向前行驶，最终到达$L$处。（也就是说，火车在第$1min$时在$1$处,在$2min$时在2处）

铁路沿线挂着一些灯笼，这些灯笼的位于坐标是$v$的倍数的地方，第一个灯笼位于$v$处

同时，有另一列火车停在另一侧的轨道上，这列火车的左右端点位于$l$和$r$处

当$Vova$先生经过一个地点，这个地点既有灯笼，又没有被另一列火车挡住时，我们称$Vova$先生可以看到灯笼，现在，我们需要你求出一路上$Vova$先生能看到几盏灯笼。本题有多组数据。

## 输入格式

第一行：一个整数$t(1≤t≤10^4$)，表示数据组数

下面$t$行，每行4个整数$L_i$，$v_i$，$l_i$，$r_i$,$(1≤L,v≤10^9,1≤l≤r≤L)$,各个字母的含义上文已经给出

## 输出格式

$t$行，每$1$个整数，表示$Vova$先生能看到的灯笼数

## 样例 #1

### 输入

```
4
10 2 3 7
100 51 51 51
1234 1 100 199
1000000000 1 1 1000000000

```

### 输出

```
3
0
1134
0

```



---

---
title: "LCM"
layout: "post"
diff: 普及-
pid: CF1068B
tag: []
---

# LCM

## 题目描述

Ivan has number $ b $ . He is sorting through the numbers $ a $ from $ 1 $ to $ 10^{18} $ , and for every $ a $ writes $ \frac{[a, \,\, b]}{a} $ on blackboard. Here $ [a, \,\, b] $ stands for least common multiple of $ a $ and $ b $ . Ivan is very lazy, that's why this task bored him soon. But he is interested in how many different numbers he would write on the board if he would finish the task. Help him to find the quantity of different numbers he would write on the board.

## 输入格式

The only line contains one integer — $ b $ $ (1 \le b \le 10^{10}) $ .

## 输出格式

Print one number — answer for the problem.

## 说明/提示

In the first example $ [a, \,\, 1] = a $ , therefore $ \frac{[a, \,\, b]}{a} $ is always equal to $ 1 $ .

In the second example $ [a, \,\, 2] $ can be equal to $ a $ or $ 2 \cdot a $ depending on parity of $ a $ . $ \frac{[a, \,\, b]}{a} $ can be equal to $ 1 $ and $ 2 $ .

## 样例 #1

### 输入

```
1

```

### 输出

```
1
```

## 样例 #2

### 输入

```
2

```

### 输出

```
2
```



---

---
title: "Card Game"
layout: "post"
diff: 普及-
pid: CF106A
tag: []
---

# Card Game

## 题目描述

一种纸牌游戏。
有许多张卡牌，每张卡牌有一个套装（“S”，“H”，“D”和“C”）和一个等级（按升序排列“6”，“7”，“8”，“9”，“T”， “J”，“Q”，“K”和“A”）
**规则：**
以下情况卡牌A才能赢卡牌B:
1、A有王牌套装，B没有
2、A和B的套装相同，但A的等级比B高
否则B赢

## 输入格式

第一行 一个字母（代表王牌套装）
第二行 卡牌A 卡牌B

## 输出格式

卡牌A能赢卡牌B输出"YES"，否则输出"NO".

## 样例 #1

### 输入

```
H
QH 9S

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
S
8D 6D

```

### 输出

```
YES
```

## 样例 #3

### 输入

```
C
7H AS

```

### 输出

```
NO
```



---

---
title: "Choosing Laptop"
layout: "post"
diff: 普及-
pid: CF106B
tag: []
---

# Choosing Laptop

## 题目描述

Vasya想购买一台笔记本电脑。商场提供了n台电脑给顾客体验。
Vasya只对以下三个电脑指标比较感兴趣：CPU速度，内存和硬盘。因为Vasya是一个程序员而不是游戏玩家，因此他对其他指标并不感兴趣。
如果一台电脑的三个指标都小于另一台电脑，那么Vasya认为这台电脑是过时的。Vasya不考虑那些过时的电脑，他会在其他（不过时）电脑中选择一台最便宜的。

## 输入格式

第一行是一个整数n ( 1<=n<=100 1<=n<=100 ).
以下n行中每一行包括四个整数，分别是电脑的speed（cpu速度）、ram（内存大小）、hdd（硬盘容量）和cost（价格）。

1000<=speed<=4200 

256<=ram<=4096 

1<=hdd<=500 

100<=cost<=1000 

所有的电脑有不同的价格。

## 输出格式

输出一个整数，即Vasya选择电脑的序号（范围在1-n之间）。

输入输出样例

## 说明/提示

第一和第五台电脑是过时的，因为它们的三个指标都小于第三台。剩下的电脑中第四台最便宜，因此，输出是4。

## 样例 #1

### 输入

```
5
2100 512 150 200
2000 2048 240 350
2300 1024 200 320
2500 2048 80 300
2000 512 180 150

```

### 输出

```
4
```



---

---
title: "Garbage Disposal"
layout: "post"
diff: 普及-
pid: CF1070D
tag: []
---

# Garbage Disposal

## 题目描述

Enough is enough. Too many times it happened that Vasya forgot to dispose of garbage and his apartment stank afterwards. Now he wants to create a garbage disposal plan and stick to it.

For each of next $ n $ days Vasya knows $ a_i $ — number of units of garbage he will produce on the $ i $ -th day. Each unit of garbage must be disposed of either on the day it was produced or on the next day. Vasya disposes of garbage by putting it inside a bag and dropping the bag into a garbage container. Each bag can contain up to $ k $ units of garbage. It is allowed to compose and drop multiple bags into a garbage container in a single day.

Being economical, Vasya wants to use as few bags as possible. You are to compute the minimum number of bags Vasya needs to dispose of all of his garbage for the given $ n $ days. No garbage should be left after the $ n $ -th day.

## 输入格式

The first line of the input contains two integers $ n $ and $ k $ ( $ 1 \le n \le 2\cdot10^5, 1 \le k \le 10^9 $ ) — number of days to consider and bag's capacity. The second line contains $ n $ space separated integers $ a_i $ ( $ 0 \le a_i \le 10^9 $ ) — the number of units of garbage produced on the $ i $ -th day.

## 输出格式

Output a single integer — the minimum number of bags Vasya needs to dispose of all garbage. Each unit of garbage should be disposed on the day it was produced or on the next day. No garbage can be left after the $ n $ -th day. In a day it is allowed to compose and drop multiple bags.

## 样例 #1

### 输入

```
3 2
3 2 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
5 1
1000000000 1000000000 1000000000 1000000000 1000000000

```

### 输出

```
5000000000

```

## 样例 #3

### 输入

```
3 2
1 0 1

```

### 输出

```
2

```

## 样例 #4

### 输入

```
4 4
2 8 4 1

```

### 输出

```
4

```



---

---
title: "Video Posts"
layout: "post"
diff: 普及-
pid: CF1070K
tag: []
---

# Video Posts

## 题目描述

Polycarp took $ n $ videos, the duration of the $ i $ -th video is $ a_i $ seconds. The videos are listed in the chronological order, i.e. the $ 1 $ -st video is the earliest, the $ 2 $ -nd video is the next, ..., the $ n $ -th video is the last.

Now Polycarp wants to publish exactly $ k $ ( $ 1 \le k \le n $ ) posts in Instabram. Each video should be a part of a single post. The posts should preserve the chronological order, it means that the first post should contain one or more of the earliest videos, the second post should contain a block (one or more videos) going next and so on. In other words, if the number of videos in the $ j $ -th post is $ s_j $ then:

- $ s_1+s_2+\dots+s_k=n $ ( $ s_i>0 $ ),
- the first post contains the videos: $ 1, 2, \dots, s_1 $ ;
- the second post contains the videos: $ s_1+1, s_1+2, \dots, s_1+s_2 $ ;
- the third post contains the videos: $ s_1+s_2+1, s_1+s_2+2, \dots, s_1+s_2+s_3 $ ;
- ...
- the $ k $ -th post contains videos: $ n-s_k+1,n-s_k+2,\dots,n $ .

Polycarp is a perfectionist, he wants the total duration of videos in each post to be the same.

Help Polycarp to find such positive integer values $ s_1, s_2, \dots, s_k $ that satisfy all the conditions above.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 10^5 $ ). The next line contains $ n $ positive integer numbers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^4 $ ), where $ a_i $ is the duration of the $ i $ -th video.

## 输出格式

If solution exists, print "Yes" in the first line. Print $ k $ positive integers $ s_1, s_2, \dots, s_k $ ( $ s_1+s_2+\dots+s_k=n $ ) in the second line. The total duration of videos in each post should be the same. It can be easily proven that the answer is unique (if it exists).

If there is no solution, print a single line "No".

## 样例 #1

### 输入

```
6 3
3 3 1 4 1 6

```

### 输出

```
Yes
2 3 1 
```

## 样例 #2

### 输入

```
3 3
1 1 1

```

### 输出

```
Yes
1 1 1 
```

## 样例 #3

### 输入

```
3 3
1 1 2

```

### 输出

```
No
```

## 样例 #4

### 输入

```
3 1
1 10 100

```

### 输出

```
Yes
3 
```



---

---
title: "Minimizing the String"
layout: "post"
diff: 普及-
pid: CF1076A
tag: []
---

# Minimizing the String

## 题目描述

You are given a string $ s $ consisting of $ n $ lowercase Latin letters.

You have to remove at most one (i.e. zero or one) character of this string in such a way that the string you obtain will be lexicographically smallest among all strings that can be obtained using this operation.

String $ s = s_1 s_2 \dots s_n $ is lexicographically smaller than string $ t = t_1 t_2 \dots t_m $ if $ n < m $ and $ s_1 = t_1, s_2 = t_2, \dots, s_n = t_n $ or there exists a number $ p $ such that $ p \le n $ and $ s_1 = t_1, s_2 = t_2, \dots, s_{p-1} = t_{p-1} $ and $ s_p < t_p $ .

For example, "aaa" is smaller than "aaaa", "abb" is smaller than "abc", "pqr" is smaller than "z".

## 输入格式

The first line of the input contains one integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ) — the length of $ s $ .

The second line of the input contains exactly $ n $ lowercase Latin letters — the string $ s $ .

## 输出格式

Print one string — the smallest possible lexicographically string that can be obtained by removing at most one character from the string $ s $ .

## 说明/提示

In the first example you can remove any character of $ s $ to obtain the string "aa".

In the second example "abca" < "abcd" < "abcda" < "abda" < "acda" < "bcda".

## 样例 #1

### 输入

```
3
aaa

```

### 输出

```
aa

```

## 样例 #2

### 输入

```
5
abcda

```

### 输出

```
abca

```



---

---
title: "Frog Jumping"
layout: "post"
diff: 普及-
pid: CF1077A
tag: []
---

# Frog Jumping

## 题目描述

对于给定的$a,b,k$，初始状态$x=0$，第$i$次操作满足以下规则：  
- $i$为奇数，$x=x+a$  
- $i$为偶数，$x=x-b$  

求$k$次操作后$x$的值

## 输入格式

**题目有多组数据**  
第一行一个整数$t(1\leq t\leq1000)$表示数据组数   
接下来$t$行，每行三个整数$a,b,k(1\leq a,b,k\leq10^9)$表示每组数据

## 输出格式

输出共$t$行，第$i$行表示第$i$组数据的答案

## 样例 #1

### 输入

```
6
5 2 3
100 1 4
1 10 5
1000000000 1 6
1 1 1000000000
1 1 999999999

```

### 输出

```
8
198
-17
2999999997
0
1

```



---

---
title: "Petya and Origami"
layout: "post"
diff: 普及-
pid: CF1080A
tag: []
---

# Petya and Origami

## 题目描述

Petya 将要举行一场派对，她要发送大量的邀请函给朋友们。

每一张邀请函需要耗费 2 张红色纸，5 张绿色纸和 8 张蓝色纸。

然而，商店里卖纸是一堆一堆卖的，每一堆有 $k$ 张且只含有红，绿，蓝三种颜色之一的纸，Petya 可以选择买哪种颜色的一堆纸。

现在 Petya 要给 $n$ 名朋友发送邀请函，请问她至少要到商店买几堆纸。

## 输入格式

第一行包含两个整数 $n$ , $k$，意义如上文所述。

## 输出格式

一行一个整数，表示 Petya 至少要买几堆纸。

## 说明/提示

$1 \leq n,k \leq 10^8$

## 样例 #1

### 输入

```
3 5

```

### 输出

```
10

```

## 样例 #2

### 输入

```
15 6

```

### 输出

```
38

```



---

---
title: "Vasya and Book"
layout: "post"
diff: 普及-
pid: CF1082A
tag: []
---

# Vasya and Book

## 题目描述

Vasya有一本 $n$ 页的电子书，她每次可以向前或向后翻 $d$ 页（但她不能翻到书外面去）。现在她要从第 $x$ 页翻到第 $y$ 页，求她最少翻的次数。

## 输入格式

输入第一行一个整数 $t$ $(1\le t\le 10^3)$ 表示数据组数。

接下来 $t$ 行，每行 $4$ 个正整数 $n,x,y,d$ .$(1\le n,d \le 10^9,1\le x,y\le n)$.

## 输出格式

输出一个整数表示最少翻页次数，如果翻不到则输出 $-1$.

## 样例 #1

### 输入

```
3
10 4 5 2
5 1 3 4
20 4 19 3

```

### 输出

```
4
-1
5

```



---

---
title: "The Fair Nut and Elevator"
layout: "post"
diff: 普及-
pid: CF1084A
tag: []
---

# The Fair Nut and Elevator

## 题目描述

The Fair Nut lives in $ n $ story house. $ a_i $ people live on the $ i $ -th floor of the house. Every person uses elevator twice a day: to get from the floor where he/she lives to the ground (first) floor and to get from the first floor to the floor where he/she lives, when he/she comes back home in the evening.

It was decided that elevator, when it is not used, will stay on the $ x $ -th floor, but $ x $ hasn't been chosen yet. When a person needs to get from floor $ a $ to floor $ b $ , elevator follows the simple algorithm:

- Moves from the $ x $ -th floor (initially it stays on the $ x $ -th floor) to the $ a $ -th and takes the passenger.
- Moves from the $ a $ -th floor to the $ b $ -th floor and lets out the passenger (if $ a $ equals $ b $ , elevator just opens and closes the doors, but still comes to the floor from the $ x $ -th floor).
- Moves from the $ b $ -th floor back to the $ x $ -th.

 The elevator never transposes more than one person and always goes back to the floor $ x $ before transposing a next passenger. The elevator spends one unit of electricity to move between neighboring floors. So moving from the $ a $ -th floor to the $ b $ -th floor requires $ |a - b| $ units of electricity.Your task is to help Nut to find the minimum number of electricity units, that it would be enough for one day, by choosing an optimal the $ x $ -th floor. Don't forget than elevator initially stays on the $ x $ -th floor.

## 输入格式

The first line contains one integer $ n $ ( $ 1 \leq n \leq 100 $ ) — the number of floors.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \leq a_i \leq 100 $ ) — the number of people on each floor.

## 输出格式

In a single line, print the answer to the problem — the minimum number of electricity units.

## 说明/提示

In the first example, the answer can be achieved by choosing the second floor as the $ x $ -th floor. Each person from the second floor (there are two of them) would spend $ 4 $ units of electricity per day ( $ 2 $ to get down and $ 2 $ to get up), and one person from the third would spend $ 8 $ units of electricity per day ( $ 4 $ to get down and $ 4 $ to get up). $ 4 \cdot 2 + 8 \cdot 1 = 16 $ .

In the second example, the answer can be achieved by choosing the first floor as the $ x $ -th floor.

## 样例 #1

### 输入

```
3
0 2 1

```

### 输出

```
16
```

## 样例 #2

### 输入

```
2
1 1

```

### 输出

```
4
```



---

---
title: "Kvass and the Fair Nut"
layout: "post"
diff: 普及-
pid: CF1084B
tag: []
---

# Kvass and the Fair Nut

## 题目描述

The Fair Nut likes kvass very much. On his birthday parents presented him $ n $ kegs of kvass. There are $ v_i $ liters of kvass in the $ i $ -th keg. Each keg has a lever. You can pour your glass by exactly $ 1 $ liter pulling this lever. The Fair Nut likes this drink very much, so he wants to pour his glass by $ s $ liters of kvass. But he wants to do it, so kvass level in the least keg is as much as possible.

Help him find out how much kvass can be in the least keg or define it's not possible to pour his glass by $ s $ liters of kvass.

## 输入格式

The first line contains two integers $ n $ and $ s $ ( $ 1 \le n \le 10^3 $ , $ 1 \le s \le 10^{12} $ ) — the number of kegs and glass volume.

The second line contains $ n $ integers $ v_1, v_2, \ldots, v_n $ ( $ 1 \le v_i \le 10^9 $ ) — the volume of $ i $ -th keg.

## 输出格式

If the Fair Nut cannot pour his glass by $ s $ liters of kvass, print $ -1 $ . Otherwise, print a single integer — how much kvass in the least keg can be.

## 说明/提示

In the first example, the answer is $ 3 $ , the Fair Nut can take $ 1 $ liter from the first keg and $ 2 $ liters from the third keg. There are $ 3 $ liters of kvass in each keg.

In the second example, the answer is $ 2 $ , the Fair Nut can take $ 3 $ liters from the first keg and $ 1 $ liter from the second keg.

In the third example, the Fair Nut can't pour his cup by $ 7 $ liters, so the answer is $ -1 $ .

## 样例 #1

### 输入

```
3 3
4 3 5

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3 4
5 3 4

```

### 输出

```
2

```

## 样例 #3

### 输入

```
3 7
1 2 3

```

### 输出

```
-1

```



---

---
title: "Palindromic Times"
layout: "post"
diff: 普及-
pid: CF108A
tag: []
---

# Palindromic Times

## 题目描述

Tattah is asleep if and only if Tattah is attending a lecture. This is a well-known formula among Tattah's colleagues.

On a Wednesday afternoon, Tattah was attending Professor HH's lecture. At 12:21, right before falling asleep, he was staring at the digital watch around Saher's wrist. He noticed that the digits on the clock were the same when read from both directions i.e. a palindrome.

In his sleep, he started dreaming about such rare moments of the day when the time displayed on a digital clock is a palindrome. As soon as he woke up, he felt destined to write a program that finds the next such moment.

However, he still hasn't mastered the skill of programming while sleeping, so your task is to help him.

## 输入格式

The first and only line of the input starts with a string with the format "HH:MM" where "HH" is from "00" to "23" and "MM" is from "00" to "59". Both "HH" and "MM" have exactly two digits.

## 输出格式

Print the palindromic time of day that comes soonest after the time given in the input. If the input time is palindromic, output the soonest palindromic time after the input time.

## 样例 #1

### 输入

```
12:21

```

### 输出

```
13:31

```

## 样例 #2

### 输入

```
23:59

```

### 输出

```
00:00

```



---

---
title: "The Pleasant Walk"
layout: "post"
diff: 普及-
pid: CF1090M
tag: []
---

# The Pleasant Walk

## 题目描述

There are $ n $ houses along the road where Anya lives, each one is painted in one of $ k $ possible colors.

Anya likes walking along this road, but she doesn't like when two adjacent houses at the road have the same color. She wants to select a long segment of the road such that no two adjacent houses have the same color.

Help Anya find the longest segment with this property.

## 输入格式

The first line contains two integers $ n $ and $ k $ — the number of houses and the number of colors ( $ 1 \le n \le 100\,000 $ , $ 1 \le k \le 100\,000 $ ).

The next line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ — the colors of the houses along the road ( $ 1 \le a_i \le k $ ).

## 输出格式

Output a single integer — the maximum number of houses on the road segment having no two adjacent houses of the same color.

## 说明/提示

In the example, the longest segment without neighboring houses of the same color is from the house 4 to the house 7. The colors of the houses are $ [3, 2, 1, 2] $ and its length is 4 houses.

## 样例 #1

### 输入

```
8 3
1 2 3 3 2 1 2 2

```

### 输出

```
4

```



---

---
title: "Uniform String"
layout: "post"
diff: 普及-
pid: CF1092A
tag: []
---

# Uniform String

## 题目描述

```plain

给你两个数, $n$,$k$

你的任务是构造一个长度为$n$的字符串 $S$, 使得英文字母表中前 $k$ 个字符在字符串中出现至少一次,并且不出现其他字母,你需要最大化出现次数最小的字母的出现次数.

你要回答 $t$ 组询问,询问之间独立.


给你两个数, $n$,$k$

你的任务是构造一个长度为$n$的字符串 $S$, 使得英文字母表中前 $k$ 个字符在字符串中出现至少一次,并且不出现其他字母,你需要最大化出现次数最小的字母的出现次数.

你要回答 $t$ 组询问,询问之间独立.

## 输入格式

第一行一个数 $T$

接下来 $T$ 行, 每行两个数 $n$,$k$.


第一行一个数 $T$

接下来 $T$ 行, 每行两个数 $n$,$k$.

## 输出格式

$T$ 行,第 $i$ 行输出询问 $i$ 的结果,**若有多解则任意输出**.
```


$T$ 行,第 $i$ 行输出询问 $i$ 的结果,**若有多解则任意输出**.

## 样例 #1

### 输入

```
3
7 3
4 4
6 2

```

### 输出

```
cbcacab
abcd
baabab

```



---

---
title: "Teams Forming"
layout: "post"
diff: 普及-
pid: CF1092B
tag: []
---

# Teams Forming

## 题目描述

There are $ n $ students in a university. The number of students is even. The $ i $ -th student has programming skill equal to $ a_i $ .

The coach wants to form $ \frac{n}{2} $ teams. Each team should consist of exactly two students, and each student should belong to exactly one team. Two students can form a team only if their skills are equal (otherwise they cannot understand each other and cannot form a team).

Students can solve problems to increase their skill. One solved problem increases the skill by one.

The coach wants to know the minimum total number of problems students should solve to form exactly $ \frac{n}{2} $ teams (i.e. each pair of students should form a team). Your task is to find this number.

## 输入格式

The first line of the input contains one integer $ n $ ( $ 2 \le n \le 100 $ ) — the number of students. It is guaranteed that $ n $ is even.

The second line of the input contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 100 $ ), where $ a_i $ is the skill of the $ i $ -th student.

## 输出格式

Print one number — the minimum total number of problems students should solve to form exactly $ \frac{n}{2} $ teams.

## 说明/提示

In the first example the optimal teams will be: $ (3, 4) $ , $ (1, 6) $ and $ (2, 5) $ , where numbers in brackets are indices of students. Then, to form the first team the third student should solve $ 1 $ problem, to form the second team nobody needs to solve problems and to form the third team the second student should solve $ 4 $ problems so the answer is $ 1 + 4 = 5 $ .

In the second example the first student should solve $ 99 $ problems to form a team with the second one.

## 样例 #1

### 输入

```
6
5 10 2 3 14 5

```

### 输出

```
5

```

## 样例 #2

### 输入

```
2
1 100

```

### 输出

```
99

```



---

---
title: "Letters Rearranging"
layout: "post"
diff: 普及-
pid: CF1093B
tag: []
---

# Letters Rearranging

## 题目描述

You are given a string $ s $ consisting only of lowercase Latin letters.

You can rearrange all letters of this string as you wish. Your task is to obtain a good string by rearranging the letters of the given string or report that it is impossible to do it.

Let's call a string good if it is not a palindrome. Palindrome is a string which is read from left to right the same as from right to left. For example, strings "abacaba", "aa" and "z" are palindromes and strings "bba", "xd" are not.

You have to answer $ t $ independent queries.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — number of queries.

Each of the next $ t $ lines contains one string. The $ i $ -th line contains a string $ s_i $ consisting only of lowercase Latin letter. It is guaranteed that the length of $ s_i $ is from $ 1 $ to $ 1000 $  (inclusive).

## 输出格式

Print $ t $ lines. In the $ i $ -th line print the answer to the $ i $ -th query: -1 if it is impossible to obtain a good string by rearranging the letters of $ s_i $ and any good string which can be obtained from the given one (by rearranging the letters) otherwise.

## 说明/提示

In the first query we cannot rearrange letters to obtain a good string.

Other examples (not all) of correct answers to the second query: "ababaca", "abcabaa", "baacaba".

In the third query we can do nothing to obtain a good string.

## 样例 #1

### 输入

```
3
aa
abacaba
xdd

```

### 输出

```
-1
abaacba
xdd
```



---

---
title: "Array Stabilization"
layout: "post"
diff: 普及-
pid: CF1095B
tag: []
---

# Array Stabilization

## 题目描述

You are given an array $ a $ consisting of $ n $ integer numbers.

Let instability of the array be the following value: $ \max\limits_{i = 1}^{n} a_i - \min\limits_{i = 1}^{n} a_i $ .

You have to remove exactly one element from this array to minimize instability of the resulting $ (n-1) $ -elements array. Your task is to calculate the minimum possible instability.

## 输入格式

The first line of the input contains one integer $ n $ ( $ 2 \le n \le 10^5 $ ) — the number of elements in the array $ a $ .

The second line of the input contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^5 $ ) — elements of the array $ a $ .

## 输出格式

Print one integer — the minimum possible instability of the array if you have to remove exactly one element from the array $ a $ .

## 说明/提示

In the first example you can remove $ 7 $ then instability of the remaining array will be $ 3 - 1 = 2 $ .

In the second example you can remove either $ 1 $ or $ 100000 $ then instability of the remaining array will be $ 100000 - 100000 = 0 $ and $ 1 - 1 = 0 $ correspondingly.

## 样例 #1

### 输入

```
4
1 3 3 7

```

### 输出

```
2

```

## 样例 #2

### 输入

```
2
1 100000

```

### 输出

```
0

```



---

---
title: "Snowball"
layout: "post"
diff: 普及-
pid: CF1099A
tag: []
---

# Snowball

## 题目描述

Today's morning was exceptionally snowy. Meshanya decided to go outside and noticed a huge snowball rolling down the mountain! Luckily, there are two stones on that mountain.

Initially, snowball is at height $ h $ and it has weight $ w $ . Each second the following sequence of events happens: snowball's weights increases by $ i $ , where $ i $ — is the current height of snowball, then snowball hits the stone (if it's present at the current height), then snowball moves one meter down. If the snowball reaches height zero, it stops.

There are exactly two stones on the mountain. First stone has weight $ u_1 $ and is located at height $ d_1 $ , the second one — $ u_2 $ and $ d_2 $ respectively. When the snowball hits either of two stones, it loses weight equal to the weight of that stone. If after this snowball has negative weight, then its weight becomes zero, but the snowball continues moving as before.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1099A/f7b26ae9a77b6104710900b83e2e840423f8f72b.png)Find the weight of the snowball when it stops moving, that is, it reaches height 0.

## 输入格式

First line contains two integers $ w $ and $ h $ — initial weight and height of the snowball ( $ 0 \le w \le 100 $ ; $ 1 \le h \le 100 $ ).

Second line contains two integers $ u_1 $ and $ d_1 $ — weight and height of the first stone ( $ 0 \le u_1 \le 100 $ ; $ 1 \le d_1 \le h $ ).

Third line contains two integers $ u_2 $ and $ d_2 $ — weight and heigth of the second stone ( $ 0 \le u_2 \le 100 $ ; $ 1 \le d_2 \le h $ ; $ d_1 \ne d_2 $ ). Notice that stones always have different heights.

## 输出格式

Output a single integer — final weight of the snowball after it reaches height 0.

## 说明/提示

In the first example, initially a snowball of weight 4 is located at a height of 3, there are two stones of weight 1, at a height of 1 and 2, respectively. The following events occur sequentially:

- The weight of the snowball increases by 3 (current height), becomes equal to 7.
- The snowball moves one meter down, the current height becomes equal to 2.
- The weight of the snowball increases by 2 (current height), becomes equal to 9.
- The snowball hits the stone, its weight decreases by 1 (the weight of the stone), becomes equal to 8.
- The snowball moves one meter down, the current height becomes equal to 1.
- The weight of the snowball increases by 1 (current height), becomes equal to 9.
- The snowball hits the stone, its weight decreases by 1 (the weight of the stone), becomes equal to 8.
- The snowball moves one meter down, the current height becomes equal to 0.

Thus, at the end the weight of the snowball is equal to 8.

## 样例 #1

### 输入

```
4 3
1 1
1 2

```

### 输出

```
8
```

## 样例 #2

### 输入

```
4 3
9 2
0 1

```

### 输出

```
1
```



---

---
title: "Squares and Segments"
layout: "post"
diff: 普及-
pid: CF1099B
tag: []
---

# Squares and Segments

## 题目描述

小索菲亚在四年级。今天，在几何课上，她学到了有关线段和正方形的知识。在回家的路上，她决定在雪中画n个边长为1的正方形。为了简单起见，我们假设Sofia生活在一个平面上，并且只能绘制与坐标轴平行、顶点位于整数点的长度为1的线段。



为了绘制一个段，Sofia进行如下操作。如果她想画一个端点为（x，y）和（x，y+1）垂直段。Sofia会查看是否已经有一个绘制的段，其端点为（x'，y）和（x'，y+1）。如果存在这样的段，那么Sofia将使用旧段作为指导，快速绘制新段。如果没有这样的线段，那么索菲亚就必须用尺子长时间测量一个新的线段。当索菲亚想画一个水平段时，也会发生同样的事情，但现在她才检查是否存在具有相同x，x+1坐标和不同y坐标的段。



例如，如果索菲亚需要画一个1 * 1的正方形，她必须用尺子画两段。



如果索菲亚需要画两个正方形，她必须用尺子画三段。

之后，她可以使用前三个部分作为向导绘制其余四个线段。



索菲亚很着急，所以她想尽量减少用尺子在没有向导的情况下绘制的线段数量。帮她找到这个最小数量。

## 输入格式

小正方形的数量n

## 输出格式

一行，一个整数，表示最小数量

## 样例 #1

### 输入

```
1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
2

```

### 输出

```
3

```

## 样例 #3

### 输入

```
4

```

### 输出

```
4

```



---

---
title: "Accordion"
layout: "post"
diff: 普及-
pid: CF1101B
tag: []
---

# Accordion

## 题目描述

题意简述

给出一个字符串，试在其中删除一些字符，使得最后的串变为满足以下条件的串且长度最大：

长度大于等于$4$；第一个字符为$'['$；最后一个字符为$']'$；第二个字符和倒数第二个字符为$':'$；其余字符全部为$'|'$．

## 输入格式

一行一个字符串

## 输出格式

如果存在满足条件的串，输出它的最长长度，否则输出```-1```

## 样例 #1

### 输入

```
|[a:b:|]

```

### 输出

```
4

```

## 样例 #2

### 输入

```
|]:[|:]

```

### 输出

```
-1

```



---

---
title: "Polycarp's New Job"
layout: "post"
diff: 普及-
pid: CF1101E
tag: []
---

# Polycarp's New Job

## 题目描述

题意简述

维护一个初始为空的点集，支持两种操作：

$+\ x\ y$：向点集中加入$(x,y)$

$?\ h\ w$：查询是否对于点集中的所有点都满足$x  \leq h \&\& y \leq w$或者$x \leq w \&\& y \leq h$

## 输入格式

第一行一个整数$n(1 \leq n \leq 5 \times 10^5)$表示操作数

接下来$n$行每行一个操作，格式如上

数据满足$1 \leq x,y,h,w \leq 10^9$，保证至少有一个$?$操作且第一个操作一定是$+$操作

## 输出格式

对于每一次询问操作输出一行，如果满足条件输出```YES```，否则输出```NO```

## 样例 #1

### 输入

```
9
+ 3 2
+ 2 3
? 1 20
? 3 3
? 2 3
+ 1 5
? 10 10
? 1 5
+ 1 1

```

### 输出

```
NO
YES
YES
YES
NO

```



---

---
title: "Doors Breaking and Repairing"
layout: "post"
diff: 普及-
pid: CF1102C
tag: []
---

# Doors Breaking and Repairing

## 题目描述

You are policeman and you are playing a game with Slavik. The game is turn-based and each turn consists of two phases. During the first phase you make your move and during the second phase Slavik makes his move.

There are $ n $ doors, the $ i $ -th door initially has durability equal to $ a_i $ .

During your move you can try to break one of the doors. If you choose door $ i $ and its current durability is $ b_i $ then you reduce its durability to $ max(0, b_i - x) $ (the value $ x $ is given).

During Slavik's move he tries to repair one of the doors. If he chooses door $ i $ and its current durability is $ b_i $ then he increases its durability to $ b_i + y $ (the value $ y $ is given). Slavik cannot repair doors with current durability equal to $ 0 $ .

The game lasts $ 10^{100} $ turns. If some player cannot make his move then he has to skip it.

Your goal is to maximize the number of doors with durability equal to $ 0 $ at the end of the game. You can assume that Slavik wants to minimize the number of such doors. What is the number of such doors in the end if you both play optimally?

## 输入格式

The first line of the input contains three integers $ n $ , $ x $ and $ y $ ( $ 1 \le n \le 100 $ , $ 1 \le x, y \le 10^5 $ ) — the number of doors, value $ x $ and value $ y $ , respectively.

The second line of the input contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^5 $ ), where $ a_i $ is the initial durability of the $ i $ -th door.

## 输出格式

Print one integer — the number of doors with durability equal to $ 0 $ at the end of the game, if you and Slavik both play optimally.

## 说明/提示

Clarifications about the optimal strategy will be ignored.

## 样例 #1

### 输入

```
6 3 2
2 3 1 3 4 2

```

### 输出

```
6

```

## 样例 #2

### 输入

```
5 3 3
1 2 4 2 3

```

### 输出

```
2

```

## 样例 #3

### 输入

```
5 5 6
1 2 6 10 3

```

### 输出

```
2

```



---

---
title: "Splitting into digits"
layout: "post"
diff: 普及-
pid: CF1104A
tag: []
---

# Splitting into digits

## 题目描述

Vasya has his favourite number $ n $ . He wants to split it to some non-zero digits. It means, that he wants to choose some digits $ d_1, d_2, \ldots, d_k $ , such that $ 1 \leq d_i \leq 9 $ for all $ i $ and $ d_1 + d_2 + \ldots + d_k = n $ .

Vasya likes beauty in everything, so he wants to find any solution with the minimal possible number of different digits among $ d_1, d_2, \ldots, d_k $ . Help him!

## 输入格式

The first line contains a single integer $ n $ — the number that Vasya wants to split ( $ 1 \leq n \leq 1000 $ ).

## 输出格式

In the first line print one integer $ k $ — the number of digits in the partition. Note that $ k $ must satisfy the inequality $ 1 \leq k \leq n $ . In the next line print $ k $ digits $ d_1, d_2, \ldots, d_k $ separated by spaces. All digits must satisfy the inequalities $ 1 \leq d_i \leq 9 $ .

You should find a partition of $ n $ in which the number of different digits among $ d_1, d_2, \ldots, d_k $ will be minimal possible among all partitions of $ n $ into non-zero digits. Among such partitions, it is allowed to find any. It is guaranteed that there exists at least one partition of the number $ n $ into digits.

## 说明/提示

In the first test, the number $ 1 $ can be divided into $ 1 $ digit equal to $ 1 $ .

In the second test, there are $ 3 $ partitions of the number $ 4 $ into digits in which the number of different digits is $ 1 $ . This partitions are $ [1, 1, 1, 1] $ , $ [2, 2] $ and $ [4] $ . Any of these partitions can be found. And, for example, dividing the number $ 4 $ to the digits $ [1, 1, 2] $ isn't an answer, because it has $ 2 $ different digits, that isn't the minimum possible number.

## 样例 #1

### 输入

```
1

```

### 输出

```
1
1 
```

## 样例 #2

### 输入

```
4

```

### 输出

```
2
2 2

```

## 样例 #3

### 输入

```
27

```

### 输出

```
3
9 9 9

```



---

---
title: "Salem and Sticks"
layout: "post"
diff: 普及-
pid: CF1105A
tag: []
---

# Salem and Sticks

## 题目描述

## 题目概述
$Salem$ 给了你 $n$ 个木棍，它们的长度分别为 $a_1,a_2,\cdot \cdot \cdot a_n$。

对于每一根木棍，你可以把它的长度变为任意整数（即收缩或者拉伸）。把一根木棍的长度 $a$ 变为 $b$ 将花费 $|a-b|$ 的价格。

如果说一根木棍对于整数 $t$ 是好的，则需要满足要求 $|a_i - t| \leq 1$。

现在 $Salem$ 让你去改变一些木棍的长度（可能全部或不改变），使所有木棍对于整数 $t$ 是好的，并让花费的价格尽可能小，$t$ 的值不是固定的值，您可以让它成为任意正整数。

现在请你输出 $t$ 的值和最小花费的价格。如果有多种情况，请输出任意一个。

## 输入格式

第一行，包含一个整数 $n$，表示木棍总数。$(1\leq n \leq 1000)$

第二行，包含 $n$ 个整数，表示每一根木棍的长度 $a_i$。$(1\leq a_i \leq 100)$

## 输出格式

共一行，包含 $t$ 的值和所花费的最小价格，中间用空格分开。

## 说明/提示

对于第一个样例，我们可以把长度为 $1$ 的木棍变成 $2$，长度为 $10$ 的木棍变成 $4$，将花费 $|1-2|+|10-4|=1+6=7$ 的价格，最终长度 $[2,4,4]$ 是适合 $t=3$ 的。

对于第二个样例，我们不需要作出任何改变，所有木棍对于 $t=2$ 都是好的。

## 样例 #1

### 输入

```
3
10 1 4

```

### 输出

```
3 7

```

## 样例 #2

### 输入

```
5
1 1 2 2 3

```

### 输出

```
2 0

```



---

---
title: "Lunar New Year and Cross Counting"
layout: "post"
diff: 普及-
pid: CF1106A
tag: []
---

# Lunar New Year and Cross Counting

## 题目描述

在一个 $n \times n$ 的地图中寻找有几个图案，满足

$M(i,j)=M(i-1,j-1)=M(i-1,j+1)=M(i+1,j-1)=M(i+1,j+1)=X$

形似下图。
```
X.X
.X.
X.X
```
如果图案中心所在位置不同即视作不同。

## 输入格式

第一行正整数 $n (1 \le n \le 500)$，表示地图的大小。
接下来 $n$ 行每行 $n$ 个字符，只包含 **'X' 或 '.'**。

## 输出格式

一行一个整数 $k$ 表示图案个数。

## 样例 #1

### 输入

```
5
.....
.XXX.
.XXX.
.XXX.
.....

```

### 输出

```
1

```

## 样例 #2

### 输入

```
2
XX
XX

```

### 输出

```
0

```

## 样例 #3

### 输入

```
6
......
X.X.X.
.X.X.X
X.X.X.
.X.X.X
......

```

### 输出

```
4

```



---

---
title: "Digits Sequence Dividing"
layout: "post"
diff: 普及-
pid: CF1107A
tag: []
---

# Digits Sequence Dividing

## 题目描述

You are given a sequence $ s $ consisting of $ n $ digits from $ 1 $ to $ 9 $ .

You have to divide it into at least two segments (segment — is a consecutive sequence of elements) (in other words, you have to place separators between some digits of the sequence) in such a way that each element belongs to exactly one segment and if the resulting division will be represented as an integer numbers sequence then each next element of this sequence will be strictly greater than the previous one.

More formally: if the resulting division of the sequence is $ t_1, t_2, \dots, t_k $ , where $ k $ is the number of element in a division, then for each $ i $ from $ 1 $ to $ k-1 $ the condition $ t_{i} < t_{i + 1} $ (using numerical comparing, it means that the integer representations of strings are compared) should be satisfied.

For example, if $ s=654 $ then you can divide it into parts $ [6, 54] $ and it will be suitable division. But if you will divide it into parts $ [65, 4] $ then it will be bad division because $ 65 > 4 $ . If $ s=123 $ then you can divide it into parts $ [1, 23] $ , $ [1, 2, 3] $ but not into parts $ [12, 3] $ .

Your task is to find any suitable division for each of the $ q $ independent queries.

## 输入格式

The first line of the input contains one integer $ q $ ( $ 1 \le q \le 300 $ ) — the number of queries.

The first line of the $ i $ -th query contains one integer number $ n_i $ ( $ 2 \le n_i \le 300 $ ) — the number of digits in the $ i $ -th query.

The second line of the $ i $ -th query contains one string $ s_i $ of length $ n_i $ consisting only of digits from $ 1 $ to $ 9 $ .

## 输出格式

If the sequence of digits in the $ i $ -th query cannot be divided into at least two parts in a way described in the problem statement, print the single line "NO" for this query.

Otherwise in the first line of the answer to this query print "YES", on the second line print $ k_i $ — the number of parts in your division of the $ i $ -th query sequence and in the third line print $ k_i $ strings $ t_{i, 1}, t_{i, 2}, \dots, t_{i, k_i} $ — your division. Parts should be printed in order of the initial string digits. It means that if you write the parts one after another without changing their order then you'll get the string $ s_i $ .

See examples for better understanding.

## 样例 #1

### 输入

```
4
6
654321
4
1337
2
33
4
2122

```

### 输出

```
YES
3
6 54 321
YES
3
1 3 37
NO
YES
2
21 22

```



---

---
title: "Two distinct points"
layout: "post"
diff: 普及-
pid: CF1108A
tag: []
---

# Two distinct points

## 题目描述

给定你数轴上的两条线段 $[l_1, r_1],[l_2, r_2]$（可能相交，重叠或重合）。你需要找到两个整数 $a,b$ 满足 $l_1 \leq a \leq r_1, l_2 \leq b \leq r_2$，且 $a\neq b$。你需要回答 $q$ 个询问，可能存在多种答案，输出任意一个即可。

## 输入格式

第一行输入一个整数 $q (1\leq q \leq 500)$，表示询问数量。
接下来 $q$ 行，每行有四个整数 $l_{1_i}, r_{1_i},l_{2_i}, r_{2_i}(1\leq l_{1_i},r_{1_i},l_{2_i},r_{2_i}\leq 10^9,l_{1_i} < r_{1_i},l_{2_i} < r_{2_i})$，表示第 $i$ 个询问的两条线段。

## 输出格式

输出 $2q$ 个整数，每行两个整数 $a_i,b_i$ 表示第 $i$ 个询问的答案，且满足要求 $l_{1_i} \leq a \leq r_{1_i}, l_{2_i} \leq b \leq r_{2_i},a_i\neq b_i$

## 样例 #1

### 输入

```
5
1 2 1 2
2 6 3 4
2 4 1 3
1 2 1 3
1 4 5 8

```

### 输出

```
2 1
3 4
3 2
1 2
3 7

```



---

---
title: "Nice Garland"
layout: "post"
diff: 普及-
pid: CF1108C
tag: []
---

# Nice Garland

## 题目描述

You have a garland consisting of $ n $ lamps. Each lamp is colored red, green or blue. The color of the $ i $ -th lamp is $ s_i $ ('R', 'G' and 'B' — colors of lamps in the garland).

You have to recolor some lamps in this garland (recoloring a lamp means changing its initial color to another) in such a way that the obtained garland is nice.

A garland is called nice if any two lamps of the same color have distance divisible by three between them. I.e. if the obtained garland is $ t $ , then for each $ i, j $ such that $ t_i = t_j $ should be satisfied $ |i-j|~ mod~ 3 = 0 $ . The value $ |x| $ means absolute value of $ x $ , the operation $ x~ mod~ y $ means remainder of $ x $ when divided by $ y $ .

For example, the following garlands are nice: "RGBRGBRG", "GB", "R", "GRBGRBG", "BRGBRGB". The following garlands are not nice: "RR", "RGBG".

Among all ways to recolor the initial garland to make it nice you have to choose one with the minimum number of recolored lamps. If there are multiple optimal solutions, print any of them.

## 输入格式

The first line of the input contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of lamps.

The second line of the input contains the string $ s $ consisting of $ n $ characters 'R', 'G' and 'B' — colors of lamps in the garland.

## 输出格式

In the first line of the output print one integer $ r $ — the minimum number of recolors needed to obtain a nice garland from the given one.

In the second line of the output print one string $ t $ of length $ n $ — a nice garland obtained from the initial one with minimum number of recolors. If there are multiple optimal solutions, print any of them.

## 样例 #1

### 输入

```
3
BRB

```

### 输出

```
1
GRB

```

## 样例 #2

### 输入

```
7
RGBGRBB

```

### 输出

```
3
RGBRGBR

```



---

---
title: "Parity"
layout: "post"
diff: 普及-
pid: CF1110A
tag: []
---

# Parity

## 题目描述

求$\sum_{i=1}^{k} a_i\times b^{k-i}$的奇偶性。

(如果看不懂上面式子的可以去看英语题目)

## 输入格式

第一行：$b$和$k$

第二行：$a_1,a_2,...,a_k$

## 输出格式

- 是奇数：输出`odd`
- 是偶数：输出`even`

## 样例 #1

### 输入

```
13 3
3 2 7

```

### 输出

```
even

```

## 样例 #2

### 输入

```
10 9
1 2 3 4 5 6 7 8 9

```

### 输出

```
odd

```

## 样例 #3

### 输入

```
99 5
32 92 85 74 4

```

### 输出

```
odd

```

## 样例 #4

### 输入

```
2 2
1 0

```

### 输出

```
even

```



---

---
title: "Superhero Transformation"
layout: "post"
diff: 普及-
pid: CF1111A
tag: []
---

# Superhero Transformation

## 题目描述

We all know that a superhero can transform to certain other superheroes. But not all Superheroes can transform to any other superhero. A superhero with name $ s $ can transform to another superhero with name $ t $ if $ s $ can be made equal to $ t $ by changing any vowel in $ s $ to any other vowel and any consonant in $ s $ to any other consonant. Multiple changes can be made.

In this problem, we consider the letters 'a', 'e', 'i', 'o' and 'u' to be vowels and all the other letters to be consonants.

Given the names of two superheroes, determine if the superhero with name $ s $ can be transformed to the Superhero with name $ t $ .

## 输入格式

The first line contains the string $ s $ having length between $ 1 $ and $ 1000 $ , inclusive.

The second line contains the string $ t $ having length between $ 1 $ and $ 1000 $ , inclusive.

Both strings $ s $ and $ t $ are guaranteed to be different and consist of lowercase English letters only.

## 输出格式

Output "Yes" (without quotes) if the superhero with name $ s $ can be transformed to the superhero with name $ t $ and "No" (without quotes) otherwise.

You can print each letter in any case (upper or lower).

## 说明/提示

In the first sample, since both 'a' and 'u' are vowels, it is possible to convert string $ s $ to $ t $ .

In the third sample, 'k' is a consonant, whereas 'a' is a vowel, so it is not possible to convert string $ s $ to $ t $ .

## 样例 #1

### 输入

```
a
u

```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
abc
ukm

```

### 输出

```
Yes

```

## 样例 #3

### 输入

```
akm
ua

```

### 输出

```
No

```



---

---
title: "Sasha and His Trip"
layout: "post"
diff: 普及-
pid: CF1113A
tag: []
---

# Sasha and His Trip

## 题目描述

Sasha is a very happy guy, that's why he is always on the move. There are $ n $ cities in the country where Sasha lives. They are all located on one straight line, and for convenience, they are numbered from $ 1 $ to $ n $ in increasing order. The distance between any two adjacent cities is equal to $ 1 $ kilometer. Since all roads in the country are directed, it's possible to reach the city $ y $ from the city $ x $ only if $ x < y $ .

Once Sasha decided to go on a trip around the country and to visit all $ n $ cities. He will move with the help of his car, Cheetah-2677. The tank capacity of this model is $ v $ liters, and it spends exactly $ 1 $ liter of fuel for $ 1 $ kilometer of the way. At the beginning of the journey, the tank is empty. Sasha is located in the city with the number $ 1 $ and wants to get to the city with the number $ n $ . There is a gas station in each city. In the $ i $ -th city, the price of $ 1 $ liter of fuel is $ i $ dollars. It is obvious that at any moment of time, the tank can contain at most $ v $ liters of fuel.

Sasha doesn't like to waste money, that's why he wants to know what is the minimum amount of money is needed to finish the trip if he can buy fuel in any city he wants. Help him to figure it out!

## 输入格式

The first line contains two integers $ n $ and $ v $ ( $ 2 \le n \le 100 $ , $ 1 \le v \le 100 $ ) — the number of cities in the country and the capacity of the tank.

## 输出格式

Print one integer — the minimum amount of money that is needed to finish the trip.

## 说明/提示

In the first example, Sasha can buy $ 2 $ liters for $ 2 $ dollars ( $ 1 $ dollar per liter) in the first city, drive to the second city, spend $ 1 $ liter of fuel on it, then buy $ 1 $ liter for $ 2 $ dollars in the second city and then drive to the $ 4 $ -th city. Therefore, the answer is $ 1+1+2=4 $ .

In the second example, the capacity of the tank allows to fill the tank completely in the first city, and drive to the last city without stops in other cities.

## 样例 #1

### 输入

```
4 2

```

### 输出

```
4

```

## 样例 #2

### 输入

```
7 6

```

### 输出

```
6

```



---

---
title: "Got Any Grapes?"
layout: "post"
diff: 普及-
pid: CF1114A
tag: []
---

# Got Any Grapes?

## 题目描述

[The Duck song](https://www.youtube.com/watch?v=MtN1YnoL46Q)



For simplicity, we'll assume that there are only three types of grapes: green grapes, purple grapes and black grapes.

Andrew, Dmitry and Michal are all grapes' lovers, however their preferences of grapes are different. To make all of them happy, the following should happen:

- Andrew, Dmitry and Michal should eat at least $ x $ , $ y $ and $ z $ grapes, respectively.
- Andrew has an extreme affinity for green grapes, thus he will eat green grapes and green grapes only.
- On the other hand, Dmitry is not a fan of black grapes — any types of grapes except black would do for him. In other words, Dmitry can eat green and purple grapes.
- Michal has a common taste — he enjoys grapes in general and will be pleased with any types of grapes, as long as the quantity is sufficient.

Knowing that his friends are so fond of grapes, Aki decided to host a grape party with them. He has prepared a box with $ a $ green grapes, $ b $ purple grapes and $ c $ black grapes.

However, Aki isn't sure if the box he prepared contains enough grapes to make everyone happy. Can you please find out whether it's possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes?

It is not required to distribute all the grapes, so it's possible that some of them will remain unused.

## 输入格式

The first line contains three integers $ x $ , $ y $ and $ z $ ( $ 1 \le x, y, z \le 10^5 $ ) — the number of grapes Andrew, Dmitry and Michal want to eat.

The second line contains three integers $ a $ , $ b $ , $ c $ ( $ 1 \le a, b, c \le 10^5 $ ) — the number of green, purple and black grapes in the box.

## 输出格式

If there is a grape distribution that allows everyone to be happy, print "YES", otherwise print "NO".

## 说明/提示

In the first example, there is only one possible distribution:

Andrew should take $ 1 $ green grape, Dmitry should take $ 3 $ remaining green grapes and $ 3 $ purple grapes, and Michal will take $ 2 $ out of $ 3 $ available black grapes.

In the second test, there is no possible distribution, since Andrew is not be able to eat enough green grapes. :(

## 样例 #1

### 输入

```
1 6 2
4 3 3

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
5 1 1
4 3 2

```

### 输出

```
NO

```



---

---
title: "Yet Another Array Partitioning Task"
layout: "post"
diff: 普及-
pid: CF1114B
tag: []
---

# Yet Another Array Partitioning Task

## 题目描述

An array $ b $ is called to be a subarray of $ a $ if it forms a continuous subsequence of $ a $ , that is, if it is equal to $ a_l $ , $ a_{l + 1} $ , $ \ldots $ , $ a_r $ for some $ l, r $ .

Suppose $ m $ is some known constant. For any array, having $ m $ or more elements, let's define it's beauty as the sum of $ m $ largest elements of that array. For example:

- For array $ x = [4, 3, 1, 5, 2] $ and $ m = 3 $ , the $ 3 $ largest elements of $ x $ are $ 5 $ , $ 4 $ and $ 3 $ , so the beauty of $ x $ is $ 5 + 4 + 3 = 12 $ .
- For array $ x = [10, 10, 10] $ and $ m = 2 $ , the beauty of $ x $ is $ 10 + 10 = 20 $ .

You are given an array $ a_1, a_2, \ldots, a_n $ , the value of the said constant $ m $ and an integer $ k $ . Your need to split the array $ a $ into exactly $ k $ subarrays such that:

- Each element from $ a $ belongs to exactly one subarray.
- Each subarray has at least $ m $ elements.
- The sum of all beauties of $ k $ subarrays is maximum possible.

## 输入格式

The first line contains three integers $ n $ , $ m $ and $ k $ ( $ 2 \le n \le 2 \cdot 10^5 $ , $ 1 \le m $ , $ 2 \le k $ , $ m \cdot k \le n $ ) — the number of elements in $ a $ , the constant $ m $ in the definition of beauty and the number of subarrays to split to.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ -10^9 \le a_i \le 10^9 $ ).

## 输出格式

In the first line, print the maximum possible sum of the beauties of the subarrays in the optimal partition.

In the second line, print $ k-1 $ integers $ p_1, p_2, \ldots, p_{k-1} $ ( $ 1 \le p_1 < p_2 < \ldots < p_{k-1} < n $ ) representing the partition of the array, in which:

- All elements with indices from $ 1 $ to $ p_1 $ belong to the first subarray.
- All elements with indices from $ p_1 + 1 $ to $ p_2 $ belong to the second subarray.
- $ \ldots $ .
- All elements with indices from $ p_{k-1} + 1 $ to $ n $ belong to the last, $ k $ -th subarray.

If there are several optimal partitions, print any of them.

## 说明/提示

In the first example, one of the optimal partitions is $ [5, 2, 5] $ , $ [2, 4] $ , $ [1, 1, 3, 2] $ .

- The beauty of the subarray $ [5, 2, 5] $ is $ 5 + 5 = 10 $ .
- The beauty of the subarray $ [2, 4] $ is $ 2 + 4 = 6 $ .
- The beauty of the subarray $ [1, 1, 3, 2] $ is $ 3 + 2 = 5 $ .

The sum of their beauties is $ 10 + 6 + 5 = 21 $ .

In the second example, one optimal partition is $ [4] $ , $ [1, 3] $ , $ [2, 2] $ , $ [3] $ .

## 样例 #1

### 输入

```
9 2 3
5 2 5 2 4 1 1 3 2

```

### 输出

```
21
3 5 
```

## 样例 #2

### 输入

```
6 1 4
4 1 3 2 2 3

```

### 输出

```
12
1 3 5 
```

## 样例 #3

### 输入

```
2 1 2
-1000000000 1000000000

```

### 输出

```
0
1 
```



---

---
title: "Best Subsegment"
layout: "post"
diff: 普及-
pid: CF1117A
tag: []
---

# Best Subsegment

## 题目描述

You are given array $ a_1, a_2, \dots, a_n $ . Find the subsegment $ a_l, a_{l+1}, \dots, a_r $ ( $ 1 \le l \le r \le n $ ) with maximum arithmetic mean $ \frac{1}{r - l + 1}\sum\limits_{i=l}^{r}{a_i} $ (in floating-point numbers, i.e. without any rounding).

If there are many such subsegments find the longest one.

## 输入格式

The first line contains single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — length of the array $ a $ .

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 0 \le a_i \le 10^9 $ ) — the array $ a $ .

## 输出格式

Print the single integer — the length of the longest subsegment with maximum possible arithmetic mean.

## 说明/提示

The subsegment $ [3, 4] $ is the longest among all subsegments with maximum arithmetic mean.

## 样例 #1

### 输入

```
5
6 1 6 6 0

```

### 输出

```
2

```



---

---
title: "Tanya and Candies"
layout: "post"
diff: 普及-
pid: CF1118B
tag: []
---

# Tanya and Candies

## 题目描述

Tanya has $ n $ candies numbered from $ 1 $ to $ n $ . The $ i $ -th candy has the weight $ a_i $ .

She plans to eat exactly $ n-1 $ candies and give the remaining candy to her dad. Tanya eats candies in order of increasing their numbers, exactly one candy per day.

Your task is to find the number of such candies $ i $ (let's call these candies good) that if dad gets the $ i $ -th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days. Note that at first, she will give the candy, after it she will eat the remaining candies one by one.

For example, $ n=4 $ and weights are $ [1, 4, 3, 3] $ . Consider all possible cases to give a candy to dad:

- Tanya gives the $ 1 $ -st candy to dad ( $ a_1=1 $ ), the remaining candies are $ [4, 3, 3] $ . She will eat $ a_2=4 $ in the first day, $ a_3=3 $ in the second day, $ a_4=3 $ in the third day. So in odd days she will eat $ 4+3=7 $ and in even days she will eat $ 3 $ . Since $ 7 \ne 3 $ this case shouldn't be counted to the answer (this candy isn't good).
- Tanya gives the $ 2 $ -nd candy to dad ( $ a_2=4 $ ), the remaining candies are $ [1, 3, 3] $ . She will eat $ a_1=1 $ in the first day, $ a_3=3 $ in the second day, $ a_4=3 $ in the third day. So in odd days she will eat $ 1+3=4 $ and in even days she will eat $ 3 $ . Since $ 4 \ne 3 $ this case shouldn't be counted to the answer (this candy isn't good).
- Tanya gives the $ 3 $ -rd candy to dad ( $ a_3=3 $ ), the remaining candies are $ [1, 4, 3] $ . She will eat $ a_1=1 $ in the first day, $ a_2=4 $ in the second day, $ a_4=3 $ in the third day. So in odd days she will eat $ 1+3=4 $ and in even days she will eat $ 4 $ . Since $ 4 = 4 $ this case should be counted to the answer (this candy is good).
- Tanya gives the $ 4 $ -th candy to dad ( $ a_4=3 $ ), the remaining candies are $ [1, 4, 3] $ . She will eat $ a_1=1 $ in the first day, $ a_2=4 $ in the second day, $ a_3=3 $ in the third day. So in odd days she will eat $ 1+3=4 $ and in even days she will eat $ 4 $ . Since $ 4 = 4 $ this case should be counted to the answer (this candy is good).

In total there $ 2 $ cases which should counted (these candies are good), so the answer is $ 2 $ .

## 输入格式

The first line of the input contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of candies.

The second line of the input contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^4 $ ), where $ a_i $ is the weight of the $ i $ -th candy.

## 输出格式

Print one integer — the number of such candies $ i $ (good candies) that if dad gets the $ i $ -th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days.

## 说明/提示

In the first example indices of good candies are $ [1, 2] $ .

In the second example indices of good candies are $ [2, 3] $ .

In the third example indices of good candies are $ [4, 5, 9] $ .

## 样例 #1

### 输入

```
7
5 5 4 5 5 5 6

```

### 输出

```
2

```

## 样例 #2

### 输入

```
8
4 8 8 7 8 4 4 5

```

### 输出

```
2

```

## 样例 #3

### 输入

```
9
2 3 4 2 2 3 2 2 4

```

### 输出

```
3

```



---

---
title: "Ilya and a Colorful Walk"
layout: "post"
diff: 普及-
pid: CF1119A
tag: []
---

# Ilya and a Colorful Walk

## 题目描述

ilya 有很多房子，每个房子都有一个颜色。因为 ilya 喜欢散步，所以想要选最远的两个不同颜色的房子作为散步的起点和终点。输出这个最远距离。

## 输入格式

第一行一个整数 $n$，表示有多少房子。

第二行 $n$ 个整数，表示颜色，相同的数字表示相同的颜色，不同的数字表示不同的颜色。

## 输出格式

输出最大距离。

## 样例 #1

### 输入

```
5
1 2 3 2 3

```

### 输出

```
4

```

## 样例 #2

### 输入

```
3
1 2 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
7
1 1 3 1 1 1 1

```

### 输出

```
4

```



---

---
title: "Petya and Inequiations"
layout: "post"
diff: 普及-
pid: CF111A
tag: []
---

# Petya and Inequiations

## 题目描述

对于给出的整数 $n, x, y,$ 找出一个正整数数组 $a$ ，满足：

$\begin{cases}a_1^2+a_2^2+...+a_n^2\geq x\\a_1+a_2+...+a_n\leq y\end{cases}$

## 输入格式

一行，三个整数 $n, x, y,$ 以空格分隔。

## 输出格式

$n$ 行，每行一个整数，其中第 $i$ 行表示 $a_i$。如果有多组解，只需输出任意一种。

特别地，如果原方程组无解，只输出一个 $-1$。

## 说明/提示

对于 $100 \%$ 的数据：

$1\leq n\leq 10^5$

$1\leq x\leq 10^{12}$

$1\leq y\leq 10^6$

## 样例 #1

### 输入

```
5 15 15

```

### 输出

```
4
4
1
1
2

```

## 样例 #2

### 输入

```
2 3 2

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
1 99 11

```

### 输出

```
11

```



---

---
title: "Be Positive"
layout: "post"
diff: 普及-
pid: CF1130A
tag: []
---

# Be Positive

## 题目描述

有一个包含nnn个整数的数组,你需要找到一个非零整数$d(-10^3\leq d \leq 10^3)$，使数组中的每一个数组除以d的商中至少有一半为正数(即至少有$\frac{n}{2}$个)注意:"正数"只要求商大于0,不要求一定是整数。如果有多个$d$满足条件，输出其中的任意一个,如果没有这样的$d$则输出$0$。

## 输入格式

第一行包含一个整数$n$,表示数组中元素的数量
第二行包含由$n$个整数,数之间由一个空格隔开。$a_1,a_2,a_3,...,a_n(-10^3\leq a_i \leq 10^3)$

## 样例 #1

### 输入

```
5
10 0 -7 2 6
```

### 输出

```
4
```

## 样例 #2

### 输入

```
7
0 0 1 -1 0 0 2

```

### 输出

```
0
```



---

---
title: "Regular Bracket Sequence"
layout: "post"
diff: 普及-
pid: CF1132A
tag: []
---

# Regular Bracket Sequence

## 题目描述

A string is called bracket sequence if it does not contain any characters other than "(" and ")". A bracket sequence is called regular if it it is possible to obtain correct arithmetic expression by inserting characters "+" and "1" into this sequence. For example, "", "(())" and "()()" are regular bracket sequences; "))" and ")((" are bracket sequences (but not regular ones), and "(a)" and "(1)+(1)" are not bracket sequences at all.

You have a number of strings; each string is a bracket sequence of length $ 2 $ . So, overall you have $ cnt_1 $ strings "((", $ cnt_2 $ strings "()", $ cnt_3 $ strings ")(" and $ cnt_4 $ strings "))". You want to write all these strings in some order, one after another; after that, you will get a long bracket sequence of length $ 2(cnt_1 + cnt_2 + cnt_3 + cnt_4) $ . You wonder: is it possible to choose some order of the strings you have such that you will get a regular bracket sequence? Note that you may not remove any characters or strings, and you may not add anything either.

## 输入格式

The input consists of four lines, $ i $ -th of them contains one integer $ cnt_i $ ( $ 0 \le cnt_i \le 10^9 $ ).

## 输出格式

Print one integer: $ 1 $ if it is possible to form a regular bracket sequence by choosing the correct order of the given strings, $ 0 $ otherwise.

## 说明/提示

In the first example it is possible to construct a string "(())()(()((()()()())))", which is a regular bracket sequence.

In the second example it is possible to construct a string "", which is a regular bracket sequence.

## 样例 #1

### 输入

```
3
1
4
3

```

### 输出

```
1

```

## 样例 #2

### 输入

```
0
0
0
0

```

### 输出

```
1

```

## 样例 #3

### 输入

```
1
2
3
4

```

### 输出

```
0

```



---

---
title: "Discounts"
layout: "post"
diff: 普及-
pid: CF1132B
tag: []
---

# Discounts

## 题目描述

输入n个整数($a_1...a_n$)和 $m$ 个整数( $q_1...q_m$ )。求在去掉第 $q_i$ 大的数字后，$n-1$ 个整数的和。

## 输入格式

共有4行输入。第1行输入一个整数 $n$ （ $2≤n≤3·10^5$ ），第2行输入$n$个整数 $a_1...a_n$（ $1≤ai≤10^9 $ ），第3行输入一个整数$m$( $1≤m≤n$ )，第 $4$ 行输入 $m$ 个整数 $q_1...q_m$（ $2≤q_i≤n$ ）。

## 输出格式

输出$m$个数字，第i行输出表示去掉第$q_i$大的数字后剩下整数的和。

## 说明/提示

样例中，输入3，去掉数组中第3大的整数7，剩下的数字和为27；输入4，去掉数组中第4大的数字4，和为30。

## 样例 #1

### 输入

```
7
7 1 3 1 4 10 8
2
3 4

```

### 输出

```
27
30

```



---

---
title: "Nastya Is Reading a Book"
layout: "post"
diff: 普及-
pid: CF1136A
tag: []
---

# Nastya Is Reading a Book

## 题目描述

Nastya决定读一本有 $n$ 个章节的书。这本书的每一页都属于一章中，同样的，每一章至少有 $1$ 页。

昨晚 Nastya 没有看完书, 所以她在第 $k$  页做下了记号，第 $k$ 页就是还没有读的第 $1$ 页（换句话说，她读了从第 $1$ 页到第 $\left(k-1\right)$ 页。

第二天， Nastya 的朋友 Igor 来问她,还有多少章没读。 但是 Nastya 太忙了, 所以让你来求出她还有多少章节**没完全读完**。

## 输入格式

第 $1$ 行包含一个整数 $n\left(1\le n\le 100\right)$，表示这本书的章节数。

第 $2$ 行到第 $n+1$ 行，每行包括两个整数 $l_i$ 和 $r_i$，$\left(l_1=1\; ,l_i\le r_i\;,1\le i \le n-1\right)$ 表示第 $i$ 章的起止页码，每章节最多包含 $100$ 页。

第 $n+2$ 行包含一个整数 $k$  $\left(1\le k \le r_n\right)$，表示做标记的页码。

## 输出格式

输出一个整数，表示没有完全读完的章节数。

## 样例 #1

### 输入

```
3
1 3
4 7
8 11
2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3
1 4
5 9
10 12
9

```

### 输出

```
2

```

## 样例 #3

### 输入

```
1
1 7
4

```

### 输出

```
1

```



---

---
title: "Even Substrings"
layout: "post"
diff: 普及-
pid: CF1139A
tag: []
---

# Even Substrings

## 题目描述

You are given a string $ s=s_1s_2\dots s_n $ of length $ n $ , which only contains digits $ 1 $ , $ 2 $ , ..., $ 9 $ .

A substring $ s[l \dots r] $ of $ s $ is a string $ s_l s_{l + 1} s_{l + 2} \ldots s_r $ . A substring $ s[l \dots r] $ of $ s $ is called even if the number represented by it is even.

Find the number of even substrings of $ s $ . Note, that even if some substrings are equal as strings, but have different $ l $ and $ r $ , they are counted as different substrings.

## 输入格式

The first line contains an integer $ n $ ( $ 1 \le n \le 65000 $ ) — the length of the string $ s $ .

The second line contains a string $ s $ of length $ n $ . The string $ s $ consists only of digits $ 1 $ , $ 2 $ , ..., $ 9 $ .

## 输出格式

Print the number of even substrings of $ s $ .

## 说明/提示

In the first example, the $ [l, r] $ pairs corresponding to even substrings are:

- $ s[1 \dots 2] $
- $ s[2 \dots 2] $
- $ s[1 \dots 4] $
- $ s[2 \dots 4] $
- $ s[3 \dots 4] $
- $ s[4 \dots 4] $

In the second example, all $ 10 $ substrings of $ s $ are even substrings. Note, that while substrings $ s[1 \dots 1] $ and $ s[2 \dots 2] $ both define the substring "2", they are still counted as different substrings.

## 样例 #1

### 输入

```
4
1234

```

### 输出

```
6
```

## 样例 #2

### 输入

```
4
2244

```

### 输出

```
10
```



---

---
title: "Grammar Lessons"
layout: "post"
diff: 普及-
pid: CF113A
tag: []
---

# Grammar Lessons

## 题目描述

Petya 发明了一种语言。这种语言的词有三种词性、两种性别。下面是每一种词性和性别的结尾表格：

|   |阳性|阴性|
|---|---|---|
|形容词|-lios|-liala|
|名词|-etr|-etra|
|动词|-initis|-inites|

这种语言的语法有以下几条：

1. 每个句子必须按照以下顺序书写：$0$ 个或多个形容词、$1$ 个名词、$0$ 个或多个动词。
2. 一个句子中所有单词的性别必须相同。
3. 每一个单词都以上述结尾来结尾，也就是说，不以上述的结尾来结尾的单词不符合语法。
4. **单独一个合法单词也可以组成一个合法的句子。**

现在 Petya 需要你来帮助他检查语法，如果正确输出 `YES`，否则输出 `NO`。

## 输入格式

一行，一个包含若干以空格分隔的单词的字符串 $s$。（$\lvert s \lvert \leq 10^5$）

数据保证单词仅由小写字母组成，单词间有且只有一个空格。

## 输出格式

一行，`YES` 或 `NO`。

## 样例 #1

### 输入

```
petr

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
etis atis animatis etis atis amatis

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
nataliala kataliala vetra feinites

```

### 输出

```
YES

```



---

---
title: "Good String"
layout: "post"
diff: 普及-
pid: CF1140B
tag: []
---

# Good String

## 题目描述

有一个长度为$n(1<=n<=100)$的字符串，只由<,>两种字符组成。对其进行一次操作如下：


------------

如果选择一个>字符，这个字符**右面**的那一个字符会被删除。特别地，如果你选择的这个字符>位于字符串的最右侧，什么都不会发生。同理，如果选择一个<字符，这个字符**左面**的那一个字符会被删除，选择位于字符串最左边的<字符也什么都不会发生。


------------

定义一下的一个字符串是“好的”：经过若干次以上操作，这个字符串可以只含有一种字符，如>,>>等。

在执行操作之前，你可以删去字符串中的$k(0<=k<=n-1)$$个字符。注意不可以把整个字符串都删去了。

你需要找出$k$的最小值，使得删去$k$个字符后的字符串是“好的”。

## 输入格式

第一行包含一个整数$t(1<=t<=100)$，表示测试数据的组数。

接下来有$2t$行，每$2$行表示一组数据：

第$i$组数据的第一行是一个整数$n$，表示字符串长度；

第二行是一个只含有字符<和>的字符串$s$。

## 输出格式

输出共$t$行，每行包含一个整数，表示删去字符数量的最小值，使剩下的字符串是“好的”。

### 输入输出样例

输入：

```cpp
3
2
<>
3
><<
1
>
```

输出：

```cpp
1
0
0
```

## 说明/提示

第一组数据中，删除任意一个字符都可以使得剩下的字符串是“好的”。

第二组数据中，原字符串就是“好的”，无需删除任何字符。

## 样例 #1

### 输入

```
3
2
<>
3
><<
1
>
```

### 输出

```
1
0
0

```



---

---
title: "Playlist"
layout: "post"
diff: 普及-
pid: CF1140C
tag: []
---

# Playlist

## 题目描述

你有一个有 $n$ 首歌曲的播放列表，第 $i$ 首歌有 $t_i$ 和 $b_i$ 两个特征——分别是它的长度和好听程度。

听这些歌的快乐程度等于这些歌的总长度乘他们中的最小的好听程度。举个例子，听三首长度为 $[5, 7, 4]$ 而好听程度为 $[11, 14, 6]$ 的歌曲获得的快乐程度等于 $(5 + 7 + 4) \times 6 = 96$。

你需要从你的播放列表中选出最多 $k$ 首歌，使听这些歌的快乐程度尽可能的大。

## 输入格式

第一行输入 $n$ 和 $k$（$1 \le k \le n \le 3 \times {10}^5$）两个整数——分别是播放列表中歌的数量和你最多选的歌的数量。

下面的 $n$ 行，每行包含两个整数 $t_i$ 和 $b_i$（$1 \le t_i, b_i \le {10}^6$）——第 $i$ 首歌的长度和好听程度。

## 输出格式

输出一个整数——最大的可能快乐程度。

## 样例 #1

### 输入

```
4 3
4 7
15 1
3 6
6 8

```

### 输出

```
78

```

## 样例 #2

### 输入

```
5 3
12 31
112 4
100 100
13 55
55 50

```

### 输出

```
10000

```



---

---
title: "Maximal Continuous Rest"
layout: "post"
diff: 普及-
pid: CF1141B
tag: []
---

# Maximal Continuous Rest

## 题目描述

Each day in Berland consists of $ n $ hours. Polycarp likes time management. That's why he has a fixed schedule for each day — it is a sequence $ a_1, a_2, \dots, a_n $ (each $ a_i $ is either $ 0 $ or $ 1 $ ), where $ a_i=0 $ if Polycarp works during the $ i $ -th hour of the day and $ a_i=1 $ if Polycarp rests during the $ i $ -th hour of the day.

Days go one after another endlessly and Polycarp uses the same schedule for each day.

What is the maximal number of continuous hours during which Polycarp rests? It is guaranteed that there is at least one working hour in a day.

## 输入格式

The first line contains $ n $ ( $ 1 \le n \le 2\cdot10^5 $ ) — number of hours per day.

The second line contains $ n $ integer numbers $ a_1, a_2, \dots, a_n $ ( $ 0 \le a_i \le 1 $ ), where $ a_i=0 $ if the $ i $ -th hour in a day is working and $ a_i=1 $ if the $ i $ -th hour is resting. It is guaranteed that $ a_i=0 $ for at least one $ i $ .

## 输出格式

Print the maximal number of continuous hours during which Polycarp rests. Remember that you should consider that days go one after another endlessly and Polycarp uses the same schedule for each day.

## 说明/提示

In the first example, the maximal rest starts in last hour and goes to the first hour of the next day.

In the second example, Polycarp has maximal rest from the $ 4 $ -th to the $ 5 $ -th hour.

In the third example, Polycarp has maximal rest from the $ 3 $ -rd to the $ 5 $ -th hour.

In the fourth example, Polycarp has no rest at all.

## 样例 #1

### 输入

```
5
1 0 1 0 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
6
0 1 0 1 1 0

```

### 输出

```
2

```

## 样例 #3

### 输入

```
7
1 0 1 1 1 0 1

```

### 输出

```
3

```

## 样例 #4

### 输入

```
3
0 0 0

```

### 输出

```
0

```



---

---
title: "The Doors"
layout: "post"
diff: 普及-
pid: CF1143A
tag: []
---

# The Doors

## 题目描述

Three years have passes and nothing changed. It is still raining in London, and Mr. Black has to close all the doors in his home in order to not be flooded. Once, however, Mr. Black became so nervous that he opened one door, then another, then one more and so on until he opened all the doors in his house.

There are exactly two exits from Mr. Black's house, let's name them left and right exits. There are several doors in each of the exits, so each door in Mr. Black's house is located either in the left or in the right exit. You know where each door is located. Initially all the doors are closed. Mr. Black can exit the house if and only if all doors in at least one of the exits is open. You are given a sequence in which Mr. Black opened the doors, please find the smallest index $ k $ such that Mr. Black can exit the house after opening the first $ k $ doors.

We have to note that Mr. Black opened each door at most once, and in the end all doors became open.

## 输入格式

The first line contains integer $ n $ ( $ 2 \le n \le 200\,000 $ ) — the number of doors.

The next line contains $ n $ integers: the sequence in which Mr. Black opened the doors. The $ i $ -th of these integers is equal to $ 0 $ in case the $ i $ -th opened door is located in the left exit, and it is equal to $ 1 $ in case it is in the right exit.

It is guaranteed that there is at least one door located in the left exit and there is at least one door located in the right exit.

## 输出格式

Print the smallest integer $ k $ such that after Mr. Black opened the first $ k $ doors, he was able to exit the house.

## 说明/提示

In the first example the first two doors are from the left exit, so when Mr. Black opened both of them only, there were two more closed door in the left exit and one closed door in the right exit. So Mr. Black wasn't able to exit at that moment.

When he opened the third door, all doors from the right exit became open, so Mr. Black was able to exit the house.

In the second example when the first two doors were opened, there was open closed door in each of the exit.

With three doors opened Mr. Black was able to use the left exit.

## 样例 #1

### 输入

```
5
0 0 1 0 0

```

### 输出

```
3

```

## 样例 #2

### 输入

```
4
1 0 0 1

```

### 输出

```
3

```



---

---
title: "Parity Alternated Deletions"
layout: "post"
diff: 普及-
pid: CF1144B
tag: []
---

# Parity Alternated Deletions

## 题目描述

$Polycarp$有一个有$n$个数的数组，他会轮流从中删去数，比如：奇数-偶数-奇数-偶数-奇数-偶数-奇数-偶数···$\ \ \ $或：偶数-奇数-偶数-奇数-偶数-奇数-偶数-奇数···直到无法删除。

## 输入格式

第一行:一个数字$n( 1 \le n \le 2000 1≤n≤2000 )$表示数组大小。

第二行：$n$个数，表示$a_{1},a_{2},a_{3}...a_{n} (0\le a_{i} \le 10^{6})$中的数。

## 输出格式

一个数，表示数组中剩余数的**最小和**。

若整个数组可以删除，**输出$0$**

## 样例 #1

### 输入

```
5
1 5 7 8 2

```

### 输出

```
0

```

## 样例 #2

### 输入

```
6
5 1 2 4 6 3

```

### 输出

```
0

```

## 样例 #3

### 输入

```
2
1000000 1000000

```

### 输出

```
1000000

```



---

---
title: "Thanos Sort"
layout: "post"
diff: 普及-
pid: CF1145A
tag: []
---

# Thanos Sort

## 题目描述

[灭霸排序](https://codegolf.stackexchange.com/questions/182221/implement-the-thanos-sorting-algorithm)是一种超级反派排序算法。

它是这样运行的：  
对于一个序列$a$,满足$\forall i<j,a_i\le a_j$，就停止排序；  
否则删掉这个序列的左半边或右半边。   
按此规则重复执行，直到满足上述条件。  

现在给你一个序列，对其进行这种排序算法后，最大长度会是多少呢？

## 输入格式

第一行一个正整数$n$  
下面一行$n$个正整数$a_i$，表示序列$a$的第$i$项。

## 输出格式

输出一个正整数，表示排序后序列$a$的最大长度。

## 说明/提示

$n\in\{1,2,4,8,16\}$  
$1\le a_i\le 100$

## 样例 #1

### 输入

```
4
1 2 2 4

```

### 输出

```
4

```

## 样例 #2

### 输入

```
8
11 12 1 2 13 14 3 4

```

### 输出

```
2

```

## 样例 #3

### 输入

```
4
7 6 5 4

```

### 输出

```
1

```



---

---
title: "Neat Words"
layout: "post"
diff: 普及-
pid: CF1145F
tag: []
---

# Neat Words

## 输入格式

The input consists of a single string of uppercase letters A-Z. The length of the string is between 1 and 10 characters, inclusive.

## 输出格式

Output "YES" or "NO".

## 样例 #1

### 输入

```
NEAT

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
WORD

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
CODER

```

### 输出

```
NO

```

## 样例 #4

### 输入

```
APRILFOOL

```

### 输出

```
NO

```

## 样例 #5

### 输入

```
AI

```

### 输出

```
YES

```

## 样例 #6

### 输入

```
JUROR

```

### 输出

```
YES

```

## 样例 #7

### 输入

```
YES

```

### 输出

```
NO

```



---

---
title: "Born This Way"
layout: "post"
diff: 普及-
pid: CF1148B
tag: []
---

# Born This Way

## 题目描述

$Arkady$ 买了一张从 $A$ 市到 $C$ 市的机票。不幸的是，这两个城市之间没有直飞航班，但是从 $A$ 市到 $B$ 市和从 $B$ 市到 $C$ 市的航班有很多。

从 $A$ 市到 $B$ 市有 $N$ 个航班，它们分别在 $a_1,a_2,a_3,...$ $,a_n$ 时起飞，在 $ta$ 个单位时间的飞行后到达 $B$ 市。

从 $B$ 市到 $C$市 有 $M$ 个航班，它们在 $b_1,b_2,b_3,...$ $,b_m$ 起飞。在 $tb$ 个单位时间的飞行后到达 $C$ 市。

转机的时间忽略不计，因此只有当 $b_j \ge a_i+ta$ 时，$Arkady$ 才能搭乘从 $A$ 市到 $B$ 市的第 $i$ 次航班和 $B$ 市到 $C$ 市的第 $j$ 次航班抵达目的地。 

你最多可以不择手段地取消 $k$ 次航班。如果你取消了航班，$Arkady$ 当然就不能搭乘它了。

$Arkady$ 想尽早到 $C$ 市，而你想让他尽可能地晚到 $C$ 市。计算你取消了 $k$ 次航班之后 $Arkady$ 最早到达 $C$ 市的时间点。如果你可以通过取消 $k$ 次或更少的航班，使 $Arkady$ 不能达到 $C$ 市，请输出 $−1$ 。

## 输入格式

输入的第一行包括五个整数 $n,m,ta,tb$ 和 $k$ （$1 \le n \le 2\cdot 10^5$ , $1 \le ta, tb \le 10^9 $ , $1 \le ta, tb \le 10^9$）。即从 $A$ 市到 $B$ 市的航班数，从 $B$ 市到 $C$ 市的航班数，从$A$ 市到 $B$ 市的飞行用时，从 $B$ 市到 $C$ 市的飞行用时和你可以取消的航班数量。 

第二行有 $n$ 个递增的整数 $a_1,a_2,a_3,...$ $,a_n$  （$1 \le a_1<a_2<\ldots<a_n \le 10^9 $）—— 从 $A$ 到 $B$ 的航班起飞的时间 。

第三行有 $m$ 个递增的整数 $b_1,b_2,b_3,...$ $,b_n$  （$1 \le b_1<b_2<\ldots<b_n \le 10^9 $）—— 从 $B$ 到 $C$ 的航班起飞的时间 。

## 输出格式

如果您可以取消 $k$ 或更少次数的航班，使 $Arkady$ 根本不可能达到 $C$ 市，请输出−1。

否则，如果您取消k次航班，只能最大限度地延后这一时间，则输出 $Arkady$ 到达 $C$ 市的最晚的最早抵达时间
。

## 样例 #1

### 输入

```
4 5 1 1 2
1 3 5 7
1 2 3 9 10

```

### 输出

```
11

```

## 样例 #2

### 输入

```
2 2 4 4 2
1 10
10 20

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
4 3 2 3 1
1 999999998 999999999 1000000000
3 4 1000000000

```

### 输出

```
1000000003

```



---

---
title: "Prefix Sum Primes"
layout: "post"
diff: 普及-
pid: CF1149A
tag: []
---

# Prefix Sum Primes

## 题目描述

We're giving away nice huge bags containing number tiles! A bag we want to present to you contains $ n $ tiles. Each of them has a single number written on it — either $ 1 $ or $ 2 $ .

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1 \leq n \leq 200\,000 $ ) — the number of number tiles in the bag. The following line contains $ n $ space-separated integers $ a_1, a_2, \dots, a_n $ ( $ a_i \in \{1, 2\} $ ) — the values written on the tiles.

## 输出格式

Output a permutation $ b_1, b_2, \dots, b_n $ of the input sequence $ (a_1, a_2, \dots, a_n) $ maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

## 说明/提示

The first solution produces the prefix sums $ 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} $ (four primes constructed), while the prefix sums in the second solution are $ 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} $ (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.

## 样例 #1

### 输入

```
5
1 2 1 2 1

```

### 输出

```
1 1 1 2 2

```

## 样例 #2

### 输入

```
9
1 1 2 1 1 1 2 1 1

```

### 输出

```
1 1 1 2 1 1 1 2 1

```



---

---
title: "Stock Arbitraging"
layout: "post"
diff: 普及-
pid: CF1150A
tag: []
---

# Stock Arbitraging

## 题目描述

Welcome to Codeforces Stock Exchange! We're pretty limited now as we currently allow trading on one stock, Codeforces Ltd. We hope you'll still be able to make profit from the market!

In the morning, there are $ n $ opportunities to buy shares. The $ i $ -th of them allows to buy as many shares as you want, each at the price of $ s_i $ bourles.

In the evening, there are $ m $ opportunities to sell shares. The $ i $ -th of them allows to sell as many shares as you want, each at the price of $ b_i $ bourles. You can't sell more shares than you have.

It's morning now and you possess $ r $ bourles and no shares.

What is the maximum number of bourles you can hold after the evening?

## 输入格式

The first line of the input contains three integers $ n, m, r $ ( $ 1 \leq n \leq 30 $ , $ 1 \leq m \leq 30 $ , $ 1 \leq r \leq 1000 $ ) — the number of ways to buy the shares on the market, the number of ways to sell the shares on the market, and the number of bourles you hold now.

The next line contains $ n $ integers $ s_1, s_2, \dots, s_n $ ( $ 1 \leq s_i \leq 1000 $ ); $ s_i $ indicates the opportunity to buy shares at the price of $ s_i $ bourles.

The following line contains $ m $ integers $ b_1, b_2, \dots, b_m $ ( $ 1 \leq b_i \leq 1000 $ ); $ b_i $ indicates the opportunity to sell shares at the price of $ b_i $ bourles.

## 输出格式

Output a single integer — the maximum number of bourles you can hold after the evening.

## 说明/提示

In the first example test, you have $ 11 $ bourles in the morning. It's optimal to buy $ 5 $ shares of a stock at the price of $ 2 $ bourles in the morning, and then to sell all of them at the price of $ 5 $ bourles in the evening. It's easy to verify that you'll have $ 26 $ bourles after the evening.

In the second example test, it's optimal not to take any action.

## 样例 #1

### 输入

```
3 4 11
4 2 5
4 4 5 4

```

### 输出

```
26

```

## 样例 #2

### 输入

```
2 2 50
5 7
4 2

```

### 输出

```
50

```



---

---
title: "Maxim and Biology"
layout: "post"
diff: 普及-
pid: CF1151A
tag: []
---

# Maxim and Biology

## 题目描述

Today in the scientific lyceum of the Kingdom of Kremland, there was a biology lesson. The topic of the lesson was the genomes. Let's call the genome the string "ACTG".

Maxim was very boring to sit in class, so the teacher came up with a task for him: on a given string $ s $ consisting of uppercase letters and length of at least $ 4 $ , you need to find the minimum number of operations that you need to apply, so that the genome appears in it as a substring. For one operation, you can replace any letter in the string $ s $ with the next or previous in the alphabet. For example, for the letter "D" the previous one will be "C", and the next — "E". In this problem, we assume that for the letter "A", the previous one will be the letter "Z", and the next one will be "B", and for the letter "Z", the previous one is the letter "Y", and the next one is the letter "A".

Help Maxim solve the problem that the teacher gave him.

A string $ a $ is a substring of a string $ b $ if $ a $ can be obtained from $ b $ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.

## 输入格式

The first line contains a single integer $ n $ ( $ 4 \leq n \leq 50 $ ) — the length of the string $ s $ .

The second line contains the string $ s $ , consisting of exactly $ n $ uppercase letters of the Latin alphabet.

## 输出格式

Output the minimum number of operations that need to be applied to the string $ s $ so that the genome appears as a substring in it.

## 说明/提示

In the first example, you should replace the letter "Z" with "A" for one operation, the letter "H" — with the letter "G" for one operation. You will get the string "ACTG", in which the genome is present as a substring.

In the second example, we replace the letter "A" with "C" for two operations, the letter "D" — with the letter "A" for three operations. You will get the string "ZACTG", in which there is a genome.

## 样例 #1

### 输入

```
4
ZCTH

```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
ZDATG

```

### 输出

```
5
```

## 样例 #3

### 输入

```
6
AFBAKC

```

### 输出

```
16
```



---

---
title: "Neko Finds Grapes"
layout: "post"
diff: 普及-
pid: CF1152A
tag: []
---

# Neko Finds Grapes

## 题目描述

On a random day, Neko found $ n $ treasure chests and $ m $ keys. The $ i $ -th chest has an integer $ a_i $ written on it and the $ j $ -th key has an integer $ b_j $ on it. Neko knows those chests contain the powerful mysterious green Grapes, thus Neko wants to open as many treasure chests as possible.

The $ j $ -th key can be used to unlock the $ i $ -th chest if and only if the sum of the key number and the chest number is an odd number. Formally, $ a_i + b_j \equiv 1 \pmod{2} $ . One key can be used to open at most one chest, and one chest can be opened at most once.

Find the maximum number of chests Neko can open.

## 输入格式

The first line contains integers $ n $ and $ m $ ( $ 1 \leq n, m \leq 10^5 $ ) — the number of chests and the number of keys.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the numbers written on the treasure chests.

The third line contains $ m $ integers $ b_1, b_2, \ldots, b_m $ ( $ 1 \leq b_i \leq 10^9 $ ) — the numbers written on the keys.

## 输出格式

Print the maximum number of chests you can open.

## 说明/提示

In the first example, one possible way to unlock $ 3 $ chests is as follows:

- Use first key to unlock the fifth chest,
- Use third key to unlock the second chest,
- Use fourth key to unlock the first chest.

In the second example, you can use the only key to unlock any single chest (note that one key can't be used twice).

In the third example, no key can unlock the given chest.

## 样例 #1

### 输入

```
5 4
9 14 6 2 11
8 4 7 20

```

### 输出

```
3
```

## 样例 #2

### 输入

```
5 1
2 4 6 8 10
5

```

### 输出

```
1
```

## 样例 #3

### 输入

```
1 4
10
20 30 40 50

```

### 输出

```
0
```



---

---
title: "Neko Performs Cat Furrier Transform"
layout: "post"
diff: 普及-
pid: CF1152B
tag: []
---

# Neko Performs Cat Furrier Transform

## 题目描述

Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat.

Assume that we have a cat with a number $ x $ . A perfect longcat is a cat with a number equal $ 2^m - 1 $ for some non-negative integer $ m $ . For example, the numbers $ 0 $ , $ 1 $ , $ 3 $ , $ 7 $ , $ 15 $ and so on are suitable for the perfect longcats.

In the Cat Furrier Transform, the following operations can be performed on $ x $ :

- (Operation A): you select any non-negative integer $ n $ and replace $ x $ with $ x \oplus (2^n - 1) $ , with $ \oplus $ being a [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).
- (Operation B): replace $ x $ with $ x + 1 $ .

The first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B.

Neko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most $ 40 $ operations. Can you help Neko writing a transformation plan?

Note that it is not required to minimize the number of operations. You just need to use no more than $ 40 $ operations.

## 输入格式

The only line contains a single integer $ x $ ( $ 1 \le x \le 10^6 $ ).

## 输出格式

The first line should contain a single integer $ t $ ( $ 0 \le t \le 40 $ ) — the number of operations to apply.

Then for each odd-numbered operation print the corresponding number $ n_i $ in it. That is, print $ \lceil \frac{t}{2} \rceil $ integers $ n_i $ ( $ 0 \le n_i \le 30 $ ), denoting the replacement $ x $ with $ x \oplus (2^{n_i} - 1) $ in the corresponding step.

If there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem.

## 说明/提示

In the first test, one of the transforms might be as follows: $ 39 \to 56 \to 57 \to 62 \to 63 $ . Or more precisely:

1. Pick $ n = 5 $ . $ x $ is transformed into $ 39 \oplus 31 $ , or $ 56 $ .
2. Increase $ x $ by $ 1 $ , changing its value to $ 57 $ .
3. Pick $ n = 3 $ . $ x $ is transformed into $ 57 \oplus 7 $ , or $ 62 $ .
4. Increase $ x $ by $ 1 $ , changing its value to $ 63 = 2^6 - 1 $ .

In the second and third test, the number already satisfies the goal requirement.

## 样例 #1

### 输入

```
39

```

### 输出

```
4
5 3 
```

## 样例 #2

### 输入

```
1

```

### 输出

```
0

```

## 样例 #3

### 输入

```
7

```

### 输出

```
0

```



---

---
title: "Serval and Bus"
layout: "post"
diff: 普及-
pid: CF1153A
tag: []
---

# Serval and Bus

## 题目描述

It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly.

Serval will go to the bus station at time $ t $ , and there are $ n $ bus routes which stop at this station. For the $ i $ -th bus route, the first bus arrives at time $ s_i $ minutes, and each bus of this route comes $ d_i $ minutes later than the previous one.

As Serval's best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them.

## 输入格式

The first line contains two space-separated integers $ n $ and $ t $ ( $ 1\leq n\leq 100 $ , $ 1\leq t\leq 10^5 $ ) — the number of bus routes and the time Serval goes to the station.

Each of the next $ n $ lines contains two space-separated integers $ s_i $ and $ d_i $ ( $ 1\leq s_i,d_i\leq 10^5 $ ) — the time when the first bus of this route arrives and the interval between two buses of this route.

## 输出格式

Print one number — what bus route Serval will use. If there are several possible answers, you can print any of them.

## 说明/提示

In the first example, the first bus of the first route arrives at time $ 6 $ , and the first bus of the second route arrives at time $ 9 $ , so the first route is the answer.

In the second example, a bus of the third route arrives at time $ 5 $ , so it is the answer.

In the third example, buses of the first route come at times $ 2 $ , $ 4 $ , $ 6 $ , $ 8 $ , and so fourth, buses of the second route come at times $ 2 $ , $ 5 $ , $ 8 $ , and so fourth and buses of the third route come at times $ 2 $ , $ 6 $ , $ 10 $ , and so on, so $ 1 $ and $ 2 $ are both acceptable answers while $ 3 $ is not.

## 样例 #1

### 输入

```
2 2
6 4
9 5

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5 5
3 3
2 5
5 6
4 9
6 1

```

### 输出

```
3

```

## 样例 #3

### 输入

```
3 7
2 2
2 3
2 4

```

### 输出

```
1

```



---

---
title: "Restoring Three Numbers"
layout: "post"
diff: 普及-
pid: CF1154A
tag: []
---

# Restoring Three Numbers

## 题目描述

Polycarp has guessed three positive integers $ a $ , $ b $ and $ c $ . He keeps these numbers in secret, but he writes down four numbers on a board in arbitrary order — their pairwise sums (three numbers) and sum of all three numbers (one number). So, there are four numbers on a board in random order: $ a+b $ , $ a+c $ , $ b+c $ and $ a+b+c $ .

You have to guess three numbers $ a $ , $ b $ and $ c $ using given numbers. Print three guessed integers in any order.

Pay attention that some given numbers $ a $ , $ b $ and $ c $ can be equal (it is also possible that $ a=b=c $ ).

## 输入格式

The only line of the input contains four positive integers $ x_1, x_2, x_3, x_4 $ ( $ 2 \le x_i \le 10^9 $ ) — numbers written on a board in random order. It is guaranteed that the answer exists for the given number $ x_1, x_2, x_3, x_4 $ .

## 输出格式

Print such positive integers $ a $ , $ b $ and $ c $ that four numbers written on a board are values $ a+b $ , $ a+c $ , $ b+c $ and $ a+b+c $ written in some order. Print $ a $ , $ b $ and $ c $ in any order. If there are several answers, you can print any. It is guaranteed that the answer exists.

## 样例 #1

### 输入

```
3 6 5 4

```

### 输出

```
2 1 3

```

## 样例 #2

### 输入

```
40 40 40 60

```

### 输出

```
20 20 20

```

## 样例 #3

### 输入

```
201 101 101 200

```

### 输出

```
1 100 100

```



---

---
title: "Reverse a Substring"
layout: "post"
diff: 普及-
pid: CF1155A
tag: []
---

# Reverse a Substring

## 题目描述

给定一个**仅含小写字母**的字符串$s$，其长度为$n$

我们定义子串为一个字符串中连续的一段，比如```acab```是```abacaba```的子串（位置是```3~6```），而```aa```和```d```不是。所以对于一个字符串$s$，它的位置为$[l,r]$的子串可以表示成$s[l;r]$，即$s_ls_{l+1}...s_r$

您需要指定$s$的**一个**子串并翻转这个子串，使得新字符串的字典序比原来的字符串$s$小。注意不是最小。

如果可以满足题意，输出```YES```，再输出反转的区间。否则输出```NO```

我们认为字符串$x<y$当且仅当存在一个 $i$ $(1 \leq i\leq min(|x| ,|y|))$，使得 $x_i < y_i$ 并且$x_j =y_j (1 \leq j < i)$ 此处的绝对值符号```|x|``` 指的是字符串长度。在某些语言中您可以用 $<$ 运算符比较字符串字典序

## 输入格式

第一行一个整数 $n(2\leq n \leq 3\times10^5)$ ，表示字符串$s$的长度

第二行一个**仅含小写字母**的字符串$s$

## 输出格式

如果可以通过翻转**一个**子串得到字典序更小的字符串，输出```YES```，换行，再输出反转的区间（如果有多种方案仅输出一个）。否则仅输出```NO```

## 说明/提示

样例$1$中，翻转后的字符串是```aacabba```

## 样例 #1

### 输入

```
7
abacaba

```

### 输出

```
YES
2 5

```

## 样例 #2

### 输入

```
6
aabcfg

```

### 输出

```
NO

```



---

---
title: "Inscribed Figures"
layout: "post"
diff: 普及-
pid: CF1156A
tag: []
---

# Inscribed Figures

## 题目描述

The math faculty of Berland State University has suffered the sudden drop in the math skills of enrolling students. This year the highest grade on the entrance math test was 8. Out of 100! Thus, the decision was made to make the test easier.

Future students will be asked just a single question. They are given a sequence of integer numbers $ a_1, a_2, \dots, a_n $ , each number is from $ 1 $ to $ 3 $ and $ a_i \ne a_{i + 1} $ for each valid $ i $ . The $ i $ -th number represents a type of the $ i $ -th figure:

1. circle;
2. isosceles triangle with the length of height equal to the length of base;
3. square.

The figures of the given sequence are placed somewhere on a Cartesian plane in such a way that:

- $ (i + 1) $ -th figure is inscribed into the $ i $ -th one;
- each triangle base is parallel to OX;
- the triangle is oriented in such a way that the vertex opposite to its base is at the top;
- each square sides are parallel to the axes;
- for each $ i $ from $ 2 $ to $ n $ figure $ i $ has the maximum possible length of side for triangle and square and maximum radius for circle.

Note that the construction is unique for some fixed position and size of just the first figure.

The task is to calculate the number of distinct points (not necessarily with integer coordinates) where figures touch. The trick is, however, that the number is sometimes infinite. But that won't make the task difficult for you, will it?

So can you pass the math test and enroll into Berland State University?

## 输入格式

The first line contains a single integer $ n $ ( $ 2 \le n \le 100 $ ) — the number of figures.

The second line contains $ n $ integer numbers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 3 $ , $ a_i \ne a_{i + 1} $ ) — types of the figures.

## 输出格式

The first line should contain either the word "Infinite" if the number of distinct points where figures touch is infinite or "Finite" otherwise.

If the number is finite than print it in the second line. It's guaranteed that the number fits into 32-bit integer type.

## 说明/提示

Here are the glorious pictures for the examples. Note that the triangle is not equilateral but just isosceles with the length of height equal to the length of base. Thus it fits into a square in a unique way.

The distinct points where figures touch are marked red.

In the second example the triangle and the square touch each other for the whole segment, it contains infinite number of points.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1156A/ecd8055b09d857a1401e35aa45bd638bb2a049f0.png)

## 样例 #1

### 输入

```
3
2 1 3

```

### 输出

```
Finite
7

```

## 样例 #2

### 输入

```
3
1 2 3

```

### 输出

```
Infinite

```



---

---
title: "Reachable Numbers"
layout: "post"
diff: 普及-
pid: CF1157A
tag: []
---

# Reachable Numbers

## 题目描述

有一个函数$f(x)$，效果是将$x+1$后，去掉末尾所有的$0$，例如：

$f(599)=6$，因为$599+1=600→60→6$

$f(7)=8$，因为$7+1=8$

$f(9)=1$，因为$9+1=10→1$

$f(10099)=101$，因为$10099+1=10100→1010→101$

我们可以多次进行函数$f(x)$的运算，从而让一个数$x$转换为另一个数，例如$10098$可以转换为$102$，因为$f(f(f(10098)))=f(f(10099))=f(101)=102$。

你需要做的是给你一个数$n$，求出$n$经过多次函数$f(x)$的计算，能转换为几个不同的数（包括自身）？

## 输入格式

一个整数$n \space (n \le 10^9)$。

## 输出格式

一个整数，代表$n$能够转换为的不同数字的个数。

## 样例 #1

### 输入

```
1098

```

### 输出

```
20

```

## 样例 #2

### 输入

```
10

```

### 输出

```
19

```



---

---
title: "Long Number"
layout: "post"
diff: 普及-
pid: CF1157B
tag: []
---

# Long Number

## 题目描述

给定一个一个n位数，以及1~9数字的替换数。现请你在这个n位数上选一个连续的数段，将段内的每个数字替换成相应数字的替换数。要求：输出按照要求替换后的最大n位整数。

## 输入格式

第一行一个整数n$ ( 1 \le n \le 2 \cdot 10^5 ) $

第二行一个n位整数

第三行为9个替换数(一位正整数)，第i个为数字i的替换数

## 输出格式

一个n位整数，即按照要求替换后你的最大结果

## 样例 #1

### 输入

```
4
1337
1 2 5 4 6 6 3 1 9

```

### 输出

```
1557

```

## 样例 #2

### 输入

```
5
11111
9 8 7 6 5 4 3 2 1

```

### 输出

```
99999

```

## 样例 #3

### 输入

```
2
33
1 1 1 1 1 1 1 1 1

```

### 输出

```
33

```



---

---
title: "The Party and Sweets"
layout: "post"
diff: 普及-
pid: CF1158A
tag: []
---

# The Party and Sweets

## 题目描述

 $ n $ boys and $ m $ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $ 1 $ to $ n $ and all girls are numbered with integers from $ 1 $ to $ m $ . For all $ 1 \leq i \leq n $ the minimal number of sweets, which $ i $ -th boy presented to some girl is equal to $ b_i $ and for all $ 1 \leq j \leq m $ the maximal number of sweets, which $ j $ -th girl received from some boy is equal to $ g_j $ .

More formally, let $ a_{i,j} $ be the number of sweets which the $ i $ -th boy give to the $ j $ -th girl. Then $ b_i $ is equal exactly to the minimum among values $ a_{i,1}, a_{i,2}, \ldots, a_{i,m} $ and $ g_j $ is equal exactly to the maximum among values $ b_{1,j}, b_{2,j}, \ldots, b_{n,j} $ .

You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $ a_{i,j} $ for all $ (i,j) $ such that $ 1 \leq i \leq n $ and $ 1 \leq j \leq m $ . You are given the numbers $ b_1, \ldots, b_n $ and $ g_1, \ldots, g_m $ , determine this number.

## 输入格式

The first line contains two integers $ n $ and $ m $ , separated with space — the number of boys and girls, respectively ( $ 2 \leq n, m \leq 100\,000 $ ). The second line contains $ n $ integers $ b_1, \ldots, b_n $ , separated by spaces — $ b_i $ is equal to the minimal number of sweets, which $ i $ -th boy presented to some girl ( $ 0 \leq b_i \leq 10^8 $ ). The third line contains $ m $ integers $ g_1, \ldots, g_m $ , separated by spaces — $ g_j $ is equal to the maximal number of sweets, which $ j $ -th girl received from some boy ( $ 0 \leq g_j \leq 10^8 $ ).

## 输出格式

If the described situation is impossible, print $ -1 $ . In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.

## 说明/提示

In the first test, the minimal total number of sweets, which boys could have presented is equal to $ 12 $ . This can be possible, for example, if the first boy presented $ 1 $ and $ 4 $ sweets, the second boy presented $ 3 $ and $ 2 $ sweets and the third boy presented $ 1 $ and $ 1 $ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $ 12 $ .

In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.

In the third test, the minimal total number of sweets, which boys could have presented is equal to $ 4 $ . This can be possible, for example, if the first boy presented $ 1 $ , $ 1 $ , $ 2 $ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $ 4 $ .

## 样例 #1

### 输入

```
3 2
1 2 1
3 4

```

### 输出

```
12
```

## 样例 #2

### 输入

```
2 2
0 1
1 0

```

### 输出

```
-1
```

## 样例 #3

### 输入

```
2 3
1 0
1 1 2

```

### 输出

```
4
```



---

---
title: "Eating Soup"
layout: "post"
diff: 普及-
pid: CF1163A
tag: []
---

# Eating Soup

## 题目描述

The three friends, Kuro, Shiro, and Katie, met up again! It's time for a party...

What the cats do when they unite? Right, they have a party. Since they wanted to have as much fun as possible, they invited all their friends. Now $ n $ cats are at the party, sitting in a circle and eating soup. The rules are simple: anyone having finished their soup leaves the circle.

Katie suddenly notices that whenever a cat leaves, the place where she was sitting becomes an empty space, which means the circle is divided into smaller continuous groups of cats sitting next to each other. At the moment Katie observes, there are $ m $ cats who left the circle. This raises a question for Katie: what is the maximum possible number of groups the circle is divided into at the moment?

Could you help her with this curiosity?

You can see the examples and their descriptions with pictures in the "Note" section.

## 输入格式

The only line contains two integers $ n $ and $ m $ ( $ 2 \leq n \leq 1000 $ , $ 0 \leq m \leq n $ ) — the initial number of cats at the party and the number of cats who left the circle at the moment Katie observes, respectively.

## 输出格式

Print a single integer — the maximum number of groups of cats at the moment Katie observes.

## 说明/提示

In the first example, originally there are $ 7 $ cats sitting as shown below, creating a single group:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1163A/582841c5dfb385439eea8c43d7ec4b1600b2e8bf.png)At the observed moment, $ 4 $ cats have left the table. Suppose the cats $ 2 $ , $ 3 $ , $ 5 $ and $ 7 $ have left, then there are $ 3 $ groups remaining. It is possible to show that it is the maximum possible number of groups remaining.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1163A/b09fab4219f78478e7216cc25f298db91c1649f6.png)In the second example, there are $ 6 $ cats sitting as shown below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1163A/44c3b731251174253272f06b55bec85d62ac7660.png)At the observed moment, $ 2 $ cats have left the table. Suppose the cats numbered $ 3 $ and $ 6 $ left, then there will be $ 2 $ groups remaining ( $ \{1, 2\} $ and $ \{4, 5\} $ ). It is impossible to have more than $ 2 $ groups of cats remaining.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1163A/b113b3b66afa92745963d53380bedced5a41e1a8.png)In the third example, no cats have left, so there is $ 1 $ group consisting of all cats.

In the fourth example, all cats have left the circle, so there are $ 0 $ groups.

## 样例 #1

### 输入

```
7 4

```

### 输出

```
3

```

## 样例 #2

### 输入

```
6 2

```

### 输出

```
2

```

## 样例 #3

### 输入

```
3 0

```

### 输出

```
1

```

## 样例 #4

### 输入

```
2 2

```

### 输出

```
0

```



---

---
title: "Remainder"
layout: "post"
diff: 普及-
pid: CF1165A
tag: []
---

# Remainder

## 题目描述

Aiming_High神仙给你一个由$n$位数字组成的数，且保证这个数字没有前导零，且每一位数字要么是$0$要么是$1$。



Aiming_High神仙需要你对这个数进行若干次操作（可能是$0$次）。每次操作中，你可以更改其中的任何数位，把这个数位上的数字从$1$变成$0$或从$0$变成$1$。操作后的数可能带有前导零，但并不影响这个问题。



Aiming_High神仙还给了你两个数字$x$，$y$。你要做的是最小化操作次数，使得操作后的数除以$10^x$的余数等于$10^y$。

## 输入格式

输入的第一行包含三个整数$n$，$x$，$y$。



第二行包括一个数，由$n$个数位组成。保证每个数位上的数都是$0$或$1$，且无前导零。

## 输出格式

输出一个整数，表示最小操作次数。

## 样例 #1

### 输入

```
11 5 2
11010100101

```

### 输出

```
1

```

## 样例 #2

### 输入

```
11 5 1
11010100101

```

### 输出

```
3

```



---

---
title: "Polycarp Training"
layout: "post"
diff: 普及-
pid: CF1165B
tag: []
---

# Polycarp Training

## 题目描述

Polycarp wants to train before another programming competition. During the first day of his training he should solve exactly $ 1 $ problem, during the second day — exactly $ 2 $ problems, during the third day — exactly $ 3 $ problems, and so on. During the $ k $ -th day he should solve $ k $ problems.

Polycarp has a list of $ n $ contests, the $ i $ -th contest consists of $ a_i $ problems. During each day Polycarp has to choose exactly one of the contests he didn't solve yet and solve it. He solves exactly $ k $ problems from this contest. Other problems are discarded from it. If there are no contests consisting of at least $ k $ problems that Polycarp didn't solve yet during the $ k $ -th day, then Polycarp stops his training.

How many days Polycarp can train if he chooses the contests optimally?

## 输入格式

The first line of the input contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of contests.

The second line of the input contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 2 \cdot 10^5 $ ) — the number of problems in the $ i $ -th contest.

## 输出格式

Print one integer — the maximum number of days Polycarp can train if he chooses the contests optimally.

## 样例 #1

### 输入

```
4
3 1 4 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3
1 1 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
5
1 1 1 2 2

```

### 输出

```
2

```



---

---
title: "Good String"
layout: "post"
diff: 普及-
pid: CF1165C
tag: []
---

# Good String

## 题目描述

Let's call (yet again) a string good if its length is even, and every character in odd position of this string is different from the next character (the first character is different from the second, the third is different from the fourth, and so on). For example, the strings good, string and xyyx are good strings, and the strings bad, aa and aabc are not good. Note that the empty string is considered good.

You are given a string $ s $ , you have to delete minimum number of characters from this string so that it becomes good.

## 输入格式

The first line contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of characters in $ s $ .

The second line contains the string $ s $ , consisting of exactly $ n $ lowercase Latin letters.

## 输出格式

In the first line, print one integer $ k $ ( $ 0 \le k \le n $ ) — the minimum number of characters you have to delete from $ s $ to make it good.

In the second line, print the resulting string $ s $ . If it is empty, you may leave the second line blank, or not print it at all.

## 样例 #1

### 输入

```
4
good

```

### 输出

```
0
good

```

## 样例 #2

### 输入

```
4
aabc

```

### 输出

```
2
ab

```

## 样例 #3

### 输入

```
3
aaa

```

### 输出

```
3


```



---

---
title: "Silent Classroom"
layout: "post"
diff: 普及-
pid: CF1166A
tag: []
---

# Silent Classroom

## 题目描述

There are $ n $ students in the first grade of Nlogonia high school. The principal wishes to split the students into two classrooms (each student must be in exactly one of the classrooms). Two distinct students whose name starts with the same letter will be chatty if they are put in the same classroom (because they must have a lot in common). Let $ x $ be the number of such pairs of students in a split. Pairs $ (a, b) $ and $ (b, a) $ are the same and counted only once.

For example, if there are $ 6 $ students: "olivia", "jacob", "tanya", "jack", "oliver" and "jessica", then:

- splitting into two classrooms ("jack", "jacob", "jessica", "tanya") and ("olivia", "oliver") will give $ x=4 $ ( $ 3 $ chatting pairs in the first classroom, $ 1 $ chatting pair in the second classroom),
- splitting into two classrooms ("jack", "tanya", "olivia") and ("jessica", "oliver", "jacob") will give $ x=1 $ ( $ 0 $ chatting pairs in the first classroom, $ 1 $ chatting pair in the second classroom).

You are given the list of the $ n $ names. What is the minimum $ x $ we can obtain by splitting the students into classrooms?

Note that it is valid to place all of the students in one of the classrooms, leaving the other one empty.

## 输入格式

The first line contains a single integer $ n $ ( $ 1\leq n \leq 100 $ ) — the number of students.

After this $ n $ lines follow.

The $ i $ -th line contains the name of the $ i $ -th student.

It is guaranteed each name is a string of lowercase English letters of length at most $ 20 $ . Note that multiple students may share the same name.

## 输出格式

The output must consist of a single integer $ x $ — the minimum possible number of chatty pairs.

## 说明/提示

In the first sample the minimum number of pairs is $ 1 $ . This can be achieved, for example, by putting everyone except jose in one classroom, and jose in the other, so jorge and jerry form the only chatty pair.

In the second sample the minimum number of pairs is $ 2 $ . This can be achieved, for example, by putting kambei, gorobei, shichiroji and kyuzo in one room and putting heihachi, katsushiro and kikuchiyo in the other room. In this case the two pairs are kambei and kyuzo, and katsushiro and kikuchiyo.

In the third sample the minimum number of pairs is $ 4 $ . This can be achieved by placing three of the students named mike in one classroom and the other two students in another classroom. Thus there will be three chatty pairs in one classroom and one chatty pair in the other classroom.

## 样例 #1

### 输入

```
4
jorge
jose
oscar
jerry

```

### 输出

```
1

```

## 样例 #2

### 输入

```
7
kambei
gorobei
shichiroji
kyuzo
heihachi
katsushiro
kikuchiyo

```

### 输出

```
2

```

## 样例 #3

### 输入

```
5
mike
mike
mike
mike
mike

```

### 输出

```
4

```



---

---
title: "All the Vowels Please"
layout: "post"
diff: 普及-
pid: CF1166B
tag: []
---

# All the Vowels Please

## 题目描述

Tom loves vowels, and he likes long words with many vowels. His favorite words are vowelly words. We say a word of length $ k $ is vowelly if there are positive integers $ n $ and $ m $ such that $ n\cdot m = k $ and when the word is written by using $ n $ rows and $ m $ columns (the first row is filled first, then the second and so on, with each row filled from left to right), every vowel of the English alphabet appears at least once in every row and every column.

You are given an integer $ k $ and you must either print a vowelly word of length $ k $ or print $ -1 $ if no such word exists.

In this problem the vowels of the English alphabet are 'a', 'e', 'i', 'o' ,'u'.

## 输入格式

Input consists of a single line containing the integer $ k $ ( $ 1\leq k \leq 10^4 $ ) — the required length.

## 输出格式

The output must consist of a single line, consisting of a vowelly word of length $ k $ consisting of lowercase English letters if it exists or $ -1 $ if it does not.

If there are multiple possible words, you may output any of them.

## 说明/提示

In the second example, the word "agoeuioaeiruuimaeoieauoweouoiaouimae" can be arranged into the following $ 6 \times 6 $ grid:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1166B/7d474325157104f047038dc9401e0f23cf51cf99.png)It is easy to verify that every row and every column contain all the vowels.

## 样例 #1

### 输入

```
7

```

### 输出

```
-1

```

## 样例 #2

### 输入

```
36

```

### 输出

```
agoeuioaeiruuimaeoieauoweouoiaouimae
```



---

---
title: "News Distribution"
layout: "post"
diff: 普及-
pid: CF1167C
tag: []
---

# News Distribution

## 题目描述

In some social network, there are $ n $ users communicating with each other in $ m $ groups of friends. Let's analyze the process of distributing some news between users.

Initially, some user $ x $ receives the news from some source. Then he or she sends the news to his or her friends (two users are friends if there is at least one group such that both of them belong to this group). Friends continue sending the news to their friends, and so on. The process ends when there is no pair of friends such that one of them knows the news, and another one doesn't know.

For each user $ x $ you have to determine what is the number of users that will know the news if initially only user $ x $ starts distributing it.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1 \le n, m \le 5 \cdot 10^5 $ ) — the number of users and the number of groups of friends, respectively.

Then $ m $ lines follow, each describing a group of friends. The $ i $ -th line begins with integer $ k_i $ ( $ 0 \le k_i \le n $ ) — the number of users in the $ i $ -th group. Then $ k_i $ distinct integers follow, denoting the users belonging to the $ i $ -th group.

It is guaranteed that $ \sum \limits_{i = 1}^{m} k_i \le 5 \cdot 10^5 $ .

## 输出格式

Print $ n $ integers. The $ i $ -th integer should be equal to the number of users that will know the news if user $ i $ starts distributing it.

## 样例 #1

### 输入

```
7 5
3 2 5 4
0
2 1 2
1 1
2 6 7

```

### 输出

```
4 4 1 4 4 2 2 
```



---

---
title: "Pairs"
layout: "post"
diff: 普及-
pid: CF1169B
tag: []
---

# Pairs

## 题目描述

Toad Ivan has $ m $ pairs of integers, each integer is between $ 1 $ and $ n $ , inclusive. The pairs are $ (a_1, b_1), (a_2, b_2), \ldots, (a_m, b_m) $ .

He asks you to check if there exist two integers $ x $ and $ y $ ( $ 1 \leq x < y \leq n $ ) such that in each given pair at least one integer is equal to $ x $ or $ y $ .

## 输入格式

The first line contains two space-separated integers $ n $ and $ m $ ( $ 2 \leq n \leq 300\,000 $ , $ 1 \leq m \leq 300\,000 $ ) — the upper bound on the values of integers in the pairs, and the number of given pairs.

The next $ m $ lines contain two integers each, the $ i $ -th of them contains two space-separated integers $ a_i $ and $ b_i $ ( $ 1 \leq a_i, b_i \leq n, a_i \neq b_i $ ) — the integers in the $ i $ -th pair.

## 输出格式

Output "YES" if there exist two integers $ x $ and $ y $ ( $ 1 \leq x < y \leq n $ ) such that in each given pair at least one integer is equal to $ x $ or $ y $ . Otherwise, print "NO". You can print each letter in any case (upper or lower).

## 说明/提示

In the first example, you can't choose any $ x $ , $ y $ because for each such pair you can find a given pair where both numbers are different from chosen integers.

In the second example, you can choose $ x=2 $ and $ y=4 $ .

In the third example, you can choose $ x=1 $ and $ y=2 $ .

## 样例 #1

### 输入

```
4 6
1 2
1 3
1 4
2 3
2 4
3 4

```

### 输出

```
NO

```

## 样例 #2

### 输入

```
5 4
1 2
2 3
3 4
4 5

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
300000 5
1 2
1 2
1 2
1 2
1 2

```

### 输出

```
YES

```



---

---
title: "Little Pigs and Wolves"
layout: "post"
diff: 普及-
pid: CF116B
tag: []
---

# Little Pigs and Wolves

## 题目描述

在一个大小为$n*m$的二维网格里有几只猪和几只狼，这个网格里每一个单元只包含一只猪或一只狼。

如果猪和狼在同一条公共边上，则我们就说他们相邻。因为小猪怕狼，所以每只猪旁边只可能会有一只狼，但是每只狼旁边可能会有好几头猪。

狼将选择其中与其相邻的一头并吃掉，此过程将不再重复。也就是说，一头狼只能吃一头猪，而小猪在被吃掉后会消失且不能被别的狼吃。

求最多有多少只猪会被狼吃掉。

## 输入格式

第一行包含两个整数n和m$(1<=n,m<=10)$，分别表示网格的行数和列数。 接下来n行，每行m个字符输入网格。其中“.”表示此格为空，“P”代表小猪，“W”代表狼。

数据保证任意一个小猪至多与一个狼相邻。

## 输出格式

最多有几个小猪会被狼吃掉。

## 样例 #1

### 输入

```
2 3
PPW
W.P

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3 3
P.W
.P.
W.P

```

### 输出

```
0

```



---

---
title: "Nauuo and Chess"
layout: "post"
diff: 普及-
pid: CF1173B
tag: []
---

# Nauuo and Chess

## 题目描述

Nauuo is a girl who loves playing chess.

One day she invented a game by herself which needs $ n $ chess pieces to play on a $ m\times m $ chessboard. The rows and columns are numbered from $ 1 $ to $ m $ . We denote a cell on the intersection of the $ r $ -th row and $ c $ -th column as $ (r,c) $ .

The game's goal is to place $ n $ chess pieces numbered from $ 1 $ to $ n $ on the chessboard, the $ i $ -th piece lies on $ (r_i,\,c_i) $ , while the following rule is satisfied: for all pairs of pieces $ i $ and $ j $ , $ |r_i-r_j|+|c_i-c_j|\ge|i-j| $ . Here $ |x| $ means the absolute value of $ x $ .

However, Nauuo discovered that sometimes she couldn't find a solution because the chessboard was too small.

She wants to find the smallest chessboard on which she can put $ n $ pieces according to the rules.

She also wonders how to place the pieces on such a chessboard. Can you help her?

## 输入格式

The only line contains a single integer $ n $ ( $ 1\le n\le 1000 $ ) — the number of chess pieces for the game.

## 输出格式

The first line contains a single integer — the minimum value of $ m $ , where $ m $ is the length of sides of the suitable chessboard.

The $ i $ -th of the next $ n $ lines contains two integers $ r_i $ and $ c_i $ ( $ 1\le r_i,c_i\le m $ ) — the coordinates of the $ i $ -th chess piece.

If there are multiple answers, print any.

## 说明/提示

In the first example, you can't place the two pieces on a $ 1\times1 $ chessboard without breaking the rule. But you can place two pieces on a $ 2\times2 $ chessboard like this:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1173B/19a9324ad1d9f76a12004b1e06e1a6fc8ea5363a.png)

In the second example, you can't place four pieces on a $ 2\times2 $ chessboard without breaking the rule. For example, if you place the pieces like this:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1173B/dd0c838eb5fa429a4dd839467d147e6034fac9bb.png)

then $ |r_1-r_3|+|c_1-c_3|=|1-2|+|1-1|=1 $ , $ |1-3|=2 $ , $ 1<2 $ ; and $ |r_1-r_4|+|c_1-c_4|=|1-2|+|1-2|=2 $ , $ |1-4|=3 $ , $ 2<3 $ . It doesn't satisfy the rule.

However, on a $ 3\times3 $ chessboard, you can place four pieces like this:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1173B/b7f6bf4dffb399263283db89988092d0fdbbac58.png)

## 样例 #1

### 输入

```
2

```

### 输出

```
2
1 1
1 2
```

## 样例 #2

### 输入

```
4

```

### 输出

```
3
1 1
1 3
3 1
3 3
```



---

---
title: "Ehab Fails to Be Thanos"
layout: "post"
diff: 普及-
pid: CF1174A
tag: []
---

# Ehab Fails to Be Thanos

## 题目描述

You're given an array $ a $ of length $ 2n $ . Is it possible to reorder it in such way so that the sum of the first $ n $ elements isn't equal to the sum of the last $ n $ elements?

## 输入格式

The first line contains an integer $ n $ ( $ 1 \le n \le 1000 $ ), where $ 2n $ is the number of elements in the array $ a $ .

The second line contains $ 2n $ space-separated integers $ a_1 $ , $ a_2 $ , $ \ldots $ , $ a_{2n} $ ( $ 1 \le a_i \le 10^6 $ ) — the elements of the array $ a $ .

## 输出格式

If there's no solution, print "-1" (without quotes). Otherwise, print a single line containing $ 2n $ space-separated integers. They must form a reordering of $ a $ . You are allowed to not change the order.

## 说明/提示

In the first example, the first $ n $ elements have sum $ 2+1+3=6 $ while the last $ n $ elements have sum $ 1+1+2=4 $ . The sums aren't equal.

In the second example, there's no solution.

## 样例 #1

### 输入

```
3
1 2 2 1 3 1

```

### 输出

```
2 1 3 1 1 2
```

## 样例 #2

### 输入

```
1
1 1

```

### 输出

```
-1
```



---

---
title: "Ehab Is an Odd Person"
layout: "post"
diff: 普及-
pid: CF1174B
tag: []
---

# Ehab Is an Odd Person

## 题目描述

You're given an array $ a $ of length $ n $ . You can perform the following operation on it as many times as you want:

- Pick two integers $ i $ and $ j $ $ (1 \le i,j \le n) $ such that  $ a_i+a_j $ is odd, then swap $ a_i $ and $ a_j $ .

What is lexicographically the smallest array you can obtain?

An array $ x $ is [lexicographically smaller](https://en.wikipedia.org/wiki/Lexicographical_order) than an array $ y $ if there exists an index $ i $ such that $ x_i<y_i $ , and $ x_j=y_j $ for all $ 1 \le j < i $ . Less formally, at the first index $ i $ in which they differ, $ x_i<y_i $

## 输入格式

The first line contains an integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the number of elements in the array $ a $ .

The second line contains $ n $ space-separated integers $ a_1 $ , $ a_2 $ , $ \ldots $ , $ a_{n} $ ( $ 1 \le a_i \le 10^9 $ ) — the elements of the array $ a $ .

## 输出格式

The only line contains $ n $ space-separated integers, the lexicographically smallest array you can obtain.

## 说明/提示

In the first example, we can swap $ 1 $ and $ 4 $ since $ 1+4=5 $ , which is odd.

## 样例 #1

### 输入

```
3
4 1 7

```

### 输出

```
1 4 7 
```

## 样例 #2

### 输入

```
2
1 1

```

### 输出

```
1 1 
```



---

---
title: "Ehab and a Special Coloring Problem"
layout: "post"
diff: 普及-
pid: CF1174C
tag: []
---

# Ehab and a Special Coloring Problem

## 题目描述

You're given an integer $ n $ . For every integer $ i $ from $ 2 $ to $ n $ , assign a positive integer $ a_i $ such that the following conditions hold:

- For any pair of integers $ (i,j) $ , if $ i $ and $ j $ are coprime, $ a_i \neq a_j $ .
- The maximal value of all $ a_i $ should be minimized (that is, as small as possible).

A pair of integers is called [coprime](https://en.wikipedia.org/wiki/Coprime_integers) if their [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) is $ 1 $ .

## 输入格式

The only line contains the integer $ n $ ( $ 2 \le n \le 10^5 $ ).

## 输出格式

Print $ n-1 $ integers, $ a_2 $ , $ a_3 $ , $ \ldots $ , $ a_n $ ( $ 1 \leq a_i \leq n $ ).

If there are multiple solutions, print any of them.

## 说明/提示

In the first example, notice that $ 3 $ and $ 4 $ are coprime, so $ a_3 \neq a_4 $ . Also, notice that $ a=[1,2,3] $ satisfies the first condition, but it's not a correct answer because its maximal value is $ 3 $ .

## 样例 #1

### 输入

```
4

```

### 输出

```
1 2 1 
```

## 样例 #2

### 输入

```
3

```

### 输出

```
2 1
```



---

---
title: "From Hero to Zero"
layout: "post"
diff: 普及-
pid: CF1175A
tag: []
---

# From Hero to Zero

## 题目描述

You are given an integer $ n $ and an integer $ k $ .

In one step you can do one of the following moves:

- decrease $ n $ by $ 1 $ ;
- divide $ n $ by $ k $ if $ n $ is divisible by $ k $ .

For example, if $ n = 27 $ and $ k = 3 $ you can do the following steps: $ 27 \rightarrow 26 \rightarrow 25 \rightarrow 24 \rightarrow 8 \rightarrow 7 \rightarrow 6 \rightarrow 2 \rightarrow 1 \rightarrow 0 $ .

You are asked to calculate the minimum number of steps to reach $ 0 $ from $ n $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of queries.

The only line of each query contains two integers $ n $ and $ k $ ( $ 1 \le n \le 10^{18} $ , $ 2 \le k \le 10^{18} $ ).

## 输出格式

For each query print the minimum number of steps to reach $ 0 $ from $ n $ in single line.

## 说明/提示

Steps for the first test case are: $ 59 \rightarrow 58 \rightarrow 57 \rightarrow 19 \rightarrow 18 \rightarrow 6 \rightarrow 2 \rightarrow 1 \rightarrow 0 $ .

In the second test case you have to divide $ n $ by $ k $ $ 18 $ times and then decrease $ n $ by $ 1 $ .

## 样例 #1

### 输入

```
2
59 3
1000000000000000000 10

```

### 输出

```
8
19

```



---

---
title: "Divide it!"
layout: "post"
diff: 普及-
pid: CF1176A
tag: []
---

# Divide it!

## 题目描述

给你一个整数$n$

你可以对这个数进行任意多次（可以为$0$）如下的操作

1. 如果$n$是$2$的倍数，把$n$替换成$\frac{n}{2}$
2. 如果$n$是$3$的倍数，把$n$替换成$\frac{2n}{3}$
3. 如果$n$是$5$的倍数，把$n$替换成$\frac{4n}{5}$

举个例子，你可以通过操作$1$把$30$变成$15$，用操作$2$把$30$变成$20$，用操作$3$把$30$变成$24$

你的任务是找到把$n$变成$1$的最少操作次数，或者说不可能做到

你需要回答$q$个独立的询问

## 输入格式

输入的第一行包括一个整数$q$（$1\leq q\leq 1000$）——询问的数量

接下来$q$行每行一个询问，每个询问给你一个$n$（$1\leq n\leq 10^{18}$）

## 输出格式

对于每个询问一行输出一个答案，如果不可能从$n$变成$1$，输出$-1$；否则输出操作的最少次数

## 样例 #1

### 输入

```
7
1
10
25
30
14
27
1000000000000000000

```

### 输出

```
0
4
6
6
-1
6
72

```



---

---
title: "Digits Sequence (Easy Edition)"
layout: "post"
diff: 普及-
pid: CF1177A
tag: []
---

# Digits Sequence (Easy Edition)

## 题目描述

序列123456789101112131415161718192021222324252627282930313233343536...是无穷无尽的,现在你要输出它的第k项。

## 输入格式

一个整数k。

## 样例 #1

### 输入

```
7

```

### 输出

```
7

```

## 样例 #2

### 输入

```
21

```

### 输出

```
5

```



---

---
title: "Equalize Prices"
layout: "post"
diff: 普及-
pid: CF1183B
tag: []
---

# Equalize Prices

## 题目描述

There are $ n $ products in the shop. The price of the $ i $ -th product is $ a_i $ . The owner of the shop wants to equalize the prices of all products. However, he wants to change prices smoothly.

In fact, the owner of the shop can change the price of some product $ i $ in such a way that the difference between the old price of this product $ a_i $ and the new price $ b_i $ is at most $ k $ . In other words, the condition $ |a_i - b_i| \le k $ should be satisfied ( $ |x| $ is the absolute value of $ x $ ).

He can change the price for each product not more than once. Note that he can leave the old prices for some products. The new price $ b_i $ of each product $ i $ should be positive (i.e. $ b_i > 0 $ should be satisfied for all $ i $ from $ 1 $ to $ n $ ).

Your task is to find out the maximum possible equal price $ B $ of all productts with the restriction that for all products the condiion $ |a_i - B| \le k $ should be satisfied (where $ a_i $ is the old price of the product and $ B $ is the same new price of all products) or report that it is impossible to find such price $ B $ .

Note that the chosen price $ B $ should be integer.

You should answer $ q $ independent queries.

## 输入格式

The first line of the input contains one integer $ q $ ( $ 1 \le q \le 100 $ ) — the number of queries. Each query is presented by two lines.

The first line of the query contains two integers $ n $ and $ k $ ( $ 1 \le n \le 100, 1 \le k \le 10^8 $ ) — the number of products and the value $ k $ . The second line of the query contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^8 $ ), where $ a_i $ is the price of the $ i $ -th product.

## 输出格式

Print $ q $ integers, where the $ i $ -th integer is the answer $ B $ on the $ i $ -th query.

If it is impossible to equalize prices of all given products with restriction that for all products the condition $ |a_i - B| \le k $ should be satisfied (where $ a_i $ is the old price of the product and $ B $ is the new equal price of all products), print -1. Otherwise print the maximum possible equal price of all products.

## 说明/提示

In the first example query you can choose the price $ B=2 $ . It is easy to see that the difference between each old price and each new price $ B=2 $ is no more than $ 1 $ .

In the second example query you can choose the price $ B=6 $ and then all the differences between old and new price $ B=6 $ will be no more than $ 2 $ .

In the third example query you cannot choose any suitable price $ B $ . For any value $ B $ at least one condition out of two will be violated: $ |1-B| \le 2 $ , $ |6-B| \le 2 $ .

In the fourth example query all values $ B $ between $ 1 $ and $ 7 $ are valid. But the maximum is $ 7 $ , so it's the answer.

## 样例 #1

### 输入

```
4
5 1
1 1 2 3 1
4 2
6 4 8 5
2 2
1 6
3 5
5 2 5

```

### 输出

```
2
6
-1
7

```



---

---
title: "Candy Box (easy version)"
layout: "post"
diff: 普及-
pid: CF1183D
tag: []
---

# Candy Box (easy version)

## 题目描述

This problem is actually a subproblem of problem G from the same contest.

There are $ n $ candies in a candy box. The type of the $ i $ -th candy is $ a_i $ ( $ 1 \le a_i \le n $ ).

You have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $ 1 $ and two candies of type $ 2 $ is bad).

It is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.

Your task is to find out the maximum possible size of the single gift you can prepare using the candies you have.

You have to answer $ q $ independent queries.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.

## 输入格式

The first line of the input contains one integer $ q $ ( $ 1 \le q \le 2 \cdot 10^5 $ ) — the number of queries. Each query is represented by two lines.

The first line of each query contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of candies.

The second line of each query contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ), where $ a_i $ is the type of the $ i $ -th candy in the box.

It is guaranteed that the sum of $ n $ over all queries does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each query print one integer — the maximum possible size of the single gift you can compose using candies you got in this query with the restriction described in the problem statement.

## 说明/提示

In the first query, you can prepare a gift with two candies of type $ 8 $ and one candy of type $ 5 $ , totalling to $ 3 $ candies.

Note that this is not the only possible solution — taking two candies of type $ 4 $ and one candy of type $ 6 $ is also valid.

## 样例 #1

### 输入

```
3
8
1 4 8 4 5 6 3 8
16
2 1 3 3 4 3 4 4 1 3 2 2 2 4 1 1
9
2 2 4 4 4 7 7 7 7

```

### 输出

```
3
10
9

```



---

---
title: "Ropewalkers"
layout: "post"
diff: 普及-
pid: CF1185A
tag: []
---

# Ropewalkers

## 题目描述

数轴上有3个整点A,B,C，分别分布在数a,b,c的地方。现需要让三个点之间两两距离不小于d。每秒钟有且仅有一个点可以移动一步，每步可以向左或向右移动恰好1个单位长度。我们想知道：为了达成目标，至少需要多少秒？

## 输入格式

一行，四个正整数a,b,c,d，含义如题所示。

## 输出格式

一行，一个整数，表示答案。

## 说明/提示

对于100%的数据，保证1<=a,b,c,d<=10^9。

## 样例 #1

### 输入

```
5 2 6 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3 1 5 6

```

### 输出

```
8

```

## 样例 #3

### 输入

```
8 3 3 2

```

### 输出

```
2

```

## 样例 #4

### 输入

```
2 3 10 4

```

### 输出

```
3

```



---

---
title: "Email from Polycarp"
layout: "post"
diff: 普及-
pid: CF1185B
tag: []
---

# Email from Polycarp

## 题目描述

Methodius received an email from his friend Polycarp. However, Polycarp's keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once (if you press a key on a regular keyboard, it prints exactly one symbol).

For example, as a result of typing the word "hello", the following words could be printed: "hello", "hhhhello", "hheeeellllooo", but the following could not be printed: "hell", "helo", "hhllllooo".

Note, that when you press a key, the corresponding symbol must appear (possibly, more than once). The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result.

For each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him.

You are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp's keyboard.

## 输入格式

The first line of the input contains one integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the number of pairs to check. Further input contains $ n $ descriptions of pairs.

The first line of each description contains a single non-empty word $ s $ consisting of lowercase Latin letters. The second line of the description contains a single non-empty word $ t $ consisting of lowercase Latin letters. The lengths of both strings are not greater than $ 10^6 $ .

It is guaranteed that the total length of all words $ s $ in the input is not greater than $ 10^6 $ . Also, it is guaranteed that the total length of all words $ t $ in the input is not greater than $ 10^6 $ .

## 输出格式

Output $ n $ lines. In the $ i $ -th line for the $ i $ -th pair of words $ s $ and $ t $ print YES if the word $ t $ could be printed by typing the word $ s $ . Otherwise, print NO.

## 样例 #1

### 输入

```
4
hello
hello
hello
helloo
hello
hlllloo
hello
helo

```

### 输出

```
YES
YES
NO
NO

```

## 样例 #2

### 输入

```
5
aa
bb
codeforces
codeforce
polycarp
poolycarpp
aaaa
aaaab
abcdefghijklmnopqrstuvwxyz
zabcdefghijklmnopqrstuvwxyz

```

### 输出

```
NO
NO
YES
NO
NO

```



---

---
title: "Letters Shop"
layout: "post"
diff: 普及-
pid: CF1187B
tag: []
---

# Letters Shop

## 题目描述

字母商店的橱窗其实是一个由 $n$ 个小写字母组成的字符串 $s$！店如其名，这家店就是卖字母的。

字母商店卖的东西很奇怪，卖的方式更奇怪，它只从左往右卖，意思是说，你只能买这个字符串 $s$ 的前缀。

你有 $m$ 个好基友，第 $i$ 个的名字叫做 $t_i$。他们听说了这家店，都打算来买点字母，来拼出自己的名字，当然买来的字母是可以被打乱顺序或者干脆不用的。他们都想知道至少要买下几个字母才能拼出自己的名字。

举几个例子

- $s="arrayhead" , t_i="arya"$时，必须买下$"\underline{array}head"$ $5$个字母

- $s="arrayhead" , t_i="harry"$时，必须买下$"\underline{arrayh}ead"$ $6$个字母

- $s="arrayhead" , t_i="ray"$时，必须买下$"\underline{array}head"$ $5$个字母

- $s="arrayhead" , t_i="r"$时，必须买下$"\underline{ar}rayhead"$ $2$个字母

- $s="arrayhead" , t_i="areahydra"$时，必须买下$"\underline{arrayhead}"$ $9$个字母

字母商店的字母很齐全，所有的朋友肯定都能拼出自己的名字。

要注意的是，你的朋友们都只是在Doing [window shopping](https://baike.baidu.com/item/%E6%A9%B1%E7%AA%97%E8%B4%AD%E7%89%A9/9473660?fr=aladdin&fromid=8209896&fromtitle=Window+shopping)。他们只要你帮他们算出答案，并不会真正买下这些字母。

## 输入格式

第一行是一个整数 $n(1\leq n \leq 2 \times10^5)$ 表示橱窗 $s$ 的长度

第二行是字符串 $s$

第三行一个整数 $m(1 \leq m \leq 5 \times10^4)$ 表示你的朋友个数

此后 $m$ 行 ,每一行有一个字符串 $t_i(1 \leq |t_i| \leq 2 \times 10^5)$

你的朋友都很正常，所以他们名字总长度不会超过$2\times10^5$

## 输出格式

共$m$行，第 $i$ 行对于第 $i$ 个朋友的询问输出他至少要买下几个字母才能拼出自己的名字。

## 样例 #1

### 输入

```
9
arrayhead
5
arya
harry
ray
r
areahydra

```

### 输出

```
5
6
5
2
9

```



---

---
title: "Number Circle"
layout: "post"
diff: 普及-
pid: CF1189B
tag: []
---

# Number Circle

## 题目描述

You are given $ n $ numbers $ a_1, a_2, \ldots, a_n $ . Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors?

For example, for the array $ [1, 4, 5, 6, 7, 8] $ , the arrangement on the left is valid, while arrangement on the right is not, as $ 5\ge 4 + 1 $ and $ 8> 1 + 6 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1189B/68eb6130a6cefad8260448b1347c6d6d41d81495.png)

## 输入格式

The first line contains a single integer $ n $ ( $ 3\le n \le 10^5 $ ) — the number of numbers.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \le 10^9 $ ) — the numbers. The given numbers are not necessarily distinct (i.e. duplicates are allowed).

## 输出格式

If there is no solution, output "NO" in the first line.

If there is a solution, output "YES" in the first line. In the second line output $ n $ numbers — elements of the array in the order they will stay in the circle. The first and the last element you output are considered neighbors in the circle. If there are multiple solutions, output any of them. You can print the circle starting with any element.

## 说明/提示

One of the possible arrangements is shown in the first example:

 $ 4< 2 + 3 $ ;

 $ 2 < 4 + 3 $ ;

 $ 3< 4 + 2 $ .

One of the possible arrangements is shown in the second example.

No matter how we arrange $ 13, 8, 5 $ in a circle in the third example, $ 13 $ will have $ 8 $ and $ 5 $ as neighbors, but $ 13\ge 8 + 5 $ .

There is no solution in the fourth example.

## 样例 #1

### 输入

```
3
2 4 3

```

### 输出

```
YES
4 2 3 
```

## 样例 #2

### 输入

```
5
1 2 3 4 4

```

### 输出

```
YES
4 4 2 1 3
```

## 样例 #3

### 输入

```
3
13 8 5

```

### 输出

```
NO
```

## 样例 #4

### 输入

```
4
1 10 100 1000

```

### 输出

```
NO
```



---

---
title: "Yet Another Crosses Problem"
layout: "post"
diff: 普及-
pid: CF1194B
tag: []
---

# Yet Another Crosses Problem

## 题目描述

你将会得到若干个 $n$ 行 $m$ 列的矩阵。每一格都被涂成了黑色或白色

若矩阵中的某行，某列都为黑色，则这一行与一列构成了一个十字架

如下所示，这些矩阵都包含了至少一个十字架

![qaq](https://cdn.luogu.org/upload/vjudge_pic/CF1194B/88ab70f483371a989bc0a7f4c7494f932bf59239.png)

而下列矩阵则不包含十字架

![233](https://cdn.luogu.org/upload/vjudge_pic/CF1194B/a3af39e3883913d8cb154cdd61325299208144f4.png)

你的任务是，共有 $q$ 次询问。对于每一次询问，给出一个矩阵，求出至少还要将多少个白色格子涂成黑色，才能使这个矩阵包含至少一个十字架

## 输入格式

第一行包含了一个正整数 $q (1 \leq q \leq 5 \times 10^4)$，意义如上

在每一个询问中，第一行包含了两个正整数 $n, m(1 \leq n, m \leq 5 \times 10^4, n \times m \leq 4 \times 10^5)$，意义如上

接下来会给出 $n$ 行字符，每行 $m$ 个。若第 $i$ 行 $j$ 个字符为 '.'，则代表矩阵的第 $i, j$ 格为白色，'*' 代表黑色

保证 $\displaystyle \sum n \leq 5 \times 10^4$ 且 $\displaystyle \sum n \times m \leq 4 \times 10^5$

## 输出格式

输出 $q$ 行，每行包含一个正整数，要求如上

## 样例 #1

### 输入

```
9
5 5
..*..
..*..
*****
..*..
..*..
3 4
****
.*..
.*..
4 3
***
*..
*..
*..
5 5
*****
*.*.*
*****
..*.*
..***
1 4
****
5 5
.....
..*..
.***.
..*..
.....
5 3
...
.*.
.*.
***
.*.
3 3
.*.
*.*
.*.
4 4
*.**
....
*.**
*.**

```

### 输出

```
0
0
0
0
0
4
1
1
2

```



---

---
title: "Drinks Choosing"
layout: "post"
diff: 普及-
pid: CF1195A
tag: []
---

# Drinks Choosing

## 题目描述

Old timers of Summer Informatics School can remember previous camps in which each student was given a drink of his choice on the vechorka (late-evening meal). Or may be the story was more complicated?

There are $ n $ students living in a building, and for each of them the favorite drink $ a_i $ is known. So you know $ n $ integers $ a_1, a_2, \dots, a_n $ , where $ a_i $ ( $ 1 \le a_i \le k $ ) is the type of the favorite drink of the $ i $ -th student. The drink types are numbered from $ 1 $ to $ k $ .

There are infinite number of drink sets. Each set consists of exactly two portions of the same drink. In other words, there are $ k $ types of drink sets, the $ j $ -th type contains two portions of the drink $ j $ . The available number of sets of each of the $ k $ types is infinite.

You know that students will receive the minimum possible number of sets to give all students exactly one drink. Obviously, the number of sets will be exactly $ \lceil \frac{n}{2} \rceil $ , where $ \lceil x \rceil $ is $ x $ rounded up.

After students receive the sets, they will distribute their portions by their choice: each student will get exactly one portion. Note, that if $ n $ is odd then one portion will remain unused and the students' teacher will drink it.

What is the maximum number of students that can get their favorite drink if $ \lceil \frac{n}{2} \rceil $ sets will be chosen optimally and students will distribute portions between themselves optimally?

## 输入格式

The first line of the input contains two integers $ n $ and $ k $ ( $ 1 \le n, k \le 1\,000 $ ) — the number of students in the building and the number of different drinks.

The next $ n $ lines contain student's favorite drinks. The $ i $ -th line contains a single integer from $ 1 $ to $ k $ — the type of the favorite drink of the $ i $ -th student.

## 输出格式

Print exactly one integer — the maximum number of students that can get a favorite drink.

## 说明/提示

In the first example, students could choose three sets with drinks $ 1 $ , $ 1 $ and $ 2 $ (so they will have two sets with two drinks of the type $ 1 $ each and one set with two drinks of the type $ 2 $ , so portions will be $ 1, 1, 1, 1, 2, 2 $ ). This way all students except the second one will get their favorite drinks.

Another possible answer is sets with drinks $ 1 $ , $ 2 $ and $ 3 $ . In this case the portions will be $ 1, 1, 2, 2, 3, 3 $ . Then all the students except one will gain their favorite drinks. The only student that will not gain the favorite drink will be a student with $ a_i = 1 $ (i.e. the first, the third or the fourth).

## 样例 #1

### 输入

```
5 3
1
3
1
1
2

```

### 输出

```
4

```

## 样例 #2

### 输入

```
10 3
2
1
3
2
3
3
1
3
1
2

```

### 输出

```
9

```



---

---
title: "Sport Mafia"
layout: "post"
diff: 普及-
pid: CF1195B
tag: []
---

# Sport Mafia

## 题目描述

Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia.

For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $ n $ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:

- the first option, in case the box contains at least one candy, is to take exactly one candy out and eat it. This way the number of candies in the box decreased by $ 1 $ ;
- the second option is to put candies in the box. In this case, Alya will put $ 1 $ more candy, than she put in the previous time.

Thus, if the box is empty, then it can only use the second option.

For example, one possible sequence of Alya's actions look as follows:

- put one candy into the box;
- put two candies into the box;
- eat one candy from the box;
- eat one candy from the box;
- put three candies into the box;
- eat one candy from the box;
- put four candies into the box;
- eat one candy from the box;
- put five candies into the box;

This way she will perform $ 9 $ actions, the number of candies at the end will be $ 11 $ , while Alya will eat $ 4 $ candies in total.

You know the total number of actions $ n $ and the number of candies at the end $ k $ . You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $ n $ and $ k $ the answer always exists.

Please note, that during an action of the first option, Alya takes out and eats exactly one candy.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1 \le n \le 10^9 $ ; $ 0 \le k \le 10^9 $ ) — the total number of moves and the number of candies in the box at the end.

It's guaranteed, that for the given $ n $ and $ k $ the answer exists.

## 输出格式

Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data.

## 说明/提示

In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $ 0 $ candies.

In the second example the possible sequence of Alya's actions looks as follows:

- put $ 1 $ candy,
- put $ 2 $ candies,
- eat a candy,
- eat a candy,
- put $ 3 $ candies,
- eat a candy,
- put $ 4 $ candies,
- eat a candy,
- put $ 5 $ candies.

This way, she will make exactly $ n=9 $ actions and in the end the box will contain $ 1+2-1-1+3-1+4-1+5=11 $ candies. The answer is $ 4 $ , since she ate $ 4 $ candies in total.

## 样例 #1

### 输入

```
1 1

```

### 输出

```
0
```

## 样例 #2

### 输入

```
9 11

```

### 输出

```
4
```

## 样例 #3

### 输入

```
5 0

```

### 输出

```
3
```

## 样例 #4

### 输入

```
3 2

```

### 输出

```
1
```



---

---
title: "Robot Breakout"
layout: "post"
diff: 普及-
pid: CF1196C
tag: []
---

# Robot Breakout

## 题目描述

## 题面翻译

有 $n$ 个机器人在一个平面上，第 $i$ 个机器人的位置是 $(X_i,Y_i)$。


在设计的时候，第 $i$ 个机器人可以执行的操作：

1. 位置从 $(X_i,Y_i)$ 变为 $(X_i-1,Y_i)$。

2. 位置从 $(X_i,Y_i)$ 变为 $(X_i,Y_i+1)$。

3. 位置从 $(X_i,Y_i)$ 变为 $(X_i+1,Y_i)$。

4. 位置从 $(X_i,Y_i)$ 变为 $(X_i,Y_i-1)$。

但设计出现了缺陷，某些机器人可能不能执行上述的某些操作。

你需要找一个点 $(A,H)$，使得 $n$ 个机器人都可以到达 $(A,H)$ 。注意，一开始的位置在 $(A,H)$ 也算到达，且对于 $A,H$ 的范围有限制 —— $-10^5\leq A,H \leq 10^5$。

## 输入格式

该题有多组数据。

整个输入的第一行，是一个整数 $q (1\leq q \leq 10^5)$ ，表示数据组数。

对于每组数据，第一行有一个整数 $n$ ，表示机器人的数量。

接下来 $n$ 行，每行 $6$ 个整数 $X_i,Y_i,f_1,f_2,f_3,f_4( - 10^ 5 \leq X_i,Y_i \leq 10^ 5,0 \leq f_1,f_2,f_3,f_4 \leq 1)$。$X_i,Y_i$ 表示这个机器人的坐标，$f_1,f_2,f_3,f_4$ 分别表示第 $i$ 个机器人的上述 $4$ 个功能是否可用。如果$f_{ahak} = 1 (1\leq ahak \leq 4)$，则表示第 $ahak$ 个功能可用，否则不可用。

## 输出格式

对于每组数据，如果无解，输出 $0$。

否则，输出 $1, A, H$，表示所有机器人都可以到达 $(A,H)$。

CF1196C 翻译贡献者 @兹磁洛谷

## 样例 #1

### 输入

```
4
2
-1 -2 0 0 0 0
-1 -2 0 0 0 0
3
1 5 1 1 1 1
2 5 0 1 0 1
3 5 1 0 0 0
2
1337 1337 0 1 1 1
1336 1337 1 1 0 1
1
3 5 1 1 1 1

```

### 输出

```
1 -1 -2
1 2 5
0
1 -100000 -100000

```



---

---
title: "RGB Substring (easy version)"
layout: "post"
diff: 普及-
pid: CF1196D1
tag: []
---

# RGB Substring (easy version)

## 题目描述

The only difference between easy and hard versions is the size of the input.

You are given a string $ s $ consisting of $ n $ characters, each character is 'R', 'G' or 'B'.

You are also given an integer $ k $ . Your task is to change the minimum number of characters in the initial string $ s $ so that after the changes there will be a string of length $ k $ that is a substring of $ s $ , and is also a substring of the infinite string "RGBRGBRGB ...".

A string $ a $ is a substring of string $ b $ if there exists a positive integer $ i $ such that $ a_1 = b_i $ , $ a_2 = b_{i + 1} $ , $ a_3 = b_{i + 2} $ , ..., $ a_{|a|} = b_{i + |a| - 1} $ . For example, strings "GBRG", "B", "BR" are substrings of the infinite string "RGBRGBRGB ..." while "GR", "RGR" and "GGG" are not.

You have to answer $ q $ independent queries.

## 输入格式

The first line of the input contains one integer $ q $ ( $ 1 \le q \le 2000 $ ) — the number of queries. Then $ q $ queries follow.

The first line of the query contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 2000 $ ) — the length of the string $ s $ and the length of the substring.

The second line of the query contains a string $ s $ consisting of $ n $ characters 'R', 'G' and 'B'.

It is guaranteed that the sum of $ n $ over all queries does not exceed $ 2000 $ ( $ \sum n \le 2000 $ ).

## 输出格式

For each query print one integer — the minimum number of characters you need to change in the initial string $ s $ so that after changing there will be a substring of length $ k $ in $ s $ that is also a substring of the infinite string "RGBRGBRGB ...".

## 说明/提示

In the first example, you can change the first character to 'R' and obtain the substring "RG", or change the second character to 'R' and obtain "BR", or change the third, fourth or fifth character to 'B' and obtain "GB".

In the second example, the substring is "BRG".

## 样例 #1

### 输入

```
3
5 2
BGGGG
5 3
RBRGR
5 5
BBBRR

```

### 输出

```
1
0
3

```



---

---
title: "DIY Wooden Ladder"
layout: "post"
diff: 普及-
pid: CF1197A
tag: []
---

# DIY Wooden Ladder

## 题目描述

**PS:此翻译对原题意进行了修改。**  
有$n$个数，依次为$a_1,a_2,a_3...a_n$。  
然后你可以从中选出$k+2$个数（$k$为任意正整数）。  
对于这$k+2$个数字，要满足第二大的数字至少比$k$大$1$。  
问最大的符合条件的$k$为多少。

## 输入格式

本题由$T$组数据构成（$1 \le T \le 100$）  
每一组数据，第一行会给出$n$（$2 \le n \le 10^5$）  
第二行有$n$个数字，第$i$个数字表示$a_i$（$1 \le a_i \le 10^5$）

## 输出格式

对于每一组数据，输出最大的符合条件的$k$。  
### 特别的，如果没有符合条件的$k$，则输出$0$。

## 样例 #1

### 输入

```
4
4
1 3 1 3
3
3 3 2
5
2 3 3 4 2
3
1 1 2

```

### 输出

```
2
1
2
0

```



---

---
title: "Pillars"
layout: "post"
diff: 普及-
pid: CF1197B
tag: []
---

# Pillars

## 题目描述

**题意**

给定$n$个盘子，盘子的半径是$1$到$n$

现在的有$n$个柱子，每个柱子上有一个盘子，问时候能够把所有的盘子移动到一个柱子上

如果要把一个盘子从柱子$i$移动到柱子$j$则要求
1. 柱子$i$上只有一个盘子
2. 柱子$j$上没有盘子，或盘子的半径大于柱子$i$上的盘子
3. $i$，$j$必须相邻

## 输入格式

第一行一个整数$n$

第二行$n$个整数，第$i$个数字$a_i$代表第$i$个柱子上盘子的半径

## 输出格式

如果可以将所有的盘子移动到一个柱子上输出`YES`

反之输出`NO`

## 说明/提示

$3\le n\le 2e5$

$1\le a_i\le n$

## 样例 #1

### 输入

```
4
1 3 4 2

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3
3 1 2

```

### 输出

```
NO

```



---

---
title: "City Day"
layout: "post"
diff: 普及-
pid: CF1199A
tag: []
---

# City Day

## 题目描述

很多年了，N市的节日是在下雨天最严重的那一天举行。新的领导者打算去打破这个传统，并准备选择一个下雨天不是那么严重的一天进行活动。领导者知道$n$天的天气预报。在第$i$天上，下$a_i$毫米的雨。

领导者知道市民们关注$x$天前以及$y$天后的天气。因此，他说假定第$d$天下雨不是那么严重在满足以下情况  
1. 满足$a_d<a_j$  
2. $j$满足$d-x \leq j<d$或者$d<j \leq d+y$ 

由于市民们只看n天，所以j同时还要满足$1 \leq j \leq n$  
请帮助领导者找到下雨不是那么严重的一天

## 输入格式

第一行输入$n$,$x$,$y$，他们满足$1 \leq n \leq 100000$， $0 \leq x,y \leq 7$  
第二行输入$a_1$,$a_2$,...,$a_n$，他们满足$1 \leq a_i \leq 10^9$

## 输出格式

输出最早的下雨不是那么严重的一天

## 说明/提示

#### 第一个样例
第3天和第8天都满足这个条件，第三天更早，所以答案是第三个。

#### 第二个样例
第三天不满足这个条件，因为$3+y=6$ 且 $a_3>a_6$。第8天是答案。请注意：$8+y=11$，然而我们没有第11天，所以无需考虑第11天。

## 样例 #1

### 输入

```
10 2 2
10 9 6 7 8 3 2 1 4 5

```

### 输出

```
3

```

## 样例 #2

### 输入

```
10 2 3
10 9 6 7 8 3 2 1 4 5

```

### 输出

```
8

```

## 样例 #3

### 输入

```
5 5 5
100000 10000 1000 100 10

```

### 输出

```
5

```



---

---
title: "Water Lily"
layout: "post"
diff: 普及-
pid: CF1199B
tag: []
---

# Water Lily

## 题目描述

While sailing on a boat, Inessa noticed a beautiful water lily flower above the lake's surface. She came closer and it turned out that the lily was exactly $ H $ centimeters above the water surface. Inessa grabbed the flower and sailed the distance of $ L $ centimeters. Exactly at this point the flower touched the water surface.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1199B/42f6cea9c2bcade7ac8750d98129857158bca8c3.png)Suppose that the lily grows at some point $ A $ on the lake bottom, and its stem is always a straight segment with one endpoint at point $ A $ . Also suppose that initially the flower was exactly above the point $ A $ , i.e. its stem was vertical. Can you determine the depth of the lake at point $ A $ ?

## 输入格式

The only line contains two integers $ H $ and $ L $ ( $ 1 \le H < L \le 10^{6} $ ).

## 输出格式

Print a single number — the depth of the lake at point $ A $ . The absolute or relative error should not exceed $ 10^{-6} $ .

Formally, let your answer be $ A $ , and the jury's answer be $ B $ . Your answer is accepted if and only if $ \frac{|A - B|}{\max{(1, |B|)}} \le 10^{-6} $ .

## 样例 #1

### 输入

```
1 2

```

### 输出

```
1.5000000000000

```

## 样例 #2

### 输入

```
3 5

```

### 输出

```
2.6666666666667

```



---

---
title: "Important Exam"
layout: "post"
diff: 普及-
pid: CF1201A
tag: []
---

# Important Exam

## 题目描述

A class of students wrote a multiple-choice test.

There are $ n $ students in the class. The test had $ m $ questions, each of them had $ 5 $ possible answers (A, B, C, D or E). There is exactly one correct answer for each question. The correct answer for question $ i $ worth $ a_i $ points. Incorrect answers are graded with zero points.

The students remember what answers they gave on the exam, but they don't know what are the correct answers. They are very optimistic, so they want to know what is the maximum possible total score of all students in the class.

## 输入格式

The first line contains integers $ n $ and $ m $ ( $ 1 \le n, m \le 1000 $ ) — the number of students in the class and the number of questions in the test.

Each of the next $ n $ lines contains string $ s_i $ ( $ |s_i| = m $ ), describing an answer of the $ i $ -th student. The $ j $ -th character represents the student answer (A, B, C, D or E) on the $ j $ -th question.

The last line contains $ m $ integers $ a_1, a_2, \ldots, a_m $ ( $ 1 \le a_i \le 1000 $ ) — the number of points for the correct answer for every question.

## 输出格式

Print a single integer — the maximum possible total score of the class.

## 说明/提示

In the first example, one of the most optimal test answers is "ABCD", this way the total number of points will be $ 16 $ .

In the second example, one of the most optimal test answers is "CCC", this way each question will be answered by exactly one student and the total number of points is $ 5 + 4 + 12 = 21 $ .

## 样例 #1

### 输入

```
2 4
ABCD
ABCE
1 2 3 4

```

### 输出

```
16
```

## 样例 #2

### 输入

```
3 3
ABC
BCD
CDE
5 4 12

```

### 输出

```
21
```



---

---
title: "Circle of Students"
layout: "post"
diff: 普及-
pid: CF1203A
tag: []
---

# Circle of Students

## 题目描述

有 $n$ 个学生按一定的顺序围成一圈，每个学生有一个互不相同的编号 $p_i$ 。

现在这些学生围成一圈跳圆圈舞，他们可以按顺时针或逆时针跳舞，但必须满足以下条件之一：\
1、编号为 $2$ 的学生是编号为 $1$ 的学生的**顺**时针顺序的第一个学生，编号为 $3$ 的学生是编号为 $2$ 的学生的**顺**时针顺序的第一个学生，以此类推。\
2、编号为 $2$ 的学生是编号为 $1$ 的学生的**逆**时针顺序的第一个学生，编号为 $3$ 的学生是编号为 $2$ 的学生的**逆**时针顺序的第一个学生，以此类推。

例如：如果有 $5$ 个学生，按**顺**时针顺序排列的学生的 $p_i$ 为$[2,3,4,5,1]$ ，那就**顺**时针跳舞；如果有 $4$ 个学生，按**顺**时针顺序排列的学生的 $p_i$ 为$[3,2,1,4]$ ，那就**逆**时针跳舞。

一共有 $q$ 组询问。

## 输入格式

第一行输入一个正整数 $q$ ，表示有 $q$ 组询问。\
每组询问分为两行：\
第一行输入一个正整数 $n$ ，表示有 $n$ 个学生。\
第二行输入一行正整数 $p_i$ ，表示按顺时针排列的学生的编号。

## 输出格式

输出共 $q$ 行。\
每一行输出一组询问的答案，如果他们能按顺时针或逆时针跳舞，则输出"YES"；否则输出"NO"。

## 说明/提示

$1\leq n,q\leq 200$\
$1\leq p_i\leq n$

## 样例 #1

### 输入

```
5
4
1 2 3 4
3
1 3 2
5
1 2 3 5 4
1
1
5
3 2 1 5 4

```

### 输出

```
YES
YES
NO
YES
YES

```



---

---
title: "BowWow and the Timetable"
layout: "post"
diff: 普及-
pid: CF1204A
tag: []
---

# BowWow and the Timetable

## 题目描述

已知圣彼得堡的车站会在第 $4^k(k\geq 0)$ 分钟开出新的一趟火车，已知BowWow团队将在第 $s(0\leq s\leq 2^{100})$ 分钟时到达火车站，他们想知道自己错过了多少趟火车；换句话说，在第 $s$ 分钟之前开出了多少趟火车。举个例子，当 $s=20$ 时，他们错过了第 1、4 和 16 分钟的火车。现在只有你知道这个时间 $s$，请你求出他们错过了多少趟火车。

## 输入格式

输入共一行。

第一行输入一串由 0 和 1 组成的数字串(长度$\leq 100$)，为 $s$ 的二进制形式。

## 输出格式

输出一个数，为第 $s$ 分钟前开出的火车数量。

## 样例 #1

### 输入

```
100000000

```

### 输出

```
4

```

## 样例 #2

### 输入

```
101

```

### 输出

```
2

```

## 样例 #3

### 输入

```
10100

```

### 输出

```
3

```



---

---
title: "Make Product Equal One"
layout: "post"
diff: 普及-
pid: CF1206B
tag: []
---

# Make Product Equal One

## 题目描述

给你一个有 $n$ 个数的数组。你可以用 $x$(x为任意正整数) 的代价将数组中的任意一个数增加或减少 $x$ ，你可以重复多次此操作。现在需要你用若干次操作使得 $a_1·a_2·...·a_n = 1$ （数组的乘积为1）。

比如，当 $n=3$ 和数组为 [**1,-3,0**] 时，我们最少需要花费 $3$ 的代价：用 $2$ 的代价把 -$3$ 增加到 -$1$ ，再用 $1$ 的代价把 $0$ 减少到 -$1$ ，数组就变成了 [**1,-1,-1**] ，然后 $1·（-1）·（-1）=1$ 。

现在询问最少需要花费多少的代价使得数组的乘积为 $1$ 。

## 输入格式

输入共两行。

第一行输入一个数 $n$ ，表示数组的数字个数。

第二行输入 $n$ 个数 $a_i$ ，表示该数组。

## 输出格式

输出一个数，表示使得数组的乘积为 $1$ 的最少的花费。

## 说明/提示

$1\leq n\leq 10^5$

$-10^9\leq a_i\leq 10^9$

## 样例 #1

### 输入

```
2
-1 1

```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
0 0 0 0

```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
-5 -3 5 3 0

```

### 输出

```
13
```



---

---
title: "Square Filling"
layout: "post"
diff: 普及-
pid: CF1207B
tag: []
---

# Square Filling

## 题目描述

You are given two matrices $ A $ and $ B $ . Each matrix contains exactly $ n $ rows and $ m $ columns. Each element of $ A $ is either $ 0 $ or $ 1 $ ; each element of $ B $ is initially $ 0 $ .

You may perform some operations with matrix $ B $ . During each operation, you choose any submatrix of $ B $ having size $ 2 \times 2 $ , and replace every element in the chosen submatrix with $ 1 $ . In other words, you choose two integers $ x $ and $ y $ such that $ 1 \le x < n $ and $ 1 \le y < m $ , and then set $ B_{x, y} $ , $ B_{x, y + 1} $ , $ B_{x + 1, y} $ and $ B_{x + 1, y + 1} $ to $ 1 $ .

Your goal is to make matrix $ B $ equal to matrix $ A $ . Two matrices $ A $ and $ B $ are equal if and only if every element of matrix $ A $ is equal to the corresponding element of matrix $ B $ .

Is it possible to make these matrices equal? If it is, you have to come up with a sequence of operations that makes $ B $ equal to $ A $ . Note that you don't have to minimize the number of operations.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 2 \le n, m \le 50 $ ).

Then $ n $ lines follow, each containing $ m $ integers. The $ j $ -th integer in the $ i $ -th line is $ A_{i, j} $ . Each integer is either $ 0 $ or $ 1 $ .

## 输出格式

If it is impossible to make $ B $ equal to $ A $ , print one integer $ -1 $ .

Otherwise, print any sequence of operations that transforms $ B $ into $ A $ in the following format: the first line should contain one integer $ k $ — the number of operations, and then $ k $ lines should follow, each line containing two integers $ x $ and $ y $ for the corresponding operation (set $ B_{x, y} $ , $ B_{x, y + 1} $ , $ B_{x + 1, y} $ and $ B_{x + 1, y + 1} $ to $ 1 $ ). The condition $ 0 \le k \le 2500 $ should hold.

## 说明/提示

The sequence of operations in the first example:

 $ \begin{matrix} 0 & 0 & 0 & & 1 & 1 & 0 & & 1 & 1 & 1 & & 1 & 1 & 1 \\ 0 & 0 & 0 & \rightarrow & 1 & 1 & 0 & \rightarrow & 1 & 1 & 1 & \rightarrow & 1 & 1 & 1 \\ 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 1 & 1 \end{matrix} $

## 样例 #1

### 输入

```
3 3
1 1 1
1 1 1
0 1 1

```

### 输出

```
3
1 1
1 2
2 2

```

## 样例 #2

### 输入

```
3 3
1 0 1
1 0 1
0 0 0

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
3 2
0 0
0 0
0 0

```

### 输出

```
0

```



---

---
title: "XORinacci"
layout: "post"
diff: 普及-
pid: CF1208A
tag: []
---

# XORinacci

## 题目描述

Cengiz recently learned Fibonacci numbers and now he is studying different algorithms to find them. After getting bored of reading them, he came with his own new type of numbers that he named XORinacci numbers. He defined them as follows:

- $ f(0) = a $ ;
- $ f(1) = b $ ;
- $ f(n) = f(n-1) \oplus f(n-2) $ when $ n > 1 $ , where $ \oplus $ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

You are given three integers $ a $ , $ b $ , and $ n $ , calculate $ f(n) $ .

You have to answer for $ T $ independent test cases.

## 输入格式

The input contains one or more independent test cases.

The first line of input contains a single integer $ T $ ( $ 1 \le T \le 10^3 $ ), the number of test cases.

Each of the $ T $ following lines contains three space-separated integers $ a $ , $ b $ , and $ n $ ( $ 0 \le a, b, n \le 10^9 $ ) respectively.

## 输出格式

For each test case, output $ f(n) $ .

## 说明/提示

In the first example, $ f(2) = f(0) \oplus f(1) = 3 \oplus 4 = 7 $ .

## 样例 #1

### 输入

```
3
3 4 2
4 5 0
325 265 1231232

```

### 输出

```
7
4
76

```



---

---
title: "Paint the Numbers"
layout: "post"
diff: 普及-
pid: CF1209A
tag: []
---

# Paint the Numbers

## 题目描述

给出一个长度为$n$的序列$a_1,a_2,a_3,...\ ,a_n$，要求你使用最少的颜色对每个染色。对于任何颜色，满足：染成该颜色的数都能被染成该颜色的最小数整除。

比如$[40,60,10]$可以被染成同一种颜色，因为它们都可以被$10$整除。

每种颜色可以使用一次或多次。染成同一个颜色的所有元素不需要是连续的。请求出最少需要的颜色数量。

## 输入格式

第一行一个正整数$n$，表示序列长度。

第二行$n$个正整数，表示序列的每个元素。

## 输出格式

一个整数，表示至少需要的颜色数量。

## 说明/提示

$1 \leq n \leq 100$, $1 \leq a_i \leq 100$

### 样例解释

样例1：$[ {\color{red}{10}}, {\color{blue}{2}}, {\color{orange}{3}},{\color{red}{5}}, {\color{blue}{4}}, {\color{blue}{2}} ]$

样例2：$[ {\color{red}{100}}, {\color{red}{100}}, {\color{red}{100}},{\color{red}{100}} ]$

样例3：$[ {\color{gray}{7}}, {\color{blue}{6}}, {\color{orange}{5}},{\color{red}{4}}, {\color{blue}{3}}, {\color{red}{2}}, {\color{red}{2}}, {\color{blue}{3}} ]$

## 样例 #1

### 输入

```
6
10 2 3 5 4 2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
4
100 100 100 100

```

### 输出

```
1

```

## 样例 #3

### 输入

```
8
7 6 5 4 3 2 2 3

```

### 输出

```
4

```



---

---
title: "Koala and Lights"
layout: "post"
diff: 普及-
pid: CF1209B
tag: []
---

# Koala and Lights

## 题目描述

有 $n$ 盏灯泡，给定初始状态，第 $i$ 盏灯泡会在 $b_i,b_i+a_i,b_i+2 \times a_i$ 等时刻变成相反的状态，求在某一个时刻亮灯数的最大值。

## 输入格式

第一行包含一个整数 $n$ ($1 \leq n \leq 100$)，表示有 $n$ 盏灯。

下一行包含一个 $n$ 个元素的字符串 $s$，如果 $s_i$ 为 $\verb!1!$，表示第 $i$ 盏灯初始是亮起的；

如果 $s_i$ 为 $\verb!0!$ ，表示第 $i$ 盏灯初始是熄灭的。

接下来 $n$ 行，每行包含两个整数 $a_i$ 和 $b_i$。

## 输出格式

一行，表示在某一时刻亮灯数的最大值。

## 样例 #1

### 输入

```
3
101
3 3
3 2
3 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
4
1111
3 4
5 2
3 1
3 2

```

### 输出

```
4

```

## 样例 #3

### 输入

```
6
011100
5 3
5 5
2 4
3 5
4 2
1 5

```

### 输出

```
6

```



---

---
title: "Three Sons"
layout: "post"
diff: 普及-
pid: CF120D
tag: []
---

# Three Sons

## 题目描述

**题意简述**

给定一个 $n\times m$ 的长方形矩阵，第 $(i,j)$ 个方格上面有一个值 $c_{i,j}$。现在要将矩阵分成三部分，要求两条切割线必须互相平行且与边线平行，不能切开网格，使得切出的三部分每个部分所包含的方格的值的总和分别为 $A$，$B$，$C$。求有多少种切法。

## 输入格式

第一行包含两个整数 $n,m$（$1\le n,m\le 50$，$\max(n,m)\ge 3$）。

接下来 $n$ 行，每行包含 $m$ 个整数 $c_{i,j}$（$0\le c_{i,j}\le 100$），表示矩阵中 $(i,j)$ 的值。

第 $n+2$ 行包含三个整数 $A,B,C$（$0\le A,B,C\le 10^6$），意义如上所示。

## 输出格式

输出一行表示答案。如无解请输出 $0$。

**样例 $1$ 说明**

对于该样例，可横着切亦可竖着切，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pru3h44o.png)

## 样例 #1

### 输入

```
3 3
1 1 1
1 1 1
1 1 1
3 3 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
2 5
1 1 1 1 1
2 2 2 2 2
3 6 6

```

### 输出

```
3

```

## 样例 #3

### 输入

```
3 3
1 2 3
3 1 2
2 3 1
5 6 7

```

### 输出

```
0

```



---

---
title: "Bad Prices"
layout: "post"
diff: 普及-
pid: CF1213B
tag: []
---

# Bad Prices

## 题目描述

Polycarp analyzes the prices of the new berPhone. At his disposal are the prices for $ n $ last days: $ a_1, a_2, \dots, a_n $ , where $ a_i $ is the price of berPhone on the day $ i $ .

Polycarp considers the price on the day $ i $ to be bad if later (that is, a day with a greater number) berPhone was sold at a lower price. For example, if $ n=6 $ and $ a=[3, 9, 4, 6, 7, 5] $ , then the number of days with a bad price is $ 3 $ — these are days $ 2 $ ( $ a_2=9 $ ), $ 4 $ ( $ a_4=6 $ ) and $ 5 $ ( $ a_5=7 $ ).

Print the number of days with a bad price.

You have to answer $ t $ independent data sets.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10000 $ ) — the number of sets of input data in the test. Input data sets must be processed independently, one after another.

Each input data set consists of two lines. The first line contains an integer $ n $ ( $ 1 \le n \le 150000 $ ) — the number of days. The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^6 $ ), where $ a_i $ is the price on the $ i $ -th day.

It is guaranteed that the sum of $ n $ over all data sets in the test does not exceed $ 150000 $ .

## 输出格式

Print $ t $ integers, the $ j $ -th of which should be equal to the number of days with a bad price in the $ j $ -th input data set.

## 样例 #1

### 输入

```
5
6
3 9 4 6 7 5
1
1000000
2
2 1
10
31 41 59 26 53 58 97 93 23 84
7
3 2 1 2 3 4 5

```

### 输出

```
3
0
1
8
2

```



---

---
title: "Optimal Currency Exchange"
layout: "post"
diff: 普及-
pid: CF1214A
tag: []
---

# Optimal Currency Exchange

## 题目描述

Andrew参加了Olympiad of Metropolises，现准备回国，需要兑换货币。

现有如下面额的美元纸币：$1 , 2 , 5 , 10 , 20 , 50 , 100$，以及以下面额的欧元纸币：$5 , 10 , 20 , 50 , 100 , 200$（注意，不考虑$500$欧元纸币，因为在货币兑换窗口很难找到这种）。已知兑换$1$美元需要$d$卢布，$1$欧元需要$e$卢布，而Andrew有$n$卢布。

他可以兑换任意数量的美元和欧元（一种纸币可以兑换多次，可以美元和欧元混合），并且，他希望使兑换后手里剩余的卢布数尽可能少。请你写一个程序帮他解决问题（只需求出最小的剩余卢布数）。

## 输入格式

3行，3个正整数$n,d,e$。

## 输出格式

1行，1个非负整数表示最小剩余量。

## 说明/提示

$1 \leq n \leq 10^8$

$30 \leq d,e \leq 100$

## 样例 #1

### 输入

```
100
60
70

```

### 输出

```
40

```

## 样例 #2

### 输入

```
410
55
70

```

### 输出

```
5

```

## 样例 #3

### 输入

```
600
60
70

```

### 输出

```
0

```



---

---
title: "Yellow Cards"
layout: "post"
diff: 普及-
pid: CF1215A
tag: []
---

# Yellow Cards

## 题目描述

``Berland``足球杯总决赛最近举行了。整场比赛中，裁判出示了$n$张黄牌。比赛一开始，在第一队中有$a_1$个球员而在第二队中有$a_2$个。

在``Berland``足球杯中，把人罚下场的规则与正常规则略有不同。来自第一队的一个球员收到$k_1$张黄牌，他被罚下场并不能继续参加比赛了；来自第二队的球员则需要$k_2$张才会下场。下场的球员不能再收到黄牌。即使某一队（甚至两队）的球员全部被罚下场，比赛仍能继续。

裁判忘记了自己把每张黄牌罚给了谁，所以请你帮助裁判确定可能的被罚下场的人数的最小值和最大值。

## 输入格式

共有5行，每行一个整数$a_1,a_2,k_1,k_2,n$。含义如上文所述。

保证：$1\le a_1,a_2,k_1,k_2\le1000,1\le n\le a_1*k_1+a_2*k_2$。

## 输出格式

一行两个整数，表示可能的被罚下场的球员数的最小值和最大值。

## 说明/提示

在第一个样例中，可能一个球员都没被罚下场，所以最小值是0；最大值是4，1个来自第一队的球员和3个来自第二队的球员。

在第二个样例中，$n$达到了可能出示的黄牌数最大值（$3*6+1*7=25$），所以不论如何所有球员都得下场。

## 样例 #1

### 输入

```
2
3
5
1
8

```

### 输出

```
0 4

```

## 样例 #2

### 输入

```
3
1
6
7
25

```

### 输出

```
4 4

```

## 样例 #3

### 输入

```
6
4
9
10
89

```

### 输出

```
5 9

```



---

---
title: "The Number of Products"
layout: "post"
diff: 普及-
pid: CF1215B
tag: []
---

# The Number of Products

## 题目描述

给出一个由$n$个非零整数构成的序列$a_1,a_2,\dots,a_n$。

你需要计算下列两个值：

1.下标对$(l,r)(l\le r)$使得$a_l*a_{l+1}*\dots*a_r$为负数；

2.下标对$(l,r)(l\le r)$使得$a_l*a_{l+1}*\dots*a_r$为正数；

## 输入格式

第一行包含一个整数$n(1\le n\le2*10^5)$，表示序列的元素个数。

第二行包含$n$个非零整数$a_i(-10^9\le a_i\le10^9;a_i\neq 0)$，表示数列中的各个元素。

## 输出格式

输出两个整数，分别表示乘积为负的子区间个数和乘积为正的子区间个数。

## 样例 #1

### 输入

```
5
5 -3 3 -1 1

```

### 输出

```
8 7

```

## 样例 #2

### 输入

```
10
4 2 -4 3 1 2 -4 3 2 3

```

### 输出

```
28 27

```

## 样例 #3

### 输入

```
5
-1 -2 -3 -4 -5

```

### 输出

```
9 6

```



---

---
title: "2048 Game"
layout: "post"
diff: 普及-
pid: CF1221A
tag: []
---

# 2048 Game

## 题目描述

You are playing a variation of game 2048. Initially you have a multiset $ s $ of $ n $ integers. Every integer in this multiset is a power of two.

You may perform any number (possibly, zero) operations with this multiset.

During each operation you choose two equal integers from $ s $ , remove them from $ s $ and insert the number equal to their sum into $ s $ .

For example, if $ s = \{1, 2, 1, 1, 4, 2, 2\} $ and you choose integers $ 2 $ and $ 2 $ , then the multiset becomes $ \{1, 1, 1, 4, 4, 2\} $ .

You win if the number $ 2048 $ belongs to your multiset. For example, if $ s = \{1024, 512, 512, 4\} $ you can win as follows: choose $ 512 $ and $ 512 $ , your multiset turns into $ \{1024, 1024, 4\} $ . Then choose $ 1024 $ and $ 1024 $ , your multiset turns into $ \{2048, 4\} $ and you win.

You have to determine if you can win this game.

You have to answer $ q $ independent queries.

## 输入格式

The first line contains one integer $ q $ ( $ 1 \le q \le 100 $ ) – the number of queries.

The first line of each query contains one integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of elements in multiset.

The second line of each query contains $ n $ integers $ s_1, s_2, \dots, s_n $ ( $ 1 \le s_i \le 2^{29} $ ) — the description of the multiset. It is guaranteed that all elements of the multiset are powers of two.

## 输出格式

For each query print YES if it is possible to obtain the number $ 2048 $ in your multiset, and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).

## 说明/提示

In the first query you can win as follows: choose $ 512 $ and $ 512 $ , and $ s $ turns into $ \{1024, 64, 1024\} $ . Then choose $ 1024 $ and $ 1024 $ , and $ s $ turns into $ \{2048, 64\} $ and you win.

In the second query $ s $ contains $ 2048 $ initially.

## 样例 #1

### 输入

```
6
4
1024 512 64 512
1
2048
3
64 512 2
2
4096 4
7
2048 2 2048 2048 2048 2048 2048
2
2048 4096

```

### 输出

```
YES
YES
NO
NO
YES
YES

```



---

---
title: "Knights"
layout: "post"
diff: 普及-
pid: CF1221B
tag: []
---

# Knights

## 题目描述

You are given a chess board with $ n $ rows and $ n $ columns. Initially all cells of the board are empty, and you have to put a white or a black knight into each cell of the board.

A knight is a chess piece that can attack a piece in cell ( $ x_2 $ , $ y_2 $ ) from the cell ( $ x_1 $ , $ y_1 $ ) if one of the following conditions is met:

- $ |x_1 - x_2| = 2 $ and $ |y_1 - y_2| = 1 $ , or
- $ |x_1 - x_2| = 1 $ and $ |y_1 - y_2| = 2 $ .

Here are some examples of which cells knight can attack. In each of the following pictures, if the knight is currently in the blue cell, it can attack all red cells (and only them).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1221B/52d6b0891a161fbd4258da7a11dd1ce54ed8afcb.png)A duel of knights is a pair of knights of different colors such that these knights attack each other. You have to put a knight (a white one or a black one) into each cell in such a way that the number of duels is maximum possible.

## 输入格式

The first line contains one integer $ n $ ( $ 3 \le n \le 100 $ ) — the number of rows (and columns) in the board.

## 输出格式

Print $ n $ lines with $ n $ characters in each line. The $ j $ -th character in the $ i $ -th line should be W, if the cell ( $ i $ , $ j $ ) contains a white knight, or B, if it contains a black knight. The number of duels should be maximum possible. If there are multiple optimal answers, print any of them.

## 说明/提示

In the first example, there are $ 8 $ duels:

1. the white knight in ( $ 1 $ , $ 1 $ ) attacks the black knight in ( $ 3 $ , $ 2 $ );
2. the white knight in ( $ 1 $ , $ 1 $ ) attacks the black knight in ( $ 2 $ , $ 3 $ );
3. the white knight in ( $ 1 $ , $ 3 $ ) attacks the black knight in ( $ 3 $ , $ 2 $ );
4. the white knight in ( $ 1 $ , $ 3 $ ) attacks the black knight in ( $ 2 $ , $ 1 $ );
5. the white knight in ( $ 3 $ , $ 1 $ ) attacks the black knight in ( $ 1 $ , $ 2 $ );
6. the white knight in ( $ 3 $ , $ 1 $ ) attacks the black knight in ( $ 2 $ , $ 3 $ );
7. the white knight in ( $ 3 $ , $ 3 $ ) attacks the black knight in ( $ 1 $ , $ 2 $ );
8. the white knight in ( $ 3 $ , $ 3 $ ) attacks the black knight in ( $ 2 $ , $ 1 $ ).

## 样例 #1

### 输入

```
3

```

### 输出

```
WBW
BBB
WBW

```



---

---
title: "Perfect Team"
layout: "post"
diff: 普及-
pid: CF1221C
tag: []
---

# Perfect Team

## 题目描述

您可能已经知道标准的ICPC团队正好由三名成员组成。然而，完美的团队有更多的限制。学生可以有一些专业：编码或数学家。她/他可以没有专业化，但不能同时拥有两者。

因此，如果团队至少包括一名编码员，至少有一名数学家，并且由三名成员组成，那么团队就被认为是完美的。

你是一所非常大的大学的教练，你知道你的学生的$c$ 是编码员，$m$ 是数学家，$x$ 没有专业。

您可以分配给他们的最佳完整团队的最大数量是多少？

请注意，有些学生可能没有团队，每个学生都可以成为一个团队的一员。

您还被要求回答$q$ 个独立查询。

## 输入格式

第一行包含单个整数 $q$（$ 1 \leq q \leq 10 ^4$） ： 查询数量。

每个一个$q$ 包含三个整数$c$ , $m$ 和 $x$ （ 0 $\leq c,m,x \leq 10^8$） ： 分别表示编码员，数学家和没有任何专业的学生的数量。

请注意，没有学生同时是编码员和数学家。

## 输出格式

每行输出 $q$ 个整数，它们的第$i$ 个应该是$i$ 查询的答案，按照它们在输入中给出的顺序。答案是您可以将学生分配到的完整完美团队的最大数量。

## 样例 #1

### 输入

```
6
1 1 1
3 6 0
0 0 0
0 1 1
10 1 10
4 4 1

```

### 输出

```
1
3
0
0
1
3

```



---

---
title: "Forgetting Things"
layout: "post"
diff: 普及-
pid: CF1225A
tag: []
---

# Forgetting Things

## 题目描述

### 题意简述

求不定方程

$$a+1=b$$

且 $a$ 的第一位为 $d_a$，$b$ 的第一位为 $d_b$ 的一组解。

## 输入格式

一行，$d_a,d_b(1\leq d_a,d_b\leq 9)$。

## 输出格式

如果无解请输出 $-1$。

否则请输出 $a,b$。如果有多组解满足条件请输出任意一组。**请注意，输出的 $a,b$ 还必须满足 $1\leq a < b \leq 10^9$**。

翻译贡献者：Meatherm (U108949)

## 样例 #1

### 输入

```
1 2

```

### 输出

```
199 200

```

## 样例 #2

### 输入

```
4 4

```

### 输出

```
412 413

```

## 样例 #3

### 输入

```
5 7

```

### 输出

```
-1

```

## 样例 #4

### 输入

```
6 2

```

### 输出

```
-1

```



---

---
title: "TV Subscriptions (Easy Version)"
layout: "post"
diff: 普及-
pid: CF1225B1
tag: []
---

# TV Subscriptions (Easy Version)

## 题目描述

### 题意简述



给定长度为 $n$ 的序列 $a$，对于 $a_i(1\leq i \leq n)$ 有 $a_i\leq k$。请你找出一段长度为 $d$ 的区间，使得这段区间所包含的不同元素的数量最小。

## 输入格式

第一行一个正整数 $t(1\leq t \leq 100)$ —— 数据组数。



对于每组数据，第一行有三个正整数 $n,k,d(1\leq n,k \leq 100,1\leq d \leq n)$。



接下来一行 $n$ 个正整数 $a_1,a_2,a_3,···a_n$。

## 输出格式

对于每组数据，输出长度为 $d$ 的区间中最小的不同元素的数量。



翻译贡献者：Meatherm (U108949)

## 样例 #1

### 输入

```
4
5 2 2
1 2 1 2 1
9 3 3
3 3 3 2 2 2 1 1 1
4 10 4
10 8 6 4
16 9 8
3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3

```

### 输出

```
2
1
4
5

```



---

---
title: "Math Problem"
layout: "post"
diff: 普及-
pid: CF1227A
tag: []
---

# Math Problem

## 题目描述

你的数学老师给了你以下问题：

在 $x$ 轴上有 $n$ 个段，$[l_1;r_1],[l_2;r_2]\ldots[l_n;r_n]$。段 $[l;r]$ 包括了边界，即它是 $x$ 的集合，其中 $l \leq x \leq r$。段 $[l;r]$ 的长度等于 $r-l$。

两个段 $[a;b]$ 和 $[c;d]$ 有一个公共点（相交）如果存在一个 $x$ 并满足 $a \leq x \leq b$,$c \leq x \leq d$。例如，$[2;5]$ 和 $[3;10]$ 有一个公共点，但是 $[5;6]$ 和 $[1;4]$ 没有。

你应该添加一个线段，使该线段与每个给定线段至少有一个公共点，并且尽可能短（既具有最小长度）。所需的段可以是一个点（及长度为零的一个段）。添加的段可能在给定的 $n$ 段中，也可能不在其中。

换句话说，您需要找到一个段 $[a;b]$，使得 $[a;b]$ 和每个 $[l_i;r_i]$ 有一个公共点，并且 $b-a$ 是最小的。

## 输入格式

第一行包含一个整数 $t(1 \leq t \leq 100)$，表示测试用例数量。然后是 $n$ 个测试用例。

没个测试用例的第一行包含一个整数 $n(1 \leq n \leq 10^5)$，表示段数。以下 $n$ 行描述每一段：其中第 $i$ 个包含两个整数 $l_i,r_i(1 \leq l_i \leq r_i \leq 10^9)$。

输入中的所有测试用例的每个 $n$ 的总和不超过 $10^5$。

## 输出格式

对于每个测试用例，输出一个整数，表示与所有给定段至少有一个公共点的段的最小长度。

## 说明/提示

在样例的第一个测试用例中，我们可以选择分段 $[5;7]$ 作为答案。它是与所有给定线段至少有一个公共点的最短线段。

## 样例 #1

### 输入

```
4
3
4 5
5 9
7 7
5
11 19
4 17
16 16
3 12
14 17
1
1 10
1
1 1

```

### 输出

```
2
4
0
0

```



---

---
title: "Filling the Grid"
layout: "post"
diff: 普及-
pid: CF1228B
tag: []
---

# Filling the Grid

## 题目描述

Suppose there is a $ h \times w $ grid consisting of empty or full cells. Let's make some definitions:

- $ r_{i} $ is the number of consecutive full cells connected to the left side in the $ i $ -th row ( $ 1 \le i \le h $ ). In particular, $ r_i=0 $ if the leftmost cell of the $ i $ -th row is empty.
- $ c_{j} $ is the number of consecutive full cells connected to the top end in the $ j $ -th column ( $ 1 \le j \le w $ ). In particular, $ c_j=0 $ if the topmost cell of the $ j $ -th column is empty.

In other words, the $ i $ -th row starts exactly with $ r_i $ full cells. Similarly, the $ j $ -th column starts exactly with $ c_j $ full cells.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1228B/718cfa57d80806dbeecabcc145703169da7deb79.png)These are the $ r $ and $ c $ values of some $ 3 \times 4 $ grid. Black cells are full and white cells are empty.You have values of $ r $ and $ c $ . Initially, all cells are empty. Find the number of ways to fill grid cells to satisfy values of $ r $ and $ c $ . Since the answer can be very large, find the answer modulo $ 1000000007\,(10^{9} + 7) $ . In other words, find the remainder after division of the answer by $ 1000000007\,(10^{9} + 7) $ .

## 输入格式

The first line contains two integers $ h $ and $ w $ ( $ 1 \le h, w \le 10^{3} $ ) — the height and width of the grid.

The second line contains $ h $ integers $ r_{1}, r_{2}, \ldots, r_{h} $ ( $ 0 \le r_{i} \le w $ ) — the values of $ r $ .

The third line contains $ w $ integers $ c_{1}, c_{2}, \ldots, c_{w} $ ( $ 0 \le c_{j} \le h $ ) — the values of $ c $ .

## 输出格式

Print the answer modulo $ 1000000007\,(10^{9} + 7) $ .

## 说明/提示

In the first example, this is the other possible case.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1228B/9d1150639137da10f3c33f0f1362034ed19afeb9.png)In the second example, it's impossible to make a grid to satisfy such $ r $ , $ c $ values.

In the third example, make sure to print answer modulo $ (10^9 + 7) $ .

## 样例 #1

### 输入

```
3 4
0 3 1
0 2 3 0

```

### 输出

```
2

```

## 样例 #2

### 输入

```
1 1
0
1

```

### 输出

```
0

```

## 样例 #3

### 输入

```
19 16
16 16 16 16 15 15 0 5 0 4 9 9 1 4 4 0 8 16 12
6 12 19 15 8 6 19 19 14 6 9 16 10 11 15 4

```

### 输出

```
797922655

```



---

---
title: "Lucky Division"
layout: "post"
diff: 普及-
pid: CF122A
tag: []
---

# Lucky Division

## 输出格式

感谢@隐鬼在侧 提供的翻译

## 样例 #1

### 输入

```
47

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
16

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
78

```

### 输出

```
NO

```



---

---
title: "Ania and Minimizing"
layout: "post"
diff: 普及-
pid: CF1230B
tag: []
---

# Ania and Minimizing

## 题目描述

Ania has a large integer $ S $ . Its decimal representation has length $ n $ and doesn't contain any leading zeroes. Ania is allowed to change at most $ k $ digits of $ S $ . She wants to do it in such a way that $ S $ still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1 \leq n \leq 200\,000 $ , $ 0 \leq k \leq n $ ) — the number of digits in the decimal representation of $ S $ and the maximum allowed number of changed digits.

The second line contains the integer $ S $ . It's guaranteed that $ S $ has exactly $ n $ digits and doesn't contain any leading zeroes.

## 输出格式

Output the minimal possible value of $ S $ which Ania can end with. Note that the resulting integer should also have $ n $ digits.

## 说明/提示

A number has leading zeroes if it consists of at least two digits and its first digit is $ 0 $ . For example, numbers $ 00 $ , $ 00069 $ and $ 0101 $ have leading zeroes, while $ 0 $ , $ 3000 $ and $ 1010 $ don't have leading zeroes.

## 样例 #1

### 输入

```
5 3
51528

```

### 输出

```
10028

```

## 样例 #2

### 输入

```
3 2
102

```

### 输出

```
100

```

## 样例 #3

### 输入

```
1 1
1

```

### 输出

```
0

```



---

---
title: "Increasing Matrix"
layout: "post"
diff: 普及-
pid: CF1231C
tag: []
---

# Increasing Matrix

## 题目描述

In this problem, a $ n \times m $ rectangular matrix $ a $ is called increasing if, for each row of $ i $ , when go from left to right, the values strictly increase (that is, $ a_{i,1}<a_{i,2}<\dots<a_{i,m} $ ) and for each column $ j $ , when go from top to bottom, the values strictly increase (that is, $ a_{1,j}<a_{2,j}<\dots<a_{n,j} $ ).

In a given matrix of non-negative integers, it is necessary to replace each value of $ 0 $ with some positive integer so that the resulting matrix is increasing and the sum of its elements is maximum, or find that it is impossible.

It is guaranteed that in a given value matrix all values of $ 0 $ are contained only in internal cells (that is, not in the first or last row and not in the first or last column).

## 输入格式

The first line contains integers $ n $ and $ m $ ( $ 3 \le n, m \le 500 $ ) — the number of rows and columns in the given matrix $ a $ .

The following lines contain $ m $ each of non-negative integers — the values in the corresponding row of the given matrix: $ a_{i,1}, a_{i,2}, \dots, a_{i,m} $ ( $ 0 \le a_{i,j} \le 8000 $ ).

It is guaranteed that for all $ a_{i,j}=0 $ , $ 1 < i < n $ and $ 1 < j < m $ are true.

## 输出格式

If it is possible to replace all zeros with positive numbers so that the matrix is increasing, print the maximum possible sum of matrix elements. Otherwise, print -1.

## 说明/提示

In the first example, the resulting matrix is as follows:

```
<pre class="verbatim"><br></br>1 3 5 6 7<br></br>3 6 7 8 9<br></br>5 7 8 9 10<br></br>8 9 10 11 12<br></br>
```

In the second example, the value $ 3 $ must be put in the middle cell.

In the third example, the desired resultant matrix does not exist.

## 样例 #1

### 输入

```
4 5
1 3 5 6 7
3 0 7 0 9
5 0 0 0 10
8 9 10 11 12

```

### 输出

```
144

```

## 样例 #2

### 输入

```
3 3
1 2 3
2 0 4
4 5 6

```

### 输出

```
30

```

## 样例 #3

### 输入

```
3 3
1 2 3
3 0 4
4 5 6

```

### 输出

```
-1

```

## 样例 #4

### 输入

```
3 3
1 2 3
2 3 4
3 4 2

```

### 输出

```
-1

```



---

---
title: "Social Network (easy version)"
layout: "post"
diff: 普及-
pid: CF1234B1
tag: []
---

# Social Network (easy version)

## 题目描述

你知道了将来N次给你发送的消息，而聊天软件一次性只能显示与K(1≤K≤200)个人的聊天记录。

当收到一条消息时，如果与这个人的聊天记录显示在聊天软件中，就什么都不做（注意，不需要把当前聊天记录置顶）；否则，如果当前已经显示了K个聊天记录，则删除最后一个聊天记录；添加与这个人的聊天记录在列表顶端，同时其他聊天记录下移一个位置。

询问在这N条消息发送之后，你的聊天软件最终会显示与哪几个人的聊天记录。

## 输入格式

第一行两个正整数N,K(1≤N,K≤200)，表示N条发来的消息和一次性显示的聊天记录个数。

接下来一行N个正整数id[i] (1≤id[i]≤200)，为第i条消息的发送者。

## 输出格式

第一行，输出最后屏幕上显示的聊天记录个数X。

接下来一行X个正整数，按顺序输出最后屏幕上显示的聊天记录的对象。

## 样例 #1

### 输入

```
7 2
1 2 3 2 1 3 2

```

### 输出

```
2
2 1 

```

## 样例 #2

### 输入

```
10 4
2 3 3 1 1 2 1 2 3 3

```

### 输出

```
3
1 3 2 

```



---

---
title: "Kill 'Em All"
layout: "post"
diff: 普及-
pid: CF1238B
tag: []
---

# Kill 'Em All

## 题目描述

Ivan plays an old action game called Heretic. He's stuck on one of the final levels of this game, so he needs some help with killing the monsters.

The main part of the level is a large corridor (so large and narrow that it can be represented as an infinite coordinate line). The corridor is divided into two parts; let's assume that the point $ x = 0 $ is where these parts meet.

The right part of the corridor is filled with $ n $ monsters — for each monster, its initial coordinate $ x_i $ is given (and since all monsters are in the right part, every $ x_i $ is positive).

The left part of the corridor is filled with crusher traps. If some monster enters the left part of the corridor or the origin (so, its current coordinate becomes less than or equal to $ 0 $ ), it gets instantly killed by a trap.

The main weapon Ivan uses to kill the monsters is the Phoenix Rod. It can launch a missile that explodes upon impact, obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter. Formally, suppose that Ivan launches a missile so that it explodes in the point $ c $ . Then every monster is either killed by explosion or pushed away. Let some monster's current coordinate be $ y $ , then:

- if $ c = y $ , then the monster is killed;
- if $ y < c $ , then the monster is pushed $ r $ units to the left, so its current coordinate becomes $ y - r $ ;
- if $ y > c $ , then the monster is pushed $ r $ units to the right, so its current coordinate becomes $ y + r $ .

Ivan is going to kill the monsters as follows: choose some integer point $ d $ and launch a missile into that point, then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps, then, if at least one monster is still alive, choose another integer point (probably the one that was already used) and launch a missile there, and so on.

What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters? You may assume that every time Ivan fires the Phoenix Rod, he chooses the impact point optimally.

You have to answer $ q $ independent queries.

## 输入格式

The first line contains one integer $ q $ ( $ 1 \le q \le 10^5 $ ) — the number of queries.

The first line of each query contains two integers $ n $ and $ r $ ( $ 1 \le n, r \le 10^5 $ ) — the number of enemies and the distance that the enemies are thrown away from the epicenter of the explosion.

The second line of each query contains $ n $ integers $ x_i $ ( $ 1 \le x_i \le 10^5 $ ) — the initial positions of the monsters.

It is guaranteed that sum of all $ n $ over all queries does not exceed $ 10^5 $ .

## 输出格式

For each query print one integer — the minimum number of shots from the Phoenix Rod required to kill all monsters.

## 说明/提示

In the first test case, Ivan acts as follows:

- choose the point $ 3 $ , the first monster dies from a crusher trap at the point $ -1 $ , the second monster dies from the explosion, the third monster is pushed to the point $ 7 $ ;
- choose the point $ 7 $ , the third monster dies from the explosion.

In the second test case, Ivan acts as follows:

- choose the point $ 5 $ , the first and fourth monsters die from the explosion, the second monster is pushed to the point $ 1 $ , the third monster is pushed to the point $ 2 $ ;
- choose the point $ 2 $ , the first monster dies from a crusher trap at the point $ 0 $ , the second monster dies from the explosion.

## 样例 #1

### 输入

```
2
3 2
1 3 5
4 1
5 2 3 5

```

### 输出

```
2
2

```



---

---
title: "Character Swap (Easy Version)"
layout: "post"
diff: 普及-
pid: CF1243B1
tag: []
---

# Character Swap (Easy Version)

## 题目描述

### 题意简述

给定两个长为 $n$ 的字符串 $s,t$。

您需要进行一次交换：找到一组 $i,j$ 满足 $1\leq i,j \leq n$，交换 $s_i$ 和 $t_j$。

问是否可以通过这次交换使得 $s=t$。

注意：您不能不进行交换。

## 输入格式

第一行一个正整数 $k(1\leq k \leq 10)$，表示数据的组数。

对于每组数据，第一行一个正整数 $n(2\leq n \leq 10^4)$。

接下来一行一个字符串 $s$。

接下来一行一个字符串 $t$。

## 输出格式

对于每组数据，如果可以通过一次交换使得 $s=t$，输出 `Yes`，否则输出 `No`。

您可以输出 `Yes` 和 `No` 的任意大小写形式。当答案为 `Yes` 时，输出 `yes`，`YES`，`YEs`，`yeS` 等答案都会被判为正确。

翻译贡献者 U108949

## 样例 #1

### 输入

```
4
5
souse
houhe
3
cat
dog
2
aa
az
3
abc
bca

```

### 输出

```
Yes
No
No
No

```



---

---
title: "Rooms and Staircases"
layout: "post"
diff: 普及-
pid: CF1244B
tag: []
---

# Rooms and Staircases

## 题目描述

有两层房间，每层 $n$ 个，我们用数对 $(a, b)$ 来表示每个房子，其中 $a$ 表示第几层，$b$ 表示从左向右数第几个

对于房子 $(1, i)$ 或 $(2, i)$，都与 $(1, i - 1), (1, i + 1)$ 或 $(2, i - 1), (2, i + 1)$ 相连

而在若干个或个位置中，又有一个双向的梯子，具体来说，若在 $i$ 的位置有一个梯子，则 $(1, i), (2, i)$ 是相连的

求不重复经过同一个房间的情况下，最多能走过多少个房间

## 输入格式

第一行给出测试数据组数

对于每组测试数据：

第一行给出 $n$，意义如上

第二行给出一个长度为 $n$ 的 $01$ 串，若在 $i$ 位为 $1$，代表在位置 $i$ 有个梯子

## 输出格式

不重复经过同一个房间的情况下，最多能走过多少个房间

## 样例 #1

### 输入

```
4
5
00100
8
00000000
5
11111
3
110

```

### 输出

```
6
8
10
6

```



---

---
title: "Good ol' Numbers Coloring"
layout: "post"
diff: 普及-
pid: CF1245A
tag: []
---

# Good ol' Numbers Coloring

## 题目描述

对于一个非负整数的数列$0,1,2...$，给定两个整数$a,b(1\le a,b\le10^4)$，我们把每个数从小到大染色



每个数字只能被染成黑白两种颜色，而且对$i$染色的规则如下



- 如果$i=0$，则染为白色

- 如果$i\ge a$且$i-a$是白色的，则染为白色

- 如果$i\ge b$且$i-b$是白色的，则染为白色

- 否则染为黑色



举个例子，如果$a=3,b=5$，那么这个序列的染色情况就是（0代表白色，1代表黑色）

$$0,1,1,0,1,0,0,1,0,0,...$$

注意：



- 有可能无限多个数被染为黑色。举个例子，当$a=10,b=10$的时候，只有$10$的倍数是白色的，其余数都是黑色

- 也有可能有限多个数被染为黑色。再举个例子，当$a=1,b=10$的时候，没有一个数是黑色的。



你的任务是判断对于每个$a,b$，数列的黑色数是不是无限的。



如果有无限个数是黑色的，则输出$Infinite$（不含引号）。否则输出$Finite$（不含引号）。

## 输出格式

对于每一组测试数据，输出$Infinite$或$Finite$（不含引号）。输出不区分大小写（就是说$infinite$，$inFiNite$ 或 $finiTE$都是答案）

## 样例 #1

### 输入

```
4
10 10
1 10
6 9
7 3

```

### 输出

```
Infinite
Finite
Infinite
Finite

```



---

---
title: "Integer Points"
layout: "post"
diff: 普及-
pid: CF1248A
tag: []
---

# Integer Points

## 题目描述

DLS and JLS are bored with a Math lesson. In order to entertain themselves, DLS took a sheet of paper and drew $ n $ distinct lines, given by equations $ y = x + p_i $ for some distinct $ p_1, p_2, \ldots, p_n $ .

Then JLS drew on the same paper sheet $ m $ distinct lines given by equations $ y = -x + q_i $ for some distinct $ q_1, q_2, \ldots, q_m $ .

DLS and JLS are interested in counting how many line pairs have integer intersection points, i.e. points with both coordinates that are integers. Unfortunately, the lesson will end up soon, so DLS and JLS are asking for your help.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ), the number of test cases in the input. Then follow the test case descriptions.

The first line of a test case contains an integer $ n $ ( $ 1 \le n \le 10^5 $ ), the number of lines drawn by DLS.

The second line of a test case contains $ n $ distinct integers $ p_i $ ( $ 0 \le p_i \le 10^9 $ ) describing the lines drawn by DLS. The integer $ p_i $ describes a line given by the equation $ y = x + p_i $ .

The third line of a test case contains an integer $ m $ ( $ 1 \le m \le 10^5 $ ), the number of lines drawn by JLS.

The fourth line of a test case contains $ m $ distinct integers $ q_i $ ( $ 0 \le q_i \le 10^9 $ ) describing the lines drawn by JLS. The integer $ q_i $ describes a line given by the equation $ y = -x + q_i $ .

The sum of the values of $ n $ over all test cases in the input does not exceed $ 10^5 $ . Similarly, the sum of the values of $ m $ over all test cases in the input does not exceed $ 10^5 $ .

In hacks it is allowed to use only one test case in the input, so $ t=1 $ should be satisfied.

## 输出格式

For each test case in the input print a single integer — the number of line pairs with integer intersection points.

## 说明/提示

The picture shows the lines from the first test case of the example. Black circles denote intersection points with integer coordinates.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1248A/8a7326901424797e600db27d56ff13441fc9fe8a.png)

## 样例 #1

### 输入

```
3
3
1 3 2
2
0 3
1
1
1
1
1
2
1
1

```

### 输出

```
3
1
0

```



---

---
title: "Grow The Tree"
layout: "post"
diff: 普及-
pid: CF1248B
tag: []
---

# Grow The Tree

## 题目描述

Gardener Alexey teaches competitive programming to high school students. To congratulate Alexey on the Teacher's Day, the students have gifted him a collection of wooden sticks, where every stick has an integer length. Now Alexey wants to grow a tree from them.

The tree looks like a polyline on the plane, consisting of all sticks. The polyline starts at the point $ (0, 0) $ . While constructing the polyline, Alexey will attach sticks to it one by one in arbitrary order. Each stick must be either vertical or horizontal (that is, parallel to $ OX $ or $ OY $ axis). It is not allowed for two consecutive sticks to be aligned simultaneously horizontally or simultaneously vertically. See the images below for clarification.

Alexey wants to make a polyline in such a way that its end is as far as possible from $ (0, 0) $ . Please help him to grow the tree this way.

Note that the polyline defining the form of the tree may have self-intersections and self-touches, but it can be proved that the optimal answer does not contain any self-intersections or self-touches.

## 输入格式

The first line contains an integer $ n $ ( $ 1 \le n \le 100\,000 $ ) — the number of sticks Alexey got as a present.

The second line contains $ n $ integers $ a_1, \ldots, a_n $ ( $ 1 \le a_i \le 10\,000 $ ) — the lengths of the sticks.

## 输出格式

Print one integer — the square of the largest possible distance from $ (0, 0) $ to the tree end.

## 说明/提示

The following pictures show optimal trees for example tests. The squared distance in the first example equals $ 5 \cdot 5 + 1 \cdot 1 = 26 $ , and in the second example $ 4 \cdot 4 + 2 \cdot 2 = 20 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1248B/7db20a2c52bb98904e15a368693f20c8c6e11756.png) ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1248B/f37e132abb11c10bbc7a671b08b806fa38567869.png)

## 样例 #1

### 输入

```
3
1 2 3

```

### 输出

```
26
```

## 样例 #2

### 输入

```
4
1 1 2 2

```

### 输出

```
20
```



---

---
title: "Books Exchange (easy version)"
layout: "post"
diff: 普及-
pid: CF1249B1
tag: []
---

# Books Exchange (easy version)

## 题目描述

The only difference between easy and hard versions is constraints.

There are $ n $ kids, each of them is reading a unique book. At the end of any day, the $ i $ -th kid will give his book to the $ p_i $ -th kid (in case of $ i = p_i $ the kid will give his book to himself). It is guaranteed that all values of $ p_i $ are distinct integers from $ 1 $ to $ n $ (i.e. $ p $ is a permutation). The sequence $ p $ doesn't change from day to day, it is fixed.

For example, if $ n=6 $ and $ p=[4, 6, 1, 3, 5, 2] $ then at the end of the first day the book of the $ 1 $ -st kid will belong to the $ 4 $ -th kid, the $ 2 $ -nd kid will belong to the $ 6 $ -th kid and so on. At the end of the second day the book of the $ 1 $ -st kid will belong to the $ 3 $ -th kid, the $ 2 $ -nd kid will belong to the $ 2 $ -th kid and so on.

Your task is to determine the number of the day the book of the $ i $ -th child is returned back to him for the first time for every $ i $ from $ 1 $ to $ n $ .

Consider the following example: $ p = [5, 1, 2, 4, 3] $ . The book of the $ 1 $ -st kid will be passed to the following kids:

- after the $ 1 $ -st day it will belong to the $ 5 $ -th kid,
- after the $ 2 $ -nd day it will belong to the $ 3 $ -rd kid,
- after the $ 3 $ -rd day it will belong to the $ 2 $ -nd kid,
- after the $ 4 $ -th day it will belong to the $ 1 $ -st kid.

So after the fourth day, the book of the first kid will return to its owner. The book of the fourth kid will return to him for the first time after exactly one day.

You have to answer $ q $ independent queries.

## 输入格式

The first line of the input contains one integer $ q $ ( $ 1 \le q \le 200 $ ) — the number of queries. Then $ q $ queries follow.

The first line of the query contains one integer $ n $ ( $ 1 \le n \le 200 $ ) — the number of kids in the query. The second line of the query contains $ n $ integers $ p_1, p_2, \dots, p_n $ ( $ 1 \le p_i \le n $ , all $ p_i $ are distinct, i.e. $ p $ is a permutation), where $ p_i $ is the kid which will get the book of the $ i $ -th kid.

## 输出格式

For each query, print the answer on it: $ n $ integers $ a_1, a_2, \dots, a_n $ , where $ a_i $ is the number of the day the book of the $ i $ -th child is returned back to him for the first time in this query.

## 样例 #1

### 输入

```
6
5
1 2 3 4 5
3
2 3 1
6
4 6 2 1 5 3
1
1
4
3 4 1 2
5
5 1 2 4 3

```

### 输出

```
1 1 1 1 1 
3 3 3 
2 3 3 2 1 3 
1 
2 2 2 2 
4 4 4 1 4 

```



---

---
title: "Good Numbers (easy version)"
layout: "post"
diff: 普及-
pid: CF1249C1
tag: []
---

# Good Numbers (easy version)

## 题目描述

简单难度与困难难度的唯一差别是$n$的取值范围

现在给出一个定义：Good Number（下文以好数代替），好数是指可以变成$3$的**不同**次幂的加和的数

例如：

$30$ 是好数 $30=3^3+3^1$

$1$ 是好数 $1=3^0$

$12$ 是好数 $12=3^2+3^1$

$2$ 不是好数，因为$2=3^0+3^0$，不符合不同次幂的条件

$19$ 不是好数，例如$19=3^2+3^2+3^0=3^2+3^1+3^1+3^1+3^0$，不符合不同次幂的条件

$20$不是好数，同理不符合不同次幂的条件，无法把$20$分为$3$的不同次幂的加和

现在给你一些正整数$n$，对于每个$n$请你给出一个最小的$m$满足：①$m$是好数 ②$n≤m$

## 输入格式

输入第一行为一个正整数$q(1≤q≤500)$，表示有$q$个样例

然后有$q$行，每行一个正整数$n(1≤n≤10^4)$

## 输出格式

对于每个nnn，输出最小的$m$满足：①$m$是好数 ②$n≤m$。每个输出占一行

## 样例 #1

### 输入

```
7
1
2
6
13
14
3620
10000

```

### 输出

```
1
3
9
13
27
6561
19683

```



---

---
title: "Broken Keyboard"
layout: "post"
diff: 普及-
pid: CF1251A
tag: []
---

# Broken Keyboard

## 题目描述

Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning. For simplicity, we assume that Polycarp's keyboard contains $ 26 $ buttons (one for each letter of the Latin alphabet). Each button is either working fine or malfunctioning.

To check which buttons need replacement, Polycarp pressed some buttons in sequence, and a string $ s $ appeared on the screen. When Polycarp presses a button with character $ c $ , one of the following events happened:

- if the button was working correctly, a character $ c $ appeared at the end of the string Polycarp was typing;
- if the button was malfunctioning, two characters $ c $ appeared at the end of the string.

For example, suppose the buttons corresponding to characters a and c are working correctly, and the button corresponding to b is malfunctioning. If Polycarp presses the buttons in the order a, b, a, c, a, b, a, then the string he is typing changes as follows: a $ \rightarrow $ abb $ \rightarrow $ abba $ \rightarrow $ abbac $ \rightarrow $ abbaca $ \rightarrow $ abbacabb $ \rightarrow $ abbacabba.

You are given a string $ s $ which appeared on the screen after Polycarp pressed some buttons. Help Polycarp to determine which buttons are working correctly for sure (that is, this string could not appear on the screen if any of these buttons was malfunctioning).

You may assume that the buttons don't start malfunctioning when Polycarp types the string: each button either works correctly throughout the whole process, or malfunctions throughout the whole process.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases in the input.

Then the test cases follow. Each test case is represented by one line containing a string $ s $ consisting of no less than $ 1 $ and no more than $ 500 $ lowercase Latin letters.

## 输出格式

For each test case, print one line containing a string $ res $ . The string $ res $ should contain all characters which correspond to buttons that work correctly in alphabetical order, without any separators or repetitions. If all buttons may malfunction, $ res $ should be empty.

## 样例 #1

### 输入

```
4
a
zzaaz
ccff
cbddbb

```

### 输出

```
a
z

bc

```



---

---
title: "Copying Homework"
layout: "post"
diff: 普及-
pid: CF1252A
tag: []
---

# Copying Homework

## 题目描述

Danang and Darto are classmates. They are given homework to create a permutation of $ N $ integers from $ 1 $ to $ N $ . Danang has completed the homework and created a permutation $ A $ of $ N $ integers. Darto wants to copy Danang's homework, but Danang asks Darto to change it up a bit so it does not look obvious that Darto copied.

The difference of two permutations of $ N $ integers $ A $ and $ B $ , denoted by $ diff(A, B) $ , is the sum of the absolute difference of $ A_i $ and $ B_i $ for all $ i $ . In other words, $ diff(A, B) = \Sigma_{i=1}^N |A_i - B_i| $ . Darto would like to create a permutation of $ N $ integers that maximizes its difference with $ A $ . Formally, he wants to find a permutation of $ N $ integers $ B_{max} $ such that $ diff(A, B_{max}) \ge diff(A, B') $ for all permutation of $ N $ integers $ B' $ .

Darto needs your help! Since the teacher giving the homework is lenient, any permutation of $ N $ integers $ B $ is considered different with $ A $ if the difference of $ A $ and $ B $ is at least $ N $ . Therefore, you are allowed to return any permutation of $ N $ integers $ B $ such that $ diff(A, B) \ge N $ .

Of course, you can still return $ B_{max} $ if you want, since it can be proven that $ diff(A, B_{max}) \ge N $ for any permutation $ A $ and $ N > 1 $ . This also proves that there exists a solution for any permutation of $ N $ integers $ A $ . If there is more than one valid solution, you can output any of them.

## 输入格式

Input begins with a line containing an integer: $ N $ ( $ 2 \le N \le 100\,000 $ ) representing the size of Danang's permutation. The next line contains $ N $ integers: $ A_i $ ( $ 1 \le A_i \le N $ ) representing Danang's permutation. It is guaranteed that all elements in $ A $ are distinct.

## 输出格式

Output in a line $ N $ integers (each separated by a single space) representing the permutation of $ N $ integers $ B $ such that $ diff(A, B) \ge N $ . As a reminder, all elements in the permutation must be between $ 1 $ to $ N $ and distinct.

## 说明/提示

Explanation for the sample input/output #1

With $ A = [1, 3, 2, 4] $ and $ B = [4, 2, 3, 1] $ , $ diff(A, B) = |1 - 4| + |3 - 2| + |2 - 3| + |4 - 1| = 3 + 1 + 1 + 3 = 8 $ . Since $ 8 \ge 4 $ , $ [4, 2, 3, 1] $ is one of the valid output for this sample.

## 样例 #1

### 输入

```
4
1 3 2 4

```

### 输出

```
4 2 3 1

```

## 样例 #2

### 输入

```
2
2 1

```

### 输出

```
1 2

```



---

---
title: "Single Push"
layout: "post"
diff: 普及-
pid: CF1253A
tag: []
---

# Single Push

## 题目描述

You're given two arrays $ a[1 \dots n] $ and $ b[1 \dots n] $ , both of the same length $ n $ .

In order to perform a push operation, you have to choose three integers $ l, r, k $ satisfying $ 1 \le l \le r \le n $ and $ k > 0 $ . Then, you will add $ k $ to elements $ a_l, a_{l+1}, \ldots, a_r $ .

For example, if $ a = [3, 7, 1, 4, 1, 2] $ and you choose $ (l = 3, r = 5, k = 2) $ , the array $ a $ will become $ [3, 7, \underline{3, 6, 3}, 2] $ .

You can do this operation at most once. Can you make array $ a $ equal to array $ b $ ?

(We consider that $ a = b $ if and only if, for every $ 1 \le i \le n $ , $ a_i = b_i $ )

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 20 $ ) — the number of test cases in the input.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100\ 000 $ ) — the number of elements in each array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 1000 $ ).

The third line of each test case contains $ n $ integers $ b_1, b_2, \ldots, b_n $ ( $ 1 \le b_i \le 1000 $ ).

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case, output one line containing "YES" if it's possible to make arrays $ a $ and $ b $ equal by performing at most once the described operation or "NO" if it's impossible.

You can print each letter in any case (upper or lower).

## 说明/提示

The first test case is described in the statement: we can perform a push operation with parameters $ (l=3, r=5, k=2) $ to make $ a $ equal to $ b $ .

In the second test case, we would need at least two operations to make $ a $ equal to $ b $ .

In the third test case, arrays $ a $ and $ b $ are already equal.

In the fourth test case, it's impossible to make $ a $ equal to $ b $ , because the integer $ k $ has to be positive.

## 样例 #1

### 输入

```
4
6
3 7 1 4 1 2
3 7 3 6 3 2
5
1 1 1 1 1
1 2 1 3 1
2
42 42
42 42
1
7
6

```

### 输出

```
YES
NO
YES
NO

```



---

---
title: "Fridge Lockers"
layout: "post"
diff: 普及-
pid: CF1255B
tag: []
---

# Fridge Lockers

## 题目描述

## 题意翻译



现在有$n$人，每人都拥有1个冰箱。现提供$m$条铁链，每条铁链可以连接两个冰箱，且只有这两个冰箱的主人可以解锁这条铁链。



只有冰箱上所有铁链都被解锁后，才能打开这个冰箱，如果一个冰箱被铁链加固后只有它的主人可以独自打开它，那么我们称这个冰箱是“私有的”。



另外，如果只有2个冰箱，那么无论有多少条铁链，两个冰箱都不是“私有的”，因为这两个人都可以独自打开对方的冰箱。



在图例中有4个冰箱和5条铁链，所有冰箱都是“私有的”。1号冰箱的主人可以解锁连接1-2和连接1-4的铁链，1号冰箱只能被它的主人独自打开，或者被2号和4号同时打开。



每个冰箱都有一个重量，记为$a_1,a_2,a_3,\ldots,a_n$。如果要给u号和v号冰箱用铁链加固，需要花费$a_u+a_v$元。两个冰箱之间可以有多条铁链加固。



请求出，在将$m$条铁链全部被使用后，所有冰箱是否可能均为“私有的”，如果可能，那么求出最小花费是多少。

## 输入格式

**每个测试点包含多组测试数据**



第一行输入数据组数$T$($1 \le T \le 10$)，接下来输入$T$组数据，每组数据格式如下：



第一行包含两个正整数$n,m$($2 \le n \le 1000,1 \le m \le n $)，分别代表人数和铁链数量。



第二行包含$n$个整数$a_1,a_2,a_3,\ldots,a_n$($0 \le a_i \le 1000$)，代表每个冰箱的重量。

## 输出格式

对于每组测试数据：



- 如果不能使每个冰箱都是“私有的”，输出-1。



- 否则，输出一个整数$c$，代表最小花费。接下来每行，对于第$i$行，输出第$i$条铁链连接的两个冰箱。两个冰箱之间可以有任意多的铁链相连。



如果答案不唯一，输出任意一组。

## 样例 #1

### 输入

```
3
4 4
1 1 1 1
3 1
1 2 3
3 3
1 2 3

```

### 输出

```
8
1 2
4 3
3 2
4 1
-1
12
3 2
1 2
3 1
```



---

---
title: "Payment Without Change"
layout: "post"
diff: 普及-
pid: CF1256A
tag: []
---

# Payment Without Change

## 题目描述

你身上有 $a$ 个 $n$ 元的硬币和 $b$ 个 $1$ 元的硬币。请问能不能在不找零的情况下购买 $s$ 元的物品。

## 输入格式

本题有多组数据。

第一行一个数 $q$ 代表有 $q$ 组数据。

接下来的 $q$ 行，每行有 $4$ 个数，$a,b,n,s$ ，含义如题。

## 输出格式

对于每组数据，如果能在不找零的情况下购买 $s$ 元的物品，则输出"YES" ，反之则输出"NO"。

## 样例 #1

### 输入

```
4
1 2 3 4
1 2 3 6
5 2 6 27
3 3 5 18

```

### 输出

```
YES
NO
NO
YES

```



---

---
title: "Magic Stick"
layout: "post"
diff: 普及-
pid: CF1257B
tag: []
---

# Magic Stick

## 题目描述

Recently Petya walked in the forest and found a magic stick.

Since Petya really likes numbers, the first thing he learned was spells for changing numbers. So far, he knows only two spells that can be applied to a positive integer:

1. If the chosen number $ a $ is even, then the spell will turn it into $ \frac{3a}{2} $ ;
2. If the chosen number $ a $ is greater than one, then the spell will turn it into $ a-1 $ .

Note that if the number is even and greater than one, then Petya can choose which spell to apply.

Petya now has only one number $ x $ . He wants to know if his favorite number $ y $ can be obtained from $ x $ using the spells he knows. The spells can be used any number of times in any order. It is not required to use spells, Petya can leave $ x $ as it is.

## 输入格式

The first line contains single integer $ T $ ( $ 1 \le T \le 10^4 $ ) — the number of test cases. Each test case consists of two lines.

The first line of each test case contains two integers $ x $ and $ y $ ( $ 1 \le x, y \le 10^9 $ ) — the current number and the number that Petya wants to get.

## 输出格式

For the $ i $ -th test case print the answer on it — YES if Petya can get the number $ y $ from the number $ x $ using known spells, and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).

## 样例 #1

### 输入

```
7
2 3
1 1
3 6
6 8
1 2
4 1
31235 6578234

```

### 输出

```
YES
YES
NO
YES
NO
YES
YES

```



---

---
title: "Measuring Lengths in Baden"
layout: "post"
diff: 普及-
pid: CF125A
tag: []
---

# Measuring Lengths in Baden

## 题目描述

Lengths are measures in Baden in inches and feet. To a length from centimeters it is enough to know that an inch equals three centimeters in Baden and one foot contains 12 inches.

You are given a length equal to $ n $ centimeters. Your task is to convert it to feet and inches so that the number of feet was maximum. The result should be an integer rounded to the closest value containing an integral number of inches.

Note that when you round up, 1 cm rounds up to 0 inches and 2 cm round up to 1 inch.

## 输入格式

The only line contains an integer $ n $ ( $ 1<=n<=10000 $ ).

## 输出格式

Print two non-negative space-separated integers $ a $ and $ b $ , where $ a $ is the numbers of feet and $ b $ is the number of inches.

## 样例 #1

### 输入

```
42

```

### 输出

```
1 2

```

## 样例 #2

### 输入

```
5

```

### 输出

```
0 2

```



---

---
title: "Sweet Problem"
layout: "post"
diff: 普及-
pid: CF1263A
tag: []
---

# Sweet Problem

## 题目描述

### 题意简述

有三堆糖果，在同一堆中的糖果颜色相同，但没有两堆糖果的颜色是一样的。

你每天要吃掉两个糖果，但不能吃掉两个颜色相同的糖果。你最多可以吃多少天？

## 输入格式

第一行一个正整数 $t(1\leq t \leq 1000)$ 测试数据的数量。

对于每组测试数据，在一行有三个正整数 $r,g,b(1\leq r,g,b \leq 10^8)$，表示每堆糖果的数量。

## 输出格式

对于每组测试数据，输出一个整数，表示最多可以吃的天数。

翻译贡献者 U108949

## 样例 #1

### 输入

```
6
1 1 1
1 2 1
4 1 1
7 4 10
8 1 4
8 2 8

```

### 输出

```
1
2
2
10
5
9

```



---

---
title: "Beautiful String"
layout: "post"
diff: 普及-
pid: CF1265A
tag: []
---

# Beautiful String

## 题目描述

### 题意简述



给定字符串 $s$，由 `a`，`b`，`c`，`?` 四种字符构成。



您需要将 $s$ 中的所有 `?` 修改为 `a`，`b`，`c` 中的一种，使得 $s$ 相邻两个字符均不相同。

## 输入格式

第一行是一个整数 $t(t≤1000)$，表示数据组数。



对于每组数据，一行一个字符串 $s$，**保证满足上述限制**。



保证 $s$ 的长度之和不超过 $10^5$。

## 输出格式

对于每组数据，输出一行一个字符串，表示修改之后的 $s$。如果有多组解，输出**任意一组**。如果无解，输出 `-1`。



翻译贡献者 U108949

## 样例 #1

### 输入

```
3
a???cb
a??bbc
a?b?c

```

### 输出

```
ababcb
-1
acbac

```



---

---
title: "Competitive Programmer"
layout: "post"
diff: 普及-
pid: CF1266A
tag: []
---

# Competitive Programmer

## 题目描述

Bob is a competitive programmer. He wants to become red, and for that he needs a strict training regime. He went to the annual meeting of grandmasters and asked $ n $ of them how much effort they needed to reach red.

"Oh, I just spent $ x_i $ hours solving problems", said the $ i $ -th of them.

Bob wants to train his math skills, so for each answer he wrote down the number of minutes ( $ 60 \cdot x_i $ ), thanked the grandmasters and went home. Bob could write numbers with leading zeroes — for example, if some grandmaster answered that he had spent $ 2 $ hours, Bob could write $ 000120 $ instead of $ 120 $ .

Alice wanted to tease Bob and so she took the numbers Bob wrote down, and for each of them she did one of the following independently:

- rearranged its digits, or
- wrote a random number.

This way, Alice generated $ n $ numbers, denoted $ y_1 $ , ..., $ y_n $ .

For each of the numbers, help Bob determine whether $ y_i $ can be a permutation of a number divisible by $ 60 $ (possibly with leading zeroes).

## 输入格式

The first line contains a single integer $ n $ ( $ 1 \leq n \leq 418 $ ) — the number of grandmasters Bob asked.

Then $ n $ lines follow, the $ i $ -th of which contains a single integer $ y_i $ — the number that Alice wrote down.

Each of these numbers has between $ 2 $ and $ 100 $ digits '0' through '9'. They can contain leading zeroes.

## 输出格式

Output $ n $ lines.

For each $ i $ , output the following. If it is possible to rearrange the digits of $ y_i $ such that the resulting number is divisible by $ 60 $ , output "red" (quotes for clarity). Otherwise, output "cyan".

## 说明/提示

In the first example, there is one rearrangement that yields a number divisible by $ 60 $ , and that is $ 360 $ .

In the second example, there are two solutions. One is $ 060 $ and the second is $ 600 $ .

In the third example, there are $ 6 $ possible rearrangments: $ 025 $ , $ 052 $ , $ 205 $ , $ 250 $ , $ 502 $ , $ 520 $ . None of these numbers is divisible by $ 60 $ .

In the fourth example, there are $ 3 $ rearrangements: $ 228 $ , $ 282 $ , $ 822 $ .

In the fifth example, none of the $ 24 $ rearrangements result in a number divisible by $ 60 $ .

In the sixth example, note that $ 000\dots0 $ is a valid solution.

## 样例 #1

### 输入

```
6
603
006
205
228
1053
0000000000000000000000000000000000000000000000

```

### 输出

```
red
red
cyan
cyan
cyan
red

```



---

---
title: "Dice Tower"
layout: "post"
diff: 普及-
pid: CF1266B
tag: []
---

# Dice Tower

## 题目描述

鲍勃正在玩 $6$ 面的骰子。他有不限量的这样的骰子。骰子可以搭成骰子塔，骰子塔上可以看见的点子的数量称为骰子塔的点数。

## 输入格式

有两行。第一行包含一个整数 $T$，表示 $T$ 次询问。第二行包含 $T$ 个整数 $x$，表示骰子塔的点数。

## 输出格式

有 $T$ 行，表示每一次询问的结果。如果可以搭成有 $x$ 个点数的骰子塔输出`YES`，否则输出`NO`。

## 样例 #1

### 输入

```
4
29 34 19 38

```

### 输出

```
YES
YES
YES
NO

```



---

---
title: "Three Friends"
layout: "post"
diff: 普及-
pid: CF1272A
tag: []
---

# Three Friends

## 题目描述

有三个人站在一个平面直角坐标系的$x$轴上，他们的纵坐标分别为$a,b,c$  
定义这三个的距离和为$|a-b|+|b-c|+|a-c|$

接下来的一分钟，他们每一个人可以选择：向左走一个单位长度 或 向右走一个单位长度，求一分钟后的三个人的最小距离和

## 输入格式

第一行一个整数$q$，表示有$q$组数据  
接下来$q$行，每行三个整数$a,b,c$，如题所述

## 输出格式

$q$行，每行一个整数，对应每组数据，表示一分钟后三个人的最小距离和

## 说明/提示

$1\leq q \le 1000$  
$1\leq a,b,c \le 10^9$  
感谢 @_Wolverine  提供的翻译

## 样例 #1

### 输入

```
8
3 3 4
10 20 30
5 5 5
2 4 3
1 1000000000 1000000000
1 1000000000 999999999
3 2 5
3 2 6

```

### 输出

```
0
36
0
0
1999999994
1999999994
2
4

```



---

---
title: "As Simple as One and Two"
layout: "post"
diff: 普及-
pid: CF1276A
tag: []
---

# As Simple as One and Two

## 题目描述

You are given a non-empty string $ s=s_1s_2\dots s_n $ , which consists only of lowercase Latin letters. Polycarp does not like a string if it contains at least one string "one" or at least one string "two" (or both at the same time) as a substring. In other words, Polycarp does not like the string $ s $ if there is an integer $ j $ ( $ 1 \le j \le n-2 $ ), that $ s_{j}s_{j+1}s_{j+2}= $ "one" or $ s_{j}s_{j+1}s_{j+2}= $ "two".

For example:

- Polycarp does not like strings "oneee", "ontwow", "twone" and "oneonetwo" (they all have at least one substring "one" or "two"),
- Polycarp likes strings "oonnee", "twwwo" and "twnoe" (they have no substrings "one" and "two").

Polycarp wants to select a certain set of indices (positions) and remove all letters on these positions. All removals are made at the same time.

For example, if the string looks like $ s= $ "onetwone", then if Polycarp selects two indices $ 3 $ and $ 6 $ , then "onetwone" will be selected and the result is "ontwne".

What is the minimum number of indices (positions) that Polycarp needs to select to make the string liked? What should these positions be?

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the input. Next, the test cases are given.

Each test case consists of one non-empty string $ s $ . Its length does not exceed $ 1.5\cdot10^5 $ . The string $ s $ consists only of lowercase Latin letters.

It is guaranteed that the sum of lengths of all lines for all input data in the test does not exceed $ 1.5\cdot10^6 $ .

## 输出格式

Print an answer for each test case in the input in order of their appearance.

The first line of each answer should contain $ r $ ( $ 0 \le r \le |s| $ ) — the required minimum number of positions to be removed, where $ |s| $ is the length of the given line. The second line of each answer should contain $ r $ different integers — the indices themselves for removal in any order. Indices are numbered from left to right from $ 1 $ to the length of the string. If $ r=0 $ , then the second line can be skipped (or you can print empty). If there are several answers, print any of them.

## 说明/提示

In the first example, answers are:

- "onetwone",
- "testme" — Polycarp likes it, there is nothing to remove,
- "oneoneone",
- "twotwo".

In the second example, answers are:

- "onetwonetwooneooonetwooo",
- "two",
- "one",
- "twooooo",
- "ttttwo",
- "ttwwoo" — Polycarp likes it, there is nothing to remove,
- "ooone",
- "onnne" — Polycarp likes it, there is nothing to remove,
- "oneeeee",
- "oneeeeeeetwooooo".

## 样例 #1

### 输入

```
4
onetwone
testme
oneoneone
twotwo

```

### 输出

```
2
6 3
0

3
4 1 7 
2
1 4

```

## 样例 #2

### 输入

```
10
onetwonetwooneooonetwooo
two
one
twooooo
ttttwo
ttwwoo
ooone
onnne
oneeeee
oneeeeeeetwooooo

```

### 输出

```
6
18 11 12 1 6 21 
1
1 
1
3 
1
2 
1
6 
0

1
4 
0

1
1 
2
1 11 

```



---

---
title: "Happy Birthday, Polycarp!"
layout: "post"
diff: 普及-
pid: CF1277A
tag: []
---

# Happy Birthday, Polycarp!

## 题目描述

Hooray! Polycarp turned $ n $ years old! The Technocup Team sincerely congratulates Polycarp!

Polycarp celebrated all of his $ n $ birthdays: from the $ 1 $ -th to the $ n $ -th. At the moment, he is wondering: how many times he turned beautiful number of years?

According to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $ 1 $ , $ 77 $ , $ 777 $ , $ 44 $ and $ 999999 $ . The following numbers are not beautiful: $ 12 $ , $ 11110 $ , $ 6969 $ and $ 987654321 $ .

Of course, Polycarpus uses the decimal numeral system (i.e. radix is 10).

Help Polycarpus to find the number of numbers from $ 1 $ to $ n $ (inclusive) that are beautiful.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the input. Then $ t $ test cases follow.

Each test case consists of one line, which contains a positive integer $ n $ ( $ 1 \le n \le 10^9 $ ) — how many years Polycarp has turned.

## 输出格式

Print $ t $ integers — the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between $ 1 $ and $ n $ , inclusive.

## 说明/提示

In the first test case of the example beautiful years are $ 1 $ , $ 2 $ , $ 3 $ , $ 4 $ , $ 5 $ , $ 6 $ , $ 7 $ , $ 8 $ , $ 9 $ and $ 11 $ .

## 样例 #1

### 输入

```
6
18
1
9
100500
33
1000000000

```

### 输出

```
10
1
9
45
12
81

```



---

---
title: "Shuffle Hashing"
layout: "post"
diff: 普及-
pid: CF1278A
tag: []
---

# Shuffle Hashing

## 题目描述

Polycrap正在建立他自己的网页服务。作为一个很现代的网站其包含登入的功能。当然，这总会涉及到密码的安全问题。

Polycarp决定要储存密码的哈希值。密码的哈希值由以下这个算法来生成：

1.把只包含小写拉丁字母的密码$p$进行随机打乱，记为$p'$（$p'$可能和$p$相等）；

2.生成两个随机的只包含小写拉丁字母的字符串$s_1$和$s_2$（这两个串中的任何一个可能为空串）；

3.哈希算法的结果$h=s_1+p'+s_2$，此处的$+$是指把前后两个字符串首尾相接。

举个例子，$p=\texttt {abacaba}$，则$p'$可能为$\texttt{aabcaab}$。随机生成两个字符串$s_1=\texttt{zyx}",s_2=\texttt{kjh}$。那么$h=\texttt{zyxaabcaabkjh}$。

需要注意的是，从$p$变换道$p'$的过程中，不会添加或者删除任何字母，只会改变字母的顺序。

现在Polycarp想让你帮他编写密码哈希的校验模块。给出密码$p$和生成的哈希$h$，你需要检查$h$是否是$p$的一个哈希结果。

## 输入格式

第一行包含了一个正整数$t(1\leq t\leq100)$——查询的次数。

每一次查询的第一行包含了一个由小写拉丁字母组成的非空字符串$p$。$p$的长度不超过$100$。

每一次查询的第二行包含了一个由小写拉丁字母组成的非空字符串$h$。$h$的长度不超过$100$。

## 输出格式

对于每一次查询，如果$h$是$p$的一个哈希结果，就输出"YES"，反之输出"NO"。

## 说明/提示

第一组查询的解释已经在题干中给出。

第二组查询中$s_1$和$s_2$均是空串，$p'$是$p$的一种打乱。

第三组查询中哈希不能通过密码生成。

第四组查询中$s_1=\texttt{n}$，$s_2$是空串，$p'=\texttt{one}$是$p$的一种打乱（虽然打乱并没有效果）。

第五组查询中哈希不能通过密码生成。

## 样例 #1

### 输入

```
5
abacaba
zyxaabcaabkjh
onetwothree
threetwoone
one
zzonneyy
one
none
twenty
ten

```

### 输出

```
YES
YES
NO
YES
NO

```



---

---
title: "Verse For Santa"
layout: "post"
diff: 普及-
pid: CF1279B
tag: []
---

# Verse For Santa

## 题目描述

### 题意简述

给定正整数 $n$，$s$ 和长为 $n$ 的整数数列 $a_1,a_2,...,a_n$。

求一个最大的 $i$，使得存在一个 $j$ 满足 $1\leq j\leq i$，让 $(\sum_{k=1}^{i} a_k) -a_j \leq s$ 。

## 输入格式

**本题有多组数据**。

第一行一个正整数 $t(1\leq t\leq 100)$，表示数据组数。

对于每组数据，第一行两个正整数 $n$，$s(1\leq n \leq 10^5,1\leq s \leq 10^9)$。

接下来一行 $n$ 个整数 $a_1,a_2,...,a_n(1\leq a_i \leq 10^9)$。

保证输入的 $n$ 之和不超过 $10^5$。

## 输出格式

对于每组数据，输出 $j$，意义如题意所述。如果存在多个 $j$ 输出任意一个。

特殊的，如果 $\sum_{i=1}^{n} a_i \leq s$，输出 $0$。

## 样例 #1

### 输入

```
3
7 11
2 9 1 3 18 1 4
4 35
11 9 10 7
1 8
5

```

### 输出

```
2
1
0

```



---

---
title: "Wasted Time"
layout: "post"
diff: 普及-
pid: CF127A
tag: []
---

# Wasted Time

## 题目描述

Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.

Mr. Scrooge's signature can be represented as a polyline $ A_{1}A_{2}...\ A_{n} $ . Scrooge signs like that: first it places a pen at the point $ A_{1} $ , then draws a segment from point $ A_{1} $ to point $ A_{2} $ , then he draws a segment from point $ A_{2} $ to point $ A_{3} $ and so on to point $ A_{n} $ , where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — $ 50 $ millimeters per second.

Scrooge signed exactly $ k $ papers throughout his life and all those signatures look the same.

Find the total time Scrooge wasted signing the papers.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 2<=n<=100 $ , $ 1<=k<=1000 $ ). Each of the following $ n $ lines contains the coordinates of the polyline's endpoints. The $ i $ -th one contains coordinates of the point $ A_{i} $ — integers $ x_{i} $ and $ y_{i} $ , separated by a space.

All points $ A_{i} $ are different. The absolute value of all coordinates does not exceed $ 20 $ . The coordinates are measured in millimeters.

## 输出格式

Print one real number — the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed $ 10^{-6} $ .

## 样例 #1

### 输入

```
2 1
0 0
10 0

```

### 输出

```
0.200000000
```

## 样例 #2

### 输入

```
5 10
3 1
-5 6
-2 -1
3 2
10 0

```

### 输出

```
6.032163204
```

## 样例 #3

### 输入

```
6 10
5 0
4 0
6 0
3 0
7 0
2 0

```

### 输出

```
3.000000000
```



---

---
title: "Temporarily unavailable"
layout: "post"
diff: 普及-
pid: CF1282A
tag: []
---

# Temporarily unavailable

## 题目描述

Polycarp lives on the coordinate axis $ Ox $ and travels from the point $ x=a $ to $ x=b $ . It moves uniformly rectilinearly at a speed of one unit of distance per minute.

On the axis $ Ox $ at the point $ x=c $ the base station of the mobile operator is placed. It is known that the radius of its coverage is $ r $ . Thus, if Polycarp is at a distance less than or equal to $ r $ from the point $ x=c $ , then he is in the network coverage area, otherwise — no. The base station can be located both on the route of Polycarp and outside it.

Print the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $ x=a $ to $ x=b $ . His speed — one unit of distance per minute.

## 输入格式

The first line contains a positive integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. In the following lines are written $ t $ test cases.

The description of each test case is one line, which contains four integers $ a $ , $ b $ , $ c $ and $ r $ ( $ -10^8 \le a,b,c \le 10^8 $ , $ 0 \le r \le 10^8 $ ) — the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.

Any of the numbers $ a $ , $ b $ and $ c $ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.

## 输出格式

Print $ t $ numbers — answers to given test cases in the order they are written in the test. Each answer is an integer — the number of minutes during which Polycarp will be unavailable during his movement.

## 说明/提示

The following picture illustrates the first test case.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1282A/307b325125eb4f2400d0fb03b9026999f9da2b19.png)Polycarp goes from $ 1 $ to $ 10 $ . The yellow area shows the coverage area of the station with a radius of coverage of $ 1 $ , which is located at the point of $ 7 $ . The green area shows a part of the path when Polycarp is out of coverage area.

## 样例 #1

### 输入

```
9
1 10 7 1
3 3 3 0
8 2 10 4
8 2 10 100
-10 20 -17 2
-3 2 2 0
-3 1 2 0
2 3 2 3
-1 3 -2 2

```

### 输出

```
7
0
4
0
30
5
4
0
3

```



---

---
title: "Just Eat It!"
layout: "post"
diff: 普及-
pid: CF1285B
tag: []
---

# Just Eat It!

## 题目描述

### 题意简述

给定长度为 $n$ 的数列 $a=[a_1,a_2,...,a_n]$。

Yasser 会选择所有的 $n$ 个数，并算出它们的和 $\sum a_i$。

Adel 会选择两个正整数 $l,r(1\leq l \leq r \leq n)$，并算出 $\sum_{i=l}^{r} a_i$。Adel 不能选择 $l=1,r=n$。

如果 Yasser 算出的和在任意情况下（即 Adel 选取任意的 $l,r$ 都是如此）**严格大于** Adel 算出的，那么 Yasser 会开心。否则 Yasser 不会开心。

请你判断 Yasser 是否开心。

## 输入格式

**本题有多组数据**。

第一行一个正整数 $t(1\leq t \leq 10^4)$，表示数据的组数。

对于每组数据，第一行一个正整数 $n(2\leq n \leq 10^5)$。

接下来一行 $a_1,a_2,...,a_n(-10^{9} \leq a_i \leq 10^9)$。

保证 $\sum n$ 不会超过 $10^5$。

## 输出格式

对于每组数据，如果 Yasser 会开心，输出 `YES`，否则输出 `NO`。

翻译贡献者 U108949

## 样例 #1

### 输入

```
3
4
1 2 3 4
3
7 4 -1
3
5 -5 5
```

### 输出

```
YES
NO
NO
```



---

---
title: "Yet Another Meme Problem"
layout: "post"
diff: 普及-
pid: CF1288B
tag: []
---

# Yet Another Meme Problem

## 题目描述

Try guessing the statement from this picture <http://tiny.cc/ogyoiz>.

You are given two integers $ A $ and $ B $ , calculate the number of pairs $ (a, b) $ such that $ 1 \le a \le A $ , $ 1 \le b \le B $ , and the equation $ a \cdot b + a + b = conc(a, b) $ is true; $ conc(a, b) $ is the concatenation of $ a $ and $ b $ (for example, $ conc(12, 23) = 1223 $ , $ conc(100, 11) = 10011 $ ).  $ a $ and $ b $ should not contain leading zeroes.

## 输入格式

The first line contains $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

Each test case contains two integers $ A $ and $ B $ $ (1 \le A, B \le 10^9) $ .

## 输出格式

Print one integer — the number of pairs $ (a, b) $ such that $ 1 \le a \le A $ , $ 1 \le b \le B $ , and the equation $ a \cdot b + a + b = conc(a, b) $ is true.

## 说明/提示

There is only one suitable pair in the first test case: $ a = 1 $ , $ b = 9 $ ( $ 1 + 9 + 1 \cdot 9 = 19 $ ).

## 样例 #1

### 输入

```
3
1 11
4 2
191 31415926
```

### 输出

```
1
0
1337
```



---

---
title: "Collecting Packages"
layout: "post"
diff: 普及-
pid: CF1294B
tag: []
---

# Collecting Packages

## 题目描述

There is a robot in a warehouse and $ n $ packages he wants to collect. The warehouse can be represented as a coordinate grid. Initially, the robot stays at the point $ (0, 0) $ . The $ i $ -th package is at the point $ (x_i, y_i) $ . It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point $ (0, 0) $ doesn't contain a package.

The robot is semi-broken and only can move up ('U') and right ('R'). In other words, in one move the robot can go from the point $ (x, y) $ to the point ( $ x + 1, y $ ) or to the point $ (x, y + 1) $ .

As we say above, the robot wants to collect all $ n $ packages (in arbitrary order). He wants to do it with the minimum possible number of moves. If there are several possible traversals, the robot wants to choose the lexicographically smallest path.

The string $ s $ of length $ n $ is lexicographically less than the string $ t $ of length $ n $ if there is some index $ 1 \le j \le n $ that for all $ i $ from $ 1 $ to $ j-1 $ $ s_i = t_i $ and $ s_j < t_j $ . It is the standard comparison of string, like in a dictionary. Most programming languages compare strings in this way.

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Then test cases follow.

The first line of a test case contains one integer $ n $ ( $ 1 \le n \le 1000 $ ) — the number of packages.

The next $ n $ lines contain descriptions of packages. The $ i $ -th package is given as two integers $ x_i $ and $ y_i $ ( $ 0 \le x_i, y_i \le 1000 $ ) — the $ x $ -coordinate of the package and the $ y $ -coordinate of the package.

It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point $ (0, 0) $ doesn't contain a package.

The sum of all values $ n $ over test cases in the test doesn't exceed $ 1000 $ .

## 输出格式

Print the answer for each test case.

If it is impossible to collect all $ n $ packages in some order starting from ( $ 0,0 $ ), print "NO" on the first line.

Otherwise, print "YES" in the first line. Then print the shortest path — a string consisting of characters 'R' and 'U'. Among all such paths choose the lexicographically smallest path.

Note that in this problem "YES" and "NO" can be only uppercase words, i.e. "Yes", "no" and "YeS" are not acceptable.

## 说明/提示

For the first test case in the example the optimal path RUUURRRRUU is shown below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1294B/e4c36c660714086e3ff8d4a648ef3d91b10cec02.png)

## 样例 #1

### 输入

```
3
5
1 3
1 2
3 3
5 5
4 3
2
1 0
0 1
1
4 3
```

### 输出

```
YES
RUUURRRRUU
NO
YES
RRRRUUU
```



---

---
title: "Array with Odd Sum"
layout: "post"
diff: 普及-
pid: CF1296A
tag: []
---

# Array with Odd Sum

## 题目描述

You are given an array $ a $ consisting of $ n $ integers.

In one move, you can choose two indices $ 1 \le i, j \le n $ such that $ i \ne j $ and set $ a_i := a_j $ . You can perform such moves any number of times (possibly, zero). You can choose different indices in different operations. The operation := is the operation of assignment (i.e. you choose $ i $ and $ j $ and replace $ a_i $ with $ a_j $ ).

Your task is to say if it is possible to obtain an array with an odd (not divisible by $ 2 $ ) sum of elements.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 2000 $ ) — the number of test cases.

The next $ 2t $ lines describe test cases. The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 2000 $ ) — the number of elements in $ a $ . The second line of the test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 2000 $ ), where $ a_i $ is the $ i $ -th element of $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2000 $ ( $ \sum n \le 2000 $ ).

## 输出格式

For each test case, print the answer on it — "YES" (without quotes) if it is possible to obtain the array with an odd sum of elements, and "NO" otherwise.

## 样例 #1

### 输入

```
5
2
2 3
4
2 2 8 8
3
3 3 3
4
5 5 5 5
4
1 1 1 1
```

### 输出

```
YES
NO
YES
NO
NO
```



---

---
title: "Food Buying"
layout: "post"
diff: 普及-
pid: CF1296B
tag: []
---

# Food Buying

## 题目描述

Mishka wants to buy some food in the nearby shop. Initially, he has $ s $ burles on his card.

Mishka can perform the following operation any number of times (possibly, zero): choose some positive integer number $ 1 \le x \le s $ , buy food that costs exactly $ x $ burles and obtain $ \lfloor\frac{x}{10}\rfloor $ burles as a cashback (in other words, Mishka spends $ x $ burles and obtains $ \lfloor\frac{x}{10}\rfloor $ back). The operation $ \lfloor\frac{a}{b}\rfloor $ means $ a $ divided by $ b $ rounded down.

It is guaranteed that you can always buy some food that costs $ x $ for any possible value of $ x $ .

Your task is to say the maximum number of burles Mishka can spend if he buys food optimally.

For example, if Mishka has $ s=19 $ burles then the maximum number of burles he can spend is $ 21 $ . Firstly, he can spend $ x=10 $ burles, obtain $ 1 $ burle as a cashback. Now he has $ s=10 $ burles, so can spend $ x=10 $ burles, obtain $ 1 $ burle as a cashback and spend it too.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The next $ t $ lines describe test cases. Each test case is given on a separate line and consists of one integer $ s $ ( $ 1 \le s \le 10^9 $ ) — the number of burles Mishka initially has.

## 输出格式

For each test case print the answer on it — the maximum number of burles Mishka can spend if he buys food optimally.

## 样例 #1

### 输入

```
6
1
10
19
9876
12345
1000000000
```

### 输出

```
1
11
21
10973
13716
1111111111
```



---

---
title: "Students and Shoelaces"
layout: "post"
diff: 普及-
pid: CF129B
tag: []
---

# Students and Shoelaces

## 题目描述

小贝和小聪是俱乐部的管理人员。当俱乐部聚会时，学生们又开始捣乱。他们带来很多鞋带，并且用鞋带将大家相互捆绑起来，每根鞋带捆住两个学生。



为了恢复秩序，小贝和小聪采取了以下措施。首先，对于每位学生，小贝检查他和哪些学生捆在一起。如果和这个学生捆在一起的学生人数等于1，小贝就将这个学生记录在案。小贝检查完每位学生后，小聪就将这些被记录的学生分到一个组中，并将这组学生踢出俱乐部。这组学生立刻离开俱乐部，同时将捆着他们的鞋带也一起带走。这组学生离开后，小贝和小聪继续重复上述的过程，直到没有学生可以被记录下来为止。



请确定总共有多少组学生被踢出俱乐部。

## 输入格式

第一行包含两个整数n和m分别表示刚开始的学生数量和鞋带数量(![图片](http://codeforces.com/predownloaded/71/d0/71d028b02d9dc63a3c5b31c7dff711ec27569a4c.png))。学生们从1到n进行编号，鞋带从1到m进行编号。接下来m行，每行包含两个整数a和b，表示被第i根鞋带捆住的两位学生的编号(1 ≤ a, b ≤ n, a ≠ b)。输入保证没有一对学生被多于一根的鞋带捆住。

## 输出格式

输出一个整数，表示被踢出俱乐部的学生组数。

## 说明/提示

在第一个样例中，小贝和小聪不会踢掉任何学生，因为每位学生都和另外两位学生捆在一起。



在第二个样例中，有4名学生依次捆成一条“链”，还有2名学生没有被捆。小贝和小聪会先将“链”两端的学生（1号和4号）作为一组踢走，再将2号和3号作为一组踢走，所以答案为2。



在第三组样例中，除了4号学生，其他学生会作为一组一起被踢走，所以答案为1。

## 样例 #1

### 输入

```
3 3
1 2
2 3
3 1

```

### 输出

```
0

```

## 样例 #2

### 输入

```
6 3
1 2
2 3
3 4

```

### 输出

```
2

```

## 样例 #3

### 输入

```
6 5
1 4
2 4
3 4
5 4
6 4

```

### 输出

```
1

```



---

---
title: "Assigning to Classes"
layout: "post"
diff: 普及-
pid: CF1300B
tag: []
---

# Assigning to Classes

## 题目描述

Reminder: the [median](https://en.wikipedia.org/wiki/Median) of the array $ [a_1, a_2, \dots, a_{2k+1}] $ of odd number of elements is defined as follows: let $ [b_1, b_2, \dots, b_{2k+1}] $ be the elements of the array in the sorted order. Then median of this array is equal to $ b_{k+1} $ .

There are $ 2n $ students, the $ i $ -th student has skill level $ a_i $ . It's not guaranteed that all skill levels are distinct.

Let's define skill level of a class as the median of skill levels of students of the class.

As a principal of the school, you would like to assign each student to one of the $ 2 $ classes such that each class has odd number of students (not divisible by $ 2 $ ). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.

What is the minimum possible absolute difference you can achieve?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the number of students halved.

The second line of each test case contains $ 2n $ integers $ a_1, a_2, \dots, a_{2 n} $ ( $ 1 \le a_i \le 10^9 $ ) — skill levels of students.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output a single integer, the minimum possible absolute difference between skill levels of two classes of odd sizes.

## 说明/提示

In the first test, there is only one way to partition students — one in each class. The absolute difference of the skill levels will be $ |1 - 1| = 0 $ .

In the second test, one of the possible partitions is to make the first class of students with skill levels $ [6, 4, 2] $ , so that the skill level of the first class will be $ 4 $ , and second with $ [5, 1, 3] $ , so that the skill level of the second class will be $ 3 $ . Absolute difference will be $ |4 - 3| = 1 $ .

Note that you can't assign like $ [2, 3] $ , $ [6, 5, 4, 1] $ or $ [] $ , $ [6, 5, 4, 1, 2, 3] $ because classes have even number of students.

 $ [2] $ , $ [1, 3, 4] $ is also not possible because students with skills $ 5 $ and $ 6 $ aren't assigned to a class.

In the third test you can assign the students in the following way: $ [3, 4, 13, 13, 20], [2, 5, 8, 16, 17] $ or $ [3, 8, 17], [2, 4, 5, 13, 13, 16, 20] $ . Both divisions give minimal possible absolute difference.

## 样例 #1

### 输入

```
3
1
1 1
3
6 5 4 1 2 3
5
13 4 20 13 2 5 8 3 17 16
```

### 输出

```
0
1
5
```



---

---
title: "Three Strings"
layout: "post"
diff: 普及-
pid: CF1301A
tag: []
---

# Three Strings

## 题目描述

You are given three strings $ a $ , $ b $ and $ c $ of the same length $ n $ . The strings consist of lowercase English letters only. The $ i $ -th letter of $ a $ is $ a_i $ , the $ i $ -th letter of $ b $ is $ b_i $ , the $ i $ -th letter of $ c $ is $ c_i $ .

For every $ i $ ( $ 1 \leq i \leq n $ ) you must swap (i.e. exchange) $ c_i $ with either $ a_i $ or $ b_i $ . So in total you'll perform exactly $ n $ swap operations, each of them either $ c_i \leftrightarrow a_i $ or $ c_i \leftrightarrow b_i $ ( $ i $ iterates over all integers between $ 1 $ and $ n $ , inclusive).

For example, if $ a $ is "code", $ b $ is "true", and $ c $ is "help", you can make $ c $ equal to "crue" taking the $ 1 $ -st and the $ 4 $ -th letters from $ a $ and the others from $ b $ . In this way $ a $ becomes "hodp" and $ b $ becomes "tele".

Is it possible that after these swaps the string $ a $ becomes exactly the same as the string $ b $ ?

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a string of lowercase English letters $ a $ .

The second line of each test case contains a string of lowercase English letters $ b $ .

The third line of each test case contains a string of lowercase English letters $ c $ .

It is guaranteed that in each test case these three strings are non-empty and have the same length, which is not exceeding $ 100 $ .

## 输出格式

Print $ t $ lines with answers for all test cases. For each test case:

If it is possible to make string $ a $ equal to string $ b $ print "YES" (without quotes), otherwise print "NO" (without quotes).

You can print either lowercase or uppercase letters in the answers.

## 说明/提示

In the first test case, it is impossible to do the swaps so that string $ a $ becomes exactly the same as string $ b $ .

In the second test case, you should swap $ c_i $ with $ a_i $ for all possible $ i $ . After the swaps $ a $ becomes "bca", $ b $ becomes "bca" and $ c $ becomes "abc". Here the strings $ a $ and $ b $ are equal.

In the third test case, you should swap $ c_1 $ with $ a_1 $ , $ c_2 $ with $ b_2 $ , $ c_3 $ with $ b_3 $ and $ c_4 $ with $ a_4 $ . Then string $ a $ becomes "baba", string $ b $ becomes "baba" and string $ c $ becomes "abab". Here the strings $ a $ and $ b $ are equal.

In the fourth test case, it is impossible to do the swaps so that string $ a $ becomes exactly the same as string $ b $ .

## 样例 #1

### 输入

```
4
aaa
bbb
ccc
abc
bca
bca
aabb
bbaa
baba
imi
mii
iim
```

### 输出

```
NO
YES
YES
NO
```



---

---
title: "National Project"
layout: "post"
diff: 普及-
pid: CF1303B
tag: []
---

# National Project

## 题目描述

Your company was appointed to lay new asphalt on the highway of length $ n $ . You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing.

Skipping the repair is necessary because of the climate. The climate in your region is periodical: there are $ g $ days when the weather is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next $ b $ days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again $ g $ good days, $ b $ bad days and so on.

You can be sure that you start repairing at the start of a good season, in other words, days $ 1, 2, \dots, g $ are good.

You don't really care about the quality of the highway, you just want to make sure that at least half of the highway will have high-quality pavement. For example, if the $ n = 5 $ then at least $ 3 $ units of the highway should have high quality; if $ n = 4 $ then at least $ 2 $ units should have high quality.

What is the minimum number of days is needed to finish the repair of the whole highway?

## 输入格式

The first line contains a single integer $ T $ ( $ 1 \le T \le 10^4 $ ) — the number of test cases.

Next $ T $ lines contain test cases — one per line. Each line contains three integers $ n $ , $ g $ and $ b $ ( $ 1 \le n, g, b \le 10^9 $ ) — the length of the highway and the number of good and bad days respectively.

## 输出格式

Print $ T $ integers — one per test case. For each test case, print the minimum number of days required to repair the whole highway if at least half of it should have high quality.

## 说明/提示

In the first test case, you can just lay new asphalt each day, since days $ 1, 3, 5 $ are good.

In the second test case, you can also lay new asphalt each day, since days $ 1 $ - $ 8 $ are good.

## 样例 #1

### 输入

```
3
5 1 1
8 10 10
1000000 1 1000000
```

### 输出

```
5
8
499999500000
```



---

---
title: "Kuroni and the Gifts"
layout: "post"
diff: 普及-
pid: CF1305A
tag: []
---

# Kuroni and the Gifts

## 题目描述

Kuroni has $ n $ daughters. As gifts for them, he bought $ n $ necklaces and $ n $ bracelets:

- the $ i $ -th necklace has a brightness $ a_i $ , where all the $ a_i $ are pairwise distinct (i.e. all $ a_i $ are different),
- the $ i $ -th bracelet has a brightness $ b_i $ , where all the $ b_i $ are pairwise distinct (i.e. all $ b_i $ are different).

Kuroni wants to give exactly one necklace and exactly one bracelet to each of his daughters. To make sure that all of them look unique, the total brightnesses of the gifts given to each daughter should be pairwise distinct. Formally, if the $ i $ -th daughter receives a necklace with brightness $ x_i $ and a bracelet with brightness $ y_i $ , then the sums $ x_i + y_i $ should be pairwise distinct. Help Kuroni to distribute the gifts.

For example, if the brightnesses are $ a = [1, 7, 5] $ and $ b = [6, 1, 2] $ , then we may distribute the gifts as follows:

- Give the third necklace and the first bracelet to the first daughter, for a total brightness of $ a_3 + b_1 = 11 $ .
- Give the first necklace and the third bracelet to the second daughter, for a total brightness of $ a_1 + b_3 = 3 $ .
- Give the second necklace and the second bracelet to the third daughter, for a total brightness of $ a_2 + b_2 = 8 $ .

Here is an example of an invalid distribution:

- Give the first necklace and the first bracelet to the first daughter, for a total brightness of $ a_1 + b_1 = 7 $ .
- Give the second necklace and the second bracelet to the second daughter, for a total brightness of $ a_2 + b_2 = 8 $ .
- Give the third necklace and the third bracelet to the third daughter, for a total brightness of $ a_3 + b_3 = 7 $ .

This distribution is invalid, as the total brightnesses of the gifts received by the first and the third daughter are the same. Don't make them this upset!

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of daughters, necklaces and bracelets.

The second line of each test case contains $ n $ distinct integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 1000 $ ) — the brightnesses of the necklaces.

The third line of each test case contains $ n $ distinct integers $ b_1, b_2, \dots, b_n $ ( $ 1 \le b_i \le 1000 $ ) — the brightnesses of the bracelets.

## 输出格式

For each test case, print a line containing $ n $ integers $ x_1, x_2, \dots, x_n $ , representing that the $ i $ -th daughter receives a necklace with brightness $ x_i $ . In the next line print $ n $ integers $ y_1, y_2, \dots, y_n $ , representing that the $ i $ -th daughter receives a bracelet with brightness $ y_i $ .

The sums $ x_1 + y_1, x_2 + y_2, \dots, x_n + y_n $ should all be distinct. The numbers $ x_1, \dots, x_n $ should be equal to the numbers $ a_1, \dots, a_n $ in some order, and the numbers $ y_1, \dots, y_n $ should be equal to the numbers $ b_1, \dots, b_n $ in some order.

It can be shown that an answer always exists. If there are multiple possible answers, you may print any of them.

## 说明/提示

In the first test case, it is enough to give the $ i $ -th necklace and the $ i $ -th bracelet to the $ i $ -th daughter. The corresponding sums are $ 1 + 8 = 9 $ , $ 8 + 4 = 12 $ , and $ 5 + 5 = 10 $ .

The second test case is described in the statement.

## 样例 #1

### 输入

```
2
3
1 8 5
8 4 5
3
1 7 5
6 1 2
```

### 输出

```
1 8 5
8 4 5
5 1 7
6 2 1
```



---

---
title: "Cow and Haybales"
layout: "post"
diff: 普及-
pid: CF1307A
tag: []
---

# Cow and Haybales

## 题目描述

有n个数，你每次可以选择相邻的两个数i和j，使ai-1，aj+1，你的目的是经过d此操作后，使得a1最大。

## 输入格式

第一行一个整数t（1≤t≤100），表示有t组数据。

每组数据第一行2个整数，表示n和d（ 1≤n,d≤100）。

第2行n个整数，分别表示 a1, a2……,an ( 0≤ai≤100 )

## 输出格式

t行。每行表示第t次操作a1的最大值。

## 样例 #1

### 输入

```
3
4 5
1 0 3 2
2 2
100 1
1 8
0
```

### 输出

```
3
101
0
```



---

---
title: "Add Odd or Subtract Even"
layout: "post"
diff: 普及-
pid: CF1311A
tag: []
---

# Add Odd or Subtract Even

## 题目描述

You are given two positive integers $ a $ and $ b $ .

In one move, you can change $ a $ in the following way:

- Choose any positive odd integer $ x $ ( $ x > 0 $ ) and replace $ a $ with $ a+x $ ;
- choose any positive even integer $ y $ ( $ y > 0 $ ) and replace $ a $ with $ a-y $ .

You can perform as many such operations as you want. You can choose the same numbers $ x $ and $ y $ in different moves.

Your task is to find the minimum number of moves required to obtain $ b $ from $ a $ . It is guaranteed that you can always obtain $ b $ from $ a $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Then $ t $ test cases follow. Each test case is given as two space-separated integers $ a $ and $ b $ ( $ 1 \le a, b \le 10^9 $ ).

## 输出格式

For each test case, print the answer — the minimum number of moves required to obtain $ b $ from $ a $ if you can perform any number of moves described in the problem statement. It is guaranteed that you can always obtain $ b $ from $ a $ .

## 说明/提示

In the first test case, you can just add $ 1 $ .

In the second test case, you don't need to do anything.

In the third test case, you can add $ 1 $ two times.

In the fourth test case, you can subtract $ 4 $ and add $ 1 $ .

In the fifth test case, you can just subtract $ 6 $ .

## 样例 #1

### 输入

```
5
2 3
10 10
2 4
7 4
9 3
```

### 输出

```
1
0
2
2
1
```



---

---
title: "Two Regular Polygons"
layout: "post"
diff: 普及-
pid: CF1312A
tag: []
---

# Two Regular Polygons

## 题目描述

You are given two integers $ n $ and $ m $ ( $ m < n $ ). Consider a convex regular polygon of $ n $ vertices. Recall that a regular polygon is a polygon that is equiangular (all angles are equal in measure) and equilateral (all sides have the same length).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1312A/95b1bef3403a130cb1532da909306b47c3e9056c.png) Examples of convex regular polygons Your task is to say if it is possible to build another convex regular polygon with $ m $ vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The next $ t $ lines describe test cases. Each test case is given as two space-separated integers $ n $ and $ m $ ( $ 3 \le m < n \le 100 $ ) — the number of vertices in the initial polygon and the number of vertices in the polygon you want to build.

## 输出格式

For each test case, print the answer — "YES" (without quotes), if it is possible to build another convex regular polygon with $ m $ vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon and "NO" otherwise.

## 说明/提示

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1312A/0982568e883452a4972ef18c303a083c1c1e1608.png) The first test case of the example It can be shown that the answer for the second test case of the example is "NO".

## 样例 #1

### 输入

```
2
6 3
7 3
```

### 输出

```
YES
NO
```



---

---
title: "Fast Food Restaurant"
layout: "post"
diff: 普及-
pid: CF1313A
tag: []
---

# Fast Food Restaurant

## 题目描述

由于Denis工作得很累，他想开家餐厅。

第一天，他做了 $a$ 份饺子，$b$ 份莓果汁和 $c$ 份淋有炼乳的松饼。

Denis餐厅奇怪的地方在于订餐的过程。对于每位客人Denis会自己选**一份套餐**给客人。

Denis选**套餐**的规则是这样的：

1. 每个客人都要至少有一份**食物**（饺子、莓果汁、淋有炼乳的松饼都是食物）。

2. 每个客人**不能收到多于一份饺子**，**不能收到多于一份莓果汁**，**且不能收到多于一份淋有炼乳的松饼**。

3. 每个客人都要有**不一样**的套餐。

Denis**最多**可以为几个客人提供套餐呢？

## 输入格式

第一行，一个整数 $t$$(1 \leq t \leq 500)$。表示你有 $t$ 组测试数据要解决。

剩下的 $t$ 行每行有三个整数 $a$, $b$ 和 $c$，表示Denis做了 $a$ 份饺子，$b$ 份莓果汁和 $c$ $(0 \leq a,b,c \leq 10)$ 份淋有炼乳的松饼。

## 输出格式

对于每组测试数据，输出一个整数，表示Denis**最多**可以为几个客人提供套餐。

## 样例 #1

### 输入

```
7
1 2 1
0 0 0
9 1 7
2 2 3
2 3 2
3 2 2
4 4 4
```

### 输出

```
3
0
4
5
5
5
7
```



---

---
title: "Dead Pixel"
layout: "post"
diff: 普及-
pid: CF1315A
tag: []
---

# Dead Pixel

## 题目描述

Screen resolution of Polycarp's monitor is $ a \times b $ pixels. Unfortunately, there is one dead pixel at his screen. It has coordinates $ (x, y) $ ( $ 0 \le x < a, 0 \le y < b $ ). You can consider columns of pixels to be numbered from $ 0 $ to $ a-1 $ , and rows — from $ 0 $ to $ b-1 $ .

Polycarp wants to open a rectangular window of maximal size, which doesn't contain the dead pixel. The boundaries of the window should be parallel to the sides of the screen.

Print the maximal area (in pixels) of a window that doesn't contain the dead pixel inside itself.

## 输入格式

In the first line you are given an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test. In the next lines you are given descriptions of $ t $ test cases.

Each test case contains a single line which consists of $ 4 $ integers $ a, b, x $ and $ y $ ( $ 1 \le a, b \le 10^4 $ ; $ 0 \le x < a $ ; $ 0 \le y < b $ ) — the resolution of the screen and the coordinates of a dead pixel. It is guaranteed that $ a+b>2 $ (e.g. $ a=b=1 $ is impossible).

## 输出格式

Print $ t $ integers — the answers for each test case. Each answer should contain an integer equal to the maximal possible area (in pixels) of a rectangular window, that doesn't contain the dead pixel.

## 说明/提示

In the first test case, the screen resolution is $ 8 \times 8 $ , and the upper left pixel is a dead pixel. Here you can see one of two possible layouts of the maximal window.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1315A/cb58b5325ebfab8c891df37e110ee05ad36ccf9e.png)

## 样例 #1

### 输入

```
6
8 8 0 0
1 10 0 3
17 31 10 4
2 1 0 0
5 10 3 9
10 10 4 8
```

### 输出

```
56
6
442
1
45
80
```



---

---
title: "Grade Allocation"
layout: "post"
diff: 普及-
pid: CF1316A
tag: []
---

# Grade Allocation

## 题目描述

$ n $ students are taking an exam. The highest possible score at this exam is $ m $ . Let $ a_{i} $ be the score of the $ i $ -th student. You have access to the school database which stores the results of all students.

You can change each student's score as long as the following conditions are satisfied:

- All scores are integers
- $ 0 \leq a_{i} \leq m $
- The average score of the class doesn't change.

You are student $ 1 $ and you would like to maximize your own score.

Find the highest possible score you can assign to yourself such that all conditions are satisfied.

## 输入格式

Each test contains multiple test cases.

The first line contains the number of test cases $ t $ ( $ 1 \le t \le 200 $ ). The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \leq n \leq 10^{3} $ , $ 1 \leq m \leq 10^{5} $ ) — the number of students and the highest possible score respectively.

The second line of each testcase contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $  0 \leq a_{i} \leq m $ ) — scores of the students.

## 输出格式

For each testcase, output one integer — the highest possible score you can assign to yourself such that both conditions are satisfied.\_

## 说明/提示

In the first case, $ a = [1,2,3,4]  $ , with average of $ 2.5 $ . You can change array $ a $ to $ [10,0,0,0] $ . Average remains $ 2.5 $ , and all conditions are satisfied.

In the second case, $ 0 \leq a_{i} \leq 5 $ . You can change $ a $ to $ [5,1,1,3] $ . You cannot increase $ a_{1} $ further as it will violate condition $ 0\le a_i\le m $ .

## 样例 #1

### 输入

```
2
4 10
1 2 3 4
4 5
1 2 3 4
```

### 输出

```
10
5
```



---

---
title: "Contest for Robots"
layout: "post"
diff: 普及-
pid: CF1321A
tag: []
---

# Contest for Robots

## 题目描述

Polycarp is preparing the first programming contest for robots. There are $ n $ problems in it, and a lot of robots are going to participate in it. Each robot solving the problem $ i $ gets $ p_i $ points, and the score of each robot in the competition is calculated as the sum of $ p_i $ over all problems $ i $ solved by it. For each problem, $ p_i $ is an integer not less than $ 1 $ .

Two corporations specializing in problem-solving robot manufacturing, "Robo-Coder Inc." and "BionicSolver Industries", are going to register two robots (one for each corporation) for participation as well. Polycarp knows the advantages and flaws of robots produced by these companies, so, for each problem, he knows precisely whether each robot will solve it during the competition. Knowing this, he can try predicting the results — or manipulating them.

For some reason (which absolutely cannot involve bribing), Polycarp wants the "Robo-Coder Inc." robot to outperform the "BionicSolver Industries" robot in the competition. Polycarp wants to set the values of $ p_i $ in such a way that the "Robo-Coder Inc." robot gets strictly more points than the "BionicSolver Industries" robot. However, if the values of $ p_i $ will be large, it may look very suspicious — so Polycarp wants to minimize the maximum value of $ p_i $ over all problems. Can you help Polycarp to determine the minimum possible upper bound on the number of points given for solving the problems?

## 输入格式

The first line contains one integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of problems.

The second line contains $ n $ integers $ r_1 $ , $ r_2 $ , ..., $ r_n $ ( $ 0 \le r_i \le 1 $ ). $ r_i = 1 $ means that the "Robo-Coder Inc." robot will solve the $ i $ -th problem, $ r_i = 0 $ means that it won't solve the $ i $ -th problem.

The third line contains $ n $ integers $ b_1 $ , $ b_2 $ , ..., $ b_n $ ( $ 0 \le b_i \le 1 $ ). $ b_i = 1 $ means that the "BionicSolver Industries" robot will solve the $ i $ -th problem, $ b_i = 0 $ means that it won't solve the $ i $ -th problem.

## 输出格式

If "Robo-Coder Inc." robot cannot outperform the "BionicSolver Industries" robot by any means, print one integer $ -1 $ .

Otherwise, print the minimum possible value of $ \max \limits_{i = 1}^{n} p_i $ , if all values of $ p_i $ are set in such a way that the "Robo-Coder Inc." robot gets strictly more points than the "BionicSolver Industries" robot.

## 说明/提示

In the first example, one of the valid score assignments is $ p = [3, 1, 3, 1, 1] $ . Then the "Robo-Coder" gets $ 7 $ points, the "BionicSolver" — $ 6 $ points.

In the second example, both robots get $ 0 $ points, and the score distribution does not matter.

In the third example, both robots solve all problems, so their points are equal.

## 样例 #1

### 输入

```
5
1 1 1 0 0
0 1 1 1 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
0 0 0
0 0 0
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4
1 1 1 1
1 1 1 1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
9
1 0 0 0 0 0 0 0 1
0 1 1 0 1 1 1 1 0
```

### 输出

```
4
```



---

---
title: "Unusual Competitions"
layout: "post"
diff: 普及-
pid: CF1322A
tag: []
---

# Unusual Competitions

## 题目描述

A bracketed sequence is called correct (regular) if by inserting "+" and "1" you can get a well-formed mathematical expression from it. For example, sequences "(())()", "()" and "(()(()))" are correct, while ")(", "(()" and "(()))(" are not.

The teacher gave Dmitry's class a very strange task — she asked every student to come up with a sequence of arbitrary length, consisting only of opening and closing brackets. After that all the students took turns naming the sequences they had invented. When Dima's turn came, he suddenly realized that all his classmates got the correct bracketed sequence, and whether he got the correct bracketed sequence, he did not know.

Dima suspects now that he simply missed the word "correct" in the task statement, so now he wants to save the situation by modifying his sequence slightly. More precisely, he can the arbitrary number of times (possibly zero) perform the reorder operation.

The reorder operation consists of choosing an arbitrary consecutive subsegment (substring) of the sequence and then reordering all the characters in it in an arbitrary way. Such operation takes $ l $ nanoseconds, where $ l $ is the length of the subsegment being reordered. It's easy to see that reorder operation doesn't change the number of opening and closing brackets. For example for "))((" he can choose the substring ")(" and do reorder ")()(" (this operation will take $ 2 $ nanoseconds).

Since Dima will soon have to answer, he wants to make his sequence correct as fast as possible. Help him to do this, or determine that it's impossible.

## 输入格式

The first line contains a single integer $ n $ ( $ 1 \le n \le 10^6 $ ) — the length of Dima's sequence.

The second line contains string of length $ n $ , consisting of characters "(" and ")" only.

## 输出格式

Print a single integer — the minimum number of nanoseconds to make the sequence correct or "-1" if it is impossible to do so.

## 说明/提示

In the first example we can firstly reorder the segment from first to the fourth character, replacing it with "()()", the whole sequence will be "()()())(". And then reorder the segment from the seventh to eighth character, replacing it with "()". In the end the sequence will be "()()()()", while the total time spent is $ 4 + 2 = 6 $ nanoseconds.

## 样例 #1

### 输入

```
8
))((())(
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3
(()
```

### 输出

```
-1
```



---

---
title: "Even Subset Sum Problem"
layout: "post"
diff: 普及-
pid: CF1323A
tag: []
---

# Even Subset Sum Problem

## 题目描述

### 题意简述

给定数组 $a$，求出它一个和为偶数的的非空子集。

## 输入格式

**本题有多组数据。**

第一行一个正整数 $t$ 表示数据组数。

对于每组数据，第一行一个正整数 $n$。

接下来一行 $n$ 个正整数 $a_1,a_2,...,a_n$。

## 输出格式

对于每组数据，如果有解，在第一行输出 $k$，表示你找到的非空子集的大小。在第二行输出 $k$ 个正整数，表示你找到的非空子集在 $a$ 数组中的下标。

如果无解，在第一行输出 $-1$。

## 说明/提示

$1 \leq t,n,a_i \leq 100$。

翻译 by Meatherm

## 样例 #1

### 输入

```
3
3
1 4 3
1
15
2
3 5
```

### 输出

```
1
2
-1
2
1 2
```



---

---
title: "Yet Another Tetris Problem"
layout: "post"
diff: 普及-
pid: CF1324A
tag: []
---

# Yet Another Tetris Problem

## 题目描述

你有一个数列 $\{a_n\}$，现在有两种操作：

1. 当数列 $\{a_n\}$ 的任意一项大于 $0$ 时，你可以选择**一些** $i(1\le i\le n)$，把每个 $a_i$ 加上 $2$。
2. 当数列 $\{a_n\}$ 的每一项都大于 $0$ 时，把这个数列的每一项都减去 $1$。

问你最后能不能把 $\{a\}$ 数组的元素全部变成 $0$。如果能，输出 `YES`，不然输出 `NO`。

## 输入格式

**本题有多组数据。**

第一行一个整数 $t$，表示数据组数。

每组数据包含两行，第一行一个整数 $n$，表示数列的长度；第二行有 $n$ 个整数，表示数列 $\{a_n\}$。

## 输出格式

对于每组数据，输出 `YES` 或 `NO`，每行一个。

## 说明/提示

$1\le t\le 100$，$1\le n\le 100$，$1\le a_i\le 100$。

## 样例 #1

### 输入

```
4
3
1 1 3
4
1 1 2 1
2
11 11
1
100
```

### 输出

```
YES
NO
YES
YES
```



---

---
title: "Yet Another Palindrome Problem"
layout: "post"
diff: 普及-
pid: CF1324B
tag: []
---

# Yet Another Palindrome Problem

## 题目描述

You are given an array $ a $ consisting of $ n $ integers.

Your task is to determine if $ a $ has some subsequence of length at least $ 3 $ that is a palindrome.

Recall that an array $ b $ is called a subsequence of the array $ a $ if $ b $ can be obtained by removing some (possibly, zero) elements from $ a $ (not necessarily consecutive) without changing the order of remaining elements. For example, $ [2] $ , $ [1, 2, 1, 3] $ and $ [2, 3] $ are subsequences of $ [1, 2, 1, 3] $ , but $ [1, 1, 2] $ and $ [4] $ are not.

Also, recall that a palindrome is an array that reads the same backward as forward. In other words, the array $ a $ of length $ n $ is the palindrome if $ a_i = a_{n - i - 1} $ for all $ i $ from $ 1 $ to $ n $ . For example, arrays $ [1234] $ , $ [1, 2, 1] $ , $ [1, 3, 2, 2, 3, 1] $ and $ [10, 100, 10] $ are palindromes, but arrays $ [1, 2] $ and $ [1, 2, 3, 1] $ are not.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

Next $ 2t $ lines describe test cases. The first line of the test case contains one integer $ n $ ( $ 3 \le n \le 5000 $ ) — the length of $ a $ . The second line of the test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ), where $ a_i $ is the $ i $ -th element of $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5000 $ ( $ \sum n \le 5000 $ ).

## 输出格式

For each test case, print the answer — "YES" (without quotes) if $ a $ has some subsequence of length at least $ 3 $ that is a palindrome and "NO" otherwise.

## 说明/提示

In the first test case of the example, the array $ a $ has a subsequence $ [1, 2, 1] $ which is a palindrome.

In the second test case of the example, the array $ a $ has two subsequences of length $ 3 $ which are palindromes: $ [2, 3, 2] $ and $ [2, 2, 2] $ .

In the third test case of the example, the array $ a $ has no subsequences of length at least $ 3 $ which are palindromes.

In the fourth test case of the example, the array $ a $ has one subsequence of length $ 4 $ which is a palindrome: $ [1, 2, 2, 1] $ (and has two subsequences of length $ 3 $ which are palindromes: both are $ [1, 2, 1] $ ).

In the fifth test case of the example, the array $ a $ has no subsequences of length at least $ 3 $ which are palindromes.

## 样例 #1

### 输入

```
5
3
1 2 1
5
1 2 2 3 2
3
1 1 2
4
1 2 2 1
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
YES
YES
NO
YES
NO
```



---

---
title: "Frog Jumps"
layout: "post"
diff: 普及-
pid: CF1324C
tag: []
---

# Frog Jumps

## 题目描述

There is a frog staying to the left of the string $ s = s_1 s_2 \ldots s_n $ consisting of $ n $ characters (to be more precise, the frog initially stays at the cell $ 0 $ ). Each character of $ s $ is either 'L' or 'R'. It means that if the frog is staying at the $ i $ -th cell and the $ i $ -th character is 'L', the frog can jump only to the left. If the frog is staying at the $ i $ -th cell and the $ i $ -th character is 'R', the frog can jump only to the right. The frog can jump only to the right from the cell $ 0 $ .

Note that the frog can jump into the same cell twice and can perform as many jumps as it needs.

The frog wants to reach the $ n+1 $ -th cell. The frog chooses some positive integer value $ d $ before the first jump (and cannot change it later) and jumps by no more than $ d $ cells at once. I.e. if the $ i $ -th character is 'L' then the frog can jump to any cell in a range $ [max(0, i - d); i - 1] $ , and if the $ i $ -th character is 'R' then the frog can jump to any cell in a range $ [i + 1; min(n + 1; i + d)] $ .

The frog doesn't want to jump far, so your task is to find the minimum possible value of $ d $ such that the frog can reach the cell $ n+1 $ from the cell $ 0 $ if it can jump by no more than $ d $ cells at once. It is guaranteed that it is always possible to reach $ n+1 $ from $ 0 $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The next $ t $ lines describe test cases. The $ i $ -th test case is described as a string $ s $ consisting of at least $ 1 $ and at most $ 2 \cdot 10^5 $ characters 'L' and 'R'.

It is guaranteed that the sum of lengths of strings over all test cases does not exceed $ 2 \cdot 10^5 $ ( $ \sum |s| \le 2 \cdot 10^5 $ ).

## 输出格式

For each test case, print the answer — the minimum possible value of $ d $ such that the frog can reach the cell $ n+1 $ from the cell $ 0 $ if it jumps by no more than $ d $ at once.

## 说明/提示

The picture describing the first test case of the example and one of the possible answers:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1324C/662a540925813072330b737ce66b1eb08560ce29.png)

In the second test case of the example, the frog can only jump directly from $ 0 $ to $ n+1 $ .

In the third test case of the example, the frog can choose $ d=3 $ , jump to the cell $ 3 $ from the cell $ 0 $ and then to the cell $ 4 $ from the cell $ 3 $ .

In the fourth test case of the example, the frog can choose $ d=1 $ and jump $ 5 $ times to the right.

In the fifth test case of the example, the frog can only jump directly from $ 0 $ to $ n+1 $ .

In the sixth test case of the example, the frog can choose $ d=1 $ and jump $ 2 $ times to the right.

## 样例 #1

### 输入

```
6
LRLRRLL
L
LLR
RRRR
LLLLLL
R
```

### 输出

```
3
2
3
1
7
1
```



---

---
title: "Bad Ugly Numbers"
layout: "post"
diff: 普及-
pid: CF1326A
tag: []
---

# Bad Ugly Numbers

## 题目描述

You are given a integer $ n $ ( $ n > 0 $ ). Find any integer $ s $ which satisfies these conditions, or report that there are no such numbers:

In the decimal representation of $ s $ :

- $ s > 0 $ ,
- $ s $ consists of $ n $ digits,
- no digit in $ s $ equals $ 0 $ ,
- $ s $ is not divisible by any of it's digits.

## 输入格式

The input consists of multiple test cases. The first line of the input contains a single integer $ t $ ( $ 1 \leq t \leq 400 $ ), the number of test cases. The next $ t $ lines each describe a test case.

Each test case contains one positive integer $ n $ ( $ 1 \leq n \leq 10^5 $ ).

It is guaranteed that the sum of $ n $ for all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, print an integer $ s $ which satisfies the conditions described above, or "-1" (without quotes), if no such number exists. If there are multiple possible solutions for $ s $ , print any solution.

## 说明/提示

In the first test case, there are no possible solutions for $ s $ consisting of one digit, because any such solution is divisible by itself.

For the second test case, the possible solutions are: $ 23 $ , $ 27 $ , $ 29 $ , $ 34 $ , $ 37 $ , $ 38 $ , $ 43 $ , $ 46 $ , $ 47 $ , $ 49 $ , $ 53 $ , $ 54 $ , $ 56 $ , $ 57 $ , $ 58 $ , $ 59 $ , $ 67 $ , $ 68 $ , $ 69 $ , $ 73 $ , $ 74 $ , $ 76 $ , $ 78 $ , $ 79 $ , $ 83 $ , $ 86 $ , $ 87 $ , $ 89 $ , $ 94 $ , $ 97 $ , and $ 98 $ .

For the third test case, one possible solution is $ 239 $ because $ 239 $ is not divisible by $ 2 $ , $ 3 $ or $ 9 $ and has three digits (none of which equals zero).

## 样例 #1

### 输入

```
4
1
2
3
4
```

### 输出

```
-1
57
239
6789
```



---

---
title: "Maximums"
layout: "post"
diff: 普及-
pid: CF1326B
tag: []
---

# Maximums

## 题目描述

Alicia has an array, $ a_1, a_2, \ldots, a_n $ , of non-negative integers. For each $ 1 \leq i \leq n $ , she has found a non-negative integer $ x_i = max(0, a_1, \ldots, a_{i-1}) $ . Note that for $ i=1 $ , $ x_i = 0 $ .

For example, if Alicia had the array $ a = \{0, 1, 2, 0, 3\} $ , then $ x = \{0, 0, 1, 2, 2\} $ .

Then, she calculated an array, $ b_1, b_2, \ldots, b_n $ : $ b_i = a_i - x_i $ .

For example, if Alicia had the array $ a = \{0, 1, 2, 0, 3\} $ , $ b = \{0-0, 1-0, 2-1, 0-2, 3-2\} = \{0, 1, 1, -2, 1\} $ .

Alicia gives you the values $ b_1, b_2, \ldots, b_n $ and asks you to restore the values $ a_1, a_2, \ldots, a_n $ . Can you help her solve the problem?

## 输入格式

The first line contains one integer $ n $ ( $ 3 \leq n \leq 200\,000 $ ) – the number of elements in Alicia's array.

The next line contains $ n $ integers, $ b_1, b_2, \ldots, b_n $ ( $ -10^9 \leq b_i \leq 10^9 $ ).

It is guaranteed that for the given array $ b $ there is a solution $ a_1, a_2, \ldots, a_n $ , for all elements of which the following is true: $ 0 \leq a_i \leq 10^9 $ .

## 输出格式

Print $ n $ integers, $ a_1, a_2, \ldots, a_n $ ( $ 0 \leq a_i \leq 10^9 $ ), such that if you calculate $ x $ according to the statement, $ b_1 $ will be equal to $ a_1 - x_1 $ , $ b_2 $ will be equal to $ a_2 - x_2 $ , ..., and $ b_n $ will be equal to $ a_n - x_n $ .

It is guaranteed that there exists at least one solution for the given tests. It can be shown that the solution is unique.

## 说明/提示

The first test was described in the problem statement.

In the second test, if Alicia had an array $ a = \{1000, 1000000000, 0\} $ , then $ x = \{0, 1000, 1000000000\} $ and $ b = \{1000-0, 1000000000-1000, 0-1000000000\} = \{1000, 999999000, -1000000000\} $ .

## 样例 #1

### 输入

```
5
0 1 1 -2 1
```

### 输出

```
0 1 2 0 3
```

## 样例 #2

### 输入

```
3
1000 999999000 -1000000000
```

### 输出

```
1000 1000000000 0
```

## 样例 #3

### 输入

```
5
2 1 2 2 3
```

### 输出

```
2 3 5 7 10
```



---

---
title: "Princesses and Princes"
layout: "post"
diff: 普及-
pid: CF1327B
tag: []
---

# Princesses and Princes

## 题目描述

The King of Berland Polycarp LXXXIV has $ n $ daughters. To establish his power to the neighbouring kingdoms he wants to marry his daughters to the princes of these kingdoms. As a lucky coincidence there are $ n $ other kingdoms as well.

So Polycarp LXXXIV has enumerated his daughters from $ 1 $ to $ n $ and the kingdoms from $ 1 $ to $ n $ . For each daughter he has compiled a list of kingdoms princes of which she wanted to marry.

Polycarp LXXXIV is very busy, so he finds a couple for his daughters greedily one after another.

For the first daughter he takes the kingdom with the lowest number from her list and marries the daughter to their prince. For the second daughter he takes the kingdom with the lowest number from her list, prince of which hasn't been taken already. If there are no free princes in the list then the daughter marries nobody and Polycarp LXXXIV proceeds to the next daughter. The process ends after the $ n $ -th daughter.

For example, let there be $ 4 $ daughters and kingdoms, the lists daughters have are $ [2, 3] $ , $ [1, 2] $ , $ [3, 4] $ , $ [3] $ , respectively.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1327B/50ce2d8ac0f6b682008f6274aa8cfbc6afc16be3.png)In that case daughter $ 1 $ marries the prince of kingdom $ 2 $ , daughter $ 2 $ marries the prince of kingdom $ 1 $ , daughter $ 3 $ marries the prince of kingdom $ 3 $ , leaving daughter $ 4 $ nobody to marry to.

Actually, before starting the marriage process Polycarp LXXXIV has the time to convince one of his daughters that some prince is also worth marrying to. Effectively, that means that he can add exactly one kingdom to exactly one of his daughter's list. Note that this kingdom should not be present in the daughter's list.

Polycarp LXXXIV wants to increase the number of married couples.

Unfortunately, what he doesn't have the time for is determining what entry to add. If there is no way to increase the total number of married couples then output that the marriages are already optimal. Otherwise, find such an entry that the total number of married couples increases if Polycarp LXXXIV adds it.

If there are multiple ways to add an entry so that the total number of married couples increases then print any of them.

For your and our convenience you are asked to answer $ t $ independent test cases.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^5 $ ) — the number of test cases.

Then $ t $ test cases follow.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the number of daughters and the number of kingdoms.

Each of the next $ n $ lines contains the description of each daughter's list. The first integer $ k $ ( $ 0 \le k \le n $ ) is the number of entries in the $ i $ -th daughter's list. After that $ k $ distinct integers follow $ g_i[1], g_i[2], \dots, g_i[k] $ ( $ 1 \le g_i[j] \le n $ ) — the indices of the kingdoms in the list in the increasing order ( $ g_i[1] < g_i[2] < \dots < g_i[k] $ ).

It's guaranteed that the total number of daughters over all test cases does not exceed $ 10^5 $ .

It's also guaranteed that the total number of kingdoms in lists over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case print the answer to it.

Print "IMPROVE" in the first line if Polycarp LXXXIV can add some kingdom to some of his daughter's list so that the total number of married couples increases. The second line then should contain two integers — the index of the daughter and the index of the kingdom Polycarp LXXXIV should add to that daughter's list.

If there are multiple ways to add an entry so that the total number of married couples increases then print any of them.

Otherwise the only line should contain one word "OPTIMAL".

## 说明/提示

The first test case is depicted in the statement. Adding the fourth kingdom to the list of the fourth daughter makes her marry the prince of the fourth kingdom.

In the second test case any new entry will increase the number of marriages from $ 0 $ to $ 1 $ .

In the third and the fourth test cases there is no way to add an entry.

In the fifth test case there is no way to change the marriages by adding any entry.

## 样例 #1

### 输入

```
5
4
2 2 3
2 1 2
2 3 4
1 3
2
0
0
3
3 1 2 3
3 1 2 3
3 1 2 3
1
1 1
4
1 1
1 2
1 3
1 4
```

### 输出

```
IMPROVE
4 4
IMPROVE
1 1
OPTIMAL
OPTIMAL
OPTIMAL
```



---

---
title: "Game with Chips"
layout: "post"
diff: 普及-
pid: CF1327C
tag: []
---

# Game with Chips

## 题目描述

Petya 有一个大小为 $n×m$ 的矩形版。一开始，在板子上有 $k$ 个芯片，第 $i$ 个芯片位置位于第 $sx$ 行与第 $sy$ 列的相交点上。

在一次操作中， Petya 可以把所有的芯片向左、向右、向下或者向上移动一格。

如果芯片在 $(x, y)$ 格中，则在操作之后：

- 往左：坐标为 $(x, y - 1)$;
- 往右：坐标为 $(x, y + 1)$;
- 往下：坐标为 $(x + 1, y)$;
- 往上：坐标为 $(x - 1, y)$;

如果现在芯片在版的边缘上，然而 Petya 将其移向边缘，那么芯片的位置保持不变。

对于每一个芯片， Petya 选择了他应该到达的位置。注意：芯片不须在这个地方停下来。

由于 Petya 时间不多， 总操作数不能超过 $2nm$。

你需要求出 Petya 应该做的操作：在不超过 $2nm$ 的操作里让每个芯片走过 Petya 选定的位置一遍。或者说明是不可能达到目的的。

## 输入格式

第一行三个整数 $n,m,k$（$1 \le n,m,k \le 200$），分别表示矩形板的长，矩形板的宽和芯片的个数。

接下来的 $k$ 行每行两个整数 $ sx_i, sy_i$ （$1 \le sx_i \le n, 1 \le sy_i \le m$），表示第 $i$ 个芯片的初始位置。

再接下来的 $k$ 行每行两个整数 $ fx_i, fy_i$ （$1 \le fx_i \le n, 1 \le fy_i \le m$），表示第 $i$ 个芯片须达到的位置。

## 输出格式

输出第一行一个整数，表示能达到目的的操作次数（不需要最小）。

在第二行输出一个序列，用 "L、R、D、U" 分别表示 "左、右、下、上" 。

若无解，则输出 $ -1 $ 。

## 样例 #1

### 输入

```
3 3 2
1 2
2 1
3 3
3 2
```

### 输出

```
3
DRD
```

## 样例 #2

### 输入

```
5 4 3
3 4
3 1
3 3
5 3
1 3
1 4
```

### 输出

```
9
DDLUUUURR
```



---

---
title: "K-th Beautiful String"
layout: "post"
diff: 普及-
pid: CF1328B
tag: []
---

# K-th Beautiful String

## 题目描述

For the given integer $ n $ ( $ n > 2 $ ) let's write down all the strings of length $ n $ which contain $ n-2 $ letters 'a' and two letters 'b' in lexicographical (alphabetical) order.

Recall that the string $ s $ of length $ n $ is lexicographically less than string $ t $ of length $ n $ , if there exists such $ i $ ( $ 1 \le i \le n $ ), that $ s_i < t_i $ , and for any $ j $ ( $ 1 \le j < i $ ) $ s_j = t_j $ . The lexicographic comparison of strings is implemented by the operator &lt; in modern programming languages.

For example, if $ n=5 $ the strings are (the order does matter):

1. aaabb
2. aabab
3. aabba
4. abaab
5. ababa
6. abbaa
7. baaab
8. baaba
9. babaa
10. bbaaa

It is easy to show that such a list of strings will contain exactly $ \frac{n \cdot (n-1)}{2} $ strings.

You are given $ n $ ( $ n > 2 $ ) and $ k $ ( $ 1 \le k \le \frac{n \cdot (n-1)}{2} $ ). Print the $ k $ -th string from the list.

## 输入格式

The input contains one or more test cases.

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test. Then $ t $ test cases follow.

Each test case is written on the the separate line containing two integers $ n $ and $ k $ ( $ 3 \le n \le 10^5, 1 \le k \le \min(2\cdot10^9, \frac{n \cdot (n-1)}{2}) $ .

The sum of values $ n $ over all test cases in the test doesn't exceed $ 10^5 $ .

## 输出格式

For each test case print the $ k $ -th string from the list of all described above strings of length $ n $ . Strings in the list are sorted lexicographically (alphabetically).

## 样例 #1

### 输入

```
7
5 1
5 2
5 8
5 10
3 1
3 2
20 100
```

### 输出

```
aaabb
aabab
baaba
bbaaa
abb
bab
aaaaabaaaaabaaaaaaaa
```



---

---
title: "Ternary XOR"
layout: "post"
diff: 普及-
pid: CF1328C
tag: []
---

# Ternary XOR

## 题目描述

A number is ternary if it contains only digits $ 0 $ , $ 1 $ and $ 2 $ . For example, the following numbers are ternary: $ 1022 $ , $ 11 $ , $ 21 $ , $ 2002 $ .

You are given a long ternary number $ x $ . The first (leftmost) digit of $ x $ is guaranteed to be $ 2 $ , the other digits of $ x $ can be $ 0 $ , $ 1 $ or $ 2 $ .

Let's define the ternary XOR operation $ \odot $ of two ternary numbers $ a $ and $ b $ (both of length $ n $ ) as a number $ c = a \odot b $ of length $ n $ , where $ c_i = (a_i + b_i) \% 3 $ (where $ \% $ is modulo operation). In other words, add the corresponding digits and take the remainders of the sums when divided by $ 3 $ . For example, $ 10222 \odot 11021 = 21210 $ .

Your task is to find such ternary numbers $ a $ and $ b $ both of length $ n $ and both without leading zeros that $ a \odot b = x $ and $ max(a, b) $ is the minimum possible.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Then $ t $ test cases follow. The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 5 \cdot 10^4 $ ) — the length of $ x $ . The second line of the test case contains ternary number $ x $ consisting of $ n $ digits $ 0, 1 $ or $ 2 $ . It is guaranteed that the first digit of $ x $ is $ 2 $ . It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5 \cdot 10^4 $ ( $ \sum n \le 5 \cdot 10^4 $ ).

## 输出格式

For each test case, print the answer — two ternary integers $ a $ and $ b $ both of length $ n $ and both without leading zeros such that $ a \odot b = x $ and $ max(a, b) $ is the minimum possible. If there are several answers, you can print any.

## 样例 #1

### 输入

```
4
5
22222
5
21211
1
2
9
220222021
```

### 输出

```
11111
11111
11000
10211
1
1
110111011
110111010
```



---

---
title: "Dreamoon and Ranking Collection"
layout: "post"
diff: 普及-
pid: CF1330A
tag: []
---

# Dreamoon and Ranking Collection

## 题目描述

Dreamoon 热衷于参加 Codeforces 竞赛。

一天，他声称自己再参加两场 rated 场后，就会获得过从第 $1$ 名到第 $54$ 名的所有名次。这真是不可思议！

基于此，你提出了如下一个问题：

张三参加了 $n$ 场 Codeforces 比赛。他第一场的排名为 $a_1$，第二场的排名为 $a_2$，……，第 $n$ 场的排名为 $a_n$。

给出一个正整数 $x$。请找到最大的 $v$，满足张三在再参加 $x$ 场 rated 比赛后，有可能取得 $1$ 到 $v$ 中所有名次。

换句话说，你需要找到最大的 $v$，满足在继续参加 $x$ 场 rated 比赛后，有可能对于任意的 $1 \le i \le v$，存在一场张三排在第 $i$ 名的比赛。

举个例子，如果 $n = 6, x = 2, a = [3, 1, 1, 5, 7, 10]$，那么答案 $v = 5$。因为如果接下来的两次比赛内，张三分别取得了第 $2$ 名和第 $4$ 名，他可以获得过第 $1$ 名到第 $5$ 名内的所有名次，所以 $v = 5$ 是可能达成的最大答案。


对于第二组测试数据，张三将会再参加 $100$ 场比赛，他可以以任意顺序取得第 $1, 2, \ldots, 99$ 和 $101$ 名，就获得过第 $1, 2, \ldots, 101$ 名中的所有名词。

## 输入格式

第一行输入一个整数 $t ~ (1 \le t \le 5)$，表示测试数据组数。

对于每组测试数据，输入两行。

第一行输入两个整数 $n, x ~ (1 \le n, x \le 100)$。

第二行输入 $n$ 个正整数 $a_1, a_2, \ldots, a_n ~ (1 \le a_i \le 100)$。

## 输出格式

对于每组测试数据，输出一行一个整数 $v$，表示在再参加 $x$ 次比赛后，有可能实现对于所有 $1 \le i \le v$，存在一场比赛张三排在第 $i$ 名。

## 样例 #1

### 输入

```
5
6 2
3 1 1 5 7 10
1 100
100
11 1
1 1 1 1 1 1 1 1 1 1 1
1 1
1
4 57
80 60 40 20
```

### 输出

```
5
101
2
2
60
```



---

---
title: "Exercising Walk"
layout: "post"
diff: 普及-
pid: CF1332A
tag: []
---

# Exercising Walk

## 题目描述

给定一个矩形，左下角顶点坐标为$(x_1,y_1)$，右上角顶点坐标为$(x_2,y_2)$。现在有一个起点$(x,y)$,以及四个数$a,b,c,d$,问能否从起点开始走若干步（向左，向右，向上或向下），使向左、右、下、上分别**共**走了$a,b,c,d$步。

## 输入格式

有$t$ 组测试数据，第一行输入一个整数$t$$(1\le t\le 10^3)$。

每组测试数据共两行，第一行输入四个整数$a,b,c,d$ $( 0 \le a,b,c,d \le 10^8 , a+b+c+d \ge 1)$。第二行输入六个整数$x,y,x_1,y_1,x_2,y_2$$(-10^8\le x_1\le x\le x_2\le 10^8,-10^8\le y_1\le y\le y_2\le 10^8)$。

## 输出格式

对于每一组测试数据，输出一行Yes或No。

## 样例 #1

### 输入

```
6
3 2 2 2
0 0 -2 -2 2 2
3 1 4 1
0 0 -1 -1 1 1
1 1 1 1
1 1 1 1 1 1
0 0 0 1
0 0 0 0 0 1
5 1 1 1
0 0 -100 -100 0 100
1 1 5 1
0 0 -100 -100 100 0
```

### 输出

```
Yes
No
No
Yes
Yes
Yes
```



---

---
title: "Little Artem"
layout: "post"
diff: 普及-
pid: CF1333A
tag: []
---

# Little Artem

## 题目描述

Young boy Artem tries to paint a picture, and he asks his mother Medina to help him. Medina is very busy, that's why she asked for your help.

Artem wants to paint an $ n \times m $ board. Each cell of the board should be colored in white or black.

Lets $ B $ be the number of black cells that have at least one white neighbor adjacent by the side. Let $ W $ be the number of white cells that have at least one black neighbor adjacent by the side. A coloring is called good if $ B = W + 1 $ .

The first coloring shown below has $ B=5 $ and $ W=4 $ (all cells have at least one neighbor with the opposite color). However, the second coloring is not good as it has $ B=4 $ , $ W=4 $ (only the bottom right cell doesn't have a neighbor with the opposite color).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1333A/34674661541310c7b0f570cbf7d03ed451c5851a.png)Please, help Medina to find any good coloring. It's guaranteed that under given constraints the solution always exists. If there are several solutions, output any of them.

## 输入格式

Each test contains multiple test cases.

The first line contains the number of test cases $ t $ ( $ 1 \le t \le 20 $ ). Each of the next $ t $ lines contains two integers $ n, m $ ( $ 2 \le n,m \le 100 $ ) — the number of rows and the number of columns in the grid.

## 输出格式

For each test case print $ n $ lines, each of length $ m $ , where $ i $ -th line is the $ i $ -th row of your colored matrix (cell labeled with 'B' means that the cell is black, and 'W' means white). Do not use quotes.

It's guaranteed that under given constraints the solution always exists.

## 说明/提示

In the first testcase, $ B=3 $ , $ W=2 $ .

In the second testcase, $ B=5 $ , $ W=4 $ . You can see the coloring in the statement.

## 样例 #1

### 输入

```
2
3 2
3 3
```

### 输出

```
BW
WB
BB
BWB
BWW
BWB
```



---

---
title: "Kind Anton"
layout: "post"
diff: 普及-
pid: CF1333B
tag: []
---

# Kind Anton

## 题目描述

Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:

There are two arrays of integers $ a $ and $ b $ of length $ n $ . It turned out that array $ a $ contains only elements from the set $ \{-1, 0, 1\} $ .

Anton can perform the following sequence of operations any number of times:

1. Choose any pair of indexes $ (i, j) $ such that $ 1 \le i < j \le n $ . It is possible to choose the same pair $ (i, j) $ more than once.
2. Add $ a_i $ to $ a_j $ . In other words, $ j $ -th element of the array becomes equal to $ a_i + a_j $ .

For example, if you are given array $ [1, -1, 0] $ , you can transform it only to $ [1, -1, -1] $ , $ [1, 0, 0] $ and $ [1, -1, 1] $ by one operation.

Anton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $ a $ so that it becomes equal to array $ b $ . Can you help him?

## 输入格式

Each test contains multiple test cases.

The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10000 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of arrays.

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ -1 \le a_i \le 1 $ ) — elements of array $ a $ . There can be duplicates among elements.

The third line of each test case contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ -10^9 \le b_i \le 10^9 $ ) — elements of array $ b $ . There can be duplicates among elements.

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case, output one line containing "YES" if it's possible to make arrays $ a $ and $ b $ equal by performing the described operations, or "NO" if it's impossible.

You can print each letter in any case (upper or lower).

## 说明/提示

In the first test-case we can choose $ (i, j)=(2, 3) $ twice and after that choose $ (i, j)=(1, 2) $ twice too. These operations will transform $ [1, -1, 0] \to [1, -1, -2] \to [1, 1, -2] $

In the second test case we can't make equal numbers on the second position.

In the third test case we can choose $ (i, j)=(1, 2) $ $ 41 $ times. The same about the fourth test case.

In the last lest case, it is impossible to make array $ a $ equal to the array $ b $ .

## 样例 #1

### 输入

```
5
3
1 -1 0
1 1 -2
3
0 1 1
0 2 2
2
1 0
1 41
2
-1 0
-1 -41
5
0 1 -1 1 -1
1 1 -1 1 -1
```

### 输出

```
YES
NO
YES
YES
NO
```



---

---
title: "Level Statistics"
layout: "post"
diff: 普及-
pid: CF1334A
tag: []
---

# Level Statistics

## 题目描述

Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by $ 1 $ . If he manages to finish the level successfully then the number of clears increases by $ 1 $ as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats $ n $ times and wrote down $ n $ pairs of integers — $ (p_1, c_1), (p_2, c_2), \dots, (p_n, c_n) $ , where $ p_i $ is the number of plays at the $ i $ -th moment of time and $ c_i $ is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

## 输入格式

The first line contains a single integer $ T $ $ (1 \le T \le 500) $ — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of moments of time Polycarp peeked at the stats.

Each of the next $ n $ lines contains two integers $ p_i $ and $ c_i $ ( $ 0 \le p_i, c_i \le 1000 $ ) — the number of plays and the number of clears of the level at the $ i $ -th moment of time.

Note that the stats are given in chronological order.

## 输出格式

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

## 说明/提示

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.

## 样例 #1

### 输入

```
6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0
```

### 输出

```
NO
YES
NO
YES
NO
YES
```



---

---
title: "Middle Class"
layout: "post"
diff: 普及-
pid: CF1334B
tag: []
---

# Middle Class

## 题目描述

Many years ago Berland was a small country where only $ n $ people lived. Each person had some savings: the $ i $ -th one had $ a_i $ burles.

The government considered a person as wealthy if he had at least $ x $ burles. To increase the number of wealthy people Berland decided to carry out several reforms. Each reform looked like that:

- the government chooses some subset of people (maybe all of them);
- the government takes all savings from the chosen people and redistributes the savings among the chosen people equally.

For example, consider the savings as list $ [5, 1, 2, 1] $ : if the government chose the $ 1 $ -st and the $ 3 $ -rd persons then it, at first, will take all $ 5 + 2 = 7 $ burles and after that will return $ 3.5 $ burles to the chosen people. As a result, the savings will become $ [3.5, 1, 3.5, 1] $ .

A lot of data was lost from that time, so we don't know how many reforms were implemented and to whom. All we can do is ask you to calculate the maximum possible number of wealthy people after several (maybe zero) reforms.

## 输入格式

The first line contains single integer $ T $ ( $ 1 \le T \le 1000 $ ) — the number of test cases.

Next $ 2T $ lines contain the test cases — two lines per test case. The first line contains two integers $ n $ and $ x $ ( $ 1 \le n \le 10^5 $ , $ 1 \le x \le 10^9 $ ) — the number of people and the minimum amount of money to be considered as wealthy.

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the initial savings of each person.

It's guaranteed that the total sum of $ n $ doesn't exceed $ 10^5 $ .

## 输出格式

Print $ T $ integers — one per test case. For each test case print the maximum possible number of wealthy people after several (maybe zero) reforms.

## 说明/提示

The first test case is described in the statement.

In the second test case, the government, for example, could carry out two reforms: $ [\underline{11}, \underline{9}, 11, 9] \rightarrow [10, 10, \underline{11}, \underline{9}] \rightarrow [10, 10, 10, 10] $ .

In the third test case, the government couldn't make even one person wealthy.

In the fourth test case, the government could choose all people to carry out a reform: $ [\underline{9}, \underline{4}, \underline{9}] \rightarrow [7\frac{1}{3}, 7\frac{1}{3}, 7\frac{1}{3}] $ .

## 样例 #1

### 输入

```
4
4 3
5 1 2 1
4 10
11 9 11 9
2 5
4 3
3 7
9 4 9
```

### 输出

```
2
4
0
3
```



---

---
title: "Two Teams Composing"
layout: "post"
diff: 普及-
pid: CF1335C
tag: []
---

# Two Teams Composing

## 题目描述

You have $ n $ students under your control and you have to compose exactly two teams consisting of some subset of your students. Each student had his own skill, the $ i $ -th student skill is denoted by an integer $ a_i $ (different students can have the same skills).

So, about the teams. Firstly, these two teams should have the same size. Two more constraints:

- The first team should consist of students with distinct skills (i.e. all skills in the first team are unique).
- The second team should consist of students with the same skills (i.e. all skills in the second team are equal).

Note that it is permissible that some student of the first team has the same skill as a student of the second team.

Consider some examples (skills are given):

- $ [1, 2, 3] $ , $ [4, 4] $ is not a good pair of teams because sizes should be the same;
- $ [1, 1, 2] $ , $ [3, 3, 3] $ is not a good pair of teams because the first team should not contain students with the same skills;
- $ [1, 2, 3] $ , $ [3, 4, 4] $ is not a good pair of teams because the second team should contain students with the same skills;
- $ [1, 2, 3] $ , $ [3, 3, 3] $ is a good pair of teams;
- $ [5] $ , $ [6] $ is a good pair of teams.

Your task is to find the maximum possible size $ x $ for which it is possible to compose a valid pair of teams, where each team size is $ x $ (skills in the first team needed to be unique, skills in the second team should be the same between them). A student cannot be part of more than one team.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of students. The second line of the test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ), where $ a_i $ is the skill of the $ i $ -th student. Different students can have the same skills.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ ( $ \sum n \le 2 \cdot 10^5 $ ).

## 输出格式

For each test case, print the answer — the maximum possible size $ x $ for which it is possible to compose a valid pair of teams, where each team size is $ x $ .

## 说明/提示

In the first test case of the example, it is possible to construct two teams of size $ 3 $ : the first team is $ [1, 2, 4] $ and the second team is $ [4, 4, 4] $ . Note, that there are some other ways to construct two valid teams of size $ 3 $ .

## 样例 #1

### 输入

```
4
7
4 2 4 1 4 3 4
5
2 1 5 4 3
1
1
4
1 1 1 3
```

### 输出

```
3
1
0
2
```



---

---
title: "Anti-Sudoku"
layout: "post"
diff: 普及-
pid: CF1335D
tag: []
---

# Anti-Sudoku

## 题目描述

You are given a correct solution of the sudoku puzzle. If you don't know what is the sudoku, you can read about it [here](http://tiny.cc/636xmz).

The picture showing the correct sudoku solution:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1335D/512a05a69fe045d0e0e90836d8dc5e29c119293a.png)

Blocks are bordered with bold black color.

Your task is to change at most $ 9 $ elements of this field (i.e. choose some $ 1 \le i, j \le 9 $ and change the number at the position $ (i, j) $ to any other number in range $ [1; 9] $ ) to make it anti-sudoku. The anti-sudoku is the $ 9 \times 9 $ field, in which:

- Any number in this field is in range $ [1; 9] $ ;
- each row contains at least two equal elements;
- each column contains at least two equal elements;
- each $ 3 \times 3 $ block (you can read what is the block in the link above) contains at least two equal elements.

It is guaranteed that the answer exists.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

Each test case consists of $ 9 $ lines, each line consists of $ 9 $ characters from $ 1 $ to $ 9 $ without any whitespaces — the correct solution of the sudoku puzzle.

## 输出格式

For each test case, print the answer — the initial field with at most $ 9 $ changed elements so that the obtained field is anti-sudoku. If there are several solutions, you can print any. It is guaranteed that the answer exists.

## 样例 #1

### 输入

```
1
154873296
386592714
729641835
863725149
975314628
412968357
631457982
598236471
247189563
```

### 输出

```
154873396
336592714
729645835
863725145
979314628
412958357
631457992
998236471
247789563
```



---

---
title: "Kana and Dragon Quest game"
layout: "post"
diff: 普及-
pid: CF1337B
tag: []
---

# Kana and Dragon Quest game

## 题目描述

现在我们有一条龙，它的血量为 $x$ 。

我们有两个技能：雷击和空洞吸收。

雷击：

攻击后使得龙的血量减 $10$ ，也就是说，原来 $h$ 的血量变为了 $h - 10$ 。

空洞吸收：

攻击后使得龙的血量变为：$[\frac{h}{2}]+10$  ，其中 $[h]$ 表示向下取整。

现在要知道是否可以在技能有使用次数的限制下打倒龙。

## 输入格式

**本题有多组数据**

第一行是一个整数 $T$,表示测试数据的组数。

接下来的 $T$ 行 分别包含三个整数： 龙的血量 $x$ ,
空洞吸收的使用次数 $n$ ，雷击的使用次数 $m$

## 输出格式

对于每一组数据，如果可以打倒龙，输出 “$YES$”（不带引号），否则输出 "$NO$"（不带引号）

## 说明/提示

$1 \le T \le 1000$。

$1 \le x \le 10^5$。

$0 \le n,m \le 30 $。

-----------
以下是样例 $1$ 的测试数据 $1$ 的解释：

(以 $L$ 代替 雷击, $V$ 代替 空洞吸收)

操作    || 血量状态

$V \ \ \ \ \ [\frac{100}{2}]+10 =60$

$L \ \ \ \ \ 60-10=50$

$V \ \ \ \ \  [\frac{50}{2}]+10=35$

$V \ \ \ \ \ [\frac {35}{2}]+10=27$

$L \ \ \ \ \ 27-10=17$

$L \ \ \ \ \ 17-10=7$

$L \ \ \ \ \ 7-10=-3$

·Translated by black_trees

## 样例 #1

### 输入

```
7
100 3 4
189 3 4
64 2 3
63 2 3
30 27 7
10 9 1
69117 21 2
```

### 输出

```
YES
NO
NO
YES
YES
YES
YES
```



---

---
title: "Filling Diamonds"
layout: "post"
diff: 普及-
pid: CF1339A
tag: []
---

# Filling Diamonds

## 题目描述

给定一个数字 $n$ ,要求你用 $n$ 个菱形去填满 $4n-2$ 个正三角形。求有多少种不同的填法。

其中，这一个菱形由两个正三角形组成，它可以被平移或是旋转，但是不可以被缩放。

上图是 $n \ = 1,2,3,4$ 时的需要填充的三角形。

## 输入格式

**本题有多组数据！**

第一行，一个整数 $T$ ，表示测试数据的组数

接下来的 $T$ 行中，每行只有一个整数 $n$ 。

## 输出格式

总共有 $T$ 行 ，每一行都输出一个整数，代表填充对应的 $4n - 2$ 个三角形的不同方式的种数。

## 说明/提示

------------


$1 \le T \le 10^{4}$。

$1 \le n \le 10^{9}$。
 
对于每一个测试数据，保证填充方法的种数 $\le 10^{18}$


------------


如下图，当 $n \ = 2 $ 时，有不同的两种填充方法。


------------

· Translated by black_trees

## 样例 #1

### 输入

```
2
2
1
```

### 输出

```
2
1
```



---

---
title: "Nastya and Rice"
layout: "post"
diff: 普及-
pid: CF1341A
tag: []
---

# Nastya and Rice

## 题目描述

有$n$个范围为$[a-b,a+b]$的数，判断他们的和是否可能在$[c-d,c+d]$范围中。

输入有多组数据（$1 \le T \le 1000$），保证：

- $1 \le n \le 1000$
- $0 \le b < a \le 1000 $
- $0 \le d < c \le 1000$

## 输入格式

- 第一行为数据组数$T$。
- 接下来每行五个整数，$n,a,b,c,d$。

## 输出格式

- 如果所有数的和可能在$[c-d,c+d]$范围中，输出`Yes`，否则输出`No`。

## 样例 #1

### 输入

```
5
7 20 3 101 18
11 11 10 234 2
8 9 7 250 122
19 41 21 321 10
3 10 8 6 1
```

### 输出

```
Yes
No
Yes
No
Yes
```



---

---
title: "Road To Zero"
layout: "post"
diff: 普及-
pid: CF1342A
tag: []
---

# Road To Zero

## 题目描述

You are given two integers $ x $ and $ y $ . You can perform two types of operations:

1. Pay $ a $ dollars and increase or decrease any of these integers by $ 1 $ . For example, if $ x = 0 $ and $ y = 7 $ there are four possible outcomes after this operation: 
  - $ x = 0 $ , $ y = 6 $ ;
  - $ x = 0 $ , $ y = 8 $ ;
  - $ x = -1 $ , $ y = 7 $ ;
  - $ x = 1 $ , $ y = 7 $ .
2. Pay $ b $ dollars and increase or decrease both integers by $ 1 $ . For example, if $ x = 0 $ and $ y = 7 $ there are two possible outcomes after this operation: 
  - $ x =             -1 $ , $ y = 6 $ ;
  - $ x = 1 $ , $ y = 8 $ .

Your goal is to make both given integers equal zero simultaneously, i.e. $ x = y = 0 $ . There are no other requirements. In particular, it is possible to move from $ x=1 $ , $ y=0 $ to $ x=y=0 $ .

Calculate the minimum amount of dollars you have to spend on it.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le       100 $ ) — the number of testcases.

The first line of each test case contains two integers $ x $ and $ y $ ( $ 0 \le x, y \le 10^9 $ ).

The second line of each test case contains two integers $ a $ and $ b $ ( $ 1 \le a, b \le 10^9 $ ).

## 输出格式

For each test case print one integer — the minimum amount of dollars you have to spend.

## 说明/提示

In the first test case you can perform the following sequence of operations: first, second, first. This way you spend $ 391 + 555       + 391 = 1337 $ dollars.

In the second test case both integers are equal to zero initially, so you dont' have to spend money.

## 样例 #1

### 输入

```
2
1 3
391 555
0 0
9 4
```

### 输出

```
1337
0
```



---

---
title: "Candies"
layout: "post"
diff: 普及-
pid: CF1343A
tag: []
---

# Candies

## 题目描述

Recently Vova found $ n $ candy wrappers. He remembers that he bought $ x $ candies during the first day, $ 2x $ candies during the second day, $ 4x $ candies during the third day, $ \dots $ , $ 2^{k-1} x $ candies during the $ k $ -th day. But there is an issue: Vova remembers neither $ x $ nor $ k $ but he is sure that $ x $ and $ k $ are positive integers and $ k > 1 $ .

Vova will be satisfied if you tell him any positive integer $ x $ so there is an integer $ k>1 $ that $ x + 2x + 4x + \dots +       2^{k-1} x = n $ . It is guaranteed that at least one solution exists. Note that $ k > 1 $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1       \le t \le 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The only line of the test case contains one integer $ n $ ( $ 3       \le n \le 10^9 $ ) — the number of candy wrappers Vova found. It is guaranteed that there is some positive integer $ x $ and integer $ k>1 $ that $ x + 2x + 4x + \dots + 2^{k-1} x = n $ .

## 输出格式

Print one integer — any positive integer value of $x$ so there is an integer $k>1$ that $x+2x+4x+⋯+2^{k-1}x=n$.

## 说明/提示

In the first test case of the example, one of the possible answers is $ x=1, k=2 $ . Then $ 1 \cdot 1 + 2 \cdot 1 $ equals $ n=3 $ .

In the second test case of the example, one of the possible answers is $ x=2, k=2 $ . Then $ 1 \cdot 2 + 2 \cdot 2 $ equals $ n=6 $ .

In the third test case of the example, one of the possible answers is $ x=1, k=3 $ . Then $ 1 \cdot 1 + 2 \cdot 1 + 4 \cdot       1 $ equals $ n=7 $ .

In the fourth test case of the example, one of the possible answers is $ x=7, k=2 $ . Then $ 1 \cdot 7 + 2 \cdot 7 $ equals $ n=21 $ .

In the fifth test case of the example, one of the possible answers is $ x=4, k=3 $ . Then $ 1 \cdot 4 + 2 \cdot 4 + 4 \cdot       4 $ equals $ n=28 $ .

## 样例 #1

### 输入

```
7
3
6
7
21
28
999999999
999999984
```

### 输出

```
1
2
1
7
4
333333333
333333328
```



---

---
title: "Balanced Array"
layout: "post"
diff: 普及-
pid: CF1343B
tag: []
---

# Balanced Array

## 题目描述

You are given a positive integer $ n $ , it is guaranteed that $ n $ is even (i.e. divisible by $ 2 $ ).

You want to construct the array $ a $ of length $ n $ such that:

- The first $ \frac{n}{2} $ elements of $ a $ are even (divisible by $ 2 $ );
- the second $ \frac{n}{2} $ elements of $ a $ are odd (not divisible by $ 2 $ );
- all elements of $ a $ are distinct and positive;
- the sum of the first half equals to the sum of the second half ( $ \sum\limits_{i=1}^{\frac{n}{2}} a_i =         \sum\limits_{i=\frac{n}{2} + 1}^{n} a_i $ ).

If there are multiple answers, you can print any. It is not guaranteed that the answer exists.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1       \le t \le 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The only line of the test case contains one integer $ n $ ( $ 2       \le n \le 2 \cdot 10^5 $ ) — the length of the array. It is guaranteed that that $ n $ is even (i.e. divisible by $ 2 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ ( $ \sum n \le 2 \cdot 10^5 $ ).

## 输出格式

For each test case, print the answer — "NO" (without quotes), if there is no suitable answer for the given test case or "YES" in the first line and any suitable array a1,a2,…,an (1≤ai≤10^9) satisfying conditions from the problem statement on the second line.

## 样例 #1

### 输入

```
5
2
4
6
8
10
```

### 输出

```
NO
YES
2 4 1 5
NO
YES
2 4 6 8 1 3 5 11
NO
```



---

---
title: "Card Constructions"
layout: "post"
diff: 普及-
pid: CF1345B
tag: []
---

# Card Constructions

## 题目描述

A card pyramid of height $ 1 $ is constructed by resting two cards against each other. For $ h>1 $ , a card pyramid of height $ h $ is constructed by placing a card pyramid of height $ h-1 $ onto a base. A base consists of $ h $ pyramids of height $ 1 $ , and $ h-1 $ cards on top. For example, card pyramids of heights $ 1 $ , $ 2 $ , and $ 3 $ look as follows:

  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1345B/c8f889835ab0788603a3c97f750b5560a2dca9f4.png)You start with $ n $ cards and build the tallest pyramid that you can. If there are some cards remaining, you build the tallest pyramid possible with the remaining cards. You repeat this process until it is impossible to build another pyramid. In the end, how many pyramids will you have constructed?

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1\le t\le 1000 $ ) — the number of test cases. Next $ t $ lines contain descriptions of test cases.

Each test case contains a single integer $ n $ ( $ 1\le n\le       10^9 $ ) — the number of cards.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^9 $ .

## 输出格式

For each test case output a single integer — the number of pyramids you will have constructed in the end.

## 说明/提示

In the first test, you construct a pyramid of height $ 1 $ with $ 2 $ cards. There is $ 1 $ card remaining, which is not enough to build a pyramid.

In the second test, you build two pyramids, each of height $ 2 $ , with no cards remaining.

In the third test, you build one pyramid of height $ 3 $ , with no cards remaining.

In the fourth test, you build one pyramid of height $ 3 $ with $ 9 $ cards remaining. Then you build a pyramid of height $ 2 $ with $ 2 $ cards remaining. Then you build a final pyramid of height $ 1 $ with no cards remaining.

In the fifth test, one card is not enough to build any pyramids.

## 样例 #1

### 输入

```
5
3
14
15
24
1
```

### 输出

```
1
2
1
3
0
```



---

---
title: "Average Numbers"
layout: "post"
diff: 普及-
pid: CF134A
tag: []
---

# Average Numbers

## 题目描述

You are given a sequence of positive integers $ a_{1},a_{2},...,a_{n} $ . Find all such indices $ i $ , that the $ i $ -th element equals the arithmetic mean of all other elements (that is all elements except for this one).

## 输入格式

The first line contains the integer $ n $ ( $ 2<=n<=2·10^{5} $ ). The second line contains elements of the sequence $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=1000 $ ). All the elements are positive integers.

## 输出格式

Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from $ 1 $ to $ n $ .

If the sought elements do not exist, then the first output line should contain number $ 0 $ . In this case you may either not print the second line or print an empty line.

## 样例 #1

### 输入

```
5
1 2 3 4 5

```

### 输出

```
1
3 
```

## 样例 #2

### 输入

```
4
50 50 50 50

```

### 输出

```
4
1 2 3 4 
```



---

---
title: "Same Parity Summands"
layout: "post"
diff: 普及-
pid: CF1352B
tag: []
---

# Same Parity Summands

## 题目描述

You are given two positive integers $ n $ ( $ 1 \le n \le       10^9 $ ) and $ k $ ( $ 1 \le k \le 100 $ ). Represent the number $ n $ as the sum of $ k $ positive integers of the same parity (have the same remainder when divided by $ 2 $ ).

In other words, find $ a_1, a_2, \ldots, a_k $ such that all $ a_i>0 $ , $ n = a_1 + a_2 + \ldots + a_k $ and either all $ a_i $ are even or all $ a_i $ are odd at the same time.

If such a representation does not exist, then report it.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le       1000 $ ) — the number of test cases in the input. Next, $ t $ test cases are given, one per line.

Each test case is two positive integers $ n $ ( $ 1 \le n \le       10^9 $ ) and $ k $ ( $ 1 \le k \le 100 $ ).

## 输出格式

For each test case print:

- YES and the required values $ a_i $ , if the answer exists (if there are several answers, print any of them);
- NO if the answer does not exist.

The letters in the words YES and NO can be printed in any case.

## 样例 #1

### 输入

```
8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9
```

### 输出

```
YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120
```



---

---
title: "K-th Not Divisible by n"
layout: "post"
diff: 普及-
pid: CF1352C
tag: []
---

# K-th Not Divisible by n

## 题目描述

给定两个正整数 $n$ 和 $k$。求出第 $k$ 个不能被 $n$ 整除的正整数。

例如，如果 $n=3$，$k=7$，那么所有不能被 $3$ 整除的数为：$1,2,4,5,7,8,10,11,13 \ldots$ 在这其中的第 $7$ 个数字为 $10$。

## 输入格式

**本题有多组数据**

第一行包括一个整数 $t$ $(1 \leq t \leq 1000)$，表示数据的组数。

接下来的 $t$ 行，每行两个正整数 $n$ $(2 \leq n \leq 10^9)$ 和 $k$ $(1 \leq k \leq 10^9)$。

## 输出格式

对于每一组数据，输出第 $k$ 个不能被 $n$ 整除的正整数。

## 样例 #1

### 输入

```
6
3 7
4 12
2 1000000000
7 97
1000000000 1000000000
2 1
```

### 输出

```
10
15
1999999999
113
1000000001
1
```



---

---
title: "Board Moves"
layout: "post"
diff: 普及-
pid: CF1353C
tag: []
---

# Board Moves

## 题目描述

有一个$n×n$的棋盘（$n$为奇数），一开始每个格子中都含有一个数。现在你可以进行以下操作：

一步操作指选定任意格中的恰好一个数，并将其移动到周围的八个格子中之一。也就是说，如果原来格子的坐标是$(i,j)$，那么你可以将这个数移到$(i+1,j)$$(i-1,j)$$(i+1,j+1)$$(i,j+1)$$(i-1,j+1)$$(i+1,j-1)$$(i,j-1)$$(i-1,j-1)$这八个格子中。

当然，你不能把棋子移到棋盘外。允许在一次操作后一个格子里存在多个数。

你的任务是找出操作的最小次数，使得所有的数都在一个方格内。也就是说在$(n^2-1)$个格子内都没有数，而在$1$个格子内有所有的数。

## 输入格式

**本题有多组测试数据**。

第一行一个整数$t(1<=t<=200)$，表示测试数据的组数；

接下来的$t$行，每行一个整数$n(1<=n<=5×10^5)$——棋盘的边长。保证$n$为奇数。

同时保证所有$t$个$n$的值的和不超过$5×10^5$。

## 输出格式

输出共$t$行，每行包含一个整数，表示每一组测试数据的答案。

## 样例 #1

### 输入

```
3
1
5
499993
```

### 输出

```
0
40
41664916690999888
```



---

---
title: "Sequence with Digits"
layout: "post"
diff: 普及-
pid: CF1355A
tag: []
---

# Sequence with Digits

## 题目描述

Let's define the following recurrence: $ $$$a_{n+1} = a_{n} +       minDigit(a_{n}) \cdot maxDigit(a_{n}). $ $ </p>     <p>Here  $ minDigit(x) $  and  $ maxDigit(x) $  are the minimal and       maximal digits in the decimal representation of  $ x $  without       leading zeroes. For examples refer to notes.</p>     <p>Your task is calculate  $ a\_{K} $  for given  $ a\_{1} $  and  $ K$$$.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le       1000 $ ) — the number of independent test cases.

Each test case consists of a single line containing two integers $ a_{1} $ and $ K $ ( $ 1 \le a_{1} \le 10^{18} $ , $ 1 \le K       \le 10^{16} $ ) separated by a space.

## 输出格式

For each test case print one integer $ a_{K} $ on a separate line.

## 说明/提示

$ a_{1} = 487 $

 $ a_{2} = a_{1} + minDigit(a_{1}) \cdot maxDigit(a_{1}) = 487 +       \min (4, 8, 7) \cdot \max (4, 8, 7) = 487 + 4 \cdot 8 = 519 $

 $ a_{3} = a_{2} + minDigit(a_{2}) \cdot maxDigit(a_{2}) = 519 +       \min (5, 1, 9) \cdot \max (5, 1, 9) = 519 + 1 \cdot 9 = 528 $

 $ a_{4} = a_{3} + minDigit(a_{3}) \cdot maxDigit(a_{3}) = 528 +       \min (5, 2, 8) \cdot \max (5, 2, 8) = 528 + 2 \cdot 8 = 544 $

 $ a_{5} = a_{4} + minDigit(a_{4}) \cdot maxDigit(a_{4}) = 544 +       \min (5, 4, 4) \cdot \max (5, 4, 4) = 544 + 4 \cdot 5 = 564 $

 $ a_{6} = a_{5} + minDigit(a_{5}) \cdot maxDigit(a_{5}) = 564 +       \min (5, 6, 4) \cdot \max (5, 6, 4) = 564 + 4 \cdot 6 = 588 $

 $ a_{7} = a_{6} + minDigit(a_{6}) \cdot maxDigit(a_{6}) = 588 +       \min (5, 8, 8) \cdot \max (5, 8, 8) = 588 + 5 \cdot 8 = 628 $

## 样例 #1

### 输入

```
8
1 4
487 1
487 2
487 3
487 4
487 5
487 6
487 7
```

### 输出

```
42
487
519
528
544
564
588
628
```



---

---
title: "Young Explorers"
layout: "post"
diff: 普及-
pid: CF1355B
tag: []
---

# Young Explorers

## 题目描述

Young wilderness explorers set off to their first expedition led by senior explorer Russell. Explorers went into a forest, set up a camp and decided to split into groups to explore as much interesting locations as possible. Russell was trying to form groups, but ran into some difficulties...

Most of the young explorers are inexperienced, and sending them alone would be a mistake. Even Russell himself became senior explorer not long ago. Each of young explorers has a positive integer parameter $ e_i $ — his inexperience. Russell decided that an explorer with inexperience $ e $ can only join the group of $ e $ or more people.

Now Russell needs to figure out how many groups he can organize. It's not necessary to include every explorer in one of the groups: some can stay in the camp. Russell is worried about this expedition, so he asked you to help him.

## 输入格式

The first line contains the number of independent test cases $ T $ ( $ 1 \leq T \leq 2 \cdot 10^5 $ ). Next $ 2T $ lines contain description of test cases.

The first line of description of each test case contains the number of young explorers $ N $ ( $ 1 \leq N \leq 2 \cdot 10^5 $ ).

The second line contains $ N $ integers $ e_1, e_2, \ldots,       e_N $ ( $ 1 \leq e_i \leq N $ ), where $ e_i $ is the inexperience of the $ i $ -th explorer.

It's guaranteed that sum of all $ N $ doesn't exceed $ 3 \cdot 10^5 $ .

## 输出格式

Print $ T $ numbers, each number on a separate line.

In $ i $ -th line print the maximum number of groups Russell can form in $ i $ -th test case.

## 说明/提示

In the first example we can organize three groups. There will be only one explorer in each group. It's correct because inexperience of each explorer equals to $ 1 $ , so it's not less than the size of his group.

In the second example we can organize two groups. Explorers with inexperience $ 1 $ , $ 2 $ and $ 3 $ will form the first group, and the other two explorers with inexperience equal to $ 2 $ will form the second group.

This solution is not unique. For example, we can form the first group using the three explorers with inexperience equal to $ 2 $ , and the second group using only one explorer with inexperience equal to $ 1 $ . In this case the young explorer with inexperience equal to $ 3 $ will not be included in any group.

## 样例 #1

### 输入

```
2
3
1 1 1
5
2 3 1 2 2
```

### 输出

```
3
2
```



---

---
title: "Maria Breaks the Self-isolation"
layout: "post"
diff: 普及-
pid: CF1358B
tag: []
---

# Maria Breaks the Self-isolation

## 题目描述

由于本场题面违反互联网相关法律，不予展示原题面。

## 样例 #1

### 输入

```
4
5
1 1 2 2 1
6
2 3 4 5 6 7
6
1 5 4 5 1 9
5
1 2 3 5 6
```

### 输出

```
6
1
6
4
```



---

---
title: "Berland Poker"
layout: "post"
diff: 普及-
pid: CF1359A
tag: []
---

# Berland Poker

## 题目描述

The game of Berland poker is played with a deck of $ n $ cards, $ m $ of which are jokers. $ k $ players play this game ( $ n $ is divisible by $ k $ ).

At the beginning of the game, each player takes $ \frac{n}{k} $ cards from the deck (so each card is taken by exactly one player). The player who has the maximum number of jokers is the winner, and he gets the number of points equal to $ x - y $ , where $ x $ is the number of jokers in the winner's hand, and $ y $ is the maximum number of jokers among all other players. If there are two or more players with maximum number of jokers, all of them are winners and they get $ 0 $ points.

Here are some examples:

- $ n = 8 $ , $ m = 3 $ , $ k = 2 $ . If one player gets $ 3 $ jokers and $ 1 $ plain card, and another player gets $ 0 $ jokers and $ 4 $ plain cards, then the first player is the winner and gets $ 3 - 0 = 3 $ points;
- $ n = 4 $ , $ m = 2 $ , $ k = 4 $ . Two players get plain cards, and the other two players get jokers, so both of them are winners and get $ 0 $ points;
- $ n = 9 $ , $ m = 6 $ , $ k = 3 $ . If the first player gets $ 3 $ jokers, the second player gets $ 1 $ joker and $ 2 $ plain cards, and the third player gets $ 2 $ jokers and $ 1 $ plain card, then the first player is the winner, and he gets $ 3 - 2 = 1 $ point;
- $ n = 42 $ , $ m = 0 $ , $ k = 7 $ . Since there are no jokers, everyone gets $ 0 $ jokers, everyone is a winner, and everyone gets $ 0 $ points.

Given $ n $ , $ m $ and $ k $ , calculate the maximum number of points a player can get for winning the game.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases.

Then the test cases follow. Each test case contains three integers $ n $ , $ m $ and $ k $ ( $ 2 \le n \le 50 $ , $ 0 \le m \le n $ , $ 2 \le k \le n $ , $ k $ is a divisors of $ n $ ).

## 输出格式

For each test case, print one integer — the maximum number of points a player can get for winning the game.

## 说明/提示

Test cases of the example are described in the statement.

## 样例 #1

### 输入

```
4
8 3 2
4 2 4
9 6 3
42 0 7
```

### 输出

```
3
0
1
0
```



---

---
title: "New Theatre Square"
layout: "post"
diff: 普及-
pid: CF1359B
tag: []
---

# New Theatre Square

## 题目描述

You might have remembered Theatre square from the [problem 1A](https://codeforces.com/problemset/problem/1/A). Now it's finally getting repaved.

The square still has a rectangular shape of $ n \times m $ meters. However, the picture is about to get more complicated now. Let $ a_{i,j} $ be the $ j $ -th square in the $ i $ -th row of the pavement.

You are given the picture of the squares:

- if $ a_{i,j} =  $ "\*", then the $ j $ -th square in the $ i $ -th row should be black;
- if $ a_{i,j} =  $ ".", then the $ j $ -th square in the $ i $ -th row should be white.

The black squares are paved already. You have to pave the white squares. There are two options for pavement tiles:

- $ 1 \times 1 $ tiles — each tile costs $ x $ burles and covers exactly $ 1 $ square;
- $ 1 \times 2 $ tiles — each tile costs $ y $ burles and covers exactly $ 2 $ adjacent squares of the same row. Note that you are not allowed to rotate these tiles or cut them into $ 1 \times 1 $ tiles.

You should cover all the white squares, no two tiles should overlap and no black squares should be covered by tiles.

What is the smallest total price of the tiles needed to cover all the white squares?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of testcases. Then the description of $ t $ testcases follow.

The first line of each testcase contains four integers $ n $ , $ m $ , $ x $ and $ y $ ( $ 1 \le n \le 100 $ ; $ 1 \le m \le 1000 $ ; $ 1 \le x, y \le 1000 $ ) — the size of the Theatre square, the price of the $ 1 \times 1 $ tile and the price of the $ 1 \times 2 $ tile.

Each of the next $ n $ lines contains $ m $ characters. The $ j $ -th character in the $ i $ -th line is $ a_{i,j} $ . If $ a_{i,j} =  $ "\*", then the $ j $ -th square in the $ i $ -th row should be black, and if $ a_{i,j} =  $ ".", then the $ j $ -th square in the $ i $ -th row should be white.

It's guaranteed that the sum of $ n \times m $ over all testcases doesn't exceed $ 10^5 $ .

## 输出格式

For each testcase print a single integer — the smallest total price of the tiles needed to cover all the white squares in burles.

## 说明/提示

In the first testcase you are required to use a single $ 1 \times 1 $ tile, even though $ 1 \times 2 $ tile is cheaper. So the total price is $ 10 $ burles.

In the second testcase you can either use two $ 1 \times 1 $ tiles and spend $ 20 $ burles or use a single $ 1 \times 2 $ tile and spend $ 1 $ burle. The second option is cheaper, thus the answer is $ 1 $ .

The third testcase shows that you can't rotate $ 1 \times 2 $ tiles. You still have to use two $ 1 \times 1 $ tiles for the total price of $ 20 $ .

In the fourth testcase the cheapest way is to use $ 1 \times 1 $ tiles everywhere. The total cost is $ 6 \cdot 3 = 18 $ .

## 样例 #1

### 输入

```
4
1 1 10 1
.
1 2 10 1
..
2 1 10 1
.
.
3 3 3 7
..*
*..
.*.
```

### 输出

```
10
1
20
18
```



---

---
title: "Replacement"
layout: "post"
diff: 普及-
pid: CF135A
tag: []
---

# Replacement

## 题目描述

Little Petya very much likes arrays consisting of $ n $ integers, where each of them is in the range from $ 1 $ to $ 10^{9} $ , inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from $ 1 $ to $ 10^{9} $ , inclusive. It is not allowed to replace a number with itself or to change no number at all.

After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=10^{5} $ ), which represents how many numbers the array has. The next line contains $ n $ space-separated integers — the array's description. All elements of the array lie in the range from $ 1 $ to $ 10^{9} $ , inclusive.

## 输出格式

Print $ n $ space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.

## 样例 #1

### 输入

```
5
1 2 3 4 5

```

### 输出

```
1 1 2 3 4

```

## 样例 #2

### 输入

```
5
2 3 4 5 6

```

### 输出

```
1 2 3 4 5

```

## 样例 #3

### 输入

```
3
2 2 2

```

### 输出

```
1 2 2

```



---

---
title: "Honest Coach"
layout: "post"
diff: 普及-
pid: CF1360B
tag: []
---

# Honest Coach

## 题目描述

你面前有 n 名运动员 运动员的编号从左到右分别是1--n你知道每个运动员的力量 编号为i的运动员的力量为si

   	你需要把所有运动员分到两队里，每队至少有一人，每名运动员必须在其中一队里。

    你需要在第一队里最强壮的运动员和第二队里最虚弱的运动员的差距尽可能的小。

    正式的，你想把运动员分成A，B两队导致价值∣max(A)−min(B)∣尽可能的小。

    其中max（A）是A队中力量最大的，min（B）是队伍中力量最小的。

    例如，如果n=5，力量分别为s={3,1,2,4,6}；则最理想的分配是：

    第一队 A={1,2,4}；第二队B={3，6}；

    这样一来最大的价值的绝对值是|4-3|=1，这个例子说明了一种最佳的分成两个团队的方法。输出最小的价值|max(A)-min(B)|。

## 输入格式

第一行输入一个t( 1≤t≤1000 ) --输入中的测试用例数。接下来是t测试用例。



每组数据包含两行，第一行是n（2≤n≤50）；



第二行包含n个数据S1，S2....Sn( 1≤Si≤1000 )

--Si表示每名运动员的力量 ，请注意，s值可能不明显。

## 输出格式

每组数据输出一行--把所有运动员分成两队后的∣max(A)−min(B)∣的最小值。



每个运动员都必须是这两个队中的一个。

## 样例 #1

### 输入

```
5
5
3 1 2 6 4
6
2 1 3 2 4 3
4
7 9 3 1
2
1 1000
3
100 150 200
```

### 输出

```
1
0
2
999
50
```



---

---
title: "Johnny and Ancient Computer"
layout: "post"
diff: 普及-
pid: CF1362A
tag: []
---

# Johnny and Ancient Computer

## 题目描述

Johnny has recently found an ancient, broken computer. The machine has only one register, which allows one to put in there one variable. Then in one operation, you can shift its bits left or right by at most three positions. The right shift is forbidden if it cuts off some ones. So, in fact, in one operation, you can multiply or divide your number by $ 2 $ , $ 4 $ or $ 8 $ , and division is only allowed if the number is divisible by the chosen divisor.

Formally, if the register contains a positive integer $ x $ , in one operation it can be replaced by one of the following:

- $ x \cdot 2 $
- $ x \cdot 4 $
- $ x \cdot 8 $
- $ x / 2 $ , if $ x $ is divisible by $ 2 $
- $ x / 4 $ , if $ x $ is divisible by $ 4 $
- $ x / 8 $ , if $ x $ is divisible by $ 8 $

For example, if $ x = 6 $ , in one operation it can be replaced by $ 12 $ , $ 24 $ , $ 48 $ or $ 3 $ . Value $ 6 $ isn't divisible by $ 4 $ or $ 8 $ , so there're only four variants of replacement.

Now Johnny wonders how many operations he needs to perform if he puts $ a $ in the register and wants to get $ b $ at the end.

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The following $ t $ lines contain a description of test cases.

The first and only line in each test case contains integers $ a $ and $ b $ ( $ 1 \leq a, b \leq 10^{18} $ ) — the initial and target value of the variable, respectively.

## 输出格式

Output $ t $ lines, each line should contain one integer denoting the minimum number of operations Johnny needs to perform. If Johnny cannot get $ b $ at the end, then write $ -1 $ .

## 说明/提示

In the first test case, Johnny can reach $ 5 $ from $ 10 $ by using the shift to the right by one (i.e. divide by $ 2 $ ).

In the second test case, Johnny can reach $ 44 $ from $ 11 $ by using the shift to the left by two (i.e. multiply by $ 4 $ ).

In the third test case, it is impossible for Johnny to reach $ 21 $ from $ 17 $ .

In the fourth test case, initial and target values are equal, so Johnny has to do $ 0 $ operations.

In the fifth test case, Johnny can reach $ 3 $ from $ 96 $ by using two shifts to the right: one by $ 2 $ , and another by $ 3 $ (i.e. divide by $ 4 $ and by $ 8 $ ).

## 样例 #1

### 输入

```
10
10 5
11 44
17 21
1 1
96 3
2 128
1001 1100611139403776
1000000000000000000 1000000000000000000
7 1
10 8
```

### 输出

```
1
1
-1
0
2
2
14
0
-1
-1
```



---

---
title: "Odd Selection"
layout: "post"
diff: 普及-
pid: CF1363A
tag: []
---

# Odd Selection

## 题目描述

给出一个 $n$ 项的数列，要求选出 $x$ 个数（不要求连续），使这 $x$ 个数的和为奇数。判断这是否可能。

## 输入格式

第一行一个整数 $t (1 \le t \le 100)$ ，表示测试数据的组数。

接下来的 $2t$ 行描述这 $t$ 组数据：

第一行两个整数 $n,x(1\le x\le n\le 1000)$ ，分别表示数列的项数和需要选出的项数。

第二行 $n$ 个整数，表示数列的 $n$ 项，第$i(1\le i\le n)$ 项满足 $1\le ai\le 1000$ 。

## 输出格式

输出共 $t$ 行，其中第 $i$ 行表示对于第 $i$ 组数据，是否存在一种选法，使得被选出的 $x$ 个数之和为奇数。可以则输出`Yes`，不可以则输出`No`。其中`Yes,No`中每个字符的大小写不限。

## 说明/提示

对于第一组数据，我们必须选出 $999$ ，其为奇数。

对于第二组数据，我们必须选出 $1000$ ，其不是奇数。

对于第三组数据，我们可以选择 $51$ ，使得总和为奇数。

对于第四组数据，我们必须选择 $51$ 与 $50$ ，和为 $51+50=101$ 为奇数。

对于第五组数据，我们必须选择全部的三个数，但是总和并不是奇数。

## 样例 #1

### 输入

```
5
1 1
999
1 1
1000
2 1
51 50
2 2
51 50
3 3
101 102 103
```

### 输出

```
Yes
No
Yes
Yes
No
```



---

---
title: "Subsequence Hate"
layout: "post"
diff: 普及-
pid: CF1363B
tag: []
---

# Subsequence Hate

## 题目描述

Shubham has a binary string $ s $ . A binary string is a string containing only characters "0" and "1".

He can perform the following operation on the string any amount of times:

- Select an index of the string, and flip the character at that index. This means, if the character was "0", it becomes "1", and vice versa.

A string is called good if it does not contain "010" or "101" as a subsequence — for instance, "1001" contains "101" as a subsequence, hence it is not a good string, while "1000" doesn't contain neither "010" nor "101" as subsequences, so it is a good string.

What is the minimum number of operations he will have to perform, so that the string becomes good? It can be shown that with these operations we can make any string good.

A string $ a $ is a subsequence of a string $ b $ if $ a $ can be obtained from $ b $ by deletion of several (possibly, zero or all) characters.

## 输入格式

The first line of the input contains a single integer $ t $ $ (1\le t \le 100) $ — the number of test cases.

Each of the next $ t $ lines contains a binary string $ s $ $ (1 \le |s| \le 1000) $ .

## 输出格式

For every string, output the minimum number of operations required to make it good.

## 说明/提示

In test cases $ 1 $ , $ 2 $ , $ 5 $ , $ 6 $ no operations are required since they are already good strings.

For the $ 3 $ rd test case: "001" can be achieved by flipping the first character — and is one of the possible ways to get a good string.

For the $ 4 $ th test case: "000" can be achieved by flipping the second character — and is one of the possible ways to get a good string.

For the $ 7 $ th test case: "000000" can be achieved by flipping the third and fourth characters — and is one of the possible ways to get a good string.

## 样例 #1

### 输入

```
7
001
100
101
010
0
1
001100
```

### 输出

```
0
0
1
1
0
0
2
```



---

---
title: "Matrix Game"
layout: "post"
diff: 普及-
pid: CF1365A
tag: []
---

# Matrix Game

## 题目描述

一个 $n$ 行 $m$ 列的网格图，有些格子上已经有 $1$，`Ashish` 和 `Vivek` 在这张网格图上做游戏，`Ashish` 先手。  

对于当前玩家，他需要在网格图上找一个位置设置为 $1$，条件是这一个位置所在的行以及列上都没有其他的 $1$，如果他不能操作了，那么他就输了。

求对于输入的网格图，谁能获胜。

## 输入格式

**本题有多组数据**

第一行有一个正整数 $T$，表示有 $T$ 组数据。  

每组数据的第一行有两个正整数 $n, m$，表示网格图的行数以及列数。  

之后 $n$ 行，每行一个长度为 $m$ 的 01 串，描述了这组数据的网格图上的这一行的初始状态。

保证 $1\le t,n,m\le50$。

## 输出格式

对于每组数据，输出胜者的名字。

## 样例 #1

### 输入

```
4
2 2
0 0
0 0
2 2
0 0
0 1
2 3
1 0 1
1 1 0
3 3
1 0 0
0 0 0
1 0 0
```

### 输出

```
Vivek
Ashish
Vivek
Ashish
```



---

---
title: "Even Array"
layout: "post"
diff: 普及-
pid: CF1367B
tag: []
---

# Even Array

## 题目描述

You are given an array $ a[0 \ldots n-1] $ of length $ n $ which consists of non-negative integers. Note that array indices start from zero.

An array is called good if the parity of each index matches the parity of the element at that index. More formally, an array is good if for all $ i $ ( $ 0 \le i \le n - 1 $ ) the equality $ i \bmod 2 = a[i] \bmod 2 $ holds, where $ x \bmod 2 $ is the remainder of dividing $ x $ by 2.

For example, the arrays \[ $ 0, 5, 2, 1 $ \] and \[ $ 0, 17, 0, 3 $ \] are good, and the array \[ $ 2, 4, 6, 7 $ \] is bad, because for $ i=1 $ , the parities of $ i $ and $ a[i] $ are different: $ i \bmod 2 = 1 \bmod 2 = 1 $ , but $ a[i] \bmod 2 = 4 \bmod 2 = 0 $ .

In one move, you can take any two elements of the array and swap them (these elements are not necessarily adjacent).

Find the minimum number of moves in which you can make the array $ a $ good, or say that this is not possible.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases in the test. Then $ t $ test cases follow.

Each test case starts with a line containing an integer $ n $ ( $ 1 \le n \le 40 $ ) — the length of the array $ a $ .

The next line contains $ n $ integers $ a_0, a_1, \ldots, a_{n-1} $ ( $ 0 \le a_i \le 1000 $ ) — the initial array.

## 输出格式

For each test case, output a single integer — the minimum number of moves to make the given array $ a $ good, or -1 if this is not possible.

## 说明/提示

In the first test case, in the first move, you can swap the elements with indices $ 0 $ and $ 1 $ , and in the second move, you can swap the elements with indices $ 2 $ and $ 3 $ .

In the second test case, in the first move, you need to swap the elements with indices $ 0 $ and $ 1 $ .

In the third test case, you cannot make the array good.

## 样例 #1

### 输入

```
4
4
3 2 7 6
3
3 2 6
1
7
7
4 9 2 1 18 3 0
```

### 输出

```
2
1
-1
0
```



---

---
title: "AccurateLee"
layout: "post"
diff: 普及-
pid: CF1369B
tag: []
---

# AccurateLee

## 题目描述

Lee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...

The string $ s $ he found is a binary string of length $ n $ (i. e. string consists only of 0-s and 1-s).

In one move he can choose two consecutive characters $ s_i $ and $ s_{i+1} $ , and if $ s_i $ is 1 and $ s_{i + 1} $ is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.

Lee can make an arbitrary number of moves (possibly zero) and he'd like to make the string $ s $ as clean as possible. He thinks for two different strings $ x $ and $ y $ , the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.

Now you should answer $ t $ test cases: for the $ i $ -th test case, print the cleanest possible string that Lee can get by doing some number of moves.

Small reminder: if we have two strings $ x $ and $ y $ of the same length then $ x $ is lexicographically smaller than $ y $ if there is a position $ i $ such that $ x_1 = y_1 $ , $ x_2 =       y_2 $ ,..., $ x_{i - 1} = y_{i - 1} $ and $ x_i < y_i $ .

## 输入格式

The first line contains the integer $ t $ ( $ 1 \le t \le       10^4 $ ) — the number of test cases.

Next $ 2t $ lines contain test cases — one per two lines.

The first line of each test case contains the integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of the string $ s $ .

The second line contains the binary string $ s $ . The string $ s $ is a string of length $ n $ which consists only of zeroes and ones.

It's guaranteed that sum of $ n $ over test cases doesn't exceed $ 10^5 $ .

## 输出格式

Print $ t $ answers — one per test case.

The answer to the $ i $ -th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).

## 说明/提示

In the first test case, Lee can't perform any moves.

In the second test case, Lee should erase $ s_2 $ .

In the third test case, Lee can make moves, for example, in the following order: 11001101 $ \rightarrow $ 1100101 $ \rightarrow $ 110101 $ \rightarrow $ 10101 $ \rightarrow $ 1101 $ \rightarrow $ 101 $ \rightarrow $ 01.

## 样例 #1

### 输入

```
5
10
0001111111
4
0101
8
11001101
10
1110000000
1
1
```

### 输出

```
0001111111
001
01
0
1
```



---

---
title: "Ternary Logic"
layout: "post"
diff: 普及-
pid: CF136B
tag: []
---

# Ternary Logic

## 题目描述

Little Petya very much likes computers. Recently he has received a new "Ternatron IV" as a gift from his mother. Unlike other modern computers, "Ternatron IV" operates with ternary and not binary logic. Petya immediately wondered how the $ xor $ operation is performed on this computer (and whether there is anything like it).

It turned out that the operation does exist (however, it is called $ tor $ ) and it works like this. Suppose that we need to calculate the value of the expression $ a\ tor\ b $ . Both numbers $ a $ and $ b $ are written in the ternary notation one under the other one ( $ b $ under $ a $ ). If they have a different number of digits, then leading zeroes are added to the shorter number until the lengths are the same. Then the numbers are summed together digit by digit. The result of summing each two digits is calculated modulo 3. Note that there is no carry between digits (i. e. during this operation the digits aren't transferred). For example: $ 14_{10}\ tor\ 50_{10}=0112_{3}\ tor\ 1212_{3}=1021_{3}=34_{10} $ .

Petya wrote numbers $ a $ and $ c $ on a piece of paper. Help him find such number $ b $ , that $ a\ tor\ b=c $ . If there are several such numbers, print the smallest one.

## 输入格式

The first line contains two integers $ a $ and $ c $ ( $ 0<=a,c<=10^{9} $ ). Both numbers are written in decimal notation.

## 输出格式

Print the single integer $ b $ , such that $ a\ tor\ b=c $ . If there are several possible numbers $ b $ , print the smallest one. You should print the number in decimal notation.

## 样例 #1

### 输入

```
14 34

```

### 输出

```
50

```

## 样例 #2

### 输入

```
50 34

```

### 输出

```
14

```

## 样例 #3

### 输入

```
387420489 225159023

```

### 输出

```
1000000001

```

## 样例 #4

### 输入

```
5 5

```

### 输出

```
0

```



---

---
title: "GCD Compression"
layout: "post"
diff: 普及-
pid: CF1370B
tag: []
---

# GCD Compression

## 题目描述

Ashish has an array $ a $ of consisting of $ 2n $ positive integers. He wants to compress $ a $ into an array $ b $ of size $ n-1 $ . To do this, he first discards exactly $ 2 $ (any two) elements from $ a $ . He then performs the following operation until there are no elements left in $ a $ :

- Remove any two elements from $ a $ and append their sum to $ b $ .

The compressed array $ b $ has to have a special property. The greatest common divisor ( $ \mathrm{gcd} $ ) of all its elements should be greater than $ 1 $ .

Recall that the $ \mathrm{gcd} $ of an array of positive integers is the biggest integer that is a divisor of all integers in the array.

It can be proven that it is always possible to compress array $ a $ into an array $ b $ of size $ n-1 $ such that $ gcd(b_1, b_2..., b_{n-1}) > 1 $ .

Help Ashish find a way to do so.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t       \leq 10 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \leq n \leq 1000 $ ).

The second line of each test case contains $ 2n $ integers $ a_1, a_2, \ldots, a_{2n} $ ( $ 1 \leq a_i \leq 1000 $ ) — the elements of the array $ a $ .

## 输出格式

For each test case, output $ n-1 $ lines — the operations performed to compress the array $ a $ to the array $ b $ . The initial discard of the two elements is not an operation, you don't need to output anything about it.

The $ i $ -th line should contain two integers, the indices ( $ 1 $ —based) of the two elements from the array $ a $ that are used in the $ i $ -th operation. All $ 2n-2 $ indices should be distinct integers from $ 1 $ to $ 2n $ .

You don't need to output two initially discarded elements from $ a $ .

If there are multiple answers, you can find any.

## 说明/提示

In the first test case, $ b = \{3+6, 4+5\} = \{9, 9\} $ and $ \mathrm{gcd}(9, 9) = 9 $ .

In the second test case, $ b = \{9+10\} = \{19\} $ and $ \mathrm{gcd}(19) = 19 $ .

In the third test case, $ b = \{1+2, 3+3, 4+5, 90+3\} = \{3, 6,       9, 93\} $ and $ \mathrm{gcd}(3, 6, 9, 93) = 3 $ .

## 样例 #1

### 输入

```
3
3
1 2 3 4 5 6
2
5 7 9 10
5
1 3 3 4 5 90 100 101 2 3
```

### 输出

```
3 6
4 5
3 4
1 9
2 3
4 5
6 10
```



---

---
title: "Omkar and Completion"
layout: "post"
diff: 普及-
pid: CF1372A
tag: []
---

# Omkar and Completion

## 题目描述

You have been blessed as a child of Omkar. To express your gratitude, please solve this problem for Omkar!

An array $ a $ of length $ n $ is called complete if all elements are positive and don't exceed $ 1000 $ , and for all indices $ x $ , $ y $ , $ z $ ( $ 1 \leq x,y,z \leq n $ ), $ a_{x}+a_{y} \neq a_{z} $ (not necessarily distinct).

You are given one integer $ n $ . Please find any complete array of length $ n $ . It is guaranteed that under given constraints such array exists.

## 输入格式

Each test contains multiple test cases. The first line contains $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Description of the test cases follows.

The only line of each test case contains one integer $ n $ ( $ 1 \leq n \leq 1000 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 1000 $ .

## 输出格式

For each test case, print a complete array on a single line. All elements have to be integers between $ 1 $ and $ 1000 $ and for all indices $ x $ , $ y $ , $ z $ ( $ 1 \leq x,y,z \leq       n $ ) (not necessarily distinct), $ a_{x}+a_{y} \neq a_{z} $ must hold.

If multiple solutions exist, you may print any.

## 说明/提示

It can be shown that the outputs above are valid for each test case. For example, $ 44+44 \neq 384 $ .

Below are some examples of arrays that are NOT complete for the 1st test case:

 $ [1,2,3,4,5] $

Notice that $ a_{1}+a_{2} = a_{3} $ .

 $ [1,3000,1,300,1] $

Notice that $ a_{2} = 3000 > 1000 $ .

## 样例 #1

### 输入

```
2
5
4
```

### 输出

```
1 5 3 77 12
384 384 44 44
```



---

---
title: "Donut Shops"
layout: "post"
diff: 普及-
pid: CF1373A
tag: []
---

# Donut Shops

## 题目描述

There are two rival donut shops.

The first shop sells donuts at retail: each donut costs $ a $ dollars.

The second shop sells donuts only in bulk: box of $ b $ donuts costs $ c $ dollars. So if you want to buy $ x $ donuts from this shop, then you have to buy the smallest number of boxes such that the total number of donuts in them is greater or equal to $ x $ .

You want to determine two positive integer values:

1. how many donuts can you buy so that they are strictly cheaper in the first shop than in the second shop?
2. how many donuts can you buy so that they are strictly cheaper in the second shop than in the first shop?

If any of these values doesn't exist then that value should be equal to $ -1 $ . If there are multiple possible answers, then print any of them.

 The printed values should be less or equal to $ 10^9 $ . It can be shown that under the given constraints such values always exist if any values exist at all.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le       1000 $ ) — the number of testcases.

Each of the next $ t $ lines contains three integers $ a $ , $ b $ and $ c $ ( $ 1 \le a \le 10^9 $ , $ 2 \le b \le       10^9 $ , $ 1 \le c \le 10^9 $ ).

## 输出格式

For each testcase print two positive integers. For both shops print such $ x $ that buying $ x $ donuts in this shop is strictly cheaper than buying $ x $ donuts in the other shop. $ x $ should be greater than $ 0 $ and less or equal to $ 10^9 $ .

If there is no such $ x $ , then print $ -1 $ . If there are multiple answers, then print any of them.

## 说明/提示

In the first testcase buying any number of donuts will be cheaper in the second shop. For example, for $ 3 $ or $ 5 $ donuts you'll have to buy a box of $ 10 $ donuts for $ 4 $ dollars. $ 3 $ or $ 5 $ donuts in the first shop would cost you $ 15 $ or $ 25 $ dollars, respectively, however. For $ 20 $ donuts you'll have to buy two boxes for $ 8 $ dollars total. Note that $ 3 $ and $ 5 $ are also valid answers for the second shop, along with many other answers.

In the second testcase buying any number of donuts will be either cheaper in the first shop or the same price. $ 8 $ donuts cost $ 32 $ dollars in the first shop and $ 40 $ dollars in the second shop (because you have to buy two boxes). $ 10 $ donuts will cost $ 40 $ dollars in both shops, so $ 10 $ is not a valid answer for any of the shops.

In the third testcase $ 1 $ donut costs $ 2 $ and $ 3 $ dollars, respectively. $ 2 $ donuts cost $ 4 $ and $ 3 $ dollars. Thus, $ 1 $ is a valid answer for the first shop and $ 2 $ is a valid answer for the second shop.

In the fourth testcase $ 10^9 $ donuts cost $ 10^{18} $ dollars in the first shop and $ 10^9 $ dollars in the second shop.

## 样例 #1

### 输入

```
4
5 10 4
4 5 20
2 2 3
1000000000 1000000000 1000000000
```

### 输出

```
-1 20
8 -1
1 2
-1 1000000000
```



---

---
title: "01 Game"
layout: "post"
diff: 普及-
pid: CF1373B
tag: []
---

# 01 Game

## 题目描述

**题目大意**

`Alice`和`Bob`在玩游戏。

初始有一个仅由`01`构成的字符串。`Alice`和`Bob`轮流进行游戏，`Alice`先行。轮到某个人的时候，他需要从原串中找到并删除两个相邻且不同的字符（`01`或`10`），无法操作者输。

两人都用最优的策略进行，你需要确定谁能够赢得游戏。

## 输入格式

第一行输入一个整数$t(1\le t \le 1000)$表示测试数据的数量。

接下类每组数据输入一个字符串$s(1\le |s|\le 100),|\sum|=\{'0','1'\}$,表示初始字符串。

## 输出格式

对于每组数据，如果`Alice`赢，输出`DA`,否则输出`NET`。

## 样例 #1

### 输入

```
3
01
1111
0011
```

### 输出

```
DA
NET
NET
```



---

---
title: "Multiply by 2, divide by 6"
layout: "post"
diff: 普及-
pid: CF1374B
tag: []
---

# Multiply by 2, divide by 6

## 题目描述

You are given an integer $ n $ . In one move, you can either multiply $ n $ by two or divide $ n $ by $ 6 $ (if it is divisible by $ 6 $ without the remainder).

Your task is to find the minimum number of moves needed to obtain $ 1 $ from $ n $ or determine if it's impossible to do that.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1       \le t \le 2 \cdot 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The only line of the test case contains one integer $ n $ ( $ 1       \le n \le 10^9 $ ).

## 输出格式

For each test case, print the answer — the minimum number of moves needed to obtain $ 1 $ from $ n $ if it's possible to do that or -1 if it's impossible to obtain $ 1 $ from $ n $ .

## 说明/提示

Consider the sixth test case of the example. The answer can be obtained by the following sequence of moves from the given integer $ 15116544 $ :

1. Divide by $ 6 $ and get $ 2519424 $ ;
2. divide by $ 6 $ and get $ 419904 $ ;
3. divide by $ 6 $ and get $ 69984 $ ;
4. divide by $ 6 $ and get $ 11664 $ ;
5. multiply by $ 2 $ and get $ 23328 $ ;
6. divide by $ 6 $ and get $ 3888 $ ;
7. divide by $ 6 $ and get $ 648 $ ;
8. divide by $ 6 $ and get $ 108 $ ;
9. multiply by $ 2 $ and get $ 216 $ ;
10. divide by $ 6 $ and get $ 36 $ ;
11. divide by $ 6 $ and get $ 6 $ ;
12. divide by $ 6 $ and get $ 1 $ .

## 样例 #1

### 输入

```
7
1
2
3
12
12345
15116544
387420489
```

### 输出

```
0
-1
2
-1
-1
12
36
```



---

---
title: "Sign Flipping"
layout: "post"
diff: 普及-
pid: CF1375A
tag: []
---

# Sign Flipping

## 题目描述

You are given $ n $ integers $ a_1, a_2, \dots, a_n $ , where $ n $ is odd. You are allowed to flip the sign of some (possibly all or none) of them. You wish to perform these flips in such a way that the following conditions hold:

1. At least $ \frac{n - 1}{2} $ of the adjacent differences $ a_{i + 1} - a_i $ for $ i = 1, 2, \dots, n - 1 $ are greater than or equal to $ 0 $ .
2. At least $ \frac{n - 1}{2} $ of the adjacent differences $ a_{i + 1} - a_i $ for $ i = 1, 2, \dots, n - 1 $ are less than or equal to $ 0 $ .

Find any valid way to flip the signs. It can be shown that under the given constraints, there always exists at least one choice of signs to flip that satisfies the required condition. If there are several solutions, you can find any of them.

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 3 \le n \le 99 $ , $ n $ is odd) — the number of integers given to you.

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ -10^9 \le a_i \le 10^9 $ ) — the numbers themselves.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10000 $ .

## 输出格式

For each test case, print $ n $ integers $ b_1, b_2, \dots,       b_n $ , corresponding to the integers after flipping signs. $ b_i $ has to be equal to either $ a_i $ or $ -a_i $ , and of the adjacent differences $ b_{i + 1} - b_i $ for $ i = 1,       \dots, n - 1 $ , at least $ \frac{n - 1}{2} $ should be non-negative and at least $ \frac{n - 1}{2} $ should be non-positive.

It can be shown that under the given constraints, there always exists at least one choice of signs to flip that satisfies the required condition. If there are several solutions, you can find any of them.

## 说明/提示

In the first test case, the difference $ (-4) - (-2) = -2 $ is non-positive, while the difference $ 3 - (-4) = 7 $ is non-negative.

In the second test case, we don't have to flip any signs. All $ 4 $ differences are equal to $ 0 $ , which is both non-positive and non-negative.

In the third test case, $ 7 - (-4) $ and $ 4 - (-6) $ are non-negative, while $ (-4) - (-2) $ and $ (-6) - 7 $ are non-positive.

## 样例 #1

### 输入

```
5
3
-2 4 3
5
1 1 1 1 1
5
-2 4 7 -6 4
9
9 7 -4 -2 1 -3 9 -4 -5
9
-4 1 9 4 8 9 5 1 -9
```

### 输出

```
-2 -4 3
1 1 1 1 1
-2 -4 7 -6 4
-9 -7 -4 2 1 -3 -9 -4 -5
4 -1 -9 -4 -8 -9 -5 -1 9
```



---

---
title: "Permutation"
layout: "post"
diff: 普及-
pid: CF137B
tag: []
---

# Permutation

## 题目描述

"作业时间到啦"-- Polycarpus突然想道。当然，他要先做他最喜欢的科目IT（计算机~）Polycarpus奇迹般地在20分钟内做完了除了最后一题以外的所有题目--不过他在最后一题上卡住了。所以Polycarpus想让你帮帮他：

此题定义中，排列就是，在保证1-n个整数都被包含的情况下n个整数的顺序。现在你有一个随机的序列a1,a2,...an（一共n个整数），每个数>=1且<=5000。请帮Polycarpus求出他获得一个排列之前最少需要改变多少数（他不能删除或加入数）。所谓的一次改变就是指把序列中的一个数改掉，比如说换成另一个整数。

## 输入格式

第一行为整数n(1<=n<=5000),也就是序列中数的个数。第二行为所有整数ai的序列（1<=ai<=5000,1<=i<=n）

## 输出格式

只输出一个数：最少步数

~~（样例省略不翻译）~~

## 说明/提示

第一个样例就是一个“排列”，所以不用进行改变；

第二个样例中只需要一次改变（关于数字1的改变），所以答案是2；

第三个样例中我们可以把第二个数变成4，第三个数变成2.

## 样例 #1

### 输入

```
3
3 1 2

```

### 输出

```
0

```

## 样例 #2

### 输入

```
2
2 2

```

### 输出

```
1

```

## 样例 #3

### 输入

```
5
5 3 3 3 1

```

### 输出

```
2

```



---

---
title: "History"
layout: "post"
diff: 普及-
pid: CF137C
tag: []
---

# History

## 题目描述

Polycarpus likes studying at school a lot and he is always diligent about his homework. Polycarpus has never had any problems with natural sciences as his great-great-grandfather was the great physicist Seinstein. On the other hand though, Polycarpus has never had an easy time with history.

Everybody knows that the World history encompasses exactly $ n $ events: the $ i $ -th event had continued from the year $ a_{i} $ to the year $ b_{i} $ inclusive ( $ a_{i}&lt;b_{i} $ ). Polycarpus easily learned the dates when each of $ n $ events started and ended (Polycarpus inherited excellent memory from his great-great-granddad). But the teacher gave him a more complicated task: Polycaprus should know when all events began and ended and he should also find out for each event whether it includes another event. Polycarpus' teacher thinks that an event $ j $ includes an event $ i $ if $ a_{j}&lt;a_{i} $ and $ b_{i}&lt;b_{j} $ . Your task is simpler: find the number of events that are included in some other event.

## 输入格式

The first input line contains integer $ n $ ( $ 1<=n<=10^{5} $ ) which represents the number of events. Next $ n $ lines contain descriptions of the historical events, one event per line. The $ i+1 $ line contains two integers $ a_{i} $ and $ b_{i} $ ( $ 1<=a_{i}&lt;b_{i}<=10^{9} $ ) — the beginning and the end of the $ i $ -th event. No two events start or finish in the same year, that is, $ a_{i}≠a_{j},a_{i}≠b_{j},b_{i}≠a_{j},b_{i}≠b_{j} $ for all $ i $ , $ j $ (where $ i≠j $ ). Events are given in arbitrary order.

## 输出格式

Print the only integer — the answer to the problem.

## 说明/提示

In the first example the fifth event is contained in the fourth. Similarly, the fourth event is contained in the third, the third — in the second and the second — in the first.

In the second example all events except the first one are contained in the first.

In the third example only one event, so the answer is 0.

## 样例 #1

### 输入

```
5
1 10
2 9
3 8
4 7
5 6

```

### 输出

```
4

```

## 样例 #2

### 输入

```
5
1 100
2 50
51 99
52 98
10 60

```

### 输出

```
4

```

## 样例 #3

### 输入

```
1
1 1000000000

```

### 输出

```
0

```



---

---
title: "Three Indices"
layout: "post"
diff: 普及-
pid: CF1380A
tag: []
---

# Three Indices

## 题目描述

You are given a permutation $ p_1, p_2, \dots, p_n $ . Recall that sequence of $ n $ integers is called a permutation if it contains all integers from $ 1 $ to $ n $ exactly once.

Find three indices $ i $ , $ j $ and $ k $ such that:

- $ 1 \le i < j < k \le n $ ;
- $ p_i < p_j $ and $ p_j > p_k $ .

 Or say that there are no such indices.

## 输入格式

The first line contains a single integer $ T $ ( $ 1 \le T \le       200 $ ) — the number of test cases.

Next $ 2T $ lines contain test cases — two lines per test case. The first line of each test case contains the single integer $ n $ ( $ 3 \le n \le 1000 $ ) — the length of the permutation $ p $ .

The second line contains $ n $ integers $ p_1, p_2, \dots,       p_n $ ( $ 1 \le p_i \le n $ ; $ p_i \neq p_j $ if $ i \neq       j $ ) — the permutation $ p $ .

## 输出格式

For each test case:

- if there are such indices $ i $ , $ j $ and $ k $ , print YES (case insensitive) and the indices themselves;
- if there are no such indices, print NO (case insensitive).

If there are multiple valid triples of indices, print any of them.

## 样例 #1

### 输入

```
3
4
2 1 4 3
6
4 6 1 2 5 3
5
5 3 1 2 4
```

### 输出

```
YES
2 3 4
YES
3 5 6
NO
```



---

---
title: "Universal Solution"
layout: "post"
diff: 普及-
pid: CF1380B
tag: []
---

# Universal Solution

## 题目描述

Recently, you found a bot to play "Rock paper scissors" with. Unfortunately, the bot uses quite a simple algorithm to play: he has a string $ s = s_1 s_2 \dots s_{n} $ of length $ n $ where each letter is either R, S or P.

While initializing, the bot is choosing a starting index $ pos $ ( $ 1 \le pos \le n $ ), and then it can play any number of rounds. In the first round, he chooses "Rock", "Scissors" or "Paper" based on the value of $ s_{pos} $ :

- if $ s_{pos} $ is equal to R the bot chooses "Rock";
- if $ s_{pos} $ is equal to S the bot chooses "Scissors";
- if $ s_{pos} $ is equal to P the bot chooses "Paper";

In the second round, the bot's choice is based on the value of $ s_{pos + 1} $ . In the third round — on $ s_{pos + 2} $ and so on. After $ s_n $ the bot returns to $ s_1 $ and continues his game.

You plan to play $ n $ rounds and you've already figured out the string $ s $ but still don't know what is the starting index $ pos $ . But since the bot's tactic is so boring, you've decided to find $ n $ choices to each round to maximize the average number of wins.

In other words, let's suggest your choices are $ c_1 c_2 \dots       c_n $ and if the bot starts from index $ pos $ then you'll win in $ win(pos) $ rounds. Find $ c_1 c_2 \dots c_n $ such that $ \frac{win(1) + win(2) + \dots + win(n)}{n} $ is maximum possible.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le       1000 $ ) — the number of test cases.

Next $ t $ lines contain test cases — one per line. The first and only line of each test case contains string $ s = s_1 s_2       \dots s_{n} $ ( $ 1 \le n \le 2 \cdot 10^5 $ ; $ s_i \in       \{\text{R}, \text{S}, \text{P}\} $ ) — the string of the bot.

It's guaranteed that the total length of all strings in one test doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print $ n $ choices $ c_1 c_2 \dots c_n $ to maximize the average number of wins. Print them in the same manner as the string $ s $ .

If there are multiple optimal answers, print any of them.

## 说明/提示

In the first test case, the bot (wherever it starts) will always choose "Rock", so we can always choose "Paper". So, in any case, we will win all $ n = 4 $ rounds, so the average is also equal to $ 4 $ .

In the second test case:

- if bot will start from $ pos = 1 $ , then $ (s_1,         c_1) $ is draw, $ (s_2, c_2) $ is draw and $ (s_3, c_3) $ is draw, so $ win(1) = 0 $ ;
- if bot will start from $ pos = 2 $ , then $ (s_2, c_1) $ is win, $ (s_3, c_2) $ is win and $ (s_1, c_3) $ is win, so $ win(2) = 3 $ ;
- if bot will start from $ pos = 3 $ , then $ (s_3, c_1) $ is lose, $ (s_1, c_2) $ is lose and $ (s_2, c_3) $ is lose, so $ win(3) = 0 $ ;

 The average is equal to $ \frac{0 + 3 + 0}{3} = 1 $ and it can be proven that it's the maximum possible average. A picture from Wikipedia explaining "Rock paper scissors" game:

  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1380B/19e6d37b1bc101bbdb7001f87def1e230fc259d2.png)

## 样例 #1

### 输入

```
3
RRRR
RSP
S
```

### 输出

```
PPPP
RSP
R
```



---

---
title: "Create The Teams"
layout: "post"
diff: 普及-
pid: CF1380C
tag: []
---

# Create The Teams

## 题目描述

There are $ n $ programmers that you want to split into several non-empty teams. The skill of the $ i $ -th programmer is $ a_i $ . You want to assemble the maximum number of teams from them. There is a restriction for each team: the number of programmers in the team multiplied by the minimum skill among all programmers in the team must be at least $ x $ .

Each programmer should belong to at most one team. Some programmers may be left without a team.

Calculate the maximum number of teams that you can assemble.

## 输入格式

The first line contains the integer $ t $ ( $ 1 \le t \le       1000 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ x $ ( $ 1 \le n \le 10^5; 1 \le x \le 10^9 $ ) — the number of programmers and the restriction of team skill respectively.

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots , a_n $ ( $ 1 \le a_i \le 10^9 $ ), where $ a_i $ is the skill of the $ i $ -th programmer.

The sum of $ n $ over all inputs does not exceed $ 10^5 $ .

## 输出格式

For each test case print one integer — the maximum number of teams that you can assemble.

## 样例 #1

### 输入

```
3
5 10
7 11 2 9 5
4 8
2 4 2 3
4 11
1 3 3 7
```

### 输出

```
2
1
0
```



---

---
title: "Sequential Nim"
layout: "post"
diff: 普及-
pid: CF1382B
tag: []
---

# Sequential Nim

## 题目描述

There are $ n $ piles of stones, where the $ i $ -th pile has $ a_i $ stones. Two people play a game, where they take alternating turns removing stones.

In a move, a player may remove a positive number of stones from the first non-empty pile (the pile with the minimal index, that has at least one stone). The first player who cannot make a move (because all piles are empty) loses the game. If both players play optimally, determine the winner of the game.

## 输入格式

The first line contains a single integer $ t $ ( $ 1\le t\le       1000 $ ) — the number of test cases. Next $ 2t $ lines contain descriptions of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1\le n\le 10^5 $ ) — the number of piles.

The second line of each test case contains $ n $ integers $ a_1,\ldots,a_n $ ( $ 1\le a_i\le 10^9 $ ) — $ a_i $ is equal to the number of stones in the $ i $ -th pile.

It is guaranteed that the sum of $ n $ for all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, if the player who makes the first move will win, output "First". Otherwise, output "Second".

## 说明/提示

In the first test case, the first player will win the game. His winning strategy is:

1. The first player should take the stones from the first pile. He will take $ 1 $ stone. The numbers of stones in piles will be $ [1, 5, 4] $ .
2. The second player should take the stones from the first pile. He will take $ 1 $ stone because he can't take any other number of stones. The numbers of stones in piles will be $ [0,         5, 4] $ .
3. The first player should take the stones from the second pile because the first pile is empty. He will take $ 4 $ stones. The numbers of stones in piles will be $ [0, 1, 4] $ .
4. The second player should take the stones from the second pile because the first pile is empty. He will take $ 1 $ stone because he can't take any other number of stones. The numbers of stones in piles will be $ [0, 0, 4] $ .
5. The first player should take the stones from the third pile because the first and second piles are empty. He will take $ 4 $ stones. The numbers of stones in piles will be $ [0, 0,         0] $ .
6. The second player will lose the game because all piles will be empty.

## 样例 #1

### 输入

```
7
3
2 5 4
8
1 1 1 1 1 1 1 1
6
1 2 3 4 5 6
6
1 1 2 1 2 2
1
1000000000
5
1 2 2 1 1
3
1 1 1
```

### 输出

```
First
Second
Second
First
First
Second
First
```



---

---
title: "Common Prefixes"
layout: "post"
diff: 普及-
pid: CF1384A
tag: []
---

# Common Prefixes

## 题目描述

The length of the longest common prefix of two strings $ s = s_1 s_2 \ldots s_n $ and $ t       = t_1 t_2 \ldots t_m $ is defined as the maximum integer $ k $ ( $ 0 \le k \le min(n,m) $ ) such that $ s_1 s_2 \ldots s_k $ equals $ t_1 t_2 \ldots t_k $ .

Koa the Koala initially has $ n+1 $ strings $ s_1, s_2, \dots, s_{n+1} $ .

For each $ i $ ( $ 1 \le i \le n $ ) she calculated $ a_i $ — the length of the longest common prefix of $ s_i $ and $ s_{i+1} $ .

Several days later Koa found these numbers, but she couldn't remember the strings.

So Koa would like to find some strings $ s_1, s_2, \dots,       s_{n+1} $ which would have generated numbers $ a_1, a_2, \dots,       a_n $ . Can you help her?

If there are many answers print any. We can show that answer always exists for the given constraints.

## 输入格式

Each test contains multiple test cases. The first line contains $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of elements in the list $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 50 $ ) — the elements of $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 100 $ .

## 输出格式

For each test case:

Output $ n+1 $ lines. In the $ i $ -th line print string $ s_i $ ( $ 1 \le |s_i| \le 200 $ ), consisting of lowercase Latin letters. Length of the longest common prefix of strings $ s_i $ and $ s_{i+1} $ has to be equal to $ a_i $ .

If there are many answers print any. We can show that answer always exists for the given constraints.

## 说明/提示

In the $ 1 $ -st test case one of the possible answers is $ s =       [aeren, ari, arousal, around, ari] $ .

Lengths of longest common prefixes are:

- Between $ \color{red}{a}eren $ and $ \color{red}{a}ri $ $ \rightarrow 1 $
- Between $ \color{red}{ar}i $ and $ \color{red}{ar}ousal $ $ \rightarrow 2 $
- Between $ \color{red}{arou}sal $ and $ \color{red}{arou}nd $ $ \rightarrow 4 $
- Between $ \color{red}{ar}ound $ and $ \color{red}{ar}i $ $ \rightarrow 2 $

## 样例 #1

### 输入

```
4
4
1 2 4 2
2
5 3
3
1 3 1
3
0 0 0
```

### 输出

```
aeren
ari
arousal
around
ari
monogon
monogamy
monthly
kevinvu
kuroni
kurioni
korone
anton
loves
adhoc
problems
```



---

---
title: "Captain Flint and Crew Recruitment"
layout: "post"
diff: 普及-
pid: CF1388A
tag: []
---

# Captain Flint and Crew Recruitment

## 题目描述

如果一个正整数能写成两个不同质数的积，那么我们称它为类质数。

给定一个自然数 $n$，请问是否能将 $n$ 写成四个**互不相同**的正整数的和，并满足这四个正整数中**至少**有三个是类质数。如果能，请给出一种方案。

## 输入格式

**本题包含多组测试数据。**

第一行包含一个整数 $T$ $(1 \le T \le 1000)$，表示数据组数。

接下来 $T$ 行每行一个整数 $n(1 \le n \le 2\times10^5)$。

## 输出格式

对于每组数据，若不能被分解成满足要求的四个正整数，单独输出一行 `NO`。

否则第一行输出 `YES`，第二行输出以单个空格分隔的四个正整数，表示一种可行方案。

Translated by [cmll02](https://www.luogu.com.cn/user/171487)

## 样例 #1

### 输入

```
7
7
23
31
36
44
100
258
```

### 输出

```
NO
NO
YES
14 10 6 1
YES
5 6 10 15
YES
6 7 10 21
YES
2 10 33 55
YES
10 21 221 6
```



---

---
title: "Captain Flint and a Long Voyage"
layout: "post"
diff: 普及-
pid: CF1388B
tag: []
---

# Captain Flint and a Long Voyage

## 题目描述

若有一个 $n$ 位正整数 $x$，定义 $k$ 的值为将 $x$ 的每一位上的数字转换为二进制（不含前导 $0$）。比如 $x=729$ 时，$k=111101001$。将 $k$ 的后 $n$ 位截去得到 $r$。比如 $x=729$ 时，$r=111101$。

现在给定 $n$，你需要找到 $r$ 最大时 $x$ 的最小值。

## 输入格式

第一行一个整数 $T(1\le t\le1000)$，表示数据组数。

接下来 $T$ 行，每行一个正整数 $n(1\le n\le 10^5)$。

## 输出格式

对于每组数据，输出一行一个正整数，表示 $r$ 最大时 $x$ 的最小值。

## 说明/提示

$1\le t\le1000$，$1\le n\le 10^5$。

数据保证所有数据中的 $n$ 之和不超过 $2\times10^5$。

Translated by [cmll02](https://www.luogu.com.cn/user/171487).

## 样例 #1

### 输入

```
2
1
3
```

### 输出

```
8
998
```



---

---
title: "Fix You"
layout: "post"
diff: 普及-
pid: CF1391B
tag: []
---

# Fix You

## 题目描述

给你一个 $n \times m$ 的矩阵，每一格上有个一标记不是 $R$ 就是 $D$，如果为 $R$ 表示这一格的物品会被送到这一格紧邻的右边的那一格，如果为 $D$ 表示这一格的物品会被送到这一格紧邻的下边的那一格。问你最少修改（$R$ 变 $D$ 或者 $D$ 变 $R$）多少次使得不管哪一个里的物品最后都能到达 $(n,m)$。

translated by [yu__xuan](https://www.luogu.com.cn/user/142110)

## 输入格式

多组测试。

第一行一个 $t \ (1 \leq t \leq 10)$，表示数据组数。

每一组数据第一行为 $n,m \ (1 \leq n,m \leq 100)$ 表示矩阵有 $n$ 行 $m$ 列。

接下来有 $n$ 行每行 $m$ 个字符为 $R$ 或 $D$（无空格分隔）。

## 输出格式

对于每组数据输出一行表示最少修改多少次。

## 样例 #1

### 输入

```
4
3 3
RRD
DDR
RRC
1 4
DDDC
6 9
RDDDDDRRR
RRDDRRDDD
RRDRDRRDR
DDDDRDDRR
DRRDRDDDR
DDRDRRDDC
1 1
C
```

### 输出

```
1
3
9
0
```



---

---
title: "Omkar and Password"
layout: "post"
diff: 普及-
pid: CF1392A
tag: []
---

# Omkar and Password

## 题目描述

Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret!

A password is an array $ a $ of $ n $ positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index $ i $ such that $ 1 \leq i       < n $ and $ a_{i} \neq a_{i+1} $ , delete both $ a_i $ and $ a_{i+1} $ from the array and put $ a_{i}+a_{i+1} $ in their place.

For example, for array $ [7, 4, 3, 7] $ you can choose $ i =       2 $ and the array will become $ [7, 4+3, 7] = [7, 7, 7] $ . Note that in this array you can't apply this operation anymore.

Notice that one operation will decrease the size of the password by $ 1 $ . What is the shortest possible length of the password after some number (possibly $ 0 $ ) of operations?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the length of the password.

The second line of each test case contains $ n $ integers $ a_{1},a_{2},\dots,a_{n} $ ( $ 1 \leq a_{i} \leq 10^9 $ ) — the initial contents of your password.

The sum of $ n $ over all test cases will not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each password, print one integer: the shortest possible length of the password after some number of operations.

## 说明/提示

In the first test case, you can do the following to achieve a length of $ 1 $ :

Pick $ i=2 $ to get $ [2, 4, 1] $

Pick $ i=1 $ to get $ [6, 1] $

Pick $ i=1 $ to get $ [7] $

In the second test case, you can't perform any operations because there is no valid $ i $ that satisfies the requirements mentioned above.

## 样例 #1

### 输入

```
2
4
2 1 3 1
2
420 420
```

### 输出

```
1
2
```



---

---
title: "Rainbow Dash, Fluttershy and Chess Coloring"
layout: "post"
diff: 普及-
pid: CF1393A
tag: []
---

# Rainbow Dash, Fluttershy and Chess Coloring

## 题目描述

One evening Rainbow Dash and Fluttershy have come up with a game. Since the ponies are friends, they have decided not to compete in the game but to pursue a common goal.

The game starts on a square flat grid, which initially has the outline borders built up. Rainbow Dash and Fluttershy have flat square blocks with size $ 1\times1 $ , Rainbow Dash has an infinite amount of light blue blocks, Fluttershy has an infinite amount of yellow blocks.

The blocks are placed according to the following rule: each newly placed block must touch the built on the previous turns figure by a side (note that the outline borders of the grid are built initially). At each turn, one pony can place any number of blocks of her color according to the game rules.

Rainbow and Fluttershy have found out that they can build patterns on the grid of the game that way. They have decided to start with something simple, so they made up their mind to place the blocks to form a chess coloring. Rainbow Dash is well-known for her speed, so she is interested in the minimum number of turns she and Fluttershy need to do to get a chess coloring, covering the whole grid with blocks. Please help her find that number!

Since the ponies can play many times on different boards, Rainbow Dash asks you to find the minimum numbers of turns for several grids of the games.

The chess coloring in two colors is the one in which each square is neighbor by side only with squares of different colors.

## 输入格式

The first line contains a single integer $ T $ ( $ 1 \le T \le       100 $ ): the number of grids of the games.

Each of the next $ T $ lines contains a single integer $ n $ ( $ 1 \le n \le 10^9 $ ): the size of the side of the grid of the game.

## 输出格式

For each grid of the game print the minimum number of turns required to build a chess coloring pattern out of blocks on it.

## 说明/提示

For $ 3\times3 $ grid ponies can make two following moves: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1393A/e700c5c9ebb73cd50fb6689a87a04ee305695b19.png)

## 样例 #1

### 输入

```
2
3
4
```

### 输出

```
2
3
```



---

---
title: "Boboniu Likes to Color Balls"
layout: "post"
diff: 普及-
pid: CF1395A
tag: []
---

# Boboniu Likes to Color Balls

## 题目描述

Boboniu gives you

- $ r $ red balls,
- $ g $ green balls,
- $ b $ blue balls,
- $ w $ white balls.

He allows you to do the following operation as many times as you want:

- Pick a red ball, a green ball, and a blue ball and then change their color to white.

You should answer if it's possible to arrange all the balls into a palindrome after several (possibly zero) number of described operations.

## 输入格式

The first line contains one integer $ T $ ( $ 1\le T\le 100 $ ) denoting the number of test cases.

For each of the next $ T $ cases, the first line contains four integers $ r $ , $ g $ , $ b $ and $ w $ ( $ 0\le r,g,b,w\le 10^9 $ ).

## 输出格式

For each test case, print "Yes" if it's possible to arrange all the balls into a palindrome after doing several (possibly zero) number of described operations. Otherwise, print "No".

## 说明/提示

In the first test case, you're not able to do any operation and you can never arrange three balls of distinct colors into a palindrome.

In the second test case, after doing one operation, changing $ (8,1,9,3) $ to $ (7,0,8,6) $ , one of those possible palindromes may be "rrrwwwbbbbrbbbbwwwrrr".

A palindrome is a word, phrase, or sequence that reads the same backwards as forwards. For example, "rggbwbggr", "b", "gg" are palindromes while "rgbb", "gbbgr" are not. Notice that an empty word, phrase, or sequence is palindrome.

## 样例 #1

### 输入

```
4
0 1 1 1
8 1 9 3
0 0 0 0
1000000000 1000000000 1000000000 1000000000
```

### 输出

```
No
Yes
Yes
Yes
```



---

---
title: "Boboniu Plays Chess"
layout: "post"
diff: 普及-
pid: CF1395B
tag: []
---

# Boboniu Plays Chess

## 题目描述

Boboniu likes playing chess with his employees. As we know, no employee can beat the boss in the chess game, so Boboniu has never lost in any round.

You are a new applicant for his company. Boboniu will test you with the following chess question:

Consider a $ n\times m $ grid (rows are numbered from $ 1 $ to $ n $ , and columns are numbered from $ 1 $ to $ m $ ). You have a chess piece, and it stands at some cell $ (S_x,S_y) $ which is not on the border (i.e. $ 2 \le S_x \le n-1 $ and $ 2       \le S_y \le m-1 $ ).

From the cell $ (x,y) $ , you can move your chess piece to $ (x,y') $ ( $ 1\le y'\le m, y' \neq y $ ) or $ (x',y) $ ( $ 1\le x'\le n, x'\neq x $ ). In other words, the chess piece moves as a rook. From the cell, you can move to any cell on the same row or column.

Your goal is to visit each cell exactly once. Can you find a solution?

Note that cells on the path between two adjacent cells in your route are not counted as visited, and it is not required to return to the starting point.

## 输入格式

The only line of the input contains four integers $ n $ , $ m $ , $ S_x $ and $ S_y $ ( $ 3\le n,m\le 100 $ , $ 2 \le       S_x \le n-1 $ , $ 2 \le S_y \le m-1 $ ) — the number of rows, the number of columns, and the initial position of your chess piece, respectively.

## 输出格式

You should print $ n\cdot m $ lines.

The $ i $ -th line should contain two integers $ x_i $ and $ y_i $ ( $ 1 \leq x_i \leq n $ , $ 1 \leq y_i \leq m $ ), denoting the $ i $ -th cell that you visited. You should print exactly $ nm $ pairs $ (x_i, y_i) $ , they should cover all possible pairs $ (x_i, y_i) $ , such that $ 1 \leq x_i \leq       n $ , $ 1 \leq y_i \leq m $ .

We can show that under these constraints there always exists a solution. If there are multiple answers, print any.

## 说明/提示

Possible routes for two examples:

  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1395B/c064004f0504fcb32a549da42e8ef5b0adb837cd.png)

## 样例 #1

### 输入

```
3 3 2 2
```

### 输出

```
2 2
1 2
1 3
2 3
3 3
3 2
3 1
2 1
1 1
```

## 样例 #2

### 输入

```
3 4 2 2
```

### 输出

```
2 2
2 1
2 3
2 4
1 4
3 4
3 3
3 2
3 1
1 1
1 2
1 3
```



---

---
title: "Remove Smallest"
layout: "post"
diff: 普及-
pid: CF1399A
tag: []
---

# Remove Smallest

## 题目描述

You are given the array $ a $ consisting of $ n $ positive (greater than zero) integers.

In one move, you can choose two indices $ i $ and $ j $ ( $ i       \ne j $ ) such that the absolute difference between $ a_i $ and $ a_j $ is no more than one ( $ |a_i - a_j| \le 1 $ ) and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one).

Your task is to find if it is possible to obtain the array consisting of only one element using several (possibly, zero) such moves or not.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1       \le t \le 1000 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 50 $ ) — the length of $ a $ . The second line of the test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 100 $ ), where $ a_i $ is the $ i $ -th element of $ a $ .

## 输出格式

For each test case, print the answer: "YES" if it is possible to obtain the array consisting of only one element using several (possibly, zero) moves described in the problem statement, or "NO" otherwise.

## 说明/提示

In the first test case of the example, we can perform the following sequence of moves:

- choose $ i=1 $ and $ j=3 $ and remove $ a_i $ (so $ a $ becomes $ [2; 2] $ );
- choose $ i=1 $ and $ j=2 $ and remove $ a_j $ (so $ a $ becomes $ [2] $ ).

In the second test case of the example, we can choose any possible $ i $ and $ j $ any move and it doesn't matter which element we remove.

In the third test case of the example, there is no way to get rid of $ 2 $ and $ 4 $ .

## 样例 #1

### 输入

```
5
3
1 2 2
4
5 5 5 5
3
1 2 4
4
1 3 4 4
1
100
```

### 输出

```
YES
YES
NO
NO
YES
```



---

---
title: "Gifts Fixing"
layout: "post"
diff: 普及-
pid: CF1399B
tag: []
---

# Gifts Fixing

## 题目描述

You have $ n $ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $ i $ -th gift consists of $ a_i $ candies and $ b_i $ oranges.

During one move, you can choose some gift $ 1 \le i \le n $ and do one of the following operations:

- eat exactly one candy from this gift (decrease $ a_i $ by one);
- eat exactly one orange from this gift (decrease $ b_i $ by one);
- eat exactly one candy and exactly one orange from this gift (decrease both $ a_i $ and $ b_i $ by one).

Of course, you can not eat a candy or orange if it's not present in the gift (so neither $ a_i $ nor $ b_i $ can become less than zero).

As said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $ a_1 = a_2 = \dots = a_n $ and $ b_1 = b_2 = \dots       = b_n $ (and $ a_i $ equals $ b_i $ is not necessary).

Your task is to find the minimum number of moves required to equalize all the given gifts.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1       \le t \le 1000 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 50 $ ) — the number of gifts. The second line of the test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ), where $ a_i $ is the number of candies in the $ i $ -th gift. The third line of the test case contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ 1 \le b_i       \le 10^9 $ ), where $ b_i $ is the number of oranges in the $ i $ -th gift.

## 输出格式

For each test case, print one integer: the minimum number of moves required to equalize all the given gifts.

## 说明/提示

In the first test case of the example, we can perform the following sequence of moves:

- choose the first gift and eat one orange from it, so $ a         = [3, 5, 6] $ and $ b = [2, 2, 3] $ ;
- choose the second gift and eat one candy from it, so $ a =         [3, 4, 6] $ and $ b = [2, 2, 3] $ ;
- choose the second gift and eat one candy from it, so $ a =         [3, 3, 6] $ and $ b = [2, 2, 3] $ ;
- choose the third gift and eat one candy and one orange from it, so $ a = [3, 3, 5] $ and $ b = [2, 2, 2] $ ;
- choose the third gift and eat one candy from it, so $ a =         [3, 3, 4] $ and $ b = [2, 2, 2] $ ;
- choose the third gift and eat one candy from it, so $ a =         [3, 3, 3] $ and $ b = [2, 2, 2] $ .

## 样例 #1

### 输入

```
5
3
3 5 6
3 2 3
5
1 2 3 4 5
5 4 3 2 1
3
1 1 1
2 2 2
6
1 1000000000 1000000000 1000000000 1000000000 1000000000
1 1 1 1 1 1
3
10 12 8
7 5 4
```

### 输出

```
6
16
0
4999999995
7
```



---

---
title: "String Similarity"
layout: "post"
diff: 普及-
pid: CF1400A
tag: []
---

# String Similarity

## 题目描述

A binary string is a string where each character is either 0 or 1. Two binary strings $ a $ and $ b $ of equal length are similar, if they have the same character in some position (there exists an integer $ i $ such that $ a_i = b_i $ ). For example:

- 10010 and 01111 are similar (they have the same character in position $ 4 $ );
- 10010 and 11111 are similar;
- 111 and 111 are similar;
- 0110 and 1001 are not similar.

You are given an integer $ n $ and a binary string $ s $ consisting of $ 2n-1 $ characters. Let's denote $ s[l..r] $ as the contiguous substring of $ s $ starting with $ l $ -th character and ending with $ r $ -th character (in other words, $ s[l..r] = s_l s_{l + 1} s_{l + 2} \dots s_r $ ).

You have to construct a binary string $ w $ of length $ n $ which is similar to all of the following strings: $ s[1..n] $ , $ s[2..n+1] $ , $ s[3..n+2] $ , ..., $ s[n..2n-1] $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le       1000 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 50 $ ).

The second line of each test case contains the binary string $ s $ of length $ 2n - 1 $ . Each character $ s_i $ is either 0 or 1.

## 输出格式

For each test case, print the corresponding binary string $ w $ of length $ n $ . If there are multiple such strings — print any of them. It can be shown that at least one string $ w $ meeting the constraints always exists.

## 说明/提示

The explanation of the sample case (equal characters in equal positions are bold):

The first test case:

- $ \mathbf{1} $ is similar to $ s[1..1] = \mathbf{1} $ .

The second test case:

- $ \mathbf{000} $ is similar to $ s[1..3] =         \mathbf{000} $ ;
- $ \mathbf{000} $ is similar to $ s[2..4] =         \mathbf{000} $ ;
- $ \mathbf{000} $ is similar to $ s[3..5] =         \mathbf{000} $ .

The third test case:

- $ \mathbf{1}0\mathbf{10} $ is similar to $ s[1..4] =         \mathbf{1}1\mathbf{10} $ ;
- $ \mathbf{1}01\mathbf{0} $ is similar to $ s[2..5] =         \mathbf{1}10\mathbf{0} $ ;
- $ \mathbf{10}1\mathbf{0} $ is similar to $ s[3..6] =         \mathbf{10}0\mathbf{0} $ ;
- $ 1\mathbf{0}1\mathbf{0} $ is similar to $ s[4..7] =         0\mathbf{0}0\mathbf{0} $ .

The fourth test case:

- $ 0\mathbf{0} $ is similar to $ s[1..2] =         1\mathbf{0} $ ;
- $ \mathbf{0}0 $ is similar to $ s[2..3] = \mathbf{0}1 $ .

## 样例 #1

### 输入

```
4
1
1
3
00000
4
1110000
2
101
```

### 输出

```
1
000
1010
00
```



---

---
title: "Ternary Sequence"
layout: "post"
diff: 普及-
pid: CF1401B
tag: []
---

# Ternary Sequence

## 题目描述

You are given two sequences $ a_1, a_2, \dots, a_n $ and $ b_1, b_2, \dots, b_n $ . Each element of both sequences is either $ 0 $ , $ 1 $ or $ 2 $ . The number of elements $ 0 $ , $ 1 $ , $ 2 $ in the sequence $ a $ is $ x_1 $ , $ y_1 $ , $ z_1 $ respectively, and the number of elements $ 0 $ , $ 1 $ , $ 2 $ in the sequence $ b $ is $ x_2 $ , $ y_2 $ , $ z_2 $ respectively.

You can rearrange the elements in both sequences $ a $ and $ b $ however you like. After that, let's define a sequence $ c $ as follows:

 $ c_i = \begin{cases} a_i b_i & \mbox{if }a_i > b_i \\ 0       & \mbox{if }a_i = b_i \\ -a_i b_i & \mbox{if }a_i < b_i \end{cases} $

You'd like to make $ \sum_{i=1}^n c_i $ (the sum of all elements of the sequence $ c $ ) as large as possible. What is the maximum possible sum?

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le       10^4 $ ) — the number of test cases.

Each test case consists of two lines. The first line of each test case contains three integers $ x_1 $ , $ y_1 $ , $ z_1 $ ( $ 0       \le x_1, y_1, z_1 \le 10^8 $ ) — the number of $ 0 $ -s, $ 1 $ -s and $ 2 $ -s in the sequence $ a $ .

The second line of each test case also contains three integers $ x_2 $ , $ y_2 $ , $ z_2 $ ( $ 0 \le x_2, y_2, z_2 \le       10^8 $ ; $ x_1 + y_1 + z_1 = x_2 + y_2 + z_2 > 0 $ ) — the number of $ 0 $ -s, $ 1 $ -s and $ 2 $ -s in the sequence $ b $ .

## 输出格式

For each test case, print the maximum possible sum of the sequence $ c $ .

## 说明/提示

In the first sample, one of the optimal solutions is:

 $ a = \{2, 0, 1, 1, 0, 2, 1\} $

 $ b = \{1, 0, 1, 0, 2, 1, 0\} $

 $ c = \{2, 0, 0, 0, 0, 2, 0\} $

In the second sample, one of the optimal solutions is:

 $ a = \{0, 2, 0, 0, 0\} $

 $ b = \{1, 1, 0, 1, 0\} $

 $ c = \{0, 2, 0, 0, 0\} $

In the third sample, the only possible solution is:

 $ a = \{2\} $

 $ b = \{2\} $

 $ c = \{0\} $

## 样例 #1

### 输入

```
3
2 3 2
3 3 1
4 0 1
2 3 0
0 0 1
0 0 1
```

### 输出

```
4
2
0
```



---

---
title: "Maximum Product"
layout: "post"
diff: 普及-
pid: CF1406B
tag: []
---

# Maximum Product

## 题目描述

You are given an array of integers $ a_1,a_2,\ldots,a_n $ . Find the maximum possible value of $ a_ia_ja_ka_la_t $ among all five indices $ (i, j, k, l, t) $ ( $ i<j<k<l<t $ ).

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1\le t\le 2 \cdot 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 5\le n\le 10^5 $ ) — the size of the array.

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ -3\times 10^3\le a_i\le 3\times 10^3 $ ) — given array.

It's guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, print one integer — the answer to the problem.

## 说明/提示

In the first test case, choosing $ a_1,a_2,a_3,a_4,a_5 $ is a best choice: $ (-1)\cdot (-2) \cdot (-3)\cdot (-4)\cdot (-5)=-120 $ .

In the second test case, choosing $ a_1,a_2,a_3,a_5,a_6 $ is a best choice: $ (-1)\cdot (-2) \cdot (-3)\cdot 2\cdot (-1)=12 $ .

In the third test case, choosing $ a_1,a_2,a_3,a_4,a_5 $ is a best choice: $ (-1)\cdot 0\cdot 0\cdot 0\cdot (-1)=0 $ .

In the fourth test case, choosing $ a_1,a_2,a_3,a_4,a_6 $ is a best choice: $ (-9)\cdot (-7) \cdot (-5)\cdot (-3)\cdot 1=945 $ .

## 样例 #1

### 输入

```
4
5
-1 -2 -3 -4 -5
6
-1 -2 -3 1 2 -1
6
-1 0 0 0 -1 -1
6
-9 -7 -5 -3 -2 1
```

### 输出

```
-120
12
0
945
```



---

---
title: "Ahahahahahahahaha"
layout: "post"
diff: 普及-
pid: CF1407A
tag: []
---

# Ahahahahahahahaha

## 题目描述

Alexandra 有一个由若干$0$和$1$组成的数组$a$，且数组$a$的长度$n$为偶数，数列中所有元素的编号依次为$1$ ~ $n$。她希望在数组中删除一些元素，来使得奇数编号位置上的数字之和等于偶数编号位置上的数字之和（$a_1 - a_2 + a_3 - a_4 + ... = 0$），最多删除$\frac{n}{2}$个元素且删除的元素不必是连续的



例如，如果原数组$a$ =  $\left[1,0,1,0,0,0\right]$,且她删除了原数列中的第$2$个和第$4$个元素，那么数组$a$将变成$\left[1,1,0,0\right]$，并且奇数编号位置上的数字之和等于偶数编号位置上的数字之和。



帮帮她解决这个问题吧！

## 输入格式

每个测试点包含多组样例，输入的第一行包含一个数字t，表示样例的组数。($1 \le t \le 10^3$ )



接下来每两行为一组样例，其中第一行包含一个整数$n$，表示数组的长度。($2 \le n \le 10^3$ 且 n为偶数)



第二行包含n个整数，分别为数组中的每个元素 $a_1, a_2, a_3, ... , a_n$。（$0 \le a_i \le 1$ ）



输入数据保证所有测试点中$n$的和不超过$10^3$。

## 输出格式

对于每组样例，第一行输出$k$，用来表示经过删除操作后数组$a$中剩下的元素个数。（$\frac{n}{2} \le k \le n$）



然后在第二行中，输出这剩下的$k$个数字。注意是输出这些数字本身，而不是输出他们的编号。



显而易见的是答案必然会存在至少一个，如果有多个答案，你可以输出其中的任何一个答案。

## 样例 #1

### 输入

```
4
2
1 0
2
0 0
4
0 1 1 1
4
1 1 0 0
```

### 输出

```
1
0
1
0
2
1 1
4
1 1 0 0
```



---

---
title: "Minimum Product"
layout: "post"
diff: 普及-
pid: CF1409B
tag: []
---

# Minimum Product

## 题目描述

You are given four integers $ a $ , $ b $ , $ x $ and $ y $ . Initially, $ a \ge x $ and $ b \ge y $ . You can do the following operation no more than $ n $ times:

- Choose either $ a $ or $ b $ and decrease it by one. However, as a result of this operation, value of $ a $ cannot become less than $ x $ , and value of $ b $ cannot become less than $ y $ .

Your task is to find the minimum possible product of $ a $ and $ b $ ( $ a \cdot b $ ) you can achieve by applying the given operation no more than $ n $ times.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 2 \cdot 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The only line of the test case contains five integers $ a $ , $ b $ , $ x $ , $ y $ and $ n $ ( $ 1 \le a, b, x, y, n \le 10^9 $ ). Additional constraint on the input: $ a \ge x $ and $ b \ge y $ always holds.

## 输出格式

For each test case, print one integer: the minimum possible product of $ a $ and $ b $ ( $ a \cdot b $ ) you can achieve by applying the given operation no more than $ n $ times.

## 说明/提示

In the first test case of the example, you need to decrease $ b $ three times and obtain $ 10 \cdot 7 = 70 $ .

In the second test case of the example, you need to decrease $ a $ one time, $ b $ one time and obtain $ 11 \cdot 7 = 77 $ .

In the sixth test case of the example, you need to decrease $ a $ five times and obtain $ 5 \cdot 11 = 55 $ .

In the seventh test case of the example, you need to decrease $ b $ ten times and obtain $ 10 \cdot 1 = 10 $ .

## 样例 #1

### 输入

```
7
10 10 8 5 3
12 8 8 7 2
12343 43 4543 39 123212
1000000000 1000000000 1 1 1
1000000000 1000000000 1 1 1000000000
10 11 2 1 5
10 11 9 1 10
```

### 输出

```
70
77
177177
999999999000000000
999999999
55
10
```



---

---
title: "Yet Another Array Restoration"
layout: "post"
diff: 普及-
pid: CF1409C
tag: []
---

# Yet Another Array Restoration

## 题目描述

We have a secret array. You don't know this array and you have to restore it. However, you know some facts about this array:

- The array consists of $ n $ distinct positive (greater than $ 0 $ ) integers.
- The array contains two elements $ x $ and $ y $ (these elements are known for you) such that $ x < y $ .
- If you sort the array in increasing order (such that $ a_1 < a_2 < \ldots < a_n $ ), differences between all adjacent (consecutive) elements are equal (i.e. $ a_2 - a_1 = a_3 - a_2 = \ldots = a_n - a_{n-1}) $ .

It can be proven that such an array always exists under the constraints given below.

Among all possible arrays that satisfy the given conditions, we ask you to restore one which has the minimum possible maximum element. In other words, you have to minimize $ \max(a_1, a_2, \dots, a_n) $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Then $ t $ test cases follow.

The only line of the test case contains three integers $ n $ , $ x $ and $ y $ ( $ 2 \le n \le 50 $ ; $ 1 \le x < y \le 50 $ ) — the length of the array and two elements that are present in the array, respectively.

## 输出格式

For each test case, print the answer: $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ), where $ a_i $ is the $ i $ -th element of the required array. If there are several answers, you can print any (it also means that the order of elements doesn't matter).

It can be proven that such an array always exists under the given constraints.

## 样例 #1

### 输入

```
5
2 1 49
5 20 50
6 20 50
5 3 8
9 13 22
```

### 输出

```
1 49 
20 40 30 50 10
26 32 20 38 44 50 
8 23 18 13 3 
1 10 13 4 19 22 25 16 7
```



---

---
title: "Repainting Street"
layout: "post"
diff: 普及-
pid: CF1415B
tag: []
---

# Repainting Street

## 题目描述

- 有一条街道，$n$ 栋房子排成一行，编号从 $1$ 到 $n$。每个房子的颜色为 $c_i$ ，工人每次可粉刷连续的 $k$ 个房子，求出将整条街刷成同一个颜色的最短的次数。

------------

## 输入格式

- 第一行输入整数 $t$ 为街道的条数，并且保证 $t$（$1 \leqslant t \leqslant {10}^4$）
- 第二行输入两个整数 $n$ 和 $k$（$1 \leqslant k \leqslant n \leqslant {10}^5$）
- 第三行输入房屋初始颜色 $c_i$（$1 \leqslant c_i \leqslant 100$）

------------

## 输出格式

- 输出 $t$ 行，每行为每个街道粉刷需要的最少天数

Translated by [Seth](https://www.luogu.com.cn/user/358800).

## 样例 #1

### 输入

```
3
10 2
1 1 2 2 1 1 2 2 2 1
7 1
1 2 3 4 5 6 7
10 3
1 3 3 3 3 1 2 1 3 3
```

### 输出

```
3
6
2
```



---

---
title: "Two Arrays"
layout: "post"
diff: 普及-
pid: CF1417B
tag: []
---

# Two Arrays

## 题目描述

RedDreamer has an array $ a $ consisting of $ n $ non-negative integers, and an unlucky integer $ T $ .

Let's denote the misfortune of array $ b $ having length $ m $ as $ f(b) $ — the number of pairs of integers $ (i, j) $ such that $ 1 \le i < j \le m $ and $ b_i + b_j = T $ . RedDreamer has to paint each element of $ a $ into one of two colors, white and black (for each element, the color is chosen independently), and then create two arrays $ c $ and $ d $ so that all white elements belong to $ c $ , and all black elements belong to $ d $ (it is possible that one of these two arrays becomes empty). RedDreamer wants to paint the elements in such a way that $ f(c) + f(d) $ is minimum possible.

For example:

- if $ n = 6 $ , $ T = 7 $ and $ a = [1, 2, 3, 4, 5, 6] $ , it is possible to paint the $ 1 $ -st, the $ 4 $ -th and the $ 5 $ -th elements white, and all other elements black. So $ c = [1, 4, 5] $ , $ d = [2, 3, 6] $ , and $ f(c) + f(d) = 0 + 0 = 0 $ ;
- if $ n = 3 $ , $ T = 6 $ and $ a = [3, 3, 3] $ , it is possible to paint the $ 1 $ -st element white, and all other elements black. So $ c = [3] $ , $ d = [3, 3] $ , and $ f(c) + f(d) = 0 + 1 = 1 $ .

Help RedDreamer to paint the array optimally!

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of each test case contains two integers $ n $ and $ T $ ( $ 1 \le n \le 10^5 $ , $ 0 \le T \le 10^9 $ ) — the number of elements in the array and the unlucky integer, respectively.

The second line contains $ n $ integers $ a_1 $ , $ a_2 $ , ..., $ a_n $ ( $ 0 \le a_i \le 10^9 $ ) — the elements of the array.

The sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case print $ n $ integers: $ p_1 $ , $ p_2 $ , ..., $ p_n $ (each $ p_i $ is either $ 0 $ or $ 1 $ ) denoting the colors. If $ p_i $ is $ 0 $ , then $ a_i $ is white and belongs to the array $ c $ , otherwise it is black and belongs to the array $ d $ .

If there are multiple answers that minimize the value of $ f(c) + f(d) $ , print any of them.

## 样例 #1

### 输入

```
2
6 7
1 2 3 4 5 6
3 6
3 3 3
```

### 输出

```
1 0 0 1 1 0 
1 0 0
```



---

---
title: "Digit Game"
layout: "post"
diff: 普及-
pid: CF1419A
tag: []
---

# Digit Game

## 题目描述

Everyone knows that agents in Valorant decide, who will play as attackers, and who will play as defenders. To do that Raze and Breach decided to play $ t $ matches of a digit game...

In each of $ t $ matches of the digit game, a positive integer is generated. It consists of $ n $ digits. The digits of this integer are numerated from $ 1 $ to $ n $ from the highest-order digit to the lowest-order digit. After this integer is announced, the match starts.

Agents play in turns. Raze starts. In one turn an agent can choose any unmarked digit and mark it. Raze can choose digits on odd positions, but can not choose digits on even positions. Breach can choose digits on even positions, but can not choose digits on odd positions. The match ends, when there is only one unmarked digit left. If the single last digit is odd, then Raze wins, else Breach wins.

It can be proved, that before the end of the match (for every initial integer with $ n $ digits) each agent has an ability to make a turn, i.e. there is at least one unmarked digit, that stands on a position of required parity.

For each of $ t $ matches find out, which agent wins, if both of them want to win and play optimally.

## 输入格式

First line of input contains an integer $ t $ $ (1 \le t \le 100) $ — the number of matches.

The first line of each match description contains an integer $ n $ $ (1 \le n \le 10^3) $ — the number of digits of the generated number.

The second line of each match description contains an $ n $ -digit positive integer without leading zeros.

## 输出格式

For each match print $ 1 $ , if Raze wins, and $ 2 $ , if Breach wins.

## 说明/提示

In the first match no one can make a turn, the only digit left is $ 2 $ , it's even, so Breach wins.

In the second match the only digit left is $ 3 $ , it's odd, so Raze wins.

In the third match Raze can mark the last digit, after that Breach can only mark $ 0 $ . $ 1 $ will be the last digit left, it's odd, so Raze wins.

In the fourth match no matter how Raze plays, Breach can mark $ 9 $ , and in the end there will be digit $ 0 $ . It's even, so Breach wins.

## 样例 #1

### 输入

```
4
1
2
1
3
3
102
4
2069
```

### 输出

```
2
1
1
2
```



---

---
title: "Stairs"
layout: "post"
diff: 普及-
pid: CF1419B
tag: []
---

# Stairs

## 题目描述

Jett is tired after destroying the town and she wants to have a rest. She likes high places, that's why for having a rest she wants to get high and she decided to craft staircases.

Staircase is a squared figure that consists of square cells. Each staircase consists of an arbitrary number of stairs. If a staircase has $ n $ stairs, then it is made of $ n $ columns, the first column is $ 1 $ cell high, the second column is $ 2 $ cells high, $ \ldots $ , the $ n $ -th column if $ n $ cells high. The lowest cells of all stairs must be in the same row.

A staircase with $ n $ stairs is called nice, if it may be covered by $ n $ disjoint squares made of cells. All squares should fully consist of cells of a staircase.

 This is how a nice covered staircase with $ 7 $ stairs looks like: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1419B/20e8f39717a3a82bb8f73bd6c4f499217c03a037.png)Find out the maximal number of different nice staircases, that can be built, using no more than $ x $ cells, in total. No cell can be used more than once.

## 输入格式

The first line contains a single integer $ t $ $ (1 \le t \le 1000) $ — the number of test cases.

The description of each test case contains a single integer $ x $ $ (1 \le x \le 10^{18}) $ — the number of cells for building staircases.

## 输出格式

For each test case output a single integer — the number of different nice staircases, that can be built, using not more than $ x $ cells, in total.

## 说明/提示

In the first test case, it is possible to build only one staircase, that consists of $ 1 $ stair. It's nice. That's why the answer is $ 1 $ .

In the second test case, it is possible to build two different nice staircases: one consists of $ 1 $ stair, and another consists of $ 3 $ stairs. This will cost $ 7 $ cells. In this case, there is one cell left, but it is not possible to use it for building any nice staircases, that have not been built yet. That's why the answer is $ 2 $ .

In the third test case, it is possible to build only one of two nice staircases: with $ 1 $ stair or with $ 3 $ stairs. In the first case, there will be $ 5 $ cells left, that may be used only to build a staircase with $ 2 $ stairs. This staircase is not nice, and Jett only builds nice staircases. That's why in this case the answer is $ 1 $ . If Jett builds a staircase with $ 3 $ stairs, then there are no more cells left, so the answer is $ 1 $ again.

## 样例 #1

### 输入

```
4
1
8
6
1000000000000000000
```

### 输出

```
1
2
1
30
```



---

---
title: "Sage's Birthday (easy version)"
layout: "post"
diff: 普及-
pid: CF1419D1
tag: []
---

# Sage's Birthday (easy version)

## 题目描述

This is the easy version of the problem. The difference between the versions is that in the easy version all prices $ a_i $ are different. You can make hacks if and only if you solved both versions of the problem.

Today is Sage's birthday, and she will go shopping to buy ice spheres. All $ n $ ice spheres are placed in a row and they are numbered from $ 1 $ to $ n $ from left to right. Each ice sphere has a positive integer price. In this version all prices are different.

An ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.

You can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.

## 输入格式

The first line contains a single integer $ n $ $ (1 \le n \le 10^5) $ — the number of ice spheres in the shop.

The second line contains $ n $ different integers $ a_1, a_2, \dots, a_n $ $ (1 \le a_i \le 10^9) $ — the prices of ice spheres.

## 输出格式

In the first line print the maximum number of ice spheres that Sage can buy.

In the second line print the prices of ice spheres in the optimal order. If there are several correct answers, you can print any of them.

## 说明/提示

In the example it's not possible to place ice spheres in any order so that Sage would buy $ 3 $ of them. If the ice spheres are placed like this $ (3, 1, 4, 2, 5) $ , then Sage will buy two spheres: one for $ 1 $ and one for $ 2 $ , because they are cheap.

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
2
3 1 4 2 5
```



---

---
title: "Amusing Joke"
layout: "post"
diff: 普及-
pid: CF141A
tag: []
---

# Amusing Joke

## 题目描述

So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two "New Year and Christmas Men" meet, thear assistants cut out of cardboard the letters from the guest's name and the host's name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door.

The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters.

Help the "New Year and Christmas Men" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.

## 输入格式

The input file consists of three lines: the first line contains the guest's name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed $ 100 $ .

## 输出格式

Print "YES" without the quotes, if the letters in the pile could be permuted to make the names of the "New Year and Christmas Men". Otherwise, print "NO" without the quotes.

## 说明/提示

In the first sample the letters written in the last line can be used to write the names and there won't be any extra letters left.

In the second sample letter "P" is missing from the pile and there's an extra letter "L".

In the third sample there's an extra letter "L".

## 样例 #1

### 输入

```
SANTACLAUS
DEDMOROZ
SANTAMOROZDEDCLAUS

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
PAPAINOEL
JOULUPUKKI
JOULNAPAOILELUPUKKI

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
BABBONATALE
FATHERCHRISTMAS
BABCHRISTMASBONATALLEFATHER

```

### 输出

```
NO

```



---

---
title: "Hopscotch"
layout: "post"
diff: 普及-
pid: CF141B
tag: []
---

# Hopscotch

## 题目描述

So nearly half of the winter is over and Maria is dreaming about summer. She's fed up with skates and sleds, she was dreaming about Hopscotch all night long. It's a very popular children's game. The game field, the court, looks as is shown in the figure (all blocks are square and are numbered from bottom to top, blocks in the same row are numbered from left to right). Let us describe the hopscotch with numbers that denote the number of squares in the row, staring from the lowest one: 1-1-2-1-2-1-2-(1-2)..., where then the period is repeated (1-2).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF141B/3cab0cfd180f2a7ceceec93813314c6b7ddd8ea0.png)The coordinate system is defined as shown in the figure. Side of all the squares are equal and have length $ a $ .

Maria is a very smart and clever girl, and she is concerned with quite serious issues: if she throws a stone into a point with coordinates $ (x,y) $ , then will she hit some square? If the answer is positive, you are also required to determine the number of the square.

It is believed that the stone has fallen into the square if it is located strictly inside it. In other words a stone that has fallen on the square border is not considered a to hit a square.

## 输入格式

The only input line contains three integers: $ a $ , $ x $ , $ y $ , where $ a $ ( $ 1<=a<=100 $ ) is the side of the square, $ x $ and $ y $ ( $ -10^{6}<=x<=10^{6},0<=y<=10^{6} $ ) are coordinates of the stone.

## 输出格式

Print the number of the square, inside which the stone fell. If the stone is on a border of some stone or outside the court, print "-1" without the quotes.

## 样例 #1

### 输入

```
1 0 0

```

### 输出

```
-1

```

## 样例 #2

### 输入

```
3 1 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
3 0 10

```

### 输出

```
5

```

## 样例 #4

### 输入

```
3 0 7

```

### 输出

```
-1

```

## 样例 #5

### 输入

```
3 4 0

```

### 输出

```
-1

```



---

---
title: "Cubes Sorting"
layout: "post"
diff: 普及-
pid: CF1420A
tag: []
---

# Cubes Sorting

## 题目描述

For god's sake, you're boxes with legs! It is literally your only purpose! Walking onto buttons! How can you not do the one thing you were designed for?Oh, that's funny, is it? Oh it's funny? Because we've been at this for twelve hours and you haven't solved it either, so I don't know why you're laughing. You've got one hour! Solve it!





Wheatley decided to try to make a test chamber. He made a nice test chamber, but there was only one detail absent — cubes.

For completing the chamber Wheatley needs $ n $ cubes. $ i $ -th cube has a volume $ a_i $ .

Wheatley has to place cubes in such a way that they would be sorted in a non-decreasing order by their volume. Formally, for each $ i>1 $ , $ a_{i-1} \le a_i $ must hold.

To achieve his goal, Wheatley can exchange two neighbouring cubes. It means that for any $ i>1 $ you can exchange cubes on positions $ i-1 $ and $ i $ .

But there is a problem: Wheatley is very impatient. If Wheatley needs more than $ \frac{n \cdot (n-1)}{2}-1 $ exchange operations, he won't do this boring work.

Wheatly wants to know: can cubes be sorted under this conditions?

## 输入格式

Each test contains multiple test cases.

The first line contains one positive integer $ t $ ( $ 1 \le t \le 1000 $ ), denoting the number of test cases. Description of the test cases follows.

The first line of each test case contains one positive integer $ n $ ( $ 2 \le n \le 5 \cdot 10^4 $ ) — number of cubes.

The second line contains $ n $ positive integers $ a_i $ ( $ 1 \le a_i \le 10^9 $ ) — volumes of cubes.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, print a word in a single line: "YES" (without quotation marks) if the cubes can be sorted and "NO" (without quotation marks) otherwise.

## 说明/提示

In the first test case it is possible to sort all the cubes in $ 7 $ exchanges.

In the second test case the cubes are already sorted.

In the third test case we can make $ 0 $ exchanges, but the cubes are not sorted yet, so the answer is "NO".

## 样例 #1

### 输入

```
3
5
5 3 2 1 4
6
2 2 2 2 2 2
2
2 1
```

### 输出

```
YES
YES
NO
```



---

---
title: "Putting Bricks in the Wall"
layout: "post"
diff: 普及-
pid: CF1421B
tag: []
---

# Putting Bricks in the Wall

## 题目描述

Pink Floyd are pulling a prank on Roger Waters. They know he doesn't like [walls](https://www.youtube.com/watch?v=YR5ApYxkU-U), he wants to be able to walk freely, so they are blocking him from exiting his room which can be seen as a grid.

Roger Waters has a square grid of size $ n\times n $ and he wants to traverse his grid from the upper left ( $ 1,1 $ ) corner to the lower right corner ( $ n,n $ ). Waters can move from a square to any other square adjacent by a side, as long as he is still in the grid. Also except for the cells ( $ 1,1 $ ) and ( $ n,n $ ) every cell has a value $ 0 $ or $ 1 $ in it.

Before starting his traversal he will pick either a $ 0 $ or a $ 1 $ and will be able to only go to cells values in which are equal to the digit he chose. The starting and finishing cells ( $ 1,1 $ ) and ( $ n,n $ ) are exempt from this rule, he may go through them regardless of picked digit. Because of this the cell ( $ 1,1 $ ) takes value the letter 'S' and the cell ( $ n,n $ ) takes value the letter 'F'.

For example, in the first example test case, he can go from ( $ 1, 1 $ ) to ( $ n, n $ ) by using the zeroes on this path: ( $ 1, 1 $ ), ( $ 2, 1 $ ), ( $ 2, 2 $ ), ( $ 2, 3 $ ), ( $ 3, 3 $ ), ( $ 3, 4 $ ), ( $ 4, 4 $ )

The rest of the band (Pink Floyd) wants Waters to not be able to do his traversal, so while he is not looking they will invert at most two cells in the grid (from $ 0 $ to $ 1 $ or vice versa). They are afraid they will not be quick enough and asked for your help in choosing the cells.  Note that you cannot invert cells $ (1, 1) $ and $ (n, n) $ .

We can show that there always exists a solution for the given constraints.

Also note that Waters will pick his digit of the traversal after the band has changed his grid, so he must not be able to reach ( $ n,n $ ) no matter what digit he picks.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 50 $ ). Description of the test cases follows.

The first line of each test case contains one integers $ n $ ( $ 3 \le n \le 200 $ ).

The following $ n $ lines of each test case contain the binary grid, square ( $ 1, 1 $ ) being colored in 'S' and square ( $ n, n $ ) being colored in 'F'.

The sum of values of $ n $ doesn't exceed $ 200 $ .

## 输出格式

For each test case output on the first line an integer $ c $ ( $ 0 \le c \le 2 $ ) — the number of inverted cells.

In $ i $ -th of the following $ c $ lines, print the coordinates of the $ i $ -th cell you inverted. You may not invert the same cell twice.  Note that you cannot invert cells $ (1, 1) $ and $ (n, n) $ .

## 说明/提示

For the first test case, after inverting the cell, we get the following grid:

```
<pre class="verbatim"><br></br>S010<br></br>0001<br></br>1001<br></br>111F<br></br>
```

## 样例 #1

### 输入

```
3
4
S010
0001
1000
111F
3
S10
101
01F
5
S0101
00000
01111
11111
0001F
```

### 输出

```
1
3 4
2
1 2
2 1
0
```



---

---
title: "Increase and Copy"
layout: "post"
diff: 普及-
pid: CF1426C
tag: []
---

# Increase and Copy

## 题目描述

Initially, you have the array $ a $ consisting of one element $ 1 $ ( $ a = [1] $ ).

In one move, you can do one of the following things:

- Increase some (single) element of $ a $ by $ 1 $ (choose some $ i $ from $ 1 $ to the current length of $ a $ and increase $ a_i $ by one);
- Append the copy of some (single) element of $ a $ to the end of the array (choose some $ i $ from $ 1 $ to the current length of $ a $ and append $ a_i $ to the end of the array).

For example, consider the sequence of five moves:

1. You take the first element $ a_1 $ , append its copy to the end of the array and get $ a = [1, 1] $ .
2. You take the first element $ a_1 $ , increase it by $ 1 $ and get $ a = [2, 1] $ .
3. You take the second element $ a_2 $ , append its copy to the end of the array and get $ a = [2, 1, 1] $ .
4. You take the first element $ a_1 $ , append its copy to the end of the array and get $ a = [2, 1, 1, 2] $ .
5. You take the fourth element $ a_4 $ , increase it by $ 1 $ and get $ a = [2, 1, 1, 3] $ .

Your task is to find the minimum number of moves required to obtain the array with the sum at least $ n $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Then $ t $ test cases follow.

The only line of the test case contains one integer $ n $ ( $ 1 \le n \le 10^9 $ ) — the lower bound on the sum of the array.

## 输出格式

For each test case, print the answer: the minimum number of moves required to obtain the array with the sum at least $ n $ .

## 样例 #1

### 输入

```
5
1
5
42
1337
1000000000
```

### 输出

```
0
3
11
72
63244
```



---

---
title: "Belted Rooms"
layout: "post"
diff: 普及-
pid: CF1428B
tag: []
---

# Belted Rooms

## 题目描述

In the snake exhibition, there are $ n $ rooms (numbered $ 0 $ to $ n - 1 $ ) arranged in a circle, with a snake in each room. The rooms are connected by $ n $ conveyor belts, and the $ i $ -th conveyor belt connects the rooms $ i $ and $ (i+1) \bmod n $ . In the other words, rooms $ 0 $ and $ 1 $ , $ 1 $ and $ 2 $ , $ \ldots $ , $ n-2 $ and $ n-1 $ , $ n-1 $ and $ 0 $ are connected with conveyor belts.

The $ i $ -th conveyor belt is in one of three states:

- If it is clockwise, snakes can only go from room $ i $ to $ (i+1) \bmod n $ .
- If it is anticlockwise, snakes can only go from room $ (i+1) \bmod n $ to $ i $ .
- If it is off, snakes can travel in either direction.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1428B/76fac914463a158de3ff2f71ea695b0a2d793a84.png)Above is an example with $ 4 $ rooms, where belts $ 0 $ and $ 3 $ are off, $ 1 $ is clockwise, and $ 2 $ is anticlockwise.

Each snake wants to leave its room and come back to it later. A room is returnable if the snake there can leave the room, and later come back to it using the conveyor belts. How many such returnable rooms are there?

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ): the number of test cases. The description of the test cases follows.

 The first line of each test case description contains a single integer $ n $ ( $ 2 \le n \le 300\,000 $ ): the number of rooms.

 The next line of each test case description contains a string $ s $ of length $ n $ , consisting of only '&lt;', '&gt;' and '-'.

- If $ s_{i} =  $ '&gt;', the $ i $ -th conveyor belt goes clockwise.
- If $ s_{i} =  $ '&lt;', the $ i $ -th conveyor belt goes anticlockwise.
- If $ s_{i} =  $ '-', the $ i $ -th conveyor belt is off.

It is guaranteed that the sum of $ n $ among all test cases does not exceed $ 300\,000 $ .

## 输出格式

For each test case, output the number of returnable rooms.

## 说明/提示

In the first test case, all rooms are returnable except room $ 2 $ . The snake in the room $ 2 $ is trapped and cannot exit. This test case corresponds to the picture from the problem statement.

 In the second test case, all rooms are returnable by traveling on the series of clockwise belts.

## 样例 #1

### 输入

```
4
4
-><-
5
>>>>>
3
<--
2
<>
```

### 输出

```
3
5
3
0
```



---

---
title: "Barrels"
layout: "post"
diff: 普及-
pid: CF1430B
tag: []
---

# Barrels

## 题目描述

You have $ n $ barrels lined up in a row, numbered from left to right from one. Initially, the $ i $ -th barrel contains $ a_i $ liters of water.

You can pour water from one barrel to another. In one act of pouring, you can choose two different barrels $ x $ and $ y $ (the $ x $ -th barrel shouldn't be empty) and pour any possible amount of water from barrel $ x $ to barrel $ y $ (possibly, all water). You may assume that barrels have infinite capacity, so you can pour any amount of water in each of them.

Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $ k $ times.

Some examples:

- if you have four barrels, each containing $ 5 $ liters of water, and $ k = 1 $ , you may pour $ 5 $ liters from the second barrel into the fourth, so the amounts of water in the barrels are $ [5, 0, 5, 10] $ , and the difference between the maximum and the minimum is $ 10 $ ;
- if all barrels are empty, you can't make any operation, so the difference between the maximum and the minimum amount is still $ 0 $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k < n \le 2 \cdot 10^5 $ ) — the number of barrels and the number of pourings you can make.

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 0 \le a_i \le 10^{9} $ ), where $ a_i $ is the initial amount of water the $ i $ -th barrel has.

It's guaranteed that the total sum of $ n $ over test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $ k $ times.

## 样例 #1

### 输入

```
2
4 1
5 5 5 5
3 2
0 0 0
```

### 输出

```
10
0
```



---

---
title: "Yet Another Bookshelf"
layout: "post"
diff: 普及-
pid: CF1433B
tag: []
---

# Yet Another Bookshelf

## 题目描述

There is a bookshelf which can fit $ n $ books. The $ i $ -th position of bookshelf is $ a_i = 1 $ if there is a book on this position and $ a_i = 0 $ otherwise. It is guaranteed that there is at least one book on the bookshelf.

In one move, you can choose some contiguous segment $ [l; r] $ consisting of books (i.e. for each $ i $ from $ l $ to $ r $ the condition $ a_i = 1 $ holds) and:

- Shift it to the right by $ 1 $ : move the book at index $ i $ to $ i + 1 $ for all $ l \le i \le r $ . This move can be done only if $ r+1 \le n $ and there is no book at the position $ r+1 $ .
- Shift it to the left by $ 1 $ : move the book at index $ i $ to $ i-1 $ for all $ l \le i \le r $ . This move can be done only if $ l-1 \ge 1 $ and there is no book at the position $ l-1 $ .

Your task is to find the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment (i.e. the segment without any gaps).

For example, for $ a = [0, 0, 1, 0, 1] $ there is a gap between books ( $ a_4 = 0 $ when $ a_3 = 1 $ and $ a_5 = 1 $ ), for $ a = [1, 1, 0] $ there are no gaps between books and for $ a = [0, 0,0] $ there are also no gaps between books.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 200 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 50 $ ) — the number of places on a bookshelf. The second line of the test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 1 $ ), where $ a_i $ is $ 1 $ if there is a book at this position and $ 0 $ otherwise. It is guaranteed that there is at least one book on the bookshelf.

## 输出格式

For each test case, print one integer: the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment (i.e. the segment without gaps).

## 说明/提示

In the first test case of the example, you can shift the segment $ [3; 3] $ to the right and the segment $ [4; 5] $ to the right. After all moves, the books form the contiguous segment $ [5; 7] $ . So the answer is $ 2 $ .

In the second test case of the example, you have nothing to do, all the books on the bookshelf form the contiguous segment already.

In the third test case of the example, you can shift the segment $ [5; 5] $ to the left and then the segment $ [4; 4] $ to the left again. After all moves, the books form the contiguous segment $ [1; 3] $ . So the answer is $ 2 $ .

In the fourth test case of the example, you can shift the segment $ [1; 1] $ to the right, the segment $ [2; 2] $ to the right, the segment $ [6; 6] $ to the left and then the segment $ [5; 5] $ to the left. After all moves, the books form the contiguous segment $ [3; 4] $ . So the answer is $ 4 $ .

In the fifth test case of the example, you can shift the segment $ [1; 2] $ to the right. After all moves, the books form the contiguous segment $ [2; 5] $ . So the answer is $ 1 $ .

## 样例 #1

### 输入

```
5
7
0 0 1 0 1 0 1
3
1 0 0
5
1 1 0 0 1
6
1 0 0 0 0 1
5
1 1 0 1 1
```

### 输出

```
2
0
2
4
1
```



---

---
title: "Dominant Piranha"
layout: "post"
diff: 普及-
pid: CF1433C
tag: []
---

# Dominant Piranha

## 题目描述

There are $ n $ piranhas with sizes $ a_1, a_2, \ldots, a_n $ in the aquarium. Piranhas are numbered from left to right in order they live in the aquarium.

Scientists of the Berland State University want to find if there is dominant piranha in the aquarium. The piranha is called dominant if it can eat all the other piranhas in the aquarium (except itself, of course). Other piranhas will do nothing while the dominant piranha will eat them.

Because the aquarium is pretty narrow and long, the piranha can eat only one of the adjacent piranhas during one move. Piranha can do as many moves as it needs (or as it can). More precisely:

- The piranha $ i $ can eat the piranha $ i-1 $ if the piranha $ i-1 $ exists and $ a_{i - 1} < a_i $ .
- The piranha $ i $ can eat the piranha $ i+1 $ if the piranha $ i+1 $ exists and $ a_{i + 1} < a_i $ .

When the piranha $ i $ eats some piranha, its size increases by one ( $ a_i $ becomes $ a_i + 1 $ ).

Your task is to find any dominant piranha in the aquarium or determine if there are no such piranhas.

Note that you have to find any (exactly one) dominant piranha, you don't have to find all of them.

For example, if $ a = [5, 3, 4, 4, 5] $ , then the third piranha can be dominant. Consider the sequence of its moves:

- The piranha eats the second piranha and $ a $ becomes $ [5, \underline{5}, 4, 5] $ (the underlined piranha is our candidate).
- The piranha eats the third piranha and $ a $ becomes $ [5, \underline{6}, 5] $ .
- The piranha eats the first piranha and $ a $ becomes $ [\underline{7}, 5] $ .
- The piranha eats the second piranha and $ a $ becomes $ [\underline{8}] $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 2 \cdot 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 2 \le n \le 3 \cdot 10^5 $ ) — the number of piranhas in the aquarium. The second line of the test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ), where $ a_i $ is the size of the $ i $ -th piranha.

It is guaranteed that the sum of $ n $ does not exceed $ 3 \cdot 10^5 $ ( $ \sum n \le 3 \cdot 10^5 $ ).

## 输出格式

For each test case, print the answer: -1 if there are no dominant piranhas in the aquarium or index of any dominant piranha otherwise. If there are several answers, you can print any.

## 说明/提示

The first test case of the example is described in the problem statement.

In the second test case of the example, there are no dominant piranhas in the aquarium.

In the third test case of the example, the fourth piranha can firstly eat the piranha to the left and the aquarium becomes $ [4, 4, 5, 4] $ , then it can eat any other piranha in the aquarium.

## 样例 #1

### 输入

```
6
5
5 3 4 4 5
3
1 1 1
5
4 4 3 4 4
5
5 5 4 3 2
3
1 1 2
5
5 4 3 5 5
```

### 输出

```
3
-1
4
3
3
1
```



---

---
title: "Prime Square"
layout: "post"
diff: 普及-
pid: CF1436B
tag: []
---

# Prime Square

## 题目描述

Sasha likes investigating different math objects, for example, magic squares. But Sasha understands that magic squares have already been studied by hundreds of people, so he sees no sense of studying them further. Instead, he invented his own type of square — a prime square.

A square of size $ n \times n $ is called prime if the following three conditions are held simultaneously:

- all numbers on the square are non-negative integers not exceeding $ 10^5 $ ;
- there are no prime numbers in the square;
- sums of integers in each row and each column are prime numbers.

Sasha has an integer $ n $ . He asks you to find any prime square of size $ n \times n $ . Sasha is absolutely sure such squares exist, so just help him!

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10 $ ) — the number of test cases.

Each of the next $ t $ lines contains a single integer $ n $ ( $ 2 \le n \le 100 $ ) — the required size of a square.

## 输出格式

For each test case print $ n $ lines, each containing $ n $ integers — the prime square you built. If there are multiple answers, print any.

## 样例 #1

### 输入

```
2
4
2
```

### 输出

```
4 6 8 1
4 9 9 9
4 10 10 65
1 4 4 4
1 1
1 1
```



---

---
title: "Marketing Scheme"
layout: "post"
diff: 普及-
pid: CF1437A
tag: []
---

# Marketing Scheme

## 题目描述

You got a job as a marketer in a pet shop, and your current task is to boost sales of cat food. One of the strategies is to sell cans of food in packs with discounts.

Suppose you decided to sell packs with $ a $ cans in a pack with a discount and some customer wants to buy $ x $ cans of cat food. Then he follows a greedy strategy:

- he buys $ \left\lfloor \frac{x}{a} \right\rfloor $ packs with a discount;
- then he wants to buy the remaining $ (x \bmod a) $ cans one by one.

 $ \left\lfloor \frac{x}{a} \right\rfloor $ is $ x $ divided by $ a $ rounded down, $ x \bmod a $ is the remainer of $ x $ divided by $ a $ .

But customers are greedy in general, so if the customer wants to buy $ (x \bmod a) $ cans one by one and it happens that $ (x \bmod a) \ge \frac{a}{2} $ he decides to buy the whole pack of $ a $ cans (instead of buying $ (x \bmod a) $ cans). It makes you, as a marketer, happy since the customer bought more than he wanted initially.

You know that each of the customers that come to your shop can buy any number of cans from $ l $ to $ r $ inclusive. Can you choose such size of pack $ a $ that each customer buys more cans than they wanted initially?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The first and only line of each test case contains two integers $ l $ and $ r $ ( $ 1 \le l \le r \le 10^9 $ ) — the range of the number of cans customers can buy.

## 输出格式

For each test case, print YES if you can choose such size of pack $ a $ that each customer buys more cans than they wanted initially. Otherwise, print NO.

You can print each character in any case.

## 说明/提示

In the first test case, you can take, for example, $ a = 5 $ as the size of the pack. Then if a customer wants to buy $ 3 $ cans, he'll buy $ 5 $ instead ( $ 3 \bmod 5 = 3 $ , $ \frac{5}{2} = 2.5 $ ). The one who wants $ 4 $ cans will also buy $ 5 $ cans.

In the second test case, there is no way to choose $ a $ .

In the third test case, you can take, for example, $ a = 80 $ .

## 样例 #1

### 输入

```
3
3 4
1 2
120 150
```

### 输出

```
YES
NO
YES
```



---

---
title: "Help Vasilisa the Wise 2"
layout: "post"
diff: 普及-
pid: CF143A
tag: []
---

# Help Vasilisa the Wise 2

## 题目描述

Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.

The box's lock looks as follows: it contains $ 4 $ identical deepenings for gems as a $ 2×2 $ square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF143A/3afffa6690b0a7fee0cca96fe3fb7d95cf7329f2.png)The box is accompanied with $ 9 $ gems. Their shapes match the deepenings' shapes and each gem contains one number from $ 1 $ to $ 9 $ (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF143A/3d3ced733d775964ba52205e4c988cebde0d133f.png)Now Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.

## 输入格式

The input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers $ r_{1} $ and $ r_{2} $ that define the required sums of numbers in the rows of the square. The second line contains space-separated integers $ c_{1} $ and $ c_{2} $ that define the required sums of numbers in the columns of the square. The third line contains space-separated integers $ d_{1} $ and $ d_{2} $ that define the required sums of numbers on the main and on the side diagonals of the square ( $ 1<=r_{1},r_{2},c_{1},c_{2},d_{1},d_{2}<=20 $ ). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF143A/f08042200b16ea0b985a26619f2a38dbdf350df2.png)

## 输出格式

Print the scheme of decorating the box with stones: two lines containing two space-separated integers from $ 1 $ to $ 9 $ . The numbers should be pairwise different. If there is no solution for the given lock, then print the single number "-1" (without the quotes).

If there are several solutions, output any.

## 说明/提示

Pay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number "5". However, Vasilisa only has one gem with each number from $ 1 $ to $ 9 $ .

## 样例 #1

### 输入

```
3 7
4 6
5 5

```

### 输出

```
1 2
3 4

```

## 样例 #2

### 输入

```
11 10
13 8
5 16

```

### 输出

```
4 7
9 1

```

## 样例 #3

### 输入

```
1 2
3 4
5 6

```

### 输出

```
-1

```

## 样例 #4

### 输入

```
10 10
10 10
10 10

```

### 输出

```
-1

```



---

---
title: "Buy the String"
layout: "post"
diff: 普及-
pid: CF1440A
tag: []
---

# Buy the String

## 题目描述

You are given four integers $ n $ , $ c_0 $ , $ c_1 $ and $ h $ and a binary string $ s $ of length $ n $ .

A binary string is a string consisting of characters $ 0 $ and $ 1 $ .

You can change any character of the string $ s $ (the string should be still binary after the change). You should pay $ h $ coins for each change.

After some changes (possibly zero) you want to buy the string. To buy the string you should buy all its characters. To buy the character $ 0 $ you should pay $ c_0 $ coins, to buy the character $ 1 $ you should pay $ c_1 $ coins.

Find the minimum number of coins needed to buy the string.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10 $ ) — the number of test cases. Next $ 2t $ lines contain descriptions of test cases.

The first line of the description of each test case contains four integers $ n $ , $ c_{0} $ , $ c_{1} $ , $ h $ ( $ 1 \leq n, c_{0}, c_{1}, h \leq 1000 $ ).

The second line of the description of each test case contains the binary string $ s $ of length $ n $ .

## 输出格式

For each test case print a single integer — the minimum number of coins needed to buy the string.

## 说明/提示

In the first test case, you can buy all characters and pay $ 3 $ coins, because both characters $ 0 $ and $ 1 $ costs $ 1 $ coin.

In the second test case, you can firstly change $ 2 $ -nd and $ 4 $ -th symbols of the string from $ 1 $ to $ 0 $ and pay $ 2 $ coins for that. Your string will be $ 00000 $ . After that, you can buy the string and pay $ 5 \cdot 10 = 50 $ coins for that. The total number of coins paid will be $ 2 + 50 = 52 $ .

## 样例 #1

### 输入

```
6
3 1 1 1
100
5 10 100 1
01010
5 10 1 1
11111
5 1 10 1
11111
12 2 1 10
101110110101
2 100 1 10
00
```

### 输出

```
3
52
5
10
16
22
```



---

---
title: "Kids Seating"
layout: "post"
diff: 普及-
pid: CF1443A
tag: []
---

# Kids Seating

## 题目描述

Today the kindergarten has a new group of $ n $ kids who need to be seated at the dinner table. The chairs at the table are numbered from $ 1 $ to $ 4n $ . Two kids can't sit on the same chair. It is known that two kids who sit on chairs with numbers $ a $ and $ b $ ( $ a \neq b $ ) will indulge if:

1. $ gcd(a, b) = 1 $ or,
2. $ a $ divides $ b $ or $ b $ divides $ a $ .

 $ gcd(a, b) $ — the maximum number $ x $ such that $ a $ is divisible by $ x $ and $ b $ is divisible by $ x $ .

For example, if $ n=3 $ and the kids sit on chairs with numbers $ 2 $ , $ 3 $ , $ 4 $ , then they will indulge since $ 4 $ is divided by $ 2 $ and $ gcd(2, 3) = 1 $ . If kids sit on chairs with numbers $ 4 $ , $ 6 $ , $ 10 $ , then they will not indulge.

The teacher really doesn't want the mess at the table, so she wants to seat the kids so there are no $ 2 $ of the kid that can indulge. More formally, she wants no pair of chairs $ a $ and $ b $ that the kids occupy to fulfill the condition above.

Since the teacher is very busy with the entertainment of the kids, she asked you to solve this problem.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases. Then $ t $ test cases follow.

Each test case consists of one line containing an integer $ n $ ( $ 1 \leq n \leq 100 $ ) — the number of kids.

## 输出格式

Output $ t $ lines, which contain $ n $ distinct integers from $ 1 $ to $ 4n $ — the numbers of chairs that the kids should occupy in the corresponding test case. If there are multiple answers, print any of them. You can print $ n $ numbers in any order.

## 样例 #1

### 输入

```
3
2
3
4
```

### 输出

```
6 4
4 6 10
14 10 12 8
```



---

---
title: "Array Rearrangment"
layout: "post"
diff: 普及-
pid: CF1445A
tag: []
---

# Array Rearrangment

## 题目描述

You are given two arrays $ a $ and $ b $ , each consisting of $ n $ positive integers, and an integer $ x $ . Please determine if one can rearrange the elements of $ b $ so that $ a_i + b_i \leq x $ holds for each $ i $ ( $ 1 \le i \le n $ ).

## 输入格式

The first line of input contains one integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases. $ t $ blocks follow, each describing an individual test case.

The first line of each test case contains two integers $ n $ and $ x $ ( $ 1 \leq n \leq 50 $ ; $ 1 \leq x \leq 1000 $ ) — the length of arrays $ a $ and $ b $ , and the parameter $ x $ , described in the problem statement.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_1 \le a_2 \le \dots \le a_n \leq x $ ) — the elements of array $ a $ in non-descending order.

The third line of each test case contains $ n $ integers $ b_1, b_2, \ldots, b_n $ ( $ 1 \leq b_1 \le b_2 \le \dots \le b_n \leq x $ ) — the elements of array $ b $ in non-descending order.

Test cases are separated by a blank line.

## 输出格式

For each test case print Yes if one can rearrange the corresponding array $ b $ so that $ a_i + b_i \leq x $ holds for each $ i $ ( $ 1 \le i \le n $ ) or No otherwise.

Each character can be printed in any case.

## 说明/提示

In the first test case, one can rearrange $ b $ so it'll look like $ [1, 2, 1] $ . In this case, $ 1 + 1 \leq 4 $ ; $ 2 + 2 \leq 4 $ ; $ 3 + 1 \leq 4 $ .

In the second test case, one can set $ b $ to $ [5, 2] $ , then $ 1 + 5 \leq 6 $ ; $ 4 + 2 \leq 6 $ .

In the third test case, no matter how one shuffles array $ b $ , $ a_4 + b_4 = 4 + b_4 > 4 $ .

In the fourth test case, there is only one rearrangement of array $ b $ and it doesn't satisfy the condition since $ 5 + 5 > 5 $ .

## 样例 #1

### 输入

```
4
3 4
1 2 3
1 1 2

2 6
1 4
2 5

4 4
1 2 3 4
1 2 3 4

1 5
5
5
```

### 输出

```
Yes
Yes
No
No
```



---

---
title: "Elimination"
layout: "post"
diff: 普及-
pid: CF1445B
tag: []
---

# Elimination

## 题目描述

There is a famous olympiad, which has more than a hundred participants. The Olympiad consists of two stages: the elimination stage, and the final stage. At least a hundred participants will advance to the final stage. The elimination stage in turn consists of two contests.

A result of the elimination stage is the total score in two contests, but, unfortunately, the jury lost the final standings and has only standings for the first and for the second contest separately.

In each contest, the participants are ranked by their point score in non-increasing order. When two participants have a tie (earned the same score), they are ranked by their passport number (in accordance with local regulations, all passport numbers are distinct).

In the first contest, the participant on the 100-th place scored $ a $ points. Also, the jury checked all participants from the 1-st to the 100-th place (inclusive) in the first contest and found out that all of them have at least $ b $ points in the second contest.

Similarly, for the second contest, the participant on the 100-th place has $ c $ points. And the jury checked that all the participants from the 1-st to the 100-th place (inclusive) have at least $ d $ points in the first contest.

After two contests, all participants are ranked by their total score in two contests in non-increasing order. When participants have the same total score, tie-breaking with passport numbers is used. The cutoff score to qualify to the final stage is the total score of the participant on the 100-th place.

Given integers $ a $ , $ b $ , $ c $ , $ d $ , please help the jury determine the smallest possible value of the cutoff score.

## 输入格式

You need to process $ t $ test cases.

The first line contains an integer $ t $ ( $ 1 \leq t \leq 3025 $ ) — the number of test cases. Then descriptions of $ t $ test cases follow.

The first line of each test case contains four integers $ a $ , $ b $ , $ c $ , $ d $ ( $ 0 \le a,\,b,\,c,\,d \le 9 $ ; $ d \leq a $ ; $ b \leq c $ ).

One can show that for any test case satisfying the constraints above, there is at least one olympiad scenario possible.

## 输出格式

For each test case print a single integer — the smallest possible cutoff score in some olympiad scenario satisfying the given information.

## 说明/提示

For the first test case, consider the following olympiad scenario: there are $ 101 $ participants in the elimination stage, each having $ 1 $ point for the first contest and $ 2 $ points for the second contest. Hence the total score of the participant on the 100-th place is $ 3 $ .

For the second test case, consider the following olympiad scenario:

- there are $ 50 $ participants with points $ 5 $ and $ 9 $ for the first and second contest respectively;
- $ 50 $ participants with points $ 4 $ and $ 8 $ for the first and second contest respectively;
- and $ 50 $ participants with points $ 2 $ and $ 9 $ for the first and second contest respectively.

 Hence the total point score of the participant on the 100-th place is $ 12 $ .

## 样例 #1

### 输入

```
2
1 2 2 1
4 8 9 2
```

### 输出

```
3
12
```



---

---
title: "Numbers Box"
layout: "post"
diff: 普及-
pid: CF1447B
tag: []
---

# Numbers Box

## 题目描述

You are given a rectangular grid with $ n $ rows and $ m $ columns. The cell located on the $ i $ -th row from the top and the $ j $ -th column from the left has a value $ a_{ij} $ written in it.

You can perform the following operation any number of times (possibly zero):

- Choose any two adjacent cells and multiply the values in them by $ -1 $ . Two cells are called adjacent if they share a side.

Note that you can use a cell more than once in different operations.

You are interested in $ X $ , the sum of all the numbers in the grid.

What is the maximum $ X $ you can achieve with these operations?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.

The first line of each test case contains two integers $ n $ , $ m $ ( $ 2 \le n $ , $ m \le 10 $ ).

The following $ n $ lines contain $ m $ integers each, the $ j $ -th element in the $ i $ -th line is $ a_{ij} $ ( $ -100\leq a_{ij}\le 100 $ ).

## 输出格式

For each testcase, print one integer $ X $ , the maximum possible sum of all the values in the grid after applying the operation as many times as you want.

## 说明/提示

In the first test case, there will always be at least one $ -1 $ , so the answer is $ 2 $ .

In the second test case, we can use the operation six times to elements adjacent horizontally and get all numbers to be non-negative. So the answer is: $ 2\times 1 + 3\times2 + 3\times 3 + 2\times 4 + 1\times 5 = 30 $ .

## 样例 #1

### 输入

```
2
2 2
-1 1
1 1
3 4
0 -1 -2 -3
-1 -2 -3 -4
-2 -3 -4 -5
```

### 输出

```
2
30
```



---

---
title: "Meeting"
layout: "post"
diff: 普及-
pid: CF144B
tag: []
---

# Meeting

## 题目描述

The Super Duper Secret Meeting of the Super Duper Secret Military Squad takes place in a Super Duper Secret Place. The place is an infinite plane with introduced Cartesian coordinate system. The meeting table is represented as a rectangle whose sides are parallel to the coordinate axes and whose vertexes are located at the integer points of the plane. At each integer point which belongs to the table perimeter there is a chair in which a general sits.

Some points on the plane contain radiators for the generals not to freeze in winter. Each radiator is characterized by the number $ r_{i} $ — the radius of the area this radiator can heat. That is, if the distance between some general and the given radiator is less than or equal to $ r_{i} $ , than the general feels comfortable and warm. Here distance is defined as Euclidean distance, so the distance between points $ (x_{1},y_{1}) $ and $ (x_{2},y_{2}) $ is ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF144B/db1ba0d5909a3b47109b2e5f65fe13400ae1bd9a.png)

Each general who is located outside the radiators' heating area can get sick. Thus, you should bring him a warm blanket. Your task is to count the number of warm blankets you should bring to the Super Duper Secret Place.

The generals who are already comfortable do not need a blanket. Also the generals never overheat, ever if they are located in the heating area of several radiators. The radiators can be located at any integer points on the plane, even inside the rectangle (under the table) or on the perimeter (directly under some general). Even in this case their radius does not change.

## 输入格式

The first input line contains coordinates of two opposite table corners $ x_{a} $ , $ y_{a} $ , $ x_{b} $ , $ y_{b} $ ( $ x_{a}≠x_{b},y_{a}≠y_{b}) $ . The second line contains integer $ n $ — the number of radiators ( $ 1<=n<=10^{3} $ ). Then $ n $ lines contain the heaters' coordinates as " $ x_{i} $ $ y_{i} $ $ r_{i} $ ", the numbers are separated by spaces. All input data numbers are integers. The absolute value of all coordinates does not exceed $ 1000 $ , $ 1<=r_{i}<=1000 $ . Several radiators can be located at the same point.

## 输出格式

Print the only number — the number of blankets you should bring.

## 说明/提示

In the first sample the generals are sitting at points: $ (2,2) $ , $ (2,3) $ , $ (2,4) $ , $ (2,5) $ , $ (3,2) $ , $ (3,5) $ , $ (4,2) $ , $ (4,3) $ , $ (4,4) $ , $ (4,5) $ . Among them, 4 generals are located outside the heating range. They are the generals at points: $ (2,5) $ , $ (3,5) $ , $ (4,4) $ , $ (4,5) $ .

In the second sample the generals are sitting at points: $ (5,2) $ , $ (5,3) $ , $ (6,2) $ , $ (6,3) $ . All of them are located inside the heating range.

## 样例 #1

### 输入

```
2 5 4 2
3
3 1 2
5 3 1
1 3 2

```

### 输出

```
4

```

## 样例 #2

### 输入

```
5 2 6 3
2
6 2 2
6 5 3

```

### 输出

```
0

```



---

---
title: "Balls of Steel"
layout: "post"
diff: 普及-
pid: CF1450B
tag: []
---

# Balls of Steel

## 题目描述

You have $ n $ distinct points $ (x_1, y_1),\ldots,(x_n,y_n) $ on the plane and a non-negative integer parameter $ k $ . Each point is a microscopic steel ball and $ k $ is the attract power of a ball when it's charged. The attract power is the same for all balls.

In one operation, you can select a ball $ i $ to charge it. Once charged, all balls with Manhattan distance at most $ k $ from ball $ i $ move to the position of ball $ i $ . Many balls may have the same coordinate after an operation.

More formally, for all balls $ j $ such that $ |x_i - x_j| + |y_i - y_j| \le k $ , we assign $ x_j:=x_i $ and $ y_j:=y_i $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1450B/bd476820b8f47c8050ef448d8375a731892e001a.png) An example of an operation. After charging the ball in the center, two other balls move to its position. On the right side, the red dot in the center is the common position of those balls. Your task is to find the minimum number of operations to move all balls to the same position, or report that this is impossible.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ , $ k $ ( $ 2 \le n \le 100 $ , $ 0 \le k \le 10^6 $ ) — the number of balls and the attract power of all balls, respectively.

The following $ n $ lines describe the balls' coordinates. The $ i $ -th of these lines contains two integers $ x_i $ , $ y_i $ ( $ 0 \le x_i, y_i \le 10^5 $ ) — the coordinates of the $ i $ -th ball.

It is guaranteed that all points are distinct.

## 输出格式

For each test case print a single integer — the minimum number of operations to move all balls to the same position, or $ -1 $ if it is impossible.

## 说明/提示

In the first test case, there are three balls at $ (0, 0) $ , $ (3, 3) $ , and $ (1, 1) $ and the attract power is $ 2 $ . It is possible to move two balls together with one operation, but not all three balls together with any number of operations.

In the second test case, there are three balls at $ (6, 7) $ , $ (8, 8) $ , and $ (6, 9) $ and the attract power is $ 3 $ . If we charge any ball, the other two will move to the same position, so we only require one operation.

In the third test case, there are four balls at $ (0, 0) $ , $ (0, 1) $ , $ (0, 2) $ , and $ (0, 3) $ , and the attract power is $ 1 $ . We can show that it is impossible to move all balls to the same position with a sequence of operations.

## 样例 #1

### 输入

```
3
3 2
0 0
3 3
1 1
3 3
6 7
8 8
6 9
4 1
0 0
0 1
0 2
0 3
```

### 输出

```
-1
1
-1
```



---

---
title: "Non-Substring Subsequence"
layout: "post"
diff: 普及-
pid: CF1451B
tag: []
---

# Non-Substring Subsequence

## 题目描述

Hr0d1y has $ q $ queries on a binary string $ s $ of length $ n $ . A binary string is a string containing only characters '0' and '1'.

A query is described by a pair of integers $ l_i $ , $ r_i $ $ (1 \leq l_i \lt r_i \leq n) $ .

For each query, he has to determine whether there exists a good subsequence in $ s $ that is equal to the substring $ s[l_i\ldots r_i] $ .

- A substring $ s[i\ldots j] $ of a string $ s $ is the string formed by characters $ s_i s_{i+1} \ldots s_j $ .
- String $ a $ is said to be a subsequence of string $ b $ if $ a $ can be obtained from $ b $ by deleting some characters without changing the order of the remaining characters.
- A subsequence is said to be good if it is not contiguous and has length $ \ge 2 $ . For example, if $ s $ is "1100110", then the subsequences $ s_1s_2s_4 $ ("1100110") and $ s_1s_5s_7 $ ("1100110") are good, while $ s_1s_2s_3 $ ("1100110") is not good.

Can you help Hr0d1y answer each query?

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1\leq t \leq 100 $ ) — the number of test cases. The description of each test case is as follows.

The first line contains two integers $ n $ ( $ 2 \leq n \leq 100 $ ) and $ q $ ( $ 1\leq q \leq 100 $ ) — the length of the string and the number of queries.

The second line contains the string $ s $ .

The $ i $ -th of the next $ q $ lines contains two integers $ l_i $ and $ r_i $ ( $ 1 \leq l_i \lt r_i \leq n $ ).

## 输出格式

For each test case, output $ q $ lines. The $ i $ -th line of the output of each test case should contain "YES" if there exists a good subsequence equal to the substring $ s[l_i...r_i] $ , and "NO" otherwise.

You may print each letter in any case (upper or lower).

## 说明/提示

In the first test case,

- $ s[2\ldots 4] =  $ "010". In this case $ s_1s_3s_5 $ ("001000") and $ s_2s_3s_6 $ ("001000") are good suitable subsequences, while $ s_2s_3s_4 $ ("001000") is not good.
- $ s[1\ldots 3] =  $ "001". No suitable good subsequence exists.
- $ s[3\ldots 5] =  $ "100". Here $ s_3s_5s_6 $ ("001000") is a suitable good subsequence.

## 样例 #1

### 输入

```
2
6 3
001000
2 4
1 3
3 5
4 2
1111
1 4
2 3
```

### 输出

```
YES
NO
YES
NO
YES
```



---

---
title: "Robot Program"
layout: "post"
diff: 普及-
pid: CF1452A
tag: []
---

# Robot Program

## 题目描述

There is an infinite 2-dimensional grid. The robot stands in cell $ (0, 0) $ and wants to reach cell $ (x, y) $ . Here is a list of possible commands the robot can execute:

- move north from cell $ (i, j) $ to $ (i, j + 1) $ ;
- move east from cell $ (i, j) $ to $ (i + 1, j) $ ;
- move south from cell $ (i, j) $ to $ (i, j - 1) $ ;
- move west from cell $ (i, j) $ to $ (i - 1, j) $ ;
- stay in cell $ (i, j) $ .

The robot wants to reach cell $ (x, y) $ in as few commands as possible. However, he can't execute the same command two or more times in a row.

What is the minimum number of commands required to reach $ (x, y) $ from $ (0, 0) $ ?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of testcases.

Each of the next $ t $ lines contains two integers $ x $ and $ y $ ( $ 0 \le x, y \le 10^4 $ ) — the destination coordinates of the robot.

## 输出格式

For each testcase print a single integer — the minimum number of commands required for the robot to reach $ (x, y) $ from $ (0, 0) $ if no command is allowed to be executed two or more times in a row.

## 说明/提示

The explanations for the example test:

We use characters N, E, S, W and 0 to denote going north, going east, going south, going west and staying in the current cell, respectively.

In the first test case, the robot can use the following sequence: NENENENENE.

In the second test case, the robot can use the following sequence: NENENEN.

In the third test case, the robot can use the following sequence: ESENENE0ENESE.

In the fourth test case, the robot doesn't need to go anywhere at all.

In the fifth test case, the robot can use the following sequence: E0E.

## 样例 #1

### 输入

```
5
5 5
3 4
7 1
0 0
2 0
```

### 输出

```
10
7
13
0
3
```



---

---
title: "Unique Bid Auction"
layout: "post"
diff: 普及-
pid: CF1454B
tag: []
---

# Unique Bid Auction

## 题目描述

There is a game called "Unique Bid Auction". You can read more about it here: <a>https://en.wikipedia.org/wiki/Unique\_bid\_auction</a> (though you don't have to do it to solve this problem).

Let's simplify this game a bit. Formally, there are $ n $ participants, the $ i $ -th participant chose the number $ a_i $ . The winner of the game is such a participant that the number he chose is unique (i. e. nobody else chose this number except him) and is minimal (i. e. among all unique values of $ a $ the minimum one is the winning one).

Your task is to find the index of the participant who won the game (or -1 if there is no winner). Indexing is $ 1 $ -based, i. e. the participants are numbered from $ 1 $ to $ n $ .

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 2 \cdot 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of participants. The second line of the test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le n $ ), where $ a_i $ is the $ i $ -th participant chosen number.

It is guaranteed that the sum of $ n $ does not exceed $ 2 \cdot 10^5 $ ( $ \sum n \le 2 \cdot 10^5 $ ).

## 输出格式

For each test case, print the answer — the index of the participant who won the game (or -1 if there is no winner). Note that the answer is always unique.

## 样例 #1

### 输入

```
6
2
1 1
3
2 1 3
4
2 2 2 3
1
1
5
2 3 2 4 2
6
1 1 5 5 4 4
```

### 输出

```
-1
2
4
1
2
-1
```



---

---
title: "Ping-pong"
layout: "post"
diff: 普及-
pid: CF1455C
tag: []
---

# Ping-pong

## 题目描述

Alice and Bob play ping-pong with simplified rules.

During the game, the player serving the ball commences a play. The server strikes the ball then the receiver makes a return by hitting the ball back. Thereafter, the server and receiver must alternately make a return until one of them doesn't make a return.

The one who doesn't make a return loses this play. The winner of the play commences the next play. Alice starts the first play.

Alice has $ x $ stamina and Bob has $ y $ . To hit the ball (while serving or returning) each player spends $ 1 $ stamina, so if they don't have any stamina, they can't return the ball (and lose the play) or can't serve the ball (in this case, the other player serves the ball instead). If both players run out of stamina, the game is over.

Sometimes, it's strategically optimal not to return the ball, lose the current play, but save the stamina. On the contrary, when the server commences a play, they have to hit the ball, if they have some stamina left.

Both Alice and Bob play optimally and want to, firstly, maximize their number of wins and, secondly, minimize the number of wins of their opponent.

Calculate the resulting number of Alice's and Bob's wins.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first and only line of each test case contains two integers $ x $ and $ y $ ( $ 1 \le x, y \le 10^6 $ ) — Alice's and Bob's initial stamina.

## 输出格式

For each test case, print two integers — the resulting number of Alice's and Bob's wins, if both of them play optimally.

## 说明/提示

In the first test case, Alice serves the ball and spends $ 1 $ stamina. Then Bob returns the ball and also spends $ 1 $ stamina. Alice can't return the ball since she has no stamina left and loses the play. Both of them ran out of stamina, so the game is over with $ 0 $ Alice's wins and $ 1 $ Bob's wins.

In the second test case, Alice serves the ball and spends $ 1 $ stamina. Bob decides not to return the ball — he loses the play but saves stamina. Alice, as the winner of the last play, serves the ball in the next play and spends $ 1 $ more stamina. This time, Bob returns the ball and spends $ 1 $ stamina. Alice doesn't have any stamina left, so she can't return the ball and loses the play. Both of them ran out of stamina, so the game is over with $ 1 $ Alice's and $ 1 $ Bob's win.

In the third test case, Alice serves the ball and spends $ 1 $ stamina. Bob returns the ball and spends $ 1 $ stamina. Alice ran out of stamina, so she can't return the ball and loses the play. Bob, as a winner, serves the ball in the next $ 6 $ plays. Each time Alice can't return the ball and loses each play. The game is over with $ 0 $ Alice's and $ 7 $ Bob's wins.

## 样例 #1

### 输入

```
3
1 1
2 1
1 7
```

### 输出

```
0 1
1 1
0 7
```



---

---
title: "Lucky Conversion"
layout: "post"
diff: 普及-
pid: CF145A
tag: []
---

# Lucky Conversion

## 题目描述

Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya has two strings $ a $ and $ b $ of the same length $ n $ . The strings consist only of lucky digits. Petya can perform operations of two types:

- replace any one digit from string $ a $ by its opposite (i.e., replace $ 4 $ by $ 7 $ and $ 7 $ by $ 4 $ );
- swap any pair of digits in string $ a $ .

Petya is interested in the minimum number of operations that are needed to make string $ a $ equal to string $ b $ . Help him with the task.

## 输入格式

The first and the second line contains strings $ a $ and $ b $ , correspondingly. Strings $ a $ and $ b $ have equal lengths and contain only lucky digits. The strings are not empty, their length does not exceed $ 10^{5} $ .

## 输出格式

Print on the single line the single number — the minimum number of operations needed to convert string $ a $ into string $ b $ .

## 说明/提示

In the first sample it is enough simply to swap the first and the second digit.

In the second sample we should replace the second digit with its opposite.

In the third number we should replace all three digits with their opposites.

## 样例 #1

### 输入

```
47
74

```

### 输出

```
1

```

## 样例 #2

### 输入

```
774
744

```

### 输出

```
1

```

## 样例 #3

### 输入

```
777
444

```

### 输出

```
3

```



---

---
title: "Find the Spruce"
layout: "post"
diff: 普及-
pid: CF1461B
tag: []
---

# Find the Spruce

## 题目描述

Holidays are coming up really soon. Rick realized that it's time to think about buying a traditional spruce tree. But Rick doesn't want real trees to get hurt so he decided to find some in an $ n \times m $ matrix consisting of "\*" and ".".

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1461B/0f830498ab169a471030eeb85fc12c395e76f5ca.png)To find every spruce first let's define what a spruce in the matrix is. A set of matrix cells is called a spruce of height $ k $ with origin at point $ (x, y) $ if:

- All cells in the set contain an "\*".
- For each $ 1 \le i \le k $ all cells with the row number $ x+i-1 $ and columns in range $ [y - i + 1, y + i - 1] $ must be a part of the set. All other cells cannot belong to the set.

Examples of correct and incorrect spruce trees:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1461B/2ce2df8e09c4fc74a3e149e5906821e41a5e552f.png)Now Rick wants to know how many spruces his $ n \times m $ matrix contains. Help Rick solve this problem.

## 输入格式

Each test contains one or more test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10 $ ).

The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \le n, m \le 500 $ ) — matrix size.

Next $ n $ lines of each test case contain $ m $ characters $ c_{i, j} $ — matrix contents. It is guaranteed that $ c_{i, j} $ is either a "." or an "\*".

It is guaranteed that the sum of $ n \cdot m $ over all test cases does not exceed $ 500^2 $ ( $ \sum n \cdot m \le 500^2 $ ).

## 输出格式

For each test case, print single integer — the total number of spruces in the matrix.

## 说明/提示

In the first test case the first spruce of height $ 2 $ has its origin at point $ (1, 2) $ , the second spruce of height $ 1 $ has its origin at point $ (1, 2) $ , the third spruce of height $ 1 $ has its origin at point $ (2, 1) $ , the fourth spruce of height $ 1 $ has its origin at point $ (2, 2) $ , the fifth spruce of height $ 1 $ has its origin at point $ (2, 3) $ .

In the second test case the first spruce of height $ 1 $ has its origin at point $ (1, 2) $ , the second spruce of height $ 1 $ has its origin at point $ (2, 1) $ , the third spruce of height $ 1 $ has its origin at point $ (2, 2) $ .

## 样例 #1

### 输入

```
4
2 3
.*.
***
2 3
.*.
**.
4 5
.***.
*****
*****
*.*.*
5 7
..*.*..
.*****.
*******
.*****.
..*.*..
```

### 输出

```
5
3
23
34
```



---

---
title: "Unique Number"
layout: "post"
diff: 普及-
pid: CF1462C
tag: []
---

# Unique Number

## 题目描述

You are given a positive number $ x $ . Find the smallest positive integer number that has the sum of digits equal to $ x $ and all digits are distinct (unique).

## 输入格式

The first line contains a single positive integer $ t $ ( $ 1 \le t \le 50 $ ) — the number of test cases in the test. Then $ t $ test cases follow.

Each test case consists of a single integer number $ x $ ( $ 1 \le x \le 50 $ ).

## 输出格式

Output $ t $ answers to the test cases:

- if a positive integer number with the sum of digits equal to $ x $ and all digits are different exists, print the smallest such number;
- otherwise print -1.

## 样例 #1

### 输入

```
4
1
5
15
50
```

### 输出

```
1
5
69
-1
```



---

---
title: "Dungeon"
layout: "post"
diff: 普及-
pid: CF1463A
tag: []
---

# Dungeon

## 题目描述

You are playing a new computer game in which you have to fight monsters. In a dungeon you are trying to clear, you met three monsters; the first of them has $ a $ health points, the second has $ b $ health points, and the third has $ c $ .

To kill the monsters, you can use a cannon that, when fired, deals $ 1 $ damage to the selected monster. Every $ 7 $ -th (i. e. shots with numbers $ 7 $ , $ 14 $ , $ 21 $ etc.) cannon shot is enhanced and deals $ 1 $ damage to all monsters, not just one of them. If some monster's current amount of health points is $ 0 $ , it can't be targeted by a regular shot and does not receive damage from an enhanced shot.

You want to pass the dungeon beautifully, i. e., kill all the monsters with the same enhanced shot (i. e. after some enhanced shot, the health points of each of the monsters should become equal to $ 0 $ for the first time). Each shot must hit a monster, i. e. each shot deals damage to at least one monster.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of a single line that contains three integers $ a $ , $ b $ and $ c $ ( $ 1 \le a, b, c \le 10^8 $ ) — the number of health points each monster has.

## 输出格式

For each test case, print YES if you can kill all the monsters with the same enhanced shot. Otherwise, print NO. You may print each letter in any case (for example, YES, Yes, yes, yEs will all be recognized as positive answer).

## 说明/提示

In the first test case, you can do as follows: $ 1 $ -th shot to the first monster, $ 2 $ -th shot to the second monster, $ 3 $ -th shot to the third monster, $ 4 $ -th shot to the first monster, $ 5 $ -th shot to the third monster, $ 6 $ -th shot to the third monster, and $ 7 $ -th enhanced shot will kill all the monsters.

In the second test case, you can't kill monsters with the same enhanced shot, because the total number of health points of monsters is $ 3 $ , and you will kill them in the first 3 shots.

## 样例 #1

### 输入

```
3
3 2 4
1 1 1
10 1 7
```

### 输出

```
YES
NO
NO
```



---

---
title: "Wizard of Orz"
layout: "post"
diff: 普及-
pid: CF1467A
tag: []
---

# Wizard of Orz

## 题目描述

There are $ n $ digital panels placed in a straight line. Each panel can show any digit from $ 0 $ to $ 9 $ . Initially, all panels show $ 0 $ .

Every second, the digit shown by each panel increases by $ 1 $ . In other words, at the end of every second, a panel that showed $ 9 $ would now show $ 0 $ , a panel that showed $ 0 $ would now show $ 1 $ , a panel that showed $ 1 $ would now show $ 2 $ , and so on.

When a panel is paused, the digit displayed on the panel does not change in the subsequent seconds.

You must pause exactly one of these panels, at any second you wish. Then, the panels adjacent to it get paused one second later, the panels adjacent to those get paused $ 2 $ seconds later, and so on. In other words, if you pause panel $ x $ , panel $ y $ (for all valid $ y $ ) would be paused exactly $ |x−y| $ seconds later.

For example, suppose there are $ 4 $ panels, and the $ 3 $ -rd panel is paused when the digit $ 9 $ is on it.

- The panel $ 1 $ pauses $ 2 $ seconds later, so it has the digit $ 1 $ ;
- the panel $ 2 $ pauses $ 1 $ second later, so it has the digit $ 0 $ ;
- the panel $ 4 $ pauses $ 1 $ second later, so it has the digit $ 0 $ .

The resulting $ 4 $ -digit number is $ 1090 $ . Note that this example is not optimal for $ n = 4 $ .

Once all panels have been paused, you write the digits displayed on them from left to right, to form an $ n $ digit number (it can consist of leading zeros). What is the largest possible number you can get? Initially, all panels show $ 0 $ .

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Each test case consists of a single line containing a single integer $ n $ ( $ 1 \le n \le 2\cdot10^5 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, print the largest number you can achieve, if you pause one panel optimally.

## 说明/提示

In the first test case, it is optimal to pause the first panel when the number $ 9 $ is displayed on it.

In the second test case, it is optimal to pause the second panel when the number $ 8 $ is displayed on it.

## 样例 #1

### 输入

```
2
1
2
```

### 输出

```
9
98
```



---

---
title: "Waste Sorting"
layout: "post"
diff: 普及-
pid: CF1468N
tag: []
---

# Waste Sorting

## 题目描述

有三个桶，五种垃圾，每个桶有固定的容量。

$1$垃圾放入$1$号桶中，$2$垃圾放入$2$号桶中，$3$垃圾放入$3$号桶中，$4$垃圾可以放入$1$、$3$号桶中，$5$垃圾可以放入$2$、$3$号桶中。

对于给定的桶容量$c$和垃圾量$a$，请问垃圾是否可以全部放入桶中？

## 输入格式

**本题有多组数据**

第一行包含一个整数$t（1\le t\le 3 * 10^4）$——测试用例的数量。

每个测试用例由两行组成。每个测试用例的第一行包含三个整数$c_1,c_2,c_3（0\le c_1、c_2、c_3\le 10^8）$——容器的容量。

每个测试用例的第二行包含五个整数$a_1、a_2、a_3、a_4、a_5（0\le a_i\le 10^8）$，其中$a_ i$是必须丢弃的第$i$类垃圾的数量。

## 输出格式

对于每个测试用例，如果可以将所有项目装入容器，则打印 $YES$，否则打印 $NO$。您可以在任何情况下打印每个字母（例如,$YES,Yes,yes,yEs$都将被视为肯定答案）。

## 样例 #1

### 输入

```
7
1 2 3
1 2 3 0 0
2 2 3
1 2 3 1 0
2 2 3
1 2 3 0 1
1 2 5
1 2 3 1 1
0 0 0
0 0 0 0 0
0 0 4
1 0 0 0 0
13 37 42
0 0 0 40 47
```

### 输出

```
YES
YES
NO
YES
YES
NO
YES
```



---

---
title: "Red and Blue"
layout: "post"
diff: 普及-
pid: CF1469B
tag: []
---

# Red and Blue

## 题目描述

Monocarp had a sequence $ a $ consisting of $ n + m $ integers $ a_1, a_2, \dots, a_{n + m} $ . He painted the elements into two colors, red and blue; $ n $ elements were painted red, all other $ m $ elements were painted blue.

After painting the elements, he has written two sequences $ r_1, r_2, \dots, r_n $ and $ b_1, b_2, \dots, b_m $ . The sequence $ r $ consisted of all red elements of $ a $ in the order they appeared in $ a $ ; similarly, the sequence $ b $ consisted of all blue elements of $ a $ in the order they appeared in $ a $ as well.

Unfortunately, the original sequence was lost, and Monocarp only has the sequences $ r $ and $ b $ . He wants to restore the original sequence. In case there are multiple ways to restore it, he wants to choose a way to restore that maximizes the value of

 $ $$$f(a) = \max(0, a_1, (a_1 + a_2), (a_1 + a_2 + a_3), \dots, (a_1 + a_2 + a_3 + \dots + a_{n + m})) $ $ </p><p>Help Monocarp to calculate the maximum possible value of  $ f(a)$$$.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Then the test cases follow. Each test case consists of four lines.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 100 $ ).

The second line contains $ n $ integers $ r_1, r_2, \dots, r_n $ ( $ -100 \le r_i \le 100 $ ).

The third line contains one integer $ m $ ( $ 1 \le m \le 100 $ ).

The fourth line contains $ m $ integers $ b_1, b_2, \dots, b_m $ ( $ -100 \le b_i \le 100 $ ).

## 输出格式

For each test case, print one integer — the maximum possible value of $ f(a) $ .

## 说明/提示

In the explanations for the sample test cases, red elements are marked as bold.

In the first test case, one of the possible sequences $ a $ is $ [\mathbf{6}, 2, \mathbf{-5}, 3, \mathbf{7}, \mathbf{-3}, -4] $ .

In the second test case, one of the possible sequences $ a $ is $ [10, \mathbf{1}, -3, \mathbf{1}, 2, 2] $ .

In the third test case, one of the possible sequences $ a $ is $ [\mathbf{-1}, -1, -2, -3, \mathbf{-2}, -4, -5, \mathbf{-3}, \mathbf{-4}, \mathbf{-5}] $ .

In the fourth test case, one of the possible sequences $ a $ is $ [0, \mathbf{0}] $ .

## 样例 #1

### 输入

```
4
4
6 -5 7 -3
3
2 3 -4
2
1 1
4
10 -3 2 2
5
-1 -2 -3 -4 -5
5
-1 -2 -3 -4 -5
1
0
1
0
```

### 输出

```
13
13
0
0
```



---

---
title: "Strange List"
layout: "post"
diff: 普及-
pid: CF1471B
tag: []
---

# Strange List

## 题目描述

You have given an array $ a $ of length $ n $ and an integer $ x $ to a brand new robot. What the robot does is the following: it iterates over the elements of the array, let the current element be $ q $ . If $ q $ is divisible by $ x $ , the robot adds $ x $ copies of the integer $ \frac{q}{x} $ to the end of the array, and moves on to the next element. Note that the newly added elements could be processed by the robot later. Otherwise, if $ q $ is not divisible by $ x $ , the robot shuts down.

Please determine the sum of all values of the array at the end of the process.

## 输入格式

The first input line contains a single integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ x $ ( $ 1 \leq n \leq 10^5 $ , $ 2 \leq x \leq 10^9 $ ) — the length of the array and the value which is used by the robot.

The next line contains integers $ a_1 $ , $ a_2 $ , ..., $ a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the initial values in the array.

It is guaranteed that the sum of values $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case output one integer — the sum of all elements at the end of the process.

## 说明/提示

In the first test case the array initially consists of a single element $ [12] $ , and $ x=2 $ . After the robot processes the first element, the array becomes $ [12, 6, 6] $ . Then the robot processes the second element, and the array becomes $ [12, 6, 6, 3, 3] $ . After the robot processes the next element, the array becomes $ [12, 6, 6, 3, 3, 3, 3] $ , and then the robot shuts down, since it encounters an element that is not divisible by $ x = 2 $ . The sum of the elements in the resulting array is equal to $ 36 $ .

In the second test case the array initially contains integers $ [4, 6, 8, 2] $ , and $ x=2 $ . The resulting array in this case looks like $  [4, 6, 8, 2, 2, 2, 3, 3, 4, 4, 1, 1, 1, 1, 1, 1] $ .

## 样例 #1

### 输入

```
2
1 2
12
4 2
4 6 8 2
```

### 输出

```
36
44
```



---

---
title: "Long Jumps"
layout: "post"
diff: 普及-
pid: CF1472C
tag: []
---

# Long Jumps

## 题目描述

Polycarp found under the Christmas tree an array $ a $ of $ n $ elements and instructions for playing with it:

- At first, choose index $ i $ ( $ 1 \leq i \leq n $ ) — starting position in the array. Put the chip at the index $ i $ (on the value $ a_i $ ).
- While $ i \leq n $ , add $ a_i $ to your score and move the chip $ a_i $ positions to the right (i.e. replace $ i $ with $ i + a_i $ ).
- If $ i > n $ , then Polycarp ends the game.

For example, if $ n = 5 $ and $ a = [7, 3, 1, 2, 3] $ , then the following game options are possible:

- Polycarp chooses $ i = 1 $ . Game process: $ i = 1 \overset{+7}{\longrightarrow} 8 $ . The score of the game is: $ a_1 = 7 $ .
- Polycarp chooses $ i = 2 $ . Game process: $ i = 2 \overset{+3}{\longrightarrow} 5 \overset{+3}{\longrightarrow} 8 $ . The score of the game is: $ a_2 + a_5 = 6 $ .
- Polycarp chooses $ i = 3 $ . Game process: $ i = 3 \overset{+1}{\longrightarrow} 4 \overset{+2}{\longrightarrow} 6 $ . The score of the game is: $ a_3 + a_4 = 3 $ .
- Polycarp chooses $ i = 4 $ . Game process: $ i = 4 \overset{+2}{\longrightarrow} 6 $ . The score of the game is: $ a_4 = 2 $ .
- Polycarp chooses $ i = 5 $ . Game process: $ i = 5 \overset{+3}{\longrightarrow} 8 $ . The score of the game is: $ a_5 = 3 $ .

Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of each test case contains one integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the length of the array $ a $ .

The next line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — elements of the array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output on a separate line one number — the maximum score that Polycarp can get by playing the game on the corresponding array according to the instruction from the statement. Note that Polycarp chooses any starting position from $ 1 $ to $ n $ in such a way as to maximize his result.

## 说明/提示

The first test case is explained in the statement.

In the second test case, the maximum score can be achieved by choosing $ i = 1 $ .

In the third test case, the maximum score can be achieved by choosing $ i = 2 $ .

In the fourth test case, the maximum score can be achieved by choosing $ i = 1 $ .

## 样例 #1

### 输入

```
4
5
7 3 1 2 3
3
2 1 4
6
2 1000 2 3 995 1
5
1 1 1 1 1
```

### 输出

```
7
6
1000
5
```



---

---
title: "String LCM"
layout: "post"
diff: 普及-
pid: CF1473B
tag: []
---

# String LCM

## 题目描述

如果字符串 $s$ 可以变成 $n$ 个字符串 $s_1$ 首尾相连，则说 $s$ 能被 $s_1$ 整除或 $s_1$ 能整除 $s$。

定义两个字符串 $s_1,s_2$ 的最短公倍串为：**可以被 $s_1$ 和 $s_2$ 整除的最短的非空串**。

例如： $baba$ 和 $ba$ 的最短公倍串为 $baba$；$aa$ 和 $aaa$ 的最短公倍串为 $aaaaaa$；$aba$ 和 $ab$ 没有最短公倍串。

## 输入格式

第一行一个整数 $t(1 \leq t \leq 2000)$，表示测试数据组数。

对于每一个测试数据，一共两行，每行一个字符串 $s_1,s_2(1 \leq |s_1|,|s_2| \leq 20)$，两个字符串都由 $'a'$ 和 $'b'$ 组成。

## 输出格式

对于每一个测试数据，输出 $s_1,s_2$ 的最短公倍串，如果没有输出 $-1$。

translated by [me](https://www.luogu.com.cn/user/390770)

## 样例 #1

### 输入

```
3
baba
ba
aa
aaa
aba
ab
```

### 输出

```
baba
aaaaaa
-1
```



---

---
title: "The Great Hero"
layout: "post"
diff: 普及-
pid: CF1480B
tag: []
---

# The Great Hero

## 题目描述

### 题意

  我们定义一个人物为一个二元组$(x, y)$, 称其中 $x$ 为攻击力, $y$ 为血量. 一个英雄是一个人物. 现在有 $n$ 个怪物, 每个怪物是一个人物. 我们这样定义两个人物 $A$ 与 $B$ 交战:

- $A$ 的血量减少等同于 $B$ 的攻击力的数值, $B$ 的血量也减少等同于 $A$ 的攻击力的数值.
- 然后, $A$ 和 $B$ 中所有血量小于等于 $0$ 的人物死亡.

  现在英雄需要消灭所有怪物, 消灭怪物的方式是与之交战. 请求出英雄能不能消灭所有的怪物, 即使英雄本人在消灭所有怪物后死亡.

## 输入格式

第一行包含一个正整数 $T (1\leq T \leq 10^5)$, 表示有 $T$ 组测试数据.

  接下来第 $3k-2$ 行, 包括第 $k$ 组数据中, 英雄的攻击力 $A (1\leq A\leq 10^6)$, 血量 $B (1\leq B\leq 10^6)$, 怪物个数 $n(1\leq n\leq 10^5)$.

  接下来第 $3k-1$ 行, 包括对于每个 $i\in[1, n]$ 第 $k$ 组数据中第 $i$ 个怪物的攻击力 $a_i (1\leq a_i\leq 10^6)$.

  接下来第 $3k$ 行, 包括对于每个 $i\in[1, n]$ 第 $k$ 组数据中第 $i$ 个怪物的血量 $b_i (1\leq b_i\leq 10^6)$.

  所有数据的 $n$ 的总和小于等于 $10^5$.

## 输出格式

对于每组测试数据, 输出仅一行一个字符串 "YES"(如果英雄能够杀死所有怪物) 或 "NO"(如果英雄不能杀死所有怪物) (不包括括号).

## 样例 #1

### 输入

```
5
3 17 1
2
16
10 999 3
10 20 30
100 50 30
1000 1000 4
200 300 400 500
1000 1000 1000 1000
999 999 1
1000
1000
999 999 1
1000000
999
```

### 输出

```
YES
YES
YES
NO
YES
```



---

---
title: "New Colony"
layout: "post"
diff: 普及-
pid: CF1481B
tag: []
---

# New Colony

## 题目描述

After reaching your destination, you want to build a new colony on the new planet. Since this planet has many mountains and the colony must be built on a flat surface you decided to flatten the mountains using boulders (you are still dreaming so this makes sense to you).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1481B/cfa82fc997bb3aa9f87fa07cb8193ccc436f5cb7.png)You are given an array $ h_1, h_2, \dots, h_n $ , where $ h_i $ is the height of the $ i $ -th mountain, and $ k $ — the number of boulders you have.

You will start throwing boulders from the top of the first mountain one by one and they will roll as follows (let's assume that the height of the current mountain is $ h_i $ ):

- if $ h_i \ge h_{i + 1} $ , the boulder will roll to the next mountain;
- if $ h_i < h_{i + 1} $ , the boulder will stop rolling and increase the mountain height by $ 1 $ ( $ h_i = h_i + 1 $ );
- if the boulder reaches the last mountain it will fall to the waste collection system and disappear.

You want to find the position of the $ k $ -th boulder or determine that it will fall into the waste collection system.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

Each test case consists of two lines. The first line in each test case contains two integers $ n $ and $ k $ ( $ 1 \le n \le 100 $ ; $ 1 \le k \le 10^9 $ ) — the number of mountains and the number of boulders.

The second line contains $ n $ integers $ h_1, h_2, \dots, h_n $ ( $ 1 \le h_i \le 100 $ ) — the height of the mountains.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 100 $ .

## 输出格式

For each test case, print $ -1 $ if the $ k $ -th boulder will fall into the collection system. Otherwise, print the position of the $ k $ -th boulder.

## 说明/提示

Let's simulate the first case:

- The first boulder starts at $ i = 1 $ ; since $ h_1 \ge h_2 $ it rolls to $ i = 2 $ and stops there because $ h_2 < h_3 $ .
- The new heights are $ [4,2,2,3] $ .
- The second boulder starts at $ i = 1 $ ; since $ h_1 \ge h_2 $ the boulder rolls to $ i = 2 $ ; since $ h_2 \ge h_3 $ the boulder rolls to $ i = 3 $ and stops there because $ h_3 < h_4 $ .
- The new heights are $ [4,2,3,3] $ .
- The third boulder starts at $ i = 1 $ ; since $ h_1 \ge h_2 $ it rolls to $ i = 2 $ and stops there because $ h_2 < h_3 $ .
- The new heights are $ [4,3,3,3] $ .

The positions where each boulder stopped are the following: $ [2,3,2] $ .

In the second case, all $ 7 $ boulders will stop right at the first mountain rising its height from $ 1 $ to $ 8 $ .

The third case is similar to the first one but now you'll throw $ 5 $ boulders. The first three will roll in the same way as in the first test case. After that, mountain heights will be equal to $ [4, 3, 3, 3] $ , that's why the other two boulders will fall into the collection system.

In the fourth case, the first and only boulders will fall straight into the collection system.

## 样例 #1

### 输入

```
4
4 3
4 1 2 3
2 7
1 8
4 5
4 1 2 3
3 1
5 3 1
```

### 输出

```
2
1
-1
-1
```



---

---
title: "Restore Modulo"
layout: "post"
diff: 普及-
pid: CF1484B
tag: []
---

# Restore Modulo

## 题目描述

For the first place at the competition, Alex won many arrays of integers and was assured that these arrays are very expensive. After the award ceremony Alex decided to sell them. There is a rule in arrays pawnshop: you can sell array only if it can be compressed to a generator.

This generator takes four non-negative numbers $ n $ , $ m $ , $ c $ , $ s $ . $ n $ and $ m $ must be positive, $ s $ non-negative and for $ c $ it must be true that $ 0 \leq c < m $ . The array $ a $ of length $ n $ is created according to the following rules:

- $ a_1 = s \bmod m $ , here $ x \bmod y $ denotes remainder of the division of $ x $ by $ y $ ;
- $ a_i = (a_{i-1} + c) \bmod m $ for all $ i $ such that $ 1 < i \le n $ .

For example, if $ n = 5 $ , $ m = 7 $ , $ c = 4 $ , and $ s = 10 $ , then $ a = [3, 0, 4, 1, 5] $ .

Price of such an array is the value of $ m $ in this generator.

Alex has a question: how much money he can get for each of the arrays. Please, help him to understand for every array whether there exist four numbers $ n $ , $ m $ , $ c $ , $ s $ that generate this array. If yes, then maximize $ m $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^5 $ ) — the number of arrays.

The first line of array description contains a single integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the size of this array.

The second line of array description contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \leq a_i \leq 10^9 $ ) — elements of the array.

It is guaranteed that the sum of array sizes does not exceed $ 10^5 $ .

## 输出格式

For every array print:

- $ -1 $ , if there are no such four numbers that generate this array;
- $ 0 $ , if $ m $ can be arbitrary large;
- the maximum value $ m $ and any appropriate $ c $ ( $ 0 \leq c < m $ ) in other cases.

## 样例 #1

### 输入

```
6
6
1 9 17 6 14 3
3
4 2 2
3
7 3 4
3
2 2 4
5
0 1000000000 0 1000000000 0
2
1 1
```

### 输出

```
19 8
-1
-1
-1
2000000000 1000000000
0
```



---

---
title: "Add and Divide"
layout: "post"
diff: 普及-
pid: CF1485A
tag: []
---

# Add and Divide

## 题目描述

You have two positive integers $ a $ and $ b $ .

You can perform two kinds of operations:

- $ a = \lfloor \frac{a}{b} \rfloor $ (replace $ a $ with the integer part of the division between $ a $ and $ b $ )
- $ b=b+1 $ (increase $ b $ by $ 1 $ )

Find the minimum number of operations required to make $ a=0 $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

The only line of the description of each test case contains two integers $ a $ , $ b $ ( $ 1 \le a,b \le 10^9 $ ).

## 输出格式

For each test case, print a single integer: the minimum number of operations required to make $ a=0 $ .

## 说明/提示

In the first test case, one of the optimal solutions is:

1. Divide $ a $ by $ b $ . After this operation $ a = 4 $ and $ b = 2 $ .
2. Divide $ a $ by $ b $ . After this operation $ a = 2 $ and $ b = 2 $ .
3. Increase $ b $ . After this operation $ a = 2 $ and $ b = 3 $ .
4. Divide $ a $ by $ b $ . After this operation $ a = 0 $ and $ b = 3 $ .

## 样例 #1

### 输入

```
6
9 2
1337 1
1 1
50000000 4
991026972 997
1234 5678
```

### 输出

```
4
9
2
12
3
1
```



---

---
title: "Replace and Keep Sorted"
layout: "post"
diff: 普及-
pid: CF1485B
tag: []
---

# Replace and Keep Sorted

## 题目描述

Given a positive integer $ k $ , two arrays are called $ k $ -similar if:

- they are strictly increasing;
- they have the same length;
- all their elements are positive integers between $ 1 $ and $ k $ (inclusive);
- they differ in exactly one position.

You are given an integer $ k $ , a strictly increasing array $ a $ and $ q $ queries. For each query, you are given two integers $ l_i \leq r_i $ . Your task is to find how many arrays $ b $ exist, such that $ b $ is $ k $ -similar to array $ [a_{l_i},a_{l_i+1}\ldots,a_{r_i}] $ .

## 输入格式

The first line contains three integers $ n $ , $ q $ and $ k $ ( $ 1\leq n, q \leq 10^5 $ , $ n\leq k \leq 10^9 $ ) — the length of array $ a $ , the number of queries and number $ k $ .

The second line contains $ n $ integers $ a_1, a_2, \ldots,a_n $ ( $ 1 \leq a_i \leq k $ ). This array is strictly increasing — $ a_1 < a_2 < \ldots < a_n $ .

Each of the following $ q $ lines contains two integers $ l_i $ , $ r_i $ ( $ 1 \leq l_i \leq r_i \leq n $ ).

## 输出格式

Print $ q $ lines. The $ i $ -th of them should contain the answer to the $ i $ -th query.

## 说明/提示

In the first example:

In the first query there are $ 4 $ arrays that are $ 5 $ -similar to $ [2,4] $ : $ [1,4],[3,4],[2,3],[2,5] $ .

In the second query there are $ 3 $ arrays that are $ 5 $ -similar to $ [4,5] $ : $ [1,5],[2,5],[3,5] $ .

## 样例 #1

### 输入

```
4 2 5
1 2 4 5
2 3
3 4
```

### 输出

```
4
3
```

## 样例 #2

### 输入

```
6 5 10
2 4 6 7 8 9
1 4
1 2
3 5
1 6
5 5
```

### 输出

```
8
9
7
6
9
```



---

---
title: "Cat Cycle"
layout: "post"
diff: 普及-
pid: CF1487B
tag: []
---

# Cat Cycle

## 题目描述

Suppose you are living with two cats: A and B. There are $ n $ napping spots where both cats usually sleep.

Your cats like to sleep and also like all these spots, so they change napping spot each hour cyclically:

- Cat A changes its napping place in order: $ n, n - 1, n - 2, \dots, 3, 2, 1, n, n - 1, \dots $ In other words, at the first hour it's on the spot $ n $ and then goes in decreasing order cyclically;
- Cat B changes its napping place in order: $ 1, 2, 3, \dots, n - 1, n, 1, 2, \dots $ In other words, at the first hour it's on the spot $ 1 $ and then goes in increasing order cyclically.

The cat B is much younger, so they have a strict hierarchy: A and B don't lie together. In other words, if both cats'd like to go in spot $ x $ then the A takes this place and B moves to the next place in its order (if $ x < n $ then to $ x + 1 $ , but if $ x = n $ then to $ 1 $ ). Cat B follows his order, so it won't return to the skipped spot $ x $ after A frees it, but will move to the spot $ x + 2 $ and so on.

Calculate, where cat B will be at hour $ k $ ?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first and only line of each test case contains two integers $ n $ and $ k $ ( $ 2 \le n \le 10^9 $ ; $ 1 \le k \le 10^9 $ ) — the number of spots and hour $ k $ .

## 输出格式

For each test case, print one integer — the index of the spot where cat B will sleep at hour $ k $ .

## 说明/提示

In the first and second test cases $ n = 2 $ , so:

- at the $ 1 $ -st hour, A is on spot $ 2 $ and B is on $ 1 $ ;
- at the $ 2 $ -nd hour, A moves to spot $ 1 $ and B — to $ 2 $ .

 If $ n = 3 $ then: - at the $ 1 $ -st hour, A is on spot $ 3 $ and B is on $ 1 $ ;
- at the $ 2 $ -nd hour, A moves to spot $ 2 $ ; B'd like to move from $ 1 $ to $ 2 $ , but this spot is occupied, so it moves to $ 3 $ ;
- at the $ 3 $ -rd hour, A moves to spot $ 1 $ ; B also would like to move from $ 3 $ to $ 1 $ , but this spot is occupied, so it moves to $ 2 $ .

In the sixth test case:

- A's spots at each hour are $ [5, 4, 3, 2, 1] $ ;
- B's spots at each hour are $ [1, 2, 4, 5, 2] $ .

## 样例 #1

### 输入

```
7
2 1
2 2
3 1
3 2
3 3
5 5
69 1337
```

### 输出

```
1
2
1
3
2
2
65
```



---

---
title: "Sum of Cubes"
layout: "post"
diff: 普及-
pid: CF1490C
tag: []
---

# Sum of Cubes

## 题目描述

给您一个正整数  $x$ ，问这个正整数能否拆分成两个立方数之和。

也就是说，是否存在  $1\le a, b$ 满足  $a^3+b^3=x$ 。

## 输入格式

第一行是数据个数 $t(1\le t\le100)$。

后 $T$行每行一个 $x (1\le x \le 10^{12})$，为要判断的数。

请注意，32位整型变量可能存放不下所有的 $x$，所以你应该选择你所用的编程语言里至少64位的整型变量。（要开`long long`）

## 输出格式

对于每一个 $x$，输出单独一行。

- 如果输入的 $x$满足条件就输出"YES"

- 否则输出"NO"

## 样例 #1

### 输入

```
7
1
2
4
34
35
16
703657519796
```

### 输出

```
NO
YES
NO
NO
YES
YES
YES
```



---

---
title: "Permutation Transformation"
layout: "post"
diff: 普及-
pid: CF1490D
tag: []
---

# Permutation Transformation

## 题目描述

A permutation — is a sequence of length $ n $ integers from $ 1 $ to $ n $ , in which all the numbers occur exactly once. For example, $ [1] $ , $ [3, 5, 2, 1, 4] $ , $ [1, 3, 2] $ — permutations, and $ [2, 3, 2] $ , $ [4, 3, 1] $ , $ [0] $ — no.

Polycarp was recently gifted a permutation $ a[1 \dots n] $ of length $ n $ . Polycarp likes trees more than permutations, so he wants to transform permutation $ a $ into a rooted binary tree. He transforms an array of different integers into a tree as follows:

- the maximum element of the array becomes the root of the tree;
- all elements to the left of the maximum — form a left subtree (which is built according to the same rules but applied to the left part of the array), but if there are no elements to the left of the maximum, then the root has no left child;
- all elements to the right of the maximum — form a right subtree (which is built according to the same rules but applied to the right side of the array), but if there are no elements to the right of the maximum, then the root has no right child.

For example, if he builds a tree by permutation $ a=[3, 5, 2, 1, 4] $ , then the root will be the element $ a_2=5 $ , and the left subtree will be the tree that will be built for the subarray $ a[1 \dots 1] = [3] $ , and the right one — for the subarray $ a[3 \dots 5] = [2, 1, 4] $ . As a result, the following tree will be built:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1490D/0aafe2e3bc6081fb6190b15e93678e9e1d0a0393.png)The tree corresponding to the permutation $ a=[3, 5, 2, 1, 4] $ .Another example: let the permutation be $ a=[1, 3, 2, 7, 5, 6, 4] $ . In this case, the tree looks like this:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1490D/5e7d3506add8fba00a43e087fca1d5c43d5b6f50.png)The tree corresponding to the permutation $ a=[1, 3, 2, 7, 5, 6, 4] $ .Let us denote by $ d_v $ the depth of the vertex $ a_v $ , that is, the number of edges on the path from the root to the vertex numbered $ a_v $ . Note that the root depth is zero. Given the permutation $ a $ , for each vertex, find the value of $ d_v $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of each test case contains an integer $ n $ ( $ 1 \le n \le 100 $ ) — the length of the permutation.

This is followed by $ n $ numbers $ a_1, a_2, \ldots, a_n $ — permutation $ a $ .

## 输出格式

For each test case, output $ n $ values — $ d_1, d_2, \ldots, d_n $ .

## 样例 #1

### 输入

```
3
5
3 5 2 1 4
1
1
4
4 3 1 2
```

### 输出

```
1 0 2 3 1 
0 
0 1 3 2
```



---

---
title: "Minimal Cost"
layout: "post"
diff: 普及-
pid: CF1491B
tag: []
---

# Minimal Cost

## 题目描述

给你一个 $n$ 行 $10^6+2$ 列的图，行从 $1$ 到 $n$ 标号，列从 $0$ 到 $10^6+1$ 标号。

为简便，下面用 $(i,j)$ 表示第 $i$ 行第 $j$ 列的节点。

一开始每一行 $i$ 都恰好有一个障碍物 $(i,a_i)$。你可以将障碍物移动到四周空的节点（不能移出图的范围），上下移动一个单位花费 $u$，左右移动一个单位花费 $v$。（可参照上图）

你需要使得 $(1,0)$ 到 $(n,10^6+1)$ 之间有一条路径（只能上下左右移动，不能越过障碍物），求移动障碍物的最小花费。

## 输入格式

第一行为数据组数 $t$ ($1 \leq t \leq 10^4$)。

每组数据第一行为三个整数 $n,u,v$ ($2 \leq n \leq 100, 1 \leq u,v \leq 10^9$) —— 图的行数、上下移动一个单位的花费、左右移动一个单位的花费

每组数据第二行为 $n$ 个整数 $a_1,a_2,...,a_n$ ($1 \leq a_i \leq 10^6$) —— $a_i$ 表示第 $i$ 行有障碍物 $(i,a_i)$。

保证 $\sum n \leq 2 \cdot 10^4$

## 输出格式

对于每组数据，输出一个整数 —— 移动障碍物的最小花费。

显然在题目限制下，必然有解。

## 样例 #1

### 输入

```
3
2 3 4
2 2
2 3 4
3 2
2 4 3
3 2
```

### 输出

```
7
3
3
```



---

---
title: "Card Deck"
layout: "post"
diff: 普及-
pid: CF1492B
tag: []
---

# Card Deck

## 题目描述

You have a deck of $ n $ cards, and you'd like to reorder it to a new one.

Each card has a value between $ 1 $ and $ n $ equal to $ p_i $ . All $ p_i $ are pairwise distinct. Cards in a deck are numbered from bottom to top, i. e. $ p_1 $ stands for the bottom card, $ p_n $ is the top card.

In each step you pick some integer $ k > 0 $ , take the top $ k $ cards from the original deck and place them, in the order they are now, on top of the new deck. You perform this operation until the original deck is empty. (Refer to the notes section for the better understanding.)

Let's define an order of a deck as $ \sum\limits_{i = 1}^{n}{n^{n - i} \cdot p_i} $ .

Given the original deck, output the deck with maximum possible order you can make using the operation above.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The first line of each test case contains the single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the size of deck you have.

The second line contains $ n $ integers $ p_1, p_2,\dots, p_n $ ( $ 1 \le p_i \le n $ ; $ p_i \neq p_j $ if $ i \neq j $ ) — values of card in the deck from bottom to top.

It's guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case print the deck with maximum possible order. Print values of cards in the deck from bottom to top.

If there are multiple answers, print any of them.

## 说明/提示

In the first test case, one of the optimal strategies is the next one:

1. take $ 1 $ card from the top of $ p $ and move it to $ p' $ : $ p $ becomes $ [1, 2, 3] $ , $ p' $ becomes $ [4] $ ;
2. take $ 1 $ card from the top of $ p $ : $ p $ becomes $ [1, 2] $ , $ p' $ becomes $ [4, 3] $ ;
3. take $ 1 $ card from the top of $ p $ : $ p $ becomes $ [1] $ , $ p' $ becomes $ [4, 3, 2] $ ;
4. take $ 1 $ card from the top of $ p $ : $ p $ becomes empty, $ p' $ becomes $ [4, 3, 2, 1] $ .

 In result, $ p' $ has order equal to $ 4^3 \cdot 4 + 4^2 \cdot 3 + 4^1 \cdot 2 + 4^0 \cdot 1 $ $ = $ $ 256 + 48 + 8 + 1 = 313 $ .In the second test case, one of the optimal strategies is:

1. take $ 4 $ cards from the top of $ p $ and move it to $ p' $ : $ p $ becomes $ [1] $ , $ p' $ becomes $ [5, 2, 4, 3] $ ;
2. take $ 1 $ card from the top of $ p $ and move it to $ p' $ : $ p $ becomes empty, $ p' $ becomes $ [5, 2, 4, 3, 1] $ ;

 In result, $ p' $ has order equal to $ 5^4 \cdot 5 + 5^3 \cdot 2 + 5^2 \cdot 4 + 5^1 \cdot 3 + 5^0 \cdot 1 $ $ = $ $ 3125 + 250 + 100 + 15 + 1 = 3491 $ .In the third test case, one of the optimal strategies is:

1. take $ 2 $ cards from the top of $ p $ and move it to $ p' $ : $ p $ becomes $ [4, 2, 5, 3] $ , $ p' $ becomes $ [6, 1] $ ;
2. take $ 2 $ cards from the top of $ p $ and move it to $ p' $ : $ p $ becomes $ [4, 2] $ , $ p' $ becomes $ [6, 1, 5, 3] $ ;
3. take $ 2 $ cards from the top of $ p $ and move it to $ p' $ : $ p $ becomes empty, $ p' $ becomes $ [6, 1, 5, 3, 4, 2] $ .

 In result, $ p' $ has order equal to $ 6^5 \cdot 6 + 6^4 \cdot 1 + 6^3 \cdot 5 + 6^2 \cdot 3 + 6^1 \cdot 4 + 6^0 \cdot 2 $ $ = $ $ 46656 + 1296 + 1080 + 108 + 24 + 2 = 49166 $ .

## 样例 #1

### 输入

```
4
4
1 2 3 4
5
1 5 2 4 3
6
4 2 5 3 6 1
1
1
```

### 输出

```
4 3 2 1
5 2 4 3 1
6 1 5 3 4 2
1
```



---

---
title: "Planet Lapituletti"
layout: "post"
diff: 普及-
pid: CF1493B
tag: []
---

# Planet Lapituletti

## 题目描述

The time on the planet Lapituletti goes the same way it goes on Earth but a day lasts $ h $ hours and each hour lasts $ m $ minutes. The inhabitants of that planet use digital clocks similar to earth ones. Clocks display time in a format HH:MM (the number of hours in decimal is displayed first, then (after the colon) follows the number of minutes in decimal; the number of minutes and hours is written with leading zeros if needed to form a two-digit number). Hours are numbered from $ 0 $ to $ h-1 $ and minutes are numbered from $ 0 $ to $ m-1 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1493B/60f2fad68c8c57b27eed490aaadafcab0fd86b23.png)That's how the digits are displayed on the clock. Please note that digit $ 1 $ is placed in the middle of its position.

A standard mirror is in use on the planet Lapituletti. Inhabitants often look at the reflection of the digital clocks in the mirror and feel happy when what you see on the reflected clocks is a valid time (that means that you see valid digits in the reflection and this time can be seen on the normal clocks at some moment of a day).

The image of the clocks in the mirror is reflected against a vertical axis.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1493B/45e02f44df121c5701b96d2a2728d34df90fea6a.png)The reflection is not a valid time.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1493B/a42f523b339fb6fa2f4820a2d60d05f67a7624be.png)

The reflection is a valid time with $ h=24 $ , $ m = 60 $ . However, for example, if $ h=10 $ , $ m=60 $ , then the reflection is not a valid time.

An inhabitant of the planet Lapituletti begins to look at a mirrored image of the clocks at some time moment $ s $ and wants to know the nearest future time moment (which can possibly happen on the next day), when the reflected clock time is valid.

It can be shown that with any $ h $ , $ m $ , $ s $ such a moment exists. If the reflected time is correct at the moment the inhabitant began to look at the clock, that moment is considered the nearest.

You are asked to solve the problem for several test cases.

## 输入格式

The first line contains a single integer $ T $ ( $ 1 \le T \le 100 $ ) — the number of test cases.

The next $ 2 \cdot T $ lines contain the description of test cases. The description of each test case consists of two lines.

The first line of a test case contains two integers $ h $ , $ m $ ( $ 1 \le h, m \le 100 $ ).

The second line contains the start time $ s $ in the described format HH:MM.

## 输出格式

For each test case output in a separate line the nearest moment in format HH:MM when the reflected time is correct.

## 说明/提示

In the second test case it is not hard to show that the reflection of 23:59 is incorrect, while the reflection of the moment 00:00 on the next day is correct.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1493B/50d79fafef9eb95bbfe6fa29f77ca1c6567a1615.png)

## 样例 #1

### 输入

```
5
24 60
12:21
24 60
23:59
90 80
52:26
1 100
00:01
10 10
04:04
```

### 输出

```
12:21
00:00
52:28
00:00
00:00
```



---

---
title: "Berland Crossword"
layout: "post"
diff: 普及-
pid: CF1494B
tag: []
---

# Berland Crossword

## 题目描述

Berland crossword is a puzzle that is solved on a square grid with $ n $ rows and $ n $ columns. Initially all the cells are white.

To solve the puzzle one has to color some cells on the border of the grid black in such a way that:

- exactly $ U $ cells in the top row are black;
- exactly $ R $ cells in the rightmost column are black;
- exactly $ D $ cells in the bottom row are black;
- exactly $ L $ cells in the leftmost column are black.

Note that you can color zero cells black and leave every cell white.

Your task is to check if there exists a solution to the given puzzle.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of testcases.

Then the descriptions of $ t $ testcases follow.

The only line of each testcase contains $ 5 $ integers $ n, U, R, D, L $ ( $ 2 \le n \le 100 $ ; $ 0 \le U, R, D, L \le n $ ).

## 输出格式

For each testcase print "YES" if the solution exists and "NO" otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as positive answer).

## 说明/提示

Here are possible solutions to testcases $ 1 $ , $ 2 $ and $ 4 $ :

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1494B/d621c171f085bccb3662990f2929812003bf6b92.png)

## 样例 #1

### 输入

```
4
5 2 5 3 1
3 0 0 0 0
4 4 1 4 0
2 1 1 1 1
```

### 输出

```
YES
YES
NO
YES
```



---

---
title: "Diamond Miner"
layout: "post"
diff: 普及-
pid: CF1495A
tag: []
---

# Diamond Miner

## 题目描述

[题目链接](https://codeforces.com/problemset/problem/1495/A)

在一个平面直角坐标系上，有 $n$ 个矮人与 $n$ 个钻石。保证所有矮人都在 $y$ 轴上，所有钻石都在 $x$ 轴上，且没有东西在原点

现在，每个矮人都需要去捡一个钻石。假设矮人和钻石的坐标分别为 $(x,y),(u,v)$，那么这个矮人去捡这个钻石所花费的体力就是 $\sqrt{(x-u)^2+(y-v)^2}$（也就是两点间的距离）

求一个钻石的分配方案，使得所有矮人花费的总体力最少，并输出这个最小值

## 输入格式

**本题有多组数据**  
第一行一个整数 $T$，表示数据的组数

对于每组数据：  
第一行一个整数 $n$，表示矮人与钻石的个数  
接下来 $2\cdot n$ 行，每行两个整数 $x,y$  
若 $x=0$ 则代表 $(0,y)$ 处有一个矿工  
若 $y=0$，则代表 $(x,0)$ 出有一个钻石

## 输出格式

对于每组数据，输出一行一个实数，表示最小的总体力花费  
你需要保证与答案的相对误差 $<10^{-9}$

## 说明/提示

$1 \le T \le 10$  
$1\le n \le 10^5,\sum n\le 10^5$  
$|x|,|y|\le 10^8$

## 样例 #1

### 输入

```
3
2
0 1
1 0
0 -1
-2 0
4
1 0
3 0
-5 0
6 0
0 3
0 1
0 2
0 4
5
3 0
0 4
0 -3
4 0
2 0
1 0
-3 0
0 -10
0 -2
0 -10
```

### 输出

```
3.650281539872885
18.061819283610362
32.052255376143336
```



---

---
title: "Max and Mex"
layout: "post"
diff: 普及-
pid: CF1496B
tag: []
---

# Max and Mex

## 题目描述

[题目链接](https://codeforces.com/problemset/problem/1496/B)

给出一个长度大小为 $n$ 的可重集合 $S$（集合内允许有），保证这 $n$ 个数互不相同且非负。

接下来，你需要将下面操作进行 $k$ 次：  
将 $\lceil \frac{a+b}{2}\rceil$ 加入集合（注意这里是**可重集**），其中 $a=\operatorname{mex}(S)$， $b=\max(S)$。

这里 $\operatorname{mex}(S)$ 表示集合 $S$ 中没有出现过的最小的非负整数，$\max(S)$ 表示 $S$ 中的最大整数。

求 $k$ 次操作后，集合 $S$ 中有多少个不同的数。

## 输入格式

**本题有多组数据**  
第一行一个整数 $T$，表示数据的组数。  
对于每组数据：  
第一行两个整数 $n,k$，表示集合初始长度和操作次数。  
第二行 $n$ 个整数，表示 $a_{1 \dots n}$。

## 输出格式

对于每组数据，输出一行一个整数表示答案。

## 说明/提示

$1\le T \le 100$  
$1\le n \le 10^5$  
$0 \le a_i,k \le 10^9$  
$\sum n\le 10^5$

## 样例 #1

### 输入

```
5
4 1
0 1 3 4
3 1
0 1 4
3 0
0 1 4
3 2
0 1 2
3 2
1 2 3
```

### 输出

```
4
4
3
5
3
```



---

---
title: "M-arrays"
layout: "post"
diff: 普及-
pid: CF1497B
tag: []
---

# M-arrays

## 题目描述

You are given an array $ a_1, a_2, \ldots, a_n $ consisting of $ n $ positive integers and a positive integer $ m $ .

You should divide elements of this array into some arrays. You can order the elements in the new arrays as you want.

Let's call an array $ m $ -divisible if for each two adjacent numbers in the array (two numbers on the positions $ i $ and $ i+1 $ are called adjacent for each $ i $ ) their sum is divisible by $ m $ . An array of one element is $ m $ -divisible.

Find the smallest number of $ m $ -divisible arrays that $ a_1, a_2, \ldots, a_n $ is possible to divide into.

## 输入格式

The first line contains a single integer $ t $ $ (1 \le t \le 1000) $ — the number of test cases.

The first line of each test case contains two integers $ n $ , $ m $ $ (1 \le n \le 10^5, 1 \le m \le 10^5) $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ $ (1 \le a_i \le 10^9) $ .

It is guaranteed that the sum of $ n $ and the sum of $ m $ over all test cases do not exceed $ 10^5 $ .

## 输出格式

For each test case print the answer to the problem.

## 说明/提示

In the first test case we can divide the elements as follows:

- $ [4, 8] $ . It is a $ 4 $ -divisible array because $ 4+8 $ is divisible by $ 4 $ .
- $ [2, 6, 2] $ . It is a $ 4 $ -divisible array because $ 2+6 $ and $ 6+2 $ are divisible by $ 4 $ .
- $ [9] $ . It is a $ 4 $ -divisible array because it consists of one element.

## 样例 #1

### 输入

```
4
6 4
2 2 8 6 9 4
10 8
1 1 1 5 2 4 4 8 6 7
1 1
666
2 2
2 4
```

### 输出

```
3
6
1
1
```



---

---
title: "k-LCM (easy version)"
layout: "post"
diff: 普及-
pid: CF1497C1
tag: []
---

# k-LCM (easy version)

## 题目描述

It is the easy version of the problem. The only difference is that in this version $ k = 3 $ .

You are given a positive integer $ n $ . Find $ k $ positive integers $ a_1, a_2, \ldots, a_k $ , such that:

- $ a_1 + a_2 + \ldots + a_k = n $
- $ LCM(a_1, a_2, \ldots, a_k) \le \frac{n}{2} $

Here $ LCM $ is the [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of numbers $ a_1, a_2, \ldots, a_k $ .

We can show that for given constraints the answer always exists.

## 输入格式

The first line contains a single integer $ t $ $ (1 \le t \le 10^4) $ — the number of test cases.

The only line of each test case contains two integers $ n $ , $ k $ ( $ 3 \le n \le 10^9 $ , $ k = 3 $ ).

## 输出格式

For each test case print $ k $ positive integers $ a_1, a_2, \ldots, a_k $ , for which all conditions are satisfied.

## 样例 #1

### 输入

```
3
3 3
8 3
14 3
```

### 输出

```
1 1 1
4 2 2
2 6 6
```



---

---
title: "GCD Sum"
layout: "post"
diff: 普及-
pid: CF1498A
tag: []
---

# GCD Sum

## 题目描述

The $ \text{ $ gcdSum $ } $ of a positive integer is the $ gcd $ of that integer with its sum of digits. Formally, $ \text{ $ gcdSum $ }(x) = gcd(x, \text{ sum of digits of } x) $ for a positive integer $ x $ . $ gcd(a, b) $ denotes the greatest common divisor of $ a $ and $ b $ — the largest integer $ d $ such that both integers $ a $ and $ b $ are divisible by $ d $ .

For example: $ \text{ $ gcdSum $ }(762) = gcd(762, 7 + 6 + 2)=gcd(762,15) = 3 $ .

Given an integer $ n $ , find the smallest integer $ x \ge n $ such that $ \text{ $ gcdSum $ }(x) > 1 $ .

## 输入格式

The first line of input contains one integer $ t $ $ (1 \le t \le 10^4) $ — the number of test cases.

Then $ t $ lines follow, each containing a single integer $ n $ $ (1 \le n \le 10^{18}) $ .

All test cases in one test are different.

## 输出格式

Output $ t $ lines, where the $ i $ -th line is a single integer containing the answer to the $ i $ -th test case.

## 说明/提示

Let us explain the three test cases in the sample.

Test case 1: $ n = 11 $ :

 $ \text{ $ gcdSum $ }(11) = gcd(11, 1 + 1) = gcd(11,\ 2) = 1 $ .

 $ \text{ $ gcdSum $ }(12) = gcd(12, 1 + 2) = gcd(12,\ 3) = 3 $ .

So the smallest number $ \ge 11 $ whose $ gcdSum $ $ > 1 $ is $ 12 $ .

Test case 2: $ n = 31 $ :

 $ \text{ $ gcdSum $ }(31) = gcd(31, 3 + 1) = gcd(31,\ 4) = 1 $ .

 $ \text{ $ gcdSum $ }(32) = gcd(32, 3 + 2) = gcd(32,\ 5) = 1 $ .

 $ \text{ $ gcdSum $ }(33) = gcd(33, 3 + 3) = gcd(33,\ 6) = 3 $ .

So the smallest number $ \ge 31 $ whose $ gcdSum $ $ > 1 $ is $ 33 $ .

Test case 3: $ \ n = 75 $ :

 $ \text{ $ gcdSum $ }(75) = gcd(75, 7 + 5) = gcd(75,\ 12) = 3 $ .

The $ \text{ $ gcdSum $ } $ of $ 75 $ is already $ > 1 $ . Hence, it is the answer.

## 样例 #1

### 输入

```
3
11
31
75
```

### 输出

```
12
33
75
```



---

---
title: "Binary Removals"
layout: "post"
diff: 普及-
pid: CF1499B
tag: []
---

# Binary Removals

## 题目描述

You are given a string $ s $ , consisting only of characters '0' or '1'. Let $ |s| $ be the length of $ s $ .

You are asked to choose some integer $ k $ ( $ k > 0 $ ) and find a sequence $ a $ of length $ k $ such that:

- $ 1 \le a_1 < a_2 < \dots < a_k \le |s| $ ;
- $ a_{i-1} + 1 < a_i $ for all $ i $ from $ 2 $ to $ k $ .

The characters at positions $ a_1, a_2, \dots, a_k $ are removed, the remaining characters are concatenated without changing the order. So, in other words, the positions in the sequence $ a $ should not be adjacent.

Let the resulting string be $ s' $ . $ s' $ is called sorted if for all $ i $ from $ 2 $ to $ |s'| $ $ s'_{i-1} \le s'_i $ .

Does there exist such a sequence $ a $ that the resulting string $ s' $ is sorted?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of testcases.

Then the descriptions of $ t $ testcases follow.

The only line of each testcase contains a string $ s $ ( $ 2 \le |s| \le 100 $ ). Each character is either '0' or '1'.

## 输出格式

For each testcase print "YES" if there exists a sequence $ a $ such that removing the characters at positions $ a_1, a_2, \dots, a_k $ and concatenating the parts without changing the order produces a sorted string.

Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as positive answer).

## 说明/提示

In the first testcase you can choose a sequence $ a=[1,3,6,9] $ . Removing the underlined letters from "10101011011" will produce a string "0011111", which is sorted.

In the second and the third testcases the sequences are already sorted.

In the fourth testcase you can choose a sequence $ a=[3] $ . $ s'= $ "11", which is sorted.

In the fifth testcase there is no way to choose a sequence $ a $ such that $ s' $ is sorted.

## 样例 #1

### 输入

```
5
10101011011
0000
11111
110
1100
```

### 输出

```
YES
YES
YES
YES
NO
```



---

---
title: "Young Photographer"
layout: "post"
diff: 普及-
pid: CF14B
tag: []
---

# Young Photographer

## 题目描述

Among other things, Bob is keen on photography. Especially he likes to take pictures of sportsmen. That was the reason why he placed himself in position $ x_{0} $ of a long straight racetrack and got ready to take pictures. But the problem was that not all the runners passed him. The total amount of sportsmen, training at that racetrack, equals $ n $ . And each of them regularly runs distances within a particular segment of the racetrack, which is the same for each sportsman. For example, the first sportsman runs from position $ a_{1} $ to position $ b_{1} $ , the second — from $ a_{2} $ to $ b_{2} $

What is the minimum distance that Bob should move to have a chance to take pictures of each sportsman? Bob can take a picture of a sportsman, if he stands within the segment that this sportsman covers on the racetrack.

## 输入格式

The first line of the input file contains integers $ n $ and $ x_{0} $ ( $ 1<=n<=100 $ ; $ 0<=x_{0}<=1000 $ ). The following $ n $ lines contain pairs of integers $ a_{i},b_{i} $ ( $ 0<=a_{i},b_{i}<=1000 $ ; $ a_{i}≠b_{i} $ ).

## 输出格式

Output the required minimum distance in the same units as the positions on the racetrack. If there is no such a position, output -1.

## 样例 #1

### 输入

```
3 3
0 7
14 2
4 6

```

### 输出

```
1

```



---

---
title: "Napoleon Cake"
layout: "post"
diff: 普及-
pid: CF1501B
tag: []
---

# Napoleon Cake

## 题目描述

This week Arkady wanted to cook some pancakes (to follow ancient traditions) and make a problem about that. But then he remembered that one can't make a problem about stacking pancakes without working at a specific IT company, so he decided to bake the Napoleon cake instead.

To bake a Napoleon cake, one has to bake $ n $ dry layers first, and then put them on each other in one stack, adding some cream. Arkady started with an empty plate, and performed the following steps $ n $ times:

- place a new cake layer on the top of the stack;
- after the $ i $ -th layer is placed, pour $ a_i $ units of cream on top of the stack.

When $ x $ units of cream are poured on the top of the stack, top $ x $ layers of the cake get drenched in the cream. If there are less than $ x $ layers, all layers get drenched and the rest of the cream is wasted. If $ x = 0 $ , no layer gets drenched.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1501B/d2a848de33f21319239069b9694ee652ecb320b0.png)The picture represents the first test case of the example.Help Arkady determine which layers of the cake eventually get drenched when the process is over, and which don't.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 20\,000 $ ). Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of layers in the cake.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le n $ ) — the amount of cream poured on the cake after adding each layer.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print a single line with $ n $ integers. The $ i $ -th of the integers should be equal to $ 1 $ if the $ i $ -th layer from the bottom gets drenched, and $ 0 $ otherwise.

## 样例 #1

### 输入

```
3
6
0 3 0 0 1 3
10
0 0 0 1 0 5 0 0 0 2
3
0 0 0
```

### 输出

```
1 1 0 1 1 1 
0 1 1 1 1 1 0 0 1 1 
0 0 0
```



---

---
title: "Déjà Vu"
layout: "post"
diff: 普及-
pid: CF1504A
tag: []
---

# Déjà Vu

## 题目描述

定义一个回文串为正着读与倒着读都相同的字符串，比如 `z`，`aba` 和 `abccba` 都是回文串。你恨回文串因为它给你“既视感”。

现有一字符串  $s$，你必须插入恰好一个字母 `a` 在  $s$ 的某处。若操作后的新字符串可能**不是**回文串，你需要找到一个例子；反之，你需要报告这是不可能的

比如，假设  $s$ 为 `cbabc`，通过插入一个字母 `a`，可以得到 `acbabc`、`cababc`、`cbaabc`、`cbabac`、或 `cbabca`。然而，`cbaabc` 是回文串，所以你应当输出其它字符串中的一个。

## 输入格式

第  $1$ 行一个整数  $t$，代表  $t$ 组测试数据

第  $2$ 行至第  $n+1$ 行，每行一个字符串

## 输出格式

对于每个字符串
- 若不可能使新字符串不是回文串，输出 `NO`
- 反之，输出 `YES`，换行并举出一例

换行

`YES` 与 `NO` 可以是小写或大写

## 说明/提示

$1 \leq t \leq 10^4$

字符串总长度不超过  $3 \times 10^5$

## 样例 #1

### 输入

```
6
cbabc
ab
zza
ba
a
nutforajaroftuna
```

### 输出

```
YES
cbabac
YES
aab
YES
zaza
YES
baa
NO
YES
nutforajarofatuna
```



---

---
title: "Flip the Bits"
layout: "post"
diff: 普及-
pid: CF1504B
tag: []
---

# Flip the Bits

## 题目描述

There is a binary string $ a $ of length $ n $ . In one operation, you can select any prefix of $ a $ with an equal number of $ 0 $ and $ 1 $ symbols. Then all symbols in the prefix are inverted: each $ 0 $ becomes $ 1 $ and each $ 1 $ becomes $ 0 $ .

For example, suppose $ a=0111010000 $ .

- In the first operation, we can select the prefix of length $ 8 $ since it has four $ 0 $ 's and four $ 1 $ 's: $ [01110100]00\to [10001011]00 $ .
- In the second operation, we can select the prefix of length $ 2 $ since it has one $ 0 $ and one $ 1 $ : $ [10]00101100\to [01]00101100 $ .
- It is illegal to select the prefix of length $ 4 $ for the third operation, because it has three $ 0 $ 's and one $ 1 $ .

Can you transform the string $ a $ into the string $ b $ using some finite number of operations (possibly, none)?

## 输入格式

The first line contains a single integer $ t $ ( $ 1\le t\le 10^4 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1\le n\le 3\cdot 10^5 $ ) — the length of the strings $ a $ and $ b $ .

The following two lines contain strings $ a $ and $ b $ of length $ n $ , consisting of symbols $ 0 $ and $ 1 $ .

The sum of $ n $ across all test cases does not exceed $ 3\cdot 10^5 $ .

## 输出格式

For each test case, output "YES" if it is possible to transform $ a $ into $ b $ , or "NO" if it is impossible. You can print each letter in any case (upper or lower).

## 说明/提示

The first test case is shown in the statement.

In the second test case, we transform $ a $ into $ b $ by using zero operations.

In the third test case, there is no legal operation, so it is impossible to transform $ a $ into $ b $ .

In the fourth test case, here is one such transformation:

- Select the length $ 2 $ prefix to get $ 100101010101 $ .
- Select the length $ 12 $ prefix to get $ 011010101010 $ .
- Select the length $ 8 $ prefix to get $ 100101011010 $ .
- Select the length $ 4 $ prefix to get $ 011001011010 $ .
- Select the length $ 6 $ prefix to get $ 100110011010 $ .

In the fifth test case, the only legal operation is to transform $ a $ into $ 111000 $ . From there, the only legal operation is to return to the string we started with, so we cannot transform $ a $ into $ b $ .

## 样例 #1

### 输入

```
5
10
0111010000
0100101100
4
0000
0000
3
001
000
12
010101010101
100110011010
6
000111
110100
```

### 输出

```
YES
YES
NO
YES
NO
```



---

---
title: "Partial Replacement"
layout: "post"
diff: 普及-
pid: CF1506B
tag: []
---

# Partial Replacement

## 题目描述

You are given a number $ k $ and a string $ s $ of length $ n $ , consisting of the characters '.' and '\*'. You want to replace some of the '\*' characters with 'x' characters so that the following conditions are met:

- The first character '\*' in the original string should be replaced with 'x';
- The last character '\*' in the original string should be replaced with 'x';
- The distance between two neighboring replaced characters 'x' must not exceed $ k $ (more formally, if you replaced characters at positions $ i $ and $ j $ ( $ i < j $ ) and at positions $ [i+1, j-1] $ there is no "x" symbol, then $ j-i $ must be no more than $ k $ ).

For example, if $ n=7 $ , $ s= $ .\*\*.\*\*\* and $ k=3 $ , then the following strings will satisfy the conditions above:

- .xx.\*xx;
- .x\*.x\*x;
- .xx.xxx.

 But, for example, the following strings will not meet the conditions: - .\*\*.\*xx (the first character '\*' should be replaced with 'x');
- .x\*.xx\* (the last character '\*' should be replaced with 'x');
- .x\*.\*xx (the distance between characters at positions $ 2 $ and $ 6 $ is greater than $ k=3 $ ).

Given $ n $ , $ k $ , and $ s $ , find the minimum number of '\*' characters that must be replaced with 'x' in order to meet the above conditions.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 500 $ ). Then $ t $ test cases follow.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 50 $ ).

The second line of each test case contains a string $ s $ of length $ n $ , consisting of the characters '.' and '\*'.

It is guaranteed that there is at least one '\*' in the string $ s $ .

It is guaranteed that the distance between any two neighboring '\*' characters does not exceed $ k $ .

## 输出格式

For each test case output the minimum number of '\*' characters that must be replaced with 'x' characters in order to satisfy the conditions above.

## 样例 #1

### 输入

```
5
7 3
.**.***
5 1
..*..
5 2
*.*.*
3 2
*.*
1 1
*
```

### 输出

```
3
1
3
2
1
```



---

---
title: "Double-ended Strings"
layout: "post"
diff: 普及-
pid: CF1506C
tag: []
---

# Double-ended Strings

## 题目描述

You are given the strings $ a $ and $ b $ , consisting of lowercase Latin letters. You can do any number of the following operations in any order:

- if $ |a| > 0 $ (the length of the string $ a $ is greater than zero), delete the first character of the string $ a $ , that is, replace $ a $ with $ a_2 a_3 \ldots a_n $ ;
- if $ |a| > 0 $ , delete the last character of the string $ a $ , that is, replace $ a $ with $ a_1 a_2 \ldots a_{n-1} $ ;
- if $ |b| > 0 $ (the length of the string $ b $ is greater than zero), delete the first character of the string $ b $ , that is, replace $ b $ with $ b_2 b_3 \ldots b_n $ ;
- if $ |b| > 0 $ , delete the last character of the string $ b $ , that is, replace $ b $ with $ b_1 b_2 \ldots b_{n-1} $ .

Note that after each of the operations, the string $ a $ or $ b $ may become empty.

For example, if $ a= $ "hello" and $ b= $ "icpc", then you can apply the following sequence of operations:

- delete the first character of the string $ a $ $ \Rightarrow $ $ a= $ "ello" and $ b= $ "icpc";
- delete the first character of the string $ b $ $ \Rightarrow $ $ a= $ "ello" and $ b= $ "cpc";
- delete the first character of the string $ b $ $ \Rightarrow $ $ a= $ "ello" and $ b= $ "pc";
- delete the last character of the string $ a $ $ \Rightarrow $ $ a= $ "ell" and $ b= $ "pc";
- delete the last character of the string $ b $ $ \Rightarrow $ $ a= $ "ell" and $ b= $ "p".

For the given strings $ a $ and $ b $ , find the minimum number of operations for which you can make the strings $ a $ and $ b $ equal. Note that empty strings are also equal.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ). Then $ t $ test cases follow.

The first line of each test case contains the string $ a $ ( $ 1 \le |a| \le 20 $ ), consisting of lowercase Latin letters.

The second line of each test case contains the string $ b $ ( $ 1 \le |b| \le 20 $ ), consisting of lowercase Latin letters.

## 输出格式

For each test case, output the minimum number of operations that can make the strings $ a $ and $ b $ equal.

## 样例 #1

### 输入

```
5
a
a
abcd
bc
hello
codeforces
hello
helo
dhjakjsnasjhfksafasd
adjsnasjhfksvdafdser
```

### 输出

```
0
2
13
3
20
```



---

---
title: "TMT Document"
layout: "post"
diff: 普及-
pid: CF1509B
tag: []
---

# TMT Document

## 题目描述

The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.

However, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length $ n $ whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.

A string $ a $ is a subsequence of a string $ b $ if $ a $ can be obtained from $ b $ by deletion of several (possibly, zero) characters.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 5000 $ ) — the number of test cases.

The first line of each test case contains an integer $ n $ ( $ 3 \le n < 10^5 $ ), the number of characters in the string entered in the document. It is guaranteed that $ n $ is divisible by $ 3 $ .

The second line of each test case contains a string of length $ n $ consisting of only the characters T and M.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, print a single line containing YES if the described partition exists, and a single line containing NO otherwise.

## 说明/提示

In the first test case, the string itself is already a sequence equal to TMT.

In the third test case, we may partition the string into the subsequences TMTMTT. Both the bolded and the non-bolded subsequences are equal to TMT.

## 样例 #1

### 输入

```
5
3
TMT
3
MTT
6
TMTMTT
6
TMTTTT
6
TTMMTT
```

### 输出

```
YES
NO
YES
NO
YES
```



---

---
title: "GCD Length"
layout: "post"
diff: 普及-
pid: CF1511B
tag: []
---

# GCD Length

## 题目描述

You are given three integers $ a $ , $ b $ and $ c $ .

Find two positive integers $ x $ and $ y $ ( $ x > 0 $ , $ y > 0 $ ) such that:

- the decimal representation of $ x $ without leading zeroes consists of $ a $ digits;
- the decimal representation of $ y $ without leading zeroes consists of $ b $ digits;
- the decimal representation of $ gcd(x, y) $ without leading zeroes consists of $ c $ digits.

 $ gcd(x, y) $ denotes the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $ x $ and $ y $ .

Output $ x $ and $ y $ . If there are multiple answers, output any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 285 $ ) — the number of testcases.

Each of the next $ t $ lines contains three integers $ a $ , $ b $ and $ c $ ( $ 1 \le a, b \le 9 $ , $ 1 \le c \le min(a, b) $ ) — the required lengths of the numbers.

It can be shown that the answer exists for all testcases under the given constraints.

Additional constraint on the input: all testcases are different.

## 输出格式

For each testcase print two positive integers — $ x $ and $ y $ ( $ x > 0 $ , $ y > 0 $ ) such that

- the decimal representation of $ x $ without leading zeroes consists of $ a $ digits;
- the decimal representation of $ y $ without leading zeroes consists of $ b $ digits;
- the decimal representation of $ gcd(x, y) $ without leading zeroes consists of $ c $ digits.

## 说明/提示

In the example:

1. $ gcd(11, 492) = 1 $
2. $ gcd(13, 26) = 13 $
3. $ gcd(140133, 160776) = 21 $
4. $ gcd(1, 1) = 1 $

## 样例 #1

### 输入

```
4
2 3 1
2 2 2
6 6 2
1 1 1
```

### 输出

```
11 492
13 26
140133 160776
1 1
```



---

---
title: "Almost Rectangle"
layout: "post"
diff: 普及-
pid: CF1512B
tag: []
---

# Almost Rectangle

## 题目描述

There is a square field of size $ n \times n $ in which two cells are marked. These cells can be in the same row or column.

You are to mark two more cells so that they are the corners of a rectangle with sides parallel to the coordinate axes.

For example, if $ n=4 $ and a rectangular field looks like this (there are asterisks in the marked cells):

  $$\begin{matrix}
.&.&*&.\\
.&.&.&.\\
*&.&.&.\\
.&.&.&.\\
\end{matrix}$$

Then you can mark two more cells as follows

 $$\begin{matrix}
*&.&*&.\\
.&.&.&.\\
*&.&*&.\\
.&.&.&.\\
\end{matrix} $$

If there are several possible solutions, then print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 400 $ ). Then $ t $ test cases follow.

The first row of each test case contains a single integer $ n $ ( $ 2 \le n \le 400 $ ) — the number of rows and columns in the table.

The following $ n $ lines each contain $ n $ characters '.' or '\*' denoting empty and marked cells, respectively.

It is guaranteed that the sums of $ n $ for all test cases do not exceed $ 400 $ .

It is guaranteed that there are exactly two asterisks on the field. They can be in the same row/column.

It is guaranteed that the solution exists.

## 输出格式

For each test case, output $ n $ rows of $ n $ characters — a field with four asterisks marked corresponding to the statements. If there multiple correct answers, print any of them.

## 样例 #1

### 输入

```
6
4
..*.
....
*...
....
2
*.
.*
2
.*
.*
3
*.*
...
...
5
.....
..*..
.....
.*...
.....
4
....
....
*...
*...
```

### 输出

```
*.*.
....
*.*.
....
**
**
**
**
*.*
*.*
...
.....
.**..
.....
.**..
.....
....
....
**..
**..
```



---

---
title: "Phoenix and Gold"
layout: "post"
diff: 普及-
pid: CF1515A
tag: []
---

# Phoenix and Gold

## 题目描述

Phoenix has collected $ n $ pieces of gold, and he wants to weigh them together so he can feel rich. The $ i $ -th piece of gold has weight $ w_i $ . All weights are distinct. He will put his $ n $ pieces of gold on a weight scale, one piece at a time.

The scale has an unusual defect: if the total weight on it is exactly $ x $ , it will explode. Can he put all $ n $ gold pieces onto the scale in some order, without the scale exploding during the process? If so, help him find some possible order.

Formally, rearrange the array $ w $ so that for each $ i $ $ (1 \le i \le n) $ , $ \sum\limits_{j = 1}^{i}w_j \ne x $ .

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ x $ ( $ 1 \le n \le 100 $ ; $ 1 \le x \le 10^4 $ ) — the number of gold pieces that Phoenix has and the weight to avoid, respectively.

The second line of each test case contains $ n $ space-separated integers $ (1 \le w_i \le 100) $ — the weights of the gold pieces. It is guaranteed that the weights are pairwise distinct.

## 输出格式

For each test case, if Phoenix cannot place all $ n $ pieces without the scale exploding, print NO. Otherwise, print YES followed by the rearranged array $ w $ . If there are multiple solutions, print any.

## 说明/提示

In the first test case, Phoenix puts the gold piece with weight $ 3 $ on the scale first, then the piece with weight $ 2 $ , and finally the piece with weight $ 1 $ . The total weight on the scale is $ 3 $ , then $ 5 $ , then $ 6 $ . The scale does not explode because the total weight on the scale is never $ 2 $ .

In the second test case, the total weight on the scale is $ 8 $ , $ 9 $ , $ 11 $ , $ 14 $ , then $ 18 $ . It is never $ 3 $ .

In the third test case, Phoenix must put the gold piece with weight $ 5 $ on the scale, and the scale will always explode.

## 样例 #1

### 输入

```
3
3 2
3 2 1
5 3
1 2 3 4 8
1 5
5
```

### 输出

```
YES
3 2 1
YES
8 1 2 3 4
NO
```



---

---
title: "Phoenix and Puzzle"
layout: "post"
diff: 普及-
pid: CF1515B
tag: []
---

# Phoenix and Puzzle

## 题目描述

Phoenix is playing with a new puzzle, which consists of $ n $ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1515B/49a24f982b19e9535d6f30d4c91e443065d9fee9.png)A puzzle pieceThe goal of the puzzle is to create a square using the $ n $ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $ n $ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains an integer $ n $ ( $ 1 \le n \le 10^9 $ ) — the number of puzzle pieces.

## 输出格式

For each test case, if Phoenix can create a square with the $ n $ puzzle pieces, print YES. Otherwise, print NO.

## 说明/提示

For $ n=2 $ , Phoenix can create a square like this:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1515B/0fdfe011cd52355d3ad3123ce3848f97d63a78aa.png)For $ n=4 $ , Phoenix can create a square like this:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1515B/79f4dda31da05d0a22081f6d24d2a99d26f679bc.png)For $ n=6 $ , it is impossible for Phoenix to create a square.

## 样例 #1

### 输入

```
3
2
4
6
```

### 输出

```
YES
YES
NO
```



---

---
title: "Berland Regional"
layout: "post"
diff: 普及-
pid: CF1519C
tag: []
---

# Berland Regional

## 题目描述

Polycarp is an organizer of a Berland ICPC regional event. There are $ n $ universities in Berland numbered from $ 1 $ to $ n $ . Polycarp knows all competitive programmers in the region. There are $ n $ students: the $ i $ -th student is enrolled at a university $ u_i $ and has a programming skill $ s_i $ .

Polycarp has to decide on the rules now. In particular, the number of members in the team.

Polycarp knows that if he chooses the size of the team to be some integer $ k $ , each university will send their $ k $ strongest (with the highest programming skill $ s $ ) students in the first team, the next $ k $ strongest students in the second team and so on. If there are fewer than $ k $ students left, then the team can't be formed. Note that there might be universities that send zero teams.

The strength of the region is the total skill of the members of all present teams. If there are no teams present, then the strength is $ 0 $ .

Help Polycarp to find the strength of the region for each choice of $ k $ from $ 1 $ to $ n $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of testcases.

The first line of each testcase contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of universities and the number of students.

The second line of each testcase contains $ n $ integers $ u_1, u_2, \dots, u_n $ ( $ 1 \le u_i \le n $ ) — the university the $ i $ -th student is enrolled at.

The third line of each testcase contains $ n $ integers $ s_1, s_2, \dots, s_n $ ( $ 1 \le s_i \le 10^9 $ ) — the programming skill of the $ i $ -th student.

The sum of $ n $ over all testcases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each testcase print $ n $ integers: the strength of the region — the total skill of the members of the present teams — for each choice of team size $ k $ .

## 说明/提示

In the first testcase the teams from each university for each $ k $ are:

- $ k=1 $ : 
  - university $ 1 $ : $ [6], [5], [5], [3] $ ;
  - university $ 2 $ : $ [8], [1], [1] $ ;
- $ k=2 $ : 
  - university $ 1 $ : $ [6, 5], [5, 3] $ ;
  - university $ 2 $ : $ [8, 1] $ ;
- $ k=3 $ : 
  - university $ 1 $ : $ [6, 5, 5] $ ;
  - university $ 2 $ : $ [8, 1, 1] $ ;
- $ k=4 $ : 
  - university $ 1 $ : $ [6, 5, 5, 3] $ ;

## 样例 #1

### 输入

```
4
7
1 2 1 2 1 2 1
6 8 3 1 5 1 5
10
1 1 1 2 2 2 2 3 3 3
3435 3014 2241 2233 2893 2102 2286 2175 1961 2567
6
3 3 3 3 3 3
5 9 6 7 9 7
1
1
3083
```

### 输出

```
29 28 26 19 0 0 0 
24907 20705 22805 9514 0 0 0 0 0 0 
43 43 43 32 38 43 
3083
```



---

---
title: "Soft Drinking"
layout: "post"
diff: 普及-
pid: CF151A
tag: []
---

# Soft Drinking

## 题目描述

This winter is so cold in Nvodsk! A group of $ n $ friends decided to buy $ k $ bottles of a soft drink called "Take-It-Light" to warm up a bit. Each bottle has $ l $ milliliters of the drink. Also they bought $ c $ limes and cut each of them into $ d $ slices. After that they found $ p $ grams of salt.

To make a toast, each friend needs $ nl $ milliliters of the drink, a slice of lime and $ np $ grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?

## 输入格式

The first and only line contains positive integers $ n $ , $ k $ , $ l $ , $ c $ , $ d $ , $ p $ , $ nl $ , $ np $ , not exceeding $ 1000 $ and no less than $ 1 $ . The numbers are separated by exactly one space.

## 输出格式

Print a single integer — the number of toasts each friend can make.

## 说明/提示

A comment to the first sample:

Overall the friends have $ 4*5=20 $ milliliters of the drink, it is enough to make $ 20/3=6 $ toasts. The limes are enough for $ 10*8=80 $ toasts and the salt is enough for $ 100/1=100 $ toasts. However, there are 3 friends in the group, so the answer is $ min(6,80,100)/3=2 $ .

## 样例 #1

### 输入

```
3 4 5 10 8 100 3 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
5 100 10 1 19 90 4 3

```

### 输出

```
3

```

## 样例 #3

### 输入

```
10 1000 1000 25 23 1 50 1

```

### 输出

```
0

```



---

---
title: "Do Not Be Distracted!"
layout: "post"
diff: 普及-
pid: CF1520A
tag: []
---

# Do Not Be Distracted!

## 题目描述

Polycarp 有 $26$ 个任务。每一个任务都由一个大写字母来决定。

老师让 Polycarp 按以下规则做任务：如果 Polycarp 开始做某些任务，那么他必须一直做它，期间不能做其它任务，直到切换任务。但在切换到另一个任务之后，Polycarp 就不能再回到以前做过的任务了。

Polycarp 只能在一天内做一个任务。每一天他会写下他做了什么任务。现在老师想知道 Polycarp 是否遵守了他的规则。

举个例子，如果 Polycarp 以`DDBBCCCBBEZ`的顺序来做任务，那么老师就会知道在第三天 Polycarp 开始做任务`B`，然后在第五天他转移到做任务`C`，在第八天 Polycarp 又回到了做任务`B`，不符合老师的规则，老师就会怀疑他。老师会怀疑的的另外的例子有：`BAB`、`AABBCCDDEEBZZ`和`AAAAZAAAAA`。

如果 Polycarp 按照 `FFGZZZY` 的顺序来做，那么老师就没有任何怀疑。请注意 Polycarp 不必须完成所有的 $26$ 个任务。老师不会怀疑的其它例子有：`BA`、`AFFFCC`和`YYYYY`。

请你帮 Polycarp 指出他的老师是否会怀疑他。

## 输入格式

第一行有一个整数 $t$（$1\leq t\leq1000$），表示数据组数。接下来分别输入这 $t$ 组数据。

对于每一组数据，第一行一个整数 $n$（$1\leq n\leq50$），表示 Polycarp 花了几天做任务。

第二行为一个长度为 $n$ 的字符串，只包括大写的字母，表示 Polycarp 每天做的任务。

## 输出格式

对于每一组数据输出：

- `YES`，表示老师不会怀疑 Polycarp。
- 否则，输出 `NO`。

你可以以任意的方式输出字母（例如，`yEs`、`yes`、`Yes`和`YES`都表示老师不会怀疑）。

## 样例 #1

### 输入

```
5
3
ABA
11
DDBBCCCBBEZ
7
FFGZZZY
1
Z
2
AB
```

### 输出

```
NO
NO
YES
YES
YES
```



---

---
title: "Same Differences"
layout: "post"
diff: 普及-
pid: CF1520D
tag: []
---

# Same Differences

## 题目描述

You are given an array $ a $ of $ n $ integers. Count the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_j - a_i = j - i $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ). Then $ t $ test cases follow.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ).

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le n $ ) — array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case output the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_j - a_i = j - i $ .

## 样例 #1

### 输入

```
4
6
3 5 1 4 6 6
3
1 2 3
4
1 3 3 4
6
1 6 3 4 5 6
```

### 输出

```
1
3
3
10
```



---

---
title: "Arranging The Sheep"
layout: "post"
diff: 普及-
pid: CF1520E
tag: []
---

# Arranging The Sheep

## 题目描述

You are playing the game "Arranging The Sheep". The goal of this game is to make the sheep line up. The level in the game is described by a string of length $ n $ , consisting of the characters '.' (empty space) and '\*' (sheep). In one move, you can move any sheep one square to the left or one square to the right, if the corresponding square exists and is empty. The game ends as soon as the sheep are lined up, that is, there should be no empty cells between any sheep.

For example, if $ n=6 $ and the level is described by the string "\*\*.\*..", then the following game scenario is possible:

- the sheep at the $ 4 $ position moves to the right, the state of the level: "\*\*..\*.";
- the sheep at the $ 2 $ position moves to the right, the state of the level: "\*.\*.\*.";
- the sheep at the $ 1 $ position moves to the right, the state of the level: ".\*\*.\*.";
- the sheep at the $ 3 $ position moves to the right, the state of the level: ".\*.\*\*.";
- the sheep at the $ 2 $ position moves to the right, the state of the level: "..\*\*\*.";
- the sheep are lined up and the game ends.

For a given level, determine the minimum number of moves you need to make to complete the level.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ). Then $ t $ test cases follow.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 10^6 $ ).

The second line of each test case contains a string of length $ n $ , consisting of the characters '.' (empty space) and '\*' (sheep) — the description of the level.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^6 $ .

## 输出格式

For each test case output the minimum number of moves you need to make to complete the level.

## 样例 #1

### 输入

```
5
6
**.*..
5
*****
3
.*.
3
...
10
*.*...*.**
```

### 输出

```
1
0
0
0
9
```



---

---
title: "Guess the K-th Zero (Easy version)"
layout: "post"
diff: 普及-
pid: CF1520F1
tag: []
---

# Guess the K-th Zero (Easy version)

## 题目描述

This is an interactive problem.

This is an easy version of the problem. The difference from the hard version is that in the easy version $ t=1 $ and the number of queries is limited to $ 20 $ .

Polycarp is playing a computer game. In this game, an array consisting of zeros and ones is hidden. Polycarp wins if he guesses the position of the $ k $ -th zero from the left $ t $ times.

Polycarp can make no more than $ 20 $ requests of the following type:

- ? $ l $ $ r $ — find out the sum of all elements in positions from $ l $ to $ r $ ( $ 1 \le l \le r \le n $ ) inclusive.

In this (easy version) of the problem, this paragraph doesn't really make sense since $ t=1 $ always. To make the game more interesting, each guessed zero turns into one and the game continues on the changed array. More formally, if the position of the $ k $ -th zero was $ x $ , then after Polycarp guesses this position, the $ x $ -th element of the array will be replaced from $ 0 $ to $ 1 $ . Of course, this feature affects something only for $ t>1 $ .

Help Polycarp win the game.

## 输出格式

First, your program must read two integers $ n $ and $ t $ ( $ 1 \le n \le 2 \cdot 10^5 $ , $ t=1 $ ).

Then $ t $ lines follow, each of which contains one integer $ k $ ( $ 1 \le k \le n $ ). It is guaranteed that at the moment of the request the array contains at least $ k $ zeros. In order to get the next value of $ k $ , you must output the answer for the current value of $ k $ .

After that, you can make no more than $ 20 $ requests.

Use the following format to output the answer (it is not a request, it doesn't count in $ 20 $ ):

- ! $ x $ — position of the $ k $ -th zero.

Positions in the array are numbered from left to right from $ 1 $ to $ n $ inclusive.

After printing $ t $ answers, your program should exit immediately.

In this task, the interactor is not adaptive. This means that within the same test, the hidden array and the queries do not change.

In case of an incorrect query, -1 will be displayed. When this value is received, your program must immediately exit normally (for example, by calling exit(0)), otherwise, the testing system may issue an arbitrary verdict.

If the number of requests is exceeded, the verdict wrong answer will be displayed.

Your solution may get the verdict Idleness limit exceeded if you don't print anything or forget to flush the output buffer.

To flush the output buffer, you need to do the following immediately after the query output and the end-of-line character:

- fflush(stdout) or cout.flush() in C ++;
- System.out.flush() in Java;
- flush(output) in Pascal;
- stdout.flush() in Python;
- see the documentation for other languages.

Hacks

Use the following format for hacks:

On the first line print the string $ s $ ( $ 1 \le |s| \le 2 \cdot 10^5 $ ), consisting of zeros and ones, and an integer $ t $ ( $ t = 1 $ ) — hidden array and number of requests, respectively. In the next $ t $ lines output the number $ k $ ( $ 1 \le k \le |s| $ ).

The hacked solution will not have direct access to the hidden array.

## 说明/提示

In the first test, the $ [1, 0, 1, 1, 0, 1] $ array is hidden. In this test $ k=2 $ .

## 样例 #1

### 输入

```
6 1
2

2

1

1

0

0
```

### 输出

```
? 4 6

? 1 1

? 1 2

? 2 2

? 5 5

! 5
```



---

---
title: "Nastia and a Good Array"
layout: "post"
diff: 普及-
pid: CF1521B
tag: []
---

# Nastia and a Good Array

## 题目描述

Nastia has received an array of $ n $ positive integers as a gift.

She calls such an array $ a $ good that for all $ i $ ( $ 2 \le i \le n $ ) takes place $ gcd(a_{i - 1}, a_{i}) = 1 $ , where $ gcd(u, v) $ denotes the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $ u $ and $ v $ .

You can perform the operation: select two different indices $ i, j $ ( $ 1 \le i, j \le n $ , $ i \neq j $ ) and two integers $ x, y $ ( $ 1 \le x, y \le 2 \cdot 10^9 $ ) so that $ \min{(a_i, a_j)} = \min{(x, y)} $ . Then change $ a_i $ to $ x $ and $ a_j $ to $ y $ .

The girl asks you to make the array good using at most $ n $ operations.

It can be proven that this is always possible.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10\,000 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of the array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_{n} $ ( $ 1 \le a_i \le 10^9 $ ) — the array which Nastia has received as a gift.

It's guaranteed that the sum of $ n $ in one test doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each of $ t $ test cases print a single integer $ k $ ( $ 0 \le k \le n $ ) — the number of operations. You don't need to minimize this number.

In each of the next $ k $ lines print $ 4 $ integers $ i $ , $ j $ , $ x $ , $ y $ ( $ 1 \le i \neq j \le n $ , $ 1 \le x, y \le 2 \cdot 10^9 $ ) so that $ \min{(a_i, a_j)} = \min{(x, y)} $ — in this manner you replace $ a_i $ with $ x $ and $ a_j $ with $ y $ .

If there are multiple answers, print any.

## 说明/提示

Consider the first test case.

Initially $ a = [9, 6, 3, 11, 15] $ .

In the first operation replace $ a_1 $ with $ 11 $ and $ a_5 $ with $ 9 $ . It's valid, because $ \min{(a_1, a_5)} = \min{(11, 9)} = 9 $ .

After this $ a = [11, 6, 3, 11, 9] $ .

In the second operation replace $ a_2 $ with $ 7 $ and $ a_5 $ with $ 6 $ . It's valid, because $ \min{(a_2, a_5)} = \min{(7, 6)} = 6 $ .

After this $ a = [11, 7, 3, 11, 6] $ — a good array.

In the second test case, the initial array is already good.

## 样例 #1

### 输入

```
2
5
9 6 3 11 15
3
7 5 13
```

### 输出

```
2
1 5 11 9
2 5 7 6
0
```



---

---
title: "Game of Life"
layout: "post"
diff: 普及-
pid: CF1523A
tag: []
---

# Game of Life

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1523A/010268700b5eefe6d637a339a161b9e30121cb66.png)William really likes the cellular automaton called "Game of Life" so he decided to make his own version. For simplicity, William decided to define his cellular automaton on an array containing $ n $ cells, with each cell either being alive or dead.

Evolution of the array in William's cellular automaton occurs iteratively in the following way:

- If the element is dead and it has exactly $ 1 $ alive neighbor in the current state of the array, then on the next iteration it will become alive. For an element at index $ i $ the neighbors would be elements with indices $ i - 1 $ and $ i + 1 $ . If there is no element at that index, it is considered to be a dead neighbor.
- William is a humane person so all alive elements stay alive.

Check the note section for examples of the evolution.

You are given some initial state of all elements and you need to help William find the state of the array after $ m $ iterations of evolution.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^3 $ ). Description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 2 \le n \le 10^3, 1 \le m \le 10^9 $ ), which are the total number of cells in the array and the number of iterations.

The second line of each test case contains a string of length $ n $ made up of characters "0" and "1" and defines the initial state of the array. "1" means a cell is alive and "0" means it is dead.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^4 $ .

## 输出格式

In each test case output a string of length $ n $ , made up of characters "0" and "1" — the state of the array after $ m $ iterations of evolution.

## 说明/提示

Sequence of iterations of evolution for the first test case

- 01000000001 — initial state
- 11100000011 — first iteration of evolution
- 11110000111 — second iteration of evolution
- 11111001111 — third iteration of evolution

Sequence of iterations of evolution for the second test case

- 0110100101 — initial state
- 1110111101 — first iteration of evolution
- 1110111101 — second iteration of evolution

## 样例 #1

### 输入

```
4
11 3
01000000001
10 2
0110100101
5 2
10101
3 100
000
```

### 输出

```
11111001111
1110111101
10101
000
```



---

---
title: "Permutation Sort"
layout: "post"
diff: 普及-
pid: CF1525B
tag: []
---

# Permutation Sort

## 题目描述

You are given a permutation $ a $ consisting of $ n $ numbers $ 1 $ , $ 2 $ , ..., $ n $ (a permutation is an array in which each element from $ 1 $ to $ n $ occurs exactly once).

You can perform the following operation: choose some subarray (contiguous subsegment) of $ a $ and rearrange the elements in it in any way you want. But this operation cannot be applied to the whole array.

For example, if $ a = [2, 1, 4, 5, 3] $ and we want to apply the operation to the subarray $ a[2, 4] $ (the subarray containing all elements from the $ 2 $ -nd to the $ 4 $ -th), then after the operation, the array can become $ a = [2, 5, 1, 4, 3] $ or, for example, $ a = [2, 1, 5, 4, 3] $ .

Your task is to calculate the minimum number of operations described above to sort the permutation $ a $ in ascending order.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 2000 $ ) — the number of test cases.

The first line of the test case contains a single integer $ n $ ( $ 3 \le n \le 50 $ ) — the number of elements in the permutation.

The second line of the test case contains $ n $ distinct integers from $ 1 $ to $ n $ — the given permutation $ a $ .

## 输出格式

For each test case, output a single integer — the minimum number of operations described above to sort the array $ a $ in ascending order.

## 说明/提示

In the explanations, $ a[i, j] $ defines the subarray of $ a $ that starts from the $ i $ -th element and ends with the $ j $ -th element.

In the first test case of the example, you can select the subarray $ a[2, 3] $ and swap the elements in it.

In the second test case of the example, the permutation is already sorted, so you don't need to apply any operations.

In the third test case of the example, you can select the subarray $ a[3, 5] $ and reorder the elements in it so $ a $ becomes $ [2, 1, 3, 4, 5] $ , and then select the subarray $ a[1, 2] $ and swap the elements in it, so $ a $ becomes $ [1, 2, 3, 4, 5] $ .

## 样例 #1

### 输入

```
3
4
1 3 2 4
3
1 2 3
5
2 1 4 5 3
```

### 输出

```
1
0
2
```



---

---
title: "And Then There Were K"
layout: "post"
diff: 普及-
pid: CF1527A
tag: []
---

# And Then There Were K

## 题目描述

给定一个正整数 $n$，请你求出一个最大的正整数 $k$，满足 $n \& (n-1)\&(n-2)\&...\&(k)$ 的值为 0。（这里的 $\&$ 指的是按位与操作，即 ` C++` 语言里的 `&` 运算符）

## 输入格式

第一行是一个正整数 $t$（$1\le t\le 3 \times 10^4$），表示数据的组数。

接下来 $t$ 行，每行一个正整数 $n$（$1\le n\le 10^9$）。

## 输出格式

$t$ 行，对于每组数据，输出一个正整数 $k$。

## 样例 #1

### 输入

```
3
2
5
17
```

### 输出

```
1
3
15
```



---

---
title: "Sifid and Strange Subsequences"
layout: "post"
diff: 普及-
pid: CF1529B
tag: []
---

# Sifid and Strange Subsequences

## 题目描述

A sequence $ (b_1, b_2, \ldots, b_k) $ is called strange, if the absolute difference between any pair of its elements is greater than or equal to the maximum element in the sequence. Formally speaking, it's strange if for every pair $ (i, j) $ with $ 1 \le i<j \le k $ , we have $ |a_i-a_j|\geq MAX $ , where $ MAX $ is the largest element of the sequence. In particular, any sequence of length at most $ 1 $ is strange.

For example, the sequences $ (-2021, -1, -1, -1) $ and $ (-1, 0, 1) $ are strange, but $ (3, 0, 1) $ is not, because $ |0 - 1| < 3 $ .

Sifid has an array $ a $ of $ n $ integers. Sifid likes everything big, so among all the strange subsequences of $ a $ , he wants to find the length of the longest one. Can you help him?

A sequence $ c $ is a subsequence of an array $ d $ if $ c $ can be obtained from $ d $ by deletion of several (possibly, zero or all) elements.

## 输入格式

The first line contains an integer $ t $ $ (1\le t\le 10^4) $ — the number of test cases. The description of the test cases follows.

The first line of each test case contains an integer $ n $ $ (1\le n\le 10^5) $ — the length of the array $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ $ (-10^9\le a_i \le 10^9) $ — the elements of the array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case output a single integer — the length of the longest strange subsequence of $ a $ .

## 说明/提示

In the first test case, one of the longest strange subsequences is $ (a_1, a_2, a_3, a_4) $

In the second test case, one of the longest strange subsequences is $ (a_1, a_3, a_4, a_5, a_7) $ .

In the third test case, one of the longest strange subsequences is $ (a_1, a_3, a_4, a_5) $ .

In the fourth test case, one of the longest strange subsequences is $ (a_2) $ .

In the fifth test case, one of the longest strange subsequences is $ (a_1, a_2, a_4) $ .

## 样例 #1

### 输入

```
6
4
-1 -2 0 0
7
-3 4 -2 0 -4 6 1
5
0 5 -3 2 -5
3
2 3 1
4
-3 0 2 0
6
-3 -2 -1 1 1 1
```

### 输出

```
4
5
4
1
3
4
```



---

---
title: "Putting Plates"
layout: "post"
diff: 普及-
pid: CF1530B
tag: []
---

# Putting Plates

## 题目描述

有一张桌子，分为 $h$ 行 $w$ 列。

桌子**边缘**上的某一行某一列可以放一个盘子（也可以不放）。但是，一个盘子的上面、下面、左面、右面、左上、右上、左下、右下都不能有盘子。

问题来了：这个桌子，放盘子最多的方案是什么？请输出这个方案。当然，答案不止一种，你也不用全部输出，输出任意一个，即可。

## 输入格式

第一行一个数 $t$（$1\le t\le100$），表示测试数据组数。

接下来 $t$ 行，每行两个数，分别代表 $h$ 和 $w$（$3\le h,w\le20$）。

## 输出格式

输出这个桌子放盘子最多的方案。盘子用 `1` 表示，空位用 `0` 表示。

每个测试数据之间都要打印一个空行。

Translated by [dengzijun](https://www.luogu.com.cn/user/387836)

## 样例 #1

### 输入

```
3
3 5
4 4
5 6
```

### 输出

```
10101
00000
10101

0100
0001
1000
0010

010101
000000
100001
000000
101010
```



---

---
title: "Colour the Flag"
layout: "post"
diff: 普及-
pid: CF1534A
tag: []
---

# Colour the Flag

## 题目描述

Today we will be playing a red and white colouring game (no, this is not the Russian Civil War; these are just the colours of the Canadian flag).

You are given an $ n \times m $ grid of "R", "W", and "." characters. "R" is red, "W" is white and "." is blank. The neighbours of a cell are those that share an edge with it (those that only share a corner do not count).

Your job is to colour the blank cells red or white so that every red cell only has white neighbours (and no red ones) and every white cell only has red neighbours (and no white ones). You are not allowed to recolour already coloured cells.

## 输入格式

The first line contains $ t $ ( $ 1 \le t \le 100 $ ), the number of test cases.

In each test case, the first line will contain $ n $ ( $ 1 \le n \le 50 $ ) and $ m $ ( $ 1 \le m \le 50 $ ), the height and width of the grid respectively.

The next $ n $ lines will contain the grid. Each character of the grid is either 'R', 'W', or '.'.

## 输出格式

For each test case, output "YES" if there is a valid grid or "NO" if there is not.

If there is, output the grid on the next $ n $ lines. If there are multiple answers, print any.

In the output, the "YES"s and "NO"s are case-insensitive, meaning that outputs such as "yEs" and "nO" are valid. However, the grid is case-sensitive.

## 说明/提示

The answer for the first example case is given in the example output, and it can be proven that no grid exists that satisfies the requirements of the second example case. In the third example all cells are initially coloured, and the colouring is valid.

## 样例 #1

### 输入

```
3
4 6
.R....
......
......
.W....
4 4
.R.W
....
....
....
5 1
R
W
R
W
R
```

### 输出

```
YES
WRWRWR
RWRWRW
WRWRWR
RWRWRW
NO
YES
R
W
R
W
R
```



---

---
title: "Prinzessin der Verurteilung"
layout: "post"
diff: 普及-
pid: CF1536B
tag: []
---

# Prinzessin der Verurteilung

## 题目描述

定义一个字符串的 $MEX$ 为**在输入中不作为连续子字符串出现的最短字符串**。

如果有长度相同的 $MEX$，则取字典序最小的。

## 输入格式

第一行输入一个整数 $T$，表示测试组数。

接下来每一组第一行一个整数 $n$，表示该字符串的长度，第二行一个长度为 $n$ 的字符串。

## 输出格式

输出 $T$ 行，每一行对应一组输入数据的 $MEX$。

## 样例 #1

### 输入

```
3
28
qaabzwsxedcrfvtgbyhnujmiklop
13
cleanairactbd
10
aannttoonn
```

### 输出

```
ac
f
b
```



---

---
title: "Contest Start"
layout: "post"
diff: 普及-
pid: CF1539A
tag: []
---

# Contest Start

## 题目描述

### 题意描述

有 $n$ 个人参加某个竞赛，他们以 $x$ 分钟的间隔开始。

每个参赛者的比赛时长为 $t$ 分钟，因此第一个参赛者在 $t$ 时间结束比赛，第二个参赛者在 $t+x$ 时间结束比赛，依此类推。当一个参赛者完成比赛时，他们的不满意程度等于已开始比赛（或现在正好开始）但还没有完成比赛的参赛者人数。

求所有参赛者的不满意程度之和。

## 输入格式

第一行包含一个整数 $k$ ( $1\leq k\leq 1000$)，表示数据组数。

接下来的每一行包含三个整数 $ n,x,t$ ( $1\leq n,x,t\leq 2⋅10^9$)，分别为参与者的数量，开始时间间隔和比赛时长。

## 输出格式

一共 $k$ 行，在第 $i$ 行中输出第 $i$ 组数据中参与者的不满意程度之和。

## 样例 #1

### 输入

```
4
4 2 5
3 1 2
3 3 10
2000000000 1 2000000000
```

### 输出

```
5
3
3
1999999999000000000
```



---

---
title: "Caesar Cipher"
layout: "post"
diff: 普及-
pid: CF153C
tag: []
---

# Caesar Cipher

## 题目描述

输入一个由大写字母构成的字符串 $s$ ,求 $s$ 的每一个字母往后移 $k$ 位的结果。当字母移动后超出 $\texttt{Z}$ 时，回到字母表的开头  $\texttt{A}$ 继续移动。

## 输入格式

第一行一个字符串 $s$ （长度在 $1$ 到 $10$ 之间）。

第二行一个整数 $k\ (0 \le k \le 25)$。

## 输出格式

一行一个字符串，表示 $s$ 的每一个字母往后移 $k$ 位的结果。

## 样例 #1

### 输入

```
CODEFORCES
5

```

### 输出

```
HTIJKTWHJX

```

## 样例 #2

### 输入

```
WIXYZILWYM
6

```

### 输出

```
CODEFORCES

```



---

---
title: "Pleasant Pairs"
layout: "post"
diff: 普及-
pid: CF1541B
tag: []
---

# Pleasant Pairs

## 题目描述

You are given an array $ a_1, a_2, \dots, a_n $ consisting of $ n $ distinct integers. Count the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i \cdot a_j = i + j $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. Then $ t $ cases follow.

The first line of each test case contains one integer $ n $ ( $ 2 \leq n \leq 10^5 $ ) — the length of array $ a $ .

The second line of each test case contains $ n $ space separated integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 2 \cdot n $ ) — the array $ a $ . It is guaranteed that all elements are distinct.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i \cdot a_j = i + j $ .

## 说明/提示

For the first test case, the only pair that satisfies the constraints is $ (1, 2) $ , as $ a_1 \cdot a_2 = 1 + 2 = 3 $

For the second test case, the only pair that satisfies the constraints is $ (2, 3) $ .

For the third test case, the pairs that satisfy the constraints are $ (1, 2) $ , $ (1, 5) $ , and $ (2, 3) $ .

## 样例 #1

### 输入

```
3
2
3 1
3
6 1 5
5
3 1 5 9 2
```

### 输出

```
1
1
3
```



---

---
title: "AquaMoon and Two Arrays"
layout: "post"
diff: 普及-
pid: CF1546A
tag: []
---

# AquaMoon and Two Arrays

## 题目描述

AquaMoon and Cirno are playing an interesting game with arrays. Cirno has prepared two arrays $ a $ and $ b $ , both consist of $ n $ non-negative integers. AquaMoon can perform the following operation an arbitrary number of times (possibly zero):

- She chooses two indices $ i $ and $ j $ ( $ 1 \le i, j \le n $ ), then decreases the $ i $ -th element of array $ a $ by $ 1 $ , and increases the $ j $ -th element of array $ a $ by $ 1 $ . The resulting values at $ i $ -th and $ j $ -th index of array $ a $ are $ a_i - 1 $ and $ a_j + 1 $ , respectively. Each element of array $ a $ must be non-negative after each operation. If $ i = j $ this operation doesn't change the array $ a $ .

AquaMoon wants to make some operations to make arrays $ a $ and $ b $ equal. Two arrays $ a $ and $ b $ are considered equal if and only if $ a_i = b_i $ for all $ 1 \leq i \leq n $ .

Help AquaMoon to find a sequence of operations that will solve her problem or find, that it is impossible to make arrays $ a $ and $ b $ equal.

Please note, that you don't have to minimize the number of operations.

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 100 $ ).

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 0 \leq a_i \leq 100 $ ). The sum of all $ a_i $ does not exceed $ 100 $ .

The third line of each test case contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ 0 \leq b_i \leq 100 $ ). The sum of all $ b_i $ does not exceed $ 100 $ .

## 输出格式

For each test case print "-1" on the only line if it is impossible to make two arrays equal with some sequence of operations.

Otherwise, print an integer $ m $ ( $ 0 \leq m \leq 100 $ ) in the first line — the number of operations. Then print $ m $ lines, each line consists of two integers $ i $ and $ j $ — the indices you choose for the operation.

It can be proven that if it is possible to make two arrays equal with some sequence of operations, there exists a sequence with $ m \leq 100 $ .

If there are multiple possible solutions, you can print any.

## 说明/提示

In the first example, we do the following operations:

- $ i = 2 $ , $ j = 1 $ : $ [1, 2, 3, 4] \rightarrow [2, 1, 3, 4] $ ;
- $ i = 3 $ , $ j = 1 $ : $ [2, 1, 3, 4] \rightarrow [3, 1, 2, 4] $ ;

In the second example, it's impossible to make two arrays equal.

## 样例 #1

### 输入

```
4
4
1 2 3 4
3 1 2 4
2
1 3
2 1
1
0
0
5
4 3 2 1 0
0 1 2 3 4
```

### 输出

```
2
2 1
3 1
-1
0
6
1 4
1 4
1 5
1 5
2 5
2 5
```



---

---
title: "Gregor and the Pawn Game"
layout: "post"
diff: 普及-
pid: CF1549B
tag: []
---

# Gregor and the Pawn Game

## 题目描述

There is a chessboard of size $ n $ by $ n $ . The square in the $ i $ -th row from top and $ j $ -th column from the left is labelled $ (i,j) $ .

Currently, Gregor has some pawns in the $ n $ -th row. There are also enemy pawns in the $ 1 $ -st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from $ (i,j) $ to $ (i-1,j) $ ) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from $ (i,j) $ to either $ (i-1,j-1) $ or $ (i-1,j+1) $ ) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.

Gregor wants to know what is the maximum number of his pawns that can reach row $ 1 $ ?

Note that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row $ 1 $ , it is stuck and cannot make any further moves.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1\le t\le 2\cdot 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

Each test case consists of three lines. The first line contains a single integer $ n $ ( $ 2\le n\le 2\cdot{10}^{5} $ ) — the size of the chessboard.

The second line consists of a string of binary digits of length $ n $ , where a $ 1 $ in the $ i $ -th position corresponds to an enemy pawn in the $ i $ -th cell from the left, and $ 0 $ corresponds to an empty cell.

The third line consists of a string of binary digits of length $ n $ , where a $ 1 $ in the $ i $ -th position corresponds to a Gregor's pawn in the $ i $ -th cell from the left, and $ 0 $ corresponds to an empty cell.

It is guaranteed that the sum of $ n $ across all test cases is less than $ 2\cdot{10}^{5} $ .

## 输出格式

For each test case, print one integer: the maximum number of Gregor's pawns which can reach the $ 1 $ -st row.

## 说明/提示

In the first example, Gregor can simply advance all $ 3 $ of his pawns forward. Thus, the answer is $ 3 $ .

In the second example, Gregor can guarantee that all $ 4 $ of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this "game"!

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1549B/eb2df5f00e8c7d1290d3251e314fd1200ad28d29.png)In the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.

In the fourth example, Gregor has no pawns, so the answer is clearly $ 0 $ .

## 样例 #1

### 输入

```
4
3
000
111
4
1111
1111
3
010
010
5
11001
00000
```

### 输出

```
3
4
0
0
```



---

---
title: "Find The Array"
layout: "post"
diff: 普及-
pid: CF1550A
tag: []
---

# Find The Array

## 题目描述

Let's call an array $ a $ consisting of $ n $ positive (greater than $ 0 $ ) integers beautiful if the following condition is held for every $ i $ from $ 1 $ to $ n $ : either $ a_i = 1 $ , or at least one of the numbers $ a_i - 1 $ and $ a_i - 2 $ exists in the array as well.

For example:

- the array $ [5, 3, 1] $ is beautiful: for $ a_1 $ , the number $ a_1 - 2 = 3 $ exists in the array; for $ a_2 $ , the number $ a_2 - 2 = 1 $ exists in the array; for $ a_3 $ , the condition $ a_3 = 1 $ holds;
- the array $ [1, 2, 2, 2, 2] $ is beautiful: for $ a_1 $ , the condition $ a_1 = 1 $ holds; for every other number $ a_i $ , the number $ a_i - 1 = 1 $ exists in the array;
- the array $ [1, 4] $ is not beautiful: for $ a_2 $ , neither $ a_2 - 2 = 2 $ nor $ a_2 - 1 = 3 $ exists in the array, and $ a_2 \ne 1 $ ;
- the array $ [2] $ is not beautiful: for $ a_1 $ , neither $ a_1 - 1 = 1 $ nor $ a_1 - 2 = 0 $ exists in the array, and $ a_1 \ne 1 $ ;
- the array $ [2, 1, 3] $ is beautiful: for $ a_1 $ , the number $ a_1 - 1 = 1 $ exists in the array; for $ a_2 $ , the condition $ a_2 = 1 $ holds; for $ a_3 $ , the number $ a_3 - 2 = 1 $ exists in the array.

You are given a positive integer $ s $ . Find the minimum possible size of a beautiful array with the sum of elements equal to $ s $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 5000 $ ) — the number of test cases.

Then $ t $ lines follow, the $ i $ -th line contains one integer $ s $ ( $ 1 \le s \le 5000 $ ) for the $ i $ -th test case.

## 输出格式

Print $ t $ integers, the $ i $ -th integer should be the answer for the $ i $ -th testcase: the minimum possible size of a beautiful array with the sum of elements equal to $ s $ .

## 说明/提示

Consider the example test:

1. in the first test case, the array $ [1] $ meets all conditions;
2. in the second test case, the array $ [3, 4, 1] $ meets all conditions;
3. in the third test case, the array $ [1, 2, 4] $ meets all conditions;
4. in the fourth test case, the array $ [1, 4, 6, 8, 10, 2, 11] $ meets all conditions.

## 样例 #1

### 输入

```
4
1
8
7
42
```

### 输出

```
1
3
3
7
```



---

---
title: "Maximum Cost Deletion"
layout: "post"
diff: 普及-
pid: CF1550B
tag: []
---

# Maximum Cost Deletion

## 题目描述

You are given a string $ s $ of length $ n $ consisting only of the characters 0 and 1.

You perform the following operation until the string becomes empty: choose some consecutive substring of equal characters, erase it from the string and glue the remaining two parts together (any of them can be empty) in the same order. For example, if you erase the substring 111 from the string 111110, you will get the string 110. When you delete a substring of length $ l $ , you get $ a \cdot l + b $ points.

Your task is to calculate the maximum number of points that you can score in total, if you have to make the given string empty.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 2000 $ ) — the number of testcases.

The first line of each testcase contains three integers $ n $ , $ a $ and $ b $ ( $ 1 \le n \le 100; -100 \le a, b \le 100 $ ) — the length of the string $ s $ and the parameters $ a $ and $ b $ .

The second line contains the string $ s $ . The string $ s $ consists only of the characters 0 and 1.

## 输出格式

For each testcase, print a single integer — the maximum number of points that you can score.

## 说明/提示

In the first example, it is enough to delete the entire string, then we will get $ 2 \cdot 3 + 0 = 6 $ points.

In the second example, if we delete characters one by one, then for each deleted character we will get $ (-2) \cdot 1 + 5 = 3 $ points, i. e. $ 15 $ points in total.

In the third example, we can delete the substring 00 from the string 100111, we get $ 1 \cdot 2 + (-4) = -2 $ points, and the string will be equal to 1111, removing it entirely we get $ 1 \cdot 4 + (-4) = 0 $ points. In total, we got $ -2 $ points for $ 2 $ operations.

## 样例 #1

### 输入

```
3
3 2 0
000
5 -2 5
11001
6 1 -4
100111
```

### 输出

```
6
15
-2
```



---

---
title: "Wonderful Coloring - 1"
layout: "post"
diff: 普及-
pid: CF1551B1
tag: []
---

# Wonderful Coloring - 1

## 题目描述

This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.

Paul and Mary have a favorite string $ s $ which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:

1. each letter of the string is either painted in exactly one color (red or green) or isn't painted;
2. each two letters which are painted in the same color are different;
3. the number of letters painted in red is equal to the number of letters painted in green;
4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions.

E. g. consider a string $ s $ equal to "kzaaa". One of the wonderful colorings of the string is shown in the figure.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1551B1/c8856daa04b74978f65da846cae3db3aad690b80.png)The example of a wonderful coloring of the string "kzaaa".Paul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find $ k $ — the number of red (or green, these numbers are equal) letters in a wonderful coloring.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Then $ t $ test cases follow.

Each test case consists of one non-empty string $ s $ which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed $ 50 $ .

## 输出格式

For each test case, output a separate line containing one non-negative integer $ k $ — the number of letters which will be painted in red in a wonderful coloring.

## 说明/提示

The first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing $ 3 $ or more red letters because the total number of painted symbols will exceed the string's length.

The string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters "c", "o", "e" in red and the second ones in green. Let's paint the letters "d", "f" in red and "r", "s" in green. So every letter will be painted in red or green, hence the answer better than $ 5 $ doesn't exist.

The third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.

The fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.

The fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red.

## 样例 #1

### 输入

```
5
kzaaa
codeforces
archive
y
xxxxxx
```

### 输出

```
2
5
3
0
1
```



---

---
title: "Subsequence Permutation"
layout: "post"
diff: 普及-
pid: CF1552A
tag: []
---

# Subsequence Permutation

## 题目描述

A string $ s $ of length $ n $ , consisting of lowercase letters of the English alphabet, is given.

You must choose some number $ k $ between $ 0 $ and $ n $ . Then, you select $ k $ characters of $ s $ and permute them however you want. In this process, the positions of the other $ n-k $ characters remain unchanged. You have to perform this operation exactly once.

For example, if $ s=\texttt{"andrea"} $ , you can choose the $ k=4 $ characters $ \texttt{"a_d_ea"} $ and permute them into $ \texttt{"d_e_aa"} $ so that after the operation the string becomes $ \texttt{"dneraa"} $ .

Determine the minimum $ k $ so that it is possible to sort $ s $ alphabetically (that is, after the operation its characters appear in alphabetical order).

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 40 $ ) — the length of the string.

The second line of each test case contains the string $ s $ . It is guaranteed that $ s $ contains only lowercase letters of the English alphabet.

## 输出格式

For each test case, output the minimum $ k $ that allows you to obtain a string sorted alphabetically, through the operation described above.

## 说明/提示

In the first test case, we can choose the $ k=2 $ characters $ \texttt{"_ol"} $ and rearrange them as $ \texttt{"_lo"} $ (so the resulting string is $ \texttt{"llo"} $ ). It is not possible to sort the string choosing strictly less than $ 2 $ characters.

In the second test case, one possible way to sort $ s $ is to consider the $ k=6 $ characters $ \texttt{"_o__force_"} $ and rearrange them as $ \texttt{"_c__efoor_"} $ (so the resulting string is $ \texttt{"ccdeefoors"} $ ). One can show that it is not possible to sort the string choosing strictly less than $ 6 $ characters.

In the third test case, string $ s $ is already sorted (so we can choose $ k=0 $ characters).

In the fourth test case, we can choose all $ k=4 $ characters $ \texttt{"dcba"} $ and reverse the whole string (so the resulting string is $ \texttt{"abcd"} $ ).

## 样例 #1

### 输入

```
4
3
lol
10
codeforces
5
aaaaa
4
dcba
```

### 输出

```
2
6
0
4
```



---

---
title: "Reverse String"
layout: "post"
diff: 普及-
pid: CF1553B
tag: []
---

# Reverse String

## 题目描述

You have a string $ s $ and a chip, which you can place onto any character of this string.

After placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is $ i $ , you move it to the position $ i + 1 $ . Of course, moving the chip to the right is impossible if it is already in the last position.

After moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is $ i $ , you move it to the position $ i - 1 $ . Of course, moving the chip to the left is impossible if it is already in the first position.

When you place a chip or move it, you write down the character where the chip ends up after your action. For example, if $ s $ is abcdef, you place the chip onto the $ 3 $ -rd character, move it to the right $ 2 $ times and then move it to the left $ 3 $ times, you write down the string cdedcb.

You are given two strings $ s $ and $ t $ . Your task is to determine whether it's possible to perform the described operations with $ s $ so that you write down the string $ t $ as a result.

## 输入格式

The first line contains one integer $ q $ ( $ 1 \le q \le 500 $ ) — the number of test cases.

Each test case consists of two lines. The first line contains the string $ s $ ( $ 1 \le |s| \le 500 $ ), the second line contains the string $ t $ ( $ 1 \le |t| \le 2 \cdot |s| - 1 $ ). Both strings consist of lowercase English characters.

It is guaranteed that the sum of $ |s| $ over all test cases does not exceed $ 500 $ .

## 输出格式

For each test case, print "YES" if you can obtain the string $ t $ by performing the process mentioned in the statement with the string $ s $ , or "NO" if you cannot.

You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).

## 说明/提示

Consider the examples.

The first test case is described in the statement.

In the second test case, you can place the chip on the $ 1 $ -st position, move it twice to the right, and then move it twice to the left.

In the fourth test case, you can place the chip on the $ 2 $ -nd position, and then don't move it at all.

In the fifth test case, you can place the chip on the $ 1 $ -st position, move it $ 5 $ times to the right, and then finish the process.

## 样例 #1

### 输入

```
6
abcdef
cdedcb
aaa
aaaaa
aab
baaa
ab
b
abcdef
abcdef
ba
baa
```

### 输出

```
YES
YES
NO
YES
YES
NO
```



---

---
title: "Penalty"
layout: "post"
diff: 普及-
pid: CF1553C
tag: []
---

# Penalty

## 题目描述

Consider a simplified penalty phase at the end of a football match.

A penalty phase consists of at most $ 10 $ kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the $ 7 $ -th kick the first team has scored $ 1 $ goal, and the second team has scored $ 3 $ goals, the penalty phase ends — the first team cannot reach $ 3 $ goals.

You know which player will be taking each kick, so you have your predictions for each of the $ 10 $ kicks. These predictions are represented by a string $ s $ consisting of $ 10 $ characters. Each character can either be 1, 0, or ?. This string represents your predictions in the following way:

- if $ s_i $ is 1, then the $ i $ -th kick will definitely score a goal;
- if $ s_i $ is 0, then the $ i $ -th kick definitely won't score a goal;
- if $ s_i $ is ?, then the $ i $ -th kick could go either way.

Based on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase — you may know that some kick will/won't be scored, but the referee doesn't.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1\,000 $ ) — the number of test cases.

Each test case is represented by one line containing the string $ s $ , consisting of exactly $ 10 $ characters. Each character is either 1, 0, or ?.

## 输出格式

For each test case, print one integer — the minimum possible number of kicks in the penalty phase.

## 说明/提示

Consider the example test:

In the first test case, consider the situation when the $ 1 $ -st, $ 5 $ -th and $ 7 $ -th kicks score goals, and kicks $ 2 $ , $ 3 $ , $ 4 $ and $ 6 $ are unsuccessful. Then the current number of goals for the first team is $ 3 $ , for the second team is $ 0 $ , and the referee sees that the second team can score at most $ 2 $ goals in the remaining kicks. So the penalty phase can be stopped after the $ 7 $ -th kick.

In the second test case, the penalty phase won't be stopped until all $ 10 $ kicks are finished.

In the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the $ 6 $ -th kick, the first team has scored $ 0 $ goals and the second team has scored $ 3 $ goals, and the referee sees that the first team can score at most $ 2 $ goals in the remaining kicks. So, the penalty phase can be stopped after the $ 6 $ -th kick.

In the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the $ 9 $ -th kick.

## 样例 #1

### 输入

```
4
1?0???1001
1111111111
??????????
0100000000
```

### 输出

```
7
10
6
9
```



---

---
title: "Cherry"
layout: "post"
diff: 普及-
pid: CF1554A
tag: []
---

# Cherry

## 题目描述

You are given $ n $ integers $ a_1, a_2, \ldots, a_n $ . Find the maximum value of $ max(a_l, a_{l + 1}, \ldots, a_r) \cdot min(a_l, a_{l + 1}, \ldots, a_r) $ over all pairs $ (l, r) $ of integers for which $ 1 \le l < r \le n $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10\,000 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^5 $ ).

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^6 $ ).

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 3 \cdot 10^5 $ .

## 输出格式

For each test case, print a single integer — the maximum possible value of the product from the statement.

## 说明/提示

Let $ f(l, r) = max(a_l, a_{l + 1}, \ldots, a_r) \cdot min(a_l, a_{l + 1}, \ldots, a_r) $ .

In the first test case,

- $ f(1, 2) = max(a_1, a_2) \cdot min(a_1, a_2) = max(2, 4) \cdot min(2, 4) = 4 \cdot 2 = 8 $ .
- $ f(1, 3) = max(a_1, a_2, a_3) \cdot min(a_1, a_2, a_3) = max(2, 4, 3) \cdot min(2, 4, 3) = 4 \cdot 2 = 8 $ .
- $ f(2, 3) = max(a_2, a_3) \cdot min(a_2, a_3) = max(4, 3) \cdot min(4, 3) = 4 \cdot 3 = 12 $ .

So the maximum is $ f(2, 3) = 12 $ .

In the second test case, the maximum is $ f(1, 2) = f(1, 3) = f(2, 3) = 6 $ .

## 样例 #1

### 输入

```
4
3
2 4 3
4
3 2 3 1
2
69 69
6
719313 273225 402638 473783 804745 323328
```

### 输出

```
12
6
4761
381274500335
```



---

---
title: "Two Tables"
layout: "post"
diff: 普及-
pid: CF1555B
tag: []
---

# Two Tables

## 题目描述

You have an axis-aligned rectangle room with width $ W $ and height $ H $ , so the lower left corner is in point $ (0, 0) $ and the upper right corner is in $ (W, H) $ .

There is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in $ (x_1, y_1) $ , and the upper right corner in $ (x_2, y_2) $ .

You want to place another rectangular table in this room with width $ w $ and height $ h $ with the width of the table parallel to the width of the room.

The problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).

You can't rotate any of the tables, but you can move the first table inside the room.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1555B/148c3af8c708a59f4665d57c0e4342daba4e07ae.png)Example of how you may move the first table.What is the minimum distance you should move the first table to free enough space for the second one?

## 输入格式

The first line contains the single integer $ t $ ( $ 1 \le t \le 5000 $ ) — the number of the test cases.

The first line of each test case contains two integers $ W $ and $ H $ ( $ 1 \le W, H \le 10^8 $ ) — the width and the height of the room.

The second line contains four integers $ x_1 $ , $ y_1 $ , $ x_2 $ and $ y_2 $ ( $ 0 \le x_1 < x_2 \le W $ ; $ 0 \le y_1 < y_2 \le H $ ) — the coordinates of the corners of the first table.

The third line contains two integers $ w $ and $ h $ ( $ 1 \le w \le W $ ; $ 1 \le h \le H $ ) — the width and the height of the second table.

## 输出格式

For each test case, print the minimum distance you should move the first table, or $ -1 $ if there is no way to free enough space for the second table.

Your answer will be considered correct if its absolute or relative error doesn't exceed $ 10^{-6} $ .

## 说明/提示

The configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by $ (0, -1) $ , so the lower left corner will move from $ (2, 1) $ to $ (2, 0) $ . Then you can place the second table at $ (0, 3)-(4, 5) $ .

In the second test case, there is no way to fit both tables in the room without intersecting.

In the third test case, you can move the first table by $ (0, 2) $ , so the lower left corner will move from $ (0, 3) $ to $ (0, 5) $ .

## 样例 #1

### 输入

```
5
8 5
2 1 7 4
4 2
5 4
2 2 5 4
3 3
1 8
0 3 1 6
1 5
8 1
3 0 6 1
5 1
8 10
4 5 7 8
8 5
```

### 输出

```
1.000000000
-1
2.000000000
2.000000000
0.000000000
```



---

---
title: "A Variety of Operations"
layout: "post"
diff: 普及-
pid: CF1556A
tag: []
---

# A Variety of Operations

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1556A/5428dff7add309271d42dab51ff349469f968da9.png)William has two numbers $ a $ and $ b $ initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer $ k $ is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer $ k $ )

1. add number $ k $ to both $ a $ and $ b $ , or
2. add number $ k $ to $ a $ and subtract $ k $ from $ b $ , or
3. add number $ k $ to $ b $ and subtract $ k $ from $ a $ .

Note that after performing operations, numbers $ a $ and $ b $ may become negative as well.

William wants to find out the minimal number of operations he would have to perform to make $ a $ equal to his favorite number $ c $ and $ b $ equal to his second favorite number $ d $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). Description of the test cases follows.

The only line of each test case contains two integers $ c $ and $ d $ $ (0 \le c, d \le 10^9) $ , which are William's favorite numbers and which he wants $ a $ and $ b $ to be transformed into.

## 输出格式

For each test case output a single number, which is the minimal number of operations which William would have to perform to make $ a $ equal to $ c $ and $ b $ equal to $ d $ , or $ -1 $ if it is impossible to achieve this using the described operations.

## 说明/提示

Let us demonstrate one of the suboptimal ways of getting a pair $ (3, 5) $ :

- Using an operation of the first type with $ k=1 $ , the current pair would be equal to $ (1, 1) $ .
- Using an operation of the third type with $ k=8 $ , the current pair would be equal to $ (-7, 9) $ .
- Using an operation of the second type with $ k=7 $ , the current pair would be equal to $ (0, 2) $ .
- Using an operation of the first type with $ k=3 $ , the current pair would be equal to $ (3, 5) $ .

## 样例 #1

### 输入

```
6
1 2
3 5
5 3
6 6
8 0
0 0
```

### 输出

```
-1
2
2
1
2
0
```



---

---
title: "Take Your Places!"
layout: "post"
diff: 普及-
pid: CF1556B
tag: []
---

# Take Your Places!

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1556B/1e01fe272756235c22745e77349edf5747f912ab.png)William has an array of $ n $ integers $ a_1, a_2, \dots, a_n $ . In one move he can swap two neighboring items. Two items $ a_i $ and $ a_j $ are considered neighboring if the condition $ |i - j| = 1 $ is satisfied.

William wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). Description of the test cases follows.

The first line of each test case contains an integer $ n $ $ (1 \le n \le 10^5) $ which is the total number of items in William's array.

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ $ (1 \le a_i \le 10^9) $ which are William's array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case output the minimal number of operations needed or $ -1 $ if it is impossible to get the array to a state when no neighboring numbers have the same parity.

## 说明/提示

In the first test case the following sequence of operations would satisfy the requirements:

1. swap(2, 3). Array after performing the operation: $ [6, 1, 6] $

In the second test case the array initially does not contain two neighboring items of the same parity.

In the third test case the following sequence of operations would satisfy the requirements:

1. swap(3, 4). Array after performing the operation: $ [1, 1, 2, 1, 2, 2] $
2. swap(2, 3). Array after performing the operation: $ [1, 2, 1, 1, 2, 2] $
3. swap(4, 5). Array after performing the operation: $ [1, 2, 1, 2, 1, 2] $

In the fourth test case it is impossible to satisfy the requirements.

In the fifth test case the following sequence of operations would satisfy the requirements:

1. swap(2, 3). Array after performing the operation: $ [6, 3, 2, 4, 5, 1] $
2. swap(4, 5). Array after performing the operation: $ [6, 3, 2, 5, 4, 1] $

## 样例 #1

### 输入

```
5
3
6 6 1
1
9
6
1 1 1 2 2 2
2
8 6
6
6 2 3 4 5 1
```

### 输出

```
1
0
3
-1
2
```



---

---
title: "Moamen and k-subarrays"
layout: "post"
diff: 普及-
pid: CF1557B
tag: []
---

# Moamen and k-subarrays

## 题目描述

Moamen has an array of $ n $ distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:

1. Split the array into exactly $ k $ non-empty subarrays such that each element belongs to exactly one subarray.
2. Reorder these subarrays arbitrary.
3. Merge the subarrays in their new order.

A sequence $ a $ is a subarray of a sequence $ b $ if $ a $ can be obtained from $ b $ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Can you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^3 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 10^5 $ ).

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le |a_i| \le 10^9 $ ). It is guaranteed that all numbers are distinct.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 3\cdot10^5 $ .

## 输出格式

For each test case, you should output a single string.

If Moamen can sort the array in non-decreasing order, output "YES" (without quotes). Otherwise, output "NO" (without quotes).

You can print each letter of "YES" and "NO" in any case (upper or lower).

## 说明/提示

In the first test case, $ a = [6, 3, 4, 2, 1] $ , and $ k = 4 $ , so we can do the operations as follows:

1. Split $ a $ into $ \{ [6], [3, 4], [2], [1] \} $ .
2. Reorder them: $ \{ [1], [2], [3,4], [6] \} $ .
3. Merge them: $ [1, 2, 3, 4, 6] $ , so now the array is sorted.

In the second test case, there is no way to sort the array by splitting it into only $ 2 $ subarrays.

As an example, if we split it into $ \{ [1, -4], [0, -2] \} $ , we can reorder them into $ \{ [1, -4], [0, -2] \} $ or $ \{ [0, -2], [1, -4] \} $ . However, after merging the subarrays, it is impossible to get a sorted array.

## 样例 #1

### 输入

```
3
5 4
6 3 4 2 1
4 2
1 -4 0 -2
5 1
1 2 3 4 5
```

### 输出

```
Yes
No
Yes
```



---

---
title: "Mocha and Math"
layout: "post"
diff: 普及-
pid: CF1559A
tag: []
---

# Mocha and Math

## 题目描述

Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.

This day, Mocha got a sequence $ a $ of length $ n $ . In each operation, she can select an arbitrary interval $ [l, r] $ and for all values $ i $ ( $ 0\leq i \leq r-l $ ), replace $ a_{l+i} $ with $ a_{l+i} \,\&\, a_{r-i} $ at the same time, where $ \& $ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.

For example, if $ n=5 $ , the array is $ [a_1,a_2,a_3,a_4,a_5] $ , and Mocha selects the interval $ [2,5] $ , then the new array is $ [a_1,a_2\,\&\, a_5, a_3\,\&\, a_4, a_4\,\&\, a_3, a_5\,\&\, a_2] $ .

Now Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?

## 输入格式

Each test contains multiple test cases.

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Each test case consists of two lines.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the length of the sequence.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 10^9 $ ).

## 输出格式

For each test case, print one integer — the minimal value of the maximum value in the sequence.

## 说明/提示

In the first test case, Mocha can choose the interval $ [1,2] $ , then the sequence becomes $ [ 0, 0] $ , where the first element is $ 1\,\&\,2 $ , and the second element is $ 2\,\&\,1 $ .

In the second test case, Mocha can choose the interval $ [1,3] $ , then the sequence becomes $ [ 1,1,1] $ , where the first element is $ 1\,\&\,3 $ , the second element is $ 1\,\&\,1 $ , and the third element is $ 3\,\&\,1 $ .

## 样例 #1

### 输入

```
4
2
1 2
3
1 1 3
4
3 11 3 7
5
11 7 15 3 7
```

### 输出

```
0
1
3
3
```



---

---
title: "Mocha and Red and Blue"
layout: "post"
diff: 普及-
pid: CF1559B
tag: []
---

# Mocha and Red and Blue

## 题目描述

As their story unravels, a timeless tale is told once again...

Shirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.

There are $ n $ squares arranged in a row, and each of them can be painted either red or blue.

Among these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.

Some pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.

For example, the imperfectness of "BRRRBBR" is $ 3 $ , with "BB" occurred once and "RR" occurred twice.

Your goal is to minimize the imperfectness and print out the colors of the squares after painting.

## 输入格式

Each test contains multiple test cases.

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Each test case consists of two lines.

The first line of each test case contains an integer $ n $ ( $ 1\leq n\leq 100 $ ) — the length of the squares row.

The second line of each test case contains a string $ s $ with length $ n $ , containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.

## 输出格式

For each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.

## 说明/提示

In the first test case, if the squares are painted "BRRBRBR", the imperfectness is $ 1 $ (since squares $ 2 $ and $ 3 $ have the same color), which is the minimum possible imperfectness.

## 样例 #1

### 输入

```
5
7
?R???BR
7
???R???
1
?
1
B
10
?R??RB??B?
```

### 输出

```
BRRBRBR
BRBRBRB
B
B
BRRBRBBRBR
```



---

---
title: "Combination"
layout: "post"
diff: 普及-
pid: CF155B
tag: []
---

# Combination

## 题目描述

Ilya plays a card game by the following rules.

A player has several cards. Each card contains two non-negative integers inscribed, one at the top of the card and one at the bottom. At the beginning of the round the player chooses one of his cards to play it. If the top of the card contains number $ a_{i} $ , and the bottom contains number $ b_{i} $ , then when the player is playing the card, he gets $ a_{i} $ points and also gets the opportunity to play additional $ b_{i} $ cards. After the playing the card is discarded.

More formally: let's say that there is a counter of the cards that can be played. At the beginning of the round the counter equals one. When a card is played, the counter decreases by one for the played card and increases by the number $ b_{i} $ , which is written at the bottom of the card. Then the played card is discarded. If after that the counter is not equal to zero, the player gets the opportunity to play another card from the remaining cards. The round ends when the counter reaches zero or the player runs out of cards.

Of course, Ilya wants to get as many points as possible. Can you determine the maximum number of points he can score provided that you know his cards?

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=1000 $ ) — the number of cards Ilya has.

Each of the next $ n $ lines contains two non-negative space-separated integers — $ a_{i} $ and $ b_{i} $ ( $ 0<=a_{i},b_{i}<=10^{4} $ ) — the numbers, written at the top and the bottom of the $ i $ -th card correspondingly.

## 输出格式

Print the single number — the maximum number of points you can score in one round by the described rules.

## 说明/提示

In the first sample none of two cards brings extra moves, so you should play the one that will bring more points.

In the second sample you should first play the third card that doesn't bring any points but lets you play both remaining cards.

## 样例 #1

### 输入

```
2
1 0
2 0

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3
1 0
2 0
0 2

```

### 输出

```
3

```



---

---
title: "Infinity Table"
layout: "post"
diff: 普及-
pid: CF1560C
tag: []
---

# Infinity Table

## 题目描述

Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from $ 1 $ , starting from the topmost one. The columns are numbered from $ 1 $ , starting from the leftmost one.

Initially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from $ 1 $ and so on to the table as follows.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1560C/fbe22cdb57a9c1d91e54741c4b3ed27f17ef455a.png)The figure shows the placement of the numbers from $ 1 $ to $ 10 $ . The following actions are denoted by the arrows.The leftmost topmost cell of the table is filled with the number $ 1 $ . Then he writes in the table all positive integers beginning from $ 2 $ sequentially using the following algorithm.

First, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).

After that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.

A friend of Polycarp has a favorite number $ k $ . He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number $ k $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Then $ t $ test cases follow.

Each test case consists of one line containing one integer $ k $ ( $ 1 \le k \le 10^9 $ ) which location must be found.

## 输出格式

For each test case, output in a separate line two integers $ r $ and $ c $ ( $ r, c \ge 1 $ ) separated by spaces — the indices of the row and the column containing the cell filled by the number $ k $ , respectively.

## 样例 #1

### 输入

```
7
11
14
5
4
1
2
1000000000
```

### 输出

```
2 4
4 3
1 3
2 1
1 1
1 2
31623 14130
```



---

---
title: "The Miracle and the Sleeper"
layout: "post"
diff: 普及-
pid: CF1562A
tag: []
---

# The Miracle and the Sleeper

## 题目描述

You are given two integers $ l $ and $ r $ , $ l\le r $ . Find the largest possible value of $ a \bmod b $ over all pairs $ (a, b) $ of integers for which $ r\ge a \ge b \ge l $ .

As a reminder, $ a \bmod b $ is a remainder we get when dividing $ a $ by $ b $ . For example, $ 26 \bmod 8 = 2 $ .

## 输入格式

Each test contains multiple test cases.

The first line contains one positive integer $ t $ $ (1\le t\le 10^4) $ , denoting the number of test cases. Description of the test cases follows.

The only line of each test case contains two integers $ l $ , $ r $ ( $ 1\le l \le r \le 10^9 $ ).

## 输出格式

For every test case, output the largest possible value of $ a \bmod b $ over all pairs $ (a, b) $ of integers for which $ r\ge a \ge b \ge l $ .

## 说明/提示

In the first test case, the only allowed pair is $ (a, b) = (1, 1) $ , for which $ a \bmod b = 1 \bmod 1 = 0 $ .

In the second test case, the optimal choice is pair $ (a, b) = (1000000000, 999999999) $ , for which $ a \bmod b = 1 $ .

## 样例 #1

### 输入

```
4
1 1
999999999 1000000000
8 26
1 999999999
```

### 输出

```
0
1
12
499999999
```



---

---
title: "Scenes From a Memory"
layout: "post"
diff: 普及-
pid: CF1562B
tag: []
---

# Scenes From a Memory

## 题目描述

给出一个正整数 $n$，$n$ 中不包含 $0$。求最大删去多少位使其变成一个合数或 $1$。数据保证一定存在答案。

素数是指除 $1$ 和它本身外没有除数的数。合数是指一个有两个以上除数的数。$1$ 既不是质数也不是合数。

## 输入格式

第一行一个正整数 $t(1\leq t \leq 10^3)$，表示数据组数。

每组数据第一行一个正整数 $k(1\leq k\leq 50)$，表示数字的位数。

第二行一整正整数 $n(10^{k-1}\leq n \leq 10^{k})$。

## 输出格式

对于每组数据，第一行输出剩下的数的位数，第二行输出剩下的数。

若有多组解，输出任意一个即可。

## 样例 #1

### 输入

```
7
3
237
5
44444
3
221
2
35
3
773
1
4
30
626221626221626221626221626221
```

### 输出

```
2
27
1
4
1
1
2
35
2
77
1
4
1
6
```



---

---
title: "MAX-MEX Cut"
layout: "post"
diff: 普及-
pid: CF1566C
tag: []
---

# MAX-MEX Cut

## 题目描述

A binary string is a string that consists of characters $ 0 $ and $ 1 $ . A bi-table is a table that has exactly two rows of equal length, each being a binary string.

Let $ \operatorname{MEX} $ of a bi-table be the smallest digit among $ 0 $ , $ 1 $ , or $ 2 $ that does not occur in the bi-table. For example, $ \operatorname{MEX} $ for $ \begin{bmatrix} 0011\\ 1010 \end{bmatrix} $ is $ 2 $ , because $ 0 $ and $ 1 $ occur in the bi-table at least once. $ \operatorname{MEX} $ for $ \begin{bmatrix} 111\\ 111 \end{bmatrix} $ is $ 0 $ , because $ 0 $ and $ 2 $ do not occur in the bi-table, and $ 0 < 2 $ .

You are given a bi-table with $ n $ columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table — the whole bi-table.

What is the maximal sum of $ \operatorname{MEX} $ of all resulting bi-tables can be?

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Description of the test cases follows.

The first line of the description of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the number of columns in the bi-table.

Each of the next two lines contains a binary string of length $ n $ — the rows of the bi-table.

It's guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case print a single integer — the maximal sum of $ \operatorname{MEX} $ of all bi-tables that it is possible to get by cutting the given bi-table optimally.

## 说明/提示

In the first test case you can cut the bi-table as follows:

- $ \begin{bmatrix} 0\\ 1 \end{bmatrix} $ , its $ \operatorname{MEX} $ is $ 2 $ .
- $ \begin{bmatrix} 10\\ 10 \end{bmatrix} $ , its $ \operatorname{MEX} $ is $ 2 $ .
- $ \begin{bmatrix} 1\\ 1 \end{bmatrix} $ , its $ \operatorname{MEX} $ is $ 0 $ .
- $ \begin{bmatrix} 0\\ 1 \end{bmatrix} $ , its $ \operatorname{MEX} $ is $ 2 $ .
- $ \begin{bmatrix} 0\\ 0 \end{bmatrix} $ , its $ \operatorname{MEX} $ is $ 1 $ .
- $ \begin{bmatrix} 0\\ 0 \end{bmatrix} $ , its $ \operatorname{MEX} $ is $ 1 $ .

The sum of $ \operatorname{MEX} $ is $ 8 $ .

## 样例 #1

### 输入

```
4
7
0101000
1101100
5
01100
10101
2
01
01
6
000000
111111
```

### 输出

```
8
8
2
12
```



---

---
title: "Seating Arrangements (easy version)"
layout: "post"
diff: 普及-
pid: CF1566D1
tag: []
---

# Seating Arrangements (easy version)

## 题目描述

It is the easy version of the problem. The only difference is that in this version $ n = 1 $ .

In the cinema seats can be represented as the table with $ n $ rows and $ m $ columns. The rows are numbered with integers from $ 1 $ to $ n $ . The seats in each row are numbered with consecutive integers from left to right: in the $ k $ -th row from $ m (k - 1) + 1 $ to $ m k $ for all rows $ 1 \le k \le n $ .

  $ 1 $

 $ 2 $  $ \cdots $  $ m - 1 $  $ m $  $ m + 1 $

 $ m + 2 $  $ \cdots $  $ 2 m - 1 $  $ 2 m $  $ 2m + 1 $

 $ 2m + 2 $  $ \cdots $  $ 3 m - 1 $  $ 3 m $  $ \vdots $

 $ \vdots $  $ \ddots $  $ \vdots $  $ \vdots $  $ m (n - 1) + 1 $

 $ m (n - 1) + 2 $  $ \cdots $  $ n m - 1 $  $ n m $ The table with seats indicesThere are $ nm $ people who want to go to the cinema to watch a new film. They are numbered with integers from $ 1 $ to $ nm $ . You should give exactly one seat to each person.

It is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. $ i $ -th person has the level of sight $ a_i $ . Let's define $ s_i $ as the seat index, that will be given to $ i $ -th person. You want to give better places for people with lower sight levels, so for any two people $ i $ , $ j $ such that $ a_i < a_j $ it should be satisfied that $ s_i < s_j $ .

After you will give seats to all people they will start coming to their seats. In the order from $ 1 $ to $ nm $ , each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.

Let's consider an example: $ m = 5 $ , the person has the seat $ 4 $ in the first row, the seats $ 1 $ , $ 3 $ , $ 5 $ in the first row are already occupied, the seats $ 2 $ and $ 4 $ are free. The inconvenience of this person will be $ 2 $ , because he will go through occupied seats $ 1 $ and $ 3 $ .

Find the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ n = 1 $ , $ 1 \le m \le 300 $ ) — the number of rows and places in each row respectively.

The second line of each test case contains $ n \cdot m $ integers $ a_1, a_2, \ldots, a_{n \cdot m} $ ( $ 1 \le a_i \le 10^9 $ ), where $ a_i $ is the sight level of $ i $ -th person.

It's guaranteed that the sum of $ n \cdot m $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case print a single integer — the minimal total inconvenience that can be achieved.

## 说明/提示

In the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be $ 0 $ , inconvenience of the second person will be $ 1 $ and inconvenience of the third person will be $ 2 $ . The total inconvenience is $ 0 + 1 + 2 = 3 $ .

In the second test case, people should sit as follows: $ s_1 = 2 $ , $ s_2 = 1 $ , $ s_3 = 5 $ , $ s_4 = 4 $ , $ s_5 = 3 $ . The total inconvenience will be $ 6 $ .

## 样例 #1

### 输入

```
4
1 3
1 2 3
1 5
2 1 5 3 3
1 2
2 1
1 6
2 3 2 1 1 1
```

### 输出

```
3
6
0
1
```



---

---
title: "MEXor Mixup"
layout: "post"
diff: 普及-
pid: CF1567B
tag: []
---

# MEXor Mixup

## 题目描述

给你两个数字 $a$，$b$，问使得一个非负整数数组的 $\operatorname{MEX}$ 为 $a$ ，数组内所有数的 $\operatorname{XOR}$ 为 $b$ 的最短长度。

称不属于该数组的最小非负整数为该数组的 $\operatorname{MEX}$ ，数组的 $\operatorname{XOR}$ 为数组所有元素的按位异或。

## 输入格式

多组数据。

第一行一个 $t$ ，表示数据组数。

接下来每组数据包含两个整数 $a$ 和 $b$ 。

## 输出格式

对于每一组数据，输出一个数表示所能构成的最短长度。

## 说明/提示

$1\leq t \leq 5\cdot10^5,1\leq  a \leq 3\cdot10^5,0\leq b\leq 3\cdot10^5$

译者：@smyslenny

## 样例 #1

### 输入

```
5
1 1
2 1
2 0
1 10000
2 10000
```

### 输出

```
3
2
3
2
3
```



---

---
title: "Chess Tournament"
layout: "post"
diff: 普及-
pid: CF1569B
tag: []
---

# Chess Tournament

## 题目描述

### 题意翻译

$n$ 个人进行比赛，每场比赛的结果只有输，赢，平局三种情况。

每个玩家对于比赛都有自己的期望，有以下两种类型：

1. 玩家不想输掉任何一场比赛；

2. 玩家想要赢得至少一场比赛。

判断是否存在所有比赛的结果，使得所有玩家都满足他们的期望。 如果有多种可能的结果，输出任意一种即可。 如果没有，输出 No。

## 输入格式

多组数据。

一个行一个整数 $T$,代表数据组数。

对于每组数据，第一行一个整数 $n$，代表选手的数量。

第二行一个字符串 $s$，长度为 $n$，由 1,2 构成，分别表示当前玩家期望第一种结果，当前玩家期望第二种结果。

## 输出格式

对于每组数据，如果不存在合法方案，输出 `No`。

否则，输出 `Yes`。并在下一行输出一个 $n\times n$ 的矩阵。

矩阵的第 $i$ 行第 $j$ 列表示 $i,j$ 选手比赛的结果，如果 $i$ 胜利，输出 `+` ，如果 $j$ 胜利，输出 `-`，如果平局，输出 `=`。
当 $i=j$ 时，输出 `X`。

## 说明/提示

$1\le t \le 200,2\le n \le50$。

译者：@smyslenny

## 样例 #1

### 输入

```
3
3
111
2
21
4
2122
```

### 输出

```
YES
X==
=X=
==X
NO
YES
X--+
+X++
+-X-
--+X
```



---

---
title: "Combinatorics Homework"
layout: "post"
diff: 普及-
pid: CF1574B
tag: []
---

# Combinatorics Homework

## 题目描述

You are given four integer values $ a $ , $ b $ , $ c $ and $ m $ .

Check if there exists a string that contains:

- $ a $ letters 'A';
- $ b $ letters 'B';
- $ c $ letters 'C';
- no other letters;
- exactly $ m $ pairs of adjacent equal letters (exactly $ m $ such positions $ i $ that the $ i $ -th letter is equal to the $ (i+1) $ -th one).

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

Each of the next $ t $ lines contains the description of the testcase — four integers $ a $ , $ b $ , $ c $ and $ m $ ( $ 1 \le a, b, c \le 10^8 $ ; $ 0 \le m \le 10^8 $ ).

## 输出格式

For each testcase print "YES" if there exists a string that satisfies all the requirements. Print "NO" if there are no such strings.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).

## 说明/提示

In the first testcase strings "ABCAB" or "BCABA" satisfy the requirements. There exist other possible strings.

In the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.

In the third testcase string "CABBCC" satisfies the requirements. There exist other possible strings.

## 样例 #1

### 输入

```
3
2 2 1 0
1 1 1 1
1 2 3 2
```

### 输出

```
YES
NO
YES
```



---

---
title: "Game Outcome"
layout: "post"
diff: 普及-
pid: CF157A
tag: []
---

# Game Outcome

## 题目描述

## 题意
福尔摩斯和华生在一个n * n的棋盘上玩添数游戏。在游戏期间，他们放置一些数到棋盘上，（其中的规则我们不知道）。然而，现在游戏结束了，棋盘中都有一个数字。要知道谁赢，他们需要计算获胜方块的数量。如果要确定特定的方块是否获胜，你需要做到以下几点。分别计算出这个方块所在的纵列上所有数的和（包括自身）和计算出这个方块所在的横列上所有数的和（包括自身）。如果纵列的和大于横列的和，那么这个方块就算一个获胜方块。
如图所示，真是一个结束的棋局。
然后，紫色格子获胜，因为其纵列之和（8+3+6+7=24）大于其横列（9+5+3+2=19）之和，以及24>1924>1924>19。

## 输入格式

第一行包含一个整数n（1<=n<=30）。
接下来n行，每行n个数，每个数用空格隔开。第i行上的第j个数字表示棋盘上地i行第j列方格上的数字。棋盘上所有数字大于等于1，小于等于100。

## 输出格式

输出一个数字——获胜方块的数量。

## 样例 #1

### 输入

```
1
1

```

### 输出

```
0

```

## 样例 #2

### 输入

```
2
1 2
3 4

```

### 输出

```
2

```

## 样例 #3

### 输入

```
4
5 7 8 4
9 5 3 2
1 6 6 4
9 5 7 3

```

### 输出

```
6

```



---

---
title: "CQXYM Count Permutations"
layout: "post"
diff: 普及-
pid: CF1581A
tag: []
---

# CQXYM Count Permutations

## 题目描述

CQXYM is counting permutations length of $ 2n $ .

A permutation is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array) and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array).

A permutation $ p $ (length of $ 2n $ ) will be counted only if the number of $ i $ satisfying $ p_i<p_{i+1} $ is no less than $ n $ . For example:

- Permutation $ [1, 2, 3, 4] $ will count, because the number of such $ i $ that $ p_i<p_{i+1} $ equals $ 3 $ ( $ i = 1 $ , $ i = 2 $ , $ i = 3 $ ).
- Permutation $ [3, 2, 1, 4] $ won't count, because the number of such $ i $ that $ p_i<p_{i+1} $ equals $ 1 $ ( $ i = 3 $ ).

CQXYM wants you to help him to count the number of such permutations modulo $ 1000000007 $ ( $ 10^9+7 $ ).

In addition, [modulo operation](https://en.wikipedia.org/wiki/Modulo_operation) is to get the remainder. For example:

- $ 7 \mod 3=1 $ , because $ 7 = 3 \cdot 2 + 1 $ ,
- $ 15 \mod 4=3 $ , because $ 15 = 4 \cdot 3 + 3 $ .

## 输入格式

The input consists of multiple test cases.

The first line contains an integer $ t (t \geq 1) $ — the number of test cases. The description of the test cases follows.

Only one line of each test case contains an integer $ n(1 \leq n \leq 10^5) $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $

## 输出格式

For each test case, print the answer in a single line.

## 说明/提示

$ n=1 $ , there is only one permutation that satisfies the condition: $ [1,2]. $

In permutation $ [1,2] $ , $ p_1<p_2 $ , and there is one $ i=1 $ satisfy the condition. Since $ 1 \geq n $ , this permutation should be counted. In permutation $ [2,1] $ , $ p_1>p_2 $ . Because $ 0<n $ , this permutation should not be counted.

 $ n=2 $ , there are $ 12 $ permutations: $ [1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[2,1,3,4],[2,3,1,4],[2,3,4,1],[2,4,1,3],[3,1,2,4],[3,4,1,2],[4,1,2,3]. $

## 样例 #1

### 输入

```
4
1
2
9
91234
```

### 输出

```
1
12
830455698
890287984
```



---

---
title: "Luntik and Concerts"
layout: "post"
diff: 普及-
pid: CF1582A
tag: []
---

# Luntik and Concerts

## 题目描述

有 $a$ 个 $1$ 分钟的音乐，$b$ 个 $2$ 分钟的音乐，$c$ 个 $3$ 分钟的音乐，将这些音乐分成 $2$ 组，使两组音乐的总时长之差的绝对值尽可能小。

## 输入格式

第一行输入一个正整数 $t$ 表示数据组数。

## 输出格式

对于每组数据输出一行一个整数表示两组音乐的总时长之差的绝对值的最小值。

## 说明/提示

$1\le t\le1000,1\le a,b,c\le10^9$。

### 样例解释：
1. 第一组 $1$ 个 $1$ 分钟音乐、$2$ 个 $2$ 分钟音乐，第二组 $1$ 个 $3$ 分钟音乐时两组音乐总时长之差的绝对值最小，为 $0$。
2. 第一组 $2$ 个 $1$ 分钟音乐、$1$ 个 $2$ 分钟音乐$1$ 个 $3$ 分钟音乐，第二组 $2$ 个 $3$ 分钟音乐时两组音乐总时长之差的绝对值最小，为 $1$。
3. 第一组 $5$ 个 $1$ 分钟音乐、$5$ 个 $2$ 分钟音乐，第二组 $5$ 个 $3$ 分钟音乐时两组音乐总时长之差的绝对值最小，为 $0$。
4. 第一组 $1$ 个 $1$ 分钟音乐、$1$ 个 $3$ 分钟音乐，第二组 $1$ 个 $2$ 分钟音乐、$1$ 个 $3$ 分钟音乐时两组音乐总时长之差的绝对值最小，为 $1$。

## 样例 #1

### 输入

```
4
1 1 1
2 1 3
5 5 5
1 1 2
```

### 输出

```
0
1
0
1
```



---

---
title: "Luntik and Subsequences"
layout: "post"
diff: 普及-
pid: CF1582B
tag: []
---

# Luntik and Subsequences

## 题目描述

有一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，和为 $s$，求这个序列有多少个子序列（可以为空）和为 $s-1$。

## 输入格式

第一行输入一个正整数 $t$ 表示数据组数。

接下来 $2t$ 行每 $2$ 行表示一组数据。

对于每组数据，第一行输入一个正整数 $n$ 表示序列长度；第二行输入 $n$ 个整数表示这个序列。

## 输出格式

对于每组数据，输出一行一个整数表示满足条件的子序列的个数。

## 说明/提示

$1\le t\le1000,1\le n\le60,0\le a_i\le10^9$。
### 样例解释
第一组数据，满足条件的子序列为 $\{2,3,4,5\}$。

第二组数据，没有满足条件的子序列。

第三组数据，满足条件的子序列为 $\{\}$ 和 $\{0\}$。

## 样例 #1

### 输入

```
5
5
1 2 3 4 5
2
1000 1000
2
1 0
5
3 0 2 1 1
5
2 1 0 3 0
```

### 输出

```
1
0
2
4
4
```



---

---
title: "Windblume Ode"
layout: "post"
diff: 普及-
pid: CF1583A
tag: []
---

# Windblume Ode

## 题目描述

A bow adorned with nameless flowers that bears the earnest hopes of an equally nameless person.

You have obtained the elegant bow known as the Windblume Ode. Inscribed in the weapon is an array of $ n $ ( $ n \ge 3 $ ) positive distinct integers (i.e. different, no duplicates are allowed).

Find the largest subset (i.e. having the maximum number of elements) of this array such that its sum is a composite number. A positive integer $ x $ is called composite if there exists a positive integer $ y $ such that $ 1 < y < x $ and $ x $ is divisible by $ y $ .

If there are multiple subsets with this largest size with the composite sum, you can output any of them. It can be proven that under the constraints of the problem such a non-empty subset always exists.

## 输入格式

Each test consists of multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 3 \leq n \leq 100 $ ) — the length of the array.

The second line of each test case contains $ n $ distinct integers $ a_{1},a_{2},\dots,a_{n} $ ( $ 1 \leq a_{i} \leq 200 $ ) — the elements of the array.

## 输出格式

Each test case should have two lines of output.

The first line should contain a single integer $ x $ : the size of the largest subset with composite sum. The next line should contain $ x $ space separated integers representing the indices of the subset of the initial array.

## 说明/提示

In the first test case, the subset $ \{a_2, a_1\} $ has a sum of $ 9 $ , which is a composite number. The only subset of size $ 3 $ has a prime sum equal to $ 11 $ . Note that you could also have selected the subset $ \{a_1, a_3\} $ with sum $ 8 + 2 = 10 $ , which is composite as it's divisible by $ 2 $ .

In the second test case, the sum of all elements equals to $ 21 $ , which is a composite number. Here we simply take the whole array as our subset.

## 样例 #1

### 输入

```
4
3
8 1 2
4
6 9 4 2
9
1 2 3 4 5 6 7 8 9
3
200 199 198
```

### 输出

```
2
2 1
4
2 1 4 3
9
6 9 1 2 3 4 5 7 8
3
1 2 3
```



---

---
title: "Omkar and Heavenly Tree"
layout: "post"
diff: 普及-
pid: CF1583B
tag: []
---

# Omkar and Heavenly Tree

## 题目描述

Lord Omkar would like to have a tree with $ n $ nodes ( $ 3 \le n \le 10^5 $ ) and has asked his disciples to construct the tree. However, Lord Omkar has created $ m $ ( $ \mathbf{1 \le m < n} $ ) restrictions to ensure that the tree will be as heavenly as possible.

A tree with $ n $ nodes is an connected undirected graph with $ n $ nodes and $ n-1 $ edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.

Here is an example of a tree:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1583B/922e28fa3dc9009cfe0a3df0832a3fd2d74db75e.png)A restriction consists of $ 3 $ pairwise distinct integers, $ a $ , $ b $ , and $ c $ ( $ 1 \le a,b,c \le n $ ). It signifies that node $ b $ cannot lie on the simple path between node $ a $ and node $ c $ .

Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \leq t \leq 10^4 $ ). Description of the test cases follows.

The first line of each test case contains two integers, $ n $ and $ m $ ( $ 3 \leq n \leq 10^5 $ , $ \mathbf{1 \leq m < n} $ ), representing the size of the tree and the number of restrictions.

The $ i $ -th of the next $ m $ lines contains three integers $ a_i $ , $ b_i $ , $ c_i $ ( $ 1 \le a_i, b_i, c_i \le n $ ,  $ a $ , $ b $ , $ c $ are distinct), signifying that node $ b_i $ cannot lie on the simple path between nodes $ a_i $ and $ c_i $ .

It is guaranteed that the sum of $ n $ across all test cases will not exceed $ 10^5 $ .

## 输出格式

For each test case, output $ n-1 $ lines representing the $ n-1 $ edges in the tree. On each line, output two integers $ u $ and $ v $ ( $ 1 \le u, v \le n $ , $ u \neq v $ ) signifying that there is an edge between nodes $ u $ and $ v $ . Given edges have to form a tree that satisfies Omkar's restrictions.

## 说明/提示

The output of the first sample case corresponds to the following tree:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1583B/0c5be7df736dea93d6f4b675bd823f2c78ee5fb4.png) For the first restriction, the simple path between $ 1 $ and $ 3 $ is $ 1, 3 $ , which doesn't contain $ 2 $ . The simple path between $ 3 $ and $ 5 $ is $ 3, 5 $ , which doesn't contain $ 4 $ . The simple path between $ 5 $ and $ 7 $ is $ 5, 3, 1, 2, 7 $ , which doesn't contain $ 6 $ . The simple path between $ 6 $ and $ 4 $ is $ 6, 7, 2, 1, 3, 4 $ , which doesn't contain $ 5 $ . Thus, this tree meets all of the restrictions.The output of the second sample case corresponds to the following tree:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1583B/72e70755d9a3eab42b10c011746b34dd97df37a1.png)

## 样例 #1

### 输入

```
2
7 4
1 2 3
3 4 5
5 6 7
6 5 4
5 3
1 2 3
2 3 4
3 4 5
```

### 输出

```
1 2
1 3
3 5
3 4
2 7
7 6
5 1
1 3
3 2
2 4
```



---

---
title: "Coloring Rectangles"
layout: "post"
diff: 普及-
pid: CF1584B
tag: []
---

# Coloring Rectangles

## 题目描述

David was given a red checkered rectangle of size $ n \times m $ . But he doesn't like it. So David cuts the original or any other rectangle piece obtained during the cutting into two new pieces along the grid lines. He can do this operation as many times as he wants.

As a result, he will get a set of rectangles. Rectangles $ 1 \times 1 $ are forbidden.

David also knows how to paint the cells blue. He wants each rectangle from the resulting set of pieces to be colored such that any pair of adjacent cells by side (from the same piece) have different colors.

What is the minimum number of cells David will have to paint?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^3 $ ) — the number of test cases. The next lines contain descriptions of test cases.

The only line of each test case contains two integers $ n $ , $ m $ ( $ 1 \leq n, m \leq 3 \cdot 10^4 $ , $ n \cdot m \geq 2 $ ).

## 输出格式

For each test case print a single integer — the minimum number of cells David will have to paint blue.

## 说明/提示

The following pictures show how the initial rectangle can be split and cells colored blue.

In the first test case:

 ![](https://espresso.codeforces.com/d4181663ab2adbfb9f518c9f09390152197a7da9.png)In the second test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1584B/031877f8fff4a791933910251c89a32c8e77053c.png)In the third test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1584B/56c02ce81081236d5a7f494f32a723cf9e1c4a6e.png)In the fourth test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1584B/13bf05e608fac4f3bd0b4c9984699891f97a32fe.png)

## 样例 #1

### 输入

```
4
1 3
2 2
2 5
3 5
```

### 输出

```
1
2
4
5
```



---

---
title: "Two Arrays"
layout: "post"
diff: 普及-
pid: CF1584C
tag: []
---

# Two Arrays

## 题目描述

You are given two arrays of integers $ a_1, a_2, \ldots, a_n $ and $ b_1, b_2, \ldots, b_n $ .

Let's define a transformation of the array $ a $ :

1. Choose any non-negative integer $ k $ such that $ 0 \le k \le n $ .
2. Choose $ k $ distinct array indices $ 1 \le i_1 < i_2 < \ldots < i_k \le n $ .
3. Add $ 1 $ to each of $ a_{i_1}, a_{i_2}, \ldots, a_{i_k} $ , all other elements of array $ a $ remain unchanged.
4. Permute the elements of array $ a $ in any order.

Is it possible to perform some transformation of the array $ a $ exactly once, so that the resulting array is equal to $ b $ ?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. Descriptions of test cases follow.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the size of arrays $ a $ and $ b $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ -100 \le a_i \le 100 $ ).

The third line of each test case contains $ n $ integers $ b_1, b_2, \ldots, b_n $ ( $ -100 \le b_i \le 100 $ ).

## 输出格式

For each test case, print "YES" (without quotes) if it is possible to perform a transformation of the array $ a $ , so that the resulting array is equal to $ b $ . Print "NO" (without quotes) otherwise.

You can print each letter in any case (upper or lower).

## 说明/提示

In the first test case, we can make the following transformation:

- Choose $ k = 2 $ .
- Choose $ i_1 = 1 $ , $ i_2 = 2 $ .
- Add $ 1 $ to $ a_1 $ and $ a_2 $ . The resulting array is $ [0, 2, 0] $ .
- Swap the elements on the second and third positions.

In the second test case there is no suitable transformation.

In the third test case we choose $ k = 0 $ and do not change the order of elements.

## 样例 #1

### 输入

```
3
3
-1 1 0
0 0 2
1
0
2
5
1 2 3 4 5
1 2 3 4 5
```

### 输出

```
YES
NO
YES
```



---

---
title: "Array Eversion"
layout: "post"
diff: 普及-
pid: CF1585B
tag: []
---

# Array Eversion

## 题目描述

You are given an array $ a $ of length $ n $ .

Let's define the eversion operation. Let $ x = a_n $ . Then array $ a $ is partitioned into two parts: left and right. The left part contains the elements of $ a $ that are not greater than $ x $ ( $ \le x $ ). The right part contains the elements of $ a $ that are strictly greater than $ x $ ( $ > x $ ). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array $ a $ is $ [2, 4, 1, 5, 3] $ , the eversion goes like this: $ [2, 4, 1, 5, 3] \to [2, 1, 3], [4, 5] \to [2, 1, 3, 4, 5] $ .

We start with the array $ a $ and perform eversions on this array. We can prove that after several eversions the array $ a $ stops changing. Output the minimum number $ k $ such that the array stops changing after $ k $ eversions.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.

The first line contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ).

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case print a single integer $ k $ — the number of eversions after which the array stops changing.

## 说明/提示

Consider the fist example.

- The first eversion: $ a = [1, 4, 2, 5, 3] $ , $ x = 3 $ . $ [2, 4, 1, 5, 3] \to [2, 1, 3], [4, 5] \to [2, 1, 3, 4, 5] $ .
- The second and following eversions: $ a = [2, 1, 3, 4, 5] $ , $ x = 5 $ . $ [2, 1, 3, 4, 5] \to [2, 1, 3, 4, 5], [] \to [2, 1, 3, 4, 5] $ . This eversion does not change the array, so the answer is $ 1 $ .

Consider the second example.

- The first eversion: $ a = [5, 3, 2, 4, 1] $ , $ x = 1 $ . $ [5, 3, 2, 4, 1] \to [1], [5, 3, 2, 4] \to [1, 5, 3, 2, 4] $ .
- The second eversion: $ a = [1, 5, 3, 2, 4] $ , $ x = 4 $ . $ [1, 5, 3, 2, 4] \to [1, 3, 2, 4], [5] \to [1, 3, 2, 4, 5] $ .
- The third and following eversions: $ a = [1, 3, 2, 4, 5] $ , $ x = 5 $ . $ [1, 3, 2, 4, 5] \to [1, 3, 2, 4, 5], [] \to [1, 3, 2, 4, 5] $ . This eversion does not change the array, so the answer is $ 2 $ .

## 样例 #1

### 输入

```
3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1
```

### 输出

```
1
2
0
```



---

---
title: "Taxi"
layout: "post"
diff: 普及-
pid: CF158B
tag: []
---

# Taxi

## 题目描述

After the lessons $ n $ groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the $ i $ -th group consists of $ s_{i} $ friends ( $ 1<=s_{i}<=4 $ ), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of groups of schoolchildren. The second line contains a sequence of integers $ s_{1},s_{2},...,s_{n} $ ( $ 1<=s_{i}<=4 $ ). The integers are separated by a space, $ s_{i} $ is the number of children in the $ i $ -th group.

## 输出格式

Print the single number — the minimum number of taxis necessary to drive all children to Polycarpus.

## 说明/提示

In the first test we can sort the children into four cars like this:

- the third group (consisting of four children),
- the fourth group (consisting of three children),
- the fifth group (consisting of three children),
- the first and the second group (consisting of one and two children, correspondingly).

There are other ways to sort the groups into four cars.

## 样例 #1

### 输入

```
5
1 2 4 3 3

```

### 输出

```
4

```

## 样例 #2

### 输入

```
8
2 3 4 4 2 1 3 1

```

### 输出

```
5

```



---

---
title: "Array Eversion"
layout: "post"
diff: 普及-
pid: CF1591B
tag: []
---

# Array Eversion

## 题目描述

You are given an array $ a $ of length $ n $ .

Let's define the eversion operation. Let $ x = a_n $ . Then array $ a $ is partitioned into two parts: left and right. The left part contains the elements of $ a $ that are not greater than $ x $ ( $ \le x $ ). The right part contains the elements of $ a $ that are strictly greater than $ x $ ( $ > x $ ). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array $ a $ is $ [2, 4, 1, 5, 3] $ , the eversion goes like this: $ [2, 4, 1, 5, 3] \to [2, 1, 3], [4, 5] \to [2, 1, 3, 4, 5] $ .

We start with the array $ a $ and perform eversions on this array. We can prove that after several eversions the array $ a $ stops changing. Output the minimum number $ k $ such that the array stops changing after $ k $ eversions.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.

The first line contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ).

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case print a single integer $ k $ — the number of eversions after which the array stops changing.

## 说明/提示

Consider the fist example.

- The first eversion: $ a = [1, 4, 2, 5, 3] $ , $ x = 3 $ . $ [2, 4, 1, 5, 3] \to [2, 1, 3], [4, 5] \to [2, 1, 3, 4, 5] $ .
- The second and following eversions: $ a = [2, 1, 3, 4, 5] $ , $ x = 5 $ . $ [2, 1, 3, 4, 5] \to [2, 1, 3, 4, 5], [] \to [2, 1, 3, 4, 5] $ . This eversion does not change the array, so the answer is $ 1 $ .

Consider the second example.

- The first eversion: $ a = [5, 3, 2, 4, 1] $ , $ x = 1 $ . $ [5, 3, 2, 4, 1] \to [1], [5, 3, 2, 4] \to [1, 5, 3, 2, 4] $ .
- The second eversion: $ a = [1, 5, 3, 2, 4] $ , $ x = 4 $ . $ [1, 5, 3, 2, 4] \to [1, 3, 2, 4], [5] \to [1, 3, 2, 4, 5] $ .
- The third and following eversions: $ a = [1, 3, 2, 4, 5] $ , $ x = 5 $ . $ [1, 3, 2, 4, 5] \to [1, 3, 2, 4, 5], [] \to [1, 3, 2, 4, 5] $ . This eversion does not change the array, so the answer is $ 2 $ .

## 样例 #1

### 输入

```
3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1
```

### 输出

```
1
2
0
```



---

---
title: "Hemose Shopping"
layout: "post"
diff: 普及-
pid: CF1592B
tag: []
---

# Hemose Shopping

## 题目描述

Hemose was shopping with his friends Samez, AhmedZ, AshrafEzz, TheSawan and O\_E in Germany. As you know, Hemose and his friends are problem solvers, so they are very clever. Therefore, they will go to all discount markets in Germany.

Hemose has an array of $ n $ integers. He wants Samez to sort the array in the non-decreasing order. Since it would be a too easy problem for Samez, Hemose allows Samez to use only the following operation:

- Choose indices $ i $ and $ j $ such that $ 1 \le i, j \le n $ , and $ \lvert i - j \rvert \geq x $ . Then, swap elements $ a_i $ and $ a_j $ .

Can you tell Samez if there's a way to sort the array in the non-decreasing order by using the operation written above some finite number of times (possibly $ 0 $ )?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ $ (1 \leq t \leq 10^5) $ . Description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ x $ $ (1 \leq x \leq n \leq 10^5) $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, ..., a_n $ $ (1 \leq a_i \leq 10^9) $ .

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, you should output a single string.

If Samez can sort the array in non-decreasing order using the operation written above, output "YES" (without quotes). Otherwise, output "NO" (without quotes).

You can print each letter of "YES" and "NO" in any case (upper or lower).

## 说明/提示

In the first test case, you can't do any operations.

In the second test case, the array is already sorted.

In the third test case, you can do the operations as follows:

- $ [5,1,2,3,4] $ , $ swap(a_1,a_3) $
- $ [2,1,5,3,4] $ , $ swap(a_2,a_5) $
- $ [2,4,5,3,1] $ , $ swap(a_2,a_4) $
- $ [2,3,5,4,1] $ , $ swap(a_1,a_5) $
- $ [1,3,5,4,2] $ , $ swap(a_2,a_5) $
- $ [1,2,5,4,3] $ , $ swap(a_3,a_5) $
- $ [1,2,3,4,5] $

(Here $ swap(a_i, a_j) $ refers to swapping elements at positions $ i $ , $ j $ ).

## 样例 #1

### 输入

```
4
3 3
3 2 1
4 3
1 2 3 4
5 2
5 1 2 3 4
5 4
1 2 3 4 4
```

### 输出

```
NO
YES
YES
YES
```



---

---
title: "Rubik's Cube Coloring (easy version)"
layout: "post"
diff: 普及-
pid: CF1594E1
tag: []
---

# Rubik's Cube Coloring (easy version)

## 题目描述

It is the easy version of the problem. The difference is that in this version, there are no nodes with already chosen colors.

Theofanis is starving, and he wants to eat his favorite food, sheftalia. However, he should first finish his homework. Can you help him with this problem?

You have a perfect binary tree of $ 2^k - 1 $ nodes — a binary tree where all vertices $ i $ from $ 1 $ to $ 2^{k - 1} - 1 $ have exactly two children: vertices $ 2i $ and $ 2i + 1 $ . Vertices from $ 2^{k - 1} $ to $ 2^k - 1 $ don't have any children. You want to color its vertices with the $ 6 $ Rubik's cube colors (White, Green, Red, Blue, Orange and Yellow).

Let's call a coloring good when all edges connect nodes with colors that are neighboring sides in the Rubik's cube.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1594E1/b0755608caf4588a1ceffdca8e2be827560017bc.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1594E1/c6ef9fa6fcd45f3211d7baf9a8cc69c074f640a9.png)A picture of Rubik's cube and its 2D map.More formally:

- a white node can not be neighboring with white and yellow nodes;
- a yellow node can not be neighboring with white and yellow nodes;
- a green node can not be neighboring with green and blue nodes;
- a blue node can not be neighboring with green and blue nodes;
- a red node can not be neighboring with red and orange nodes;
- an orange node can not be neighboring with red and orange nodes;

You want to calculate the number of the good colorings of the binary tree. Two colorings are considered different if at least one node is colored with a different color.

The answer may be too large, so output the answer modulo $ 10^9+7 $ .

## 输入格式

The first and only line contains the integers $ k $ ( $ 1 \le k \le 60 $ ) — the number of levels in the perfect binary tree you need to color.

## 输出格式

Print one integer — the number of the different colorings modulo $ 10^9+7 $ .

## 说明/提示

In the picture below, you can see one of the correct colorings of the first example.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1594E1/dcebca3c4893383a751dc627ead5632c7d038ce7.png)

## 样例 #1

### 输入

```
3
```

### 输出

```
24576
```

## 样例 #2

### 输入

```
14
```

### 输出

```
934234
```



---

---
title: "Groups"
layout: "post"
diff: 普及-
pid: CF1598B
tag: []
---

# Groups

## 题目描述

$ n $ students attended the first meeting of the Berland SU programming course ( $ n $ is even). All students will be divided into two groups. Each group will be attending exactly one lesson each week during one of the five working days (Monday, Tuesday, Wednesday, Thursday and Friday), and the days chosen for the groups must be different. Furthermore, both groups should contain the same number of students.

Each student has filled a survey in which they told which days of the week are convenient for them to attend a lesson, and which are not.

Your task is to determine if it is possible to choose two different week days to schedule the lessons for the group (the first group will attend the lesson on the first chosen day, the second group will attend the lesson on the second chosen day), and divide the students into two groups, so the groups have equal sizes, and for each student, the chosen lesson day for their group is convenient.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

Then the descriptions of $ t $ testcases follow.

The first line of each testcase contains one integer $ n $ ( $ 2 \le n \le 1\,000 $ ) — the number of students.

The $ i $ -th of the next $ n $ lines contains $ 5 $ integers, each of them is $ 0 $ or $ 1 $ . If the $ j $ -th integer is $ 1 $ , then the $ i $ -th student can attend the lessons on the $ j $ -th day of the week. If the $ j $ -th integer is $ 0 $ , then the $ i $ -th student cannot attend the lessons on the $ j $ -th day of the week.

Additional constraints on the input: for each student, at least one of the days of the week is convenient, the total number of students over all testcases doesn't exceed $ 10^5 $ .

## 输出格式

For each testcase print an answer. If it's possible to divide the students into two groups of equal sizes and choose different days for the groups so each student can attend the lesson in the chosen day of their group, print "YES" (without quotes). Otherwise, print "NO" (without quotes).

## 说明/提示

In the first testcase, there is a way to meet all the constraints. For example, the first group can consist of the first and the third students, they will attend the lessons on Thursday (the fourth day); the second group can consist of the second and the fourth students, and they will attend the lessons on Tuesday (the second day).

In the second testcase, it is impossible to divide the students into groups so they attend the lessons on different days.

## 样例 #1

### 输入

```
2
4
1 0 0 1 0
0 1 0 0 1
0 0 0 1 0
0 1 0 1 0
2
0 0 0 1 0
0 0 0 1 0
```

### 输出

```
YES
NO
```



---

---
title: "Matchmaker"
layout: "post"
diff: 普及-
pid: CF159B
tag: []
---

# Matchmaker

## 题目描述

ygg 有 $n$ 只马克笔和 $m$ 个笔盖。我们可以使用二元组 $(a, b)$ 来描述一只笔或一个笔盖，其中 $a$ 表示颜色，$b$ 表示大小。任意一对笔和笔盖只有在**大小相同**的时候才可以配对，如果这一对笔和笔盖**大小相同且颜色相同**，我们就称这一对笔和笔盖为**优秀的配对**。  
现在 ygg 希望知道他最多可以构成多少**优秀的配对**，以及最多共有多少对配对。

## 输入格式

第一行两个整数 $n$ 和 $m$ ，表示笔的数量和笔盖的数量  
接下来的 $n$ 行，每行两个整数 $a_i, b_i$ ，表示第 $i$ 只笔的颜色和大小。  
接下来的 $m$ 行，每行两个整数 $a_i, b_i$ ，表示第 $i$ 个笔盖的颜色和大小。

## 输出格式

输出一行，两个整数，表示最多共有多少对配对和最多的**优秀**的配对数。

## 样例 #1

### 输入

```
3 4
1 2
3 4
2 4
5 4
2 4
1 1
1 2

```

### 输出

```
3 2

```

## 样例 #2

### 输入

```
2 2
1 2
2 1
3 4
5 1

```

### 输出

```
1 0

```



---

---
title: "Array Elimination"
layout: "post"
diff: 普及-
pid: CF1601A
tag: []
---

# Array Elimination

## 题目描述

有一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，每次操作选择 $k$ 个数，将这 $k$ 个数减去他们的与（二进制运算中的与）的和。求哪些 $k$ 可以在有限次操作内使所有数变成 $0$。

## 输入格式

第一行一个正整数 $t$ 表示数据组数。

对于每一组数据，第一行输入一个正整数 $n$ 表示序列长度，第二行输入 $n$ 个非负整数表示序列 $a$ 。

## 输出格式

对于每一组数据，输出一行，从小到大输出每一个可能的 $k$ ，两个数之间用空格隔开。

## 说明/提示

$1\le t\le10^4,1\le\sum n\le2\times10^5,0\le a_i<2^{30}$。

## 样例 #1

### 输入

```
5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0
```

### 输出

```
1 2 4
1 2
1
1
1 2 3 4 5
```



---

---
title: "Update Files"
layout: "post"
diff: 普及-
pid: CF1606B
tag: []
---

# Update Files

## 题目描述

### 题意简述

有 $n$ 台电脑需要安装更新文件，开始时仅有 $1$ 号电脑有更新文件。

在每一个小时内，已安装文件的电脑可以通过一条电缆把文件传给另一个未安装文件的电脑。你只有 $k$ 条电缆，也就是说每个小时至多只能有 $k$ 台电脑进行传输。

问所有电脑都接受到更新文件需要多少小时。

## 输入格式

多组数据，第一行一个整数 $T\ (1\le T\le 10^5)$。

接下来 $T$ 行，每行两个整数 $n,k\ (1\le n\le k\le 10^{18})$。

## 输出格式

对于每组数据，输出一个整数表示答案。

## 样例 #1

### 输入

```
4
8 3
6 6
7 1
1 1
```

### 输出

```
4
3
6
0
```



---

---
title: "Odd Grasshopper"
layout: "post"
diff: 普及-
pid: CF1607B
tag: []
---

# Odd Grasshopper

## 题目描述

The grasshopper is located on the numeric axis at the point with coordinate $ x_0 $ .

Having nothing else to do he starts jumping between integer points on the axis. Making a jump from a point with coordinate $ x $ with a distance $ d $ to the left moves the grasshopper to a point with a coordinate $ x - d $ , while jumping to the right moves him to a point with a coordinate $ x + d $ .

The grasshopper is very fond of positive integers, so for each integer $ i $ starting with $ 1 $ the following holds: exactly $ i $ minutes after the start he makes a jump with a distance of exactly $ i $ . So, in the first minutes he jumps by $ 1 $ , then by $ 2 $ , and so on.

The direction of a jump is determined as follows: if the point where the grasshopper was before the jump has an even coordinate, the grasshopper jumps to the left, otherwise he jumps to the right.

For example, if after $ 18 $ consecutive jumps he arrives at the point with a coordinate $ 7 $ , he will jump by a distance of $ 19 $ to the right, since $ 7 $ is an odd number, and will end up at a point $ 7 + 19 = 26 $ . Since $ 26 $ is an even number, the next jump the grasshopper will make to the left by a distance of $ 20 $ , and it will move him to the point $ 26 - 20 = 6 $ .

Find exactly which point the grasshopper will be at after exactly $ n $ jumps.

## 输入格式

The first line of input contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

Each of the following $ t $ lines contains two integers $ x_0 $ ( $ -10^{14} \leq x_0 \leq 10^{14} $ ) and $ n $ ( $ 0 \leq n \leq 10^{14} $ ) — the coordinate of the grasshopper's initial position and the number of jumps.

## 输出格式

Print exactly $ t $ lines. On the $ i $ -th line print one integer — the answer to the $ i $ -th test case — the coordinate of the point the grasshopper will be at after making $ n $ jumps from the point $ x_0 $ .

## 说明/提示

The first two test cases in the example correspond to the first two jumps from the point $ x_0 = 0 $ .

Since $ 0 $ is an even number, the first jump of length $ 1 $ is made to the left, and the grasshopper ends up at the point $ 0 - 1 = -1 $ .

Then, since $ -1 $ is an odd number, a jump of length $ 2 $ is made to the right, bringing the grasshopper to the point with coordinate $ -1 + 2 = 1 $ .

## 样例 #1

### 输入

```
9
0 1
0 2
10 10
10 99
177 13
10000000000 987654321
-433494437 87178291199
1 0
-1 1
```

### 输出

```
-1
1
11
110
190
9012345679
-87611785637
1
0
```



---

---
title: "Minimum Extraction"
layout: "post"
diff: 普及-
pid: CF1607C
tag: []
---

# Minimum Extraction

## 题目描述

*Yelisey* 有一个含有 $n$ 个整数的数组 $a$。

如果 $a$ 的长度大于 $1$，*Yelisey* 就能对它进行一种被称为「提取最小值」的操作：

1. 将最小值 $m$ 从数组中删除，数组的长度会因此缩短 $1$。

   （如果有几个相同的 $m$，*Yelisei* 可以凭心情任选一个。）

2. 数组中剩下的元素也会被减去 $m$。

举个例子，有一个数组 $\{1, 6, -4, -2, -4\}$，其中的最小元素是 $-4$。我们将随意删去 $a_3$、$a_5$ 中的一个，再把剩余元素各减去 $-4$。显而易见，操作后的数组长这样：$\{1-(-4),6-(-4),-2-(-4),-4-(-4)\}$，化简后得到答案 $\{5, 10, 2, 0\}$。

由于 Yelisey 更喜欢大数，他希望这种操作能使数组 $a$ 中的元素数值尽可能大。

准确来说，他希望使数组 $a$ 中的最小值最大。为了达到这一目的，*Yelisey* 不惜对数组进行任意次「提取最小值」操作；当然，他也不一定非要进行这种操作。

现在，请你帮助他计算出在进行任意次「提取最小值」操作后，数组 $a$ 中的最小元素可以具有的最大值。

## 输入格式

第一行包含一个整数 $t( 1\le t\le10^4 )$，表示询问的次数。

接下来的 $2t$ 行对于每次询问在第一行给出了数组的原始长度 $n(1\le n\le 2⋅10^5)$ 和每个元素的值 $a_i( -10^9\le a_i\le 10^9)$。

## 输出格式

输出 $t$ 行，每行一个整数表示数次（可以是 $0$ 次）操作后数组 $a$ 中最小数的最大值。

## 说明/提示

在第一组数据中，数组的原始长度 $n=1$，*Yelisey* 不能对它进行操作。因此最小元素的最大值是 $a_1=10$ 。

在第二组数据中，数组始终只有 $0$。所以，最小元素的最大值为 $a_2=0$。

在第三组数据中，数组的改变过程如下： $\{\color{blue}{-1}$$,2,0\}\to\{ 3,\color{blue}1$$\}\to$ $\{$$\color{blue} {2}$$\}$。所以，最小元素的最大值是 $a_3=2$ 。(当前数组最小的数以蓝色标出）

保证所有询问的数组原始长度 $n$ 之和不超过 $2\cdot 10^5$。

在第四组数据中，数组的改变过程如下：$\{2,10,$$\color{blue}{1}$$,7\}\to\{\color{blue}{1}$$,9,6\}\to\{8,\color {blue}{5}$$\}\to$$\{$$\color{blue}{3}$$\}$。 所以，最小元素的最大值是 $a_4=5$ 。

Translated by @[Aynxul03](https://www.luogu.com.cn/user/267459) & @[li142857](https://www.luogu.com.cn/user/540584)

## 样例 #1

### 输入

```
8
1
10
2
0 0
3
-1 2 0
4
2 10 1 7
2
2 3
5
3 2 -4 -2 0
2
-1 1
1
-2
```

### 输出

```
10
0
2
5
2
2
2
-2
```



---

---
title: "William the Vigilant"
layout: "post"
diff: 普及-
pid: CF1609B
tag: []
---

# William the Vigilant

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1609B/bc27b81066321842bda936f44a55e1a8e3d4f0d8.png)Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is the correct formal description of the homework assignment:

You are given a string $ s $ of length $ n $ only consisting of characters "a", "b" and "c". There are $ q $ queries of format ( $ pos, c $ ), meaning replacing the element of string $ s $ at position $ pos $ with character $ c $ . After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn't contain string "abc" as a substring. A valid replacement of a character is replacing it with "a", "b" or "c".

A string $ x $ is a substring of a string $ y $ if $ x $ can be obtained from $ y $ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.

## 输入格式

The first line contains two integers $ n $ and $ q $ $ (1 \le n, q \le 10^5) $ , the length of the string and the number of queries, respectively.

The second line contains the string $ s $ , consisting of characters "a", "b" and "c".

Each of the next $ q $ lines contains an integer $ i $ and character $ c $ $ (1 \le i \le n) $ , index and the value of the new item in the string, respectively. It is guaranteed that character's $ c $ value is "a", "b" or "c".

## 输出格式

For each query output the minimal number of characters that would have to be replaced so that the string doesn't contain "abc" as a substring.

## 说明/提示

Let's consider the state of the string after each query:

1. $ s = $ "abcabcabc". In this case $ 3 $ replacements can be performed to get, for instance, string $ s = $ "bbcaccabb". This string does not contain "abc" as a substring.
2. $ s = $ "bbcabcabc". In this case $ 2 $ replacements can be performed to get, for instance, string $ s = $ "bbcbbcbbc". This string does not contain "abc" as a substring.
3. $ s = $ "bccabcabc". In this case $ 2 $ replacements can be performed to get, for instance, string $ s = $ "bccbbcbbc". This string does not contain "abc" as a substring.
4. $ s = $ "bcaabcabc". In this case $ 2 $ replacements can be performed to get, for instance, string $ s = $ "bcabbcbbc". This string does not contain "abc" as a substring.
5. $ s = $ "bcabbcabc". In this case $ 1 $ replacements can be performed to get, for instance, string $ s = $ "bcabbcabb". This string does not contain "abc" as a substring.
6. $ s = $ "bcabccabc". In this case $ 2 $ replacements can be performed to get, for instance, string $ s = $ "bcabbcabb". This string does not contain "abc" as a substring.
7. $ s = $ "bcabccaac". In this case $ 1 $ replacements can be performed to get, for instance, string $ s = $ "bcabbcaac". This string does not contain "abc" as a substring.
8. $ s = $ "bcabccaab". In this case $ 1 $ replacements can be performed to get, for instance, string $ s = $ "bcabbcaab". This string does not contain "abc" as a substring.
9. $ s = $ "ccabccaab". In this case $ 1 $ replacements can be performed to get, for instance, string $ s = $ "ccabbcaab". This string does not contain "abc" as a substring.
10. $ s = $ "ccaaccaab". In this case the string does not contain "abc" as a substring and no replacements are needed.

## 样例 #1

### 输入

```
9 10
abcabcabc
1 a
1 b
2 c
3 a
4 b
5 c
8 a
9 b
1 c
4 a
```

### 输出

```
3
2
2
2
1
2
1
1
1
0
```



---

---
title: "Unlucky Ticket"
layout: "post"
diff: 普及-
pid: CF160B
tag: []
---

# Unlucky Ticket

## 题目描述

Each of you probably has your personal experience of riding public transportation and buying tickets. After a person buys a ticket (which traditionally has an even number of digits), he usually checks whether the ticket is lucky. Let us remind you that a ticket is lucky if the sum of digits in its first half matches the sum of digits in its second half.

But of course, not every ticket can be lucky. Far from it! Moreover, sometimes one look at a ticket can be enough to say right away that the ticket is not lucky. So, let's consider the following unluckiness criterion that can definitely determine an unlucky ticket. We'll say that a ticket is definitely unlucky if each digit from the first half corresponds to some digit from the second half so that each digit from the first half is strictly less than the corresponding digit from the second one or each digit from the first half is strictly more than the corresponding digit from the second one. Each digit should be used exactly once in the comparisons. In other words, there is such bijective correspondence between the digits of the first and the second half of the ticket, that either each digit of the first half turns out strictly less than the corresponding digit of the second half or each digit of the first half turns out strictly more than the corresponding digit from the second half.

For example, ticket $ 2421 $ meets the following unluckiness criterion and will not be considered lucky (the sought correspondence is $ 2&gt;1 $ and $ 4&gt;2 $ ), ticket $ 0135 $ also meets the criterion (the sought correspondence is $ 0&lt;3 $ and $ 1&lt;5 $ ), and ticket $ 3754 $ does not meet the criterion.

You have a ticket in your hands, it contains $ 2n $ digits. Your task is to check whether it meets the unluckiness criterion.

## 输入格式

The first line contains an integer $ n $ ( $ 1<=n<=100 $ ). The second line contains a string that consists of $ 2n $ digits and defines your ticket.

## 输出格式

In the first line print "YES" if the ticket meets the unluckiness criterion. Otherwise, print "NO" (without the quotes).

## 样例 #1

### 输入

```
2
2421

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
2
0135

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
2
3754

```

### 输出

```
NO

```



---

---
title: "Kalindrome Array"
layout: "post"
diff: 普及-
pid: CF1610B
tag: []
---

# Kalindrome Array

## 题目描述

An array $ [b_1, b_2, \ldots, b_m] $ is a palindrome, if $ b_i = b_{m+1-i} $ for each $ i $ from $ 1 $ to $ m $ . Empty array is also a palindrome.

An array is called kalindrome, if the following condition holds:

- It's possible to select some integer $ x $ and delete some of the elements of the array equal to $ x $ , so that the remaining array (after gluing together the remaining parts) is a palindrome.

Note that you don't have to delete all elements equal to $ x $ , and you don't have to delete at least one element equal to $ x $ .

For example :

- $ [1, 2, 1] $ is kalindrome because you can simply not delete a single element.
- $ [3, 1, 2, 3, 1] $ is kalindrome because you can choose $ x = 3 $ and delete both elements equal to $ 3 $ , obtaining array $ [1, 2, 1] $ , which is a palindrome.
- $ [1, 2, 3] $ is not kalindrome.

You are given an array $ [a_1, a_2, \ldots, a_n] $ . Determine if $ a $ is kalindrome or not.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the length of the array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le n $ ) — elements of the array.

It's guaranteed that the sum of $ n $ over all test cases won't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print YES if $ a $ is kalindrome and NO otherwise. You can print each letter in any case.

## 说明/提示

In the first test case, array $ [1] $ is already a palindrome, so it's a kalindrome as well.

In the second test case, we can choose $ x = 2 $ , delete the second element, and obtain array $ [1] $ , which is a palindrome.

In the third test case, it's impossible to obtain a palindrome.

In the fourth test case, you can choose $ x = 4 $ and delete the fifth element, obtaining $ [1, 4, 4, 1] $ . You also can choose $ x = 1 $ , delete the first and the fourth elements, and obtain $ [4, 4, 4] $ .

## 样例 #1

### 输入

```
4
1
1
2
1 2
3
1 2 3
5
1 4 4 1 4
```

### 输出

```
YES
YES
NO
YES
```



---

---
title: "Team Composition: Programmers and Mathematicians"
layout: "post"
diff: 普及-
pid: CF1611B
tag: []
---

# Team Composition: Programmers and Mathematicians

## 题目描述

The All-Berland Team Programming Contest will take place very soon. This year, teams of four are allowed to participate.

There are $ a $ programmers and $ b $ mathematicians at Berland State University. How many maximum teams can be made if:

- each team must consist of exactly $ 4 $ students,
- teams of $ 4 $ mathematicians or $ 4 $ programmers are unlikely to perform well, so the decision was made not to compose such teams.

Thus, each team must have at least one programmer and at least one mathematician.

Print the required maximum number of teams. Each person can be a member of no more than one team.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) —the number of test cases.

This is followed by descriptions of $ t $ sets, one per line. Each set is given by two integers $ a $ and $ b $ ( $ 0 \le a,b \le 10^9 $ ).

## 输出格式

Print $ t $ lines. Each line must contain the answer to the corresponding set of input data — the required maximum number of teams.

## 说明/提示

In the first test case of the example, two teams can be composed. One way to compose two teams is to compose two teams of $ 2 $ programmers and $ 2 $ mathematicians.

In the second test case of the example, only one team can be composed: $ 3 $ programmers and $ 1 $ mathematician in the team.

## 样例 #1

### 输入

```
6
5 5
10 1
2 3
0 0
17 2
1000000000 1000000000
```

### 输出

```
2
1
1
0
2
500000000
```



---

---
title: "Polycarp Recovers the Permutation"
layout: "post"
diff: 普及-
pid: CF1611C
tag: []
---

# Polycarp Recovers the Permutation

## 题目描述

Polycarp wrote on a whiteboard an array $ p $ of length $ n $ , which is a permutation of numbers from $ 1 $ to $ n $ . In other words, in $ p $ each number from $ 1 $ to $ n $ occurs exactly once.

He also prepared a resulting array $ a $ , which is initially empty (that is, it has a length of $ 0 $ ).

After that, he did exactly $ n $ steps. Each step looked like this:

- Look at the leftmost and rightmost elements of $ p $ , and pick the smaller of the two.
- If you picked the leftmost element of $ p $ , append it to the left of $ a $ ; otherwise, if you picked the rightmost element of $ p $ , append it to the right of $ a $ .
- The picked element is erased from $ p $ .

Note that on the last step, $ p $ has a length of $ 1 $ and its minimum element is both leftmost and rightmost. In this case, Polycarp can choose what role the minimum element plays. In other words, this element can be added to $ a $ both on the left and on the right (at the discretion of Polycarp).

Let's look at an example. Let $ n=4 $ , $ p=[3, 1, 4, 2] $ . Initially $ a=[] $ . Then:

- During the first step, the minimum is on the right (with a value of $ 2 $ ), so after this step, $ p=[3,1,4] $ and $ a=[2] $ (he added the value $ 2 $ to the right).
- During the second step, the minimum is on the left (with a value of $ 3 $ ), so after this step, $ p=[1,4] $ and $ a=[3,2] $ (he added the value $ 3 $ to the left).
- During the third step, the minimum is on the left (with a value of $ 1 $ ), so after this step, $ p=[4] $ and $ a=[1,3,2] $ (he added the value $ 1 $ to the left).
- During the fourth step, the minimum is both left and right (this value is $ 4 $ ). Let's say Polycarp chose the right option. After this step, $ p=[] $ and $ a=[1,3,2,4] $ (he added the value $ 4 $ to the right).

Thus, a possible value of $ a $ after $ n $ steps could be $ a=[1,3,2,4] $ .

You are given the final value of the resulting array $ a $ . Find any possible initial value for $ p $ that can result the given $ a $ , or determine that there is no solution.

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test.

Each test case consists of two lines. The first of them contains an integer $ n $ ( $ 1 \le n \le 2\cdot10^5 $ ) — the length of the array $ a $ . The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ) — the elements of the array $ a $ . All elements of the $ a $ array are distinct numbers.

It is guaranteed that the sum of the values $ n $ over all test cases in the test does not exceed $ 2\cdot10^5 $ .

## 输出格式

Print $ t $ lines, each of the lines must contain the answer to the corresponding set of input data: numbers $ p_1, p_2, \dots, p_n $ — any of the possible initial values of the array $ p $ , which will lead to the given array $ a $ . All elements of $ p $ are distinct integers from $ 1 $ to $ n $ . Thus, if there are several solutions, print any. If there is no solution, then print -1 on the line.

## 说明/提示

The first test case in the example is clarified in the main section of the problem statement. There may be other correct answers for this test set.

In the second test case, $ n=1 $ . Thus, there is only one permutation that can be the answer: $ p=[1] $ . Indeed, this is the answer to this test case.

In the third test case of the example, no matter what permutation you take as $ p $ , after applying the $ n $ steps, the result will differ from $ a=[1, 3, 5, 4, 2] $ .

## 样例 #1

### 输入

```
4
4
1 3 2 4
1
1
5
1 3 5 4 2
3
3 2 1
```

### 输出

```
3 1 4 2
1
-1
2 3 1
```



---

---
title: "Long Comparison"
layout: "post"
diff: 普及-
pid: CF1613A
tag: []
---

# Long Comparison

## 题目描述

Monocarp 在一个黑板上写下了两个数。每一个数都用两个整数 $x,p$ 表示，表示其值为 $x$ 后有 $p$ 个 $0$。Monocarp 想让你比较这两个数的大小。

## 输入格式

第一行一个整数 $t$（$1\leq t\leq {10}^{4}$），表示数据的组数。

对于每组数据，有以下两行输入。

第一行两个整数 $x_{1},p_{1}$（$1\leq x_{1}\leq 10^{6}$，$0\leq p_{1}\leq 10^{6}$），表示第一个数。

第二行两个整数 $x_{2},p_{2}$（$1\leq x_{2}\leq 10^{6}$，$0\leq p_{2}\leq 10^{6}$），表示第二个数。

## 输出格式

对于每组数据，若第一个数大于第二个数，输出 `>`；若第一个数等于第二个数，输出 `=`；若第一个数小于第二个数，输出 `<`。

## 说明/提示

样例中的五组数分别为 $20\gt 19,1000=1000,1999\lt 2000,1=1,99\lt 100$。

By @[雨伞CKY](/user/415445)

## 样例 #1

### 输入

```
5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2
```

### 输出

```
&gt;
=
&lt;
=
&lt;
```



---

---
title: "Absent Remainder"
layout: "post"
diff: 普及-
pid: CF1613B
tag: []
---

# Absent Remainder

## 题目描述

You are given a sequence $ a_1, a_2, \dots, a_n $ consisting of $ n $ pairwise distinct positive integers.

Find $ \left\lfloor \frac n 2 \right\rfloor $ different pairs of integers $ x $ and $ y $ such that:

- $ x \neq y $ ;
- $ x $ and $ y $ appear in $ a $ ;
- $ x~mod~y $ doesn't appear in $ a $ .

Note that some $ x $ or $ y $ can belong to multiple pairs.

 $ \lfloor x \rfloor $ denotes the floor function — the largest integer less than or equal to $ x $ . $ x~mod~y $ denotes the remainder from dividing $ x $ by $ y $ .

If there are multiple solutions, print any of them. It can be shown that at least one solution always exists.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains a single integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ) — the length of the sequence.

The second line of each testcase contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^6 $ ).

All numbers in the sequence are pairwise distinct. The sum of $ n $ over all testcases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

The answer for each testcase should contain $ \left\lfloor \frac n 2 \right\rfloor $ different pairs of integers $ x $ and $ y $ such that $ x \neq y $ , $ x $ and $ y $ appear in $ a $ and $ x~mod~y $ doesn't appear in $ a $ . Print the pairs one after another.

You can print the pairs in any order. However, the order of numbers in the pair should be exactly such that the first number is $ x $ and the second number is $ y $ . All pairs should be pairwise distinct.

If there are multiple solutions, print any of them.

## 说明/提示

In the first testcase there are only two pairs: $ (1, 4) $ and $ (4, 1) $ . $ \left\lfloor \frac 2 2 \right\rfloor=1 $ , so we have to find one pair. $ 1~mod~4=1 $ , and $ 1 $ appears in $ a $ , so that pair is invalid. Thus, the only possible answer is a pair $ (4, 1) $ .

In the second testcase, we chose pairs $ 8~mod~2=0 $ and $ 8~mod~4=0 $ . $ 0 $ doesn't appear in $ a $ , so that answer is valid. There are multiple possible answers for that testcase.

In the third testcase, the chosen pairs are $ 9~mod~5=4 $ and $ 7~mod~5=2 $ . Neither $ 4 $ , nor $ 2 $ , appears in $ a $ , so that answer is valid.

## 样例 #1

### 输入

```
4
2
1 4
4
2 8 3 4
5
3 8 5 9 7
6
2 7 5 3 4 8
```

### 输出

```
4 1
8 2
8 4
9 5
7 5
8 7
4 3
5 2
```



---

---
title: "Divan and a Store"
layout: "post"
diff: 普及-
pid: CF1614A
tag: []
---

# Divan and a Store

## 题目描述

给定一个长为 $n$ 的数组 $a$，从中选出若干个在 $[l,r]$ 区间的数，使得总和不大于 $k$。求最多个数。

## 输入格式

第一行一个 $t$，表示数据组数。

每一组数据中：

第一行有四个整数  $ n $ , $ l $ , $ r $ , $ k $ ( $ 1 \le n \le 100 $ , $ 1 \le l \le r \le 10^9 $ , $ 1 \le k \le 10^9 $ )。

第二行有 $n$ 个整数，表示数组 $a$。

## 输出格式

对于每一组数据输出一行一个整数，表示最大个数。

## 样例 #1

### 输入

```
8
3 1 100 100
50 100 50
6 3 5 10
1 2 3 4 5 6
6 3 5 21
1 2 3 4 5 6
10 50 69 100
20 30 40 77 1 1 12 4 70 10000
3 50 80 30
20 60 70
10 2 7 100
2 2 2 2 2 7 7 7 7 7
4 1000000000 1000000000 1000000000
1000000000 1000000000 1000000000 1000000000
1 1 1 1
1
```

### 输出

```
2
2
3
0
0
10
1
1
```



---

---
title: "Divan and a New Project"
layout: "post"
diff: 普及-
pid: CF1614B
tag: []
---

# Divan and a New Project

## 题目描述

有 $n + 1$ 座的建筑，编号从 $0\sim n$。

有一个人从编号为 $0$ 的建筑出发， 分别要去编号为 $i$ 的建筑 $a_i$ 次。

设编号为 $i$ 的建筑坐标为 $x_i$， 这个人往返编号为 $i$ 的建筑一趟花费的时间为 $2 \times|x_i - x_0|$ 。

求如何安排这 $n + 1$ 座建筑的坐标， 使这个人在路上花费的总时间最小。

## 输入格式

输入第一行一个整数 $t$，表示有 $t$ 组数据。

每组数据第一行一个整数 $n$， 第二行 $n$ 个数， 分别表示 $a_1$ …… $a_n$。

## 输出格式

每组数据输出共两行，第一行一个整数，表示最小要花费的总时间。第二行 $n + 1$ 个整数， 表示使总时间花费最小的 $x_0$ …… $x_n$。如果有多组符合条件的解，输出任意一组即可。

## 说明/提示

对于 $100\%$ 的数据，$1 \le t \le 10^3$，$1 \le n \le 2 \cdot 10^5$，$\sum n \le 2 \cdot 10^5$，$0 \le a_i \le 10^6$，$-10^6 \le x_i \le 10^6$。

## 样例 #1

### 输入

```
4
3
1 2 3
5
3 8 10 6 1
5
1 1 1 1 1
1
0
```

### 输出

```
14
2 4 1 3
78
1 -1 0 2 3 4
18
3 6 1 5 2 4
0
1 2
```



---

---
title: "Paint the Array"
layout: "post"
diff: 普及-
pid: CF1618C
tag: []
---

# Paint the Array

## 题目描述

You are given an array $ a $ consisting of $ n $ positive integers. You have to choose a positive integer $ d $ and paint all elements into two colors. All elements which are divisible by $ d $ will be painted red, and all other elements will be painted blue.

The coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array. Your task is to find any value of $ d $ which yields a beautiful coloring, or report that it is impossible.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of testcases.

The first line of each testcase contains one integer $ n $ ( $ 2 \le n \le 100 $ ) — the number of elements of the array.

The second line of each testcase contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^{18} $ ).

## 输出格式

For each testcase print a single integer. If there is no such value of $ d $ that yields a beautiful coloring, print $ 0 $ . Otherwise, print any suitable value of $ d $ ( $ 1 \le d \le 10^{18} $ ).

## 样例 #1

### 输入

```
5
5
1 2 3 4 5
3
10 5 15
3
100 10 200
10
9 8 2 6 6 2 8 6 5 4
2
1 3
```

### 输出

```
2
0
100
0
3
```



---

---
title: "Berland Music"
layout: "post"
diff: 普及-
pid: CF1622B
tag: []
---

# Berland Music

## 题目描述

Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.

So imagine Monocarp got recommended $ n $ songs, numbered from $ 1 $ to $ n $ . The $ i $ -th song had its predicted rating equal to $ p_i $ , where $ 1 \le p_i \le n $ and every integer from $ 1 $ to $ n $ appears exactly once. In other words, $ p $ is a permutation.

After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string $ s $ , such that $ s_i=0 $ means that he disliked the $ i $ -th song, and $ s_i=1 $ means that he liked it.

Now the service has to re-evaluate the song ratings in such a way that:

- the new ratings $ q_1, q_2, \dots, q_n $ still form a permutation ( $ 1 \le q_i \le n $ ; each integer from $ 1 $ to $ n $ appears exactly once);
- every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all $ i, j $ such that $ s_i=1 $ and $ s_j=0 $ , $ q_i>q_j $ should hold).

Among all valid permutations $ q $ find the one that has the smallest value of $ \sum\limits_{i=1}^n |p_i-q_i| $ , where $ |x| $ is an absolute value of $ x $ .

Print the permutation $ q_1, q_2, \dots, q_n $ . If there are multiple answers, you can print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of songs.

The second line of each testcase contains $ n $ integers $ p_1, p_2, \dots, p_n $ ( $ 1 \le p_i \le n $ ) — the permutation of the predicted ratings.

The third line contains a single string $ s $ , consisting of $ n $ characters. Each character is either a $ 0 $ or a $ 1 $ . $ 0 $ means that Monocarp disliked the song, and $ 1 $ means that he liked it.

The sum of $ n $ over all testcases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each testcase, print a permutation $ q $ — the re-evaluated ratings of the songs. If there are multiple answers such that $ \sum\limits_{i=1}^n |p_i-q_i| $ is minimum possible, you can print any of them.

## 说明/提示

In the first testcase, there exists only one permutation $ q $ such that each liked song is rating higher than each disliked song: song $ 1 $ gets rating $ 2 $ and song $ 2 $ gets rating $ 1 $ . $ \sum\limits_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2 $ .

In the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to $ p $ . Its cost is $ 0 $ .

## 样例 #1

### 输入

```
3
2
1 2
10
3
3 1 2
111
8
2 3 1 8 5 4 7 6
01110001
```

### 输出

```
2 1
3 1 2
1 6 5 8 3 2 4 7
```



---

---
title: "Game on Ranges"
layout: "post"
diff: 普及-
pid: CF1623B
tag: []
---

# Game on Ranges

## 题目描述

Alice and Bob play the following game. Alice has a set $ S $ of disjoint ranges of integers, initially containing only one range $ [1, n] $ . In one turn, Alice picks a range $ [l, r] $ from the set $ S $ and asks Bob to pick a number in the range. Bob chooses a number $ d $ ( $ l \le d \le r $ ). Then Alice removes $ [l, r] $ from $ S $ and puts into the set $ S $ the range $ [l, d - 1] $ (if $ l \le d - 1 $ ) and the range $ [d + 1, r] $ (if $ d + 1 \le r $ ). The game ends when the set $ S $ is empty. We can show that the number of turns in each game is exactly $ n $ .

After playing the game, Alice remembers all the ranges $ [l, r] $ she picked from the set $ S $ , but Bob does not remember any of the numbers that he picked. But Bob is smart, and he knows he can find out his numbers $ d $ from Alice's ranges, and so he asks you for help with your programming skill.

Given the list of ranges that Alice has picked ( $ [l, r] $ ), for each range, help Bob find the number $ d $ that Bob has picked.

We can show that there is always a unique way for Bob to choose his number for a list of valid ranges picked by Alice.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 1000 $ ).

Each of the next $ n $ lines contains two integers $ l $ and $ r $ ( $ 1 \le l \le r \le n $ ), denoting the range $ [l, r] $ that Alice picked at some point.

Note that the ranges are given in no particular order.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 1000 $ , and the ranges for each test case are from a valid game.

## 输出格式

For each test case print $ n $ lines. Each line should contain three integers $ l $ , $ r $ , and $ d $ , denoting that for Alice's range $ [l, r] $ Bob picked the number $ d $ .

You can print the lines in any order. We can show that the answer is unique.

It is not required to print a new line after each test case. The new lines in the output of the example are for readability only.

## 说明/提示

In the first test case, there is only 1 range $ [1, 1] $ . There was only one range $ [1, 1] $ for Alice to pick, and there was only one number $ 1 $ for Bob to pick.

In the second test case, $ n = 3 $ . Initially, the set contains only one range $ [1, 3] $ .

- Alice picked the range $ [1, 3] $ . Bob picked the number $ 1 $ . Then Alice put the range $ [2, 3] $ back to the set, which after this turn is the only range in the set.
- Alice picked the range $ [2, 3] $ . Bob picked the number $ 3 $ . Then Alice put the range $ [2, 2] $ back to the set.
- Alice picked the range $ [2, 2] $ . Bob picked the number $ 2 $ . The game ended.

In the fourth test case, the game was played with $ n = 5 $ . Initially, the set contains only one range $ [1, 5] $ . The game's turn is described in the following table.

 Game turnAlice's picked rangeBob's picked numberThe range set afterBefore the game start $  \{ [1, 5] \}  $ 1 $ [1, 5] $  $ 3 $  $  \{ [1, 2], [4, 5] \} $ 2 $ [1, 2] $  $ 1 $  $  \{ [2, 2], [4, 5] \}  $ 3 $ [4, 5] $  $ 5 $  $  \{ [2, 2], [4, 4] \}  $ 4 $ [2, 2] $  $ 2 $  $  \{ [4, 4] \}  $ 5 $ [4, 4] $  $ 4 $  $  \{ \}  $ (empty set)

## 样例 #1

### 输入

```
4
1
1 1
3
1 3
2 3
2 2
6
1 1
3 5
4 4
3 6
4 5
1 6
5
1 5
1 2
4 5
2 2
4 4
```

### 输出

```
1 1 1

1 3 1
2 2 2
2 3 3

1 1 1
3 5 3
4 4 4
3 6 6
4 5 5
1 6 2

1 5 3
1 2 1
4 5 5
2 2 2
4 4 4
```



---

---
title: "Elementary Particles"
layout: "post"
diff: 普及-
pid: CF1625B
tag: []
---

# Elementary Particles

## 题目描述

Martians are actively engaged in interplanetary trade. Olymp City, the Martian city known for its spaceport, has become a place where goods from all the corners of our Galaxy come. To deliver even more freight from faraway planets, Martians need fast spaceships.

A group of scientists conducts experiments to build a fast engine for the new spaceship. In the current experiment, there are $ n $ elementary particles, the $ i $ -th of them has type $ a_i $ .

Denote a subsegment of the particle sequence ( $ a_1, a_2, \dots, a_n $ ) as a sequence ( $ a_l, a_{l+1}, \dots, a_r $ ) for some left bound $ l $ and right bound $ r $ ( $ 1 \le l \le r \le n $ ). For instance, the sequence $ (1\ 4\ 2\ 8\ 5\ 7) $ for $ l=2 $ and $ r=4 $ has the sequence $ (4\ 2\ 8) $ as a subsegment. Two subsegments are considered different if at least one bound of those subsegments differs.

Note that the subsegments can be equal as sequences but still considered different. For example, consider the sequence $ (1\ 1\ 1\ 1\ 1) $ and two of its subsegments: one with $ l=1 $ and $ r=3 $ and another with $ l=2 $ and $ r=4 $ . Both subsegments are equal to $ (1\ 1\ 1) $ , but still considered different, as their left and right bounds differ.

The scientists want to conduct a reaction to get two different subsegments of the same length. Denote this length $ k $ . The resulting pair of subsegments must be harmonious, i. e. for some $ i $ ( $ 1 \le i \le k $ ) it must be true that the types of particles on the $ i $ -th position are the same for these two subsegments. For example, the pair $ (1\ 7\ 3) $ and $ (4\ 7\ 8) $ is harmonious, as both subsegments have $ 7 $ on the second position. The pair $ (1\ 2\ 3) $ and $ (3\ 1\ 2) $ is not harmonious.

The longer are harmonious subsegments, the more chances for the scientists to design a fast engine. So, they asked you to calculate the maximal possible length of harmonious pair made of different subsegments.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. The following are descriptions of the test cases.

The first line contains an integer $ n $ ( $ 2 \le n \le 150\,000 $ ) — the amount of elementary particles in the sequence.

The second line contains $ n $ integers $ a_i $ ( $ 1 \le a_i \le 150\,000 $ ) — types of elementary particles.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 3\cdot10^5 $ .

## 输出格式

For each test, print a single integer, maximal possible length of harmonious pair made of different subsegments. If such pair does not exist, print $ -1 $ instead.

## 说明/提示

The first test case is shown on the picture below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1625B/8f8e2ae794791a59d3657c5398bdb22d42498124.png)As you can see from it, you may choose the subsegments $ (2\ 1\ 3\ 4) $ and $ (3\ 1\ 5\ 2) $ , which are a harmonious pair. Their length is equal to $ 4 $ , so the answer is $ 4 $ .

In the second test case, you need to take two subsegments: one with $ l=1 $ and $ r=5 $ , and one with $ l=2 $ and $ r=6 $ . It's not hard to observe that these segments are a harmonious pair and considered different even though they are both equal to $ (1\ 1\ 1\ 1\ 1) $ .

In the third test case, you cannot make a harmonious pair, so the answer is $ -1 $ .

## 样例 #1

### 输入

```
4
7
3 1 5 2 1 3 4
6
1 1 1 1 1 1
6
1 4 2 8 5 7
2
15 15
```

### 输出

```
4
5
-1
1
```



---

---
title: "Minor Reduction"
layout: "post"
diff: 普及-
pid: CF1626B
tag: []
---

# Minor Reduction

## 题目描述

You are given a decimal representation of an integer $ x $ without leading zeros.

You have to perform the following reduction on it exactly once: take two neighboring digits in $ x $ and replace them with their sum without leading zeros (if the sum is $ 0 $ , it's represented as a single $ 0 $ ).

For example, if $ x = 10057 $ , the possible reductions are:

- choose the first and the second digits $ 1 $ and $ 0 $ , replace them with $ 1+0=1 $ ; the result is $ 1057 $ ;
- choose the second and the third digits $ 0 $ and $ 0 $ , replace them with $ 0+0=0 $ ; the result is also $ 1057 $ ;
- choose the third and the fourth digits $ 0 $ and $ 5 $ , replace them with $ 0+5=5 $ ; the result is still $ 1057 $ ;
- choose the fourth and the fifth digits $ 5 $ and $ 7 $ , replace them with $ 5+7=12 $ ; the result is $ 10012 $ .

What's the largest number that can be obtained?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

Each testcase consists of a single integer $ x $ ( $ 10 \le x < 10^{200000} $ ). $ x $ doesn't contain leading zeros.

The total length of the decimal representations of $ x $ over all testcases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each testcase, print a single integer — the largest number that can be obtained after the reduction is applied exactly once. The number should not contain leading zeros.

## 说明/提示

The first testcase of the example is already explained in the statement.

In the second testcase, there is only one possible reduction: the first and the second digits.

## 样例 #1

### 输入

```
2
10057
90
```

### 输出

```
10012
9
```



---

---
title: "Fun with Even Subarrays"
layout: "post"
diff: 普及-
pid: CF1631B
tag: []
---

# Fun with Even Subarrays

## 题目描述

You are given an array $ a $ of $ n $ elements. You can apply the following operation to it any number of times:

- Select some subarray from $ a $ of even size $ 2k $ that begins at position $ l $ ( $ 1\le l \le l+2\cdot{k}-1\le n $ , $ k \ge 1 $ ) and for each $ i $ between $ 0 $ and $ k-1 $ (inclusive), assign the value $ a_{l+k+i} $ to $ a_{l+i} $ .

For example, if $ a = [2, 1, 3, 4, 5, 3] $ , then choose $ l = 1 $ and $ k = 2 $ , applying this operation the array will become $ a = [3, 4, 3, 4, 5, 3] $ .

Find the minimum number of operations (possibly zero) needed to make all the elements of the array equal.

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 2 \cdot 10^4 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the length of the array.

The second line of each test case consists of $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq n $ ) — the elements of the array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

Print $ t $ lines, each line containing the answer to the corresponding test case — the minimum number of operations needed to make equal all the elements of the array with the given operation.

## 说明/提示

In the first test, all elements are equal, therefore no operations are needed.

In the second test, you can apply one operation with $ k=1 $ and $ l=1 $ , set $ a_1 := a_2 $ , and the array becomes $ [1, 1] $ with $ 1 $ operation.

In the third test, you can apply one operation with $ k=1 $ and $ l=4 $ , set $ a_4 := a_5 $ , and the array becomes $ [4, 4, 4, 4, 4] $ .

In the fourth test, you can apply one operation with $ k=1 $ and $ l=3 $ , set $ a_3 := a_4 $ , and the array becomes $ [4, 2, 3, 3] $ , then you can apply another operation with $ k=2 $ and $ l=1 $ , set $ a_1 := a_3 $ , $ a_2 := a_4 $ , and the array becomes $ [3, 3, 3, 3] $ .

In the fifth test, there is only one element, therefore no operations are needed.

## 样例 #1

### 输入

```
5
3
1 1 1
2
2 1
5
4 4 4 2 4
4
4 2 1 3
1
1
```

### 输出

```
0
1
1
2
0
```



---

---
title: "Roof Construction"
layout: "post"
diff: 普及-
pid: CF1632B
tag: []
---

# Roof Construction

## 题目描述

It has finally been decided to build a roof over the football field in School 179. Its construction will require placing $ n $ consecutive vertical pillars. Furthermore, the headmaster wants the heights of all the pillars to form a permutation $ p $ of integers from $ 0 $ to $ n - 1 $ , where $ p_i $ is the height of the $ i $ -th pillar from the left $ (1 \le i \le n) $ .

As the chief, you know that the cost of construction of consecutive pillars is equal to the maximum value of the bitwise XOR of heights of all pairs of adjacent pillars. In other words, the cost of construction is equal to $ \max\limits_{1 \le i \le n - 1}{p_i \oplus p_{i + 1}} $ , where $ \oplus $ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Find any sequence of pillar heights $ p $ of length $ n $ with the smallest construction cost.

In this problem, a permutation is an array consisting of $ n $ distinct integers from $ 0 $ to $ n - 1 $ in arbitrary order. For example, $ [2,3,1,0,4] $ is a permutation, but $ [1,0,1] $ is not a permutation ( $ 1 $ appears twice in the array) and $ [1,0,3] $ is also not a permutation ( $ n=3 $ , but $ 3 $ is in the array).

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). Description of the test cases follows.

The only line for each test case contains a single integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ) — the number of pillars for the construction of the roof.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case print $ n $ integers $ p_1 $ , $ p_2 $ , $ \ldots $ , $ p_n $ — the sequence of pillar heights with the smallest construction cost.

If there are multiple answers, print any of them.

## 说明/提示

For $ n = 2 $ there are $ 2 $ sequences of pillar heights:

- $ [0, 1] $ — cost of construction is $ 0 \oplus 1 = 1 $ .
- $ [1, 0] $ — cost of construction is $ 1 \oplus 0 = 1 $ .

For $ n = 3 $ there are $ 6 $ sequences of pillar heights:

- $ [0, 1, 2] $ — cost of construction is $ \max(0 \oplus 1, 1 \oplus 2) = \max(1, 3) = 3 $ .
- $ [0, 2, 1] $ — cost of construction is $ \max(0 \oplus 2, 2 \oplus 1) = \max(2, 3) = 3 $ .
- $ [1, 0, 2] $ — cost of construction is $ \max(1 \oplus 0, 0 \oplus 2) = \max(1, 2) = 2 $ .
- $ [1, 2, 0] $ — cost of construction is $ \max(1 \oplus 2, 2 \oplus 0) = \max(3, 2) = 3 $ .
- $ [2, 0, 1] $ — cost of construction is $ \max(2 \oplus 0, 0 \oplus 1) = \max(2, 1) = 2 $ .
- $ [2, 1, 0] $ — cost of construction is $ \max(2 \oplus 1, 1 \oplus 0) = \max(3, 1) = 3 $ .

## 样例 #1

### 输入

```
4
2
3
5
10
```

### 输出

```
0 1
2 0 1
3 2 1 0 4
4 6 3 2 0 8 9 1 7 5
```



---

---
title: "Differential Sorting"
layout: "post"
diff: 普及-
pid: CF1635C
tag: []
---

# Differential Sorting

## 题目描述

You are given an array $ a $ of $ n $ elements.

Your can perform the following operation no more than $ n $ times: Select three indices $ x,y,z $ $ (1 \leq x < y < z \leq n) $ and replace $ a_x $ with $ a_y - a_z $ . After the operation, $ |a_x| $ need to be less than $ 10^{18} $ .

Your goal is to make the resulting array non-decreasing. If there are multiple solutions, you can output any. If it is impossible to achieve, you should report it as well.

## 输入格式

Each test contains multiple test cases. The first line will contain a single integer $ t $ $ (1 \leq t \leq 10000) $ — the number of test cases. Then $ t $ test cases follow.

The first line of each test case contains a single integer $ n $ $ (3 \leq n \leq 2 \cdot 10^5) $ — the size of the array $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots ,a_n $ $ (-10^9 \leq a_i \leq 10^9) $ , the elements of $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print $ -1 $ in a single line if there is no solution. Otherwise in the first line you should print a single integer $ m $ $ (0 \leq m \leq n) $ — number of operations you performed.

Then the $ i $ -th of the following $ m $ lines should contain three integers $ x,y,z $ $ (1 \leq x < y < z \leq n) $ — description of the $ i $ -th operation.

If there are multiple solutions, you can output any. Note that you don't have to minimize the number of operations in this task.

## 说明/提示

In the first example, the array becomes

 $ [-6,-4,2,-1,2] $ after the first operation,

 $ [-6,-4,-3,-1,2] $ after the second operation.

In the second example, it is impossible to make the array sorted after any sequence of operations.

In the third example, the array is already sorted, so we don't need to perform any operations.

## 样例 #1

### 输入

```
3
5
5 -4 2 -1 2
3
4 3 2
3
-3 -2 -1
```

### 输出

```
2
1 2 3
3 4 5
-1
0
```



---

---
title: "MEX and Array"
layout: "post"
diff: 普及-
pid: CF1637B
tag: []
---

# MEX and Array

## 题目描述

Let there be an array $ b_1, b_2, \ldots, b_k $ . Let there be a partition of this array into segments $ [l_1; r_1], [l_2; r_2], \ldots, [l_c; r_c] $ , where $ l_1 = 1 $ , $ r_c = k $ , and for any $ 2 \leq i \leq c $ holds that $ r_{i-1} + 1 = l_i $ . In other words, each element of the array belongs to exactly one segment.

Let's define the cost of a partition as $c + \sum_{i = 1}^{c} \operatorname{mex}(\{b_{l_i}, b_{l_i + 1}, \ldots, b_{r_i}\}), $  where  $ \\operatorname{mex} $  of a set of numbers  $ S $  is the smallest non-negative integer that does not occur in the set  $ S $ . In other words, the cost of a partition is the number of segments plus the sum of MEX over all segments. Let's define the value of an array  $ b_1, b_2, \ldots, b_k $  as the maximum possible cost over all partitions of this array. You are given an array  $ a $  of size  $ n $ . Find the sum of values of all its subsegments.An array  $ x $  is a subsegment of an array  $ y $  if  $ x $  can be obtained from  $ y$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

## 输入格式

The input contains several test cases. The first line contains one integer $ t $ ( $ 1 \leq t \leq 30 $ ) — the number of test cases.

The first line for each test case contains one integer $ n $ ( $ 1 \leq n \leq 100 $ ) — the length of the array.

The second line contains a sequence of integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \leq a_i \leq 10^9 $ ) — the array elements.

It is guaranteed that the sum of the values $ n $ over all test cases does not exceed $ 100 $ .

## 输出格式

For each test case print a single integer — the answer to the problem.

## 说明/提示

In the second test case:

- The best partition for the subsegment $ [2, 0, 1] $ : $ [2], [0, 1] $ . The cost of this partition equals to $ 2 + \operatorname{mex}(\{2\}) + \operatorname{mex}(\{0, 1\}) = 2 + 0 + 2 = 4 $ .
- The best partition for the subsegment $ [2, 0] $ : $ [2], [0] $ . The cost of this partition equals to $ 2 + \operatorname{mex}(\{2\}) + \operatorname{mex}(\{0\}) = 2 + 0 + 1 = 3 $
- The best partition for the subsegment $ [2] $ : $ [2] $ . The cost of this partition equals to $ 1 + \operatorname{mex}(\{2\}) = 1 + 0 = 1 $ .
- The best partition for the subsegment $ [0, 1] $ : $ [0, 1] $ . The cost of this partition equals to $ 1 + \operatorname{mex}(\{0, 1\}) = 1 + 2 = 3 $ .
- The best partition for the subsegment $ [0] $ : $ [0] $ . The cost of this partition equals to $ 1 + \operatorname{mex}(\{0\}) = 1 + 1 = 2 $ .
- The best partition for the subsegment $ [1] $ : $ [1] $ . The cost of this partition equals to $ 1 + \operatorname{mex}(\{1\}) = 1 + 0 = 1 $ .

The sum of values over all subsegments equals to $ 4 + 3 + 1 + 3 + 2 + 1 = 14 $ .

## 样例 #1

### 输入

```
4
2
1 2
3
2 0 1
4
2 0 5 1
5
0 1 1 0 1
```

### 输出

```
4
14
26
48
```



---

---
title: "Reverse"
layout: "post"
diff: 普及-
pid: CF1638A
tag: []
---

# Reverse

## 题目描述

You are given a permutation $ p_1, p_2, \ldots, p_n $ of length $ n $ . You have to choose two integers $ l,r $ ( $ 1 \le l \le r \le n $ ) and reverse the subsegment $ [l,r] $ of the permutation. The permutation will become $ p_1,p_2, \dots, p_{l-1},p_r,p_{r-1}, \dots, p_l,p_{r+1},p_{r+2}, \dots ,p_n $ .

Find the lexicographically smallest permutation that can be obtained by performing exactly one reverse operation on the initial permutation.

Note that for two distinct permutations of equal length $ a $ and $ b $ , $ a $ is lexicographically smaller than $ b $ if at the first position they differ, $ a $ has the smaller element.

A permutation is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array) and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array).

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 500 $ ) — the length of the permutation.

The second line of each test case contains $ n $ integers $ p_1, p_2, \dots, p_n $ ( $ 1 \le p_i \le n $ ) — the elements of the permutation.

## 输出格式

For each test case print the lexicographically smallest permutation you can obtain.

## 说明/提示

In the first test case, the permutation has length $ 1 $ , so the only possible segment is $ [1,1] $ . The resulting permutation is $ [1] $ .

In the second test case, we can obtain the identity permutation by reversing the segment $ [1,2] $ . The resulting permutation is $ [1,2,3] $ .

In the third test case, the best possible segment is $ [2,3] $ . The resulting permutation is $ [1,2,4,3] $ .

In the fourth test case, there is no lexicographically smaller permutation, so we can leave it unchanged by choosing the segment $ [1,1] $ . The resulting permutation is $ [1,2,3,4,5] $ .

## 样例 #1

### 输入

```
4
1
1
3
2 1 3
4
1 4 2 3
5
1 2 3 4 5
```

### 输出

```
1 
1 2 3 
1 2 4 3 
1 2 3 4 5
```



---

---
title: "Odd Swap Sort"
layout: "post"
diff: 普及-
pid: CF1638B
tag: []
---

# Odd Swap Sort

## 题目描述

#### 题目大意

给定一个数列 $a_1,a_2,...,a_n$ 。

你可以执行若干次如下的操作：

- 选择一个整数 $i\ (\ 1\leq i< n\ )$ ，如果 $a_i+a_{i+1}$ 为奇数，交换 $a_i$ 和 $a_{i+1}$ 。

问是否可以将该数列排序成单调不降数列。

## 输入格式

第一行一个整数 $t\ (\ 1\leq t\leq 10^5\ )$ ，表示测试组数。

每组第一行一个整数 $n\ (\ 1\leq n\leq 10^5)$ ，表示数列的长度。

每组第二行 $n$ 个整数 $a_1,a_2,...,a_n\ (\ 1\leq a_i\leq 10^9\ )$ ，表示给定的数列。

可以保证 $t$ 组测试的 $n$ 的和不超过 $2·10^5$ 。

## 输出格式

共 $t$ 行。

对于每组测试，如果你可以将该数列排序成单调不降数列，输出 ``Yes`` ；否则，输出 ``No`` 。

#### 样例解释

- 第一组测试，可以交换 $31$ 和 $14$ （ $31+14=45$ 是奇数）然后得到单调不降数列 $[1,6,14,31]$ 。
- 第二组测试，我们想要得到单调不降数列就一定要交换 $4$ 和 $2$ ，但这是不可能的，因为 $4+2=6$ 是偶数。
- 第三组测试，没有方法可以使其排序成单调不降数列。
- 第四组测试，该数列已经是单调不降数列了。

## 样例 #1

### 输入

```
4
4
1 6 31 14
2
4 2
5
2 9 6 7 10
3
6 6 6
```

### 输出

```
Yes
No
No
Yes
```



---

---
title: "Anti-Fibonacci Permutation"
layout: "post"
diff: 普及-
pid: CF1644B
tag: []
---

# Anti-Fibonacci Permutation

## 题目描述

Let's call a permutation $ p $ of length $ n $ anti-Fibonacci if the condition $ p_{i-2} + p_{i-1} \ne p_i $ holds for all $ i $ ( $ 3 \le i \le n $ ). Recall that the permutation is the array of length $ n $ which contains each integer from $ 1 $ to $ n $ exactly once.

Your task is for a given number $ n $ print $ n $ distinct anti-Fibonacci permutations of length $ n $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 48 $ ) — the number of test cases.

The single line of each test case contains a single integer $ n $ ( $ 3 \le n \le 50 $ ).

## 输出格式

For each test case, print $ n $ lines. Each line should contain an anti-Fibonacci permutation of length $ n $ . In each test case, you cannot print any permutation more than once.

If there are multiple answers, print any of them. It can be shown that it is always possible to find $ n $ different anti-Fibonacci permutations of size $ n $ under the constraints of the problem.

## 样例 #1

### 输入

```
2
4
3
```

### 输出

```
4 1 3 2
1 2 4 3
3 4 1 2
2 4 1 3
3 2 1
1 3 2
3 1 2
```



---

---
title: "Quality vs Quantity"
layout: "post"
diff: 普及-
pid: CF1646B
tag: []
---

# Quality vs Quantity

## 题目描述

$  \def\myred#1{\color{red}{\underline{\bf{#1}}}} \def\myblue#1{\color{blue}{\overline{\bf{#1}}}}  $ $ \def\RED{\myred{Red}} \def\BLUE{\myblue{Blue}} $

You are given a sequence of $ n $ non-negative integers $ a_1, a_2, \ldots, a_n $ . Initially, all the elements of the sequence are unpainted. You can paint each number $ \RED $ or $ \BLUE $ (but not both), or leave it unpainted.

For a color $ c $ , $ \text{Count}(c) $ is the number of elements in the sequence painted with that color and $ \text{Sum}(c) $ is the sum of the elements in the sequence painted with that color.

For example, if the given sequence is $ [2, 8, 6, 3, 1] $ and it is painted this way: $ [\myblue{2}, 8, \myred{6}, \myblue{3}, 1] $ (where $ 6 $ is painted red, $ 2 $ and $ 3 $ are painted blue, $ 1 $ and $ 8 $ are unpainted) then $ \text{Sum}(\RED)=6 $ , $ \text{Sum}(\BLUE)=2+3=5 $ , $ \text{Count}(\RED)=1 $ , and $ \text{Count}(\BLUE)=2 $ .

Determine if it is possible to paint the sequence so that $ \text{Sum}(\RED) > \text{Sum}(\BLUE) $ and $ \text{Count}(\RED) < \text{Count}(\BLUE) $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). Description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 3\le n\le 2\cdot 10^5 $ ) — the length of the given sequence.

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 0\le a_i\le 10^9 $ ) — the given sequence.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, print YES if it is possible to paint the given sequence satisfying the above requirements, and NO otherwise.

You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

## 说明/提示

In the first test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $ [\myblue{1},\myblue{2},\myred{3}] $ (where $ 3 $ is painted red, $ 1 $ and $ 2 $ are painted blue) then $ \text{Count}(\RED)=1 < \text{Count}(\BLUE)=2 $ , but $ \text{Sum}(\RED)=3 \ngtr \text{Sum}(\BLUE)=3 $ . So, this is not a possible way to paint the sequence.

In the second test case, a possible way to paint the sequence is described in the statement. We can see that $ \text{Sum}(\RED)=6 > \text{Sum}(\BLUE)=5 $ and $ \text{Count}(\RED)=1 < \text{Count}(\BLUE)=2 $ .

In the third test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $ [\myred{3},\myred{5},\myblue{4}, \myblue{2}] $ (where $ 3 $ and $ 5 $ are painted red, $ 4 $ and $ 2 $ are painted blue) then $ \text{Sum}(\RED) = 8 > \text{Sum}(\BLUE) = 6 $ but $ \text{Count}(\RED) = 2 \nless \text{Count}(\BLUE) = 2 $ . So, this is not a possible way to paint the sequence.

In the fourth test case, it can be proven that there is no possible way to paint the sequence satisfying sum and count constraints.

## 样例 #1

### 输入

```
4
3
1 2 3
5
2 8 6 3 1
4
3 5 4 2
5
1000000000 1000000000 1000000000 1000000000 1000000000
```

### 输出

```
NO
YES
NO
NO
```



---

---
title: "Madoka and Math Dad"
layout: "post"
diff: 普及-
pid: CF1647A
tag: []
---

# Madoka and Math Dad

## 题目描述

Madoka finally found the administrator password for her computer. Her father is a well-known popularizer of mathematics, so the password is the answer to the following problem.

Find the maximum decimal number without zeroes and with no equal digits in a row, such that the sum of its digits is $ n $ .

Madoka is too tired of math to solve it herself, so help her to solve this problem!

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. Description of the test cases follows.

The only line of each test case contains an integer $ n $ ( $ 1 \le n \le 1000 $ ) — the required sum of the digits.

## 输出格式

For each test case print the maximum number you can obtain.

## 说明/提示

The only numbers with the sum of digits equal to $ 2 $ without zeros are $ 2 $ and $ 11 $ . But the last one has two ones in a row, so it's not valid. That's why the answer is $ 2 $ .

The only numbers with the sum of digits equal to $ 3 $ without zeros are $ 111 $ , $ 12 $ , $ 21 $ , and $ 3 $ . The first one has $ 2 $ ones in a row, so it's not valid. So the maximum valid number is $ 21 $ .

The only numbers with the sum of digits equals to $ 4 $ without zeros are $ 1111 $ , $ 211 $ , $ 121 $ , $ 112 $ , $ 13 $ , $ 31 $ , $ 22 $ , and $ 4 $ . Numbers $ 1111 $ , $ 211 $ , $ 112 $ , $ 22 $ aren't valid, because they have some identical digits in a row. So the maximum valid number is $ 121 $ .

## 样例 #1

### 输入

```
5
1
2
3
4
5
```

### 输出

```
1
2
21
121
212
```



---

---
title: "Madoka and the Elegant Gift"
layout: "post"
diff: 普及-
pid: CF1647B
tag: []
---

# Madoka and the Elegant Gift

## 题目描述

Madoka's father just reached $ 1 $ million subscribers on Mathub! So the website decided to send him a personalized award — The Mathhub's Bit Button!

The Bit Button is a rectangular table with $ n $ rows and $ m $ columns with $ 0 $ or $ 1 $ in each cell. After exploring the table Madoka found out that:

- A subrectangle $ A $ is contained in a subrectangle $ B $ if there's no cell contained in $ A $ but not contained in $ B $ .
- Two subrectangles intersect if there is a cell contained in both of them.
- A subrectangle is called black if there's no cell with value $ 0 $ inside it.
- A subrectangle is called nice if it's black and it's not contained in another black subrectangle.
- The table is called elegant if there are no two nice intersecting subrectangles.

For example, in the first illustration the red subrectangle is nice, but in the second one it's not, because it's contained in the purple subrectangle.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1647B/527c997c3730172d58419587c380220df58d0b35.png)Help Madoka to determine whether the table is elegant.

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 200 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains two positive integers $ n, m $ ( $ 1 \le n, m \le 100 $ ).

The next $ n $ lines contain strings of length $ m $ consisting of zeros and ones — the description of the table.

It is guaranteed that the sum of the values of $ n $ and the sum of the values of $ m $ for all test cases do not exceed $ 777 $ .

## 输出格式

For each test case print "YES" if its table is elegant or print "NO" otherwise.

You may print each letter in any case (for example, "YES", "Yes", "yes", "yEs" will all be recognized as positive answer).

## 说明/提示

In the second test case the table is not elegant, because the red and the purple subrectangles are nice and intersect.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1647B/274bbf1f30d832fb82dd64034e57adcb4cd9b242.png)In the fourth test case the table is not elegant, because the red and the purple subrectangles are nice and intersect.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1647B/6dc815ec1b802f77b63db126c6131ed14481d644.png)

## 样例 #1

### 输入

```
5
3 3
100
011
011
3 3
110
111
110
1 5
01111
4 5
11111
01010
01000
01000
3 2
11
00
11
```

### 输出

```
YES
NO
YES
NO
YES
```



---

---
title: "Madoka and Childish Pranks"
layout: "post"
diff: 普及-
pid: CF1647C
tag: []
---

# Madoka and Childish Pranks

## 题目描述

Madoka as a child was an extremely capricious girl, and one of her favorite pranks was drawing on her wall. According to Madoka's memories, the wall was a table of $ n $ rows and $ m $ columns, consisting only of zeroes and ones. The coordinate of the cell in the $ i $ -th row and the $ j $ -th column ( $ 1 \le i \le n $ , $ 1 \le j \le m $ ) is $ (i, j) $ .

One day she saw a picture "Mahou Shoujo Madoka Magica" and decided to draw it on her wall. Initially, the Madoka's table is a table of size $ n \times m $ filled with zeroes. Then she applies the following operation any number of times:

Madoka selects any rectangular subtable of the table and paints it in a chess coloring (the upper left corner of the subtable always has the color $ 0 $ ). Note that some cells may be colored several times. In this case, the final color of the cell is equal to the color obtained during the last repainting.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1647C/382bdf687e9360fce9f9a4f6fec3edc2a2101bb5.png)White color means $ 0 $ , black means $ 1 $ . So, for example, the table in the first picture is painted in a chess coloring, and the others are not.For better understanding of the statement, we recommend you to read the explanation of the first test.

Help Madoka and find some sequence of no more than $ n \cdot m $ operations that allows you to obtain the picture she wants, or determine that this is impossible.

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 10 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \leq n, m \leq 100 $ ) — the size of the table. Each of the following $ n $ lines contains a string of length $ m $ consisting only of $ 1 $ and $ 0 $ — description of the picture that Madoka wants to obtain.

## 输出格式

If it is impossible to obtain the given picture, print $ -1 $ .

Otherwise, print in the first line a single integer $ q $ ( $ 0 \leq q \leq n \cdot m $ ) — the number of operations you need to obtain the picture. Note that you do not need to minimize the number of operations.

Then for each operation (in the order of execution) print a single line containing four numbers — the coordinates of the upper-left corner and the lower-right corner of the rectangle.

## 说明/提示

The description of the first test case is below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1647C/5712ccf8799cc158d880a39b68cfedf66e8a3903.png)In the third test case, it is impossible to paint the desired picture.

In the fourth test case, the initial table is already the desired picture.

## 样例 #1

### 输入

```
4
4 5
01000
10100
01010
00110
2 3
001
010
3 3
110
101
000
1 1
0
```

### 输出

```
4
1 1 3 3
3 3 4 4
4 3 4 4
4 2 4 3
1
1 2 2 3
-1
0
```



---

---
title: "Game of Ball Passing"
layout: "post"
diff: 普及-
pid: CF1649B
tag: []
---

# Game of Ball Passing

## 题目描述

Daniel is watching a football team playing a game during their training session. They want to improve their passing skills during that session.

The game involves $ n $ players, making multiple passes towards each other. Unfortunately, since the balls were moving too fast, after the session Daniel is unable to know how many balls were involved during the game. The only thing he knows is the number of passes delivered by each player during all the session.

Find the minimum possible amount of balls that were involved in the game.

## 输入格式

There are several test cases in the input data. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 5 \cdot 10^4 $ ) — the number of test cases. This is followed by the test cases description.

The first line of each test case contains one integer $ n $ ( $ 2 \leq n \leq 10^5 $ ) — the number of players.

The second line of the test case contains a sequence of integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \leq a_i \leq 10^9 $ ), where $ a_i $ is the number of passes delivered by the $ i $ -th player.

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case print a single integer — the answer to the problem.

## 说明/提示

In the first test case, with the only ball, the game can go like this:

 $ 2 \rightarrow 1 \rightarrow 3 \rightarrow 4 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 2 \rightarrow 3 \rightarrow 2 $ .

In the second test case, there is no possible way to play the game with only one ball. One possible way to play with two balls:

 $ 2 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 2 \rightarrow 1 $ .

 $ 2 \rightarrow 3 \rightarrow 2 \rightarrow 1 $

In the third example, there were no passes, so $ 0 $ balls are possible.

## 样例 #1

### 输入

```
4
4
2 3 3 2
3
1 5 2
2
0 0
4
1000000000 1000000000 1000000000 1000000000
```

### 输出

```
1
2
0
1
```



---

---
title: "DIV + MOD"
layout: "post"
diff: 普及-
pid: CF1650B
tag: []
---

# DIV + MOD

## 题目描述

Not so long ago, Vlad came up with an interesting function:

- $ f_a(x)=\left\lfloor\frac{x}{a}\right\rfloor + x \bmod a $ , where $ \left\lfloor\frac{x}{a}\right\rfloor $ is $ \frac{x}{a} $ , rounded down, $ x \bmod a $ — the remainder of the integer division of $ x $ by $ a $ .

For example, with $ a=3 $ and $ x=11 $ , the value $ f_3(11) = \left\lfloor\frac{11}{3}\right\rfloor + 11 \bmod 3 = 3 + 2 = 5 $ .

The number $ a $ is fixed and known to Vlad. Help Vlad find the maximum value of $ f_a(x) $ if $ x $ can take any integer value from $ l $ to $ r $ inclusive ( $ l \le x \le r $ ).

## 输入格式

The first line of input data contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of input test cases.

This is followed by $ t $ lines, each of which contains three integers $ l_i $ , $ r_i $ and $ a_i $ ( $ 1 \le l_i \le r_i \le 10^9, 1 \le a_i \le 10^9 $ ) — the left and right boundaries of the segment and the fixed value of $ a $ .

## 输出格式

For each test case, output one number on a separate line — the maximum value of the function on a given segment for a given $ a $ .

## 说明/提示

In the first sample:

- $ f_3(1) = \left\lfloor\frac{1}{3}\right\rfloor + 1 \bmod 3 = 0 + 1 = 1 $ ,
- $ f_3(2) = \left\lfloor\frac{2}{3}\right\rfloor + 2 \bmod 3 = 0 + 2 = 2 $ ,
- $ f_3(3) = \left\lfloor\frac{3}{3}\right\rfloor + 3 \bmod 3 = 1 + 0 = 1 $ ,
- $ f_3(4) = \left\lfloor\frac{4}{3}\right\rfloor + 4 \bmod 3 = 1 + 1 = 2 $

As an answer, obviously, $ f_3(2) $ and $ f_3(4) $ are suitable.

## 样例 #1

### 输入

```
5
1 4 3
5 8 4
6 10 6
1 1000000000 1000000000
10 12 8
```

### 输出

```
2
4
5
999999999
5
```



---

---
title: "Weight of the System of Nested Segments"
layout: "post"
diff: 普及-
pid: CF1650C
tag: []
---

# Weight of the System of Nested Segments

## 题目描述

On the number line there are $ m $ points, $ i $ -th of which has integer coordinate $ x_i $ and integer weight $ w_i $ . The coordinates of all points are different, and the points are numbered from $ 1 $ to $ m $ .

A sequence of $ n $ segments $ [l_1, r_1], [l_2, r_2], \dots, [l_n, r_n] $ is called system of nested segments if for each pair $ i, j $ ( $ 1 \le i < j \le n $ ) the condition $ l_i < l_j < r_j < r_i $ is satisfied. In other words, the second segment is strictly inside the first one, the third segment is strictly inside the second one, and so on.

For a given number $ n $ , find a system of nested segments such that:

- both ends of each segment are one of $ m $ given points;
- the sum of the weights $ 2\cdot n $ of the points used as ends of the segments is minimal.

For example, let $ m = 8 $ . The given points are marked in the picture, their weights are marked in red, their coordinates are marked in blue. Make a system of three nested segments:

- weight of the first segment: $ 1 + 1 = 2 $
- weight of the second segment: $ 10 + (-1) = 9 $
- weight of the third segment: $ 3 + (-2) = 1 $
- sum of the weights of all the segments in the system: $ 2 + 9 + 1 = 12 $

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1650C/5aeab71f3d5a716d6e18fda5439622dc4cd35cbc.png)System of three nested segments

## 输入格式

The first line of input data contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) —the number of input test cases.

An empty line is written before each test case.

The first line of each test case contains two positive integers $ n $ ( $ 1 \le n \le 10^5 $ ) and $ m $ ( $ 2 \cdot n \le m \le 2 \cdot 10^5 $ ).

The next $ m $ lines contain pairs of integers $ x_i $ ( $ -10^9 \le x_i \le 10^9 $ ) and $ w_i $ ( $ -10^4 \le w_i \le 10^4 $ ) — coordinate and weight of point number $ i $ ( $ 1 \le i \le m $ ) respectively. All $ x_i $ are different.

It is guaranteed that the sum of $ m $ values over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output $ n + 1 $ lines: in the first of them, output the weight of the composed system, and in the next $ n $ lines output exactly two numbers — the indices of the points which are the endpoints of the $ i $ -th segment ( $ 1 \le i \le n $ ). The order in which you output the endpoints of a segment is not important — you can output the index of the left endpoint first and then the number of the right endpoint, or the other way around.

If there are several ways to make a system of nested segments with minimal weight, output any of them.

## 说明/提示

The first test case coincides with the example from the condition. It can be shown that the weight of the composed system is minimal.

The second test case has only $ 6 $ points, so you need to use each of them to compose $ 3 $ segments.

## 样例 #1

### 输入

```
3

3 8
0 10
-2 1
4 10
11 20
7 -1
9 1
2 3
5 -2

3 6
-1 2
1 3
3 -1
2 4
4 0
8 2

2 5
5 -1
3 -2
1 0
-2 0
-5 -3
```

### 输出

```
12
2 6
5 1
7 8

10
1 6
5 2
3 4

-6
5 1
4 2
```



---

---
title: "Prefix Removals"
layout: "post"
diff: 普及-
pid: CF1654B
tag: []
---

# Prefix Removals

## 题目描述

You are given a string $ s $ consisting of lowercase letters of the English alphabet. You must perform the following algorithm on $ s $ :

- Let $ x $ be the length of the longest prefix of $ s $ which occurs somewhere else in $ s $ as a contiguous substring (the other occurrence may also intersect the prefix). If $ x = 0 $ , break. Otherwise, remove the first $ x $ characters of $ s $ , and repeat.

A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string "abcd" has 5 prefixes: empty string, "a", "ab", "abc" and "abcd".

For instance, if we perform the algorithm on $ s = $ "abcabdc",

- Initially, "ab" is the longest prefix that also appears somewhere else as a substring in $ s $ , so $ s = $ "cabdc" after $ 1 $ operation.
- Then, "c" is the longest prefix that also appears somewhere else as a substring in $ s $ , so $ s = $ "abdc" after $ 2 $ operations.
- Now $ x=0 $ (because there are no non-empty prefixes of "abdc" that also appear somewhere else as a substring in $ s $ ), so the algorithm terminates.

Find the final state of the string after performing the algorithm.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

This is followed by $ t $ lines, each containing a description of one test case. Each line contains a string $ s $ . The given strings consist only of lowercase letters of the English alphabet and have lengths between $ 1 $ and $ 2 \cdot 10^5 $ inclusive.

It is guaranteed that the sum of the lengths of $ s $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print a single line containing the string $ s $ after executing the algorithm. It can be shown that such string is non-empty.

## 说明/提示

The first test case is explained in the statement.

In the second test case, no operations can be performed on $ s $ .

In the third test case,

- Initially, $ s = $ "bbbbbbbbbb".
- After $ 1 $ operation, $ s = $ "b".

In the fourth test case,

- Initially, $ s = $ "codeforces".
- After $ 1 $ operation, $ s = $ "odeforces".
- After $ 2 $ operations, $ s = $ "deforces".

## 样例 #1

### 输入

```
6
abcabdc
a
bbbbbbbbbb
codeforces
cffcfccffccfcffcfccfcffccffcfccf
zyzyzwxxyyxxyyzzyzzxxwzxwywxwzxxyzzw
```

### 输出

```
abdc
a
b
deforces
cf
xyzzw
```



---

---
title: "Subtract Operation"
layout: "post"
diff: 普及-
pid: CF1656B
tag: []
---

# Subtract Operation

## 题目描述

You are given a list of $ n $ integers. You can perform the following operation: you choose an element $ x $ from the list, erase $ x $ from the list, and subtract the value of $ x $ from all the remaining elements. Thus, in one operation, the length of the list is decreased by exactly $ 1 $ .

Given an integer $ k $ ( $ k>0 $ ), find if there is some sequence of $ n-1 $ operations such that, after applying the operations, the only remaining element of the list is equal to $ k $ .

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 2 \leq n \leq 2\cdot 10^5 $ , $ 1 \leq k \leq 10^9 $ ), the number of integers in the list, and the target value, respectively.

The second line of each test case contains the $ n $ integers of the list $ a_1, a_2, \ldots, a_n $ ( $ -10^9 \leq a_i \leq 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases is not greater that $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print YES if you can achieve $ k $ with a sequence of $ n-1 $ operations. Otherwise, print NO.

You may print each letter in any case (for example, "YES", "Yes", "yes", "yEs" will all be recognized as a positive answer).

## 说明/提示

In the first example we have the list $ \{4, 2, 2, 7\} $ , and we have the target $ k = 5 $ . One way to achieve it is the following: first we choose the third element, obtaining the list $ \{2, 0, 5\} $ . Next we choose the first element, obtaining the list $ \{-2, 3\} $ . Finally, we choose the first element, obtaining the list $ \{5\} $ .

## 样例 #1

### 输入

```
4
4 5
4 2 2 7
5 4
1 9 1 3 4
2 17
17 0
2 17
18 18
```

### 输出

```
YES
NO
YES
NO
```



---

---
title: "XY Sequence"
layout: "post"
diff: 普及-
pid: CF1657B
tag: []
---

# XY Sequence

## 题目描述

You are given four integers $ n $ , $ B $ , $ x $ and $ y $ . You should build a sequence $ a_0, a_1, a_2, \dots, a_n $ where $ a_0 = 0 $ and for each $ i \ge 1 $ you can choose:

- either $ a_i = a_{i - 1} + x $
- or $ a_i = a_{i - 1} - y $ .

Your goal is to build such a sequence $ a $ that $ a_i \le B $ for all $ i $ and $ \sum\limits_{i=0}^{n}{a_i} $ is maximum possible.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Next $ t $ cases follow.

The first and only line of each test case contains four integers $ n $ , $ B $ , $ x $ and $ y $ ( $ 1 \le n \le 2 \cdot 10^5 $ ; $ 1 \le B, x, y \le 10^9 $ ).

It's guaranteed that the total sum of $ n $ doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print one integer — the maximum possible $ \sum\limits_{i=0}^{n}{a_i} $ .

## 说明/提示

In the first test case, the optimal sequence $ a $ is $ [0, 1, 2, 3, 4, 5] $ .

In the second test case, the optimal sequence $ a $ is $ [0, 10^9, 0, 10^9, 0, 10^9, 0, 10^9] $ .

In the third test case, the optimal sequence $ a $ is $ [0, -3, -6, 1, -2] $ .

## 样例 #1

### 输入

```
3
5 100 1 30
7 1000000000 1000000000 1000000000
4 1 7 3
```

### 输出

```
15
4000000000
-10
```



---

---
title: "Bracket Sequence Deletion"
layout: "post"
diff: 普及-
pid: CF1657C
tag: []
---

# Bracket Sequence Deletion

## 题目描述

### 题目翻译

LBW 有一个长度为 $n$ 的由括号组成的字符串，他每次要选择一个前缀并将其从字符串中删除。

这个前缀至少要满足以下两点要求：

+ 这个前缀是一个合法括号序列。
+ 此前缀是长度大于等于 $2$ 的回文串。

一直这样做，直到无法执行。

LBW 想知道最多能执行的次数与此时剩下的字符数。

## 输入格式

**本题有多组数据。**

第一行，一个整数 $T$，表示有 $T$ 组测试数据。

对于每组测试数据：

第一行，一个整数 $n$，表示括号序列的长度。

第二行，一个字符串，表示括号序列。

## 输出格式

对于每个测试数据，输出最多能执行的次数与此时剩下的字符数。

## 说明/提示

$1 \le T \le 10^4$

$1 \le n \le 5 \times 10^5$

## 样例 #1

### 输入

```
5
2
()
3
())
4
((((
5
)((()
6
)((()(
```

### 输出

```
1 0
1 1
2 0
1 0
1 1
```



---

---
title: "Marin and Anti-coprime Permutation"
layout: "post"
diff: 普及-
pid: CF1658B
tag: []
---

# Marin and Anti-coprime Permutation

## 题目描述

Marin wants you to count number of permutations that are beautiful. A beautiful permutation of length $ n $ is a permutation that has the following property: $ $$$ \gcd (1 \cdot p_1, \, 2 \cdot p_2, \, \dots, \, n \cdot p_n) > 1,  $ $  where  $ \\gcd $  is the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a>.</p><p>A permutation is an array consisting of  $ n $  distinct integers from  $ 1 $  to  $ n $  in arbitrary order. For example,  $ \[2,3,1,5,4\] $  is a permutation, but  $ \[1,2,2\] $  is not a permutation ( $ 2 $  appears twice in the array) and  $ \[1,3, 4\] $  is also not a permutation ( $ n=3 $  but there is  $ 4$$$ in the array).

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^3 $ ) — the number of test cases.

Each test case consists of one line containing one integer $ n $ ( $ 1 \le n \le 10^3 $ ).

## 输出格式

For each test case, print one integer — number of beautiful permutations. Because the answer can be very big, please print the answer modulo $ 998\,244\,353 $ .

## 说明/提示

In first test case, we only have one permutation which is $ [1] $ but it is not beautiful because $ \gcd(1 \cdot 1) = 1 $ .

In second test case, we only have one beautiful permutation which is $ [2, 1] $ because $ \gcd(1 \cdot 2, 2 \cdot 1) = 2 $ .

## 样例 #1

### 输入

```
7
1
2
3
4
5
6
1000
```

### 输出

```
0
1
0
4
0
36
665702330
```



---

---
title: "Supercentral Point"
layout: "post"
diff: 普及-
pid: CF165A
tag: []
---

# Supercentral Point

## 题目描述

One day Vasya painted a Cartesian coordinate system on a piece of paper and marked some set of points $ (x_{1},y_{1}),(x_{2},y_{2}),...,(x_{n},y_{n}) $ . Let's define neighbors for some fixed point from the given set $ (x,y) $ :

- point $ (x',y') $ is $ (x,y) $ 's right neighbor, if $ x'&gt;x $ and $ y'=y $
- point $ (x',y') $ is $ (x,y) $ 's left neighbor, if $ x'&lt;x $ and $ y'=y $
- point $ (x',y') $ is $ (x,y) $ 's lower neighbor, if $ x'=x $ and $ y'&lt;y $
- point $ (x',y') $ is $ (x,y) $ 's upper neighbor, if $ x'=x $ and $ y'&gt;y $

We'll consider point $ (x,y) $ from the given set supercentral, if it has at least one upper, at least one lower, at least one left and at least one right neighbor among this set's points.

Vasya marked quite many points on the paper. Analyzing the picture manually is rather a challenge, so Vasya asked you to help him. Your task is to find the number of supercentral points in the given set.

## 输入格式

The first input line contains the only integer $ n $ ( $ 1<=n<=200 $ ) — the number of points in the given set. Next $ n $ lines contain the coordinates of the points written as " $ x $ $ y $ " (without the quotes) ( $ |x|,|y|<=1000 $ ), all coordinates are integers. The numbers in the line are separated by exactly one space. It is guaranteed that all points are different.

## 输出格式

Print the only number — the number of supercentral points of the given set.

## 说明/提示

In the first sample the supercentral points are only points $ (1,1) $ and $ (1,2) $ .

In the second sample there is one supercental point — point $ (0,0) $ .

## 样例 #1

### 输入

```
8
1 1
4 2
3 1
1 2
0 2
0 1
1 0
1 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
5
0 0
0 1
1 0
0 -1
-1 0

```

### 输出

```
1

```



---

---
title: "Get an Even String"
layout: "post"
diff: 普及-
pid: CF1660C
tag: []
---

# Get an Even String

## 题目描述

A string $ a=a_1a_2\dots a_n $ is called even if it consists of a concatenation (joining) of strings of length $ 2 $ consisting of the same characters. In other words, a string $ a $ is even if two conditions are satisfied at the same time:

- its length $ n $ is even;
- for all odd $ i $ ( $ 1 \le i \le n - 1 $ ), $ a_i = a_{i+1} $ is satisfied.

For example, the following strings are even: "" (empty string), "tt", "aabb", "oooo", and "ttrrrroouuuuuuuukk". The following strings are not even: "aaa", "abab" and "abba".

Given a string $ s $ consisting of lowercase Latin letters. Find the minimum number of characters to remove from the string $ s $ to make it even. The deleted characters do not have to be consecutive.

## 输入格式

The first line of input data contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) —the number of test cases in the test.

The descriptions of the test cases follow.

Each test case consists of one string $ s $ ( $ 1 \le |s| \le 2 \cdot 10^5 $ ), where $ |s| $ — the length of the string $ s $ . The string consists of lowercase Latin letters.

It is guaranteed that the sum of $ |s| $ on all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print a single number — the minimum number of characters that must be removed to make $ s $ even.

## 说明/提示

In the first test case you can remove the characters with indices $ 6 $ , $ 7 $ , and $ 9 $ to get an even string "aabbddcc".

In the second test case, each character occurs exactly once, so in order to get an even string, you must remove all characters from the string.

In the third test case, you can get an even string "aaaabb" by removing, for example, $ 4 $ -th and $ 6 $ -th characters, or a string "aabbbb" by removing the $ 5 $ -th character and any of the first three.

## 样例 #1

### 输入

```
6
aabbdabdccc
zyx
aaababbb
aabbcc
oaoaaaoo
bmefbmuyw
```

### 输出

```
3
3
2
0
2
7
```



---

---
title: "Array Balancing"
layout: "post"
diff: 普及-
pid: CF1661A
tag: []
---

# Array Balancing

## 题目描述

You are given two arrays of length $ n $ : $ a_1, a_2, \dots, a_n $ and $ b_1, b_2, \dots, b_n $ .

You can perform the following operation any number of times:

1. Choose integer index $ i $ ( $ 1 \le i \le n $ );
2. Swap $ a_i $ and $ b_i $ .

What is the minimum possible sum $ |a_1 - a_2| + |a_2 - a_3| + \dots + |a_{n-1} - a_n| $ $ + $ $ |b_1 - b_2| + |b_2 - b_3| + \dots + |b_{n-1} - b_n| $ (in other words, $ \sum\limits_{i=1}^{n - 1}{\left(|a_i - a_{i+1}| + |b_i - b_{i+1}|\right)} $ ) you can achieve after performing several (possibly, zero) operations?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 4000 $ ) — the number of test cases. Then, $ t $ test cases follow.

The first line of each test case contains the single integer $ n $ ( $ 2 \le n \le 25 $ ) — the length of arrays $ a $ and $ b $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the array $ a $ .

The third line of each test case contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ 1 \le b_i \le 10^9 $ ) — the array $ b $ .

## 输出格式

For each test case, print one integer — the minimum possible sum $ \sum\limits_{i=1}^{n-1}{\left(|a_i - a_{i+1}| + |b_i - b_{i+1}|\right)} $ .

## 说明/提示

In the first test case, we can, for example, swap $ a_3 $ with $ b_3 $ and $ a_4 $ with $ b_4 $ . We'll get arrays $ a = [3, 3, 3, 3] $ and $ b = [10, 10, 10, 10] $ with sum $ 3 \cdot |3 - 3| + 3 \cdot |10 - 10| = 0 $ .

In the second test case, arrays already have minimum sum (described above) equal to $ |1 - 2| + \dots + |4 - 5| + |6 - 7| + \dots + |9 - 10| $ $ = 4 + 4 = 8 $ .

In the third test case, we can, for example, swap $ a_5 $ and $ b_5 $ .

## 样例 #1

### 输入

```
3
4
3 3 10 10
10 10 3 3
5
1 2 3 4 5
6 7 8 9 10
6
72 101 108 108 111 44
10 87 111 114 108 100
```

### 输出

```
0
8
218
```



---

---
title: "Deletive Editing"
layout: "post"
diff: 普及-
pid: CF1666D
tag: []
---

# Deletive Editing

## 题目描述

Daisy 喜欢玩有关文字的游戏。最近，她一直在和 Daniel 玩下面描述的删除与编辑的文字游戏。

这个游戏按以下描述的方式进行：Daisy 最初选择一个词，例如 `DETERMINED`。在游戏的每个回合里，Daniel 选择一个字母，例如 `E`，接下来 Daisy 删除掉在这个词中出现的第一个这个字母，这时她得到 `DTERMINED`，这个回合结束。

在下面的回合中，Daniel 依次选择 `D`、`I`、`N`、`D`，而 Daisy 依次得到 `TERMINED`、`TERMNED`、`TERMED`、`TERME`。现在，如果 Daniel 选择 `E`，Daisy 会得到 `TRME`。但如果她最开始选择的词为 `DETERMINED`，Daisy 将不可能得到 `TERM` 这个词。

Daisy 现在好奇在给定初始的词时，她能否在 $0$ 个或多个回合内通过这个游戏得到她选择的最终词。你的任务是帮助她判断这是否可行。

## 输入格式

第一行有一个整数 $n$，代表子任务组数（$1 \le n \le 10000$），接下来 $n$ 行，每行一个子任务。

每一个子任务包含 $2$ 个用空格分隔的字符串 $s$ 和 $t$。这两个字符串由不超过 $30$ 个大写英语字母构成。其中，$s$ 是 Daisy 初始选择的词，$t$ 是 Daisy 想要得到的词。

## 输出格式

输出 $n$ 行，每行代表一个子任务的答案。如果 Daisy 以 $s$ 为初始词能通过这个游戏得到 $t$，输出 `YES`；否则输出 `NO`。

## 样例 #1

### 输入

```
6
DETERMINED TRME
DETERMINED TERM
PSEUDOPSEUDOHYPOPARATHYROIDISM PEPA
DEINSTITUTIONALIZATION DONATION
CONTEST CODE
SOLUTION SOLUTION
```

### 输出

```
YES
NO
NO
YES
NO
YES
```



---

---
title: "Make it Increasing"
layout: "post"
diff: 普及-
pid: CF1667A
tag: []
---

# Make it Increasing

## 题目描述

给定一个包含 $n$ 个**正整数**的数列 $a$ 以及一个长度为 $n$ 的数列 $b$ ,初始时数列 $b$ 的每一个元素都为0。定义一次操作为把数列 $b$ 中的某个元素 $b_i$ 加上或减去 $a_i$ 的值，求使得数列 $b$ 严格递增最小的操作次数。

## 输入格式

第一行为一个整数 $n$ $(2 \le n \le 5000)$，第二行为 $n$ 个正整数，$a_1$ , $a_2$ , ... , $a_n$ $(1 \le a_i \le {10}^9)$ ，作为数列 $a$ 的值。

## 输出格式

输出使数列 $b$ 严格递增的最小操作次数。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
4
```

## 样例 #2

### 输入

```
7
1 2 1 2 1 2 1
```

### 输出

```
10
```

## 样例 #3

### 输入

```
8
1 8 2 7 3 6 4 5
```

### 输出

```
16
```



---

---
title: "Social Distance"
layout: "post"
diff: 普及-
pid: CF1668B
tag: []
---

# Social Distance

## 题目描述

有一圈共 $m$ 个座椅（编号 $0 \sim m-1$），有 $n$ 个人要坐在上面，第 $i$ 个人左右两边至少要有 $a_i$ 个空座椅，问是否有一种方案可以使得所有人都能坐在上面。

## 输入格式

第一行一个整数 $t ( 1\le t \le 5 ⋅ 10^4 )$，表示有 $t$ 组询问。

接下来 $2⋅t$ 行，每两行为一组询问。对于每一组询问，第一行两个整数，为 $n$ 和 $m$ ($2\le n \le 10^5$, $1\le m \le 10^9$)，接下来一行为 $n$ 个整数，第 $i$ 个整数为 $a_i(1\le a_i \le 10^9 )$。

## 输出格式

对于每一组询问，输出对应的答案，可以输出 `YES`，否则输出 `NO`。

## 说明/提示

样例第一组询问：人数大于座椅数，无解。

样例第二组询问：一种可行解为第一个人坐编号为 $2$ 的座椅，第二个人坐编号为 $0$ 的座椅。

样例第三组询问：第二个人无论坐哪，第一个人都没有位置，无解。

样例第四组询问：一种可行解为第一个人坐编号为 $1$ 的座椅，第二个人坐编号为 $4$ 的座椅，第三个人坐编号为 $7$ 的座椅。

## 样例 #1

### 输入

```
6
3 2
1 1 1
2 4
1 1
2 5
2 1
3 8
1 2 1
4 12
1 2 1 3
4 19
1 2 1 3
```

### 输出

```
NO
YES
NO
YES
NO
YES
```



---

---
title: "Odd/Even Increments"
layout: "post"
diff: 普及-
pid: CF1669C
tag: []
---

# Odd/Even Increments

## 题目描述

给定一个长为 $n$ 数组 $a=[a_1,a_2,a_3····,a_n]$ ，您可以对其进行两种类型的操作：

1.将 $1$ 添加到具有奇数索引的每个元素。换句话说，改变数组如下：$a_1=a_1+1,a_3=a_3+1,a_5=a_5+1,......$

2.将 $1$ 添加到具有偶数索引的每个元素。换句话说，改变数组如下：$a_2=a_2+1,a_4=a_4+1,a_6=a_
6+1,......$

确定经过任意次数的操作后，是否有可能使最终数组仅包含偶数或仅包含奇数。换句话说，确定是否可以使数组的所有元素在经过任意次数的操作后具有相同的奇偶性。

请注意，您可以多次执行这两种类型的操作（甚至没有）。不同类型的操作可以执行不同的次数。

## 输入格式

第一行包含一个整数 $t\ (1\le t \le 100)$ — 测试样例的数量。

每个测试样例的第一行包含一个整数 $ n\ (2 \le n \le 50)$ 。

每个测试用例的第二行包含 $n$ 个整数 $a_1,a_2,a_3,....,a_n\ (1\le a_i\le 10^3)$ —数组的元素。

请注意，在执行操作之后，数组中的元素可能会变得大于 $10^3$。

## 输出格式

输出 $t$ 列，每列都包含对应测试用例的答案。如果经过任意次数的操作后可以使最终数组仅包含偶数或奇数，则输出“YES”，否则输出“NO”。 您可以输出任何合法的答案（例如，字符串“yEs”、“yes”、“Yes”和“YES”将被识别为正确答案）。

### 输入输出样例

#### 输入 #1
```
4
3
1 2 1
4
2 2 2 3
4
2 2 2 2
5
1000 1 1000 1 1000
```
#### 输出 #1

```
YES
NO
YES
YES
```

## 说明/提示

对于第一个测试用例，可以增加偶数索引的元素，得到数组 $[1, 3, 1]$ ，它只包含奇数，所以答案是“YES”。 

对于第二个测试用例，可以证明在执行任意数量的操作后，我们将无法使所有元素具有相同的奇偶性，因此答案是“NO”。

对于第三个测试用例，元素已经具有相同的奇偶性，因此答案是“YES”。 

对于第四个测试用例，可以执行一次操作，将奇数位置的所有元素都增加 11 ，从而得到数组 $[1001, 1, 1001, 1, 1001]$ ，所有元素变成奇数，所以答案是“YES”。

## 样例 #1

### 输入

```
4
3
1 2 1
4
2 2 2 3
4
2 2 2 2
5
1000 1 1000 1 1000
```

### 输出

```
YES
NO
YES
YES
```



---

---
title: "Colorful Stamp"
layout: "post"
diff: 普及-
pid: CF1669D
tag: []
---

# Colorful Stamp

## 题目描述

A row of $ n $ cells is given, all initially white. Using a stamp, you can stamp any two neighboring cells such that one becomes red and the other becomes blue. A stamp can be rotated, i.e. it can be used in both ways: as $ \color{blue}{\texttt{B}}\color{red}{\texttt{R}} $ and as $ \color{red}{\texttt{R}}\color{blue}{\texttt{B}} $ .

During use, the stamp must completely fit on the given $ n $ cells (it cannot be partially outside the cells). The stamp can be applied multiple times to the same cell. Each usage of the stamp recolors both cells that are under the stamp.

For example, one possible sequence of stamps to make the picture $ \color{blue}{\texttt{B}}\color{red}{\texttt{R}}\color{blue}{\texttt{B}}\color{blue}{\texttt{B}}\texttt{W} $ could be $ \texttt{WWWWW} \to \texttt{WW}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\texttt{W} \to \color{brown}{\underline{\color{blue}{\texttt{B}}\color{red}{\texttt{R}}}}\color{red}{\texttt{R}}\color{blue}{\texttt{B}}\texttt{W} \to \color{blue}{\texttt{B}}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\color{blue}{\texttt{B}}\texttt{W} $ . Here $ \texttt{W} $ , $ \color{red}{\texttt{R}} $ , and $ \color{blue}{\texttt{B}} $ represent a white, red, or blue cell, respectively, and the cells that the stamp is used on are marked with an underline.

Given a final picture, is it possible to make it using the stamp zero or more times?

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the length of the picture.

The second line of each test case contains a string $ s $ — the picture you need to make. It is guaranteed that the length of $ s $ is $ n $ and that $ s $ only consists of the characters $ \texttt{W} $ , $ \texttt{R} $ , and $ \texttt{B} $ , representing a white, red, or blue cell, respectively.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

Output $ t $ lines, each of which contains the answer to the corresponding test case. As an answer, output "YES" if it possible to make the picture using the stamp zero or more times, and "NO" otherwise.

You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).

## 说明/提示

The first test case is explained in the statement.

For the second, third, and fourth test cases, it is not possible to stamp a single cell, so the answer is "NO".

For the fifth test case, you can use the stamp as follows: $ \texttt{WWW} \to \texttt{W}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}} \to \color{brown}{\underline{\color{blue}{\texttt{B}}\color{red}{\texttt{R}}}}\color{blue}{\texttt{B}} $ .

For the sixth test case, you can use the stamp as follows: $ \texttt{WWW} \to \texttt{W}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}} \to \color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\color{blue}{\texttt{B}} $ .

For the seventh test case, you don't need to use the stamp at all.

## 样例 #1

### 输入

```
12
5
BRBBW
1
B
2
WB
2
RW
3
BRB
3
RBB
7
WWWWWWW
9
RBWBWRRBW
10
BRBRBRBRRB
12
BBBRWWRRRWBR
10
BRBRBRBRBW
5
RBWBW
```

### 输出

```
YES
NO
NO
NO
YES
YES
YES
NO
YES
NO
YES
NO
```



---

---
title: "2-Letter Strings"
layout: "post"
diff: 普及-
pid: CF1669E
tag: []
---

# 2-Letter Strings

## 题目描述

你被给予了$n$个长度为2的字符串，每个含有从$a$到$k$的小写字母。找出所有对$(i,j)$使得$i<j$并且第$i$个字符串和第$j$个字符串**刚好**有1个字符不同。

换句话来说，找到所有的数字对$(i,j)(i<j)$使得第$i$个字符串与第$j$个字符串有唯一一个数字$p(1 \leq p \leq 2)$使得$s_{i_p}\neq s_{j_p}$

答案可能超出32位数的范围，所以你在使用c++时应该使用long long等64位变量类型来存储数据避免溢出

注：本题有多数据

## 输入格式

第一行输入一个整数$t(1\leq t \leq 100)$表示测试组数

每个测试组的第一行输入一个整数$n(1\leq n \leq 10^5)$，意义在上面

接下来的$n$行每行输入一个2字符长的字符串$s_i$，只包含字符$a$到$k$。

数据保证$n$的总和不超过$10^5$

## 输出格式

对于每一个测试组，输出一个表示数字对的个数，条件在背景里

##### 重复一遍(?)：答案可能超出32位数的范围，所以你在使用c++时应该使用long long等64位变量类型来存储数据避免溢出

## 说明/提示

对于第一个测试样例，符合的字符串对为： ("ab", "cb"), ("ab", "db"), ("ab", "aa"), ("cb", "db") 和 ("cb", "cc")。

对于第二个测试样例，符合的字符串对为： ("aa", "ac"), ("aa", "ca"), ("cc", "ac"), ("cc", "ca"), ("ac", "aa") 和 ("ca", "aa")。

对于最后一个测试样例，没有一种情况符合

## 样例 #1

### 输入

```
4
6
ab
cb
db
aa
cc
ef
7
aa
bb
cc
ac
ca
bb
aa
4
kk
kk
ab
ab
5
jf
jf
jk
jk
jk
```

### 输出

```
5
6
0
6
```



---

---
title: "Eating Candies"
layout: "post"
diff: 普及-
pid: CF1669F
tag: []
---

# Eating Candies

## 题目描述

There are $ n $ candies put from left to right on a table. The candies are numbered from left to right. The $ i $ -th candy has weight $ w_i $ . Alice and Bob eat candies.

Alice can eat any number of candies from the left (she can't skip candies, she eats them in a row).

Bob can eat any number of candies from the right (he can't skip candies, he eats them in a row).

Of course, if Alice ate a candy, Bob can't eat it (and vice versa).

They want to be fair. Their goal is to eat the same total weight of candies. What is the most number of candies they can eat in total?

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 2\cdot10^5 $ ) — the number of candies on the table.

The second line of each test case contains $ n $ integers $ w_1, w_2, \dots, w_n $ ( $ 1 \leq w_i \leq 10^4 $ ) — the weights of candies from left to right.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, print a single integer — the maximum number of candies Alice and Bob can eat in total while satisfying the condition.

## 说明/提示

For the first test case, Alice will eat one candy from the left and Bob will eat one candy from the right. There is no better way for them to eat the same total amount of weight. The answer is $ 2 $ because they eat two candies in total.

For the second test case, Alice will eat the first three candies from the left (with total weight $ 7 $ ) and Bob will eat the first three candies from the right (with total weight $ 7 $ ). They cannot eat more candies since all the candies have been eaten, so the answer is $ 6 $ (because they eat six candies in total).

For the third test case, there is no way Alice and Bob will eat the same non-zero weight so the answer is $ 0 $ .

For the fourth test case, Alice will eat candies with weights $ [7, 3, 20] $ and Bob will eat candies with weights $ [10, 8, 11, 1] $ , they each eat $ 30 $ weight. There is no better partition so the answer is $ 7 $ .

## 样例 #1

### 输入

```
4
3
10 20 10
6
2 1 4 2 4 1
5
1 2 4 8 16
9
7 3 20 5 15 1 11 8 10
```

### 输出

```
2
6
0
7
```



---

---
title: "Fall Down"
layout: "post"
diff: 普及-
pid: CF1669G
tag: []
---

# Fall Down

## 题目描述

There is a grid with $ n $ rows and $ m $ columns, and three types of cells:

- An empty cell, denoted with '.'.
- A stone, denoted with '\*'.
- An obstacle, denoted with the lowercase Latin letter 'o'.

All stones fall down until they meet the floor (the bottom row), an obstacle, or other stone which is already immovable. (In other words, all the stones just fall down as long as they can fall.)

Simulate the process. What does the resulting grid look like?

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \leq n, m \leq 50 $ ) — the number of rows and the number of columns in the grid, respectively.

Then $ n $ lines follow, each containing $ m $ characters. Each of these characters is either '.', '\*', or 'o' — an empty cell, a stone, or an obstacle, respectively.

## 输出格式

For each test case, output a grid with $ n $ rows and $ m $ columns, showing the result of the process.

You don't need to output a new line after each test, it is in the samples just for clarity.

## 样例 #1

### 输入

```
3
6 10
.*.*....*.
.*.......*
...o....o.
.*.*....*.
..........
.o......o*
2 9
...***ooo
.*o.*o.*o
5 5
*****
*....
*****
....*
*****
```

### 输出

```
..........
...*....*.
.*.o....o.
.*........
.*......**
.o.*....o*

....**ooo
.*o**o.*o

.....
*...*
*****
*****
*****
```



---

---
title: "Maximal AND"
layout: "post"
diff: 普及-
pid: CF1669H
tag: []
---

# Maximal AND

## 题目描述

Let $ \mathsf{AND} $ denote the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and $ \mathsf{OR} $ denote the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).

You are given an array $ a $ of length $ n $ and a non-negative integer $ k $ . You can perform at most $ k $ operations on the array of the following type:

- Select an index $ i $ ( $ 1 \leq i \leq n $ ) and replace $ a_i $ with $ a_i $ $ \mathsf{OR} $ $ 2^j $ where $ j $ is any integer between $ 0 $ and $ 30 $ inclusive. In other words, in an operation you can choose an index $ i $ ( $ 1 \leq i \leq n $ ) and set the $ j $ -th bit of $ a_i $ to $ 1 $ ( $ 0 \leq j \leq 30 $ ).

Output the maximum possible value of $ a_1 $ $ \mathsf{AND} $ $ a_2 $ $ \mathsf{AND} $ $ \dots $ $ \mathsf{AND} $ $ a_n $ after performing at most $ k $ operations.

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains the integers $ n $ and $ k $ ( $ 1 \le n \le 2 \cdot 10^5 $ , $ 0 \le k \le 10^9 $ ).

Then a single line follows, containing $ n $ integers describing the arrays $ a $ ( $ 0 \leq a_i < 2^{31} $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single line containing the maximum possible $ \mathsf{AND} $ value of $ a_1 $ $ \mathsf{AND} $ $ a_2 $ $ \mathsf{AND} $ $ \dots $ $ \mathsf{AND} $ $ a_n $ after performing at most $ k $ operations.

## 说明/提示

For the first test case, we can set the bit $ 1 $ ( $ 2^1 $ ) of the last $ 2 $ elements using the $ 2 $ operations, thus obtaining the array \[ $ 2 $ , $ 3 $ , $ 3 $ \], which has $ \mathsf{AND} $ value equal to $ 2 $ .

For the second test case, we can't perform any operations so the answer is just the $ \mathsf{AND} $ of the whole array which is $ 4 $ .

## 样例 #1

### 输入

```
4
3 2
2 1 1
7 0
4 6 6 28 6 6 12
1 30
0
4 4
3 1 3 1
```

### 输出

```
2
4
2147483646
1073741825
```



---

---
title: "Dorms War"
layout: "post"
diff: 普及-
pid: CF1670B
tag: []
---

# Dorms War

## 题目描述

Hosssam decided to sneak into Hemose's room while he is sleeping and change his laptop's password. He already knows the password, which is a string $ s $ of length $ n $ . He also knows that there are $ k $ special letters of the alphabet: $ c_1,c_2,\ldots, c_k $ .

Hosssam made a program that can do the following.

1. The program considers the current password $ s $ of some length $ m $ .
2. Then it finds all positions $ i $ ( $ 1\le i<m $ ) such that $ s_{i+1} $ is one of the $ k $ special letters.
3. Then it deletes all of those positions from the password $ s $ even if $ s_{i} $ is a special character. If there are no positions to delete, then the program displays an error message which has a very loud sound.

For example, suppose the string $ s $ is "abcdef" and the special characters are 'b' and 'd'. If he runs the program once, the positions $ 1 $ and $ 3 $ will be deleted as they come before special characters, so the password becomes "bdef". If he runs the program again, it deletes position $ 1 $ , and the password becomes "def". If he is wise, he won't run it a third time.

Hosssam wants to know how many times he can run the program on Hemose's laptop without waking him up from the sound of the error message. Can you help him?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^5 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^5 $ ) — the initial length of the password.

The next line contains a string $ s $ consisting of $ n $ lowercase English letters — the initial password.

The next line contains an integer $ k $ ( $ 1 \le k \le 26 $ ), followed by $ k $ distinct lowercase letters $ c_1,c_2,\ldots,c_k $ — the special letters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, print the maximum number of times Hosssam can run the program without displaying the error message, on a new line.

## 说明/提示

In the first test case, the program can run $ 5 $ times as follows: $ \text{iloveslim} \to \text{ilovslim} \to \text{iloslim} \to \text{ilslim} \to \text{islim} \to \text{slim} $

In the second test case, the program can run $ 2 $ times as follows: $ \text{joobeel} \to \text{oel} \to \text{el} $

In the third test case, the program can run $ 3 $ times as follows: $ \text{basiozi} \to \text{bioi} \to \text{ii} \to \text{i} $ .

In the fourth test case, the program can run $ 5 $ times as follows: $ \text{khater} \to \text{khatr} \to \text{khar} \to \text{khr} \to \text{kr} \to \text{r} $

In the fifth test case, the program can run only once as follows: $ \text{abobeih} \to \text{h} $

In the sixth test case, the program cannot run as none of the characters in the password is a special character.

## 样例 #1

### 输入

```
10
9
iloveslim
1 s
7
joobeel
2 o e
7
basiozi
2 s i
6
khater
1 r
7
abobeih
6 a b e h i o
5
zondl
5 a b c e f
6
shoman
2 a h
7
shetwey
2 h y
5
samez
1 m
6
mouraz
1 m
```

### 输出

```
5
2
3
5
1
0
3
5
2
0
```



---

---
title: "Consecutive Points Segment"
layout: "post"
diff: 普及-
pid: CF1671B
tag: []
---

# Consecutive Points Segment

## 题目描述

You are given $ n $ points with integer coordinates on a coordinate axis $ OX $ . The coordinate of the $ i $ -th point is $ x_i $ . All points' coordinates are distinct and given in strictly increasing order.

For each point $ i $ , you can do the following operation no more than once: take this point and move it by $ 1 $ to the left or to the right (i..e., you can change its coordinate $ x_i $ to $ x_i - 1 $ or to $ x_i + 1 $ ). In other words, for each point, you choose (separately) its new coordinate. For the $ i $ -th point, it can be either $ x_i - 1 $ , $ x_i $ or $ x_i + 1 $ .

Your task is to determine if you can move some points as described above in such a way that the new set of points forms a consecutive segment of integers, i. e. for some integer $ l $ the coordinates of points should be equal to $ l, l + 1, \ldots, l + n - 1 $ .

Note that the resulting points should have distinct coordinates.

You have to answer $ t $ independent test cases.

## 输入格式

The first line of the input contains one integer $ t $ ( $ 1 \le t \le 2 \cdot 10^4 $ ) — the number of test cases. Then $ t $ test cases follow.

The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of points in the set $ x $ .

The second line of the test case contains $ n $ integers $ x_1 < x_2 < \ldots < x_n $ ( $ 1 \le x_i \le 10^6 $ ), where $ x_i $ is the coordinate of the $ i $ -th point.

It is guaranteed that the points are given in strictly increasing order (this also means that all coordinates are distinct). It is also guaranteed that the sum of $ n $ does not exceed $ 2 \cdot 10^5 $ ( $ \sum n \le 2 \cdot 10^5 $ ).

## 输出格式

For each test case, print the answer — if the set of points from the test case can be moved to form a consecutive segment of integers, print YES, otherwise print NO.

## 样例 #1

### 输入

```
5
2
1 4
3
1 2 3
4
1 2 3 7
1
1000000
3
2 5 6
```

### 输出

```
YES
YES
NO
YES
YES
```



---

---
title: "Unequal Array"
layout: "post"
diff: 普及-
pid: CF1672C
tag: []
---

# Unequal Array

## 题目描述

You are given an array $ a $ of length $ n $ . We define the equality of the array as the number of indices $ 1 \le i \le n - 1 $ such that $ a_i = a_{i + 1} $ . We are allowed to do the following operation:

- Select two integers $ i $ and $ x $ such that $ 1 \le i \le n - 1 $ and $ 1 \le x \le 10^9 $ . Then, set $ a_i $ and $ a_{i + 1} $ to be equal to $ x $ .

Find the minimum number of operations needed such that the equality of the array is less than or equal to $ 1 $ .

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 2 \le n \le 2 \cdot 10 ^ 5 $ ) — the length of array $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — elements of the array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10 ^ 5 $

## 输出格式

For each test case, print the minimum number of operations needed.

## 说明/提示

In the first test case, we can select $ i=2 $ and $ x=2 $ to form $ [1, 2, 2, 1, 1] $ . Then, we can select $ i=3 $ and $ x=3 $ to form $ [1, 2, 3, 3, 1] $ .

In the second test case, we can select $ i=3 $ and $ x=100 $ to form $ [2, 1, 100, 100, 2] $ .

## 样例 #1

### 输入

```
4
5
1 1 1 1 1
5
2 1 1 1 2
6
1 1 2 3 3 4
6
1 2 1 4 5 4
```

### 输出

```
2
1
2
0
```



---

---
title: "Subtle Substring Subtraction"
layout: "post"
diff: 普及-
pid: CF1673A
tag: []
---

# Subtle Substring Subtraction

## 题目描述

Alice and Bob are playing a game with strings. There will be $ t $ rounds in the game. In each round, there will be a string $ s $ consisting of lowercase English letters.

Alice moves first and both the players take alternate turns. Alice is allowed to remove any substring of even length (possibly empty) and Bob is allowed to remove any substring of odd length from $ s $ .

More formally, if there was a string $ s = s_1s_2 \ldots s_k $ the player can choose a substring $ s_ls_{l+1} \ldots s_{r-1}s_r $ with length of corresponding parity and remove it. After that the string will become $ s = s_1 \ldots s_{l-1}s_{r+1} \ldots s_k $ .

After the string becomes empty, the round ends and each player calculates his/her score for this round. The score of a player is the sum of values of all characters removed by him/her. The value of $ \texttt{a} $ is $ 1 $ , the value of $ \texttt{b} $ is $ 2 $ , the value of $ \texttt{c} $ is $ 3 $ , $ \ldots $ , and the value of $ \texttt{z} $ is $ 26 $ . The player with higher score wins the round. For each round, determine the winner and the difference between winner's and loser's scores. Assume that both players play optimally to maximize their score. It can be proved that a draw is impossible.

## 输入格式

The first line of input contains a single integer $ t $ ( $ 1\leq t\leq 5\cdot 10^4 $ ) denoting the number of rounds.

Each of the next $ t $ lines contain a single string $ s $ ( $ 1\leq |s|\leq 2\cdot 10^5 $ ) consisting of lowercase English letters, denoting the string used for the round. Here $ |s| $ denotes the length of the string $ s $ .

It is guaranteed that the sum of $ |s| $ over all rounds does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each round, print a single line containing a string and an integer. If Alice wins the round, the string must be "Alice". If Bob wins the round, the string must be "Bob". The integer must be the difference between their scores assuming both players play optimally.

## 说明/提示

For the first round, $ \texttt{"aba"}\xrightarrow{\texttt{Alice}}\texttt{"}{\color{red}{\texttt{ab}}}\texttt{a"}\xrightarrow{} \texttt{"a"}\xrightarrow{\texttt{Bob}}\texttt{"}{\color{red}{\texttt{a}}}\texttt{"}\xrightarrow{}\texttt{""} $ . Alice's total score is $ 1+2=3 $ . Bob's total score is $ 1 $ .

For the second round, $ \texttt{"abc"}\xrightarrow{\texttt{Alice}}\texttt{"a}{\color{red}{\texttt{bc}}}\texttt{"}\xrightarrow{} \texttt{"a"}\xrightarrow{\texttt{Bob}}\texttt{"}{\color{red}{\texttt{a}}}\texttt{"}\xrightarrow{}\texttt{""} $ . Alice's total score is $ 2+3=5 $ . Bob's total score is $ 1 $ .

For the third round, $ \texttt{"cba"}\xrightarrow{\texttt{Alice}}\texttt{"}{\color{red}{\texttt{cb}}}\texttt{a"}\xrightarrow{} \texttt{"a"}\xrightarrow{\texttt{Bob}}\texttt{"}{\color{red}{\texttt{a}}}\texttt{"}\xrightarrow{}\texttt{""} $ . Alice's total score is $ 3+2=5 $ . Bob's total score is $ 1 $ .

For the fourth round, $ \texttt{"n"}\xrightarrow{\texttt{Alice}}\texttt{"n"}\xrightarrow{} \texttt{"n"}\xrightarrow{\texttt{Bob}}\texttt{"}{\color{red}{\texttt{n}}}\texttt{"}\xrightarrow{}\texttt{""} $ . Alice's total score is $ 0 $ . Bob's total score is $ 14 $ .

For the fifth round, $ \texttt{"codeforces"}\xrightarrow{\texttt{Alice}}\texttt{"}{\color{red}{\texttt{codeforces}}}\texttt{"}\xrightarrow{} \texttt{""} $ . Alice's total score is $ 3+15+4+5+6+15+18+3+5+19=93 $ . Bob's total score is $ 0 $ .

## 样例 #1

### 输入

```
5
aba
abc
cba
n
codeforces
```

### 输出

```
Alice 2
Alice 4
Alice 4
Bob 14
Alice 93
```



---

---
title: "Infinite Replacement"
layout: "post"
diff: 普及-
pid: CF1674C
tag: []
---

# Infinite Replacement

## 题目描述

You are given a string $ s $ , consisting only of Latin letters 'a', and a string $ t $ , consisting of lowercase Latin letters.

In one move, you can replace any letter 'a' in the string $ s $ with a string $ t $ . Note that after the replacement string $ s $ might contain letters other than 'a'.

You can perform an arbitrary number of moves (including zero). How many different strings can you obtain? Print the number, or report that it is infinitely large.

Two strings are considered different if they have different length, or they differ at some index.

## 输入格式

The first line contains a single integer $ q $ ( $ 1 \le q \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains a non-empty string $ s $ , consisting only of Latin letters 'a'. The length of $ s $ doesn't exceed $ 50 $ .

The second line contains a non-empty string $ t $ , consisting of lowercase Latin letters. The length of $ t $ doesn't exceed $ 50 $ .

## 输出格式

For each testcase, print the number of different strings $ s $ that can be obtained after an arbitrary amount of moves (including zero). If the number is infinitely large, print -1. Otherwise, print the number.

## 说明/提示

In the first example, you can replace any letter 'a' with the string "a", but that won't change the string. So no matter how many moves you make, you can't obtain a string other than the initial one.

In the second example, you can replace the second letter 'a' with "abc". String $ s $ becomes equal to "aabc". Then the second letter 'a' again. String $ s $ becomes equal to "aabcbc". And so on, generating infinitely many different strings.

In the third example, you can either leave string $ s $ as is, performing zero moves, or replace the only 'a' with "b". String $ s $ becomes equal to "b", so you can't perform more moves on it.

## 样例 #1

### 输入

```
3
aaaa
a
aa
abc
a
b
```

### 输出

```
1
-1
2
```



---

---
title: "Everything Everywhere All But One"
layout: "post"
diff: 普及-
pid: CF1686A
tag: []
---

# Everything Everywhere All But One

## 题目描述

You are given an array of $ n $ integers $ a_1, a_2, \ldots, a_n $ . After you watched the amazing film "Everything Everywhere All At Once", you came up with the following operation.

In one operation, you choose $ n-1 $ elements of the array and replace each of them with their arithmetic mean (which doesn't have to be an integer). For example, from the array $ [1, 2, 3, 1] $ we can get the array $ [2, 2, 2, 1] $ , if we choose the first three elements, or we can get the array $ [\frac{4}{3}, \frac{4}{3}, 3, \frac{4}{3}] $ , if we choose all elements except the third.

Is it possible to make all elements of the array equal by performing a finite number of such operations?

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 200 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 3 \le n \le 50 $ ) — the number of integers.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 100 $ ).

## 输出格式

For each test case, if it is possible to make all elements equal after some number of operations, output $ \texttt{YES} $ . Otherwise, output $ \texttt{NO} $ .

You can output $ \texttt{YES} $ and $ \texttt{NO} $ in any case (for example, strings $ \texttt{yEs} $ , $ \texttt{yes} $ , $ \texttt{Yes} $ will be recognized as a positive response).

## 说明/提示

In the first test case, all elements are already equal.

In the second test case, you can choose all elements except the third, their average is $ \frac{1 + 2 + 4 + 5}{4} = 3 $ , so the array will become $ [3, 3, 3, 3, 3] $ .

It's possible to show that it's impossible to make all elements equal in the third and fourth test cases.

## 样例 #1

### 输入

```
4
3
42 42 42
5
1 2 3 4 5
4
4 3 2 1
3
24 2 22
```

### 输出

```
YES
YES
NO
NO
```



---

---
title: "Odd Subarrays"
layout: "post"
diff: 普及-
pid: CF1686B
tag: []
---

# Odd Subarrays

## 题目描述

For an array $ [b_1, b_2, \ldots, b_m] $ define its number of inversions as the number of pairs $ (i, j) $ of integers such that $ 1 \le i < j \le m $ and $ b_i>b_j $ . Let's call array $ b $ odd if its number of inversions is odd.

For example, array $ [4, 2, 7] $ is odd, as its number of inversions is $ 1 $ , while array $ [2, 1, 4, 3] $ isn't, as its number of inversions is $ 2 $ .

You are given a permutation $ [p_1, p_2, \ldots, p_n] $ of integers from $ 1 $ to $ n $ (each of them appears exactly once in the permutation). You want to split it into several consecutive subarrays (maybe just one), so that the number of the odd subarrays among them is as large as possible.

What largest number of these subarrays may be odd?

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 10^5 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the size of the permutation.

The second line of each test case contains $ n $ integers $ p_1, p_2, \ldots, p_n $ ( $ 1 \le p_i \le n $ , all $ p_i $ are distinct) — the elements of the permutation.

The sum of $ n $ over all test cases doesn't exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case output a single integer — the largest possible number of odd subarrays that you can get after splitting the permutation into several consecutive subarrays.

## 说明/提示

In the first and third test cases, no matter how we split our permutation, there won't be any odd subarrays.

In the second test case, we can split our permutation into subarrays $ [4, 3], [2, 1] $ , both of which are odd since their numbers of inversions are $ 1 $ .

In the fourth test case, we can split our permutation into a single subarray $ [2, 1] $ , which is odd.

In the fifth test case, we can split our permutation into subarrays $ [4, 5], [6, 1, 2, 3] $ . The first subarray has $ 0 $ inversions, and the second has $ 3 $ , so it is odd.

## 样例 #1

### 输入

```
5
3
1 2 3
4
4 3 2 1
2
1 2
2
2 1
6
4 5 6 1 2 3
```

### 输出

```
0
2
0
1
1
```



---

---
title: "Lex String"
layout: "post"
diff: 普及-
pid: CF1689A
tag: []
---

# Lex String

## 题目描述

Kuznecov likes art, poetry, and music. And strings consisting of lowercase English letters.

Recently, Kuznecov has found two strings, $ a $ and $ b $ , of lengths $ n $ and $ m $ respectively. They consist of lowercase English letters and no character is contained in both strings.

Let another string $ c $ be initially empty. Kuznecov can do the following two types of operations:

- Choose any character from the string $ a $ , remove it from $ a $ , and add it to the end of $ c $ .
- Choose any character from the string $ b $ , remove it from $ b $ , and add it to the end of $ c $ .

But, he can not do more than $ k $ operations of the same type in a row. He must perform operations until either $ a $ or $ b $ becomes empty. What is the lexicographically smallest possible value of $ c $ after he finishes?

A string $ x $ is lexicographically smaller than a string $ y $ if and only if one of the following holds:

- $ x $ is a prefix of $ y $ , but $ x \neq y $ ;
- in the first position where $ x $ and $ y $ differ, the string $ x $ has a letter that appears earlier in the alphabet than the corresponding letter in $ y $ .

## 输入格式

There are several test cases in the input data. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases. This is followed by the test cases description.

The first line of each test case contains three integers $ n $ , $ m $ , and $ k $ ( $ 1\leq n,m,k \leq 100 $ ) — parameters from the statement.

The second line of each test case contains the string $ a $ of length $ n $ .

The third line of each test case contains the string $ b $ of length $ m $ .

The strings contain only lowercase English letters. It is guaranteed that no symbol appears in $ a $ and $ b $ simultaneously.

## 输出格式

In each test case, output a single string $ c $ — the answer to the problem.

## 说明/提示

In the first test case, it is optimal to take two 'a's from the string $ a $ and add them to the string $ c $ . Then it is forbidden to take more characters from $ a $ , hence one character 'b' from the string $ b $ has to be taken. Following that logic, we end up with $ c $ being 'aabaabaa' when string $ a $ is emptied.

In the second test case it is optimal to take as many 'a's from string $ a $ as possible, then take as many 'b's as possible from string $ b $ . In the end, we take two 'c's from the string $ a $ emptying it.

## 样例 #1

### 输入

```
3
6 4 2
aaaaaa
bbbb
5 9 3
caaca
bedededeb
7 7 1
noskill
wxhtzdy
```

### 输出

```
aabaabaa
aaabbcc
dihktlwlxnyoz
```



---

---
title: "Mystic Permutation"
layout: "post"
diff: 普及-
pid: CF1689B
tag: []
---

# Mystic Permutation

## 题目描述

Monocarp is a little boy who lives in Byteland and he loves programming.

Recently, he found a permutation of length $ n $ . He has to come up with a mystic permutation. It has to be a new permutation such that it differs from the old one in each position.

More formally, if the old permutation is $ p_1,p_2,\ldots,p_n $ and the new one is $ q_1,q_2,\ldots,q_n $ it must hold that $ $$$p_1\neq q_1, p_2\neq q_2, \ldots ,p_n\neq q_n. $ $$$

Monocarp is afraid of lexicographically large permutations. Can you please help him to find the lexicographically minimal mystic permutation?

## 输入格式

There are several test cases in the input data. The first line contains a single integer $ t $ ( $ 1\leq t\leq 200 $ ) — the number of test cases. This is followed by the test cases description.

The first line of each test case contains a positive integer $ n $ ( $ 1\leq n\leq 1000 $ ) — the length of the permutation.

The second line of each test case contains $ n $ distinct positive integers $ p_1, p_2, \ldots, p_n $ ( $ 1 \leq p_i \leq n $ ). It's guaranteed that $ p $ is a permutation, i. e. $ p_i \neq p_j $ for all $ i \neq j $ .

It is guaranteed that the sum of $ n $ does not exceed $ 1000 $ over all test cases.

## 输出格式

For each test case, output $ n $ positive integers — the lexicographically minimal mystic permutations. If such a permutation does not exist, output $ -1 $ instead.

## 说明/提示

In the first test case possible permutations that are mystic are $ [2,3,1] $ and $ [3,1,2] $ . Lexicographically smaller of the two is $ [2,3,1] $ .

In the second test case, $ [1,2,3,4,5] $ is the lexicographically minimal permutation and it is also mystic.

In third test case possible mystic permutations are $ [1,2,4,3] $ , $ [1,4,2,3] $ , $ [1,4,3,2] $ , $ [3,1,4,2] $ , $ [3,2,4,1] $ , $ [3,4,2,1] $ , $ [4,1,2,3] $ , $ [4,1,3,2] $ and $ [4,3,2,1] $ . The smallest one is $ [1,2,4,3] $ .

## 样例 #1

### 输入

```
4
3
1 2 3
5
2 3 4 5 1
4
2 3 1 4
1
1
```

### 输出

```
2 3 1
1 2 3 4 5
1 2 4 3
-1
```



---

---
title: "Print a Pedestal (Codeforces logo?)"
layout: "post"
diff: 普及-
pid: CF1690A
tag: []
---

# Print a Pedestal (Codeforces logo?)

## 题目描述

给您一些个数为 $n$ 的方块，请您用这些方块构造一个台座~~CodeForces的徽标~~，每个方块必须都被使用。

这个台座包含三个宽度为 $1$ 格的颁奖台——从左向右依次为第 $2$ 名、第 $1$ 名和第 $3$ 名的位置。

第 $1$ 名的颁奖台必须严格高于第 $2$ 名的颁奖台，第 $2$ 名的颁奖台必须严格高于第 $3$ 名的颁奖台。 此外，每个颁奖台的高度必须大于零（即每个颁奖台必须至少包含一个方块）。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjwn88is.png)

如上图所示，我们用 $n = 11$ 个方块构造出了合法的台座：第二名的颁奖台的高度是 $4$，第一名高度是 $5$ 而第三名高度是 $2$

在所有的可以被构建出的台座中，我们希望让第一名的颁奖台高度**最低**。

如果有多种可能，输出任意一种即可。

## 输入格式

第一行一个整数 $t$ $(1\le t\le 10^4)$ 代表数据组数

下面 $t$ 行，每行一个整数 $n$ $(6\le n\le 10^5)$ 代表可以使用的方块数量。注意所有 $n$ 个方块必须都被使用。

保证一个数据点中所有 $n$ 的和不超过 $10^6$

## 输出格式

对于每一组测试数据，您需要输出三个整数 $h_2$ ，$h_1$ 和 $h_3$ ，代表了每个颁奖台高度。

在所有的可以被构建出的台座中，我们希望让第一名的颁奖台高度最低。

如果有多种可能，输出任意一种即可。

## 说明/提示

在第一组样例中我们不能让第一名的颁奖台台高度小于 $5$ ，因为如果第一名的平台高度不超过 $4$ ，我们最多只可以使用 $4 + 3 + 2 = 9$ 个方块。

当第一名的颁奖台高度是  $5$ 的时候，注意到 $11 = 4 + 5 + 2$ ， 因此答案 $4$ $5$ $2$ 合法。

在第二组样例中只有一种合法答案：$2$ $3$ $1$

## 样例 #1

### 输入

```
6
11
6
10
100000
7
8
```

### 输出

```
4 5 2
2 3 1
4 5 1
33334 33335 33331
2 4 1
3 4 1
```



---

---
title: "Array Decrements"
layout: "post"
diff: 普及-
pid: CF1690B
tag: []
---

# Array Decrements

## 题目描述

Kristina has two arrays $ a $ and $ b $ , each containing $ n $ non-negative integers. She can perform the following operation on array $ a $ any number of times:

- apply a decrement to each non-zero element of the array, that is, replace the value of each element $ a_i $ such that $ a_i > 0 $ with the value $ a_i - 1 $ ( $ 1 \le i \le n $ ). If $ a_i $ was $ 0 $ , its value does not change.

Determine whether Kristina can get an array $ b $ from an array $ a $ in some number of operations (probably zero). In other words, can she make $ a_i = b_i $ after some number of operations for each $ 1 \le i \le n $ ?

For example, let $ n = 4 $ , $ a = [3, 5, 4, 1] $ and $ b = [1, 3, 2, 0] $ . In this case, she can apply the operation twice:

- after the first application of the operation she gets $ a = [2, 4, 3, 0] $ ;
- after the second use of the operation she gets $ a = [1, 3, 2, 0] $ .

Thus, in two operations, she can get an array $ b $ from an array $ a $ .

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) —the number of test cases in the test.

The descriptions of the test cases follow.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 5 \cdot 10^4 $ ).

The second line of each test case contains exactly $ n $ non-negative integers $ a_1, a_2, \dots, a_n $ ( $ 0 \le a_i \le 10^9 $ ).

The third line of each test case contains exactly $ n $ non-negative integers $ b_1, b_2, \dots, b_n $ ( $ 0 \le b_i \le 10^9 $ ).

It is guaranteed that the sum of $ n $ values over all test cases in the test does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output on a separate line:

- YES, if by doing some number of operations it is possible to get an array $ b $ from an array $ a $ ;
- NO otherwise.

You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

## 说明/提示

The first test case is analyzed in the statement.

In the second test case, it is enough to apply the operation to array $ a $ once.

In the third test case, it is impossible to get array $ b $ from array $ a $ .

## 样例 #1

### 输入

```
6
4
3 5 4 1
1 3 2 0
3
1 2 1
0 1 0
4
5 3 7 2
1 1 1 1
5
1 2 3 4 5
1 2 3 4 6
1
8
0
1
4
6
```

### 输出

```
YES
YES
NO
NO
YES
NO
```



---

---
title: "Restoring the Duration of Tasks"
layout: "post"
diff: 普及-
pid: CF1690C
tag: []
---

# Restoring the Duration of Tasks

## 题目描述

Recently, Polycarp completed $ n $ successive tasks.

For each completed task, the time $ s_i $ is known when it was given, no two tasks were given at the same time. Also given is the time $ f_i $ when the task was completed. For each task, there is an unknown value $ d_i $ ( $ d_i>0 $ ) — duration of task execution.

It is known that the tasks were completed in the order in which they came. Polycarp performed the tasks as follows:

- As soon as the very first task came, Polycarp immediately began to carry it out.
- If a new task arrived before Polycarp finished the previous one, he put the new task at the end of the queue.
- When Polycarp finished executing the next task and the queue was not empty, he immediately took a new task from the head of the queue (if the queue is empty — he just waited for the next task).

Find $ d_i $ (duration) of each task.

### 题目翻译

Polycarp（以下称为Pc）得到了 $n\ (1\le n\le2\times 10^5)$ 个任务。

每个任务有两个属性 $s_i$ 和 $f_i$，分别表示这个任务开始和结束的时间。

Pc在任务开始时间没到的时候什么都不会做，时间一到就会立马开始。

在任务期间，下一个任务来了Pc会把这个任务加到任务列表的末尾。

当处理完一个任务后，如果任务列表还有任务时，会立马处理第一个任务。

当处理完一个任务后，如果任务列表没有任务了，Pc什么都不会做直到下一个任务来临。

处理每个任务的时间就是原文中的 $d_i$。

测试数据个数 $t\ (1\le t\le 10^4)$。

**输入：**

第一行，$t$。

对于每一个测试数据：

第一行一个任务数 $n$，

第二行 $n$ 个正整数，表示 $s_1<s_2<s_2<...<s_n\ (0\le s_i\le 10^9)$，

第三行 $n$ 个正整数，表示 $f_1<f_2<f_3<...<f_n\ (s_i<f_i\le 10^9)$。

**输出：**

对于每一个测试数据，一行 $n$ 个正整数，表示 $d_i$。

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The descriptions of the input data sets follow.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ).

The second line of each test case contains exactly $ n $ integers $ s_1 < s_2 < \dots < s_n $ ( $ 0 \le s_i \le 10^9 $ ).

The third line of each test case contains exactly $ n $ integers $ f_1 < f_2 < \dots < f_n $ ( $ s_i < f_i \le 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each of $ t $ test cases print $ n $ positive integers $ d_1, d_2, \dots, d_n $ — the duration of each task.

## 说明/提示

First test case:

The queue is empty at the beginning: $ [ ] $ . And that's where the first task comes in. At time $ 2 $ , Polycarp finishes doing the first task, so the duration of the first task is $ 2 $ . The queue is empty so Polycarp is just waiting.

At time $ 3 $ , the second task arrives. And at time $ 7 $ , the third task arrives, and now the queue looks like this: $ [7] $ .

At the time $ 10 $ , Polycarp finishes doing the second task, as a result, the duration of the second task is $ 7 $ .

And at time $ 10 $ , Polycarp immediately starts doing the third task and finishes at time $ 11 $ . As a result, the duration of the third task is $ 1 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1690C/d2350660c42c220190947ba223600b0328cd0bf5.png)An example of the first test case.

## 样例 #1

### 输入

```
4
3
0 3 7
2 10 11
2
10 15
11 16
9
12 16 90 195 1456 1569 3001 5237 19275
13 199 200 260 9100 10000 10914 91066 5735533
1
0
1000000000
```

### 输出

```
2 7 1 
1 1 
1 183 1 60 7644 900 914 80152 5644467 
1000000000
```



---

---
title: "Black and White Stripe"
layout: "post"
diff: 普及-
pid: CF1690D
tag: []
---

# Black and White Stripe

## 题目描述

You have a stripe of checkered paper of length $ n $ . Each cell is either white or black.

What is the minimum number of cells that must be recolored from white to black in order to have a segment of $ k $ consecutive black cells on the stripe?

If the input data is such that a segment of $ k $ consecutive black cells already exists, then print 0.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Next, descriptions of $ t $ test cases follow.

The first line of the input contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 2\cdot10^5 $ ). The second line consists of the letters 'W' (white) and 'B' (black). The line length is $ n $ .

It is guaranteed that the sum of values $ n $ does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each of $ t $ test cases print an integer — the minimum number of cells that need to be repainted from white to black in order to have a segment of $ k $ consecutive black cells.

## 说明/提示

In the first test case, $ s $ ="BBWBW" and $ k=3 $ . It is enough to recolor $ s_3 $ and get $ s $ ="BBBBW". This string contains a segment of length $ k=3 $ consisting of the letters 'B'.

In the second test case of the example $ s $ ="BBWBW" and $ k=5 $ . It is enough to recolor $ s_3 $ and $ s_5 $ and get $ s $ ="BBBBB". This string contains a segment of length $ k=5 $ consisting of the letters 'B'.

In the third test case of the example $ s $ ="BBWBW" and $ k=1 $ . The string $ s $ already contains a segment of length $ k=1 $ consisting of the letters 'B'.

## 样例 #1

### 输入

```
4
5 3
BBWBW
5 5
BBWBW
5 1
BBWBW
1 1
W
```

### 输出

```
1
2
0
1
```



---

---
title: "Shoe Shuffling"
layout: "post"
diff: 普及-
pid: CF1691B
tag: []
---

# Shoe Shuffling

## 题目描述

一个班的学生想要互相换鞋子，假设这个班有 $n$ 名学生，给定一个**非递减**的序列记录每个学生鞋子的码数。你需要给出一个下标排列，使得每个学生拿到的都不是自己的鞋子，并且码数与原来的相同。如果找不到这样的下标排列，输出 $-1$ 。

定义一个下标排列由整数 $1$ 到 $n$ 组成，顺序任意。比如， $ [2,3,1,5,4] $ 是一个下标序列；$ [1,2,2] $ 不是一个下标数列，因为 $2$ 出现了两次；$ [1,3,4] $ 不是一个下标序列，因为排列的长度为 $3$ 却出现了元素 $4$。

## 输入格式

每个测试点有多组数据。

第一行一个整数 $t$ ( $ 1 \le t \le 1000 $ )，表示共有 $t$  组数据。

接下来 $2t$ 行。每组数据 $2$ 行。

每组数据的第一行一个整数 $n$ ( $ 1\leq n\leq10^5 $ ) 表示学生个数。

每组数据第二行 $n$ 个整数  $ s_1, s_2,\ldots,s_n $ ( $ 1\leq s_i\leq10^9 $ ，对于所有 $ 1\le i<n $ , $ s_i\le s_{i+1} $ ) ，表示学生鞋子的码数。

保证所有数据 $n$ 的和不超过 $ 10^5 $ 。

## 说明/提示

对于第一组数据，除了 $[1, 2, 3, 4, 5]$ 外的长度为 $5$ 的下标序列都是合法的，因为每个同学之间都能穿对方的鞋子。

对于第二组数据，可以证明没有合法的下标序列。

## 样例 #1

### 输入

```
2
5
1 1 1 1 1
6
3 6 8 13 15 21
```

### 输出

```
5 1 2 3 4 
-1
```



---

---
title: "Where's the Bishop?"
layout: "post"
diff: 普及-
pid: CF1692C
tag: []
---

# Where's the Bishop?

## 题目描述

Mihai has an $ 8 \times 8 $ chessboard whose rows are numbered from $ 1 $ to $ 8 $ from top to bottom and whose columns are numbered from $ 1 $ to $ 8 $ from left to right.

Mihai has placed exactly one bishop on the chessboard. The bishop is not placed on the edges of the board. (In other words, the row and column of the bishop are between $ 2 $ and $ 7 $ , inclusive.)

The bishop attacks in all directions diagonally, and there is no limit to the distance which the bishop can attack. Note that the cell on which the bishop is placed is also considered attacked.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1692C/a628ab5b17df485b146f85dc0b0977dd4288932f.png)An example of a bishop on a chessboard. The squares it attacks are marked in red.Mihai has marked all squares the bishop attacks, but forgot where the bishop was! Help Mihai find the position of the bishop.

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \leq t \leq 36 $ ) — the number of test cases. The description of test cases follows. There is an empty line before each test case.

Each test case consists of $ 8 $ lines, each containing $ 8 $ characters. Each of these characters is either '\#' or '.', denoting a square under attack and a square not under attack, respectively.

## 输出格式

For each test case, output two integers $ r $ and $ c $ ( $ 2 \leq r, c \leq 7 $ ) — the row and column of the bishop.

The input is generated in such a way that there is always exactly one possible location of the bishop that is not on the edge of the board.

## 说明/提示

The first test case is pictured in the statement. Since the bishop lies in the intersection row $ 4 $ and column $ 3 $ , the correct output is 4 3.

## 样例 #1

### 输入

```
3

.....#..
#...#...
.#.#....
..#.....
.#.#....
#...#...
.....#..
......#.

#.#.....
.#......
#.#.....
...#....
....#...
.....#..
......#.
.......#

.#.....#
..#...#.
...#.#..
....#...
...#.#..
..#...#.
.#.....#
#.......
```

### 输出

```
4 3
2 2
4 5
```



---

---
title: "The Clock"
layout: "post"
diff: 普及-
pid: CF1692D
tag: []
---

# The Clock

## 题目描述

Victor has a [24-hour clock](https://en.wikipedia.org/wiki/24-hour_clock) that shows the time in the format "HH:MM" (00 $ \le $ HH $ \le $ 23, 00 $ \le $ MM $ \le $ 59). He looks at the clock every $ x $ minutes, and the clock is currently showing time $ s $ .

How many different palindromes will Victor see in total after looking at the clock every $ x $ minutes, the first time being at time $ s $ ?

For example, if the clock starts out as 03:12 and Victor looks at the clock every $ 360 $ minutes (i.e. every $ 6 $ hours), then he will see the times 03:12, 09:12, 15:12, 21:12, 03:12, and the times will continue to repeat. Here the time 21:12 is the only palindrome he will ever see, so the answer is $ 1 $ .

A palindrome is a string that reads the same backward as forward. For example, the times 12:21, 05:50, 11:11 are palindromes but 13:13, 22:10, 02:22 are not.

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases. The description of each test case follows.

The only line of each test case contains a string $ s $ of length $ 5 $ with the format "HH:MM" where "HH" is from "00" to "23" and "MM" is from "00" to "59" (both "HH" and "MM" have exactly two digits) and an integer $ x $ ( $ 1 \leq x \leq 1440 $ ) — the number of minutes Victor takes to look again at the clock.

## 输出格式

For each test case, output a single integer — the number of different palindromes Victor will see if he looks at the clock every $ x $ minutes starting from time $ s $ .

## 说明/提示

The first test case is explained in the statement.

## 样例 #1

### 输入

```
6
03:12 360
00:00 1
13:22 2
15:15 10
11:11 1440
22:30 27
```

### 输出

```
1
16
10
0
1
1
```



---

---
title: "Binary Deque"
layout: "post"
diff: 普及-
pid: CF1692E
tag: []
---

# Binary Deque

## 题目描述

Slavic has an array of length $ n $ consisting only of zeroes and ones. In one operation, he removes either the first or the last element of the array.

What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to $ s $ after performing all the operations? In case the sum $ s $ can't be obtained after any amount of operations, you should output -1.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ s $ ( $ 1 \leq n, s \leq 2 \cdot 10^5 $ ) — the length of the array and the needed sum of elements.

The second line of each test case contains $ n $ integers $ a_i $ ( $ 0 \leq a_i \leq 1 $ ) — the elements of the array.

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the minimum amount of operations required to have the total sum of the array equal to $ s $ , or -1 if obtaining an array with sum $ s $ isn't possible.

## 说明/提示

In the first test case, the sum of the whole array is $ 1 $ from the beginning, so we don't have to make any operations.

In the second test case, the sum of the array is $ 2 $ and we want it to be equal to $ 1 $ , so we should remove the first element. The array turns into $ [1, 0] $ , which has a sum equal to $ 1 $ .

In the third test case, the sum of the array is $ 5 $ and we need it to be $ 3 $ . We can obtain such a sum by removing the first two elements and the last element, doing a total of three operations. The array turns into $ [0, 1, 1, 1, 0, 0] $ , which has a sum equal to $ 3 $ .

## 样例 #1

### 输入

```
7
3 1
1 0 0
3 1
1 1 0
9 3
0 1 0 1 1 1 0 0 1
6 4
1 1 1 1 1 1
5 1
0 0 1 1 0
16 2
1 1 0 0 1 0 0 1 1 0 0 0 0 0 1 1
6 3
1 0 1 0 0 0
```

### 输出

```
0
1
3
2
2
7
-1
```



---

---
title: "3SUM"
layout: "post"
diff: 普及-
pid: CF1692F
tag: []
---

# 3SUM

## 题目描述

给出一个长度为 $n$ 的正整数数组 $a$，判断是否存在三个不同的下标 $i$，$j$，$k$，使 $a_i+a_j+a_k$以数字 $3$ 结尾。

## 输入格式

第一行包含一个整数 $t$ $(1≤t≤1000)$——测试数据的组数。

每组测试数据的第一行包含一个整数 $ n $ ( $ 3 \leq n \leq 2 \cdot 10^5 $ ) ——数组的长度。

每组测试数据的第二行包含 $n$ 个整数 $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) ——数组的元素。

所有测试数据中的 $n$ 的总和不超过 $ 2 \cdot 10^5 $ 。

## 输出格式

输出 $t$ 行，每行包含对应的测试数据的答案。如果存在三个不同的下标 $i$，$j$，$k$，使 $a_i+a_j+a_k$以数字 $3$ 结尾，则输出 "YES"，否则输出 "NO"。

你可以输出任意大小写的答案（例如，字符串 "yEs"、"yes"、"Yes "和 "YES "都将被认为是正确的答案）。


## 样例 #1

### 样例输入 #1

```
6
4
20 22 19 84
4
1 11 1 2022
4
1100 1100 1100 1111
5
12 34 56 78 90
4
1 9 8 4
6
16 38 94 25 18 99
```

### 样例输出 #1

```
YES
YES
NO
NO
YES
YES
```

## 说明/提示

在第一组测试数据中，你可以选择 $ i=1 $ , $ j=4 $ , $ k=3 $，那么 $ a_1 + a_4 + a_3 = 20 + 84 + 19 = 123 $，以数字 $3$ 结尾

在第二组测试数据中，你可以选择 $ i=1 $ , $ j=2 $ , $ k=3 $，那么 $ a_1 + a_2 + a_3 = 1 + 11 + 1 = 13 $，以数字 $3$ 结尾

在第三组测试数据中，可以证明不存在这样的 $i$，$j$，$k$。请注意，$ i=4 $ , $ j=4 $ , $ k=4 $ 并不是一个有效的答案，因为尽管 $ a_4 + a_4 + a_4 = 1111 + 1111 + 1111 = 3333 $ 以数字3结尾，但题目中要求选择的三个下标是不同的。

在第四组测试数据中，可以证明不存在这样的 $i$，$j$，$k$。

在第五组测试数据中，你可以选择 $ i=4 $ , $ j=3 $ , $ k=1 $，那么 $ a_4 + a_3 + a_1 = 4 + 8 + 1 = 13 $，以数字 $3$ 结尾

在第六组测试数据中，你可以选择 $ i=1 $ , $ j=2 $ , $ k=6 $，那么 $ a_1 + a_2 + a_6 = 16 + 38 + 99 = 153 $，以数字 $3$ 结尾

## 样例 #1

### 输入

```
6
4
20 22 19 84
4
1 11 1 2022
4
1100 1100 1100 1111
5
12 34 56 78 90
4
1 9 8 4
6
16 38 94 25 18 99
```

### 输出

```
YES
YES
NO
NO
YES
YES
```



---

---
title: "2^Sort"
layout: "post"
diff: 普及-
pid: CF1692G
tag: []
---

# 2^Sort

## 题目描述

Given an array $ a $ of length $ n $ and an integer $ k $ , find the number of indices $ 1 \leq i \leq n - k $ such that the subarray $ [a_i, \dots, a_{i+k}] $ with length $ k+1 $ (not with length $ k $ ) has the following property:

- If you multiply the first element by $ 2^0 $ , the second element by $ 2^1 $ , ..., and the ( $ k+1 $ )-st element by $ 2^k $ , then this subarray is sorted in strictly increasing order.

 More formally, count the number of indices $ 1 \leq i \leq n - k $ such that $ $$$2^0 \cdot a_i < 2^1 \cdot a_{i+1} < 2^2 \cdot a_{i+2} < \dots < 2^k \cdot a_{i+k}. $ $$$

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ , $ k $ ( $ 3 \leq n \leq 2 \cdot 10^5 $ , $ 1 \leq k < n $ ) — the length of the array and the number of inequalities.

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the elements of the array.

The sum of $ n $ across all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the number of indices satisfying the condition in the statement.

## 说明/提示

In the first test case, both subarrays satisfy the condition:

- $ i=1 $ : the subarray $ [a_1,a_2,a_3] = [20,22,19] $ , and $ 1 \cdot 20 < 2 \cdot 22 < 4 \cdot 19 $ .
- $ i=2 $ : the subarray $ [a_2,a_3,a_4] = [22,19,84] $ , and $ 1 \cdot 22 < 2 \cdot 19 < 4 \cdot 84 $ .

 In the second test case, three subarrays satisfy the condition: - $ i=1 $ : the subarray $ [a_1,a_2] = [9,5] $ , and $ 1 \cdot 9 < 2 \cdot 5 $ .
- $ i=2 $ : the subarray $ [a_2,a_3] = [5,3] $ , and $ 1 \cdot 5 < 2 \cdot 3 $ .
- $ i=3 $ : the subarray $ [a_3,a_4] = [3,2] $ , and $ 1 \cdot 3 < 2 \cdot 2 $ .
- $ i=4 $ : the subarray $ [a_4,a_5] = [2,1] $ , but $ 1 \cdot 2 = 2 \cdot 1 $ , so this subarray doesn't satisfy the condition.

## 样例 #1

### 输入

```
6
4 2
20 22 19 84
5 1
9 5 3 2 1
5 2
9 5 3 2 1
7 2
22 12 16 4 3 22 12
7 3
22 12 16 4 3 22 12
9 3
3 9 12 3 9 12 3 9 12
```

### 输出

```
2
3
2
3
1
0
```



---

---
title: "Creep"
layout: "post"
diff: 普及-
pid: CF1694A
tag: []
---

# Creep

## 题目描述

请你构造出一个有 $a$ 个 $0$ 和 $b$ 个 $1$ 的字符串，使它的 $0$ 和 $1$ 的个数相差最多的前缀，$0$ 和 $1$ 的个数相差最少。若有多种答案，输出任意一种。多组数据。

## 输入格式

先输入数据组数 $t$，然后 $t$ 行，每行两个整数 $a,b$，表示一组数据。

## 输出格式

输出 $t$ 行，每行一个字符串，表示一组数据的答案。

## 说明/提示

$1\leq t\leq 1000$

$1\leq a,b\leq 100$

Translate by [庄nnnn额](https://www.luogu.com.cn/user/521592)

## 样例 #1

### 输入

```
5
1 1
1 2
5 2
4 5
3 7
```

### 输出

```
10
011
0011000
101010101
0001111111
```



---

---
title: "Paranoid String"
layout: "post"
diff: 普及-
pid: CF1694B
tag: []
---

# Paranoid String

## 题目描述

Let's call a binary string $ T $ of length $ m $ indexed from $ 1 $ to $ m $ paranoid if we can obtain a string of length $ 1 $ by performing the following two kinds of operations $ m-1 $ times in any order :

- Select any substring of $ T $ that is equal to 01, and then replace it with 1.
- Select any substring of $ T $ that is equal to 10, and then replace it with 0.For example, if $ T =  $ 001, we can select the substring $ [T_2T_3] $ and perform the first operation. So we obtain $ T =  $ 01.

You are given a binary string $ S $ of length $ n $ indexed from $ 1 $ to $ n $ . Find the number of pairs of integers $ (l, r) $ $ 1 \le l \le r \le n $ such that $ S[l \ldots r] $ (the substring of $ S $ from $ l $ to $ r $ ) is a paranoid string.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the size of $ S $ .

The second line of each test case contains a binary string $ S $ of $ n $ characters $ S_1S_2 \ldots S_n $ . ( $ S_i =  $ 0 or $ S_i =  $ 1 for each $ 1 \le i \le n $ )

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output the number of pairs of integers $ (l, r) $ $ 1 \le l \le r \le n $ such that $ S[l \ldots r] $ (the substring of $ S $ from $ l $ to $ r $ ) is a paranoid string.

## 说明/提示

In the first sample, $ S $ already has length $ 1 $ and doesn't need any operations.

In the second sample, all substrings of $ S $ are paranoid. For the entire string, it's enough to perform the first operation.

In the third sample, all substrings of $ S $ are paranoid except $ [S_2S_3] $ , because we can't perform any operations on it, and $ [S_1S_2S_3] $ (the entire string).

## 样例 #1

### 输入

```
5
1
1
2
01
3
100
4
1001
5
11111
```

### 输出

```
1
3
4
8
5
```



---

---
title: "Subrectangle Guess"
layout: "post"
diff: 普及-
pid: CF1695A
tag: []
---

# Subrectangle Guess

## 题目描述

Michael 和 Joe 在玩一个游戏。一共有 $t$ 次，每次 Michael 给出一个 $n\times m$ 的矩阵和一对 $h,w$，Jeo 在 Michael 看不见的情况下盖住任意一个 $h\times w$ 的子矩阵，问 Michael 这个子矩阵中最大的数是多少。Michael 答对即为获胜。

现在，我们对每一次给出的矩阵都要找出一对最小的 $h,w$，使得 Michael 一定能赢。

## 输入格式

第一行一个整数 $t$，表示有 $t$ 组数据。

接下来对于每一组数据：

第一行两个正整数 $n,m$，表示一个 $n\times m$ 的矩阵。

接下来 $n$ 行，每行 $m$ 个数，表示这个矩阵中的元素。

## 输出格式

对于每组数据，输出**一个整数**表示我们选出的 $h,w$ **的乘积**。

### 输入输出样例

#### 样例输入 #1

```plain
3
1 1
3
4 4
2 12 6 10
3 15 16 4
1 13 8 11
14 7 9 5
2 3
-7 5 2
0 8 -3
```
#### 样例输出 #1

```plain
1
9
4
```

## 说明/提示

在第一组数据中，矩阵是 $1\times 1$ 的，因此对于 $h,w$，唯一可能的选择是 $h=1，w=1$，给出了 $h\cdot w=1$ 的面积。

描述中展示了第二组数据给出的矩阵。可以证明，只要 $h=3$，$w=3$，迈克尔就能保证胜利，而只要 $h\cdot w\le 8$，任何选择都不能保证胜利。

对于所有数据，$1\le t\le 20,1\le n,m\le 40,-10^9\le 矩阵中的元素\le 10^9$。

## 样例 #1

### 输入

```
3
1 1
3
4 4
2 12 6 10
3 15 16 4
1 13 8 11
14 7 9 5
2 3
-7 5 2
0 8 -3
```

### 输出

```
1
9
4
```



---

---
title: "Circle Game"
layout: "post"
diff: 普及-
pid: CF1695B
tag: []
---

# Circle Game

## 题目描述

Mike 和 Joe 正在玩石子，迈克先手。他们有 $n$ 堆大小为 $a_1 , a_2,\ldots,a_n$ 的石子，堆呈圆形排列。

玩家从第一堆开始，顺时针依次从一堆中取出一些正数的石头。如果一个玩家在回合中从第 $i$ 堆取石头，另一个玩家在下一轮从 $ ((i\bmod n) + 1) $ 堆取石头。

如果玩家在回合中无法取走任何石头（因为堆是空的），他就输了。

假设 Mike 和 Joe 都采取最优策略，那么谁会赢？

## 输入格式

每个测试点包含多组数据。
第一行包含数据组数 $ t $ ( $ 1 \le t \le 1000 $ )。

每组数据的第一行包含一个整数 $ n $ ( $ 1$ $ \le50$ ) 表示堆的数量。
第二行包含 $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) 表示每个堆的大小。

## 输出格式

对于每组数据，在输出获胜者，Mike 或 Joe 。

## 样例 #1

### 输入

```
2
1
37
2
100 100
```

### 输出

```
Mike
Joe
```



---

---
title: "Rising Sand"
layout: "post"
diff: 普及-
pid: CF1698B
tag: []
---

# Rising Sand

## 题目描述

There are $ n $ piles of sand where the $ i $ -th pile has $ a_i $ blocks of sand. The $ i $ -th pile is called too tall if $ 1 < i < n $ and $ a_i > a_{i-1} + a_{i+1} $ . That is, a pile is too tall if it has more sand than its two neighbours combined. (Note that piles on the ends of the array cannot be too tall.)

You are given an integer $ k $ . An operation consists of picking $ k $ consecutive piles of sand and adding one unit of sand to them all. Formally, pick $ 1 \leq l,r \leq n $ such that $ r-l+1=k $ . Then for all $ l \leq i \leq r $ , update $ a_i \gets a_i+1 $ .

What is the maximum number of piles that can simultaneously be too tall after some (possibly zero) operations?

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 3 \leq n \leq 2 \cdot 10^5 $ ; $ 1 \leq k \leq n $ ) — the number of piles of sand and the size of the operation, respectively.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the sizes of the piles.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the maximum number of piles that are simultaneously too tall after some (possibly zero) operations.

## 说明/提示

In the first test case, we can perform the following three operations:

- Add one unit of sand to piles $ 1 $ and $ 2 $ : $ [\color{red}{3}, \color{red}{10}, 2, 4, 1] $ .
- Add one unit of sand to piles $ 4 $ and $ 5 $ : $ [3, 10, 2, \color{red}{5}, \color{red}{2}] $ .
- Add one unit of sand to piles $ 3 $ and $ 4 $ : $ [3, 10, \color{red}{3}, \color{red}{6}, 2] $ .

 Now piles $ 2 $ and $ 4 $ are too tall, so in this case the answer is $ 2 $ . It can be shown that it is impossible to make more than $ 2 $ piles too tall.In the second test case, any operation will increase all piles by $ 1 $ unit, so the number of too tall piles will always be $ 0 $ .

In the third test case, we can increase any pile by $ 1 $ unit of sand. It can be shown that the maximum number of too tall piles is $ 1 $ .

## 样例 #1

### 输入

```
3
5 2
2 9 2 4 1
4 4
1 3 2 1
3 1
1 3 1
```

### 输出

```
2
0
1
```



---

---
title: "Almost Ternary Matrix"
layout: "post"
diff: 普及-
pid: CF1699B
tag: []
---

# Almost Ternary Matrix

## 题目描述

给定偶数 $ n $ 和 $ m $，构造一个 $ n $ 行 $m $ 列只有0和1的方格矩阵，使得任意一个方格 $ (i,j) $ 正好有两个邻居方格的值不同与自己的值 $ a_{i,j} $ 。

公用一条边的两个方格视为邻居，准确为：方格 $ (x,y) $ 的邻居位置为 $ (x-1,y) $ ， $ (x+1,y) $ ， $ (x,y-1) $ ， $ (x,y+1) $ 。

## 输入格式

每个测试包含多组测试用例。第一行输入一个整数 $ t $ ( $ 1 \le t \le 100 $ ) ，即为测试用例的数量。

每个测试用例只有一行 $ n $ 和 $ m $ ，表示行数和列数。

## 输出格式

对于每个测试用例，输出 $ n $ 行，每行 $ m $ 个数，每个数为0或1，即为构成的满足条件的方格矩阵。

可以证明，在给定条件下，答案必定存在。

## 说明/提示

白代表0，黑代表1。

三张图分别表示样例的三个测试用例。

## 样例 #1

### 输入

```
3
2 4
2 2
4 4
```

### 输出

```
1 0 0 1
0 1 1 0
1 0
0 1
1 0 1 0
0 0 1 1
1 1 0 0
0 1 0 1
```



---

---
title: "Burglar and Matches"
layout: "post"
diff: 普及-
pid: CF16B
tag: []
---

# Burglar and Matches

## 题目描述

一个窃贼到火柴仓库偷火柴,仓库有 $m$ 个容器,第 $i$ 个容器有 $a_i$ 个火柴盒,其中每个火柴盒中有 $b_i$ 根火柴,窃贼最多可以拿 $n$ 个火柴盒 。

## 输入格式

第一行两个正整数 $n$，$m$ 下面 $m$ 行每行有两个数 $a_i$ 和 $b_i$。

## 输出格式

输出窃贼最多能偷多少根火柴。

## 说明/提示

#### 数据规模与约定

$ 1 \le n \le 2 \times 10^8$，$1 \le m \le 20$，$1 \le a_i \le 10^8$，$1 \le b_i \le 10$ 。

## 样例 #1

### 输入

```
7 3
5 10
2 5
3 6

```

### 输出

```
62

```

## 样例 #2

### 输入

```
3 3
1 3
2 2
3 1

```

### 输出

```
7

```



---

---
title: "Monitor"
layout: "post"
diff: 普及-
pid: CF16C
tag: []
---

# Monitor

## 题目描述

Reca company makes monitors, the most popular of their models is AB999 with the screen size $ a×b $ centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio $ x:y $ became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes $ x:y $ , at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.

## 输入格式

The first line of the input contains 4 integers — $ a $ , $ b $ , $ x $ and $ y $ ( $ 1<=a,b,x,y<=2·10^{9} $ ).

## 输出格式

If the answer exists, output 2 positive integers — screen parameters of the reduced size model. Output 0 0 otherwise.

## 样例 #1

### 输入

```
800 600 4 3

```

### 输出

```
800 600

```

## 样例 #2

### 输入

```
1920 1200 16 9

```

### 输出

```
1920 1080

```

## 样例 #3

### 输入

```
1 1 1 2

```

### 输出

```
0 0

```



---

---
title: "Optimal Path"
layout: "post"
diff: 普及-
pid: CF1700A
tag: []
---

# Optimal Path

## 题目描述

# 最优路径


你得到一个大小为 $ n \times m $ 的表 $ a $ 。我们将考虑从上到下从 $1$ 到 $n$ 编号的表格行，从左到右从 $1$ 到 $m$ 编号的列。我们将在 $ i $ -th 行和 $ j $ -th 列中的单元格表示为 $ (i, j) $ 。在单元格 $ (i, j) $ 中有一个数字 $ (i - 1) \cdot m + j $ ，即 $ a_{ij} = (i - 1) \cdot m + j $ 。

一只乌龟最初站在单元格 $ (1, 1) $ 中，它想来到单元格 $ (n, m) $ 。从单元格 $ (i, j) $ 它可以一步转到单元格 $ (i + 1, j) $ 或 $ (i, j + 1) $ 之一，如果它存在的话。路径是一系列单元格，其中对于序列中的每两个相邻单元格，满足以下条件：乌龟可以一步从第一个单元格到达第二个单元格。路径的成本是写入路径单元格中的数字的总和。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1700A/f97a8d75c2b2fd773655dec21eded248ca86a4f4.png)例如，$ n = 2 $ 和 $ m = 3 $ 表格将如上所示。海龟可以走以下路径： $ (1, 1) \rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) $ 。这种方式的成本等于 $ a_{11} + a_{12} + a_{13} + a_{23} = 12 $ 。另一方面，路径 $ (1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (2, 1) $ 和 $ (1, 1) \rightarrow (1, 3) $是不正确的，因为在第一条路径中乌龟不能迈出一步 $ (2, 2) \rightarrow (2, 1) $ ，而在第二条路径中它不能迈出一步 $ (1, 1) \右箭头 (1, 3) $ 。

你被要求告诉海龟从单元 $ (1, 1) $ 到单元 $ (n, m) $ 的路径的最小可能成本。请注意，单元格 $ (1, 1) $ 和 $ (n, m) $ 是其中的一部分。

## 输入格式

第一行包含一个整数 $ t $ ( $ 1 \leq t \leq 1000 $ ) — 测试用例的数量。测试用例的描述如下。

每个测试用例的一行包含两个整数 $ n $ 和 $ m $ ( $ 1 \leq n, m \leq 10^4 $ ) — 分别是表 $ a $ 的行数和列数。

## 输出格式

对于每个测试用例，输出一个整数——从单元格 $ (1, 1) $ 到单元格 $ (n, m) $ 的路径的最小可能成本。

## 样例#1

### 样例输入示例 #1

```
7
1 1
2 3
3 2
7 1
1 10
5 5
10000 10000
```

### 样例输出#1

```
1
12
13
28
55
85
500099995000
```

## 说明/提示

在第一个测试用例中，唯一可能的路径由单个单元格 $ (1, 1) $ 组成。

语句中显示了第二个测试用例中成本最低的路径。

在第四和第五个测试用例中，从 $ (1, 1) $ 到 $ (n, m) $ 只有一条路径。两条路径都访问表中的每个单元格。

## 样例 #1

### 输入

```
7
1 1
2 3
3 2
7 1
1 10
5 5
10000 10000
```

### 输出

```
1
12
13
28
55
85
500099995000
```



---

---
title: "Palindromic Numbers "
layout: "post"
diff: 普及-
pid: CF1700B
tag: []
---

# Palindromic Numbers 

## 题目描述

#### 题目大意

每天散步时，艾琳娜都会注意到地上有一个很长的数字（一个 $n$ 位数）。现在艾琳娜想找一个不含前导 $0$ 的 $n$ 位数，使得这两个 $n$ 位数的和是一个回文数。

数据保证一定有一个 $n$ 位数符合要求。如果有多个 $n$ 位数符合要求，任意输出其中的一个即可。

（回文数：如果一个数字从右往左读和从左往右读得到的数相同，那么它就被称为回文数。例如，数字121、66、98989是回文数，103、239、1241不是回文数。）

## 输入格式

第一行包含一个整数 $t$（$1 \leq t \leq 100$），表示数据组数。

每组数据的第一行包含一个整数 $n$（$1 \leq n \leq 10^5$，且保证 $\sum \limits{n} \leq 10^5$）,表示地上这个数字的长度为 $n$ 位。第二行包含一个 $n$ 位数，表示地上这个数字本身。

## 输出格式

对于每组数据，输出一个 $n$ 位数，表示一个符合要求的 $n$ 位数。

## 样例 #1

### 输入

```
3
2
99
4
1023
3
385
```

### 输出

```
32
8646
604
```



---

---
title: "Permutation"
layout: "post"
diff: 普及-
pid: CF1701B
tag: []
---

# Permutation

## 题目描述

Recall that a permutation of length $ n $ is an array where each element from $ 1 $ to $ n $ occurs exactly once.

For a fixed positive integer $ d $ , let's define the cost of the permutation $ p $ of length $ n $ as the number of indices $ i $ $ (1 \le i < n) $ such that $ p_i \cdot d = p_{i + 1} $ .

For example, if $ d = 3 $ and $ p = [5, 2, 6, 7, 1, 3, 4] $ , then the cost of such a permutation is $ 2 $ , because $ p_2 \cdot 3 = p_3 $ and $ p_5 \cdot 3 = p_6 $ .

Your task is the following one: for a given value $ n $ , find the permutation of length $ n $ and the value $ d $ with maximum possible cost (over all ways to choose the permutation and $ d $ ). If there are multiple answers, then print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases.

The single line of each test case contains a single integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ).

The sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print the value $ d $ in the first line, and $ n $ integers in the second line — the permutation itself. If there are multiple answers, then print any of them.

## 样例 #1

### 输入

```
2
2
3
```

### 输出

```
2
1 2
3
2 1 3
```



---

---
title: "Polycarp Writes a String from Memory"
layout: "post"
diff: 普及-
pid: CF1702B
tag: []
---

# Polycarp Writes a String from Memory

## 题目描述

Polycarp has a poor memory. Each day he can remember no more than $ 3 $ of different letters.

Polycarp wants to write a non-empty string of $ s $ consisting of lowercase Latin letters, taking minimum number of days. In how many days will he be able to do it?

Polycarp initially has an empty string and can only add characters to the end of that string.

For example, if Polycarp wants to write the string lollipops, he will do it in $ 2 $ days:

- on the first day Polycarp will memorize the letters l, o, i and write lolli;
- On the second day Polycarp will remember the letters p, o, s, add pops to the resulting line and get the line lollipops.

If Polycarp wants to write the string stringology, he will do it in $ 4 $ days:

- in the first day will be written part str;
- on day two will be written part ing;
- on the third day, part of olog will be written;
- on the fourth day, part of y will be written.

For a given string $ s $ , print the minimum number of days it will take Polycarp to write it.

## 输入格式

The first line of input data contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of a non-empty string $ s $ consisting of lowercase Latin letters (the length of the string $ s $ does not exceed $ 2 \cdot 10^5 $ ) — the string Polycarp wants to construct.

It is guaranteed that the sum of string lengths $ s $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print a single number — minimum number of days it will take Polycarp to write the string $ s $ from memory.

## 样例 #1

### 输入

```
6
lollipops
stringology
abracadabra
codeforces
test
f
```

### 输出

```
2
4
3
4
1
1
```



---

---
title: "Train and Queries"
layout: "post"
diff: 普及-
pid: CF1702C
tag: []
---

# Train and Queries

## 题目描述

Along the railroad there are stations indexed from $ 1 $ to $ 10^9 $ . An express train always travels along a route consisting of $ n $ stations with indices $ u_1, u_2, \dots, u_n $ , where ( $ 1 \le u_i \le 10^9 $ ). The train travels along the route from left to right. It starts at station $ u_1 $ , then stops at station $ u_2 $ , then at $ u_3 $ , and so on. Station $ u_n $ — the terminus.

It is possible that the train will visit the same station more than once. That is, there may be duplicates among the values $ u_1, u_2, \dots, u_n $ .

You are given $ k $ queries, each containing two different integers $ a_j $ and $ b_j $ ( $ 1 \le a_j, b_j \le 10^9 $ ). For each query, determine whether it is possible to travel by train from the station with index $ a_j $ to the station with index $ b_j $ .

For example, let the train route consist of $ 6 $ of stations with indices \[ $ 3, 7, 1, 5, 1, 4 $ \] and give $ 3 $ of the following queries:

- $ a_1 = 3 $ , $ b_1 = 5 $ It is possible to travel from station $ 3 $ to station $ 5 $ by taking a section of the route consisting of stations \[ $ 3, 7, 1, 5 $ \]. Answer: YES.
- $ a_2 = 1 $ , $ b_2 = 7 $ You cannot travel from station $ 1 $ to station $ 7 $ because the train cannot travel in the opposite direction. Answer: NO.
- $ a_3 = 3 $ , $ b_3 = 10 $ It is not possible to travel from station $ 3 $ to station $ 10 $ because station $ 10 $ is not part of the train's route. Answer: NO.

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) —the number of test cases in the test.

The descriptions of the test cases follow.

The first line of each test case is empty.

The second line of each test case contains two integers: $ n $ and $ k $ ( $ 1 \le n \le 2 \cdot 10^5, 1 \le k \le 2 \cdot 10^5 $ ) —the number of stations the train route consists of and the number of queries.

The third line of each test case contains exactly $ n $ integers $ u_1, u_2, \dots, u_n $ ( $ 1 \le u_i \le 10^9 $ ). The values $ u_1, u_2, \dots, u_n $ are not necessarily different.

The following $ k $ lines contain two different integers $ a_j $ and $ b_j $ ( $ 1 \le a_j, b_j \le 10^9 $ ) describing the query with index $ j $ .

It is guaranteed that the sum of $ n $ values over all test cases in the test does not exceed $ 2 \cdot 10^5 $ . Similarly, it is guaranteed that the sum of $ k $ values over all test cases in the test also does not exceed $ 2 \cdot 10^5 $

## 输出格式

For each test case, output on a separate line:

- YES, if you can travel by train from the station with index $ a_j $ to the station with index $ b_j $
- NO otherwise.

You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

## 说明/提示

The first test case is explained in the problem statement.

## 样例 #1

### 输入

```
3


6 3
3 7 1 5 1 4
3 5
1 7
3 10


3 3
1 2 1
2 1
1 2
4 5


7 5
2 1 1 1 2 4 4
1 3
1 4
2 1
4 1
1 2
```

### 输出

```
YES
NO
NO
YES
YES
NO
NO
YES
YES
NO
YES
```



---

---
title: "Not a Cheap String"
layout: "post"
diff: 普及-
pid: CF1702D
tag: []
---

# Not a Cheap String

## 题目描述

Let $ s $ be a string of lowercase Latin letters. Its price is the sum of the indices of letters (an integer between 1 and 26) that are included in it. For example, the price of the string abca is $ 1+2+3+1=7 $ .

The string $ w $ and the integer $ p $ are given. Remove the minimal number of letters from $ w $ so that its price becomes less than or equal to $ p $ and print the resulting string. Note that the resulting string may be empty. You can delete arbitrary letters, they do not have to go in a row. If the price of a given string $ w $ is less than or equal to $ p $ , then nothing needs to be deleted and $ w $ must be output.

Note that when you delete a letter from $ w $ , the order of the remaining letters is preserved. For example, if you delete the letter e from the string test, you get tst.

## 输入格式

The first line of input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test. The following are descriptions of $ t $ test cases.

Each case consists of two lines.

The first of them is the string $ w $ , it is non-empty and consists of lowercase Latin letters. Its length does not exceed $ 2\cdot10^5 $ .

The second line contains an integer $ p $ ( $ 1 \le p \le 5\,200\,000 $ ).

It is guaranteed that the sum of string lengths $ w $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

Output exactly $ t $ rows, the $ i $ -th of them should contain the answer to the $ i $ -th set of input data. Print the longest string that is obtained from $ w $ by deleting letters such that its price is less or equal to $ p $ . If there are several answers, then output any of them.

Note that the empty string — is one of the possible answers. In this case, just output an empty string.

## 样例 #1

### 输入

```
5
abca
2
abca
6
codeforces
1
codeforces
10
codeforces
100
```

### 输出

```
aa
abc

cdc
codeforces
```



---

---
title: "Cypher"
layout: "post"
diff: 普及-
pid: CF1703C
tag: []
---

# Cypher

## 题目描述

有一把 $n$ 个锁轮的锁，每个锁轮上写有数字 $a_i$ ，对于第 $i$ 个锁轮，做了 $b_i$ 次操作。这些操作有两种类型：

- `U`：锁轮上的数字 $+1$ ，超过 $9$ 则变为 $0$ 。
- `D`：锁轮上的数字 $-1$ ，小于 $0$ 则变为 $9$ 。

现在给定操作后的锁轮和操作，请你还原操作前的锁轮。

## 输入格式

第一行一个整数 $t$ ，表示测试点内数据组数。

每组数据中第一行是一个正整数 $n$ ，表示锁轮数。

下一行有 $n$ 个整数 $a_i$ ，表示每个锁轮操作后的数字。

## 输出格式

一行 $n$ 个用空格隔开的整数，表示操作前锁轮上的数字。

## 说明/提示

$1 \le n,t \le 100,0 \le a_i \le 9,1 \le b_i \le 10$

## 样例 #1

### 输入

```
3
3
9 3 1
3 DDD
4 UDUU
2 DU
2
0 9
9 DDDDDDDDD
9 UUUUUUUUU
5
0 5 9 8 3
10 UUUUUUUUUU
3 UUD
8 UUDUUDDD
10 UUDUUDUDDU
4 UUUU
```

### 输出

```
2 1 1 
9 0 
0 4 9 6 9
```



---

---
title: "Double Strings"
layout: "post"
diff: 普及-
pid: CF1703D
tag: []
---

# Double Strings

## 题目描述

You are given $ n $ strings $ s_1, s_2, \dots, s_n $ of length at most $ \mathbf{8} $ .

For each string $ s_i $ , determine if there exist two strings $ s_j $ and $ s_k $ such that $ s_i = s_j + s_k $ . That is, $ s_i $ is the concatenation of $ s_j $ and $ s_k $ . Note that $ j $ can be equal to $ k $ .

Recall that the concatenation of strings $ s $ and $ t $ is $ s + t = s_1 s_2 \dots s_p t_1 t_2 \dots t_q $ , where $ p $ and $ q $ are the lengths of strings $ s $ and $ t $ respectively. For example, concatenation of "code" and "forces" is "codeforces".

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the number of strings.

Then $ n $ lines follow, the $ i $ -th of which contains non-empty string $ s_i $ of length at most $ \mathbf{8} $ , consisting of lowercase English letters. Among the given $ n $ strings, there may be equal (duplicates).

The sum of $ n $ over all test cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case, output a binary string of length $ n $ . The $ i $ -th bit should be $ \texttt{1} $ if there exist two strings $ s_j $ and $ s_k $ where $ s_i = s_j + s_k $ , and $ \texttt{0} $ otherwise. Note that $ j $ can be equal to $ k $ .

## 说明/提示

In the first test case, we have the following:

- $ s_1 = s_2 + s_2 $ , since $ \texttt{abab} = \texttt{ab} + \texttt{ab} $ . Remember that $ j $ can be equal to $ k $ .
- $ s_2 $ is not the concatenation of any two strings in the list.
- $ s_3 = s_2 + s_5 $ , since $ \texttt{abc} = \texttt{ab} + \texttt{c} $ .
- $ s_4 $ is not the concatenation of any two strings in the list.
- $ s_5 $ is not the concatenation of any two strings in the list.

 Since only $ s_1 $ and $ s_3 $ satisfy the conditions, only the first and third bits in the answer should be $ \texttt{1} $ , so the answer is $ \texttt{10100} $ .

## 样例 #1

### 输入

```
3
5
abab
ab
abc
abacb
c
3
x
xx
xxx
8
codeforc
es
codes
cod
forc
forces
e
code
```

### 输出

```
10100
011
10100101
```



---

---
title: "Mirror Grid"
layout: "post"
diff: 普及-
pid: CF1703E
tag: []
---

# Mirror Grid

## 题目描述

You are given a square grid with $ n $ rows and $ n $ columns. Each cell contains either $ 0 $ or $ 1 $ .

In an operation, you can select a cell of the grid and flip it (from $ 0 \to 1 $ or $ 1 \to 0 $ ). Find the minimum number of operations you need to obtain a square that remains the same when rotated $ 0^{\circ} $ , $ 90^{\circ} $ , $ 180^{\circ} $ and $ 270^{\circ} $ .

The picture below shows an example of all rotations of a grid.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1703E/df4a9e7a944efc8b4d2d665fb77f2a0392653bc5.png)

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 100 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 100 $ ) — the size of the grid.

Then $ n $ lines follow, each with $ n $ characters $ a_{i,j} $ ( $ 0 \leq a_{i,j} \leq 1 $ ) — the number written in each cell.

## 输出格式

For each test case output a single integer — the minimum number of operations needed to make the square look the same rotated $ 0^{\circ} $ , $ 90^{\circ} $ , $ 180^{\circ} $ and $ 270^{\circ} $ .

## 说明/提示

In the first test case, we can perform one operations to make the grid $ \begin{matrix}0 & 1 & 0\\ 1 & 1 & \color{red}{1}\\ 0 & 1 & 0\end{matrix} $ . Now, all rotations of the square are the same.

In the second test case, all rotations of the square are already the same, so we don't need any flips.

## 样例 #1

### 输入

```
5
3
010
110
010
1
0
5
11100
11011
01011
10011
11000
5
01000
10101
01010
00010
01001
5
11001
00000
11111
10110
01111
```

### 输出

```
1
0
9
7
6
```



---

---
title: "Chip Game"
layout: "post"
diff: 普及-
pid: CF1719A
tag: []
---

# Chip Game

## 题目描述

Burenka and Tonya are playing an old Buryat game with a chip on a board of $ n \times m $ cells.

At the beginning of the game, the chip is located in the lower left corner of the board. In one move, the player can move the chip to the right or up by any odd number of cells (but you cannot move the chip both to the right and up in one move). The one who cannot make a move loses.

Burenka makes the first move, the players take turns. Burenka really wants to win the game, but she is too lazy to come up with a strategy, so you are invited to solve the difficult task of finding it. Name the winner of the game (it is believed that Burenka and Tonya are masters of playing with chips, so they always move in the optimal way).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1719A/a6c823a6eb354fdb9ffdf07a308c103419371a6a.png)Chip's starting cell is green, the only cell from which chip can't move is red. if the chip is in the yellow cell, then blue cells are all options to move the chip in one move.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The following is a description of the input data sets.

The only line of each test case contains two integers $ n $ and $ m $ ( $ 1 \leq n, m \leq 10^9 $ ) — the dimensions of the game board.

## 输出格式

For each test case print a single line — the name of the winner of the game ("Burenka" or "Tonya").

## 说明/提示

In the first case, Burenka has no move, so Tonya wins.

In the second case, Burenka can move $ 3 $ cells to the right, after which Tony will not be able to make a move, which means that Burenka wins.

In the third case, Burenka can move $ 5 $ squares to the right. Then we can say that we have a game on a board of $ 1 \times 5 $ cells, and Tonya is the first player. In such game the second player wins, so in the original one Burenka will win.

## 样例 #1

### 输入

```
6
1 1
1 4
5 6
2 2
6 3
999999999 1000000000
```

### 输出

```
Tonya
Burenka
Burenka
Tonya
Burenka
Burenka
```



---

---
title: "Burenka Plays with Fractions"
layout: "post"
diff: 普及-
pid: CF1720A
tag: []
---

# Burenka Plays with Fractions

## 题目描述

给出两个分数 $ \dfrac{a}{b}$ 和 $\dfrac{c}{d}$ ，你每次操作能够选择其中一个分数的分子或分母，将其乘上任意一个整数（当然不能对分母乘 $0$）。要求求出能够使两个分数相等的最小操作次数。

## 输入格式

第一行一个整数 $t(1\leq t\leq 10^4)$，代表有 $t$ 组数据。

以后 $t$ 行，每行四个整数 $a,b,c,d(0\leq a,c\leq 10^9,1\leq b,d\leq 10^9$)，分别代表两个分数的分子和分母。

## 输出格式

对于每组数据输出一行一个整数，即最小操作数。
### 样例解释
对于第 $1$ 组数据，将 $c$ 乘上 $2$ 即可。

对于第 $2$ 组数据，两个分数已经相等，无需操作。

对于第 $3$ 组数据，可以将 $a$ 乘上 $4$，将 $b$ 乘上 $3$。两个分数就能够相等($\dfrac{1\cdot 4}{2 \cdot 3}=\dfrac{2}{3}$)。

## 样例 #1

### 输入

```
8
2 1 1 1
6 3 2 1
1 2 2 3
0 1 0 100
0 1 228 179
100 3 25 6
999999999 300000000 666666666 100000000
33 15 0 84
```

### 输出

```
1
0
2
0
1
1
1
1
```



---

---
title: "Interesting Sum"
layout: "post"
diff: 普及-
pid: CF1720B
tag: []
---

# Interesting Sum

## 题目描述

You are given an array $ a $ that contains $ n $ integers. You can choose any proper subsegment $ a_l, a_{l + 1}, \ldots, a_r $ of this array, meaning you can choose any two integers $ 1 \le l \le r \le n $ , where $ r - l + 1 < n $ . We define the beauty of a given subsegment as the value of the following expression:

$$\max(a_{1}, a_{2}, \ldots, a_{l-1}, a_{r+1}, a_{r+2}, \ldots, a_{n}) - \min(a_{1}, a_{2}, \ldots, a_{l-1}, a_{r+1}, a_{r+2}, \ldots, a_{n}) + \max(a_{l}, \ldots, a_{r}) - \min(a_{l}, \ldots, a_{r}). $$

Please find the maximum beauty among all proper subsegments.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. Then follow the descriptions of each test case.

The first line of each test case contains a single integer $ n $ $ (4 \leq n \leq 10^5) $ — the length of the array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_{i} \leq 10^9 $ ) — the elements of the given array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each testcase print a single integer — the maximum beauty of a proper subsegment.

## 说明/提示

In the first test case, the optimal segment is $ l = 7 $ , $ r = 8 $ . The beauty of this segment equals to $ (6 - 1) + (5 - 1) = 9 $ .

In the second test case, the optimal segment is $ l = 2 $ , $ r = 4 $ . The beauty of this segment equals $ (100 - 2) + (200 - 1) = 297 $ .

## 样例 #1

### 输入

```
4
8
1 2 2 3 1 5 6 1
5
1 2 3 100 200
4
3 3 3 3
6
7 8 3 1 1 8
```

### 输出

```
9
297
0
14
```



---

---
title: "Mainak and Array"
layout: "post"
diff: 普及-
pid: CF1726A
tag: []
---

# Mainak and Array

## 题目描述

### 题目大意

给定一个长度为 $n$ 的数组 $a$，可以选定**一个**区间 $[l, \; r]$ 进行**恰好一次**操作，求操作后最大的 $a_n - a_1$。

操作方法：选定区间 $[l, \; r]$ 和旋转次数 $k$, 每次旋转为 $a_l = a_{l + 1}, \; a_{l + 1} = a_{l + 2}, \; \dots, \; a_{r - 1} = a_r, \; a_r = a_l$

## 输入格式

第一行一个整数 $T \; (1 \leqslant T \leqslant 50)$，表示测试样例组数。

对于每组测试样例，第一行为一个整数 $n \; (1 \leqslant n \leqslant 2000)$ 表示数组长度。

接下来的一行含有 $n$ 个整数 $a_i \; (1 \leqslant a_i \leqslant 999)$，表示该数组。

数据保证 $\sum n \leqslant 2000$。

## 输出格式

对于每组测试样例包含一行一个整数，表示最大的 $a_n - a_1$。

$Translated \; by \; Zigh$

## 样例 #1

### 输入

```
5
6
1 3 9 11 5 7
1
20
3
9 99 999
4
2 1 8 1
3
2 1 5
```

### 输出

```
10
0
990
7
4
```



---

---
title: "Mainak and Interesting Sequence"
layout: "post"
diff: 普及-
pid: CF1726B
tag: []
---

# Mainak and Interesting Sequence

## 题目描述

### 题目大意

认定一个长度为 $n$ 的序列 $a$ 是有趣的有且仅当满足以下条件：

- 对于**任意**一个整数 $a_i$，所有**严格小于**它的数的异或和为 $0$。( 假定所有满足条件的数为 $b_j$，则异或和为 $0$ 表示 $b_1 \; xor \; b_2 \; xor \; \dots \; xor \; b_j = 0$，xor 表示按位异或 )

请求出满足 $\sum_{i = 1}^n a_i = m$ 的长度为 $n$ 有趣的序列。 若有多种构造方式，则任意输出一种即可。

例如：$[1,3,2,3,1,2,3] , [4,4,4,4] , [25]$ 是有趣的，而 $[1,2,3,4] \; (p_2 = 1 \neq 0), \; [4,1,1,2,4] \; (p_4 = 1 \; xor \; 1 \; xor \; 2 = 2 \neq 0), \; [29,30,30] \; (p_{30} = 29 \neq 0)$不是有趣的。( 其中 $p_i$ 表示题目要求中的异或和 )。

## 输入格式

第一行一个整数 $T \; (1 \leqslant T \leqslant 10^5)$ ，表示测试样例组数。

对于每组测试样例，包含一行两个整数 $n \; (1 \leqslant n \leqslant 10^5)$ 和 $m \; (1 \leqslant m \leqslant 10^9)$，含义见题目。

数据保证 $\sum n \leqslant 10^5$。

## 输出格式

对于每组测试样例，如果第一行为一个字符串。如果存在满足条件的有趣的序列则输出 Yes ，否则输出 No。

如果你的输出是 Yes，则接下来的一行包含 $n$ 个数，表示你构造的序列，否则不输出这一行。

$Translated \; by \; Zigh$

## 样例 #1

### 输入

```
4
1 3
6 12
2 1
3 6
```

### 输出

```
Yes
3
Yes
1 3 2 2 3 1
No
Yes
2 2 2
```



---

---
title: "Jumping on Tiles"
layout: "post"
diff: 普及-
pid: CF1729C
tag: []
---

# Jumping on Tiles

## 题目描述

### 题目大意

给定一个字符串 $s$，polycarp 欲从字符串首跳到字符串末 ($s_1$ → $s_n$，其中 $n$ 表示该字符串长度)。

假设 polycarp 现从 $a_i$ 跳到了 $a_j$ 我们定义这一次跳跃的权值为 $|\operatorname{index}(a_i) - \operatorname{index}(a_j)|$，其中 $\operatorname{index}$
 表示该字符在字母表中的序号 ( 如 $\operatorname{index}('a') = 1, \; \operatorname{index}('z') = 26$ )。
 
 请构造出一种在保证**权值和最小**的情况下**经过的字符最多**的跳跃方案 ( 当然，同一个字符只能经过一次，其中同一个仅指在字符串中的位置相同 )。

## 输入格式

第一行包含一个整数 $t \; (1 \leqslant t \leqslant 10^4)$ ，表示测试样例组数。
 
 对于每组测试样例，包含一行一个字符串 $s \; (2 \leqslant |s| \leqslant 2 \cdot 10^5)$，意义见题面。

## 输出格式

对于每组测试样例，第一行包含两个用空格隔开的整数 $cost$ 和 $m$ 分别表示 最小权值和 和 最大经过的字符数。
 
 第二行包含 $m$ 个整数，分别表示沿途经过的所有字符位置。( 例如输出 $1 \; 4 \; 3 \; 5$ 表示跳跃路径为 $s_1$ → $s_4$ → $s_3$ → $s_5$ ) 数与数之间用空格隔开。
 
 $Translated \; by \; Zigh$

## 样例 #1

### 输入

```
6
logic
codeforces
bca
aaaaaaaaaaa
adbaadabad
to
```

### 输出

```
9 4
1 4 3 5
16 10
1 8 3 4 9 5 2 6 7 10
1 2
1 3
0 11
1 8 10 4 3 5 7 2 9 6 11
3 10
1 9 5 4 7 3 8 6 2 10
5 2
1 2
```



---

---
title: "Friends and the Restaurant"
layout: "post"
diff: 普及-
pid: CF1729D
tag: []
---

# Friends and the Restaurant

## 题目描述

A group of $ n $ friends decide to go to a restaurant. Each of the friends plans to order meals for $ x_i $ burles and has a total of $ y_i $ burles ( $ 1 \le i \le n $ ).

The friends decide to split their visit to the restaurant into several days. Each day, some group of at least two friends goes to the restaurant. Each of the friends visits the restaurant no more than once (that is, these groups do not intersect). These groups must satisfy the condition that the total budget of each group must be not less than the amount of burles that the friends in the group are going to spend at the restaurant. In other words, the sum of all $ x_i $ values in the group must not exceed the sum of $ y_i $ values in the group.

What is the maximum number of days friends can visit the restaurant?

For example, let there be $ n = 6 $ friends for whom $ x $ = \[ $ 8, 3, 9, 2, 4, 5 $ \] and $ y $ = \[ $ 5, 3, 1, 4, 5, 10 $ \]. Then:

- first and sixth friends can go to the restaurant on the first day. They will spend $ 8+5=13 $ burles at the restaurant, and their total budget is $ 5+10=15 $ burles. Since $ 15 \ge 13 $ , they can actually form a group.
- friends with indices $ 2, 4, 5 $ can form a second group. They will spend $ 3+2+4=9 $ burles at the restaurant, and their total budget will be $ 3+4+5=12 $ burles ( $ 12 \ge 9 $ ).

It can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill.

So, the maximum number of groups the friends can split into is $ 2 $ . Friends will visit the restaurant for a maximum of two days. Note that the $ 3 $ -rd friend will not visit the restaurant at all.

Output the maximum number of days the friends can visit the restaurant for given $ n $ , $ x $ and $ y $ .

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test.

The descriptions of the test cases follow.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^5 $ ) — the number of friends.

The second line of each test case contains exactly $ n $ integers $ x_1, x_2, \dots, x_n $ ( $ 1 \le x_i \le 10^9 $ ). The value of $ x_i $ corresponds to the number of burles that the friend numbered $ i $ plans to spend at the restaurant.

The third line of each test case contains exactly $ n $ integers $ y_1, y_2, \dots, y_n $ ( $ 1 \le y_i \le 10^9 $ ). The value $ y_i $ corresponds to the number of burles that the friend numbered $ i $ has.

It is guaranteed that the sum of $ n $ values over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, print the maximum number of days to visit the restaurant. If friends cannot form even one group to visit the restaurant, print 0.

## 说明/提示

The first test case in explained in the problem statement.

In the second test case, friends cannot form at least one group of two or more people.

In the third test case, one way to visit the restaurant in one day is to go in a group of all three friends ( $ 1+3+10 \ge 2+3+7 $ ). Note that they do not have the option of splitting into two groups.

## 样例 #1

### 输入

```
6
6
8 3 9 2 4 5
5 3 1 4 5 10
4
1 2 3 4
1 1 2 2
3
2 3 7
1 3 10
6
2 3 6 9 5 7
3 2 7 10 6 10
6
5 4 2 1 8 100
1 1 1 1 1 200
6
1 4 1 2 4 2
1 3 3 2 3 4
```

### 输出

```
2
0
1
3
1
3
```



---

---
title: "Bestie"
layout: "post"
diff: 普及-
pid: CF1732A
tag: []
---

# Bestie

## 题目描述

You are given an array $ a $ consisting of $ n $ integers $ a_1, a_2, \ldots, a_n $ . Friends asked you to make the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of all numbers in the array equal to $ 1 $ . In one operation, you can do the following:

- Select an arbitrary index in the array $ 1 \leq i \leq n $ ;
- Make $ a_i = \gcd(a_i, i) $ , where $ \gcd(x, y) $ denotes the GCD of integers $ x $ and $ y $ . The cost of such an operation is $ n - i + 1 $ .

You need to find the minimum total cost of operations we need to perform so that the GCD of the all array numbers becomes equal to $ 1 $ .

## 输入格式

Each test consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 5\,000 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 20 $ ) — the length of the array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the elements of the array.

## 输出格式

For each test case, output a single integer — the minimum total cost of operations that will need to be performed so that the GCD of all numbers in the array becomes equal to $ 1 $ .

We can show that it's always possible to do so.

## 说明/提示

In the first test case, the GCD of the entire array is already equal to $ 1 $ , so there is no need to perform operations.

In the second test case, select $ i = 1 $ . After this operation, $ a_1 = \gcd(2, 1) = 1 $ . The cost of this operation is $ 1 $ .

In the third test case, you can select $ i = 1 $ , after that the array $ a $ will be equal to $ [1, 4] $ . The GCD of this array is $ 1 $ , and the total cost is $ 2 $ .

In the fourth test case, you can select $ i = 2 $ , after that the array $ a $ will be equal to $ [3, 2, 9] $ . The GCD of this array is $ 1 $ , and the total cost is $ 2 $ .

In the sixth test case, you can select $ i = 4 $ and $ i = 5 $ , after that the array $ a $ will be equal to $ [120, 60, 80, 4, 5] $ . The GCD of this array is $ 1 $ , and the total cost is $ 3 $ .

## 样例 #1

### 输入

```
9
1
1
1
2
2
2 4
3
3 6 9
4
5 10 15 20
5
120 60 80 40 80
6
150 90 180 120 60 30
6
2 4 6 9 12 18
6
30 60 90 120 125 125
```

### 输出

```
0
1
2
2
1
3
3
0
1
```



---

---
title: "Ugu"
layout: "post"
diff: 普及-
pid: CF1732B
tag: []
---

# Ugu

## 题目描述

A binary string is a string consisting only of the characters 0 and 1. You are given a binary string $ s_1 s_2 \ldots s_n $ . It is necessary to make this string non-decreasing in the least number of operations. In other words, each character should be not less than the previous. In one operation, you can do the following:

- Select an arbitrary index $ 1 \leq i \leq n $ in the string;
- For all $ j \geq i $ , change the value in the $ j $ -th position to the opposite, that is, if $ s_j = 1 $ , then make $ s_j = 0 $ , and vice versa.

What is the minimum number of operations needed to make the string non-decreasing?

## 输入格式

Each test consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of test cases follows.

The first line of each test cases a single integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the length of the string.

The second line of each test case contains a binary string $ s $ of length $ n $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the minimum number of operations that are needed to make the string non-decreasing.

## 说明/提示

In the first test case, the string is already non-decreasing.

In the second test case, you can select $ i = 1 $ and then $ s = \mathtt{01} $ .

In the third test case, you can select $ i = 1 $ and get $ s = \mathtt{010} $ , and then select $ i = 2 $ . As a result, we get $ s = \mathtt{001} $ , that is, a non-decreasing string.

In the sixth test case, you can select $ i = 5 $ at the first iteration and get $ s = \mathtt{100001} $ . Then choose $ i = 2 $ , then $ s = \mathtt{111110} $ . Then we select $ i = 1 $ , getting the non-decreasing string $ s = \mathtt{000001} $ .

## 样例 #1

### 输入

```
8
1
1
2
10
3
101
4
1100
5
11001
6
100010
10
0000110000
7
0101010
```

### 输出

```
0
1
2
1
2
3
1
5
```



---

---
title: "Consecutive Sum"
layout: "post"
diff: 普及-
pid: CF1733A
tag: []
---

# Consecutive Sum

## 题目描述

You are given an array $ a $ with $ n $ integers. You can perform the following operation at most $ k $ times:

- Choose two indices $ i $ and $ j $ , in which $ i \,\bmod\, k = j \,\bmod\, k $ ( $ 1 \le i < j \le n $ ).
- Swap $ a_i $ and $ a_j $ .

After performing all operations, you have to select $ k $ consecutive elements, and the sum of the $ k $ elements becomes your score. Find the maximum score you can get.

Here $ x \bmod y $ denotes the remainder from dividing $ x $ by $ y $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 600 $ ) — the number of test cases.

Each test case consists of two lines.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 100 $ ) — the length of the array and the number in the statement above.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 10^9 $ ) — the array itself.

## 输出格式

For each test case, print the maximum score you can get, one per line.

## 说明/提示

In the first test case, we can get a score of $ 11 $ if we select $ a_1, a_2 $ without performing any operations.

In the third test case, we can get a score of $ 15 $ if we first swap $ a_1 $ with $ a_4 $ and then select $ a_3, a_4, a_5 $ .

## 样例 #1

### 输入

```
5
3 2
5 6 0
1 1
7
5 3
7 0 4 0 4
4 2
2 7 3 4
3 3
1000000000 1000000000 999999997
```

### 输出

```
11
7
15
10
2999999997
```



---

---
title: "Rule of League"
layout: "post"
diff: 普及-
pid: CF1733B
tag: []
---

# Rule of League

## 题目描述

There is a badminton championship in which $ n $ players take part. The players are numbered from $ 1 $ to $ n $ .

The championship proceeds as follows: player $ 1 $ and player $ 2 $ play a game, then the winner and player $ 3 $ play a game, and then the winner and player $ 4 $ play a game, and so on. So, $ n-1 $ games are played, and the winner of the last game becomes the champion. There are no draws in the games.

You want to find out the result of championship. Currently, you only know the following information:

- Each player has either won $ x $ games or $ y $ games in the championship.

Given $ n $ , $ x $ , and $ y $ , find out if there is a result that matches this information.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^5 $ ) — the number of test cases.

The only line of each test case contains three integers $ n $ , $ x $ , $ y $ ( $ 2 \le n \le 10^5 $ , $ 0 \le x, y < n $ ).

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

Print the answer for each test case, one per line. If there is no result that matches the given information about $ n $ , $ x $ , $ y $ , print $ -1 $ . Otherwise, print $ n-1 $ space separated integers, where the $ i $ -th integer is the player number of the winner of the $ i $ -th game.

If there are multiple valid results, print any.

## 说明/提示

In the first test case, player $ 1 $ and player $ 4 $ won $ x $ times, player $ 2 $ and player $ 3 $ won $ y $ times.

In the second, third, and fifth test cases, no valid result exists.

## 样例 #1

### 输入

```
5
5 2 0
8 1 2
3 0 0
2 0 1
6 3 0
```

### 输出

```
1 1 4 4
-1
-1
2 
-1
```



---

---
title: "Tea with Tangerines"
layout: "post"
diff: 普及-
pid: CF1735B
tag: []
---

# Tea with Tangerines

## 题目描述

There are $ n $ pieces of tangerine peel, the $ i $ -th of them has size $ a_i $ . In one step it is possible to divide one piece of size $ x $ into two pieces of positive integer sizes $ y $ and $ z $ so that $ y + z = x $ .

You want that for each pair of pieces, their sizes differ strictly less than twice. In other words, there should not be two pieces of size $ x $ and $ y $ , such that $ 2x \le y $ . What is the minimum possible number of steps needed to satisfy the condition?

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains the integer $ n $ ( $ 1 \le n \le 100 $ ).

Then one line follows, containing $ n $ integers $ a_1 \le a_2 \le \ldots \le a_n $ ( $ 1 \le a_i \le 10^7 $ ).

## 输出格式

For each test case, output a single line containing the minimum number of steps.

## 说明/提示

In the first test case, we initially have a piece of size $ 1 $ , so all final pieces must have size $ 1 $ . The total number of steps is: $ 0 + 1 + 2 + 3 + 4 = 10 $ .

In the second test case, we have just one piece, so we don't need to do anything, and the answer is $ 0 $ steps.

In the third test case, one of the possible cut options is: $ 600,\ 900,\ (600 | 700),\ (1000 | 1000),\ (1000 | 1000 | 550) $ . You can see this option in the picture below. The maximum piece has size $ 1000 $ , and it is less than $ 2 $ times bigger than the minimum piece of size $ 550 $ . $ 4 $ steps are done. We can show that it is the minimum possible number of steps.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1735B/28837ca57e9f20f873e71a5d21feab7da5248146.png)

## 样例 #1

### 输入

```
3
5
1 2 3 4 5
1
1033
5
600 900 1300 2000 2550
```

### 输出

```
10
0
4
```



---

---
title: "Make A Equal to B"
layout: "post"
diff: 普及-
pid: CF1736A
tag: []
---

# Make A Equal to B

## 题目描述

You are given two arrays $ a $ and $ b $ of $ n $ elements, each element is either $ 0 $ or $ 1 $ .

You can make operations of $ 2 $ kinds.

- Pick an index $ i $ and change $ a_i $ to $ 1-a_i $ .
- Rearrange the array $ a $ however you want.

Find the minimum number of operations required to make $ a $ equal to $ b $ .

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 400 $ ) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 100 $ ) — the length of the arrays $ a $ and $ b $ .

The second line of each test case contains $ n $ space-separated integers $ a_1,a_2,\ldots,a_n $ ( $ a_i $ is $ 0 $ or $ 1 $ ), representing the array $ a $ .

The third line of each test case contains $ n $ space-separated integers $ b_1,b_2,\ldots,b_n $ ( $ b_i $ is $ 0 $ or $ 1 $ ), representing the array $ b $ .

## 输出格式

For each test case, print the minimum number of operations required to make $ a $ equal to $ b $ .

## 说明/提示

In the first case, we need only one operation: change $ a_1 $ to $ 1-a_i $ . Now $ a = [0, 0] $ which is equal to $ b $ .

In the second case, the optimal way is to rearrange $ a $ to get the array $ [0, 1, 11 $ . Now $ a = [0, 0, 1] $ which is equal to $ b $ .

In the second case, one of optimal ways would be to first change $ a_3 $ to $ 1 - a_3 $ , then rearrange $ a $ .

In the third case, no operation is needed.

In the fourth case, the optimal way is to rearrange $ a $ to get the array $ [0, 1, 1, 0] $ .

## 样例 #1

### 输入

```
5
3
1 0 1
0 0 1
4
1 1 0 0
0 1 1 1
2
1 1
1 1
4
1 0 0 1
0 1 1 0
1
0
1
```

### 输出

```
1
2
0
1
1
```



---

---
title: "Ela Sorting Books"
layout: "post"
diff: 普及-
pid: CF1737A
tag: []
---

# Ela Sorting Books

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1737A/56ed0d2349bc5e2f6cd6bfba1e2e6140ddd296a6.png)Ela loves reading a lot, just like her new co-workers in DTL! On her first day after becoming an engineer in DTL, she is challenged by a co-worker to sort a heap of books into different compartments on the shelf. $ n $ books must be split into $ k $ compartments on the bookshelf ( $ n $ is divisible by $ k $ ). Each book is represented by a lowercase Latin letter from 'a' to 'y' inclusively, which is the beginning letter in the title of the book.

Ela must stack exactly $ \frac{n}{k} $ books in each compartment. After the books are stacked, for each compartment indexed from $ 1 $ to $ k $ , she takes the minimum excluded (MEX) letter of the multiset of letters formed by letters representing all books in that compartment, then combines the resulting letters into a string. The first letter of the resulting string is the MEX letter of the multiset of letters formed by the first compartment, the second letter of the resulting string is the MEX letter of the multiset of letters formed by the second compartment, ... and so on. Please note, under the constraint of this problem, MEX letter can always be determined for any multiset found in this problem because 'z' is not used.

What is the lexicographically greatest resulting string possible that Ela can create?

A string $ a $ is lexicographically greater than a string $ b $ if and only if one of the following holds:

- $ b $ is a prefix of $ a $ , but $ b \ne a $ ;
- in the first position where $ a $ and $ b $ differ, the string $ a $ has a letter that appears later in the alphabet than the corresponding letter in $ b $ .

The minimum excluded (MEX) letter of a multiset of letters is the letter that appears earliest in the alphabet and is not contained in the multiset. For example, if a multiset of letters contains $ 7 $ letters 'b', 'a', 'b', 'c', 'e', 'c', 'f' respectively, then the MEX letter of this compartment is 'd', because 'd' is not included in the multiset, and all letters comes before 'd' in the alphabet, namely 'a', 'b' and 'c', are included in the multiset.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le n \le 200 $ ; $ 1 \le k \le n $ ). It is guaranteed that $ n $ is divisible by $ k $ .

The second line of each test case contains a string of $ n $ lowercase Latin letters from 'a' to 'y' inclusively. Each letter represents the starting letter of the title of a book in the initial heap.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 1000 $ .

## 输出格式

For each test case, output a string of $ k $ letters which is the most optimal string that Ela can find.

## 说明/提示

In the first test case, the books can be divided into $ 3 $ compartments as below:

- the first compartment contains the books with indices $ 1, 2, 3, 7 $ : $ multiset_1 = \{ $ 'c', 'a', 'b', 'd' $ \} $ $ \rightarrow $ $ MEX(multiset_1) = $ 'e'
- the second compartment contains the books with indices $ 4, 5, 6, 9 $ : $ multiset_2 = \{ $ 'c', 'c', 'a', 'b' $ \} $ $ \rightarrow $ $ MEX(multiset_2) = $ 'd'
- the third compartment contains the remaining books $ 8, 10, 11, 12 $ : $ multiset_3 = \{ $ 'a', 'a', 'a', 'c' $ \} $ $ \rightarrow $ $ MEX(multiset_3) = $ 'b'

Therefore, the answer is 'edb'. It can be proven that there is no way that Ela can arrange the books so that it results in a lexicographically greater string.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1737A/407eef03cdf4780f728db3b04f21cd023d792a00.png)

## 样例 #1

### 输入

```
5
12 3
cabccadabaac
12 6
cabccadabaac
12 12
cabccadabaac
25 1
abcdefghijklmnopqrstuvwxy
10 5
bcdxedbcfg
```

### 输出

```
edb
ccbbba
bbbbbaaaaaaa
z
aaaaa
```



---

---
title: "Glory Addicts"
layout: "post"
diff: 普及-
pid: CF1738A
tag: []
---

# Glory Addicts

## 题目描述

The hero is addicted to glory, and is fighting against a monster.

The hero has $ n $ skills. The $ i $ -th skill is of type $ a_i $ (either fire or frost) and has initial damage $ b_i $ .

The hero can perform all of the $ n $ skills in any order (with each skill performed exactly once). When performing each skill, the hero can play a magic as follows:

- If the current skill immediately follows another skill of a different type, then its damage is doubled.

 In other words, 1. If a skill of type fire and with initial damage $ c $ is performed immediately after a skill of type fire, then it will deal $ c $ damage;
2. If a skill of type fire and with initial damage $ c $ is performed immediately after a skill of type frost, then it will deal $ 2c $ damage;
3. If a skill of type frost and with initial damage $ c $ is performed immediately after a skill of type fire, then it will deal $ 2c $ damage;
4. If a skill of type frost and with initial damage $ c $ is performed immediately after a skill of type frost , then it will deal $ c $ damage.

Your task is to find the maximum damage the hero can deal.

## 输入格式

Each test contains multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^5 $ ) — the number of test cases. The following lines contain the description of each test case.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 10^5 $ ), indicating the number of skills.

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 0 \leq a_i \leq 1 $ ), where $ a_i $ indicates the type of the $ i $ -th skill. Specifically, the $ i $ -th skill is of type fire if $ a_i = 0 $ , and of type frost if $ a_i = 1 $ .

The third line of each test case contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ 1 \leq b_i \leq 10^9 $ ), where $ b_i $ indicates the initial damage of the $ i $ -th skill.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output the maximum damage the hero can deal.

## 说明/提示

In the first test case, we can order the skills by $ [3, 1, 4, 2] $ , and the total damage is $ 100 + 2 \times 1 + 2 \times 1000 + 10 = 2112 $ .

In the second test case, we can order the skills by $ [1, 4, 2, 5, 3, 6] $ , and the total damage is $ 3 + 2 \times 6 + 2 \times 4 + 2 \times 7 + 2 \times 5 + 2 \times 8 = 63 $ .

In the third test case, we can order the skills by $ [1, 2, 3] $ , and the total damage is $ 1000000000 + 1000000000 + 1000000000 = 3000000000 $ .

In the fourth test case, there is only one skill with initial damage $ 1 $ , so the total damage is $ 1 $ .

## 样例 #1

### 输入

```
4
4
0 1 1 1
1 10 100 1000
6
0 0 0 1 1 1
3 4 5 6 7 8
3
1 1 1
1000000000 1000000000 1000000000
1
1
1
```

### 输出

```
2112
63
3000000000
1
```



---

---
title: "Array Recovery"
layout: "post"
diff: 普及-
pid: CF1739B
tag: []
---

# Array Recovery

## 题目描述

For an array of non-negative integers $ a $ of size $ n $ , we construct another array $ d $ as follows: $ d_1 = a_1 $ , $ d_i = |a_i - a_{i - 1}| $ for $ 2 \le i \le n $ .

Your task is to restore the array $ a $ from a given array $ d $ , or to report that there are multiple possible arrays.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 100 $ ) — the size of the arrays $ a $ and $ d $ .

The second line contains $ n $ integers $ d_1, d_2, \dots, d_n $ ( $ 0 \le d_i \le 100 $ ) — the elements of the array $ d $ .

It can be shown that there always exists at least one suitable array $ a $ under these constraints.

## 输出格式

For each test case, print the elements of the array $ a $ , if there is only one possible array $ a $ . Otherwise, print $ -1 $ .

## 说明/提示

In the second example, there are two suitable arrays: $ [2, 8, 5] $ and $ [2, 8, 11] $ .

## 样例 #1

### 输入

```
3
4
1 0 2 5
3
2 6 3
5
0 0 0 0 0
```

### 输出

```
1 1 3 8
-1
0 0 0 0 0
```



---

---
title: "Rock-Paper-Scissors"
layout: "post"
diff: 普及-
pid: CF173A
tag: []
---

# Rock-Paper-Scissors

## 题目描述

Nikephoros and Polycarpus play rock-paper-scissors. The loser gets pinched (not too severely!).

Let us remind you the rules of this game. Rock-paper-scissors is played by two players. In each round the players choose one of three items independently from each other. They show the items with their hands: a rock, scissors or paper. The winner is determined by the following rules: the rock beats the scissors, the scissors beat the paper and the paper beats the rock. If the players choose the same item, the round finishes with a draw.

Nikephoros and Polycarpus have played $ n $ rounds. In each round the winner gave the loser a friendly pinch and the loser ended up with a fresh and new red spot on his body. If the round finished in a draw, the players did nothing and just played on.

Nikephoros turned out to have worked out the following strategy: before the game began, he chose some sequence of items $ A=(a_{1},a_{2},...,a_{m}) $ , and then he cyclically showed the items from this sequence, starting from the first one. Cyclically means that Nikephoros shows signs in the following order: $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{m} $ , $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{m} $ , $ a_{1} $ , $ ... $ and so on. Polycarpus had a similar strategy, only he had his own sequence of items $ B=(b_{1},b_{2},...,b_{k}) $ .

Determine the number of red spots on both players after they've played $ n $ rounds of the game. You can consider that when the game began, the boys had no red spots on them.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=2·10^{9} $ ) — the number of the game's rounds.

The second line contains sequence $ A $ as a string of $ m $ characters and the third line contains sequence $ B $ as a string of $ k $ characters ( $ 1<=m,k<=1000 $ ). The given lines only contain characters "R", "S" and "P". Character "R" stands for the rock, character "S" represents the scissors and "P" represents the paper.

## 输出格式

Print two space-separated integers: the numbers of red spots Nikephoros and Polycarpus have.

## 说明/提示

In the first sample the game went like this:

- R - R. Draw.
- P - S. Nikephoros loses.
- S - P. Polycarpus loses.
- R - P. Nikephoros loses.
- P - R. Polycarpus loses.
- S - S. Draw.
- R - P. Nikephoros loses.

Thus, in total Nikephoros has $ 3 $ losses (and $ 3 $ red spots), and Polycarpus only has $ 2 $ .

## 样例 #1

### 输入

```
7
RPS
RSPP

```

### 输出

```
3 2
```

## 样例 #2

### 输入

```
5
RRRRRRRR
R

```

### 输出

```
0 0
```



---

---
title: "Compare T-Shirt Sizes"
layout: "post"
diff: 普及-
pid: CF1741A
tag: []
---

# Compare T-Shirt Sizes

## 题目描述

Two T-shirt sizes are given: $ a $ and $ b $ . The T-shirt size is either a string M or a string consisting of several (possibly zero) characters X and one of the characters S or L.

For example, strings M, XXL, S, XXXXXXXS could be the size of some T-shirts. And the strings XM, LL, SX are not sizes.

The letter M stands for medium, S for small, L for large. The letter X refers to the degree of size (from eXtra). For example, XXL is extra-extra-large (bigger than XL, and smaller than XXXL).

You need to compare two given sizes of T-shirts $ a $ and $ b $ .

The T-shirts are compared as follows:

- any small size (no matter how many letters X) is smaller than the medium size and any large size;
- any large size (regardless of the number of letters X) is larger than the medium size and any small size;
- the more letters X before S, the smaller the size;
- the more letters X in front of L, the larger the size.

For example:

- XXXS &lt; XS
- XXXL &gt; XL
- XL &gt; M
- XXL = XXL
- XXXXXS &lt; M
- XL &gt; XXXS

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of one line, in which $ a $ and $ b $ T-shirt sizes are written. The lengths of the strings corresponding to the T-shirt sizes do not exceed $ 50 $ . It is guaranteed that all sizes are correct.

## 输出格式

For each test case, print on a separate line the result of comparing $ a $ and $ b $ T-shirt sizes (lines "&lt;", "&gt;" or "=" without quotes).

## 样例 #1

### 输入

```
6
XXXS XS
XXXL XL
XL M
XXL XXL
XXXXXS M
L M
```

### 输出

```
<
>
>
=
<
>

```



---

---
title: "Funny Permutation"
layout: "post"
diff: 普及-
pid: CF1741B
tag: []
---

# Funny Permutation

## 题目描述

如果一个长度为 $n$ 的数列满足恰好包含 $1$ 到 $n$ 的整数各一个，则我们称之为排列。例如，$[3,1,4,2]$、$[1]$ 和 $[2,1]$ 都是排列，但是 $[1,2,1]$、$[0,1]$ 和 $[1,3,4]$ 都不是。

给你一个 $n$，你需要构造一个长度为 $n$ 的排列 $p$，使得它同时满足以下两个要求：

1. $\forall 1 \leq i \leq n$，都至少有一个邻居（$p_i$ 的邻居为 $p_{i + 1}$ 和 $p_{i - 1}$），使其值为 $p_i + 1$ 或 $p_i - 1$。

2. $\forall 1 \leq i \leq n$，都有 $p_i \ne i$。

我们称同时符合以上两个要求的排列为“有趣的排列”。

例如，当 $n = 4$ 时，$[4,3,1,2]$ 是一个“有趣的排列”，因为：

* $p_2 = p_1 - 1 = 4 - 1 = 3$；
* $p_1 = p_2 + 1 = 3 + 1 = 4$；
* $p_4 = p_3 + 1 = 1 + 1 = 2$；
* $p_3 = p_4 - 1 = 2 - 1 = 1$；
* $\forall 1 \leq i \leq n$，都有 $p_i \ne i$。

给定一个 $n$，你需要构造出一个长度为 $n$ 的“有趣的排列”，或者输出一个 $-1$ 来表明不存在长度为 $n$ 的“有趣的排列”。

## 输入格式

第一行，输入一个正整数 $t(1 \leq t \leq 10^4$，表示数据组数。

接下来 $t$ 行，每行一个正整数 $n(2 \leq n \leq 2 \times 10^5)$，表示你需要构造一个长度为 $n$ 的“有趣的排列”。

数据保证 $\sum{n} \leq 2 \times 10^5$。

## 输出格式

对于每组测试数据，输出**任意**一个长度为 $n$ 的“有趣的排列，或者输出一个 $-1$——如果这根本不可能。

（Translated by @[owo_ImposterAnYu_owo](https://www.luogu.com.cn/user/510555)）

## 样例 #1

### 输入

```
5
4
3
7
5
2
```

### 输出

```
3 4 2 1
-1
6 7 4 5 3 2 1
5 4 1 2 3
2 1
```



---

---
title: "Minimize the Thickness"
layout: "post"
diff: 普及-
pid: CF1741C
tag: []
---

# Minimize the Thickness

## 题目描述

给你一个长度为 $n$ 的数组 $a$，第 $i$ 个元素为 $a_i$。我们可以将 $a$ 分为若干个连续的不为空的子段，但前提条件是每个元素都要在一个子段里，且每个子段里的元素和都必须相等。

例如，我们有一个长度为 $6$ 的数组 $[55,45,30,30,40,100]$，如果我们把这个数组分为 $[55,45]$、$[30,30,40]$ 和 $[100]$ 三个子段的话，那么每个子段里的元素和都为 $100$。

定义若干个子段的厚度为这些子段里元素最多的子段里的元素个数，你的目标就是给定一个长度为 $n$ 的数组，找到一种分割子段的方法，使得分割后所有子段的厚度最小。

## 输入格式

第一行，一个正整数 $t(1 \leq t \leq 100)$，表示数据组数。

每组输入由两行组成：

第一行是一个正整数 $n(1 \leq n \leq 2000)$，表示数组的长度。

第二行，$n$ 个正整数，表示你需要分割的数组。

数据保证 $\sum n \leq 2000$。

## 输出格式

对于每一组数据，输出一个正整数，表示可以得到的最小厚度。

（Translated by @[owo_ImposterAnYu_owo](https://www.luogu.com.cn/user/510555)）

## 样例 #1

### 输入

```
4
6
55 45 30 30 40 100
4
10 23 7 13
5
10 55 35 30 65
6
4 1 1 1 1 4
```

### 输出

```
3
4
2
3
```



---

---
title: "Stripes"
layout: "post"
diff: 普及-
pid: CF1742C
tag: []
---

# Stripes

## 题目描述

On an $ 8 \times 8 $ grid, some horizontal rows have been painted red, and some vertical columns have been painted blue, in some order. The stripes are drawn sequentially, one after the other. When the stripe is drawn, it repaints all the cells through which it passes.

Determine which color was used last.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1742C/6f423ce4b1dd07561098c185bf230d882c12b3e9.png)The red stripe was painted after the blue one, so the answer is R.

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \leq t \leq 4000 $ ) — the number of test cases. The description of test cases follows. There is an empty line before each test case.

Each test case consists of $ 8 $ lines, each containing $ 8 $ characters. Each of these characters is either 'R', 'B', or '.', denoting a red square, a blue square, and an unpainted square, respectively.

It is guaranteed that the given field is obtained from a colorless one by drawing horizontal red rows and vertical blue columns.

At least one stripe is painted.

## 输出格式

For each test case, output 'R' if a red stripe was painted last, and 'B' if a blue stripe was painted last (without quotes).

## 说明/提示

The first test case is pictured in the statement.

In the second test case, the first blue column is painted first, then the first and last red rows, and finally the last blue column. Since a blue stripe is painted last, the answer is B.

## 样例 #1

### 输入

```
4


....B...
....B...
....B...
RRRRRRRR
....B...
....B...
....B...
....B...


RRRRRRRB
B......B
B......B
B......B
B......B
B......B
B......B
RRRRRRRB


RRRRRRBB
.B.B..BB
RRRRRRBB
.B.B..BB
.B.B..BB
RRRRRRBB
.B.B..BB
.B.B..BB


........
........
........
RRRRRRRR
........
........
........
........
```

### 输出

```
R
B
B
R
```



---

---
title: "Permutation Value"
layout: "post"
diff: 普及-
pid: CF1743B
tag: []
---

# Permutation Value

## 题目描述

You are given an integer $ n $ . You have to construct a permutation of size $ n $ .

A permutation is an array where each integer from $ 1 $ to $ s $ (where $ s $ is the size of permutation) occurs exactly once. For example, $ [2, 1, 4, 3] $ is a permutation of size $ 4 $ ; $ [1, 2, 4, 5, 3] $ is a permutation of size $ 5 $ ; $ [1, 4, 3] $ is not a permutation (the integer $ 2 $ is absent), $ [2, 1, 3, 1] $ is not a permutation (the integer $ 1 $ appears twice).

A subsegment of a permutation is a contiguous subsequence of that permutation. For example, the permutation $ [2, 1, 4, 3] $ has $ 10 $ subsegments: $ [2] $ , $ [2, 1] $ , $ [2, 1, 4] $ , $ [2, 1, 4, 3] $ , $ [1] $ , $ [1, 4] $ , $ [1, 4, 3] $ , $ [4] $ , $ [4, 3] $ and $ [3] $ .

The value of the permutation is the number of its subsegments which are also permutations. For example, the value of $ [2, 1, 4, 3] $ is $ 3 $ since the subsegments $ [2, 1] $ , $ [1] $ and $ [2, 1, 4, 3] $ are permutations.

You have to construct a permutation of size $ n $ with minimum possible value among all permutations of size $ n $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 48 $ ) — the number of test cases.

Then, $ t $ lines follow. The $ i $ -th of them contains one integer $ n $ ( $ 3 \le n \le 50 $ ) representing the $ i $ -th test case.

## 输出格式

For each test case, print $ n $ integers — the permutation of size $ n $ with minimum possible value. If there are multiple such permutations, print any of them.

## 说明/提示

In the first example, the permutation $ [1, 4, 3, 5, 2] $ is one of the possible answers; its value is $ 2 $ .

In the second example, the permutation $ [4, 1, 6, 2, 5, 3] $ is one of the possible answers; its value is $ 2 $ .

## 样例 #1

### 输入

```
2
5
6
```

### 输出

```
1 4 3 5 2
4 1 6 2 5 3
```



---

---
title: "Save the Magazines"
layout: "post"
diff: 普及-
pid: CF1743C
tag: []
---

# Save the Magazines

## 题目描述

Monocarp has been collecting rare magazines for quite a while, and now he has decided to sell them. He distributed the magazines between $ n $ boxes, arranged in a row. The $ i $ -th box contains $ a_i $ magazines. Some of the boxes are covered with lids, others are not.

Suddenly it started to rain, and now Monocarp has to save as many magazines from the rain as possible. To do this, he can move the lids between boxes as follows: if the $ i $ -th box was covered with a lid initially, he can either move the lid from the $ i $ -th box to the box $ (i-1) $ (if it exists), or keep the lid on the $ i $ -th box. You may assume that Monocarp can move the lids instantly at the same moment, and no lid can be moved more than once. If a box will be covered with a lid after Monocarp moves the lids, the magazines in it will be safe from the rain; otherwise they will soak.

You have to calculate the maximum number of magazines Monocarp can save from the rain.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of the testcases.

The first line of each testcase contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of boxes.

The second line contains a string of $ n $ characters 0 and/or 1. If the $ i $ -th character is 1, the $ i $ -th box is initially covered with a lid. If the $ i $ -th character is 0, the $ i $ -th box is initially not covered.

The third line contains a sequence of integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^4 $ ), where $ a_i $ is the number of magazines in the $ i $ -th box.

The sum of $ n $ over all testcases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each testcase, print one integer — the maximum number of magazines Monocarp can save from the rain.

## 说明/提示

In the first testcase of the example, Monocarp can move the lid from the second box to the first box, so the boxes $ 1 $ , $ 3 $ and $ 4 $ are covered, and $ 10 + 8 + 9 = 27 $ magazines are saved.

In the second testcase, Monocarp can move the lid from the second box to the first box, then from the third box to the second box, then from the fifth box to the fourth box, and then from the sixth box to the fifth box. The boxes $ 1 $ , $ 2 $ , $ 4 $ and $ 5 $ will be covered, so $ 20 + 10 + 30 + 20 = 80 $ magazines can be saved.

There are no lids in the third testcase, so it's impossible to save even a single magazine.

## 样例 #1

### 输入

```
4
5
01110
10 5 8 9 6
6
011011
20 10 9 30 20 19
4
0000
100 100 100 100
4
0111
5 4 5 1
```

### 输出

```
27
80
0
14
```



---

---
title: "Traffic Light"
layout: "post"
diff: 普及-
pid: CF1744C
tag: []
---

# Traffic Light

## 题目描述

You find yourself on an unusual crossroad with a weird traffic light. That traffic light has three possible colors: red (r), yellow (y), green (g). It is known that the traffic light repeats its colors every $ n $ seconds and at the $ i $ -th second the color $ s_i $ is on.

That way, the order of the colors is described by a string. For example, if $ s= $ "rggry", then the traffic light works as the following: red-green-green-red-yellow-red-green-green-red-yellow- ... and so on.

More formally, you are given a string $ s_1, s_2, \ldots, s_n $ of length $ n $ . At the first second the color $ s_1 $ is on, at the second — $ s_2 $ , ..., at the $ n $ -th second the color $ s_n $ is on, at the $ n + 1 $ -st second the color $ s_1 $ is on and so on.

You need to cross the road and that can only be done when the green color is on.

You know which color is on the traffic light at the moment, but you don't know the current moment of time. You need to find the minimum amount of time in which you are guaranteed to cross the road.

You can assume that you cross the road immediately.

For example, with $ s= $ "rggry" and the current color r there are two options: either the green color will be on after $ 1 $ second, or after $ 3 $ . That way, the answer is equal to $ 3 $ — that is the number of seconds that we are guaranteed to cross the road, if the current color is r.

## 输入格式

The first line contains a single integer $ t $ $ (1 \leq t \leq 10^4 $ ) — the number of test cases.

Then the description of the test cases follows.

The first line of each test case contains an integer $ n $ and a symbol $ c $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ , $ c $ is one of allowed traffic light colors r, y or g)— the length of the string $ s $ and the current color of the traffic light.

The second line of each test case contains a string $ s $ of the length $ n $ , consisting of the letters r, y and g.

It is guaranteed that the symbol g is in the string $ s $ and the symbol $ c $ is in the string $ s $ .

It is guaranteed, that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case output the minimal number of second in which you are guaranteed to cross the road.

## 说明/提示

The first test case is explained in the statement.

In the second test case the green color is on so you can cross the road immediately.

In the third test case, if the red color was on at the second second, then we would wait for the green color for one second, and if the red light was on at the first second, then we would wait for the green light for two seconds.

In the fourth test case the longest we would wait for the green color is if we wait for it starting from the fifth second.

## 样例 #1

### 输入

```
6
5 r
rggry
1 g
g
3 r
rrg
5 y
yrrgy
7 r
rgrgyrg
9 y
rrrgyyygy
```

### 输出

```
3
0
2
4
1
4
```



---

---
title: "Maxmina"
layout: "post"
diff: 普及-
pid: CF1746A
tag: []
---

# Maxmina

## 题目描述

You have an array $ a $ of size $ n $ consisting only of zeroes and ones and an integer $ k $ . In one operation you can do one of the following:

- Select $ 2 $ consecutive elements of $ a $ and replace them with their minimum (that is, let $ a := [a_{1}, a_{2}, \ldots, a_{i-1}, \min(a_{i}, a_{i+1}), a_{i+2}, \ldots, a_{n}] $ for some $ 1 \le i \le n-1 $ ). This operation decreases the size of $ a $ by $ 1 $ .
- Select $ k $ consecutive elements of $ a $ and replace them with their maximum (that is, let $ a := [a_{1}, a_{2}, \ldots, a_{i-1}, \max(a_{i}, a_{i+1}, \ldots, a_{i+k-1}), a_{i+k}, \ldots, a_{n}] $ for some $ 1 \le i \le n-k+1 $ ). This operation decreases the size of $ a $ by $ k-1 $ .

Determine if it's possible to turn $ a $ into $ [1] $ after several (possibly zero) operations.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 2 \le k \le n \le 50 $ ), the size of array $ a $ and the length of segments that you can perform second type operation on.

The second line contains $ n $ integers $ a_{1}, a_{2}, \ldots, a_{n} $ ( $ a_i $ is $ 0 $ or $ 1 $ ), elements of array $ a $ .

## 输出格式

For each test case, if it is possible to turn $ a $ into $ [1] $ , print "YES", otherwise print "NO".

## 说明/提示

In the first test case, you can perform the second type operation on second and third elements so $ a $ becomes $ [0, 1] $ , then you can perform the second type operation on first and second elements, so $ a $ turns to $ [1] $ .

In the fourth test case, it's obvious to see that you can't make any $ 1 $ , no matter what you do.

In the fifth test case, you can first perform a type 2 operation on the first three elements so that $ a $ becomes $ [1, 0, 0, 1] $ , then perform a type 2 operation on the elements in positions two through four, so that $ a $ becomes $ [1, 1] $ , and finally perform the first type operation on the remaining elements, so that $ a $ becomes $ [1] $ .

## 样例 #1

### 输入

```
7
3 2
0 1 0
5 3
1 0 1 1 0
2 2
1 1
4 4
0 0 0 0
6 3
0 0 1 0 0 1
7 5
1 1 1 1 1 1 1
5 3
0 0 1 0 0
```

### 输出

```
YES
YES
YES
NO
YES
YES
YES
```



---

---
title: "Rebellion"
layout: "post"
diff: 普及-
pid: CF1746B
tag: []
---

# Rebellion

## 题目描述

You have an array $ a $ of size $ n $ consisting only of zeroes and ones. You can do the following operation:

- choose two indices $ 1 \le i , j \le n $ , $ i \ne j $ ,
- add $ a_{i} $ to $ a_{j} $ ,
- remove $ a_{i} $ from $ a $ .

Note that elements of $ a $ can become bigger than $ 1 $ after performing some operations. Also note that $ n $ becomes $ 1 $ less after the operation.

What is the minimum number of operations needed to make $ a $ non-decreasing, i. e. that each element is not less than the previous element?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 1 \le n \le 10^5 $ ), the size of array $ a $ .

Next line contains $ n $ integers $ a_{1}, a_{2}, \ldots a_{n} $ ( $ a_i $ is $ 0 $ or $ 1 $ ), elements of array $ a $ .

It's guaranteed that sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case print a single integer, minimum number of operations needed to make $ a $ non-decreasing.

## 说明/提示

In the first test case, $ a $ is already non-decreasing, so you don't need to do any operations and the answer is $ 0 $ .

In the second test case, you can perform an operation for $ i = 1 $ and $ j = 5 $ , so $ a $ will be equal to $ [0, 0, 1, 2] $ and it becomes non-decreasing.

In the third test case, you can perform an operation for $ i = 2 $ and $ j = 1 $ , so $ a $ will be equal to $ [1] $ and it becomes non-decreasing.

## 样例 #1

### 输入

```
4
8
0 0 1 1 1 1 1 1
5
1 0 0 1 1
2
1 0
11
1 1 0 0 1 0 0 1 1 1 0
```

### 输出

```
0
1
1
3
```



---

---
title: "Death's Blessing"
layout: "post"
diff: 普及-
pid: CF1749B
tag: []
---

# Death's Blessing

## 题目描述

You are playing a computer game. To pass the current level, you have to kill a big horde of monsters. In this horde, there are $ n $ monsters standing in the row, numbered from $ 1 $ to $ n $ . The $ i $ -th monster has $ a_i $ health and a special "Death's Blessing" spell of strength $ b_i $ attached to it.

You are going to kill all of them one by one. It takes exactly $ h $ seconds to kill a monster with health $ h $ .

When the $ i $ -th monster dies, it casts its spell that increases the health of its neighbors by $ b_i $ (the neighbors of the $ j $ -th monster in the row are the monsters on places $ j - 1 $ and $ j + 1 $ . The first and the last monsters have only one neighbor each).

After each monster is killed, the row shrinks, so its former neighbors become adjacent to each other (so if one of them dies, the other one is affected by its spell). For example, imagine a situation with $ 4 $ monsters with health $ a = [2, 6, 7, 3] $ and spells $ b = [3, 6, 0, 5] $ . One of the ways to get rid of the monsters is shown below:

  $ 2 $  $ 6 $  $ 7 $  $ 3 $  $ \xrightarrow{6\ s} $  $ 8 $  $ 13 $  $ 3 $  $ \xrightarrow{13\ s} $  $ 8 $  $ 3 $  $ \xrightarrow{8\ s} $  $ 6 $  $ \xrightarrow{6\ s} $  $ \{\} $  $ 3 $  $ 6 $  $ 0 $  $ 5 $  $ 3 $  $ 0 $  $ 5 $  $ 3 $  $ 5 $  $ 5 $ The first row represents the health of each monster, the second one — the power of the spells.As a result, we can kill all monsters in $ 6 + 13 + 8 + 6 $ $ = $ $ 33 $ seconds. Note that it's only an example and may not be the fastest way to get rid of the monsters.

What is the minimum time required to kill all monsters in the row?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of monsters in the row.

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the initial health of corresponding monsters.

The third line contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ 0 \le b_i \le 10^9 $ ), where $ b_i $ is the strength of the spell for the $ i $ -th monster.

It's guaranteed that the sum of $ n $ doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print one integer — the minimum possible total time to kill all monsters.

## 说明/提示

In the first test case, there is only one monster that will be killed in $ 10 $ seconds.

In the second test case, it's optimal to kill the first monster, the last monster and then the middle one. It will take $ 100 + 100 + (1 + 1 + 1) $ $ = $ $ 203 $ seconds.

In the third test case, it's optimal to kill the first monster, then the third one, then the fourth one and finally the second one. It will take $ 2 + 7 + (3 + 0) + (3 + 6 + 5) $ $ = $ $ 26 $ seconds.

## 样例 #1

### 输入

```
4
1
10
0
3
100 1 100
1 100 1
4
2 6 7 3
3 6 0 5
2
1000000000 1000000000
1000000000 1000000000
```

### 输出

```
10
203
26
3000000000
```



---

---
title: "Technical Support"
layout: "post"
diff: 普及-
pid: CF1754A
tag: []
---

# Technical Support

## 题目描述

### 题面翻译

给定一个只包含大写字母 $\texttt{Q}$ 和 $\texttt{A}$ 的字符串，如果字符串里的每一个 $\texttt{Q}$ 都能与**在其之后**的 $\texttt{A}$ 一一对应地匹配，则输出字符串 $\texttt{Yes}$，否则输出字符串 $\texttt{No}$。注意，可以有 $\texttt{A}$ 没有被匹配，但每个 $\texttt{Q}$ 必须成功地匹配。

## 输入格式

输入一个只包含大写字母 $\texttt{Q}$ 和 $\texttt{A}$ 的字符串。

## 输出格式

输出字符串 $\texttt{Yes}$ 或 $\texttt{No}$。

## 样例 #1

### 输入

```
5
4
QQAA
4
QQAQ
3
QAA
1
Q
14
QAQQAQAAQQQAAA
```

### 输出

```
Yes
No
Yes
No
Yes
```



---

---
title: "XOR = Average"
layout: "post"
diff: 普及-
pid: CF1758B
tag: []
---

# XOR = Average

## 题目描述

You are given an integer $ n $ . Find a sequence of $ n $ integers $ a_1, a_2, \dots, a_n $ such that $ 1 \leq a_i \leq 10^9 $ for all $ i $ and $ $$$a_1 \oplus a_2 \oplus \dots \oplus a_n = \frac{a_1 + a_2 + \dots + a_n}{n}, $ $  where  $ \\oplus$$$ represents the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

It can be proven that there exists a sequence of integers that satisfies all the conditions above.

## 输入格式

The first line of input contains $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first and only line of each test case contains one integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the length of the sequence you have to find.

The sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output $ n $ space-separated integers $ a_1, a_2, \dots, a_n $ satisfying the conditions in the statement.

If there are several possible answers, you can output any of them.

## 说明/提示

In the first test case, $ 69 = \frac{69}{1} = 69 $ .

In the second test case, $ 13 \oplus 2 \oplus 8 \oplus 1 = \frac{13 + 2 + 8 + 1}{4} = 6 $ .

## 样例 #1

### 输入

```
3
1
4
3
```

### 输出

```
69
13 2 8 1
7 7 7
```



---

---
title: "Lost Permutation"
layout: "post"
diff: 普及-
pid: CF1759B
tag: []
---

# Lost Permutation

## 题目描述

A sequence of $ n $ numbers is called a permutation if it contains all integers from $ 1 $ to $ n $ exactly once. For example, the sequences \[ $ 3, 1, 4, 2 $ \], \[ $ 1 $ \] and \[ $ 2,1 $ \] are permutations, but \[ $ 1,2,1 $ \], \[ $ 0,1 $ \] and \[ $ 1,3,4 $ \] — are not.

Polycarp lost his favorite permutation and found only some of its elements — the numbers $ b_1, b_2, \dots b_m $ . He is sure that the sum of the lost elements equals $ s $ .

Determine whether one or more numbers can be appended to the given sequence $ b_1, b_2, \dots b_m $ such that the sum of the added numbers equals $ s $ , and the resulting new array is a permutation?

## 输入格式

The first line of input contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) —the number of test cases.

Then the descriptions of the test cases follow.

The first line of each test set contains two integers $ m $ and $ s $ ( $ 1 \le m \le 50 $ , $ 1 \le s \le 1000 $ )—-the number of found elements and the sum of forgotten numbers.

The second line of each test set contains $ m $ different integers $ b_1, b_2 \dots b_m $ ( $ 1 \le b_i \le 50 $ ) — the elements Polycarp managed to find.

## 输出格式

Print $ t $ lines, each of which is the answer to the corresponding test set. Print as the answer YES if you can append several elements to the array $ b $ , that their sum equals $ s $ and the result will be a permutation. Output NO otherwise.

You can output the answer in any case (for example, yEs, yes, Yes and YES will be recognized as positive answer).

## 说明/提示

In the test case of the example, $ m=3, s=13, b=[3,1,4] $ . You can append to $ b $ the numbers $ 6,2,5 $ , the sum of which is $ 6+2+5=13 $ . Note that the final array will become $ [3,1,4,6,2,5] $ , which is a permutation.

In the second test case of the example, $ m=1, s=1, b=[1] $ . You cannot append one or more numbers to $ [1] $ such that their sum equals $ 1 $ and the result is a permutation.

In the third test case of the example, $ m=3, s=3, b=[1,4,2] $ . You can append the number $ 3 $ to $ b $ . Note that the resulting array will be $ [1,4,2,3] $ , which is a permutation.

## 样例 #1

### 输入

```
5
3 13
3 1 4
1 1
1
3 3
1 4 2
2 1
4 3
5 6
1 2 3 4 5
```

### 输出

```
YES
NO
YES
NO
YES
```



---

---
title: "Thermostat"
layout: "post"
diff: 普及-
pid: CF1759C
tag: []
---

# Thermostat

## 题目描述

Vlad came home and found out that someone had reconfigured the old thermostat to the temperature of $ a $ .

The thermostat can only be set to a temperature from $ l $ to $ r $ inclusive, the temperature cannot change by less than $ x $ . Formally, in one operation you can reconfigure the thermostat from temperature $ a $ to temperature $ b $ if $ |a - b| \ge x $ and $ l \le b \le r $ .

You are given $ l $ , $ r $ , $ x $ , $ a $ and $ b $ . Find the minimum number of operations required to get temperature $ b $ from temperature $ a $ , or say that it is impossible.

## 输入格式

The first line of input data contains the single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test.

The descriptions of the test cases follow.

The first line of each case contains three integers $ l $ , $ r $ and $ x $ ( $ -10^9 \le l \le r \le 10^9 $ , $ 1 \le x \le 10^9 $ ) — range of temperature and minimum temperature change.

The second line of each case contains two integers $ a $ and $ b $ ( $ l \le a, b \le r $ ) — the initial and final temperatures.

## 输出格式

Output $ t $ numbers, each of which is the answer to the corresponding test case. If it is impossible to achieve the temperature $ b $ , output -1, otherwise output the minimum number of operations.

## 说明/提示

In the first example, the thermostat is already set up correctly.

In the second example, you can achieve the desired temperature as follows: $ 4 \rightarrow 10 \rightarrow 5 $ .

In the third example, you can achieve the desired temperature as follows: $ 3 \rightarrow 8 \rightarrow 2 \rightarrow 7 $ .

In the fourth test, it is impossible to make any operation.

## 样例 #1

### 输入

```
10
3 5 6
3 3
0 15 5
4 5
0 10 5
3 7
3 5 6
3 4
-10 10 11
-5 6
-3 3 4
1 0
-5 10 8
9 2
1 5 1
2 5
-1 4 3
0 2
-6 3 6
-1 -4
```

### 输出

```
0
2
3
-1
1
-1
3
1
3
-1
```



---

---
title: "Challenging Valleys"
layout: "post"
diff: 普及-
pid: CF1760D
tag: []
---

# Challenging Valleys

## 题目描述

You are given an array $ a[0 \dots n-1] $ of $ n $ integers. This array is called a "valley" if there exists exactly one subarray $ a[l \dots r] $ such that:

- $ 0 \le l \le r \le n-1 $ ,
- $ a_l = a_{l+1} = a_{l+2} = \dots = a_r $ ,
- $ l = 0 $ or $ a_{l-1} > a_{l} $ ,
- $ r = n-1 $ or $ a_r < a_{r+1} $ .

Here are three examples:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1760D/03a48b22ef3c4e8e328e6caa6008b87fe7824d84.png)The first image shows the array \[ $ 3, 2, 2, 1, 2, 2, 3 $ \], it is a valley because only subarray with indices $ l=r=3 $ satisfies the condition.

The second image shows the array \[ $ 1, 1, 1, 2, 3, 3, 4, 5, 6, 6, 6 $ \], it is a valley because only subarray with indices $ l=0, r=2 $ satisfies the codition.

The third image shows the array \[ $ 1, 2, 3, 4, 3, 2, 1 $ \], it is not a valley because two subarrays $ l=r=0 $ and $ l=r=6 $ that satisfy the condition.

You are asked whether the given array is a valley or not.

Note that we consider the array to be indexed from $ 0 $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 2\cdot10^5 $ ) — the length of the array.

The second line of each test case contains $ n $ integers $ a_i $ ( $ 1 \leq a_i \leq 10^9 $ ) — the elements of the array.

It is guaranteed that the sum of $ n $ over all test cases is smaller than $ 2\cdot10^5 $ .

## 输出格式

For each test case, output "YES" (without quotes) if the array is a valley, and "NO" (without quotes) otherwise.

You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).

## 说明/提示

The first three test cases are explained in the statement.

## 样例 #1

### 输入

```
6
7
3 2 2 1 2 2 3
11
1 1 1 2 3 3 4 5 6 6 6
7
1 2 3 4 3 2 1
7
9 7 4 6 9 9 10
1
1000000000
8
9 4 4 5 9 4 9 10
```

### 输出

```
YES
YES
NO
YES
YES
NO
```



---

---
title: "Binary Inversions"
layout: "post"
diff: 普及-
pid: CF1760E
tag: []
---

# Binary Inversions

## 题目描述

You are given a binary array $ ^{\dagger} $ of length $ n $ . You are allowed to perform one operation on it at most once. In an operation, you can choose any element and flip it: turn a $ 0 $ into a $ 1 $ or vice-versa.

What is the maximum number of inversions $ ^{\ddagger} $ the array can have after performing at most one operation?

 $ ^\dagger $ A binary array is an array that contains only zeroes and ones.

 $ ^\ddagger $ The number of inversions in an array is the number of pairs of indices $ i,j $ such that $ i<j $ and $ a_i > a_j $ .

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 2\cdot10^5 $ ) — the length of the array.

The following line contains $ n $ space-separated positive integers $ a_1 $ , $ a_2 $ ,..., $ a_n $ ( $ 0 \leq a_i \leq 1 $ ) — the elements of the array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, output a single integer — the maximum number of inversions the array can have after performing at most one operation.

## 说明/提示

For the first test case, the inversions are initially formed by the pairs of indices ( $ 1, 2 $ ), ( $ 1, 4 $ ), ( $ 3, 4 $ ), being a total of $ 3 $ , which already is the maximum possible.

For the second test case, the inversions are initially formed by the pairs of indices ( $ 2, 3 $ ), ( $ 2, 4 $ ), ( $ 2, 6 $ ), ( $ 5, 6 $ ), being a total of four. But, by flipping the first element, the array becomes $ {1, 1, 0, 0, 1, 0} $ , which has the inversions formed by the pairs of indices ( $ 1, 3 $ ), ( $ 1, 4 $ ), ( $ 1, 6 $ ), ( $ 2, 3 $ ), ( $ 2, 4 $ ), ( $ 2, 6 $ ), ( $ 5, 6 $ ) which total to $ 7 $ inversions which is the maximum possible.

## 样例 #1

### 输入

```
5
4
1 0 1 0
6
0 1 0 0 1 0
2
0 0
8
1 0 1 1 0 0 0 1
3
1 1 1
```

### 输出

```
3
7
1
13
2
```



---

---
title: "Elimination of a Ring"
layout: "post"
diff: 普及-
pid: CF1761B
tag: []
---

# Elimination of a Ring

## 题目描述

Define a cyclic sequence of size $ n $ as an array $ s $ of length $ n $ , in which $ s_n $ is adjacent to $ s_1 $ .

Muxii has a ring represented by a cyclic sequence $ a $ of size $ n $ .

However, the ring itself hates equal adjacent elements. So if two adjacent elements in the sequence are equal at any time, one of them will be erased immediately. The sequence doesn't contain equal adjacent elements initially.

Muxii can perform the following operation until the sequence becomes empty:

- Choose an element in $ a $ and erase it.

For example, if ring is $ [1, 2, 4, 2, 3, 2] $ , and Muxii erases element $ 4 $ , then ring would erase one of the elements equal to $ 2 $ , and the ring will become $ [1, 2, 3, 2] $ .

Muxii wants to find the maximum number of operations he could perform.

Note that in a ring of size $ 1 $ , its only element isn't considered adjacent to itself (so it's not immediately erased).

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1\leq t\leq 100 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1\leq n\leq 100 $ ) — the size of the cyclic sequence.

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\leq a_i\leq n $ ) — the sequence itself.

It's guaranteed that $ a_i\ne a_{i+1} $ for $ 1\leq i<n $ .

It's guaranteed that $ a_n\ne a_1 $ when $ n>1 $ .

## 输出格式

For each test case, output a single integer — the maximum number of operations Muxii can perform.

## 说明/提示

In the first test case, you can erase the second element first, then erase the remaining elements one by one in any order. In total, you can perform the operation $ 4 $ times. Note that if you erase the first element first, then the sequence will be turned into $ [2,3,2] $ and then immediately become $ [2,3] $ .

In the second test case, you can erase the first element first, then the sequence becomes $ [2,1] $ . Then you can erase all remaining elements one by one in any order.

## 样例 #1

### 输入

```
3
4
1 2 3 2
4
1 2 1 2
1
1
```

### 输出

```
4
3
1
```



---

---
title: "Make Array Good"
layout: "post"
diff: 普及-
pid: CF1762B
tag: []
---

# Make Array Good

## 题目描述

我们称一个长度为 $m$ 序列 $b$ 是好的，当且仅当对于每一个二元组 $i,j \in [1,m]$，都有 $\min(b_i,b_j) | \max(b_i,b_j)$。

其中 $|$ 表示整除，即 $a|b$ 表示 $a$ 被 $b$ 整除。

接下来给定一个长度为 $n$ 的序列 $a$。

你可以对他进行以下操作：

- 选择 $i(1 \le i \le n)$ 和一个非负整数 $x(0 \le x \le a_i)$，将 $a_i$ 变成 $a_i+x$。

- 你应该保证在操作后 $a_i \le 10^{18}$。

你需要使用最多 $n$ 个操作，使得 $a$ 序列成为一个好的序列，可以证明一定是可以构造出来的。

请输出构造方案。

## 输入格式

第一行一个正整数 $t(1 \le t \le 10^4)$，表示数据组数。

对于每组数据：

第一行一个正整数 $n(1 \le n \le 10^5)$ 表示序列的长度。

接下来 $n$ 个正整数 $a_1,a_2,\dots,a_n(1 \le a_i \le 10^9)$。

## 输出格式

对于每组数据：

第一行一个整数 $p(0 \le p \le n)$，表示解决方案的操作数。

接下来 $p$ 行，每行两个用空格分开的整数 $i$ 和 $x$。

不需要最小化方案数。

## 样例 #1

### 输入

```
4
4
2 3 5 5
2
4 8
5
3 4 343 5 6
3
31 5 17
```

### 输出

```
4
1 2
1 1
2 2
3 0
0
5
1 3
1 4
2 1
5 4
3 7
3
1 29
2 5
3 3
```



---

---
title: "Exchange"
layout: "post"
diff: 普及-
pid: CF1765E
tag: []
---

# Exchange

## 题目描述

Monocarp is playing a MMORPG. There are two commonly used types of currency in this MMORPG — gold coins and silver coins. Monocarp wants to buy a new weapon for his character, and that weapon costs $ n $ silver coins. Unfortunately, right now, Monocarp has no coins at all.

Monocarp can earn gold coins by completing quests in the game. Each quest yields exactly one gold coin. Monocarp can also exchange coins via the in-game trading system. Monocarp has spent days analyzing the in-game economy; he came to the following conclusion: it is possible to sell one gold coin for $ a $ silver coins (i. e. Monocarp can lose one gold coin to gain $ a $ silver coins), or buy one gold coin for $ b $ silver coins (i. e. Monocarp can lose $ b $ silver coins to gain one gold coin).

Now Monocarp wants to calculate the minimum number of quests that he has to complete in order to have at least $ n $ silver coins after some abuse of the in-game economy. Note that Monocarp can perform exchanges of both types (selling and buying gold coins for silver coins) any number of times.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of one line containing three integers $ n $ , $ a $ and $ b $ ( $ 1 \le n \le 10^7 $ ; $ 1 \le a, b \le 50 $ ).

## 输出格式

For each test case, print one integer — the minimum possible number of quests Monocarp has to complete.

## 说明/提示

In the first test case of the example, Monocarp should complete $ 4 $ quests, and then sell $ 4 $ gold coins for $ 100 $ silver coins.

In the second test case, Monocarp should complete $ 400000 $ quests, and then sell $ 400000 $ gold coins for $ 10 $ million silver coins.

In the third test case, Monocarp should complete $ 1 $ quest, sell the gold coin for $ 50 $ silver coins, buy a gold coin for $ 48 $ silver coins, and then sell it again for $ 50 $ coins. So, he will have $ 52 $ silver coins.

In the fourth test case, Monocarp should complete $ 1 $ quest and then sell the gold coin he has obtained for $ 50 $ silver coins.

## 样例 #1

### 输入

```
4
100 25 30
9999997 25 50
52 50 48
49 50 1
```

### 输出

```
4
400000
1
1
```



---

---
title: "Minimum LCM"
layout: "post"
diff: 普及-
pid: CF1765M
tag: []
---

# Minimum LCM

## 题目描述

You are given an integer $ n $ .

Your task is to find two positive (greater than $ 0 $ ) integers $ a $ and $ b $ such that $ a+b=n $ and the least common multiple (LCM) of $ a $ and $ b $ is the minimum among all possible values of $ a $ and $ b $ . If there are multiple answers, you can print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^9 $ ).

## 输出格式

For each test case, print two positive integers $ a $ and $ b $ — the answer to the problem. If there are multiple answers, you can print any of them.

## 说明/提示

In the second example, there are $ 8 $ possible pairs of $ a $ and $ b $ :

- $ a = 1 $ , $ b = 8 $ , $ LCM(1, 8) = 8 $ ;
- $ a = 2 $ , $ b = 7 $ , $ LCM(2, 7) = 14 $ ;
- $ a = 3 $ , $ b = 6 $ , $ LCM(3, 6) = 6 $ ;
- $ a = 4 $ , $ b = 5 $ , $ LCM(4, 5) = 20 $ ;
- $ a = 5 $ , $ b = 4 $ , $ LCM(5, 4) = 20 $ ;
- $ a = 6 $ , $ b = 3 $ , $ LCM(6, 3) = 6 $ ;
- $ a = 7 $ , $ b = 2 $ , $ LCM(7, 2) = 14 $ ;
- $ a = 8 $ , $ b = 1 $ , $ LCM(8, 1) = 8 $ .

In the third example, there are $ 5 $ possible pairs of $ a $ and $ b $ :

- $ a = 1 $ , $ b = 4 $ , $ LCM(1, 4) = 4 $ ;
- $ a = 2 $ , $ b = 3 $ , $ LCM(2, 3) = 6 $ ;
- $ a = 3 $ , $ b = 2 $ , $ LCM(3, 2) = 6 $ ;
- $ a = 4 $ , $ b = 1 $ , $ LCM(4, 1) = 4 $ .

## 样例 #1

### 输入

```
4
2
9
5
10
```

### 输出

```
1 1
3 6
1 4
5 5
```



---

---
title: "Notepad#"
layout: "post"
diff: 普及-
pid: CF1766B
tag: []
---

# Notepad#

## 题目描述

一开始打出的内容为空。现在你要打出一个长度为 $n$ 的字符串 $s$（全为英文小写字母组成），为此每次你可以进行如下操作中的一种：

- 在已打出内容的最后添加一个字符。
- 复制已打出内容的一个连续的子串并加到内容的末尾。

问你能不能在严格小于 $n$ 次操作下打出字符串 $s$？

## 输入格式

$t$ 组数据。第一行输入正整数 $t(1\le t\le10^4)$。

每组数据第一行输入正整数 $n$，第二行输入字符串 $s$。

单个测试点内所有 $n$ 之和不超过 $2\times10^5$。

## 输出格式

输出 $t$ 行，每行输出这组数据的答案。如果可以达到要求，输出 `YES`。否则输出 `NO`。

## 样例 #1

### 输入

```
6
10
codeforces
8
labacaba
5
uohhh
16
isthissuffixtree
1
x
4
momo
```

### 输出

```
NO
YES
NO
YES
NO
YES
```



---

---
title: "Quick Sort"
layout: "post"
diff: 普及-
pid: CF1768B
tag: []
---

# Quick Sort

## 题目描述

You are given a permutation $ ^\dagger $ $ p $ of length $ n $ and a positive integer $ k \le n $ .

In one operation, you:

- Choose $ k $ distinct elements $ p_{i_1}, p_{i_2}, \ldots, p_{i_k} $ .
- Remove them and then add them sorted in increasing order to the end of the permutation.

For example, if $ p = [2,5,1,3,4] $ and $ k = 2 $ and you choose $ 5 $ and $ 3 $ as the elements for the operation, then $ [2, \color{red}{5}, 1, \color{red}{3}, 4] \rightarrow [2, 1, 4, \color{red}{3},\color{red}{5}] $ .

Find the minimum number of operations needed to sort the permutation in increasing order. It can be proven that it is always possible to do so.

 $ ^\dagger $ A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array).

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 2 \le n \le 10^5 $ , $ 1 \le k \le n $ ).

The second line of each test case contains $ n $ integers $ p_1,p_2,\ldots, p_n $ ( $ 1 \le p_i \le n $ ). It is guaranteed that $ p $ is a permutation.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case output a single integer — the minimum number of operations needed to sort the permutation. It can be proven that it is always possible to do so.

## 说明/提示

In the first test case, the permutation is already sorted.

In the second test case, you can choose element $ 3 $ , and the permutation will become sorted as follows: $ [\color{red}{3}, 1, 2] \rightarrow [1, 2, \color{red}{3}] $ .

In the third test case, you can choose elements $ 3 $ and $ 4 $ , and the permutation will become sorted as follows: $ [1, \color{red}{3}, 2, \color{red}{4}] \rightarrow [1, 2, \color{red}{3},\color{red}{4}] $ .

In the fourth test case, it can be shown that it is impossible to sort the permutation in $ 1 $ operation. However, if you choose elements $ 2 $ and $ 1 $ in the first operation, and choose elements $ 3 $ and $ 4 $ in the second operation, the permutation will become sorted as follows: $ [\color{red}{2}, 3, \color{red}{1}, 4] \rightarrow [\color{blue}{3}, \color{blue}{4}, \color{red}{1}, \color{red}{2}] \rightarrow [1,2, \color{blue}{3}, \color{blue}{4}] $ .

## 样例 #1

### 输入

```
4
3 2
1 2 3
3 1
3 1 2
4 2
1 3 2 4
4 2
2 3 1 4
```

### 输出

```
0
1
1
2
```



---

---
title: "Копирование файлов I"
layout: "post"
diff: 普及-
pid: CF1769B1
tag: []
---

# Копирование файлов I

## 题目描述

В этой версии задачи размеры копируемых файлов не превышают $ 1000 $ байт.

Вы копируете с одного сервера на другой $ n $ файлов размером $ a_1, a_2, \ldots, a_n $ байт. Файлы копируются последовательно в заданном порядке.

При копировании вы видите два прогресс-бара: первый показывает процент скопированных данных в текущем файле, а второй — общий процент скопированных данных по всем $ n $ файлам. Оба процента отображаются округлёнными вниз до целого числа. Значения на прогресс-барах обновляются после копирования каждого байта.

Формально, после копирования байта номер $ x $ из файла номер $ i $ первый прогресс-бар показывает $ \lfloor \frac{100 \cdot x}{a_i} \rfloor $ процентов, а второй — $ \lfloor \frac{100 \cdot (a_1 + a_2 + \ldots + a_{i - 1} + x)}{a_1 + a_2 + \ldots + a_n} \rfloor $ процентов. В самом начале копирования оба прогресс-бара показывают $ 0 $ процентов.

Найдите все такие целые числа от $ 0 $ до $ 100 $ включительно, что существует момент времени, в который оба прогресс-бара одновременно показывают это число. Выведите эти числа в порядке возрастания.

## 输入格式

В первой строке задано одно целое число $ n $ ( $ 1 \le n \le 100 $ ) — число копируемых файлов.

Во второй строке заданы $ n $ целых чисел $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 1000 $ ) — размеры файлов в байтах в том порядке, в котором они будут копироваться.

## 输出格式

Выведите в возрастающем порядке все числа от $ 0 $ до $ 100 $ включительно такие, что существует момент времени, в который на обоих прогресс-барах одновременно показывается это число.

## 样例 #1

### 输入

```
1
6
```

### 输出

```
0
16
33
50
66
83
100
```

## 样例 #2

### 输入

```
2
100 500
```

### 输出

```
0
95
96
97
98
99
100
```

## 样例 #3

### 输入

```
4
1000 2 2 998
```

### 输出

```
0
50
99
100
```

## 样例 #4

### 输入

```
6
170 130 400 256 30 100
```

### 输出

```
0
17
43
44
84
90
99
100
```



---

---
title: "Trading Business"
layout: "post"
diff: 普及-
pid: CF176A
tag: []
---

# Trading Business

## 题目描述

To get money for a new aeonic blaster, ranger Qwerty decided to engage in trade for a while. He wants to buy some number of items (or probably not to buy anything at all) on one of the planets, and then sell the bought items on another planet. Note that this operation is not repeated, that is, the buying and the selling are made only once. To carry out his plan, Qwerty is going to take a bank loan that covers all expenses and to return the loaned money at the end of the operation (the money is returned without the interest). At the same time, Querty wants to get as much profit as possible.

The system has $ n $ planets in total. On each of them Qwerty can buy or sell items of $ m $ types (such as food, medicine, weapons, alcohol, and so on). For each planet $ i $ and each type of items $ j $ Qwerty knows the following:

- $ a_{ij} $ — the cost of buying an item;
- $ b_{ij} $ — the cost of selling an item;
- $ c_{ij} $ — the number of remaining items.

It is not allowed to buy more than $ c_{ij} $ items of type $ j $ on planet $ i $ , but it is allowed to sell any number of items of any kind.

Knowing that the hold of Qwerty's ship has room for no more than $ k $ items, determine the maximum profit which Qwerty can get.

## 输入格式

The first line contains three space-separated integers $ n $ , $ m $ and $ k $ ( $ 2<=n<=10 $ , $ 1<=m,k<=100 $ ) — the number of planets, the number of question types and the capacity of Qwerty's ship hold, correspondingly.

Then follow $ n $ blocks describing each planet.

The first line of the $ i $ -th block has the planet's name as a string with length from $ 1 $ to $ 10 $ Latin letters. The first letter of the name is uppercase, the rest are lowercase. Then in the $ i $ -th block follow $ m $ lines, the $ j $ -th of them contains three integers $ a_{ij} $ , $ b_{ij} $ and $ c_{ij} $ ( $ 1<=b_{ij}<a_{ij}<=1000 $ , $ 0<=c_{ij}<=100 $ ) — the numbers that describe money operations with the $ j $ -th item on the $ i $ -th planet. The numbers in the lines are separated by spaces.

It is guaranteed that the names of all planets are different.

## 输出格式

Print a single number — the maximum profit Qwerty can get.

## 说明/提示

In the first test case you should fly to planet Venus, take a loan on 74 units of money and buy three items of the first type and 7 items of the third type ( $ 3·6+7·8=74 $ ). Then the ranger should fly to planet Earth and sell there all the items he has bought. He gets $ 3·9+7·9=90 $ units of money for the items, he should give 74 of them for the loan. The resulting profit equals 16 units of money. We cannot get more profit in this case.

## 样例 #1

### 输入

```
3 3 10
Venus
6 5 3
7 6 5
8 6 10
Earth
10 9 0
8 6 4
10 9 3
Mars
4 3 0
8 4 12
7 2 5

```

### 输出

```
16
```



---

---
title: "Koxia and Whiteboards"
layout: "post"
diff: 普及-
pid: CF1770A
tag: []
---

# Koxia and Whiteboards

## 题目描述

Kiyora has $ n $ whiteboards numbered from $ 1 $ to $ n $ . Initially, the $ i $ -th whiteboard has the integer $ a_i $ written on it.

Koxia performs $ m $ operations. The $ j $ -th operation is to choose one of the whiteboards and change the integer written on it to $ b_j $ .

Find the maximum possible sum of integers written on the whiteboards after performing all $ m $ operations.

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \le n,m \le 100 $ ).

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ).

The third line of each test case contains $ m $ integers $ b_1, b_2, \ldots, b_m $ ( $ 1 \le b_i \le 10^9 $ ).

## 输出格式

For each test case, output a single integer — the maximum possible sum of integers written on whiteboards after performing all $ m $ operations.

## 说明/提示

In the first test case, Koxia can perform the operations as follows:

1. Choose the $ 1 $ -st whiteboard and rewrite the integer written on it to $ b_1=4 $ .
2. Choose the $ 2 $ -nd whiteboard and rewrite to $ b_2=5 $ .

After performing all operations, the numbers on the three whiteboards are $ 4 $ , $ 5 $ and $ 3 $ respectively, and their sum is $ 12 $ . It can be proven that this is the maximum possible sum achievable.

In the second test case, Koxia can perform the operations as follows:

1. Choose the $ 2 $ -nd whiteboard and rewrite to $ b_1=3 $ .
2. Choose the $ 1 $ -st whiteboard and rewrite to $ b_2=4 $ .
3. Choose the $ 2 $ -nd whiteboard and rewrite to $ b_3=5 $ .

The sum is $ 4 + 5 = 9 $ . It can be proven that this is the maximum possible sum achievable.

## 样例 #1

### 输入

```
4
3 2
1 2 3
4 5
2 3
1 2
3 4 5
1 1
100
1
5 3
1 1 1 1 1
1000000000 1000000000 1000000000
```

### 输出

```
12
9
1
3000000002
```



---

---
title: "Koxia and Permutation"
layout: "post"
diff: 普及-
pid: CF1770B
tag: []
---

# Koxia and Permutation

## 题目描述

Reve has two integers $ n $ and $ k $ .

Let $ p $ be a permutation $ ^\dagger $ of length $ n $ . Let $ c $ be an array of length $ n - k + 1 $ such that $ $$$c_i = \max(p_i, \dots, p_{i+k-1}) + \min(p_i, \dots, p_{i+k-1}). $ $  Let the <span class="tex-font-style-it">cost</span> of the permutation  $ p $  be the maximum element of  $ c $ .</p><p>Koxia wants you to construct a permutation with the minimum possible cost.</p><p> $ ^\\dagger $  A permutation of length  $ n $  is an array consisting of  $ n $  distinct integers from  $ 1 $  to  $ n $  in arbitrary order. For example,  $ \[2,3,1,5,4\] $  is a permutation, but  $ \[1,2,2\] $  is not a permutation ( $ 2 $  appears twice in the array), and  $ \[1,3,4\] $  is also not a permutation ( $ n=3 $  but there is  $ 4$$$ in the array).

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 2000 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \leq k \leq n \leq 2 \cdot 10^5 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output $ n $ integers $ p_1,p_2,\dots,p_n $ , which is a permutation with minimal cost. If there is more than one permutation with minimal cost, you may output any of them.

## 说明/提示

In the first test case,

- $ c_1 = \max(p_1,p_2,p_3) + \min(p_1,p_2,p_3) = 5 + 1 = 6 $ .
- $ c_2 = \max(p_2,p_3,p_4) + \min(p_2,p_3,p_4) = 3 + 1 = 4 $ .
- $ c_3 = \max(p_3,p_4,p_5) + \min(p_3,p_4,p_5) = 4 + 2 = 6 $ .

Therefore, the cost is $ \max(6,4,6)=6 $ . It can be proven that this is the minimal cost.

## 样例 #1

### 输入

```
3
5 3
5 1
6 6
```

### 输出

```
5 1 2 3 4
1 2 3 4 5
3 2 4 1 6 5
```



---

---
title: "Hossam and Combinatorics"
layout: "post"
diff: 普及-
pid: CF1771A
tag: []
---

# Hossam and Combinatorics

## 题目描述

Hossam woke up bored, so he decided to create an interesting array with his friend Hazem.

Now, they have an array $ a $ of $ n $ positive integers, Hossam will choose a number $ a_i $ and Hazem will choose a number $ a_j $ .

Count the number of interesting pairs $ (a_i, a_j) $ that meet all the following conditions:

- $ 1 \le i, j \le n $ ;
- $ i \neq j $ ;
- The absolute difference $ |a_i - a_j| $ must be equal to the maximum absolute difference over all the pairs in the array. More formally, $ |a_i - a_j| = \max_{1 \le p, q \le n} |a_p - a_q| $ .

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ), which denotes the number of test cases. Description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 2 \le n \le 10^5 $ ).

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^5 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case print an integer — the number of interesting pairs $ (a_i, a_j) $ .

## 说明/提示

In the first example, the two ways are:

- Hossam chooses the fourth number $ 8 $ and Hazem chooses the fifth number $ 1 $ .
- Hossam chooses the fifth number $ 1 $ and Hazem chooses the fourth number $ 8 $ .

In the second example, the four ways are:

- Hossam chooses the second number $ 2 $ and Hazem chooses the sixth number $ 10 $ .
- Hossam chooses the sixth number $ 10 $ and Hazem chooses the second number $ 2 $ .
- Hossam chooses the fifth number $ 2 $ and Hazem chooses the sixth number $ 10 $ .
- Hossam chooses the sixth number $ 10 $ and Hazem chooses the fifth number $ 2 $ .

## 样例 #1

### 输入

```
2
5
6 2 3 8 1
6
7 2 8 3 2 10
```

### 输出

```
2
4
```



---

---
title: "Matrix Rotation"
layout: "post"
diff: 普及-
pid: CF1772B
tag: []
---

# Matrix Rotation

## 题目描述

You have a matrix $ 2 \times 2 $ filled with distinct integers. You want your matrix to become beautiful. The matrix is beautiful if the following two conditions are satisfied:

- in each row, the first element is smaller than the second element;
- in each column, the first element is smaller than the second element.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1772B/3883cb5d5c3c3237649026ca712db7066e7d51ae.png)You can perform the following operation on the matrix any number of times: rotate it clockwise by $ 90 $ degrees, so the top left element shifts to the top right cell, the top right element shifts to the bottom right cell, and so on:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1772B/a844c7395726cf76b3147efc79ccce4d8f167fbf.png)Determine if it is possible to make the matrix beautiful by applying zero or more operations.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

Each test case consists of two lines. Each of those lines contains two integers — the elements of the corresponding row of the matrix. In each matrix, all four elements are distinct integers from $ 1 $ to $ 100 $ .

## 输出格式

For each test case, print YES if the matrix can become beautiful, or NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).

## 样例 #1

### 输入

```
6
1 3
5 7
8 10
3 4
8 10
4 3
6 1
9 2
7 5
4 2
1 2
4 3
```

### 输出

```
YES
YES
NO
YES
YES
NO
```



---

---
title: "Different Differences"
layout: "post"
diff: 普及-
pid: CF1772C
tag: []
---

# Different Differences

## 题目描述

An array $ a $ consisting of $ k $ integers is strictly increasing if $ a_1 < a_2 < \dots < a_k $ . For example, the arrays $ [1, 3, 5] $ , $ [1, 2, 3, 4] $ , $ [3, 5, 6] $ are strictly increasing; the arrays $ [2, 2] $ , $ [3, 7, 5] $ , $ [7, 4, 3] $ , $ [1, 2, 2, 3] $ are not.

For a strictly increasing array $ a $ of $ k $ elements, let's denote the characteristic as the number of different elements in the array $ [a_2 - a_1, a_3 - a_2, \dots, a_k - a_{k-1}] $ . For example, the characteristic of the array $ [1, 3, 4, 7, 8] $ is $ 3 $ since the array $ [2, 1, 3, 1] $ contains $ 3 $ different elements: $ 2 $ , $ 1 $ and $ 3 $ .

You are given two integers $ k $ and $ n $ ( $ k \le n $ ). Construct an increasing array of $ k $ integers from $ 1 $ to $ n $ with maximum possible characteristic.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 819 $ ) — the number of test cases.

Each test case consists of one line containing two integers $ k $ and $ n $ ( $ 2 \le k \le n \le 40 $ ).

## 输出格式

For each test case, print $ k $ integers — the elements of the strictly increasing array $ a $ with the maximum possible characteristic. If there are multiple answers, print any of them.

## 样例 #1

### 输入

```
7
5 9
4 12
3 3
3 4
4 4
4 6
8 11
```

### 输出

```
1 3 4 7 8
2 4 7 12
1 2 3
1 3 4
1 2 3 4
2 4 5 6
1 2 3 5 6 7 8 11
```



---

---
title: "Gardener and the Capybaras (hard version)"
layout: "post"
diff: 普及-
pid: CF1775A2
tag: []
---

# Gardener and the Capybaras (hard version)

## 题目描述

有三个只由字符 `a,b` 构成的字符串 $a,b,c$ ，且 $a\le b,c\le b$ 或 $a\ge b,c\ge b$。 将它们拼在一起构成了一个新字符串 $s$。


现在给你 $s$，($3\le |s|\le 2\cdot 10^5$)，你要复原这三个字符串。

一共有 $T(T\le 10^4)$ 组测试数据，所有数据中字符串的总长不会超过 $4\cdot 10^5$。

## 输入格式

第一行，一个数 $T$。  
接下来的 $T$ 行，每行一个字符串，表示字符串 $s$。

## 输出格式

对于每组测试数据，输出一行三个字符串，用空格隔开，表示拆出的三个字符串。

如果有多种拆分方式，输出任意一种。

如果无法拆分，则输出 `:(`。

## 说明/提示

定义字符串 $x$ 小于 $y$ ，当且仅当：

$x$ 是 $y$ 的前缀，且 $x \not =y$ 。

或

在 $x$ 与 $y$ 的第一个不同的位置，$x$ 的这一位字符是 `a`，$y$ 的这一位字符是 `b`。

## 样例 #1

### 输入

```
5
bbba
aba
aaa
abba
abbb
```

### 输出

```
b bb a
a b a
a a a
ab b a
a bb b
```



---

---
title: "Emordnilap"
layout: "post"
diff: 普及-
pid: CF1777B
tag: []
---

# Emordnilap

## 题目描述

A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array). There are $ n! = n \cdot (n-1) \cdot (n - 2) \cdot \ldots \cdot 1 $ different permutations of length $ n $ .

Given a permutation $ p $ of $ n $ numbers, we create an array $ a $ consisting of $ 2n $ numbers, which is equal to $ p $ concatenated with its reverse. We then define the beauty of $ p $ as the number of inversions in $ a $ .

The number of inversions in the array $ a $ is the number of pairs of indices $ i $ , $ j $ such that $ i < j $ and $ a_i > a_j $ .

For example, for permutation $ p = [1, 2] $ , $ a $ would be $ [1, 2, 2, 1] $ . The inversions in $ a $ are $ (2, 4) $ and $ (3, 4) $ (assuming 1-based indexing). Hence, the beauty of $ p $ is $ 2 $ .

Your task is to find the sum of beauties of all $ n! $ permutations of size $ n $ . Print the remainder we get when dividing this value by $ 1\,000\,000\,007 $ ( $ 10^9 + 7 $ ).

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^5 $ ). The description of the test cases follows.

Each test case has only one line — the integer $ n $ ( $ 1 \leq n \leq 10^5 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, print one integer — the sum of beauties of all permutations of size $ n $ modulo $ 1\,000\,000\,007 $ ( $ 10^9 + 7 $ ).

## 说明/提示

For the first test case of the example, $ p = [1] $ is the only permutation. $ a = [1, 1] $ has $ 0 $ inversions.

For the second test case of the example, the permutations are $ [1, 2] $ and $ [2, 1] $ . Their respective $ a $ arrays are $ [1, 2, 2, 1] $ and $ [2, 1, 1, 2] $ , both of which have $ 2 $ inversions.

## 样例 #1

### 输入

```
3
1
2
100
```

### 输出

```
0
4
389456655
```



---

---
title: "Flip Flop Sum"
layout: "post"
diff: 普及-
pid: CF1778A
tag: []
---

# Flip Flop Sum

## 题目描述

You are given an array of $ n $ integers $ a_1, a_2, \ldots, a_n $ . The integers are either $ 1 $ or $ -1 $ . You have to perform the following operation exactly once on the array $ a $ :

- Choose an index $ i $ ( $ 1 \leq i < n $ ) and flip the signs of $ a_i $ and $ a_{i+1} $ . Here, flipping the sign means $ -1 $ will be $ 1 $ and $ 1 $ will be $ -1 $ .

What is the maximum possible value of $ a_1 + a_2 + \ldots + a_n $ after applying the above operation?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 500 $ ). Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^5 $ ), the length of the array $ a $ .

The next line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ a_i = 1 $ or $ a_i = -1 $ ).

The sum of $ n $ over all cases doesn't exceed $ 10^5 $ .

## 输出格式

For each test case, print the maximum possible sum of the array $ a $ you can get in a separate line.

## 说明/提示

In the first case, we can choose index $ 4 $ and flip the signs of $ a_4 $ and $ a_5 $ . After this operation, the sum will be $ -1+1+1+1+1 = 3 $ . We can't make the sum larger than this.

In the third case, the only option is to choose the index $ 1 $ .

## 样例 #1

### 输入

```
4
5
-1 1 1 -1 -1
5
1 1 -1 -1 -1
2
1 1
4
1 -1 -1 1
```

### 输出

```
3
3
-2
4
```



---

---
title: "MKnez's ConstructiveForces Task"
layout: "post"
diff: 普及-
pid: CF1779B
tag: []
---

# MKnez's ConstructiveForces Task

## 题目描述

MKnez wants to construct an array $ s_1,s_2, \ldots , s_n $ satisfying the following conditions:

- Each element is an integer number different from $ 0 $ ;
- For each pair of adjacent elements their sum is equal to the sum of the whole array.

More formally, $ s_i \neq 0 $ must hold for each $ 1 \leq i \leq n $ . Moreover, it must hold that $ s_1 + s_2 + \cdots + s_n = s_i + s_{i+1} $ for each $ 1 \leq i < n $ .

Help MKnez to construct an array with these properties or determine that it does not exist.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \leq t \leq 100 $ ). The description of the test cases follows.

The only line of each test case contains a single integer $ n $ ( $ 2 \leq n \leq 1000 $ ) — the length of the array.

## 输出格式

For each test case, print "YES" if an array of length $ n $ satisfying the conditions exists. Otherwise, print "NO". If the answer is "YES", on the next line print a sequence $ s_1,s_2, \ldots, s_n $ satisfying the conditions. Each element should be a non-zero integer in the range $ [-5000,5000] $ , i. e. $ -5000 \leq s_i \leq 5000 $ and $ s_i \neq 0 $ should hold for each $ 1 \leq i \leq n $ .

It can be proved that if a solution exists then there also exists one which satisfies the additional constraints on the range.

If there are several correct answers, print any of them.

## 说明/提示

In the first test case, $ [9,5] $ is a valid answer since $ 9+5 $ (the sum of the two adjacent elements $ s_1+s_2 $ ) is equal to $ 9+5 $ (the sum of all elements). Other solutions include $ [6,-9], [-1,-2], [-5000,5000], \ldots $

For the second test case, let us show why some arrays do not satisfy the constraints:

- $ [1,1,1] $ — $ s_1+s_2 = 1+1 = 2 $ and $ s_1+s_2+s_3=1+1+1 = 3 $ differ;
- $ [1,-1,1] $ — $ s_1+s_2=1+(-1)=0 $ and $ s_1+s_2+s_3=1+(-1)+1 = 1 $ differ;
- $ [0,0,0] $ — The array $ s $ cannot contain a $ 0 $ .

This is not a proof, but it can be shown that the answer is "NO".

## 样例 #1

### 输入

```
2
2
3
```

### 输出

```
YES
9 5
NO
```



---

---
title: "Rectangular Game"
layout: "post"
diff: 普及-
pid: CF177B1
tag: []
---

# Rectangular Game

## 题目描述

The Smart Beaver from ABBYY decided to have a day off. But doing nothing the whole day turned out to be too boring, and he decided to play a game with pebbles. Initially, the Beaver has $ n $ pebbles. He arranges them in $ a $ equal rows, each row has $ b $ pebbles ( $ a>1 $ ). Note that the Beaver must use all the pebbles he has, i. e. $ n=a·b $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF177B1/72b3400d0a6aa691e5c49fe273a750815ff16b58.png) 10 pebbles are arranged in two rows, each row has 5 pebbles Once the Smart Beaver has arranged the pebbles, he takes back any of the resulting rows (that is, $ b $ pebbles) and discards all other pebbles. Then he arranges all his pebbles again (possibly choosing other values of $ a $ and $ b $ ) and takes back one row, and so on. The game continues until at some point the Beaver ends up with exactly one pebble.

The game process can be represented as a finite sequence of integers $ c_{1},...,c_{k} $ , where:

- $ c_{1}=n $
- $ c_{i+1} $ is the number of pebbles that the Beaver ends up with after the $ i $ -th move, that is, the number of pebbles in a row after some arrangement of $ c_{i} $ pebbles ( $ 1<=i<k $ ). Note that $ c_{i}>c_{i+1} $ .
- $ c_{k}=1 $

The result of the game is the sum of numbers $ c_{i} $ . You are given $ n $ . Find the maximum possible result of the game.

## 输入格式

The single line of the input contains a single integer $ n $ — the initial number of pebbles the Smart Beaver has.

The input limitations for getting 30 points are:

- $ 2<=n<=50 $

The input limitations for getting 100 points are:

- $ 2<=n<=10^{9} $

## 输出格式

Print a single number — the maximum possible result of the game.

## 说明/提示

Consider the first example ( $ c_{1}=10 $ ). The possible options for the game development are:

- Arrange the pebbles in 10 rows, one pebble per row. Then $ c_{2}=1 $ , and the game ends after the first move with the result of 11.
- Arrange the pebbles in 5 rows, two pebbles per row. Then $ c_{2}=2 $ , and the game continues. During the second move we have two pebbles which can be arranged in a unique way (remember that you are not allowed to put all the pebbles in the same row!) — 2 rows, one pebble per row. $ c_{3}=1 $ , and the game ends with the result of 13.
- Finally, arrange the pebbles in two rows, five pebbles per row. The same logic leads us to $ c_{2}=5,c_{3}=1 $ , and the game ends with the result of 16 — the maximum possible result.

## 样例 #1

### 输入

```
10

```

### 输出

```
16

```

## 样例 #2

### 输入

```
8

```

### 输出

```
15

```



---

---
title: "Going to the Cinema"
layout: "post"
diff: 普及-
pid: CF1781B
tag: []
---

# Going to the Cinema

## 题目描述

A company of $ n $ people is planning a visit to the cinema. Every person can either go to the cinema or not. That depends on how many other people will go. Specifically, every person $ i $ said: "I want to go to the cinema if and only if at least $ a_i $ other people will go, not counting myself". That means that person $ i $ will become sad if:

- they go to the cinema, and strictly less than $ a_i $ other people go; or
- they don't go to the cinema, and at least $ a_i $ other people go.

In how many ways can a set of people going to the cinema be chosen so that nobody becomes sad?

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

Each test case consists of two lines. The first line contains a single integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ) — the number of people in the company.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le n - 1 $ ) — integers from peoples' claims.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print a single integer — the number of different ways to choose a set of people going to the cinema so that nobody becomes sad.

## 说明/提示

In the first test case, both people want to go to the cinema if and only if the other person goes. There are two valid options: either both people go, or neither of them goes. However, if just one of them goes, both will be sad.

In the second test case, everyone has to go to the cinema. In any other case, someone will be sad.

In the third test case, there are three valid options: person number $ 2 $ goes to the cinema; or persons with indices $ 2, 3, 4, 7 $ go; or all eight people go.

## 样例 #1

### 输入

```
4
2
1 1
7
0 1 2 3 4 5 6
8
6 0 3 3 6 7 2 7
5
3 0 0 3 3
```

### 输出

```
2
1
3
2
```



---

---
title: "Make it Beautiful"
layout: "post"
diff: 普及-
pid: CF1783A
tag: []
---

# Make it Beautiful

## 题目描述

如果一个数组中存在一个数恰好等于该数前面所有数之和，那么这个数组就是丑的。如果一个数组不是丑的，就是美的。

比如说：

- 数组 $ [6, 3, 9, 6] $ 是丑的，因为 $9 = 6 + 3$ ；
- 数组 $ [5, 5, 7] $ 是丑的，因为第二个 $5 = 5$ 。
- 数组 $ [8, 4, 10, 14] $ 是美的，因为 $ 8 \ne 0 $ , $ 4 \ne 8 $ , $ 10 \ne 8 + 4 $ , $ 14 \ne 8 + 4 + 10 $ ，没有任何一个数等于它前面的数之和。

给定数组 $a$ 满足 $ 1 \le a_1 \le a_2 \le \dots \le a_n \le 100 $ 。 你可以任意调整元素的顺序，也可以不调整，使它变成一个美的数组。

## 输入格式

第一行一个整数 $ t $ ( $ 1 \le t \le 2000 $ ) ，表示测试点数量。

每个测试点有两行的输入。第一行一个整数 $ n $ ( $ 2 \le n \le 50 $ )。 第二行有 $ n $ 个数 $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_1 \le a_2 \le \dots \le a_n \le 100 $ )。

## 输出格式

对于每一个测试点，按如下方式输出：

- 如果没办法使数组变成美的，输出 ``NO`` 。
- 否则在第一行输出一个 ``YES`` ，第二行输出调整完后的数组。如果有多个答案，输出任意一个。

### 样例 #1

#### 样例输入 #1

```
4
4
3 3 6 6
2
10 10
5
1 2 3 4 5
3
1 4 4
```

#### 样例输出 #1

```
YES
3 6 3 6
NO
YES
2 4 1 5 3
YES
1 4 4
```

## 样例 #1

### 输入

```
4
4
3 3 6 6
2
10 10
5
1 2 3 4 5
3
1 4 4
```

### 输出

```
YES
3 6 3 6
NO
YES
2 4 1 5 3
YES
1 4 4
```



---

---
title: "Matrix of Differences"
layout: "post"
diff: 普及-
pid: CF1783B
tag: []
---

# Matrix of Differences

## 题目描述

For a square matrix of integers of size $ n \times n $ , let's define its beauty as follows: for each pair of side-adjacent elements $ x $ and $ y $ , write out the number $ |x-y| $ , and then find the number of different numbers among them.

For example, for the matrix $ \begin{pmatrix} 1 & 3\\ 4 & 2 \end{pmatrix} $ the numbers we consider are $ |1-3|=2 $ , $ |1-4|=3 $ , $ |3-2|=1 $ and $ |4-2|=2 $ ; there are $ 3 $ different numbers among them ( $ 2 $ , $ 3 $ and $ 1 $ ), which means that its beauty is equal to $ 3 $ .

You are given an integer $ n $ . You have to find a matrix of size $ n \times n $ , where each integer from $ 1 $ to $ n^2 $ occurs exactly once, such that its beauty is the maximum possible among all such matrices.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 49 $ ) – the number of test cases.

The first (and only) line of each test case contains a single integer $ n $ ( $ 2 \le n \le 50 $ ).

## 输出格式

For each test case, print $ n $ rows of $ n $ integers — a matrix of integers of size $ n \times n $ , where each number from $ 1 $ to $ n^2 $ occurs exactly once, such that its beauty is the maximum possible among all such matrices. If there are multiple answers, print any of them.

## 样例 #1

### 输入

```
2
2
3
```

### 输出

```
1 3
4 2
1 3 4
9 2 7
5 8 6
```



---

---
title: "Cake Assembly Line"
layout: "post"
diff: 普及-
pid: CF1786B
tag: []
---

# Cake Assembly Line

## 题目描述

A cake assembly line in a bakery was once again optimized, and now $ n $ cakes are made at a time! In the last step, each of the $ n $ cakes should be covered with chocolate.

Consider a side view on the conveyor belt, let it be a number line. The $ i $ -th cake occupies the segment $ [a_i - w, a_i + w] $ on this line, each pair of these segments does not have common points. Above the conveyor, there are $ n $ dispensers, and when a common button is pressed, chocolate from the $ i $ -th dispenser will cover the conveyor segment $ [b_i - h, b_i + h] $ . Each pair of these segments also does not have common points.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1786B/346ba483d975827d12cf4a1c8655bc16066dc283.png) Cakes and dispensers corresponding to the first example.The calibration of this conveyor belt part has not yet been performed, so you are to make it. Determine if it's possible to shift the conveyor so that each cake has some chocolate on it, and there is no chocolate outside the cakes. You can assume that the conveyour is long enough, so the cakes never fall. Also note that the button can only be pressed once.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1786B/9d91448781ebe899dcbaa2a5c7ae76c17064ee03.png) In the first example we can shift the cakes as shown in the picture.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^5 $ ). The description of the test cases follows.

The first line of each test case contains three integers $ n $ , $ w $ , and $ h $ ( $ 1 \le n \le 10^5 $ ; $ 1 \le w, h \le 10^5 $ ; $ h \le w $ ) — the number of cakes and dispensers, as well as the halfwidths of cakes and segments on which the chocolate is dispensed.

The second line contains $ n $ integers $ a_1 $ , $ a_2 $ , ..., $ a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the positions of the cakes centers. It is guaranteed that $ a_i + w < a_{i + 1} - w $ for all $ i $ .

The third line contains $ n $ integers $ b_1 $ , $ b_2 $ , ..., $ b_n $ ( $ 1 \le b_i \le 10^9 $ ) — the positions of the dispensers. It is guaranteed that $ b_i + h < b_{i + 1} - h $ for all $ i $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case output "YES", if it's possible to shift the conveyor in such a way that each cake ends up with some chocolate, and no chocolate is outside the cakes, and "NO" otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

The first example is shown in the figures in the statement.

In the second example, we can move the conveyor, for example, so that the centers of the cakes are at $ 4, 9, 14, 19, 24 $ .

In the third example, we can't move the conveyor accordingly.

## 样例 #1

### 输入

```
4
3 10 5
65 95 165
40 65 145
5 2 1
1 6 11 16 21
4 9 14 19 24
3 3 2
13 22 29
5 16 25
4 4 1
27 36 127 136
35 50 141 144
```

### 输出

```
YES
YES
NO
YES
```



---

---
title: "Number Factorization"
layout: "post"
diff: 普及-
pid: CF1787B
tag: []
---

# Number Factorization

## 题目描述

Given an integer $ n $ .

Consider all pairs of integer arrays $ a $ and $ p $ of the same length such that $ n = \prod a_i^{p_i} $ (i.e. $ a_1^{p_1}\cdot a_2^{p_2}\cdot\ldots $ ) ( $ a_i>1;p_i>0 $ ) and $ a_i $ is the product of some (possibly one) distinct prime numbers.

For example, for $ n = 28 = 2^2\cdot 7^1 = 4^1 \cdot 7^1 $ the array pair $ a = [2, 7] $ , $ p = [2, 1] $ is correct, but the pair of arrays $ a = [4, 7] $ , $ p = [1, 1] $ is not, because $ 4=2^2 $ is a product of non-distinct prime numbers.

Your task is to find the maximum value of $ \sum a_i \cdot p_i $ (i.e. $ a_1\cdot p_1 + a_2\cdot p_2 + \ldots $ ) over all possible pairs of arrays $ a $ and $ p $ . Note that you do not need to minimize or maximize the length of the arrays.

## 输入格式

Each test contains multiple test cases. The first line contains an integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

Each test case contains only one integer $ n $ ( $ 2 \le n \le 10^9 $ ).

## 输出格式

For each test case, print the maximum value of $ \sum a_i \cdot p_i $ .

## 说明/提示

In the first test case, $ 100 = 10^2 $ so that $ a = [10] $ , $ p = [2] $ when $ \sum a_i \cdot p_i $ hits the maximum value $ 10\cdot 2 = 20 $ . Also, $ a = [100] $ , $ p = [1] $ does not work since $ 100 $ is not made of distinct prime factors.

In the second test case, we can consider $ 10 $ as $ 10^1 $ , so $ a = [10] $ , $ p = [1] $ . Notice that when $ 10 = 2^1\cdot 5^1 $ , $ \sum a_i \cdot p_i = 7 $ .

## 样例 #1

### 输入

```
7
100
10
864
130056192
1000000000
2
999999018
```

### 输出

```
20
10
22
118
90
2
333333009
```



---

---
title: "One and Two"
layout: "post"
diff: 普及-
pid: CF1788A
tag: []
---

# One and Two

## 题目描述

# One and Two


给你一个数列 $ a_1, a_2, \ldots, a_n $ . 数列中的每一个数的值要么是 $ 1 $ 要么是 $ 2 $ .
找到一个最小的正整数 $ k $，使之满足：
- $ 1 \leq k \leq n-1 $ , and
- $ a_1 \cdot a_2 \cdot \ldots \cdot a_k = a_{k+1} \cdot a_{k+2} \cdot \ldots \cdot a_n $ .

## 输入格式

第一行输入一个 $ t $，表示测试用例数目。
每个测试用例的第一行输入一个 $ n $ ( $ 2 \leq n \leq 1000 $ ).
后面一行输入 $ n $ 个整数$ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 2 $ ).

## 输出格式

找不到 $k$ 输出 $ -1 $.
否则输出满足条件的 $k$ 的最小值。

## 样例 #1

### 样例输入 #1

```
3
6
2 2 1 2 1 2
3
1 2 1
4
1 1 1 1
```

### 样例输出 #1

```
2
-1
1
```

## 说明/提示

就是找一个最小的整数 $k$,使满足 $k$ 及其前面的乘积和其之后的乘积相等。

## 样例 #1

### 输入

```
3
6
2 2 1 2 1 2
3
1 2 1
4
1 1 1 1
```

### 输出

```
2
-1
1
```



---

---
title: "Sum of Two Numbers"
layout: "post"
diff: 普及-
pid: CF1788B
tag: []
---

# Sum of Two Numbers

## 题目描述

The sum of digits of a non-negative integer $ a $ is the result of summing up its digits together when written in the decimal system. For example, the sum of digits of $ 123 $ is $ 6 $ and the sum of digits of $ 10 $ is $ 1 $ . In a formal way, the sum of digits of $ \displaystyle a=\sum_{i=0}^{\infty} a_i \cdot 10^i $ , where $ 0 \leq a_i \leq 9 $ , is defined as $ \displaystyle\sum_{i=0}^{\infty}{a_i} $ .

Given an integer $ n $ , find two non-negative integers $ x $ and $ y $ which satisfy the following conditions.

- $ x+y=n $ , and
- the sum of digits of $ x $ and the sum of digits of $ y $ differ by at most $ 1 $ .

It can be shown that such $ x $ and $ y $ always exist.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10\,000 $ ).

Each test case consists of a single integer $ n $ ( $ 1 \leq n \leq 10^9 $ )

## 输出格式

For each test case, print two integers $ x $ and $ y $ .

If there are multiple answers, print any.

## 说明/提示

In the second test case, the sum of digits of $ 67 $ and the sum of digits of $ 94 $ are both $ 13 $ .

In the third test case, the sum of digits of $ 60 $ is $ 6 $ , and the sum of digits of $ 7 $ is $ 7 $ .

## 样例 #1

### 输入

```
5
1
161
67
1206
19
```

### 输出

```
1 0
67 94
60 7
1138 68
14 5
```



---

---
title: "Serval and Mocha's Array"
layout: "post"
diff: 普及-
pid: CF1789A
tag: []
---

# Serval and Mocha's Array

## 题目描述

Mocha likes arrays, and Serval gave her an array consisting of positive integers as a gift.

Mocha thinks that for an array of positive integers $ a $ , it is good iff the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of all the elements in $ a $ is no more than its length. And for an array of at least $ 2 $ positive integers, it is beautiful iff all of its prefixes whose length is no less than $ 2 $ are good.

For example:

- $ [3,6] $ is not good, because $ \gcd(3,6)=3 $ is greater than its length $ 2 $ .
- $ [1,2,4] $ is both good and beautiful, because all of its prefixes whose length is no less than $ 2 $ , which are $ [1,2] $ and $ [1,2,4] $ , are both good.
- $ [3,6,1] $ is good but not beautiful, because $ [3,6] $ is not good.

Now Mocha gives you the gift array $ a $ of $ n $ positive integers, and she wants to know whether array $ a $ could become beautiful by reordering the elements in $ a $ . It is allowed to keep the array $ a $ unchanged.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1\leq t\leq 500 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2\leq n\leq 100 $ ) — the length of array $ a $ .

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\leq a_1,a_2,\ldots,a_n\leq 10^6 $ ) — the elements of array $ a $ .

## 输出格式

For each test case, print Yes if it is possible to reorder the elements in $ a $ to make it beautiful, and print No if not.

You can output Yes and No in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

## 说明/提示

In the first test case, neither $ [3,6] $ nor $ [6,3] $ are beautiful, so it's impossible to obtain a beautiful array by reordering the elements in $ a $ .

In the second test case, $ [1,2,4] $ is already beautiful. Keeping the array $ a $ unchanged can obtain a beautiful array.

## 样例 #1

### 输入

```
6
2
3 6
3
1 2 4
3
3 6 1
3
15 35 21
4
35 10 35 14
5
1261 227821 143 4171 1941
```

### 输出

```
No
Yes
Yes
No
Yes
Yes
```



---

---
title: "Serval and Inversion Magic"
layout: "post"
diff: 普及-
pid: CF1789B
tag: []
---

# Serval and Inversion Magic

## 题目描述

Serval has a string $ s $ that only consists of 0 and 1 of length $ n $ . The $ i $ -th character of $ s $ is denoted as $ s_i $ , where $ 1\leq i\leq n $ .

Serval can perform the following operation called Inversion Magic on the string $ s $ :

- Choose an segment $ [l, r] $ ( $ 1\leq l\leq r\leq n $ ). For $ l\leq i\leq r $ , change $ s_i $ into 1 if $ s_i $ is 0, and change $ s_i $ into 0 if $ s_i $ is 1.

For example, let $ s $ be 010100 and the segment $ [2,5] $ is chosen. The string $ s $ will be 001010 after performing the Inversion Magic.

Serval wants to make $ s $ a palindrome after performing Inversion Magic exactly once. Help him to determine whether it is possible.

A string is a palindrome iff it reads the same backwards as forwards. For example, 010010 is a palindrome but 10111 is not.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1\leq t\leq 10^4 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2\leq n\leq 10^5 $ ) — the length of string $ s $ .

The second line of each test case contains a binary string $ s $ of length $ n $ . Only characters 0 and 1 can appear in $ s $ .

It's guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, print Yes if $ s $ can be a palindrome after performing Inversion Magic exactly once, and print No if not.

You can output Yes and No in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

## 说明/提示

In the first test case, Serval can perform Inversion Magic on the segment $ [1,4] $ . The string $ s $ will be 0110 after the magic.

In the second test case, Serval can perform Inversion Magic on the segment $ [1,3] $ . The string $ s $ will be 01110 after the magic.

In the third test case, Serval can't make $ s $ a palindrome by performing Inversion Magic exactly once.

## 样例 #1

### 输入

```
3
4
1001
5
10010
7
0111011
```

### 输出

```
Yes
Yes
No
```



---

---
title: "Educational Game"
layout: "post"
diff: 普及-
pid: CF178A1
tag: []
---

# Educational Game

## 题目描述

The Smart Beaver from ABBYY began to develop a new educational game for children. The rules of the game are fairly simple and are described below.

The playing field is a sequence of $ n $ non-negative integers $ a_{i} $ numbered from $ 1 $ to $ n $ . The goal of the game is to make numbers $ a_{1},a_{2},...,a_{k} $ (i.e. some prefix of the sequence) equal to zero for some fixed $ k $ $ (k<n) $ , and this should be done in the smallest possible number of moves.

One move is choosing an integer $ i $ ( $ 1<=i<=n $ ) such that $ a_{i}>0 $ and an integer $ t $ $ (t>=0) $ such that $ i+2^{t}<=n $ . After the values of $ i $ and $ t $ have been selected, the value of $ a_{i} $ is decreased by $ 1 $ , and the value of $ a_{i+2^{t}} $ is increased by $ 1 $ . For example, let $ n=4 $ and $ a=(1,0,1,2) $ , then it is possible to make move $ i=3 $ , $ t=0 $ and get $ a=(1,0,0,3) $ or to make move $ i=1 $ , $ t=1 $ and get $ a=(0,0,2,2) $ (the only possible other move is $ i=1 $ , $ t=0 $ ).

You are given $ n $ and the initial sequence $ a_{i} $ . The task is to calculate the minimum number of moves needed to make the first $ k $ elements of the original sequence equal to zero for each possible $ k $ $ (1<=k<n) $ .

## 输入格式

The first input line contains a single integer $ n $ . The second line contains $ n $ integers $ a_{i} $ ( $ 0<=a_{i}<=10^{4} $ ), separated by single spaces.

The input limitations for getting 20 points are:

- $ 1<=n<=300 $

The input limitations for getting 50 points are:

- $ 1<=n<=2000 $

The input limitations for getting 100 points are:

- $ 1<=n<=10^{5} $

## 输出格式

Print exactly $ n-1 $ lines: the $ k $ -th output line must contain the minimum number of moves needed to make the first $ k $ elements of the original sequence $ a_{i} $ equal to zero.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams, or the %I64d specifier.

## 样例 #1

### 输入

```
4
1 0 1 2

```

### 输出

```
1
1
3

```

## 样例 #2

### 输入

```
8
1 2 3 4 5 6 7 8

```

### 输出

```
1
3
6
10
16
24
40

```



---

---
title: "Educational Game"
layout: "post"
diff: 普及-
pid: CF178A2
tag: []
---

# Educational Game

## 题目描述

The Smart Beaver from ABBYY began to develop a new educational game for children. The rules of the game are fairly simple and are described below.

The playing field is a sequence of $ n $ non-negative integers $ a_{i} $ numbered from $ 1 $ to $ n $ . The goal of the game is to make numbers $ a_{1},a_{2},...,a_{k} $ (i.e. some prefix of the sequence) equal to zero for some fixed $ k $ $ (k<n) $ , and this should be done in the smallest possible number of moves.

One move is choosing an integer $ i $ ( $ 1<=i<=n $ ) such that $ a_{i}>0 $ and an integer $ t $ $ (t>=0) $ such that $ i+2^{t}<=n $ . After the values of $ i $ and $ t $ have been selected, the value of $ a_{i} $ is decreased by $ 1 $ , and the value of $ a_{i+2^{t}} $ is increased by $ 1 $ . For example, let $ n=4 $ and $ a=(1,0,1,2) $ , then it is possible to make move $ i=3 $ , $ t=0 $ and get $ a=(1,0,0,3) $ or to make move $ i=1 $ , $ t=1 $ and get $ a=(0,0,2,2) $ (the only possible other move is $ i=1 $ , $ t=0 $ ).

You are given $ n $ and the initial sequence $ a_{i} $ . The task is to calculate the minimum number of moves needed to make the first $ k $ elements of the original sequence equal to zero for each possible $ k $ $ (1<=k<n) $ .

## 输入格式

The first input line contains a single integer $ n $ . The second line contains $ n $ integers $ a_{i} $ ( $ 0<=a_{i}<=10^{4} $ ), separated by single spaces.

The input limitations for getting 20 points are:

- $ 1<=n<=300 $

The input limitations for getting 50 points are:

- $ 1<=n<=2000 $

The input limitations for getting 100 points are:

- $ 1<=n<=10^{5} $

## 输出格式

Print exactly $ n-1 $ lines: the $ k $ -th output line must contain the minimum number of moves needed to make the first $ k $ elements of the original sequence $ a_{i} $ equal to zero.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams, or the %I64d specifier.

## 样例 #1

### 输入

```
4
1 0 1 2

```

### 输出

```
1
1
3

```

## 样例 #2

### 输入

```
8
1 2 3 4 5 6 7 8

```

### 输出

```
1
3
6
10
16
24
40

```



---

---
title: "Educational Game"
layout: "post"
diff: 普及-
pid: CF178A3
tag: []
---

# Educational Game

## 题目描述

The Smart Beaver from ABBYY began to develop a new educational game for children. The rules of the game are fairly simple and are described below.

The playing field is a sequence of $ n $ non-negative integers $ a_{i} $ numbered from $ 1 $ to $ n $ . The goal of the game is to make numbers $ a_{1},a_{2},...,a_{k} $ (i.e. some prefix of the sequence) equal to zero for some fixed $ k $ $ (k<n) $ , and this should be done in the smallest possible number of moves.

One move is choosing an integer $ i $ ( $ 1<=i<=n $ ) such that $ a_{i}>0 $ and an integer $ t $ $ (t>=0) $ such that $ i+2^{t}<=n $ . After the values of $ i $ and $ t $ have been selected, the value of $ a_{i} $ is decreased by $ 1 $ , and the value of $ a_{i+2^{t}} $ is increased by $ 1 $ . For example, let $ n=4 $ and $ a=(1,0,1,2) $ , then it is possible to make move $ i=3 $ , $ t=0 $ and get $ a=(1,0,0,3) $ or to make move $ i=1 $ , $ t=1 $ and get $ a=(0,0,2,2) $ (the only possible other move is $ i=1 $ , $ t=0 $ ).

You are given $ n $ and the initial sequence $ a_{i} $ . The task is to calculate the minimum number of moves needed to make the first $ k $ elements of the original sequence equal to zero for each possible $ k $ $ (1<=k<n) $ .

## 输入格式

The first input line contains a single integer $ n $ . The second line contains $ n $ integers $ a_{i} $ ( $ 0<=a_{i}<=10^{4} $ ), separated by single spaces.

The input limitations for getting 20 points are:

- $ 1<=n<=300 $

The input limitations for getting 50 points are:

- $ 1<=n<=2000 $

The input limitations for getting 100 points are:

- $ 1<=n<=10^{5} $

## 输出格式

Print exactly $ n-1 $ lines: the $ k $ -th output line must contain the minimum number of moves needed to make the first $ k $ elements of the original sequence $ a_{i} $ equal to zero.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams, or the %I64d specifier.

## 样例 #1

### 输入

```
4
1 0 1 2

```

### 输出

```
1
1
3

```

## 样例 #2

### 输入

```
8
1 2 3 4 5 6 7 8

```

### 输出

```
1
3
6
10
16
24
40

```



---

---
title: "Taisia and Dice"
layout: "post"
diff: 普及-
pid: CF1790B
tag: []
---

# Taisia and Dice

## 题目描述

Taisia has $ n $ six-sided dice. Each face of the die is marked with a number from $ 1 $ to $ 6 $ , each number from $ 1 $ to $ 6 $ is used once.

Taisia rolls all $ n $ dice at the same time and gets a sequence of values $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 6 $ ), where $ a_i $ is the value on the upper face of the $ i $ -th dice. The sum of this sequence is equal to $ s $ .

Suddenly, Taisia's pet cat steals exactly one dice with maximum value $ a_i $ and calculates the sum of the values on the remaining $ n-1 $ dice, which is equal to $ r $ .

You only know the number of dice $ n $ and the values of $ s $ , $ r $ . Restore a possible sequence $ a $ that fulfills the constraints.

## 输入格式

The first line contains the integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of testcases.

Each testcase is given on a separate line and contains three integers $ n $ , $ s $ , $ r $ ( $ 2 \le n \le 50 $ , $ 1 \le r < s \le 300 $ ).

It is guaranteed that a solution exists.

## 输出格式

For each testcase, print: $ n $ integers $ a_1, a_2, \ldots, a_n $ in any order. It is guaranteed that such sequence exists.

If there are multiple solutions, print any.

## 样例 #1

### 输入

```
7
2 2 1
2 4 2
4 9 5
5 17 11
3 15 10
4 4 3
5 20 15
```

### 输出

```
1 1
2 2 
1 2 2 4
6 4 2 3 2
5 5 5
1 1 1 1
1 4 5 5 5
```



---

---
title: "Premutation"
layout: "post"
diff: 普及-
pid: CF1790C
tag: []
---

# Premutation

## 题目描述

A sequence of $ n $ numbers is called permutation if it contains all integers from $ 1 $ to $ n $ exactly once. For example, the sequences \[ $ 3, 1, 4, 2 $ \], \[ $ 1 $ \] and \[ $ 2,1 $ \] are permutations, but \[ $ 1,2,1 $ \], \[ $ 0,1 $ \] and \[ $ 1,3,4 $ \] — are not.

Kristina had a permutation $ p $ of $ n $ elements. She wrote it on the whiteboard $ n $ times in such a way that:

- while writing the permutation at the $ i $ -th ( $ 1 \le i \le n) $ time she skipped the element $ p_i $

 So, she wrote in total $ n $ sequences of length $ n-1 $ each.For example, suppose Kristina had a permutation $ p $ = $ [4,2,1,3] $ of length $ 4 $ . Then she did the following:

1. Wrote the sequence $ [2, 1, 3] $ , skipping the element $ p_1=4 $ from the original permutation.
2. Wrote the sequence $ [4, 1, 3] $ , skipping the element $ p_2=2 $ from the original permutation.
3. Wrote the sequence $ [4, 2, 3] $ , skipping the element $ p_3=1 $ from the original permutation.
4. Wrote the sequence $ [4, 2, 1] $ , skipping the element $ p_4=3 $ from the original permutation.

You know all $ n $ of sequences that have been written on the whiteboard, but you do not know the order in which they were written. They are given in arbitrary order. Reconstruct the original permutation from them.

For example, if you know the sequences $ [4, 2, 1] $ , $ [4, 2, 3] $ , $ [2, 1, 3] $ , $ [4, 1, 3] $ , then the original permutation will be $ p $ = $ [4, 2, 1, 3] $ .

## 输入格式

The first line of input data contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The description of the test cases follows.

The first line of each test case contains one integer $ n $ ( $ 3 \le n \le 100 $ ).

This is followed by $ n $ lines, each containing exactly $ n-1 $ integers and describing one of the sequences written out on the whiteboard.

It is guaranteed that all sequences could be obtained from some permutation $ p $ , and that the sum $ n^2 $ over all input sets does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output on a separate line a permutation $ p $ such that the given $ n $ sequences could be obtained from it.

It is guaranteed that the answer exists and it is the only one. In other words, for each test case the required permutation is sure to exist.

## 说明/提示

The first test case is described in the problem statement.

In the second test case, the sequences are written in the correct order.

## 样例 #1

### 输入

```
5
4
4 2 1
4 2 3
2 1 3
4 1 3
3
2 3
1 3
1 2
5
4 2 1 3
2 1 3 5
4 2 3 5
4 1 3 5
4 2 1 5
4
2 3 4
1 3 4
1 2 3
1 2 4
3
2 1
1 3
2 3
```

### 输出

```
4 2 1 3 
1 2 3 
4 2 1 3 5 
1 2 3 4 
2 1 3
```



---

---
title: "Distinct Split"
layout: "post"
diff: 普及-
pid: CF1791D
tag: []
---

# Distinct Split

## 题目描述

Let's denote the $ f(x) $ function for a string $ x $ as the number of distinct characters that the string contains. For example $ f(\texttt{abc}) = 3 $ , $ f(\texttt{bbbbb}) = 1 $ , and $ f(\texttt{babacaba}) = 3 $ .

Given a string $ s $ , split it into two non-empty strings $ a $ and $ b $ such that $ f(a) + f(b) $ is the maximum possible. In other words, find the maximum possible value of $ f(a) + f(b) $ such that $ a + b = s $ (the concatenation of string $ a $ and string $ b $ is equal to string $ s $ ).

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 2 \leq n \leq 2\cdot10^5 $ ) — the length of the string $ s $ .

The second line contains the string $ s $ , consisting of lowercase English letters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, output a single integer — the maximum possible value of $ f(a) + f(b) $ such that $ a + b = s $ .

## 说明/提示

For the first test case, there is only one valid way to split $ \texttt{aa} $ into two non-empty strings $ \texttt{a} $ and $ \texttt{a} $ , and $ f(\texttt{a}) + f(\texttt{a}) = 1 + 1 = 2 $ .

For the second test case, by splitting $ \texttt{abcabcd} $ into $ \texttt{abc} $ and $ \texttt{abcd} $ we can get the answer of $ f(\texttt{abc}) + f(\texttt{abcd}) = 3 + 4 = 7 $ which is maximum possible.

For the third test case, it doesn't matter how we split the string, the answer will always be $ 2 $ .

## 样例 #1

### 输入

```
5
2
aa
7
abcabcd
5
aaaaa
10
paiumoment
4
aazz
```

### 输出

```
2
7
2
10
3
```



---

---
title: "Negatives and Positives"
layout: "post"
diff: 普及-
pid: CF1791E
tag: []
---

# Negatives and Positives

## 题目描述

Given an array $ a $ consisting of $ n $ elements, find the maximum possible sum the array can have after performing the following operation any number of times:

- Choose $ 2 $ adjacent elements and flip both of their signs. In other words choose an index $ i $ such that $ 1 \leq i \leq n - 1 $ and assign $ a_i = -a_i $ and $ a_{i+1} = -a_{i+1} $ .

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains an integer $ n $ ( $ 2 \leq n \leq 2\cdot10^5 $ ) — the length of the array.

The following line contains $ n $ space-separated integers $ a_1,a_2,\dots,a_n $ ( $ -10^9 \leq a_i \leq 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, output the maximum possible sum the array can have after performing the described operation any number of times.

## 说明/提示

For the first test case, by performing the operation on the first two elements, we can change the array from $ [-1, -1, -1] $ to $ [1, 1, -1] $ , and it can be proven this array obtains the maximum possible sum which is $ 1 + 1 + (-1) = 1 $ .

For the second test case, by performing the operation on $ -5 $ and $ 0 $ , we change the array from $ [1, 5, -5, 0, 2] $ to $ [1, 5, -(-5), -0, 2] = [1, 5, 5, 0, 2] $ , which has the maximum sum since all elements are non-negative. So, the answer is $ 1 + 5 + 5 + 0 + 2 = 13 $ .

For the third test case, the array already contains only positive numbers, so performing operations is unnecessary. The answer is just the sum of the whole array, which is $ 1 + 2 + 3 = 6 $ .

## 样例 #1

### 输入

```
5
3
-1 -1 -1
5
1 5 -5 0 2
3
1 2 3
6
-1 10 9 8 7 6
2
-1 -1
```

### 输出

```
1
13
6
39
2
```



---

---
title: "Teleporters (Easy Version)"
layout: "post"
diff: 普及-
pid: CF1791G1
tag: []
---

# Teleporters (Easy Version)

## 题目描述

The only difference between the easy and hard versions are the locations you can teleport to.

Consider the points $ 0, 1, \dots, n $ on the number line. There is a teleporter located on each of the points $ 1, 2, \dots, n $ . At point $ i $ , you can do the following:

- Move left one unit: it costs $ 1 $ coin.
- Move right one unit: it costs $ 1 $ coin.
- Use a teleporter at point $ i $ , if it exists: it costs $ a_i $ coins. As a result, you teleport to point $ 0 $ . Once you use a teleporter, you can't use it again.

You have $ c $ coins, and you start at point $ 0 $ . What's the most number of teleporters you can use?

## 输入格式

The input consists of multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains two integers $ n $ and $ c $ ( $ 1 \leq n \leq 2\cdot10^5 $ ; $ 1 \leq c \leq 10^9 $ ) — the length of the array and the number of coins you have respectively.

The following line contains $ n $ space-separated integers $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the costs to use the teleporters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, output the maximum number of teleporters you can use.

## 说明/提示

In the first test case, you can move one unit to the right, use the teleporter at index $ 1 $ and teleport to point $ 0 $ , move two units to the right and use the teleporter at index $ 2 $ . You are left with $ 6-1-1-2-1 = 1 $ coins you don't have enough coins to use another teleporter. You have used two teleporters, so the answer is two.

In the second test case, you go four units to the right and use the teleporter to go to $ 0 $ , then go six units right and use the teleporter at index $ 6 $ to go to $ 0 $ . The total cost will be $ 4+6+6+4 = 20 $ . You are left with $ 12 $ coins, but it is not enough to reach any other teleporter and use it so the answer is $ 2 $ .

In the third test case, you don't have enough coins to use any teleporter, so the answer is zero.

## 样例 #1

### 输入

```
10
5 6
1 1 1 1 1
8 32
100 52 13 6 9 4 100 35
1 1
5
4 5
4 3 2 1
5 9
2 3 1 4 1
5 8
2 3 1 4 1
4 3
2 3 4 1
4 9
5 4 3 3
2 14
7 5
5 600000000
500000000 400000000 300000000 200000000 100000000
```

### 输出

```
2
2
0
1
2
2
1
1
1
2
```



---

---
title: "GamingForces"
layout: "post"
diff: 普及-
pid: CF1792A
tag: []
---

# GamingForces

## 题目描述

Monocarp is playing a computer game. He's going to kill $ n $ monsters, the $ i $ -th of them has $ h_i $ health.

Monocarp's character has two spells, either of which he can cast an arbitrary number of times (possibly, zero) and in an arbitrary order:

- choose exactly two alive monsters and decrease their health by $ 1 $ ;
- choose a single monster and kill it.

When a monster's health becomes $ 0 $ , it dies.

What's the minimum number of spell casts Monocarp should perform in order to kill all monsters?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of monsters.

The second line contains $ n $ integers $ h_1, h_2, \dots, h_n $ ( $ 1 \le h_i \le 100 $ ) — the health of each monster.

The sum of $ n $ over all testcases doesn't exceed $ 2 \cdot 10^4 $ .

## 输出格式

For each testcase, print a single integer — the minimum number of spell casts Monocarp should perform in order to kill all monsters.

## 说明/提示

In the first testcase, the initial health list is $ [1, 2, 1, 2] $ . Three spells are casted:

- the first spell on monsters $ 1 $ and $ 2 $ — monster $ 1 $ dies, monster $ 2 $ has now health $ 1 $ , new health list is $ [0, 1, 1, 2] $ ;
- the first spell on monsters $ 3 $ and $ 4 $ — monster $ 3 $ dies, monster $ 4 $ has now health $ 1 $ , new health list is $ [0, 1, 0, 1] $ ;
- the first spell on monsters $ 2 $ and $ 4 $ — both monsters $ 2 $ and $ 4 $ die.

In the second testcase, the initial health list is $ [2, 4, 2] $ . Three spells are casted:

- the first spell on monsters $ 1 $ and $ 3 $ — both monsters have health $ 1 $ now, new health list is $ [1, 4, 1] $ ;
- the second spell on monster $ 2 $ — monster $ 2 $ dies, new health list is $ [1, 0, 1] $ ;
- the first spell on monsters $ 1 $ and $ 3 $ — both monsters $ 1 $ and $ 3 $ die.

In the third testcase, the initial health list is $ [1, 2, 3, 4, 5] $ . Five spells are casted. The $ i $ -th of them kills the $ i $ -th monster with the second spell. Health list sequence: $ [1, 2, 3, 4, 5] $ $ \rightarrow $ $ [0, 2, 3, 4, 5] $ $ \rightarrow $ $ [0, 0, 3, 4, 5] $ $ \rightarrow $ $ [0, 0, 0, 4, 5] $ $ \rightarrow $ $ [0, 0, 0, 0, 5] $ $ \rightarrow $ $ [0, 0, 0, 0, 0] $ .

## 样例 #1

### 输入

```
3
4
1 2 1 2
3
2 4 2
5
1 2 3 4 5
```

### 输出

```
3
3
5
```



---

---
title: "Stand-up Comedian"
layout: "post"
diff: 普及-
pid: CF1792B
tag: []
---

# Stand-up Comedian

## 题目描述

Eve is a beginner stand-up comedian. Her first show gathered a grand total of two spectators: Alice and Bob.

Eve prepared $ a_1 + a_2 + a_3 + a_4 $ jokes to tell, grouped by their type:

- type 1: both Alice and Bob like them;
- type 2: Alice likes them, but Bob doesn't;
- type 3: Bob likes them, but Alice doesn't;
- type 4: neither Alice nor Bob likes them.

Initially, both spectators have their mood equal to $ 0 $ . When a spectator hears a joke he/she likes, his/her mood increases by $ 1 $ . When a spectator hears a joke he/she doesn't like, his/her mood decreases by $ 1 $ . If the mood of a spectator becomes negative (strictly below zero), he/she leaves.

When someone leaves, Eve gets sad and ends the show. If no one leaves, and Eve is out of jokes, she also ends the show.

Thus, Eve wants to arrange her jokes in such a way that the show lasts as long as possible. Help her to calculate the maximum number of jokes she can tell before the show ends.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The only line of each testcase contains four integers $ a_1, a_2, a_3, a_4 $ ( $ 0 \le a_1, a_2, a_3, a_4 \le 10^8 $ ; $ a_1 + a_2 + a_3 + a_4 \ge 1 $ ) — the number of jokes of each type Eve prepared.

## 输出格式

For each testcase, print a single integer — the maximum number of jokes Eve can tell before at least one of the spectators leaves or before she runs out of jokes.

## 说明/提示

In the first testcase, Eve only has jokes of the first type. Thus, there's no order to choose. She tells all her jokes, both Alice and Bob like them. Their mood becomes $ 5 $ . The show ends after Eve runs out of jokes.

In the second testcase, Eve only has jokes of the fourth type. Thus, once again no order to choose. She tells a joke, and neither Alice, nor Bob likes it. Their mood decrease by one, becoming $ -1 $ . They both have negative mood, thus, both leave, and the show ends.

In the third testcase, first, Eve tells both jokes of the first type. Both Alice and Bob has mood $ 2 $ . Then she can tell $ 2 $ jokes of the third type. Alice's mood becomes $ 0 $ . Bob's mood becomes $ 4 $ . Then $ 4 $ jokes of the second type. Alice's mood becomes $ 4 $ . Bob's mood becomes $ 0 $ . Then another $ 4 $ jokes of the third type. Alice's mood becomes $ 0 $ . Bob's mood becomes $ 4 $ . Then the remaining joke of the second type. Alice's mood becomes $ 1 $ . Bob's mood becomes $ 3 $ . Then one more joke of the third type, and a joke of the fourth type, for example. Alice's mood becomes $ -1 $ , she leaves, and the show ends.

In the fourth testcase, Eve should first tell the jokes both spectators like, then the jokes they don't. She can tell $ 4 $ jokes of the fourth type until the spectators leave.

## 样例 #1

### 输入

```
4
5 0 0 0
0 0 0 5
2 5 10 6
3 0 0 7
```

### 输出

```
5
1
15
7
```



---

---
title: "Not Dividing"
layout: "post"
diff: 普及-
pid: CF1794B
tag: []
---

# Not Dividing

## 题目描述

You are given an array of $ n $ positive integers $ a_1, a_2, \ldots, a_n $ . In one operation, you can choose any number of the array and add $ 1 $ to it.

Make at most $ 2n $ operations so that the array satisfies the following property: $ a_{i+1} $ is not divisible by $ a_i $ , for each $ i = 1, 2, \ldots, n-1 $ .

You do not need to minimize the number of operations.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 1\le n\le 10^4 $ ) — the length of the given array.

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\le a_i\leq 10^9 $ ) — the given array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5\cdot 10^4 $ .

## 输出格式

For each test case, print the answer on a separate line.

In the only line, print $ n $ integers — the resulting array $ a $ after applying at most $ 2n $ operations.

We can show that an answer always exists under the given constraints. If there are multiple answers, print any of them.

## 说明/提示

In the first test case, the array $ [4, 5, 6, 7] $ can be achieved by applying $ 2 $ operations to the first element, $ 1 $ operation to the second element, $ 3 $ operations to the third element, and $ 1 $ operation to the last element. The total number of operations performed is $ 7 $ , which is less than the allowed $ 8 $ operations in this case.

In the second test case, the array $ [3, 2, 3] $ can be achieved by applying two operations to the first element. Another possible resulting array could be $ [2, 3, 5] $ , because the total number of operations does not need to be minimum.

In the third test case, not applying any operations results in an array that satisfies the statement's property. Observe that it is not mandatory to make operations.

## 样例 #1

### 输入

```
3
4
2 4 3 6
3
1 2 3
2
4 2
```

### 输出

```
4 5 6 7
3 2 3
4 2
```



---

---
title: "Ideal Point"
layout: "post"
diff: 普及-
pid: CF1795B
tag: []
---

# Ideal Point

## 题目描述

You are given $ n $ one-dimensional segments (each segment is denoted by two integers — its endpoints).

Let's define the function $ f(x) $ as the number of segments covering point $ x $ (a segment covers the point $ x $ if $ l \le x \le r $ , where $ l $ is the left endpoint and $ r $ is the right endpoint of the segment).

An integer point $ x $ is called ideal if it belongs to more segments than any other integer point, i. e. $ f(y) < f(x) $ is true for any other integer point $ y $ .

You are given an integer $ k $ . Your task is to determine whether it is possible to remove some (possibly zero) segments, so that the given point $ k $ becomes ideal.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le n, k \le 50 $ ).

Then $ n $ lines follow, $ i $ -th line of them contains two integers $ l_i $ and $ r_i $ ( $ 1 \le l_i, r_i \le 50 $ ; $ l_i \le r_i $ ) — the endpoints of the $ i $ -th segment.

## 输出格式

For each test case, print YES if it is possible to remove some (possibly zero) segments, so that the given point $ k $ becomes ideal, otherwise print NO.

You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).

## 说明/提示

In the first example, the point $ 3 $ is already ideal (it is covered by three segments), so you don't have to delete anything.

In the fourth example, you can delete everything except the segment $ [5, 5] $ .

## 样例 #1

### 输入

```
4
4 3
1 3
7 9
2 5
3 6
2 9
1 4
3 7
1 3
2 4
3 5
1 4
6 7
5 5
```

### 输出

```
YES
NO
NO
YES
```



---

---
title: "Asterisk-Minor Template"
layout: "post"
diff: 普及-
pid: CF1796B
tag: []
---

# Asterisk-Minor Template

## 题目描述

You are given two strings $ a $ and $ b $ , consisting of lowercase Latin letters.

A template $ t $ is string, consisting of lowercase Latin letters and asterisks (character '\*'). A template is called asterisk-minor if the number of asterisks in it is less than or equal to the number of letters in it.

A string $ s $ is said to be matching a template $ t $ if you can replace each asterisk in $ t $ with a string of lowercase Latin letters (possibly, an empty string) so that it becomes equal to $ s $ .

Find an asterisk-minor template such that both $ a $ and $ b $ match it, or report that such a template doesn't exist. If there are multiple answers, print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains a string $ a $ ( $ 1 \le |a| \le 50 $ , where $ |a| $ is the length of $ a $ ), consisting of lowercase Latin letters.

The second line contains a string $ b $ ( $ 1 \le |b| \le 50 $ ), consisting of lowercase Latin letters.

## 输出格式

For each testcase, output "NO", if there doesn't exist an asterisk-minor template that both $ a $ and $ b $ match. Otherwise, print "YES" in the first line and the template in the second line. If there are multiple answers, print any of them.

A template should consist only of lowercase Latin letters and asterisks (character '\*'). The number of asterisks should be less than or equal to the number of letters.

## 说明/提示

In the first testcase, for a template "\*b", you can replace the only asterisk with "aaa" to get "aaab" (which is equal to $ a $ ) or with "zzz" to get "zzzb" (which is equal to $ b $ ).

In the third testcase, a template "\*o\*" is not asterisk-minor, as it contains more asterisks than letters. There are no asterisk-minor templates that both $ a $ and $ b $ match.

In the fourth testcase, for a template "a\*a\*a\*a", you can replace all asterisks with empty strings to get "aaaa" (which is equal to $ a $ ) or two of them with "a" and two of them with an empty string to get "aaaaaa" (which is equal to $ b $ ).

In the fifth testcase, there are no asterisks in a template "abcd", so only "abcd" can match it (which is coincidentally both $ a $ and $ b $ ).

## 样例 #1

### 输入

```
6
aaab
zzzb
codeforces
atcoder
codeforces
tokitlx
aaaa
aaaaaa
abcd
abcd
c
f
```

### 输出

```
YES
*b
YES
*co*
NO
YES
a*a*a*a
YES
abcd
NO
```



---

---
title: "Li Hua and Pattern"
layout: "post"
diff: 普及-
pid: CF1797B
tag: []
---

# Li Hua and Pattern

## 题目描述

Li Hua has a pattern of size $ n\times n $ , each cell is either blue or red. He can perform exactly $ k $  operations. In each operation, he chooses a cell and changes its color from red to blue or from blue to red. Each cell can be chosen as many times as he wants. Is it possible to make the pattern, that matches its rotation by $ 180^{\circ} $ ?

Suppose you were Li Hua, please solve this problem.

## 输入格式

The first line contains the single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.

The first line of each test case contains two integers $ n,k $ ( $ 1\le n\le 10^3,0\le k \le 10^9 $ ) — the size of the pattern and the number of operations.

Each of next $ n $ lines contains $ n $ integers $ a_{i,j} $ ( $ a_{i,j}\in\{0,1\} $ ) — the initial color of the cell, $ 0 $ for blue and $ 1 $ for red.

It's guaranteed that sum of $ n $ over all test cases does not exceed $ 10^3 $ .

## 输出格式

For each set of input, print "YES" if it's possible to make the pattern, that matches its rotation by $ 180^{\circ} $ after applying exactly $ k $ of operations, and "NO" otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

In test case 1, you can't perform any operation. The pattern after rotation is on the right.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1797B/debd4989c6daceeecb5305f7cb7ec257866c6bf5.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1797B/187295f499fcefe17d924d6eb93da50e9773c4d3.png)In test case 2, you can perform operations on $ (2,1),(3,2),(3,4) $ . The pattern after operations is in the middle and the pattern after rotation is on the right.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1797B/0c0aed7c9c5dddd78137bdc2f8654231a7026420.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1797B/3b36bd2af8c0789e62f808d71f3af4107dad02c2.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1797B/3b36bd2af8c0789e62f808d71f3af4107dad02c2.png)

## 样例 #1

### 输入

```
3
4 0
1 1 1 1
0 0 0 1
1 0 1 0
1 1 1 1
4 3
1 0 1 1
1 0 0 0
0 1 0 1
1 1 0 1
5 4
0 0 0 0 0
0 1 1 1 1
0 1 0 0 0
1 1 1 1 1
0 0 0 0 0
```

### 输出

```
NO
YES
YES
```



---

---
title: "Showstopper"
layout: "post"
diff: 普及-
pid: CF1798A
tag: []
---

# Showstopper

## 题目描述

You are given two arrays $ a_1, a_2, \ldots, a_n $ and $ b_1, b_2, \ldots, b_n $ .

In one operation, you can choose any integer $ i $ from $ 1 $ to $ n $ and swap the numbers $ a_i $ and $ b_i $ .

Determine whether, after using any (possibly zero) number of operations, the following two conditions can be satisfied simultaneously:

- $ a_n = \max(a_1, a_2, \ldots, a_n) $ ,
- $ b_n = \max(b_1, b_2, \ldots, b_n) $ .

Here $ \max(c_1, c_2, \ldots, c_k) $ denotes the maximum number among $ c_1, c_2, \ldots, c_k $ . For example, $ \max(3, 5, 4) = 5 $ , $ \max(1, 7, 7) = 7 $ , $ \max(6, 2) = 6 $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 200 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 100 $ ) — the length of the arrays.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 100 $ ) — elements of the first array.

The third line of each test case contains $ n $ integers $ b_1, b_2, \ldots, b_n $ ( $ 1 \le b_i \le 100 $ ) — elements of the second array.

## 输出格式

For each test case, print "Yes" if after using any (possibly zero) number of operations the conditions described above are satisfied. Otherwise, print "No".

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

In the first test case, you can swap the numbers $ a_3 $ and $ b_3 $ , after which the array $ a $ becomes equal to $ [7, 9, 9] $ , and the array $ b $ becomes equal to $ [7, 6, 7] $ , and both conditions are met.

In the second test case, it can be proved that it is impossible to satisfy both conditions.

In the third test case, you can swap the numbers $ a_1 $ and $ b_1 $ , after which the array $ a $ becomes equal to $ [99, 99] $ , and the array $ b $ becomes equal to $ [100, 100] $ , and both conditions are satisfied.

In fifth test case, you can swap $ a_7 $ and $ b_7 $ , $ a_8 $ and $ b_8 $ , $ a_9 $ and $ b_9 $ , after which the array $ a $ becomes equal to $ [1, 2, 3, 4, 5, 6, 6, 6, 6] $ , and the array $ b $ becomes equal to $ [9, 9, 9, 9, 9, 9, 7, 8, 9] $ , and both conditions are satisfied.

## 样例 #1

### 输入

```
7
3
7 9 7
7 6 9
4
10 10 15 15
10 16 15 15
2
100 99
99 100
1
1
1
9
1 2 3 4 5 6 7 8 9
9 9 9 9 9 9 6 6 6
7
1 1 2 2 1 1 2
1 2 1 2 1 2 1
2
30 4
5 30
```

### 输出

```
Yes
No
Yes
Yes
Yes
No
No
```



---

---
title: "Count the Number of Pairs"
layout: "post"
diff: 普及-
pid: CF1800B
tag: []
---

# Count the Number of Pairs

## 题目描述

Kristina has a string $ s $ of length $ n $ , consisting only of lowercase and uppercase Latin letters. For each pair of lowercase letter and its matching uppercase letter, Kristina can get $ 1 $ burl. However, pairs of characters cannot overlap, so each character can only be in one pair.

For example, if she has the string $ s $ = "aAaaBACacbE", she can get a burl for the following character pairs:

- $ s_1 $ = "a" and $ s_2 $ = "A"
- $ s_4 $ = "a" and $ s_6 $ = "A"
- $ s_5 $ = "B" and $ s_{10} $ = "b"
- $ s_7 $ = "C" and $ s_9 $ = "c"

Kristina wants to get more burles for her string, so she is going to perform no more than $ k $ operations on it. In one operation, she can:

- either select the lowercase character $ s_i $ ( $ 1 \le i \le n $ ) and make it uppercase.
- or select uppercase character $ s_i $ ( $ 1 \le i \le n $ ) and make it lowercase.

For example, when $ k $ = 2 and $ s $ = "aAaaBACacbE" it can perform one operation: choose $ s_3 $ = "a" and make it uppercase. Then she will get another pair of $ s_3 $ = "A" and $ s_8 $ = "a"

Find maximum number of burles Kristina can get for her string.

## 输入格式

The first line of input data contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The description of the test cases follows.

The first line of each test case contains two integers $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) and $ k $ ( $ 0 \le k \le n $ ) — the number of characters in the string and the maximum number of operations that can be performed on it.

The second line of each test case contains a string $ s $ of length $ n $ , consisting only of lowercase and uppercase Latin letters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print exactly one integer on a separate line: the maximum number of burles that Kristina can get for her string $ s $ .

## 说明/提示

The first test case is explained in the problem statement.

In the second test case, it is not possible to get any pair by performing any number of operations.

## 样例 #1

### 输入

```
5
11 2
aAaaBACacbE
2 2
ab
4 1
aaBB
6 0
abBAcC
5 3
cbccb
```

### 输出

```
5
0
1
3
2
```



---

---
title: "Powering the Hero (easy version)"
layout: "post"
diff: 普及-
pid: CF1800C1
tag: []
---

# Powering the Hero (easy version)

## 题目描述

This is an easy version of the problem. It differs from the hard one only by constraints on $ n $ and $ t $ .

There is a deck of $ n $ cards, each of which is characterized by its power. There are two types of cards:

- a hero card, the power of such a card is always equal to $ 0 $ ;
- a bonus card, the power of such a card is always positive.

You can do the following with the deck:

- take a card from the top of the deck;
- if this card is a bonus card, you can put it on top of your bonus deck or discard;
- if this card is a hero card, then the power of the top card from your bonus deck is added to his power (if it is not empty), after that the hero is added to your army, and the used bonus discards.

Your task is to use such actions to gather an army with the maximum possible total power.

## 输入格式

The first line of input data contains single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases in the test.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 5000 $ ) — the number of cards in the deck.

The second line of each test case contains $ n $ integers $ s_1, s_2, \dots, s_n $ ( $ 0 \le s_i \le 10^9 $ ) — card powers in top-down order.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5000 $ .

## 输出格式

Output $ t $ numbers, each of which is the answer to the corresponding test case — the maximum possible total power of the army that can be achieved.

## 说明/提示

In the first sample, you can take bonuses $ 1 $ and $ 2 $ . Both hero cards will receive $ 3 $ power. If you take all the bonuses, one of them will remain unused.

In the second sample, the hero's card on top of the deck cannot be powered up, and the rest can be powered up with $ 2 $ and $ 3 $ bonuses and get $ 6 $ total power.

In the fourth sample, you can take bonuses $ 1 $ , $ 2 $ , $ 3 $ , $ 5 $ and skip the bonus $ 6 $ , then the hero $ 4 $ will be enhanced with a bonus $ 3 $ by $ 5 $ , and the hero $ 7 $ with a bonus $ 5 $ by $ 4 $ . $ 4+5=9 $ .

## 样例 #1

### 输入

```
5
5
3 3 3 0 0
6
0 3 3 0 0 3
7
1 2 3 0 4 5 0
7
1 2 5 0 4 3 0
5
3 1 0 0 4
```

### 输出

```
6
6
8
9
4
```



---

---
title: "Powering the Hero (hard version)"
layout: "post"
diff: 普及-
pid: CF1800C2
tag: []
---

# Powering the Hero (hard version)

## 题目描述

This is a hard version of the problem. It differs from the easy one only by constraints on $ n $ and $ t $ .

There is a deck of $ n $ cards, each of which is characterized by its power. There are two types of cards:

- a hero card, the power of such a card is always equal to $ 0 $ ;
- a bonus card, the power of such a card is always positive.

You can do the following with the deck:

- take a card from the top of the deck;
- if this card is a bonus card, you can put it on top of your bonus deck or discard;
- if this card is a hero card, then the power of the top card from your bonus deck is added to his power (if it is not empty), after that the hero is added to your army, and the used bonus discards.

Your task is to use such actions to gather an army with the maximum possible total power.

## 输入格式

The first line of input data contains single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases in the test.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of cards in the deck.

The second line of each test case contains $ n $ integers $ s_1, s_2, \dots, s_n $ ( $ 0 \le s_i \le 10^9 $ ) — card powers in top-down order.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

Output $ t $ numbers, each of which is the answer to the corresponding test case — the maximum possible total power of the army that can be achieved.

## 说明/提示

In the first sample, you can take bonuses $ 1 $ and $ 2 $ . Both hero cards will receive $ 3 $ power. If you take all the bonuses, one of them will remain unused.

In the second sample, the hero's card on top of the deck cannot be powered up, and the rest can be powered up with $ 2 $ and $ 3 $ bonuses and get $ 6 $ total power.

In the fourth sample, you can take bonuses $ 1 $ , $ 2 $ , $ 3 $ , $ 5 $ and skip the bonus $ 6 $ , then the hero $ 4 $ will be enhanced with a bonus $ 3 $ by $ 5 $ , and the hero $ 7 $ with a bonus $ 5 $ by $ 4 $ . $ 4+5=9 $ .

## 样例 #1

### 输入

```
5
5
3 3 3 0 0
6
0 3 3 0 0 3
7
1 2 3 0 4 5 0
7
1 2 5 0 4 3 0
5
3 1 0 0 4
```

### 输出

```
6
6
8
9
4
```



---

---
title: "Settlement of Guinea Pigs"
layout: "post"
diff: 普及-
pid: CF1802B
tag: []
---

# Settlement of Guinea Pigs

## 题目描述

Dasha loves guinea pigs very much. In this regard, she decided to settle as many guinea pigs at home as possible and developed a plan for the next $ n $ days. Every day, she will either buy a new guinea pig or call a doctor to examine all her pets.

Unfortunately, the store where she was going to buy guinea pigs does not understand them. Therefore, it cannot determine their gender. Dasha can't do it either. The only one who can help is a doctor.

To keep guinea pigs, aviaries are needed. Dasha plans to buy them in the same store. Unfortunately, only one species is sold there — a double aviary. No more than two guinea pigs can live in it.

Since Dasha does not want to cause moral injury to her pets — she will not settle two guinea pigs of different genders in one aviary.

Help Dasha calculate how many aviaries in the worst case you need to buy so that you can be sure that at no moment of time do two guinea pigs of different genders live in the same aviary.

As part of this task, we believe that guinea pigs have only two genders — male and female.

## 输入格式

The first line of input data contains one number $ t $ ( $ 1 \leqslant t \leqslant 10^5 $ ) — the number of input data sets.

The first line of each input data set contains one number $ n $ ( $ 1 \leqslant n \leqslant 10^5 $ ) — the number of days Dasha has a plan for.

The next line contains $ n $ numbers $ b_1, b_2, b_3, \ldots, b_n $ ( $ 1 \leqslant b_i \leqslant 2 $ ) — Dasha's plan. If $ b_i = 1 $ , then on the $ i $ th day, Dasha will buy a new guinea pig. If $ b_i = 2 $ , then on the $ i $ th day, a doctor will come to Dasha and help determine the sex of all guinea pigs that Dasha already has.

It is guaranteed that the sum of $ n $ for all input data sets does not exceed $ 10^5 $ .

## 输出格式

For each set of input data, output one number — the minimum number of aviaries Dasha needs to buy so that no matter what the genders of the pigs turn out to be, we can settle them so that at no point in time do two guinea pigs of different genders live together.

## 说明/提示

In the first set of input data, Dasha needs to put each guinea pig in a separate enclosure, since she does not know their gender.

In the second set of input data, Dasha will buy $ 0 $ guinea pigs, which means she will need $ 0 $ aviaries.

In the third set of input data, you even need $ 3 $ aviaries to put each guinea pig in a separate aviary before the doctor arrives at the $ 4 $ th day. When she finds out their gender, at least two guinea pigs will be of the same gender and they can be placed in one aviary, and the third in another aviary. Thus, she will have one free aviary in which she can settle a new guinea pig. So answer is $ 3 $ .

In the fourth set of input data, we show that $ 4 $ is the optimal answer.

To begin with, we note that the first four guinea pigs can be placed one at a time in an aviary. Then a doctor will come and determine their gender. Among these four guinea pigs there will be at least one pair of the same gender, because: either male guinea pigs are at least $ 2 $ , or they are not more than $ 1 $ , which means that the female is at least $ 3 $ . Now we can put this couple in one aviary, and the other two in separate ones. We will have one more empty aviary where we can put a new pig.

Now let's show that the answer is at least $ 4 $ . Let's say that among the first $ 4 $ guinea pigs, $ 3 $ are female and $ 1 $ is male. We need at least $ 3 $ aviaries to settle them. Then, when we buy a new guinea pig, we will need another aviary in which we will put it, since we do not know its gender.

## 样例 #1

### 输入

```
6
3
1 1 1
3
2 2 2
5
1 1 1 2 1
10
1 2 1 2 1 2 1 2 1 2
20
1 2 1 1 1 1 1 2 1 2 1 2 2 1 1 1 1 1 1 1
20
2 1 1 2 1 1 2 1 2 2 1 1 1 2 2 1 1 1 1 2
```

### 输出

```
3
0
3
4
12
9
```



---

---
title: "Vaccination"
layout: "post"
diff: 普及-
pid: CF1804B
tag: []
---

# Vaccination

## 题目描述

#### 题目大意

Ethan 经营一个疫苗接种站，帮助人们抵御季节性流感。他分析历史数据，以便开发出最佳的疫苗使用策略。

假设有 $n$ 个病人在特定的一天来到诊所，第 $i$ 个病人在时刻 $t_i$ 来。我们知道这些病人中的每一个都可以被要求等待不超过 $w$ 个时间点。这意味着第 $i$ 个病人可以在时刻 $t_i,t_i+1,…,t_i+w$ 接种疫苗。

疫苗以包装形式出现，每个包装包含 $k$ 剂量。每个病人需要恰好一剂量。包装是存放在一个特殊冰箱里的。如果一个包装被取出并打开，它便不能再放回去。疫苗在冰箱外的寿命为 $d$ 个时间点。因此，如果此包装是在时刻 $x$ 被取出且打开，其剂量可用于在时刻 $x,x+1,…,x+d$ 接种疫苗。在时刻 $x+d+1$，这个包装剩余的未使用剂量全部被扔掉。

假设接种站有足够的工作人员在任意时刻进行任意数量的操作。那么接种所有 $n$ 个病人所需的最少疫苗包装数是多少？

## 输入格式

第一行是测试用例数 $t$ $(1≤t≤10^4)$。随后是 $t$ 组测试用例的描述。

每个测试用例的第一行包含四个整数 $n$、$k$、$d$ 和 $w$$（1≤n,k≤2⋅10^5，0≤d，w≤10^6）$。它们分别是病人的数量，每个疫苗包装的剂量数，疫苗可在冰箱外存活的时间数以及病人可以等待的时间数。

每个测试用例的第二行包含一个非降序列 $t_1,t_2,…,t_n$$（0≤t_1≤t_2≤⋯≤t_n≤10^6）$。这个序列的第 $i$ 个元素是第 $i$ 个病人来接种疫苗的时刻。

保证所有测试用例中的 $n$ 的总和不超过 $2⋅10^5$。

## 输出格式

输出一个整数，表示接种所有病人所需的最少疫苗包装数。

Translate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)

## 样例 #1

### 输入

```
5
6 3 5 3
1 2 3 10 11 18
6 4 0 0
3 3 3 3 3 4
9 10 2 2
0 1 2 3 4 5 6 7 8
3 10 3 6
10 20 30
5 5 4 4
0 2 4 6 8
```

### 输出

```
2
3
2
3
1
```



---

---
title: "Mex Master"
layout: "post"
diff: 普及-
pid: CF1806B
tag: []
---

# Mex Master

## 题目描述

You are given an array $ a $ of length $ n $ . The score of $ a $ is the MEX $ ^{\dagger} $ of $ [a_1+a_2,a_2+a_3,\ldots,a_{n-1}+a_n] $ . Find the minimum score of $ a $ if you are allowed to rearrange elements of $ a $ in any order. Note that you are not required to construct the array $ a $ that achieves the minimum score.

 $ ^{\dagger} $ The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:

- The MEX of $ [2,2,1] $ is $ 0 $ , because $ 0 $ does not belong to the array.
- The MEX of $ [3,1,0,1] $ is $ 2 $ , because $ 0 $ and $ 1 $ belong to the array, but $ 2 $ does not.
- The MEX of $ [0,3,1,2] $ is $ 4 $ because $ 0 $ , $ 1 $ , $ 2 $ , and $ 3 $ belong to the array, but $ 4 $ does not.

## 输入格式

The first line contains a single integer $ t $ ( $ 1\le t\le 10^4 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2\le n\le 2\cdot10^5 $ ).

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 2\cdot 10^5 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, output the minimum score of $ a $ after rearranging the elements of $ a $ in any order.

## 说明/提示

In the first test case, it is optimal to rearrange $ a $ as $ [0,0] $ , the score of this array is the MEX of $ [0+0]=[0] $ , which is $ 1 $ .

In the second test case, it is optimal to rearrange $ a $ as $ [0,1,0] $ , the score of this array is the MEX of $ [0+1,1+0]=[1,1] $ , which is $ 0 $ .

## 样例 #1

### 输入

```
3
2
0 0
3
0 0 1
8
1 0 0 0 2 0 3 0
```

### 输出

```
1
0
1
```



---

---
title: "Odd Queries"
layout: "post"
diff: 普及-
pid: CF1807D
tag: []
---

# Odd Queries

## 题目描述

You have an array $ a_1, a_2, \dots, a_n $ . Answer $ q $ queries of the following form:

- If we change all elements in the range $ a_l, a_{l+1}, \dots, a_r $ of the array to $ k $ , will the sum of the entire array be odd?

 Note that queries are independent and do not affect future queries.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The first line of each test case consists of $ 2 $ integers $ n $ and $ q $ ( $ 1 \le n \le 2 \cdot 10^5 $ ; $ 1 \le q \le 2 \cdot 10^5 $ ) — the length of the array and the number of queries.

The second line of each test case consists of $ n $ integers $ a_i $ ( $ 1 \le a_i \le 10^9 $ ) — the array $ a $ .

The next $ q $ lines of each test case consists of $ 3 $ integers $ l,r,k $ ( $ 1 \le l \le r \le n $ ; $ 1 \le k \le 10^9 $ ) — the queries.

It is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ , and the sum of $ q $ doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each query, output "YES" if the sum of the entire array becomes odd, and "NO" otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

For the first test case:

- If the elements in the range $ (2, 3) $ would get set to $ 3 $ the array would become $ \{2, 3, 3, 3, 2\} $ , the sum would be $ 2+3+3+3+2 = 13 $ which is odd, so the answer is "YES".
- If the elements in the range $ (2, 3) $ would get set to $ 4 $ the array would become $ \{2, 4, 4, 3, 2\} $ , the sum would be $ 2+4+4+3+2 = 15 $ which is odd, so the answer is "YES".
- If the elements in the range $ (1, 5) $ would get set to $ 5 $ the array would become $ \{5, 5, 5, 5, 5\} $ , the sum would be $ 5+5+5+5+5 = 25 $ which is odd, so the answer is "YES".
- If the elements in the range $ (1, 4) $ would get set to $ 9 $ the array would become $ \{9, 9, 9, 9, 2\} $ , the sum would be $ 9+9+9+9+2 = 38 $ which is even, so the answer is "NO".
- If the elements in the range $ (2, 4) $ would get set to $ 3 $ the array would become $ \{2, 3, 3, 3, 2\} $ , the sum would be $ 2+3+3+3+2 = 13 $ which is odd, so the answer is "YES".

## 样例 #1

### 输入

```
2
5 5
2 2 1 3 2
2 3 3
2 3 4
1 5 5
1 4 9
2 4 3
10 5
1 1 1 1 1 1 1 1 1 1
3 8 13
2 5 10
3 8 10
1 10 2
1 9 100
```

### 输出

```
YES
YES
YES
NO
YES
NO
NO
NO
NO
YES
```



---

---
title: "Subsequence Addition (Easy Version)"
layout: "post"
diff: 普及-
pid: CF1807G1
tag: []
---

# Subsequence Addition (Easy Version)

## 题目描述

The only difference between the two versions is that in this version, the constraints are lower.

Initially, array $ a $ contains just the number $ 1 $ . You can perform several operations in order to change the array. In an operation, you can select some subsequence $ ^{\dagger} $ of $ a $ and add into $ a $ an element equal to the sum of all elements of the subsequence.

You are given a final array $ c $ . Check if $ c $ can be obtained from the initial array $ a $ by performing some number (possibly 0) of operations on the initial array.

 $ ^{\dagger} $ A sequence $ b $ is a subsequence of a sequence $ a $ if $ b $ can be obtained from $ a $ by the deletion of several (possibly zero, but not all) elements. In other words, select $ k $ ( $ 1 \leq k \leq |a| $ ) distinct indices $ i_1, i_2, \dots, i_k $ and insert anywhere into $ a $ a new element with the value equal to $ a_{i_1} + a_{i_2} + \dots + a_{i_k} $ .

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 5000 $ ) — the number of elements the final array $ c $ should have.

The second line of each test case contains $ n $ space-separated integers $ c_i $ ( $ 1 \leq c_i \leq 5000 $ ) — the elements of the final array $ c $ that should be obtained from the initial array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5000 $ .

## 输出格式

For each test case, output "YES" (without quotes) if such a sequence of operations exists, and "NO" (without quotes) otherwise.

You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).

## 说明/提示

For the first test case, the initial array $ a $ is already equal to $ [1] $ , so the answer is "YES".

For the second test case, performing any amount of operations will change $ a $ to an array of size at least two which doesn't only have the element $ 2 $ , thus obtaining the array $ [2] $ is impossible and the answer is "NO".

For the third test case, we can perform the following operations in order to obtain the final given array $ c $ :

- Initially, $ a = [1] $ .
- By choosing the subsequence $ [1] $ , and inserting $ 1 $ in the array, $ a $ changes to $ [1, 1] $ .
- By choosing the subsequence $ [1, 1] $ , and inserting $ 1+1=2 $ in the middle of the array, $ a $ changes to $ [1, 2, 1] $ .
- By choosing the subsequence $ [1, 2] $ , and inserting $ 1+2=3 $ after the first $ 1 $ of the array, $ a $ changes to $ [1, 3, 2, 1] $ .
- By choosing the subsequence $ [1, 3, 1] $ and inserting $ 1+3+1=5 $ at the beginning of the array, $ a $ changes to $ [5, 1, 3, 2, 1] $ (which is the array we needed to obtain).

## 样例 #1

### 输入

```
6
1
1
1
2
5
5 1 3 2 1
5
7 1 5 2 1
3
1 1 1
5
1 1 4 2 1
```

### 输出

```
YES
NO
YES
NO
YES
YES
```



---

---
title: "Lucky Numbers"
layout: "post"
diff: 普及-
pid: CF1808A
tag: []
---

# Lucky Numbers

## 题目描述

Olympus City recently launched the production of personal starships. Now everyone on Mars can buy one and fly to other planets inexpensively.

Each starship has a number —some positive integer $ x $ . Let's define the luckiness of a number $ x $ as the difference between the largest and smallest digits of that number. For example, $ 142857 $ has $ 8 $ as its largest digit and $ 1 $ as its smallest digit, so its luckiness is $ 8-1=7 $ . And the number $ 111 $ has all digits equal to $ 1 $ , so its luckiness is zero.

Hateehc is a famous Martian blogger who often flies to different corners of the solar system. To release interesting videos even faster, he decided to buy himself a starship. When he came to the store, he saw starships with numbers from $ l $ to $ r $ inclusively. While in the store, Hateehc wanted to find a starship with the luckiest number.

Since there are a lot of starships in the store, and Hateehc can't program, you have to help the blogger and write a program that answers his question.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1808A/e10cd9aa8c24a123d5e125320e42ed0d55b601c6.png)

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10\,000 $ ) —the number of test cases.

Each of the following $ t $ lines contains a description of the test case. The description consists of two integers $ l $ and $ r $ ( $ 1 \le l \le r \le 10^6 $ ) — the largest and smallest numbers of the starships in the store.

## 输出格式

Print $ t $ lines, one line for each test case, containing the luckiest starship number in the store.

If there are several ways to choose the luckiest number, output any of them.

## 说明/提示

Let's look at two test examples:

- the luckiness of the number $ 59 $ is $ 9 - 5 = 4 $ ;
- the luckiness of $ 60 $ equals $ 6 - 0 = 6 $ ;
- the luckiness of $ 61 $ equals $ 6 - 1 = 5 $ ;
- the luckiness of $ 62 $ equals $ 6 - 2 = 4 $ ;
- the luckiness of $ 63 $ is $ 6 - 3 = 3 $ .

 Thus, the luckiest number is $ 60 $ .In the fifth test example, the luckiest number is $ 90 $ .

## 样例 #1

### 输入

```
5
59 63
42 49
15 15
53 57
1 100
```

### 输出

```
60
49
15
57
90
```



---

---
title: "Points on Plane"
layout: "post"
diff: 普及-
pid: CF1809B
tag: []
---

# Points on Plane

## 题目描述

You are given a two-dimensional plane, and you need to place $ n $ chips on it.

You can place a chip only at a point with integer coordinates. The cost of placing a chip at the point $ (x, y) $ is equal to $ |x| + |y| $ (where $ |a| $ is the absolute value of $ a $ ).

The cost of placing $ n $ chips is equal to the maximum among the costs of each chip.

You need to place $ n $ chips on the plane in such a way that the Euclidean distance between each pair of chips is strictly greater than $ 1 $ , and the cost is the minimum possible.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Next $ t $ cases follow.

The first and only line of each test case contains one integer $ n $ ( $ 1 \le n \le 10^{18} $ ) — the number of chips you need to place.

## 输出格式

For each test case, print a single integer — the minimum cost to place $ n $ chips if the distance between each pair of chips must be strictly greater than $ 1 $ .

## 说明/提示

In the first test case, you can place the only chip at point $ (0, 0) $ with total cost equal to $ 0 + 0 = 0 $ .

In the second test case, you can, for example, place chips at points $ (-1, 0) $ , $ (0, 1) $ and $ (1, 0) $ with costs $ |-1| + |0| = 1 $ , $ |0| + |1| = 1 $ and $ |0| + |1| = 1 $ . Distance between each pair of chips is greater than $ 1 $ (for example, distance between $ (-1, 0) $ and $ (0, 1) $ is equal to $ \sqrt{2} $ ). The total cost is equal to $ \max(1, 1, 1) = 1 $ .

In the third test case, you can, for example, place chips at points $ (-1, -1) $ , $ (-1, 1) $ , $ (1, 1) $ , $ (0, 0) $ and $ (0, 2) $ . The total cost is equal to $ \max(2, 2, 2, 0, 2) = 2 $ .

## 样例 #1

### 输入

```
4
1
3
5
975461057789971042
```

### 输出

```
0
1
2
987654321
```



---

---
title: "Letter"
layout: "post"
diff: 普及-
pid: CF180C
tag: []
---

# Letter

## 题目描述

给你一个字符串，我们每一次操作都可以将一个大写字母变成任意小写字母，当然同理也可以将小写字母变成任意大写字母，问最少操作多少次，能够使得字符串变成前边都是大写字母，后边都是小写字母。

## 输入格式

输入的唯一行包含一个由大写字母和小写字母组成的非空字符串。字符串的长度不超过10^5个

## 输出格式

输出一个数字最少删除次数

## 样例 #1

### 输入

```
PRuvetSTAaYA

```

### 输出

```
5

```

## 样例 #2

### 输入

```
OYPROSTIYAOPECHATALSYAPRIVETSTASYA

```

### 输出

```
0

```

## 样例 #3

### 输入

```
helloworld

```

### 输出

```
0

```



---

---
title: "Mathematical Analysis Rocks!"
layout: "post"
diff: 普及-
pid: CF180F
tag: []
---

# Mathematical Analysis Rocks!

## 题目描述

Students of group 199 have written their lectures dismally. Now an exam on Mathematical Analysis is approaching and something has to be done asap (that is, quickly). Let's number the students of the group from 1 to $ n $ . Each student $ i $ ( $ 1<=i<=n $ ) has a best friend $ p[i] $ ( $ 1<=p[i]<=n $ ). In fact, each student is a best friend of exactly one student. In other words, all $ p[i] $ are different. It is possible that the group also has some really "special individuals" for who $ i=p[i] $ .

Each student wrote exactly one notebook of lecture notes. We know that the students agreed to act by the following algorithm:

- on the first day of revising each student studies his own Mathematical Analysis notes,
- in the morning of each following day each student gives the notebook to his best friend and takes a notebook from the student who calls him the best friend.

Thus, on the second day the student $ p[i] $ ( $ 1<=i<=n $ ) studies the $ i $ -th student's notes, on the third day the notes go to student $ p[p[i]] $ and so on. Due to some characteristics of the boys' friendship (see paragraph 1), each day each student has exactly one notebook to study.

You are given two sequences that describe the situation on the third and fourth days of revising:

- $ a_{1},a_{2},...,a_{n} $ , where $ a_{i} $ means the student who gets the $ i $ -th student's notebook on the third day of revising;
- $ b_{1},b_{2},...,b_{n} $ , where $ b_{i} $ means the student who gets the $ i $ -th student's notebook on the fourth day of revising.

You do not know array $ p $ , that is you do not know who is the best friend to who. Write a program that finds $ p $ by the given sequences $ a $ and $ b $ .

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of students in the group. The second line contains sequence of different integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=n $ ). The third line contains the sequence of different integers $ b_{1},b_{2},...,b_{n} $ ( $ 1<=b_{i}<=n $ ).

## 输出格式

Print sequence $ n $ of different integers $ p[1],p[2],...,p[n] $ ( $ 1<=p[i]<=n $ ). It is guaranteed that the solution exists and that it is unique.

## 样例 #1

### 输入

```
4
2 1 4 3
3 4 2 1

```

### 输出

```
4 3 1 2 
```

## 样例 #2

### 输入

```
5
5 2 3 1 4
1 3 2 4 5

```

### 输出

```
4 3 2 5 1 
```

## 样例 #3

### 输入

```
2
1 2
2 1

```

### 输出

```
2 1 
```



---

---
title: "Conveyor Belts"
layout: "post"
diff: 普及-
pid: CF1811B
tag: []
---

# Conveyor Belts

## 题目描述

Conveyor matrix $ m_n $ is matrix of size $ n \times n $ , where $ n $ is an even number. The matrix consists of concentric ribbons moving clockwise.

In other words, the conveyor matrix for $ n = 2 $ is simply a matrix $ 2 \times 2 $ , whose cells form a cycle of length $ 4 $ clockwise. For any natural $ k \ge 2 $ , the matrix $ m_{2k} $ is obtained by adding to the matrix $ m_{2k - 2} $ an outer layer forming a clockwise cycle.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1811B/9983d2b36278ac1465bae7e881cd16110c58e71c.png) The conveyor matrix $ 8 \times 8 $ . You are standing in a cell with coordinates $ x_1, y_1 $ and you want to get into a cell with coordinates $ x_2, y_2 $ . A cell has coordinates $ x, y $ if it is located at the intersection of the $ x $ th row and the $ y $ th column.

Standing on some cell, every second you will move to the cell next in the direction of movement of the tape on which you are. You can also move to a neighboring cell by spending one unit of energy. Movements happen instantly and you can make an unlimited number of them at any time.

Your task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates $ x_1, y_1 $ to the cell with coordinates $ x_2, y_2 $ .

For example, $ n=8 $ initially you are in a cell with coordinates $ 1,3 $ and you want to get into a cell with coordinates $ 6, 4 $ . You can immediately make $ 2 $ movements, once you are in a cell with coordinates $ 3, 3 $ , and then after $ 8 $ seconds you will be in the right cell.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 2 \cdot 10^5 $ ) — the number of test cases.

The descriptions of the test cases follow.

The description of each test case consists of one string containing five integers $ n $ , $ x_1 $ , $ y_1 $ , $ x_2 $ and $ y_2 $ ( $ 1 \le x_1, y_1, x_2, y_2 \le n \le 10^9 $ ) — matrix size and the coordinates of the start and end cells. It is guaranteed that the number $ n $ is even.

## 输出格式

For each test case, print one integer in a separate line — the minimum amount of energy that will have to be spent to get from the cell with coordinates $ x_1, y_1 $ to the cell with coordinates $ x_2, y_2 $ .

## 样例 #1

### 输入

```
5
2 1 1 2 2
4 1 4 3 3
8 1 3 4 6
100 10 20 50 100
1000000000 123456789 987654321 998244353 500000004
```

### 输出

```
0
1
2
9
10590032
```



---

---
title: "Restore the Array"
layout: "post"
diff: 普及-
pid: CF1811C
tag: []
---

# Restore the Array

## 题目描述

Kristina 有一个包含 $ n $ 个**非负整数**的数组 $ a $。

她构造了一个长度为 $ n - 1 $ 的新数组 $ b $，使得 $ b_i = \max(a_i, a_{i + 1}) \text{ } (1 \le i \le n - 1) $。

例如，假设 Kristina 有一个长度为 $ 5 $ 的数组 $ a = [ 3, 0, 4, 0, 5 ] $，则她将以以下方式构造数组 $ b $：

1. $ b_1 = \max(a_1, a_2) = \max(3, 0) = 3; $
2. $ b_2 = \max(a_2, a_3) = \max(0, 4) = 4; $
3. $ b_3 = \max(a_3, a_4) = \max(4, 0) = 4; $
4. $ b_4 = \max(a_4, a_5) = \max(0, 5) = 5. $

所以，她得到了一个长度为 $ 4 $ 的数组 $ b = [ 3, 4, 4, 5 ] $。

现在，你只知道数组 $ b $。你需要找出**任意一个**可能的数组 $ a $。



对于第二组测试数据，我们可以从 $ a = [ 2, 2, 1, 1 ] $ 推出 $ b = [ 2, 2, 1 ] $：

* $ b_1 = \max(a_1, a_2) = \max(2, 2) = 2; $
* $ b_2 = \max(a_2, a_3) = \max(2, 1) = 2; $
* $ b_3 = \max(a_3, a_4) = \max(1, 1) = 1. $

对于第三组测试数据，数组 $ b $ 中的所有元素均为 $ 0 $，因为 $ b $ 中的每个元素均为 $ a $ 中两个相邻元素的最大值，所以数组 $ a $ 中的每个元素均为 $ 0 $。

对于第四组测试数据，我们可以从 $ a = [ 0, 0, 3, 4, 3, 3 ] $ 推出 $ b = [ 0, 3, 4, 3, 3 ] $：

* $ b_1 = \max(a_1, a_2) = \max(0, 0) = 0; $
* $ b_2 = \max(a_2, a_3) = \max(0, 3) = 3; $
* $ b_3 = \max(a_3, a_4) = \max(3, 4) = 4; $
* $ b_4 = \max(a_4, a_5) = \max(4, 3) = 4; $
* $ b_5 = \max(a_5, a_6) = \max(3, 3) = 3. $

## 输入格式

输入数据的第一行包含一个整数 $ t \text{ } (1 \le t \le 10 ^ 4) $，代表测试数据组数。

每组测试数据的第一行包含一个整数 $ n \text{ } (1 \le n \le 2 \times 10 ^ 5) $，代表数组 $ a $ 的长度。

每组测试数据的第二行包含 $ n - 1 $ 个非负整数，代表数组 $ b $ 的各个元素 $ (0 \le b_i \le 10^9) $。

对于每个测试点，保证所有 $ t $ 组测试数据中 $ n $ 的总和不超过 $ 2 \times 10 ^ 5 $，且保证有解。

## 输出格式

对于每组测试数据，在同一行内输出 $ n $ 个非负整数，代表数组 $ a $ 的元素，元素与元素之间以空格隔开。

如果有多种可能的答案，输出**任意一种**即可。

## 样例 #1

### 输入

```
11
5
3 4 4 5
4
2 2 1
5
0 0 0 0
6
0 3 4 4 3
2
10
4
3 3 3
5
4 2 5 5
4
3 3 3
4
2 1 0
3
4 4
6
8 1 3 5 10
```

### 输出

```
3 0 4 0 5
2 2 1 1
0 0 0 0 0
0 0 3 4 3 3
10 10
3 3 3 1
4 2 2 5 5
3 3 3 3
2 1 0 0
2 4 4
8 1 1 3 5 10
```



---

---
title: "Grid Reconstruction"
layout: "post"
diff: 普及-
pid: CF1816B
tag: []
---

# Grid Reconstruction

## 题目描述

在一个 $2×n$ 的网格中 （$n$ 为偶数），标记 $1,2,\ldots,2n$，但每个数只能被使用 $1$ 次。

某条路径是从 $(1,1)$ 开始的单元序列，随后不断地向下走或向右走，直到到达 $(2,n)$。注意：这条路径不能超出网格的边界。

通过这条路径的成本是这条路径所通过的单元格上的数字交替和，即，设路径上的数为 $a,a_1,a_2,\ldots,a_k$（它是第几个被标记到的，它的下标就是几），则通过这条路径的成本就是 $ a_1 - a_2 + a_3 - a_4 + \ldots = \sum_{i=1}^k a_i \cdot (-1)^{i+1} $。

你需要求一个在网格中标记 $1,2,...,2n$ 的方案，最大化成本最小的路径的成本。如果有多个答案，你可以输出任意一个。本题中，每个测试点包含 $t$ 组数据。

## 输入格式

第一行包含 $t$（$t$ 是测试数据组数）。

随后的 $t$  行，每行给出一个 $n$，表示网格的边长。
数据保证 $n\le10^5$。

## 输出格式

共 $2t$ 行，每组测试数据两行，每行包含 $n$ 个整数，表示所需的网格。如果有多个答案，你可以输出任意一个。

## 说明/提示

在第一组测试数据中，只有两条从 $(1,1)$ 到 $(2,2)$ 的路径，它们的成本分别是 $3-1+4=6$ 和 $3-2+4=5$，其中成本更小的方案是 $5$，这是最优的方案。

在第二组测试数据中，有四条从 $(1,1)$ 到 $(2,4)$ 的路径，它们的成本分别是 $8-1+5-3+7=16$，$8-2+5-3+7=15$，$8-2+6-3+7=16$ 和 $8-2+6-4+7=15$，其中成本最小的一种方案是 $15$，这是最优的方案。

## 样例 #1

### 输入

```
3
2
4
6
```

### 输出

```
3 2
1 4
8 2 6 4
1 5 3 7
11 5 9 1 7 3
6 10 2 8 4 12
```



---

---
title: "Indivisible"
layout: "post"
diff: 普及-
pid: CF1818B
tag: []
---

# Indivisible

## 题目描述

给定一个整数 $n$。

你需要构造一个一个长度为 $n$ 的排列 $A$，使得对于任意一对 $l,r$（$1\le l<r\le n$），都满足 $A_l+A_{l+1}+\dots+A_r$ 不可以被 $r-l+1$ 整除。

## 输入格式

输入一个 $t(1\le t\le 100)$ 表示数据组数。

每组数据一行一个整数 $n(1\le n\le100)$，即排列的长度。

## 输出格式

对于每组数据，若所求排列不存在，输出 `-1`，否则输出任意一个合法的排列。

## 样例 #1

### 输入

```
3
1
2
3
```

### 输出

```
1
1 2
-1
```



---

---
title: "JoJo's Incredible Adventures"
layout: "post"
diff: 普及-
pid: CF1820B
tag: []
---

# JoJo's Incredible Adventures

## 题目描述

给定一个长度为 $n$ 的二进制字符串 $s$，构建一个 $n \times n$ 的方格表。首行写下原始字符串 $s$，次行右移一个字符的循环移位字符串 $s$，第三行右移两个字符的循环移位字符串 $s$，以此类推。因此，第 $k$ 行包含一个从 $s$ 右移 $k$ 个字符的循环移位字符串。行从上到下编号 $0$ 至 $n-1$。

在生成的表中，需要找到只由数字 $1$ 构成的矩形并计算其面积，返回最大的面积。

注意：字符串 $s$ 向右循环移动 $k$ 位是指将其最后 $k$ 个字符移动到前面，即字符串 $s_{n-k+1} \cdots s_n \; s_1 \cdots s_{n-k}$。

## 输入格式

第一行的正整数 $t$ ($1\leq t\leq 2\times10^4$) 是测试用例的数量。 对于每个测试用例，只有一行，是一个只由零和一组成的二进制字符串。

保证所有测试用例中字符总数之和不超过 $2\times 10^5$。

## 输出格式

对于每个测试用例，输出一个整数：只由数字 $1$ 构成的矩形的最大面积。如果不存在这样的矩形，则输出 $0$。

## 样例 #1

### 输入

```
5
0
1
101
011110
101010
```

### 输出

```
0
1
2
6
1
```



---

---
title: "Matching"
layout: "post"
diff: 普及-
pid: CF1821A
tag: []
---

# Matching

## 题目描述

整数模板是**每位均为数字或问号**的字符串。

如果可以用数字**替换**模板中的每个问号，从而获得该**正整数（严格大于 $0$）** 的十进制表示形式，且**不带任何前导零**，则该正整数与整数模板匹配。

例如：  
$42$ 匹配 ```4?```；   
$1337$ 匹配 ```????```；    
$1337$ 匹配 ```1?3?```；   
$1337$ 匹配 ```1337```；   
$3$ 不匹配 ```??```；   
$8$ 不匹配 ```???8```；   
$1337$ 不匹配 ```1?7```；

你将获得一个最多包含 $5$ 个字符的整数模板。计算与其匹配的正整数（严格大于 $0$）的数量。

## 输入格式

**本题包含多组数据**    
第一行包含一个正整数 $t$ 为数据组数。  
每个测试用例由一行组成。其中包含每位均为数字或问号的字符串 $s$，即对应测试的整数模板。

## 输出格式

对于每个测试用例，输出一个整数：与模板匹配的正整数（严格大于 $0$）的数量。

## 说明/提示

$1 \le t \le 2 \times 10^{5}$， $t$ 为数据组数。   
$1 \le |s| \le 5$，$|s|$ 为每组数据中字符串（整数模板）的长度。

翻译者：[SCAR_L](https://www.luogu.com.cn/user/608703) at 2023.04.30

## 样例 #1

### 输入

```
8
??
?
0
9
03
1??7
?5?
9??99
```

### 输出

```
90
9
0
1
0
100
90
100
```



---

---
title: "Sort the Subarray"
layout: "post"
diff: 普及-
pid: CF1821B
tag: []
---

# Sort the Subarray

## 题目描述

Monocarp had an array $ a $ consisting of $ n $ integers. He has decided to choose two integers $ l $ and $ r $ such that $ 1 \le l \le r \le n $ , and then sort the subarray $ a[l..r] $ (the subarray $ a[l..r] $ is the part of the array $ a $ containing the elements $ a_l, a_{l+1}, a_{l+2}, \dots, a_{r-1}, a_r $ ) in non-descending order. After sorting the subarray, Monocarp has obtained a new array, which we denote as $ a' $ .

For example, if $ a = [6, 7, 3, 4, 4, 6, 5] $ , and Monocarp has chosen $ l = 2, r = 5 $ , then $ a' = [6, 3, 4, 4, 7, 6, 5] $ .

You are given the arrays $ a $ and $ a' $ . Find the integers $ l $ and $ r $ that Monocarp could have chosen. If there are multiple pairs of values $ (l, r) $ , find the one which corresponds to the longest subarray.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of three lines:

- the first line contains one integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ );
- the second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ );
- the third line contains $ n $ integers $ a'_1, a'_2, \dots, a'_n $ ( $ 1 \le a'_i \le n $ ).

Additional constraints on the input:

- the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ ;
- it is possible to obtain the array $ a' $ by sorting one subarray of $ a $ ;
- $ a' \ne a $ (there exists at least one position in which these two arrays are different).

## 输出格式

For each test case, print two integers — the values of $ l $ and $ r $ ( $ 1 \le l \le r \le n $ ). If there are multiple answers, print the values that correspond to the longest subarray. If there are still multiple answers, print any of them.

## 样例 #1

### 输入

```
3
7
6 7 3 4 4 6 5
6 3 4 4 7 6 5
3
1 2 1
1 1 2
3
2 2 1
2 1 2
```

### 输出

```
2 5
1 3
2 3
```



---

---
title: "Sort with Step"
layout: "post"
diff: 普及-
pid: CF1823B
tag: []
---

# Sort with Step

## 题目描述

给定一个 $1$ 到 $n$ 的排列 $p$ 和一个正整数 $k$。

你可以对 $p$ 进行若干次操作，每次操作交换 $p_i$ 和 $p_j$，其中 $|i-j|=k$。你的目标是使得 $p$ 变为升序。

除此之外，在开始你的操作之前，你还可以**预先交换**任意两个 $p_i$ 和 $p_j$ 一次。

你的任务是判断：

1. 能否在不用预先交换的情况下，使得 $p$ 变为升序；
2. 如果不能，能否在预先交换一次的情况下，使得 $p$ 变为升序。

## 输入格式

本题有**多组数据**。第一行输入数据组数 $t$（$1\le t\le10^4$）。

对于每组数据，第一行输入 $n$ 和 $k$，第二行输入 $n$ 个整数，其中第 $i$ 个整数表示 $p_i$。

## 输出格式

对于每组数据：

- 如果满足条件 1 输出一行 `0`；
- 如果不满足条件 1 但满足条件 2 输出一行 `1`；
- 如果条件 1, 2 都不满足输出一行 `-1`。

## 说明/提示

$1\le t\le10^4$，$2\le n\le2\times10^5$，$1\le k\le n-1$，$1\le p_i\le n$。

每组数据的 $n$ 的总和 $\sum n\le2\times10^5$。

## 样例 #1

### 输入

```
6
4 1
3 1 2 4
4 2
3 4 1 2
4 2
3 1 4 2
10 3
4 5 9 1 8 6 10 2 3 7
10 3
4 6 9 1 8 5 10 2 3 7
10 3
4 6 9 1 8 5 10 3 2 7
```

### 输出

```
0
0
1
0
1
-1
```



---

---
title: "LuoTianyi and the Table"
layout: "post"
diff: 普及-
pid: CF1825B
tag: []
---

# LuoTianyi and the Table

## 题目描述

LuoTianyi gave an array $ b $ of $ n \cdot m $ integers. She asks you to construct a table $ a $ of size $ n \times m $ , filled with these $ n \cdot m $ numbers, and each element of the array must be used exactly once. Also she asked you to maximize the following value:

  $ \sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\left(\max\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}-\min\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}\right) $ This means that we consider $ n \cdot m $ subtables with the upper left corner in $ (1,1) $ and the bottom right corner in $ (i, j) $ ( $ 1 \le i \le n $ , $ 1 \le j \le m $ ), for each such subtable calculate the difference of the maximum and minimum elements in it, then sum up all these differences. You should maximize the resulting sum.

Help her find the maximal possible value, you don't need to reconstruct the table itself.

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 200 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 2 \le n, m \le 100 $ ) — the number of rows and columns of the table.

The second line of each test case contains $ n \cdot m $ integers $ b_1, b_2, \ldots, b_{n\cdot m} $ ( $ -10^5 \le b_{i} \le 10^5 $ ) — the numbers you can put in the table.

Note, that integers in the array $ b $ can be negative.

It is guaranteed that the sum of $ n \cdot m $ over all test cases doesn't exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the maximal value, that can be obtained.

## 说明/提示

In the first test case, the table is follows:

4113In the subtable with the bottom right corner in $ (1, 1) $ , the difference of the maximal and minimal elements is $ 4 - 4 = 0 $ .

In the subtable with the bottom right corner in $ (1, 2) $ , the difference of the maximal and minimal elements is $ 4 - 1 = 3 $ .

In the subtable with the bottom right corner in $ (2, 1) $ , the difference of the maximal and minimal elements is $ 4 - 1 = 3 $ .

In the subtable with the bottom right corner in $ (2, 2) $ , the difference of the maximal and minimal elements is $ 4 - 1 = 3 $ .

Then the maximum possible value is $ 0+3+3+3=9 $ .

In the second test case, all elements are equal, so all differences are $ 0 $ , and the answer is $ 0 $ .

## 样例 #1

### 输入

```
5
2 2
1 3 1 4
2 2
-1 -1 -1 -1
2 3
7 8 9 -3 10 8
3 2
4 8 -3 0 -7 1
4 3
-32030 59554 16854 -85927 68060 -64460 -79547 90932 85063 82703 -12001 38762
```

### 输出

```
9
0
64
71
1933711
```



---

---
title: "Trust Nobody"
layout: "post"
diff: 普及-
pid: CF1826A
tag: []
---

# Trust Nobody

## 题目描述

有由 $n$ 个人组成的群体，其中的一部分人被称为“说谎者”，总是说谎话，另一部分人总是说真话。对于 $1\leq i \leq n$ ，第 $i$ 个人说：“在我们中间至少有 $l_i$ 个人说谎话。”写一个程序判断人们所说的是矛盾的，还是可能存在的。如果是可能存在的，输出群体中说谎者的数量，如果有多种可能，输出其中任意一种即可。

## 输入格式

第一行一个整数 $t(1 \leq t \leq 1000)$ ，代表测试数据的组数。

对于每一组测试数据：
第一行一个整数 $n(1 \leq n \leq 100)$ ，代表群体中的人数。

第二行共 $n$ 个数，以空格隔开，对于 $1\leq i \leq n$，第 $i$ 个数代表 $l_i$ 。

数据保证 $\displaystyle\sum n \leq 10^4$。

## 输出格式

对于每一组测试数据，输出一个整数。如果人们所说的是矛盾的，输出 $-1$ ,否则，输出群体中说谎者的数量，如果有多种可能，输出其中任意一种即可。

## 样例 #1

### 输入

```
7
2
1 2
2
2 2
2
0 0
1
1
1
0
5
5 5 3 3 5
6
5 3 6 6 3 5
```

### 输出

```
1
-1
0
-1
0
3
4
```



---

---
title: "Lunatic Never Content"
layout: "post"
diff: 普及-
pid: CF1826B
tag: []
---

# Lunatic Never Content

## 题目描述

现在有一个数组 $a$，和 $n$ 个非负整数，定义 $f(a,x)=[a_1\bmod x,a_2\bmod x,\dots,a_n\bmod x]$，其中 $x$ 为正整数。现要你找到最大的 $x$，使得 $f(a,x)$ 是回文的。

这里，$a \bmod x$ 的含义为 $a$ 除以 $x$ 得到的余数。

我们认为一个数组是回文的，当且仅当从前往后读得到的结果和从后往前读得到的结果完全相同。换句话说，一个长度为 $n$ 的数组 $a$ 是回文的，当且仅当 $\forall 1\leq i \leq n$，有 $a_i=a_{n-i+1}$。

## 输入格式

第一行一个整数 $t(1 \leq t \leq 10^5)$，代表测试数据的组数。

对于每一组测试数据：

第一行一个整数 $n(1 \leq n \leq 10^5)$，代表数组 $a$ 的长度。

第二行共 $n$ 个数，以空格隔开，对于 $1\leq i \leq n$，第 $i$ 个数代表 $a_i$。

数据保证 $\sum n \leq 10^5$。

## 输出格式

对于每一组测试用例，输出最大的 $x$ ，使得 $f(a,x)$ 是回文的。如果 $x$ 可以为无穷大，输出 $0$ 来代替。

## 样例 #1

### 输入

```
4
2
1 2
8
3 0 1 2 0 3 2 1
1
0
3
100 1 1000000000
```

### 输出

```
1
2
0
999999900
```



---

---
title: "Permutation Swap"
layout: "post"
diff: 普及-
pid: CF1828B
tag: []
---

# Permutation Swap

## 题目描述

You are given an unsorted permutation $ p_1, p_2, \ldots, p_n $ . To sort the permutation, you choose a constant $ k $ ( $ k \ge 1 $ ) and do some operations on the permutation. In one operation, you can choose two integers $ i $ , $ j $ ( $ 1 \le j < i \le n $ ) such that $ i - j = k $ , then swap $ p_i $ and $ p_j $ .

What is the maximum value of $ k $ that you can choose to sort the given permutation?

A permutation is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2, 3, 1, 5, 4] $ is a permutation, but $ [1, 2, 2] $ is not a permutation ( $ 2 $ appears twice in the array) and $ [1, 3, 4] $ is also not a permutation ( $ n = 3 $ but there is $ 4 $ in the array).

An unsorted permutation $ p $ is a permutation such that there is at least one position $ i $ that satisfies $ p_i \ne i $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^{5} $ ) — the length of the permutation $ p $ .

The second line of each test case contains $ n $ distinct integers $ p_1, p_2, \ldots, p_n $ ( $ 1 \le p_i \le n $ ) — the permutation $ p $ . It is guaranteed that the given numbers form a permutation of length $ n $ and the given permutation is unsorted.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^{5} $ .

## 输出格式

For each test case, output the maximum value of $ k $ that you can choose to sort the given permutation.

We can show that an answer always exists.

## 说明/提示

In the first test case, the maximum value of $ k $ you can choose is $ 1 $ . The operations used to sort the permutation are:

- Swap $ p_2 $ and $ p_1 $ ( $ 2 - 1 = 1 $ ) $ \rightarrow $ $ p = [1, 3, 2] $
- Swap $ p_2 $ and $ p_3 $ ( $ 3 - 2 = 1 $ ) $ \rightarrow $ $ p = [1, 2, 3] $

In the second test case, the maximum value of $ k $ you can choose is $ 2 $ . The operations used to sort the permutation are:

- Swap $ p_3 $ and $ p_1 $ ( $ 3 - 1 = 2 $ ) $ \rightarrow $ $ p = [1, 4, 3, 2] $
- Swap $ p_4 $ and $ p_2 $ ( $ 4 - 2 = 2 $ ) $ \rightarrow $ $ p = [1, 2, 3, 4] $

## 样例 #1

### 输入

```
7
3
3 1 2
4
3 4 1 2
7
4 2 6 7 5 3 1
9
1 6 7 4 9 2 3 8 5
6
1 5 3 4 2 6
10
3 10 5 2 9 6 7 8 1 4
11
1 11 6 4 8 3 7 5 9 10 2
```

### 输出

```
1
2
3
4
3
2
3
```



---

---
title: "Gold Rush"
layout: "post"
diff: 普及-
pid: CF1829D
tag: []
---

# Gold Rush

## 题目描述

Initially you have a single pile with $ n $ gold nuggets. In an operation you can do the following:

- Take any pile and split it into two piles, so that one of the resulting piles has exactly twice as many gold nuggets as the other. (All piles should have an integer number of nuggets.)

  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1829D/7d414b1e40fe9f84ac7152f64f7f831c73043b5b.png)One possible move is to take a pile of size $ 6 $ and split it into piles of sizes $ 2 $ and $ 4 $ , which is valid since $ 4 $ is twice as large as $ 2 $ .

 Can you make a pile with exactly $ m $ gold nuggets using zero or more operations?

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases.

The only line of each test case contains two integers $ n $ and $ m $ ( $ 1 \leq n, m \leq 10^7 $ ) — the starting and target pile sizes, respectively.

## 输出格式

For each test case, output "YES" if you can make a pile of size exactly $ m $ , and "NO" otherwise.

You can output the answer in any case (for example, the strings "yEs", "yes", "Yes" and "YES" will be recognized as a positive answer).

## 说明/提示

The first test case is pictured in the statement. We can make a pile of size $ 4 $ .

In the second test case, we can perform the following operations: $ \{\color{red}{9}\} \to \{\color{red}{6},3\} \to \{4,2,3\} $ . The pile that is split apart is colored red before each operation.

In the third test case, we can't perform a single operation.

In the fourth test case, we can't end up with a larger pile than we started with.

## 样例 #1

### 输入

```
11
6 4
9 4
4 2
18 27
27 4
27 2
27 10
1 1
3 1
5 1
746001 2984004
```

### 输出

```
YES
YES
NO
NO
YES
YES
NO
YES
YES
NO
NO
```



---

---
title: "The Lakes"
layout: "post"
diff: 普及-
pid: CF1829E
tag: []
---

# The Lakes

## 题目描述

You are given an $ n \times m $ grid $ a $ of non-negative integers. The value $ a_{i,j} $ represents the depth of water at the $ i $ -th row and $ j $ -th column.

A lake is a set of cells such that:

- each cell in the set has $ a_{i,j} > 0 $ , and
- there exists a path between any pair of cells in the lake by going up, down, left, or right a number of times and without stepping on a cell with $ a_{i,j} = 0 $ .

The volume of a lake is the sum of depths of all the cells in the lake.

Find the largest volume of a lake in the grid.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains two integers $ n, m $ ( $ 1 \leq n, m \leq 1000 $ ) — the number of rows and columns of the grid, respectively.

Then $ n $ lines follow each with $ m $ integers $ a_{i,j} $ ( $ 0 \leq a_{i,j} \leq 1000 $ ) — the depth of the water at each cell.

It is guaranteed that the sum of $ n \cdot m $ over all test cases does not exceed $ 10^6 $ .

## 输出格式

For each test case, output a single integer — the largest volume of a lake in the grid.

## 样例 #1

### 输入

```
5
3 3
1 2 0
3 4 0
0 0 5
1 1
0
3 3
0 1 1
1 0 1
1 1 1
5 5
1 1 1 1 1
1 0 0 0 1
1 0 5 0 1
1 0 0 0 1
1 1 1 1 1
5 5
1 1 1 1 1
1 0 0 0 1
1 1 4 0 1
1 0 0 0 1
1 1 1 1 1
```

### 输出

```
10
0
7
16
21
```



---

---
title: "Vasya's Calendar"
layout: "post"
diff: 普及-
pid: CF182B
tag: []
---

# Vasya's Calendar

## 题目描述

Vasya lives in a strange world. The year has $ n $ months and the $ i $ -th month has $ a_{i} $ days. Vasya got a New Year present — the clock that shows not only the time, but also the date.

The clock's face can display any number from $ 1 $ to $ d $ . It is guaranteed that $ a_{i}<=d $ for all $ i $ from $ 1 $ to $ n $ . The clock does not keep information about the current month, so when a new day comes, it simply increases the current day number by one. The clock cannot display number $ d+1 $ , so after day number $ d $ it shows day $ 1 $ (the current day counter resets). The mechanism of the clock allows you to increase the day number by one manually. When you execute this operation, day $ d $ is also followed by day $ 1 $ .

Vasya begins each day checking the day number on the clock. If the day number on the clock does not match the actual day number in the current month, then Vasya manually increases it by one. Vasya is persistent and repeats this operation until the day number on the clock matches the actual number of the current day in the current month.

A year passed and Vasya wonders how many times he manually increased the day number by one, from the first day of the first month to the last day of the $ n $ -th month inclusive, considering that on the first day of the first month the clock display showed day $ 1 $ .

## 输入格式

The first line contains the single number $ d $ — the maximum number of the day that Vasya's clock can show $ (1<=d<=10^{6}) $ .

The second line contains a single integer $ n $ — the number of months in the year $ (1<=n<=2000) $ .

The third line contains $ n $ space-separated integers: $ a_{i} $ $ (1<=a_{i}<=d) $ — the number of days in each month in the order in which they follow, starting from the first one.

## 输出格式

Print a single number — the number of times Vasya manually increased the day number by one throughout the last year.

## 说明/提示

In the first sample the situation is like this:

- Day 1. Month 1. The clock shows $ 1 $ . Vasya changes nothing.
- Day 2. Month 1. The clock shows $ 2 $ . Vasya changes nothing.
- Day 1. Month 2. The clock shows $ 3 $ . Vasya manually increases the day number by $ 1 $ . After that the clock shows $ 4 $ . Vasya increases the day number by $ 1 $ manually. After that the clock shows $ 1 $ .
- Day 2. Month 2. The clock shows $ 2 $ . Vasya changes nothing.

 In total, Vasya manually changed the day number by $ 1 $ exactly $ 2 $ times.

## 样例 #1

### 输入

```
4
2
2 2

```

### 输出

```
2

```

## 样例 #2

### 输入

```
5
3
3 4 3

```

### 输出

```
3

```

## 样例 #3

### 输入

```
31
12
31 28 31 30 31 30 31 31 30 31 30 31

```

### 输出

```
7

```



---

---
title: "Array merging"
layout: "post"
diff: 普及-
pid: CF1831B
tag: []
---

# Array merging

## 题目描述

给定两个长度为 $n$ 的数组 $a$ 和 $b$。

猫猫让你合并这些数组，形成另一个长度为 $2n$ 的数组 $c$。你需要找到所有 $c$ 中元素值相同的子串长度的最大值。


合并过程是：每次选择任一非空数组中的第一个元素，将其添加到 $c$ 的末尾后从原数组中删除，这样的操作进行 $2n$ 次，直到两个数组都为空为止。

## 输入格式

第一行包含整数 $t$，表示测试数据的数量。

对于每组测试数据：

第一行一个整数 $n$，表示数组 $a$ 和 $b$ 的长度。

第二行 $n$ 个整数 $a_1,a_2,\dots,a_n$，表示数组 $a$ 的元素。

第三行 $n$ 个整数 $b_1,b_2,\dots,b_n$，表示数组 $b$ 的元素。

保证所有测试数据中 $n$ 的总和不超过 $ 2 \cdot 10^5 $。

## 输出格式

对于每个测试数据，输出跨所有合并数组 $c$ 的相等值的最大子数组的长度。

## 样例 #1

### 输入

```
4
1
2
2
3
1 2 3
4 5 6
2
1 2
2 1
5
1 2 2 2 2
2 1 1 1 1
```

### 输出

```
2
1
2
5
```



---

---
title: "New Palindrome"
layout: "post"
diff: 普及-
pid: CF1832A
tag: []
---

# New Palindrome

## 题目描述

A palindrome is a string that reads the same from left to right as from right to left. For example, abacaba, aaaa, abba, racecar are palindromes.

You are given a string $ s $ consisting of lowercase Latin letters. The string $ s $ is a palindrome.

You have to check whether it is possible to rearrange the letters in it to get another palindrome (not equal to the given string $ s $ ).

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The only line of each test case contains a string $ s $ ( $ 2 \le |s| \le 50 $ ) consisting of lowercase Latin letters. This string is a palindrome.

## 输出格式

For each test case, print YES if it is possible to rearrange the letters in the given string to get another palindrome. Otherwise, print NO.

You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).

## 说明/提示

In the first test case, it is possible to rearrange the letters in the palindrome codedoc to obtain the string ocdedco, which is different from the given string, but also a palindrome.

## 样例 #1

### 输入

```
3
codedoc
gg
aabaa
```

### 输出

```
YES
NO
NO
```



---

---
title: "Maximum Sum"
layout: "post"
diff: 普及-
pid: CF1832B
tag: []
---

# Maximum Sum

## 题目描述

You are given an array $ a_1, a_2, \dots, a_n $ , where all elements are different.

You have to perform exactly $ k $ operations with it. During each operation, you do exactly one of the following two actions (you choose which to do yourself):

- find two minimum elements in the array, and delete them;
- find the maximum element in the array, and delete it.

You have to calculate the maximum possible sum of elements in the resulting array.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of two lines:

- the first line contains two integers $ n $ and $ k $ ( $ 3 \le n \le 2 \cdot 10^5 $ ; $ 1 \le k \le 99999 $ ; $ 2k < n $ ) — the number of elements and operations, respectively.
- the second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ; all $ a_i $ are different) — the elements of the array.

Additional constraint on the input: the sum of $ n $ does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print one integer — the maximum possible sum of elements in the resulting array.

## 说明/提示

In the first testcase, applying the first operation produces the following outcome:

- two minimums are $ 1 $ and $ 2 $ ; removing them leaves the array as $ [5, 10, 6] $ , with sum $ 21 $ ;
- a maximum is $ 10 $ ; removing it leaves the array as $ [2, 5, 1, 6] $ , with sum $ 14 $ .

 $ 21 $ is the best answer.

In the second testcase, it's optimal to first erase two minimums, then a maximum.

## 样例 #1

### 输入

```
6
5 1
2 5 1 10 6
5 2
2 5 1 10 6
3 1
1 2 3
6 1
15 22 12 10 13 11
6 2
15 22 12 10 13 11
5 1
999999996 999999999 999999997 999999998 999999995
```

### 输出

```
21
11
3
62
46
3999999986
```



---

---
title: "Restore the Weather"
layout: "post"
diff: 普及-
pid: CF1833B
tag: []
---

# Restore the Weather

## 题目描述

You are given an array $ a $ containing the weather forecast for Berlandia for the last $ n $ days. That is, $ a_i $ — is the estimated air temperature on day $ i $ ( $ 1 \le i \le n $ ).

You are also given an array $ b $ — the air temperature that was actually present on each of the days. However, all the values in array $ b $ are mixed up.

Determine which day was which temperature, if you know that the weather never differs from the forecast by more than $ k $ degrees. In other words, if on day $ i $ the real air temperature was $ c $ , then the equality $ |a_i - c| \le k $ is always true.

For example, let an array $ a $ = \[ $ 1, 3, 5, 3, 9 $ \] of length $ n = 5 $ and $ k = 2 $ be given and an array $ b $ = \[ $ 2, 5, 11, 2, 4 $ \]. Then, so that the value of $ b_i $ corresponds to the air temperature on day $ i $ , we can rearrange the elements of the array $ b $ so: \[ $ 2, 2, 5, 4, 11 $ \]. Indeed:

- On the $ 1 $ st day, $ |a_1 - b_1| = |1 - 2| = 1 $ , $ 1 \le 2 = k $ is satisfied;
- On the $ 2 $ nd day $ |a_2 - b_2| = |3 - 2| = 1 $ , $ 1 \le 2 = k $ is satisfied;
- On the $ 3 $ rd day, $ |a_3 - b_3| = |5 - 5| = 0 $ , $ 0 \le 2 = k $ is satisfied;
- On the $ 4 $ th day, $ |a_4 - b_4| = |3 - 4| = 1 $ , $ 1 \le 2 = k $ is satisfied;
- On the $ 5 $ th day, $ |a_5 - b_5| = |9 - 11| = 2 $ , $ 2 \le 2 = k $ is satisfied.

## 输入格式

The first line of input data contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The description of the test cases follows.

The first line of each test case contains two integers $ n $ ( $ 1 \le n \le 10^5 $ ) and $ k $ ( $ 0 \le k \le10^9 $ ) — the number of days and the maximum difference between the expected and actual air temperature on each day.

The second line of each test case contains exactly $ n $ integers — elements of array $ a $ ( $ -10^9 \le a_i \le 10^9 $ ).

The third line of each test case contains exactly $ n $ integers — elements of array $ b $ ( $ -10^9 \le b_i \le 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ , and that the elements of array $ b $ can always be rearranged so that the equality $ |a_i - b_i| \le k $ is true for all $ i $ .

## 输出格式

On a separate line for each test case, output exactly $ n $ numbers — the values of air temperature on each of the days in the correct order.

If there is more than one answer — output any of them.

## 样例 #1

### 输入

```
3
5 2
1 3 5 3 9
2 5 11 2 4
6 1
-1 3 -2 0 -5 -1
-4 0 -1 4 0 0
3 3
7 7 7
9 4 8
```

### 输出

```
2 2 5 4 11
0 4 -1 0 -4 0
8 4 9
```



---

---
title: "Maximum Strength"
layout: "post"
diff: 普及-
pid: CF1834B
tag: []
---

# Maximum Strength

## 题目描述

Fedya is playing a new game called "The Legend of Link", in which one of the character's abilities is to combine two materials into one weapon. Each material has its own strength, which can be represented by a positive integer $ x $ . The strength of the resulting weapon is determined as the sum of the absolute differences of the digits in the decimal representation of the integers at each position.

Formally, let the first material have strength $ X = \overline{x_{1}x_{2} \ldots x_{n}} $ , and the second material have strength $ Y = \overline{y_{1}y_{2} \ldots y_{n}} $ . Then the strength of the weapon is calculated as $ |x_{1} - y_{1}| + |x_{2} - y_{2}| + \ldots + |x_{n} - y_{n}| $ . If the integers have different lengths, then the shorter integer is padded with leading zeros.

Fedya has an unlimited supply of materials with all possible strengths from $ L $ to $ R $ , inclusive. Help him find the maximum possible strength of the weapon he can obtain.

An integer $ C = \overline{c_{1}c_{2} \ldots c_{k}} $ is defined as an integer obtained by sequentially writing the digits $ c_1, c_2, \ldots, c_k $ from left to right, i.e. $ 10^{k-1} \cdot c_1 + 10^{k-2} \cdot c_2 + \ldots + c_k $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 500 $ ). The description of the test cases follows.

The first line of each test case contains two integers $ L $ and $ R $ ( $ 1 \le L \le R < 10^{100} $ ) — the decimal representation of the integers representing the minimum and maximum strength of the materials that Fedya has. It is guaranteed that the integers $ L $ and $ R $ do not contain leading zeros.

Note that the input data may not fit into standard $ 32 $ -bit or $ 64 $ -bit integer data types.

## 输出格式

For each test case print one integer — the maximum possible strength of the weapon that Fedya can obtain from the given materials.

## 说明/提示

In the first test case, the weapon made from materials with strengths $ 53 $ and $ 57 $ will have the maximum possible strength: $ |5 - 5| + |3 - 7| = 4 $ .

In the second test case, the maximum strength is achieved with materials with strengths $ 190 $ and $ 209 $ : $ |1 - 2| + |9 - 0| + |0 - 9| = 19 $ .

In the fourth test case, there is only one valid strength, so the answer is $ 0 $ .

In the sixth test case, the maximum strength is achieved with materials with strengths $ 1909 $ and $ 90 $ : $ |1 - 0| + |9 - 0| + |0 - 9| + |9 - 0| = 28 $ . Note that the shorter integer was padded with leading zeros.

## 样例 #1

### 输入

```
6
53 57
179 239
13 37
132228 132228
54943329752812629795 55157581939688863366
88 1914
```

### 输出

```
4
19
11
0
163
28
```



---

---
title: "Astrophysicists"
layout: "post"
diff: 普及-
pid: CF1836B
tag: []
---

# Astrophysicists

## 题目描述

In many, many years, far, far away, there will be a launch of the first flight to Mars. To celebrate the success, $ n $ astrophysicists working on the project will be given bonuses of a total value of $ k $ gold coins.

You have to distribute the money among the astrophysicists, and to make it easier, you have to assign bonuses in silver coins. Each gold coin is worth $ g $ silver coins, so you have to distribute all $ k \cdot g $ silver coins among $ n $ people.

Unfortunately, the company has some financial troubles right now. Therefore, instead of paying the number of silver coins written on the bonus, they decided to round this amount to the nearest integer number of gold coins.

The rounding procedure is as follows. If an astrophysicist has bonus equal to $ x $ silver coins, and we denote $ r = x \bmod g $ , then:

- If $ r \geq \lceil \frac{g}{2} \rceil $ , the astrophysicist receives $ x + (g - r) $ silver coins;
- Otherwise, an astrophysicists receives $ x - r $ silver coins.

 Note that due to rounding, the total sum of actually paid money is not, in general, equal to $ k \cdot g $ silver coins. The operation $ a \bmod b $ denotes the remainder of the division of $ a $ by $ b $ . Sum of values before rounding has to be equal to $ k \cdot g $ silver coins, but some workers can be assigned $ 0 $ silver coins.You aim to distribute the bonuses so that the company saves as many silver coins due to rounding as possible. Please note that there is always a distribution in which the company spends no more than $ k \cdot g $ silver coins.

## 输入格式

In the first line of input, there is one integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) denoting the number of test cases.

Each of the following $ t $ lines describes one test case and contains three integers $ n $ , $ k $ , $ g $ ( $ 1 \le n \le 10^9 $ , $ 0 \le k \le 10^9 $ , $ 2 \le g \le 10^9 $ ) — respectively the number of astrophysicists in the company, total number of gold coins to assign and the number of silver coins that one gold coin corresponds to.

## 输出格式

In a separate line for each test case, output a single integer — the maximum number of silver coins that could be saved due to rounding.

## 说明/提示

In the first test case, one of the optimal assignments could be the following:

- First person: $ x = 30 $ silver coins: company pays $ 0 $ , saves $ 30 $ silver coins,
- Second person: $ x = 140 $ silver coins: company pays $ 100 $ , saves $ 40 $ silver coins,
- Third person: $ x = 130 $ silver coins: company pays $ 100 $ , saves $ 30 $ silver coins.

In the second test case, we could have the following assignment:

- First person: $ x = 8 $ silver coins: company pays $ 14 $ , spends extra $ 6 $ silver coins,
- Second person: $ x = 6 $ silver coins: company pays $ 0 $ , saves $ 6 $ silver coins.

If the bonuses are assigned to $ 7 $ silver coins for both astrophysicists, then the company would have to pay an additional gold coin to cover the bonuses.

## 样例 #1

### 输入

```
5
3 3 100
2 1 14
91 2 13
36 16 6
73 8 22
```

### 输出

```
100
0
26
72
176
```



---

---
title: "Comparison String"
layout: "post"
diff: 普及-
pid: CF1837B
tag: []
---

# Comparison String

## 题目描述

You are given a string $ s $ of length $ n $ , where each character is either &lt; or &gt;.

An array $ a $ consisting of $ n+1 $ elements is compatible with the string $ s $ if, for every $ i $ from $ 1 $ to $ n $ , the character $ s_i $ represents the result of comparing $ a_i $ and $ a_{i+1} $ , i. e.:

- $ s_i $ is &lt; if and only if $ a_i < a_{i+1} $ ;
- $ s_i $ is &gt; if and only if $ a_i > a_{i+1} $ .

For example, the array $ [1, 2, 5, 4, 2] $ is compatible with the string &lt;&lt;&gt;&gt;. There are other arrays with are compatible with that string, for example, $ [13, 37, 42, 37, 13] $ .

The cost of the array is the number of different elements in it. For example, the cost of $ [1, 2, 5, 4, 2] $ is $ 4 $ ; the cost of $ [13, 37, 42, 37, 13] $ is $ 3 $ .

You have to calculate the minimum cost among all arrays which are compatible with the given string $ s $ .

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases.

Each test case consists of two lines:

- the first line contains one integer $ n $ ( $ 1 \le n \le 100 $ );
- the second line contains the string $ s $ , consisting of $ n $ characters. Each character of $ s $ is either &lt; or &gt;.

## 输出格式

For each test case, print one integer — the minimum cost among all arrays which are compatible with the given string $ s $ .

## 说明/提示

In the first test case of the example, the array can be $ [13, 37, 42, 37, 13] $ .

In the second test case of the example, the array can be $ [42, 37, 13, 37, 42] $ .

## 样例 #1

### 输入

```
4
4
<<>>
4
>><<
5
>>>>>
7
<><><><

```

### 输出

```
3
3
6
2
```



---

---
title: "Best Binary String"
layout: "post"
diff: 普及-
pid: CF1837C
tag: []
---

# Best Binary String

## 题目描述

You are given a string $ s $ consisting of the characters 0, 1 and/or ?. Let's call it a pattern.

Let's say that the binary string (a string where each character is either 0 or 1) matches the pattern if you can replace each character ? with 0 or 1 (for each character, the choice is independent) so that the strings become equal. For example, 0010 matches ?01?, but 010 doesn't match 1??, ??, or ????.

Let's define the cost of the binary string as the minimum number of operations of the form "reverse an arbitrary contiguous substring of the string" required to sort the string in non-descending order.

You have to find a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 3 \cdot 10^4 $ ) — the number of test cases.

The first and only line of each test case contains the string $ s $ ( $ 1 \le |s| \le 3 \cdot 10^5 $ ) consisting of characters 0, 1, and/or ?.

The sum of the string lengths over all test cases does not exceed $ 3 \cdot 10^5 $ .

## 输出格式

For each test case, print a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.

## 说明/提示

In the first test case of the example, the cost of the resulting string is $ 0 $ .

In the second test case, the cost of the resulting string is $ 2 $ : we can reverse the substring from the $ 1 $ -st character to the $ 5 $ -th character, and we obtain the string 00101. Then we reverse the substring from the $ 3 $ -rd to the $ 4 $ -th character, and we obtain the string 00011, which is sorted in non-descending order.

## 样例 #1

### 输入

```
4
??01?
10100
1??10?
0?1?10?10
```

### 输出

```
00011
10100
111101
011110010
```



---

---
title: "Blackboard List"
layout: "post"
diff: 普及-
pid: CF1838A
tag: []
---

# Blackboard List

## 题目描述

Two integers were written on a blackboard. After that, the following step was carried out $ n-2 $ times:

- Select any two integers on the board, and write the absolute value of their difference on the board.

After this process was complete, the list of $ n $ integers was shuffled. You are given the final list. Recover one of the initial two numbers. You do not need to recover the other one.

You are guaranteed that the input can be generated using the above process.

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 3 \le n \le 100 $ ) — the size of the final list.

The next line of each test case contains $ n $ integers $ a_1, a_2, \ldots a_n $ ( $ -10^9 \le a_i \le 10^9 $ ) — the shuffled list of numbers written on the blackboard.

It is guaranteed that the input was generated using the process described above.

## 输出格式

For each test case, output a single integer $ x $ — one of the two initial numbers on the blackboard.

If there are multiple solutions, print any of them.

## 说明/提示

For the first test case, $ a $ can be produced by starting with either $ 9 $ and $ 2 $ , and then writing down $ |9-2|=7 $ , or starting with $ 9 $ and $ 7 $ and writing down $ |9-7|=2 $ . So $ 2 $ , $ 7 $ , and $ 9 $ are all valid answers, because they all appear in at least one valid pair.

For the second test case, we can show that the two initial numbers must have been $ -4 $ and $ 11 $ .

For the fourth test case, the starting numbers could have been either $ 3 $ and $ 3 $ , or $ 3 $ and $ 0 $ , so $ 3 $ and $ 0 $ are both valid answers.

For the fifth test case, we can show that the starting numbers were $ 8 $ and $ 16 $ .

## 样例 #1

### 输入

```
9
3
9 2 7
3
15 -4 11
4
-9 1 11 -10
5
3 0 0 0 3
7
8 16 8 0 8 16 8
4
0 0 0 0
10
27 1 24 28 2 -1 26 25 28 27
6
600000000 800000000 0 -200000000 1000000000 800000000
3
0 -1000000000 1000000000
```

### 输出

```
9
11
-9
3
8
0
-1
600000000
0
```



---

---
title: "Minimize Permutation Subarrays"
layout: "post"
diff: 普及-
pid: CF1838B
tag: []
---

# Minimize Permutation Subarrays

## 题目描述

You are given a permutation $ p $ of size $ n $ . You want to minimize the number of subarrays of $ p $ that are permutations. In order to do so, you must perform the following operation exactly once:

- Select integers $ i $ , $ j $ , where $ 1 \le i, j \le n $ , then
- Swap $ p_i $ and $ p_j $ .

For example, if $ p = [5, 1, 4, 2, 3] $ and we choose $ i = 2 $ , $ j = 3 $ , the resulting array will be $ [5, 4, 1, 2, 3] $ . If instead we choose $ i = j = 5 $ , the resulting array will be $ [5, 1, 4, 2, 3] $ .

Which choice of $ i $ and $ j $ will minimize the number of subarrays that are permutations?

A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array).

An array $ a $ is a subarray of an array $ b $ if $ a $ can be obtained from $ b $ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 3 \le n \le 2\cdot 10^5 $ ) — the size of the permutation.

The next line of each test case contains $ n $ integers $ p_1, p_2, \ldots p_n $ ( $ 1 \le p_i \le n $ , all $ p_i $ are distinct) — the elements of the permutation $ p $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, output two integers $ i $ and $ j $ ( $ 1 \le i, j \le n $ ) — the indices to swap in $ p $ .

If there are multiple solutions, print any of them.

## 说明/提示

For the first test case, there are four possible arrays after the swap:

- If we swap $ p_1 $ and $ p_2 $ , we get the array $ [2, 1, 3] $ , which has 3 subarrays that are permutations ( $ [1] $ , $ [2, 1] $ , $ [2, 1, 3] $ ).
- If we swap $ p_1 $ and $ p_3 $ , we get the array $ [3, 2, 1] $ , which has 3 subarrays that are permutations ( $ [1] $ , $ [2, 1] $ , $ [3, 2, 1] $ ).
- If we swap $ p_2 $ and $ p_3 $ , we get the array $ [1, 3, 2] $ , which has 2 subarrays that are permutations ( $ [1] $ , $ [1, 3, 2] $ ).
- If we swap any element with itself, we get the array $ [1, 2, 3] $ , which has 3 subarrays that are permutations ( $ [1] $ , $ [1, 2] $ , $ [1, 2, 3] $ ).

 So the best swap to make is positions $ 2 $ and $ 3 $ .For the third sample case, after we swap elements at positions $ 2 $ and $ 5 $ , the resulting array is $ [1, 4, 2, 5, 3] $ . The only subarrays that are permutations are $ [1] $ and $ [1, 4, 2, 5, 3] $ . We can show that this is minimal.

## 样例 #1

### 输入

```
8
3
1 2 3
3
1 3 2
5
1 3 2 5 4
6
4 5 6 1 2 3
9
8 7 6 3 2 1 4 5 9
10
7 10 5 1 9 8 3 2 6 4
10
8 5 10 9 2 1 3 4 6 7
10
2 3 5 7 10 1 8 6 4 9
```

### 输出

```
2 3
1 1
5 2
1 4
9 5
8 8
6 10
5 4
```



---

---
title: "Lamps"
layout: "post"
diff: 普及-
pid: CF1839B
tag: []
---

# Lamps

## 题目描述

You have $ n $ lamps, numbered by integers from $ 1 $ to $ n $ . Each lamp $ i $ has two integer parameters $ a_i $ and $ b_i $ .

At each moment each lamp is in one of three states: it may be turned on, turned off, or broken.

Initially all lamps are turned off. In one operation you can select one lamp that is turned off and turn it on (you can't turn on broken lamps). You receive $ b_i $ points for turning lamp $ i $ on. The following happens after each performed operation:

- Let's denote the number of lamps that are turned on as $ x $ (broken lamps do not count). All lamps $ i $ such that $ a_i \le x $ simultaneously break, whether they were turned on or off.

Please note that broken lamps never count as turned on and that after a turned on lamp breaks, you still keep points received for turning it on.

You can perform an arbitrary number of operations.

Find the maximum number of points you can get.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of lamps.

Each of the next $ n $ lines contains two integers $ a_i $ and $ b_i $ ( $ 1 \le a_i \le n, 1 \le b_i \le 10^9 $ ) — parameters of the $ i $ -th lamp.

It is guaranteed that sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output one integer — the maximum number of points you can get.

## 说明/提示

In first test case $ n = 4 $ . One of ways to get the maximum number of points is as follows:

- You turn lamp $ 4 $ on and receive $ b_4 = 13 $ points.
- The number of lamps that are turned on is $ 1 $ , so all lamps with $ a_i \le 1 $ (namely lamps $ 2 $ , $ 3 $ and $ 4 $ ) break. Lamp $ 4 $ is no longer turned on, so the number of lamps that are turned becomes $ 0 $ .
- The only lamp you can turn on is lamp $ 1 $ , as all other lamps are broken. You receive $ b_1 = 2 $ points for turning it on.
- The number of lamps that are turned on is $ 1 $ . As $ a_1 = 2 $ , lamp $ 1 $ doesn't break.

Your receive $ 13 + 2 = 15 $ points in total. It can be shown that this is the maximum number of points you can get, so the answer for the first test case is $ 15 $ .

In the second test case, one of the ways to get the maximum number of points is as follows:

- On the first operation you turn on lamp $ 4 $ and receive $ 2 $ points. No lamps break after the first operation.
- On the second operation you turn on lamp $ 3 $ and receive $ 5 $ points. After the second operation, there are $ 2 $ lamps turned on. As $ a_3 \le 2 $ , lamp $ 3 $ breaks.
- On the third operation, you turn on lamp $ 1 $ and receive $ 4 $ points.
- On the fourth operation, you turn on lamp $ 5 $ and receive $ 3 $ points. After that there are $ 3 $ lamps turned on: lamps $ 1 $ , $ 4 $ and $ 5 $ . Lamps $ 1 $ , $ 2 $ , $ 4 $ and $ 5 $ simultaneously break, because for all of them $ a_i \le 3 $ .

You receive $ 2 + 5 + 4 + 3 = 14 $ points in total. It can be shown that this is the maximum number of points you can get.

In the third test case, one of the ways to get the maximum number of points is as follows:

- Turn the lamp $ 3 $ on and receive $ 4 $ points. Lamps $ 1 $ and $ 3 $ break.
- Turn the lamp $ 2 $ on and receive $ 4 $ points.
- Turn the lamp $ 6 $ on and receive $ 3 $ points. Lamp $ 6 $ breaks.
- Turn the lamp $ 4 $ on and receive $ 4 $ points.
- Turn the lamp $ 5 $ on and receive $ 5 $ points. Lamps $ 2 $ , $ 4 $ and $ 5 $ break.

You receive $ 4 + 4 + 3 + 4 + 5 = 20 $ points in total. It can be shown that this is the maximum number of points you can get.

## 样例 #1

### 输入

```
4
4
2 2
1 6
1 10
1 13
5
3 4
3 1
2 5
3 2
3 3
6
1 2
3 4
1 4
3 4
3 5
2 3
1
1 1
```

### 输出

```
15
14
20
1
```



---

---
title: "Binary Cafe"
layout: "post"
diff: 普及-
pid: CF1840B
tag: []
---

# Binary Cafe

## 题目描述

Once upon a time, Toma found himself in a binary cafe. It is a very popular and unusual place.

The cafe offers visitors $ k $ different delicious desserts. The desserts are numbered from $ 0 $ to $ k-1 $ . The cost of the $ i $ -th dessert is $ 2^i $ coins, because it is a binary cafe! Toma is willing to spend no more than $ n $ coins on tasting desserts. At the same time, he is not interested in buying any dessert more than once, because one is enough to evaluate the taste.

In how many different ways can he buy several desserts (possibly zero) for tasting?

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

Then follows $ t $ lines, each of which describes one test case.

Each test case is given on a single line and consists of two integers $ n $ and $ k $ ( $ 1 \le n, k \le 10^9 $ ) — the number of coins Toma is willing to spend and the number of desserts in the binary cafe.

## 输出格式

Output $ t $ integers, the $ i $ -th of which should be equal to the answer for the $ i $ -th test case — the number of ways to buy desserts for tasting.

## 说明/提示

Variants for 1st sample: {}, {1}

Variants for 2nd sample: {}, {1}

Variants for 3rd sample: {}, {1}, {2}

Variants for 4th sample: {}, {1}, {2}, {1, 2}

## 样例 #1

### 输入

```
5
1 2
2 1
2 2
10 2
179 100
```

### 输出

```
2
2
3
4
180
```



---

---
title: "Ski Resort"
layout: "post"
diff: 普及-
pid: CF1840C
tag: []
---

# Ski Resort

## 题目描述

Dima Vatrushin is a math teacher at school. He was sent on vacation for $ n $ days for his good work. Dima has long dreamed of going to a ski resort, so he wants to allocate several consecutive days and go skiing. Since the vacation requires careful preparation, he will only go for at least $ k $ days.

You are given an array $ a $ containing the weather forecast at the resort. That is, on the $ i $ -th day, the temperature will be $ a_i $ degrees.

Dima was born in Siberia, so he can go on vacation only if the temperature does not rise above $ q $ degrees throughout the vacation.

Unfortunately, Dima was so absorbed in abstract algebra that he forgot how to count. He asks you to help him and count the number of ways to choose vacation dates at the resort.

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Then follow the descriptions of the test cases.

The first line of each test case contains three integers $ n $ , $ k $ , $ q $ ( $ 1 \le n \le 2 \cdot 10^5 $ , $ 1 \le k \le n $ , $ -10^9 \le q \le 10^9 $ ) — the length of the array $ a $ , the minimum number of days at the resort, and the maximum comfortable temperature for Dima.

The second line of each test case contains $ n $ integers $ a_1, a_2, a_3, \dots, a_n $ ( $ -10^9 \le a_i \le 10^9 $ ) — the temperature at the ski resort.

The sum of all $ n $ values over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

Output $ t $ integers, each of which is the answer to the corresponding test case — the number of ways for Dima to choose vacation dates at the resort.

## 说明/提示

In the first test case of the example, Dima can go on any day, so the suitable dates for him are \[1\], \[2\], \[3\], \[1, 2\], \[2, 3\], \[1, 2, 3\].

In the second and fourth test cases of the example, Dima cannot go on any day due to the high temperature, so there are no suitable dates.

In the third test case of the example, Dima can only go on the dates \[1, 2, 3\].

## 样例 #1

### 输入

```
7
3 1 15
-5 0 -10
5 3 -33
8 12 9 0 5
4 3 12
12 12 10 15
4 1 -5
0 -1 2 5
5 5 0
3 -1 4 -5 -3
1 1 5
5
6 1 3
0 3 -2 5 -4 -4
```

### 输出

```
6
0
1
0
0
1
9
```



---

---
title: "Keep it Beautiful"
layout: "post"
diff: 普及-
pid: CF1841B
tag: []
---

# Keep it Beautiful

## 题目描述

The array $ [a_1, a_2, \dots, a_k] $ is called beautiful if it is possible to remove several (maybe zero) elements from the beginning of the array and insert all these elements to the back of the array in the same order in such a way that the resulting array is sorted in non-descending order.

In other words, the array $ [a_1, a_2, \dots, a_k] $ is beautiful if there exists an integer $ i \in [0, k-1] $ such that the array $ [a_{i+1}, a_{i+2}, \dots, a_{k-1}, a_k, a_1, a_2, \dots, a_i] $ is sorted in non-descending order.

For example:

- $ [3, 7, 7, 9, 2, 3] $ is beautiful: we can remove four first elements and insert them to the back in the same order, and we get the array $ [2, 3, 3, 7, 7, 9] $ , which is sorted in non-descending order;
- $ [1, 2, 3, 4, 5] $ is beautiful: we can remove zero first elements and insert them to the back, and we get the array $ [1, 2, 3, 4, 5] $ , which is sorted in non-descending order;
- $ [5, 2, 2, 1] $ is not beautiful.

Note that any array consisting of zero elements or one element is beautiful.

You are given an array $ a $ , which is initially empty. You have to process $ q $ queries to it. During the $ i $ -th query, you will be given one integer $ x_i $ , and you have to do the following:

- if you can append the integer $ x_i $ to the back of the array $ a $ so that the array $ a $ stays beautiful, you have to append it;
- otherwise, do nothing.

After each query, report whether you appended the given integer $ x_i $ , or not.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of two lines. The first line contains one integer $ q $ ( $ 1 \le q \le 2 \cdot 10^5 $ ) — the number of queries. The second line contains $ q $ integers $ x_1, x_2, \dots, x_q $ ( $ 0 \le x_i \le 10^9 $ ).

Additional constraint on the input: the sum of $ q $ over all test cases does not exceed $ 2 \cdot 10^5 $ ).

## 输出格式

For each test case, print one string consisting of exactly $ q $ characters. The $ i $ -th character of the string should be 1 if you appended the integer during the $ i $ -th query; otherwise, it should be 0.

## 说明/提示

Consider the first test case of the example. Initially, the array is $ [] $ .

- trying to append an integer $ 3 $ . The array $ [3] $ is beautiful, so we append $ 3 $ ;
- trying to append an integer $ 7 $ . The array $ [3, 7] $ is beautiful, so we append $ 7 $ ;
- trying to append an integer $ 7 $ . The array $ [3, 7, 7] $ is beautiful, so we append $ 7 $ ;
- trying to append an integer $ 9 $ . The array $ [3, 7, 7, 9] $ is beautiful, so we append $ 9 $ ;
- trying to append an integer $ 2 $ . The array $ [3, 7, 7, 9, 2] $ is beautiful, so we append $ 2 $ ;
- trying to append an integer $ 4 $ . The array $ [3, 7, 7, 9, 2, 4] $ is not beautiful, so we don't append $ 4 $ ;
- trying to append an integer $ 6 $ . The array $ [3, 7, 7, 9, 2, 6] $ is not beautiful, so we don't append $ 6 $ ;
- trying to append an integer $ 3 $ . The array $ [3, 7, 7, 9, 2, 3] $ is beautiful, so we append $ 3 $ ;
- trying to append an integer $ 4 $ . The array $ [3, 7, 7, 9, 2, 3, 4] $ is not beautiful, so we don't append $ 4 $ .

## 样例 #1

### 输入

```
3
9
3 7 7 9 2 4 6 3 4
5
1 1 1 1 1
5
3 2 1 2 3
```

### 输出

```
111110010
11111
11011
```



---

---
title: "Tenzing and Books"
layout: "post"
diff: 普及-
pid: CF1842B
tag: []
---

# Tenzing and Books

## 题目描述

Tenzing received $ 3n $ books from his fans. The books are arranged in $ 3 $ stacks with $ n $ books in each stack. Each book has a non-negative integer difficulty rating.

Tenzing wants to read some (possibly zero) books. At first, his knowledge is $ 0 $ .

To read the books, Tenzing will choose a non-empty stack, read the book on the top of the stack, and then discard the book. If Tenzing's knowledge is currently $ u $ , then his knowledge will become $ u|v $ after reading a book with difficulty rating $ v $ . Here $ | $ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Note that Tenzing can stop reading books whenever he wants.

Tenzing's favourite number is $ x $ . Can you help Tenzing check if it is possible for his knowledge to become $ x $ ?

## 输入格式

Each test contains multiple test cases. The first line of input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains two integers $ n $ and $ x $ ( $ 1 \leq n \leq 10^5 $ , $ 0 \leq x \leq 10^9 $ ) — the number of books in each stack and Tenzing's favourite number.

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 0 \leq a_i \leq 10^9 $ ) — the difficulty rating of the books in the first stack, from top to bottom.

The third line of each test case contains $ n $ integers $ b_1,b_2,\ldots,b_n $ ( $ 0 \leq b_i \leq 10^9 $ ) — the difficulty rating of the books in the second stack, from top to bottom.

The fourth line of each test case contains $ n $ integers $ c_1,c_2,\ldots,c_n $ ( $ 0 \leq c_i \leq 10^9 $ ) — the difficulty rating of the books in the third stack, from top to bottom.

It is guaranteed that the sum of $ n $ does not exceed $ 10^5 $ .

## 输出格式

For each test case, output "Yes" (without quotes) if Tenzing can make his knowledge equal to $ x $ , and "No" (without quotes) otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

For the first test case, Tenzing can read the following $ 4 $ books:

- read the book with difficulty rating $ 1 $ on the top of the first stack. Tenzing's knowledge changes to $ 0|1=1 $ .
- read the book with difficulty rating $ 1 $ on the top of the third stack. Tenzing's knowledge changes to $ 1|1=1 $ .
- read the book with difficulty rating $ 2 $ on the top of the first stack. Tenzing's knowledge changes to $ 1|2=3 $ .
- read the book with difficulty rating $ 5 $ on the top of the second stack. Tenzing's knowledge changes to $ 3|5=7 $ .

After reading all books, Tenzing's knowledge is $ 7 $ .

For the third test case, Tenzing can read $ 0 $ books to make his final knowledge equals to $ 0 $ .

## 样例 #1

### 输入

```
3
5 7
1 2 3 4 5
5 4 3 2 1
1 3 5 7 9
5 2
3 2 3 4 5
5 4 3 2 1
3 3 5 7 9
3 0
1 2 3
3 2 1
2 2 2
```

### 输出

```
Yes
No
Yes
```



---

---
title: "Long Long"
layout: "post"
diff: 普及-
pid: CF1843B
tag: []
---

# Long Long

## 题目描述

给出一个包含 $n$ 个数字的数列 $a$。你可以执行任意次操作，每次操作可以更改 [l, r] 范围内的正负性（正数变负，负数变正，0 不变）。你要使得数列每个元素之和尽量大，问最小的操作次数。

多组询问。

## 输入格式

第一行一个整数 $T$，表示询问组数。

每一组数据第一行输入一个整数 $n$，表述数列长度。

第二行 $n$ 个整数 $a_1,a_2,...,a_n​$ 表示数列 $a$ 中的每个元素。

## 输出格式

对于每组数据，每一行，输出两个用空格隔开的整数，分别表示最大可能的数列元素之和与最小操作次数。

## 说明/提示

$1\leq T \leq 10^4$

$1\leq n \leq 2\times10^5$

$-10^9\leq a_i \leq 10^9$

数据保证所有询问的 $n$ 总和不超过 $2\times10^5$。

统计数字之和部分可能会爆 int，请选择合适的储存方式。

## 样例 #1

### 输入

```
5
6
-1 7 -4 -2 5 -8
8
-1 0 0 -2 1 0 -3 0
5
2 -1 0 -3 -7
5
0 -17 0 1 0
4
-1 0 -2 -1
```

### 输出

```
27 3
7 2
13 1
18 1
4 1
```



---

---
title: "Sum in Binary Tree"
layout: "post"
diff: 普及-
pid: CF1843C
tag: []
---

# Sum in Binary Tree

## 题目描述

Vanya really likes math. One day when he was solving another math problem, he came up with an interesting tree. This tree is built as follows.

Initially, the tree has only one vertex with the number $ 1 $ — the root of the tree. Then, Vanya adds two children to it, assigning them consecutive numbers — $ 2 $ and $ 3 $ , respectively. After that, he will add children to the vertices in increasing order of their numbers, starting from $ 2 $ , assigning their children the minimum unused indices. As a result, Vanya will have an infinite tree with the root in the vertex $ 1 $ , where each vertex will have exactly two children, and the vertex numbers will be arranged sequentially by layers.

 ![](https://espresso.codeforces.com/3fe851b2505ce276dabd4a63ad7472346f98f9a8.png) Part of Vanya's tree.Vanya wondered what the sum of the vertex numbers on the path from the vertex with number $ 1 $ to the vertex with number $ n $ in such a tree is equal to. Since Vanya doesn't like counting, he asked you to help him find this sum.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

This is followed by $ t $ lines — the description of the test cases. Each line contains one integer $ n $ ( $ 1 \le n \le 10^{16} $ ) — the number of vertex for which Vanya wants to count the sum of vertex numbers on the path from the root to that vertex.

## 输出格式

For each test case, print one integer — the desired sum.

## 说明/提示

In the first test case of example on the path from the root to the vertex $ 3 $ there are two vertices $ 1 $ and $ 3 $ , their sum equals $ 4 $ .

In the second test case of example on the path from the root to the vertex with number $ 10 $ there are vertices $ 1 $ , $ 2 $ , $ 5 $ , $ 10 $ , sum of their numbers equals $ 1+2+5+10 = 18 $ .

## 样例 #1

### 输入

```
6
3
10
37
1
10000000000000000
15
```

### 输出

```
4
18
71
1
19999999999999980
26
```



---

---
title: "Permutations & Primes"
layout: "post"
diff: 普及-
pid: CF1844B
tag: []
---

# Permutations & Primes

## 题目描述

You are given a positive integer $ n $ .

In this problem, the $ \operatorname{MEX} $ of a collection of integers $ c_1,c_2,\dots,c_k $ is defined as the smallest positive integer $ x $ which does not occur in the collection $ c $ .

The primality of an array $ a_1,\dots,a_n $ is defined as the number of pairs $ (l,r) $ such that $ 1 \le l \le r \le n $ and $ \operatorname{MEX}(a_l,\dots,a_r) $ is a prime number.

Find any permutation of $ 1,2,\dots,n $ with the maximum possible primality among all permutations of $ 1,2,\dots,n $ .

Note:

- A prime number is a number greater than or equal to $ 2 $ that is not divisible by any positive integer except $ 1 $ and itself. For example, $ 2,5,13 $ are prime numbers, but $ 1 $ and $ 6 $ are not prime numbers.
- A permutation of $ 1,2,\dots,n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array).

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The only line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output $ n $ integers: a permutation of $ 1,2,\dots,n $ that achieves the maximum possible primality.

If there are multiple solutions, print any of them.

## 说明/提示

In the first test case, there are $ 3 $ pairs $ (l,r) $ with $ 1 \le l \le r \le 2 $ , out of which $ 2 $ have a prime $ \operatorname{MEX}(a_l,\dots,a_r) $ :

- $ (l,r) = (1,1) $ : $ \operatorname{MEX}(2) = 1 $ , which is not prime.
- $ (l,r) = (1,2) $ : $ \operatorname{MEX}(2,1) = 3 $ , which is prime.
- $ (l,r) = (2,2) $ : $ \operatorname{MEX}(1) = 2 $ , which is prime.

 Therefore, the primality is $ 2 $ .In the second test case, $ \operatorname{MEX}(1) = 2 $ is prime, so the primality is $ 1 $ .

In the third test case, the maximum possible primality is $ 8 $ .

## 样例 #1

### 输入

```
3
2
1
5
```

### 输出

```
2 1
1
5 2 1 4 3
```



---

---
title: "Come Together"
layout: "post"
diff: 普及-
pid: CF1845B
tag: []
---

# Come Together

## 题目描述

Bob and Carol hanged out with Alice the whole day, but now it's time to go home. Alice, Bob and Carol live on an infinite 2D grid in cells $ A $ , $ B $ , and $ C $ respectively. Right now, all of them are in cell $ A $ .

If Bob (or Carol) is in some cell, he (she) can move to one of the neighboring cells. Two cells are called neighboring if they share a side. For example, the cell $ (3, 5) $ has four neighboring cells: $ (2, 5) $ , $ (4, 5) $ , $ (3, 6) $ and $ (3, 4) $ .

Bob wants to return to the cell $ B $ , Carol — to the cell $ C $ . Both of them want to go along the shortest path, i. e. along the path that consists of the minimum possible number of cells. But they would like to walk together as well.

What is the maximum possible number of cells that Bob and Carol can walk together if each of them walks home using one of the shortest paths?

## 输入格式

The first line contains the single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains two integers $ x_A $ and $ y_A $ ( $ 1 \le x_A, y_A \le 10^8 $ ) — the position of cell $ A $ , where both Bob and Carol are right now.

The second line contains two integers $ x_B $ and $ y_B $ ( $ 1 \le x_B, y_B \le 10^8 $ ) — the position of cell $ B $ (Bob's house).

The third line contains two integers $ x_C $ and $ y_C $ ( $ 1 \le x_C, y_C \le 10^8 $ ) — the position of cell $ C $ (Carol's house).

Additional constraint on the input: the cells $ A $ , $ B $ , and $ C $ are pairwise distinct in each test case.

## 输出格式

For each test case, print the single integer — the maximum number of cells Bob and Carol can walk together if each of them goes home along one of the shortest paths.

## 说明/提示

In all pictures, red color denotes cells belonging only to Bob's path, light blue color — cells belonging only to Carol's path, and dark blue color — cells belonging to both paths.

One of the optimal routes for the first test case is shown below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1845B/c85b53d9d1c53dba5706a67df1e77b327570237d.png)  Bob's route contains $ 5 $ cells, Carol's route — $ 7 $ cells, and they will visit $ 3 $ cells together.The optimal answer for the second test case is shown below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1845B/50a4de29eccf387d8021b4c4d1c44c0fb0d1aede.png)  Bob's route contains $ 4 $ cells, Carol's route — $ 3 $ cells, and they will visit only $ 1 $ cell together.One of the optimal answers for the third test case is shown below:

 ![](https://espresso.codeforces.com/c353903c5672ef730d834c0e4d58e6d3554a4b1b.png)  Bob's route contains $ 6 $ cells, Carol's route — $ 9 $ cells, and they will visit $ 6 $ cells together.

## 样例 #1

### 输入

```
3
3 1
1 3
6 4
5 2
2 2
7 2
1 1
4 3
5 5
```

### 输出

```
3
1
6
```



---

---
title: "Hamon Odyssey"
layout: "post"
diff: 普及-
pid: CF1847B
tag: []
---

# Hamon Odyssey

## 题目描述

乔纳森正在与迪奥的吸血鬼手下战斗。其中有 $n$ 个吸血鬼，它们的强度分别为 $a_1, a_2,\cdots, a_n$。
将 $(l,r)$ 表示由索引 $l$ 到 $r$ 的吸血鬼组成的一组。乔纳森意识到每个这样的组的强度取决于它们的最弱环节，即按位与操作。更具体地说，组 $(l,r)$ 的强度等于 $f(l,r) =$ $a_l \ \& \ a_{l+1} \ \& \ a_{l+2} \ \& \cdots \&  \ a_r$。这里，$\&$ 表示按位与操作。

乔纳森希望能快速击败这些吸血鬼手下，因此他会将吸血鬼分成连续的组，使得每个吸血鬼正好属于一组，并且这些组的强度之和尽量小。在所有可能的分组方式中，他希望找到组数最多的方式。

给定每个吸血鬼的强度，找出在所有可能的分组方式中，拥有最小强度之和的组的最大数量。

## 输入格式

第一行包含一个整数 $t$ $(1 \le t \le 10^4)$，表示测试用例的数量。接下来是每个测试用例的描述。

每个测试用例的第一行包含一个整数 $n$ $(1 \le n \le 2⋅10^5)$，表示吸血鬼的数量。

每个测试用例的第二行包含 $n$ 个整数 $a_1, a_2, \cdots, a_n$ $(0 \le a_i \le 10^9)$，表示每个吸血鬼的个体强度。

所有测试用例中 $n$ 的总和不超过 $2⋅10^5$。

## 输出格式

对于每个测试用例，输出一个整数，表示在所有可能的分组方式中，拥有最小强度之和的组的最大数量。

#### 样例解释

在第一个测试用例中，最优的方式是将所有的吸血鬼作为一组。所以 $f(1,3) = $$1 \ \& \ 2 \ \& \ 3 = 0$。

在第二个测试用例中，最优的方式是分成两组，$(2,3,1)$ 和 $(5,2)$。所以 $f(1,3) + f(4,5) = (2 \ \&  \ 3 \ \& \ 1) + (5 \ \& \ 2) = 0 + 0 = 0$。

Translate by @[ZeXic_B](https://www.luogu.com.cn/user/661274).

## 样例 #1

### 输入

```
3
3
1 2 3
5
2 3 1 5 2
4
5 7 12 6
```

### 输出

```
1
2
1
```



---

---
title: "Vika and Her Friends"
layout: "post"
diff: 普及-
pid: CF1848A
tag: []
---

# Vika and Her Friends

## 题目描述

# Vika和她的朋友们


Vika和她的朋友们去了一个购物中心，可以将其表示为一个边长为 $n$ 和 $m$ 的矩形网格的房间。每个房间都有坐标 $(a, b)$，其中 $1 \leq a \leq n, 1 \leq b \leq m$。因此，我们将具有坐标 $(c, d)$ 的大厅称为其邻居，如果 $|a-c| + |b-d| = 1$。

厌倦了空洞的时尚交谈，Vika决定悄悄溜走。但是由于她还没有机会参观其中一家商店，她不想离开购物中心。过了一会儿，她的朋友们注意到Vika的失踪，并开始寻找她。

目前，Vika位于坐标 $(x, y)$ 的房间中，她的 $k$ 个朋友分别位于坐标为 $(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$ 的房间中。坐标可以重合。请注意，所有女孩都必须移动到相邻的房间。

每分钟，首先Vika移动到她选择的一个侧面相邻的房间，然后每个朋友（看到Vika的选择）也选择一个相邻的房间移动。

如果在一分钟结束时（即，在所有女孩都移动到相邻的房间之后），至少有一个朋友与Vika在同一个房间中，她被抓住，其他所有朋友都被叫走。

告诉我们，Vika能否永远逃离她烦人的朋友，还是她将不得不继续听空洞的时尚交谈？

## 输入格式

每个测试由多个测试用例组成。第一行包含一个整数 $t$（$1 \leq t \leq 100$） - 测试用例的数量。以下是测试用例的描述。

每个测试用例的第一行包含三个整数 $n, m, k$（$1 \leq n, m, k \leq 100$） - 商场的大小和 Vika 的朋友数量。

每个测试用例的第二行包含一对整数 $x$ 和 $y$（$1 \leq x \leq n, 1 \leq y \leq m$）- Vika所在房间的坐标。

每个测试用例的接下来的$k$行中的每一行包含一对整数 $x_i$ 和 $y_i$（$1 \leq x_i \leq n, 1 \leq y_i \leq m$）- 第 $i$ 个朋友所在的房间的坐标。

## 输出格式

对于每个测试用例，如果Vika可以永远逃离她的朋友，则输出"YES"，否则输出"NO"。

您可以以任何大小写形式输出每个字母（小写或大写）。例如，字符串"yEs"，"yes"，"Yes"和"YES"将被接受为肯定答案。

## 样例＃1

### 示例输入＃1

```
6
2 2 1
1 1
1 2
2 2 2
1 1
2 2
2 2
1 2 1
1 1
1 2
5 5 4
3 3
1 1
1 5
5 1
5 5
2 2 2
1 1
2 1
1 2
3 4 1
1 2
3 3
```

### 样例输出＃1

```
YES
NO
YES
NO
YES
YES
```

## 说明/提示

在第一个测试用例中，朋友永远无法赶上Vika，因为Vika总是可以移动到与朋友所在的房间对角相对的房间。

在第二个测试用例中，无论Vika去哪里，她的每个朋友都可以在第一次移动后抓住她。

在第三个测试用例中，Vika和她的朋友始终在不同的大厅中。

## 样例 #1

### 输入

```
6
2 2 1
1 1
1 2
2 2 2
1 1
2 2
2 2
1 2 1
1 1
1 2
5 5 4
3 3
1 1
1 5
5 1
5 5
2 2 2
1 1
2 1
1 2
3 4 1
1 2
3 3
```

### 输出

```
YES
NO
YES
NO
YES
YES
```



---

---
title: "Monsters"
layout: "post"
diff: 普及-
pid: CF1849B
tag: []
---

# Monsters

## 题目描述

Monocarp is playing yet another computer game. And yet again, his character is killing some monsters. There are $ n $ monsters, numbered from $ 1 $ to $ n $ , and the $ i $ -th of them has $ a_i $ health points initially.

Monocarp's character has an ability that deals $ k $ damage to the monster with the highest current health. If there are several of them, the one with the smaller index is chosen. If a monster's health becomes less than or equal to $ 0 $ after Monocarp uses his ability, then it dies.

Monocarp uses his ability until all monsters die. Your task is to determine the order in which monsters will die.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le n \le 3 \cdot 10^5 $ ; $ 1 \le k \le 10^9 $ ) — the number of monsters and the damage which Monocarp's ability deals.

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the initial health points of monsters.

The sum of $ n $ over all test cases doesn't exceed $ 3 \cdot 10^5 $ .

## 输出格式

For each test case, print $ n $ integers — the indices of monsters in the order they die.

## 说明/提示

In the first example, the health points change as follows: $ [1, 2, \underline{3}] \rightarrow [1, \underline{2}, 1] \rightarrow [\underline{1}, 0, 1] \rightarrow [-1, 0, \underline{1}] \rightarrow [-1, 0, -1] $ . The monster that is going to take damage the next time Monocarp uses his ability is underlined.

In the second example, the health points change as follows: $ [\underline{1}, 1] \rightarrow [-2, \underline{1}] \rightarrow [-2, -2] $ .

In the third example, the health points change as follows: $ [2, \underline{8}, 3, 5] \rightarrow [2, \underline{5}, 3, 5] \rightarrow [2, 2, 3, \underline{5}] \rightarrow [2, 2, \underline{3}, 2] \rightarrow [\underline{2}, 2, 0, 2] \rightarrow [-1, \underline{2}, 0, 2] \rightarrow [-1, -1, 0, \underline{2}] \rightarrow [-1, -1, 0, -1] $ .

## 样例 #1

### 输入

```
3
3 2
1 2 3
2 3
1 1
4 3
2 8 3 5
```

### 输出

```
2 1 3 
1 2 
3 1 2 4
```



---

---
title: "Balanced Round"
layout: "post"
diff: 普及-
pid: CF1850D
tag: []
---

# Balanced Round

## 题目描述

你是codeforces round的出题人，现在你将设置n个问题，第i个问题的难度是ai。你将进行以下操作步骤：
1.	从题单中移除一部分题目（移除的题目的数量可能是0）
2.	按你想要的任何顺序重新排列剩余的问题

当且仅当任意两道连续的题目的难度之差的绝对值最多为k时（即绝对值小于等于k），这一回合（round）会被认为是平衡的。

你最少需要移除多少道题目，才能使问题的安排是平衡的？

## 输入格式

第一行包含一个整数t(1≤t≤1000)，代表样例的数量

对于每个样例的第一行包含两个正整数n(1≤n≤2⋅10^5)和k(1≤k≤10^9)，n代表初始问题的数量，k代表连续的两个问题难度之差的绝对值的最大值

对于每个样例的第二行包含n个用空格隔开的整数ai(1≤ai≤10^9)，代表每个问题的难度

请注意，所有测试用例的n不超过2⋅10^5

## 输出格式

对于每个测试用例，输出一个正整数，代表你为了使问题的安排平衡所最少需要移除的问题的数量

## 说明/提示

对于第一个样例，我们可以移除前两个问题并得到一个问题的排列，其难度为【4，5，6】，连续的两个问题的难度之差的绝对值满足|5-4|=1≤1，|6-5|=1≤1

对于第二个样例，我们可以得到一个问题并将这一个问题（难度10）作为一个回合(round)

## 样例 #1

### 输入

```
7
5 1
1 2 4 5 6
1 2
10
8 3
17 3 1 20 12 5 17 12
4 2
2 4 6 8
5 3
2 3 19 10 8
3 4
1 10 5
8 1
8 3 1 4 5 10 7 3
```

### 输出

```
2
0
5
0
3
1
4
```



---

---
title: "Cardboard for Pictures"
layout: "post"
diff: 普及-
pid: CF1850E
tag: []
---

# Cardboard for Pictures

## 题目描述

Mircea有n张照片。第i张照片是一个边长为si厘米的正方形。

他将每张照片装在一个正方形的纸板上，使得每张照片的四周都有w厘米的纸板边框。总共，他使用了c平方厘米的纸板。根据照片的尺寸和c的值，你能找出w的值吗？
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1850E/8be93a707152c424940afd3c547aecafb34ece9f.png)
c=50=5²+4²+3²，所以w = 1 是本题目的答案。请注意，纸板的一角会出现在每张图片的后面，而不仅仅是边框上。

## 输入格式

输入的第一行包含一个整数t（1≤t≤1000），表示测试用例的数量。

每个测试用例的第一行包含两个正整数n（1≤n≤2⋅105）和c（1≤c≤1018），分别表示照片的数量和使用的卡纸的面积。

每个测试用例的第二行包含n个空格分隔的整数si（1≤si≤104），表示每张照片的尺寸。

所有测试用例中n的总和不超过2⋅105。

输入的附加约束条件：对于每个测试用例，存在一个整数w。

请注意，一些测试用例中的输入可能超过32位整数的范围，因此您应该在编程语言中至少使用64位整数类型（如C++中的long long类型）。

## 输出格式

对于每个测试用例，输出一个整数，表示使用了多少宽度的边框w，使得其恰好使用了c平方厘米的纸板。

# 样例
```
输入：10
3 50
3 2 1
1 100
6
5 500
2 2 2 2 2
2 365
3 4
2 469077255466389
10000 2023
10 635472106413848880
9181 4243 7777 1859 2017 4397 14 9390 2245 7225
7 176345687772781240
9202 9407 9229 6257 7743 5738 7966
14 865563946464579627
3654 5483 1657 7571 1639 9815 122 9468 3079 2666 5498 4540 7861 5384
19 977162053008871403
9169 9520 9209 9013 9300 9843 9933 9454 9960 9167 9964 9701 9251 9404 9462 9277 9661 9164 9161
18 886531871815571953
2609 10 5098 9591 949 8485 6385 4586 1064 5412 6564 8460 2245 6552 5089 8353 3803 3764
```
```
输出：1
2
4
5
7654321
126040443
79356352
124321725
113385729
110961227

## 说明/提示

```
在第一个测试用例中，根据题目给出的例子
```
我们需要使用1张照片，因此可以选择任意宽度的边框w。

在第二个测试用例中，假设我们选择的宽度w为22，那么每张照片需要的纸板面积为(2w+6)^2=10^2=100平方厘米。
```
在第三个测试用例中，假设我们选择的宽度w为44，那么每张照片需要的纸板面积为
```
(2w+2)^2×5=10^2×5=100×5=500平方厘米。

## 样例 #1

### 输入

```
10
3 50
3 2 1
1 100
6
5 500
2 2 2 2 2
2 365
3 4
2 469077255466389
10000 2023
10 635472106413848880
9181 4243 7777 1859 2017 4397 14 9390 2245 7225
7 176345687772781240
9202 9407 9229 6257 7743 5738 7966
14 865563946464579627
3654 5483 1657 7571 1639 9815 122 9468 3079 2666 5498 4540 7861 5384
19 977162053008871403
9169 9520 9209 9013 9300 9843 9933 9454 9960 9167 9964 9701 9251 9404 9462 9277 9661 9164 9161
18 886531871815571953
2609 10 5098 9591 949 8485 6385 4586 1064 5412 6564 8460 2245 6552 5089 8353 3803 3764
```

### 输出

```
1
2
4
5
7654321
126040443
79356352
124321725
113385729
110961227
```



---

---
title: "Tiles Comeback"
layout: "post"
diff: 普及-
pid: CF1851C
tag: []
---

# Tiles Comeback

## 题目描述

Vlad remembered that he had a series of $ n $ tiles and a number $ k $ . The tiles were numbered from left to right, and the $ i $ -th tile had colour $ c_i $ .

If you stand on the first tile and start jumping any number of tiles right, you can get a path of length $ p $ . The length of the path is the number of tiles you stood on.

Vlad wants to see if it is possible to get a path of length $ p $ such that:

- it ends at tile with index $ n $ ;
- $ p $ is divisible by $ k $
- the path is divided into blocks of length exactly $ k $ each;
- tiles in each block have the same colour, the colors in adjacent blocks are not necessarily different.

For example, let $ n = 14 $ , $ k = 3 $ .

The colours of the tiles are contained in the array $ c $ = \[ $ \color{red}{1}, \color{violet}{2}, \color{red}{1}, \color{red}{1}, \color{gray}{7}, \color{orange}{5}, \color{green}{3}, \color{green}{3}, \color{red}{1}, \color{green}{3}, \color{blue}{4}, \color{blue}{4}, \color{violet}{2}, \color{blue}{4} $ \]. Then we can construct a path of length $ 6 $ consisting of $ 2 $ blocks:

 $ \color{red}{c_1} \rightarrow \color{red}{c_3} \rightarrow \color{red}{c_4} \rightarrow \color{blue}{c_{11}} \rightarrow \color{blue}{c_{12}} \rightarrow \color{blue}{c_{14}} $

All tiles from the $ 1 $ -st block will have colour $ \color{red}{\textbf{1}} $ , from the $ 2 $ -nd block will have colour $ \color{blue}{\textbf{4}} $ .

It is also possible to construct a path of length $ 9 $ in this example, in which all tiles from the $ 1 $ -st block will have colour $ \color{red}{\textbf{1}} $ , from the $ 2 $ -nd block will have colour $ \color{green}{\textbf{3}} $ , and from the $ 3 $ -rd block will have colour $ \color{blue}{\textbf{4}} $ .

## 输入格式

The first line of input data contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 2 \cdot 10^5 $ )—the number of tiles in the series and the length of the block.

The second line of each test case contains $ n $ integers $ c_1, c_2, c_3, \dots, c_n $ ( $ 1 \le c_i \le n $ ) — the colours of the tiles.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output on a separate line:

- YES if you can get a path that satisfies these conditions;
- NO otherwise.

You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as positive response).

## 说明/提示

In the first test case, you can jump from the first tile to the last tile;

The second test case is explained in the problem statement.

## 样例 #1

### 输入

```
10
4 2
1 1 1 1
14 3
1 2 1 1 7 5 3 3 1 3 4 4 2 4
3 3
3 1 3
10 4
1 2 1 2 1 2 1 2 1 2
6 2
1 3 4 1 6 6
2 2
1 1
4 2
2 1 1 1
2 1
1 2
3 2
2 2 2
4 1
1 1 2 2
```

### 输出

```
YES
YES
NO
NO
YES
YES
NO
YES
YES
YES
```



---

---
title: "Longest Divisors Interval"
layout: "post"
diff: 普及-
pid: CF1855B
tag: []
---

# Longest Divisors Interval

## 题目描述

Given a positive integer $ n $ , find the maximum size of an interval $ [l, r] $ of positive integers such that, for every $ i $ in the interval (i.e., $ l \leq i \leq r $ ), $ n $ is a multiple of $ i $ .

Given two integers $ l\le r $ , the size of the interval $ [l, r] $ is $ r-l+1 $ (i.e., it coincides with the number of integers belonging to the interval).

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The only line of the description of each test case contains one integer $ n $ ( $ 1 \leq n \leq 10^{18} $ ).

## 输出格式

For each test case, print a single integer: the maximum size of a valid interval.

## 说明/提示

In the first test case, a valid interval with maximum size is $ [1, 1] $ (it's valid because $ n = 1 $ is a multiple of $ 1 $ ) and its size is $ 1 $ .

In the second test case, a valid interval with maximum size is $ [4, 5] $ (it's valid because $ n = 40 $ is a multiple of $ 4 $ and $ 5 $ ) and its size is $ 2 $ .

In the third test case, a valid interval with maximum size is $ [9, 11] $ .

In the fourth test case, a valid interval with maximum size is $ [8, 13] $ .

In the seventh test case, a valid interval with maximum size is $ [327869, 327871] $ .

## 样例 #1

### 输入

```
10
1
40
990990
4204474560
169958913706572972
365988220345828080
387701719537826430
620196883578129853
864802341280805662
1000000000000000000
```

### 输出

```
1
2
3
6
4
22
3
1
2
2
```



---

---
title: "Good Arrays"
layout: "post"
diff: 普及-
pid: CF1856B
tag: []
---

# Good Arrays

## 题目描述

You are given an array of positive integers $ a $ of length $ n $ .

Let's call an array of positive integers $ b $ of length $ n $ good if:

1. $ a_i \neq b_i $ for all $ i $ from $ 1 $ to $ n $ ,
2. $ a_1 + a_2 +\ldots + a_n = b_1 + b_2 + \ldots + b_n $ .

Does a good array exist?

## 输入格式

Each test contains multiple test cases. The first line of input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of the array $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10 ^ 9 $ ) — the elements of the array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output "YES" (without quotes) if there exists a good array, and "NO" (without quotes) otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs","yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

In the first test case, a possible good array is $ [3, 3, 3] $ . Some examples of not good arrays are:

- $ [8, 0, 1] $ — the array does not consist of only positive integers,
- $ [5, 2, 4] $ — the array does not have the same sum as the given array,
- $ [5, 2, 2] $ — the third element is equal to the third element of the given array.

In the second test case, $ [1, 1] $ is the only array of positive integers of length $ 2 $ that has the sum of it's elements equal to $ 2 $ . Since $ [1, 1] $ is not a good array, the answer is "NO".

## 样例 #1

### 输入

```
6
3
6 1 2
2
1 1
4
3 1 2 4
1
17
5
1 2 1 1 1
3
618343152 819343431 1000000000
```

### 输出

```
YES
NO
YES
NO
NO
YES
```



---

---
title: "Maximum Rounding"
layout: "post"
diff: 普及-
pid: CF1857B
tag: []
---

# Maximum Rounding

## 题目描述

Given a natural number $ x $ . You can perform the following operation:

- choose a positive integer $ k $ and round $ x $ to the $ k $ -th digit

Note that the positions are numbered from right to left, starting from zero. If the number has $ k $ digits, it is considered that the digit at the $ k $ -th position is equal to $ 0 $ .

The rounding is done as follows:

- if the digit at the $ (k-1) $ -th position is greater than or equal to $ 5 $ , then the digit at the $ k $ -th position is increased by $ 1 $ , otherwise the digit at the $ k $ -th position remains unchanged (mathematical rounding is used).
- if before the operations the digit at the $ k $ -th position was $ 9 $ , and it should be increased by $ 1 $ , then we search for the least position $ k' $ ( $ k'>k $ ), where the digit at the $ k' $ -th position is less than $ 9 $ and add $ 1 $ to the digit at the $ k' $ -th position. Then we assign $ k=k' $ .
- after that, all digits which positions are less than $ k $ are replaced with zeros.

Your task is to make $ x $ as large as possible, if you can perform the operation as many times as you want.

For example, if $ x $ is equal to $ 3451 $ , then if you choose consecutively:

- $ k=1 $ , then after the operation $ x $ will become $ 3450 $
- $ k=2 $ , then after the operation $ x $ will become $ 3500 $
- $ k=3 $ , then after the operation $ x $ will become $ 4000 $
- $ k=4 $ , then after the operation $ x $ will become $ 0 $

 To maximize the answer, you need to choose $ k=2 $ first, and then $ k=3 $ , then the number will become $ 4000 $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1\le t\le 10^4 $ ) — the number of test cases.

Each test case consists of positive integer $ x $ with a length of up to $ 2 \cdot 10^5 $ . It is guaranteed that there are no leading zeros in the integer.

It is guaranteed that the sum of the lengths of all integers $ x $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each set of input data, output the maximum possible value of $ x $ after the operations. The number should not have leading zeros in its representation.

## 说明/提示

In the first sample, it is better not to perform any operations.

In the second sample, you can perform one operation and obtain $ 10 $ .

In the third sample, you can choose $ k=1 $ or $ k=2 $ . In both cases the answer will be $ 100 $ .

## 样例 #1

### 输入

```
10
1
5
99
913
1980
20444
20445
60947
419860
40862016542130810467
```

### 输出

```
1
10
100
1000
2000
20444
21000
100000
420000
41000000000000000000
```



---

---
title: "Yet Another Permutation Problem"
layout: "post"
diff: 普及-
pid: CF1858C
tag: []
---

# Yet Another Permutation Problem

## 题目描述

# 又一个排列问题


Alex 收到了一个名为 "GCD 排列" 的游戏作为生日礼物。这个游戏的每一轮进行如下操作：

- 首先，Alex 选择一个整数序列 $ ^{\dagger} $ $ a_1, a_2, \ldots, a_n $ ，其中整数范围从 $ 1 $ 到 $ n $ 。
- 然后，对于每个 $ i $ 从 $ 1 $ 到 $ n $ ，计算整数 $ d_i = \gcd(a_i, a_{(i \bmod n) + 1}) $ 。
- 本轮的得分是 $ d_1, d_2, \ldots, d_n $ 中不同数字的数量。

Alex 已经玩了几轮游戏，所以他决定找一个整数序列 $ a_1, a_2, \ldots, a_n $ ，使得它的得分尽可能地大。

回顾一下，$ \gcd(x, y) $ 表示 $ x $ 和 $ y $ 的 [最大公约数（GCD）](https://en.wikipedia.org/wiki/Greatest_common_divisor)，而 $ x \bmod y $ 表示将 $ x $ 除以 $ y $ 的余数。

 $ ^{\dagger} $ 长度为 $ n $ 的排列是一个由 $ n $ 个不同整数组成的数组，整数范围从 $ 1 $ 到 $ n $ 且顺序任意。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 不是排列（数组中有重复的 $ 2 $），$ [1,3,4] $ 也不是排列（虽然 $ n=3 $，但数组中有 $ 4 $）。

## 输入格式

第一行包含一个整数 $ t $（$ 1 \le t \le 10^4 $） — 测试用例的数量。

每个测试用例由一行组成，包含一个整数 $ n $（$ 2 \le n \le 10^5 $） — 数列中的整数数量。

保证所有测试用例中的 $ n $ 总和不超过 $ 10^5 $。

## 输出格式

对于每个测试用例，输出一行包含 $ n $ 个不同整数 $ a_{1},a_{2},\ldots,a_{n} $（$ 1 \le a_i \le n $） — 得分最大的排列。

如果有多个得分相同的排列，可以输出其中任何一个。

## 样例 #1

### 样例输入 #1

```
4
5
2
7
10
```

### 样例输出 #1

```
1 2 4 3 5 
1 2 
1 2 3 6 4 5 7 
1 2 3 4 8 5 10 6 9 7
```

## 说明/提示

在第一个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 5 $ 组成的排列。对于排列 $ a=[1,2,4,3,5] $，数组 $ d $ 等于 $ [1,2,1,1,1] $。它包含 $ 2 $ 个不同的整数。可以证明，长度为 $ 5 $ 的排列中没有比这个得分更高的。

在第二个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 2 $ 组成的排列。只有两种这样的排列：$ a=[1,2] $ 和 $ a=[2,1] $。在这两种情况下，数组 $ d $ 都等于 $ [1,1] $，所以这两种排列都是正确的。

在第三个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 7 $ 组成的排列。对于排列 $ a=[1,2,3,6,4,5,7] $，数组 $ d $ 等于 $ [1,1,3,2,1,1,1] $。它包含 $ 3 $ 个不同的整数，所以得分等于 $ 3 $。可以证明，由整数 $ 1 $ 到 $ 7 $ 组成的排列中没有得分更高的。

## 样例 #1

### 输入

```
4
5
2
7
10
```

### 输出

```
1 2 4 3 5 
1 2 
1 2 3 6 4 5 7 
1 2 3 4 8 5 10 6 9 7
```



---

---
title: "United We Stand"
layout: "post"
diff: 普及-
pid: CF1859A
tag: []
---

# United We Stand

## 题目描述

一共 $t$ 组数据，每组数据给定一个长度为 $n$ 数组 $a$，将其分为两个数组，使得任意第二个数组中的数不可以整除任意第一个数组中的数。

## 输入格式

第一行，一个 $t$（$1\le t\le500$）。
之后每组数据第一行为数组大小 $n$（$2\le n\le100$），第二行为 $a_1,a_2,...,a_n$（$2\le a_1\le10^9$）

## 输出格式

对于每组数据第一行为两个数组的长度，第二行为第一个数组，第三行为第二个数组。

## 样例 #1

### 输入

```
5
3
2 2 2
5
1 2 3 4 5
3
1 3 5
7
1 7 7 2 9 1 4
5
4 8 12 12 4
```

### 输出

```
-1
3 2
1 3 5 
2 4 
1 2
1 
3 5 
2 5
1 1 
2 4 7 7 9 
3 2
4 8 4 
12 12
```



---

---
title: "Olya and Game with Arrays"
layout: "post"
diff: 普及-
pid: CF1859B
tag: []
---

# Olya and Game with Arrays

## 题目描述

Artem suggested a game to the girl Olya. There is a list of $ n $ arrays, where the $ i $ -th array contains $ m_i \ge 2 $ positive integers $ a_{i,1}, a_{i,2}, \ldots, a_{i,m_i} $ .

Olya can move at most one (possibly $ 0 $ ) integer from each array to another array. Note that integers can be moved from one array only once, but integers can be added to one array multiple times, and all the movements are done at the same time.

The beauty of the list of arrays is defined as the sum $ \sum_{i=1}^n \min_{j=1}^{m_i} a_{i,j} $ . In other words, for each array, we find the minimum value in it and then sum up these values.

The goal of the game is to maximize the beauty of the list of arrays. Help Olya win this challenging game!

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 25000 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 25000 $ ) — the number of arrays in the list.

This is followed by descriptions of the arrays. Each array description consists of two lines.

The first line contains a single integer $ m_i $ ( $ 2 \le m_i \le 50000 $ ) — the number of elements in the $ i $ -th array.

The next line contains $ m_i $ integers $ a_{i, 1}, a_{i, 2}, \ldots, a_{i, m_i} $ ( $ 1 \le a_{i,j} \le 10^9 $ ) — the elements of the $ i $ -th array.

It is guaranteed that the sum of $ m_i $ over all test cases does not exceed $ 50000 $ .

## 输出格式

For each test case, output a single line containing a single integer — the maximum beauty of the list of arrays that Olya can achieve.

## 说明/提示

In the first test case, we can move the integer $ 3 $ from the second array to the first array. Then the beauty is $ \min(1, 2, 3) + \min(4) = 5 $ . It can be shown that this is the maximum possible beauty.

In the second test case, there is only one array, so regardless of the movements, the beauty will be $ \min(100, 1, 6) = 1 $ .

## 样例 #1

### 输入

```
3
2
2
1 2
2
4 3
1
3
100 1 6
3
4
1001 7 1007 5
3
8 11 6
2
2 9
```

### 输出

```
5
1
19
```



---

---
title: "Not a Substring"
layout: "post"
diff: 普及-
pid: CF1860A
tag: []
---

# Not a Substring

## 题目描述

A bracket sequence is a string consisting of characters '(' and/or ')'. A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example:

- bracket sequences "()()" and "(())" are regular (they can be transformed into "(1)+(1)" and "((1+1)+1)", respectively);
- bracket sequences ")(", "(" and ")" are not regular.

You are given a bracket sequence $ s $ ; let's define its length as $ n $ . Your task is to find a regular bracket sequence $ t $ of length $ 2n $ such that $ s $ does not occur in $ t $ as a contiguous substring, or report that there is no such sequence.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The only line of each test case contains a string $ s $ ( $ 2 \le |s| \le 50 $ ), consisting of characters "(" and/or ")".

## 输出格式

For each test case, print the answer to it. If there is no required regular bracket sequence, print NO in a separate line. Otherwise, print YES in the first line, and the required regular bracket sequence $ t $ itself in the second line. If there are multiple answers — you may print any of them.

## 样例 #1

### 输入

```
4
)(
(()
()
))()
```

### 输出

```
YES
(())
YES
()()()
NO
YES
()(()())
```



---

---
title: "Two Binary Strings"
layout: "post"
diff: 普及-
pid: CF1861B
tag: []
---

# Two Binary Strings

## 题目描述

You are given two strings $ a $ and $ b $ of equal length, consisting of only characters 0 and/or 1; both strings start with character 0 and end with character 1.

You can perform the following operation any number of times (possibly zero):

- choose one of the strings and two equal characters in it; then turn all characters between them into those characters.

Formally, you choose one of these two strings (let the chosen string be $ s $ ), then pick two integers $ l $ and $ r $ such that $ 1 \le l < r \le |s| $ and $ s_l = s_r $ , then replace every character $ s_i $ such that $ l < i < r $ with $ s_l $ .

For example, if the chosen string is 010101, you can transform it into one of the following strings by applying one operation:

- 000101 if you choose $ l = 1 $ and $ r = 3 $ ;
- 000001 if you choose $ l = 1 $ and $ r = 5 $ ;
- 010001 if you choose $ l = 3 $ and $ r = 5 $ ;
- 010111 if you choose $ l = 4 $ and $ r = 6 $ ;
- 011111 if you choose $ l = 2 $ and $ r = 6 $ ;
- 011101 if you choose $ l = 2 $ and $ r = 4 $ .

You have to determine if it's possible to make the given strings equal by applying this operation any number of times.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 2000 $ ) — the number of test cases.

Each test case consists of two lines:

- the first line contains the string $ a $ ( $ 2 \le |a| \le 5000 $ ), consisting of only characters 0 and/or 1.
- the second line contains the string $ b $ ( $ 2 \le |b| \le 5000 $ ), consisting of only characters 0 and/or 1.

Additional constraints on the input:

- in each test case, $ |a| = |b| $ (the strings have equal length);
- in each test case, both strings start with 0 and end with 1;
- the total length of all strings $ a $ in all test cases does not exceed $ 5000 $ .

## 输出格式

For each test case, print YES if it is possible to make the strings equal. Otherwise, print NO. You can print each letter in any register.

## 说明/提示

In the first test case, we can perform the following operations:

1. choose the string $ a $ , $ l = 2 $ , $ r = 4 $ ; after this operation, $ a $ is 01110001, $ b $ is 01110101;
2. choose the string $ b $ , $ l = 5 $ , $ r = 7 $ ; after this operation, $ a $ is 01110001, $ b $ is 01110001.

In the second test case, the strings are already equal.

In the third test case, we can perform the following operations:

1. choose the string $ a $ , $ l = 4 $ , $ r = 6 $ ; after this operation, $ a $ is 000111, $ b $ is 010111;
2. choose the string $ b $ , $ l = 1 $ , $ r = 3 $ ; after this operation, $ a $ is 000111, $ b $ is 000111;

In the fourth and fifth test cases, it's impossible to make the given strings equal.

## 样例 #1

### 输入

```
7
01010001
01110101
01001
01001
000101
010111
00001
01111
011
001
001001
011011
010001
011011
```

### 输出

```
YES
YES
YES
NO
NO
NO
YES
```



---

---
title: "Flower City Fence"
layout: "post"
diff: 普及-
pid: CF1862C
tag: []
---

# Flower City Fence

## 题目描述

Anya lives in the Flower City. By order of the city mayor, she has to build a fence for herself.

The fence consists of $ n $ planks, each with a height of $ a_i $ meters. According to the order, the heights of the planks must not increase. In other words, it is true that $ a_i \ge a_j $ for all $ i < j $ .

Anya became curious whether her fence is symmetrical with respect to the diagonal. In other words, will she get the same fence if she lays all the planks horizontally in the same order.

For example, for $ n = 5 $ , $ a = [5, 4, 3, 2, 1] $ , the fence is symmetrical. Because if all the planks are laid horizontally, the fence will be $ [5, 4, 3, 2, 1] $ , as shown in the diagram.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1862C/bee85e28c2f6c75c9cfffe7860d8e27020ca6057.png) On the left is the fence $ [5, 4, 3, 2, 1] $ , on the right is the same fence laid horizontally

But for $ n = 3 $ , $ a = [4, 2, 1] $ , the fence is not symmetrical. Because if all the planks are laid horizontally, the fence will be $ [3, 2, 1, 1] $ , as shown in the diagram.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1862C/61240a948afb884e3b78ad7f150c3256a48031f7.png) On the left is the fence $ [4, 2, 1] $ , on the right is the same fence laid horizontally

Help Anya and determine whether her fence is symmetrical.

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The description of the test cases follows.

The first line of a test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the length of the fence.

The second line of a test case contains $ n $ integers $ a_1 \ge a_2 \ge a_3 \ge \dots \ge a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the heights of the planks.

The sum of the values of $ n $ for all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output "YES" if the fence is symmetrical, otherwise output "NO".

You can output each letter in any case (lowercase or uppercase). For example, the strings "yEs", "yes", "Yes" and "YES" will be accepted as a positive answer.

## 说明/提示

In the first and second test cases of the example, the fence is symmetrical.

In the third test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be $ [3, 2, 1, 1] $ .

In the fourth test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be $ [1, 1] $ .

In the fifth and sixth test cases of the example, the fence is symmetrical.

In the seventh test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be $ [2, 1, 1, 1, 1, 1] $ .

## 样例 #1

### 输入

```
7
5
5 4 3 2 1
3
3 1 1
3
4 2 1
1
2
5
5 3 3 1 1
5
5 5 5 3 3
2
6 1
```

### 输出

```
YES
YES
NO
NO
YES
YES
NO
```



---

---
title: "Split Sort"
layout: "post"
diff: 普及-
pid: CF1863B
tag: []
---

# Split Sort

## 题目描述

You are given a permutation $ ^{\dagger} $ $ p_1, p_2, \ldots, p_n $ of integers $ 1 $ to $ n $ .

You can change the current permutation by applying the following operation several (possibly, zero) times:

- choose some $ x $ ( $ 2 \le x \le n $ );
- create a new permutation by: 
  - first, writing down all elements of $ p $ that are less than $ x $ , without changing their order;
  - second, writing down all elements of $ p $ that are greater than or equal to $ x $ , without changing their order;
- replace $ p $ with the newly created permutation.

For example, if the permutation used to be $ [6, 4, 3, 5, 2, 1] $ and you choose $ x = 4 $ , then you will first write down $ [3, 2, 1] $ , then append this with $ [6, 4, 5] $ . So the initial permutation will be replaced by $ [3, 2, 1, 6, 4, 5] $ .

Find the minimum number of operations you need to achieve $ p_i = i $ for $ i = 1, 2, \ldots, n $ . We can show that it is always possible to do so.

 $ ^{\dagger} $ A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n=3 $ but there is $ 4 $ in the array).

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). The description of the test cases follows.

The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 100\,000 $ ).

The second line of each test case contains $ n $ integers $ p_1, p_2, \ldots, p_n $ ( $ 1 \le p_i \le n $ ). It is guaranteed that $ p_1, p_2, \ldots, p_n $ is a permutation.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 100\,000 $ .

## 输出格式

For each test case, output the answer on a separate line.

## 说明/提示

In the first test case, $ n = 1 $ and $ p_1 = 1 $ , so there is nothing left to do.

In the second test case, we can choose $ x = 2 $ and we immediately obtain $ p_1 = 1 $ , $ p_2 = 2 $ .

In the third test case, we can achieve the minimum number of operations in the following way:

1. $ x = 4 $ : $ [6, 4, 3, 5, 2, 1] \rightarrow [3, 2, 1, 6, 4, 5] $ ;
2. $ x = 6 $ : $ [3, 2, 1, 6, 4, 5] \rightarrow [3, 2, 1, 4, 5, 6] $ ;
3. $ x = 3 $ : $ [3, 2, 1, 4, 5, 6] \rightarrow [2, 1, 3, 4, 5, 6] $ ;
4. $ x = 2 $ : $ [2, 1, 3, 4, 5, 6] \rightarrow [1, 2, 3, 4, 5, 6] $ .

## 样例 #1

### 输入

```
5
1
1
2
2 1
6
6 4 3 5 2 1
3
3 1 2
19
10 19 7 1 17 11 8 5 12 9 4 18 14 2 6 15 3 16 13
```

### 输出

```
0
1
4
1
7
```



---

---
title: "MEX Repetition"
layout: "post"
diff: 普及-
pid: CF1863C
tag: []
---

# MEX Repetition

## 题目描述

You are given an array $ a_1,a_2,\ldots, a_n $ of pairwise distinct integers from $ 0 $ to $ n $ . Consider the following operation:

- consecutively for each $ i $ from $ 1 $ to $ n $ in this order, replace $ a_i $ with $ \operatorname{MEX}(a_1, a_2, \ldots, a_n) $ .

Here $ \operatorname{MEX} $ of a collection of integers $ c_1, c_2, \ldots, c_m $ is defined as the smallest non-negative integer $ x $ which does not occur in the collection $ c $ . For example, $ \operatorname{MEX}(0, 2, 2, 1, 4) = 3 $ and $ \operatorname{MEX}(1, 2) = 0 $ .

Print the array after applying $ k $ such operations.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^5 $ ). The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1\le n\le 10^5 $ , $ 1\le k\le 10^9 $ ).

The second line contains $ n $ pairwise distinct integers $ a_1,a_2,\ldots, a_n $ ( $ 0\le a_i\le n $ ) representing the elements of the array before applying the operations.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, print all $ n $ elements of the array after applying $ k $ operations.

## 说明/提示

In the first test case, here is the entire process:

1. On the first operation, the array changes from $ [1] $ to $ [0] $ , since $ \operatorname{MEX}(1) = 0 $ .
2. On the second operation, the array changes from $ [0] $ to $ [1] $ , since $ \operatorname{MEX}(0) = 1 $ .

Thus, the array becomes $ [1] $ after two operations.

In the second test case, the array changes as follows during one operation: $ [{\mkern3mu\underline{\mkern-3mu {\bf 0}\mkern-3mu}\mkern3mu}, 1, 3] \rightarrow [2, {\mkern3mu\underline{\mkern-3mu {\bf 1}\mkern-3mu}\mkern3mu}, 3] \rightarrow [2, 0, {\mkern3mu\underline{\mkern-3mu {\bf 3}\mkern-3mu}\mkern3mu}] \rightarrow [2, 0, 1] $ .

In the third test case, the array changes as follows during one operation: $ [{\mkern3mu\underline{\mkern-3mu {\bf 0}\mkern-3mu}\mkern3mu}, 2] \rightarrow [1, {\mkern3mu\underline{\mkern-3mu {\bf 2}\mkern-3mu}\mkern3mu}] \rightarrow [1, 0] $ . And during the second operation: $ [{\mkern3mu\underline{\mkern-3mu {\bf 1}\mkern-3mu}\mkern3mu}, 0] \rightarrow [2, {\mkern3mu\underline{\mkern-3mu {\bf 0}\mkern-3mu}\mkern3mu}] \rightarrow [2, 1] $ .

## 样例 #1

### 输入

```
5
1 2
1
3 1
0 1 3
2 2
0 2
5 5
1 2 3 4 5
10 100
5 3 0 4 2 1 6 9 10 8
```

### 输出

```
1
2 0 1
2 1
2 3 4 5 0
7 5 3 0 4 2 1 6 9 10
```



---

---
title: "XOR Palindromes"
layout: "post"
diff: 普及-
pid: CF1867B
tag: []
---

# XOR Palindromes

## 题目描述

给出一个长度为 $n$ 的 $01$ 串(只含 $0,1$ 的字符串) $s$。定义一个数 $x$ 是好数，当仅当存在一个长度也为 $n$ 的 $01$ 串 $l$ 使得对于所有的 $s_i$ 被 $s_i\oplus l_i$ 替换后得到的 $01$ 串是一个回文串。

对于给出的一组 $n,s$ ，你需要给出一个长度为 $n+1$ 的 $01$ 串 $t$ ，$t_i=1$ 当仅当 $i$ 是一个好数。**注意，$t$ 从 $0$ 开始编号**

题目中 $\oplus$ 表示异或。

回文串指正着读反着读都相同的字符串，比如 $0110,01010,1111$ 都是回文串。

## 输入格式

每个测试点有多组数据。对于每个测试点，第一行为一个整数 $t$，代表有 $t (1\leq t\leq 10^5)$ 组数据。

对于每组数据，第一行为一个整数 $n (1 \leq n\leq 10^5)$。

第二行是一行长度为 $n$ 的 $01$ 串 $s$。

保证单个测试点所有 $n$ 的和不超过 $10^5$

## 输出格式

对于每组数据，输出一行长度为 $n+1$ 的 $01$ 串 $l$ 。

## 说明/提示

考虑第一个例子：

 $t_2=1$ 是因为我们可以选到 $l=010100$ ，异或后 $s$ 变成 $111111$ 成为一个回文串。
 
 $t_4=1$ 是因为我们可以选到 $l=101011$ 此时 $s$ 变成回文串 $000000$。
 
 可以证明其他任意的 $i$ 都不满足成为 “好数” 的条件，故其他所有的位置都是 $0$。

## 样例 #1

### 输入

```
5
6
101011
5
00000
9
100100011
3
100
1
1
```

### 输出

```
0010100
111111
0011111100
0110
11
```



---

---
title: "Make It Zero"
layout: "post"
diff: 普及-
pid: CF1869A
tag: []
---

# Make It Zero

## 题目描述

During Zhongkao examination, Reycloer met an interesting problem, but he cannot come up with a solution immediately. Time is running out! Please help him.

Initially, you are given an array $ a $ consisting of $ n \ge 2 $ integers, and you want to change all elements in it to $ 0 $ .

In one operation, you select two indices $ l $ and $ r $ ( $ 1\le l\le r\le n $ ) and do the following:

- Let $ s=a_l\oplus a_{l+1}\oplus \ldots \oplus a_r $ , where $ \oplus $ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR);
- Then, for all $ l\le i\le r $ , replace $ a_i $ with $ s $ .

You can use the operation above in any order at most $ 8 $ times in total.

Find a sequence of operations, such that after performing the operations in order, all elements in $ a $ are equal to $ 0 $ . It can be proven that the solution always exists.

## 输入格式

The first line of input contains a single integer $ t $ ( $ 1\le t\le 500 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2\le n\le 100 $ ) — the length of the array $ a $ .

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 0\le a_i\le 100 $ ) — the elements of the array $ a $ .

## 输出格式

For each test case, in the first line output a single integer $ k $ ( $ 0\le k\le 8 $ ) — the number of operations you use.

Then print $ k $ lines, in the $ i $ -th line output two integers $ l_i $ and $ r_i $ ( $ 1\le l_i\le r_i\le n $ ) representing that you select $ l_i $ and $ r_i $ in the $ i $ -th operation.

Note that you do not have to minimize $ k $ . If there are multiple solutions, you may output any of them.

## 说明/提示

In the first test case, since $ 1\oplus2\oplus3\oplus0=0 $ , after performing the operation on segment $ [1,4] $ , all the elements in the array are equal to $ 0 $ .

In the second test case, after the first operation, the array becomes equal to $ [3,1,4,15,15,15,15,6] $ , after the second operation, the array becomes equal to $ [0,0,0,0,0,0,0,0] $ .

In the third test case:

 Operation $ a $ before $ a $ after $ 1 $  $ [\underline{1,5},4,1,4,7] $  $ \rightarrow $  $ [4,4,4,1,4,7] $  $ 2 $  $ [4,4,\underline{4,1},4,7] $  $ \rightarrow $  $ [4,4,5,5,4,7] $  $ 3 $  $ [4,4,5,5,\underline{4,7}] $  $ \rightarrow $  $ [4,4,5,5,3,3] $  $ 4 $  $ [\underline{4,4,5},5,3,3] $  $ \rightarrow $  $ [5,5,5,5,3,3] $  $ 5 $  $ [5,5,5,\underline{5,3,3}] $  $ \rightarrow $  $ [5,5,5,5,5,5] $  $ 6 $  $ [\underline{5,5,5,5,5,5}] $  $ \rightarrow $  $ [0,0,0,0,0,0] $ In the fourth test case, the initial array contains only $ 0 $ , so we do not need to perform any operations with it.

## 样例 #1

### 输入

```
6
4
1 2 3 0
8
3 1 4 1 5 9 2 6
6
1 5 4 1 4 7
5
0 0 0 0 0
7
1 1 9 9 0 1 8
3
100 100 0
```

### 输出

```
1
1 4
2
4 7
1 8
6
1 2
3 4
5 6
1 3
4 6
1 6
0
4
1 2
6 7
3 4
6 7
1
1 2
```



---

---
title: "2D Traveling"
layout: "post"
diff: 普及-
pid: CF1869B
tag: []
---

# 2D Traveling

## 题目描述

Piggy lives on an infinite plane with the Cartesian coordinate system on it.

There are $ n $ cities on the plane, numbered from $ 1 $ to $ n $ , and the first $ k $ cities are defined as major cities. The coordinates of the $ i $ -th city are $ (x_i,y_i) $ .

Piggy, as a well-experienced traveller, wants to have a relaxing trip after Zhongkao examination. Currently, he is in city $ a $ , and he wants to travel to city $ b $ by air. You can fly between any two cities, and you can visit several cities in any order while travelling, but the final destination must be city $ b $ .

Because of active trade between major cities, it's possible to travel by plane between them for free. Formally, the price of an air ticket $ f(i,j) $ between two cities $ i $ and $ j $ is defined as follows:

 $ $$$ f(i,j)= \begin{cases} 0, & \text{if cities }i \text{ and }j \text{ are both major cities} \\ |x_i-x_j|+|y_i-y_j|, & \text{otherwise} \end{cases}  $ $$$

Piggy doesn't want to save time, but he wants to save money. So you need to tell him the minimum value of the total cost of all air tickets if he can take any number of flights.

## 输入格式

The first line of input contains a single integer $ t $ ( $ 1\le t\le 10^4 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains four integers $ n $ , $ k $ , $ a $ and $ b $ ( $ 2\le n\le 2\cdot 10^5 $ , $ 0\le k\le n $ , $ 1\le a,b\le n $ , $ a\ne b $ ) — the number of cities, the number of major cities and the numbers of the starting and the ending cities.

Then $ n $ lines follow, the $ i $ -th line contains two integers $ x_i $ and $ y_i $ ( $ -10^9\le x_i,y_i\le 10^9 $ ) — the coordinates of the $ i $ -th city. The first $ k $ lines describe major cities. It is guaranteed that all coordinates are pairwise distinct.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, print a single integer — the minimum value of the total price of all air tickets.

## 说明/提示

In the first test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1869B/5d562a7fae0997b047c9a0448bd832cdb0a43e6a.png) The major cities are marked red.The optimal way to choose the flights is: $ 3\rightarrow 1 \rightarrow 2 \rightarrow 5 $ , which will cost $ 3+0+1=4 $ . Note that the flight $ 1\rightarrow 2 $ costs $ 0 $ , because both city $ 1 $ and $ 2 $ are major cities.

In the second test case, since there are only $ 2 $ cities, the only way is to take a flight from city $ 1 $ to $ 2 $ .

In the third test case, since city $ 2 $ and $ 4 $ are both major cities, Piggy can directly take a flight from city $ 2 $ to $ 4 $ , which costs $ 0 $ .

In the fourth test case, Piggy can choose to take the following flights: $ 3\rightarrow 2\rightarrow 1 $ , and the cost is $ 11+11=22 $ .

## 样例 #1

### 输入

```
5
6 2 3 5
0 0
1 -2
-2 1
-1 3
2 -2
-3 -3
2 0 1 2
-1000000000 -1000000000
1000000000 1000000000
7 5 4 2
154 147
-154 -147
123 456
20 23
43 20
998 244
353 100
3 1 3 1
0 10
1 20
2 30
4 3 2 4
0 0
-100 100
-1 -1
-1 0
```

### 输出

```
4
4000000000
0
22
1
```



---

---
title: "Growing Mushrooms"
layout: "post"
diff: 普及-
pid: CF186B
tag: []
---

# Growing Mushrooms

## 题目描述

每年，矮人王城堡里都会举行矮人种植蘑菇比赛。这项比赛是最负盛名的比赛之一，获胜者会得到一个木制沙拉碗。今年的比赛汇集了世界各地最优秀的蘑菇种植者，因此我们不得不对比赛规则稍作改动，使比赛更具观赏性。

每位蘑菇种植者都有自己要在比赛中种植的蘑菇。根据新规则，比赛由两部分组成。第一部分持续 $t1$ 秒，第二部分持续 $t2$ 秒。第一部分和第二部分之间有一小段休息时间。

哨声响起后，比赛的第一部分开始，所有蘑菇种植者同时开始种植蘑菇，每个人的速度为 $v_i$ 米/秒。$t1$ 秒后，蘑菇种植者停止种植蘑菇，开始休息。在休息期间，由于不明原因，所有蘑菇的生长量减少了 $k$% 。休息后，比赛的第二部分开始，所有种菇人同时继续种菇，每个人的速度为 $u_i$ 米/秒。经过 $t2$ 秒后，比赛结束。注意休息前后的速度可能不同。

赛前，小矮人帕夏向所有参赛者了解了他们选择的两种速度。不过，参赛者并不想向他透露自己的所有策略，因此也没有说他们将按照什么顺序使用这些速度。也就是说，如果参与者选择了速度 $a_i$ 和 $b_i$，则有两种策略：他要么先使用速度 $a_i$，后用 $b_i$，反之亦然。 

小矮人帕夏非常想赢得总分赛。他知道每个参赛者都会选择使蘑菇高度最大化的策略。帮助小矮人帕夏制作比赛结果的最终表格。

在成绩表中，参赛者按蘑菇高度排序（蘑菇高度高的参赛者排在前面）。如果蘑菇高度相同，则按参赛者的编号排序（编号小的参赛者排在前面）。

## 输入格式

第一行输入 $4$ 个整数，分别表示 $n,t1,t2,k$（$1\le n,t1,t2\le 1000; 1\le k\le 100$） ——参与者人数、中断前的时间、中断后的时间和中断期间蘑菇生长量下降的百分比。 

下面 第 $2$ ~ $n+1$ 行，每行包含两个整数 $a_i,b_i$，表示参与者 $i$ 选择的速度。

## 输出格式

打印最终结果表：

共 $n$ 行，每行应包含相应矮人的编号及其蘑菇的最终最大高度，保留到小数点后两位数。如果答案绝对准确，则视为正确答案。

## 样例 #1

### 输入

```
2 3 3 50
2 4
4 2

```

### 输出

```
1 15.00
2 15.00

```

## 样例 #2

### 输入

```
4 1 1 1
544 397
280 101
280 101
693 970

```

### 输出

```
4 1656.07
1 937.03
2 379.99
3 379.99

```



---

---
title: "The Corridor or There and Back Again"
layout: "post"
diff: 普及-
pid: CF1872B
tag: []
---

# The Corridor or There and Back Again

## 题目描述

You are in a corridor that extends infinitely to the right, divided into square rooms. You start in room $ 1 $ , proceed to room $ k $ , and then return to room $ 1 $ . You can choose the value of $ k $ . Moving to an adjacent room takes $ 1 $ second.

Additionally, there are $ n $ traps in the corridor: the $ i $ -th trap is located in room $ d_i $ and will be activated $ s_i $ seconds after you enter the room $ \boldsymbol{d_i} $ . Once a trap is activated, you cannot enter or exit a room with that trap.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1872B/4c6bb8cafdaa97d3491d04295a1aa2f558037158.png) A schematic representation of a possible corridor and your path to room $ k $ and back.Determine the maximum value of $ k $ that allows you to travel from room $ 1 $ to room $ k $ and then return to room $ 1 $ safely.

For instance, if $ n=1 $ and $ d_1=2, s_1=2 $ , you can proceed to room $ k=2 $ and return safely (the trap will activate at the moment $ 1+s_1=1+2=3 $ , it can't prevent you to return back). But if you attempt to reach room $ k=3 $ , the trap will activate at the moment $ 1+s_1=1+2=3 $ , preventing your return (you would attempt to enter room $ 2 $ on your way back at second $ 3 $ , but the activated trap would block you). Any larger value for $ k $ is also not feasible. Thus, the answer is $ k=2 $ .

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The descriptions of the test cases follow.

The first line of each test case description contains an integer $ n $ ( $ 1 \le n \le 100 $ ) — the number of traps.

The following $ n $ lines of each test case description present two integers $ d_i $ and $ s_i $ ( $ 1 \le d_i, s_i \le 200 $ ) — the parameters of a trap (you must leave room $ d_i $ strictly before $ s_i $ seconds have passed since entering this room). It's possible for multiple traps to occupy a single room (the values of $ d_i $ can be repeated).

## 输出格式

For each test case, print the maximum value of $ k $ that allows you to travel to room $ k $ and return to room $ 1 $ without encountering an active trap.

## 说明/提示

The first test case is explained in the problem statement above.

In the second test case, the second trap prevents you from achieving $ k\ge6 $ . If $ k\ge6 $ , the second trap will activate at the moment $ 3+s_2=3+3=6 $ (the time you enter room $ 4 $ plus $ s_2 $ ). In the case of $ k\ge6 $ , you will return to room $ 4 $ at time $ 7 $ or later. The trap will be active at that time. It can be shown that room $ k=5 $ can be reached without encountering an active trap.

In the third test case, you can make it to room $ 299 $ and then immediately return to room $ 1 $ .

## 样例 #1

### 输入

```
7
1
2 2
3
2 8
4 3
5 2
1
200 200
4
1 20
5 9
3 179
100 1
2
10 1
1 18
2
1 1
1 2
3
1 3
1 1
1 3
```

### 输出

```
2
5
299
9
9
1
1
```



---

---
title: "Non-coprime Split"
layout: "post"
diff: 普及-
pid: CF1872C
tag: []
---

# Non-coprime Split

## 题目描述

You are given two integers $ l \le r $ . You need to find positive integers $ a $ and $ b $ such that the following conditions are simultaneously satisfied:

- $ l \le a + b \le r $
- $ \gcd(a, b) \neq 1 $

or report that they do not exist.

 $ \gcd(a, b) $ denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of numbers $ a $ and $ b $ . For example, $ \gcd(6, 9) = 3 $ , $ \gcd(8, 9) = 1 $ , $ \gcd(4, 2) = 2 $ .

## 输入格式

The first line of the input contains an integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases.

Then the descriptions of the test cases follow.

The only line of the description of each test case contains $ 2 $ integers $ l, r $ ( $ 1 \le l \le r \le 10^7 $ ).

## 输出格式

For each test case, output the integers $ a, b $ that satisfy all the conditions on a separate line. If there is no answer, instead output a single number $ -1 $ .

If there are multiple answers, you can output any of them.

## 说明/提示

In the first test case, $ 11 \le 6 + 9 \le 15 $ , $ \gcd(6, 9) = 3 $ , and all conditions are satisfied. Note that this is not the only possible answer, for example, $ \{4, 10\}, \{5, 10\}, \{6, 6\} $ are also valid answers for this test case.

In the second test case, the only pairs $ \{a, b\} $ that satisfy the condition $ 1 \le a + b \le 3 $ are $ \{1, 1\}, \{1, 2\}, \{2, 1\} $ , but in each of these pairs $ \gcd(a, b) $ equals $ 1 $ , so there is no answer.

In the third sample test, $ \gcd(14, 4) = 2 $ .

## 样例 #1

### 输入

```
11
11 15
1 3
18 19
41 43
777 777
8000000 10000000
2000 2023
1791791 1791791
1 4
2 3
9840769 9840769
```

### 输出

```
6 9
-1
14 4
36 6
111 666
4000000 5000000 
2009 7
-1
2 2
-1
6274 9834495
```



---

---
title: "Building an Aquarium"
layout: "post"
diff: 普及-
pid: CF1873E
tag: []
---

# Building an Aquarium

## 题目描述

You love fish, that's why you have decided to build an aquarium. You have a piece of coral made of $ n $ columns, the $ i $ -th of which is $ a_i $ units tall. Afterwards, you will build a tank around the coral as follows:

- Pick an integer $ h \geq 1 $ — the height of the tank. Build walls of height $ h $ on either side of the tank.
- Then, fill the tank up with water so that the height of each column is $ h $ , unless the coral is taller than $ h $ ; then no water should be added to this column.

 For example, with $ a=[3,1,2,4,6,2,5] $ and a height of $ h=4 $ , you will end up using a total of $ w=8 $ units of water, as shown.  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1873E/7c1e58fc4d1641ece42f30c898039b9158eaffda.png)  You can use at most $ x $ units of water to fill up the tank, but you want to build the biggest tank possible. What is the largest value of $ h $ you can select?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains two positive integers $ n $ and $ x $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ; $ 1 \leq x \leq 10^9 $ ) — the number of columns of the coral and the maximum amount of water you can use.

The second line of each test case contains $ n $ space-separated integers $ a_i $ ( $ 1 \leq a_i \leq 10^9 $ ) — the heights of the coral.

The sum of $ n $ over all test cases doesn't exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single positive integer $ h $ ( $ h \geq 1 $ ) — the maximum height the tank can have, so you need at most $ x $ units of water to fill up the tank.

We have a proof that under these constraints, such a value of $ h $ always exists.

## 说明/提示

The first test case is pictured in the statement. With $ h=4 $ we need $ 8 $ units of water, but if $ h $ is increased to $ 5 $ we need $ 13 $ units of water, which is more than $ x=9 $ . So $ h=4 $ is optimal.

In the second test case, we can pick $ h=4 $ and add $ 3 $ units to each column, using a total of $ 9 $ units of water. It can be shown that this is optimal.

In the third test case, we can pick $ h=2 $ and use all of our water, so it is optimal.

## 样例 #1

### 输入

```
5
7 9
3 1 2 4 6 2 5
3 10
1 1 1
4 1
1 4 3 4
6 1984
2 6 5 9 1 8
1 1000000000
1
```

### 输出

```
4
4
2
335
1000000001
```



---

---
title: "Vasilije in Cacak"
layout: "post"
diff: 普及-
pid: CF1878C
tag: []
---

# Vasilije in Cacak

## 题目描述

Aca and Milovan, two fellow competitive programmers, decided to give Vasilije a problem to test his skills.

Vasilije is given three positive integers: $ n $ , $ k $ , and $ x $ , and he has to determine if he can choose $ k $ distinct integers between $ 1 $ and $ n $ , such that their sum is equal to $ x $ .

Since Vasilije is now in the weirdest city in Serbia where Aca and Milovan live, Cacak, the problem seems weird to him. So he needs your help with this problem.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The only line of each test case contains three integers $ n $ , $ k $ and $ x $ ( $ 1 \le n \le 2 \cdot 10^5 $ , $ 1 \le k \le n $ , $ 1 \le x \le 4 \cdot 10^{10} $ ) — the maximum element he can choose, the number of elements he can choose and the sum he has to reach.

Note that the sum of $ n $ over all test cases may exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case output one line: "YES", if it is possible to choose $ k $ distinct integers between $ 1 $ and $ n $ , such that their sum is equal to $ x $ , and "NO", if it isn't.

You can output the answer in any case (for example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as a positive answer).

## 说明/提示

In the first test case $ n = 5,\ k=3,\ x=10 $ , so we can choose the numbers: $ 2 $ , $ 3 $ , $ 5 $ , whose sum is $ 10 $ , so the answer is "YES".

In the second test case $ n = 5, \ k=3, \ x=3 $ , there is no three numbers which satisfies the condition, so the answer is "NO". It can be shown that there are no three numbers whose sum is $ 3 $ .

## 样例 #1

### 输入

```
12
5 3 10
5 3 3
10 10 55
6 5 20
2 1 26
187856 87856 2609202300
200000 190000 19000000000
28 5 2004
2 2 2006
9 6 40
47202 32455 613407217
185977 145541 15770805980
```

### 输出

```
YES
NO
YES
YES
NO
NO
YES
NO
NO
NO
YES
YES
```



---

---
title: "Chips on the Board"
layout: "post"
diff: 普及-
pid: CF1879B
tag: []
---

# Chips on the Board

## 题目描述

You are given a board of size $ n \times n $ ( $ n $ rows and $ n $ colums) and two arrays of positive integers $ a $ and $ b $ of size $ n $ .

Your task is to place the chips on this board so that the following condition is satisfied for every cell $ (i, j) $ :

- there exists at least one chip in the same column or in the same row as the cell $ (i, j) $ . I. e. there exists a cell $ (x, y) $ such that there is a chip in that cell, and either $ x = i $ or $ y = j $ (or both).

The cost of putting a chip in the cell $ (i, j) $ is equal to $ a_i + b_j $ .

For example, for $ n=3 $ , $ a=[1, 4, 1] $ and $ b=[3, 2, 2] $ . One of the possible chip placements is as follows:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1879B/41f651e9026b79c2105cacdfb396235f2e97b44b.png) White squares are emptyThe total cost of that placement is $ (1+3) + (1+2) + (1+2) = 10 $ .

Calculate the minimum possible total cost of putting chips according to the rules above.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 3 \cdot 10^5 $ ).

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ).

The third line contains $ n $ integers $ b_1, b_2, \dots, b_n $ ( $ 1 \le b_i \le 10^9 $ ).

The sum of $ n $ over all test cases doesn't exceed $ 3 \cdot 10^5 $ .

## 输出格式

For each test case, print a single integer — the minimum possible total cost of putting chips according to the rules.

## 说明/提示

The first test case of the example is described in the statement.

## 样例 #1

### 输入

```
4
3
1 4 1
3 2 2
1
4
5
2
4 5
2 3
5
5 2 4 5 3
3 4 2 1 5
```

### 输出

```
10
9
13
24
```



---

---
title: "Three Threadlets"
layout: "post"
diff: 普及-
pid: CF1881B
tag: []
---

# Three Threadlets

## 题目描述

Once upon a time, bartender Decim found three threadlets and a pair of scissors.

In one operation, Decim chooses any threadlet and cuts it into two threadlets, whose lengths are positive integers and their sum is equal to the length of the threadlet being cut.

For example, he can cut a threadlet of length $ 5 $ into threadlets of lengths $ 2 $ and $ 3 $ , but he cannot cut it into threadlets of lengths $ 2.5 $ and $ 2.5 $ , or lengths $ 0 $ and $ 5 $ , or lengths $ 3 $ and $ 4 $ .

Decim can perform at most three operations. He is allowed to cut the threadlets obtained from previous cuts. Will he be able to make all the threadlets of equal length?

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Then follows the description of each test case.

In a single line of each test case, there are three integers $ a $ , $ b $ , $ c $ ( $ 1 \le a, b, c \le 10^9 $ ) — the lengths of the threadlets.

## 输出格式

For each test case, output "YES" if it is possible to make all the threadlets of equal length by performing at most three operations, otherwise output "NO".

You can output "YES" and "NO" in any case (for example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as a positive answer).

## 说明/提示

Let's consider some testcases of the first test.

In the first testcase, you can apply following operations:

 $ 1, 3, 2 \to 1, 2, 1, 2 \to 1, 1, 1, 1, 2 \to 1, 1, 1, 1, 1, 1 $ .

In the second testcase, you can do nothing, the threadlets are already of equal length.

In the third testcase, it isn't possible to make threadlets of equal length.

## 样例 #1

### 输入

```
15
1 3 2
5 5 5
6 36 12
7 8 7
6 3 3
4 4 12
12 6 8
1000000000 1000000000 1000000000
3 7 1
9 9 1
9 3 6
2 8 2
5 3 10
8 4 8
2 8 4
```

### 输出

```
YES
YES
NO
NO
YES
YES
NO
YES
NO
NO
YES
YES
NO
YES
NO
```



---

---
title: "Chemistry"
layout: "post"
diff: 普及-
pid: CF1883B
tag: []
---

# Chemistry

## 题目描述

You are given a string $ s $ of length $ n $ , consisting of lowercase Latin letters, and an integer $ k $ .

You need to check if it is possible to remove exactly $ k $ characters from the string $ s $ in such a way that the remaining characters can be rearranged to form a palindrome. Note that you can reorder the remaining characters in any way.

A palindrome is a string that reads the same forwards and backwards. For example, the strings "z", "aaa", "aba", "abccba" are palindromes, while the strings "codeforces", "reality", "ab" are not.

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of the test cases. This is followed by their description.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 0 \leq k < n \leq 10^5 $ ) — the length of the string $ s $ and the number of characters to be deleted.

The second line of each test case contains a string $ s $ of length $ n $ , consisting of lowercase Latin letters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output "YES" if it is possible to remove exactly $ k $ characters from the string $ s $ in such a way that the remaining characters can be rearranged to form a palindrome, and "NO" otherwise.

You can output the answer in any case (uppercase or lowercase). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive answers.

## 说明/提示

In the first test case, nothing can be removed, and the string "a" is a palindrome.

In the second test case, nothing can be removed, but the strings "ab" and "ba" are not palindromes.

In the third test case, any character can be removed, and the resulting string will be a palindrome.

In the fourth test case, one occurrence of the character "a" can be removed, resulting in the string "bb", which is a palindrome.

In the sixth test case, one occurrence of the characters "b" and "d" can be removed, resulting in the string "acac", which can be rearranged to the string "acca".

In the ninth test case, one occurrence of the characters "t" and "k" can be removed, resulting in the string "aagaa", which is a palindrome.

## 样例 #1

### 输入

```
14
1 0
a
2 0
ab
2 1
ba
3 1
abb
3 2
abc
6 2
bacacd
6 2
fagbza
6 2
zwaafa
7 2
taagaak
14 3
ttrraakkttoorr
5 3
debdb
5 4
ecadc
5 3
debca
5 3
abaac
```

### 输出

```
YES
NO
YES
YES
YES
YES
NO
NO
YES
YES
YES
YES
NO
YES
```



---

---
title: "Raspberries"
layout: "post"
diff: 普及-
pid: CF1883C
tag: []
---

# Raspberries

## 题目描述

You are given an array of integers $ a_1, a_2, \ldots, a_n $ and a number $ k $ ( $ 2 \leq k \leq 5 $ ). In one operation, you can do the following:

- Choose an index $ 1 \leq i \leq n $ ,
- Set $ a_i = a_i + 1 $ .

Find the minimum number of operations needed to make the product of all the numbers in the array $ a_1 \cdot a_2 \cdot \ldots \cdot a_n $ divisible by $ k $ .

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. Then follows the description of the test cases.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 2 \leq n \leq 10^5 $ , $ 2 \leq k \leq 5 $ ) — the size of the array $ a $ and the number $ k $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 10 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output the minimum number of operations needed to make the product of all the numbers in the array divisible by $ k $ .

## 说明/提示

In the first test case, we need to choose the index $ i = 2 $ twice. After that, the array will be $ a = [7, 5] $ . The product of all the numbers in the array is $ 35 $ .

In the fourth test case, the product of the numbers in the array is $ 120 $ , which is already divisible by $ 5 $ , so no operations are needed.

In the eighth test case, we can perform two operations by choosing $ i = 2 $ and $ i = 3 $ in any order. After that, the array will be $ a = [1, 6, 10] $ . The product of the numbers in the array is $ 60 $ .

## 样例 #1

### 输入

```
15
2 5
7 3
3 3
7 4 1
5 2
9 7 7 3 9
5 5
5 4 1 2 3
7 4
9 5 1 5 9 5 1
3 4
6 3 6
3 4
6 1 5
3 4
1 5 9
4 4
1 4 1 1
3 4
3 5 3
4 5
8 9 9 3
2 5
1 6
2 5
10 10
4 5
1 6 1 1
2 5
7 7
```

### 输出

```
2
2
1
0
2
0
1
2
0
1
1
4
0
4
3
```



---

---
title: "Qingshan Loves Strings"
layout: "post"
diff: 普及-
pid: CF1890B
tag: []
---

# Qingshan Loves Strings

## 题目描述

Qingshan has a string $ s $ , while Daniel has a string $ t $ . Both strings only contain $ \texttt{0} $ and $ \texttt{1} $ .

A string $ a $ of length $ k $ is good if and only if

- $ a_i \ne a_{i+1} $ for all $ i=1,2,\ldots,k-1 $ .

For example, $ \texttt{1} $ , $ \texttt{101} $ , $ \texttt{0101} $ are good, while $ \texttt{11} $ , $ \texttt{1001} $ , $ \texttt{001100} $ are not good.

Qingshan wants to make $ s $ good. To do this, she can do the following operation any number of times (possibly, zero):

- insert $ t $ to any position of $ s $ (getting a new $ s $ ).

Please tell Qingshan if it is possible to make $ s $ good.

## 输入格式

The input consists of multiple test cases. The first line contains a single integer $ T $ ( $ 1\le T\le 2000 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \le n,m \le 50 $ ) — the length of the strings $ s $ and $ t $ , respectively.

The second line of each test case contains a string $ s $ of length $ n $ .

The third line of each test case contains a string $ t $ of length $ m $ .

It is guaranteed that $ s $ and $ t $ only contain $ \texttt{0} $ and $ \texttt{1} $ .

## 输出格式

For each test case, print "YES" (without quotes), if it is possible to make $ s $ good, and "NO" (without quotes) otherwise.

You can print letters in any case (upper or lower).

## 说明/提示

In the first test case, $ s $ is good initially, so you can get a good $ s $ by doing zero operations.

In the second test case, you can do the following two operations (the inserted string $ t $ is underlined):

1. $ \texttt{1}\underline{\texttt{010}}\texttt{11} $
2. $ \texttt{10101}\underline{\texttt{010}}\texttt{1} $

and get $ s = \texttt{101010101} $ , which is good.

In the third test case, there is no way to make $ s $ good after any number of operations.

## 样例 #1

### 输入

```
5
1 1
1
0
3 3
111
010
3 2
111
00
6 7
101100
1010101
10 2
1001001000
10
```

### 输出

```
Yes
Yes
No
No
No
```



---

---
title: "Deja Vu"
layout: "post"
diff: 普及-
pid: CF1891B
tag: []
---

# Deja Vu

## 题目描述

You are given an array $ a $ of length $ n $ , consisting of positive integers, and an array $ x $ of length $ q $ , also consisting of positive integers.

There are $ q $ modification. On the $ i $ -th modification ( $ 1 \leq i \leq q $ ), for each $ j $ ( $ 1 \leq j \leq n $ ), such that $ a_j $ is divisible by $ 2^{x_i} $ , you add $ 2^{x_i-1} $ to $ a_j $ . Note that $ x_i $ ( $ 1 \leq x_i \leq 30 $ ) is a positive integer not exceeding 30.

After all modification queries, you need to output the final array.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ q $ ( $ 1 \leq n, q \leq 10^5 $ ) —the length of the array $ a $ and the number of queries respectively.

The second line of each test case contains $ n $ integers $ a_1, a_2, a_3, \ldots, a_n $ — the elements of the array $ a $ ( $ 1 \leq a_i \leq 10^9 $ ).

The third line of each test case contains $ q $ integers $ x_1, x_2, x_3, \ldots, x_q $ — the elements of the array $ x $ ( $ 1 \leq x_i \leq 30 $ ), which are the modification queries.

It is guaranteed that the sum of $ n $ and the sum of $ q $ across all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output the array after all of the modification queries.

## 说明/提示

In the first test case, the first query will add $ 2 $ to the integers in positions $ 4 $ and $ 5 $ . After this addition, the array would be $ [1, 2, 3, 6, 6] $ . Other operations will not modify the array.

In the second test case, the first modification query does not change the array. The second modification query will add $ 8 $ to the integer in position $ 5 $ , so that the array would look like this: $ [7, 8, 12, 36, 56, 6, 3] $ . The third modification query will add $ 2 $ to the integers in positions $ 2, 3 $ , $ 4 $ and $ 5 $ . The array would then look like this: $ [7, 10, 14, 38, 58, 6, 3] $ .

## 样例 #1

### 输入

```
4
5 3
1 2 3 4 4
2 3 4
7 3
7 8 12 36 48 6 3
10 4 2
5 4
2 2 2 2 2
1 1 1 1
5 5
1 2 4 8 16
5 2 3 4 1
```

### 输出

```
1 2 3 6 6 
7 10 14 38 58 6 3 
3 3 3 3 3 
1 3 7 11 19
```



---

---
title: "Two Out of Three"
layout: "post"
diff: 普及-
pid: CF1894B
tag: []
---

# Two Out of Three

## 题目描述

给定一个数组 $a_1, a_2, ..., a_n$。你需要找到一个数组 $b_1$, $b_2$, ..., $b_n$，其中包含数字 $1, 2, 3$，使得以下三个条件中恰好有两个条件被满足：

- 存在 $1\le i, j\le n$，使得 $a_i=a_j,b_i=1,b_j=2$。
- 存在 $1\le i, j\le n$，使得 $a_i=a_j,b_i=1,b_j=3$。
- 存在 $1\le i, j\le n$，使得 $a_i=a_j,b_i=2,b_j=3$。

如果不存在这样的数组 $b$，请报告不可以。

## 输入格式

每个测试点多测。第一行输入一个整数 $t$，表示数据组数。对于每一组数据：

第一行输入一个整数 $n$ $(1\le n\le 100)$，表示数组 $a$ 的长度。

第二行读入 $n$ 个整数 $a_1,a_2,...,a_n$ $(1\le a_i\le 100)$，代表数组 $a$。

## 输出格式

对于每组数据输出一行。若无解，则输出 `-1`。否则输出一个由 $1,2,3$ 组成的数组 $b$，恰好满足两条性质。如果有多个合法数组，输出任一即可。

### **说明/提示**

第一个数组 $a$，合法数组可以是 $b=[1,2,3,1,1,1]$。当 $i = 4,j = 2$ 时，满足性质一。当$i = 6,j = 3$ 时满足性质二。数组 $b$ 无法满足性质三，所以恰好满足两条，合法。

## 样例 #1

### 输入

```
9
6
1 2 3 2 2 3
7
7 7 7 7 7 7 7
4
1 1 2 2
7
1 2 3 4 5 6 7
5
2 3 3 3 2
3
1 2 1
9
1 1 1 7 7 7 9 9 9
1
1
18
93 84 50 21 88 52 16 50 63 1 30 85 29 67 63 58 37 69
```

### 输出

```
1 2 3 1 1 1 
-1
3 2 2 1 
-1
2 1 2 1 3 
-1
1 1 2 2 1 2 2 3 3
-1
3 2 1 3 3 3 3 2 2 1 1 2 3 1 3 1 1 2
```



---

---
title: "Points and Minimum Distance"
layout: "post"
diff: 普及-
pid: CF1895B
tag: []
---

# Points and Minimum Distance

## 题目描述

You are given a sequence of integers $ a $ of length $ 2n $ . You have to split these $ 2n $ integers into $ n $ pairs; each pair will represent the coordinates of a point on a plane. Each number from the sequence $ a $ should become the $ x $ or $ y $ coordinate of exactly one point. Note that some points can be equal.

After the points are formed, you have to choose a path $ s $ that starts from one of these points, ends at one of these points, and visits all $ n $ points at least once.

The length of path $ s $ is the sum of distances between all adjacent points on the path. In this problem, the distance between two points $ (x_1, y_1) $ and $ (x_2, y_2) $ is defined as $ |x_1-x_2| + |y_1-y_2| $ .

Your task is to form $ n $ points and choose a path $ s $ in such a way that the length of path $ s $ is minimized.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of testcases.

The first line of each testcase contains a single integer $ n $ ( $ 2 \le n \le 100 $ ) — the number of points to be formed.

The next line contains $ 2n $ integers $ a_1, a_2, \dots, a_{2n} $ ( $ 0 \le a_i \le 1\,000 $ ) — the description of the sequence $ a $ .

## 输出格式

For each testcase, print the minimum possible length of path $ s $ in the first line.

In the $ i $ -th of the following $ n $ lines, print two integers $ x_i $ and $ y_i $ — the coordinates of the point that needs to be visited at the $ i $ -th position.

If there are multiple answers, print any of them.

## 说明/提示

In the first testcase, for instance, you can form points $ (10, 1) $ and $ (15, 5) $ and start the path $ s $ from the first point and end it at the second point. Then the length of the path will be $ |10 - 15| + |1 - 5| = 5 + 4 = 9 $ .

In the second testcase, you can form points $ (20, 20) $ , $ (10, 30) $ , and $ (10, 30) $ , and visit them in that exact order. Then the length of the path will be $ |20 - 10| + |20 - 30| + |10 - 10| + |30 - 30| = 10 + 10 + 0 + 0 = 20 $ .

## 样例 #1

### 输入

```
2
2
15 1 10 5
3
10 30 20 20 30 10
```

### 输出

```
9
10 1
15 5
20
20 20
10 30
10 30
```



---

---
title: "AB Flipping"
layout: "post"
diff: 普及-
pid: CF1896B
tag: []
---

# AB Flipping

## 题目描述

You are given a string $ s $ of length $ n $ consisting of characters $ \texttt{A} $ and $ \texttt{B} $ . You are allowed to do the following operation:

- Choose an index $ 1 \le i \le n - 1 $ such that $ s_i = \texttt{A} $ and $ s_{i + 1} = \texttt{B} $ . Then, swap $ s_i $ and $ s_{i+1} $ .

You are only allowed to do the operation at most once for each index $ 1 \le i \le n - 1 $ . However, you can do it in any order you want. Find the maximum number of operations that you can carry out.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). Description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 2\cdot 10^5 $ ) — the length of string $ s $ .

The second line of each test case contains the string $ s $ ( $ s_i=\texttt{A} $ or $ s_i=\texttt{B} $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, print a single integer containing the maximum number of operations that you can carry out.

## 说明/提示

In the first test case, we can do the operation exactly once for $ i=1 $ as $ s_1=\texttt{A} $ and $ s_2=\texttt{B} $ .

In the second test case, it can be proven that it is not possible to do an operation.

In the third test case, we can do an operation on $ i=2 $ to form $ \texttt{ABAB} $ , then another operation on $ i=3 $ to form $ \texttt{ABBA} $ , and finally another operation on $ i=1 $ to form $ \texttt{BABA} $ . Note that even though at the end, $ s_2 = \texttt{A} $ and $ s_3 = \texttt{B} $ , we cannot do an operation on $ i=2 $ again as we can only do the operation at most once for each index.

## 样例 #1

### 输入

```
3
2
AB
4
BBBA
4
AABB
```

### 输出

```
1
0
3
```



---

---
title: "250 Thousand Tons of TNT"
layout: "post"
diff: 普及-
pid: CF1899B
tag: []
---

# 250 Thousand Tons of TNT

## 题目描述

Alex is participating in the filming of another video of BrMeast, and BrMeast asked Alex to prepare 250 thousand tons of TNT, but Alex didn't hear him well, so he prepared $ n $ boxes and arranged them in a row waiting for trucks. The $ i $ -th box from the left weighs $ a_i $ tons.

All trucks that Alex is going to use hold the same number of boxes, denoted by $ k $ . Loading happens the following way:

- The first $ k $ boxes goes to the first truck,
- The second $ k $ boxes goes to the second truck,
- $ \dotsb $
- The last $ k $ boxes goes to the $ \frac{n}{k} $ -th truck.

Upon loading is completed, each truck must have exactly $ k $ boxes. In other words, if at some point it is not possible to load exactly $ k $ boxes into the truck, then the loading option with that $ k $ is not possible.

Alex hates justice, so he wants the maximum absolute difference between the total weights of two trucks to be as great as possible. If there is only one truck, this value is $ 0 $ .

Alex has quite a lot of connections, so for every $ 1 \leq k \leq n $ , he can find a company such that each of its trucks can hold exactly $ k $ boxes. Print the maximum absolute difference between the total weights of any two trucks.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains one integer $ n $ ( $ 1 \leq n \leq 150\,000 $ ) — the number of boxes.

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the weights of the boxes.

It is guaranteed that the sum of $ n $ for all test cases does not exceed $ 150\,000 $ .

## 输出格式

For each test case, print a single integer — the answer to the problem.

## 说明/提示

In the first case, we should pick two trucks, so the first one will have only the first box, and the second one will have only the second box.

In the second case, we should pick six trucks, so the maximum will be $ 10 $ , the minimum will be $ 1 $ , and the answer is $ 10 - 1 = 9 $ .

In the third case, for any possible $ k $ , the trucks will have the same total weight of boxes, so the answer is $ 0 $ .

## 样例 #1

### 输入

```
5
2
1 2
6
10 2 3 6 1 3
4
1000000000 1000000000 1000000000 1000000000
15
60978 82265 78961 56708 39846 31071 4913 4769 29092 91348 64119 72421 98405 222 14294
8
19957 69913 37531 96991 57838 21008 14207 19198
```

### 输出

```
1
9
0
189114
112141
```



---

---
title: "Yarik and Array"
layout: "post"
diff: 普及-
pid: CF1899C
tag: []
---

# Yarik and Array

## 题目描述

A subarray is a continuous part of array.

Yarik recently found an array $ a $ of $ n $ elements and became very interested in finding the maximum sum of a non empty subarray. However, Yarik doesn't like consecutive integers with the same parity, so the subarray he chooses must have alternating parities for adjacent elements.

For example, $ [1, 2, 3] $ is acceptable, but $ [1, 2, 4] $ is not, as $ 2 $ and $ 4 $ are both even and adjacent.

You need to help Yarik by finding the maximum sum of such a subarray.

## 输入格式

The first line contains an integer $ t $ $ (1 \le t \le 10^4) $ — number of test cases. Each test case is described as follows.

The first line of each test case contains an integer $ n $ $ (1 \le n \le 2 \cdot 10^5) $ — length of the array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ $ (-10^3 \le a_i \le 10^3) $ — elements of the array.

It is guaranteed that the sum of $ n $ for all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the answer to the problem.

## 样例 #1

### 输入

```
7
5
1 2 3 4 5
4
9 9 8 8
6
-1 4 -1 0 5 -4
4
-1 2 4 -3
1
-1000
3
101 -99 101
20
-10 5 -8 10 6 -10 7 9 -2 -6 7 2 -4 6 -1 7 -6 -7 4 1
```

### 输出

```
15
17
8
4
-1000
101
10
```



---

---
title: "Triangle"
layout: "post"
diff: 普及-
pid: CF18A
tag: []
---

# Triangle

## 题目描述

At a geometry lesson Bob learnt that a triangle is called right-angled if it is nondegenerate and one of its angles is right. Bob decided to draw such a triangle immediately: on a sheet of paper he drew three points with integer coordinates, and joined them with segments of straight lines, then he showed the triangle to Peter. Peter said that Bob's triangle is not right-angled, but is almost right-angled: the triangle itself is not right-angled, but it is possible to move one of the points exactly by distance 1 so, that all the coordinates remain integer, and the triangle become right-angled. Bob asks you to help him and find out if Peter tricks him. By the given coordinates of the triangle you should find out if it is right-angled, almost right-angled, or neither of these.

## 输入格式

The first input line contains 6 space-separated integers $ x_{1},y_{1},x_{2},y_{2},x_{3},y_{3} $ — coordinates of the triangle's vertices. All the coordinates are integer and don't exceed 100 in absolute value. It's guaranteed that the triangle is nondegenerate, i.e. its total area is not zero.

## 输出格式

If the given triangle is right-angled, output RIGHT, if it is almost right-angled, output ALMOST, and if it is neither of these, output NEITHER.

## 样例 #1

### 输入

```
0 0 2 0 0 1

```

### 输出

```
RIGHT

```

## 样例 #2

### 输入

```
2 3 4 5 6 6

```

### 输出

```
NEITHER

```

## 样例 #3

### 输入

```
-1 0 2 0 0 1

```

### 输出

```
ALMOST

```



---

---
title: "Platforms"
layout: "post"
diff: 普及-
pid: CF18B
tag: []
---

# Platforms

## 题目描述

In one one-dimensional world there are $ n $ platforms. Platform with index $ k $ (platforms are numbered from 1) is a segment with coordinates $ [(k-1)m,(k-1)m+l] $ , and $ l<m $ . Grasshopper Bob starts to jump along the platforms from point $ 0 $ , with each jump he moves exactly $ d $ units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.

## 输入格式

The first input line contains 4 integer numbers $ n $ , $ d $ , $ m $ , $ l $ ( $ 1<=n,d,m,l<=10^{6},l<m $ ) — respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers $ m $ and $ l $ needed to find coordinates of the $ k $ -th platform: $ [(k-1)m,(k-1)m+l] $ .

## 输出格式

Output the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.

## 样例 #1

### 输入

```
2 2 5 3

```

### 输出

```
4

```

## 样例 #2

### 输入

```
5 4 11 8

```

### 输出

```
20

```



---

---
title: "Laura and Operations"
layout: "post"
diff: 普及-
pid: CF1900B
tag: []
---

# Laura and Operations

## 题目描述

Laura is a girl who does not like combinatorics. Nemanja will try to convince her otherwise.

Nemanja wrote some digits on the board. All of them are either $ 1 $ , $ 2 $ , or $ 3 $ . The number of digits $ 1 $ is $ a $ . The number of digits $ 2 $ is $ b $ and the number of digits $ 3 $ is $ c $ . He told Laura that in one operation she can do the following:

- Select two different digits and erase them from the board. After that, write the digit ( $ 1 $ , $ 2 $ , or $ 3 $ ) different from both erased digits.

For example, let the digits be $ 1 $ , $ 1 $ , $ 1 $ , $ 2 $ , $ 3 $ , $ 3 $ . She can choose digits $ 1 $ and $ 3 $ and erase them. Then the board will look like this $ 1 $ , $ 1 $ , $ 2 $ , $ 3 $ . After that, she has to write another digit $ 2 $ , so at the end of the operation, the board will look like $ 1 $ , $ 1 $ , $ 2 $ , $ 3 $ , $ 2 $ .

Nemanja asked her whether it was possible for only digits of one type to remain written on the board after some operations. If so, which digits can they be?

Laura was unable to solve this problem and asked you for help. As an award for helping her, she will convince Nemanja to give you some points.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^5 $ ). The description of the test cases follows.

The first and only line of each test case contains three integers $ a $ , $ b $ , $ c $ ( $ 1 \le a, b, c \le 100 $ ) — the number of ones, number of twos, and number of threes, respectively.

## 输出格式

For each test case, output one line containing $ 3 $ integers.

The first one should be $ 1 $ if it is possible that after some operations only digits $ 1 $ remain on the board, and $ 0 $ otherwise.

Similarly, the second one should be $ 1 $ if it is possible that after some operations only digits $ 2 $ remain on the board, and $ 0 $ otherwise.

Similarly, the third one should be $ 1 $ if it is possible that after some operations only digits $ 3 $ remain on the board, and $ 0 $ otherwise.

## 说明/提示

In the first test case, Laura can remove digits $ 2 $ and $ 3 $ and write digit $ 1 $ . After that, the board will have $ 2 $ digits $ 1 $ . She can make it have only digits $ 2 $ or $ 3 $ left by performing a similar operation.

In the second test case, she can remove digits $ 1 $ and $ 3 $ and write a digit $ 2 $ . After performing that operation $ 2 $ times, the board will have only digits $ 2 $ left. It can be proven that there is no way to have only digits $ 1 $ or only digits $ 3 $ left.

In the third test case, there is a sequence of operations that leaves only digits $ 1 $ on the board. It can be proven that there is no way to have only digits $ 2 $ or only digits $ 3 $ left.

## 样例 #1

### 输入

```
3
1 1 1
2 3 2
82 47 59
```

### 输出

```
1 1 1
0 1 0
1 0 0
```



---

---
title: "Chip and Ribbon"
layout: "post"
diff: 普及-
pid: CF1901B
tag: []
---

# Chip and Ribbon

## 题目描述

There is a ribbon divided into $ n $ cells, numbered from $ 1 $ to $ n $ from left to right. Initially, an integer $ 0 $ is written in each cell.

Monocarp plays a game with a chip. The game consists of several turns. During the first turn, Monocarp places the chip in the $ 1 $ -st cell of the ribbon. During each turn except for the first turn, Monocarp does exactly one of the two following actions:

- move the chip to the next cell (i. e. if the chip is in the cell $ i $ , it is moved to the cell $ i+1 $ ). This action is impossible if the chip is in the last cell;
- choose any cell $ x $ and teleport the chip into that cell. It is possible to choose the cell where the chip is currently located.

At the end of each turn, the integer written in the cell with the chip is increased by $ 1 $ .

Monocarp's goal is to make some turns so that the $ 1 $ -st cell contains the integer $ c_1 $ , the $ 2 $ -nd cell contains the integer $ c_2 $ , ..., the $ n $ -th cell contains the integer $ c_n $ . He wants to teleport the chip as few times as possible.

Help Monocarp calculate the minimum number of times he has to teleport the chip.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

Each test case consists of two lines:

- the first line contains one integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ );
- the second line contains $ n $ integers $ c_1, c_2, \dots, c_n $ ( $ 0 \le c_i \le 10^9 $ ; $ c_1 \ge 1 $ ).

It can be shown that under these constraints, it is always possible to make a finite amount of turns so that the integers in the cells match the sequence $ c_1, c_2, \dots, c_n $ .

Additional constraint on the input: the sum of values of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, print one integer — the minimum number of times Monocarp has to teleport the chip.

## 说明/提示

In the first test case of the example, Monocarp can perform the turns as follows:

- place the chip in the $ 1 $ -st cell; the numbers in the cells are $ [1, 0, 0, 0] $ ;
- move the chip to the next ( $ 2 $ -nd) cell; the numbers in the cells are $ [1, 1, 0, 0] $ ;
- move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $ [1, 1, 1, 0] $ ;
- teleport the chip to the $ 2 $ -nd cell; the numbers in the cells are $ [1, 2, 1, 0] $ ;
- move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $ [1, 2, 2, 0] $ ;
- move the chip to the next ( $ 4 $ -th) cell; the numbers in the cells are $ [1, 2, 2, 1] $ .

## 样例 #1

### 输入

```
4
4
1 2 2 1
5
1 0 1 0 1
5
5 4 3 2 1
1
12
```

### 输出

```
1
2
4
11
```



---

---
title: "Getting Points"
layout: "post"
diff: 普及-
pid: CF1902B
tag: []
---

# Getting Points

## 题目描述

Monocarp is a student at Berland State University. Due to recent changes in the Berland education system, Monocarp has to study only one subject — programming.

The academic term consists of $ n $ days, and in order not to get expelled, Monocarp has to earn at least $ P $ points during those $ n $ days. There are two ways to earn points — completing practical tasks and attending lessons. For each practical task Monocarp fulfills, he earns $ t $ points, and for each lesson he attends, he earns $ l $ points.

Practical tasks are unlocked "each week" as the term goes on: the first task is unlocked on day $ 1 $ (and can be completed on any day from $ 1 $ to $ n $ ), the second task is unlocked on day $ 8 $ (and can be completed on any day from $ 8 $ to $ n $ ), the third task is unlocked on day $ 15 $ , and so on.

Every day from $ 1 $ to $ n $ , there is a lesson which can be attended by Monocarp. And every day, Monocarp chooses whether to study or to rest the whole day. When Monocarp decides to study, he attends a lesson and can complete no more than $ 2 $  tasks, which are already unlocked and not completed yet. If Monocarp rests the whole day, he skips a lesson and ignores tasks.

Monocarp wants to have as many days off as possible, i. e. he wants to maximize the number of days he rests. Help him calculate the maximum number of days he can rest!

## 输入格式

The first line contains a single integer $ tc $ ( $ 1 \le tc \le 10^4 $ ) — the number of test cases. The description of the test cases follows.

The only line of each test case contains four integers $ n $ , $ P $ , $ l $ and $ t $ ( $ 1 \le n, l, t \le 10^9 $ ; $ 1 \le P \le 10^{18} $ ) — the number of days, the minimum total points Monocarp has to earn, the points for attending one lesson and points for completing one task.

It's guaranteed for each test case that it's possible not to be expelled if Monocarp will attend all lessons and will complete all tasks.

## 输出格式

For each test, print one integer — the maximum number of days Monocarp can rest without being expelled from University.

## 说明/提示

In the first test case, the term lasts for $ 1 $ day, so Monocarp should attend at day $ 1 $ . Since attending one lesson already gives $ 5 $ points ( $ 5 \ge P $ ), so it doesn't matter, will Monocarp complete the task or not.

In the second test case, Monocarp can, for example, study at days $ 8 $ and $ 9 $ : at day $ 8 $ he will attend a lesson for $ 10^9 $ points and complete two tasks for another $ 5 \cdot 10^8 + 5 \cdot 10^8 $ points. And at day $ 9 $ he only attends a lesson for another $ 10^9 $ points.

In the third test case, Monocarp can, for example, study at day $ 42 $ : attending a lesson gives him $ 1 $ point and solving $ 2 $ out of $ 6 $ available tasks gives him another $ 2 \cdot 10 $ points.

In the fourth test case, Monocarp has to attend all lessons and complete all tasks to get $ 8 \cdot 10 + 2 \cdot 20 = 120 $ points.

In the fifth test case, Monocarp can, for example, study at days: $ 8 $ — one lesson and first and second tasks; $ 15 $ — one lesson and the third task; $ 22 $ — one lesson and the fourth task; $ 29 $ — one lesson and the fifth task; $ 36 $ — one lesson and the sixth task.

## 样例 #1

### 输入

```
5
1 5 5 2
14 3000000000 1000000000 500000000
100 20 1 10
8 120 10 20
42 280 13 37
```

### 输出

```
0
12
99
0
37
```



---

---
title: "StORage room"
layout: "post"
diff: 普及-
pid: CF1903B
tag: []
---

# StORage room

## 题目描述

In Cyprus, the weather is pretty hot. Thus, Theofanis saw this as an opportunity to create an ice cream company.

He keeps the ice cream safe from other ice cream producers by locking it inside big storage rooms. However, he forgot the password. Luckily, the lock has a special feature for forgetful people!

It gives you a table $ M $ with $ n $ rows and $ n $ columns of non-negative integers, and to open the lock, you need to find an array $ a $ of $ n $ elements such that:

- $ 0 \le a_i < 2^{30} $ , and
- $ M_{i,j} = a_i | a_j $ for all $ i \neq j $ , where $ | $ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).

The lock has a bug, and sometimes it gives tables without any solutions. In that case, the ice cream will remain frozen for the rest of eternity.

Can you find an array to open the lock?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^{3} $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^{3} $ ) — the size of the hidden array.

The next $ n $ lines describe the rows of $ M $ , line $ i $ contains the table values $ M_{i,1}, M_{i,2}, \ldots, M_{i,n} $ ( $ 0 \le M_{i,j} < 2^{30} $ ).

It is guaranteed that $ M_{i,i} = 0 $ and $ M_{i,j} = M_{j,i} $ for all $ 1 \le i,j \le n $ .

It is also guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^{3} $ .

## 输出格式

For each test case, if there is a solution print YES and an array that satisfies the property, otherwise print NO.

If there are multiple solutions, print any of them.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 样例 #1

### 输入

```
4
1
0
4
0 3 3 5
3 0 3 7
3 3 0 7
5 7 7 0
5
0 7 7 5 5
7 0 3 2 6
7 3 0 3 7
5 2 3 0 4
5 6 7 4 0
3
0 0 1
0 0 0
1 0 0
```

### 输出

```
YES
7
YES
1 3 2 5 
YES
5 2 3 0 4
NO
```



---

---
title: "Collecting Game"
layout: "post"
diff: 普及-
pid: CF1904B
tag: []
---

# Collecting Game

## 题目描述

You are given an array $ a $ of $ n $ positive integers and a score. If your score is greater than or equal to $ a_i $ , then you can increase your score by $ a_i $ and remove $ a_i $ from the array.

For each index $ i $ , output the maximum number of additional array elements that you can remove if you remove $ a_i $ and then set your score to $ a_i $ . Note that the removal of $ a_i $ should not be counted in the answer.

## 输入格式

Each test contains multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 5000 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of the array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the elements of the array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output $ n $ integers, the $ i $ -th of which denotes the maximum number of additional array elements that you can remove if you remove $ a_i $ from the array and then set your score to $ a_i $ .

## 说明/提示

In the first test case, the answers are as follows:

If we start with $ i=4 $ , our initial score is $ a_4=4 $ and $ a=[20,5,1,2] $ . We can remove $ 3 $ additional elements in the following order:

1. Since $ 4 \ge 1 $ , we can remove $ 1 $ and our score becomes $ 5 $ . After this, $ a=[20,5,2] $ .
2. Since $ 5 \ge 5 $ , we can remove $ 5 $ and our score becomes $ 10 $ . After this, $ a=[20,2] $ .
3. Since $ 10 \ge 2 $ , we can remove $ 2 $ and our score becomes $ 12 $ . After this, $ a=[20] $ .

If we start with $ i=1 $ we can remove all remaining elements in the array, so the answer is $ 4 $ .

If we start with $ i=2 $ , we can remove $ 3 $ additional elements in the following order: $ 1 $ , $ 4 $ , $ 2 $ .

If we start with $ i=3 $ , we can remove no additional elements.

If we start with $ i=5 $ , we can remove $ 1 $ additional element: $ 1 $ .

## 样例 #1

### 输入

```
4
5
20 5 1 4 2
3
1434 7 1442
1
1
5
999999999 999999999 999999999 1000000000 1000000000
```

### 输出

```
4 3 0 3 1 
1 0 2 
0 
4 4 4 4 4
```



---

---
title: "Begginer's Zelda"
layout: "post"
diff: 普及-
pid: CF1905B
tag: []
---

# Begginer's Zelda

## 题目描述

You are given a tree $ ^{\dagger} $ . In one zelda-operation you can do follows:

- Choose two vertices of the tree $ u $ and $ v $ ;
- Compress all the vertices on the path from $ u $ to $ v $ into one vertex. In other words, all the vertices on path from $ u $ to $ v $ will be erased from the tree, a new vertex $ w $ will be created. Then every vertex $ s $ that had an edge to some vertex on the path from $ u $ to $ v $ will have an edge to the vertex $ w $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1905B/c3222ff4e4569cd9f8a56d2650b8f98bd69be3cf.png) Illustration of a zelda-operation performed for vertices $ 1 $ and $ 5 $ .Determine the minimum number of zelda-operations required for the tree to have only one vertex.

 $ ^{\dagger} $ A tree is a connected acyclic undirected graph.

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^5 $ ) — the number of vertices.

 $ i $ -th of the next $ n − 1 $ lines contains two integers $ u_i $ and $ v_i $ ( $ 1 \le u_i, v_i \le n, u_i \ne v_i $ ) — the numbers of vertices connected by the $ i $ -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output a single integer — the minimum number of zelda-operations required for the tree to have only one vertex.

## 说明/提示

In the first test case, it's enough to perform one zelda-operation for vertices $ 2 $ and $ 4 $ .

In the second test case, we can perform the following zelda-operations:

1. $ u = 2, v = 1 $ . Let the resulting added vertex be labeled as $ w = 10 $ ;
2. $ u = 4, v = 9 $ . Let the resulting added vertex be labeled as $ w = 11 $ ;
3. $ u = 8, v = 10 $ . After this operation, the tree consists of a single vertex.

## 样例 #1

### 输入

```
4
4
1 2
1 3
3 4
9
3 1
3 5
3 2
5 6
6 7
7 8
7 9
6 4
7
1 2
1 3
2 4
4 5
3 6
2 7
6
1 2
1 3
1 4
4 5
2 6
```

### 输出

```
1
3
2
2
```



---

---
title: "Removal of Unattractive Pairs"
layout: "post"
diff: 普及-
pid: CF1907C
tag: []
---

# Removal of Unattractive Pairs

## 题目描述

Vlad found a string $ s $ consisting of $ n $ lowercase Latin letters, and he wants to make it as short as possible.

To do this, he can remove any pair of adjacent characters from $ s $ any number of times, provided they are different. For example, if $ s $ =racoon, then by removing one pair of characters he can obtain the strings coon, roon, raon, and raco, but he cannot obtain racn (because the removed letters were the same) or rcon (because the removed letters were not adjacent).

What is the minimum length Vlad can achieve by applying any number of deletions?

## 输入格式

The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Descriptions of the test cases follow.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the length of the string $ s $ .

The second line of each test case contains the string $ s $ consisting of $ n $ lowercase Latin letters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single number—the minimum length of the string $ s $ , after removing pairs of adjacent characters with different values.

## 说明/提示

In the first test case of the example, you need to act as follows: "aabc" $ \rightarrow $ "ac" $ \rightarrow $ "". Note that with a different order of deletions, the string will not become empty.

## 样例 #1

### 输入

```
10
4
aabc
5
abaca
10
avbvvcvvvd
7
abcdefg
5
dabbb
8
aacebeaa
7
bbbbacc
6
dacfcc
6
fdfcdc
9
dbdcfbbdc
```

### 输出

```
0
1
2
1
1
0
1
0
0
1
```



---

---
title: "Make Almost Equal With Mod"
layout: "post"
diff: 普及-
pid: CF1909B
tag: []
---

# Make Almost Equal With Mod

## 题目描述

[xi - Solar Storm](https://soundcloud.com/yugenero/xi-solar-storm)

⠀



You are given an array $ a_1, a_2, \dots, a_n $ of distinct positive integers. You have to do the following operation exactly once:

- choose a positive integer $ k $ ;
- for each $ i $ from $ 1 $ to $ n $ , replace $ a_i $ with $ a_i \text{ mod } k^\dagger $ .

Find a value of $ k $ such that $ 1 \leq k \leq 10^{18} $ and the array $ a_1, a_2, \dots, a_n $ contains exactly $ 2 $ distinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such $ k $ always exists. If there are multiple solutions, you can print any of them.

 $ ^\dagger $ $ a \text{ mod } b $ denotes the remainder after dividing $ a $ by $ b $ . For example:

- $ 7 \text{ mod } 3=1 $ since $ 7 = 3 \cdot 2 + 1 $
- $ 15 \text{ mod } 4=3 $ since $ 15 = 4 \cdot 3 + 3 $
- $ 21 \text{ mod } 1=0 $ since $ 21 = 21 \cdot 1 + 0 $

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 500 $ ). The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 100 $ ) — the length of the array $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^{17} $ ) — the initial state of the array. It is guaranteed that all the $ a_i $ are distinct.

Note that there are no constraints on the sum of $ n $ over all test cases.

## 输出格式

For each test case, output a single integer: a value of $ k $ ( $ 1 \leq k \leq 10^{18} $ ) such that the array $ a_1, a_2, \dots, a_n $ contains exactly $ 2 $ distinct values at the end of the operation.

## 说明/提示

In the first test case, you can choose $ k = 7 $ . The array becomes $ [8 \text{ mod } 7, 15 \text{ mod } 7, 22 \text{ mod } 7, 30 \text{ mod } 7] = [1, 1, 1, 2] $ , which contains exactly $ 2 $ distinct values ( $ \{1, 2\} $ ).

In the second test case, you can choose $ k = 30 $ . The array becomes $ [0, 0, 8, 0, 8] $ , which contains exactly $ 2 $ distinct values ( $ \{0, 8\} $ ). Note that choosing $ k = 10 $ would also be a valid solution.

In the last test case, you can choose $ k = 10^{18} $ . The array becomes $ [2, 1] $ , which contains exactly $ 2 $ distinct values ( $ \{1, 2\} $ ). Note that choosing $ k = 10^{18} + 1 $ would not be valid, because $ 1 \leq k \leq 10^{18} $ must be true.

## 样例 #1

### 输入

```
5
4
8 15 22 30
5
60 90 98 120 308
6
328 769 541 986 215 734
5
1000 2000 7000 11000 16000
2
2 1
```

### 输出

```
7
30
3
5000
1000000000000000000
```



---

---
title: "Vasya and the Bus"
layout: "post"
diff: 普及-
pid: CF190A
tag: []
---

# Vasya and the Bus

## 题目描述

--

一天，Vasya 听到一个故事，它说：“在 High Bertown 城，一辆 $62$ 路公交车带着 $n$ 位大人和 $m$ 位小孩，从公交车站开了出来……”

至于那些后续，都是无关紧要的。Vasya 是一位会计，而且他很享受数钱数到手抽经的快感。因此，他想知道这趟车上的这些乘客所付车票钱的最小值和最大值是多少

在 High Bertown 城，公交车的车票为 $1$ 卢布 。但是，那么简单的题目想都别想遇到—— $1$ 位大人可以免票带 $1$ 位小孩。这意味着 $1$ 位大人和 $k$ 个小孩共同乘车，总的需要 $k$ 卢布的车票；他自己需要 $1$ 张车票，孩子们需要 $(k-1)$  张。除此之外，大人们可以不带孩子乘车，这样他们就只要支付自己的 $1$ 卢布车票钱。

同时，我们还知道在 High Bertown 城，孩子们不能在没有大人的陪同下单独乘车。

请你帮帮 Vasya 计算一下这辆车上乘客需付金额总和的最小值和最大值。

---

## 输入格式

输入文件包括一行两个整数 $n$ 和 $m$ $(0\leq n,m\leq 10^5)$ 。其相互对应车上大人和小孩的人数。

## 输出格式

---


如果 $n$ 位大人和 $m$ 位孩子乘车的情况合法，则在一行内输出以空格分隔的两个整数——最小值和最大值。

否则，输出"Impossible"(不含引号)。

---

## 说明/提示

---

在第一个样例中， $1$ 位大人和 $2$ 位孩子乘车，不管怎么样，都需要支付 $2$ 卢布。

在第二个样例中，只有孩子乘车是不合法的。

在第三个样例中，有两种情况：

1.  $2$ 位大人各带 $1$ 位小孩，各付 $1$ 卢布车票钱。此时，乘客们一共支付了 $2$ 卢布。

2. 另一种情况下，一位大人带 $2$ 位孩子，支付 $2$ 卢布车票钱；另一位独自乘车，花费 $1$ 卢布。因此，他们一共支付了 $3$ 卢布。

## 样例 #1

### 输入

```
1 2

```

### 输出

```
2 2
```

## 样例 #2

### 输入

```
0 5

```

### 输出

```
Impossible
```

## 样例 #3

### 输入

```
2 2

```

### 输出

```
2 3
```



---

---
title: "Swap and Delete"
layout: "post"
diff: 普及-
pid: CF1913B
tag: []
---

# Swap and Delete

## 题目描述

有一个只含 $\texttt{0}$ 和 $\texttt{1}$ 的字符串 $s$，你可以对它进行如下两种操作：

1. 耗费一个金币，从 $s$ 中删除 $1$ 个字符。

2. 将 $s$ 中任意两字符互换位置（免费）。

定义一个字符串 $t$ 是美的代表对于所有满足 $1 \le i \le \left|t\right|$ 的 $i$，$s_i \ne t_i$ 。

你可以进行任意多次操作，假设 $s$ 修改后变为了 $s'$，问最少花费多少金币能使最终得到的 $s'$ 是美的。

## 输入格式

**本题单测试点内有多组数据。**

第一行，一个整数 $t(1 \le t \le 10^4)$，表示数据的组数。

接下来的 $t$ 行，每行一个字符串 $s$。$(1 \le \left|s\right| \le 2 \times 10^5,s_i \in \{\texttt{0},\texttt{1}\})$。

## 输出格式

对于每一组数据，输出一行，为最少花费的金币数。

## 样例 #1

### 输入

```
4
0
011
0101110001
111100
```

### 输出

```
1
1
0
4
```



---

---
title: "Minimize Inversions"
layout: "post"
diff: 普及-
pid: CF1918B
tag: []
---

# Minimize Inversions

## 题目描述

You are given two permutations $ a $ and $ b $ of length $ n $ . A permutation is an array of $ n $ elements from $ 1 $ to $ n $ where all elements are distinct. For example, an array \[ $ 2,1,3 $ \] is a permutation, but \[ $ 0,1 $ \] and \[ $ 1,3,1 $ \] aren't.

You can (as many times as you want) choose two indices $ i $ and $ j $ , then swap $ a_i $ with $ a_j $ and $ b_i $ with $ b_j $ simultaneously.

You hate inversions, so you want to minimize the total number of inversions in both permutations.

An inversion in a permutation $ p $ is a pair of indices $ (i, j) $ such that $ i < j $ and $ p_i > p_j $ . For example, if $ p=[3,1,4,2,5] $ then there are $ 3 $ inversions in it (the pairs of indices are $ (1,2) $ , $ (1,4) $ and $ (3,4) $ ).

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 20\,000 $ ) — the number of test cases.

Each test case consists of three lines. The first line contains an integer $ n $ ( $ 1 \leq n \leq 2\cdot10^5 $ ) — the length of the permutations $ a $ and $ b $ . The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq n $ ) — permutation $ a $ . The third line contains $ b $ in a similar format.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot10^5 $ .

## 输出格式

For each test case, output two permutations $ a' $ and $ b' $ (in the same format as in the input) — the permutations after all operations. The total number of inversions in $ a' $ and $ b' $ should be the minimum possible among all pairs of permutations that can be obtained using operations from the statement.

If there are multiple solutions, print any of them.

## 说明/提示

In the first test case, the minimum possible number of inversions is $ 10 $ .

In the second test case, we can sort both permutations at the same time. For this, the following operations can be done:

- Swap the elements in the positions $ 1 $ and $ 3 $ in both permutations. After the operation, $ a = $ \[ $ 2,1,3 $ \], $ b = $ \[ $ 2,1,3 $ \].
- Swap the elements in the positions $ 1 $ and $ 2 $ . After the operations, $ a $ and $ b $ are sorted.

In the third test case, the minimum possible number of inversions is $ 7 $ .

## 样例 #1

### 输入

```
3
5
1 2 3 4 5
5 4 3 2 1
3
3 1 2
3 1 2
6
2 5 6 1 3 4
1 5 3 6 2 4
```

### 输出

```
3 2 5 1 4
3 4 1 5 2
1 2 3
1 2 3
2 3 4 6 5 1
1 2 4 3 5 6
```



---

---
title: "Plus-Minus Split"
layout: "post"
diff: 普及-
pid: CF1919B
tag: []
---

# Plus-Minus Split

## 题目描述

You are given a string $ s $ of length $ n $ consisting of characters "+" and "-". $ s $ represents an array $ a $ of length $ n $ defined by $ a_i=1 $ if $ s_i= $ "+" and $ a_i=-1 $ if $ s_i= $ "-".

You will do the following process to calculate your penalty:

1. Split $ a $ into non-empty arrays $ b_1,b_2,\ldots,b_k $ such that $ b_1+b_2+\ldots+b_k=a^\dagger $ , where $ + $ denotes array concatenation.
2. The penalty of a single array is the absolute value of its sum multiplied by its length. In other words, for some array $ c $ of length $ m $ , its penalty is calculated as $ p(c)=|c_1+c_2+\ldots+c_m| \cdot m $ .
3. The total penalty that you will receive is $ p(b_1)+p(b_2)+\ldots+p(b_k) $ .

If you perform the above process optimally, find the minimum possible penalty you will receive.

 $ ^\dagger $ Some valid ways to split $ a=[3,1,4,1,5] $ into $ (b_1,b_2,\ldots,b_k) $ are $ ([3],[1],[4],[1],[5]) $ , $ ([3,1],[4,1,5]) $ and $ ([3,1,4,1,5]) $ while some invalid ways to split $ a $ are $ ([3,1],[1,5]) $ , $ ([3],[\,],[1,4],[1,5]) $ and $ ([3,4],[5,1,1]) $ .

## 输入格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 5000 $ ) — the length of string $ s $ .

The second line of each test case contains string $ s $ ( $ s_i \in \{ \mathtt{+}, \mathtt{-} \} $ , $ |s| = n $ ).

Note that there are no constraints on the sum of $ n $ over all test cases.

## 输出格式

For each test case, output a single integer representing the minimum possible penalty you will receive.

## 说明/提示

In the first test case, we have $ a=[1] $ . We can split array $ a $ into $ ([1]) $ . Then, the sum of penalties of the subarrays is $ p([1]) = 1 $ .

In the second test case, we have $ a=[-1,-1,-1,-1,-1] $ . We can split array $ a $ into $ ([-1],[-1],[-1],[-1],[-1]) $ . Then, the sum of penalties of the subarrays is $ p([-1]) + p([-1]) + p([-1]) + p([-1]) + p([-1]) = 1 + 1 + 1 + 1 + 1 = 5 $ .

In the third test case, we have $ a=[1,-1,1,-1,1,-1] $ . We can split array $ a $ into $ ([1,-1,1,-1],[1,-1]) $ . Then, the sum of penalties of the subarrays is $ p([1,-1,1,-1]) + p([1,-1]) = 0 + 0 = 0 $ .

## 样例 #1

### 输入

```
5
1
+
5
-----
6
+-+-+-
10
--+++++++-
20
+---++++-+++++---++-
```

### 输出

```
1
5
0
4
4
```



---

---
title: "Summation Game"
layout: "post"
diff: 普及-
pid: CF1920B
tag: []
---

# Summation Game

## 题目描述

Alice and Bob are playing a game. They have an array $ a_1, a_2,\ldots,a_n $ . The game consists of two steps:

- First, Alice will remove at most $ k $ elements from the array.
- Second, Bob will multiply at most $ x $ elements of the array by $ -1 $ .

Alice wants to maximize the sum of elements of the array while Bob wants to minimize it. Find the sum of elements of the array after the game if both players play optimally.

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains three integers $ n $ , $ k $ , and $ x $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ , $ 1 \leq x,k \leq n $ ) — the number of elements in the array, the limit on the number of elements of the array that Alice can remove, and the limit on the number of elements of the array that Bob can multiply $ -1 $ to.

The second line of each test case contains $ n $ integers $ a_1, a_2,\ldots, a_n $ ( $ 1 \leq a_i \leq 1000 $ ) — the elements of the array.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the sum of elements of the array after the game if both players play optimally.

## 说明/提示

In the first test case, it is optimal for Alice to remove the only element of the array. Then, the sum of elements of the array is $ 0 $ after the game is over.

In the second test case, it is optimal for Alice to not remove any elements. Bob will then multiply $ 4 $ by $ -1 $ . So the final sum of elements of the array is $ 3+1+2-4=2 $ .

In the fifth test case, it is optimal for Alice to remove $ 9, 9 $ . Bob will then multiply $ 5, 5, 3 $ by $ -1 $ . So the final sum of elements of the array is $ -5-5-3+3+3+2=-5 $ .

## 样例 #1

### 输入

```
8
1 1 1
1
4 1 1
3 1 2 4
6 6 3
1 4 3 2 5 6
6 6 1
3 7 3 3 32 15
8 5 3
5 5 3 3 3 2 9 9
10 6 4
1 8 2 9 3 3 4 5 3 200
2 2 1
4 3
2 1 2
1 3
```

### 输出

```
0
2
0
3
-5
-9
0
-1
```



---

---
title: "Sending Messages"
layout: "post"
diff: 普及-
pid: CF1921C
tag: []
---

# Sending Messages

## 题目描述

Stepan是一个busy的人。今天，他需要在 $m_1,m_2,\dots m_n$ 时刻发送 $n$ 条信息。很惨的是，到 $0$ 时刻，他的手机只剩 $f$ 个单位电量。此时手机已开机。

手机每开机一时刻就会损失 $a$ 个单位电量。此外，Stepan可以随时关闭手机，稍后再开机，每次共消耗 $b$ 个单位的能量。开关机不花费任何时间，这样就可以在 $x$ 时刻打开它，同时发送信息，反之，在 $x$ 时刻发送信息同时关闭手机也是可以的。

如果在任何时候电量降至 $0$ 以下，则手机自动关机，无法发送消息。Stepan想知道是否可以在不给手机充电的情况下发送所有信息。

## 输入格式

_**本题包含多组测试数据。**_ 
 
第一行一个整数 $T$( $ 1 \le T \le 10^4 $ ) ，表示测试用例数量。

对于每个测试用例，第一行输入四个整数 $n,f,a,b$( $ 1 \le n \le 2 \cdot 10^5 $ , $ 1 \le f, a, b \le 10^9 $ ) ，意义已给出。第二行输入 $n$ 个整数 $m_1,m_2,\dots m_n$( $ 1 \le m_i \le 10^9 $ ) ，保证其单调递增。

## 输出格式

对于每个测试用例，输出字符串 ```YES``` 或 ```NO``` 的一种，表示是否能发送所有信息。

## 样例 #1

### 输入

```
6
1 3 1 5
3
7 21 1 3
4 6 10 13 17 20 26
5 10 1 2
1 2 3 4 5
1 1000000000 1000000000 1000000000
1000000000
3 11 9 6
6 8 10
12 621526648 2585904 3566299
51789 61859 71998 73401 247675 298086 606959 663464 735972 806043 806459 919683
```

### 输出

```
NO
YES
YES
NO
NO
YES
```



---

---
title: "A Balanced Problemset?"
layout: "post"
diff: 普及-
pid: CF1925B
tag: []
---

# A Balanced Problemset?

## 题目描述

**题意简述**

有一个序列，已知其和为 $X$，长度为 $N$，求这个序列最大的最大公因数。

## 输入格式

第一行有一个整数 $T$，有 $T$ 组数据。

接下来 $T$ 行，每行两个整数，分别为 $X,N$。

## 输出格式

每组数据输出一行，表示可能的最大公因数。

## 样例 #1

### 输入

```
3
10 3
5 5
420 69
```

### 输出

```
2
1
6
```



---

---
title: "Vlad and a Sum of Sum of Digits"
layout: "post"
diff: 普及-
pid: CF1926C
tag: []
---

# Vlad and a Sum of Sum of Digits

## 题目描述

Please note that the time limit for this problem is only 0.5 seconds per test.

Vladislav wrote the integers from $ 1 $ to $ n $ , inclusive, on the board. Then he replaced each integer with the sum of its digits.

What is the sum of the numbers on the board now?

For example, if $ n=12 $ then initially the numbers on the board are: $ $$$1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12. $ $  Then after the replacement, the numbers become:  $ $ 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3. $ $  The sum of these numbers is  $ 1+2+3+4+5+6+7+8+9+1+2+3=51 $ . Thus, for  $ n=12 $  the answer is  $ 51$$$.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The only line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the largest number Vladislav writes.

## 输出格式

For each test case, output a single integer — the sum of the numbers at the end of the process.

## 样例 #1

### 输入

```
7
12
1
2
3
1434
2024
200000
```

### 输出

```
51
1
3
6
18465
28170
4600002
```



---

---
title: "Vlad and Division"
layout: "post"
diff: 普及-
pid: CF1926D
tag: []
---

# Vlad and Division

## 题目描述

Vladislav has $ n $ non-negative integers, and he wants to divide all of them into several groups so that in any group, any pair of numbers does not have matching bit values among bits from $ 1 $ -st to $ 31 $ -st bit (i.e., considering the $ 31 $ least significant bits of the binary representation).

For an integer $ k $ , let $ k_2(i) $ denote the $ i $ -th bit in its binary representation (from right to left, indexing from 1). For example, if $ k=43 $ , since $ 43=101011_2 $ , then $ 43_2(1)=1 $ , $ 43_2(2)=1 $ , $ 43_2(3)=0 $ , $ 43_2(4)=1 $ , $ 43_2(5)=0 $ , $ 43_2(6)=1 $ , $ 43_2(7)=0 $ , $ 43_2(8)=0, \dots, 43_2(31)=0 $ .

Formally, for any two numbers $ x $ and $ y $ in the same group, the condition $ x_2(i) \neq y_2(i) $ must hold for all $ 1 \leq i < 32 $ .

What is the minimum number of groups Vlad needs to achieve his goal? Each number must fall into exactly one group.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the total number of integers.

The second line of each test case contains $ n $ given integers $ a_1, \ldots, a_n $ ( $ 0 \leq a_j < 2^{31} $ ).

The sum of $ n $ over all test cases in a test does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the minimum number of groups required to satisfy the condition.

## 说明/提示

In the first test case, any two numbers have the same last $ 31 $ bits, so we need to place each number in its own group.

In the second test case, $ a_1=0000000000000000000000000000000_2 $ , $ a_2=1111111111111111111111111111111_2 $ so they can be placed in the same group because $ a_1(i) \ne a_2(i) $ for each $ i $ between $ 1 $ and $ 31 $ , inclusive.

## 样例 #1

### 输入

```
9
4
1 4 3 4
2
0 2147483647
5
476319172 261956880 2136179468 1671164475 1885526767
3
1335890506 811593141 1128223362
4
688873446 627404104 1520079543 1458610201
4
61545621 2085938026 1269342732 1430258575
4
0 0 2147483647 2147483647
3
0 0 2147483647
8
1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735
```

### 输出

```
4
1
3
2
2
3
2
2
4
```



---

---
title: "Sasha and the Drawing"
layout: "post"
diff: 普及-
pid: CF1929B
tag: []
---

# Sasha and the Drawing

## 题目描述

即使在幼儿园，Sasha 也喜欢一个女孩。因此，他想给她一幅画，并吸引她的注意力。

作为绘画，他决定绘制一个大小为 $n\times n$ 的正方形网格，其中染色的一些单元格。但是着色单元格很困难，因此他希望尽可能少地染色。但与此同时，他希望至少有 $k$ 条对角线至少有一个染色单元格。注意，大小为 $n \times n$ 的正方形网格总共有 $4n - 2$ 条对角线。

帮助小 Sasha 让女孩爱上他，并告诉他需要染色的最少单元格数。

## 输入格式

每个测试用例包括多个测试。第一行包含一个整数 $t$（$1 \le t \le 1000$）——测试用例数。接下来是描述测试用例。

每个测试用例的唯一行包含两个整数 $n$ 和 $k$（$2 \leq n \leq 10^8$，$1 \leq k \leq 4n - 2$）——正方形网格的大小和至少应包含一个染色单元格的对角线数。

## 输出格式

对于每个测试用例，输出一个整数——需要染色的最少单元格数。

### 样例

#### 输入样例：

```
7
3 4
3 3
3 10
3 9
4 7
7 11
2 3
```

#### 输出样例：

```
2
2
6
5
4
6
2
```

## 说明/提示

下面的图片中，黑色标记染色单元格，所有对角线标记为紫色。

在第一个测试用例中，您可以染色 $2$ 个单元格，以使 $4$ 条对角线包含至少一个染色单元格。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1929B/4864b78fe9eb050caf4657b8002f6908e15fc9d0.png)

在第三个测试用例中，您可以染色 $6$ 个单元格，以使所有 $10$ 条对角线都包含至少一个染色单元格。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1929B/739c9b82a674c23c09f172f9a61b92f42e5cc20b.png)

## 样例 #1

### 输入

```
7
3 4
3 3
3 10
3 9
4 7
7 11
2 3
```

### 输出

```
2
2
6
5
4
6
2
```



---

---
title: "Funky Numbers"
layout: "post"
diff: 普及-
pid: CF192A
tag: []
---

# Funky Numbers

## 题目描述

今年最时髦的数字是三角数（即可表示为 $\frac{k(k+1)}{2}$ 的数字，其中 $k$ 是正整数），而今年最酷的数字是那些可表示为两个三角数之和的数字。

著名的嬉皮士安德烈崇拜一切酷而时髦的东西。但不幸的是，他不擅长数学。给定一个数字 $n$，请帮助他确定这个数字是否能够由两个三角形数的和来表示。（两个三角数可以相同）

## 输入格式

一行，一个数 $n\ (1\le n \le 10^9)$。

## 输出格式

输出这个数是否满足安德烈的要求。如果是，输出 `YES`，否则输出 `NO`。

## 样例 #1

### 输入

```
256

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
512

```

### 输出

```
NO

```



---

---
title: "Walking in the Rain"
layout: "post"
diff: 普及-
pid: CF192B
tag: []
---

# Walking in the Rain

## 题目描述

In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of $ n $ tiles that are lain in a row and are numbered from $ 1 $ to $ n $ from right to left. The opposition should start walking on the tile number $ 1 $ and the finish on the tile number $ n $ . During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number $ i $ $ (i&lt;n-1) $ , you can reach the tiles number $ i+1 $ or the tile number $ i+2 $ from it (if you stand on the tile number $ n-1 $ , you can only reach tile number $ n $ ). We can assume that all the opposition movements occur instantaneously.

In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the $ i $ -th tile is destroyed after $ a_{i} $ days of rain (on day $ a_{i} $ tile isn't destroyed yet, and on day $ a_{i}+1 $ it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number $ 1 $ is broken, or the tile number $ n $ is broken, or it is impossible to reach the tile number $ n $ from the tile number $ 1 $ if we can walk on undestroyed tiles.

The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number $ 1 $ to the tile number $ n $ will be possible.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=10^{3} $ ) — the boulevard's length in tiles.

The second line contains $ n $ space-separated integers $ a_{i} $ — the number of days after which the $ i $ -th tile gets destroyed ( $ 1<=a_{i}<=10^{3} $ ).

## 输出格式

Print a single number — the sought number of days.

## 说明/提示

In the first sample the second tile gets destroyed after day three, and the only path left is $ 1→3→4 $ . After day five there is a two-tile gap between the first and the last tile, you can't jump over it.

In the second sample path $ 1→3→5 $ is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.

## 样例 #1

### 输入

```
4
10 3 5 10

```

### 输出

```
5

```

## 样例 #2

### 输入

```
5
10 2 8 3 5

```

### 输出

```
5

```



---

---
title: "Make Equal Again"
layout: "post"
diff: 普及-
pid: CF1931C
tag: []
---

# Make Equal Again

## 题目描述

You have an array $ a $ of $ n $ integers.

You can no more than once apply the following operation: select three integers $ i $ , $ j $ , $ x $ ( $ 1 \le i \le j \le n $ ) and assign all elements of the array with indexes from $ i $ to $ j $ the value $ x $ . The price of this operation depends on the selected indices and is equal to $ (j - i + 1) $ burles.

For example, the array is equal to $ [1, 2, 3, 4, 5, 1] $ . If we choose $ i = 2, j = 4, x = 8 $ , then after applying this operation, the array will be equal to $ [1, 8, 8, 8, 5, 1] $ .

What is the least amount of burles you need to spend to make all the elements of the array equal?

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of input test cases. The descriptions of the test cases follow.

The first line of the description of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10 ^ 5 $ ) — the size of the array.

The second line of the description of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ) — array elements.

It is guaranteed that the sum of $ n $ for all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output one integer — the minimum number of burles that will have to be spent to make all the elements of the array equal. It can be shown that this can always be done.

## 样例 #1

### 输入

```
8
6
1 2 3 4 5 1
7
1 1 1 1 1 1 1
8
8 8 8 1 2 8 8 8
1
1
2
1 2
3
1 2 3
7
4 3 2 7 1 1 3
9
9 9 2 9 2 5 5 5 3
```

### 输出

```
4
0
2
0
1
2
6
7
```



---

---
title: "Informatics in MAC"
layout: "post"
diff: 普及-
pid: CF1935B
tag: []
---

# Informatics in MAC

## 题目描述

In the Master's Assistance Center, Nyam-Nyam was given a homework assignment in informatics.

There is an array $ a $ of length $ n $ , and you want to divide it into $ k > 1 $ subsegments $ ^{\dagger} $ in such a way that the $ \operatorname{MEX} ^{\ddagger} $ on each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not exist.

 $ ^{\dagger} $ A division of an array into $ k $ subsegments is defined as $ k $ pairs of integers $ (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) $ such that $ l_i \le r_i $ and for each $ 1 \le j \le k - 1 $ , $ l_{j + 1} = r_j + 1 $ , and also $ l_1 = 1 $ and $ r_k = n $ . These pairs represent the subsegments themselves.

 $ ^{\ddagger}\operatorname{MEX} $ of an array is the smallest non-negative integer that does not belong to the array.

For example:

- $ \operatorname{MEX} $ of the array $ [2, 2, 1] $ is $ 0 $ , because $ 0 $ does not belong to the array.
- $ \operatorname{MEX} $ of the array $ [3, 1, 0, 1] $ is $ 2 $ , because $ 0 $ and $ 1 $ belong to the array, but $ 2 $ does not.
- $ \operatorname{MEX} $ of the array $ [0, 3, 1, 2] $ is $ 4 $ , because $ 0 $ , $ 1 $ , $ 2 $ , and $ 3 $ belong to the array, but $ 4 $ does not.

## 输入格式

Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^5 $ ) — the length of the array $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i < n $ ) — the elements of the array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output a single integer $ -1 $ if a suitable division does not exist.

Otherwise, on the first line, output an integer $ k $ ( $ 2 \le k \le n $ ) — the number of subsegments in the division.

Then output $ k $ lines — the division into subsegments. The $ i $ -th line should contain two integers $ l_i $ and $ r_i $ ( $ 1 \le l_i \le r_i \le n $ ) — the boundaries of the $ i $ -th subsegment.

The following conditions must be satisfied:

- For all $ 1 \le j \le k - 1 $ , $ l_{j + 1} = r_j + 1 $ ;
- $ l_1 = 1 $ , $ r_k = n $ .

If there are multiple possible solutions, output any of them.

## 说明/提示

In the first test case, the array $ a $ can be divided into $ 2 $ subsegments with boundaries $ [1, 1] $ and $ [2, 2] $ :

- $ \operatorname{MEX} $ of the first subsegment $ [0] $ is $ 1 $ , as $ 0 $ belongs to the subsegment, but $ 1 $ does not.
- $ \operatorname{MEX} $ of the second subsegment $ [0] $ is $ 1 $ , as $ 0 $ belongs to the subsegment, but $ 1 $ does not.

In the second test case, it can be proven that the required division does not exist.

In the third test case, the array $ a $ can be divided into $ 3 $ subsegments with boundaries $ [1, 3] $ , $ [4, 5] $ , $ [6, 8] $ :

- $ \operatorname{MEX} $ of the first subsegment $ [0, 1, 7] $ is $ 2 $ , as $ 0 $ and $ 1 $ belong to the subsegment, but $ 2 $ does not.
- $ \operatorname{MEX} $ of the second subsegment $ [1, 0] $ is $ 2 $ , as $ 0 $ and $ 1 $ belong to the subsegment, but $ 2 $ does not.
- $ \operatorname{MEX} $ of the third subsegment $ [1, 0, 3] $ is $ 2 $ , as $ 0 $ and $ 1 $ belong to the subsegment, but $ 2 $ does not.

## 样例 #1

### 输入

```
5
2
0 0
5
0 1 2 3 4
8
0 1 7 1 0 1 0 3
3
2 2 2
4
0 1 2 0
```

### 输出

```
2
1 1
2 2
-1
3
1 3
4 5
6 8
3
1 1
2 2
3 3
-1
```



---

---
title: "Square"
layout: "post"
diff: 普及-
pid: CF194B
tag: []
---

# Square

## 题目描述

一张纸上画着一个正方形，正方形的边等于 $n$ 米。约翰·多伊在广场周围画十字。约翰在广场左下角画第一个十字。然后约翰沿着正方形的周长按顺时针方向移动（先向上，然后向右，然后向下，然后向左，依此类推）。每次他走 $n+1$ 米时，他都会画一个十字（详见图片）。

只有当广场左下角有两个十字时，他才会停下来。约翰将画几个十字？

图中显示了约翰为一个 $4$ 边的正方形画十字的顺序。左下角有两个十字架。约翰画了 $17$ 个十字架。

## 输入格式

第一行一个整数 $t$，表示测试数据的组数。、

第二行包含 $t$ 个以空格间隔的整数，分别为 $n_1,n_2,n_3\ldots n_t$，分别表示 $t$ 个正方形的边长。

## 输出格式

对于每一组数据，在一行上输出答案，也就是说，当约翰沿着相应大小的正方形移动时，输出他将画出十字的数目。请按输入中给出数据的顺序输出对应的的答案。

## 说明/提示

对于所有数据，$1\leq t \leq 10^4$，$1 \leq n_i \leq 10^9$。
请不要使用 `%lld` 来读取或输出 C++ 中的64位整数，最好使用`cin`、`cout`或者`%I64d` 说明符。

Translated by Maxwang.

## 样例 #1

### 输入

```
3
4 8 100

```

### 输出

```
17
33
401

```



---

---
title: "Battle Cows"
layout: "post"
diff: 普及-
pid: CF1951B
tag: []
---

# Battle Cows

## 题目描述

有 $ n $ 头奶牛参加编程比赛。奶牛 $ i $ 的 Cowdeforces 评级为 $ a_i $（奶牛们的评级全部不同）。它们最初处于 $ i $ 的位置。比赛由 $ n-1 $ 个比赛组成，规则如下所示：

- 第一场比赛是在位置 $ 1 $ 的奶牛和位置 $ 2 $ 的奶牛之间。
- 随后，每场比赛 $ i $ 在位置 $ i+1 $ 的奶牛和比赛 $ i-1 $ 的获胜者之间。
- 在每场比赛中，Cowdeforces 评级较高的奶牛获胜并进入下一场比赛。

你是奶牛 $ k $ 的主人。对你来说，赢得比赛并不重要。你希望你的奶牛在尽可能多的比赛中获胜。作为比赛组织者的熟人，你可以要求他们将你的奶牛与另一头奶牛交换一次位置，或者什么都不做。请问你的奶牛最多胜利几场？

## 输入格式

**每个测试点都包含多组数据**。第一行为数据组数 $ t $ （ $ 1 \le t \le 10^4 $ ）。
每组数据的第一行包含两个整数 $ n $ 和 $ k $ 表示奶牛的数量和你的奶牛的位置（ $ 2 \le n \le 10^5， 1 \le k \le n $ ）。
第二行包含 $ n $ 个整数 $ a_1，a_2，\ldots，a_n $ 表示奶牛的 Cowdeforces 评级（ $ 1 \le a_i \le 10^9 $ ）。保证 $ a_i $ 与 $ a_{i+1} $ 不同。

保证所有数据的 $ n $ 之和不超过 $ 10^5 $ 。

## 输出格式

对于每组数据，输出一个整数，表示奶牛 $ k $ 可以达到的最多胜利次数。

## 说明/提示

在第一组数据中，应该什么都不做。设 $ a' $ 是原始顺序中奶牛的 Cowdeforces 评级（你的奶牛评级会加粗）。

- 最初，$ a' = [\mathbf{12}， 10， 14， 11， 8， 3] $ 。
- 你的奶牛与 Cowdeforces 评级为 $ 10 $ 的奶牛对战并获胜。现在 $ a' = [\mathbf{12}， 14， 11， 8， 3] $ 。
- 你的奶牛与 Cowdeforces 评级为 $14$ 的奶牛对战，输掉了比赛。

你的奶牛赢得了 $ 1 $ 场比赛。在第二组数据中，应该将奶牛交换到位置 $ 3 $ 。然后，设 $ a' $ 是交换后顺序中奶牛的 Cowdeforces 评级。

- 最初，$ a' = [7， 2， \mathbf{12}， 10， 727， 13] $ .
- Cowdeforces 评级为 $ 7 $ 的奶牛与Cowdeforces评级为 $ 2 $ 的奶牛对战并获胜。现在 $ a' = [7， \mathbf{12}， 10， 727， 13] $ .
- Cowdeforces 评级为 $ 7 $ 的奶牛与你的奶牛对战，你的奶牛获胜。$ a' = [\mathbf{12}， 10， 727， 13] $ .
- 你的奶牛与 Cowdeforces 评级为 $ 10 $ 的奶牛对战并获胜。现在 $ a' = [\mathbf{12}， 727， 13] $ .
- 你的奶牛与 Cowdeforces 评级为 $727$ 的奶牛对战，输掉了比赛。

你的奶牛赢得了 $ 2 $ 场比赛。

## 样例 #1

### 输入

```
3
6 1
12 10 14 11 8 3
6 5
7 2 727 10 12 13
2 2
1000000000 1
```

### 输出

```
1
2
0
```



---

---
title: "Let's Watch Football"
layout: "post"
diff: 普及-
pid: CF195A
tag: []
---

# Let's Watch Football

## 题目描述

Valeric和Valerko错过了最后一场欧洲杯足球赛，所以他们决定在网上观看比赛的关键时刻。他们想尽快开始观看，但连接速度太低。如果他们现在打开视频，它将“挂断”，因为每秒观看的数据大小将超过每秒下载的数据大小。

这些家伙想要在没有任何停顿的情况下观看整个视频，所以他们必须等待一些整数秒的时间才能下载视频的一部分。在这几秒钟过去之后，他们就可以开始观看了。等待整个视频下载是不必要的，因为视频可以下载后，他们才开始观看。

假设视频的长度是c，秒Valeric和Valerko在观看前等待了几秒钟。那么在任时刻t≤t0≤c+t则必须满足以下条件:以秒为单位接收的数据的大小不小于观看视频的-t秒所需的数据的大小。

当然，这些人希望等待的时间越短越好，所以你的任务是找到在打开视频之前等待的最小整数秒数。伙计们必须不停地看视频

## 输入格式

第一行包含三个空格分隔的整数a，带(1<=a,b,c<=1000a>b)。第一个数字(a)表示观看视频一秒钟所需的数据量。第二个数字(b)表示Valeric和Valerko每秒可以从网上下载的数据大小。第三个数字(c) 表示视频的长度(秒)。

## 说明/提示

第一个样本视频的长度为1秒，观看1秒需要4个数据单位，所以人们需要下载4，1=4单位的数据来观看整个视频。最理想的方式是等待3秒，直到3单位的数提将被下载，然后开始观看。当人们将观看1秒的视频时，一个数据单位将被下载而Valerik和Valerko将在观看结束时有4个数据单位。而且，在视频结束之前的每一刻，男人们都会有更多的数据，然后才是观看视频所必需的。

在第二个样本中，人们需要2.10=20个单位的数据，所以他们必须等待5秒，之后他们将在第二秒结束前获得20个单位的数据。然而，如果男人等待4秒，他们将能够观看视频的第一秒没有暂停，但他们将下载18个单位的数据由第二秒结束，它是那么不必要

## 样例 #1

### 输入

```
4 1 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
10 3 2

```

### 输出

```
5

```

## 样例 #3

### 输入

```
13 12 1

```

### 输出

```
1

```



---

---
title: "Lexicographically Maximum Subsequence"
layout: "post"
diff: 普及-
pid: CF196A
tag: []
---

# Lexicographically Maximum Subsequence

## 题目描述

你现在有一个只包含小写英文字母的字符串，要求求它的最大字典序子序列。

我们把一个非空字符串s[p_{1}p_{2}...\ p_{k}]=s_{p1}s_{p2}...\ s_{pk}(1<=p_{1}<p_{2}<...<p_{k}<=|s|)叫做字符串s=s1s2…s|s|的一个子序列。

如果|x|>|y|而且x1=y1,x2=y2…X|y|=Y|y|或者存在一个数字r (r<|x|,r<|y|)满足x1=y1,x2=y2…X|y|=Y|y|并且x_{r+1}>y_{r+1}，那么字符串x=x1x2…x|x|在字典序上比字符串y=y1y2…y|y|大。在行中的字符根据他们的ASCII码进行比较

## 输入格式

只有一行，包括一个非空的只含小写字母的字符串s，字符串长度不超过10^5

## 输出格式

输出只有一行，输出字符串s的 最大字典序子序列

## 说明/提示

让我们看一下样例并看一看待求的子序列长什么样子(用大写粗体字母标注）

样例1:a**B**a**BBA**

样例2:abb**C**b**CC**a**C**bb**CB**aa**BA**

## 样例 #1

### 输入

```
ababba

```

### 输出

```
bbba

```

## 样例 #2

### 输入

```
abbcbccacbbcbaaba

```

### 输出

```
cccccbba

```



---

---
title: "Submission Bait"
layout: "post"
diff: 普及-
pid: CF1990A
tag: []
---

# Submission Bait

## 题目描述

Alice and Bob are playing a game in an array $ a $ of size $ n $ .

They take turns to do operations, with Alice starting first. The player who can not operate will lose. At first, a variable $ mx $ is set to $ 0 $ .

In one operation, a player can do:

- Choose an index $ i $ ( $ 1 \le i \le n $ ) such that $ a_{i} \geq mx $ and set $ mx $ to $ a_{i} $ . Then, set $ a_{i} $ to $ 0 $ .

Determine whether Alice has a winning strategy.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^3 $ ) — the number of test cases.

For each test case:

- The first line contains an integer $ n $ ( $ 2 \leq n \leq 50 $ ) — the size of the array.
- The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq n $ ) — the elements of the array.

## 输出格式

For each test case, if Alice has a winning strategy, output "YES". Otherwise, output "NO".

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 说明/提示

In the first test case, Alice can choose $ i=1 $ since $ a_1=2 \ge mx=0 $ .

After Alice's operation, $ a=[0,1] $ and $ mx=2 $ . Bob can not do any operation. Alice wins.

In the second test case, Alice doesn't have a winning strategy.

For example, if Alice chooses $ i=1 $ , after Alice's operation: $ a=[0,1] $ and $ mx=1 $ . Then, Bob can choose $ i=2 $ since $ a_2=1 \ge mx=1 $ . After Bob's operation: $ a=[0,0] $ and $ mx=1 $ . Alice can not do any operation. Bob wins.

## 样例 #1

### 输入

```
5
2
2 1
2
1 1
3
3 3 3
4
3 3 4 4
4
1 2 2 2
```

### 输出

```
YES
NO
YES
NO
YES
```



---

---
title: "Array Craft"
layout: "post"
diff: 普及-
pid: CF1990B
tag: []
---

# Array Craft

## 题目描述

For an array $ b $ of size $ m $ , we define:

- the maximum prefix position of $ b $ is the smallest index $ i $ that satisfies $ b_1+\ldots+b_i=\max_{j=1}^{m}(b_1+\ldots+b_j) $ ;
- the maximum suffix position of $ b $ is the largest index $ i $ that satisfies $ b_i+\ldots+b_m=\max_{j=1}^{m}(b_j+\ldots+b_m) $ .

You are given three integers $ n $ , $ x $ , and $ y $ ( $ x > y $ ). Construct an array $ a $ of size $ n $ satisfying:

- $ a_i $ is either $ 1 $ or $ -1 $ for all $ 1 \le i \le n $ ;
- the maximum prefix position of $ a $ is $ x $ ;
- the maximum suffix position of $ a $ is $ y $ .

If there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

For each test case:

- The only line contains three integers $ n $ , $ x $ , and $ y $ ( $ 2 \leq n \leq 10^5, 1 \le y \lt x \le n) $ .

It is guaranteed that the sum of $ n $ over all test cases will not exceed $ 10^5 $ .

## 输出格式

For each test case, output $ n $ space-separated integers $ a_1, a_2, \ldots, a_n $ in a new line.

## 说明/提示

In the second test case,

- $ i=x=4 $ is the smallest index that satisfies $ a_1+\ldots +a_i=\max_{j=1}^{n}(a_1+\ldots+a_j)=2 $ ;
- $ i=y=3 $ is the greatest index that satisfies $ a_i+\ldots +a_n=\max_{j=1}^{n}(a_j+\ldots+a_n)=2 $ .

Thus, the array $ a=[1,-1,1,1] $ is considered correct.

## 样例 #1

### 输入

```
3
2 2 1
4 4 3
6 5 1
```

### 输出

```
1 1
1 -1 1 1
1 1 -1 1 1 -1
```



---

---
title: "Drinks"
layout: "post"
diff: 普及-
pid: CF200B
tag: []
---

# Drinks

## 题目描述

Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are $ n $ drinks in his fridge, the volume fraction of orange juice in the $ i $ -th drink equals $ p_{i} $ percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the $ n $ drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.

## 输入格式

The first input line contains a single integer $ n $ ( $ 1<=n<=100 $ ) — the number of orange-containing drinks in Vasya's fridge. The second line contains $ n $ integers $ p_{i} $ ( $ 0<=p_{i}<=100 $ ) — the volume fraction of orange juice in the $ i $ -th drink, in percent. The numbers are separated by a space.

## 输出格式

Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed $ 10^{-4} $ .

## 说明/提示

Note to the first sample: let's assume that Vasya takes $ x $ milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF200B/7c2a6a8bbcdbfef1f9a32c2eb1f7549c3c17c619.png) milliliters. The total cocktail's volume equals $ 3·x $ milliliters, so the volume fraction of the juice in the cocktail equals ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF200B/cc3d21395b67607dff0b7baa3b0b870221e3352d.png), that is, $ 66.(6) $ percent.

## 样例 #1

### 输入

```
3
50 50 100

```

### 输出

```
66.666666666667

```

## 样例 #2

### 输入

```
4
0 25 50 75

```

### 输出

```
37.500000000000

```



---

---
title: "Clear Symmetry"
layout: "post"
diff: 普及-
pid: CF201A
tag: []
---

# Clear Symmetry

## 题目描述

Consider some square matrix $ A $ with side $ n $ consisting of zeros and ones. There are $ n $ rows numbered from $ 1 $ to $ n $ from top to bottom and $ n $ columns numbered from $ 1 $ to $ n $ from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the $ i $ -row and the $ j $ -th column as $ A_{i,j} $ .

Let's call matrix $ A $ clear if no two cells containing ones have a common side.

Let's call matrix $ A $ symmetrical if it matches the matrices formed from it by a horizontal and/or a vertical reflection. Formally, for each pair $ (i,j) $ $ (1<=i,j<=n) $ both of the following conditions must be met: $ A_{i,j}=A_{n-i+1,j} $ and $ A_{i,j}=A_{i,n-j+1} $ .

Let's define the sharpness of matrix $ A $ as the number of ones in it.

Given integer $ x $ , your task is to find the smallest positive integer $ n $ such that there exists a clear symmetrical matrix $ A $ with side $ n $ and sharpness $ x $ .

## 输入格式

The only line contains a single integer $ x $ ( $ 1<=x<=100 $ ) — the required sharpness of the matrix.

## 输出格式

Print a single number — the sought value of $ n $ .

## 说明/提示

The figure below shows the matrices that correspond to the samples:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF201A/4a353f15397909088e2fcb0cff23c93ecb30c822.png)

## 样例 #1

### 输入

```
4

```

### 输出

```
3

```

## 样例 #2

### 输入

```
9

```

### 输出

```
5

```



---

---
title: "Startup"
layout: "post"
diff: 普及-
pid: CF2036B
tag: []
---

# Startup

## 题目描述

Arseniy came up with another business plan — to sell soda from a vending machine! For this, he purchased a machine with $ n $ shelves, as well as $ k $ bottles, where the $ i $ -th bottle is characterized by the brand index $ b_i $ and the cost $ c_i $ .

You can place any number of bottles on each shelf, but all bottles on the same shelf must be of the same brand.

Arseniy knows that all the bottles he puts on the shelves of the machine will be sold. Therefore, he asked you to calculate the maximum amount he can earn.

## 输入格式

The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le n, k \le 2 \cdot 10^5 $ ), where $ n $ is the number of shelves in the machine, and $ k $ is the number of bottles available to Arseniy.

The next $ k $ lines contain two integers $ b_i $ and $ c_i $ ( $ 1 \le b_i \le k, 1 \le c_i \le 1000 $ ) — the brand and cost of the $ i $ -th bottle.

It is also guaranteed that the sum of $ n $ across all test cases does not exceed $ 2 \cdot 10^5 $ and that the sum of $ k $ across all test cases also does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output one integer — the maximum amount that Arseniy can earn.

## 说明/提示

In the first test case, Arseniy has $ 3 $ shelves in the vending machine. He can place, for example, two bottles of the brand $ 2 $ on the first shelf and a bottle of the brand $ 1 $ on the second shelf. Then the total cost of the bottles would be $ 6 + 7 + 15 = 28 $ .

In the second test case, he has only one shelf. It is not difficult to show that the optimal option is to place a bottle of the brand $ 1 $ on it. Then the total cost will be $ 15 $ .

In the third test case, he has as many as $ 6 $ shelves, so he can place all available bottles with a total cost of $ 7 + 5 = 12 $ .

## 样例 #1

### 输入

```
4
3 3
2 6
2 7
1 15
1 3
2 6
2 7
1 15
6 2
1 7
2 5
190000 1
1 1000
```

### 输出

```
28
15
12
1000
```



---

---
title: "Preparing for the Exam"
layout: "post"
diff: 普及-
pid: CF2051C
tag: ['分类讨论']
---

# Preparing for the Exam

## 题目描述

Monocarp 正在为他的第一场大学考试做准备。这场考试可能会涉及到 $n$ 个不同的问题，编号从 $1$ 到 $n$。一共有 $m$ 个不同的问题列表，每个列表包含正好 $n-1$ 个不同的问题。对于每个列表 $i$，用一个整数 $a_i$ 指定唯一没有出现在第 $i$ 个列表中的问题。例如，当 $n = 4$ 且 $a_i = 3$ 时，第 $i$ 个列表里有问题 $[1, 2, 4]$。

在考试的时候，Monocarp 将会拿到其中的一个问题列表，然后老师会要求他回答列表中所有的问题。要通过考试，Monocarp 必须回答列表中所有问题。

Monocarp 已经掌握了 $k$ 个问题的答案，这些问题编号是 $q_1, q_2, \dots, q_k$。请判断对于每一个问题列表，Monocarp 是否能够通过考试。

## 输入格式

第一行输入一个整数 $t$，表示测试用例的数量（$1 \le t \le 10^4$）。

每个测试用例包含以下三行：

- 第一行给出三个整数 $n$、$m$ 和 $k$（$2 \le n \le 3 \times 10^5$；$1 \le m, k \le n$）；
- 第二行包含 $m$ 个不同的整数 $a_1, a_2, \dots, a_m$（$1 \le a_i \le n$；$a_i < a_{i+1}$）；
- 第三行包含 $k$ 个不同的整数 $q_1, q_2, \dots, q_k$（$1 \le q_i \le n$；$q_i < q_{i+1}$）。

注意：所有测试用例中 $n$ 的总和不超过 $3 \times 10^5$。

## 输出格式

对于每个测试用例，输出一个长度为 $m$ 的由 '1' 和 '0' 组成的字符串。如果 Monocarp 能通过这个问题列表，则对应位置输出 '1'，否则输出 '0'。

## 说明/提示

在第一个测试用例中，Monocarp 已掌握的问题是 $[1, 3, 4]$。我们来看所有的问题列表：

- 第一个列表的问题是 $[2, 3, 4]$。Monocarp 不懂第 $2$ 个问题，所以不能通过；
- 第二个列表的问题是 $[1, 3, 4]$。Monocarp 知道这些问题，因此能通过；
- 第三个列表的问题是 $[1, 2, 4]$。Monocarp 不懂第 $2$ 个问题，所以不能通过；
- 第四个列表的问题是 $[1, 2, 3]$。Monocarp 不懂第 $2$ 个问题，所以不能通过。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
4 4 3
1 2 3 4
1 3 4
5 4 3
1 2 3 4
1 3 4
4 4 4
1 2 3 4
1 2 3 4
2 2 1
1 2
2
```

### 输出

```
0100
0000
1111
10
```



---

---
title: "Little Elephant and Sorting"
layout: "post"
diff: 普及-
pid: CF205B
tag: []
---

# Little Elephant and Sorting

## 题目描述

The Little Elephant loves sortings.

He has an array $ a $ consisting of $ n $ integers. Let's number the array elements from 1 to $ n $ , then the $ i $ -th element will be denoted as $ a_{i} $ . The Little Elephant can make one move to choose an arbitrary pair of integers $ l $ and $ r $ $ (1<=l<=r<=n) $ and increase $ a_{i} $ by $ 1 $ for all $ i $ such that $ l<=i<=r $ .

Help the Little Elephant find the minimum number of moves he needs to convert array $ a $ to an arbitrary array sorted in the non-decreasing order. Array $ a $ , consisting of $ n $ elements, is sorted in the non-decreasing order if for any $ i $ $ (1<=i&lt;n) $ $ a_{i}<=a_{i+1} $ holds.

## 输入格式

The first line contains a single integer $ n $ $ (1<=n<=10^{5}) $ — the size of array $ a $ . The next line contains $ n $ integers, separated by single spaces — array $ a $ $ (1<=a_{i}<=10^{9}) $ . The array elements are listed in the line in the order of their index's increasing.

## 输出格式

In a single line print a single integer — the answer to the problem.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.

## 说明/提示

In the first sample the array is already sorted in the non-decreasing order, so the answer is $ 0 $ .

In the second sample you need to perform two operations: first increase numbers from second to third (after that the array will be: \[3, 3, 2\]), and second increase only the last element (the array will be: \[3, 3, 3\]).

In the third sample you should make at least 6 steps. The possible sequence of the operations is: (2; 3), (2; 3), (2; 3), (3; 3), (3; 3), (3; 3). After that the array converts to \[7, 7, 7, 47\].

## 样例 #1

### 输入

```
3
1 2 3

```

### 输出

```
0

```

## 样例 #2

### 输入

```
3
3 2 1

```

### 输出

```
2

```

## 样例 #3

### 输入

```
4
7 4 1 47

```

### 输出

```
6

```



---

---
title: "Clockwork"
layout: "post"
diff: 普及-
pid: CF2062B
tag: []
---

# Clockwork

## 题目描述

You have a sequence of $ n $ time clocks arranged in a line, where the initial time on the $ i $ -th clock is $ a_i $ . In each second, the following happens in order:

- Each clock's time decreases by $ 1 $ . If any clock's time reaches $ 0 $ , you lose immediately.
- You can choose to move to an adjacent clock or stay at the clock you are currently on.
- You can reset the time of the clock you are on back to its initial value $ a_i $ .

Note that the above events happen in order. If the time of a clock reaches $ 0 $ in a certain second, even if you can move to this clock and reset its time during that second, you will still lose.

You can start from any clock. Determine if it is possible to continue this process indefinitely without losing.

## 输入格式

The first line of input contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

For each test case, the first line contains a single integer $ n $ ( $ 2 \leq n \leq 5 \cdot 10^5 $ ) — the number of time clocks.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the initial times set on the clocks.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5\cdot 10^5 $ .

## 输出格式

For each test case, print "YES" (without quotes) if it is possible to continue this process indefinitely, or "NO" (without quotes) otherwise.

You can output "YES" and "NO" in any case (for example, strings "yEs", "yes" and "Yes" will be recognized as a positive response).

## 说明/提示

In the first test case, you can move back and forth between the two clocks, resetting them repeatedly.

In the third test case, assuming that you start from clock $ 1 $ and follow the strategy below:

Initially, $ a=[4,10,5] $ .

1. $ a $ becomes $ [3, 9, 4] $ . You move to clock $ 2 $ and reset its time, resulting in $ a=[3, 10, 4] $ .
2. $ a $ becomes $ [2, 9, 3] $ . You move to clock $ 3 $ and reset its time, resulting in $ a=[2, 9, 5] $ .
3. $ a $ becomes $ [1, 8, 4] $ . You move to clock $ 2 $ and reset its time, resulting in $ a=[1, 10, 4] $ .
4. $ a $ becomes $ [0, 9, 3] $ . You move to clock $ 1 $ , but you lose because $ a_1 $ reaches $ 0 $ .

It can be proven that no other strategy allows you to continue this process indefinitely.

## 样例 #1

### 输入

```
5
2
4 10
2
2 2
3
4 10 5
3
5 3 5
5
12 13 25 17 30
```

### 输出

```
YES
NO
NO
YES
YES
```



---

---
title: "Subsequence Update"
layout: "post"
diff: 普及-
pid: CF2063B
tag: []
---

# Subsequence Update

## 题目描述

After Little John borrowed expansion screws from auntie a few hundred times, eventually she decided to come and take back the unused ones.But as they are a crucial part of home design, Little John decides to hide some in the most unreachable places — under the eco-friendly wood veneers.

You are given an integer sequence $ a_1, a_2, \ldots, a_n $ , and a segment $ [l,r] $ ( $ 1 \le l \le r \le n $ ).

You must perform the following operation on the sequence exactly once.

- Choose any subsequence $ ^{\text{∗}} $ of the sequence $ a $ , and reverse it. Note that the subsequence does not have to be contiguous.

Formally, choose any number of indices $ i_1,i_2,\ldots,i_k $ such that $ 1 \le i_1 < i_2 < \ldots < i_k \le n $ . Then, change the $ i_x $ -th element to the original value of the $ i_{k-x+1} $ -th element simultaneously for all $ 1 \le x \le k $ .

Find the minimum value of $ a_l+a_{l+1}+\ldots+a_{r-1}+a_r $ after performing the operation.

 $ ^{\text{∗}} $ A sequence $ b $ is a subsequence of a sequence $ a $ if $ b $ can be obtained from $ a $ by the deletion of several (possibly, zero or all) element from arbitrary positions.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.

The first line of each test case contains three integers $ n $ , $ l $ , $ r $ ( $ 1 \le l \le r \le n \le 10^5 $ ) — the length of $ a $ , and the segment $ [l,r] $ .

The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1 \le a_{i} \le 10^9 $ ).

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output the minimum value of $ a_l+a_{l+1}+\ldots+a_{r-1}+a_r $ on a separate line.

## 说明/提示

On the second test case, the array is $ a=[1,2,3] $ and the segment is $ [2,3] $ .

After choosing the subsequence $ a_1,a_3 $ and reversing it, the sequence becomes $ [3,2,1] $ . Then, the sum $ a_2+a_3 $ becomes $ 3 $ . It can be shown that the minimum possible value of the sum is $ 3 $ .

## 样例 #1

### 输入

```
6
2 1 1
2 1
3 2 3
1 2 3
3 1 3
3 1 2
4 2 3
1 2 2 2
5 2 5
3 3 2 3 5
6 1 3
3 6 6 4 3 2
```

### 输出

```
1
3
6
3
11
8
```



---

---
title: "Variety is Discouraged"
layout: "post"
diff: 普及-
pid: CF2064B
tag: []
---

# Variety is Discouraged

## 题目描述

Define the score of an arbitrary array $ b $ to be the length of $ b $ minus the number of distinct elements in $ b $ . For example:

- The score of $ [1, 2, 2, 4] $ is $ 1 $ , as it has length $ 4 $ and only $ 3 $ distinct elements ( $ 1 $ , $ 2 $ , $ 4 $ ).
- The score of $ [1, 1, 1] $ is $ 2 $ , as it has length $ 3 $ and only $ 1 $ distinct element ( $ 1 $ ).
- The empty array has a score of $ 0 $ .

You have an array $ a $ . You need to remove some non-empty contiguous subarray from $ a $ at most once.

More formally, you can do the following at most once:

- pick two integers $ l $ , $ r $ where $ 1 \le l \le r \le n $ , and
- delete the contiguous subarray $ [a_l,\ldots,a_r] $ from $ a $ (that is, replace $ a $ with $ [a_1,\ldots,a_{l - 1},a_{r + 1},\ldots,a_n] $ ).

Output an operation such that the score of $ a $ is maximum; if there are multiple answers, output one that minimises the final length of $ a $ after the operation. If there are still multiple answers, you may output any of them.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains an integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the length of the array $ a $ .

The second line of each testcase contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1 \le a_i \le n $ ).

The sum of $ n $ across all testcases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each testcase, if you wish to not make a move, output $ 0 $ .

Otherwise, output two integers $ l $ and $ r $ ( $ 1 \le l \le r \le n $ ), representing the left and right bound of the removed subarray.

The removed subarray should be chosen such that the score is maximized, and over all such answers choose any of them that minimises the final length of the array.

## 说明/提示

In the first testcase, we have two options:

- do nothing: the score of $ [1] $ is $ 1-1=0 $ .
- remove the subarray with $ l=1 $ , $ r=1 $ : we remove the only element, and we get an empty array with score $ 0 $ .

 Therefore, the maximum score possible is $ 0 $ . However, since we need to additionally minimise the final length of the array, we must output the second option with $ l=r=1 $ . Note that the first option of doing nothing is incorrect, since it has a longer final length.In the second testcase, no subarray is selected, so after which $ a $ is still $ [1, 1, 1, 1, 1] $ . This has length $ 5 $ and $ 1 $ distinct element, so it has a score of $ 5 - 1 = 4 $ . This can be proven to be a shortest array which maximises the score.

In the third testcase, the subarray selected is $ [2, \color{red}1, \color{red}3, 2] $ , after which $ a $ becomes $ [2, 2] $ . This has length $ 2 $ and $ 1 $ distinct element, so it has a score of $ 2 - 1 = 1 $ . This can be proven to be a shortest array which maximises the score.

## 样例 #1

### 输入

```
3
1
1
5
1 1 1 1 1
4
2 1 3 2
```

### 输出

```
1 1
0
2 3
```



---

---
title: "Remove the Ends"
layout: "post"
diff: 普及-
pid: CF2064C
tag: []
---

# Remove the Ends

## 题目描述

You have an array $ a $ of length $ n $ consisting of non-zero integers. Initially, you have $ 0 $ coins, and you will do the following until $ a $ is empty:

- Let $ m $ be the current size of $ a $ . Select an integer $ i $ where $ 1 \le i \le m $ , gain $ |a_i| $ $ ^{\text{∗}} $ coins, and then: 
  - if $ a_i < 0 $ , then replace $ a $ with $ [a_1,a_2,\ldots,a_{i - 1}] $ (that is, delete the suffix beginning with $ a_i $ );
  - otherwise, replace $ a $ with $ [a_{i + 1},a_{i + 2},\ldots,a_m] $ (that is, delete the prefix ending with $ a_i $ ).

Find the maximum number of coins you can have at the end of the process.

 $ ^{\text{∗}} $ Here $ |a_i| $ represents the absolute value of $ a_i $ : it equals $ a_i $ when $ a_i > 0 $ and $ -a_i $ when $ a_i < 0 $ .

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains an integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the length of $ a $ .

The second line of each testcase contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ -10^9 \le a_i \le 10^9 $ , $ a_i \ne 0 $ ).

The sum of $ n $ across all testcases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output the maximum number of coins you can have at the end of the process.

## 说明/提示

An example of how to get $ 23 $ coins in the first testcase is as follows:

- $ a = [3, 1, 4, -1, -5, \color{red}{-9}] \xrightarrow{i = 6} a = [3, 1, 4, -1, -5]  $ , and get $ 9 $ coins.
- $ a = [\color{red}{3}, 1, 4, -1, -5] \xrightarrow{i = 1} a = [1, 4, -1, -5]  $ , and get $ 3 $ coins.
- $ a = [\color{red}{1}, 4, -1, -5] \xrightarrow{i = 1} a = [4, -1, -5]  $ , and get $ 1 $ coin.
- $ a = [4, -1, \color{red}{-5}] \xrightarrow{i = 3} a = [4, -1]  $ , and get $ 5 $ coins.
- $ a = [4, \color{red}{-1}] \xrightarrow{i = 2} a = [4]  $ , and get $ 1 $ coin.
- $ a = [\color{red}{4}] \xrightarrow{i = 1} a = []  $ , and get $ 4 $ coins.

 After all the operations, you have $ 23 $ coins.An example of how to get $ 40 $ coins in the second testcase is as follows:

- $ a = [-10, -3, -17, \color{red}{1}, 19, 20] \xrightarrow{i = 4} a = [19, 20]  $ , and get $ 1 $ coin.
- $ a = [\color{red}{19}, 20] \xrightarrow{i = 1} a = [20]  $ , and get $ 19 $ coins.
- $ a = [\color{red}{20}] \xrightarrow{i = 1} a = []  $ , and get $ 20 $ coins.

 After all the operations, you have $ 40 $ coins.

## 样例 #1

### 输入

```
3
6
3 1 4 -1 -5 -9
6
-10 -3 -17 1 19 20
1
1
```

### 输出

```
23
40
1
```



---

---
title: "Equation"
layout: "post"
diff: 普及-
pid: CF20B
tag: []
---

# Equation

## 题目描述

### 题目大意

给定 $A, B, C$，求方程 $Ax^2+Bx+C=0$ 的解的个数，如果有无穷个解，则输出 `-1`。

## 输入格式

第一行：三个整数表示上式的 $A, B, C$。

## 输出格式

第一行：一个整数，表示解的个数，如果有无数个解，请输出 `-1`。

接下来若干行：每行一个解，请按大小顺序输出。

## 样例 #1

### 输入

```
1 -5 6

```

### 输出

```
2
2.0000000000
3.0000000000
```



---

---
title: "Bicycle Chain"
layout: "post"
diff: 普及-
pid: CF215A
tag: []
---

# Bicycle Chain

## 题目描述

Vasya's bicycle chain drive consists of two parts: $ n $ stars are attached to the pedal axle, $ m $ stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.

We know that the $ i $ -th star on the pedal axle has $ a_{i} $ $ (0&lt;a_{1}&lt;a_{2}&lt;...&lt;a_{n}) $ teeth, and the $ j $ -th star on the rear wheel axle has $ b_{j} $ $ (0&lt;b_{1}&lt;b_{2}&lt;...&lt;b_{m}) $ teeth. Any pair $ (i,j) $ $ (1<=i<=n $ ; $ 1<=j<=m) $ is called a gear and sets the indexes of stars to which the chain is currently attached. Gear $ (i,j) $ has a gear ratio, equal to the value ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF215A/552855b6cae5503b6d59fc360af0683e021f4625.png).

Since Vasya likes integers, he wants to find such gears $ (i,j) $ , that their ratios are integers. On the other hand, Vasya likes fast driving, so among all "integer" gears $ (i,j) $ he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.

In the problem, fraction ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF215A/552855b6cae5503b6d59fc360af0683e021f4625.png) denotes division in real numbers, that is, no rounding is performed.

## 输入格式

The first input line contains integer $ n $ $ (1<=n<=50) $ — the number of stars on the bicycle's pedal axle. The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=10^{4}) $ in the order of strict increasing.

The third input line contains integer $ m $ $ (1<=m<=50) $ — the number of stars on the rear wheel axle. The fourth line contains $ m $ integers $ b_{1},b_{2},...,b_{m} $ $ (1<=b_{i}<=10^{4}) $ in the order of strict increasing.

It is guaranteed that there exists at least one gear ( $ i,j $ ), that its gear ratio is an integer. The numbers on the lines are separated by spaces.

## 输出格式

Print the number of "integer" gears with the maximum ratio among all "integer" gears.

## 说明/提示

In the first sample the maximum "integer" gear ratio equals 3. There are two gears that have such gear ratio. For one of them $ a_{1}=4,b_{1}=12 $ , and for the other $ a_{2}=5,b_{3}=15 $ .

## 样例 #1

### 输入

```
2
4 5
3
12 13 15

```

### 输出

```
2

```

## 样例 #2

### 输入

```
4
1 2 3 4
5
10 11 12 13 14

```

### 输出

```
1

```



---

---
title: "Tiling with Hexagons"
layout: "post"
diff: 普及-
pid: CF216A
tag: []
---

# Tiling with Hexagons

## 题目描述

Several ages ago Berland was a kingdom. The King of Berland adored math. That's why, when he first visited one of his many palaces, he first of all paid attention to the floor in one hall. The floor was tiled with hexagonal tiles.

The hall also turned out hexagonal in its shape. The King walked along the perimeter of the hall and concluded that each of the six sides has $ a $ , $ b $ , $ c $ , $ a $ , $ b $ and $ c $ adjacent tiles, correspondingly.

To better visualize the situation, look at the picture showing a similar hexagon for $ a=2 $ , $ b=3 $ and $ c=4 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF216A/3f981143d696c9bb68234ae6ba7b4116d86bd7a4.png)According to the legend, as the King of Berland obtained the values $ a $ , $ b $ and $ c $ , he almost immediately calculated the total number of tiles on the hall floor. Can you do the same?

## 输入格式

The first line contains three integers: $ a $ , $ b $ and $ c $ ( $ 2<=a,b,c<=1000 $ ).

## 输出格式

Print a single number — the total number of tiles on the hall floor.

## 样例 #1

### 输入

```
2 3 4

```

### 输出

```
18
```



---

---
title: "Mountain Scenery"
layout: "post"
diff: 普及-
pid: CF218A
tag: []
---

# Mountain Scenery

## 题目描述

Little Bolek has found a picture with $ n $ mountain peaks painted on it. The $ n $ painted peaks are represented by a non-closed polyline, consisting of $ 2n $ segments. The segments go through $ 2n+1 $ points with coordinates $ (1,y_{1}) $ , $ (2,y_{2}) $ , $ ... $ , $ (2n+1,y_{2n+1}) $ , with the $ i $ -th segment connecting the point $ (i,y_{i}) $ and the point $ (i+1,y_{i+1}) $ . For any even $ i $ $ (2<=i<=2n) $ the following condition holds: $ y_{i-1}&lt;y_{i} $ and $ y_{i}&gt;y_{i+1} $ .

We shall call a vertex of a polyline with an even $ x $ coordinate a mountain peak.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF218A/96f9e39adc23f097d41530b53dba00529f48c7bd.png) The figure to the left shows the initial picture, the figure to the right shows what the picture looks like after Bolek's actions. The affected peaks are marked red, $ k $ = 2. Bolek fancied a little mischief. He chose exactly $ k $ mountain peaks, rubbed out the segments that went through those peaks and increased each peak's height by one (that is, he increased the $ y $ coordinate of the corresponding points). Then he painted the missing segments to get a new picture of mountain peaks. Let us denote the points through which the new polyline passes on Bolek's new picture as $ (1,r_{1}) $ , $ (2,r_{2}) $ , $ ... $ , $ (2n+1,r_{2n+1}) $ .

Given Bolek's final picture, restore the initial one.

## 输入格式

The first line contains two space-separated integers $ n $ and $ k $ $ (1<=k<=n<=100) $ . The next line contains $ 2n+1 $ space-separated integers $ r_{1},r_{2},...,r_{2n+1} $ $ (0<=r_{i}<=100) $ — the $ y $ coordinates of the polyline vertices on Bolek's picture.

It is guaranteed that we can obtain the given picture after performing the described actions on some picture of mountain peaks.

## 输出格式

Print $ 2n+1 $ integers $ y_{1},y_{2},...,y_{2n+1} $ — the $ y $ coordinates of the vertices of the polyline on the initial picture. If there are multiple answers, output any one of them.

## 样例 #1

### 输入

```
3 2
0 5 3 5 1 5 2

```

### 输出

```
0 5 3 4 1 4 2 

```

## 样例 #2

### 输入

```
1 1
0 2 0

```

### 输出

```
0 1 0 

```



---

---
title: "Airport"
layout: "post"
diff: 普及-
pid: CF218B
tag: []
---

# Airport

## 题目描述

Lolek and Bolek are about to travel abroad by plane. The local airport has a special "Choose Your Plane" offer. The offer's conditions are as follows:

- it is up to a passenger to choose a plane to fly on;
- if the chosen plane has $ x $ $ (x&gt;0) $ empty seats at the given moment, then the ticket for such a plane costs $ x $ zlotys (units of Polish currency).

The only ticket office of the airport already has a queue of $ n $ passengers in front of it. Lolek and Bolek have not stood in the queue yet, but they are already wondering what is the maximum and the minimum number of zlotys the airport administration can earn if all $ n $ passengers buy tickets according to the conditions of this offer?

The passengers buy tickets in turn, the first person in the queue goes first, then goes the second one, and so on up to $ n $ -th person.

## 输入格式

The first line contains two integers $ n $ and $ m $ $ (1<=n,m<=1000) $ — the number of passengers in the queue and the number of planes in the airport, correspondingly. The next line contains $ m $ integers $ a_{1},a_{2},...,a_{m} $ $ (1<=a_{i}<=1000) $ — $ a_{i} $ stands for the number of empty seats in the $ i $ -th plane before the ticket office starts selling tickets.

The numbers in the lines are separated by a space. It is guaranteed that there are at least $ n $ empty seats in total.

## 输出格式

Print two integers — the maximum and the minimum number of zlotys that the airport administration can earn, correspondingly.

## 说明/提示

In the first test sample the number of passengers is equal to the number of empty seats, so regardless of the way the planes are chosen, the administration will earn the same sum.

In the second sample the sum is maximized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 2-nd plane, the 3-rd person — to the 3-rd plane, the 4-th person — to the 1-st plane. The sum is minimized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 1-st plane, the 3-rd person — to the 2-nd plane, the 4-th person — to the 2-nd plane.

## 样例 #1

### 输入

```
4 3
2 1 1

```

### 输出

```
5 5

```

## 样例 #2

### 输入

```
4 3
2 2 2

```

### 输出

```
7 6

```



---

---
title: "Special Offer! Super Price 999 Bourles!"
layout: "post"
diff: 普及-
pid: CF219B
tag: []
---

# Special Offer! Super Price 999 Bourles!

## 题目描述

Polycarpus is an amateur businessman. Recently he was surprised to find out that the market for paper scissors is completely free! Without further ado, Polycarpus decided to start producing and selling such scissors.

Polycaprus calculated that the optimal celling price for such scissors would be $ p $ bourles. However, he read somewhere that customers are attracted by prices that say something like "Special Offer! Super price 999 bourles!". So Polycarpus decided to lower the price a little if it leads to the desired effect.

Polycarpus agrees to lower the price by no more than $ d $ bourles so that the number of nines at the end of the resulting price is maximum. If there are several ways to do it, he chooses the maximum possible price.

Note, Polycarpus counts only the trailing nines in a price.

## 输入格式

The first line contains two integers $ p $ and $ d $ ( $ 1<=p<=10^{18} $ ; $ 0<=d&lt;p $ ) — the initial price of scissors and the maximum possible price reduction.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.

## 输出格式

Print the required price — the maximum price that ends with the largest number of nines and that is less than $ p $ by no more than $ d $ .

The required number shouldn't have leading zeroes.

## 样例 #1

### 输入

```
1029 102

```

### 输出

```
999

```

## 样例 #2

### 输入

```
27191 17

```

### 输出

```
27189

```



---

---
title: "Little Elephant and Problem"
layout: "post"
diff: 普及-
pid: CF220A
tag: []
---

# Little Elephant and Problem

## 题目描述

The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array $ a $ of length $ n $ and possibly swapped some elements of the array.

The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array $ a $ , only if array $ a $ can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.

Help the Little Elephant, determine if he could have accidentally changed the array $ a $ , sorted by non-decreasing, himself.

## 输入格式

The first line contains a single integer $ n $ $ (2<=n<=10^{5}) $ — the size of array $ a $ . The next line contains $ n $ positive integers, separated by single spaces and not exceeding $ 10^{9} $ , — array $ a $ .

Note that the elements of the array are not necessarily distinct numbers.

## 输出格式

In a single line print "YES" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and "NO" (without the quotes) otherwise.

## 说明/提示

In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is "YES".

In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is "YES".

In the third sample we can't sort the array in more than one swap operation, so the answer is "NO".

## 样例 #1

### 输入

```
2
1 2

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3
3 2 1

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
4
4 3 2 1

```

### 输出

```
NO

```



---

---
title: "Dice Tower"
layout: "post"
diff: 普及-
pid: CF225A
tag: []
---

# Dice Tower

## 题目描述

A dice is a cube, its faces contain distinct integers from 1 to 6 as black points. The sum of numbers at the opposite dice faces always equals 7. Please note that there are only two dice (these dices are mirror of each other) that satisfy the given constraints (both of them are shown on the picture on the left).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF225A/85f2da947143b29924bb6531722e86105dbf28c1.png)Alice and Bob play dice. Alice has built a tower from $ n $ dice. We know that in this tower the adjacent dice contact with faces with distinct numbers. Bob wants to uniquely identify the numbers written on the faces of all dice, from which the tower is built. Unfortunately, Bob is looking at the tower from the face, and so he does not see all the numbers on the faces. Bob sees the number on the top of the tower and the numbers on the two adjacent sides (on the right side of the picture shown what Bob sees).

Help Bob, tell whether it is possible to uniquely identify the numbers on the faces of all the dice in the tower, or not.

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=100 $ ) — the number of dice in the tower.

The second line contains an integer $ x $ $ (1<=x<=6) $ — the number Bob sees at the top of the tower. Next $ n $ lines contain two space-separated integers each: the $ i $ -th line contains numbers $ a_{i},b_{i} $ $ (1<=a_{i},b_{i}<=6; a_{i}≠b_{i}) $ — the numbers Bob sees on the two sidelong faces of the $ i $ -th dice in the tower.

Consider the dice in the tower indexed from top to bottom from 1 to $ n $ . That is, the topmost dice has index 1 (the dice whose top face Bob can see). It is guaranteed that it is possible to make a dice tower that will look as described in the input.

## 输出格式

Print "YES" (without the quotes), if it is possible to to uniquely identify the numbers on the faces of all the dice in the tower. If it is impossible, print "NO" (without the quotes).

## 样例 #1

### 输入

```
3
6
3 2
5 4
2 4

```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3
3
2 6
4 1
5 3

```

### 输出

```
NO
```



---

---
title: "Effective Approach"
layout: "post"
diff: 普及-
pid: CF227B
tag: []
---

# Effective Approach

## 题目描述

Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the $ 1 $ -st one (in this problem we consider the elements of the array indexed from $ 1 $ to $ n $ ) and ending with the $ n $ -th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the $ n $ -th and ending with the $ 1 $ -st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from $ 1 $ to $ n $ , and generated $ m $ queries of the form: find element with value $ b_{i} $ in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.

## 输入格式

The first line contains integer $ n $ $ (1<=n<=10^{5}) $ — the number of elements in the array. The second line contains $ n $ distinct space-separated integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=n) $ — the elements of array.

The third line contains integer $ m $ $ (1<=m<=10^{5}) $ — the number of queries. The last line contains $ m $ space-separated integers $ b_{1},b_{2},...,b_{m} $ $ (1<=b_{i}<=n) $ — the search queries. Note that the queries can repeat.

## 输出格式

Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.

## 说明/提示

In the first sample Vasya's approach will make one comparison (it starts with the $ 1 $ -st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the $ 2 $ -nd array element, doesn't find the search item and compares with the $ 1 $ -st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with $ 1 $ -st element, and then with the $ 2 $ -nd), and Petya's approach will find the required value in one comparison (the first comparison with the $ 2 $ -nd element).

## 样例 #1

### 输入

```
2
1 2
1
1

```

### 输出

```
1 2

```

## 样例 #2

### 输入

```
2
2 1
1
1

```

### 输出

```
2 1

```

## 样例 #3

### 输入

```
3
3 1 2
3
1 2 3

```

### 输出

```
6 6

```



---

---
title: "Bargaining Table"
layout: "post"
diff: 普及-
pid: CF22B
tag: []
---

# Bargaining Table

## 题目描述

Bob wants to put a new bargaining table in his office. To do so he measured the office room thoroughly and drew its plan: Bob's office room is a rectangular room $ n×m $ meters. Each square meter of the room is either occupied by some furniture, or free. A bargaining table is rectangular, and should be placed so, that its sides are parallel to the office walls. Bob doesn't want to change or rearrange anything, that's why all the squares that will be occupied by the table should be initially free. Bob wants the new table to sit as many people as possible, thus its perimeter should be maximal. Help Bob find out the maximum possible perimeter of a bargaining table for his office.

## 输入格式

The first line contains 2 space-separated numbers $ n $ and $ m $ ( $ 1<=n,m<=25 $ ) — the office room dimensions. Then there follow $ n $ lines with $ m $ characters 0 or 1 each. 0 stands for a free square meter of the office room. 1 stands for an occupied square meter. It's guaranteed that at least one square meter in the room is free.

## 输出格式

Output one number — the maximum possible perimeter of a bargaining table for Bob's office room.

## 样例 #1

### 输入

```
3 3
000
010
000

```

### 输出

```
8

```

## 样例 #2

### 输入

```
5 4
1100
0000
0000
0000
0000

```

### 输出

```
16

```



---

---
title: "Perfect Permutation"
layout: "post"
diff: 普及-
pid: CF233A
tag: []
---

# Perfect Permutation

## 题目描述

现有一个$1$~$n$的排列$p_1,p_2,...,p_n$。

$Nickolas$喜欢排列，他认为有一种排列是完美的。用$p_i$表示排列中的第$i$个元素，则完美的排列符合如下性质：

1. $p_{p_i}=i$

2. $p_i≠i$

现在给出$n$的值，请求出这个完美的排列。


现有一个$1$~$n$的排列$p_1,p_2,...,p_n$。

$Nickolas$喜欢排列，他认为有一种排列是完美的。用$p_i$表示排列中的第$i$个元素，则完美的排列符合如下性质：

1. $p_{p_i}=i$

2. $p_i≠i$

现在给出$n$的值，请求出这个完美的排列。

## 输入格式

仅一行，一个整数$n(1≤n≤ 100)$


仅一行，一个整数$n(1≤n≤ 100)$

## 输出格式

如果排列不存在，输出$-1$，否则输出完美排列，数字之间用空格隔开。

```


如果排列不存在，输出$-1$，否则输出完美排列，数字之间用空格隔开。
```

## 样例 #1

### 输入

```
1

```

### 输出

```
-1

```

## 样例 #2

### 输入

```
2

```

### 输出

```
2 1 

```

## 样例 #3

### 输入

```
4

```

### 输出

```
2 1 4 3 

```



---

---
title: "Non-square Equation"
layout: "post"
diff: 普及-
pid: CF233B
tag: []
---

# Non-square Equation

## 题目描述

让我们看看如下等式：

$x^2+s(x)×x-n=0$ ，其中$x$ ，$n$ 是正整数，$s(x)$ 是函数，相当于求十进制中$x$ 的位数之和。

给出一个整数$n$ ，找到$x$ 的最小正整数根，或确定没有这样的根。

## 输入格式

只有一行，包括一个整数$n(1<=n<=10^{18})$ ,表示方程中的参数。

请不要在С++中使用％lld读取或写入64位整数。 最好使用cin，cout流或％I64d。

## 输出格式

输出使方程成立的最小正整数根$x(x>0)$ ，如果没有这样的根，则输出-1。

## 说明/提示

在第一组数据中，$x=1$ 是最小根。因为$s(1)=1$ 且$1^2+1×1-2=0$ 

在第二组数据中，$x=10$ 是最小根。因为$s(10)=1+0=1$ 且$10^2+1×10-110=0$ 

在第三组数据中，方程无根。

感谢@二元长天笑 提供的翻译

## 样例 #1

### 输入

```
2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
110

```

### 输出

```
10

```

## 样例 #3

### 输入

```
4

```

### 输出

```
-1

```



---

---
title: "Easy Number Challenge"
layout: "post"
diff: 普及-
pid: CF236B
tag: []
---

# Easy Number Challenge

## 题目描述

Let's denote $ d(n) $ as the number of divisors of a positive integer $ n $ . You are given three integers $ a $ , $ b $ and $ c $ . Your task is to calculate the following sum:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF236B/6b4d9893ce96bd0459ff1289a8bf3491052ac12a.png)Find the sum modulo $ 1073741824 $ $ (2^{30}) $ .

## 输入格式

The first line contains three space-separated integers $ a $ , $ b $ and $ c $ ( $ 1<=a,b,c<=100 $ ).

## 输出格式

Print a single integer — the required sum modulo $ 1073741824 $ $ (2^{30}) $ .

## 说明/提示

For the first example.

- $ d(1·1·1)=d(1)=1 $ ;
- $ d(1·1·2)=d(2)=2 $ ;
- $ d(1·2·1)=d(2)=2 $ ;
- $ d(1·2·2)=d(4)=3 $ ;
- $ d(2·1·1)=d(2)=2 $ ;
- $ d(2·1·2)=d(4)=3 $ ;
- $ d(2·2·1)=d(4)=3 $ ;
- $ d(2·2·2)=d(8)=4 $ .

So the result is $ 1+2+2+3+2+3+3+4=20 $ .

## 样例 #1

### 输入

```
2 2 2

```

### 输出

```
20

```

## 样例 #2

### 输入

```
5 6 7

```

### 输出

```
1520

```



---

---
title: "Young Table"
layout: "post"
diff: 普及-
pid: CF237B
tag: []
---

# Young Table

## 题目描述

You've got table $ a $ , consisting of $ n $ rows, numbered from 1 to $ n $ . The $ i $ -th line of table $ a $ contains $ c_{i} $ cells, at that for all $ i $ $ (1&lt;i<=n) $ holds $ c_{i}<=c_{i-1} $ .

Let's denote $ s $ as the total number of cells of table $ a $ , that is, ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF237B/41032ee9d28de3347d7865d06640fb12d664cefb.png). We know that each cell of the table contains a single integer from $ 1 $ to $ s $ , at that all written integers are distinct.

Let's assume that the cells of the $ i $ -th row of table $ a $ are numbered from 1 to $ c_{i} $ , then let's denote the number written in the $ j $ -th cell of the $ i $ -th row as $ a_{i,j} $ . Your task is to perform several swap operations to rearrange the numbers in the table so as to fulfill the following conditions:

1. for all $ i,j $ $ (1&lt;i<=n; 1<=j<=c_{i}) $ holds $ a_{i,j}&gt;a_{i-1,j} $ ;
2. for all $ i,j $ $ (1<=i<=n; 1&lt;j<=c_{i}) $ holds $ a_{i,j}&gt;a_{i,j-1} $ .

In one swap operation you are allowed to choose two different cells of the table and swap the recorded there numbers, that is the number that was recorded in the first of the selected cells before the swap, is written in the second cell after it. Similarly, the number that was recorded in the second of the selected cells, is written in the first cell after the swap.

Rearrange the numbers in the required manner. Note that you are allowed to perform any number of operations, but not more than $ s $ . You do not have to minimize the number of operations.

## 输入格式

The first line contains a single integer $ n $ $ (1<=n<=50) $ that shows the number of rows in the table. The second line contains $ n $ space-separated integers $ c_{i} $ $ (1<=c_{i}<=50; c_{i}<=c_{i-1}) $ — the numbers of cells on the corresponding rows.

Next $ n $ lines contain table $ а $ . The $ i $ -th of them contains $ c_{i} $ space-separated integers: the $ j $ -th integer in this line represents $ a_{i,j} $ .

It is guaranteed that all the given numbers $ a_{i,j} $ are positive and do not exceed $ s $ . It is guaranteed that all $ a_{i,j} $ are distinct.

## 输出格式

In the first line print a single integer $ m $ $ (0<=m<=s) $ , representing the number of performed swaps.

In the next $ m $ lines print the description of these swap operations. In the $ i $ -th line print four space-separated integers $ x_{i},y_{i},p_{i},q_{i} $ $ (1<=x_{i},p_{i}<=n; 1<=y_{i}<=c_{xi}; 1<=q_{i}<=c_{pi}) $ . The printed numbers denote swapping the contents of cells $ a_{xi},y_{i} $ and $ a_{pi},q_{i} $ . Note that a swap operation can change the contents of distinct table cells. Print the swaps in the order, in which they should be executed.

## 样例 #1

### 输入

```
3
3 2 1
4 3 5
6 1
2

```

### 输出

```
2
1 1 2 2
2 1 3 1

```

## 样例 #2

### 输入

```
1
4
4 3 2 1

```

### 输出

```
2
1 1 1 4
1 2 1 3

```



---

---
title: "Dividing Orange"
layout: "post"
diff: 普及-
pid: CF244A
tag: []
---

# Dividing Orange

## 题目描述

有一个橙子，分成 $n⋅k$ 瓣，编号为 $1,2,3,\cdots n\cdot k$。现在要分给 $k$ 个小孩，以下是给橙子的规则：
- 每个小孩得到 $n$ 瓣橙子。
- 第 $i$ 个小孩有一个对橙子的要求：$a_i$，即他得到的橙子瓣中必须有编号为 $a_i$ 的橙子瓣。

保证没有两个小孩的 $a_i$ 相同。

## 输入格式

第一行有两个整数 $n,k$ $(1\le n,k\le 30)$

第二行有 $k$ 个整数 $a_1,a_2,...,a_k$ $(1\le a_i\le n⋅k)$

## 输出格式

输出一个 $n⋅k$ 的矩阵，即橙子分割后的编号矩阵，答案可能有多个解，输出其中一个即可

翻译者：[LYR_](https://www.luogu.com.cn/user/110319)

## 样例 #1

### 输入

```
2 2
4 1

```

### 输出

```
2 4 
1 3 

```

## 样例 #2

### 输入

```
3 1
2

```

### 输出

```
3 2 1 

```



---

---
title: "Mishap in Club"
layout: "post"
diff: 普及-
pid: CF245E
tag: []
---

# Mishap in Club

## 题目描述

Polycarpus just has been out of luck lately! As soon as he found a job in the "Binary Cat" cafe, the club got burgled. All ice-cream was stolen.

On the burglary night Polycarpus kept a careful record of all club visitors. Each time a visitor entered the club, Polycarpus put down character "+" in his notes. Similarly, each time a visitor left the club, Polycarpus put character "-" in his notes. We know that all cases of going in and out happened consecutively, that is, no two events happened at the same time. Polycarpus doesn't remember whether there was somebody in the club at the moment when his shift begun and at the moment when it ended.

Right now the police wonders what minimum number of distinct people Polycarpus could have seen. Assume that he sees anybody coming in or out of the club. Each person could have come in or out an arbitrary number of times.

## 输入格式

The only line of the input contains a sequence of characters "+" and "-", the characters are written one after another without any separators. The characters are written in the order, in which the corresponding events occurred. The given sequence has length from 1 to 300 characters, inclusive.

## 输出格式

Print the sought minimum number of people

## 样例 #1

### 输入

```
+-+-+

```

### 输出

```
1

```

## 样例 #2

### 输入

```
---
```

### 输出

```
3
```



---

---
title: "Buggy Sorting"
layout: "post"
diff: 普及-
pid: CF246A
tag: []
---

# Buggy Sorting

## 题目描述

Little boy Valera studies an algorithm of sorting an integer array. After studying the theory, he went on to the practical tasks. As a result, he wrote a program that sorts an array of $ n $ integers $ a_{1},a_{2},...,a_{n} $ in the non-decreasing order. The pseudocode of the program, written by Valera, is given below. The input of the program gets number $ n $ and array $ a $ .

`<br></br>loop integer variable  $ i $  from  $ 1 $  to  $ n-1 $ <br></br>    loop integer variable  $ j $  from  $ i $  to  $ n-1 $ <br></br>        if  $ (a_{j}&gt;a_{j+1}) $ , then swap the values of elements  $ a_{j} $  and  $ a_{j+1} $ <br></br>`But Valera could have made a mistake, because he hasn't yet fully learned the sorting algorithm. If Valera made a mistake in his program, you need to give a counter-example that makes his program work improperly (that is, the example that makes the program sort the array not in the non-decreasing order). If such example for the given value of $ n $ doesn't exist, print -1.

## 输入格式

You've got a single integer $ n $ $ (1<=n<=50) $ — the size of the sorted array.

## 输出格式

Print $ n $ space-separated integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=100 $ ) — the counter-example, for which Valera's algorithm won't work correctly. If the counter-example that meets the described conditions is impossible to give, print -1.

If there are several counter-examples, consisting of $ n $ numbers, you are allowed to print any of them.

## 样例 #1

### 输入

```
1

```

### 输出

```
-1

```



---

---
title: "Cupboards"
layout: "post"
diff: 普及-
pid: CF248A
tag: []
---

# Cupboards

## 题目描述

One foggy Stockholm morning, Karlsson decided to snack on some jam in his friend Lillebror Svantenson's house. Fortunately for Karlsson, there wasn't anybody in his friend's house. Karlsson was not going to be hungry any longer, so he decided to get some food in the house.

Karlsson's gaze immediately fell on $ n $ wooden cupboards, standing in the kitchen. He immediately realized that these cupboards have hidden jam stocks. Karlsson began to fly greedily around the kitchen, opening and closing the cupboards' doors, grab and empty all the jars of jam that he could find.

And now all jars of jam are empty, Karlsson has had enough and does not want to leave traces of his stay, so as not to let down his friend. Each of the cupboards has two doors: the left one and the right one. Karlsson remembers that when he rushed to the kitchen, all the cupboards' left doors were in the same position (open or closed), similarly, all the cupboards' right doors were in the same position (open or closed). Karlsson wants the doors to meet this condition as well by the time the family returns. Karlsson does not remember the position of all the left doors, also, he cannot remember the position of all the right doors. Therefore, it does not matter to him in what position will be all left or right doors. It is important to leave all the left doors in the same position, and all the right doors in the same position. For example, all the left doors may be closed, and all the right ones may be open.

Karlsson needs one second to open or close a door of a cupboard. He understands that he has very little time before the family returns, so he wants to know the minimum number of seconds $ t $ , in which he is able to bring all the cupboard doors in the required position.

Your task is to write a program that will determine the required number of seconds $ t $ .

## 输入格式

The first input line contains a single integer $ n $ — the number of cupboards in the kitchen ( $ 2<=n<=10^{4} $ ). Then follow $ n $ lines, each containing two integers $ l_{i} $ and $ r_{i} $ $ (0<=l_{i},r_{i}<=1) $ . Number $ l_{i} $ equals one, if the left door of the $ i $ -th cupboard is opened, otherwise number $ l_{i} $ equals zero. Similarly, number $ r_{i} $ equals one, if the right door of the $ i $ -th cupboard is opened, otherwise number $ r_{i} $ equals zero.

The numbers in the lines are separated by single spaces.

## 输出格式

In the only output line print a single integer $ t $ — the minimum number of seconds Karlsson needs to change the doors of all cupboards to the position he needs.

## 样例 #1

### 输入

```
5
0 1
1 0
0 1
1 1
0 1

```

### 输出

```
3

```



---

---
title: "Chilly Willy"
layout: "post"
diff: 普及-
pid: CF248B
tag: []
---

# Chilly Willy

## 题目描述

Chilly Willy loves playing with numbers. He only knows prime numbers that are digits yet. These numbers are $ 2 $ , $ 3 $ , $ 5 $ and $ 7 $ . But Willy grew rather bored of such numbers, so he came up with a few games that were connected with them.

Chilly Willy wants to find the minimum number of length $ n $ , such that it is simultaneously divisible by all numbers Willy already knows ( $ 2 $ , $ 3 $ , $ 5 $ and $ 7 $ ). Help him with that.

A number's length is the number of digits in its decimal representation without leading zeros.

## 输入格式

A single input line contains a single integer $ n $ ( $ 1<=n<=10^{5} $ ).

## 输出格式

Print a single integer — the answer to the problem without leading zeroes, or "-1" (without the quotes), if the number that meet the problem condition does not exist.

## 样例 #1

### 输入

```
1

```

### 输出

```
-1

```

## 样例 #2

### 输入

```
5

```

### 输出

```
10080
```



---

---
title: "Paper Work"
layout: "post"
diff: 普及-
pid: CF250A
tag: []
---

# Paper Work

## 题目描述

Polycarpus has been working in the analytic department of the "F.R.A.U.D." company for as much as $ n $ days. Right now his task is to make a series of reports about the company's performance for the last $ n $ days. We know that the main information in a day report is value $ a_{i} $ , the company's profit on the $ i $ -th day. If $ a_{i} $ is negative, then the company suffered losses on the $ i $ -th day.

Polycarpus should sort the daily reports into folders. Each folder should include data on the company's performance for several consecutive days. Of course, the information on each of the $ n $ days should be exactly in one folder. Thus, Polycarpus puts information on the first few days in the first folder. The information on the several following days goes to the second folder, and so on.

It is known that the boss reads one daily report folder per day. If one folder has three or more reports for the days in which the company suffered losses $ (a_{i}&lt;0) $ , he loses his temper and his wrath is terrible.

Therefore, Polycarpus wants to prepare the folders so that none of them contains information on three or more days with the loss, and the number of folders is minimal.

Write a program that, given sequence $ a_{i} $ , will print the minimum number of folders.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=100 $ ), $ n $ is the number of days. The second line contains a sequence of integers $ a_{1},a_{2},...,a_{n} $ ( $ |a_{i}|<=100 $ ), where $ a_{i} $ means the company profit on the $ i $ -th day. It is possible that the company has no days with the negative $ a_{i} $ .

## 输出格式

Print an integer $ k $ — the required minimum number of folders. In the second line print a sequence of integers $ b_{1} $ , $ b_{2} $ , ..., $ b_{k} $ , where $ b_{j} $ is the number of day reports in the $ j $ -th folder.

If there are multiple ways to sort the reports into $ k $ days, print any of them.

## 说明/提示

Here goes a way to sort the reports from the first sample into three folders:

 1 2 3 -4 -5 | -6 5 -5 | -6 -7 6In the second sample you can put all five reports in one folder.

## 样例 #1

### 输入

```
11
1 2 3 -4 -5 -6 5 -5 -6 -7 6

```

### 输出

```
3
5 3 3 
```

## 样例 #2

### 输入

```
5
0 -1 100 -1 0

```

### 输出

```
1
5 
```



---

---
title: "Boys and Girls"
layout: "post"
diff: 普及-
pid: CF253A
tag: []
---

# Boys and Girls

## 题目描述

There are $ n $ boys and $ m $ girls studying in the class. They should stand in a line so that boys and girls alternated there as much as possible. Let's assume that positions in the line are indexed from left to right by numbers from 1 to $ n+m $ . Then the number of integers $ i $ ( $ 1<=i&lt;n+m $ ) such that positions with indexes $ i $ and $ i+1 $ contain children of different genders (position $ i $ has a girl and position $ i+1 $ has a boy or vice versa) must be as large as possible.

Help the children and tell them how to form the line.

## 输入格式

The single line of the input contains two integers $ n $ and $ m $ ( $ 1<=n,m<=100 $ ), separated by a space.

## 输出格式

Print a line of $ n+m $ characters. Print on the $ i $ -th position of the line character "B", if the $ i $ -th position of your arrangement should have a boy and "G", if it should have a girl.

Of course, the number of characters "B" should equal $ n $ and the number of characters "G" should equal $ m $ . If there are multiple optimal solutions, print any of them.

## 说明/提示

In the first sample another possible answer is BGBGBG.

In the second sample answer BBGBGB is also optimal.

## 样例 #1

### 输入

```
3 3

```

### 输出

```
GBGBGB

```

## 样例 #2

### 输入

```
4 2

```

### 输出

```
BGBGBB

```



---

---
title: "Little Elephant and Bits"
layout: "post"
diff: 普及-
pid: CF258A
tag: []
---

# Little Elephant and Bits

## 题目描述

The Little Elephant has an integer $ a $ , written in the binary notation. He wants to write this number on a piece of paper.

To make sure that the number $ a $ fits on the piece of paper, the Little Elephant ought to delete exactly one any digit from number $ a $ in the binary record. At that a new number appears. It consists of the remaining binary digits, written in the corresponding order (possible, with leading zeroes).

The Little Elephant wants the number he is going to write on the paper to be as large as possible. Help him find the maximum number that he can obtain after deleting exactly one binary digit and print it in the binary notation.

## 输入格式

The single line contains integer $ a $ , written in the binary notation without leading zeroes. This number contains more than $ 1 $ and at most $ 10^{5} $ digits.

## 输出格式

In the single line print the number that is written without leading zeroes in the binary notation — the answer to the problem.

## 说明/提示

In the first sample the best strategy is to delete the second digit. That results in number $ 11_{2}=3_{10} $ .

In the second sample the best strategy is to delete the third or fourth digits — that results in number $ 11010_{2}=26_{10} $ .

## 样例 #1

### 输入

```
101

```

### 输出

```
11

```

## 样例 #2

### 输入

```
110010

```

### 输出

```
11010

```



---

---
title: "Little Elephant and Chess"
layout: "post"
diff: 普及-
pid: CF259A
tag: []
---

# Little Elephant and Chess

## 题目描述

The Little Elephant loves chess very much.

One day the Little Elephant and his friend decided to play chess. They've got the chess pieces but the board is a problem. They've got an $ 8×8 $ checkered board, each square is painted either black or white. The Little Elephant and his friend know that a proper chessboard doesn't have any side-adjacent cells with the same color and the upper left cell is white. To play chess, they want to make the board they have a proper chessboard. For that the friends can choose any row of the board and cyclically shift the cells of the chosen row, that is, put the last (rightmost) square on the first place in the row and shift the others one position to the right. You can run the described operation multiple times (or not run it at all).

For example, if the first line of the board looks like that "BBBBBBWW" (the white cells of the line are marked with character "W", the black cells are marked with character "B"), then after one cyclic shift it will look like that "WBBBBBBW".

Help the Little Elephant and his friend to find out whether they can use any number of the described operations to turn the board they have into a proper chessboard.

## 输入格式

The input consists of exactly eight lines. Each line contains exactly eight characters "W" or "B" without any spaces: the $ j $ -th character in the $ i $ -th line stands for the color of the $ j $ -th cell of the $ i $ -th row of the elephants' board. Character "W" stands for the white color, character "B" stands for the black color.

Consider the rows of the board numbered from 1 to 8 from top to bottom, and the columns — from 1 to 8 from left to right. The given board can initially be a proper chessboard.

## 输出格式

In a single line print "YES" (without the quotes), if we can make the board a proper chessboard and "NO" (without the quotes) otherwise.

## 说明/提示

In the first sample you should shift the following lines one position to the right: the 3-rd, the 6-th, the 7-th and the 8-th.

In the second sample there is no way you can achieve the goal.

## 样例 #1

### 输入

```
WBWBWBWB
BWBWBWBW
BWBWBWBW
BWBWBWBW
WBWBWBWB
WBWBWBWB
BWBWBWBW
WBWBWBWB

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
WBWBWBWB
WBWBWBWB
BBWBWWWB
BWBWBWBW
BWBWBWBW
BWBWBWWW
BWBWBWBW
BWBWBWBW

```

### 输出

```
NO

```



---

---
title: "Little Elephant and Magic Square"
layout: "post"
diff: 普及-
pid: CF259B
tag: []
---

# Little Elephant and Magic Square

## 题目描述

小象非常喜欢幻方。 幻方是一个3×3的表，每个单元格包含一些正整数。此时，表中所有行、列和对角线的整数之和相等。下图显示了幻方，其所有行、列和对角线中的整数之和等于15。 小象想起了一个幻方。他开始在一张纸上写这个正方形，但是当他写的时候，他忘记了幻方主对角线的所有三个元素。幸运的是，小象清楚地记得幻方的所有元素都没有超过10的5次方。 鉴于小象的笔记，帮助小象，恢复原来的幻方。

## 输入格式

输入的前三行包含小象的笔记。第一行包含幻方第一行的元素。第二行包含第二行的元素，第三行是第三行。大象忘记的主要对角线元素用零表示。 保证音符正好包含三个零，并且它们都位于主对角线上。保证表中所有正数不超过10的5次方。

## 输出格式

打印三行，每行打印三个整数——小象的幻方。如果有多个幻方，你可以打印其中任何一个。请注意，您打印的所有数字必须是正数，并且不超过10的5次方。 保证至少存在一个满足条件的幻方。

## 样例 #1

### 输入

```
0 1 1
1 0 1
1 1 0

```

### 输出

```
1 1 1
1 1 1
1 1 1

```

## 样例 #2

### 输入

```
0 3 6
5 0 5
4 7 0

```

### 输出

```
6 3 6
5 5 5
4 7 4

```



---

---
title: "Maxim and Discounts"
layout: "post"
diff: 普及-
pid: CF261A
tag: []
---

# Maxim and Discounts

## 题目描述

Maxim always goes to the supermarket on Sundays. Today the supermarket has a special offer of discount systems.

There are $ m $ types of discounts. We assume that the discounts are indexed from 1 to $ m $ . To use the discount number $ i $ , the customer takes a special basket, where he puts exactly $ q_{i} $ items he buys. Under the terms of the discount system, in addition to the items in the cart the customer can receive at most two items from the supermarket for free. The number of the "free items" (0, 1 or 2) to give is selected by the customer. The only condition imposed on the selected "free items" is as follows: each of them mustn't be more expensive than the cheapest item out of the $ q_{i} $ items in the cart.

Maxim now needs to buy $ n $ items in the shop. Count the minimum sum of money that Maxim needs to buy them, if he use the discount system optimally well.

Please assume that the supermarket has enough carts for any actions. Maxim can use the same discount multiple times. Of course, Maxim can buy items without any discounts.

## 输入格式

The first line contains integer $ m $ $ (1<=m<=10^{5}) $ — the number of discount types. The second line contains $ m $ integers: $ q_{1},q_{2},...,q_{m} $ $ (1<=q_{i}<=10^{5}) $ .

The third line contains integer $ n $ $ (1<=n<=10^{5}) $ — the number of items Maxim needs. The fourth line contains $ n $ integers: $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=10^{4}) $ — the items' prices.

The numbers in the lines are separated by single spaces.

## 输出格式

In a single line print a single integer — the answer to the problem.

## 说明/提示

In the first sample Maxim needs to buy two items that cost $ 100 $ and get a discount for two free items that cost $ 50 $ . In that case, Maxim is going to pay $ 200 $ .

In the second sample the best strategy for Maxim is to buy $ 3 $ items and get $ 2 $ items for free using the discount. In that case, Maxim is going to pay $ 150 $ .

## 样例 #1

### 输入

```
1
2
4
50 50 100 100

```

### 输出

```
200

```

## 样例 #2

### 输入

```
2
2 3
5
50 50 50 50 50

```

### 输出

```
150

```

## 样例 #3

### 输入

```
1
1
7
1 1 1 1 1 1 1

```

### 输出

```
3

```



---

---
title: "Squares"
layout: "post"
diff: 普及-
pid: CF263B
tag: []
---

# Squares

## 题目描述

Vasya has found a piece of paper with a coordinate system written on it. There are $ n $ distinct squares drawn in this coordinate system. Let's number the squares with integers from 1 to $ n $ . It turned out that points with coordinates $ (0,0) $ and $ (a_{i},a_{i}) $ are the opposite corners of the $ i $ -th square.

Vasya wants to find such integer point (with integer coordinates) of the plane, that belongs to exactly $ k $ drawn squares. We'll say that a point belongs to a square, if the point is located either inside the square, or on its boundary.

Help Vasya find a point that would meet the described limits.

## 输入格式

The first line contains two space-separated integers $ n $ , $ k $ $ (1<=n,k<=50) $ . The second line contains space-separated integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=10^{9}) $ .

It is guaranteed that all given squares are distinct.

## 输出格式

In a single line print two space-separated integers $ x $ and $ y $ $ (0<=x,y<=10^{9}) $ — the coordinates of the point that belongs to exactly $ k $ squares. If there are multiple answers, you are allowed to print any of them.

If there is no answer, print "-1" (without the quotes).

## 样例 #1

### 输入

```
4 3
5 1 3 4

```

### 输出

```
2 1

```

## 样例 #2

### 输入

```
3 1
2 4 1

```

### 输出

```
4 0

```

## 样例 #3

### 输入

```
4 50
5 1 10 2

```

### 输出

```
-1

```



---

---
title: "Roadside Trees (Simplified Edition)"
layout: "post"
diff: 普及-
pid: CF265B
tag: []
---

# Roadside Trees (Simplified Edition)

## 题目描述

Squirrel Liss loves nuts. There are $ n $ trees (numbered $ 1 $ to $ n $ from west to east) along a street and there is a delicious nut on the top of each tree. The height of the tree $ i $ is $ h_{i} $ . Liss wants to eat all nuts.

Now Liss is on the root of the tree with the number $ 1 $ . In one second Liss can perform one of the following actions:

- Walk up or down one unit on a tree.
- Eat a nut on the top of the current tree.
- Jump to the next tree. In this action the height of Liss doesn't change. More formally, when Liss is at height $ h $ of the tree $ i $ ( $ 1<=i<=n-1 $ ), she jumps to height $ h $ of the tree $ i+1 $ . This action can't be performed if $ h&gt;h_{i+1} $ .

Compute the minimal time (in seconds) required to eat all nuts.

## 输入格式

The first line contains an integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of trees.

Next $ n $ lines contains the height of trees: $ i $ -th line contains an integer $ h_{i} $ ( $ 1<=h_{i}<=10^{4} $ ) — the height of the tree with the number $ i $ .

## 输出格式

Print a single integer — the minimal time required to eat all nuts in seconds.

## 样例 #1

### 输入

```
2
1
2

```

### 输出

```
5

```

## 样例 #2

### 输入

```
5
2
1
2
1
1

```

### 输出

```
14

```



---

---
title: "Buttons"
layout: "post"
diff: 普及-
pid: CF268B
tag: []
---

# Buttons

## 题目描述

Manao is trying to open a rather challenging lock. The lock has $ n $ buttons on it and to open it, you should press the buttons in a certain order to open the lock. When you push some button, it either stays pressed into the lock (that means that you've guessed correctly and pushed the button that goes next in the sequence), or all pressed buttons return to the initial position. When all buttons are pressed into the lock at once, the lock opens.

Consider an example with three buttons. Let's say that the opening sequence is: {2, 3, 1}. If you first press buttons 1 or 3, the buttons unpress immediately. If you first press button 2, it stays pressed. If you press 1 after 2, all buttons unpress. If you press 3 after 2, buttons 3 and 2 stay pressed. As soon as you've got two pressed buttons, you only need to press button 1 to open the lock.

Manao doesn't know the opening sequence. But he is really smart and he is going to act in the optimal way. Calculate the number of times he's got to push a button in order to open the lock in the worst-case scenario.

## 输入格式

A single line contains integer $ n $ ( $ 1<=n<=2000 $ ) — the number of buttons the lock has.

## 输出格式

In a single line print the number of times Manao has to push a button in the worst-case scenario.

## 说明/提示

Consider the first test sample. Manao can fail his first push and push the wrong button. In this case he will already be able to guess the right one with his second push. And his third push will push the second right button. Thus, in the worst-case scenario he will only need 3 pushes.

## 样例 #1

### 输入

```
2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3

```

### 输出

```
7

```



---

---
title: "Fancy Fence"
layout: "post"
diff: 普及-
pid: CF270A
tag: []
---

# Fancy Fence

## 输入格式

第一行输入一个整数t，表示有t组样例输入。
之后的t行，每行一个整数a，表示转动的角度。

## 输出格式

如果围得出正多边形，输出“YES”（不要定义）。否则，输出“NO”（同上）。

（输入均不超过int类型）
## 输入输出样例

##### 输入样例#1：
3 30
60
90
##### 输出样例#1： 
NO
YES
YES

## 说明/提示

Emuskald想在他的农场周围造一圈栅栏，但是他太懒了，不想自己动手。于是，他买了一个栅栏机器人。

Emuskald想把栅栏围成正多边形。机器人每次造一个边，之后只能转动a°继续建造下一个边。

Emuskald能造出他想要的围栏吗？也就是说，有没有一种正多边形的每一个角都为a°。
第一组样例中，转动角度为30°，围不出正多边形。
第二组转动角度为60°，围出三角形。
第三组转动角度为90°，围出正方形。

感谢@PaulHunter 提供的翻译

## 样例 #1

### 输入

```
3
30
60
90

```

### 输出

```
NO
YES
YES

```



---

---
title: "Prime Matrix"
layout: "post"
diff: 普及-
pid: CF271B
tag: []
---

# Prime Matrix

## 题目描述

You've got an $ n×m $ matrix. The matrix consists of integers. In one move, you can apply a single transformation to the matrix: choose an arbitrary element of the matrix and increase it by $ 1 $ . Each element can be increased an arbitrary number of times.

You are really curious about prime numbers. Let us remind you that a prime number is a positive integer that has exactly two distinct positive integer divisors: itself and number one. For example, numbers 2, 3, 5 are prime and numbers 1, 4, 6 are not.

A matrix is prime if at least one of the two following conditions fulfills:

- the matrix has a row with prime numbers only;
- the matrix has a column with prime numbers only;

Your task is to count the minimum number of moves needed to get a prime matrix from the one you've got.

## 输入格式

The first line contains two integers $ n,m $ $ (1<=n,m<=500) $ — the number of rows and columns in the matrix, correspondingly.

Each of the following $ n $ lines contains $ m $ integers — the initial matrix. All matrix elements are positive integers. All numbers in the initial matrix do not exceed $ 10^{5} $ .

The numbers in the lines are separated by single spaces.

## 输出格式

Print a single integer — the minimum number of moves needed to get a prime matrix from the one you've got. If you've got a prime matrix, print 0.

## 说明/提示

In the first sample you need to increase number 1 in cell (1, 1). Thus, the first row will consist of prime numbers: 2, 2, 3.

In the second sample you need to increase number 8 in cell (1, 2) three times. Thus, the second column will consist of prime numbers: 11, 2.

In the third sample you don't have to do anything as the second column already consists of prime numbers: 3, 2.

## 样例 #1

### 输入

```
3 3
1 2 3
5 6 1
4 4 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
2 3
4 8 8
9 2 9

```

### 输出

```
3

```

## 样例 #3

### 输入

```
2 2
1 3
4 2

```

### 输出

```
0

```



---

---
title: "Lights Out"
layout: "post"
diff: 普及-
pid: CF275A
tag: []
---

# Lights Out

## 题目描述

$Lenny$ 正在操作一个 $3×3$ 大小的网格。 在游戏开始时，所有数都为 $1$ 。 操作任何一个指示灯都会改变它以及它上下左右四个相邻的网格（要在 $3×3$ 网格内）。每次操作时，所有需要改变的数均由 $0$ 变为 $1$ 或者由 $1$ 变为 $0$ 。
 
现在 $Lenny$ 已经操作了每一格一定次数。给定每个方格的操作次数，请输出每个方格的最终数值。

## 输入格式

输入共三行，每行包含三个整数 $x$ ( $0 \leqslant x \leqslant 100$ )。 第 $i$ 行的第 $j$ 个数表示操作网格的第 $i$ 行的第 $j$ 个方格的次数。

## 输出格式

输出三行，每行三个整数。第 $i$ 行的第 $j$ 个方格的数表示该方格的最终数值（ $0$ 或 $1$）。

## 样例 #1

### 输入

```
1 0 0
0 0 0
0 0 1

```

### 输出

```
001
010
100

```

## 样例 #2

### 输入

```
1 0 1
8 8 8
2 0 3

```

### 输出

```
010
011
100

```



---

---
title: "Lunch Rush"
layout: "post"
diff: 普及-
pid: CF276A
tag: []
---

# Lunch Rush

## 题目描述

$n$ 个餐馆，每个餐馆都有两个值 $f_i$，$t_i$，分别代表在该餐馆的快乐值和所要停留的时间，给出一个正整数 $k$，如果 $t_i>k$，则在该餐馆的快乐值为 $f_i-(t_i-k)$，否则，仍为 $f_i$，选择一个餐馆，使获得的快乐值最大。

## 输入格式

第一行两个正数 $n$，$k$。

接下来 $n$ 行每行两个数 $f_i$，$t_i$。

## 输出格式

一个数，表示最大快乐值。

## 说明/提示

$1\leq n \leq 10^4$，$1\leq k,f_i,t_i \leq 10^9$。

## 样例 #1

### 输入

```
2 5
3 3
4 5

```

### 输出

```
4

```

## 样例 #2

### 输入

```
4 6
5 8
3 6
2 3
2 2

```

### 输出

```
3

```

## 样例 #3

### 输入

```
1 5
1 7

```

### 输出

```
-1

```



---

---
title: "Circle Line"
layout: "post"
diff: 普及-
pid: CF278A
tag: []
---

# Circle Line

## 题目描述

有$n$个车站排成一个环形，给定$n$个车站之间的距离，求从第$s$个车站到第$t$个车站所需的最短距离。

## 输入格式

第一行给定车站个数$n$。

第二行给定$n$个车站之间的距离，其中第$i$个数表示第$i$个车站到第$i+1$个车站的距离$d_{i}$。特别地，最后一个数表示第一个车站与最后一个车站之间的距离。

第三行给定两个整数$s$和$t$，表示起点和终点。

## 输出格式

输出共一行，表示第$s$个车站到第$t$个车站之间的最短距离。

## 样例 #1

### 输入

```
4
2 3 4 9
1 3

```

### 输出

```
5

```

## 样例 #2

### 输入

```
4
5 8 2 100
4 1

```

### 输出

```
15

```

## 样例 #3

### 输入

```
3
1 1 1
3 1

```

### 输出

```
1

```

## 样例 #4

### 输入

```
3
31 41 59
1 1

```

### 输出

```
0

```



---

---
title: "Point on Spiral"
layout: "post"
diff: 普及-
pid: CF279A
tag: []
---

# Point on Spiral

## 题目描述

Valera the horse lives on a plane. The Cartesian coordinate system is defined on this plane. Also an infinite spiral is painted on the plane. The spiral consists of segments:  $ [(0,0),(1,0)] $ , $ [(1,0),(1,1)] $ , $ [(1,1),(-1,1)] $ , $ [(-1,1),(-1,-1)] $ , $ [(-1,-1),(2,-1)] $ , $ [(2,-1),(2,2)] $  and so on. Thus, this infinite spiral passes through each integer point of the plane.

Valera the horse lives on the plane at coordinates $ (0,0) $ . He wants to walk along the spiral to point $ (x,y) $ . Valera the horse has four legs, so he finds turning very difficult. Count how many times he will have to turn if he goes along a spiral from point $ (0,0) $ to point $ (x,y) $ .

## 输入格式

The first line contains two space-separated integers $ x $ and $ y $ $ (|x|,|y|<=100) $ .

## 输出格式

Print a single integer, showing how many times Valera has to turn.

## 样例 #1

### 输入

```
0 0

```

### 输出

```
0

```

## 样例 #2

### 输入

```
1 0

```

### 输出

```
0

```

## 样例 #3

### 输入

```
0 1

```

### 输出

```
2

```

## 样例 #4

### 输入

```
-1 -1

```

### 输出

```
3

```



---

---
title: "Cows and Poker Game"
layout: "post"
diff: 普及-
pid: CF284B
tag: []
---

# Cows and Poker Game

## 题目描述

There are $ n $ cows playing poker at a table. For the current betting phase, each player's status is either "ALLIN", "IN", or "FOLDED", and does not change throughout the phase. To increase the suspense, a player whose current status is not "FOLDED" may show his/her hand to the table. However, so as not to affect any betting decisions, he/she may only do so if all other players have a status of either "ALLIN" or "FOLDED". The player's own status may be either "ALLIN" or "IN".

Find the number of cows that can currently show their hands without affecting any betting decisions.

## 输入格式

The first line contains a single integer, $ n $ ( $ 2<=n<=2·10^{5} $ ). The second line contains $ n $ characters, each either "A", "I", or "F". The $ i $ -th character is "A" if the $ i $ -th player's status is "ALLIN", "I" if the $ i $ -th player's status is "IN", or "F" if the $ i $ -th player's status is "FOLDED".

## 输出格式

The first line should contain a single integer denoting the number of players that can currently show their hands.

## 说明/提示

In the first sample, cows 1, 4, 5, and 6 can show their hands. In the second sample, only cow 3 can show her hand.

## 样例 #1

### 输入

```
6
AFFAAA

```

### 输出

```
4

```

## 样例 #2

### 输入

```
3
AFI

```

### 输出

```
1

```



---

---
title: "Slightly Decreasing Permutations"
layout: "post"
diff: 普及-
pid: CF285A
tag: []
---

# Slightly Decreasing Permutations

## 题目描述

Permutation $ p $ is an ordered set of integers $ p_{1},p_{2},...,p_{n} $ , consisting of $ n $ distinct positive integers, each of them doesn't exceed $ n $ . We'll denote the $ i $ -th element of permutation $ p $ as $ p_{i} $ . We'll call number $ n $ the size or the length of permutation $ p_{1},p_{2},...,p_{n} $ .

The decreasing coefficient of permutation $ p_{1},p_{2},...,p_{n} $ is the number of such $ i\ (1<=i&lt;n) $ , that $ p_{i}&gt;p_{i+1} $ .

You have numbers $ n $ and $ k $ . Your task is to print the permutation of length $ n $ with decreasing coefficient $ k $ .

## 输入格式

The single line contains two space-separated integers: $ n,k\ (1<=n<=10^{5},0<=k&lt;n) $ — the permutation length and the decreasing coefficient.

## 输出格式

In a single line print $ n $ space-separated integers: $ p_{1},p_{2},...,p_{n} $ — the permutation of length $ n $ with decreasing coefficient $ k $ .

If there are several permutations that meet this condition, print any of them. It is guaranteed that the permutation with the sought parameters exists.

## 样例 #1

### 输入

```
5 2

```

### 输出

```
1 5 2 4 3

```

## 样例 #2

### 输入

```
3 0

```

### 输出

```
1 2 3

```

## 样例 #3

### 输入

```
3 2

```

### 输出

```
3 2 1

```



---

---
title: "Building Permutation"
layout: "post"
diff: 普及-
pid: CF285C
tag: []
---

# Building Permutation

## 题目描述

Permutation $ p $ is an ordered set of integers $ p_{1},p_{2},...,p_{n} $ , consisting of $ n $ distinct positive integers, each of them doesn't exceed $ n $ . We'll denote the $ i $ -th element of permutation $ p $ as $ p_{i} $ . We'll call number $ n $ the size or the length of permutation $ p_{1},p_{2},...,p_{n} $ .

You have a sequence of integers $ a_{1},a_{2},...,a_{n} $ . In one move, you are allowed to decrease or increase any number by one. Count the minimum number of moves, needed to build a permutation from this sequence.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=3·10^{5} $ ) — the size of the sought permutation. The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ -10^{9}<=a_{i}<=10^{9} $ ).

## 输出格式

Print a single number — the minimum number of moves.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.

## 说明/提示

In the first sample you should decrease the first number by one and then increase the second number by one. The resulting permutation is $ (2,1) $ .

In the second sample you need 6 moves to build permutation $ (1,3,2) $ .

## 样例 #1

### 输入

```
2
3 0

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3
-1 -1 2

```

### 输出

```
6

```



---

---
title: "IQ Test"
layout: "post"
diff: 普及-
pid: CF287A
tag: []
---

# IQ Test

## 题目描述

In the city of Ultima Thule job applicants are often offered an IQ test.

The test is as follows: the person gets a piece of squared paper with a $ 4×4 $ square painted on it. Some of the square's cells are painted black and others are painted white. Your task is to repaint at most one cell the other color so that the picture has a $ 2×2 $ square, completely consisting of cells of the same color. If the initial picture already has such a square, the person should just say so and the test will be completed.

Your task is to write a program that determines whether it is possible to pass the test. You cannot pass the test if either repainting any cell or no action doesn't result in a $ 2×2 $ square, consisting of cells of the same color.

## 输入格式

Four lines contain four characters each: the $ j $ -th character of the $ i $ -th line equals "." if the cell in the $ i $ -th row and the $ j $ -th column of the square is painted white, and "\#", if the cell is black.

## 输出格式

Print "YES" (without the quotes), if the test can be passed and "NO" (without the quotes) otherwise.

## 说明/提示

In the first test sample it is enough to repaint the first cell in the second row. After such repainting the required $ 2×2 $ square is on the intersection of the $ 1 $ -st and $ 2 $ -nd row with the $ 1 $ -st and $ 2 $ -nd column.

## 样例 #1

### 输入

```
####
.#..
####
....

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
####
....
####
....

```

### 输出

```
NO

```



---

---
title: "Polo the Penguin and Strings"
layout: "post"
diff: 普及-
pid: CF288A
tag: []
---

# Polo the Penguin and Strings

## 题目描述

```
CF288A
题目大意：
找到一个字符串，满足以下条件：
1、长度为n，且字符串中包含k种小写字母；
2、相邻的字符不相等；
3、在满足1、2两条件的所有字符串中字典序最小。

## 输入格式

一行，包含两个整数n、k，分别表示字符串的长度以及包含的小写字母数量（1<=n<=1000000,1<=k<=26）

## 输出格式

若存在满足上述条件的字符串，输出该字符串，否则输出-1
```

## 样例 #1

### 输入

```
7 4

```

### 输出

```
ababacd

```

## 样例 #2

### 输入

```
4 7

```

### 输出

```
-1

```



---

---
title: "Polo the Penguin and Segments"
layout: "post"
diff: 普及-
pid: CF289A
tag: []
---

# Polo the Penguin and Segments

## 题目描述

Little penguin Polo adores integer segments, that is, pairs of integers $ [l; r] $ $ (l<=r) $ .

He has a set that consists of $ n $ integer segments: $ [l_{1}; r_{1}],[l_{2}; r_{2}],...,[l_{n}; r_{n}] $ . We know that no two segments of this set intersect. In one move Polo can either widen any segment of the set 1 unit to the left or 1 unit to the right, that is transform $ [l; r] $ to either segment $ [l-1; r] $ , or to segment $ [l; r+1] $ .

The value of a set of segments that consists of $ n $ segments $ [l_{1}; r_{1}],[l_{2}; r_{2}],...,[l_{n}; r_{n}] $ is the number of integers $ x $ , such that there is integer $ j $ , for which the following inequality holds, $ l_{j}<=x<=r_{j} $ .

Find the minimum number of moves needed to make the value of the set of Polo's segments divisible by $ k $ .

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1<=n,k<=10^{5} $ ). Each of the following $ n $ lines contain a segment as a pair of integers $ l_{i} $ and $ r_{i} $ ( $ -10^{5}<=l_{i}<=r_{i}<=10^{5} $ ), separated by a space.

It is guaranteed that no two segments intersect. In other words, for any two integers $ i,j $ $ (1<=i&lt;j<=n) $ the following inequality holds, $ min(r_{i},r_{j})&lt;max(l_{i},l_{j}) $ .

## 输出格式

In a single line print a single integer — the answer to the problem.

## 样例 #1

### 输入

```
2 3
1 2
3 4

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3 7
1 2
3 3
4 7

```

### 输出

```
0

```



---

---
title: "Polo the Penguin and Matrix"
layout: "post"
diff: 普及-
pid: CF289B
tag: []
---

# Polo the Penguin and Matrix

## 题目描述

Little penguin Polo has an $ n×m $ matrix, consisting of integers. Let's index the matrix rows from 1 to $ n $ from top to bottom and let's index the columns from 1 to $ m $ from left to right. Let's represent the matrix element on the intersection of row $ i $ and column $ j $ as $ a_{ij} $ .

In one move the penguin can add or subtract number $ d $ from some matrix element. Find the minimum number of moves needed to make all matrix elements equal. If the described plan is impossible to carry out, say so.

## 输入格式

The first line contains three integers $ n $ , $ m $ and $ d $ $ (1<=n,m<=100,1<=d<=10^{4}) $ — the matrix sizes and the $ d $ parameter. Next $ n $ lines contain the matrix: the $ j $ -th integer in the $ i $ -th row is the matrix element $ a_{ij} $ $ (1<=a_{ij}<=10^{4}) $ .

## 输出格式

In a single line print a single integer — the minimum number of moves the penguin needs to make all matrix elements equal. If that is impossible, print "-1" (without the quotes).

## 样例 #1

### 输入

```
2 2 2
2 4
6 8

```

### 输出

```
4

```

## 样例 #2

### 输入

```
1 2 7
6 7

```

### 输出

```
-1

```



---

---
title: "Yaroslav and Permutations"
layout: "post"
diff: 普及-
pid: CF296A
tag: []
---

# Yaroslav and Permutations

## 题目描述

Yaroslav has an array that consists of $ n $ integers. In one second Yaroslav can swap two neighboring array elements. Now Yaroslav is wondering if he can obtain an array where any two neighboring elements would be distinct in a finite time.

Help Yaroslav.

## 输入格式

The first line contains integer $ n $ $ (1<=n<=100) $ — the number of elements in the array. The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=1000) $ — the array elements.

## 输出格式

In the single line print "YES" (without the quotes) if Yaroslav can obtain the array he needs, and "NO" (without the quotes) otherwise.

## 说明/提示

In the first sample the initial array fits well.

In the second sample Yaroslav can get array: $ 1 $ , $ 2 $ , $ 1 $ . He can swap the last and the second last elements to obtain it.

In the third sample Yarosav can't get the array he needs.

## 样例 #1

### 输入

```
1
1

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3
1 1 2

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
4
7 7 7 7

```

### 输出

```
NO

```



---

---
title: "Parity Game"
layout: "post"
diff: 普及-
pid: CF297A
tag: []
---

# Parity Game

## 题目描述

你和北极熊 Alice 和北极熊 Bob 一起钓鱼。他们等鱼上钩等得很无聊，于是想到了一个游戏来消磨时间。首先，Alice 和 Bob 分别写下一个 01 串（只包含”0”和“1”的字符串）$a$ 和 $b$，然后你可以通过两种操作尝试将 $a$ 变成 $b$：



- 将 $parity(a)$ 添加到 $a$ 的末尾。例如：$1010 \rightarrow 10100$。



- 删除 $a$ 的第一个字符。例如：$1001 \rightarrow 001$。若 $a$ 为空串则无法进行此操作。



你可以进行任意多次操作。现在请你求出是否能将 $a$ 变为 $b$。



如果一个 01 串中有奇数个 $1$，那么这个 01 串的 $parity$ 值是 $1$，否则是 $0$。

## 输入格式

第一行为 01 串 $a$，第二行为 01 串 $b$（$1 \le |a|, |b| \le 1000$）。其中 $|x|$ 表示串 $x$ 的长度。

## 输出格式

如果可能将 $a$ 变为 $b$ 则输出 `YES`，否则输出 `NO`。

## 样例 #1

### 输入

```
01011
0110

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
0011
1110

```

### 输出

```
NO

```



---

---
title: "Array"
layout: "post"
diff: 普及-
pid: CF300A
tag: []
---

# Array

## 题目描述

Vitaly has an array of $ n $ distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold:

1. The product of all numbers in the first set is less than zero $ (<0) $ .
2. The product of all numbers in the second set is greater than zero $ (>0) $ .
3. The product of all numbers in the third set is equal to zero.
4. Each number from the initial array must occur in exactly one set.

Help Vitaly. Divide the given array.

## 输入格式

The first line of the input contains integer $ n $ $ (3<=n<=100) $ . The second line contains $ n $ space-separated distinct integers $ a_{1},a_{2},...,a_{n} $ $ (|a_{i}|<=10^{3}) $ — the array elements.

## 输出格式

In the first line print integer $ n_{1} $ $ (n_{1}>0) $ — the number of elements in the first set. Then print $ n_{1} $ numbers — the elements that got to the first set.

In the next line print integer $ n_{2} $ $ (n_{2}>0) $ — the number of elements in the second set. Then print $ n_{2} $ numbers — the elements that got to the second set.

In the next line print integer $ n_{3} $ $ (n_{3}>0) $ — the number of elements in the third set. Then print $ n_{3} $ numbers — the elements that got to the third set.

The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.

## 样例 #1

### 输入

```
3
-1 2 0

```

### 输出

```
1 -1
1 2
1 0

```

## 样例 #2

### 输入

```
4
-1 -2 -3 0

```

### 输出

```
1 -1
2 -3 -2
1 0

```



---

---
title: "Pythagorean Theorem II"
layout: "post"
diff: 普及-
pid: CF304A
tag: []
---

# Pythagorean Theorem II

## 题目描述

In mathematics, the Pythagorean theorem — is a relation in Euclidean geometry among the three sides of a right-angled triangle. In terms of areas, it states:

 In any right-angled triangle, the area of the square whose side is the hypotenuse (the side opposite the right angle) is equal to the sum of the areas of the squares whose sides are the two legs (the two sides that meet at a right angle).

The theorem can be written as an equation relating the lengths of the sides $ a $ , $ b $ and $ c $ , often called the Pythagorean equation:

 $ a^{2}+b^{2}=c^{2} $ where $ c $ represents the length of the hypotenuse, and $ a $ and $ b $ represent the lengths of the other two sides.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF304A/dce71d69bec644282a576a6a33bfe17bb5e666a5.png)Given $ n $ , your task is to count how many right-angled triangles with side-lengths $ a $ , $ b $ and $ c $ that satisfied an inequality $ 1<=a<=b<=c<=n $ .

## 输入格式

The only line contains one integer $ n (1<=n<=10^{4}) $ as we mentioned above.

## 输出格式

Print a single integer — the answer to the problem.

## 样例 #1

### 输入

```
5

```

### 输出

```
1

```

## 样例 #2

### 输入

```
74

```

### 输出

```
35

```



---

---
title: "Calendar"
layout: "post"
diff: 普及-
pid: CF304B
tag: []
---

# Calendar

## 题目描述

Calendars in widespread use today include the Gregorian calendar, which is the de facto international standard, and is used almost everywhere in the world for civil purposes. The Gregorian reform modified the Julian calendar's scheme of leap years as follows:

 Every year that is exactly divisible by four is a leap year, except for years that are exactly divisible by 100; the centurial years that are exactly divisible by 400 are still leap years. For example, the year 1900 is not a leap year; the year 2000 is a leap year.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF304B/f8498332105130efe5e68ba02dfcaba5e2afd72f.png)In this problem, you have been given two dates and your task is to calculate how many days are between them. Note, that leap years have unusual number of days in February.

Look at the sample to understand what borders are included in the aswer.

## 输入格式

The first two lines contain two dates, each date is in the format yyyy:mm:dd ( $ 1900<=yyyy<=2038 $ and yyyy:mm:dd is a legal date).

## 输出格式

Print a single integer — the answer to the problem.

## 样例 #1

### 输入

```
1900:01:01
2038:12:31

```

### 输出

```
50768

```

## 样例 #2

### 输入

```
1996:03:09
1991:11:12

```

### 输出

```
1579

```



---

---
title: "Accounting"
layout: "post"
diff: 普及-
pid: CF30A
tag: []
---

# Accounting

## 题目描述

A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.

The total income $ A $ of his kingdom during $ 0 $ -th year is known, as well as the total income $ B $ during $ n $ -th year (these numbers can be negative — it means that there was a loss in the correspondent year).

King wants to show financial stability. To do this, he needs to find common coefficient $ X $ — the coefficient of income growth during one year. This coefficient should satisfy the equation:

 $ A·X^{n}=B. $ Surely, the king is not going to do this job by himself, and demands you to find such number $ X $ .

It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient $ X $ must be integers. The number $ X $ may be zero or negative.

## 输入格式

The input contains three integers $ A $ , $ B $ , $ n $ ( $ |A|,|B|<=1000 $ , $ 1<=n<=10 $ ).

## 输出格式

Output the required integer coefficient $ X $ , or «No solution», if such a coefficient does not exist or it is fractional. If there are several possible solutions, output any of them.

## 样例 #1

### 输入

```
2 18 2

```

### 输出

```
3
```

## 样例 #2

### 输入

```
-1 8 3

```

### 输出

```
-2
```

## 样例 #3

### 输入

```
0 0 10

```

### 输出

```
5
```

## 样例 #4

### 输入

```
1 16 5

```

### 输出

```
No solution
```



---

---
title: "Codeforces World Finals"
layout: "post"
diff: 普及-
pid: CF30B
tag: []
---

# Codeforces World Finals

## 题目描述

## 题意描述
关于 Codeforces 的网站 king Copa 经常被报道，使得它在要使用网站进行训练和比赛的人之间迅速流行开来。最近， Copa 明白，要征服世界，他需要组织世界 Codeforces 锦标赛。他希望在这次比赛之后之后，最聪明的人将成为被挑选出来成为他的下属，然后征服世界最艰难的部分将会完成。

Codeforces 世界总决赛的最后一轮定于 $YY$ 年 $MM$ 月 $DD$ 日举行，其中 $DD$  是当天的日期， $MM$ 是当月的月份， $YY$ 是当年的年份的最后两位。Bob 很幸运地能成为来自 Berland 的一名决赛选手。但有一个问题：根据比赛规则，所有参赛者在决赛时必须年满 $18$ 岁。 Bob 出生于 $BY$ 年， $BM$ 月，$BD$ 日。这个日期记录在他的护照上，他的护照复印件已经寄给了组织者。但是 Bob 了解到，在不同的国家，日期的书写方式是不同的。例如，在美国，先写月份，然后写日期，最后写年份。

鲍勃想知道是否有可能重新排列他出生日期的数字，以便他在 $YY$ 年， $MM$ 月， $DD$ 日那天至少 $18$ 岁。他看出，在他的祖国，日期写的顺序不一样。请帮帮他。
根据另一个奇怪的规则，合格的参赛者必须与决赛日期出生在同一个世纪。如果决赛当天刚好是参赛者的 $18$ 岁生日，则他可以参加。

因为我们只考虑从 $2001$ 年到 $2099$ 年的决赛年份，所以使用以下规则：如果年份的数字可以被 $4$ 整除，那么年份就是闰年。

## 输入格式

第一行包括三个数字 $DD,MM,YY$ ，第二行包括三个数字 $BD,BM,BY$ ，数据保证两个日期的正确性，并且 $BY$ 和 $YY$ 保证在 $[ 01 ，99 ]$ 中。

## 输出格式

如果可能通过重新排列出生日期的顺序，让 Bob 在比赛当天至少 $18$ 岁，则输出 YES 。如果不能，则输出 NO。

## 样例 #1

### 输入

```
01.01.98
01.01.80

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
20.10.20
10.02.30

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
28.02.74
28.02.64

```

### 输出

```
NO

```



---

---
title: "Whose sentence is it?"
layout: "post"
diff: 普及-
pid: CF312A
tag: []
---

# Whose sentence is it?

## 题目描述

One day, liouzhou\_101 got a chat record of Freda and Rainbow. Out of curiosity, he wanted to know which sentences were said by Freda, and which were said by Rainbow. According to his experience, he thought that Freda always said "lala." at the end of her sentences, while Rainbow always said "miao." at the beginning of his sentences. For each sentence in the chat record, help liouzhou\_101 find whose sentence it is.

## 输入格式

The first line of the input contains an integer $ n $ ( $ 1<=n<=10 $ ), number of sentences in the chat record. Each of the next $ n $ lines contains a sentence. A sentence is a string that contains only Latin letters (A-Z, a-z), underline (\_), comma (,), point (.) and space ( ). Its length doesn’t exceed 100.

## 输出格式

For each sentence, output "Freda's" if the sentence was said by Freda, "Rainbow's" if the sentence was said by Rainbow, or "OMG>.< I don't know!" if liouzhou\_101 can’t recognize whose sentence it is. He can’t recognize a sentence if it begins with "miao." and ends with "lala.", or satisfies neither of the conditions.

## 样例 #1

### 输入

```
5
I will go to play with you lala.
wow, welcome.
miao.lala.
miao.
miao .

```

### 输出

```
Freda's
OMG>.< I don't know!
OMG>.< I don't know!
Rainbow's
OMG>.< I don't know!

```



---

---
title: "Ilya and Bank Account"
layout: "post"
diff: 普及-
pid: CF313A
tag: []
---

# Ilya and Bank Account

## 题目描述

Ilya是一只灰常聪明的狮子，他住在一座不同寻常的城市中——动物园！在这座城市中，每一只动物都有它的权利与义务。它们甚至都有自己的银行账户。银行账户包含一个整数，其中有可能是负数（说明它欠钱了）。

Ilya最近要过生日了，所以他收到了一系列礼物。其中一个礼物（动物园总行）可以让它消除它银行账户上的最后一位或倒数第二位数字（**就一次**）。比如说，如果Ilya的账户上余额为-123，那么他可以消除3得到-12，或者消除2得到-13（当然它不傻，知道欠钱越少越好）。Ilya也可以不消除数字。

现在，Ilya要你帮他算出它最多有多少钱。

## 输入格式

一行一个整数 $n$（$10\le|n|\le 10^9$）

## 输出格式

一行一个整数，表示他最多有多少钱。

## 说明/提示

第一个样例中，狮子没有用那个礼物消除数。
第二个样例中，狮子消除了1得到0。

## 样例 #1

### 输入

```
2230

```

### 输出

```
2230

```

## 样例 #2

### 输入

```
-10

```

### 输出

```
0

```

## 样例 #3

### 输入

```
-100003

```

### 输出

```
-10000

```



---

---
title: "Sereja and Bottles"
layout: "post"
diff: 普及-
pid: CF315A
tag: []
---

# Sereja and Bottles

## 题目描述

Sereja and his friends went to a picnic. The guys had $ n $ soda bottles just for it. Sereja forgot the bottle opener as usual, so the guys had to come up with another way to open bottles.

Sereja knows that the $ i $ -th bottle is from brand $ a_{i} $ , besides, you can use it to open other bottles of brand $ b_{i} $ . You can use one bottle to open multiple other bottles. Sereja can open bottle with opened bottle or closed bottle.

Knowing this, Sereja wants to find out the number of bottles they've got that they won't be able to open in any way. Help him and find this number.

## 输入格式

The first line contains integer $ n $ $ (1<=n<=100) $ — the number of bottles. The next $ n $ lines contain the bottles' description. The $ i $ -th line contains two integers $ a_{i},b_{i} $ $ (1<=a_{i},b_{i}<=1000) $ — the description of the $ i $ -th bottle.

## 输出格式

In a single line print a single integer — the answer to the problem.

## 样例 #1

### 输入

```
4
1 1
2 2
3 3
4 4

```

### 输出

```
4

```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
4 1

```

### 输出

```
0

```



---

---
title: "Sereja and Array"
layout: "post"
diff: 普及-
pid: CF315B
tag: []
---

# Sereja and Array

## 题目描述

Sereja has got an array, consisting of $ n $ integers, $ a_{1},a_{2},...,a_{n} $ . Sereja is an active boy, so he is now going to complete $ m $ operations. Each operation will have one of the three forms:

1. Make $ v_{i} $ -th array element equal to $ x_{i} $ . In other words, perform the assignment $ a_{vi}=x_{i} $ .
2. Increase each array element by $ y_{i} $ . In other words, perform $ n $ assignments $ a_{i}=a_{i}+y_{i} $ $ (1<=i<=n) $ .
3. Take a piece of paper and write out the $ q_{i} $ -th array element. That is, the element $ a_{qi} $ .

Help Sereja, complete all his operations.

## 输入格式

The first line contains integers $ n $ , $ m $ $ (1<=n,m<=10^{5}) $ . The second line contains $ n $ space-separated integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=10^{9}) $ — the original array.

Next $ m $ lines describe operations, the $ i $ -th line describes the $ i $ -th operation. The first number in the $ i $ -th line is integer $ t_{i} $ $ (1<=t_{i}<=3) $ that represents the operation type. If $ t_{i}=1 $ , then it is followed by two integers $ v_{i} $ and $ x_{i} $ , $ (1<=v_{i}<=n,1<=x_{i}<=10^{9}) $ . If $ t_{i}=2 $ , then it is followed by integer $ y_{i} $ $ (1<=y_{i}<=10^{4}) $ . And if $ t_{i}=3 $ , then it is followed by integer $ q_{i} $ $ (1<=q_{i}<=n) $ .

## 输出格式

For each third type operation print value $ a_{qi} $ . Print the values in the order, in which the corresponding queries follow in the input.

## 样例 #1

### 输入

```
10 11
1 2 3 4 5 6 7 8 9 10
3 2
3 9
2 10
3 1
3 10
1 1 10
2 10
2 10
3 1
3 10
3 9

```

### 输出

```
2
9
11
20
30
40
39

```



---

---
title: "Special Task"
layout: "post"
diff: 普及-
pid: CF316A1
tag: []
---

# Special Task

## 题目描述

Special Agent Smart Beaver works in a secret research department of ABBYY. He's been working there for a long time and is satisfied with his job, as it allows him to eat out in the best restaurants and order the most expensive and exotic wood types there.

The content special agent has got an important task: to get the latest research by British scientists on the English Language. These developments are encoded and stored in a large safe. The Beaver's teeth are strong enough, so the authorities assured that upon arriving at the place the beaver won't have any problems with opening the safe.

And he finishes his aspen sprig and leaves for this important task. Of course, the Beaver arrived at the location without any problems, but alas. He can't open the safe with his strong and big teeth. At this point, the Smart Beaver get a call from the headquarters and learns that opening the safe with the teeth is not necessary, as a reliable source has sent the following information: the safe code consists of digits and has no leading zeroes. There also is a special hint, which can be used to open the safe. The hint is string $ s $ with the following structure:

- if $ s_{i} $ = "?", then the digit that goes $ i $ -th in the safe code can be anything (between $ 0 $ to $ 9 $ , inclusively);
- if $ s_{i} $ is a digit (between $ 0 $ to $ 9 $ , inclusively), then it means that there is digit $ s_{i} $ on position $ i $ in code;
- if the string contains letters from "A" to "J", then all positions with the same letters must contain the same digits and the positions with distinct letters must contain distinct digits.
- The length of the safe code coincides with the length of the hint.

For example, hint "?JGJ9" has such matching safe code variants: "51919", "55959", "12329", "93539" and so on, and has wrong variants such as: "56669", "00111", "03539" and "13666".

After receiving such information, the authorities change the plan and ask the special agents to work quietly and gently and not to try to open the safe by mechanical means, and try to find the password using the given hint.

At a special agent school the Smart Beaver was the fastest in his platoon finding codes for such safes, but now he is not in that shape: the years take their toll ... Help him to determine the number of possible variants of the code to the safe, matching the given hint. After receiving this information, and knowing his own speed of entering codes, the Smart Beaver will be able to determine whether he will have time for tonight's show "Beavers are on the trail" on his favorite TV channel, or he should work for a sleepless night...

## 输入格式

The first line contains string $ s $ — the hint to the safe code. String $ s $ consists of the following characters: ?, 0-9, A-J. It is guaranteed that the first character of string $ s $ doesn't equal to character $ 0 $ .

The input limits for scoring 30 points are (subproblem A1):

- $ 1<=|s|<=5 $ .

The input limits for scoring 100 points are (subproblems A1+A2):

- $ 1<=|s|<=10^{5} $ .

Here $ |s| $ means the length of string $ s $ .

## 输出格式

Print the number of codes that match the given hint.

## 样例 #1

### 输入

```
AJ

```

### 输出

```
81

```

## 样例 #2

### 输入

```
1?AA

```

### 输出

```
100

```



---

---
title: "Worms Evolution"
layout: "post"
diff: 普及-
pid: CF31A
tag: []
---

# Worms Evolution

## 题目描述

Vasechkin教授正在研究蠕虫的进化。最近他提出一种假说——所有蠕虫都是通过分裂而来。这里有n种形态不同的蠕虫。这些蠕虫有以下长度$a_1,a_2,\ldots,a_n$

为了证明他的理论，教授需要找到3种形态不同的蠕虫，其中第一个的长度是另外两个的和。帮助他完成这个吧。

## 输入格式

第一行包含一个整数n（$3\leq n\leq100$）——蠕虫的数量。第二行包含n个被空格分开的整数$a_i$​（$1\leq a_i\leq1000$）——每种形态蠕虫的长度

## 输出格式

输出3个不同的整数i,j,k（$1\leq i,j,k\leq n$）——满足这样条件的蠕虫的索引（索引？译者注：我真不知道这里怎么翻译好，这里就是指a的下标）

表示有$a_i=a_j+a_k$​。如果不存在这样的三元组，输出-1。如果有多种解，输出它们中的任意一种。可以是$a_j=a_k$

Translated by Khassar

## 样例 #1

### 输入

```
5
1 2 3 5 7

```

### 输出

```
3 2 1

```

## 样例 #2

### 输入

```
5
1 8 1 5 1

```

### 输出

```
-1

```



---

---
title: "Magic Numbers"
layout: "post"
diff: 普及-
pid: CF320A
tag: []
---

# Magic Numbers

## 题目描述

A magic number is a number formed by concatenation of numbers $ 1 $ , $ 14 $ and $ 144 $ . We can use each of these numbers any number of times. Therefore $ 14144 $ , $ 141414 $ and $ 1411 $ are magic numbers but $ 1444 $ , $ 514 $ and $ 414 $ are not.

You're given a number. Determine if it is a magic number or not.

## 输入格式

The first line of input contains an integer $ n $ , $ (1<=n<=10^{9}) $ . This number doesn't contain leading zeros.

## 输出格式

Print "YES" if $ n $ is a magic number or print "NO" if it's not.

## 样例 #1

### 输入

```
114114

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
1111

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
441231

```

### 输出

```
NO

```



---

---
title: "Ciel and Dancing"
layout: "post"
diff: 普及-
pid: CF322A
tag: []
---

# Ciel and Dancing

## 题目描述

Fox Ciel and her friends are in a dancing room. There are $ n $ boys and $ m $ girls here, and they never danced before. There will be some songs, during each song, there must be exactly one boy and one girl are dancing. Besides, there is a special rule:

- either the boy in the dancing pair must dance for the first time (so, he didn't dance with anyone before);
- or the girl in the dancing pair must dance for the first time.

Help Fox Ciel to make a schedule that they can dance as many songs as possible.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1<=n,m<=100 $ ) — the number of boys and girls in the dancing room.

## 输出格式

In the first line print $ k $ — the number of songs during which they can dance. Then in the following $ k $ lines, print the indexes of boys and girls dancing during songs chronologically. You can assume that the boys are indexed from 1 to $ n $ , and the girls are indexed from 1 to $ m $ .

## 说明/提示

In test case 1, there are 2 boys and 1 girl. We can have 2 dances: the 1st boy and 1st girl (during the first song), the 2nd boy and 1st girl (during the second song).

And in test case 2, we have 2 boys with 2 girls, the answer is 3.

## 样例 #1

### 输入

```
2 1

```

### 输出

```
2
1 1
2 1

```

## 样例 #2

### 输入

```
2 2

```

### 输出

```
3
1 1
1 2
2 2

```



---

---
title: "Ciel and Flowers"
layout: "post"
diff: 普及-
pid: CF322B
tag: []
---

# Ciel and Flowers

## 题目描述

Fox Ciel has some flowers: $ r $ red flowers, $ g $ green flowers and $ b $ blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:

- To make a "red bouquet", it needs 3 red flowers.
- To make a "green bouquet", it needs 3 green flowers.
- To make a "blue bouquet", it needs 3 blue flowers.
- To make a "mixing bouquet", it needs 1 red, 1 green and 1 blue flower.

Help Fox Ciel to find the maximal number of bouquets she can make.

## 输入格式

The first line contains three integers $ r $ , $ g $ and $ b $ ( $ 0<=r,g,b<=10^{9} $ ) — the number of red, green and blue flowers.

## 输出格式

Print the maximal number of bouquets Fox Ciel can make.

## 说明/提示

In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.

## 样例 #1

### 输入

```
3 6 9

```

### 输出

```
6

```

## 样例 #2

### 输入

```
4 4 4

```

### 输出

```
4

```

## 样例 #3

### 输入

```
0 0 0

```

### 输出

```
0

```



---

---
title: "IQ Test"
layout: "post"
diff: 普及-
pid: CF328A
tag: []
---

# IQ Test

## 题目描述

Petya is preparing for IQ test and he has noticed that there many problems like: you are given a sequence, find the next number. Now Petya can solve only problems with arithmetic or geometric progressions.

Arithmetic progression is a sequence $ a_{1} $ , $ a_{1}+d $ , $ a_{1}+2d $ , $ ... $ , $ a_{1}+(n-1)d $ , where $ a_{1} $ and $ d $ are any numbers.

Geometric progression is a sequence $ b_{1} $ , $ b_{2}=b_{1}q $ , $ ... $ , $ b_{n}=b_{n-1}q $ , where $ b_{1}≠0 $ , $ q≠0 $ , $ q≠1 $ .

Help Petya and write a program to determine if the given sequence is arithmetic or geometric. Also it should found the next number. If the sequence is neither arithmetic nor geometric, print 42 (he thinks it is impossible to find better answer). You should also print 42 if the next element of progression is not integer. So answer is always integer.

## 输入格式

The first line contains exactly four integer numbers between 1 and 1000, inclusively.

## 输出格式

Print the required number. If the given sequence is arithmetic progression, print the next progression element. Similarly, if the given sequence is geometric progression, print the next progression element.

Print 42 if the given sequence is not an arithmetic or geometric progression.

## 说明/提示

This problem contains very weak pretests!

## 样例 #1

### 输入

```
836 624 412 200

```

### 输出

```
-12

```

## 样例 #2

### 输入

```
1 334 667 1000

```

### 输出

```
1333

```



---

---
title: "Flea"
layout: "post"
diff: 普及-
pid: CF32C
tag: []
---

# Flea

## 题目描述

It is known that fleas in Berland can jump only vertically and horizontally, and the length of the jump is always equal to $ s $ centimeters. A flea has found herself at the center of some cell of the checked board of the size $ n×m $ centimeters (each cell is $ 1×1 $ centimeters). She can jump as she wishes for an arbitrary number of times, she can even visit a cell more than once. The only restriction is that she cannot jump out of the board.

The flea can count the amount of cells that she can reach from the starting position $ (x,y) $ . Let's denote this amount by $ d_{x,y} $ . Your task is to find the number of such starting positions $ (x,y) $ , which have the maximum possible value of $ d_{x,y} $ .

## 输入格式

The first line contains three integers $ n $ , $ m $ , $ s $ ( $ 1<=n,m,s<=10^{6} $ ) — length of the board, width of the board and length of the flea's jump.

## 输出格式

Output the only integer — the number of the required starting positions of the flea.

## 样例 #1

### 输入

```
2 3 1000000

```

### 输出

```
6

```

## 样例 #2

### 输入

```
3 3 2

```

### 输出

```
4

```



---

---
title: "Constellation"
layout: "post"
diff: 普及-
pid: CF32D
tag: []
---

# Constellation

## 题目描述

一个Berland星空图填充了一个N×M的正方形。在每一个正方形上都可能有星星。Berland的十字星座是所有的天文学家最喜欢的星座。这个星座可以由任何5个恒星组成，所以对于整数x（星座的半径），有以下原则：

第二个和第一个在同一条垂直线上，但是在第一个的上边x单位处。

第三个和第一个在同一条垂直线上，但是在第一个的下边x单位处。

第四个和第一个在同一水平线上，但是在第一个的左边x单位处。

第五个和第一个在同一水平线上，但是在第一个的右边x单位处。

这些星座可以非常多，这就是为什么他们有以下原则：当两星座相比，更小的半径会有更小的指数；如果他们的半径相等，其中央恒星如果高于另一个中央恒星；如果他们中央恒星都在同一水平的人，其中央恒星是对另一个中央恒星的左边。

你的任务是找到星座为指数K的Berland的星空图。

## 输入格式

第一行包含三个整数N,M和k(1 <= N，M = 300,1 <= K <= 3*10^7)分别为地图的高与宽以及所需星座的指数。左上角坐标为(1,1)，右下角坐标为(N,M)。N行，M列的字符分别描述星空图。第i行第j列的字符为mapij

## 输出格式

如果星座指数小于k，输出-1。否则输出5行，每行分别两个整数，即星座的每一个星星的坐标。按照中央、上、下、左、右的顺序输出星星： 

感谢@Shan_Xian 提供的翻译

## 样例 #1

### 输入

```
5 6 1
....*.
...***
....*.
..*...
.***..

```

### 输出

```
2 5
1 5
3 5
2 4
2 6

```

## 样例 #2

### 输入

```
5 6 2
....*.
...***
....*.
..*...
.***..

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
7 7 2
...*...
.......
...*...
*.***.*
...*...
.......
...*...

```

### 输出

```
4 4
1 4
7 4
4 1
4 7

```



---

---
title: "Cakeminator"
layout: "post"
diff: 普及-
pid: CF330A
tag: []
---

# Cakeminator

## 题目描述

给你一个矩形蛋糕，表示为r×c网格。每个网格都可能有一个邪恶的草莓或者没有。例如，3×4蛋糕可能如下所示：【见图】

cakeminator将要吃蛋糕啦！每次他吃东西，他都会选择一个不含任何邪恶草莓的行或列，并且至少包含一个以前没有吃过的蛋糕，并吃掉那一行或列的所有蛋糕。他可能会吃多次。

请输出cakeminator可以吃的最大蛋糕数。

## 输入格式

第一行包含两个整数r和c（2 <= r，c <= 10 2 <= r，c <= 10 2 <= r，c <= 10），表示行数和列数蛋糕。下一行r每行包含c个字符 - 第i行的第j个字符表示第i行和第j行的单元格内容，并且是以下之一：

    ''字符表示没有邪恶草莓的蛋糕;
    'S'字符表示带有邪恶草莓的蛋糕。

## 输出格式

输出蛋糕机可以吃的最大蛋糕数。

## 样例 #1

### 输入

```
3 4
S...
....
..S.

```

### 输出

```
8

```



---

---
title: "Candy Bags"
layout: "post"
diff: 普及-
pid: CF334A
tag: []
---

# Candy Bags

## 题目描述

Gerald has $ n $ younger brothers and their number happens to be even. One day he bought $ n^{2} $ candy bags. One bag has one candy, one bag has two candies, one bag has three candies and so on. In fact, for each integer $ k $ from $ 1 $ to $ n^{2} $ he has exactly one bag with $ k $ candies.

Help him give $ n $ bags of candies to each brother so that all brothers got the same number of candies.

## 输入格式

The single line contains a single integer $ n $ ( $ n $ is even, $ 2<=n<=100 $ ) — the number of Gerald's brothers.

## 输出格式

Let's assume that Gerald indexes his brothers with numbers from $ 1 $ to $ n $ . You need to print $ n $ lines, on the $ i $ -th line print $ n $ integers — the numbers of candies in the bags for the $ i $ -th brother. Naturally, all these numbers should be distinct and be within limits from $ 1 $ to $ n^{2} $ . You can print the numbers in the lines in any order.

It is guaranteed that the solution exists at the given limits.

## 说明/提示

The sample shows Gerald's actions if he has two brothers. In this case, his bags contain 1, 2, 3 and 4 candies. He can give the bags with 1 and 4 candies to one brother and the bags with 2 and 3 to the other brother.

## 样例 #1

### 输入

```
2

```

### 输出

```
1 4
2 3

```



---

---
title: "Eight Point Sets"
layout: "post"
diff: 普及-
pid: CF334B
tag: []
---

# Eight Point Sets

## 题目描述

Gerald is very particular to eight point sets. He thinks that any decent eight point set must consist of all pairwise intersections of three distinct integer vertical straight lines and three distinct integer horizontal straight lines, except for the average of these nine points. In other words, there must be three integers $ x_{1},x_{2},x_{3} $ and three more integers $ y_{1},y_{2},y_{3} $ , such that $ x_{1}&lt;x_{2}&lt;x_{3} $ , $ y_{1}&lt;y_{2}&lt;y_{3} $ and the eight point set consists of all points $ (x_{i},y_{j}) $ ( $ 1<=i,j<=3 $ ), except for point $ (x_{2},y_{2}) $ .

You have a set of eight points. Find out if Gerald can use this set?

## 输入格式

The input consists of eight lines, the $ i $ -th line contains two space-separated integers $ x_{i} $ and $ y_{i} $ ( $ 0<=x_{i},y_{i}<=10^{6} $ ). You do not have any other conditions for these points.

## 输出格式

In a single line print word "respectable", if the given set of points corresponds to Gerald's decency rules, and "ugly" otherwise.

## 样例 #1

### 输入

```
0 0
0 1
0 2
1 0
1 2
2 0
2 1
2 2

```

### 输出

```
respectable

```

## 样例 #2

### 输入

```
0 0
1 0
2 0
3 0
4 0
5 0
6 0
7 0

```

### 输出

```
ugly

```

## 样例 #3

### 输入

```
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2

```

### 输出

```
ugly

```



---

---
title: "Puzzles"
layout: "post"
diff: 普及-
pid: CF337A
tag: []
---

# Puzzles

## 题目描述

The end of the school year is near and Ms. Manana, the teacher, will soon have to say goodbye to a yet another class. She decided to prepare a goodbye present for her $ n $ students and give each of them a jigsaw puzzle (which, as wikipedia states, is a tiling puzzle that requires the assembly of numerous small, often oddly shaped, interlocking and tessellating pieces).

The shop assistant told the teacher that there are $ m $ puzzles in the shop, but they might differ in difficulty and size. Specifically, the first jigsaw puzzle consists of $ f_{1} $ pieces, the second one consists of $ f_{2} $ pieces and so on.

Ms. Manana doesn't want to upset the children, so she decided that the difference between the numbers of pieces in her presents must be as small as possible. Let $ A $ be the number of pieces in the largest puzzle that the teacher buys and $ B $ be the number of pieces in the smallest such puzzle. She wants to choose such $ n $ puzzles that $ A-B $ is minimum possible. Help the teacher and find the least possible value of $ A-B $ .

## 输入格式

The first line contains space-separated integers $ n $ and $ m $ ( $ 2<=n<=m<=50 $ ). The second line contains $ m $ space-separated integers $ f_{1},f_{2},...,f_{m} $ ( $ 4<=f_{i}<=1000 $ ) — the quantities of pieces in the puzzles sold in the shop.

## 输出格式

Print a single integer — the least possible difference the teacher can obtain.

## 说明/提示

Sample 1. The class has 4 students. The shop sells 6 puzzles. If Ms. Manana buys the first four puzzles consisting of 10, 12, 10 and 7 pieces correspondingly, then the difference between the sizes of the largest and the smallest puzzle will be equal to 5. It is impossible to obtain a smaller difference. Note that the teacher can also buy puzzles 1, 3, 4 and 5 to obtain the difference 5.

## 样例 #1

### 输入

```
4 6
10 12 10 7 5 22

```

### 输出

```
5

```



---

---
title: "Routine Problem"
layout: "post"
diff: 普及-
pid: CF337B
tag: []
---

# Routine Problem

## 题目描述

Manao has a monitor. The screen of the monitor has horizontal to vertical length ratio $ a $ : $ b $ . Now he is going to watch a movie. The movie's frame has horizontal to vertical length ratio $ c $ : $ d $ . Manao adjusts the view in such a way that the movie preserves the original frame ratio, but also occupies as much space on the screen as possible and fits within it completely. Thus, he may have to zoom the movie in or out, but Manao will always change the frame proportionally in both dimensions.

Calculate the ratio of empty screen (the part of the screen not occupied by the movie) to the total screen size. Print the answer as an irreducible fraction $ p/q $ .

## 输入格式

A single line contains four space-separated integers $ a $ , $ b $ , $ c $ , $ d $ ( $ 1<=a,b,c,d<=1000 $ ).

## 输出格式

Print the answer to the problem as "p/q", where $ p $ is a non-negative integer, $ q $ is a positive integer and numbers $ p $ and $ q $ don't have a common divisor larger than 1.

## 说明/提示

Sample 1. Manao's monitor has a square screen. The movie has 3:2 horizontal to vertical length ratio. Obviously, the movie occupies most of the screen if the width of the picture coincides with the width of the screen. In this case, only 2/3 of the monitor will project the movie in the horizontal dimension: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF337B/429cc762b90fac9b9969eeb0bd54bb3278635967.png)

Sample 2. This time the monitor's width is 4/3 times larger than its height and the movie's frame is square. In this case, the picture must take up the whole monitor in the vertical dimension and only 3/4 in the horizontal dimension: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF337B/9da098e1ff076f33756d107ad7616fb9b6b441f1.png)

## 样例 #1

### 输入

```
1 1 3 2

```

### 输出

```
1/3

```

## 样例 #2

### 输入

```
4 3 2 2

```

### 输出

```
1/4

```



---

---
title: "Rational Resistance"
layout: "post"
diff: 普及-
pid: CF343A
tag: []
---

# Rational Resistance

## 题目描述

Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.

However, all Mike has is lots of identical resistors with unit resistance $ R_{0}=1 $ . Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements:

1. one resistor;
2. an element and one resistor plugged in sequence;
3. an element and one resistor plugged in parallel.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF343A/f117fcf32ddafc80e319e28fce885c21483edc5b.png)With the consecutive connection the resistance of the new element equals $ R=R_{e}+R_{0} $ . With the parallel connection the resistance of the new element equals ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF343A/a708eb8090c66cbbd34afced0c36506bcb612681.png). In this case $ R_{e} $ equals the resistance of the element being connected.

Mike needs to assemble an element with a resistance equal to the fraction ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF343A/eecd60ed91fbeebe74e2406ea1a11d26df905945.png). Determine the smallest possible number of resistors he needs to make such an element.

## 输入格式

The single input line contains two space-separated integers $ a $ and $ b $ ( $ 1<=a,b<=10^{18} $ ). It is guaranteed that the fraction ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF343A/eecd60ed91fbeebe74e2406ea1a11d26df905945.png) is irreducible. It is guaranteed that a solution always exists.

## 输出格式

Print a single number — the answer to the problem.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.

## 说明/提示

In the first sample, one resistor is enough.

In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF343A/234023ef6c61445a95e9903d46cd7846f3823141.png). We cannot make this element using two resistors.

## 样例 #1

### 输入

```
1 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
3 2

```

### 输出

```
3

```

## 样例 #3

### 输入

```
199 200

```

### 输出

```
200

```



---

---
title: "Simple Molecules"
layout: "post"
diff: 普及-
pid: CF344B
tag: []
---

# Simple Molecules

## 题目描述

Mad scientist Mike is busy carrying out experiments in chemistry. Today he will attempt to join three atoms into one molecule.

A molecule consists of atoms, with some pairs of atoms connected by atomic bonds. Each atom has a valence number — the number of bonds the atom must form with other atoms. An atom can form one or multiple bonds with any other atom, but it cannot form a bond with itself. The number of bonds of an atom in the molecule must be equal to its valence number.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF344B/e6377325271b4515d315f9767d5c5b94bf56f174.png)Mike knows valence numbers of the three atoms. Find a molecule that can be built from these atoms according to the stated rules, or determine that it is impossible.

## 输入格式

The single line of the input contains three space-separated integers $ a $ , $ b $ and $ c $ ( $ 1<=a,b,c<=10^{6} $ ) — the valence numbers of the given atoms.

## 输出格式

If such a molecule can be built, print three space-separated integers — the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print "Impossible" (without the quotes).

## 说明/提示

The first sample corresponds to the first figure. There are no bonds between atoms 1 and 2 in this case.

The second sample corresponds to the second figure. There is one or more bonds between each pair of atoms.

The third sample corresponds to the third figure. There is no solution, because an atom cannot form bonds with itself.

The configuration in the fourth figure is impossible as each atom must have at least one atomic bond.

## 样例 #1

### 输入

```
1 1 2

```

### 输出

```
0 1 1

```

## 样例 #2

### 输入

```
3 4 5

```

### 输出

```
1 3 2

```

## 样例 #3

### 输入

```
4 1 1

```

### 输出

```
Impossible

```



---

---
title: "Fixed Points"
layout: "post"
diff: 普及-
pid: CF347B
tag: []
---

# Fixed Points

## 题目描述

A permutation of length $ n $ is an integer sequence such that each integer from 0 to $ (n-1) $ appears exactly once in it. For example, sequence $ [0,2,1] $ is a permutation of length 3 while both $ [0,2,2] $ and $ [1,2,3] $ are not.

A fixed point of a function is a point that is mapped to itself by the function. A permutation can be regarded as a bijective function. We'll get a definition of a fixed point in a permutation. An integer $ i $ is a fixed point of permutation $ a_{0},a_{1},...,a_{n-1} $ if and only if $ a_{i}=i $ . For example, permutation $ [0,2,1] $ has $ 1 $ fixed point and permutation $ [0,1,2] $ has $ 3 $ fixed points.

You are given permutation $ a $ . You are allowed to swap two elements of the permutation at most once. Your task is to maximize the number of fixed points in the resulting permutation. Note that you are allowed to make at most one swap operation.

## 输入格式

The first line contains a single integer $ n $ $ (1<=n<=10^{5}) $ . The second line contains $ n $ integers $ a_{0},a_{1},...,a_{n-1} $ — the given permutation.

## 输出格式

Print a single integer — the maximum possible number of fixed points in the permutation after at most one swap operation.

## 样例 #1

### 输入

```
5
0 1 3 4 2

```

### 输出

```
3

```



---

---
title: "Cinema Line"
layout: "post"
diff: 普及-
pid: CF349A
tag: []
---

# Cinema Line

## 题目描述

新电影《虎胆龙威》刚刚上映了！  
有n位观众正~~焦急地~~站在电影院售票处并且排成了一列长队。他们或多或少都有**一张**100,50或是25卢布（毕竟是毛子的oj网站）的钞票。  
一张《虎胆龙威》的票价是25卢布。  
那么问题是：如果这位售票员最初没有钱，并且严格地按照人们排队的顺序（有素质）卖票，售票员能否将一张票卖给每位观众并且找零吗？

## 输入格式

第一行包含了一位整数n (1<=n<=10^5)用于表示正在排队的观众的数量。  
第二行包含了n位整数，他们是25,50,100这三个数其中之一位用于表示每位观众所持有的钞票面额。（这些数字是顺序给出的）。

## 输出格式

如果售票员可以使得这些观众都看上电影并且能找开他们的零钱，输出“YES”。否则，输出“NO”（不带引号）。~~“”：又不带我嘤嘤嘤...~~   
（样例#2解释：有两位观众，这两位观众分别有一张25卢布面额的钞票和一张100卢布的钞票，因为售票员最初没有任何钱，所以他在收了第一位观众的钱后（得到了25卢布），找不开第二位观众所需的75卢布，所以输出“NO”）

## 样例 #1

### 输入

```
4
25 25 50 50

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
2
25 100

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
4
50 50 25 25

```

### 输出

```
NO

```



---

---
title: "TL"
layout: "post"
diff: 普及-
pid: CF350A
tag: []
---

# TL

## 题目描述

Valera wanted to prepare a Codesecrof round. He's already got one problem and he wants to set a time limit (TL) on it.

Valera has written $ n $ correct solutions. For each correct solution, he knows its running time (in seconds). Valera has also wrote $ m $ wrong solutions and for each wrong solution he knows its running time (in seconds).

Let's suppose that Valera will set $ v $ seconds TL in the problem. Then we can say that a solution passes the system testing if its running time is at most $ v $ seconds. We can also say that a solution passes the system testing with some "extra" time if for its running time, $ a $ seconds, an inequality $ 2a<=v $ holds.

As a result, Valera decided to set $ v $ seconds TL, that the following conditions are met:

1. $ v $ is a positive integer;
2. all correct solutions pass the system testing;
3. at least one correct solution passes the system testing with some "extra" time;
4. all wrong solutions do not pass the system testing;
5. value $ v $ is minimum among all TLs, for which points $ 1 $ , $ 2 $ , $ 3 $ , $ 4 $ hold.

Help Valera and find the most suitable TL or else state that such TL doesn't exist.

## 输入格式

The first line contains two integers $ n $ , $ m $ ( $ 1<=n,m<=100 $ ). The second line contains $ n $ space-separated positive integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=100 $ ) — the running time of each of the $ n $ correct solutions in seconds. The third line contains $ m $ space-separated positive integers $ b_{1},b_{2},...,b_{m} $ ( $ 1<=b_{i}<=100 $ ) — the running time of each of $ m $ wrong solutions in seconds.

## 输出格式

If there is a valid TL value, print it. Otherwise, print -1.

## 样例 #1

### 输入

```
3 6
4 5 2
8 9 6 10 7 11

```

### 输出

```
5
```

## 样例 #2

### 输入

```
3 1
3 4 5
6

```

### 输出

```
-1

```



---

---
title: "Jeff and Periods"
layout: "post"
diff: 普及-
pid: CF352B
tag: []
---

# Jeff and Periods

## 题目描述

One day Jeff got hold of an integer sequence $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{n} $ of length $ n $ . The boy immediately decided to analyze the sequence. For that, he needs to find all values of $ x $ , for which these conditions hold:

- $ x $ occurs in sequence $ a $ .
- Consider all positions of numbers $ x $ in the sequence $ a $ (such $ i $ , that $ a_{i}=x $ ). These numbers, sorted in the increasing order, must form an arithmetic progression.

Help Jeff, find all $ x $ that meet the problem conditions.

## 输入格式

The first line contains integer $ n $ $ (1<=n<=10^{5}) $ . The next line contains integers $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{n} $ $ (1<=a_{i}<=10^{5}) $ . The numbers are separated by spaces.

## 输出格式

In the first line print integer $ t $ — the number of valid $ x $ . On each of the next $ t $ lines print two integers $ x $ and $ p_{x} $ , where $ x $ is current suitable value, $ p_{x} $ is the common difference between numbers in the progression (if $ x $ occurs exactly once in the sequence, $ p_{x} $ must equal 0). Print the pairs in the order of increasing $ x $ .

## 说明/提示

In the first test $ 2 $ occurs exactly once in the sequence, ergo $ p_{2}=0 $ .

## 样例 #1

### 输入

```
1
2

```

### 输出

```
1
2 0

```

## 样例 #2

### 输入

```
8
1 2 1 3 1 2 1 5

```

### 输出

```
4
1 2
2 4
3 0
5 0

```



---

---
title: "Domino"
layout: "post"
diff: 普及-
pid: CF353A
tag: []
---

# Domino

## 题目描述

## 【问题描述】

Hades与Dionysus在狂饮后玩起了多米诺骨牌的小游戏。
现在桌上有n块多米诺骨牌，每块多米诺骨牌上半部分和下半部分上都有一个整数。每次翻转可让一块多米诺骨牌上下翻转，即上下部分数交换。Hades想让n块骨牌上半部分的数加起来是一个偶数，而Dionysus想让这n块骨牌下半部分的数加起来是一个偶数。喝醉的两人都不肯退让，非要达到自己的目的。路过的Hephaestus在扫了一眼桌上的骨牌后瞬间给出了一个让两人都满意且翻转次数最少的方案，便转身离去，留下迟滞的二人。可这还没完，喝得烂醉的二人很快忘记了Hephaestus所说的方案，Hades说他还记得最少的翻转次数，Dionysus不愿被比下去，只好来请教你了。

## 输入格式

第一行包含一个整数n，表示多米诺骨牌的数量。之后n行每行包含两个分隔的整数xi，yi，初始时xi在上方，yi在下方。

## 输出格式

一个整数，表示所需的最少翻转次数。若无法达到目的，输出-1。

## 样例 #1

### 输入

```
2
4 2
6 4

```

### 输出

```
0

```

## 样例 #2

### 输入

```
1
2 3

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
3
1 4
2 3
4 4

```

### 输出

```
1

```



---

---
title: "Vasya and Digital Root"
layout: "post"
diff: 普及-
pid: CF355A
tag: []
---

# Vasya and Digital Root

## 题目描述

Vasya has recently found out what a digital root of a number is and he decided to share his knowledge with you.

Let's assume that $ S(n) $ is the sum of digits of number $ n $ , for example, $ S(4098)=4+0+9+8=21 $ . Then the digital root of number $ n $ equals to:

1. $ dr(n)=S(n) $ , if $ S(n)&lt;10 $ ;
2. $ dr(n)=dr(S(n)) $ , if $ S(n)>=10 $ .

For example, $ dr(4098)=dr(21)=3 $ .

Vasya is afraid of large numbers, so the numbers he works with are at most $ 10^{1000} $ . For all such numbers, he has proved that $ dr(n)=S(S(S(S(n)))) $ $ (n<=10^{1000}) $ .

Now Vasya wants to quickly find numbers with the given digital root. The problem is, he hasn't learned how to do that and he asked you to help him. You task is, given numbers $ k $ and $ d $ , find the number consisting of exactly $ k $ digits (the leading zeroes are not allowed), with digital root equal to $ d $ , or else state that such number does not exist.

## 输入格式

The first line contains two integers $ k $ and $ d $ $ (1<=k<=1000; 0<=d<=9) $ .

## 输出格式

In a single line print either any number that meets the requirements (without the leading zeroes) or "No solution" (without the quotes), if the corresponding number does not exist.

The chosen number must consist of exactly $ k $ digits. We assume that number 0 doesn't contain any leading zeroes.

## 说明/提示

For the first test sample $ dr(5881)=dr(22)=4 $ .

For the second test sample $ dr(36172)=dr(19)=dr(10)=1 $ .

## 样例 #1

### 输入

```
4 4

```

### 输出

```
5881

```

## 样例 #2

### 输入

```
5 1

```

### 输出

```
36172

```

## 样例 #3

### 输入

```
1 0

```

### 输出

```
0

```



---

---
title: "Group of Students"
layout: "post"
diff: 普及-
pid: CF357A
tag: []
---

# Group of Students

## 题目描述

有一些学生考了试，他们在考试中获得了$1$~$m$的分数，获得 i 分的有 $C_i$人。\
你需要求出一个分数线，满足低于分数线的人数和高于分数线(含)的人数均在$[x,y]$范围之内

## 输入格式

------------
第一行一个整数，$m$\
第二行$m$个整数，为$C_1$~$C_m$
第三行两个整数$x,y$

## 输出格式

------------
输出分数线，特别的，若没有满足要求的分数线，输出0

## 样例 #1

### 输入

```
5
3 4 3 2 1
6 8

```

### 输出

```
3

```

## 样例 #2

### 输入

```
5
0 3 3 4 2
3 10

```

### 输出

```
4

```

## 样例 #3

### 输入

```
2
2 5
3 6

```

### 输出

```
0

```



---

---
title: "Flag Day"
layout: "post"
diff: 普及-
pid: CF357B
tag: []
---

# Flag Day

## 题目描述

In Berland, there is the national holiday coming — the Flag Day. In the honor of this event the president of the country decided to make a big dance party and asked your agency to organize it. He has several conditions:

- overall, there must be $ m $ dances;
- exactly three people must take part in each dance;
- each dance must have one dancer in white clothes, one dancer in red clothes and one dancer in blue clothes (these are the colors of the national flag of Berland).

The agency has $ n $ dancers, and their number can be less than $ 3m $ . That is, some dancers will probably have to dance in more than one dance. All of your dancers must dance on the party. However, if some dance has two or more dancers from a previous dance, then the current dance stops being spectacular. Your agency cannot allow that to happen, so each dance has at most one dancer who has danced in some previous dance.

You considered all the criteria and made the plan for the $ m $ dances: each dance had three dancers participating in it. Your task is to determine the clothes color for each of the $ n $ dancers so that the President's third condition fulfilled: each dance must have a dancer in white, a dancer in red and a dancer in blue. The dancers cannot change clothes between the dances.

## 输入格式

The first line contains two space-separated integers $ n $ ( $ 3<=n<=10^{5} $ ) and $ m $ ( $ 1<=m<=10^{5} $ ) — the number of dancers and the number of dances, correspondingly. Then $ m $ lines follow, describing the dances in the order of dancing them. The $ i $ -th line contains three distinct integers — the numbers of the dancers that take part in the $ i $ -th dance. The dancers are numbered from $ 1 $ to $ n $ . Each dancer takes part in at least one dance.

## 输出格式

Print $ n $ space-separated integers: the $ i $ -th number must represent the color of the $ i $ -th dancer's clothes ( $ 1 $ for white, $ 2 $ for red, $ 3 $ for blue). If there are multiple valid solutions, print any of them. It is guaranteed that at least one solution exists.

## 样例 #1

### 输入

```
7 3
1 2 3
1 4 5
4 6 7

```

### 输出

```
1 2 3 3 2 2 1 

```

## 样例 #2

### 输入

```
9 3
3 6 9
2 5 8
1 4 7

```

### 输出

```
1 1 1 2 2 2 3 3 3 

```

## 样例 #3

### 输入

```
5 2
4 1 5
3 1 2

```

### 输出

```
2 3 1 1 3 

```



---

---
title: "Warehouse"
layout: "post"
diff: 普及-
pid: CF35B
tag: []
---

# Warehouse

## 题目描述

**注意：需要文件输入输出，输入文件为 input.txt，输出文件为 output.txt**

仓库里有一个高为 $n$，宽为 $m$ 的架子，即 $n \times m$ 的一个架子。DravDe 会进行 $k$ 次操作，每次操作他会往这个架子上的一个位置放进或拿出一个箱子。

如果 DravDe 要放一个箱子，他会先看这个位置上是不是已经有箱子了，如果有则放入右边的位置；如果右边也有箱子，则以此类推。如果到了此行的第 $m$ 列还有箱子，他会放入下一行的第一列，并重复上述操作。如果到最后都找不到，他会把箱子丢掉，不放到架子上。

如果 DravDe 要拿出一个箱子，你需要输出这个箱子所在的坐标 $(i,j)$，表示这个箱子被放在了第 $i$ 行第 $j$ 列，并拿走它。**这个箱子可能不存在**。

## 输入格式

第一行三个整数 $n,m,k$，意义如题面描述。

接下来 $k$ 行，每行表示一个操作，操作有 $2$ 种形式：

**+1 x y d**：在第 $x$ 行第 $y$ 列放入一个名为 $id$ 的箱子，放置规则如题意；

**-1 id**：拿走名为 $id$ 的箱子，此操作需要你输出这个箱子所在位置坐标，如果没有则输出 **-1 -1**。

## 输出格式

对于每一个操作 $2$，输出这个箱子位置的横坐标和纵坐标，横坐标和纵坐标之间用一个空格隔开。

$1 \leq n,m \leq 30,1 \leq k \leq 2000,1 \leq x \leq n,1 \leq y \leq m$，$id$ 为长度不超过 $10$ 的小写拉丁文字母串。

## 样例 #1

### 输入

```
2 2 9
+1 1 1 cola
+1 1 1 fanta
+1 1 1 sevenup
+1 1 1 whitekey
-1 cola
-1 fanta
-1 sevenup
-1 whitekey
-1 cola

```

### 输出

```
1 1
1 2
2 1
2 2
-1 -1

```

## 样例 #2

### 输入

```
2 2 8
+1 1 1 cola
-1 cola
+1 1 1 fanta
-1 fanta
+1 1 1 sevenup
-1 sevenup
+1 1 1 whitekey
-1 whitekey

```

### 输出

```
1 1
1 1
1 1
1 1

```



---

---
title: "Animals"
layout: "post"
diff: 普及-
pid: CF35D
tag: []
---

# Animals

## 题目描述

Once upon a time DravDe, an outstanding person famous for his professional achievements (as you must remember, he works in a warehouse storing Ogudar-Olok, a magical but non-alcoholic drink) came home after a hard day. That day he had to drink 9875 boxes of the drink and, having come home, he went to bed at once.

DravDe dreamt about managing a successful farm. He dreamt that every day one animal came to him and asked him to let it settle there. However, DravDe, being unimaginably kind, could send the animal away and it went, rejected. There were exactly $ n $ days in DravDe’s dream and the animal that came on the $ i $ -th day, ate exactly $ c_{i} $ tons of food daily starting from day $ i $ . But if one day the animal could not get the food it needed, it got really sad. At the very beginning of the dream there were exactly $ X $ tons of food on the farm.

DravDe woke up terrified...

When he retold the dream to you, he couldn’t remember how many animals were on the farm by the end of the $ n $ -th day any more, but he did remember that nobody got sad (as it was a happy farm) and that there was the maximum possible amount of the animals. That’s the number he wants you to find out.

It should be noticed that the animals arrived in the morning and DravDe only started to feed them in the afternoon, so that if an animal willing to join them is rejected, it can’t eat any farm food. But if the animal does join the farm, it eats daily from that day to the $ n $ -th.

## 输入格式

The first input line contains integers $ n $ and $ X $ ( $ 1<=n<=100,1<=X<=10^{4} $ ) — amount of days in DravDe’s dream and the total amount of food (in tons) that was there initially. The second line contains integers $ c_{i} $ ( $ 1<=c_{i}<=300 $ ). Numbers in the second line are divided by a space.

## 输出格式

Output the only number — the maximum possible amount of animals on the farm by the end of the $ n $ -th day given that the food was enough for everybody.

## 说明/提示

Note to the first example: DravDe leaves the second and the third animal on the farm. The second animal will eat one ton of food on the second day and one ton on the third day. The third animal will eat one ton of food on the third day.

## 样例 #1

### 输入

```
3 4
1 1 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3 6
1 1 1

```

### 输出

```
3

```



---

---
title: "Levko and Table"
layout: "post"
diff: 普及-
pid: CF361A
tag: []
---

# Levko and Table

## 题目描述

Levko loves tables that consist of $ n $ rows and $ n $ columns very much. He especially loves beautiful tables. A table is beautiful to Levko if the sum of elements in each row and column of the table equals $ k $ .

Unfortunately, he doesn't know any such table. Your task is to help him to find at least one of them.

## 输入格式

The single line contains two integers, $ n $ and $ k $ ( $ 1<=n<=100 $ , $ 1<=k<=1000 $ ).

## 输出格式

Print any beautiful table. Levko doesn't like too big numbers, so all elements of the table mustn't exceed $ 1000 $ in their absolute value.

If there are multiple suitable tables, you are allowed to print any of them.

## 说明/提示

In the first sample the sum in the first row is $ 1+3=4 $ , in the second row — $ 3+1=4 $ , in the first column — $ 1+3=4 $ and in the second column — $ 3+1=4 $ . There are other beautiful tables for this sample.

In the second sample the sum of elements in each row and each column equals $ 7 $ . Besides, there are other tables that meet the statement requirements.

## 样例 #1

### 输入

```
2 4

```

### 输出

```
1 3
3 1

```

## 样例 #2

### 输入

```
4 7

```

### 输出

```
2 1 0 4
4 0 2 1
1 3 3 0
0 3 2 2

```



---

---
title: "Petya and Staircases"
layout: "post"
diff: 普及-
pid: CF362B
tag: []
---

# Petya and Staircases

## 题目描述

有很多级台阶，皮特想走过他们，有的台阶很脏，所以他不想踏上去。他一次可以跨过 **1 或 2 级** 台阶，也可以只走到上一级，而不跨过台阶。现在他在第一级台阶，他要到第 $n$ 级台阶上，问是否能在不踏上脏台阶的情况下做到。



注意：皮特一定会踏上第一个和最后一个台阶，所以如果第一个或最后一个台阶是脏的，那么皮特一定会踏上脏台阶。

## 输入格式

第一行两个整数 $n$ 和 $m$ ，表示有 $n$ 级台阶，和 $m$ 级脏的台阶，接下来是 $m$ 级脏台阶的编号。

## 输出格式

如果皮特在不踏上脏台阶的情况下也能到第 $n$ 级台阶上，输出 ``YES``.



否则输出``NO``.



$( 1<=n<=10^{9},0<=m<=3000 ) $

## 样例 #1

### 输入

```
10 5
2 4 8 3 6

```

### 输出

```
NO
```

## 样例 #2

### 输入

```
10 5
2 4 5 7 9

```

### 输出

```
YES
```



---

---
title: "Fence"
layout: "post"
diff: 普及-
pid: CF363B
tag: []
---

# Fence

## 题目描述

There is a fence in front of Polycarpus's home. The fence consists of $ n $ planks of the same width which go one after another from left to right. The height of the $ i $ -th plank is $ h_{i} $ meters, distinct planks can have distinct heights.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF363B/89891f9a8aa0dbd268db12cc4f373a8fc8629b6b.png)Fence for $ n=7 $ and $ h=[1,2,6,1,1,7,1] $ Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly $ k $ consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such $ k $ consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of $ k $ consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).

## 输入格式

The first line of the input contains integers $ n $ and $ k $ ( $ 1<=n<=1.5·10^{5},1<=k<=n $ ) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers $ h_{1},h_{2},...,h_{n} $ ( $ 1<=h_{i}<=100 $ ), where $ h_{i} $ is the height of the $ i $ -th plank of the fence.

## 输出格式

Print such integer $ j $ that the sum of the heights of planks $ j $ , $ j+1 $ , ..., $ j+k-1 $ is the minimum possible. If there are multiple such $ j $ 's, print any of them.

## 说明/提示

In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.

## 样例 #1

### 输入

```
7 3
1 2 6 1 1 7 1

```

### 输出

```
3

```



---

---
title: "Good Number"
layout: "post"
diff: 普及-
pid: CF365A
tag: []
---

# Good Number

## 题目描述

Let's call a number $ k $ -good if it contains all digits not exceeding $ k $ ( $ 0,...,k $ ). You've got a number $ k $ and an array $ a $ containing $ n $ numbers. Find out how many $ k $ -good numbers are in $ a $ (count each number every time it occurs in array $ a $ ).

## 输入格式

The first line contains integers $ n $ and $ k $ ( $ 1<=n<=100 $ , $ 0<=k<=9 $ ). The $ i $ -th of the following $ n $ lines contains integer $ a_{i} $ without leading zeroes ( $ 1<=a_{i}<=10^{9} $ ).

## 输出格式

Print a single integer — the number of $ k $ -good numbers in $ a $ .

## 样例 #1

### 输入

```
10 6
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560

```

### 输出

```
10

```

## 样例 #2

### 输入

```
2 1
1
10

```

### 输出

```
1

```



---

---
title: "The Fibonacci Segment"
layout: "post"
diff: 普及-
pid: CF365B
tag: []
---

# The Fibonacci Segment

## 题目描述

你得到了一个数组 $a_1,a_2,\dots,a_n$。区间 $[l,r]$被称为**好的**，仅当对于每一个 $i$ $(l + 2 \leq i\leq r)$，都满足 $a_i = a_{i-1} + a_{i - 2}$。

定义区间 $[l,r]$ 的长度 $len([l,r])$ 为 $r - l + 1$，区间 $[l_1,r_1]$ 比 区间 $[l_2,r_2]$ 更长，仅当 $len([l_1,r_1]) \gt len([l_2,r_2])$。

你要求出在数组 $a$ 中最长的好的区间。

注意，一个长度为 $1$ 或 $2$ 的区间总是好的。

## 输入格式

第一行是一个正整数 $n$ $(1\leq n \leq 10^5)$，表示数组 $a$ 的长度。

第二行是 $n$ 个整数，表示 $a_1,a_2,\dots,a_n$ $(0 \leq a_i \leq 10^9)$。

## 输出格式

输出数组 $a$ 中最长的好的区间的长度。

Translate By @LaDeX

## 样例 #1

### 输入

```
10
1 2 3 5 8 13 21 34 55 89

```

### 输出

```
10

```

## 样例 #2

### 输入

```
5
1 1 1 1 1

```

### 输出

```
2

```



---

---
title: "Sereja and Coat Rack"
layout: "post"
diff: 普及-
pid: CF368A
tag: []
---

# Sereja and Coat Rack

## 题目描述

Sereja owns a restaurant for $ n $ people. The restaurant hall has a coat rack with $ n $ hooks. Each restaurant visitor can use a hook to hang his clothes on it. Using the $ i $ -th hook costs $ a_{i} $ rubles. Only one person can hang clothes on one hook.

Tonight Sereja expects $ m $ guests in the restaurant. Naturally, each guest wants to hang his clothes on an available hook with minimum price (if there are multiple such hooks, he chooses any of them). However if the moment a guest arrives the rack has no available hooks, Sereja must pay a $ d $ ruble fine to the guest.

Help Sereja find out the profit in rubles (possibly negative) that he will get tonight. You can assume that before the guests arrive, all hooks on the rack are available, all guests come at different time, nobody besides the $ m $ guests is visiting Sereja's restaurant tonight.

## 输入格式

The first line contains two integers $ n $ and $ d $ $ (1<=n,d<=100) $ . The next line contains integers $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{n} $ $ (1<=a_{i}<=100) $ . The third line contains integer $ m $ $ (1<=m<=100) $ .

## 输出格式

In a single line print a single integer — the answer to the problem.

## 说明/提示

In the first test both hooks will be used, so Sereja gets $ 1+2=3 $ rubles.

In the second test both hooks will be used but Sereja pays a fine $ 8 $ times, so the answer is $ 3-8=-5 $ .

## 样例 #1

### 输入

```
2 1
2 1
2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
2 1
2 1
10

```

### 输出

```
-5

```



---

---
title: "Sereja and Suffixes"
layout: "post"
diff: 普及-
pid: CF368B
tag: []
---

# Sereja and Suffixes

## 题目描述

Sereja has an array $ a $ , consisting of $ n $ integers $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{n} $ . The boy cannot sit and do nothing, he decided to study an array. Sereja took a piece of paper and wrote out $ m $ integers $ l_{1},l_{2},...,l_{m} $ $ (1<=l_{i}<=n) $ . For each number $ l_{i} $ he wants to know how many distinct numbers are staying on the positions $ l_{i} $ , $ l_{i}+1 $ , ..., $ n $ . Formally, he want to find the number of distinct numbers among $ a_{li},a_{li}+1,...,a_{n} $ .?

Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time. Help him, find the answer for the described question for each $ l_{i} $ .

## 输入格式

The first line contains two integers $ n $ and $ m $ $ (1<=n,m<=10^{5}) $ . The second line contains $ n $ integers $ a_{1} $ , $ a_{2} $ , $ ... $ , $ a_{n} $ $ (1<=a_{i}<=10^{5}) $ — the array elements.

Next $ m $ lines contain integers $ l_{1},l_{2},...,l_{m} $ . The $ i $ -th line contains integer $ l_{i} $ $ (1<=l_{i}<=n) $ .

## 输出格式

Print $ m $ lines — on the $ i $ -th line print the answer to the number $ l_{i} $ .

## 样例 #1

### 输入

```
10 10
1 2 3 4 1 2 3 4 100000 99999
1
2
3
4
5
6
7
8
9
10

```

### 输出

```
6
6
6
6
6
5
4
3
2
1

```



---

---
title: "Valera and Contest"
layout: "post"
diff: 普及-
pid: CF369B
tag: []
---

# Valera and Contest

## 题目描述

Valera loves to participate in competitions. Especially in programming contests. Today he has participated in the contest with his team, consisting of $ n $ students (including Valera). This contest was an individual competition, so each student in the team solved problems individually.

After the contest was over, Valera was interested in results. He found out that:

- each student in the team scored at least $ l $ points and at most $ r $ points;
- in total, all members of the team scored exactly $ s_{all} $ points;
- the total score of the $ k $ members of the team who scored the most points is equal to exactly $ s_{k} $ ; more formally, if $ a_{1},a_{2},...,a_{n} $ is the sequence of points earned by the team of students in the non-increasing order $ (a_{1}>=a_{2}>=...>=a_{n}) $ , then $ s_{k}=a_{1}+a_{2}+...+a_{k} $ .

However, Valera did not find out exactly how many points each of $ n $ students scored. Valera asked you to recover any distribution of scores between the students of the team, such that all the conditions above are met.

## 输入格式

The first line of the input contains exactly six integers $ n,k,l,r,s_{all},s_{k} $ ( $ 1<=n,k,l,r<=1000 $ ; $ l<=r $ ; $ k<=n $ ; $ 1<=s_{k}<=s_{all}<=10^{6} $ ).

It's guaranteed that the input is such that the answer exists.

## 输出格式

Print exactly $ n $ integers $ a_{1},a_{2},...,a_{n} $ — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.

## 样例 #1

### 输入

```
5 3 1 3 13 9

```

### 输出

```
2 3 2 3 3 
```

## 样例 #2

### 输入

```
5 3 1 3 15 9

```

### 输出

```
3 3 3 3 3 
```



---

---
title: "K-Periodic Array"
layout: "post"
diff: 普及-
pid: CF371A
tag: []
---

# K-Periodic Array

## 题目描述

This task will exclusively concentrate only on the arrays where all elements equal 1 and/or 2.

Array $ a $ is $ k $ -period if its length is divisible by $ k $ and there is such array $ b $ of length $ k $ , that $ a $ is represented by array $ b $ written exactly ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF371A/53488bbee46df1b241cbadadd932aea80891152b.png) times consecutively. In other words, array $ a $ is $ k $ -periodic, if it has period of length $ k $ .

For example, any array is $ n $ -periodic, where $ n $ is the array length. Array $ [2,1,2,1,2,1] $ is at the same time 2-periodic and 6-periodic and array $ [1,2,1,1,2,1,1,2,1] $ is at the same time 3-periodic and 9-periodic.

For the given array $ a $ , consisting only of numbers one and two, find the minimum number of elements to change to make the array $ k $ -periodic. If the array already is $ k $ -periodic, then the required value equals $ 0 $ .

## 输入格式

The first line of the input contains a pair of integers $ n $ , $ k $ ( $ 1<=k<=n<=100) $ , where $ n $ is the length of the array and the value $ n $ is divisible by $ k $ . The second line contains the sequence of elements of the given array $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=2 $ ), $ a_{i} $ is the $ i $ -th element of the array.

## 输出格式

Print the minimum number of array elements we need to change to make the array $ k $ -periodic. If the array already is $ k $ -periodic, then print 0.

## 说明/提示

In the first sample it is enough to change the fourth element from 2 to 1, then the array changes to $ [2,1,2,1,2,1] $ .

In the second sample, the given array already is 4-periodic.

In the third sample it is enough to replace each occurrence of number two by number one. In this case the array will look as $ [1,1,1,1,1,1,1,1,1] $ — this array is simultaneously 1-, 3- and 9-periodic.

## 样例 #1

### 输入

```
6 2
2 1 2 2 2 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
8 4
1 1 2 1 1 1 2 1

```

### 输出

```
0

```

## 样例 #3

### 输入

```
9 3
2 1 1 1 2 1 1 1 2

```

### 输出

```
3

```



---

---
title: "Fox Dividing Cheese"
layout: "post"
diff: 普及-
pid: CF371B
tag: []
---

# Fox Dividing Cheese

## 题目描述

两头贪心的小熊有 a，b 两块蛋糕，他们都想要大的那一块的那一块。于是狡猾的狐狸提出一个方案：让狐狸吃掉一些蛋糕，最后使得两块蛋糕大小一样。假如这块蛋糕的重量是 2 的倍数，那么狐狸可以吃掉二分之一；假如蛋糕的重量是 3 的倍数，那么狐狸可以吃掉三分之二；假如蛋糕的重量是 5 的倍数，狐狸可以吃掉五分之四。为了不让狐狸吃掉太多，熊要求以最少的次数将两块蛋糕吃的大小一样，求最小次数。

## 输入格式

第一行输入两个整数 $a，b$ ($1 \le a,b \le 10^9$)。

## 输出格式

若有可分方案，输出最小次数，若无可分方案，输出 `-1`。

## 样例 #1

### 输入

```
15 20

```

### 输出

```
3

```

## 样例 #2

### 输入

```
14 8

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
6 6

```

### 输出

```
0

```



---

---
title: "Collecting Beats is Fun"
layout: "post"
diff: 普及-
pid: CF373A
tag: []
---

# Collecting Beats is Fun

## 题目描述

Cucumber boy is fan of Kyubeat, a famous music game.

Kyubeat has $ 16 $ panels for playing arranged in $ 4×4 $ table. When a panel lights up, he has to press that panel.

Each panel has a timing to press (the preffered time when a player should press it), and Cucumber boy is able to press at most $ k $ panels in a time with his one hand. Cucumber boy is trying to press all panels in perfect timing, that is he wants to press each panel exactly in its preffered time. If he cannot press the panels with his two hands in perfect timing, his challenge to press all the panels in perfect timing will fail.

You are given one scene of Kyubeat's panel from the music Cucumber boy is trying. Tell him is he able to press all the panels in perfect timing.

## 输入格式

The first line contains a single integer $ k $ ( $ 1<=k<=5 $ ) — the number of panels Cucumber boy can press with his one hand.

Next 4 lines contain 4 characters each (digits from 1 to 9, or period) — table of panels. If a digit $ i $ was written on the panel, it means the boy has to press that panel in time $ i $ . If period was written on the panel, he doesn't have to press that panel.

## 输出格式

Output "YES" (without quotes), if he is able to press all the panels in perfect timing. If not, output "NO" (without quotes).

## 说明/提示

In the third sample boy cannot press all panels in perfect timing. He can press all the panels in timing in time 1, but he cannot press the panels in time 2 in timing with his two hands.

## 样例 #1

### 输入

```
1
.135
1247
3468
5789

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
5
..1.
1111
..1.
..1.

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
1
....
12.1
.2..
.2..

```

### 输出

```
NO

```



---

---
title: "Lever"
layout: "post"
diff: 普及-
pid: CF376A
tag: []
---

# Lever

## 题目描述

你有一根杠杆，用一个字符串s表示（$3≤|s|≤10^{6}$）。

若字符串的下标为i的字符为“^”，则表示杠杆的支点的坐标为i；

若字符串的下标为i的字符为“=”，则表示坐标为i的位置没有任何东西；

若字符串的下标为i的字符为一个数字c（$1≤c≤9$），则表示在坐标为i处，有一个质量为c的重物挂在杠杆上。

杠杆一开始是平衡的，杠杆自重忽略不计。

你的任务是判断这根杠杆的状态（平衡、向左倾斜或向右倾斜）。

注意，本题需要使用64位整型。

## 输入格式

一行，一个字符串s。

保证字符串中只包含一个“^”，保证杠杆的支点不位于杠杆的任何一端。

## 输出格式

若杠杆平衡，则输出“balance”；

若杠杆向左倾斜，则输出“left”；

若杠杆向右倾斜，则输出“right”。

## 样例 #1

### 输入

```
=^==

```

### 输出

```
balance

```

## 样例 #2

### 输入

```
9===^==1

```

### 输出

```
left

```

## 样例 #3

### 输入

```
2==^7==

```

### 输出

```
right

```

## 样例 #4

### 输入

```
41^52==

```

### 输出

```
balance

```



---

---
title: "I.O.U."
layout: "post"
diff: 普及-
pid: CF376B
tag: []
---

# I.O.U.

## 题目描述

Imagine that there is a group of three friends: A, B and С. A owes B 20 rubles and B owes C 20 rubles. The total sum of the debts is 40 rubles. You can see that the debts are not organized in a very optimal manner. Let's rearrange them like that: assume that A owes C 20 rubles and B doesn't owe anything to anybody. The debts still mean the same but the total sum of the debts now equals 20 rubles.

This task is a generalisation of a described example. Imagine that your group of friends has $ n $ people and you know the debts between the people. Optimize the given debts without changing their meaning. In other words, finally for each friend the difference between the total money he should give and the total money he should take must be the same. Print the minimum sum of all debts in the optimal rearrangement of the debts. See the notes to the test samples to better understand the problem.

## 输入格式

The first line contains two integers $ n $ and $ m $ $ (1<=n<=100; 0<=m<=10^{4}) $ . The next $ m $ lines contain the debts. The $ i $ -th line contains three integers $ a_{i},b_{i},c_{i} $ $ (1<=a_{i},b_{i}<=n; a_{i}≠b_{i}; 1<=c_{i}<=100) $ , which mean that person $ a_{i} $ owes person $ b_{i} $ $ c_{i} $ rubles.

Assume that the people are numbered by integers from 1 to $ n $ .

It is guaranteed that the same pair of people occurs at most once in the input. The input doesn't simultaneously contain pair of people $ (x,y) $ and pair of people $ (y,x) $ .

## 输出格式

Print a single integer — the minimum sum of debts in the optimal rearrangement.

## 说明/提示

In the first sample, you can assume that person number 1 owes 8 rubles to person number 2, 1 ruble to person number 3 and 1 ruble to person number 4. He doesn't owe anybody else anything. In the end, the total debt equals 10.

In the second sample, there are no debts.

In the third sample, you can annul all the debts.

## 样例 #1

### 输入

```
5 3
1 2 10
2 3 1
2 4 1

```

### 输出

```
10

```

## 样例 #2

### 输入

```
3 0

```

### 输出

```
0

```

## 样例 #3

### 输入

```
4 3
1 2 1
2 3 1
3 1 1

```

### 输出

```
0

```



---

---
title: "Playing with Dice"
layout: "post"
diff: 普及-
pid: CF378A
tag: []
---

# Playing with Dice

## 题目描述

两个人正在玩游戏。每人写一个 1~6 之间的数，然后掷骰子。写下的数字和骰子上的数最接近的那个人获胜。如果两个人写的数和骰子上的数差距都是一样的，那么是平局。

第一个人写的数是 a，第二个人写的数是 b。
请分别输出第一个人赢、平局、第二个人赢有多少种可能（方法数）。

## 输入格式

一行两个数 a 和 b (1<=a,b<=6)。
表示两个人写下的数。

## 输出格式

一行三个数，用空格分隔。
分别表示第一个人赢、平局、第二个人赢的方法数。

## 说明/提示

骰子是一个正方体。每个面上有 1~6 的数字。

当 $| a-x | < | b-x |$ 时，可以说 a 比 b 更接近 x。

## 样例 #1

### 输入

```
2 5

```

### 输出

```
3 0 3

```

## 样例 #2

### 输入

```
2 4

```

### 输出

```
2 1 3

```



---

---
title: "Semifinals"
layout: "post"
diff: 普及-
pid: CF378B
tag: []
---

# Semifinals

## 题目描述

在跑步比赛中，两场半决赛刚刚结束。每场半决赛有 $n$ 名选手参加。一共有 $n$ 名选手能够晋级决赛。晋级规则如下：对于每场半决赛，前 $k$（$0 \le 2 k \le n$）名选手能够直接晋级决赛；对于其余选手，前 $n − 2 k$ 名选手晋级决赛。

现在 $k$ 还没有公布，每名选手都想知道他能否晋级。

## 输入格式

第一行一个整数 $n$（$1 \le n \le {10}^5$），表示每场半决赛的人数。

接下来 $n$ 行，每行两个整数 $a_i, b_i$（$1 \le a_i, b_i \le {10}^9$），表示两组半决赛中第 $i$ 名选手的成绩（跑的时间）。所有成绩保证各不相同，且 $a_1, a_2, \ldots, a_n$ 和 $b_1, b_2, \ldots, b_n$ 均为升序。

## 输出格式

输出共两行，均为长度为 $n$ 的 $01$ 串，代表两组半决赛的选手是否能晋级。其中第一行对应 $a$ 数组的选手，第二行对应 $b$ 数组的选手。

每一行的第 $i$ 个字符如果为 `1`，表示这一组的第 $i$ 名有机会晋级，如果为 `0`，表示他没有机会晋级。

**【样例解释】**

第一组半决赛每名选手的成绩分别为 9840, 9860, 9930, 10040

第二组半决赛每名选手成绩为 9920, 9980, 10020, 10090。

当 $k=0$ 时，成绩为 $9840, 9860, 9920, 9930$ 的选手晋级

当 $k=1$ 时，每组第一名（$9840$ 和 $9920$）晋级，其余选手中 $9860$ 和 $9930$ 晋级。

当 $k=2$ 时，每组前两名（$9840, 9860$ 和 $9920$，$9980$）晋级。

## 样例 #1

### 输入

```
4
9840 9920
9860 9980
9930 10020
10040 10090

```

### 输出

```
1110
1100

```

## 样例 #2

### 输入

```
4
9900 9850
9940 9930
10000 10020
10060 10110

```

### 输出

```
1100
1100

```



---

---
title: "Sereja and Stairs"
layout: "post"
diff: 普及-
pid: CF381B
tag: []
---

# Sereja and Stairs

## 题目描述

Sereja loves integer sequences very much. He especially likes stairs.

Sequence $ a_{1},a_{2},...,a_{|a|} $ ( $ |a| $ is the length of the sequence) is stairs if there is such index $ i $ $ (1<=i<=|a|) $ , that the following condition is met:

 $ a_{1}&lt;a_{2}&lt;...&lt;a_{i-1}&lt;a_{i}&gt;a_{i+1}&gt;...&gt;a_{|a|-1}&gt;a_{|a|}. $ For example, sequences \[1, 2, 3, 2\] and \[4, 2\] are stairs and sequence \[3, 1, 2\] isn't.

Sereja has $ m $ cards with numbers. He wants to put some cards on the table in a row to get a stair sequence. What maximum number of cards can he put on the table?

## 输入格式

The first line contains integer $ m $ $ (1<=m<=10^{5}) $ — the number of Sereja's cards. The second line contains $ m $ integers $ b_{i} $ $ (1<=b_{i}<=5000) $ — the numbers on the Sereja's cards.

## 输出格式

In the first line print the number of cards you can put on the table. In the second line print the resulting stairs.

## 样例 #1

### 输入

```
5
1 2 3 4 5

```

### 输出

```
5
5 4 3 2 1

```

## 样例 #2

### 输入

```
6
1 1 2 2 3 3

```

### 输出

```
5
1 2 3 2 1

```



---

---
title: "Ksenia and Pan Scales"
layout: "post"
diff: 普及-
pid: CF382A
tag: []
---

# Ksenia and Pan Scales

## 题目描述

Ksenia has ordinary pan scales and several weights of an equal mass. Ksenia has already put some weights on the scales, while other weights are untouched. Ksenia is now wondering whether it is possible to put all the remaining weights on the scales so that the scales were in equilibrium.

The scales is in equilibrium if the total sum of weights on the left pan is equal to the total sum of weights on the right pan.

## 输入格式

The first line has a non-empty sequence of characters describing the scales. In this sequence, an uppercase English letter indicates a weight, and the symbol "|" indicates the delimiter (the character occurs in the sequence exactly once). All weights that are recorded in the sequence before the delimiter are initially on the left pan of the scale. All weights that are recorded in the sequence after the delimiter are initially on the right pan of the scale.

The second line contains a non-empty sequence containing uppercase English letters. Each letter indicates a weight which is not used yet.

It is guaranteed that all the English letters in the input data are different. It is guaranteed that the input does not contain any extra characters.

## 输出格式

If you cannot put all the weights on the scales so that the scales were in equilibrium, print string "Impossible". Otherwise, print the description of the resulting scales, copy the format of the input.

If there are multiple answers, print any of them.

## 样例 #1

### 输入

```
AC|T
L

```

### 输出

```
AC|TL

```

## 样例 #2

### 输入

```
|ABC
XYZ

```

### 输出

```
XYZ|ABC

```

## 样例 #3

### 输入

```
W|T
F

```

### 输出

```
Impossible

```

## 样例 #4

### 输入

```
ABC|
D

```

### 输出

```
Impossible

```



---

---
title: "Coder"
layout: "post"
diff: 普及-
pid: CF384A
tag: []
---

# Coder

## 题目描述

Iahub 很喜欢下棋。他甚至发明了一种棋子叫做 "Coder"。

一个 Coder 可以攻击与它相邻的格子中的棋子（水平和竖直方向）。如果一个 Coder 在坐标 $(x,y)$上，它可以攻击 $(x+1,y)$ , $(x-1,y)$ , $(x,y+1)$ , $(x,y-1)$ 这四个格子。

Iahub 想要知道有多少个 Coder 可以被放在 $n*n$
 的棋盘中，使得任意两个 Coder 都不能互相攻击。

## 输入格式

一行一个数 $n$ ，表示棋盘的大小。

## 输出格式

第一行一个数，表示最多可以放几个 Coder。

接下来一个 $n*n$ 的字符矩阵，每个位置是 `c` 或 `.` ，分别表示这个位置放与不放棋子。

如果有多个解，随意输出一个解即可。

## 样例 #1

### 输入

```
2

```

### 输出

```
2
C.
.C

```



---

---
title: "Bear and Raspberry"
layout: "post"
diff: 普及-
pid: CF385A
tag: []
---

# Bear and Raspberry

## 题目描述

给定一个序列，请求出相邻两个数之间（前数$-$后数）差的最大值与$c$的差。

如果结果小于$0$的话就输出$0$。

## 输入格式

第一行输入$n$和$c$。

接下来一行$n$个数字，描述整个序列。

## 输出格式

输出一行表示结果。

## 样例 #1

### 输入

```
5 1
5 10 7 3 20

```

### 输出

```
3

```

## 样例 #2

### 输入

```
6 2
100 1 10 40 10 40

```

### 输出

```
97

```

## 样例 #3

### 输入

```
3 0
1 2 3

```

### 输出

```
0

```



---

---
title: "George and Sleep"
layout: "post"
diff: 普及-
pid: CF387A
tag: []
---

# George and Sleep

## 题目描述

给出一个时间点 $s$ 和一个时间段 $t$，求出从时间点 $s$ 向前回推时间段 $t$ 得到的时间点 $p$。（所有时间用 `HH:MM` 的格式表示）

## 输入格式

共两行，每行为一个格式为 `HH:MM` 的字符串，分别表示时间点 $s$ 和时间段 $t$。

## 输出格式

共一行，为一个格式为 `HH:MM` 的字符串，表示你得到的时间点 $p$。

## 说明/提示

对于 $100\%$ 的数据，$0\le \text{HH}\le 23$，$0\le \text{MM}\le 59$。

时间点 $s$ 和时间点 $p$ 可能不在同一天。

## 样例 #1

### 输入

```
05:50
05:44

```

### 输出

```
00:06

```

## 样例 #2

### 输入

```
00:00
01:00

```

### 输出

```
23:00

```

## 样例 #3

### 输入

```
00:01
00:00

```

### 输出

```
00:01

```



---

---
title: "George and Round"
layout: "post"
diff: 普及-
pid: CF387B
tag: []
---

# George and Round

## 题目描述

George decided to prepare a Codesecrof round, so he has prepared $ m $ problems for the round. Let's number the problems with integers $ 1 $ through $ m $ . George estimates the $ i $ -th problem's complexity by integer $ b_{i} $ .

To make the round good, he needs to put at least $ n $ problems there. Besides, he needs to have at least one problem with complexity exactly $ a_{1} $ , at least one with complexity exactly $ a_{2} $ , ..., and at least one with complexity exactly $ a_{n} $ . Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity $ c $ to any positive integer complexity $ d $ ( $ c>=d $ ), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the $ m $ he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1<=n,m<=3000 $ ) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{1}&lt;a_{2}&lt;...&lt;a_{n}<=10^{6} $ ) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers $ b_{1},b_{2},...,b_{m} $ ( $ 1<=b_{1}<=b_{2}...<=b_{m}<=10^{6} $ ) — the complexities of the problems prepared by George.

## 输出格式

Print a single integer — the answer to the problem.

## 说明/提示

In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities $ 2 $ and $ 3 $ to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: $ 2,3,4 $ .

## 样例 #1

### 输入

```
3 5
1 2 3
1 2 2 3 3

```

### 输出

```
0

```

## 样例 #2

### 输入

```
3 5
1 2 3
1 1 1 1 1

```

### 输出

```
2

```

## 样例 #3

### 输入

```
3 1
2 3 4
1

```

### 输出

```
3

```



---

---
title: "Fox and Cross"
layout: "post"
diff: 普及-
pid: CF389B
tag: []
---

# Fox and Cross

## 题目描述

Fox Ciel has a board with $ n $ rows and $ n $ columns. So, the board consists of $ n×n $ cells. Each cell contains either a symbol '.', or a symbol '\#'.

A cross on the board is a connected set of exactly five cells of the board that looks like a cross. The picture below shows how it looks.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF389B/5ccac31668e0d529fa8a5f9e69b4dcfcf1f3b650.png)Ciel wants to draw several (may be zero) crosses on the board. Each cross must cover exactly five cells with symbols '\#', and any cell with symbol '\#' must belong to some cross. No two crosses can share a cell.

Please, tell Ciel if she can draw the crosses in the described way.

## 输入格式

The first line contains an integer $ n $ ( $ 3<=n<=100 $ ) — the size of the board.

Each of the next $ n $ lines describes one row of the board. The $ i $ -th line describes the $ i $ -th row of the board and consists of $ n $ characters. Each character is either a symbol '.', or a symbol '\#'.

## 输出格式

Output a single line with "YES" if Ciel can draw the crosses in the described way. Otherwise output a single line with "NO".

## 说明/提示

In example 1, you can draw two crosses. The picture below shows what they look like.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF389B/2961c8465879f5caacf5ebd47c02d06b75cd444e.png)In example 2, the board contains 16 cells with '\#', but each cross contains 5. Since 16 is not a multiple of 5, so it's impossible to cover all.

## 样例 #1

### 输入

```
5
.#...
####.
.####
...#.
.....

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
4
####
####
####
####

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
6
.#....
####..
.####.
.#.##.
######
.#..#.

```

### 输出

```
YES

```

## 样例 #4

### 输入

```
6
.#..#.
######
.####.
.####.
######
.#..#.

```

### 输出

```
NO

```

## 样例 #5

### 输入

```
3
...
...
...

```

### 输出

```
YES

```



---

---
title: "Blinds"
layout: "post"
diff: 普及-
pid: CF38C
tag: []
---

# Blinds

## 题目描述

The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are $ n $ blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)

Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)

After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.

Thus, if the blinds consist of $ k $ pieces each $ d $ in length, then they are of form of a rectangle of $ k×d $ bourlemeters.

Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than $ l $ bourlemeter. The window is of form of a rectangle with side lengths as positive integers.

## 输入格式

The first output line contains two space-separated integers $ n $ and $ l $ ( $ 1<=n,l<=100 $ ). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated $ n $ integers $ a_{i} $ . They are the lengths of initial stripes in bourlemeters ( $ 1<=a_{i}<=100 $ ).

## 输出格式

Print the single number — the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number $ 0 $ .

## 说明/提示

In the first sample test the required window is $ 2×4 $ in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.

## 样例 #1

### 输入

```
4 2
1 2 3 4

```

### 输出

```
8

```

## 样例 #2

### 输入

```
5 3
5 5 7 3 1

```

### 输出

```
15

```

## 样例 #3

### 输入

```
2 3
1 2

```

### 输出

```
0

```



---

---
title: "Inna and Alarm Clock"
layout: "post"
diff: 普及-
pid: CF390A
tag: []
---

# Inna and Alarm Clock

## 题目描述

Inna loves sleeping very much, so she needs $ n $ alarm clocks in total to wake up. Let's suppose that Inna's room is a $ 100×100 $ square with the lower left corner at point $ (0,0) $ and with the upper right corner at point $ (100,100) $ . Then the alarm clocks are points with integer coordinates in this square.

The morning has come. All $ n $ alarm clocks in Inna's room are ringing, so Inna wants to turn them off. For that Inna has come up with an amusing game:

- First Inna chooses a type of segments that she will use throughout the game. The segments can be either vertical or horizontal.
- Then Inna makes multiple moves. In a single move, Inna can paint a segment of any length on the plane, she chooses its type at the beginning of the game (either vertical or horizontal), then all alarm clocks that are on this segment switch off. The game ends when all the alarm clocks are switched off.

Inna is very sleepy, so she wants to get through the alarm clocks as soon as possible. Help her, find the minimum number of moves in the game that she needs to turn off all the alarm clocks!

## 输入格式

The first line of the input contains integer $ n $ $ (1<=n<=10^{5}) $ — the number of the alarm clocks. The next $ n $ lines describe the clocks: the $ i $ -th line contains two integers $ x_{i} $ , $ y_{i} $ — the coordinates of the $ i $ -th alarm clock $ (0<=x_{i},y_{i}<=100) $ .

Note that a single point in the room can contain any number of alarm clocks and the alarm clocks can lie on the sides of the square that represents the room.

## 输出格式

In a single line print a single integer — the minimum number of segments Inna will have to draw if she acts optimally.

## 说明/提示

In the first sample, Inna first chooses type "vertical segments", and then she makes segments with ends at : $ (0,0) $ , $ (0,2) $ ; and, for example, $ (1,0) $ , $ (1,1) $ . If she paints horizontal segments, she will need at least 3 segments.

In the third sample it is important to note that Inna doesn't have the right to change the type of the segments during the game. That's why she will need 3 horizontal or 3 vertical segments to end the game.

## 样例 #1

### 输入

```
4
0 0
0 1
0 2
1 0

```

### 输出

```
2

```

## 样例 #2

### 输入

```
4
0 0
0 1
1 0
1 1

```

### 输出

```
2

```

## 样例 #3

### 输入

```
4
1 1
1 2
2 3
3 3

```

### 输出

```
3

```



---

---
title: "Genetic Engineering"
layout: "post"
diff: 普及-
pid: CF391A
tag: []
---

# Genetic Engineering

## 题目描述

You will receive 3 points for solving this problem.

Manao is designing the genetic code for a new type of algae to efficiently produce fuel. Specifically, Manao is focusing on a stretch of DNA that encodes one protein. The stretch of DNA is represented by a string containing only the characters 'A', 'T', 'G' and 'C'.

Manao has determined that if the stretch of DNA contains a maximal sequence of consecutive identical nucleotides that is of even length, then the protein will be nonfunctional. For example, consider a protein described by DNA string "GTTAAAG". It contains four maximal sequences of consecutive identical nucleotides: "G", "TT", "AAA", and "G". The protein is nonfunctional because sequence "TT" has even length.

Manao is trying to obtain a functional protein from the protein he currently has. Manao can insert additional nucleotides into the DNA stretch. Each additional nucleotide is a character from the set {'A', 'T', 'G', 'C'}. Manao wants to determine the minimum number of insertions necessary to make the DNA encode a functional protein.

## 输入格式

The input consists of a single line, containing a string $ s $ of length $ n $ $ (1<=n<=100) $ . Each character of $ s $ will be from the set {'A', 'T', 'G', 'C'}.

This problem doesn't have subproblems. You will get 3 points for the correct submission.

## 输出格式

The program should print on one line a single integer representing the minimum number of 'A', 'T', 'G', 'C' characters that are required to be inserted into the input string in order to make all runs of identical characters have odd length.

## 说明/提示

In the first example, it is sufficient to insert a single nucleotide of any type between the two 'T's in the sequence to restore the functionality of the protein.

## 样例 #1

### 输入

```
GTTAAAG

```

### 输出

```
1

```

## 样例 #2

### 输入

```
AACCAACCAAAAC

```

### 输出

```
5

```



---

---
title: "Counting Sticks"
layout: "post"
diff: 普及-
pid: CF394A
tag: []
---

# Counting Sticks

## 题目描述

When new students come to the Specialized Educational and Scientific Centre (SESC) they need to start many things from the beginning. Sometimes the teachers say (not always unfairly) that we cannot even count. So our teachers decided to teach us arithmetics from the start. And what is the best way to teach students add and subtract? — That's right, using counting sticks! An here's our new task:

An expression of counting sticks is an expression of type:

\[ $ A $ sticks\]\[sign +\]\[ $ B $ sticks\]\[sign =\]\[ $ C $ sticks\] $ (1<=A,B,C) $ . Sign + consists of two crossed sticks: one vertical and one horizontal. Sign = consists of two horizontal sticks. The expression is arithmetically correct if $ A+B=C $ .

We've got an expression that looks like $ A+B=C $ given by counting sticks. Our task is to shift at most one stick (or we can shift nothing) so that the expression became arithmetically correct. Note that we cannot remove the sticks from the expression, also we cannot shift the sticks from the signs + and =.

We really aren't fabulous at arithmetics. Can you help us?

## 输入格式

The single line contains the initial expression. It is guaranteed that the expression looks like $ A+B=C $ , where $ 1<=A,B,C<=100 $ .

## 输出格式

If there isn't a way to shift the stick so the expression becomes correct, print on a single line "Impossible" (without the quotes). If there is a way, print the resulting expression. Follow the format of the output from the test samples. Don't print extra space characters.

If there are multiple correct answers, print any of them. For clarifications, you are recommended to see the test samples.

## 说明/提示

In the first sample we can shift stick from the third group of sticks to the first one.

In the second sample we cannot shift vertical stick from + sign to the second group of sticks. So we cannot make a - sign.

There is no answer in the third sample because we cannot remove sticks from the expression.

In the forth sample the initial expression is already arithmetically correct and that is why we don't have to shift sticks.

## 样例 #1

### 输入

```
||+|=|||||

```

### 输出

```
|||+|=||||

```

## 样例 #2

### 输入

```
|||||+||=||

```

### 输出

```
Impossible

```

## 样例 #3

### 输入

```
|+|=||||||

```

### 输出

```
Impossible

```

## 样例 #4

### 输入

```
||||+||=||||||

```

### 输出

```
||||+||=||||||

```



---

---
title: "On Corruption and Numbers"
layout: "post"
diff: 普及-
pid: CF397B
tag: []
---

# On Corruption and Numbers

## 题目描述

Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — $ n_{i} $ berubleys. He cannot pay more than $ n_{i} $ , because then the difference between the paid amount and $ n_{i} $ can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than $ r_{i} $ . The rector also does not carry coins of denomination less than $ l_{i} $ in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination $ x $ berubleys, where $ l_{i}<=x<=r_{i} $ (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given $ t $ requests, each of them contains numbers $ n_{i},l_{i},r_{i} $ . For each query you need to answer, whether it is possible to gather the sum of exactly $ n_{i} $ berubleys using only coins with an integer denomination from $ l_{i} $ to $ r_{i} $ berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

## 输入格式

The first line contains the number of universities $ t $ , ( $ 1<=t<=1000 $ ) Each of the next $ t $ lines contain three space-separated integers: $ n_{i},l_{i},r_{i} $ ( $ 1<=n_{i},l_{i},r_{i}<=10^{9}; l_{i}<=r_{i} $ ).

## 输出格式

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

## 说明/提示

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.

## 样例 #1

### 输入

```
2
5 2 3
6 4 5

```

### 输出

```
Yes
No

```



---

---
title: "Multiplication Table"
layout: "post"
diff: 普及-
pid: CF39H
tag: []
---

# Multiplication Table

## 题目描述

Petya studies positional notations. He has already learned to add and subtract numbers in the systems of notations with different radices and has moved on to a more complicated action — multiplication. To multiply large numbers one has to learn the multiplication table. Unfortunately, in the second grade students learn only the multiplication table of decimals (and some students even learn it in the first grade). Help Petya make a multiplication table for numbers in the system of notations with the radix $ k $ .

## 输入格式

The first line contains a single integer $ k $ ( $ 2<=k<=10 $ ) — the radix of the system.

## 输出格式

Output the multiplication table for the system of notations with the radix $ k $ . The table must contain $ k-1 $ rows and $ k-1 $ columns. The element on the crossing of the $ i $ -th row and the $ j $ -th column is equal to the product of $ i $ and $ j $ in the system of notations with the radix $ k $ . Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).

## 样例 #1

### 输入

```
10

```

### 输出

```
1  2  3  4  5  6  7  8  9
2  4  6  8 10 12 14 16 18
3  6  9 12 15 18 21 24 27
4  8 12 16 20 24 28 32 36
5 10 15 20 25 30 35 40 45
6 12 18 24 30 36 42 48 54
7 14 21 28 35 42 49 56 63
8 16 24 32 40 48 56 64 72
9 18 27 36 45 54 63 72 81

```

## 样例 #2

### 输入

```
3

```

### 输出

```
1  2
2 11
```



---

---
title: "Inna and Choose Options"
layout: "post"
diff: 普及-
pid: CF400A
tag: []
---

# Inna and Choose Options

## 题目描述

Inna 在玩井字棋的升级版。游戏规则如下：

在游戏开始前，他将 $12$ 张卡片排列在桌子上。每张卡片上都有一个字符 `X` 或 `O`。然后玩家选择两个正整数 $a$ 和 $b$ $(a\times b=12)$ 
，然后根据放在桌子上的卡片制作一个 $a\times b$ 大小的表格，前 $b$ 
 张卡片组成第一行，接下来的 $b$ 张卡片组成第二行，依此类推，最后的 $b$ 张卡片组成最后一行（第 $a$ 行）。玩家获胜的条件是表格中某一列的所有卡片都含有字符 `X`。否则，玩家失败。

Inna 已经把 $12$ 张卡片按顺序放在了桌子上。但不幸的是，她不知道选择什么样的 $a$ 和 $b$ 来帮助她赢得游戏，所以她让你输出可能的所有选择 $a,b$，以及能够获胜的方式。

## 输入格式

输入的第一行包含整数 $t$$(1\le t\le100) $。这个值表示输入中测试数据的个数。接下来的几行描述了每个测试的情况。

每个测试的描述都是一个由 $12$ 个字符组成的字符串，其中每个字符要么是 `X`，要么是 `O`。字符串的第 $i$ 个字符表示从开头算起第 $i$ 张卡片上的字符。

## 输出格式

对于每个测试，将其答案打印在一行上。行中的第一个数字表示选择两个数 $ a,b $ 的不同方式的数量。接下来，在这一行上按照 $a$ 递增的顺序打印出这些对 $a,b$ 的选择。以 `a x b ` 的格式打印这些对。在行中用空格分隔这些对。

Translate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)

## 样例 #1

### 输入

```
4
OXXXOXOOXOOX
OXOXOXOXOXOX
XXXXXXXXXXXX
OOOOOOOOOOOO

```

### 输出

```
3 1x12 2x6 4x3
4 1x12 2x6 3x4 6x2
6 1x12 2x6 3x4 4x3 6x2 12x1
0

```



---

---
title: "Inna and Huge Candy Matrix"
layout: "post"
diff: 普及-
pid: CF400C
tag: []
---

# Inna and Huge Candy Matrix

## 题目描述

Inna and Dima decided to surprise Sereja. They brought a really huge candy matrix, it's big even for Sereja! Let's number the rows of the giant matrix from $ 1 $ to $ n $ from top to bottom and the columns — from $ 1 $ to $ m $ , from left to right. We'll represent the cell on the intersection of the $ i $ -th row and $ j $ -th column as $ (i,j) $ . Just as is expected, some cells of the giant candy matrix contain candies. Overall the matrix has $ p $ candies: the $ k $ -th candy is at cell $ (x_{k},y_{k}) $ .

The time moved closer to dinner and Inna was already going to eat $ p $ of her favourite sweets from the matrix, when suddenly Sereja (for the reason he didn't share with anyone) rotated the matrix $ x $ times clockwise by 90 degrees. Then he performed the horizontal rotate of the matrix $ y $ times. And then he rotated the matrix $ z $ times counterclockwise by 90 degrees. The figure below shows how the rotates of the matrix looks like.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF400C/168ff7db18e226cd45113b10da5f3c7fbd5680f5.png)Inna got really upset, but Duma suddenly understood two things: the candies didn't get damaged and he remembered which cells contained Inna's favourite sweets before Sereja's strange actions. Help guys to find the new coordinates in the candy matrix after the transformation Sereja made!

## 输入格式

The first line of the input contains fix integers $ n $ , $ m $ , $ x $ , $ y $ , $ z $ , $ p $ $ (1<=n,m<=10^{9}; 0<=x,y,z<=10^{9}; 1<=p<=10^{5}) $ .

Each of the following $ p $ lines contains two integers $ x_{k} $ , $ y_{k} $ $ (1<=x_{k}<=n; 1<=y_{k}<=m) $ — the initial coordinates of the $ k $ -th candy. Two candies can lie on the same cell.

## 输出格式

For each of the $ p $ candies, print on a single line its space-separated new coordinates.

## 说明/提示

Just for clarity. Horizontal rotating is like a mirroring of the matrix. For matrix:

`<br></br>QWER      REWQ <br></br>ASDF  ->  FDSA<br></br>ZXCV      VCXZ<br></br>`

## 样例 #1

### 输入

```
3 3 3 1 1 9
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3

```

### 输出

```
1 3
1 2
1 1
2 3
2 2
2 1
3 3
3 2
3 1

```



---

---
title: "Vanya and Cards"
layout: "post"
diff: 普及-
pid: CF401A
tag: []
---

# Vanya and Cards

## 题目描述

Vanya loves playing. He even has a special set of cards to play with. Each card has a single integer. The number on the card can be positive, negative and can even be equal to zero. The only limit is, the number on each card doesn't exceed $ x $ in the absolute value.

Natasha doesn't like when Vanya spends a long time playing, so she hid all of his cards. Vanya became sad and started looking for the cards but he only found $ n $ of them. Vanya loves the balance, so he wants the sum of all numbers on found cards equal to zero. On the other hand, he got very tired of looking for cards. Help the boy and say what is the minimum number of cards does he need to find to make the sum equal to zero?

You can assume that initially Vanya had infinitely many cards with each integer number from $ -x $ to $ x $ .

## 输入格式

The first line contains two integers: $ n $ $ (1<=n<=1000) $ — the number of found cards and $ x $ $ (1<=x<=1000) $ — the maximum absolute value of the number on a card. The second line contains $ n $ space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed $ x $ in their absolute value.

## 输出格式

Print a single number — the answer to the problem.

## 说明/提示

In the first sample, Vanya needs to find a single card with number -2.

In the second sample, Vanya needs to find two cards with number 2. He can't find a single card with the required number as the numbers on the lost cards do not exceed 3 in their absolute value.

## 样例 #1

### 输入

```
3 2
-1 1 2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
2 3
-2 -2

```

### 输出

```
2

```



---

---
title: "Nuts"
layout: "post"
diff: 普及-
pid: CF402A
tag: []
---

# Nuts

## 题目描述

You have $ a $ nuts and lots of boxes. The boxes have a wonderful feature: if you put $ x $ $ (x>=0) $ divisors (the spacial bars that can divide a box) to it, you get a box, divided into $ x+1 $ sections.

You are minimalist. Therefore, on the one hand, you are against dividing some box into more than $ k $ sections. On the other hand, you are against putting more than $ v $ nuts into some section of the box. What is the minimum number of boxes you have to use if you want to put all the nuts in boxes, and you have $ b $ divisors?

Please note that you need to minimize the number of used boxes, not sections. You do not have to minimize the number of used divisors.

## 输入格式

The first line contains four space-separated integers $ k $ , $ a $ , $ b $ , $ v $ ( $ 2<=k<=1000 $ ; $ 1<=a,b,v<=1000 $ ) — the maximum number of sections in the box, the number of nuts, the number of divisors and the capacity of each section of the box.

## 输出格式

Print a single integer — the answer to the problem.

## 说明/提示

In the first sample you can act like this:

- Put two divisors to the first box. Now the first box has three sections and we can put three nuts into each section. Overall, the first box will have nine nuts.
- Do not put any divisors into the second box. Thus, the second box has one section for the last nut.

In the end we've put all the ten nuts into boxes.

The second sample is different as we have exactly one divisor and we put it to the first box. The next two boxes will have one section each.

## 样例 #1

### 输入

```
3 10 3 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3 10 1 3

```

### 输出

```
3

```

## 样例 #3

### 输入

```
100 100 1 1000

```

### 输出

```
1

```



---

---
title: "Searching for Graph"
layout: "post"
diff: 普及-
pid: CF402C
tag: []
---

# Searching for Graph

## 题目描述

Let's call an undirected graph of $ n $ vertices  $ p $ -interesting, if the following conditions fulfill:

- the graph contains exactly $ 2n+p $ edges;
- the graph doesn't contain self-loops and multiple edges;
- for any integer $ k $ ( $ 1<=k<=n $ ), any subgraph consisting of $ k $ vertices contains at most $ 2k+p $ edges.

A subgraph of a graph is some set of the graph vertices and some set of the graph edges. At that, the set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices.

Your task is to find a  $ p $ -interesting graph consisting of $ n $ vertices.

## 输入格式

The first line contains a single integer $ t $ ( $ 1<=t<=5 $ ) — the number of tests in the input. Next $ t $ lines each contains two space-separated integers: $ n $ , $ p $ ( $ 5<=n<=24 $ ; $ p>=0 $ ; ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF402C/5c1502c81534ca3ec91c7247a7dbb60fd411d7ba.png)) — the number of vertices in the graph and the interest value for the appropriate test.

It is guaranteed that the required graph exists.

## 输出格式

For each of the $ t $ tests print $ 2n+p $ lines containing the description of the edges of a  $ p $ -interesting graph: the $ i $ -th line must contain two space-separated integers $ a_{i},b_{i} $ ( $ 1<=a_{i},b_{i}<=n; a_{i}≠b_{i} $ ) — two vertices, connected by an edge in the resulting graph. Consider the graph vertices numbered with integers from $ 1 $ to $ n $ .

Print the answers to the tests in the order the tests occur in the input. If there are multiple solutions, you can print any of them.

## 样例 #1

### 输入

```
1
6 0

```

### 输出

```
1 2
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6

```



---

---
title: "Valera and X"
layout: "post"
diff: 普及-
pid: CF404A
tag: []
---

# Valera and X

## 题目描述

Valera是一个小男孩。昨天，他的数学作业很多，因此他没有时间去温习英语课的单词表。不幸的是，英语老师决定在今天的课上进行一场单词小测。测试中，发下的试卷是正方形的，由许多小格子组成，共有n行n列（n是奇数），每个单位的小格子都包含一个英文字母。

Valera需要知道试卷上的小字母是否会组成一个大写字母“X”的形状。Valera的老师认为试卷上的字母会构成“X”，当且仅当：

1、所有对角线上的格子所包含的字母必须一致。

2、其他所有格子（不在对角线上的），也必须由相同的字母所组成且这个字母不能与对角线上的字母相同。

请你按照题面描述，编程帮Valera解决这个问题。

## 输入格式

第1行包含一个整数n（3 <= n < 300，n是奇数）

第2~n+1行，每行包含n个英文字母，如题面描述。

## 输出格式

如果试卷上的字母能构成“X”，输出字符串“YES”；如果不能，则输出字符串“NO”。

输出不加双引号。

## 样例 #1

### 输入

```
5
xooox
oxoxo
soxoo
oxoxo
xooox

```

### 输出

```
NO

```

## 样例 #2

### 输入

```
3
wsw
sws
wsw

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
3
xpx
pxp
xpe

```

### 输出

```
NO

```



---

---
title: "Line to Cashier"
layout: "post"
diff: 普及-
pid: CF408A
tag: []
---

# Line to Cashier

## 题目描述

Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.

There are $ n $ cashiers at the exit from the supermarket. At the moment the queue for the $ i $ -th cashier already has $ k_{i} $ people. The $ j $ -th person standing in the queue to the $ i $ -th cashier has $ m_{i,j} $ items in the basket. Vasya knows that:

- the cashier needs 5 seconds to scan one item;
- after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change.

Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=100 $ ) — the number of cashes in the shop. The second line contains $ n $ space-separated integers: $ k_{1},k_{2},...,k_{n} $ ( $ 1<=k_{i}<=100 $ ), where $ k_{i} $ is the number of people in the queue to the $ i $ -th cashier.

The $ i $ -th of the next $ n $ lines contains $ k_{i} $ space-separated integers: $ m_{i,1},m_{i,2},...,m_{i,ki} $ ( $ 1<=m_{i,j}<=100 $ ) — the number of products the $ j $ -th person in the queue for the $ i $ -th cash has.

## 输出格式

Print a single integer — the minimum number of seconds Vasya needs to get to the cashier.

## 说明/提示

In the second test sample, if Vasya goes to the first queue, he gets to the cashier in $ 100·5+15=515 $ seconds. But if he chooses the second queue, he will need $ 1·5+2·5+2·5+3·5+4·15=100 $ seconds. He will need $ 1·5+9·5+1·5+3·15=100 $ seconds for the third one and $ 7·5+8·5+2·15=105 $ seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.

## 样例 #1

### 输入

```
1
1
1

```

### 输出

```
20

```

## 样例 #2

### 输入

```
4
1 4 3 2
100
1 2 2 3
1 9 1
7 8

```

### 输出

```
100

```



---

---
title: "Guess a number!"
layout: "post"
diff: 普及-
pid: CF416A
tag: []
---

# Guess a number!

## 题目描述

A TV show called "Guess a number!" is gathering popularity. The whole Berland, the old and the young, are watching the show.

The rules are simple. The host thinks of an integer $ y $ and the participants guess it by asking questions to the host. There are four types of acceptable questions:

- Is it true that $ y $ is strictly larger than number $ x $ ?
- Is it true that $ y $ is strictly smaller than number $ x $ ?
- Is it true that $ y $ is larger than or equal to number $ x $ ?
- Is it true that $ y $ is smaller than or equal to number $ x $ ?

On each question the host answers truthfully, "yes" or "no".

Given the sequence of questions and answers, find any integer value of $ y $ that meets the criteria of all answers. If there isn't such value, print "Impossible".

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=10000 $ ) — the number of questions (and answers). Next $ n $ lines each contain one question and one answer to it. The format of each line is like that: "sign x answer", where the sign is:

- ">" (for the first type queries),
- "<" (for the second type queries),
- ">=" (for the third type queries),
- "<=" (for the fourth type queries).

All values of $ x $ are integer and meet the inequation $ -10^{9}<=x<=10^{9} $ . The answer is an English letter "Y" (for "yes") or "N" (for "no").

Consequtive elements in lines are separated by a single space.

## 输出格式

Print any of such integers $ y $ , that the answers to all the queries are correct. The printed number $ y $ must meet the inequation $ -2·10^{9}<=y<=2·10^{9} $ . If there are many answers, print any of them. If such value doesn't exist, print word "Impossible" (without the quotes).

## 样例 #1

### 输入

```
4
&gt;= 1 Y
&lt; 3 N
&lt;= -3 N
&gt; 55 N

```

### 输出

```
17

```

## 样例 #2

### 输入

```
2
&gt; 100 Y
&lt; -100 Y

```

### 输出

```
Impossible

```



---

---
title: "Martian Dollar"
layout: "post"
diff: 普及-
pid: CF41B
tag: []
---

# Martian Dollar

## 题目描述

一天Vasya得到了接下来n天，在bourles 有火星元的交易的信息。 第i天每一火星元的市价（不管是买入还是卖出都一样）是a[i]. Vasya有b 火星元。 他可以执行至多一次买入一定数量的火星元并卖出的操作。 根据火星法律，对火星元的买卖必须以整数为单位。试问Vasya在过了n天后最多能得到多少火星元？

## 输入格式

第一行两个数$n,b (1 <= n,b <= 2000)$  ，
第二行，n个数a[i] $ 1 <= a_i<= 2000$  ，含义如题

## 输出格式

一行一个数，表示答案。

Translated by @Maniac丶坚果

## 样例 #1

### 输入

```
2 4
3 7

```

### 输出

```
8

```

## 样例 #2

### 输入

```
4 10
4 3 2 1

```

### 输出

```
10

```

## 样例 #3

### 输入

```
4 10
4 2 3 1

```

### 输出

```
15

```



---

---
title: "Email address"
layout: "post"
diff: 普及-
pid: CF41C
tag: []
---

# Email address

## 题目描述

Sometimes one has to spell email addresses over the phone. Then one usually pronounces a dot as dot, an at sign as at. As a result, we get something like vasyaatgmaildotcom. Your task is to transform it into a proper email address (vasya@gmail.com).

It is known that a proper email address contains only such symbols as . @ and lower-case Latin letters, doesn't start with and doesn't end with a dot. Also, a proper email address doesn't start with and doesn't end with an at sign. Moreover, an email address contains exactly one such symbol as @, yet may contain any number (possible, zero) of dots.

You have to carry out a series of replacements so that the length of the result was as short as possible and it was a proper email address. If the lengths are equal, you should print the lexicographically minimal result.

Overall, two variants of replacement are possible: dot can be replaced by a dot, at can be replaced by an at.



## 输入格式

The first line contains the email address description. It is guaranteed that that is a proper email address with all the dots replaced by dot an the at signs replaced by at. The line is not empty and its length does not exceed 100 symbols.

## 输出格式

Print the shortest email address, from which the given line could be made by the described above replacements. If there are several solutions to that problem, print the lexicographically minimal one (the lexicographical comparison of the lines are implemented with an operator < in modern programming languages).

In the ASCII table the symbols go in this order: . @ ab...z

## 样例 #1

### 输入

```
vasyaatgmaildotcom

```

### 输出

```
vasya@gmail.com

```

## 样例 #2

### 输入

```
dotdotdotatdotdotat

```

### 输出

```
dot..@..at

```

## 样例 #3

### 输入

```
aatt

```

### 输出

```
a@t

```



---

---
title: "Squats"
layout: "post"
diff: 普及-
pid: CF424A
tag: []
---

# Squats

## 题目描述

Pasha has many hamsters and he makes them work out. Today, $ n $ hamsters ( $ n $ is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF424A/666f6519688863e0a36337875170dd12050e1c31.png) hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?

## 输入格式

The first line contains integer $ n $ ( $ 2<=n<=200 $ ; $ n $ is even). The next line contains $ n $ characters without spaces. These characters describe the hamsters' position: the $ i $ -th character equals 'X', if the $ i $ -th hamster in the row is standing, and 'x', if he is sitting.

## 输出格式

In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.

## 样例 #1

### 输入

```
4
xxXx

```

### 输出

```
1
XxXx

```

## 样例 #2

### 输入

```
2
XX

```

### 输出

```
1
xX

```

## 样例 #3

### 输入

```
6
xXXxXx

```

### 输出

```
0
xXXxXx

```



---

---
title: "Police Recruits"
layout: "post"
diff: 普及-
pid: CF427A
tag: []
---

# Police Recruits

## 题目描述

The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.

Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.

If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.

Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.

## 输入格式

The first line of input will contain an integer $ n (1<=n<=10^{5}) $ , the number of events. The next line will contain $ n $ space-separated integers.

If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.

## 输出格式

Print a single integer, the number of crimes which will go untreated.

## 说明/提示

Lets consider the second example:

1. Firstly one person is hired.
2. Then crime appears, the last hired person will investigate this crime.
3. One more person is hired.
4. One more crime appears, the last hired person will investigate this crime.
5. Crime appears. There is no free policeman at the time, so this crime will go untreated.
6. One more person is hired.
7. One more person is hired.
8. One more person is hired.

The answer is one, as one crime (on step 5) will go untreated.

## 样例 #1

### 输入

```
3
-1 -1 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
8
1 -1 1 -1 -1 1 1 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
11
-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1

```

### 输出

```
8

```



---

---
title: "Prison Transfer"
layout: "post"
diff: 普及-
pid: CF427B
tag: []
---

# Prison Transfer

## 题目描述

The prison of your city has $ n $ prisoners. As the prison can't accommodate all of them, the city mayor has decided to transfer $ c $ of the prisoners to a prison located in another city.

For this reason, he made the $ n $ prisoners to stand in a line, with a number written on their chests. The number is the severity of the crime he/she has committed. The greater the number, the more severe his/her crime was.

Then, the mayor told you to choose the $ c $ prisoners, who will be transferred to the other prison. He also imposed two conditions. They are,

- The chosen $ c $ prisoners has to form a contiguous segment of prisoners.
- Any of the chosen prisoner's crime level should not be greater then $ t $ . Because, that will make the prisoner a severe criminal and the mayor doesn't want to take the risk of his running away during the transfer.

Find the number of ways you can choose the $ c $ prisoners.

## 输入格式

The first line of input will contain three space separated integers $ n (1<=n<=2·10^{5}) $ , $ t (0<=t<=10^{9}) $ and $ c (1<=c<=n) $ . The next line will contain $ n $ space separated integers, the $ i^{th} $ integer is the severity $ i^{th} $ prisoner's crime. The value of crime severities will be non-negative and will not exceed $ 10^{9} $ .

## 输出格式

Print a single integer — the number of ways you can choose the $ c $ prisoners.

## 样例 #1

### 输入

```
4 3 3
2 3 1 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
1 1 1
2

```

### 输出

```
0

```

## 样例 #3

### 输入

```
11 4 2
2 2 0 7 3 2 2 4 9 1 4

```

### 输出

```
6

```



---

---
title: "Queue on Bus Stop"
layout: "post"
diff: 普及-
pid: CF435A
tag: []
---

# Queue on Bus Stop

## 题目描述

It's that time of the year when the Russians flood their countryside summer cottages (dachas) and the bus stop has a lot of people. People rarely go to the dacha on their own, it's usually a group, so the people stand in queue by groups.

The bus stop queue has $ n $ groups of people. The $ i $ -th group from the beginning has $ a_{i} $ people. Every $ 30 $ minutes an empty bus arrives at the bus stop, it can carry at most $ m $ people. Naturally, the people from the first group enter the bus first. Then go the people from the second group and so on. Note that the order of groups in the queue never changes. Moreover, if some group cannot fit all of its members into the current bus, it waits for the next bus together with other groups standing after it in the queue.

Your task is to determine how many buses is needed to transport all $ n $ groups to the dacha countryside.

## 输入格式

The first line contains two integers $ n $ and $ m $ $ (1<=n,m<=100) $ . The next line contains $ n $ integers: $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=m) $ .

## 输出格式

Print a single integer — the number of buses that is needed to transport all $ n $ groups to the dacha countryside.

## 样例 #1

### 输入

```
4 3
2 3 2 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3 4
1 2 1

```

### 输出

```
1

```



---

---
title: "The Child and Homework"
layout: "post"
diff: 普及-
pid: CF437A
tag: []
---

# The Child and Homework

## 题目描述

Once upon a time a child got a test consisting of multiple-choice questions as homework. A multiple-choice question consists of four choices: A, B, C and D. Each choice has a description, and the child should find out the only one that is correct.

Fortunately the child knows how to solve such complicated test. The child will follow the algorithm:

- If there is some choice whose description at least twice shorter than all other descriptions, or at least twice longer than all other descriptions, then the child thinks the choice is great.
- If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).

You are given a multiple-choice questions, can you predict child's choose?

## 输入格式

The first line starts with "A." (without quotes), then followed the description of choice A. The next three lines contains the descriptions of the other choices in the same format. They are given in order: B, C, D. Please note, that the description goes after prefix "X.", so the prefix mustn't be counted in description's length.

Each description is non-empty and consists of at most $ 100 $ characters. Each character can be either uppercase English letter or lowercase English letter, or "\_".

## 输出格式

Print a single line with the child's choice: "A", "B", "C" or "D" (without quotes).

## 说明/提示

In the first sample, the first choice has length 39, the second one has length 35, the third one has length 37, and the last one has length 15. The choice D (length 15) is twice shorter than all other choices', so it is great choice. There is no other great choices so the child will choose D.

In the second sample, no choice is great, so the child will choose the luckiest choice C.

In the third sample, the choice B (length 2) is twice longer than all other choices', so it is great choice. There is no other great choices so the child will choose B.

## 样例 #1

### 输入

```
A.VFleaKing_is_the_author_of_this_problem
B.Picks_is_the_author_of_this_problem
C.Picking_is_the_author_of_this_problem
D.Ftiasch_is_cute

```

### 输出

```
D

```

## 样例 #2

### 输入

```
A.ab
B.abcde
C.ab
D.abc

```

### 输出

```
C

```

## 样例 #3

### 输入

```
A.c
B.cc
C.c
D.c

```

### 输出

```
B

```



---

---
title: "The Child and Set"
layout: "post"
diff: 普及-
pid: CF437B
tag: []
---

# The Child and Set

## 题目描述

给你两个整数 $n,m$，要求选若干个不大于 $m$ 的数，使得这几个数的 Lowbit 值和等于 $n$。

## 输入格式

两个数 $n, m$。

## 输出格式

第一行：选了几个数。

第二行：这几个数，用空格分开，有多解输出任意一解，无解输出 $-1$。

**样例 \#1 解释**：$\operatorname {lowbit}(4)=4,\operatorname {lowbit}(5)=1$，$4+1=5$。

**样例 \#2 解释**：$\operatorname {lowbit}(2)=2,\operatorname {lowbit}(1)=1,\operatorname {lowbit}(3)=1$，$2+1+1=4$。

由 @Hjl1777 提供翻译

## 样例 #1

### 输入

```
5 5

```

### 输出

```
2
4 5

```

## 样例 #2

### 输入

```
4 3

```

### 输出

```
3
2 3 1

```

## 样例 #3

### 输入

```
5 1

```

### 输出

```
-1

```



---

---
title: "Devu, the Singer and Churu, the Joker"
layout: "post"
diff: 普及-
pid: CF439A
tag: []
---

# Devu, the Singer and Churu, the Joker

## 题目描述

Devu is a renowned classical singer. He is invited to many big functions/festivals. Recently he was invited to "All World Classical Singing Festival". Other than Devu, comedian Churu was also invited.

Devu has provided organizers a list of the songs and required time for singing them. He will sing $ n $ songs, $ i^{th} $ song will take $ t_{i} $ minutes exactly.

The Comedian, Churu will crack jokes. All his jokes are of 5 minutes exactly.

People have mainly come to listen Devu. But you know that he needs rest of 10 minutes after each song. On the other hand, Churu being a very active person, doesn't need any rest.

You as one of the organizers should make an optimal sсhedule for the event. For some reasons you must follow the conditions:

- The duration of the event must be no more than $ d $ minutes;
- Devu must complete all his songs;
- With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible.

If it is not possible to find a way to conduct all the songs of the Devu, output -1. Otherwise find out maximum number of jokes that Churu can crack in the grand event.

## 输入格式

The first line contains two space separated integers $ n $ , $ d $ $ (1<=n<=100; 1<=d<=10000) $ . The second line contains $ n $ space-separated integers: $ t_{1},t_{2},...,t_{n} $ $ (1<=t_{i}<=100) $ .

## 输出格式

If there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.

## 说明/提示

Consider the first example. The duration of the event is $ 30 $ minutes. There could be maximum $ 5 $ jokes in the following way:

- First Churu cracks a joke in $ 5 $ minutes.
- Then Devu performs the first song for $ 2 $ minutes.
- Then Churu cracks $ 2 $ jokes in $ 10 $ minutes.
- Now Devu performs second song for $ 2 $ minutes.
- Then Churu cracks $ 2 $ jokes in $ 10 $ minutes.
- Now finally Devu will perform his last song in $ 1 $ minutes.

Total time spent is $ 5+2+10+2+10+1=30 $ minutes.

Consider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1.

## 样例 #1

### 输入

```
3 30
2 2 1

```

### 输出

```
5

```

## 样例 #2

### 输入

```
3 20
2 1 1

```

### 输出

```
-1

```



---

---
title: "Lucky Tickets"
layout: "post"
diff: 普及-
pid: CF43C
tag: []
---

# Lucky Tickets

## 题目描述

Vasya thinks that lucky tickets are the tickets whose numbers are divisible by 3. He gathered quite a large collection of such tickets but one day his younger brother Leonid was having a sulk and decided to destroy the collection. First he tore every ticket exactly in two, but he didn’t think it was enough and Leonid also threw part of the pieces away. Having seen this, Vasya got terrified but still tried to restore the collection. He chose several piece pairs and glued each pair together so that each pair formed a lucky ticket. The rest of the pieces Vasya threw away reluctantly. Thus, after the gluing of the $ 2t $ pieces he ended up with $ t $ tickets, each of which was lucky.

When Leonid tore the tickets in two pieces, one piece contained the first several letters of his number and the second piece contained the rest.

Vasya can glue every pair of pieces in any way he likes, but it is important that he gets a lucky ticket in the end. For example, pieces 123 and 99 can be glued in two ways: 12399 and 99123.

What maximum number of tickets could Vasya get after that?

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=10^{4} $ ) — the number of pieces. The second line contains $ n $ space-separated numbers $ a_{i} $ ( $ 1<=a_{i}<=10^{8} $ ) — the numbers on the pieces. Vasya can only glue the pieces in pairs. Even if the number of a piece is already lucky, Vasya should glue the piece with some other one for it to count as lucky. Vasya does not have to use all the pieces. The numbers on the pieces an on the resulting tickets may coincide.

## 输出格式

Print the single number — the maximum number of lucky tickets that will be able to be restored. Don't forget that every lucky ticket is made of exactly two pieces glued together.

## 样例 #1

### 输入

```
3
123 123 99

```

### 输出

```
1

```

## 样例 #2

### 输入

```
6
1 1 1 23 10 3

```

### 输出

```
1

```



---

---
title: "Valera and Fruits"
layout: "post"
diff: 普及-
pid: CF441B
tag: []
---

# Valera and Fruits

## 题目描述

Valera很爱他的花园，因为那里生长着n棵果树。

今年他将迎来一场大丰收！第i棵树上会结出bi个果实，它们将在第ai天全部成熟。不幸的是，这些果子将很快枯萎，因此Valera只能在第ai天和第ai+1天摘下它们。（所有不在指定的两天内摘下的果子，都不可食用）

Valera的动作不是很快，但他也有自己的优势。他已经准备好了，以保证每天都可以工作。一天，Valera最多可以摘下v个果子，这些果子有可能是同一棵树上的，也有可能不是。那么，在合理安排日程表的情况下，Valera最多可以收获多少个果子？

## 输入格式

第1行包含两个用空格隔开的整数，n和v（1 <= n,v <= 3000）——即花园里一共有多少棵树，以及Valera一天最多可以摘下多少个果子。

第2~n+1行包含对于每一棵树的具体描述。第i+1行会包含两个用空格隔开的整数，ai和bi（1 <= ai,bi <= 3000）——即第i棵树上的果子会在哪一天完全成熟，以及第i棵树上会结出多少个果子。

## 输出格式

输出一个整数——即Valera所能收获的果子的最大值。

## 样例 #1

### 输入

```
2 3
1 5
2 3

```

### 输出

```
8

```

## 样例 #2

### 输入

```
5 10
3 20
2 20
1 20
4 20
5 20

```

### 输出

```
60

```



---

---
title: "Valera and Tubes"
layout: "post"
diff: 普及-
pid: CF441C
tag: []
---

# Valera and Tubes

## 题目描述

有一个n×m的矩形网格


定义“管道”如下：


是一些格子组成的序列 序列长度至少为2


序列中任意相邻两个格子必须在网格中也相邻（四联通）


序列中不能出现重复的格子


现在要给出k个管道使得每个格子恰好属于一个管道

## 输入格式

一行 依次输入 n m 和 k（2≤n m≤300 2≤2k≤n×m）

## 输出格式

每个管道所对应的序列

k行 由若干Xi和Yi组成


如果有多解 仅输出一种即可

## 样例 #1

### 输入

```
3 3 3

```

### 输出

```
3 1 1 1 2 1 3
3 2 1 2 2 2 3
3 3 1 3 2 3 3

```

## 样例 #2

### 输入

```
2 3 1

```

### 输出

```
6 1 1 1 2 1 3 2 3 2 2 2 1

```



---

---
title: "Cola"
layout: "post"
diff: 普及-
pid: CF44B
tag: []
---

# Cola

## 题目描述

To celebrate the opening of the Winter Computer School the organizers decided to buy in $ n $ liters of cola. However, an unexpected difficulty occurred in the shop: it turned out that cola is sold in bottles $ 0.5 $ , $ 1 $ and $ 2 $ liters in volume. At that, there are exactly $ a $ bottles $ 0.5 $ in volume, $ b $ one-liter bottles and $ c $ of two-liter ones. The organizers have enough money to buy any amount of cola. What did cause the heated arguments was how many bottles of every kind to buy, as this question is pivotal for the distribution of cola among the participants (and organizers as well).

Thus, while the organizers are having the argument, discussing different variants of buying cola, the Winter School can't start. Your task is to count the number of all the possible ways to buy exactly $ n $ liters of cola and persuade the organizers that this number is too large, and if they keep on arguing, then the Winter Computer School will have to be organized in summer.

All the bottles of cola are considered indistinguishable, i.e. two variants of buying are different from each other only if they differ in the number of bottles of at least one kind.

## 输入格式

The first line contains four integers — $ n $ , $ a $ , $ b $ , $ c $ ( $ 1<=n<=10000 $ , $ 0<=a,b,c<=5000 $ ).

## 输出格式

Print the unique number — the solution to the problem. If it is impossible to buy exactly $ n $ liters of cola, print $ 0 $ .

## 样例 #1

### 输入

```
10 5 5 5

```

### 输出

```
9

```

## 样例 #2

### 输入

```
3 0 0 2

```

### 输出

```
0

```



---

---
title: "Anfisa the Monkey"
layout: "post"
diff: 普及-
pid: CF44E
tag: []
---

# Anfisa the Monkey

## 题目描述

Anfisa the monkey learns to type. She is yet unfamiliar with the "space" key and can only type in lower-case Latin letters. Having typed for a fairly long line, Anfisa understood that it would be great to divide what she has written into $ k $ lines not shorter than $ a $ and not longer than $ b $ , for the text to resemble human speech more. Help Anfisa.

## 输入格式

The first line contains three integers $ k $ , $ a $ and $ b $ ( $ 1<=k<=200 $ , $ 1<=a<=b<=200 $ ). The second line contains a sequence of lowercase Latin letters — the text typed by Anfisa. It is guaranteed that the given line is not empty and its length does not exceed $ 200 $ symbols.

## 输出格式

Print $ k $ lines, each of which contains no less than $ a $ and no more than $ b $ symbols — Anfisa's text divided into lines. It is not allowed to perform any changes in the text, such as: deleting or adding symbols, changing their order, etc. If the solution is not unique, print any of them. If there is no solution, print "No solution" (without quotes).

## 样例 #1

### 输入

```
3 2 5
abrakadabra

```

### 输出

```
ab
rakad
abra

```

## 样例 #2

### 输入

```
4 1 2
abrakadabra

```

### 输出

```
No solution

```



---

---
title: "Jzzhu and Children"
layout: "post"
diff: 普及-
pid: CF450A
tag: []
---

# Jzzhu and Children

## 题目描述

`Jzzhu`给学校里的$n$个孩子发糖果，编号从$1$到$n$排成一队，第$i$个孩子想得到至少$a_i$个糖果。  
`Jzzhu`的操作如下：
- 给队首的孩子$m$个糖果
- 如果这个孩子已经得到满足，他就会回家，否则他会到队尾。
- 在队列非空时重复上述两个操作  

在满足上述条件的情况下，求出最后回家的孩子的编号

## 输入格式

第一行两个整数$n,m(1\leq n,m\leq100)$，第二行$n$个整数$a_1,a_2,\cdots,a_n(\forall a_i\in[1,100])$

## 输出格式

输出一个整数表示最后回家的孩子的编号

## 样例 #1

### 输入

```
5 2
1 3 1 4 2

```

### 输出

```
4

```

## 样例 #2

### 输入

```
6 4
1 1 2 2 3 3

```

### 输出

```
6

```



---

---
title: "Game With Sticks"
layout: "post"
diff: 普及-
pid: CF451A
tag: []
---

# Game With Sticks

## 题目描述

After winning gold and silver in IOI 2014, Akshat and Malvika want to have some fun. Now they are playing a game on a grid made of $ n $ horizontal and $ m $ vertical sticks.

An intersection point is any point on the grid which is formed by the intersection of one horizontal stick and one vertical stick.

In the grid shown below, $ n=3 $ and $ m=3 $ . There are $ n+m=6 $ sticks in total (horizontal sticks are shown in red and vertical sticks are shown in green). There are $ n·m=9 $ intersection points, numbered from $ 1 $ to $ 9 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF451A/18b27511f71a42f9e0fd0b22af6d5248021325d7.png)The rules of the game are very simple. The players move in turns. Akshat won gold, so he makes the first move. During his/her move, a player must choose any remaining intersection point and remove from the grid all sticks which pass through this point. A player will lose the game if he/she cannot make a move (i.e. there are no intersection points remaining on the grid at his/her move).

Assume that both players play optimally. Who will win the game?

## 输入格式

The first line of input contains two space-separated integers, $ n $ and $ m $ ( $ 1<=n,m<=100 $ ).

## 输出格式

Print a single line containing "Akshat" or "Malvika" (without the quotes), depending on the winner of the game.

## 说明/提示

Explanation of the first sample:

The grid has four intersection points, numbered from $ 1 $ to $ 4 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF451A/e0d83475f64b355b0a9b5538e74aa373b38a9909.png)If Akshat chooses intersection point $ 1 $ , then he will remove two sticks ( $ 1-2 $ and $ 1-3 $ ). The resulting grid will look like this.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF451A/c9bd491d9b8dd9c48045e00c65ed3725174a35a0.png)Now there is only one remaining intersection point (i.e. $ 4 $ ). Malvika must choose it and remove both remaining sticks. After her move the grid will be empty.

In the empty grid, Akshat cannot make any move, hence he will lose.

Since all $ 4 $ intersection points of the grid are equivalent, Akshat will lose no matter which one he picks.

## 样例 #1

### 输入

```
2 2

```

### 输出

```
Malvika

```

## 样例 #2

### 输入

```
2 3

```

### 输出

```
Malvika

```

## 样例 #3

### 输入

```
3 3

```

### 输出

```
Akshat

```



---

---
title: "Pashmak and Garden"
layout: "post"
diff: 普及-
pid: CF459A
tag: []
---

# Pashmak and Garden

## 题目描述

Pashmak在一年前和一个叫Parmida的妹子相爱...

今天，Pashmak准备在一个浪漫的花园约会，但他忘记了花园的位置。他记得花园看起来像一个平行于坐标轴的正方形，正方形的每一个顶点上都有一棵树。现在，他只知道其中两棵树的位置。帮助他找到剩下两个的位置。

## 输入格式

第一行有四个整数x1​,y1​,x2​,y2​ (−100<=x1,y1,x2,y2<=100)，x1​,y1​为第一个树的坐标，x2​,y2​ 为第二个树的坐标。保证给定的点是不同的。

## 输出格式

输出另外两个树的坐标x3​,y3​,x4​,y4​.如果有多种方案，输出任意一种即可；如果无解，输出-1.
注意：x3​,y3​,x4​,y4​必须满足(−1000<=x3,y3,x4,y4<=1000)

## 样例 #1

### 输入

```
0 0 0 1

```

### 输出

```
1 0 1 1

```

## 样例 #2

### 输入

```
0 0 1 1

```

### 输出

```
0 1 1 0

```

## 样例 #3

### 输入

```
0 0 1 2

```

### 输出

```
-1

```



---

---
title: "Pashmak and Flowers"
layout: "post"
diff: 普及-
pid: CF459B
tag: []
---

# Pashmak and Flowers

## 题目描述

Pashmak 想要给 Parmida一对花。有n朵花在花园里，每朵花都有一个魅力值bi，Pashmak想要两朵魅力值相差最大的花，问有多少种方案？

## 输入格式

首先输入n (2<= n <= 2*10^5)。
接下来一行有n个空格隔开的整数b1, b2, …, bn (1 <= bi <= 10 ^ 9).

## 输出格式

输出最大差异和方案数，中间用空格隔开

## 样例 #1

### 输入

```
2
1 2

```

### 输出

```
1 1
```

## 样例 #2

### 输入

```
3
1 4 5

```

### 输出

```
4 1
```

## 样例 #3

### 输入

```
5
3 1 2 3 1

```

### 输出

```
2 4
```



---

---
title: "Director"
layout: "post"
diff: 普及-
pid: CF45E
tag: []
---

# Director

## 题目描述

给出$n$个名字和$n$个附名，请你将名字和附名两两配对，使得首字母相同的名字对数最多，并以最小字典序输出。

## 输入格式

第一行一个正整数$n(1 \leq n \leq 100)$

接下来$n$行每行一个长度不超过$10$的字符串描述一个名字。接下来$n$行每行一个长度不超过$10$的字符串描述一个附名。数据保证字符串两两不同，字符串的第一个字母为大写拉丁字母，其余为小写拉丁字母

## 输出格式

$Name_1\ Surname_1,\ Name_2\ Surname_2,\ ... \,,\ Name_n\ Surname_n$

其中$Name_i$与$Surname_i$为一对配对的名字与附名，其间用一个空格隔开。每一对名字之间用一个逗号加一个空格隔开。$Surname_n$之后不能出现额外的空格或者逗号

## 样例 #1

### 输入

```
4
Ann
Anna
Sabrina
John
Petrov
Ivanova
Stoltz
Abacaba

```

### 输出

```
Ann Abacaba, Anna Ivanova, John Petrov, Sabrina Stoltz
```

## 样例 #2

### 输入

```
4
Aa
Ab
Ac
Ba
Ad
Ae
Bb
Bc

```

### 输出

```
Aa Ad, Ab Ae, Ac Bb, Ba Bc
```



---

---
title: "Appleman and Toastman"
layout: "post"
diff: 普及-
pid: CF461A
tag: []
---

# Appleman and Toastman

## 题目描述

### 问题描述

苹果人和土司人正在玩游戏。一开始苹果人把包含 $n$ 个数的一组数给土司人，然后他们开始进行下面两个步骤：

- 每次土司人得到一组数，他把这些数的和加入到得分中，然后他把这组数交给苹果人。
- 每次苹果人得到只包含一个数的一组数，他会把这组数扔掉；每次苹果人得到包含至少两个数的一组数，他会任意的把它分成两个非空的组，并把这两组数分别交给土司人。

在这两个逗逼完成了所有的任务后他们会查看他们的分数。他们的最多能得多少分呢？

## 输入格式

第一行包含一个整数 $n$（$1\le n\le 3\times 10^5$）。

第二行包含 $n$ 个整数 $a_1,a_2,\cdots,a_n$（$1\le a_i\le 10^6$），表示一开始土司人得到的一组数。

## 输出格式

输出一个整数，表示可能的最大的分。

## 样例 #1

### 输入

```
3
3 1 5

```

### 输出

```
26

```

## 样例 #2

### 输入

```
1
10

```

### 输出

```
10

```



---

---
title: "Appleman and Easy Task"
layout: "post"
diff: 普及-
pid: CF462A
tag: []
---

# Appleman and Easy Task

## 题目描述

Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?

Given a $ n×n $ checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.

## 输入格式

The first line contains an integer $ n $ ( $ 1<=n<=100 $ ). Then $ n $ lines follow containing the description of the checkerboard. Each of them contains $ n $ characters (either 'x' or 'o') without spaces.

## 输出格式

Print "YES" or "NO" (without the quotes) depending on the answer to the problem.

## 样例 #1

### 输入

```
3
xxo
xox
oxx

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
4
xxxo
xoxo
oxox
xxxx

```

### 输出

```
NO

```



---

---
title: "Appleman and Card Game"
layout: "post"
diff: 普及-
pid: CF462B
tag: []
---

# Appleman and Card Game

## 题目描述

给你个长度为 $n$ 的字符串，要求你从这个字符串中选取 $k$ 个字符，使选到的每个字母的数量的平方和最大。

## 输入格式

第 $1$ 行两个整数 $n,k\space(1\le k\le n\le 10^5)$。

第 $2$ 行 $n$ 个大写字母，表示字符串。

## 输出格式

一个整数，表示选到的每个字母的数量的平方和。

Translated by @[busy_programmer](https://www.luogu.com.cn/user/649315)。

## 样例 #1

### 输入

```
15 10
DZFDFZDFDDDDDDF

```

### 输出

```
82

```

## 样例 #2

### 输入

```
6 4
YJSNPI

```

### 输出

```
4

```



---

---
title: "Caisa and Pylons"
layout: "post"
diff: 普及-
pid: CF463B
tag: []
---

# Caisa and Pylons

## 题目描述

Caisa 在玩游戏。



游戏中有从 $0$ 到 $n$ 编号的 $(n+1)$ 个电塔，编号为 $0$ 的电塔高度为 $0$，编号为 $i$ 的电塔高度为$h_i$。



游戏的目标是到达第 $n$ 个电塔，而玩家唯一能做的就是从当前电塔（不妨设编号为 $k$）跳到下一个电塔（编号为 $k+1$）。当玩家这样做时，他的能量值会增加 $h_k-h_{k+1}$（如果该值为负数，则玩家失去能量值）。



玩家必须保证在任何时候他的能量值非负。



Caisa 从 $0$ 号塔开始，问他在一开始最少需要多少能量值才能达到游戏的目标？

## 输入格式

第一行一个正整数 $n(1 \le n \le 10^5)$。  

第二行 $n$ 个正整数 $h_1,h_2,...,h_n(1 \le h_i \le 10^5)$。

## 输出格式

一行，一个整数，表示 Caisa 在游戏开始时最少需要多少能量值才能达到游戏的目标。

## 样例 #1

### 输入

```
5
3 4 3 2 4

```

### 输出

```
4

```

## 样例 #2

### 输入

```
3
4 4 4

```

### 输出

```
4

```



---

---
title: "inc ARG"
layout: "post"
diff: 普及-
pid: CF465A
tag: []
---

# inc ARG

## 题目描述

Sergey is testing a next-generation processor. Instead of bytes the processor works with memory cells consisting of $ n $ bits. These bits are numbered from $ 1 $ to $ n $ . An integer is stored in the cell in the following way: the least significant bit is stored in the first bit of the cell, the next significant bit is stored in the second bit, and so on; the most significant bit is stored in the $ n $ -th bit.

Now Sergey wants to test the following instruction: "add $ 1 $ to the value of the cell". As a result of the instruction, the integer that is written in the cell must be increased by one; if some of the most significant bits of the resulting number do not fit into the cell, they must be discarded.

Sergey wrote certain values ​​of the bits in the cell and is going to add one to its value. How many bits of the cell will change after the operation?

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=100 $ ) — the number of bits in the cell.

The second line contains a string consisting of $ n $ characters — the initial state of the cell. The first character denotes the state of the first bit of the cell. The second character denotes the second least significant bit and so on. The last character denotes the state of the most significant bit.

## 输出格式

Print a single integer — the number of bits in the cell which change their state after we add 1 to the cell.

## 说明/提示

In the first sample the cell ends up with value $ 0010 $ , in the second sample — with $ 0000 $ .

## 样例 #1

### 输入

```
4
1100

```

### 输出

```
3

```

## 样例 #2

### 输入

```
4
1111

```

### 输出

```
4

```



---

---
title: "Inbox (100500)"
layout: "post"
diff: 普及-
pid: CF465B
tag: []
---

# Inbox (100500)

## 题目描述

Over time, Alexey's mail box got littered with too many letters. Some of them are read, while others are unread.

Alexey's mail program can either show a list of all letters or show the content of a single letter. As soon as the program shows the content of an unread letter, it becomes read letter (if the program shows the content of a read letter nothing happens). In one click he can do any of the following operations:

- Move from the list of letters to the content of any single letter.
- Return to the list of letters from single letter viewing mode.
- In single letter viewing mode, move to the next or to the previous letter in the list. You cannot move from the first letter to the previous one or from the last letter to the next one.

The program cannot delete the letters from the list or rearrange them.

Alexey wants to read all the unread letters and go watch football. Now he is viewing the list of all letters and for each letter he can see if it is read or unread. What minimum number of operations does Alexey need to perform to read all unread letters?

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=1000 $ ) — the number of letters in the mailbox.

The second line contains $ n $ space-separated integers (zeros and ones) — the state of the letter list. The $ i $ -th number equals either $ 1 $ , if the $ i $ -th number is unread, or $ 0 $ , if the $ i $ -th letter is read.

## 输出格式

Print a single number — the minimum number of operations needed to make all the letters read.

## 说明/提示

In the first sample Alexey needs three operations to cope with the task: open the second letter, move to the third one, move to the fourth one.

In the second sample the action plan: open the first letter, move to the second letter, return to the list, open the fifth letter.

In the third sample all letters are already read.

## 样例 #1

### 输入

```
5
0 1 0 1 0

```

### 输出

```
3

```

## 样例 #2

### 输入

```
5
1 1 0 0 1

```

### 输出

```
4

```

## 样例 #3

### 输入

```
2
0 0

```

### 输出

```
0

```



---

---
title: "Cheap Travel"
layout: "post"
diff: 普及-
pid: CF466A
tag: []
---

# Cheap Travel

## 题目描述

Ann has recently started commuting by subway. We know that a one ride subway ticket costs $ a $ rubles. Besides, Ann found out that she can buy a special ticket for $ m $ rides (she can buy it several times). It costs $ b $ rubles. Ann did the math; she will need to use subway $ n $ times. Help Ann, tell her what is the minimum sum of money she will have to spend to make $ n $ rides?

## 输入格式

The single line contains four space-separated integers $ n $ , $ m $ , $ a $ , $ b $ ( $ 1<=n,m,a,b<=1000 $ ) — the number of rides Ann has planned, the number of rides covered by the $ m $ ride ticket, the price of a one ride ticket and the price of an $ m $ ride ticket.

## 输出格式

Print a single integer — the minimum sum in rubles that Ann will need to spend.

## 说明/提示

In the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three $ m $ ride tickets.

## 样例 #1

### 输入

```
6 2 1 2

```

### 输出

```
6

```

## 样例 #2

### 输入

```
5 2 2 3

```

### 输出

```
8

```



---

---
title: "Fedor and New Game"
layout: "post"
diff: 普及-
pid: CF467B
tag: []
---

# Fedor and New Game

## 题目描述

After you had helped George and Alex to move in the dorm, they went to help their friend Fedor play a new computer game «Call of Soldiers 3».

The game has $ (m+1) $ players and $ n $ types of soldiers in total. Players «Call of Soldiers 3» are numbered form $ 1 $ to $ (m+1) $ . Types of soldiers are numbered from $ 0 $ to $ n-1 $ . Each player has an army. Army of the $ i $ -th player can be described by non-negative integer $ x_{i} $ . Consider binary representation of $ x_{i} $ : if the $ j $ -th bit of number $ x_{i} $ equal to one, then the army of the $ i $ -th player has soldiers of the $ j $ -th type.

Fedor is the $ (m+1) $ -th player of the game. He assume that two players can become friends if their armies differ in at most $ k $ types of soldiers (in other words, binary representations of the corresponding numbers differ in at most $ k $ bits). Help Fedor and count how many players can become his friends.

## 输入格式

The first line contains three integers $ n $ , $ m $ , $ k $ $ (1<=k<=n<=20; 1<=m<=1000) $ .

The $ i $ -th of the next $ (m+1) $ lines contains a single integer $ x_{i} $ $ (1<=x_{i}<=2^{n}-1) $ , that describes the $ i $ -th player's army. We remind you that Fedor is the $ (m+1) $ -th player.

## 输出格式

Print a single integer — the number of Fedor's potential friends.

## 样例 #1

### 输入

```
7 3 1
8
5
111
17

```

### 输出

```
0

```

## 样例 #2

### 输入

```
3 3 3
1
2
3
4

```

### 输出

```
3

```



---

---
title: "I Wanna Be the Guy"
layout: "post"
diff: 普及-
pid: CF469A
tag: []
---

# I Wanna Be the Guy

## 题目描述

There is a game called "I Wanna Be the Guy", consisting of $ n $ levels. Little X and his friend Little Y are addicted to the game. Each of them wants to pass the whole game.

Little X can pass only $ p $ levels of the game. And Little Y can pass only $ q $ levels of the game. You are given the indices of levels Little X can pass and the indices of levels Little Y can pass. Will Little X and Little Y pass the whole game, if they cooperate each other?

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=100 $ ).

The next line contains an integer $ p $ $ (0<=p<=n) $ at first, then follows $ p $ distinct integers $ a_{1},a_{2},...,a_{p} $ $ (1<=a_{i}<=n) $ . These integers denote the indices of levels Little X can pass. The next line contains the levels Little Y can pass in the same format. It's assumed that levels are numbered from 1 to $ n $ .

## 输出格式

If they can pass all the levels, print "I become the guy.". If it's impossible, print "Oh, my keyboard!" (without the quotes).

## 说明/提示

In the first sample, Little X can pass levels \[1 2 3\], and Little Y can pass level \[2 4\], so they can pass all the levels both.

In the second sample, no one can pass level 4.

## 样例 #1

### 输入

```
4
3 1 2 3
2 2 4

```

### 输出

```
I become the guy.

```

## 样例 #2

### 输入

```
4
3 1 2 3
2 2 3

```

### 输出

```
Oh, my keyboard!

```



---

---
title: "Ball Game"
layout: "post"
diff: 普及-
pid: CF46A
tag: []
---

# Ball Game

## 题目描述

原题意

幼儿园老师纳塔利娅帕夫洛夫娜发明了一种新的球类游戏。这场比赛不仅培养了孩子们的体格，还教会了他们如何计数。

游戏如下。孩子们围成一圈。将孩子顺时针编号为1至n的数字，并且孩子1持球

之后有n-1次投球 第i次投球将会把球从持球孩子手中传至持球孩子右边第i个孩子

比如有8个孩子 依次接到球的孩子编号是 2 4 7 3 8 ...

简洁版题意

有数列 $f$ ， $f_0 = 1$ ， $f_i=((f_{i-1}+i-1)\;mod\;n)+1$ 。输出 $f_1$ ~ $f_{n-1}$ 。

## 输入格式

一个整数$n$，表示有$n$个孩子

$2≤n≤100$

## 输出格式

$n-1$个数

表示每次投球接到球孩子的编号，用空格隔开

Translate by @Diex

## 样例 #1

### 输入

```
10

```

### 输出

```
2 4 7 1 6 2 9 7 6

```

## 样例 #2

### 输入

```
3

```

### 输出

```
2 1

```



---

---
title: "T-shirts from Sponsor"
layout: "post"
diff: 普及-
pid: CF46B
tag: []
---

# T-shirts from Sponsor

## 题目描述

某著名比赛的知名赞助商决定给比赛的每个参赛者一件T恤作为礼物。

现在出现了一个问题：一方面，目前尚不清楚应该订购什么尺码的T恤，另一方面，他不想订购太多的T恤。经过大量的脑力训练和一些预估，赞助商订购了一定数量的尺寸为S，M，L，XL和XXL的T恤。T恤最终带来了好运，在比赛那天有一排参与者都想得到一件。

每个参赛者都以Ta期望的T恤尺码为特征（尺寸S，M，L，XL和XXL之一）。参与者一个接一个地拿到T恤。

如果还有适合的尺寸的T恤，那么Ta就会拿走它。否则，参赛者会选择尺寸尽可能接近最佳尺寸的T恤（相邻尺码之间的距离等于1）。如果有多种可供选择，参赛者将选择更大尺寸的T恤。例如，对于最佳大小为L的人，首选项列表如下所示：L，XL，M，XXL，S。

## 输入格式

第一行是5个不超过1000的非负数$N_S,N_M,N_L,N_{XL},N_{XXL}$
为买入数

第二行是K，代表参赛人数

第三行是每人的尺码

$N_{S}+N_{M}+N_{L}+N_{XL}+N_{XXL}>=K$

## 输出格式

一行，每个参赛者获得的衣服的尺码数

## 样例 #1

### 输入

```
1 0 2 0 1
3
XL
XXL
M

```

### 输出

```
XXL
L
L

```



---

---
title: "Hamsters and Tigers"
layout: "post"
diff: 普及-
pid: CF46C
tag: []
---

# Hamsters and Tigers

## 题目描述

**题目大意：**

给你个**环**，环上有$n(2<=n<=1000)$个点，每个点为黑色（题目中的仓鼠）或白色（题目中的老虎），你每次可以交换两个点的位置，求最少交换次数使得黑点白点分离（即黑点连续，中间没有白点）

## 输入格式

第一行为一个整数$n$，表示点数

第二行为一个长度为$n$的字符串，其中$H$表示黑点，$T$表示白点

## 输出格式

一个整数，即最少交换次数

感谢@守望 提供翻译

## 样例 #1

### 输入

```
3
HTH

```

### 输出

```
0

```

## 样例 #2

### 输入

```
9
HTHTHTHHT

```

### 输出

```
2

```



---

---
title: "Bayan Bus"
layout: "post"
diff: 普及-
pid: CF475A
tag: []
---

# Bayan Bus

## 题目描述

The final round of Bayan Programming Contest will be held in Tehran, and the participants will be carried around with a yellow bus. The bus has 34 passenger seats: 4 seats in the last row and 3 seats in remaining rows.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF475A/8bce19353e5f54c2dfc8345d92904e1c0260a14e.png)The event coordinator has a list of $ k $ participants who should be picked up at the airport. When a participant gets on the bus, he will sit in the last row with an empty seat. If there is more than one empty seat in that row, he will take the leftmost one.

In order to keep track of the people who are on the bus, the event coordinator needs a figure showing which seats are going to be taken by $ k $ participants. Your task is to draw the figure representing occupied seats.

## 输入格式

The only line of input contains integer $ k $ , $ (0<=k<=34) $ , denoting the number of participants.

## 输出格式

The final round of Bayan Programming Contest will be held in Tehran, and the participants will be carried around with a yellow bus. The bus has 34 passenger seats: 4 seats in the last row and 3 seats in remaining rows.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF475A/8bce19353e5f54c2dfc8345d92904e1c0260a14e.png)The event coordinator has a list of $ k $ participants who should be picked up at the airport. When a participant gets on the bus, he will sit in the last row with an empty seat. If there is more than one empty seat in that row, he will take the leftmost one.

In order to keep track of the people who are on the bus, the event coordinator needs a figure showing which seats are going to be taken by $ k $ participants. Your task is to draw the figure representing occupied seats.

## 样例 #1

### 输入

```
9

```

### 输出

```
+------------------------+
|O.O.O.#.#.#.#.#.#.#.#.|D|)
|O.O.O.#.#.#.#.#.#.#.#.|.|
|O.......................|
|O.O.#.#.#.#.#.#.#.#.#.|.|)
+------------------------+

```

## 样例 #2

### 输入

```
20

```

### 输出

```
+------------------------+
|O.O.O.O.O.O.O.#.#.#.#.|D|)
|O.O.O.O.O.O.#.#.#.#.#.|.|
|O.......................|
|O.O.O.O.O.O.#.#.#.#.#.|.|)
+------------------------+

```



---

---
title: "Dreamoon and WiFi"
layout: "post"
diff: 普及-
pid: CF476B
tag: []
---

# Dreamoon and WiFi

## 题目描述

Dreamoon is standing at the position $ 0 $ on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types:

1. Go 1 unit towards the positive direction, denoted as '+'
2. Go 1 unit towards the negative direction, denoted as '-'

But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the $ 1 $ unit to the negative or positive direction with the same probability $ 0.5 $ ).

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?

## 输入格式

Dreamoon is standing at the position $ 0 $ on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types:

1. Go 1 unit towards the positive direction, denoted as '+'
2. Go 1 unit towards the negative direction, denoted as '-'

But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the $ 1 $ unit to the negative or positive direction with the same probability $ 0.5 $ ).

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?

## 输出格式

Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed $ 10^{-9} $ .

## 说明/提示

Dreamoon is standing at the position $ 0 $ on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types:

1. Go 1 unit towards the positive direction, denoted as '+'
2. Go 1 unit towards the negative direction, denoted as '-'

But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the $ 1 $ unit to the negative or positive direction with the same probability $ 0.5 $ ).

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?

## 样例 #1

### 输入

```
++-+-
+-+-+

```

### 输出

```
1.000000000000

```

## 样例 #2

### 输入

```
+-+-
+-??

```

### 输出

```
0.500000000000

```

## 样例 #3

### 输入

```
+++
??-

```

### 输出

```
0.000000000000

```



---

---
title: "Initial Bet"
layout: "post"
diff: 普及-
pid: CF478A
tag: []
---

# Initial Bet

## 题目描述

There are five people playing a game called "Generosity". Each person gives some non-zero number of coins $ b $ as an initial bet. After all players make their bets of $ b $ coins, the following operation is repeated for several times: a coin is passed from one player to some other player.

Your task is to write a program that can, given the number of coins each player has at the end of the game, determine the size $ b $ of the initial bet or find out that such outcome of the game cannot be obtained for any positive number of coins $ b $ in the initial bet.

## 输入格式

There are five people playing a game called "Generosity". Each person gives some non-zero number of coins $ b $ as an initial bet. After all players make their bets of $ b $ coins, the following operation is repeated for several times: a coin is passed from one player to some other player.

Your task is to write a program that can, given the number of coins each player has at the end of the game, determine the size $ b $ of the initial bet or find out that such outcome of the game cannot be obtained for any positive number of coins $ b $ in the initial bet.

## 输出格式

Print the only line containing a single positive integer $ b $ — the number of coins in the initial bet of each player. If there is no such value of $ b $ , then print the only value "-1" (quotes for clarity).

## 说明/提示

In the first sample the following sequence of operations is possible:

1. One coin is passed from the fourth player to the second player;
2. One coin is passed from the fourth player to the fifth player;
3. One coin is passed from the first player to the third player;
4. One coin is passed from the fourth player to the second player.

## 样例 #1

### 输入

```
2 5 4 0 4

```

### 输出

```
3

```

## 样例 #2

### 输入

```
4 5 9 2 1

```

### 输出

```
-1

```



---

---
title: "Counterexample"
layout: "post"
diff: 普及-
pid: CF483A
tag: []
---

# Counterexample

## 题目描述

Your friend has recently learned about coprime numbers. A pair of numbers $ {a,b} $ is called coprime if the maximum number that divides both $ a $ and $ b $ is equal to one.

Your friend often comes up with different statements. He has recently supposed that if the pair $ (a,b) $ is coprime and the pair $ (b,c) $ is coprime, then the pair $ (a,c) $ is coprime.

You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers $ (a,b,c) $ , for which the statement is false, and the numbers meet the condition $ l<=a<b<c<=r $ .

More specifically, you need to find three numbers $ (a,b,c) $ , such that $ l<=a<b<c<=r $ , pairs $ (a,b) $ and $ (b,c) $ are coprime, and pair $ (a,c) $ is not coprime.

## 输入格式

The single line contains two positive space-separated integers $ l $ , $ r $ ( $ 1<=l<=r<=10^{18} $ ; $ r-l<=50 $ ).

## 输出格式

Print three positive space-separated integers $ a $ , $ b $ , $ c $ — three distinct numbers $ (a,b,c) $ that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order.

If the counterexample does not exist, print the single number -1.

## 说明/提示

In the first sample pair $ (2,4) $ is not coprime and pairs $ (2,3) $ and $ (3,4) $ are.

In the second sample you cannot form a group of three distinct integers, so the answer is -1.

In the third sample it is easy to see that numbers $ 900000000000000009 $ and $ 900000000000000021 $ are divisible by three.

## 样例 #1

### 输入

```
2 4

```

### 输出

```
2 3 4

```

## 样例 #2

### 输入

```
10 11

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
900000000000000009 900000000000000029

```

### 输出

```
900000000000000009 900000000000000010 900000000000000021

```



---

---
title: "Factory"
layout: "post"
diff: 普及-
pid: CF485A
tag: []
---

# Factory

## 题目描述

有一个工厂，在一天的开始时，共有x条细节（？），在这一天结束时，会生产x mod m条细节。
 
 现在已知第一天所拥有的细节数a，以及m的值
 
请问，是否存在一个时刻，整个工厂会停止生产（x mod m = 0）？

## 输入格式

两个整数，a 和 m

## 输出格式

当生产会停止时，输出`Yes`，否则输出`No`

## 样例 #1

### 输入

```
1 5

```

### 输出

```
No

```

## 样例 #2

### 输入

```
3 6

```

### 输出

```
Yes

```



---

---
title: "Giga Tower"
layout: "post"
diff: 普及-
pid: CF488A
tag: []
---

# Giga Tower

## 题目描述

Giga Tower is the tallest and deepest building in Cyberland. There are $ 17777777777 $ floors, numbered from $ -8888888888 $ to $ 8888888888 $ . In particular, there is floor $ 0 $ between floor $ -1 $ and floor $ 1 $ . Every day, thousands of tourists come to this place to enjoy the wonderful view.

In Cyberland, it is believed that the number "8" is a lucky number (that's why Giga Tower has $ 8888888888 $ floors above the ground), and, an integer is lucky, if and only if its decimal notation contains at least one digit "8". For example, $ 8,-180,808 $ are all lucky while $ 42,-10 $ are not. In the Giga Tower, if you write code at a floor with lucky floor number, good luck will always be with you (Well, this round is #278, also lucky, huh?).

Tourist Henry goes to the tower to seek good luck. Now he is at the floor numbered $ a $ . He wants to find the minimum positive integer $ b $ , such that, if he walks $ b $ floors higher, he will arrive at a floor with a lucky number.

## 输入格式

The only line of input contains an integer $ a $ ( $ -10^{9}<=a<=10^{9} $ ).

## 输出格式

Print the minimum $ b $ in a line.

## 说明/提示

For the first sample, he has to arrive at the floor numbered $ 180 $ .

For the second sample, he will arrive at $ 8 $ .

Note that $ b $ should be positive, so the answer for the third sample is $ 10 $ , not $ 0 $ .

## 样例 #1

### 输入

```
179

```

### 输出

```
1

```

## 样例 #2

### 输入

```
-1

```

### 输出

```
9

```

## 样例 #3

### 输入

```
18

```

### 输出

```
10

```



---

---
title: "Land Lot"
layout: "post"
diff: 普及-
pid: CF48B
tag: []
---

# Land Lot

## 题目描述

Vasya has a beautiful garden where wonderful fruit trees grow and yield fantastic harvest every year. But lately thieves started to sneak into the garden at nights and steal the fruit too often. Vasya can’t spend the nights in the garden and guard the fruit because there’s no house in the garden! Vasya had been saving in for some time and finally he decided to build the house. The rest is simple: he should choose in which part of the garden to build the house. In the evening he sat at his table and drew the garden’s plan. On the plan the garden is represented as a rectangular checkered field $ n×m $ in size divided into squares whose side length is 1. In some squares Vasya marked the trees growing there (one shouldn’t plant the trees too close to each other that’s why one square contains no more than one tree). Vasya wants to find a rectangular land lot $ a×b $ squares in size to build a house on, at that the land lot border should go along the lines of the grid that separates the squares. All the trees that grow on the building lot will have to be chopped off. Vasya loves his garden very much, so help him choose the building land lot location so that the number of chopped trees would be as little as possible.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1<=n,m<=50 $ ) which represent the garden location. The next $ n $ lines contain $ m $ numbers 0 or 1, which describe the garden on the scheme. The zero means that a tree doesn’t grow on this square and the 1 means that there is a growing tree. The last line contains two integers $ a $ and $ b $ ( $ 1<=a,b<=50 $ ). Note that Vasya can choose for building an $ a×b $ rectangle as well a $ b×a $ one, i.e. the side of the lot with the length of $ a $ can be located as parallel to the garden side with the length of $ n $ , as well as parallel to the garden side with the length of $ m $ .

## 输出格式

Print the minimum number of trees that needs to be chopped off to select a land lot $ a×b $ in size to build a house on. It is guaranteed that at least one lot location can always be found, i. e. either $ a<=n $ and $ b<=m $ , or $ a<=m $ и $ b<=n $ .

## 说明/提示

In the second example the upper left square is (1,1) and the lower right is (3,2).

## 样例 #1

### 输入

```
2 2
1 0
1 1
1 1

```

### 输出

```
0

```

## 样例 #2

### 输入

```
4 5
0 0 1 0 1
0 1 1 1 0
1 0 1 0 1
1 1 1 1 1
2 3

```

### 输出

```
2

```



---

---
title: "Up the hill"
layout: "post"
diff: 普及-
pid: CF491A
tag: []
---

# Up the hill

## 题目描述

Hiking club "Up the hill" just returned from a walk. Now they are trying to remember which hills they've just walked through.

It is known that there were $ N $ stops, all on different integer heights between $ 1 $ and $ N $ kilometers (inclusive) above the sea level. On the first day they've traveled from the first stop to the second stop, on the second day they've traveled from the second to the third and so on, and on the last day they've traveled from the stop $ N-1 $ to the stop $ N $ and successfully finished their expedition.

They are trying to find out which heights were their stops located at. They have an entry in a travel journal specifying how many days did they travel up the hill, and how many days did they walk down the hill.

Help them by suggesting some possible stop heights satisfying numbers from the travel journal.

## 输入格式

In the first line there is an integer non-negative number $ A $ denoting the number of days of climbing up the hill. Second line contains an integer non-negative number $ B $ — the number of days of walking down the hill ( $ A+B+1=N $ , $ 1<=N<=100000 $ ).

## 输出格式

Output $ N $ space-separated distinct integers from $ 1 $ to $ N $ inclusive, denoting possible heights of the stops in order of visiting.

## 样例 #1

### 输入

```
0
1

```

### 输出

```
2 1 

```

## 样例 #2

### 输入

```
2
1
```

### 输出

```
1 3 4 2
```



---

---
title: "Vanya and Lanterns"
layout: "post"
diff: 普及-
pid: CF492B
tag: []
---

# Vanya and Lanterns

## 题目描述

Vanya walks late at night along a straight street of length $ l $ , lit by $ n $ lanterns. Consider the coordinate system with the beginning of the street corresponding to the point $ 0 $ , and its end corresponding to the point $ l $ . Then the $ i $ -th lantern is at the point $ a_{i} $ . The lantern lights all points of the street that are at the distance of at most $ d $ from it, where $ d $ is some positive number, common for all lanterns.

Vanya wonders: what is the minimum light radius $ d $ should the lanterns have to light the whole street?

## 输入格式

Vanya walks late at night along a straight street of length $ l $ , lit by $ n $ lanterns. Consider the coordinate system with the beginning of the street corresponding to the point $ 0 $ , and its end corresponding to the point $ l $ . Then the $ i $ -th lantern is at the point $ a_{i} $ . The lantern lights all points of the street that are at the distance of at most $ d $ from it, where $ d $ is some positive number, common for all lanterns.

Vanya wonders: what is the minimum light radius $ d $ should the lanterns have to light the whole street?

## 输出格式

Print the minimum light radius $ d $ , needed to light the whole street. The answer will be considered correct if its absolute or relative error doesn't exceed $ 10^{-9} $ .

## 说明/提示

Vanya walks late at night along a straight street of length $ l $ , lit by $ n $ lanterns. Consider the coordinate system with the beginning of the street corresponding to the point $ 0 $ , and its end corresponding to the point $ l $ . Then the $ i $ -th lantern is at the point $ a_{i} $ . The lantern lights all points of the street that are at the distance of at most $ d $ from it, where $ d $ is some positive number, common for all lanterns.

Vanya wonders: what is the minimum light radius $ d $ should the lanterns have to light the whole street?

## 样例 #1

### 输入

```
7 15
15 5 3 7 9 14 0

```

### 输出

```
2.5000000000

```

## 样例 #2

### 输入

```
2 5
2 5

```

### 输出

```
2.0000000000

```



---

---
title: "Vasya and Wrestling"
layout: "post"
diff: 普及-
pid: CF493B
tag: []
---

# Vasya and Wrestling

## 题目描述

Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.

## 输入格式

Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.

## 输出格式

If the first wrestler wins, print string "first", otherwise print "second"

## 说明/提示

Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.

## 样例 #1

### 输入

```
5
1
2
-3
-4
3

```

### 输出

```
second

```

## 样例 #2

### 输入

```
3
-1
-2
3

```

### 输出

```
first

```

## 样例 #3

### 输入

```
2
4
-4

```

### 输出

```
second

```



---

---
title: "Digital Counter"
layout: "post"
diff: 普及-
pid: CF495A
tag: []
---

# Digital Counter

## 题目描述

Malek lives in an apartment block with $ 100 $ floors numbered from $ 0 $ to $ 99 $ . The apartment has an elevator with a digital counter showing the floor that the elevator is currently on. The elevator shows each digit of a number with $ 7 $ light sticks by turning them on or off. The picture below shows how the elevator shows each digit.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF495A/82c4b2ab842edc90f41be56a97fcef1aaf93be0a.png)One day when Malek wanted to go from floor $ 88 $ to floor $ 0 $ using the elevator he noticed that the counter shows number $ 89 $ instead of $ 88 $ . Then when the elevator started moving the number on the counter changed to $ 87 $ . After a little thinking Malek came to the conclusion that there is only one explanation for this: One of the sticks of the counter was broken. Later that day Malek was thinking about the broken stick and suddenly he came up with the following problem.

Suppose the digital counter is showing number $ n $ . Malek calls an integer $ x $ ( $ 0<=x<=99 $ ) good if it's possible that the digital counter was supposed to show $ x $ but because of some(possibly none) broken sticks it's showing $ n $ instead. Malek wants to know number of good integers for a specific $ n $ . So you must write a program that calculates this number. Please note that the counter always shows two digits.

## 输入格式

The only line of input contains exactly two digits representing number $ n $ ( $ 0<=n<=99 $ ). Note that $ n $ may have a leading zero.

## 输出格式

In the only line of the output print the number of good integers.

## 说明/提示

In the first sample the counter may be supposed to show $ 88 $ or $ 89 $ .

In the second sample the good integers are $ 00 $ , $ 08 $ , $ 80 $ and $ 88 $ .

In the third sample the good integers are $ 03,08,09,33,38,39,73,78,79,83,88,89,93,98,99 $ .

## 样例 #1

### 输入

```
89

```

### 输出

```
2

```

## 样例 #2

### 输入

```
00

```

### 输出

```
4

```

## 样例 #3

### 输入

```
73

```

### 输出

```
15

```



---

---
title: "Minimum Difficulty"
layout: "post"
diff: 普及-
pid: CF496A
tag: []
---

# Minimum Difficulty

## 题目描述

Mike is trying rock climbing but he is awful at it.

There are $ n $ holds on the wall, $ i $ -th hold is at height $ a_{i} $ off the ground. Besides, let the sequence $ a_{i} $ increase, that is, $ a_{i}<a_{i+1} $ for all $ i $ from 1 to $ n-1 $ ; we will call such sequence a track. Mike thinks that the track $ a_{1} $ , ..., $ a_{n} $ has difficulty ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF496A/6c4805b013b934a5f994bca3651000871cc18881.png). In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights $ a_{1} $ , ..., $ a_{n} $ . To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence $ (1,2,3,4,5) $ and remove the third element from it, we obtain the sequence $ (1,2,4,5) $ ). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

## 输入格式

Mike is trying rock climbing but he is awful at it.

There are $ n $ holds on the wall, $ i $ -th hold is at height $ a_{i} $ off the ground. Besides, let the sequence $ a_{i} $ increase, that is, $ a_{i}<a_{i+1} $ for all $ i $ from 1 to $ n-1 $ ; we will call such sequence a track. Mike thinks that the track $ a_{1} $ , ..., $ a_{n} $ has difficulty ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF496A/6c4805b013b934a5f994bca3651000871cc18881.png). In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights $ a_{1} $ , ..., $ a_{n} $ . To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence $ (1,2,3,4,5) $ and remove the third element from it, we obtain the sequence $ (1,2,4,5) $ ). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

## 输出格式

Print a single number — the minimum difficulty of the track after removing a single hold.

## 说明/提示

In the first sample you can remove only the second hold, then the sequence looks like $ (1,6) $ , the maximum difference of the neighboring elements equals 5.

In the second test after removing every hold the difficulty equals 2.

In the third test you can obtain sequences $ (1,3,7,8) $ , $ (1,2,7,8) $ , $ (1,2,3,8) $ , for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.

## 样例 #1

### 输入

```
3
1 4 6

```

### 输出

```
5

```

## 样例 #2

### 输入

```
5
1 2 3 4 5

```

### 输出

```
2

```

## 样例 #3

### 输入

```
5
1 2 3 7 8

```

### 输出

```
4

```



---

---
title: "Lecture"
layout: "post"
diff: 普及-
pid: CF499B
tag: []
---

# Lecture

## 题目描述

你现在有一位新图论教授，你觉得他讲课讲的很好，但他说话实在是太快了，搞得你根本没有时间记笔记。所以呢，你有一个计划来跟上他讲课时的“脚步”，并记下重要的笔记。

你总共会两种语言：A 语言和 B 语言，教授用来讲课的是其中的 A 语言。A 语言和 B 语言有以下共同点：

- 它们都由若干小写字母构成；
- 每个单词里都不包括空格；
- 它们的长度都不超过 10。

另外，可以保证同一种语言中任意两个单词都有不同的拼写，且 A 语言的每一个单词与 B 语言中的每一个单词一一对应。

你的做笔记方式如下：

- 你必须写出写出教授给出的每一个单词；
- 为保证写单词用时最短，你必须要选择两种语言中单词长度更短的一个；
- 如果两个单词的长度一样，为保证讲课的原汁原味，你会选择第一种语言来做笔记。

我们会给你教授的演讲。而你呢，需要编一个程序来写出你的笔记。

## 输入格式

第一行包括两个整数，分别为教授的演讲里有多少个单词的 $n$，还有两种语言中共有多少词汇的 $m$（$1 \leq n \leq 3\,000$，$1 \leq m \leq 3\,000$）

接下来有 $m$ 行，每行两个单词，分别为 $a_i$ 和 $b_i$（两种语言里的单词）

最后一样中有 $n$ 个单词，代表教授的演讲。

## 输出格式

输出 $n$ 个单词，代表按照题目中的规则你记下的笔记。

感谢@deadpool123 提供的翻译

## 样例 #1

### 输入

```
4 3
codeforces codesecrof
contest round
letter message
codeforces contest letter contest

```

### 输出

```
codeforces round letter round

```

## 样例 #2

### 输入

```
5 3
joll wuqrd
euzf un
hbnyiyc rsoqqveh
hbnyiyc joll joll euzf joll

```

### 输出

```
hbnyiyc joll joll un joll

```



---

---
title: "Amr and Music"
layout: "post"
diff: 普及-
pid: CF507A
tag: []
---

# Amr and Music

## 题目描述

给定$n$个物品，装进一个容量为$k$的背包，每个物品的价值为$1$，重量为$c[i]$。

求一种选物品的方案，要求所获得的价值最大（可以不装满背包），要求输出选的物品的编号（任意顺序，本题```SPJ```）

## 输入格式

第一行两个整数$n$，$k$。

第二行$n$个整数，表示每个物品的重量

## 输出格式

输出共两行。

第一行为所选的物品数量。

第二行为所选的物品的编号（任意排列，本题```Special Judge```）

## 样例 #1

### 输入

```
4 10
4 3 1 2

```

### 输出

```
4
1 2 3 4
```

## 样例 #2

### 输入

```
5 6
4 3 1 1 2

```

### 输出

```
3
1 3 4
```

## 样例 #3

### 输入

```
1 3
4

```

### 输出

```
0

```



---

---
title: "Pasha and Pixels"
layout: "post"
diff: 普及-
pid: CF508A
tag: []
---

# Pasha and Pixels

## 题目描述

Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of $ n $ row with $ m $ pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a $ 2×2 $ square consisting of black pixels is formed.

Pasha has made a plan of $ k $ moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers $ i $ and $ j $ , denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the $ 2×2 $ square consisting of black pixels is formed.

## 输入格式

The first line of the input contains three integers $ n,m,k $ ( $ 1<=n,m<=1000 $ , $ 1<=k<=10^{5} $ ) — the number of rows, the number of columns and the number of moves that Pasha is going to perform.

The next $ k $ lines contain Pasha's moves in the order he makes them. Each line contains two integers $ i $ and $ j $ ( $ 1<=i<=n $ , $ 1<=j<=m $ ), representing the row number and column number of the pixel that was painted during a move.

## 输出格式

If Pasha loses, print the number of the move when the $ 2×2 $ square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no $ 2×2 $ square consisting of black pixels is formed during the given $ k $ moves, print $ 0 $ .

## 样例 #1

### 输入

```
2 2 4
1 1
1 2
2 1
2 2

```

### 输出

```
4

```

## 样例 #2

### 输入

```
2 3 6
2 3
2 2
1 3
2 2
1 2
1 1

```

### 输出

```
5

```

## 样例 #3

### 输入

```
5 3 7
2 3
1 2
1 1
4 1
3 1
5 3
3 2

```

### 输出

```
0

```



---

---
title: "Anton and currency you all know"
layout: "post"
diff: 普及-
pid: CF508B
tag: []
---

# Anton and currency you all know

## 题目描述

Berland, 2016. The exchange rate of currency you all know against the burle has increased so much that to simplify the calculations, its fractional part was neglected and the exchange rate is now assumed to be an integer.

Reliable sources have informed the financier Anton of some information about the exchange rate of currency you all know against the burle for tomorrow. Now Anton knows that tomorrow the exchange rate will be an even number, which can be obtained from the present rate by swapping exactly two distinct digits in it. Of all the possible values that meet these conditions, the exchange rate for tomorrow will be the maximum possible. It is guaranteed that today the exchange rate is an odd positive integer $ n $ . Help Anton to determine the exchange rate of currency you all know for tomorrow!

## 输入格式

The first line contains an odd positive integer $ n $ — the exchange rate of currency you all know for today. The length of number $ n $ 's representation is within range from $ 2 $ to $ 10^{5} $ , inclusive. The representation of $ n $ doesn't contain any leading zeroes.

## 输出格式

If the information about tomorrow's exchange rate is inconsistent, that is, there is no integer that meets the condition, print $ -1 $ .

Otherwise, print the exchange rate of currency you all know against the burle for tomorrow. This should be the maximum possible number of those that are even and that are obtained from today's exchange rate by swapping exactly two digits. Exchange rate representation should not contain leading zeroes.

## 样例 #1

### 输入

```
527

```

### 输出

```
572

```

## 样例 #2

### 输入

```
4573

```

### 输出

```
3574

```

## 样例 #3

### 输入

```
1357997531

```

### 输出

```
-1

```



---

---
title: "Choosing Symbol Pairs"
layout: "post"
diff: 普及-
pid: CF50B
tag: []
---

# Choosing Symbol Pairs

## 题目描述

There is a given string $ S $ consisting of $ N $ symbols. Your task is to find the number of ordered pairs of integers $ i $ and $ j $ such that

1\. $ 1<=i,j<=N $

2\. $ S[i]=S[j] $ , that is the $ i $ -th symbol of string $ S $ is equal to the $ j $ -th.

## 输入格式

The single input line contains $ S $ , consisting of lowercase Latin letters and digits. It is guaranteed that string $ S $ in not empty and its length does not exceed $ 10^{5} $ .

## 输出格式

Print a single number which represents the number of pairs $ i $ and $ j $ with the needed property. Pairs $ (x,y) $ and $ (y,x) $ should be considered different, i.e. the ordered pairs count.

## 样例 #1

### 输入

```
great10

```

### 输出

```
7

```

## 样例 #2

### 输入

```
aaaaaaaaaa

```

### 输出

```
100

```



---

---
title: "Permutations"
layout: "post"
diff: 普及-
pid: CF513B1
tag: []
---

# Permutations

## 题目描述

You are given a permutation $ p $ of numbers $ 1,2,...,n $ . Let's define $ f(p) $ as the following sum:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF513B1/01b3997850b3844bd3627bf7c28ebf2176a4c489.png)Find the lexicographically $ m $ -th permutation of length $ n $ in the set of permutations having the maximum possible value of $ f(p) $ .

## 输入格式

The single line of input contains two integers $ n $ and $ m $ ( $ 1<=m<=cnt_{n} $ ), where $ cnt_{n} $ is the number of permutations of length $ n $ with maximum possible value of $ f(p) $ .

The problem consists of two subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.

- In subproblem B1 ( $ 3 $ points), the constraint $ 1<=n<=8 $ will hold.
- In subproblem B2 ( $ 4 $ points), the constraint $ 1<=n<=50 $ will hold.

## 输出格式

Output $ n $ number forming the required permutation.

## 说明/提示

In the first example, both permutations of numbers {1, 2} yield maximum possible $ f(p) $ which is equal to 4. Among them, $ (2,1) $ comes second in lexicographical order.

## 样例 #1

### 输入

```
2 2

```

### 输出

```
2 1 

```

## 样例 #2

### 输入

```
3 2

```

### 输出

```
1 3 2 

```



---

---
title: "Drazil and Date"
layout: "post"
diff: 普及-
pid: CF515A
tag: []
---

# Drazil and Date

## 题目描述

Someday, Drazil wanted to go on date with Varda. Drazil and Varda live on Cartesian plane. Drazil's home is located in point $ (0,0) $ and Varda's home is located in point $ (a,b) $ . In each step, he can move in a unit distance in horizontal or vertical direction. In other words, from position $ (x,y) $ he can go to positions $ (x+1,y) $ , $ (x-1,y) $ , $ (x,y+1) $ or $ (x,y-1) $ .

Unfortunately, Drazil doesn't have sense of direction. So he randomly chooses the direction he will go to in each step. He may accidentally return back to his house during his travel. Drazil may even not notice that he has arrived to $ (a,b) $ and continue travelling.

Luckily, Drazil arrived to the position $ (a,b) $ successfully. Drazil said to Varda: "It took me exactly $ s $ steps to travel from my house to yours". But Varda is confused about his words, she is not sure that it is possible to get from $ (0,0) $ to $ (a,b) $ in exactly $ s $ steps. Can you find out if it is possible for Varda?

## 输入格式

You are given three integers $ a $ , $ b $ , and $ s $ ( $ -10^{9}<=a,b<=10^{9} $ , $ 1<=s<=2·10^{9} $ ) in a single line.

## 输出格式

If you think Drazil made a mistake and it is impossible to take exactly $ s $ steps and get from his home to Varda's home, print "No" (without quotes).

Otherwise, print "Yes".

## 说明/提示

In fourth sample case one possible route is: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF515A/c7eeb592e99c054b70275e1c11760c4bf457a818.png).

## 样例 #1

### 输入

```
5 5 11

```

### 输出

```
No

```

## 样例 #2

### 输入

```
10 15 25

```

### 输出

```
Yes

```

## 样例 #3

### 输入

```
0 5 1

```

### 输出

```
No

```

## 样例 #4

### 输入

```
0 0 2

```

### 输出

```
Yes

```



---

---
title: "A and B and Compilation Errors"
layout: "post"
diff: 普及-
pid: CF519B
tag: []
---

# A and B and Compilation Errors

## 题目描述

A和B在准备他们的编程比赛。

B十分喜欢调试他的代码，但在他让程序输出结果并开始调试之前，他必须先编译他的代码。

最初，编译器显示了nnn 处编译错误，每一处被描述为一个正整数。经过不懈的努力，B就能够修复一个错误然后再去修复另一个。

然而，尽管事实上B的确修复了两个错误，但他无法准确地记住哪些编译上的错误消失了——B所使用的编译器每次输出的剩下的编译错误的顺序是不定的！B明白，不像其它的编程语言，他编程中的某一个编译错误与其它的错误无关，也就是说，修正了一个错误之后，其它的错误依旧存在，不会被修正。

你能帮助B找出他修正了哪两个错误吗？（只有两个）

## 输入格式

第一行包括一个整数n （$3<=n<=10^5$），表示最初有多少个编译错误。

第二行包括n个整数，输入时用空格隔开：$a_{1},a_{2},...,a_{n}(1<=a_{i}<=10^9)$ ——表示所有最初编译器输出的编译错误。

第三行包括n−1个整数：$b_{1},b_{2},...,b_{n-1}$——表示B消除一个错误之后，编译器展示出的编译错误。数据保证第三行的序列包括第二列的数中除消除的数（或编译错误）外的所有数。

第四行包括n−2个整数：$c_{1},c_{2},...,c_{n-2}$ ——表示B再消除一个错误之后，编译器展示出的编译错误。数据保证第四行的序列包括第三列中的书中除消除的数（或编译错误）外的所有数。

（以上如有不懂的看样例总能明白!!!）

## 输出格式

两行，每行一个数，分别代表B第一次和第二次消除的错误。

感谢lonelysir 提供的翻译

## 样例 #1

### 输入

```
5
1 5 8 123 7
123 7 5 1
5 1 7

```

### 输出

```
8
123

```

## 样例 #2

### 输入

```
6
1 4 3 3 5 7
3 7 5 4 3
4 3 7 5

```

### 输出

```
1
3

```



---

---
title: "A and B and Team Training"
layout: "post"
diff: 普及-
pid: CF519C
tag: []
---

# A and B and Team Training

## 题目描述

A和B正在准备编程比赛。

准备比赛中十分重要的一环即是让编程老手们向新手们传授经验。所以，在下一次团队训练中，A决定将成员分组，使新手和老手一起面对和解决问题。

A认为一个合理的分组由一个老手和两个新手构成。这样，老手们就可以向尽可能多的人传授他们的知识。

B认为一个合理的分组由两个老手和一个新手构成。这样，新手们就可以增长见识，更多地提升能力。

于是，A和B经过商议决定，每一个分组都必须是以上两种分组的一种，同时分出的组要尽量多。

现在我们知道一共有$n$ 位编程老手，$m$ 位新手，那么最多可以分成多少组呢？

## 输入格式

一行，输入编程老手数量$n$ ，新手数量$m$ ，中间含空格$$(0<=n,m<=500000)$$

## 输出格式

一行，表示最多的分组数。

## 说明/提示

只作注释：XP为老手，NB为新手。

感谢@lonelysir 提供的翻译

## 样例 #1

### 输入

```
2 6

```

### 输出

```
2

```

## 样例 #2

### 输入

```
4 5

```

### 输出

```
3

```



---

---
title: "Cheaterius's Problem"
layout: "post"
diff: 普及-
pid: CF51A
tag: []
---

# Cheaterius's Problem

## 题目描述

Cheaterius is a famous in all the Berland astrologist, magician and wizard, and he also is a liar and a cheater. One of his latest inventions is Cheaterius' amulets! They bring luck and wealth, but are rather expensive. Cheaterius makes them himself. The technology of their making is kept secret. But we know that throughout long nights Cheaterius glues together domino pairs with super glue to get squares $ 2×2 $ which are the Cheaterius' magic amulets!

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF51A/5f1914bbdaa36d78b7400d8ccae8395b8432e5c5.png)That's what one of Cheaterius's amulets looks likeAfter a hard night Cheaterius made $ n $ amulets. Everyone of them represents a square $ 2×2 $ , every quarter contains 1 to 6 dots. Now he wants sort them into piles, every pile must contain similar amulets. Two amulets are called similar if they can be rotated by 90, 180 or 270 degrees so that the following condition is met: the numbers of dots in the corresponding quarters should be the same. It is forbidden to turn over the amulets.

Write a program that by the given amulets will find the number of piles on Cheaterius' desk.

## 输入格式

The first line contains an integer $ n $ ( $ 1<=n<=1000 $ ), where $ n $ is the number of amulets. Then the amulet's descriptions are contained. Every description occupies two lines and contains two numbers (from 1 to 6) in each line. Between every pair of amulets the line "\*\*" is located.

## 输出格式

Print the required number of piles.

## 样例 #1

### 输入

```
4
31
23
**
31
23
**
13
32
**
32
13

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4
51
26
**
54
35
**
25
61
**
45
53

```

### 输出

```
2

```



---

---
title: "Photo to Remember"
layout: "post"
diff: 普及-
pid: CF522B
tag: []
---

# Photo to Remember

## 题目描述

One day $ n $ friends met at a party, they hadn't seen each other for a long time and so they decided to make a group photo together.

Simply speaking, the process of taking photos can be described as follows. On the photo, each photographed friend occupies a rectangle of pixels: the $ i $ -th of them occupies the rectangle of width $ w_{i} $ pixels and height $ h_{i} $ pixels. On the group photo everybody stands in a line, thus the minimum pixel size of the photo including all the photographed friends, is $ W×H $ , where $ W $ is the total sum of all widths and $ H $ is the maximum height of all the photographed friends.

As is usually the case, the friends made $ n $ photos — the $ j $ -th ( $ 1<=j<=n $ ) photo had everybody except for the $ j $ -th friend as he was the photographer.

Print the minimum size of each made photo in pixels.

## 输入格式

The first line contains integer $ n $ ( $ 2<=n<=200000 $ ) — the number of friends.

Then $ n $ lines follow: the $ i $ -th line contains information about the $ i $ -th friend. The line contains a pair of integers $ w_{i},h_{i} $ ( $ 1<=w_{i}<=10,1<=h_{i}<=1000 $ ) — the width and height in pixels of the corresponding rectangle.

## 输出格式

Print $ n $ space-separated numbers $ b_{1},b_{2},...,b_{n} $ , where $ b_{i} $ — the total number of pixels on the minimum photo containing all friends expect for the $ i $ -th one.

## 样例 #1

### 输入

```
3
1 10
5 5
10 1

```

### 输出

```
75 110 60 
```

## 样例 #2

### 输入

```
3
2 1
1 2
2 1

```

### 输出

```
6 4 6 
```



---

---
title: "Statistics of Recompressing Videos"
layout: "post"
diff: 普及-
pid: CF523D
tag: []
---

# Statistics of Recompressing Videos

## 题目描述

A social network for dogs called DH (DogHouse) has $ k $ special servers to recompress uploaded videos of cute cats. After each video is uploaded, it should be recompressed on one (any) of the servers, and only after that it can be saved in the social network.

We know that each server takes one second to recompress a one minute fragment. Thus, any server takes $ m $ seconds to recompress a $ m $ minute video.

We know the time when each of the $ n $ videos were uploaded to the network (in seconds starting from the moment all servers started working). All videos appear at different moments of time and they are recompressed in the order they appear. If some video appeared at time $ s $ , then its recompressing can start at that very moment, immediately. Some videos can await recompressing when all the servers are busy. In this case, as soon as a server is available, it immediately starts recompressing another video. The videos that await recompressing go in a queue. If by the moment the videos started being recompressed some servers are available, then any of them starts recompressing the video.

For each video find the moment it stops being recompressed.

## 输入格式

The first line of the input contains integers $ n $ and $ k $ ( $ 1<=n,k<=5·10^{5} $ ) — the number of videos and servers, respectively.

Next $ n $ lines contain the descriptions of the videos as pairs of integers $ s_{i},m_{i} $ ( $ 1<=s_{i},m_{i}<=10^{9} $ ), where $ s_{i} $ is the time in seconds when the $ i $ -th video appeared and $ m_{i} $ is its duration in minutes. It is guaranteed that all the $ s_{i} $ 's are distinct and the videos are given in the chronological order of upload, that is in the order of increasing $ s_{i} $ .

## 输出格式

Print $ n $ numbers $ e_{1},e_{2},...,e_{n} $ , where $ e_{i} $ is the time in seconds after the servers start working, when the $ i $ -th video will be recompressed.

## 样例 #1

### 输入

```
3 2
1 5
2 5
3 5

```

### 输出

```
6
7
11

```

## 样例 #2

### 输入

```
6 1
1 1000000000
2 1000000000
3 1000000000
4 1000000000
5 1000000000
6 3

```

### 输出

```
1000000001
2000000001
3000000001
4000000001
5000000001
5000000004

```



---

---
title: "Vitaliy and Pie"
layout: "post"
diff: 普及-
pid: CF525A
tag: []
---

# Vitaliy and Pie

## 题目描述

After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it's not that simple. Vitaly is in the first room of the house with $ n $ room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on — you can go from the ( $ n-1 $ )-th room to the $ n $ -th room. Thus, you can go to room $ x $ only from room $ x-1 $ .

The potato pie is located in the $ n $ -th room and Vitaly needs to go there.

Each pair of consecutive rooms has a door between them. In order to go to room $ x $ from room $ x-1 $ , you need to open the door between the rooms with the corresponding key.

In total the house has several types of doors (represented by uppercase Latin letters) and several types of keys (represented by lowercase Latin letters). The key of type $ t $ can open the door of type $ T $ if and only if $ t $ and $ T $ are the same letter, written in different cases. For example, key f can open door F.

Each of the first $ n-1 $ rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won't get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door.

Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room $ n $ .

Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room $ n $ , which has a delicious potato pie. Write a program that will help Vitaly find out this number.

## 输入格式

The first line of the input contains a positive integer $ n $ ( $ 2<=n<=10^{5} $ ) — the number of rooms in the house.

The second line of the input contains string $ s $ of length $ 2·n-2 $ . Let's number the elements of the string from left to right, starting from one.

The odd positions in the given string $ s $ contain lowercase Latin letters — the types of the keys that lie in the corresponding rooms. Thus, each odd position $ i $ of the given string $ s $ contains a lowercase Latin letter — the type of the key that lies in room number $ (i+1)/2 $ .

The even positions in the given string contain uppercase Latin letters — the types of doors between the rooms. Thus, each even position $ i $ of the given string $ s $ contains an uppercase letter — the type of the door that leads from room $ i/2 $ to room $ i/2+1 $ .

## 输出格式

Print the only integer — the minimum number of keys that Vitaly needs to buy to surely get from room one to room $ n $ .

## 样例 #1

### 输入

```
3
aAbB

```

### 输出

```
0

```

## 样例 #2

### 输入

```
4
aBaCaB

```

### 输出

```
3

```

## 样例 #3

### 输入

```
5
xYyXzZaZ

```

### 输出

```
2

```



---

---
title: "Playing with Paper"
layout: "post"
diff: 普及-
pid: CF527A
tag: []
---

# Playing with Paper

## 题目描述

One day Vasya was sitting on a not so interesting Maths lesson and making an origami from a rectangular $ a $ mm $ × $ $ b $ mm sheet of paper ( $ a>b $ ). Usually the first step in making an origami is making a square piece of paper from the rectangular sheet by folding the sheet along the bisector of the right angle, and cutting the excess part.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF527A/919759a22ff5597b60d204c65faf22c2233113ef.png)After making a paper ship from the square piece, Vasya looked on the remaining $ (a-b) $ mm $ × $ $ b $ mm strip of paper. He got the idea to use this strip of paper in the same way to make an origami, and then use the remainder (if it exists) and so on. At the moment when he is left with a square piece of paper, he will make the last ship from it and stop.

Can you determine how many ships Vasya will make during the lesson?

## 输入格式

The first line of the input contains two integers $ a $ , $ b $ ( $ 1<=b<a<=10^{12} $ ) — the sizes of the original sheet of paper.

## 输出格式

Print a single integer — the number of ships that Vasya will make.

## 说明/提示

Pictures to the first and second sample test.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF527A/8a10deb3e516fda81e76aae552290cb4cf3649c8.png)

## 样例 #1

### 输入

```
2 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
10 7

```

### 输出

```
6

```

## 样例 #3

### 输入

```
1000000000000 1

```

### 输出

```
1000000000000

```



---

---
title: "Exam"
layout: "post"
diff: 普及-
pid: CF534A
tag: []
---

# Exam

## 题目描述

An exam for $ n $ students will take place in a long and narrow room, so the students will sit in a line in some order. The teacher suspects that students with adjacent numbers ( $ i $ and $ i+1 $ ) always studied side by side and became friends and if they take an exam sitting next to each other, they will help each other for sure.

Your task is to choose the maximum number of students and make such an arrangement of students in the room that no two students with adjacent numbers sit side by side.

## 输入格式

A single line contains integer $ n $ ( $ 1<=n<=5000 $ ) — the number of students at an exam.

## 输出格式

In the first line print integer $ k $ — the maximum number of students who can be seated so that no two students with adjacent numbers sit next to each other.

In the second line print $ k $ distinct integers $ a_{1},a_{2},...,a_{k} $ ( $ 1<=a_{i}<=n $ ), where $ a_{i} $ is the number of the student on the $ i $ -th position. The students on adjacent positions mustn't have adjacent numbers. Formally, the following should be true: $ |a_{i}-a_{i+1}|≠1 $ for all $ i $ from $ 1 $ to $ k-1 $ .

If there are several possible answers, output any of them.

## 样例 #1

### 输入

```
6
```

### 输出

```
6
1 5 3 6 2 4
```

## 样例 #2

### 输入

```
3

```

### 输出

```
2
1 3
```



---

---
title: "Tavas and Nafas"
layout: "post"
diff: 普及-
pid: CF535A
tag: []
---

# Tavas and Nafas

## 题目描述

Today Tavas got his test result as an integer score and he wants to share it with his girlfriend, Nafas.

His phone operating system is Tavdroid, and its keyboard doesn't have any digits! He wants to share his score with Nafas via text, so he has no choice but to send this number using words.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF535A/b4f47a55f97fcd02924cac5270349f0616c61519.png)He ate coffee mix without water again, so right now he's really messed up and can't think.

Your task is to help him by telling him what to type.

## 输入格式

The first and only line of input contains an integer $ s $ ( $ 0<=s<=99 $ ), Tavas's score.

## 输出格式

In the first and only line of output, print a single string consisting only from English lowercase letters and hyphens ('-'). Do not use spaces.

## 说明/提示

You can find all you need to know about English numerals in [http://en.wikipedia.org/wiki/English\_numerals](http://en.wikipedia.org/wiki/English_numerals) .

## 样例 #1

### 输入

```
6

```

### 输出

```
six

```

## 样例 #2

### 输入

```
99

```

### 输出

```
ninety-nine

```

## 样例 #3

### 输入

```
20

```

### 输出

```
twenty

```



---

---
title: "Tavas and SaDDas"
layout: "post"
diff: 普及-
pid: CF535B
tag: []
---

# Tavas and SaDDas

## 题目描述

Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: "If you solve the following problem, I'll return it to you."

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF535B/f91fa10ac839dabd2f33826f1fa403b926bbc6c1.png)The problem is:

You are given a lucky number $ n $ . Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

If we sort all lucky numbers in increasing order, what's the 1-based index of $ n $ ?

Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back.

## 输入格式

The first and only line of input contains a lucky number $ n $ ( $ 1<=n<=10^{9} $ ).

## 输出格式

Print the index of $ n $ among all lucky numbers.

## 样例 #1

### 输入

```
4

```

### 输出

```
1

```

## 样例 #2

### 输入

```
7

```

### 输出

```
2

```

## 样例 #3

### 输入

```
77

```

### 输出

```
6

```



---

---
title: "Little Frog"
layout: "post"
diff: 普及-
pid: CF53C
tag: []
---

# Little Frog

## 题目描述

从前一个名叫 Vasya 的小青蛙决定在它家的沼泽里四处旅行。沼泽里有 $n$ 个位于一条线的土堆，相邻的土堆之间的距离是 $1$ 米。Vasya 想在一天内参观所有的土堆；此外，它想每一个都只去一次。为此，它制定了一个路线计划。Vasya 可以选择任何土丘作为起点。同时，它想要任何两次跳跃的路径的长度不同。请你帮助 Vasya 青蛙，完成它的计划。

## 输入格式

输入一个正整数 $n(1\le n\le10^4)$，即土堆的数量。

## 输出格式

输出 $n$ 个正整数 $p_i$（要求$1\le p_i\le n$），表示小青蛙第 $i$ 次跳到第 $p_i$ 个土丘上。如果有多种解决方案，输出任何一个即可。

## 样例 #1

### 输入

```
2

```

### 输出

```
1 2 
```

## 样例 #2

### 输入

```
3

```

### 输出

```
1 3 2 
```



---

---
title: "Sea and Islands"
layout: "post"
diff: 普及-
pid: CF544B
tag: []
---

# Sea and Islands

## 题目描述

A map of some object is a rectangular field consisting of $ n $ rows and $ n $ columns. Each cell is initially occupied by the sea but you can cover some some cells of the map with sand so that exactly $ k $ islands appear on the map. We will call a set of sand cells to be island if it is possible to get from each of them to each of them by moving only through sand cells and by moving from a cell only to a side-adjacent cell. The cells are called to be side-adjacent if they share a vertical or horizontal side. It is easy to see that islands do not share cells (otherwise they together form a bigger island).

Find a way to cover some cells with sand so that exactly $ k $ islands appear on the $ n×n $ map, or determine that no such way exists.

## 输入格式

The single line contains two positive integers $ n $ , $ k $ ( $ 1<=n<=100 $ , $ 0<=k<=n^{2} $ ) — the size of the map and the number of islands you should form.

## 输出格式

If the answer doesn't exist, print "NO" (without the quotes) in a single line.

Otherwise, print "YES" in the first line. In the next $ n $ lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal $ n $ .

If there are multiple answers, you may print any of them.

You should not maximize the sizes of islands.

## 样例 #1

### 输入

```
5 2

```

### 输出

```
YES
SSSSS
LLLLL
SSSSS
LLLLL
SSSSS

```

## 样例 #2

### 输入

```
5 25

```

### 输出

```
NO

```



---

---
title: "Toy Cars"
layout: "post"
diff: 普及-
pid: CF545A
tag: []
---

# Toy Cars

## 题目描述

Little Susie, thanks to her older brother, likes to play with cars. Today she decided to set up a tournament between them. The process of a tournament is described in the next paragraph.

There are $ n $ toy cars. Each pair collides. The result of a collision can be one of the following: no car turned over, one car turned over, both cars turned over. A car is good if it turned over in no collision. The results of the collisions are determined by an $ n×n $ matrix $ А $ : there is a number on the intersection of the $ і $ -th row and $ j $ -th column that describes the result of the collision of the $ і $ -th and the $ j $ -th car:

- $ -1 $ : if this pair of cars never collided. $ -1 $ occurs only on the main diagonal of the matrix.
- $ 0 $ : if no car turned over during the collision.
- $ 1 $ : if only the $ i $ -th car turned over during the collision.
- $ 2 $ : if only the $ j $ -th car turned over during the collision.
- $ 3 $ : if both cars turned over during the collision.

Susie wants to find all the good cars. She quickly determined which cars are good. Can you cope with the task?

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=100 $ ) — the number of cars.

Each of the next $ n $ lines contains $ n $ space-separated integers that determine matrix $ A $ .

It is guaranteed that on the main diagonal there are $ -1 $ , and $ -1 $ doesn't appear anywhere else in the matrix.

It is guaranteed that the input is correct, that is, if $ A_{ij}=1 $ , then $ A_{ji}=2 $ , if $ A_{ij}=3 $ , then $ A_{ji}=3 $ , and if $ A_{ij}=0 $ , then $ A_{ji}=0 $ .

## 输出格式

Print the number of good cars and in the next line print their space-separated indices in the increasing order.

## 样例 #1

### 输入

```
3
-1 0 0
0 -1 1
0 2 -1

```

### 输出

```
2
1 3 
```

## 样例 #2

### 输入

```
4
-1 3 3 3
3 -1 3 3
3 3 -1 3
3 3 3 -1

```

### 输出

```
0

```



---

---
title: "Equidistant String"
layout: "post"
diff: 普及-
pid: CF545B
tag: []
---

# Equidistant String

## 题目描述

Susie 喜欢字符串。她的字符串只包含数字 $0$ 和 $1$。今天，她使用了[汉明距离法](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin)计算了它们之间的距离。

汉明距离的定义表示两个相同长度字符串对应位置的不同字符的数量。

有2个长度为 $n$ 的字符串 $s$ 和 $t$ 她还想要一个长度为 $n$ 的字符串 $p$ 使得 $p$ 到 $s$ 的距离等于 $p$ 到 $t$ 的距离

请你帮她找到这样的字符串 $p$。可能有很多种答案，找到一种即可。

## 输入格式

第一行是字符串 $s$

第二行是字符串 $t$

## 输出格式

输出一行字符串 $p$，如果不存在满足要求的字符串 $p$，输出 `impossible`

## 说明/提示

第一组样例：汉明距离为3

答案也可以为 $1001$

第二组样例：无法找到满足要求的字符串

translated by [Yang080108](https://www.luogu.com.cn/user/422348)

## 样例 #1

### 输入

```
0001
1011

```

### 输出

```
0011

```

## 样例 #2

### 输入

```
000
111

```

### 输出

```
impossible

```



---

---
title: "Mike and Fax"
layout: "post"
diff: 普及-
pid: CF548A
tag: []
---

# Mike and Fax

## 题目描述

While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string $ s $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF548A/8e6eb6a5966077211062d31ebdd4df5e9f389a77.png)He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly $ k $ messages in his own bag, each was a palindrome string and all those strings had the same length.

He asked you to help him and tell him if he has worn his own back-bag. Check if the given string $ s $ is a concatenation of $ k $ palindromes of the same length.

## 输入格式

The first line of input contains string $ s $ containing lowercase English letters ( $ 1<=|s|<=1000 $ ).

The second line contains integer $ k $ ( $ 1<=k<=1000 $ ).

## 输出格式

Print "YES"(without quotes) if he has worn his own back-bag or "NO"(without quotes) otherwise.

## 说明/提示

Palindrome is a string reading the same forward and backward.

In the second sample, the faxes in his back-bag can be "saddas" and "tavvat".

## 样例 #1

### 输入

```
saba
2

```

### 输出

```
NO

```

## 样例 #2

### 输入

```
saddastavvat
2

```

### 输出

```
YES

```



---

---
title: "Presents"
layout: "post"
diff: 普及-
pid: CF54A
tag: []
---

# Presents

## 题目描述

刺猬喜欢给朋友送礼物，但他不喜欢收到礼物。（有钱的刺猬）

所以，刺猬要求你给他写一个程序，计算他在接下来的几天里收到的礼物数。他收到的礼物遵循以下原则：

在每个假日日，刺猬一定会收到礼物
他每K天会收到至少一件礼物（即，如果他在第i天收到了一件礼物，那么他会在i+k天或之前再次收到一见礼物，但在一天里，无论他收到多少礼物，仅被视为收到一件礼物）。
给定的n和k，以及在接下来的n天中的假期列表，请计算刺猬的能获得礼物最少数量。今天的日期视作零，你应该把今天的礼物看作是已经存在的（也就是说，你不应该把它算在答案里）。

## 输出格式

翻译贡献者UID：74874

## 样例 #1

### 输入

```
5 2
1 3

```

### 输出

```
3
```

## 样例 #2

### 输入

```
10 1
3 6 7 8

```

### 输出

```
10
```



---

---
title: "GukiZ and Contest"
layout: "post"
diff: 普及-
pid: CF551A
tag: []
---

# GukiZ and Contest

## 题目描述

GukiZ 喜欢 OI，也喜欢出毒瘤题。他喜欢根据比赛的成绩为选手计算 rating。他现在正在准备一套新的毒瘤题。

一共有 $n$ 名选手被骗来做他的毒瘤题，每一位选手有一个正的 rating。选手们的编号为 $1$ 到 $n$。第 $i$ 名选手的 rating 是 $a_{i}$。比赛还没有开始，GukiZ 开始预测比赛结果。

GukiZ 认为，每名选手的排名应该是 $1 + G$，其中 $G$ 表示 rating 严格比这名选手大的选手数量。也就是说，如果选手 A 的 rating 严格比选手 B 高，他的排名就一定在 B 之上；如果两名选手 rating 相同，那么他们就一定会并列。

然而这件事情几乎不可能发生，但 GukiZ 依然想知道根据他的想法，每名选手的排名。

## 输入格式

输入的第一行包含一个整数 $n$，表示这场比赛的选手数量。

输入的第二行包含 $n$ 个整数 $a_i$ （$1\le a_i\le 2000$），第 $i$ 个整数表示第 $i$ 名选手的 rating。

## 输出格式

输出一行 $n$ 个整数，表示他们的理论排名。


样例解释 1

$2$ 号选手和 $3$ 号选手是第一名（因为没有选手 rating 比他们高），$1$ 号选手第三名（因为两名选手 rating 比他高）。

## 样例 #1

### 输入

```
3
1 3 3

```

### 输出

```
3 1 1

```

## 样例 #2

### 输入

```
1
1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
5
3 5 3 4 5

```

### 输出

```
4 1 4 3 1

```



---

---
title: "Vanya and Table"
layout: "post"
diff: 普及-
pid: CF552A
tag: []
---

# Vanya and Table

## 题目描述

Vanya has a table consisting of $ 100 $ rows, each row contains $ 100 $ cells. The rows are numbered by integers from $ 1 $ to $ 100 $ from bottom to top, the columns are numbered from $ 1 $ to $ 100 $ from left to right.

In this table, Vanya chose $ n $ rectangles with sides that go along borders of squares (some rectangles probably occur multiple times). After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it. Now he wants to find the sum of values in all cells of the table and as the table is too large, he asks you to help him find the result.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=100 $ ) — the number of rectangles.

Each of the following $ n $ lines contains four integers $ x_{1},y_{1},x_{2},y_{2} $ ( $ 1<=x_{1}<=x_{2}<=100 $ , $ 1<=y_{1}<=y_{2}<=100) $ , where $ x_{1} $ and $ y_{1} $ are the number of the column and row of the lower left cell and $ x_{2} $ and $ y_{2} $ are the number of the column and row of the upper right cell of a rectangle.

## 输出格式

In a single line print the sum of all values in the cells of the table.

## 说明/提示

Note to the first sample test:

Values of the table in the first three rows and columns will be as follows:

 $ 121 $

 $ 121 $

 $ 110 $

So, the sum of values will be equal to $ 10 $ .

Note to the second sample test:

Values of the table in the first three rows and columns will be as follows:

 $ 222 $

 $ 222 $

 $ 222 $

So, the sum of values will be equal to $ 18 $ .

## 样例 #1

### 输入

```
2
1 1 2 3
2 2 3 3

```

### 输出

```
10

```

## 样例 #2

### 输入

```
2
1 1 3 3
1 1 3 3

```

### 输出

```
18

```



---

---
title: "Case of Fake Numbers"
layout: "post"
diff: 普及-
pid: CF556B
tag: []
---

# Case of Fake Numbers

## 题目描述

Andrewid the Android is a galaxy-famous detective. He is now investigating a case of frauds who make fake copies of the famous Stolp's gears, puzzles that are as famous as the Rubik's cube once was.

Its most important components are a button and a line of $ n $ similar gears. Each gear has $ n $ teeth containing all numbers from $ 0 $ to $ n-1 $ in the counter-clockwise order. When you push a button, the first gear rotates clockwise, then the second gear rotates counter-clockwise, the the third gear rotates clockwise an so on.

Besides, each gear has exactly one active tooth. When a gear turns, a new active tooth is the one following after the current active tooth according to the direction of the rotation. For example, if $ n=5 $ , and the active tooth is the one containing number $ 0 $ , then clockwise rotation makes the tooth with number $ 1 $ active, or the counter-clockwise rotating makes the tooth number $ 4 $ active.

Andrewid remembers that the real puzzle has the following property: you can push the button multiple times in such a way that in the end the numbers on the active teeth of the gears from first to last form sequence $ 0,1,2,...,n-1 $ . Write a program that determines whether the given puzzle is real or fake.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=1000 $ ) — the number of gears.

The second line contains $ n $ digits $ a_{1},a_{2},...,a_{n} $ ( $ 0<=a_{i}<=n-1 $ ) — the sequence of active teeth: the active tooth of the $ i $ -th gear contains number $ a_{i} $ .

## 输出格式

In a single line print "Yes" (without the quotes), if the given Stolp's gears puzzle is real, and "No" (without the quotes) otherwise.

## 说明/提示

In the first sample test when you push the button for the first time, the sequence of active teeth will be 2 2 1, when you push it for the second time, you get 0 1 2.

## 样例 #1

### 输入

```
3
1 0 0

```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
5
4 2 1 4 3

```

### 输出

```
Yes

```

## 样例 #3

### 输入

```
4
0 2 3 1

```

### 输出

```
No

```



---

---
title: "Ilya and Diplomas"
layout: "post"
diff: 普及-
pid: CF557A
tag: []
---

# Ilya and Diplomas

## 题目描述

不久将在 Berland 举行一场信息奥林匹克竞赛，将有 $n$ 名学生参加。

在奥赛评委会议上，决定根据比赛成绩，为每个参赛者颁发一、二或三等证书。因此，每个学生将获得且只能获得一个证书。

他们还决定一定要颁发至少 $\min_1$ 和至多 $\max_1$ 个一等证书，至少 $\min_2$ 和至多 $\max_2$ 个二等证书，以及至少 $\min_3$ 和至多  $\max_3$ 个三等证书。

经过一番讨论，决定从满足这些限制条件的分配证书的所有选项中选择一种，最大化获得一等证书的学生人数。如果存在多个这样的选项，则选择能最大化获得二等证书的学生人数的选项。如果存在多个这样的选项，则选择能最大化获得三等证书的选项。

你要保证所述限制条件使得可以选择一种分配证书的方式，以便奥林匹克竞赛的所有 $n$ 名参赛者都能获得某个等级的证书。

## 输入格式

输入的第一行包含一个整数 $n$ $（3 \le n\le 3\cdot10^6）$——将参加奥林匹克竞赛的学生人数。

输入的第二行包含两个整数 $\min_1$ 和 $\max_1$$（1\le \min_1 \le \max_1 \le10^6）$——可以分发的一等证书的最低和最高限制。

输入的第三行包含两个整数 $\min_2$ 和 $\max_2$$（1\le \min_2 \le \max_2 \le10^6）$——可以分发的二等证书的最低和最高限制。

输入的第四行包含两个整数 $\min_3$ 和 $\max_3$$（1\le \min_3 \le \max_3 \le10^6）$——可以分发的三等证书的最低和最高限制。

保证 $\min_1+\min_2+\min_3\le n\le\max_1+\max_2+\max_3$。

## 输出格式

在输出的第一行中打印三个数字，表示在最佳的证书分配方案中将授予学生一、二和三等证书的数量。

最佳的证书分配方案是最大化获得一等证书的学生人数的方案。在所有合适的选项中，最佳方案是最大化获得二等证书的学生人数的方案。如果存在多个这样的选项，则最佳方案是最大化获得三等证书的方案。

Translate By @[ZeXic_B](https://www.luogu.com.cn/user/661274)

## 样例 #1

### 输入

```
6
1 5
2 6
3 7

```

### 输出

```
1 2 3 

```

## 样例 #2

### 输入

```
10
1 2
1 3
1 5

```

### 输出

```
2 3 5 

```

## 样例 #3

### 输入

```
6
1 3
2 2
2 2

```

### 输出

```
2 2 2 

```



---

---
title: "Lala Land and Apple Trees"
layout: "post"
diff: 普及-
pid: CF558A
tag: []
---

# Lala Land and Apple Trees

## 题目描述

Amr lives in Lala Land. Lala Land is a very beautiful country that is located on a coordinate line. Lala Land is famous with its apple trees growing everywhere.

Lala Land has exactly $ n $ apple trees. Tree number $ i $ is located in a position $ x_{i} $ and has $ a_{i} $ apples growing on it. Amr wants to collect apples from the apple trees. Amr currently stands in $ x=0 $ position. At the beginning, he can choose whether to go right or left. He'll continue in his direction until he meets an apple tree he didn't visit before. He'll take all of its apples and then reverse his direction, continue walking in this direction until he meets another apple tree he didn't visit before and so on. In the other words, Amr reverses his direction when visiting each new apple tree. Amr will stop collecting apples when there are no more trees he didn't visit in the direction he is facing.

What is the maximum number of apples he can collect?

## 输入格式

The first line contains one number $ n $ ( $ 1<=n<=100 $ ), the number of apple trees in Lala Land.

The following $ n $ lines contains two integers each $ x_{i} $ , $ a_{i} $ ( $ -10^{5}<=x_{i}<=10^{5} $ , $ x_{i}≠0 $ , $ 1<=a_{i}<=10^{5} $ ), representing the position of the $ i $ -th tree and number of apples on it.

It's guaranteed that there is at most one apple tree at each coordinate. It's guaranteed that no tree grows in point $ 0 $ .

## 输出格式

Output the maximum number of apples Amr can collect.

## 说明/提示

In the first sample test it doesn't matter if Amr chose at first to go left or right. In both cases he'll get all the apples.

In the second sample test the optimal solution is to go left to $ x=-1 $ , collect apples from there, then the direction will be reversed, Amr has to go to $ x=1 $ , collect apples from there, then the direction will be reversed and Amr goes to the final tree $ x=-2 $ .

In the third sample test the optimal solution is to go right to $ x=1 $ , collect apples from there, then the direction will be reversed and Amr will not be able to collect anymore apples because there are no apple trees to his left.

## 样例 #1

### 输入

```
2
-1 5
1 5

```

### 输出

```
10
```

## 样例 #2

### 输入

```
3
-2 2
1 4
-1 3

```

### 输出

```
9
```

## 样例 #3

### 输入

```
3
1 9
3 5
7 10

```

### 输出

```
9
```



---

---
title: "Gerald's Hexagon"
layout: "post"
diff: 普及-
pid: CF559A
tag: []
---

# Gerald's Hexagon

## 题目描述

Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF559A/51081de61718bdab7ac2fc919b0406c7c9b3db07.png). Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.

## 输入格式

The first and the single line of the input contains 6 space-separated integers $ a_{1},a_{2},a_{3},a_{4},a_{5} $ and $ a_{6} $ ( $ 1<=a_{i}<=1000 $ ) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.

## 输出格式

Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.

## 说明/提示

This is what Gerald's hexagon looks like in the first sample:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF559A/4ab048b05b556943a01545b02118caaeb324465f.png)

And that's what it looks like in the second sample:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF559A/5870b6c24fc4fc3203a53b2587509290d8665c96.png)

## 样例 #1

### 输入

```
1 1 1 1 1 1

```

### 输出

```
6

```

## 样例 #2

### 输入

```
1 2 1 2 1 2

```

### 输出

```
13

```



---

---
title: "Inventory"
layout: "post"
diff: 普及-
pid: CF569B
tag: []
---

# Inventory

## 题目描述

Companies always have a lot of equipment, furniture and other things. All of them should be tracked. To do this, there is an inventory number assigned with each item. It is much easier to create a database by using those numbers and keep the track of everything.

During an audit, you were surprised to find out that the items are not numbered sequentially, and some items even share the same inventory number! There is an urgent need to fix it. You have chosen to make the numbers of the items sequential, starting with $ 1 $ . Changing a number is quite a time-consuming process, and you would like to make maximum use of the current numbering.

You have been given information on current inventory numbers for $ n $ items in the company. Renumber items so that their inventory numbers form a permutation of numbers from $ 1 $ to $ n $ by changing the number of as few items as possible. Let us remind you that a set of $ n $ numbers forms a permutation if all the numbers are in the range from $ 1 $ to $ n $ , and no two numbers are equal.

## 输入格式

The first line contains a single integer $ n $ — the number of items ( $ 1<=n<=10^{5} $ ).

The second line contains $ n $ numbers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{5} $ ) — the initial inventory numbers of the items.

## 输出格式

Print $ n $ numbers — the final inventory numbers of the items in the order they occur in the input. If there are multiple possible answers, you may print any of them.

## 说明/提示

In the first test the numeration is already a permutation, so there is no need to change anything.

In the second test there are two pairs of equal numbers, in each pair you need to replace one number.

In the third test you need to replace $ 2 $ by $ 1 $ , as the numbering should start from one.

## 样例 #1

### 输入

```
3
1 3 2

```

### 输出

```
1 3 2 

```

## 样例 #2

### 输入

```
4
2 2 3 3

```

### 输出

```
2 1 3 4 

```

## 样例 #3

### 输入

```
1
2

```

### 输出

```
1 

```



---

---
title: "Corporation Mail"
layout: "post"
diff: 普及-
pid: CF56C
tag: []
---

# Corporation Mail

## 题目描述

The Beroil corporation structure is hierarchical, that is it can be represented as a tree. Let's examine the presentation of this structure as follows:

- $ employee $ ::= $ name $ . | $ name $ : $ employee_{1} $ , $ employee_{2} $ , ... , $ employee_{k} $ .
- $ name $ ::= name of an employee

That is, the description of each employee consists of his name, a colon (:), the descriptions of all his subordinates separated by commas, and, finally, a dot. If an employee has no subordinates, then the colon is not present in his description.

For example, line MIKE:MAX.,ARTEM:MIKE..,DMITRY:DMITRY.,DMITRY... is the correct way of recording the structure of a corporation where the director MIKE has subordinates MAX, ARTEM and DMITRY. ARTEM has a subordinate whose name is MIKE, just as the name of his boss and two subordinates of DMITRY are called DMITRY, just like himself.

In the Beroil corporation every employee can only correspond with his subordinates, at that the subordinates are not necessarily direct. Let's call an uncomfortable situation the situation when a person whose name is $ s $ writes a letter to another person whose name is also $ s $ . In the example given above are two such pairs: a pair involving MIKE, and two pairs for DMITRY (a pair for each of his subordinates).

Your task is by the given structure of the corporation to find the number of uncomfortable pairs in it.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF56C/9868b26a06de68925d83118f98afdf9f4510a164.png)

## 输入格式

The first and single line contains the corporation structure which is a string of length from 1 to 1000 characters. It is guaranteed that the description is correct. Every name is a string consisting of capital Latin letters from 1 to 10 symbols in length.

## 输出格式

Print a single number — the number of uncomfortable situations in the company.

## 样例 #1

### 输入

```
MIKE:MAX.,ARTEM:MIKE..,DMITRY:DMITRY.,DMITRY...

```

### 输出

```
3

```

## 样例 #2

### 输入

```
A:A..

```

### 输出

```
1

```

## 样例 #3

### 输入

```
A:C:C:C:C.....

```

### 输出

```
6

```



---

---
title: "Arrays"
layout: "post"
diff: 普及-
pid: CF572A
tag: []
---

# Arrays

## 题目描述

You are given two arrays $ A $ and $ B $ consisting of integers, sorted in non-decreasing order. Check whether it is possible to choose $ k $ numbers in array $ A $ and choose $ m $ numbers in array $ B $ so that any number chosen in the first array is strictly less than any number chosen in the second array.

## 输入格式

The first line contains two integers $ n_{A},n_{B} $ ( $ 1<=n_{A},n_{B}<=10^{5} $ ), separated by a space — the sizes of arrays $ A $ and $ B $ , correspondingly.

The second line contains two integers $ k $ and $ m $ ( $ 1<=k<=n_{A},1<=m<=n_{B} $ ), separated by a space.

The third line contains $ n_{A} $ numbers $ a_{1},a_{2},...\ a_{nA} $ ( $ -10^{9}<=a_{1}<=a_{2}<=...<=a_{nA}<=10^{9} $ ), separated by spaces — elements of array $ A $ .

The fourth line contains $ n_{B} $ integers $ b_{1},b_{2},...\ b_{nB} $ ( $ -10^{9}<=b_{1}<=b_{2}<=...<=b_{nB}<=10^{9} $ ), separated by spaces — elements of array $ B $ .

## 输出格式

Print "YES" (without the quotes), if you can choose $ k $ numbers in array $ A $ and $ m $ numbers in array $ B $ so that any number chosen in array $ A $ was strictly less than any number chosen in array $ B $ . Otherwise, print "NO" (without the quotes).

## 说明/提示

In the first sample test you can, for example, choose numbers 1 and 2 from array $ A $ and number 3 from array $ B $ (1 < 3 and 2 < 3).

In the second sample test the only way to choose $ k $ elements in the first array and $ m $ elements in the second one is to choose all numbers in both arrays, but then not all the numbers chosen in $ A $ will be less than all the numbers chosen in $ B $ : ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF572A/8f3fbb0b873bf77b8e348f9f28840bbc5c624918.png).

## 样例 #1

### 输入

```
3 3
2 1
1 2 3
3 4 5

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3 3
3 3
1 2 3
3 4 5

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
5 2
3 1
1 1 1 1 1
2 2

```

### 输出

```
YES

```



---

---
title: "Martian Architecture"
layout: "post"
diff: 普及-
pid: CF57B
tag: []
---

# Martian Architecture

## 题目描述

Chris the Rabbit found the traces of an ancient Martian civilization. The brave astronomer managed to see through a small telescope an architecture masterpiece — "A Road to the Sun". The building stands on cubical stones of the same size. The foundation divides the entire "road" into cells, into which the cubical stones are fit tightly. Thus, to any cell of the foundation a coordinate can be assigned. To become the leader of the tribe, a Martian should build a Road to the Sun, that is to build from those cubical stones on a given foundation a stairway. The stairway should be described by the number of stones in the initial coordinate and the coordinates of the stairway's beginning and end. Each following cell in the coordinate's increasing order should contain one cubical stone more than the previous one. At that if the cell has already got stones, they do not count in this building process, the stairways were simply built on them. In other words, let us assume that a stairway is built with the initial coordinate of $ l $ , the final coordinate of $ r $ and the number of stones in the initial coordinate $ x $ . That means that $ x $ stones will be added in the cell $ l $ , $ x+1 $ stones will be added in the cell $ l+1 $ , ..., $ x+r-l $ stones will be added in the cell $ r $ .

Chris managed to find an ancient manuscript, containing the descriptions of all the stairways. Now he wants to compare the data to be sure that he has really found "A Road to the Sun". For that he chose some road cells and counted the total number of cubical stones that has been accumulated throughout the Martian history and then asked you to count using the manuscript to what the sum should ideally total.

## 输入格式

The first line contains three space-separated integers: $ n,m,k $ ( $ 1<=n,m<=10^{5},1<=k<=min(n,100) $ ) which is the number of cells, the number of "Roads to the Sun" and the number of cells in the query correspondingly. Each of the following $ m $ roads contain three space-separated integers: $ a_{i},b_{i},c_{i} $ ( $ 1<=a_{i}<=b_{i}<=n,1<=c_{i}<=1000 $ ) which are the stairway's description, its beginning, end and the initial cell's height. Then follow a line, containing $ k $ different space-separated integers $ b_{i} $ . All these numbers ranging from $ 1 $ to $ n $ are cells, the number of stones in which interests Chris.

## 输出格式

You have to print a single number on a single line which is the sum of stones in all the cells Chris is interested in.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).

## 样例 #1

### 输入

```
5 2 1
1 5 1
2 4 1
3

```

### 输出

```
5

```

## 样例 #2

### 输入

```
3 2 1
1 3 1
1 3 1
2

```

### 输出

```
4

```

## 样例 #3

### 输入

```
3 2 1
1 3 1
1 3 1
3

```

### 输出

```
6

```



---

---
title: "Asphalting Roads"
layout: "post"
diff: 普及-
pid: CF583A
tag: []
---

# Asphalting Roads

## 题目描述

有一个边长为$n$的正方形的城市，一个小组要在这个城市的路上铺上柏油路。一共要进行$n^2$天，小组第$i$天要铺两条道路$h_i$和$v_i$。如果当天要铺的两条路道路都没被铺过则将这两条道路铺上柏油路，否则则什么都不干。根据施工的时间表，告诉这条道路将在哪几天里被铺上柏油路。

## 输入格式

第一行一个数n$(1<=n<=50)$，表示城市的边长

接下来的$n^2$行每行两个数，表示$h_i$和$v_i$$(1<=h_i,v_i<=n) $

## 输出格式

一行若干个数，哪几天里会被铺上柏油路（天数从1开始算）

#### Translate by @zky06

## 样例 #1

### 输入

```
2
1 1
1 2
2 1
2 2

```

### 输出

```
1 4 

```

## 样例 #2

### 输入

```
1
1 1

```

### 输出

```
1 

```



---

---
title: "Robot's Task"
layout: "post"
diff: 普及-
pid: CF583B
tag: []
---

# Robot's Task

## 题目描述

Robot Doc is located in the hall, with $ n $ computers stand in a line, numbered from left to right from $ 1 $ to $ n $ . Each computer contains exactly one piece of information, each of which Doc wants to get eventually. The computers are equipped with a security system, so to crack the $ i $ -th of them, the robot needs to collect at least $ a_{i} $ any pieces of information from the other computers. Doc can hack the computer only if he is right next to it.

The robot is assembled using modern technologies and can move along the line of computers in either of the two possible directions, but the change of direction requires a large amount of resources from Doc. Tell the minimum number of changes of direction, which the robot will have to make to collect all $ n $ parts of information if initially it is next to computer with number $ 1 $ .

It is guaranteed that there exists at least one sequence of the robot's actions, which leads to the collection of all information. Initially Doc doesn't have any pieces of information.

## 输入格式

The first line contains number $ n $ ( $ 1<=n<=1000 $ ). The second line contains $ n $ non-negative integers $ a_{1},a_{2},...,a_{n} $ ( $ 0<=a_{i}&lt;n $ ), separated by a space. It is guaranteed that there exists a way for robot to collect all pieces of the information.

## 输出格式

Print a single number — the minimum number of changes in direction that the robot will have to make in order to collect all $ n $ parts of information.

## 说明/提示

In the first sample you can assemble all the pieces of information in the optimal manner by assembling first the piece of information in the first computer, then in the third one, then change direction and move to the second one, and then, having 2 pieces of information, collect the last piece.

In the second sample to collect all the pieces of information in the optimal manner, Doc can go to the fourth computer and get the piece of information, then go to the fifth computer with one piece and get another one, then go to the second computer in the same manner, then to the third one and finally, to the first one. Changes of direction will take place before moving from the fifth to the second computer, then from the second to the third computer, then from the third to the first computer.

In the third sample the optimal order of collecting parts from computers can look like that: 1->3->4->6->2->5->7.

## 样例 #1

### 输入

```
3
0 2 0

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
4 2 3 0 1

```

### 输出

```
3

```

## 样例 #3

### 输入

```
7
0 3 1 0 5 2 6

```

### 输出

```
2

```



---

---
title: "Alena's Schedule"
layout: "post"
diff: 普及-
pid: CF586A
tag: []
---

# Alena's Schedule

## 题目描述

Alena has successfully passed the entrance exams to the university and is now looking forward to start studying.

One two-hour lesson at the Russian university is traditionally called a pair, it lasts for two academic hours (an academic hour is equal to 45 minutes).

The University works in such a way that every day it holds exactly $ n $ lessons. Depending on the schedule of a particular group of students, on a given day, some pairs may actually contain classes, but some may be empty (such pairs are called breaks).

The official website of the university has already published the schedule for tomorrow for Alena's group. Thus, for each of the $ n $ pairs she knows if there will be a class at that time or not.

Alena's House is far from the university, so if there are breaks, she doesn't always go home. Alena has time to go home only if the break consists of at least two free pairs in a row, otherwise she waits for the next pair at the university.

Of course, Alena does not want to be sleepy during pairs, so she will sleep as long as possible, and will only come to the first pair that is presented in her schedule. Similarly, if there are no more pairs, then Alena immediately goes home.

Alena appreciates the time spent at home, so she always goes home when it is possible, and returns to the university only at the beginning of the next pair. Help Alena determine for how many pairs she will stay at the university. Note that during some pairs Alena may be at the university waiting for the upcoming pair.

## 输入格式

The first line of the input contains a positive integer $ n $ ( $ 1<=n<=100 $ ) — the number of lessons at the university.

The second line contains $ n $ numbers $ a_{i} $ ( $ 0<=a_{i}<=1 $ ). Number $ a_{i} $ equals $ 0 $ , if Alena doesn't have the $ i $ -th pairs, otherwise it is equal to $ 1 $ . Numbers $ a_{1},a_{2},...,a_{n} $ are separated by spaces.

## 输出格式

Print a single number — the number of pairs during which Alena stays at the university.

## 说明/提示

In the first sample Alena stays at the university from the second to the fifth pair, inclusive, during the third pair she will be it the university waiting for the next pair.

In the last sample Alena doesn't have a single pair, so she spends all the time at home.

## 样例 #1

### 输入

```
5
0 1 0 1 1

```

### 输出

```
4

```

## 样例 #2

### 输入

```
7
1 0 1 0 0 1 0

```

### 输出

```
4

```

## 样例 #3

### 输入

```
1
0

```

### 输出

```
0

```



---

---
title: "Duff and Meat"
layout: "post"
diff: 普及-
pid: CF588A
tag: []
---

# Duff and Meat

## 题目描述

Duff is addicted to meat! Malek wants to keep her happy for $ n $ days. In order to be happy in $ i $ -th day, she needs to eat exactly $ a_{i} $ kilograms of meat.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF588A/e0a1a4af93fd8d07e258d5dc1cd3e48db986dfbc.png)There is a big shop uptown and Malek wants to buy meat for her from there. In $ i $ -th day, they sell meat for $ p_{i} $ dollars per kilogram. Malek knows all numbers $ a_{1},...,a_{n} $ and $ p_{1},...,p_{n} $ . In each day, he can buy arbitrary amount of meat, also he can keep some meat he has for the future.

Malek is a little tired from cooking meat, so he asked for your help. Help him to minimize the total money he spends to keep Duff happy for $ n $ days.

## 输入格式

The first line of input contains integer $ n $ ( $ 1<=n<=10^{5} $ ), the number of days.

In the next $ n $ lines, $ i $ -th line contains two integers $ a_{i} $ and $ p_{i} $ ( $ 1<=a_{i},p_{i}<=100 $ ), the amount of meat Duff needs and the cost of meat in that day.

## 输出格式

Print the minimum money needed to keep Duff happy for $ n $ days, in one line.

## 说明/提示

In the first sample case: An optimal way would be to buy 1 kg on the first day, 2 kg on the second day and 3 kg on the third day.

In the second sample case: An optimal way would be to buy 1 kg on the first day and 5 kg (needed meat for the second and third day) on the second day.

## 样例 #1

### 输入

```
3
1 3
2 2
3 1

```

### 输出

```
10

```

## 样例 #2

### 输入

```
3
1 3
2 1
3 2

```

### 输出

```
8

```



---

---
title: "Calendar"
layout: "post"
diff: 普及-
pid: CF58D
tag: []
---

# Calendar

## 题目描述

BerOilGasDiamondBank has branches in $ n $ cities, at that $ n $ is an even number. The bank management wants to publish a calendar with the names of all those cities written in two columns: the calendar should consist of exactly $ n/2 $ lines of strictly equal length, each of which contains exactly two names and exactly one separator character between them. The name of every city should be used in the calendar exactly once. For historical reasons the symbol $ d $ is used as the separator of words in the calendar.

The BerOilGasDiamondBank management wants to show that all its branches are equally important to it, that's why the order of their appearance in the calendar should be following: if we "glue"(concatinate) all the $ n/2 $ calendar lines (from top to bottom) to make a single line, then the lexicographically minimal line is obtained. No separator character will be used to separate calendar lines. For example, if the lines are "bertown!berville", "newberville!bera", then the resulting line is "bertown!bervillenewberville!bera". In some sense one has to find the lexicographically minimal calendar, where the comparison of calendars happens line by line.

Help BerOilGasDiamondBank and construct the required calendar.

## 输入格式

The first line contains an integer $ n $ ( $ 1<=n<=10^{4} $ , $ n $ is even) which is the number of branches. Then follow $ n $ lines which are the names of the cities. All the names consist of lowercase Latin letters; their lengths are no less than 1 and no more than 10 symbols. The next line contains a single symbol $ d $ ( $ d $ has an ASCII-code from 33 to 126 inclusively, excluding lowercase Latin letters) which is the separator between words in the calendar lines. It is guaranteed that the calendar is possible to be constructed and all the names are different.

## 输出格式

Print $ n/2 $ lines of similar length which are the required calendar. Every line should contain exactly two words and exactly one separator between them. If there are several solutions, print the lexicographically minimal one. The lexicographical comparison of lines is realized by the "<" operator in the modern programming languages.

## 样例 #1

### 输入

```
4
b
aa
hg
c
.

```

### 输出

```
aa.b
c.hg

```

## 样例 #2

### 输入

```
2
aa
a
!

```

### 输出

```
a!aa

```

## 样例 #3

### 输入

```
2
aa
a
|

```

### 输出

```
aa|a

```



---

---
title: "The Monster and the Squirrel"
layout: "post"
diff: 普及-
pid: CF592B
tag: []
---

# The Monster and the Squirrel

## 题目描述

### 题目概要

有一个正n多边形，每个顶点从1到n标号，从顶点1开始，向每个顶点的方向上绘制一条线。线到达顶点或与之前绘制的另一条线相交时停止。你需要经过所有线划分成的区域，当你在一个区域时，当且仅当另一个区域与你所在的区域共边时，你才能到这个区域，求你最少需要穿过几次所画的线。

## 输入格式

一个整数，表示n。

## 输出格式

一个整数，表示最少穿过画的线的次数。

## 样例 #1

### 输入

```
5

```

### 输出

```
9

```

## 样例 #2

### 输入

```
3

```

### 输出

```
1

```



---

---
title: "Vitaly and Night"
layout: "post"
diff: 普及-
pid: CF595A
tag: []
---

# Vitaly and Night

## 题目描述

One day Vitaly was going home late at night and wondering: how many people aren't sleeping at that moment? To estimate, Vitaly decided to look which windows are lit in the house he was passing by at that moment.

Vitaly sees a building of $ n $ floors and $ 2·m $ windows on each floor. On each floor there are $ m $ flats numbered from $ 1 $ to $ m $ , and two consecutive windows correspond to each flat. If we number the windows from $ 1 $ to $ 2·m $ from left to right, then the $ j $ -th flat of the $ i $ -th floor has windows $ 2·j-1 $ and $ 2·j $ in the corresponding row of windows (as usual, floors are enumerated from the bottom). Vitaly thinks that people in the flat aren't sleeping at that moment if at least one of the windows corresponding to this flat has lights on.

Given the information about the windows of the given house, your task is to calculate the number of flats where, according to Vitaly, people aren't sleeping.

## 输入格式

The first line of the input contains two integers $ n $ and $ m $ ( $ 1<=n,m<=100 $ ) — the number of floors in the house and the number of flats on each floor respectively.

Next $ n $ lines describe the floors from top to bottom and contain $ 2·m $ characters each. If the $ i $ -th window of the given floor has lights on, then the $ i $ -th character of this line is '1', otherwise it is '0'.

## 输出格式

Print a single integer — the number of flats that have lights on in at least one window, that is, the flats where, according to Vitaly, people aren't sleeping.

## 说明/提示

In the first test case the house has two floors, two flats on each floor. That is, in total there are 4 flats. The light isn't on only on the second floor in the left flat. That is, in both rooms of the flat the light is off.

In the second test case the house has one floor and the first floor has three flats. The light is on in the leftmost flat (in both windows) and in the middle flat (in one window). In the right flat the light is off.

## 样例 #1

### 输入

```
2 2
0 0 0 1
1 0 1 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
1 3
1 1 0 1 0 0

```

### 输出

```
2

```



---

---
title: "Wilbur and Swimming Pool"
layout: "post"
diff: 普及-
pid: CF596A
tag: []
---

# Wilbur and Swimming Pool

## 题目描述

After making bad dives into swimming pools, Wilbur wants to build a swimming pool in the shape of a rectangle in his backyard. He has set up coordinate axes, and he wants the sides of the rectangle to be parallel to them. Of course, the area of the rectangle must be positive. Wilbur had all four vertices of the planned pool written on a paper, until his friend came along and erased some of the vertices.

Now Wilbur is wondering, if the remaining $ n $ vertices of the initial rectangle give enough information to restore the area of the planned swimming pool.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=4 $ ) — the number of vertices that were not erased by Wilbur's friend.

Each of the following $ n $ lines contains two integers $ x_{i} $ and $ y_{i} $ ( $ -1000<=x_{i},y_{i}<=1000 $ ) —the coordinates of the $ i $ -th vertex that remains. Vertices are given in an arbitrary order.

It's guaranteed that these points are distinct vertices of some rectangle, that has positive area and which sides are parallel to the coordinate axes.

## 输出格式

Print the area of the initial rectangle if it could be uniquely determined by the points remaining. Otherwise, print $ -1 $ .

## 说明/提示

In the first sample, two opposite corners of the initial rectangle are given, and that gives enough information to say that the rectangle is actually a unit square.

In the second sample there is only one vertex left and this is definitely not enough to uniquely define the area.

## 样例 #1

### 输入

```
2
0 0
1 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
1
1 1

```

### 输出

```
-1

```



---

---
title: "Wilbur and Array"
layout: "post"
diff: 普及-
pid: CF596B
tag: []
---

# Wilbur and Array

## 题目描述

小猪威尔伯又在试图修复数组了。他有一个数组 a[1],a[2],...,a[n] 最初由 n 个0组成。第一步，他可以选择任何一个下标 i 并让其下标之后的所有元素 a[i],a[i+1],...,a[n] 加1，或者减1。他的目标是得到数组 b[1],b[2],...,b[n]。

当然，威尔伯希望使用最少的步数挑战这个目标，并要求你计算这个值。

## 输入格式

第一行是一个整数 n(1<=n<=200000) ，代表数组的长度。

因为整个数组初始元素全是0，所以数组的元素不会给出。

第二行包括 n 个整数 b[1],b[2],...,b[n] (-10^9<=b[i]<=10^9)

## 输出格式

输出最小的步数。

## 样例 #1

### 输入

```
5
1 2 3 4 5

```

### 输出

```
5
```

## 样例 #2

### 输入

```
4
1 2 2 1

```

### 输出

```
3
```



---

---
title: "Restaurant"
layout: "post"
diff: 普及-
pid: CF597B
tag: []
---

# Restaurant

## 题目描述

A restaurant received $ n $ orders for the rental. Each rental order reserve the restaurant for a continuous period of time, the $ i $ -th order is characterized by two time values — the start time $ l_{i} $ and the finish time $ r_{i} $ ( $ l_{i}<=r_{i} $ ).

Restaurant management can accept and reject orders. What is the maximal number of orders the restaurant can accept?

No two accepted orders can intersect, i.e. they can't share even a moment of time. If one order ends in the moment other starts, they can't be accepted both.

## 输入格式

The first line contains integer number $ n $ ( $ 1<=n<=5·10^{5} $ ) — number of orders. The following $ n $ lines contain integer values $ l_{i} $ and $ r_{i} $ each ( $ 1<=l_{i}<=r_{i}<=10^{9} $ ).

## 输出格式

Print the maximal number of orders that can be accepted.

## 样例 #1

### 输入

```
2
7 11
4 7

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
1 2
2 3
3 4
4 5
5 6

```

### 输出

```
3

```

## 样例 #3

### 输入

```
6
4 8
1 5
4 7
2 5
1 3
6 8

```

### 输出

```
2

```



---

---
title: "Queries about less or equal elements"
layout: "post"
diff: 普及-
pid: CF600B
tag: []
---

# Queries about less or equal elements

## 题目描述

You are given two arrays of integers $ a $ and $ b $ . For each element of the second array $ b_{j} $ you should find the number of elements in array $ a $ that are less than or equal to the value $ b_{j} $ .

## 输入格式

The first line contains two integers $ n,m $ ( $ 1<=n,m<=2·10^{5} $ ) — the sizes of arrays $ a $ and $ b $ .

The second line contains $ n $ integers — the elements of array $ a $ ( $ -10^{9}<=a_{i}<=10^{9} $ ).

The third line contains $ m $ integers — the elements of array $ b $ ( $ -10^{9}<=b_{j}<=10^{9} $ ).

## 输出格式

Print $ m $ integers, separated by spaces: the $ j $ -th of which is equal to the number of such elements in array $ a $ that are less than or equal to the value $ b_{j} $ .

## 样例 #1

### 输入

```
5 4
1 3 5 7 9
6 4 2 8

```

### 输出

```
3 2 1 4

```

## 样例 #2

### 输入

```
5 5
1 2 1 2 5
3 1 4 1 5

```

### 输出

```
4 2 4 2 5

```



---

---
title: "Uncowed Forces"
layout: "post"
diff: 普及-
pid: CF604A
tag: []
---

# Uncowed Forces

## 题目描述

凯文刚刚完成了 CF 的比赛。测试时间为 120 分钟，有 5 个题目。题目 1~5 的满分分别是: 500、1000、1500、2000  和 2500。他作答了所有的题。

他知道自己每个问题的提交时间、每个问题上他提交错误的次数，以及它提交正确和错误的总数。

但 CF 评分的机制很复杂， 凯文想知道他的最终得分。

评分机制：设一个问题的最高分是 x ,提交者在第 m 分钟时提交正确，提交者错误提交了 w 此。那么，他的每道题的得分是： 

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF604A/3fb27769d723e1978a19f6c6254058e35687ad16.png)

他的总成绩是他每道题成绩的和。此外，凯文每通过一道题，他的总分数将增加 100 ；反之，他每错误一次，他的总分数将减少 50 分。

所有运算都是觉得准确的，没有四舍五入。凯文的得分绝对是整数。

## 输入格式

第一行分别是：m1 , m2 , m3 , m4 , m5 。

第二行分别是：w1 , w2 , w3 , w4 , w5。

第三行有两个数：凯文的正确总数和错误总数。

## 输出格式

打印一个整数，既凯文的最终得分。

## 样例 #1

### 输入

```
20 40 60 80 100
0 1 2 3 4
1 0

```

### 输出

```
4900

```

## 样例 #2

### 输入

```
119 119 119 119 119
0 0 0 0 0
10 0

```

### 输出

```
4930

```



---

---
title: "Saitama Destroys Hotel"
layout: "post"
diff: 普及-
pid: CF608A
tag: []
---

# Saitama Destroys Hotel

## 题目描述

Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from $ 0 $ to $ s $ and elevator initially starts on floor $ s $ at time $ 0 $ .

The elevator takes exactly $ 1 $ second to move down exactly $ 1 $ floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor $ 0 $ .

## 输入格式

The first line of input contains two integers $ n $ and $ s $ ( $ 1<=n<=100 $ , $ 1<=s<=1000 $ ) — the number of passengers and the number of the top floor respectively.

The next $ n $ lines each contain two space-separated integers $ f_{i} $ and $ t_{i} $ ( $ 1<=f_{i}<=s $ , $ 1<=t_{i}<=1000 $ ) — the floor and the time of arrival in seconds for the passenger number $ i $ .

## 输出格式

Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor $ 0 $ .

## 说明/提示

In the first sample, it takes at least $ 11 $ seconds to bring all passengers to floor $ 0 $ . Here is how this could be done:

1\. Move to floor $ 5 $ : takes $ 2 $ seconds.

2\. Pick up passenger $ 3 $ .

3\. Move to floor $ 3 $ : takes $ 2 $ seconds.

4\. Wait for passenger $ 2 $ to arrive: takes $ 4 $ seconds.

5\. Pick up passenger $ 2 $ .

6\. Go to floor $ 2 $ : takes $ 1 $ second.

7\. Pick up passenger $ 1 $ .

8\. Go to floor $ 0 $ : takes $ 2 $ seconds.

This gives a total of $ 2+2+4+1+2=11 $ seconds.

## 样例 #1

### 输入

```
3 7
2 1
3 8
5 2

```

### 输出

```
11

```

## 样例 #2

### 输入

```
5 10
2 77
3 33
8 21
9 12
10 64

```

### 输出

```
79

```



---

---
title: "The Best Gift"
layout: "post"
diff: 普及-
pid: CF609B
tag: []
---

# The Best Gift

## 题目描述

Emily's birthday is next week and Jack has decided to buy a present for her. He knows she loves books so he goes to the local bookshop, where there are $ n $ books on sale from one of $ m $ genres.

In the bookshop, Jack decides to buy two books of different genres.

Based on the genre of books on sale in the shop, find the number of options available to Jack for choosing two books of different genres for Emily. Options are considered different if they differ in at least one book.

The books are given by indices of their genres. The genres are numbered from $ 1 $ to $ m $ .

## 输入格式

The first line contains two positive integers $ n $ and $ m $ ( $ 2<=n<=2·10^{5},2<=m<=10 $ ) — the number of books in the bookstore and the number of genres.

The second line contains a sequence $ a_{1},a_{2},...,a_{n} $ , where $ a_{i} $ ( $ 1<=a_{i}<=m $ ) equals the genre of the $ i $ -th book.

It is guaranteed that for each genre there is at least one book of that genre.

## 输出格式

Print the only integer — the number of ways in which Jack can choose books.

It is guaranteed that the answer doesn't exceed the value $ 2·10^{9} $ .

## 说明/提示

The answer to the first test sample equals 5 as Sasha can choose:

1. the first and second books,
2. the first and third books,
3. the first and fourth books,
4. the second and third books,
5. the third and fourth books.

## 样例 #1

### 输入

```
4 3
2 1 3 1

```

### 输出

```
5

```

## 样例 #2

### 输入

```
7 4
4 2 3 1 2 4 3

```

### 输出

```
18

```



---

---
title: "Where Are My Flakes?"
layout: "post"
diff: 普及-
pid: CF60A
tag: []
---

# Where Are My Flakes?

## 题目描述

一天早上，麦片仔发现他所有的麦片都不见了(天哪)。他发现了一张纸条而不是他的麦片。原来他聪明(xie e)的室友把雪花藏在了n个盒子里。这些盒子排成一排，从左到右编号从1到n。室友留下一些提示，像"隐藏在第i个盒子的左边"("To the left of i")，"隐藏在第i个盒子的右边"("To the right of i")。这样的提示意味着 **在i个盒子中也没有麦片**。斟酌所有的提示，麦片仔想要知道他需要检查多少个盒子才能找到麦片。或者他想知道这些暗示是矛盾的，室友对他撒谎，也就是说，盒子里没有麦片(麦片机惨)。

## 输入格式

第一行包含两个整数n和m (1<=n<=1000,0<=m<=1000)(真小)，分别表示盒子的数量和提示的数量。接下来的m 行包含"To the left of i"和"To the right of i"这样的提示，其中i是整数(1<=i<=n)。这些提示可能同时出现。

## 输出格式

答案应该只包含一个整数(就是要检查的盒子数),如果提示是矛盾的,就输出-1。

## 样例 #1

### 输入

```
2 1
To the left of 2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
3 2
To the right of 1
To the right of 2

```

### 输出

```
1

```

## 样例 #3

### 输入

```
3 1
To the left of 3

```

### 输出

```
2

```

## 样例 #4

### 输入

```
3 2
To the left of 2
To the right of 1

```

### 输出

```
-1

```



---

---
title: "Serial Time!"
layout: "post"
diff: 普及-
pid: CF60B
tag: []
---

# Serial Time!

## 题目描述

The Cereal Guy's friend Serial Guy likes to watch soap operas. An episode is about to start, and he hasn't washed his plate yet. But he decided to at least put in under the tap to be filled with water. The plate can be represented by a parallelepiped $ k×n×m $ , that is, it has $ k $ layers (the first layer is the upper one), each of which is a rectangle $ n×m $ with empty squares ('.') and obstacles ('#'). The water can only be present in the empty squares. The tap is positioned above the square $ (x,y) $ of the first layer, it is guaranteed that this square is empty. Every minute a cubical unit of water falls into the plate. Find out in how many minutes the Serial Guy should unglue himself from the soap opera and turn the water off for it not to overfill the plate. That is, you should find the moment of time when the plate is absolutely full and is going to be overfilled in the next moment.

Note: the water fills all the area within reach (see sample 4). Water flows in each of the 6 directions, through faces of $ 1×1×1 $ cubes.

## 输入格式

The first line contains three numbers $ k $ , $ n $ , $ m $ ( $ 1<=k,n,m<=10 $ ) which are the sizes of the plate. Then follow $ k $ rectangles consisting of $ n $ lines each containing $ m $ characters '.' or '#', which represents the "layers" of the plate in the order from the top to the bottom. The rectangles are separated by empty lines (see the samples). The last line contains $ x $ and $ y $ ( $ 1<=x<=n,1<=y<=m $ ) which are the tap's coordinates. $ x $ is the number of the line and $ y $ is the number of the column. Lines of each layer are numbered from left to right by the integers from $ 1 $ to $ n $ , columns of each layer are numbered from top to bottom by the integers from $ 1 $ to $ m $ .

## 输出格式

The answer should contain a single number, showing in how many minutes the plate will be filled.

## 样例 #1

### 输入

```
1 1 1

.

1 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
2 1 1

.

#

1 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
2 2 2

.#
##

..
..

1 1

```

### 输出

```
5

```

## 样例 #4

### 输入

```
3 2 2

#.
##

#.
.#

..
..

1 2

```

### 输出

```
7

```

## 样例 #5

### 输入

```
3 3 3

.#.
###
##.

.##
###
##.

...
...
...

1 1

```

### 输出

```
13

```



---

---
title: "Pasha and Stick"
layout: "post"
diff: 普及-
pid: CF610A
tag: []
---

# Pasha and Stick

## 题目描述

Pasha has a wooden stick of some positive integer length $ n $ . He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be $ n $ .

Pasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.

Your task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer $ x $ , such that the number of parts of length $ x $ in the first way differ from the number of parts of length $ x $ in the second way.

## 输入格式

The first line of the input contains a positive integer $ n $ ( $ 1<=n<=2·10^{9} $ ) — the length of Pasha's stick.

## 输出格式

The output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square.

## 说明/提示

There is only one way to divide the stick in the first sample {1, 1, 2, 2}.

Four ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.

## 样例 #1

### 输入

```
6

```

### 输出

```
1

```

## 样例 #2

### 输入

```
20

```

### 输出

```
4

```



---

---
title: "Vika and Squares"
layout: "post"
diff: 普及-
pid: CF610B
tag: []
---

# Vika and Squares

## 题目描述

Vika 有 $n$ 桶油漆，第 $i$ 桶有 $a_i$ 升油漆。

Vika 有一张无限长的长方形纸条，她将长方形纸条分成了无限个正方形，她将按照以下规则对正方形涂色。

- 涂一个正方形需要 $1$ 升油漆。
- 第一个正方形可以用第任意第 $i$ 桶油漆。
- 若第 $k$ 个正方形用了第 $x$ 桶油漆，则第 $k+1$ 个正方形将用第 $x+1$ 桶油漆，若 $x=n$，则第 $k+1$ 个正方形将用第 $1$ 桶油漆。若 $a_x = 0$ 则停止涂色。

求 Vika 最多可以涂多少个正方形。

## 输入格式

两行

第 $1$ 行，一个整数 $n$。

第 $2$ 行，$n$ 个整数 $a_i$ 。

## 输出格式

一行，Vika 最多可涂的正方形数量。

translate by @sqh_let_it_be

## 样例 #1

### 输入

```
5
2 4 2 3 3

```

### 输出

```
12

```

## 样例 #2

### 输入

```
3
5 5 5

```

### 输出

```
15

```

## 样例 #3

### 输入

```
6
10 10 10 1 10 10

```

### 输出

```
11

```



---

---
title: "The Text Splitting"
layout: "post"
diff: 普及-
pid: CF612A
tag: []
---

# The Text Splitting

## 题目描述

You are given the string $ s $ of length $ n $ and the numbers $ p,q $ . Split the string $ s $ to pieces of length $ p $ and $ q $ .

For example, the string "Hello" for $ p=2 $ , $ q=3 $ can be split to the two strings "Hel" and "lo" or to the two strings "He" and "llo".

Note it is allowed to split the string $ s $ to the strings only of length $ p $ or to the strings only of length $ q $ (see the second sample test).

## 输入格式

The first line contains three positive integers $ n,p,q $ ( $ 1<=p,q<=n<=100 $ ).

The second line contains the string $ s $ consists of lowercase and uppercase latin letters and digits.

## 输出格式

If it's impossible to split the string $ s $ to the strings of length $ p $ and $ q $ print the only number "-1".

Otherwise in the first line print integer $ k $ — the number of strings in partition of $ s $ .

Each of the next $ k $ lines should contain the strings in partition. Each string should be of the length $ p $ or $ q $ . The string should be in order of their appearing in string $ s $ — from left to right.

If there are several solutions print any of them.

## 样例 #1

### 输入

```
5 2 3
Hello

```

### 输出

```
2
He
llo

```

## 样例 #2

### 输入

```
10 9 5
Codeforces

```

### 输出

```
2
Codef
orces

```

## 样例 #3

### 输入

```
6 4 5
Privet

```

### 输出

```
-1

```

## 样例 #4

### 输入

```
8 1 1
abacabac

```

### 输出

```
8
a
b
a
c
a
b
a
c

```



---

---
title: "HDD is Outdated Technology"
layout: "post"
diff: 普及-
pid: CF612B
tag: []
---

# HDD is Outdated Technology

## 题目描述

HDD hard drives group data by sectors. All files are split to fragments and each of them are written in some sector of hard drive. Note the fragments can be written in sectors in arbitrary order.

One of the problems of HDD hard drives is the following: the magnetic head should move from one sector to another to read some file.

Find the time need to read file split to $ n $ fragments. The $ i $ -th sector contains the $ f_{i} $ -th fragment of the file ( $ 1\le f_{i}\le n $ ). Note different sectors contains the different fragments. At the start the magnetic head is in the position that contains the first fragment. The file are reading in the following manner: at first the first fragment is read, then the magnetic head moves to the sector that contains the second fragment, then the second fragment is read and so on until the $ n $ -th fragment is read. The fragments are read in the order from the first to the $ n $ -th.

It takes $ |a-b| $ time units to move the magnetic head from the sector $ a $ to the sector $ b $ . Reading a fragment takes no time.

## 输入格式

The first line contains a positive integer $ n $ ( $ 1\le n\le 2\times 10^{5} $ ) — the number of fragments.

The second line contains $ n $ different integers $ f_{i} $ ( $ 1\le f_{i}\le n $ ) — the number of the fragment written in the $ i $ -th sector.

## 输出格式

Print the only integer — the number of time units needed to read the file.

## 说明/提示

In the second example the head moves in the following way:

- 1->2 means movement from the sector 1 to the sector 5, i.e. it takes 4 time units
- 2->3 means movement from the sector 5 to the sector 2, i.e. it takes 3 time units
- 3->4 means movement from the sector 2 to the sector 4, i.e. it takes 2 time units
- 4->5 means movement from the sector 4 to the sector 3, i.e. it takes 1 time units

So the answer to the second example is $ 4+3+2+1=10 $ .

## 样例 #1

### 输入

```
3
3 1 2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
5
1 3 5 4 2

```

### 输出

```
10

```



---

---
title: "Link/Cut Tree"
layout: "post"
diff: 普及-
pid: CF614A
tag: []
---

# Link/Cut Tree

## 题目描述

Programmer Rostislav got seriously interested in the Link/Cut Tree data structure, which is based on Splay trees. Specifically, he is now studying the $ expose $ procedure.

Unfortunately, Rostislav is unable to understand the definition of this procedure, so he decided to ask programmer Serezha to help him. Serezha agreed to help if Rostislav solves a simple task (and if he doesn't, then why would he need Splay trees anyway?)

Given integers $ l $ , $ r $ and $ k $ , you need to print all powers of number $ k $ within range from $ l $ to $ r $ inclusive. However, Rostislav doesn't want to spent time doing this, as he got interested in playing a network game called Agar with Gleb. Help him!

## 输入格式

The first line of the input contains three space-separated integers $ l $ , $ r $ and $ k $ ( $ 1<=l<=r<=10^{18} $ , $ 2<=k<=10^{9} $ ).

## 输出格式

Print all powers of number $ k $ , that lie within range from $ l $ to $ r $ in the increasing order. If there are no such numbers, print "-1" (without the quotes).

## 说明/提示

Note to the first sample: numbers $ 2^{0}=1 $ , $ 2^{1}=2 $ , $ 2^{2}=4 $ , $ 2^{3}=8 $ lie within the specified range. The number $ 2^{4}=16 $ is greater then $ 10 $ , thus it shouldn't be printed.

## 样例 #1

### 输入

```
1 10 2

```

### 输出

```
1 2 4 8 
```

## 样例 #2

### 输入

```
2 4 5

```

### 输出

```
-1
```



---

---
title: "Bulbs"
layout: "post"
diff: 普及-
pid: CF615A
tag: []
---

# Bulbs

## 题目描述

Vasya wants to turn on Christmas lights consisting of $ m $ bulbs. Initially, all bulbs are turned off. There are $ n $ buttons, each of them is connected to some set of bulbs. Vasya can press any of these buttons. When the button is pressed, it turns on all the bulbs it's connected to. Can Vasya light up all the bulbs?

If Vasya presses the button such that some bulbs connected to it are already turned on, they do not change their state, i.e. remain turned on.

## 输入格式

The first line of the input contains integers $ n $ and $ m $ ( $ 1<=n,m<=100 $ ) — the number of buttons and the number of bulbs respectively.

Each of the next $ n $ lines contains $ x_{i} $ ( $ 0<=x_{i}<=m $ ) — the number of bulbs that are turned on by the $ i $ -th button, and then $ x_{i} $ numbers $ y_{ij} $ ( $ 1<=y_{ij}<=m $ ) — the numbers of these bulbs.

## 输出格式

If it's possible to turn on all $ m $ bulbs print "YES", otherwise print "NO".

## 说明/提示

In the first sample you can press each button once and turn on all the bulbs. In the 2 sample it is impossible to turn on the 3-rd lamp.

## 样例 #1

### 输入

```
3 4
2 1 4
3 1 3 1
1 2

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3 3
1 1
1 2
1 1

```

### 输出

```
NO

```



---

---
title: "Chocolate"
layout: "post"
diff: 普及-
pid: CF617B
tag: []
---

# Chocolate

## 题目描述

## 分割序列

给一个01序列，将之分割成若干段，要求每段恰好只含有1个1，计算分解方案的总数。

## 输入格式

第一行为正整数n(≤100)，第二行为用空格分隔的n个0或1。

## 输出格式

输出分解方案总数。

#### 输入 #1

3

0 1 0

#### 输出 #1

1

#### 输入 #2

5

1 0 1 0 1

#### 输出 #2

4

## 样例 #1

### 输入

```
3
0 1 0

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
1 0 1 0 1

```

### 输出

```
4

```



---

---
title: "Guess the Permutation"
layout: "post"
diff: 普及-
pid: CF618B
tag: []
---

# Guess the Permutation

## 题目描述

Bob has a permutation of integers from $ 1 $ to $ n $ . Denote this permutation as $ p $ . The $ i $ -th element of $ p $ will be denoted as $ p_{i} $ . For all pairs of distinct integers $ i,j $ between $ 1 $ and $ n $ , he wrote the number $ a_{i,j}=min(p_{i},p_{j}) $ . He writes $ a_{i,i}=0 $ for all integer $ i $ from $ 1 $ to $ n $ .

Bob gave you all the values of $ a_{i,j} $ that he wrote down. Your job is to reconstruct any permutation that could have generated these values. The input will be formed so that it is guaranteed that there is at least one solution that is consistent with the information given.

## 输入格式

The first line of the input will contain a single integer $ n $ ( $ 2<=n<=50 $ ).

The next $ n $ lines will contain the values of $ a_{i,j} $ . The $ j $ -th number on the $ i $ -th line will represent $ a_{i,j} $ . The $ i $ -th number on the $ i $ -th line will be $ 0 $ . It's guaranteed that $ a_{i,j}=a_{j,i} $ and there is at least one solution consistent with the information given.

## 输出格式

Print $ n $ space separated integers, which represents a permutation that could have generated these values. If there are multiple possible solutions, print any of them.

## 说明/提示

In the first case, the answer can be $ {1,2} $ or $ {2,1} $ .

In the second case, another possible answer is $ {2,4,5,1,3} $ .

## 样例 #1

### 输入

```
2
0 1
1 0

```

### 输出

```
2 1

```

## 样例 #2

### 输入

```
5
0 2 2 1 2
2 0 4 1 3
2 4 0 1 3
1 1 1 0 1
2 3 3 1 0

```

### 输出

```
2 5 4 1 3

```



---

---
title: "Grandfather Dovlet’s calculator"
layout: "post"
diff: 普及-
pid: CF620B
tag: []
---

# Grandfather Dovlet’s calculator

## 题目描述

Once Max found an electronic calculator from his grandfather Dovlet's chest. He noticed that the numbers were written with seven-segment indicators ([https://en.wikipedia.org/wiki/Seven-segment\_display](https://en.wikipedia.org/wiki/Seven-segment_display)).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF620B/67b24c9a2393a33eff16b95f90d96d29b0d56e85.png)Max starts to type all the values from $ a $ to $ b $ . After typing each number Max resets the calculator. Find the total number of segments printed on the calculator.

For example if $ a=1 $ and $ b=3 $ then at first the calculator will print $ 2 $ segments, then — $ 5 $ segments and at last it will print $ 5 $ segments. So the total number of printed segments is $ 12 $ .

## 输入格式

The only line contains two integers $ a,b $ ( $ 1<=a<=b<=10^{6} $ ) — the first and the last number typed by Max.

## 输出格式

Print the only integer $ a $ — the total number of printed segments.

## 样例 #1

### 输入

```
1 3

```

### 输出

```
12

```

## 样例 #2

### 输入

```
10 15

```

### 输出

```
39

```



---

---
title: "Wet Shark and Bishops"
layout: "post"
diff: 普及-
pid: CF621B
tag: []
---

# Wet Shark and Bishops

## 题目描述

Today, Wet Shark is given $ n $ bishops on a $ 1000 $ by $ 1000 $ grid. Both rows and columns of the grid are numbered from $ 1 $ to $ 1000 $ . Rows are numbered from top to bottom, while columns are numbered from left to right.

Wet Shark thinks that two bishops attack each other if they share the same diagonal. Note, that this is the only criteria, so two bishops may attack each other (according to Wet Shark) even if there is another bishop located between them. Now Wet Shark wants to count the number of pairs of bishops that attack each other.

## 输入格式

The first line of the input contains $ n $ ( $ 1<=n<=200000 $ ) — the number of bishops.

Each of next $ n $ lines contains two space separated integers $ x_{i} $ and $ y_{i} $ ( $ 1<=x_{i},y_{i}<=1000 $ ) — the number of row and the number of column where $ i $ -th bishop is positioned. It's guaranteed that no two bishops share the same position.

## 输出格式

Output one integer — the number of pairs of bishops which attack each other.

## 说明/提示

In the first sample following pairs of bishops attack each other: $ (1,3) $ , $ (1,5) $ , $ (2,3) $ , $ (2,4) $ , $ (3,4) $ and $ (3,5) $ . Pairs $ (1,2) $ , $ (1,4) $ , $ (2,5) $ and $ (4,5) $ do not attack each other because they do not share the same diagonal.

## 样例 #1

### 输入

```
5
1 1
1 5
3 3
5 1
5 5

```

### 输出

```
6

```

## 样例 #2

### 输入

```
3
1 1
2 3
3 5

```

### 输出

```
0

```



---

---
title: "The Time"
layout: "post"
diff: 普及-
pid: CF622B
tag: []
---

# The Time

## 题目描述

You are given the current time in $ 24 $ -hour format hh:mm. Find and print the time after $ a $ minutes.

Note that you should find only the time after $ a $ minutes, see the examples to clarify the problem statement.

You can read more about $ 24 $ -hour format here [https://en.wikipedia.org/wiki/24-hour\_clock](https://en.wikipedia.org/wiki/24-hour_clock).

## 输入格式

The first line contains the current time in the format hh:mm ( $ 0<=hh&lt;24,0<=mm&lt;60 $ ). The hours and the minutes are given with two digits (the hours or the minutes less than $ 10 $ are given with the leading zeroes).

The second line contains integer $ a $ ( $ 0<=a<=10^{4} $ ) — the number of the minutes passed.

## 输出格式

The only line should contain the time after $ a $ minutes in the format described in the input. Note that you should print exactly two digits for the hours and the minutes (add leading zeroes to the numbers if needed).

See the examples to check the input/output format.

## 样例 #1

### 输入

```
23:59
10

```

### 输出

```
00:09

```

## 样例 #2

### 输入

```
20:20
121

```

### 输出

```
22:21

```

## 样例 #3

### 输入

```
10:10
0

```

### 输出

```
10:10

```



---

---
title: "War of the Corporations"
layout: "post"
diff: 普及-
pid: CF625B
tag: []
---

# War of the Corporations

## 题目描述

A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.

This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.

Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with "\#". As this operation is pretty expensive, you should find the minimum number of characters to replace with "\#", such that the name of AI doesn't contain the name of the phone as a substring.

Substring is a continuous subsequence of a string.

## 输入格式

The first line of the input contains the name of AI designed by Gogol, its length doesn't exceed $ 100000 $ characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed $ 30 $ . Both string are non-empty and consist of only small English letters.

## 输出格式

Print the minimum number of characters that must be replaced with "\#" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.

## 说明/提示

In the first sample AI's name may be replaced with "int#llect".

In the second sample Gogol can just keep things as they are.

In the third sample one of the new possible names of AI may be "s#ris#ri".

## 样例 #1

### 输入

```
intellect
tell

```

### 输出

```
1
```

## 样例 #2

### 输入

```
google
apple

```

### 输出

```
0
```

## 样例 #3

### 输入

```
sirisiri
sir

```

### 输出

```
2
```



---

---
title: "Far Relative’s Problem"
layout: "post"
diff: 普及-
pid: CF629B
tag: []
---

# Far Relative’s Problem

## 题目描述

Famil Door wants to celebrate his birthday with his friends from Far Far Away. He has $ n $ friends and each of them can come to the party in a specific range of days of the year from $ a_{i} $ to $ b_{i} $ . Of course, Famil Door wants to have as many friends celebrating together with him as possible.

Far cars are as weird as Far Far Away citizens, so they can only carry two people of opposite gender, that is exactly one male and one female. However, Far is so far from here that no other transportation may be used to get to the party.

Famil Door should select some day of the year and invite some of his friends, such that they all are available at this moment and the number of male friends invited is equal to the number of female friends invited. Find the maximum number of friends that may present at the party.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=5000 $ ) — then number of Famil Door's friends.

Then follow $ n $ lines, that describe the friends. Each line starts with a capital letter 'F' for female friends and with a capital letter 'M' for male friends. Then follow two integers $ a_{i} $ and $ b_{i} $ ( $ 1<=a_{i}<=b_{i}<=366 $ ), providing that the $ i $ -th friend can come to the party from day $ a_{i} $ to day $ b_{i} $ inclusive.

## 输出格式

Print the maximum number of people that may come to Famil Door's party.

## 说明/提示

In the first sample, friends $ 3 $ and $ 4 $ can come on any day in range $ [117,128] $ .

In the second sample, friends with indices $ 3 $ , $ 4 $ , $ 5 $ and $ 6 $ can come on day $ 140 $ .

## 样例 #1

### 输入

```
4
M 151 307
F 343 352
F 117 145
M 24 128

```

### 输出

```
2

```

## 样例 #2

### 输入

```
6
M 128 130
F 128 131
F 131 140
F 131 141
M 131 200
M 140 200

```

### 输出

```
4

```



---

---
title: "Again Twenty Five!"
layout: "post"
diff: 普及-
pid: CF630A
tag: []
---

# Again Twenty Five!

## 题目描述

The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. "Do I give such a hard task?" — the HR manager thought. "Just raise number $ 5 $ to the power of $ n $ and get last two digits of the number. Yes, of course, $ n $ can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions."

Could you pass the interview in the machine vision company in IT City?

## 输入格式

The only line of the input contains a single integer $ n $ ( $ 2<=n<=2·10^{18} $ ) — the power in which you need to raise number $ 5 $ .

## 输出格式

Output the last two digits of $ 5^{n} $ without spaces between them.

## 样例 #1

### 输入

```
2

```

### 输出

```
25
```



---

---
title: "Moore's Law"
layout: "post"
diff: 普及-
pid: CF630B
tag: []
---

# Moore's Law

## 题目描述

根据摩尔定律，集成电路上可以容纳的晶体管数目每秒可变为原来的 $1.000000011$ 倍，现给定当前晶体管数目 $n$，和经历的秒数 $t$，求 $t$ 秒后集成电路上可以容纳的晶体管数目约是多少。

## 输出格式

一个浮点数作为答案，你的答案与标准答案差的绝对值不超过 $10^{-6}$ 即判定为正确。

形式化来讲，设你的答案为 $x$，标准答案为 $y$，则你需要使 $\lvert x - y \rvert < 10^{-6}$。

## 说明/提示

$10^3 \le n \le 10^4$，$0 \le t \le 2 \times 10^9$。

## 样例 #1

### 输入

```
1000 1000000

```

### 输出

```
1011.060722383550382782399454922040

```



---

---
title: "Lucky Numbers"
layout: "post"
diff: 普及-
pid: CF630C
tag: []
---

# Lucky Numbers

## 题目描述

The numbers of all offices in the new building of the Tax Office of IT City will have lucky numbers.

Lucky number is a number that consists of digits $ 7 $ and $ 8 $ only. Find the maximum number of offices in the new building of the Tax Office given that a door-plate can hold a number not longer than $ n $ digits.

## 输入格式

The only line of input contains one integer $ n $ ( $ 1<=n<=55 $ ) — the maximum length of a number that a door-plate can hold.

## 输出格式

Output one integer — the maximum number of offices, than can have unique lucky numbers not longer than $ n $ digits.

## 样例 #1

### 输入

```
2

```

### 输出

```
6
```



---

---
title: "Hexagons!"
layout: "post"
diff: 普及-
pid: CF630D
tag: []
---

# Hexagons!

## 题目描述

After a probationary period in the game development company of IT City Petya was included in a group of the programmers that develops a new turn-based strategy game resembling the well known "Heroes of Might & Magic". A part of the game is turn-based fights of big squadrons of enemies on infinite fields where every cell is in form of a hexagon.

Some of magic effects are able to affect several field cells at once, cells that are situated not farther than $ n $ cells away from the cell in which the effect was applied. The distance between cells is the minimum number of cell border crosses on a path from one cell to another.

It is easy to see that the number of cells affected by a magic effect grows rapidly when $ n $ increases, so it can adversely affect the game performance. That's why Petya decided to write a program that can, given $ n $ , determine the number of cells that should be repainted after effect application, so that game designers can balance scale of the effects and the game performance. Help him to do it. Find the number of hexagons situated not farther than $ n $ cells away from a given cell.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF630D/b73bc98c088fe19987a12ad8929090ba13c1d4a0.png)

## 输入格式

The only line of the input contains one integer $ n $ ( $ 0<=n<=10^{9} $ ).

## 输出格式

Output one integer — the number of hexagons situated not farther than $ n $ cells away from a given cell.

## 样例 #1

### 输入

```
2

```

### 输出

```
19
```



---

---
title: "Selection of Personnel"
layout: "post"
diff: 普及-
pid: CF630F
tag: []
---

# Selection of Personnel

## 题目描述

One company of IT City decided to create a group of innovative developments consisting from $ 5 $ to $ 7 $ people and hire new employees for it. After placing an advertisment the company received $ n $ resumes. Now the HR department has to evaluate each possible group composition and select one of them. Your task is to count the number of variants of group composition to evaluate.

## 输入格式

The only line of the input contains one integer $ n $ ( $ 7<=n<=777 $ ) — the number of potential employees that sent resumes.

## 输出格式

Output one integer — the number of different variants of group composition.

## 样例 #1

### 输入

```
7

```

### 输出

```
29
```



---

---
title: "Game"
layout: "post"
diff: 普及-
pid: CF630R
tag: []
---

# Game

## 题目描述

学生与教授在$n×n(1<=n<=10^{18})$的棋盘上做游戏，教授给定$n$的值，学生可以选择是先手还是后手。规则如下：

两人轮流给棋盘上的格子染色，不能将已染色的格子的周围格进行染色。这里的周围格指的是有公共边的格子，也就是说仅有公共点的格子是可以染色的。谁没有格子染谁就输。

问：若两人都以最好的方式染色（也就是尽可能使自己赢），学生应该选择先手还是后手？

## 输入格式

一行一个整数$n$，表示棋盘的边长。

## 输出格式

一行一个整数$1$或$2$，$1$表示学生应该选择先手，$2$反之。

## 样例 #1

### 输入

```
1

```

### 输出

```
1
```

## 样例 #2

### 输入

```
2

```

### 输出

```
2
```



---

---
title: "Voting for Photos"
layout: "post"
diff: 普及-
pid: CF637A
tag: []
---

# Voting for Photos

## 题目描述

给定一个数组，找出出现最多的数，若有多个，输出最后一次出现时最靠前的数。

## 输入格式

两行。  
第一行，一个自然数n（1<=n<=1000）  
第二行，一个长度为n的数组，数组中每个数均小于1000000。

## 输出格式

一行，出现最多的数中，最后一次出现时最靠前的数。

## 样例 #1

### 输入

```
5
1 3 2 2 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
9
100 200 300 200 100 300 300 100 200

```

### 输出

```
300

```



---

---
title: "Sinking Ship"
layout: "post"
diff: 普及-
pid: CF63A
tag: []
---

# Sinking Ship

## 题目描述

The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All $ n $ crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to $ n $ ) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:

The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.

If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).

For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.

## 输入格式

The first line contains an integer $ n $ , which is the number of people in the crew ( $ 1<=n<=100 $ ). Then follow $ n $ lines. The $ i $ -th of those lines contains two words — the name of the crew member who is $ i $ -th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.

## 输出格式

Print $ n $ lines. The $ i $ -th of them should contain the name of the crew member who must be the $ i $ -th one to leave the ship.

## 样例 #1

### 输入

```
6
Jack captain
Alice woman
Charlie man
Teddy rat
Bob child
Julia woman

```

### 输出

```
Teddy
Alice
Bob
Julia
Charlie
Jack

```



---

---
title: "Settlers' Training"
layout: "post"
diff: 普及-
pid: CF63B
tag: []
---

# Settlers' Training

## 题目描述

In a strategic computer game "Settlers II" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly $ n $ soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.

Every soldier has a rank — some natural number from $ 1 $ to $ k $ . $ 1 $ stands for a private and $ k $ stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.

To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the $ n $ soldiers are present.

At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank $ k $ are present, exactly one soldier increases his rank by one.

You know the ranks of all $ n $ soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank $ k $ .

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1<=n,k<=100 $ ). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains $ n $ numbers in the non-decreasing order. The $ i $ -th of them, $ a_{i} $ , represents the rank of the $ i $ -th soldier in the defense building ( $ 1<=i<=n $ , $ 1<=a_{i}<=k $ ).

## 输出格式

Print a single integer — the number of golden coins needed to raise all the soldiers to the maximal rank.

## 说明/提示

In the first example the ranks will be raised in the following manner:

1 2 2 3 $ → $ 2 2 3 4 $ → $ 2 3 4 4 $ → $ 3 4 4 4 $ → $ 4 4 4 4

Thus totals to 4 training sessions that require 4 golden coins.

## 样例 #1

### 输入

```
4 4
1 2 2 3

```

### 输出

```
4
```

## 样例 #2

### 输入

```
4 3
1 1 1 1

```

### 输出

```
5
```



---

---
title: "Little Artem and Grasshopper"
layout: "post"
diff: 普及-
pid: CF641A
tag: []
---

# Little Artem and Grasshopper

## 题目描述

有一只蚱蜢和一个有着$n$个格子的条子，蚱蜢刚开始在第$1$个格子上。每个格子上都标有下次跳的方向以及距离。当蚱蜢跳出边界时就会停止。请问蚱蜢是否会一直跳下去？

## 输入格式

第一行，一个正整数$n$($1$<=$n$<=$100000$)，表示条子长度。                    
第二行，$n$个字符，第$i$个字符表示第$i$个格子上表示方向的标识，`<`表示往左跳，`>`表示往右跳。（样例中的`&lt;`即为`<`，`&gt;`即为`>`。中间没有空格）            
第三行，$n$个数字，第$i$个数字表示第$i$个格子上表示距离的标识。 （空格隔开）

## 输出格式

如果蚱蜢会永远跳下去，输出`INFINITE`，否则输出`FINITE`。   


$Translate$ $by$ $U144044$                      
$\color{white}\texttt{蚱蜢永远跳下去不会累死吗}$

## 样例 #1

### 输入

```
2
&gt;&lt;
1 2

```

### 输出

```
FINITE

```

## 样例 #2

### 输入

```
3
&gt;&gt;&lt;
2 1 1

```

### 输出

```
INFINITE
```



---

---
title: "Bear and Colors"
layout: "post"
diff: 普及-
pid: CF643A
tag: []
---

# Bear and Colors

## 题目描述

Bear Limak has $ n $ colored balls, arranged in one long row. Balls are numbered $ 1 $ through $ n $ , from left to right. There are $ n $ possible colors, also numbered $ 1 $ through $ n $ . The $ i $ -th ball has color $ t_{i} $ .

For a fixed interval (set of consecutive elements) of balls we can define a dominant color. It's a color occurring the biggest number of times in the interval. In case of a tie between some colors, the one with the smallest number (index) is chosen as dominant.

There are ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF643A/e72cbeaa17cceea137ec85134680a8c41a08d995.png) non-empty intervals in total. For each color, your task is to count the number of intervals in which this color is dominant.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=5000 $ ) — the number of balls.

The second line contains $ n $ integers $ t_{1},t_{2},...,t_{n} $ ( $ 1<=t_{i}<=n $ ) where $ t_{i} $ is the color of the $ i $ -th ball.

## 输出格式

Print $ n $ integers. The $ i $ -th of them should be equal to the number of intervals where $ i $ is a dominant color.

## 说明/提示

In the first sample, color $ 2 $ is dominant in three intervals:

- An interval $ [2,2] $ contains one ball. This ball's color is $ 2 $ so it's clearly a dominant color.
- An interval $ [4,4] $ contains one ball, with color $ 2 $ again.
- An interval $ [2,4] $ contains two balls of color $ 2 $ and one ball of color $ 1 $ .

There are $ 7 $ more intervals and color $ 1 $ is dominant in all of them.

## 样例 #1

### 输入

```
4
1 2 1 2

```

### 输出

```
7 3 0 0 

```

## 样例 #2

### 输入

```
3
1 1 1

```

### 输出

```
6 0 0 

```



---

---
title: "Parliament of Berland"
layout: "post"
diff: 普及-
pid: CF644A
tag: []
---

# Parliament of Berland

## 题目描述

$Berland$ 有 $n$ 名议员，编号为 $1$ ~ $n$ ，所有编号为奇数的议员都是民主党人，编号为偶数的议员都是共和党人。



新的议会集会厅是一个矩形，由 $a×b$ 把椅子组成——  $a$ 行，每行 $b$ 把椅子。横/纵坐标相差 $1$ 的椅子是相邻的，例如，第 $2$ 行的 $5 $号椅子与该行的 $4$ 和 $6$ 号椅子以及第 $1$ 和 $3$ 行的 $5$ 号椅子相邻。因此，除了大厅边缘的椅子外，每把椅子都与另外 $4$ 把椅子相邻。



如果一个政党的两名议员（即两个民主党人或两个共和党人）在相邻的椅子就座，他们将花费所有时间~~划水~~讨论党内问题。



对于给定的议员人数和大厅大小，确定是否有办法使同一政党的任何两个成员的座位都不相邻。

## 输入格式

一行三个整数，$n$ ，$a$ ， $b$

## 输出格式

如果无法满足要求，输出 $-1$



否则，输出 $a$ 行 $b$ 个整数，每个数表示占据该位置的议员编号，留空则为$0$。如有多种方案，输出任意一种

## 样例 #1

### 输入

```
3 2 2

```

### 输出

```
0 3
1 2

```

## 样例 #2

### 输入

```
8 4 3

```

### 输出

```
7 8 3
0 1 4
6 0 5
0 2 0

```

## 样例 #3

### 输入

```
10 2 2

```

### 输出

```
-1

```



---

---
title: "Amity Assessment"
layout: "post"
diff: 普及-
pid: CF645A
tag: []
---

# Amity Assessment

## 题目描述

Bessie the cow and her best friend Elsie each received a sliding puzzle on Pi Day. Their puzzles consist of a $ 2×2 $ grid and three tiles labeled 'A', 'B', and 'C'. The three tiles sit on top of the grid, leaving one grid cell empty. To make a move, Bessie or Elsie can slide a tile adjacent to the empty cell into the empty cell as shown below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF645A/dea7f0e6f6bd920a326a8e3da7a33cbf3667be5d.png)In order to determine if they are truly Best Friends For Life (BFFLs), Bessie and Elsie would like to know if there exists a sequence of moves that takes their puzzles to the same configuration (moves can be performed in both puzzles). Two puzzles are considered to be in the same configuration if each tile is on top of the same grid cell in both puzzles. Since the tiles are labeled with letters, rotations and reflections are not allowed.

## 输入格式

The first two lines of the input consist of a $ 2×2 $ grid describing the initial configuration of Bessie's puzzle. The next two lines contain a $ 2×2 $ grid describing the initial configuration of Elsie's puzzle. The positions of the tiles are labeled 'A', 'B', and 'C', while the empty cell is labeled 'X'. It's guaranteed that both puzzles contain exactly one tile with each letter and exactly one empty position.

## 输出格式

Output "YES"(without quotes) if the puzzles can reach the same configuration (and Bessie and Elsie are truly BFFLs). Otherwise, print "NO" (without quotes).

## 说明/提示

The solution to the first sample is described by the image. All Bessie needs to do is slide her 'A' tile down.

In the second sample, the two puzzles can never be in the same configuration. Perhaps Bessie and Elsie are not meant to be friends after all...

## 样例 #1

### 输入

```
AB
XC
XB
AC

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
AB
XC
AC
BX

```

### 输出

```
NO

```



---

---
title: "z-sort"
layout: "post"
diff: 普及-
pid: CF652B
tag: []
---

# z-sort

## 题目描述

z学校的一位学生发现了一种叫做z排序的排序方法。如果数组a满足以下两个条件，那么称它为z排序后的:

1.对所有的偶数i，$a_i$>=$a_{i-1}$；

2.对所有的奇数i，$a_i$<=$a_{i-1}$。

例如，数组【1,2,1,2】和【1,1,1,1】是z排序过的，而数组【1,2,3,4】不是。

你能对一个数组进行z排序吗？

## 输入格式

第一行包括一个整数$n$ ( 1<=$n$<=1000) ,代表数组$a$的元素个数。

第二行包括n个整数$a_i$（1<=$a_i$<=10$^9$）,代表数组$a$的每个元素

## 输出格式

如果可以将数组a进行z排序，输出排序后的数组，每个元素之间用空格隔开，否则输出“Impossible”。

## 样例 #1

### 输入

```
4
1 2 2 1

```

### 输出

```
1 2 1 2

```

## 样例 #2

### 输入

```
5
1 3 2 2 5

```

### 输出

```
1 5 2 3 2

```



---

---
title: "Tanya and Toys"
layout: "post"
diff: 普及-
pid: CF659C
tag: []
---

# Tanya and Toys

## 题目描述

In Berland recently a new collection of toys went on sale. This collection consists of $ 10^{9} $ types of toys, numbered with integers from $ 1 $ to $ 10^{9} $ . A toy from the new collection of the $ i $ -th type costs $ i $ bourles.

Tania has managed to collect $ n $ different types of toys $ a_{1},a_{2},...,a_{n} $ from the new collection. Today is Tanya's birthday, and her mother decided to spend no more than $ m $ bourles on the gift to the daughter. Tanya will choose several different types of toys from the new collection as a gift. Of course, she does not want to get a type of toy which she already has.

Tanya wants to have as many distinct types of toys in her collection as possible as the result. The new collection is too diverse, and Tanya is too little, so she asks you to help her in this.

## 输入格式

The first line contains two integers $ n $ ( $ 1<=n<=100000 $ ) and $ m $ ( $ 1<=m<=10^{9} $ ) — the number of types of toys that Tanya already has and the number of bourles that her mom is willing to spend on buying new toys.

The next line contains $ n $ distinct integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{9} $ ) — the types of toys that Tanya already has.

## 输出格式

In the first line print a single integer $ k $ — the number of different types of toys that Tanya should choose so that the number of different types of toys in her collection is maximum possible. Of course, the total cost of the selected toys should not exceed $ m $ .

In the second line print $ k $ distinct space-separated integers $ t_{1},t_{2},...,t_{k} $ ( $ 1<=t_{i}<=10^{9} $ ) — the types of toys that Tanya should choose.

If there are multiple answers, you may print any of them. Values of $ t_{i} $ can be printed in any order.

## 说明/提示

In the first sample mom should buy two toys: one toy of the $ 2 $ -nd type and one toy of the $ 5 $ -th type. At any other purchase for $ 7 $ bourles (assuming that the toys of types $ 1 $ , $ 3 $ and $ 4 $ have already been bought), it is impossible to buy two and more toys.

## 样例 #1

### 输入

```
3 7
1 3 4

```

### 输出

```
2
2 5 

```

## 样例 #2

### 输入

```
4 14
4 6 12 8

```

### 输出

```
4
7 2 3 1

```



---

---
title: "Bicycle Race"
layout: "post"
diff: 普及-
pid: CF659D
tag: []
---

# Bicycle Race

## 题目描述

Maria participates in a bicycle race.

The speedway takes place on the shores of Lake Lucerne, just repeating its contour. As you know, the lake shore consists only of straight sections, directed to the north, south, east or west.

Let's introduce a system of coordinates, directing the $ Ox $ axis from west to east, and the $ Oy $ axis from south to north. As a starting position of the race the southernmost point of the track is selected (and if there are several such points, the most western among them). The participants start the race, moving to the north. At all straight sections of the track, the participants travel in one of the four directions (north, south, east or west) and change the direction of movement only in bends between the straight sections. The participants, of course, never turn back, that is, they do not change the direction of movement from north to south or from east to west (or vice versa).

Maria is still young, so she does not feel confident at some turns. Namely, Maria feels insecure if at a failed or untimely turn, she gets into the water. In other words, Maria considers the turn dangerous if she immediately gets into the water if it is ignored.

Help Maria get ready for the competition — determine the number of dangerous turns on the track.

## 输入格式

The first line of the input contains an integer $ n $ ( $ 4<=n<=1000 $ ) — the number of straight sections of the track.

The following $ (n+1) $ -th line contains pairs of integers $ (x_{i},y_{i}) $ ( $ -10000<=x_{i},y_{i}<=10000 $ ). The first of these points is the starting position. The $ i $ -th straight section of the track begins at the point $ (x_{i},y_{i}) $ and ends at the point $ (x_{i+1},y_{i+1}) $ .

It is guaranteed that:

- the first straight section is directed to the north;
- the southernmost (and if there are several, then the most western of among them) point of the track is the first point;
- the last point coincides with the first one (i.e., the start position);
- any pair of straight sections of the track has no shared points (except for the neighboring ones, they share exactly one point);
- no pair of points (except for the first and last one) is the same;
- no two adjacent straight sections are directed in the same direction or in opposite directions.

## 输出格式

Print a single integer — the number of dangerous turns on the track.

## 说明/提示

The first sample corresponds to the picture:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF659D/d384618c4de83253addcd24088af2096098ca28a.png)The picture shows that you can get in the water under unfortunate circumstances only at turn at the point $ (1,1) $ . Thus, the answer is $ 1 $ .

## 样例 #1

### 输入

```
6
0 0
0 1
1 1
1 2
2 2
2 0
0 0

```

### 输出

```
1

```

## 样例 #2

### 输入

```
16
1 1
1 5
3 5
3 7
2 7
2 9
6 9
6 7
5 7
5 3
4 3
4 4
3 4
3 2
5 2
5 1
1 1

```

### 输出

```
6

```



---

---
title: "Harry Potter and Three Spells"
layout: "post"
diff: 普及-
pid: CF65A
tag: []
---

# Harry Potter and Three Spells

## 题目描述

很久以前（可能甚至在第一本书中），尼古拉斯·勒梅，一位伟大的炼金术士和魔法石的创造者，教了哈利·波特三个有用的咒语。第一种方法可以将 $a$ 克沙子转换成 $b$ 克铅，第二种方法可以将 $c$ 克铅转换成 $d$ 克金，第三种方法可以将 $e$ 克金转换成 $f$ 克沙子。

当哈利告诉他的朋友这些咒语时，罗恩很惊讶。毕竟，如果他们能把沙子变成铅，铅变成金，然后再把部分金变成沙子，那么就有可能从少量的沙子开始得到大量的金！即是无限量的黄金！

相比之下，格兰杰对这个想法持怀疑态度。她认为，根据物质守恒定律，获得无限量的物质，即使使用魔法，也是不可能的。相反，物质在转化过程中甚至会减少，转化为能量。

虽然赫敏的理论似乎令人信服，罗恩却不相信她。罗恩觉得，赫敏制定了只属于她的物质守恒定律，以阻止哈利和罗恩在这些胡言乱语上浪费时间，并且让他们去做作业。

这就是为什么罗恩已经收集了一定数量的沙子进行实验。

朋友之间的争吵似乎是不可避免的。帮助哈利确定他的朋友中哪一个是对的，避免争吵。要做到这一点，你必须弄清楚是否有可能从有限数量的沙子中获得比任何预先分配黄金数量更多的黄金数量。

---

## 输入格式

输入共一行，包含 $6$ 个整数，$a,b,c,d,e,f$ $(a,b,c,d,e,f\leq 1000)$。

---

## 输出格式

如果可以获得无限的黄金，输出`Ron`，否则输出`Hermione`。

---

#### 样例解释

##### 样例一

如果最初有 $500$ 克沙子，应用第一种法术 $5$ 次，把沙子变成 $1000$ 克铅。然后应用第二个法术 $4$ 次，得到 $600$ 克黄金，把其中 $400$ 克的黄金转化成沙子，得到 $500$ 克沙子和 $200$ 克黄金。对这其中的 $500$ 克沙子进行同样的操作，可以得到无限黄金。所以输出`Ron`。

##### 样例四

由于得不到任何物质，所以不能得到无限黄金，输出`Hermione`。

##### 样例五

因为使用第二种法术可以无限凭空得到金子，所以输出`Ron`。

##### 样例七

用第三种法术，可以凭空得到无限沙子。我们用这种方法先得到 $10000$ 克沙子，然后用第一种法术 $100$ 次获得 $100$ 克铅。用这些铅，可以转化为 $1$ 克黄金。显然，因为沙子数量无限，所以可以得到无限数量的黄金，输出`Ron`。

## 样例 #1

### 输入

```
100 200 250 150 200 250

```

### 输出

```
Ron

```

## 样例 #2

### 输入

```
100 50 50 200 200 100

```

### 输出

```
Hermione

```

## 样例 #3

### 输入

```
100 10 200 20 300 30

```

### 输出

```
Hermione

```

## 样例 #4

### 输入

```
0 0 0 0 0 0

```

### 输出

```
Hermione

```

## 样例 #5

### 输入

```
1 1 0 1 1 1

```

### 输出

```
Ron

```

## 样例 #6

### 输入

```
1 0 1 2 1 2

```

### 输出

```
Hermione

```

## 样例 #7

### 输入

```
100 1 100 1 0 1

```

### 输出

```
Ron

```



---

---
title: "Co-prime Array"
layout: "post"
diff: 普及-
pid: CF660A
tag: []
---

# Co-prime Array

## 题目描述

给你一个n个元素的数组，你必须尽可能少的添加元素使得该序列成为一个co-prime数组。

每次可以插入任何正整数不大于10^9在数组的任意位置。

如果一个数组的任意两个相邻的数是互质的，那么这个数组就是co-prime。

## 输入格式

第一行 n （1≤n≤1000）
第二行 ai的描述 (1≤ai≤10^9)

## 输出格式

第一行输出k的值---k为添加到数组a中使其成为co-prime数组的最少添加元素个数
第二行应该包含n+k个整数a[i]的输出
如果有多个答案，输出任意一个就行

## 样例 #1

### 输入

```
3
2 7 28

```

### 输出

```
1
2 7 9 28

```



---

---
title: "Seating On Bus"
layout: "post"
diff: 普及-
pid: CF660B
tag: []
---

# Seating On Bus

## 题目描述

Consider $ 2n $ rows of the seats in a bus. $ n $ rows of the seats on the left and $ n $ rows of the seats on the right. Each row can be filled by two people. So the total capacity of the bus is $ 4n $ .

Consider that $ m $ ( $ m<=4n $ ) people occupy the seats in the bus. The passengers entering the bus are numbered from $ 1 $ to $ m $ (in the order of their entering the bus). The pattern of the seat occupation is as below:

 $ 1 $ -st row left window seat, $ 1 $ -st row right window seat, $ 2 $ -nd row left window seat, $ 2 $ -nd row right window seat, ... , $ n $ -th row left window seat, $ n $ -th row right window seat.

After occupying all the window seats (for $ m&gt;2n $ ) the non-window seats are occupied:

 $ 1 $ -st row left non-window seat, $ 1 $ -st row right non-window seat, ... , $ n $ -th row left non-window seat, $ n $ -th row right non-window seat.

All the passengers go to a single final destination. In the final destination, the passengers get off in the given order.

 $ 1 $ -st row left non-window seat, $ 1 $ -st row left window seat, $ 1 $ -st row right non-window seat, $ 1 $ -st row right window seat, ... , $ n $ -th row left non-window seat, $ n $ -th row left window seat, $ n $ -th row right non-window seat, $ n $ -th row right window seat.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF660B/1bcb7084db323b1a8f04b6bcb377a8cb09279f9d.png)The seating for $ n=9 $ and $ m=36 $ .You are given the values $ n $ and $ m $ . Output $ m $ numbers from $ 1 $ to $ m $ , the order in which the passengers will get off the bus.

## 输入格式

The only line contains two integers, $ n $ and $ m $ ( $ 1<=n<=100,1<=m<=4n $ ) — the number of pairs of rows and the number of passengers.

## 输出格式

Print $ m $ distinct integers from $ 1 $ to $ m $ — the order in which the passengers will get off the bus.

## 样例 #1

### 输入

```
2 7

```

### 输出

```
5 1 6 2 7 3 4

```

## 样例 #2

### 输入

```
9 36

```

### 输出

```
19 1 20 2 21 3 22 4 23 5 24 6 25 7 26 8 27 9 28 10 29 11 30 12 31 13 32 14 33 15 34 16 35 17 36 18

```



---

---
title: "Complicated GCD"
layout: "post"
diff: 普及-
pid: CF664A
tag: []
---

# Complicated GCD

## 题目描述

【问题描述】 给你若干个整数，它们是a,a+1,a+2,…,b，请求出它们的最大公约数，即 gcd(a, a+1, a+2, …, b)。

## 输出格式

【输入样例1】 1 2

【输出样例1】 1

【输入样例2】 61803398874989484820458683436563811772030917980576 

61803398874989484820458683436563811772030917980576

【输出样例2】 61803398874989484820458683436563811772030917980576

## 样例 #1

### 输入

```
1 2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576

```

### 输出

```
61803398874989484820458683436563811772030917980576

```



---

---
title: "Shopping"
layout: "post"
diff: 普及-
pid: CF665B
tag: []
---

# Shopping

## 题目描述

小 $W$​​ 的商店开始了线上购物，线下提货的服务。商店有 $k$​​ 个商品（编号 $1$ 到 $k$）， $n$ 个用户使用了这项服务。每个用户的订单都包含 $m$ 个商品，并在线付费，以  $a_{ij}$ 表示第 $i$ 个用户的订单中第 $j$ 个商品的编号。所有的商品是排成一排的，在小 $W$ 收到第 $i$ 件商品时，他会从前向后找所有的商品 $a_{ij}$  ( $1\le j\le m$ )，令 $pos(x)$ 表示该用户需要的编号为 $x$ 的商品，此时在序列中的位置。小 $W$ 需要 $pos(a_{i1})+pos(a_{i2})+...+pos(a_{im})$ 为第 $i$ 个客户服务的时间。当小 $W$ 访问第 $x$ 个元素时，他会将新的存货放到最前面，并将位置为 $x$ 的元素移除，因此，此序列是在不断更新的。你需要算出小 $W$​ 需要的时间。假设市场上有无尽的存货。

## 输入格式

第一行包含三个整数 $n$ ， $m$  和 $k$ ( $1\le n,k\le 100,1\le m\le k$ ) 。第二行包含 $k$ 个正整数 $p_1,p_2,...,p_k$ ( $1\le p_i\le k$ ) 。接下来的 $n$​​​ 行，每行包含 $m$​​​ 个正整数 $ a_{ij} $​​​ ( $1\le a_{ij}\le k$​​​​​ ) 。

## 输出格式

仅一行，输出一个整数 $t$​ ，即小 $W$​ 需要的时间。



#### 样例解释：

顾客 $1$ 想要 $1$ 号和 $5$号商品 。$pos(1)=3$ ，所以新的顺序是： $[1,3,4,2,5]$ 。$ pos(5)=5 $ ，所以新的顺序是： $[5,1,3,4,2]$ 。第一个顾客需要的时间为 $3+5=8$ 。顾客 $2$ 想要 $3$ 号和 $1$ 号商品。$pos(3)=3$ ，所以新的顺序是： $[3,5,1,4,2]$ 。$ pos(1)=3 $ ，所以新的顺序是： $ [1,3,5,4,2] $ 。第二个顾客需要的时间为 $3+3=6$ 。总时间是 $8+6=14$ 。在形式上，在队列里， $pos(x)$ 是 $x$​​​ 的指针。

## 样例 #1

### 输入

```
2 2 5
3 4 1 2 5
1 5
3 1

```

### 输出

```
14

```



---

---
title: "Simple Strings"
layout: "post"
diff: 普及-
pid: CF665C
tag: []
---

# Simple Strings

## 题目描述

zscoder loves simple strings! A string $ t $ is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple.

zscoder is given a string $ s $ . He wants to change a minimum number of characters so that the string $ s $ becomes simple. Help him with this task!

## 输入格式

The only line contains the string $ s $ ( $ 1<=|s|<=2·10^{5} $ ) — the string given to zscoder. The string $ s $ consists of only lowercase English letters.

## 输出格式

Print the simple string $ s' $ — the string $ s $ after the minimal number of changes. If there are multiple solutions, you may output any of them.

Note that the string $ s' $ should also consist of only lowercase English letters.

## 样例 #1

### 输入

```
aab

```

### 输出

```
bab

```

## 样例 #2

### 输入

```
caaab

```

### 输出

```
cabab

```

## 样例 #3

### 输入

```
zscoder

```

### 输出

```
zscoder

```



---

---
title: "Coat of Anticubism"
layout: "post"
diff: 普及-
pid: CF667B
tag: []
---

# Coat of Anticubism

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF667B/da431a35861ffb0dfb05294a401b5e75bc0d5240.png)As some of you know, cubism is a trend in art, where the problem of constructing volumetrical shape on a plane with a combination of three-dimensional geometric shapes comes to the fore.

A famous sculptor Cicasso, whose self-portrait you can contemplate, hates cubism. He is more impressed by the idea to transmit two-dimensional objects through three-dimensional objects by using his magnificent sculptures. And his new project is connected with this. Cicasso wants to make a coat for the haters of anticubism. To do this, he wants to create a sculpture depicting a well-known geometric primitive — convex polygon.

Cicasso prepared for this a few blanks, which are rods with integer lengths, and now he wants to bring them together. The $ i $ -th rod is a segment of length $ l_{i} $ .

The sculptor plans to make a convex polygon with a nonzero area, using all rods he has as its sides. Each rod should be used as a side to its full length. It is forbidden to cut, break or bend rods. However, two sides may form a straight angle ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF667B/88c61e080ae2c77e20323807b54f172a39161c4f.png).

Cicasso knows that it is impossible to make a convex polygon with a nonzero area out of the rods with the lengths which he had chosen. Cicasso does not want to leave the unused rods, so the sculptor decides to make another rod-blank with an integer length so that his problem is solvable. Of course, he wants to make it as short as possible, because the materials are expensive, and it is improper deed to spend money for nothing.

Help sculptor!

## 输入格式

The first line contains an integer $ n $ ( $ 3<=n<=10^{5} $ ) — a number of rod-blanks.

The second line contains $ n $ integers $ l_{i} $ ( $ 1<=l_{i}<=10^{9} $ ) — lengths of rods, which Cicasso already has. It is guaranteed that it is impossible to make a polygon with $ n $ vertices and nonzero area using the rods Cicasso already has.

## 输出格式

Print the only integer $ z $ — the minimum length of the rod, so that after adding it it can be possible to construct convex polygon with $ (n+1) $ vertices and nonzero area from all of the rods.

## 说明/提示

In the first example triangle with sides $ {1+1=2,2,1} $ can be formed from a set of lengths $ {1,1,1,2} $ .

In the second example you can make a triangle with lengths $ {20,11,4+3+2+1=10} $ .

## 样例 #1

### 输入

```
3
1 2 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
20 4 3 2 1

```

### 输出

```
11

```



---

---
title: "Petya and Countryside"
layout: "post"
diff: 普及-
pid: CF66B
tag: []
---

# Petya and Countryside

## 题目描述

Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle $ 1×n $ in size, when viewed from above. This rectangle is divided into $ n $ equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.

Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a $ 1×5 $ rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF66B/9a7bf3e55f07a79a8c55bac4c2b87a72e9e3e5af.png)As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him.

## 输入格式

The first line contains a positive integer $ n $ ( $ 1<=n<=1000 $ ). The second line contains $ n $ positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.

## 输出格式

Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.

## 样例 #1

### 输入

```
1
2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
1 2 1 2 1

```

### 输出

```
3

```

## 样例 #3

### 输入

```
8
1 2 1 1 1 3 3 4

```

### 输出

```
6

```



---

---
title: "Game of Robots"
layout: "post"
diff: 普及-
pid: CF670B
tag: []
---

# Game of Robots

## 题目描述

有$n(n\leq100000)$个机器人，每个机器人都有一个唯一的整数序号，该序号在$1$到$10^9$之间。他们在做一个叫“滚雪球”的游戏，即第一个机器人说出第一个机器人的序号，第二个机器人说出第一到第二个机器人的序号，第三个机器人说出第一到第三个机器人的序号……以此类推。求第$k(k\leq min(2\cdot10^9,n\cdot(n+1)/2)$个被说出的序号。

## 输入格式

第一行包含两个整数$n$和$k$（范围如上所述）。

第二行包含$n$个整数，第$i$个整数代表第$i$个机器人的序号。

## 输出格式

一行，包含第$k$个被说出的序号

## 样例 #1

### 输入

```
2 2
1 2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4 5
10 4 18 3

```

### 输出

```
4

```



---

---
title: "Cinema"
layout: "post"
diff: 普及-
pid: CF670C
tag: []
---

# Cinema

## 题目描述

莫斯科在举办一场重要的有$n$ 个不同国家的珂学家参与的国际会议，每个珂学家都只会一种语言。为了方便起见，我们规定一种语言用$1$ 到$10^9$ 的数来描述。 
在会议之后的晚上，珂学家们决定去看电影。他们去的电影院有$m$ 场电影，每场有两个不同的数字，分别代表配音的语言和字幕的语言。如果一个珂学家能听懂配音，他会非常愉悦；如果能看懂字幕，他会比较满意。如果既看不懂也听不懂，他会很生气。 
珂学家们决定去看同一场电影，你必须帮助他们选择一场电影，让愉悦的人最多的前提下，比较满意的人最多。

## 输入格式

第二行$n$ 个整数$a_1, a_2, ..., a_n(1 \leq a_i \leq 10^9)$ 表示珂学家们会的语言。 
第三行一个整数$1 \leq m \leq 200000$ 表示电影的场数。 
第四行$m$ 个整数$b_1, b_2, ..., b_n(1 \leq b_j \leq 10^9)$ 表示电影的配音用的语言。
第五行$m$ 个整数$c_1, c_2, ..., c_n(1 \leq c_j \leq 10^9)$ 表示电影的字幕用的语言。

## 样例 #1

### 输入

```
3
2 3 2
2
3 2
2 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
6
6 3 1 1 3 7
5
1 2 3 4 5
2 3 4 5 1

```

### 输出

```
1

```



---

---
title: "Different is Good"
layout: "post"
diff: 普及-
pid: CF672B
tag: []
---

# Different is Good

## 题目描述

A wise man told Kerem "Different is good" once, so Kerem wants all things in his life to be different.

Kerem recently got a string $ s $ consisting of lowercase English letters. Since Kerem likes it when things are different, he wants all substrings of his string $ s $ to be distinct. Substring is a string formed by some number of consecutive characters of the string. For example, string "aba" has substrings "" (empty substring), "a", "b", "a", "ab", "ba", "aba".

If string $ s $ has at least two equal substrings then Kerem will change characters at some positions to some other lowercase English letters. Changing characters is a very tiring job, so Kerem want to perform as few changes as possible.

Your task is to find the minimum number of changes needed to make all the substrings of the given string distinct, or determine that it is impossible.

## 输入格式

The first line of the input contains an integer $ n $ ( $ 1<=n<=100000 $ ) — the length of the string $ s $ .

The second line contains the string $ s $ of length $ n $ consisting of only lowercase English letters.

## 输出格式

If it's impossible to change the string $ s $ such that all its substring are distinct print -1. Otherwise print the minimum required number of changes.

## 说明/提示

In the first sample one of the possible solutions is to change the first character to 'b'.

In the second sample, one may change the first character to 'a' and second character to 'b', so the string becomes "abko".

## 样例 #1

### 输入

```
2
aa

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4
koko

```

### 输出

```
2

```

## 样例 #3

### 输入

```
5
murat

```

### 输出

```
0

```



---

---
title: "Bear and Game"
layout: "post"
diff: 普及-
pid: CF673A
tag: []
---

# Bear and Game

## 题目描述

Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts $ 90 $ minutes and there are no breaks.

Each minute can be either interesting or boring. If $ 15 $ consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be $ n $ interesting minutes $ t_{1},t_{2},...,t_{n} $ . Your task is to calculate for how many minutes Limak will watch the game.

## 输入格式

The first line of the input contains one integer $ n $ ( $ 1<=n<=90 $ ) — the number of interesting minutes.

The second line contains $ n $ integers $ t_{1},t_{2},...,t_{n} $ ( $ 1<=t_{1}&lt;t_{2}&lt;...\ t_{n}<=90 $ ), given in the increasing order.

## 输出格式

Print the number of minutes Limak will watch the game.

## 说明/提示

In the first sample, minutes $ 21,22,...,35 $ are all boring and thus Limak will turn TV off immediately after the $ 35 $ -th minute. So, he would watch the game for $ 35 $ minutes.

In the second sample, the first $ 15 $ minutes are boring.

In the third sample, there are no consecutive $ 15 $ boring minutes. So, Limak will watch the whole game.

## 样例 #1

### 输入

```
3
7 20 88

```

### 输出

```
35

```

## 样例 #2

### 输入

```
9
16 20 30 40 50 60 70 80 90

```

### 输出

```
15

```

## 样例 #3

### 输入

```
9
15 20 30 40 50 60 70 80 90

```

### 输出

```
90

```



---

---
title: "Nicholas and Permutation"
layout: "post"
diff: 普及-
pid: CF676A
tag: []
---

# Nicholas and Permutation

## 题目描述

Nicholas has an array $ a $ that contains $ n $ distinct integers from $ 1 $ to $ n $ . In other words, Nicholas has a permutation of size $ n $ .

Nicholas want the minimum element (integer $ 1 $ ) and the maximum element (integer $ n $ ) to be as far as possible from each other. He wants to perform exactly one swap in order to maximize the distance between the minimum and the maximum elements. The distance between two elements is considered to be equal to the absolute difference between their positions.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 2<=n<=100 $ ) — the size of the permutation.

The second line of the input contains $ n $ distinct integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=n $ ), where $ a_{i} $ is equal to the element at the $ i $ -th position.

## 输出格式

Print a single integer — the maximum possible distance between the minimum and the maximum elements Nicholas can achieve by performing exactly one swap.

## 说明/提示

In the first sample, one may obtain the optimal answer by swapping elements $ 1 $ and $ 2 $ .

In the second sample, the minimum and the maximum elements will be located in the opposite ends of the array if we swap $ 7 $ and $ 2 $ .

In the third sample, the distance between the minimum and the maximum elements is already maximum possible, so we just perform some unnecessary swap, for example, one can swap $ 5 $ and $ 2 $ .

## 样例 #1

### 输入

```
5
4 5 1 3 2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
7
1 6 5 3 4 7 2

```

### 输出

```
6

```

## 样例 #3

### 输入

```
6
6 5 4 3 2 1

```

### 输出

```
5

```



---

---
title: "Bear and Five Cards"
layout: "post"
diff: 普及-
pid: CF680A
tag: []
---

# Bear and Five Cards

## 题目描述

A little bear Limak plays a game. He has five cards. There is one number written on each card. Each number is a positive integer.

Limak can discard (throw out) some cards. His goal is to minimize the sum of numbers written on remaining (not discarded) cards.

He is allowed to at most once discard two or three cards with the same number. Of course, he won't discard cards if it's impossible to choose two or three cards with the same number.

Given five numbers written on cards, cay you find the minimum sum of numbers on remaining cards?

## 输入格式

The only line of the input contains five integers $ t_{1} $ , $ t_{2} $ , $ t_{3} $ , $ t_{4} $ and $ t_{5} $ ( $ 1<=t_{i}<=100 $ ) — numbers written on cards.

## 输出格式

Print the minimum possible sum of numbers written on remaining cards.

## 说明/提示

In the first sample, Limak has cards with numbers $ 7 $ , $ 3 $ , $ 7 $ , $ 3 $ and $ 20 $ . Limak can do one of the following.

- Do nothing and the sum would be $ 7+3+7+3+20=40 $ .
- Remove two cards with a number $ 7 $ . The remaining sum would be $ 3+3+20=26 $ .
- Remove two cards with a number $ 3 $ . The remaining sum would be $ 7+7+20=34 $ .

You are asked to minimize the sum so the answer is $ 26 $ .

In the second sample, it's impossible to find two or three cards with the same number. Hence, Limak does nothing and the sum is $ 7+9+1+3+8=28 $ .

In the third sample, all cards have the same number. It's optimal to discard any three cards. The sum of two remaining numbers is $ 10+10=20 $ .

## 样例 #1

### 输入

```
7 3 7 3 20

```

### 输出

```
26

```

## 样例 #2

### 输入

```
7 9 3 1 8

```

### 输出

```
28

```

## 样例 #3

### 输入

```
10 10 10 10 10

```

### 输出

```
20

```



---

---
title: "Bear and Finding Criminals"
layout: "post"
diff: 普及-
pid: CF680B
tag: []
---

# Bear and Finding Criminals

## 题目描述

There are $ n $ cities in Bearland, numbered $ 1 $ through $ n $ . Cities are arranged in one long row. The distance between cities $ i $ and $ j $ is equal to $ |i-j| $ .

Limak is a police officer. He lives in a city $ a $ . His job is to catch criminals. It's hard because he doesn't know in which cities criminals are. Though, he knows that there is at most one criminal in each city.

Limak is going to use a BCD (Bear Criminal Detector). The BCD will tell Limak how many criminals there are for every distance from a city $ a $ . After that, Limak can catch a criminal in each city for which he is sure that there must be a criminal.

You know in which cities criminals are. Count the number of criminals Limak will catch, after he uses the BCD.

## 输入格式

The first line of the input contains two integers $ n $ and $ a $ ( $ 1<=a<=n<=100 $ ) — the number of cities and the index of city where Limak lives.

The second line contains $ n $ integers $ t_{1},t_{2},...,t_{n} $ ( $ 0<=t_{i}<=1 $ ). There are $ t_{i} $ criminals in the $ i $ -th city.

## 输出格式

Print the number of criminals Limak will catch.

## 说明/提示

In the first sample, there are six cities and Limak lives in the third one (blue arrow below). Criminals are in cities marked red.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF680B/53b34f04c80c68b5459bb6787b79d861ce7bb49e.png)Using the BCD gives Limak the following information:

- There is one criminal at distance $ 0 $ from the third city — Limak is sure that this criminal is exactly in the third city.
- There is one criminal at distance $ 1 $ from the third city — Limak doesn't know if a criminal is in the second or fourth city.
- There are two criminals at distance $ 2 $ from the third city — Limak is sure that there is one criminal in the first city and one in the fifth city.
- There are zero criminals for every greater distance.

So, Limak will catch criminals in cities $ 1 $ , $ 3 $ and $ 5 $ , that is $ 3 $ criminals in total.

In the second sample (drawing below), the BCD gives Limak the information that there is one criminal at distance $ 2 $ from Limak's city. There is only one city at distance $ 2 $ so Limak is sure where a criminal is.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF680B/9b09abcaba16810167119bac2c883bc8bf99b11b.png)

## 样例 #1

### 输入

```
6 3
1 1 1 0 1 0

```

### 输出

```
3

```

## 样例 #2

### 输入

```
5 2
0 0 0 1 0

```

### 输出

```
1

```



---

---
title: "Alyona and Numbers"
layout: "post"
diff: 普及-
pid: CF682A
tag: []
---

# Alyona and Numbers

## 题目描述

After finishing eating her bun, Alyona came up with two integers $ n $ and $ m $ . She decided to write down two columns of integers — the first column containing integers from $ 1 $ to $ n $ and the second containing integers from $ 1 $ to $ m $ . Now the girl wants to count how many pairs of integers she can choose, one from the first column and the other from the second column, such that their sum is divisible by $ 5 $ .

Formally, Alyona wants to count the number of pairs of integers $ (x,y) $ such that $ 1<=x<=n $ , $ 1<=y<=m $ and ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF682A/bb850c8c10ee7a9c00e5b1ff3da7605a7415f98c.png) equals $ 0 $ .

As usual, Alyona has some troubles and asks you to help.

## 输入格式

The only line of the input contains two integers $ n $ and $ m $ ( $ 1<=n,m<=1000000 $ ).

## 输出格式

Print the only integer — the number of pairs of integers $ (x,y) $ such that $ 1<=x<=n $ , $ 1<=y<=m $ and $ (x+y) $ is divisible by $ 5 $ .

## 说明/提示

Following pairs are suitable in the first sample case:

- for $ x=1 $ fits $ y $ equal to $ 4 $ or $ 9 $ ;
- for $ x=2 $ fits $ y $ equal to $ 3 $ or $ 8 $ ;
- for $ x=3 $ fits $ y $ equal to $ 2 $ , $ 7 $ or $ 12 $ ;
- for $ x=4 $ fits $ y $ equal to $ 1 $ , $ 6 $ or $ 11 $ ;
- for $ x=5 $ fits $ y $ equal to $ 5 $ or $ 10 $ ;
- for $ x=6 $ fits $ y $ equal to $ 4 $ or $ 9 $ .

Only the pair $ (1,4) $ is suitable in the third sample case.

## 样例 #1

### 输入

```
6 12

```

### 输出

```
14

```

## 样例 #2

### 输入

```
11 14

```

### 输出

```
31

```

## 样例 #3

### 输入

```
1 5

```

### 输出

```
1

```

## 样例 #4

### 输入

```
3 8

```

### 输出

```
5

```

## 样例 #5

### 输入

```
5 7

```

### 输出

```
7

```

## 样例 #6

### 输入

```
21 21

```

### 输出

```
88

```



---

---
title: "Alyona and Mex"
layout: "post"
diff: 普及-
pid: CF682B
tag: []
---

# Alyona and Mex

## 题目描述

Someone gave Alyona an array containing $ n $ positive integers $ a_{1},a_{2},...,a_{n} $ . In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.

Formally, after applying some operations Alyona will get an array of $ n $ positive integers $ b_{1},b_{2},...,b_{n} $ such that $ 1<=b_{i}<=a_{i} $ for every $ 1<=i<=n $ . Your task is to determine the maximum possible value of mex of this array.

Mex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing $ 1 $ , $ 3 $ and $ 4 $ is equal to $ 2 $ , while mex of the array containing $ 2 $ , $ 3 $ and $ 2 $ is equal to $ 1 $ .

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=100000 $ ) — the number of elements in the Alyona's array.

The second line of the input contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{9} $ ) — the elements of the array.

## 输出格式

Print one positive integer — the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.

## 说明/提示

In the first sample case if one will decrease the second element value to $ 2 $ and the fifth element value to $ 4 $ then the mex value of resulting array $ 1 $ $ 2 $ $ 3 $ $ 3 $ $ 4 $ will be equal to $ 5 $ .

To reach the answer to the second sample case one must not decrease any of the array elements.

## 样例 #1

### 输入

```
5
1 3 3 3 6

```

### 输出

```
5

```

## 样例 #2

### 输入

```
2
2 1

```

### 输出

```
3

```



---

---
title: "Free Ice Cream"
layout: "post"
diff: 普及-
pid: CF686A
tag: []
---

# Free Ice Cream

## 题目描述

凯和格尔达开了个冰淇凌店。他们最开始有x个冰淇淋。冰淇淋是免费的。人们可以给他们提供d个冰淇淋，也可以从他们这里要d个冰淇淋。若他们的冰淇淋不够给要冰淇淋的人，要冰淇淋的人会失落，他们的冰淇淋不会减少。他们想知道收摊以后，他们还剩多少冰淇淋和有多少失落的人。

## 输入格式

输入n,x（1<=n<=1000,0<=x<=10^9）,表示有n个人，最开始有x个冰淇淋
接下来每行输入‘+’或‘-’和d，“+ d”表示有人给了d个冰淇淋，“- d”表示有人想要d个冰淇淋

## 输出格式

输出两个数，剩的冰淇淋数和失落的人数

## 样例 #1

### 输入

```
5 7
+ 5
- 10
- 20
+ 40
- 20

```

### 输出

```
22 1

```

## 样例 #2

### 输入

```
5 17
- 16
- 2
- 98
+ 100
- 98

```

### 输出

```
3 2

```



---

---
title: "Little Robber Girl's Zoo"
layout: "post"
diff: 普及-
pid: CF686B
tag: []
---

# Little Robber Girl's Zoo

## 题目描述

Little Robber Girl likes to scare animals in her zoo for fun. She decided to arrange the animals in a row in the order of non-decreasing height. However, the animals were so scared that they couldn't stay in the right places.

The robber girl was angry at first, but then she decided to arrange the animals herself. She repeatedly names numbers $ l $ and $ r $ such that $ r-l+1 $ is even. After that animals that occupy positions between $ l $ and $ r $ inclusively are rearranged as follows: the animal at position $ l $ swaps places with the animal at position $ l+1 $ , the animal $ l+2 $ swaps with the animal $ l+3 $ , ..., finally, the animal at position $ r-1 $ swaps with the animal $ r $ .

Help the robber girl to arrange the animals in the order of non-decreasing height. You should name at most $ 20000 $ segments, since otherwise the robber girl will become bored and will start scaring the animals again.

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=100 $ ) — number of animals in the robber girl's zoo.

The second line contains $ n $ space-separated integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{9} $ ), where $ a_{i} $ is the height of the animal occupying the $ i $ -th place.

## 输出格式

Print the sequence of operations that will rearrange the animals by non-decreasing height.

The output should contain several lines, $ i $ -th of the lines should contain two space-separated integers $ l_{i} $ and $ r_{i} $ ( $ 1<=l_{i}&lt;r_{i}<=n $ ) — descriptions of segments the robber girl should name. The segments should be described in the order the operations are performed.

The number of operations should not exceed $ 20000 $ .

If the animals are arranged correctly from the start, you are allowed to output nothing.

## 说明/提示

Note that you don't have to minimize the number of operations. Any solution that performs at most $ 20000 $ operations is allowed.

## 样例 #1

### 输入

```
4
2 1 4 3

```

### 输出

```
1 4

```

## 样例 #2

### 输入

```
7
36 28 57 39 66 69 68

```

### 输出

```
1 4
6 7

```

## 样例 #3

### 输入

```
5
1 2 1 2 1

```

### 输出

```
2 5
3 4
1 4
1 4

```



---

---
title: "Collective Mindsets (easy)"
layout: "post"
diff: 普及-
pid: CF690A1
tag: []
---

# Collective Mindsets (easy)

## 题目描述

Tonight is brain dinner night and all zombies will gather together to scarf down some delicious brains. The artful Heidi plans to crash the party, incognito, disguised as one of them. Her objective is to get away with at least one brain, so she can analyze the zombies' mindset back home and gain a strategic advantage.

They will be $ N $ guests tonight: $ N-1 $ real zombies and a fake one, our Heidi. The living-dead love hierarchies as much as they love brains: each one has a unique rank in the range $ 1 $ to $ N-1 $ , and Heidi, who still appears slightly different from the others, is attributed the highest rank, $ N $ . Tonight there will be a chest with brains on display and every attendee sees how many there are. These will then be split among the attendees according to the following procedure:

The zombie of the highest rank makes a suggestion on who gets how many brains (every brain is an indivisible entity). A vote follows. If at least half of the attendees accept the offer, the brains are shared in the suggested way and the feast begins. But if majority is not reached, then the highest-ranked zombie is killed, and the next zombie in hierarchy has to make a suggestion. If he is killed too, then the third highest-ranked makes one, etc. (It's enough to have exactly half of the votes – in case of a tie, the vote of the highest-ranked alive zombie counts twice, and he will of course vote in favor of his own suggestion in order to stay alive.)

You should know that zombies are very greedy and sly, and they know this too – basically all zombie brains are alike. Consequently, a zombie will never accept an offer which is suboptimal for him. That is, if an offer is not strictly better than a potential later offer, he will vote against it. And make no mistake: while zombies may normally seem rather dull, tonight their intellects are perfect. Each zombie's priorities for tonight are, in descending order:

1. survive the event (they experienced death already once and know it is no fun),
2. get as many brains as possible.

Heidi goes first and must make an offer which at least half of the attendees will accept, and which allocates at least one brain for Heidi herself.

What is the smallest number of brains that have to be in the chest for this to be possible?

## 输入格式

The only line of input contains one integer: $ N $ , the number of attendees ( $ 1<=N<=10^{9} $ ).

## 输出格式

Output one integer: the smallest number of brains in the chest which allows Heidi to take one brain home.

## 样例 #1

### 输入

```
1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4

```

### 输出

```
2

```



---

---
title: "s-palindrome"
layout: "post"
diff: 普及-
pid: CF691B
tag: []
---

# s-palindrome

## 题目描述

Let's call a string "s-palindrome" if it is symmetric about the middle of the string. For example, the string "oHo" is "s-palindrome", but the string "aa" is not. The string "aa" is not "s-palindrome", because the second half of it is not a mirror reflection of the first half.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF691B/4db2e6d4ff8e49af69a33905ad7864160ff04588.png)English alphabetYou are given a string $ s $ . Check if the string is "s-palindrome".

## 输入格式

The only line contains the string $ s $ ( $ 1<=|s|<=1000 $ ) which consists of only English letters.

## 输出格式

Print "TAK" if the string $ s $ is "s-palindrome" and "NIE" otherwise.

## 样例 #1

### 输入

```
oXoxoXo

```

### 输出

```
TAK

```

## 样例 #2

### 输入

```
bod

```

### 输出

```
TAK

```

## 样例 #3

### 输入

```
ER

```

### 输出

```
NIE

```



---

---
title: "Launch of Collider"
layout: "post"
diff: 普及-
pid: CF699A
tag: []
---

# Launch of Collider

## 题目描述

There will be a launch of a new, powerful and unusual collider very soon, which located along a straight line. $ n $ particles will be launched inside it. All of them are located in a straight line and there can not be two or more particles located in the same point. The coordinates of the particles coincide with the distance in meters from the center of the collider, $ x_{i} $ is the coordinate of the $ i $ -th particle and its position in the collider at the same time. All coordinates of particle positions are even integers.

You know the direction of each particle movement — it will move to the right or to the left after the collider's launch start. All particles begin to move simultaneously at the time of the collider's launch start. Each particle will move straight to the left or straight to the right with the constant speed of $ 1 $ meter per microsecond. The collider is big enough so particles can not leave it in the foreseeable time.

Write the program which finds the moment of the first collision of any two particles of the collider. In other words, find the number of microseconds before the first moment when any two particles are at the same point.

## 输入格式

The first line contains the positive integer $ n $ ( $ 1<=n<=200000 $ ) — the number of particles.

The second line contains $ n $ symbols "L" and "R". If the $ i $ -th symbol equals "L", then the $ i $ -th particle will move to the left, otherwise the $ i $ -th symbol equals "R" and the $ i $ -th particle will move to the right.

The third line contains the sequence of pairwise distinct even integers $ x_{1},x_{2},...,x_{n} $ ( $ 0<=x_{i}<=10^{9} $ ) — the coordinates of particles in the order from the left to the right. It is guaranteed that the coordinates of particles are given in the increasing order.

## 输出格式

In the first line print the only integer — the first moment (in microseconds) when two particles are at the same point and there will be an explosion.

Print the only integer -1, if the collision of particles doesn't happen.

## 说明/提示

In the first sample case the first explosion will happen in $ 1 $ microsecond because the particles number $ 1 $ and $ 2 $ will simultaneously be at the same point with the coordinate $ 3 $ .

In the second sample case there will be no explosion because there are no particles which will simultaneously be at the same point.

## 样例 #1

### 输入

```
4
RLRL
2 4 6 10

```

### 输出

```
1

```

## 样例 #2

### 输入

```
3
LLR
40 50 60

```

### 输出

```
-1

```



---

---
title: "One Bomb"
layout: "post"
diff: 普及-
pid: CF699B
tag: []
---

# One Bomb

## 题目描述

你接到了一个拆除工作：

有一个 $n*m$ 个单元格的仓库，其中每个格子只可能是"."或"*"。

"."表示该格子为空，"*"表示这里有一面墙。

现在你有一枚炸弹，可以爆破所有同行或同列的墙(它既可以放在墙内，也可以放在空单元格)

请你找出一种放置炸弹的方式，使得所有的墙都能被清除。

## 输入格式

第一行，两个整数$n$，$m$ $(1<=n,m<=1000)$

接下来是一个$n*m$的矩阵，表示仓库的分布图。

## 输出格式

如果一颗炸弹就可以清除所有的墙，就输出"YES"（没有引号）,并在下一行输出x和y，表示炸弹放置的位置。

否则输出"NO"（同样没有引号）

如果存在多于一种方案，则输出其中一种即可。

## 样例 #1

### 输入

```
3 4
.*..
....
.*..

```

### 输出

```
YES
1 2

```

## 样例 #2

### 输入

```
3 3
..*
.*.
*..

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
6 5
..*..
..*..
*****
..*..
..*..
..*..

```

### 输出

```
YES
3 3

```



---

---
title: "Bets"
layout: "post"
diff: 普及-
pid: CF69B
tag: []
---

# Bets

## 题目描述

在chelyabinsk这个地方住着一个厉害的商人，他叫nikita。人人都叫他boss (老板的意思)。

有一天nikita跟朋友alex一起去一个叫做summer biathlon world cup (夏日滑雪世界杯？。)的比赛。

nikita因为是一个厉害的人，所以他拿到了一个神奇奖券。这个奖券可以让他赌谁赢，每个赛道不能赌超过一个选手。



------------


------------


这个比赛的规则是这样的：

有n个相等长度的赛道以及m个参赛者（编号1到m）。对于每个参赛者有以下信息：

- Li：始发赛道号码

- Ri：结束赛道号码（Li<=Ri）

- Ti：这个选手完成一个赛道的时间

- Ci：利润。。。单位是卢布（俄罗斯货币单位）。如果这个选手赢了，那么赌这个人会赢的人可以获得这么多钱。


第i个选手穿过从Li到Ri的赛道（包括Li和Ri），时间为(Ri-Li+1)·Ti个单位时间。每个赛道都需要Ti个单位时间。若这个选手在k个赛道中获得胜利，那么赌他会赢的人可以拿到k·Ci卢布。


在每个赛道中，每个独立的获胜者符合：


- 如果至少有一个选手在这个赛道中比赛，那么获胜者为花时间最少的人。花时间最少指仅在这个赛道上的花时间最少的人。


- 如果有多个选手用相同的时间，那么序号小的选手获胜。

- 如果这个赛道上没有选手，那么就没有获胜者。

注意：每个人的速度始终不变。


nikita可以在每个赛道上分别赌任何一个选手会赢。


帮助nikita和alex找到最大的利润。



------------


------------

## 输入格式

第一行两个整数n和m(1<=n,m<=100)。接着的m行每行四个整数Li, Ri, Ti, Ci (1<=Li<=Ri<=n, 1<=Ti, Ci<=1000)。



------------


------------

## 输出格式

一行，最大的利润值。

again:每个赛道不能赌超过一个选手。



------------


------------

## 说明/提示

**第一个测试数据**

第1-2个赛道赌选手1。

第3个赛道赌选手3。

第4个赛道赌选手4。

利润为5（赛道1）+5（赛道2）+30（赛道3）+20（赛道4）=60卢布。

**第二个测试数据**

第1，5个赛道赌选手1。

第2-4个赛道赌选手2。

第6-7个赛道赌选手4。

第八个赛道没有获胜者。

利润为10（赛道1）+15（赛道2-4）+10（赛道5）+20（赛道6，7）=105卢布。

## 样例 #1

### 输入

```
4 4
1 4 20 5
1 3 21 10
3 3 4 30
3 4 4 20

```

### 输出

```
60
```

## 样例 #2

### 输入

```
8 4
1 5 24 10
2 4 6 15
4 6 30 50
6 7 4 20

```

### 输出

```
105
```



---

---
title: "Mishka and trip"
layout: "post"
diff: 普及-
pid: CF703B
tag: []
---

# Mishka and trip

## 题目描述

Little Mishka is a great traveller and she visited many countries. After thinking about where to travel this time, she chose XXX — beautiful, but little-known northern country.

Here are some interesting facts about XXX:

1. XXX consists of $ n $ cities, $ k $ of whose (just imagine!) are capital cities.
2. All of cities in the country are beautiful, but each is beautiful in its own way. Beauty value of $ i $ -th city equals to $ c_{i} $ .
3. All the cities are consecutively connected by the roads, including $ 1 $ -st and $ n $ -th city, forming a cyclic route $ 1—2—...—n—1 $ . Formally, for every $ 1<=i&lt;n $ there is a road between $ i $ -th and $ i+1 $ -th city, and another one between $ 1 $ -st and $ n $ -th city.
4. Each capital city is connected with each other city directly by the roads. Formally, if city $ x $ is a capital city, then for every $ 1<=i<=n,i≠x $ , there is a road between cities $ x $ and $ i $ .
5. There is at most one road between any two cities.
6. Price of passing a road directly depends on beauty values of cities it connects. Thus if there is a road between cities $ i $ and $ j $ , price of passing it equals $ c_{i}·c_{j} $ .

Mishka started to gather her things for a trip, but didn't still decide which route to follow and thus she asked you to help her determine summary price of passing each of the roads in XXX. Formally, for every pair of cities $ a $ and $ b $ ( $ a&lt;b $ ), such that there is a road between $ a $ and $ b $ you are to find sum of products $ c_{a}·c_{b} $ . Will you help her?

## 输入格式

The first line of the input contains two integers $ n $ and $ k $ ( $ 3<=n<=100000,1<=k<=n $ ) — the number of cities in XXX and the number of capital cities among them.

The second line of the input contains $ n $ integers $ c_{1},c_{2},...,c_{n} $ ( $ 1<=c_{i}<=10000 $ ) — beauty values of the cities.

The third line of the input contains $ k $ distinct integers $ id_{1},id_{2},...,id_{k} $ ( $ 1<=id_{i}<=n $ ) — indices of capital cities. Indices are given in ascending order.

## 输出格式

Print the only integer — summary price of passing each of the roads in XXX.

## 说明/提示

This image describes first sample case:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF703B/f56e7113e4ecabd1250712cc69d300125f300e0b.png)

It is easy to see that summary price is equal to $ 17 $ .

This image describes second sample case:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF703B/e184cc93e6f4812674986a147f81ce08dfb70d8b.png)

It is easy to see that summary price is equal to $ 71 $ .

## 样例 #1

### 输入

```
4 1
2 3 1 2
3

```

### 输出

```
17
```

## 样例 #2

### 输入

```
5 2
3 5 2 2 4
1 4

```

### 输出

```
71
```



---

---
title: "Spider Man"
layout: "post"
diff: 普及-
pid: CF705B
tag: []
---

# Spider Man

## 题目描述

彼得·帕克想和章鱼博士玩一个游戏。游戏是关于循环的。循环是一个顶点序列，第一个顶点与第二个顶点相连，第二个顶点与第三个顶点相连，依此类推，最后一个顶点与第一个顶点再次相连。循环可以由单个独立顶点组成。



最初有k个循环，第i个循环由精确的vi个顶点组成。玩家可以选择。彼得先走。在每一回合中，玩家必须在所有可用循环中选择一个具有至少2个顶点（例如x顶点）的循环，并将其替换为两个循环，其中$1<=p<x$由玩家选择。无法移动的玩家将失去游戏（以及他的生命！）.



彼得想在和章鱼博士玩之前先测试一些初始周期的配置。最初他有一套空的。在第i个测试中，他将一个带有ai顶点的循环添加到集合中（这实际上是一个多集，因为它可以包含两个或更多相同的循环）。每次测试后，彼得都想知道，如果玩家以当前的循环开始游戏，谁会赢？



彼得数学很好，但现在他请你帮忙。

## 输入格式

输入的第一行包含一个整数n（1<=n<=100000）表示彼得将要进行的测试数量。



第二行包含n个空格分隔的整数a1，a2，…，an

（1<=ai<=10^9），其中i-th代表在第i-th测试之前添加的循环中的顶点数。

## 输出格式

按顺序输出所有测试的结果。如果第一个移动的玩家获胜，请输出1，否则输出2。

## 说明/提示

在第一个样例中：



在彼得的第一个测试中，只有一个1顶点的循环。第一名选手不能移动而输。



在他的第二个测试中，有一个循环有1个顶点，还有一个循环有2个顶点。没有人能用1个顶点在循环中移动。第一个玩家可以用两个1顶点的循环来代替第二个循环，第二个玩家不能移动和丢失。



在他的第三个测试中，循环有1、2和3个顶点。像上次测试一样，没有人能在第一个循环中移动。第一个玩家可以用一个1号和一个2号的循环替换第三个循环。现在循环有1，1，2，2个顶点。第二个玩家唯一的动作是用2个1号的循环来代替2号的循环。循环为1，1，1，1，2。第一个玩家用1号的2个循环替换最后一个循环并获胜。



在第二个样例中：



拥有大小为1的循环就像没有它们一样（因为没有人可以移动它们）。



在彼得的第三个测试中：有一个5号的循环（其他的并不重要）。第一个玩家有两个选择：用1号和4号或2号和3号的循环替换它。



如果他用尺寸为1和4的循环替换它：只有第二个循环才重要。第二个玩家将用2个2号的循环来代替它。第一个玩家的唯一选择是用两个1号的循环替换其中一个。第二个玩家对另一个循环做同样的事情。第一名选手不能移动，所以输了。



如果他用2号和3号的循环替换它：第二个玩家将用1号和2号的循环替换3号的循环。现在只有一个以上顶点的循环是两个大小为2的循环。如前一种情况所示，2圈2秒大小的玩家获胜。



所以，不管怎样，第一个玩家输了。

## 样例 #1

### 输入

```
3
1 2 3

```

### 输出

```
2
1
1

```

## 样例 #2

### 输入

```
5
1 1 5 1 1

```

### 输出

```
2
2
2
2
2

```



---

---
title: "Beru-taxi"
layout: "post"
diff: 普及-
pid: CF706A
tag: []
---

# Beru-taxi

## 题目描述

**题意翻译**
Vasiliy在点（a，b），他周围有n辆出租车，坐标在点（x，y），速度是v，假设Vasiliy已经知道了他最早能坐上哪辆出租车，请你求出他最早能坐上出租车的时间（出租车将直线朝Vasiliy行驶）。

## 输入格式

第一行三个整数分别是Vasiliy的坐标a，b和出租车的数量n。
第二行到第n + 1行，每行有三个整数，分别是每辆出租车的坐标x，y和每辆出租车的速度v。

## 输出格式

第一行一个浮点数，是Vasiliy最早能坐上出租车的时间，保留20位小数。

## 样例 #1

### 输入

```
0 0
2
2 0 1
0 2 2

```

### 输出

```
1.00000000000000000000
```

## 样例 #2

### 输入

```
1 3
3
3 3 2
-2 3 6
-2 7 10

```

### 输出

```
0.50000000000000000000
```



---

---
title: "Interesting drink"
layout: "post"
diff: 普及-
pid: CF706B
tag: []
---

# Interesting drink

## 题目描述

Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink "Beecola", which can be bought in $ n $ different shops in the city. It's known that the price of one bottle in the shop $ i $ is equal to $ x_{i} $ coins.

Vasiliy plans to buy his favorite drink for $ q $ consecutive days. He knows, that on the $ i $ -th day he will be able to spent $ m_{i} $ coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of "Beecola".

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=100000 $ ) — the number of shops in the city that sell Vasiliy's favourite drink.

The second line contains $ n $ integers $ x_{i} $ ( $ 1<=x_{i}<=100000 $ ) — prices of the bottles of the drink in the $ i $ -th shop.

The third line contains a single integer $ q $ ( $ 1<=q<=100000 $ ) — the number of days Vasiliy plans to buy the drink.

Then follow $ q $ lines each containing one integer $ m_{i} $ ( $ 1<=m_{i}<=10^{9} $ ) — the number of coins Vasiliy can spent on the $ i $ -th day.

## 输出格式

Print $ q $ integers. The $ i $ -th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the $ i $ -th day.

## 说明/提示

On the first day, Vasiliy won't be able to buy a drink in any of the shops.

On the second day, Vasiliy can buy a drink in the shops $ 1 $ , $ 2 $ , $ 3 $ and $ 4 $ .

On the third day, Vasiliy can buy a drink only in the shop number $ 1 $ .

Finally, on the last day Vasiliy can buy a drink in any shop.

## 样例 #1

### 输入

```
5
3 10 8 6 11
4
1
10
3
11

```

### 输出

```
0
4
1
5

```



---

---
title: "Memory and Crow"
layout: "post"
diff: 普及-
pid: CF712A
tag: []
---

# Memory and Crow

## 题目描述

There are $ n $ integers $ b_{1},b_{2},...,b_{n} $ written in a row. For all $ i $ from $ 1 $ to $ n $ , values $ a_{i} $ are defined by the crows performing the following procedure:

- The crow sets $ a_{i} $ initially $ 0 $ .
- The crow then adds $ b_{i} $ to $ a_{i} $ , subtracts $ b_{i+1} $ , adds the $ b_{i+2} $ number, and so on until the $ n $ 'th number. Thus, $ a_{i}=b_{i}-b_{i+1}+b_{i+2}-b_{i+3}... $ .

Memory gives you the values $ a_{1},a_{2},...,a_{n} $ , and he now wants you to find the initial numbers $ b_{1},b_{2},...,b_{n} $ written in the row? Can you do it?

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 2<=n<=100000 $ ) — the number of integers written in the row.

The next line contains $ n $ , the $ i $ 'th of which is $ a_{i} $ ( $ -10^{9}<=a_{i}<=10^{9} $ ) — the value of the $ i $ 'th number.

## 输出格式

Print $ n $ integers corresponding to the sequence $ b_{1},b_{2},...,b_{n} $ . It's guaranteed that the answer is unique and fits in 32-bit integer type.

## 说明/提示

In the first sample test, the crows report the numbers $ 6 $ , $ -4 $ , $ 8 $ , $ -2 $ , and $ 3 $ when he starts at indices $ 1 $ , $ 2 $ , $ 3 $ , $ 4 $ and $ 5 $ respectively. It is easy to check that the sequence $ 2 $ $ 4 $ $ 6 $ $ 1 $ $ 3 $ satisfies the reports. For example, $ 6=2-4+6-1+3 $ , and $ -4=4-6+1-3 $ .

In the second sample test, the sequence $ 1 $ , $ -3 $ , $ 4 $ , $ 11 $ , $ 6 $ satisfies the reports. For example, $ 5=11-6 $ and $ 6=6 $ .

## 样例 #1

### 输入

```
5
6 -4 8 -2 3

```

### 输出

```
2 4 6 1 3 

```

## 样例 #2

### 输入

```
5
3 -2 -1 5 6

```

### 输出

```
1 -3 4 11 6 

```



---

---
title: "Meeting of Old Friends"
layout: "post"
diff: 普及-
pid: CF714A
tag: []
---

# Meeting of Old Friends

## 题目描述

今天森林里将要发生一件大事——刺猬 Filya 要去看望他的老朋友 Sonya！  
Sonya 身为一只傲娇的猫头鹰，当然要在白天睡觉。不过，她会在 $[l_1,r_1]$ 分钟内会保持清醒。作为一只美美的猫头鹰，在第 $k$ 分钟，Sonya 会补妆，这时她和 Filya 不能在一起。  
Filya 有很多工作要做，他预计在 $[l_2,r_2]$ 分钟去探望 Sonya。  
请你计算两人可以相处多长时间。

## 输入格式

一行，五个整数 $l_1,r_1,l_2,r_2$ 和 $k(1 \le l_1,r_1,l_2,r_2,k \le 10^{18},l_1 \le r_1,l_2 < r_2)$。

## 输出格式

一个整数，表示 Sonya 和 Filya 的相处时间。

## 说明/提示

### 【样例一解释】
在第 $[9,10]$ 分钟相处。
### 【样例二解释】
在第 $[50,74]$ 分钟和第 $[76,100]$ 分钟在一起，第 $75$ 分钟时 Sonya 当然是去补妆辣！

Translated by @Ehrgeiz  @I_love_him52

## 样例 #1

### 输入

```
1 10 9 20 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
1 100 50 200 75

```

### 输出

```
50

```



---

---
title: "Filya and Homework"
layout: "post"
diff: 普及-
pid: CF714B
tag: []
---

# Filya and Homework

## 题目描述

刺猬 Filya 今天第一次去学校，由于老师给他的作业太难所有他需要你的帮助来完成：

老师给 Filya 一个仅包含正整数的数组 $a_1, a_2, \cdots,a_n $ 首先，他选择一个整数 $x$ ，然后他将 $x$ 加到数组的某些元素上（仅有一次），再从其他一些元素中减去 $x$，（每个元素仅减一次）并留一些元素不进行操作。经过这些操作以后，他希望数组内所有的元素均相等。现在，他想知道他可不可以找到这样一个 $x$ 并进行上述操作，使数组内的每一个元素相等。

## 输入格式

第一行包含一个整数$n$（$1\le n\le10^5$）表示数组内的元素个数。

第二行包含 $n$ 个整数 $a_1, a_2, …… a_n$（$0\le a_i\le 10^9$）即为数组内的元素。

## 输出格式

输出仅为一行如果数组内的元素在经过题目内所述操作后不能全部相等，则输出 `NO` ； 否则，输出 `YES` 。

## 说明/提示

在第一个样例中，应该选择第一个元素作为 $x$，添加到第一个和第五个，然后从第二个和第三个减去。

## 样例 #1

### 输入

```
5
1 3 3 2 1

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
5
1 2 3 4 5

```

### 输出

```
NO

```



---

---
title: "Crazy Computer"
layout: "post"
diff: 普及-
pid: CF716A
tag: []
---

# Crazy Computer

## 题目描述

ZS the Coder is coding on a crazy computer. If you don't type in a word for a $ c $ consecutive seconds, everything you typed disappear!

More formally, if you typed a word at second $ a $ and then the next word at second $ b $ , then if $ b-a<=c $ , just the new word is appended to other words on the screen. If $ b-a&gt;c $ , then everything on the screen disappears and after that the word you have typed appears on the screen.

For example, if $ c=5 $ and you typed words at seconds $ 1,3,8,14,19,20 $ then at the second $ 8 $ there will be $ 3 $ words on the screen. After that, everything disappears at the second $ 13 $ because nothing was typed. At the seconds $ 14 $ and $ 19 $ another two words are typed, and finally, at the second $ 20 $ , one more word is typed, and a total of $ 3 $ words remain on the screen.

You're given the times when ZS the Coder typed the words. Determine how many words remain on the screen after he finished typing everything.

## 输入格式

The first line contains two integers $ n $ and $ c $ ( $ 1<=n<=100000,1<=c<=10^{9} $ ) — the number of words ZS the Coder typed and the crazy computer delay respectively.

The next line contains $ n $ integers $ t_{1},t_{2},...,t_{n} $ ( $ 1<=t_{1}&lt;t_{2}&lt;...&lt;t_{n}<=10^{9} $ ), where $ t_{i} $ denotes the second when ZS the Coder typed the $ i $ -th word.

## 输出格式

Print a single positive integer, the number of words that remain on the screen after all $ n $ words was typed, in other words, at the second $ t_{n} $ .

## 说明/提示

The first sample is already explained in the problem statement.

For the second sample, after typing the first word at the second $ 1 $ , it disappears because the next word is typed at the second $ 3 $ and $ 3-1&gt;1 $ . Similarly, only $ 1 $ word will remain at the second $ 9 $ . Then, a word is typed at the second $ 10 $ , so there will be two words on the screen, as the old word won't disappear because $ 10-9<=1 $ .

## 样例 #1

### 输入

```
6 5
1 3 8 14 19 20

```

### 输出

```
3
```

## 样例 #2

### 输入

```
6 1
1 3 5 7 9 10

```

### 输出

```
2
```



---

---
title: "Vitya in the Countryside"
layout: "post"
diff: 普及-
pid: CF719A
tag: []
---

# Vitya in the Countryside

## 题目描述

Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.

Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is $ 0 $ , $ 1 $ , $ 2 $ , $ 3 $ , $ 4 $ , $ 5 $ , $ 6 $ , $ 7 $ , $ 8 $ , $ 9 $ , $ 10 $ , $ 11 $ , $ 12 $ , $ 13 $ , $ 14 $ , $ 15 $ , $ 14 $ , $ 13 $ , $ 12 $ , $ 11 $ , $ 10 $ , $ 9 $ , $ 8 $ , $ 7 $ , $ 6 $ , $ 5 $ , $ 4 $ , $ 3 $ , $ 2 $ , $ 1 $ , and then cycle repeats, thus after the second $ 1 $ again goes $ 0 $ .

As there is no internet in the countryside, Vitya has been watching the moon for $ n $ consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=92 $ ) — the number of consecutive days Vitya was watching the size of the visible part of the moon.

The second line contains $ n $ integers $ a_{i} $ ( $ 0<=a_{i}<=15 $ ) — Vitya's records.

It's guaranteed that the input data is consistent.

## 输出格式

If Vitya can be sure that the size of visible part of the moon on day $ n+1 $ will be less than the size of the visible part on day $ n $ , then print "DOWN" at the only line of the output. If he might be sure that the size of the visible part will increase, then print "UP". If it's impossible to determine what exactly will happen with the moon, print -1.

## 说明/提示

In the first sample, the size of the moon on the next day will be equal to $ 8 $ , thus the answer is "UP".

In the second sample, the size of the moon on the next day will be $ 11 $ , thus the answer is "DOWN".

In the third sample, there is no way to determine whether the size of the moon on the next day will be $ 7 $ or $ 9 $ , thus the answer is -1.

## 样例 #1

### 输入

```
5
3 4 5 6 7

```

### 输出

```
UP

```

## 样例 #2

### 输入

```
7
12 13 14 15 14 13 12

```

### 输出

```
DOWN

```

## 样例 #3

### 输入

```
1
8

```

### 输出

```
-1

```



---

---
title: "Anatoly and Cockroaches"
layout: "post"
diff: 普及-
pid: CF719B
tag: []
---

# Anatoly and Cockroaches

## 题目描述

Anatoly lives in the university dorm as many other students do. As you know, cockroaches are also living there together with students. Cockroaches might be of two colors: black and red. There are $ n $ cockroaches living in Anatoly's room.

Anatoly just made all his cockroaches to form a single line. As he is a perfectionist, he would like the colors of cockroaches in the line to alternate. He has a can of black paint and a can of red paint. In one turn he can either swap any two cockroaches, or take any single cockroach and change it's color.

Help Anatoly find out the minimum number of turns he needs to make the colors of cockroaches in the line alternate.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=100000 $ ) — the number of cockroaches.

The second line contains a string of length $ n $ , consisting of characters 'b' and 'r' that denote black cockroach and red cockroach respectively.

## 输出格式

Print one integer — the minimum number of moves Anatoly has to perform in order to make the colors of cockroaches in the line to alternate.

## 说明/提示

In the first sample, Anatoly has to swap third and fourth cockroaches. He needs $ 1 $ turn to do this.

In the second sample, the optimum answer is to paint the second and the fourth cockroaches red. This requires $ 2 $ turns.

In the third sample, the colors of cockroaches in the line are alternating already, thus the answer is $ 0 $ .

## 样例 #1

### 输入

```
5
rbbrr

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
bbbbb

```

### 输出

```
2

```

## 样例 #3

### 输入

```
3
rbr

```

### 输出

```
0

```



---

---
title: "Passwords"
layout: "post"
diff: 普及-
pid: CF721B
tag: []
---

# Passwords

## 题目描述

## 题目大意
Vanya想去他最喜欢的名为Codehorses的网站，他平时用n个密码作为他所有网站的密码。但是这天，Vanya突然忘了他的密码。
Vanya试的所有密码中，不存在某一次长度小于上一次的长度，他每次会随机试同一长度的密码（当这种长度试完后，会试下一长度的密码）。当他试对时，会瞬间批准进入网站。
他每次输入密码需要1秒，每连续k次输错后，需要等5秒再试下一次。他输密码的过程中不会休息停顿。
准确算出他进入网站最好情况和最差情况所需要的秒数。

## 输入格式

第一行：输入整数n，k (1<=n,k<=100)
接下来n行：输入密码，不超过100个字符，可以是拉丁字母也可以是数字。
最后一行：正确的密码，必须和上面n个密码中的一个相同。

## 输出格式

两个整数，分别是最好情况所需的时间和最坏情况所需的时间。

## 样例 #1

### 输入

```
5 2
cba
abc
bb1
abC
ABC
abc

```

### 输出

```
1 15

```

## 样例 #2

### 输入

```
4 100
11
22
1
2
22

```

### 输出

```
3 4

```



---

---
title: "Text Document Analysis"
layout: "post"
diff: 普及-
pid: CF723B
tag: []
---

# Text Document Analysis

## 题目描述

Modern text editors usually show some information regarding the document being edited. For example, the number of words, the number of pages, or the number of characters.

In this problem you should implement the similar functionality.

You are given a string which only consists of:

- uppercase and lowercase English letters,
- underscore symbols (they are used as separators),
- parentheses (both opening and closing).

It is guaranteed that each opening parenthesis has a succeeding closing parenthesis. Similarly, each closing parentheses has a preceding opening parentheses matching it. For each pair of matching parentheses there are no other parenthesis between them. In other words, each parenthesis in the string belongs to a matching "opening-closing" pair, and such pairs can't be nested.

For example, the following string is valid: "\_Hello\_Vasya(and\_Petya)\_\_bye\_(and\_OK)".

Word is a maximal sequence of consecutive letters, i.e. such sequence that the first character to the left and the first character to the right of it is an underscore, a parenthesis, or it just does not exist. For example, the string above consists of seven words: "Hello", "Vasya", "and", "Petya", "bye", "and" and "OK". Write a program that finds:

- the length of the longest word outside the parentheses (print 0, if there is no word outside the parentheses),
- the number of words inside the parentheses (print 0, if there is no word inside the parentheses).

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=255 $ ) — the length of the given string. The second line contains the string consisting of only lowercase and uppercase English letters, parentheses and underscore symbols.

## 输出格式

Print two space-separated integers:

- the length of the longest word outside the parentheses (print 0, if there is no word outside the parentheses),
- the number of words inside the parentheses (print 0, if there is no word inside the parentheses).

## 说明/提示

In the first sample, the words "Hello", "Vasya" and "bye" are outside any of the parentheses, and the words "and", "Petya", "and" and "OK" are inside. Note, that the word "and" is given twice and you should count it twice in the answer.

## 样例 #1

### 输入

```
37
_Hello_Vasya(and_Petya)__bye_(and_OK)

```

### 输出

```
5 4
```

## 样例 #2

### 输入

```
37
_a_(_b___c)__de_f(g_)__h__i(j_k_l)m__

```

### 输出

```
2 6
```

## 样例 #3

### 输入

```
27
(LoooonG)__shOrt__(LoooonG)

```

### 输出

```
5 2
```

## 样例 #4

### 输入

```
5
(___)

```

### 输出

```
0 0

```



---

---
title: "Food on the Plane"
layout: "post"
diff: 普及-
pid: CF725B
tag: []
---

# Food on the Plane

## 题目描述

一架新的喷气式飞机有无限行，从驾驶舱到机尾从1开始用正整数编号。每排有六个座位，用字母“a”到“f”表示。座位'a'、'b'、'c'位于过道的左侧（如果有人朝驾驶舱方向看），而座位'd'、'e'、'f'位于右侧。座位'A'和'F'靠近窗户，座位'C'和'D'靠近过道。
    现在是午餐时间，两名乘务员刚开始供应食物。他们从第一排移到最后一排，由于他们中间有食物推车，他们总是保持两排的距离。因此，在开始时，第一个服务员服务第1行，而第二个乘务员服务第3行。当两行都完成服务后，它们向前移动一行(第一个乘务员服务第2行，第二个乘务员服务第4行)。然后他们向前移动三行，第一个乘务员服务第5行，第二个服务员服务第7行。然后他们再向前移动一行，以此类推。
    乘务员以同样的速度工作：服务一名乘客需要1秒钟，向前移动一排需要1秒钟。每位乘务员首先在过道右侧的座位上为乘客服务，然后在过道左侧的座位上为乘客服务（如果有人朝驾驶舱方向看的话）。此外，从窗口到过道，他们总是按顺序为乘客服务。因此，第一个在每排接收食物的乘客位于“F”座，最后一个在“C”座（假设所有座位都有人）。
    Vasya在N排S座，她想知道在她吃午饭前会等多少秒。

## 输入格式

两个数n，s用来表示Vasya座位，其中n是行数，s是该行的座位，表示为字母'a'到'f'。行数和座位之间没有用空格分隔。

## 输出格式

一个整数表示Vasya需要等待多少秒。

## 说明/提示

第一个样例中：第一个乘务员首先为Vasya服务，所以瓦西亚在1秒钟后吃午饭。
    第二个样例中：乘务员花费6s为第1行和第3行中的每个人服务，然后他们将在1s内向前移动一行。当他们第一次提供位于过道右侧的座位时，Vasya必须再等3s。总共6+1+3=10s。

## 样例 #1

### 输入

```
1f

```

### 输出

```
1

```

## 样例 #2

### 输入

```
2d

```

### 输出

```
10

```

## 样例 #3

### 输入

```
4a

```

### 输出

```
11

```

## 样例 #4

### 输入

```
5e

```

### 输出

```
18

```



---

---
title: "Transformation: from A to B"
layout: "post"
diff: 普及-
pid: CF727A
tag: []
---

# Transformation: from A to B

## 题目描述

Vasily has a number $ a $ , which he wants to turn into a number $ b $ . For this purpose, he can do two types of operations:

- multiply the current number by $ 2 $ (that is, replace the number $ x $ by $ 2·x $ );
- append the digit $ 1 $ to the right of current number (that is, replace the number $ x $ by $ 10·x+1 $ ).

You need to help Vasily to transform the number $ a $ into the number $ b $ using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform $ a $ into $ b $ .

## 输入格式

The first line contains two positive integers $ a $ and $ b $ ( $ 1<=a&lt;b<=10^{9} $ ) — the number which Vasily has and the number he wants to have.

## 输出格式

If there is no way to get $ b $ from $ a $ , print "NO" (without quotes).

Otherwise print three lines. On the first line print "YES" (without quotes). The second line should contain single integer $ k $ — the length of the transformation sequence. On the third line print the sequence of transformations $ x_{1},x_{2},...,x_{k} $ , where:

- $ x_{1} $ should be equal to $ a $ ,
- $ x_{k} $ should be equal to $ b $ ,
- $ x_{i} $ should be obtained from $ x_{i-1} $ using any of two described operations ( $ 1&lt;i<=k $ ).

If there are multiple answers, print any of them.

## 样例 #1

### 输入

```
2 162

```

### 输出

```
YES
5
2 4 8 81 162 

```

## 样例 #2

### 输入

```
4 42

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
100 40021

```

### 输出

```
YES
5
100 200 2001 4002 40021 

```



---

---
title: "Night at the Museum"
layout: "post"
diff: 普及-
pid: CF731A
tag: []
---

# Night at the Museum

## 题目描述

Grigoriy像某一喜剧电影中的英雄一样（我也不知道哪一部）晚上在博物馆里当保安。第一天晚上他收到了一个标签打印机。他要去给展馆里的文物一个个贴标签了。

这个标签打印机可以打印一张塑料标签。它打印的标签上的字母一个连着一个。打印机上有一个小写英文字母环，一个指向选中字母的指针和一个选中字母的按钮。字母环一个字母为一个，你想怎么转就怎么转，顺逆皆可。下面那张图为指针和字母环排列顺序。指针开始指向“a”。

Grigoriy添加一样新展品时需要打印出它的名字贴在上面。打完一个字母后不需要返回到字母“a”。

我们的英雄现在有点慌了。他感觉有些展品活过来了而且要锤他，所以他想赶快把名字打完回家。帮他找到打印字符串时字母环最少转动多少格。

## 输入格式

一行一个不超过一百个字符的字符串，均为小写英文字母，无空格。

## 输出格式

一个正整数：字母环最小转动的各数

## 说明/提示

1.从‘a’到‘z’（逆时针1格）  
2.从‘z’到‘e’（顺时针5格）   
3.从‘e’到‘u’（逆时针10格）   
4.从‘u’到‘s’（逆时针2格）

## 样例 #1

### 输入

```
zeus

```

### 输出

```
18

```

## 样例 #2

### 输入

```
map

```

### 输出

```
35

```

## 样例 #3

### 输入

```
ares

```

### 输出

```
34

```



---

---
title: "Cormen — The Best Friend Of a Man"
layout: "post"
diff: 普及-
pid: CF732B
tag: []
---

# Cormen — The Best Friend Of a Man

## 题目描述

Recently a dog was bought for Polycarp. The dog's name is Cormen. Now Polycarp has a lot of troubles. For example, Cormen likes going for a walk.

Empirically Polycarp learned that the dog needs at least $ k $ walks for any two consecutive days in order to feel good. For example, if $ k=5 $ and yesterday Polycarp went for a walk with Cormen $ 2 $ times, today he has to go for a walk at least $ 3 $ times.

Polycarp analysed all his affairs over the next $ n $ days and made a sequence of $ n $ integers $ a_{1},a_{2},...,a_{n} $ , where $ a_{i} $ is the number of times Polycarp will walk with the dog on the $ i $ -th day while doing all his affairs (for example, he has to go to a shop, throw out the trash, etc.).

Help Polycarp determine the minimum number of walks he needs to do additionaly in the next $ n $ days so that Cormen will feel good during all the $ n $ days. You can assume that on the day before the first day and on the day after the $ n $ -th day Polycarp will go for a walk with Cormen exactly $ k $ times.

Write a program that will find the minumum number of additional walks and the appropriate schedule — the sequence of integers $ b_{1},b_{2},...,b_{n} $ ( $ b_{i}>=a_{i} $ ), where $ b_{i} $ means the total number of walks with the dog on the $ i $ -th day.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1<=n,k<=500 $ ) — the number of days and the minimum number of walks with Cormen for any two consecutive days.

The second line contains integers $ a_{1},a_{2},...,a_{n} $ ( $ 0<=a_{i}<=500 $ ) — the number of walks with Cormen on the $ i $ -th day which Polycarp has already planned.

## 输出格式

In the first line print the smallest number of additional walks that Polycarp should do during the next $ n $ days so that Cormen will feel good during all days.

In the second line print $ n $ integers $ b_{1},b_{2},...,b_{n} $ , where $ b_{i} $ — the total number of walks on the $ i $ -th day according to the found solutions ( $ a_{i}<=b_{i} $ for all $ i $ from 1 to $ n $ ). If there are multiple solutions, print any of them.

## 样例 #1

### 输入

```
3 5
2 0 1

```

### 输出

```
4
2 3 2

```

## 样例 #2

### 输入

```
3 1
0 0 0

```

### 输出

```
1
0 1 0

```

## 样例 #3

### 输入

```
4 6
2 4 3 5

```

### 输出

```
0
2 4 3 5

```



---

---
title: "Parade"
layout: "post"
diff: 普及-
pid: CF733B
tag: []
---

# Parade

## 题目描述

Very soon there will be a parade of victory over alien invaders in Berland. Unfortunately, all soldiers died in the war and now the army consists of entirely new recruits, many of whom do not even know from which leg they should begin to march. The civilian population also poorly understands from which leg recruits begin to march, so it is only important how many soldiers march in step.

There will be $ n $ columns participating in the parade, the $ i $ -th column consists of $ l_{i} $ soldiers, who start to march from left leg, and $ r_{i} $ soldiers, who start to march from right leg.

The beauty of the parade is calculated by the following formula: if $ L $ is the total number of soldiers on the parade who start to march from the left leg, and $ R $ is the total number of soldiers on the parade who start to march from the right leg, so the beauty will equal $ |L-R| $ .

No more than once you can choose one column and tell all the soldiers in this column to switch starting leg, i.e. everyone in this columns who starts the march from left leg will now start it from right leg, and vice versa. Formally, you can pick no more than one index $ i $ and swap values $ l_{i} $ and $ r_{i} $ .

Find the index of the column, such that switching the starting leg for soldiers in it will maximize the the beauty of the parade, or determine, that no such operation can increase the current beauty.

## 输入格式

The first line contains single integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of columns.

The next $ n $ lines contain the pairs of integers $ l_{i} $ and $ r_{i} $ ( $ 1<=l_{i},r_{i}<=500 $ ) — the number of soldiers in the $ i $ -th column which start to march from the left or the right leg respectively.

## 输出格式

Print single integer $ k $ — the number of the column in which soldiers need to change the leg from which they start to march, or $ 0 $ if the maximum beauty is already reached.

Consider that columns are numbered from 1 to $ n $ in the order they are given in the input data.

If there are several answers, print any of them.

## 说明/提示

In the first example if you don't give the order to change the leg, the number of soldiers, who start to march from the left leg, would equal $ 5+8+10=23 $ , and from the right leg — $ 6+9+3=18 $ . In this case the beauty of the parade will equal $ |23-18|=5 $ .

If you give the order to change the leg to the third column, so the number of soldiers, who march from the left leg, will equal $ 5+8+3=16 $ , and who march from the right leg — $ 6+9+10=25 $ . In this case the beauty equals $ |16-25|=9 $ .

It is impossible to reach greater beauty by giving another orders. Thus, the maximum beauty that can be achieved is 9.

## 样例 #1

### 输入

```
3
5 6
8 9
10 3

```

### 输出

```
3

```

## 样例 #2

### 输入

```
2
6 5
5 6

```

### 输出

```
1

```

## 样例 #3

### 输入

```
6
5 9
1 3
4 8
4 5
23 54
12 32

```

### 输出

```
0

```



---

---
title: "Urbanization"
layout: "post"
diff: 普及-
pid: CF735B
tag: []
---

# Urbanization

## 题目描述

## 题目大意

$n$个人要住进两个城市里，两个城市分别能住$n1$,$n2$个人。

$n$个人中，每个人都有一个财富值——第$i$个人的是$ai$。

现在请你安排这些人的入住，使得两个城市的每位居民的财富值**平均值的和**最大。（分别计算两个城市的财富值平均值，再相加）

当然，每一个人只能至多住进一个城市。

注意，并不是每一位居民都必须被安排住进两个城市中，没有被安排的居民直接回家。

## 输入格式

第一行包含3个整数——$n,n1,n2$，分别表示总人数、第一个城市居民数，第二个城市居民数。

第二行包含$n$个整数，第$i$个表示第$i$位居民的财富值$ai$。

## 输出格式

仅一个实数，表示最大的两个城市的每位居民的财富值**平均值的和**。保留$8$位小数。

## 说明/提示

$ 1≤n,n1,n2≤100000 $

$ n1+n2≤n $

$ 1≤ai≤100000 $


第一个样例中，可以让第一个居民住进第一个城市、让第二个居民住进第二个城市。

第二个样例中，让三号、四号居民住进第一个城市，让二号居民住进第二个城市。这样平均值的和最大，等于
$ (2+3)÷2+4÷1=6.5 $。

## 样例 #1

### 输入

```
2 1 1
1 5

```

### 输出

```
6.00000000

```

## 样例 #2

### 输入

```
4 2 1
1 4 2 3

```

### 输出

```
6.50000000

```



---

---
title: "Alyona and copybooks"
layout: "post"
diff: 普及-
pid: CF740A
tag: []
---

# Alyona and copybooks

## 题目描述

Alyona 在学校学习 4 门课程，她要去书店买笔记本。她想让 4 门课程的笔记本数量相同。

Alyona 一开始时有 $n$ 个笔记本。书店有 $3$ 种笔记本购买方式：

 1. 买一个笔记本，花费 $a$ 卢布；
 2. 买两个笔记本，花费 $b$ 卢布；
 3. 买三个笔记本，花费 $c$ 卢布。
 
Alyona 可以购买任意次笔记本。问最少要花多少卢布？

## 输入格式

一行，$n$，$a$，$b$，$c$（$1\le n,a,b,c\le 10^9$）。

## 输出格式

输出 Alyona 最少需要花多少卢布以保证符合要求。

## 样例 #1

### 输入

```
1 1 3 4

```

### 输出

```
3

```

## 样例 #2

### 输入

```
6 2 1 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
4 4 4 4

```

### 输出

```
0

```

## 样例 #4

### 输入

```
999999999 1000000000 1000000000 1000000000

```

### 输出

```
1000000000

```



---

---
title: "Alyona and flowers"
layout: "post"
diff: 普及-
pid: CF740B
tag: []
---

# Alyona and flowers

## 题目描述

Little Alyona is celebrating Happy Birthday! Her mother has an array of $ n $ flowers. Each flower has some mood, the mood of $ i $ -th flower is $ a_{i} $ . The mood can be positive, zero or negative.

Let's define a subarray as a segment of consecutive flowers. The mother suggested some set of subarrays. Alyona wants to choose several of the subarrays suggested by her mother. After that, each of the flowers will add to the girl's happiness its mood multiplied by the number of chosen subarrays the flower is in.

For example, consider the case when the mother has $ 5 $ flowers, and their moods are equal to $ 1,-2,1,3,-4 $ . Suppose the mother suggested subarrays $ (1,-2) $ , $ (3,-4) $ , $ (1,3) $ , $ (1,-2,1,3) $ . Then if the girl chooses the third and the fourth subarrays then:

- the first flower adds $ 1·1=1 $ to the girl's happiness, because he is in one of chosen subarrays,
- the second flower adds $ (-2)·1=-2 $ , because he is in one of chosen subarrays,
- the third flower adds $ 1·2=2 $ , because he is in two of chosen subarrays,
- the fourth flower adds $ 3·2=6 $ , because he is in two of chosen subarrays,
- the fifth flower adds $ (-4)·0=0 $ , because he is in no chosen subarrays.

Thus, in total $ 1+(-2)+2+6+0=7 $ is added to the girl's happiness. Alyona wants to choose such subarrays from those suggested by the mother that the value added to her happiness would be as large as possible. Help her do this!

Alyona can choose any number of the subarrays, even $ 0 $ or all suggested by her mother.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1<=n,m<=100 $ ) — the number of flowers and the number of subarrays suggested by the mother.

The second line contains the flowers moods — $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ -100<=a_{i}<=100 $ ).

The next $ m $ lines contain the description of the subarrays suggested by the mother. The $ i $ -th of these lines contain two integers $ l_{i} $ and $ r_{i} $ ( $ 1<=l_{i}<=r_{i}<=n $ ) denoting the subarray $ a[l_{i}],a[l_{i}+1],...,a[r_{i}] $ .

Each subarray can encounter more than once.

## 输出格式

Print single integer — the maximum possible value added to the Alyona's happiness.

## 说明/提示

The first example is the situation described in the statements.

In the second example Alyona should choose all subarrays.

The third example has answer $ 0 $ because Alyona can choose none of the subarrays.

## 样例 #1

### 输入

```
5 4
1 -2 1 3 -4
1 2
4 5
3 4
1 4

```

### 输出

```
7

```

## 样例 #2

### 输入

```
4 3
1 2 3 4
1 3
2 4
1 1

```

### 输出

```
16

```

## 样例 #3

### 输入

```
2 2
-1 -2
1 1
1 2

```

### 输出

```
0

```



---

---
title: "Chloe and the sequence"
layout: "post"
diff: 普及-
pid: CF743B
tag: []
---

# Chloe and the sequence

## 题目描述

Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to $ 1 $ . Then we perform $ (n-1) $ steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence $ [1,2,1] $ after the first step, the sequence $ [1,2,1,3,1,2,1] $ after the second step.

The task is to find the value of the element with index $ k $ (the elements are numbered from $ 1 $ ) in the obtained sequence, i. e. after $ (n-1) $ steps.

Please help Chloe to solve the problem!

## 输入格式

The only line contains two integers $ n $ and $ k $ ( $ 1<=n<=50 $ , $ 1<=k<=2^{n}-1 $ ).

## 输出格式

Print single integer — the integer at the $ k $ -th position in the obtained sequence.

## 说明/提示

In the first sample the obtained sequence is $ [1,2,1,3,1,2,1] $ . The number on the second position is $ 2 $ .

In the second sample the obtained sequence is $ [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1] $ . The number on the eighth position is $ 4 $ .

## 样例 #1

### 输入

```
3 2

```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 8

```

### 输出

```
4
```



---

---
title: "Hongcow Learns the Cyclic Shift"
layout: "post"
diff: 普及-
pid: CF745A
tag: []
---

# Hongcow Learns the Cyclic Shift

## 题目描述

Hongcow正在学习拼写单词！这天，他（他？）的老师给了他一个需要拼写的单词。作为一个好学生，他很快就学会了如何拼写。  
Hongcow决定搞个大新闻。他从刚学会拼写的单词开始，每次把最后一个字符移到单词开头。他称此为一次变换。他可以进行多次变换，例如：单词"abracadabra"可以变成"aabracadabr"、"raabracadab"等等  
现在，他想知道通过变换能变成几个不同的单词，包括初始单词

## 输入格式

一行一个字符串$s(1\leq|s|\leq 50)$，表示初始单词，只由$a-z$组成

## 输出格式

一行表示不同单词个数
感谢 @Fheiwn  提供的翻译。

## 样例 #1

### 输入

```
abcd

```

### 输出

```
4

```

## 样例 #2

### 输入

```
bbb

```

### 输出

```
1

```

## 样例 #3

### 输入

```
yzyz

```

### 输出

```
2

```



---

---
title: "Hongcow Solves A Puzzle"
layout: "post"
diff: 普及-
pid: CF745B
tag: []
---

# Hongcow Solves A Puzzle

## 题目描述

Hongcow likes solving puzzles.

One day, Hongcow finds two identical puzzle pieces, with the instructions "make a rectangle" next to them. The pieces can be described by an $ n $ by $ m $ grid of characters, where the character 'X' denotes a part of the puzzle and '.' denotes an empty part of the grid. It is guaranteed that the puzzle pieces are one 4-connected piece. See the input format and samples for the exact details on how a jigsaw piece will be specified.

The puzzle pieces are very heavy, so Hongcow cannot rotate or flip the puzzle pieces. However, he is allowed to move them in any directions. The puzzle pieces also cannot overlap.

You are given as input the description of one of the pieces. Determine if it is possible to make a rectangle from two identical copies of the given input. The rectangle should be solid, i.e. there should be no empty holes inside it or on its border. Keep in mind that Hongcow is not allowed to flip or rotate pieces and they cannot overlap, i.e. no two 'X' from different pieces can share the same position.

## 输入格式

The first line of input will contain two integers $ n $ and $ m $ ( $ 1<=n,m<=500 $ ), the dimensions of the puzzle piece.

The next $ n $ lines will describe the jigsaw piece. Each line will have length $ m $ and will consist of characters '.' and 'X' only. 'X' corresponds to a part of the puzzle piece, '.' is an empty space.

It is guaranteed there is at least one 'X' character in the input and that the 'X' characters form a 4-connected region.

## 输出格式

Output "YES" if it is possible for Hongcow to make a rectangle. Output "NO" otherwise.

## 说明/提示

For the first sample, one example of a rectangle we can form is as follows

`<br></br>111222<br></br>111222<br></br>`For the second sample, it is impossible to put two of those pieces without rotating or flipping to form a rectangle.

In the third sample, we can shift the first tile by one to the right, and then compose the following rectangle:

`<br></br>.....<br></br>..XX.<br></br>.....<br></br>.....<br></br>.....<br></br>`

## 样例 #1

### 输入

```
2 3
XXX
XXX

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
2 2
.X
XX

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
5 5
.....
..X..
.....
.....
.....

```

### 输出

```
YES

```



---

---
title: "Decoding"
layout: "post"
diff: 普及-
pid: CF746B
tag: []
---

# Decoding

## 题目描述

## **题目大意**

Polycarp很想编码，这就是他编写Sveta编码信息的原因。他把中间字母称为单词中间的字母。如果单词的长度是偶数，则中间字母是两个中间字母的左边。在以下示例中，中间字母突出显示：con**t** est，i**n**fo。如果单词由单个字母组成，则根据上面的定义，这个字母是中间字母。



Polycarp以下列方式对每个单词进行编码：他写下单词的中间字母，然后将其删除并重复该过程，直到没有字母为止。例如，他将volga编码为logva。



你得到一个编码，你的任务是进行译码。

## 输入格式

第一行包含正整数（1<=n<=2000）n代表编码字的长度。



第二行包含一个只由小写英文字母组成的字符串编码。

## 输出格式

输出Polycarp进行编码的原单词输出Polycarp进行编码的原单词。

## 样例 #1

### 输入

```
5
logva

```

### 输出

```
volga

```

## 样例 #2

### 输入

```
2
no

```

### 输出

```
no

```

## 样例 #3

### 输入

```
4
abba

```

### 输出

```
baba

```



---

---
title: "Green and Black Tea"
layout: "post"
diff: 普及-
pid: CF746D
tag: []
---

# Green and Black Tea

## 题目描述

Innokentiy likes tea very much and today he wants to drink exactly $ n $ cups of tea. He would be happy to drink more but he had exactly $ n $ tea bags, $ a $ of them are green and $ b $ are black.

Innokentiy doesn't like to drink the same tea (green or black) more than $ k $ times in a row. Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink $ n $ cups of tea, without drinking the same tea more than $ k $ times in a row, or to inform that it is impossible. Each tea bag has to be used exactly once.

## 输入格式

The first line contains four integers $ n $ , $ k $ , $ a $ and $ b $ ( $ 1<=k<=n<=10^{5} $ , $ 0<=a,b<=n $ ) — the number of cups of tea Innokentiy wants to drink, the maximum number of cups of same tea he can drink in a row, the number of tea bags of green and black tea. It is guaranteed that $ a+b=n $ .

## 输出格式

If it is impossible to drink $ n $ cups of tea, print "NO" (without quotes).

Otherwise, print the string of the length $ n $ , which consists of characters 'G' and 'B'. If some character equals 'G', then the corresponding cup of tea should be green. If some character equals 'B', then the corresponding cup of tea should be black.

If there are multiple answers, print any of them.

## 样例 #1

### 输入

```
5 1 3 2

```

### 输出

```
GBGBG

```

## 样例 #2

### 输入

```
7 2 2 5

```

### 输出

```
BBGBGBB
```

## 样例 #3

### 输入

```
4 3 4 0

```

### 输出

```
NO

```



---

---
title: "Servers"
layout: "post"
diff: 普及-
pid: CF747C
tag: []
---

# Servers

## 题目描述

There are $ n $ servers in a laboratory, each of them can perform tasks. Each server has a unique id — integer from $ 1 $ to $ n $ .

It is known that during the day $ q $ tasks will come, the $ i $ -th of them is characterized with three integers: $ t_{i} $ — the moment in seconds in which the task will come, $ k_{i} $ — the number of servers needed to perform it, and $ d_{i} $ — the time needed to perform this task in seconds. All $ t_{i} $ are distinct.

To perform the $ i $ -th task you need $ k_{i} $ servers which are unoccupied in the second $ t_{i} $ . After the servers begin to perform the task, each of them will be busy over the next $ d_{i} $ seconds. Thus, they will be busy in seconds $ t_{i},t_{i}+1,...,t_{i}+d_{i}-1 $ . For performing the task, $ k_{i} $ servers with the smallest ids will be chosen from all the unoccupied servers. If in the second $ t_{i} $ there are not enough unoccupied servers, the task is ignored.

Write the program that determines which tasks will be performed and which will be ignored.

## 输入格式

The first line contains two positive integers $ n $ and $ q $ ( $ 1<=n<=100 $ , $ 1<=q<=10^{5} $ ) — the number of servers and the number of tasks.

Next $ q $ lines contains three integers each, the $ i $ -th line contains integers $ t_{i} $ , $ k_{i} $ and $ d_{i} $ ( $ 1<=t_{i}<=10^{6} $ , $ 1<=k_{i}<=n $ , $ 1<=d_{i}<=1000 $ ) — the moment in seconds in which the $ i $ -th task will come, the number of servers needed to perform it, and the time needed to perform this task in seconds. The tasks are given in a chronological order and they will come in distinct seconds.

## 输出格式

Print $ q $ lines. If the $ i $ -th task will be performed by the servers, print in the $ i $ -th line the sum of servers' ids on which this task will be performed. Otherwise, print -1.

## 说明/提示

In the first example in the second $ 1 $ the first task will come, it will be performed on the servers with ids $ 1 $ , $ 2 $ and $ 3 $ (the sum of the ids equals $ 6 $ ) during two seconds. In the second $ 2 $ the second task will come, it will be ignored, because only the server $ 4 $ will be unoccupied at that second. In the second $ 3 $ the third task will come. By this time, servers with the ids $ 1 $ , $ 2 $ and $ 3 $ will be unoccupied again, so the third task will be done on all the servers with the ids $ 1 $ , $ 2 $ , $ 3 $ and $ 4 $ (the sum of the ids is $ 10 $ ).

In the second example in the second $ 3 $ the first task will come, it will be performed on the servers with ids $ 1 $ and $ 2 $ (the sum of the ids is $ 3 $ ) during three seconds. In the second $ 5 $ the second task will come, it will be performed on the server $ 3 $ , because the first two servers will be busy performing the first task.

## 样例 #1

### 输入

```
4 3
1 3 2
2 2 1
3 4 3

```

### 输出

```
6
-1
10

```

## 样例 #2

### 输入

```
3 2
3 2 3
5 1 2

```

### 输出

```
3
3

```

## 样例 #3

### 输入

```
8 6
1 3 20
4 2 1
6 5 5
10 1 1
15 3 6
21 8 8

```

### 输出

```
6
9
30
-1
15
36

```



---

---
title: "Santa Claus and a Place in a Class"
layout: "post"
diff: 普及-
pid: CF748A
tag: []
---

# Santa Claus and a Place in a Class

## 题目描述

Santa Claus is the first who came to the Christmas Olympiad, and he is going to be the first to take his place at a desk! In the classroom there are $ n $ lanes of $ m $ desks each, and there are two working places at each of the desks. The lanes are numbered from $ 1 $ to $ n $ from the left to the right, the desks in a lane are numbered from $ 1 $ to $ m $ starting from the blackboard. Note that the lanes go perpendicularly to the blackboard, not along it (see picture).

The organizers numbered all the working places from $ 1 $ to $ 2nm $ . The places are numbered by lanes (i. e. all the places of the first lane go first, then all the places of the second lane, and so on), in a lane the places are numbered starting from the nearest to the blackboard (i. e. from the first desk in the lane), at each desk, the place on the left is numbered before the place on the right.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF748A/bbf8fc48769a6dddf0555cdcd0723e32248a57bd.png)The picture illustrates the first and the second samples.Santa Clause knows that his place has number $ k $ . Help him to determine at which lane at which desk he should sit, and whether his place is on the left or on the right!

## 输入格式

The only line contains three integers $ n $ , $ m $ and $ k $ ( $ 1<=n,m<=10000 $ , $ 1<=k<=2nm $ ) — the number of lanes, the number of desks in each lane and the number of Santa Claus' place.

## 输出格式

Print two integers: the number of lane $ r $ , the number of desk $ d $ , and a character $ s $ , which stands for the side of the desk Santa Claus. The character $ s $ should be "L", if Santa Clause should sit on the left, and "R" if his place is on the right.

## 说明/提示

The first and the second samples are shown on the picture. The green place corresponds to Santa Claus' place in the first example, the blue place corresponds to Santa Claus' place in the second example.

In the third sample there are two lanes with four desks in each, and Santa Claus has the fourth place. Thus, his place is in the first lane at the second desk on the right.

## 样例 #1

### 输入

```
4 3 9

```

### 输出

```
2 2 L

```

## 样例 #2

### 输入

```
4 3 24

```

### 输出

```
4 3 R

```

## 样例 #3

### 输入

```
2 4 4

```

### 输出

```
1 2 R

```



---

---
title: "Santa Claus and Keyboard Check"
layout: "post"
diff: 普及-
pid: CF748B
tag: []
---

# Santa Claus and Keyboard Check

## 题目描述

# 题义翻译
圣诞老人拆开、清洁了他的键盘，但是在将所有的按键安好后，他发现一些按键的位置发生
了两两交换！于是，圣诞老人猜测对于键盘上的每一个按键，要么在它本来正确的位置，
要么与另一个按键交换了位置。  为了验证他的猜想，他决定只根据正确的按键位置打出他
最爱的文字。现给出圣诞老人要打出的字符串 *s*，和他实际敲出的字符串 *t*,请你确定
哪几组字母发生了两两交换（即每对交换位置的字母不应出现在其他字母对中）

## 输入格式

非空、等长，且长度最大为1000 的字符串 *s*、*t*，所有字母均为小写字母

## 输出格式

如果圣诞老人的猜想是错的，那么无法将位置交换的按键分为两两一组，此时输出“-1”（不含引号）\
否则输出第一行只包含一个非负整数*k*（可以为0）：交换位置的字母对数；下面的*k*行分别输出每对交换位置的字母，用空格隔开；所有字母至多出现一次。\
如果存在多种答案，输出任意一种；输出字母对的顺序以及每个字母对中两个字母的顺序任意。

## 样例 #1

### 输入

```
helloworld
ehoolwlroz

```

### 输出

```
3
h e
l o
d z

```

## 样例 #2

### 输入

```
hastalavistababy
hastalavistababy

```

### 输出

```
0

```

## 样例 #3

### 输入

```
merrychristmas
christmasmerry

```

### 输出

```
-1

```



---

---
title: "Bachgold Problem"
layout: "post"
diff: 普及-
pid: CF749A
tag: []
---

# Bachgold Problem

## 题目描述

Bachgold problem is very easy to formulate. Given a positive integer $ n $ represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than $ 1 $ .

Recall that integer $ k $ is called prime if it is greater than $ 1 $ and has exactly two positive integer divisors — $ 1 $ and $ k $ .

## 输入格式

The only line of the input contains a single integer $ n $ ( $ 2<=n<=100000 $ ).

## 输出格式

The first line of the output contains a single integer $ k $ — maximum possible number of primes in representation.

The second line should contain $ k $ primes with their sum equal to $ n $ . You can print them in any order. If there are several optimal solution, print any of them.

## 样例 #1

### 输入

```
5

```

### 输出

```
2
2 3

```

## 样例 #2

### 输入

```
6

```

### 输出

```
3
2 2 2

```



---

---
title: "Parallelogram is Back"
layout: "post"
diff: 普及-
pid: CF749B
tag: []
---

# Parallelogram is Back

## 题目描述

Long time ago Alex created an interesting problem about parallelogram. The input data for this problem contained four integer points on the Cartesian plane, that defined the set of vertices of some non-degenerate (positive area) parallelogram. Points not necessary were given in the order of clockwise or counterclockwise traversal.

Alex had very nice test for this problem, but is somehow happened that the last line of the input was lost and now he has only three out of four points of the original parallelogram. He remembers that test was so good that he asks you to restore it given only these three points.

## 输入格式

The input consists of three lines, each containing a pair of integer coordinates $ x_{i} $ and $ y_{i} $ ( $ -1000<=x_{i},y_{i}<=1000 $ ). It's guaranteed that these three points do not lie on the same line and no two of them coincide.

## 输出格式

First print integer $ k $ — the number of ways to add one new integer point such that the obtained set defines some parallelogram of positive area. There is no requirement for the points to be arranged in any special order (like traversal), they just define the set of vertices.

Then print $ k $ lines, each containing a pair of integer — possible coordinates of the fourth point.

## 说明/提示

If you need clarification of what parallelogram is, please check Wikipedia page:

https://en.wikipedia.org/wiki/Parallelogram

## 样例 #1

### 输入

```
0 0
1 0
0 1

```

### 输出

```
3
1 -1
-1 1
1 1

```



---

---
title: "Room Leader"
layout: "post"
diff: 普及-
pid: CF74A
tag: []
---

# Room Leader

## 题目描述

比赛开始时，参赛者被分进几个不同的房间。每个房间恰好包含 $n$ 位参赛者。在比赛中，参与者被要求解决五个问题， $A$ 、 $B$ 、 $C$ 、 $D$ 和 $E$ 。

对于每个问题，参赛者会根据解决给定问题的时长以及是否彻底解决获得一些积分。此外，参赛者可以对其他参赛者进行攻击。每成功攻击一次，即可赢得 $100$ 分；攻击不成功一次，则会损失 $50$ 分。每个参赛者的得分由他从所有问题及攻击中获得的得分总和表示。

请确定给定的一个房间内得分最高的参与者。

## 输入格式

第一行包含一个整数 $n$ ，它是房间中参赛者的人数（ $1 \leqslant n \leqslant 50$ ）。

接下来的 $n$ 行包含给定房间的参与者信息。第 $i+1$ 行包含 $1$ 个字符串 $handle_i$ 及 $7$ 个整数$plus_i,minus_i,a_i,b_i,c_i,d_i,e_i$，分别表示参赛者的名称，成功的攻击次数，失败的攻击次数以及他从问题 $A$ 、 $B$ 、 $C$ 、 $D$ 、 $E$ 获得的分数。每个参与者的名称由拉丁字母、数字和下划线组成，长度不少于 $1$ 个字符且不超过 $20$ 个字符。

## 输出格式

输出共一行，房间内得分最高的参与者的名称。

## 说明/提示

$0 \leqslant plus_i,minus_i \leqslant 50$ ；

 $150 \leqslant a_i \leqslant 500$ 或 $a_i=0$ （若问题 $A$ 没有解决）；

 $300 \leqslant b_i \leqslant 1000$ 或 $b_i=0$ （若问题 $B$ 没有解决）；

 $450 \leqslant c_i \leqslant 1500$ 或 $c_i=0$ （若问题 $C$ 没有解决）；

 $600 \leqslant d_i \leqslant 2000$ 或 $d_i=0$ （若问题 $D$ 没有解决）；

 $750 \leqslant e_i \leqslant 2500$ 或 $e_i=0$ （若问题 $E$ 没有解决）；

所有数字都是整数。所有参与者都有不同的名称。可以确保房间中不存在多个参与者分数均为最高。

## 样例 #1

### 输入

```
5
Petr 3 1 490 920 1000 1200 0
tourist 2 0 490 950 1100 1400 0
Egor 7 0 480 900 950 0 1000
c00lH4x0R 0 10 150 0 0 0 0
some_participant 2 1 450 720 900 0 0

```

### 输出

```
tourist
```



---

---
title: "New Year and North Pole"
layout: "post"
diff: 普及-
pid: CF750B
tag: []
---

# New Year and North Pole

## 题目描述

In this problem we assume the Earth to be a completely round ball and its surface a perfect sphere. The length of the equator and any meridian is considered to be exactly $ 40000 $ kilometers. Thus, travelling from North Pole to South Pole or vice versa takes exactly $ 20000 $ kilometers.

Limak, a polar bear, lives on the North Pole. Close to the New Year, he helps somebody with delivering packages all around the world. Instead of coordinates of places to visit, Limak got a description how he should move, assuming that he starts from the North Pole. The description consists of $ n $ parts. In the $ i $ -th part of his journey, Limak should move $ t_{i} $ kilometers in the direction represented by a string $ dir_{i} $ that is one of: "North", "South", "West", "East".

Limak isn’t sure whether the description is valid. You must help him to check the following conditions:

- If at any moment of time (before any of the instructions or while performing one of them) Limak is on the North Pole, he can move only to the South.
- If at any moment of time (before any of the instructions or while performing one of them) Limak is on the South Pole, he can move only to the North.
- The journey must end on the North Pole.

Check if the above conditions are satisfied and print "YES" or "NO" on a single line.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=50 $ ).

The $ i $ -th of next $ n $ lines contains an integer $ t_{i} $ and a string $ dir_{i} $ ( $ 1<=t_{i}<=10^{6} $ , ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF750B/bad8e6778e4440b96077dcc3eab91b8cb46271e1.png)) — the length and the direction of the $ i $ -th part of the journey, according to the description Limak got.

## 输出格式

Print "YES" if the description satisfies the three conditions, otherwise print "NO", both without the quotes.

## 说明/提示

Drawings below show how Limak's journey would look like in first two samples. In the second sample the answer is "NO" because he doesn't end on the North Pole.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF750B/9bb594fe352848bbba36035935a49c02ad65109a.png)

## 样例 #1

### 输入

```
5
7500 South
10000 East
3500 North
4444 West
4000 North

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
2
15000 South
4000 East

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
5
20000 South
1000 North
1000000 West
9000 North
10000 North

```

### 输出

```
YES

```

## 样例 #4

### 输入

```
3
20000 South
10 East
20000 North

```

### 输出

```
NO

```

## 样例 #5

### 输入

```
2
1000 North
1000 South

```

### 输出

```
NO

```

## 样例 #6

### 输入

```
4
50 South
50 North
15000 South
15000 North

```

### 输出

```
YES

```



---

---
title: "Santa Claus and Candies"
layout: "post"
diff: 普及-
pid: CF753A
tag: []
---

# Santa Claus and Candies

## 题目描述

圣诞老人有$n$ 个糖果，他想要把这些作为礼物送给孩子们。

如果圣诞老人想要每个孩子得到的糖果数都是不同的正整数，那他最多能将糖果分给多少个孩子。圣诞老人（Santa Class — 错误的原文）想把他有的$n$ 个糖果都送出去。

## 输入格式

仅输入一行一个正整数$n$ （$1\leq n\leq 1000$ ） — 圣诞老人有的糖果数。

## 输出格式

输出的第一行为一个整数$k$  — 能得到糖果的孩子的最大数目。

输出第二行为$k$ 个不同的整数：为这$k$ 个孩子各自得到的糖果数。输出的这$k$ 个数的和应为$n$ 。

如果有多种方案，输出其中的任意一种。

感谢@Khassar 提供的翻译

## 样例 #1

### 输入

```
5

```

### 输出

```
2
2 3

```

## 样例 #2

### 输入

```
9

```

### 输出

```
3
3 5 1

```

## 样例 #3

### 输入

```
2

```

### 输出

```
1
2 

```



---

---
title: "PolandBall and Hypothesis"
layout: "post"
diff: 普及-
pid: CF755A
tag: []
---

# PolandBall and Hypothesis

## 题目描述

PolandBall is a young, clever Ball. He is interested in prime numbers. He has stated a following hypothesis: "There exists such a positive integer $ n $ that for each positive integer $ m $ number $ n·m+1 $ is a prime number".

Unfortunately, PolandBall is not experienced yet and doesn't know that his hypothesis is incorrect. Could you prove it wrong? Write a program that finds a counterexample for any $ n $ .

## 输入格式

The only number in the input is $ n $ ( $ 1<=n<=1000 $ ) — number from the PolandBall's hypothesis.

## 输出格式

Output such $ m $ that $ n·m+1 $ is not a prime number. Your answer will be considered correct if you output any suitable $ m $ such that $ 1<=m<=10^{3} $ . It is guaranteed the the answer exists.

## 说明/提示

A prime number (or a prime) is a natural number greater than $ 1 $ that has no positive divisors other than $ 1 $ and itself.

For the first sample testcase, $ 3·1+1=4 $ . We can output $ 1 $ .

In the second sample testcase, $ 4·1+1=5 $ . We cannot output $ 1 $ because $ 5 $ is prime. However, $ m=2 $ is okay since $ 4·2+1=9 $ , which is not a prime number.

## 样例 #1

### 输入

```
3

```

### 输出

```
1
```

## 样例 #2

### 输入

```
4

```

### 输出

```
2
```



---

---
title: "Blown Garland"
layout: "post"
diff: 普及-
pid: CF758B
tag: []
---

# Blown Garland

## 题目描述

Nothing is eternal in the world, Kostya understood it on the 7-th of January when he saw partially dead four-color garland.

Now he has a goal to replace dead light bulbs, however he doesn't know how many light bulbs for each color are required. It is guaranteed that for each of four colors at least one light is working.

It is known that the garland contains light bulbs of four colors: red, blue, yellow and green. The garland is made as follows: if you take any four consecutive light bulbs then there will not be light bulbs with the same color among them. For example, the garland can look like "RYBGRYBGRY", "YBGRYBGRYBG", "BGRYB", but can not look like "BGRYG", "YBGRYBYGR" or "BGYBGY". Letters denote colors: 'R' — red, 'B' — blue, 'Y' — yellow, 'G' — green.

Using the information that for each color at least one light bulb still works count the number of dead light bulbs of each four colors.

## 输入格式

The first and the only line contains the string $ s $ ( $ 4<=|s|<=100 $ ), which describes the garland, the $ i $ -th symbol of which describes the color of the $ i $ -th light bulb in the order from the beginning of garland:

- 'R' — the light bulb is red,
- 'B' — the light bulb is blue,
- 'Y' — the light bulb is yellow,
- 'G' — the light bulb is green,
- '!' — the light bulb is dead.

The string $ s $ can not contain other symbols except those five which were described.

It is guaranteed that in the given string at least once there is each of four letters 'R', 'B', 'Y' and 'G'.

It is guaranteed that the string $ s $ is correct garland with some blown light bulbs, it means that for example the line "GRBY!!!B" can not be in the input data.

## 输出格式

In the only line print four integers $ k_{r},k_{b},k_{y},k_{g} $ — the number of dead light bulbs of red, blue, yellow and green colors accordingly.

## 说明/提示

In the first example there are no dead light bulbs.

In the second example it is obvious that one blue bulb is blown, because it could not be light bulbs of other colors on its place according to the statements.

## 样例 #1

### 输入

```
RYBGRYBGR

```

### 输出

```
0 0 0 0
```

## 样例 #2

### 输入

```
!RGYB

```

### 输出

```
0 1 0 0
```

## 样例 #3

### 输入

```
!!!!YGRB

```

### 输出

```
1 1 1 1
```

## 样例 #4

### 输入

```
!GB!RG!Y!

```

### 输出

```
2 1 1 0
```



---

---
title: "Life Without Zeros"
layout: "post"
diff: 普及-
pid: CF75A
tag: []
---

# Life Without Zeros

## 题目描述

Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation $ a+b=c $ , where $ a $ and $ b $ are positive integers, and $ c $ is the sum of $ a $ and $ b $ . Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is $ 101+102=203 $ , if we removed all zeros it will be $ 11+12=23 $ which is still a correct equation.

But if the equation is $ 105+106=211 $ , if we removed all zeros it will be $ 15+16=211 $ which is not a correct equation.

## 输入格式

The input will consist of two lines, the first line will contain the integer $ a $ , and the second line will contain the integer $ b $ which are in the equation as described above ( $ 1<=a,b<=10^{9} $ ). There won't be any leading zeros in both. The value of $ c $ should be calculated as $ c=a+b $ .

## 输出格式

The output will be just one line, you should print "YES" if the equation will remain correct after removing all zeros, and print "NO" otherwise.

## 样例 #1

### 输入

```
101
102

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
105
106

```

### 输出

```
NO

```



---

---
title: "Dasha and Stairs"
layout: "post"
diff: 普及-
pid: CF761A
tag: []
---

# Dasha and Stairs

## 题目描述

老虎Dasha在她前往编程学校的路上遇到了第一个挑战 — 一个巨大的楼梯！

这些台阶被从一到无穷编号。据我们所知，老虎喜欢所有有斑纹的东西，那可能就像是他们身上的颜色。所以在她的路上的一些时间她计算了两个值 — 台阶编号的奇偶数的数量。

你需要检查一下是否存在一段从第$l$ 个台阶到第$r$ 个台阶（$1\leq l\leq r$ ），Dasha认为其（奇偶）值是合适的。

## 输入格式

在唯一的一行你被给了两个整数$a$ ，$b$ （$0\leq a,b\leq 100$ ） — 对应奇偶台阶数。

## 输出格式

仅需输出一行"YES"，如果存在这样的一段台阶，否则输出"NO"。

## 说明/提示

在第一个样例中一段合适的区间为$1$ 到$5$ 。这段区间包含了两个偶数台阶 — $2$ 和$4$ ,和三个奇数：$1$ ，$3$ 和$5$ 。

（注：由于题面或我的问题，这样翻译其实题意并不明，附上题目大意）

#### 题目大意

给你两个数，分别为偶数的数量$a$ 和奇数的数量$b$ ，问是否存在一段连续区间$[l,r]$ 其奇偶数的数目为$a$ 和$b$ （就是所谓的合适的）。

感谢@Khassar  提供的翻译

## 样例 #1

### 输入

```
2 3

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3 1

```

### 输出

```
NO

```



---

---
title: "Timofey and cubes"
layout: "post"
diff: 普及-
pid: CF764B
tag: []
---

# Timofey and cubes

## 题目描述

Young Timofey has a birthday today! He got kit of $ n $ cubes as a birthday present from his parents. Every cube has a number $ a_{i} $ , which is written on it. Timofey put all the cubes in a row and went to unpack other presents.

In this time, Timofey's elder brother, Dima reordered the cubes using the following rule. Suppose the cubes are numbered from $ 1 $ to $ n $ in their order. Dima performs several steps, on step $ i $ he reverses the segment of cubes from $ i $ -th to $ (n-i+1) $ -th. He does this while $ i<=n-i+1 $ .

After performing the operations Dima went away, being very proud of himself. When Timofey returned to his cubes, he understood that their order was changed. Help Timofey as fast as you can and save the holiday — restore the initial order of the cubes using information of their current location.

## 输入格式

The first line contains single integer $ n $ ( $ 1<=n<=2·10^{5} $ ) — the number of cubes.

The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ -10^{9}<=a_{i}<=10^{9} $ ), where $ a_{i} $ is the number written on the $ i $ -th cube after Dima has changed their order.

## 输出格式

Print $ n $ integers, separated by spaces — the numbers written on the cubes in their initial order.

It can be shown that the answer is unique.

## 说明/提示

Consider the first sample.

1. At the begining row was \[ $ 2 $ , $ 3 $ , $ 9 $ , $ 6 $ , $ 7 $ , $ 1 $ , $ 4 $ \].
2. After first operation row was \[ $ 4 $ , $ 1 $ , $ 7 $ , $ 6 $ , $ 9 $ , $ 3 $ , $ 2 $ \].
3. After second operation row was \[ $ 4 $ , $ 3 $ , $ 9 $ , $ 6 $ , $ 7 $ , $ 1 $ , $ 2 $ \].
4. After third operation row was \[ $ 4 $ , $ 3 $ , $ 7 $ , $ 6 $ , $ 9 $ , $ 1 $ , $ 2 $ \].
5. At fourth operation we reverse just middle element, so nothing has changed. The final row is \[ $ 4 $ , $ 3 $ , $ 7 $ , $ 6 $ , $ 9 $ , $ 1 $ , $ 2 $ \]. So the answer for this case is row \[ $ 2 $ , $ 3 $ , $ 9 $ , $ 6 $ , $ 7 $ , $ 1 $ , $ 4 $ \].

## 样例 #1

### 输入

```
7
4 3 7 6 9 1 2

```

### 输出

```
2 3 9 6 7 1 4
```

## 样例 #2

### 输入

```
8
6 1 4 2 5 6 9 2

```

### 输出

```
2 1 6 2 5 4 9 6
```



---

---
title: "Code obfuscation"
layout: "post"
diff: 普及-
pid: CF765B
tag: []
---

# Code obfuscation

## 题目描述

Kostya likes Codeforces contests very much. However, he is very disappointed that his solutions are frequently hacked. That's why he decided to obfuscate (intentionally make less readable) his code before upcoming contest.

To obfuscate the code, Kostya first looks at the first variable name used in his program and replaces all its occurrences with a single symbol $ a $ , then he looks at the second variable name that has not been replaced yet, and replaces all its occurrences with $ b $ , and so on. Kostya is well-mannered, so he doesn't use any one-letter names before obfuscation. Moreover, there are at most 26 unique identifiers in his programs.

You are given a list of identifiers of some program with removed spaces and line breaks. Check if this program can be a result of Kostya's obfuscation.

## 输入格式

In the only line of input there is a string $ S $ of lowercase English letters ( $ 1<=|S|<=500 $ ) — the identifiers of a program with removed whitespace characters.

## 输出格式

If this program can be a result of Kostya's obfuscation, print "YES" (without quotes), otherwise print "NO".

## 说明/提示

In the first sample case, one possible list of identifiers would be "number string number character number string number". Here how Kostya would obfuscate the program:

- replace all occurences of number with a, the result would be "a string a character a string a",
- replace all occurences of string with b, the result would be "a b a character a b a",
- replace all occurences of character with c, the result would be "a b a c a b a",
- all identifiers have been replaced, thus the obfuscation is finished.

## 样例 #1

### 输入

```
abacaba

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
jinotega

```

### 输出

```
NO

```



---

---
title: "Snacktower"
layout: "post"
diff: 普及-
pid: CF767A
tag: []
---

# Snacktower

## 题目描述

According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time $ n $ snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF767A/180cab69cae65dd25cd78379f99c54f80aacaf67.png)However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.

## 输入格式

The first line contains single integer $ n $ ( $ 1<=n<=100000 $ ) — the total number of snacks.

The second line contains $ n $ integers, the $ i $ -th of them equals the size of the snack which fell on the $ i $ -th day. Sizes are distinct integers from $ 1 $ to $ n $ .

## 输出格式

Print $ n $ lines. On the $ i $ -th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the $ i $ -th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.

## 说明/提示

In the example a snack of size $ 3 $ fell on the first day, and the residents immediately placed it. On the second day a snack of size $ 1 $ fell, and the residents weren't able to place it because they were missing the snack of size $ 2 $ . On the third day a snack of size $ 2 $ fell, and the residents immediately placed it. Right after that they placed the snack of size $ 1 $ which had fallen before.

## 样例 #1

### 输入

```
3
3 1 2

```

### 输出

```
3
 
2 1
```

## 样例 #2

### 输入

```
5
4 5 1 2 3

```

### 输出

```
 
5 4
 
 
3 2 1

```



---

---
title: "Oath of the Night's Watch"
layout: "post"
diff: 普及-
pid: CF768A
tag: []
---

# Oath of the Night's Watch

## 题目描述

### 简要翻译

- 给定 $n$ 个非负整数 $a_{1 \ldots n}$。
- 你需要求出有多少个 $a_i$，满足：存在正整数 $j, k$，使得 $a_j < a_i$ 且 $a_k > a_i$。
- $1 \leqslant n \leqslant 10^5$；$\forall 1 \leqslant i \leqslant n$，有 $0 \leqslant a_i \leqslant 10^9$。


“长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。”——《守夜人誓言》

琼恩·雪诺的守夜开始了。他被派去守护管家。

这次他需要守护 $n$ 个管家。每个管家都有他自己的力量值 $a$。琼恩喜欢守护一个管家，当且仅当存在至少一个力量值严格小于这个管家的管家，且存在至少一个力量值严格大于这个管家的管家。

你知道琼恩喜欢守护多少管家吗？

## 输入格式

共两行。

第一行：一个整数 $n$，表示琼恩需要守护的管家数量。

第二行：$n$ 个整数，第 $i$ 个数 $a_i$ 表示第 $i$ 个管家的力量值。

## 输出格式

共一行，一个整数，表示琼恩喜欢守护的管家数量。

## 说明/提示

#### 样例解释

- 样例 $1$ 解释：琼恩既不喜欢守护力量值为 $1$ 的管家，也不愿意守护力量值为 $5$ 的管家；因为没有任何一个管家的力量值小于 $1$，也没有任何一个管家的力量值大于 $5$。
- 样例 $2$ 解释：琼恩喜欢守护力量值为 $2$ 的管家，因为既有力量值小于 $2$ 的管家，也有力量值大于 $2$ 的管家。


- $1 \leqslant n \leqslant 10^5$。
- $\forall 1 \leqslant i \leqslant n,0 \leqslant a_i \leqslant 10^9$。

## 样例 #1

### 输入

```
2
1 5

```

### 输出

```
0
```

## 样例 #2

### 输入

```
3
1 2 5

```

### 输出

```
1
```



---

---
title: "New Password"
layout: "post"
diff: 普及-
pid: CF770A
tag: []
---

# New Password

## 题目描述

Innokentiy decides to change the password in the social net "Contact!", but he is too lazy to invent a new password by himself. That is why he needs your help.

Innokentiy decides that new password should satisfy the following conditions:

- the length of the password must be equal to $ n $ ,
- the password should consist only of lowercase Latin letters,
- the number of distinct symbols in the password must be equal to $ k $ ,
- any two consecutive symbols in the password must be distinct.

Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.

## 输入格式

The first line contains two positive integers $ n $ and $ k $ ( $ 2<=n<=100 $ , $ 2<=k<=min(n,26) $ ) — the length of the password and the number of distinct symbols in it.

Pay attention that a desired new password always exists.

## 输出格式

Print any password which satisfies all conditions given by Innokentiy.

## 说明/提示

In the first test there is one of the appropriate new passwords — java, because its length is equal to $ 4 $ and $ 3 $ distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to $ 6 $ and it consists of $ 6 $ distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to $ 5 $ and $ 2 $ distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.

## 样例 #1

### 输入

```
4 3

```

### 输出

```
java

```

## 样例 #2

### 输入

```
6 6

```

### 输出

```
python

```

## 样例 #3

### 输入

```
5 2

```

### 输出

```
phphp

```



---

---
title: "Maximum Number"
layout: "post"
diff: 普及-
pid: CF774C
tag: []
---

# Maximum Number

## 题目描述

Stepan has the newest electronic device with a display. Different digits can be shown on it. Each digit is shown on a seven-section indicator like it is shown on the picture below.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF774C/7e680319981615bc8164e9951beec5e830c7cca7.png)So, for example, to show the digit $ 3 $ on the display, $ 5 $ sections must be highlighted; and for the digit $ 6 $ , $ 6 $ sections must be highlighted.

The battery of the newest device allows to highlight at most $ n $ sections on the display.

Stepan wants to know the maximum possible integer number which can be shown on the display of his newest device. Your task is to determine this number. Note that this number must not contain leading zeros. Assume that the size of the display is enough to show any integer.

## 输入格式

The first line contains the integer $ n $ ( $ 2<=n<=100000 $ ) — the maximum number of sections which can be highlighted on the display.

## 输出格式

Print the maximum integer which can be shown on the display of Stepan's newest device.

## 样例 #1

### 输入

```
2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
3

```

### 输出

```
7

```



---

---
title: "Game of Credit Cards"
layout: "post"
diff: 普及-
pid: CF777B
tag: []
---

# Game of Credit Cards

## 题目描述

After the fourth season Sherlock and Moriary have realized the whole foolishness of the battle between them and decided to continue their competitions in peaceful game of Credit Cards.

Rules of this game are simple: each player bring his favourite $ n $ -digit credit card. Then both players name the digits written on their cards one by one. If two digits are not equal, then the player, whose digit is smaller gets a flick (knock in the forehead usually made with a forefinger) from the other player. For example, if $ n=3 $ , Sherlock's card is $ 123 $ and Moriarty's card has number $ 321 $ , first Sherlock names $ 1 $ and Moriarty names $ 3 $ so Sherlock gets a flick. Then they both digit $ 2 $ so no one gets a flick. Finally, Sherlock names $ 3 $ , while Moriarty names $ 1 $ and gets a flick.

Of course, Sherlock will play honestly naming digits one by one in the order they are given, while Moriary, as a true villain, plans to cheat. He is going to name his digits in some other order (however, he is not going to change the overall number of occurences of each digit). For example, in case above Moriarty could name $ 1 $ , $ 2 $ , $ 3 $ and get no flicks at all, or he can name $ 2 $ , $ 3 $ and $ 1 $ to give Sherlock two flicks.

Your goal is to find out the minimum possible number of flicks Moriarty will get (no one likes flicks) and the maximum possible number of flicks Sherlock can get from Moriarty. Note, that these two goals are different and the optimal result may be obtained by using different strategies.

## 输入格式

The first line of the input contains a single integer $ n $ ( $ 1<=n<=1000 $ ) — the number of digits in the cards Sherlock and Moriarty are going to use.

The second line contains $ n $ digits — Sherlock's credit card number.

The third line contains $ n $ digits — Moriarty's credit card number.

## 输出格式

First print the minimum possible number of flicks Moriarty will get. Then print the maximum possible number of flicks that Sherlock can get from Moriarty.

## 说明/提示

First sample is elaborated in the problem statement. In the second sample, there is no way Moriarty can avoid getting two flicks.

## 样例 #1

### 输入

```
3
123
321

```

### 输出

```
0
2

```

## 样例 #2

### 输入

```
2
88
00

```

### 输出

```
2
0

```



---

---
title: "Pupils Redistribution"
layout: "post"
diff: 普及-
pid: CF779A
tag: []
---

# Pupils Redistribution

## 题目描述

在Berland每一个高中生的成绩都很有特点 — 一个在$1$ 和$5$ 之间的整数。

在高中0xFF有两个学生小组，每个小组都有$n$ 名学生。每名学生的成绩就像所知的 — 一个在$1$ 和$5$ 之间的整数。

学校主任想要在小组间重新分配这些学生以达到在两个小组间成绩为$1$ 的学生数量相等，成绩为$2$ 的学生数量相等，以此类推。换句话说，学校主任的目的是，在改变完学生的组成后，每个成绩在两个小组都有相同的人数。

实现这个的方式是，有计划的在小组间进行一系列的学生交换。每次交换中主任都会从$A$ 班(原文就是班，实际应该是组的意思)中选一名学生，再从B班中选一名学生。然后，交换他们所属的组。

输出最少的交换数，来使得每个成绩在两个小组都有相同的人数。

## 输入格式

第一行输入一个整数$n$ （$1\leq n\leq 100$ ） — 两个组各自的学生数。

第二行包含一列整数$a_1,a_2,\dots,a_n$ （$1\leq a_i\leq 5$ ） — $a_i$ 为在$A$ 组第$i$ 名学生的成绩。

第三行包含一列整数$b_1,b_2,\dots,b_n$ （$1\leq b_i\leq 5$ ） — $b_i$ 为在$B$ 组第$i$ 名学生的成绩。

## 输出格式

输出完成要求所需要的最少交换数，或-1，表示要求根本不能完成。

感谢@Khassar  提供的翻译

## 样例 #1

### 输入

```
4
5 4 4 4
5 5 4 5

```

### 输出

```
1

```

## 样例 #2

### 输入

```
6
1 1 1 1 1 1
5 5 5 5 5 5

```

### 输出

```
3

```

## 样例 #3

### 输入

```
1
5
3

```

### 输出

```
-1

```

## 样例 #4

### 输入

```
9
3 2 5 5 2 3 3 3 2
4 1 4 1 1 2 4 4 1

```

### 输出

```
4

```



---

---
title: "Dishonest Sellers"
layout: "post"
diff: 普及-
pid: CF779C
tag: []
---

# Dishonest Sellers

## 题目描述

Igor found out discounts in a shop and decided to buy $ n $ items. Discounts at the store will last for a week and Igor knows about each item that its price now is $ a_{i} $ , and after a week of discounts its price will be $ b_{i} $ .

Not all of sellers are honest, so now some products could be more expensive than after a week of discounts.

Igor decided that buy at least $ k $ of items now, but wait with the rest of the week in order to save money as much as possible. Your task is to determine the minimum money that Igor can spend to buy all $ n $ items.

## 输入格式

In the first line there are two positive integer numbers $ n $ and $ k $ ( $ 1<=n<=2·10^{5} $ , $ 0<=k<=n $ ) — total number of items to buy and minimal number of items Igor wants to by right now.

The second line contains sequence of integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{4} $ ) — prices of items during discounts (i.e. right now).

The third line contains sequence of integers $ b_{1},b_{2},...,b_{n} $ ( $ 1<=b_{i}<=10^{4} $ ) — prices of items after discounts (i.e. after a week).

## 输出格式

Print the minimal amount of money Igor will spend to buy all $ n $ items. Remember, he should buy at least $ k $ items right now.

## 说明/提示

In the first example Igor should buy item 3 paying 6. But items 1 and 2 he should buy after a week. He will pay 3 and 1 for them. So in total he will pay $ 6+3+1=10 $ .

In the second example Igor should buy right now items 1, 2, 4 and 5, paying for them 3, 4, 10 and 3, respectively. Item 3 he should buy after a week of discounts, he will pay 5 for it. In total he will spend $ 3+4+10+3+5=25 $ .

## 样例 #1

### 输入

```
3 1
5 4 6
3 1 5

```

### 输出

```
10

```

## 样例 #2

### 输入

```
5 3
3 4 7 10 3
4 5 5 12 5

```

### 输出

```
25

```



---

---
title: "Andryusha and Socks"
layout: "post"
diff: 普及-
pid: CF780A
tag: []
---

# Andryusha and Socks

## 题目描述

Andryusha is an orderly boy and likes to keep things in their place.

Today he faced a problem to put his socks in the wardrobe. He has $ n $ distinct pairs of socks which are initially in a bag. The pairs are numbered from $ 1 $ to $ n $ . Andryusha wants to put paired socks together and put them in the wardrobe. He takes the socks one by one from the bag, and for each sock he looks whether the pair of this sock has been already took out of the bag, or not. If not (that means the pair of this sock is still in the bag), he puts the current socks on the table in front of him. Otherwise, he puts both socks from the pair to the wardrobe.

Andryusha remembers the order in which he took the socks from the bag. Can you tell him what is the maximum number of socks that were on the table at the same time?

## 输入格式

The first line contains the single integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of sock pairs.

The second line contains $ 2n $ integers $ x_{1},x_{2},...,x_{2n} $ ( $ 1<=x_{i}<=n $ ), which describe the order in which Andryusha took the socks from the bag. More precisely, $ x_{i} $ means that the $ i $ -th sock Andryusha took out was from pair $ x_{i} $ .

It is guaranteed that Andryusha took exactly two socks of each pair.

## 输出格式

Print single integer — the maximum number of socks that were on the table at the same time.

## 说明/提示

In the first example Andryusha took a sock from the first pair and put it on the table. Then he took the next sock which is from the first pair as well, so he immediately puts both socks to the wardrobe. Thus, at most one sock was on the table at the same time.

In the second example Andryusha behaved as follows:

- Initially the table was empty, he took out a sock from pair $ 2 $ and put it on the table.
- Sock $ (2) $ was on the table. Andryusha took out a sock from pair $ 1 $ and put it on the table.
- Socks $ (1,2) $ were on the table. Andryusha took out a sock from pair $ 1 $ , and put this pair into the wardrobe.
- Sock $ (2) $ was on the table. Andryusha took out a sock from pair $ 3 $ and put it on the table.
- Socks $ (2,3) $ were on the table. Andryusha took out a sock from pair $ 2 $ , and put this pair into the wardrobe.
- Sock $ (3) $ was on the table. Andryusha took out a sock from pair $ 3 $ and put this pair into the wardrobe.

 Thus, at most two socks were on the table at the same time.

## 样例 #1

### 输入

```
1
1 1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
3
2 1 1 3 2 3

```

### 输出

```
2

```



---

---
title: "Anton and Classes"
layout: "post"
diff: 普及-
pid: CF785B
tag: []
---

# Anton and Classes

## 题目描述

Anton很喜欢下棋，同时又很喜欢编程。难怪，他会想去参加棋艺班和编程班！

一共有n个棋艺班，m个编程班。第i个棋艺班的时间用$(l_{1,i},r_{1,i})$表示，第i个编程班的时间用$(l_{2,i},r_{2,i})$表示。

Anton需要在全部的棋艺班和编程班中间恰好各选一个。他想要在两个班之间有休息的时间，所以对于所有可能的选择，他希望两个时间段的距离（即他的休息时间）最大。

两个时间段$(l_1,r_1)$和$(l_2,r_2)$的距离是这样定义的：对于$l_1\le i\le r_1$，$l_2\le j\le r_2$，距离就是$|i-j|$的最小值。如果两个时间段相交，那么他们的距离当然就是$0$。

Anton很想知道，他的休息时间最大是多少。帮帮他解决这个问题吧！

## 输入格式

第一行一个整数n。

第2~n+1行，每行两个数$l_{1,i}$和$r_{1,i}$。

第n+2行一个整数m。

接下来mmm行，每行两个数$l_{2,i}$和$r_{2,i}$。

保证$1<=n,m<=200000$。对于输入中的所有$x$，保证$1<=x<=10^9$。

## 输出格式

一个整数，表示Anton的最大休息时间。

## 样例 #1

### 输入

```
3
1 5
2 6
2 3
2
2 4
6 8

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3
1 5
2 6
3 7
2
2 4
1 4

```

### 输出

```
0

```



---

---
title: "Not Afraid"
layout: "post"
diff: 普及-
pid: CF787B
tag: []
---

# Not Afraid

## 题目描述

Since the giant heads have appeared in the sky all humanity is in danger, so all Ricks and Mortys from all parallel universes are gathering in groups to find a solution to get rid of them.

There are $ n $ parallel universes participating in this event ( $ n $ Ricks and $ n $ Mortys). I. e. each of $ n $ universes has one Rick and one Morty. They're gathering in $ m $ groups. Each person can be in many groups and a group can contain an arbitrary number of members.

Ricks and Mortys have registered online in these groups. So, a person can have joined a group more than once (developer of this website hadn't considered this possibility).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF787B/dcab08f4f41338897a1e46a0544bffe9ab994433.png)Summer from universe #1 knows that in each parallel universe (including hers) exactly one of Rick and Morty from that universe is a traitor and is loyal, but no one knows which one. She knows that we are doomed if there's a group such that every member in that group is a traitor (they will plan and destroy the world).

Summer knows that if there's a possibility that world ends (there's a group where all members are traitors) she should immediately cancel this event. So she wants to know if she should cancel the event. You have to tell her yes if and only if there's at least one scenario (among all $ 2^{n} $ possible scenarios, $ 2 $ possible scenarios for who a traitor in each universe) such that in that scenario the world will end.

## 输入格式

The first line of input contains two integers $ n $ and $ m $ ( $ 1<=n,m<=10^{4} $ ) — number of universes and number of groups respectively.

The next $ m $ lines contain the information about the groups. $ i $ -th of them first contains an integer $ k $ (number of times someone joined $ i $ -th group, $ k&gt;0 $ ) followed by $ k $ integers $ v_{i,1},v_{i,2},...,v_{i,k} $ . If $ v_{i,j} $ is negative, it means that Rick from universe number $ -v_{i,j} $ has joined this group and otherwise it means that Morty from universe number $ v_{i,j} $ has joined it.

Sum of $ k $ for all groups does not exceed $ 10^{4} $ .

## 输出格式

In a single line print the answer to Summer's question. Print "YES" if she should cancel the event and "NO" otherwise.

## 说明/提示

In the first sample testcase, $ 1 $ st group only contains the Rick from universe number $ 3 $ , so in case he's a traitor, then all members of this group are traitors and so Summer should cancel the event.

## 样例 #1

### 输入

```
4 2
1 -3
4 -2 3 2 -3

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
5 2
5 3 -2 1 -1 5
3 -5 2 5

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
7 2
3 -1 6 7
7 -5 4 2 4 7 -3 4

```

### 输出

```
YES

```



---

---
title: "Easter Eggs"
layout: "post"
diff: 普及-
pid: CF78B
tag: []
---

# Easter Eggs

## 题目描述

The Easter Rabbit laid $ n $ eggs in a circle and is about to paint them.

Each egg should be painted one color out of 7: red, orange, yellow, green, blue, indigo or violet. Also, the following conditions should be satisfied:

- Each of the seven colors should be used to paint at least one egg.
- Any four eggs lying sequentially should be painted different colors.

Help the Easter Rabbit paint the eggs in the required manner. We know that it is always possible.

## 输入格式

The only line contains an integer $ n $ — the amount of eggs ( $ 7<=n<=100 $ ).

## 输出格式

Print one line consisting of $ n $ characters. The $ i $ -th character should describe the color of the $ i $ -th egg in the order they lie in the circle. The colors should be represented as follows: "R" stands for red, "O" stands for orange, "Y" stands for yellow, "G" stands for green, "B" stands for blue, "I" stands for indigo, "V" stands for violet.

If there are several answers, print any of them.

## 说明/提示

The way the eggs will be painted in the first sample is shown on the picture:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF78B/89e74426378989547383b9ed8ec253c74d4ce7d9.png)

## 样例 #1

### 输入

```
8

```

### 输出

```
ROYGRBIV

```

## 样例 #2

### 输入

```
13

```

### 输出

```
ROYGBIVGBIVYG

```



---

---
title: "New Bus Route"
layout: "post"
diff: 普及-
pid: CF792A
tag: []
---

# New Bus Route

## 题目描述

There are $ n $ cities situated along the main road of Berland. Cities are represented by their coordinates — integer numbers $ a_{1},a_{2},...,a_{n} $ . All coordinates are pairwise distinct.

It is possible to get from one city to another only by bus. But all buses and roads are very old, so the Minister of Transport decided to build a new bus route. The Minister doesn't want to spend large amounts of money — he wants to choose two cities in such a way that the distance between them is minimal possible. The distance between two cities is equal to the absolute value of the difference between their coordinates.

It is possible that there are multiple pairs of cities with minimal possible distance, so the Minister wants to know the quantity of such pairs.

Your task is to write a program that will calculate the minimal possible distance between two pairs of cities and the quantity of pairs which have this distance.

## 输入格式

The first line contains one integer number $ n $ ( $ 2<=n<=2·10^{5} $ ).

The second line contains $ n $ integer numbers $ a_{1},a_{2},...,a_{n} $ ( $ -10^{9}<=a_{i}<=10^{9} $ ). All numbers $ a_{i} $ are pairwise distinct.

## 输出格式

Print two integer numbers — the minimal distance and the quantity of pairs with this distance.

## 说明/提示

In the first example the distance between the first city and the fourth city is $ |4-6|=2 $ , and it is the only pair with this distance.

## 样例 #1

### 输入

```
4
6 -3 0 4

```

### 输出

```
2 1

```

## 样例 #2

### 输入

```
3
-2 0 2

```

### 输出

```
2 2

```



---

---
title: "Counting-out Rhyme"
layout: "post"
diff: 普及-
pid: CF792B
tag: []
---

# Counting-out Rhyme

## 题目描述

 $ n $ children are standing in a circle and playing the counting-out game. Children are numbered clockwise from $ 1 $ to $ n $ . In the beginning, the first child is considered the leader. The game is played in $ k $ steps. In the $ i $ -th step the leader counts out $ a_{i} $ people in clockwise order, starting from the next person. The last one to be pointed at by the leader is eliminated, and the next player after him becomes the new leader.

For example, if there are children with numbers $ [8,10,13,14,16] $ currently in the circle, the leader is child $ 13 $ and $ a_{i}=12 $ , then counting-out rhyme ends on child $ 16 $ , who is eliminated. Child $ 8 $ becomes the leader.

You have to write a program which prints the number of the child to be eliminated on every step.

## 输入格式

The first line contains two integer numbers $ n $ and $ k $ ( $ 2<=n<=100 $ , $ 1<=k<=n-1 $ ).

The next line contains $ k $ integer numbers $ a_{1},a_{2},...,a_{k} $ ( $ 1<=a_{i}<=10^{9} $ ).

## 输出格式

Print $ k $ numbers, the $ i $ -th one corresponds to the number of child to be eliminated at the $ i $ -th step.

## 说明/提示

Let's consider first example:

- In the first step child $ 4 $ is eliminated, child $ 5 $ becomes the leader.
- In the second step child $ 2 $ is eliminated, child $ 3 $ becomes the leader.
- In the third step child $ 5 $ is eliminated, child $ 6 $ becomes the leader.
- In the fourth step child $ 6 $ is eliminated, child $ 7 $ becomes the leader.
- In the final step child $ 1 $ is eliminated, child $ 3 $ becomes the leader.

## 样例 #1

### 输入

```
7 5
10 4 11 4 1

```

### 输出

```
4 2 5 6 1 

```

## 样例 #2

### 输入

```
3 2
2 5

```

### 输出

```
3 2 

```



---

---
title: "Oleg and shares"
layout: "post"
diff: 普及-
pid: CF793A
tag: []
---

# Oleg and shares

## 题目描述

Oleg the bank client checks share prices every day. There are $ n $ share prices he is interested in. Today he observed that each second exactly one of these prices decreases by $ k $ rubles (note that each second exactly one price changes, but at different seconds different prices can change). Prices can become negative. Oleg found this process interesting, and he asked Igor the financial analyst, what is the minimum time needed for all $ n $ prices to become equal, or it is impossible at all? Igor is busy right now, so he asked you to help Oleg. Can you answer this question?

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1<=n<=10^{5},1<=k<=10^{9} $ ) — the number of share prices, and the amount of rubles some price decreases each second.

The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{9} $ ) — the initial prices.

## 输出格式

Print the only line containing the minimum number of seconds needed for prices to become equal, of «-1» if it is impossible.

## 说明/提示

Consider the first example.

Suppose the third price decreases in the first second and become equal $ 12 $ rubles, then the first price decreases and becomes equal $ 9 $ rubles, and in the third second the third price decreases again and becomes equal $ 9 $ rubles. In this case all prices become equal $ 9 $ rubles in $ 3 $ seconds.

There could be other possibilities, but this minimizes the time needed for all prices to become equal. Thus the answer is $ 3 $ .

In the second example we can notice that parity of first and second price is different and never changes within described process. Thus prices never can become equal.

In the third example following scenario can take place: firstly, the second price drops, then the third price, and then fourth price. It happens $ 999999999 $ times, and, since in one second only one price can drop, the whole process takes $ 999999999*3=2999999997 $ seconds. We can note that this is the minimum possible time.

## 样例 #1

### 输入

```
3 3
12 9 15

```

### 输出

```
3
```

## 样例 #2

### 输入

```
2 2
10 9

```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4 1
1 1000000000 1000000000 1000000000

```

### 输出

```
2999999997
```



---

---
title: "Odd sum"
layout: "post"
diff: 普及-
pid: CF797B
tag: []
---

# Odd sum

## 题目描述

现给予你一个长度为n,包含正整数的序列 ***a1,a2……an***，你的任务是找到一个和为奇数且值最大（在和为奇数的子序列中）的子序列。可以保证该序列中有和为奇数的子序列  
子序列是一个可以通过删除一个序列中的部分元素，但不改变其他元素的顺序后得到的新序列  
现在请你写一个程序找到上述的这样一个子序列

## 输入格式

第一行包含一个整数***(1<=n<=10^5)***
第二行包含n个整数***a1,a2……an(-10^4<=ai<=10^4)*** 该序列包含至少一个和为奇数的子序列

## 输出格式

输出找到的子序列的和

## 说明/提示

第一个样例中的第二个元素与第四个元素的和为3

## 样例 #1

### 输入

```
4
-2 2 -3 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
3
2 -5 -3

```

### 输出

```
-1

```



---

---
title: "Carrot Cakes"
layout: "post"
diff: 普及-
pid: CF799A
tag: []
---

# Carrot Cakes

## 题目描述

一共需要烤 $n$ 个蛋糕，用一个烤箱烤 $k$ 个蛋糕需要 $t$ 分钟。现有一个烤箱，可以再用 $d$ 分钟建一个。建烤箱时正在建的烤箱不能工作，但另一个烤箱可以。问：新建烤箱烤完 $n$ 个蛋糕的时间是否比不新建要严格快（即不能等于）？

## 输入格式

一行，四个数，分别是 $n$ , $t$ , $k$ , $d$。

## 输出格式

若比它要快，输出```YES```；否则输出```NO```。

## 样例 #1

### 输入

```
8 6 4 5

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
8 6 4 6

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
10 3 11 4

```

### 输出

```
NO

```

## 样例 #4

### 输入

```
4 2 1 4

```

### 输出

```
YES

```



---

---
title: "Bus Game"
layout: "post"
diff: 普及-
pid: CF79A
tag: []
---

# Bus Game

## 题目描述

在狐狸Ciel赢得一场编程现场赛之后，她乘坐公共汽车返回她的城堡。 公共汽车的车费是220日元。 她在巴士上遇到了兔子Hanako。 因为他们在公车上感到无聊，所以她们决定玩下面这个游戏。 起初，有一堆硬币，里面包含了x枚100日元硬币和y枚10日元硬币。 他们轮流从中取硬币。 Ciel先手拿。 在每个回合里，她们每次必须从堆中拿出刚好220日元。 在轮到Ciel时，如果她有多种方式可以从中取出220日元，她会选择包含最大数量的100日元硬币的方式。 轮到Hanako时，如果有多种方式可以取出220日元，她会选择包含最多10日元硬币的方式。如果轮到了Ciel或Hanako不能从堆中拿出220日元，那么她就会失败。 请确定这场游戏的胜利者。

## 输出格式

说明： 第一回合（Ciel取），她会选择2个100日元硬币和2个10日元硬币。 在第二回合（Hanako取），她会选择1个100日元硬币和12个10日元硬币。 在第三回合（Ciel取），她不能取得220日元，所以Ciel会输。

Translated by @good_vegetable

## 样例 #1

### 输入

```
2 2

```

### 输出

```
Ciel

```

## 样例 #2

### 输入

```
3 22

```

### 输出

```
Hanako

```



---

---
title: "Distances to Zero"
layout: "post"
diff: 普及-
pid: CF803B
tag: []
---

# Distances to Zero

## 题目描述

You are given the array of integer numbers $ a_{0},a_{1},...,a_{n-1} $ . For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=2·10^{5} $ ) — length of the array $ a $ . The second line contains integer elements of the array separated by single spaces ( $ -10^{9}<=a_{i}<=10^{9} $ ).

## 输出格式

Print the sequence $ d_{0},d_{1},...,d_{n-1} $ , where $ d_{i} $ is the difference of indices between $ i $ and nearest $ j $ such that $ a_{j}=0 $ . It is possible that $ i=j $ .

## 样例 #1

### 输入

```
9
2 1 0 3 0 0 3 2 4

```

### 输出

```
2 1 0 1 0 0 1 2 3 
```

## 样例 #2

### 输入

```
5
0 1 2 3 4

```

### 输出

```
0 1 2 3 4 
```

## 样例 #3

### 输入

```
7
5 6 0 1 -2 3 4

```

### 输出

```
2 1 0 1 2 3 4 
```



---

---
title: "Lucky Year"
layout: "post"
diff: 普及-
pid: CF808A
tag: []
---

# Lucky Year

## 题目描述

除了一年中的许多假期，Berland的居民还有一整个幸运年。如果年份中有不超过1个的非零数字，这一年就被认为是幸运的。所以100,40000,5年是幸运的，12,3001,12345年不是。

你被告知了Berland当前的年份，你的任务就是去找到Berland还要等多久才能迎来下一个幸运年。

## 输入格式

第一行包含一个整数 $n$  （$1\leq n\leq 10^9$ ）— 当前Berland的年份。

## 输出格式

输出一个从当前年份到下一个幸运年所经过的年数。

## 说明/提示

第一个样例中，下一个幸运年是5。在第二个中 — 300。在第三个中 — 5000。

by @Khassar

## 样例 #1

### 输入

```
4

```

### 输出

```
1

```

## 样例 #2

### 输入

```
201

```

### 输出

```
99

```

## 样例 #3

### 输入

```
4000

```

### 输出

```
1000

```



---

---
title: "Average Sleep Time"
layout: "post"
diff: 普及-
pid: CF808B
tag: []
---

# Average Sleep Time

## 题目描述

It's been almost a week since Polycarp couldn't get rid of insomnia. And as you may already know, one week in Berland lasts $ k $ days!

When Polycarp went to a doctor with his problem, the doctor asked him about his sleeping schedule (more specifically, the average amount of hours of sleep per week). Luckily, Polycarp kept records of sleep times for the last $ n $ days. So now he has a sequence $ a_{1},a_{2},...,a_{n} $ , where $ a_{i} $ is the sleep time on the $ i $ -th day.

The number of records is so large that Polycarp is unable to calculate the average value by himself. Thus he is asking you to help him with the calculations. To get the average Polycarp is going to consider $ k $ consecutive days as a week. So there will be $ n-k+1 $ weeks to take into consideration. For example, if $ k=2 $ , $ n=3 $ and $ a=[3,4,7] $ , then the result is ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF808B/86ab5f462dc3fdaf9fb78d24cfe814007844dab2.png).

You should write a program which will calculate average sleep times of Polycarp over all weeks.

## 输入格式

The first line contains two integer numbers $ n $ and $ k $ ( $ 1<=k<=n<=2·10^{5} $ ).

The second line contains $ n $ integer numbers $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i}<=10^{5} $ ).

## 输出格式

Output average sleeping time over all weeks.

The answer is considered to be correct if its absolute or relative error does not exceed $ 10^{-6} $ . In particular, it is enough to output real number with at least 6 digits after the decimal point.

## 说明/提示

In the third example there are $ n-k+1=7 $ weeks, so the answer is sums of all weeks divided by 7.

## 样例 #1

### 输入

```
3 2
3 4 7

```

### 输出

```
9.0000000000

```

## 样例 #2

### 输入

```
1 1
10

```

### 输出

```
10.0000000000

```

## 样例 #3

### 输入

```
8 2
1 2 4 100000 123 456 789 1

```

### 输出

```
28964.2857142857

```



---

---
title: "Depression"
layout: "post"
diff: 普及-
pid: CF80B
tag: []
---

# Depression

## 题目描述

在地下室深处躺着数字时钟，显示时间格式为HH：MM。

现在城堡的居民面临着艰巨的任务,**Cogsworth的最初时间是12:00**，他们需要**向右转动**Cogsworth的时针和分针，直到Cogsworth显示正确的时间。**所以，他们需要找到时针和分针顺时针旋转的角度。**

Cogsworth的时针和分针均匀且连续地移动。时针和分针独立移动，所以当转动另一只针时另一只针仍然静止不动。

22：00与10：00旋转角度是相同的

## 输入格式

唯一的输入行包含根据数字时钟的当前时间，格式为HH：MM (00 ≤ HH ≤ 23, 00 ≤ MM ≤ 59)。Cogsworth最初显示12:00。

## 输出格式

输出数字x和y -- 时针和分针的旋转角度(0 ≤ x, y < 360). 答案中的绝对或相对误差不应超过10 e-9

## 样例 #1

### 输入

```
12:00

```

### 输出

```
0 0
```

## 样例 #2

### 输入

```
04:30

```

### 输出

```
135 180
```

## 样例 #3

### 输入

```
08:17

```

### 输出

```
248.5 102
```



---

---
title: "Straight «A»"
layout: "post"
diff: 普及-
pid: CF810A
tag: []
---

# Straight «A»

## 题目描述

Noora is a student of one famous high school. It's her final year in school — she is going to study in university next year. However, she has to get an «A» graduation certificate in order to apply to a prestigious one.

In school, where Noora is studying, teachers are putting down marks to the online class register, which are integers from $ 1 $ to $ k $ . The worst mark is $ 1 $ , the best is $ k $ . Mark that is going to the certificate, is calculated as an average of all the marks, rounded to the closest integer. If several answers are possible, rounding up is produced. For example, $ 7.3 $ is rounded to $ 7 $ , but $ 7.5 $ and $ 7.8784 $ — to $ 8 $ .

For instance, if Noora has marks $ [8,9] $ , then the mark to the certificate is $ 9 $ , because the average is equal to $ 8.5 $ and rounded to $ 9 $ , but if the marks are $ [8,8,9] $ , Noora will have graduation certificate with $ 8 $ .

To graduate with «A» certificate, Noora has to have mark $ k $ .

Noora got $ n $ marks in register this year. However, she is afraid that her marks are not enough to get final mark $ k $ . Noora decided to ask for help in the internet, where hacker Leha immediately responded to her request. He is ready to hack class register for Noora and to add Noora any number of additional marks from $ 1 $ to $ k $ . At the same time, Leha want his hack be unseen to everyone, so he decided to add as less as possible additional marks. Please help Leha to calculate the minimal number of marks he has to add, so that final Noora's mark will become equal to $ k $ .

## 输入格式

The first line contains two integers $ n $ and $ k $ $ (1<=n<=100,1<=k<=100) $ denoting the number of marks, received by Noora and the value of highest possible mark.

The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ $ (1<=a_{i}<=k) $ denoting marks received by Noora before Leha's hack.

## 输出格式

Print a single integer — minimal number of additional marks, that Leha has to add in order to change Noora's final mark to $ k $ .

## 说明/提示

Consider the first example testcase.

Maximal mark is $ 10 $ , Noora received two marks — $ 8 $ and $ 9 $ , so current final mark is $ 9 $ . To fix it, Leha can add marks $ [10,10,10,10] $ ( $ 4 $ marks in total) to the registry, achieving Noora having average mark equal to ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF810A/b75d87f7c46ec7c9f8f2851b79244a71ffa349ba.png). Consequently, new final mark is $ 10 $ . Less number of marks won't fix the situation.

In the second example Leha can add $ [5,5,5] $ to the registry, so that making average mark equal to $ 4.5 $ , which is enough to have $ 5 $ in the certificate.

## 样例 #1

### 输入

```
2 10
8 9

```

### 输出

```
4
```

## 样例 #2

### 输入

```
3 5
4 4 4

```

### 输出

```
3
```



---

---
title: "Vladik and Courtesy"
layout: "post"
diff: 普及-
pid: CF811A
tag: []
---

# Vladik and Courtesy

## 题目描述

在一次正规的比赛后Vladik和Valera分别赢得了$a$ 个糖果和$b$  个糖果。Vladik将$1$ 个他的糖果给Valera。然后Valera将$2$ 个的糖果给Vladik，所以没有人认为他不是那么慷慨大方。接下来Vladik因为同样的原因将$3$ 个糖果给Valera。

更确切的说，每个人给对方比上一次自己收到的更多一个糖果

这种情况直到他们其中有人给不出足够的糖果为止。他们从对方那里得到的糖果不被认为是自己的。你需要直到谁是给不出糖果的人。

## 输入格式

输入仅一行包含两个用空格分开的整数$a,b$  （$1\leq a,b\leq10^9$  ）— 分别为Vladik和Valera的糖果数

## 输出格式

输出一行"Vladik"，如果是Vladik首先给不出糖果，同理或者是"Valera"。

（译者注：强烈建议好好看看说明中的样例解释的图）

Translated by Khassar

## 样例 #1

### 输入

```
1 1

```

### 输出

```
Valera

```

## 样例 #2

### 输入

```
7 6

```

### 输出

```
Vladik

```



---

---
title: "Sagheer and Crossroads"
layout: "post"
diff: 普及-
pid: CF812A
tag: []
---

# Sagheer and Crossroads

## 题目描述

Sagheer is walking in the street when he comes to an intersection of two roads. Each road can be represented as two parts where each part has $ 3 $ lanes getting into the intersection (one for each direction) and $ 3 $ lanes getting out of the intersection, so we have $ 4 $ parts in total. Each part has $ 4 $ lights, one for each lane getting into the intersection ( $ l $ — left, $ s $ — straight, $ r $ — right) and a light $ p $ for a pedestrian crossing.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF812A/a08cde5c54e404c978bae7b092917e8befa50c5b.png)An accident is possible if a car can hit a pedestrian. This can happen if the light of a pedestrian crossing of some part and the light of a lane that can get to or from that same part are green at the same time.

Now, Sagheer is monitoring the configuration of the traffic lights. Your task is to help him detect whether an accident is possible.

## 输入格式

The input consists of four lines with each line describing a road part given in a counter-clockwise order.

Each line contains four integers $ l $ , $ s $ , $ r $ , $ p $ — for the left, straight, right and pedestrian lights, respectively. The possible values are $ 0 $ for red light and $ 1 $ for green light.

## 输出格式

On a single line, print "YES" if an accident is possible, and "NO" otherwise.

## 说明/提示

In the first example, some accidents are possible because cars of part $ 1 $ can hit pedestrians of parts $ 1 $ and $ 4 $ . Also, cars of parts $ 2 $ and $ 3 $ can hit pedestrians of part $ 4 $ .

In the second example, no car can pass the pedestrian crossing of part $ 4 $ which is the only green pedestrian light. So, no accident can occur.

## 样例 #1

### 输入

```
1 0 0 1
0 1 0 0
0 0 1 0
0 0 0 1

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
0 1 1 0
1 0 1 0
1 1 0 0
0 0 0 1

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
1 0 0 0
0 0 0 1
0 0 0 0
1 0 1 0

```

### 输出

```
NO

```



---

---
title: "The Contest"
layout: "post"
diff: 普及-
pid: CF813A
tag: []
---

# The Contest

## 题目描述

Pasha 在打一场比赛，比赛共 $n$ 道题，第 $i$ 道题需要 $a_i$ 长度的时间解决，而已经被解决的题目可以在某一时刻被瞬间全部提交完成。由于评测网站收到的评测信息过多，现在只有 $m$ 个时间段是可提交的，第 $j$ 个时间段的左右端分别是 $l_j$ 和 $r_j$，请求出他能否成功提交并通过所有题目（假定他的做法永远正确）。

## 输入格式

第一行一个整数 $n$（$1\le n\le 1000$），第二行共 $n$ 个正整数，第 $i$ 个数表示 $a_i$（$1\le a_i\le 10^5$）。
第三行一个正整数 $m$（$0\le m\le 1000$），随后的 $m$ 行每行两个整数，其中第 $j$ 行的两个数分别表示 $l_j$ 和 $r_j$（$1\le l_j,r_j\le 10^5$）。

## 输出格式

如果 Pasha 最终可以成功提交并通过所有题目，输出他完成提交所有题目的最短时间，否则输出 $-1$。

## 说明/提示

某次提交并不需要额外花费一个单位时间，所以样例一中的答案即为 $3+4=7$，而不需要加上若干单位时间长。

## 样例 #1

### 输入

```
2
3 4
2
1 4
7 9

```

### 输出

```
7

```

## 样例 #2

### 输入

```
1
5
1
1 4

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
1
5
1
1 5

```

### 输出

```
5

```



---

---
title: "Treasure Hunt"
layout: "post"
diff: 普及-
pid: CF817A
tag: []
---

# Treasure Hunt

## 题目描述

Bill船长收到一个有趣的挑战，有一些陌生人给了他一张地图和一些能够远程传送的药水…………



简单而言，给你移动方式，让你判断能否从(x1,y1)的位置移动到(x2,y2)的位置



而移动方式如下：输入x,y，你一共有四种移动方式可选择

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF817A/5f61670d9b3608116440491f8884c7a41d992eb9.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF817A/fdee4e4bb66766e4b40f483072f3c9b0b1880af7.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF817A/7517913342c0c19a2f0627ccf2eab647a7b547bf.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF817A/324d1b3af2d1a5e602e1cfc99403662780a262b3.png)

## 输入格式

第一行输入x1,y1,x2,y2第二行输入x,y

## 输出格式

如果可以，输出YES，如果不行，输出NO

## 样例 #1

### 输入

```
0 0 0 6
2 3

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
1 1 3 6
1 5

```

### 输出

```
NO

```



---

---
title: "Diplomas and Certificates"
layout: "post"
diff: 普及-
pid: CF818A
tag: []
---

# Diplomas and Certificates

## 题目描述

有n名学生参加了比赛，现在奖项已经公布了下来。   
n名学生中，中有人获得了文凭，也有人获得了证书，但还有人什么都没有。  

其中官方颁奖还有个规则：    
1.证书的数量必须恰好是文凭数量的k倍。   
2.获奖者人数不得超过所有学生人数的一半(即不超过n的一半)。

当然也可能没有赢家。

而题目让你求出最大的赢家数量，以及这种情况下，有文凭的学生人数，有证书的学生人数和没有获奖的学生人数。

## 输入格式

两个整数，n和k，分别是学生人数和证书数量与文凭数量之比。（1<=n,k<=10^12）

## 输出格式

三个数，有文凭的学生的数量，有证书的学生的数量和没有中奖的学生的数量。

**提示：可能没有赢家**。

## 样例 #1

### 输入

```
18 2

```

### 输出

```
3 6 9

```

## 样例 #2

### 输入

```
9 10

```

### 输出

```
0 0 9

```

## 样例 #3

### 输入

```
1000000000000 5

```

### 输出

```
83333333333 416666666665 500000000002

```

## 样例 #4

### 输入

```
1000000000000 499999999999

```

### 输出

```
1 499999999999 500000000000

```



---

---
title: "Plug-in"
layout: "post"
diff: 普及-
pid: CF81A
tag: []
---

# Plug-in

## 题目描述

Polycarp thinks about the meaning of life very often. He does this constantly, even when typing in the editor. Every time he starts brooding he can no longer fully concentrate and repeatedly presses the keys that need to be pressed only once. For example, instead of the phrase "how are you" he can type "hhoow aaaare yyoouu".

Polycarp decided to automate the process of correcting such errors. He decided to write a plug-in to the text editor that will remove pairs of identical consecutive letters (if there are any in the text). Of course, this is not exactly what Polycarp needs, but he's got to start from something!

Help Polycarp and write the main plug-in module. Your program should remove from a string all pairs of identical letters, which are consecutive. If after the removal there appear new pairs, the program should remove them as well. Technically, its work should be equivalent to the following: while the string contains a pair of consecutive identical letters, the pair should be deleted. Note that deleting of the consecutive identical letters can be done in any order, as any order leads to the same result.

## 输入格式

The input data consists of a single line to be processed. The length of the line is from $ 1 $ to $ 2·10^{5} $ characters inclusive. The string contains only lowercase Latin letters.

## 输出格式

Print the given string after it is processed. It is guaranteed that the result will contain at least one character.

## 样例 #1

### 输入

```
hhoowaaaareyyoouu

```

### 输出

```
wre
```

## 样例 #2

### 输入

```
reallazy

```

### 输出

```
rezy
```

## 样例 #3

### 输入

```
abacabaabacabaa

```

### 输出

```
a
```



---

---
title: "Sequence Formatting"
layout: "post"
diff: 普及-
pid: CF81B
tag: []
---

# Sequence Formatting

## 题目描述

Polycarp 是个非常严谨的人，不像他的同班同学那样，他甚至仔细地键入数字序列。

如果他看到一个序列在逗号后面没有空格，或是一行有多个空格，或者当其他东西看起来不严谨时，他会立刻纠正它。

例如，如“1,2，3，…，10”所写的数字序列将被修正为“1, 2, 3，…，10”。

在这个任务中，你得到一个字符串 s ，

s 由术语的连词构成，每一个词可以是：



	1.任意长度的正整数（不允许前导零），

	2. 逗号符号（“，”），

	3. 空格符号（“ ”），

	4. “三点”（“…”），即一个接一个地写三个点，也称为“暂停点”。

Polycarp想添加并且删除字符串s中多余的空格来满足以下要求：



	1.每个逗号后面只有一个空格（若逗号是字符串中的最后一个字符，则此规则不适用于它）；

	2.每个“三点”前正好有一个空格（若三点在字符串的开头，则此规则不适用于它）；

	3.如果两个连续的数字仅由空格分隔，那么就应该只剩下一个空格，不应该有多余的空格。

现在请你编写一个程序帮助Polycarp完成对字符串s的操作。

## 输入格式

输入数据包含一个字符串s，它由最少1个字符，最多255个字符组成。

	s不会以一个空格开始或结束。

	它的内容与上面给出的描述相匹配。

## 输出格式

处理后的s。你的程序的输出应该和预期的答案完全一样。

	允许输出换行输出s，也可以不换。

## 样例 #1

### 输入

```
1,2 ,3,...,     10

```

### 输出

```
1, 2, 3, ..., 10

```

## 样例 #2

### 输入

```
1,,,4...5......6

```

### 输出

```
1, , , 4 ...5 ... ...6

```

## 样例 #3

### 输入

```
...,1,2,3,...

```

### 输出

```
..., 1, 2, 3, ...

```



---

---
title: "Mister B and Book Reading"
layout: "post"
diff: 普及-
pid: CF820A
tag: []
---

# Mister B and Book Reading

## 题目描述

Mister B once received a gift: it was a book about aliens, which he started read immediately. This book had $ c $ pages.

At first day Mister B read $ v_{0} $ pages, but after that he started to speed up. Every day, starting from the second, he read $ a $ pages more than on the previous day (at first day he read $ v_{0} $ pages, at second — $ v_{0}+a $ pages, at third — $ v_{0}+2a $ pages, and so on). But Mister B is just a human, so he physically wasn't able to read more than $ v_{1} $ pages per day.

Also, to refresh his memory, every day, starting from the second, Mister B had to reread last $ l $ pages he read on the previous day. Mister B finished the book when he read the last page for the first time.

Help Mister B to calculate how many days he needed to finish the book.

## 输入格式

First and only line contains five space-separated integers: $ c $ , $ v_{0} $ , $ v_{1} $ , $ a $ and $ l $ ( $ 1<=c<=1000 $ , $ 0<=l&lt;v_{0}<=v_{1}<=1000 $ , $ 0<=a<=1000 $ ) — the length of the book in pages, the initial reading speed, the maximum reading speed, the acceleration in reading speed and the number of pages for rereading.

## 输出格式

Print one integer — the number of days Mister B needed to finish the book.

## 说明/提示

In the first sample test the book contains $ 5 $ pages, so Mister B read it right at the first day.

In the second sample test at first day Mister B read pages number $ 1-4 $ , at second day — $ 4-11 $ , at third day — $ 11-12 $ and finished the book.

In third sample test every day Mister B read $ 1 $ page of the book, so he finished in 15 days.

## 样例 #1

### 输入

```
5 5 10 5 4

```

### 输出

```
1

```

## 样例 #2

### 输入

```
12 4 12 4 1

```

### 输出

```
3

```

## 样例 #3

### 输入

```
15 1 100 0 0

```

### 输出

```
15

```



---

---
title: "Binary Protocol"
layout: "post"
diff: 普及-
pid: CF825A
tag: []
---

# Binary Protocol

## 题目描述

Polycarp has just invented a new binary protocol for data transmission. He is encoding positive integer decimal number to binary string using following algorithm:

- Each digit is represented with number of '1' characters equal to the value of that digit (for 0 it is zero ones).
- Digits are written one by one in order corresponding to number and separated by single '0' character.

Though Polycarp learnt how to encode the numbers, he has no idea how to decode them back. Help him calculate the decoded number.

## 输入格式

The first line contains one integer number $ n $ ( $ 1<=n<=89 $ ) — length of the string $ s $ .

The second line contains string $ s $ — sequence of '0' and '1' characters, number in its encoded format. It is guaranteed that the number corresponding to the string is positive and doesn't exceed $ 10^{9} $ . The string always starts with '1'.

## 输出格式

Print the decoded number.

## 样例 #1

### 输入

```
3
111

```

### 输出

```
3

```

## 样例 #2

### 输入

```
9
110011101

```

### 输出

```
2031

```



---

---
title: "Five-In-a-Row"
layout: "post"
diff: 普及-
pid: CF825B
tag: []
---

# Five-In-a-Row

## 题目描述

Alice and Bob play 5-in-a-row game. They have a playing field of size $ 10×10 $ . In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts.

In current match they have made some turns and now it's Alice's turn. She wonders if she can put cross in such empty cell that she wins immediately.

Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.

## 输入格式

You are given matrix $ 10×10 $ (10 lines of 10 characters each) with capital Latin letters 'X' being a cross, letters 'O' being a nought and '.' being an empty cell. The number of 'X' cells is equal to the number of 'O' cells and there is at least one of each type. There is at least one empty cell.

It is guaranteed that in the current arrangement nobody has still won.

## 输出格式

Print 'YES' if it's possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print 'NO'.

## 样例 #1

### 输入

```
XX.XX.....
.....OOOO.
..........
..........
..........
..........
..........
..........
..........
..........

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
XXOXX.....
OO.O......
..........
..........
..........
..........
..........
..........
..........
..........

```

### 输出

```
NO

```



---

---
title: "Double Cola"
layout: "post"
diff: 普及-
pid: CF82A
tag: []
---

# Double Cola

## 题目描述

肖尔顿，莱奥纳多，佩妮，拉杰什和霍华德正在在卖“分裂可乐”的自动贩卖机那里排队。

队里第一个人（肖尔顿）会买一瓶分裂可乐，喝完以后他就会分裂成两个人并站到队尾。

下一个人（莱奥纳多）也会买一瓶分裂可乐，喝完后也会和刚才的肖尔顿一样分裂成两个人并站到队尾。

这个过程可以一直持续下去。~~（永动机）~~

举个例子，当佩妮喝下可乐（他之前的人也喝完了）后队列会变成这样：拉杰什，霍华德，肖尔顿，肖尔顿，莱奥纳多，莱奥纳多，佩妮，佩妮。

请您编写一个程序来输出喝下第$ n $罐分裂可乐的人。

__注意：__一开始的队列总会是这样的：肖尔顿，莱奥纳多，佩妮，拉杰什，霍华德。第一个去买可乐的人总会是肖尔顿。

## 输入格式

输入包含一个整数 $ n (1 <= n <= 10^9) $

## 输出格式

输出一行，一个字符串，代表喝下第$ n $瓶分裂可乐的人的名字，只可能包含五种答案：分别是 "Sheldon", "Leonard", "Penny", "Rajesh", "Howard"。

## 样例 #1

### 输入

```
1

```

### 输出

```
Sheldon

```

## 样例 #2

### 输入

```
6

```

### 输出

```
Sheldon

```

## 样例 #3

### 输入

```
1802

```

### 输出

```
Penny

```



---

---
title: "Keyboard Layouts"
layout: "post"
diff: 普及-
pid: CF831B
tag: []
---

# Keyboard Layouts

## 题目描述

There are two popular keyboard layouts in Berland, they differ only in letters positions. All the other keys are the same. In Berland they use alphabet with $ 26 $ letters which coincides with English alphabet.

You are given two strings consisting of $ 26 $ distinct letters each: all keys of the first and the second layouts in the same order.

You are also given some text consisting of small and capital English letters and digits. It is known that it was typed in the first layout, but the writer intended to type it in the second layout. Print the text if the same keys were pressed in the second layout.

Since all keys but letters are the same in both layouts, the capitalization of the letters should remain the same, as well as all other characters.

## 输入格式

The first line contains a string of length $ 26 $ consisting of distinct lowercase English letters. This is the first layout.

The second line contains a string of length $ 26 $ consisting of distinct lowercase English letters. This is the second layout.

The third line contains a non-empty string $ s $ consisting of lowercase and uppercase English letters and digits. This is the text typed in the first layout. The length of $ s $ does not exceed $ 1000 $ .

## 输出格式

Print the text if the same keys were pressed in the second layout.

## 样例 #1

### 输入

```
qwertyuiopasdfghjklzxcvbnm
veamhjsgqocnrbfxdtwkylupzi
TwccpQZAvb2017

```

### 输出

```
HelloVKCup2017

```

## 样例 #2

### 输入

```
mnbvcxzlkjhgfdsapoiuytrewq
asdfghjklqwertyuiopzxcvbnm
7abaCABAABAcaba7

```

### 输出

```
7uduGUDUUDUgudu7

```



---

---
title: "The Festive Evening"
layout: "post"
diff: 普及-
pid: CF834B
tag: []
---

# The Festive Evening

## 题目描述

七月底，果冻城堡举行节日晚会！来自王国各地的客人聚集在这里讨论糖果业的新趋势。然而，这里讨论的一些事情不应该向公众披露：这些信息可能会在斯威特兰王国引起不和，以防落入坏人之手。所以有必要不让任何不速之客进来。

果冻城堡有26个入口，上面有从A到Z的大写英文字母。由于安全措施，每个客人都被指定了一个入口，他应该通过这个入口进入城堡。每个入口的门在第一个客人到达前打开，在最后一个客人到达后关闭，最后一个客人应该通过这个入口进入城堡。两位客人不能同时进入城堡。

为了保护入口免受可能的入侵，应为其分配一个糖果警卫。城堡里有k这样的守卫，所以如果打开的门超过k，其中一个就会无人看守！注意一个警卫在他被指派的门关上之前不能离开他的岗位。

Slastyona怀疑晚上可能有不速之客。她知道被邀请的客人进入城堡的顺序，想让你帮她检查一下是否有超过千扇门被打开的时刻。

## 输入格式

第一个行中给出了两个整数：来宾数n和守卫数k（1<=n<=10^6,1<=k<=26 ）。

在第二行中， 

给定n个大写英文字母 s1,s2…sn ，其中s
[i]

是第i位客人使用的入口。

## 输出格式

如果在一段时间内至少有一扇门无人看守，则输出“YES”，否则输出“NO”。

## 样例 #1

### 输入

```
5 1
AABBB

```

### 输出

```
NO

```

## 样例 #2

### 输入

```
5 1
ABABB

```

### 输出

```
YES

```



---

---
title: "Flag of Berland"
layout: "post"
diff: 普及-
pid: CF837B
tag: []
---

# Flag of Berland

## 题目描述

Berland之旗是满足以下条件的 $n \times m$ 矩形区域：

- 旗中包含三种颜色，相应地以字母“R”, “G”和“B”表示。

- 旗中包含三个“长条”，他们的长度和宽度相等（长条1的长度等于长条2的长度，也等于长条3的长度，宽度类似），并且互相平行，同时还平行于旗子的边缘。每个“长条”仅有一种颜色。

- 每个颜色仅能在一个“长条”中出现。 

现在给定由“R”, “G”和“B”构成的 $n \times m$ 矩形区域。请判断它是否是一个正确的Berland之旗，是则输出 "YES"，否则输出"NO"。

## 输入格式

第一行包含两个整数 $n$ 和 $m$ （ $1 \le n, m \le 100 $ ）表示区域的大小。

接下来的 $n$ 行表示给定的矩形区域。

## 输出格式

如果给定的区域是一个正确的Berland之旗则输出"YES"（不含引号），否则输出"NO"（不含引号）。

## 说明/提示

第三个样例中的区域不包含平行的“长条”。

第四个样例中虽然“长条”间互相平行，且都平行于边缘，但他们高度不同——2，1和1。

## 样例 #1

### 输入

```
6 5
RRRRR
RRRRR
BBBBB
BBBBB
GGGGG
GGGGG

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
4 3
BRG
BRG
BRG
BRG

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
6 7
RRRGGGG
RRRGGGG
RRRGGGG
RRRBBBB
RRRBBBB
RRRBBBB

```

### 输出

```
NO

```

## 样例 #4

### 输入

```
4 4
RRRR
RRRR
BBBB
GGGG

```

### 输出

```
NO

```



---

---
title: "Magical Array"
layout: "post"
diff: 普及-
pid: CF83A
tag: []
---

# Magical Array

## 题目描述

Valery is very interested in magic. Magic attracts him so much that he sees it everywhere. He explains any strange and weird phenomenon through intervention of supernatural forces. But who would have thought that even in a regular array of numbers Valera manages to see something beautiful and magical.

Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written. He immediately thought that the numbers in this array were not random. As a result of extensive research Valera worked out a wonderful property that a magical array should have: an array is defined as magic if its minimum and maximum coincide.

He decided to share this outstanding discovery with you, but he asks you for help in return. Despite the tremendous intelligence and wit, Valera counts very badly and so you will have to complete his work. All you have to do is count the number of magical subarrays of the original array of numbers, written on the parchment. Subarray is defined as non-empty sequence of consecutive elements.

## 输入格式

The first line of the input data contains an integer $ n $ ( $ 1<=n<=10^{5} $ ). The second line contains an array of original integers $ a_{1},a_{2},...,a_{n} $ ( $ -10^{9}<=a_{i}<=10^{9} $ ).

## 输出格式

Print on the single line the answer to the problem: the amount of subarrays, which are magical.

Please do not use the %lld specificator to read or write 64-bit numbers in C++. It is recommended to use cin, cout streams (you can also use the %I64d specificator).

## 说明/提示

Notes to sample tests:

Magical subarrays are shown with pairs of indices \[a;b\] of the beginning and the end.

In the first sample: \[1;1\], \[2;2\], \[3;3\], \[4;4\], \[2;3\].

In the second sample: \[1;1\], \[2;2\], \[3;3\], \[4;4\], \[5;5\], \[1;2\], \[2;3\], \[1;3\].

## 样例 #1

### 输入

```
4
2 1 1 4

```

### 输出

```
5

```

## 样例 #2

### 输入

```
5
-2 -2 -2 0 1

```

### 输出

```
8

```



---

---
title: "Godsend"
layout: "post"
diff: 普及-
pid: CF841B
tag: []
---

# Godsend

## 题目描述

### 翻译

有两个人，他们面对一个数组，轮流取数组里的数， 第一个取的人要在这个数组里选择一个长度非零的子段，且其和为奇数，这个人要把他选定的子段删掉，并把原子段黏合。而第二个人的操作跟第一个人类似，只是和要是偶数。胜负的判定就是谁最先没法行动谁就输。

## 输入格式

第一行是一个数n，表示数组里的数的个数 第二行是n个数，表示数组里的数

## 输出格式

第一个人赢输出“First”，否则输出“Second”

Translated by @bluewzl

## 样例 #1

### 输入

```
4
1 3 2 3

```

### 输出

```
First

```

## 样例 #2

### 输入

```
2
2 2

```

### 输出

```
Second

```



---

---
title: "Gleb And Pizza"
layout: "post"
diff: 普及-
pid: CF842B
tag: []
---

# Gleb And Pizza

## 题目描述

### 题目大意

Gleb 点了披萨，他发现有几片香肠在外皮上，但他讨厌披萨的外皮。

披萨一个半径为  $r$ 的圆，圆心位于原点，披萨中间部分是半径为  $r-d$ 的圆，圆心也在原点。外皮部分就是外面一圈宽为  $d$ 的环。

香肠片也是圆的，对于第  $i$ 片香肠，他的半径为  $r_i$ ，圆心位于  $(x_i,y_i)$

现在求有多少个香肠片整个都在外皮上。

## 输入格式

第一行给定两个数  $r$ 和  $d$ 。

第二行一个数  $n$ 表示香肠片数。

接下来有  $n$ 行，每行有  $3$ 个数  $x_i,y_i,r_i$ ，表示第  $i$ 个香肠片的相关信息。

## 输出格式

一行，表示答案。

translated by Rainy7

## 样例 #1

### 输入

```
8 4
7
7 8 1
-7 3 2
0 2 1
0 -2 2
-3 -3 1
0 6 2
5 3 1

```

### 输出

```
2

```

## 样例 #2

### 输入

```
10 8
4
0 0 9
0 0 10
1 0 1
1 0 2

```

### 输出

```
0

```



---

---
title: "Diversity"
layout: "post"
diff: 普及-
pid: CF844A
tag: []
---

# Diversity

## 题目描述

Calculate the minimum number of characters you need to change in the string $ s $ , so that it contains at least $ k $ different letters, or print that it is impossible.

String $ s $ consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.

## 输入格式

First line of input contains string $ s $ , consisting only of lowercase Latin letters ( $ 1<=|s|<=1000 $ , $ |s| $ denotes the length of $ s $ ).

Second line of input contains integer $ k $ ( $ 1<=k<=26 $ ).

## 输出格式

Print single line with a minimum number of necessary changes, or the word «impossible» (without quotes) if it is impossible.

## 说明/提示

In the first test case string contains $ 6 $ different letters, so we don't need to change anything.

In the second test case string contains $ 4 $ different letters: $ {'a','h','o','y'} $ . To get $ 5 $ different letters it is necessary to change one occurrence of $ 'o' $ to some letter, which doesn't occur in the string, for example, $ {'b'} $ .

In the third test case, it is impossible to make $ 7 $ different letters because the length of the string is $ 6 $ .

## 样例 #1

### 输入

```
yandex
6

```

### 输出

```
0

```

## 样例 #2

### 输入

```
yahoo
5

```

### 输出

```
1

```

## 样例 #3

### 输入

```
google
7

```

### 输出

```
impossible

```



---

---
title: "Luba And The Ticket"
layout: "post"
diff: 普及-
pid: CF845B
tag: []
---

# Luba And The Ticket

## 题目描述

Luba 有一张票，上有六个数字。每一次操作时，她可以将其中一个数字改为任意一个数字。现在她希望知道最少需要操作多少次才可以将这张票上的数字改为一个幸运数字。 
当一个数的前三位之和与其后三位之和相等时，这便是一个幸运数字

## 输入格式

输入一个六位的字符串（字符串中的每一个字符均为0~9中的一个数字）作为Luba票上的数字。  
 **这组数字可以以0开头**

## 输出格式

一个数字，即为使该票号成为幸运数字的最少操作次数

## 说明/提示

样例1给出的数字本身即为幸运数字，因此操作数为 0 次  

样例 2 中仅需将 4、5 替换成 0 即可，很容易便看出最少需要操作 2 次  

样例 3 中仅需将任意一个 0 替换成 3，最少操作次数便是 1  

*以上即为题目简述，有不足之处请大家指出*

## 样例 #1

### 输入

```
000000

```

### 输出

```
0

```

## 样例 #2

### 输入

```
123456

```

### 输出

```
2

```

## 样例 #3

### 输入

```
111000

```

### 输出

```
1

```



---

---
title: "Weather Tomorrow"
layout: "post"
diff: 普及-
pid: CF847M
tag: []
---

# Weather Tomorrow

## 题目描述

`Vasya`想出了一个他自己的天气预报方法。他知道最近$n$天每天的平均气温。假设每天的平均气温是个整数。

`Vasya`相信这$n$天每天的平均气温构成一个等差数列，在这个数列中，第一项是第一天的平均气温，第二项是第二天的平均气温，以此类推。那么第$n+1$天（也就是明天）的平均气温将是这个数列的第$n+1$项。如果这个数列前$n$项并没有他所想的那样是个等差数列，那么按`Vasya`的算法，第$n+1$天的气温将等于第$n$天的气温。

你需要根据`Vasya`的算法求出明天的平均气温。

## 样例 #1

### 输入

```
5
10 5 0 -5 -10

```

### 输出

```
-15

```

## 样例 #2

### 输入

```
4
1 1 1 1

```

### 输出

```
1

```

## 样例 #3

### 输入

```
3
5 1 -5

```

### 输出

```
-5

```

## 样例 #4

### 输入

```
2
900 1000

```

### 输出

```
1100

```



---

---
title: "Odds and Ends"
layout: "post"
diff: 普及-
pid: CF849A
tag: []
---

# Odds and Ends

## 题目描述

Where do odds begin, and where do they end? Where does hope emerge, and will they ever break?

Given an integer sequence $ a_{1},a_{2},...,a_{n} $ of length $ n $ . Decide whether it is possible to divide it into an odd number of non-empty subsegments, the each of which has an odd length and begins and ends with odd numbers.

A subsegment is a contiguous slice of the whole sequence. For example, $ {3,4,5} $ and $ {1} $ are subsegments of sequence $ {1,2,3,4,5,6} $ , while $ {1,2,4} $ and $ {7} $ are not.

## 输入格式

The first line of input contains a non-negative integer $ n $ ( $ 1<=n<=100 $ ) — the length of the sequence.

The second line contains $ n $ space-separated non-negative integers $ a_{1},a_{2},...,a_{n} $ ( $ 0<=a_{i}<=100 $ ) — the elements of the sequence.

## 输出格式

Output "Yes" if it's possible to fulfill the requirements, and "No" otherwise.

You can output each letter in any case (upper or lower).

## 说明/提示

In the first example, divide the sequence into $ 1 $ subsegment: $ {1,3,5} $ and the requirements will be met.

In the second example, divide the sequence into $ 3 $ subsegments: $ {1,0,1} $ , $ {5} $ , $ {1} $ .

In the third example, one of the subsegments must start with $ 4 $ which is an even number, thus the requirements cannot be met.

In the fourth example, the sequence can be divided into $ 2 $ subsegments: $ {3,9,9} $ , $ {3} $ , but this is not a valid solution because $ 2 $ is an even number.

## 样例 #1

### 输入

```
3
1 3 5

```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
5
1 0 1 5 1

```

### 输出

```
Yes

```

## 样例 #3

### 输入

```
3
4 3 1

```

### 输出

```
No

```

## 样例 #4

### 输入

```
4
3 9 9 3

```

### 输出

```
No

```



---

---
title: "Arpa and an exam about geometry"
layout: "post"
diff: 普及-
pid: CF851B
tag: []
---

# Arpa and an exam about geometry

## 题目描述

题意

Arpa正在参加一场几何学考试。这是这场考试的最后一题。
给你三个点。让你找一个点和一个角度使得按这个点旋转这个角度后，a的新位置与b的原位置重合，b的新位置与c的原位置重合。
Arpa怀疑这个问题是否有解（如果存在一个点和一个角度满足条件）。请帮助Arpa确定这个问题是否有解决方案。

## 输入格式

单独一行包含六个整数$a_{x},a_{y},b_{x},b_{y},c_{x},c_{y}$ 。保证给出的点是不同的。

## 输出格式

如果这个问题有解决方案，输出 "Yes"，否则，输出 "No" 。

感谢@Fowany 提供的翻译

## 样例 #1

### 输入

```
0 1 1 1 1 0

```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
1 1 0 0 1000 1000

```

### 输出

```
No

```



---

---
title: "Fraction"
layout: "post"
diff: 普及-
pid: CF854A
tag: []
---

# Fraction

## 题目描述

Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF854A/9f8335062cbc9ed9ecb9607f5d06d53170cb1e1a.png) is called proper iff its numerator is smaller than its denominator ( $ a<b $ ) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except $ 1 $ ).

During his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button ( $ + $ ) instead of division button ( $ ÷ $ ) and got sum of numerator and denominator that was equal to $ n $ instead of the expected decimal notation.

Petya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF854A/9f8335062cbc9ed9ecb9607f5d06d53170cb1e1a.png) such that sum of its numerator and denominator equals $ n $ . Help Petya deal with this problem.

## 输入格式

In the only line of input there is an integer $ n $ ( $ 3<=n<=1000 $ ), the sum of numerator and denominator of the fraction.

## 输出格式

Output two space-separated positive integers $ a $ and $ b $ , numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.

## 样例 #1

### 输入

```
3

```

### 输出

```
1 2

```

## 样例 #2

### 输入

```
4

```

### 输出

```
1 3

```

## 样例 #3

### 输入

```
12

```

### 输出

```
5 7

```



---

---
title: "Maxim Buys an Apartment"
layout: "post"
diff: 普及-
pid: CF854B
tag: []
---

# Maxim Buys an Apartment

## 题目描述

Maxim想在大都会的莱恩大道上买一座新的公寓。这幢楼房共有 n 座公寓，从 1 到 n 编号排列在一个数列中。两座相邻公寓的编号相差为 1。有一些公寓已经被售出了，另外的一些是待售的。

Maxim时常拜访他的邻居，因此如果有一座待售公寓，其相邻公寓中至少有一座是已售出的，那么这座公寓很适合Maxim。Maxim已经知道了有 k 座公寓已被售出，但是他还不知道这些已售出公寓的编号是多少。

计算出适合Maxim的公寓数可能的最小值及最大值。

## 输入格式

输入数据只包括两个整数 n，k(1 <= n <= 10^9，0 <= k <= n)。

## 输出格式

输出可能的最小值及最大值。

## 说明/提示

在样例中，如果编号为 1，2，3 的公寓被售出了，那么只有编号为 4 的公寓适合Maxim。如果编号为 1，3，5 的公寓被售出了，那么编号为 2，4，6 的公寓都是适合Maxim的。

Translated by @radish布団

## 样例 #1

### 输入

```
6 3

```

### 输出

```
1 3

```



---

---
title: "Lazy Security Guard"
layout: "post"
diff: 普及-
pid: CF859B
tag: []
---

# Lazy Security Guard

## 题目描述

Your security guard friend recently got a new job at a new security company. The company requires him to patrol an area of the city encompassing exactly $ N $ city blocks, but they let him choose which blocks. That is, your friend must walk the perimeter of a region whose area is exactly $ N $ blocks. Your friend is quite lazy and would like your help to find the shortest possible route that meets the requirements. The city is laid out in a square grid pattern, and is large enough that for the sake of the problem it can be considered infinite.

## 输入格式

Input will consist of a single integer $ N $ ( $ 1<=N<=10^{6} $ ), the number of city blocks that must be enclosed by the route.

## 输出格式

Print the minimum perimeter that can be achieved.

## 说明/提示

Here are some possible shapes for the examples:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF859B/5e7ebb69b8e66ba58196d654a3513a2ca92c6a2a.png)

## 样例 #1

### 输入

```
4

```

### 输出

```
8

```

## 样例 #2

### 输入

```
11

```

### 输出

```
14

```

## 样例 #3

### 输入

```
22

```

### 输出

```
20

```



---

---
title: "Embassy Queue"
layout: "post"
diff: 普及-
pid: CF85B
tag: []
---

# Embassy Queue

## 题目描述

In an embassy of a well-known kingdom an electronic queue is organised. Every person who comes to the embassy, needs to make the following three actions: show the ID, pay money to the cashier and be fingerprinted. Besides, the actions should be performed in the given order.

For each action several separate windows are singled out: $ k_{1} $ separate windows for the first action (the first type windows), $ k_{2} $ windows for the second one (the second type windows), and $ k_{3} $ for the third one (the third type windows). The service time for one person in any of the first type window equals to $ t_{1} $ . Similarly, it takes $ t_{2} $ time to serve a person in any of the second type windows. And it takes $ t_{3} $ to serve one person in any of the third type windows. Thus, the service time depends only on the window type and is independent from the person who is applying for visa.

At some moment $ n $ people come to the embassy, the $ i $ -th person comes at the moment of time $ c_{i} $ . The person is registered under some number. After that he sits in the hall and waits for his number to be shown on a special board. Besides the person's number the board shows the number of the window where one should go and the person goes there immediately. Let's consider that the time needed to approach the window is negligible. The table can show information for no more than one person at a time. The electronic queue works so as to immediately start working with the person who has approached the window, as there are no other people in front of the window.

The Client Service Quality inspectors noticed that several people spend too much time in the embassy (this is particularly tiresome as the embassy has no mobile phone reception and 3G). It was decided to organise the system so that the largest time a person spends in the embassy were minimum. Help the inspectors organise the queue. Consider that all actions except for being served in at the window, happen instantly.

## 输入格式

The first line contains three space-separated integers $ k_{1} $ , $ k_{2} $ , $ k_{3} $ ( $ 1<=k_{i}<=10^{9} $ ), they are the number of windows of the first, second and third type correspondingly.

The second line contains three space-separated integers $ t_{1} $ , $ t_{2} $ , $ t_{3} $ ( $ 1<=t_{i}<=10^{5} $ ), they are the periods of time needed to serve one person in the window of the first, second and third type correspondingly.

The third line contains an integer $ n $ ( $ 1<=n<=10^{5} $ ), it is the number of people.

The fourth line contains $ n $ space-separated integers $ c_{i} $ ( $ 1<=c_{i}<=10^{9} $ ) in the non-decreasing order; $ c_{i} $ is the time when the person number $ i $ comes to the embassy.

## 输出格式

Print the single number, the maximum time a person will spend in the embassy if the queue is organized optimally.

Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams (also you may use the %I64d specificator).

## 说明/提示

In the first test 5 people come simultaneously at the moment of time equal to 1. There is one window of every type, it takes 1 unit of time to be served at each window. That's why the maximal time a person spends in the embassy is the time needed to be served at the windows (3 units of time) plus the time the last person who comes to the first window waits (4 units of time).

 Windows in the second test work like this:

The first window of the first type: $ [1,6) $ — the first person, $ [6,11) $ — third person, $ [11,16) $ — fifth person

The second window of the first type: $ [2,7) $ — the second person,  $ [7,12) $  — the fourth person

The only second type window: $ [6,7) $ — first, $ [7,8) $ — second, $ [11,12) $ — third, $ [12,13) $ — fourth, $ [16,17) $ — fifth

The only third type window: $ [7,8) $ — first, $ [8,9) $ — second, $ [12,13) $ — third, $ [13,14) $ — fourth, $ [17,18) $ — fifth

We can see that it takes most time to serve the fifth person.

## 样例 #1

### 输入

```
1 1 1
1 1 1
5
1 1 1 1 1

```

### 输出

```
7

```

## 样例 #2

### 输入

```
2 1 1
5 1 1
5
1 2 3 3 5

```

### 输出

```
13

```



---

---
title: "Mahmoud and Ehab and the MEX"
layout: "post"
diff: 普及-
pid: CF862A
tag: []
---

# Mahmoud and Ehab and the MEX

## 题目描述

**题意描述**

在一片邪恶之地，邪恶博士绑架了Mahmoud和Ehab，因为他们在邪恶信息学奥林匹克竞赛(Evil Olympiad in Informatics,EOI)中的突出表现。邪恶博士又决定给他们一些问题让他们回答。问题如下：

邪恶博士对集合很感兴趣。他有一个包含n个整数的集合。邪恶博士认为，如果一个集合的Mex值恰好为x，那么这个集合就是邪恶的。定义Mex值为一个集合中没有出现的最小非负整数。举个例子，Mex（{0,2,4}） = 1，Mex（{1,2,3}） = 0 。

邪恶博士想让他的集合变得邪恶，因此他会执行一些操作。在每个操作中他可能会加入一个非负整数，也可能删去一个数。请问最少需要多少次操作才能让邪恶博士的集合变得邪恶？

## 输入格式

第一行，包括两个整数n和x，意义如上述。1<=n<=100,1<=x<=100.

第二行，包括n个不同的非负整数，且每个数均不超过100，表示一开始集合中的元素。

## 输出格式

仅输出一行，表示邪恶博士最少需要执行多少次操作。

## 样例 #1

### 输入

```
5 3
0 4 5 6 7

```

### 输出

```
2

```

## 样例 #2

### 输入

```
1 0
0

```

### 输出

```
1

```

## 样例 #3

### 输入

```
5 0
1 2 3 4 5

```

### 输出

```
0

```



---

---
title: "Kayaking"
layout: "post"
diff: 普及-
pid: CF863B
tag: []
---

# Kayaking

## 题目描述

Vadim真的很喜欢旅行。（所以）当他听说在他的小镇附近有一个皮划艇大赛的时候，是十分激动的，所以，他参加了这场皮划艇的聚会。

现在聚会已经准备好开始了他们的皮划艇之旅了，但首先，他们需要选择皮划艇。这有 $2n$ 个人（包括Vadim），并且他们有$n-1$ 个双人皮划艇（当然，每个可以坐两个人）和$2$ 个单人皮划艇。第$i$ 个人的体重是$w_i$ ，并且体重在皮划艇中是一件重要的事——如果坐在同一个双人皮划艇上的两人的体重相差太多，皮划艇就会倾覆。当然，人们想要分配他们的座位来最小化使皮划艇倾覆的可能性。

事实上，单人皮划艇的不稳定性总是$0$ ，并且双人皮划艇的不稳定性为在皮划艇上两人体重的差的绝对值。在整场旅行中的不稳定值就是所有皮划艇不稳定值的和。

帮助这个聚会找出最小的总不稳定值！

## 输入格式

第一行包含一个整数$n$ （$2\leq n\leq 50$ ）
，第二行包含$2n$ 个整数$w_1,w_2,\dots,w_{2n}$ ，其中$w_i$ 表示第$i$ 个的体重（$1\leq w_i\leq1000$ ）

## 输出格式

输出一个可能的最小不稳定值

感谢@Khassar 提供的翻译

## 样例 #1

### 输入

```
2
1 2 3 4

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4
1 3 4 6 3 4 100 200

```

### 输出

```
5

```



---

---
title: "Bus"
layout: "post"
diff: 普及-
pid: CF864C
tag: []
---

# Bus

## 题目描述

A bus moves along the coordinate line $ Ox $ from the point $ x=0 $ to the point $ x=a $ . After starting from the point $ x=0 $ , it reaches the point $ x=a $ , immediately turns back and then moves to the point $ x=0 $ . After returning to the point $ x=0 $ it immediately goes back to the point $ x=a $ and so on. Thus, the bus moves from $ x=0 $ to $ x=a $ and back. Moving from the point $ x=0 $ to $ x=a $ or from the point $ x=a $ to $ x=0 $ is called a bus journey. In total, the bus must make $ k $ journeys.

The petrol tank of the bus can hold $ b $ liters of gasoline. To pass a single unit of distance the bus needs to spend exactly one liter of gasoline. The bus starts its first journey with a full petrol tank.

There is a gas station in point $ x=f $ . This point is between points $ x=0 $ and $ x=a $ . There are no other gas stations on the bus route. While passing by a gas station in either direction the bus can stop and completely refuel its tank. Thus, after stopping to refuel the tank will contain $ b $ liters of gasoline.

What is the minimum number of times the bus needs to refuel at the point $ x=f $ to make $ k $ journeys? The first journey starts in the point $ x=0 $ .

## 输入格式

The first line contains four integers $ a $ , $ b $ , $ f $ , $ k $ ( $ 0<f<a<=10^{6} $ , $ 1<=b<=10^{9} $ , $ 1<=k<=10^{4} $ ) — the endpoint of the first bus journey, the capacity of the fuel tank of the bus, the point where the gas station is located, and the required number of journeys.

## 输出格式

Print the minimum number of times the bus needs to refuel to make $ k $ journeys. If it is impossible for the bus to make $ k $ journeys, print -1.

## 说明/提示

In the first example the bus needs to refuel during each journey.

In the second example the bus can pass $ 10 $ units of distance without refueling. So the bus makes the whole first journey, passes $ 4 $ units of the distance of the second journey and arrives at the point with the gas station. Then it can refuel its tank, finish the second journey and pass $ 2 $ units of distance from the third journey. In this case, it will again arrive at the point with the gas station. Further, he can refill the tank up to $ 10 $ liters to finish the third journey and ride all the way of the fourth journey. At the end of the journey the tank will be empty.

In the third example the bus can not make all $ 3 $ journeys because if it refuels during the second journey, the tanks will contain only $ 5 $ liters of gasoline, but the bus needs to pass $ 8 $ units of distance until next refueling.

## 样例 #1

### 输入

```
6 9 2 4

```

### 输出

```
4

```

## 样例 #2

### 输入

```
6 10 2 4

```

### 输出

```
2

```

## 样例 #3

### 输入

```
6 5 4 3

```

### 输出

```
-1

```



---

---
title: "Race Against Time"
layout: "post"
diff: 普及-
pid: CF868B
tag: []
---

# Race Against Time

## 题目描述

Have you ever tried to explain to the coordinator, why it is eight hours to the contest and not a single problem has been prepared yet? Misha had. And this time he has a really strong excuse: he faced a space-time paradox! Space and time replaced each other.

The entire universe turned into an enormous clock face with three hands — hour, minute, and second. Time froze, and clocks now show the time $ h $ hours, $ m $ minutes, $ s $ seconds.

Last time Misha talked with the coordinator at $ t_{1} $ o'clock, so now he stands on the number $ t_{1} $ on the clock face. The contest should be ready by $ t_{2} $ o'clock. In the terms of paradox it means that Misha has to go to number $ t_{2} $ somehow. Note that he doesn't have to move forward only: in these circumstances time has no direction.

Clock hands are very long, and Misha cannot get round them. He also cannot step over as it leads to the collapse of space-time. That is, if hour clock points 12 and Misha stands at 11 then he cannot move to 1 along the top arc. He has to follow all the way round the clock center (of course, if there are no other hands on his way).

Given the hands' positions, $ t_{1} $ , and $ t_{2} $ , find if Misha can prepare the contest on time (or should we say on space?). That is, find if he can move from $ t_{1} $ to $ t_{2} $ by the clock face.

## 输入格式

Five integers $ h $ , $ m $ , $ s $ , $ t_{1} $ , $ t_{2} $ ( $ 1<=h<=12 $ , $ 0<=m,s<=59 $ , $ 1<=t_{1},t_{2}<=12 $ , $ t_{1}≠t_{2} $ ).

Misha's position and the target time do not coincide with the position of any hand.

## 输出格式

Print "YES" (quotes for clarity), if Misha can prepare the contest on time, and "NO" otherwise.

You can print each character either upper- or lowercase ("YeS" and "yes" are valid when the answer is "YES").

## 说明/提示

The three examples are shown on the pictures below from left to right. The starting position of Misha is shown with green, the ending position is shown with pink. Note that the positions of the hands on the pictures are not exact, but are close to the exact and the answer is the same.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF868B/a67db32a4530841b7d57b21ea225d21a83f385f3.png)

## 样例 #1

### 输入

```
12 30 45 3 11

```

### 输出

```
NO

```

## 样例 #2

### 输入

```
12 0 1 12 1

```

### 输出

```
YES

```

## 样例 #3

### 输入

```
3 47 0 4 9

```

### 输出

```
YES

```



---

---
title: "The Eternal Immortality"
layout: "post"
diff: 普及-
pid: CF869B
tag: []
---

# The Eternal Immortality

## 题目描述

Even if the world is full of counterfeits, I still regard it as wonderful.

Pile up herbs and incense, and arise again from the flames and ashes of its predecessor — as is known to many, the phoenix does it like this.

The phoenix has a rather long lifespan, and reincarnates itself once every $ a! $ years. Here $ a! $ denotes the factorial of integer $ a $ , that is, $ a!=1×2×...×a $ . Specifically, $ 0!=1 $ .

Koyomi doesn't care much about this, but before he gets into another mess with oddities, he is interested in the number of times the phoenix will reincarnate in a timespan of $ b! $ years, that is, ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF869B/e1b2fb98f4ea484515a807ebc0e143dd3b54b9f1.png). Note that when $ b>=a $ this value is always integer.

As the answer can be quite large, it would be enough for Koyomi just to know the last digit of the answer in decimal representation. And you're here to provide Koyomi with this knowledge.

## 输入格式

The first and only line of input contains two space-separated integers $ a $ and $ b $ ( $ 0<=a<=b<=10^{18} $ ).

## 输出格式

Output one line containing a single decimal digit — the last digit of the value that interests Koyomi.

## 说明/提示

In the first example, the last digit of ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF869B/710c390d7d95fd1e439facb57a8db32614f140ba.png) is $ 2 $ ;

In the second example, the last digit of ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF869B/9a0a3742a40de8b41b9545899252cb65c16a80ca.png) is $ 0 $ ;

In the third example, the last digit of ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF869B/ba5fe125aa2ce1485bb9c22050da0a9acf975415.png) is $ 2 $ .

## 样例 #1

### 输入

```
2 4

```

### 输出

```
2

```

## 样例 #2

### 输入

```
0 10

```

### 输出

```
0

```

## 样例 #3

### 输入

```
107 109

```

### 输出

```
2

```



---

---
title: "Maximum of Maximums of Minimums"
layout: "post"
diff: 普及-
pid: CF870B
tag: []
---

# Maximum of Maximums of Minimums

## 题目描述

You are given an array $ a_{1},a_{2},...,a_{n} $ consisting of $ n $ integers, and an integer $ k $ . You have to split the array into exactly $ k $ non-empty subsegments. You'll then compute the minimum integer on each subsegment, and take the maximum integer over the $ k $ obtained minimums. What is the maximum possible integer you can get?

Definitions of subsegment and array splitting are given in notes.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 1<=k<=n<=10^{5} $ ) — the size of the array $ a $ and the number of subsegments you have to split the array to.

The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ -10^{9}<=a_{i}<=10^{9} $ ).

## 输出格式

Print single integer — the maximum possible integer you can get if you split the array into $ k $ non-empty subsegments and take maximum of minimums on the subsegments.

## 说明/提示

A subsegment $ [l,r] $ ( $ l<=r $ ) of array $ a $ is the sequence $ a_{l},a_{l+1},...,a_{r} $ .

Splitting of array $ a $ of $ n $ elements into $ k $ subsegments $ [l_{1},r_{1}] $ , $ [l_{2},r_{2}] $ , ..., $ [l_{k},r_{k}] $ ( $ l_{1}=1 $ , $ r_{k}=n $ , $ l_{i}=r_{i-1}+1 $ for all $ i>1 $ ) is $ k $ sequences $ (a_{l1},...,a_{r1}),...,(a_{lk},...,a_{rk}) $ .

In the first example you should split the array into subsegments $ [1,4] $ and $ [5,5] $ that results in sequences $ (1,2,3,4) $ and $ (5) $ . The minimums are $ min(1,2,3,4)=1 $ and $ min(5)=5 $ . The resulting maximum is $ max(1,5)=5 $ . It is obvious that you can't reach greater result.

In the second example the only option you have is to split the array into one subsegment $ [1,5] $ , that results in one sequence $ (-4,-5,-3,-2,-1) $ . The only minimum is $ min(-4,-5,-3,-2,-1)=-5 $ . The resulting maximum is $ -5 $ .

## 样例 #1

### 输入

```
5 2
1 2 3 4 5

```

### 输出

```
5

```

## 样例 #2

### 输入

```
5 1
-4 -5 -3 -2 -1

```

### 输出

```
-5

```



---

---
title: "Classroom Watch"
layout: "post"
diff: 普及-
pid: CF875A
tag: []
---

# Classroom Watch

## 题目描述

Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number $ n $ . He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that $ n $ is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer $ x $ was given. The task was to add $ x $ to the sum of the digits of the number $ x $ written in decimal numeral system.

Since the number $ n $ on the board was small, Vova quickly guessed which $ x $ could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number $ n $ for all suitable values of $ x $ or determine that such $ x $ does not exist. Write such a program for Vova.

## 输入格式

The first line contains integer $ n $ ( $ 1<=n<=10^{9} $ ).

## 输出格式

In the first line print one integer $ k $ — number of different values of $ x $ satisfying the condition.

In next $ k $ lines print these values in ascending order.

## 说明/提示

In the first test case $ x=15 $ there is only one variant: $ 15+1+5=21 $ .

In the second test case there are no such $ x $ .

## 样例 #1

### 输入

```
21

```

### 输出

```
1
15

```

## 样例 #2

### 输入

```
20

```

### 输出

```
0

```



---

---
title: "Divisiblity of Differences"
layout: "post"
diff: 普及-
pid: CF876B
tag: []
---

# Divisiblity of Differences

## 题目描述

You are given a multiset of $ n $ integers. You should select exactly $ k $ of them in a such way that the difference between any two of them is divisible by $ m $ , or tell that it is impossible.

Numbers can be repeated in the original multiset and in the multiset of selected numbers, but number of occurrences of any number in multiset of selected numbers should not exceed the number of its occurrences in the original multiset.

## 输入格式

First line contains three integers $ n $ , $ k $ and $ m $ ( $ 2<=k<=n<=100000 $ , $ 1<=m<=100000 $ ) — number of integers in the multiset, number of integers you should select and the required divisor of any pair of selected integers.

Second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ 0<=a_{i}<=10^{9} $ ) — the numbers in the multiset.

## 输出格式

If it is not possible to select $ k $ numbers in the desired way, output «No» (without the quotes).

Otherwise, in the first line of output print «Yes» (without the quotes). In the second line print $ k $ integers $ b_{1},b_{2},...,b_{k} $ — the selected numbers. If there are multiple possible solutions, print any of them.

## 样例 #1

### 输入

```
3 2 3
1 8 4

```

### 输出

```
Yes
1 4 
```

## 样例 #2

### 输入

```
3 3 3
1 8 4

```

### 输出

```
No
```

## 样例 #3

### 输入

```
4 3 5
2 7 7 7

```

### 输出

```
Yes
2 7 7 
```



---

---
title: "Trains"
layout: "post"
diff: 普及-
pid: CF87A
tag: []
---

# Trains

## 题目描述

程序员Vasya有两个女友，一个叫Dasha，另一个叫Masha。她们分别住在Vasya所在地铁线路的两个始发站。

当Vasya有空闲时间时，他会去找他的一个女友。他在某个时间下降到火车站，等待第一班火车到来（地铁去哪，他就去哪个女友那里）。但两个方向的火车发车时间不同，向Dasha方向的火车a分钟一班，向Masha方向的火车b分钟一班。如果两列火车同时到达，Vasya会朝着发车时间较长的方向前进。在第0分钟，两班火车同时从Vasya所在站的前一个站和后一个站开出。（chinaxjh这个蒟蒻无法翻译的更好一点了）

问Vasya去哪个女友那里的概率大。（输出英文名即可，如果一样输出“Equal”，引号不用输出）

## 输入格式

第一行包含两个整数a和b（a≠b,1<=a,b<=10 ^ {6}）。

## 输出格式

一行，“Dasha”“Masha”或“Equal”

## 样例 #1

### 输入

```
3 7

```

### 输出

```
Dasha

```

## 样例 #2

### 输入

```
5 3

```

### 输出

```
Masha

```

## 样例 #3

### 输入

```
2 3

```

### 输出

```
Equal

```



---

---
title: "Quadcopter Competition"
layout: "post"
diff: 普及-
pid: CF883M
tag: []
---

# Quadcopter Competition

## 题目描述

你参加了一个飞行器比赛，并知道你的飞行器起点在$(x_1,y_1)$ ，有一面旗子在$(x_2,y_2)$ 。

每次你的飞行器能够沿平行于坐标轴方向移动$1$ 单位长度，即假如你在$(x,y)$ ，你的飞行器可以前往$(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 四者中的一个。

现在你需要规划一个路线，这个路线从起点出发并回到起点，并构成一个封闭环。同时这个封闭环必须**严格包含**旗子所在的格点。（具体看下面的图片）

求飞行器最短飞行距离为多少。

## 输入格式

第一行$x_1,y_1$ ，第二行$x_2,y_2$ 。

## 输出格式

一个答案。

## 说明/提示

$-100\le x_1,x_2,y_1,y_2\le 100$ 。

感谢@U50882 OwenOwl 提供的翻译

## 样例 #1

### 输入

```
1 5
5 2

```

### 输出

```
18

```

## 样例 #2

### 输入

```
0 1
0 0

```

### 输出

```
8

```



---

---
title: "Petya and Catacombs"
layout: "post"
diff: 普及-
pid: CF886C
tag: []
---

# Petya and Catacombs

## 题目描述

A very brave explorer Petya once decided to explore Paris catacombs. Since Petya is not really experienced, his exploration is just walking through the catacombs.

Catacombs consist of several rooms and bidirectional passages between some pairs of them. Some passages can connect a room to itself and since the passages are built on different depths they do not intersect each other. Every minute Petya arbitrary chooses a passage from the room he is currently in and then reaches the room on the other end of the passage in exactly one minute. When he enters a room at minute $ i $ , he makes a note in his logbook with number $ t_{i} $ :

- If Petya has visited this room before, he writes down the minute he was in this room last time;
- Otherwise, Petya writes down an arbitrary non-negative integer strictly less than current minute $ i $ .

Initially, Petya was in one of the rooms at minute $ 0 $ , he didn't write down number $ t_{0} $ .

At some point during his wandering Petya got tired, threw out his logbook and went home. Vasya found his logbook and now he is curious: what is the minimum possible number of rooms in Paris catacombs according to Petya's logbook?

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=2·10^{5} $ ) — then number of notes in Petya's logbook.

The second line contains $ n $ non-negative integers $ t_{1},t_{2},...,t_{n} $ ( $ 0<=t_{i}&lt;i $ ) — notes in the logbook.

## 输出格式

In the only line print a single integer — the minimum possible number of rooms in Paris catacombs.

## 说明/提示

In the first sample, sequence of rooms Petya visited could be, for example $ 1→1→2 $ , $ 1→2→1 $ or $ 1→2→3 $ . The minimum possible number of rooms is $ 2 $ .

In the second sample, the sequence could be $ 1→2→3→1→2→1 $ .

## 样例 #1

### 输入

```
2
0 0

```

### 输出

```
2

```

## 样例 #2

### 输入

```
5
0 1 0 1 3

```

### 输出

```
3

```



---

---
title: "Buggy Robot"
layout: "post"
diff: 普及-
pid: CF888B
tag: []
---

# Buggy Robot

## 题目描述

Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell $ (0,0) $ . The robot can process commands. There are four types of commands it can perform:

- U — move from the cell $ (x,y) $ to $ (x,y+1) $ ;
- D — move from $ (x,y) $ to $ (x,y-1) $ ;
- L — move from $ (x,y) $ to $ (x-1,y) $ ;
- R — move from $ (x,y) $ to $ (x+1,y) $ .

Ivan entered a sequence of $ n $ commands, and the robot processed it. After this sequence the robot ended up in the starting cell $ (0,0) $ , but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!

## 输入格式

The first line contains one number $ n $ — the length of sequence of commands entered by Ivan ( $ 1<=n<=100 $ ).

The second line contains the sequence itself — a string consisting of $ n $ characters. Each character can be U, D, L or R.

## 输出格式

Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.

## 样例 #1

### 输入

```
4
LDUR

```

### 输出

```
4

```

## 样例 #2

### 输入

```
5
RRRUU

```

### 输出

```
0

```

## 样例 #3

### 输入

```
6
LLRRRR

```

### 输出

```
4

```



---

---
title: "Chord"
layout: "post"
diff: 普及-
pid: CF88A
tag: []
---

# Chord

## 题目描述

Vasya studies music.

He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitones

Vasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.

Let's define a major triad. Let the triad consist of notes $ X $ , $ Y $ and $ Z $ . If we can order the notes so as the distance along the musical scale between $ X $ and $ Y $ equals 4 semitones and the distance between $ Y $ and $ Z $ is 3 semitones, then the triad is major. The distance between $ X $ and $ Z $ , accordingly, equals 7 semitones.

A minor triad is different in that the distance between $ X $ and $ Y $ should be 3 semitones and between $ Y $ and $ Z $ — 4 semitones.

For example, the triad "C E G" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet "C# B F" is minor, because if we order the notes as "B C# F", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.

Help Vasya classify the triad the teacher has given to him.

## 输入格式

The only line contains 3 space-separated notes in the above-given notation.

## 输出格式

Print "major" if the chord is major, "minor" if it is minor, and "strange" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.

## 样例 #1

### 输入

```
C E G

```

### 输出

```
major

```

## 样例 #2

### 输入

```
C# B F

```

### 输出

```
minor

```

## 样例 #3

### 输入

```
A B H

```

### 输出

```
strange

```



---

---
title: "Chess For Three"
layout: "post"
diff: 普及-
pid: CF893A
tag: []
---

# Chess For Three

## 题目描述

A，B，C 三人下棋，A 和 B 先下，每次下完棋之后由现在观战的人（例如第一局就由 C）代替下输的人。
每次输入一个数表示谁赢了（A 是 $1$，B 是 $2$，C 是 $3$），如果每一次输入的赢家都不是当时旁观者，则输出 $\mathtt{YES}$，否则输出 $\mathtt{NO}$。

## 输入格式

第一行输入正整数 $n$（$n\leq100$），表示比赛局数。
接下来n行，每一行输入一个正整数 $a_i$（$1\leq a_i\leq3$），表示此局赢家

## 输出格式

如果此过程中不存在旁观者胜利，则输出 $\mathtt{YES}$，否则输出 $\mathtt{NO}$。

## 说明/提示

第一个样例顺序：  
A:B，A 胜  
A:C，A 胜   
A:B，B 胜 

第二个样例 B 输了第一场，可是他第二场赢了，矛盾，输出 $\mathtt{NO}$。

## 样例 #1

### 输入

```
3
1
1
2

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
2
1
2

```

### 输出

```
NO

```



---

---
title: "Beautiful Divisors"
layout: "post"
diff: 普及-
pid: CF893B
tag: []
---

# Beautiful Divisors

## 题目描述

Recently Luba learned about a special kind of numbers that she calls beautiful numbers. The number is called beautiful iff its binary representation consists of $ k+1 $ consecutive ones, and then $ k $ consecutive zeroes.

Some examples of beautiful numbers:

- $ 1_{2} $ ( $ 1_{10} $ );
- $ 110_{2} $ ( $ 6_{10} $ );
- $ 1111000_{2} $ ( $ 120_{10} $ );
- $ 111110000_{2} $ ( $ 496_{10} $ ).

More formally, the number is beautiful iff there exists some positive integer $ k $ such that the number is equal to $ (2^{k}-1)*(2^{k-1}) $ .

Luba has got an integer number $ n $ , and she wants to find its greatest beautiful divisor. Help her to find it!

## 输入格式

The only line of input contains one number $ n $ ( $ 1<=n<=10^{5} $ ) — the number Luba has got.

## 输出格式

Output one number — the greatest beautiful divisor of Luba's number. It is obvious that the answer always exists.

## 样例 #1

### 输入

```
3

```

### 输出

```
1

```

## 样例 #2

### 输入

```
992

```

### 输出

```
496

```



---

---
title: "Months and Years"
layout: "post"
diff: 普及-
pid: CF899B
tag: []
---

# Months and Years

## 题目描述

Everybody in Russia uses Gregorian calendar. In this calendar there are $ 31 $ days in January, $ 28 $ or $ 29 $ days in February (depending on whether the year is leap or not), $ 31 $ days in March, $ 30 $ days in April, $ 31 $ days in May, $ 30 $ in June, $ 31 $ in July, $ 31 $ in August, $ 30 $ in September, $ 31 $ in October, $ 30 $ in November, $ 31 $ in December.

A year is leap in one of two cases: either its number is divisible by $ 4 $ , but not divisible by $ 100 $ , or is divisible by $ 400 $ . For example, the following years are leap: $ 2000 $ , $ 2004 $ , but years $ 1900 $ and $ 2018 $ are not leap.

In this problem you are given $ n $ ( $ 1<=n<=24 $ ) integers $ a_{1},a_{2},...,a_{n} $ , and you have to check if these integers could be durations in days of $ n $ consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is $ a_{1} $ days, duration of the next month is $ a_{2} $ days, and so on.

## 输入格式

The first line contains single integer $ n $ ( $ 1<=n<=24 $ ) — the number of integers.

The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} $ ( $ 28<=a_{i}<=31 $ ) — the numbers you are to check.

## 输出格式

If there are several consecutive months that fit the sequence, print "YES" (without quotes). Otherwise, print "NO" (without quotes).

You can print each letter in arbitrary case (small or large).

## 说明/提示

In the first example the integers can denote months July, August, September and October.

In the second example the answer is no, because there are no two consecutive months each having $ 30 $ days.

In the third example the months are: February (leap year) — March — April – May — June.

In the fourth example the number of days in the second month is $ 28 $ , so this is February. March follows February and has $ 31 $ days, but not $ 30 $ , so the answer is NO.

In the fifth example the months are: December — January — February (non-leap year).

## 样例 #1

### 输入

```
4
31 31 30 31

```

### 输出

```
Yes


```

## 样例 #2

### 输入

```
2
30 30

```

### 输出

```
No


```

## 样例 #3

### 输入

```
5
29 31 30 31 30

```

### 输出

```
Yes


```

## 样例 #4

### 输入

```
3
31 28 30

```

### 输出

```
No


```

## 样例 #5

### 输入

```
3
31 31 28

```

### 输出

```
Yes


```



---

---
title: "Dividing the numbers"
layout: "post"
diff: 普及-
pid: CF899C
tag: []
---

# Dividing the numbers

## 题目描述

Petya has $ n $ integers: $ 1,2,3,...,n $ . He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible.

Help Petya to split the integers. Each of $ n $ integers should be exactly in one group.

## 输入格式

The first line contains a single integer $ n $ ( $ 2<=n<=60000 $ ) — the number of integers Petya has.

## 输出格式

Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.

## 说明/提示

In the first example you have to put integers $ 1 $ and $ 4 $ in the first group, and $ 2 $ and $ 3 $ in the second. This way the sum in each group is $ 5 $ , and the absolute difference is $ 0 $ .

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is $ 1 $ .

## 样例 #1

### 输入

```
4

```

### 输出

```
0
2 1 4 

```

## 样例 #2

### 输入

```
2

```

### 输出

```
1
1 1 

```



---

---
title: "Visiting a Friend"
layout: "post"
diff: 普及-
pid: CF902A
tag: []
---

# Visiting a Friend

## 题目描述

Pig 想去拜访一位朋友。

Pig 的家位于坐标轴的起点，即点 $0$，而他朋友的家位于点 $m$。

在这段旅途中，Pig 可以通过传送门在坐标轴上移动。

在使用传送门时，Pig 需要先到达传送门所在位置，并从中选择一个目标位置。每个传送门都有其最远可达的终点，称为该传送门的限制点。

具体来说，位于点 $x$ 且限制点为 $y$ 的传送门可以将 Pig 从 $x$ 移动到 $[x, y]$ 之间（包括端点）的任意位置。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/92bc86959654b1405c61b81d368eac9f5c5fe404.png)请判断 Pig 是否可以仅通过传送门顺利抵达朋友的家，否则，Pig 将需要开车前往。

## 输入格式

第一行包含两个整数 $n$ 和 $m$，分别表示传送门的数量和朋友家的位置，满足 $1 \le n \le 100, 1 \le m \le 100$。

接下来的 $n$ 行描述了传送门的信息。

第 $i$ 行包含两个整数 $a_i$ 和 $b_i$，其中 $a_i$ 是第 $i$ 个传送门的位置，$b_i$ 是该传送门的限制点，满足 $0 \le a_i \le b_i \le m$。

输入保证，对于所有 $2 \le i \le n$，都有 $a_i \ge a_{i-1}$。

## 输出格式

如果 Pig 可以仅使用传送门从家到达朋友家，请输出 `YES`；否则输出 `NO`。

输出中的字母大小写不作要求。

## 说明/提示

第一个例子如图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/753e62c3b07259c4bd5318fcbc1770c920417f65.png)

Pig 可以依次利用传送门，从家移动到点 $2$、再到点 $3$，最后到达朋友的家——点 $5$。

第二个例子如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/907bb5d428f081e5cfddf9be149837a9d7265e2e.png)

可以看到，Pig 无法仅借助传送门从家到达朋友家。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 5
0 2
2 4
3 5

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
3 7
0 4
2 5
6 7

```

### 输出

```
NO

```



---

---
title: "Masha and Bears"
layout: "post"
diff: 普及-
pid: CF907A
tag: []
---

# Masha and Bears

## 题目描述

A family consisting of father bear, mother bear and son bear owns three cars. Father bear can climb into the largest car and he likes it. Also, mother bear can climb into the middle car and she likes it. Moreover, son bear can climb into the smallest car and he likes it. It's known that the largest car is strictly larger than the middle car, and the middle car is strictly larger than the smallest car.

Masha came to test these cars. She could climb into all cars, but she liked only the smallest car.

It's known that a character with size $ a $ can climb into some car with size $ b $ if and only if $ a<=b $ , he or she likes it if and only if he can climb into this car and $ 2a>=b $ .

You are given sizes of bears and Masha. Find out some possible integer non-negative sizes of cars.

## 输入格式

You are given four integers $ V_{1} $ , $ V_{2} $ , $ V_{3} $ , $ V_{m} $ ( $ 1<=V_{i}<=100 $ ) — sizes of father bear, mother bear, son bear and Masha, respectively. It's guaranteed that $ V_{1}>V_{2}>V_{3} $ .

## 输出格式

Output three integers — sizes of father bear's car, mother bear's car and son bear's car, respectively.

If there are multiple possible solutions, print any.

If there is no solution, print "-1" (without quotes).

## 说明/提示

In first test case all conditions for cars' sizes are satisfied.

In second test case there is no answer, because Masha should be able to climb into smallest car (so size of smallest car in not less than 21), but son bear should like it, so maximum possible size of it is 20.

## 样例 #1

### 输入

```
50 30 10 10

```

### 输出

```
50
30
10

```

## 样例 #2

### 输入

```
100 50 10 21

```

### 输出

```
-1

```



---

---
title: "New Year and Counting Cards"
layout: "post"
diff: 普及-
pid: CF908A
tag: []
---

# New Year and Counting Cards

## 题目描述

翻译：

你的朋友有N张牌。

每一张卡片上都有一个小写的英文字母和一个数字。

现在，你的朋友已经把卡片放在了一张桌子上，所以每张卡片只有一面可见。你很想知道你的朋友对所拥有的卡片的描述是否正确：“如果一张卡片上有一个元音，那么它的另一面一定是一个偶数”(元音是“A”、“E”、“I”、“O”或“u”的一个，偶数是“0”、“2”、“4”、“6”或“8”的一种)。

例如，如果一张牌的一面是“A”，另一面有“6”，那么这句话是对的。此外，一张有“B”和“4”的卡片，以及一张有“B”和“3”的卡片的描述也是正确的（因为字母不是元音）。

而有“E”和“5”的卡是错误的。

如果所有的卡都是符合要求的，你会感兴趣。另外，如果没有卡是元音，描述是真的。

为了确定这一点，你可以翻转一些卡片来显示另一面。你想知道在最坏的情况下需要翻转的最小卡片数。

## 输入格式

输入的只有一行，为一个字符串S（1≤s的长度≤50），表示你在桌子上看到的每个字符（只包含字母和数字）

## 输出格式

输出一个整数，表示最少要翻几张卡片。

Translated by @引领天下

## 样例 #1

### 输入

```
ee

```

### 输出

```
2

```

## 样例 #2

### 输入

```
z

```

### 输出

```
0

```

## 样例 #3

### 输入

```
0ay1

```

### 输出

```
2

```



---

---
title: "African Crossword"
layout: "post"
diff: 普及-
pid: CF90B
tag: []
---

# African Crossword

## 题目描述

An African crossword is a rectangular table $ n×m $ in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.

To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.

When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.

You are suggested to solve an African crossword and print the word encrypted there.

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1<=n,m<=100 $ ). Next $ n $ lines contain $ m $ lowercase Latin letters each. That is the crossword grid.

## 输出格式

Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.

## 样例 #1

### 输入

```
3 3
cba
bcd
cbc

```

### 输出

```
abcd
```

## 样例 #2

### 输入

```
5 5
fcofd
ooedo
afaoa
rdcdf
eofsf

```

### 输出

```
codeforces
```



---

---
title: "Door Frames"
layout: "post"
diff: 普及-
pid: CF910B
tag: []
---

# Door Frames

## 题目描述

Petya有一些长度为 n 的木条。他想要为两个一样的门做一个框架。每个框架都有两个竖直的长度为 a 的边（左边和右边）和一个长度为 b 的顶边。每个边都需要一个实心的（即不间断的）木条。

求出为两个门做框架所需要的最少的木条。Petya可以将一个木条切成几段，但是门的每一边都应该是完整的一块木板。

## 输入格式

第一行包含一个正整数 n，表示木条的长度

第二行包含一个正整数 a，表示门左右两边的长度

第三行包含一个正整数 b，表示门顶部的长度

## 输出格式

输出用长度为 n 的木条为两个门做框架，所需的最少木条数。
Translated by @Fowany

## 样例 #1

### 输入

```
8
1
2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
5
3
4

```

### 输出

```
6

```

## 样例 #3

### 输入

```
6
4
2

```

### 输出

```
4

```

## 样例 #4

### 输入

```
20
5
6

```

### 输出

```
2

```



---

---
title: "Two Cakes"
layout: "post"
diff: 普及-
pid: CF911B
tag: []
---

# Two Cakes

## 题目描述

除夕将至，因此Ivan觉得应该开始摆盘了。Ivan买了两个蛋糕并且把他们切成了块：第一个蛋糕被切成a块，第二个被切成b块。 Ivan知道包括他在内将会有n个人参加庆祝活动，所以他已经为蛋糕准备了n个盘子。现在他在思考怎样分配盘子和蛋糕。Ivan想要满足一下所有条件： 1.每块蛋糕都被放在盘子上； 2.每个盘子至少放了一块蛋糕； 3.没有盘子放了两个不同的蛋糕（即切开前分别属于两个不同的大蛋糕）； 为了给客人带来更多快♂感，Ivan想让（数量）最小份的蛋糕数量尽可能大。他希望知道最大的x，使得他使得他可以根据上述条件分发蛋糕，并且每个盘子包含至少x块蛋糕。 帮助伊万来计算这个数字 x！

## 输入格式

第一行包含三个整数n，a和b（1<=a，b<=100 ，2<=n<=a+b）——盘子的数量，第一个蛋糕被切成的块数和第二个蛋糕被切成的块数。

## 输出格式

输出最大可能的数字x使得Ivan可以以这样的方式，每个盘子里包含至少分发蛋糕x块蛋糕

样例略

## 说明/提示

在第一个样例中，只有一种方法可以将蛋糕分配进盘子，即每个盘子1个蛋糕。 在第二个样例中，你可以在两个盘子分别放3块第一个蛋糕和4块第二个蛋糕，另外两个盘子都放5块第二个蛋糕。最少的块数是3。

## 样例 #1

### 输入

```
5 2 3

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4 7 10

```

### 输出

```
3

```



---

---
title: "Christmas Spruce"
layout: "post"
diff: 普及-
pid: CF913B
tag: []
---

# Christmas Spruce

## 题目描述

Consider a rooted tree. A rooted tree has one special vertex called the root. All edges are directed from the root. Vertex $ u $ is called a child of vertex $ v $ and vertex $ v $ is called a parent of vertex $ u $ if there exists a directed edge from $ v $ to $ u $ . A vertex is called a leaf if it doesn't have children and has a parent.

Let's call a rooted tree a spruce if its every non-leaf vertex has at least $ 3 $ leaf children. You are given a rooted tree, check whether it's a spruce.

The definition of a rooted tree can be found [here](https://goo.gl/1dqvzz).

## 输入格式

The first line contains one integer $ n $ — the number of vertices in the tree ( $ 3<=n<=1000 $ ). Each of the next $ n-1 $ lines contains one integer $ p_{i} $ ( $ 1<=i<=n-1 $ ) — the index of the parent of the $ i+1 $ -th vertex ( $ 1<=p_{i}<=i $ ).

Vertex $ 1 $ is the root. It's guaranteed that the root has at least $ 2 $ children.

## 输出格式

Print "Yes" if the tree is a spruce and "No" otherwise.

## 说明/提示

The first example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF913B/3d87b6a6cda0ba6f4ad05908fb42ae8248c8369b.png)

The second example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF913B/bd0b03933e2dbb274b2b58b0c7a13d930c39c80b.png)

It is not a spruce, because the non-leaf vertex $ 1 $ has only $ 2 $ leaf children.

The third example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF913B/a9d72240b2a5e338c43541d320aabfb5ee526dff.png)

## 样例 #1

### 输入

```
4
1
1
1

```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
7
1
1
1
2
2
2

```

### 输出

```
No

```

## 样例 #3

### 输入

```
8
1
1
1
1
3
3
3

```

### 输出

```
Yes

```



---

---
title: "Browser"
layout: "post"
diff: 普及-
pid: CF915B
tag: []
---

# Browser

## 题目描述

Luba正在网上冲浪。她在浏览器里打开了n个标签，从左到右编号为1到n。目前鼠标光标的位置在第pos个标签。Luba需要使用编号从l到r（包含l与r）的标签，并且她想尽可能快地关闭其它的标签。

Luba每秒可以把光标往左移或者往右移（如果光标当前在标签ii，则她可以将光标移到标签max(i-1,a)或者min(i+1,b)，或者关闭它左边或右边所有的标签（如果光标当前在标签i，她可以关闭[a,i−1]这段标签或者[i+1,b]这段标签）。在上述表达式中，a与b分别表示未关闭标签最小与最大的编号。如果最初有7个标签，1、2、7号标签都被关闭了，那么a=3,b=6

为了只留下初始编号从ll到rr的标签，Luba至少花费多少秒钟？

## 输入格式

输入只有一行，包括四个整数n,pos,l,r（1<=n<=100 , 1<=pos<=n ，1<=l<=r<=n）——标签的数量，光标的位置与Luba需要留下的标签的范围。

## 输出格式

输出一个整数，表示关闭除了范围[l,r]以外的所有标签所需的最短秒数。

## 说明/提示

第一个样例中Luba需要做下面的操作：移动光标至标签2，关闭它左边的所有标签，移动光标到标签3，再到标签4，然后关闭它右边的所有标签。

第二个样例中她只需要关闭光标右边的所有标签。

第三个样例中Luba不需要做任何事。

## 样例 #1

### 输入

```
6 3 2 4

```

### 输出

```
5

```

## 样例 #2

### 输入

```
6 3 1 3

```

### 输出

```
1

```

## 样例 #3

### 输入

```
5 2 1 5

```

### 输出

```
0

```



---

---
title: "Radio Station"
layout: "post"
diff: 普及-
pid: CF918B
tag: []
---

# Radio Station

## 题目描述

As the guys fried the radio station facilities, the school principal gave them tasks as a punishment. Dustin's task was to add comments to nginx configuration for school's website. The school has $ n $ servers. Each server has a name and an ip (names aren't necessarily unique, but ips are). Dustin knows the ip and name of each server. For simplicity, we'll assume that an nginx command is of form "command ip;" where command is a string consisting of English lowercase letter only, and ip is the ip of one of school servers.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF918B/ad878d2803e8a6ba1a8b3d8d599829e1c536a92a.png)Each ip is of form "a.b.c.d" where $ a $ , $ b $ , $ c $ and $ d $ are non-negative integers less than or equal to $ 255 $ (with no leading zeros). The nginx configuration file Dustin has to add comments to has $ m $ commands. Nobody ever memorizes the ips of servers, so to understand the configuration better, Dustin has to comment the name of server that the ip belongs to at the end of each line (after each command). More formally, if a line is "command ip;" Dustin has to replace it with "command ip; #name" where name is the name of the server with ip equal to ip.

Dustin doesn't know anything about nginx, so he panicked again and his friends asked you to do his task for him.

## 输入格式

The first line of input contains two integers $ n $ and $ m $ ( $ 1<=n,m<=1000 $ ).

The next $ n $ lines contain the names and ips of the servers. Each line contains a string name, name of the server and a string ip, ip of the server, separated by space ( $ 1<=|name|<=10 $ , $ name $ only consists of English lowercase letters). It is guaranteed that all ip are distinct.

The next $ m $ lines contain the commands in the configuration file. Each line is of form "command ip;" ( $ 1<=|command|<=10 $ , command only consists of English lowercase letters). It is guaranteed that ip belongs to one of the $ n $ school servers.

## 输出格式

Print $ m $ lines, the commands in the configuration file after Dustin did his task.

## 样例 #1

### 输入

```
2 2
main 192.168.0.2
replica 192.168.0.1
block 192.168.0.1;
proxy 192.168.0.2;

```

### 输出

```
block 192.168.0.1; #replica
proxy 192.168.0.2; #main

```

## 样例 #2

### 输入

```
3 5
google 8.8.8.8
codeforces 212.193.33.27
server 138.197.64.57
redirect 138.197.64.57;
block 8.8.8.8;
cf 212.193.33.27;
unblock 8.8.8.8;
check 138.197.64.57;

```

### 输出

```
redirect 138.197.64.57; #server
block 8.8.8.8; #google
cf 212.193.33.27; #codeforces
unblock 8.8.8.8; #google
check 138.197.64.57; #server

```



---

---
title: "Perfect Number"
layout: "post"
diff: 普及-
pid: CF919B
tag: []
---

# Perfect Number

## 题目描述

We consider a positive integer perfect, if and only if the sum of its digits is exactly $ 10 $ . Given a positive integer $ k $ , your task is to find the $ k $ -th smallest perfect positive integer.

## 输入格式

A single line with a positive integer $ k $ ( $ 1<=k<=10000 $ ).

## 输出格式

A single number, denoting the $ k $ -th smallest perfect integer.

## 说明/提示

The first perfect integer is $ 19 $ and the second one is $ 28 $ .

## 样例 #1

### 输入

```
1

```

### 输出

```
19

```

## 样例 #2

### 输入

```
2

```

### 输出

```
28

```



---

---
title: "Seat Arrangements"
layout: "post"
diff: 普及-
pid: CF919C
tag: []
---

# Seat Arrangements

## 题目描述

教室有n排座位，每排有m个座位，将教室表示为$n*m$  的矩阵。字符'.'代表一个空座位，而'*'意味着座位被占用。你需要在同一行或同一列中找到k个连续的空席位，并为你和你的朋友安排这些座位。你的任务是找出安排座位的方式。如果学生所占据的地方不同，两种方式被认为是不同的。

## 输入格式

第一行n, m, k $(1\le n,m,k \le 2000)$ 

接下来一个n*m的矩阵。

## 输出格式

一个整数 表示不同的方案数

Translated by Pine

## 样例 #1

### 输入

```
2 3 2
**.
...

```

### 输出

```
3

```

## 样例 #2

### 输入

```
1 2 2
..

```

### 输出

```
1

```

## 样例 #3

### 输入

```
3 3 4
.*.
*.*
.*.

```

### 输出

```
0

```



---

---
title: "Is This a Zebra?"
layout: "post"
diff: 普及-
pid: CF926C
tag: []
---

# Is This a Zebra?

## 题目描述

A camera you have accidentally left in a desert has taken an interesting photo. The photo has a resolution of $ n $ pixels width, and each column of this photo is all white or all black. Thus, we can represent the photo as a sequence of $ n $ zeros and ones, where $ 0 $ means that the corresponding column is all white, and $ 1 $ means that the corresponding column is black.

You think that this photo can contain a zebra. In this case the whole photo should consist of several (possibly, only one) alternating black and white stripes of equal width. For example, the photo $ [0,0,0,1,1,1,0,0,0] $ can be a photo of zebra, while the photo $ [0,0,0,1,1,1,1] $ can not, because the width of the black stripe is $ 3 $ , while the width of the white stripe is $ 4 $ . Can the given photo be a photo of zebra or not?

## 输入格式

The first line contains a single integer $ n $ ( $ 1<=n<=100000 $ ) — the width of the photo.

The second line contains a sequence of integers $ a_{1},a_{2},...,a_{n} $ ( $ 0<=a_{i}<=1 $ ) — the description of the photo. If $ a_{i} $ is zero, the $ i $ -th column is all black. If $ a_{i} $ is one, then the $ i $ -th column is all white.

## 输出格式

If the photo can be a photo of zebra, print "YES" (without quotes). Otherwise, print "NO".

You can print each letter in any case (upper or lower).

## 说明/提示

The first two examples are described in the statements.

In the third example all pixels are white, so the photo can be a photo of zebra.

In the fourth example the width of the first stripe is equal to three (white color), the width of the second stripe is equal to three (black), and the width of the third stripe is equal to two (white). Thus, not all stripes have equal length, so this photo is not a photo of zebra.

## 样例 #1

### 输入

```
9
0 0 0 1 1 1 0 0 0

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
7
0 0 0 1 1 1 1

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
5
1 1 1 1 1

```

### 输出

```
YES

```

## 样例 #4

### 输入

```
8
1 1 1 0 0 0 1 1

```

### 输出

```
NO

```

## 样例 #5

### 输入

```
9
1 1 0 1 1 0 1 1 0

```

### 输出

```
NO

```



---

---
title: "World Cup"
layout: "post"
diff: 普及-
pid: CF931B
tag: []
---

# World Cup

## 题目描述

世界杯足球赛的最后一个阶段是使用决赛系统进行的。

这个阶段还有n个团队，从1到n枚举。举行了几轮比赛，每轮比赛中，剩下的队伍按照ID的顺序进行排序，然后按此顺序的第一个队与第二个队比赛，第三个队与第四个队比赛，第五个队与第六个队比赛，依此类推。保证每轮比赛都有偶数支球队。每场比赛的胜利者晋级下一轮，失败者被淘汰出局，没有平局。在最后一轮比赛中，只有剩下的两支球队参加：这轮比赛称为决赛，获胜者称为冠军，比赛结束。

Arkady想让他最喜欢的两支球队参加决赛。不幸的是，团队ID已经确定了，而且可能会发生这样的情况：如果团队足够强大的话，他们就不可能在决赛中相遇，因为他们将在更早的阶段相遇。确定ID A和B的团队可以在哪一轮会面。

## 输入格式

一行包含三个整数n，a和b（2<=n<=256，2<=n<=256，1<=a，b<=n，1<=a，b<=n）团队总数和Arkady感兴趣的团队的ID。

可以保证n是这样的：在每轮比赛中，队伍前进的次数是偶数，a和b不相等。

## 输出格式

在唯一一行输出“Final!”，如果A队和B队能在决赛中相遇。

否则，输出一个整数,a队和b队可以相遇的轮数。该轮从1开始计算。

## 说明/提示

在第一个例子中，1队和2队在第一轮比赛中相遇。

在第二个例子中，2队和6队只能在第三轮比赛中相遇，这是决赛，前提是他们在前几轮中赢得了所有的对手。

在第三个例子中，如果在第一轮中赢得对手，IDS7和55的球队可以在第二轮中相遇。

## 样例 #1

### 输入

```
4 1 2

```

### 输出

```
1

```

## 样例 #2

### 输入

```
8 2 6

```

### 输出

```
Final!

```

## 样例 #3

### 输入

```
8 7 5

```

### 输出

```
2

```



---

---
title: "Fafa and the Gates"
layout: "post"
diff: 普及-
pid: CF935B
tag: []
---

# Fafa and the Gates

## 题目描述

Two neighboring kingdoms decided to build a wall between them with some gates to enable the citizens to go from one kingdom to another. Each time a citizen passes through a gate, he has to pay one silver coin.

The world can be represented by the first quadrant of a plane and the wall is built along the identity line (i.e. the line with the equation $ x=y $ ). Any point below the wall belongs to the first kingdom while any point above the wall belongs to the second kingdom. There is a gate at any integer point on the line (i.e. at points $ (0,0) $ , $ (1,1) $ , $ (2,2) $ , ...). The wall and the gates do not belong to any of the kingdoms.

Fafa is at the gate at position $ (0,0) $ and he wants to walk around in the two kingdoms. He knows the sequence $ S $ of moves he will do. This sequence is a string where each character represents a move. The two possible moves Fafa will do are 'U' (move one step up, from $ (x,y) $ to $ (x,y+1) $ ) and 'R' (move one step right, from $ (x,y) $ to $ (x+1,y) $ ).

Fafa wants to know the number of silver coins he needs to pay to walk around the two kingdoms following the sequence $ S $ . Note that if Fafa visits a gate without moving from one kingdom to another, he pays no silver coins. Also assume that he doesn't pay at the gate at point $ (0,0) $ , i. e. he is initially on the side he needs.

## 输入格式

The first line of the input contains single integer $ n $ $ (1<=n<=10^{5}) $ — the number of moves in the walking sequence.

The second line contains a string $ S $ of length $ n $ consisting of the characters 'U' and 'R' describing the required moves. Fafa will follow the sequence $ S $ in order from left to right.

## 输出格式

On a single line, print one integer representing the number of silver coins Fafa needs to pay at the gates to follow the sequence $ S $ .

## 说明/提示

The figure below describes the third sample. The red arrows represent the sequence of moves Fafa will follow. The green gates represent the gates at which Fafa have to pay silver coins.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF935B/b75712c03fca29d89953f4e50f7a0d99cb311364.png)

## 样例 #1

### 输入

```
1
U

```

### 输出

```
0

```

## 样例 #2

### 输入

```
6
RURUUR

```

### 输出

```
1

```

## 样例 #3

### 输入

```
7
URRRUUU

```

### 输出

```
2

```



---

---
title: "Run For Your Prize"
layout: "post"
diff: 普及-
pid: CF938B
tag: []
---

# Run For Your Prize

## 题目描述

You and your friend are participating in a TV show "Run For Your Prize".

At the start of the show $ n $ prizes are located on a straight line. $ i $ -th prize is located at position $ a_{i} $ . Positions of all prizes are distinct. You start at position $ 1 $ , your friend — at position $ 10^{6} $ (and there is no prize in any of these two positions). You have to work as a team and collect all prizes in minimum possible time, in any order.

You know that it takes exactly $ 1 $ second to move from position $ x $ to position $ x+1 $ or $ x-1 $ , both for you and your friend. You also have trained enough to instantly pick up any prize, if its position is equal to your current position (and the same is true for your friend). Carrying prizes does not affect your speed (or your friend's speed) at all.

Now you may discuss your strategy with your friend and decide who will pick up each prize. Remember that every prize must be picked up, either by you or by your friend.

What is the minimum number of seconds it will take to pick up all the prizes?

## 输入格式

The first line contains one integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of prizes.

The second line contains $ n $ integers $ a_{1} $ , $ a_{2} $ , ..., $ a_{n} $ ( $ 2<=a_{i}<=10^{6}-1 $ ) — the positions of the prizes. No two prizes are located at the same position. Positions are given in ascending order.

## 输出格式

Print one integer — the minimum number of seconds it will take to collect all prizes.

## 说明/提示

In the first example you take all the prizes: take the first at $ 1 $ , the second at $ 2 $ and the third at $ 8 $ .

In the second example you take the first prize in $ 1 $ second and your friend takes the other in $ 5 $ seconds, you do this simultaneously, so the total time is $ 5 $ .

## 样例 #1

### 输入

```
3
2 3 9

```

### 输出

```
8

```

## 样例 #2

### 输入

```
2
2 999995

```

### 输出

```
5

```



---

---
title: "Weird Subtraction Process"
layout: "post"
diff: 普及-
pid: CF946B
tag: []
---

# Weird Subtraction Process

## 题目描述

两个数 $a$ 和 $b$ 要对它们做以下操作:

1. 如果 $a=0$ 或 $b=0$ ，结束程序。否则执行第 $2$ 步。

2. 如果 $a\geq2b$ ，把 $a$ 变为 $a-2b$ ，并返回第 $1$ 步。否则执行第 $3$ 步。

3. 如果 $b\geq 2 a$ ，把 $b$ 变为 $b-2a$，并返回第 $1$ 步。否则结束程序。

你需要将 $a,b$ 持续进行操作直到结束程序，输出结束程序时的 $a,b$。

## 输入格式

一行包含两个整数 $a$ 和 $b$（$1 \leq a,b \leq 10^{18}$）。

## 输出格式

对 $a,b$ 持续进行操作直到结束程序，输出结束程序时的 $a,b$ 值，用空格隔开。

## 样例 #1

### 输入

```
12 5

```

### 输出

```
0 1

```

## 样例 #2

### 输入

```
31 12

```

### 输出

```
7 12

```



---

---
title: "String Transformation"
layout: "post"
diff: 普及-
pid: CF946C
tag: []
---

# String Transformation

## 题目描述

You are given a string $ s $ consisting of $ |s| $ small english letters.

In one move you can replace any character of this string to the next character in alphabetical order (a will be replaced with b, s will be replaced with t, etc.). You cannot replace letter z with any other letter.

Your target is to make some number of moves (not necessary minimal) to get string abcdefghijklmnopqrstuvwxyz (english alphabet) as a subsequence. Subsequence of the string is the string that is obtained by deleting characters at some positions. You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible.

## 输入格式

The only one line of the input consisting of the string $ s $ consisting of $ |s| $ ( $ 1<=|s|<=10^{5} $ ) small english letters.

## 输出格式

If you can get a string that can be obtained from the given string and will contain english alphabet as a subsequence, print it. Otherwise print «-1» (without quotes).

## 样例 #1

### 输入

```
aacceeggiikkmmooqqssuuwwyy

```

### 输出

```
abcdefghijklmnopqrstuvwxyz

```

## 样例 #2

### 输入

```
thereisnoanswer

```

### 输出

```
-1

```



---

---
title: "Restoring Password"
layout: "post"
diff: 普及-
pid: CF94A
tag: []
---

# Restoring Password

## 题目描述

Igor K. always used to trust his favorite Kashpirovsky Antivirus. That is why he didn't hesitate to download the link one of his groupmates sent him via QIP Infinium. The link was said to contain "some real funny stuff about swine influenza". The antivirus had no objections and Igor K. run the flash application he had downloaded. Immediately his QIP Infinium said: "invalid login/password".

Igor K. entered the ISQ from his additional account and looked at the info of his main one. His name and surname changed to "H1N1" and "Infected" correspondingly, and the "Additional Information" field contained a strange-looking binary code $ 80 $ characters in length, consisting of zeroes and ones. "I've been hacked" — thought Igor K. and run the Internet Exploiter browser to quickly type his favourite search engine's address.

Soon he learned that it really was a virus that changed ISQ users' passwords. Fortunately, he soon found out that the binary code was actually the encrypted password where each group of $ 10 $ characters stood for one decimal digit. Accordingly, the original password consisted of $ 8 $ decimal digits.

Help Igor K. restore his ISQ account by the encrypted password and encryption specification.

## 输入格式

The input data contains $ 11 $ lines. The first line represents the binary code $ 80 $ characters in length. That is the code written in Igor K.'s ISQ account's info. Next $ 10 $ lines contain pairwise distinct binary codes $ 10 $ characters in length, corresponding to numbers 0, 1, ..., 9.

## 输出格式

Print one line containing $ 8 $ characters — The password to Igor K.'s ISQ account. It is guaranteed that the solution exists.

## 样例 #1

### 输入

```
01001100100101100000010110001001011001000101100110010110100001011010100101101100
0100110000
0100110010
0101100000
0101100010
0101100100
0101100110
0101101000
0101101010
0101101100
0101101110

```

### 输出

```
12345678

```

## 样例 #2

### 输入

```
10101101111001000010100100011010101101110010110111011000100011011110010110001000
1001000010
1101111001
1001000110
1010110111
0010110111
1101001101
1011000001
1110010101
1011011000
0110001000

```

### 输出

```
30234919

```



---

---
title: "Left-handers, Right-handers and Ambidexters"
layout: "post"
diff: 普及-
pid: CF950A
tag: []
---

# Left-handers, Right-handers and Ambidexters

## 题目描述

你现在在一个运动队里。

这个队里有l 个人只能用他的左手训练（左撇子），另外有r 个人只能用右手训练（右撇子），还有a 个两只手都可以训练的人（既不是左撇子也不是右撇子，但只能用一只手）。

你们的教练决定组建一支队伍，但要保证队伍里用左手训练的人和用右手训练的人一样多。 你的任务是找到这个团队里最多能有多少个人。

## 输入格式

输入的是3个整数l,r,a(0<=l,r,a<=100)，代表左撇子，右撇子和既不是左撇子也不是右撇子的人数。

## 输出格式

输出一个整数，代表这个队伍里最多有多少人，如果组不成这样的队伍，则输出0 .

Translated by @cn：苏卿念

## 样例 #1

### 输入

```
1 4 2

```

### 输出

```
6

```

## 样例 #2

### 输入

```
5 5 5

```

### 输出

```
14

```

## 样例 #3

### 输入

```
0 2 0

```

### 输出

```
0

```



---

---
title: "Diagonal Walking"
layout: "post"
diff: 普及-
pid: CF954A
tag: []
---

# Diagonal Walking

## 题目描述

Mikhail walks on a 2D plane. He can go either up or right. You are given a sequence of Mikhail's moves. He thinks that this sequence is too long and he wants to make it as short as possible.

In the given sequence moving up is described by character U and moving right is described by character R. Mikhail can replace any pair of consecutive moves RU or UR with a diagonal move (described as character D). After that, he can go on and do some other replacements, until there is no pair of consecutive moves RU or UR left.

Your problem is to print the minimum possible length of the sequence of moves after the replacements.

## 输入格式

The first line of the input contains one integer $ n $ ( $ 1<=n<=100 $ ) — the length of the sequence. The second line contains the sequence consisting of $ n $ characters U and R.

## 输出格式

Print the minimum possible length of the sequence of moves after all replacements are done.

## 说明/提示

In the first test the shortened sequence of moves may be DUD (its length is $ 3 $ ).

In the second test the shortened sequence of moves can be UUDRRRDUDDUUU (its length is $ 13 $ ).

## 样例 #1

### 输入

```
5
RUURU

```

### 输出

```
3

```

## 样例 #2

### 输入

```
17
UUURRRRRUUURURUUU

```

### 输出

```
13

```



---

---
title: "Tritonic Iridescence"
layout: "post"
diff: 普及-
pid: CF957A
tag: []
---

# Tritonic Iridescence

## 题目描述

Overlooking the captivating blend of myriads of vernal hues, Arkady the painter lays out a long, long canvas.

Arkady has a sufficiently large amount of paint of three colours: cyan, magenta, and yellow. On the one-dimensional canvas split into $ n $ consecutive segments, each segment needs to be painted in one of the colours.

Arkady has already painted some (possibly none or all) segments and passes the paintbrush to you. You are to determine whether there are at least two ways of colouring all the unpainted segments so that no two adjacent segments are of the same colour. Two ways are considered different if and only if a segment is painted in different colours in them.

## 输入格式

The first line contains a single positive integer $ n $ ( $ 1<=n<=100 $ ) — the length of the canvas.

The second line contains a string $ s $ of $ n $ characters, the $ i $ -th of which is either 'C' (denoting a segment painted in cyan), 'M' (denoting one painted in magenta), 'Y' (one painted in yellow), or '?' (an unpainted one).

## 输出格式

If there are at least two different ways of painting, output "Yes"; otherwise output "No" (both without quotes).

You can print each character in any case (upper or lower).

## 说明/提示

For the first example, there are exactly two different ways of colouring: CYCMY and CYMCY.

For the second example, there are also exactly two different ways of colouring: CMCMY and CYCMY.

For the third example, there are four ways of colouring: MCYCM, MCYCY, YCYCM, and YCYCY.

For the fourth example, no matter how the unpainted segments are coloured, the existing magenta segments will prevent the painting from satisfying the requirements. The similar is true for the fifth example.

## 样例 #1

### 输入

```
5
CY??Y

```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
5
C?C?Y

```

### 输出

```
Yes

```

## 样例 #3

### 输入

```
5
?CYC?

```

### 输出

```
Yes

```

## 样例 #4

### 输入

```
5
C??MM

```

### 输出

```
No

```

## 样例 #5

### 输入

```
3
MMY

```

### 输出

```
No

```



---

---
title: "Maximum Control (easy)"
layout: "post"
diff: 普及-
pid: CF958B1
tag: []
---

# Maximum Control (easy)

## 题目描述

The Resistance is trying to take control over all planets in a particular solar system. This solar system is shaped like a tree. More precisely, some planets are connected by bidirectional hyperspace tunnels in such a way that there is a path between every pair of the planets, but removing any tunnel would disconnect some of them.

The Resistance already has measures in place that will, when the time is right, enable them to control every planet that is not remote. A planet is considered to be remote if it is connected to the rest of the planets only via a single hyperspace tunnel.

How much work is there left to be done: that is, how many remote planets are there?

## 输入格式

The first line of the input contains an integer $ N $ ( $ 2<=N<=1000 $ ) – the number of planets in the galaxy.

The next $ N-1 $ lines describe the hyperspace tunnels between the planets. Each of the $ N-1 $ lines contains two space-separated integers $ u $ and $ v $ ( $ 1<=u,v<=N $ ) indicating that there is a bidirectional hyperspace tunnel between the planets $ u $ and $ v $ . It is guaranteed that every two planets are connected by a path of tunnels, and that each tunnel connects a different pair of planets.

## 输出格式

A single integer denoting the number of remote planets.

## 说明/提示

In the first example, only planets $ 2 $ , $ 3 $ and $ 5 $ are connected by a single tunnel.

In the second example, the remote planets are $ 2 $ and $ 3 $ .

Note that this problem has only two versions – easy and medium.

## 样例 #1

### 输入

```
5
4 1
4 2
1 3
1 5

```

### 输出

```
3

```

## 样例 #2

### 输入

```
4
1 2
4 3
1 4

```

### 输出

```
2

```



---

---
title: "Mahmoud and Ehab and the even-odd game"
layout: "post"
diff: 普及-
pid: CF959A
tag: []
---

# Mahmoud and Ehab and the even-odd game

## 题目描述

Mahmoud和Ehab正在玩一款叫做“奇偶”的游戏。Ehab选择了一个他最喜欢的整数n然后他们开始玩这个游戏（从Mahmoud开始）在每个人的回合中，他必须选择一个数a，然后从n中减去它。

条件：

     1<=a<=n.
     如果轮到Mahmoud，a必须是偶数。
     但如果轮到Ehab，a必须是奇数。
     
如果当前的玩家不能选择任何满足条件的数字，他就会输。请输出谁获胜了。

## 输入格式

只输入一个n（n1<=n<=10^9),n为游戏开始的数字。

## 输出格式

如果Mahmoud获胜了，就输出"Mahmoud"(没有引号)。
否则输出"Ehab"(没有引号）。

## 说明/提示

在样例1中，Mahmoud不能选择任何一个整数，因为没有一个正偶数小于（等于）1。所以Ehab获胜了。

在样例2中，Mahmoud应当选择a为2。从n中减去2。轮到Ehab的回合了，此时n=0。因为没有小于（等于）0的正奇数，所以Mahmoud获胜了。

## 样例 #1

### 输入

```
1

```

### 输出

```
Ehab
```

## 样例 #2

### 输入

```
2

```

### 输出

```
Mahmoud
```



---

---
title: "Lecture Sleep"
layout: "post"
diff: 普及-
pid: CF961B
tag: []
---

# Lecture Sleep

## 题目描述

Your friend Mishka and you attend a calculus lecture. Lecture lasts $ n $ minutes. Lecturer tells $ a_{i} $ theorems during the $ i $ -th minute.

Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array $ t $ of Mishka's behavior. If Mishka is asleep during the $ i $ -th minute of the lecture then $ t_{i} $ will be equal to $ 0 $ , otherwise it will be equal to $ 1 $ . When Mishka is awake he writes down all the theorems he is being told — $ a_{i} $ during the $ i $ -th minute. Otherwise he writes nothing.

You know some secret technique to keep Mishka awake for $ k $ minutes straight. However you can use it only once. You can start using it at the beginning of any minute between $ 1 $ and $ n-k+1 $ . If you use it on some minute $ i $ then Mishka will be awake during minutes $ j $ such that ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF961B/74a70105e36a7144196883409708a1b859a35796.png) and will write down all the theorems lecturer tells.

You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.

## 输入格式

The first line of the input contains two integer numbers $ n $ and $ k $ ( $ 1<=k<=n<=10^{5} $ ) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.

The second line of the input contains $ n $ integer numbers $ a_{1},a_{2},...\ a_{n} $ ( $ 1<=a_{i}<=10^{4} $ ) — the number of theorems lecturer tells during the $ i $ -th minute.

The third line of the input contains $ n $ integer numbers $ t_{1},t_{2},...\ t_{n} $ ( $ 0<=t_{i}<=1 $ ) — type of Mishka's behavior at the $ i $ -th minute of the lecture.

## 输出格式

Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.

## 说明/提示

In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to $ 16 $ .

## 样例 #1

### 输入

```
6 3
1 3 5 2 5 4
1 1 0 1 0 0

```

### 输出

```
16

```



---

---
title: "Aramic script"
layout: "post"
diff: 普及-
pid: CF975A
tag: []
---

# Aramic script

## 题目描述

In Aramic language words can only represent objects.

Words in Aramic have special properties:

- A word is a root if it does not contain the same letter more than once.
- A root and all its permutations represent the same object.
- The root $ x $ of a word $ y $ is the word that contains all letters that appear in $ y $ in a way that each letter appears once. For example, the root of "aaaa", "aa", "aaa" is "a", the root of "aabb", "bab", "baabb", "ab" is "ab".
- Any word in Aramic represents the same object as its root.

You have an ancient script in Aramic. What is the number of different objects mentioned in the script?

## 输入格式

The first line contains one integer $ n $ ( $ 1 \leq n \leq 10^3 $ ) — the number of words in the script.

The second line contains $ n $ words $ s_1, s_2, \ldots, s_n $ — the script itself. The length of each string does not exceed $ 10^3 $ .

It is guaranteed that all characters of the strings are small latin letters.

## 输出格式

Output one integer — the number of different objects mentioned in the given ancient Aramic script.

## 说明/提示

In the first test, there are two objects mentioned. The roots that represent them are "a","ab".

In the second test, there is only one object, its root is "amer", the other strings are just permutations of "amer".

## 样例 #1

### 输入

```
5
a aa aaa ab abb

```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
amer arem mrea

```

### 输出

```
1
```



---

---
title: "Mancala"
layout: "post"
diff: 普及-
pid: CF975B
tag: []
---

# Mancala

## 题目描述

在外国有一种棋，这种棋在一个有 $14$ 个孔的棋盘上玩。一开始，每个洞有 $a_i$ 个石头。当玩家操作的时候，他会选择一个石头个数为正整数的孔并把所有石头都放到这个孔里，然后逆时针把这些石头一个一个地重新分配到下一个洞里方向。逆时针方向的意思是：玩家将在第 $(i+1)$ 、第 $(i+2) \dots$ 个孔依次放入一块石头。如果玩家将一块石头放入第 $14$ 个孔，则下一个要放在第 $1$ 个孔里面。在操作之后，玩家将从包含偶数个石头的洞里收集所有的石头，收集的石头数就是得分。请问一次移动后得到的最高分数是多少？

## 输入格式

一行并且仅有 $14$ 个整数 $a_1,a_2,a_3, \dots,a_{14}$ 表示每个孔里面石头的初始数量。



保证对于任意的 $i$ ( $1 \leq i \leq 14$ ) ，满足 $a_i$ 不是 $0$ 就是奇数，且棋盘上至少有一块石头。

## 输出格式

输出一个整数，一次移动后的最大可能分数。

## 样例 #1

### 输入

```
0 1 1 0 0 0 0 0 0 7 0 0 0 0

```

### 输出

```
4

```

## 样例 #2

### 输入

```
5 1 1 1 1 0 0 0 0 0 0 0 0 0

```

### 输出

```
8

```



---

---
title: "Less or Equal"
layout: "post"
diff: 普及-
pid: CF977C
tag: []
---

# Less or Equal

## 题目描述

You are given a sequence of integers of length $ n $ and integer number $ k $ . You should print any integer number $ x $ in the range of $ [1; 10^9] $ (i.e. $ 1 \le x \le 10^9 $ ) such that exactly $ k $ elements of given sequence are less than or equal to $ x $ .

Note that the sequence can contain equal elements.

If there is no such $ x $ , print "-1" (without quotes).

## 输入格式

The first line of the input contains integer numbers $ n $ and $ k $ ( $ 1 \le n \le 2 \cdot 10^5 $ , $ 0 \le k \le n $ ). The second line of the input contains $ n $ integer numbers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the sequence itself.

## 输出格式

Print any integer number $ x $ from range $ [1; 10^9] $ such that exactly $ k $ elements of given sequence is less or equal to $ x $ .

If there is no such $ x $ , print "-1" (without quotes).

## 说明/提示

In the first example $ 5 $ is also a valid answer because the elements with indices $ [1, 3, 4, 6] $ is less than or equal to $ 5 $ and obviously less than or equal to $ 6 $ .

In the second example you cannot choose any number that only $ 2 $ elements of the given sequence will be less than or equal to this number because $ 3 $ elements of the given sequence will be also less than or equal to this number.

## 样例 #1

### 输入

```
7 4
3 7 5 1 10 3 20

```

### 输出

```
6
```

## 样例 #2

### 输入

```
7 2
3 7 5 1 10 3 20

```

### 输出

```
-1

```



---

---
title: "Letters"
layout: "post"
diff: 普及-
pid: CF978C
tag: []
---

# Letters

## 题目描述

There are $ n $ dormitories in Berland State University, they are numbered with integers from $ 1 $ to $ n $ . Each dormitory consists of rooms, there are $ a_i $ rooms in $ i $ -th dormitory. The rooms in $ i $ -th dormitory are numbered from $ 1 $ to $ a_i $ .

A postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all $ n $ dormitories is written on an envelope. In this case, assume that all the rooms are numbered from $ 1 $ to $ a_1 + a_2 + \dots + a_n $ and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on.

For example, in case $ n=2 $ , $ a_1=3 $ and $ a_2=5 $ an envelope can have any integer from $ 1 $ to $ 8 $ written on it. If the number $ 7 $ is written on an envelope, it means that the letter should be delivered to the room number $ 4 $ of the second dormitory.

For each of $ m $ letters by the room number among all $ n $ dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered.

## 输入格式

The first line contains two integers $ n $ and $ m $ $ (1 \le n, m \le 2 \cdot 10^{5}) $ — the number of dormitories and the number of letters.

The second line contains a sequence $ a_1, a_2, \dots, a_n $ $ (1 \le a_i \le 10^{10}) $ , where $ a_i $ equals to the number of rooms in the $ i $ -th dormitory. The third line contains a sequence $ b_1, b_2, \dots, b_m $ $ (1 \le b_j \le a_1 + a_2 + \dots + a_n) $ , where $ b_j $ equals to the room number (among all rooms of all dormitories) for the $ j $ -th letter. All $ b_j $ are given in increasing order.

## 输出格式

Print $ m $ lines. For each letter print two integers $ f $ and $ k $ — the dormitory number $ f $ $ (1 \le f \le n) $ and the room number $ k $ in this dormitory $ (1 \le k \le a_f) $ to deliver the letter.

## 说明/提示

In the first example letters should be delivered in the following order:

- the first letter in room $ 1 $ of the first dormitory
- the second letter in room $ 9 $ of the first dormitory
- the third letter in room $ 2 $ of the second dormitory
- the fourth letter in room $ 13 $ of the second dormitory
- the fifth letter in room $ 1 $ of the third dormitory
- the sixth letter in room $ 12 $ of the third dormitory

## 样例 #1

### 输入

```
3 6
10 15 12
1 9 12 23 26 37

```

### 输出

```
1 1
1 9
2 2
2 13
3 1
3 12

```

## 样例 #2

### 输入

```
2 3
5 10000000000
5 6 9999999999

```

### 输出

```
1 5
2 1
2 9999999994

```



---

---
title: "Pizza, Pizza, Pizza!!!"
layout: "post"
diff: 普及-
pid: CF979A
tag: []
---

# Pizza, Pizza, Pizza!!!

## 题目描述

Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.

Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.

She has ordered a very big round pizza, in order to serve her many friends. Exactly $ n $ of Shiro's friends are here. That's why she has to divide the pizza into $ n + 1 $ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.

Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.

As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?

## 输入格式

A single line contains one non-negative integer $ n $ ( $ 0 \le n \leq 10^{18} $ ) — the number of Shiro's friends. The circular pizza has to be sliced into $ n + 1 $ pieces.

## 输出格式

A single integer — the number of straight cuts Shiro needs.

## 说明/提示

To cut the round pizza into quarters one has to make two cuts through the center with angle $ 90^{\circ} $ between them.

To cut the round pizza into five equal parts one has to make five cuts.

## 样例 #1

### 输入

```
3

```

### 输出

```
2
```

## 样例 #2

### 输入

```
4

```

### 输出

```
5
```



---

---
title: "Businessmen Problems"
layout: "post"
diff: 普及-
pid: CF981B
tag: []
---

# Businessmen Problems

## 题目描述

Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.

In order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.

All elements are enumerated with integers. The ChemForces company has discovered $ n $ distinct chemical elements with indices $ a_1, a_2, \ldots, a_n $ , and will get an income of $ x_i $ Berland rubles if the $ i $ -th element from this list is in the set of this company.

The TopChemist company discovered $ m $ distinct chemical elements with indices $ b_1, b_2, \ldots, b_m $ , and it will get an income of $ y_j $ Berland rubles for including the $ j $ -th element from this list to its set.

In other words, the first company can present any subset of elements from $ \{a_1, a_2, \ldots, a_n\} $ (possibly empty subset), the second company can present any subset of elements from $ \{b_1, b_2, \ldots, b_m\} $ (possibly empty subset). There shouldn't be equal elements in the subsets.

Help the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.

## 输入格式

The first line contains a single integer $ n $ ( $ 1 \leq n \leq 10^5 $ ) — the number of elements discovered by ChemForces.

The $ i $ -th of the next $ n $ lines contains two integers $ a_i $ and $ x_i $ ( $ 1 \leq a_i \leq 10^9 $ , $ 1 \leq x_i \leq 10^9 $ ) — the index of the $ i $ -th element and the income of its usage on the exhibition. It is guaranteed that all $ a_i $ are distinct.

The next line contains a single integer $ m $ ( $ 1 \leq m \leq 10^5 $ ) — the number of chemicals invented by TopChemist.

The $ j $ -th of the next $ m $ lines contains two integers $ b_j $ and $ y_j $ , ( $ 1 \leq b_j \leq 10^9 $ , $ 1 \leq y_j \leq 10^9 $ ) — the index of the $ j $ -th element and the income of its usage on the exhibition. It is guaranteed that all $ b_j $ are distinct.

## 输出格式

Print the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.

## 说明/提示

In the first example ChemForces can choose the set ( $ 3, 7 $ ), while TopChemist can choose ( $ 1, 2, 4 $ ). This way the total income is $ (10 + 2) + (4 + 4 + 4) = 24 $ .

In the second example ChemForces can choose the only element $ 10^9 $ , while TopChemist can choose ( $ 14, 92, 35 $ ). This way the total income is $ (239) + (15 + 65 + 89) = 408 $ .

## 样例 #1

### 输入

```
3
1 2
7 2
3 10
4
1 4
2 4
3 4
4 4

```

### 输出

```
24

```

## 样例 #2

### 输入

```
1
1000000000 239
3
14 15
92 65
35 89

```

### 输出

```
408

```



---

---
title: "Bus of Characters"
layout: "post"
diff: 普及-
pid: CF982B
tag: []
---

# Bus of Characters

## 题目描述

在一辆公交车中有 $n$ 排座位，每一排有两个座位。第 $i$ 排的两个座位的宽度均为 $w_i$ 。所有的 $w_i$ 互不相同。



初始时，公交车是空的。接下来会依次停靠 $2n$ 个站，每一站将上来一名乘客。乘客分为两类：

- 内向者：此类乘客总是会选择两个座位都是空的那一排就坐，如果有多排都是空的，他将会选择 $w_i$ 最小的那一排中任意一个空座坐下。

- 外向者：此类乘客总是会选择已有一人就坐（当然是内向者）的那一排，如果有多排都满足条件，他会选择 $w_i$ 最大的那一排的空座坐下。



现在给定每一排的宽度 $w_i$ 以及乘客上车的顺序。请确定每一个乘客将会选择哪一排坐下。

## 输入格式

第一行包括一个整数 $n$ ($1\leqslant n \leqslant 200000$)——公交车中座位的排数。



第二行为一个序列 $w_1,w_2,\dots,w_n$($1\leqslant w_i \leqslant 10^9$)，其中 $w_i$ 为第 $i$ 排的座位的宽度。保证所有的 $w_i$ 互不相同。



第三行是一个长度为 $2n$ 的01字符串，表示乘客上车的顺序。如果第 $j$ 个字符为'0'，表示第 $j$ 名乘客是内向者，如果第 $j$ 个字符为'1'，表示第 $j$ 名乘客是外向者。**数据保证内向者和外向者人数相同（即均为 $n$ ），对每一名上车的外向者，保证有空座位可以坐。**

## 输出格式

输出 $2n$ 个整数，空格分开，表示每名乘客会选哪一排就座。

## 说明/提示

在第一个样例中：



第1名乘客（内向者）选择了第2排（由于它的宽度最小）。



第2名乘客（内向者）选择了第1排（由于它是唯一的没有人坐的那排）。



第3名乘客（外向者）选择了第1排（由于它正好是有一个人落座，并且宽度最大）。



第4名乘客（外向者）选择了第2排（由于它是唯一的有空座的那排）。

## 样例 #1

### 输入

```
2
3 1
0011

```

### 输出

```
2 1 1 2 

```

## 样例 #2

### 输入

```
6
10 8 9 11 13 5
010010011101

```

### 输出

```
6 6 2 3 3 1 4 4 1 2 5 5 

```



---

---
title: "Minesweeper"
layout: "post"
diff: 普及-
pid: CF984B
tag: []
---

# Minesweeper

## 题目描述

One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.

Alex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?

He needs your help to check it.

A Minesweeper field is a rectangle $ n \times m $ , where each cell is either empty, or contains a digit from $ 1 $ to $ 8 $ , or a bomb. The field is valid if for each cell:

- if there is a digit $ k $ in the cell, then exactly $ k $ neighboring cells have bombs.
- if the cell is empty, then all neighboring cells have no bombs.

Two cells are neighbors if they have a common side or a corner (i. e. a cell has at most $ 8 $ neighboring cells).

## 输入格式

The first line contains two integers $ n $ and $ m $ ( $ 1 \le n, m \le 100 $ ) — the sizes of the field.

The next $ n $ lines contain the description of the field. Each line contains $ m $ characters, each of them is "." (if this cell is empty), "\*" (if there is bomb in this cell), or a digit from $ 1 $ to $ 8 $ , inclusive.

## 输出格式

Print "YES", if the field is valid and "NO" otherwise.

You can choose the case (lower or upper) for each letter arbitrarily.

## 说明/提示

In the second example the answer is "NO" because, if the positions of the bombs are preserved, the first line of the field should be \*2\*1.

You can read more about Minesweeper in <a>Wikipedia's article</a>.

## 样例 #1

### 输入

```
3 3
111
1*1
111

```

### 输出

```
YES
```

## 样例 #2

### 输入

```
2 4
*.*.
1211

```

### 输出

```
NO
```



---

---
title: "Substrings Sort"
layout: "post"
diff: 普及-
pid: CF988B
tag: []
---

# Substrings Sort

## 题目描述

给定一个数n和n个字符串，求一个重新排列，对于新排列中的每个字符串
都满足在它前面的串都是它的子串。 


感谢@南方不败 提供翻译

## 输入格式

第一行n，第二行开始n个字符串

## 样例 #1

### 输入

```
5
a
aba
abacaba
ba
aba

```

### 输出

```
YES
a
ba
aba
aba
abacaba

```

## 样例 #2

### 输入

```
5
a
abacaba
ba
aba
abab

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
3
qwerty
qwerty
qwerty

```

### 输出

```
YES
qwerty
qwerty
qwerty

```



---

---
title: "Balloons"
layout: "post"
diff: 普及-
pid: CF998A
tag: []
---

# Balloons

## 题目描述

There are quite a lot of ways to have fun with inflatable balloons. For example, you can fill them with water and see what happens.

Grigory and Andrew have the same opinion. So, once upon a time, they went to the shop and bought $ n $ packets with inflatable balloons, where $ i $ -th of them has exactly $ a_i $ balloons inside.

They want to divide the balloons among themselves. In addition, there are several conditions to hold:

- Do not rip the packets (both Grigory and Andrew should get unbroken packets);
- Distribute all packets (every packet should be given to someone);
- Give both Grigory and Andrew at least one packet;
- To provide more fun, the total number of balloons in Grigory's packets should not be equal to the total number of balloons in Andrew's packets.

Help them to divide the balloons or determine that it's impossible under these conditions.

## 输入格式

The first line of input contains a single integer $ n $ ( $ 1 \le n \le 10 $ ) — the number of packets with balloons.

The second line contains $ n $ integers: $ a_1 $ , $ a_2 $ , $ \ldots $ , $ a_n $ ( $ 1 \le a_i \le 1000 $ ) — the number of balloons inside the corresponding packet.

## 输出格式

If it's impossible to divide the balloons satisfying the conditions above, print $ -1 $ .

Otherwise, print an integer $ k $ — the number of packets to give to Grigory followed by $ k $ distinct integers from $ 1 $ to $ n $ — the indices of those. The order of packets doesn't matter.

If there are multiple ways to divide balloons, output any of them.

## 说明/提示

In the first test Grigory gets $ 3 $ balloons in total while Andrey gets $ 1 $ .

In the second test there's only one way to divide the packets which leads to equal numbers of balloons.

In the third test one of the boys won't get a packet at all.

## 样例 #1

### 输入

```
3
1 2 1

```

### 输出

```
2
1 2

```

## 样例 #2

### 输入

```
2
5 5

```

### 输出

```
-1

```

## 样例 #3

### 输入

```
1
10

```

### 输出

```
-1

```



---

---
title: "Mishka and Contest"
layout: "post"
diff: 普及-
pid: CF999A
tag: []
---

# Mishka and Contest

## 题目描述

给出长度为 $n$ 的数列，每次只能删除右端或左端小于等于 $k$ 的数，求最多能删除几个数。

## 输入格式

- 第一行 $n, k$；
- 第二行输入 $n$ 个数，表示要删除的数列。

## 输出格式

- 一个数，表示最多能删除几个数。

## 样例 #1

### 输入

```
8 4
4 2 3 1 5 1 6 4

```

### 输出

```
5

```

## 样例 #2

### 输入

```
5 2
3 1 2 1 3

```

### 输出

```
0

```

## 样例 #3

### 输入

```
5 100
12 34 55 43 21

```

### 输出

```
5

```



---

---
title: "Help Far Away Kingdom"
layout: "post"
diff: 普及-
pid: CF99A
tag: []
---

# Help Far Away Kingdom

## 题目描述

In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.

Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly $ 0.273549107 $ beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this:

- If a number's integer part does not end with digit $ 9 $ and its fractional part is strictly less than $ 0.5 $ , then the rounded up number coincides with the number’s integer part.
- If a number's integer part does not end with digit $ 9 $ and its fractional part is not less than $ 0.5 $ , the rounded up number is obtained if we add $ 1 $ to the last digit of the number’s integer part.
- If the number’s integer part ends with digit $ 9 $ , to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position.

Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order?

## 输入格式

The first line contains a single number to round up — the integer part (a non-empty set of decimal digits that do not start with $ 0 $ — with the exception of a case when the set consists of a single digit — in this case 0 can go first), then follows character «.» (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed $ 1000 $ characters, including the dot. There are no other characters in the input data.

## 输出格式

If the last number of the integer part is not equal to $ 9 $ , print the rounded-up number without leading zeroes. Otherwise, print the message "GOTO Vasilisa." (without the quotes).

## 样例 #1

### 输入

```
0.0

```

### 输出

```
0
```

## 样例 #2

### 输入

```
1.49

```

### 输出

```
1
```

## 样例 #3

### 输入

```
1.50

```

### 输出

```
2
```

## 样例 #4

### 输入

```
2.71828182845904523536

```

### 输出

```
3
```

## 样例 #5

### 输入

```
3.14159265358979323846

```

### 输出

```
3
```

## 样例 #6

### 输入

```
12345678901234567890.1

```

### 输出

```
12345678901234567890
```

## 样例 #7

### 输入

```
123456789123456789.999

```

### 输出

```
GOTO Vasilisa.
```



---

---
title: "Running Student"
layout: "post"
diff: 普及-
pid: CF9B
tag: []
---

# Running Student

## 题目描述

一位可怜的学生再次遭遇不幸——他要考试迟到了。

【他所在的地区可以看成一个平面直角坐标系，】他跑到了位于(0,0)处的公交车站，上了一辆小巴。这辆小巴沿x轴向x轴正方向行驶。

这个学生知道这样一些事：

这辆小巴将停靠n个站点，其中第i个站点位于(xi,0)处。

每一个站点的坐标都不相同。

这辆小巴将以速度vb匀速行驶。

小巴停站的时间很短，可以忽略不计。

乘客只能在站点上下车。

乘客最晚必须在终点站下车。

考试地点在(xu,yu)处。

他可以用vs的速度匀速从一个车站跑向考试地点。

在平面直角坐标系内，两点间的距离可以用![](https://cdn.luogu.org/upload/vjudge_pic/CF9B/22fd88ba9a7f84161b680cf39a97d9a06bc287ba.png)表示

他不能在上车站下车。
这个可怜的学生想用尽可能短的时间到达考试地点。请你帮他选择一个可以达到他的目的的下车地点。如果有多个满足的下车地点，请输出离考试地点最近的一个。

## 输入格式

输入的第一行包括三个整数：n,vb和vs。第二行包括n个升序排序的非负整数，第i个数表示第i个站点的横坐标。第1个数一定等于0。第三行包括两个整数，依次为考试地点的横坐标xu和纵坐标yu。

## 输出格式

输出一行，一个整数，他应该下车站的序号。

## 说明/提示

保证2<=n<=100,1<=vb,vs<=1000,0<=xi<=10^5,0<=|xu|,|yu|<=10^5

其他

就像你所知道的一样，学生通常是匆匆忙忙的，但小巴通常不是。所以如果你发现学生的速度比小巴快，不要吃惊。

## 样例 #1

### 输入

```
4 5 2
0 2 4 6
4 1

```

### 输出

```
3
```

## 样例 #2

### 输入

```
2 1 1
0 100000
100000 100000

```

### 输出

```
2
```



---


---
title: "MP3"
layout: "post"
diff: 普及/提高-
pid: CF1198A
tag: []
---

# MP3

## 题目描述

有一种数字化一段录音的常用方式，是记录每一个时刻的强度值。这些非负的强度值就可以代表一段音频

对于一段音频，若有 $K$ 个不同的强度值，那么每一位我们都需要 $k = \lceil\log_2K \rceil$ $\text{bit}$ 来存储

也就是说，为了存储这一段音频，我们需要 $nk$ 个 $\text{bit}$

为了压缩音频大小，我们们采取如下的方式：

选择两个整数 $l, r(l \leq r)$，对于音频的强度值序列 $v$，将其作一次变换：

$$
v_i = 
\begin{cases}
v_i&l \leq v_i \leq r \\
l &v_i < l\\
r &r < v_i
\end{cases}
$$

其中第 $2, 3$ 种情况被视作 $v_i$ 这个强度值被更改了

你的任务是对于给定的强度值序列 $a$，找到一组 $l, r$，使得在经过上述压缩后能够被大小为 $I \ \text{bytes} (\text{1bytes = 8 bit})$ 的存储器装下，并最小化被更改的强度值的数量

## 输入格式

第一行包含两个正整数 $n,I \ (n \leq 4 \cdot 10^5, I \leq 10^8)$，描述了音量总时刻数与存储器大小

第二行包含 $n$ 个正整数

对于第 $i$ 个数，描述了 $a_i$，即时刻 $i$ 的音量强度值

## 输出格式

输出答案，即在所有的适合存储器大小的压缩方案中，最小的被更改的强度值的数量

## 样例 #1

### 输入

```
6 1
2 1 2 3 4 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
6 2
2 1 2 3 4 3

```

### 输出

```
0

```

## 样例 #3

### 输入

```
6 1
1 1 2 2 3 3

```

### 输出

```
2

```


---
title: "Сортировка слиянием"
layout: "post"
diff: 难度0
pid: CF1531E3
tag: []
---

# Сортировка слиянием

## 题目描述

请看以下用 Python 编写的归并排序代码：

```
<pre class="lstlisting">```
def sort(a):
  n = len(a)
  b = [0 for i in range(n)]
  log = []

  def mergeSort(l, r):
    if r - l <= 1:
      return
    m = (l + r) >> 1
    mergeSort(l, m)
    mergeSort(m, r)
    i, j, k = l, m, l
    while i < m and j < r:
      if a[i] < a[j]:
        log.append('0')
        b[k] = a[i]
        i += 1
      else:
        log.append('1')
        b[k] = a[j]
        j += 1
      k += 1
    while i < m:
      b[k] = a[i]
      i += 1
      k += 1
    while j < r:
      b[k] = a[j]
      j += 1
      k += 1
    for p in range(l, r):
      a[p] = b[p]

  mergeSort(0, n)
  return "".join(log)
```
```

可以注意到，这段代码中用了日志记录，这是编程中一个非常重要的工具。

VK 的高级开发人员瓦西里生成了一个由 $n$ 个不同整数组成的排列 $a$（范围是从 $1$ 到 $n$），他把这个排列输入到 `sort` 函数中，得到了一个字符串 $s$。第二天，瓦西里找到了字符串 $s$，然而，他却弄丢了原始排列 $a$。

瓦西里希望能恢复出一个排列 $a$，使得通过 `sort` 函数再次运行后得到相同的字符串 $s$。请你帮帮他！

## 输入格式

输入中包含一个非空的字符串 $s$，这个字符串由 '0' 和 '1' 组成。

对于任意的测试数据，总存在一个长度不超过 $10^5$ 的排列满足上述条件。不过，你的答案长度可以任意，包括超过 $10^5$。

## 输出格式

第一行输出一个整数 $n$，表示排列的长度。

第二行输出 $n$ 个不同的整数 $a_0, a_1, \ldots, a_{n-1}$，这些整数是排列的元素，并且满足 $1 \le a_i \le n$。

如果有多个可能的答案，输出其中任何一个即可。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
00000000000000000000000000000000
```

### 输出

```
16
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
```

## 样例 #2

### 输入

```
11111111111111111111111111111111
```

### 输出

```
16
16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
```

## 样例 #3

### 输入

```
101011010001100100011011001111011000011110010
```

### 输出

```
16
13 6 1 7 12 5 4 15 14 16 10 11 3 8 9 2
```


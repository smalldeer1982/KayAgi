---
title: "Reverse Sort"
layout: "post"
diff: 普及-
pid: CF1605B
tag: ['贪心', '排序']
---

# Reverse Sort

## 题目描述

题目共给出 $t(1 \le t \le 1000)$ 组数据，每组数据包含一个正整数 $n(1 \le n \le 1000)$ 和一个长度为 $n$ 的 $01$ 串 $s$， 现在你需要在 $s$ 中选出一个子序列，将这个子序列中的字符翻转（如字符串 $10100$， 选出子序列 $1100$， 翻转得到 $0011$， 放回原串中得到 $00011$），使得翻转后的字符串字典序最小。

## 输入格式

第一行一个 $t$， 表示样例组数。

每组一个正整数 $t$ 和一个字符串 $s$， 表示字符串的长度和你将要进行操作的字符串。

## 输出格式

对于每组数据，第一行输出需要操作的次数（一次提取和一次翻转总称为一次操作，若不需修改则输出 $0$，详见样例），若操作次数不为零，则在第二行输出：

第一个数字 $k$，表示需要提取出来的数字个数，后 $k$ 个数字，表示提取出来的数字在原串中的位置（下标 + 1）

样例解释：

对于第一组样例，不需要进行任何操作，本身字典序最小，输出 $0$

对于第二组样例，需要进行一次操作，即将 $10100$ 中的 $1100$ 提取出来翻转，原串变为 $00011$

对于第三组样例，需要进行一次操作，即将 $001000$ 中的 $100$ 提取出来翻转，原串变为 $000001$

## 样例 #1

### 输入

```
3
7
0011111
5
10100
6
001000
```

### 输出

```
0
1
4 1 3 4 5 
1
3 3 5 6
```


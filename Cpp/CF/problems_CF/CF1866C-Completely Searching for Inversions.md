---
title: "Completely Searching for Inversions"
layout: "post"
diff: 提高+/省选-
pid: CF1866C
tag: []
---

# Completely Searching for Inversions

## 题目描述

给定一个有 $ N $ 个结点的有向无环图。结点 $ i $ 的出度为 $ S_i $。结点 $ i $ 的第 $ j $ 条出边指向 $ L_{i, j} $，边权为 $ W_{i, j} \text{ } (0 \le W_{i, j} \le 1) $。给出的图保证从结点 $ 1 $ 出发可以到达所有结点。

给定初始为空的数组 $ Z $。

定义函数 $ \texttt{dfs} $ 如下：

```cpp
// 以结点 i 为起点进行 dfs
void dfs(int i) {
    // 遍历 i 的每条出边
    for(int j = 1; j <= S[i]; j++) {
        Z.push_back(W[i][j]); // 将当前边的边权加入数组 Z 的末尾
        dfs(L[i][j]); // 从下一个结点继续 dfs
    }
}
```

请注意，以上函数并没有记录经过的结点，所以有些结点可能被经过不止一次。

在主函数中，程序调用了一次 $ \texttt{dfs(1)} $，得到了一个只包含 $ 0 $ 和 $ 1 $ 的数组 $ Z $。请你求出数组 $ Z $ 的逆序对数。

由于答案可能很大，你只需要输出答案对 $ 998 \text{ } 244 \text{ } 353 $ 取模的值。

## 输入格式

每组测试数据的第一行包含一个整数 $ N \text{ } (2 \le N \le 10^5) $，代表图中的结点个数。接下来的数据包含了结点 $ 1 $ 到结点 $ N $ 的信息。

结点 $ i $ 所对应信息的第一行包含一个整数 $ S_i \text{ } (0 \le S_i \le N - 1) $，代表结点 $ i $ 的出度。

接下来的 $ S_i $ 行中的第 $ j $ 行包含两个整数 $ L_{i, j} \text{ } (1 \le L_{i, j} \le N) $ 和 $ W_{i, j} \text{ } (0 \le W_{i, j} \le 1) $，表示从结点 $ i $ 的其中一条出边指向结点 $ L_{i, j} $，边权为 $ W_{i, j} $。

输入数据保证给定的图没有重边，没有环。保证 $ \sum S_i \le 2 \times 10^5 $。保证从结点 $ 1 $ 出发可以到达图中的任意一个结点。

## 输出格式

输出一个整数，代表答案对 $ 998 \text{ } 244 \text{ } 353 $ 取模的值。

### 样例解释

数组 $ Z = [0, 1, 0, 1, 1, 0] $。逆序对为 $ (2, 3) $，$ (2, 6) $，$ (4, 6) $，和 $ (5, 6) $。

## 样例 #1

### 输入

```
5
2
4 0
3 1
0
1
2 0
2
3 1
5 1
0
```

### 输出

```
4
```


---
title: "Qingshan Loves Strings 2"
layout: "post"
diff: 普及/提高-
pid: CF1889A
tag: []
---

# Qingshan Loves Strings 2

## 题目描述

我们称长度为 $ k $ 的01串 $ a $ 是**好的**且仅当

- $ \forall i \in \left [ 1,k  \right ], a_i \ne a_{k-i+1}$

比如，$ \texttt{10} $ , $ \texttt{1010} $ , $ \texttt{111000} $ 是好的，而 $ \texttt{11} $ , $ \texttt{101} $ , $ \texttt{001} $ , $ \texttt{001100} $ 不是好的。

现在给你一个01串 $ s $，你可以执行不多于 $ 300 $ 次以下操作使得 $ s $ 变为好的（次数可以为 $ 0 $）：

- $ \text{插入} \texttt{01} \text{到} s \text{的任意位置} $

请你判断是否有解，并在有解的情况下输出操作次数和每个操作的插入位置。

## 输入格式

采用多组测试。

第一行输入一个整数 $ t $ ( $ 1\le t\le 100 $ ) 表示测试组数。

每组数据的第一行输入一个整数 $ n $ ( $ 1 \le n\le 100 $ ) 表示01串 $ s $ 的长度。

每组数据的第二行输入一个长度为 $ n $ 的01串 $ s $。

## 输出格式

对于每组数据，如果无法使 $ s $ 变好，输出一行一个 $ -1 $。

否则，输出 $ p $ ( $ 0 \le p \le 300 $ ) 表示操作总数。

接下来，输出 $ p $ 个整数 $ x_i $ ( $ 0 \le x_i \le n+2i-2 $ ) 表示操作位置。当 $ x_i = 0 $ 时表示插入$ \texttt{01} $到 $ s $ 开头，否则表示插入到 $ s $ 的第 $ x_i $ 项后面。

可以证明，在此问题的约束下，如果有答案存在，那么总有一个答案仅需要 $ 300 $ 次以下的操作数便可以完成。

**样例 1**

**样例输入 1**

```
6
2
01
3
000
4
1111
6
001110
10
0111001100
3
001
```

**样例输出 1**

```
0

-1
-1
2
6 7
1
10
-1
```

## 说明/提示

在第一组样例中，你不需要进行任何操作就可以使 $ s $ 为好的01串。

另一种方法是插入$\texttt{01}$到第 $ 1 $ 项后面，即：

1. $ \texttt{0}\underline{\texttt{01}}\texttt{1} $

最终 $ s = \texttt{0011} $，是好的01串。

在第二组样例中，没有办法使 $ s $ 变好。

在第四组样例中，你可以进行如下操作：

1. $ \texttt{001110}\underline{\texttt{01}} $
2. $ \texttt{0011100}\underline{\texttt{01}}\texttt{1} $

最终 $ s = \texttt{0011100011} $，是好的01串。

## 样例 #1

### 输入

```
6
2
01
3
000
4
1111
6
001110
10
0111001100
3
001
```

### 输出

```
0

-1
-1
2
6 7
1
10
-1
```


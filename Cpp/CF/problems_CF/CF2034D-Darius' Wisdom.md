---
title: "Darius' Wisdom"
layout: "post"
diff: 普及+/提高
pid: CF2034D
tag: ['贪心']
---

# Darius' Wisdom

## 题目描述

大流士一世正在建造 $ n $ 根石柱，每根石柱由一个底座和不超过两个铭文块构成。

在每次操作中，大流士可以选择两根石柱 $ u $ 和 $ v $，只要这两根石柱的铭文数量差恰好为 $ 1 $，就可以将一个铭文从较多的一根转移到较少的一根。可以保证至少有一根石柱含有正好 $ 1 $ 个铭文。

为使得石柱看起来更美观，大流士希望这些石柱的铭文数量按不减顺序排列。为了减少工人们的辛劳，他希望你制定一个操作序列，最多使用 $ n $ 次操作实现这一目标，不需要优化操作次数。

## 输入格式

第一行是一个整数 $ t $，表示测试用例的数量。（$ 1 \leq t \leq 3000 $）

接下来每个测试用例的第一行包含一个整数 $ n $，表示石柱数目。（$ 1 \leq n \leq 2 \cdot 10^5 $）

第二行有 $ n $ 个整数 $ a_1, a_2, \ldots, a_n $，其中 $ a_i \in \{0,1,2\} $ 表示第 $ i $ 根石柱最开始的铭文数。保证至少有一根石柱有且只有一个铭文。

在所有测试用例中，$ n $ 的总和不超过 $ 2 \cdot 10^5 $。

## 输出格式

对每个测试用例，首先输出一个整数 $ k $，表示用于排序石柱的操作次数。（$ 0 \leq k \leq n $）

接着输出 $ k $ 行，每行包含两个整数 $ u_i $ 和 $ v_i $，表示第 $ i $ 次操作中转移铭文的两个石柱索引，要求转移时 $ |a_{u_i} - a_{v_i}| = 1 $。

可以证明，在这些限制下，总能找到一个可行的解。

## 说明/提示

以下是几个测试用例的样例状态：

- 第一个测试用例：
  - 初始状态：$ 0, 2, 0, 1 $
  - 第一次操作后：$ 0, 1, 0, 2 $
  - 第二次操作后：$ 0, 0, 1, 2 $

- 第二个测试用例：
  - 初始状态：$ 1, 2, 0 $
  - 第一次操作后：$ 0, 2, 1 $
  - 第二次操作后：$ 0, 1, 2 $

- 在第三个测试用例中，石柱的铭文数量已经是按升序排列的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
4
0 2 0 1
3
1 2 0
6
0 1 1 2 2 2
```

### 输出

```
2
2 4
2 3
2
3 1
2 3
0
```


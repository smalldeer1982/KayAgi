---
title: "Quantifier"
layout: "post"
diff: NOI/NOI+/CTSC
pid: CF2081E
tag: ['动态规划 DP', '组合数学']
---

# Quantifier

## 题目描述

给定一棵包含 $n+1$ 个节点的有根树，节点编号为 $0$ 到 $n$，其中根节点为 $0$，其唯一的子节点是 $1$。现有 $m$ 个不同芯片，编号为 $1$ 到 $m$，每个芯片颜色为黑色或白色。初始时，这些芯片按编号升序从上到下排列在边 $(0,1)$ 上。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2081E/58bf900e143672111ffad5778f71f85a1474d17a.png) 

芯片的初始位置。树节点以蓝色显示。你可以按任意顺序执行以下操作任意次（包括零次）：
1. 选择两条边 $(u,v)$ 和 $(v,w)$，其中 $u$ 是 $v$ 的父节点，$v$ 是 $w$ 的父节点，且边 $(u,v)$ 上至少有一个芯片。将边 $(u,v)$ 上的最底部芯片移动到边 $(v,w)$ 的最顶部位置（即置于该边所有现有芯片之上）。
2. 选择两条边 $(u,v)$ 和 $(v,w)$，其中 $u$ 是 $v$ 的父节点，$v$ 是 $w$ 的父节点，且边 $(v,w)$ 上至少有一个芯片。将边 $(v,w)$ 上的最顶部芯片移动到边 $(u,v)$ 的最底部位置（即置于该边所有现有芯片之下）。
3. 选择同一边上两个相邻的同色芯片，交换它们的位置。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2081E/6b3fd794319ff8c895e98bf884db81759bf5fe7e.png) 

允许的操作。每个芯片 $i$ 有一个移动范围，定义为从根节点到节点 $d_i$ 的简单路径上的所有边。操作过程中必须确保没有芯片被移动到其移动范围之外的边上。

最终，你需要将所有芯片移回边 $(0,1)$。可以发现芯片的顺序可能发生变化。请计算最终边 $(0,1)$ 上芯片排列的可能方案数对 $998\,244\,353$ 取模的结果。

芯片的排列定义为从顶到底的芯片编号组成的长度为 $m$ 的序列。

## 输入格式

每个测试包含多个测试用例。第一行输入测试用例数量 $t$（$1 \le t \le 5000$）。接下来描述每个测试用例。

每个测试用例的第一行包含两个整数 $n$ 和 $m$（$1 \le n, m \le 5000$）——树的大小减一（即树有 $n+1$ 个节点）和芯片数量。

第二行包含 $n$ 个整数 $p_1, p_2, \ldots, p_n$（$0 \le p_i < i$）——节点 $1$ 到 $n$ 的父节点。保证当且仅当 $i=1$ 时 $p_i = 0$（根的唯一子节点是 $1$）。

第三行包含 $m$ 个整数 $c_1, c_2, \ldots, c_m$（$c_i \in \{0, 1\}$）——每个芯片的颜色（$0$ 表示黑色，$1$ 表示白色）。

第四行包含 $m$ 个整数 $d_1, d_2, \ldots, d_m$（$1 \le d_i \le n$）——每个芯片的移动范围。

保证所有测试用例的 $n$ 总和不超过 $5000$，$m$ 总和不超过 $5000$。

## 输出格式

对于每个测试用例，输出一个整数——可能排列数对 $998\,244\,353$ 取模的结果。


## 说明/提示

第一个测试用例中，可以达成 $2$ 种排列：(1,2) 和 (2,1)。

第二个测试用例中，可以达成 $8$ 种排列：(1,2,3,4)、(1,2,4,3)、(1,3,2,4)、(1,3,4,2)、(1,4,2,3)、(1,4,3,2)、(2,1,3,4) 和 (2,1,4,3)。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 2
0 1 1
0 1
2 3
4 4
0 1 1 2
0 0 1 1
1 2 3 3
6 6
0 1 1 1 4 5
0 0 0 0 1 1
5 6 1 2 4 3
16 15
0 1 1 3 1 3 4 3 3 7 1 6 11 5 8 10
1 0 1 1 0 1 1 1 1 0 1 1 0 0 0
12 14 13 10 9 16 11 14 13 15 16 10 2 2 5
```

### 输出

```
2
8
108
328459046
```


---
title: "Secret"
layout: "post"
diff: 普及/提高-
pid: CF271C
tag: []
---

# Secret

## 题目描述

有史以来最伟大的秘密包含$n$个单词，它们的顺序从$1$到$n$。秘密必须在$k$个守密的人之间进行分割（用正整数$1$到$k$表示守密人的序号），第$i$个守密人得到一个非空字符串以及$U_i=(u_{i,1},u_{i,2},...,u_{i,|U_i|})$集合中的数。我们把集合元素按照升序排列。

如果以下条件成立，则秘密被成功保守：

- 对于任何两个整数$i,j(i<=i,j<=k)$，则升序中的$U_i$和$U_j$为空集合；
- $U_1,U_2,...,U_k$的联合是集合$(1,2,...,n)$；
- 对于每一个集合$U_i$，它的元素$u_{i,1},u_{i,2},...u_{i,|u_{i}|}$不构成等差数列，即$|U_i|>=3$应当成立；

让我们提醒你，集合$(u_1,u_2,...,u_s)$的元素在满足以下条件时构成等差数列：有一个数$d$，它满足所有的$i(1<=i<=s)$，使得$u_i+d=u_{i+1}$。例如，元素$(5),(1,10)$和$(1,5,9)$构成等差数列，而$(1,2,4)$和$(3,6,8)$则不构成。

你的任务就是找到任意一个把这一集合的文字分割成子集合$U_1,U_2,...,U_k$的方法，使得秘密能够被保守。否则指出没有满足条件的分割方式。

## 输入格式

输入只有一行，包括两个整数$n,k(2<=k<=n<=10^6)$——分别代表秘密所含单词的数量和守密的人数。两个数字之间用一个空格分隔。

## 输出格式

如果没有办法使得秘密保守，输出一个整数"$-1$"（不包括双引号）。否则，输出$n$个整数，其中第$i$个整数表示得到第$i$个单词的人的序号。

如果有多种结果，输出任意一种。

## 样例 #1

### 输入

```
11 3

```

### 输出

```
3 1 2 1 1 2 3 2 2 3 1

```

## 样例 #2

### 输入

```
5 2

```

### 输出

```
-1

```


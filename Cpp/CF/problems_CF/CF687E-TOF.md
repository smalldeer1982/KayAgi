---
title: "TOF"
layout: "post"
diff: 省选/NOI-
pid: CF687E
tag: []
---

# TOF

## 题目描述

今天，Pari 给 Arya 出了一个有趣的图论题目。Arya 编写了一个性能不佳的解决方案，因为他相信自己能够优化这些非最佳方案。不仅如此，代码中还存在不少错误，他尝试了多次进行优化，结果代码变得非常杂乱！他不断遇到“超出时间限制”的问题，这让他感到很失望。不过突然之间，他灵光一现！

下列是他的杂乱代码：

```cpp
dfs(v) {
    count[v] = count[v] + 1;
    if (count[v] < 1000) {
        foreach u in neighbors[v] {
            if (visited[u] == false) {
                dfs(u);
            }
            break;
        }
    }
    visited[v] = true;
}

main() {
    输入有向图();
    TOF();
    for 1 <= i <= n {
        count[i] = 0;
        visited[i] = false;
    }
    for 1 <= v <= n {
        if (visited[v] == false) {
            dfs(v);
        }
    }
    // 之后会做一些很酷而神奇的事情，但我们不能告诉你具体是什么！
}
```

Arya 请求你帮助编写 `TOF` 函数，以优化代码运行时间，并尽量减少 `dfs` 函数的调用次数。输入是一个有向图，你需要在 `TOF` 函数中重新排列每个顶点的邻接表。`dfs` 函数的调用次数与每个顶点的邻接顺序有关。

## 输入格式

第一行输入两个整数 $n$ 和 $m$，分别表示图的顶点数和有向边数（$1 \leq n, m \leq 5000$）。

接下来的 $m$ 行中，每行包含两个整数 $u_i$ 和 $v_i$，表示存在一条从 $u_i$ 到 $v_i$ 的有向边（$1 \leq u_i, v_i \leq n$）。

可以假设图中不存在自环，并且任意一对无序顶点之间最多只有一条边。

## 输出格式

输出一个整数，表示通过调整边的顺序后，可以实现的最小 `dfs` 函数调用次数。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 3
1 2
2 3
3 1

```

### 输出

```
2998

```

## 样例 #2

### 输入

```
6 7
1 2
2 3
3 1
3 4
4 5
5 6
6 4

```

### 输出

```
3001

```


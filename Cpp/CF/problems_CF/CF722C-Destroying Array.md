---
title: "Destroying Array"
layout: "post"
diff: 普及/提高-
pid: CF722C
tag: ['线段树', '并查集']
---

# Destroying Array

## 题目描述

给你一个由 $n$ 个非负整数组成的数列 $a_1$，$a_2$，$\cdots$，$a_n$。

你将要一个一个摧毁这个数列中的数。并且，现在给你一个由 $1$ 到 $n$ 组成的序列来告诉你每个数被摧毁的时间顺序。

每当一个元素被摧毁时，你需要找到这个当前数列中的未被摧毁的数组成的和最大的连续子序列，另外，如果当前剩余的序列是空的的话，最大和就是 $0$。

## 输入格式

第一行包含一个整数 $n (1\le n\le 100000)$ , 代表数列的长度。

第二行包含 $n$ 个整数 $a_1$，$a_2$，$\cdots$，$a_n$ $(0\le a_i\le 10^9)$。

第三行包含一个由 $1$ 到 $n$ 的整数组成的序列，代表数被摧毁的顺序。

## 输出格式

输出有 $n$ 行，第 $i$ 行包含一个整数 —— 在第 $i$ 个操作已经执行完之后，数列中连续的最大和。

## 说明/提示

第一个样例：

1.第三个数被删除了，现在的数列是 1 3 x 5 ，5由一个数5组成。

2.第四个数被删除了，现在的数列是 1 3 x x ，4由两个数1和3组成。

3.第一个数被删除了，现在的数列是 x 3 x x ，3由一个数3组成。

4.最后一个剩下的数被删除了，现在的数列中没有东西啦，所以答案是0呢！


感谢 @FangHaosb 提供的翻译

## 样例 #1

### 输入

```
4
1 3 2 5
3 4 1 2

```

### 输出

```
5
4
3
0

```

## 样例 #2

### 输入

```
5
1 2 3 4 5
4 2 3 5 1

```

### 输出

```
6
5
5
1
0

```

## 样例 #3

### 输入

```
8
5 5 4 4 6 6 5 5
5 2 8 7 1 3 4 6

```

### 输出

```
18
16
11
8
8
6
6
0

```


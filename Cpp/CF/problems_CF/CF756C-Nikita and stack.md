---
title: "Nikita and stack"
layout: "post"
diff: 省选/NOI-
pid: CF756C
tag: []
---

# Nikita and stack

## 题目描述

NK有一个栈。 此问题中的栈是支持两个操作的数据结构。 push(x)操作将整数$x$放在栈顶，而pop()操作则从栈中删除顶部的整数，即最后添加的整数。 如果栈为空，则pop()函数不执行任何操作。

NK用堆栈进行了$m$次操作，但忘记了那$m$次操作干了什么。在第$i$个步骤中，他记得他进行过第$p_{i}$个操作。 换句话说，他以某些排列$p_{1}$，$p_{2}$，...，$p_{m}$的顺序记住操作。 在完成每一步之后，NK想要以相应的顺序知道在已经记住的操作后栈的顶部的数是什么。帮帮NK！

## 输入格式

第一行是一个整数$m(1\le m\le 10^{5})$，表示NK进行了几次操作。

接下来的$m$行是NK所记得的操作。第$i$行包含2个整数，$p_i$和$t_i$$(1\le p_i\le m, t_i = 0$或$t_i = 1)$———他在步骤i上记住的操作索引以及操作类型。若$t_i=0$，则该操作为pop()，反之为push(x)。如果操作为push(x)，则该行还会包含一个整数$x_i(1\le x_i\le10^6)$，即加到栈内的数。

确保从1到$m$的每个整数在整数$p_{i}$中仅出现一次。

## 输出格式

输出$m$个整数。第$i$个输出的整数应等于NK记得的第$i$次操作后栈顶的元素。如果栈为空，则返回$-1$。

## 说明/提示

在第一个示例中，在NK记住第一步的操作之后，操作push(2)是唯一的操作，因此答案是2。 在他记住在push(2)之前完成的pop()操作之后，答案保持不变。

在第二个示例中，操作是push(2)，push(3)和pop()。 NK按照顺序记住它们。

在第三个示例中，NK以相反的顺序记住了所有的操作。

## 样例 #1

### 输入

```
2
2 1 2
1 0

```

### 输出

```
2
2

```

## 样例 #2

### 输入

```
3
1 1 2
2 1 3
3 0

```

### 输出

```
2
3
2

```

## 样例 #3

### 输入

```
5
5 0
4 0
3 1 1
2 1 1
1 1 2

```

### 输出

```
-1
-1
-1
-1
2

```


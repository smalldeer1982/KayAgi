# Delicate Anti-monotonous Operations

## 题目描述

生活中有许多重复的工作，Iris 不喜欢它们，然而时间不能倒流，我们只好一路向前。

说回正题，Iris 有一个数列 $a$，数列中的每个数都是 $1$ 到 $w$ 之间的正整数（保证 $w\ge 2$。）。

Iris 定义单次操作为：选择数列中相邻且相等的两个数 $a_i$ 和 $a_{i+1}$，将它们变为 $1$ 到 $w$ 之间的任意两个正整数（可以与原来相同），但是由于 Iris 不喜欢相等的数，因此修改后的 $a_i$ 和 $a_{i+1}$ 必须不等（当然，允许因为后续操作导致 $a_i$ 和 $a_{i+1}$ 与先前操作过的数相等，即操作互相独立。每对数，每个数均可操作多次）。

现在，Iris 希望知道整个数列所有数字和的最大值，以及得到这个最大值所需的最少操作次数。


保证对于每组数据所有 $a_i$ 满足 $1\le a_i\le w$， 所有数据 $n$ 的和不超过 $10^6$。

## 说明/提示

#### 样例解释

对于第一组数据，所有 $a_i$ 互不相同，无法操作，因此最大值为 $1+2+3+4+5=15$，此时操作次数为 $0$。

对于第二组数据，操作方式为：

$$[3, 1, 2, 3, 4, \underline{1, 1}] \rightarrow [3, 1, 2, 3, \underline{4, 4}, 5] \rightarrow [3, 1, 2, \underline{3, 3}, 5, 5] \rightarrow [3, 1, \underline{2, 2}, 5, 5, 5] \rightarrow [3, \underline{1, 1}, 5, 5, 5, 5] \rightarrow [\underline{3, 3}, 5, 5, 5, 5, 5] \rightarrow [4, 5, 5, 5, 5, 5, 5]$$

可以证明不存在更好的方案，此时所有数字之和为 $34$，共 $6$ 次操作。


- $1\le n\le 10^5,2\le w\le10^8$。

- 单个测试点所有数据的 $n$ 之和不超过 $10^6$。

## 样例 #1

### 输入

```
2
5 8
1 2 3 4 5
7 5
3 1 2 3 4 1 1```

### 输出

```
15 0
34 6```

# 题解

## 作者：irris (赞：1)

> 分类讨论

出题人的人机题解。

## 提示

### 提示 1

如果 $w = 2$ 会怎样？假设 $a_0 = a_{n+1} = 2$，那么让 $\sum\limits_{i=0}^n [a_i \neq a_{i+1}]$ 增加还会最优吗？

### 提示 2

如果 $w \geq 3$，第一个问题的答案是什么？

### 提示 3

如果 $a_i = a_{i+1}$，经过一次操作 $(i, i+1)$，我们就可以得到 $a_{i-1} = a_i$ 或 $a_{i+1} = a_{i+2}$（也可能两者兼有）。

### 提示 4

尝试反向思考整个过程。如果 $w \geq 3$，$1 \leq a_i \leq w - 1$，你能解决这个问题吗？

### 提示 5

对每个 $1 \leq i \leq n$，如果 $a_i = w$，你还需要多少次额外操作？

## 题解

请先阅读提示。

1. $w = 2$

在任何操作之后，$k = \sum_{i=0}^n [a_i \neq a_{i+1}]$ 都不会减少（假设 $a_0 = a_{n+1} = 2$）。对于固定的 $k$，$\sum a_i$ 的最大值会是 $2n - \frac{k}{2}$，这可以通过每次将 $[2, 1, 1]$ 变成 $[2, 2, 1]$（或对称地，$[1, 1, 2] \rightarrow [1, 2, 2]$）来达到，这时，只有 $\frac{k}{2}$ 个 $1$，并且每个 $1$ 形成一个独立的连续段。容易计算两个问题的答案。

2. $w \geq 3$
    - 无法进行任何初始操作，或 $\min(a_i) = w$

这种情况很简单。

2. $w \geq 3$
    - 可以进行一些初始操作，且 $\min(a_i) \neq w$

我们声称第一个问题的答案是 $nw - 1$。对于第二个问题，让我们在下面研究一些更简单的情况。

2. $w \geq 3$
    - 可以进行一些初始操作，且 $\min(a_i) \neq w$
        - $a_i \neq w$

我们假设最终序列是 $[w, w, \dots, w, (w-1), w, w, \dots, w]$，那么由于操作后 $(a_i, a_{i+1})$ 必须不同，最后一个操作只能发生在 $[w, (w-1)]$（或 $[(w-1), w]$）。并且由于最初 $a_i \neq w$，每个位置必须至少被操作一次。

这给我们提供了诸如 $[w, \dots, w, x, x, w, \dots, w]$、$[w, \dots, w, y, y, x, w, \dots, w]$ 等状态。在最左边的位置，我们得到 $a_1 = a_2$（基于提示 3）。此外，我们得到...... $a_{n-1} = a_n$？当且仅当初始 $[w, (w - 1)]$ 既不在开头也不在结尾时，这才成立。如果初始的 $[w,(w-1)]$ 在开始处，我们只需要满足 $a_{n-1} = a_n$ 就可以达到目标，并且对称同理。少即是多。于是，显然：**我们只需要满足 $\bm{a_1 = a_2}$ 或 $\bm{a_{n-1} = a_n}$，然后再使用 $\bm{n - 1}$ 次操作即可达到目标情况**。

我们如何得到 $a_1 = a_2$（对称同理）？基于提示 3，我们找到满足 $a_x = a_{x+1}$ 的最小 $x$，然后按照上面的例子，再次使用 $x - 1$ 次操作将等号进行运算，就可以让当前的状态满足 $a_1 = a_2$。

#### 最优性

> **引理 1**：我们永远不能选择一个索引 $a_i = w$，固定它（即避免在以下操作中改变 $a_i$），然后使用一些操作来达到 $\sum a_i = nw - 1$，除非 $[a_1, \ldots, a_i] = [w, \ldots, w]$ 或 $[a_i, \ldots, a_n] = [w, \ldots, w]$。

**证明**：如果不是这样，数组将分成两部分：$[a_1, \ldots, a_{i-1}]$ 和 $[a_{i+1}, \ldots, a_n]$。我们有：经过一些操作后，我们能得到的最大 $\sum a_i$ 分别为 $(i-1)w - 1, (n-i)w - 1$，将它们相加得到 $nw - 2$，小于 $nw - 1$，因此它永远不是最优的。

> **引理 2**：考察最终数组 $a$，它由 $n - 1$ 个元素 $w$ 和 $1$ 个元素 $(w - 1)$ 组成。通过保留值为 $w$ 的元素获得数组 $a'$。将 $t_i$ 表示为最后一轮将 ${a'}_i$ 更改为 $w$（然后变为固定值）。然后，存在某个 $k$ 使得 $t_1 < t_2 < \dots < t_k > t_{k+1} > \dots > t_{n-1}$。

**证明**：这从 **引理 1** 直接得出。

根据 **引理 2**，我们可以看到上面使用的操作模式确实是最优的。

2. $w \geq 3$
    - 可以进行一些初始操作，且 $\min(a_i) \neq w$
        - $a_1 \neq w, a_n \neq w$

基本上，想法仍然是先以相同的方式（对称同理）达到 $a_1 = a_2$，然后扩展到所有位置。但是此时，在第二阶段，可能会出现一些问题：

- $[\dots \underline{a_k}\ a_{k+1}\ w\ a_{k+3} \dots]$
- $[\dots \underline{\color{red}{a_{k+1}}\ a_{k+1}}\ w\ a_{k+3} \dots]$
- $[\dots {\color{red}s}\ \underline{\color{red}w\ w}\ a_{k+3} \dots]$
- $[\dots {\color{red}{\underline{s\ s}}}\ t\ a_{k+3} \dots]$
- $[\dots {\color{red}w}\ \underline{\color{red}t\ t}\ a_{k+3} \dots]$
- $[\dots {\color{red}{w\ w}}\ \underline{{\color{red}{a_{k+3}}}\ a_{k+3}} \dots]$

其中 $s, t, w$ 是三个 $[1, w]$ 内不同的整数（这也解释了为什么我们需要特别处理 $w = 2$ 的情况）。由于我们无法一开始就确定 $a_{k+2} = w$（请参阅上面的 **最优性**），我们必须首先将 $a_{k+2}$ 改为不等于 $w$ 的值，这至少需要 $2$ 次额外操作，如上所示。

**我们总是需要 $2$ 次额外的操作吗？** 有人可能会注意到，如果 $a_i = a_{i+1} = w$，其中两个元素都处于扩展范围内，我们可以使用 $1$ 个操作来让它们都不为 $w$。形式化地说，如果有一个极长连续的 $w$ 的子段处于扩展范围内，设其长度为 $L$，那么我们将花费 $\lceil \frac{L}{2} \rceil + [L = 1]$ 个额外的操作。容易证明，这是正确的。

#### 扩展范围在哪里

假设在第一阶段，我们选择 $a_x = a_{x+1}$ 并继续对其进行操作，直到 $a_1 = a_2$。然后，$\forall 3 \leq k \leq x + 1$，$a_k$ 可以是任意一个不同于初始 $a_{k-1}$ 的数，因此我们总是可以强制它不等于 $w$。

在上述情况下，只有子数组 $[a_{x+2}, \ldots, a_n]$ 被视为在扩展范围内。对称同理。


2. $w \geq 3$
    - 可以进行一些初始操作，且 $\min(a_i) \neq w$
        - 没有额外的约束

你可能会想到，如果 $a_1 = w$，我们可以忽略 $a_1$；如果 $a_1 = a_2 = w$，我们可以再忽略 $a_2$。对称同理……然后，我们将问题归结为上一个情况。

这是正确的，除非在某些罕见情况下，其中要么当我们忽略所有前缀和后缀时，将不存在剩余的 $a_i = a_{i+1}$；要么如果我们选择任何 $a_i = a_{i+1}$ 作为剩余数组中的起始对，与选择 $a_k = a_{k+1} = w (a_{k+2} \neq w)$（对称同理）相比，不是最优的。因此，一旦删除的前缀和后缀的长度大于 $2$，我们就必须对其进行特殊处理。

综上，该问题可以在 $\mathcal O(n)$ 中解决。

---

## 作者：IvanZhang2009 (赞：1)

~~本题本来可以出构造方案但是最后只要最小化步数，很良心吧！~~

~~就是样例给的有点少。~~

先特判初始不能操作和初始已经全部是 $w$ 的情况。手玩一下，发现大多数情况都有最大值为 $nw-1$。可以发现 $w=2$ 是一个特殊的情况，所有 $1,2$ 的连续段在最优策略下都不会改变，因为不可能删掉两个连续段之间的间隔，最终最大值为 $2n$ 减去 $1$ 的段数，最小操作次数就是第一问答案减掉原来的和，因为每个 $1$ 都要操作一次变成 $2$，一次只能操作一个。

注意到剩下的情况都有答案为 $nw-1$。考虑一个简单的构造：找到任意一个操作的起点，先把它扩展到边上，即每次把 `a a b ...` 改成 `a b b ...` 然后继续下去。此时得到一个边上的可操作点，我们按相同的方式拓展即可。例如当前的连续段 `a a b`，在 $b\neq w$ 的时候我们直接把两个 $a$ 改成 $w,b$ 即可；否则可以先改成 $w-1,w$，然后把后两个 $w$ 改成 $w-1,w-2$，然后把两个 $w-1$ 改成 $w,w-2$。注意到此时用到了第三个数，所以 $w=2$ 的时候不能如此操作。

这样已经构造出一个合法解，且可以发现一般来说都可以让最后的 $w-1$ 放在末尾，除非后面有一个长的 $w$ 连续段。考虑证明的话就是如果 $w-1$ 在中间，需要把两个连续段向两边扩展再合并，分析发现操作次数远远更劣。我们考虑枚举它放在哪个边上，然后做法变成取离开头最近的连续段移动到边上，然后再扩展。这里有一个小细节，如果枚举到的一边上有若干个 $w$，可以将其视作连续段，也可以将其直接忽略。

接下来是一些小细节。

- 我们考虑一段较长的 $w$ 怎么处理。例如 $w=9$，序列为 `1191199`，`11991199`，`119991199`，`11999991199`。只有一个 $w$ 的时候可以 `119`，`899`，`877`，`887`，`977`；有两个 $w$ 的时候可以先处理掉这两个，然后按朴素做法做；有更多 $w$ 的时候发现若有偶数个则两两消掉，否则 `11999`，`11199` 来处理掉第一个，后面照旧。
- 更令人难受的细节是在一开始把相同段推到边缘时，把后面的不用的元素改成什么。可以发现不改成 $w$ 一般是更优的，但是如果起点的附近又是一个 $w$ 的连续段，可以考虑把奇数变成偶数减小后续的次数。
- 上面说的一个细节：两侧都有 $w$ 连续段。一个细节是如果边上有两个 $w$ 可以视其为相同数，使得次数进一步减小。

关于如何具体证明这是最小步数，其实手玩各个 case 的时候已经可以感受到了。更具体地，写个优秀的拍子就可以对拍证明了！优秀的暴力写法在文章最下面。

提供一个我~~花了两个小时写~~的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MOD         998244353
#define speMOD      2933256077ll
#define int         long long
#define pii         pair<int,int>
#define all(v)      v.begin(),v.end()
#define pb          push_back
#define REP(i,b,e)  for(int i=(b);i<(int)(e);++i)
#define over(x)     {cout<<(x)<<endl;return;}
#define lowbit(x)   ((x)&(-(x)))
#define cntbit(x)   __builtin_popcount(x)
#define deal(v)     sort(all(v));v.erase(unique(v.begin(),v.end()),v.end())
#define lbound(v,x) lower_bound(all(v),x)-v.begin()
int n,w,N;
int a[200005],b[200005];
int solve(){
	int x=0,ans=0;
	REP(i,1,n)if(b[i]==b[i-1]){
		x=i-1;break;
	}
	int m=n;while(b[m-1]==w-1)--m;//>=m 的都是 w
	//先把 same 推到最边上
	ans+=x;//x x+1 m
	int f=m<=x+2,g=0,h=0;
	if(m<=x)return 1e18;
	if(!f&&x){
		int len=x+2;
		while(len<n&&b[len]==w-1)++len;
		if(len==x+3)g=1;
		else g=0;
	}
	if(g){
		if(b[x-1]!=w-1)b[x+1]=w-1,b[x]=b[x-1],--x;
		else ans+=2,b[x+2]=b[x]? b[x]-1:1;
	}
	for(int i=x-1;i>=0;--i){
		if(!i&&b[i]==w-1){--ans;h=1;break;}
		if(b[i]==w-1)f=0;
		if(!f)b[i+2]=b[i]? b[i]-1:1;
		else b[i+2]=w-1;
		b[i+1]=b[i];
	}
	if(h)x=1;
	else{
		x=0;
		if(b[0]==w-1){while(x+2<n&&b[x+2]==b[x+1])++x;if(x+3<n&&b[x+2]==b[x+3])x+=2;}
	}
	//b[x]=b[x+1], 目标推进 b[x+2]
	while(x+1<m){
		if(x+2==m)return ++ans;
		if(b[x]==w-1&&b[x+1]==w-1&&b[x+2]==w-1){++x;continue;}
		if(b[x+2]!=w-1){
			b[x]=w-1;b[x+1]=b[x+2];++ans;++x;
			continue;
		}
		//9119
		// x  
		if(b[x+3]==w-1){
			if(x+4<n&&b[x+4]==w-1&&(x+5>=n||b[x+5]!=w-1)){
				//911999 911199 991199
				ans+=2;swap(b[x],b[x+2]);++x;
			}else{
				//91199 91188 99888 99988
				ans+=3;
				b[x]=b[x+1]=w-1;b[x+2]=b[x+3]=w-2;
				x+=2;
			}
		}else{
			//91191 92991 92211 99111 99911
			ans+=4;b[x]=b[x+1]=w-1;b[x+2]=b[x+3];
			x+=2;
		}
	}
	return ans;
}
int spesolve(){
	N=n;
	REP(i,0,n)b[i]=a[i];
	if(b[0]==w-1&&b[1]==w-1){
		int x=0,y=n-1;
		while(b[x]==w-1)++x;
		while(b[y]==w-1)--y;
		int f=0;
		REP(i,x+1,y+1)if(b[i]==b[i-1])f=1;
		if(!f){
			n=y+1;
		}else{
			f=0;
			REP(i,x+1,n)if(b[i]==b[i-1])f=1;
			if(f){
				int cur=solve();
				REP(i,0,n)b[i]=a[i];
				n-=x;
				REP(i,0,n)b[i]=b[i+x];
				return min(cur,solve());
			}
		}
	}
	return solve();
}
void Main() {
	cin>>n>>w;
	REP(i,0,n)cin>>a[i];
	if(w==2){
		int ans=0;
		REP(i,1,n){
			if(a[i]==1&&a[i-1]==1)a[i-1]=2,++ans;
		}
		int res=0;
		REP(i,0,n)res+=a[i];
		cout<<res<<' '<<ans<<endl;
		return;
	}
	bool f=1;int s=0;
	REP(i,1,n)if(a[i]==a[i-1])f=0;
	REP(i,0,n)s+=a[i];
	if(f||s>=n*w-1){
		cout<<s<<' '<<0<<endl;
		return;
	}
	cout<<n*w-1<<' ';
	if(w>4){
		int lst=-1,op=1;
		REP(i,0,n)if(a[i]<w-1){
			if(lst!=a[i])op^=3,lst=a[i];
			a[i]=op;
		}else a[i]-=w-4;
		w=4;
	}
	REP(i,0,n)--a[i];
	if(n==2)over(1)
	int cans=spesolve();n=N;
	reverse(a,a+n);
	cans=min(cans,spesolve());
	over(cans)
}
void TC() {
    int tc=1;
    cin>>tc;
	while(tc--){
		Main();
		cout.flush();
	}
}
signed main() {
	return cin.tie(0),cout.tie(0),ios::sync_with_stdio(0),TC(),0;
}
```

注意到本题细节超级多。我们考虑一个优秀的暴力方便我们对拍调试。注意到我们只关心 $=w$，$=w-1$ 和更小的数以及其中的相等关系。我们保留 $w,w-1$，把剩下的数标为 $1,2$，其中第一个数标为 $1$，后面的数根据“和前一个数是否相等”来决定是 $1$ 或 $2$。这样可以得到一个 $O(4^n\mathrm{poly}n)$ 做法，可以很方便的对拍！这个东西在上面的代码里也实现了。

实际上在特判掉很多 corner case 之后 $w-1$ 也是不重要的，可以变成 $w=3$，但是需要更多特判细节，容易写错。时间复杂度 $O(3^n\mathrm{poly}n)$。具体实现可以用 $3$ 进制数记录状态，用 bfs 实现最小步数。

---


# Turing's Award

## 题目描述

艾伦·图灵站在一条无限延伸、被划分为若干格子的纸带上。

格子从左到右用连续的整数编号。艾伦最初站在 $0$ 号格子上。每个格子 $x$ 的左边是 $x-1$ 号格子，右边是 $x+1$ 号格子。

每个格子可以包含一个整数，也可以为空。最初所有格子都是空的。

艾伦获得了一个长度为 $n$ 的排列 $a_1, a_2, \ldots, a_n$，该排列是从 $1$ 到 $n$ 的所有整数的一个随机排列。

在第 $1$ 时刻，整数 $a_1$ 被写入艾伦所在的 $0$ 号格子。

从第 $2$ 时刻到第 $n$ 时刻，每次操作如下：首先，艾伦可以选择留在当前格子，或者移动到左边相邻的格子，或者移动到右边相邻的格子。之后，整数 $a_i$ 被写入艾伦当前所在的格子。如果该格子已经有整数，则旧的整数会被覆盖，从此不再相关。

当第 $n$ 个数 $a_n$ 被写入某个格子后，依次从左到右收集所有格子中包含的整数，形成序列 $b$，忽略所有空格子。

图灵的奖励等于序列 $b$ 的最长上升子序列的长度。

请帮助艾伦，计算如果他采取最优策略，他能获得的奖励的最大值。

## 说明/提示

序列 $b$ 的最长上升子序列是指可以通过删除 $b$ 中若干（可能为零或全部）元素后得到的最长严格递增序列。

在第一个测试用例中，艾伦只有在第 $2$ 时刻可以做决策。如果艾伦留在 $0$ 号格子，$b=[2]$；如果艾伦移动到左边的 $-1$ 号格子，$b=[2, 1]$；如果艾伦移动到右边的 $1$ 号格子，$b=[1, 2]$。只有最后一种情况下，$b$ 的最长上升子序列长度为 $2$，因此答案为 $2$。

在第二个测试用例中，一种最优操作序列是：第 $2$、$3$ 时刻向左移动，第 $4$ 时刻向右移动。此时 $b=[2, 3, 4]$，其最长上升子序列长度为 $3$。

在第三个测试用例中，一种最优方式是每次都向左移动。此时 $b=[2, 1, 4, 7, 5, 6, 3]$，其最长上升子序列长度为 $4$。

在第四个测试用例中，一种最优方式是连续向右移动四次，然后向左移动一次，最后原地不动。此时 $b=[5, 2, 3, 4, 6]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
2
1 2
4
4 1 2 3
7
3 6 5 7 4 1 2
7
5 2 3 7 6 1 4```

### 输出

```
2
3
4
4```

# 题解

## 作者：Arghariza (赞：8)

参考官方题解。

你发现这个覆盖不太好考虑，考虑时间倒流，变成如下形式：

> 一开始，小 A 的位置上有一个数 $a_n$，然后对于接下来 $n-1$ 步，每次小 A 可以向左走/向右走/不动，然后如果此时小 A 所站的位置上**没有数**，就写上 $a_i$，求最后形成序列的最长上升子序列长度。

考虑到任意时刻的序列一定是包含原点的连续序列 $b$，并且此时不能覆盖有数的位置，那么 $a_i$ 只可能插入到 $b$ 的首尾两个位置。

我们将所有**最终**在 $b$ 中的元素 $a_i$ 成为「好」的元素，显然 $a_n$ 一定是好元素，观察到：

1.  我们并不关心小 A 走到 $b$ 中间哪个**位置**，只关心他是否有**时间**在已经确定的连续好元素之间移动。例如，目前考虑了 $a_i,a_{i+1},\cdots, a_{n}$，钦定 $a_i$ 为好元素并且插入到 $b$ 的**首位**（插入末尾的情况是对称的），目前 $a_i,a_{i+1},\cdots ,a_n$ 中一共有 $k$ 个好元素，考虑第 $k+1$ 个好元素 $a_j(j<i)$：
- 如果 $a_j$ 插入在 $b$ 的**首位**，我们可以在小 A 走过 $i-1,i-2,\cdots,j+1$ 的时候都选择留在原位，这样保证不会覆盖，然后 $j$ 时刻再向左移动一位。所以这种情况没有限制。
- 如果 $a_j$ 插入在 $b$ 的**末尾**，小 A 要走过 $k$ 个好元素。那么需要满足 $i-j\ge k$。
2. 考虑一个好元素 $a_j$（$j\neq n$）如果存在一种方案使得 $a_j$ 在最终的 $b$ 序列里不在 LIS 中，一定存在一种方案使得 $a_j$ 最终不在 $b$ 序列中，因为可以在时刻 $j$ 留在原地不动。所以我们更改好元素的定义：最终出现在 **LIS** 中的元素（包括 $a_n$）。

然后我们可以讨论 $a_n$ 是否属于 LIS，考虑 dp：

令 $f_L(k,i)$ 表示当前从 $n$ 考虑到 $i$，$a_i$ 插入到了 LIS 的**首位**，目前一共有 $k$ 个好元素，LIS **末尾**元素的**最小值**；$f_R(k,i)$ 表示当前从 $n$ 考虑到 $i$，$a_i$ 插入到了 LIS 的**末尾**，目前一共有 $k$ 个好元素，LIS **首位**元素的**最大值**。那么我们要求的就是最大的 $k$，使得存在一个 $i$，状态 $f_{L}(k,i)$ 或者 $f_{R}(k,i)$ 合法（属于 $[1,n]$）。

根据 $a_n$ 是否属于 LIS，我们可以确定 dp 的初始状态。

考虑 $f_{L}(k,i)$ 可以贡献到的状态（$f_R(k,i)$ 类似），讨论新的好元素 $a_j$ 放左还是放右即可：

- $f_{L}(k,i)\to f_{L}(k+1,j)\quad j<i\land a_j<a_i$
- $a_i\to f_{R}(k+1,j)\quad \quad \quad \ j<i-k\land a_j>f_{L}(k,i)$

那么不难得到 $f_{L},f_{R}$ 的转移：

$$\begin{aligned}f_{L}(k+1,i)=\min\left(\min\limits_{j>i\land a_j>a_i}f_{L}(k,j),\min\limits_{j\ge i+k\land f_R(k,j)\ge a_i}a_j\right)\\f_{R}(k+1,i)=\max\left(\max\limits_{j>i\land a_j<a_i}f_{R}(k,j),\max\limits_{j\ge i+k\land f_L(k,j)\le a_i}a_j\right)\end{aligned}$$

显然可以优化，用两个数据结构支持查询前缀 $\max$ 和后缀 $\min$ 即可。复杂度 $O(kn\log n)$，$k$ 为答案，考虑到[均匀随机序列的 LIS 长度期望](https://www.zhihu.com/question/266958886)为 $O(\sqrt n)$，$k$ 取 $O(\sqrt n)$，复杂度 $O(n\sqrt n\log n)$。

其实这里有一个简易的 dp 优化套路：将 dp 答案与状态的一维交换，例如我们也可以按照 LIS 的首尾位为状态 dp，但是复杂度更劣。所以把 LIS 长度列入 dp 状态。

写起来很简单，而且跑得巨快无比。但是为什么 *3400 评紫呢，可能是因为数据结构优化 dp 对于卷怪们已经是套路了吧。


```cpp
const int N = 1.5e4 + 150;
const int inf = 0x3f3f3f3f;
int T, n, ans, a[N], fl[2][N], fr[2][N], tl[N], tr[N];

#define lb(x) (x & (-x))
void updmn(int x, int y) { if (x <= 0 || x > n) return; for (int i = x; i; i -= lb(i)) tl[i] = min(tl[i], y); }
int qrymn(int x) { int res = inf; for (int i = x; i <= n; i += lb(i)) res = min(res, tl[i]); return res; }
void updmx(int x, int y) { if (x <= 0 || x > n) return; for(int i = x; i <= n; i += lb(i)) tr[i] = max(tr[i], y); }
int qrymx(int x) { int res = -inf; for (int i = x; i; i -= lb(i)) res = max(res, tr[i]); return res; }

int dp(int p) {
	int t = 0;
	for (int len = p; ; len++, t ^= 1) {
		int flg = 0;
		for (int i = 1; i <= n; i++) {
			if (fl[t][i] <= n || fr[t][i] >= 1) {
				flg = 1;
				break;
			}
		}
		if (!flg) return len - p;
		memset(tl, inf, sizeof(int) * (n + 10));
		memset(tr, -inf, sizeof(int) * (n + 10));
		for (int i = n; i; i--) {
			if (i < n) updmn(a[i + 1], fl[t][i + 1]), updmx(a[i + 1], fr[t][i + 1]);
			if (i + len <= n) updmn(fr[t][i + len], a[i + len]), updmx(fl[t][i + len], a[i + len]);
			fl[t ^ 1][i] = qrymn(a[i]), fr[t ^ 1][i] = qrymx(a[i]);
		}
	}
}

void solve() {
	n = rd(), ans = 0;
	for (int i = 1; i <= n; i++)
		a[i] = rd(), fl[0][i] = fr[0][i] = a[i];
	ans = max(ans, dp(2));
	memset(fl[0], inf, sizeof(int) * (n + 10));
	memset(fr[0], -inf, sizeof(int) * (n + 10));
	fl[0][n] = fr[0][n] = a[n];
	ans = max(ans, dp(1));
	wr(ans), puts("");
}

int main() {
	T = rd();
	while (T--) solve();
	return 0;
}
```

---

## 作者：歌吟入梦 (赞：2)

考虑把整个过程倒过来，问题就转化为了：

给定 1 ∼ $n$ 的排列 $p_1$, $p_2$, ⋯ , $p_n$。 

初始时你在数轴的原点处，每一步你可以向左或向右走一个单位长度（也可以不动）。

第 $i$ 步结束后，如果你当前的位置上没有数，就写上 $p_i$ 。
 
求最终数轴从左到右的所有数的 LIS 的最大值。

----------

考虑在行走的过程中你关心什么？

只用考虑 LIS 中的元素。

当前在 LIS 的左侧还是右侧？

LIS 中有几个元素？

LIS 首尾元素的值？

怎样判断能否将当前元素加入到 LIS 的左 / 右侧？

设 $f_L(k,i)$ 表示 LIS 长度为 $k$ 时，末尾是 $p_i$ ,开头的最大值。

$f_R(k,i)$ 同理表示末尾的最小值。

写出转移，发现可以 BIT 优化。

LIS 的长度期望 $O(\sqrt n)$

于是就 $O(n\sqrt n \log n)$过了此题

---

## 作者：dead_X (赞：1)

经典结论：随机序列的 LIS 是 $O(\sqrt n)$ 级别的。

考虑我们选出的 LIS 的下标序列，注意到结论：两个数中间不可能存在比它们都小的数。

于是相当于我们按照下标从大到小放数，每次放的数只能在两侧。

这就可以 DP 了，设 $f_{x,y}$ 代表以 $a_x$ 开头，$a_y$ 结尾的 LIS 的最长长度，时间复杂度 $O(n^3)$。

然后就直接考虑我们只需要知道较小的数在哪一端，以及另一端的值。

那么因为 LIS 长度在 $O(\sqrt n)$ 我们对于每个长度维护 $\min(a_x)$ 或 $\min(a_y)$ 即可。

注意第一个放的数不是 $a_n$ 时需要多留一个空位。

使用树状数组优化转移，时间复杂度 $O(n\sqrt n\log n)$。

---

## 作者：_fairytale_ (赞：0)

>于是啜泣着妄想躲回夏天的怀抱

好吧。

首先有性质：一定存在一种操作顺序，使得最终序列只包含答案的 LIS 以及 $a_n$。

证明：假如有 $a_j(j<n)$ 出现在了最终序列，显然所有的 $a_k,k>j$ 都只能放在 $a_j$ 的一侧，因此在写下 $a_j$ 后不动，让 $a_{j+1}$ 覆盖 $a_j$，接下来决策不变，就可以把 $a_j$ 从序列中删除。

考虑时光倒流，设 $f_{i,j}$ 表示考虑了 $a_i\dots a_n$，$a_i$ 在最终序列的一个端点，另一边的值是 $j$ 的 LIS 长度。转移枚举下一个填进来 $a_k$，复杂度 $\mathcal O(n^3)$。

按照题面中的操作，生成的序列最多是原序列的一段前缀拼上一段后缀的翻转（这里是近似，实际肯定比这个短），因此生成的 LIS 长度最多是原序列 LIS+LDS 的长度，根据经典结论，随机排列的 LIS 是 $\mathcal O(\sqrt n)$ 级别的，所以可以得知答案不超过 $\mathcal O(\sqrt n)$。

考虑状态和 DP 值交换，设 $f_{i,j,0/1}$ 表示考虑了 $a_i\dots a_n$，$a
_i$ 在最终序列的一个端点，LIS 的值是 $j$，$a_i$ 作为左端点/右端点出现，另一边的最小/最大值是多少。这样复杂度降低到了 $\mathcal O(n^{2.5})$。

交换一下前两维，把转移写成填表的形式：

$$
f_{j,i,0}=\min(\min_{k>i,a_k>a_i}f_{j-1,k,0},[\max_{k>i}f_{j-1,k,1}\ge a_i]a_i)
$$

发现转移类似一个后缀 $\min$，可以树状数组优化。

时间复杂度 $\mathcal O(n\sqrt n\log n)$。

---


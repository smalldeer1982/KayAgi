# PalindORme

## 题目描述

一个长度为 $n$ 的整数数组 $a$ 被称为 PalindORme，当且仅当对于所有 $1 \leq i \leq n$，都有 $(a_1 \mid a_2 \mid \ldots \mid a_i) = (a_{n-i+1} \mid \ldots \mid a_{n-1} \mid a_n)$，其中 $|$ 表示[按位或运算](https://en.wikipedia.org/wiki/Bitwise_operation#OR)。

如果一个长度为 $n$ 的整数数组 $a$ 的元素可以重新排列成一个 PalindORme，则称该数组是好的。形式化地说，如果存在一个排列 $p_1, p_2, \ldots, p_n$（一个 $1$ 到 $n$ 的排列），使得 $a_{p_1}, a_{p_2}, \ldots, a_{p_n}$ 是 PalindORme，则称数组 $a$ 是好的。

请你计算长度为 $n$、所有元素都在区间 $[0, 2^k - 1]$ 内的好的数组的个数，并对某个质数 $m$ 取模后输出。

如果存在某个 $i$（$1 \leq i \leq n$）使得 $a_i \ne b_i$，则数组 $a_1, a_2, \ldots, a_n$ 和 $b_1, b_2, \ldots, b_n$ 被认为是不同的。

## 说明/提示

在第一个样例中，所有可能的数组 $[0]$ 和 $[1]$ 都是好的。

在第二个样例中，一些好的数组示例有：

- $[2, 1, 2]$，因为它本身就是 PalindORme。
- $[1, 1, 0]$，因为它可以重排为 $[1, 0, 1]$，是 PalindORme。

注意 $[1, 1, 0]$、$[1, 0, 1]$ 和 $[0, 1, 1]$ 都是好的数组，并且根据题意它们被认为是不同的。

在第三个样例中，一个好的数组示例是 $[1, 0, 1, 4, 2, 5, 4]$。它可以重排为 $b = [1, 5, 0, 2, 4, 4, 1]$，这是一个 PalindORme，因为：

- $\mathrm{OR}(1, 1) = \mathrm{OR}(7, 7) = 1$
- $\mathrm{OR}(1, 2) = \mathrm{OR}(6, 7) = 5$
- $\mathrm{OR}(1, 3) = \mathrm{OR}(5, 7) = 5$
- $\mathrm{OR}(1, 4) = \mathrm{OR}(4, 7) = 7$
- $\mathrm{OR}(1, 5) = \mathrm{OR}(3, 7) = 7$
- $\mathrm{OR}(1, 6) = \mathrm{OR}(2, 7) = 7$
- $\mathrm{OR}(1, 7) = \mathrm{OR}(1, 7) = 7$

这里 $\mathrm{OR}(l, r)$ 表示 $b_l \mid b_{l+1} \mid \ldots \mid b_r$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1 1 998244353```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2 999999733```

### 输出

```
40```

## 样例 #3

### 输入

```
7 3 796735397```

### 输出

```
1871528```

## 样例 #4

### 输入

```
2 46 606559127```

### 输出

```
177013```

# 题解

## 作者：whiteqwq (赞：15)

[CF1605F PalindORme](https://www.luogu.com.cn/problem/CF1605F) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15801470.html)

## 题意

定义一个序列是好的当且仅当任意前缀的按位与都等于与其等长的后缀的按位与，定义一个序列是合法的当且仅当其重排之后是好的，求长度为 $n$，值域为 $[0,2^k-1]$ 的合法序列数量。

$1\leqslant n,k\leqslant 80$。

## 分析

Div.2 无人场切的题目竟然只有 *2900/jy。

用一种更加方便的方式刻画合法序列，我们发现每一个合法序列都能通过以下操作删至不超过一个数，同样一个不合法序列一定不行。

1. 令变量 $V=0$；
2. 从序列中选出两个数 $x,y$ 使得 $x\text{ or }V=y\text{ or }V$。
3. 令 $V\leftarrow x\text{ or }V$，删除 $x,y$ 然后回到第二步。

一个合法序列一定不会被判为不合法序列是因为你每一步没有选择的合法 $(x,y)$ 在之后的步骤一定能继续用。

我们发现利用这个性质仍然不好对合法串计数，但是可以尝试通过这一操作搭建合法序列与不合法序列之间的桥梁，然后容斥算出其对应合法序列数量。

定义一个不合法序列的最优子序列为其经过操作后移除的序列（若存在一个和 $V$ 的按位与等于自己的数，就将其放在最优子序列的中间）

可以发现一个不合法序列剩下的数都满足，去掉 $V$ 为 $1$ 的二进制位，任意数不为 $0$ 且两两不同，于是我们建立了一个不合法序列与合法序列（序列内部无序）之间的映射，其中合法序列长度、二进制位数量均小于不合法序列。

接下来就是正常流程了，令 $f_{i,j}$ 为长度为 $i$，二进制位数量恰好为 $j$ 的序列数量，$g_{i,j}$ 为长度为 $i$，二进制位数量恰好为 $j$ 的不合法序列数量。

$f_{i,j}$ 明显可以容斥预处理，也就是：

$$f_{i,j}=\sum_{k=0}^j (-1)^{j-k}{j\choose k}(2^k)^i$$

$g_{i,j}$ 可以直接枚举其最优子序列的长度与二进制位个数，然后有：

$$g_{i,j}=\sum_{i'=0}^{i-1}\sum_{j'=0}^{j-1}{i\choose i'}{j\choose j'}(2^{j'})^{i-i'}h_{i-i',j-j'}(f_{i',j'}-g_{i',j'})$$

前面两个组合数的系数很显然，二的幂次的系数是因为被删去的二进制位可以任意放，$h_{i,j}$ 是长度为 $i$，二进制位数量恰好为 $j$，数字非零且两两不同的方案数，直接容斥计算即可：

$$h_{i,j}=\sum_{k=0}^j (-1)^{j-k}{j\choose k}(2^k-1)^{\underline i}$$

但是还有一点问题，一个长度为奇数的不合法序列不能从它长度减一的合法序列转移过来，因为显然这也是合法序列。

然后就做完了，复杂度 $O(n^2k^2)$。

## 代码

```
#include<stdio.h>
const int maxn=105;
int n,m,mod,ans;
int C[maxn][maxn],f[maxn][maxn],g[maxn][maxn],h[maxn][maxn],mul2[maxn*maxn],mul[2];
int calc(int n,int m){
	int res=1;
	for(int i=n;i>=n-m+1;i--)
		res=1ll*res*i%mod;
	return res;
}
int main(){
	scanf("%d%d%d",&n,&m,&mod),mul[0]=1,mul[1]=mod-1;
	for(int i=0;i<=100;i++){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	mul2[0]=1;
	for(int i=1;i<=n*m;i++)
		mul2[i]=(mul2[i-1]+mul2[i-1])%mod;
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			for(int k=0;k<=j;k++){
				f[i][j]=(f[i][j]+1ll*C[j][k]*mul[(j-k)&1]%mod*mul2[i*k])%mod;
				h[i][j]=(h[i][j]+1ll*C[j][k]*mul[(j-k)&1]%mod*calc(mul2[k]-1,i))%mod;
			}
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			for(int x=0;x<i;x++)
				for(int y=0;y<j;y++){
					if((n&1)&&(i==n)&&(x==n-1))
						continue;
					g[i][j]=(g[i][j]+1ll*C[i][x]*C[j][y]%mod*mul2[(i-x)*y]%mod*h[i-x][j-y]%mod*(f[x][y]-g[x][y]+mod))%mod;
				}
	for(int i=0;i<=m;i++)
		ans=(ans+1ll*C[m][i]*(f[n][i]-g[n][i]+mod))%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：feecle6418 (赞：11)

> 称一个长度为 $n$ 的序列 $a$ 是 $\text{PalindORme}$ 的，当且仅当对于任意 $1 \le i \le n$，满足 $a_1 | a_2 | \dots | a_i = a_n | a_{n-1} | \dots |a_{n-i+1}$，其中 `|` 表示按位或运算。
>
> 称一个长度为 $n$ 的序列 $b$ 是 $\text{good}$ 的，当且仅当它可以重排成一个 $\text{PalindORme}$ 的序列。
>
> 给你 $n,k,m$，求长度为 $n$，每个元素值域为 $[0,2^k)$ 的序列中有多少个是 $\text{good}$ 的，对 $m$ 取模。
>
> $n,k\le 80$

神仙题。

考虑如何判断一个序列是否好，可以采用以下方法：

> 找到序列中两个相等的数放在最左边、最右边，并删掉其它的数中这两个数有的位，重复操作直到序列长度 $\le 1$。

然而这个操作无法直接变成 dp，因为一种操作顺序对应了一个序列，而非一个可以重排的可重集。

下一步是类似 数联通无向图个数 的容斥了，对每个 bad 序列，他一定存在**唯一**一个**最长**的 good 子序列，满足以下条件：

> 除开这个 good 子序列有的位，剩下的数其它位都互不相同。

如果最长 good 子序列是长度偶数，那它就是满足条件的。否则，如果这个子序列里面放在中间那一个数是包含在两边的数的 or 和内的，它也是满足条件的。否则，中间的数引入了新的位数，会导致这个子序列不唯一，难以计数。

比较显然，但确实很震撼。

称满足条件的 good 序列为合法 good 序列。所以可以这样算**合法** good 序列的数量：设 $f(n,m)$ 表示长度为 $n$，恰好有 $m$ 个位的**合法** good 序列的数量，答案是 $\sum \binom mi f(n,i)$。
$$
f(n,m)=all(n,m)-
$$

$$
\sum_{i<n}\sum_{j<m} \binom ni\binom mj f(i,j)2^{j(n-i)}g(n-i,m-j)
$$
枚举这个最长合法 good 子序列的长度及包含位数，$2^{j(n-i)}$ 表示包含在这些位里面的随便选，$g(n-i,m-j)$ 表示在 $0\sim 2^{m-j}-1$ 中选 $n-i$ 个两两不同的数且包含了所有 $m-j$ 位的方案数。$all,g$ 都可以容斥算。

这个 dp 不能算到前面说的 good 但不合法的情况，需要在 $n-1\to n$ 的时候特殊算一下这种情况的贡献。若视 $n=k$，复杂度 $O(n^4)$。

---

## 作者：pigstd (赞：10)

[CF1605F PalindORme](https://www.luogu.com.cn/problem/CF1605F)

一道 div2 赛时没人过的题，评分竟然只有 `2900`，小编也很惊讶，可是事实就是如此。

考虑已知一个序列如何判断他是好的：容易发现第一个和最后一个一定得相同，然后这些有 $1$ 的位数可以不管，然后需要再找到不管这些位数的情况下相同的两个数。实际上这个过程等价于每次找两个能匹配的放两边。

那么考虑一个坏的序列：那么的话必然是一直操作下去，直到剩下的数中没有相同的为止。如果有 $0$ 的话就再把这个 $0$ 加进去避免算重，这样就可以让一个坏的序列对应为一个长度为 $k$ 的好的序列。

考虑一个 dp，一个朴素的想法是 $dp_{i,j}$ 表示长度为 $i$ 的序列，每个数在 $[0,2^j)$ 之间的坏的序列的个数，但是这样子实际上是难以转移的，经过尝试之后，容易注意到，第二维可以设置成所有数的或的 $\text{popcount}$。那么转移的话，枚举这个坏的序列所对应的好的序列的长度和这个序列的或的 $\text{popcount}$，然后转移的方程为 $\displaystyle  dp_{i,j}=\sum_{w1,w2} (all_{w1,w2}-dp_{w1,w2})\times \dbinom{i}{w1} \times \dbinom{j}{w2} \times 2^{(i-w1)\times w2} \times f_{i-w1,j-w2}$，其中 $f(i,j)$ 表示 $i$ 个 $[1,2^j)$ 中的数，每个数最多出现一次，而且所有数的或为 $2^j-1$ 的方案数，$all_{i,j}$ 表示 $i$ 个 $[0,2^j)$ 的数组成的序列，所有的或为 $2^j-1$ 的方案数，这两个都可以容斥后预处理。时间复杂度 $\mathcal{O}(n^2k^2)$。[code](https://www.luogu.com.cn/record/63915933)。



---

## 作者：Aigony (赞：3)

为什么只有 \*2900 呢。总之就很理解为什么 3 月没补这题，因为确实看不懂！

考虑怎么判定一个已知的序列 $b$ 是 $\text{good}$ 的。首先一个边界条件是它可以选出一对相等的数，使得 $a_1=a_n$。

那么去掉这两个数对 $\text{or}$ 结果的影响，即为将 $b$ 中剩下的数所有 $a_1$ 有的位都变为 $1$。这样即消除了 $a_1$ 和 $a_n$ 的贡献，可以对长度为 $n-2$ 的子序列重复上述做法。

概括一下，我们用如下步骤判定一个序列：

- 在序列中选出两个相等的数 $x$，并删去它们；
- 对剩下的所有数，$b_i\gets b_i \text{ or } x$；
- 若序列删空，则为 $\text{good}$ 序列；若找不到相等的数，则为 $\text{bad}$ 序列；否则返回第一步。

注意到，$\text{good}$ 序列似乎仍是不好计数的，考虑反过来对 $\text{bad}$ 序列计数。我们定义一个 $\text{bad}$ 序列的「最长 $\text{good}$ 子序列」为其采用上述方法成功删去的数的集合。

可以证明，对于一个 $\text{bad}$ 序列，与之对应的最长 $\text{good}$ 子序列也可以唯一确定。  

挖掘一下剩下删不掉的序列的性质：除掉已经被删掉的数包含的二进制位外，剩下的数互不相同。

设 $f_{i,j}$ 表示长度为 $i$，值域在 $[0,2^j)$ 之间的 $\text{bad}$ 序列个数，发现这并不好转移。问题出在，比起关心一共有多少位，我们更关心的是有多少个位置的 $\text{or}$ 和是 $1$。

将状态改为 $f_{i,j}$ 表示长度为 $i$，所有数 $\text{or}$ 起来的 $\text{popcount}=j$ 的序列个数；$All_{i,j}$ 表示 $i$ 个值域在 $[0,2^j)$ 的数，它们按位或起来为 $2^j-1$ 的方案数；$g_{i,j}$ 表示在 $All_{i,j}$ 的基础上，每个数互不相同的方案数。其中 $All$ 和 $g$ 数组均可以通过经典的容斥求出。

枚举 $a$ 表示最长 $\text{good}$ 子序列的长度，$b$ 表示这个 $\text{good}$ 子序列按位或的 $\text{popcount}$。有转移：
$$
f_{i,j}\gets \sum_{a=0}^{i-1}\sum_{b=0}^{j-1} (All_{a,b}-f_{a,b})\binom{i}{a}\binom{j}{b}2^{(i-a)b}g_{i-a,j-b}
$$

其中 $All_{a,b}-f_{a,b}$ 即为可能的合法序列个数；两个组合数分别决定 $\text{good}$ 序列对应的位置和二进制位；$2^{(i-a)b}$ 表示原序列剩下的位置有 $b$ 个二进制位是随便选的，这样的数有 $(i-a)$ 个； $g_{i-a,j-b}$ 满足上文「删不掉的序列的性质」。

时间复杂度 $\mathcal{O}(n^2k^2)$，不过这个人懒得预处理快速幂，多个 $\log$ 也能过。
```cpp
#define int long long
const int N=85;
int n,K,mod;
int jc[N],inv[N];
il int qpow(int n,int k=mod-2)
{
    int res=1;
    for(;k;n=n*n%mod,k>>=1) if(k&1) res=res*n%mod;
    return res;
}
il void init(int mx)
{
    jc[0]=inv[0]=1;
    for(int i=1;i<=mx;i++) jc[i]=jc[i-1]*i%mod;
    inv[mx]=qpow(jc[mx]);
    for(int i=mx-1;i;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
il int C(int n,int m) 
{
    if(m>n) return 0;
    return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
int all[N][N],g[N][N],f[N][N];
il void add(int &x,int y) {x=((x+y)%mod+mod)%mod;}
signed main()
{
    n=read(),K=read(),mod=read();
    init(max(n,K));
    for(int i=0;i<=n;i++)
        for(int j=0;j<=K;j++)
        {
            for(int k=0;k<=j;k++)
            {
                add(all[i][j],C(j,k)*(j-k&1?-1:1)*qpow(2,k*i));
                int res=1;
                for(int l=qpow(2,k)-1;l>=qpow(2,k)-i;l--) res=res*l%mod;
                add(g[i][j],C(j,k)*(j-k&1?-1:1)*res%mod);
            }
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=K;j++)  
        {
            for(int a=0;a<i;a++)
                for(int b=0;b<j;b++)
                {
                    if(i==n&&n&1&&a+1==i) continue;
                    add(f[i][j],(all[a][b]-f[a][b])*C(i,a)%mod*C(j,b)%mod*qpow(2,(i-a)*b)%mod*g[i-a][j-b]%mod);
                }
        }
    int ans=0;
    for(int i=0;i<=K;i++) add(ans,(all[n][i]-f[n][i])*C(K,i)%mod);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Arghariza (赞：3)

不知道是怎么想到的。ntf 实在是不平凡的。/bx/bx/bx

你考虑如何判断一个序列是 $\text{good}$ 的。设重排后序列 $t_i$ 前缀 $[1,i]$ 和后缀 $[n-i+1,n]$ 按位或等于 $w_1$，$[1,i+1]$ 和 $[n-i,n]$ 按位或等于 $w_2$。不难发现 $w_1\subseteq w_2$，这说明 $w_2$ 和 $w_1$ 的**对称差**对应的那些位上，$t_{i+1}$ 和 $t_{n-i}$ 均为 $1$。于是扔掉顺序，就变成了 $b_i$ 里面任取两个数 $x,y$，令 $x',y'$ 为它们去掉当前按位或值 $V$ 是 $1$ 的位的值，那么 $x'=y'$，再将 $V\gets V\text{or}\ x'$。

合法的序列一定会判断合法，因为每步中满足条件的 $x,y$，如果它们没有被选，那么接下来选数时 $x,y$ 仍然合法。并且一定可以从一个不合法的序列中拆出一个合法的子序列，而且去掉这个子序列的或和为 $1$ 的位之后，剩下来的数**互不相同**。

为了避免算重，如果剩下的数中有 $0$，我们将其算进合法子序列内。

然后就可以数数了。设 $dp_{i,j}$ 为长度为 $i$，按位或的 $\text{popcount}$ 为 $j$ 的**不合法**序列的方案数。答案枚举 $j$ 求和即可。每次转移就枚举其合法子序列的长度以及值域（因为合法子序列的或值上的 $1$ 可以全部去除），显然：

$$dp_{i,j}=\sum\limits_{p\in [0,i),q\in [0,j)}(g_{p,q}-dp_{p,q})\dbinom{i}{p}\dbinom{j}{q}2^{(i-p)q}f_{i-p,j-q}$$

其中 $g_{i,j}$ 表示长度 $i$，值域 $[0,2^j)$ 的序列，按位或和为 $2^j-1$ 的序列个数。$f_{i,j}$ 表示长度 $i$，值域 $[1,2^j)$ 的序列，每个位置上的值**互不相同**，按位或和为 $2^j-1$ 的序列个数。$g_{p,q}-dp_{p,q}$ 就是合法子序列的个数，然后任取 $p$ 个位置和 $q$ 个二进制位。最后要求 $i-p$ 个数要**互不相同**，而且对于 $V$ 为 $1$ 的位，不合法的部分的数可以任选，所以乘上 $2^{(i-p)q}$。

至于如何计算 $f,g$，根据二项式反演（钦定一些位为 $1$）：

$$f_{i,j}=\sum\limits_{k=0}^j\dbinom{j}{k}(-1)^{j-k}(2^k-1)^{\underline{i}}$$
$$g_{i,j}=\sum\limits_{k=0}^j\dbinom{j}{k}(-1)^{j-k}(2^k)^i$$

做完了，复杂度 $O(n^2k^2)$。

[评测记录。](https://codeforces.com/contest/1605/submission/196570190)

---

upd : 详细证一下最后那个式子。

考虑计算 $g$，首先令 $t_{i,j}$ 为长度 $i$，值域 $2^{j}-1$ 随便选的方案。显然 $t_{i,j}=2^{ij}$。

考虑选出 $k$ 位，使得或起来后这些位为 $1$，其它全是 $0$。去掉其它位后，只剩 $k$ 位，所以方案数就是 $g_{i,k}$。

那么枚举 $k$：

$$t_{i,j}=\sum\limits_{k=0}^j\dbinom{j}{k}g_{i,k}$$

其实本质是容斥，二项式反演即可。$f$ 同理。

---

## 作者：Albert_Wei (赞：1)

#### $\mathbf{Part. 0}$ 如何判定

首先依然考虑如何判定。容易注意到只有 $i \le \dfrac{n}{2}$ 的限制有用。我们考虑贪心。每次对于两个相等的数，则令它们分别为 $a_1, a_n$，并将它们二进制为 $1$ 的位删去。重复该过程，显然原序列是好的当且仅当可以将原序列删空或只留一个元素。

#### $\mathbf{Part.1}$ 分析性质

对于一个坏序列，我们考虑贪心地删元素后序列的剩余部分，我们希望它是唯一的，但其实并不是。我们容易发现留下的序列中 $a_i$ 互不相同，且若 $(a_i, a_j)$ 在若干次操作前已经相等，则操作后必然仍相等。考虑利用以上两条性质分析序列剩余部分满足的条件。如果存在两个不同的操作若干次后的子序列 $A, B$ 均不能操作，我们考虑说明两者删去的二进制位一定相同。我们设 $A$ 中按 $x_1, x_2, \cdots, x_i$ 的顺序删去二进制位，$B$ 中按 $y_1, y_2, \cdots, y_j$ 的顺序删去二进制位，不妨 $i \ge j$，则由假设，$\exist x_k \not \in \{y_1, y_2, \cdots, y_j\}$，我们找到满足这样条件最小的 $k$。我们设操作到 $A$ 的过程中，$(u, v)$ 操作删去了二进制的第 $x_k$ 位。则若 $u$ 或 $v$ 在 $B$ 中已经操作过，第 $x_k$ 位显然已经被删去，矛盾。若 $(u, v)$ 还未被操作过，由于 $k$ 的最小性，知此时 $(u, v)$ 在 $B$ 中可以被操作，矛盾。

故我们说明了，操作到不能操作后，剩余的二进制位构成的集合是固定的。进一步，我们可以发现，若在某种操作方法里，$a_x$ 可以被删去，则在其他情况下，$a_x$ 要么变成 $0$，要么被删去，且这样的 $x$ 至多有一个。

#### $\mathbf{Part.2}$ 找到坏序列与长度更小的好序列的一一对应

对于一个序列，我们称其的最长好子序列 $a_{i_1}, a_{i_2}, \cdots, a_{i_m}$ 为满足：

1. $a_{i_1}, a_{i_2}, \cdots, a_{i_m}$ 是好的。
2. 记 $S_i$ 为 $i$ 的二进制为 $1$ 的位构成的集合，若 $2 \nmid m$，则 $S_{i_{\frac{m + 1}{2}}} \subseteq \bigcup\limits_{j \neq \frac{m + 1}{2}} S_{i_j}$，即 $a_{i_{\frac{m + 1}{2}}}$ 在贪心删元素与二进制位的过程后会变为 $0$。
3. 是满足上述条件的子序列中最长的。

根据 $\mathbf{Part.2}$ 的论述，我们发现该子序列恰为所有可能被删去的元素，故是唯一的。

#### $\mathbf{Part.3}$ 设计dp

下称满足 $\operatorname{popcount}(a_1 \operatorname{or} a_2 \operatorname{or} \cdots \operatorname{or} a_i) = j$ 的序列 $a_1, \cdots, a_i$ 为恰含有 $j$ 个二进制位的序列。考虑设 $f_{i, j}$ 表示长度为 $i$，恰含有 $j$ 个二进制位的合法序列数。**注意，对于 $2 \nmid i$ 的情况，我们只计数排序后 $a_{\frac{i + 1}{2}}$ 不产生新的二进制 $1$ 位的序列**。记 $g_{i, j} = \sum\limits_{k = 0} ^ j \dbinom{j}{k} (-1) ^ {j - k} 2 ^ {ik}$ 表示长度为 $i$，恰含有 $j$ 个二进制位的所有序列数。记 $h_{i, j} = \sum\limits_{k = 0} ^ j \dbinom{j}{k} (-1) ^ {j - k} (2 ^ k − 1) ^ {\underline{i}}$ 表示长度为 $i$，每个元素不为 $0$ 且互不相同，且恰含有 $j$ 个二进制位的序列个数。考虑转移。我们考虑枚举最长好子序列的长度为 $k$，恰含 $l$ 个二进制位。则转移为 $f_{i, j} = g_{i, j} - \sum\limits_{k = 0} ^ {i - 1} \sum\limits_{l = 0} ^ {j - 1} \dbinom{i}{k} \dbinom{j}{l} 2 ^ {l(i - k)}h_{i - k, j - l}f_{k, l}$。注意由于题目并未限制 $a_{\frac{n + 1}{2}}$ 的二进制 $1$，在 $2 \nmid n$ 的 $f$ 的转移时，我们不需要减去 $k = n - 1$ 的情况，特判即可。复杂度 $\mathcal{O}(n ^ 2 k ^ 2)$，需要预处理 $2$ 的幂。

---

## 作者：_Cheems (赞：1)

先只考虑偶数。要计数，先判定，构造单射，令 $b_i=a_{p_i}$。起始情况选取两个相等的数填到 $b_1,b_n$，然后假设已经确定 $b_1\dots b_{i-1},b_{n-i+2}\dots b_n$，设 $S$ 为或之和，那么选取的两个数 $x,y$ 合法，当且仅当 $S$ 为 $0$ 的那些位上 $x,y$ 相等。

这相当于填写一个回文序列，只不过每次忽略掉一些位。注意一下，假如某一次填写有多种选择，随便选一种即可，因为其它选择之后也必然合法。

然后考虑不完美序列与完美序列的联系，可以发现，两者互为补集，同时不完美序列由 $[1,i],[i+1,n-i],[n-i+1,n]$ 构成，其中 $[1,i]+[n-i+1,n]$ 是完美序列，$[i+1,n-i]$ 由忽略某些位后互不相等的元素构成。

于是设计状态 $f_{i,j}$，表示已经填写 $b_1\dots b_i,b_{n-i+1}\dots b_n$，恰好涉及 $j$ 位，对应的 $a_1\dots a_n$ 的不同方案数。

$b\to a$ 并不构成单射，所以要着重关注去重。

然后设计辅助状态 $all_{i,j},dif_{i,j}$，分别表示总集、互不相等方案数。不难容斥得出。

然后有转移：

$$f_{n,k}=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{k-1}{n\choose i}{k\choose j}(all_{i,j}-f_{i,j})dif_{n-i,k-j}2^{(n-i)j}$$

解释：$i,j$ 不能取到 $n,k$ 否则会出错。组合数在 $a$ 中选择若干位置和二进制位作为完美序列部分，总集减 $f$ 是求这些位置的完美序列，最后是互不相等部分，二次方部分是为互不相等部分的数确定被忽略的二进制位的取值。

看起来很完美，不是吗？考察一下这样做会不会算重（显然不会算少）。考虑完美序列部分与互不相等部分，我们必须满足两者没有相同的元素，才能使用 ${n\choose i}$ 将两者组合为一体，否则映射到 $a$ 上就会算重。

记完美序列部分设计到的位为本原位，其余的是新增位。
由于互不相等部分的新增位有值，而完美序列部分此处无值，所以不会算重。但是！这题毒瘤的地方来了，$a$ 可以填 $0$！所以就会导致两个部分有交于是算重。

怎样解决呢？观察到互不相等部分至多有一个 $0$，这启示我们按是否有 $0$ 分类转移。

一种好写的解决方案是修改完美序列的定义。若长度为偶数，保留原有定义。若为奇数，就让它必须存在一个 $0$，且除掉一个 $0$ 后为完美序列（是题面的定义）。同理能推出 $f$ 的定义。

然后让 $dif$ 不能填 $0$，这样转移枚举的两部分不可能相交了。

然后解释下修改后的转移：

* 偶数长度：假如枚举的两部分为偶数，那么就能求出不存在 $0$ 的方案；否则就是求有 $0$ 方案，可以理解为让奇完美序列保留的那个 $0$ 加到互不相等序列中（显然加完后依旧互不相等）。

* 奇数长度：此时 $f$ 的定义为互不相等部分长度大于 $1$（即题面定义的不完美序列）或互不相等部分长度为 $1$ 且不为 $0$。那么当枚举的互不相等部分大于 $1$ 时就是对应了前者，否则对应了后者。

这样就不会算重了！更好的是，转移没有发生变化，仅仅是多考虑了奇数并修改 $dif$ 的定义。

然后答案是 $\sum\limits_{i=0}^k {k\choose i}f_{n,i}$。

假如 $n$ 为奇数怎么办？根据题面定义，那么 $f_{n,i}$ 不应该包含“互不相等部分长度为 $1$ 且不为 $0$” 这部分，因为剩下的一个元素想填啥就填啥。所以此时不要转移即可。即 $i=n-1$ 且 $n$ 为奇数时不转移。
#### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define ADD(a, b) a = (a + b) % mod
const int N = 1e2 + 5;
int T, n, m, mod, ans;
int jc[N], jcinv[N];
int all[N][N], dif[N][N], f[N][N], bas[N * N]; 

inline int qstp(int a, int k) {int res = 1; for(; k; a = a * a % mod, k >>= 1) if(k & 1) res = res * a % mod; return res;}
inline int C(int n, int m) {return (n < 0 || m < 0 || n < m) ? 0 : jc[n] * jcinv[m] % mod * jcinv[n - m] % mod;}
signed main(){
	scanf("%lld%lld%lld", &n, &m, &mod);
	jc[0] = jcinv[0] = bas[0] = 1;
	for(int i = 1; i < N; ++i) jcinv[i] = qstp(jc[i] = jc[i - 1] * i % mod, mod - 2);  
	for(int i = 1; i < N * N; ++i) bas[i] = bas[i - 1] * 2 % mod;
	memset(all, 0, sizeof all), memset(dif, 0, sizeof dif), memset(f, 0, sizeof f);
	
	for(int i = 0; i <= n; ++i)
		for(int j = 0; j <= m; ++j)
			for(int k = 0, fl = 1; k <= j; ++k, fl = mod - fl){
				int res = fl * C(j, k) % mod, cnt = 1; 
				ADD(all[i][j], res * bas[i * (j - k)] % mod);
				for(int p = bas[j - k] - 1, lby = 1; lby <= i; ++lby, p = (p + mod - 1) % mod) cnt = cnt * p % mod;
				ADD(dif[i][j], res * cnt % mod);
			}
	all[0][0] = 1; 
	
	for(int i = 0; i <= n; ++i)
		for(int j = 0; j <= m; ++j)
			for(int k = 0; k < i; ++k)
				for(int p = 0; p < j; ++p){
					if(k == n - 1 && n % 2 == 1) continue;
					ADD(f[i][j], C(i, k) * C(j, p) % mod * (all[k][p] - f[k][p] + mod) % mod * dif[i - k][j - p] % mod * bas[(i - k) * p] % mod);
				}
	for(int j = 0; j <= m; ++j) ADD(ans, (all[n][j] - f[n][j] + mod) * C(m, j) % mod);
	cout << ans;
	return 0;
}
```

---

## 作者：bamboo12345 (赞：0)

看了 n 年才发现自己读错题了。

题意：很简单了，不再赘述。

做法：

一般来说给了一个定义就先手玩一下感受一下，我们从 $i=1$ 开始手玩：

$$a_1 = a_n$$
$$a_1|a_2 = a_{n-1}|a_n$$

我们先考虑相邻的这两个限制，会发现一个事情，对于 $a_{n-1}$ 和 $a_2$，他们会多出来的位一定是相同的，对于其他的讨论同样有此结论。

那么我们就可以给出来一个合法序列的充要条件，假设我们目前序列中已有的数或值为 $V$，那么要求能选出两个数 $x,y$，满足 $V|x = V|y$，然后把他们加入集合中。

有了这个条件我们再考虑计数，直接计数好像并不太容易，注意到不能继续操作的时候肯定是除去 $V$ 中位的时候剩余的数各不相同，这个看起来很容易计数，我们考虑计数不能的方案再减去。

首先我们计算总的方案数，记 $f_{i,j}$ 代表序列长为 $i$，二进制位恰好有 $j$ 位时的总序列数，那么直接容斥 $j$，可以得到转移式：

$$f_{i,j} = \sum_{k=0}^j(-1)^{j-k}C_{j}^k(2^k)^i$$

然后我们考虑用 $g_{i,j}$ 代表序列长为 $i$，二进制位恰有 $j$ 位时不合法序列数，这里我们考虑直接枚举到什么时候我们无法操作了，有转移式：

$$g_{i,j} = \sum_{x = 0}^{i-1}\sum_{y=0}^{j-1} (f_{x, y} - g_{x,y})\times (2^y) ^ {i-x}C_{i}^xC_j^y \times [长为 i-x，用了恰好 j-y 个位的序列数量]$$

解释一下，$f_{x,y}-g_{x,y}$ 是枚举的合法序列数量，$(2^y)^i$ 是因为我这剩下的 $i-x$ 个数在这 $y$ 位中可以随意选择，组合数就是选出来的方案数。

那么看到上面还有一个东西要求，我们可以再设一个，$h_{i,j}$ 代表序列长为 $i$，二进制位恰有 $j$ 位时，所有数全都不同且没有 $0$ 有多少种方案，还是对 $j$ 容斥得到式子：

$$h_{i,j} = \sum_{k=0}^j(-1)^{j-k}C_j^k(2^k-1)^{\underline{i}}$$

注意我们这里特别强调了没有 $0$，因为如果我们前面填了 $0$，但是我们在这个不能操作的序列中也有 0，这样就重复了，所以我们这里不能让他有 $0$。

注意到一个事情，如果说是奇数的 $n$，那么显然最后的时候我们其实是可以填一个 $0$ 上去的，所以注意转移 $g$ 的时候此时不能转移。

复杂度 $O(n^2k^2)$。

---


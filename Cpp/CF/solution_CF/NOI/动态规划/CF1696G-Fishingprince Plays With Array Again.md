# Fishingprince Plays With Array Again

## 题目描述

给定一个以 $1$ 为下标起点的非负整数序列 $a$，长度为 $n$，以及两个整数 $x$、$y$。在连续的 $t$ 秒内（$t$ 可以为任意正实数），你可以进行以下两种操作之一：

- 选择 $1\le i<n$，将 $a_i$ 减少 $x\cdot t$，并将 $a_{i+1}$ 减少 $y\cdot t$。
- 选择 $1\le i<n$，将 $a_i$ 减少 $y\cdot t$，并将 $a_{i+1}$ 减少 $x\cdot t$。

定义使序列中所有元素都小于等于 $0$ 所需的最少时间（可能为实数）为 $f(a)$。

例如，当 $x=1$，$y=2$ 时，处理数组 $[3,1,1,3]$ 需要 $3$ 秒。可以这样操作：

- 首先用 $1.5$ 秒对 $i=1$ 执行第二种操作。
- 接着用 $1.5$ 秒对 $i=3$ 执行第一种操作。

可以证明，不可能在少于 $3$ 秒内使所有元素小于等于 $0$，因此 $f([3,1,1,3])=3$。

现在，给定一个以 $1$ 为下标起点的正整数序列 $b$，长度为 $n$。还给定正整数 $x$、$y$。你需要处理 $q$ 个如下两种类型的操作：

- 1 k v：将 $b_k$ 修改为 $v$。
- 2 l r：输出 $f([b_l,b_{l+1},\dots,b_r])$。

## 说明/提示

我们来分析样例。

在第一个查询中，要求计算 $f([3,1,1,4])$。答案为 $3.5$。一种最优操作序列为：

- 首先用 $1.5$ 秒对 $i=1$ 执行第二种操作。
- 接着用 $2$ 秒对 $i=3$ 执行第一种操作。

在第三个查询中，要求计算 $f([1,1,1])$。答案为 $1$。一种最优操作序列为：

- 首先用 $0.5$ 秒对 $i=1$ 执行第二种操作。
- 接着用 $0.5$ 秒对 $i=2$ 执行第一种操作。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 3
1 2
3 1 1 4
2 1 4
1 1 1
2 1 3```

### 输出

```
3.500000000000000
1.000000000000000```

# 题解

## 作者：老莽莽穿一切 (赞：13)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16427416.html)

---

考虑如果没有修改，单次查询怎么做。

我们可以先将询问的式子写出来，我们设在 $i$ 位置花费在 $1$ 操作上的时间为 $t_{i,1}$，同理花费在 $2$ 操作上的时间为 $t_{i,2}$，则可以得到下面的式子：

$$
\begin{aligned}
&\min\sum_{i=1}^{n-1}t_{i,1}+t_{i,2}\\
&\begin{cases}
Xt_{1,1}+Yt_{1,2}\ge a_1\\
\forall i\in(1,n)\cap\mathbb Z,\ Yt_{i-1,1}+Xt_{i-1,2}+Xt_{i,1}+Yt_{i,2}\ge a_i\\
Yt_{n-1,1}+Xt_{n-1,2}\ge a_n\\
\forall i\in[1,n]\cap\mathbb Z,\ t_{i,1}\ge0,t_{i,2}\ge0
\end{cases}
\end{aligned}
$$

可以看出这是一个线性规划，但现在这个线性规划的未知数实在太多，反而限制比未知数还少，我们考虑得到该问题的**对偶问题**。

首先这个式子非常难看，所以我们很难一下子找到它的对偶问题，所以把整个方程先展开成表格（这个表格可能会有一点大，空格处都为 $0$）：


|$t_{1,1}$|$t_{1,2}$|$t_{2,1}$|$t_{2,2}$|$t_{3,1}$|$t_{3,2}$|$\cdots$|$t_{n-2,1}$|$t_{n-2,2}$|$t_{n-1,1}$|$t_{n-1,2}$|        |         |
|:-:      |:-:      |:-:      |:-:      |:-:      |:-:      |:-:     |:-:        |:-:        |:-:        |:-:        |:-:     |:-:      |
|$X$      |$Y$      |         |         |         |         |$\cdots$|           |           |           |           |$\ge$   |$a_1$    |
|$Y$      |$X$      |$X$      |$Y$      |         |         |$\cdots$|           |           |           |           |$\ge$   |$a_2$    |
|         |         |$Y$      |$X$      |$X$      |$Y$      |$\cdots$|           |           |           |           |$\ge$   |$a_3$    |
|$\vdots$ |$\vdots$ |$\vdots$ |$\vdots$ |$\vdots$ |$\vdots$ |$\ddots$|$\vdots$   |$\vdots$   |$\vdots$   |$\vdots$   |$\vdots$|$\vdots$ |
|         |         |         |         |         |         |$\cdots$|$X$        |$Y$        |           |           |$\ge$   |$a_{n-2}$|
|         |         |         |         |         |         |$\cdots$|$Y$        |$X$        |$X$        |$Y$        |$\ge$   |$a_{n-1}$|
|         |         |         |         |         |         |$\cdots$|           |           |$Y$        |$X$        |$\ge$   |$a_n$    |

这下好找多了，把方程重新竖着写，答案就直接出来了，对偶问题就是：

$$
\begin{aligned}
&\max\sum_{i=1}^{n}a_ix_i\\
&\begin{cases}
\forall i\in[1,n]\cap\mathbb Z, Xx_i+Yx_i\le1\\
\forall i\in[1,n]\cap\mathbb Z, Yx_i+Xx_i\le1\\
\forall i\in[1,n]\cap\mathbb Z,\ x_i\ge0
\end{cases}
\end{aligned}
$$

这个式子看上去比起上面的那是相当好看了，然后我们思考如何求解这个线性规划。

解决这个问题的最大阻碍是每个变量的可取值太多，但是介于这些约束条件是特别优美的，我们可以试图挖掘一些性质，首先给出结论：令 $X>Y$（所有关于 $X$，$Y$ 的式子都是对称的，所以无所谓），则 $\forall i\in[1,n]\cap\mathbb Z,\ x_i\in\{\frac1X,\frac1{X+Y},0\}$，下面给出两种证明：

从一个比较粗略感性的角度来想，我们先给所有变量随机分配一个值，然后对其进行调整，由于所有约束条件都只约束相邻两个，所以我们肯定是在相邻的变量上做文章，可以想象我们的调整应该会是将一个值升高或降低再将其两边进行对应调整，同样也可以猜测结果的边界，因为会一直调整，所以结果要么是一个满的两边都是空的，要么是相邻两个相等，前者情况是中间 $\frac1X$，两边 $0$，后者是相邻两个都为 $\frac1{X+Y}$。

更加理性的证明并不是没有，我们知道一个线性规划问题的解本质上是在求一个高维凸包的切，其答案必然经过高维凸包的至少一个端点，而穿过端点说明它会使一些约束条件到达**边界**，且显然每一个变量都至少被一个约束条件约束到边界上，我们接下来进行一些构造，我们将每个变量视为一个点，我们将所有到达边界的约束条件取出用于连边，如果一个约束条件只和一个点有关（约束中的另一个点为 $0$ 或本身为 $0$），则连接一个自环，否则如果该约束条件与 $i$ 和 $i+1$ 有关，则连接一条边 $\langle i,i+1\rangle$，结论是这张图中任意一个点和任意一条边都会被包含在环里，可以进行证明：

点的部分可以在边的部分证明完成后自然得证，所以我们率先证明边的结论：首先发现如果不是环就只可能是一条链，链中的节点一定是连续的，我们将所有节点分成奇偶两类，可以很容易地得知同一类中所有点对应的变量的取值都是相同的，假设变量取值更大的集合是 $A$，另一个集合是 $B$，因为如果 $A$ 与 $B$ 中元素不可能相等，因为相等时即同时满足 $i$ 与 $i+1$ 间的两个约束条件，形成一个二元环，否则肯定满足 $\forall i\in A,j\in B,\ Xx_i+Yx_j=1$，证明显然，我们可以发现此时我们令 $A$ 集合对应位置的序列 $a$ 中元素的和为 $s_A$，同理 $B$ 集合对应的和为 $s_B$，我们此时发现，如果任何 $A$ 集合中元素变化 $Yd$，则 $B$ 集合中元素反向 $Xd$，此时所有约束保持不变，若 $Xs_B>Ys_A$，则此时可以将集合 $B$ 中的元素一直增大到**临界点**，即 $A$ 中元素与 $B$ 中元素相等，此时若继续变化还可以更优就是另一种情况，即 $Ys_A>Xs_B$，此时可以一直增加直到 $B$ 中所有元素的值为 $0$，则整条链消失，每个元素被自环约束，且因为刚刚的操作一直在使答案增加，所以刚刚是链的情况显然不会是最优解，若满足 $Ys_A=Xs_B$，我们发现已经满足 $s_A>s_B$，当 $B$ 最开始增加时答案不变，而当其达到临界点后 $A$ 和 $B$ 发生反转，此时一直增加答案达到最优。

上面证明了每条边在环内，而每个变量至少被一个约束条件边界约束，自然得证。

我们发现自环的情况就是 $0$ 和 $\frac1X$，而二元环中两元素相等同时满足两个约束即 $\frac1{X+Y}$，我们就证明了答案只可能从三种情况产生（上面的证明可能有误，但结论正确，如有纰漏欢迎指正）。

现在我们就可以非常简单地解决单次查询了，可以使用 dp，发现动态询问是经典的单点修改区间查询，所以考虑使用线段树，而我们的 dp 正好满足区间可加性，设 $f_{l,r,0/1/2,0/1/2}$ 表示 $[l,r]$ 区间内左端点取 $0/\frac1{X+Y}/\frac1X$，右端点同理的最优解，可以简单地动态维护，这里代码实现上可以使用一点小技巧，就是这个方程的转移形如可以稍微改一下 dp 状态定义，设 $f_{l,r,0/1/2,0/1/2}$ 表示 $[l,r]$ 区间内左端点取 $0/\frac1{X+Y}/\frac1X$，右端点**后一位最大允许取 $0/\frac1{X+Y}/\frac1X$**，此时转移形如 $f_{l,r,i,j}=\max_{k\in\{0,1,2\}}f_{l,mid,i,k}+f_{mid+1,r,k,j}$，转移形似矩阵乘法，实际上就是广义矩乘，可以直接用矩阵类实现，状态中的 $l,r$ 其实在线段树内部自带，无需维护。

[**代码**](https://codeforces.com/contest/1696/submission/162184667)相较于思路上的头脑风暴，可以说是非常简单了。

---

## 作者：周子衡 (赞：7)

先把结论发出来，晚些补证明。方便起见，假定 $x < y$。

考虑对某个给定的序列 $c_1,...,c_n$，怎么方便地计算 $f([c_1,...,c_n])$。考虑去找出 $F=f([c_1,...,c_n])$ 的一些下界：

- 由于单位时间内所有数的总和只变小 $x+y$，有 $F\geq \dfrac{\sum c_i}{x+y}$。
- 单位时间内，奇数位置上的数的总和至多变小 $y$，偶数也是。则 $F\geq \dfrac{c_1+c_3+\cdots}{y}$，$F\geq \dfrac{c_2+c_4+\cdots}{y}$。
- 实际上上一条仍然是不够紧的。考虑序列 $[1,0,0,1]$，虽然两个 $1$ 分别在奇数位、偶数位，但我们仍然不能同时减小这两个位置的值。也就是说，$F\geq \dfrac{c_1+c_4}{y}$。

摸索一番后，我们可以得到一个较普遍的形式：

**性质** 对任意满足下列条件的序列 $d_1,...,d_n$：
- $d_i\in \{0,\dfrac{1}{x+y},\dfrac{1}{y}\}$；
- 若某个 $d_i=\dfrac{1}{y}$，则 $d_{i-1}=d_{i+1}=0$。这里认为 $d_0=d_{n+1}=0$；

都有 $F\geq \sum_{i=1}^n c_id_i$。

证明比较直观：设所有 $d_i=\dfrac{1}{y}$ 的 $c_i$ 和为 $S_1$，$d_i=\dfrac{1}{x+y}$ 的 $c_i$ 和为 $S_2$。由于组成 $S_1$ 的都是单点，在某段很短的时间 $t$ 内，我们要么使得 $S_1$ 下降 $yt$，要么使得 $S_2$ 下降 $(x+y)t$，即证。

可以猜想，这样找到的最大限制即为 $F$ 最终的值。证明我目前还没想清楚，想清楚了会在这里更新。

回到原题。由于要支持修改、查询操作，我们需要一种支持维护序列区间信息的数据结构，下面以线段树为例。在线段树的每个节点 $[l,r]$ 上，我们维护一个矩阵 $D$，$D_{a,b}$ 表示 $d_l=a,d_r=b$ 时，区间内 $\sum c_id_i$ 的最大值。由于 $a,b$ 只能取自 $\{0,\dfrac{1}{x+y},\dfrac{1}{y}\}$，下面代码里分别用 $0,1,2$ 来对应这三种取值。这样修改、区间查询都可以轻松解决，总时间复杂度 $O((n+q)\log n)$。

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

const double INF=1e15;

double x,y;

struct MAT
{
	double num[3][3];
	MAT(){for(int i=0;i<3;i++)for(int j=0;j<3;j++)num[i][j]=-INF;}
	double* operator[](int x){return num[x];}
};
MAT operator*(MAT a,MAT b)
{
	MAT c;
	for(int i=0;i<3;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++)c[i][j]=max(c[i][j],a[i][k]+b[k][j]);
	return c;
}

MAT C;
struct SegmentTree
{
	struct nd
	{
		int l,r;MAT D;
	}t[800000];
	void build(int l,int r,int k=1)
	{
		t[k].l=l,t[k].r=r;if(l==r)return;
		int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	}
	void update(int pos,double val,int k=1)
	{
		if(t[k].l==t[k].r)
		{
			t[k].D[0][0]=0,t[k].D[1][1]=val/(x+y),t[k].D[2][2]=val/y;return;
		}
		int mid=(t[k].l+t[k].r)>>1;if(pos<=mid)update(pos,val,k<<1);else update(pos,val,k<<1|1);
		t[k].D=t[k<<1].D*C*t[k<<1|1].D;
	}
	MAT query(int l,int r,int k=1)
	{
		if(l<=t[k].l&&t[k].r<=r)return t[k].D;
		int mid=(t[k].l+t[k].r)>>1;
		if(r<=mid)return query(l,r,k<<1);
		if(l>mid)return query(l,r,k<<1|1);
		return query(l,r,k<<1)*C*query(l,r,k<<1|1);
	}
}T;



int main()
{
	C[0][0]=C[0][1]=C[0][2]=C[1][0]=C[2][0]=C[1][1]=0,C[1][2]=C[2][1]=C[2][2]=-INF;
	int n=0,q=0;scanf("%d%d%lf%lf",&n,&q,&x,&y);if(x>y)swap(x,y);T.build(1,n);
	for(int i=1;i<=n;i++){double b=0;scanf("%lf",&b);T.update(i,b);}
	while(q--)
	{
		int op=0;scanf("%d",&op);
		if(op==1)
		{
			int pos=0;double v=0;scanf("%d%lf",&pos,&v);T.update(pos,v);
		}
		else
		{
			int l=0,r=0;scanf("%d%d",&l,&r);
			MAT M=T.query(l,r);double ans=-INF;for(int i=0;i<3;i++)for(int j=0;j<3;j++)ans=max(ans,M[i][j]);
			printf("%.10lf\n",ans);
		}
	}
}
```

**关于证明（更新时间：2022 年 6 月 30 日）**

其实上面的整个思路和线性规划对偶定理“以下界逼近上界”的思想不谋而合。我试图找一个不用到线性规划理论的简单证明，不过没找到。下面我们来用线性规划证明这个结论。

考虑先把原问题转化为线性规划的形式。可以构造出下面的例子：

$$
\min \sum_{i=1}^nu_i+\sum_{i=1}^nv_i
$$

其中 $u_i,v_i(i\in [1,n])$ 是变量，需要满足：

$$
u_i,v_i\geq 0
$$

$$
xu_i+yv_i+yu_{i-1}+xv_{i+1}\geq c_i
$$

其中 $u_i$ 表示让第 $i$ 个位置减 $x$，第 $i+1$ 个位置减 $y$ 的总时间，$v_i$ 表示让第 $i$ 个位置减 $y$，第 $i+1$ 个位置减 $x$ 的总时间。

考虑这个问题的对偶问题。其为：

$$
\max\sum_{i=1}^nc_id_i
$$

其中 $d_i(i\in [1,n])$ 为变量，满足：

$$
xd_i+yd_{i-1}\leq 1\ \ (1)
$$

$$
xd_{i-1}+yd_{i}\leq 1\ \ (2)
$$

$$
d_i\geq 0\ \ (3)
$$

我们将证明一定存在一组最优的 $d_i$ 符合我们之前提到的形式。方便起见，下面称统称条件 $(1)\sim (3)$ 为条件。称 $d$ 某个元素是好的当且仅当它属于 $\{0,\dfrac{1}{y},\dfrac{1}{x+y}\}$ 之中。

考虑对于一组任意符合条件的 $d_i$，我们说明如果 $d$ 中不是所有元素都是好的，那么一定存在一组 $d'_i$ 使得 $d'$ 好元素比 $d$ 多，且 $d'$ 不劣于 $d$，从而说明上面提到的做法的正确性。我们来对 $d_i$ 进行如下调整：

- 对每个 $i$，如果 $d_{i-1},d_{i+1}\leq \dfrac{1}{x+y}$ 且 $d_i < \dfrac{1}{x+y}$，则令 $d_i\gets \dfrac{1}{x+y}$。这一步并不会破坏条件，且会增大目标式。
- 在经过上一步操作之后，相邻两个位置必有至少一个 $\geq \dfrac{1}{x+y}$。注意到任何时刻不会相邻两个位置都 $ > \dfrac{1}{x+y}$；若某个位置值为 $\dfrac{1}{y}$，则周围两个位置一定为 $0$，我们把这三个位置删去，两边断开。在没被删去的位置中，我们认为所有 $ > \dfrac{1}{x+y}$ 的位置是黑的，其他位置是白的。两个黑位置如果下标之差等于 $2$ 则认为它们相邻。考虑一段极长的相邻黑段，以及和该段内黑点相邻的白点。可知这些点目前都不是好元素，我们考虑不断给所有黑点加一个极小量，同时给所有白点减一个极小量，直到某个黑点变成 $\dfrac{1}{y}$；或者给所有白点加一个量、黑点减一个量，直到某个黑点变成 $\dfrac{1}{x+y}$。注意到上面两种策略对总贡献代价加起来为 $0$，那么一定有一侧 $\geq 0$，选择这一侧的操作即可让好元素数量增加。

综上，我们便证明了：上述策略能找到最优解。

**后记：关于线性规划**

似乎这东西在 OI 圈内不甚普及。这里给出一个简单的介绍，更详细的资料大家可以在网上查找。

常遇到这样一类问题：有若干变量、若干限制，变量值域为全体实数；每个限制都形如“$x_1\sim x_5$ 的和不超过 $1$、$2x_6+3x_7\geq 8$”这样，对若干变量的线性式的范围限制；在这些限制下，我们要求某个式子的最值，这个式子也是关于这些变量的线性式。我们可以将这类问题进行泛化：

- **线性规划问题（标准型）：** 有 $n$ 个 **非负** 实变量 $x_1,...,x_n$，需要满足 $m$ 条限制，第 $j$ 条限制形如 $a_{j,1}x_1+\cdots +a_{j,n}x_n\leq b_i$。再给出 $n$ 个系数 $c_1,...,c_n$，求 $\sum c_ia_i$ 的最大值。

注意到上面给每个变量加上了非负的限制，不过一般情况下这不重要。

我们考虑不断用限制“凑”出目标式的形式。举个简单的例子：假如限制了 $p,q,r\geq 0,p+q+r\leq 2,2p+q+5r\leq 3$，我们很容易知道 $3p+2q+6r\leq 5$（因为它等于两条限制加起来）；同时也知道 $3p+2q+5r\leq 5$，因为显然 $5r\leq 6r$。我们来用规范的语言来描述“凑系数”这件事。具体来说，假设我们要给第 $j$ 条式子乘上 $y_j$，那么应该有：

- $y_j\geq 0$。（否则不等式就反号了。）
- 对每个 $i=1,...,n$，都有 $a_{1,i}y_1+a_{2,i}y_2+\cdots+a_{m,i}y_m\leq c_i$。（否则凑出的式子有一项比目标式大，这是不合理的。）

对每一组符合条件的 $y$，我们都知道上面那个问题的答案不超过 $\sum b_iy_i$。为了得到上面那个问题的答案，我们需要去找出所有限制中最紧的那一条，也就是 $\sum b_iy_i$ 的最小值。此时我们惊奇地发现：这不就是另一个线性规划问题吗？

实际上，这就是线性规划中关键的“对偶问题”的概念。显然的事实是，在上面的设定下，原问题的最优解（最大值）一定小于等于对偶问题的最优解（最小值）。这称为 **弱对偶定理**。而 **强对偶定理** 则进一步说明了这两者一定相等。直观上看也不难理解，但严格证明有些困难，可以参考其他资料。

---


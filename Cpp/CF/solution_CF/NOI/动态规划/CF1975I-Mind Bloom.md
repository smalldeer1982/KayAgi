# Mind Bloom

## 题目描述

这就是一切一直以来的样子。

这也将是未来永远的样子。

一切很快又会被遗忘……

Jellyfish 正在玩一款单人卡牌游戏“Slay the Spire”。共有 $n$ 张卡牌，编号从 $1$ 到 $n$。第 $i$ 张卡牌的力量为 $c_i$。

有一个长度为 $n$ 的二进制字符串 $s$。如果 $s_i = \texttt{0}$，则第 $i$ 张卡牌最初在抽牌堆中。如果 $s_i = \texttt{1}$，则第 $i$ 张卡牌最初在 Jellyfish 的手牌中。

Jellyfish 会重复以下过程，直到她的手牌或抽牌堆为空为止：

1. 设 $x$ 为她手牌中力量最大的卡牌的力量。
2. 将一张力量为 $x$ 的卡牌放回抽牌堆。
3. 从抽牌堆中随机抽取 $x$ 张卡牌。抽取的所有 $x$ 张卡牌的子集等概率被抽中。如果抽牌堆中的卡牌数少于 $x$，Jellyfish 会抽取所有卡牌。

在这个过程结束时，求 Jellyfish 能将抽牌堆清空的概率，结果对 $1\,000\,000\,007$ 取模。

形式化地，设 $M=1\,000\,000\,007$。可以证明答案可以表示为最简分数 $\frac{p}{q}$，其中 $p$ 和 $q$ 是整数且 $q \not\equiv 0 \pmod{M}$。输出等于 $p \cdot q^{-1} \bmod M$ 的整数。换句话说，输出一个整数 $x$，满足 $0 \le x < M$ 且 $x \cdot q \equiv p \pmod{M}$。

## 说明/提示

在第一个测试用例中，Jellyfish 会不断打出力量为 $1$ 的卡牌，直到她抽到一张力量为 $0$ 或 $2$ 的卡牌。如果她抽到力量为 $0$ 的卡牌，最终她会将手牌打空。如果她抽到力量为 $2$ 的卡牌，最终她会将抽牌堆清空。由于抽到 $0$ 或 $2$ 的概率相等，答案为 $\frac{1}{2}$，而 $2 \cdot 500\,000\,004 \equiv 1 \pmod {10^9+7}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
5
0 1 1 1 2
00100
3
2 3 3
000
10
0 0 0 0 0 0 0 1 1 1
1111011111
20
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 3 3 4
00000000001000101010```

### 输出

```
500000004
0
0
675898154```

# 题解

## 作者：dlhham (赞：16)

前后花了好多个小时，终于搞懂了这个题，写篇题解纪念一下。

我们来假设 $a_1=0,a_n\geq 2$。否则答案可以口算。$1\leq |S|\leq n-1$，否则答案也可以口算。

看起来计算他输光的概率要好算一些：

考虑到，那个人（以后叫笨蛋）不能抽完牌库，当且仅当他用完了手上的非 $0$ 牌。我们可以轻松设计出一个暴力状压 DP，但这显然是毫无意义的。我们需要去设计一个更强的状态，来把该合并的状态合并起来。



首先考虑这样一件事，假设笨蛋现在手上只有一张牌 $a_i$，抽完这张牌以后，他最大的牌是 $a_j$，那么：笨蛋手上有 $1,\dots,j-1$ 之间每一张牌的概率是相等的，那么看起来这个状态可以合并在一起算。

我们以笨蛋手上最大的牌 $\max(S)$ 作为参考来考虑这个过程：

假设笨蛋输光了所有的牌，那么 $\max(S)$ 一定会在这个过程中，逐渐减少到 $0$ 的（虽然中间可能会有反弹）。

我们假设当前 $\max(S)=i$，也就是手上最大的牌是 $a_i$。以及 $|S-\{i\}|=x$，也就是除去 $i$ 的牌以外，他还有 $x$ 张牌。

我们定义 $F_{i,x,y}$ 表示当前笨蛋的 $\max(S)=i$，除去 $i$ 以外还有 $x$ 张，它有多大的概率进入一个 $\max(S)<i$ 的状态，并且进入的时候，$|S|=y$。

此处多做一点解释：这个 DP 的状态的含义是，我们只观察从 $(i,x+1)$ 到 $(<i,y)$ 的随机过程，一旦进入到 $(<i,y)$ 的状态，我们这个随机过程也就停止了。



那么，怎么求 $F_{i,x,y}$ 呢？我们继续来烤熟这个随机过程是什么样子的。

对于确定的 $(i,x)$，笨蛋一定会从牌库中抽 $a_i$ 张牌出来，假设这 $a_i$ 张牌都是小于 $i$ 的，则这个随机过程就结束了；否则，会进入一个新的状态 $(j,x+a_i-1)$。

为了解决这个问题，我们定义一个辅助的数组 $G_{j,y}$，表示在上述 $(i,x)$ 情况下，笨蛋走到 $\max(S)\leq j$，且 $|S|=y$ 的概率是多少。显然，我们关心的 $j$ 只有 $n,n-1,\dots,i-1$ 这些取值。

与此同时，我们需要明确一个事实：我们只知道此刻手上最大的牌 $\leq j$，以及手上一共有 $y$ 张牌，但并不知道手上具体有哪些牌。因此，对于 $1,\dots,j$ 中，所有不在初始 $ x$ 张牌中的每一张牌，我们都有 $p=\frac{y-x}{j-x}$ 的概率拿在手上。

这个概率 $p$ 之所以是 $\frac{y-x}{j-x}$，是因为剩余 $j-x$ 张牌中的每一张牌，我都是等概率抽到手上的，其概率乘以数量应该恰好等于牌的增量 $y-x$，所以有 $p\times (j-x)=y-x$。



那么，对于 $G_{j,y}$：

如果笨蛋没有 $j$：那么 $(1-p)G_{j,y}$ 应该贡献给 $G_{j-1,y}$。

如果笨蛋有 $j$：我们枚举在 $|S|=z$ 的时候 $\max(S)\leq j-1$ 的。那么这个概率就是 $F_{j,y-1,z}$，也就是把 $pG_{j,y}F_{j,y-1,z}$ 贡献给 $G_{j-1,z}$。



总结一下就是：

枚举 $j$ 从 $n$ 到 $i$：

1. 执行：$G_{j-1,y}←(1-p)G_{j,y}$

2. 枚举 $z$ 执行：$G_{j-1,z}←pG_{j,y}F_{j,y-1,z}$，此处 $p=\frac{y-x}{j-x}$。

最终 $F_{i,x,y}$ 就是 $G_{i-1,y}$。



这个转移牵扯一个小问题是：假设 $j=i$ 并且 $x=y-1$，我们会把 $F_{i,x,z}$ 贡献给 $G_{i-1,z}$，相当于是 $F_{i,x,z}$ 自己被自己给贡献了，我们需要在此处记录一下 $F_{i,x,z}=AF_{i,x,z}+B$，然后移项求出 $F_{i,x,z}$。



到此为止，我们通过 $O(n^5)$ 的速度求出了一个数组 $F_{i,x,y}$，表示我当前最大的牌是 $i$，除去 $i$ 以外还有 $x$ 张牌，我有多大的概率走到一个最大的牌 $<i$，且恰好有 $y$ 张牌的状态。



看懂了上述部分，求答案就显得简单多了：

定义：$ans_{i,x}$ 表示笨蛋此时此刻手上有所有读入的 $\leq i$ 的 $s_i$ 张卡片，以及从剩余 $i-s_i$ 张卡中随机抽了一些卡，直到凑够 $x$ 张卡，从这个状态开始，输光卡牌的平均概率。

那么：

1. $c_i=1$。$ans_{i,x}=\sum F_{i,x-1,y}ans_{i-1,y}$。

2. $c_i=0$。$ans_{i,x}=(1-p)ans_{i-1,x}+p\sum F_{i,x-1,y}ans_{i-1,y}$。

最后，$1-ans_{n,s_n}$ 就是答案了。



总时间复杂度 $O(n^5)$，可以通过本题。



一个优化是：

考虑到，对于 $(i+1,x)$ 以及 $(i,x)$，如果 $a_i=a_{i+1}$，那么我计算 $(i+1,x)$ 时候算出来的 $G_{j,y}$ 数组，在 $j\geq i+1$ 时候是可以复用的，那么就只用求 $G_{[i-1,i],y}$ 两项了，会快好多，原题数据 $100ms$ 多一点就跑出来了。



```c++
ll pw(ll x,ll mi)
{
	ll ret=1; while (mi) {if (mi&1) ret=ret*x%mod; x=x*x%mod; mi=mi>>1;} 
	return ret;
}
inline void add(ll &x,ll y) {x=(x+y)%mod;}
ll n,a[125];
string s;
//f(i,x,y) 从a[i]出发，手上还有x张<a[i]的牌，到达<i，且一共y张牌的概率 
ll f[125][125][125]; 
ll g[125][125][125];
ll ni[125]; //1/i
inline void getf(int i,int x)
{
	if (a[i]==0) {f[i][x][x]=1; return;}
	
	int sum=a[i];
	for (int j=1;j<=x;j++) sum+=a[j];
	//特判一下，假设我拿的小牌已经够了，就直接概率为0就完事。
	if (sum>=n) {for (int y=0;y<=n;y++) f[i][x][y]=0; return;}	
	if (x+a[i]>=n) return;
	
	int up=n;
	if (a[i]==a[i+1] && i<=n-1) 
	{
		//i-1，i重新求即可
		for (int j=i-1;j<=i;j++)
		for (int y=0;y<=n;y++)
			g[x][j][y]=0;
		up=i+1;
	}
	else
	{
		memset(g[x],0,sizeof(g[x]));
		g[x][n][x+a[i]]=1;		
	}
	
	ll xi[245]; memset(xi,0,sizeof(xi));
	int lim=x+a[i];
	for (int j=up;j>=i;j--) //第i层以后都一样，第i层是特例 
	for (int y=j;y>=lim;y--) //此时最多j张牌
	if (g[x][j][y])
	{
		ll p=(y-x)*ni[j-x]%mod;
		//case1：没有j
		add(g[x][j-1][y],(1-p+mod)*g[x][j][y]);	
		ll gai=p*g[x][j][y]%mod;
		//case2：有j,那么通过F[j][y-1][z]的概率转移
		if (j==i)
		{
			for (int z=a[j]+y-1;z<=j-1;z++)
			{
				if (j==i && y-1==x) add(xi[z],gai); 
				else add(g[x][j-1][z],gai*f[j][y-1][z]); 
			}	
		}
		else
		{
			for (int z=a[j]+y-1;z<=j-1;z++)
			{
				add(g[x][j-1][z],gai*f[j][y-1][z]); 
			}	
		}
	} 
	
	for (int y=x;y<=n;y++)
	{
		f[i][x][y]=pw(1-xi[y]+mod,mod-2)*g[x][i-1][y]%mod;
	}
	return;
}
void work()
{
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	cin>>s;
	memset(f,0,sizeof(f));
	for (int i=n;i>=1;i--) 
	{
		for (int x=i-1;x>=0;x--) getf(i,x);
	}
}
ll ans[125][125],S[125];
void work2()
{
	memset(ans,0,sizeof(ans));
	for (int x=0;x<=n;x++) ans[0][x]=1;
	for (int i=1;i<=n;i++) if (s[i-1]=='1') S[i]=S[i-1]+1; else S[i]=S[i-1];
	//ans[i][x] 我最大的是i，且拿着<=i的所有原来的卡，以及抽出来一共x张 
	for (int i=1;i<=n;i++)
	for (int x=S[i];x<=i;x++)
	{
		ll p=(x-S[i])*pw(i-S[i],mod-2)%mod;
		if (s[i-1]=='1')
		{
			for (int y=0;y<=i;y++)
				add(ans[i][x],f[i][x-1][y]*ans[i-1][y]);
		}
		else
		{
			add(ans[i][x],(1-p+mod)*ans[i-1][x]);
			for (int y=0;y<=i;y++)
				add(ans[i][x],p*f[i][x-1][y]%mod*ans[i-1][y]);
		}
	}
	ll ret=0;
	add(ret,1-ans[n][S[n]]+mod);
	if (S[n]==n) {cout<<1<<endl; return;}
	if (S[n]==0) {cout<<0<<endl; return;}
	if (a[1]>=2) {cout<<1<<endl; return;}
	if (a[n]==1)
	{
		if (S[n]==n) cout<<1<<endl; else cout<<0<<endl;
		return;
	} 
	cout<<ret<<endl;
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	for (int i=1;i<=120;i++) ni[i]=pw(i,mod-2);
	int T;
	cin>>T; 
	while (T--) 
	{
		work();
		work2();
	}
}
```

---

## 作者：一只绝帆 (赞：8)

# CF1975I Mind Bloom 题解

唐氏官方题解，写错了 $\infty$ 处地方，导致我、@waauto、@Mikefeng 看了三天才（对着题解给的正确代码）看懂。

经过精心的卡常，目前（$2024.6.23$）我的代码 CF 全球最快，大约是第二名的 $\frac 1 2$。

看懂题解的过程中前半段 @Mikefeng 在发力，后半段 @waauto 在发力，所以由我这个混饭吃的来讲解，给后人铺个路。

这篇题解鸽了很久，谢罪了。

***

### Part1：基本转化

首先题目让我们求赢的概率，由于赢时的状态手上可能有很多张牌，且最后打出的一张牌可能并没有抽完，所以我们**转而统计输的概率**。

有一些最基本的观察，譬如说如果全局只有 $0/1$ 那么开局没有所有牌就必输，还有最初手上的 $0$ 牌可以直接忽略掉（下文就当其不存在）。

由于有一些相等的牌，我们不妨为它们也钦定一个顺序，这方便了我们统计的过程，于是现在**任意两张牌之间都有大小关系，没有相等关系**。

考虑刻画输的过程，手上最大的手牌最终必定是 $0$，那我们就**考虑手上最大的手牌一步步变小的过程**，将手牌变大这个事件揉进转移中考虑，而中间抽出的小的手牌我们记不下来，但是我们可以记住抽出了多少张**并在以后钦定它们都是什么**。

### Part2：设状态

我们设状态 $f_{i,u,p,x}$ 表示如果我们在过程的开始打出了一张 $u$（且完成了抽出 $u$ 张牌，其中抽出了一张 $i$），此时牌堆里还有 $p$ 张牌，此时反复进行游戏过程，直到手上的牌全部小于 $i$（在这个过程中我们把 $u$ 张牌里面 $\ge i$ 的部分都钦定了），该过程结束后我们**净赚**了 $x$ 张新的牌（可以由我们自行钦定抽出了什么的牌）的概率。

注意这个 $x$ 中**净赚**的含义，这表示我们将 $u$ 张**可以钦定为任意点数的牌**经过这个过程后变为 $(u+x)$ **张可以钦定为任何** $<i$ **的点数的牌**。

![](https://s3.bmp.ovh/imgs/2024/07/15/42333d0476fab12c.png)

在这张图上 $f$ 的含义类似于一个起点 $u$ 向右找到第一个 $i$，在这期间一直在 $i$ 这条线的上面蹦跶（且至少有一次落到这条线上），并最终落到 $i$ 这条线的下面。

顺便我们定义 $g_{i,u,p,x}$ 是 $f_{i,u,p,x}$ 在 $i$ 这一维上的后缀和，实际意义相当于不在乎具体抽出的牌是多少，我们接下来要钦定的牌就是 $<i$，于是把所有具体的最小值 $i$ 汇总成一个后缀和以方便转移，所以这个状态出现时可以认为我们**打光了** $u$ **抽出的** $\ge i$ **的牌然后抽出了** $x$ **张可钦定的牌**，相比 $f$ 的定义，没有了最小值的约束。

在图上解释 $g$ 的含义就是划定了一条线，除起点 $u$ 外一直在 $i$ 这条线上面蹦跶，并且没有了必须落到这条线上的限制，并最终落到这条线的下面。

> 值得解释的是，这并不意味着我们抽出的 $u$ 张牌抽中最小牌就是 $i$，而只是在这个过程中暂时没有打出，也没有钦定 $i$ 以下的牌。

### Part3：f 与 g 的转移

我们敏锐地观察到，$u=0$（即最开始）和 $c_i\le1$（$0$ 不能丢，$1$ 丢了之后有可能转移到自己）的状态都比较特殊，所以我们先考虑 $c_i>1\wedge u>0$ 的转移。

$$f_{i,u,p,x}\gets \sum_yg_{i+1,u,p,y}\frac{(u+y)}{(p-y+1)^{\underline{c_i}}}g_{i,c_i,p-(c_i-1)-y,x-(c_i-1)-y}$$

解释一下：

- 首先前一段，我们需要钦定哪张排抽出了 $i$，于是我们先反复抽光 $\ge i+1$ 的牌，并枚举这一过程中获得了 $y$ 张可钦定的牌（$g_{i+1,u,p,y}$）。
- 在经历完上段后，现在我们有 $(u+y)$ 张可以钦定为 $<i+1$ 的牌，我们从里面钦定一张为 $i$ 并打出去（$(u+y)$）。
- 打出 $i$ 后要抽 $c_i$ 张卡，当前牌堆里共有 $p-y+1$ 张（考虑上净赚的还有刚打的 $i$）（$\frac{1}{(p-y+1)^{\underline{c_i}}}$）。
- 后半段是我们打出了一张 $i$，然后现在要把 $\ge i$ 的全部打掉，并完成净赚 $x$ 张的目标，也就是再赚 $x-(c_i-1)-y$ 张。

然后我们来处理 $u=0$ 的情况，这种情况有一点点不同，因为并不是所有手牌都可以用来钦定，有些手牌是一开始就在你手上的。

所以我们需要分讨当前牌是否是最初的手牌，我们设有 $h$ 张最初的手牌比 $i$ 大（转移会用到）。

当前牌不是手牌的情况：

$$f_{i,0,p,x}\gets \sum_yg_{i+1,0,p,y}\frac{y}{(p-y+1+h)^{\underline{c_i}}}g_{i,c_i,p-(c_i-1)-y+h,x-(c_i-1)-y}$$

在简单粗暴地把 $u$ 替换为 $0$ 后，还有几处明显的变化，这些变化都是因为：在打出 $\ge i+1$ 的牌的过程中，除了我们净赚的 $y$ 张牌，那 $h$ 张牌也被打回牌堆里了，相当于开局系统送了你一些牌，这些牌不参与 $x$ 张净赚牌的构成，但确实是被打回到牌堆里了。

所以在涉及到牌堆的时候会多 $h$ 张。

当前牌是最初手牌的情况：

$$f_{i,0,p,x}\gets \sum_yg_{i+1,0,p,y}\frac{1}{(p-y+1+h)^{\underline{c_i}}}g_{i,c_i,p-(c_i-1)-y+h,x-c_i-y}$$

再对比一下上面的式子，变化的地方在于当前牌既然是最初的手牌，那不应该从已有的可钦定物中钦定一个，所以钦定的系数变成了 $1$，同时我们不消耗钦定的 $y$ 张牌，所以后面只需要再净赚 $x-c_i-y$ 张牌就够了，不必多赚一张。

在进行完这些转移后，我们拥有了一个强大的抽卡工具，所以接下来处理 $c_i\le 1$ 的部分也需要用到上面的工具（只需要用到最后进行的最小的 $i$ 的部分，不妨我们设 $t$ 是这个最小的 $i$ 使得 $c_i\ge 2$）。

### Part4：$c_i\le 1$

此时的问题就是我们打出一张 $1$ 有可能抽回来一张 $1$，这种转移到自己的转移显然应当被我们在分母中忽略掉。

设 $h_{i,j}$ 表示手上仅有 $i$ 张 $0$ 和 $j$ 张 $1$ 的概率，以下设 $m_0=\sum_i[c_i=0],m_1=\sum_i[c_i=1],m_2=\sum_i[c_i\ge 2]$。

现在我们要打一张 $1$，很显然排除掉抽回来 $1$，我们要么抽 $0$ 要么抽 $\ge 2$ 的数，据此我们能写出 $h$ 的转移：

$$\begin{aligned}h_{i+1,j-1}&\gets h_{i,j}\frac{1}{m_2+m_0-i}\\h_{i+k_0,j+k_1-1}&\gets h_{i,j}\frac{1}{m_2+m_0-i}g_{t,1,n-i-j,k_0+k_1-1}\binom{k_0+k_1}{k_1}(m_1-j+1)^{\underline{k_1}}\end{aligned}$$

解释一下：

- 第一个式子是这一张抽出了 $0$，由于 $0$ 之间也是不同的，我们这里就钦定抽出了其中的一张，这也是系数不用 $\frac{m_0-i}{m_2+m_0-i}$ 的原因。
- 第二个式子是这一张抽出了一个 $c_i\ge 2$，由于 $g$ 里面已经隐含了对到底是哪个 $i$ 的选择，所以我们的系数同样不能使用 $\frac{m_2}{m_2+m_0-i}$。
- 我们枚举最终抽回了 $k_0$ 张 $0$ 和 $k_1$ 张 $1$，所以我们要把 $1$ 张可以钦定为任何点数的牌转化为 $k_0+k_1$ 张 $\le 1$ 的牌，所以用 $g_{t,1,n-i-j,k_o+k_1-1}$。
- 然后是选出 $k_1$ 张 $1$，并钦定它们都是哪几张 $1$，注意这里的钦定哪张 $1$ 与前面的钦定是哪张卡不太一样。

接下来统计答案，$ans\gets h_{i,0}(m_0)^{\underline{i}}$，钦定所有的 $0$ 都是哪些，这里的答案就是输的概率，输出 $1-ans$ 即可。

分析一下复杂度是 $n^5$ 的，不过常数极小，且循环之间的顺序并不重要，下面给几个比较大的优化：

- 可行状态并不多，请在瓶颈的 $f,g$ 转移中先枚举 $y$ 再枚举 $x$，把没有用的 $y$ 剪掉，cf 官解提到的 $n^4\sqrt n$ 想必就是利用了很少的可行状态,，在实际的速度上这份最优解就是 $n^5$ 卡常而来，会分析复杂度的大佬可以帮忙分析一下。
- 使用滚动数组，对 $i$ 这一维进行滚动，前缀和可以直接保留原来的值进行转移，但转移时要同时利用上一次的值和这次的值，所以还是要把 $f,g$ 都开出来，不能只用 $g$。
- 组合数，排列数，排列数倒数请使用预处理。

[code（未卡常）](https://codeforces.com/contest/1975/submission/266856763)，[code（卡常）](https://codeforces.com/contest/1975/submission/266947570)。

完结撒花，写题解过程中突然就发现某个点之前的理解还是片面许多，然后想一会儿才恍然大悟，有锅再滚回来修吧。

---

## 作者：nullqtr_pwp (赞：4)

### Preface
神仙题。模拟赛 $46$ 个人在这个题一共得了 $30$ 分。太难想了，代码倒挺好写。

### 平凡情况
先有几种平凡的情况使得答案为 $0$ 或 $1$。优先级依次递减。

- 初始时 $|S|=n$，答案为 $1$。
- 初始时 $|S|=0$，答案为 $0$。
- 初始时 $a_n\leq 1$，每次都不会让手里的牌变多，会逐渐输干净，答案为 $0$。
- 初始时 $a_1\ge 0$，手里的牌数不减，并且此时 $a_n>1$，可以变多，答案为 $1$。
### 基础分析

由于 $c_i$ 单调不降，并且相同能力值之间事实上互不区分，但是方便起见，每一轮我们可以直接认为打出去的是标号最大的那张。因此我们讨论某张手牌的**标号**而不是能力值。

令 $S$ 表示水母手中牌的集合，把平凡的情况去除后一定有 $a_1\ge 0,a_n>1$ 且初始时 $|S|\in[1,n-1]$。

下文定义 $\text{operate}(S)=\text{operate}\lbrace{i\in S}\mid i\rbrace$。

**正难则反**，我们不好刻画赢牌，但是可以注意到输光的过程一定是在最后打空了所有能力值非零的卡牌，手中要么为空要么全是能力值为 $0$，此时是必败的。我们可以计算水母输牌的概率 $ans'$，最终答案 $ans$ 就是 $1-ans'$。

这一定是一个 DP 题，但是我们需要合适地**划分子过程**，对应 DP 的分阶段递推。在本题中，可以用实时的 $\max(S)$ 来考虑。最终就是 $\max(S)=0$ 就输了，但是将 $\max(S)$ 画成一条折线时，整体趋势就是往下掉，最后掉成 $0$，没有必要是单调减的，但是考虑一个时刻的 $\max(S)$ 达成了**历史最小**时（前缀 $\min$），就可以看成一个新的阶段了。

因此可以将整个掉的过程划分成若干子过程。从这个 $\max(S)=k$ 的时刻逐渐操作，到后面**首次**时刻使得 $\max(S)<k$，最终 $\max(S)=0$。

### DP 设计

在往下掉的过程中，$\max(S)$ 可能会往上走，但是原来的 $S_i$ 且 $S_i\ne \max(S)$ 是几乎没用的，所以可以只考虑这个过程开始时的 $|S|$。

考虑 DP 记录什么。假设水母当前在 $\max(S)=i,|S\setminus\lbrace i\rbrace|=x$ 的状态，令下一个子过程开始时的 $|S|=y$，那么可以设计 DP 为 $f_{i,x,y}$：下一个 $\max(S)<i$ 的首个状态时，$|S|=y$ 的概率。

我们希望对于固定的二元组 $(i,x)$ 求出所有的 $f_{i,x,y}$。打出卡牌 $i$ 之后会剩下 $n-x$ 张卡牌，她们有相等可能被水母的 $a_i$ 张之一抽中。因此这些卡牌在当前抽卡轮的持有的概率都是 $\dfrac{a_i}{n-x}$。

之前说了，$\max(S)$ 可能会往上飘，但是我们希望在上飘时也考虑往下掉的过程。考虑令时间线的起点为打出 $i$，后续有 $n-i+2$ 个关键时刻：$\max(S)$ 第一次 $\leq n$，$\max(S)$ 第一次 $\leq n-1$，$\cdots$，$\max(S)$ 第一次 $\leq i+1$，$\max(S)$ 第一次 $\leq i$，$\max(S)$ 第一次 $\leq i-1$。

令 $g_{j,y}$ 表示到达首次 $\max(S)\leq j$ 的状态时，$|S|=y$ 的概率。打出 $i$ 那一轮即初始时一定满足 $g_{n,x+a_i}=1$，其余的 $g_{n,*}$ 均为 $0$。

此时考虑 $g_{j,y}$。所有 $\leq j$ 且不是初始 $x$ 个的卡牌都是对称的，因此拥有卡牌 $j$ 的概率为 $p=\dfrac{y-x}{j-x}$，这时考虑往下一层 $g_{j-1,*}$ 的转移。

- 若水母没有卡牌 $j$，就有 $(1-p)g_{j,y}\to g_{j-1,y}$，原因是此时 $\leq j$ 等价于 $\leq j-1$。
- 若水母有卡牌 $j$，枚举下一个 $\max(S)\leq j-1$ 时 $|S|=q$，这种情况的发生概率为 $f_{j,y-1,q}$。因此有转移 $pg_{j,y}f_{j,y-1,q}\to g_{j-1,q}$。

显然有 $f_{i,x,y}=g_{i-1,y}$。

>额外解释：而时间线开始前的 $S\setminus\lbrace i\rbrace$ 的那 $x$ 个都是现在集合里的常驻角色，考虑 $\leq j$ 且不是初始的 $x$ 个都是**对称**的。
>
>这是首次 $\max(S)\leq j$，那么之前打出的卡牌一定都是 $>j$ 的，那么从这些打出的牌来看，$\leq j$ 的牌都是等价，对称的。

整体上倒序遍历 $i$，倒序遍历 $x$ 求解所有 $f_{i,x,*}$ 可以保证不会访问未计算的值。

但是如果在求解 $g$ 时假设 $j=i,x=y-1$，$f_{i,x,q}$ 会贡献给 $g_{i-1,q}$，然后再返还给 $f_{i,x,q}$ 自身。这样的转移有自环。解决方案就是考虑转移可以规约成 $f_{i,x,y}=A+Bf_{i,x,y}$，其中 $B_{i,x,y}$ 就是自己贡献给自己的系数。那么有 $f_{i,x,y}=\dfrac{A}{1-B}$。事实上不会有 $B=1$ 的情况。

这样我们就 $O(n^5)$ 地求出了所有的 $f_{i,x,y}$。
### 统计答案

重新定义 $s_i=\sum_{j=1}^i[j\in S']$，$S'$ 为最开始的卡牌集合。

定义 $h_{i,x}$ 为：若水母从，最初位于 $[1,i]$ 的 $s_i$ 张卡牌，以及，$[1,i]$ 剩余的 $i-s_i$ 张她最开始没有的，等概率随机抽取 $x-s_i$ 张卡牌，这一共 $x$ 张牌：此时进行游戏，最终打空非零卡牌即输掉的概率的期望。

从小到大枚举 $i$，初始若 $a_i=0$ 有 $h_{i,j}=1$。

- 若 $i\in S'$，$h_{i,x}=\sum_y f_{i,x-1,y}h_{i-1,y}$。
- 若 $i\not\in S'$，则有 $p=\dfrac{x-s_i}{i-s_i}$ 的概率在 $S$ 中。当 $i=s_i$ 时显然不会执行这一步。若在 $S$ 中，对上一句的转移整体乘 $p$；若不在 $S$ 中，$h_{i,x}$ 加上 $(1-p)h_{i-1,x}$。

这一部分容易 $O(n^3)$ 完成。

最终答案为 $1-h_{n,s_n}$，就是赢得游戏的概率。

总时间复杂度 $O(n^5)$，常数较小可以通过。

### 代码

[CF 提交记录。](https://codeforces.com/contest/1975/submission/277315956)

---

## 作者：lalaouye (赞：2)

dp 好题。

首先，读完题后，就感觉很不可做，我们可以考虑正难则反，算输光的概率，这样可以想出一个暴力状压 dp 的做法，但是考场上连状压再高消的分都没给。

我们考虑设计一个巧妙的状态去描述这个局面，注意，设计状态的范围是很广的。我们发现我们输光的过程的 $\max(S)$ 长成一个折线图，最后归为 $0$。并且，每张牌被选中的概率是一定的，我们可以针对这些性质，压缩冗余的状态。

直觉告诉我们，$\max(S)$ 显然是最重要的，我们考虑在状态里只加入 $\max(S)$，再观察形似折线图的过程，我们发现对于一个状态，如果我们在下一次随机选牌的时候 $\max(S)$ 变小了，那么再进入下一个状态，而如果 $\max(S)$ 变大了，我们仍然不需要 $<\max(S)$ 的牌。

所以，这时脑子里我们可以出现一个大致的 dp 状态，为了使得不同状态在概率上是本质相同的，我们不仅要记录 $\max(S)$，还要记录一下我们当前拥有的牌数，并且为了转移，还要记录下一个状态的牌数，即记 $f_{i,x,y}$ 表示当前 $\max(S)$ 在第 $i$ 位，且当前**除了最大值**以外我们手里还有 $x$ 张牌，第一次到 $\max(S)$ 小于当前最大的概率（换句话说，就是在折线图中第一个在该点右边的，且低于当前点的）， 然而该过程是波折的，我们还要记一个辅助 dp 数组，$g_{j,y}$ 表示从 $(i,x)$ 这个状态随机到 $\max(S)\le j$ 且 $|S|=y$ 的概率，显然 $g_{n,x+c_i}=1$，且 $f_{i,x,y}=g_{i-1,y}$。接下来就是转移的事情了，我们试着推出转移方程式。

这个状态中，每个数被选择的概率均是 $p=\frac{y-x}{j-x}$，因为首先显然对于初始的 $x$ 张牌我们永远不会打出，所以这些不在选择里，所以概率是这个。

考虑 $g_{j,y}$ 的贡献。如果这个状态下手里没有第 $j$ 张牌，$g_{j-1,y} \longleftarrow g_{j,y}\times p$。

然后，如果有的话，对于 $g_{j-1,z}$，有 $g_{j-1,z} \longleftarrow (1-p)\times g_{j,y}\times f_{j,y-1,z}$。

惊奇的发现，哇，他们是可以互相转移的！且转移大体是个 DAG，不需要高消，但为什么是大体呢，因为我们发现，当 $i=j,x=y-1$ 时，$f_{i,x,y}$ 贡献了自己，我们把他记录成 $f_{i,x,y}=k\times f_{i,x,y}+b$，最后再移项就好了。

那么接下来，答案该怎么求呢？我们设一个类似于 $g$ 的状态，记 $h_{i,x}$ 表示对于原序列中前 $i$ 个，选择了一些必选（初始手里就有的），和一些之后选择的，总数为 $x$ 张牌最后输光的概率，他很好转移：

当 $s_i=1$ 时，我们只能选，那么转移为 $h_{i,x}=\sum f_{i,x-1,y}\times h_{i-1,y}$。

当 $s_i=0$ 时，我们有 $p=\frac{x-sum_n}{i-sum_n}$ 选择它，那么转移为 $h_{i,x}=(1-p)h_{i-1,x}+p\sum f_{i,x-1,y}\times h_{i-1,y}$。

最后 $ans=1-h_{n,sum_n}$，然后我们就做完了！时间复杂度为 $\mathcal{O}(n^5)$，稍微加点优化就能通过。

[提交记录](https://codeforces.com/contest/1975/submission/277905034)

---

## 作者：Otomachi_Una_ (赞：2)

**【题目简述】**

小 U 有一副 $n$ 张卡片的牌，第 $i$ 张上面写着 $a_i$。你一开始手上有一些牌，每次把编号最大的牌 $a_x$ 扔进牌堆，然后从当前剩余牌堆中随机抽取 $a_x$ 张牌。

问你能把所有牌都拿到手的概率。

$n\leq 120,0\leq a_1\leq a_2\leq\dots\leq a_n\leq n$。

**【解题思路】**

我们先判掉一下几种平凡的情况：

- 你手上一张牌都没有，或者都有。
- $a_n\leq 1$ 或者 $a_1\geq 1$。

记当前小 U 手上牌的编号为 $S$。

我们观察剩下的情况，我们反面考虑，那么小 U 失去手上所有牌，必然会到达 $a_{\max(S)}=0$ 的状态。 那么这肯定是伴随这 $\max(S)$ 不断下降的一个过程。

我们把小 U 逐渐输掉手上所有牌的过程按照 $\max(S)$ **达到历史最小**作为一次划分，我们把划分出来的东西称为一个**阶段**。这样划分的好处是：考虑一个阶段开始的地方，假设 $M=\max(S)$，对所有 $i<M$ 的 $i$，都有：

- 如果 $i$ 一开始就在手上，那么还是会在手上；
- 否则，其他所有这样 $i$ 是对称的。

我们考虑 dp，$F_{i,j,k}$ 表示我们当前 $\max(S)=i,|S-\{i\}|=j$，我们第一次 $\max(S)<i$ 的时候，此时 $|S|=k$ 的概率。我们发现到达一个阶段之前 $S-\{i\}$ 是不会产生任何影响的，所以我们的 dp 状态只需要记录 $\max(S),|S|$。

我们算出来这个有什么用呢？如果我们能计算出来 $F$，我们可以定义 $ans_{i,j}$ 表示当前 $\max (S)\leq i$，$|S|=j$，一开始就在手中的牌在 $S$ 中，其他牌等概率出现在 $S$ 中的概率。我们考虑通过 $F$ 去转移 $ans$：

- 如果 $i$ 一开始就在手中，$ans_{i,j}=\sum_{k=0}^{i-1} F_{i,j-1,k}·ans_{i-1,k}$。
- 否则，$i$ 会有 $p=\dfrac{j-s_i}{i-s_i}$ 的概率在手中，分两种情况：
- - 如果在手中，那么和上面转移是一致的。
  - 否则，就是 $(1-p)·ans_{i-1,j}$。

也就是，我们能通过 $F$ 来计算 $ans$，最终的答案就是 $1-ans_{n,s_n}$。

考虑怎么转移 $F$：我们发现打出去 $i$ 这张牌之后比较难计算。我们可以定义 $G_{x,y}$（$x\in [i-1,n]$） 表示考虑打出 $a_i$ 之后，第一次 $\max(S)\leq x$ 此时 $|S|=y$ 的概率。考虑 $G$ 的转移：

- 如果 $x\in S$，那么这会归类到 $F_{x,y-1,*}$；
- 否则，会归类到 $G_{x-1,y}$。

由于每个数是对称的，所以上面两种情况的概率是能计算的。

最后会有个小问题，就是计算 $G_{i-1,*}$ 的时候会用到 $F_{i,j,*}$，那这样子我们可以列出类似 $F_{i,j,z}=G_{i-1,z}=AF_{i,j,z}+B$ 的形式，于是 $F_{i,j,*}$ 就能计算了。

时间复杂度：$\mathcal O(n^5)$，能跑过去。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=125;
const int MOD=1e9+7;
int n,a[MAXN],s[MAXN];char c[MAXN];
int f[MAXN][MAXN][MAXN],g[MAXN][MAXN],ans[MAXN][MAXN],h[MAXN],inv[MAXN];
// f[i][j][k] 当前 max(S)=i，|S|=j+1，下一个阶段到达 |S|=k 的概率
// g[i][j] 辅助转移，从 f(x,y,*) 出发，到达第一个阶段，max(S)<=i，|S|=j 的概率
// ans[i][j] 当前 max(S)=i，|S|=j，S 元素为 <=i 的已选元素+随机抽取其余元素
// ans[i][j] 表示最终 S 走向失败的概率
int ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
void add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}
void solve_DP(int x,int y){
	// 从 max(S)=x, |S|=y+1 开始
	// g[i][j]: 第一次到达 max(S)<=i, |S|=j 的概率
	if(!a[x]) return f[x][y][y]=1,void();
	if(a[x]+y>=n) return;
	memset(g,0,sizeof(g));memset(h,0,sizeof(h));
	g[n][y+a[x]]=1;
	for(int i=n;i>=x;i--) for(int j=i;j>=a[x]+y;j--) if(g[i][j]){
		int p=1ll*(j-y)*inv[i-y]%MOD;
		// 情况 1: j 不属于 S
		add(g[i-1][j],1ll*g[i][j]*(MOD+1-p)%MOD);
		// 情况 2: j 属于 S
		for(int z=a[i]+j-1;z<i;z++){
			if(i!=x||j!=y+1) add(g[i-1][z],1ll*p*g[i][j]%MOD*f[i][j-1][z]%MOD);
			else add(h[z],1ll*p*g[i][j]%MOD);
		}
	}
	for(int i=y;i<=x-1;i++) f[x][y][i]=1ll*g[x-1][i]*ksm(1+MOD-h[i],MOD-2)%MOD;
}
void solve(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>c[i],s[i]=s[i-1]+(c[i]=='1');
	if(s[n]==n) return cout<<1<<'\n',void();
	if(s[n]==0) return cout<<0<<'\n',void();
	if(a[n]<=1) return cout<<0<<'\n',void();
	if(a[1]>=1) return cout<<1<<'\n',void();
	memset(f,0,sizeof(f));
	for(int i=n;i>=1;i--) for(int j=i-1;j>=0;j--) solve_DP(i,j);
	memset(ans,0,sizeof(ans));
	ans[0][0]=1;
	for(int i=1;i<=n;i++) for(int j=s[i];j<=i;j++){
		if(c[i]=='1'){
			for(int k=0;k<i;k++){
				add(ans[i][j],1ll*ans[i-1][k]*f[i][j-1][k]%MOD);
			}
		}else{
			int p=1ll*(j-s[i])*inv[i-s[i]]%MOD;
			add(ans[i][j],1ll*(1+MOD-p)*ans[i-1][j]%MOD);
			for(int k=0;k<i;k++){
				add(ans[i][j],1ll*p*ans[i-1][k]%MOD*f[i][j-1][k]%MOD);
			}
		}
	}
	cout<<(MOD+1-ans[n][s[n]])%MOD<<'\n';
}
int main(){
	ios::sync_with_stdio(false);
	for(int i=1;i<MAXN;i++) inv[i]=ksm(i,MOD-2);
	// freopen("Otomachi_Una.in","r",stdin);
	// freopen("Otomachi_Una.out","w",stdout);
	int _;cin>>_;
	while(_--) solve();
	cerr<<"Running time: "<<1.*clock()/CLOCKS_PER_SEC<<'\n';
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/CF1975I)

**题目大意**

> 给定 $n$ 张牌，第 $i$ 张有数字 $a_i$，初始手牌为 $S$，每次可以打出手中数字最大的牌 $x$，从剩余的牌中等概率抽 $a_x$ 张加入手牌，求抽出所有牌的概率。
>
> 数据范围：$n\le 120$。

**思路分析**

将 $a_i$ 从小到大排序，反面考虑求失败的概率。

考虑划分状态，我们发现初始手牌一定按从大到小的顺序被打出，且如果 $\max(S)>i$ 一定不可能打出 $i$。

因此我们可以按 $\max(S)$ 减小来划分状态，在 $\max (S)$ 减小之前，$[1,\max(S))$ 中的牌不会被打出。

设计状态 $dp_{i,j}$ 表示仅考虑 $[1,i]$ 中的牌，当前 $|S|=j$。

假设 $S$ 中 $[1,i]$ 有 $c_i$ 张牌，那么剩余的 $i-c_i$ 张牌是对称的，每张牌在 $S$ 的概率都是 $\dfrac {j-c_i}{i-c_i}$。

转移时枚举 $i$ 是否在 $S$ 中，如果在，那么求出 $\max(S)$ 减小后还剩 $k$ 张牌的概率并从 $dp_{i-1}$ 转移。

那么我们要求的就是转移系数 $f_{i,j,k}$，表示当前 $\max(S)=i$，且有 $j$ 张 $<i$ 的牌，在 $\max(S)$ 减小后还剩 $k$ 张牌的概率。

计算的时候再做一遍求答案的 dp，$g_{u,v}$ 表示 $[1,u]$ 中的牌有 $v$ 张的概率。

转移 $g$ 的时候依然考虑 $u$ 是否 $\in S$，同理概率为 $\dfrac{v-j}{u-j}$，如果 $u\in S$，那么以系数 $f_{u,v-1,q}$ 向 $g_{u-1,q}$ 转移。

从大到小 dp，由 $g_n$ 转移到 $g_{i-1}$，在 $u=i,v=j+1$ 时会有自环，把 $g_{i-1,k}$ 写成关于 $f_{i,j,k}$ 的一次函数即可。

处理出 $f$ 后在原序列上从小到大转移 $dp$。

时间复杂度 $\mathcal O(n^5)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=125,MOD=1e9+7;
int ksm(int a,int b=MOD-2) { int s=1; for(;b;a=1ll*a*a%MOD,b>>=1) if(b&1) s=1ll*s*a%MOD; return s; }
int n,a[MAXN],c[MAXN],inv[MAXN],op[MAXN];
int f[MAXN][MAXN][MAXN],g[MAXN][MAXN],h[MAXN];
int dp[MAXN][MAXN];
void F(int u,int s) { //max=u, cnt[1,u-1] = s
	if(!a[u]) return f[u][s][s]=1,void();
	if(a[u]+s>=n) return ;
	memset(g,0,sizeof(g));
	memset(h,0,sizeof(h));
	g[n][a[u]+s]=1;
	for(int i=n;i>=u;--i) for(int j=i;j>=a[u]+s;--j) { //max<=i, cnt=j
		const int p=1ll*(j-s)*inv[i-s]%MOD,z=g[i][j],w=1ll*p*z%MOD;
		if(!z) continue;
		g[i-1][j]=(g[i-1][j]+1ll*(1+MOD-p)*z)%MOD;
		for(int k=j+a[i]-1;k<i;++k) {
			if(i==u&&j==s+1) h[k]=(h[k]+w)%MOD;
			else g[i-1][k]=(g[i-1][k]+1ll*w*f[i][j-1][k])%MOD;
		}
	}
	for(int i=s;i<u;++i) f[u][s][i]=1ll*g[u-1][i]*ksm(1+MOD-h[i])%MOD;
}
void solve() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n;++i) scanf("%1d",&op[i]),c[i]=c[i-1]+op[i];
	if(c[n]==n) return puts("1"),void();
	if(c[n]==0) return puts("0"),void();
	if(a[n]<=1) return puts("0"),void();
	if(a[1]>=1) return puts("1"),void();
	memset(f,0,sizeof(f));
	for(int i=n;i;--i) for(int j=i-1;~j;--j) F(i,j);
	memset(dp,0,sizeof(dp));
	dp[0][0]=1;
	for(int i=1;i<=n;++i) for(int j=c[i];j<=i;++j) { //max<=i, cnt=j
		for(int k=0;k<i;++k) {
			dp[i][j]=(dp[i][j]+1ll*f[i][j-1][k]*dp[i-1][k])%MOD;
		}
		if(!op[i]) {
			const int p=1ll*(j-c[i])*inv[i-c[i]]%MOD;
			dp[i][j]=(1ll*(1+MOD-p)*dp[i-1][j]+1ll*p*dp[i][j])%MOD;
		}
	}
	printf("%d\n",(1+MOD-dp[n][c[n]])%MOD);
}
signed main() {
	inv[1]=1;
	for(int i=2;i<MAXN;++i) inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---


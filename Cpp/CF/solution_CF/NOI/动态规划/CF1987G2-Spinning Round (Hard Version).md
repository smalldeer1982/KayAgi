# Spinning Round (Hard Version)

## 题目描述

这是该问题的困难版本。两种版本的区别仅在于 $s$ 中允许的字符。只有当你同时解决了两个版本的问题时，才能进行 Hack。

给定一个长度为 $n$ 的排列 $p$，以及一个长度为 $n$ 的字符串 $s$，其中每个字符都是 L、R 或 ?。

对于每个 $i$，$1 \le i \le n$：

- 定义 $l_i$ 为最大的 $j < i$，使得 $p_j > p_i$。如果不存在这样的 $j$，则 $l_i := i$。
- 定义 $r_i$ 为最小的 $j > i$，使得 $p_j > p_i$。如果不存在这样的 $j$，则 $r_i := i$。

初始时，你有一个 $n$ 个点（编号为 $1$ 到 $n$）且没有边的无向图。然后，对于每个 $i$，$1 \le i \le n$，向图中添加一条边：

- 如果 $s_i = \text{L}$，则添加边 $(i, l_i)$。
- 如果 $s_i = \text{R}$，则添加边 $(i, r_i)$。
- 如果 $s_i = ?$，你可以选择添加边 $(i, l_i)$ 或 $(i, r_i)$。

请你求出所有可能构造出的连通图中，直径的最大值。如果无法构造出任何连通图，输出 $-1$。

$^*$ 设 $d(s, t)$ 表示从 $s$ 到 $t$ 的任意路径上最少的边数。

图的直径定义为所有点对 $(s, t)$ 中 $d(s, t)$ 的最大值。

## 说明/提示

在第一个测试用例中，有两个连通图（节点编号为索引）：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1987G2/b9e604b93005a6fc948b7a3b538eda48ad94326a.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1987G2/1015454202f1913e51db8d5cb7f5b2c4acb62524.png)

左边的图的直径为 $2$，右边的图的直径为 $3$，所以答案为 $3$。

在第二个测试用例中，无法构造出任何连通图，所以答案为 $-1$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
8
5
2 1 4 3 5
R?RL?
2
1 2
LR
3
3 1 2
L?R
7
5 3 1 6 4 2 7
?R?R?R?
5
5 2 1 3 4
?????
6
6 2 3 4 5 1
?LLRLL
8
1 7 5 6 2 8 4 3
?R??????
12
6 10 7 1 8 5 12 2 11 3 4 9
????????????```

### 输出

```
3
-1
-1
4
4
3
5
8```

# 题解

## 作者：qiuzx (赞：18)

容易发现最终连出来的图一定是一棵树，然后最大值自己连一个自环。因此若有一个不是最大值的点自己连向自己，则无解。否则随便连哪个不是自己的边都一定有解，下面假定一定有解，并且对于哪些只能连出一条边的，我们相应地修改 $s_i$ 使得这些位置的连边已经被确定。

建出这个排列的笛卡尔树，则一个点向左连边可以看作在笛卡尔树一直向上跳直到第一次以右儿子的身份跳上去。这里无需考虑不存在这样的点的情况，因为这种情况下在我们刚刚的修改中已经将 $s_i$ 改为 `R`，所以这里不可能向左连边。向右连边也是类似的。这道题中我们希望求出最大直径，这等价于求所有可能连出来的树中所有路径长度的最大值，因此我们只需钦定一些点在路径上，然后求出所有这样路径长度的最大值即可。

取出一条路径的两个端点，则这条路径必然形如两个点向上跳直到在某个点处相遇，因此我们考虑 dfs 整个笛卡尔树，在这个相遇的点上统计答案。对于一棵子树而言，若实际的相遇点在它的上方，则对于所有可能从这棵子树走中出去的路径，只有下面三种可能性：

1. 向左跳出去，并在外面和某个其它子树出来的路径合并成为一条路径。
2. 向右跳出去，并在外面和某个其它子树出来的路径合并成为一条路径。
3. 有两条不交的路径，一条从左跳出去，一条从右跳出去，并在外面合并成为一条路径。

注意到对于所有能向左跳出去的点，它们跳出去所连向的点是一样的，向右也是同理。所以对于这三种情况，我们只需要关心在能向相应方向跳出去的前提下，子树内路径长度的最大值。因此可以记 $dp_{i,0/1/2}$ 表示以 $i$ 为根的子树中这三种路径分别的最大长度，这里为了方便路径长度包含了向上跳出去的那条边。

考虑如何转移一个 $dp_x$，记 $l,r$ 分别为 $x$ 的左右儿子。首先 $x$ 本身可以不被钦定进入我们的路径，此时 $dp_{x,0}$ 从 $dp_{l,0}$ 转移而来，$dp_{x,1}$ 从 $dp_{r,1}$ 转移而来，$dp_{x,2}$ 从 $dp_{l,0}+dp_{r,1}$ 转移而来。注意此时 $x$ 向外如何连边不会影响到子树中点向左/右能否连出去的合法性，所以可以直接转移。

否则枚举 $x$ 向哪个方向连边了，两个方向是类似的，所以下面以向左连边为例。因为此时考虑的是路径中包含 $x$ 的情况，所以 $dp_{x,1}$ 肯定是无法转移的。对于 $dp_{x,0}$ 来说，由于 $x$ 已经向左连边，所以在包含 $x$ 的路径中只有 $x$ 才能连向左侧，因此一定是左子树或右子树中的路径连到 $x$ 这个点，再从 $x$ 连出去，所以有转移 $dp_{x,0}\leftarrow\max(dp_{l,1}+1,dp_{r,0}+1)$。还有一种情况就是同时连出两条路径，此时向左的一条是包含 $x$ 的这条，那么向右的那条只能是从右子树向外伸出去的那条。这样同样分 $x$ 从哪个子树连过来讨论，可以得到转移 $dp_{x,2}\leftarrow dp_{l,1}+dp_{r,1}+1$ 和 $dp_{x,2}\leftarrow dp_{r,2}+1$。

现在我们得到了所有的 dp 值，但这些 dp 并不能直接得出答案，所以还需要考虑如何计算答案。我们考虑两条路径在 $x$ 处合并的情形。此时有两种情况，一种是两条路径从 $x$ 的两个子树中分别向上跳出来，在 $x$ 处相遇，此时可以用 $dp_{l,1}+dp_{r,0}$ 更新答案。

另一种是从同一个子树中跳出来在 $x$ 处合并，这种情况不能在 $x$ 上枚举，因为这种情况的本质是某个 $x$ 子树内的点 $y$ 分出两个子树，从这两个子树出发一直跳相反的方向在 $x$ 处相遇，但我们无法确定 $y$ 的值。因此我们考虑在 跳的最后一步这里计算答案。具体地，对于一个 $x$，我们考虑两条路径经过 $x$，且在跳出 $x$ 的第一步就完成合并时的答案。此时先枚举 $x$ 的方向，不妨设是向左，然后同样分两种情况讨论。如果是从 $x$ 的两个子树中跳出来，那么就是 $dp_{l,0}+dp_{r,0}+1$（因为此时这两个子树只有在向左的时候才能遇到一起），否则就是 $dp_{l,2}+1$（$x$ 向左和左子树向左的这两条边会碰到一起）。

这样建出笛卡尔树之后直接 dp 即可，复杂度线性。

[代码](https://codeforces.com/contest/1987/submission/268392569)

---

## 作者：Moeebius (赞：10)

> **upd on 2024.10.6: 修了一张挂掉的图片。**

---

> Fun fact：本题被用作了一场 NOIP 模拟赛的 T4。
>
> 本文一定程度上参考了 @[qiuzx](https://www.luogu.com.cn/user/173935) 的 [题解](https://www.luogu.com.cn/article/sijcfsn1)。

一些初步的想法是：最终连出来的一定是一棵树；如果除了最大值之外还有其他点只能连自己，则无解。

考虑建出排列对应的大根笛卡尔树。

对于一种不连向自己的连边方案，向左连边就等价于在笛卡尔树上往上跳，直到第一次以右儿子的身份跳上去；向右连边则对应第一次以左儿子的身份跳上去。

![graph1](https://cdn.luogu.com.cn/upload/image_hosting/7n9hor8l.png)

$$
\small{ 上图是排列 \{2,1,4,3,5\} 对应的笛卡尔树。}
\\
\small{2\ 号点若向右连边，则会连向\ 3\ 号点。}
$$

考虑在笛卡尔树上 dfs，顺带维护这棵新连出的树的直径。

在 dfs 前，我们可以先预处理出只能向右/向左连边的点，稍后特判即可。

类比树的直径的树形 DP 做法，我们尝试在 LCA 处统计贡献。

---

记 $f_{i,0/1/2}$ 为：从 $i$ 子树内跳出，且最后一步对应 向左/向右/均有 连边，连边数量的最大值（包含跳出去对应的边）。

特别地，对于 $f_{i,2}$，要求连出来的是两条不交的路径。

假设我们现在在点 $x$，考虑转移：

1. **路径不要求含 $x$：**

$$
f_{x, 0} \gets f_{lc_x, 0} \\
f_{x, 1} \gets f_{rc_x, 1} \\
f_{x, 2} \gets f_{lc_x, 0} + f_{rc_x, 1}
$$

> 注意到如果向左连边并且跳出了左子树，那么一定也跳出了 $x$ 所在子树。其余情况同理。

![](https://cdn.luogu.com.cn/upload/image_hosting/b4761yx5.png)

$$
\small{虚线表示不一定直接相连的点。箭头表示新树上连的边。下同。}
$$

2. **路径要求包含 $x$，且 $x$ 向左连边：**

$$
f_{x, 0} \gets \max\{f_{lc_x,1},f_{rc_x,0}\} + 1 \\
f_{x, 2} \gets \max\{f_{lc_x,1} + f_{rc_x,1}, f_{rc_x,2}\} + 1
$$

> 注意到：
>
> 这种情况必然不会对 $f_{x,1}$ 产生贡献；
> 
> 第一个柿子表示从左/右子树跳到了 $x$，再用一步跳出去；
>
> 第二个柿子表示，如果存在一左一右两条跳出 $x$ 子树的路径，由于 $x$ 已经向左跳出，且左子树向右跳只可能跳到 $x$，故一定是右子树提供了这条向右跳出的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/5j4eelz4.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/oz514pbb.png)

$$
\small{蓝色，紫色箭头表示二选一。下同。}
$$

3. **路径要求包含 $x$，且 $x$ 向右连边：**

类似 2，不再赘述。

---

最后来统计答案，记路径两端点的 LCA 为点 $x$：

1. **两端点分属 $x$ 的两个子树：**

$$
\text{ans} \gets f_{lc_x,1} + f_{rc_x,0}
$$

2. **两端点来自 $x$ 同一子树内的两条不同路径：**

这种情况就不方便在 LCA 处统计了，因为两条边有可能是从子树内很深的点远道而来；我们转而考虑汇合前的最后一次跳跃。

枚举其中一个端点最后一次连边的方向，不妨设在点 $y$ 处向左连边（另一种情况同理）。

$$
\text{ans} \gets \max\{
f_{lc_y,0} + f_{rc_y,0},
f_{lc_y, 2}
\} + 1
$$

> 上式的含义是，要么左子树向左连边，在 $y$ 上方与 $x$ 向左连的边汇合，同时右子树向左连向 $y$；要么左子树连出一左一右两条边，其中向左的那条边与 $y$ 连的边汇合，向右的那条连向 $y$。

![](https://cdn.luogu.com.cn/upload/image_hosting/q1oardgj.png)

---

综上，我们在 $O(n)$ 的时间复杂度内解决了本题。代码实现难度较低。[代码。](https://codeforces.com/contest/1987/submission/276104020)
>

---

## 作者：naoliaok_lovely (赞：1)

参考了 <https://www.luogu.com.cn/article/32ct7526>。

首先手搓一下，尝试找出有解的充要条件：由题意得，每个点只会主动连出 $1$ 条边，且 $p_i=n$ 一定无法连边，因此这张图的边数上限为 $n-1$。所以原图连通等价于对于 $p_i\ne n$ 的所有点都成功找到了连边的 $j$，同时我们也得出最后是一棵树的结论。

向左右第一个比他大的点连边，考虑建笛卡尔树（大根），然后在笛卡尔树上 dp。具体的，$L$ 的含义是连接它的祖先中第一个左上方向的点，$R$ 是右上方向的点。根据我们上面有解的分析，我们不用担心除了根节点以外的点没有连边的情况。  
于是我们可以定义状态 $f_{i,0/1/2}$ 表示当前讨论到了以 $i$ 为根的子树，这棵子树中所有未连边的点 都为 $L$/都为 $R$/$LR$ 都有 的最大距离。这里的 $LR$ 都有指的是将未连边的点取出来，字符串为 $LL...LRR...R$ 的形式，这个在纸上画画就可以发现。

考虑 $f_x$ 的转移：  
首先考虑最后的直径不含 $x$ 点，直接继承即可：

$$f_{x,0}=f_{lson,0}\\f_{x,1}=f_{rson,1}\\f_{x,2}=f_{lson,0}+f_{rson,1}$$

这部分没什么好解释的，比较容易发现。  
否则，按照 $x$ 是 $L/R$ 分类，不妨设为 $L$（$R$ 同理）：

$$f_{x,0}=\max\{f_{lson,1},f_{rson,0}\}+1\\f_{x,2}=\max\{f_{lson,1}+f_{rson,1},f_{rson,2}\}+1$$

这里解释一下转移二：由于是 $f_{x,2}$ 且 $s_x=L$，意味着一定有剩余的 $R$ 未能成功匹配，要么来自 $f_{rson,1}$，要么来自 $f_{rson,2}$。

接着枚举每个点统计答案即可。这一步有别于只需要暴力枚举 $\operatorname{lca}$ 的朴素 dp 求直径，下面的情况很容易算漏：

![CF1987G2.png](https://cdn.acwing.com/media/article/image/2024/08/19/104910_5792e26b5d-CF1987G2.png) 

同样来考虑分类：

1. 贡献来自 $\operatorname{lca}$ 的两棵子树：$f_{lson,1}+f_{rson,0}$。
2. 贡献来自同一棵子树，向上面的图那样，此时我们在中间的那个点计算贡献。这个和之前的转移二类似，枚举红边的左右，例如上面的图是左上，则贡献为：$\max\{f_{lson,0}+f_{rson,0},f_{lson,2}\}+1$。

贡献取最大值即可。

```
#include<bits/stdc++.h>
using namespace std;

const int N = 4e5 + 10;
int n, p[N], f[N][3], ans;
char c[N];
int lson[N], rson[N], q[N], tt;

bool check()
{
	for(int i = 1, maxn = 0; i <= n && p[i] != n; i++)
		if(p[i] > maxn)
		{
			if(c[i] == 'L') return 1;
			c[i] = 'R';
			maxn = p[i];
		}
	for(int i = n, maxn = 0; i && p[i] != n; i--)
		if(p[i] > maxn)
		{
			if(c[i] == 'R') return 1;
			c[i] = 'L';
			maxn = p[i];
		}
	return 0;
}

void dfs(int x)
{
	if(lson[x]) dfs(lson[x]);
	if(rson[x]) dfs(rson[x]);
	f[x][0] = f[lson[x]][0], f[x][1] = f[rson[x]][1], f[x][2] = f[lson[x]][0] + f[rson[x]][1];
	ans = max(ans, f[lson[x]][1] + f[rson[x]][0]);
	
	if(x == q[1]) return;
	if(c[x] == 'L' || c[x] == '?') 
	{
		f[x][0] = max(f[x][0], max(f[lson[x]][1], f[rson[x]][0]) + 1);
		f[x][2] = max(f[x][2], max(f[lson[x]][1] + f[rson[x]][1], f[rson[x]][2]) + 1);
		ans = max(ans, max(f[lson[x]][0] + f[rson[x]][0], f[lson[x]][2]) + 1);
	}
	if(c[x] == 'R' || c[x] == '?')
	{
		f[x][1] = max(f[x][1], max(f[lson[x]][1], f[rson[x]][0]) + 1);
		f[x][2] = max(f[x][2], max(f[lson[x]][0] + f[rson[x]][0], f[lson[x]][2]) + 1);
		ans = max(ans, max(f[lson[x]][1] + f[rson[x]][1], f[rson[x]][2]) + 1);
	}
}

int main()
{
	int T;
	cin >> T;
	while(T--)
	{
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) scanf("%d", &p[i]);
		scanf("%s", c + 1);
		if(check())
		{
			puts("-1");
			continue; 
		}
		
		tt = ans = 0; 
		for(int i = 1; i <= n; i++)
		{
			lson[i] = rson[i] = 0;
			while(tt && p[i] > p[q[tt]]) lson[i] = q[tt--];
			if(tt) rson[q[tt]] = i;
			q[++tt] = i;
		}
		dfs(q[1]);
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/CF1987G2)

**题目大意**

> 给定 $1\sim n$ 排列 $a$，定义 $l_i,r_i$ 表示 $i$ 左侧 / 右侧第一个 $>a_i$ 的元素（没有设成 $i$）。
>
> 每个点向 $l_i/r_i$ 连边，有一些点已经确定连边，使得图连通并最大化直径。
>
> 数据范围：$n\le 4\times 10^5$。

**思路分析**

建出大根笛卡尔树，那么 $l_i,r_i$ 就是 $i$ 的左右父亲。

很显然根节点一定会连自己，那么剩下的边必须构成数，那么根的左链必须连 $r_i$，右链必须连 $l_i$，剩余的点随便连。

考虑树上线头 dp，对于每个 $u$，我们记录是否直径是否从 $u$ 子树连向 $l_u/r_u$。

设 $f_{u,0/1/2}$ 表示直径从 $u$ 子树连向 $l_u/r_u$ 或同时连向 $l_u,r_u$。

转移的时候分讨 $u$ 连边，以及直径从 $u$ 的左儿子还是右儿子向外连接。

查询的时候枚举 $\mathrm{LCA}$，如果直径端点分属 $\mathrm{LCA}$ 的不同子树，则是平凡的，否则答案肯定分属 $\mathrm{LCA}$ 儿子的不同子树，在 $\mathrm{LCA}$ 儿子处统计答案即可。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=4e5+5;
inline void chkmax(int &x,const int &y) { x=y>x?y:x; }
int n,rt,a[MAXN],ls[MAXN],rs[MAXN],f[MAXN][3],stk[MAXN],ans;
char str[MAXN];
void dfs(int u) {
	if(!u) return ;
	int lc=ls[u],rc=rs[u];
	dfs(lc),dfs(rc);
	f[u][0]=f[lc][0],f[u][1]=f[rc][1],f[u][2]=f[lc][0]+f[rc][1];
	chkmax(ans,f[lc][1]+f[rc][0]);
	if(u==rt) return ;
	if(str[u]!='R') {
		chkmax(f[u][0],max(f[lc][1],f[rc][0])+1);
		chkmax(f[u][2],max(f[lc][1]+f[rc][1],f[rc][2])+1);
		chkmax(ans,max(f[lc][2],f[lc][0]+f[rc][0])+1);
	}
	if(str[u]!='L') {
		chkmax(f[u][1],max(f[lc][1],f[rc][0])+1);
		chkmax(f[u][2],max(f[lc][2],f[lc][0]+f[rc][0])+1);
		chkmax(ans,max(f[lc][1]+f[rc][1],f[rc][2])+1);
	}
}
void solve() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),ls[i]=rs[i]=0;
	scanf("%s",str+1);
	int tp=0;
	for(int i=1;i<=n;++i) {
		while(tp&&a[stk[tp]]<a[i]) ls[i]=stk[tp--];
		if(tp) rs[stk[tp]]=i;
		stk[++tp]=i;
	}
	rt=stk[1];
	for(int u=ls[rt];u;u=ls[u]) {
		if(str[u]=='L') return puts("-1"),void();
		str[u]='R';
	}
	for(int u=rs[rt];u;u=rs[u]) {
		if(str[u]=='R') return puts("-1"),void();
		str[u]='L';
	}
	ans=0,dfs(rt);
	printf("%d\n",ans);
}
signed main() {
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---


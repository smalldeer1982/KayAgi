# Counting 101

## 题目描述

### 题目背景

夏日漫长，蝉鸣不断，酷暑难耐。终于，它落下了帷幕。决战已过，大门敞开，只留下一阵轻风。

你的前辈们已经完成了最后的鞠躬，轮到你上场了。


在整理留下的一些笔记时，你发现了一份名为 **问题 101** 的奇怪声明：

- 给定一个正整数序列 $a_1,a_2,\ldots,a_n$，你可以对它进行任意次操作。在一次操作中，你可以选择连续的三个元素 $a_i,a_{i+1},a_{i+2}$，并将它们合并为一个元素 $\max(a_i+1,a_{i+1},a_{i+2}+1)$。请计算在不产生大于 $m$ 的元素的前提下，最多可以进行多少次操作。

经过思考，你决定提出下面这个问题，命名为 **计算 101**：

- 给定 $n$ 和 $m$。对于每一个 $k=0,1,\ldots,\left\lfloor\frac{n-1}{2}\right\rfloor$，求元素在 $[1, m]$ 中的整数序列 $a_1,a_2,\ldots,a_n$ 的个数，使得作为 **问题 101** 的输入时，答案是 $k$。由于答案可能非常大，只需要输出对 $10^9+7$ 的结果即可。

## 样例 #1

### 输入

```
2
3 2
10 10```

### 输出

```
6 2 
1590121 23399118 382293180 213020758 379696760```

# 题解

## 作者：ForgotMe (赞：4)

不是哥们，$\mathcal{O}(n^5m)$ 开 $n=130,m=30$，就欺负我常数大吗？？？真的是要吐了。

官方题解写的不是很详细，读起来可能比较令人迷惑，这里写一篇比较详细的题解，希望能给后人引路。

为了阅读的流畅性，先定义一些东西：

- $n$：序列 $a$ 的长度，$m$：操作过程中元素大小的限制。

## Part 1：How to solve Problem 101.

很容易看出来这是一个 dp 套 dp 的问题，那么先从最简单的入手，如何解决 Problem 101，这个都不会何谈计数。

可以发现这并不是一个平凡的区间 dp 问题，因为是 $3$ 个数合成一个数，直接先要按照以往区间 dp 的套路去做是行不通的。

注意到每次操作一定会减少 $2$ 个数，那么让剩下的数的个数尽量少就是让操作次数最大化。

考虑先挖掘一些性质。

### 性质 $1$

- 当序列 $a$ 的最大值**不超过** $m-1$ 时，此时最少能剩下的数的个数不超过 $2$。

Proof：

这个性质的证明比较简单。

- 当 $n\bmod 2=0$ 时，此时最少能剩下两个数，选一个最中间位置的数以其为中心不断操作即可。

- 当 $n\bmod 2=1$ 时，此时最少能剩下一个数，选最中间位置的数以其为中心不断操作即可。

显然最后剩下的数的大小都不超过 $m$。

这个性质启发我们可以将序列 $a$ 按照最大值 $m$ 的位置分成若干段，因为值等于 $m$ 的位置只能以其为中心进行操作，换句话说就是此时各段之间是独立的。

设 $pos_1,pos_2,...pos_l$ 从小到大依次表示满足 $a_{pos_i}=m$ 的位置，此时序列被分成了 $[1,pos_1-1],[pos_1+1,pos_2-1],...,[pos_{l-1}+1,pos_l-1],[pos_l+1,n]$ 这些段。

于是可以很自然的引出一个 dp，设 $g_{i,j}$ 表示考虑到了第 $i$ 个最大值，其中以第 $i$ 个最大值的位置为中心操作了 $j$ 次。

如何转移呢？假设现在要从 $g_{i,j_1}$ 转移到 $g_{i+1,j_2}$，并设中间夹着的段的长度为 $R$，首先肯定要满足 $j_1+j_2\le R$，不然肯定无法转移。

根据上面的性质 $1$，可以知道中间的段最终剩下的长度一定不会超过 $2$。那么不如先考虑一下中间的段能不能全部消除掉。手玩可以发现如果要消完，一定是中间的段先内部消化，消成个数只有 $j_1+j_2$ 时就给两边的最大值消。

问题来了，中间的段不一定能消成 $j_1+j_2$，因为性质 $1$ 中最后剩下的元素可能会有 $m$，此时无法给两边的最大值消。于是又可以引出另外一个数组：设 $f_{l,r,v}$ 表示对区间 $[l,r]$ 的数操作在不操作出大于 $v$ 的数的前提下最少能剩下几个数。有了这个，$g$ 就可以转移了。

设 $g_{i+1,j_2}=g_{i,j_1}+cost(j_1+j_2,f_{pos_{i}+1,pos_{j}-1,m-1})$。

其中 $cost(j,L,R)$ 如下：

- $j>R$，$+\infty$。
- $j\equiv L (\bmod\ 2)$，当 $L\le j\le R$，值为 $0$，当 $j\lt L$ 时，值为 $2$。
- $j \not\equiv L (\bmod\ 2)$，$j\le R$ 时，一定是 $1$。

转移就不在解释了，这些东西自己手动推一推都能得出来。

关键是 $f$ 怎么搞，注意到 $f$ 其实上就是一个子问题，因为本来要求的答案就是 $f_{1,n,m}$。

于是现在就会了 Problem 101，感觉这个就已经够恶心了。

## Part 2：How to Count Problem 101

如果想直接把 $g$ 数组压进 dp 状态里，那肯定是不现实的，既然这个题能做，说明 $g$ 数组存在一定的性质。

如果你是一个喜欢打表观察规律的人，那么很容易发现以下性质。

### 性质 $2$

- $\forall 1\le i\le l$，设 $mn=\min_j g_{i,j}$，序列 $\{g_{i,j}-mn\}$ 将会出现以下形式 $[...2,1,2,1,0,1,0,1,0,1,2,1,2..]$，即将序列 $\{g_{i,j}-mn\}$ 按照下标 $j$ 奇偶分类分成两部分，一部分全是 $1$，另一部分全是 $0,2$ 且是**单谷**。

这是一个非常牛逼的性质，通过该性质，容易通过一个四元组 $(l,r,mn,lim)$ 刻画一个数组 $g$，其中 $l,r$ 分别表示满足 $g_{i,j}=0$ 的所有 $j$ 中的最小/最大的 $j$，$mn$ 定义如上，$lim$ 为 $j$ 的上界限制。

这个性质的证明不算难，但是非常的 dirty work，需要大量的分类讨论，此处略去。

那么就可以有一个初步的做法了，设 $dp_{i,v,l,r,mn,lim}$ 表示当前一共填了 $i$ 个数，最大值限制是 $v$，$(l,r,mn,lim)$ 刻画了当前的 $g$ 数组的方案数。

转移是简单的，枚举下一个段的长度 $len$，还需要枚举该段在不操作出大于 $v$ 的数的前提下最少能剩下几个数 $L$，请注意，由于这里是计数版本，$f$ 的定义需要改变，$f_{n,m,L}$ 表示长度为 $n$ 值域在 $[1,m]$ 的所有序列中最少能剩下 $L$ 个数的序列个数。

那么可以写出转移式 $dp_{i,v,l,r,mn,lim}\times f_{len,v-1,L}\rightarrow dp_{i+len+1,v,l^{'},r^{'},mn^{'},len}$。其中 $l^{'},r^{'},mn^{'},len$ 用于刻画新的 $g$ 数组，这可以通过预处理得到。

于是得到了一个恐怖的 $\mathcal{O}(n^7m)$ 做法。

考虑优化。

### 性质 $3$

- 我们声称：$g$ 数组中 $j$ 的上界（$lim$）是不重要的，用 $(l,r,mn)$（超过上界的依然当作有值），直接去转移同样能得到正确的 $l^{'},r^{'},mn^{'}$。

这个性质是容易证明的，因为超过上界的有值的部分是 $1$ 或者 $2$，本身就已经很劣，通过一些分类讨论可以说明这些超过上界部分的转移是不优的，可以省去。

于是 dp 数组降了一维，复杂度来到了 $\mathcal{O}(n^6m)$ 做法。

可惜还是很慢，考虑省略掉不需要的状态。

在书写性质 $4$ 之前，先规定一些东西。

对于三元组 $(l,r,mn)$，认为一次转移就是对其施加一个二元组 $(L,R)$（即后面加入一个长度为 $R$ 的段，$L$ 为 $cost$ 函数的参数）后，得到一个新的三元组 $(l^{'},r^{'},mn^{'})$。

### 性质 $4$

- 我们声称：对于一个三元组 $(l,r,mn)$，将其拆分成 $(l,+\infty,mn),(l\bmod 2,r,mn),(l\bmod 2,+\infty,mn)$ 三个三元组，无论后面将要进行多少次转移，设这四个三元组最后分别变成了 $(l_1,r_1,mn_1),(l_2,r_2,mn_2),...,(l_4,r_4,mn_4)$，一定有 $\{mn_1\}=\{mn_2,mn_3\} / \{mn_4\}$（$/$ 表示剔除这个集合），注意这里的集合是可重集，认为 $\{4,4\}/\{4\}=\{4\}$。

Proof：如果想要直接证明的话是非常复杂的，注意到这个问题是对称的，可以从前往后转移，也可以从后往前转移，两者是显然是等价的，于是可以考虑把后面的段从后往前转移合并成一个新的 $g^{'}$ 数组，然后再把当前的 $g$ 数组与 $g^{'}$ 合并。形式化来讲，设这四个三元组所对应的 $g$ 分别是 $g_1,g_2,g_3,g_4$，那么只需要证明 $ \{ \min_j(g_{1,j}+g^{'}_{j}) \}= \{ \min_j(g_{2,j}+g^{'}_{j}),\min_j(g_{3,j}+g^{'}_{j})\} / \{\min_j(g_{4,j}+g^{'}_{j})\}$，现在就好证明多了，根据 $g$ 的奇偶单谷性质和一些分类讨论就能进行证明。

这是一个非常强的性质，说明一个状态可以拆分成三个状态进行转移且最终的答案是不变的。

那么现在本质不同的状态数量级别又少了一个 $n$，可以每转移一步就把转移出来的区间拆了。时间复杂度 $\mathcal{O}(n^5m)$，超级卡常，根本过不去。

找了下出题人，出题人说跑不满，但这个数据范围可能不太合理。所以我开摆了，精神胜利了，代码并不难写，所以就不放了。看了下 AC 代码，似乎存在其他的小常数做法？？？

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/CF2002H)

**题目大意**

> 给定一个序列 $a$，一次操作可以将 $a_{i-1},a_i,a_{i+1}$ 替换成 $\max(a_{i-1}+1,a_i,a_{i+1}+1)$。
>
> 定义一个序列的权值为：保证 $\max a_i\le  m$ 的情况下能进行最多的操作次数。
>
> 给定 $n,m$，对于每个 $k$ 求有多少序列 $a_1\sim a_n$ 权值为 $k$。
>
> 数据范围：$n\le 130,m\le 30$。

**思路分析**

先刻画序列的权值，如果初始没有 $a_i=m$ 的元素，那么剩下的元素个数不超过 $2$。

这是显然的，我们不断操作序列最中间的元素，此时最终的元素是 $\max a_i+[i\ne mid]\le m$。

那么如果有 $a_i=m$ 的元素，很显然如果对这个元素操作，一定是以 $a_i$ 为中心进行操作。

观察相邻两个 $m$ 之间的元素，我们发现最优解有两种情况：

- 一种是先把以 $m$ 为中心的操作全部做完，剩下 $<m$ 的每一段元素用上述 $\max a_i<m$ 的元素删剩下 $1\sim 2$ 个。
- 如果想剩下 $0$ 个元素，那么我们要先在区间内操作几次，在不产生 $=m$ 的元素的情况下使得区间内的元素被两端 $a_i=m$ 的元素的操作覆盖。

因此我们只关心每个 $a_i=m$ 的位置上操作了几次，记为 $g_{i,j}$，表示第 $i$ 个 $m$ 上操作了 $j$ 次，最少能剩下几个元素。

转移就是 $g_{i-1,j_1}\to g_{i,j_2}$，设两个 $m$ 中间夹着的连续段长度为 $L$，转移系数就是这个 $L$ 个元素最少能剩下几个：

- 首先要求 $j_1+j_2\le L$。

- 如果 $L\bmod 2=1$，那么转移系数就是 $+1$。

- 否则考虑这一段区间内部，在值域 $[1,m-1]$ 的情况下最少剩几个元素，很显然这就是值域 $m-1$ 的子问题，设答案为 $p$。

  如果 $j_1+j_2\ge p$，系数是 $0$，否则系数是 $1$。

然后解决原问题需要套一个 dp of dp，把 $g_i$ 压入状态。

但 $g_i$ 的信息量太大，需要压缩。

对于这种转移系数极差很小的情况，可以猜测 $g_i$ 的极差也很小。

因此定义 $g'_{i,j}=g_{i,j}-\min_k g_{i,k}$，打表发现：$g'_i$ 的形式和转移系数完全相似，都形如 $1,2,1,0,1,2,1$。

即某种奇偶性的下表上全是 $1$，另一种上是若干个 $2$ 加若干个 $0$ 再加若干个 $2$，证明可以分讨归纳。

那么记录一个 $g_i$，只需要 $(\min g_i,l,r,len)$，表示长度为 $len$，取到 $\min g_i$ 的下标是 $[l,r]$ 中间和 $l$ 同奇偶的位置。

此时状态仍然过大，进一步发现： $>r$ 的元素意义较小，因为转移函数相对单调，较大的位置对 dp 转移几乎没有贡献。

事实上可以证明 $(\min g_i,l,r,len)\iff(\min g_i,l,r,\infty)$，即这两个 $g_i$ 进行内层 dp 的结果相同，从而优化掉一维状态。

这还不够，我们发现同时记录 $[l,r]$ 的复杂度难以承受，进一步观察可以发现 $(\min g_i,l,r)\iff(\min g_i,l,\infty)+(\min g_i,l\bmod 2,r)-(\min g_i,l\bmod 2,\infty)$。

即最终内层 dp 的答案等价于这三个内层 dp 的答案相加减的结果。

感性理解就是用 $[l,r]$ 转移得到的 $g'_{i,j}$ 和 $[l\bmod 2,r),[l,\infty)$ 转移得到的 $g'_{i,j}$ 中的一个相同，即最优的转移点不可能同时存在于 $<l$ 和 $>r$ 的位置。

那么每次转移后立刻分拆状态，转移的时候分讨 $g$ 形态变化即可。

时间复杂度 $\mathcal O(n^5m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int n=130,m=30,MOD=1e9+7;
inline void add(int &x,const int &y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
int pw[35][135],dp[35][135][135],f[135][135][135],g[135][135][135];
//dp[v,i,j]: val[1,v], len=i, max del=j
//f[i,j,l],g[i,j,r]: len=i, g0=j, [L0,R0] = [l,inf]/[0,r]
signed main() {
	for(int i=0;i<=m;++i) for(int j=pw[i][0]=1;j<=n;++j) pw[i][j]=1ll*pw[i][j-1]*i%MOD;
	dp[0][0][0]=1;
	for(int v=1;v<=m;++v) {
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		g[0][0][0]=1;
		for(int i=0;i<=n+1;++i) for(int j=0;j<=i;++j) {
			for(int l=0;l<=i;++l) if(f[i][j][l]) add(f[i][j][l&1],MOD-f[i][j][l]); //split -> [0,l]-[0,inf]
			for(int l=0;l<=i;++l) if(f[i][j][l]) {
				const int w=f[i][j][l];
				for(int k=0;i+k<=n;++k) {
					const int z=1ll*w*pw[v-1][k]%MOD;
					if(l>k) { //can't +0
						int nr=k-((l+1)&1); //trans +1, (a+l-k)%2=1
						if(nr>=0) add(g[i+k+1][j+2][nr],z); //max a = k-(l&1^1)
						else add(g[i+k+1][j+3][0],z); //can't +1
					} else add(g[i+k+1][j+1][k-l],z); //a+l<=k
				}
			}
			for(int r=0;r<=i;++r) if(g[i][j][r]) {
				const int w=g[i][j][r],l=r&1; //[l,r]
				for(int k=0;i+k<=n;++k) {
					const int z=1ll*w*pw[v-1][k]%MOD;
					if(l>k) { //can't +0 (same)
						int nr=k-((l+1)&1);
						if(nr>=0) add(g[i+k+1][j+2][nr],z);
						else add(g[i+k+1][j+3][0],z); 
					} else {
						//d<=a+r,a+l<=k -> a in [d-r,k-l]
						//split to [d-r,inf] + [0,k-l] - [0,inf]
						add(g[i+k+1][j+1][k-l],z);
						int *nw=f[i+k+1][j+1],*Z=dp[v-1][k];
						for(int d=r+(k-l)%2;d<=k;d+=2) if(Z[d]) {
							nw[d-r]=(nw[d-r]+1ll*w*Z[d])%MOD;
//							(nw[d-r] -= w*Z[d]) split -[0,inf] at line#18
						}
					}
				}
			}
		}
		for(int i=1;i<=n+1;++i) for(int j=1;j<=i;++j) {
			//0-th & i-th element is virtual, j=g[0]
			for(int l=0;l<=i;++l) {
				add(dp[v][i-1][j-1+(!l?0:(l&1?1:2))],f[i][j][l]);
			}
			for(int r=0;r<=i;++r) {
				add(dp[v][i-1][j-1+(r&1)],g[i][j][r]);
			}
		}
	}
	int T; scanf("%d",&T);
	for(int N,M;T--;) {
		scanf("%d%d",&N,&M);
		for(int K=0;K<=(N-1)/2;++K) printf("%d ",dp[M][N][N-2*K]); puts("");
	}
	return 0;
}
```

---


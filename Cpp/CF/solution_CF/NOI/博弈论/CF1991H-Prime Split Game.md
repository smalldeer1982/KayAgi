# Prime Split Game

## 题目描述

Alice 和 Bob 正在玩一个有 $n$ 堆石子的游戏，第 $i$ 堆有 $a_i$ 个石子。两人轮流操作，Alice 先手。

每次操作，玩家需要完成以下三步：

1. 选择一个整数 $k$（$1 \leq k \leq \frac{n}{2}$）。注意，不同回合可以选择不同的 $k$。
2. 移除 $k$ 堆石子。
3. 再选择另外 $k$ 堆石子，将每一堆分成两堆，每一新堆的石子数都必须是质数。

无法进行操作的玩家判负。

请判断如果双方都采取最优策略，谁会获胜。

## 说明/提示

在第一个测试用例中，有 $2$ 堆石子，分别有 $2$ 和 $1$ 个石子。由于 $1$ 和 $2$ 都无法分成两个质数的堆，Alice 无法进行操作，因此 Bob 获胜。

在第二个测试用例中，有 $3$ 堆石子，分别有 $3$、$5$ 和 $7$ 个石子。Alice 可以选择 $k=1$，移除 $7$ 个石子的那一堆，然后将 $5$ 个石子的那一堆分成 $2$ 和 $3$ 两堆（都是质数）。此时剩下 $3$ 堆石子，分别为 $3$、$2$ 和 $3$ 个，Bob 无法进行有效操作，因此 Alice 获胜。

在第三个测试用例中，有 $4$ 堆石子，分别为 $4$、$6$、$8$ 和 $10$ 个。Alice 可以选择 $k=2$，移除 $8$ 和 $10$ 个石子的两堆，将 $4$ 个石子的那一堆分成 $2$ 和 $2$ 两堆，将 $6$ 个石子的那一堆分成 $3$ 和 $3$ 两堆。此时 Bob 无法进行有效操作，因此 Alice 获胜。

在第四个测试用例中，有 $5$ 堆石子，每堆都是 $8$ 个。可以证明，如果双方都采取最优策略，Bob 会获胜。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
2
2 1
3
3 5 7
4
4 6 8 10
5
8 8 8 8 8```

### 输出

```
Bob
Alice
Alice
Bob```

# 题解

## 作者：Eraine (赞：15)

编号：CF1991H

tag：博弈论，数论

难度：$\color{black}{3}\color{red}{328}$（$\texttt{Clist}$ 数据）

额其实不需要卷积。暴力 + 一点点剪枝优化也能通过此题。希望各位读者能通过此题和本文的一点点帮助能对博弈论有更为深刻的理解。

既然是博弈论的题目，那么我们先来思考什么是结束态。即每个数都不能被拆分成两个质数的形式。对于正偶数而言，除了 $2$ 以外其他数均能被拆分成两个质数相加的形式。对于正奇数而言，由于正奇数 $x$ 拆分成任何两个正数相加，这两个正数必然一个为奇数，一个为偶数。而偶质数只有 $2$，那么另外一个数必然为 $x-2$。也就是一个序列为结束态当且仅当对于任意的 $i$ 都有 $a_i\in{1,2,4}$ 或 $a_i-2\in \text{Prime}$。

博弈论最好还是手玩一下。从最简单的情况考虑：对于长度为 $2$ 的序列 ${1,x}$，对于每一个 $x$ 都判断先手的输赢情况。$x=1,2$ 显然先手必输。考虑 $x\ge 3$ 的情况。分成奇偶两类讨论。奇数只能拆成 $2$ 和一个奇素数的和的形式。那么需要得到最多能从 $x$ 拆出 $2$ 的数量，这个值若为奇数显然必赢，偶数必输。

接下来讨论 $x$ 为偶数的情况。除了 $x=4$ 的情况只能拆成 $(2,2)$，其他情况都能拆成两个奇质数。$x=4$ 的情况显然必赢。不难发现拆的两个奇素数必须满足单独出现时（即奇素数 $x$ 在情况 $(x,1)$ 时的输赢情况）均为必输态才能必赢，否则对手可以选择其中的必赢态进行拆分。

大致规定一下 $\text{sg}$ 函数。规定必输态 $\text{sg}(i)=0$，必赢态 $\text{sg}(i)=1$。

$\text{sg}(i)=\begin{cases}
0&\text{if}\ i\in\{1,2\}\\
1&\text{if}\ i\in\{4\}\\
0&\text{if}\ i\ \text{is odd},cnt(i)\ \text{is even}\\
1&\text{if}\ i\ \text{is odd},cnt(i)\ \text{is odd}\\
0&\text{if}\ i\ \text{is even},\forall j\in\text{Prime}\land i-j\in\text{Prime},\text{sg}(j)=1 \lor \text{sg}(i-j)=1\\
1&\text{if}\ i\ \text{is even},\exists j\in\text{Prime}\land i-j\in\text{Prime},\text{sg}(j)=\text{sg}(i-j)=0\\
\end{cases}$

其中 $cnt(i)$ 表示奇数 $i$ 最多能拆分出多少个 $2$ 出去。

显然对于 ${1,x}$ 中的 $x$ 满足上述情况。

我们发现，当 $\text{sg}(i)=0$ 时，若还可以拆分，假设拆分成 $x,y$，则 $\text{sg}(x)=1$ 和 $\text{sg}(y)=1$ 至少有一个成立。而 $\text{sg}(i)=1$ 时，必然存在 $\text{sg}(x)=\text{sg}(y)=0$。其实这句话就是本题的核心了。

扩展到 $n\in[2,2\times 10^5]$ 的一般情况。有结论：

> 当 $\forall\ i\in[1,n],\text{sg}(a_i)=0$ 时，Alice 必输。

这个和 Nim 其实有点像。但是游戏策略不同。假设此时 Alice 将 $k$ 个 $\text{sg}(i)=0$ 的数拆分了，那么拆分后的 $2k$ 个数至少有 $k$ 个数的 $\text{sg}$ 值为 $1$。此时 Bob 只需要将 $\text{sg}$ 值为 $1$ 的任意 $k$ 个数拆分成 $2k$ 个 $\text{sg}$ 值为 $0$ 的数，同时覆盖剩下的最多 $k$ 个 $\text{sg}$ 值为 $1$ 的数。这样使得序列的 $\text{sg}$ 值再次全部变为 $0$。而最终态也满足 $\text{sg}$ 值全为 $0$，所以必输。

那么其实可以猜到了，对于大部分情况而言，有以下结论：

> 当 $\exists\ i\in[1,n],\text{sg}(a_i)=1$ 时，Alice 必赢。

显然先手可以采用覆盖的策略，如果此时出现 $2k(-1)$ 个 $\text{sg}$ 值为 $1$ 的数，同上文 Bob 策略覆盖即可。

为什么说是大部分情况呢？因为你会发现这个策略过不了如下样例：

```
5
4 4 4 4 4
```

这个样例答案是 Bob。可是根据上述策略会输出 Alice。

当 $n$ 是奇数且 $n$ 个数的 $\text{sg}$ 值都为 $1$ 时，无法做到一遍就将所有数的 $\text{sg}$ 值变为 $0$。对于特殊数据，看起来就是 Bob 赢了。大概想一想就是随便翻几个 $\text{sg}$ 值为 $1$ 的变成 $0$，那么就转变成 Alice 必赢的情况了，由于已经 Alice 执行过了于是就变成 Bob 必赢。

但是这段话有一个问题。随便翻几个 $\text{sg}$ 值为 $1$ 的在前面的必胜策略中是变成两个 $0$，可是是在必胜策略中，这里就要输了，所以可以改变策略。为了方便，称 $\text{sg}$ 值为 $1$ 且能拆分成两个 $\text{sg}$ 值为 $1$ 的和的数为双子数。双子数若拆分，拆分后的两个数必然都不为双子数。所以拆分双子数的结果是减少。拆分多少个双子数，双子数个数就减少多少。如果 $1$ 能变成两个 $1$（两个 $0$ 和一个 $0$ 加上一个 $1$ 都不合法，因为这样会变成 Bob 必赢的情况，这里必须使序列保持全部值的 $\text{sg}$ 值均为 $1$），那么就可以拖延一会儿，拖延到对方遇到不存在双子数的情况，那么此时就必赢。具体地，设 $n=2m+1$，$p$ 为双子数个数，当 $p=0$ 时显然 Bob 必赢，$p\in[1,2m]$ 可以类似前面覆盖的方法一遍将所有双子数全部变消失，所以 Alice 必赢。$p=2m+1$ 时，Bob 必赢。具体地，Bob 取后的状态尽量维持双子数个数为奇数。Alice 第一步只能将双子数个数减少 $2l$ 个。因为此时序列中全是双子数。Bob 的第一步就是减少 $1$ 个使此时序列双子数个数从奇数变为偶数。接下来~~抄袭 Alice~~ Alice 上一步将双子数减少了多少，Bob 同样也减少多少。这很好做到。所以最后一个双子数只能由 Bob 拆分。此时就变成 Bob 必赢（即 $p=0$ 的状态回到了 Alice 上）。

根据这个策略，我们可以成功通过此题。在求出 $\text{sg}$ 函数的基础上，根据上述逻辑判断是 $\Theta(\sum n)$ 的。程序的瓶颈在于求出 $\text{sg}$ 函数和双子数判断函数（即一个数组存每个值是否是双子数）。$2\nmid i$ 的部分是线性的，$2\mid i$ 的部分是平方的。但是观察这个复杂度平方的式子，是一个卷积的形式，那么就可以用 FFT/NTT 优化。众所周知，FFT/NTT 不是 NOI 考点，所以我们可以用 bitset 优化或者加一些剪枝。这里就让大家各显神通了。方法很多，随便选一个打一下只要能过就行。

设 $f(i)$ 表示求出 $1\sim i$ 区间内所有元素的 $\text{sg}$ 值和双子数判断函数的复杂度。

$\Theta(f(2\times 10^5)+\sum n)$。

[submission](https://codeforces.com/contest/1991/submission/273330503)

若有疑问或错误请指出，虚心接受您的意见。

upd：

2024.7.30 感谢 @wukaichen888 指出了本文的三处笔误。已修正。

2024.11.18 感谢 @Drind 指出了本文的一处笔误。已修正。

---

## 作者：xuanxuan001 (赞：4)

垃圾结论 G 题还我 rating。。。

我知道有些靠着 G 起飞的人看到后会不认可，~~因为之前我也是这么看别人对一些其他题目的评论的~~，但我还是觉得这种纯猜结论的题很垃圾，即使之前没被卡也这么觉得。

找回了一点补难题的快乐，但这题也不算太难，主要是不难写。

正文
-

看着这个博弈方式感觉无从下手，所以考虑一些简单情况，考虑只有两堆石子，一堆只有一个，另一堆有 $n$ 个。

那么肯定要分割 $n$。如果 $n$ 是奇数就一定会分成 $2$ 和 $n-2$，很容易判断胜负。如果是偶数就一定会分成两个奇数（$4$ 单独考虑），那么后手可以选择保留一个奇数，因此只要有一个奇数是会让先手胜利的数就不行。

将先手必胜的 $n$ 认为是好数(?)，否则是坏数。那么上面的分析可以归纳为：

$n$ 为好数当且仅当 $n$ 可以被分割为两个坏数（当然它们也需要是质数）。

奇数的好坏可以递推得到，偶数的在奇数的基础上跑一遍 NTT 即可（当然需要特殊考虑 $4$ 是好数）。

然后回到原题，发现如果所有数都是坏数，那么先手已经输了，因为假设他选择了分割 $k$ 个数，那么后手可以直接分割他产生的 $k$ 个好数并删去剩下的 $k$ 个，依然全是坏数。

所以 Alice 就要尽量制造这种局面，她会尝试在第一步直接把所有好数分割或删去，并且在大部分情况下是可以做到的，只有在 $n$ 是奇数并且全都是好数时做不到。下面考虑这种情况，读者可以先自行思考一下，记住每次分割完必须是质数~~我就因为忘了这个尝试自己思考没想出来~~。

这时很容易以为 Alice 必输，但其实不是，她只需要让操作后的数依然全是好数就还有机会。那么会发现这时的情况与原题类似，再定义一个二级好数，一个数是二级好数当且仅当它自己是个好数并且可以分割成两个不是二级好数的好质数（好绕口，但大致意思很简单），然后又是类似的结论。

然后考虑如何快速判定二级好数，分析后发现，首先奇数不可能是二级好数，因为它一定会分出坏数 $2$。而偶数一定会分成两个奇数（$4$ 显然不是二级好数，不用考虑），因此不用考虑分出来的数是不是二级好数的问题，因此又是一个简单的 NTT 卷积。

会不会导致需要继续定义三级甚至更多级的好数呢？继续上面的分析，二级好数一定不是质数，所以也就不需要继续考虑了。

结束了？结束了。[代码](https://codeforces.com/contest/1991/submission/273330033)。

---

## 作者：Awdrgysxc (赞：2)

先从一个简单的情况考虑，假设现在只有两堆，并且其中一堆是 $1$（只要是无法操作的数字即可）。

对另一堆讨论：

不可拆分，那么为先手必败态。

可以拆分，那么需要判断状态，做法是在所有拆分方案中寻找是否可拆分成两个先手必败态，若可以找到，那么当前状态为先手必胜态。若至少能拆分出一个先手必胜态，则当前状态一定为先手必败态，因为对手可以直接拆分其中一个处于必胜态的数字，然后再删去另一个即可。

先不考虑怎么具体处理，假设现在能用比较快的方式求出每个数字对应的状态，我们接着考虑对于更一般的情况，也就是，有多堆数字怎么办？

假设有 $n$ 堆数字，有 $x$ 个必胜态，当然如果 $x=0$ 先手必败。如果不是 $0$ 怎么办？

根据上述第二点的讨论，可以发现如果我们能把所有处于必胜态的数字删掉（如果能全部删掉，那当然要全部删掉，这样一定不劣），那么先手必胜。

如何才能全部删掉？

发现和 $n$ 的奇偶性相关。若 $n$ 是偶数，那么无论有多少给处于必胜态的数字都能删去。若 $n$ 是奇数，那么最多删掉 $n-1$ 个。上述情况都是必胜的。

还剩最后一直情况，$n$ 为奇数，有 $n$ 个处于必胜态的数字。

这时候如何仅仅将数字分为必胜/必败态就不够明智了，因为在这种情况下，在这种分解策略下是必败的，但是此时先手真的必败吗？

如果这些处于必胜态的数字只能拆分成两个处于必败态的数字，那么这种情况确实必败，因为没法分解了。

那么我们考虑能不能把这种情况留给对手，也就是考虑把原来的必胜态分解成两个必胜态，并且一开始把所有这种必胜态都分解掉或删掉。那么这样就只剩下最后一种情况了。

当然这个做法的前提是一个由必胜态分解出来的必胜态不能再分解成两个必胜态（暂且称它为双必胜态）。由于质数只有 $2$ 是偶数，其余都是奇数，我们不妨从奇偶性去考虑这个问题。

假设双必胜态为奇数，那么一定会分解出一个偶数 $2$，然而 $2$ 是必败态，所有矛盾，不成立。

双必胜态一定为偶数，那么只能分解成两个奇数 ($2+2$ 除外)，根据以上论述，奇数不是双必胜态，所有双必胜态最多分解一次（两个必胜态）。

如果 $n$ 为奇数，有 $n$ 个必胜态，并且有双必胜态，且双必胜态的数量小于 $n$，那么此时先手必胜，证明是类似的。

接着考虑如何快速求出必胜态以及双必胜态。

如果用最暴力的方式去判断必胜/必败态，时间复杂度为 $O(\frac{N^2}{\ln N})$。

根据质数的特殊性，我们同样分奇偶考虑这个问题。

如果 $x$ 是奇数，那么只能分解成 $2+(x-2)$，这个直接递推处理即可。

如果 $x$ 是偶数，要找到一组分解 $a+b=x$ 且 $a,b$ 为质数，且为必败态。注意，这里是质数必败态，这个是好处理的，只能分解成 $2+(x-2)$。

这个其实就可以先预处理奇数的部分，然后做一个值域上的卷积了，可以考虑 fft 或者用 bitset 优化暴力乘法，时间复杂度为 $O(N\log N)$ 或 $O(\dfrac{N^2}{w})$。

对于双必胜态，处理方式是类似的，先要处理出质数的必胜态，再做一个卷积，时间复杂度是一样的。

```cpp
#include <bits/stdc++.h>

const int MAXN = 2.001E5;
std::bitset <MAXN> isPrime, primeLose, win, primeWin, doubleWin;

inline void initialize() {
  isPrime.set();
  isPrime.reset(1);
  for (int i = 2; i < MAXN; ++i)
    if (isPrime[i])
      for (int j = i + i; j < MAXN; j += i)
        isPrime.reset(j);
  
  win.set(4);
  for (int i = 3; i < MAXN; i += 2) {
    int cnts = 0, x = i;
    while (isPrime[x - 2]) {
      cnts ^= 1, x -= 2;
    }

    win[i] = cnts, primeLose[i] = isPrime[i] && !win[i];
  }

  for (int i = 3; i < MAXN; i += 2)
    if (primeLose[i])
      win |= primeLose << i;
  for (int i = 1; i < MAXN; ++i)
    primeWin[i] = (i & 1) && win[i] && isPrime[i];
  for (int i = 3; i < MAXN; ++i)
    if (primeWin[i])
      doubleWin |= primeWin << i;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);

  initialize();
  int testCase = 1;
  std::cin >> testCase;
  while (testCase--) {
    int N, cntsWin = 0, cntsDoubleWin = 0;
    std::cin >> N;
    for (int i = 1, a; i <= N; ++i) {
      std::cin >> a;
      cntsWin += win[a], cntsDoubleWin += doubleWin[a];
    }

    if ((N + 1) & 1)
      std::cout << (cntsWin ? "Alice" : "Bob");
    else {
      if (cntsWin == N)
        std::cout << ((cntsDoubleWin == 0 || cntsDoubleWin == N) ? "Bob" : "Alice");
      else 
        std::cout << (cntsWin ? "Alice" : "Bob");
    }
    std::cout << '\n';
  }

  return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/CF1991H)

**题目大意**

> 给定 $n$ 个数 $a_1\sim a_n$，每次操作可以选择 $x$，然后删除 $x$ 个数，再选择另外的 $x$ 个数，把每个数写成两个质数之和，并把两个质数加入 $a$。
>
> 两个人轮流操作，不能操作的人输，问谁必胜。
>
> 数据范围：$n,a_i\le 2\times 10^5$

**思路分析**

考虑 $a=[1,x]$，此时两个人轮流分拆 $x$，观察那些 $x$ 使得先手必胜。

如果 $x$ 为奇数，那么只能拆成 $2,x-2$，要求 $x-2$ 为质数，且 $x-2$ 先手必败。

如果 $x$ 为偶数，当 $x>4$，只能拆成两个奇质数 $p,q$。

如果 $p$ 是先手必胜的，那么后手可以删除 $q$，拆分 $p$，此时先手必败。

因此 $x$ 先手必胜当且仅当存在两个先手必败的质数 $p,q$ 满足 $p+q=x$。

回到原问题，从边界条件开始：如果 $a_1\sim a_n$ 全部是先手必败数。

那么对于每个被拆分的数 $x_1\sim x_k$，先手此时无论怎么操作都会产生至少一个先手必胜的数 $p_1\sim p_k$。

那么后手可以选择 $p_1\sim p_k$ 并分别拆分成两个先手必败态，然后删除 $q_1\sim q_k$。

此时后手有必胜策略。

那么先手的目标就是把所有先手必胜的数删除掉。

很显然先手可以拆分 $k$ 个先手必胜的数，再删除 $k$ 个其他数，如果 $n$ 为偶数，先手可以处理掉任意多个先手必胜数，如果 $n$ 为奇数，先手最多处理 $n-1$ 个先手必胜数。

最后仅剩的情况是 $n$ 个数，且全部都是先手必胜数。

此时先手不一定必败，如果存在一个数可以拆成两个先手必胜数，那么先手拆分之，就可以把同样的局面留给对手。

我们称这种数为“二阶必胜数”，二阶必胜数就是所有质数的先手必胜数的和。

如果不存在二阶必胜数，那么至少会给后手留一个先手必胜数，那么先手必败。

否则先手的目标变为删除所有二阶必胜数，同上，要求二阶必胜数的个数为 $[1,n-1]$ 之间。

如果二阶必胜数有 $n$ 个，那是否存在类似的“三阶必胜数”能拆成两个二阶必胜数之和？

很显然这是不行的，因为所有质必胜数都是奇数，所以二阶必胜数都是偶数，那么不可能拆出二阶必胜数。

所以二阶必胜数有 $n$ 个时先手必败。

我们只要求出所有先手必胜数和二阶必胜数，这是一个卷积问题，可以 NTT 或者 `std::bitset`，注意到我们求的是能否把 $x$ 分解两个质必胜 / 非必胜数的和，因此复杂度 $\mathcal O\left(\dfrac{V\pi(V)}{\omega}\right)$。

时间复杂度 $\mathcal O\left(\dfrac{V\pi(V)}{\omega}+n\right)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
bitset <MAXN> isp,f,g,o,t; //f: win, g: double win
void solve() {
	int n,cf=0,cg=0;
	cin>>n;
	for(int i=1,x;i<=n;++i) cin>>x,cf+=f[x],cg+=g[x];
	if(!cf) cout<<"Bob\n";
	else if(n%2==0||cf<n) cout<<"Alice\n";
	else if(cg==0||cg==n) cout<<"Bob\n";
	else cout<<"Alice\n";
}
signed main() {
	const int n=2e5;
	isp.set(),isp[0]=isp[1]=0;
	for(int i=2;i<=n;++i) if(isp[i]) for(int j=2*i;j<=n;j+=i) isp[j]=0;
	f[4]=1;
	for(int i=3;i<=n;i+=2) {
		if(isp[i-2]&!f[i-2]) f[i]=1;
		if(isp[i]&&!f[i]) o[i]=1;
	}
	for(int i=3;i<=n;i+=2) if(o[i]) t=o,t<<=i,f|=t;
	o.reset();
	for(int i=3;i<=n;i+=2) if(f[i]&&isp[i]) o[i]=1;
	for(int i=3;i<=n;i+=2) if(o[i]) t=o,t<<=i,g|=t;
	ios::sync_with_stdio(false);
	int T; cin>>T;
	while(T--) solve();
	return 0;
}
```

---


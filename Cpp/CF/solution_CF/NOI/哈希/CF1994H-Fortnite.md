# Fortnite

## 题目描述

这是一个交互题！

Timofey 正在编写一场名为 Capture the Flag（简称 CTF）的比赛。他还剩下最后一道题，这道题涉及到破解一个安全系统。整个系统基于多项式哈希 $^{\text{∗}}$。

Timofey 可以向系统输入一个由小写拉丁字母组成的字符串，系统会返回它的多项式哈希值。为了破解系统，Timofey 需要找出系统使用的多项式哈希参数（$p$ 和 $m$）。

Timofey 时间不多了，所以他最多只能进行 $3$ 次查询。请你帮助他完成这道题。

$^{\text{∗}}$ 一个长度为 $n$ 的小写拉丁字母字符串 $s$ 的多项式哈希值，基于 $p$ 并对 $m$ 取模，定义为 $(\mathrm{ord}(s_1) \cdot p^0 + \mathrm{ord}(s_2) \cdot p^1 + \mathrm{ord}(s_3) \cdot p^2 + \ldots + \mathrm{ord}(s_n) \cdot p^{n-1}) \bmod m$。其中 $s_i$ 表示字符串 $s$ 的第 $i$ 个字符，$\mathrm{ord}(\mathrm{chr})$ 表示字符 $\mathrm{chr}$ 在英文字母表中的序号，$x \bmod m$ 表示 $x$ 除以 $m$ 的余数。

## 说明/提示

第一次查询的答案为 $(\mathrm{ord}(a) \cdot 31^0 + \mathrm{ord}(a) \cdot 31^1) \bmod 59 = (1 + 1 \cdot 31) \bmod 59 = 32$。

第二次查询的答案为 $(\mathrm{ord}(y) \cdot 31^0 + \mathrm{ord}(b) \cdot 31^1) \bmod 59 = (25 + 2 \cdot 31) \bmod 59 = 28$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1

32

28```

### 输出

```
? aa

? yb

! 31 59```

# 题解

## 作者：Sharpsmile (赞：5)

# CF1994H Fortnite

堡垒之夜。但是我没玩过。不过这个题和堡垒之夜也没什么关系（）

每次询问你可以给出一个长度不超过 $50$ 的由小写字母构成的字符串，返回这个字符串的哈希值（即 $(\sum\limits _{i=0}p^i(s_i-asc(a)))\bmod m$），你需要在三次询问内得到 $p$ 和 $m$。保证 $26<p\leq 50,p+1<m\leq 2\times 10^9$。



巨大困难题，不过感觉很有意思。

感觉能找的题解写的有点悟性门槛太高了，看了好久，感觉都是直接给出了如何询问，不是很理解咋想的。尝试总结了一些看起来很合理的思考过程。

首先 $p$ 都不知道很难受，直接询问一个 `aa`，可以得到 $p+1$ 的值。因为 $p\in (26,50]$。我们现在知道 $p$ 了，那我们也就知道任意一个字符串再不取模情况下的哈希值 $H(t)$ 了。

然后我们需要考虑后面怎么得到一个 $m$ 出来，可以想到两种想法。

第一种就是我们找两个差是 $m$ 的东西，这个听起来不好做，我们只有两次询问机会，而我们不知道 $m$ 的情况下大概率做不了。

第二种听起来比较有前途，我们在式子里面直接弄出一个 $m$。因为我们可以得到的是取模之后的结果，这种情况想要弄到 $m$，我们可以尝试得到某个哈希值的相反数取模的结果，因为 $(-s)\bmod m=m-s$，如果我们知道 $m-s=d$，那么我们就能得到 $m=s+d$。

那么我们考虑怎么得到一个相反数，我们这里只能借助评测机对某个字符串的哈希值取模，我们无法直接得到 $(-s)\bmod m$。

注意到我们需要的形式是 $d=m-s$。更严谨的，令 $s$ 表示未取模的某个字符串的哈希值，我们应当求的是 $(-s)\bmod m=km-s=m-(s\bmod m)$，这里因为我们由评测机得到的 $s\bmod m\in [0,m)$，所以我们不妨认为 $(-s)\bmod m\in[1,m]$。容易发现这个式子在 $m|s$ 的时候，我们希望 $s=(k-1)m$。而这个 $s$ 看起来要比 $km$ 的构造更加灵活，所以我们先确定 $km$ 再确定 $s$。 

这个 $s$ 我们只要保证他是一个字符串的哈希值即可，那我们如何得到一个 $km$ ？不难发现 $p$ 和 $p\bmod m$ 在模 $m$ 意义下是同余的。~~（？）~~

所以我们找一个字符串，令他的哈希值为 $X(X>m)$，$X\bmod m=x$，显然 $X-x=km$。我们还剩下一次询问。

那我们现在根据上面的式子，我们只要 $s\in[(k-1)m,km)=[X-x-m,X-x)=((X-1)-x-m,(X-1)-x]$ 即可。注意到这个区间里有一个 $m$，这是我们不希望看到的，我们强化这个区间的限制，因为 $x\in [0,m)$ ，所以 $(X-1)-2x>(X-1)-x-m$。所以如果 $s\in [(X-1)-2x,(X-1)-x]$ 那他也符合原限制。

那我们尝试构造一个字符串 $t$ 使得 $H(t)=s$ 满足上面的限制。如果可以，那我们就有 $km-s=m-(s\bmod m)$ 也就是 $X-x-H(t)=m-(H(t)\bmod m),m=X-x-H(t)+(H(t)\bmod m)$​。

那如何构造？为了方便，令 $X'=X-1$，那我们要做的就是保证 $(X'-x)-s\in[0,x]$。

我们欲要构造这个字符串，大概率需要按位构造，而 $x$ 在 $p$ 进制下的形式因为是取模过的，大致可以看作是随机的，不大受控制（而且我们也不知道模数也没法控制）。那我们就让 $X$ 每一位都尽量的大，这样感觉上就很不。因为 $X$ 是没有取模的，我们很好控制，只要让整个串都是 `z` 即可做到 $X$ 在 $p$ 进制下每一位都是 $26$。也就是 $X'$ 除了第 $0$ 位是 $25$ 意外全都是 $26$。

我们下称 $t_i$ 为字符串 $t$ 的第 $i$ 位，$x_i,X'_i$ 表示对应数在 $p$ 进制下的第 $i$ 位。 

那我们考虑 $X'-x$ 的形式，因为需要考虑退位的情况，我们从低位向高位考虑。

当 $X'_i>x_i$ 的时候，我们直接令 $t_i=X'_i-x_i$ 即可，$(X'-x)-s$ 在这一位上没有贡献。

否则，我们从上一位退位，也就是 $X'_{i+1}\rightarrow X'_{i+1}-1$。这一位的当前的 $X’_i-x_i$ 实际上就变成了 $X'_i-x_i+p$ 。我们令 $t_i$ 为在退位之前的 $X'_i$。因为注意到，第一位是 $25$，但是不会退位，剩下的位至多退 $1$，也就是在任何情况下，$X'_i\in\{25,26\}$。这意味着首先这种情况下 $t_i$ 是合法的。在这一位上 $(X'-x)-s$ 的贡献是 $X'_i-x_i+p-X'i=p-x_i$。而此时 $X'_i\geq 25$ 所以 $x_i\geq25$，又因为 $p\leq 50$，所以 $p-x_i\leq 25$。所以在这一位的贡献上，$p-x_i\leq x_i$​！



所以我们可以构造出这样的 $t$。我们也就解决了这个题。

---

## 作者：xzCyanBrad (赞：5)

设 $a$ 为一个数，我们定义 $a_x$ 为 $a$ 的 $p$ 进制表示的从低位开始的第 $x$ 位，$x$ 从零开始标号。

算法流程为：

1. 询问 $\texttt{aa}$ 得到 $p+1$，直接拿到 $p$。

2. 询问 $\texttt{zzzzzzzzzz}$。设它的哈希值为 $X$，给的哈希值为 $x$。那么显然 $m\mid (X-x)$。如果我们能找到一个 $s$ 满足 $X-2x-1\le \text{Hash}(s)\le X-x-1$，那么显然 $\text{Hash(s)}\bmod m=m+\left(\text{Hash(s)}-X-x\right)$。因为 $-\left(\text{Hash(s)}-X-x\right)$ 太重要了，我们给他一个名字，叫做 $y$。

3. 考虑怎么找到这个 $s$。发现只需要使对应的 $y$ 在 $[1,x+1]$ 内就行了。再想想，**其实就是我们希望不让他借位所影响的数超过 $y$**。可以先让 $X$ 减一。然后第 $i$ 位考虑两种情况：

   - $x_i\le 24$：可以直接让 $X_i$ 减掉 $x_i$，不花代价。
   - $x_i>24$：考虑让 $X_{i+1}\leftarrow X_{i+1}-1$。这样的代价在这一位是 $p-x_i$。又 $p\le 50,x_i\ge 25$，所以 $x_i\ge p-x_i$，因此发现在这一步中，代价 $y_i$ 不超过 $x_i$。

   这样处理完的 $X$ 转成字符串就是 $s$。因为 $\forall i,0\le y_i\le x_i$，所以 $0\le y\le x$。注意前面还让 $X$ 减了一，故最后 $y$ 还需加一，$1\le y\le x+1$，完美满足需求！

4. 因为我们知道了 $\text{Hash}(s)\bmod m$ 和 $y$，那么根据上面的讨论，$m$ 显然等于 $y+(\text{Hash}(s)\bmod m)$。

这样，你就做出了一道 T 宝（写的假做法），蒋老师，wmh 和 rainboy 赛时都没过的题！

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/CF1994H)

**题目大意**

> 交互器里有底数 $p$ 和模数 $m$，每次可以询问字符串 $s$，得到哈希值 $h(s)=\sum c(s_i)p^i\bmod m$，其中 $c(\texttt a)=1,c(\texttt b)=2,\dots,c(\texttt z)=26$，在三次询问内求出 $p,m$。
>
> 数据范围：$26<p\le 50,p+1<m\le 2\times 10^9$。

**思路分析**

定义 $v(s)=\sum c(s_i)p^i$，即 $h(s)$ 取模前的结果。

求出 $p$ 是简单的，因为 $h(\texttt {aa})=p+1\bmod m=p+1$，因此可以直接求出 $p$。

然后我们要通过两次询问确定 $m$，一个想法是：利用 $m\mid v(s)-h(s)$ 挖掘性质，但这样显然难以做到两次询问。

那么假设 $v(s)-h(s)=km$，如果能找到一个字符串 $t$ 使得 $v(t)-h(t)=(k-1)m$，很显然能直接得到答案。

这就要求 $v(t)\in [v(s)-h(s)-m,v(s)-h(s))$，尝试把限制中的 $m$ 去掉，注意到 $m<h(s)$，因此可以钦定 $v(t)\ge v(s)-2h(s)$，依然满足条件。

转成左开右闭区间，就是 $v(t)\in(v(s)-1-2h(s),v(s)-1-h(s)]$。

我们要保证 $v(s)-1-h(s)-v(t)\in [0,h(s)]$。

把 $v(s)-1$ 和 $h(s)$ 表示成 $p$ 进制数 $a,b$，逐位构造 $v(t)$ 的 $p$ 进制表示 $c$：

- 如果 $a_i>b_i$，取 $c_i=a_i-b_i$，此时 $1\le c_i\le a_i$，且最终 $a-b-c$ 上这一位为 $0$。

- 否则向 $a_{i+1}$ 借位，取 $c_i=a_i$（借位前的），那么 $a-b-c$ 上这一位的贡献为 $p-b_i$。

  由于 $a_i$ 至多被借一位，所以 $b_i>a_{i}-1$，因此取 $a_i=26$ 时，$b_i>25>p-b_i$，所以此时 $p-b_i<b_i$。

从而每一位的贡献都小于 $b$ 在对应位的贡献。

那么 $s$ 取全 $\mathrm{z}$ 串，并且保证 $v(s)>m$ 即可。

时间复杂度 $\mathcal O(1)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int a[15],b[15],c[15],p;
int hsh(string s) {
	cout<<"? "<<s<<endl;
	int o; cin>>o; return o;
}
ll val(string s) {
	reverse(s.begin(),s.end());
	ll z=0;
	for(char o:s) z=z*p+o-'a'+1;
	return z;
}
void solve() {
	p=hsh("aa")-1;
	string X="zzzzzzzzzz";
	int x=hsh(X);
	for(int i=0,w=x;i<10;++i) a[i]=(i?26:25),b[i]=w%p,w/=p;
	string s;
	for(int i=0;i<10;++i) {
		if(a[i]>b[i]) c[i]=a[i]-b[i];
		else --a[i+1],c[i]=a[i];
		s.push_back(c[i]-1+'a');
	}
	int y=hsh(s);
	cout<<"! "<<p<<" "<<(val(X)-x)-(val(s)-y)<<endl;
}
signed main() {
	int T; cin>>T;
	while(T--) solve();
	return 0;
}
```

---


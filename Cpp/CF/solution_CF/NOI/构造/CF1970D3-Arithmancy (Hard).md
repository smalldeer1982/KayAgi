# Arithmancy (Hard)

## 题目描述

在这道问题中，不同版本的唯一区别是 $ n $ 的最大值。

Vector 教授正忙着为她的算术课准备材料。她需要准备 $ n $ 个不同的魔法词。这些魔法词是由 X 和 O 组成的字符串。一个咒语是由两个魔法词组合而成的字符串，其威力由这个咒语中所有不同非空子串的数量决定。例如，XOXO 这个咒语的威力是 7，因为它有 7 种不同的子串：X、O、XO、OX、XOX、OXO 和 XOXO。

每位学生将从这些魔法词中挑选两个，拼接在一起形成自己的咒语。由于学生们对魔法尚不熟练，这两个词是从 Vector 教授准备的 $ n $ 个词中独立随机选择的，因此有可能选择的是同一个词。然后，学生会计算他们咒语的威力，并告诉 Vector 教授。为了更出色地评价学生的工作，Vector 教授希望能够精确地辨别出学生使用了哪两个魔法词，并且知道它们的顺序。

你的任务是扮演 Vector 教授的角色：首先，生成 $ n $ 个不同的魔法词，然后根据学生给出的咒语威力，确定他们使用了哪两个魔法词及其顺序。

## 说明/提示

- $ 1 \le n \le 1000 $
- $ 1 \le q \le 1000 $
- 每个魔法词的长度在 1 到 $ 30 \cdot n $ 之间。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2


2
15

11```

### 输出

```
XOXO
X


1 1

2 1```

# 题解

## 作者：Kevin_Lsy (赞：3)

# 0x00 有感
神仙构造题，想了很久......

本题正解甚至需要打表(雾

# 0x01 思维过程
题目要求构造 $n$ 个长度 $|S|\in[1..30n]$ 的字符串，字符集为 $\set{X,O}$，满足任选出两个字符串(可以选同一个串两次)，前后拼接后所得到的新串的本质不同子串个数两两不同。

对于 D1，D2 我们可以通过较优的随机构造方式完成满足题意的 $n$ 个串的构造，对于询问使用后缀数据结构在可以在 $O(nq)$ 的时间复杂度下解决。

而 D3 中通过随机的策略在时限内完成串的构造都是不可能的，且 $O(n)$ 的线性询问回答也不足。所以要从串的构造方式与计算拼接后本质不同子串个数两方面优化，容易发现这是可以同时做到的。

考虑将 $n$ 个串用相似的一类方式来构造，方便我们推通项实现更优的查询复杂度。设 $f(i,j)$ 表示构造的串 $s_i$ 和 $s_j$ 拼接出的串的本质不同子串个数，那么只需要找到一种构造方式满足以下条件:
- 构造方式足够简单；
- $f(i,j)$ 的值容易得出通项且可以 $O(1)$ 求出；
- 满足 $f(i,j)\neq f(j,i)$。

这些条件较为严苛，经过尝试可以得到一种合法构造 $s_i=XOX^{i-1}$，即第 $i$ 个串是 $XO$ 后面跟上 $i-1$ 个 $X$。

# 0x02 实现方式
打表时间开销小，易调试，从 $i=1$ 开始，枚举 $|s_i|$ 寻找下一个满足与目前所有满足条件的串的 $f(pre,i),f(i,pre)$ 值不与之前任一重复的，成为满足条件的串之一即可。

# 0x03 code
## 1) gen
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mxlen=30000;
inline int qry(int x,int y){
	int ret=3*max(x,y)+(x+1)*y;
	ret-=(max(x,y)!=1);
	ret+=(x>=y?2+(x>1):0);
	return ret;
}
vector<int>p,his;
unordered_map<int,int>vis,f;
int main(){
	vis.clear();
	for(int len=1;len<mxlen;len++){
		his.clear(),f.clear();
		bool flg=false;
		for(int pre:p){
			his.push_back(qry(len,pre)),his.push_back(qry(pre,len));
			f[qry(len,pre)]++,f[qry(pre,len)]++;
			if(f[qry(len,pre)]>1||f[qry(pre,len)]>1)flg=1;
		}
		his.push_back(qry(len,len));
		f[qry(len,len)]++;
		if(f[qry(len,len)]>1)flg=1;
		for(int x:his){
			if(flg)break;
			if(!vis[x])continue;
			flg=true;
			break;
		}
		if(!flg){
			for(int x:his)vis[x]=1;
			p.push_back(len);
		}
	}
	for(int val:p)cout<<val<<",";
	return 0;
}
```
## 2) submitted code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,id;
int len[]={0,1,2,6,10,15,22,26,28,33,39,46,50,58,62,75,82,88,96,98,106,108,112,121,126,136,147,156,166,178,205,214,218,226,261,268,277,281,283,292,302,308,316,330,345,353,382,388,397,403,421,442,446,466,472,477,482,488,502,508,514,595,607,613,646,652,664,673,694,702,709,716,718,733,737,757,772,787,817,826,838,856,862,866,873,877,939,981,983,997,1032,1041,1049,1051,1082,1086,1093,1108,1138,1151,1153,1181,1186,1201,1233,1237,1245,1249,1282,1318,1342,1366,1370,1381,1395,1402,1447,1453,1486,1492,1537,1552,1558,1569,1577,1593,1595,1601,1603,1618,1620,1626,1646,1670,1693,1761,1776,1822,1850,1866,1873,1893,1905,1916,1933,1948,1969,2017,2026,2038,2043,2056,2061,2113,2122,2137,2161,2205,2238,2242,2246,2251,2258,2262,2266,2283,2293,2341,2347,2396,2446,2452,2458,2462,2557,2578,2593,2608,2613,2647,2673,2689,2693,2707,2711,2721,2747,2765,2777,2797,2818,2836,2853,2857,2878,2913,2917,2929,2956,2962,2968,2998,3022,3046,3061,3097,3148,3166,3183,3217,3221,3273,3312,3328,3358,3371,3373,3395,3411,3448,3466,3498,3506,3517,3532,3547,3578,3621,3637,3639,3676,3693,3697,3753,3777,3802,3830,3862,3907,3942,3946,3965,3973,3988,4006,4018,4027,4046,4126,4138,4156,4166,4177,4196,4201,4219,4258,4286,4306,4337,4357,4363,4372,4413,4425,4441,4473,4506,4546,4552,4561,4604,4621,4651,4669,4678,4701,4713,4762,4786,4801,4846,4868,4882,4933,4954,4993,5006,5011,5030,5041,5054,5077,5085,5090,5097,5101,5163,5211,5233,5240,5272,5308,5314,5316,5353,5393,5397,5403,5426,5437,5462,5482,5503,5505,5521,5573,5578,5582,5613,5646,5666,5692,5701,5721,5738,5803,5812,5861,5878,5958,5969,6007,6037,6073,6133,6158,6172,6217,6242,6276,6316,6337,6354,6361,6373,6418,6427,6451,6465,6472,6504,6584,6598,6628,6637,6652,6667,6686,6702,6772,6778,6826,6846,6865,6883,6891,6926,6982,7057,7062,7078,7113,7131,7147,7165,7186,7213,7233,7246,7258,7303,7309,7311,7417,7438,7477,7492,7502,7516,7522,7537,7541,7558,7593,7642,7646,7672,7687,7701,7753,7772,7792,7817,7821,7862,7926,7933,7988,8001,8046,8068,8101,8146,8186,8221,8242,8265,8301,8348,8388,8422,8461,8542,8563,8565,8594,8626,8654,8677,8698,8781,8818,8841,8846,8858,8862,8893,8962,9032,9058,9077,9133,9172,9181,9187,9194,9266,9276,9326,9342,9397,9430,9436,9466,9528,9538,9586,9643,9661,9668,9677,9696,9721,9753,9777,9794,9813,9817,9832,9838,9859,9886,9901,9973,10006,10033,10038,10054,10078,10102,10151,10173,10253,10312,10333,10337,10341,10357,10365,10372,10378,10453,10458,10462,10531,10558,10562,10588,10601,10606,10612,10666,10721,10732,10748,10773,10781,10798,10837,10861,10884,10957,10985,11002,11013,11057,11113,11126,11137,11177,11181,11212,11272,11278,11301,11306,11317,11378,11422,11473,11487,11497,11537,11548,11558,11578,11587,11593,11633,11642,11677,11698,11742,11806,11863,11941,11958,12088,12106,12157,12163,12202,12226,12241,12262,12301,12323,12332,12394,12396,12421,12428,12457,12526,12538,12547,12565,12601,12621,12646,12651,12658,12686,12696,12706,12757,12763,12811,12841,12884,12898,12906,12911,12916,12941,12982,13003,13027,13042,13093,13102,13126,13162,13213,13217,13228,13266,13291,13301,13308,13317,13381,13387,13401,13417,13466,13522,13614,13626,13681,13722,13742,13798,13828,13878,13882,13917,13921,13927,13933,13993,13997,14054,14086,14107,14128,14163,14206,14217,14235,14242,14253,14386,14422,14437,14451,14505,14523,14542,14548,14556,14593,14666,14683,14692,14698,14737,14758,14803,14821,14843,14856,14866,14897,14901,14907,14918,14969,14997,15013,15101,15145,15177,15218,15232,15241,15277,15307,15338,15361,15396,15426,15607,15628,15646,15667,15682,15716,15733,15766,15797,15802,15901,15922,15969,15997,16011,16033,16052,16074,16102,16117,16186,16219,16227,16276,16322,16333,16342,16363,16381,16402,16404,16417,16462,16504,16526,16545,16552,16573,16581,16593,16618,16633,16657,16706,16725,16738,16742,16763,16786,16889,16936,16963,16971,17011,17026,17032,17041,17047,17053,17077,17161,17218,17246,17282,17293,17326,17348,17377,17386,17428,17449,17481,17553,17557,17565,17581,17606,17782,17826,17851,17858,17881,17902,17938,17960,17971,17998,18013,18026,18058,18067,18076,18082,18086,18091,18097,18133,18181,18205,18217,18236,18253,18273,18293,18301,18307,18313,18341,18397,18412,18442,18454,18456,18481,18520,18586,18604,18636,18673,18691,18697,18701,18712,18741,18749,18838,18883,18916,18918,18946,18958,19036,19042,19101,19217,19237,19258,19267,19298,19378,19420,19454,19477,19497,19538,19582,19707,19713,19813,19857,19861,19867,19882,19888,19934,19972,20122,20143,20182,20281,20323,20353,20362,20386,20388,20395,20441,20476,20494,20533,20542,20606,20611,20641,20662,20765,20788,20806,20814,20857,20897,20913,20947,20962,20973,21001,21038,21043,21056,21058,21066,21166,21187,21193,21206,21277,21313,21326,21366,21382,21387,21417,21445,21477,21523,21577,21612,21651,21661,21765,21772,21796,21806,21817,21848,21884,21890,21907,21928,21985,21991,22012,22093,22118,22123,22292,22342,22394,22452,22480,22501,22573,22621,22641,22731,22738,22766,22768,22786,22797,22821,22942,22965,22972,23038,23053,23081,23203,23227,23234,23313,23333,23371,23444,23467,23473,23487,23514,23537,23547,23557,23566,23568,23593,23602,23626,23662,23677,23691,23742,23747,23756,23773,23818,23846,23852,23857,23878,23898,24014,24021,24028,24043,24056,24068,24082,24091,24097,24171,24202,24225,24238,24267,24280,24355,24421,24468,24537,24571,24657,24746,24781,24801,24817,24907,24931,24952,25005,25033,25088,25147,25153,25218,25237,25306,25341,25348,25457,25502,25523,25540,25561,25582,25587,25618,25637,25642,25656};
inline int ans(int x,int y){
	int ret=3*max(x,y)+(x+1)*y;
	ret-=(max(x,y)!=1);
	ret+=(x>=y?2+(x>1):0);
	return ret;
}
map<int,pair<int,int> >mp;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		string a(1,'X'),b(1,'O'),c(len[i]-1,'X');
		printf("%s\n",(a+b+c).c_str());
		fflush(stdout);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			mp[ans(len[i],len[j])]=make_pair(i,j);
		}
	}
	scanf("%d",&q);
	while(q--){
		scanf("%d",&id);
		printf("%d %d\n",mp[id].first,mp[id].second);
		fflush(stdout);
	}
	return 0;
}
```

---

## 作者：lgx57 (赞：2)

写了一个不需要打表的程序，以 $9843 \operatorname{ms}$ 获得了全球最劣解。

记号说明：

1. $f(i,j)$ 为第 $i$ 个与第 $j$ 个字符串拼接后的本质不同的子串个数。

D1 只需要随便打几个字符串就可以了。但 D2 就无法像这样直接随机。经过我的尝试，我的程序最多只能随机出 $n=25$ 的解。这引导我们去想更好的随机方式。

容易发现，我们如果每一次随机都重新计算 $n$ 个字符串，速度会很慢。于是我们可以考虑递推。每一次先构造好前面的字符串，再随机当前的字符串，直到当前字符串与前面的字符串的 $f$，与前面都不同。

但是即使这样，直接随机字符串依然很困难，这主要体现在 $2$ 个方面：

1. 每一次计算 $f$ 的速度比较慢（$O(n \log n)$）。

2. 字符串的格式不确定，随机状态非常多。

这 $2$ 点都启发我们找到一个固定的字符串的格式，使得 $f$ 的计算也很方便。

当 $\text{X}$ 和 $\text{O}$ 都很多的时候，$f$ 显然不方便计算，于是我们可以考虑比较极端的构造，例如全部都是 $\text{X}$ 或全部都是 $\text{O}$。但是显然不满足条件。于是我们可以只改一个字符，从而使字符串都是形如 $\text{XO}$ 后面跟上一堆 $\text{X}$。

对于这种字符串，我们容易检验 $n$ 比较小的时候是可以递推的，于是大胆猜测 $n=1000$ 时递推不会错。

现在只要处理的问题就是：如何快速计算 $f$？

可以通过尝试小的例子来找出规律:

设第 $i$ 个字符串的长度为 $x$，第 $j$ 个字符串的长度为 $y$。那么：

$$f(i,j)=\begin{cases} x(y+2)-1 & x \ge y \\ (x+3)(y-1)-1 & \text{otherwise} \end{cases}$$

然后代码的实现是非常简单的。我们使用一个 map 来存储答案，每一次递推求答案的时候新开一个 map 来判断当前这个字符串放进答案中是否可行。如果可行，就把这个字符串与前面字符串的 $f$ 值存到答案里，否则就尝试更长的字符串。

最后的询问只要输出 map 里储存的两个字符串的编号即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fi first
#define se second
#define pii pair<int,int>
#define endl '\n'
#define pb push_back
#define ls(p) ((p)<<1)
#define rs(p) ((p)<<1|1)
#define lowbit(x) ((x)&(-(x)))
#define abs(x) ((x)>0?(x):(-(x))
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define gc getchar
#define pc putchar
#define sz(v) ((int)(v.size()))
using namespace std;
mt19937_64 Rand(chrono::steady_clock::now().time_since_epoch().count());
inline int read(){
	int x=0,f=1;
	char ch=gc();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=gc();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=gc();}
	return x*f;
}
inline void print(int x){
	if (x<0) pc('-'),x*=-1;
	if (x<10) pc(x+'0');
    else print(x/10),pc(x%10+'0');
}
int work(int x,int y){// f 函数
	return x>=y?x*(y+2)-1:(x+3)*(y-1)-1;
}
int n;
unordered_map<int,pii> ans;
unordered_map<int,bool> mp;
const int N=1005;
int b[N];// b_i=len(a_i)
string a[N];
void init(){
	int now=1;
	for (int i=1;i<=n;i++){
		bool f=1;
		do{
			now++;//增加长度
			f=1;
			mp.clear();
			int cnt=work(now,now);
			if (ans.count(cnt)){
				f=0;
				continue;
			}
			mp[cnt]=1;
			for (int _=1;_<i;_++){
				cnt=work(b[_],now);
				if (ans.count(cnt)||mp.count(cnt)){
					f=0;
					continue;
				}
				mp[cnt]=1;
				cnt=work(now,b[_]);
				if (ans.count(cnt)||mp.count(cnt)){
					f=0;
					continue;
				}
				mp[cnt]=1;
			}
			if (f){// 如果可以，把当前字符串与前面的字符串的 f 值放进 ans 中
				ans[work(now,now)]={i,i};
				for (int _=1;_<i;_++){
					ans[work(b[_],now)]={_,i};
					ans[work(now,b[_])]={i,_};
				}
			}
		}while (!f);
		a[i]="XO";
		for (int _=1;_<=now-2;_++) a[i]+='X';//存储答案
		b[i]=now;
	}
}
void sol(){
	for (int i=1;i<=n;i++) cout<<a[i]<<endl;
	int q;
	cin>>q;
	while (q--){
		int x;
		cin>>x;
		cout<<ans[x].fi<<' '<<ans[x].se<<endl;
	} 
}
signed main(){
	cin>>n;
	init();
	sol();
	return 0;
}
```

**温馨提示：如果你 TLE on #15，请不要使用 map，改成 unordered_map。**

---

## 作者：EXODUS (赞：1)

# Part 1：前言

本场唯一一个看题解才会做的题。

# Part 2：正文

题目要做的事情是让所有字符串拼接后得到的串本质不同子串数两两不同。先来看 D2。我们可以感知到字符串两两拼接后本质不同子串数两两不同这个限制是难以构造的，所以考虑随机化后 check。我们随机一些长度不均等的字符串，将其两两拼接后检查得到的字符串本质不同子串数是否两两不同，若不满足则重新随机。检查的方式可以暴力实现，也可以后缀数组。这样做即可通过 D2。

最后来看看 D3。注意到随机化很难通过 $n=50$，所以现在我们需要确定构造。思路是，我们需要有一个字符串集合 $S$，这里面任意两个字符串以任意顺序拼接后得到的字符串的本质不同子串数我们可以快速计算。然后我们就可以按照长度从小到大尝试添加字符串，如果其与已添加的字符串拼接后不会产生本质不同子串数相同的字符串，就将其添加到答案集合中，直到答案集合大小为 $n$。经过一些尝试后我们发现字符串集 $S_i=\texttt{XOXX...X}$ 是符合题意的，其中第 $i$ 个字符串末尾 $\texttt{X}$ 的长度为 $n-1$。代价计算函数可以看下文代码。

# Part 3：代码

由于我对可以添加的字符串进行了打表，所以完整代码参见 CF 提交记录。

[Submission #262003572 - Codeforces](https://codeforces.com/contest/1970/submission/262003572)

```cpp
// Cause all that I trust
// 曾相信的一切
// Had crumbled to dust
// 早已土崩瓦解
// But finally I can breathe
// 而放下终得畅然
// Open my eyes and see
// 睁开双眼
// All of the beauty in front of me
// 可见瑰丽美景
// Giving back all the energy that
// 心无旁骛
// I never felt, I never felt before
// 尽可欣然徜徉
// Beyond the lights of society
// 灯红酒绿 逢场作戏
// That were killing me quietly
// 纯真之心 日渐麻痹
// Now I found myself, I found myself a home
// 如今我已找回自我 心有所向
// Out on my own
// 全凭一己之力
    
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;

#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define eb emplace_back
#define File(filename) freopen(filename ".in","r",stdin),freopen(filename ".out","w",stdout)
#define Exit(p) fprintf(stderr,"[exit]: at breakpoint %d\n",p),exit(0);

#ifdef EXODUS
	#define Debug(...) fprintf(stderr,__VA_ARGS__)
#else
	#define Debug(...) 0
#endif

//=========================================================================================================
// Something about IO

template<typename T>
void read(T &x){
	x=0;T flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flg;
}
template<typename T>
void seq_read(T bg,T ed){for(auto i=bg;i!=ed;++i)read(*i);}
template<typename T,typename... Args>
void read(T &x,Args &...args){read(x),read(args...);}

//=========================================================================================================
//Some useful function

template<typename T>
void cmax(T& x,T y){x=max(x,y);}
template<typename T,typename... Args>
void cmax(T& x,T y,Args ...args){cmax(x,y);cmax(x,args...);}
template<typename T>
void cmin(T& x,T y){x=min(x,y);}
template<typename T,typename... Args>
void cmin(T& x,T y,Args ...args){cmin(x,y);cmin(x,args...);}
template<typename T,typename U>
void seq_assign(T bg,T ed,U val){for(auto i=bg;i!=ed;++i)(*i)=val;}
template<typename T,class F,class=enable_if_t<is_invocable_v<F>>>
void seq_assign(T bg,T ed,F func){for(auto i=bg;i!=ed;++i)(*i)=func(i);}
template<typename T>
void seq_copy(T dstbg,T dsted,T srcbg,T srced){for(auto i=dstbg,j=srcbg;i!=dsted&&j!=srced;++i,++j)(*i)=(*j);}

//=========================================================================================================
// Define the global variables here.

bool membg=0;

int len[]={};


bool memed=0;

//=========================================================================================================
// Code here.

int calc(int x,int y){
	return max(x,y)*3-(max(x,y)!=1)+(x+1)*y+(x>=y?2+(x>1):0);
}

void solve(){
	int n;
	read(n);
	for(int i=1;i<=n;i++){
		string a(1,'X'),b(1,'O'),c(len[i]-1,'X');
		printf("%s\n",(a+b+c).c_str());
	}
	fflush(stdout);
	map<int,pair<int,int>>ans;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			ans[calc(len[i],len[j])]={i,j};
			
	int Q;
	read(Q);
	for(int i=1;i<=Q;i++){
		int v;
		read(v);
		printf("%d %d\n",ans[v].first,ans[v].second);
		fflush(stdout);
	}
	return;
}


//=========================================================================================================

int main(){
	Debug("%.3lfMB\n",fabs(&memed-&membg)/1024.0/1024.0);
	int timbg=clock();
	int T=1;
	while(T--)solve();
	int timed=clock();
	Debug("%.3lfs\n",1.0*(timed-timbg)/CLOCKS_PER_SEC);
	fflush(stdout);
	return 0;
}
```

---


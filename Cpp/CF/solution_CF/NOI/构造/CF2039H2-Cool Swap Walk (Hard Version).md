# Cool Swap Walk (Hard Version)

## 题目描述

# Cool Swap Walk (Easy Version)


给你一个大小为 $ n $ 的数组 $ a $ 。

下面是一个很酷的交换行走过程：

- 你需要从 $(1,1) $ 走到 $(n,n) $ ，只需向右或向下走一步。
- 从形式上看，如果当前位于 $ (x,y) $，则可以走到 $ (x+1,y) $ 或 $ (x,y+1) $，但不能越过网格边界。
- 当你步进 $ (i,j) $ 时，必须在 $ i\neq j $ 时交换 $ a_i $ 和 $ a_j $。

你最多可以进行 $ n+4 $ 次酷交换行走。将数组 $ a_1, a_2, \ldots, a_n $ 按非递减顺序排序。数据保证成立。

## 说明/提示

样例一中，数组 $ a $ 已经是非递减的，所以不需要再走一遍。

样例二中，$ a=[2,1,3] $ 最初是递减的。

在第一次行走中

- 然后，$ a=[1,2,3] $ 注意，虽然数组 $ a $ 已经是非递减的，但在到达 $ (n,n) $ 之前不能停止。
- 在第 $ 2 $ 步中，你向右走到 $ (1,3) $ . 然后，$ a=[3,2,1] $ .
- 在第 $ 3 $ 步中，向下移动到 $ (2,3) $ . 然后，$ a=[3,1,2] $ .
- 在第 $ 4 $ 步中，你下到 $ (3,3) $ . 然后，$ a=[3,1,2] $ .

在第二次行走中

- 在第 $ 1 $ 步中，你下到 $ (2,1) $ . 然后，$ a=[1,3,2] $ .
- 在第 $ 2 $ 步中，向右走到 $ (2,2) $ . 然后，$ a=[1,3,2] $ .
- 在第 $ 4 $ 步中，向下移动到 $ (3,2) $ . 然后，$ a=[1,2,3] $ .
- 在第 $ 4 $ 步中，你下到 $ (3,3) $ . 然后，$ a=[1,2,3] $ .

经过上述两次酷交换行走，我们得到 $ a=[1,2,3] $ ，它是不递减的。

## 样例 #1

### 输入

```
3
2
1 2
3
2 1 3
4
3 2 3 4```

### 输出

```
0
2
RRDD
DRDR
3
RRDRDD
DRDDRR
DDRRRD```

# 题解

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/CF2039H2)

**题目大意**

> 给定一个 $1\sim n$ 排列 $p$，定义一次操作为选择一条 $(1,1)\to (n,n)$ 的格路，对于经过的每个点 $(i,j)$，依次交换 $p_i,p_j$，构造一种在 $n+4$ 次操作内还原该序列的方法。
>
> 数据范围：$n\le 500$。

**思路分析**

首先这条格路的形态不固定时很难刻画，为了简化操作，我们肯定想让这条格路尽可能在主对角线上移动。

此时从 $(x,x)$ 出发，如果向右再向下，相当于交换 $a_x,a_{x+1}$，如果向右两步再向下两步，相当于翻转 $a[x,x+2]$。

观察发现这个过程中的 $a_x$ 一直是原来的 $a_1$，因此我们一定会把 $a_1$ 放到序列的末尾。

忽略 $a_1$ 的影响，那么我们能做的实际上是选择若干不想交的 $[i,i+1]$ 并交换 $a_i,a_{i+1}$。

这就是奇偶排序的过程，因此我们可以在 $n+\mathcal O(1)$ 的步数内还原排列。

现在还要考虑上循环移位的问题，不妨钦定操作 $n+4$ 轮，我们只要让最终的序列变成 $[n-3,n-2,n-1,n,1,2,\dots,n-4]$ 即可。

暴力模拟奇偶排序的过程。

事实上由于我们的操作不能选择 $i=1$，因此这个奇偶排序的实际花费可能超过 $n+\mathcal O(1)$ 的界，但在本题数据下足以通过。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=505;
int n,a[MAXN],id[MAXN],b[MAXN];
void solve() {
	cin>>n;
	for(int i=0;i<n;++i) cin>>a[i],id[i]=i;
	if(n==2) return cout<<(a[0]<=a[1]?"0\n":"1\nRD\n"),void();
	sort(id,id+n,[&](int x,int y){ return a[x]<a[y]; });
	for(int i=0;i<n;++i) a[id[i]]=((i+4)%n+n)%n;
	cout<<n+4<<"\n";
	for(int i=0;i<n+4;++i) {
		for(int j=2;j<n;j+=2) {
			int x=(i+j-1)%n,y=(i+j)%n;
			if(y&&a[x]>a[y]) swap(a[x],a[y]),cout<<"RRDD";
			else cout<<"RDRD";
		}
		cout<<(n&1?"\n":"RD\n");
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int _; cin>>_;
	while(_--) solve();
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

我们只进行一下两种操作：

- `RD` 这时 $(a_x,a_{x+1})$ 会变成 $(a_{x+1},a_x)$。
- `RRDD` 这时 $(a_x,a_{x+1},a_{x+2})$ 会变成 $(a_{x+2},a_{x+1},a_x)$。

我们用以上两种操作组成串之后，不难发现每次 $a_1$ 都会被挪到最后面。然后观察发现其余元素要么是不变，要么是交换。其中一次 Walk 操作交换的元素不能重叠。

容易想到奇偶排序。每次奇偶排序完之后把 $1$ 挪回来就能做到 $2n$ 次操作。

考虑优化。不难发现把 $a_1$ 挪到最后面相当于循环移位。枚举操作次数 $x$。那么在没有交换的时候，第 $i$ 个元素进行 $x$ 次操作后会变到在 $c_i=(i-x)\bmod n$ 上。

第 $i$ 次操作相当于 $i$ 不能移动，其余环上元素能配对移动。对这个环按照 $c_i$ 为判断标准奇偶排序即可。

这个做法能做到 $n$ 次。

---

## 作者：xuanxuan001 (赞：0)

时隔数天来搬运个题解，为什么这题的标签上每个都贴了两遍啊，是出 bug 了吗，试了下别的题也不能放重复的，我给去掉了，但那三个 constructive algorithm 就留着了，挺合适的。

感觉这题的 H1 和 H2 并没有很明显的递进关系，像是一道题的两个做法然后发现其中一个做出来比另一个优。[之后的这场的 G](https://codeforces.com/contest/2034/problem/G2)更是这样，并且甚至由 G1 规约到 G2 的过程都不是那么显然，至少不是看完题面就能发现的那种~~甚至有个人场上过 G2 没过 G1~~。

首先有这么几种操作（设初始序列为 $a_1,a_2,\cdots,a_n$）：

1. 先向左一直走再向下一直走，手模容易发现会变为 $a_n,a_{n-1},a_1,a_2,\cdots,a_{n-3}$。
1. 由一些``RD``和``RRDD``拼接而成。发现如果现在在 $(x,x)$，那么``RD``就是交换 $a_x,a_{x+1}$，``RRDD``就是交换 $a_x,a_{x+2}$。那么这些交换组合在一起其实就是将 $a_1$ 移到最后，其他的可以选择若干对相邻数交换，每个数只能在至多一对里面。
1. 依次经过 $(1,p_1),(2,p_2),(3,p_3),\cdots,(k,p_k)$，每次都是先向右再向下连接，其中 $p$ 单调递增，$p_1 > 1$。手模一下，发现会变成 $(a_{p_1},a_{p_2},\cdots,a_{p_k},\cdots)$，后面的省略号表示顺序不确定。

然后考虑解题，引入一种对 $a$ 排序的方式，就是每一轮交替进行如下操作：

1. 如果 $a_{2i - 1} > a_{2i}$，交换它们。
2. 如果 $a_{2i} > a_{2i + 1}$，交换它们。

不管先进行哪类操作，都会在至多 $n$ 步内排序完成，不难发现这其实就是上面说的 2 操作可以实现的功能。

G1 就是考虑每次搞一遍 2 操作再用 1 操作给调到最后面的 $a_1$ 挪回来，同时记住现在 $2 \rightarrow n$ 被转成啥样差不多就行。

写这篇题解的时候突然想到可能可以两次 2 操作搞一次 1 操作做到 $\dfrac 32n + O(1)$，但没啥用。

那么发现这样操作很浪费的样子，考虑能不能更好地利用这个把第一个往回扔的特性而不是尝试弥补它。

下面先假设 $n = 2k$，并不妨设 $a$ 是个排列，不难发现这样不会比有重复数的情况简单。假设现在前 $k$ 个数是 $1$ 到 $k$，后 $k$ 个数是 $k+1$ 到 $n$。那么可以用 $k$ 次 2 操作排好后 $k$ 个大数，同时会让它们跑到前面而前 $k$ 个小数跑到后面，然后再重复一遍刚好就可以用 $n$ 次排好序。

同时给两遍排序可能可以，但被切开的那边会有一个在第一个的数不能参与交换，而且需要满足位移是整的，感觉不能降低最坏次数。

而让小数在前 $k$ 个是容易的，这是操作 3 干的事。但这之前需要先用一次操作找一个大数扔到第一个，否则不满足操作 3 的条件。

然后考虑 $n=2k+1$ 的情况，此时可以将小于等于 $k+1$ 的都认为是小数，然后在分大小数的时候就让 $1$ 排在第一个，这样后面小数也只需要 $k$ 次操作即可完成排序。

具体是这样：

1. 用一个 3 操作将 $1$ 提到第一个。
1. 用一个 2 操作将 $1$ 扔到最后一个，同时注意不要让 $n$ 成为第一个，判断一下前面用``RDRD``还是``RRDD``即可。
1. 用一个 3 操作把 $n$ 提到第一个，$1$ 提到第二个。
1. 用一个 3 操作把小数放到前面 $\lceil \dfrac n2 \rceil$ 个位置，此时 $1$ 一定是第一个。
1. 进行 $n$ 次操作 2，刚好轮换回来，同时排好序。

刚好是 $n+4$ 次操作，[代码](https://codeforces.com/contest/2039/submission/293836671)。

---


# Buggy DFS

## 题目描述

你正在学习一种名为深度优先搜索（DFS）的图遍历算法。然而，由于一个小错误，你的算法与标准版本略有区别。以下是你实现的有误深度优先搜索（BDFS）算法，假设图中有 $N$ 个节点（编号从 $1$ 到 $N$）。

```
BDFS():
  令 S 为一个空栈
  令 FLAG 为大小为 N 的布尔数组，初始值均为 false
  令 counter 为一个整数，初始化为 0

  将 1 压入栈 S

  当 S 不为空时：
    弹出 S 的栈顶元素到 u
    FLAG[u] = true

    对于 u 的每个邻居 v（按升序访问）：
      counter = counter + 1
      如果 FLAG[v] 为 false：
        将 v 压入栈 S

  返回 counter
```

你发现这个错误让算法比标准的 DFS 慢。通过查看函数 BDFS() 的返回值可以探究这个问题。为了更好地研究算法的行为，你打算构造一些无向简单图，让函数 BDFS() 的返回值等于 $K$，或者确定这样的图是否存在。

## 样例 #1

### 输入

```
8```

### 输出

```
3 3
1 2
1 3
2 3```

## 样例 #2

### 输入

```
1```

### 输出

```
-1 -1```

## 样例 #3

### 输入

```
23```

### 输出

```
5 7
4 5
2 3
3 1
2 4
4 3
2 1
1 5```

# 题解

## 作者：Sio_ (赞：1)

感觉不是很难。

先考虑构造一个方案使得 $k$ 极大。

我先想到了一种错误的做法。$1,2$ 和 $3$ 到 $n$ 所有点连边。因为在我到 $n$ 后，点 $2$ 会位于栈顶，那接下来就没办法用点 $2$ 来刷贡献。     
考虑对于 $3$ 到 $n$ 之间相邻的点连边，此时你就构造出了 $k$ 和 $n^2$ 同级别的构造方案。     
但是这个构造 $m=3n-7$，发现点 $1$ 和 $3$ 到 $n-1$ 的边都没有用，可以删掉，此时边数合法，容易发现这样的结构 $k=(n-2)^2+3(n-2)$。       

如何构造出恰好为 $k$ 的解的方案？发现将很多个相同的结构都用点 $1$ 连起来，这些结构的答案可以直接累加。

最后这样的结构 $k$ 只能为偶数，我们需要构造一组答案为奇数的最小的解，手模一下可以得出

```
1 2
2 3
3 1
2 4
```
的答案为 11。

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n=1;
int main()
{
    vector<pair<int,int>> ans;
    cin>>k;
    if(k%2==1&&k<=9){cout<<-1<<" "<<-1<<'\n';return 0;}
    if(k%2==1)
    {
        ans.push_back({1,2});
        ans.push_back({2,3});
        ans.push_back({1,3});
        ans.push_back({2,4});
        k-=11;
        n=4;
    }
    for(int i=(1<<15);i>=3;i--)
    {
        int x=(i-2)*(i-2)+3*(i-2);
        if(k<x) continue;
        k-=x;
        for(int k=n+2;k<=n+i-1;k++)
        {
            if(k!=n+2) ans.push_back({k-1,k});
            ans.push_back({k,n+1});
        }
        ans.push_back({1,n+i-1});
        n+=i-1;
        i++;
    }
    while(k>0) ans.push_back({1,n+1}),n++,k-=2;
    cout<<n<<" "<<ans.size()<<"\n";
    for(auto [x,y]:ans) cout<<x<<" "<<y<<"\n";
}
```

---

## 作者：int08 (赞：0)

## 前言
相当有趣的构造题。

现 CF 最短解（$554$ B）。

# Solution
第一反应是去找一些 `BDFS` 的性质，似乎不太成功。

于是我们先手写一个 `BDFS` 并搞一些图来手玩。

先试试完全图吧！

发现完全图非常不牛，边数开满了都达不到 $10^9$。

是不是高于这个值的时候根本无解？非也。

考虑每个点对答案的贡献：把 `vis` 数组变成统计入栈次数的，发现答案就是 $\sum deg_i\times vis_i$。

输出一下 $vis$ 发现 $vis_1=1,vis_i=n+1-i(2\le i\le n)$，则答案来到 $O(n^3)$ 级别。

我们运用 $O(n^2)$ 条边才使得答案变成 $O(n^3)$，效率极低啊！

所以我们需要争取用 $O(n)$ 条边就让一个点的 $vis$ 和度数都达到 $n-1$。

发现完全图框架很好：点的遍历顺序是 $1,n,n-1,n-2,\dots,2$，这主要是由于 $(1,n)\cup\{(i,i+1),2\le i<n\}$ 这些边的存在。

如果在这个基础上增加 $(u,v),2\le u<v-1< n$，一定会让 $u,v$ 度数加一且 $vis_u$ 加一。

于是有一个比较优秀的方案：保留上述框架的基础上让所有点向 $2$ 连边，这样 $deg_2$ 和 $vis_2$ 都来到了约 $n$，我们用约 $2n$ 条边把答案变成了约 $n^2$，总算有了正确的量级，在这个基础上加以调整或许就可以得到正确的答案。

调整有两种方式：$1$ 连上一个新点答案可以加 $2$，$(1,n-1)$ 可以让答案加 $5$（只用于奇偶性调整），但是这两种还是太慢了。

考虑如下方式：先用 $O(n)$ 条边让答案还剩 $O(n)$，接着用 $O(\sqrt n)$ 条边继续让剩下部分来到 $O(\sqrt n)$ 量级……多做几次直到还差 $O(1)$ 的时候使用上述调整方式。

### 关于实现细节
首先，无解条件是 $k\le 9$ 且 $k$ 为奇数，较小值（$k\le 8$）建议直接特判。

然后为了避免其他小数据的细节，$k\le 32700\times 2$ 时候直接造一条链用上述调整搞定，否则先把上文所提到的框架搞好。

同时，不向 $2$ 而是向 $3$ 连边，理由是 $3$ 度数为 $2$，而等会第二次用 $O(\sqrt n)$ 条边的时候连向的点度数也会为 $2$。

然后观察发现向某个点第 $i$ 次连边的时候答案增加 $2i+3$，直接做就行。

剩下的细节看代码吧。

## AC Code
注意：实际上我使用了一些无意义手段去掉了特判部分以获得最短解（~~不过似乎去掉之前就是最短解了~~）。


```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n,i,j;
vector<pair<int,int> > ed;
int main()
{
	cin>>k;
	if(k==2)
	{
		cout<<"2 1\n1 2";return 0;
	}
	if(k==4)
	{
		cout<<"3 2\n1 2\n1 3";return 0;
	}
	if(k==6)
	{
		cout<<"4 3\n1 2\n2 3\n3 4";return 0;
	}
	if(k==8)
	{
		cout<<"3 3\n1 2\n2 3\n3 1";return 0;
	}
	if(k<=9)
	{
		cout<<"-1 -1";return 0;
	}
	n=min(k/2-1,32700);
	k-=n*2-2;int cnt=2;
	for(i=2;i<n;i++) ed.push_back({i,i+1});
	ed.push_back({1,n});
	while(k>100)
	{
		int now=++cnt,pnt=5;cnt++;
		while(k-pnt>20) k-=pnt,pnt+=2,ed.push_back({now,++cnt});
	}
	if(k&1) ed.push_back({1,n-1}),k-=5;
	while(k) k-=2,ed.push_back({1,++n});
	cout<<n<<" "<<ed.size()<<"\n";
	for(auto x:ed) cout<<x.first<<" "<<x.second<<"\n";
}
```
# The End.

---


# Kevin and Puzzle (Easy Version)

## 题目描述

这是问题的简单版本。在这个版本中，你需要找到任意一个符合条件的数组。只有在解决了所有版本的问题后，你才可以进行 hack。

Kevin 在红教堂参观时，墙上发现一个谜题。

对于一个数组 $a$，定义 $c(l, r)$ 表示在 $a_l, a_{l+1}, \ldots, a_r$ 之间不同数字的数量。特别地，当 $l > r$ 时，定义 $c(l, r) = 0$。

给定一个长度为 $n$ 的字符串 $s$，字符串中仅包含字母 $\texttt{L}$ 和 $\texttt{R}$。若一个非负整数数组 $a$ 满足以下条件，则称其为“好”数组：

- 如果 $s_i=\verb!L!$，则 $c(1, i-1)=a_i$；
- 如果 $s_i=\verb!R!$，则 $c(i+1, n)=a_i$。

如果存在这样的“好”数组 $a$，请输出任意一个符合要求的数组。否则，输出 -1 表示不存在。

## 说明/提示

在第一个测试用例中，数组 $[0, 1, 0]$ 满足条件，因为：

- 当 $i=1$ 时，$s_i=\verb!L!$，此时 $c(1, 0)=0$；
- 当 $i=2$ 时，$s_i=\verb!L!$，此时 $c(1, 1)=1$，因为 $a_1$ 中只有一个不同的数字；
- 当 $i=3$ 时，$s_i=\verb!R!$，此时 $c(4, 3)=0$。

在第二个测试用例中，数组 $[1, 1, 1]$ 也是一个有效答案。

在第三个测试用例中，可以证明不存在满足条件的数组。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
3
LLR
3
RRL
4
RRLR
5
LLRLR```

### 输出

```
0 1 0
2 1 2
-1
0 1 2 3 0```

# 题解

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/CF2048I1)

**题目大意**

> 给定长度为 $n$ 的串 $s_i$，构造 $a_1\sim a_n$ 使得 $s_i=L$ 时 $a[1,i-1]$ 的颜色数 $=a_i$，$s_i=R$ 时 $a[i+1,n]$ 的颜色数 $=a_{i}$。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

从一些简易的情形入手，如果 $s_1=L$，则 $a_1=0$，如果 $s_n=R$，那么 $a_n=0$。

因此可以分讨 $(s_1,s_n)$ 的情况：

- $(s_1,s_n)=(L,R)$：那么 $a_1=a_n=0$，且 $a_{2\sim n-1}$ 中没有 $0$，因此可以看成给 $a_{2\sim n-1}$ 直接 $+1$。
- $(s_1,s_n)=(L,L)/(R,R)$：不妨设 $s_1=L$，则 $a_1=0$，设 $a_n=x$，那么构造的时候 $a[2,n-1]$ 必须包含 $1\sim x-1$ 的所有数。
- $(s_1,s_n)=(R,L)$：很显然 $a$ 中没有 $0$，一种可能的构造是所有 $a_i=1$。

分析上述条件，导出矛盾当且仅当 $(s_1,s_n)=(L,L)$，然后 $s_{2\sim n-1}$ 中出现了一对 $(R,L)$，此时不能保证 $1\sim x-1$ 的所有数都出现过。

否则直接按照上述过程递归构造即可。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int n,a[MAXN],ok;
char s[MAXN];
int dfs(int l,int r,int d,int x) {
	if(l>r) return 0;
	if(l==r) return a[l]=x;
	if(s[l]==s[r]) {
		a[l]=x,a[r]=max(x,dfs(l+1,r-1,1,x+1))+1;
		if(s[r]=='R') swap(a[l],a[r]);
		return max(a[l],a[r]);
	}
	if(s[l]=='L') return a[l]=a[r]=x,max(x,dfs(l+1,r-1,d,x+1));
	ok&=d!=1,fill(a+l,a+r+1,x+1);
	return x+1;
}
void solve() {
	cin>>n,ok=1;
	for(int i=1;i<=n;++i) cin>>s[i],a[i]=0;
	dfs(1,n,-1,0);
	if(!ok) cout<<"-1\n";
	else for(int i=1;i<=n;++i) cout<<a[i]<<" \n"[i==n];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int _; cin>>_;
	while(_--) solve();
	return 0;
}
```

---

## 作者：Little09 (赞：0)

引理：假设最后填出来最大值是 $mx$，不同的数的个数是 $c$，记 $d=c-mx$。那么 $d=0$ 或 $d=1$。

证明：首先显然有 $c\le mx+1$。假设 $c<mx$，观察填 $mx$ 的位置则容易发现矛盾。

考虑序列 $s$ 中最左边和最右边的字符是什么：

- 如果分别是 L 和 R，可以发现这两个位置的数一定都是 $0$，而除了这两个位置一定不能填 $0$。对于内部的位置，无论是 L 还是 R，都会将 $0$ 统计为一种不同的数字。因此我们可以删去这两个位置，对里面递归做，在完成后给里面的所有数字 $+1$，并在前后各加入一个 $0$。
- 如果分别是 L 和 L，首先左边的 L 一定是 $0$，假设右边的 L 写的是 $x$，容易证明里面的位置不可能填 $x$。对于内部的位置，无论是 L 还是 R，都会将 $0$ 或 $x$ 统计为一种不同的数字。 所以和上一种情况类似地，还是删去两端后递归做，然后给里面的数都 $+1$ 再填上 $0$ 和 $x$。需要满足 $x$ 的值是里面的不同数的个数 $+1$。此时要求 $x$ 在内部不能出现过，根据引理可以发现这个条件等价于，内部整个区间满足 $d=1$。
- 如果分别是 R 和 R，跟上一种情况相同。
- 如果分别是 R 和 L，可以得到一种简单的构造是全填 $1$。同时我们发现，在这种情况下，无论填什么数字都不会出现 $0$，因此这个情况只能对应 $d=0$。

我们把原字符串每次取出首尾字符后递归构造。

分析 $d$ 的变化，对于 LR 情况 $d$ 不变，对于 LL 或 RR 要求内部 $d=1$，对于 RL 会使整个区间 $d$ 变为 $0$。

因此，考虑最外层的 RL，其外层若包含 LL 或 RR，则无解。

否则一定有解，且容易根据上述过程构造。

复杂度 $O(n)$。

---


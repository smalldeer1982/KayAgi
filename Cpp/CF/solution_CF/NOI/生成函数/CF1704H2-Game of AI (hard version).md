# Game of AI (hard version)

## 题目描述

这是本题的困难版本。简单版本与困难版本的区别在于对 $k$ 的约束和时间限制。注意在本版本中，你需要为所有正整数 $n \in [1, k]$ 计算答案。只有当两个版本均被解决时，你才能进行 hack。

Cirno 正在玩一款战争模拟游戏，其中有 $n$ 座塔（编号为 $1$ 至 $n$）和 $n$ 个机器人（编号为 $1$ 至 $n$）。初始时，第 $i$ 座塔被第 $i$ 个机器人占据（$1 \le i \le n$）。

在游戏开始前，Cirno 首先选择一个长度为 $n$ 的排列 $p = [p_1, p_2, \ldots, p_n]$（一个长度为 $n$ 的排列是指每个 $1$ 到 $n$ 的整数恰好出现一次的数组）。接着，她选择一个序列 $a = [a_1, a_2, \ldots, a_n]$（满足 $1 \le a_i \le n$ 且 $a_i \ne i$ 对所有 $1 \le i \le n$ 成立）。

游戏包含 $n$ 轮攻击。在第 $i$ 轮中，如果第 $p_i$ 个机器人仍在游戏中，它将发起攻击，导致第 $a_{p_i}$ 座塔被第 $p_i$ 个机器人占据；原本占据第 $a_{p_i}$ 座塔的机器人将失去该塔。如果第 $p_i$ 个机器人已不在游戏中，此轮不会发生任何事。

每轮结束后，如果一个机器人未占据任何塔，它将被淘汰并退出游戏。注意一座塔不能同时被多个机器人占据，但一个机器人可以在游戏中占据多座塔。

游戏结束时，Cirno 将记录结果序列 $b = [b_1, b_2, \ldots, b_n]$，其中 $b_i$ 表示结束时占据第 $i$ 座塔的机器人编号。

然而，作为数学大师，她希望你解决以下计数问题而非亲自游戏：

计算所有可能的序列 $a$ 和排列 $p$ 能生成的不同序列对 $(a, b)$ 的数量。

请为所有满足 $1 \le n \le k$ 的正整数 $n$ 计算答案。由于结果可能很大，请输出其对 $M$ 取模后的值。

## 说明/提示

当 $n=1$ 时，不存在合法的序列 $a$，因此答案为 $0$。

当 $n=2$ 时，唯一可能的数组 $a$ 是 $[2, 1]$：
- 当 $a$ 为 $[2, 1]$ 且 $p$ 为 $[1, 2]$ 时，最终序列 $b$ 为 $[1, 1]$。具体过程：
  - 第一轮，第一个机器人发起攻击并占领第 $2$ 座塔。此轮结束后，第二个机器人因失去所有塔而被淘汰。
  - 第二轮，第二个机器人已不在游戏中。
- 当 $a$ 为 $[2, 1]$ 且 $p$ 为 $[2, 1]$ 时，最终序列 $b$ 为 $[2, 2]$。具体过程：
  - 第一轮，第二个机器人发起攻击并占领第 $1$ 座塔。此轮结束后，第一个机器人被淘汰。
  - 第二轮，第一个机器人已不在游戏中。

因此当 $n=2$ 时，不同的序列对 $(a, b)$ 的数量为 $2$（即 $([2, 1], [1, 1])$ 和 $([2, 1], [2, 2])$）。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
8 998244353```

### 输出

```
0
2
24
360
6800
153150
4057452
123391016```

# 题解

## 作者：zhoukangyang (赞：12)

场上直接写了下面的做法，但是以为除叶子外树上的一个点最终标号不能是自己，于是一直调不出来，下分了 /ll

~~感觉 G 很简单，亏大了~~

[cnblogs](https://www.cnblogs.com/zkyJuruo/p/16539097.html)

## 题意

> 对于每个序列 $a$ 满足 $1 \le a_i \le n$ 且 $a_i \neq i$，以及一个排列 $p$，一个 bot 的游戏定义为：
开始每个位置 $i$ 都被 $i$ 号 $\rm bot$ 占领。
在第 $i$ 轮游戏中，$p_i$ 号 $\rm bot$ 如果在游戏中存在，那么他会占领 $a_{p_i}$ 号位置，原先占领 $a_{p_i}$ 号位置的 $\rm bot$ 将不再占领那个位置。
如果一个 $\rm bot$ 不再占领任何一个位置，那么该 $\rm bot$ 将会退出游戏。
设最后占领第 $i$ 个位置的 $\rm bot$ 是 $b_i$。对于 $1 \le n \le N$，求 $(a,b)$ 的个数。

> 数据范围：$1 \le N \le 10^5$。

## 题解

我们对于每个序列 $a$ 计数 $b$ 的个数。$a$ 形成了一颗基环树。

首先考虑对于一颗树计数：

设 $F(x)$ 表示对于一棵大小为 $x$ 的树的 $b$ 的个数的 $\rm EGF$，$G(x)$ 表示对于一颗大小为 $x$ 且 $b_{root} = root$ 的 $b$ 的个数的 $\rm EGF$。

首先考虑假设 $b_{root} \neq root$，那么根节点可以取任意一个子节点的标号，于是：

$$F(x) = G(x) + x \sum_{i \ge 1} \frac{iF(x)^i}{i!} = G(x) + xF\exp(F)$$

然后考虑 $b_{root} = root$ 的情况。在这种情况下，就要求根节点所有子节点都被踢出了游戏，也就是 $b_{son} \neq son$。因此：

$$G(x) = x \exp(F - G)$$

这个东西可以用分治 $\rm FFT$ 分治的时候同时记下 $\exp(F-G)$ 和 $\exp(F)$。

也可以用牛顿迭代：$F = x\exp(xF\exp(F)) + xF\exp(F)$。

然后考虑对于单个基环树计数。

对于环上的一个节点 $x$ 分类讨论。设 $y$ 为 $x$ 在环上的上一个节点。

1. $b_x = y$：对于环上的所有点不能都满足 $b_x = y$，由于子树是什么不重要，因此生成函数为 $x\exp(F)$。
1. $b_x \neq x, b_x \neq y$：那么取的是一个 $x$ 的子节点，没有限制，生成函数为 $F - G$。
1. $b_x = x$：那么 $x$ 的上一个节点 $y$ 必然满足 $b_y \neq y$。这个时候我们可以把这个节点和上一个节点合并起来，看成一个大节点。这个大点的生成函数就是：$(x\exp(F) + F-G) \times G$。

首先总情况数就是这三种情况的生成函数的和，设和为 $T$，然后连成一个环，其生成函数就是 $\sum_{i \ge 1} \frac{T^i}{i} = \ln(1-T)$。

然而这样直接连可能不合法，因此容斥掉环上所有点都满足 $b_x = y$ 的情况，再容斥掉环上只有一个点的情况即可。

算出单个基环树的答案后，直接 $\exp$ 就能得出答案。

我的实现中树的答案是用分治 FFT 求的，时间复杂度 $\Theta(n \log^2 n)$，如果用牛顿迭代就是 $\Theta(n \log n)$。

[aclink](https://codeforces.com/problemset/submission/1704/166424861)。

---

## 作者：JWRuixi (赞：2)

## CF1704H Game of AI

### 题意

对于每一个长度为 $n$ 的序列 $a$，满足 $a_i \in [n] \setminus \{i\}$，以及一个排列 $p$，定义一个游戏为：

- 初始时 $b_i = i$；
- 对于 $i = 1, \dots, n$：
  - 若存在 $j$ 满足 $b_j = p_i$，则令 $a_{p_i} \gets p_i$；
  - 否则无事发生。

求对于所有可能的 $a$，$p$ 进行的游戏，不同的序列二元组 $(a, b)$ 的个数 $\bmod P$。你需要对于 $n = 1, \dots, k$ 求答案。

$k \le 10^5$，$2^{18} | P - 1$。

### 分析

考虑连边 $i \to a_i$，那么所有的赋值操作形成一棵内向基环树，我们能决定的是边操作的顺序。

很难不发现“存在 $j$ 满足 $b_j = p_i$”等价于“此时 $b_{p_i} = p_i$”，也就是说，相当于此时 $p_i$ 的儿子及基环上的前驱均未操作。那么树的部分的方案和环就独立了！

那么对于一个树上（非环上）节点而言，它的所有儿子的操作顺序是可以人为决定的，也就是说 $b_i$ 至少有 $|son_i|$ 种取值。

问题在于 $b_i$ 是否可以等于 $i$？一种简单的情况是如果它的儿子中存在叶子，那么显然是不行的；否则我大概可以通过控制儿子到 $i$ 的边操作时间后于儿子被覆盖的时间，使得 $b_i = i$。然而这不太对，推广一下，广义的叶子可以定义为所有 $b_u = u$ 的节点。那么现在就可以确定，不合法当且仅当儿子中存在广义叶子。

我们不关心点具体的标号，可以直接计数不同的树的形态，那么就可以有一种按子树大小从小到大 DP 的方式，复杂度较高。可以使用生成函数描述这个 DP，记 $f_i$ 为大小为 $i$ 的树所有可能的序列 $b$ 的方案，记 $g_i$ 为满足 $b_{rt} = rt$ 的序列数，$F$，$G$ 分别是它们的生成函数，有：
$$
\begin{align}
F &= G + x \sum\limits_{d \ge 1} \dfrac{d F^d}{d!} = G + x F \exp(F) \\
G &= x \sum\limits_{d \ge 1} \dfrac{(F - G)^d}{d!} = x \exp(F - G)
\end{align}
$$
将一式带入二式，有 $G = x \exp(x F \exp(F))$，回带就能得出 $F = x \exp(x F \exp(F)) + x F \exp(F)$。这已经是一个只关于 $F$ 的方程了，且有 $[x^0]F = 0, [x^1]F = 1$，那么直接使用牛顿迭代求解就可以了！

讨论一下环上点 $x$ 的 $b_x$ 的取值，记 $y$ 为 $x$ 在环上的前驱：

- $b_x = y$：对 $x$ 儿子的边的顺序没有要求，我们总是可以将 $y \to x$ 安排在最后，注意要去掉最后一层乘的方案数，生成函数为 $x \exp(F)$，注意一个小细节是不能环上全部点都满足；
- $b_x \in son_x$：只要将 $y \to x$ 安排在最前面就可以了，生成函数为 $F - G$；

- $b_x = x$：满足 $b_y \ne y$，直接捆绑法，将 $x$，$y$ 合并为一个大点，整体的生成函数为 $(x \exp(F) + (F - G)) G$；

记 $H$ 为三类情况的生成函数和，那么总方案数为 $\sum\limits_{i \ge 1} \dfrac{H^i}{i}$，注意到这是 $\ln(1 - H)$，直接求就可以了。

但是有一个小问题，我们算错了一些贡献：所有点都满足 $b_x = y$；环上只有一个点。方案数分别为 $\ln(1 - x \exp(F))$，$F - G$，将它们容斥掉就可以了！

时间复杂度 $\mathcal O(n \log n)$，其中牛顿迭代部分常数极大，因此实测基本上要跑个 $7 \sim 8$ 秒……

### Code

提交记录：<https://codeforces.com/contest/1704/submission/285244571>。

---


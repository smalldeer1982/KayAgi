# Doping

## 题目描述

我们称长度为 $n$ 的数组 $a$ 为“花式数组”，如果对于每个 $1 < i \le n$，都有 $a_i = a_{i-1} + 1$。

我们定义 $f(p)$ 作用于一个长度为 $n$ 的排列 $^\dagger$，表示将其划分为若干个子数组，每个子数组都是花式数组的最小划分数。例如 $f([1,2,3]) = 1$，$f([3,1,2]) = 2$，$f([3,2,1]) = 3$。

给定 $n$ 和一个长度为 $n$ 的排列 $p$，我们定义长度为 $n$ 的排列 $p'$ 是 $k$-特殊的，当且仅当：

- $p'$ 字典序小于 $p$ $^\ddagger$，且
- $f(p') = k$。

你的任务是，对于每个 $1 \le k \le n$，计算 $k$-特殊排列的个数，对 $m$ 取模。

$^\dagger$ 排列是一个包含 $n$ 个 $1$ 到 $n$ 的不同整数的数组，顺序任意。例如 $[2,3,1,5,4]$ 是一个排列，但 $[1,2,2]$ 不是排列（$2$ 出现了两次），$[1,3,4]$ 也不是排列（$n=3$ 但有 $4$）。

$^\ddagger$ 长度为 $n$ 的排列 $a$ 的字典序小于排列 $b$，当且仅当：在第一个不同的位置，$a$ 的元素小于 $b$ 的对应元素。

## 说明/提示

在第一个样例中，字典序小于 $[1,3,4,2]$ 的排列有：

- $[1,2,3,4]$，$f([1,2,3,4])=1$；
- $[1,2,4,3]$，$f([1,2,4,3])=3$；
- $[1,3,2,4]$，$f([1,3,2,4])=4$。

因此答案为 $[1,0,1,1]$。

在第二个样例中，字典序小于 $[3,2,1]$ 的排列有：

- $[1,2,3]$，$f([1,2,3])=1$；
- $[1,3,2]$，$f([1,3,2])=3$；
- $[2,1,3]$，$f([2,1,3])=3$；
- $[2,3,1]$，$f([2,3,1])=2$；
- $[3,1,2]$，$f([3,1,2])=2$。

因此答案为 $[1,2,2]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 666012
1 3 4 2```

### 输出

```
1 0 1 1```

## 样例 #2

### 输入

```
3 10
3 2 1```

### 输出

```
1 2 2```

## 样例 #3

### 输入

```
7 1000000000
7 2 1 3 5 4 6```

### 输出

```
1 6 40 201 705 1635 1854```

## 样例 #4

### 输入

```
10 11
10 9 8 7 6 5 4 3 2 1```

### 输出

```
1 9 9 0 1 5 5 0 1 0```

# 题解

## 作者：Alex_Wei (赞：14)

### [CF1750G Doping](https://www.luogu.com.cn/problem/CF1750G)

非常好的组合题！复习了一下二项式反演。

#### 子问题

考虑最朴素的问题：求有多少个 $n$ 阶排列 $p$ 满足 $f(p) = k$。

$f(p) = k$ 的限制不好处理，此时经典的套路是通过二项式反演计算答案。问题来了：排列问题有两个维度，位置和值，究竟对哪一维二项式反演？

观察到，原问题对字典序做出限制，一般方法是枚举 LCP 再枚举第一个不同的值，此时剩余的所有位置依然是一段区间，但剩余的值会被已经枚举的值切割得七零八落。此时再钦定位置上的连续就不太可做了，因为可能没有足够长的可行值连续段与位置连续段相对应。

于是，为了使做法可扩展到原问题，我们钦定值的连续：选择若干值 $x_1, x_2, \cdots, x_k$ 满足 $1\leq x_i < n$ 且 $x_i$ 互不相同，钦定 $x_i$ 下一个数一定是 $x_{i} + 1$。形如 “$x$ 下一个数一定是 $x + 1$” 的限制让一些数必须成段出现，而不同的段之间是相互独立，没有约束的。于是，在 $\{x_i\}$ 已经确定时，可算出对应方案数为 $(n - k)!$。

设 $G_k$ 表示钦定 $k$ 个值域维度上的空隙连续（方便起见，称为 **连接**）的方案数，则
$$
G_k = \binom {n - 1} k (n - k)!
$$
前者是选择 $\{x_i\}$ 的方案数，后者是固定 $\{x_i\}$ 时排列的数量。

那么考虑恰好有 $k$ 个连接的排列，对 $k' \leq k$，它会在其所有连接中的任意 $k'$ 个被钦定时被统计恰好一次。设恰好有 $k$ 个连接的排列数为 $F_k$，则
$$
G_{k'} = \sum_{k = k'} ^ {n - 1} F_{k} \binom {k} {k'}
$$
于是，根据二项式反演，有
$$
F_k = \sum_{k' = k} ^ {n - 1} (-1) ^ {k' - k} G_{k'} \binom {k'} k
$$
它的实际含义为：

- 加上 $G_k$ 表示钦定 $k$ 个连接，此时有 $k$ 个连接的排列会被恰好算一次。
- 有 $k + 1$ 个连接的排列每个都被算了 $\binom {k + 1} k$ 次，应当算零次，于是加上 $-G_{k + 1}\binom {k + 1} k$（这是唯一能够不改变恰有 $k$ 个连接的排列的贡献系数，但改变恰有 $k + 1$ 个连接的排列的贡献系数的办法）。
- 考虑有 $k + 2$ 个连接的排列每个被算了多少次：$G_k$ 带来的 $\binom {k + 2} k$ 和 $G_{k + 1}$ 带来的 $-\binom {k + 2} {k + 1} \binom {k + 1} k$，求和为 $-\binom {k + 2} k$。

以此类推，有 $k + d$ 个连接的排列每个被算了
$$
\sum_{c = 0} ^ {d - 1} (-1) ^ c \binom {k + d}{k + c} \binom {k + c} k = \binom {k + d} k\sum_{c = 0} ^ {d - 1} (-1) ^ c \binom {d} c
$$
次，其中的变形可以通过组合意义得出，或直接代数推导。而 $d \geq 1$，于是 $\sum_{c = 0} ^ d (-1) ^ c \binom d c = 0$。因此有 $k +d$ 个连接的排列每个被算了 $-(-1) ^ d \binom d d \binom {k + d} k$ 次，于是 $G_{k + d}$ 对 $F_k$ 的贡献系数为 $(-1) ^ d \binom {k + d} k$，这与二项式反演得到的公式相吻合（其实它们本质相同）。

~~好像把二项式反演重新介绍了一遍，不过因为我对其理解不算深刻，所以就当复习了~~。

以上步骤熟练了之后应当在很短的时间内想出来。

#### 原问题

回归原问题。设题目给出的排列为 $q$，需要计数的排列为 $p$。枚举 $p, q$ 的 LCP 长度加 $1$ 的值 $L$（$1 \leq L \leq n$），以及 $p_{L} < q_{L}$。此时 $p_{1\sim L}$ 已经全部确定，$p_{L + 1\sim n}$ 可以任意填入所有还没有被填入的数，然后贡献至 $k = f(p)$ 时的答案。

由于 $f(p) = k$ 等价于连接数为 $n - k$，所以方便起见，考虑直接对连接数为 $k$ 的排列计数（这一步转化不做也可以）。

由于没有被填入的值被分成了若干连续段，所以可以钦定的连接数并非 $n - L - 1$ 而是 $n - L - c$，其中 $c$ 是值连续段的数量。进行二项式反演，可以得到复杂度为 $\mathcal{O}(n ^ 4)$ 的无法通过的算法。

注意到 $p_{L +1}$ 具体的取值并不重要，我们只关心 $p_{L + 1}$ 确定后剩余值的连续段数量，很明显它只有 $\mathcal{O}(1)$ 种不同的取值。于是复杂度降至 $\mathcal{O}(n ^ 3)$。

> 这里有一个注意点。
>
> 也许你会问：二项式反演是线性变换，为什么不能先对 $G$ 求和，最后再二项式反演呢？这样复杂度不就是 $\mathcal{O}(n ^ 2)$ 的了吗？
>
> 核心问题是 **下标偏移**。
>
> 请注意，我们做二项式反演，是在对 $p_{L + 1\sim n}$ 而非 $p_{1\sim n}$ 做。在已有 $c$ 个连接的基础上钦定 $p_{L + 1\sim n}$（这里还要处理 $p_{L}$ 和 $p_{L + 1}$ 之间的细节，放在后面讲）新增 $k$ 个连接，方案数对 $G$ 产生贡献的下标应当为 $k$ 而非 $c + k$：对 $0 \leq k \leq k'$，每个 $c + k'$ 个连接的排列会在它的 $k'$ 个新增连接中任意 $k$ 个被钦定时被计算一次，而非所有 $c + k'$ 个连接中任意 $c + k$ 个被钦定时被计算一次，于是系数为 $\binom {k'} {k}$ 而非 $\binom {c + k'} {c + k}$。相对应的，为了满足 $G_{k} = \sum_{k' = k} ^ {n - 1} \binom {k'} {k} F_{k'}$ 的前提条件（这样才能二项式反演），钦定 $k$ 个连接时对应的方案数应贡献至 $G_k$ 而非 $G_{c + k}$。
>
> 二项式反演得到 $F_k$，表示恰好新增 $k$ 个连接的排列数，此时再其贡献至连接数为 $c + k$ 的答案。这就使得我们必须对所有情况的 $G$ 先二项式反演，进行对应的下标偏移，再求和。

这是否意味着本题无法做到 $\mathcal{O}(n ^ 2)$ 呢？非也。“下标偏移” 既然是难点，那它肯定也是本题的突破口。

#### 下标偏移

欲从二项式反演的角度解决问题，则最多只能进行一次二项式反演（不排除做很多次规模较小的反演，但本题看起来不像）。这说明不能在每个 $L$ 的地方都二项式反演，那么只能放在最后了。于是，我们希望求和的每个 $G$ 在二项式反演后都能得到 **不需要下标偏移** 的 $F$。

于是问题的核心来到：**考察 $G$ 应当如何变化，才能使其二项式反演后的 $F$ 产生下标偏移**。笔者认为这是本题最大的难点（其它部分是顺理成章的，虽然该难点对于熟练掌握组合数学相关工具的同学很简单）。

由于下标偏移会让 $F$ 的每个元素的下标增加 $c \geq 0$，所以我们首先考察如何操作 $G$ 会让 $F$ 的每个元素的下标增加 $1$。

已知 $F'_{k} = F_{k - 1}$，以及
$$
\begin{aligned}
G_k & = \sum_{k' = k} ^ {n - 1} \binom {k'} {k} F_{k'} \\
G'_k & = \sum_{k' = k} ^ {n - 1} \binom {k'} {k} F'_{k'}
\end{aligned}
$$
我们希望用 $G_k$ 表示 $G'_k$，主要思路是将 $G_k'$ 的式子的形式尽量往 $G_k$ 上凑。

将 $F'_k = F_{k - 1}$ 带入，有
$$
G'_k = \sum_{k' = k} ^ {n - 1} \binom {k'} {k} F_{k' - 1}
$$
尝试将组合数里的 $k'$ 和 $F$ 的下标 $k' - 1$ 对齐（因为 $G_k$ 是对齐的）。根据 $\binom {n} {m} = \binom {n - 1}{m - 1} + \binom {n - 1} {m}$，有
$$
G_k' = \left(\sum_{k' = k} ^ {n - 1} \binom {k' - 1} {k - 1} F_{k' - 1}\right) + \left(\sum_{k' = k} ^ {n - 1} \binom {k' - 1} {k} F_{k' - 1} \right)
$$
由于将 $F$ 的下标增加 $1$ 之前 $F_{n - 1} = 0$（否则说明 $F'_n$ 非零，根据题意这是不可能的），于是将 $k'$ 的求和上界增至 $n$ 不改变结果，即
$$
G_k' = \left(\sum_{k' = k} ^ {n} \binom {k' - 1} {k - 1} F_{k' - 1}\right) + \left(\sum_{k' = k} ^ {n} \binom {k' - 1} {k} F_{k' - 1} \right)
$$
令 $k'$ 减去 $1$，于是求和范围从原来的 $[k, n]$ 变成 $[k - 1, n - 1]$，即
$$
G_k' = \left(\sum_{k' = k - 1} ^ {n - 1} \binom {k'} {k - 1} F_{k'}\right) + \left(\sum_{k' = k - 1} ^ {n - 1} \binom {k'} {k} F_{k'} \right)
$$
前者就是 $G_{k - 1}$，后者由于 $k' = k - 1$ 时 $\binom {k'} k = 0$，所以 $k'$ 可以从 $k$ 开始求和，就是 $G_k$。

于是
$$
G'_k = G_k + G_{k - 1}
$$
从生成函数的角度来看，$G' = G\times(1 + x)$。于是如果要让 $F$ 的下标向右偏移 $c$，那么 $G' = G\times (1 + x) ^ c$，即 $G'_k = \sum_{i = 0} ^ c \binom c i G_{k - i}$，就是将 $G$ 做 $c$ 次上述操作得到的结果。其组合意义为：考虑 $G_{k - i}$ 到 $G'_k$ 的贡献系数，等于每次可以选择将下标加 $0$ 或 $1$，总共 $c$ 次，下标从 $k - i$ 到 $k$ 的方案数。$c$ 次选 $i$ 次下标加 $1$，即 $\binom c i$。也可以从组合数的递推关系角度考虑。

设 $SG_c$ 表示二项式反演后下标偏移量需要为 $c$ 的 $G$ 之和。对每个 $c$，计算 $SC_c$ 进行 $c$ 次上述操作后的结果，求和后再二项式反演。但计算 $c$ 次操作后的结果的复杂度是 $\mathcal{O}(nc)$，依然无法接受。

没关系，很明显 “操作” 是线性的，即设变换 $A$ 表示 $G' = A(G)$，那么 $A(P) + A(Q) = A(P + Q)$。从生成函数的角度很好理解：$P(1 + x) + Q(1 + x) = (P + Q)(1 + x)$。

于是我们可以先对 $SC_c$ 进行一次操作，此时 $SC_c$ 和 $SC_{c - 1}$ 都还需要再进行 $c - 1$ 次操作，直接将它们合并在一起，进行一次操作，再和 $SC_{c - 2}$ 合并，以此类推。从生成函数的角度，这就是秦九韶算法。
$$
\sum_{i = 0} ^ {c} SC_i (1 + x) ^ i = (1 + x)[(1 + x)(\cdots) + SC_1 ] + SC_0
$$

#### 细节处理

当然，我们不能将 $p_{L + 1\sim n}$ 完全独立来看，因为 $p_L$ 和 $p_{L + 1}$ 之间也会产生连接。

现在 $p_{1\sim L - 1}$ 已知，$p_{L\sim n}$ 未知，可以将 $p_{L\sim n}$ 看成独立的一部分并要求 $p_L < q_L$。

设前面的值构成集合 $S$，剩下的值有 $d$ 个连接，即存在 $d$ 个 $v\in [1, n - 1]$ 使得 $v, v + 1\notin S$。枚举 $p_L < q_L \land p_L \notin S$。

- 若 $p_{L} - 1\notin S$，由于不能钦定 $p_L - 1$ 和 $p_L$ 连接，所以钦定 $k$（$0\leq k < d$）个连接的方案数为从 $d - 1$ 个连接中任选 $k$ 个的方案数 $\binom {d - 1} {k}$，乘以安排 $n - L + 1 - k$ 个连续段的方案数 $(n - L - k)!$，减去 $1$ 是因为以 $p_L$ 开头的段必须放在开头。贡献至 $G_k$。
- 若 $p_L - 1\in S$，类似地，可知方案数为 $\binom d k (n - L - k)!$。贡献至 $G_k$。
- 特别地，当 $p_L = p_{L - 1} + 1$ 时，还要将方案数额外贡献至 $G_{k + 1}$。

于是，$p_L - 1\in S$ 的 $p_L$ 产生的贡献相同，$p_{L} - 1\notin S$ 的 $p_L$ 产生的贡献相同，故只需各考虑一次贡献，乘以对应系数即可。

为了使用类似秦九韶的方法处理下标偏移，需要从 $n - 1$ 到 $1$ 枚举 $L$。在 $L + 1\to L$ 时，考察当前二项式反演钦定连接的位置范围：$L\sim n$。于是若 $p_{L - 1} + 1 = p_{L}$，则需要在计算 $L$ 的贡献之前将当前的 $G$ 乘以 $(1 + x)$。

时间复杂度 $\mathcal{O}(n ^ 2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 2e3 + 5;
int n, mod, p[N], C[N][N], fc[N], F[N], G[N];
void addt(int &x, int y) {x += y, x >= mod && (x -= mod);}
int main() {
  cin >> n >> mod;
  for(int i = 1; i <= n; i++) cin >> p[i];
  for(int i = 0; i <= n; i++) {
    for(int j = 0; j <= i; j++) {
      if(j == 0) C[i][j] = 1;
      else C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
      if(C[i][j] >= mod) C[i][j] -= mod;
    }
  }
  fc[0] = 1;
  for(int i = 1; i <= n; i++) fc[i] = 1ll * fc[i - 1] * i % mod;
  for(int L = n - 1; L; L--) {
    if(L > 1 && p[L - 1] + 1 == p[L]) {
      for(int i = n; i; i--) addt(G[i], G[i - 1]);
    }
    vector<int> vis(n + 1, 0);
    vis[0] = 1;
    for(int i = 1; i < L; i++) vis[p[i]] = 1;
    int lemp = 0, lhav = 0, d = 0;
    for(int v = 1; v < n; v++) {
      d += !vis[v] && !vis[v + 1];
      if(!vis[v] && v < p[L]) !vis[v - 1] ? lemp++ : lhav++;
    }
    for(int k = 0; k <= d; k++) {
      int coef = 1ll * C[d][k] * lhav % mod;
      if(k < d) addt(coef, 1ll * C[d - 1][k] * lemp % mod);
      addt(G[k], 1ll * coef * fc[n - L - k] % mod);
      if(L > 1 && !vis[p[L - 1] + 1] && p[L - 1] + 1 < p[L]) {
        addt(G[k + 1], 1ll * C[d][k] * fc[n - L - k] % mod);
      }
    }
  }
  for(int k = 0; k <= n; k++) {
    for(int _k = k; _k <= n; _k++) {
      int val = 1ll * G[_k] * C[_k][k] % mod;
      if(_k - k & 1) val = mod - val;
      addt(F[k], val);
    }
  }
  for(int i = 1; i <= n; i++) cout << F[n - i] << " ";
  return 0;
}
```

#### 其它思考方式

在处理下标偏移的时候，我们使用了比较繁琐的推式子法，得到 “如何处理特定形式的二项式反演前的数组，使得其在二项式反演后得到的结果相较于处理前的数组在二项式反演后的结果向右平移了一位”。其中特定的二项式反演形式为
$$
G_k = \sum_{k' = k} ^ n \binom {k'} k F_{k'} \iff F_k = \sum_{k' = k} ^ n (-1) ^ {k' - k} \binom {k'} k G_{k'}
$$
我们得到的结论是将 $G$ 乘以 $1 + x$，即同时令所有 $G_k$ 变成 $G_k + G_{k - 1}$。特别地，这种方法要求平移前的 $F_n = 0$。如果平移前 $F_n\neq 0$ 且希望截断，即平移后丢掉原来的 $F_n$，则需要先将所有 $G_k$ 减去 $\binom n k F_n$（去掉 $F_n$ 对 $G$ 的贡献，相当于将 $F_n$ 置为 $0$），再乘以 $1 + x$。

有没有更简单的思考方式呢？我们可以从组合意义入手。强制下标向右偏移 $1$ 相当于给所有排列新增一个连接。对于这个连接，可以选择是否钦定它。如果不钦定它，就相当于原来的 $G$。如果钦定它，就相当于 $G$ 向右偏移 $1$。换言之，对于新的 $G'_k$，它有两种选择：一种是不钦定新增的连接，方案数是 $G_k$；另一种是钦定新增的连接，那么原来的连接数量应当为 $k - 1$，方案数是 $G_{k - 1}$。

进一步地，对于一个连接数量为 $k'$ 的排列，它对 $G_k$ 的贡献是任选 $k$ 个连接钦定的方案数 $\binom {k'} k$。当 $k'$ 变成 $k' + 1$ 时，它对 $G_k$ 的贡献变为 $\binom {k' + 1} k$。根据新增的连接是否被钦定，可得 $\binom {k' + 1} k = \binom {k'} k + \binom {k'} {k - 1}$，于是新的贡献到 $k$ 的方案数就是原来贡献到 $k$ 的方案数加上原来贡献到 $k - 1$ 的方案数。这是 $\binom n m = \binom {n - 1} {m} + \binom {n - 1} {m - 1}$ 的组合解释，和我们推式子的过程中采用的组合恒等式是一致的。

于是，通过组合意义，我们可以直接得出为了让 $F$ 向右平移 $1$，$G$ 应当乘以 $1 + x$，略去了繁琐的推式子过程。

还有一个根据二项式反演的组合意义直接解决本题的做法，见 [ymx 的题解](https://www.luogu.com.cn/blog/Troverld/solution-cf1750g)。

从本题出发，可以得到一些扩展问题，笔者将它们作为思考题留给各位读者。

- 对于本题的二项式反演形式，如果希望将 $F$ 向左平移 $1$，应当如何操作 $G$？它和生成函数中乘以 $\frac 1 {1 + x}$ 的操作一致吗？

- 对于另一种二项式反演形式
  $$
  G_k = \sum_{k' = 0} ^ k \binom {k} {k'} F_{k'} \iff F_k = \sum_{k' = 0} ^ k (-1) ^ {k - k'} \binom {k} {k'} G_{k'}
  $$
  结合 “子问题” 小节思考它的实际含义，并使用组合恒等式验证。如果希望将 $F$ 向左或向右平移 $1$，应当如何操作 $G$？

---

## 作者：Kubic (赞：10)

考虑容斥。设 $f_i$ 表示恰好能被分为 $i$ 段的排列数量，$g_i$ 表示钦定被分为 $i$ 段的排列数量。那么可以得到：

$$g_i=\sum\limits_{j=1}^i\dbinom{n-j}{n-i}f_j$$

因此我们只需要计算出 $g$ 就可以逆推出 $f$。

枚举 $p$ 与 $p'$ 的 LCP 长度 $i$。

将 $p_{i\dots n}$ 分为 $<p_i$ 和 $\ge p_i$ 两类。分这两类考虑是因为我们要求 $p'_i<p_i$。

设两类数中分别有 $a_1,a_2$ 个差为 $1$ 的数对，同时在值域上分别形成了 $b_1,b_2$ 个连续段。

可以根据插板法得到 $p_{i\dots n}$ 钦定被分为 $k$ 段的排列方案数为：

$$\sum\limits_{j=0}^k(b_1+j)(k-1)!\dbinom{a_1}{j}\dbinom{a_2}{k-b_1-b_2-j}$$

$$=b_1(k-1)!\dbinom{a_1+a_2}{k-b_1-b_2}+a_1(k-1)!\dbinom{a_1+a_2-1}{k-b_1-b_2-1}$$

可能会出现 $p_{i-1}=p_i-1$，这种情况的方案数为：

$$(k-1)!\dbinom{a_1+a_2}{k-b_1-b_2}$$

但如果对每个 $i$ 都进行容斥复杂度就会达到 $O(n^3)$，我们希望只在最后进行一次容斥。

设 $dp_{i,j}$ 表示只考虑 $p_{i\dots n}$ 时 $g_j$ 的值。

如果 $p_i=p_{i-1}+1$，那么 $dp_{i,j}=dp_{i+1,j}+dp_{i+1,j-1}$。两种转移分别表示当前这个位置是否被钦定分段。

如果 $p_i\neq p_{i-1}+1$，那么 $dp_{i,j}=dp_{i+1,j-1}$。这是因为当前这个位置必须被钦定分段。

只需要在 $dp_{i,j}$ 处加入 $p_{i\dots n}$ 钦定被分为 $j$ 段的方案数，然后往前推即可。时间复杂度 $O(n^2)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2005
int n,MOD,a[N],b[N],fc[N],z[N],C[N][N];bool vs[N];
void W(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;}
int add(int x,int y) {x+=y;return x<MOD?x:x-MOD;}
int main()
{
	scanf("%d %d",&n,&MOD);b[1]=1;
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=0;i<=n;++i) for(int j=0;j<=i;++j)
		C[i][j]=j?add(C[i-1][j],C[i-1][j-1]):1;
	fc[0]=1;for(int i=1;i<=n;++i) fc[i]=1ll*fc[i-1]*i%MOD;
	for(int i=n,t,t1,o1[2],o2[2];i;--i)
	{
		if(i>1 && a[i]==a[i-1]+1)
			for(int j=1;j<=n;++j) W(z[j-1],z[j]);
		vs[a[i]]=1;o1[0]=o1[1]=o2[0]=o2[1]=0;
		for(int j=1;j<a[i];++j) o1[vs[j-1]]+=vs[j];
		for(int j=a[i];j<=n;++j) o2[vs[j-1]]+=vs[j];
		for(int j=0;j<=o1[1]+o2[1];++j)
		{
			t=o1[0]+o2[0]+j+i-1;t1=fc[t-i];
			W(z[t],1ll*o1[0]*C[o1[1]+o2[1]][j]%MOD*t1%MOD);
			if(j) W(z[t],1ll*o1[1]*C[o1[1]+o2[1]-1][j-1]%MOD*t1%MOD);
			if(i>1 && vs[a[i-1]+1] && a[i-1]+1<a[i])
				W(z[t-1],1ll*C[o1[1]+o2[1]][j]*t1%MOD);
		}
	}
	for(int i=1;i<=n;++i) for(int j=1;j<i;++j)
		W(z[i],MOD-1ll*C[n-j][n-i]*z[j]%MOD);
	for(int i=1;i<=n;++i) printf("%d ",z[i]);return 0;
}
```

---

## 作者：OtoriEmu (赞：8)

不会做组合题的 emu（

先考虑一个没有限制的问题，也即对于所有 $n$ 阶排列求答案，记答案的数列为 $f$。直接算 $f$ 不好算，考虑算另一个数列 $g$，其中 $g_i$ 表示钦定划分成 $i$ 个段的方案数（一个排列可以贡献多次），可以写出关于 $f$ 和 $g$ 的表达式：

$$
g_i = \sum_{j=1}^i \dbinom{n-j}{i-j} f_j
$$

这个式子比较好理解，恰好被分成 $j$ 个段的排列还有 $n-j$ 个位置可以切开，需要选择 $i-j$ 个位置。只要得到 $g$ 就可以得到 $f$，具体的通过 $g_{1\dots i-1}$ 得到 $f_{1\dots i-1}$，在 $g_i$ 中 $f_i$ 的系数为 $1$，就可以算出来。

要求字典序小于某一个排列，只能枚举 LCP 之后计算。假设我们现在确定了一个长为 $i-1$ 的 LCP，第 $i$ 位需要填进一个小于 $p_i$ 的数。首先预处理两组东西，第一组表示还没有填入的数中，值小于 $p_i$ 的在数轴上构成的连续段个数，以及这样的数的个数 $(f_1,g_1+f_1)$；第二组就是把这样的数换成不大于 $p_i$ 的数，求出另外一个 $(f_2,g_2+f_2)$（$\cdots, p_i-1,p_i,p_i+1,\cdots$ 视作构成一个值小于 $p_i$ 的数在数轴上构成的连续段，另外请注意每组数的第二个值是 $g_i+f_i$ 而非 $g_i$）。

有了这几个东西我们就可以求贡献了。钦定 $p'[i\dots n]$ 被分成了 $k$ 段（$f_1+f_2 \leq j \leq f_1+f_2+g_1+g_2$），方案数为：

$$
\sum_{j=0}^k \dfrac{g_1+j}{k} k! \dbinom{g_1}{j} \dbinom{g_2}{k-f_1-f_2-j}
$$

简单解释一下含义：因为一定至少有 $f_1+f_2$ 个连续段，我们枚举前小于 $p_i$ 的数多构成了多少个连续段，那么后面不小于 $p_i$ 的数多构成的连续段确定，也即 $\dbinom{g_1}{j}\dbinom{g_2}{k-f_1-f_2-j}$。$k$ 个段乱排方案为 $k!$，但是要求 $p_i'<p_i$，发现所有 $k!$ 个排列中有 $\dfrac{g_1+j}{k}$ 都是合法的。

接下来是一些比较简单的东西，具体运用 $m\dbinom{n}{m} = n\dbinom{n-1}{m-1}$ 以及两次范德蒙德卷积将整体拆成和 $j$ 无关的形式，下面直接给出结果：

$$
(k-1)!f_1\dbinom{g_1+g_2}{k-f_1-f_2} + (k-1)!g_1\dbinom{g_1+g_2-1}{k-f_1-f_2-1}
$$

当然还有特殊情况，也即 $p_i'$ 可以填入 $p_{i-1}+1$，这样可以选择不钦定 $i$ 作为一段的起点，这样的方案为 $\dfrac{k!}{k}\dbinom{g_1+g_2}{k-f_1-f_2}$（因为在这种情况下 $p_{i-1}+1$ 一定是一个连续段的起点，可以不枚举，补满缺少的 $k-f_1-f_2$ 个钦定的连续段之后的所有连续段排列有 $\dfrac{1}{k}$ 的概率满足条件）。

当然如果做 $n$ 次容斥不太科学，我们考虑只做一次。注意到一开始的式子 $g$ 可加，我们从大到小枚举 LCP，让后面的 $g$ 加到当前的 $g$ 上来。简单分类讨论，如果 $p_i-1=p_{i-1}$ 就可以选择是否钦定分段，那么有转移 $g_{i,j}=g_{i,j-1}+g_{i,j}$；否则一定要分段，转移 $g_{i,j}=g_{i,j-1}$。

[评测记录](https://codeforces.com/contest/1750/submission/180070446)。



---

## 作者：ZillionX (赞：7)

绝世好题！细节有点多，想了一天才搞懂。

> 给定长度为 $n$ 的排列 $a$，要对于 $k=1,2,3,\cdots,n$ 求出，有多少个长度为 $n$ 的排列 $p$ 满足 $p$ 字典序比 $a$ 小，且 $f(p)=k$，其中 $f(p)$ 表示 $p$ 最少可以划分成多少个区间，使得每个区间中的元素都是公差为 $1$ 的等差数列。答案对 $m$ 取模，$m$ 不一定是质数。

> $n\le 2000$，3s。

\*3300 的字典序计数题，显然地先考虑枚举 $p$ 与 $a$ 的 LCP，这里设它为 $i-1$，那么现在就有 $p_i<a_i$，我们考虑 $p_{i \sim n}$ 的 $f$ 值。

当然，这段排列并不是在值域上整段连续的，可以证明它的 $f$ 值与且仅与下面两个东西有关系：首先就是 $n-i+1$ 的大小，其次就是它在值域上相邻数对的数量和连续段的数量……吗？

事实上我们这里需要保证 $p_i<a_i$，所以相邻数对的数量 $l$ 和连续段的数量 $c$ 都要分成两部分来处理：一部分是 $p_{i \sim n}$ 中 $<a_i$ 的数（记为 $l_1,c_1$），另一部分则是 $\ge a_i$ 的数（记为 $l_2,c_2$）。这时候可能有人就会问了：那我可以把一段开头 $<a_i$ 的连续段放在最前面，然后这个连续段后面 $\ge a_i$，你这样不是会漏算在 $f$ 里面吗？

事实上如果存在 $x=p_i-1$ 的话，我们直接不把这段算在 $c_2$ 里面即可，注意仍然要算在 $l_2$ 里面。

尝试直接计数，容易发现这样必然会算重，不妨经典反演技巧，化“恰好”为“钦定”，若设 $F_x$ 为钦定 $f(p_{i \sim n})=x$ 的方案数，$G_x$ 为恰好的方案数，显然有

$$F_i=\sum_{j=1}^i {{n-j}\choose{i-j}} G_j$$

容易发现在 $F_i$ 中 $G_i$ 的系数为 $1$，所以根据 $F$ 反演得到 $G$ 是不难的，下面讲如何得到 $F$。

$$F(k)=\sum_{j=0}{l_1 \choose j}{l_2 \choose k-c_1-c_2-j}(c_1+j)(k-1)!+\sum_{j=0}{l_1 \choose j}{l_2 \choose k+1-c_1-c_2-j}k!$$

这个式子捏就是分两种情况来讨论，首先就是 $p_i \neq a_{i-1}+1$，$p_i$ 为一段段首，枚举 $c_1$ 里面被多分出来的段数 $j$，那么新分出来的段的段首就有 $l_1 \choose j$ 种可能，根据 $k,c_1,c_2$ 和 $j$ 可以算出来 $\ge a_i$ 的部分新分出来多少段，同理就有 ${l_2 \choose k-c_1-c_2-j}$，为使得 $p_i<a_i$，$p_i$ 就有 $c_1+j$ 种取值可能，然后剩下 $k-1$ 段可以任意排列有 $(k-1)!$ 种方案。$p_i=a_{i-1}+1$ 的情况同理，注意这个情况当且仅当 $a_{i-1}+1<a_i$ 且 $\exists x \in \{p_{i \sim n}\},x=a_{i-1}+1$ 是对答案有贡献的，而且这里因为开头不新开一段，上文的 $k$ 要增大 $1$。

显然这个式子是范德蒙德卷积的形式，利用组合数吸收恒等式 ${n \choose m}=\frac{n}{m}{n-1 \choose m-1}$，容易作出以下推导：

$$\begin{aligned}F(k)&=\sum_{j=0}{l_1 \choose j}{l_2 \choose k-c_1-c_2-j}(c_1+j)(k-1)!+\sum_{j=0}{l_1 \choose j}{l_2 \choose k+1-c_1-c_2-j}k!\\&=(k-1)!c_1\sum_{j=0}{l_1 \choose j}{l_2 \choose k-c_1-c_2-j}+(k-1)!l_1\sum_{j=0}{l_1-1 \choose j}{l_2 \choose k-c_1-c_2-1-j}+k!\sum_{j=0}{l_1 \choose j}{l_2 \choose k+1-c_1-c_2-j}\\&=(k-1)!c_1{l_1+l_2\choose k-c_1-c_2}+(k-1)!l_1{l_1+l_2-1 \choose k-c_1-c_2-1}+k!{l_1+l_2\choose k+1-c_1-c_2}\end{aligned}$$

注意对于每个 $p_{i \sim n}$ 对 $F_x$ 的贡献，要考虑前面的数也会增加划分出来的段数，同时还要分类讨论 $i$ 是否是段首来处理答案。这个可以用 DP 转移的形式来实现，记 $h_{i,j}$ 为 $p_{i \sim n},p_{i+1 \sim n}, \cdots$ 对 $F_j$ 的贡献，则若 $a_{i-1}+1=a_i$ 则有 $h_{i,j} \leftarrow h_{i+1,j}+h_{i+1,j-1}$；否则 $h_{i,j} \leftarrow h_{i+1,j-1}$。不要忘记给 $h_{i,j}$ 加上 $p_{i \sim n}$ 自己的贡献。

总时空复杂度 $\mathcal O(n^2)$。

```cpp
#define int long long
const int N=2e3+5;
int n,m,mo,a[N],_C[N][N],f[N],g[N],fc[N];
bool e[N];
int C(int n,int m){
	if(n<m||n<0||m<0)return 0;
	return _C[n][m];
}
signed main(){
	scanf("%lld%lld",&n,&m),mo=m;
	_C[0][0]=1;
	for(int i=1;i<=n;i++){
		_C[i][0]=1;
		for(int j=1;j<=i;j++)_C[i][j]=mpl(_C[i-1][j],_C[i-1][j-1]);
	}
	fc[0]=1;
	for(int i=1;i<=n;i++)fc[i]=fc[i-1]*i%mo;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=n;i;i--){
		if(i>1&&a[i-1]+1==a[i]){for(int _=n;_;_--)mad(f[_],f[_-1]);}
		else{for(int _=n;_;_--)f[_]=f[_-1];f[0]=0;}
		e[a[i]]=1;
		int l1=0,c1=0,l2=0,c2=0;
		for(int j=1;j<a[i];j++)
			if(e[j-1]&&e[j])l1++;
			else if(!e[j-1]&&e[j])c1++;
		for(int j=a[i];j<=n;j++)
			if(e[j-1]&&e[j])l2++;
			else if(!e[j-1]&&e[j])c2++;
		for(int k=0;k<=n;k++){
			if(k)mad(f[k],fc[k-1]*c1%mo*C(l1+l2,k-c1-c2)%mo);
			if(k)mad(f[k],fc[k-1]*l1%mo*C(l1+l2-1,k-c1-c2-1)%mo);
			if(i>1&&a[i-1]+1<a[i]&&e[a[i-1]+1]&&k<n)mad(f[k],fc[k]*C(l1+l2,k+1-c1-c2)%mo);
		}
	}
	for(int i=1;i<=n;i++){
		g[i]=f[i];
		for(int j=1;j<i;j++)mde(g[i],C(n-j,i-j)*g[j]%mo);
		printf("%lld ",g[i]);
	}
	return 0;
}
```


---

## 作者：xtx1092515503 (赞：6)

> 代数推导大脑报废，组合意义巧夺天工。

首先将划分为公差为一的等差数列变成 $n$ 减去所有相邻且差为一的位置数。于是就只需统计相邻差为一的数目。

字典序的限制，不妨先暴力一点直接枚举公共前缀再枚举下一个元素。于是我们有一段后缀，其中元素均可以任意赋值；一段前缀，其中所有元素均已确定。

在值域轴上，前缀中已确定的部分占据了若干点。剩下的未使用元素凭借差一关系构成若干线段。

一个暴力的想法是，二项式反演，钦定若干差一元素必然相邻出现，于是已钦定的部分构成若干连续段，直接一个阶乘即得此时的方案数。除此之外，还要考虑已确定和未确定交界处的对的影响。

将问题抽象。我们可以用什么信息描述一个状态呢？

- $i$，确定的前缀长度。$n-i$ 即为未确定部分长度。
- $j$，前缀中相邻数目。
- $k$，未确定的部分摊在值域轴中的相邻对数目。
- $t=0/1$，指是否存在一个未在已确定部分中出现过的元素，其等于已确定部分中最后一个元素加一。

注意到对于固定的 $i$ 来说，枚举下一个元素，对 $j$ 的影响为不变或加一，对 $k$ 的影响是不变、减一或减二。这意味着，至多仅有线性组不同的 $(i,j,k,t)$，可以对所有四元组各自考虑。

考虑分析 $t$ 的影响。其事实上是将若干中情况的 $j$ 加一，这个影响是可以在 $j$ 中手动剔除、并贡献给 $j+1$ 的，不在话下。现在仅需考虑 $(i,j,k)$ 三元组。对其二项式反演是简单的，但是复杂度是平方的，无法承受。

考虑对数组 $a_i$ 二项式反演得到 $a_i'$ 的组合意义：在 $(0,0)$ 处放置 $a_0$，在 $(0,1)$ 处放置 $a_1$，……，在 $(0,n)$ 处放置 $a_n$；我们令 **向左走一步，权值取反；向上走一步，权值不变**，以此在网格图上作路径计数；则，$(i,i)$ 处的权值和，即为二项式反演后的 $a'_i$。我们有 $a_p=(n-i-1-p)!\dbinom kp$。

现在考虑 $j$ 的影响，其是将 $a_i'$ 作平移。将整个坐标系向右上平移一位，最终结果数组亦向右上平移一位。并且，这样平移后，对于不产生贡献的位置不会产生额外影响。故所有二项式反演数组可直接表示在同一坐标系上，一起二项式反演（也即路径计数）。

复杂度平方。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mod,fac[2010],a[2010];
bool occ[2010];
int arr[2010][2010];
int C[2010][2010];
int main(){
	scanf("%d%d",&n,&mod);
	fac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=0;i<=n;i++)C[i][0]=1;
	for(int i=1;i<=n;i++)for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=0,j=0,k=n-1;i<n;i++){
		int num[2][3][2];memset(num,0,sizeof(num));
		for(int t=1;t<a[i+1];t++)
			if(!occ[t]){
				int dj=(i&&(t==a[i]+1));
				int dk=0,dt=0;
				if(t>1&&!occ[t-1])dk++;
				if(t<n&&!occ[t+1])dk++,dt=1;
				num[dj][dk][dt]++;
			}
		for(int J=j;J<=j+1;J++)for(int K=k;K>=k-2;K--)for(int T=0;T<2;T++)if(num[J-j][k-K][T]){
			int val=num[J-j][k-K][T];
			// printf("%d %d %d %d:%d\n",i,J,K,T,val);
			for(int p=0;p<=K;p++)
				(arr[p+J][J]+=1ll*fac[(n-i-1)-p]*C[K][p]%mod*val%mod)%=mod;
			if(T){
				for(int p=0;p<=K;p++)
					(arr[p+J][J]+=mod-1ll*fac[(n-i-1)-p-1]*C[K][p]%mod*val%mod)%=mod;
				for(int p=0;p<=K;p++)
					(arr[p+J+1][J+1]+=1ll*fac[(n-i-1)-p-1]*C[K][p]%mod*val%mod)%=mod;
			}
		}
		j+=(i&&(a[i+1]==a[i]+1));
		k-=(a[i+1]>1&&!occ[a[i+1]-1]);
		k-=(a[i+1]<n&&!occ[a[i+1]+1]);
		occ[a[i+1]]=true;
	}
	// for(int j=n;j>=0;j--){for(int i=0;i<=n;i++)
	// 	printf("%4d ",arr[i][j]);puts("");}
	for(int i=n;i>=0;i--)for(int j=0;j<=n;j++){
		(arr[i][j]+=mod-arr[i+1][j])%=mod;
		if(j)(arr[i][j]+=arr[i][j-1])%=mod;
	}
	for(int i=1;i<=n;i++)printf("%d ",arr[n-i][n-i]);puts("");
	return 0;
}
```



---

## 作者：_lbw_ (赞：2)

upd on 24.10.9: 修了一些 typo.

定义 $i$ 和 $i+1$ 是相邻的，当且仅当 $a_i+1=a_{i+1}$。

考虑求出有 $k$ 个相邻的方案数，容斥，求出钦定 $k$ 个相邻的方案数，最后二项式反演即可。

枚举 lcp，设现在做到 $i$，前一半有 $a$ 个相邻，假设后一半有 $b$ 个可能相邻的。

这里 可能相邻 指 $(j,j+1)$ 都没被使用过。

接下来我们枚举前一半钦定有 $t_1$ 个相邻，后一半钦定有 $t_2$ 个相邻，则前一半需要在已知的 $a$ 个选出 $t_1$ 个，后一半在 $b$ 中选出 $t_2$ 个相邻，剩下的乱排，写出式子：

$$f_{t_1+t_2}\gets \binom{a}{t_1}\binom{b}{t_2} (b-t_2)!$$

直接枚举 lcp 和 lcp 后一位取什么，时间复杂度 $\mathcal{O}(n^4)$。

我们发现 lcp 后一位取什么对后面 $a,b$ 的影响是 $\leq 2$ 的，我们对于每一种影响算出数量，然后乘一下计入答案即可，时间复杂度 $\mathcal{O}(n^3)$。

我们盯着这个式子看，发现一眼卷积。于是考虑 GF。

我们有两个 GF，一个 $F_a(z)=(1+z)^a$ 一个 $G_i(z)=$ 后面一大坨 $\times z^x$。

最后答案可以表示为 $\mathcal{O}(n)$ 个 $F\times G$ 之和。

显而易见的，$F$ 看上去非常简单，我们将相同 $a$ 的 $F$ 要乘的 $G$ 并在一起，最后答案式子：

$$\sum\limits_{a=0}^n(1+z)^a\times G_a$$

不过并没有什么用，时间复杂度依然是 $\mathcal{O}(n^3)$。

使用秦九韶算法，每次先乘一个 $1+z$ 再加一个 $G$，时间复杂度 $\mathcal{O}(n^2)$。

至此，本题得到了解决。

---


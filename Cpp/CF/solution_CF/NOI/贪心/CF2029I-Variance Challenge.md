# Variance Challenge

## 题目描述

Kevin 最近学会了方差的定义。对于一个长度为 $n$ 的数组 $a$，其方差定义如下：

- 令 $x = \dfrac{1}{n}\displaystyle\sum_{i=1}^n a_i$，即 $x$ 是数组 $a$ 的平均值；
- 那么，$a$ 的方差为
$$
V(a) = \frac{1}{n}\sum_{i=1}^n (a_i - x)^2。
$$

现在，Kevin 给你一个由 $n$ 个整数构成的数组 $a$，以及一个整数 $k$。你可以对 $a$ 执行如下操作：

- 选择一个区间 $[l, r]$（$1 \le l \le r \le n$），然后对于每个 $l \le i \le r$，将 $a_i$ 增加 $k$。

对于每个 $1 \le p \le m$，你需要分别独立地求出恰好执行 $p$ 次操作后，数组 $a$ 的最小可能方差。

为简化问题，你只需要输出答案乘以 $n^2$ 的结果。可以保证结果总是整数。

## 说明/提示

在第一个测试用例中：

- 对于 $p = 1$，你可以在区间 $[1, 1]$ 上操作，将 $a$ 从 $[1, 2, 2]$ 变为 $[2, 2, 2]$。此时所有元素都相等，方差为 $0$。
- 对于 $p = 2$，你可以依次在区间 $[1, 3]$ 和 $[1, 1]$ 上操作，将 $a$ 从 $[1, 2, 2]$ 变为 $[2, 3, 3]$，再变为 $[3, 3, 3]$。此时所有元素都相等，方差为 $0$。

在第二个测试用例中，一些可能的最优选择为：

- $p=1$：$[\underline{1,}\,2,2] \to [3,2,2]$；
- $p=2$：$[1,\underline{2,2}] \to [\underline{1,}\,4,4] \to [3,4,4]$。

在第三个测试用例中，一些可能的最优选择为：

- $p=1$：$[10,\underline{1,1,1,1,10,1,1,1,1}] \to [10,2,2,2,2,11,2,2,2,2]$；
- $p=2$：$[10,1,1,1,1,10,\underline{1,1,1,1}] \to [10,\underline{1,1,1,1},10,2,2,2,2] \to [10,2,2,2,2,10,2,2,2,2]$。

在第八个测试用例中，对于所有 $p$，最优选择都是每次对整个数组操作。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
9
3 2 1
1 2 2
3 2 2
1 2 2
10 2 1
10 1 1 1 1 10 1 1 1 1
6 8 2
1 1 4 5 1 3
8 8 7
20 43 24 2 4 3 20 43
8 8 3
20 43 24 2 4 3 20 43
10 12 1
5 3 3 5 4 1 8 1 1 1
13 10 100000
1 2 3 4 5 6 7 8 9 10 11 5 4
10 5 10000
2308 9982 4435 3310 100000 9 7 8100 1919 100000```

### 输出

```
0 0
2 2
1161 1024
53 21 21 5 5 5 5 5
10608 6912 4448 3104 1991 1312 535 304
13248 11184 9375 7815 6447 5319 4383 3687
385 316 269 224 181 156 124 101 80 56 41 29
1486 1486 1486 1486 1486 1486 1486 1486 1486 1486
134618047140 119919447140 107020847140 93922247140 82623647140```

# 题解

## 作者：Petit_Souris (赞：4)

### I Variance Challenge

非常深刻的一题！

**难点：不去想多项式复杂度的 DP。** 虽然我感觉这件事就是纯抽奖啊，我验题的时候想了大半天怎么优化 $\mathcal O(n^2m^3)$ 的 DP，结果被干飞了。

**关键观察：** 对于函数 $f(x)=\sum (a_i-x)^2$，其最小值的 $\frac{1}{n}$ 倍即为方差。证明只需要考虑将这个东西当作二次函数，那么对称轴即为所有 $a_i$ 的平均数。

我们发现可能的平均值种数并不多，只有 $nm+1$ 种。我们可以枚举这 $nm+1$ 种 $x$，并对于 $i\in [1,n]$ 计算操作 $i$ 次后 $f(x)$ 的最小值。你可能想问这里如果操作的区间长度之和不符合 $x$ 的限制怎么办，实际上由于上面这个观察，这样的情况只会把答案算大，所以不存在任何影响。

那么现在问题变为：

- 给定正整数 $x$，你可以对恰好 $i$ 个任意区间执行区间 $+k$ 操作，求操作结束后 $\sum (a_i-x)^2$ 的最小值。

这实际上是一个很经典的反悔贪心问题。可以把费用流的图建出来，那么增广路只有以下两种形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/k9tnp0if.png)

红色表示增加一次操作，绿色表示减掉这段操作（注意这意味着要求这段每条边都至少经过一次，否则反向弧不存在）。由于这个代价函数是个二次函数，是凸的，所以可以直接差分拆开，每次一定会选最小的那条走。所以直接模拟这件事情就行了，每次找最小子段和即可。时间复杂度 $\mathcal O(n^2m^2)$。

注意开 i128，注意实现常数。我的写法太烂了，卡了半天常，谴责 ey/fn

[submission](https://codeforces.com/contest/2029/submission/290868793)，取得了最劣解，cooooool。

---

## 作者：ForgotMe (赞：3)

破防了，研究了一晚上的模拟费用流，发现自己唐到居然以为非增量模拟费用流会让源汇退流/lh。

首先需要一个非常关键的转化：对于函数 $f(x)=\sum_{i=1}^{n}(a_i-x)^2$，当 $f(x)$ 取到最小值的时候，$x=\frac{\sum_{i=1}^n a_i}{n}$，也就是说 $f(x)$ 的最小值等价于方差。那么就可以抛开 $x$ 是 $a_i$ 的平均值的限制，枚举 $x$ 的值，直接去计算 $f(x)$ 的最小值。

问题现在转化为已知一个数 $x$，现在进行 $p$ 次区间加操作，让 $\sum_{i=1}^n (a_i-x)^2$ 最小。这个问题比较困难。考虑使用最小费用最大流：

- 对于 $1\le i\le n+1$，连一条 $s$ 到 $i$ 的边，一条 $i$ 到 $t$ 的边。

那如何刻画新选择的区间对答案造成的 $\Delta$ 呢？先看只选择一个区间

- 对于 $1\le i\le n$ 连一条 $i$ 到 $i+1$ 容量为 $1$，费用为 $(a_i-x+k)^2-(a_i-x)^2$ 的边。

那么上图的最短增广路就是 $p=1$ 的解。如何扩展到任意 $p$ 呢？

考虑拆点，对于 $1\le i\le n$，将其拆成 $m+1$ 个点，分别编号为 $id_{i,0\sim m}$，连边改成 $id_{i,0}$ 向 $id_{i,j}$ 连一条容量为 $1$ 费用为 $(a_i-x+jk)^2-(a_i-x+(j-1)k)^2$ 的边，最后记得要让 $id_{i,j}$ 向 $id_{i+1,0}$ 连边，$id_{i,0}$ 分别与 $s,t$ 两边。

请注意上图的正确性在于应先把 $id_{i,0}$ 到 $id_{i,1\sim k}$ 的边都流了才能流 $id_{i,k+1}$，但是最小费用最大流是不能保证这一点的。但是这个代价非常的特殊，$(a_i-x+jk)^2$ 这个函数是凸的，换个说法，$(a_i-x+jk)^2-(a_i-x+(j-1)k)^2=k(2a_i-2x+(2j-1)k)$，这东西随着 $j$ 越来越大，所以不会出现跳着流的情况。

如果直接对上图跑 MCMF，肯定会 TLE。考虑模拟费用流，这是一个非增量模拟费用流，源汇都不会退流。手玩一下这个图发现只会有两种合法的增广路：

下面称 $id_{i,0}\rightarrow id_{i,j},id_{i,j}\rightarrow id_{i+1,0}$ 为正向边，$id_{i,j}\rightarrow id_{i,0},id_{i+1,0}\rightarrow id_{i,j}$ 为反向边（即相当于反悔）。

- $s$ 到某个 $id_{x,0}$ 然后只走正向边走到 $id_{y,0}(y>x)$ 然后走到 $t$。其意义等价于选择区间 $[x,y-1]$ 让其多加一次，那么求一个最大子段和即可。

- $s$ 到某个 $id_{y,0}$ 然后走反向边走到 $id_{x,0}(x<y)$ 然后走到 $t$。其意义等价于对区间 $[x,y-1]$ 进行反悔，让其减少一次，同样的，也只需要求一个最大子段和。（注：当一个点一次都没加时，是不能反悔的）

那么本题基本上做完了，最后发现 $x$ 只有 $n\times m$ 种，于是直接跑就行。（一个小细节是先把答案的 $n^2$ 乘进去，变成 $\sum_{i=1}^n (na_i-x)^2$，$k\leftarrow k\times n$，避免 $x$ 出现不是整数的情况，最后再把答案除以 $n$ 即可）。中间变量可能会爆 long long，应使用 __int128。时间复杂度 $\mathcal{O}(n^2m^2)$，6s 足以跑过。

扔个代码：https://www.luogu.com.cn/paste/bx86v9be

---

## 作者：zhouxianzhuo (赞：0)

性质：函数 $f(x)=\sum_{i=1}^n(a_i-x)^2$ 在 $x=\bar{a}$ 时取到最小值，且最小值为方差乘 $n$。

因为总共进行 $m$ 次操作，每次操作最多令 $n$ 个 $a_i$ 加 $k$，所以平均数可能的取值有 $n\times m$ 个。

枚举每一种可能的取值，设为 $x_0$，建立费用流模型。即令源点、汇点都与每个点各连一条流量为 $1$、费用为 $0$ 的边；对于 $1$ 到 $n$ 每个点，$i$ 号点都向 $i+1$ 号点连 $m$ 条边，流量均为 $1$，第 $j$ 条边的费用为 $(a_i+j\times k-x_0)^2-(a_i+(j-1)\times k-x_0)^2$，跑最小费用流。

可以使用最小子段和进行模拟，由于边的编号越大，正边的费用越大，反边的费用越小，所以正边的编号越小越好，而反边的编号则越大越好，因此最优的正边与反边一定相邻，用一个数组记录正边最小编号即可。

代码如下，具体看注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
const __int128 inf=1e25;
int n,m,k,a[5010],p[5010];
long long sum,b[5010];
__int128 ans[5010];
long long calc(int i,int j){
	return (b[i]+j*k)*(b[i]+j*k)-(b[i]+(j-1)*k)*(b[i]+(j-1)*k);
}
void solve(long long x){
	__int128 flow=0;
	for(int i=1;i<=n;i++)
	{
		b[i]=a[i]-x;
		flow+=b[i]*b[i];
		p[i]=0;
		//p[i] 表示第 i 个位置已选的编号最小的正边的编号 
	}
	for(int j=1;j<=m;j++)
	{
		int l,r,lst,op;
		//l、r 分别记录选取子段的左、右端点，lst 记录当前最小后缀的左端点，op 记录所取子段是正边还是反边 
		__int128 rm=inf,mi=inf;
		//rm 记录最小后缀和，mi 记录最小子段和 
		for(int i=1;i<=n;i++)
		{
			__int128 ts=calc(i,p[i]+1);
			rm=min(rm+ts,ts);
			if(rm==ts)lst=i;
			if(rm<mi)
			{
				mi=rm;
				l=lst;
				r=i;
				op=1;
			}
		}
		rm=inf;
		for(int i=1;i<=n;i++)
		{
			__int128 ts=-calc(i,p[i]);
			if(p[i]==0)ts=inf;
			//如果当前位置没取过正边，则没有反边可取 
			rm=min(rm+ts,ts);
			if(rm==ts)lst=i;
			if(rm<mi)
			{
				mi=rm;
				l=lst;
				r=i;
				op=-1;
			}
		}
		for(int i=l;i<=r;i++)
			p[i]+=op;
		//更新正边最小编号数组 
		flow+=mi;
		ans[j]=min(ans[j],flow);
	}
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d",&n,&m,&k);
		k*=n;
		sum=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			sum+=a[i];
			a[i]*=n;
		}
		//为了避免平均值是小数，先将代入函数的所有值乘 n，则最后求出的值是方差的 n^3 倍，也就是答案的 n 倍 
		for(int j=1;j<=m;j++)
			ans[j]=inf;
		for(int i=1;i<=n*m;i++)
			solve(sum+k/n*i);
		//枚举所有可能的平均值，找到最小答案 
		for(int j=1;j<=m;j++)
			printf("%lld ",(long long)(ans[j]/n));
		printf("\n");
	}
	return 0;
}
```

---


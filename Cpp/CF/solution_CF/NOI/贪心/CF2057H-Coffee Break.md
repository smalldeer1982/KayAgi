# Coffee Break

## 题目描述

T-Generation 的课程十分漫长。在一天中，必须安排时间来分析训练和专题比赛，讲解新内容，并在可能的情况下，举行一个小型研讨会。因此，课间休息时学生们会去喝咖啡或聊天。

走廊上总共有 $n+2$ 台咖啡机，依次排列。咖啡机编号从 $0$ 到 $n+1$，当休息开始时，第 $i$ 台咖啡机周围聚集了 $a_i$ 名学生。

由于学生们说话声太大，老师需要进行一个重要的通知。因此，他们希望将尽可能多的学生聚集到某一台咖啡机周围。不过，老师们懒得亲自去召集学生，想出了一种巧妙的方法：

- 随时可以选择房间 $i$（$1 \le i \le n$）并关闭那里的灯；
- 如果该房间有 $x$ 名学生，关灯后，$\lfloor \frac{1}{2} x \rfloor$ 名学生会去左边的房间 $(i-1)$，另外 $\lfloor \frac{1}{2} x \rfloor$ 名学生会去右边的房间 $(i+1)$；
- 如果 $x$ 是奇数，则有一名学生留在原位；
- 随后再次打开房间 $i$ 的灯。

老师们尚未决定最终要在何处聚集学生，因此需要计算，对于每个 $i$ 从 $1$ 到 $n$，在第 $i$ 台咖啡机周围最多能聚集多少名学生。

老师们可以任意顺序、任意次数选择关灯，可以在同一个房间多次操作。

需要注意的是，$a_0$ 和 $a_{n+1}$ 的值对结果没有影响，因此不需要考虑这两个值。

## 说明/提示

举个例子，分析第一个测试用例：

- 为了让第 $1$ 台咖啡机周围的学生人数最大化，只需要保持现状。
- 为了让第 $2$ 台咖啡机周围的学生人数最大化，只需在第 $1$ 个房间关一次灯。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
2
8 0
5
2 2 2 2 2
5
0 0 9 0 0```

### 输出

```
8 4 
4 5 4 5 4 
4 6 9 6 4```

# 题解

## 作者：ForgotMe (赞：4)

结论题，敢猜就敢过。

首先读完这个题脑子里很快会冒出一个猜测：这个**最大化**是不是就是拿来搞笑的。如果要最大化 $a_k$，不操作 $k$ 其他能操作就操作感觉就是正确的，而且这个操作顺序似乎对答案并没有影响。

如果你猜到了这个关键结论，那么恭喜你，这个题基本上已经做出来一半了。这个结论的确是正确的！那这个结论能否严格证明呢？查阅了一下官方题解，感觉说了一堆没用的废话，有没有懂哥给个严谨的证明啊？

如果暴力地去操作能操作的地方，显然是会超时的。考虑另外一个结论：定义操作 $I_p$ 为选择一个位置 $p$，将 $a_p$ 减去 $2$，$a_{p-1},a_{p+1}$ 加上 $1$。显然多次操作 $I_p$ 可以组合出题目中的操作，但是这两种操作是否可以等价替换呢？如果你能够理解最开始的结论，即操作的顺序对答案没有影响，那么你就可以看出这两种操作是可以等价替换的！

现在应用上面这个结论去加速题目中的操作。假设现在已经把区间 $[1,p]$ 都变成了 $0/1$，并把 $a_0,a_{p+2}$ 看做边界，现在要加入一个数 $a_{p+1}$，然后把 $[1,p+1]$ 变成 $0/1$，并需要统计 $a_{p+2}$ 加了多少。考虑离 $a_{p+1}$ 最近的一个 $0$，其位置为 $t$。那么区间 $[t,p+1]$ 形如 $[0,1,1,\cdots,1,a](a\ge 2)$。

- 如果 $t=p$，那么操作一下 $p+1$ 会变成 $[1,a-2]$，且 $a_{p+2}$ 会加上 $1$。
- 如果 $t< p$，手动模拟一下会发现其变成了 $[1,0,1,\cdots,1,a-1]$，即 $0$ 的位置 $t$ 变成了 $t+1$，且 $a_{p+1}$ 的值少 $1$，$a_{p+2}$ 的值多 $1$。

总结一下，如果 $a\ge p+2-t$，那么 $a_{p+1}$ 会减去 $p+2-t$，然后 $a_{p+2}$ 加上 $p+1-t$，这个 $0$ 会消失变成 $1$（$a_t=1$）。

需要注意的一个 corner case 是如果 $[1,p]$ 中不存在 $0$ 怎么办？由于 $a_0$ 是不能操作的，且其值并不重要，**可以将其一直视作 $a_0=0$**，那么 $t$ 是一直存在的。

当然，如果 $a< p+2-t$，那么意味着这个 $0$ 消不掉，可以快速计算出其移动的距离，从而找到这个 $0$ 新的位置。

至此，所以的情况都已讨论完毕，为了方便实现，将所有 $0$ 的位置放进一个栈 $S$ 中，注意到栈 $S$ 最多进出 $\mathcal{O}(n)$ 次，于是复杂度为 $\mathcal{O}(n)$。

给个写得比较清晰的代码：https://www.luogu.com.cn/paste/kf4ya593

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/CF2057H)

**题目大意**

> 给定 $a_1\sim a_n$，一次对 $i$ 的操作会令 $a_i\gets a_{i}\bmod 2,a_{i-1}\gets a_{i-1}+\lfloor\frac {a_i}2\rfloor,a_{i+1}\gets a_{i+1}+\lfloor\frac {a_i}2\rfloor$，对于每个 $k\in [1,n]$ 求出若干次操作后 $a_k$ 能达到的最大值。

**思路分析**

根据贪心，我们肯定不可能操作 $a_k$，并且其他的 $a_i$ 如果 $\ge 2$ 肯定会操作。

那么我们的操作实际上和 $a_i\gets a_i-2,a_{i-1}\gets a_{i-1}+1,a_{i+1}\gets a_{i+1}+1$ 是等价的，因为我们肯定会把所有的 $a_i$ 操作到 $\le 1$。

那么动态维护 $a[1,i]$ 最多能向 $a_{i+1}$ 传递多少权值，然后翻转序列再做一遍。

考虑 $i-1\to i$ 的转移：先操作 $a_{1\sim i-1}$ 直到不能操作，然后加入 $a_i$。

找到 $a_{1\sim i-1}$ 中最后一个 $0$，设为 $a_j$，此时序列为 $[0,1,1,\dots,a_i]$，如果我们操作一次 $a_i$，那么接下来会依次操作 $i-1,i-2,\dots j+1$，序列变为 $[1,0,1,\dots,a_i-1]$，并且令 $a_{i+1}$ 加一。

不断进行这个操作，发现我们可以进行 $i-j$ 轮，会使得 $a_{j\sim i-1}=1$，$a_i$ 减去 $i-j+1$，$a_{i+1}$ 加上 $i-j$。

那么用一个栈动态维护当前剩下的所有 $0$ 的位置，手动模拟上述过程。

特殊处理 $j=0$ 的情况，此时相当于栈中有 $\infty$ 个 $j=0$ 的元素，快速计算操作总轮数即可。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h> 
#define ll long long
using namespace std;
const int MAXN=1e6+5;
int n,st[MAXN];
ll a[MAXN],b[MAXN],f[MAXN];
void sol(bool op) {
	for(int i=1,tp=0;i<=n;++i) {
		ll z=0;
		while(tp) {
			int d=i-st[tp];
			if(b[i]>d) b[i]-=d+1,z+=d,--tp;
			else break;
		}
		if(!tp) {
			ll c=b[i]/(i+1);
			b[i]-=(i+1)*c,z+=i*c;
		}
		if(b[i]>1) {
			z+=b[i]-1;
			if(tp) st[tp]+=b[i]-1;
			else st[++tp]=b[i]-1;
		} else if(!b[i]) st[++tp]=i;
		b[i+1]+=z,f[op?n-i:i+1]+=z;
	}
}
void solve() {
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i],f[i]=a[i];
	copy(a+1,a+n+1,b+1);
	sol(0);
	copy(a+1,a+n+1,b+1);
	reverse(b+1,b+n+1);
	sol(1);
	for(int i=1;i<=n;++i) cout<<f[i]<<" \n"[i==n];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int _; cin>>_;
	while(_--) solve();
	return 0;
}
```

---


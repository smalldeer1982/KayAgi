# Even Odds

## 题目描述

## 题目大意

作为一个不顺从的人， $Volodya$  不喜欢当前的事物状态，特别是自然数的顺序（自然数是正整数）。他决心重新安排他们。但是自然数太多，所以 $Volodya$ 决定从 $n$ 开始。他写出下面的数列：首先是从1到 $n$ 的所有奇数整数（以升序排列），然后从1到 $n$ 的所有偶数整数（也按升序排列）。帮助我们的英雄找出：第 $k$ 个数字是多少

## 样例 #1

### 输入

```
10 3
```

### 输出

```
5```

## 样例 #2

### 输入

```
7 7
```

### 输出

```
6```

# 题解

## 作者：Register (赞：11)

### 为什么大家都要用for？本蒟蒻的方法似乎要好一些：
	算出n个数里奇数的个数，就可以知道k是奇数还是偶数了
    偶数：（k-奇数个数）*2
    奇数：k*2-1
话不多说，上代码：
```cpp
#include <iostream>
#include <cmath>//ceil需要的库
using namespace std;
int main(){
	int n,k;
	cin>>n>>k;
	int odd=ceil(n/2.0);//算出奇数个数
	if(k>odd) cout<<(k-odd)*2<<endl;//是偶数
	else cout<<k*2-1<<endl;//是奇数
	return 0;
}
```

---

## 作者：sinsop90 (赞：3)

这道题要是用循环来跑

O(n) = 1.2秒,超时

所以必须想一个另外的办法

由题目可知分为两个部分

一个部分为奇数,一个部分为偶数

在n = 偶数时,奇数数量 = 偶数数量

反之,奇数数量 = 偶数数量+1

所以我们判断一下k是在哪一个部分,若是在偶数

就用(k-奇数数量)*2

反之就用2*k-1

所以就有如下代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,k,p;//10^12>2147483647
	cin>>n>>k;
	if(n%2==1){
		p = n/2+1;//奇数数量 = 偶数数量+1
	}
	else{
		p = n/2;//奇数数量 = 偶数数量
	}
	if(k>p){
		cout<<(k-p)*2<<endl;
	}
	else{
		cout<<2*k-1<<endl;
	}
}

```


---

## 作者：呵呵侠 (赞：3)



$\text{Update：2019/08/23}$ 这篇题解刚刚写好，提交了上去。

$\text{Update：2020/03/14}$ 把原本没选择语言的代码框架改成了cpp语言，随后写了当初不会写的$\LaTeX$。

------------

# 这是一种极其简单的做法！！

这一题，正常人的思路是循环：

代码如下（有误）：
```cpp
#include <iostream>
using namespace std;
int main()
{
    int a,b,c=0;
    cin>>a>>b;
    int p[a];
    for(int i=1;i<=a;i+=2){
        if(c==b-1)
        {
            cout<<i;
            return 0;
        }
        c++;
    }
    for(int i=2;i<=a;i+=2){
        if(c==b-1)
        {
            cout<<i;
            return 0;
        }
        c++;
    }
}
```
感觉挺对的，为什么$\text{T}$了呢？

注意数据范围！！！

$10^{12}$这个大小

$\text{TLE}$很正常

但是我非常懒

优化循环？？？不存在！！！

于是我又有了第二种思路：

输入$k,n$（代码中是$a,b$），然后用分支结构解决问题

### 第一种情况：$n\le k/2$

众所周知，这个人脑筋不正常

非要把奇数排在前面，偶数排在后面

所以前$k/2$个数一定是奇数

当$n\le k/2$时

输出一个奇数

这是第$n$个奇数

所以输出$n*2-1$

### 第二种情况：

你有没有想过，还有一种情况也能出奇数

没错

在$1$~$k$的范围内，奇数和偶数要么相等，要么是奇数比偶数多一个

也就是说，当$k \bmod 2=1$时

$k/2+1$是奇数

也是第$n$个奇数

同样输出$n*2-1$

然后，就不可能输出奇数了

输出偶数

### 第三种情况：

此时$a \bmod 2=0 $

由于前$a/2$个数都是奇数

所以偶数就要先拿$n$减去$a/2$

然后，第$n$个偶数用$n*2$

### 第四种情况：

此时$a \bmod 2=1$

由于前$a/2+1$个数都是奇数

所以偶数就要先拿$n$减去$(a/2+1)$

然后，第$n$个偶数用$n*2$

```cpp
#include <iostream>
using namespace std;
int main()
{
    long long a,b,c=0;
    cin>>a>>b;
    int p[a];
    if(b<=a/2)
        cout<<b*2-1;
    else if(a%2==1&&b==a/2+1)
        cout<<b*2-1;
    else if(b==a/2&&a%2==0)//保险起见，我写上这个
        cout<<b*2-1;
    else if(a%2==0)
        cout<<(b-a/2)*2;
    else
        cout<<(b-a/2-1)*2;
}
```

---

## 作者：CZQ_King (赞：1)

py前来报道

------------
思路：

当你看到数据范围时，你会发现模拟根本过不去，那么就必须要用到优化或公式。

这里使用公式。

首先，数组是很有规律的，先是奇数然后偶数，那么我们只需要判断$k$在奇数部分还是在偶数部分，然后再套用求第$m$个奇数或偶数的公式，输出即可。

$$\text{第$n$个偶数}=2n$$

$$\text{第$n$个奇数}=2n+1$$

判断$k$在奇数部分还是偶数部分的公式：

$$\lceil\frac n2\rceil$$

为什么向上取整呢，因为如果$n$是奇数，那么小于等于$n$的奇数有$\lceil\frac n2\rceil$个，而不是$\frac n2$个。

------------
代码：
```python
import math# ceil需要
n,k=map(int,input().split())
a=math.ceil(n/2)# 奇数还是偶数
print(2*(k-a)if(k>a)else 2*k-1)# 分类讨论
```

---

## 作者：Hexarhy (赞：1)

虽然是一道入门题，然而奇特的数据量导致会TLE。那我们采取什么策略？说出来你不信：

### 能优化就优化！卡时间（主要是for加速）

奇特的是我竟然AC了：

	提交时间 2018-08-03 09:14:08
	耗时/内存 692ms, 16KB

不多说，开始讲思路：


------------


1） 最好用scanf和printf，因为这样比cin和cout更快~~（然而并无卵用）~~

2）位运算是能用就用，比如这里我们要判断n是奇数还是偶数，那么就用n&1的位运算判断。这里就很有必要跟广大新手说说&（按位与）

	   为什么行呢？因为n会转为2进制，只有0和1。而&是双方都是1，返回1，否则0，这样&1会很奇妙，不可忽略的是1前面的自动补0。举个例子：
      
		4&1->100&001->000
		3&1->11&01->01
		7&1->111&001->001
		10&1->1010&0001->0000

		结果很明显：奇数&1返回1，偶数并1返回0。∵奇数在二进制里的末尾一定是1，偶数则一定是0，加上（后者的）1前面的补0，那么前面一定是0，关键是最后一位，∴自行continue
     
3）说了这么多，为什么要判断奇偶呢？因为要**加速**，减少for循环量！取奇偶，主要是找出奇数序列与偶数序列的分界线，即**最后一个奇数**，再与k比较一下，如果k比分界线大，那就直接找偶数，反之亦然。至于分界线怎么求，自己想吧（很简单哟(＾Ｕ＾)ノ~）

4）不得不提的是，枚举奇数序列的初始值最好不要定1开始，因为奇数是从1开始算的，所以定1-2=-1，偶数亦然。当然具体情况还是要看你的循环是怎么算的。

------------

献上完整代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;//懒得打那么多long long
ll n,k,t,j;
int main()
{
	scanf("%I64d%I64d",&n,&k);//按题目要求来
	t=n/2+bool(n&1);//这里是个简写。根据规律可以知道，奇数序列的分界线总是比中间数的位置多1个，正好n&1为奇数时返回1，否则0，那就直接相加就好了。PS：C++奇数/2自动向下取整，因此直接除就好
//	(n&1?(n/2+1):(n/2));这是另外1种写法。条件表达式?:相当于if…else…
	if(t>=k)//跟k比一下看是在奇数当中还是偶数当中
	{//奇数部分
		j=-1;//注意初始值
		for(int i=1;i<=k;i++)
	     j+=2;
	} 
	else
	{//偶数部分
		j=0;//注意初始值
		for(int i=1;i<=k-t;i++)//枚举时注意枚举的个数是k-t，要减去前面的奇数个数
		 j+=2;
	}
	printf("%I64d",j);//按要求输出……
    
    while(1);
	return string::npos;
} 
```

~~上面2行什么东西我就不说了自己用脚趾想吧~~

---

## 作者：OdtreePrince (赞：1)

# -模拟-

蒟蒻发题解，大佬不喜勿喷！ ^-^ 

这道题根据我的做法就是分类讨论，逐步模拟，代码虽长，但精髓全在其中。

这道题的翻译有一点不知为何意——请不要使用%lld说明符来读取或写入C++中的64位整数。最好使用cin、cut流或%I64d说明符。

可能是蒟蒻我见少识少吧！

这道题要讲解讲不来，还是上代码吧！

~~~
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n,k;
    scanf("%I64d%I64d",&n,&k);
    if(n%2==1){
        long long t=(n-1)/2+1;
        if(t>=k){
            long long j=-1;
            for(long long i=1;i<=k;i++){
                j+=2;
            }
            cout<<j;
        }
        else{
            long long j=0;
            for(long long i=1;i<=k-t;i++){
                j+=2;
            }
            cout<<j;
        }
    }
    else{
        long long t=(n-2)/2+1;
        if(t>=k){
            long long j=-1;
            for(long long i=1;i<=k;i++){
                j+=2;
            }
            cout<<j;
        }
        else{
            long long j=0;
            for(long long i=1;i<=k-t;i++){
                j+=2;
            }
            cout<<j;
        }
    }
    return 0;
}
~~~

---


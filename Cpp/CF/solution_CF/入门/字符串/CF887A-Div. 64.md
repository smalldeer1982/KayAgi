# Div. 64

## 题目描述

超模$Izabella$ 参加了比赛。她想要给评委留下深刻的印象并且展示她的数学技能。

她的问题如下：对于一个只由$0$ 和$1$ 组成的字符串，判断是否能删掉一些数字，使得得到的二进制数能被$64$ 整除。

## 样例 #1

### 输入

```
100010001
```

### 输出

```
yes```

## 样例 #2

### 输入

```
100
```

### 输出

```
no```

# 题解

## 作者：_StarBird_ (赞：12)

# CF887A Div. 64 题解
=
## 写在前面的闲话
-

~~您现在正在收看的是蒟蒻jch的题解~~

蒟蒻感觉这题明显恶评啊，是~~黄题~~

虽然这是道~~黄~~红题，但本蒟蒻还是控制不住篇幅，写的挺长（对于~~黄~~红题来说），可能会占用您的时间，请谅解（逃

本蒟蒻的第二篇题解，求支持qwq


## **正题开始！**
-

这题大意就是给一个二进制串，问能否在串中删一些数，使得这个串能被十进制中的64整除。

很容易发现，只要是能删成十进制中的64（$2^6$)，也就是二进制中的1000000，因为64能被64整除，所以这个串也能被64整除。

这题其实已经做完了，但为了逻辑的严谨性（我经常提到这点）（路人：啊你不是说这是第二篇题解么 本菜鸡：@#￥%&*！……），我们还要证明不满足这个条件的就不行。

### ~~丑陋而啰嗦~~华丽丽的证明过程：
其实很多神仙们应该早就反应过来为毛了，但为了~~刷题解长度~~照顾装弱装到我那么菜的巨佬们，我还是写一下吧。

#### 要使得这个串能删成1000000，有3个条件：
```
   1.有1个1；
 
   2.有6个0； 

   3.0在1的右边；
 
```

 所以，我们对每一个条件，逐一分析不满足的情况：

 不满足情况1，只有一种可能，那就是0，根据题意，0要输出的是no（别问窝为神马，我就这么错过一次，[错了的提交记录](https://www.luogu.com.cn/record/27860271)
 [in CF](http://codeforces.com/problemset/submission/887/65892953)
 
 ps:以上有2个链接
 
  不满足情况2和3，用的是同一种证明方法。
  
  能被64整除的二进制串，最小的是1000000，其次是10000000，11000000……不删成100000，只能删成这些数。而它们在十进制中是64，128，172……可以看到，两个数列都是等差数列，公差为64，也就是二进制中的100000。因此，这个数的后6位一开始是0，后来又不断加0，无论如何只能是0，换句话说，1的后面必须有6个0。也就是说，必须要有6个0，且0在1右边，才能满足要求。因此，不满足条件2或3，也不能删成能被64整除的数。
 
 **于是，我们得出了这题的证明过程。**
 
 所以，这题的做法，就是看能否在1后面找到6个0，可以就输出yes，不可以就输出no，就????了。
 
 最近有一次考试，因为码风的问题掉了很多分，被批了，因此痛改前非，什么bits啥的统统用上，int main里的括号不写void了，register，short，string，cin优化啥的都不用了，常用的cin,cout也改成了scanf，就是热衷的压行还没有丢（老师也压行）。感觉码风的转变还是挺五味杂陈的，虽然我是强迫症，可以在好几种码风同时切换（捂嘴）
 
 你们最爱的——~~求点赞关注~~上代码qaq：
 
```cpp
//老套路，（虽然这只是我的第二篇题解）建议的阅读程序顺序：头文件区（自己编的）->主程序->主程序顺序下的子函数
#include<bits/stdc++.h>//最近也改成了万能库
using namespace std;
bool flag=false;//记录第一个1 （此题不能不管1，虽然非零的2进制数一定以1开头，但不能落掉1，否则会WA(本蒟蒻的惨痛经历））
int cnt=0;//记录0的个数
char t[110];//输入的二进制串
int main()
{
	scanf("%s",t+1);//读入字符串（废话）,本菜鸡习惯从1开始存
	int len=strlen(t+1);//字符串的长度，注意从1开始存要加1
	for(int i=1;i<=len;++i)//扫一遍整个字符串
	{
		if (t[i]=='1') flag=true;//如果找到1，打上标记
		if (flag&&t[i]=='0') ++cnt;//在找到1时再统计0的个数
		if (cnt==6) {printf("yes\n");return 0;}//找完6个0就OK
	}
	printf("no\n");//没找到就失败
	return 0;//功德圆满
}
```
/*

100010001

yes

100

no
*/

ps:某ZJ菜鸡喜欢在代码后面粘样例

因为Ctrl + C= c t r l c=chang tiao rap lanqiu caixukun=唱跳rap篮球蔡徐坤；因此，代码在此，切勿copy！

## 写在最后

-
我还是喜欢给CF的题写题解，不知道是为毛，难道是因为~~崇洋媚外，卖国求荣~~你谷上做的人少?


~~呼，终于写完了~~

~~呼，终于看完了~~

题解就到这里，再次感谢您的时间，如有不当之处请私信或在此留言，拜拜qaq!

谢谢管理员大大的审理qwq

# **The end.**

---

## 作者：lxgw (赞：2)

## 题意
输入一个二进制数，判断它在删掉若干个数字后能被 64 整除

## 思路：
**因为$64=2^6$ $=$ $(1000000)_2$,所以只用求出第一次出现的 $1$ 后面是否有 $6$ 个 $0$ 即可（把第一个1后面的全部1都删了就行了）**

例：$(1001000011)_2$ $->$ $(1000000)_2$	


## 代码:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string a;
int num; //计算0出现的次数
bool v = false;  //判断1是否出现过
int main() {
    cin >> a;
    for (int i = 0; i < a.size(); i++) {
        if (a[i] == '0')
            num++;//累加0的个数
        if (a[i] == '1') {
            if (!v)
                num = 0;  //如果1是第一次出现的，就将之前0的数量清零（前导零）
            v = true;//记录1已经出现过了
        }
        if (num == 6 && v) {
            cout << "yes";
            return 0;
        }  //如果已经有6个0且不是前导零，就输出yes
    }
    cout << "no";
    return 0;
}

```
###### 完结撒花~
拜拜 $qwq$

---

## 作者：chufuzhe (赞：2)

这道题就是问这个二进制数能不能在去掉几个数以后被64整除。

因为64的二进制是1000000，有六个零。所以只有末尾有六个零是才能被64整除。

现在要解决的问题就是求出这个数能否在去掉几个数以后末尾是六个零。

这个数如果能满足在去掉几个数以后末尾是六个零，就要具备具备相面几个条件：

1.有6个及以上的0。如果有6个0，就可以吧多余的1给去掉，这样就可以让0都在末尾。

2.至少有1个1。如果没有1，不管0有多少，转化成十进制都是0，不被64整除。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string a;
	int s=0; //0的个数
	cin>>a; //输入
	for(register int i=0;i<a.size();i++)
		s+=(a[i]=='0'); //统计0的个数
	if(s>=6) puts("yes"); //判断
	else puts("no");
	return 0;
}
```

然后在第11个点就WA了。

## 3. 1后面必须有6个及以上的0。

所以还有加一个判断。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string a;
	int s=0;
	bool b=0; //是否有1出现过
	cin>>a;
	for(register int i=0;i<a.size();i++)
	{
		if(a[i]=='1') b=1; //出现过1
		if(b) s+=(a[i]=='0'); //1后面有0
	}
	if(s>=6) puts("yes"); //判断
	else puts("no");
	return 0;
}

```


---

## 作者：午尘 (赞：1)

```cpp
#include <bits/stdc++.h>
using namespace std;
char st[10001];
int i,j,k,n,m,ans;
int main(){
	cin>>st;
	k=-1;
	for (i=0;i<strlen(st);i++) 
	  if (st[i]=='1') {k=i;break;}
	  ans=0;
	for (i=k;i<strlen(st);i++) 
	  if (st[i]=='0') ans++;
	if (ans>=6 && k!=-1) cout<<"yes"<<endl;
	     else   cout<<"no"<<endl;
	return 0;
}
```
这题的基本思路就是二进制的权值，比如：

```
//二进制10010=1*16+1*2=18
```

所以，易得，删完的数必须在后六位都有0，方可被2^6整除。

然后小坑点就是：

k要赋初值啊~

不然的话。。000000000这种数据是过不了的qwq……






---

## 作者：bym666 (赞：1)

# CF887A 【Div. 64】
这道题让我们判断在删掉一些数字之后这个由0和1组成的的二进制数能否被64整除。64=2^6，所以我们只要判断这个数是否在一个1后面有6个0就行了。

代码如下：
```
#include <bits/stdc++.h>//万能头文件 
using namespace std;
string a;
int s=-1,ans;
int main()
{
	cin>>a;//输入 
	for(int i=0;i<a.size();i++) 
	{
		if(a[i]=='1') //如果有一个1 
		{
			s=i;//从1的那个地方开始 
			break;//跳出 
		}
	}
	if(s==-1)//如果没有1 
	{
		cout<<"no";//不能被64整除 
		return 0;//结束程序 
	}
	for(int i=s;i<a.size();i++)//从1的位置开始 
	{
		if(a[i]=='0') ans++;//如果是0，则0的个数加1 
	}
	if(ans>5) cout<<"yes";//如果0的个数大于等于6，输出yes 
	else cout<<"no";//否则输出no
	return 0;//结束程序 
}
```


---

## 作者：OdtreePrince (赞：1)

# -2^6=64-

因此，只需求出任意一个1后，是否具备6个零，有一个具备则输出“yes”，else 输出“no”。

简单AC！！

~~~
#include<bits/stdc++.h>
using namespace std;
int main(){
    int num=1,a=-1;
    string s;
    cin>>s;
    for(int i=s.size()-1;i>=0;i--){
        if(s[i]=='0'){
            if(num==6){
            	i--;
            	a=1;
            	int k=0;
                while(i>=0){
                	if(s[i]=='1') k=1;
                	i--;
				}
				if(k) cout<<"yes";
				else cout<<"no";
            }
            else{
                num++;
            }
        }
    }
    if(a==-1) cout<<"no";
    return 0;
}
~~~

---

## 作者：晴耕雨读罢了 (赞：0)

~~**这道题其实找到思路就很水**~~

~~接下来我来教你们思路吧~~

十进制64转二进制为（1000000）

只要把它上到这个状态就行了

找到第一个一的位置往后搜找到六个0就行了

#  _**# 附上ac代码**_ 

```
#include<bits/stdc++.h>
using namespace std;
string s;
int ans;
int  cz(string s){
for(int i=0;i<s.size();i++){
	//注意是从0开始 
	if(s[i]=='1'){
		return i;
	}
}
}//这段代码查找第一个一的位置 
int main()
{
	cin>>s;
	for(int i=cz(s);i<s.size();i++){
	    if(s[i]=='0')ans++; 
		if(ans==6){
		cout<<"yes";//找到六个0就输出yes 
		return 0;
		}
	} 
	cout<<"no";//找不到0输出no 
	return 0;
}
```
## 可能我的码风你们不太适应，如有不便请见谅。



---

## 作者：Daidly (赞：0)

# STEP1
$1.$审题，题目要求我们把二进制转化成十进制再做除法运算；所以我们可以换种思维，把十进制转化成二进制再作比较。所以我们就可以从$64$下手。

$2.$因为$64=2^6$且$2^6=(1000000)_ 2$,所以在十进制中能整除$64$，也就是在二进制中能整除$1000000$。

$3.$这样我们就把目标转向了整除$1000000$中,也就是说假如所给的串中有$6$个$0$，并且$6$个$0$之前有一个$1$，那么这个二进制数能被$64$整除。

$4.$如果能，就输出$yes$；
如果不能，就输出$no$。

# STEP2
$AC$代码
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main(){
    string a;//定义一个字符串
    cin>>a;
    int b=0,c=0,d=a.size();//b,c用来运算，d用来模拟字符串的长度
    for(int i=d-1;i>=0;i--)
    {if(a[i]=='0') c++;
       if(c>=6)
        {for(int j=i;j>=0;j--)
            {if(a[j]=='1')
                {b=1;break;}}}
        if(b==1) break;//也可以写成if(b) break;
    }
    if(b==1){//也可以写成if(b){
    cout << "yes" << endl;
    }//如果可以，就输出yes
    else{
    cout << "no" << endl;
    }//如果不可以，就输出no
    return 0;//结束
}
```
如果您听懂了，就请点个赞呗。

---

## 作者：tgs9311 (赞：0)

题目大意很清楚：删掉字符串中的一些数，让这个二进制数它能被64整除。

# 解析

因为64的二进制表达——1000000，所以只要字符串里第一个1后面有6个0（注意：无论i是连续还是不连续都行）就可以了。
```cpp
#include<iostream>
using namespace std;
int main()
{
string i;
int s2=0;//s2是第一个1后0的个数
cin>>i;
for(int j=0;j<i.size();j++)
{
	if(i[j]=='1')
	{
    		//如果找到了第一个1
		for(int q=j+1;q<i.size();q++)
     		{
            		//从1后面开始找
            		if(i[q]=='0')
			{
			s2++;
			}
     		}
         	break;//跳出循环
	}
}
//判断输出
if(s2>=6)
{
	cout<<"yes";
}
else
{
	cout<<"no";
}
}
```

---


# 2023

## 题目描述

求一个元素乘积为 $2023$ 的数组 $a$，其中的 $k$ 个元素被移除后得到数组 $b$。现在告诉你 $b$，问是否能找到一个满足以上条件的数组 $a$。

## 样例 #1

### 输入

```
7
2 2
5 2
3 1
7 17 7
4 2
1 289 1 1
3 1
7 17 17
1 1
289
1 1
2023
1 3
1```

### 输出

```
NO
NO
YES
7 1
YES
1
YES
7
YES
1
YES
7 17 17```

# 题解

## 作者：_Deer_Peach_ (赞：2)

### 思路：
先建一个变量记录输入的 $b$ 数组的乘积，如果不能被 $2023$ 整除，直接输出不行，否则可以直接输出 $2023$ 除以这个乘积，最后全部输出一即可。
### 代码：
```
#include<bits/stdc++.h>//万能头
#define int long long//知州所众，不开long long见祖宗
using namespace std;
int t;signed main(){
	cin>>t;
	while(t--){//注意多组数据
		int n,k,cnt=1;//cnt就是记录乘积
		cin>>n>>k;
		for(int i=1;i<=n;i++){
			int x;
			cin>>x;
			cnt*=x;
		}if(2023%cnt==0){//能被2023整除
			cout<<"yEs"<<endl;//既然对大小写不敏感，就玩点花的
			cout<<2023/cnt<<" ";//输出
			for(int i=0;i<k-1;i++)cout<<"1 ";
			cout<<endl;//别忘记换行
		}else cout<<"nO"<<endl;//不能被2023整除
	}return 0;//完结撒花
}
```

---

## 作者：lgydkkyd (赞：2)

这是一道稍微有一点思考难度的题，先是多组数据输入，在输入的过程中累乘起来，判断是否为 $2023$ 的因子，如果不是则不满足要求，否则输出 $k-1$ 个 $1$ 用空格隔开即可。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,k,a[6];
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
		int cj=1;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			cj*=a[i];
		}
		if(2023%cj==0){
			printf("YES\n%lld",2023/cj);
			for(int i=1;i<k;i++){
				printf(" %lld",1);
			}
			printf("\n");
		}
		else{
			printf("NO\n");
		}
	}
	return 0;
}
```

---

## 作者：Pyrf_uqcat (赞：2)

竟然有可以写题解的红题，赶紧来水一波。

题目也是很好理解，**多组数据**，告诉你 $n$ 个数，加上 $k$ 个数，判断这个序列的积是否是 $2023$。

写法很简单，把初始序列的各个元素乘起来，因为 $k$ 不为 $0$，所以只要积是 $2023$ 的因数，就能成立。因为加一个 $2023$ 除以积的商就可以了，如果 $k$ 有剩余，加 $1$。

### 核心代码
```cpp
int ji=1;
	for(int i=1;i<=n;i++)
	{
		ji*=a[i];
	}
	if(2023%j==0)
	{
		cout<<"YES\n";
		cout<<2023/j<<' ';
		for(int i=1;i<k;i++)
		{
			cout<<1<<' ';
		} 
		cout<<endl;
	}
	else cout<<"NO\n";
```

---

## 作者：封禁用户 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/CF1916A)


------------

### 题目思路：
这道题可以看得出是一道构造题。首先，因为原数组中的乘积为 $2023$，所以无论删除什么数，删完后数组中元素的乘积永远为 $2023$ 的因数,所以我们只需要看一下删除后数组的乘积，如果能被 $2023$ 整除，那么就可以改回原数组，否则不行。那么接下来还有第二步，就是输出删除的数。由刚才的思路可知，现在数组中的乘积已经算完了，且它是 $2023$ 的因数，所以只要删除的数中有一个数字为 $2023$ 与这个乘积的商，且剩下的数字全部为 $1$，则能够保证原数组的乘积是 $2023$。

### 上代码:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,k,b[6]; 
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
		for(int i=1;i<=n;i++){//输入删除后的数组 
			cin>>b[i];
		}
		int sum=1;//乘积 
		for(int i=1;i<=n;i++){//删除后数组的乘积 
			sum*=b[i];
		}
		if(2023%sum==0){//可以还原 
			cout<<"YES"<<endl;//先输出可以 
			cout<<2023/sum<<" ";//输出2023与乘积的商 
			for(int i=2;i<=k;i++){//剩下全部是1 
				cout<<1<<" ";
			}
			cout<<endl;
		}else{
			cout<<"NO"<<endl;//不可以 
		}
	}
	return 0;
}
```

---

## 作者：xujingyu (赞：0)

## 题意

输入一个序列 $b$，请判断能否加上 $k$ 个数使得乘积为 $2023$。

## 解答

根据输入的序列算出当前的积设为 $mul$，判断之除以 $2023$ 是否有余数，有就输出 `NO`，否则输出 $\dfrac{2023}{mul}$ 和 $k-1$ 个 $1$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int t,n,k,mul;

signed main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld",&n,&k);
		mul = 1;
		for(int i = 1;i <= n;i++)
		{
			int b;
			scanf("%lld",&b);
			mul *= b;//计算积
		}
		if(2023 % mul == 0)//无余数,能整除
		{
			printf("YES\n%lld",2023 / mul);
			for(int i = 1;i < k;i++) printf(" 1");//跟着很多1
			printf("\n");
		}
		else printf("NO\n");//无法凑出
	}
	return 0;
}
```

---


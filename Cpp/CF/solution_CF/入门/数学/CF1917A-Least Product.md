# Least Product

## 题目描述

给定一个整数数组 $a_1, a_2, \dots, a_n$。你可以对数组执行如下操作任意次（可以为零次）：

- 选择数组中的任意一个元素 $a_i$，并将其值更改为 $0$ 到 $a_i$ 之间的任意整数（包含端点）。更正式地说，如果 $a_i < 0$，则可以将 $a_i$ 替换为 $[a_i, 0]$ 区间内的任意整数；否则可以将 $a_i$ 替换为 $[0, a_i]$ 区间内的任意整数。

设 $r$ 为经过任意次操作后所有 $a_i$ 的最小可能乘积。

请你求出使得乘积等于 $r$ 所需的最小操作次数，并输出一种最短的操作序列。如果有多种答案，可以输出任意一种。

## 说明/提示

在第一个测试用例中，我们可以将第一个整数改为 $0$，此时乘积变为 $0$，这是最小可能值。

在第二个测试用例中，初始时所有整数的乘积为 $2 \cdot 8 \cdot (-1) \cdot 3 = -48$，这已经是最小可能值，因此无需进行任何操作。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1
155
4
2 8 -1 3
4
-1 0 -2 -5
4
-15 -75 -25 -30```

### 输出

```
1
1 0
0
0
1
3 0```

# 题解

## 作者：Pyrf_uqcat (赞：3)

一道简单题，分类讨论随便秒。

注意：因为可以把数变为零，而所有数乘零都等于零。

所以当所有数的乘积为正数时，改一个数为零。因为无法把答案变为负数。

否则乘积为负，不用改。答案无法更小。

---

## 作者：_Star_Universe_ (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/CF1917A)
由于题目实现起来不难，所以不提供标程。

### 思路
这题可以分类讨论一下，有以下几种情况：

- 当有 $0$ 结果就是 $0$ 了。
- 没有 $0$，但是有奇数个负数结果就已经最小了。
- 以上情况都不符合就把其中一个数变成 $0$。

所以，可以用两种答案解决：
```c
//第一种
0
//第二种
1
1 0
```

### 数据
给大家列举几个：

第一个：
```c
1 9 1 9 8 1 0
```
很显然，有一个 $0$，不用改了，操作次数 $0$。

第二个：
```c
1 1 4 5 1 4
```
把其中任意一个数改成 $0$ 即可，操作次数 $1$。

第三个：
```c
-56 -73 78 -4
```
$3$ 个负数，不用改了，操作次数 $0$。

---

## 作者：_Deer_Peach_ (赞：2)

一道简单的思维题。
#### 思路：
使乘积最小，那么就要分类讨论。如果没有负数，最小乘积为零，只要找输入数字中有无零即可，如果没有零，就把第一个数改成零；否则，没有零直接输出零，但是如果有负数，又有两种情况，第一种是负数个数为奇数，那么乘积为负数，可以不操作；否则，负数个数为偶数，改其中一个数为零即可。

#### 代码：
```
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		int n,cnt1=0,cnt2=0;
		cin>>n;
		for(int i=1,x;i<=n;i++){
			cin>>x;
			if(x<0)cnt1++; //负数数量
			if(x==0)cnt2++; //0的数量
		}if(cnt1%2==1 or cnt2>0)cout<<0<<endl;//不用操作的情况
		else cout<<1<<endl<<"1 0"<<endl;//要操作的情况
	}return 0;
}
```

---

## 作者：Conic_Curve (赞：0)

### 思路
因为负负得正，所以只要有奇数个负数或者有 $0$，这个结果就肯定是最小的。
如果不符合，就只需要改一次：把第一个数改成 $0$即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000005];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];//输入
		int cnt1=0,cnt2=0;
		for(int i=1;i<=n;i++){
			if(a[i]<0)cnt1++;
			if(a[i]==0)cnt2++;
        //统计负数与0的数量
		}
		if(cnt1%2==1||cnt2>0)cout<<0<<endl;
     //如果负数数量是奇数或者有0，就输出0
		else cout<<"1"<<endl<<"1 0"<<endl;
     //否则cout<<"1"<<endl<<"1 0"<<endl;
	}
	return 0;
}
```

---

## 作者：Thorongil_Gondor (赞：0)

# CF1917A Least Product 题解
## 思路
使乘积最小，两种情况：
* 没有负数，最小乘积为 $0$，判断输入数字中是否有 $0$：若没有 $0$，把第一个数改成 $0$；否则，有 $0$，则输出 $0$。
* 有负数，则分两种情况：第一种负数个数是奇数，则积为负数，不操作；第二种负数个数是偶数，将其中一个数改为 $0$。
## AC Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,x,cnt_negative,cnt_0;
signed main(){
	cin>>t;
	while(t--){//多测
		cin>>n;
        cnt_negative=0,cnt_0=0;//统计变量清零
		while(n--){
			cin>>x;
			if(x<0)cntnegative++;//负数数量增加
			if(x==0)cnt_0++;//0的数量增加
		}
        if(cnt_negative%2||cnt_0>0)cout<<0<<endl;//积为负,不操作
		else cout<<1<<endl<<"1 0"<<endl;//操作
	}
    return 0;
}
```

---

## 作者：SecuritySetting (赞：0)

这是一道考验思维的题目。

首先，题目要求乘积最小，所以结果要么是零，要么是负数。

所以，我们就需要分类讨论了：

第一种情况是使乘积为零。要使乘积为零，只需要有零即可，如果没零就操作一次把一个数变为零。

第二种情况是使乘积为负数。我们都知道负负得正，所以如果有偶然数个负数，就无法使乘积成为负数，只能使乘积为零，同第一种情况。如果只有奇数个负数，那就不需要操作了。

具体代码：
```
#include <bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin >> t;
	while (t --) { //注意是多组测试 
		int n, a = 0, b = 0; //a统计0的个数，b统计负数的个数 
		cin >> n;
		for (int i = 1; i <= n; i ++) {
			int x;
			cin >> x;
			if (x == 0) a ++;
			if (x < 0) b ++;
		}
		if (a) cout << 0 << endl; //有0不用操作直接输出 
		else if (b % 2 == 1) cout << 0 << endl; //奇数个负数不用操作直接输出 
		else if (b % 2 == 0) cout << 1 << endl << "1 0" << endl; //偶数个负数操作一次 
		else cout << 1 <<endl << "1 0" << endl; //没有负数也没有0操作一次 
	}
	return 0;
}
```

---

## 作者：lgydkkyd (赞：0)

这道题最重要的步骤就是寻找规律：首先**零与任何数的乘积都为零**，那么只要序列里有零最小的就是零了。其次按照口诀**负负得正**，所以如果序列里有**奇数个负数**结果也为零了。如果都不符合就得把其中一个数改成零，最后乘积也为零了，那么就输出```1\n1 0\n```。
```cpp
#include<bits/stdc++.h>
using namespace std;
int o[1000001],n,t,x[2];
int main(){
	scanf("%d",&t);
	while(t--){	
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&o[i]);
		x[0]=0,x[1]=0;
		for(int i=1;i<=n;i++){
			if(o[i]<0){
				x[0]=x[0]+1;
			}
			else if(o[i]==0){
				x[1]=x[1]+1;
			}
		}
		if(x[0]%2==1||x[1]>0){
			printf("0\n");
		}
		else{
			printf("1\n1 0\n");
		}
	}
	return 0;
}
```

---


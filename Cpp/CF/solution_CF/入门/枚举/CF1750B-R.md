# R

## 题目描述

R

## 说明/提示

R

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
6
5
11100
7
1100110
6
011110
7
1001010
4
1000
1
0```

### 输出

```
9
12
16
12
9
1```

# 题解

## 作者：Dangerou (赞：3)

## 分析：

题目要求很简单，答案在三种选择中取最大值：

1. 整个序列中 $0$ 的个数乘以 $1$ 的个数
2. 最长的连续的 $0$ 的个数的平方
3. 最长的连续的 $1$ 的个数的平方

直接暴力枚举即可。

最后，$2\times10^5$ 的平方会爆 `int`，不要忘记开 `long long`。

### Code
```
#include<iostream>
#include<cstdio>
using namespace std;
int T,n;
char s[200005];
long long sum0,sum1;//0或1的个数
long long maxlen0,maxlen1;//最长的连续的0或1的个数
int las;//记录上一个是0还是1
long long len;//记录当前连续长度
long long ans;//统计答案
void work()
{
	ans=0;
	sum0=0;sum1=0;
	maxlen0=0;maxlen1=0;//多测要清零
	scanf("%d%s",&n,s+1);
	s[n+1]='2';//循环到n+1且s[n+1]不能等于0或1，方便统计最后一段
	las=s[1]-'0';//特判第一个
	len=1;
	if(s[1]-'0'==0) sum0++;
	else sum1++;
	for(int i=2;i<=n+1;i++)
	{
		if(s[i]-'0'==0) sum0++;
		else if(s[i]-'0'==1) sum1++;
		if(s[i]-'0'!=las)//当与前一个不一样时，更新比开启下一次统计
		{
			if(las==0) maxlen0=max(maxlen0,len);
			else maxlen1=max(maxlen1,len);
			las=s[i]-'0';
			len=1;
		}
		else len++;
	}
	if(sum0!=0&&sum1!=0) ans=max(ans,sum0*sum1);//选择1
	if(maxlen0!=0) ans=max(ans,maxlen0*maxlen0);//选择2
	if(maxlen1!=0) ans=max(ans,maxlen1*maxlen1);//选择3
	printf("%lld\n",ans);
	return;
}
int main()
{
	scanf("%d",&T);
	while(T--) work();
	return 0;
}
```

---

## 作者：_H17_ (赞：2)

## 思路分析

这道题也就有三种计分法，所以我们挨个分析一下吧。

- 对于 $x^2$ 的贡献是：最长的只包含 $0$ 的子序列贡献最大。

- 对于 $y^2$ 的贡献是：最长的只包含 $1$ 的子序列贡献最大。
- 对于 $x \times y$ 的贡献是：这个序列本身最大。

最后我们只取 $\max$ 即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
//可能超int
using namespace std;
char s[200001];
//定义数组，用来存字符串
signed main(){
	int T,n,a,b,p,t,k;
	scanf("%lld\n",&T);
	//测试数
	while(T--){
		scanf("%lld\n%s",&n,s+1);
		//输入
		a=b=0,p=s[1]-48,t=k=1;
		//初始化
		for(int i=1;i<=n;i++)
			if(s[i]==48)
			    a++;
			else
			    b++;
        //x*y的贡献
		for(int i=2;i<=n;i++){
			if(s[i]-48!=p)
				p=s[i]-48,t=1;
			else
				t++;
			k=max(k,t);
			//x^2和y^2的贡献
		}
		printf("%lld\n",max(a*b,k*k));
		//输出
	}
	return 0;
}
```

---

## 作者：linyihdfj (赞：1)

## CF1750B Maximum Substring
想要更优质的阅读体验，就来[这里](https://www.cnblogs.com/linyihdfj/p/16893607.html)吧。
### 题目分析：
- 对于 $x \times y$ 的贡献，显然整个字符串是最优的。
- 对于 $x^2$ 的贡献，显然最长的一段 $0$ 是最优的。
- 对于 $y^2$ 的贡献，显然最长的一段 $1$ 是最优的。

那么把三个最优的值都取出来，然后取 $\max$ 就好了。
### 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 4e6+5;
char s[N];
signed main(){
	int t;
	scanf("%lld",&t);
	while(t--){
		int n;
		scanf("%lld",&n);
		scanf("%s",s+1);
		int ze = 0,on = 0;
		for(int i=1; i<=n; i++){
			if(s[i] == '0')	ze++;
			else	on++;
		}
		int now = s[1] - '0',cnt = 1,res = 1;
		for(int i=2; i<=n; i++){
			if(s[i] - '0' != now){
				now = s[i] - '0';
				cnt = 1;
			}
			else{
				cnt++;
			}
			res = max(res,cnt);
		}
		int ans = max(ze * on,res * res);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：幻想繁星 (赞：1)

## 题意

给定一个 $n$ 长的 $01$ 串，询问所有非空连续子串中的最大收益。

对于一个非空连续子串，$0$ 的个数为 $a$，$1$ 的个数为 $b$，其收益为：

- 当 $a≠0$ 且 $b≠0$ 时，收益为 $a\times b$；
- 当 $a=0$ 且 $b≠0$ 时，收益为 $b^2$；
- 当 $a≠0$ 且 $b=0$ 时，收益为 $a^2$。

## 分析

首先考虑 $a≠0$，$b≠0$ 这种情况，为了使 $a\times b$ 最大，我们取整个串作为“子串”即可。

考虑 $a=0$，$b≠0$ 这种情况，我们找整个串中，最长连续的纯 $1$ 连续子串即可。

考虑 $a≠0$，$b=0$ 这种情况，和上面那个情况同理，找整个串中，最长连续的纯 $0$ 连续子串即可。

再将三种情况的收益取最大值即可。

至于找子串，暴力枚举即可，这道题主要是考察贪心的思想。

$2\times 10^5$会炸 int，需要开 long long。

至此这道题就解决了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		long long s,a=0,b=0,ans[3],ma=0,mb=0;
		string x;
		cin>>s>>x;
		for(int i=0;i<s;i++)
			if(x[i]=='1') a++;
			else b++;
		ans[0]=a*b;
		a=b=0;
		for(int i=0;i<s;i++)
		{
			if(x[i]=='1') a++;
			else a=0;
			ma=max(ma,a);
		}
		ans[1]=ma*ma;
		for(int i=0;i<s;i++)
		{
			if(x[i]=='0') b++;
			else b=0;
			mb=max(mb,b);
		}
		ans[2]=mb*mb;
		cout<<max(max(ans[0],ans[1]),ans[2])<<"\n";
	} 
}
```


---

## 作者：icaijy (赞：0)

# 题意
题目翻译写的很清楚了，这里不再赘述。

# 思路
题目问关于一个子段的价值，最朴素的算法是枚举每个字段，但这样时间复杂度明显超过了 $2\cdot 10^5$ 的数据。那么稍微思考一下，找到如下规律：

- 满足 $x\cdot y$ 最大的子段就是整个字符串。
- 满足 $x^2$ 最大的子段就是最长的只包含 $0$ 的子段。
- 同理，满足 $y^2$ 最大的子段是最长的只包含 $1$ 的子段。

思路有了，代码也就出来了。

# 代码
```cpp
#include <iostream>
#include <string>
#define int long long // 十年OI一场梦，不开long long见祖宗 
using namespace std;

int solve(string a){
	int max0=0,max1=0,one=0,zero=0;
	int ze=0,on=0;
	char pre='c';// 上一个，判断是否是连续只包含0或1的子段 
	for (int i=0;i<a.length();i++){
		if (a[i]=='1') {
			one++; // 1的个数++ 
			if (pre!='1'){
				//新的一个只包含1的子段 
				max0=max(max0,ze); // 记录一下上一个（也就是只包含0的子段） 
				on=1;
			}
			else on++;
			pre='1'; // 更新 pre 
		}
		else{
			// 是0，照葫芦画瓢 
			zero++;
			if (pre!='0'){
				max1=max(max1,on);
				ze=1;
			}
			else ze++;
			pre='0';
		}
	}
	//扫完了，记录一下末尾的，防止末尾也有一串子段没记录 
	if (a[a.length()-1]=='1'){
		if (a[a.length()-2]=='1') max1=max(max1,on);
	}
	else if (a[a.length()-2]=='0') max0=max(max0,ze);
	
	return max(zero*one,max(max1*max1,max0*max0)); // 返回最大的 
}

signed main(){
	int n,trash;
	string s;
	cin>>n;
	while (n--){
		cin>>trash>>s; // cin不用位数了 
		if (s.length()==1) cout<<1<<endl;//特判一下长度为1的否则可能会寄 
		else cout<<solve(s)<<endl;//solve
	}
	return 0;
    // 防止抄袭の注释（
}

```


---

## 作者：Wind_Smiled (赞：0)

## 题意

给定 $T$ 组数据，每一组数据包含一个 01 字符串的长度 $n$ 和一个 01 字符串 $s$。

定义：在该字符串之中，有 $x$ 个 $0$， $y$ 个 $1$。

字符串的价值 $val_s=\left\{\begin{aligned}
&x\cdot y\quad & x>0,y>0\\
&x^2\quad & x>0,y=0\\
&y^2\quad & x=0,y>0 \end{aligned}\right.$。

求给定字符串的子串 $t$，使其价值最大，输出该价值。

## 分析

对于所给的三种情况，可以分别取最大值并输出，所以模拟即可。

对于第一种情况：记录原字符串中的 $0,1$ 的个数，相乘并记录。

对于第二种情况，要使 $x^2$ 最大，必然要使 $x$ 最大，所以记录连续出现的 $0$ 的总个数，取其最大值。

对于第二种情况，要使 $y^2$ 最大，必然要使 $y$ 最大，所以记录连续出现的 $1$ 的总个数，取其最大值。

## 提示

如果你在 #5 出错了，可以查看一下 $n$ 的数据范围。

$n \le 2 \times 10^5$，所以 $x,y \le 10^5$，相乘或平方会爆 `int`，所以要开 `long long`。

如果你一个测试点也没有对，可以试一试“多组测试，清空数据”。

其余情况则应是程序内部构造出错，可以尝试静态查错，调试一下，也许是变量名引用错了呢。

### 实现

我们对于字符串的读入之后，按位去判断，等于 $0$ 或等于 $1$，记录出现字符总数和连续出现字符个数。如果与前一位不同，则将值归为 $1$，重新记录。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s;
long long n,s0,s1,c0,c1,z0,z1,ans;//记得开long long，n为字符串长度。s0，s1分别表示原字符串中的0,1个数。c0，c1记录当前连续出现的0,1个数。z0，z1记录0,1连续出现的最长长度。ans记录答案。
int main(){
	scanf("%d",&t);
	while(t--){
		ans=0,c0=1,c1=1,z0=1,z1=1,s0=0,s1=0;//多测清空
		scanf("%lld",&n);//scanf里的占位符也不能忘记更改
		cin>>s;
		for(int i=0;i<n;i++){//字符串是从第0位开始记录的
			if(s[i]-'0'==0){//如果当前位置是0
				s0++;//计数器增加一
				if(i!=0){//如果不是第0位，防止越界
					if(s[i-1]-'0'==0){
						c0++;//当前个数+1
						z0=max(z0,c0);//传参
					}
					else{
						z0=max(z0,c0);
						c0=1;//归成1
					}
				}
			}
			else{
				s1++;
				if(i!=0){
					if(s[i-1]-'0'==1){
						c1++;//当前个数+1
						z1=max(z1,c1);//传参
					}
					else{
						z1=max(z1,c1);
						c1=1;//归成1
					}
				}
			}
		}
		ans=max(ans,s0*s1);//第一种
		ans=max(ans,z0*z0);//第二种
		ans=max(ans,z1*z1);//第三种
		printf("%lld\n",ans);//输出的占位符别忘了
	}
	return 0;
}
```

---

## 作者：隐仞Mrsu (赞：0)

# 题意
给定一个 $n$ 长的 $01$ 串，询问所有非空连续子串（整个串也是子串）中的最大收益。

对于一个非空连续子串，$0$ 的个数为 $x$，$1$ 的个数为 $y$，其收益为：
- 当 $x\neq0$ 且 $y\neq0$ 时，收益为 $x\cdot y$；
- 当 $x=0$ 且 $y\neq0$ 时，收益为 $y^{2}$；
- 当 $x\neq0$ 且 $y=0$ 时，收益为 $x^{2}$。

# 分析
考虑 $x\ne0,y\ne0$ 这种情况，为了使 $x\cdot y$ 最大，我们取整个串作为“子串”，从而得到最多的 $0$ 和 $1$。

考虑 $x=0,y\ne0$ 这种情况，同时注意到题目中要求子串是连续的，所以我们找整个串中，最长连续的纯 $1$ 连续子串，将其长度取平方得到答案。

考虑 $x\neq0,y=0$ 这种情况，和上面那个情况同理，找整个串中，最长连续的纯 $0$ 连续子串，将其长度取平方得到答案。

于是，最终答案就是三者的最大值。

# 代码
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e6+6;
LL _,n,num[2],sum[2],mx[N];
string s;
void work(){
	cin>>n>>s;
	LL len=s.length();
	num[s[0]-'0']++;//num数组表示0和1的数量
	mx[0]++;
	sum[s[0]-'0']++;//sum数组表示最长连续纯0/1子串的长度
	for(LL i=1;i<len;i++){
		num[s[i]-'0']++;
		if(s[i]==s[i-1]){
			mx[i]=mx[i-1]+1;//该位和上一位相同，数量加1
		}
		else{
			mx[i]=1;//该位和上一位不同，数量改回1
		}
		sum[s[i]-'0']=max(sum[s[i]-'0'],mx[i]);
	}
	LL a[3]={sum[0]*sum[0],sum[1]*sum[1],num[0]*num[1]};
	sort(a,a+3);//取三种情况的最大值
	cout<<a[2]<<'\n';
    //清空数组
	for(LL i=0;i<len;i++){
		mx[i]=0;
	}
	num[0]=num[1]=sum[0]=sum[1]=0; 
} 
int main(){
	//ios::sync_with_stdio(false);
	cin>>_;
	while(_--){
		work();
	}
}
```


---

## 作者：smallpeter (赞：0)

显然的一眼贪心吧。

# 解题思路

分情况考虑。

## 1、选择第一种计算贡献的方法

不难发现选的 $0$ 和 $1$ 越多越好，显然选整个串的贡献最高（如果此串既有 $0$ 又有 $1$ 的话）。

## 2、选择第二、三种计算贡献的方法

显然只能全选 $0$ 或 $1$。那么就相当于计算连续相等段的贡献。不难发现选的数越多贡献越大，于是计算最长连续相等段。

综上所述，在两种贡献中取价值最大的。

其实我的代码是偷了懒的，我没有判断整个串是否同时有 $0$ 和 $1$ 就计算了第一种贡献方法。但其实这样也是正确的，因为如果整个串没有 $0$ 或 $1$，那这种方法算出来的贡献为 $0$，显然不可能是最大贡献。

# 代码
```
#include<bits/stdc++.h>
using namespace std;

#define LL long long

const LL N=2e5+10;

LL t,n,xx,yy,a[N];

char c[N];

int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		for(LL i=1;i<=n;i++) cin>>c[i];
		for(LL i=1;i<=n;i++) a[i]=c[i]-'0';
		xx=yy=0;
		for(LL i=1;i<=n;i++){
			if(c[i]=='0') xx++;
			else yy++;
		}
		LL mx=1,sum=1;
		a[n+1]=-1;
		for(LL i=2;i<=n+1;i++){
			if(a[i]!=a[i-1]){
				mx=max(sum,mx);
				sum=1;
			}
			else sum++;
		}
		printf("%lld\n",max(mx*mx,xx*yy));
	}
}
```

---

## 作者：二叉苹果树 (赞：0)

## 题意

给出一个 $\rm{01}$ 串，要求选出其中的一个子串，使这个字串的权值尽可能大。

对于一个 $\rm{01}$ 串，若其中有 $x$ 个 $\rm{0}$，$y$ 个 $\rm{1}$，定义其权值为：

- $x \cdot y,x>0$ 且 $y>0$
- $x^2,x>0$ 且 $y=0$
- $y^2,x=0$ 且 $y>0$

## 做法

权值为 $x \cdot y$ 的情况时，显然，选出整个字符串为最优情况。

权值为 $x^2$ 的情况时，显然，要选出字符串中最大的一段全部由 $\rm{0}$ 构成的字串，构成最优情况。

权值为 $y^2$ 的情况时，同理，要选出字符串中最大的一段全部由 $\rm{1}$ 构成的字串，构成最优情况。

由此，我们只需要记录出字符串中 $0$ 的最大长度 $max_0$，总个数 $sum_0$， $1$ 的最大长度 $max_1$，总个数 $sum_1$，最终所求的答案即为 $\max\{sum_0\cdot sum_1, max_0^2,max_1^2\}$。

```cpp
#include<bits/stdc++.h>

int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*f;
}

#define MAXN 200005

int main()
{
    int t=read();
    while(t--)
    {
        int n=read();
        long long max0=0,max1=0,now0=0,now1=0,sum0=0,sum1=0;
        char ch[MAXN];
        scanf("%s",ch);
        for(int i=0;i<n;i++)
        {
            if(ch[i]=='1')
            {
                now1++;
                sum1++;
                now0=0;
            }
            if(ch[i]=='0')
            {
                now0++;
                sum0++;
                now1=0;
            }
            max0=std::max(max0,now0);
            max1=std::max(max1,now1);
        }
        printf("%lld\n",std::max(sum0*sum1,std::max(max0*max0,max1*max1)));
    }
    return 0;
}
```


---


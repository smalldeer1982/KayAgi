# Mind the Gap

## 题目描述

最近 Arkady 在一个大型机场当空中交通管理员.他管理着一条用于飞机降 落的跑道。因此，他的手中有一份当天的飞机降落时刻表。每架飞机需要一分钟 来降落。（即：从给定的时间持续一分钟）

现在有一架飞机要插队。这架飞机也需要一分钟来降落，但是为了安全，它 的降落前后应该有一段时间的空缺，前后各 s 分钟。

请你找到最早的可以安排插队的时间。

## 样例 #1

### 输入

```
6 60
0 0
1 20
3 21
5 0
19 30
23 40
```

### 输出

```
6 1
```

## 样例 #2

### 输入

```
16 50
0 30
1 20
3 0
4 30
6 10
7 50
9 30
11 10
12 50
14 30
16 10
17 50
19 30
21 10
22 50
23 59
```

### 输出

```
24 50
```

## 样例 #3

### 输入

```
3 17
0 30
1 0
12 0
```

### 输出

```
0 0
```

# 题解

## 作者：Creroity (赞：2)

~~说实话这题很水啊。~~

你看数据那么小，还用什么概率啊……

#### 直接暴力枚举！

对于输入和输出的小时和分钟还是比较好处理的，我们可以将其全部化为分钟后再存储，最后输出的时候转化一下也一样是很方便的。

然后判断两者之间的时间差时，只需要将 $a_i - a_{i-1}$ 再看一下是否大于 $s \times 2$ 就可以了。

当然这里有几个坑点，首先就是如果在第一架飞机前着陆的话，只需要计算一个 s ，还有就是计算 s 时，还要加上飞机降落的时间，也就是 1 分钟。而且同样在第一架飞机前需要特判，在第一架飞机前只需要加上插队飞机的降落时间，但后面几架飞机还需要加上之前降落的飞机的 1 分钟，也就是总共加 2 分钟。

那么代码很自然的就出来了。

#### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,h,m,a[105];
int main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>h>>m;//输入 
		a[i]=60*h+m;//转化并存储 
		if(i==1){//特判 
			if(a[i]>=s+1){//注意要+1 
				cout<<0<<' '<<0;//直接输出 
				return 0;//结束 
			}
		}
		else if(a[i]-a[i-1]>=s*2+2){//记住s要乘二，而且要+2 
			int x=(a[i-1]+s+1)/60,y=(a[i-1]+s+1)%60;//转化成小时和分钟 
			cout<<x<<' '<<y;//输出 
			return 0;//结束 
		}
	}
	cout<<(a[n]+s+1)/60<<' '<<(a[n]+s+1)%60;//转化并输出 
	return 0;//结束 
}
```
###### ~~求个赞~~

---

## 作者：Tweetuzki (赞：1)

$n$ 和 $s$ 这么小，直接暴力就好了。

开一个 bool 数组 $ok$，$ok_i$ 表示能不能在第 $i$ 分钟起飞。一开始所有 $ok_i = true$。

然后对于每一架飞机，把这架飞机起飞前 $s$ 分钟的全部变为 $false$，后 $s$ 分钟的也全部变为 $false$，自己的时间也变为 $false$。这个用一个 for 循环就可以搞定。

最后从头开始扫 $ok$ 数组，扫到的第一个 $true$ 就是最早可以起飞的时间。

时间复杂度：$O(ns)$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXT = 1500; //因为最多会到 25:00 起飞，所以最多有 1500 分钟

int n, s;
bool ok[MAXT + 1];

int main() {
    memset(ok, true, sizeof ok);

    cin >> n >> s;

    for (int i = 1; i <= n; ++i) {
        int h, m;
        cin >> h >> m;

        int t = h * 60 + m; //全部转成分钟

        for (int i = max(0, t - s); i <= t + s; ++i)
            ok[i] = false;
    }

    for (int i = 0; i <= MAXT; ++i)
    if (ok[i]) {
        int h = i / 60, m = i % 60;
        cout << h << " " << m << endl;
        break;
    }

    return 0;
}
```

---

## 作者：ChenJr (赞：1)

	题目意思：飞机都会进行n次降落，每次降落的时间为xh，ymin，在两两飞机降落之间要插入一次起飞，起飞和降落之间都要间隔s分钟，每次起飞和降落都需要花费1分钟的死时间，问你最早要插入的时间为什么时候。
	题目分析：这题是一个挺考细节的题目。因为小时和分钟同时出现，因此，为了方便计算，我们可以将时间统一化成分钟，最后再重新化成小时分钟即可。
    首先，当s+1没有超过最开始的时间的时候，证明是最早的起飞是可以发生在0 0时刻的。其次，如果不能满足最开始的时刻，则需要枚举所有的时间，判断前一个时间+s*2+2是否大于后面的时刻，如果小于，就将前一个时间+s+1输出即可。
    最后，倘若所有都不满足，则需要在最后的时间+s+1即可。
    （ps：需要主意好边界的处理，否则很容易错误）
    
```cpp
#include <bits/stdc++.h>
using namespace std;
struct num{
    int hours,mins;
}q[105];//小时和分钟
int times[105];//统计成总的时间
int main()
{
    int n,s;
    cin>>n>>s;
    for(int i=1;i<=n;i++){
        cin>>q[i].hours>>q[i].mins;//输入
        times[i]=q[i].hours*60+q[i].mins;//统计时间
    }
    bool flag=true;//标记
    if(times[1]-s-1>=0){//如果可以在0 0时刻起飞
        cout<<0<<" 0"<<endl;
        return 0;
    }
    for(int i=2;i<=n;i++){//否则枚举所有的时间点
        if(times[i-1]+s*2+2>times[i]) continue;//如果前一个时刻不满足条件则继续枚举
        else{
            int tmp=times[i-1]+s+1;
            cout<<tmp/60<<" "<<tmp%60<<endl;//满足条件则按小时分钟输出
            flag=false;
            break;
        }
    }
    if(flag){//如果全部时刻均不满足，则在最后+s+1后输出
        int tmp=times[n]+s+1;
        cout<<tmp/60<<" "<<tmp%60<<endl;
    }
}

```

---

## 作者：miaohongxuan (赞：0)

[原题链接](https://www.luogu.com.cn/problem/CF967A)

读完题，我们梳理一下：

1. 输入【 cin 和 for 】

2. 加入【重点部分】

有三种情况：
 - 在第一架飞机之前就可以加入【 if 】
 - 最普通的情况，在两项之间插加入【 for 和 if 】
 - 在最后加入【 直接输出 】
 
3. 输出【会融合在加入部分】

---

### 接下来，我们来一步步完成：

**1.标准格式和数组定义**


```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n,h,m,s,t[105];
//分别代表输入的n，h，m，s和实际距0：0的分钟数 
bool flag = 1;
//表示是否不能在全部降落前降落 
int main(){
	
	return 0;
}

```

**2.输入**


```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n,h,m,s,t[105];
//分别代表输入的n，h，m，s和实际距0：0的分钟 
bool flag = 1;
//表示是否不能在全部降落前降落 
int main(){
	cin >> n >> s;
	for(int i = 0; i < n; i++){//输入 
		cin >> h >> m;
		t[i] = h*60 + m;//转为分钟 
	} 
	
	return 0;
}
```

**3.加入**

 _3.1.在第一架之前插入_
 
 如果第一架的降落时间减去安全间隔时间s，再减降落用的 $1$ 分钟 $\ge  0$ 就可以在第一架之前起飞，输出“0 0”，并退出程序。
 
```cpp
	if(t[0] -s -1 >= 0){
	//当第一架的降落时间减去安全间隔时间s，再减降落用的1分钟≥0 
		cout << "0 0";//输出 0 0 
		return 0;//退出程序 
	} 
```

_3.2.最普通的情况，在两项之间插加入_

 用for循环,从 $1$ 开始，到 $n$ 结束，如果第 $i$ 项和第 $i-1$ 项之间有 $2 \times s$ (与两架飞机都要有安全时间) $+ 2 \times 1$(同样 $i-1$ 架飞机和需加入的飞机都要降落时间) $\ge 0$ 时，输出并退出程序。
 
```cpp
	for(int i = 1; i < n; i++){
		if(t[i] -t[i-1] -s*2 -1 -1 >= 0){//还要减前一架飞机的降落时间  
			cout << (t[i-1] +s + 1)/60 << " " << (t[i-1] +s +1) %60;//输出 
			return 0;//退出程序 
		}
	} 
```

_3.3.在最后加入_

 因为在前面只要找到就退出程序，所以能执行到最后一步，只有在最后加入的情况了，直接输出。
 
```cpp
	cout << (t[n-1] +s +1) /60 << " " << (t[n-1] +s + 1) %60;
    
```
完成！(๑╹◡╹)ﾉ

---

### 完整代码：

**请勿抄袭！！！**

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n,h,m,s,t[105];
//分别代表输入的n，h，m，s和实际距0：0的分钟  
int main(){
	cin >> n >> s;
	for(int i = 0; i < n; i++){//输入 
		cin >> h >> m;
		t[i] = h*60 + m;//转为分钟 
	} 
	//先来考虑能不能在第一架飞机之前降落
	if(t[0] -s -1 >= 0){
	//当第一架的降落时间减去安全间隔时间s，再减降落用的1分钟≥0 
		cout << "0 0";//输出 0 0 
		return 0;//退出程序 
	} 
	//如果不能第一个降落
	for(int i = 1; i < n; i++){
		if(t[i] -t[i-1] -s*2 -1 -1 >= 0){//还要减前一架飞机的降落时间  
			cout << (t[i-1] +s + 1)/60 << " " << (t[i-1] +s +1) %60;//输出 
			return 0;//退出程序 
		}
	} 
	//如果只能在最后一个降落
	cout << (t[n-1] +s +1) /60 << " " << (t[n-1] +s + 1) %60;
	return 0;
}
```

---


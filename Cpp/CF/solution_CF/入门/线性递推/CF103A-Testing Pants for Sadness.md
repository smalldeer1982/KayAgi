# Testing Pants for Sadness

## 题目描述

普通矿工 Vaganych 参加了进修课程。每当矿工完成课程后，他都需要参加考试。最难的一项是名为“测试裤子的悲伤”的计算机测试。

该测试包含 $n$ 个问题，必须严格按照给定顺序依次作答，从第 $1$ 题到第 $n$ 题。第 $i$ 题有 $a_i$ 个选项，且只有一个选项是正确的。

每点击一次，表示在某个问题上选择了一个答案。目标是为每个问题都选择正确的答案。如果 Vaganych 在某个问题上选错了答案，那么所有已选答案都会被取消，测试会从头开始，即从第 $1$ 题重新开始。但 Vaganych 记忆力极好，他能记住所有内容。每道题的顺序和每道题的选项顺序都不会改变，题目和选项本身也不会变。

Vaganych 非常聪明，记忆力极佳，但他极其倒霉，对测试内容一无所知。请问在最坏情况下，他需要点击多少次才能通过测试？

## 说明/提示

对第二个样例的说明。在最坏情况下，你需要点击五次：

- 第一次点击选择了第一个问题的第一个选项，结果错误。
- 第二次点击选择了第一个问题的第二个选项，结果正确，进入第二题。
- 第三次点击选择了第二个问题的第一个选项，结果错误，回到第一题。
- 第四次点击再次选择第一个问题的第二个选项，结果正确，进入第二题。
- 第五次点击选择了第二个问题的第二个选项，结果正确，测试完成。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
1 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
2
2 2
```

### 输出

```
5```

## 样例 #3

### 输入

```
1
10
```

### 输出

```
10```

# 题解

## 作者：yizimi远欣 (赞：6)

### 解题思路
首先要知道每次尝试需要重新再做一遍~~（要是我就没有这个耐力）~~，重新做就是把已经做过的题数+1重复选项数-1遍，加上最后的选项数（不理解可以手动模拟一下，还是用实打实的手写吧，我拿电脑不便于记录每步的状态）。于是可得此递推式：
	
       		 n
		ans=Σ(a[i]-1)*(i-1)+a[i]
	  
      	 	i=1
       
### 代码实现

时间复杂度O(n)，空间复杂度O(1)

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
//上面下面的是为了偷懒
#define go(i,j,n,k) for(register ll i=j;i<=n;i+=k)
inline ll read(){//读入优化，有没有无所谓，用cin就可以
	ll x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
ll n,a,ans=0,num;
int main(){
	n=read();
	go(i,1,n,1){
		a=read();//输入，顺便直接求和，减少数组与另一个循环
		ans+=(a-1)*(i-1)+a;//递推式
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：GVNDN (赞：2)

主要讲讲怎么得出来“递推式”的。

由于这题考虑的是最差情况，即每道题的正确答案都是最后一个选项，所以第$i$题需要选$a_i$次才能选到正确答案（$a_i$），而前面需要进行$a_i-1$次的试错，每次试错都要把前面已知正确答案的$i-1$题重新选一遍（$(a_i-1) * (i - 1)$）。再加上第$i-1$题的选择总数，就是第$i$题的选择总数。

即若以$f_i$来表示第$i$题的选择总数的话：

$f_i = f_i-_1 + a_i + (a_i-1) * (i-1)$

边界条件为：$f_1 = a_1$。

当然，这里可以将递推式直接以和的形式进行计算，就是：
```cpp
ans += a[i] + (a[i] - 1) * (i - 1)    //ans代表前i - 1道题的选择总数
```

代码：
```cpp
#include<iostream>
using namespace std;

long long a[110], ans = 0;

int main(){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	for(int i = 1; i <= n; i++)
		ans += a[i] + (a[i] - 1) * (i - 1);
	cout << ans;
	return 0;
}
```

---


# Turtle Puzzle: Rearrange and Negate

## 题目描述

给定一个包含 $n$ 个整数的数组 $a$。你需要对该数组依次执行以下两个操作（先执行第一个操作，再执行第二个操作）：

1. 可以任意重新排列数组中的元素，或者保持原有顺序不变。
2. 可以选择至多一个连续的元素区间，并将该区间内所有元素的符号取反。形式化地说，你可以选择一对下标 $l, r$，满足 $1 \le l \le r \le n$，然后对所有 $l \le i \le r$ 的 $a_i$ 执行 $a_i = -a_i$ 操作（即取反）。注意，你也可以选择不进行任何操作，保持所有元素符号不变。

在依次执行上述两个操作后，数组元素之和的最大值是多少？

## 说明/提示

在第一个测试用例中，你可以先将数组重新排列为 $[3, -2, -3]$（操作1），然后选择 $l = 2, r = 3$，得到和为 $3 + -((-2) + (-3)) = 8$（操作2）。

在第二个测试用例中，你可以两次都不进行操作，得到和为 $0$。

在第三个测试用例中，你可以两次都不进行操作，得到和为 $0 + 1 = 1$。

在第四个测试用例中，你可以保持顺序不变（操作1），然后选择 $l = 1, r = 1$，得到和为 $-(-99) = 99$（操作2）。

在第五个测试用例中，你可以保持顺序不变（操作1），然后选择 $l = 2, r = 3$，得到和为 $10 + -((-2) + (-3)) + 7 = 22$（操作2）。

在第六个测试用例中，你可以保持顺序不变（操作1），然后选择 $l = 1, r = 5$，得到和为 $-((-1)+(-2)+(-3)+(-4)+(-5))=15$（操作2）。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
8
3
-2 3 -3
1
0
2
0 1
1
-99
4
10 -2 -3 7
5
-1 -2 -3 -4 -5
6
-41 22 -69 73 -15 -50
12
1 2 3 4 5 6 7 8 9 10 11 12```

### 输出

```
8
0
1
99
22
15
270
78```

# 题解

## 作者：封禁用户 (赞：3)

此题每一个数字可以变成它的相反数，而题目要求一行的数最后总和最大，所以只要看到一个负数就可以把它变成它的相反数，这样可以让总和最大。

AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,p[114514],cnt;
int main(){
	cin>>t; 
	for(int i=1;i<=t;i++){
		cin>>n;
		cnt=0;//初始化 
		for(int j=1;j<=n;j++){
			cin>>p[j];//数据范围绰绰有余 
			if(p[j]<0){
				p[j]=-p[j];//负数变成相反数
			}
			cnt+=p[j];
		}
		cout<<cnt<<endl;
	}
	return 0;
}

```
蒟蒻代码有些丑，请见谅。

# 杜绝抄袭，从我做起！

---

## 作者：zhuxiangrui_2010 (赞：1)

# CF1933A 题解
## 题意
每次给出一个数列，其中每个元素都可以变成它的相反数，求修改后最大的各个元素之和。
## 思路
首先，我们要引进一个概念：[绝对值](https://baike.baidu.com/item/%E7%BB%9D%E5%AF%B9%E5%80%BC/3995097?fr=ge_ala)。

通过概念可以知道，正数的绝对值是它本身，负数的绝对值是它的相反数，$0$ 的绝对值就是 $0$。

也就是说，$\left | x \right | \ge x$。

所以，只需要对每一个数取绝对值再相加，就能得到最大值。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
	    int n,s=0;
	    cin>>n;
	    for(int j=1;j<=n;j++){
	        int x;
	        cin>>x;
	        s+=abs(x);//绝对值函数
	    }
	    cout<<s<<endl;
	}
	return 114514;//防抄袭
} 
```
~~求赞~~。

---

## 作者：iyka (赞：1)

### 题目大意
每组测试样例给出一个数列 $a$，我们可以将数列 $a$ 中的任意元素变为相反数，求：
$$\max{\sum_{i = 1}^{n} a_i}$$

### 题目做法
首先我们先要知道**相反数**是什么。（~~话说你都看懂上面的求和公式了，你还不知道相反数是什么？~~）假设有一实数 $k$，那它的相反数就为 $-k$。  
然后我们不难想出当一个数列中的所有数都为正数时，此时此数列中所有元素和最大，那怎么快速的求出正数呢？这里使用绝对值。（~~别告诉我你又不会……~~）假设有一实数 $k$，若它为正数，那它的绝对值就为 $k$；若它为负数，那它的绝对值就为 $-k$，特殊的，若 $k=0$，那它的绝对值还是 $0$。  
最后我们只需要在输入中给 $a_i$ 取绝对值再求和就能得到答案了。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int t,n,a,ans;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n; ans=0;
		for(int i=1;i<=n;++i)
			cin>>a, ans+=abs(a); //abs()为c++中自带的取绝对值函数  
		cout<<ans<<"\n";
	}
	return 0;
} 
```

---

## 作者：xujingyu (赞：0)

## 题意简述

多组数据，对于每组数据给出一个序列 $a_i$，每个数可以不变，也可以变为相反数，求 $\max\sum\limits_{i=1}^na_i$。

## 解法

dp 题，从 $a_1$ 开始枚举到 $a_n$，状态转移方程为 $dp_i=\max(dp_{i-1}+a_i,dp_{i-1}-a_i)$，即当前值为前项加上这个数或者减这个数。

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,a,dp[51];
signed main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		dp[0] = 0;//初始化
		for(int i = 1;i <= n;i++)
		{
			scanf("%d",&a);
			dp[i] = max(dp[i - 1] + a,dp[i - 1] - a);//状态转移方程
		}
		printf("%d\n",dp[n]);//输出最后一项
	}
	return 0;
}
```

---


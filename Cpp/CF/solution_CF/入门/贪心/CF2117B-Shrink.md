# Shrink

## 题目描述

对一个大小为 $ m $ 的数组 $ a $ 进行“缩小操作”的定义如下：

- 选择一个索引 $ i $（$ 2 \le i \le m - 1 $），使得 $ a_i \gt a_{i - 1} $ 且 $ a_i \gt a_{i + 1} $。
- 将 $ a_i $ 从数组中移除。

定义一个排列 $ ^{\text{∗}} $ $ p $ 的“分数”为可以对 $ p $ 执行的最大缩小操作次数。

鸭鸭给你一个整数 $ n $。构造一个长度为 $ n $ 的排列 $ p $，使其分数尽可能大。如果有多个答案，输出任意一个即可。

$ ^{\text{∗}} $ 一个长度为 $ n $ 的排列是指由 $ 1 $ 到 $ n $ 的 $ n $ 个不同整数按任意顺序组成的数组。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 不是排列（因为 $ 2 $ 出现了两次），$ [1,3,4] $ 也不是排列（因为 $ n=3 $ 但数组中出现了 $ 4 $）。

## 说明/提示

在第一个测试用例中：

- 我们选择 $ p = [1, 3, 2] $。
- 选择索引 $ 2 $，并移除 $ p_2 $。数组变为 $ p = [1, 2] $。

可以证明，我们能执行的最大操作次数是 $ 1 $。另一个有效答案是 $ p = [2, 3, 1] $。

在第二个测试用例中：

- 我们选择 $ p = [2, 3, 6, 4, 5, 1] $。
- 选择索引 $ 5 $，并移除 $ p_5 $。数组变为 $ p = [2, 3, 6, 4, 1] $。
- 选择索引 $ 3 $，并移除 $ p_3 $。数组变为 $ p = [2, 3, 4, 1] $。
- 选择索引 $ 3 $，并移除 $ p_3 $。数组变为 $ p = [2, 3, 1] $。
- 选择索引 $ 2 $，并移除 $ p_2 $。数组变为 $ p = [2, 1] $。

我们能执行的最大操作次数是 $ 4 $。任何分数为 $ 4 $ 的排列都是有效的。

## 样例 #1

### 输入

```
2
3
6```

### 输出

```
1 3 2
2 3 6 4 5 1```

# 题解

## 作者：Clare613 (赞：5)

## 思路：
### 题目大意:
给你一个整数 $ n $。构造一个长度为 $ n $ 的排列 $ p $，使其分数尽可能大。分数的计算方法：
- 选择一个索引 $ i $（$ 2 \le i \le m - 1 $），使得 $ a_i \gt a_{i - 1} $ 且 $ a_i \gt a_{i + 1} $。
- 将 $ a_i $ 从数组中移除。

这样记作一分。
### 正题:
根据以上的题面，我们可以用手算一下，不难得到类似于这样的一个序列：
> $1,3,4,\dots,n-1,n,2$

那么这个序列有什么用呢，我们可以发现从 $n$ 消除起，$n$ 消去后 $n-1$ 也可以消去，以此类推，最后只会剩下这个序列：
> $1,2$

可得这就是最简序列。有人就会有一个问题：是不是只有 $1$ 和 $2$ 在两边把关即可？其实可以用手验证，实际检验看[这里](https://www.luogu.me/paste/d7bosi9f#)。
## code：
很简单的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	cin.tie(0)->sync_with_stdio(0);
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		cout<<"1 ";
		for(int i=3;i<=n;i++){
			cout<<i<<" ";
		}
		cout<<"2\n";
	}
	return 0;
}
```

---

## 作者：zhoujunchen (赞：1)

构造题。



题意
--

给你一个 $n$，让你用构造一个长度为 $n$ 的排列使得得分尽量的多。

- 选择一个索引 $ i $（$ 2 \le i \le n - 1 $），使得 $ a_{i - 1}< a_i$ 且 $ a_i \gt a_{i + 1} $。
- 将 $ a_i $ 从数组中移除。

这样记作一分。


思路
--

我们可以将大的放两个小的中间，不难得出下面的方法：

$$1,3,5,7,...,n-1,n,n-2,...,4,2$$

删完只会剩下 $1$ 和 $2$。

维护两个指针，相中靠拢就可以了。

时间复杂度 $O(n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ans[114514];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		int l=1,r=n,cnt=0;
		while(l<r){
			cnt++,ans[l]=cnt;
			cnt++,ans[r]=cnt;
			l++,r--;//向中靠拢 
		}
		if(n%2==1)ans[n/2+1]=n;//特判 
		for(int i=1;i<=n;i++)cout<<ans[i]<<" ";
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：ttyy0518 (赞：0)

## 题意简述

共 $t$ 组数据，每组输入一个长度为 $n$ 的数组 $a$，如果 $a_i>a_{i+1}$ 且 $a_i>a_{i-1}$，删除 $a_i$。输出一个数组 $n$ 能使**删除次数**最多。

## 解题思路

- 想要使删除次数最多，可以发现数组最后只会剩下 $1$ 和 $2$ 两个数，而数组最开始，中间则为递增或递减。
- 所以我们可以每组数据从 $2$ 开始输出到 $n$ 最后在输出 $1$。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000+5;
int t,n[maxn];
int main(){
	cin>>t;
	for(int i=1;i<=t;i++)scanf("%d",&n[i]);
	for(int i=1;i<=t;i++){
		for(int j=2;j<=n[i];j++)cout<<j<<" ";
		cout<<1<<endl;
	}
	return 0;
}
```

~~当然这道题还有很多种代码的写法。~~

---

## 作者：_second_coming_ (赞：0)

### 题意
如果 $a_{i+1},a_i,a_{i−1}$ 中 $a_i$ 最大，就可以删掉 $a_i$，得到一分，问一个排列最多有多少分。

### 解法
构造一个排列：第一项是 $1$，第二项是 $n$，然后之后的每项递减，直到 $2$。

不难发现消掉 $n$ 后，就可以继续消 $n-1$ 和 $n-2$，以此类推。最后只剩下 $1$ 和 $2$ 这两个数，是最佳方案。
### 代码
```cpp
#include<iostream>
using namespace std;
int main(){
int t;
cin>>t;
while(t--){
int n;
cin>>n;
cout<<1<<" ";
for(int i=n;i>=2;i--)cout<<i<<' ';
cout<<endl;
}
}
```

---

## 作者：_you_know_who_ (赞：0)

## 题意
要求构造一个长为 $n$ 序列，让这个序列可以进行 $n-2$ 次操作。每次操做删掉一个比两个相邻的数都大的数，并且这个序列是 $1 \sim n$ 的一个排列。

## 思路
首先，删除的数字不可能是两边的数，因为两边的数只有一个相邻的数，无法满足删除的条件，可得，两边的数一定是最小的两个，分别是 $1$ 和 $2$。这样才能使旁边的数被删除。

然后我们发现只要把剩下的数从小到大排列，就可以从右到左依次删除每个在中间的数。因为最右边的数一定是中间的数中最大的数，也比它右边相邻的数大，所以可以删除。就这样把中间的 $n-2$ 个数依次删除就可以了。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[11];
int main()
{
    int t;
    cin>>t;
    for(int pp=1;pp<=t;pp++)
    {
        int n;
        cin>>n;
        cout<<1;
        for(int i=3;i<=n;i++)
        {
            cout<<' '<<i;
        }
        cout<<' '<<2<<endl;
    }
    return 0;
}
```

---

## 作者：_Star_Universe_ (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/CF2117B)
### 题目大意
对一个大小为 $m$ 的数组 $a$ 进行“缩小操作”的定义如下：

- 选择一个索引 $i$（$2 \le i \le m - 1$），使得 $a_i \gt a_{i - 1}$ 且 $a_i \gt a_{i + 1}$。
- 将 $a_i$ 从数组中移除。

定义排列 $p$ 的“分数”为可以对 $p$ 执行的最大缩小操作次数，也就是上面所说的操作，删除一次记一分。

### 思路
其实这题有一点思维含量，给大家演示一下如何构造以及消除。

最简单的一种构造方法是，将 $1$ 和 $2$ 放在两端，将剩余的数升序排在中间即可。把这个排列写出来就是 $p = \{1,3,4,\cdots,n-2,n-1,n,2\}$。

这样我们从 $n$ 开始删除元素，假设这个排列足够长，由于 $n$ 大于两边的数，删去。发现 $n-1$ 是大于两边的 $n-2$ 和 $2$ 的，继续删去，$n-2$ 又是大于 $n-3$ 和 $2$ 的，再删去……以此类推到 $3$ 大于 $1$ 和 $2$，所以排列 $p$ 最终一定会变成 $\{1,2\}$，对照样例解释，发现我们的推论是对的，而且不需要排列得那么复杂。

代码就不给了，排列 $p$ 已经给各位列出来了，编写一个 for 循环输出这个排列即可。

---

## 作者：_Deer_Peach_ (赞：0)

基础构造题。

题意已经够简洁了不再赘述。

注意到删除方式是当前数的左右两边两个数都必须小于它，所以可以先确定最大的数，在左右两边分别放比它小的两个数，以此类推。这样我们可以保证每次都能删去最大的数，最后只会剩最小的两个数。

那么转换一下，就是依次把最小的数放到序列左右两端，然后往内逐渐变大，也能达到同样的效果。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define endl '\n'
const int N=2e5+5;
int t;
int n,a[N];
signed main(){
	IOS;
	cin>>t;
	while(t--){
		cin>>n;
		int l=1,r=n,cnt=0;
		while(l<r){
			a[l]=++cnt;
			a[r]=++cnt;
			l++,r--;
		}
		if(n&1)a[n/2+1]=++cnt;
		for(int i=1;i<n;i++)cout<<a[i]<<" ";
		cout<<a[n]<<endl;
	}
	return 0;
}
```
[记录](https://codeforces.com/problemset/submission/2117/323991313)。

---

## 作者：Program_A2 (赞：0)

为了能更多地收缩数组，就必须保证其中每三个数中中间数最大。由此我们可以构造一个最简单合理的数组模式：第一个数为 $1$，第二个数为 $n$，然后一直递减，直到写到第 $n$ 个数。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
		int n;
		cin>>n;
		cout<<1;
		for(int i=n;i>=2;i--)cout<<" "<<i;     //递减
		cout<<'\n';
	}
    return 0;
}

```

---

## 作者：xf20280111 (赞：0)

好像我的思路和题解区其他人不一样。
## 题意
如果 $a_{i} > a_{i + 1}$ 且 $a_{i} < a_{i - 1}$，就可以删去 $a_{i}$，得一分，问一个序列最多有多少分。

## 思路
将序列里的所有奇数从小到大排，偶数从大到小接上。

证明：

这么排序后,数列最大值就是 $a_{n / 2 + 1}$ 或者 $a_{ 1}$（分类讨论一下数列长度 $n$ 可以证到）。

然后数列的次大值就是 $a_{n / 2}$ 或者 $a_{n / 2 + 2}$。

然后我们消去最大值后剩下的式子和原式一样消去。

所以最后就只会剩两个数，显然最优。


## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int a[N],b[N];

int main() {
    int T; cin >> T;
    while(T--) {
        int n,len = 0; cin >> n;
        for (int i = 1;i <= n;i++){
            a[i] = i;
            if (i % 2 == 1) b[++ len] = i;
        }
        for (int i = n;i >= 1;i--){
            if (i % 2 == 0) b[++ len] = i;
        }
        for (int i = 1;i <= len;i++) cout << b[i] << " ";
        cout << "\n";
        
    }
    return 0;
}
```

---


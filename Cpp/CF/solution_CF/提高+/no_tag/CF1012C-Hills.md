# Hills

## 题目描述

Innopolis 城里有 $n$ 座山，第 $i$ 座的高度为 $a_i$。

美观起见，当一座山比它两边的山（如果存在）**严格** 地高时，才能在这座山上建房子。

有一台挖掘机，每小时可以将任意一座山的高度降低 $1$，同一时间挖掘机只能在一座山上工作。山的高度可以被降为 $0$ 或负数。

请求出当 $1\leq k\leq \lceil\frac{n}{2}\rceil$ 时，建造 $k$ 座房子（即至少使得 $k$ 座山满足上面的要求）时，挖掘机至少需要工作几小时。

## 说明/提示

【样例一解释】

将山 $2$ 的高度降低 $1$，山的高度变为 $1,0,1,1,1$，此时山 $1$ 满足条件。

再将山 $4$ 的高度降低 $1$，山的高度变为 $1,0,1,0,1$，此时山 $1,3,5$ 满足条件。

---

【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^3$，$1\leq a_i\leq 10^5$。

| 子任务编号 | 分数 | 限制 |
| :----------: | :----------: | :----------: |
| $1$ | $0$ | 样例 |
| $2$ | $7$ | $n=3,a_i\leq 100$ |
| $3$ | $15$ | $n\leq 10,a_i\leq 100$ |
| $4$ | $13$ | $n\leq 100,a_i\leq 100$ |
| $5$ | $18$ | $n\leq 100,a_i\leq 2\times 10^3$ |
| $6$ | $22$ | $n\leq 500$ |
| $7$ | $25$ | 无特殊限制 |

---

来源：[eJOI2018](http://ejoi2018.org/) Problem A「Hills」

说明：翻译来自 [LOJ](https://loj.ac/problem/2813)

## 样例 #1

### 输入

```
5
1 1 1 1 1
```

### 输出

```
1 2 2 
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
0 2 
```

## 样例 #3

### 输入

```
5
1 2 3 2 2
```

### 输出

```
0 1 3 
```

# 题解

## 作者：ouuan (赞：25)

这里是双div最优解31ms0KB！

## 赛时心路历程（只想看正解的可以跳过）

首先看这道题感觉貌似可以dp，然后看数据范围，应该是O(n²)，因为要求多个k的答案，其中一维肯定是使几个数满足条件，另一维就肯定是算到第几个数了。尝试用f[i][j]代表前i个数有j个满足条件最少操作数，但转移时会因前一个数有没有满足条件而改变，所以尝试用f[i][j][0]表示前i个数有j个满足条件、i不满足条件的最少操作数，f[i][j][1]表示前i个数有j个满足条件、i满足条件的最少操作数（这里的操作数都是把i当做最右一个，即不计算对第i+1个数的操作）。然而f[i][j][1]转移时会不清楚i-1有没有已经被操作，有的dalao是用一堆ifelse解决的，然而我觉得既然状态转移和前两个数是否满足条件都有关，不如就在状态中表示前两个数是否满足条件，于是就有了下面的正解：

## 正解

### 状态表示
(这里的操作数都是把i当做最右一个，即不计算对第i+1个数的操作)
1. f[i][j][0]表示表示前i个数有j个满足条件，i、i-1都不满足条件的最少操作数
2. f[i][j][1]表示表示前i个数有j个满足条件，i满足条件的最少操作数
3. f[i][j][2]表示表示前i个数有j个满足条件，i-1满足条件的最少操作数

都满足条件呢？如果你问这个问题建议你再好好读一读题面...

### 转移方程

```
f[i][j][0]=min(f[i-1][j][0],f[i-1][j][2]);
```

这个没什么说的..

```
f[i][j][1]=min(f[i-1][j-1][0]+max(0,a[i-1]-a[i]+1),f[i-1][j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1));
```

这个分为两种情况：

1. 前两个都不满足条件，那么i-1一定是原来的数，即没有被操作过，需要的操作数就是max(0,a[i-1]-a[i]+1)

2. i-2满足条件，那么i-1已经变成了min(a[i-1],a[i-2]-1)，还需要的操作数就是max(0,min(a[i-1],a[i-2]-1)-a[i]+1)

```
f[i][j][2]=f[i-1][j][1]+max(0,a[i]-a[i-1]+1);
```

如果i-1满足条件就只有一种情况，需要的操作数是max(0,a[i]-a[i-1]+1)

### 空间优化

为什么我空间是0KB呢？因为使用了滚动数组（然而这题空间限制512MB，完全不需要滚动数组）

注意到转移只用到了f[i-1][j]和f[i-1][j-1]，所以逆序枚举j。

f[i][j][0]转移用到了f[i-1][j][0]和f[i-1][j][2]、f[i][j][1]转移用到了f[i-1][j-1][0]和f[i-1][j-1][2]、f[i][j][2]转移只用到了f[i-1][j][1]。~~进行一个手动拓扑排序~~，就可以得到要先计算0，再计算2，最后计算1。

### 代码
```
#include <iostream>
#include <algorithm>

using namespace std;

int n,f[2510][3],a[5010];

int main()
{
    int i,j;
    
    cin>>n;
    
    for (i=1;i<=n;++i)
    {
        cin>>a[i];
    }
    
    for (j=(n+1)/2;j>=0;--j)
    {
        for (i=0;i<=2;++i)
        {
            f[j][i]=0x3fffffff; //因为有的状态不存在，比如f[5][4][x]，把所有状态初始化为inf就不会让这样的状态被转移，然而inf不能太大，不然加一起会爆int
        }
    }
    
    f[0][0]=f[1][1]=0; //还是要把f[1][0][0]和f[1][1][1]初始化为0
    
    for (i=2;i<=n;++i)
    {
        for (j=(i+1)/2;j>=1;--j) //逆序枚举j防止覆盖未转移的状态
        {
            f[j][0]=min(f[j][0],f[j][2]);
            f[j][2]=f[j][1]+max(0,a[i]-a[i-1]+1);
            f[j][1]=min(f[j-1][0]+max(0,a[i-1]-a[i]+1),f[j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1));
        }
    }
    
    for (j=1;j<=(n+1)/2;++j)
    {
        cout<<min(f[j][0],min(f[j][1],f[j][2]))<<' '; //输出答案
    }
    
    return 0;
}
```

---

## 作者：Sol1 (赞：5)

~~您们怎么都是 3 维 dp 啊 qwq~~

其实本题可以只用两维 dp 解决。

设 $f_{i,j}$ 表示 $[1,j]$ 中，有 $i-1$ 个满足要求的点，且将 $a_{j-1}$ 修改到 $<a_j$ 的最小时间。

然后在转移的时候就要考虑两个因素：

1. 把前一个点的下一个位置挖下去。
2. 把当前点的上一个位置挖下去。

而这两个位置是可以重叠的，所以有两种可能的转移：

1. 从 $f_{i-1,j-2}$ 转移。此时要把 $a_{j-1}$ 挖到同时比 $a_{j-2}$ 和 $a_j$ 矮。此时有转移：

$$f_{i,j}\leftarrow f_{i-1,j-2}+\max\{0,a_{j-1}-a_j+1,a_{j-1}-a_{j-2}+1\}$$

2. 从 $f_{i-1,k}\ (k<j-2)$ 转移。此时要把 $a_{k+1}$ 挖到比 $a_k$ 矮，把 $a_{j-1}$ 挖到比 $a_j$ 矮。有转移：

$$f_{i,j}\leftarrow \min_{1\leq k\leq j-3}f_{i-1,k}+\max\{a_{k+1}-a_k+1,0\}+\max\{a_{j-1}-a_j+1,0\}$$

然后发现第 2 种转移其实就是取前缀 $\min$，所以可以开一个变量统计，就可以把转移优化到 $O(1)$。

于是这题就做完了~

时间 $O(n^2)$，空间 $O(n^2)$。

可以用滚动数组做到空间 $O(n)$，但是我懒得滚。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline long long Abs(const long long& x) {return (x > 0 ? x : -x);}
inline long long Max(const long long& x, const long long& y) {return (x > y ? x : y);}
inline long long Min(const long long& x, const long long& y) {return (x < y ? x : y);}

int n, a[5005], cost[5005];
long long dp[5005][5005];

inline void Read() {
	n = qread();
	for (int i = 1;i <= n;i++) a[i] = qread();
}

inline void Solve() {
	memset(dp, 0x3f, sizeof(dp));
	for (int i = 1;i <= n;i++) dp[0][i] = 0;
	for (int i = 1;i <= n;i++) dp[1][i] = Max(0, a[i - 1] - a[i] + 1);
	for (int i = 1;i <= n;i++) cost[i] = Max(0, a[i + 1] - a[i] + 1);
	//for (int i = 1;i <= n;i++) printf("%d ", cost[i]);
	//puts("");
	for (int i = 2;i <= n;i++) {
		long long premin = 0x3f3f3f3f3f3f3f3f;
		for (int j = i;j <= n;j++) {
			//printf("premin=%lld ", premin);
			dp[i][j] = Min(premin + Max(0, a[j - 1] - a[j] + 1), dp[i - 1][j - 2] + Max(Max(0, a[j - 1] - a[j] + 1), a[j - 1] - a[j - 2] + 1));
			premin = Min(premin, dp[i - 1][j - 2] + cost[j - 2]);
		}
		//puts("");
	}
	//for (int i = 1;i <= n;i++) {
	//	for (int j = 1;j <= n;j++) printf("%lld ", dp[i][j]);
	//	puts("");
	//}
	for (int i = 1;i <= (n + 1) / 2;i++) {
		long long ans = 0x3f3f3f3f3f3f3f3f;
		for (int j = 1;j <= n;j++) ans = Min(ans, dp[i][j] + cost[j]);
		printf("%lld ", ans);
	}
}

int main() {
	Read();
	Solve();
	return 0;
}
```

---

## 作者：linaonao (赞：5)

这道题我们采用$dp$解决（~~纯贪心实在想不出来~~）
## 思路
$dp$基本思路: 题目要问什么？“**给你n个数**”“**任意的k个数**”“**最少需要几次操作**”,这为我们点明了思路：于是我们用三维数组记录**答案**：操作次数，第一维记录考虑了几个，也就是**范围**，第二维记录用了$k$个数中的几个，也就是**限制**，最后一维记录选用这一个还是不选用，也就是**操作**。

于是$dp$所需的几个因素都被你考虑了，开始写公式（这里先出示公式，下面再讲解）:

```cpp
f[i][j][0]=min(f[i-1][j][0],f[i-1][j][1]+max(0,a[i]-a[i-1]+1));
f[i][j][1]=min(f[i-2][j-1][0]+max(0,a[i-1]-a[i]+1),f[i-2][j-1][1]+max(0,max(a[i-1]-a[i]+1,a[i-1]-a[i-2]+1)));
```

第三维$0$表示不选，$1$选：
- 不选的情况由上一个选和不选推过来，注意**调整自身高度使满足上一个能做出贡献**。
- 选的情况，显然选了这一点，上一个点一定不选，于是我们从前一个点转移:
	- 前一个点不选，就只需**调整上一个高度满足当前点能做出贡献**。
	- 前一个点选，则**调整上一个点使前一个和当前一个都做出贡献**。

可以通过画图理解 (手画，丑，懂？) :

![](https://cdn.luogu.com.cn/upload/image_hosting/n0vechuv.png)

还有一个注意点，有可能**不需调整**，所以我们将代价与$0$取$max$。

最后贴上代码

~~~cpp
#include<bits/stdc++.h>
#define t(x) (x+1)/2 
#define INF 0x3f3f3f
template<typename T>inline void read(T &x){
	T f=0;x=0;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())f|=ch=='-';
    for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    x=f?-x:x;
}
template<typename T>inline void write(T x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+48);
}
using namespace std;
int f[5005][5005][2];
int a[5005],n; 
int main(){
	read(n);
	for(int i=1;i<=n;++i) read(a[i]);
	a[0]=INF;
	memset(f,INF,sizeof(f));
	f[0][0][0]=0;f[1][0][0]=0;f[1][1][1]=0;
	for(int i=2;i<=n;++i){
		f[i][0][0]=f[i-1][0][0];
		for(int j=1;j<=t(i);++j){
			f[i][j][0]=min(f[i-1][j][0],f[i-1][j][1]+max(0,a[i]-a[i-1]+1));
			f[i][j][1]=min(f[i-2][j-1][0]+max(0,a[i-1]-a[i]+1),f[i-2][j-1][1]+max(0,max(a[i-1]-a[i]+1,a[i-1]-a[i-2]+1)));
		}
	}
	for(int i=1;i<=t(n);++i) printf("%d ",min(f[n][i][0],f[n][i][1]));
	return 0;
}


~~~





---

## 作者：HH_Halo (赞：3)

### 题目大意：

有n座山，在山上建房子，需要保证有房子的山的高度比它两边的山的高度都要高，否则，就把比它高的山挖到比它低。每分钟可以令一座山的高度减一，分别求建$1$~$n/2$幢房子花费的最短时间

## 思路分析：

* 又是一个线性$DP$，一步一步往后推就行了

* 题目不是很难理解，但是最后让求的这个东西就比较有意思了，$1$~$n/2$，为什么是 $n/2$ 而不是 $n$ ？——显然，两座相邻的山没法同时建房子，要不你就挖去吧，地心挖穿也建不成（开个玩笑）。注意：这里得到一个很关键的性质——所建的房子必须相间，相间，相间！！！

* 常规思路，从 $1$ 到 $n$ ，当做终点进行处理，那我们就只需考虑这个终点前面的山的高度，但是这道题不一样在哪里了呢？——每个点有两点状态，即建房子或不建房子，那么怎么处理呢？数组多开一维不就得了，ｂ(￣▽￣)ｄ

* 每个点的两种状态各需要一个转移方程，**一个建房子的**，**一个不建房子的**。
  * 第 $i$ 座山建房子的：（划重点）第 $i$ 座山如果建房子的话，那么第 $i-1$ 座山肯定不能建，经过这座山时也不会增加时间，那我们就直接蹦到 $i-2$ 去考虑。$i-2$ 同样也有两种情况，建或不建——如果不建，那就拿第 $i$ 座和第 $i-1$ 座比较，看看要不要挖；如果建了，那就拿 $i-2$ 和 $n$ 共同与 $i-1$ 进行比较，因为 $i-1$ 要满足比它们两个都要低。

  * 第 $i$ 座山不建房子的：那这个时候 $i-1$ 就可以考虑建房子了，这个情况就比较简单了
  
`代码更详细哦`
## $\textcolor{green}{Code}$

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn = 5000+10;
int h[5050];
int dp[5050][5050][2];
int main(){
    memset(dp,0x3f,sizeof(dp));
    dp[0][0][0]= dp[1][1][1] = dp[1][0][0] =0; //初始化，这里其实省了一个循环，把dp[i][0][0]放到下面的dp循环里了
    h[0]=0x3f3f3f3f; //设为无限大，是为了不干扰后面的操作，而且h[0]一定会出现
    int n;scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&h[i]);
    }
    for(int i=2;i<=n;++i){
        dp[i][0][0]=dp[i-1][0][0];  //前面省的初始化化放到这里了
        for(int j=1;j<=(i+1)/2;++j){  //这个括号可能有点长，但其实并不太复杂
            dp[i][j][1]=min(dp[i-2][j-1][0]+max(0,h[i-1]-h[i]+1),   //max函数，其实是代替了if，如果h[i-1]-h[i]+1小于0，说明i-1更矮，就不用挖掉了
                           dp[i-2][j-1][1]+max(0,h[i-1]-min(h[i],h[i-2])+1));  //h[i]和h[i-2]，哪个高出来得更多，就挖哪个，这样另一个就也比i-1矮了
            dp[i][j][0]=min(dp[i-1][j][0],
                           dp[i-1][j][1]+max(0,h[i]-h[i-1]+1)); //上面那个理解了这个就没问题了
        }
    }
    for(int i=1;i<=(n+1)/2;++i){
        printf("%d ", min(dp[n][i][0],dp[n][i][1]));
    }
    return 0;
}

```

---

## 作者：EternalAlexander (赞：3)

%%%ouuan

大概是ouuan题解中所说的一堆if/else的解法

当时这个细节dp写到心态爆炸...不过果然还是小黄鸭调试法比较好用，最后1A倒还是不错的。

考虑dp如何记录状态。

前一篇题解中已经提到了要记录正在考虑哪一坐山丘的决策以及之前已经修建了多少个房子，但这样是不够的，考虑当前这座山丘的决策还需要知道前一座山丘被挖的情况。

简单分析可知，最优答案中前一座山丘只可能是:

1.被挖成了第i-2个山丘的高度-1

2.没动

因此dp[i][j][k=(0/1)]表示正在考虑第i做山峰的决策，之前已经修建了j座房子，状态为k(如前所述)来记录状态，然后就可以开始if/else了

一些细节：

不可能有连续两座山丘修建房子，因此可以直接转移给i+2

因为上面写出的原因，最后的答案其实应当取max(dp[n+2][j][0], dp[n+2][j][1])

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

int n, h[5005];
int dp[5005][5005][2];
/*dp[i][j][k]表示正在考虑第i个山丘的决策，已经修建了j个房子，前面一个房子的状态是k
时的最小工作量。
k=0:没动过
k=1:挖成了第i-2的高度减一
dp[1][0][0]=0
*/

int main() {
	scanf("%d", &n);
	for (int i=1;i<=n;++i) scanf("%d", &h[i]);
	std::memset(dp, 127, sizeof(dp));
	dp[1][0][0]=0;
	h[0]=-999999; h[n+1]=-999999;
	h[n+2]=-9999999;
	for (int i=1;i<=n+2;++i) {
		for (int j=0;j<=((i)>>1);++j) {
			//if (i==5&&j==2) printf("!");
			//printf("|%d %d|", dp[i][j][0], dp[i][j][1]);
			dp[i+1][j][0]=std::min(dp[i][j][0], dp[i+1][j][0]);
			dp[i+1][j][0]=std::min(dp[i][j][1], dp[i+1][j][0]);
			if (h[i-1]<h[i]) {
				if (h[i+1]<h[i]) {
					
					dp[i+2][j+1][0]=std::min(dp[i+2][j+1][0], dp[i][j][0]);
				//	if (i==3&&j==1) printf("!%d %d\n", dp[i][j][0], dp[5][2][0]);
				}
				else dp[i+2][j+1][1]=std::min(dp[i+2][j+1][1], dp[i][j][0]+h[i+1]-h[i]+1);
			}else {
				if (h[i+1]<h[i]) dp[i+2][j+1][0]=std::min(dp[i+2][j+1][0], dp[i][j][0]+h[i-1]-h[i]+1);
				else dp[i+2][j+1][1]=std::min(dp[i+2][j+1][1], dp[i][j][0]+h[i+1]-h[i]+1+h[i-1]-h[i]+1);
			}if (i==1) continue;
			if (h[i-2]<=h[i]) {
				if (h[i+1]<h[i]) dp[i+2][j+1][0]=std::min(dp[i+2][j+1][0], dp[i][j][1]);
				else dp[i+2][j+1][1]=std::min(dp[i+2][j+1][1], dp[i][j][1]+h[i+1]-h[i]+1);
			} else {
				if (h[i+1]<h[i]) dp[i+2][j+1][0]=std::min(dp[i+2][j+1][0], dp[i][j][1]+h[i-2]-h[i]);
				else dp[i+2][j+1][1]=std::min(dp[i+2][j+1][1], dp[i][j][1]+h[i-2]-h[i]+h[i+1]-h[i]+1);
			}
		}//printf("\n");
	} for (int i=1;i<=((n+1)>>1);++i) printf("%d ", std::min(dp[n+2][i][0], dp[n+2][i][1]));
	return 0;
}

```

~~为啥您们可以写得这么短啊~~


---

## 作者：Yizhixiaoyun (赞：1)

[博客园食用](https://www.cnblogs.com/yizhixiaoyun/p/16776596.html)

[题目传送门](https://www.luogu.com.cn/problem/CF1012C)

一道蛮有意思的 $\text{dp}$ 好题。

## 题目分析

**~~不会吧，不会真的有人看到这道题没有想到贪心吧...~~**。

只能说考场如果死磕贪心解法会死得很惨，想了几个搞法正确性明显没保证。

在贪心被否决后，动规做法就是显然的。

设计状态 $dp_{i,j}$ 表示前 $i$ 个数中，选择了 $j$ 个数，然后发现对于第 $i$ 个数我们还要判断选或不选。因此额外设计一维，即 $dp_{i,j,k}$ 三维。

不难发现如果我们要选择一个数 $a_i$，则与它相邻的 $a_{i-1}$ 一定不可以选。

- 选择第 $i$ 个数

此时我们不可以选择第 $i-1$ 个数，于是转移到选择第 $i-2$ 个数的情况。

如果选择，那么看 $a_{i-1}$ 是否比 $a_{i-2}$ 高，如果是要减少 $a_{i-1}$ 至 $a_{i-2}-1$，然后再看它是否比 $a_i$ 高，是的话还要再减。

如果不选，那么直接看 $a_{i-1}$ 要不要减就可以了。

- 不选择第 $i$ 个数

此时直接转移到 $a_{i-1}$ 的情况，考虑 $a_{i-1}$ 选不选即可。

## 贴上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5002;
int n,a[maxn];
int dp[maxn][maxn][2];
inline void init(){
	memset(dp,0x7f,sizeof(dp));
	dp[0][0][0]=dp[1][1][1]=dp[1][0][0]=0; 
    cin>>n;
    for(register int i=1;i<=n;++i) cin>>a[i];
} 
int main(){
	init();
    for(register int i=2;i<=n;++i){
        dp[i][0][0]=dp[i-1][0][0];
        for(register int j=1;j<=((i+1)>>1);++j){
            dp[i][j][0]=min(dp[i-1][j][0],dp[i-1][j][1]+max(a[i]-a[i-1]+1,0));
            dp[i][j][1]=min(dp[i-2][j-1][0]+max(a[i-1]-a[i]+1,0),dp[i-2][j-1][1]+max(a[i-1]-min(a[i-2],a[i])+1,0));
        }
    }
    for(register int i=1;i<=((n+1)>>1);++i) cout<<min(dp[n][i][0],dp[n][i][1])<<" ";
}
```

---

## 作者：桃雨凪丝 (赞：1)

DP 裸题，但是细节过多，设计状态较麻烦。

------------
别的题解讲的很好，补充细节。


------------


定义名称为 $f$ 的四维数组，其中 $f_{i,j,k,l}$ 表示，第 $i$ 座山，在已经建了 $j$ 座房子，前个山头有没有房子（$k=0$ 代表没有，否则代表有），前前个山头有没有房子（$l=0$ 代表没有，否则代表有），所消费的时间。

表示前 $i$ 座山中有 $j$ 座用来造房子，第 $i−1$ 座山与第 i 座山的状态（ $0$ 表示不建房子，$1$ 反之）的最小花费。

------------

**为什么可以只要记录两个山（前一座山和前前一座山）的状态呢**

根据严格高，连续两座山必然有一座山不严格高于另一座山，所以两个房子肯定**不相邻**！

重题链接：[P6304](https://www.luogu.com.cn/problem/P6304)。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 1e9+10//不能定义 0x7fffffff，后面操作会越界，变成 -inf
#define lim 5010
int val(int x){
	if(x<=0) return 0;
	return x; 
}//如果本来就合法，t=0
int n,f[lim][lim/2][2][2],a[lim];
int main()
{
	ios::sync_with_stdio(false);//让 cin ，cout 达到 printf 的 1.01 倍
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];                      
		f[i][0][1][0]=inf;
		for(int j=1;j<=(n+1)/2;j++){                                             
			for(int c=0;c<2;c++){
				for(int d=0;d<2;d++){
					f[i][j][c][d]=inf;
				}
			}
		}//当时写的奇奇怪怪，就是把 f 数组全部初始化为 inf
	}
	
	f[1][0][0][0]=f[1][1][0][1]=0;//第 1 座山，0 个房子为 0 个 t
	a[0]=inf;让编号为0的山无限高
	for(int i=2;i<=n;i++){
		for(int j=1;j<=(i+1)/2;j++){
			f[i][j][0][0]=min(f[i-1][j][1][0],f[i-1][j][0][0]);//连续两座山都没有房子，状态转移方程很自然
			f[i][j][1][0]=f[i-1][j][0][1]+val(a[i]-a[i-1]+1);//如果前面一个山有房子，这个山头肯定没有房子，状态转移方程唯一                                                                                                   
			f[i][j][0][1]=min(f[i-1][j-1][0][0]+val(a[i-1]-a[i]+1),f[i-1][j-1][1][0]+val(min((a[i-2]-1),a[i-1])-a[i]+1));
		}
	}
	for(int i=1;i<=(n+1)/2;i++){
		int mi=inf;
		for(int j=0;j<2;j++){
			for(int k=0;k<2;k++){
				mi=min(mi,f[n][i][j][k]);
			}
		}//按照题意，遍历所有房子数，找到每个房子数对应的最小值
		cout<<mi<<" ";
	}
	return 0;
}
```


---

## 作者：一只书虫仔 (赞：1)

#### Description

> 给定一个长度为 $n$ 的序列 $a_i$，请对 $k =1,2,\cdots,\left\lfloor\frac n 2\right\rfloor$ 回答出使 $k$ 个数严格大于他两边的数，至少需要进行多少次让其中一个数加一或减一的操作。

#### Solution

考虑 dp，设 $f_{i,j,k}$ 为 $[1,i]$ 中有 $j$ 个数满足要求至少需要进行多少次操作，其中：

- $k=0$，$a_{i-1}$ 与 $a_i$ 都不满足要求；
- $k=1$，$a_{i-1}$ 满足要求；
- $k=2$，$a_i$ 满足要求。

考虑转移：

- $f_{i,j,0}$ 只能从 $a_{i-1}$ 时 $a_{i-1},a_{i-2}$ 都不满足要求或 $a_{i-2}$ 满足要求转移过来，即：

$$f_{i,j,0}=\min\{f_{i-1,j,0},f_{i-1,j,1}\}$$

- $f_{i,j,1}$ 能从 $f_{i-1,j,2}$ 转移过来，如果 $a_i>a_{i-1}$ 的话就减掉就好了，即：

$$f_{i,j,1}=f_{i-1,j,2}+(a_i-a_{i-1}+1)[a_i>a_{i-1}]$$

- $f_{i,j,2}$ 的情况需要分类讨论：
	- $a_{i-1}$ 与 $a_{i-2}$ 都不满足要求，就直接操作 $a_{i-1}$ 就可以了，处理 $a_{i-1}>a_i$ 即可；
    - $a_{i-2}$ 满足要求，则 $a_{i-1}$ 一定不满足要求，即 $a_{i-1}<a_{i-2}$，换句话说，$a_{i-1}$ 已经进行了替换：$a_{i-1}=\min\{a_{i-1},a_{i-2}-1\}$，我们设其为 $Q$，则按照第一种情况处理 $Q>a_i$ 即可：
    
$$f_{i,j,2}=\min\{f_{i-1,j-1,0}+(a_{i-1}-a_i+1)[a_{i-1}>a_i],f_{i-1,j-1,1}+(Q-a_i+1)[Q>a_i]\}$$

对 $k \in \left[1,\left\lfloor\frac n 2\right\rfloor\right]$，输出 $\min\{f_{n,k,0/1/2}\}$ 即可。

---

## 作者：aakennes (赞：1)


输入格式：

第一行一个正整数n

第二行n个正整数ai

# 思路：

看到这道题的第一眼，我想到了一道题，$2018noipD1T1$铺设道路（链接：https://www.luogu.com.cn/problem/P5019） 看起来十分相似，于是这道题想用朴素的贪心写，结果果然不对，两道题的区别还是很大，贪心的正确性无法保证，所以还是回来老老实实的写动归。

我们设定一个三维数组$f$，$f[i][j][0]$表示前i座山，修建j座房子，且第i座山没有建房子的代价，$f[i][j][1]$表示前i座山，修建j座房子，且第i座山建有房子的代价。

通过简单的模拟我们可以得到，

*$ f[i][j][0]$会从$f[i-1][j][0]$（直接从前一个状态搬过来，前一座山和这座山都不建房子，抹油代价）和$f[i-1][j][1]$（前一座山已经建了房子，那么就要使这座山的高度低于前一座山的高度，代价为$max(0,a[i]-a[i-1]+1)$，有$0$是因为可能这座山的高度原来就低于前一座山的高度）转移过来，转移方程为：$f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+max(0,a[i]-a[i-1]+1))$

* $f[i][j][1]$的处理要比$f[i][j][0]$的处理相对复杂，在此我们明确一个观点，相邻的两座山不可能都建房子，并且在考虑这座山是否建房子的时候，可以只考虑这座山之前的状态，而不去考虑这座山之后的状态，这座山之后的状态我们可以在之后再处理

* 因此，$f[i][j][1]$可以从$f[i-2][j-1][0]$转移过来，因为第$i-2$座山没有建房子，所以第i-1座山的高度没有变化，代价为$max(0,a[i]-a[i-1]+1)$。$f[i][j][1]$同样可以从$f[i-2][j-1][1]$转移过来，因为第i-2座山已经建有房子，所以第i-1座山的高度可能会有变化

* 综上，总代价为：$max(0,a[i-1]-(a[i-2],a[i])+1)$（大家思考一下，为什么这里总代价不是：$max(0,a[i-1]-min(0,a[i-1]-a[i-2]+1)-a[i]+1)) $答案（先思考再看答案）：因为第$i-1$座山的高度一定比第$i-2$和$i$座山低，而这样做只能保证第$i-1$座山的高度低于第$i-2$座山的高度，无法保证第$i-1$座山的高度低于第i座山的高度，因此，我们也可以改成：$max(max(0,a[i-1]-a[i]+1),max(0,a[i-1]-a[i-2]+1)) $）
# 代码：

 ```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=5e3+5,maxe=5e3+5,INF=0x3f3f3f3f;
int n,m,a[maxn],f[maxn][maxn][3],ans;
inline int read(){
    int s=0,t=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*t;
}//朴素快读 
int main(){
    freopen("a.in","r",stdin);
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    a[0]=INF;
    memset(f,0x3f,sizeof(f));
    f[0][0][0]=f[1][0][0]=f[1][1][1]=0;//初始化 
    for(int i=2;i<=n;i++){
        f[i][0][0]=f[i-1][0][0];
        for(int j=1;j<=(i+1)/2;j++){//这里我测了一下，不管是用floor+1还是用ceil都不行，神奇 
            f[i][j][1]=min(f[i-2][j-1][0]+max(0,a[i-1]-a[i]+1),f[i-2][j-1][1]+max(max(0,a[i-1]-a[i]+1),max(0,a[i-1]-a[i-2]+1)));
            f[i][j][0]=min(f[i-1][j][0],f[i-1][j][1]+max(0,a[i]-a[i-1]+1));
        }
        //cout<<floor(i/2)+1<<" "<<(i+1)/2<<endl;
    }
    for(int i=1;i<=(n+1)/2;i++)cout<<min(f[n][i][0],f[n][i][1])<<" ";
    return 0;
}
```



---

## 作者：Su_Zipei (赞：0)

## 分析
先来分析状态的定义，首先输出的时候跟$k$有关，所以$k$一定要先占一个状态，山的数目也要占一个状态，因为不枚举每座山峰，就无法知道山峰的高度，那么状态可不可以只有$i$和$j$呢？显然也不可以，建房子的时候有高度限制。于是状态大致就有了，是一个三维的状态，$dp[i][k][\ \ \ ]$，那么剩下的那个状态怎么选呢，因为我们转移的时候只考虑了前边的$i$个，所以第$i$个建不建，只与第$i-1$个有关，$i$与$i-1$建房的情况有三种，都不建，$i$建，$i-1$建，$i$和$i-1$都建呢？请回去读题。所以定义$dp[i][j][0/1/2]$，表示前$i$个山，建$j$个房子，$0:i$和$i-1$都不建，$1:i$建，$2:i-1$建时最小花费。

接下来考虑状态转移，对于$0$的情况，就是$dp[i-1][j][0]$和$dp[i-1][j][2]$的情况，前者是$i-1$和$i-2$都不建，后者是$i-1$不建，$i-2$建。这两种情况都是满足我们这个状态并且合起来正好能够填满这个状态。

对于$1$的情况，$i$建了，那么$i-1$一定不能建，考虑$i-2$建还是不建，如果$i-2$建了，那么$i-1$的山峰就要满足比$i-2$和$i$都小，如果$i-1$比$i-2$要高，那么$i-1$就至少要被砍到$i-2$的高度$-1$的位置，即$min(a[i-1],a[i-2]-1)$，如果这个数还比$i$高，那么它还要被砍，于是额外的代价就是$h-(a[i]-1)$,所以总代价就是$dp[i-1][j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1)$，再考虑$i-2$不建的情况，就是看$i-1$需不需要砍一刀，所以这个状态最后的转移方程就是：
$$
dp[i][j][1]=min(dp[i-1][j-1][0]+max(0,a[i-1]-a[i]+1),dp[i-1][j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1))
$$
虽然有点长但是好好理解一下还是挺好懂得，最后就是$2$的情况了，如果$i-1$建了，那么就要保证$i$的高度低于$i-1$于是取$a[i]-a[i-1]+1$和$0$的最大值就行。最后可以小小的优化一下，状态转移的时候，$i$能且只能由$i-1$转移过来，所以第一维状态可以省略。

最后就是初始化了，由于要求最小，所以最开始全部初始化为$INF$，初态$dp[0][0],dp[1][1]$均为$0$，稍微解释一下，建$0$座房子，显然叭，不花钱，建一个，也不花。

　　tips：：压维的话注意一点，转移的时候，要考虑转移顺序，先转移$0$，因为$0$受$2$的影响，再转移$2$，$2$受$1$的影响，最后是$1$，这样就可以避免用现阶段的东西来转移现阶段的东西，从而保证了转移的正确性。
  
  ```
#include<iostream>
#include<cstring>
using namespace std;
const int N=2501;
int dp[N][3],a[N<<1];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=dp[1][1]=0;
    for(int i=2;i<=n;i++)
        for(int j=i+1>>1;j;j--){
            dp[j][0]=min(dp[j][0],dp[j][2]);
            dp[j][2]=dp[j][1]+max(0,a[i]-a[i-1]+1);
            dp[j][1]=min(dp[j-1][0]+max(0,a[i-1]-a[i]+1),dp[j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1));
        }
    for(int j=1;j<=n+1>>1;j++)
        cout<<min(dp[j][0],min(dp[j][1],dp[j][2]))<<" ";
}
  ```

---


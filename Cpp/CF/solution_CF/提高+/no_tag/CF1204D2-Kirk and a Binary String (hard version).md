# Kirk and a Binary String (hard version)

## 题目描述

给你一个二进制字符串$s$，让你求出一个新的二进制字符串$t$，使其满足以下条件：

1. 新字符串的$0$的个数尽可能多。
1. 对于每个$l,r(1≤l≤r≤n)$，两个字符串的最长不下降子序列等长。

## 样例 #1

### 输入

```
110
```

### 输出

```
010
```

## 样例 #2

### 输入

```
010
```

### 输出

```
010
```

## 样例 #3

### 输入

```
0001111
```

### 输出

```
0000000
```

## 样例 #4

### 输入

```
0111001100111011101000
```

### 输出

```
0011001100001011101000
```

# 题解

## 作者：Llf0703 (赞：8)

[更好的阅读体验](https://llf0703.com/p/cf-1204.html#dkirkandabinarystring)

可以发现一定是把原序列中的 $1$ 变成 $0$ ，那么题目就变成了选一些 $1\rightarrow 0$ 。

当一个数是 $1$ 时，它只能连接后面的 $1$ ；变 $0$ 后就能连 $0$ 了，所以只要它后面 $0$ 的个数 $\le$ $1$ 的个数，那么就可以选它。

至于以它为终点的区间，因为它前面连续的 $1$ 也会随之被删掉，所以它们之间的不降序列个数不变。

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read()
{
    char ch=getchar(); int f=1,x=0;
    while (ch<'0' || ch>'9') { if (ch=='-') f=-1; ch=getchar(); }
    while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
    return f*x;
}

int n;
char s[100005];

signed main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    int sum=0; //0与1个数的差
    for (int i=n;i;i--)
    {
        if (s[i]=='0') sum++;
        else if (sum) sum--;
        else s[i]='0';
    }
    return !printf("%s",s+1);
}
```

---

## 作者：wf1594937223 (赞：5)

一道很好的题，这里主要讲一下翻译的第一篇。

@Llf0703 题解的代码是没有任何问题的，但是他的讲述可能有些许欠缺。

在此感谢[@FourteenObsidian](https://www.luogu.com.cn/user/108098)对我做此题不可忽视的帮助。

---

引理：我们将一个 **没有任何等效序列** 的串（即不能通过将其中一些0转成1且将一些1转成0使得满足翻译中的第二条）称为 "fixed" 串，那么，"fixed"串有以下性质：

- 我们将数字“1”看成“(”，“0”看成“)”，那么所有的"fixed"串都是一个合法的括号序列；

证明：

为方便描述，我们将把串中数字“1”看成“(”，“0”看成“)”后是一个合法括号序列的串称为“nfixed”串；

我们将既是"nfixed"也是"fixed"的串称为"dfixed"串；

充分性：“nfixed”串一定"fixed"：

我们考虑以下几点：

- 对于串“10”，它是一个"dfixed"串；

- 对于串 $p,q$，若它们均是"dfixed"串，那么 $pq$ 也是"dfixed"串；（显然，你不能改任意一个位置上的值）

- 对于串 $p$，若它是"dfixed"串，那么串 $1p0$ 也是；（考虑按长度归纳证明，若长为 $|s|-2$ 的所有dfixed串都是满足这三条，那么将其前面加1，后面加0，任意改这两个中的哪一个都会使得原串的最长不下降子序列长度+1）

而以上三种操作能生成所有的"nfixed"串，所以证毕。

必要性：只有满足这样的条件的串"fixed"：

引理：对于一个"nfixed"串，它一定满足：它的最长不降子序列长度一定是 $\dfrac{|s|}{2}$，且可以通过全取0或全取1得到；

引理证明：把合法的不降子序列看成一个括号串，则它一定是如")...)(...("的形式；将其中的所有")"换成"("或将其中的所有"("换成")"均能成立且长度不变；

必要性证明：

- 按长度归纳证明，我们发现将其他串**剔除**掉所有的"nfixed"串后，剩下的串一定是形如“0...01...1”（可能没有0或没有1）的形式；我们发现，将这个剩下的串改成"000...0"的形式，再放回原序列中，一定合法；因为对于原来如同"0...0[nfixed]0...01...1[nfixed]1...1"的子串，原来的和改后的最大值均是 $\dfrac{total\_len\_of[fixed]}{2}+others$；所以它有等效序列，不满足我们的定义，所以证毕。

于是，我们可以将原串中的所有"fixed"串剔除（因为它们反正不能被改）；这样我们得到的串就是一个形如"0...01...1"的串，我们将后面的一截"1"改为等长的一截"0"就好啦~

找"fixed"串可以考虑从后往前扫，因为考虑到"fixed"串一定有对于任意后缀，0的个数 $\ge$ 1的个数，不符合的就一定不在fixed串中；

代码实现详见@Llf0703 的题解~

---

## 作者：Eibon (赞：3)

可以通过线性 dp 进行求解。

设 $dp_{i}$ 表示以 $i$ 为结尾的最长不下降子串。

则 $dp_{0}=dp_{0}+[s_{i}=0]$

$dp_{1}=\max(dp_{0},dp_{1})+[s_{i}=1]$

考虑能否进行优化，发现最长不下降子串一定为一串 $0$ 连着一串 $1$，其中 $0$ 的数量与 $1$ 的数量可以为 $0$。

则更改子串中的数时，必须使这一位往后的 $1$ 的数量不得小于 $0$ 的数量，不然就会使最长不下降子串改变，于是维护 $1$ 与 $0$ 的差值即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
int n,sum;
char s[100005];
signed main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    for (int i=n;i;i--){
        if(s[i]=='0'){
			sum++;
		}
        else if(sum){
			sum--;
		}
        else{
			s[i]='0';
		}
    }
    printf("%s",s+1);
    return 0;
}
//dyyyyds
```

---

## 作者：Zpair (赞：3)

证明思路来源：[wf1594937223](https://www.luogu.com.cn/user/34200)

定义 A 类串为不存在新的不同二进制字符串，使得其满足题中第二条限制的串。

定义 B 类串为将 $1$ 看作左括号，$0$ 看作右括号，其形成一个合法括号序列的串。

我们断言，A 类串与 B 类串等价，证明如下：

- 所有 B 类串都是 A 类串。

  > 我们给出 B 类串的生成方式。
  >
  > 1. 空串是一个 B 类串。
  > 2. 若 $p,q$ 都是 B 类串，则 $pq$ 也是 B 类串。
  > 3. 若 $p$ 是 B 类串，则 $1p0$ 也是 B 类串。
  >
  >  对上面的生成方式归纳，发现每一步都可以保证生成出的串是 A 类串，证毕。

- 所有非 B 类串都不是 A 类串。

  在证明其之前，我们需要先证明一些引理：

  - 引理1：长度为 $n$ 的 B 类串的最长不降子序列长度为 $\frac n 2$，且可以通过只取 $0/1$ 得到。

    > 考虑不降子序列的形态，一定是类似 $)))(((($ 的形式，它们之间一定无法匹配。
    >
    > 所以若不降子序列长度为 $x$，则至少还需要 $x$ 个括号与它们匹配，所以 $x$ 最大为 $\frac n 2$。
    >
    > 一个合法的括号序列，$0/1$ 的个数为 $\frac n 2$，所以可以通过只取 $0/1$ 得到，证毕。

  - 引理2：对于一个 B 类串的前缀，其最长不降子序列一定取可以通过只取 $1$ 得到。

    > 在前缀后加入一些 $0$，使得其是一个 B 类串。根据引理1，得到其最长不降子序列可以通过取 $1$ 得到。
    >
    > 再删去末尾的一些 $0$，显然全取 $1$ 一定优于在删去前取 $0$，证毕。

  - 引理3：对于一个 B 类串的后缀，其最长不降子序列一定可以通过只取 $0$ 得到。

    > 证明类似引理2，因此略去不证。

  然后就可以证明原问题。

  > 考虑在非 B 类串中删除所有极长 B 类串。
  >
  > 根据括号序列的性质，最后剩下的一定是形如 $00\cdots011\cdots 1$ 的形式。
  >
  > 设其个数为 $k$，剩余得到的序列为 $\{a_i\}$。
  >
  > 然后对于每两个数之间，存在一个可以为空的 B 类串。
  >
  > 考虑该串的任意子串，在删除后的位置一定是一段 B 类串后缀，一段 $a$ 和 B 类串夹在一起，一段 B 类串前缀拼起来。
  >
  > 设其中第一个 $a$ 为 $a_i$，最后一个 $a$ 为 $a_j$。
  >
  > 根据上面的三条引理，可以知道其最长不降子序列构成为：$a_i$ 之前取 $0$，$a_i$ 到 $a_j$ 之间取 $a_i$，$a_j$ 之后取 $1$。
  >
  > 所以我们只需保证 $a_i \le a_j$ 即可，于是我们取任意 $00 \cdots 0 11 \cdots 1$ 的形式一定合法，证毕。

  于是做法就简单了，根据上面的证明，只需删除所有合法的括号序列，然后把剩余的变成全 $0$ 再还原即可。

---

## 作者：Super_Cube (赞：1)

# Solution

把 $0$ 变成 $1$ 不如不变，所以问题转为选一些 $1$ 变为 $0$。最长不降子序列为一些 $0$ 拼上一些 $1$（可以为空），所以如果一个 $1$ 想要变成 $0$，其后面的 $1$ 个数要不多于 $0$ 的个数。于是从后往前倒着扫一遍，贪心地更改即可。

# Code

```cpp
#include<bits/stdc++.h>
char s[100005];
int main(){
	scanf("%s",s+1);
	for(int i=strlen(s+1),c=0;i;--i){
		if(s[i]=='0')++c;
		else if(c)--c;
		else --s[i];
	}
	puts(s+1);
	return 0;
}
```

---

## 作者：NightmareAlita (赞：1)

## 形式化题意

给你一个长为 $n$ 的仅包含 $0$ 和 $1$ 的串，要求尽可能多地将里面的 $1$ 改成 $0$ 使得在得到的新串中，对于 $\forall l,r\in [1,n](l \le r)$，两个串的 $[l,r]$ 区间内的最长不降子序列等长。

## 策略分析

题中给的数据范围是 $10^5$，我们很容易去思考一些 $O(n \log n)$ 的做法，从而去找数据结构来维护，但这是 CF 的题，所以我们坚信这一定是一道人类智慧题。所以我们充分发扬人类智慧，$O(n)$ 来构造这个题。

对于只有 $0,1$ 的串来讲，一个序列想要不降其实只需要满足两个条件：

- 如果当前位为 $0$，那么后面无论 $0,1$ 都是不降的；
- 如果当前位为 $1$，那么后面为 $1$ 才是不降的。

那么我们是不是很容易发现本题的构造原则：一个 $1$ 能够被替换成 $0$ **当且仅当这个 $1$ 后面的 $1$ 的个数大于等于 $0$ 的个数**。这个结论说出来很抽象，我们用一个例子来理解。

```
0 1 1 1 1 1 0 0 0
1 2 3 4 5 6 7 8 9 
```

为了方便读者观看，这个串下面的数字是其下标。我们以下标为 $2$ 的这个下标的位置为例，$[2,9]$ 区间内的最长不降子序列是 `1 1 1 1 1`，这一位改成 $0$ 后变成 `0 1 1 1 1`，不管怎么变长度都不会变，因为其后 $1$ 比 $0$ 多，最长不降子序列一定是连着一坨 $1$。然而对于下标为 $4$ 这个位置的 $1$ 来讲，这一位后面的 $0$ 比 $1$ 多，我们将这一位换成 $0$ 后，$[4,9]$ 区间内的最长不降子序列从 `1 1 1` 变成了 `0 0 0 0`，不符合我们的构造条件。

出现这种情况的原因是，对于当前位来讲，它的最长不降子序列只能是一堆 $1$，这是我们刚刚提到过的结论，改成 $0$ 后就有了三种选择，而我们必须让它别无选择，这就要求更改的这一位只能继续选后面连一堆 $1$，那么我们发现这种别无选择的情况就必须让当前位后的 $1$ 的数量比 $0$ 的数量多，这就证明了我们刚刚得出的结论，这道题也就做完了。

在写代码的时候，我们可以把维护个数改成维护 $0$ 与 $1$ 的个数的差值，这样可以简化代码难度，当 $0$ 的个数减去 $1$ 的个数非正时就把这一位的 $1$ 换掉。

## 参考代码

  ``` cpp
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;

namespace SHAWN {
    string s;
    int cnt;
    int work()
    {
        cin >> s;
        for (int i = s.size() - 1; i >= 0; --i) {
            if (s[i] == '0') { ++cnt; }
            else if (s[i] == '1' && cnt <= 0) { s[i] = '0'; }
            else { --cnt; }
        }
        cout << s << '\n';
        return 0;
    }
}

signed int main() {
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    return SHAWN :: work();
}
  ```





---

## 作者：Iveloid (赞：1)

很奇怪的题目
不明白为什么不能直接在读到的字符串上改
但是大致的想法是,如果当前位是1才会改,
然后如果从现在位置开始的Lis对应的是11111这样的子序列
,那么你当前位1变成0也没事, 否则显然不成立,因为倒推的lis[i] 对于s[i]==0肯定会是lis[i+1] +1 
```c
#include<bits/stdc++.h>
using namespace std;
char s[100005],t[100005];
int n,dp[100005][2];
signed main(){
  scanf("%s",s+1);
  n=strlen(s+1);
  memcpy(t,s,sizeof(s));
  dp[n+1][0]=dp[n+1][1]=0;
  for(int i=n;i>=1;--i){
    dp[i][0]=max(dp[i+1][1],dp[i+1][0])+(s[i]=='0');
    dp[i][1]=dp[i+1][1]+(s[i]=='1');
    if(s[i]=='1'&&dp[i][1]>dp[i][0]) t[i]='0';
  }
  cout<<(t+1)<<endl;
  return 0;
}

```


---

## 作者：Dr_殇 (赞：1)

我觉得我这道题的算法可能有些玄学。。。

## 题意简述

给你一个二进制字符串，让你求一个新的二进制字符串，使其$0$的个数尽量多且对于每个$l,r(1≤l≤r≤n)$，原串与新串的最长不下降子序列等长。

## 题目分析

根据题意，可知是将原串中的一些字符修改。但是，会有以下几个问题出现：

### $Question 1$ 修改哪些字符

首先，$0$是一定不能修改的，修改之后不满足使$0$的个数最多的条件。

那么只有$1$是可以改的，这个问题算是解决了，但又有下面两个问题出现了：

### $Question 2$ 修改多少$1$

我们先假设原字符串的最长不下降子序列的长度为$len$，且原串中$0$的个数为$cnt$，如果$cnt$恰好等于$len$，那么证明原字符串的最长不下降子序列全为$0$组成，不需修改，直接输出原序列即可。

若是不等于，那么我们需要修改$len-cnt$个$1$为$0$，只有这样才能使0的个数尽可能多。

### $Question 3$ 修改哪些$1$

知道修改多少，修改哪些就不是很难了。首先我们只需要考虑$l=1$时的情况，对于其他$l$的值是无需考虑的。所以我们得求出原字符串对于$l=1,1≤r≤n$的最长不下降子序列的长度。

我们设$f_i$为第$i$个位置以$1$结尾的最长不下降子序列的长度，$sum_i$为前$i$为$0$的个数，可以得出转移方程：

$$
f_i = \begin{cases} max(f_{i-1}+1,sum_{i-1}+1)(s_i=1)\\f_{i-1}(s_i=0)\end{cases}
$$

$$
sum_i = \begin{cases} sum_{i-1}+1(s_i=0)\\sum_{i-1}(s_i=1)\end{cases}
$$

然后得出这个即可处理，首先对于第$i$个位置，如果将它从$1$修改成$0$，那么必须满足$f_i=sum_i+1+c$（$c$为过去修改的个数）。不过若是你如此处理的话，可能对后面有所影响。用这个算法处理出的字符串主要有以下几种可能：

$0001001100011011101000$

$0000001100111011101000$

不难发现，这两个序列都是错误的，所以这种方法不可取。若是要不对后面有影响，必须逆序处理。

令$now=len-cnt$，对于第$i$个位置，如果将它从$1$修改成$0$，那么必须满足$f_i=sum_i+now-c$（$c$为过去修改的个数）。

经过如此处理，便会得出正确答案。

## 代码如下

```cpp
#include <cmath>
#include <queue>
#include <string>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
 
int l, now, dp[100005][2];// dp[i][0] 即为 sum[i]，dp[i][1] 即为f[i]
char c[100005], s[100005];
 
long long Read() {
	long long k = 0, tmp = 1; char _c = getchar();
	while (_c > '9' or _c < '0') {
		if (_c == '-') tmp = -1;
		_c = getchar();
	}
	while (_c <= '9' and _c >= '0') {
		k = (k << 1) + (k << 3) + (_c ^ 48);
		_c = getchar();
	}
	return k * tmp;
}
void Work();
 
int main() {
	Work();
}
 
void Work() {
	cin >> c + 1;
	l = strlen(c + 1);
	for (int i = 1; i <= l; i++) {
		dp[i][1] = dp[i - 1][1];
		dp[i][0] = dp[i - 1][0];
		if (c[i] == '1') dp[i][1] = max(dp[i - 1][1] + 1, dp[i - 1][0] + 1);
		else dp[i][0] = dp[i - 1][0] + 1;
	}
	if (dp[l][0] >= dp[l][1]) {
		cout << c + 1 << endl;
	}
	else {
		now = dp[l][1] - dp[l][0]; // dp[l][1]即为cnt，dp[l][0]即为sum
		for (int i = l; i >= 1; i--) {
			if (c[i] == '0') s[i] = '0';// 如果是0，不修改
			else {
				if (dp[i][1] - dp[i][0] == now and now > 0) {// 如果是1且满足条件，修改
					s[i] = '0';
					now--;
				}
				else s[i] = '1';// 否则不修改
			}
		}
		for (int i = 1; i <= l; i++) {
			printf("%c", s[i]);// 输出答案
		}
		printf("\n");
	}
}
```


---

## 作者：Unnamed114514 (赞：0)

被 \*2100 硬控了，如果 NOIP 出 $4$ 道 greedy 我怕不是废了。

先把原串复制下来，显然 $0$ 不可能变成 $1$，只有可能是 $1$ 变成 $0$。

注意到 $1$ 变成 $0$ 对答案的影响只根后面是 $1/0$ 有关，所以倒序枚举，确定后缀。

只有后面只能取 $0$ 的时候 $1$ 不能变成 $0$，容易发现此时后面存在一个前缀使得 $0$ 比 $1$ 多。

维护最大子段和就行了，注意这里考虑的是原串的方案，所以维护的是原串的最大子段和。

---

## 作者：xxxr_2024 (赞：0)

# CF1204D2 Kirk and a Binary String (hard version) 题解
## 分析
先来分析 $01$ 串的最长不下降子序列。全是 $0$ 显然是不下降的，如果中间出现一个 $1$，为了维护不下降的性质，后面就只能全是 $1$。一句话概括一下，$0$ 后面能跟 $0,1$，$1$ 后面只能跟 $1$。

现在来分析这道题。显然有一种 $\mathcal O(n^2)$ 的做法。从后往前遍历，如果这一位是 $1$，就先改成 $0$，然后用线性 dp 来求他们最长不下降子序列，看有没有改变。具体实现可以用 $dp[i]$ 表示以 $i$ 结尾的最长不下降子序列的长度，代码就不放了。

考虑 $\mathcal O(n)$ 做法。还是得从后往前遍历，但是我们发现，把一位从 $1$ 改成 $0$ 会影响最长不下降子序列长度时，当且仅当这以为后面的 $0$ 的个数比 $1$ 的个数大。因为当你把一个 $1$ 改成 $0$ 时，这个 $0$ 就可以和它后面的 $0,1$ 都构成不下降子序列，而原来的 $1$ 仅仅只能和后面的 $1$ 来构成。只有后面的 $1$ 的个数大于等于 $0$ 的个数时，才不会对最长不下降子序列的长度造成影响。

## $\mathcal O(n)$ 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Raiden
{
    signed work()
    {
        string s;
        cin>>s;
        int n=s.size();
        int ans=0;
        for(int i=n-1;i>=0;i--)
        {
            if(s[i]=='0')
            {
                ans++;
            }
            else if(s[i]=='1'&&ans==0)
            {
                s[i]='0';
            }
            else
            {
                ans--;
            }
        }
        cout<<s<<endl;
        return 0;
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return Raiden::work();
}
```

---


# Sequence Sorting

## 题目描述

给定一个整数序列 $a_1, a_2, \dots, a_n$。

你可以对该序列进行如下操作：选择某个整数 $x$，将所有等于 $x$ 的元素一起移动到序列的开头或结尾。注意，每次操作必须将所有等于 $x$ 的元素统一移动到一个方向。

例如，若 $a = [2, 1, 3, 1, 1, 3, 2]$，你可以通过一次操作得到以下序列（为方便起见，将等于 $x$ 的元素称为 $x$ 元素）：

- 若将所有 $1$ 元素移到开头，得到 $[1, 1, 1, 2, 3, 3, 2]$；
- 若将所有 $1$ 元素移到结尾，得到 $[2, 3, 3, 2, 1, 1, 1]$；
- 若将所有 $2$ 元素移到开头，得到 $[2, 2, 1, 3, 1, 1, 3]$；
- 若将所有 $2$ 元素移到结尾，得到 $[1, 3, 1, 1, 3, 2, 2]$；
- 若将所有 $3$ 元素移到开头，得到 $[3, 3, 2, 1, 1, 1, 2]$；
- 若将所有 $3$ 元素移到结尾，得到 $[2, 1, 1, 1, 2, 3, 3]$。

你需要求出，使序列 $a$ 变为非降序（即对于所有 $2 \le i \le n$，都有 $a_{i-1} \le a_i$）所需的最少操作次数。

注意，你需要回答 $q$ 个独立的询问。

## 说明/提示

对于第一个询问，你可以先将所有 $1$ 元素移到开头（此时序列变为 $[1, 1, 1, 3, 6, 6, 3]$），再将所有 $6$ 元素移到结尾。

对于第二个询问，序列本身已经有序，因此答案为 $0$。

对于第三个询问，你需要将所有 $2$ 元素移到开头。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
7
3 1 6 6 3 1 1
8
1 1 4 4 4 7 8 8
7
4 2 5 2 6 2 7
```

### 输出

```
2
0
1
```

# 题解

## 作者：泠小毒 (赞：10)

# Sequence Sorting
有n个数的序列，每次操作可以选择一种数，将他们全部移到开头或结尾：

1,5,2,1,3,2 -> 1,1,5,2,3,2（选1）

1,5,2,1,3,2 -> 5,2,3,2,1,1（选1）

问最少需要多少次操作，才能使序列变为非递减序列。
## 广告插入
在我的博客里看题解使用效果更佳哦QwQ

[慕容琳的后花园](https://muronglin.top/luogu-cf1223d/)

[博客园(同步更新)](https://www.cnblogs.com/muronglin/p/luogu-cf1223d.html)
## 解法
显然最多的操作次数就是数的种数

那怎么节省操作次数呢

考虑有些数不用动，而不用动的这些数会构成一个

离散化之后值连续的不下降子序列

那么我们求出最长的值连续的不下降子序列即可
## ac代码
```cpp
#include<bits/stdc++.h>
#define N 300010
using namespace std;
int T,n,cnt,x,ans,a[N],first[N],last[N],f[N];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n),ans=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			if(!first[a[i]])
				first[a[i]]=i;
			last[a[i]]=i;
		}
		sort(a+1,a+n+1);
		cnt=unique(a+1,a+n+1)-a-1;
		for(int i=1;i<=cnt;i++)
		{
			if(first[a[i]]>last[a[i-1]])
				f[a[i]]=f[a[i-1]]+1;
			else f[a[i]]=1;
			ans=max(ans,f[a[i]]);
		}
		printf("%d\n",cnt-ans);
		for(int i=1;i<=cnt;i++)
			first[a[i]]=f[a[i]]=0;
	}
	return 0;
}
```

---

## 作者：Mine_King (赞：4)

## Problem

[CF1223D](https://www.luogu.com.cn/problem/CF1223D)

**题目大意：**

给出一个长度为 $n$ 的序列 $a$，其中对于 $\forall 1 \le i \le n,1 \le a_i \le n$。  
每次操作可以把所有值为 $x$ 的数放到序列的最前面或最后面，问使序列单调上升的最小操作次数是多少。

## Solution

首先有两个很重要的性质。

第一个性质，每一种数最多只会被移动一次。  
可以用反证法来证明。假设一个数 $x$ 被移动到了头或尾，那么它再被移动就需要在之后有一个比x大的数移动到了头或一个比 $x$ 小的数移动到了尾。  
那么此时我们可以通过先移动那个数再移动 $x$ 的方式使它的移动次数又变会 $1$ 次。

第二个性质，不被移动的数一定是一段连续的数。这里的连续指的是在数值上相邻两种数的差值为 $1$。  
如果不是一段连续的数，那么说明中间间隔的那些数是需要被移动的，但是移动之后，必然会导致不移动的数的位置错乱，所以是不可能的。

当然，不移动的数也必须本身有序才行。那么接下来的目标就是找到这样满足要求的最长的长度。

我们考虑当数没有重复，即原序列是一个排列时怎么做。  
可以使用递推，设 $f_i$ 表示以数字 $i$ 为结尾的最长的不移动的数字长度。  
很明显，若数字 $i-1$ 出现在 $i$ 之前，则 $f_i=f_{i-1}+1$，也就是继承前面的答案。否则 $f_i=1$，因为无法继承答案，所以只能是自己一个。  
最后对于所有的 $1 \le i \le n$，取最大的 $f_i$ 即可。时间复杂度为 $O(n)$。

那么对于有重复的数，我们发现只要改动对于能否继承的判断即可。那么什么情况下能继承，什么情况下不能呢？我们把所有的情况都枚举一遍。当然枚举时也有技巧。我们可以把相同的数看做一段区间，最左边的数的位置即为左边界，最右边的数的位置即为右边：  
![](https://cdn.luogu.com.cn/upload/image_hosting/z9pdyjaj.png)  
![](https://cdn.luogu.com.cn/upload/image_hosting/hlpn1rct.png)  
![](https://cdn.luogu.com.cn/upload/image_hosting/bppc73ru.png)  
上面三张图中，红色的表示前一个数的区间，蓝色的表示当前数的区间。

我们观察后发现：只有第一张图的情况可以继承答案，即上一个数整个区间都在当前数区间的左边，此时满足上一个区间的右边界比当前数的左边界小。  
第二和第三张图都不满足条件，即两个区间交叉或当前数整个区间在上一个数的区间的左边。此时满足上一个数的区间的右边界比当前数区间的左边界大。  
那么，我们只要预处理出每个区间的左右边界，就可以做到 $O(1)$ 判断。预处理可以 $O(n)$ 做。

递推方式与排列时的方式相同。总时间复杂度为 $O(n)$。  
另外还有一点需要注意，因为有重复数字，所以必然有一些数字没有出现，若当前数是 $i$，那么不能从 $i-1$ 转移过来，应该从上一个出现的数转移过来。

## Code
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int q,n,a[300005],l[300005],r[300005];
int sum,ans,f[300005];
int main()
{
	q=read();
	while(q--)
	{
		ans=0;
		n=read();
		for(int i=1;i<=n;i++) l[i]=r[i]=f[i]=0;
		for(int i=1;i<=n;i++)
		{
			a[i]=read();
			if(l[a[i]]==0) l[a[i]]=i;
			r[a[i]]=i;
		}//读入并预处理。
		sum=n;//sum表示值不同的数的个数。
		int lst=0;//lst表示上一个出现的数。
		for(int i=1;i<=n;i++)
		{
			if(l[i]==0){sum--;continue;}
			if(l[i]<r[lst]) f[i]=1;//不能继承答案
			else f[i]=f[lst]+1;//能继承答案
			ans=max(ans,f[i]);
			lst=i;
		}
		printf("%d\n",sum-ans);
	}
	return 0;
}
```

---

## 作者：123zbk (赞：1)

首先记录每一种数字开头的位置和结尾的位置。只有当一个数字的开头的位置大于另一个数结尾的位置时才是有效的。

然后想要操作次数最少，就是要不动的数字最多，也就是求最长非递减序列的个数。将序列排序和去重，然后 $dp$，$dp_i$ 代表到 $i$ 这个数字时最长的非递减个数。

如果当前数字的左端点大于上一个数字的右端点，$dp$ 值就加 $1$。否则，$dp$ 值就回到 $1$。

最后用总共的数字种数减去即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=3e5+5;
int T,n,a[maxn],l[maxn],r[maxn],dp[maxn],ans,id;
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
            if(l[a[i]]==0)
            {
                l[a[i]]=i;
            }
            r[a[i]]=i;
        }
        sort(a+1,a+n+1);
        id=unique(a+1,a+n+1)-a-1;
        for(int i=1;i<=id;i++)
        {
            if(l[a[i]]>r[a[i-1]])
            {
                dp[a[i]]=dp[a[i-1]]+1;
            }
            else
            {
                dp[a[i]]=1;
            }
            ans=max(ans,dp[a[i]]);
        }
        printf("%d\n",id-ans);
        for(int i=1;i<=n;i++)
        {
            l[i]=r[i]=0;
        }
        id=ans=0;
    }
    return 0;
}
```

---


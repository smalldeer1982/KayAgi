# Zigu Zagu

## 题目描述

你有一个长度为$n$的二进制串$a$

现在给出$q$次询问，每次询问给出两个数$l,r$，保证$1 \leq l \leq r \leq n$。

令$s=a[l,r]$，你可以对$s$做如下操作：

1.选择两个数$x,y$，满足$1 \leq x \leq y \leq |s|$。令子串$t=s[x,y]$，对于所有

的$1 \leq i \leq |t|-1$，需要满足$t_i \neq t_{i+1}$，操作才是合法的，否则是不

合法的。注意$x=y$时永远是合法的。

2.从$s$中删除$s[x,y]$。

对于每一个询问，请求出最少需要多少个操作才能把$s$变成一个空串。

标记提示:$s[l,r]$表示从$l$开始,到$r$结束的子串。

## 样例 #1

### 输入

```
5 3
11011
2 4
1 5
3 5```

### 输出

```
1
3
2```

## 样例 #2

### 输入

```
10 3
1001110110
1 10
2 5
5 10```

### 输出

```
4
2
3```

# 题解

## 作者：NusGhy (赞：13)

  nb 题  
  
  考虑计数区间内 $00$ 和 $11$ 二元组的数量，分别设为 $x,y$。
  
  首先显然每次会删掉一个极长的满足条件的区间。
  
  假如删掉了一个偶数长度的区间（$0[0101...0101]1\rightarrow 01$），那么 $x$ 和 $y$ 都会减少一。
  
  假如删掉一个奇数长度的区间，（$1[1010...0101]1\rightarrow 11$），那么 $x$ 或 $y$ 会减少一。
  
  并且发现只要 $x$ 和 $y$ 都不为 $0$，那么总是可以找到一个偶数长度的区间删（相邻的两个不同的二元组之间总是可以删掉）。
  
  同理，奇数长度段在 $x$ 或 $y$ 不为零时一定可以找到并删掉。
  
  由于我们一定要消掉所有的二元组，并且显然没有更好的删掉的策略，所以消掉所有的二元组最少要 $\max (x,y)$ 次（不妨设 $x\leq y$，前 $x$ 次删偶数长度段，后 $y-x$ 次删奇数长度段）。
  
  于是最终的答案就是 $\max(x,y)+1$ ，前缀和优化回答询问即可。
  
  code & data：[https://codeforces.com/contest/1672/submission/155021164](https://codeforces.com/contest/1672/submission/155021164)
  
  题外话：CF 官方题解是一个超级复杂的论文解法，想锻炼英语阅读的话可以去看看（

---

## 作者：ioker (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/CF1672H)
## 题目描述
你有一个长度为 $n$ 的二进制串 $a$，和 $q$ 个询问，每个询问包含 $l,r$，保证$1 \le l \le r \le n$。

每组询问设有字符串 $s=a[l,r]$。

选择两个数 $x,y$ 满足 $1\le x \le y\le |s|$，令字串 $t=s[x,y]$。

当所有的 $1\le i\le |t|-1$ 都满足 $t_i\not=t_{i+1}$ 或 $x=y$ 时，可以删除字串 $t$。

求每个 $s$ 清空的最少操作次数。
## 思路

设出现 $\text{00}$ 的数量为 $X$，出现 $\text{11}$ 的数量为 $Y$。

假如删掉一个偶数长度的区间 $(0[01...01]1\rightarrow 01)$，那么 $X$ 和 $Y$ 都会减少一。

假如删掉一个奇数长度的区间 $(1[101...01]1\rightarrow 11)$，那么 $X$ 或 $Y$ 会减少一。

而每次操作在 $X\not=0,Y\not=0$ 时，一定可以找到一种删除策略（总能找到 $01$ 的情况）。

因为是求最少的操作次数，所以删除一个偶数区间更优，最后会剩下 $\text{abs}(X-Y)$ 个。

所以操作次数最少是 $\text{max}(X,Y)$。

于是最终答案是 $\text{max}(X,Y)+1$

$X$ 和 $Y$ 可用前缀和维护，时间复杂度 $\Theta(n+q)$，参考代码见下。

```cpp
#include <bits/stdc++.h>
using namespace std;
char c[10000001];
int s1[10000001], s2[10000001];
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, m, l, r;
    cin >> n >> m >> c[1];

    for (int i = 2; i <= n; i++) {
        cin >> c[i];
        s1[i] = s1[i - 1], s2[i] = s2[i - 1];

        if (c[i] != c[i - 1])
            continue;

        if (c[i] == '1')
            s1[i]++;
        else
            s2[i]++;
    }

    while (m--) {
        cin >> l >> r;
        cout << max(s1[r] - s1[l], s2[r] - s2[l]) + 1 << '\n';
    }

    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

一道妙题！

原串是一个 01 串，要求删除 01 交替的串，我们分情况讨论。

如果删除了一个偶数长度的区间：

$ \ldots 0[0101 \ldots 0101]1 \ldots \to  \ldots 01 \ldots$ 

或者

$ \ldots 1[1010 \ldots 1010]0 \ldots \to  \ldots 10 \ldots$ 

发现串 $\text{00}$ **和**串 $\text{11}$ 的数量都减少了一个。

而如果删除了一个奇数长度的区间：

$ \ldots 0[0101 \ldots 010]0 \ldots \to  \ldots 00 \ldots$ 

或者

$ \ldots 1[1010 \ldots 101]1 \ldots \to  \ldots 11 \ldots$ 

发现串 $\text{00}$ **或**串 $\text{11}$ 的数量都减少了一个。

容易发现，在同时存在串 $\text{00}$ 和串 $\text{11}$ 时，一定是存在偶数长的串。

又发现，在不存在串 $\text{00}$ 和串 $\text{11}$ 时，原串一定是一个 01 交替的串，可以一次性删除。

所以答案是 $\max(sum_{00},sum_{11}) + 1$。

代码大家都会写，就不展示了。

---


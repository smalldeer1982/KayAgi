# Evaluate It and Back Again

## 题目描述

Aidan and Nadia are long-time friends with a shared passion for mathematics. Each of them has a favorite number: Aidan's favorite number is $ p $ , and Nadia's is $ q $ .

To commemorate their friendship, their friends want to make a present: a plaque with an arithmetic expression whose value is equal to their favorite numbers. At first glance, it sounds impossible, but the answer is simple: Aidan reads left-to-right, while Nadia reads right-to-left, so the same expression can have different values for them.

For example, if 2023-12-13 is written on the plaque, then Aidan would calculate the result as $ 2023-12-13 = 1998 $ , and Nadia would calculate it as $ 31-21-3202=-3192 $ .

Find an arithmetic expression that, when read left-to-right, evaluates to $ p $ , and, when read right-to-left, evaluates to $ q $ . Its length must be at most $ 1000 $ characters. It's guaranteed that such an expression exists for all valid inputs.

## 样例 #1

### 输入

```
1998 -3192```

### 输出

```
2023-12-13```

## 样例 #2

### 输入

```
413 908```

### 输出

```
12*34+5```

# 题解

## 作者：Kotobuki_Tsumugi (赞：11)

考虑一个问题：是否存在一个构造序列，使得其正着读对答案有贡献，反着读对答案没贡献。

答案是肯定的，其中一种构造方法如下。

$$0+k+k-0$$

用这种构造方法，正着读的贡献为 $2k$，反着读贡献为 $0$。

同理我们可以思考：怎么构造使得正着读没贡献，反着读有贡献。

我们沿用上面的思路得到了如下的一种构造方式。

$$0-k+k+0$$

用这种构造方法，正着读的贡献为 $0$，反着读贡献为 $2k$。

将上面两种情况结合起来。由于 $2k$ 是偶数，我们就可以构造出任何一种答案为偶数的序列。

那如果有奇数呢？这种情景下还得分三类讨论。

1. 如果 $p$ 和 $q$ 均为奇数，我们只需在序列前加上 $0+1+0$，然后构造 $p-1$ 和 $q-1$ 即可。

2. 如果只有 $p$ 为奇数，我们只需在序列前加上 $0+21+0$，然后构造 $p-21$ 和 $q-12$ 即可。

3. 如果只有 $q$ 为奇数，我们只需在序列前加上 $0+12+0$，然后构造 $p-12$ 和 $q-21$ 即可。

最后再考虑代码实现上的问题：我们在构造倒着读的序列时，先将 $q$ 除以 $2$ 得到 $nq$，再将 $nq$ [翻转](https://www.luogu.com.cn/problem/P1307)后的数加入序列。但是这样可能会被前导 $0$ 影响答案。例如 $15000$，翻转后会变成 $51$。如何避免这个问题？我们只需要在出现这种情况时在序列前加上 $0+2+0$ 然后继续构造 $p-2$ 和 $q-2$ 即可。

[提交记录。](https://codeforces.com/contest/1912/submission/264389022)

---

## 作者：ysl_wf (赞：6)

# 【CF1912E】Evaluate It and Back Again【保姆级】

## 前言
- [博客食用更佳~](https://www.cnblogs.com/ysl-fengem/articles/18303953)

与楼中的大佬思路相同，有借鉴之处，但本蒻蒟这篇~~还算详细~~，这是来自蒻蒟的发言，不要在意...

## 前置思维

- 构造。

## 分析

使得正着读它的结果是 $p$，倒着读它的结果是 $q$。  
我们可以想到，让这个式子由两部分构成：  
1. 正着读可以算出 $p$ 的值（部分一）。
2. 反着读可以算出 $q$ 的值（部分二）。 
    
这便是**思路**：  
1. 部分一：反着读的值为零。
2. 部分二：正着读的值为零。

这样的话，本题似乎只需要用到加法和减法！  
如果你有了思路，此灵感会祝你 **AC** 本题！  
具体下面分晓！
   
## 构码思路

### 正读为 $p$ 反读为 0（核心）

我们可以想象一种构造：  

以**偶数**考虑！

$$
0 + k + k - 0
$$
这样的话，正着读的贡献为 $2k$，反着读贡献为 $0$（对 $p$ 而言）。  

相反 $q$ 的构造便是：
$$
0 - k + k + 0
$$
这样的话，正着读的贡献为 $0$，反着读贡献为 $2k$（对 $p$ 而言）。

我们便可以得到以下 code：

#### Code
```cpp
p /= 2; q /= 2;
//p
if(p > 0) printf("0+%lld+%lld-0+", p, p);
else printf("0%lld%lld+0+", p, p);
//q
q = fzs(q);//翻转数字
if(q > 0) printf("0-%lld+%lld+0", q, q);
else printf("0+%lld%lld-0", -q, q);
```

### 翻转数字

emmm... 这部分显而易见，开辟一个 $f = 1$，在原数字除 $10$ 的同时，$f$ 乘上 $10$ 加上扣下来的数。  
我想 code 更可以说明方法！

#### code
```cpp
lt fzs(lt n){//翻转数字
    lt f = 0;
    while(n){
        f = f*10 + n%10;
        n /= 10;
    }
    return f;
}
```

### 其它细节

如果是奇数，$2k$ 的方法会出现问题，但是我们可以用**拆数**的方式进行构造！！！  
那怎么拆？我们可以灵活应用 $12$ 和 $21$ 相反且一奇一偶的特点：

1. 如果均为奇数：我们只需要在序列前加上 $0+1+0$，然后构造 $p-1,q-1$。
2. $p$ 为奇数：我们只需要在序列前加上 $0+21+0$，然后构造 $p-21, q-12$。
3. $q$ 为奇数：我们只需要在序列前加上 $0+12+0$，然后构造 $p-12, q-21$。


## 小小的BUG

我们考虑害怕 $q$ 或 $p$ 翻转后会出现前导零的错误！！！  
所以我们可以通过 $0+2+0$ 的方式构造剩余！！！注意用 `while` 更为保险！

### Code

```cpp
//害怕出现q翻转后结尾为零
while(p%10 == 0 || q%10 == 0){
    p -= 2, q -= 2;
    printf("0+2+0+");
}
```

最后完整 code 放下面了，里面有注释，助力你 **AC** 本题！
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long lt;
lt p, q;
bool pf, qf;//f判断奇偶

lt fzs(lt n){//翻转数字
    lt f = 0;
    while(n){
        f = f*10 + n%10;
        n /= 10;
    }
    return f;
}

int main(){
    scanf("%lld%lld", &p, &q);
    if(p % 2) pf = 1; if(q % 2) qf = 1;

    //p, q均为奇
    if(pf && qf){
        printf("0+1+0+");
        p -= 1; q -= 1;
    }
    //p为奇
    else if(pf){
        printf("0+21+0+");
        p -= 21; q -= 12;
    }
    //q为奇
    else if(qf){
        printf("0+12+0+");
        p -= 12; q -= 21;
    }

    //害怕出现q翻转后结尾为零
    while(p%10 == 0 || q%10 == 0){
        p -= 2, q -= 2;
        printf("0+2+0+");
    }

    //开整！
    p /= 2; q /= 2;
    //p
    if(p > 0) printf("0+%lld+%lld-0+", p, p);
    else printf("0%lld%lld+0+", p, p);
    //q
    q = fzs(q);
    if(q > 0) printf("0-%lld+%lld+0", q, q);
    else printf("0+%lld%lld-0", -q, q);
    return 0;
}
//正读有贡献，反着无： 0+k+k-0
//反读有贡献，正着无： 0-k+k+0
```

---

## 作者：SegT (赞：4)

[Exp10re](https://www.luogu.com.cn/user/403069) 显然想复杂了。

## 解题思路

在此处我会对 [Exp10re的题解](https://www.luogu.com.cn/blog/Exp10re/solution-cf1912e) 进行一些借鉴。（反正都是一个人写的问题不大）

里面提到的一个操作：

- 对于任意整数 $k$，正向计算能使结果 $+2k$，反向计算结果不变。（或者相反）

实现方法如下：

定义对于任意数 $k$ 左右翻转后表示为 $k'$。

任意整数不一定满足正向与反向阅读同等的性质，因此考虑以下做法：

$$0+k+k-0$$

其反向阅读的结果如下：

$$0-k'+k'+0$$

结果为 $0$，显然结果与 $k'$ 无关。

$-2k$ 同理，不多赘述。

反向 $+k$ 做法有所差别：

$$0-k'+k'+0$$

因为 $k'$ 反向阅读结果就是 $k$，正确性显然。

------------

注意到当 $p$ 或 $q$ 为偶数时，使用此操作可以直接构造出 $+p$ 或者 $+q$。

分类讨论：

如果 $p$ 和 $q$ 均为偶数，直接构造即可。

如果 $p$ 和 $q$ 均为奇数，考虑在左端构造如下表达式：

$$0+1+0$$

如此，只需要构造 $p-1$ 和 $q-1$ 即可。容易证明其均为偶数。

如果只有 $p$ 为奇数，考虑在左端构造如下表达式：

$$0+21+0$$

正向阅读的结果会 $+21$，反向阅读的结果会 $+12$，只需要构造 $p-21$ 和 $q-12$ 即可。容易证明其均为偶数。

如果只有 $q$ 为奇数，考虑在左端构造如下表达式：

$$0+12+0$$

正向阅读的结果会 $+12$，反向阅读的结果会 $+21$，只需要构造 $p-12$ 和 $q-21$ 即可。容易证明其均为偶数。

如此我们就用简单的分类讨论省略了 [Exp10re的题解](https://www.luogu.com.cn/blog/Exp10re/solution-cf1912e) 里面一些繁杂的步骤。

------------

另外，前导零需要特判。

具体的，如果 $+2k$ 操作

$$0+k+k-0$$

中 $k$ 有末尾 $0$，可以考虑转变成如下操作：

$$0+(k-1)+(k-1)-0+1-1+0$$

如此，就避免了前导 $0$。

---

## 作者：SXqwq (赞：3)

### Description

请给出一个仅由 $0 \sim 9, +, -, \times$ 构成的式子，使得正着读它的结果是 $p$，倒着读它的结果是 $q$。

注意 `-` 只能用作减法，不能用作负号。

### Analysis

令 $\overline{P}$ 表示表达式 $P$ 的反串结果。

对于这种构造题，没有思路的时候，不妨从特例出发，令 $q=-p$，我们先解决这个小问题。

考虑下列问题。

什么样的表达式满足 $P=\overline{P}$ 呢？答案是当 $P$ 只包括一位数、$+$、$\times$ 时。因为加法和乘法是满足交换律的。该条件是 $P=\overline{P}$
 的充分条件。
 
进一步的，什么样的表达式满足 $Q=-\overline{Q}$ 呢？答案是当 $Q=0-P$ 时。需要保证 $P=\overline{P}$。

因此，当 $q=-p$ 时，我们可以很容易地构造。

我们尝试推广该结论。

不妨设 $p,q$ 都可以写成 $a+b,a-b$ 的形式。例如当 $p=10,q=20$ 时，$a=15,b=5$。则我们可以构造 $S=A+(0-B)$，则 $\overline{S}=B-0+A$。

进而得 $S=a-b=p,\overline{S}=b+a=q$

因此，我们只需要构造出 $A=\overline{A}=a,B=\overline{B}=b$ 即可。

$a,b$ 比较好求，问题在与如何构造 $A,B$。

我们用 $9$ 进制表示即可。因为 $10$ 进制会出现 $10$，前文提到必须是个位数。太小了会导致构造序列太长。

---

## 作者：mlvx (赞：3)

### 题意

给两数 $p,q$，构造一个只含数字与加号以及乘号的表达式，使得其正着算答案是 $p$，反着算答案是 $q$。

### 分析

$x+x-0$ 正着的答案是 $2x$，倒着的答案是 $0$。

$0-x-x$ 正着的答案是 $-2x$，倒着的答案是 $0$。

可以发现构造出来的都是偶数。

如果都是奇数呢？

把序列改成 $1+x+x-0$ 即可，正着答案是 $2x+1$，反着答案是 $1$，也就相当于构造的数变成了 $p-1,q-1$。

如果 $p$ 是奇数，$q$ 是偶数，把序列改成 $21+x+x-0$ 即可，正着答案是 $2x+21$，反着答案是 $12$，也就相当于构造的数变成了 $p-21,q-12$。

如果 $p$ 是偶数，$q$ 是奇数，把序列改成 $12+x+x-0$ 即可，正着答案是 $2x+12$，反着答案是 $21$，也就相当于构造的数变成了 $p-12,q-21$。

其实上面的数只需要满足正反奇偶性不同就行了。

综上，我们能把所有情况转化成两个偶数的情况。

那现在是 $x+x-0$ 或 $0-x-x$，现在应该怎么办呢？

显然，反过来答案是 $0$，但是我们需要的答案是 $q$。

我们可以在后面加上 $q$。但是由于反过来要保证没有前导零，所以我们直接加上一个正反都等于 $q$ 的表达式。

可以把 $q$ 拆成若干个回文数之和，也可以直接拆分 $q$ 的九进制，然后按权输出。

这样 $x=\dfrac{p-q}{2}$。如果 $x$ 是负数的话就把 $x$ 变成它的相反数，然后按 $0-x-x$ 输出。

注意处理下 $x$ 末尾有 $0$ 的情况。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll p,q;
int main(){
	cin>>p>>q;
	if((p&1)&&(q&1))cout<<"1+",--p,--q;
	if((p&1)&&!(q&1))cout<<"21+",p-=21,q-=12;
	if(!(p&1)&&(q&1))cout<<"12+",p-=12,q-=21;
	ll pp=p,qq=q,flag=0;
	if(qq<0)qq=-qq,flag=1,cout<<"0-";
	for(int cnt=0;qq;qq/=9,cnt++)if(qq%9){
		cout<<qq%9;
		for(int i=1;i<=cnt;i++)cout<<"*9";
		putchar(flag?'-':'+');
	}putchar('0');
	ll x=p-q>>1;
	if(!(x%10)){
		if(x>0)cout<<"+"<<x-1<<'+'<<x-1<<"-0+1+1-0";
		else if(x<0)cout<<x+1<<x+1<<"+0-1-1";
	}else{
		if(x>0)cout<<"+"<<x<<'+'<<x<<"-0";
		else if(x<0)cout<<x<<x;
	}return 0;
}
```

---

## 作者：Annihilation_y (赞：2)

## 分析
首先由于乘除法以及括号在反转过后的情况变得较为复杂，所以暂时不考虑。思考如何通过加减法构造。

考虑在加减法中，最为特殊的数组为 $0$，即对于任意一个数字不管加减 $0$ 这个数字都不变，所以可以考虑对 $0$ 的妙用。

经过一定量的思考可以发现，$k+k-0$ 的结果是 $2k$，而反转过后 $0-k+k$ 为 $0$。同理可得，$k-k+0$ 的结果是 $-2k$，而反转过后 $0+k-k$ 为 $0$。

所以，我们只需要让两个数都为 $2$ 的倍数，这道题就迎刃而解了。即只需要考虑对于输入的两个数 $p$ 和 $q$，如何将两个数都变为偶数。

- $p$ 和 $q$ 均为奇数。这个好处理，直接在式子最前面加上 $1+0$，同时对两数都减 $1$。

- $p$ 为奇数。观察样例可以发现，$12$ 反转过后的结果为 $21$，两数相差为奇数。所以直接在式子最前面加上 $21+0$，对 $p$ 减 $21$，对 $q$ 减 $12$。

- $q$ 为奇数。同理可得，在式子最前面加上 $12+0$，对 $p$ 减 $12$，对 $q$ 减 $21$。。

而为了防止前导 $0$ 的出现，直接在式子最前面 $2+0$ 并同时对两数减 $2$，如果还有就再操作一次。

注意在实际的代码实现中，为了方便操作，先在式子的最前面加了一个 $0$。

## Code
~~~c++
#include <bits/stdc++.h>
using namespace std;
namespace yhy{
	#define int long long
	string s;
	int main() {
		std::ios::sync_with_stdio(false);
		cin.tie(0);cout.tie(0);
		int x,y;
		cin>>x>>y;
		s="0";
		if((x&1)&&(y&1)) {
			s+="+1+0";
			x--,y--;
		}
		else if((x+y)&1) {
			if(x&1) {
				s+="+21+0";
				x-=21;
				y-=12;
			}
			else {
				s+="+12+0";
				x-=12;
				y-=21;
			}
		}
		if(abs(x)%10==0 || abs(y)%10==0) { //处理前导0 
			s+="+2+0";
			x-=2;
			y-=2;
			if(abs(x)%10==0 || abs(y)%10==0) {
				s+="+2+0";
				x-=2;
				y-=2;
			}
		}
		if(x) {
			x>>=1;
			if(x>0) {
				s+="+";
				s+=to_string(x);
				s+="+";
				s+=to_string(x);
				s+="-0";
			}
			if(x<0) {
				x=-x;
				s+="-";
				s+=to_string(x);
				s+="-";
				s+=to_string(x);
				s+="+0";
			}
		}
		if(y) {
			y>>=1;
			if(y>0) {
				string x=to_string(y);
				reverse(x.begin(),x.end());
				s+="-";
				s+=x;
				s+="+";
				s+=x;
				s+="+0";
			}
			if(y<0) {
				y=-y;
				string x=to_string(y);
				reverse(x.begin(),x.end());
				s+="+";
				s+=x;
				s+="-";
				s+=x;
				s+="-0";
			}
		}
//		reverse(s.begin(),s.end());
		cout<<s<<'\n';
		return 0;
	}
}
signed main() {
	yhy::main();
	return 0;
}
~~~

---

## 作者：chenhouyuan (赞：2)

先令 $p=a-b$、$q=a+b$，$a$、$b$ 显然很好求解，那么本题就转化成了求解两个表达式使得一个正读反读值不变，另一个正读值为 $-x$，反读值为 $x$。

对于第一个表达式我们发现只拥有一位数字、加号、乘号的表达式符合要求，那么我们可以将 $a$ 进行九进制拆分。负数怎么办？将加号改成负号并在表达式两端加上 `0-` 和 `-0`。

对于第二个表达式我们同样进行九进制拆分，不过对于中间的连接符我们在加减号前加上 `-0`，这样我们就会惊奇的发现其正读值为 $-x$，反读值为 $x$。
#### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string ans;
void ma(ll x,char ch){
	ll cnt=1;
	if(ch=='-')ans+=ch;
	ans+=x%9+'0';
	x/=9;
	while(x){
		ans+=ch;
		ans+=x%9+'0';
		for(ll i=1;i<=cnt;i++){
			ans+="*9";
		}
		x/=9;
		cnt++;
	}
}
void mb(ll x,char ch){
	ll cnt=0;
	while(x){
		if(ch=='-'){
			ans+="0-";
		}
		ans+=x%9+'0';
		for(ll i=1;i<=cnt;i++){
			ans+="*9";
		}
		if(ch=='+'){
			ans+="-0";
		}
		ans+='+';
		x/=9;
		cnt++;
	}
	ans+='0';
}
void solve(ll p,ll q){
	ll a=(p+q)/2;
	ll b=p-a;
	if(a>=0){
		ma(a,'+');
	}
	else{
		ans+='0';
		ma(-a,'-');
		ans+="-0";
	}
	ans+='+';
	if(b>=0){
		mb(b,'+');
	}
	else{
		mb(-b,'-');
	}
}
int main(){
	ll p,q;
	cin>>p>>q;
	if(abs(p)%2==abs(q)%2){
		solve(p,q);
	}
	else{
		solve(p-12,q-21);
		ans+="+12";
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Exp10re (赞：2)

非常神仙构造题……为什么没人写……

[传送门](https://www.luogu.com.cn/problem/CF1912E)，这道题真的很神。

这里给出一种不同于[官方题解](https://codeforces.com/contest/1912/attachments/download/23436/nef-2023-tutorial.pdf)的思路，优势在于不需要乘法。

## 解题思路

考虑一段表达式可以实现以下四种操作：

- 对于任意整数 $k$，正向计算能使结果 $+k$，反向计算能使结果 $-k$。

- 对于任意整数 $k$，正向计算能使结果 $+2k$，反向计算结果不变。（或者相反）

- 对于整数 $k\in[0,9]$，正向反向计算均能使结果 $+k$。

以上三种操作分别编号操作 $1,2,3$，接下来对其逐个进行实现：

### 操作 1

考虑一种简化版问题：给定 $k$，对于十进制下的某一位，正向计算能使该位 $+k$，反向计算能使该位 $-k$。

如果不是个位，那么考虑以下构造方案：

$$0+k00\cdots00k-k+0$$

因为 $k00\cdots00k$ 正向与反向阅读是一样的，因此正向阅读的结果就是 $k00\cdots000$，反向阅读的结果就是 $-k00\cdots000$。

对于个位数的情况，在首位与末位都加上一个数会导致重合，因此考虑以下构造方法：

$$0+k+k-k-0$$

$k$ 正向与反向阅读是一样的，正确性显然。

### 操作 2

定义对于任意数 $k$ 左右翻转后表示为 $k'$。

任意整数不一定满足正向与反向阅读同等的性质，因此考虑以下做法：

$$0+k+k-0$$

其反向阅读的结果如下：

$$0-k'+k'+0$$

结果为 $0$，显然结果与 $k'$ 无关。

$-2k$ 同理，不多赘述。

反向 $+k$ 做法有所差别：

$$0-k'+k'+0$$

因为 $k'$ 反向阅读结果就是 $k$，正确性显然。

### 操作 3

$k$ 正向与反向阅读是一样的，因此操作 $3$ 做法显然。

$$0+k+0$$

------------

了解以上三种操作的做法之后可以考虑如下做法：

如果 $p$ 和 $q$ 奇偶性不同，在表达式开头写 $0+12+0$，反向阅读就是 $0+21+0$，此时 $p,q$ 奇偶性相同。

如果 $p$ 和 $q$ 奇偶性相同，记 $mid=\frac {p+q} 2$，将正反的表达式使用操作 $2$ 和操作 $3$ 同时 $+mid$，然后使用操作 $1$ 使得正向 $+(p-mid)$，反向 $-(p-mid)$，得到的结果就是 $p$ 和 $q$。

具体而言，使用操作 $2$ 和操作 $3$ 同时 $+mid$ 可以考虑以下做法：

若 $mid$ 为偶数，使用操作 $2$ 正向 $+(\frac {mid} 2)$，反向 $+(\frac {mid} 2)$ 即可。

若 $mid$ 为奇数，使用操作 $3$ 正向 $+1$，反向 $+1$ ，后面的操作与偶数的情况同理。

------------

还有一个非常值得注意的一点：前导零需要特判。具体的，如果操作 $2$ 进行 $+2k$ 末尾有 $0$，可以考虑将 $+2k$ 改成 $+2(k-1)$ 和一次 $+2$。

大概就是这些，代码太屎山就不放了。

---

## 作者：lilong (赞：2)

最近正在练构造题，写篇题解分享一下实现的细节。

#### 核心过程

大胆猜测，不难发现一个重要的结论：假设有一个式子 $a+a-0$，则其从左往右的结果为 $2a$，从右往左的结果为 $0$。有了这个结论，我们就可以考虑用两段这样的式子来分别求得 $p$ 和 $q$。接下来分析细节。

上述结论的使用前提为 $p,q$ 均为偶数。如果 $p,q$ 不为偶数则需进行处理。下面进行分类讨论：

- $p,q$ 均为奇数

不难想到，可以给 $p,q$ 都加上（或减去）一个奇数。直接输出一个奇数即可，两端符号最好相同。

- $p,q$ 中有一个为奇数

由于两个数的运算方向相反，因此可以选择一个**最高位和最低位奇偶性不同**的数。输出即可，两端符号最好相同。

注意到题目还有一个限制，即不能出现前导零。因此在进行上述操作后还要进行判断，若有前导零可以通过加上（或减去）一个偶数来满足。

最后还要留意构造 $q$ 的部分输出时要**倒序输出**。

#### Code

具体细节实详见代码。

```cpp
#include <iostream>
#include <cstdio>
#define int long long

using namespace std;

signed main()
{
	int a,b,c = 0,e;
	cin >> a >> b;
	if( a % 2 && b % 2 )
	{	
		cout << "0-11-0";
		a += 11;
		b += 11;
		e = 2;
		while( ( a - e ) / 2 % 10 == 0 || ( b - e ) / 2 % 10 == 0 ) e += 2;
		cout << "+" << e << "+0";
		a -= e;
		b -= e;
		if( a < 0 ) cout << a / 2 << a / 2 << '+';
		else cout << '+' << a / 2 << '+' << a / 2 << '-';
		cout << "0";
		b /= 2;
		do
		{
			c = c * 10 + b % 10;
			b /= 10;
		}
		while( b );
		b = c;
		if( b < 0 ) cout << '+' << - b << b << '-';
		else cout << '-' << b << '+' << b << '+';
		cout << "0";
	}
	else if( a % 2 )
	{
		cout << "0-21-0";
		a += 21;
		b += 12;
		e = 2;
		while( ( a - e ) / 2 % 10 == 0 || ( b - e ) / 2 % 10 == 0 ) e += 2;
		cout << "+" << e << "+0";
		a -= e;
		b -= e;
		if( a < 0 ) cout << a / 2 << a / 2 << '+';
		else cout << '+' << a / 2 << '+' << a / 2 << '-';
		cout << "0";
		b /= 2;
		do
		{
			c = c * 10 + b % 10;
			b /= 10;
		}
		while( b );
		b = c;
		if( b < 0 ) cout << '+' << - b << b << '-';
		else cout << '-' << b << '+' << b << '+';
		cout << "0";
	}
	else if( b % 2 )
	{
		cout << "0-12-0";
		a += 12;
		b += 21;
		e = 2;
		while( ( a - e ) / 2 % 10 == 0 || ( b - e ) / 2 % 10 == 0 ) e += 2;
		cout << "+" << e << "+0";
		a -= e;
		b -= e;
		if( a < 0 ) cout << a / 2 << a / 2 << '+';
		else cout << '+' << a / 2 << '+' << a / 2 << '-';
		cout << "0";
		b /= 2;
		do
		{
			c = c * 10 + b % 10;
			b /= 10;
		}
		while( b );
		b = c;
		if( b < 0 ) cout << '+' << - b << b << '-';
		else cout << '-' << b << '+' << b << '+';
		cout << "0";
	}
	else
	{
		cout << "0";
		e = 2;
		while( ( a - e ) / 2 % 10 == 0 || ( b - e ) / 2 % 10 == 0 ) e += 2;
		cout << "+" << e << "+0";
		a -= e;
		b -= e;
		if( a < 0 ) cout << a / 2 << a / 2 << '+';
		else cout << '+' << a / 2 << '+' << a / 2 << '-';
		cout << "0";
		b /= 2;
		do
		{
			c = c * 10 + b % 10;
			b /= 10;
		}
		while( b );
		b = c;
		if( b < 0 ) cout << '+' << - b << b << '-';
		else cout << '-' << b << '+' << b << '+';
		cout << "0";
	}
	return 0;
}
```


---

## 作者：Infinity_Fantasy (赞：1)

### 突破思考瓶颈
找到特殊的地方，比如我们发现一个回文串翻转后是不变的，一个一位数反转后也是不变的，根据加法和乘法的交换律，加和乘反转后也是不变的。

这时，我们把一个数字进行二进制拆分，于是一个数就变成了 $\sum{n\times2^k}$ 这样就全是一位数，反转后也是原数。

由于题目要求长度不超过 1000 个字符因此进行九进制拆分，减少字符位数。

### 构造
假设输入的 $p$ 和 $q$ 能被拆分成 $a+b$ 和 $a-b$，则我们可以构造 $S=a+0-b$ 因此我们可以解二元一次方程。

解出 $a$ 和 $b$ 后，由于要保证反转后还是要保证为原数，因此将其进行九进制拆分。

这样我们可以用 $\sum_{i=0}^{\log_9p}(2i+1)$ 个字符构造出答案，这个数约为 $\log^2_9p$，在 $1000$ 以内。

考虑到上述情况只适用于 $p$ 和 $q$ 的奇偶性是相同的，当二者奇偶性不同时，我们则可以考虑构造 $S=a+0-b+12$，容易证明，这样解可以得到正确答案。

---

## 作者：自由软件Free (赞：0)

# CF1912E Evaluate It and Back Again题解

## 题意

给定两个数，要求你写出一个只包含数字, $+, \times, -$ 的式子，正着看是第一个数，反着看是第二个数。

## 题解

观察发现只有**一位数**和 $+, \times$ 的**单项式**倒过来读还是一样的，由 $-0$ 结尾的单项式倒过来读和原式结果相反。

发现可以将一个要求倒着读后数值不变的数表示为 $9$ 进制的形式，这样多项式中每一项都是倒着读后不变的。

- 对于两个奇偶性相同的数，可以求两个数的平均数，将 $p, q$ 分别表示为 $p = \overline{pq} + \frac{p - q}{2}, q = \overline{pq} - \frac{p - q}{2}$
- 对于两个奇偶性不同的数，也可以求平均数，但是为了让 $p, q$ 奇偶性统一，需要给 $p, q$ 分别减去一个正着读是奇数，反着读是偶数的数，如 $12$，然后即可按照第一种形式做

然后就是注意特判两个相同的数和 `0 0` 的情况，别忘记开 long long 就结束了

不懂看注释

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string ans;
string to_9(long long n) //转换为正反均相同的多项式
{
    bool flag = n >= 0;
    if (!flag)
        n = -n;
    ans = "";
    long long cnt = 0;
    long long yu[20] = {};
    while (n >= 10ll)
        yu[cnt++] = n % 9ll, n /= 9ll;
    yu[cnt] = n;
    if (!flag)
        ans += "0-";
    for (long long i = 0; i <= cnt; ++i)
    {
        if (yu[cnt - i] != 0)
        {
            for (long long j = 0; j < cnt - i; ++j)
                ans += "9*";
            ans += yu[cnt - i] + '0';
            if (flag)
                ans += "+0+";
            else
                ans += "-0-";
        }
    }
    while (ans[ans.size() - 1] == '+' || ans[ans.size() - 1] == '-')
        ans.pop_back(); // 去掉多于符号
    return ans;
}
string to_9_0(long long n) // 转换为正反读相反的多项式
{
    bool flag = n >= 0;
    if (!flag)
        n = -n;
    ans = "";
    long long cnt = 0;
    long long yu[20] = {};
    while (n >= 10)
    {
        yu[cnt++] = n % 9ll;
        n /= 9ll;
    }
    yu[cnt] = n;
    if (!flag)
        ans += "0-";
    for (long long i = 0; i <= cnt; ++i)
    {
        if (yu[cnt - i] != 0)
        {
            for (long long j = 0; j < cnt - i; ++j)
                ans += "9*";
            ans += yu[cnt - i] + '0';
            if (flag)
                ans += "-0+";
            else
                ans += "+0-";
        }
    }
    while (ans[ans.size() - 1] == '+' || ans[ans.size() - 1] == '-')
        ans.pop_back(); // 去掉多于符号
    return ans;
}
int main()
{
    long long p = 0, q = 0;
    scanf("%lld%lld", &p, &q);
    if (abs(p) % 2 == abs(q) % 2) // 同奇偶
    {
        long long _pq = p + q >> 1, p_q = p - _pq;
        if (p == 0 && q == 0) // 特判
        {
            puts("0");
            return 0;
        }
        cout << to_9(_pq) << ((_pq != 0 && p_q != 0) ? "+" : "") << to_9_0(p_q) << endl;
    }
    else // 异奇偶
    {
        long long _pq = (p - 21 + q - 12) >> 1, p_q = p - 21 - _pq; // 转换为同奇偶
        cout << to_9(_pq) << ((_pq != 0 && p_q != 0) ? "+" : "") << to_9_0(p_q) << ((p_q != 0 || _pq != 0) ? "+" : "") << "21" << endl;
    }
    return 0;
}

```

---

## 作者：zhoumurui (赞：0)

# 题面展示

请给出一个仅由 $0 \sim 9, +, -, \times$ 构成的式子，使得正着读它的结果是 $p$，倒着读它的结果是 $q$。

注意 `-` 只能用作减法，不能用作负号。

$ -10^{18} \le p, q \le 10^{18} $.

# 题目思路

题面非常的简洁，但我们为了审清题意，先来个样例解释：

$2023-12-13=1998$

$31-21-3202=-3192$

看着这题似乎难以构造，但我们完全不必按照样例这样~~出题人似乎是先造样例输出再再造样例输入~~的方法来构造，考虑构造一个正着念不是 $0$，反着念是 $0$ 的式子，这样就可以扩展到原题了。

当我们要构造一个偶数时，这种式子很好构造，假设这个偶数等于 $2 \times p$，$p$ 倒过来念是 $p'$：

$ 0 + p + p - 0 = 2 \times p $

$ 0 - p' + p' + 0 = 0 $

正着念是 $0$，反着念不是 $0$ 的式子的构造同理，假设需要构造的偶数等于 $2*p$，$p$ 倒过来念是 $p'$：

$ 0 - p' + p' + 0 = 0 $

$ 0 + p + p - 0 = 2 \times  p $

那么如果希望正着念是 $2 \times p$，反着念是  $2 \times q$ 的话：

$ 0 + p + p - 0 + 0 - q' + q' + 0 = 2  \times p $

$ 0 + q + q - 0 + 0 - p' + p' + 0 = 2 \times q $

但是还有两个问题：

第一个问题：要凑奇数怎么办？

如果 $p$ 是奇数，首先在开头凑上一个

$21 + $

然后要构造的就是 $p-21$ 和 $q-12$ 了，如果 $q$ 是奇数同理。

都是奇数的话，可以在开头凑一个

$11 + $

这样要构造的就是 $p-11$ 和 $q-11$ 了。所有情况都被转换成了 $p,q$ 都是偶数的情况。

第二个问题：

如果有一个数末尾带 $0$，那倒着念不是带前导 $0$ 了吗？

**所以 $p$ 和 $q$ 的末尾都不能带 $0$。**

要避免这样，在开头凑一个 $2 +$ 或者 $4 +$，使得要构造的数的末尾不带 $0$ 即可。

这样这题就 AC 掉了。

~~代码就不贴了，大家应该都能看懂吧~~

---

## 作者：Fa_Nanf1204 (赞：0)

### 分析：
题目要求正反两个串所计算的值要分别为 $p$ 和 $q$，所以考虑构造两个子结构后再合并处理。

考虑构造 $0+p+p-0$ 这样一个结构，那么此字符串正读为 $2p$，反着读为 $0$。

再考虑构造另一个子结构，根据上一个结构来看我们应该构造一个正读为 $0$，反着读为 $2q$ 的子结构，可以容易的得出结论，构造 $0-q+q+0$。

之后就可以合并得到 $0+p+p-0-q+q+0$，那么此字符串正读为 $2p$，反着读为 $2q$，此时 $p$ 和 $q$ 为一个数字。

那么就可以分讨了，因为不可能 $p$ 和 $q$ 永远都为偶数，所以当 $p$ 和 $q$ 都为奇数时，在字符串前添上 $0+1+0$，$p$ 和 $q$ 自减 $1$。

若 $p$ 为奇数，$q$ 为偶数，在字符串前添上 $0+21+0$，$p$ 自减 $21$，$q$ 自减 $12$。

若 $p$ 为偶数，$q$ 为奇数，在字符串前添上 $0+12+0$，$p$ 自减 $12$，$q$ 自减 $21$。

还有前导零的问题，$p$ 和 $q$ 的末尾不能有零，所以在字符串前添上 $0+2+0$，$p$ 自减 $2$，$q$ 自减 $2$。

还有些符号问题，若 $p$ 或 $q$ 为负数，则其所在子结构的所有符号需取反。
### Code:
```cpp
//0+p+p-0-q+q+0 正：2p  反：2q 
#include<bits/stdc++.h>
#define ll long long
using namespace std; 
ll p,q,st_p,st_q;
int len,l[10005];
ll r(ll x,ll sum=0){
	len=0;
	while(x!=0){
		l[++len]=x%10;
		x/=10;
	}
	for(int i=1;i<=len;i++){
		sum=sum*10+l[i];
	}
	return sum;
} 
int main(){
	cin>>p>>q;
	if(abs(p)%2==1 and abs(q)%2==1){
		p--,q--;
		cout<<"0+1+0+";
	}
	else if(abs(p)%2==1 and abs(q)%2==0){
		p-=21,q-=12;
		cout<<"0+21+0+";
	}
	else if(abs(p)%2==0 and abs(q)%2==1){
		p-=12,q-=21;
		cout<<"0+12+0+";
	}
	while(q%10==0 or p%10==0){
		q-=2,p-=2;
		cout<<"0+2+0+";
	}
	st_p=p/2;
	st_q=r(q/2);
	cout<<"0";
	if(st_p<0) cout<<st_p;
	else cout<<"+"<<st_p; 
	if(st_p<0) cout<<st_p;
	else cout<<"+"<<st_p; 
	if(st_p<0) cout<<"+0";
	else cout<<"-0"; 
	if(st_q<0) cout<<"+"<<-st_q;
	else cout<<"-"<<st_q;
	if(st_q<0) cout<<st_q;
	else cout<<"+"<<st_q;
	if(st_q<0) cout<<"-0";
	else cout<<"+0";
	return 0;
}
```

---


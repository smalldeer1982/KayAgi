# Farm Game

## 题目描述

### Farm Game


[Lunatic Princess - Touhou](https://soundcloud.com/p92402/kaguyas-theme-lunatic-princess)

FN 带着他的奶牛来到 FJ 的农场里玩游戏！FJ 的农场可视作一条 $0$ 点和 $l+1$ 点有墙的数轴。FJ 和 FN 各有 $n$ 头牛（共 $2n$ 头牛）。他们把他们的奶牛分别放到不同的整点上，并且 FJ 的奶牛互不相邻，FN 的奶牛互不相邻。当两头牛中间没有其他牛，这两头牛是相邻的。

形式上地讲，定义 $ a_1, a_2, \ldots, a_n $ 表示 FJ 的牛的位置，$ b_1, b_2, \ldots, b_n $ 表示 FN 的牛的位置，则要么 $ 0 < a_1 < b_1 < a_2 < b_2 < \ldots < a_n < b_n < l + 1 $，要么 $ 0 < b_1 < a_1 < b_2 < a_2 < \ldots < b_n < a_n < l + 1 $。

对于一次移动，农夫（FJ 或 FN）选择一个整数 $ k $ $ (1 \leq k \leq n) $ 和一个方向（左或右）。然后他会选择 $ k $ 头他的牛向此方向移动一个单位。农夫不能将他的牛移到墙上或者另外一位农夫的牛上。如果有一人无法再移动他的牛，他就输了。FJ 先手。

给定 $ l $ 和 $ n $，找到在双方都采取最优策略下，FJ 赢的不同的初始奶牛排列数量。有可能游戏会无穷尽地继续下去，这时算作无人获胜。答案取模 $ 998\,244\,353 $。

题目多测。

## 样例 #1

### 输入

```
3
2 1
3 1
420 69```

### 输出

```
0
2
870279412```

# 题解

## 作者：onlycre (赞：7)

我们先默认第一头牛是 John 的，另一种情况本质相同，最后答案乘上 $2$ 就可以了。

先说结论：我们将相邻两头牛配对，那么最终答案即满足**至少一对牛间隔了奇数个空位**的方案数。证明很简单，分 $3$ 种情况讨论：

1. 每对牛间都间隔了奇数个空位。那么 John 开始时让所有牛往右行动，在 Nhoj 行动后，John 只需要保证 Nhoj 行动的牛对应的 John 那头牛也行动，方向向右，这样就能保证轮到 John 时每队牛都间隔奇数个空位，并且不会出现游戏无法终止的情况。然后最后当每对牛都间隔为 $0$ 时，轮到 Nhoj 行动，John 胜。
2. 有些对牛间隔了奇数个空位，还有些隔了偶数个空位。那么 John 开始时选取所有奇数个空位的牛对里的牛行动，这样，如果 Nhoj 移动了奇数个空位的牛对里的牛，同第一种情况，如果移动了隔了偶数个空位牛对里的牛，John 不对对应的牛做任何操作，这样下一轮到他的时候就会变成第一种情况。
3. 每对牛间都间隔了偶数个空位。John 先手必须行动，那么就会转化为上面的两种情况，Nhoj 必胜。

算答案我们考虑容斥，用总方案减去每对牛间都间隔了偶数个空位的方案，前者即为 $\binom{l}{2n}$，后者枚举所有牛对间一共隔了 $i$ 个空位，简单组合计数得到 $\binom{l-i-n}{n}\binom{i/2+n-1}{n-1}$。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define per(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
typedef long long LL;
typedef pair<LL,int>pli;
const int N=2e6+10,MOD=998244353;
LL fac[N],ifac[N];
int qpow(int a,int b)
{
	int res=1;
	for(;b;b>>=1)
	{
		if(b&1)res=1ll*res*a%MOD;
		a=1ll*a*a%MOD;
	}
	return res;
}
void pw(int n)
{
	fac[0]=ifac[0]=1;rep(i,1,n)fac[i]=fac[i-1]*i%MOD;
	ifac[n]=qpow(fac[n],MOD-2);per(i,n-1,1)ifac[i]=ifac[i+1]*(i+1)%MOD;	
}
LL C(int n,int m){return n>=m?fac[n]*ifac[m]%MOD*ifac[n-m]%MOD:0;}
int n,k;
int main()
{
	int TOT;scanf("%d",&TOT);
	while(TOT--)
	{
		scanf("%d%d",&n,&k);
		pw(2*n+5);
		LL ans=C(n,k*2);
		for(int i=0;i<=n;i+=2)
		{
			LL val=C(n-i-k,k)*C(i/2+k-1,k-1)%MOD;
			(ans-=val)%=MOD;
		}
		(ans+=MOD)%=MOD;
		printf("%lld\n",ans*2%MOD);
	}
	return 0;
}


```

---

## 作者：EuphoricStar (赞：6)

不妨假设先手的牛在后手的牛左边，右边是对称的。

直接给出结论：先手必败当且仅当全部 $b_i - a_i$ 为奇数。

证明考虑归纳，首先 $\forall i \in [1, n], b_i - a_i = 1$ 是必败态，因为先手只能往左退，最后后手会把先手逼到最左边使得它无法动弹。

然后若存在 $i$ 使得 $b_i - a_i$ 为偶数，那么先手可以选择这些 $i$ 然后把这些牛往右移，让后手面对这个 $b_i - a_i$ 都为奇数的必败的局面。

计数是简单的。考虑数必败态，枚举 $\sum\limits_{i = 1}^n b_i - a_i - 1 = t$，那么相当于要把其他的空隙分成 $n + 1$ 份分别插入开头、末尾和第 $2i$ 和第 $2i + 1$ 头牛之间，然后对于第 $2i - 1$ 和第 $2i$ 的牛之间都要分配偶数个空隙。这些都可以用插板法计算。

时间复杂度 $O(l)$。

[code](https://codeforces.com/problemset/submission/1942/254165824)

---

## 作者：mayike (赞：5)

这题的计数过于有实力了。

### [题目传送门](https://codeforces.com/contest/1942/problem/E)

## 思路

发现对于 `a_b` 的输赢类似 `__abab` 是 `a` 赢，`abab__` 是 `b` 赢。

则可规定方向，毕竟 `a` 向左走是没必要的，`b` 同理，结果两倍即可。

规定相隔和距离指某两数之间的空格个数，例如 `a _ _ _ b` 中空格个数即距离是 $3$。

经过我的手玩和一些推导得一个 `a` 和其右边的第一个 `b` 的距离为奇数那么对于这个 `a` 是有进攻优势的，即单独算这个 `a` 进攻 `b` 是绝对胜利的，反得偶数必输。于是我们对于所有与其右边的第一个 `b` 相隔为奇数的 `a` 动即可，动完所有 `b` 与其左边的第一个 `a` 相隔为偶，必输。

对于奇数最优的证明：因为每次 `a` 往右走都会拉进一个与 `b` 的距离，而 `b` 要么往右要么往左，或者已经输了。那么每次 `a` 和 `b` 之间的距离只会不变或减少 $2$ 距离，又因为 `a` 是先手，所以 `a` 总会堵死 `b`，赢。

令所有 `a` 与其右边的第一个 `b` 相隔全为偶数的个数为 $p$。

$$ans\gets (\binom{l}{2n}-p)\times2$$

对于计数，因为总数为 $l$，我们变 $l\gets l-2\times n$。则减去这 $2\times n$ 个数后有 $l$ 个空位置。枚举除 `a` 和 `b` 之间的距离和 $t$，由插板法得方案：

$$\binom{t\div2+n-1}{n-1}$$

因为只能偶数个一组。然后就变成 $x=l-t$，再由插板法得：

$$\binom{l-t+n}{n}$$

结果：

$$ans\gets(\binom{l}{2n}-\sum_ {\substack{0 \leq t \leq l \\  2\mid t}}\binom{t\div2+n-1}{n-1}\times \binom{l-t+n}{n})\times2$$

时间复杂度 $\mathcal{O}(l)$。

---

## 作者：Eraine (赞：5)

编号：CF1942E

tag：博弈论，组合数学

难度：*2288（$\texttt{Clist}$ 数据）

别问为什么没有代码，问就是在老家网络不好 C 都打不了。下了 $206$ 分。

场外口胡型选手。

假设 $a_i\lt b_i$，由于 $a_i\gt b_i$ 是对称的，只需答案 $\times 2$ 即可。

FJ 获胜的策略很明显是把所有的棋子全部逼到右边，而 FN 获胜的策略相反，是把所有棋子全部逼到左边。

我们定义第 $i$ 组棋子的距离为 $b_i-a_i-1$，所以 $a_i$ 和 $b_i$ 相邻距离正好为 $0$。再定义往对方的方向（把对方逼死的方向）为前进，反方向为后退。

很容易发现，若到一方发现 $n$ 组棋子距离全为 $0$ 则该方必输。原因很简单，该方只能后退（被逼），对方只要模仿该方即可逼到角落。

若遇到 $n$ 组棋子距离不全为 $0$ 的情况，类似地，我们考虑后退，只要对方模仿该方的步骤前进则就是保持原有局面。所以后退是没有用的操作。只有前进有用。

考虑前进会对向量 $(b_1-a_1-1,b_2-a_2-1,\dots,b_i-a_i-1,\dots,b_n-a_n-1)$ 造成什么样的影响。选定 $k$ 个数移动，则是在该 $n$ 维向量中选择 $k$ 维同时 $-1$。

$n$ 维向量似乎不太好观察 $\texttt{SG}$ 函数，我们从 $2$ 维向量开始讨论。~~众所周知，博弈论打个表有助于我们观察结论。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/88rh258h.png)

很容易发现，必输态 $\texttt{N}$ 出现当且仅当两维均是 $2$ 的倍数。我们猜测扩展到 $n$ 为就是必输态 $\texttt{N}$ 出现当且仅当对于任意的 $i$ 均有 $2\mid b_i-a_i-1$。

容易用数学归纳法证明得出。

首先回顾一下 $\texttt{SG}$ 函数的定义。只要能下一步到达必输态 $\texttt{N}$ 则就是必赢态 $\texttt{Y}$，否则若下一步到达的均为必赢态则为必输态 $\texttt{N}$。

对于向量 $(0,0,\dots,0)$，显然是 $\texttt{N}$。

对于非 $0$ 向量 $f$，假设对于 $g_i\le f_i$ 且 $g\neq f$ 均满足以上结论，分两种情况讨论。

当存在 $i$ 满足 $2\nmid f_i$ 时，只需把所有的满足 $2\nmid f_i$ 的 $i$ 拎出来全部 $-1$ 就使得任意的 $i$ 均满足 $2\mid f_i$ 即必输态 $\texttt{N}$，所以该状态为必赢态 $\texttt{Y}$。

当对于任意的 $i$ 均满足 $2\mid f_i$ 时，因为拎出任意的非空子集都会使得子集部分变成 $2\nmid f_i$，也就是必赢态 $\texttt{Y}$，所以该状态为必输态 $\texttt{N}$。

得证。

考虑答案容斥，将全部情况减去必输的情况即可得到必赢的情况。

预处理阶乘及其逆元。全部情况即为 $2n\choose k$，而必输的情况可以枚举向量各个维度的总和 $\sum f_i$，用隔板法算出 $i$ 固定时 $f$ 的情况数和 $i$ 可能存在的位置总数，两者相乘即可。

$\Theta(\sum n)$。

各位看官点个赞再走吧。

---

## 作者：TLE_Automat (赞：3)

[Read In My Blog](https://tle-automat.top/2024/04/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1942E/#more)

## 题目链接

[https://codeforces.com/contest/1942/problem/E](https://codeforces.com/contest/1942/problem/E)

## 题目大意

小 N 和小 J 各有 $n$ 头奶牛，小 N 的奶牛位置为 $a_1, a_2, \cdots, a_n$，小 J 的奶牛位置为 $b_1, b_2, \cdots, b_n$。其中小 N 和小 J 的奶牛交替出现，且位置在 $1$ 与 $l$ 之间，即满足 $0 < a_1 < b_1 < a_2 < b_2 < \cdots < a_n < b_n < l + 1$ 或 $0 < b_1 < a_1 < b_2 < a_2 < \cdots < b_n < a_n < l + 1$。

现在小 J 和小 N 轮流进行以下操作，小 J 先手：

- 当前操作的人任意选中自己的 $k(1 \le k \le n)$ 头奶牛，并且让这些奶牛一起向左或向右移动**一格**。移动后，位置不能与另外一个人的奶牛重合，也不能超出边界（即位置不能小于 $1$ 也不能大于 $n$）。
- 若无法进行上述操作，当前操作的人判负。

问有多少种合法的序列组合 $(a, b)$，使得小 J 必胜（两人均足够聪明）。

## 数据范围

多组测试数据，保证

- $2 \le l \le 10^6 , \sum l \le 10^{6}$
- $1 \le n \le \left\lfloor\frac{l}{2}\right\rfloor$ 

## 解题思路

十分有意思的小清新博弈和组合数学题。

### Step 1

这题要求我们对先手必胜态进行计数，要计数我们必须要先搞清楚先手必胜态长什么样子。

先考虑比较简单的情况，如果 $n = 1$，此时发现如果小 J 的奶牛与小 N 的奶牛贴贴，那么小 J 必败；否则，小 J 和小 N 要尽量避免自己的奶牛被对方贴贴。

我们又发现，操作的人把自己的奶牛向使相对距离变远的方向移动是没有意义的，因为下一个操作的人模仿相同的动作总能把相对距离变回原来的状态。

所以 $n = 1$ 时小 J 是否必胜只与两头奶牛的相对距离的奇偶性有关。

### Step 2

我们 $n$ 为任意正整数时上述结论仍然成立，即

- 小 J 和小 N 的奶牛两两贴贴时先手必败。
- 操作的人把自己的奶牛向使相对距离变远的方向移动是没有意义的。

所以两两配对的奶牛之间的距离只会一直缩小至 $0$。

问题可以转化为给定 $n$ 堆石子，每次选取任意个（不能不选）剩余石子个数大于 $0$ 的堆，从这些堆的每一堆中都取走 $1$ 个石子，问先手是否必胜。

### Step 3

分析上一步转化的问题，发现**先手必败**的充要条件是所有堆的石子数均为偶数。

**证明：**如果石子堆中有奇数的堆，先手可以通过一次操作使得所有的堆中石子数均为偶数；否则，先手操作后至少会有一个奇数的堆。又因为最终不能操作的状态为全 $0$，都是偶数。所以如果有奇数的堆，先手每次操作后都能控制所有堆中的石子都是偶数，以此把后手逼迫到全 $0$。

### Step 4

经过上述分析，问题变为统计从长为 $l$ 的段中截取出若干个不相交的长度不全为偶数的子段的方案数。

不妨先统计总方案，再减去长度全为偶数的方案。

每一部分的方案使用乘法原理和隔板法计算即可。

最后答案别忘记乘 $2$，因为可以把小 J 的奶牛放在前面，也可以把小 N 的奶牛放在前面。

## 参考代码

[https://codeforces.com/contest/1942/submission/254441026](https://codeforces.com/contest/1942/submission/254441026)

---


# Below the Diagonal

## 题目描述

给你一个 $n$ 行 $n$ 列的矩阵，每行从上到下编号依次为 $1$ 至 $n$，每列从左到右编号依次为 $1$ 至 $n$。矩阵中，恰好有 $n-1$ 个位置上的元素为 $1$，其余元素为 $0$。你可以对矩阵进行如下操作：

1. 交换矩阵的第 $i$ 行与第 $j$ 行；
1. 交换矩阵的第 $i$ 列与第 $j$ 列；

你的目标是使得矩阵中每个 $1$ 的位置都在主对角线以下，即对于 $\forall\ i,j\in [1,n]$，若第 $i$ 行第 $j$ 列上的元素为 $1$，则应有 $i>j$。

请给出操作方案。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
2
2 1 2
1 1 2
```

## 样例 #2

### 输入

```
3
3 1
1 3
```

### 输出

```
3
2 2 3
1 1 3
1 1 2
```

## 样例 #3

### 输入

```
3
2 1
3 2
```

### 输出

```
0
```

# 题解

## 作者：ifffer_2137 (赞：0)

不算太妙的构造，~~但是还是想不到~~。
### 题意
给定 $n \times n$ 的矩阵中的 $n-1$ 个特殊点，每次操作可以交换任意两行或者两列，构造方案，使得若干次操作后所有特殊点都在主对角线以下（即横坐标大于纵坐标）。不必使操作数最少。
### 分析
考虑递归构造，让问题变得更小。在 $n=1$ 时已然解决。

$n \times n$ 的矩阵中只有 $n-1$ 个关键点，显然存在一列没有任何点，我们直接将第 $n$ 列换成空列。然后我们找一个非空的行，将它换到第 $n$ 行，由于第 $n$ 列已经为空所以第 $n$ 行此时一定满足条件，且至少有一个关键点。此时去掉第 $n$ 行和第 $n$ 列，在 $(n-1) \times (n-1)$ 的矩阵中至多有 $n-2$ 个点，问题规模缩小，递归构造即可。

容易发现递归 $O(n)$ 层，每层交换 $O(1)$ 次，所以总共操作次数在 $O(n)$ 级别，符合要求，具体实现暴力即可，给出复杂度 $O(n^2)$ 的粗糙实现。
### 代码
把一些头给去掉了。
```cpp
void solve(int x){
	if(x==1) return;
	for(int i=1;i<=x;i++) a[i]=b[i]=0;
	for(int i=1;i<=x;i++) for(int j=1;j<=x;j++) a[i]+=c[i][j],b[j]+=c[i][j];
	if(b[x]) for(int i=1;i<x;i++) if(!b[i]){ans.eb((node){2,i,x}); for(int j=1;j<=x;j++) swap(c[j][i],c[j][x]); break;}
	if(!a[x]) for(int i=1;i<x;i++) if(a[i]){ans.eb((node){1,i,x}); for(int j=1;j<=x;j++) swap(c[i][j],c[x][j]); break;}
	solve(x-1);
}
signed main(){
	#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	cin.tie(0),cout.tie(0);
	n=read();
	for(int i=1;i<n;i++){int x=read(),y=read();c[x][y]=1;}
	solve(n);
	cout<<ans.size()<<"\n";
	for(node k:ans) cout<<k.t<<" "<<k.i<<" "<<k.j<<"\n";
	return 0;
}
```

---


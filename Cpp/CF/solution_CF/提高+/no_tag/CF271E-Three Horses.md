# Three Horses

## 题目描述

有灰、白、灰白相间的马各一匹。马是享受娱乐的动物，这也是为什么它们喜爱特殊的牌。每一种牌必须包含两个整数——其中一个在牌顶，一个在牌底。让我们用$(a,b)$表示顶部为$a$，底部为$b$的牌。

这三匹马都能够创造特殊的牌。

如果你把一张$(a,b)$卡牌展示给灰马，那么它就会创造一张$(a+1,b+1)$卡牌。

如果你把一张$(a,b)$卡牌展示给白马，且$a,b$都为偶数，那么它就会创造一张$(\frac{a}{2},\frac{b}{2})$卡牌。

如果你把两张分别为$(a,b),(b,c)$的卡牌展示给灰白相间的马，那么它就会创造一张$(a,c)$卡牌。

现在要求拿到$n$张特殊卡牌$(1,a_1),(1,a_2),...,(1,a_n)$。但是只能携带一张$(x,y)$前往。请问有多少种选择初始卡牌$(x,y)$的方式，能够让三匹马创造出上述所有卡牌？

只能通过上述三匹马的创造方式得到卡牌。允许用一张卡牌创造出多张。

## 样例 #1

### 输入

```
1 6
2
```

### 输出

```
11
```

## 样例 #2

### 输入

```
1 6
7
```

### 输出

```
14
```

## 样例 #3

### 输入

```
2 10
13 7
```

### 输出

```
36
```

# 题解

## 作者：Velix (赞：0)

半年没做数论了，手感生疏，望谅解（

---

### 题意简述：

对于若干数对，有如下三个操作：

1. 用 $(x,y)$ 生成一个新数对 $(x+1,y+1)$；

2. 用 $(x,y)$ ( $x$、$y$ 均为偶数)生成一个新数对 $(x/2,y/2)$；

3. 用两个数对 $(x,y),(y,z)$ 生成一个新数对 $(x,z)$。

有 $n$ 个数对 $(1,a_i)$，

求有多少种数对 $(x,y)$ 可以同时生成这 $n$ 个数对 $(1\leqslant x<y\leqslant m)$。

$n\leqslant 10^5,2\leqslant m,a_i\leqslant10^9$

---

根据操作1可知，任意一个数对 $(x,y)$ 可以生成 $(x+z,y+z)$，其中 $z$ 为任意正整数。

那么假设此时有数对 $(a,a+b)$，那么操作1可以生成 $(a+b,a+2b)$，并使用操作3，可以生成 $(a,a+2b)$；

再以此数对生成 $(a+b,a+3b)$，并与 $(a,a+b)$ 生成 $(a,a+3b)$；

以此类推，可以生成数对 $(a,a+4b),(a,a+5b),(a,a+6b)……$

我们对于数对 $(1,a_i)$，可以考虑先生成数对 $(0,a_i-1)$ 再生成它（其实不可能，只用来辅助说明）。

而能够用上述方法能生成 $(0,a_i-1)$ 的数对集合显然为 $(0,a_i-1\text{的约数})$；

因此设 $x=gcd_{i=1}^n(a_i-1)$，由上可知能够同时生成所有 $(0,a_i-1)$ 的数的集合为 $(0,x\text{的约数})$。

不过考虑到操作2的存在，这个集合应该被扩充为 $(0,x\text{的约数乘任意2的幂次})$。

当然前面只是针对于数对中前一个数为 $0$ 的情况，现在还得考虑不为 $0$ 的情况。

---

### 结论：若 $(0,k)$ 为合法解，则任意 $(x,x+k)$ 均为合法解

考虑到实际上 $(x,x+k)$ 不可能化为 $(0,k)$，所以将其化为 $(1,1+k)$。

设有一个足够大的 $y$ 使得 $2^y>x$；

又设 $x+z=2^y$；

那么首先进行多次操作使 $(x,x+k)$ 生成 $(x,x+2^yk)$；

再进行操作1使其变为 $(x+z,x+2^yk+z)$；

而 $(x+z,x+2^yk+z)=(x+z,x+z+2^yk)=(2^y,2^y+2^yk)=(2^y,2^y(k+1))$

由于所有的 $2$ 次幂可以通过一堆操作2消掉，于是该式就化为了 $(1,1+k)$

---

然而当你快乐的打完前面的代码后你会发现答案总是多那么亿点点（

这是因为当 $x$ 的一个约数是 $2$ 的倍数时它的所有产生的合法解其实都已经被之前的不含 $2$ 的约数的二次幂给算过了，导致算重。~~好绕~~

知道就好做了，直接不算约数中是 $2$ 的倍数的就行了。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100010],n,m,g,b[100010],tot,ans;
long long gcd(long long x,long long y){return x%y?gcd(y,x%y):y;}
int main()
{
	cin>>n>>m;
	cin>>a[1];
	g=a[1]-1;
	for(int i=2;i<=n;i++)
	{
		cin>>a[i];
		g=gcd(g,a[i]-1);//处理gcd 
	}
	for(int i=1;i*i<=g;i++)//计算约数（记得去掉2的倍数） 
	if(g%i==0) 
	{
		if(i&1)b[++tot]=i;
		if(((g/i)&1)&&i!=(g/i))b[++tot]=g/i;
	}
	for(int i=1;i<=tot;i++)
		for(int j=0;b[i]*(1<<j)<=m;j++)//枚举每个约数的2次幂 
			ans+=m-(b[i]*(1<<j));
	cout<<ans;
}
```


---


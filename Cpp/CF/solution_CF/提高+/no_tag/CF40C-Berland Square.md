# Berland Square

## 题目描述

集合(K,z)是以点(z,0)为圆心，分别以1、2、………K 为半径画出的同心圆。在平面上画了一个(N,x)集和一个(M,y)集，你必须找出这些集合把平面分成了多少部分。

## 样例 #1

### 输入

```
1 0 1 1
```

### 输出

```
4
```

## 样例 #2

### 输入

```
1 0 1 2
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3 3 4 7
```

### 输出

```
17
```

# 题解

## 作者：shinkuu (赞：0)

一个不需要分讨的做法。

直接数分割成的部分数是难做的，不过这种问题可以考虑平面图的欧拉公式：$|V|-|E|+|F|-1=|C|$。其中 $V$ 是点集，$E$ 是边集，$F$ 是分割成的平面集，$C$ 是连通块集。

然后考虑怎么算。此时还有一个观察：由于这个平面图是由圆组成的，每一个圆相当于图的一个环，而环上 $|V|=|E|$。也就是说，只需要对于其中一个 $(K,z)$ 集合，算出来这个圆一共被分成了多少段记作 $x$，那么答案就是 $x+|C|+1$ 了。

还需要注意，这里我们将一个不和其他任何圆在弧上相交的圆视作 $|V|=|E|=1$ 的连通块。

然后考虑算这个 $x$。枚举左侧的集合的每一个圆，不难发现和这个圆弧相交的右侧的圆的 $r$ 是一段区间。每和一个圆相交，就会多分出来 $2$ 段弧。但是要特判相切的情况。此时只会多一段。

最后就是算 $|C|$。不难发现对于两个集合都是 $r$ 的一段前缀及后缀的圆不与其他圆有交。直接数就行。

code：

```cpp
int n,m,k;
void Yorushika(){
	int x;
	read(n,x,m,k);
	k-=x,k=abs(k);
	ll E=0;
	rep(i,1,n){
		int l=abs(k-i),r=min(k+i,m);
		if(l<=r){
			E+=(r-l+1-!l)*2-(l==abs(k-i)&&l)-(r==k+i);
		}
	}
	printf("%lld\n",E+1+min(max(k-n-1,0),m)+min(max(k-m-1,0),n)+max(n-k-m,0)+max(m-k-n,0)+(n+m>=k));
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：huoyuxi (赞：0)

本题是一个找规律的题

给的两个点的起始坐标，可以转化为距离，将半径大的归r1,另一个给r2。

本题半径较大应该用长整形，我的代码多讨论了一种x=y的情况。

我的分类依据的是以内切外切
```
#include<iostream>
#include<string.h> 
#include<math.h>
using namespace std;
int main()
{
	long long int r1,r2,a1,a2,k;
	cin>>r1>>a1>>r2>>a2;
	k=abs(a1-a2);
	if(r2>r1)
	{
		a1=r1;
		r1=r2;
		r2=a1;
	}
	if(k==0)
	cout<<r1+1;
	else if(r1+r2<=k)
	cout<<r1+r2+1;
	else if(r1<=k&&k<r1+r2)
	cout<<k+1+(r1+r2-k)*(r1+r2-k+1);
	else if(r2<=k&&k<r1&&r1<=k+r2)
	cout<<r1+1+2*r2*r2-(r2-r1+k)*(r2-r1+k-1);
	else if(r2<=k&&k<r1&&r1>k+r2)
	cout<<r1+1+2*r2*r2 ;
	else if(r2>k&&r1>=k+r2)
	cout<<2*r2*r2-2*(r2-k)*(r2-k)+r1-r2+k+1;
	else if(r2>k&&r1<k+r2)
	cout<<2*r2*r2-2*(r2-k)*(r2-k)+r1-r2+k+1-(r2+k-r1)*(r2+k-r1-1);
 } 
```


---


# Safe cracking

## 样例 #1

### 输入

```
1 2 4 2
```

### 输出

```
/2
/3
```

## 样例 #2

### 输入

```
3 3 1 1
```

### 输出

```
+1
/1
/1
```

## 样例 #3

### 输入

```
2 1 2 4
```

### 输出

```
/3
/4
```

# 题解

## 作者：__Cby___ (赞：2)

## 警钟 
- 1.这道题不同于别的 `CF` 题，有多组数据，像楼下写的那样，只有一组数据，事实上有几十个测试点，一个测试点就 $4$ 个数不会再多!!  
- 2.此题中，那个无解 $-1$ 是没用的，~~不能不可以总司令了QWQ~~
- 3.需要有**肝帝**精神。

## 思路
### 思路
贪心求解，由于最大的要最先消除，所以每次找到最大的。  
若最大的为偶数:
- 1.若左边也为偶数，左边和最大的一起除以 $2$。  
- 2.若右边也为偶数，右边和最大的一起除以 $2$。  
- 3.若左右皆为奇数，左和最大加 $1$，最大和右加 $1$，最大和左除以 $2$。  

若最大的为奇数:
- 1.若左边也为奇数，左边和最大的一起加 $1$ 并除以 $2$。  
- 2.若右边也为奇数，右边和最大的一起加 $1$ 并除以 $2$。  
- 3.若左右皆为偶数，最大和右加 $1$，最大和左除以 $2$。 　
### 存储方式
用数组存，方便计算左右边。  
边计算边输出。  
## AC代码
```cpp
#include <iostream>
using namespace std;
int a[5];
int main(){
	for(int i=1;i<=4;i++){
		cin>>a[i];
	}
	while(1){
		int t=0;
		bool y=1;
		for(int i=1;i<=4;i++){
			if(t<a[i])t=i;//最大
			if(a[i]!=1)y=0;
		}
		if(y){//退出
			break;
		}
		int l=(t+3)%4,r=(t+1)%4;//找出左右的下标
		if(l==0)l=4;
		if(r==0)r=4;
		if(a[t]%2==0){
			if(a[l]%2==0){
				cout<<"/"<<l<<endl;
				a[l]/=2;a[t]/=2;
			}
			else if(a[r]%2==0){
				cout<<"/"<<t<<endl;
				a[t]/=2;a[r]/=2;
			}
			else if(a[l]%2==1&&a[r]%2==1){
				cout<<"+"<<l<<endl<<"+"<<t<<endl;
				a[l]++;a[r]++;a[t]+=2;
				cout<<"/"<<l<<endl;
				a[l]/=2;a[t]/=2;
			}
			else{
				cout<<-1<<endl;//没用
				break;
			}
		}
		else{
			if(a[l]%2==1){
				cout<<"+"<<l<<endl<<"/"<<l<<endl;
				a[l]++;a[t]++;a[l]/=2;a[t]/=2;
			}
			else if(a[r]%2==1){
				cout<<"+"<<t<<endl<<"/"<<t<<endl;
				a[t]++;a[r]++;a[t]/=2;a[r]/=2;
			}
			else if(a[l]%2==0&&a[r]%2==0){
				cout<<"+"<<t<<endl<<"/"<<l<<endl;
				a[t]++;a[r]++;a[t]/=2;a[l]/=2;
			}
			else{
				cout<<-1<<endl;//没用
				break;
			}
		}
	}
	return 0;
} 
```


---

## 作者：小杨小小杨 (赞：0)

## 题意
给你四个数，你可以选择两个相邻的数字都加一，或者选择两个相邻的数字都除以二，使得最终四个数都为一。
## 思路 
贪心算法加数学。   
因为最终结果要求你把每一个数都变成一，那么就可以这么去做：  

1. 找到这四个数中最大的。  

2. 判断它是奇数还是偶数和左右两个数是奇数还是偶数。  

3. 如果最大数是偶数：
	1. 如果它的左边那个数也是偶数，那么就把它自己和它左边的数分别除以二，并保存左边那个数（除）。
    
   2. 如果它的右边那个数也是偶数，那么就把它自己和它右边的数分别除以二，并保存它自己（除）。
   
   3. 如果它的左边那个数是奇数，且它的右边那个数也是奇数，那么就现将它和它左边的数分别加一，再将它和它右边的数分别加一，最后把它左边的数和它自己分别除以二，并保存它左边的数（加）、它自己（加）和它左边的数（除）。
4. 如果最大数是奇数：
	1. 如果它的左边那个数也是奇数，那么就把它自己和它左边的数分别加一再除以二，并两次保存左边那个数（加）。
    
   2. 如果它的右边那个数也是奇数，那么就把它自己和它右边的数分别加一除以二，并两次保存他自己（加）。
   
   3. 如果它的左边那个数是偶数，且它的右边那个数也是偶数，那么就将它和它右边的数分别加一，再把它左边的数和它自己分别除以二，并保存它自己（加）和他左边的数（除）。
   
 以上为核心思路。程序中我用 $1$ 表示除， $0$ 表示加。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5],b[10001],c[10001],tot;
int main(){
	while (~scanf("%d%d%d%d",&a[1],&a[2],&a[3],&a[4])){
		tot=0;
		while (1){
			int ma=-1,top=0;
			for (int i=1;i<=4;i++)
				if (a[i]>ma) ma=a[i],top=i;
			if (ma==1) break;
			int l=(top-1+4-1)%4+1,r=top%4+1;
			if (a[top]%2==0){//上面都说了
				if (a[l]%2==0){
					a[top]/=2;a[l]/=2;
					b[++tot]=1;c[tot]=l;//保存
				}
				else if (a[r]%2==0){//上面都说了
					a[top]/=2;a[r]/=2;
					b[++tot]=1;c[tot]=top;//保存
				}
				else{//上面都说了
					a[top]=a[top]/2+1;a[l]=a[l]/2+1;a[r]++;
					b[++tot]=0;c[tot]=l;
					b[++tot]=0;c[tot]=top;
					b[++tot]=1;c[tot]=l;//保存
				}
			}
			else{
				if (a[l]%2){//上面都说了
					a[top]=a[top]/2+1;a[l]=a[l]/2+1;
					b[++tot]=0;c[tot]=l;
					b[++tot]=1;c[tot]=l;//保存
				}
				else if (a[r]%2){//上面都说了
					a[top]=a[top]/2+1;a[r]=a[r]/2+1;
					b[++tot]=0;c[tot]=top;
					b[++tot]=1;c[tot]=top;//保存
				}
				else{//上面都说了
					a[top]=a[top]/2+1;a[r]++;a[l]/=2;
					b[++tot]=0;c[tot]=top;
					b[++tot]=1;c[tot]=l;//保存
				}
			}
		}	
		for (int i=1;i<=tot;i++,putchar(10))
			if (b[i]) printf("/%d",c[i]);
			else printf("+%d",c[i]);
	}
	return 0;
}

```


---


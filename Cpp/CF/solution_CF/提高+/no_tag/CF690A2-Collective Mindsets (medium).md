# Collective Mindsets (medium)

## 题目描述

Way to go! Heidi now knows how many brains there must be for her to get one. But throwing herself in the midst of a clutch of hungry zombies is quite a risky endeavor. Hence Heidi wonders: what is the smallest number of brains that must be in the chest for her to get out at all (possibly empty-handed, but alive)?

The brain dinner night will evolve just as in the previous subtask: the same crowd is present, the $ N-1 $ zombies have the exact same mindset as before and Heidi is to make the first proposal, which must be accepted by at least half of the attendees for her to survive.

## 样例 #1

### 输入

```
1
```

### 输出

```
0
```

## 样例 #2

### 输入

```
3
```

### 输出

```
1
```

## 样例 #3

### 输入

```
99
```

### 输出

```
49
```

# 题解

## 作者：tzc_wk (赞：11)

[Codeforces 题面传送门](https://codeforces.ml/contest/690/problem/A2) & [洛谷题面传送门](https://www.luogu.com.cn/problem/CF690A2)

一道脑筋急转弯的结论题。

首先我们考虑对于某个特定的金币数 $m$，有哪些 $n$ 满足条件。考虑最 naive 的情况，$m=0$：显然 $n=1,2$ 满足条件，而对于 $n=3$，由于总共只有 $0$ 个金币，因此第 $2,3$ 个人会且只会拿到 $0$ 个金币，而即便第一个人被杀，问题转化为 $n=2$ 的情形，另外两个人也会活下来，没有做到“严格更优”，因此另外两人必然投反对，第一个人也就被杀了。对于 $n=4$，第一个人自己肯定赞成，由于第一个人被杀后问题转化为 $n=3$ 的情形，此时第二个人必然被杀，因此第二个人也会赞成，后两人由于不管怎么样都是 $0$ 个金币且一定活下来，因此自然投反对，$2$ 对 $2$，因此第一个人会活下来。同理 $n=5$，后四个人不管怎么样都是 $0$ 个金币，都投反对，因此第一个人会被杀；$n=6$，第一个人赞成，由于第一个人被杀后，第二个人就变为 $n=5$ 的分配金币情况，不论怎样都被杀，因此第二个人也会赞成，后四个人自然反对，$2$ 对 $4$，人数没过半，第一个人被杀；$n=7$，第一、二、三个人肯定都会赞成，否则轮到它们分的时分别是 $n=5,6$ 的情况，这两种情况都会导致分金币的人被杀，但另外四个人还剩会反对，$3$ 对 $4$，人还是不够，被杀；$n=8$，类似地有前四个人投赞成，后四个人投反对，刚好 $4$ 对 $4$。

相信推到这里，聪明的你已经发现，对于 $m=0$ 的情况，符合条件的 $n$ 可以写成 $2^k$ 的形式 $(k\in\mathbb{Z})$

接下来考虑推广到更一般的情况，容易注意到一件事情，那就是当 $n=2m$ 时一定符合条件，此时第一个人只用把金币分给与它所在位置奇偶性相同的人即可，这个不难归纳证明。同理 $n=2m+1$ 时候也符合条件，类似地分给第 $3,5,7,\cdots,2k+1,\cdots,2m+1(k\in[1,m])$ 即可。我们考虑从 $n=2m+2$ 开始推起，显然当 $n=2m+2$ 时第一个人只用拿金币贿赂第 $3,5,7,\cdots,2m+1$ 个人即可，因为如果第一个人被杀死了，轮到第二个人分金币，他肯定会分给第 $4,6,8,\cdots,2m+2$ 个人，这些人就一分钱都莫得了，加上自己，刚好 $m+1$ 个人。但是 $n=2m+3$ 时就没那么走运了，因为 $m$ 个金币最多贿赂 $m$ 个人，即便你把这些金币分给第 $5,7,9,\cdots,2m+3$ 个人，让他们赞成你，又如何？第二个人必然反对——因为如果第一个人被杀死了，轮到他分，不管怎样都是 $0$ 个金币，没有做到“严格更优”，同理第三个人也会反对，第 $4,6,8,\cdots,2m+2$ 个人也就更会反对了——如果第二个人分他们本可以拿的更多的，因此总共 $m+1$ 人赞成，第一个人被杀。对于 $n=2m+4$ 的情况，首先第一个人会赞成，其次第二个人也会赞成，因为如果第一个人被杀问题就变为 $n=2m+3$，他也就 GG 了，然后你再拿金币贿赂第 $6,8,\cdots,2m+4$ 个人——因为如果第一个人被杀，第二个人 $n=2m+3$ 的情况也被杀，就轮到第三个人分金币，那他肯定会分给第 $5,7,\cdots,2m+3$ 个人，就没有这些人的份了，他们都投赞成，总共 $m+2$ 个赞成，刚好。$n=2m+5$，第一个人赞成自己，第二个人反对，因为就算第一个人被杀轮到他分还是 $0$ 个，第三、四、五个人同理反对，此时再贿赂 $m$ 个人，最多 $m+1$ 个赞成，被杀。同理 $n=2m+6,2m+7$ 也会被杀，而对于 $n=2m+8$，第一个人显然赞成，第二、三、四个人也赞成，否则轮到他们时他们就被杀了，此时再贿赂 $m$ 个人，总共 $m+4$，刚好过半。

相信聪明的读者一定还能发现，对于这种情况，符合条件的 $n$ 一定等于 $2^k+2m(k\in\mathbb{Z})$，因此对于 $n$ 是奇数的情况答案显然是 $\dfrac{n-1}{2}$，否则记 $k$ 为满足 $2^k\le n$ 的最大的整数，答案就是 $\dfrac{n-2^k}{2}$。

~~真·这篇题解码了我 1.2k，尽管只是个 *2300~~

---

## 作者：Karry5307 (赞：6)

### 题意

给定一个整数 $n$，问当 $n$ 个海盗分金子的时候第一个海盗最少需要多少金子才能不被杀死。

$\texttt{Data Range:}1\leq n\leq 10^9$

### 题解

这题好神啊……

考虑从已知金子的数量 $m$ 反推有多少海盗的时候第一个海盗不会被杀死。

当 $n\leq 2m$ 的时候是显然可以的，因为 $1$ 号只需要给除了自己以外并且编号为奇数的那些海盗每人一个金子即可。这样下来所有编号为奇数的海盗都会赞同，显然过半，因此第一个海盗会存活下来。

然而这不是全部情况。假设现在第一个海盗一个金子都没有，考虑当人数为多少的时候能存活下来。

当 $n=1,2$ 的时候，显然能够活下来。当 $n=3$ 的时候，由于 $1$ 号没有办法去贿赂剩下的海盗投赞成票，同时如果自己死了 $2$ 号仍然能存活下来，所以必死无疑。当 $n=4$ 的时候，由于 $1$ 号死了必然导致 $2$ 号死，所以 $2$ 号投赞成票，$1$ 号得以保全性命。

当 $n=5$ 的时候，除了自己没有人会投赞成票，所以必死；$n=6$ 时只有前两个人会投赞成票，还是必死；$n=7$ 的时候只有前三个人会投赞成票，仍然是必死；直到 $n=8$，由于 $5,6,7$ 号都想活下来，都会给 $8$ 号投赞成票，再加上自己的一个就可以活下来了。

接下来证明，如果没有金子的时候只有当 $n=2^k$ 时 $1$ 号才能保全，这个可以采用数学归纳法。

假设结论在 $n=2^k$ 时成立（这里假设 $k>3$，因为 $k\leq 3$ 的情况上，无法存活；$n=2^k+2$ 时只有 $1,2$ 号赞成，无法存活；以此类推，到 $n=2^k+2^k-1$ 时 $1,\cdots 2^k-1$ 号都会赞成，但是赞成的数量还是没有过半，所以还是必死。当 $n=2^{k+1}$ 时，$1\cdots 2^k$ 号都会赞成，于是能够活下来，所以结论也会在 $n=2^{k+1}$ 时成立。

最终证明了这个结论的正确性。现在当有 $m$ 个金子的时候，$1$ 号会先在前 $2m$ 个人中用手头上的金子贿赂 $m$ 个人，接下来变成没有金子的问题。所以当 $n=2^k+2m$ 的时候第一个人会活下来。

于是分析了这么多之后，$1$ 号能活下来当且仅当 $1\leq n\leq 2m$ 或者 $n=2^k+2m$，贪心即可找到当 $n$ 固定时候最小的 $m$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
ll n;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read();
	printf("%d\n",n&1?n/2:(n-(1<<(ll)(log2(n))))/2);	
}
```

---

## 作者：fish_love_cat (赞：3)

三道神仙题，给出题人磕一个。

## [A1](https://www.luogu.com.cn/problem/CF690A1)

你有 $m$ 枚硬币，你要给 up 们投币，up 们会投票决定是否打飞你，你需要有至少一半的 up 支持你活下来并且保存一枚硬币，问 $m$ 最小多少。

首先我要是没给 up 投币，up 肯定会红温决定打飞我，所以我们至少要给一半的 up 投币以求存活，答案 $\lceil \frac{n}{2} \rceil$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<(n+1)/2;
    return 0;
}
```

[记录](https://codeforces.com/problemset/submission/690/318438598)。

## [A2](https://www.luogu.com.cn/problem/CF690A2)

同样问 $m$ 最小多少，但此时你不用保存一枚硬币在手上了。

根据 A1 显然有 $m\ge\frac{n}{2}$ 活，但不一定最优。

考虑没币的时候怎么活。

注意到 $1,2$ 号一定死不了，所以这两个可以肆无忌惮的打飞其他人。

于是 $3$ 号就可以被打飞了，所以为了活下来她会拼命支持后面的 $4$ 号。

又注意到 $4$ 号此时无敌了，所以前面的四个心眼又开始黑了，决定联合打飞后面的好来分硬币，直到 $[5,8]$ 号联手存活。

又注意到 $8$ 号此时无敌了，所以前面的八个心眼又开始黑了，决定联合打飞后面的好来分硬币，直到 $[9,16]$ 号联手存活。

……

又注意到 $2^k$ 号此时无敌了，所以前面的 $2^k$ 个心眼又开始黑了，决定联合打飞后面的好来分硬币，直到 $[2^k+1,2^{k+1}]$ 号联手存活。

所以可以得到 $n=2^k$ 可以活。

那我不是怎么办！

容易发现可以在开始时先进行奇偶交替的互抵贿赂，于是在 $n=2^k+2m$ 时也能活了。

现在答案就可以轻松的找出来了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    if(n%2)cout<<n/2;
    else for(int i=31;i;i--)if(n&(1<<i)){
        cout<<(n-(1<<i))/2;
        return 0;
    }
    return 0;
}
```

[记录](https://codeforces.com/problemset/submission/690/318440080)。

## [A3](https://www.luogu.com.cn/problem/CF690A3)

题不一样了。这是最高妙的一题。

首先我知道所有人的数字和是一个定值。

于是考虑猜测我们数字和的大小，然后再根据我所看见的其他人数字的和，从而推算出我的数字是啥。

由于都是在模 $n$ 意义下考虑的，所以可以让每个编号固定猜测数字和的值，然后进行推算，这样就保证了必有一个正确。

```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(){
    int n,m;
    cin>>n>>m;
    int flc=0;
    for(int i=1;i<n;i++){
        int x;
        cin>>x;
        flc+=x;
    }
    m=m+flc-1;
    cout<<n-m%n<<'\n';
}
int main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

[记录](https://codeforces.com/problemset/submission/690/318440706)。

---

## 作者：yzy1 (赞：3)

考虑有 $0$ 个金币时哪些人会存活。$1$ 号、$2$ 号显然存活，$3$ 号会被 $1,2$ 反对所以无法存活，$4$ 号会获得 $3$ 的赞同票所以可以存活。可以发现，存活的人是 $1,2,4,8,\cdots$。

有 $1$ 个金币时，$1,2,3,4$ 显然存活，$5$ 无法获得多于 $2$ 个选票所以无法存活，$6$ 会获得 $5$ 的赞同票所以可以存活。可以发现，存活的人是 $1,2,3,4,6,10\cdots$。

所以得出结论，有 $B$ 个金币时，存活的人的集合是 $\{1,2,3,...,2B\}\cup(2B+\{1,2,4,8...\})$。

- 当 $n \bmod 2 = 1$ 时，$B=(n-1)/2$ 时 $n$会第一次在集合中出现，答案为 $\dfrac{n-1}2$。
- 当 $n\bmod 2 = 0$ 时，找到最大的 $2$ 的次幂 $p$ 使得 $p\le n$，此时 $n$ 会在 $B=\dfrac{n-p}2$ 时第一次在集合中出现，答案为 $\dfrac{n-p}2$。



---

## 作者：Kreado (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/CF690A2)。

有意思的结论题，想了我一个多小时。

## 思路

请注意题目中：**每个海盗的第一目标都是保命，其次是拿到更多的金币，再其次是杀掉更多的人**。

既然题目要求最小，那么我们不妨考虑从 $ans=0$ 入手。

当 $n=1$ 时，$0$ 显然是合适的答案。

当 $n=2$ 时，第一个人给自己投支持票，那么显然 $0$ 是一个合适的答案。

当 $n=3$ 时，第二，三个人无论如何都不会死，所以肯定会给第一个人投反对票，也就是 $n=3$ 时答案大于 $0$。

当 $n=4$ 时，第三，四个人无论如何都不会死，假设第二个人投反对票给第一个人，那么就来到 $n=3$ 的情况，这个时候这个人无论如何都会死，那么第二个人一定会给第一个人投支持票，此时 $0$ 是一个合法的答案。

当 $n=5$ 时，我们已经能确保最后四个人一定不会死，那么一定会投反对票，$0$ 是一个不合法的答案。

以此类推，$n=6,7$ 时 $ans=0$ 都不合法，当 $n=8$ 时，后面四个人会投反对票，若前面四个人当中有一个人投了反对票，那么就会来到 $n=7$ 的情况，此时除后面四个人，其余的人都会死，那么前面四个人一定不会投反对票，$0$ 就是一个合法的答案。

我们发现 $n=8$ 又会形成一个轮回，后面八个人一定会给前面的人投反对票，此时你应该得到了一个结论，当 $n=2^k(k\in\mathbb{Z})$ 时，$ans=0$。

接下来考虑从 $ans=1$ 考虑：

当 $n=1,2,3,4$ 时，$ans=1$ 显然是一个合适的答案。

当 $n=5$ 时，无论投给谁都无法获得超过 $3$ 个人的支持，因此 $ans=1$ 不是一个合适的答案。

当 $n=6$ 时，第二个人一定会给第一个人支持票，考虑 $n=4$ 含有一枚金币的情况，此时最后一个人获得金币，那么我们只需将金币给第四个人或者第五个人即可。

我们发现 $ans=1$ 的形式和 $ans=0$ 的形式非常相似，我们可以对此总结出，假设要分 $k$ 个金币，那么 $k$ 对于这些 $\{n\mid \{1,2,\dots,2k \}\cup \{1+2k,2+2k,4+2k,\dots\} \}$ 来说是一个合适的答案。

对于每个合适的答案，我们取一个最小值即可，那么有：

当 $2\nmid n$ 时，$ans=\lfloor n/2 \rfloor$。

当 $2\mid n$ 时，$ans=(n-2^{\lfloor\log_2 n \rfloor})/2$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int n;

int main(){
	scanf("%d",&n);
	int x=log2(n);
	if(n&1) printf("%d",n/2);
	else printf("%d",(n-(int)pow(2,x))/2);
	return 0;
}

```

---

## 作者：FriedrichC (赞：2)

[洛谷题面](https://www.luogu.com.cn/problem/CF690A2)

[原题链接](https://codeforces.com/problemset/problem/690/A2)

这题相对于 A3 来说，也是十分有趣的题目。

如果读者还没做过这题的 A1 [简单版本](https://www.luogu.com.cn/problem/CF690A1)，建议可以先花一点时间把这题切了。

将本题与其简单版本相比较，我们一下就能发现问题的关键。

## 题目分析
本题相较于 A1 来说，区别在于每个人可以为了活命而**不要金币**，

A1 的答案只是简单的 $\lceil \dfrac{n}{2}\rceil$，而本题的答案并没有表面上看起来那么简单。

先考虑一下前面所说的那个区别对于答案产生了什么影响，

我们意识到，与 A1 相比，由于我们不用保证一定要得到金币，所以在同等总人数（记为 $n$）的情况下，我们所需要的最少金币数（记为 $m_0$）可能会**更少**，也就是最优解更优，

再比如，A1 当中绝对不会存在 $m_0=0$ 的合法解，而本题却可以存在，

所以本题相较于 A1 还可能**增加**了合法解的**种类**。

如果从**博弈论**的角度出发，我们可以很清楚的看到不同的解之间的关系。

我们把**总人数**与**金币数**的**二元组** $(n,m)$ 当做一种**局面**，把**第一个人**能存活的局面叫做**必胜局面**，反之为**必败局面**。

首先我们知道，不论如何，当 $m=\lceil \dfrac{n}{2}\rceil$ 时都是必胜局面，但是在本题的条件之下，最优解肯定会**更小**。

这样思考启发了我们：是否存在当 $m$ **极小时**，比如 $m=0$ 时的**必胜局面**的存在**规律**呢？

如果我们能找到这样一个规律，我们就可以把这样的局面当做其他相邻局面的**后继局面**，那么我们就可以通过反向**扩展**得到将所有局面改为必胜局面的**通解**。

## 局面研究
那么我们先来尝试研究当 $m=0$ 时必胜局面的规律。

首先，局面 $(1,0),(2,0)$ 显然为必胜局面，从 $(2,0)$ 之中我们似乎可以看到一些端倪：

仔细想一想，究竟为什么在 $(2,0)$ 时，不需要任何金币 $1$ 号就可以活下来呢？

我们知道，当根本分不到金币时，个体会依据下一个**优先级**（也就是杀更多的人）来行动，

但是哪怕 $2$ 号会不同意 $1$ 号的方案，至少 $1$ 号会同意自己的方案，那么因为同意的人数与不同意的人数是**相等**的，$1$ 号就得以存活。

我们由此得到启发，可以借这个思路去拓展**下一个**必败和必胜局面：

当以 $(2,0)$ 为后继局面时，设当前局面为 $(n_0,0)$，局面中的**后两个人**一定会不同意 $1$ 号，因为当不断从前往后淘汰人，最终使得人数减为 $2$ 时，此时的局面是必胜局面，也就是说明这两人本就可以存活。

那么根据我们上面说的，如果使得同意与不同意的人数相等，我们就创造出了必胜局面，因此 $(4,0)$ 就是必胜局面，

相应的，如果同意的人数小于不同意的人数，就是必败局面，比如 $(3,0)$。

那么我们以此类推，再以 $(4,0)$ 为后继局面不断拓展，我们会发现得到其他的必胜局面比如 $(8,0)$,$(16,0)$ 等等。

由于在扩展时每次人数翻倍，显然我们有 $(2^k,0)$ 是必胜局面，其中 $k\in \mathbb{N}$。

其余的 $m=0$ 的局面都是必败局面。

## 答案求解
在博弈图上，可以上述内容可以理解为每个局面向最近的必胜局面也就是数值最近的 $m$ 为 $2$ 的**整数幂**的局面连边。

那么对于一般的局面 $(n,m)$，当且仅当 $n=2^k,k\in \mathbb{N}$ 时 $m$ 可以取极小值，那么为了使得其他的情况成为必胜局面，需要排除其后继局面，也就是最近的 $2$ 的整数幂的人数的影响，

即需要至少 $m_0=\dfrac{n-2^k}{2}$，其中 $k$ 为不大于 $n$ 的最大 $2$ 的整数幂的**指数**。

这样做的意义在于：打破当前局面的后继局面的**平衡性**，使得其原先的后继局面不再是一个必胜局面，因此 $2^k$ 个人就不可能是清一色的反对。

这样的策略的正确性很容易证明：

$n-2^k$ 是原先 $m=0$ 时同意与不同意的人数的差值，显然我们只需得到其**一半**的赞成票就可以形成必胜局面。

需要注意的是，由于 $m\in \mathbb{N}$，所以当 $n$ 为**奇数**时，只能取 $k=0$。

## 附上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    if(n%2)cout<<(n-1)/2;
    else cout<<((n-(1<<__lg(n)))/2);
	return 0;
}
```






































---

## 作者：Aw顿顿 (赞：2)

这场的 A2 和 A3 怎么都这么神仙（痛苦

--------

显然当我们给每个奇数位置的海盗金币，就可以获得半数的赞成，即需要 $n\div 2$ 个金币，但是这一定最优吗？

我们列举一下 $m=0$ 时可能的情况：

- $1$ 个人：活下来。
- $2$ 个人：活下来。
- $3$ 个人：如果不贿赂最小的那个，就会死。
- $4$ 个人：活下来。
- $5$ 个人：变成四个可以活下来，剩余人无论如否赞成都可以活下来，因此赞成杀掉头领。
- $6$ 个人：因为只有 $5$ 号怕死会支持，因此会死。
- $7$ 个人：只有 $5,6$ 号支持，会死。
- $8$ 个人：有 $5,6,7$ 和自己支持，活下来。

因此，我们发现**怕死的人**不需要得到金币就会支持你，因此我们观察上述结论，发现形如 $2^k$ 的人数，不需要金币就能够存活。这个结论是否能够拓展呢？由于每一种情况都会递归回前面的某种情况，因此死的情况必须累计到半数之后才会进入下一个阶段，因此每次会翻倍，结论是可以推广的。

然后我们进一步考虑，如果我们有 $x$ 枚金币，就可以多按照第一种策略处理 $2x$ 个人，然后转化为 $2^k$ 的情况，进一步考量。

那么我们就很容易得出结论：能用贿赂就贿赂，不能贿赂就用零金币的方法，这是可以被理解的。那根据我们已知的结论，就可以找到最小的 $m$ 了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
signed main(){
	scanf("%lld",&n);
	int x=log2(n);
	if(n%2==0)printf("%lld\n",(n-(1<<x)>>1));
	else printf("%lld\n",(n>>1));
}
```



---

## 作者：Perfonster (赞：2)

很有意思的结论题。

不要被样例给迷惑了。我们假设$n=4$，此时第一个人肯定是赞成的，而对于$2$号成员，如果第一个人被干掉了，轮到自己分配，那么自己必死无疑，所以$2$号成员一定会无条件支持第一个人的分配，因此第一个人能够在一个钻石都没有的情况下活下去。

当 $n \geqslant 5$ 的时候，如果没有钻石，编号为$2$到$5$的成员都会反对——毕竟干到$n = 4$时他们都能活下来。

那么如果$n=5,6,7$时，第一个人就必须拿出钻石来了，所以$n=8$时可以没有钻石（$5,6,7,8$支持，否则要被干掉），同理，在$n$为$2$的正整数幂的时候，第一个人均能够在一个钻石都不拿出来分配的情况下保住性命。


当第一个人拿出$1$个钻石来时，类似地递推可以知道，$n=1...4$是可以的，$n=5$活不下去，因此$n=6$时，$2$ 号成员会无条件支持$1$号成员的方案，之后$1$号成员再将钻石给另一个人（$n=4$时不可能拿到钻石的人）就可以保住性命，进行类似的自底向上过程（$1$个钻石可以使$1$个人投赞成票，成员编号大于上一个能使得老大活下来的人数的也都要投赞成票）可知$n=10,18...$均符合要求（注意$n=8$没钻石可行并不意味着有$1$个钻石就可行，即答案不满足单调性）


归纳得知，对于一个钻石数$B$，当且仅当$1 \leqslant n \leqslant 2B$或$n = 2^k + 2B ,k\in N$
时，$1$号成员能够活下来，我们接下就是要对任意一个$n$找到最小的能使得他存活下来的 $B$。


通过简单的贪心我们就可以知道，在$n$为偶数时，去掉其二进制最高位，然后除$2$便是答案，而在奇数的时候，答案便是简单的$\dfrac{n}{2}$下取整。

看完这篇题解，不会还有人写不出代码吧，不会吧不会吧？:D

---

## 作者：_Kenma_ (赞：1)

# CF690A2 解题报告

## 前言

眼前一黑思维题（确信）。

做完估计都能当心理学专家了。

## 思路分析

感觉没有什么太好的切入点……

可能可以从小到大依次分析？

那么展现一下各位海盗的内心活动。

为了方便表述，把海盗从 $n$ 到 $1$ 排序，从 $n$ 到 $1$ 提出方案。和题面中相反，请读者注意区分。

~~长文预警。~~
### n=1

死不了。

答案为 $0$。

### n=2

投赞成票，也死不了。

答案为 $0$。

### n=3

如果 3 号死了，那么金币会被 2 号拿走，1 号拿不到。

所以只要给 1 号一枚金币，他就会投赞成票。

答案为 $1$。

### n=4

如果 4 号没有金币，并且 4 号死了，那么 3 号也得死，因为 3 号至少要一枚金币才能存活。

所以如果 4 号没有金币，那么 3 号会投赞成票保命。

答案为 $0$。

### n=5

如果 5 号死了，那么 4 号会拿走所有金币，3 号拿不到。所以只要给 3 号一枚金币，他就会投赞成票。

如果 4 号拿到金币，他会给 2 号一枚金币，所以 2 号和 4 号是一伙的。

如果 5 号死了，1 号也拿不到金币，所以只要给 1 号一枚金币，他也会投赞成票。

答案为 $2$。

### n=6

如果 6 号手里有一枚金币，并且 6 号死了，那么 5 号也得死，所以 5 号会投赞成票保命。

如果 5 号死了，4 号可以拿走金币，3 号拿不到，所以只要给 3 号一枚金币，他就会投赞成票。

答案为 $1$。

### n=7

和 $n=5$ 相似。

答案为 $3$。

### n=8

好玩的来了。

如果 8 号手里没有金币，并且 8 号死了，那么 5 号，6 号，7 号都得死，因为他们手里的金币不够。

所以这 3 个人都会投赞成票保命。

答案为 $0$。

### n=9

和 $n=7$ 相似。

答案为 $4$。

### n=10

如果 10 号手里没有金币，那么 9 号会投赞成票保命。

但是没有用，因为 8 号可以活下来，而其他海盗因为死不了，所以开始杀人，所以 10 号没有金币必死。

如果 10 号手里有一枚金币，那么 8 号就不淡定了，因为此时 6 号因为有一枚金币可以活，他不会再支持 8 号，所以 8 号为了保命也会和 9 号一起投赞成票。

这样，7号，8号，9号都会投赞成票。

因为 6 号会拿走金币，5 号拿不到。所以只要给 5 号一枚金币，他就会投赞成票。

答案为 $1$。

### n=11

和  $n=9$ 相似。

答案为 $5$。

### n=12

如果没有或者有一枚金币，12 号都会死，读者可以自己验证。

如果有两枚金币，10 号会失去 8 号的支持，所以 10 号，11 号都会投赞成票保命。

然后如果 12 号死了，8 号会拿到全部金币，所以只要分别给 6 号，7 号一枚金币，他们都会投赞成票。

答案为 $2$。

### n=13

和 $n=11$ 相似。

答案为 $6$。

### n=14

答案为 $4$，读者可以自行验证。

### n=15

和 $n=13$ 相似。

答案为 $7$。

### n=16

好玩的又来了。

如果 16 号没有金币，那么 9 号，10 号，11 号，12 号，13 号，14 号，15 号都会投赞成票保命。

答案为 $0$。

### 总结

应该分析的差不多了。

发现当 $n$ 是奇数时，因为当前人死了不会有人陪葬，所以他们不得不给 $\frac{n-1}{2}$ 个拿不到金币的人一人一枚金币，来换取他们的赞成票。

当 $n$ 是偶数时，并不是金币越多越好，有时候金币少会导致别人陪葬，从而获得这些人的保命票。

这样的人的数量变化是有周期规律的。

令 $k$ 为 $2^k\le n$ 的极大值，那么答案为 $\frac{n-2^k}{2}$。

## 代码实现

想得多了，写的就少。

```cpp

#include<bits/stdc++.h>
using namespace std;
int n,cnt;
int main(){
	cin>>n;
	if(n&1) cout<<(n-1)/2;
	else{
		while((1<<(cnt+1))<=n) cnt++;
		cout<<(n-(1<<cnt))/2;
	}
	return 0;
}

```

## 后记

心理学题。

---

## 作者：Yyxxxxx (赞：1)

## $Solution$
 - 花费为$0$  
 首先，可以通过简单的计算得出，第四个人肯定会存活且不需要任何花费。   
 于是前四人都会将第五人杀死，这样子生下来四个人就一定可以存活。      
 其次，可以进一步得出$5,6,7$号都需要花费，但是$8$并不需要，因为此时为了存活，$5,6,7,8$都会赞同，达到半数。推广地，只要$n=2^k(k\in\mathbb{N})$
 
 - 花费为$1$  
 同样地，$1,2,3,4$肯定可以，故$5$不可以通过一花费拉获得半数票，必死   
 于是$5$一定会赞成$6$ ,$6$便只需要用一花费来拉拢在前四个方案中无法拿到钻石的人就可以。   
 同样的对于任何的$n=2^k+2(k\in\mathbb{N})$都可以    
 
 - 花费为$T$       
 由上述归纳可以得出$n$可以在$T$花费下存活的条件是$1\le n \le2T\lor n=2^k+2T(k\in\mathbb{N})$   
 在$n$是偶数时用后者即去掉二进制的最高位除以二    
 在$n$时奇数时用前者即除以二下取整。      
 
 ## $Code$
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int x;scanf("%d",&x);
	if(x&1)printf("%d",(x-1)>>1);
	else
	{
		int limit;
		for(int i=1;i<=31;i++)
			if(1<<i>x)
			{
				limit=1<<(i-1);
				break;
			}
		printf("%d",(x-limit)>>1);
	}
}
```

---

## 作者：Priestess_SLG (赞：0)

首先考虑 $1$ 号海盗没有金币却仍然能存活的情况。显然可知 $n\le 2$ 的时候 $1$ 号海盗必然能存活。而当 $n=3$ 的时候，如果 $1$ 死了那么转换为 $n=2$ 的情况，$2,3$ 都可以活，那么肯定都跳反，局势 1v2 肯定 $1$ 就 g 掉了。而当 $n=4$，则若 $1$ 被公投 1v3 g 掉，那么剩下的 $n=3$ 的情况 $2$ 变成新的 $1$ 就被新的 $2,3$ 给公投 1v2 g 掉，$2$ 显然不想趋势所以肯定给 $1$ 拉一票，变成 2v2 $1$ 就可以反败为胜。因此 $n=4$ 的情况可行。

而 $n=5\sim 8$ 的情况同理。对于 $n=5$ 的情况 $1$ 如果被干掉那么 $2,3,4,5$ 都能活肯定希望 $1$ 被干，因此 1v4 $1$ 就 g 掉了。而 $n=6$ 时 $1$ 被干那么 $2$ 就变成新的 $1$ 直面 $n=5$ 的情况。因此 $2$ 会给 $1$ 拉票。而如果 $1,2$ 都被干，那么 $3$ 变成新的 $1$ 直面 $n=4$ 的情况，这个情况下 $3,4,5,6$ 都能活，因此 2v4 $1$ 还是会被 $3,4,5,6$ 给干。同理可知 $n=7$ 时是 3v4 $1$ 被干，$n=8$ 时 4v4 $1$ 可以幸存。

$n=9\sim 16$ 的情况也同样的循环，就是从 1v8 一直到 8v8，当且仅当 $n=16$ 时 $1$ 可以幸存。因此可以得到结论：

若 $n=2^k(k\in\mathbb{N})$，则 $1$ 不需要拥有任何金币就可以幸存，否则 $1$ 必然被干。

剩下 $n\neq 2^k$ 的情况。因为每一个当前的 $1$ 都肯定会自己抱着金币私吞，所以如果 $1$ 拿着一个金币贿赂某一个人，那么不管这个人一开始是跳忠还是跳反，都必然会在被贿赂后改投 $1$。因此若 $1$ 初始有 $m$ 个金币，那么直接拿着 $m$ 个金币去贿赂跳反了她的人即可，可以贿赂 $2m$ 个人并使其跳反。

很明显 $m$ 具有单调性，因此二分答案即可。时间复杂度为 $O(\log n)$，可以随便通过，然后可以发现这个东西变化的量是常数的，因此直接 $O(1)$ 数学公式计算答案即可。

```cpp
#pragma GCC optimize(3, "Ofast", "inline")
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
    cin.tie(0)->sync_with_stdio(false);
    cout << fixed << setprecision(15);
    int n;
    cin >> n;
    if ((1 << __lg(n)) == n) {
        cout << "0\n";
        return 0;
    }
    if (n & 1) cout << (n - 1) / 2 << '\n';
    else cout << (n - (1 << __lg(n))) / 2 << '\n';
    return 0;
}


```

---

## 作者：断清秋 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF690A2)

这题跟 CF690A1 的唯一区别是编号为 $1$ 的海盗可以不给自己分金币。那么显然他在任何情况下永远不会给自己金币，即海盗 $1$ 获得的金币数永远为 $0$。

那么 $n$ 为奇数的情况就十分简单了，就是 CF690A1 的结论再减去 $1$ 即可，那么答案就是 $\left\lfloor\dfrac{n}{2}\right\rfloor$。

但是 $n$ 为偶数的情况会变得相当复杂。由于没有了金币数至少为 $1$ 的限制，之前的结论就不成立了。我们考虑什么情况下金币数可以为 $0$。

$n=2$ 就不用说了，考虑 $n=4$ 的情况，此时金币数可以为 $0$。因为如果海盗 $1$ 死了，那么海盗 $2$ 必然也会死，因此海盗 $2$ 无条件支持海盗 $1$ 的决策，这样海盗 $1$ 即使一个金币都不分，他也能得到两票支持，这样他就不会死，因此 $n=4$ 时答案为 $0$。

但是 $n=6$ 时，不拿出金币是不可能的，因为海盗 $3,4,5,6$ 都会投反对票，他们必然会选择票死海盗 $1$ 和海盗 $2$，然后退化成 $n=4$ 的情况，这样大家都能活下来。

因此海盗 $1$ 必须花 $1$ 个金币收买之前投反对票的一个海盗，这样他自己，海盗 $2$（海盗 $2$ 无论如何都必须支持他）和被收买的海盗都支持他，这样就有三票支持，海盗 $1$ 就能活下来，因此 $n=6$ 时答案为 $1$。

$n=8$ 时，答案可以为 $0$，因为显然海盗 $1,2,3,4$ 都会无条件投赞成票，不然他们都会死。

可以发现，当 $n=2^k$ 时，前 $2^{k-1}$ 个海盗都会投赞成票，因此答案均为 $0$。这个证明十分容易，因为显然 $n=2^k$ 的情况等价于 $n=2^{k-1}$ 的情况，依次向下退化最终必然退化成 $n=4$ 的情况。

接下来考虑 $n≠2^k$ 的情况。我们发现，$1$ 个金币就可以获得 $1$ 个海盗的支持，那么问题变成需要获得几个海盗支持。

不妨令 $n=2^k+m$（$m$ 为偶数），因为前 $2^k$ 个人不需要考虑，那么只考虑后 $m$ 个人即可，于是显然只需要收买 $\dfrac{m}{2}$ 个人。因此答案必然为 $\dfrac{m}{2}$。

然后暴力找一下最大的 $k$ 即可。

时间复杂度 $O(logn)$。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define back return
#define ri register int
#define ull unsigned ll
using namespace std;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	back x*f;
}
ll t,n,s;
int main()
{
	n=read();
	if(n%2==0)
	{
		for(ri i=1;i<=50;i++)
			if(pow(2,i)<=n&&pow(2,i+1)>n)
			{
				n-=pow(2,i);
				break;
			}
		cout<<n/2<<"\n";
	}
	else
		cout<<(n-1)/2<<"\n";
	back 0;
}
```

---


# Mike and gcd problem

## 题目描述

Mike 有一个长度为 $n$ 的序列 $A=[a_1,a_2,\dots,a_n]$。他认为一个序列 $B=[b_1,b_2,\dots,b_n]$ 是优美的，当且仅当其所有元素的 $\gcd$ 大于 $1$，即 $\gcd(b_1,b_2,\dots,b_n)>1$。

Mike 想要对他的序列进行操作来使它变为优美的。每次操作，他可以选择一个下标 $i(1\leqslant i<n)$，删除 $a_i$ 和 $a_{i+1}$，然后把 $a_i-a_{i+1}$ 和 $a_i+a_{i+1}$ 放回这两个位置上。他希望操作次数尽可能少。如果序列可以变为优美的，你需要给出最少操作次数，否则，指出不可能。

$\gcd(b_1,b_2,\dots,b_n)$ 是最大的非负整数 $d$ 使得 $d$ 整除每一个 $b_i(1\leqslant i\leqslant n)$。

## 样例 #1

### 输入

```
2
1 1
```

### 输出

```
YES
1
```

## 样例 #2

### 输入

```
3
6 2 4
```

### 输出

```
YES
0
```

## 样例 #3

### 输入

```
2
1 3
```

### 输出

```
YES
1
```

# 题解

## 作者：JackcreaM (赞：6)

## 偶然间看到这么好的题目

## 发现居然没有一篇题解。。。

## 所以我来安利一篇别人的题解

### 原帖 [https://blog.csdn.net/mengxiang000000/article/details/71155450](https://blog.csdn.net/mengxiang000000/article/details/71155450)

题目大意：

我们有一种操作，选择两个相邻的数（Ai，Ai+1）能够将其变成：（Ai-Ai+1，Ai+Ai+1）；

我们希望最终的数组的|Gcd（A1,A2,A3,A4,A5..............）|>1.询问最少需要操作多少步。



思路：



问题的操作是在两个数的基础上进行的。

那么我们不妨只考虑两个数的操作，手写几组数据不难发现，所有写出来的两个数A.B，都会在至多两次操作内完成任务。那么我们可以考虑其性质：

两个数A.B.无非四种情况：
奇数，奇数--------------->操作后变成       偶数，偶数

奇数，偶数--------------->操作后变成       奇数，奇数

偶数，奇数--------------->操作后变成       奇数，奇数

偶数，偶数--------------->操作后变成       偶数，偶数



所以：

如果原来两个数都是偶数的话，那么操作数为0.

如果原来两个数都是奇数的话，那么操作数为1.

如果原来两个数是一奇一偶的话，那么操作数为2.



而后我们考虑结果，其最终可行解为两种情况：

①偶数 偶数的话，那么没有什么异议.

②奇数 奇数的话，只有这两个数相等且>1的话才会满足结果。

其一定不会出现结果是（3 ，6）这种情况的，除非原序列就是这样的。





那么我们不妨将问题推展到三个数，如果结果是（奇数 奇数 奇数）的话，我们肯定原来序列和结果序列是一样的，而且这三个奇数是相等且大于1的。

否则不可能有这样的结果，反之，如果结果是（偶数 偶数 偶数）的话，那么是没有异议的。

所以如果原序列的结果是>1的，那么操作数需要为0.

反之我们将原序列全部变成偶数即可。



Ac代码：

```
#include<bits/stdc++.h>
using namespace std;
int a[1555555],n,i,j,gc,ans,t;
int gcd(int x,int y)
{
	if(y==0)
	{
		return x;
	}
	else
	{
		return gcd(y,x%y);
	}
}
int main()
{
	cin>>n;
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
	}
    for(i=0;i<n;i++)
	{
		gc=gcd(gc,a[i]);
	}
    if(gc>1)
    {
        cout<<0;
    }
    else
    {
        for(i=0;i<n-1;i++)
        {
            while(abs(a[i])%2==1)
            {
                ans++;
                t=a[i];
                a[i]=a[i]-a[i+1];
                a[i+1]=t+a[i+1];
        	}
        }
        while(abs(a[n-1])%2==1)
        {
            ans++;
            t=a[n-2];
            a[n-2]=a[n-2]-a[n-1];
            a[n-1]=t+a[n-1];
        }
        if(ans)
        {
        	cout<<ans;
		}
        else
        {
        	cout<<-1;
		}
    }
    return 0;
}
```

---

## 作者：Joker_M (赞：5)

CF798C Mike and gcd problem

操作：将 $a_i$ 和 $a_{i+1}$ 变成 $a_i-a_{i+1}$ 和 $a_{i}+a_{i+1}$ ，

求使该序列的 $\gcd$ 大于 $1$ 的最小操作次数。

考虑操作之后对序列的 $\gcd$ 的影响，

发现对于 $a_i$ 和 $a_{i+1}$ ，若操作前其 $\gcd$ 为 $x$ ，

那么操作后其 $\gcd$ 只可能为 $x$ 或 $2x$，不会再增加其他质因子。

证明：

设 $x=\gcd(a_i,a_{i+1}),a_i=ax,a_{i+1}=bx$，

所以 $a \perp b$，

操作后 $a_i=(a-b)x,a_{i+1}=(a+b)x$，

则 $\gcd(a_i,a_{i+1})=\gcd((a-b)x,(a+b)x)=x\times \gcd(a-b,a+b)$，

设 $\gcd(a-b,a+b)=k,a-b=a'k,a+b=b'k$，

那么 $(a-b)+(a+b)=a'k+b'k,(a+b)-(a-b)=b'k-a'k$，

所以 $2a=a'k+b'k,2b=b'k-a'k$，

因为 $\gcd(2a,2b)=2\times \gcd(a,b)=2$，

所以 $\gcd(a'k+b'k,b'k-a'k)=k \times \gcd(a'+b',b'-a')=2$，

可得 $k=1$ 或 $k=2$，

故 $\gcd(a_i,a_{i+1})=x\times k=x$ 或 $2x$。

证毕。

若原序列的 $\gcd$ 大于 $1$ ，则不需要操作，

若原序列 $\gcd$ 为 $1$ ，由上面的分析可得，我们只能把 $\gcd$ 变成 $2$ 或其倍数。

分析一次操作对奇偶性的影响：

奇数与奇数操作，变成两个偶数；

奇数与偶数操作，变成两个奇数，再操作一次，变成两个偶数。

所以我们得到了一种贪心的策略：

扫描整个序列，对于一段连续的奇数，

先把它们两两配对进行操作变成偶数，

最后如果还剩下一个奇数，则它两边一定都是偶数，

使用两次操作把它变成偶数即可，

复杂度为 $\mathcal O(nlogn)$ ，瓶颈在于求 $\gcd$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;

const int N=105000;

int n,d,cnt,ans;
int a[N];

inline long long read(){
	long long re=0,k=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')	k=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		re=re*10+ch-'0';
		ch=getchar();
	}
	return re*k;
}

inline int gcd(int x,int y){
	if(!y)	return x;
	return gcd(y,x%y);
}

int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		d=(i==1)?a[i]:gcd(d,a[i]);
	}
	if(d>1){
		printf("YES\n0\n");
		return 0;
	}
	for(int i=1;i<=n;i++){
		if(a[i]&1)	cnt++;
		else ans+=(cnt>>1)+((cnt&1)?2:0),cnt=0;
	}
	ans+=(cnt>>1)+((cnt&1)?2:0);
	printf("YES\n%d\n",ans);
	return 0;
}
```

---

## 作者：lalaouye (赞：1)

这题好清新，好喜欢！

显然我们需要分析每一次操作的性质与带来的改变。考虑令 $x=a_i-a_{i+1},y=a_{i+1}$。那么 $\gcd(a_i,a_j)$ 将变为 $\gcd(x,x+2y)=\gcd(x,2y)$。我们先考虑 $\gcd(x,y)=\gcd(a_i-a_{i+1},a_{i+1})=\gcd(a_i,a_{i+1})$，那么 $x$ 只有可能是偶数时才会带来 $\gcd$ 的变化。所以如果我们想通过操作使得整个序列是优美的，只能将所有奇数都变成偶数才行，当然得先特判是不是初始序列就是优美的。

策略是简单的，两个奇数挨在一起直接处理，否则一奇一偶处理两次。

---

## 作者：FReQuenter (赞：1)

先从只有两个数的情况开始考虑（设为 $a$ 和 $b$）：

1. $a$ 是偶数，$b$ 是偶数时，不需要任何操作。

2. $a$ 是偶数，$b$ 是奇数时，需要两次操作：一次操作后 $a$ 变为奇数，$b$ 变为奇数，再一次操作两个数变为偶数。

3. $a$ 是奇数，$b$ 是偶数时，和第二种情况一样需要两次操作。

4. $a$ 是奇数，$b$ 是奇数时，需要一次操作，$a$ 和 $b$ 都变为偶数。

那么我们开始思考对于整个数组的操作：既然四种操作都导向偶数，那么最终整个数组都会变为偶数（因为奇数和偶数互质），除非整个数组一开始都是奇数且 $\gcd(a_1,a_2,\cdots,a_n)>2$。

所以我们可以将相邻奇数两两配对，每两个花费一次操作把他们变成偶数。如果还剩下一个奇数，那么它单独花费两次操作和旁边的偶数一起变成偶数。不会存在旁边没有偶数的情况，因为如果原数列全是奇数，要么 $\gcd(a_1,a_2,\cdots,a_n)>2$，要么换完以后会留下至少一个偶数。**这也是这道题一定会有解的原因。**


```cpp
#include<bits/stdc++.h>
#define gcd __gcd
#define MAXN 100005
using namespace std;
int n,ans,a[MAXN];
signed main(){
	cin>>n;
	int g=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		g=gcd(g,a[i]);
	}
	if(g==1){
		int i=1,j=1;
		while(i<=n){
			j=i;
			if(a[i]%2==0) i++;
			while(j<=n&&a[j+1]%2) j++;
			ans+=(j-i+1)/2;
			if((j-i+1)%2) ans+=2;
			i=j+1; 
		} 
	}
	cout<<"YES\n";
	cout<<ans;
}
```

---

## 作者：Dreamweaver (赞：1)

# Preface

GCD 好题。

# Description

给定一个 $n$ 个元素的整数序列 $a_1,a_2,...,a_n$,每次操作可以选择一个 $i$ $(1≤i<n)$，将 $a_i,a_{i+1}$ 变成 $a_i-a_{i+1}$ 和 $a_i+a_{i+1}$。

现在想要使 $a$ 序列的 $\gcd$ 大于 $1$，请计算最少的操作次数。

$2≤n≤100000$。

$1≤a_i≤10^9$。

# Solution
首先，答案一定为 YES。

若原序列 $\gcd$ 大于 $1$，则为 $0$；

否则，原序列 $\gcd$ 为 $1$:

结论：经过一次操作后 $\gcd$ 至多变大两倍。

证明：设对 $a_i$,$a_{i+1}$ 进行操作，操作后序列的 $\gcd$ 为 $d$。

$ d \mid a_i-a_{i+1}$ , $d \mid a_i+a_{i+1}$ 

$\Rightarrow$ $d \mid 2 \times a_i$ , $d \mid 2 \times a_{i+1}$

$\Rightarrow$ $d \mid \gcd(a_1,a_2,…,2 \times a_i, 2\times a_{i+1},…) $

$\Rightarrow$ $d \mid 2 \times \gcd(a_1,a_2,…, a_i,  a_{i+1},…) $。

贪心考虑，使 $\gcd$ 变为 $2$ 是最优的，就是让所有数都变成偶数。

对于两个数，有 $4$ 种情况：

偶数 偶数 $0$ 次。

奇数 偶数 => 奇数 奇数 => 偶数 偶数 $2$ 次。

偶数 奇数 => 奇数 奇数 => 偶数 偶数 $2$ 次。

奇数 奇数 => 偶数 偶数 $1$ 次。

最优方案是把所有连续的奇数段集中消灭。

假设有 $t$ 段，长度分别为 $s_1$,$s_2$,…,$s_t$，则答案为
$\sum\limits_{i=1}^t \left\lceil\dfrac{s_i}{2}\right\rceil+(s_i \mod 2)$。

# Code

代码就不放了吧 φ(>ω<*) 。




---

## 作者：ZLCT (赞：0)

# CF798C Mike and gcd problem
## 题目翻译
定义一个序列 $b$ 是优雅的，仅当 $\gcd(b_1,b_2,...,b_n)>1$。\
给定一个长度为 $n$ 的序列 $a$。每次操作可以选择 $a_i,a_{i+1}$，令 $a_i=a_i-a_{i+1},a_{i+1}=a_i+a_{i+1}$。求最小操作次数使得 $a$ 是优雅的。
### $\gcd>1\implies $ 有共同质因子
首先如果原序列已经满足条件了，那肯定直接输出 $0$ 即可，这种情况特判掉即可。\
既然只给了我们一种操作，那我们就从这个操作出发思考。
- 一次操作：$a_i=a_i-a_{i+1},a_{i+1}=a_i+a_{i+1}$。
- 两次操作：$a_i=-2a_{i+1},a_{i+1}=2a_i$。\
  诶？都出现了共同因子 $2$。

那么我们对于每一个不为偶数的情况进行两次操作就行了？\
我们注意到还有一种情况例如 $[3,5,4,6]$，我们其实只需要对 $a_1,a_2$ 操作一次就变成了 $[-2,8,4,6]$。所以我们一次一次地操作，这样才可以保证不会有浪费情况。\
事情结束了吗？当然不是。\
我们还落了一种情况：$[2,2,2,3]$，我们操作到了最后一个数字后面没有可以继续操作的数字了。很简单，我们只需要对 $a_{n-1}$ 做两次操作就行了。\
OK，那我们构造方法就结束了，但是如何保证这是最优的呢？我们来证明一下。
### 最期待的证明环节
我们现在一共有两件事需要证明：
1. 如果原序列 $\gcd$ 是 $1$，构造的新序列的 $\gcd$ 一定要是 $2$ 吗？
2. 为什么要构造 $\gcd=2$ 时这么构造一定是最优的呢？
#### NO.0
首先我们要知道新的 $\gcd$ 我们一定不会要求它是个合数（显然这是没事找事）。
#### NO.1
那么对于第一个事情，我们假设存在最优解使得 $\gcd\ne 2$，假设 $\gcd=d$，那么如果操作 $2$ 次那一定是没有意义的，因为变成 $-2a_{i+1},2a_i$，如果 $d\ne 2$ 那这就是个没有必要的操作。\
那只操作一次呢？假设 $d|a_i-a_{i+1}$ 且 $d|a_i+a_{i+1}$，考虑变化一下形式变成 $a_i-a_{i+1}\equiv0\pmod{d}$ 且 $a_i+a_{i+1}\equiv0\pmod{d}$。把 $a_i$ 移到右边就变成了 $-a_{i+1}\equiv -a_i\pmod{d}$ 且 $a_{i+1}\equiv-a_i\pmod{d}$。\
那么一个数的与它的相反数模意义下相等，思考一下会发现这只可能在 $d$ 是质数情况下存在。那我们又不会选合数，于是就只能选 $2$ 咯。\
于是第一个问题就优雅地解决了。
#### NO.2
我们再看第二个问题，假设我们遇到了一个偶数，我们的构造方法里这一步操作数为 $0$，众所周知在有理数领域目前 $0$ 是最小的，于是不可能有更优解。如果我们遇到了一个奇数，我们的操作是一步步操作看能否满足条件，所以除非不操作否则一定不会优于我们。而不操作就与 $\gcd=2$ 矛盾。\
证毕。
### 接下来就是代码时间了
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
int gcd(int x,int y){
    if(y==0)return x;
    return gcd(y,x%y);
}
int n,a[112345],gg;
signed main(){
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        gg=gcd(gg,a[i]);
    }
    cout<<"YES\n";
    if(gg!=1){
        cout<<0<<'\n';
        return 0;
    }
    for(int i=1;i<n;++i){
        if(a[i]&1){
            int x=a[i],y=a[i+1];
            a[i]=x-y;a[i+1]=x+y;
            ans++;
        }
        if(a[i]&1){
            int x=a[i],y=a[i+1];
            a[i]=x-y;a[i+1]=x+y;
            ans++;
        }
    }
    if(a[n]&1){
        ans+=2;
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：Rosent (赞：0)

[Link](https://www.luogu.com.cn/problem/CF798C)

显然在一个所有元素都为偶数的序列 $A=[a_{1},a_{2},\dots,a_{n}]$ 中，$\gcd(a_{1},a_{2},\dots,a_{n})>1$，所以我们可以将问题转化为如何用尽可能少的操作让序列里的所有元素都为偶数。

将序列上的问题转化为如何让两数 $a,b$ 转化为两个偶数。

分类讨论：

- 若 $a,b$ 都为奇数，则 $a-b$ 和 $a+b$ 都为偶数，花费 $1$ 次操作。

- 若 $a,b$ 都为偶数，花费 $0$ 次操作。

- 若 $a,b$ 一奇一偶，则 $a-b$ 和 $a+b$ 都为奇数,此时转化为 $a,b$ 都为奇数的情况，共需要 $2$ 次操作。

为什么一定是存在解的？继续分类讨论！若奇数两两存在，我们只需要将他们结合即可，否则我们只需要将两两结合后剩余的一个奇数单独花费 $2$ 次操作即可转化成偶数，故可以的，总司令！

一个小特判：如果原序列的最大公因数 $>1$ 最小操作次数一定是 $0$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100010];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cout<<"YES"<<endl;
	int g=0;
	for(int i=1;i<=n;i++)
	{
		g=__gcd(g,a[i]);
		if(a[i]%2==0) 
			a[i]=0;
		else
			a[i]=1;
	} 
	if(g!=1)
		cout<<0,exit(0);
	int cnt=0;
	for(int i=1;i<n;i++)
	{
		if(a[i]&&a[i+1])
		{
			a[i]=a[i+1]=0;
			cnt++;
		}
		if(a[i]) 
			cnt+=2;
	}
	if(a[n]) 
		cnt+=2;
	cout<<cnt;
	return 0;
}
```

---


# 1-2-3

## 题目描述

**题面**

Ilya 从事机器人制作这一行业。Ilya 为娱乐机器人编程，目前他工作的项目是 "Bob"，新一代的游戏机器人。Ilya 的老板最近想知道他的进展如何，特别是如果 Bob 比以前的 Alice 更擅长玩不同的游戏，他会对此很感兴趣。

现在，Ilya 想知道他的机器人在一个简单的叫“ 1-2-3 ”的游戏中的表现。这个游戏类似于“石头、剪刀、布”的游戏：两个机器人同时 $3}$ 中选择一个数字，如果他们选择相同的数字，那么这是平局，没有人得分。但是，如果这两个数字不同，那么其中一个机器人能得一分。$3$ 能打败 $2$，而 $2$ 能打败 $1,1$ 能打败 $3$。

这两个机器人的程序使得他们在第 $(i+1)$ 局中的选择只依赖于第 $i$ 局的选择。

Ilya 知道机器人将会玩 $k$ 局游戏，Alice 机器人将会在第一局选择数字 $a$，而 Bob 机器人会选择数字 $b$。他也知道两个机器人的程序，可以根据他们在前一场比赛中的选择来判断每个机器人会选择什么。但 Ilya 太懒了不想等到机器人把那 $k$ 局游戏玩完，所以他请你来预测在最后一场比赛后每个机器人的得分。

## 样例 #1

### 输入

```
10 2 1
1 1 1
1 1 1
1 1 1
2 2 2
2 2 2
2 2 2
```

### 输出

```
1 9
```

## 样例 #2

### 输入

```
8 1 1
2 2 1
3 3 1
3 1 3
1 1 1
2 1 1
1 2 3
```

### 输出

```
5 2
```

## 样例 #3

### 输入

```
5 1 1
1 2 2
2 2 2
2 2 2
1 2 2
2 2 2
2 2 2
```

### 输出

```
0 0
```

# 题解

## 作者：sgl654321 (赞：4)

### 题目大意
- 两个傻子 A 和 B 在玩石头剪刀布，其中 $1,2,3$ 分别代表石头，布，剪刀。
- 用 $a_{i,j}$ 表示 A 在 A 出 $i$ 这个状态，B 出 $j$ 这个状态之后他会出什么。用 $b_{i,j}$ 表示 B 在 A 出 $i$ 这个状态，B 出 $j$ 这个状态之后他会出什么。
- 问经过 $n(n\le 10^{18})$ 次石头剪刀布后双方分别赢了多少次。

### 解题思路
看到 $10^{18}$ 的数据范围，要么是 $\log$ 的算法，要么就是 $O(1)$ 的算法。两者分别对应**倍增与二分**和**寻找数学规律**。这题两种方法应该都可以。

我选用了倍增的方法进行解答。我们用 $f_{i,j,k}$ 表示 A，B 在第一次分别出 $i,j$ 这两个状态，经过 $2^k$ 次猜拳后，A 赢了多少次。$g_{i,j,k}$ 则是相应的 B 赢了多少次。

同时还要相应维护 $to_{i,j,k}$，类型是个 `pair` 数对，表示相应的，经过 $k$ 次之后，A 和 B 分别变成了哪两个状态。

转移非常显然，直接根据倍增意义即可。这里给出部分代码：

```cpp
	pair<ll, ll> tmp = to[i][j][k - 1];
	to[i][j][k] = to[tmp.first][tmp.second][k - 1];
				
	f[i][j][k] += f[i][j][k - 1];
	f[i][j][k] += f[tmp.first][tmp.second][k - 1];
				
	g[i][j][k] += g[i][j][k - 1];
	g[i][j][k] += g[tmp.first][tmp.second][k - 1];
```

那么在统计经过 $n$ 次之后双方状态时，我们只需要对 $n$
进行二进制拆分分解，加上相应的 $f$ 与 $g$ 数组的值即可。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> pll;

ll n, a[10][10], b[10][10], f[4][4][110], g[4][4][110], x, y;
pll to[4][4][110];
ll p[4][4], ans1, ans2;
int main(){
	cin >>n >> x >> y;
	
	for(int i = 1; i<= 3; i++)
		for(int j = 1; j <= 3; j++)
			cin >> a[i][j];
	for(int i = 1; i <= 3; i++)
		for(int j = 1; j <= 3; j++)
			cin >> b[i][j];		
			 
	p[1][2] = p[2][3] = p[3][1] = -1;
	p[2][1] = p[3][2] = p[1][3] = 1;
	
	for(int i = 1; i <= 3; i++)
		for(int j = 1; j <= 3; j++){
			to[i][j][0] = make_pair(a[i][j], b[i][j]);
			if(p[i][j] == 1) f[i][j][0] = 1;
			else if(p[i][j] == -1) g[i][j][0] = 1; 
		}
				
	
	for(int k = 1; k <= 70; k++)
		for(int i = 1; i <= 3; i++)
			for(int j = 1; j <= 3; j++){
				pll tmp = to[i][j][k - 1];
				to[i][j][k] = to[tmp.first][tmp.second][k - 1];
				
				f[i][j][k] += f[i][j][k - 1];
				f[i][j][k] += f[tmp.first][tmp.second][k - 1];
				
				g[i][j][k] += g[i][j][k - 1];
				g[i][j][k] += g[tmp.first][tmp.second][k - 1];
			}
		
	for(int k = 62; k >= 0; k--){
		if(n & (1ll << k)){
			ans1 += f[x][y][k]; ans2 += g[x][y][k];
			pll tmp = to[x][y][k];
			x = tmp.first, y = tmp.second;
		}
	}
	
	
	cout << ans1 << ' ' << ans2 << endl;
	
	return 0;
}

```

---

## 作者：yanghanyv (赞：3)

### 分析
我们把 $(i,j)$ 看作一个状态，表示 Alice 选择了 $i$ 而 Bob 选择了 $j$。可以发现整个游戏过程中出现的状态最多只有 9 种，且状态之间的转移是确定的。因此，游戏一定是不断循环的，我们只需要找到循环节，然后就可以求出答案。

### 进一步分析
我们虽然已经知道怎么做这道题了，但对于这道题的理解还不够透彻。  
本题的循环节究竟是怎样的？我们可以将它变成一个图，把状态作为节点，转移作为边。于是我们得到了类似于下面这个图的形状。  
![](https://cdn.luogu.com.cn/upload/image_hosting/p1wcehfo.png)  
我们可以发现，在这个图中，每个节点有且只有一条出度，且从任何一个节点出发，最后都会走到中间的环上。虽然并不是树，但我们把这种图称为**基环内向树**。  
同理，若每个节点有且只有一条入度，则称为**基环外向树**；若是一个无向图，则称为**基环树**。  
基环树的题目，大多都要先把环找出来。但找环其实并不像想象的那样简单，只有做过一遍相关题目后才能领略到关键之处。这里推荐两道关于基环树的题目：
1. [P2661 [NOIP2015 提高组] 信息传递](https://www.luogu.com.cn/problem/P2661)  较易
2. [CF1607F Robot on the Board 2](https://www.luogu.com.cn/problem/CF1607F)  较难

### 代码
最后附上本题代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll k,ansa,ansb;
int sta,stb,rs,re,rssa,rssb,resa,resb;
struct state{
	int nea,neb,sa,sb,dfn;
}s[5][5];
void dfs(int nowa,int nowb,int nowsa,int nowsb,int depth){
	s[nowa][nowb].dfn=depth;
	int nea=s[nowa][nowb].nea,neb=s[nowa][nowb].neb;
	if(nowa-nowb==1||nowa-nowb==-2){
		nowsa++;
	}else if(nowa-nowb==2||nowa-nowb==-1){
		nowsb++;
	}
	s[nowa][nowb].sa=nowsa;
	s[nowa][nowb].sb=nowsb;
	if(s[nea][neb].dfn){
		rs=s[nea][neb].dfn;
		re=depth;
	}else{
		dfs(nea,neb,nowsa,nowsb,depth+1);
	}
}//dfs找周期
int main(){
	scanf("%lld%d%d",&k,&sta,&stb);
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			scanf("%d",&s[i][j].nea);
		}
	}
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			scanf("%d",&s[i][j].neb);
		}
	}
	dfs(sta,stb,0,0,1);
	if(k<=re){
		for(int i=1;i<=3;i++){
			for(int j=1;j<=3;j++){
				if(s[i][j].dfn==k){
					ansa=s[i][j].sa;
					ansb=s[i][j].sb;
				}
			}
		}
	}else{
		for(int i=1;i<=3;i++){
			for(int j=1;j<=3;j++){
				if(s[i][j].dfn==rs-1){
					ansa=s[i][j].sa;
					ansb=s[i][j].sb;
					rssa=s[i][j].sa;
					rssb=s[i][j].sb;
				}
				if(s[i][j].dfn==re){
					resa=s[i][j].sa;
					resb=s[i][j].sb;
				}
			}
		}
		k-=rs-1;
		ansa+=k/(re-rs+1)*(resa-rssa);
		ansb+=k/(re-rs+1)*(resb-rssb);
		k%=(re-rs+1);
		for(int i=1;i<=3;i++){
			for(int j=1;j<=3;j++){
				if(s[i][j].dfn==rs+k-1){
					ansa+=s[i][j].sa-rssa;
					ansb+=s[i][j].sb-rssb;
				}
			}
		}//上面这一部分的细节很多，可以自己造一些数据模拟一下
	}
	printf("%lld %lld",ansa,ansb);
	return 0;
}
```


---

## 作者：LHLeisus (赞：3)

[原题链接](https://codeforces.com/problemset/problem/863/C)

[完美的阅读体验](https://www.cnblogs.com/LHLeisus/p/17766779.html)

- 题目给出了不同状态之间的转化关系，想到可以构成一张有向图，在 $(a,b)$ 和 $(A_{a,b},B_{a,b})$ 之间连边。但是 $k$ 的数量级十分巨大，直接跑 $k$ 个点计算答案肯定是不行的。



- 事实上状态数最多只有 $9$ 种，也就是最多只有 $9$ 个点，图上一定存在一个环。我们只需要把图拆成两部分，一部分是环外的链（可能没有），一部分是环。链上的点直接统计；对于环上的点，先算出循环一圈的贡献，再计算一共循环多少圈以及最后不满一圈还需要额外走几步。跑一圈最多走 $9$ 个点，直接统计即可。



- 连边其实没有必要，只需记录每个状态对应的编号。从 $1$ 开始，对于第 $i$ 个状态 $(a,b)$，若 $(A_{a,b},B_{a,b})$ 的编号小于 $i+1$，就找到了环。



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<utility>
#include<vector>
#include<queue>
#include<bitset>
#include<map>
#define int long long
#define FOR(i,a,b) for(register int i=a;i<=b;i++)
#define ROF(i,a,b) for(register int i=a;i>=b;i--)
#define mp(a,b) make_pair(a,b)
#define pll pair<long long,long long>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
inline int read();
typedef long long ll;
typedef double db;
const int N=1e5+5;
const int INF=0x3f3f3f3f;
int n,m,k;
int ans1=0,ans2=0;
map<pll,int>pos;
map<int,pll>pos2;
int Pos=0;
void toNum(int u,int v){
	if(pos.find(mp(u,v))==pos.end())
		pos[mp(u,v)]=++Pos,pos2[Pos]=mp(u,v);
}
int A[4][4],B[4][4];
int calcA(pll x){
	if(x.fi==x.se) return 0;
	if(x.fi==1&&x.se==3) return 1;
	if(x.fi==2&&x.se==1) return 1;
	if(x.fi==3&&x.se==2) return 1;
	return 0;
}
int calcB(pll x){
	if(x.fi==x.se) return 0;
	if(x.fi==3&&x.se==1) return 1;
	if(x.fi==1&&x.se==2) return 1;
	if(x.fi==2&&x.se==3) return 1;
	return 0;
}
signed main()
{
	k=read();
	int a=read(),b=read();
	FOR(i,1,3) FOR(j,1,3) A[i][j]=read();
	FOR(i,1,3) FOR(j,1,3) B[i][j]=read();
	int temp=0;//环和链的分界点 
	while(1){
		if(pos.find(mp(A[a][b],B[a][b]))!=pos.end()){
			toNum(a,b),toNum(A[a][b],B[a][b]);
			temp=pos[mp(A[a][b],B[a][b])];
			break;
		}
		toNum(a,b),toNum(A[a][b],B[a][b]);
		int t=a;
		a=A[a][b];
		b=B[t][b];
	}
	FOR(i,1,temp-1){//统计链上的贡献
		ans1+=calcA(pos2[i]);
		ans2+=calcB(pos2[i]);
		k--;
		if(k<=0) break;//走不到环，要及时退出 
	}
	int f=0,loop=0,ans1l=0,ans2l=0,re;
	FOR(i,1,Pos){//统计环上一圈的贡献
		if(i<temp) continue;
		if(i==temp) f++;
		if(f==2) break;
		loop++;//环长
		ans1l+=calcA(pos2[i]);
		ans2l+=calcB(pos2[i]);
	}
	re=k%loop;
	ans1l=ans1l*(k/loop);
	ans2l=ans2l*(k/loop);
	FOR(i,1,Pos){//最后剩下不满一圈的贡献
		if(i<temp) continue;
		if(re==0) break;
		re--;
		ans1l+=calcA(pos2[i]);
		ans2l+=calcB(pos2[i]);
	}
	printf("%lld %lld",ans1+ans1l,ans2+ans2l);
	return 0;
}


inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f*x;
}

```

---

## 作者：BreakPlus (赞：1)

$\large \text{Solution CF863C}$

这种题怎么能少了倍增题解……

对于这种**进行多次变换，并且下一次变换根据上一次变换结果的**题，如果变换次数较多，一般都能用**倍增**。比如，[P5151 HKE 的小朋友](https://www.luogu.com.cn/problem/P5151)。

不了解倍增的同学也可以往下看。

----

定义 $(i,j)$ 表示一个当前状态（Alice 准备出 $i$，Bob 准备出 $j$）。

我们设四个倍增数组记录：

1. $f_{i,j,k}$ 表示当前状态为 $(i,j)$，进行 $2^k$ 轮比赛后，Alice 下一局准备出的值。
2. $g_{i,j,k}$ 表示当前状态为 $(i,j)$，进行 $2^k$ 轮比赛后，Bob 下一局准备出的值。
3. $s1_{i,j,k}$ 表示当前状态为 $(i,j)$，Alice 在接下来 $2^k$ 轮中的得分。
4. $s2_{i,j,k}$ 表示当前状态为 $(i,j)$，Bob 在接下来 $2^k$ 轮中的得分。

-----

你可能会问，设它们干啥呢？不急，先解决**初始化**，也就是求 $k=0$ 时（进行 $2^0=1$ 轮比赛），四个数组的值。

1. $f_{i,j,0}=a_{i,j}$
2. $g_{i,j,0}=b_{i,j}$ （以上根据题意）
3. 如果在 $(i,j)$ 状态下，Alice 赢了，则 $s1_{i,j,0}=1$；Bob 赢了，则 $s2_{i,j,0}=1$；平局均为 $0$。

---

知道了 $k=0$ 时四个数组的值，也可以按照 $k=1,2,...$ 的顺序往下推！
（由于式子太过复杂，换一种 $\LaTeX$ 书写方式）

1. $f(i,j,k)=f(f(i,j,k-1),g(i,j,k-1),k-1)$

是不是看到这个就一头雾水了？

首先我们知道，$2^{k-1}$ 轮比赛后，状态 $(i,j)$ 变成了状态 $(f(i,j,k-1),g(i,j,k-1))$，**在这个状态的基础上**再进行 $2^{k-1}$ 轮比赛，那么 $2^{k-1}+2^{k-1}=2^k$，上面的那个式子就成功求出了 $f(i,j,k)$！

2. $g(i,j,k)=g(f(i,j,k-1),g(i,j,k-1),k-1)$

和上面的一样的道理。

3. $s1(i,j,k)=s1(i,j,k-1)+s1(f(i,j,k-1),g(i,j,k-1),k-1)$

这个式子我就不说明啦，给读者一点思考的空间（可以结合上面的理解）。

4. $s2(i,j,k)=s2(i,j,k-1)+s2(f(i,j,k-1),g(i,j,k-1),k-1)$

-----


哎呀，计算了这么多，到底有什么用？**敲重点了。**

我们设一共进行了 $K$ 场比赛，对 $K$ 进行二进制拆分，拆成 $K=2^{a_1}+2^{a_2}+2^{a_3}+...+2^{a_n}$ 的形式。

由于我们已经可以通过上面的预处理，快速模拟 $2^x$ 场比赛了。那么我们就可以对上面多项式右边的每一项依次模拟！

现在再分析一下，由于 $K\le10^{18}$，预处理倍增数组的时候，$k$ 最大取到 $\log_2(10^{18}) \approx 62$ 够了。

为了更好地让读者理解，上部分代码。

```cpp
for(ll k=62;k>=0;k--){
	if(K&(1ll<<k)){ // 如果 k 的二进制位上这一位是 1
		ans1+=s1[u][v][k], ans2+=s2[u][v][k]; // 累计答案
		ll TMPU=u,TMPV=v; // 之前的状态
		u=f[TMPU][TMPV][k], v=g[TMPU][TMPV][k]; // 倍增模拟
	}
}
```
答案就这样被统计出来了。

------

看似倍增做法比较复杂，但这题还算是套路题，很多类似题目也可以按照想倍增数组、完成初始化、想递推的方法、想统计的方法的顺序完成，我认为很有比要学会。

$\large \text{Sample Code(C++)}$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<ll,ll> PL;
ll K,u,v,a[5][5],b[5][5],ans1,ans2;
ll f[5][5][63],g[5][5][63],s1[5][5][63],s2[5][5][63];
ll pd(ll a,ll b){
    if(a==b) return 0;
    if((a==3 && b==2)||(a==2 && b==1)||(a==1 && b==3)) return 1;
    else return -1;
}
int main(){
    scanf("%lld%lld%lld",&K,&u,&v);
    for(ll i=1;i<=3;i++)
        for(ll j=1;j<=3;j++)
            scanf("%lld",&a[i][j]);
    for(ll i=1;i<=3;i++)
        for(ll j=1;j<=3;j++)
            scanf("%lld",&b[i][j]);
    for(ll i=1;i<=3;i++)
        for(ll j=1;j<=3;j++){
            f[i][j][0]=a[i][j],g[i][j][0]=b[i][j];
            if(pd(i,j)==1) s1[i][j][0]=1,s2[i][j][0]=0;
            else if(pd(i,j)==-1) s2[i][j][0]=1,s1[i][j][0]=0;
            else s1[i][j][0]=0,s2[i][j][0]=0;
        }
    for(ll k=1;k<=62;k++)
        for(ll i=1;i<=3;i++)
            for(ll j=1;j<=3;j++){
                f[i][j][k]=f[f[i][j][k-1]][g[i][j][k-1]][k-1];
                g[i][j][k]=g[f[i][j][k-1]][g[i][j][k-1]][k-1];
                s1[i][j][k]=s1[i][j][k-1]+s1[f[i][j][k-1]][g[i][j][k-1]][k-1];
                s2[i][j][k]=s2[i][j][k-1]+s2[f[i][j][k-1]][g[i][j][k-1]][k-1];
            }
    for(ll k=62;k>=0;k--){
        if(K&(1ll<<k)){
            ans1+=s1[u][v][k], ans2+=s2[u][v][k];
            ll TMPU=u,TMPV=v;
            u=f[TMPU][TMPV][k], v=g[TMPU][TMPV][k];
        }
    }
    printf("%lld %lld\n",ans1,ans2);
    return 0;
}
```

---

## 作者：MuYC (赞：1)

### 这道题目小心细节啊！！

#### 写在前面的话:

我提交了大概１６次才Ａ掉这个题，前1２次是因为没有特判循环节长度为0(相信有不少人ＲＥ是因为这个原因),也就是没有找到循环节，然后我用k去除以循环节的长度，就疯狂ＲＥ.
后面几次是因为不小心写挂了一个地方，导致死循环了。
#### 这道题的解题思路:
观察到给出的两个矩阵的大小仅有$3*3$,而且k的大小到了　$10^{18}$，当然是找循环节了！很显然，出现的情况无非就是９种:
```plain
1 1
1 2
1 3
2 1
2 2
2 3
3 1 
3 2
3 3
```
考虑用一个数组记录一下每种情况是否出现过，如果出现过，肯定是有循环节，对于循环到的每一种情况采用一个栈储存起来，然后找循环节就是不断退栈.

找到循环节把每个循环节(不超过9)的输赢情况记录下来，然后直接根据循环节长度计算就行了

注意特判循环节长度为$0$!!!ＲＥ１２次血的教训,让人想哭。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//这是一个坏习惯，但是我懒....
int a[5][5];//记录矩阵A
int b[5][5];//记录矩阵B
int k;
int A,B;
bool book[5][5];//用来记录每种情况是否出现
short tackA[25],tackB[25];//用来记录循环节
int tail = 0;
int sorceA = 0,sorceB = 0,len = 0,addA = 0,addB = 0;
int pd(int x,int y)
{
	if(x == 3 && y == 2)return 1;
	if(x == 2 && y == 1)return 1;
	if(x == 1 && y == 3)return 1;
	if(x == y)return -1;
	return 0;
}//判断输赢,用了用异或的小技巧
signed main()
{
	cin >> k >> A >> B;
	for(int i = 1 ;  i <= 3 ; i ++)
		for(int j = 1 ; j <= 3 ; j ++)
		cin >> a[i][j];
	for(int i = 1 ;  i <= 3 ; i ++)
		for(int j = 1 ; j <= 3 ; j ++)
		cin >> b[i][j];
	book[A][B] = 1;
	int z = pd(A,B);
	if(z != -1)sorceA += z , sorceB += z^1;
	k --;tail ++ , tackA[tail] = A,tackB[tail] = B;//先把初始情况入队
	while(k)//这里是找循环节　
	{
		int x = a[A][B] , y = b[A][B];
		tail ++ , tackA[tail] = x, tackB[tail] = y;
		if(book[x][y] == 1)break;//如果出现了重复的情况显然就出现了循环
		book[x][y] = 1;
		int z = pd(x,y);
		if(z != -1)sorceA += z , sorceB += z^1;//每次判断输赢
		A = x , B = y;//记录上一次的结果
		k --;
	}
	int X = tackA[tail],Y = tackB[tail];
	tail --;
	while(tail)// 退栈
	{
		len ++;
		int z = pd(tackA[tail],tackB[tail]);
		if(z != -1)addA += z , addB += z^1;
		if(tackA[tail] == X && tackB[tail] == Y)break;
		tail --;//找循环节
	}
	if(len != 0){
		sorceA += (k/len)*addA , sorceB += (k/len)*addB;
		k %= len;
	}
	while(k > 0)//此时的ｋ一定小于循环节
	{
		int X = tackA[tail] , Y = tackB[tail];
		int z = pd(X,Y);
		if(z != -1)sorceA += z , sorceB += z^1;
		k --;
		tail ++;//我退了栈，实际上元素还待在栈里面，我回溯找回元素来计算
	}
	cout << sorceA << " " << sorceB;
	return 0;
}
```


---

## 作者：憨豆Beng (赞：1)

这片题解写的真的丑 主要是 变量名用的挺乱

至于思路： 一看就是有循环的题，然后找出循环节直接计算就行了

这里用 pair 存两个人选择的 “对”， map 存谁胜出， vector 存过程
```
#include<bits/stdc++.h>
#define PI acos(-1.0)
using namespace std;
typedef long long ll;
const int maxn = 7;
ll n, ans1, ans2;
int i_, j_;
int a[maxn][maxn], b[maxn][maxn];
 
pair<int,int> t;
map<pair<int,int>, char> mp;
vector<pair<int,int> > vec;
 
void init() {
    cin>>n>>i_>>j_;
    for(int i=1;i<=3;++i)
    {
        for(int j=1;j<=3;++j)
        cin>>a[i][j];
    }
    for(int i=1;i<=3; ++i) 
    {
        for(int j=1;j<=3;++j)
            cin>>b[i][j];
    }
}
void solve() 
{
    ans1=0,ans2=0;
    int ti=i_,tj=j_;
    ll ccc=0;
    while(1)
    {
        t=make_pair(ti,tj);
        if(mp.count(t)) 
            break;
        if(ti==1&&tj==3) 
            mp[t] = 1;
        else 
        if(ti==3&&tj==1)
            mp[t] = 2;
        else 
        {
            if(ti==tj)
                mp[t]=0;
            else 
            if(ti>tj) 
                mp[t]=1;
            else mp[t]=2;
        }
        vec.push_back(t);
        int tt=ti;
        ti=a[ti][tj];
        tj=b[tt][tj];
        ccc++;
        if(ccc==n) 
            break;
    }
    int i;
    for(i=0;i<vec.size();++i) 
    {
        if(vec[i].first==t.first&&vec[i].second==t.second) 
            break;
        if(mp[vec[i]]==1) 
            ans1++;
        else 
            if(mp[vec[i]]==2) 
                ans2++;
    }
    n-=i;
    ll len=(ll)(vec.size()-i);
    ll cnt=(n/len),mod=(n%len);
    ll t1=0,t2=0;
    for(;i<vec.size()&& mod; ++i) 
    {
        if(mp[vec[i]]==1) 
        { 
            ans1++; 
            t1++;
        }
        else 
        if(mp[vec[i]]==2) 
        { 
            ans2++;
            t2++;
        }
        mod--;
    }
    for(;i<vec.size();++i) 
    {
        if(mp[vec[i]]==1) 
        t1++;
        else 
        if(mp[vec[i]]==2) 
        t2++;
    }
    t1*=cnt;t2*=cnt;
    ans1+=t1,ans2+=t2;
    cout<<ans1<<" "<<ans2<<endl;
}
int main() 
{
    init();
    solve();
    return 0;
}```

---


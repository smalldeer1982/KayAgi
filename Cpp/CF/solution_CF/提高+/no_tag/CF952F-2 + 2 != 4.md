# 2 + 2 != 4

## 题目描述

One very experienced problem writer decided to prepare a problem for April Fools Day contest. The task was very simple - given an arithmetic expression, return the result of evaluating this expression. However, looks like there is a bug in the reference solution...

## 样例 #1

### 输入

```
8-7+6-5+4-3+2-1-0
```

### 输出

```
4
```

## 样例 #2

### 输入

```
2+2
```

### 输出

```
-46
```

## 样例 #3

### 输入

```
112-37
```

### 输出

```
375
```

# 题解

## 作者：_Scaley (赞：9)

# CF952F 2 + 2 != 4
首先这道题没有翻译，这是很奇怪的，经过了（bai）查（du）字（fan）典（yi）之后，你会发现，什么用都没有……

楼下的 dalao 们给的解释非常的模糊（~~果然还是我太弱了~~），于是我自己写一篇题解，来仔仔细细得解释一下。

## 进入正题

### 题目简义：

给出一道算术表达式，按照一个特定的法则来计算这道算术表达式。


------------


### 题目分析：

在手动计算一下之后，你会发现这个运算法则其实就是将运算符的ASCLL码也当做数字计算了进去。

大约就是，你需要把这个算术表达式当做字符串读入，

按照正常的流程，应该先把这个字符串中的数字和运算符分离开，

然后通过对运算符的判断，一 一把各个位于运算符两边的数字按照运算符计算，最后输出答案。

但是这个题是与正常有区别的，

你需要在遇到一个运算符后，也就是在这个运算符之后的数字之前，把这个运算符的ASCLL码当做这个数字的第一位给计算进去。

#### 以样例 3 为例：

$$112 - 37 = 375$$

其中，当你把 112 （第一个数字）提取出来之后，下一个字符为 ‘ - ’（减），‘ - ’ 的ASCLL码为 45 ，而把这个减号当做数字来处理的话，那就需要减去字符‘ 0 ’，也就是 48。

所以第二个数字的第一位为 -3。

按照正常的将各位数字转化为一个数字的流程，-3 需要先乘 10 后加上下一位的 3 得 -27 ，然后 -27 乘 10 后加上下一位数字 7。

这样得出的第二个数字为 -263。

又因为第二个数字的前面的运算符为 ‘ - ’（减）

那么就是第一个数字减去第二个数字：112 - （-263） = 375

这就是最后结果的来由。

### 最后上代码：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#define LL long long
#define F1(i, a, b) for (int i = a; i <= b; ++i)
#define F2(i, a, b) for (int i = a; i >= b; --i) // 懒人必备
using namespace std;

char s[1001]; // 存储字符串

int main() {
	LL l, sum = 0, x = 0, flag = 1; // sum存储结果，flag存储正负
	cin >> s;
	l = strlen(s);
	F1 (i, 0, l - 1) { // 遍历字符串
		if (s[i] < '0' || s[i] > '9') { // 如果当前字符为运算符
			sum += x * flag; // 将运算符前面的数字加上
			x = 0; // 为计算下一个数字，x要清零
			if (s[i] == '+') flag = 1;
			if (s[i] == '-') flag = -1;
			x = x * 10 + (s[i] - '0'); // 将当前运算符当做数字计算进去
		}
		if (s[i] >= '0' && s[i] <='9') { // 把每一位数字转化为一个数字
			x *= 10;
			x += (s[i] - '0');
		}
	}
	sum += x * flag; // 加上最后一个数字
	printf("%lld\n", sum);
	return 0;
}

```
希望解释明白了

---

## 作者：SunLegend (赞：7)

这道题作为蓝题实在简单了点……

这道题并没有中文翻译，提供自行翻译：
```
题目描述
一位经验丰富的出决定为愚人节竞赛准备一道题。任务非常简单——给定一个算术表达式，返回计算该表达式的结果。但是，参考解决方案中似乎存在错误。

输入格式
输入数据的唯一一行包含算术表达式。表达式将包含2到10个操作数，用算术符号加号或减号分隔。每个操作数都将是一个介于0和255（含0和255）之间的整数。

输出格式
如样例运算算法，计算对于输入而言的该算法运算结果
```
其中提到了“**错误**”二字，且根据标题可以看出，该运算与普通运算不同。

那么这个算法是怎么进行的呢？只能通过找样例规律得出结论：  
1. 样例1：看着跟正常计算一模一样，暂时跳过。
2. 样例2：正常情况2+2=4，比样例多50。
1. 样例3：正常情况112-37=75，比样例少300。

不难发现，末尾0的个数取决于后面数的位数，除开0又发现：
1. **3**+**字符‘+’的ASCII码值**=**字符‘0’的ASCII码值**
2. **5**+**字符‘-’的ASCII码值**=**字符‘0’的ASCII码值**

所以运算符号是被看作与下一个数一起运算的！  
如：（等号后为正常的符号）  
2+2=2+(-5)\*10+2=46  
112-37=112-(-3)\*10-37=375

注意：**加法就是符号算得减号，后面的数算得加号；减法完全相反。** 另外，综合算式计算时每个符号只关联到下一个数，而不是后面的所有数。

附上完整注释代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
string a;
int quan=1,ans,ans1;//quan是权值，如231中，1权值为1，3权值为10，2权值为100 
int main()
{
	cin>>a;
	for(int i=a.size()-1;i>=0;i--)//逆序循环是因为可以让每个数从个位开始操作，能直接确定一个数某一位的权值 
	{
		if(a[i]!='+' && a[i]!='-')//数字 
		{
			ans1+=quan*(a[i]-'0');//暂时不确定正负，先用ans1累加
			quan*=10;//下一位 
		}
		else if(a[i]=='+')
		{
			ans+=quan*(-5)+ans1;//一负一正 
			quan=1;//下一个数 
			ans1=0;
		}
		else
		{
			ans+=quan*3-ans1;//一正一负 
			quan=1;
			ans1=0;
		}
		
	}
	ans+=ans1;//第一个数前没有符号，但肯定要加 
	cout<<ans;
	return 0;
}

```


---

## 作者：Marsrayd (赞：4)

> 超级毒瘤愚人节玄学题？？？

## [题目传送门](https://www.luogu.com.cn/problem/CF952F)

## 题意简述

按照样例的方式计算题目给出的表达式的值？？？

## $\texttt{SOLUTION}$

首先我们来看一下样例：

- 样例一：$8-7+6-5+4-3+2-1-0=0=0(\text{正常运算中表达式的值})+0$
- 样例二：$2+2=-46=4(\text{正常运算中表达式的值})-5\times 10^1$
- 样例三：$112-37=375=70(\text{正常运算中表达式的值})+3\times 10^2$

看到这我们发现 $0,50,300$ 这些数都很有规律，于是开始思考：他们是怎么来的呢？

首先看样例一的式子，它的值为 $4$ ，十分正确，再对比样例二和样例三。

发现只有样例一中的 $+$ 号和 $-$ 号个数相同。

于是我们下意识的从符号下功夫。

作为一个合格的 $\text{OIer}$ 你一定对字符的 $\texttt{ASCII}$ 十分熟悉吧。

我们~~翻了翻  $\sout{\texttt{ASCII}}$ 编码表~~发现 $-$ 的  $\texttt{ASCII}$ 编码为 $45$ ，个位数为 $5$， $+$ 的  $\texttt{ASCII}$ 编码为 $43$ ，个位数为 $3$。

然而，样例二却是 $-$ $\color{red}5$ $\times 10^1$ ，样例三是 $+$ $\color{red}3$ $\times 10^2$，加红的数刚好与 $+$ 号 $-$ 号的 $\texttt{ASCII}$ 的个位数反过来了，而数之前的符号也与 $+$ $-$ 反过来了。

又发现
- $10^1$ 中的 $1$ 就是 $2$ （$+$ 号后数字）的位数。
- $10^2$ 中的 $2$ 就是 $37$ （$-$ 号后数字）的位数。

于是我们就猜出了结论：按照正确计算方法计算完毕原式的值后，对于每个符号 $+$， 减去 $3\times 10^{+ \text{后数字的位数}}$。对于每个符号 $-$， 加上 $3\times 10^{- \text{后数字的位数}}$。

快速的打完了代码。

A?

A了。

真是不可思议！！！

至于为什么 $+$ 是减去 “ $3$ ” 而 $-$ 是加上 “ $5$ ”，参考了其他题解，原来并不是因为把 $\texttt{ASCII}$ 的个位数反过来，而是把符号也当做数字来看，$0$ 的 $\texttt{ASCII}$ 为 $48$ 而 $|43-48|=5$，$|45-48|=3$ ，所以 $+$ 是减去 “ $3$ ” 而 $-$ 是加上 “ $5$ ”。

$\texttt{AC CODE}$

```cpp
#include<bits/stdc++.h>
#define IN inline
const int N=100010;
int n,ans;
char str[N];
int main()
{
	scanf("%s",str+1);
	n=strlen(str+1);
	int i=1;
    while(str[i]>='0'&&str[i]<='9'&&i<=n)//第一个数没有符号，特判
    {
        ans=ans*10+str[i]-'0';//存储每个符号之后的数字的值 
        ++i;
    }
	while(i<=n)
	{
		if(str[i]=='+')
		{
			int ws=0,num=0;
			++i;
			while(str[i]>='0'&&str[i]<='9'&&i<=n)
			{
				++ws;//存储每个符号之后的数字位数 
				num=num*10+str[i]-'0';//存储每个符号之后的数字的值 
				++i;
			}
			ans=ans-5*std::pow(10,ws)+num;
		}
		else if(str[i]=='-')
		{
			int ws=0,num=0;
			++i;
			while(str[i]>='0'&&str[i]<='9'&&i<=n)
			{
				++ws;//存储每个符号之后的数字位数 
				num=num*10+str[i]-'0';//存储每个符号之后的数字的值 
				++i;
			}
			ans=ans+3*std::pow(10,ws)-num;
		}
	}
	printf("%d",ans);
	return 0;
}

```


$\text{P.S}$. ~~这题难度**严重恶评**，这思维难度至少紫题吧！！！~~

---

## 作者：Shunpower (赞：3)

## 思路

首先把题干丢进翻译，发现并没有什么作用。

### 1.1 题目意义的分析

所以可以分析一下 $2+2=-46$ 的小样例看能不能从中得到什么信息。


利用简单的数学计算出 $2+2=4$，和我们需要的答案差了 $50$。所以可以这样想，在这个题目里 $+2$ 等同于 $-48$。

恰好，$-48=-50+2$，所以考虑多出来的 $-50$ 是哪里来的。

转变一下思路可以想到这个 $-48$ 相当于一个十位为 $-5$，个位为 $2$ 的数。

所以考虑这个 $-5$ 从哪来的。在刚刚的推导中，第二个 $2$ 已经被用了，所以这个 $-5$ 应该是从那个加号来的。

很容易想到要把字符对应到数，是 ASCII 码。而加号的 ASCII 码是 $43$。突然想到 $0$ 的 ASCII 码是 $48$。

所以题目是**把符号当成了数字加入计算**，在普通的计算表达式值的过程中，从字符串转到数时要把符号减去 $48$ 得到的数作为最高位，就像处理普通的数字一样。当然如果前面的符号是加号，就加上我们处理出的数，是减号就减去我们处理出的数。

### 1.2 代码思路的分析

普通的表达式求值是遇到字符串中的数，就把数变成 $\texttt{int}$ 加入计算，所以我们可以采取换汤不换药的方法，遇到一个数，先判断前面的符号，将记录数值的变量赋初值为前一个符号的 ASCII 码减掉 $48$ 的值（而不是 $0$）。

这是唯一的不同。其他就是正常的表达式求值。

## 代码

### 2.1 初始处理

因为我们是遇到数就往前看符号，而第一个数前面并没有符号，所以首先把第一个数取出来。

要用一个变量记录第一个数的长度，因为下一步操作要从第二个数开始。

最后记得把存数值的变量清空。

```
for(int i=0;i<s.length();i++){
	if(s[i]>='0'&&s[i]<='9'){
		sum*=10;
		sum+=s[i]-'0';//非常正常的字符串转数
		k=i;//下一步操作要从下一个数开始，所以记录第一个数的长度
	}	
	else{//我们只需要第一个数
		break;
	}
}
ans=sum;
sum=0;
```


### 2.2 处理字符串中单数的值

首先要判断这个位置是一个数字，这个不用多说。

接着要看是什么符号以分开处理。当前面的符号是加号的时候初值就是 $43-48$；是减号的时候初值就是 $45-48$。为了不打成两个`if`把中间相同的字符串转数部分写两遍，可以使用三目运算符。因此我们可以把给存数变量赋初值的部分写成：
```
sum=(s[i-1]=='-'?'-':'+')-'0';
```
还可以把最后给总答案加减值的部分写成：
```
s[f-1]=='-'?ans-=sum:ans+=sum;
```
（因为我们要在字符串转数的时候改变原本的 $i$，所以用 $f$ 存这个数开始的位置）

中间则是一个字符串转数的模板：

```
for(int j=i;j<s.length();j++){
	if(s[j]>='0'&&s[j]<='9'){
		sum*=10;
		sum+=s[j]-'0';
		i=j;//来一个数字往后面动一位，直到没有数字的时候，i 将会指向这个数后面的符号的前一个位置，而外层循环还有一个 i++。
	}
	else{//我们只要数，不要符号
		break;
	}
}
```

## AC 记录

代码不放了，防止抄题解，而且文章里面都给的很明白。

[AC 记录](https://www.luogu.com.cn/record/58691983)



---

## 作者：WCG2025 (赞：2)

为CF~~水题~~写题解



------------

首先这道题没有翻译，是十分的烦（那是因为不需要），因为这道题是一道愚人节题目！出题人就是从[BF Calculator](https://www.luogu.org/problemnew/show/CF784G)
这道题得到的灵感，具体运算规则就是从[brainfuck](https://en.wikipedia.org/wiki/Brainfuck)这种语言来的

先说2+2=-46这个样例吧，首先2的确等于2，但‘+’-‘0’=-5，要把这个-5代入下一步的运算中去，即2+-5*10+2=-46

如果还没有懂，就在代码中去看
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    char ch=getchar();
    int x=0,f=1;
    while(ch<'0'||ch>'9')
    {
       if(ch=='-') f=-1;
       ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
       x=x*10+ch-'0';
       ch=getchar();
    }
    return x*f;
}
char a[100];
int len;
long long res=0,cur=0;
int sign=1;
int main()
{
    scanf("%s",a);
    len=strlen(a);
    for(int i=0;i<len;i++)
    {
        if(a[i]=='-'||a[i]=='+')//每一次运算都是以运算符为
        {                       //一个节点
            res+=sign*cur;
            cur=0;
        }
        if(a[i]=='-')//如果为-，sign变为-1
        sign=-1;
        if(a[i]=='+')//如果为+，sign变为+1
        sign=1;
        cur=cur*10+a[i]-'0';//将这一节点的值*10后加上该点自己的值
    }
    res+=sign*cur;//这一步要注意，因为不加的话最后一个节点的值就加不了
    printf("%lld",res);
    return 0;
}

```
~~毒瘤~~CF

---

## 作者：OLE_OIer (赞：0)

这是一道非常考验大家思维的题。大家看我们的样例数据：

    2+2=-46
发现了什么？$2+(-48)=46$ 。而且 $-48$ 等于 $(-50)+2$ 。

于是，我们就可以猜 $+$ 就等于 $-5$ 。

而事实上就是这样。这道题其实将 $+$ 与 $-$ 当成了数字，但他们又具有加减符号的运算性质。

$+$ 在ASCII码中是 $43$ ，而且 $0$ 在ASCII码中是 $48$ ，所以在数字中，$+$ 代表 $-5$ ；$-$ 在ASCII码中是 $45$ ，所以在数字中，$-$ 代表 $-3$ 。

知道了这几点之后，我们就可以很快地写出代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,tmp;
int main(){
	char c;
	char prev='+';//存储上一个符号，一定要存储为加号！
	while(cin>>c){
		//处理数字：
		if('0'<=c&&c<='9') tmp=tmp*10+c-'0';
		//处理符号：
		else if(c=='+'||c=='-'){
			if(prev=='+') ans+=tmp;
			else ans-=tmp;
			prev=c;
			tmp=c-'0';
		}
		//做一个特判：
		else break;
	}
	//最后还有一次更新答案！
	if(prev=='+') ans+=tmp;
	else ans-=tmp;
	cout<<ans;
	return 0;
}
```

---


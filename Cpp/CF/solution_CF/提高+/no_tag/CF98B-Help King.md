# Help King

## 题目描述

### 题目背景

很久很久以前，一个遥远国度的公主$\mathtt{Victoria}$ 快乐地过着王室生活，但是有一天就不快乐了：恶龙袭击了王国，带走了可爱的 $\mathtt{Victoria}$。国王悲痛欲绝，他迅速喊来皇家骑士，有谁能从这个地狱猛手中救回 $\mathtt{Victoria}$，就把王国一半的土地和赏赐给他，并让公主嫁给这位勇士。

冒险途中，骑士们发现了恶龙的巢穴，奋不顾身地冲过去救 $\mathtt{Victoria}$。每个骑士都向罪大恶极的龙啐了一口（什么离谱攻击方式），可怜的龙因脆弱的心碎了而倒地。那些骑士将 $\mathtt{Victoria}$ 送到国王那儿，然后就不要脸地吵起来了，他们都想娶可爱的 $\mathtt{Victoria}$。

问题是所有骑士都一模一样，很高贵，很英俊，$\mathtt{Victoria}$ 却不想嫁给任何一个骑士。然后聪明的国王不想伤了任何人的感情，决定用抛硬币的方式随机挑一个骑士。


国王决定用抛硬币的方式随机挑一个骑士。坏消息是，有 $n$ 个骑士，硬币却只有两面。好消息是，抛完硬币，每一面朝上的概率是相等的。国王很好奇如何用硬币以相等的概率选出一位骑士(此概率应该始终等于 $\dfrac1n$)。

首先，国王想知道他需要抛多少次硬币来选出赢家。此外，在抛硬币时，国王应该遵循最佳抛硬币策略(即使抛硬币的期望次数最小的策略)。请你帮助国王完成这个具有挑战性的任务。

## 样例 #1

### 输入

```
2
```

### 输出

```
1/1
```

## 样例 #2

### 输入

```
3
```

### 输出

```
8/3
```

## 样例 #3

### 输入

```
4
```

### 输出

```
2/1
```

# 题解

## 作者：yingkeqian9217 (赞：0)

# 题目描述

有无穷个硬币，可均匀随机生成 $0$ 或 $1$，要求构造一种方法，生成 $0$ 到 $n-1$ 的随机整数，求最小期望抛硬币次数。

样例解释：样例 1,3 中 $n=2^k$，此时期望显然为 $k/1$；样例 2 中 $n=3$，我们给出如下构造：

首先抛两次硬币，生成两个 0/1，若结果为 `1`，则重新抛；否则取对应数，即若到 `00` 取 0，`01` 取 1，`10` 取 2，显然公平。计算期望次数，每轮抛两次，成功率 $\frac{3}{4}$，期望 $\frac{4}{3}$ 轮，共 $\frac{8}{3}$ 次。

# 分析

## Step.1

注意到当 $n=2^k$ 时，显然可以通过 $k$ 次抛硬币解决，直接输出。无法通过样例。

进一步地，根据样例 2，可以给出类似的构造：对于 $n\not = 2^k$，找到一个最小的 $k$ 使 $n\le 2^k$，然后抛 $k$ 次，若不为 $0$ 至 $n-1$ 的数，则重抛，类似可以计算次数得期望为 $\dfrac{k\times 2^k}{n}$。

你觉得这个看起来很对，于是自信地提交了代码，结果 "Wrong answer on test 6"。

## Step.2

进一步地，我们发现当 $n$ 含有 $2$ 因子时，我们没有必要抛 $2^k$ 次，而是可以先通过分组除掉 $n$ 的 $2$ 因子，记 $n=2^p\times n'(n'\not =0)$ 且 $2^{k-1}<n'\le 2^k$，可以得到 $p+\dfrac{k\times 2^k}{n'}$ 的做法。期望过点："Wrong answer on test 8"。

## Step.3

通过读数据，得到 $n=5$ 时，答案为 $\dfrac{18}{5}$ 而不是理论的 $\dfrac{24}{5}$，这启发我们如何优化做法。

重新回顾我们做法的本质，显然 $k$ 次无法解决 $n>2^k$ 的问题，这是因为 $k$ 次抛硬币得到的状态不足以给 $n$ 平分；另一方面，我们的做法之所以在 $n=5$ 时错误，是因为其 $2^k-n=3$ 较大，有较大概率重抛，反之，当 $n=7$ 时，$2^k-n=1$ 较小，我们的做法是正确的。

考虑进一步的判定，具体地，我们每次计算重抛情况数，如果情况数为 $1$，无法更优，直接计算；如果情况数不为 $1$，我们继续抛硬币而不是直接进入循环。

换一种说法，我们做法的本质就是考虑一颗“决策二叉树”，每次抛硬币就是选择左或右儿子往下走（如图，$n=3$）。我们需要确定一些同深度的点为叶子，保证每层 $n$ 个叶子同时出现，图中记为 `x`。

```
         o
     /      \
    o        o
  /   \    /   \
 x     x  x     o
              /   \
             o     o
           /   \ /   \
          x    ...   ...
```

对于这个无穷大小的二叉树，显然在如下构造下有 $100\%$ 的概率走到叶子，我们要求的就是构造树使得根走到叶子的期望步数最小。我们贪心地取叶子，计算当前叶子数，若多余 $n$ 则依次分配为叶子，否则不变，每次增加深度时，需要将令当前叶子数为上一层多余叶子数的两倍，递归构造。直至本层只有 $1$ 个多余节点，与根构成循环。

这样显然是最优的构造，因为取更高的叶子时不劣的，且构成循环后只会重复一次，不会出现之前 $n-5$ 时重抛次数多的情况。可以证明这样时间复杂度是正确的，对于其他详细证明见 `Ex.` 部分。

于是我们可以暴力模拟建树过程，考虑计算期望。参考之前的构造方式，我们通过期望轮数乘每轮期望次数计算，详细的代数推导见 `Ex.` 部分。

记循环节的树高为 $D$，每个叶子的深度为 $d_i$，深度从 $0$ 开始。由于走一遍只有一个叶子需要循环，所以成功概率为 $\dfrac{2^D-1}{2^D}$，期望 $\dfrac{2^D}{2^D-1}$ 轮。

每轮的期望步数可以直接用期望的定义计算 $E_1=\sum \dfrac{d_i}{2^{d_i}}+\dfrac{D}{2^D}$，最后一项是因为需要将循环点也视为一个叶子。将二者相乘，得期望步数为 $\dfrac{D+\sum d_i\times 2^{D-d_i}}{2^D-1}$，直接计算即可。

注意我们开始时去掉了 $n$ 的 $p$ 个 $2$ 因子，此时应该加上，得到最终答案为 $\dfrac{(2^D-1)p+D+\sum d_i\times 2^{D-d_i}}{2^D-1}$，注意判断 $n=2^k$ 的情况。

其实这里开始去掉因子的本质就是给决策树了一个开始深度为 $p$ 的非循环节，可以视为将所有 $2^p$ 个子树深度 $+p$。

于是，这道题就做完了……吗？

## Step.4

没错，作为一道年代比较久远的题，这道题需要开高精，因为 $2^D$ 极大。当然你也可以使用优美的 python，这里给出的是 C++ 做法，常数需要进行一些优化。

- 即时取模：计算树高时，乘完立刻取模，就不需要高精存了，只需要记录下叶子深度和总深度即可。

- 预处理 $2^k$：使用高精乘非高精的写法，比较快。

- 求 $\gcd$：这里使用每次除去 2 的因子的优化，因为高精判是否为偶数是快速的；同时此时没有必要取模，只要进行减法仍然能使复杂度正确。

- 高精计算：压位，数组开小一点，除法和取模进行二分求解。

笔者没有测试过以上优化是否均必要，读者也可以根据自己的习惯写，参考此处的优化即可。

# Code

这里省略了高精度模板，读者可以自己查询相关模板，~~或者使用 python 实现~~。

空间复杂度 $\Theta(n)$，时间复杂度约为 $\Theta(n^2 \log n)$，都有一个 $\log_w 2$ 左右的常数，具体取决于高精度写法，$w$ 为压位位数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000;
struct Int{
	...//模板
}ans,bas[10005];
Int gcd(Int x,Int y){
	int cnt=0;
	if(y<x) swap(x,y);
	while(!(x==0)){
		while(!(x.a[0]&1)&&!(y.a[0]&1)){
			x=x/2,y=y/2;
			cnt++;
		}
		while(!(x.a[0]&1)) x=x/2;
		while(!(y.a[0]&1)) y=y/2;//除去二因子结合减法实现最大公因数
		if(y<x) swap(x,y);
		y=y-x;
	}
	while(cnt--) y=y*2;
	return y;
}

int n,m;
void init(){
	bas[0]=1;
	for(int i=1;i<=N;i++) bas[i]=bas[i-1]*2;
}
signed main(){
	init();
	int res=0,dep=0;
	scanf("%d",&n);
	while(n%2==0) n/=2,res++;
	if(n==1) return printf("%d/1",res),0;
	vector<int>vec;
	for(int i=2;;i<<=1){
		dep++;
		if(i>=n) vec.push_back(dep),i-=n;
		if(i==1) break;//朴素建树
	}
	Int y=bas[dep]-1;
	ans=y*res+dep;
	for(int i:vec) ans=ans+bas[dep-i]*i*n;//根据式子计算即可
	Int g=gcd(ans,y);ans=ans/g,y=y/g;
	ans.print(),putchar('/'),y.print();
	return 0;
}
```

# Ex.

- 关于构造存在性以及时间复杂度的证明：等价于求 $2^k\equiv 1 \mod n'$，由于 $\gcd(n',2)=1$，所以由欧拉定理，存在解 $k=\varphi(n)$，得证。由于本质为求离散对数，所以存在 $O(\sqrt {\varphi(n)} \log n)$ 以及更优的求循环节的树高方法（笔者不会数论，勿喷），直接暴力也是 $O(\varphi(n))$ 的。

- 关于期望步数的计算：记所有叶子的 **实际** 深度为 $d'_i$ 其他同上，显然 $\sum 2^{-d_i}+2^{-D}=1$，得

$$E=\sum_i d'_i\times 2^{-d'_i}$$

$$E=2^p\times \sum_i\sum_{j} (p+d_i+jD)\times 2^{-(d_i+p+jD)}$$

$$E= \sum_i2^{-d_i}(p\sum_j 2^{-jD}+d_i\sum_j 2^{-jD}+\sum_{j} jD\times 2^{-jD})$$

$$E=p\times \sum_i \dfrac{2^{-d_i}}{1-2^{-D}}+\sum_i \dfrac{2^{-d_i}d_i}{1-2^{-D}}+\sum_i \dfrac{2^{-d_i}D\times 2^{-D}}{(1-2^{-D})^2}$$

$$E=p+\dfrac{\sum 2^{-d_i}d_i}{1-2^{-D}}+\dfrac{2^{-D}D}{(1-2^{-D})^2}\times(1-2^{-D})$$

$$E=\dfrac{(2^D-1)p+\sum d_i\times 2^{D-d_i}+D}{2^D-1}$$

与上文一致，证毕。

- 关于问题的拓展：对于任意的 $m$ 面硬币，是否可以得出类似结论？是否仍然可以贪心构造？由于笔者比较菜，不会证明，读者可以自己查阅相关资料，这里只随便给一个构造，不知道对不对：

1. $\gcd(m^{\infin},n)=n$，树有限，容易完成。
2. 否则，由于扩展欧拉定理，树一定是一个非循环节加上循环节，可以尝试暴力构造，建树复杂度不变，为 $O(\varphi(n))$。

---


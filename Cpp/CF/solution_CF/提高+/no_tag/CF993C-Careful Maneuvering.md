# Careful Maneuvering

## 题目描述

## 题目背景

我方的两架小战斗机被敌方的两组大战斗机包围了。


敌方的战斗机分为两组，其中一组  $x$  坐标为  $-100$ ， $y$  坐标各不相同。另一组  $x$  坐标为  $100$ ， $y$  坐标各不相同。我方的战斗机始终保持在  $x$  坐标为  $0$  的位置。

某一刻，敌方的所有战斗机会发射两束激光，分别射向我方的两架战斗机，幸运的是，我方的战斗机都能灵敏避开，而激光继续传播，还可以将敌方战斗机击落。

作为我方战斗机的指挥部，你需要告诉我方战斗机分别应该待在哪里，好让激光射落的敌方战斗机最多。而现在你只要输出这个最大值。

我方的两个战斗机可以待在同一个位置，敌方的某两辆战斗机也可以在同一位置。

## 说明/提示

- 第  $1$  组样例的解释：

让我方一架战斗机待在  $(0,\ 2)$ ，另一架待在  $(0,\ 7)$ 。到时机避开激光，激光能射落  $9$  架敌方战斗机。

- 第  $2$  组样例的解释：

让我方一架战斗机待在  $(0,\ 3)$ ，另一架可以自由翱翔。到时机避开激光，激光能射落所有敌方战斗机，即  $10$  架。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
3 9
1 2 3
1 2 3 7 8 9 11 12 13
```

### 输出

```
9
```

## 样例 #2

### 输入

```
5 5
1 2 3 4 5
1 2 3 4 5
```

### 输出

```
10
```

# 题解

## 作者：1234567890sjx (赞：0)

Duel 到的。感觉很没难度。

考虑什么时候对方的战斗机会被摧毁。显然若我方的某一台战斗机在对方两台战斗机所连接得到直线上时，这两台战斗机会被互相摧毁。发现 $n,m$ 很小，所以直接枚举所有这样的位置，计算若这里有一台我方的战斗机，则有哪些敌方战斗机会被摧毁。这个地方可以状压一下下标。

然后再枚举我方战斗机所处的两个位置（显然只有可以摧毁对方战斗机的 $O(nm)$ 个位置才会被选中），计算有多少个对方战斗机会被摧毁即可。时间复杂度为 $O(n^2m^2)$ 加上哈希的复杂度。

如果 wa $82$：注意我方两台战斗机可能重合。

```cpp
int a[N], b[N];
unordered_map<int, int> m1, m2, mp, pm;
void run() {
    int n = read(), m = read();
    for (int i = 1; i <= n; ++i) a[i] = read(), ++m1[a[i]];
    for (int i = 1; i <= m; ++i) b[i] = read(), ++m2[b[i]];
    vector<int> buc;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            int k1 = a[i] + b[j];
            buc.eb(k1);
            mp[k1] |= (1ll << (i - 1));
            pm[k1] |= (1ll << (j - 1));
        }
    sort(buc.begin(), buc.end());
    buc.erase(unique(buc.begin(), buc.end()), buc.end());
    int mx = 2;
    for (int i = 0; i < buc.size(); ++i)
        for (int j = i; j < buc.size(); ++j)
            mx = max(mx, (int)__builtin_popcountll(mp[buc[i]] | mp[buc[j]]) + (int)__builtin_popcountll(pm[buc[i]] | pm[buc[j]]));
    cout << mx << '\n';
}
```

---

## 作者：xiaorui2007 (赞：0)

## 引理
首先，显然，我方战斗机的位置对答案有贡献，当且仅当它在两架敌机连线上。由于：
>敌机一组 $x$ 坐标为 $-100$，另一组 $x$ 坐标为 $100$，我方的战斗机 $x$ 坐标为 $0$。

故我方的战斗机在两架敌机连线中点上。
## 思路
我们可以枚举第一组中的一架敌机，和第二组中的一架敌机，求出所有有贡献的点，再从中选两个点（可重），计算每组点的贡献。  
时间复杂度为 $O(m^2n^2)$，还有一个大约为 $\dfrac{1}{2}$ 的常数。
## 实现方法
由于求中点时有$\times\dfrac{1}{2}$的计算，$y$ 坐标有正负，根据 $|y|\le10000$，可以用 $2y+20000$ 代替原先的 $y$，再处理，此时 $0\le y\le40000$。  
于是可以手写一个 map，给每个点一个编号（说实话，我个人并不喜欢 STL 的 ```map```，有个较大的常数，能手写就手写）。  
用两个```long long```记录每个贡献的点能击落的敌机。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,y[2][65],mp[40005],cnt,ans;
long long s[2][3605];

int count1(long long x)//计算long long中1的个数
{
	int ans=0;
	for(;x;ans++,x&=(x-1));
	return ans;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>y[0][i];
		y[0][i]=y[0][i]*2+20000;//预处理
	}
	for(int i=1;i<=m;i++)
	{
		cin>>y[1][i];
		y[1][i]=y[1][i]*2+20000;//预处理
	}
	for(int i=1,t;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			t=(y[0][i]+y[1][j])/2;
			if(!mp[t])
				mp[t]=++cnt;
			s[0][mp[t]]|=(1ll<<(i-1ll));
			s[1][mp[t]]|=(1ll<<(j-1ll));//记录贡献
		}
	for(int i=1;i<=cnt;i++)
		for(int j=i;j<=cnt;j++)
			ans=max(ans,count1(s[0][i]|s[0][j])+count1(s[1][i]|s[1][j]));//用|是为了去重
	cout<<ans<<endl;
	return 0;
}
```

---


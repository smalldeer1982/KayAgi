# Journey

## 题目描述

兔子Stewie发现了一个新的平行宇宙。这个宇宙是二维的且是矩形网格，包含n行，m列。它是非常小的：网格的一个格子只能包含一个粒子。这个宇宙中的每一个粒子要么是静态的，要么是动态的。每个静态粒子总是保持在同一位置。由于莫名其妙的引力定律，平行宇宙中没有两个静态粒子存在于一行或一列中，也不可能存在于其它静态粒子的左上，左下，右上，右下的4个格子中。一个动态粒子出现在一个随机的空格子中，随机地选择目的格子（目的格子可能与起始格子重合，请看样例），并沿着最短的路径移动到没有被静态粒子占据的目标格子中。所有空格子被选择为路径的开始或结束的概率是相同的。到达目标格子后，粒子消失。在同一个时刻只允许有一个动态粒子存在。每个移动过程中，这个粒子必须从一个格子移动到相邻的一个格子，这个过程需要一个银河秒。Stewie对宇宙中一个粒子的平均寿命感兴趣。


------------

## 样例 #1

### 输入

```
2 2
..
.X
```

### 输出

```
0.888888888889
```

## 样例 #2

### 输入

```
3 3
...
.X.
...
```

### 输出

```
2.000000000000
```

# 题解

## 作者：Peter0701 (赞：10)

给定一张 $n \times m$ 的网格图，其中有障碍，每行每列不超过一个，每个障碍周围 $8$ 格无障碍。求任选两个无障碍点之间路径的期望长度。

考虑推一下路径期望长度的式子：设无障碍点为“好点”，有障碍点为“坏点”，两个不同“好点” $i$ 和 $j$ 之间的距离为 $d(i,j)$ 。“好点”总数为 $p$ 。则路径期望长度 $= \frac{\sum_{i=1}^p \sum_{j=1}^p d(i,j)}{p^2}$ 。

然后推两个不同“好点”间距离：对于大部分“好点”，两点间距离就是其曼哈顿距离。而对于如下图中的 $A$ 点和 $B$ 点（左边的“好点”同行右侧有“坏点” $1$ 、右边的“好点”同行左侧有“坏点” $2$ 且“坏点” $1$ 在“坏点” $2$ 左侧），则两“好点”间距为其曼哈顿距离 $+2$ 。

![图一 两“好点”间距离的特殊情况]( https://cdn.luogu.com.cn/upload/pic/68671.png )

然后就是计算曼哈顿距离：考虑分行和列分别来做。

以行为例，枚举行数 $a$ ，对于每一行的“好点”整体计算在竖直方向走过的距离。如下图，对于一个“好点” $(a,b)$ ，其到第 $c$ 行所有点竖直方向上的距离之和等于第 $c$ 行所有“好点”的数量 $\times$ 第 $c$ 行与第 $a$ 行之间的距离差。

由题可知每行有 $m$ 个点，则第 $c$ 行有“坏点”时，对答案贡献了 $(m-1) \times abs(c-a)$ （如下图 $Case$ $1$ ）；第 $c$ 行没有“坏点”时，对答案贡献了 $m \times abs(c-a)$ （如下图 $Case$ $2$ ）。

![图二 一个“好点”与一行“好点”间某一方向上距离的情况一]( https://cdn.luogu.com.cn/upload/pic/68093.png )

![图三 一个“好点”与一行“好点”间某一方向上距离的情况二]( https://cdn.luogu.com.cn/upload/pic/68096.png )

最后考虑曼哈顿距离 $+2$ 的“好点”如何补上 $2$ 的绕路：之前大多数人听到的做法会有重复，我这儿讲一个不去重的！

还是分行和列考虑：以行为例，枚举行数 $a$ 。当第 $a$ 行有“坏点”时，这个“坏点”左边所有的点都有可能绕路。

检查上下的所有行，维护一个块（如下图蓝色部分）使得在这个块之内所有的“好点”都需要绕路：

向下维护时，只要当前行的“坏点”在其下面一行的“坏点”的左边，就可以将该“坏点”右边的所有点加入块内；

如果当前行的“坏点”在其上面一行的“坏点”的右边，则将该“坏点”右边的所有“好点”加入块内后结束维护（如红色“好点”均不需要加入块内）。整个块的下边缘向右下方发展。

向上维护时同理，整个块的下边缘向右上方发展。上下都结束之后，设蓝点总数为 $q$ ，对于第 $a$ 行的一个点 $(a,b)$ 来说，它到块内任何一个点的绕路都为 $2 \times q$ 。

这样就计算了一次从左上方到右下方的“好点”和从左下方到右上方的“好点”的路径。此时只要将刚刚计算的值 $\times 2$ ，便得出了该“好点”到所有需要绕路的“好点”和所有需要绕路到该“好点”去的“好点”绕路长之和。

算出该值后，乘上第 $a$ 行“坏点”左边的“好点”的个数加入答案即可。

![图四 两“好点”间距离的特殊情况]( https://cdn.luogu.com.cn/upload/pic/68671.png )

每一行做完一次如下的操作后，枚举列再做一次类似的操作即可。


整个过程就是这样，如果还没明白或者觉得需要证明的，评论区见！感谢您的耐心阅读！

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int ret=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ret=(ret<<1)+(ret<<3)+ch-'0';
		ch=getchar();
	}
	return ret*f;
}
int n,m,totx,tot,hangx[2005],liex[2005];
double ans;
char s[2005];
inline long long finds(int n,int m,int a[])
{
	long long ret=0;
	for(register int i=1;i<=n;i++)
	{
		long long sum=0,cnt=m-a[i];
		for(register int j=1;j<=n;j++)
		{
			if(a[j])
				sum+=(m-1)*abs(i-j);
			else
				sum+=m*abs(i-j);
		}
		if(a[i])
			ret+=(m-1)*sum;
		else
			ret+=m*sum;
		if(a[i])
		{
			int l=i-1,r=i+1;
			while(a[l+1]<a[l])
			{
				cnt+=m-a[l];
				l--;
			}
			while(a[r-1]<a[r])
			{
				cnt+=m-a[r];
				r++;
			}
			ret+=4*cnt*(a[i]-1);
		}
	}
	return ret;
}
int main()
{
	n=read();
	m=read();
	for(register int i=1;i<=n;i++)
	{
		scanf("%s",&s);
		for(register int j=1;j<=m;j++)
		{
			if(s[j-1]=='X')
			{
				hangx[i]=j;
				liex[j]=i;
				totx++;
			}
		}
	}
	tot=n*m-totx;
	ans=(finds(n,m,hangx)+finds(m,n,liex))*1.0/tot/tot;
	printf("%0.6lf\n",ans);
	return 0;
}
```


---

## 作者：shadowice1984 (赞：3)

十分不清真的细节题……

注意压缩代码，不然分情况讨论会很烦……

___________________

一句话题意：给定一个网格图，图中有坏点，求任意两点间期望最短路长度(也就是所有好的点对间最短路之和/好点数的平方)

特殊限制是没有两个坏点在同一行或者同一列，也没有两个坏点是对角线相邻的
_____________________

## 本题题解

先来考虑一下没有坏点的情况，那么答案是就是所有点对间的曼哈顿距离和

那么我们可以$O(nm)$的去枚举每一个点，然后计算这个点到其他所有点的曼哈顿距离之和

怎么计算呢，假如我们是这样一张图

![](https://cdn.luogu.com.cn/upload/pic/33733.png)

我们希望计算橙色点到其他所有点的曼哈顿距离之和，那么我们发现可以将其他所有点分成绿色/蓝色/紫色/黄色矩形部分分别计算，最后我们发现可能白色部分没有被算上/算了两次(这取决于你的边界条件)，那么加上或者减去就可以了

对于其中某一个矩形的计算方式的话，我们可以考虑直接首推式子，或者干脆直接写一个二维前缀和进行打表，这样我们就可以在$O(nm)$的时间内计算出所有点对间的曼哈顿距离之和

现在来考虑一下有坏点的情况

如果存在坏点的话，我们发现其实题目的保证相当的严格，大部分时候亮点间的最短路还是两点间的曼哈顿距离

遗憾的是我们依然可以构造出一个精彩的反例

这里搬运了一下许昊然题解的图

![](https://cdn.luogu.com.cn/upload/pic/33735.png)

就是形如这样的图，图中的绿色点到蓝色点的最短路为两点间曼哈顿距离+2

不过好在我们还可以抢救一下，我们经过观察发现似乎图中最短路要么是曼哈顿距离要么是曼哈顿距离+2，并且刚才的反例是唯一的反例

证明也非常简单，由于限制条件实在是太强了所以说一个坏点周围8个格子都是好格子，因此我们总是可以只绕两个格子就绕开一个坏点

那么我们的问题就变成了两个部分，1.求解所有好点间的最短路，2.求解最短路比曼哈顿距离多2的点对个数

第一个问题相对来讲好解决，我们可以枚举每一个点，求出他到其他所有点的曼哈顿距离之和，如果这个点是一个好点我们就将这个距离加到答案当中，如果这个点是坏点就把答案减去这个距离

那么对于一条起点是好点终点是坏点的路径来讲我们不会将这样的路径算到答案当中，而对于一个两个都是坏点的路径来讲我们会发现这样的路径被连续算了两遍

没关系，我们O(n^2)枚举的坏点对计算一下路径间的曼哈顿距离然后加上就行了

好了真正麻烦的是处理曼哈顿距离比最短路少2点对的情况

我们发现对于每一行的点来讲，图中绿色的区域总是呈一个阶梯形，那么我们可以枚举每一个行计算它对应的阶梯型面积

计算方式也很简单，我们比较一下当前行绿条长度和上一行绿条长度哪个比较长，如果下面的比上面长我们就直接让阶梯的面积加等于当前条的面积，否则我们把阶梯的面积赋值成当前条的面积

然后我们就可以计算所有最短路比曼哈顿距离多2点对的数目了

但是你需要注意的事情是刚才的图形旋转90/180/270,以及翻转后旋转90/180/270度之后依然是成立的，为了节约我们的代码我们将整个矩形转8次每次跑一边刚才的算法就行了~

其实并不难写……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e3+10;typedef double db;typedef long long ll;
char mde[N][N];ll tot;int n;int m;int lf[N];int rt[N];ll f[N][N];ll fs[N];
int x[N];int y[N];int tp;char tr[N][N];
inline int mabs(int x,int y){return (x<y)?y-x:x-y;}
inline void subsolve(int* len1,int* len2)//维护阶梯形的面积 
{
	for(int i=1,ns=0;i<=n;i++)
	{
		if(len1[i]==-1)continue;
		if(len1[i-1]==-1||len1[i]<len1[i-1])ns=0;
		tot+=(ll)2*ns*len2[i];tot+=(ll)len1[i]*len2[i];
		ns+=len1[i];
	}
}
inline void solve()//一次处理左侧和右侧的对称情况 
{
	for(int i=1;i<=n;i++)
	{
		lf[i]=rt[i]=-1;
		for(int j=1;j<=m;j++)if(mde[i][j]=='X'){lf[i]=j-1,rt[i]=m-j;break;}
	}subsolve(lf,rt);subsolve(rt,lf);
}
inline void rvs()//上下翻转 
{for(int i=1;i<=n/2;i++)for(int j=1;j<=m;j++)swap(mde[i][j],mde[n-i+1][j]);}
int main()
{
	for(int i=1;i<=1000;i++)//打表前缀和 
		for(int j=1;j<=1000;j++)f[i][j]=(i+j)-2;
	for(int i=1;i<=1000;i++)
		for(int j=1;j<=1000;j++)f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
	for(int i=1;i<=1000;i++)fs[i]=i-1;
	for(int i=1;i<=1000;i++)fs[i]+=fs[i-1];
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%s",mde[i]+1);
	for(int i=1,ri=n;i<=n;i++,ri--)
		for(int j=1,rj=m;j<=m;j++,rj--)//计算曼哈顿距离和 
		{
			ll dis=f[i][j]+f[i][rj]+f[ri][j]+f[ri][rj]-fs[i]-fs[j]-fs[ri]-fs[rj];
			if(mde[i][j]=='.')tot+=dis;else x[++tp]=i,y[tp]=j,tot-=dis;
		}
	for(int i=1;i<=tp;i++)//暴力枚举点对容斥 
		for(int j=1;j<=tp;j++)tot+=(mabs(x[i],x[j])+mabs(y[i],y[j]));
	solve();rvs();solve();rvs();//计算横着的4种情况 
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)tr[j][i]=mde[i][j];
	swap(n,m);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)mde[i][j]=tr[i][j];
	solve();rvs();solve();ll fz=((ll)n*m-tp)*((ll)n*m-tp);//计算竖着的4种情况 
	printf("%.10lf",(db)tot/fz);return 0; //拜拜程序~ 
}
```


---

## 作者：Li2021 (赞：2)

## CF57D Journey 题解
### 解题思路
首先考虑没有静粒子的情况。平均寿命即为所有可能的两个动粒子位置 $p,q$ 的距离求和除以所有可能的两个位置的个数：

$$\frac{\sum_{p,q}dis(p,q)}{\sum_{p,q}1}$$

显然，$p$ 的位置有 $n\times m$ 种可能，$q$ 的位置也有 $n\times m$ 种可能（$p$ 和 $q$ 的位置可以重合），于是分母就变为：

$$\sum_{p,q}1=(nm)^2$$

考虑分子。分析行距：$q$ 在 $p$ 左侧时，枚举所有 $p$ 的位置，再枚举所有 $q$ 的位置，$q$ 在 $p$ 右侧时，同理：

$$sum=2(1+(1+2)+...+(1+2+...+(n-1)))$$

考虑到列的位置不影响行距：

$$sum _\text{行} =2m^2(1+(1+2)+...+(1+2+...+(n-1)))$$

类似地：

$$sum _\text{列} =2n^2(1+(1+2)+...+(1+2+...+(m-1)))$$

将 $sum _\text{行}$ 与 $sum _\text{列}$ 相加，得：

$$\sum_{p,q}dis(p,q) = \frac{1}{3} \times nm \times (nm-1) \times (n+m)$$

由此得：

$$\frac{\sum_{p,q}dis(p,q)}{\sum_{p,q}1} = \frac{\frac{1}{3} \times nm \times (nm-1) \times (n+m)}{(nm)^2}$$

考虑有静粒子的情况。设静粒子个数为 $d$，显然，$p,q$ 的可能位置都减少了 $d$。于是分母再次变为 $(nm-d)^2$。

因为所有静粒子都不能作为终点，于是，对于每个静粒子 $(x,y)$，减掉步数：

$$2 \times (m \times (1 + 2 + ... + (x-1) + 1 + 2 + ... + (n-x))+
n \times (1 + 2 + ... + (y-1) + 1 + 2 + ... + (n-y)))$$

考虑因为两个动粒子之间可能会有静粒子阻隔而使两个动粒子之间距离增加。如果两粒子通过的每行（每列）都有静粒子阻隔，那么他们之间的距离就会增加 $2$。当然，两个动粒子之间同行，同列阻隔，它们之间的距离也会增加 $2$。

### 提示

1. ```cout``` 输出浮点数只保留六位小数，正解会挂。
2. 多思考，写简要的伪代码

### Code

代码可能不好看，谅解。
```cpp
#include <iostream>
#define N 1002
using namespace std;
char c[N][N];
long long sum,dot,p,_i[N],_j[N],n,m,num;
int main(){
	//freopen("xxx.in","r",stdin);
	//freopen("xxx.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
			if(c[i][j]=='X'){
				dot++;
				_i[j]=i;
				_j[i]=j;
				sum-=(m*(i*(i-1)+(n-i)*(n-i+1))+n*(j*(j-1)+(m-j)*(m-j+1)));
			}
		}
	}
	for(int i=1;i<=n;i++)  for(int j=i+1;j<=n;j++)  if(_j[i]&&_j[j])  sum+=2*((j-i)+abs(_j[i]-_j[j]));
	dot=(n*m-dot)*(n*m-dot);
	sum+=(n*m*(n+m)*(n*m-1)/3);
	for(int i=1;i<=n;i++){
		if(_j[i]){
			sum+=(_j[i]-1)*(m-_j[i])*4;
			for(int j=i+1;j<=n;j++){
				if(_j[j]>_j[j-1]&&_j[j])  sum+=(_j[i]-1)*(m-_j[j])*4;
				else  break;
			}
			for(int j=i+1;j<=n;j++){
				if(_j[j]<_j[j-1]&&_j[j])  sum+=(_j[j]-1)*(m-_j[i])*4;
				else  break;
			}
		}
	}
	for(int i=1;i<=m;i++){
		if(_i[i]){
			sum+=(_i[i]-1)*(n-_i[i])*4;
			for(int j=i+1;j<=m;j++){
				if(_i[j]>_i[j-1]&&_i[j])  sum+=(_i[i]-1)*(n-_i[j])*4;
				else break;
			}
			for(int j=i+1;j<=m;j++){
				if(_i[j]<_i[j-1]&&_i[j])  sum+=(_i[j]-1)*(n-_i[i])*4;
				else break;
			}
		}
	}
	double ans=1.0;
	ans=ans*sum/dot;
	printf("%.7lf\n",ans);
	return 0;
}
```

---


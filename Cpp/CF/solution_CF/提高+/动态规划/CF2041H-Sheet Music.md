# Sheet Music

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041H/b6dd52e9533263fc8e6069a510bb15c19ed436d6.png) Image generated by ChatGPT 4o.Alice likes singing. As a singing enthusiast, Alice has listened to countless songs and has tried singing them many times. However, occasionally, some songs make Alice feel bored. After some research, Alice believes that this is because even though the songs she chose are all different, due to her instinctive preference, they all turn out to be musically similar to one another.

To thoroughly analyze this, Alice decided to study the sheet music of the songs. For convenience, Alice represented a song of length $ n $ as an integer sequence $ a_1, a_2, \ldots, a_n $ , where $ a_i $ is the pitch of the $ i $ -th note. Then she defined the musical equivalence between songs. Two songs $ a_1, a_2, \ldots, a_n $ and $ b_1, b_2, \ldots, b_n $ of length $ n $ are musically equivalent if for all $ 1\leq i<n $ , both $ a_i, a_{i+1} $ and $ b_{i}, b_{i+1} $ have the same pitch relationship. More specifically, $ a_i, a_{i+1} $ and $ b_i, b_{i+1} $ have the same pitch relationship if either

- $ a_i < a_{i + 1} $ and $ b_i < b_{i + 1} $ ,
- $ a_i = a_{i + 1} $ and $ b_i = b_{i + 1} $ , or
- $ a_i > a_{i + 1} $ and $ b_i > b_{i + 1} $ .

 For example, $ 1, 2, 3, 3, 2 $ and $ 5, 9, 13, 13, 1 $ are musically equivalent, while $ 1, 2, 3, 2, 1 $ and $ 1, 2, 2, 2, 1 $ are not. Having practiced consistently for a long time, Alice is able to sing any note in the range of $ [1, k] $ . She wants to know how many different songs of length $ n $ within her range there are, if we treat musically equivalent songs as the same one. Can you help her calculate the number?

Since the answer might be large, print the answer modulo $ 998244353 $ .

## 样例 #1

### 输入

```
3 2```

### 输出

```
7```

## 样例 #2

### 输入

```
5 3```

### 输出

```
67```

# 题解

## 作者：xiezheyuan (赞：5)

## 简要题意

定义两个长度为 $n$ 的序列 $a,b$ 是相似的，当且仅当对于任意的 $1\leq i\lt n$，有 $\mathrm{sgn}(a_i-a_{i-1})=\mathrm{sgn}(b_i-b_{i-1})$。

你需要计算有多少个所有值域为 $[1,k]\cap \mathbb{Z}$ 的长度为 $n$ 的序列，特别地，相似的两个序列仅计算一次。答案对 $998,244,353$ 取模。

$1\leq n\leq 10^6,1\leq k\leq 10^9$。

## 思路

对于一个序列 $a$，我们用一种特殊的方法来记录这个序列（下文称之为符号序列）：对于每一个 $1\leq i\lt n$，如果 $a_i<a_{i+1}$，就写下 $+$，如果 $a_i>a_{i+1}$，就写下 $-$，否则写下 $=$。可以发现两个序列相似的充要条件是符号序列相同，于是现在我们要对所有合法的长度为 $n-1$ 的符号序列计数。

先考虑只有 $<,>$ 两种符号的符号序列的合法条件，可以去写一个 [最平凡的暴力](https://www.luogu.com/paste/apt1vz4n) 去打个表，观察怎样的符号序列是不合法的（因为合法的貌似很多不方便观察共性）。

可以发现**一个符号序列不合法的充要条件是连续出现了不少于 $k$ 个相同的符号（$+$ 或 $-$）。**

证明也是不难的，必要性证明是平凡的，考虑充分性，不妨改为证明一个连续出现少于 $k$ 个相同符号的符号序列一定是合法的（逆否命题）。假如第一个符号是 $+$，就取初值为 $1$，否则取 $k$。然后每个连续段结束时将其值设定为 $k$ 或 $1$，中间随意设定，容易发现用这个方法可以构造一组合法的对应的原序列。

于是可以设计一个 dp，设 $f(i)$ 表示长度为 $i$ 的合法的符号序列的数量，不难得到：

$$
f(i)=\sum_{j=0}^{i-1}[i-j<k] f(j)
$$

初始值 $f(1)=2$ 或 $f(0)=2$ 表示第一个符号可以填 $<$ 或 $>$。这玩意可以用前缀和简单地优化到 $O(n)$。

最后考虑加上 $=$，由于 $=$ 的性质，我们往一个符号序列中的任意一个位置插入或删除一个 $=$ 都不会改变这个序列的合法性。

于是可以枚举填多少个 $<$ 和 $>$，其余位置全部填 $=$，组合数简单计算一下即可：

$$
\sum_{i=1}^{n-1} \binom{n-1}{i}f(i)
$$

时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
constexpr int mod = 998244353;
int Add(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int Sub(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int Mul(int x, int y){ return 1ll * x * y % mod; }

int n, k, fact[N], inv[N], f[N], g[N], ans = 1;

int binom(int n, int m){ return n < m ? 0 : Mul(fact[n], Mul(inv[m], inv[n - m])); }

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> k; n--;
    fact[0] = fact[1] = inv[0] = inv[1] = 1;
    for(int i=2;i<=n;i++){
        fact[i] = Mul(fact[i - 1], i);
        inv[i] = Mul(inv[mod % i], mod - mod / i);
    }
    for(int i=2;i<=n;i++) inv[i] = Mul(inv[i], inv[i - 1]);
    f[0] = g[0] = 2;
    for(int i=1;i<=n;i++){
        f[i] = Sub(g[i - 1], (i - k) >= 0 ? g[i - k] : 0);
        g[i] = Add(g[i - 1], f[i]);
        ans = Add(ans, Mul(binom(n, i), f[i]));
    }
    cout << ans << '\n';
    return 0;
}

// Written by xiezheyuan

```

---

## 作者：__log__ (赞：1)

给学弟/妹准备题目ing

先不考虑等号。

那一种『类型』就可以化成一个折线函数，如果在 $[i,i+1]$ 间单调递减，说明 $a_i > a_{i+1}$，反之同理。

可以发现，若我们把 **极大值** 点的 $a$ 值设为 $k$，把 **极小值** 点的 $a$ 值设为 $1$。那相邻的极大值点 $x_1$ 与极小值点 $x_2$ 之间限制就是：中间有不超过 $k - 1$ 段函数，即 $|x_1 - x_2| \le k - 1$。

可以直接 dp。设 $dp_{i,0}$ 为 $i$ 作为极小值点，$[1,i]$ 的『类型』数 ；$dp_{i,1}$ 为 $i$ 作为极大值点，$[1,i]$ 的『类型』数。

$$dp_{i,0}=\sum_{j=i-k+1}^{i-1}dp_{j,1}$$

$$dp_{i,1}=\sum_{j=i-k+1}^{i-1}dp_{j,0}$$

前缀和优化即可。

接下来考虑加入等号，因为等号并不会影响一段『类型』的合法性，所以可以任意插入，用插板法即可。

$$ans = \sum_{i = 1}^n(dp_{i,0}+dp_{i,1})\times\tbinom{n-1}{i-1}$$

```cpp
// I love Furina forever!
# include <bits/stdc++.h>
# define maxn 1001000
# define mod 998244353
# define inf 0x3f3f3f3f
# define mem(a, val) memset(a, val, sizeof(a))
# define rep(i, j, k) for(int i = j; i <= k; ++i)
# define per(i, j, k) for(int i = j; i >= k; --i)
using namespace std;

int n, k, ans;
int fac[maxn], inv[maxn];
int dp[maxn][2], preSum[maxn][2];

inline int qpow(int a, int b) {int mul = 1; while(b) mul = 1ll * mul * (b & 1 ? a : 1) % mod, a = 1ll * a * a % mod, b >>= 1; return mul;}
inline int c(int a, int b) {return 1ll * fac[a] * inv[a - b] % mod * inv[b] % mod;}

signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n >> k;
    if(n == 1) cout << "1\n", exit(0);
    fac[0] = 1; rep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % mod;
    inv[n] = qpow(fac[n], mod - 2); per(i, n - 1, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;
    dp[1][0] = dp[1][1] = 1;
    preSum[1][0] = preSum[1][1] = 1;
    rep(i, 2, n) {
        dp[i][0] = (preSum[i - 1][1] - preSum[max(i - k, 0)][1] + mod) % mod;
        dp[i][1] = (preSum[i - 1][0] - preSum[max(i - k, 0)][0] + mod) % mod;
        preSum[i][0] = (preSum[i - 1][0] + dp[i][0]) % mod;
        preSum[i][1] = (preSum[i - 1][1] + dp[i][1]) % mod;
    }
    ans = 1;
    rep(i, 2, n) {
        int tmp = (dp[i][0] + dp[i][1]) % mod;
        ans = (ans + 1ll * tmp * c(n - 1, i - 1) % mod) % mod;
    }
    cout << ans << '\n';
    return 0;
}
```

草，过了 9 天才发现没按提交题解。

---

## 作者：xyvsvg (赞：0)

不妨先考虑没有等号的情况。则问题转换为有多少个长度 $n-1$ 的符号序列满足条件。由于我们总时可以贪心的根据符号序列构造原序列，则只要符号序列中不出现连续的 $k-1$ 个相同符号即为合法。

如何处理等号呢？只需在符号序列中插入等号即可，显然不影响合法性，于是乘上一个组合数即可处理。

设 $f_i$、$g_i$ 分别表示当前有连续 $i$ 个小于、大于号的方案数。则转移为

$$f_i\gets f_{i-1},i>1$$
$$f_1\gets \sum g_i$$

$g$ 同理。因为它们是对称的，所以只处理 $f$ 即可。注意到除了 $f_1$，其他的都“继承”了前一个，因此我们可以使用```deque```模拟“滑动”操作，同时求出 $f_1$。

注意 $k=1$ 的情况

时间复杂度为 $O(n)$


```cpp
#include<bits/stdc++.h>
using namespace std;
signed main()
{
    const int mod=998244353;
    int n,k;
    cin>>n>>k;
    --n,--k;
    k=min(n,k);
    vector<int>fac(n+10);//阶乘
    vector<int>inv(n+10);//逆元
    vector<int>finv(n+10);//阶乘逆元
    fac[0]=1,inv[1]=1,finv[0]=1;
    for(int i=2;i<=n;++i)
        inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;
    for(int i=1;i<=n;++i)
        fac[i]=1LL*fac[i-1]*i%mod,
        finv[i]=1LL*finv[i-1]*inv[i]%mod;
    auto C=[&](int n,int m)//组合数
    {
        return 1LL*fac[n]*finv[m]%mod*finv[n-m]%mod;
    };
    deque<int>deq(k);
    int ans=1,res=0;
    if(!deq.empty())
        deq.front()=1,res=1;
    for(int i=1;i<=n;++i)
    {
        ans=(2LL*C(n,i)*res+ans)%mod;
        deq.push_front(res);
        res=(2LL*res-deq.back())%mod;
        deq.pop_back();
    }
    cout<<(ans+mod)%mod<<endl;
    return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：0)

## H. Sheet Music

定义两个序列 $a,b$ 是同一『类型』当且仅当对于所有 $i$，$a_i$ 和 $a_{i+1}$ 的大小关系与 $b_i$ 和 $b_{i+1}$ 的大小关系一致。

大小关系指：大于，小于，等于。

给定 $n,k$，求值域在 $[1,k]$ 的长度为 $n$ 的序列有多少个『类型』，答案对 $998244353$ 取模。

$1\leq n\leq 10^6$，$1\leq k\leq 10^9$。

---

等价于对符号序列计数，并且**删去等号后**满足不存在连续的 $k$ 个符号相同。

设 $f_{i,0/1}$ 表示第 $i$ 个位置填大于号或小于号的方案数。

初值 $f_{0,0}=f_{0,1}=1$。

转移为 $f_{i,0}=\sum\limits_{j=i-k+2}^{i-1} f_{j,1}$，$f_{i,1}$ 的转移同理。

显然这个式子可以用前缀和优化 DP。

之后对答案计数。枚举大于小于号序列的长度。等号可以随意插入，长度为 $i$ 的序列，插入方案数为 $\binom{n-1}{i}$，这就是系数。

答案为 $(\sum\limits_{i=0}^{n-1}\binom{n-1}{i}(f_{i,0}+f_{i,1}))-1$。

最后 $-1$ 是因为第 $0$ 个位置，就是不填符号，大于小于贡献一样，算一个的即可。

<https://codeforces.com/contest/2041/submission/293242222>

---


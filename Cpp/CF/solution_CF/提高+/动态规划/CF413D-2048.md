# 2048

## 题目描述

The programmers from the R2 company love playing 2048. One day, they decided to invent their own simplified version of this game — $ 2^{k} $ on a stripe.

Imagine an infinite in one direction stripe, consisting of unit squares (the side of each square is equal to the height of the stripe). Each square can either be empty or contain some number.

Initially, all squares are empty. Then at infinity one of the unit squares number 2 or 4 appears. Then the player presses a button once, and the appeared number begins to move towards the beginning of the stripe. Let's assume that some number $ x $ moves to the beginning of the stripe, then it will stop if:

1. it either gets in the first square of the stripe;
2. or it is in the square that is preceded by a square with number $ y $ $ (y≠x) $ . But if number $ x $ at some point of time gets to the square with the same number then both numbers add to each other and result in $ 2x $ . The new number $ 2x $ continues moving to the beginning of the stripe by the same rules.

After the final stop of the number moving process, the infinity gets a new number 2 or 4 and the process repeats. Read the notes to the test samples to better understand the moving strategy.

I guess you've understood that the game progress fully depends on the order in which numbers 2 and 4 appear. Let's look at some sequence of numbers 2 and 4 in the game. We assume that the sequence is winning if it results in at least one square getting the number greater or equal than $ 2^{k} $ .

The goal of the game is to make up a winning sequence of $ n $ numbers. But not everything is so simple, some numbers in the sequence are identified beforehand. You are given a sequence consisting of numbers 0, 2, 4. Count how many ways there are to replace each 0 of the sequence with 2 or 4 to get a winning sequence.

## 说明/提示

Consider the first example. The beginning of the strip will look as follows:

2 $ → $ 4 $ → $ 8 $ → $ 8 2 $ → $ 8 4 $ → $ 8 4 2 $ → $ 16.

To better understand the game, you can see the original game on http://gabrielecirulli.github.io/2048/. Please note that the game that is described on the strip is slightly different from the original game (when the two numbers add up in the original game, they do not keep moving). Be careful, the game is addictive, there isn't much time for the contest!

## 样例 #1

### 输入

```
7 4
2 2 4 2 2 2 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
1 3
0
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2 3
0 4
```

### 输出

```
1
```

## 样例 #4

### 输入

```
5 4
2 0 0 4 4
```

### 输出

```
2
```

# 题解

## 作者：skylee (赞：8)

### 题解地址：
[[CF413D]2048 - skylee's Blog](http://www.cnblogs.com/skylee03/p/8987373.html)

### 题目大意：
在一个长度为$n(n\le2000)$的数组中填数$2$或$4$，待所有数字全部填好后，按照类似于2048的规则向左合并。给定某些格子上的数，问在当前情况下要使得合并后的最大数超过$2^k$有几种填法。

### 思路：
动态规划。  
定义一个状态为最长不上升后缀的数字和，如$(16,4,8,4,4,2)$对应的状态为$18$，因为后面这些还是有机会合并的，且合并的过程可以直接用加法代替，如$(16,4,8,4,4,2)$后面再加上一个$2$，对应的状态变为$18+2=20$。定义目标状态为$2^k$，超过这个的状态对其取$\min$。用$f[i][j]$表示前$i$个格子状态为$j$的方案数，则不难得到如下转移：
- 当$x=2$时，$f[i][\min(j+2,2^k)]+=f[i-1][j]$；
- 当$x=4$且当前最后有多余$2$时，新加进来的数不可能再和前面的合并了，故不将前面的计入状态，$f[i][4]+=f[i-1][j]$；
- 当$x=4$且当前最后无多余$2$时，$f[i][\min(j+4,2^k)]+=f[i-1][j]$。
- 当$x$不确定时，同时进行上述两种转移即可。

时间复杂度$O(n\cdot2^k)$。

### 源代码：
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
inline int getint() {
	register char ch;
	while(!isdigit(ch=getchar()));
	register int x=ch^'0';
	while(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');
	return x;
}
const int K=10,mod=1e9+7;
int f[2][(1<<K)+1];
int main() {
	const int n=getint(),k=getint()-1;
	for(register int i=f[0][0]=1;i<=n;i++) {
		const int x=getint();
		std::fill(&f[i&1][0],&f[i&1][1<<k]+1,0);
		for(register int j=0;j<=1<<k;j++) {
			if(x!=2) (f[i&1][j&1?2:std::min(j+2,1<<k)]+=f[(i&1)^1][j])%=mod;
			if(x!=4) (f[i&1][std::min(j+1,1<<k)]+=f[(i&1)^1][j])%=mod;
		}
	}
	printf("%d\n",f[n&1][1<<k]);
	return 0;
}
```

---

## 作者：H6_6Q (赞：3)

### 思路：     
先考虑如果序列的形态全部已知，如何在线性的时间内判断该序列能否合并超过 $2^k$ 。       
可以记录一个和 $sum$ 表示当前可能继续合并的后缀的和，那么这个后缀一定是最长不上升的。   
例如这个后缀：`16 8 4 2 4` ，最后一个 $4$ 因为上升，无法合并到前面的序列中，与之前隔绝，所以不能加到前面的 $sum$ 中。       
那么分类讨论：
- 如果填的是 $2$ ，由于 $2$ 是最小的数，那么一定不会上升，直接将 $sum+=2$ 即可。
- 如果填的是 $4$ ，且 $sum$ 中没有单独的 $2$ ，即 $sum$ 可以整除 $4$，那么在这之前就没有小于 $4$ 的数，可以直接将 $sum+=4$  ( 即使有 $2$ ，因为所有 $2$ 都是成对的，所有都可以合并为 $4$ ) 。
- 如果填的是 $4$ ，且 $sum$ 中有单独的 $2$，即 $sum \bmod{4} = 2$，那么就意味着出现了上述例子的情况，新增的 $4$ 无法参与到之前的合并中，所以只能重新记录，即 $sum = 4$    

当 $sum \ge 2^k$ 时，就意味着 $2^k$ 可以被拼出来。 

那么可以将这个过程写成 dp ，设 $dp[i][j]$ 为填了前 $i$ 个数，当前的 $sum$ 为 $j$ 时的方案数。   
因为 $sum$ 只要大于 $2^k$，$2^k$ 就可以合并出来，所以我们可以把 $sum \ge 2^k$ 时的答案也归入 $sum = 2^k$ 中，即在 $2^k$ 与更新完的 $sum$ 中取 $\min$。     
那么可以得出转移方程：   
当填的是 $2$ 时：    
- $dp[i][ \min(j+2,2^k)] += dp[i-1]j]$    

当填的是 $4$ ，且 $sum$ 中没有单独的 $2$ 时：    
- $dp[i][\min(j+4,2^k)] += dp[i-1]j]$    

当填的是 $4$ ，且 $sum$ 中有单独的 $2$ 时：    
- $dp[i][4] += dp[i-1]j]$    

当填的是 $0$ 时：    
- 既当成 $2$ 转移一次，再当作 $4$ 转移一次即可。     

边界就是 $dp[0][0] = 1$       
最后的答案就是 $dp[n][2^k]$
### Code：
```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<bitset>
#include<cmath>
#include<queue>
#include<map>
#include<set>

using namespace std;

int read()
{
	int ans=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
	return ans*f;
}

const int N=2005,K=11,mod=1e9+7;
int n,k,a,dp[N][(1<<K)+5];

int main()
{
	n=read();k=read();
	dp[0][0]=1;
    // 边界
	for(int i=1;i<=n;++i)
	{
		a=read();
		for(int j=0;j<=(1<<k);++j)
       	// 枚举 sum
		{
			if(a==2||a==0)
            // 当填的是 2 或 0 时
				dp[i][min(j+2,1<<k)]=(dp[i][min(j+2,1<<k)]+dp[i-1][j])%mod;
			if(a==4||a==0)
			// 当填的是 4 或 0 时
			{
				if(j%4==2)
				// 当 sum 中有单独的 2 时
					dp[i][4]=(dp[i][4]+dp[i-1][j])%mod;
				else
				// 当 sum 中没有单独的 2 时
					dp[i][min(j+4,1<<k)]=(dp[i][min(j+4,1<<k)]+dp[i-1][j])%mod;
			}
		}
	}
	printf("%d",dp[n][1<<k]);
	return 0;
}
```


---

## 作者：co7ahang (赞：2)

机房同学借“理解题意”之名在模拟赛时打了很久的 2048。在此表示严厉谴责。

考虑怎么存储状态。进行模拟，每次入栈的元素可能为 $2$ 或 $4$。

- 如果入栈的元素为 $2$ 的话，可以证明（模拟）能够一直合并。

- 但如果入栈元素为 $4$ 的话且栈顶为 $2$，$2$ 和其以前的元素就再也无法继续合并了。但如果栈顶不为 $2$ 仍可以合并。

因此我们只需要储存**最后一个可合并的单调递减序列**。来看两个实例如下：

|$128$|$32$|$8$|$4$|$2$|
|:-:|:-:|:-:|:-:|:-:|

- 此时如果入栈为 $2$，最终合并结果为 $\left \{ 128, 32, 16  \right \} $。

- 此时如果入栈为 $4$，最终合并结果为 $\left \{ 128, 32, 8, 4, 2, 4  \right \} $，前面的部分已经不可合并，故只需存储 $\left \{ 4 \right \} $。

|$128$|$32$|$16$|$8$|$4$|
|:-:|:-:|:-:|:-:|:-:|

- 此时如果入栈为 $2$，结果为 $\left \{ 128, 32, 16, 8, 4, 2  \right \} $，依旧可以合并。

- 此时如果入栈为 $4$，最终合并结果为 $\left \{ 128, 64  \right \} $。

由于是单减序列，又注意到 $k \leq 11$，可以想到用状压来存储。定义 $dp[i][k]$ 表示第 $i$ 个元素时栈内状态为 $k$ 的方案数，初始化 $dp[0][0] = 1$。转移方程可以意会一下。

Code
```cpp
const int N = 2e3 + 10;
const int P = 1e9 + 7;
int n, m, k;
int val[N];
int dp[N][(1 << 11) + 1];
int32_t main() {
	n = read(), k = read();
	for(int i = 0; i < n; i++) val[i] = read();
	dp[0][0] = 1;
	
	for(int i = 0; i < n; i++) {
		for(int j = 0; j <= (1 << k); j++) {
			int ni = i + 1, nj;
			if(val[i] != 4) {
				//2
				nj = min((int)(1 << k), j + 2);
				dp[ni][nj] = (dp[i][j] + dp[ni][nj]) % P;
			}
			if(val[i] != 2) {
				//4
				if(j == (1 << k)) nj = j;
				else if(j & 2) nj = 4;
				else nj = min(j + 4, (int)(1 << k));
				dp[ni][nj] = (dp[i][j] + dp[ni][nj]) % P;
			}
		}
	}
	write(dp[n][(1 << k)]);
	return 0;
}//i love mike qwq
```

[通过记录](https://codeforces.com/contest/413/submission/316087620)

---

## 作者：FDOI (赞：2)

## 题意简述：

给定长度为 $n$ 的序列，将其进行 $k$ 次操作，每次压入一个 $2$ 或者 $4$，之后以题目中给定的游戏规则，即 **$2048$ 游戏规则**进行合并，最后要求给出**可行的方案数量**，使得序列中的最大数**大于** $2^k$。

## 思路分析：

看到这道题的 $k$ 居然如此之**小**，再者要求**方案**数，优先想到**状压**。

接下来是保姆级的分析。

### 定义状态：

标准的方式，定义二维，表示**压入前 $i$ 个数后情况数为 $j$**。

不熟悉状压的可以先去学板子。

### 初始化：

可以想到，当不压入时，这也是**一种合法情况**，这时令 $dp_{0,0}$ 为 $1$ 即可。

### 状态转移：

这是本题的关键所在，应该分**两种不同的情况**分析。

- 当压入的是 $2$ 时，这时由于其是**最小数**，所以一定可以将其压入序列中，此时**状态 $j$ 就会加二**，并且压入了 $i+1$ 个数，此时如果已经满足最大值大于 $2^k$ ，就直接**继承 $j$ 全部选定**，即 $j=2^k$ 的情况，否则就**继承当前情况 $j+2$** 即可。
- 反之，当压入的是 $4$ 时，我们又要**分类讨论**，当此时的状态中，上一个数**已经为 $2$ 时**，此时无法在上一个状态中**直接压入 $4$**，所以说此时**直接继承 $j=4$ 时的情况**另开，当此时**恰好满足 $j+4=2^k$ **时，那么不用再继续更新，直接继承**来自 $j$ 的状态**即可，否则如果不满足上述情况时，就**同理**要么已经大于 $2^k$ 继承 $j=2^k$ 的状态，要么就不满足不大于继承 $j+4$ 的情况。

### 输出答案：

显然，输出当压入完 $n$ 个数，状态为 $2^k$ 全部选定的情况。

### 坑点：

- 记得取模。
- 数组一定要开够。
- 要仔细理解题意，注意细节错误。
- 千万不要抄题解。

## 代码公示：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7;
int n,k;
int x;
int dp[2005][(1<<11)+1];
int a[3005];
signed main(){
	cin>>n>>k;
	dp[0][0]=1;
	for(int i=0;i<n;i++){
		cin>>x;
		for(int j=0;j<=(1<<k);j++){
			if(x!=4){
				int ni=i+1;
				int nj=min((1<<k),j+2);
				dp[ni][nj]=(dp[ni][nj]+dp[i][j])%P;
			}
			if(x!=2){
				int ni=i+1;
				int nj=j+4;
				if(nj==(1<<k)) nj=j;
				if(j&2){
					nj=4;
				}
				else nj=min(j+4,(1<<k));
				dp[ni][nj]=(dp[ni][nj]+dp[i][j])%P;
			}
		}
	}
	cout<<dp[n][(1<<k)]; 
} 
```

---

## 作者：Hevix (赞：1)

状态压缩，动态规划

很好的动态规划题目，考察对于状态的定义。

提出几个思考问题：
- 如何划分阶段？
  > 线性划分即可，考虑将前 $i$ 个数放入栈中消之后会变成什么状态。

- 过程长什么样？如何定义状态？如何精简的表示每个阶段的状态？
  >  过程中我们需要维护的就是栈中的内容，这个信息量看起来很庞大。但是思考后发现，我们只需要记录栈中最后一个递减序列即可，因为最后一个递减序列之前的数是不可能被消的。
  >
  > 所以我们需要记录栈中最后一个递减序列即可，这个可以状压记录。
  >
  > 其次，根据题目要求，我们需要记录此前是否出现数字 $\geq 2^k$ 。

```CPP
#include<bits/stdc++.h>
using namespace std;
#define ls u<<1
#define rs u<<1|1
#define ll long long
#define ii pair<int,int>
#define vv vector<vector<int > >
#define fi first
#define se second
#define endl '\n'
#define debug(x) cout << #x << ": " << x << endl
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound
#define i128 __int128
#define Time 1.0*clock()/CLOCKS_PER_SEC
#define pcnt(x) __builtin_popcount(x)
#define mem(a,goal) memset(a,(goal),sizeof(a))
#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
ll rd()
{
    ll a=0;int f=0;char p=getchar();
    while(!isdigit(p)){f|=p=='-';p=getchar();}
    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}
    return f?-a:a;
}
const int INF=998244353;
const int P=1e9+7;
const int N=1e6+5;
int n,k;
int a[2005];
int dp[2005][(1<<11)+1];//dp[i][j]
int main()
{
	n=rd();	k=rd();
	dp[0][0]=1;
	for(int i=0;i<n;++i){//我为人人 
		int x=rd();
		for(int j=0;j<=(1<<k);++j){
			//枚举转移
			if(x!=4){//下一位填2 
			//dp[~][1<<k]
				//dp[i][j]->dp[i+1][j+2]
				int ni=i+1;	int nj=min(j+2,1<<k);
				dp[ni][nj]=(dp[ni][nj]+dp[i][j])%P;
			}
			if(x!=2){//下一位填4
				int ni=i+1;	int nj;
				if(j==(1<<k))	nj=j;
				else{
					if(j&2)	nj=4;
					else	nj=min(j+4,1<<k);
				}
				dp[ni][nj]=(dp[ni][nj]+dp[i][j])%P;
			}
		}
	}
	cout<<dp[n][1<<k];
	return 0;
}
```

---

## 作者：skyskyCCC (赞：1)

## 前言。
在 $1000$ 通过后的第一个题，纪念 $2$ 年前还玩 $2048$ 这个小游戏的我。

显然对于这种填数然后构造方案的显然就是动态转移。
## 分析。
考虑动态转移，分情况讨论。

我们设 $dp\left[i\right]\left[j\right]$ 为当我们考虑到第 $i$ 个数时，合并后的和为 $j$ 的方案数。因为我们只能在空白处填 $2$ 或 $4$ 所以我们考虑单独与分解成的 $2$ 的个数。考虑将这个序列看做一个非严格递减序列。如果一个该序列的子段末尾 $2$ 的个数为偶数，则整个子段可以合并成一个数。如果 $2$ 的个数为奇数，则在最后的 $2$ 不能合并进去。

但是我们考虑这个单独的 $2$ 是否会影响到整个答案？因为如果现在能凑到 $2^k$ 的话，加上这个 $2$ 时，因为它没有办法合并，所以不影响能否凑到 $2^k$。所以，转移方程式可以以此为条件分类讨论，只要考虑是不是要加上上一个状态即可。唯一需要注意的点就是记录方案数的 $j$ 要开的尽可能大。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
const int mod=1e9+7;
int n,k,x;
int dp[2005][(1<<11)+5];
int main(){
    cin>>n>>k;
    dp[0][0]=1;
    for(int i=1;i<=n;i++){
        cin>>x;
        for(int j=0;j<=(1<<k);j++){
		    //枚举上一个dp[i][j]的状态。 
            if(x!=4){
            	int j2=min(1<<k,j+2);
			    dp[i][j2]+=dp[i-1][j];
				dp[i][j2]%=mod;
			}
            if(x!=2){
            	if(j%4==2){
            		dp[i][4]+=dp[i-1][j];
					dp[i][4]%=mod;
				}
				else{
					int j2=min(1<<k,j+4);
                    dp[i][j2]+=dp[i-1][j];
					dp[i][j2]%=mod;
                }
            }
        }
    }
    cout<<dp[n][1<<k]<<"\n";
    return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：Elairin176 (赞：0)

[传送门](https://www.luogu.com.cn/problem/CF413D)    
## 题意
给定一个栈，在栈内进行 2048 游戏。   
栈中会有一些数字为 $0$，代表需要将其填为 $2$ 或 $4$，问最后能合并出的最大数字不小于 $2^k$ 的方案数。   
## 解法
我们注意到，数字不会超过 $2^{12}$，故我们可以对所有数字对 $2$ 取 $\log$，并考虑状压 dp。    
不难看出，如果栈内的数字形如 $x,a_1,a_2,\cdots,a_n(x<a_1,a_1>a_2>\cdots>a_n)$ 的形式，那么我们此时无需考虑 $x$ 的贡献。   
那么我们可以设 $f_{s,k}$ 表示当前栈内可贡献的数字集合为 $s$，出现过的最大数字为 $k$ 的方案数。   
令 $\operatorname{g}(s,x)$ 表示一个合法集合 $s$ 在尾部添加 $x$ 后所得到的极大合法集合。  
那么利用这个函数进行转移即可。   
这里有一个小 trick：我们在 $\operatorname{g}$ 内无需暴力修改 $s$，在状态压缩下只需要判断最后一位并进行加法即可。   

```cpp
//完整缺省源请见洛谷云剪贴板 jo5j6ogx
cst int N=4096,K=12;
cst ll p=1e9+7;
int n,m,a[N+10],full,mx[N+10];
ll f[N+10][K+2],ans,g[N+10][K+2];
int main(void){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	for(int i=1;i<=N;i++){
		int j;
		for(j=0;j<=K;j++){
			if((1<<j)>i){
				break;
			}
		}
		mx[i]=j;
	}
	n=read<int>();m=read<int>();
	for(int i=1;i<=n;i++){
		a[i]=read<int>();
		a[i]=(a[i]==2?1:(a[i]==4?2:0));
	}
	f[1][1]=(a[1]!=2);f[2][2]=(a[1]!=1);
	for(int i=1;i<n;i++){
		memset(g,0,sizeof(g));
		for(int j=1;j<N;j++){
			for(int k=mx[j];k<=K;k++){
				if(a[i+1]!=2){
					int t=_max<int>(mx[j+1],k);
					g[j+1][t]=madd(g[j+1][t],f[j][k],p);
				}
				if(a[i+1]!=1){
					if(j&1){
						int t=_max<int>(k,2);
						g[2][t]=madd(g[2][t],f[j][k],p);
					}else{
						int t=_max<int>(mx[j+2],k);
						g[j+2][t]=madd(g[j+2][t],f[j][k],p);
					}
				}
			}
		}
		memcpy(f,g,sizeof(f));
	}
	for(int i=1;i<N;i++){
		for(int j=m;j<=K;j++){
			ans=madd(ans,f[i][j],p);
		}
	}
	write(ans);
	ret 0;
}
```

---

## 作者：__stick (赞：0)

# 题意
给出 $n$ 个数 $a[1\cdots n]$，是 $0$ 或者 $2$ 或者 $4$，你可以将 $0$ 换成 $2$ 或者 $4$，最后往右合并，问合并出来超过 $2^k$ 数的方案数。
# 思路
这个题翻译对合并过程的解释很有启发性，维护一个栈实现这个操作。

则不难想到将这个栈存到状态中，在这个题的特殊条件下（栈中的数都是 $2$ 的幂且唯一）是可以实现的。

我们可以将合并看做进位操作，所以加入数字也就变成了做加法，如果加入一个无法被合并的数，则就从这里重新开始维护一个栈即可。

具体的，我们使用一个状压表示这个栈，其中二进制第 $i$ 位表示栈中 $2^i$ 这个数是否存在，并且从高位开始排列，举个例子，就大概长这样： $2^{10},2^8,2^4,2^2,2$ ，这些数的和就是我们的状压表示，而超过 $2^k$ 的数没有意义，所以最大只需要 $2^k$ 就行了。

于是状态就简单了，$F_{i,j}$ 表示考虑到第 $i$ 个数，当前栈的状压表示是 $j$ ，由于新加入的数只有 $2,4$ 两种情况，所以可以讨论一下，这里使用填表法比较方便。

1. 加入 $2$，因为 $2$ 是最小的数，所以一定能加进去 $F_{i,j}\to F_{i+1,\min(j+2,2^k)}$ 

2. 加入 $4$ ，如果栈顶不是 $2$ 则可以直接加入，反之 $4$ 就是新的栈底了（新开了一个栈）


总结一下，转移有三种：

$$
F_{i,j}\to \begin{cases} 
F_{i+1,\min(j+2,2^k)}&a_i\neq 4\\
F_{i+1,\min(j+4,2^k)}&a_i\neq2  \wedge \frac{j}{2}\equiv 0\mod{2}\\
F_{i+1,4}&a_i\neq2  \wedge \frac{j}{2}\equiv 1\mod{2}
\end{cases}
$$

由于数学语言最好不带位运算，后面两个就是 $j$ 的二进制第 $1$ 是否为 $1$ 的意思，可对照代码理解。


# 代码

这里取 min 操作不仅有防止溢出的作用，而且如果这个数列提前就到了 $2^k$ 但是后边有加入了一个 $2$ 一个 $4$ ，那不就直接新开一个栈了吗，所以这里有得到一个就停手的意思。
```cpp
int F[MAXN][MAXN];//考虑到前 i 个元素，栈状压表示是 j 的方案数，显然只有 j >=k 的时候会产生大于 k 的数 
signed main()
{
	int n=R(),k=R();
	F[0][0]=1;
	for(int i=0;i<n;i++)
	{
		int x=R();
		for(int j=0;j<=(1<<k);j++)
		{
			if(x!=4)(F[i+1][min(1<<k,2+j)]+=F[i][j])%=mod;//选择 2 
			if(x!=2)// 选择 4 
			{
				if((j>>1)&1)(F[i+1][4]+=F[i][j])%=mod;
				else (F[i+1][min(1<<k,j+4)]+=F[i][j])%=mod;
			}
		}
	 } 
	 cout<<F[n][1<<k];
	return 0;
}
```


---

## 作者：XL4453 (赞：0)

### 解题思路：

考虑动态规划。

记 $f_{i,j}$ 表示第 $i$ 个点之前，最大可拓展后缀的价值为 $j$。然后根据下一次的价值进行转移。

若设 $x$ 表示当前值（若为 $0$ 则两者都考虑）。当 $x=2$ 时，无论如何都可以转移，形式化地，有：$f_{i,j+2}=\sum f_{i,j}$。当 $x=4$ 时，情况较为复杂，此时要粉能接上去（末尾不为 $2$），和不能接上去（末尾有 $2$）。

然后分情况转移就行了。

---
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MOD=1000000007;
int f[2005][(1<<11)+5],m,n,k,x;
int main(){
	scanf("%d%d",&n,&k);
	m=(1<<k);
	f[0][0]=1;
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		for(int j=0;j<=m;j++){
			if(x!=4)f[i][min(m,j+2)]=(f[i][min(m,j+2)]+f[i-1][j])%MOD;//0 或 2
			if(x!=2){
				if((j>>1)&1==1)f[i][4]=(f[i][4]+f[i-1][j])%MOD;
				else f[i][min(m,j+4)]=(f[i][min(m,j+4)]+f[i-1][j])%MOD;
			}
		}
	}
	printf("%d",f[n][m]);
	return 0;
}
```


---


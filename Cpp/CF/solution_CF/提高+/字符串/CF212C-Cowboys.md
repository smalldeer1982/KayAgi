# Cowboys

## 题目描述

问题描述
 
　　n个牛仔站立于一个环中，并且每个牛仔都用左轮手枪指着他旁边的人！每个牛仔指着他顺时针或者逆时针方向上的相邻的人。正如很多西部片那样，在这一刻，绳命是入刺的不可惜……对峙的场景每秒都在变化。每秒钟牛仔们都会分析局势，当一对相邻的牛仔发现他们正在互指的时候，就会转过身。一秒内每对这样的牛仔都会转身。所有的转身都同时在一瞬间发生。我们用字母来表示牛仔所指的方向。“A”表示顺时针方向，“B”表示逆时针方向。如此，一个仅含“A”“B”的字符串便用来表示这个由牛仔构成的环。这是由第一个指着顺时针方向的牛仔做出的记录。例如，牛仔环“ABBBABBBA”在一秒后会变成“BABBBABBA”；而牛仔环“BABBA”会变成“ABABB”。 这幅图说明了“BABBA”怎么变成“ABABB” 一秒过去了，现在用字符串s来表示牛仔们的排列。你的任务是求出一秒前有多少种可能的排列。如果某个排列中一个牛仔指向顺时针，而在另一个排列中他指向逆时针，那么这两个排列就是不同的。

## 样例 #1

### 输入

```
BABBBABBA
```

### 输出

```
2
```

## 样例 #2

### 输入

```
ABABB
```

### 输出

```
2
```

## 样例 #3

### 输入

```
ABABAB
```

### 输出

```
4
```

# 题解

## 作者：shadowice1984 (赞：5)

大力O(n)dp，这题n只给开到100的原因是防止方案数爆longlong

________________________________

简单说一下并不好懂的题意，给定一个只有A和B的环形字符串，定义一次变换是将字符串中所有的“AB”(方向是顺时针方向开始读)替换成“BA”，现在输入一个目标串，问有多少种字符串可以在一次变换之后变成目标串

## 本题题解

首先众所周知环形字符串是没法dp的，所以想dp就得破环为链

那么我们随便找一个位置开始断开，但是我们发现断开之后会发现一件事情是第一个字符可以和最后一个字符发生交换……这就相当的不妙了

那么我们把开头的字符复制到最后一个字符上同时钦定这两个字符必须相同，我们就完成了破环为链的工作了

此时我们要做的就是大力dp，设$dp_{i,j},j\in \{0,1\}$表示决策到了第i位并且第i位填了A/B这个字符时合法的字符串方案数

那么我们现在开始大力的转移就是说枚举下一位填什么字符了

那么我们开始大力分情况讨论一波

### case1:求$dp_{i+1,0}$

由于我们填了一个0，所以说明一件事是$i+1$和$i$永远不可能发生转向关系

所以我们显然只需要判断一下目标字符串的第i位是“A”还是“B”

如果是"A"的话那么$dp_{i,0}$和$dp_{i,1}$都有机会转移到$dp_{i+1,0}$上

但是如果是"B"的话由于i和i+1并没有发生转身，因此仅仅$dp_{i,1}$可以转移到$dp_{i+1,0}$上

### case2:求$dp_{i+1,1}$

这个部分的情况相对辣手，因为我们填了一个1所以导致我们的$i+1$和$i$之间可以交换了

那么此时我们就需要看目标字符串的第$i+1$位是"A"还是"B"了

#### case2.1:是"A"

那么我们发现此时发生了转向

我们此时需要看字符串的第i位是什么来判断i之前的方向

如果是A的话说明原来i的方向是”B“问题来了"BB"间不可能发生交换的

所以这种情况下$dp_{i+1,1}$是0

如果是B的话说明原来i的方向是”A“因此$dp_{i,0}$可以转移到$dp_{i+1,1}$上

#### case2.2:是"B"

那么此时我们并未发生转向

因此$dp_{i,0}$和$dp_{i,1}$都可以转移到$dp_{i+1,1}$上了

好了现在最后的问题是dp初始条件是什么呢？

~~我们枚举一下开头是选A还是选B分别跑一个dp二者相加就行了~~

记得满足破环为链的限制条件，就是说我们的开头和结尾必须是同一个字符

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e3+10;typedef long long ll;
ll res;ll dp[N][2];char mde[N];int n;
inline void dypr()
{
    for(int i=1;i<=n;i++)
    {
        dp[i+1][0]=(mde[i]=='A')?dp[i][0]+dp[i][1]:dp[i][1];
        if(mde[i+1]=='A'){if(mde[i]=='B')dp[i+1][1]=dp[i][0];}
        else {dp[i+1][1]=dp[i][1];}
    }
}
int main()
{
    scanf("%s",mde+1);for(n=1;mde[n+1]!='\0';n++);mde[n+1]=mde[1];
    dp[1][0]=1;dypr();res+=dp[n+1][0];
    for(int i=1;i<=n+1;i++)dp[i][0]=dp[i][1]=0;
    dp[1][1]=1;dypr();res+=dp[n+1][1];
    printf("%I64d",res);
}
```


---

## 作者：dami826 (赞：0)

没有 dp，纯找规律。  

首先发现，能够发生更改的位置只有形如 `BA` 的子串，可以选择翻转或不翻转。其次发现 `BA` 连续出现时会互相影响，所以考虑寻找每一段连续的 `BA...BA`，这可以 $O(n)$ 完成。

那么翻转若干个 `BA` 后，不合法的情况即为翻转后的字符串中存在不是由原字符串中的 `BA` 翻转而来的 `AB` 子串。

对于每一段连续的 `BA` ，容易发现不能有两个连续的 `BA` 都不翻转，否则会在原串中出现 `BABA`，此时中间的 `AB` 需要进行翻转，这样得到的就不是给出的字符串了。  
手推几个样例后发现在“没有两个连续的 `BA` 都不翻转”的限制下，$len$ 个 `BA` 拼接所带来的方案数为斐波那契数列的第 $len+2$ 项。  
***  
证明：  
设 $a_i$ 表示 $i$ 个 `BA` 拼接所带来的方案数。    
如果最后一个 `BA` 翻转，那么前面的 $i-1$ 个 `BA` 的翻转方案可以是任何满足条件的长度为 $i-1$ 的方案。这种情况下数目是 $a_{i-1}$。  
如果最后一个 `BA` 不翻转，那么倒数第二个 `BA` 必须翻转（否则会形成两个连续的 `BA` 都不翻转）。所以在这种情况下，除了倒数第二个 `BA` 外，那么前面的 $i-2$ 个 `BA` 的翻转方案可以是任何满足条件的长度为 $i-2$ 的方案。这种情况下数目是 $a_{i-2}$。  
因此，递推关系式为 $a_i = a_{i-1} + a_{i-2}$。这明显是斐波那契数列的递推关系。  
枚举得 $a_1=2 ,a_2=3$ ，为斐波那契数列的第 $3,4$ 项，又根据递推关系式，得证。  
***  
接下来考虑每段连续的 `BA` 两端的字符对其的影响。 

+ 对于左端的字符：容易发现，当左端字符为 `A` 时，第一个 `BA` 必须翻转，否则会出现 `ABA` 导致出现不是由 `BA` 翻转而来的 `AB`，而这会使得总方案数变为 $a_{len-1}$；而当左端字符为 `B` 时，没有任何限制。
+ 对于右端的字符：同理，当右端字符为 `A` 时，没有任何限制；而当右端字符为 `B` 时，最后一个 `BA` 必须翻转，否则会出现 `BAB` 中的 `AB`，此时总方案数变为 $a_{len-1}$。
  
总结：当左端字符为 `A` 时，`len--;` ，当右端字符为 `B` 时同理。

另外，当 `BA` 首尾相接，不存在两端字符的情况，此时限制条件仍为“没有两个连续的 `BA` 都不翻转”，但此时首尾相接，所以第一个和最后一个也不能同时不翻转。  
结论为 $a_1=1,a_2=3$，对于 $i \geq 3$，$a_i=a_{i-1}+a_{i-2}$。  
证明是相似的，此处不再赘述。  
综上，设 $a_1=1,a_2=3,a_i=a_{i-1}+a_{i-2}(i \geq 3)$，$b_1=2,b_2=3,b_i=b_{i-1}+b_{i-2}(i \geq 3)$，$n$ 为字符串长度：
+ 若字符串全部为 `BA` 循环，则答案为 $a_{\frac{n}{2}}$
+ 否则答案为 $\prod res$，其中当左端字符为 `B`，右端字符为 `A` 时，$res=b_{len}$；当左端字符和右端字符相同时，$res=b_{len-1}$； 当左端字符为 `A`，右端字符为 `B` 时，$res=b_{max(len-2,0)}$。

时间复杂度 $O(n)$。  

**AC Code**
```cpp
#include<bits/stdc++.h>
#define int long long
#define OK puts("OK"); 
using namespace std;
string str2;
char str[101]; 
int n,ans=1,cnt,start,finish,a[101],b[101],mov=-1;
bool flag=0;
signed main(){
	b[0]=1;
	a[1]=1;
	b[1]=2;
	a[2]=b[2]=3;
	for(int i=3;i<=50;i++){
		a[i]=a[i-1]+a[i-2];
		b[i]=b[i-1]+b[i-2];
	}
	cin>>str2; 
	n=str2.length();
	for(int i=3;i<n;i++){
		if(str2[i-3]=='A'&&str2[i-2]=='A'&&str2[i-1]=='B'&&str2[i]=='B'){
			printf("0\n");
			return 0;
		}
	}
	for(int i=0;i<n;i++){
		if(str2[i]=='A'){
			continue;
		} 
		if(str2[(i+1)%n]=='A'&&(str2[(i+n-1)%n]!='A'||str2[(i+n-2)%n]!='B')){
			mov=(i+1)%n;
			break;
		}
	}
	for(int i=0;i<n;i++){
		if(str2[i]==str2[(i+n-1)%n]){
			flag=1;
		}
	}
	if(!flag){
		printf("%lld\n",a[n/2]);
		return 0;
	}
	if(mov==-1){
		printf("1\n");
		return 0; 
	}
//	cout<<str2<<" "<<mov<<endl;
	for(int i=0;i<n;i++){
		str[i]=str2[(mov+i)%n];
//		printf("%c",str[i]);
	} 
//	printf("\n");
//	return 0;
	for(int i=0;i<n;i++){
//		printf("i %d\n",i);
		while(i<n&&str[i]=='A'&&str[(i+n-1)%n]=='B'){
			if(cnt==0){
				start=(i+n-1)%n;
			}
			cnt++;
			i+=2;
		}
		if(cnt==0){
			continue;
		}
//		printf("after i %d\n",i);
		i-=2;
		finish=i;
//		printf("%d %d %d\n",cnt,start,finish);
//		OK
		if(str[(finish+1)%n]=='B'){
			cnt--;
		}
		if(str[(start+n-1)%n]=='A'){
			cnt--;
		}
//		printf("cnt %d\n",cnt);
		ans*=b[max(cnt,0ll)];
		cnt=0;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


# Anya's Simultaneous Exhibition

## 题目描述

这是一个交互题。

Anya 聚集了 $n$ 位国际象棋高手，编号从 $1$ 到 $n$，并且满足以下性质：

- 对于任意一对选手，总有一方能在每场比赛中战胜对方（且不会出现平局）；
- 但不一定满足传递性——可能存在 $A$ 总是战胜 $B$，$B$ 总是战胜 $C$，而 $C$ 总是战胜 $A$。

Anya 并不知道每一对选手中谁能战胜谁。为了组织一场锦标赛，Anya 会举办 $n-1$ 场比赛。每场比赛，她选择两名选手，其中一人获胜并留下，另一人被淘汰。所有比赛结束后，只剩下一名选手。若某位选手有可能赢得锦标赛（注意，最终的获胜者可能取决于 Anya 在 $n-1$ 场比赛中选择的选手），则称该选手为候选大师。

由于 Anya 很好奇，她想找出所有的候选大师。但她时间有限。为了加快进度，她最多会组织 $2n$ 场“simul”（即“同时对弈”，一名选手同时与多名选手对弈）。

在一场 simul 中，Anya 选择一名选手，让其与其他一些（至少一名）选手对弈。被选中的选手会赢下所有他在常规比赛中能赢的对局，输掉所有他在常规比赛中会输的对局。simul 结束后，Anya 只会被告知该选手赢了多少场（但不会告知具体赢了哪些对手）。simul 期间没有人会被淘汰。

你能帮助 Anya 通过组织 simul 找出所有候选大师吗？

每一对选手的胜负关系在不同的 simul 之间可以改变，但必须保证所有已知 simul 的结果不变。这些改变可以依赖于你的查询。

## 说明/提示

在第一个样例中，第一次查询描述的是选手 $1$ 与选手 $2$ 的 simul。查询结果为 $1$，说明 $1$ 战胜了 $2$。同理，第二次查询说明 $2$ 战胜了 $3$，第三次查询说明 $3$ 战胜了 $1$。因此所有选手都是候选大师，因为：

- 若 $2$ 和 $3$ 先比赛，$3$ 输掉并被淘汰，$2$ 留下。然后 $1$ 与 $2$ 比赛并获胜；
- 其它选手也可以用类似方式获胜。

在第二个样例中，第三次查询描述的是选手 $1$ 与所有其他选手的 simul。查询结果为 $4$，说明他战胜了所有对手。可以推断 $1$ 能战胜所有其他选手，因此他总能获胜，是唯一的候选大师。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3

1

1

1```

### 输出

```
? 1 010

? 2 001

? 3 100

! 111```

## 样例 #2

### 输入

```
5

0

3

4```

### 输出

```
? 5 10110

? 2 10111

? 1 01111

! 10000```

# 题解

## 作者：蒟蒻君HJT (赞：7)

交互题用错误的询问次数故意误导选手太恶劣了。

## 思路：

这是一种只需要 $n-1$ 次操作的做法。

假设我们已经知道了所有人之间的关系，若 $i$ 能打败 $j$ 则连有向边 $(i,j)$，在此有向图中缩点，拓扑序最小的强连通分量中的点是可以获胜的。

由于任意两点间一定存在一条边，所以可以证明此强连通分量必唯一。

假设这个强连通分量的大小为 $s$ ，那么有以下性质：此强连通分量中的点出度至少为 $n-s$ ，而其余点出度至多为 $n-s-1$ 。

于是不难想到用 $n-1$ 次询问得到所有点的出度（最后一个点不用问，减一减就好了）。

得到出度 $d_i$ 后，我们按照出度从大到小给点排序。设排完序后的点为 $v_1,v_2,...v_n$ ，对应出度为 $d_1,d_2,...d_n$，满足 $d_i$ 不升。由有关度数的性质，答案一定为 $v_i$ 的一段前缀（很重要）。

从 corner case 开始考虑：若 $d_1=n-1$ ，则答案为 $v_1$，当我们推进到 $2$ 号点的时候，我们知道 $1$ 和 $2$ 之间一定有一条边（不用管具体方向），于是可以得出这两个点向后 $n-2$ 个点连边的数量是 $d_1+d_2-1$。依此类推，前 $m$ 个点向后 $n-m$ 个点连边的数量为 $\sum_{i=1}^md_i-\frac{m(m-1)}{2}$。

我们猜想，当第一次遇到前 $m$ 个点向所有后 $n-m$ 个点均连边的时候，就说明前 $m$ 个点是拓扑序最小的强连通分量。即，从前向后扫描，当扫描到 $v_m$ ，第一次发现等式 $(\sum_{i=1}^{m}d_i)-\frac{m(m-1)}{2}=m(n-m)$ 成立时，可以得出答案是 $v_1,v_2,...v_m$ 。

为什么？利用反证法证明。（这一段如果只是做题的话没必要看，感性理解即可）

我们认为前 $m$ 个点形成了拓扑序最小的强连通分量。

假设实际上是前 $t$ 个点形成了一个拓扑序最小的强连通分量。

- $\text{Case 1}$：$t<m$，那么我们在扫描到 $t$ 时等式已经成立，与 $m$ 的首次性矛盾；

- $\text{Case 2}$：$t>m$，矛盾在于：由上文的等式，$v_{m+1},v_{m+2},...v_{t}$ 没有连向 $v_1,v_2...v_m$ 的边，所以它们一定不存在能回到前 $m$ 个点的路径，也就是说它们的拓扑序一定是大于前 $m$ 个点的，绝对不可能出现在与前 $m$ 个点相同的强连通分量中。

至此，命题得证。

## 代码：

```cpp
#include <bits/stdc++.h>
#define fuck fflush(stdout);
int n, d[255], e[255];
char s[255];
inline bool cmp(int x, int y){
  return d[x] > d[y];
}
int main(){
  scanf("%d", &n);
  for(int i = 1; i <= n - 1; ++i){
    for(int j = 1; j <= n; ++j){
      if(i == j) s[j] = '0';
      else s[j] = '1';
    }
    printf("? %d %s\n", i, s + 1);
    fuck;
    scanf("%d", &d[i]);
    e[i] = i;
    d[n] -= d[i];
  }
  e[n] = n;
  d[n] += (n - 1) * n / 2;
  std::sort(e + 1, e + n + 1, cmp);
  int ans = n, sum = 0;
  for(int i = 1; i <= n - 1; ++i){
    for(int j = 1; j <= n; ++j) s[j] = '0';
    for(int j = i + 1; j <= n; ++j) s[e[j]] = '1';
    printf("? %d %s\n", e[i], s + 1);
    fuck;
    int x;
    scanf("%d", &x);
    sum += x;
    sum -= (i - 1 - (d[e[i]] - x));
    sum += d[e[i]] + 1 - i;
    if(sum == i * (n - i)){
      ans = i;
      break;
    }
  }
  for(int i = 1; i <= n; ++i) s[i] = '0';
  for(int i = 1; i <= ans; ++i) s[e[i]] = '1';
  printf("! %s\n", s + 1);
  fuck;
  return 0;
}
```


---

## 作者：StudyingFather (赞：6)

给一个 [官方题解](https://codeforces.com/blog/entry/110629) Bonus 部分中提到的“只进行 $n$ 次询问”的做法。

先考虑建立图论模型描述这个问题：对于 $u, v$ 两个人，如果 $u$ 战胜 $v$，则连边 $u \to v$，反之连边 $v \to u$。这样建立的图就是一个 **竞赛图**。

这个图显然有如下几个性质：

**引理 1**：如果一个人 $u$ 是候选冠军，则对于任意一个人 $v$，都存在一条 $u$ 到 $v$ 的路径。$\square$

**引理 2**：所有候选冠军构成一个强连通分量。$\square$

考虑对这个竞赛图的所有强连通分量缩点，有结论：

**定理 1**：对竞赛图缩点后，形成的图是一条链的传递闭包。即，链中的每个点向后面的每个点都连一条边，且 $\forall u, v$，如果 $u$ 在 $v$ 前面，则 $u$ 中所有点的入度都小于 $v$ 中所有点的入度。

**证明**：

首先明确一点，竞赛图缩点后仍然是竞赛图，因此任意两个强连通分量之间必定存在一条边相连。

如果图上只有一个或两个强连通分量，则定理显然成立。

否则，图上至少有三个强连通分量。考虑图上任意的三个强连通分量 $u, v, w$，首先，它们之间的连边不可能成环（否则它们就能组成更大的强连通分量了），从而只能形成定理 1 所描述的情况。

$\square$

因此，缩点后链上的第一个点对应的强连通分量就是我们要求的候选冠军的集合。

有了前面这些结论，已经可以推出官方题解所给的 $2n$ 次询问的做法了，这里不展开叙述。为了实现 $n$ 次询问，接下来给出一个定理。

**定理 2**：在竞赛图中，将所有点按入度升序排序后，若前 $n$ 个点的入度和为 $\dfrac{n(n-1)}{2}$，且不存在更小的 $n$ 满足这一条件，则这 $n$ 个点构成一个强连通分量。

**证明**：

考虑反证法。

1. $\exists m < n$，前 $m$ 个点构成一个强连通分量，考虑所有可能的 $m$ 中最小的那个，那么前 $m$ 个点就应该是链上的第一个强连通分量，这个强连通分量内所有点入度和的贡献应该只来自于内部两两连边，从而它们的入度和为 $\dfrac{m(m - 1)}{2}$，与“不存在更小的 $n$ 满足条件”矛盾。
2. $\exists m > n$，前 $m$ 个点构成一个强连通分量。前 $n$ 个点之间的两两连边已经让这些点的入度和等于 $\dfrac{n(n - 1)}{2}$，因此并不存在前 $n$ 个点之外的其他点向前 $n$ 个点连边的情况，从而前 $m$ 个点并不是强连通的。$\square$

（这个结论在 CF1498E 中也有用到）

因此我们得到如下算法：

1. 对于点 $i$，询问其与其他所有点的对战情况，得到 $i$ 的入度 $in_i$；
2. 将所有点按入度升序排序；
3. 找到最小的 $m$ 使得 $\sum_{i = 1}^m in_i = \dfrac{m(m-1)}{2}$，则前 $m$ 个点即为所求。

这样就只用 $n$ 次询问就完成任务了。当然最后一次询问事实上也是多余的，只要根据前面所有点的入度和就能算出最后一个点的入度，这样就是 $n - 1$ 次询问了（虽然意义不大）。

```cpp
// Problem: E. Anya's Simultaneous Exhibition
// Contest: Codeforces - Hello 2023
// URL: https://codeforces.com/contest/1779/problem/E
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit: 256 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <iostream>
using namespace std;
int in[305], id[305], ans[305];
int main() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cout << '?' << ' ' << i << ' ';
    for (int j = 1; j <= n; j++) cout << (i == j ? 0 : 1);
    cout << endl;
    cin >> in[i];
    in[i] = n - 1 - in[i]; // in + out = n - 1
    id[i] = i;
  }
  sort(id + 1, id + n + 1, [](int x, int y) { return in[x] < in[y]; });
  int sum = 0;
  for (int i = 1; i <= n; i++) {
    sum += in[id[i]];
    if (sum == i * (i - 1) / 2) {
      for (int j = 1; j <= i; j++) ans[id[j]] = 1;
      break;
    }
  }
  cout << "! ";
  for (int i = 1; i <= n; i++) cout << ans[i];
  cout << endl;
  return 0;
}
```

---

## 作者：arundo (赞：5)

CF1779E Anya's Simultaneous Exhibition 题解。

首先竞赛图缩点是链。链头的连通分量即为答案。

考虑先求出每个人和所有人比赛赢的局数，然后按照局数从大到小排序。第一个连通分量内的人的局数一定大于所有其他人，那么这些人构成排序后数组的一个前缀。

维护一个集合 $S$，表示预期的第一个连通分量的人。每次询问当前的人和 $S$ 中人的比赛情况，如果并非全输，将当前人及前面所有人更新为新的 $S$，否则什么都不做。不难证明这样是对的。

一共询问 $2n-1$ 次。

---

## 作者：Sol1 (赞：3)

这个 $2n$ 次的限制真的恶心……

首先有经典结论：竞赛图缩点后拓扑序唯一，我们需要求出缩点后没有出度的强连通分量里面的所有点。

直接使用 $n$ 次询问获取到所有点的入度 $d_u$。注意到，设答案点集为 $S$，那么对任意 $u\in S,v\notin S$，满足 $d_v<d_u$。

所以按 $d$ 排序，答案一定是一段后缀。

从小到大枚举后缀，如果某个后缀是答案，那么不在后缀里面的元素一定都向在后缀里面的元素连边。这一点可以直接通过统计从前面向后面连的边的边数进行判断。所以对于后缀 $[i,n]$，如果 $\sum_{j=i}^nd_j-(n-i)(n-i+1)/2=(n-i+1)(i-1)$，则 $[i,n]$ 就是答案。

所以 $n$ 次就做完了。

进一步，考虑到所有度数求和是 $n(n-1)/2$，可以省去一次询问，即官方题解提到的 $n-1$ 次。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 256;
int n, idx[N], cnt[N], vis[N];

int main() {
    cin >> n;
    for (int i = 1;i <= n;i++) {
        cout << "? " << i << " ";
        for (int j = 1;j <= n;j++) cout << (j != i);
        cout << endl;
        cin >> cnt[idx[i] = i];
    }
    sort(idx + 1, idx + n + 1, [&](const int &x, const int &y) {return cnt[x] < cnt[y];});
    int sum = 0;
    for (int i = n;i >= 1;i--) {
        sum += cnt[idx[i]];
        vis[idx[i]] = 1;
        if (sum - (n - i + 1) * (n - i) / 2 == (i - 1) * (n - i + 1)) break;
    }
    cout << "! ";
    for (int i = 1;i <= n;i++) cout << vis[i];
    cout << endl;
    return 0;
}
```

---

## 作者：masonpop (赞：2)

竞赛图经典套路。

对于一场两两对决的比赛，我们把任意两个人的胜利者向失败者连边，所成的就是竞赛图（可以理解成一张有向的完全图），它有着一些性质：

$\text{Lemma 1:}$ 竞赛图中，如果一个点有着最高的出度，那么它就是可能的胜利者。
* 考虑证明结论：**任意一个另外的点都可以从这个点出发经过最多两次到达。** 这样，我们显然可以安排出这样一个符合要求的淘汰赛使得这个点胜出。
* 我们设一次到达的点集 $S_1,$ 两次到达的点集 $S_2$。 若存在一个点 $x\not\in S_1,S_2$， 那么对于所有 $x\in S_1$ 以及那个度数最多的点，这个点必然和它们有有向边相连（注意竞赛图是完全图）。此时这个点的度数就过多了，矛盾。

$\text{Lemma 2:}$ 竞赛图缩点后是一条链的传递闭包结果，即一条链中，每个点都和它后面的所有点连有向边。
* 注意到竞赛图缩点后还是两两有边的竞赛图，因此分类讨论一下不难证明。

$\text{Lemma 3:}$ 竞赛图缩点后，链顶的 SCC 中任意一个点的出度都大于之后的 SCC 中所有点的出度。
* 由强连通分量的定义以及结论 $2$ 不难证明。

那么，我们只需要找出链首的那个 SCC 中的点就行了。先按照度数降序排列，那么答案一定是这个数组的一个前缀。我们考虑这些点满足什么性质。先考虑其必要条件。如果是前 $i,$ 个，由于这些点都和其它点有着有向边，那么容易用两种方法计算总出度并列出等式：$\sum\limits_{k=1}^ideg_k=\frac{i(i-1)}{2}+i(n-i).$ 

（等式右边相当于是把内部贡献和与外部点的贡献分开来算）

事实上，这个也是充分条件。

考虑证明。如果在真正的第一个 SCC，即前 $i$  个点之前就存在一个 $m$ 也满足条件，那么 $v_1,..,v_m$ 和 $v_{m+1},..,v_i$ 两两有从左到右的边。那么就没有从右面回去的边，和它们同在一个 SCC 中矛盾。

故这样判断是正确的。$O(n\log n).$ [代码](https://codeforces.com/contest/1779/submission/209067904)。

---

## 作者：zac2010 (赞：2)

这是我的第一道交互题。

然后挂了好久，错误的改正如下：
* 每个输入或者输出完就要一句 `fflush(stdout);`。
* 询问的时候对于 $i$ 号点不要把第 $i$ 位置 $1$，不然的话会答案错误（因为自己和自己对决测评机不知该如何回答你）。

### 思路

首先，我们先来明确一个定义：竞赛图。对于这道题目，我们如果把节点两两之间连一条有向边，由这两个节点比赛的胜者指向败者，那么会形成一张**任意两个节点之间有且仅有一条有向边**的竞赛图。

* 结论 $1$：假设已经知道了连边情况，我们把竞赛图进行强联通缩点，那么得到的有向无环图中每个节点会向自己后面的节点连边。严谨地说，有向无环图的最长链的节点个数等于这个图的节点个数，且最长链上的节点每个朝着自己后面的所有节点连边。

	![](https://cdn.luogu.com.cn/upload/image_hosting/i5m2y0x8.png)

* 证明 $1$：这个不难，我们发现假设有后面的点连向前面的话，必定会再构成一个更大的强联通分量，所以必定是前面的节点只想后面，而因为原图两两之间有连边，所以新图的两个点之间也有连边，所以就成了图上见到的样子。

* 结论 $2$：原图中每个点会向新图中所处的强联通分量之后的强联通分量的所有点连边。

	其实有点绕，那就比如说上面的那张图的 $3$ 号强联通分量在原图中的点会向上面的 $4$ 强联通分量在原图中的点连边。

* 证明 $2$：因为两两之间有连边，不是你连我就是我连你，如果前面的强联通分量中的点不连向后面的强联通分量中的点，那么就是后面连前面，那就成环了，然而我们知道缩点后不存在环，所以得证。

* 结论 $3$：对于这个有向无环图的唯一入度为 $0$ 的节点，即拓扑序最小的节点、上图中的 $1$ 号点，他里面的所有节点就是答案。

* 证明 $3$：这个显而易见，因为 $1$ 中的所有节点是可以互达的，也就意味着任意一个节点可以通过其他人打败 $1$ 中的所有人。那么再考虑后面的强联通分量，前面的可以通过边打败后面的是显然，而后面的也没有途径能打败前面的（因为没有连向前面的边）。

* 结论 $4$：前面的强联通分量的点的出度严格大于后面强联通分量的点的出度。

* 证明 $4$：因为前面的点指向后面的所有点，他的出度大于等于后面点的个数；后面的点会向除自己以外更后面的点连边，所以会严格小于前面的点的出度。

那么我们通过 $n-1$ 次询问得知前 $n-1$ 个点的出度（设 $i$ 号点的出度为 $d[i]$），最后一个点的出度可以拿总出度 $n \times (n-1)/2$ 减去前 $n-1$ 个点的出度和得到，即 $d[n] = n \times (n-1)/2 - \sum_{i=1}^{n-1}d[i]$。我们按照 $d$ 数组的值从大到小对每个点排序，那么又有：
* 结论：最终答案一定是以有序数组的前缀的形式出现。
* 证明：因为第一个的强联通分量中的点（即所有满足条件的点）出度大于后面的所有点，具体可以看上述的结轮 $4$。

而我们又怎么求哪一段前缀是答案呢？不妨假点 $u$ 排序后处在 $i$ 个位置，那么可知前 $i$ 个点之间两两连边对出度的贡献和是 $i \times (i-1)/2$，而前 $i$ 个点总共的出度表示为 $\sum_{j=1}^id[j]$，又可知前 $i$ 个点向后面的 $n-i$ 个点连边产生的出度和为 $\sum_{j=1}^id[j]-i \times (i-1)/2$，于是排序后的 $1$ 号位置到第一个满足 $\sum_{j=1}^id[j]-i \times (i-1)/2 = i \times (n-i)$ 的位置这段区间的节点即为答案。

我们思考怎么证明。首先，答案存在这点不可否认。那么，通过结论 $2$，我们知道了对于可能回获胜的点（即答案）来说，每个点向后面的强联通分量所连出去的边的出度和为 $n-i$，也就是后面的点数，那么前面有 $i$ 个点，所以满足每个点都想后面的所有点连边也就要满足上面一段中的那个式子。

其次，第一个强联通分量必定是第一个满足上面式子的。我们可以利用反证法证明，假设强联通分量内部少了一些点却依旧满足上式，那么又有这是一个强联通分量，每个点一定会有连向强联通分量内部其他点的边，而由于假设里面选择的那些点根据性质 $2$ 会向剩下每个点都连一条边，那就根本不可能组成一个强联通分量，故得证。

```cpp
#include <bits/stdc++.h>
#define L(i, a, b) for(int i = a; i <= b; i++)
#define R(i, a, b) for(int i = a; i >= b; i--)
using namespace std;
const int N = 251;
int n, sum, id[N], d[N], ans[N];
char s[N];
bool cmp(int i, int j){return d[i] > d[j];}
int main(){
	scanf("%d", &n);
	fflush(stdout);
	L(i, 1, n) id[i] = i, s[i] = '1';
	L(i, 1, n){
		if(i == n) d[i] = n * (n - 1) / 2 - sum;
		else{
		    s[i] = '0';
			printf("? %d %s\n", i, s + 1);
			s[i] = '1';
			fflush(stdout);
			scanf("%d", &d[i]), sum += d[i];
			fflush(stdout);
		}
	}
	sort(id + 1, id + n + 1, cmp);
	sum = 0;
	L(i, 1, n){
		sum += d[id[i]];
		if(sum - i * (i - 1) / 2 == i * (n - i)){
			putchar('!'), putchar(' ');
			L(j, 1, i) ans[id[j]] = 1;
			L(j, 1, n) putchar(ans[j] + '0');
			fflush(stdout);
			return 0;
		}
	}
	return 0;
} 
```

---

## 作者：2018ljw (赞：1)

是 $n-1$ 次询问的附加题捏。

首先要清楚，$n$ 个人之间的胜负关系构成一张竞赛图，规定 $x$ 向 $y$ 连边表示 $x$ 能赢 $y$。那么我们淘汰赛在进行的，实质上就是每次删掉一个有入度的点和与其相连的所有边，问最后哪些点可能剩下。

对于一个强连通分量，只考虑每个强连通分量构成的子图，由于存在哈密顿回路，因此最后每个点都可能剩下。考虑将图缩点。

缩点后的图一定是一个 DAG，观察它的最长链，起点对应的分量就是答案。因为不管怎么删都会剩一个点向所有剩下的点有边。

然后就是如何找第一个强连通分量了。下面讨论这条最长链的前后时，规定靠近链首为前。

先看一个很显然的结论：如果两个点满足 $y$ 所在的连通分量在 $x$ 后面，这两个点出度必有 $d_x>d_y$。这个结论的逆命题是不成立的，但我们可以推出一个更有用的结论：

每个强连通分量中，点的出度都在一个区间内，这些区间两两不交且越靠前的强连通分量，对应区间的左端点越大。

因此我们有一个可行的策略，使用 $n-1$ 次询问问出每个点的出度（剩一个点需要计算得到），从大到小枚举出度临界值 $d$，把出度 $\ge d$ 的点选出，构成有 $k$ 个点的点集 $S$。

$S$ 有两种情况，一种是由构成完整分量，一种是包含某个分量中一部分点。

前者中最大的 $d$ 就是答案，其充要条件为 $S$ 中所有点的入度和为 $\binom k2$，而入度和又可以通过出度算，这题就做完了。
```cpp
#include<cstdio>
#include<algorithm>
#define clr() fflush(stdout)
using namespace std;
int ot[501],id[501];
bool cmp(int x,int y){
	return ot[x]>ot[y];
}
int main(){
	int i,j,n;
	scanf("%d",&n);
	clr();
	for(i=1;i<n;i++){
		id[i]=i;
		printf("? %d ",i);
		for(j=1;j<=n;j++)printf("%d",i!=j);
		printf("\n");
		clr();
		scanf("%d",&ot[i]);
		clr();
	}
	ot[n]=n*(n-1)/2;id[n]=n;
	for(i=1;i<n;i++)ot[n]-=ot[i];
	sort(id+1,id+n+1,cmp);
	int rd=0;
	for(i=1;i<=n;i++){
		if(i!=n&&ot[id[i]]==ot[id[i+1]])continue;
		if(ot[id[i]]<n-i)continue;
		long long bs=i*(i-1)/2,sm=0;
		for(j=1;j<=i;j++)sm+=ot[id[j]]-(n-i);
		if(sm==bs){
			rd=ot[id[i]];
			break;
		}
	}
	printf("! ");for(i=1;i<=n;i++)printf("%d",ot[i]>=rd);
	clr();
}
```

---


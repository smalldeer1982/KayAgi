# Lift and Throw

## 题目描述

给定一条被划分为单位长度区间的直线半轴，我们称这些区间为“位置”。位置从半轴的起点开始按正整数编号，即 $1$、$2$、$3$，依此类推。两个位置之间的距离为它们编号的绝对差。

Laharl、Etna 和 Flonne 分别占据半轴上的某些位置，他们希望到达编号尽可能大的位置。三人最初分别站在不同的位置。

每个人最多可以各自执行以下每种操作一次：

- 移动一定距离。
- 抓住另一个角色并将其举过头顶。
- 将被举起的角色投掷到一定距离外。

每个人都有一个移动范围参数。只有当两个位置之间的距离不超过该角色的移动范围时，他才能移动到空闲的位置。

当两个人之间的距离为 $1$，且被抓的人没有被其他人抓住时，一个角色可以抓住另一个角色。被抓的人会移动到抓住他的人所在的位置，原先的位置变为空闲。被抓的人不能再执行任何操作，抓住别人的人也不能移动。

每个人还有一个投掷范围参数，表示他能将被举过头顶的人投掷到多远。只有在有被举起的人时，才能将其投掷到空闲的位置。

允许出现一人抓住另一人，而被抓的人又抓住第三人的情况，这样会形成一个三人“柱子”。例如，Laharl 可以抓住 Etna，而 Etna 又抓住 Flonne。在这种情况下，Etna 和 Flonne 都不能执行任何操作，Laharl 只能将 Etna（连同 Flonne 一起）投掷出去。

Laharl、Etna 和 Flonne 可以以任意顺序执行操作。每次只能有一个人执行操作，不能同时进行。

请你计算，三人中至少有一人能够到达的最大位置编号是多少。也就是说，求最大的 $x$，使得三人中至少有一人能到达位置 $x$。

## 说明/提示

下面解释样例中如何到达位置 $15$。

初始时，Laharl 在位置 $9$，Etna 在位置 $4$，Flonne 在位置 $2$。

首先，Laharl 移动到位置 $6$。

然后，Flonne 移动到位置 $5$，并抓住 Etna。

Laharl 抓住 Flonne，并将其投掷到位置 $9$。

Flonne 将 Etna 投掷到位置 $12$。

Etna 移动到位置 $15$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
9 3 3
4 3 1
2 3 3
```

### 输出

```
15```

# 题解

## 作者：Twig_K (赞：4)

搜索（加一些剪枝）。

----------

给三个人编号 $0$ 到 $2$。

需要在 dfs 过程中动态维护的一些信息：

- 三个人当前的位置 `a[i]`
- 有没有移动**过** `moved[i]`，有没有举起**过**人 `lifted[i]`。（因为只有举起来之后才能扔出去，所以没必要特别维护有没有扔过人。）
- 如果**正在**举起别人，举起了谁 `lift_who[i]`。如果没有举起任何人，则 `lift_who[i]=3`。
- **此刻**是否正**被**举起。

每次 dfs 时，枚举操作者编号 $p \in [0,2]$，依次考虑移动，举起，扔出去三个操作。

- 如果 $p$ 自己正在被举起，那么什么也做不了，直接跳过。
- 移动：
   - 条件：先前没有移动过，且当下并没有举着别人（`lift_who[p]==3`）。
   - 范围：①（必要条件）不能超过最大移动距离；②（剪枝）如果他是最靠左的那个，他不必再向左走；③（剪枝）如果他不是最靠左的那个，他最左只需要走到最左边人的恰好左边。再往左不会使答案更优。
- 举起：
    - 条件：存在一个人 $q$，他和 $p$ 距离为 1，且他现在并没有被举起。
- 放下（扔出去）：
  - 条件：$p$ 此刻需要举着人。
  - 注意，需要考虑 $q$ 有没有举起第三个人 $r$。如果有，那么 $q$ 和 $r$ 的位置都要更新。
  - 范围：和移动操作同理，可以剪枝优化。

剩下的细节主要是 dfs 过程中的回溯，可以看代码。

```cpp
#include<bits/stdc++.h>
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define For(i,il,ir) for(register int i=il;i<=ir;++i)
#define Forr(i,ir,il) for(register int i=ir;i>=il;--i)
using namespace std;

int a[4],ans;//下标从 0 开始，给三个人编号 0/1/2。a[i] 为当前的位置 
int lft_who[4];//举起了谁，值为 0/1/2（如果没有举起别人则 lift_who[i]=3） 
bool be_lifted[4];//是否被举起（如果 be_lifted[i]==1 则不能进行任何操作） 
bool moved[4],lifted[4];//有没有移动过；有没有举起过别人（不需要考虑只能扔一次的问题，因为已经限制了只能举起一次） 
int mxMove[4],mxThrow[4];//最大移动距离；最大投掷距离 

void dfs(int dep)
{
	ans=Max(Max(ans,a[0]),Max(a[1],a[2]));
	int mn=Max(Min(a[0],Min(a[1],a[2]))-1,1);
	//三个人中最靠左者的坐标减一（即如果要往回走或者往回扔，最多停留在这个人的左边一个，更靠左不会有更优的答案 
	For(p,0,2)//枚举做出动作的人 
	{
		if(be_lifted[p]) continue;//如果 p 被举起，则不能做任何动作 
		if(!moved[p]&&lft_who[p]==3)//没有移动过，且没有举起别人（举起别人的人不能移动） 
		{
			int l=Max(a[p]-mxMove[p],mn),r=a[p]+mxMove[p];//l 和 r 是能到的左右边界 
			if(dep==9) l=r;//如果是最后一步操作，只考虑最远的地方是否可行，这样一定不劣（即使那个位置有人） 
			else if(mn+1==a[p]) l=a[p]+1;//如果 p 是最靠左的那个，只向右走一定不劣 
			For(i,l,r)
				if(i^a[0]&&i^a[1]&&i^a[2])//不能有人，也不是自己原来的位置 
				{
					int tmp=a[p];
					a[p]=i,moved[p]=1;
					dfs(dep+1);
					a[p]=tmp,moved[p]=0;//全局数组，要回溯 
				}
		}
		if(!lifted[p]) For(q,0,2) //如果没有举起过别人，则枚举 p 举起的人 q 
			if(!be_lifted[q]&&abs(a[p]-a[q])==1)//要求 q 不能被举起，且距离为 1 
			{
				int tmp=a[q];
				lifted[p]=1,lft_who[p]=q,be_lifted[q]=1,a[q]=a[p];
				dfs(dep+1);
				lifted[p]=0,lft_who[p]=3,be_lifted[q]=0,a[q]=tmp;
			}
		if(lft_who[p]!=3)//lft_who 的值不为 3，说明 p 当前举着别人 
		{
			int l=Max(a[p]-mxThrow[p],mn),r=a[p]+mxThrow[p];
			if(dep==9) l=r;
			else if(mn+1==a[p]) l=a[p]+1;//l,r 的边界与 Move 操作同理 
			For(i,l,r)
				if(i^a[0]&&i^a[1]&&i^a[2]) 
				{
					int q=lft_who[p],r=lft_who[q],tmp=a[p];
					//需要考虑 A 举起 B，B 又举起 C 的情况，r 是 q 举起的人（如果 q 又有举起第三个人的话），如果 r=3 也是不影响的 
					lft_who[p]=3,be_lifted[q]=0,a[q]=a[r]=i;
					dfs(dep+1);
					lft_who[p]=q,be_lifted[q]=1,a[q]=a[r]=tmp;
				}
		}
	}
}
signed main()
{
	For(i,0,2) scanf("%d%d%d",&a[i],&mxMove[i],&mxThrow[i]),lft_who[i]=3;
	dfs(1),printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Lijunzhuo (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/CF105E)  

这是一道模拟题，需要根据给定的规则进行模拟操作，找出能够到达的最远位置。

首先，我们可以将问题简化为三个人的相对位置和移动范围、投掷范围。假设初始位置为 $A$、$B$、$C$，移动范围为 $m_A$、$m_B$、$m_C$，投掷范围为 $t_A$、$t_B$、$t_C$。

我们可以通过模拟操作来找出能够到达的最远位置。具体步骤如下：

  1. 假设 $A$ 为当前操作的人，首先判断 $A$ 是否可以移动。如果可以移动，则 $A$ 可以移动到任意一个没有人占据的位置，且移动距离不超过 $m_A$。  
  2. 如果 $A$ 无法移动，则判断 $A$ 是否可以举起 $B$。如果可以举起 $B$，则 $B$ 移动到 $A$ 的位置上。  
  3. 如果 $A$ 无法移动并且无法举起 $B$，则判断 $A$ 是否可以举起 $C$。如果可以举起 $C$，则 $C$ 移动到 $A$ 的位置上。  
  4. 如果 $A$ 无法移动并且无法举起其他人，则判断 $A$ 是否可以投掷 $B$。如果可以投掷 $B$，则 $B$ 被投掷到任意一个没有人占据的位置，且投掷距离不超过 $t_A$。  
  5. 如果 $A$ 无法移动、举起其他人或投掷其他人，则判断 $B$ 是否可以移动。如果可以移动，则 $B$ 可以移动到任意一个没有人占据的位置，且移动距离不超过  $m_B$。同样的规则适用于 $C$。  
  6. 重复步骤 $2$-$5$，直到所有人都无法移动、举起其他人或投掷其他人。
在模拟操作的过程中，记录每个人能够到达的最远位置，最后取其中的最大值即为答案。

需要注意的是，根据题目描述，可以存在一个人举起另外两个人的情况，但只有举起其他人的人可以进行操作。因此，在模拟操作时，需要考虑这种情况。

下面给出具体的实现步骤：

1. 读入输入数据，包括初始位置和移动范围、投掷范围。  
2. 初始化每个人的最远位置为其初始位置。  
3. 使用一个循环来模拟操作，直到所有人都无法移动、举起其他人或投掷其他人：  
	- 遍历每个人，按顺序进行操作。  
   - 判断当前人是否可以移动，如果可以移动，则更新其最远位置。  
	- 如果当前人无法移动，并且可以举起其他人，则执行举起操作，更新被举起人的位置。  
	- 如果当前人无法移动、且无法举起其他人，并且可以投掷其他人，则执行投掷操作，更新被投掷人的位置。  
4. 输出所有人能够到达的最远位置中的最大值。

以上就是解题的思路和步骤。通过模拟操作，我们可以找出能够到达的最远位置。

---

## 作者：Dehydration (赞：0)

## 前言：

真是大模拟啊，这道题目其实很简单，因为只有三个人，直接深搜，但代码量有点大，看没有人写题解，就来水一发，给你们提供一下细节的对照。

ps：[题目](https://www.luogu.com.cn/problem/CF105E)。

## 思路：

分步走，一个人一个人来，讲情况分出更详细。

### \#1：

定义数组，用 ```struct``` 来定义，列举出有没有扔过，有没有走过，在不在被人举着等等。

参考代码:

```
struct People
{
    int pos;
    bool lifted;//正在被举着
    bool lifting;//正在举着别人
    int lift;//举着的是谁
    int maxMove;//最大移动距离
    int maxThrow;//最大抛距离
    bool hasMoved;//是否移动过
    bool hasLifted;//是否举过别人
    //没有必要加上是否抛过别人的标记，因为只能举起别人一次
}p[3];
```

### \#2：
很显然，只有 $9$ 种操作，我们可以定义一个 ```visit``` 数组看一下有没有操作完，然后进行深搜（大模拟），再函数中定义一个  $k$，如果 $k \equiv 0  \bmod 3 $ 则为这个人的动作为 ```move```，如果 $k \equiv 1  \bmod 3 $ 则为这个人的动作为 ```lift```，如果 $k \equiv 2  \bmod 3 $ 则为这个人的动作为 ```throw```，然后这个人的编号为 $\lfloor \frac{d}{3} \rfloor$，搞明白后就依照题目进行深搜即可。

其实动和扔动作的代码实现都很相似，而且举起十分简单，只是需要关注一些细节，这里就提供 ```move``` 部分的代码：

```
    if(!m) {
        //如果此人正在被别人举着或者正在举着别人，或者已经移动过了，那么他/她不能移动。
        if(p[n].lifted || p[n].lifting || p[n].hasMoved) return;

        int i = 1;
        if(step == 9) i = p[n].maxMove;//如果当前是最后一步，那么直接向前移动可以移动的最远的距离
        //如果不是最后一步，那么他也不必从他能移动的最靠后的距离开始搜索
        //他只需要从 他的位置之前的 有人的位置 的前一个位置 开始搜索即可
        //如果他后面没人，那么他走的距离只需要从1开始搜索，不需要往后走，只需要往前走
        else {
            for(int j = 1; j < p[n].pos; j++) {
                if(Pos[j]) {
                    int l = -(p[n].pos - j -1);
                    i = l < i ? l : i;
                }
            }
            //走的距离不能超过maxMove
            i = i > -p[n].maxMove ? i : -p[n].maxMove;
        }
        for(; i <= p[n].maxMove; i++) {
            if(Pos[p[n].pos+i-1] || Pos[p[n].pos+i+1] || i == p[n].maxMove){
                if(p[n].pos + i > 0 && !Pos[p[n].pos + i]) {
                    if(!i) continue;

                    Pos[p[n].pos] = false;//当前位置置为false
                    p[n].pos += i;//向前走
                    Pos[p[n].pos] = true;//走到的新位置置为true
                    p[n].hasMoved = true;//标记一下，已经移动过了
                    Max = p[n].pos  > Max ? p[n].pos : Max;//记录最大距离

                    //继续搜索
                    for(int j = 0; j < 9; j++) {
                        if(!visit[j]) {
                            visit[j] = true;
                            dfs(j, step+1);
                            visit[j] = false;//回溯
                        }
                    }
                    //回溯
                    p[n].hasMoved = false;
                    Pos[p[n].pos] = false;
                    p[n].pos -= i;
                    Pos[p[n].pos] = true;
                }
            }
        }
    } 
```

### \#3：

我们弄完深搜函数就要进行主函数了，非常简单，输入然后从 $0$  开始遍历所有的动作进行搜索，但显然从先开始仍不合理，不让     $i \equiv 2  \bmod 3$ 直接开始即可。



代码：

```
int main()
{
    //输入
    for(int i = 0; i < 3; i++) {
        cin >> p[i].pos >> p[i].maxMove >> p[i].maxThrow;
        p[i].lifted = p[i].lifting = p[i].hasMoved = p[i].hasLifted = false;
        p[i].lift = -1;
        Pos[p[i].pos] = true;
    }
    //深搜
    for(int i = 0; i < 9; i++) {
        //一个合法的第一步，不可能是抛。必须先移动或者举起别人
        if((i % 3) != 2) 
        {
            visit[i] = true;
            dfs(i, 1);
            visit[i] = false;//回溯
        }
    }
    //结果
    cout << Max << endl;
    return 0;
}
```

完结撒花！已经AC！

写题解不易，点个赞吧！

---


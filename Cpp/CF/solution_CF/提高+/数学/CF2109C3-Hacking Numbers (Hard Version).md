# Hacking Numbers (Hard Version)

## 题目描述

这是该问题的困难版本。在此版本中，你能发送的指令限制将在题目描述中说明。只有在解决所有版本的问题后才能进行 hack。

这是一个交互式问题。

欢迎，决斗者们！在这个交互式挑战中，存在一个未知整数 $x$（$1 \le x \le 10^9$）。你需要通过利用"Mathmech"怪兽的力量，将其变为输入中给定的整数 $n$。你可以发送以下指令之一：

| 指令          | 约束条件                          | 结果                  | 更新操作                 | 裁判响应 |
|---------------|-----------------------------------|-----------------------|--------------------------|----------|
| "add $y$"     | $-10^{18} \le y \le 10^{18}$      | $\mathrm{res} = x + y$ | 若 $1 \le \mathrm{res} \le 10^{18}$，则 $x \leftarrow \mathrm{res}$ | "1"      |
|               |                                   |                       | 否则 $x \leftarrow x$    | "0"      |
| "mul $y$"     | $1 \le y \le 10^{18}$             | $\mathrm{res} = x \cdot y$ | 若 $1 \le \mathrm{res} \le 10^{18}$，则 $x \leftarrow \mathrm{res}$ | "1"      |
|               |                                   |                       | 否则 $x \leftarrow x$    | "0"      |
| "div $y$"     | $1 \le y \le 10^{18}$             | $\mathrm{res} = x/y$  | 若 $y$ 整除 $x$，则 $x \leftarrow \mathrm{res}$ | "1"      |
|               |                                   |                       | 否则 $x \leftarrow x$    | "0"      |
| "digit"       | —                                 | $\mathrm{res} = S(x)$ $^{\text{∗}}$ | 总是 $x \leftarrow \mathrm{res}$ | "1"      |

设 $f(n)$ 为最小整数，使得对于所有 $x$（$1 \le x \le 10^9$），都存在一个由 $f(n)$ 条指令组成的序列能将 $x$ 转换为 $n$。你事先不知道 $x$ 的值。你需要找到这样的 $f(n)$，使得无论 $x$ 是多少，你都能用最多 $f(n)$ 条指令将其转换为 $n$。

你的任务是用最多 $f(n)$ 条指令将 $x$ 变为 $n$。

$^{\text{∗}}$ $S(n)$ 是一个函数，返回非负整数 $n$ 的各位数字之和。例如，$S(123) = 1 + 2 + 3 = 6$。

## 说明/提示

**解释**  
$\texttt{2}$：共有 2 个测试用例。  
$\texttt{100}$：第一个测试用例中，未知整数 $x = 9$，目标值 $n = 100$。  
$\texttt{add -10}$ $\texttt{0}$：指令"add -10"返回"0"，因为 $9 + (-10) \le 0$，$x$ 保持为 9。  
$\texttt{add 1}$ $\texttt{1}$：指令"add 1"成功，$x$ 变为 10。  
$\texttt{mul 10}$ $\texttt{1}$：指令"mul 10"成功，$x$ 变为 100。  
$\texttt{!}$ $\texttt{1}$：确认 $x = n$。  
$\texttt{5}$：第二个测试用例中，$x = 1234$，$n = 5$。  
$\texttt{digit}$ $\texttt{1}$：$x$ 变为各位数字之和 10。  
$\texttt{div 2}$ $\texttt{1}$：指令"div 2"成功，$x$ 变为 5。  
$\texttt{!}$ $\texttt{1}$：确认 $x = n$。  

注意示例中的空行仅为清晰展示，实际交互中不会出现。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
100

0

1

1

1

5

1

1

1```

### 输出

```
add -10

add 1

mul 10

!

digit

div 2

!```

# 题解

## 作者：_jimmywang_ (赞：7)

我觉得能想出这个题的人离人类已经很远了。不知道出题人想出这个解法的时候有没有笑了两天才舍得出成题目发出来。

首先你要会 C2 的解法：`mul 9,digit,digit,add n-9`。原理是乘 9 后数位和一定是两位数且是 9 的倍数，所以再取一次数位和结果一定是 9。

那么沿着这个思路，你可能会想试试 `mul 99`，`mul 999` 之类的数有没有类似的结论。有的兄弟有的，结论就是这个：

$$\text{digit}((10^d-1)x)=9d, \ \forall x\in[1,10^d]$$

> 证明：$(10^d-1)x=10^dx-x=(x-1)10^d+10^d-x=(x-1)10^d+(\underbrace{99\dots9}_{d \text{ times}}-(x-1))$。
> 
> 容易发现在 $x\in[1,10^d]$ 的时候，前后两项在位数上是互不干扰的（前面一项末尾跟了 $d$ 个 0，后面一项是 $d$ 位数）。考察 $x-1$ 的每一位，在前面那项和后面那项中的贡献加起来都是 9。所以数位和是 $9d$。

注意到题中的 $x\in[1,10^9]$，所以我们执行一个 `mul 999999999`（9 个 9），结果的数位和一定是 81！

所以我们得到了一种 3 步解决的流程：`mul 999999999, digit, add n-81`，其中 $n=81$ 时可以省略最后一步。

那么怎么证明 3 步一定最少呢？其实这等价于说在至少需要两步才能得到当前的 $x$ 是什么。显然一步没法得到 $x$ 是什么（可以通过枚举这步的操作得到），我们又给出了两步得到当前 $x=81$ 的构造，所以两步是最少的。

---

## 作者：CaiZi (赞：3)

有大神拿这题做儿童节游园会小游戏，所以写篇题解。

[C2 题解](https://www.luogu.com.cn/article/6rguzrew/)。

既然 C2 要求是 $4$ 次，那么我们可以先尝试 $3$ 次操作，再尝试 $2$ 次操作（$1$ 次操作显然不可行）。

考虑 C2 有哪次操作可以不用，显然最后 $1$ 次操作优化不掉，那就只能优化前 $3$ 次操作，我们希望第 $1$ 次操作乘上某个数后，只用 $1$ 次 ```digit``` 就可以得到一个确定的数。

我们乘法最大可以乘 $10^9$，不妨尝试一下 $9$ 的倍数，发现没有结论。然后尝试一下 $9$ 个 $9$ 组成的数，即 $10^9-1$。可以发现：
$$\begin{aligned}(10^9-1)x&=10^9x-x\\&=10^9(x-1)+10^9-x\\&=[10^9(x-1)]+[(10^9-1)-(x-1)]\end{aligned}$$
令 $x-1=\overline{a_1\cdots a_9}$，那么 $(10^9-1)x=\overline{a_1\cdots a_9(9-a_1)\cdots(9-a_9)}$。

于是 $S((10^9-1)x)=a_1+(9-a_1)+\cdots+a_9+(9-a_9)=9\times9=81$。

于是现在我们找到了 $3$ 次操作的做法。对于 $n=81$ 可以略去最后 $1$ 次操作，只需要 $2$ 次操作。那么有没有什么其他的 $n$ 是只需要 $2$ 次操作就可以得到的呢？

假设存在 $a\ne10^9-1$ 使得 $S(ax)=n_0$，取 $x=10^9-1$，由上面的结论可以知道 $S(ax)=81$。而我们再取 $x=1$，$S(ax)=S(a)$，只有取 $a=10^9-1$ 才能使 $S(a)=81$。于是我们证明了只有 $n=81$ 是只需要 $2$ 次操作就可以得到的。

最终答案：
```cpp
if(n==81){
	cout<<"mul 999999999\n";
	cout<<"digit\n";
}
else{
	cout<<"mul 999999999\n";
	cout<<"digit\n";
	cout<<"add"<<n-81<<"\n";
}
```

---

## 作者：P_Bisector (赞：2)

首先我们给出此题两步得到 $81$ 的方案：

```
mul 999999999
digit
```

演绎法证明别的题解都有了。但是如果直接去想这个 $999999999$，十分困难。这里提供一种非常规做法，仅适用于在 IOI 赛制下或已知 $f(x)=3$ 时写出此题。

考虑到把 C2 的代码交进去会有 WA on #1，则 $f(x)<4$。接下来先构造一个 $f(x)=3$ 的做法。

易证 digit 是必须使用的，否在加乘除无法完成这么复杂的运算。易证 digit 不在第三步，否则当 $n>162$ 时无法完成。易证第一步不是 digit。假设第一步为 digit，则得到此时有 $1\leq x\leq 72$，然后通过两次操作变为指定的 $n$，很假。综上，第二步为 digit。

我们注意到 digit 以后只能有一个答案，否则无法归纳到 $n$。于是我们注意到最后一步应为 add，而 digit 之后得到的 $x$ 一定不变，这里称之为 $x_0$。那么 digit 之前所得的数的各位数字之和一定不变。

考虑无论是 add 还是 div 都不太能将一个数变成各位数字一定的数，因此考虑 mul 操作。我们将需要 mul 的数称为 $m$。

这个数是啥呢，好难猜啊。

那不如打表了。

易证 $1<m \leq 10^9$，那么在这个范围内进行暴力枚举。首先找一个随机的数组，然后比较数组的前两个数与 $m$ 相乘的结果，若各位数字之和相等，则比较后面两个数，以此类推。如果你的数组足够随机，最后只会得到 $m=999999999$。然后这个时候去归纳或者演绎证明，即可得到 $m=999999999$ 是正确的。

# 后记

我的朋友：这个题怎么是蓝啊，应该升黑。

直到我写完这篇题解我才意识到为什么会有人标蓝。

---

## 作者：StarTwinkleTwinkle (赞：2)

自我认为比 E 简单。

发现 $1$ 次不可能，考虑 $2$ 次或 $3$ 次。

由我的 C2 题解，我们发现 $99$ 这个数有些特殊，为 $10^2-1$。我们思索让未知整数直接乘上一个 $10^n-1$，结果的位数和应该是个定值。

考虑证明：设未知整数为 $x$，则 $x(10^n-1)=(x-1+1)(10^n-1)=(x-1)(10^n-1)+10^n-1=(x-1)10^n+10^n-1-(x-1)$。

- 当 $x\le 10^n$ 时，$10^n-1$ 与 $x-1$ 之差不产生退位，所以第 $i$ 位与第 $i+n$ 位的和为 $9$，故 $x(10^n-1)$ 的位数和为 $9n$ 。

- 反之，位数和不为 $9n$。

综上，我们可以让其乘上一个不比未知整数 $x$ 小或之比未知整数 $x$ 小 $1$ 的整数$10^n-1$，又因为未知整数 $x$ 在 $1$ 到 $10^9$ 之间，$x(10^n-1)$ 在 $1$ 到 $10^{18}-1$ 之间，故 $n=9$。

乘上 $999999999$ 并进行一遍 digit 操作后，其结果定为 $81$。在这里有一个坑点：当 $n=81$ 时，就不需要加上 $n-81$ 了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,T;
inline void solve()
{
	cin>>n;
	
	cout<<"mul 999999999"<<endl;
	cin>>x;
	
	cout<<"digit"<<endl;
	cin>>x;
	
	if(n!=81){
		cout<<"add "<<n-81<<endl;
		cin>>x;
	}
	
	cout<<"!"<<endl;
	cin>>x;
}
signed main(){
	cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：lijianACE (赞：1)

## CF2109C3 Hacking Numbers (Hard Version) 题解   

通过证明：  
![](https://cdn.luogu.com.cn/upload/image_hosting/c0hllnaa.png)  

(不知道图为什么这么小，将就)  

[洛谷传送门](https://www.luogu.com.cn/problem/CF2109C3)  

[CF传送门](https://codeforces.com/problemset/problem/2109/C3)  

题目解析：最小化操作次数，使得某个未知整数 $x$ 变换为给定整数 $n$。  

怎么说呢，后来复盘时发现这么多未知，感觉挺难做的，但刚看到时没想过这点。  

其实本题可以先看 C2（[传送门](https://codeforces.com/problemset/problem/2109/C2)）， 然后发现正解，但说实话 C2 会做 C3 基本都会，C2 不会 C3 基本都不会。  

首先看到老朋友：各位数字之和，立马想到它的很多优良~~毒瘤~~性质：  

$$x\equiv S(x)\pmod{9}$$  

（$S(x)$ 函数含义如题）  

但好吧，题目并没有给出取模运算，所以没用。  

真的吗？ 

假设我们先进行 `mul 9k`，其中 $k$ 为正整数，再进行  `digit`，由于 $x\equiv S(x)\pmod{9}$ ，而此时 $9\mid x$，则此时 $9\mid S(x)$。 


由于 $x\le 10^{18}$，$S(x)$ 最大只能到 $17\times 9$，数据范围一下缩小了很多，感觉很接近正解了。 

先考虑一个看起来无关的例子：如果对于正整数 $x$，$1\le x< 10^{d}$，如何获得一个 $x_0$，使得 $9\mid S(x)+S(x_0)$？  

其实很简单，假设 $x=\overline{a_1a_2a_3\cdots a_d}$，$0\le a_i\le 9$，$a_i$ 为整数，那么当 $x_0=\underbrace{999\cdots9}_{d个9}-x=\overline{(9-a_1)(9-a_2)\cdots (9-a_d)}$ 时，$S(x_0)=(9-a_1)+(9-a_2)+\cdots +(9-a_d)$，正好满足要求。  

说了看起来是废话的一大堆，有什么用？  

考虑 $x\times 10^d+\underbrace{999\cdots9}_{d个9}-x=\overline{a_1a_2a_3\cdots a_d}\times 10^d+\overline{(9-a_1)(9-a_2)\cdots (9-a_d)}=\overline{a_1a_2a_3\cdots a_d(9-a_1)(9-a_2)\cdots (9-a_d)}$，它的 $S(x)=a_1+a_2+a_3+\cdots +a_d+(9-a_1)+(9-a_2)+\cdots +(9-a_d)=d\times 9$，是个定值！  

我们来化简一下这个式子：$x\times 10^d+\underbrace{999\cdots9}_{d个9}-x=x\times 10^d+10^d-x-1=x\times (10^d-1)+10^d-1=(x+1)\times(10^d-1)$，所以说，当 $x<10^d$，也就是 $x+1\le10^d$ 时，将其先乘 $10^d-1$，再进行`digit`，最后结果一定是 $d\times 9$。而 $9\mid 10^d-1$，与我们最开始的猜想不谋而合！  

接下来就好做了，因为 $1\le x\le 10^9$，所以 $d=9$，即 $10^d-1=999999999$。且 $x\times 999999999<10^{18}$，符合题意，所以操作为：`mul 999999999`，`digit`，`add n-81`。操作结束。  

好，可以写代码了。

（仅展示核心代码）
```cpp
    printf("mul 999999999\n");
    printf("digit\n");
    printf("add %d\n",n-81);
```
恭喜，WA 力！  

所以我们刚刚的操作有误？  

仔细想想，我们需要最小化操作次数，而以上要三次，有没有可能可以更少？  

不难发现，当 $n=81$ 时，最后一步可以省略。  

是否有其他 $n$ 使得仅用两次操作即可变换呢？答案是否定的。对于 `digit` 以外的操作来说，两次将数缩小的区间太小，于是必然有一次 `digit` 操作。又因为第一次操作用 `digit` 只能使 $1\le x\le 81$，接下来进行什么操作都无法确定数值，只能是第二步操作为 `digit`。同时，第一步操作由于 `add` 与 `div` 无法固定为一个真正有用的固定值，所以只能是 `mul`。  

假设存在 $k\neq 999999999$，使得 $S(x\times k)$ 为定值，因为我们推出 $S(999999999\times k)=81$，所以我们可以找出 $S(x_0\times k)\neq81$ 来推翻。因为 $k\neq999999999$ 且 $k<10^9$，所以 $1\times k<999999999$，即 $S(1\times k)\le80<81$，矛盾。  

所以，当且仅当 $n=81$ 时仅需两次操作。 

Code：

```cpp
  //核心代码
  scanf("%d",&n);
  printf("mul 999999999\n");
  scanf("%d",&y);
  printf("digit\n");
  scanf("%d",&y);
  if(n!=81){
    printf("add %d\n",n-81);
    scanf("%d",&y);
  }
  printf("!\n");
  scanf("%d",&y);
```

题解写的不是很好，望谅解！  

如果有误，敬请指导。  

QWQ

---

## 作者：QWQ_SenLin (赞：1)

B 死活没调出来。。

当时第一眼看到这题，觉得乘除操作没什么用，第一感觉是要用 `add` 找出 $x$ 具体是多少，最后在加一次就行了。

但是实际上最大的查找次数是 $\log_2$ 级别的，连 C1 都过不了。

然后发现这不止给了加乘除操作，还给了求数位和的操作。

这会导致什么？假如数是 $999999999$（$9$ 个 $9$），那么执行一次操作后就变成了 $81$！下降的非常快。实际上不出 $3$ 次，就可以下降到 $10$ 以内。

这就很美妙了，二分也只需要 $4$ 次。但是我当时脑洞大开，想到了九九乘法表：
$$
1\times 9 = 9
$$
$$
2\times 9 = 18
$$
$$
9\times 9 = 81
$$
这里就列举几个，小学数学，很显然乘 $9$ 后的数位之和都为 $9$。这样我们只需要乘 $9$ 再取数位和就得到了固定的 $9$。

过了 C1 后，我尝试沿用这种思路：是否有一种数可以让某个范围内的数乘完后的数位和是个定值呢？于是我快速地打了个暴力：

```cpp
inline int sum(long long x){
    int ret = 0;
    while(x){ ret += x % 10; x /= 10; }
    return ret;
}

int main(void){
  int N = 1000;
	for(int i = 1;;i++){
        int lt = sum(i);
        bool flag = 0;
        for(int j = 2;j <= N;j++){
            if(lt != sum(1LL * j * i)){
                flag = 1;
                break;
            }
        }
        if(!flag){
            printf("%d\n" , i);
            break;
        }
    }
}
```

运行结果：$999$。

这样由于第一次取数位和后的结果就小于 $1000$ 了，所以只需要取一次，乘一次，再取一次，再加一次就行了。总共 $4$ 次，能过 C2。

到了 C3，题目要求用最少的次数。此时规律其实已经大约可以看出来了，让我们再跑几次暴力吧。

$N=10000$ 结果为 $9999$。

$N=100000$ 结果为 $99999$。

$N=1000000$ 结果为 $999999$。

好了，再往下程序跑不出来了。这里规律其实已经明显到不必多说了，我们大胆猜测：$N=10^9$ 时，乘 $10^9-1$ 后的数位和相同。

于是最终策略就是乘 $10^9-1$，取数位和，加上剩余的差。

很快啊就交上去，WA on 13，what？

最后遗憾退场。。。睡觉时猛然惊起：**没有特判加 $0$ 的情况。**

代码
```cpp
#include <cstdio>
using namespace std;

int T , n , ret;

int main(void){
	scanf("%d" , &T);
	while(T--){
		scanf("%d" , &n);
		puts("mul 999999999");fflush(stdout);
		scanf("%d" , &ret);
		puts("digit");fflush(stdout);
		scanf("%d" , &ret);
		if(n != 81){
			printf("add %d\n" , n - 81);fflush(stdout);
			scanf("%d" , &ret);
		}
		puts("!");fflush(stdout);
		scanf("%d" , &ret);
		if(ret == -1) break;
	}
}
```
这里让我们来证明一下这个结论：对于小于等于 $10^x$ 的所有正整数，乘上 $10^x-1$ 后的数位和等于 $9x$。

假设这个数为 $n$，那么乘上后为：

$$n\times (10^x-1)=n \times 10^x-n=(n-1)\times 10^x+(10^x-n)$$

令 $\overline{n-1}=\overline{a_1a_2a_3 \cdots a_x}$，因为

$$10^x-n=(10^x-1)-(n-1)=\underbrace{99 \cdots 9}_{x \text{个} 9}-(n-1)=\overline{(9-a_1)(9-a_2) \cdots (9-ax)}$$

将 $n-1$ 和 $10^x-n$ 补前导零到 $x$ 位数，显然，乘 $10^x$ 相当于向左移 $x$ 位。于是新数相当于把 $n-1$ 和 $10^x-n$ 拼在一起，变成：

$$\overline{a_1a_2 \cdots a_x (9-a_1)(9-a2) \cdots (9-a_x)}$$

显然数位和为 $9x$。与 $n$ 无关，证毕。

总的来说，这题是一道非常好的题，比较考验直觉（可能吧），像我最后 30 分钟才开 C 题，就顺着题目的提示一步步做到了 C3。C 应该是这场比赛最 amazing 的吧。

C 题的评价：

![](https://cdn.luogu.com.cn/upload/image_hosting/e2d8v61b.png)

---

## 作者：RootMirzayanov (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF2109C3)

## 题解

由于 $x,n$ 的值域已经达到了 $10^9$，题目所给操作类型仅有加减、乘、整除和数位和，且 C2 已经提示最小操作次数不超过 $4$，所以依靠返回值推测 $x$ 再变成 $n$ 不可行，那就从把 $x$ 变成一个确定的数 $x_0$ 再通过加减一次操作变成 $n$ 的角度做题。

不难发现数位和（$\operatorname{digit}$ 操作）与四则运算相比较为特殊，考虑从这一操作上入手，当 $x\in[1,10^9]$ 时，$\operatorname{digit}(x)\in[1,81]$，发现 $\operatorname{digit}$ 操作可以缩小值域的性质，至此 C1 迎刃而解——$\operatorname{digit}$($\operatorname{digit}(x))\in[1,16]$，用四次操作将值域减半后变为 $1$，最后加 $n-1$ 即为答案，共 $7$ 次操作。

从数有关数位和的性质的角度考虑，不难想到 $3$ 和 $9$ 的倍数的性质，其中 $9$ 的倍数性质更为优越——$[1,10]$ 中所有整数与 $9$ 的积数位和均为 $9$, 但是遗憾的是推广到 $22\times9=198$ 时就不适用了，幸运的是 $22\times99=2178$，数位和为 $18$，无论随机选取任何两位数还是简单写个程序验证发现对于所有 $100$ 以内的整数均成立。我们可以总结得到一个规律：

$$\operatorname{digit}((10^a-1)x)=9a,x\in[1,10^a]$$

下面尝试证明：$(10^a-1)x=(10^a-1)[(x-1)+1]=10^a(x-1)+10^a-1-(x-1)$，其中 $10^a-1=\begin{matrix}a 
\ \text{个}\\\overbrace{99\cdots99}\end{matrix}$，且 $10^a(x-1)$ 与后 $a$ 位不相交，所以 $\operatorname{digit}((10^a-1)x)=\operatorname{digit}(x)+\operatorname{digit}(10^a-1)-\operatorname{digit}(x)=9a$.

由于 $x\in[1,10^9]$，交互过程中允许的最大结果是 $10^{18}$，且 $10^9\times(10^9-1)<10^{18}$，所以 $\operatorname{digit}((10^9-1)x)=81$，共用 $2$ 次操作将所有的 $x$ 化为 $81$，最后再加 $n-81$ 就变成 $n$，共 $3$ 次操作，注意特判 $n=81$ 仅需两次操作。

考虑是否存在其他的 $n$ 使得 $f(n)\le2$：由于只有 $\operatorname{digit}$ 可以缩小值域，所以必定有一步操作是 $\operatorname{digit}$. 

1. 若第一步操作是 $\operatorname{digit}$，则 $\operatorname{digit}(x)\in[1,81]$，第二步无论如何都只能化为一个区间；

2. 若第二步操作是 $\operatorname{digit}$，则考虑是否能通过四则运算使得数位和为定值，加减与整除显然不可能，乘法这里参考官方题解，考虑反证：假设存在 $a$ 使得 $\operatorname{digit}(ax)=x_0$，则当 $x_1=1,x_2=10^9-1$ 时，$\operatorname{digit}(x_1a)=\operatorname{digit}(a)\le80<81=\operatorname{digit}((10^9-1)a)=\operatorname{digit}(x_2a)$.

所以不存在其他操作步骤比该方式所用操作次数更少。

## 代码
```cpp
#include <bits/stdc++.h>
int T, n, tmp;
int main(){
	scanf("%d", &T);
	while(T--){
		std::cin >> n;
		std::cout << "mul 999999999" << std::endl;
		std::cout.flush();
		std::cin >> tmp;
		std::cout << "digit" << std::endl;
		std::cout.flush();
        std::cin >> tmp;
		if(n == 81){
			std::cout << "!" << std::endl;
			std::cout.flush();
			std::cin >> tmp;
			continue;
		}
		std::cout << "add " << n - 81 << std::endl;
		std::cout.flush();
		std::cin >> tmp;
		std::cout << "!" << std::endl;
		std::cout.flush();
		std::cin >> tmp;
	}
	return 0;
}
```

---

## 作者：lfxxx (赞：0)

气笑了。

C2 的 $4$ 步策略交了下，样例没过。

最后一步操作是没法得到信息的，我们至少必须在前两步得到足够的信息。

求数位和操作肯定是需要的，不然我们不可能将 $10^9$ 种可能的 $x$ 在最后变成 $n$。

如果一上来就求数位和，枚举下后面的步骤发现一定完蛋了。

第一步如果是加法或者除法，感觉对求数位和后的结果影响不大。

所以我们其实希望找到一个 $k$ 使得 $x \times k$ 的数位和是一个固定的值。

那么怎么找呢？

直接搜索，小范围你发现 $99$ 乘上任意不超过 $100$ 的数，结果的数位和都是 $18$。

又因为 $x \leq 10^9$，所以不妨猜测 $k=10^9-1$，乘上去之后数位和一定是 $81$，这样就是 $3$ 步（$n=81$ 时是两步）。

交，过了。

证明考虑，$(10^9-1) \times x = 10^9 \times x - x$，当 $x<10^9$ 时，观察下面的竖式：

![](https://cdn.luogu.com.cn/upload/image_hosting/cpfihq82.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

不难发现用彩色线连起来的位置加和为 $9$，故数位和为 $9 \times 9 = 81$。而 $x = 10^9$ 时显然结论也成立，故得证。


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int res=0;
        cout<<"mul "<<999999999<<endl;
        cin>>res;
        cout<<"digit"<<endl;
        cin>>res;
        if(n!=81){
            cout<<"add "<<n-81<<endl;
            cin>>res;            
        }
        cout<<"!"<<endl;
        cin>>res;
    }
    return 0;
}
```

---

## 作者：RainWetPeopleStart (赞：0)

upd on 2025.06.10 原来的结论在段数大于 $2$ 时有一些问题，可以被 $x=880902$ 叉掉，所以重新写了推广到 $k=9$ 的部分。

这也是题？

下文的 $\log$ 默认上取整。

考虑一个做法，就是二进制拆分，然后依此减到 $1$，然后加回来即可，次数为 $\log_2 V+1$。

发现 `digit` 可以极大的缩小值域，使用一次 `digit` 就可以让 $x$ 的值域变为 $[1,81]$，两次就可以变到 $[1,9]$，然后再跑上面的做法就是 $\log_2 9+3=7$ 次。

发现这个 $\log$ 就很不好，考虑把 $\log$ 去掉，注意到对于 $x\in[1,9]$，有 $S(9x)=9$，由此，就可以把 $\log$ 的 $4$ 次优化到 $2$ 次。可以做到 $5$ 次。

然后呢，发现第一次 `digit` 以后值域有 $81$，能不能减小？

可以的，利用一下 `mul` 操作，注意到 $9\mid S(x)\Leftrightarrow 9\mid x$，考虑先 `mul 9` 再 `digit`，此时 $x$ 的值域为 $\{x\mid x\le 81,x\bmod 9=0\}$，再做一次 `digit` 就可以让 $x=9$，然后加回来就行，操作次数为 $4$ 次。

考虑优化，发现我们只能去砍掉 `digit` 操作，如果只用一次 `digit` 操作，前面就要用 `mul` 操作（其他的操作是不行的，具体参见下文）使得操作完后 $S(x)$ 取值唯一。

如果乘 $99$ 呢，类比乘 $9$ 的结论可得：$x$ 是 $99$ 的倍数等价于把 $x$ 从低到高每两个数位分成一段后，每段的和是 $99$ 的倍数。

与乘 $9$ 相比，这个操作的优势在于段数更少，更容易控制数字和。

推广一下，把乘 $9$ 换成乘 $10^k-1$，发现在 $k=9$ 时只有两段且不会爆 `long long`，此时每段的和**一定**是 $10^9-1$，可以得出此时 $S(x)$ **一定**为 $81$。

这样就可以省掉一次 `digit`，特判 $n=81$（不需要加）即可通过。

证明：（参考了题解）

只需考虑能不能两次以内把 $x$ 的值统一且这时 $x\neq 81$。

一次显然不行。

分类讨论两次的情况。

没有 `digit` 显然不行，一开始用 `digit` 就变为了 $V=81$ 的问题，一样不行。

否则，发现第一次用 `add` 和 `div` 是不行的，具体可以对 $\bmod 9$ 的余数考虑。

使用 `mul` 的话，假设乘了 $k$，因为 $S(k\times (10^9-1))=81$，而 $S(k\times 1)<81$，也不行。

可得 $f(n)=3-[n=81]$。

---

## 作者：qfy123 (赞：0)

题意：将一个未知数 $x$ 用题目所给四种指令使之变成题目给定数 $n$，并要**最小化**操作次数。

对于 Hard Version，我们先要注意到一个结论：

$$\forall x \in [1, 10^k], k \in \mathbf{N}, S((10^k-1)x) = 9k$$


> 证明：
> $$\begin{aligned}(10^k-1)x &= 10^k(x - 1) + 10^k - x \\ &= (x - 1)10^k + [(10 ^ k - 1) - (x - 1)] \end{aligned}$$ 
> 将上面式子拆成两段，考察各个式子的含义（假设 $x - 1$ 这个数形为 $\overline{\dots cba}$）：
> - $(x - 1)10^k$：将 $x - 1$ 这个数左移 $k$ 位；
> - $[(10 ^ k - 1) - (x - 1)]$：该式子算出来的结果将会形为 $\overline{999\dots(9-c)(9-b)(9-a)}$。
>  
> 那么，最终得到的数将会形为：
> $$\overline{\dots cba999\dots (9-c)(9-b)(9-a)}$$
> 对其进行 $S(x)$ 操作，前后相加抵消成 $9$，答案就剩下 $10^k - 1$ 的数字和，即 $9k$。

根据数据范围，令 $k = 9$，那么经过 ```mul 999999999``` 和 ```digit``` 操作后，最终结果一定为 $81$！

这样，我们只需要进行下面三步即可将 $x$ 变为 $n$：
1. 乘上 $999,999,999$；
2. 数位求和；
3. 加上 $n - 81$。

注意：因为要最小化操作次数，所以当 $n = 81$ 的时候第三步是没必要进行的。

---


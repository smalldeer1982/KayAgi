# Tree Colorings

## 题目描述

考虑一棵有根树，每个结点可以被染成蓝色、绿色或黄色。一个染色方案是美丽的，当且仅当：
- 根节点被染成绿色；
- 所有的**蓝色和绿色**结点构成一个点集，点集中的点两两之间的路径上都没有黄色结点；
- 所有的**黄色和绿色**结点构成一个点集，点集中的点两两之间的路径上都没有蓝色结点。

给你一个整数 $m$，问一棵**恰有** $m$ 种美丽的染色方案的有根树最少有多少个结点？

## 说明/提示

**样例解释**

我们用 $g$ 表示绿色，用 $b$ 表示蓝色，用 $y$ 表示黄色。

对于第一组数据，考虑一个只有一个结点的树。它有一种美丽的染色方案：根节点为绿色。

对于第二组数据，考虑一个有两个结点的树，根为结点 $1$，它有三种美丽的染色方案：$[g,g],[g,b],[g,y]$。

对于第三组数据，考虑一个有三个结点的链，根为结点 $1$，结点 $2$ 和结点 $1$ 与结点 $3$ 相连，它有五种美丽的染色方案：$[g,g,g],[g,g,b],[g,g,y],[g,b,b],[g,y,y]$。

对于第五组数据，考虑一个有三个结点的树，根为结点 $1$，另外两个结点和它相连，它有九种美丽的染色方案：$[g,g,g],[g,g,b],[g,g,y],[g,b,g],[g,b,b],[g,b,y],[g,y,g],[g,y,b],[g,y,y]$。

## 样例 #1

### 输入

```
5
1
3
5
7
9```

### 输出

```
1
2
3
4
3```

# 题解

## 作者：chenxi2009 (赞：9)

## 思路
太有趣了这道题。本篇题解重在思维链。\
直接做感觉十分荒唐，没有任何可以 get 的点，考虑做一个相似问题：给一棵树，有多少种美丽的染色方案？

一个美丽的染色方案肯定满足绿色的格子构成一个包含根的连通块，对于一棵以 $1$ 为根的树，我们令 $f_i$ 表示 $i$ 的子树的美丽的染色方案，考虑转移。

发现 $i$ 转移向 $i$ 的父亲时，除了 $i$ 本身的美丽方案外，还有“把 $i$ 的子树全部染成黄/蓝色”两种方案，转移的时候根据乘法原理就有：
$$
f_u=\prod_{v\in\text{son of }u}(f_v+2)
$$

叶子有 $f_i=1$，$+2$ 不改变奇偶性，所以所有 $f_i$ 都是由奇数相乘的到的，故有“任意一棵树的美丽的染色方案都是奇数”。

问题来了，我们要对一个 $f$ 去找它的树中最少包含多少个结点，这要怎么做呢？

我们考虑 $g_i(i\text{ is odd})$ 表示方案数为 $i$ 的树的最小大小，此时需要一种转移的方式能涵盖所有需要的树的形状。经过一些排除，发现“拼接”最能符合我们的需要：


示例：如果我们这样拼接，把一个根为 $7(f_7=15)$ 的树拼到一个根为 $1(f_1=35)$ 的树上...

![](https://cdn.luogu.com.cn/upload/image_hosting/k20gimvm.png)

结果：$7$ 变成了 $1$ 的儿子，图变成一颗根为 $1$ 的树（$f_1\leftarrow f_1\times(f_7+2)=35\times 17=595$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/pvd7skqg.png)

为什么选择“拼接”这样的操作呢？因为：
- 拼接操作可以不漏地拼成所有形态的树，能够确保没有遗漏的情况，这是**正确性**的由来；
- $f$ 的递推是由下至上的，拼接同样是由下至上完成的（可以拼好下面的子树，再把它向上拼接），确保**无后效性**，如果你的操作是从上至下的，比如说添加叶子，那么新增方案数就会同时受上面和下面（如果未来将要添加叶子）的结构影响，难以计算；
- 操作简便，不难发现一次拼接相当于一次转移 $f_{k}=f_i\times (f_j+2)$，我们令 $(x,y,z)\leftarrow (f_i,f_j+2,f_k)$，那么这个拼接本质上构造了一个 $g_z$ 的方案，有 $g_z\leftarrow \min(g_z,g_x+g_{y-2}),x\times y=z$。发现转移方程被我们写出来了，如此简单不禁让人感叹拼接的无后效性竟然如此强。

归纳下方程：
$$
g_i=\begin{cases}
1,i=1\\
-1,i\text{ is an even number}\\
\min\limits_{j\mid i,j<i} \left(g_j+g_{\frac{i}{j}-2}\right),i\text{ is an odd number and }i>1
\end{cases}
$$

注意到我们需要枚举 $i$ 的因数，我们运用调和级数转移，预处理出 $g$ 的复杂度是 $O(m\log m)$，每次询问的时候直接调用 $g_m$ 回答就行了，时间复杂度 $O(m\log m+T)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 600000;
int T,m,f[M];
vector<int>fct[M];
int main(){
  memset(f,-1,sizeof(f)),f[1] = 1;
  cin.tie(0)->sync_with_stdio(0);
  cin >> T;
  f[1] = 1;
  for(int i = 1;i < M;i += 2) for(int j = 2 * i;j < M;j += i) fct[j].emplace_back(i);
  for(int i = 3;i < M;i += 2){
    f[i] = 1e9;
    for(auto j : fct[i]) f[i] = min(f[i],f[j] + f[i / j - 2]);
  }
  while(T --) cin >> m,printf("%d\n",f[m]);
  return 0;
}
```

---

## 作者：gesong (赞：4)

题目传送门：[CF2112E Tree Colorings](https://www.luogu.com.cn/problem/CF2112E)。
# 思路

有趣题。

先考虑如何求解题目求解染色方案的问题。

设 $f_u$ 表示已 $u$ 为根的子树且 $u$ 涂绿色的方案数。

转移分三种情况，设 $v$ 为 $u$ 的儿子。

1. $v$ 涂绿色，那么方案数为 $f_v$。
2. $v$ 涂蓝色，那么整个子树只能涂蓝色，方案数唯一。
3. $v$ 涂黄色，那么整个子树只能涂黄色，方案数唯一。

综上转移方程即为 $f_u=\prod_{v\in son_u} (f_v+2)$。

现在考虑如何求解题目的答案。

设 $g_i$ 表示答案为 $i$ 的最小点数，首先有 $g_1=1$，然后考虑枚举最后一个子树的方案数，设为 $j$，其中需满足 $j\mid i,j>2$，这样可以将原树分为两个方案数为 $\frac{i}{j}$ 和 $j-2$ 的点数相加，因此可以写出转移：

$$g_{i}=\min_{j\mid i,j>2} g_{\frac{i}{j}}+g_{j-2}$$

根号转移即可。
# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int N=5e5+10; 
int f[N];
inline int read(){
	char c=getchar();
	int f=1,ans=0;
	while(c<48||c>57) f=(c==45?f=-1:1),c=getchar();
	while(c>=48&&c<=57) ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
	return ans*f;
}
main(){
	f[1]=1;
	for (int i=2;i<N;i++){
		f[i]=1e18;
		for (int j=1;j*j<=i;j++) if (i%j==0){
			if (j>2) f[i]=min(f[i],f[i/j]+f[j-2]);
			if (i/j>2) f[i]=min(f[i],f[j]+f[i/j-2]);
		}
	}  
	for (int i=1;i<N;i++) if (f[i]==1e18) f[i]=-1;
	int T=read();
	while(T--) printf("%lld\n",f[read()]);
    return 0;
}
```

---

## 作者：冷却心 (赞：2)

什么都不需要了。

这什么糖题。

先考虑什么情况是合法的。容易注意到合法的情况形如：选择若干个不相交的子树，每棵子树选择黄蓝中的一种全部染色，然后剩下不在这些子树内的点全部都是绿色。

为了便于考虑，我们不要求整棵树一定存在绿色点，可以全部蓝色或黄色，这样每次询问把方案数加二即可。

对于一棵树，求染色方案数是简单的 dp：记 $h_i$ 表示以 $i$ 为根的子树的染色方案数，不要求一定存在绿色点，但要求如果存在绿色点，一定和当前根在同一个连通块。那么转移要么全部染色黄蓝，要么当前根染绿色，子树答案相乘，即 

$$h_u=2+\prod_{v \in \mathrm{son}(u)} h_v.$$

我们记 $f_i$ 表示方案数恰好为 $i$ 最小的树大小。那么转移相当于给当前的根找若干子树，形式化地，找到一个 $\{a_1,a_2,\dots,a_m\}$ 满足 $\prod a_j=i-2$，就可以转移 $f_i \gets 1+\sum f_{a_j}$。发现这个不好做，记辅助数组 $g_i$ 表示所有 $\{a_1,a_2,\dots,a_m\}$ 使得乘积为 $i$ 的序列的 $\sum f_{a_j}$ 的最小值。$g_i$ 的转移枚举倍数即可，转移回 $f$ 即为 $f_i\gets g_{i-2}+1$。预处理 $f,g$ 时间复杂度调和级数，查询 $O(1)$，如果直至最后都没有被更新那么这种方案无解。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 5e5 + 10;
int n = 5e5 + 5, Q, F[N], G[N];

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	memset(G, 0x3f, sizeof G); G[1] = 0;
	for (int i = 3; i <= n; i ++) {
		F[i] = G[i - 2] + 1;
		for (int j = i; j <= n; j += i) G[j] = min(G[j], F[i] + G[j / i]);
	}
	cin >> Q; int x;
	while (Q --) {
		cin >> x; cout << (F[x + 2] > 1e7 ? -1 : F[x + 2]) << "\n";
	}
	return 0;
}
```

---

## 作者：fanminghao000 (赞：2)

**（下文美丽度即指不同的美丽的方案数）**

题面比较奇怪，居然是让美丽度来匹配对应的最少的节点数。为了弄清楚美丽度是怎么求的，不妨先反过来思考，方便理解美丽度的本质：某个形态的树的美丽度是多少？

这样转化一下，问题就有了一些抓手。这种问题当然可以用树上 dp 来求。

不难注意到一个性质：如果一个节点的父节点是绿色的，那该节点可以随便填颜色；反之，如果是黄色或蓝色，则只能填对应的颜色。所以，如果该点填黄 / 蓝色，则整个子树只有一种方案；如果填绿色，则方案树与子节点的情况还有关。

于是设 $g_u$ 表示 $u$ 为绿色节点时，以 $u$ 为根的子树美丽度。由上文及乘法原理不难推出转移式：

$$
g_u=\prod_{v\in son_u} (g_v+2)
$$

其中叶子节点 $g_x=1$。

于是，一棵树的美丽度就被刻画出来了。顺着继续往下想，如果断掉一棵树的一条边，那么树会断成两个。反过来，两棵树加上一条边就能拼成一棵新树。考虑加边拼树对美丽值产生什么影响。设 $g_k$ 和 $g'_l$ 为根节点为 $k$ 和 $l$ 的两棵树的美丽值，两棵树拼起来后以 $k$ 为新树的根节点，则 $l$ 肯定接在另一棵树的某个节点 $p$ 下。根据转移式，$g_p \to g_p(g'_l+2)$，然后新的 $g_p$ 沿着树一直贡献到根节点，有 $g_k \to g_k(g'_l+2)$ 即新树的美丽度为 $g_k(g'_l+2)$。这样我们得到了拼树的一般形式。

我们看回问题，求每个美丽度对应的最小节点数。美丽度间的关系已经找到，且显然是从小推到大的关系，无后效性。考虑 dp。设 $f_i$ 表示美丽值为 $i$ 时最少的节点数，则有：

$$
f_{i(j+2)}=\min(f_i+f_j)
$$

其中 $f_1=1$。

于是问题迎刃而解，只需预处理每个数的因数然后枚举因数转移就行了。

## 代码
从转移式中不难发现只有美丽度为奇数时才有答案。

```cpp
#include <bits/stdc++.h>
#ifndef DEBUG
#define debug(x)
#endif
using namespace std;

int f[500010];
vector<int> v[500010];
int main() {
  cin.tie(0)->sync_with_stdio(0);
  int T;cin>>T;
  int n=500000;
  memset(f,0x3f,sizeof(f));
  f[1]=1;
  for(int i=3;i<=n;i+=2)
    for(int j=i;j<=n;j+=i) v[j].push_back(i);
  for(int i=1;i<=n;i++) v[i].push_back(1);
  for(int i=3;i<=n;i+=2){
    for(auto x:v[i]){
      f[i]=min(f[x]+f[i/x-2],f[i]);
    }
  }
  while(T--){
    int x;cin>>x;
    if(f[x]>5e5) cout<<-1<<endl;
    else cout<<f[x]<<endl;
  }
  return 0;
}
```

鲜花：做完这个题后我突发奇想，把它丢给 deepseek 做，然后忘记开深度思考了。大跌眼镜的是，没开深度思考的 deepseek 居然把它秒了。~~感觉智商受到了极大侮辱。~~

---

## 作者：lilong (赞：2)

考虑 dp。设 $f_i$ 表示恰好有 $i$ 种染色方案所需的最少点数，根据乘法原理，若 $i \mid j$，则 $f_j \leftarrow \min f_{\frac{j}{i}}+ f_{i-2}$（由于是由两棵数合并为一棵树，故其中的一个树根不再要求为绿色，可以变为黄色或蓝色，原来整棵树也随之变化，产生了 $2$ 种新方案，故右边是 $f_{i-2}$ 而不是 $f_i$）。

注意 $i$ 为偶数时是无解的。可以这样理解，已知 $f_1=1$ 为奇数，根据上面的分析，新产生的总方案数总是为偶数。又由于所有的情况都是由 $f_1$ 推来的，故染色方案数一定为奇数，即偶数无解。

时间上为调和级数复杂度 $O(N\log N+T)$，其中 $N=5\times 10^5$。


```cpp
#include<iostream>
#include<cstdio>
#define N 500000
#define inf 0x3f3f3f3f
#define int long long
using namespace std;
int n,f[N+10];
signed main(){
    for(int i=2;i<=N;i++)
        f[i]=inf;
    f[1]=1;
    for(int i=2;i<=N;i++){
        for(int j=i;j<=N;j+=i)
            f[j]=min(f[j],f[j/i]+f[i-2]);
    }
    int T;
    cin>>T;
    while(T--){
        cin>>n;
        if(n&1)cout<<f[n]<<'\n';
        else cout<<-1<<'\n';
    }
    return 0;
}
```

---

## 作者：yanjiadong (赞：2)

## 题目描述
定义一棵有根树的美丽染色方案，需要满足以下限制：
1. 每个节点为蓝色、黄色或绿色之一。
2. 根节点为绿色。
3. 对于所有蓝色和绿色节点，两两之间的路径不存在黄色。
4. 对于所有黄色和绿色节点，两两之间的路径不存在蓝色。

求一棵树上至少有多少节点，使得其恰有 $m$ 种美丽染色方案。
## 转化题意
首先考虑在树形态固定的情况下，如何计算其美丽染色方案数。

注意到合法的染色方案有以下性质：
1. 树的绿色部分一定是包含根节点的连通块。
2. 如果一个节点不是绿色，那么以它为根的子树中所有的节点都和这个节点颜色一样。

这两条性质很好理解。根据限制 3 和 4，两两绿色节点之间的路径不能存在蓝色或黄色。如果一个节点是蓝色，而它的某个后代为黄色，那么这个后代到根的路径就会存在蓝色，所以不合法，反之亦然。

仔细研究一下，发现这两条性质是充分且必要的。

所以我们可以记 $g_i$ 表示将 $i$ 节点染成绿色以后，以它为根的子树的美丽染色方案数。有如下转移方程：

$$g_i=\prod_{j\in ch_i}\left(g_j + 2\right)$$

其中 $ch_i$ 表示节点 $i$ 的儿子构成的集合。

## 解题思路

注意到若 $m$ 为奇数，我们可以构造一根长度为 $\frac{m+1}{2}$ ，其中一个端点为根节点的链，这样是合法的。又注意到 $g_i$ 一定是奇数。所以当且仅当 $m$ 是偶数的时候答案非法。

然后考虑怎么计算合法情况的答案。

定义 $f_i$ 表示恰有 $i$ 中美丽染色方案的最小子树的大小。有以下转移方程：

$$
f_i = 
\begin{cases} 
1 & \text{if } i = 1, \\
\min\limits_{\substack{S \subseteq \{3,5,7,\dots\} \\ \prod_{j \in S} j = i}} \left( \sum_{j \in S} f_{j-2} \right) + 1 & \text{otherwise} .
\end{cases}
$$

读者可以自行思考一下这个方程是怎么来的。

然而这个转移方程实在是有点复杂，而且如果我们枚举每个集合 $S$ 是不现实的。

有一个很经典的套路：

$$
f_i = 
\begin{cases} 
1 & \text{if } i = 1, \\
\min\limits_{j\mid i,3\leq j}\left(f_{\frac i j}+f_{j-2}\right)& \text{otherwise} .
\end{cases}
$$

我们可以这么理解：$f_i$ 的树就是给 $f_{\frac i j}$ 的树根向 $f_{j-2}$ 的树根连边后的结果。

然后代码就很好写了。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int f[N];
int solve(int x) {
	if(x%2==0) return -1;
	if(x==1) return 1;
	if(f[x]) return f[x];
	f[x]=solve(x-2)+1;
	for(int j=3;j*j<=x;j+=2)
		if(x%j==0)
			f[x]=min(f[x],solve(x/j)+solve(j-2));
	return f[x];
}
int main() {
	cin.tie(0)->sync_with_stdio(false);
	int T;cin>>T;
	while(T--) {
		int n;cin>>n;
		cout<<solve(n)<<'\n';
	}
	return 0;
}
```

对于记忆化搜索，一共有 $O(m)$ 种状态，每种状态需要 $O(\sqrt m)$ 转移，所以总时间复杂度是 $O(m\sqrt m)$ 的。

---

## 作者：Shunpower (赞：0)

提供一个不一样的理解。

-----------

钦定 $1$ 为根。

思路的起点应该是考虑如何刻画一棵树的染色方案数。由于绿色必须是一个包含根的连通块，所以实际上当我们把绿色部分删掉之后剩下的就是一些子树，这些子树可以选择自己是黄色还是蓝色。容易发现这些子树两两不交，所以实际上这些子树的根构成一个反链。

于是我们推广开，一棵树的合法染色方案数为：

$$
(\sum\limits_{i=0}^n 2^ic_i)-2
$$

其中 $c_i$ 表示大小为 $i$ 的反链数。$-2$ 是因为要去掉单独选一个根的那个大小为 $1$ 的反链。

容易发现这个数一定是奇数，所以所有偶数都无解。通过构造一条链可以证明所有奇数都有解。

然后考虑怎么最小化树的点数。可以发现这个式子恰好支持合并子树！两个子树合并时，绝大部分的反链方案是卷起来的（$c_i\times c_j\to c_{i+j}$），而这个式子的系数 $2^i$ 恰好也是需要卷起来的（$2^i\times 2^j\to 2^{i+j}$），于是我们在合并两个子树的时候直接把两边的方案数乘起来，效果上就是多项式乘法，再进行一些微调就可以得到合并后的子树的方案数。

据此显然需要 dp，$f_i$ 表示方案数为 $i+2$ 的树的最小点数。这里我们钦定根不选进反链可以方便转移。

考虑合并两个子树 $f_i,f_j$，不妨考虑把 $f_j$ 挂在 $f_i$ 的根下面，$f_i$ 挂给 $f_j$ 同理。除了刚才说的 $i\times j$ 部分，还要多一部分 $j$ 的根与 $f_i$ 的反链构成的新反链。所以实际上是：

$$
f_{ij+2i}\gets \min(f_i+f_j)
$$

务必记得反过来挂也要做。

转移时 $j$ 显然只需要枚举到 $\frac{m}{i}$，于是复杂度是 $\mathcal O(m\ln m+T)$。

---


# Bracket Cost

## 题目描述

Daemon Targaryen 决定不再像 Metin2 角色那样打扮。他把自己变成了最美丽的东西——一个括号序列。

对于一个括号序列，我们可以进行两种操作：

- 选择它的一个子串 $^\dagger$，并将其循环右移一位。例如，"(())" 循环右移后会变成 ")(()"；
- 在序列的任意位置插入一个括号，可以是左括号 '(' 或右括号 ')'。

我们定义一个括号序列的代价为使其变为平衡括号序列所需的最少操作次数 $^\ddagger$。

给定一个长度为 $n$ 的括号序列 $s$，请计算其所有 $\frac{n(n+1)}{2}$ 个非空子串的代价之和。注意，对于每个子串，需独立计算其代价。

$^\dagger$ 字符串 $a$ 是字符串 $b$ 的子串，如果 $a$ 可以通过删除 $b$ 开头若干（可能为零或全部）字符和结尾若干（可能为零或全部）字符得到。

$^\ddagger$ 如果一个括号序列可以通过在其中添加字符 $+$ 和 $1$ 变成一个合法的数学表达式，则称其为平衡的。例如，"(())()"、"()" 和 "(()(()))" 是平衡的，而 ")("、"(()" 和 "(()))(" 不是。

## 说明/提示

在第一个测试用例中，唯一的子串是 ")"。其代价为 $1$，因为我们可以在该子串开头插入一个 '('，得到 "()"，这是一个平衡序列。

在第二个测试用例中，每个长度为 $1$ 的子串代价都是 $1$。子串 ")(" 的代价为 $1$，因为我们可以将其循环右移得到 "()"。子串 ")()" 和 "()(" 的代价都是 $1$，因为只需插入一个括号即可。子串 ")()(" 的代价为 $1$，因为我们可以将其循环右移得到 "()()"。所以共有 $4 + 2 + 2 + 1 = 9$ 个代价为 $1$ 的子串，$1$ 个代价为 $0$ 的子串。因此总代价为 $9$。

在第三个测试用例中：

- "("，代价为 $1$；
- "()"，代价为 $0$；
- "())"，代价为 $1$；
- ")"，代价为 $1$；
- "))"，代价为 $2$；
- ")"，代价为 $1$。

所以总代价为 $6$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5
1
)
4
)()(
3
())
5
(((((
10
)(())))())```

### 输出

```
1
9
6
35
112```

# 题解

## 作者：dottle (赞：21)

先来考虑一个子串怎么算最小贡献，设其有 $L$ 个左括号，$R$ 个右括号，$X$ 对已经匹配的括号。

首先，存在一个构造，操作次数为 $\max(L,R)-X$，不妨设 $L\ge R$，反之亦然：

-   依次考虑每一个左括号，如果有未匹配的右括号，则这些右括号在此左括号前面。可以直接把左括号转到某一个右括号前面。否则在该左括号右边加一个右括号。

并且，我们发现每次操作只会减少至多一个未匹配的左括号或者右括号，因此上述构造取到最优。

现在，我们来分别求出 $\sum\max(L,R)$ 和 $\sum X$。

对于 $\sum X$，考虑原串中每一对匹配的括号的贡献。如在子串中其中某个括号匹配了，则一定是与对方匹配。这样，这对匹配将在 $l\times (n-r+1)$ 个子串中出现。

对于 $\max(L,R)$，考虑其等于 $[(R+L)+|L-R|]/2$，前一个小括号里的好求。求绝对值那一项的和，将左括号视为 $1$，右括号视为 $-1$，该值等于区间和的绝对值。那么我们将所有前缀和从小到大排序为 $s$，那么绝对值之和就是 $\sum_{i=1}^n\sum_{j=i}^ns_j-s_i$，此式计算不难。

时间复杂度为 $O(n)$（若将排序视为对 $1\sim n$ 的计数排序），也很好写。

代码中标记了哪个式子是在算哪一部分。

```cpp
#include<bits/stdc++.h>
#define int long long
const int N=1000005;
using namespace std;

void solve(){
	int n;cin>>n;
	string s;cin>>s;
	vector<int> a(1);
	int sum=0;
	for(int i=0;i<n;i++){
		if(s[i]=='(')sum++;
		else sum--;
		a.push_back(sum);
	}
	sort(a.begin(),a.end());
	int res=0,ns=0;
	for(int i=0;i<=n;i++){
   		res+=i*a[i]-ns;//|L-R|
		res+=i*(n-i+1);// L+R
		ns+=a[i];
	}
	res/=2; 
	stack<int> sss;
	for(int i=0;i<n;i++){
		if(s[i]=='('){
			sss.push(i);
		}else{
			if(sss.empty())continue;
			res-=(sss.top()+1)*(n-i);// X
			sss.pop(); 
		}
	}
	cout<<res<<endl;
}

main(){
	ios::sync_with_stdio(0);
	int _T=1;cin>>_T;
	while(_T--)solve();
}
```



---

## 作者：MSqwq (赞：6)

这题赛事调了一个小时都没调出来，非常菜，于是问了 @[Cocoly1990 ](https://www.luogu.com.cn/user/183026) 和 @[泷泽三月 ](https://www.luogu.com.cn/user/115936) 。两个佬直接把我点通了，他们是写的线段树和 BIT，然后早上看到多头发了一个[无区间max](https://www.luogu.com.cn/blog/dottle/cf1750e)的做法，让我彻底想明白了。  

题意：  
给你一个字符串，对于其中任意一个非空子串，你可以进行两种操作，一种是向右滑动，比如 "(())" 会变成 ")(()"  第二种是在任意位置添加一个左括号或者右括号。  
对于每个非空子串，变成完整括号匹配的最少操作步数为其贡献，问整个字符串的总贡献。  

题解：  
既然直接求贡献不好求，我们逆向看，对于一个串，考虑已经匹配的个数为 $x$ ，然后记下这个串中左右括号较大的数为 $y$，贡献显然为 $y - x$。  
然后对 $y$ 进行拆分显然有 $y = \max(L,R)$ 其中（$L$ 为左括号数量，$R$ 为右括号数量），继续推 $\max(L,R) =  \frac{(L + R)+ \left|L - R\right|}{2}$。考虑全局，对于所有 $(L + R)$ 是可以 $O(n)$ 算出来，对于 $i$ 号位的括号，那么它对答案的贡献就是 $i \times (n-i+1)$。然后处理所有的 $\left|L - R\right|$，对其放缩，设 $L \geqslant R$，则绝对值可以展开，那么就很好算了，就是一个前缀和的事情，那么显然就可以想到，设一个左括号为 1，右括号为 -1，这样求前缀和就可以解决放缩的问题，设 $sum$ 为左右括号前缀和，那么显然有，$\sum\limits_{i=1}^n\sum\limits_{j=1}^nsum_i-sum_j$，$O(n)$ 可以算出。  

然后对于 $x$,其实这个和 $(L + R)$ 的做法很相似，假设当前为一个右括号，且与前面的左括号相匹配，那么对于这个括号整体，记左括号位置为 $l$,右括号位置为 $r$，那么贡献就为 $l \times (n-r+1)$，显然用栈维护一下，$O(n)$ 可以算出来。  

其实还是很简单嘛，下次不要做不出来了噢qwq，代码：  
```
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iostream>
#include<vector>
#include<set>
#include<string>
#include<map>
#include<queue>
#include<stack>
#include<cmath>
#include<functional>
#define ll long long
using namespace std;
const int mod=998244353;
const int INF=0x3f3f3f3f;

inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0',c=getchar();}
	return x*f;
}
const int N=2e5+10;
char a[N];
ll s[N],sum[N];
void solve()
{
	int n=read();
	cin>>a+1;
	
	s[0]=sum[0]=0;
	sum[n+1]=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]=='(')sum[i]=sum[i-1]+1;
		else sum[i]=sum[i-1]-1;
	}
	sort(sum+1,sum+2+n);
	for(int i=1;i<=n;i++)s[i]=s[i-1]+sum[i];
	
	ll y=0,x=0;
	for(ll i=1;i<=n;i++)y+=i*(n-i+1);
	for(ll i=1;i<=n+1;i++)y+=(i-1)*sum[i]-s[i-1];
	
	stack<int>s;
	for(ll i=1;i<=n;i++)
	{
		if(a[i]=='(')s.push(i-1);
		else if(!s.empty())x+=(s.top()+1)*(n-(i-1)),s.pop();
	}
	printf("%lld\n",y/2-x);
}

int main()
{
	int T=read();
	while(T--)solve();
	return 0;
}

```


---

## 作者：lkytxdy (赞：3)

对于一个括号序列，设 $x,y$ 分别为失配的左、右括号数量，则最少操作次数就是 $\max(x,y)$：因为删掉匹配的括号后，失配的括号形如 `))))((((`，进行 $\min(x,y)$ 次右移（如果 `)` 少，直接整体右移，最后形如 `((()))`；否则形如 `)(` 右移成 `()`，最后形如 `()()()`），再补上 $|x-y|$ 个括号即可。

根据 P6689，把 `(` 视作 $1$，`)` 视作 $-1$，求出前缀和 $s_i$。找到 $s_{0\sim n}$ 的最小值 $s_x$，则在此之前有 $-s_x$ 个 `)` 无法匹配，在此之后有 $s_n-s_x$ 个 `(` 无法匹配。所以：
$$
\begin{aligned}
ans&=\sum_{l=1}^n\sum_{r=l}^n\max(-(\min(s_{l-1\sim r})-s_{l-1}),s_r-\min(s_{l-1\sim r}))\\
&=\sum_{l=1}^n\sum_{r=l}^n \max(s_{l-1},s_r)-\min(s_{l-1\sim r})\\
&=\sum_{l=0}^n\sum_{r=l+1}^n \max(s_l,s_r)-\min(s_{l\sim r})\\
\end{aligned}
$$
两项可以拆开，前者枚举 $s_i=\max(s_l,s_r)$，考虑 $s_i$ 的贡献，后者直接单调栈。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int t,n,a[N],top,s[N],L[N],R[N];
long long ans;
char c[N];
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%s",&n,c+1),a[0]=ans=0;
		for(int i=1;i<=n;i++) a[i]=a[i-1]+(c[i]=='('?1:-1);
		top=0;
		for(int i=0;i<=n;i++){
			while(top&&a[i]<a[s[top]]) top--;
			L[i]=top?s[top]+1:0,s[++top]=i;
		}
		top=0;
		for(int i=n;i>=0;i--){
			while(top&&a[i]<=a[s[top]]) top--;
			R[i]=top?s[top]-1:n,s[++top]=i;
		}
		for(int i=0;i<=n;i++)
			ans-=(1ll*(i-L[i]+1)*(R[i]-i+1)-1)*a[i];
		sort(a,a+1+n);
		for(int i=0;i<=n;i++) ans+=1ll*a[i]*i;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：BqtMtsZDnlpsT (赞：3)


### 题意

定义对于一个括号串 $s$ 的值，为通过最小次数以下操作使 $s$ 平衡的操作次数。

- 选择一个子串，循环右移一位。
- 在任意一个位置插入一个任意括号。

求一个括号串的所有非空子串的值的和。

### 题解

一个串怎么做。

设这个串长度为 $l$，下标从 $0$ 开始。

我们的目标是平衡，把左括号看做 $-1$，把右括号看做 $1$，转化为：使和为 $0$，前缀和最小值 $\ge0$。

令 $s$ 表示括号串对应的 $1/-1$ 串。

为了减少讨论：如果前缀和最小值 $\ge 0$，只要在最后补上所需右括号即可。

首先，这个循环右移一格很奇怪，考虑它有什么用。

不难发现，中间不会变，只有最右边的一个括号会移到最左边。

-----------------------------------------------------

- 引理 $1$：若要进行循环右移操作，一定是选择 $[0,i](0<i<l,s_i=1)$，$i$ 为满足条件的最大编号。

	证明：

	这一操作过程中和保持不变，所以不造成影响。

	设操作区间为 $[l,r](r>l)$，前缀和数组 $p$ 发生的变化是：将 $[l,r-1]$ 这一段的值后移一位，并加上 $s_r$，并把 $p_l$ 赋值为 $p_{l-1}+s_r$。

	如果 $s_r=-1$：

	- 如果前缀和最小值在 $[l,r-1]$ 中，因为这一段的数都会减小，所以不能把最小值变大。
	- 如果最小值在右端点上，因为新数组的右端点的值不会发生改变，所以也不能把最小值变大。

	所以 $s_r=1$。
    
    而在这时：最小值不可能在右端点上，因为对于最小值位置 $g$，$s_g=-1$，否则定有 $p_{g-1}<p_g=p_{g-1}+s_g=p_{g-1}+1$。
    
    贪心考虑，为了使最小值尽量大，要让 $r-l$ 尽量大，而 $l$ 一定可以取到 $0$，$r$ 最大能取到 $s_r=1$ 的编号最大的点。
    
    
- 引理 $2$：加入一个左括号一定加在位置 $0$ 之前。

	证明：加入左括号可以看做后缀 $+1$，为了使最小值变大，加最左侧最优（变为全局加）。

定义有效循环右移操作为：操作区间包含全局前缀和最小值的位置的循环右移操作。

在左括号个数 $\ge$ 右括号个数时：
- 加入左括号（全局 $+1$），操作代价为 $2$（因为还要插入右括号使其平衡），并使最小值 $+1$。
  
- 有效循环右移，操作代价为 $1$，并使最小值 $+1$。
  
- 引理 $3$：左括号个数 $\ge$ 右括号个数时，可以通过循环右移操作使最小值 $=0$。
  
  证明：根据引理 $1$，操作右端点为最大的 $s_r=1$ 的位置，若最小值在其后，那么一定是最后一个（其后都是 $-1$），而这意味着左括号个数 $<$ 右括号个数时。

令 $\text{Min}$ 为前缀和最小值，$S_u(u\in\{1,-1\})$ 表示 $u$ 的出现次数 ，操作次数为 $-\text{Min}+S_{1}-S_{-1}$。

在左括号个数 $<$ 右括号个数时：
  
可以通过先在左侧加入左括号来转换为上一种情况。

加入后最小值一定 $\le0$，因为最后一位一定 $=0$。

操作次数为 $S_{-1}-S_{1}-(\text{Min}+S_{-1}-S_1)=-\text{Min}$。

-----------------------------------------------------


综上，操作次数为 $-\min(\text{Min},0)+\max(S_{1}-S_{-1},0)$。

暴力枚举所有区间，我们可以得到 $O(n^2)$ 代码：

```cpp
#define For(i_,l_,r_) for(int i_=(l_);i_<=(r_);i_++)
int ans=0;//ans表示答案.
For(i,1,n){
	int s=0,gg=0;
	For(j,i,n){
		gg+=(tt[j]=='('?1:-1);//tt 是读入的字符串。
		s=min(s,gg);
		ans+=-s+max(gg,0ll);
	}
}
```

考虑把答案分成两部分计算：

称 $S_{l,r}$ 表示 $\sum_{i=l}^rs_i$。

1. $-\min(\text{Min},0)$。

	下称一个区间 $[l,r]$ 的答案 $ans_{l,r}$ 为，这个区间 $-\min(\text{Min},0)$ 的值。
	
    枚举一个子串左端点 $i$ 统计答案。
    
    不难发现，对于 $j(i\le j\le n)$，$ans_{i,j}$ 一定是单调不升的。
    
    并且 $ans_{i,j}>ans_{i,j+1}(i\le j<n)$，当且仅当 $S_{i,j+1}<\min\{S_{i,k}|(i\le k\le j)\}$。
    
    所以可以通过单调栈来维护这一不升序列。
    
    不过有对 $0$ 取 $\min$ 这一操作，但也不难。
    
    我们可以对原串进行单调栈，在每一个位置，二分出第一个 $S_{1,j}-S_{1,i-1}<0 \to S_{1,j}<S_{1,i-1}$ 的位置 $j$，此时只需统计 $j$ 及其后面的部分。
    
    代码：
    
    ```cpp
    #define Rep(i_,l_,r_) for(int i_=(l_);i_>=(r_);i_--)
    Rep(i,n,1){
        while(tp&&p[i]<p[st[tp]])--tp;
        // val[i] 表示 ans 相等的所有区间的 ans 之和。
        if(!tp)val[i]=(n-i+1)*p[i];
        else val[i]=(st[tp]-i)*p[i];
        st[++tp]=i;Now[tp]=Now[tp-1]+val[i];ttt[tp]=p[i];
        int pl=lower_bound(ttt+1,ttt+1+tp,p[i-1])-ttt-1;
        ff[i]=-Now[pl]+p[i-1]*(n-(st[pl]?st[pl]-1:n));
        // ff[i] 表示当前位答案。
    }
    ```
    
2. $\max(S_{1}-S_{-1},0)$

	下称一个区间 $[l,r]$ 的答案 $ans_{l,r}$ 为，这个区间 $\max(S_{1}-S_{-1},0)$ 的值。
    
    不难发现，$ans_{l,r}=\max(S_{l,r},0)$。
    
    我们从大到小枚举 $I(-n\le I\le n)$，计算 $S_{1,i}=-I$ 的左端点 $i+1$ 的答案。
    
    因为枚举了 $I$，每次 $I\leftarrow I-1$ 只要维护当前恰好等于 $0$ 的点。
    
    具体的，我们先把 $S_{1,i}(1\le i\le n)$ 都 $+\text{Min}$，然后把每次等于 $0$ 的扔到 `std::vector` 里。
    
    讲的不是很清楚，可以看代码：
    
    ```cpp
    #define For(i_,l_,r_) for(int i_=(l_);i_<=(r_);i_++)
    #define Rep(i_,l_,r_) for(int i_=(l_);i_>=(r_);i_--)
    GG[n].push_back(0);
    For(i,1,n)p[i]=p[i-1]+(tt[i]=='('?1:-1),GG[p[i]+n].push_back(i);
    int ri=min_(p+1,p+1+n);// 区间取 min。
    int res=0,C=0;
    For(i,1,n)res+=p[i]+max(-ri,0ll),t.add(i,p[i]+max(-ri,0ll));
    Rep(i,max(-ri,0ll),-n){
        for(int U:GG[-i+n])f[U+1]=t.Q(U+1,n)-(C*(n-U-t2.Q(U+1,n))+t1.Q(U+1,n));
        for(int U:GG[-i+n])if(U)t1.add(U,C),t2.add(U,1);
        ++C;
    }
    ```
    
    


---


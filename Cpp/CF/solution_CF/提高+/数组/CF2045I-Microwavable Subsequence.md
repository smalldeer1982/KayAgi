# Microwavable Subsequence

## 题目描述

给定一个整数数组 $[A_1, A_2, \dots, A_N]$，数组长度为 $N$。

从数组中移除零个或多个元素，并保持剩余元素的顺序不变，就可以得到一个子序列。例如，$[2, 1, 2]$、$[3, 3]$、$[1]$ 和 $[3, 2, 1, 3, 2]$ 都是数组 $[3, 2, 1, 3, 2]$ 的子序列，而 $[1, 2, 3]$ 不是。

如果某个子序列最多只包含两种不同的数，并且相邻元素不相同，则称为“微波炉”子序列。例如，$[2, 1, 2]$、$[3, 2, 3, 2]$ 以及 $[1]$ 是微波炉子序列，而 $[3, 3]$ 和 $[3, 2, 1, 3, 2]$ 则不是。

函数 $f(x, y)$ 表示数组 $A$ 中元素仅为 $x$ 或 $y$ 的最长微波炉子序列的长度。请计算所有满足 $1 \leq x < y \leq M$ 的 $f(x, y)$ 之和。

## 说明/提示

### 样例解释 1

$f(1, 2)$ 的值为 $3$，可以从序列中去掉 $A_1$ 和 $A_4$，得到子序列 $[2, 1, 2]$。$f(1, 3)$ 的值为 $3$，通过去除 $A_2$ 和 $A_5$，得到子序列 $[3, 1, 3]$。$f(2, 3)$ 的值为 $4$，从序列中去除 $A_3$，得到子序列 $[3, 2, 3, 2]$。而 $f(1, 4)$、$f(2, 4)$ 和 $f(3, 4)$ 的值均为 $1$。

### 样例解释 2

$f(1, 2)$ 和 $f(1, 3)$ 的值均为 $1$，而 $f(2, 3)$ 的值是 $0$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 4
3 2 1 3 2```

### 输出

```
13```

## 样例 #2

### 输入

```
3 3
1 1 1```

### 输出

```
2```

# 题解

## 作者：灵茶山艾府 (赞：14)

这种整体求和题目，可以先从贡献法开始思考。

从左到右遍历 $a$，考虑 $a_i$ 的贡献：

- 如果 $a_i$ 是首次出现，那么：
  - $a_i$ 和一个不在 $a$ 中的数计算 $f(x,y)$，贡献是 $c$，其中 $c$ 是 $[1,m]$ 中的不在 $a$ 中的整数个数。
  - $a_i$ 和另一个在 $a$ 中且不等于 $a_i$ 的数计算 $f(x,y)$，这样的数有 $m-1-c$ 个。
      - 如果另一个数的首次出现在 $a_i$ 左边，那么把 $a_i$ 加到这个序列的末尾；
      - 如果另一个数的首次出现在 $a_i$ 右边，那么 $a_i$ 作为这个序列的第一个数。
      - 所以 $a_i$ 的贡献是 $m-1-c$。
  - 总的贡献是 $c + (m-1-c) = m-1$。
- 如果 $a_i$ 不是首次出现，设上一次出现的下标为 $\textit{pre}$：
  - 设下标在 $[\textit{pre}+1,i-1]$ 中的**不同的数**的个数有 $k$ 个，我们可以在这 $k$ 个序列的末尾都添加一个 $a_i$，所以 $a_i$ 的贡献是 $k$。

计算区间内不同的数的个数，方法同 [P1972. HH 的项链](https://www.luogu.com.cn/problem/P1972)，用树状数组维护每个数的最新下标，查询区间内下标的个数，即为区间内不同的数的个数。

```go
package main
import("bufio";."fmt";"os")

type fenwick []int

func (f fenwick) update(i, val int) {
	for ; i < len(f); i += i & -i {
		f[i] += val
	}
}

// [1,i] 的元素和
func (f fenwick) pre(i int) (res int) {
	for ; i > 0; i &= i - 1 {
		res += f[i]
	}
	return
}

// [l,r] 的元素和
func (f fenwick) query(l, r int) int {
	return f.pre(r) - f.pre(l-1)
}

func main() {
	in := bufio.NewReader(os.Stdin)
	var n, m, x, ans int
	Fscan(in, &n, &m)
	pre := make([]int, m)
	tree := make(fenwick, n+1)
	for i := 1; i <= n; i++ {
		Fscan(in, &x) // a[i]
		x--
		if pre[x] == 0 {
			ans += m - 1 // a[i] 的贡献
		} else {
			ans += tree.query(pre[x]+1, i) // a[i] 的贡献
			tree.update(pre[x], -1) // 维护 a[i] 的最新下标
		}
		tree.update(i, 1) // 维护 a[i] 的最新下标
		pre[x] = i
	}
	Print(ans)
}
```

**时间复杂度**：$\mathcal{O}(m + n\log n)$。如果把 $\textit{pre}$ 改成哈希表，则时间复杂度为 $\mathcal{O}(n\log n)$。

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)

---

## 作者：_Ch1F4N_ (赞：2)

考虑设计一种贡献方式和判定一个数是否会被算入贡献的方式。

假若当前枚举了颜色 $x,y$，我们认为，对于一个 $a_i = x$ 的 $i$，假若对于最大的满足 $a_j = x$ 且 $j<i$ 的 $j$ 而言 $[j,i]$ 内存在一个颜色为 $y$ 的位置，那么位置 $i$ 就会被算入贡献。

这个算法是对的是因为注意到这个算法相当于模拟了从前往后扫，扫到一个数能加入子序列就加入子序列的贪心算法，这个贪心算法是对的是因为一个能加入数的地方选择不加一定会损失一个贡献，而后面至多多出一个贡献，所以能加不加是不优的。

快速计算贡献考虑对于一个位置 $i$ 令上一个于其颜色相同的位置为 $lst_i$，一个位置 $i$ 的贡献次数就是 $(lst_i,i)$ 内的颜色数，利用 $lst$ 做二维数点，bit 维护即可做到 $O(n \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 3e5+114;
int cnt[maxn],a[maxn],n,m;
int ans;
int col;
int tr[maxn];
void add(int u){
    u++;
    while(u<maxn) tr[u]++,u+=(u&(-u));
}
int pre(int u){
    u++;
    int res=0;
    while(u>0) res+=tr[u],u-=(u&(-u));
    return res;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        int lst=cnt[a[i]];
        if(lst==0) col++;
        cnt[a[i]]=i;
        ans+=pre(max(0*1ll,lst-1))-(lst);
        add(lst);
    }
    cout<<ans+col*(col-1)/2+col*(m-col)<<'\n';
    return 0;
}
```

---

## 作者：Lydia1010__ (赞：1)

## 本题思路：
这道题我们直接算出每一对不同的数字的贡献肯定难如登天 ~~（不排除本人太菜了不会做）~~，我们考虑对于单个点的贡献是什么。

单个点的贡献首先我们知道我们要保证对于每一对不同的颜色最终的序列是最长的，而最长显然有一个贪心就是扫一遍，出现一个与上一次不同的字符就使答案加一，并把这个字符作为下一个的上一个字符。这个贪心显然是正确的，那么我们考虑对于一个点来说，如果这个点要对答案做的贡献那么显然就是和上一个颜色相同的点之间的不同颜色数，这些颜色与当前颜色组合的长度就会因为这个点增加一。

知道了上面这一个点那么就简单多了，我们可以开一个树状数组，把每一个颜色最后出现的位置加一，这样就能直接算出与上一个相同颜色之间有多少不同的颜色了。

但是这样过不去样例，看看样例解释或通读体面就会发现可以选择的两个数中一个数没有出现过贡献也是要被统计的，就是一，那么我们在每个点出现的时候就把他作为一些序列的开头的贡献算上即可（就是总数减去前面出现过的颜色数，这比较好理解，手推一下即可）。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int tr[300005],pd[300005],n,m;
int suan(int p){return p&(-p);}
void add(int p,int k){for(int i=p;i<=n;i+=suan(i))tr[i]+=k;}
int cha(int p){int ans=0;for(int i=p;i;i-=suan(i)) ans+=tr[i];return ans;}
signed main(){
	cin>>n>>m;int ans=0;
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		if(!pd[x]){ans+=m-1;m--;}
		if(pd[x]) add(pd[x],-1);
		add(i,1);
		int sum=cha(i-1)-cha(pd[x]);
		ans+=sum;
		pd[x]=i;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：yeyou26 (赞：0)

# CF2045I
- 官方题解思路。  
- 考虑 $(x,y)$ 中 $x,y$ 是否出现：  
	- $x,y$ 都没有出现：答案为 $0$；  
	- $x,y$ 中只有一个出现过：答案为 $1$，  
		- 显然每一种出现过的数都与每一种没有出现过的数产生 $1$ 的贡献；  
		- 设有 $a$ 个数出现过，$b$ 个数没有出现过，总贡献为 $a\times b$。  
- 接下来讨论 $x,y$ 都出现过如何计算：  
	- 转化：忽略序列中除了 $x,y$ 之外的所有值，$f(x,y)=\texttt{相邻的不同值的对数}+1$；  
	- 例：在 $121$ 这个序列中，相邻的不同值得对数共有两个 $12$ 和 $21$，所以产生 $3$ 的贡献。  
	- 现在只需要求：对于每个下标 $i$，$a_{i}$ 有多少个下标 $j$ 满足：  
		- $j<i$；  
		- $a~[j+1,i-1]$ 之间没有 $a_{i}$ 或 $a_{j}$；  
	- 设 $a_{i}$ 上一次出现的位置为 $l$，我们要求的就是 $a~[l+1,i-1]$ 去重后的数的个数。  
	- 考虑二维数点：  
		- 第一维：下标，需要满足在区间 $[l+1,i-1]$ 内；  
		- 第二维：$lst_{i}$ 表示 $a_{i}$ 上次出现的位置，需要满足在区间 $[-inf,l]$ 内；  
		- 看心情选择维护方式即可。

---


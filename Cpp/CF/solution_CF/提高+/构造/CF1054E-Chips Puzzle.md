# Chips Puzzle

## 题目描述

Egor 想出了一个新的棋子谜题，并邀请你来玩。

该谜题的形式为一个有 $n$ 行 $m$ 列的表格，每个格子中可以按顺序放置若干个黑色或白色棋子。因此，每个格子的状态可以用一个由字符 '0'（白棋子）和 '1'（黑棋子）组成的字符串描述，字符串可能为空。整个谜题可以用一个表格描述，其中每个格子是一个由 0 和 1 组成的字符串。你的任务是将谜题从一种状态变换到另一种状态。

你可以使用如下操作：

- 选择两个不同的格子 $(x_1, y_1)$ 和 $(x_2, y_2)$，这两个格子必须在同一行或同一列，并且格子 $(x_1, y_1)$ 中的字符串必须非空；
- 在一次操作中，你可以将格子 $(x_1, y_1)$ 中字符串的最后一个字符移动到格子 $(x_2, y_2)$ 的字符串开头。

Egor 为你准备了两个表格状态：初始状态和目标状态。保证两个表格中的 0 和 1 的数量相同。你的目标是通过若干次操作，将初始状态变换为目标状态。当然，Egor 不希望操作次数太多。设 $s$ 为每个表格中字符的总数（两者相同），你需要在不超过 $4 \cdot s$ 次操作内完成变换。

## 说明/提示

考虑第一个样例。

- 当前表格状态：  
  00 10  
  01 11  
  第一步操作。格子 $(2, 1)$ 中的字符串为 $01$。对 $(2, 1)$ 和 $(1, 1)$ 执行操作，将 $01$ 的末尾 $1$ 移到 $00$ 的开头，得到 $100$。
- 当前表格状态：  
  100 10  
  0   11  
  第二步操作。格子 $(1, 1)$ 中的字符串为 $100$。对 $(1, 1)$ 和 $(1, 2)$ 执行操作，将 $100$ 的末尾 $0$ 移到 $10$ 的开头，得到 $010$。
- 当前表格状态：  
  10 010  
  0  11  
  第三步操作。格子 $(1, 2)$ 中的字符串为 $010$。对 $(1, 2)$ 和 $(2, 2)$ 执行操作，将 $010$ 的末尾 $0$ 移到 $11$ 的开头，得到 $011$。
- 当前表格状态：  
  10 01  
  0  011  
  第四步操作。格子 $(2, 2)$ 中的字符串为 $011$。对 $(2, 2)$ 和 $(2, 1)$ 执行操作，将 $011$ 的末尾 $1$ 移到 $0$ 的开头，得到 $10$。
- 当前表格状态：  
  10 01  
  10 01  

很容易看出，我们已经达到了目标状态。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2 2
00 10
01 11
10 01
10 01
```

### 输出

```
4
2 1 1 1
1 1 1 2
1 2 2 2
2 2 2 1
```

## 样例 #2

### 输入

```
2 3
0 0 0
011 1 0
0 0 1
011 0 0
```

### 输出

```
4
2 2 1 2
1 2 2 2
1 2 1 3
1 3 1 2
```

# 题解

## 作者：C20203030 (赞：0)

## 一、题目
[点此看题](https://www.luogu.com.cn/problem/CF1054E)

**题目翻译**

给你两个$n\times m$的矩阵，里面的每一个元素都是$01$串，每次可以把$(x_1,y_1)$的末尾的字符插入到$(x_2,y_2)$的首位，要求$(x_1,y_1)\not=(x_2,y_2)$并且$x_1=x_2\space or\space y_1=y_2$，求一个合法的操作序列使得给出的第一个矩阵经过操作后成为第二个矩阵。

**数据范围**

$2\leq n,m\leq300$，字符总数不超过$1e5$
## 二、解法
好像没人发题解，那我来发一个。

一开始看到这道题真的没什么思路，但仔细考虑，本题并未要求操作序列长度最小，所以在一定程度上给了我们乱搞的机会。

考虑一种暴力的构造方法，假设我们能够找到一种状态，让第一个矩阵可以到达，第二个矩阵也可以到达，那我们就可以把它当成中转状态，也就是第一个矩阵的操作序列和第二个矩阵的操作序列反向就可以拼出答案。

我们把所有的$1$放在第一行，所有的$0$放在第二行，这样两个矩阵一定能到达这个状态，且是比较容易操作的。过程中我们要保证``(x1,y1),(x2,y2)``不同但要有行或列的重合，途中判断一下就行了，看代码吧。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 305;
const int M = 400005;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,tot,t,cnt[N][N],ans[M][4];string s;
void ins(int x1,int y1,int x2,int y2)
{
    cnt[x2][y2]++;
    ans[++tot][0]=x1;ans[tot][1]=y1;
    ans[tot][2]=x2;ans[tot][3]=y2;
}
void add(int x,int y,int f)
{
    if(f)
    {
        if(x!=1) ins(x,y,1,y);
        else ins(x,y,1,y==1?2:1);
        return ;
    }
    if(x!=2) ins(x,y,2,y);
    else ins(x,y,2,y==1?2:1);
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            cin>>s;
            for(int k=s.size()-1;k>=0;k--)
                add(i,j,s[k]=='1');
        }
    for(int i=1;i<=2;i++)
        for(int j=2;j<=m;j++)
            for(int k=1;k<=cnt[i][j];k++)
                ins(i,j,i,1);
    t=tot;
    //
    memset(cnt,0,sizeof cnt);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            cin>>s;
            for(int k=0;k<s.size();k++)
            //这里要注意，插入顺序要反向
                add(i,j,s[k]=='1');
        }
    for(int i=1;i<=2;i++)
        for(int j=2;j<=m;j++)
            for(int k=1;k<=cnt[i][j];k++)
                ins(i,j,i,1);
    //
    printf("%d\n",tot);
    for(int i=1;i<=t;i++)
        printf("%d %d %d %d\n",ans[i][0],ans[i][1],ans[i][2],ans[i][3]);
    for(int i=tot;i>t;i--)
        printf("%d %d %d %d\n",ans[i][2],ans[i][3],ans[i][0],ans[i][1]);
}

```



---


# Downloading B++

## 题目描述

距离知名的线上编程大赛Codehorses Round 2017只剩 _T_ 毫秒啦！

Polycarp需要下载B++的编译器来参加这次比赛。文件的大小是 _f_ 字节。

Polycarp的网络套餐能让他以每 _t0_ 秒1字节的速度下载。这个套餐已经付过费了，它的使用也不会导致任何费用。除此以外，互联网服务的提供商额外提供了两个下载包：

- 以每 _t1_ 毫秒1字节的速度下载 _a1_ 字节，价格是 _p1_ “burles”~~（这个单词没查到，反正就是钱的单位）~~。
-  以每 _t2_ 毫秒1字节的速度下载 _a2_ 字节，价格是 _p2_ “burles”。

这些包可以任意购买。买包时，它的价格（ _p1_ 或 _p2_ ）是提前付款的。一旦一个包被购买，它就会取代常规的网络套餐直到到达下载上限。在一个包用完后，Polycarp可以立即买新包或者调到常规的套餐（不损失时间）。一个包正在使用时，Polycarp不能再买包或者调回常规套餐。

你的任务就是找到Polycarp最少需要花多少钱才能在 _T_ 毫秒内下载一个 _f_ 字节的文件。

注意：因为技术原因，不管用哪种手段（常规套餐或下载包），Polycarp的下载的字节数**都是整数**, 即三种下载方式的下载字节数都会是整数。也就是说，Polycarp不能用常规套餐和/或下载包来分块地下载一个字节。

## 说明/提示

在样例一中，Polycarp需要买第一个下载包5次、买第二个下载包0次。他在120×8 = 960毫秒（960 <= 964）内下载了120字节（其实一共下载了26×5 = 130字节）。他总共花了8×5 = 40 "burles"。

在样例二中，Polycarp有足够的时间去下载10字节。花费的时间（10×20 = 200毫秒）等于上限。

在样例三中，Polycarp需要买第一个下载包1次，第二个下载包1次。

在样例四中，Polycarp无法按时下载。

## 样例 #1

### 输入

```
120 964 20
26 8 8
13 10 4
```

### 输出

```
40
```

## 样例 #2

### 输入

```
10 200 20
1 1 1
2 2 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
8 81 11
4 10 16
3 10 12
```

### 输出

```
28
```

## 样例 #4

### 输入

```
8 79 11
4 10 16
3 10 12
```

### 输出

```
-1
```

# 题解

## 作者：Muruski (赞：5)

这才不是黑题...

**题意**

为了在时间T内下载完f个文件，有三种方案，

一种是免费下载，每t0秒下载一个文件。

一种是叠加包，花一定的钱然后能够以每t秒下载一个文件，最多能下a个，用完才能切换。

再就是两种合并

叠加包可以无限购买。求最小的花费。

**题解**

枚举时间最短的套餐使用个数，得到剩余F（剩余数据包）以及剩余T（剩余时间）

然后使用最少的第二个套餐的个数，使得下载F量的数据包满足时间不超过剩余T。（相当于一元不等式，直接解就ok了，有一些细节自己考虑一下）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL inf=1e18;
LL f,T,t0,a1,t1,p1,a2,t2,p2,resF,resT,ans = inf;
int main()
{
	cin>>f>>T>>t0>>a1>>t1>>p1>>a2>>t2>>p2;
	if(t1>t2) 
        swap(a1,a2),swap(p1,p2),swap(t1,t2);
	for(int i=0;(i-1)*a1<=f;++i)
    {
		resF=f-min(i*a1,f),resT=T-min(i*a1,f)*t1;
		if(resF==0) 
        {
			if(resT<0)
                break;
			ans=min(ans,i*p1);
            break;
		}
		if(t0*resF>resT&&t2*resF>resT) 
            continue;
		if(t0*resF<=resT) 
            ans=min(ans,i*p1);
		else
        {
			LL x=(resT-t0*resF)/(t2-t0)+((resT-t0*resF)%(t2-t0)==0?0:1);
			LL pk=(x/a2)+(x%a2==0?0:1);
			ans=min(ans,pk*p2+i*p1);
		}
	}
	ans=max(ans,(LL)0);
	printf("%lld\n",ans<inf?ans:-1);
	return 0;
}
```


---


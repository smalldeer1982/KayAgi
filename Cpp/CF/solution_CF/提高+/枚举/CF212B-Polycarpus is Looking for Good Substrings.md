# Polycarpus is Looking for Good Substrings

## 题目描述

我们把字符串 $ s[a,b]=s_{a}s_{a+1}...\ s_{b} $ $ (1<=a<=b<=|s|) $ 叫做字符串 $ s=s_{1}s_{2}\dots s_{|s|} $ 的一个子串。其中 $ |s| $ 是字符串 $ s $ 的长度。

一个非空字符串 $ t $ 的字符集是包含了字符串 $t$ 中的字符的集合。比如，字符串 `"aab"` 的字符集是 `{'a','b'}`。

让我们把 $C$ 定义为一个任意字符串 $s$ 的子串的字符集。我们将 $r(C,s)$ 叫做 $s$ 的子串集合中满足字符集为 $C$ 的最大内含的数量。而如果对于由子串组成的集合中某个子串 $ s[a,b] $（设其长度为 $ n=b-a+1 $）, 不存在子串 $ s[x,y] $ 长度大于 $ n $ 且  $ 1\le a\le b\le y\le |s| $，那它是这个集合中的一个最大内含。 $ s $ 的两个子串不管内容是否一样，只要位置不同，就会被认定为是不同的。

Polycarpus 在字符串学课上得到了一个有挑战性且实际的一个任务。他必须要对于给定的字符串 $s$ 和字符集 $C_{1},C_{2},\dots,C_{m}$，算出 $ r(C_{i},s)$ $(i\in[1,m])$。

Polycarpus 不想被大学驱逐而参军，所以请帮助他解决这个问题。

## 样例 #1

### 输入

```
aaaaa
2
a
a
```

### 输出

```
1
1
```

## 样例 #2

### 输入

```
abacaba
3
ac
ba
a
```

### 输出

```
1
2
4
```

# 题解

## 作者：睿智的憨憨 (赞：2)

会之前感觉 AC 代码毫无道理，会之后觉得这简直太妙了！

## 解法分析

一句话概括下题意：输出 $s$ 的子串中字符集为 $C$ 的极长串的数量，如果一个串不被任何其他符合要求的串覆盖则是极长的。

好的，题意已经清晰了。最初的想法肯定是每次暴力找极长子串，这样是 $O(m|s|)$ 的，太慢了。看看离线怎么做，设 $ans_i$ 表示字符集为 $C_i$ 时的极长子串数量。

考虑一段极长子串 $[l,r]$，特别关注 $[l,r]$ 中每种字符在 $[l,r]$ 出现的最后一个位置中最小的那个，称其为代表位置 $p$。**那么 $[p,r]$ 中会出现所有在 $[l,r]$ 中出现过的字符，且 $s_p$ 在 $[p,r]$ 中只出现一次，且 $s_{p+1}$ 不在 $[p,r]$ 中出现，且 $[p,r]$ 和 $[l,r]$ 是一一对应的**。

于是可以枚举 $p$，设 $j$ 为满足 $i>p,s_i=s_p$ 的最小 $i$，那么 $r$ 可以是 $p \sim j-1$，顺序遍历 $r$，如果 $s_{r+1}$ 不在 $[i,r]$ 中，则当前 $[p,r]$ 对应了一个极长的字符集为 $[p,r]$ 中字符的子串，答案 $+1$ 即可。

分析下时间复杂度：对于每种字符，都会遍历一遍 $s$，因此时间复杂度为 $O(k|s|),k=26$。

## 参考代码
还有些细节，比如 $C_i=C_j$ 怎么处理，爆空间需要开 short，具体看代码。

```
#include <bits/stdc++.h>
#define ll long long
#define ld long double
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pushf push_front
#define pushb push_back
#define popf pop_front
#define popb pop_back
#define lowbit(x) (x-(x&(x-1)))
using namespace std;

int n, m, msk[10010], ans[10010];
short id[(1 << 26) + 10];
string s, C[10010];

int main(){
	ios::sync_with_stdio(false);
	
	cin >> s >> m;
	for (int i = 1; i <= m; i++)
		cin >> C[i];
	
	for (int i = 1; i <= m; i++){
		for (int j = 0; j < C[i].size(); j++)
			msk[i] |= (1 << (C[i][j] - 'a'));
		id[msk[i]] = i;
	}
	
	n = s.size(), s = ' ' + s;
	for (int i = 1; i <= n; i++){//指定i为代表位 
		int S = 0;
		for (int j = i; j <= n; j++){//此时[i,j]的字符集就代表了整串的字符集 
			if (i != j && s[j] == s[i])
				break;
			S |= (1 << (s[j] - 'a'));
			if (j == n || !((S >> (s[j + 1] - 'a')) & 1))
				ans[id[S]]++; 
		}
	}
	
	for (int i = 1; i <= m; i++)
		cout << ans[id[msk[i]]] << "\n";
	return 0;
}
```

---

## 作者：CarroT1212 (赞：1)

非常好时间复杂度，使我的大脑旋转。

------------

给定一个字符串 $s$ 和 $q$ 次询问，每次询问给定一个字符集 $C$，请你输出对于原序列中所有字符集**恰好**为 $C$ 的最大包含子串**最多**共有多少个。其中最大包含子串即不存在另一个字符集恰好为 $C$ 的子串将其完全包含。

$1 \le |s| \le 10^6$，$1 \le q \le 10^4$。

------------

首先字符集可以 $2^{26}$ 状压。考虑能不能离线把每个字符集的答案先求出来询问时再输出。先不管空间炸不炸的。

考虑每个子串是否可能成为某些字符集的最大包含子串。根据定义可知 $s$ 中 $[i,j]$ 可以成为字符集 $C$ 的最大包含子串仅当 $s_{i-1}\notin C,s_{j+1}\notin C,\{s_i,s_i+1,\cdots,s_j\}=C$。

先考虑暴力，枚举 $i$，从 $i$ 开始枚举 $j$，记录此时 $[i,j]$ 的字符集 $C$，每次到一个新的 $j$ 时，如果 $s_j$ 是一个 $C$ 里面没有的字符就将目前的 $C$ 的答案 $+1$ 然后更新 $C$（原本的 $C$ 不可能从 $i$ 开始扩展到更后面的位置了，打住），出现 $s_j=s_{i-1}$ 就不合法（保证字符集在最优策略下一定从 $i$ 这个左端点开始扩展）。于是我们喜提 $O(n^2)$ 做法……

吗？如果我们遇到 $s_j=s_{i-1}$ 就直接退出，$s$ 的每个位置都只会被从前面最后一次出现的字符开始遍历一次，所以实际上复杂度是 $O(|C|V)$ 的，已经可以通过。

但是你开了一个 $2^{26}$ 的数组，原地爆炸。答案数组值域是 $[0,O(n)]$，显然没法用 `short` 大法解决，怎么办呢。

注意到 $1 \le q \le 10^4$。也就是说如果我们只记每个字符集在询问序列中在哪个位置出现过，然后只记询问过的字符集的答案，那么答案数组大小变为 $q$，记录出现位置的数组虽然还是要开 $2^{26}$，但是它的值域是 $[1,q]$，可以开 `short` 卡过去。注意一个字符集可能在询问中出现多次。

------------

```cpp
const int I=1e9,N=1e6+7,K=7e7+7;
int n,m,b[N],cnt[N];
short p[K];
char str[N],inp[28];
void mian() {
	scanf("%s%d",str+1,&m),n=strlen(str+1);
	for (int i=1,len;i<=m;i++) {
		scanf("%s",inp+1),len=strlen(inp+1);
		for (int j=1;j<=len;j++) b[i]|=1<<inp[j]-'a';
		p[b[i]]=i;
	}
	for (int i=1;i<=n;i++) for (int j=i,s=0;j<=n&&str[j]!=str[i-1];j++) {
		s|=1ll<<str[j]-'a';
		if (s>>str[j+1]-'a'&1^1) cnt[p[s]]++;
	}
	for (int i=1;i<=m;i++) cout<<cnt[p[b[i]]]<<"\n";
}
```

---


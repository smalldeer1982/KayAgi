# Tree Array

## 题目描述

You are given a tree consisting of $ n $ nodes. You generate an array from the tree by marking nodes one by one.

Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree.

After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node.

It can be shown that the process marks all nodes in the tree.

The final array $ a $ is the list of the nodes' labels in order of the time each node was marked.

Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.

The number of inversions in an array $ a $ is the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i > a_j $ . For example, the array $ [4, 1, 3, 2] $ contains $ 4 $ inversions: $ (1, 2) $ , $ (1, 3) $ , $ (1, 4) $ , $ (3, 4) $ .

## 说明/提示

This is the tree from the first sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/3833e6cdc8f432e8774aa8c02d9352118566a812.png)For the first sample, the arrays are almost fixed. If node $ 2 $ is chosen initially, then the only possible array is $ [2, 1, 3] $ ( $ 1 $ inversion). If node $ 3 $ is chosen initially, then the only possible array is $ [3, 1, 2] $ ( $ 2 $ inversions). If node $ 1 $ is chosen initially, the arrays $ [1, 2, 3] $ ( $ 0 $ inversions) and $ [1, 3, 2] $ ( $ 1 $ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $ \frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6} $ .

 $ 166666669 \cdot 6 = 7 \pmod {10^9 + 7} $ , so the answer is $ 166666669 $ .

This is the tree from the second sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/7f613b365926417ec34142a093ccc13b3b572f4f.png)This is the tree from the third sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/4cf8ac5fc765cc7cdc6657a332a13e66dcba8fef.png)

## 样例 #1

### 输入

```
3
1 2
1 3```

### 输出

```
166666669```

## 样例 #2

### 输入

```
6
2 1
2 3
6 1
1 4
2 5```

### 输出

```
500000009```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
2 5```

### 输出

```
500000007```

# 题解

## 作者：Acfboy (赞：33)

虽然作为 Div.2 D 题难度可能有些太大了，但题是好题。

> 一棵树，开始时等概率选一个点标记，然后每一步在和已经选择的点相邻的所有点的集合中等概率选择一个点标记。把点编号按照选择的先后排序，求期望逆序对数。

显然，选出的点和最先选出的点是连成一块的，所以根在这里非常的重要，于是想到可以枚举一个根，分别求出期望后在除以 $n$。

因为题目要求的是期望逆序对数，所以可以考虑可以把每一对逆序对分开来求对期望的贡献再求和。即要考虑一个点 $a$ 比 $b$ 先取到的概率是多少，所有这样的概率的和就是期望。  
可以发现，在一层层往下选点的过程中，每一个点在某一步选到的概率就是路径上点选到的概率的积，也就是说，后面选到 $a$ 和 $b$ 的概率在我们求道 $a, b$ 的 LCA 的时候还是一样的。

那么要考虑的就是从 LCA 到 $a, b$ 的一段中 $a$ 比 $b$ 先的概率。

官方题解中将这个问题转换成了这样的一个问题：  
>给你两个栈，每次有 $p$ 的概率把第一个的栈顶弹出，$p$ 的概率把第二个的栈顶弹出，$1-2p$ 的概率啥也不做，问 $a$ 比 $b$ 先弹完的概率是多少。

这两个问题是等价的，因为 $p$ 的概率就是从现在的所有东西中取到往 $a$ 和 $b$ 中的一个的概率，而 $1-2p$ 就是其它的。  
可是……这个概率怎么搞啊，$p$ 有很多种可能，又是在变的，好像很不可做。

其实 $p$ 到底是多少，是不是确定根本没有关系，因为分开讨论了每个逆序对 $a, b$, 所以那个 $1-2p$ 在干什么我们一点也不关心，只要往 $a, b$ 的走的概率是相等的就可以了。  
这样就可以直接倒过来 dp 求了， $f_{i, j} = \frac{f_{i-1,j}+f{i,j-1}}{2}$，初始值就是 $i$ 为 $0$ 的时候概率是 $1$。

那么这个问题就解决了，只要枚举一个根，然后对于每个点对 $(a, b)$（设深度为 $x, y$）求个 LCA（深度为 $l$)，然后把 $f_{x-l,y-l}$ 加进答案离就可以了。

直接做时间 $\mathcal O(n^3 \log_2 n)$，预处理 LCA 后复杂度 $\mathcal O(n^3)$，都可以通过。

代码。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#define int long long
const int N = 205, P = 1000000007, inv2 = 500000004;
int n, x, y, fa[N][20], f[N][N], dep[N], ans;
std::vector<int> g[N];
int Pow(int a, int b) {
    int an = 1;
    for( ; b; b >>= 1, a = a * a % P) 
        if(b & 1) an = an * a % P;
    return an;
}
void dfs(int u, int par) {
    fa[u][0] = par, dep[u] = dep[par] + 1;
    for (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];
    for (int i = 0; i < (signed)g[u].size(); i++) {
        int v = g[u][i];
        if (v != par) dfs(v, u);
    }
}
int LCA(int x, int y) {
    if (dep[x] < dep[y]) std::swap(x, y);
    for (int i = 19; i >= 0; i--)
        if (dep[x] - (1 << i) >= dep[y])
            x = fa[x][i];
    if (x == y) return x;
    for (int i = 19; i >= 0; i--)
        if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}
signed main() {
    scanf("%lld", &n);
    for (int i = 1, x, y; i < n; i++) {
        scanf("%lld%lld", &x, &y);
        g[x].push_back(y);
        g[y].push_back(x);
    }
    for (int i = 1; i <= n; i++) f[0][i] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) 
            f[i][j] = (f[i-1][j] + f[i][j-1]) * inv2 % P;
    for (int i = 1; i <= n; i++) {
        dfs(i, 0);
        for (int j = 1; j <= n; j++)
            for (int k = 1; k < j; k++) {
                int lca = LCA(j, k);
                ans = (ans + f[dep[j]-dep[lca]][dep[k]-dep[lca]]) % P;
            }
    }        
    printf("%lld", ans * Pow(n, P-2) % P);
    return 0;
}
```

---

## 作者：dead_X (赞：7)

## 前言
不可发送单个标点符号。
## 思路
不难想到对每个最开始选的点分开考虑。

在选定第一个数后，我们考虑每对数的贡献。

不难发现如果令 $x$ 为根，每对数有以下几种情况：

1. 祖先关系

先取的数已经固定了，贡献只能为 $1$ 或 $0$。

2. 非祖先关系。

不难发现在插入它们的 LCA 后，剩下的插入要么与这两个点无关，要么等概率让它们其中的一个距离已选区域距离减 $1$。

于是，我们可以预处理，插入 LCA 后，两个点需要 $x,y$ 步，第一个点先到的概率。这个预处理十分简单，显然有 $f(x,y)=\frac{1}{2}(f(x-1,y)+f(x,y-1))$，$x=0$ 时答案为 $1$，$y=0$ 时答案为 $0$。

时间复杂度 $O(n^3)$ 或 $O(n^3\log n)$，代码很好写。
## 代码
```cpp
// Problem: CF1540B Tree Array
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/CF1540B
// Memory Limit: 250 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//And in that light,I find deliverance.
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
const int p=1e9+7;
int qp(int x,int y)
{
	int res=1;
	for(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;
	return res;
}
int n=read();
vector<int> e[1003];
int s;
int sz[1003];
int f[1003][1003];
//x steps,y steps,x first
void init(int n)
{
	for(int i=1; i<=n; ++i) f[0][i]=1;
	for(int i=1; i<=n; ++i)
	for(int j=1; j<=n; ++j)
	f[i][j]=(f[i-1][j]+f[i][j-1])*qp(2,p-2)%p;
	return ;
}
void getd(int x,int fa,int v)
{
	if(x<v) ++s;
	for(int i:e[x]) if(i!=fa) getd(i,x,v);
}
void dfs(int x,int fa)
{
	getd(x,fa,x);
	for(int i:e[x]) if(i!=fa) dfs(i,x);
}
vector<pair<int,int> > c[1003];
void calc(int x,int fa,int id,int d)
{
	for(pair<int,int> i:c[id]) if(x>i.first)
		s=(s+f[d][i.second])%p;
	else s=(s+f[i.second][d])%p;
	for(int i:e[x]) if(i!=fa) calc(i,x,id,d+1);
}
void add(int x,int fa,int id,int d)
{
	c[id].push_back(make_pair(x,d));
	for(int i:e[x]) if(i!=fa) add(i,x,id,d+1);
}
void dfs2(int x,int fa)
{
	for(int i:e[x]) if(i!=fa) calc(i,x,x,1),add(i,x,x,1);
	for(int i:e[x]) if(i!=fa) dfs2(i,x);
}
void calc(int x)
{
	for(int i=1; i<=n; ++i) c[i].clear();
	dfs(x,x);
	dfs2(x,x);
}
signed main()
{
	init(n);
	for(int i=1,p,q; i<n; ++i) 
	p=read(),q=read(),e[p].push_back(q),e[q].push_back(p); 
	for(int i=1; i<=n; ++i)
	calc(i);
	printf("%lld\n",s*qp(n,p-2)%p);
	return 0;
}
```

---

## 作者：白鲟 (赞：5)

## 题目描述
从一棵树中随机选择一个根结点，并每次选择一个与当前选定连通块直接相邻的结点，求选择结点排列的期望逆序对数。

## 题目分析
刚拿到题目的时候会想到不少期望题并感觉可做。

根据期望的线性性质，拆成求每一对逆序对出现的期望次数（即概率）之和。

题目给出 $n\le 200$ 的数据范围，不妨枚举根结点，再枚举每对逆序点，求较大点比较小点先出现的概率。发现在从根结点取到 LCA 前所取点对答案无影响。由于取点随机，从 LCA 开始，摒除无用取点，每一步向较大点或较小点等概率逼近一步。因此所求概率只与两点与 LCA 的深度差有关，可用 $\operatorname{O}(n^2)$ DP 预处理。


通过在每个点预处理子树内 LCA，总时间复杂度为 $\operatorname{O}(n^3)$。
## 代码
```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int maxn=200,mod=1e9+7;
int n,x,y,ans,inv2,tag,LCA[maxn+1][maxn+1],depth[maxn+1],order[maxn+1],list[maxn+1],size[maxn+1],f[maxn+1][maxn+1];
vector<int> edge[maxn+1];
int power(int base,int exponent,int mod)
{
	int result=1;
	while(exponent)
	{
		if(exponent&1)
			result=(long long)result*base%mod;
		base=(long long)base*base%mod;
		exponent>>=1;
	}
	return result%mod;
}
void dfs(int now,int parent)
{
	order[now]=++tag;
	list[tag]=now;
	size[now]=1;
	depth[now]=depth[parent]+1;
	for(int i=0;i<edge[now].size();++i)
		if(edge[now][i]!=parent)
		{
			dfs(edge[now][i],now);
			size[now]+=size[edge[now][i]];
		}	
	for(int i=0;i<edge[now].size();++i)
		if(edge[now][i]!=parent)	
			for(int j=order[edge[now][i]];j<=order[edge[now][i]]+size[edge[now][i]]-1;++j)
				for(int k=order[now];k<order[edge[now][i]];++k)
					LCA[list[k]][list[j]]=LCA[list[j]][list[k]]=now;		
	return;
}
int calc(int x)
{
	int res=0;
	tag=0;
	dfs(x,0);
	for(int i=1;i<=n;++i)
		for(int j=1;j<i;++j)
			res=(res+f[depth[i]-depth[LCA[i][j]]][depth[j]-depth[LCA[i][j]]])%mod;
	return res;
}
int main()
{
	inv2=power(2,mod-2,mod);
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		f[0][i]=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			f[i][j]=(long long)(f[i-1][j]+f[i][j-1])*inv2%mod;
	for(int i=1;i<n;++i)
	{
		scanf("%d%d",&x,&y);
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	for(int i=1;i<=n;++i)
		ans=(ans+calc(i))%mod;
	printf("%lld",(long long)ans*power(n,mod-2,mod)%mod);
	return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：4)

[传送门](codeforces.com/contest/1540/problem/B)

被 2300* 简单期望题罚坐两小时，太丢人了。

##### 分析：

不难想到钦定根，然后枚举点对 $i<j$ 造成的贡献，即 $j$ 在 $i$ 之前出现的概率。每个根的贡献相加再除以 $n$ 就是最后答案。大多数人都止步于此（包括我）

我们只关心 $(i,j)$ 出现的顺序，所以可以忽略 $i,j$ 路径以外的所有点，它们显然并不影响 $j$ 在 $i$ 之前的概率。

显然如果染色第一个就染 $lca(i,j)$. 从这个时候开始考虑 $j$ 在 $i$ 前出现的概率。

容易发现每次染色集合向 $i$ 靠近一步和向 $j$ 靠近一步的概率是相等的 $\frac{1}{2}$. （注意已经把不在路径上的点都抛弃了）。 则转化为：$a$ 与 $b$ 两者等概率的其中一个减去 $1$，问 $b$ 比 $a$ 先成为 $0$ 的概率。不难写出 dp 式子：
$$
 f(a,b)=\frac{1}{2}(f(a-1,b)+f(a,b-1))
$$
然后 $j$ 在 $i$ 前的概率即 $f(dis(i,lca),dis(j,lca))$.

因此在 $O(n^3 \log n)$ 的时间里切掉。

另外注意并不需要保存分母分子每次通分最后算，对分数直接乘上分母逆元变成整数即可。

```C++
#include<bits/stdc++.h>
#define rep(i,a,b) for(ll i=(a);i<=(b);i++)
#define per(i,a,b) for(ll i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define next Cry_For_theMoon
#define il inline
#define pb(x) push_back(x)
#define is(x) insert(x)
#define sit set<int>::iterator
#define mapit map<int,int>::iterator
#define pi pair<int,int>
#define ppi pair<int,pi>
#define pp pair<pi,pi>
#define fr first
#define se second
#define vit vector<int>::iterator
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef double db;
using namespace std;
const int MAXN=210,moder=1e9+7;
struct Edge{
	int u,v;
}edge[MAXN*2];
int first[MAXN],next[MAXN*2],tot;
int n,u,v;
int fa[MAXN][10],depth[MAXN];
ll ans,f[MAXN][MAXN];
ll power(ll a,ll n){
	if(!n)return 1;
	ll tmp=power(a,n/2);tmp=tmp*tmp%moder;
	if(n&1)tmp=tmp*a%moder;
	return tmp;
}
void addedge(int u,int v){
	edge[++tot]=(Edge){u,v};next[tot]=first[u];first[u]=tot;
}
void dfs(int u){
	rep(j,1,9)fa[u][j]=fa[fa[u][j-1]][j-1];
	for(int j=first[u];j;j=next[j]){
		int v=edge[j].v;if(v==fa[u][0])continue;
		fa[v][0]=u;depth[v]=depth[u]+1;dfs(v);
	} 
}
int lca(int x,int y){
	if(depth[x]>depth[y])swap(x,y);
	per(j,9,0){
		if(depth[y]-(1<<j)>=depth[x])y=fa[y][j];
	}
	if(x==y)return x;
	per(j,9,0){
		if(fa[x][j]!=fa[y][j])x=fa[x][j],y=fa[y][j];
	}
	return fa[x][0];
}
ll calc(int u){
	rep(j,0,9)fa[u][j]=0;
	depth[u]=1;
	dfs(u);
	ll ans=0;
	rep(i,1,n){
		rep(j,i+1,n){
			int l=lca(i,j);
			ans=(ans+f[depth[i]-depth[l]][depth[j]-depth[l]])%moder;
		}
	}
	return ans;
}
int main(){
	scanf("%d",&n);
	rep(i,1,n-1){
		scanf("%d%d",&u,&v);
		addedge(u,v);addedge(v,u);
	}
	rep(i,1,n)f[i][0]=1;
	rep(i,1,n){
		rep(j,1,n){
			f[i][j]=(f[i][j]+f[i-1][j]*power(2,moder-2))%moder;
			f[i][j]=(f[i][j]+f[i][j-1]*power(2,moder-2))%moder;
		}
	}
	rep(i,1,n){
		ans=(ans+calc(i)*power(n,moder-2))%moder;
	}
	cout<<ans;
	return 0;
}
```



 



---

## 作者：_ZSR_ (赞：3)

### [CF1540B Tree Array](https://www.luogu.com.cn/problem/CF1540B)

因为每次打标记都只能选择与已经标记了的节点相邻的节点，所以任意时刻被标记的节点一定都是与根节点连通的。这样的话我们可以枚举根节点，对于每个根节点统计答案，最后除以一个 $n$。

枚举根节点只用了 $O(n)$ 的复杂度，大概还剩下 $O(n^2)$ 的时间可以使用。并且期望拥有线性性质，因此我们可以枚举每一对逆序对，计算产生的概率，最后求和。对于一对逆序对 $(x,y)$，其中 $x>y$，我们要让 $x$ 在 $y$ 之前被打上标记，也就是要让根节点先走到 $x$。那么问题可以转换成有两个栈，每次有 $p$ 的概率弹第一个栈，有 $p$ 的概率弹第二个栈，还有 $1-2 \times p$ 的概率一个也不弹，求第一个栈比第二个栈先弹完的概率。但是这个 $p$ 是不断变化的，不好求解。仔细观察转换后的问题可以发现，我们只关心这两个栈哪一个先弹完，对于那 $1-2 \times p$ 的概率下做什么我们并不需要知道，而且弹栈的概率是相等的。因此，我们可以通过 $O(n^2)$ 预处理出 $dp_{i,j}$ 表示第一个栈的大小为 $i$，第二个栈的大小为 $j$，第一个栈比第二个栈先弹完的概率。最开始有 $dp_{0,i}=1$。转移就是 $dp_{i,j}=\frac {dp_{i-1,j}+dp_{i,j-1}} {2}$。

预处理完之后直接对于每一个根节点枚举每一对逆序对计算贡献。还有一点就是不论是走到 $x$ 还是走到 $y$，从根节点到 $x,y$ 的最近公共祖先的这一段都是相同的，因此我们只要考虑最近公共祖先到两点的距离作为栈的大小即可。

code
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=210,mod=1e9+7,inv=500000004;
int n;
int h[N],to[N<<1],nxt[N<<1],idx;
int dep[N],lg[N],fa[N][10];
int dp[N][N];
inline void add(int a,int b)
{
    to[++idx]=b;
    nxt[idx]=h[a];
    h[a]=idx;
}
inline int ksm(int a,int b)
{
    int res=1;
    while (b)
    {
        if (b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
void dfs(int u,int fath)
{
    fa[u][0]=fath;
    dep[u]=dep[fath]+1;
    for (int i=1;i<10;++i) fa[u][i]=fa[fa[u][i-1]][i-1];
    for (int i=h[u];i;i=nxt[i])
    {
        int v=to[i];
        if (v==fath) continue;
        dfs(v,u);
    }
}
inline int lca(int x,int y)
{
    if (dep[x]<dep[y]) swap(x,y);
    while (dep[x]>dep[y]) x=fa[x][lg[dep[x]-dep[y]]-1];
    if (x==y) return x;
    for (int i=lg[dep[x]]-1;i>=0;--i)
    {
        if (fa[x][i]!=fa[y][i])
        {
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return fa[x][0];
}
signed main()
{
    scanf("%lld",&n);
    for (int i=1;i<=n;++i) lg[i]=lg[i-1]+(1<<lg[i-1]==i);
    for (int i=1;i<n;++i)
    {
        int u,v;
        scanf("%lld%lld",&u,&v);
        add(u,v),add(v,u);
    }
    for (int i=1;i<=n;++i) dp[0][i]=1;
    for (int i=1;i<=n;++i)
    {
        for (int j=1;j<=n;++j)
        {
            dp[i][j]=(dp[i-1][j]+dp[i][j-1])*inv%mod;
        }
    }
    int ans=0;
    for (int i=1;i<=n;++i)
    {
        dfs(i,0);
        for (int j=1;j<=n;++j)
        {
            for (int k=1;k<j;++k)
            {
                int p=lca(j,k);
                ans=(ans+dp[dep[j]-dep[p]][dep[k]-dep[p]])%mod;
            }
        }
    }
    printf("%lld\n",ans*ksm(n,mod-2)%mod);
    return 0;
}
```


---

## 作者：云浅知处 (赞：2)

考虑先枚举第一个选的点作为根，然后再枚举点的编号 $x>y$ 且 $x$ 比 $y$ 先选的概率。最后把每个点作为根时的答案加起来除以 $n$ 即可。

那么一个显而易见的事情就是如果选定了根为 $u$，那么如果要选一个点 $x$，$u\to x$ 这条路径上的点必须都要先被选到；$y$ 同理。

考虑 $x,y$ 的 $\text{LCA}$，设为 $z$。那么想要选到 $x,y$，就必须先从 $u$ 一路选到 $z$。这部分二者是重合的，对 「$x$ 比 $y$ 先选」这一事件的概率没有贡献。

那么接下来选到了 $z$ 之后，我们考虑 $z\to x$ 与 $z\to y$ 两条路径。每一次我们在两条路径上选点的概率是相等的（尽管这个概率在不断变化，但对于 $x,y$ 而言是一样的），而我们要先选到 $x$。

因此可以考虑一个 dp：设 $F(i,j)$ 表示「左边有 $i$ 个点，右边有 $j$ 个点，每次等概率地选一边扔掉一个点，最后左边先扔完的概率」。通过考虑最后一次扔掉了哪边的点，我们得到转移方程 

$$F(i,j)=\dfrac{F(i,j-1)+F(i-1,j)}{2}$$

那么此时先选到 $x$ 的概率就是 $F(\text{dist}(x,z)-1,\text{dist}(y,z)-1)$，其中 $\text{dist}(a,b)$ 表示 $a\to b$ 这条路径上的点数（包括端点）。

时间复杂度为 $O(n^3\log n)$。$\log$ 来自于求 $\text{LCA}$。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

const int MN=205;
const int mod=1e9+7;

int ksm(int x,int y,int p=mod){
    int res=1;x%=p;
    for(int i=y;i;i>>=1,x=x*x%p)if(i&1)res=res*x%p;
    return res%p;
}

int inv(int x,int p=mod){return ksm(x,p-2,p);}

int f[MN][MN],n;
vector<int>G[MN];
int fa[MN][25],dep[MN];

void dfs(int u){
    for(int v:G[u])if(v!=fa[u][0])dep[v]=dep[u]+1,fa[v][0]=u,dfs(v);
}

int ans=0;

int LCA(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=20;i>=0;i--)if(dep[x]-(1<<i)>=dep[y])x=fa[x][i];
    if(x==y)return x;
    for(int i=20;i>=0;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}

void calc(int u){
    fa[u][0]=0,dep[u]=1;dfs(u);
    for(int i=1;i<=20;i++)for(int x=1;x<=n;x++)fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int x=1;x<=n;x++){
        for(int y=1;y<x;y++){
            int z=LCA(x,y);
            ans=(ans+f[dep[x]-dep[z]][dep[y]-dep[z]])%mod;
        }
    }
}

signed main(void){

    n=read();
    for(int i=1;i<=n-1;i++){
        int u=read(),v=read();
        G[u].push_back(v),G[v].push_back(u);
    }

    for(int i=1;i<=n;i++)f[i][0]=0,f[0][i]=1;
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)f[i][j]=(f[i-1][j]+f[i][j-1])%mod*inv(2)%mod;
    
    for(int i=1;i<=n;i++)calc(i);

    cout<<ans%mod*inv(n)%mod<<endl;

    return 0;
}
```

---

## 作者：BzhH (赞：2)

一道概率好题

题目给出 $1\le n\le 200$ 显然是想让我们直接枚举每个逆序对，那么我们就考虑每个逆序对对答案的贡献，此时，我们就不用再管其它点了，只需要考虑 $i,j$ 的相对位置，从根节点到 LCA 的概率显然不会影响答案，那么就只需要考虑 LCA 到 $i,j$ 之间的概率，每次走到向 $i,j$ 靠近一步的概率是相等的，可以直接用
$O(n^2)$ 的 DP 求出，$f_{x,y}$ 表示当前距 $i$ 点 $x$ 步，$j$ 点 $y$ 步先走到 $i$ 点的概率，转移方程为 $f_{x,y}=\frac{f_{x-1,y}+f{x,y-1}}{2}$，
最后只需要再枚举一下根就行了，总时间复杂度为 $O(n^3log~n)$

代码

```
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 505, MOD = 1e9 + 7;
typedef long long ll;

int head[N], ver[N], net[N], idx;
int fa[N][11], dep[N], f[205][205];

void add(int a, int b)
{
    net[++idx] = head[a], ver[idx] = b, head[a] = idx;
}

void dfs(int u, int f)
{
    dep[u] = dep[f] + 1, fa[u][0] = f;
    for (int i = 1; i <= 9; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int i = head[u]; i; i = net[i])
    {
        int v = ver[i];
        if (v == f)
            continue;
        dfs(v, u);
    }
}

int lca(int x, int y)
{
    if (dep[x] < dep[y])
        swap(x, y);
    for (int i = 9; i >= 0; i--)
        if (dep[fa[x][i]] >= dep[y])
            x = fa[x][i];
    if (x == y)
        return x;
    for (int i = 9; i >= 0; i--)
        if (fa[x][i] != fa[y][i])
            x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}

int qmi(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1)
            res = (ll)res * a % MOD;
        a = (ll)a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i < n; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v), add(v, u);
    }
    int inv2 = 500000004;
    for (int i = 1; i <= n; i++)
        f[0][i] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            f[i][j] = (ll)(f[i - 1][j] + f[i][j - 1]) * inv2 % MOD;
    ll ans = 0;
    for (int i = 1; i <= n; i++)
    {
        dfs(i, 0);
        for (int j = 1; j <= n; j++)
        {
            for (int k = 1; k < j; k++)            
            {
                int u = lca(j, k);
                (ans += f[dep[j] - dep[u]][dep[k] - dep[u]]) %= MOD;
            }
        }
    }
    printf("%lld", ans * qmi(n, MOD - 2) % MOD);
    return 0;
}
```

---

## 作者：dcmfqw (赞：2)

题目大意：给定一棵 $n$($1\le n\le200$) 个节点的树，首先等概率随机选择一个节点，然后每次操作等概率随机选一个未选过的但是与选过的点相邻的点，所有点选完后根据选择的顺序将点的编号排成一个排列，求这个排列的期望逆序对数，答案模以 $10^9+7$。

$1\le n\le200$ 显然是允许我们直接枚举每对节点的。

设这对节点中编号小的点为 $a$，编号大的点为 $b$。

那么 $b$ 比 $a$ 后选中便可将逆序对数量加 1。

由于期望的线性性，所以算出来 $b$ 比 $a$ 后选中的概率就可以直接加到答案中了。

接下来根据根节点即第一次选中的点的位置，可以算出来 $a$ 和 $b$ 的 $lca$，设为 $l$。

会发现操作时一个节点必须等它的父节点选后才能选，所以在选中 $l$ 前的选择是对答案即 $a$ 与 $b$ 选中的先后顺序没有关系的。

进一步会发现选中除了 $a$ 到 $b$ 路径上的点以外的所有点都对答案没有影响。

然后可以感性将题目转化成这个问题：给你两个桶，分别装有 $dist(a,l)$ 和 $dist(b,l)$ 个球，每次可以从两个桶中随机选一个，然后从中取一个球，问有多大的概率第二个比第一个桶先取完。

由于选节点的是等概率地选，选桶自然也是等概率地选。

由于 $1\le n\le200$，所以依然可以放心大胆地 dp。

设 $f_{i,j}$ 为第一个桶有 $i$ 个球，第二个桶有 $j$ 个球的答案。

转移方程：

$$f_{i,j}=\frac{f_{i-1,j}+f_{i,j-1}}{2}$$

边界条件：

$$f_{i,0}=0,f_{0,i}=1(i>0)$$

当然可以像上一篇题解一样枚举 $a$ 和 $b$ 然后枚举根再算 $l$。

我是先枚举 $a$，然后以 $a$ 为根 dfs 枚举 $b$，最后在 dfs 函数内枚举 $b$ 的祖先即所有可能的 $l$。

这样根可以通过 $size$ 直接算出选中的根使得 $l$ 为 $a$ 与 $b$ 的 lca 的概率，具体看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inl inline
#define rep(i, d, u) for(int i = d; i <= u; ++i)
#define dep(i, u, d) for(int i = u; i >= d; --i)
#define cep(n) while(n--)
#define gep(i, a) for(int i = firs[a]; i; i = neig[i])
int ured() {
	int re = 0, ch;
	do {
		ch = getchar();
	} while('9' < ch || ch < '0');
	do {
		re = re * 10 + (ch ^ '0');
	}	while('0' <= (ch = getchar()) && ch <= '9');
	return re;
}
void uwit(int da) {
	int cn = 0, ch[21];
	do {
		ch[++cn] = da - da / 10 * 10;
	} while(da /= 10);
	do {
		putchar('0' ^ ch[cn]);
	} while(--cn);
}
inl void dmax(int&fr, int to) {
	if(fr < to) {
		fr = to;
	}
}
inl void dmin(int&fr, int to) {
	if(fr > to) {
		fr = to;
	}
}
inl int mabs(int da) {
	return da >= 0 ? da : -da;
}
const int _maxn = 211, _mods = 1000000007, _einv = 500000004;
int n, a, b, ninv, firs[_maxn], neig[_maxn << 1], arri[_maxn << 1], tabl[_maxn][_maxn], atno, size[_maxn], stak[_maxn], rans;
int fpow(int da, int up) {
	int re = 1;
	while(up) {
		if(up & 1) {
			re = 1ll * re * da % _mods;
		}
		da = 1ll * da * da % _mods;
		up >>= 1;
	}
	return re;
}
void dfs1(int at, int fa) {
	size[at] = 1;
	gep(i, at) {
		if(arri[i] != fa) {
			dfs1(arri[i], at);
			size[at] += size[arri[i]];
		}
	}
}
void dfs2(int at, int fa, int de) {
	stak[de] = at;
	if(at > atno) {
		rep(i, 1, de) {
			rans += 1ll * size[stak[i]] * tabl[de - i][i - 1] % _mods;
			if(rans >= _mods) {
				rans -= _mods;
			}
		}
	}
	gep(i, at) {
		if(arri[i] != fa) {
			size[at] -= size[arri[i]];
			dfs2(arri[i], at, de + 1);
			size[at] += size[arri[i]];
		}
	}
}
int main() {
	n = ured();
	rep(i, 1, n - 1) {
		a = ured();
		b = ured();
		neig[i << 1] = firs[a];
		firs[a] = i << 1;
		arri[i << 1] = b;
		neig[i << 1 | 1] = firs[b];
		firs[b] = i << 1 | 1;
		arri[i << 1 | 1] = a;
	}
	rep(i, 0, n) {
		rep(j, 0, n) {
			if(i == 0) {
				tabl[0][j] = 1;
			} else if(j == 0) {
				tabl[i][0] = 0;
			} else {
				tabl[i][j] = 1ll * (tabl[i - 1][j] + tabl[i][j - 1]) * _einv % _mods;
			}
		}
	}
	rep(i, 1, n) {
		atno = i;
		dfs1(i, 0);
		dfs2(i, 0, 1);
	}
	uwit(1ll * rans * fpow(n, _mods - 2) % _mods);
	putchar('\n');
	return 0;
}
```

---

## 作者：遮云壑 (赞：2)

# Description
- 等概率选一个点，加入序列
- 从已选的点的相邻的点中不断等概率选点加入序列
- 求最终序列的逆序对期望个数

想看更详细的，[出门左转](https://www.luogu.com.cn/problem/CF1540B)

# Solution
- 由于最开始是等概率选点，所以每一个点都可能作为根。
- $O(n^2)$ 枚举点对 $(u,v)$ ，使 $u>v$ ，考虑 $u$ 在 $v$ 前面的概率
- 求出 $u,v$ 的LCA，会发现这个问题到了链上，就像下图

![](https://cdn.luogu.com.cn/upload/image_hosting/uf7z98zz.png)

比如我们以1为根，现在枚举到的点对是（13，6）。

- 我们发现，对于不在这条链上的点对于6和13的相对位置是没有影响的，即不管这一步选不选它。所以我们只要考虑这条链上的点。可以来一个假的dp，为什么是假的，你看看就知道了。

- 设 $dp_{i,j}$ 为从 $(u,v)$ 的LCA出发，在链上走 $i$ 步到 $u$ ，在链上走 $j$ 步到 $v$ ，使得 $u$ 在 $v$ 前面的概率。

- 然后你会发现这个dp和 $u,v$ 没有半毛钱关系，完全是可以预处理的。

- 上式子 $dp_{i,j}= \frac{1}{2}* (dp_{i-1,j}+dp_{i,j-1})$ 。为什么呢，当你在 $dp_{i-1,j}$ 的时候，你可以选则向 $dp_{i,j}$ 拓展，也可以选择向 $dp_{i-1,j+1}$ 拓展，会有 $\frac{1}{2} $ 的概率拓展到 $dp_{i,j}$ 。$dp_{i,j-1}$ 也是同理，所以两者加起来除以二就是 $dp_{i,j}$。

### 总结一下思路
1. 枚举根节点，然后枚举 $u,v$ 保证 $u>v$ 求lca
2. 答案加上 $dp_{dep_u-dep_{LCA},dep_v-dep_{LCA}}$

# Analysis

枚举根节点，枚举 $(u,v)$ ，都是 $O(n)$ ,加一个求LCA。整体复杂度 $O(n^3logn)$ 。

# Code
代码不难，重点是思路，要看的[出门右转](https://codeforces.com/contest/1540/submission/134354478)

# Conclusion
从等概率选点开始生成序列要想到枚举根节点跑LCA，当问题化简后出现了类似的情况，可以考虑对于运算预处理。这题最大的启示在于根节点不能局限于1。

---

## 作者：slzx2022YuYihan (赞：1)

# Description

给你一棵树，让你从中按顺序选这些点，满足相邻两个选的点之间有边相连，求逆序对的期望。

# Solution

一道期望 dp 好题！

根据题意我们首先要枚举根 $rt$。

看到 $n$ 很小，考虑点 $u$ 比点 $v$ 后取到的概率（$u< v$），所有概率之和就是期望（因为对答案的贡献为 $\mathbb 1$）。

于是自然想到 $lca(u,v)$。

然后进行大胆猜想：是不是只要知道 $u$ 走 $dep_u-dep_{lca(u,v)}$ 步并且 $v$ 走 $dep_v-dep_{lca(u,v)}$ 步的概率是不是就可以了？！脑补了一下，显然可以！

于是我们设 $p(i,j)$ 表示 $lca(u,v)$ 走到 $u$ 需要 $i$ 步并且 $lca(v,u)$ 走到 $v$ 需要 $j$ 步的概率，有递推柿子：$p(i,j)=\frac{p(i-1,j)+p(i,j-1)}{2}$，可以通过预处理得到。（类似思想：[$\huge P4438$](https://www.luogu.com.cn/problem/P4438)）

注意初始化 $p(i,0)=1,p(0,i)=0$。 

后面就肥肠好写！

因为我们枚举了 $n$ 个点，所以最后我们把期望乘以 $\frac{1}{n}$。

时间复杂度 $O(n^3\log n)$，可以通过。

# Code

下面是可食用代码~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
	x = 0; T w = 1; char ch = getchar();
	while (!isdigit(ch)){if (ch == '-')	w = -1; ch = getchar();}
	while (isdigit(ch))	x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	x *= w;
}
template<typename T>inline void write(T x){
	if (x < 0)	putchar('-'), x = ~(x - 1);
	if (x > 9)	write(x / 10);
	putchar(x % 10 ^ 48);
}

const ll mo = 1e9 + 7;

ll qpow(ll a, ll b){
	ll res = 1;
	while (b){
		if (b & 1)	res = res * a % mo;
		a = a * a % mo, b >>= 1;
	}
	return res;
}

const int N = 205;

ll n;

ll num, h[N], to[N << 1], nxt[N << 1];
void addedge(ll u, ll v){
	to[++num] = v, nxt[num] = h[u], h[u] = num;
}

ll ans;

ll dep[N], fa[N][9];
void dfs(ll u, ll pre){
	dep[u] = dep[pre] + 1, fa[u][0] = pre;
	for (int i = 1; fa[u][i - 1]; ++i)	fa[u][i] = fa[fa[u][i - 1]][i - 1];
	for (int i = h[u]; i; i = nxt[i]){
		ll v = to[i];
		if (v == pre)	continue;
		dfs(v, u);
	}
}
ll get_lca(ll u, ll v){
	if (dep[u] < dep[v])	swap(u, v);
	for (int i = 8; i >= 0; --i)	if (dep[fa[u][i]] >= dep[v])	u = fa[u][i];
	if (u == v)	return u;
	for (int i = 8; i >= 0; --i)	if (fa[u][i] ^ fa[v][i])	u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

ll p[N][N];

int main(){
//	freopen(".in", "r", stdin), freopen(".out", "w", stdout);
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)

	read(n);
	for (int i = 1, u, v; i < n; ++i){
		read(u), read(v);
		addedge(u, v), addedge(v, u);
	}
	ll inv_2 = qpow(2, mo - 2);
	for (int i = 0; i <= n; ++i)	p[i][0] = 1;
	for (int i = 0; i <= n; ++i)	p[0][i] = 0; 
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			p[i][j] = (p[i - 1][j] + p[i][j - 1]) % mo * inv_2 % mo;
	for (int rt = 1; rt <= n; ++rt){
		for (int i = 1; i <= n; ++i){
			dep[i] = 0;
			for (int j = 0; j < 9; ++j)	fa[i][j] = 0;
		}
		dfs(rt, 0);
		for (int i = 1; i <= n; ++i)
			for (int j = i + 1; j <= n; ++j){
				ll lca = get_lca(i, j);
				(ans += p[dep[i] - dep[lca]][dep[j] - dep[lca]]) %= mo;
			}
	}
	write(ans * qpow(n, mo - 2) % mo), putchar('\n');

	return 0;
}
/*
Notes	by slzx2022YuYihan

一道期望 dp 好题！

根据题意我们首先要枚举根 $rt$。

看到 $n$ 很小，考虑点 $u$ 比点 $v$ 后取到的概率（$u< v$），所有概率之和就是期望（因为对答案的贡献为 $\mathbb 1$）。

于是自然想到 $lca(u,v)$。

然后进行大胆猜想：是不是只要知道 $u$ 走 $dep_u-dep_{lca(u,v)}$ 步并且 $v$ 走 $dep_v-dep_{lca(u,v)}$ 步的概率是不是就可以了？！脑补了一下，显然可以！

于是我们设 $p(i,j)$ 表示 $lca(u,v)$ 走到 $u$ 需要 $i$ 步并且 $lca(v,u)$ 走到 $v$ 需要 $j$ 步的概率，有递推柿子：$p(i,j)=\frac{p(i-1,j)+p(i,j-1)}{2}$，可以通过预处理得到。（类似思想：[$\huge P4438$](https://www.luogu.com.cn/problem/P4438)）

注意初始化 $p(i,0)=1,p(0,i)=0$。 

后面就肥肠好写！

因为我们枚举了 $n$ 个点，所以最后我们把期望乘以 $\frac{1}{n}$。

时间复杂度 $O(n^3\log n)$，可以通过。
*/
```

---

## 作者：hgzxwzf (赞：0)

## [CF1540B](https://codeforces.com/problemset/problem/1540/B)

### 解题思路：

可以考虑每个点对 $(i,j),i<j$ 的贡献。

假设从起点走到 $i,j$ 路径上的第一个点是 $k$。

发现如果新打上标记的点不在 $i,j$ 路径上，那么对 $i,j$ 的顺序没有影响，所以只需要考虑新打上标记的点在 $i,j$ 路径上的情况，显然，新点更靠近 $i$ 的概率和更靠近 $j$ 的概率都是 $\frac{1}{2}$。

设 $k$ 到 $i,j$ 的距离分别为 $di,dj$。

问题可以转化为要拿 $di$ 个红色石头和 $dj$ 个蓝色石头，每次拿拿出两种石头的概率都是 $\frac{1}{2}$，求先拿完 蓝色石头的概率。

可以枚举拿出最后一个蓝色石头时拿了 $k$ 个红色石头，将这 $k$ 个石头插到 $dj$ 个空隙中，可以为空，方案数为 $\tbinom{k+dj-1}{dj-1}$，概率为 $\tbinom{k+dj-1}{dj-1}\times (\frac{1}{2})^{k+dj}$。

所以总概率为 $\sum_{k=0}^{di}\tbinom{k+dj}{dj-1}(\frac{1}{2})^{k+dj}$。

从 $i,j$ 开始往上爬，得到 $k$ 以及有多少点到 $i,j$ 路径上的第一个点是 $k$，概率就很好算了。

### [Code](https://codeforces.com/contest/1540/submission/197454314)

---

## 作者：听取MLE声一片 (赞：0)

简单题，但我调了很长时间，怎么回事呢？

直接做肯定是做不了的，考虑枚举每一个逆序对然后计算其出现的概率。

枚举两个节点 $u,v$，当 $u>v$ 时存在逆序对就是 $u$ 比 $v$ 先遍历到。

把从 $u$ 到 $v$ 这条链拉出来，然后形态就是一条链，链上每个点挂一棵子树。

大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/k0ffvj48.png)

考虑枚举从链上的点来算出其先到达 $u$ 的概率。

因为打过标记的点都在一个连通块内，所以可以看做链上的一段区间。

对于一个区间，拓展区间只能在链上向左拓展或向拓展，这两个概率是相等的，又因为在其包含的子树内打标计是不会拓展区间的，所以向左拓展和向右拓展的概率均为 $\frac{1}{2}$。

这样就可以枚举链的长度去进行区间 dp 了，其中包含开头不包含结尾的初值均为 $1$。dp 过程就按照长度从大到小转移即可。

dp 之后就可以求出链上的每个点作为第一步选择的点到达 $u$ 的概率。

然后考虑链上的每个点被第一次选中的概率。设一个点的**链上子树**大小为 $x$，那么其概率为 $\frac{x}{n}$，把这个乘上从链上先到达 $u$ 的概率即可。

考虑求链上每个点的链上子树大小。先分别求出 $u,v$ 到 LCA 的路径。设一个点 $p$ 到 LCA 的路径数组为 $e$，其中 $e_1=p$，则对于非 LCA 节点 $e_i$点的链上子树大小即为 $siz_{e_i}-siz_{e_{i-1}}$。对于 LCA，设 $u,v$ 到 LCA 路径中为 LCA 儿子的点分别为 $x,y$，则 LCA 的链上子树大小即为 $n-siz_x-siz_y$。

最后把每个逆序对的贡献加起来即可。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=210;
const int mod=1e9+7;
inline int ksm(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
inline int inv(int x){
	return ksm(x,mod-2);
}
inline int modd(int x){
	if(x<0)return x+mod;
	if(x<mod)return x;
	x-=mod;
	if(x<mod)return x;
	return x%mod;
}
int n,ans,a[N][N];
int f[N][N],g[N];
int fa[N],siz[N],dep[N],dfn[N],id[N],cnt,LCA[N][N];
vector<int>e[N],e1,e2;
void init(){
	for(int i=1;i<N;i++)
		g[i]=inv(i);
	for(int m=0;m<N-1;m++){
		memset(f,0,sizeof(f));
		for(int i=0;i<=m;i++)f[0][i]=1;
		for(int len=m;len>=1;len--)
			for(int i=1;i+len-1<=m;i++){
				int j=i+len-1;
				f[i][j]=modd(f[i-1][j]*g[2]%mod+f[i][j+1]*g[2]%mod);
			}
		for(int i=0;i<=m+1;i++)
			a[m][i]=f[i][i];
	}
}
void dfs(int u,int f){
	cnt++;
	dfn[u]=cnt;
	id[cnt]=u;
	dep[u]=dep[f]+1;
	fa[u]=f;
	siz[u]=1;
	for(int v:e[u]){
		if(v==f)continue;
		dfs(v,u);
		siz[u]+=siz[v];
	}
	for(int v:e[u]){
		if(v==f)continue;
		for(int w:e[u]){
			if(w==f||w==v)continue;
			for(int i=dfn[v];i<=dfn[v]+siz[v]-1;i++)
				for(int j=dfn[w];j<=dfn[w]+siz[w]-1;j++)
					LCA[id[i]][id[j]]=u;
		}
	}
	for(int i=dfn[u];i<=dfn[u]+siz[u]-1;i++)
		LCA[u][id[i]]=LCA[id[i]][u]=u;
}
inline int dis(int u,int v){
	int lca=LCA[u][v];
	return (dep[u]-dep[lca])+(dep[v]-dep[lca])-1;
}
signed main()
{
	init();
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	for(int u=1;u<=n;u++)
		for(int v=1;v<u;v++){
			int lca=LCA[u][v],m=dis(u,v),s=0;
			e1.clear(),e2.clear();
			e1.push_back(0),e2.push_back(0);
			int x=u,y=v;
			while(x!=lca){
				e1.push_back(x);
				x=fa[x];
			}
			while(y!=lca){
				e2.push_back(y);
				y=fa[y];
			}
			for(int i=1;i<e1.size();i++){
				x=e1[i],y=e1[i-1];
				ans=modd(ans+a[m][s]*(siz[x]-siz[y])%mod*g[n]%mod);
				s++;
			}
			x=e1.back(),y=e2.back();
			ans=modd(ans+a[m][s]*(n-siz[x]-siz[y])%mod*g[n]%mod);
			s++;
			for(int i=e2.size()-1;i>=1;i--){
				x=e2[i],y=e2[i-1];
				ans=modd(ans+a[m][s]*(siz[x]-siz[y])%mod*g[n]%mod);
				s++;
			}
		}
	cout<<ans;
	return 0;
}

```

---


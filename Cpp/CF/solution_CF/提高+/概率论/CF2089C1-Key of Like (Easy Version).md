# Key of Like (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本之间的区别在于，在这个版本中保证 $$$k = 0$$$。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此第一位成员必定用唯一的钥匙打开唯一的锁。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 0
3 2 0
2 5 0
9 104 0```

### 输出

```
1 0 0
500000004 1 500000004
200000004 800000008
869203933 991076635 39374313 496894434 9358446 51822059 979588764 523836809 38844739```

# 题解

## 作者：Unnamed114514 (赞：1)

首先容易想到锁和钥匙是无序的，然后你还会发现钥匙和锁是有对称关系的。

所以我们不妨令第一个人是用第一把钥匙配第一把锁，然后后面的人用第一把钥匙继续配，根据上述的结论这个策略显然是正确的。

然后，我们来讨论一次开锁的概率：第一次显然是 $\dfrac{1}{l}$；第二次虽然成功的概率是 $\dfrac{1}{l-1}$，但是它的前提是第一次失败了，所以概率是 $\dfrac{l-1}{l}\times\dfrac{1}{l-1}=\dfrac{1}{l}$……以此类推，你会发现每次开锁的概率都是 $\dfrac{1}{l}$。

然后容易想到定义 $f_{i,j}$ 表示还剩下 $j$ 把锁时，这把锁是被 $i$ 打开的。容易想到转移是枚举开了多少次，但是这样是 $O(nl^2)$ 的，~~拼尽全力无法卡常通过~~，考虑优化。

容易想到 $k$ 次和 $n+k$ 次的贡献是完全相同的，因此考虑算每个人的贡献即可，时间复杂度 $O(n^2l)$。

根据期望的线性性，问题显然可以转化为算每个人开每把锁的概率之和。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=1e9+7;
int T,n,l,k,f[105][5005],inv[5005],ans[105];
int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod,b>>=1;
	}
	return s;
}
int dis(int i,int j){
	if(i<j) return j-i;
	return n-(i-j);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T;
	inv[0]=1;
	for(int i=1;i<=5000;++i) inv[i]=qpow(i,mod-2);
	while(T--){
		cin>>n>>l>>k;
		for(int i=1;i<=n;++i) ans[i]=0;
		f[n][l+1]=1;
		for(int i=l;i;--i) for(int j=1;j<=n;++j){
			for(int k=1;k<=n;++k){
				int delta=i/n;
				if(dis(k,j)<=i%n) ++delta;
				f[j][i]=(f[j][i]+f[k][i+1]*delta)%mod;
			}
			f[j][i]=f[j][i]*inv[i]%mod;
			ans[j]=(ans[j]+f[j][i])%mod;
		}
		for(int i=1;i<=n;++i) cout<<ans[i]<<' ';
		cout<<endl;
		for(int i=1;i<=n;++i) for(int j=1;j<=l;++j) f[i][j]=0;
		f[n][l+1]=0;
	}
	return 0;
}
```

---

## 作者：Halberd_Cease (赞：0)

简单 C1。

假设当前场上剩下了 $k$ 把钥匙，钦定从第 $1$ 个人开始轮流解锁（因为从第几个人开始不影响相对位置上每个人解开的概率），首先第一个人一定是随机选择一把锁和一个钥匙，可以假设选择了第一把锁和第一把钥匙，那么有 $\frac1k$ 的概率直接打开。

如果打不开的话，对于第一把锁，少了一把钥匙与其配对，那么第二个人再选择第一把锁和一个其它的钥匙去配对成功的概率是 $\frac1{k-1}$，用第一把钥匙和其它锁配对成功的概率亦是 $\frac1{k-1}$。所以第二个人会随机从这 $2k-2$ 个选择中选择一个，本质不同有两种选择：选择第一把锁或者选择第一把钥匙。

假设选择了第一把锁和一把其它的钥匙（假设是 2 号钥匙），有 $\frac1{k-1}$ 的概率打开。如果没打开的话，下一轮用其它钥匙开第一把锁的概率是 $\frac{1}{k-2}$，而用第一、二把钥匙开其它的锁的概率仍然是 $\frac1{k-1}$，因此后面的人均会选择用其它钥匙尝试开第一把锁，知道该锁被打开。

假设选了第一把钥匙开其它的锁，分析过程和上面一样的，并且后面的操作只会是用第一把钥匙开其它的锁，直到打开。

两种情况，在整个周期中（一个周期是从上一把锁被成功打开之后至下一把锁被打开），每个人成功开锁的概率都是相等的，因此可以看作一种情况。

考虑一个完整的周期，剩余了 $k$ 把钥匙，第一个人开锁成功的概率是 $\frac1k$，第二个人开锁成功的概率是 $\frac{k-1}k\times \frac1{k-1}=\frac1k$，以此类推，$k$ 个可能的轮次中每次开锁成功的概率都是 $\frac1k$。然后把贡献累加到每个人头上，比如 $k=5$，$n=3$ 的时候，第一、二个人开锁成功的概率是 $\frac25$，第 $3$ 个人成功的概率是 $\frac15$。

然后考虑这一周期的结束对下一周期的开始的影响，显然如果这一周期第 $i$ 个人成功开锁，那么下一周期就是第 $i+1$ 个人（循环意义上）首先开锁。

所以我们直接把剩下 $k$ 把钥匙的情况下，每个人成功开锁的概率求出来。

然后维护一个 $f_{i,j}$，表示第 $i$ 个周期，从第 $j$ 个人开始开锁的概率。枚举周期，然后枚举从第几个人开始，通过上面求出来剩余 $l-i+1$ 把钥匙每个人开锁成功的概率累加到 $f_{i+1,j+x+1}$ 上面去，然后累加第 $j+x$ 个人的答案。

[submission](https://codeforces.com/contest/2089/submission/311997708) 赛时代码，略有繁琐，大体思路相同。

---


# Nastya Is Buying Lunch

## 题目描述

大课间时，Nastya 来到了学校食堂。学校里有 $n$ 个学生，编号从 $1$ 到 $n$。不幸的是，Nastya 来得很晚，所有学生已经排好队了，也就是说 Nastya 只能站在队伍的最后一位。虽然 Nastya 有点难过，但她并不气馁，因为队伍中的一些学生愿意和其他学生交换位置。

具体来说，存在一些学生对 $(u, v)$，如果编号为 $u$ 的学生正好站在编号为 $v$ 的学生前面，Nastya 可以请求他们交换位置，他们会同意。

Nastya 想让你帮她计算，她最多能向前移动多少个位置。

## 说明/提示

在第一个样例中，Nastya 只需和队首的学生交换一次位置。

在第二个样例中，最优的交换顺序为：

- 先交换编号为 $1$ 和 $3$ 的学生。
- 再交换编号为 $3$ 和 $2$ 的学生。
- 最后交换编号为 $1$ 和 $2$ 的学生。

队伍变化过程为 $[3, 1, 2]$，然后 $[1, 3, 2]$，再到 $[1, 2, 3]$，最后经过这些操作变为 $[2, 1, 3]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2 1
1 2
1 2
```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
3 1 2
1 2
3 1
3 2
```

### 输出

```
2```

## 样例 #3

### 输入

```
5 2
3 1 5 4 2
5 2
5 4
```

### 输出

```
1```

# 题解

## 作者：DDOSvoid (赞：7)

提供一个 $O(m\log m)$ 的暴力做法

首先能够发现对于一个可以交换的数对 $(u,v)$，如果起始的位置 $v$ 在 $u$ 前面，那么这个交换是没有意义的

所以每个数只会和后面的交换

再仔细思考，如果 $p_i$ 能够一直换到 $p_j$，也就是说 $p_i$ 能够和 $p_{i+1},p_{i+2},\cdots,p_{j}$ 交换，跟 $p_{i+1}$ 到 $p_{j}$ 的顺序无关

换句话说，就算顺序变成 $p_{i+1}$ 到 $p_{j} $ 的顺序打乱，也不影响 $p_i$ 的交换

所以我们按照位置从大到小每个数贪心尽量向后换即可 

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#define pb push_back
#define maxn 300010
#define ci const int 
using namespace std;

int n, m;

int p[maxn], d[maxn];

inline bool cmp (ci &u, ci &v) { return d[u] < d[v]; } 

vector<int> a[maxn]; 

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &p[i]), d[p[i]] = i; 
    for (int i = 1; i <= m; ++i) {
        int x, y; scanf("%d%d", &x, &y);
        a[x].pb(y); 
    }
    for (int i = n - 1, u = p[i]; i; u = p[--i]) {
        sort(a[u].begin(), a[u].end(), cmp);
        for (auto it : a[u]) 
            if (d[it] == d[u] + 1) {
                ++d[u]; --d[it]; 
            }
    } cout << n - d[p[n]]; 
    return 0; 
}

```

---

## 作者：hy233 (赞：5)

upd(2022.11.19)：更新了latex和部分描述。
## 前言
一道不错的思维题，但颜色偏高。

## 题意简述
- 有一个 $1\sim n$ 的排列。
- 给定 $m$ 对点对 $(u,v)$，表示若 $u,v$ 相邻，且 $u$ 在 $v$ 的前面，则可以交换 $u,v$ 的位置。（下文称 $u$ 可以往后跳，或 $v$ 可以往前跳）
- 求最后一个点最多可以往前跳几步。

## 题目分析
我们将除了 $n$ 号点（即最后一个点）以外的点分为两部分，一部分是可以跳到 $n$ 号点后面的点（称为**蓝点**），其他的称为**红点**。

显然，题目要求的就是最终能跳到 $n$ 号点后面的蓝点的个数。我们考虑这样一个问题：一个**最右边**的蓝点要跳到 $n$ 号点后面去，必定要先跳过这两个点中间的所有红点，并且中间的点既不能跳到 $n$ 号点后面去（~~它们是红点，它们没有资格qwq~~），他们中间的前后关系也不重要。**所以只要判断每个蓝点能否跳过中间的所有红点**。

怎么样判方便呢? 我们从后往前遍历，记录 $n$ 号点和当前点之间的红点个数 $cnt$，和每一个数能跳过这之间红点的个数 $num_i$。

- 如果新遍历到一个红点，我们将 $cnt \gets cnt+1 $，并更新所有能跳过这个红点的点 $i$，将 $num_i\gets num_i+1$，因为所有的关系总共只有 $m$ 个，所以复杂度是对的。

- 如果新遍历到一个蓝点，我们看看他能不能跳到 $n$ 号点后面去，换句话说，能不能跳过它和 $n$ 号点之间的所有红点（即 ```num[i]==cnt``` ）。如果可以，$ans \gets ans+1$，并默认把它赶到 $n$ 号点后面去（这样不会挡住后面蓝点的路径）；如果不行，**就把它变成红点**，并执行上述红点的操作。

时间复杂度为 $O(n+m)$。

## 代码
```cpp
int a[300005];	//点的编号
vector<int> mp[300005];		//存关系，mp[x]中为能跳到x后面的数
bool blue[300005];	//是否是蓝点（见上文）
int num[300005];	//（含义见上文）
int mian()
{
	int n=rd(),m=rd();
	for(int i=1;i<=n;i++)
		a[i]=rd();
	for(int i=1;i<=m;i++)
	{
		int u=rd(),v=rd();
		mp[v].push_back(u);
		if(v==a[n])
			blue[u]=1;
	}
	int ans=0;
	int cnt=0;
	for(int i=n-1;i>=1;i--)   //从后往前遍历
	{
		if(blue[a[i]])
		{
			if(num[a[i]]==cnt)  //可以跳
				ans++;	
			else
				blue[a[i]]=0;   //把它变成红点
		}
		if(!blue[a[i]])
		{
			for(int j=0;j<mp[a[i]].size();j++)   //更新所有点的num
			{
				int v=mp[a[i]][j];
				num[v]++;
			}
			cnt++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---


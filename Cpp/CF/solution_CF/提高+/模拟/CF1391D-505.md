# 505

## 题目描述

A binary matrix is called good if every even length square sub-matrix has an odd number of ones.

Given a binary matrix $ a $ consisting of $ n $ rows and $ m $ columns, determine the minimum number of cells you need to change to make it good, or report that there is no way to make it good at all.

All the terms above have their usual meanings — refer to the Notes section for their formal definitions.

## 说明/提示

In the first case, changing $ a_{1,1} $ to $ 0 $ and $ a_{2,2} $ to $ 1 $ is enough.

You can verify that there is no way to make the matrix in the second case good.

Some definitions —

- A binary matrix is one in which every element is either $ 1 $ or $ 0 $ .
- A sub-matrix is described by $ 4 $ parameters — $ r_1 $ , $ r_2 $ , $ c_1 $ , and $ c_2 $ ; here, $ 1 \leq r_1 \leq         r_2 \leq n $ and $ 1 \leq c_1 \leq c_2 \leq m $ .
- This sub-matrix contains all elements $ a_{i,j} $ that satisfy both $ r_1 \leq i \leq r_2 $ and $ c_1 \leq j \leq         c_2 $ .
- A sub-matrix is, further, called an even length square if $ r_2-r_1 = c_2-c_1 $ and $ r_2-r_1+1 $ is divisible by $ 2 $ .

## 样例 #1

### 输入

```
3 3
101
001
110```

### 输出

```
2```

## 样例 #2

### 输入

```
7 15
000100001010010
100111010110001
101101111100100
010000111111010
111010010100001
000011001111101
111111011010011```

### 输出

```
-1```

# 题解

## 作者：yangrunze (赞：21)

今天上午逛了一圈~~谔意评分揭发贴~~题目评分反馈贴，发现有人评这个题目……

听说是这题是**状压 dp**？正好最近正在练这个东西，不如做做试试看！



------------
拿到题目，放眼望去，看了好长时间，终于得出了结论：

太难了，不会。

那咱们就先**从特殊情况骗分**开始？

（前排提醒：**CF 是没有部分分的**，但是有的时候先考虑骗分的做法有助于你从正解进发！）



------------

我们先来看一下**样例**和**数据范围**：

数据范围：$n\times m\le 10^6$

遇到写成这种乘积形式的数据范围，那你可要小心：别以为数据不会超过 $10^3\times 10^3$，因为你给个 $1\times 10^6$ 也是完全符合这个范围的。

那好，二维数组存储这个矩阵可能就用不了了（？）

不过不要灰心：**出题人给你关上一扇门，必将为你打开一扇窗。** 既然数据这么毒瘤，那是不是意味着……特别大的情况，是不用存储矩阵就可以处理的呢？？



------------

确实如此。经过思考，我们发现**当 $n\ge4,m\ge4$ 时，一定是无解的。**

为什么呢？这个很好理解：

我们就先构造最简单的情况：从一个 $4\times 4$ 的矩阵开始考虑：

那么，根据题目要求，矩阵中每个 $2\times 2$ 的区域中 $1$ 的个数都应该是奇数。


![](https://cdn.luogu.com.cn/upload/image_hosting/mltl5386.png)

而这样的话，整个 $4\times 4$ 的区域中 $1$ 的个数为：

**奇数+奇数+奇数+奇数=偶数**

而题目要求的矩阵在 $4\times 4$ 的区域内的 $1$ 的个数也要是奇数啊……

所以 $4\times 4$ 的矩阵就无解了，而$n>4,m>4$ 时，可以在整个矩阵中找到好几个 $4\times 4$ 的区域，那有解就更是门都没有了。

所以……用二维数组存矩阵其实是完全可以的。

------------

好家伙，经过这么一分析，我们已经将题目简化了一大半。

而且这个题目毒瘤的同时也很良心：**数据是保证 $n\le m$ 的**。这样的话，如果 $n\ge 4$，$m$ 一定大于等于 $4$，因此我们只需要判断 $n<4$ 的情况即可。

（P.S：我看到题解区的许多小伙伴都对 $n>m$ 的情况进行了特判，然后交换 $n$ 与 $m$，其实是完全没有必要的，以后一定要**认真看题**哦！）

那剩下的情况就屈指可数了，$n=1,2,3$，我们开始逐个击破吧！



------------
- ###  $n=1$

当 $n=1$ 时，矩阵只有一行，一个边长为偶数的矩阵都没有，所以一定是好矩阵。

输出 $0$ 即可。



------------
- ### $n=2$

这时矩阵只有两行，只需要考虑在这两行里的 $m-1$ 个 $2\times 2$ 的区域就行了。

我们发现，某一列是否修改，跟**前一列的 $1$ 的个数**有关。

就这样一直推下去，也就是整个矩阵是否修改，跟**前两列**有关。

这样的话，我们就分别**控制让第一列或第二列修改/不修改**就行了。



------------
- ### $n=3$

**状压 dp**。

我们设 $dp_{i,j}$ 为第 $i$ 行在 $j$ 状态下时需要修改的最小次数。

（非常套路的一个状态设计呢 qwq）

如果你切过[玉米田](https://www.luogu.com.cn/problem/P1879)，[互不侵犯](https://www.luogu.com.cn/problem/P1896)，[炮兵阵地](https://www.luogu.com.cn/problem/P2704)等关于**网格图**的状压 dp 经典题的话，相信你也能想出一个很套路的一个转移过程：

**枚举上一行所有合法的状态 $k$** , 之后对 $j$ 和 $k$ 进行转移。

转移方程也十分好写，设将矩阵的第 $i$ 行变为 $j$ 状态要修改的数字的个数为 $\operatorname{change}(i,j)$，则：

$dp_{i,j}=\min(dp_{i,j},dp_{i-1,k}+\operatorname{change}(i,j))$



------------
最后就是代码实现的问题了，众所周知，细节决定成败。这里来提两点细节：

1. “区域内 $1$ 的个数为奇数”这个条件可以说成“ **区域内的数的异或和为 $1$** ”， 会让代码变得更好写！

2. 一定别把数组的行和列写反了呜哇啊啊啊啊啊！

````cpp
#include<iostream>
#include<cstring>
#define qwq(x,k) ((x>>k)&1) //宏定义取出二进制数 x 的第 k 位 （为了防止宏定义展开后出现问题，最好在外面加个括号）
using namespace std;
const int QAQ=(int)(2e6+5);
int a[10][QAQ],dp[QAQ][10];
bool ok(int x,int y){//n=3时，判断两个状态相邻时是否合法
	if((qwq(x,2)^qwq(x,1)^qwq(y,2)^qwq(y,1))==0)return 0;//第二列和第三列的元素的异或和不能为 0
	if((qwq(x,0)^qwq(x,1)^qwq(y,0)^qwq(y,1))==0)return 0;//第一列和第二列的元素的异或和不能为 0
	return 1;
}
int change(int l,int x){//n=3时，计算把第 i 行的状态修改为 x 状态时要修改的数字个数
	return (qwq(x,0)^a[1][l])+(qwq(x,1)^a[2][l])+(qwq(x,2)^a[3][l]);//计算第 l 行的状态与 x 不同的个数即可
}
int main(){
	int n,m;
	cin>>n>>m;
	if(n==1){//n=1直接输出0
		printf("0");
		return 0;
	}
	if(n>=4){//n>=4直接输出-1
		printf("-1");
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			a[i][j]=c-'0';	//输入矩阵
		}
	}
	if(n==2){//n=2时：
		int ans1=0,ans2=0;
     //ans1 为固定第一列，修改第二列时修改的最小个数
     //ans2 为固定第二列，修改第一列时修改的最小个数           
		int cur=a[1][2]^a[2][2];//cur 为当前列（第二列）的异或和
		if((a[1][1]^a[1][2]^a[2][1]^a[2][2])==0)//如果前两列需要修改
		ans1=1,cur^=1;//ans1加1，修改第二列
		for(int i=3;i<=m;i++){
			if((cur^a[1][i]^a[2][i])==0)
			ans1++,cur=a[1][i]^a[2][i]^1;//如果异或和为0（个数为偶数），那就要修改
			else cur=a[1][i]^a[2][i];
		}
		cur=a[1][2]^a[2][2];
		if((a[1][1]^a[1][2]^a[2][1]^a[2][2])==0)
		ans2=1;//固定第二列
		for(int i=3;i<=m;i++){
			if((cur^a[1][i]^a[2][i])==0)
			ans2++,cur=a[1][i]^a[2][i]^1;//梅   开   二   度
			else cur=a[1][i]^a[2][i];					
		}
		cout<<min(ans1,ans2);//两种取个min
		return 0;
	}
	if(n==3){//n=3时，状压dp 
		for(int i=0;i<8;i++)
		dp[1][i]=change(1,i);//初始化第一行的情况
		for(int i=2;i<=m;i++){
			for(int j=0;j<8;j++){//枚举当前行的状态，2的3次方是8
                dp[i][j]=QAQ;//先初始化称一个很大的数（我也不知道为啥用0x3f会wa）
				for(int k=0;k<8;k++){//枚举上一行的状态
					if(ok(j,k))//如果这两行合法
					dp[i][j]=min(dp[i][j],dp[i-1][k]+change(i,j));//转移
				}
			}
		}
		int ans=QAQ;
		for(int i=0;i<8;i++)ans=min(ans,dp[m][i]);//从每一行的状态中选个最小的
		cout<<ans;
	}
}
````

$\huge{\color{cyan}T\color{gold}h\color{lavender}e\;\color{cyan}e\color{gold}n\color{lavender}d }$

---

## 作者：H6_6Q (赞：10)

$update\ at\ 2020/8/10$ , $14:49$

### 题目翻译：

有一个 $n \times m$ 的 $01$ 矩阵，可以修改一些位置，使得矩阵中的所有 长度为偶数的正方形子矩阵里的 $1$ 的数量为奇数。求出最少的修改次数。

如果无论怎么修改都无法完成，输出 $-1$。

### 思路：

显然一个 $4 \times 4$ 的子矩阵可以由 $4$ 个 $2 \times 2$ 的矩阵构成。

但是如果这 $4$ 个 $2 \times 2$ 的矩阵中 $1$ 的数量都是奇数，那么 $4 \times 4$ 大小的矩阵里 $1$ 的数量就是：奇 $+$ 奇 $+$ 奇 $+$ 奇 $=$ 偶 ，这显然是自相矛盾的。

所以，当出现了一个 $4 \times 4$ 大小的子矩阵即 $n \ge 4$ 时，直接输出 $-1$ 即可。

而如果没有 $4 \times 4$ 的矩阵，那么就意味着只要考虑 $2 \times 2$ 的矩阵。

因为题目告诉我们 $n\le m$ ，故我们只需要考虑 $n==1$ 或 $2$ 或 $3$ 三种情况 。

可以分开讨论三种情况：

- 当 $n == 1$ 时：
	
    所有情况都满足要求，输出 $0$
    
- 当 $n == 2$ 时：
	
    很容易想到，如果每一个子矩阵都满足要求，那么列与列之间的奇偶关系一定是：奇偶奇偶奇偶奇偶... 或者是：偶奇偶奇偶奇偶奇... 。
    
    而如果一列转换奇偶性，那么只要修改一次。
    
    所以可以直接算变为两种情况的代价，然后在这两种情况里取最小值即可。
    
- 当 $n == 3$ 时：
	
    和 $n==2$ 的情况一样，如果每一个子矩阵都满足要求，那么对于每一列的上面两行和下面两行，他们之间的奇偶关系也是互相交错的。
    
    那么如果一列的上面两行要修改奇偶性，同样可以只修改一次。
    
    但这一次可以修改在第一行，也可以修改在第二行。如果修改在第一行那么就只有上面两行的奇偶性改变；而如果修改在第二行那么上面两行和下面两行的奇偶性都会改变。
    
    而在下面两行的修改同理。
    
    所以只要这一列中，不论是上面两行还是下面两行要转变奇偶性，最多都只要修改一次。
    
### Code：

```
#include<bits/stdc++.h>

using namespace std;

int read()
{
	int ans=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
	return ans*f;
}

const int N=1e6+5;
int n,m,mmap[5][N],ans;
//因为 n<=m 放第一维只要开到3
char s[N];

inline int get_2_ans(int x);
//计算 n=2 时的答案，x 为第一列的奇偶性
  
inline int get_3_ans(int x,int y);
//计算 n=3 时的答案，x 为第一列上面两行的奇偶性，y 为第一列下面两行的奇偶性

int main()
{
	n=read();m=read();
	if(n>=4)
		printf("-1\n");
	else if(n==1)
		printf("0\n");
	else if(n==2) //n==2 的情况
	{
		for(int i=1;i<=n;++i)
		{
			scanf("%s",s+1);
			for(int j=1;j<=m;++j)
				mmap[i][j]=s[j]-'0';
		}
		ans=min(get_2_ans(0),get_2_ans(1));
		printf("%d\n",ans);
	}
	else //n==3 的情况
	{
		for(int i=1;i<=n;++i)
		{
			scanf("%s",s+1);
			for(int j=1;j<=m;++j)
				mmap[i][j]=s[j]-'0';
		}
		ans=0x7fffffff;
 		//枚举每一种奇偶性，统计答案
		ans=min(ans,get_3_ans(0,0));
		ans=min(ans,get_3_ans(1,0));
		ans=min(ans,get_3_ans(0,1));
		ans=min(ans,get_3_ans(1,1));
		printf("%d\n",ans); 
	}
	return 0;
} 

inline int get_2_ans(int x)
{
	int res=0;
	for(int i=1;i<=m;++i)
	{
         // 如果这一列的奇偶性目标不同，修改一次
		if((mmap[1][i]+mmap[2][i])%2!=x)
			res++;
		x=!x; // 转换奇偶性
	}
	return res;
}

inline int get_3_ans(int x,int y)
{
	int res=0;
	for(int i=1;i<=m;++i)
	{
  		// 如果这一列的上面两行或者下丽两行的奇偶性目标不同，修改一次
		if((mmap[1][i]+mmap[2][i])%2!=x)
			res++;
		else if((mmap[2][i]+mmap[3][i])%2!=y)
			res++;
		x=!x;y=!y;  // 转换奇偶性
	}
	return res;
}
```


---

## 作者：Tarsal (赞：5)

比较哥哥。。。

## 题意：

给一个 $n \times m$ 的 $01$ 矩阵，定义一个矩阵是好的当且仅当他每一个边长为偶数的子正方形矩阵都恰有奇数个 $1$ ，问至少需要修改几个位置才能是的这个矩阵是好的（不可能输出-1）

数据范围 : 

$n \times m \geq 10^6$

## 题解:

首先，对于 $n \geq 4$ && $m \geq 4$ 的是肯定无解的

证明如下：

如果 $n \geq 4$ && $m \geq 4$

那么肯定存在 $4 \times 4$ 的矩阵。

那么这个 $4 \times 4$ 应该要有奇数个 $1$

但这个 $4 \times 4$ 可以被分成 $4$ 个 $2 \times 2$

每个 $2 \times 2$ 要有奇数个 $1$

$4$ 个加起来就是偶数了。

矛盾。

再考虑其他情况。

直接暴力 $dp$ 一下就行了。

因为必然有一个数小于 $3$

所以复杂度最劣是 $O(10^6 / 3 * 8^2) = O(2e8 + 1e7)$ 

信仰一波就过了。。。

至于如何 $dp$ 还需要分类讨论。

> 当 $n(m) == 1$ 时 $puts("0");$ 就行了。

> 当 $n(m) == 2$ 时 

枚举 $0 \to 3$ 的所有情况。

$dp[i][k] = min(dp[i][k], dp[i-1][j]$ ^ $a[i])$

> 当 $n(m) == 3$ 时 

枚举 $0 \to 7$ 的所有情况。

$dp[i][k] = min(dp[i][k], dp[i-1][j]$ ^ $a[i])$

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <cmath>
#define maxn 1000010
#define maxm 1000010
#define ls x << 1
#define rs x << 1 | 1
#define inf 2000000000
#define inc(i) (++ (i))
#define dec(i) (-- (i))
#define mid ((l + r) >> 1)
#define int long long
#define XRZ 1000000000
#define debug() puts("XRZ TXDY");
#define mem(i, x) memset(i, x, sizeof(i));
#define Next(i, u) for(register int i = head[u]; i ; i = e[i].nxt)
#define file(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout);
#define Rep(i, a, b) for(register int i = (a) , i##Limit = (b) ; i <= i##Limit ; inc(i))
#define Dep(i, a, b) for(register int i = (a) , i##Limit = (b) ; i >= i##Limit ; dec(i))
int dx[10] = {1, -1, 0, 0};
int dy[10] = {0, 0, 1, -1};
using namespace std;
inline int read() {
    register int x = 0, f = 1; register char c = getchar();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
} int a[maxn], f[maxn][8], b[8]; char s;
signed main() { int n = read(), m = read();
	if(n >= 4 && m >= 4) { puts("-1"); goto QwQ;}
	if(n >= m) Rep(i, 1, n) Rep(j, 1, m) scanf(" %c", &s), a[i] = (a[i] << 1) + s - '0';
	else { Rep(i, 1, n) Rep(j, 1, m) scanf(" %c", &s), a[j] = (a[j] << 1) + s - '0'; swap(n, m);}
	if(m == 1) { puts("0"); goto QwQ;} Rep(i, 1, 7) b[i] = b[i - (i & -i)] + 1;
	if(m == 2) { Rep(i, 1, n) Rep(j, 0, 3) f[i][j] = inf; Rep(i, 0, 3) f[1][i] = b[i ^ a[1]]; int Ans = inf;
		Rep(i, 2, n) Rep(j, 0, 3) Rep(k, 0, 3) if(b[j] + b[k] & 1) f[i][k] = min(f[i][k], f[i - 1][j] + b[k ^ a[i]]);
		Rep(i, 0, 3) Ans = min(Ans, f[n][i]); if(Ans > XRZ) puts("-1"); else printf("%lld", Ans);
	} else { Rep(i, 1, n) Rep(j, 0, 7) f[i][j] = inf; Rep(i, 0, 7) f[1][i] = b[i ^ a[1]]; int Ans = inf;
		Rep(i, 2, n) Rep(j, 0, 7) Rep(k, 0, 7) if((b[j & 3] + b[k & 3] & 1) && (b[j >> 1] + b[k >> 1] & 1)) f[i][k] = min(f[i][k], f[i - 1][j] + b[k ^ a[i]]);
		Rep(i, 0, 7) Ans = min(Ans, f[n][i]); if(Ans > XRZ) puts("-1"); else printf("%lld", Ans);
	} QwQ:; return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：3)

### 简化题目的分析

- $n$ 或 $m$ 为 $1$ 时，矩阵中没有任何偶数边长的子正方形，原矩阵一定满足要求。

- $n$ 和 $m$ 大于等于 $4$ 时，一定有四个相邻的边长为 $2$ 的子正方形，组成一个边长为 $4$ 的较大的子正方形。

  如果这四个子正方形的 $1$ 的个数都是奇数，满足条件，那么较大的子正方形的 $1$ 的个数为偶数，不满足条件。不管怎样修改，都不能满足要求。

### 思路

可以把 $n$ 和 $m$ 交换，使 $n\geq m$。

经过简化，我们的 $m$ 一定为 $2$ 或 $3$。

然后就没有思维难度了，写一个状压DP，$f[i][j]$ 表示让前 $i$ 行满足条件，第 $i$ 行修改后的状态为 $j$ 的最小修改次数。

### $code$

```cpp
#include<stdio.h>
#include<string.h>
inline void get(int&a){register char x;for(;x=getchar(),x!='0'&&x!='1';);a=x&1;}//输入
int n,m,a[1000000][3],ans[1000000][8],minn=1<<30;
inline void min(int&x,const int&y){if(x>y)x=y;}//min
main()
{
	scanf("%d%d",&n,&m);
	if(n>=4&&m>=4){puts("-1");return 0;}
	if(n==1||m==1){puts("0");return 0;}//简化题目
	if(n>=m)for(register int i=0;i<n;++i)for(register int j=0;j<m;++j)get(a[i][j]);
	else
	{
		for(register int i=0;i<n;++i)for(register int j=0;j<m;++j)get(a[j][i]);
        //既然交换了，那么输入的i,j就应该换一下
		register int tmp=n;n=m;m=tmp;//交换一下，方便后面的操作
	}
	memset(ans,0x3f,sizeof(ans));
	if(m==2)
	{
		for(register int now0=0;now0<2;++now0)
			for(register int now1=0;now1<2;++now1)
				ans[0][(now1<<1)|now0]=(a[0][0]!=now0)+(a[0][1]!=now1);//初始化
		for(register int i=1;i<n;++i)//DP
			for(register int now0=0;now0<2;++now0)
				for(register int now1=0;now1<2;++now1)//枚举第i行的2位
					for(register int lst0=0;lst0<2;++lst0)
						for(register int lst1=0;lst1<2;++lst1)//枚举第i-1行的2位
            if((now0+now1+lst0+lst1)&1)
							min(ans[i][(now1<<1)|now0],ans[i-1][(lst1<<1)|lst0]+
								(a[i][0]!=now0)+(a[i][1]!=now1));
		for(register int now0=0;now0<2;++now0)
			for(register int now1=0;now1<2;++now1)
				min(minn,ans[n-1][(now1<<1)|now0]);//得到答案
	}
	else
	{
		for(register int now0=0;now0<2;++now0)
			for(register int now1=0;now1<2;++now1)
				for(register int now2=0;now2<2;++now2)
					ans[0][(now2<<2)|(now1<<1)|now0]=\
						(a[0][0]!=now0)+(a[0][1]!=now1)+(a[0][2]!=now2);//初始化
		for(register int i=1;i<n;++i)//DP
			for(register int now0=0;now0<2;++now0)
				for(register int now1=0;now1<2;++now1)
					for(register int now2=0;now2<2;++now2)//枚举第i行的3位
						for(register int lst0=0;lst0<2;++lst0)
							for(register int lst1=0;lst1<2;++lst1)
								for(register int lst2=0;lst2<2;++lst2)//枚举第i-1行的3位
			if(((now0+now1+lst0+lst1)&1)&&((now1+now2+lst1+lst2)&1))
				min(ans[i][(now2<<2)|(now1<<1)|now0],ans[i-1][(lst2<<2)|(lst1<<1)|lst0]+
					(a[i][0]!=now0)+(a[i][1]!=now1)+(a[i][2]!=now2));
		for(register int now0=0;now0<2;++now0)
			for(register int now1=0;now1<2;++now1)
				for(register int now2=0;now2<2;++now2)
					min(minn,ans[n-1][(now2<<2)|(now1<<1)|now0]);//得到答案
	}
	printf("%d",minn);//输出
}
```



---

## 作者：奇米 (赞：3)

# 题解 - $\mathrm{CF1391D}$

## 题目意思

就是给你个 $n\times m$ 的矩阵，为了使其的任意长度为偶数的正方形子矩阵里要含有奇数个 $1$ 最少要改变几个 $a_{i,j}$ 的状态。

## $\mathrm{Sol}$

首先可以知道 $4\times 4$ 的合法矩阵是不存在的，那么 $\min(n,m)>3$ 的矩阵也是不存在的。

那么我们只要分类讨论分别 $\min(n,m)={1,2,3}$ 的情况即可。

我们在这边钦定 $n\leq m,n\leq 3$

对于 $n=1$ 的情况由于不存在偶数长度的子矩阵直接输出 $0$

对于 $n=2,3$ 的情况我们考虑dp。设 $f_{i,j,k,p}$ 表示到第 $i$ 列 $a_{3,i}=j,a_{2,i}=k,a_{1,i}=p$ 的最少需要改变的个数。

那么就是很显然的转移，只有当每个 $2\times 2$ 的小矩阵的 $1$ 的个数为奇数转移，具体地就是刷表法吧。

时间复杂度 $O(\max(n,m)\times2^{2\times\min(n,m)})$

## $\mathrm{Code}$

```cpp
const int mod=1e9+7;
const int mo=998244353;
const int N=1e6+5;

int n,m,f[N][2][2][2],a[4][N];
char str[N];

int main()
{
	io.read(n),io.read(m);
	if(min(n,m)>3)GG;
	if(n<m)
	{
		For(i,1,n)
		{
			scanf("%s",str+1);
			For(j,1,m) a[i][j]=str[j]^48;
		}
	}
	else 
	{
		For(i,1,n) 
		{
			scanf("%s",str+1);
			For(j,1,m) a[j][i]=str[j]^48;
		}
		swap(n,m);
	}
	if(n==1) return printf("0\n"),0;
	if(n==2)
	{
		For(i,0,1) For(j,0,1) f[1][i][j][0]=(i!=a[2][1])+(j!=a[1][1]);
		For(i,2,m) For(j,0,1) For(k,0,1) f[i][j][k][0]=1e9;
		For(i,2,m) For(j,0,1) For(k,0,1) 
		For(l,0,1) For(p,0,1) if((k+j+l+p)&1)
		{
			int s=2-((j==a[2][i])+(k==a[1][i]));
			f[i][j][k][0]=min(f[i][j][k][0],f[i-1][l][p][0]+s);
		}
		int ans=1e9;
		For(i,0,1) For(j,0,1) ans=min(ans,f[m][i][j][0]);
		io.write(ans);
		return 0;
	}
	For(i,0,1) For(j,0,1) For(k,0,1) 
	{
		f[1][i][j][k]=3-((a[3][1]==i)+(a[2][1]==j)+(a[1][1]==k));
		For(l,2,m) f[l][i][j][k]=1e9;
	}
	For(l,2,m) For(i,0,1) For(j,0,1) For(k,0,1) 
	For(ii,0,1) For(jj,0,1) For(kk,0,1) if(((kk+k+jj+j)&1)&&((jj+j+i+ii)&1))
	{
		int s=3-((a[3][l]==i)+(a[2][l]==j)+(a[1][l]==k));
		f[l][i][j][k]=min(f[l-1][ii][jj][kk]+s,f[l][i][j][k]);
	}
	int ans=1e9;
	For(i,0,1) For(j,0,1) For(k,0,1) ans=min(ans,f[m][i][j][k]);
	io.write(ans);
	return 0;
}

```


---

## 作者：loctopus (赞：2)

## 简述题意

- 给定一个 $n \times m$ 的 $01$ 矩阵。

- 请最小化修改的位置数，使该矩阵满足：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个边长为偶数的子正方形矩阵恰有奇数个 $1$ 。

- 若不可能则输出 $-1$。

- $1\leqslant n\leqslant m\leqslant 10^6 ,  n\cdot m\leqslant 10^6$。

## 思路

首先看数据范围，可以发现存储大数据时，数组大小至少为 $10^3 \times 10^6$，会 MLE。

那这是否说明当数据增大到一定范围后答案不变了，比如 $-1$ ？

确实如此。当 $n\geqslant 4$ 时，答案就是 $-1$ 了。

证明很简单，因为此时必存在大小为 $4\times 4$ 的子正方形矩阵。

而它又由 $4$ 个互不重叠的大小为 $2\times 2$ 的子正方形矩阵组成。

若 $2\times 2$ 的矩阵符合题意，那么 $4\times 4$ 的矩阵中 $1$ 的数目则为：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;奇数 $+$ 奇数 $+$ 奇数 $+$ 奇数 $=$ 偶数

明显不合题意。

故，当 $n\geqslant 4$ 时，答案为 $-1$ 。 

而当 $n = 1$ 时，答案显然为 $0$ 。 

只剩下 $1< n<4$ 的情况了，这数据范围，让人不自觉往状压 DP上想。

到这里就是一个非常经典的状压 DP了。

设 $f_{i,j}$为第 $i$ 列为 $j$ 状态时的最小修改次数。
  
枚举前一列的状态 $k$ , 判断合法后进行转移。

设将矩阵的第 $i$ 列变为 $j$ 状态要修改的次数为 $\operatorname{change}(j,i)$。

则转移方程为：$f_{i,j}=\min(f_{i,j},f_{i-1,k}+\operatorname{change}(j,i))$

完整的 code 。

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#define M 20
#define N 1000050
using namespace std;
int n,m,mp[5][N];
int sta[M],cnt[M],tot;
char s[N];
int f[N][M],ans;
void init()
{
	for(int i=0;i<(1<<n);i++)
	{
		sta[++tot]=i; int u=i;
		while(u){cnt[tot]+=((u%2)^0);u>>=1;}	
	}
}
int change(int id,int y)
{
	int ans=0,status=sta[id];
	for(int i=n;i>=1;i--,status>>=1)
		ans+=((status%2)^mp[i][y]);
	return ans;
}
void dp() 
{
	init(); memset(f,0x3f,sizeof f);
	for(int i=1;i<=tot;i++) f[1][i]=change(i,1);
	for(int i=2;i<=m;i++)
		for(int j=1;j<=tot;j++)
			for(int k=1;k<=tot;k++)
			{
				int a=sta[j],b=sta[k];
				int last=a%2+b%2,now,flag=1;
				a>>=1; b>>=1;
				for(int l=n-1;l>=1;l--)
				{
					now=a%2+b%2;
					a>>=1; b>>=1;
					if((last+now)%2==0) flag=0;
					last=now;
				}
				if(flag) f[i][j]=min(f[i][j],f[i-1][k]+change(j,i));
			}
}
int main()
{
	scanf("%d%d",&n,&m);
	if(n>=4){printf("-1");return 0;}
	if(n==1){printf("0"); return 0;}
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)
			mp[i][j]=s[j]-'0';
	}
	dp(); ans=n*m;
	for(int i=1;i<=tot;i++) ans=min(ans,f[m][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Lates (赞：1)

注意到，如果存在一个 $4\times 4$ 的方阵。

必然可以划分成 $4$ 个 $2\times 2$ 的方阵。

这便是个偶数。就寄了。$n\ge 4$ 时答案是 $-1$。

--- 


于是考虑 $n \le 3$ 时怎么做。

暴力线性dp，记录最后一位选了状态。暴力转移。

复杂度是 $\mathcal{O}(n)$ 的。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=x*10+(ch^'0'),ch=getchar();
	return f?-x:x;
}

const int MAX=1e6+5;
int n,m;
char s;
int a[10][MAX];
int f[MAX][2][2];
int g[MAX][2][2][2];
signed main(){
//	freopen("in.in","r",stdin);
	n=read(),m=read();
	if(n == 1)return puts("0"),0;
	if(n >= 4)return puts("-1"),0;
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=m;++j){
			cin>>s;
			if(s=='1')a[i][j]=1;
		}
	}
	//  n 行 m 列 n = 2,3
	if(n==2){
		memset(f,0x3f3f3f3f,sizeof(f));
		for(register int i=0;i<2;++i)
			for(register int j=0;j<2;++j){
				if(a[1][1] == i && a[2][1] == j) f[1][i][j] = 0;
				else f[1][i][j] = 1;
			}
		for(register int t=2;t<=m;++t)
			for(register int i=0;i<2;++i)
				for(register int j=0;j<2;++j)
					for(register int li=0;li<2;++li)
						for(register int lj=0;lj<2;++lj)
							if(li + lj + i + j & 1){
								int delta=(a[1][t] == i && a[2][t] == j) ? 0 : 1; 
								f[t][i][j] = min(f[t][i][j], f[t-1][li][lj] + delta);
							}
		int ans=0x3f3f3f3f;
		for(register int i=0;i<2;++i)
			for(register int j=0;j<2;++j)
				ans = min (ans,f[m][i][j]);
		printf("%d\n",ans);
	}else {// n=3
		memset(g,0x3f3f3f3f,sizeof(g));
		for(register int i=0;i<2;++i)
			for(register int j=0;j<2;++j)
				for(register int k=0;k<2;++k){
					if(a[1][1] == i && a[2][1] == j && a[3][1] == k)g[1][i][j][k]=0;
					else g[1][i][j][k]=1;
				}
		for(register int t=2;t<=m;++t){
			for(register int i=0;i<2;++i){
				for(register int j=0;j<2;++j){
					for(register int k=0;k<2;++k){
						for(register int li=0;li<2;++li){
							for(register int lj=0;lj<2;++lj){
								for(register int lk=0;lk<2;++lk){
									if((li + lj + i + j & 1 ) && (lk + lj + k + j & 1 ) ){
										int delta=(a[1][t] == i && a[2][t] == j && a[3][t] == k) ? 0 : 1;
										g[t][i][j][k] = min(g[t][i][j][k],g[t-1][li][lj][lk] + delta);
									}
								}
							}
						}
					}
				}
			}
		}
		int ans=0x3f3f3f3f;
		for(register int i=0;i<2;++i)
			for(register int j=0;j<2;++j)	
				for(register int k=0;k<2;++k)
					ans=min(ans,g[m][i][j][k]);
		printf("%d\n",ans); 
	}
	 
	
	
	return 0;
}

```


---

## 作者：kradcigam (赞：1)

这道题目的话看似没有头绪，我们分析一下。

偶数长度平方矩阵为：$2 \times 2$、$4 \times 4$、$8 \times 8$……

我们考虑是否可能同时满足所有 $2 \times 2$ 的矩阵 $1$ 的个数为奇数，所有 $4 \times 4$ 的矩阵 $1$ 的个数为奇数。

![无标题.png](https://i.loli.net/2020/08/10/Wb7EZy8nuXHwVMl.png)

如图，每个黑色正方形是一个 $2 \times 2$ 的矩阵，为了满足要求它们 $1$ 的个数都为奇数，由 $4$ 个 $2 \times 2$ 的矩阵拼成的 $4 \times 4$ 大矩阵为了复合要求也必须由奇数个 $1$，然后这和我们上面的东西矛盾，因为奇数 $\times 4=$ 偶数，所以，$n\geq 4$ 且 $m \geq 4$ 的矩阵，一定不能满足所有条件。

那么由于 $n\leq 3$，所以我们分类讨论。

- 对于 $n=1$ ，答案显然为 $0$。

- 对于 $n=2$ ，显然对于连续的 $2$ 列，这两列 $1$ 的个数必须奇偶性不相同，因为只有奇数+偶数=奇数。所以一共就只有 $2$ 钟情况。
	1. 第 $1$ 列 $1$ 的个数为奇数，第 $2$ 列 $1$ 的个数为偶数……
    2. 第 $1$ 列 $1$ 的个数为偶数，第 $2$ 列 $1$ 的个数为奇数……
    
    时间复杂度 $O(n)$。
- 对于 $n=3$，我们可以用状压 $dp$ 来做，我们设 $f_{i,j}$ 表示第 $i$ 列状态为 $j$，转移的话，我们枚举前一列的合法状态，对所有可行解取个 $\min$ 即可，最后不要忘记加上这 $1$ 列修改的方格数。

	不难发现，每个状态可以转移的状态数均为 $2$，因此此题复杂度为 $O(n)$，$16$ 倍常数，但这是可以 $A$ 的。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
int a[15][1000010],f[1000010][11];
vector<int>v[15];
bool check(int x,int y){//判断2个状态是否能相互转移
	int a1=x&1,a2=(x>>1)&1,a3=(x>>2)&1;
	int b1=y&1,b2=(y>>1)&1,b3=(y>>2)&1;
	if((a1+a2+b1+b2)%2==0)return false;
	if((a2+a3+b2+b3)%2==0)return false;
	return true;
}
int work(int y,int x){//算修改了几个格子
	int a1=x&1,a2=(x>>1)&1,a3=(x>>2)&1;
	return (a[1][y]!=a1)+(a[2][y]!=a2)+(a[3][y]!=a3);
}
int main(){
	int n,m;read(n);read(m);
	if(n>=4&&m>=4){
		puts("-1");
		return 0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			char ch=getchar();
			for(;ch!='0'&&ch!='1';ch=getchar());
			a[i][j]=(ch=='1');
		}
	if(n==1){
		puts("0");
		return 0;
	}
	if(n==2){
		int ans1=0,ans2=0;
		for(int j=1;j<=m;j++)
			if((a[1][j]+a[2][j])%2!=(j&1))ans1++;
		for(int j=1;j<=m;j++)
			if((a[1][j]+a[2][j])%2!=((j&1)^1))ans2++;
		cout<<min(ans1,ans2);
		return 0;
	}
	for(int i=0;i<(1<<3);i++)
		for(int j=0;j<(1<<3);j++)
			if(check(i,j))
				v[j].push_back(i);
	for(int j=0;j<(1<<3);j++)f[1][j]=work(1,j);//边界
	for(int i=2;i<=m;i++)
		for(int j=0;j<(1<<3);j++){
			f[i][j]=n*m+1;
			for(auto k:v[j]){
				f[i][j]=min(f[i][j],f[i-1][k]+work(i,j));
			}
		}
	int ans=n*m+1;
	for(int j=0;j<(1<<3);j++)ans=min(ans,f[m][j]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Ryo_Yamada (赞：1)

比赛的时候没时间了，不然还是能写出来的.jpg

理解题意：给出一个 $n \times m$ 的 $01$ 矩阵，如果每个长宽都为偶数的子矩阵内 $1$ 的个数都为奇数，则这是一个“好的”矩阵。

如果能把矩阵改成“好的”，问最少改多少个数。如果不能，输出 $-1$。

首先，$n, m$ 不能同时 $\geq4$ 。

证明：取 $(1, 1)$ 到 $(2, 2)$ ，$(1, 3)$ 到 $(2, 4)$ ，$(3, 3)$ 到 $(4, 4)$ ，$(3, 1)$ 到 $(4, 2)$ 。若这四个子矩阵中 $1$ 的个数均为奇数则 $(1, 1)$ 到 $(4, 4)$ 中 $1$ 的个数为偶数。

剩下的就是状压dp了。代码就不给了。

---

## 作者：引领天下 (赞：1)

一个毒瘤的状压dp。~~我挂了3次，结果罚时疼到受不了~~

首先考虑什么情况下是 `-1` ：

- 若 $4\le n,m$ ，则必然无解。

为什么呢？因为若 $n,m$ 均不小于 $4$ ，则我们必然可以找出一个 $4\times 4$ 的正方形，它的左上角的 $2\times 2$ 的正方形有奇数个 $1$ ，右上角也有奇数个，左下角也有奇数个，右下角也有奇数个，  $4$ 个奇数相加，为偶数，必然不满足题意。

那么有解的情况如何处理呢？

首先如果 $n=1$ 或 $m=1$ ，答案必然都是 `0` ：根本不存在偶数边长的正方形。

由于刚才我们判断过了 `-1` 的情况，现在的 $n,m$ 中必然有一个 $\le 3$ 。

这就好办了。

设 $n<=3$ ：

则每列的状态最多有 $8$ 种： $000,001,010,011,100,101,110,111$ 。

然后我们就可以枚举列，枚举第 $i$ 列的状态，如果当前枚举的状态合法，就可以进行转移。

伪代码如下（ $n\le 3$ ） ：

```cpp
if (check(m,st,lst))/*检查状态是否合法*/f[now][st]=min(f[now][st], f[last][lst]+chg/*加上状态间的修改代价*/);
```

$m\le 3$ 时同理。

最后在所有合法状态中取 min 就好啦。代码就不给了。

---


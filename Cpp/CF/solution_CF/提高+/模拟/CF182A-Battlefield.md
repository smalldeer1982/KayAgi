# Battlefield

## 题目描述

Vasya 在大学里落后了，于是他来到了战场。开个玩笑！其实他只是在玩一款电脑游戏。战场是一个平坦的平台，上面挖有 $n$ 条战壕。这些战壕是平面上与坐标轴平行的线段，且任意两条战壕不相交。

远处有一台巨大的敌方激光器。激光器会充电 $a$ 秒，然后持续射击 $b$ 秒，接着再次充电 $a$ 秒，如此循环往复。Vasya 知道 $a$ 和 $b$ 的值。他清楚，在激光射击期间，自己必须躲在战壕内；而在充电期间，他可以安全地在战场上移动。关键是要在激光射击前及时躲入战壕。如果 Vasya 恰好在激光开始射击的时刻到达战壕，我们认为他成功躲藏。巧合的是，任何战壕的长度（以米为单位）在数值上不超过 $b$。

初始时，Vasya 位于点 $A$，他需要到达点 $B$。Vasya 可以以 1 米每秒的速度向任意方向移动。他可以在战壕的任意位置进入或离开，且进出战壕不消耗时间。在战壕内移动时，可以不离开战壕。

假设激光在初始时刻刚刚开始充电，求 Vasya 从点 $A$ 到达点 $B$ 所需的最短时间。如果无法到达，输出 -1。如果 Vasya 在激光开始射击的时刻恰好到达点 $B$，也视为成功。

## 说明/提示

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2 4
0 5 6 5
3
0 0 0 4
1 1 4 1
6 0 6 4
```

### 输出

```
19.0000000000
```

## 样例 #2

### 输入

```
5 10
0 0 10 10
1
5 0 5 9
```

### 输出

```
-1
```

# 题解

## 作者：CarroT1212 (赞：0)

战地上有 $n$ 条战壕，你可以在战地上以一单位每秒的速度移动（移动方向不必与坐标轴平行），也可以原地不动。

敌方的操作可以表示为：最初 $a$ 秒进行装弹，紧接着射击 $b$ 秒，再装弹 $a$ 秒，射击 $b$ 秒……敌方装弹时你可以在战地上随意移动，射击时必须在战壕里移动。

给定 $A,B$ 点坐标，问你最少用多少时间才能从 $A$ 点到 $B$ 点或报告无解输出 `-1`。输出误差不超过 $10^{-4}$ 即为正确。

**保证战壕与坐标轴平行，战壕长度不超过 $b$，且没有战壕相交。保证 $A,B$ 不属于任何一条战壕。**

$1 \le n \le 1000$，所有点的坐标的绝对值都不超过 $10^4$。

------------

瞪了很久不会然后发现把关键信息全漏了……

就挺诈骗的。注意到这三条限制，说明在射击的每一段时间中，你只要成功进到战壕，你就可以在射击结束之前走到战壕的任意一个位置，然后以最近的距离冲向下一条战壕。又因为战壕不相交，这相当于每两条战壕之间在一次装弹中的可达性是完全独立的，不会被之前的行走情况影响。

所以暴力分讨预处理出每两条战壕之间是否可达，再搜一下即可。可以把 $A,B$ 当做一条长度为 $0$ 的战壕。$O(n^2)$。

细节：

+ 这个分讨预处理有一点难写。大概就是钦定有一条战壕是横向的，没有就翻转一下，然后看另外一条是什么方向。对于每种方向，看是否存在方案能向另一条战壕作垂线，不能就枚举连接每对端点然后取最小值。
+ 注意如果钦定 $A,B$ 是战壕的话，最后走到 $B$ 那一步可能并没有走满 $a$ 秒，所以要枚举倒数第二条战壕是哪条。

------------

```cpp
const ld eps=1e-6;
struct nod {
	ld x[2],y[2];
	bool dir() { return y[0]==y[1]; }
	void swp() { swap(x[0],y[0]),swap(x[1],y[1]); }
	void pws() { if (x[0]+y[0]-x[1]-y[1]>0) swap(x[0],x[1]),swap(y[0],y[1]); }
} c[N],f[2];
ld dst(ld xa,ll ya,ll xb,ll yb) { return sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)); }
ll n,a,b;
ld ax,ay,bx,by;
ld ds[N][N],dis[N],ans=J;
void mian() {
	scanf("%lld%lld%Lf%Lf%Lf%Lf%lld",&a,&b,&ax,&ay,&bx,&by,&n);
	for (ll i=1;i<=n;i++) scanf("%Lf%Lf%Lf%Lf",&c[i].x[0],&c[i].y[0],&c[i].x[1],&c[i].y[1]);
	c[++n]={ax,ax,ay,ay},c[++n]={bx,bx,by,by};
	for (ll i=1;i<=n;i++) for (ll j=1;j<=n;j++) {
		ds[i][j]=J,f[0]=c[i],f[1]=c[j];
		f[0].pws(),f[1].pws();
		if (f[0].dir()) f[0].swp(),f[1].swp();
		if (!f[1].dir()) {
			if (!(f[0].y[0]>=f[1].y[1]||f[0].y[1]<=f[1].y[0])) ds[i][j]=abs(f[0].x[0]-f[1].x[1]);
			for (ll r1=0;r1<2;r1++) for (ll r2=0;r2<2;r2++)
				ds[i][j]=min(ds[i][j],dst(f[0].x[r1],f[0].y[r1],f[1].x[r2],f[1].y[r2]));
		}
		else {
			for (ll r1=0;r1<2;r1++) for (ll r2=0;r2<2;r2++)
				ds[i][j]=min(ds[i][j],dst(f[0].x[r1],f[0].y[r1],f[1].x[r2],f[1].y[r2]));
			if (f[1].x[0]<=f[0].x[1]&&f[0].x[1]<=f[1].x[1]) ds[i][j]=min(abs(f[1].y[0]-f[0].y[0]),abs(f[1].y[1]-f[0].y[1]));
			if (f[0].y[0]<=f[1].y[0]&&f[1].y[1]<=f[0].y[1]) ds[i][j]=min(abs(f[1].x[0]-f[0].x[0]),abs(f[1].x[1]-f[0].x[1]));
		}
	}
	for (ll i=1;i<=n;i++) dis[i]=J;
	queue<ll> q;
	q.push(n-1),dis[n-1]=0;
	while (!q.empty()) {
		ll p=q.front();
		q.pop();
		for (ll i=1;i<=n;i++) if (ds[p][i]-eps<=a&&dis[i]>dis[p]+1) dis[i]=dis[p]+1,q.push(i);
	}
	for (ll i=1;i<n;i++) if (ds[i][n]-eps<=a) ans=min(ans,dis[i]*(a+b)+ds[i][n]);
	if (ans>=J-eps) cout<<"-1";
	else printf("%.15Lf",ans);
}
```

---


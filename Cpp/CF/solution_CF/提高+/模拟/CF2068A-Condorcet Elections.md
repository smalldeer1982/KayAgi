# Condorcet Elections

## 题目描述

正值市政选举年。尽管该国领导人已二十年未变，但选举始终透明且公正。

共有 $n$ 名政治候选人（编号 $1$ 至 $n$）参与竞选。选举采用改进的排序投票制：每位选民需对所有 $n$ 名候选人进行从最优到最差的排序。即每张选票是 $\{1, 2, \ldots, n\}$ 的一个排列，其中排列的第一个元素代表最优先的候选人。

当且仅当候选人 $a$ 在超过半数的选票中排在候选人 $b$ 之前时，我们称候选人 $a$ 击败候选人 $b$。

由于选举公平透明，国家电视台已提前宣布了 $m$ 个事实——第 $i$ 个事实为"候选人 $a_i$ 击败候选人 $b_i$"，且这些声明均发生在实际选举之前！

作为选举委员会负责人，你需要统计选票并给出符合电视台宣传结果的选票列表，或判定其不可能实现。但请注意，你最好能找到解决方案，否则可能得罪上级。


## 说明/提示

在第二个样例中，候选人 $1$ 击败候选人 $2$ 是因为在三张选票中有两张 $1$ 排在 $2$ 前（超过总票数的一半）。同理，候选人 $2$ 击败候选人 $3$，候选人 $3$ 击败候选人 $1$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2 1
1 2```

### 输出

```
YES
1
1 2```

## 样例 #2

### 输入

```
3 3
1 2
2 3
3 1```

### 输出

```
YES
3
1 2 3
2 3 1
3 1 2```

# 题解

## 作者：InterRiver (赞：1)

因为 $a_i \ne b_i$ 且无序对 $\set{a_i, b_i}$ 不重复，本题一定有解。

提供两种只需要 $k = 2n$ 个选票列表的构造方案。

### 第一种构造方案

第一种是我练题的时候自己想的。对某个候选人 $x$，令 $A$ 为他击败的候选人集合，令 $B$ 为不在 $A$ 中也不等于 $x$ 的候选人的集合，可以尝试构造两个排列，满足以下条件：

+ 在两个排列中，$x$ 都胜过 $A$ 的所有元素。
+ 综合两个排列，$A, B$ 势均力敌。
+ 综合两个排列，$x, B$ 势均力敌。
+ 综合两个排列，$A$ 和 $B$ 各自内部任意两个候选人势均力敌。

令 $A, B$ 为有序集合，$\mathrm{rev}(S)$ 代表反向的有序集合 $S$，下面两个排列满足上述要求：

+ $x, A, B$
+ $\mathrm{rev}(B), x, \mathrm{rev}(A)$

对每一个候选人 $1 \le x \le n$ 构造两个排列，总排列数 $k = 2n$。

### 第二种构造方案

在题解评论区，benq 提供了另一种方案，与官方题解思路比较相似。

对于一个限制 $(a, b)$，令 $S$ 为不等于 $a$ 也不等于 $b$ 的候选人的有序集合，构造两个排列：

+ $a, b, S$
+ $\mathrm{rev}(S), a, b$

这样就可以做到 $2m$ 个选票列表。但是，那么大那么长的一个 $S$ 段落可能太浪费了，假设有另外一个限制 $(c, d)$ 且 $a, b, c, d$ 互不相同，完全可以在 $S$ 段中再构造出 $c$ 对 $d$ 的胜利。令 $R$ 为所有不属于 $\set{a, b, c, d}$ 的候选人的有序集合：

+ $a, b, c, d, R$
+ $\mathrm{rev}(R), c, d, a, b$

依此类推，若有 $\lfloor \frac{n}{2} \rfloor$ 对限制条件，它们的元素互不相同，可以只用两个排列，一次性构造出它们。

benq 给出的分类方案是，对每个限制条件 $a, b$，按照 $(a + b) \mod n$ 进行分类。同类中任何两个限制条件的元素均不相同，可以只构造两个排列满足一类中所有的条件。显然种类数最多 $n$ 种，总排列数 $k \le 2n$。

---

## 作者：_O_v_O_ (赞：1)

好一个诈骗。

直接说构造方法：对于每对 $(a_i,b_i)$，分别构造出 $\{a_i,b_i,1,2,3,\cdots, a_i-1,a_i+1,\cdots, b_i-1,b_i+1,\cdots, n\}$ 和 $\{n,n-1,n-2,\cdots,b_i+1,b_i-1,\cdots,a_i+1,a_i-1,\cdots,1,a_i,b_i\}$，然后我们注意到对于其他的 $(a_j,b_j)$ 在这两个序列中的限制可以互相消除掉，而 $(a_i,b_i)$ 在这两个序列中会刚好满足限制。而总的个数为 $2\times m$，可以满足序列数的要求。

那么我们发现这题就做完了，非常难崩。

---

## 作者：ARIS1_0 (赞：1)

题意不再赘述，直接说思路

# 思路

首先我们需要证明：答案永远为 `YES`。

观察题目条件，$\{a_i,b_i\}$ 只会出现一次，而答案为 `NO` 的一个基础条件是在输入中 $a_i$ 击败了 $b_i$，而 $b_i$ 又把 $a_i$ 给击败了，但是题面确保了这一点不会出现。

那么我们来思考一下有没有其他情况会导致答案为 `NO`，无非就是没法构造一种情况使得在超过 $\frac{k}{2}$ 个结果里面，$a_i$ 击败了 $b_i$，但是这很明显不可能。我们就先假设出现了这个情况，换一个角度来想：超过 $\frac{k}{2}$ 个结果里面是 $b_i$ 击败了 $a_i$，那我们把 $a_i$ 和 $b_i$ 交换一下不就成了我们想要的情况了吗？

反正就是这么感性理解一下，答案永远为 `YES`。

接下来就剩下构造的方法了，我们可以这么想：在每一种选票结果中，单独考虑 $a_i$ 与 $b_i$，我们想要 $a_i$ 击败 $b_i$，所以我们把所有 $a_i$ 排在 $b_i$ 前面的序列的权值赋值为 $1$，反之赋值为 $-1$，那合法的方案就是所有序列的权值和为**正整数**，那么我们可以想到一个**初步的方案**：构造 $\lfloor\frac{m}{2}\rfloor+1$ 个选票结果使得 $a_i$ 击败了 $b_i$，剩下的选票结果方案随便构造即可。

这个初步方案明显是错的，一眼就能看出来。我们只考虑了单个 $\{a_i,b_i\}$ 的情况，其他的呢？我们放任不管可不是好事情哦。到时候你随便构造，只要有一个情况没有满足整个程序直接爆炸。

那么我们就需要考虑另外一个方案，在构造对于 $\{a_i,b_i\}$ 的情况时，我们要尽量使得**其他任意一对的选举结果在考虑时权值和**为 $0$。这样子就能把影响消除到最小。

怎么构造才能使得任意一对的选举结果在考虑时权值和为 $0$？很简单，我们这样来思考，对于第 $i$ 个人，我们让他在一种选票结果里面击败了第 $[1,i-1]$ 个人，被第 $[i+1,n]$ 个人以及 $a_i,b_i$ 击败。在另外一种选票结果里面，第 $i$ 个人被第 $[1,i-1]$ 个人击败，击败了第 $[i+1,n]$ 个人以及 $a_i,b_i$，这样子对于任意一对不是 $\{a_i,b_i\}$ 的选举结果，它的权值和一定为 $0$，同时又保证了 $a_i$ 击败了 $b_i$，这样子的权值和又为正整数，也就是 $2$。

所以说我们来构造两个选票序列，一个序列为 $a_i,b_i,1,2,3,\dots,n-1,n$，另外一个为 $n,n-1,n-2,\dots,2,1,a_i,b_i$ 即可！对于每一个预期的 $\{a_i,b_i\}$ 我们都只构造这个序列，因为我们在考虑其他数对时其他权值和为 $0$，权值和只由当前构造的这两个选票序列决定，正确性显然。

这道题就这么解决了。总共构造了 $m\times 2$ 个序列。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
mt19937 myrand(time(0));
inline ll read(){
	ll x=0,w=1;
	char ch=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*w;
}
void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	static int sta[35];
	int top=0;
	do{
		sta[top++]=x%10,x/=10;
	}while(x);
	while(top)putchar(sta[--top]+'0');
}
int n,m;
pair<int,int>a[3000];
bool vis[60];
int main(){
	n=read();m=read();
	for(int i=1;i<=m;i++){
		a[i].first=read();
		a[i].second=read();
	}
	puts("YES");
	cout<<(m<<1)<<"\n";
	for(int i=1;i<=m;i++){
		int a1=a[i].first;
		int b1=a[i].second;
		vis[a1]=vis[b1]=1;
		cout<<a1<<" "<<b1<<" ";
		for(int i=1;i<=n;i++){
			if(vis[i])continue;
			cout<<i<<" ";
		}
		puts("");
		for(int i=n;i;i--){
			if(vis[i])continue;
			cout<<i<<" ";
		}
		cout<<a1<<" "<<b1<<"\n";
		vis[a1]=vis[b1]=0;
	}
	return 0;
}
```

[通过记录](https://codeforces.com/contest/2068/submission/308724969)。

---

## 作者：lalaouye (赞：0)

发现一个排列加上这个翻转后的排列可以保证 $\ge \frac n 2$。

然后考虑对于每个限制可以在不影响其他限制的情况下多算。发现让这两个挨在一起其它随便放，然后翻转时不让这两个数翻转就行了。

---


# 0-1 MST

## 题目描述

Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on $ n $ vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either $ 0 $ or $ 1 $ ; exactly $ m $ edges have weight $ 1 $ , and all others have weight $ 0 $ .

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

## 说明/提示

The graph from the first sample is shown below. Dashed edges have weight $ 0 $ , other edges have weight $ 1 $ . One of the minimum spanning trees is highlighted in orange and has total weight $ 2 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1242B/fca3e805aa04953bd891689ec1c79b03eae5d280.png)In the second sample, all edges have weight $ 0 $ so any spanning tree has total weight $ 0 $ .

## 样例 #1

### 输入

```
6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 0
```

### 输出

```
0
```

# 题解

## 作者：zhoukangyang (赞：20)

蒟蒻第一次打 div1...虽然是 vp

蒟蒻的菜鸡做法竟然跑了全谷第一 (至少在 $2020.8.4$ 之前qwq) ?写篇题解纪念一下qwq

## 题面
> 给定一张完全图, 其中有 $m$ 条边权值为 $1$, 求这张图的最小生成树

> 数据范围：$n, m \le 10^5$

## 题解

转化一下, 就是给定一张图, 给定 $m$ 对点, 这 $m$ 对点之间没有连边, 要求出 联通块个数$ - 1 $

考虑到连的边有 $n^2$ 条, 然而这样跑最小生成树稳稳的 $\rm TLE$。 但是发现断开的边十分稀疏, 所以如果选出某个特定的点, 能出发连向另一个点的概率十分大, 所以可以考虑从一个度数最大的点 (就是断边最少的点), 出发去掉连向其他点的边, 然后再在剩余的点上跑类似于最小生成树的东西, 算联通块。

这里的最小生成树不用排序,跑一次有连边的点就好了qwq

时间复杂度貌似还是很大???

但是仔细一算...

最大度数最小为 $\frac{n^2 - 2m}{n}$

跑了最小生成树的点数最大为 $n - \frac{n^2 - 2m}{n} = \frac{2m}{n}$ 且不超过 $n$

所以时间复杂度是 $\Theta(n +n \times \frac{m}{n}) = \Theta(n + m)$ 的，是线性的。

## 代码


```cpp
#include<bits/stdc++.h>
#define N 110000
#define M 500
#define re register
using namespace std;
int n, m, cnt, minn = 1;
int mp[N], deg[N], bh[M], dy[N], f[N], tot;
struct edge {
    int fr, to, val;
} e[N];
bitset<N> g[M];
int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}
inline int read() {
	char c = getchar();int x = 0;
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c  <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x;
}
int main() {
    n = read(), m = read();
    for(re int i = 1; i <= n; i++) f[i] = i;
    for(re int i = 1; i <= m; i++) e[i].fr = read(), e[i].to = read(), deg[e[i].fr]++, deg[e[i].to]++;
    for(re int i = 2; i <= n; i++) if(deg[i] < deg[minn]) minn = i;
    for(re int i = 1; i <= m; i++) {
        if(e[i].fr == minn) mp[e[i].to] = 1;
        if(e[i].to == minn) mp[e[i].fr] = 1;
    }
    for(re int i = 1; i <= n; i++){
        if(mp[i] == 1) ++tot, dy[tot] = i, bh[i] = tot;
        else f[i] = minn;
    }   
    for(re int i = 1; i <= m; i++) {
        if(mp[e[i].fr] == 1) g[bh[e[i].fr]][e[i].to] = 1;
        if(mp[e[i].to] == 1) g[bh[e[i].to]][e[i].fr] = 1;
    }
    for(re int i = 1; i <= tot; i++) {
        int u = dy[i];
        for(re int j = 1; j <= n; j++) {
            if(g[i][j]) continue;
            if(find(u) == find(j)) continue;
            ++cnt, f[find(u)] = find(j);
        }
    }
    printf("%d\n", tot - cnt);
    return 0;
}
```

---

## 作者：quanjun (赞：14)

题目链接：[https://codeforces.com/problemset/problem/1242/B](https://codeforces.com/problemset/problem/1242/B)  

题目大意：  

给定一个包含 $n(1 \le n \le 10^5)$ 个节点的完全图，图中有 $m$ 条长度为 $1$ 的边（$0 \le m \le \min(\frac{n(n-1)}{2}, 10^5)$），其余的边长度均为 $0$。求最小生成树长度。  

解题思路（参考自 [官方题解](https://codeforces.com/problemset/problem/1242/B) ）：  

首先，如果只考虑图中长度为 $0$ 的边的话：假设所有节点和长度为 $0$ 的边构成的子图中有 $k$ 个连通块，则最小生成树的长度为 $k-1$（因为这 $k$ 个连通块之间需要 $k-1$ 条长度为 $1$ 的边将其连通）。因此，我们的主要目的就是去寻找存在多少个这样的连通块。  

下面描述的是一个 $O(m + n \log n)$ 的解法。  

我们使用并查集维护零权值连通块，同时存储每个连通块的大小。然后从 $1$ 到 $n$ 依次遍历每个节点 $v$，并将节点 $v$ 放到一个大小为 $1$ 的连通块内。然后我们遍历与节点 $v$ 邻接的所有权值为 $1$ 的边 $\{ u, v \}$（要求 $u \lt v$）。对于每一个零权值连通块，我们计算从这个连通块（即 $u$ 所处的连通块）到节点 $v$ 存在多少条边。如果边的数量小于 $u$ 所处的连通块的大小，我们需要合并节点 $u$ 和 $v$（因为在连通块和 $v$ 之间至少有一条权值为 $0$ 的边）。否则，我们不能将这个连通块和节点 $v$ 合并。最后，我们得到了零权值连通块的个数。  

这个算法的时间复杂度是多少呢？整体来说，有 $n$ 个连通块被创造出来了（因为每处理一个节点就会新建一个大小为 $1$ 的连通块）。当我们将某个老的连通块同节点 $v$ 进行合并的时候，连通块的数量减少了一个。所以合并操作最多进行 $O(n)$ 次，而我们是使用并查集来进行合并的，所以这部分的时间复杂度为 $O(n \log n)$。  

如果一个旧的连通块与节点 $v$ 不进行合并，则我们能证明这个旧的连通块节节点 $v$ 之间至少存在一条边，所以这种情况等于边的数量 —— $m$。所以这部分的时间复杂度为 $O(m)$。  

所以总的时间复杂度为 $O(n \log n + m)$。  

示例程序：  
```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int n, m, f[maxn], sz[maxn], ans;
vector<int> g[maxn], vec;
map<int, int> cnt;

void init() {
    for (int i = 1; i <= n; i++)
        f[i] = i, sz[i] = 1;
}

int find(int x) {
    return x == f[x] ? x : f[x] = find(f[x]);
}

void merge(int x, int y) {
    int a = find(x), b = find(y);
    if (a > b) swap(a, b);
    if (a != b) f[b] = a, sz[a] += sz[b];
}

int main() {
    cin >> n >> m;
    init();
    while (m--) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (int u = 1; u <= n; u++) {
        cnt.clear();    // cnt[i]记录u与第i个集合有多少相连的边
        for (auto v : g[u])
            if (v < u)
                cnt[find(v)]++;
        for (auto v : vec) {
            int p = find(v);
            if (sz[p] > cnt[p])
                merge(p, u);
        }
        if (find(u) == u) vec.push_back(u);
    }
    for (int i = 1; i <= n; i++)
        if (find(i) == i)
            ans++;
    cout << ans - 1 << endl;
    return 0;
}
```

---

## 作者：QwQcOrZ (赞：12)

考虑先把度数最小的结点找出来，然后用并查集进行一波合并，将所有与他没有边的点与他合并。

又是根据鸽巢原理，这个点的度数不会超过 $\frac{2m}{n}$。因为所有点度数和为 $2m$。

所以这一步之后的联通块个数最多只有 $\lfloor \frac{2m}{n} \rfloor+1$ 个。

然后对于这些联通块直接暴力合并，时间复杂度 $\mathcal O(\min(\frac{2m}{n},n)^2)$

然后你会发现 $\min$ 中的两个量乘积永远是 $2m$，所以 $\min$ 的值不超过 $\sqrt{2m}$。

因此最后时间复杂度 $\mathcal O(n+m)$

$Code\ Below$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
const int M=2e6+5;

int read()
{
	int s=0;
	char c=getchar(),lc='+';
	while (c<'0'||'9'<c) lc=c,c=getchar();
	while ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();
	return lc=='-'?-s:s;
}
void write(int x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x<10) putchar(x+'0');
	else
	{
		write(x/10);
		putchar(x%10+'0');
	}
}
void print(int x=-1,char c='\n')
{
	write(x);
	putchar(c);
}
struct node
{
	int to,nxt;
}e[M*2];
int head[N],cnte=0;
void add(int u,int v)
{
	e[++cnte].to=v;
	e[cnte].nxt=head[u];
	head[u]=cnte;
}
int siz[N],fa[N],no[N],cnt=0;
bool vis[N],is[N];
int find(int x)
{
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
inline void merge(int x,int y)
{
	fa[find(x)]=find(y);
}

signed main(signed Recall,char *_902_[])
{
	(void)Recall,(void)_902_;

	int n=read(),m=read();
	for (int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		add(u,v);
		add(v,u);
		siz[u]++;
		siz[v]++;
	}
	int Min=n,id=0;
	for (int i=1;i<=n;i++) if (Min>siz[i]) Min=siz[i],id=i;
	for (int i=1;i<=n;i++) fa[i]=i;
	for (int i=head[id];i;i=e[i].nxt) vis[e[i].to]=1;
	for (int i=1;i<=n;i++) if (!vis[i]) fa[i]=id,is[i]=1;
	for (int i=1;i<=n;i++) if (!is[i]) no[++cnt]=i;
	memset(vis,0,sizeof(vis));
	for (int i=1;i<=n;i++)
	{
		int tot=0;
		for (int j=head[i];j;j=e[j].nxt)
		{
			int to=e[j].to;
			vis[to]=1;
			tot+=is[to];
		}
		if (tot+cnt<n) merge(i,id);
		for (int j=1;j<=cnt;j++) if (!vis[no[j]]) merge(i,no[j]);
		for (int j=head[i];j;j=e[j].nxt) vis[e[j].to]=0;
	}
	int ans=-1;
	for (int i=1;i<=n;i++) ans+=i==fa[i];
	print(ans);

	return 0;
}
```

---

## 作者：Imakf (赞：10)

~~不太对劲的做法：线段树~~

由于 $w=0$ 的边太多，**我们只考虑 $w=1$ 的边**

考虑如何构造一棵生成树，先举个例子：

把 $1$ 号当作起点，此时我们显然不希望连出一条 $w=1$ 的边，于是我们给所有与 $1$ 号节点相邻（当然只考虑 $w=1$ 的边）的节点都打上一个 tag。

然后选择一个没有 tag 的点作为下一次起点，继续扩展，假设选中的是 $v$ 节点。

那么我们继续给所有与 $v$ 号节点相邻的节点都打上一个 $tag$ 。

我们一样按照贪心的思路，选中没有 tag 的节点；如果都被打上了至少一次 tag，那就寻找只被打过 tag 一次的点。将它再次作为起点。重复上述操作直到所有点都被走到。

不然就只可能剩下被打过两次 tag 的点了，**此时我们就被迫，必须连出一条 $w=1$ 的边**了，于是 $++Ans$

----

于是我们得出了算法如下：

$1.$ 随便选中一个节点 $st$ 作为起始节点； 

$2.1$ 把与起始节点 $st$ **直接相邻的点的权值都 $+1$**；  
$2.2.$ 把起始节点 $st$ 的权值设置为 $INF$ 以免重复使用；  

$3.1$ **寻找权值最小的点** $v_{\min}$;  
$3.2$ 设当前已经经过了  $size$ 个点（不包含 $v_{\min}$），若 $v_{\min}$ 的权值 $= size$，则 $++Ans$;  
$3.3$ 把 $v_{\min}$ 重新作为起始节点 $st$；  

$4.$ 如果所有的点都被经过，则结束，反之回到 $2.1$。

上述一切操作均可用线段树实现。

```cpp
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>

#define rg register
#define il inline
#define MX (100000 + 4)

int min(int a ,int b){return a < b ? a : b;}
int read(){}

int head[MX] ,tot;
struct edge{
	int node ,next;
}h[MX << 1];
void addedge(int u ,int v){
	h[++tot].next = head[u];
	head[u] = tot;
	h[tot].node = v;
}

struct node{
	int l ,r ,mn ,mnpos;
	node *lch ,*rch;
}*root;

void pushup(node *x){
	x->mn = min(x->lch->mn ,x->rch->mn);
	if(x->mn == x->lch->mn)	x->mnpos = x->lch->mnpos;
	else x->mnpos = x->rch->mnpos;
}

node *build(int l ,int r){
	node *x = new node;
	x->l = l ,x->r = r ,x->mn = 0;
	if(l == r){
		x->mnpos = l;
		x->lch = x->rch = NULL;
	}
	else{
		int mid = l + r >> 1;
		x->lch = build(l ,mid);
		x->rch = build(mid + 1 ,r);
		pushup(x);
	}
	return x;
}

void add(node *x ,int l ,int r ,int val){
	if(l <= x->l && x->r <= r)	return (void)(x->mn += val);
	int mid = x->l + x->r >> 1;
	if(mid >= l)	add(x->lch ,l ,r ,val);
	if(mid < r)		add(x->rch ,l ,r ,val);
	pushup(x);
}

int main(){
	int n = read() ,m = read();
	for(rg int i = 1 ,u ,v ; i <= m ; ++i){
		u = read() ,v = read();
		addedge(u ,v);
		addedge(v ,u);
	}
	root = build(1 ,n);
	int Ans = 0;
	for(rg int i = 1 ; i <= n ; ++i){
		node x = *root;
		if(x.mn >= i - 1)	++Ans;
		add(root ,x.mnpos ,x.mnpos ,233333);
		for(rg int j = head[x.mnpos] ; j ; j = h[j].next){
			add(root ,h[j].node ,h[j].node ,1);
		}
	}
	printf("%d\n" ,Ans - 1);
	return 0;
} 
```

---

## 作者：XY_cpp (赞：9)

首先考虑暴力

把这张图的补图建出来，那么原问题转化为求连通块个数-1

但是补图的边太多，不能直接搞

把连通块看成集合，然后想到能用并查集去维护

考虑$[1,u-1]$的点已经形成了$k$个集合，第$i$个集合的大小为$s_i$，那么对于节点$u$，计算它向每个集合连的边数
$mp_i$，如果$mp_i<s_i$，说明$u$在$i$集合中有$s_i-mp_i$条权值为$0$的边，所以 $u$**所在的集合** 与 **集合$i$** 合并。

这时，聪明的你要问了：复杂度？每次枚举点$u$，然后枚举集合$i$，复杂度不是$O(n^2)$吗？

事实上，集合数并没有这么多，~~可以口胡~~容易证明，要把一个结点从完全图中挖出来，第一个结点需要连$n$条权值为1的边，第二个结点需要连$n-1$条权值为1的边……

设有$k$个集合

$$\sum_{x=1}^k(n-x)\le min(m,\frac{n(n-1)}{2}),k \le n$$

求$k$的最大值

这个玩意我好像不太会证，如果谁能证明出来，请私信XY_cpp

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
map<int,int>ma;
vector<int>e[N],b;
int n,m,tot,f[N],s[N];
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        f[i]=i,s[i]=1;
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        if(u<v) swap(u,v);
        e[u].push_back(v);
    }
    for(int u=1;u<=n;u++)
    {
        ma.clear();
        for(auto v:e[u])
            ma[find(v)]++;
        for(auto v:b)
        {
            int x=find(u),y=find(v);
            if(x==y) continue;
            if(ma[y]<s[y])
                f[x]=y,s[y]+=s[x];
        }
        if(find(u)==u) b.push_back(u);
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        if(f[i]==i) 
            ans++;
    cout<<ans-1<<endl;
    return 0;
}
```

---

## 作者：RedLycoris (赞：9)

水题，直接暴力就能过

---

由于图很大，所以就不能直接连边最小生成树


所以我们可以换一个角度考虑:

求出所有可以用0边连成的联通块，那么将这些联通快连起来，就可以构造出一颗最小生成树

那么怎么求联通快呢?

直接dfs是可以的！

但是需要剪枝

---

最短代码

set<int> s:还有哪些点没有被访问过
  由于只有一些边是1边，所以几次下来，就几乎全访问过了

  map<int,int> g[]: 存所有的1边

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt;
map<int,int>g[200005];
set<int>s,ns;
inline void dfs(int x){
	vector<int>v;v.clear();ns.clear();
	for(set<int>::iterator it=s.begin();it!=s.end();it++)if(!g[x][*it])v.push_back(*it);else ns.insert(*it);  //只用在没有经过的点中找
	s=ns;//更新
  for(int i:v)dfs(i);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;++i)scanf("%d%d",&u,&v),g[u][v]=1,g[v][u]=1;
	for(int i=1;i<=n;++i)s.insert(i);
	for(;s.size();){++cnt;int t=*s.begin();s.erase(t);dfs(t);}
	printf("%d\n",cnt-1);
}
```

---

## 作者：一扶苏一 (赞：4)

## Analysis

按照 kruskal 的思想，首先先尽可能选 0 边。我们先用零边尽可能连连通块，答案就是用 $0$ 边连出的连通块个数减去 $1$。

共有 $m$ 条 $1$ 边分配给 $n$ 个点。于是一定存在一个点连接的 $1$ 边条数不超过 $\frac m n$，于是它连接了至少 $n - \frac m n$ 条 $0$ 边。这样，我们找到了一个大小至少为 $n - \frac m n$ 的连通块，将之称之为左部。可以想象，$n$ 比较大时，考虑到 $m$ 的限制，左部这个连通块其实包含了大量点。我们现在要说明剩下的部分很小，可以直接暴力枚举点对。

左部之外还剩下至多 $n - (n - \frac m n) = \frac m n$ 个点，它们现在各自独立成一个连通块。我们只需要考虑这些连通块之间的零边。

称左部之外的点是右部，要把右部里的点尽可能用零边连起来，只需要暴力枚举点对，看点对之间的边是不是零边即可。这是因为右部点数 $\frac m n < n$，于是总枚举量是 $(\frac m n)^2 < n \times \frac m n = m$。

考虑左右部之间的连边，只需要枚举左部点和右部点，看点对之间是不是零边。点对的枚举量是 $(n - \frac m n) \times \frac{m}{n} = m - \frac{m^2}{n^2} < m$。也是线性的。

## Code

```cpp
#include <set>
#include <vector>
#include <iostream>
#include <algorithm>

const int maxn = 100005;

int n, m;
std::set<int> e[maxn];

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> m;
  for (int u, v; m; --m) {
    std::cin >> u >> v;
    e[u].insert(v);
    e[v].insert(u);
  }
  int minid = 1;
  for (int i = 2; i <= n; ++i) if (e[i].size() < e[minid].size()) minid = i;
  std::vector<int> ufs(n + 1), rnk(n + 1);
  auto find = [&](int x) { while (ufs[x] != x) x = ufs[x] = ufs[ufs[x]]; return x; };
  auto unionn = [&](int x, int y) {
    if (x == y) return;
    if (rnk[x] > rnk[y]) std::swap(x, y);
    ufs[x] = y;
    rnk[y] += rnk[x] == rnk[y];
  };
  for (int i = 1; i <= n; ++i) rnk[ufs[i] = i] = 1;
  std::vector<int> left, right;
  for (int i = 1; i <= n; ++i) if (e[minid].count(i) == 0) {
    left.push_back(i);
  } else {
    right.push_back(i);
  }
  
  for (auto u : right) {
    for (auto v : right) if (find(u) != find(v) && e[u].count(v) == 0) {
      unionn(find(u), find(v));
    }
  }
  for (auto u : left) unionn(find(u), find(minid));
  for (auto u : left) {
    for (auto v : right) if (find(u) != find(v)) {
      if (e[u].count(v) == 0) {
        unionn(find(u), find(v));
      }
    }
  }
  int ans = -1;
  for (int u = 1; u <= n; ++u) {
    if (find(u) == u) ++ans;
  }
  std::cout << ans << std::endl;
}
```

---

## 作者：灵茶山艾府 (赞：4)

理论上来说，复杂度可以是 $O(n+m)$，证明如下：

定义权值为 $0$ 的边为 $0-$边，权值为 $1$ 的边为 $1-$边。

原题可转换成求 $0-$边构成的图的连通分量个数$-1$。

考察 $1-$边最少的点 $v$，由于「**最小值不会超过平均值**」，$v$ 的 $1-$边数量$\leq \frac{2m}{n}$。

举例来说，当 $n=1000,\ m=10000$ 时，点 $v$ **至多**有 $20$ 条 $1-$边，即至少有 $980$ 条 $0-$边。这意味着仅仅考察点 $v$，我们就找到了一个大小至少为 $980$ 的连通分量。

对于剩余的 $20$ 个点，暴力遍历求取该点所属的联通分量即可。

综上所述，使用路径压缩和按秩合并的并查集（复杂度视作常数），总的复杂度为构造点 $v$ 的联通分量的开销 $O(n)$，加上遍历剩余点的开销 $O(\frac{2m}{n}*n)$，即 $O(n+m)$。

附上 AC 代码（Golang）

```go
package main

import (
	"bufio"
	. "fmt"
	"os"
)

var fa []int

func initFa(n int) {
	fa = make([]int, n)
	for i := range fa {
		fa[i] = i
	}
}
func find(x int) int { // 简单起见，实现仅用路径压缩优化
	if fa[x] != x {
		fa[x] = find(fa[x])
	}
	return fa[x]
}
func merge(from, to int) { fa[find(from)] = find(to) }
func same(x, y int) bool { return find(x) == find(y) }

func main() {
	in := bufio.NewReader(os.Stdin)

	var n, m int
	Fscan(in, &n, &m)
	g := make([][]int, n) // 1-边
	for ; m > 0; m-- {
		var v, w int
		Fscan(in, &v, &w)
		v--
		w--
		g[v] = append(g[v], w)
		g[w] = append(g[w], v)
	}

	// 寻找 0-边最多的点 maxDeg0V
	maxDeg0, maxDeg0V := 0, 0
	for v, edges := range g {
		if deg0 := n - 1 - len(edges); deg0 > maxDeg0 {
			maxDeg0 = deg0
			maxDeg0V = v
		}
	}

	// 若图中没有 0-边，答案就是点的个数-1
	if maxDeg0 == 0 {
		Print(n - 1)
		return
	}

	mergeEdge0 := func(v int, edges []int) {
		// 将与点 v 以 0-边相连的点，合并到点 v 所属的连通分量上
		vs := map[int]bool{v: true}
		for _, w := range edges {
			vs[w] = true
		}
		for i := 0; i < n; i++ {
			if !vs[i] { // i-v 是 0-边
				merge(i, v)
			}
		}
	}
	initFa(n)
	mergeEdge0(maxDeg0V, g[maxDeg0V])
	for v, edges := range g {
		if !same(v, maxDeg0V) {
			// 暴力遍历剩余的点
			mergeEdge0(v, edges)
		}
	}

	// 计算联通分量个数-1
	ans := -1
	for i, faI := range fa {
		if i == faI {
			ans++
		}
	}
	Print(ans)
}
```


---

## 作者：elbissoPtImaerD (赞：2)

首先考虑转化题意：题意等价于求补图上的连通块个数 $-1$。  
这很好想到，因为自然是想让 $0$ 边都用上，这样在补图上就形成若干个连通块，两两连通块之间有一条 $1$ 边相连，那自然是连通块个数 $-1$。

怎么求呢？

最暴力的做法当然是 $\mathcal{O(n^2)}$ 枚举两个点然后用并查集维护。

然后发现，如果固定一个点 $u$，那另外一个点的可能性只有 $d_u$ 种，剩下的都可以直接连。

再对这 $d_u$ 个可能的点暴力考虑，复杂度是 $\mathcal{O(dn)}$ 的。

由抽屉原理，$d$ 的最小值是 $\min\{\lfloor\frac {2m}n\rfloor,n\}$。

这个东西显然均值取等，上界不超过 $\sqrt{2m}$。

复杂度 $\mathcal{O(n\sqrt m)}$。

```cpp
const int N=1e5+3;
bool*MS;
int n,m,b[N],*p_b=b,fa[N],ans;
struct wt{int x,y;}a[N];
bool vis[N];
std::vector<int>G[N];
bool*MT;
il int get(re int x)
{
	for(;x^fa[x];x=fa[x]=fa[fa[x]]);
	return x;
}
void Solve()
{
	rd(n),rd(m);
	for(re int i=1;i<=m;++i) rd(a[i].x),rd(a[i].y),G[a[i].x].pb(a[i].y),G[a[i].y].pb(a[i].x);
	re int k=1;
	for(re int i=2;i<=n;++i) G[k].size()>G[i].size()&&(k=i);
	for(re int i=1;i<=n;++i) fa[i]=i;
	for(re int i=1;i<=m;++i)
		if(a[i].x==k||a[i].y==k) *++p_b=a[i].x==k?a[i].y:a[i].x,vis[*p_b]|=1;
	for(re int i=1;i<=n;++i) vis[i]?vis[i]&=0:fa[i]=k;
	ans=p_b-b;
	for(re int*i=b+1;i<=p_b;++i)
	{
		for(re int v:G[*i]) vis[v]|=1;
		for(re int j=1,x,y;j<=n;++j)
		{
			if(vis[j]||(x=get(*i))==(y=get(j))) continue;
			fa[x]=y,--ans;
		}
		for(re int v:G[*i]) vis[v]&=0;
	}
	wrt(ans);
	return;
}
```

[$\color{green}{\checkmark}$](https://codeforces.com/contest/1242/submission/206341369)。

---

## 作者：MurataHimeko (赞：1)

看到对完全图求最小生成树，我们很自然能想到使用 Boruvka 算法。

每次扩展集合时，先枚举集合内的点的边权为 $1$ 的边，并标记终点。

如果一个点被集合内所有点标记了，那么我们就不优先选这个点。

每层枚举的复杂度为 $O(n+m)$，总共有 $\log n$ 层，时间复杂度 $O((n+m) \log n)$。


代码：

```cpp
#include <bits/stdc++.h> 
#define rep(i, f, t) for(int i(f); i <= t; ++i)
#define re(i, t) for(int i(1); i <= t; ++i)
#define per(i, t, f) for(int i(t); i >= f; --i)
#define pe(i, t) for(int i(t); i >= 1; --i) 
#define nx(i, u) for(int i(head[u]); i; i = e[i].nxt) 
typedef long long ll;
typedef long double lb;
// #define int long long
using namespace std; 

const int N = 1e5 + 5;
int n, m, u, v;
int fath[N];

int find (int u) {
    return (fath[u] == u) ? u : (fath[u] = find(fath[u]));
}

struct node {
    int to, nxt;
}e[N<<1];

int head[N], cnt;

void add (int u, int v) {
    e[++cnt] = (node){v, head[u]};
    head[u] = cnt;
}

vector<int>vec[N];
int vis[N];
int f[N], g[N];
int ans;

void solve () {
    re(i, n) vec[i].clear(), f[i] = i, g[i] = 0;
    re(i, n) {
        vec[find(i)].push_back(i);
    }
    re(i, n) {
        int sz = vec[i].size(); 
        if(!sz) continue;
        if(sz == n) return ;
        for(int u : vec[i]) { 
            nx(j, u) {
                int v = e[j].to;
                ++vis[v];
            }
        }
        int res = -1;
        re(j, n) {
            if(find(j) == i) continue;
            if(vis[j] == sz) continue ;
            res = find(j);
            break;
        }
        f[i] = res;
        if(res == -1) {
            re(j, n) {
                if(find(j) == i) continue;
                res = find(j);
                break;
            }
            f[i] = res;
            g[i] = 1;
        }
        for(int u : vec[i]) { 
            nx(j, u) {
                int v = e[j].to;
                vis[v] = 0;
            }
        }
    }
    re(i, n) {  
        if(find(f[i]) == find(i)) continue;
        fath[find(i)] = find(f[i]);
        ans += g[i];
    } 
    solve();
}

int main () {
    scanf("%d %d", &n, &m);
    re(i, m) {
        scanf("%d %d", &u, &v);
        add(u, v), add(v, u);
    }
    re(i, n) fath[i] = i;
    solve();
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：BqtMtsZDnlpsT (赞：1)

先 %wcr，反正我是想不到这么好的做法。

看题解区没有我的做法，就来一发。

题解：

考虑普里姆算法的过程，每次将距离已选点最近的点加入已选集合，并加上距离。

在本题中，你会发现，在普里姆算法的过程中，如果当前点 $u$ 更新到某个未加入集合的点 $v$，且 $u,v$ 之间的边权为 0，那么 $v$ 一定可以以 0 的边权直接加入最小生成树。

然后我们就可以在普里姆的过程中维护一个 `std::set`，表示当前边权为与已选点的距离为 1 的集合，记为 $S$。

对于一个队首的点 $u$ 记录与它距离为 1 且未访问过的点，并把 $S$ 中未被记录（即距离为 0）的点直接入队，并从 $S$ 中删除。

具体的，可以搞一个 `std::set` $T$ 记录与它距离为 1 且未访问过的点，在 $S$ 中删除 $T$ 中所有元素，并把剩余元素以 0 的边权入队，最后把 $S$ 赋为 $T$。

代码：
```cpp
struct N{
	int s,id;
	inline bool operator<(const N&U)const{
		return s>U.s;
	}
};
priority_queue<N>q;//堆优普里姆，其实可以不用堆
int n,m,cnt,hd[100005],ans;
struct E{
	int nxt,to;
}e[200005];
inline void add(int u,int v){
	e[++cnt]={hd[u],v};
	hd[u]=cnt;
}
int dis[100005];bool vis[100005];
set<int>s,t;//对应上文 S,T
void prim(){
	//普里姆都会吧。
	//先默认 1 号点已经加入最小生成树，并把与 1 号点距离为 1 的点放入集合
	for(int i=hd[1];i;i=e[i].nxt)dis[e[i].to]=1,s.insert(e[i].to);
	//把初始点对应边权放入集合
	for(int i=1;i<=n;i++)q.push({dis[i],i});
	while(!q.empty()){//基本普里姆算法不讲
		int u=q.top().id;q.pop();
		if(vis[u])continue;
		vis[u]=1;ans+=dis[u];
		t=set<int>();
		for(int i=hd[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(vis[v])continue;
			t.insert(v);
		}
		//按上文操作把距离为 0 的放入集合
		for(auto i:t)s.erase(i);
		for(auto i:s)q.push({0,i}),dis[i]=0;
		s=t;
	}
}
```

复杂度：在每条 1 边上都会有 `insert`，堆的 `push` 次数是 $O(n)$ 级别的，总复杂度是 $O(m\log n)$。

---

## 作者：thjkhdf12 (赞：1)

## 官方题解中的DSU（并查集）做法

看到很多人都用了优化的暴力搜索去AC这道题而题解中没有官方题解的DSU（也就是并查集，DSU高大上），所以我就写了这样一篇~~很烂~~的题解。。

首先直接跑最小生成树是必然超时的，完全图肯定不会使用$kruskal$算法而会使用$prim$算法，时间复杂度为$O(|E|log|V|)$，而$|E|$是$2^{10^5}$……不用想下去了，肯定超时，那么就考虑其它做法

首先考虑既然是完全图，其中一部分边权为$1$，其它边权为$0$，那么构造最小生成树就必然是优先选$0$的边，所以这样的话如果有两个点，如果之间只有$1$边，那么就至少要用$1$的边权来使他们相连，而拓展到两个不考虑$1$边情况下的联通分量，那么连通一条$1$边便可将这两个联通分量连在一起，变为一个联通分量。

所以这就转化成了一个求联通分量数量的题目，既然是联通分量的数量，那自然就要考虑到使用并查集来处理，如果两个联通分量之间有$0$边，那么就对这两个联通分量点集执行$merge$操作，所以写出如下代码

```cpp
#include<iostream>
#include<set>
#include<map>
using namespace std;
 
const int maxn = 100010;
int fa[maxn];
bool vis[maxn];
map<int, bool>isfa;
 
int find(int x)
{
	if (fa[x] == x) return x;
	fa[x] = find(fa[x]);
	return fa[x];
}
 
void merge(int a, int b)
{
	fa[find(a)] = find(b);
}
 
bool check(int a, int b)
{
	return find(a) == find(b);
}
 
set<int>e[maxn];
 
int main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) fa[i] = i;
	for (int i = 1; i <= m; i++)
	{
		int a, b;
		cin >> a >> b;
		e[a].insert(b);
		e[b].insert(a);
	}
	for (int i = 1; i <= n; i++)
	{
		if (vis[i]) continue;
		for (int j = 1; j <= n; j++)
		{
			if (e[i].count(j) || check(i, j)) continue;
			merge(i, j);
			vis[j] = true;
		}
	}
	for (int i = 1; i <= n; i++)
	{
		isfa[find(i)] = true;
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (isfa[i]) ans++;
	}
	cout << ans - 1 << endl;
}
```

但是这份代码却是~~显然~~不能$AC$的，一定会$WA$在第$13$个测试点上，考虑一下原因，如果存在这样的一个图（图中的边为$0$边)

![](https://cdn.luogu.com.cn/upload/image_hosting/4fi7tk81.png)

那么计算过程中就会出现。。$6$访问过了。。$1,2,3,6$构成的集合和$4,5$构成的连不上了。。。然后就输出了一个$1$，然而正确答案应该是$0$，而不加$vis$判断（出现正二八经的$n^2$）又会$TLE$。。。

所以考虑顺序扫描，每个节点只扫一遍，对于每个节点，计算其与每个已存在集合中的点的$1$边有多少条，如果这个$1$边数量小于这个已存在集合中的点数，那就说明存在相连的$0$边（因为根据题意没有重边存在），那就可以加入这个集合，从而将联通分量数量正确的在$O(m+nlogn)$时间复杂度内求出（$m$是读取所有边和遍历所有$1$边的时间复杂度$nlogn$是顺序遍历$n$个节点的循环中使用并查集操作（并查集自然$logn$）的时间复杂度

$AC$代码：

时间复杂度为$O(m+nlogn)$

搜索做法（$bfs$和$dfs$都一样）也已包含在代码注释中

顺带说明一下for(auto it:(vector/set/map))这种写法，相当于遍历其中每一个元素，**注意it是元素而非迭代器**

```cpp
#include<iostream>
#include<set>
#include<map>
#include<queue>
#include<algorithm>
using namespace std;

const int maxn = 100010;
int n, m;
set<int>e[maxn];	//储存1边
set<int>node;	//搜索做法用的set
int fa[maxn];	//并查集fa数组
int sz[maxn];	//sz[i]表示以i为根节点的集合中有多少个点（如果i不是根节点那么sz[i]将不再有意义）

int find(int x)	//已经运用路径压缩
{
	if (fa[x] == x) return x;
	fa[x] = find(fa[x]);
	return fa[x];
}

void merge(int a, int b)
{
	//合并，并计算出合并后的集合包含的节点数量
	int fx = find(a);
	int fy = find(b);
	fa[fx] = find(fy);
	sz[fy] += sz[fx];
}

bool check(int a, int b)
{
	return find(a) == find(b);
}

void dfs(int x)
{
	set<int>reach;
	for (auto it : node)
	{
		if (e[x].find(it) == e[x].end())
		{
			reach.insert(it);
		}
	}
	for (auto it : reach)
	{
		node.erase(it);
	}
	for (auto it : reach)
	{
		dfs(it);
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		fa[i] = i;
		node.insert(i);
	}
	for (int i = 1; i <= m; i++)
	{
		int a, b;
		cin >> a >> b;
		e[a].insert(b);
		e[b].insert(a);
	}
	/*
	//dfs做法，bfs也差不多
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (node.find(i) != node.end())
		{
			dfs(i);
			ans++;
		}
	}
	*/
	//正解：并查集
	vector<int>g;	//并查集根节点集合
	for (int i = 1; i <= n; i++)
	{
		sz[i] = 1;	//初始化当前点所在集合的点数为1
		map<int, int>cnt;	//当前点与已有的每个集合的0边数量
		for (auto it : e[i])
		{
			if (it >= i) continue;	//处理前i个节点（后面的还没遍历到，无需统计，小优化，统计了也不影响结果）
			cnt[find(it)]++;	//统计与it所在的集合有几条1边相连
		}
		for (auto it : g)
		{
			int t = find(it);	//可能这个点已经不是根节点，被合并了
			if (check(i, t)) continue;	//i已经在it所在的集合中
			if (sz[t] > cnt[t])	//如果i与it所在集合相连的0边数量小于it所在集合的节点数量
			{
				merge(i, t);	//合并，将i加入t的集合
			}
		}
		int fi = find(i);
		if (fi == i) g.push_back(fi);	//如果i自己是根节点（即没有满足条件的已存在集合）
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (fa[i] == i) ans++;	//统计根节点数量（集合数量）
	}
	cout << ans - 1;
	return 0;
}
```

---

## 作者：氧少Kevin (赞：0)

# CF1243D - 0-1 MST
- https://www.luogu.com.cn/problem/CF1242B
- 根号思想暴力

## 题意
给出一张有 $n(1\leq n\leq 10^5)$ 个点的完全图，边权均为 $0$。再给出 $m(0\leq m\leq \min(\frac{n\cdot (n-1)}{2},10^5))$ 条边，现标记这 $m$ 条边的边权为 $1$。

问这张图的最小生成树的权值加和。

## 思路
完全图是稠密图。当 $n$ 较大时，给出的边的数量是相对于总边数是很少的。

最终图的形态是 $x$ 个连通块，那么最终的答案就是 $x-1$。

对于一个点而言，如果将其与其他点完全隔离，单独形成一个连通块，需要的边数是 $n-1$。

接下来考虑一种极端情况，当 $n=\sqrt{m}$ 时，每一个点都形成了单独的连通块，此时的连通块数量最多，极端情况下连通块数量不超过 $320$ 个。

暴力搜索即可。

## 实现

用 $\tt std::set$ 维护给出的边。

用 $\tt std::set$ 维护剩余没有寻找过的点。

搜索的过程中，枚举与当前点 $u$ 直接相连的点 $v$，并且保证边 $u\leftrightarrow v$ 不在给出的边集中。

从剩余没有寻找过的点集中删去 $v$，接着搜索 $v$。

---


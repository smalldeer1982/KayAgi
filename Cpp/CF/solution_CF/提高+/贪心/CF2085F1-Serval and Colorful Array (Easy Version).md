# Serval and Colorful Array (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本的区别在于此版本中 $n \leq 3000$。仅当您解决了该问题的所有版本时才能进行 hack。

Serval 有一个魔法数 $k$（$k \geq 2$）。我们称数组 $r$ 为 colorful 当且仅当：
- $r$ 的长度为 $k$，且
- $1$ 到 $k$ 之间的每个整数在 $r$ 中恰好出现一次。

给定一个由 $n$ 个介于 $1$ 到 $k$ 的整数组成的数组 $a$。保证 $1$ 到 $k$ 之间的每个整数在 $a$ 中至少出现一次。您可以对 $a$ 执行以下操作：
- 选择一个下标 $i$（$1 \leq i < n$），然后交换 $a_i$ 和 $a_{i+1}$。

求使得 $a$ 中至少存在一个 colorful 子数组$^{\text{∗}}$所需的最小操作次数。可以证明在题目约束下这总是可行的。

$^{\text{∗}}$数组 $b$ 是数组 $a$ 的子数组，当且仅当 $b$ 可以通过从 $a$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 说明/提示

第一个测试案例中，由于子数组 $[a_1, a_2] = [1, 2]$ 和 $[a_2, a_3] = [2, 1]$ 已经是 colorful 的，因此无需执行任何操作。答案为 $0$。

第二个测试案例中，我们可以交换 $a_1$ 和 $a_2$ 得到 $[1, \underline{2, 1, 3}, 1, 1, 2]$，其中包含一个 colorful 子数组 $[a_2, a_3, a_4] = [2, 1, 3]$。由于原数组初始时没有 colorful 子数组，因此答案为 $1$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
3 2
1 2 1
7 3
2 1 1 3 1 1 2
6 3
1 1 2 2 2 3
6 3
1 2 2 2 2 3
10 5
5 1 3 1 1 2 2 4 1 3
9 4
1 2 3 3 3 3 3 2 4```

### 输出

```
0
1
2
3
4
5```

# 题解

## 作者：donaldqian (赞：2)

## 题意
给定一个长为 $n$ 的数组 $a$，且 $a_i\isin[1,k]$。\
问至少需要交换多少次相邻两项，才能使 $a$ 存在一个长为 $k$ 的子段是 $1$ 到 $k$ 的排列。\
$k\le n\le 4\times 10^5$，且保证 $[1,k]$ 内的每个数字都在 $a$ 中出现过。\
这篇题解是 [官方题解](https://codeforces.com/blog/entry/140933) 做法。
## 弱化版做法
考虑 $k\le n\le 3000$ 时怎么做。

假设我们选出了一些位置，这些位置上的数构成了一个 $1$ 到 $k$ 的排列。现在我们希望用最少的交换次数，让这些数形成一个子段（靠拢起来）。显然，我们会让两边的数向中间靠拢，中间的数（也就是第 $\frac{k}{2}$ 个数）不动。

那么我们考虑枚举中间的数（也就是区间中点）在哪里，假设当前枚举到的点是 $pos$。那么相当于我们要在 $[1,pos-1]$ 里选 $\frac{k}{2}$ 个点，$[pos+1,n]$ 里选 $\frac{k}{2}$ 个点，且这些点的值两两不同，最小化每个点到 $pos$ 的距离的和。

我们设 $l_i$ 表示 $pos$ 往左扫第一个 $i$ 的位置，$r_i$ 表示 $pos$ 往右扫第一个 $i$ 的位置，问题转化成了：对于每个 $1\le x\le k$ 选择 $l_x$ 或 $r_x$，要求最后一共选 $\frac{k}{2}$ 个 $l_i$，$\frac{k}{2}$ 个 $r_i$，最小化选择的数的和。这个问题可以如下解决：设 $c_i=r_i-l_i$，将 $c$ 数组从小到大排序，答案即为 $\sum\limits_{i=1}^k l_i+\sum\limits_{i=1}^{\frac{k}{2}}c_i$。

显然对于每个 $pos$，$l$ 数组和 $r$ 数组都是可以 $\varTheta(n)$ 计算的，瓶颈在每次对 $c$ 排序，最终复杂度 $\varTheta(n^2\log n)$。

到这里已经可以过掉此题了，下面是强化版题解。~~其实是因为不想写弱化版代码了~~
## 正解
观察上面的思路：
>我们要在 $[1,pos-1]$ 里选 $\frac{k}{2}$ 个点，$[pos+1,n]$ 里选 $\frac{k}{2}$ 个点，且这些点的值两两不同，最小化每个点到 $pos$ 的距离的和。

能不能将左右两边各取 $\frac{k}{2}$ 个点的限制去掉？可以的。
> 正确性证明：假设用这种方法求出的答案是 $res$，正确答案是 $ans$。首先因为左右分配不均时，答案一定不会更优，所以 $res\ge ans$。其次，我们考虑取到 $ans$ 时的最优策略，它一定会在区间中点处被 $res$ 考虑到，所以 $res\le ans$，证毕。

所以假设我们还是枚举 $pos$，算出 $l_i$ 和 $r_i$，这时候的答案就变成了 $\sum\limits_{i=1}^k \min(l_i,r_i)$，至此我们得到了一个 $\varTheta(n^2)$ 做法。

为了方便，以下记 $val_i=\min(l_i,r_i)$。发现此时瓶颈在于如何计算 $val_i$。我们发现，从 $pos$ 到 $pos+1$ 的过程中，$val_i$ 的变化只有可能是 $0,1,-1$，这是非常优秀的。

那么我们考虑对于每个 $1\le i\le k$ 计算出 $i$ 对所有 $pos$ 的贡献。每次看一下 $val$ 的变化量是几即可，复杂度 $\varTheta(nk)$。然后我们又发现可以二维差分一下，然后就做完了，时间复杂度 $\varTheta(n)$。

[代码](https://codeforces.com/contest/2085/submission/312140884)。

---

## 作者：kanglr1013 (赞：1)

## Serval and Colorful Array (Easy Version)

### 题意

Serval 有一个魔法数字 $k$（$k \geq 2$）。我们称一个数组 $r$ 是 **colorful** 当且仅当：

- 数组 $r$ 的长度恰好为 $k$，且
- $1$ 到 $k$ 之间的每个整数在 $r$ 中**恰好出现一次**

给定一个由 $n$ 个整数组成的数组 $a$，其中每个元素都在 $1$ 到 $k$ 之间。题目保证 $1$ 到 $k$ 中的每个数字在 $a$ 中至少出现一次。你可以对数组 $a$ 进行如下操作：

- 选择下标 $i$（$1 \leq i < n$），然后交换 $a_i$ 和 $a_{i+1}$ 的值

要求计算出使得数组 $a$ 中至少存在一个 **colorful** 子数组所需的最少操作次数。可以证明在题目约束条件下，这总是可以实现的。

> *注：子数组是指数组中连续的元素序列

在这个版本中，$2 \le k \le n \le 3000$，$1 \le a_i \le k$。

---

### 思路

根据数据范围，可以想到最终复杂度会是一个 $\mathcal{O}(n^2)$ 或者 $\mathcal{O}(n^2 \log n)$ 级别的。
$$
\fbox{5}, 1, \fbox{3}, 1, \fbox{1}, 2, \fbox{2}, \fbox{4}, 1, 3
$$
假设我们选择了框住的数作为最终子序列的数，考虑如何计算最小的代价，也就是最小交换次数。

根据初中数学知识可以知道，当我们选择**中间**的数作为不动点的时候，代价一定是最小的。与此同时，我们可以注意到使标记元素连续所需的最小交换次数是「交换前每个标记元素到中间位置的距离之和」与「交换后该距离之和」的差值，其中「交换后该距离之和」显然是一个定值，我们可以放到最后来处理。

这样，我们就可以很自然的想到从 $1 \sim n$ 对不动点进行枚举。

因为不动点同时又是中间点，因此我们需要在其左边选择 $\frac{k}{2}$ 个数，在右边选择 $\frac{k}{2}$ 个数。（向上和向下取整无关紧要）

对于每一个 $1 \le i \le k$，我们需要确定其是应当从左侧还是右侧进行选择。不妨设当前枚举的不动点为 $p$，$l_i$，$r_i$ 分别表示 $i$ 这个数在左或右侧到 $p$ 的最短距离。为了满足上面的条件，一个聪明的贪心想法是我们钦定对于每一个 $i$ 全部选择左侧，记和为 $s$，同时记 $\Delta_i = r_i - l_i$，对 $\Delta$ 数组进行排序，然后我们从中从小到大选择 $\frac{k}{2}$ 个加入到 $s$ 里面即可。这样，对于不动点 $p$ 一定是最优的。

总时间复杂度 $\mathcal{O}(n^2 \log n)$，可以过 $n \le 3000$。

代码并不难实现，细节也不多，就不放了。

---

## 作者：incra (赞：0)

### Sol
下文中答案表示 $k$ 个点到某个中心的距离之和，真正的答案需要减去 $\displaystyle\sum_{i=1}^n\left|i-\left\lfloor\frac{k+1}{2}\right\rfloor\right|$。

考虑 F1 做法，假设选定一个点在 $i$，并且以这个点为中心，$i$ 左边第一个颜色为 $j$ 的位置到 $i$ 的距离为 $l_j$，右边第一个颜色为 $j$ 的到 $i$ 的距离为 $r_j$。

此时最优方案一定是 $i$ 两侧 $l_j$ 和 $r_j$ 各选一半。

令 $c_j=r_j-l_j$，将 $c$ 排序后答案就是 $\displaystyle\sum_{i=1}^nl_j+\sum_{i=1}^{\left\lfloor\frac{k+1}{2}\right\rfloor}c_j$。

时间复杂度：$O(n^2)$。

引理：不用考虑在 $i$ 两侧各选一半 $l_j$ 和 $r_j$，一定能统计到最优解。

证明：由仓库选址问题可知如果选的中心不在正中间那么答案一定不优，且该方案一定能统计到最优解。

那么事情就变得简单了，答案变成了 $\displaystyle\sum_{i=1}^n\min(l_i,r_i)$，感觉还是不太好做，对于每一个 $\min(l_i,r_i)$ 观察可得每当 $i$ 加上 $1$，$\min(l_i,r_i)$ 变化的绝对值不超过 $1$，观察变化规律可以发现每次都是区间加一个等差数列，也就是一个二维差分，那么就做完了。

时间复杂度：$O(n^2)$。
### Code
[F1](https://codeforces.com/contest/2085/submission/314694337)。

[F2](https://codeforces.com/contest/2085/submission/314696130)。

---


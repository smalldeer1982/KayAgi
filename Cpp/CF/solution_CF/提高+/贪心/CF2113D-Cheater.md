# Cheater

## 题目描述

你正在赌场玩一种新的纸牌游戏，规则如下：

1. 游戏使用一副共 $2n$ 张不同点数的牌。
2. 牌堆被均匀分给玩家和庄家：每人获得 $n$ 张牌。
3. 在 $n$ 轮比赛中，玩家和庄家同时打出手中最上面的一张牌。比较两张牌的点数，点数较大的一方获得 $1$ 分。获胜的牌会被移出游戏，而失败的牌会返回持有者的手牌，并放在该玩家手牌堆的最上面。

注意游戏总是会进行恰好 $n$ 轮。

你已经追踪了洗牌过程，知道庄家手牌的从上到下的顺序。为了最大化你的得分，你可以在游戏开始前交换手中任意两张牌的位置（最多交换一次以避免引起怀疑）。

请确定你能获得的最大分数。

## 说明/提示

在第一个测试用例中，可以不交换任何牌。游戏过程如下：

1. 比较点数为 $13$ 和 $6$ 的牌。玩家获胜，得 $1$ 分。
2. 比较点数为 $7$ 和 $6$ 的牌。玩家获胜，得 $1$ 分。
3. 比较点数为 $4$ 和 $6$ 的牌。庄家获胜。
4. 比较点数为 $4$ 和 $1$ 的牌。玩家获胜，得 $1$ 分。
5. 比较点数为 $9$ 和 $1$ 的牌。玩家获胜，得 $1$ 分。
6. 比较点数为 $12$ 和 $1$ 的牌。玩家获胜，得 $1$ 分。
7. 比较点数为 $10$ 和 $1$ 的牌。玩家获胜，得 $1$ 分。

因此玩家总共获得 $6$ 分。

在第二个测试用例中，可以交换点数为 $1$ 和 $5$ 的牌，交换后玩家手牌变为 $[5, 6, 1]$。游戏过程如下：

1. 比较点数为 $5$ 和 $2$ 的牌。玩家获胜，得 $1$ 分。
2. 比较点数为 $6$ 和 $2$ 的牌。玩家获胜，得 $1$ 分。
3. 比较点数为 $1$ 和 $2$ 的牌。庄家获胜。

因此玩家总共获得 $2$ 分。

在第三个测试用例中，可以交换点数为 $3$ 和 $10$ 的牌，交换后玩家手牌变为 $[8, 6, 10, 3, 1]$。游戏过程如下：

1. 比较点数为 $8$ 和 $7$ 的牌。玩家获胜，得$1$分。
2. 比较点数为 $6$ 和 $7$ 的牌。庄家获胜。
3. 比较点数为 $6$ 和 $9$ 的牌。庄家获胜。
4. 比较点数为 $6$ 和 $5$ 的牌。玩家获胜，得 $1$ 分。
5. 比较点数为 $10$ 和 $5 $的牌。玩家获胜，得 $1$ 分。

因此玩家总共获得 $3$ 分。

## 样例 #1

### 输入

```
3
7
13 7 4 9 12 10 2
6 1 14 3 8 5 11
3
1 6 5
2 3 4
5
8 6 3 10 1
7 9 5 2 4```

### 输出

```
6
2
3```

# 题解

## 作者：chenly8128 (赞：4)

简单的 D 题，难度虚高。

### 题解

由题意得，赢一次相当于打出一张牌。输了打不出牌。打出了几张牌就等于赢了几场。

首先考虑如何判断赢 $x$ 场是否能做到。此时我方前 $x$ 张牌应该都要打掉、敌方不能打出超过 $n-x$ 张牌。接着考虑：

- 如果敌方的前 $n-x+1$ 张牌当中最小的小于我方前 $x$ 张牌中最小的，那么很明显，我方的前 $x$ 张牌自然都能打掉。
- 否则，我方前 $x$ 张中的最小的一定无法打出。所以无法做到赢 $x$ 张。

所以我们需要做的就是判断：**通过至多一次交换，能否使敌方的前 $n-x+1$ 张牌当中最小的小于我方前 $x$ 张牌中最小的。**

因此我们可以预处理出我方牌的前 $x$ 张最小的（记为 $f_1$）和次小的（记为 $f_2$）、我方牌后 $n-x$ 张最大的（记为 $e$）。通过至多一次交换，能使得我方前 $x$ 张牌中最小的最大为 $\max(f1,\min(f2,e))$。

把这玩意儿和对手牌中前 $n-x+1$ 张中最小的比一比（也要预处理），就能得出是否可行。

最后，只需要从大到小枚举 $x$ 判断是否可行，第一个可行的 $x$ 就是答案。

### 代码


```cpp

// Author: chenly8128
// Created: 2025-06-15 17:47:57

#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5+10;
inline int read(void) {
    int res = 0;bool flag = true;char c = getchar();
    while (c < '0' || c > '9') {flag ^= (c == '-');c = getchar();}
    while (c >= '0' && c <= '9') {res = (res << 3) + (res << 1) + (c ^ 48);c = getchar();}
    return flag ? res : -res;
}
int kase,n;
int a[MAXN],b[MAXN];
int m1[MAXN],m2[MAXN],m3[MAXN],ma[MAXN];
int main (void) {
	scanf ("%d",&kase);
	while (kase--) {
		scanf ("%d",&n);
		m1[0] = m2[0] = m3[0] = 0x3f3f3f3f;
		m3[n+1] = -0x3f3f3f3f;
		ma[n+1] = -0x3f3f3f3f;
		for (int i = 1;i <= n;i++) {
			a[i] = read();
			m1[i] = m1[i-1];
			m2[i] = m2[i-1];
			if (m1[i] > a[i]) {
				m2[i] = m1[i];
				m1[i] = a[i];
			}
			else if (m2[i] > a[i]) m2[i] = a[i];
		}
		for (int i = n;i >= 1;i--) ma[i] = max(ma[i+1],a[i]);
		for (int i = 1;i <= n;i++) m3[i] = min(m3[i-1],b[i] = read());
		for (int ans = n;ans >= 0;ans--)
			if (max(m1[ans],min(m2[ans],ma[ans+1])) > m3[n-ans+1]) {
				printf ("%d\n",ans);
				break;
			}
	}
	return 0;
}
```

---

## 作者：Cuiyi_SAI (赞：3)

## Solution

线性做法。

如果没有交换操作，如何快速判断玩家是否能**至少**拿到 $x$ 的积分？结论：若玩家手牌前 $x$ 个的最小值（称为 $u$）大于对手手牌前 $n-x+1$ 个的最小值（称为 $v$）则玩家至少可获得 $x$ 分。   
为什么？以下是证明。
- 当 $u>v$ 时，即玩家手牌前 $x$ 张牌每一个都大于对手的牌 $v$。因此，当对手的牌堆顶部是 $v$ 时，玩家一定能一口气将至少前 $x$ 张牌打完，且所用的总轮数不会超过 $n$，因为在这之前玩家最多输 $n-x$ 次牌。所以玩家至少能拿到 $x$ 分。
- 当 $u<v$ 时，即玩家的牌 $u$ 小于对手前 $n-x+1$ 手牌的每一张牌。此时若玩家想用 $u$ 赢一次，那么必定要消耗掉对手的前 $n-x+1$ 牌才有可能，而此时又因为轮数限制为 $n$ 轮，故玩家肯定拿不到 $x$ 分。

因此我们发现，玩家能拿多少分**仅取决于**两人牌堆的前缀最小值，只需要考虑这两个值即可。

此时再考虑交换操作就容易很多了。我们显然要贪心地让玩家的前缀最小值尽量大，于是就可以把前缀之外，那些玩家用不到的牌里找一张最大的拿过来替换掉原本的最小值即可。

实现就是线性扫一遍，动态更新交换后的前缀最小值（这里需要多维护一个前缀次小值）。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n,a[200010],b[200010];
int mb[200010],mxa[200010];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>T;
    int cnt=0;
    while(T--){
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        for(int i=1;i<=n;i++) cin>>b[i];
        mb[0]=1e9,mxa[n+1]=0;
        for(int i=1;i<=n;i++) mb[i]=min(mb[i-1],b[i]);
        for(int i=n;i>=1;i--) mxa[i]=max(mxa[i+1],a[i]);
        int ans=0,ma=1e9,mma=1e9;
        for(int x=1;x<=n;x++){
            if(ma>a[x]) mma=ma,ma=a[x];
            else if(mma>a[x]) mma=a[x];
            if(min(max(mxa[x+1],ma),mma)<mb[n-x+1]) break;
            ans=x;
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：zhangbo1000 (赞：2)

由于不确定换那张牌，无法简单高效直接计算得分，考虑二分答案，转化成判定性问题：我们能否通过换一次牌使得得分不小于 $x$。

因为负者会保留牌，所以如果我方的前 $x$ 张牌的最小值小于对方前 $n-x+1$ 张牌的最小值，那么我们会在拿到这张牌后无法出牌，直到结束；反之，对方会在拿到最小值后无法出牌知道结束。

那问题其实就变成了：能否换一次牌，使得我方前 $x$ 张牌的最小值大于对方前 $x$ 张牌的最小值。

通过维护前缀最小，前缀次小，后缀最大（用来换），可以 $O(1)$ 完成判定。

因为判定是 $O(1)$，而预处理是 $O(n)$ 的，所以我们可以简单地枚举答案而不必二分。

[代码和评测记录。](https://codeforces.com/contest/2113/submission/327027038)

---

## 作者：linjunye (赞：1)

如果想要真正靠推导做出这道题，那么还是不容易的。

下面我就来推导一下这道题的完整思路。

我们肯定想把玩牌的过程转移到数列上：有两个指针 $i$ 和 $j$，初始均为 $1$。比较 $a_i$ 和 $b_j$ 的大小，如果 $a_i>b_j$，那么 $i$ 向右移，玩家得一分。否则 $j$ 向右移，庄家得一分。

**提示一：每一轮输掉的牌的值有什么变化？**

首先我们能发现一个性质：我们令本次输掉的牌所表示的数（即 $a_i$ 和 $b_j$ 的最小值）为 $k$，那么 $k$ 肯定是单调不递增的。这个很好理解，因为如果上一轮的输掉的牌想在下一轮获胜，当且仅当有一个比它小的牌出来了，而那张牌又会继续这么操作。所以每一轮输掉的牌的值是不递增的。

这个有什么用呢？不要急！

我们发现好像卡住了。于是仔细阅读题面，发现游戏总是恰好执行 $n$ 轮。

为什么一定要执行 $n$ 轮？为什么不是两者中一方打完了才算结束？这个“恰好执行 $n$ 轮”引导着我们的思考。

**提示二：如果恰好执行 $n$ 轮，那么我们是不是可以设先手出了 $i$ 张牌，然后找规律？**

首先有一个显然的东西：当游戏结束时，玩家正好出完 $i$ 张牌，那么庄家就出完了 $n-i$ 张牌。玩家出的牌对应着 $a_1$ 到 $a_i$，庄家出的牌对应着 $b_1$ 到 $b_{n-i}$。然后玩家的下一张牌是 $a_{i+1}$，庄家的下一张牌是 $b_{n-i+1}$。

这样还不够直观。我们假设玩家要赢得 $i$ 分，那么玩家要出够 $i$ 张牌。

**提示三：能不能利用上面的性质？最后输掉的牌的值有什么规律吗？**

这个时候我们好像就可以利用上面发现的性质了！

我们发现每一轮输掉的牌的值是不递增的，所以最后输掉的牌肯定是 $a_{1}$ 至 $a_{i}$，$b_{1}$ 至 $b_{n-i}$ 的最小值。我们发现这个最小值在这种条件下，它肯定是一直输的。那么如果玩家想得到 $i$ 分，那么最小值一定要在庄家那边！

然后我们发现，庄家可能要出的牌是 $b_1$ 至 $b_{n-i+1}$（因为如果 $n-i$ 张牌都打完后，玩家就要靠庄家的第 $n-i+1$ 张牌决定自己的命运了）。我们令 $a_1$ 至 $a_i$ 的最小值为 $x$，$b_1$ 至 $b_{n-i+1}$ 的最小值为 $y$。那么如果先手想要得到 $i$ 分，当且仅当 $x>y$。

**提示四：随着 $i$ 的增大，$x$ 和 $y$ 有什么变化？如果有，那么就可以干什么了？**

我们发现，随着 $i$ 的增大，$x$ 会越来越小，而 $y$ 会越来越大，那么玩家就可能越来越不太可能得到 $i$ 分。

这满足单调性！

我们可以二分先手获得的分数。

但还有一个问题：先手可以交换自己的两张牌。那么如果想交换，我们肯定是要将左边的最小值替代成一个比他大的值，这样才可以使得 $x$ 变大，才有获胜的可能。容易证明即使是这样的操作之后，我们依然满足单调性（即随着 $i$ 的增大，玩家能获得 $i$ 分的可能性越低）。

或许你还不会证明。没关系，我来解释一下：首先替代后的最小值肯定是原来的次小值（如果能替代的话）。那么 $i$ 的增大，次小值会越来越小，但是 $y$ 还是越来越大。因此玩家也就可能越来越不太可能得到 $i$ 分。或者说替换后的数还是现在的最小值，那么同理。

最后考虑一个细节：如果不能替代，那么就不要交换。

为了方便，我们肯定是将前缀最小值和后缀最大值交换，因为这样可以成功交换的可能性最大。当然按照常规写法应该也是可以的。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1000010;
const int mod=998244353;
const int INF=0x3f3f3f3f3f3f3f3f;
int n;
int a[N];
int b[N];
bool check(int r){
	int x=0,y=0;
	int mn=INF,mx=-INF;
	for(int i=1;i<=r;i++){
		if(a[i]<mn){
			mn=a[i];
			x=i;
		}
	}
	for(int i=r+1;i<=n;i++){
		if(a[i]>mx){
			mx=a[i];
			y=i;
		}
	}
    bool fl=0;
	if(x&&y&&mx>mn){//注意mx>mn的细节（还要考虑能否找到最大、最小值）
        fl=1;//满足交换条件
        swap(a[x],a[y]);
    }
	mn=INF;
	for(int i=1;i<=r;i++)mn=min(mn,a[i]);
	int mn2=INF;
	for(int i=1;i<=n-r+1;i++)mn2=min(mn2,b[i]);
	bool f=(mn>=mn2);//判断
	if(fl)swap(a[x],a[y]);//换回来
	return f;
}
void solve(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	int l=1,r=n,mid;
	int ans=0;
	while(l<=r){//二分
		mid=(l+r)>>1;
		if(check(mid)){
			ans=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	cout<<ans<<"\n";
	return;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T=1;
	cin>>T;
	while(T--)solve();
	return 0;
}
/*
考虑能拿到i分，当且仅当min{a[1...i]}>=min{b[1...n-i+1]}
显然i变大时，左边会变小，右边会变大
那么可以二分
然后前缀最小值和后缀最大值换位置
*/
```

这样我们就将这道题做完了。我认为最难的就是针对“恰好打 $n$ 轮”的思考。有时候就是题目中一个不太起眼的句子，反而是解出题目的关键。这才是我们应该去学习的。

不管怎样，加油吧……

---

## 作者：Air2011 (赞：0)

### 背景

赛时左右脑互博 $1$ 小时后才过 B，遂直接看了 D。

---

### 题意

两个人在玩游戏，每个人有 $n$ 张写有不同数字的牌，每个人都按顺序出牌，数字大的那一方赢，然后打出下一张牌并继续于另外一人的牌比较，**比较一共进行 $n$ 轮**，问现在有一个人能交换两张自己的牌，最多一次，问这个人能获得的最大分数。

### 思路

我们注意到一共只会比较 $n$ 轮，所以我们可以考虑枚举对方最少能获得多少分，我们假设对手得分 $x$ 分，意味着我方前 $n-x$ 牌必须出完，我们注意到当对手目前的牌为前 $x$ 张的最小牌时，如果我方还没有出不了前 $n-x$ 张牌，那么我方一定无法获得 $n-x$ 分。

证明：对手的最小牌我方都出不了牌，那么对手往后的牌我方也一定出不了。

我们考虑我方那些牌会使我方在对手最小牌时出不了，显然是那些小于对手的最小牌的，于是我们对这一张牌与我们不需要出的牌的最大的牌交换，然后看是否还有我们出不了的牌，体现就是小于对手的最小牌的数量不能大于等于 $2$ 张。

但是直接做复杂度是 $O(n^2)$ 的我们考虑优化。

我们可以二分出来这个 $x$，然后就做完了，复杂度 $O(n \log n)$。

### 代码

```cpp
// Problem: D. Cheater
// Contest: Codeforces - Codeforces Round 1031 (Div. 2)
// URL: https://codeforces.com/contest/2113/problem/D
// Author: Air2011
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define Air
namespace io{
    inline int read(){
        int f=1,t=0;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
        while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}
        return t*f;
    }
    inline void write(int x){
        if(x<0){putchar('-');x=-x;}        
        if(x>=10){write(x/10);}
        putchar(x%10+'0');
    }
}
using namespace io;
int n;
const int N=2e5+10;
int a[N];
int b[N];
bool check(int x){
	int kk=1e18;
	for(int i=1;i<=x+1;i++){
		kk=min(kk,b[i]);
	}
	int cnt=0;
	for(int i=1;i<=n-x;i++){
		if(a[i]<=kk){
			cnt++;
			if(cnt>=2)return 0;
		}
	}
	if(cnt==0){
		return 1;
	}
	int maxx=0;
	for(int i=n-x+1;i<=n;i++){
		maxx=max(maxx,a[i]);
	}
	return maxx>kk;
}
void work(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}	
	for(int j=1;j<=n;j++){
		b[j]=read();
	}
	int l=0,r=n,mid;//让对手拿mid分
	int res=0;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)){
			res=mid;
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	write(n-res);
	putchar('\n');
}
signed main() {
#ifndef Air
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	int TCS=read();
	while(TCS--){
		work();
	}
	return 0;
}
```

---

## 作者：mkx2023275 (赞：0)

首先可以进行二分答案 $mid$，由于总局数为 $n$，所以可以计算当自己出到第 $mid$ 张牌时庄家最少出了多少张牌，再与 $n - mid$ 进行大小判断。

因为自己出牌越多庄家出牌越来越多（保持上一步的策略，每次都新增牌），$n - mid$ 越来越小，因此庄家减去 $n - mid$ 是单调递增的，也就是说这个二分具有单调性（判断两个数大小关系就相当于将两个数做差后判断和 $0$ 的大小关系）。

接下来问题就是如何求庄家最少出牌量。我们模拟这个过程，先不考虑交换的情况。

$$n = 5$$
$$a = [7, 8, 3, 4, 5]$$
$$b = [9, 6, 1, 10, 2]$$

假设 $a$ 和 $b$ 是以上情况，按顺序考虑 $a$ 的每一张牌。先考虑第一张牌 $7$，一定是先有一段 $> 7$ 的前缀一直删除，然后直到 $b$ 的顶牌 $< 7$ 时将 $7$ 删除，继续下一张牌。

$$a = [8, 3, 4, 5]$$
$$b = [6, 1, 10, 2]$$

接下来 $8$，因为之前有一个 $7$ 的牌且已经弹出，$8$ 更大，一定会直接弹出，无需进行多余判断。

$$a = [3, 4, 5]$$
$$b = [6, 1, 10, 2]$$

然后是 $3$，$3$ 之前没有比它小的，只能直接做，$4$ 和 $5$ 类似 $8$ 的做法。

$$a = [\red7, \blue8, \red3, \blue4, \blue5]$$
$$b = [9, 6, 1, 10, 2]$$

容易发现，只有前缀最小值对答案有贡献，每次都取到从上一次结束开始的第一个小于当前数的位置。然后发现这就相当于所有前缀最小值第一个小于当前数的位置的最大值，也就是所有数第一个小于当前数的位置的最大值。由于第一个小于当前数的位置具有单调性，最小的数一定能取到最小的答案。所以就是最大化所有数的最小值。

然后就好做了。将 $mid + 1 \sim n$ 中的最大值和 $1 \sim mid$ 中的最小值进行交换，计算答案即可。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 200010;

int n;
int a[N], b[N];

bool check(int mid)
{
	int minv1 = 2e9, minv2 = 2e9;
	for (int i = 1; i <= mid; i ++ )
	{
		if (a[i] <= minv1) minv2 = minv1, minv1 = a[i];
		else if (a[i] < minv2) minv2 = a[i];
	}
	for (int i = mid + 1; i <= n; i ++ )
		minv1 = max(minv1, a[i]);
	minv1 = min(minv1, minv2);
	for (int i = 1; i <= n - mid + 1; i ++ )
		if (b[i] < minv1)
			return true;
	return false;
}

int main()
{
	int T;
	scanf("%d", &T);
	while (T -- )
	{
		scanf("%d", &n);
		for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]); 
		for (int i = 1; i <= n; i ++ ) scanf("%d", &b[i]);
		int l = 0, r = n;
		while (l < r)
		{
			int mid = l + r + 1 >> 1;
			if (check(mid)) l = mid;
			else r = mid - 1;
		}
		printf("%d\n", r);
	}
	
	return 0;
}
```

---


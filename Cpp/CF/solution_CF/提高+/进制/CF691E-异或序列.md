# 异或序列

## 题目描述

给你 $n,k$，和一个 $n$ 个数的序列 $\{a_i\}_{i=1}^n$。一个序列 $\{x_i\}_{i=1}^k$ 被称作“异或序列”，当且仅当以下两个条件全部满足：

- $\forall i\in[1,k]:x_i\in[1,n]\cap\Z$；
- $\forall i\in[1,k):3\mid\mathrm{popcount}(a_{x_i}\mathbin{\mathrm{xor}} a_{x_{i+1}})$。

求有多少个异或序列，模 $10^9+7$。

**如果 $n=2,k=1,a=[1,1]$，那么答案为 $\red 2$，两个异或序列分别为 $[1],[2]$。**

## 说明/提示

$n\le100,k,a_i\le10^{18}$。

原题表述不够严谨，因此翻译对“异或序列”的定义进行了改动，不影响作答。

## 样例 #1

### 输入

```
5 2
15 1 2 4 8
```

### 输出

```
13
```

## 样例 #2

### 输入

```
5 1
15 1 2 4 8
```

### 输出

```
5
```

# 题解

## 作者：Sharpsmile (赞：6)

很好的一道矩阵加速题。

题目大意:给定集合$A$，一长为$k$的数组$B$中满足：

$
\begin{cases}
\forall i,b_i \in A\\
\forall 1\leq i < k,\operatorname{popcount}(b_i \oplus b_{i+1})|3 \\
\end{cases}
$



求方案数。

这题还是花了点时间的。众所周知$CF$不会给部分分数据范围，但是翻译者比较良心，顺带给了个对于$40\%$的数据$k\leq 10^4$（~~咱也不知道是不是真的~~）。这个数据给了我们提示——可以先想小范围然后优化。

考虑到每个元素的选取条件只与他相邻的有关，所以考虑一下$DP$

我们设$dp_{i,j}$表示$B$数组长度$i$，第$i$个元素是$a_j$的时候的方案数。

因为只有相邻的会限制条件，我们考虑用后面的限制前面的。

对于一个数字$a_j$放在$b_i$这个位置上合法当且仅当$\operatorname{popcount}(a_j\oplus b_i)\ |\ 3$

所以我们有递推式$dp_{i,j}=\sum\limits_{k=1}^{n}dp_{i-1,k}\times [\operatorname{popcount}(a_k\oplus a_j\ | \ 3)]$。

边界就是当$i=1$时，$dp_{i,j}=1$

最后的答案自然就是$\sum \limits_{i=1}^{n} dp[k][i]$

这个方法的复杂度是$O(nklog_2a)$（枚举位置+枚举元素+计算$\operatorname{popcount}$）

到这里我们可以开始优化了。

各位看官有没有发现什么？

我们的$DP$式子长这样

$dp_{i,j}=\sum\limits_{k=1}^{n}dp_{i-1,k}\times [\operatorname{popcount}(a_k\oplus a_j\ | \ 3)]$。

在每一次过程中，对于相同的$j$，不论$i$的取值，能够转移到$j$上的$k$是不变的。

这个时候我们就可以考虑一下矩阵加速了。

我们知道我们的矩阵$C$应该满足：

$\begin{bmatrix}
dp_{i,1}&dp_{i,2}\cdots dp_{i,n}
\end{bmatrix}
\times \begin{bmatrix}
C_{1,1}&\cdots&C_{1,n}\\
\vdots&\ddots&\vdots\\
C_{n,1}&\cdots&C_{n,n}
\end{bmatrix}
=\begin{bmatrix}
dp_{i+1,1}&dp_{i+1,2}\cdots dp_{i+1,n}
\end{bmatrix}$

结合递推式，我们发现$C_{i,j}\in{\{0,1\}}$

结合矩阵乘法的方法我们有$dp_{i+1,j}=\sum\limits_{k=1}^{n}dp_{i,k}\times C_{k,j}=\sum\limits_{k=1}^{n}dp_{i,k}\times [\operatorname{popcount}(a_k\oplus a_j\ | \ 3)]$

于是我们发现$C_{k,j}=[\operatorname{popcount}(a_k\oplus a_j\ | \ 3)]$

于是我们就可以愉快的求出转移矩阵啦。

直接矩阵快速幂加速即可。

捎带$AC$代码一份：

```
#include <bits/stdc++.h>
using namespace std;
inlind re(int &x) {
    x=0;
    bool f=0;
    int w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f = 1;w=getchar();}
    while(w<='9'&&w>='0')x=(x<<3)+(x<<1)+w-'0',w=getchar();
    if(f)x=-x;
}

inlint poc(int x){
    int res=0;
    while(x)res+=x&1,x>>=1;
    return res;
}
const int M=1e9+7;
int a[110];
int ok[110][110];
struct mat{
    int n,m;
    int t[110][110];
    mat operator *(const mat x){
        mat c;
        c.n=n;
        c.m=x.m;
        mem0(c.t);
        if(m!=x.n) return c;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=x.m;j++)
                for(int k=1;k<=m;k++)
                    c.t[i][j]=(c.t[i][j]+t[i][k]*x.t[k][j]%M)%M;
        return c;
    }
    mat unit(){
        mat c;
        c.n=n;
        c.m=n;
        mem0(c.t);
        for(int i=1;i<=n;i++)c.t[i][i]=1;
        return c;
    }
};
mat m_qp(mat a,int x){
    mat ans=a.unit();
    while(x){
        if(x&1)ans=ans*a;
        a=a*a;
        x>>=1;
    }
    return ans;
}
int n,k;
signed main(){
    re(n);
    re(k);
    mat y;
    y.n=y.m=n;
    mem0(y.t);
    mat o;
    o.n=1;
    o.m=n;
    mem0(o.t);
    for(int i=1;i<=n;i++)re(a[i]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(poc(a[i]^a[j])%3==0)y.t[i][j]=1;
          
    for(int i=1;i<=n;i++)o.t[1][i]=1;
    mat op=m_qp(y,k-1);
    o=o*op;

    int ans=0;
    for(int i=1;i<=n;i++)ans+=o.t[1][i],ans%=M;
    cout<<ans;
    return 0;
}
```


---

## 作者：lazytag (赞：3)

### CF691E Xor-sequences

有一种思路，考虑到 $n$ 其实很小，所以可以把异或后的数二进制下只有 3 的倍数个 1 的数字之间连一条边。

答案就是在建出来的图上问有多少条经过点数为 $k$ 的不同路径。

根据题意，若 $\exists i \in [1,k]$ ，使得第 $x,y$ 两条路径中，第 $i$ 个经过的点不同，则称 $x,y$ 这两条路径不同。

没有见过类似的题目，但是我们可以 yy 一波。

先简单写个方程：

$dp_{i,u}$ 表示第以第 $u$ 个点为终点路径长度为 $i$ 的路径有多少条。

$dp_{i,u}=\Sigma_{v|(u,v)\in E}dp_{i-1,v}$。

改下式子，就是：

$dp_{i,u}=M_{u,v}*dp_{i-1,v}$

有矩阵快速幂的味道了。

那么 $dp_{i}=M*dp_{i-1}$ ，其中 $M$ 是一个 $n*n$ 的矩阵，也就是用邻接表存储的图。

现在这道题就做完了。。。

代码：

```c++
typedef long long ll;
const int N=105,mo=1e9+7;
int n;
ll K,a[N],ans=0;
struct Matrix_M{
	ll x[N][N];
	Matrix_M(){memset(x,0,sizeof(x));}
	void pre(){
		memset(x,0,sizeof(x));
		for(int i=1;i<=n;++i)
			x[i][i]=1;
	}
	friend Matrix_M operator*(Matrix_M a,Matrix_M b){
		Matrix_M c;
		for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
		for(int k=1;k<=n;++k)
			c.x[i][j]=(c.x[i][j]+a.x[i][k]*b.x[k][j])%mo;
		return c;
	}
	void ksm(ll b){
		Matrix_M p;p.pre();
		while(b){
			if(b&1)p=p*(*this);
			(*this)=(*this)*(*this);b>>=1;
		}
		*this=p;
	}
}m;
struct Matrix_G{
	ll x[N];
	Matrix_G(){memset(x,0,sizeof(x));}
	ll & operator[](const int k){return x[k];}
	friend Matrix_G operator*(Matrix_M a,Matrix_G b){
		Matrix_G c;
		for(int i=1;i<=n;++i)
		for(int k=1;k<=n;++k)
			c[i]=(c[i]+a.x[i][k]*b[k])%mo;
		return c;
	}
}g;
bool ck(ll x){
	int res=0;
	while(x){
		res++;
		x-=(x&(-x));
	}
	return res%3==0;
}
int main(){
	read(n,K);
	for(int i=1;i<=n;++i){
		g[i]=1;m.x[i][i]=1;
		read(a[i]);
	}
	for(int i=1;i<=n;++i)
		for(int j=i+1;j<=n;++j)
			if(ck(a[i]^a[j])){
				m.x[i][j]=1;
				m.x[j][i]=1;
			}
	m.ksm(K-1);
	g=m*g;
	for(int i=1;i<=n;++i)
		ans=(ans+g[i])%mo;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：_Spectator_ (赞：2)

[可能更好的食用体验](/article/4u9v5xe7) $|$ 
[题目传送门](/problem/CF691E) $|$ 
[我的其他题解](/user/523641#article.2)

upd on 2024.8.15：修正了一处笔误，优化了码风。

前置知识：动态规划、矩阵快速幂。

------------

### ${\color{#00CD00}\text{思路}}$

首先比较容易想到一个 dp：  
定义 $f_{i,j}$ 表示已经选了 $i$ 个，最后一个选了 $a_j$ 的合法构造方案。那么可以写出转移方程为：

$$f_{i,j}=\sum\limits_{k=1}^n f_{i-1,k}\cdot [{\rm popcount}(a_j\ {\rm xor}\ a_k)\bmod 3=0]$$

这样写似乎不太容易理解。下面是代码：
```cpp
for(int i=1; i<=n; i++) f[1][i] = 1; //初始化
for(int i=2; i<=m; i++) //m 就是题目中的 k 
	for(int j=1; j<=n; j++)
		for(int k=1; k<=n; k++){
			int cnt = __builtin_popcountll(a[j]^a[k]);
			//使用  __builtin_popcount() 函数求二进制下 1 的数量 
			if(cnt%3==0) f[i][j] += f[i-1][k];
		}
//最后的答案是 f[m][1]+f[m][2]+...+f[m][n]
```
接下来考虑优化。我们先 $O(n^2)$ 预处理一个 $b$ 数组，其中 $b_{i,j}=1$ 表示 $s_i$ 和 $s_j$ 可以放在相邻的位置，$b_{i,j}=0$ 则不行。以上的转移方程变成这样：$f_{i,j}=\sum\limits_{k=1}^n f_{i-1,k}\cdot b_{j,k}$。

然后就能发现，这个式子可以用**矩阵加速**！

具体地，$f_n=b^{n-1}\times\begin{bmatrix}1\\\vdots\\1\end{bmatrix}$。

于是就愉快地解决了。

$O(n^3\log k)$。

------------

### ${\color{#00CD00}\text{代码}}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e2 + 5, Mod = 1e9 + 7;

struct Matrix{ //矩阵模板
	int n,m,a[N][N];
	Matrix(int x, int y, bool I=0){
		n=x, m=y, memset(a, 0, sizeof(a));
		if(I) for(int i=1; i<=n; i++) a[i][i]=1;
	}
	Matrix operator*(Matrix &b){
		Matrix c(n, b.m);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=b.m; j++)
				for(int k=1; k<=m; k++)
					(c[i][j] += a[i][k] * b[k][j]) %= Mod;
		return c;
	}
	int* operator[](int x){return a[x];}
};

Matrix qpow(Matrix a,int k){ //矩阵快速幂
	Matrix res(a.n, a.m, 1);
	while(k){
		if(k&1) res = res*a;
		a = a*a, k >>= 1;
	}
	return res;
}

int n, m, ans, a[N];
signed main(){
	cin >> n >> m;
	Matrix f(n,1), b(n,n);
	for(int i=1; i<=n; i++)
		cin >> a[i], f[i][1] = 1;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
		{
			int cnt = __builtin_popcountll(a[i]^a[j]);
			if(cnt%3==0) b[i][j] = 1;
		}
	f = qpow(b, m-1)*f;
	for(int i=1; i<=n; i++) (ans += f[i][1]) %= Mod;
	cout << ans;
	return 0;
}
```

---

## 作者：He_Ren (赞：2)

矩阵优化dp

因为$n$的范围只有$100$，所以很难确定选什么样的算法（但是比较大的可能是$O(n^3)$的）

这时候的思路很可能会比较混乱

似乎比较容易想到图论，或者是按二进制位动态规划，但是仔细想想又不行

**没有思路的时候可以先考虑“有目的”的暴力**

考虑暴力dp

无非是，设$f_{i,j}$为长度是$i$，以$a_j$结尾的串的数量

但是发现$i$的值并不重要，重要的是**转移的过程**，而且这一过程**保持不变**

**如果转移过程是不变的，可以考虑矩阵优化dp**

$M_{i.j}$表示$a_i$与$a_j$是否可以相邻（1=可以；0=不可以）

把$f$考虑成向量

于是$f_i=Mf_{i-1}$

_想一想，为什么_

边界情况是$f_{1,j}=1$，然后计算$M^{k-1}f_1$即可

用快速幂计算，复杂度$O(n^3 \log k)$

其实一开始用图论想也行，思路类似

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
typedef long long ll;
const int MAXN = 100 + 5;
const int mod = 1e9 + 7;
using namespace std;

int n;
ll a[MAXN];

struct Matrix
{
	ll g[MAXN][MAXN];
	Matrix(){ memset(g,0,sizeof(g));}
	inline void mul(Matrix &b)
	{
		Matrix c;
		for(int k=1; k<=n; ++k)
			for(int i=1; i<=n; ++i)
				for(int j=1; j<=n; ++j)
					c.g[i][j] += g[i][k]*b.g[k][j] %mod;
		for(int i=1; i<=n; ++i)
			for(int j=1; j<=n; ++j)
				c.g[i][j]%=mod;
		*this=c;
	}
}t,ans;

inline void pw(ll b)
{
	for(int i=1; i<=n; ++i) ans.g[i][i]=1;
	
	while(b)
	{
		if(b&1) ans.mul(t);
		t.mul(t);
		b>>=1;
	}
}

#define lowbit(x) ((x)&-(x))
inline int count(ll x)
{
	int res=0;
	while(x)
		x^=lowbit(x), ++res;
	return res;
}

int main(void)
{
	ll k;
	cin>>n>>k;
	for(int i=1; i<=n; ++i) cin>>a[i];
	
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=n; ++j)
			t.g[i][j] = (count(a[i]^a[j])%3 == 0);
	
	pw(k-1);
	int res=0;
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=n; ++j)
			res = (res+ans.g[i][j]) %mod;
	
	cout<<res;
	return 0;
}
```


---

## 作者：Steven_Meng (赞：2)

可以用矩阵快速幂解决

由于k很多，但是我们分析可以看出，dp[k]=dp[k-1] * a(dp[k]和a都是矩阵)

(a[i][j]即a[i]^a[j]中二进制1的格式模3是否等于0)

dp[1]是什么自己想一想

最后求dp[k]的元素之和即可

```
#include <cstdio>
#include <iostream>
#include <cstring>
#define MOD 1000000007
#define MAXN 105
using namespace std;
long long n,k,ans;
//快读快写
inline long long read(){
	char ch;
	long long f=1,x=0;
	ch=getchar();
	while (ch>'9'||ch<'0'){
		if (ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while (ch<='9'&&ch>='0'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}
inline void print(long long x){
	if (x<0) x=-x,putchar('-');
	if (x>9) print(x/10);
	putchar(x%10+'0');
}

struct binary{
	bool num[65];
	long long len;
	void clear(){
		memset(num,0,sizeof(num));
	}
	void convert(long long a){
		long long i=0;
		while (a>0){
			num[i++]=a&1;
			a>>=1;
		}
		len=i;
	}
	long long SumTrue(){
		long long sum=0;
		for (long long j=0;j<len;j++){
			sum+=num[j];
		}
		return sum;
	}
}a[MAXN];
binary operator ^ (const binary &a,const binary &b){
	binary c;
	long long maxlen=max(a.len,b.len);
	for (long long i=0;i<maxlen;i++){
		c.num[i]=a.num[i] xor b.num[i];
	}
	c.len=maxlen;
	return c;
}

struct matrix{
	long long v[MAXN][MAXN];
	void clear(){
		memset(v,0,sizeof(v));
	}
	void YPYlovesDYF(){
		for (long long i=0;i<n;i++){
			for (long long j=0;j<n;j++){
			    binary c=a[i]^a[j];
			    v[i][j]=(c.SumTrue()%3==0);
			}
		}
	}
};
matrix operator *(const matrix &a,const matrix &b){
	matrix ans;
	ans.clear();
	for (long long i=0;i<n;i++){
		for (long long j=0;j<n;j++){
			for (long long k=0;k<n;k++){
				ans.v[i][j]=(ans.v[i][j]+a.v[i][k]*b.v[k][j])%MOD;
			}
		}
	}
	return ans;
}

//矩阵快速幂
matrix ksm(matrix a,long long pows){
	matrix ans;
	ans.clear();
	for (long long i=0;i<n;i++){
	    ans.v[i][i]=1;
	}
	while (pows>0){
		if (pows&1){
			ans=ans*a;
		}
		a=a*a;
		pows>>=1;
	}
	return ans;
}
int main(){
	n=read();
	k=read();
	long long temp;
	for (long long i=0;i<n;i++){
		temp=read();
		a[i].clear();
		a[i].convert(temp);
	}
	matrix ans;
	ans.YPYlovesDYF();
	ans=ksm(ans,k-1);
	long long ret=0;
	for (long long i=0;i<n;i++){
	    for (long long j=0;j<n;j++){
	        ret=(ret+ans.v[i][j])%MOD;
	    }
	}
	print(ret);
	return 0;
}
```

发现自己太弱了,其实不用模拟二进制,用位运算来计算1的个数也可以

```
int count(ll a)
{
    int ans = 0;
    while(a){
        if(a & 1) ans++;
        a >>= 1;
    }
    return ans;
}
```

---

## 作者：ZJle (赞：1)

## CF691E 题解


~~写了 7 遍才过，太坐牢了~~

### 前置芝士
矩阵，矩阵快速幂。

### 题意
给定序列，从序列中选择 $k(1≤k≤10^{18})$ 个数（可以重复选择），使得得到的排列满足 $x_i$ 与 $x_{i+1}$ 异或的二进制表示中 $1$ 的个数是 $3$ 的倍数。问长度为 $k$ 的满足条件的序列有多少种？

### 解题
这题刚开始的时候没有想法，点开 CF 后看到了矩阵 tags 就会写了。

首先看到数据 $1\leq n \leq 100$，可以考虑运用邻接矩阵的方式，用 $O(n^2)$ 预处理出哪两个是可以连接到一起的，也就是当 $k=2$ 的情况。

然后我们知道，对于一对可拼接的 $x_i$ 与 $x_j$ 和另一对 $x_j$ 与 $x_k$，很显然，当 $k=3$ 的时候这两对是可以拼接成为一对三元组 $(x_i,x_j,x_k)$，这是可以满足条件的。

注意到矩阵的乘法是 $C_{i,j}=\sum_{k=1}^n a_{i,k}\times b_{k,j}$。

那么 $C_{i,j}$ 存储的就是 $x_i,x_j$ 之间的路径总数。

鉴于之前预处理的时候已经乘过一次了，所以后面只需要进行 $k-1$ 次幂操作，再统计 $\sum_{i,j=1}^{i,j\leq n}C_{i,j}$ 就行了。

由于纯暴力幂操作后全体复杂度为 $O(n^2+N^3\times k)$，很显然会爆，所以我们考虑快速幂操作，最终复杂度为 $O(n^2+N^3\times\log k)$。

上码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
void file(){
   ios::sync_with_stdio(false);
   cin.tie(0),cout.tie(0);
}
const int N=1e2+10;
const int mod=1e9+7;
struct ztxmd{
    int mp[N+1][N+1];
}ans;
ztxmd matrix;
int ap[110];
bool check(int x,int y){
    int cnt=0,op=x^y;
    while(op){
        if(op%2==1){
            cnt++;
        }
        op=op>>1;
    }
    return cnt%3==0?true:false;
}
int n;
ztxmd operator *(const ztxmd& a,const ztxmd& b){
    ztxmd c;
    memset(c.mp,0,sizeof c.mp);
    for(int i=1;i<=N;i++){
        for(int j=1;j<=N;j++){
            for(int k=1;k<=N;k++){
                (c.mp[i][j]+=a.mp[i][k]*b.mp[k][j])%mod;
            }
        }
    }
    return c;
}
void qpow(int op){
    
    memset(ans.mp,0,sizeof ans.mp);
    for(int i=1;i<=N-1;i++){
        ans.mp[i][i]=1;
    }
    while(op){
        if(op&1) ans=ans*matrix;
        matrix=matrix*matrix;
        op>>=1;
    }
}
auto main() ->signed{
    file();
    int k;
    memset(matrix.mp,0,sizeof matrix.mp);
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>ap[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(check(ap[i],ap[j])){
                matrix.mp[i][j]=1;
            }
        }
    }
    if(k==1){
        cout<<n;
        exit(0);
    }
    int hi=0;
    qpow(k-1);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
                hi=(hi+ans.mp[i][j])%mod;
        }
    }
    cout<<hi<<endl;
    return 0;
}
```

~~看懂了再贺吧~~

---

## 作者：yanghanyv (赞：1)

## 前置知识

- [矩阵乘法](https://oi-wiki.org/math/matrix/#_5)

## 思路

题目求构造一个长度为 $k$ 的序列的方案数，首先想到 DP。设 $f_{len,i}$ 表示长度为 $len$，最后一个数为 $a_i$ 时的方案数。

### 40 分解法

可以循环递推出答案 $\sum_{i=1}^n f_{k,i}$，暴力递推如下：

```cpp
for(int len=1;len<=k;len++){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int t=a[i]^a[j],cnt=0;
			while(t){
				cnt++;
				t&=(t-1);
			}
			if(cnt%3==0){//判断
            	f[len%2][i]+=f[(len-1)%2][j];//滚动数组
			}
		}
	}
}
```

### 100 分解法

$k \leq 10^{18}$，时间复杂度显然爆炸，于是考虑优化方式。看到
$n$ 很小，$k$ 很大，容易想到用矩阵优化 DP。  
- 构造一个 base 矩阵。  
由于每一个状态 $f_{len,i}$ 只与其余 $n$ 个状态 $f_{len-1,j(1 \leq j \leq n)}$ 有关，**因此 base 矩阵大小为 $n \times n$。**  
由于只有当 $a_i \operatorname{xor} a_j$ 的二进制表示中 1 的个数为 3 的倍数时，递推式才会成立，**因此当 $a_i \operatorname{xor} a_j$ 的结果的二进制表示中 $1$ 的个数为 $3$ 的倍数时，我们令 $base_{i,j}=base_{j,i}=1$，这样便得到了 base 矩阵。**  
- 然后构造初始时的 f 矩阵 
$
\begin{pmatrix}
  1&0&\cdots&0&0\\
  1&0&\cdots&0&0\\
  \vdots&\vdots&\ddots&\vdots&\vdots\\
  1&0&\cdots&0&0\\
  1&0&\cdots&0&0
\end{pmatrix}
$。  
- 得到两个矩阵后，这道题就和其它矩阵乘法题目没有区别了，直接写板子。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e2+5;
const int mod=1e9+7;
struct mat{
	ll f[N][N];
}base,f;
ll n,k,a[N],ans;
mat mat_mul(mat a,mat b){
	mat res;
	memset(res.f,0,sizeof(res.f));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				res.f[i][j]=(res.f[i][j]+(a.f[i][k]*b.f[k][j])%mod)%mod;
			}
		}
	}
	return res;
}
mat mat_pow(mat a,ll p){
	mat res;
	memset(res.f,0,sizeof(res.f));
	for(int i=1;i<=n;i++){
		res.f[i][i]=1;
	}
	while(p){
		if(p%2==1){
			res=mat_mul(res,a);
		}
		a=mat_mul(a,a);
		p/=2;
	}
	return res;
}
int main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		f.f[i][1]=1;//构造f矩阵
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			ll t=a[i]^a[j],cnt=0;
			while(t){
				cnt++;
				t&=(t-1);
			}
			if(cnt%3==0){
				base.f[i][j]=base.f[j][i]=1;
			}
		}
	}//构造base矩阵
	f=mat_mul(mat_pow(base,k-1),f);//矩阵快速幂
	for(int i=1;i<=n;i++){
		ans=(ans+f.f[i][1])%mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：lgx57 (赞：0)

很板的一道题。

把每个数看做一个点，如果 $2$ 个数可以相邻，那么它们之间连一条边。

于是问题变成了求这个图上 $k$ 长路径数。

可以用矩阵快速幂解决。详见 [模板题](https://www.luogu.com.cn/problem/AT_dp_r)。

```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define pii pair<int,int>
#define endl '\n'
#define pb push_back
#define ls(p) ((p)<<1)
#define rs(p) ((p)<<1|1)
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int mod=1e9+7;
const int N=105;
int a[N];
struct mat{
	int n;
	vector<vector<int> > m;
	mat(int x):m(x+1,vector<int>(x+1,0)){
		n=x;
	}
	void init(){
		for (int i=1;i<=n;i++) m[i][i]=1;
	}
	mat operator *(mat &b){
		mat c(n);
		for (int i=1;i<=n;i++){
			for (int j=1;j<=n;j++){
				for (int k=1;k<=n;k++){
					c.m[i][j]=(c.m[i][j]+m[i][k]*b.m[k][j]%mod)%mod;
				}
			}
		}
		return c;
	}
	mat matqp(int k){
		mat base(n);
		for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) base.m[i][j]=this->m[i][j];
		mat ans(n);
		ans.init();
		while (k){
			if (k&1){
				ans=ans*base;
			}
			base=base*base;
			k>>=1;
		}
		return ans;
	}
	void print_mat(){
		for (int i=1;i<=n;i++){
			for (int j=1;j<=n;j++){
				cout<<m[i][j]<<' ';
			}
			cout<<endl;
		}
	}
};
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int n,k;
	cin>>n>>k;
	for (int i=1;i<=n;i++){
		cin>>a[i];
	}
	mat b(n);
	for (int i=1;i<=n;i++){
		for (int j=1;j<=n;j++){
			int x=(a[i]^a[j]);
			if (__builtin_popcountll(x)%3==0){
				b.m[i][j]=1;
			}
		}
	}
	mat ans=b.matqp(k-1);
	int Ans=0;
	for (int i=1;i<=n;i++){
		for (int j=1;j<=n;j++){
			Ans=(Ans+ans.m[i][j])%mod;
		}
	}
	cout<<Ans;
	return 0;
}
```

tips：

请使用 ```__builtin_popcountll()``` 函数。

---

## 作者：WaterSky (赞：0)

# [CF691E Xor-sequences](https://www.luogu.com.cn/problem/CF691E)
## 芝士卡片
- [矩阵及矩阵加速相关芝士](https://oi.wiki/math/linear-algebra/matrix/)
- 函数 $\text{popcount}$
  - 表示二进制时 $1$ 的数量。使用方式如下：
  - ``__builtin_popcountll(x)`` 返回 $x$ 二进制下 $1$的数量。
## 碎碎念
因为被抓去讲题让我知道了我在台上会忘掉所有东西，并且这题我没有理解透，所以我就写细一点。
## 正文
### 题意：
给定集合 $A$，求满足：
$$\left\{\begin{matrix}
\forall i & b_i \in  A\\
\forall 2\le i \le k & \text{popcount}(b_{i-1} \oplus b_i)|3
\end{matrix}\right.$$
的长度为 $k$ 的数组 $B$ 的数量。
### 做法：
考虑 DP，设状态：$f_{i,j}$ 表示 $B$ 数组的长度为 $i$，且最后一个数为 $a_j$ 时的方案数。则有状态转移方程：
$$f_{i,j}=\sum_{x=1}^{n} f_{i-1,x} \times {(\text{popcount}(a_{x} \oplus a_{j})|3)}$$

解释一下这个柿子是怎么转移过来的。

可以发现，对于每一个 $a_j$，它能否放置在第 $i$ 个位置，取决于第 $i-1$ 的数是否满足：$\text{popcount}(b_{i-1} \oplus a_{j})|3]$，所以需要枚举在第 $i-1$ 的可能的数，并根据加法原理更新方案数。

还不是很理解的可以看一下下面这段程序：
```cpp
	for(int i=1;i<=k;i++)
		for(int j=1;j<=n;j++)
			for(int x=1;x<=n;x++)
				if(__builtin_popcountll(a[x]^a[j])%3==0)
					f[i][j]+=f[i-1][x];
```
那么最终的答案即为：
$$\sum_{i=1}^n f_{k,i}$$

接下来考虑优化。

可以先预处理出一个数组表示 $A$ 中两两元素之间是否符合条件，像酱紫：
```cpp
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(__builtin_popcountll(a[i]^a[j])%3==0)
                b[i][j]=1;
```
那么状态转移方程就会变成：
$$f_{i,j}=\sum_{x=1}^{n} f_{i-1,x} \times b_{j,x}$$
能够发现，对于一个相同的 $j$，不同的 $i$ 的值无法对转移到 $j$ 上的 $x$ 产生影响。

接下来就是矩阵加速 DP 了，这部分比较容易思考，所以就不写了。

### Copy
```
#include<bits/stdc++.h>
using namespace std;
const long long Mod=1e9+7;
struct Matrix{
	long long n,m,a[105][105];
	Matrix(long long x,long long y,bool bj){
		n=x,m=y,memset(a,0,sizeof(a));
		for(int i=1;i<=n&&bj;i++)
			a[i][i]=1;
	}
	Matrix operator*(Matrix &b){
		Matrix c(n,b.m,0);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=b.m;j++)
				for(int k=1;k<=m;k++)
					(c[i][j]+=a[i][k]*b[k][j])%=Mod;
		return c;
	}
	long long* operator[](long long x){return a[x];}
};
Matrix power(Matrix a,long long k){
	Matrix res(a.n,a.m,1);
	while(k){
		if(k&1)res=res*a;
		a=a*a,k>>=1; 
	}
	return res;
}
long long n,k,ans,a[105];
int main(){
	cin>>n>>k;
	Matrix f(n,1,0),b(n,n,0);
	for(int i=1;i<=n;i++)
		cin>>a[i],f[i][1]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(__builtin_popcountll(a[i]^a[j])%3==0)b[i][j]=1;
	f=power(b,k-1)*f;
	for(int i=1;i<=n;i++)
		ans=(ans+f[i][1])%Mod;
	cout<<ans;
	return 0;
}
```
感谢管理大大审核！

感谢屏幕前的你！

---

## 作者：daniEl_lElE (赞：0)

矩阵快速幂优化 DP 经典题。

## 思路

依然考虑 $dp_{i,j}$ 表示看到第 $i$ 位最后一个选的是 $a_j$，转移要求是 $\operatorname{popcount}(a_j\oplus a_k)\bmod{3}$ 是 $0$。

容易发现每次转移是一样的，我们可以先 $\Theta(n^2)$ 预处理出哪些 $(i,j)$ 可以转移即可。

然后就可以直接用矩阵快速幂优化即可，复杂度 $\Theta(n^3\log k)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=1e9+7;
struct mtx{
	int a[105][105];
};
mtx mul(mtx x,mtx y){
	mtx z;
	for(int i=1;i<=100;i++) for(int j=1;j<=100;j++) z.a[i][j]=0;
	for(int k=1;k<=100;k++) for(int i=1;i<=100;i++) for(int j=1;j<=100;j++) z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;
	return z;
}
mtx add(mtx x,mtx y){
	mtx z;
	for(int i=1;i<=100;i++) for(int j=1;j<=100;j++) z.a[i][j]=(x.a[i][j]+y.a[i][j])%mod;
	return z;
}
mtx qp(mtx a,int b){
	mtx ans;
	for(int i=1;i<=100;i++) for(int j=1;j<=100;j++) ans.a[i][j]=(i==j);
	while(b){
		if(b&1) ans=mul(ans,a);
		a=mul(a,a);
		b>>=1;
	}
	return ans;
}
int __bulitin_popcount(int i){
	int cnt=0;
	while(i){
		cnt+=(i&1);
		i>>=1;
	}
	return cnt;
}
mtx base,ori;
signed main(){
	int n,k;
	cin>>n>>k;
	int a[n+1];
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(__bulitin_popcount(a[i]^a[j])%3==0){
				base.a[i][j]=1;
			}
		}
	}
	for(int i=1;i<=n;i++) ori.a[1][i]=1;
	ori=mul(ori,qp(base,k-1));
	int ans=0;
	for(int i=1;i<=n;i++) ans=(ans+ori.a[1][i])%mod;
	cout<<ans; 
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

考虑暴力 $O(n ^ 2 \log a)$ 连边，令 $dp_{i,k}$ 表示长为 $k$ 的 $b$ 数组末尾为第 $i$ 个值时的方案数可得：        

$dp_{i,k + 1} = \sum_{(i,j) \in Edge} dp_{j,k}$ 

这个 dp 的含义就是相当于从长度比当前状态少 $1$ 的 合法状态中，找到末尾可以拼在一起的状态转移过来。

观察到每次只利用到了 $k - 1$ 的状态就能转移到 $k$ 的状态考虑矩阵加速 $dp$ 转移，将系数填入矩阵中即可进行矩阵快速幂即可。          

时间复杂度 $O(n ^ 3 \log k)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e2 + 5 , mod = 1e9 + 7;
long long n,m;
struct node
{
	long long a[Len][Len];
	node(){memset(a , 0 , sizeof a);}
	inline void build(){for(int i = 1 ; i <= n ; i ++) a[i][i] = 1;}
}Ans,K,smr;
node operator * (const node &x,const node &y)
{
	node z;
	for(int i = 1 ; i <= n ; i ++)	
		for(int j = 1 ; j <= n ; j ++)
			for(int k = 1 ; k <= n ; k ++) z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod;
	return z;
}
node mul(node x,node y)
{
	node z;
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= n ; j ++) z.a[1][i] = (z.a[1][i] + x.a[1][j] * y.a[j][i] % mod) % mod;
	return z;
}
long long val[Len];
bool count(long long x)
{
	int res = 0;
	for(int i = 62 ; i >= 0 ; i --) if((x >> i) & 1) res ++;
	return res % 3 == 0;
}
int main()
{
	scanf("%lld %lld",&n,&m);
	for(int i = 1 ; i <= n ; i ++) scanf("%lld",&val[i]);
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= n ; j ++) if(count(val[i] ^ val[j])) K.a[i][j] = 1;
	m --;
	for(int i = 1 ; i <= n ; i ++) Ans.a[1][i] = 1;
	smr.build();
	while(m)
	{
		if(m & 1) smr = smr * K;
		K = K * K;
		m = m >> 1;
	}
	Ans = mul(Ans , smr);long long res = 0;
	for(int i = 1 ; i <= n ; i ++) res += Ans.a[1][i] , res %= mod;
	printf("%lld\n",res);
 	return 0;
}
```

---


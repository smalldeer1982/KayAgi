# Minimum Triangulation

## 题目描述

You are given a regular polygon with $ n $ vertices labeled from $ 1 $ to $ n $ in counter-clockwise order. The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon, there is no pair of triangles such that their intersection has non-zero area, and the total area of all triangles is equal to the area of the given polygon. The weight of a triangulation is the sum of weigths of triangles it consists of, where the weight of a triagle is denoted as the product of labels of its vertices.

Calculate the minimum weight among all triangulations of the polygon.

## 说明/提示

According to Wiki: polygon triangulation is the decomposition of a polygonal area (simple polygon) $ P $ into a set of triangles, i. e., finding a set of triangles with pairwise non-intersecting interiors whose union is $ P $ .

In the first example the polygon is a triangle, so we don't need to cut it further, so the answer is $ 1 \cdot 2 \cdot 3 = 6 $ .

In the second example the polygon is a rectangle, so it should be divided into two triangles. It's optimal to cut it using diagonal $ 1-3 $ so answer is $ 1 \cdot 2 \cdot 3 + 1 \cdot 3 \cdot 4 = 6 + 12 = 18 $ .

## 样例 #1

### 输入

```
3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4
```

### 输出

```
18
```

# 题解

## 作者：seanlsy (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/CF1140D)

**法一**

这题一看就感觉是区间 DP。设 $f_{i,j}$ 表示从 $i$ 逆时针到 $j$ 所需的最小权值。那么可以暴力枚举割点 $k$，从而得到 $f_{i,j}$ 的结果。动态转移方程为 $f_{i,j}=\min f_{i,k}+f_{k,j}+ijk$。

如果这么做的话，时间复杂度为 $O(n^3)$，可以通过本题。

**CODE**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	int x=0;bool f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=0;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?x:-x;
}
int n,f[505][505],ans;
signed main(){
	n=read();
	for(int i=1;i<=n;f[i][++i]=0)//这里是为了避免无法转移
		for(int j=i+2;j<=n;j++)
			f[i][j]=100000000000;//注意要取极大值
	for(int i=n-2;i;i--)
		for(int j=i+2;j<=n;j++)
			for(int k=i+1;k<j;k++)
				f[i][j]=min(f[i][k]+f[k][j]+i*j*k,f[i][j]);
	printf("%lld\n",f[1][n]);
	return 0;
}
```
**法二**

仔细观察题目，发现可以利用贪心的思想。对于每一条边，如果想让这条边最终贡献最小，那显然两个顶点都应该和 $1$ 连接。

那么显然此时的答案为 $\sum_{i=2}^{n-1}i(i+1)$。

直接累加即可，时间复杂度 $O(n)$，轻松通过。

**CODE**
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0;bool f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=0;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?x:-x;
}
int n,ans;//既然考虑到了答案，那么 long long 就不用开了
int main(){
	n=read();
	for(int i=2;i<=n-1;i++) 
    	    ans+=i*(i+1);
	printf("%d\n",ans);
    return 0;
}
```

**法三**

上面的那个式子还可以变形。

我们不妨先加上一个 $1 \times 2$，后面再减去。

我们知道

$\begin{aligned}1\times2 & = \frac{1}{3}(1\times2\times3-0\times1\times2) \\ 2\times3 & = \frac{1}{3}(2\times3\times4-1\times2\times3) \\ & \dots \\ n(n-1) & = \frac{1}{3}((n-1)n(n+1)-(n-2)(n-1)n)\end{aligned}$ 

所以

$\sum_{i=2}^{n-1}i(i+1)=\sum_{i=1}^{n-1}i(i+1)-2$

$=\dfrac{1}{3}(-0\times1\times2+1\times2\times3-1\times2\times3+2\times3\times4-\cdots+(n-1)n(n+1))-2$

$=\dfrac{1}{3}(n-1)n(n+1)-2$

于是时间复杂度就降到了 $O(1)$。

这个方法喜提 [最优解](https://www.luogu.com.cn/record/76839919)。

备注：这是大号。

**CODE**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	int x=0;bool f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=0;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?x:-x;
}
int n;
signed main(){
	n=read();
	printf("%lld\n",(n-1)*n*(n+1)/3-2);
	return 0;
}
```
**总结**

这是一道方法很多的题，最快的方法的代码很短。但是其实本题最有价值的是区间 DP 的做法。因为只有这种做法有一定的适用性，它可以处理输入权值的题。另外两种做法主要是可以锻炼思维。

---

## 作者：da32s1da (赞：5)

考虑$1,x,y$连了一个三角形，$x,y,z$连了一个三角形。权值为$xy+xyz$。

换一种连接方法，$1,x,z$和$1,y,z$。权值为$xz+yz$

考虑$x,y\ge 2$时，$x+y\le xy$，所以后者剖分方法要优于前者剖分方法。

所以答案是

$$1\times 2\times 3+1\times 3\times 4+1\times 4\times 5+\cdots+1\times (n-1)\times n$$

$$=\sum_{i=1}^{n-1}i^2+\sum_{i=1}^{n-1}i-2$$

$$=\frac{n(n-1)(2n-1)}{6}+\frac{n(n-1)}{2}-2$$

$$=\frac{n^3-n}{3}-2$$

---

## 作者：jbc392 (赞：2)

 题意：求将一个n边形分解成(n-2)个三边形花费的最小精力，其中花费的精力是所有三角形的三顶点编号乘积的和(其中编号是按照顶点的顺时针顺序编写的)
 
 考虑1,x,y连了一个三角形，x,y,z连了一个三角形。权值为xy+xyz。

换一种连接方法，1,x,z和1,y,z。权值为xz+yz
考虑x,y≥2时，x+y≤xy，所以后者剖分方法要优于前者剖分方法。

所以答案是

$1\times 2\times 3+1\times 3\times 4+1\times 4\times 5+\cdots+1\times (n-1)\times n1$ 

=(n³-n)÷3－2
 
 AC代码：
 
 
 
 ```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<(n*n*n-n)/3-2;
	return 0;
}
```


---

## 作者：Supor__Shoep (赞：1)

其他人都推出了结论，而我却在用区间 DP 打表……

这道题用区间 DP 大法是非常暴力的，就是从长度为 $3$ 的区间开始，一直找到长度为 $n$ 的区间，途中枚举一个 $k$ 当中间点，也就是三角形除了区间两个点外的另一个点，转移方程为：

$$dp_{i,j}=\text{min}(dp_{i,j},dp_{i,k}+dp_{k,j}+i\times j\times k)$$

得到初步代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=505;
int n,dp[MAXN][MAXN];
int main()
{
	cin>>n;
	for(int len=3;len<=n;len++)
	{
		for(int i=1;i<=n-len+1;i++)
		{
			int j=i+len-1;
			dp[i][j]=1e9;
			for(int k=i;k<=j;k++)	dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+i*k*j);
		}
	}
	cout<<dp[1][n];
	return 0;
}
```

但是当我运行 $n=500$ 的时候，这个程序卡了一下，虽然问题不大，但是相对于人家我们还是需要越快越好的，更何况拿 $n$ 来开数组是没有问题的。所以我就照着这个代码枚举了所有的 $n$ 打出了表：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans[505]={6,18,38,68,110,166,238,328,438,570,726,908,1118,1358,1630,1936,2278,2658,3078,3540,4046,4598,5198,5848,6550,7306,8118,8988,9918,10910,11966,13088,14278,15538,16870,18276,19758,21318,22958,24680,26486,28378,30358,32428,34590,36846,39198,41648,44198,46850,49606,52468,55438,58518,61710,65016,68438,71978,75638,79420,83326,87358,91518,95808,100230,104786,109478,114308,119278,124390,129646,135048,140598,146298,152150,158156,164318,170638,177118,183760,190566,197538,204678,211988,219470,227126,234958,242968,251158,259530,268086,276828,285758,294878,304190,313696,323398,333298,343398,353700,364206,374918,385838,396968,408310,419866,431638,443628,455838,468270,480926,493808,506918,520258,533830,547636,561678,575958,590478,605240,620246,635498,650998,666748,682750,699006,715518,732288,749318,766610,784166,801988,820078,838438,857070,875976,895158,914618,934358,954380,974686,995278,1016158,1037328,1058790,1080546,1102598,1124948,1147598,1170550,1193806,1217368,1241238,1265418,1289910,1314716,1339838,1365278,1391038,1417120,1443526,1470258,1497318,1524708,1552430,1580486,1608878,1637608,1666678,1696090,1725846,1755948,1786398,1817198,1848350,1879856,1911718,1943938,1976518,2009460,2042766,2076438,2110478,2144888,2179670,2214826,2250358,2286268,2322558,2359230,2396286,2433728,2471558,2509778,2548390,2587396,2626798,2666598,2706798,2747400,2788406,2829818,2871638,2913868,2956510,2999566,3043038,3086928,3131238,3175970,3221126,3266708,3312718,3359158,3406030,3453336,3501078,3549258,3597878,3646940,3696446,3746398,3796798,3847648,3898950,3950706,4002918,4055588,4108718,4162310,4216366,4270888,4325878,4381338,4437270,4493676,4550558,4607918,4665758,4724080,4782886,4842178,4901958,4962228,5022990,5084246,5145998,5208248,5270998,5334250,5398006,5462268,5527038,5592318,5658110,5724416,5791238,5858578,5926438,5994820,6063726,6133158,6203118,6273608,6344630,6416186,6488278,6560908,6634078,6707790,6782046,6856848,6932198,7008098,7084550,7161556,7239118,7317238,7395918,7475160,7554966,7635338,7716278,7797788,7879870,7962526,8045758,8129568,8213958,8298930,8384486,8470628,8557358,8644678,8732590,8821096,8910198,8999898,9090198,9181100,9272606,9364718,9457438,9550768,9644710,9739266,9834438,9930228,10026638,10123670,10221326,10319608,10418518,10518058,10618230,10719036,10820478,10922558,11025278,11128640,11232646,11337298,11442598,11548548,11655150,11762406,11870318,11978888,12088118,12198010,12308566,12419788,12531678,12644238,12757470,12871376,12985958,13101218,13217158,13333780,13451086,13569078,13687758,13807128,13927190,14047946,14169398,14291548,14414398,14537950,14662206,14787168,14912838,15039218,15166310,15294116,15422638,15551878,15681838,15812520,15943926,16076058,16208918,16342508,16476830,16611886,16747678,16884208,17021478,17159490,17298246,17437748,17577998,17718998,17860750,18003256,18146518,18290538,18435318,18580860,18727166,18874238,19022078,19170688,19320070,19470226,19621158,19772868,19925358,20078630,20232686,20387528,20543158,20699578,20856790,21014796,21173598,21333198,21493598,21654800,21816806,21979618,22143238,22307668,22472910,22638966,22805838,22973528,23142038,23311370,23481526,23652508,23824318,23996958,24170430,24344736,24519878,24695858,24872678,25050340,25228846,25408198,25588398,25769448,25951350,26134106,26317718,26502188,26687518,26873710,27060766,27248688,27437478,27627138,27817670,28009076,28201358,28394518,28588558,28783480,28979286,29175978,29373558,29572028,29771390,29971646,30172798,30374848,30577798,30781650,30986406,31192068,31398638,31606118,31814510,32023816,32234038,32445178,32657238,32870220,33084126,33298958,33514718,33731408,33949030,34167586,34387078,34607508,34828878,35051190,35274446,35498648,35723798,35949898,36176950,36404956,36633918,36863838,37094718,37326560,37559366,37793138,38027878,38263588,38500270,38737926,38976558,39216168,39456758,39698330,39940886,40184428,40428958,40674478,40920990,41168496,41416998,41666498};
int main()
{
	int n;
	cin>>n;
	cout<<ans[n-3];
	return 0;
}
```

打表有时应该也是一种比较好的策略吧。。

---

## 作者：BYWYR (赞：1)

## $\texttt{Solution}$

考虑贪心的思想。

如果想要每一条边对于权值的贡献最小，那么这两个顶点都应该与 $1$ 连接。

理由其实很简单：

设有 $a,b,c,d$ 四个数，

且 $1 \leq a<b<c<d$，$b$ 与 $c$ 为要与 $a$ 或 $d$ 点连接的点。

如果要与 $a$ 点连接，总权值为 $a \times b \times c$；

如果要与 $d$ 点连接，总权值为 $d \times b \times c$；

$\because a<d$

$\therefore a \times b \times c < d \times b \times c$

$a_{min}=1$，所以所有点应该与 $1$ 点连接。



------------


举个栗子，如五边形 $12345$ 中：

![](https://img1.imgtp.com/2022/07/27/xKgLRXwf.PNG)

连接 $1,3$ 与 $1,4$ 使权值最小，总权值为

$$S=1 \times 2 \times 3 +1 \times 3 \times 4+1 \times 4 \times 5=38$$

## $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
ll ans;//建议开 long long
int main(){
	cin>>n;
	for(int i=2;i<n;i++)
		ans+=i*(i+1);
	cout<<ans;
	return 0;
}
```

------------

听机房巨佬说区间 DP 也能过这道题，完全没有思路 Orz

---

## 作者：tommyfj (赞：1)

我们可以用一个正五边形做个示范（如图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/60zg9vem.png?)

图中将正五边形分为三个三角形。诶？为什么要这么分呢？我随便怎么分不都一样吗？萌新提出疑惑。

错啦！题目要我们求得是 **最小权值** 啊，我们要让权值最小，那肯定要以编号 $1$ 为中心来分啦（你想想， $1 \times 2 \times 3$ 和 $2 \times 3 \times 4$ 谁大？）

所以，正n边形都是从编号 $1$ 开始分的啦。

然后，我们可以分别写出这三个三角形的权值是 $1 \times 2 \times 3,1 \times 3 \times 4,1 \times 4 \times 5$。

然后我们把这些加起来，计算最小权值是
 
$1 \times 2 \times 3 + 1 \times 3 \times 4 + 1 \times 4 \times 5$

$= 2 \times 3 + 3 \times 4 + 4 \times 5$

$= 6 +12 +20$

$= 38$

 证明：
 
 请看，$2$ 和 $3$ 差几，差 $1$；那 $3$ 和 $4$ 呢，也差 $1$；$4$ 和 $5$ 当然也差 $1$。
 所以 第 $i$ 编号 和 第 $i-1$ 编号 差 $1$。
 
 为了便于理解，我们先把 $2$ 看作 $x$ ，则 $3 = x + 1,4 = 3 + 1 = x + 2,5 = 4 + 1 = x + 3$。
 
 我们把原来的式子转换成另一个形式：
 
 $2 \times 3 + 3 \times 4 + 4 \times 5$
 
 $= x \cdot (x + 1) + (x + 1) \cdot (x + 2) + (x + 2) \cdot (x + 3)$
 
 令 $x + 1 = m$,
 
 $x \cdot (x+1) = (x+1) \cdot x = m \cdot x = m \cdot (x+1-1) = m \cdot (m-1)$
 
 这其实就是将前后的顺序进行调换，并将 $x \cdot (x+1)$ 的形式转换成 $m \cdot (m-1)$ 这种形式。
 
 那我们可按这样的转换方式转变式子，$3 \times (3+1)$ 就是 $4 \times (4-1)$,$4 \times (4+1)$ 就是 $5 \times (5-1),.....,$ 一直推到 $n$,那相应的式子是 $n \cdot (n-1)$
 
 $\therefore$ 得到公式 最小权值 $= 3 \times 2 + 4 \times 3 + ... + n \times (n-1)$。
 
 补充一点，在几何中，顶点最少的图形是三角形，所以 $n \geq 3$,这也就是为什么从 $3 \times 2$ 开始加的原因了。

我们可以用循环来实现这个公式，下面是文字解说：

 初始 ：首先 $i = 3 $,（$i < 3$ 时无法构成三角形）。进行 $1$。
 
$1$. 循环开始 计算 $i \times (i-1)$ 的值，并将该值加到 $sum$ 里，$i \leftarrow i+1 $。
 
核心代码：

```cpp
    for (int i = 3;i <= n;i ++) 
    {
        sum += i * (i - 1);
    }
```


---

## 作者：Fa1thful (赞：1)

### 题意：
给定一个n边形，求把它划分成$n-2$个三角形，求每个三角形顶点编号的乘积之和最小是多少。

### 分析：
首先，我们发现这道题没有什么思路的时候可以画一画图，找找规律。

1.一个三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/45wbgtvp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这个三角形很显然它只能分成一个三角形

权值=$1*2*3=6$.

2. 一个四边形：

![](https://cdn.luogu.com.cn/upload/image_hosting/hqlps00m.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

很显然，一个四边形有两种画法。

①连接2、4   权值=$1*2*4+2*3*4=8+24=32$

②连接1、3   权值=$1*2*3+1*3*4=6+12=18$

所以，四边形连接1、3会好一些。

 这时，我们发现了一个规律，所有被划分出来的三角形，如果最少，那么必须要带有一个$1$。
 
 下面用一个六边形验证一下：
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/8lzfrrk7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
 
 按照红色的划分权值为$5*6+4*5+3*4+2*3=68$
 
 而按照橙色的划分权值则为$2*6+2*5*6+2*4*5+2*3*4$很明显是比红色分割要大的。
 
 那么怎么证明呢？
 
####  证明：
设一个四边形点的编号为$1,x,y,z$

如果按照1分那么权值为$xy+yz$

如果另一种分法的权值为$xyz+xz$

因为$x>=2,y>=2,z>=2$

所以$xy+yz<xyz+xz$

#### 答案：

我们可以发现按照1分一定是最优方案，那么答案就可以表示为$2*3+3*4+...+n(n-1)$

所以接下来就是代码

### 代码：
```cpp
# include <bits/stdc++.h>
using namespace std;
int main()
{
	int ans = 0;
	int n;
	cin >> n;
	for (int i = 1; i + 2 <= n; i++)
	{
		ans += (i + 1) * (i + 2);
	}
	cout << ans << endl;
	return 0;
}
```

谢谢观看

---

## 作者：SIGSEGV (赞：1)

直接写了个区间 dp（这题有加强版：每个点的点权从输入中读取）

令 $dp_{i,j}$ 表示从点 $i$ 到点 $j$ 表示的区间内，三角划分的最小权值和为多少。

则显然 $dp_{i,j}=\min\{{dp_{i,k}+dp_{k,j}+ijk}\}$
(将 $i,j,k$ 三个点组成一个划分，再加上 $i$~$j$,$j$~$k$ 两段)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
long long dp[505][505];
int main ()
{
    scanf("%d",&n);
    memset(dp,-1,sizeof(dp));
    for (int i = 1;i < n;i++) dp[i][i + 1] = 0;
    for (int len = 3;len <= n;len++)
        for (int i = 1;i + len - 1 <= n;i++)
        {
            int j = i + len - 1;
            for (int k = i + 1;k < j;k++)
                if (dp[i][j] == -1 || dp[i][j] > dp[i][k] + dp[k][j] 
                    + i * j * k) 
                    dp[i][j] = dp[i][k] + dp[k][j] + i * j * k;
        }
    printf("%I64d",dp[1][n]);
    return 0;
}
```

---


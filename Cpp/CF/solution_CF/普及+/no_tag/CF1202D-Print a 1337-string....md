# Print a 1337-string...

## 题目描述

$PS:$子序列是能通过删除原序列一些元素并不更改原序列元素位置得到的序列。

给你一个数$n$，求出一个有$n$个子序列为$1337$的序列，序列长度不能大于$10^5$。

举个例子，序列$337133377$有$6$个子序列为$1337$

1. 337**133**3**7**7
1. 337**13**3**37**7
1. 337**1**3**337**7
1. 337**133**37**7**
1. 337**13**3**3**7**7**
1. 337**1**3**33**7**7**

$PS:$加粗为选中的元素

## 样例 #1

### 输入

```
2
6
1
```

### 输出

```
113337
1337```

# 题解

## 作者：皎月半洒花 (赞：9)

智商题。

其实大家都想到了`13..37`的形式，但是我当时就一心想着要质因数分解分解成$\frac{k(k-1)}{2}$的形式……

所以其实我们把剩下的`7`放到开头的`133`后面就好了，即`13377..73333..37`。

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>

using namespace std ;
int N, T, L1, L2 ;

int main(){
    cin >> T ;
    while (T --){
        cin >> N ; int p = sqrt(2*N);
        for (int i = p ; i <= 2*N ; ++ i){
            if (i * (i - 1) > 2 * N) break ;
            L1 = i * (i - 1) / 2, L2 = N - L1, L1 = i ;
        }
        printf("133") ;
        for (int i = 1 ; i <= L2 ; ++ i) putchar('7') ;
        for (int i = 1 ; i <= L1 - 2 ; ++ i) putchar('3') ;
        printf("7\n") ;
    }
}

```

---

## 作者：installb (赞：7)

构造题  
首先如果不考虑长度限制 很容易想到这样一种构造方式:  
```cpp
13377...7
```
前面$133$的选择是确定的 所以有多少个$7$就代表有多少种方法取出$1337$  
**相当于每一个$7$会对方案数产生$1$的贡献**  

但是这样不满足长度限制  
所以我们要让$3$选择的余地多一点 使得$3$不仅仅有两个  
于是构造出来这样一个式子:  
```cpp
133...3377...7
```
这里假设有$n$个$3$和$m$个$7$  
选取$1$的方式有$1$种  
选取$3$的方式有$C_n^2=\frac{n(n-1)}{2}$种  
选取$7$的方式有$m$种  

都是任意取 所以乘法原理乘起来是$\frac{mn(n-1)}{2}$  
**相当于每一个$7$会对方案数产生$\frac{n(n-1)}{2}$的贡献**

但是题目中给定的数不一定能表示成这样 所以考虑把上面两种想法结合起来  
首先在$133$确定的情况下加上$k$个$7$ 然后加上$n-2$个$3$ 最后加上$m$个$7$  

```cpp
133 77...77 33...33 77...77
```

这样前面的$7$每一个会对答案产生$1$的贡献 后面的$7$每一个会对答案产生$\frac{n(n-1)}{2}$的贡献  

方案数为 $m\times \frac{n(n-1)}{2}+k$  
令这里$0\leq k < \frac{n(n-1)}{2}$  

这样已经可以**表示所有正整数**了

为了保证$10^5$的长度限制 这里要合理选取$n$的大小  

假设$N=\frac{n(n-1)}{2}$  
这里直接考虑最劣情况 令$k=N-1$ $M = \frac{10^9}{N}$  
所以$N+n-1+\frac{10^9}{N}\leq 10^5$  

这里$N$取一个$30000$左右的数就可以了 实际上它的取值范围还挺广的 只要算出来对 答案随你取了  

我这里$n$选择了300 这样$N$是$45150$ 是可行的  

讲得差不多了把...上代码了  
**code:**  
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long LL;
const LL INF = 0x3f3f3f3f3f3f3f3f;

LL n,m,k,T;
LL cac = 0;
LL a[500005] = {0};

int main(){
	ios::sync_with_stdio(false);
	cin >> T;
	LL K = 300; // K 就是上文的 n
	while(T --){
		cin >> n;
		LL t1 = K * (K + 1) / 2,t;
        // t1是上文的 N
		t = n / t1;
		LL tmp = n - t1 * t;
        // tmp是上文的 k
        
		cout << "133";
		for(LL i = 1;i <= tmp;i ++) cout << '7';
		for(LL i = 1;i < K;i ++) cout << '3';
		for(LL i = 1;i <= t;i ++) cout << '7';
        // 构造过程
        
		cout << endl;
	}
	return 0;
}
```

---

## 作者：yinqf (赞：2)

### Part1 题目大意

给你一个数 $n$，求出一个有 $n$ 个子序列为 $n$ 的序列，序列长度不能大于 $10^5$。\
如：$337133377$ 有 $6$ 个字串\
$1 \le n\le 10^9 $。

### Part2 做法介绍

很容易想到在 ```1337``` 的两个 ```3``` 之间加上一些 ```3``` 让答案变成 $\frac{x(x-1)}{2}$ 的样子 。

但是有些时候答案并不刚好是 $\frac{x(x-1)}{2}$，所以还要找到一个小于 $n$ 的最大 $\frac{x(x-1)}{2}$ 然后添上一些合法子序列让它刚好可以等于 $n$。

具体操作：例如 ```1333337``` 变为 ```13377773337```。

其中在 ```133``` 后面添加 ```7``` 使得增加一些合法子序列，并且一个 ```7``` 只会带来一个合法子序列，可以刚好凑出 $n$。

这个构造方法长度不会超过 $10^5$。

两个 $\frac{x(x-1)}{2}$ 和 $\frac{(x-1)(x-2)}{2}$ 最多相差 $x$，并且 $x=\sqrt{n}$ 大约是 $44721$ 不会超。

### Part3 完整代码

```cpp
#include<bits/stdc++.h>
#define faster ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define LL long long
using namespace std;
const int N=1e5+5;
int T,n,num3,num7;
int main()
{
    faster;
    cin >> T;
    while(T--)
    {
        cin >> n;
        for(int i=44721;i>=2;i--)
        {
            if(i*(i-1)/2<=n)
            {
                num3=i;
                num7=n-i*(i-1)/2;
                break;
            }
        }
        cout << "133";
        for(int i=1;i<=num7;i++)
        {
            cout << '7';
        }
        for(int i=3;i<=num3;i++)
        {
            cout << '3';
        }
        cout << "7\n";
    }
    return 0;
}
```

---

## 作者：xuorange (赞：1)

我们先来找找规律：

|  数字|  13337|  1333337|  133777|  111337|
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  含有1337的个数|  3|  10|  3|  3|

显然后两种比较简单，于是直接开始试。

```
#include<iostream>
using namespace std;
int main(){
	int q,n;
	cin>>q;
	while(q--){
		cin>>n;
		cout<<"133";
		while(n--)cout<<"7";
		cout<<endl;
	}
	return 0;
}
```
然后TLE了。

也就是说不能只插入效率低的 $1$ 和 $7$ ，应该再来一些 $3$ 。

|  数字|  1337|  13337|  133337|  1333337|  13333337|  133333337|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|  含有1337个数|  1|  3|  6|  10|  15|  21|

说明，在有 $x$ 个 $3$ 、 $1$ 个 $1$ 、 $1$ 个 $7$ 时， $1337$ 的个数为 $x(x-1)/2$ 个。

但 $x(x-1)/2$ 这种整数比较罕见（如 $1,3,6,10$ 等），我们还应该插入一些 $1$ 或 $7$ （在这里我选的是 $1$ ，你也可以用 $7$ ）。

所以可以取小于n（题目要求的1337子序列的个数）的第一个 $x(x-1)/2$ ，再通过插入若干个1补上需要的 $n-x(x-1)/2$ 个 $1337$ 即可。

由于我这个解法用了预处理（暴力枚举 $x(x-1)/2$ ），所以代码很容易理解。

Code（无陷阱）
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
ll n,C[114514];
int main(){
    int t;
    cin>>t;
    for(ll i=1;i<=114514;i++) //暴力枚举x(x-1)/2
        C[i]=i*(i-1)/2;
    while(t--){
        scanf("%lld",&n);
        ll orange=1;
        while(C[orange+1]<=n)orange++;
        if(C[orange]==n){ //运气好
            cout<<1;
            for(int i=1;i<=orange;i++)cout<<3;
            cout<<7<<'\n';
            continue;
        }
        for(int i=orange;i>=2;i--){
            while(n>=C[i]){
                n-=C[i];
                printf("1");
            }
            cout<<3;
        }
        cout<<3; //别落下3
        cout<<7<<'\n';
    }
}
```


---

## 作者：brealid (赞：0)

约定：$D_{(x)}$ 表示数字 $D$ 重复 $x$ 次  
例：$3_{(2)}\ 7\ 1\ 3_{(3)}\ 7_{(2)}$ 表示 $337133377$

### 对于 $n + 3 <= 10^5$

可以构造 $1_{(n)}\ 3\ 3\ 7$，显然满足

### 对于 $n + 3 > 10^5$

这里各显神通，很容易可以想到 $\sqrt{n}$ 级别的一些构造方法。

我的一种构造方式：  
$1\ 3\ 1_{(a)}\ 3\ 7_{(b)}\ 3\ 7_{(d)}$  
易得，该种方式的 $1337$ 子串个数为 $b+(a+3)c$

取 $c = \lfloor\sqrt{n}\rfloor, a=\lfloor\frac{n}{c}\rfloor-3,b=n-(a+3)c$ 即可  
其中，$a,b,c$ 均是 $\Theta(\sqrt{n})$ 级别的，所以总共字符数 $≈3\sqrt{n}+4 ≈ 94870 \le 10^5$，可以通过

之所以要特判 $n$ 较小的部分，是为了防止 $a$ 在计算中变为负数。

```cpp
// kin 可以理解为 cin, kout 可以理解为 kout
int T, n;

signed main() {
    kin >> T;
    while (T--) {
        kin >> n;
        if (n <= 1000) { // 只要是 1e5 下一个较大的整数均可
            for (int i = 1; i <= n; ++i) kout << '1';
            kout << "337\n";
            continue;
        }
        int c = sqrt(n), a = n / c - 3, b = n - (a + 3) * c;
        kout << "13";
        for (int i = 1; i <= a; ++i) kout << '1';
        kout << '3';
        for (int i = 1; i <= b; ++i) kout << '7';
        kout << '3';
        for (int i = 1; i <= c; ++i) kout << '7';
        kout << '\n';
    }
    return 0;
}
```

---


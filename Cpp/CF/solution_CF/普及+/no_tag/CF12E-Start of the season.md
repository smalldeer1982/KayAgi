# Start of the season

## 题目描述

在伯兰的足球节开幕式中有一个奇怪的魔术秀。最有经验的魔术师会找一个n×n的矩阵（n为偶数）。足球节没有这个魔术秀绝对不会开始。这个矩阵应该包含0~n-1的正整数，且包含以下三条规则：

1、主对角线上的数应该都是0

2、且整个矩阵应该都是对称的

3、每行每列上的数都是不同的。

魔术师很不喜欢一遍又一遍的接矩阵（魔术师真懒），于是就请你写一个程序来帮助他们解决矩阵问题。

## 样例 #1

### 输入

```
2
```

### 输出

```
0 1
1 0
```

## 样例 #2

### 输入

```
4
```

### 输出

```
0 1 3 2
1 0 2 3
3 2 0 1
2 3 1 0
```

# 题解

## 作者：Durancer (赞：9)

#### 思路

一开始手模一下样例，你就会发现一个很神奇的规律

把 $0$ 的位置填上这一列（这一行）最后的那个数你就会发现

原本的矩阵是这样的（并不是按照样例来的）

```
0 2 3 1
2 0 1 3
3 1 0 2
1 3 2 0
```
填完之后的是

```
1 2 3 0
2 3 1 0
3 1 2 0
0 0 0 0

```
我们可以发现这是 $n-1$个 $1…n-1$的全排列
并且可以发现的是，第 $i$ 列是以 $i$ 开头的一个按顺序来的全排列，之后你就可以把 $(i,i)$位置上的数转移到所在行列的最后，然后把这个位置赋值为 $0$ ，就构造出来一个符合条件的矩阵啦O V O

#### 代码实现

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
#include<queue>
#include<stack>
#include<cmath>
using namespace std;
const int N=2009;
int jux[N][N];
int n;
int main()
{
	cin>>n;
	for(int i=1;i<=n-1;i++)
	{
		int k=i;
		for(int j=1;j<=n-1;j++)
		{
			jux[j][i]=k;
			k++;
			if(k==n) k=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		jux[i][n]=jux[n][i]=jux[i][i];
		jux[i][i]=0;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		cout<<jux[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}

```


---

## 作者：米奇奇米 (赞：7)

```cpp

#include<iostream>
#include<cstring>
using namespace std;
const int mm=1007;
int map[mm][mm];
int n;
int main()
{
  while(cin>>n)
  { 
    n--;
    memset(map,0,sizeof(map));//数组清零
    for(int i=0;i<n;i++)
      for(int j=0;j<n;j++)
      map[i][j]=(i+j)%n+1;//对每个各自进行巧妙的赋值
     for(int i=0;i<n;i++)
      map[i][n]=map[n][i]=map[i][i],map[i][i]=0;//把对角线变为0，同时形成对称图形
     for(int i=0;i<=n;i++)
      {cout<<map[i][0];//输出即可
      for(int j=1;j<=n;j++)
      {
       cout<<" "<<map[i][j];
      }
       cout<<"\n";
      }
  }
}
```

---

## 作者：FiraCode (赞：2)

## 题解思路

首先构造一个序列，他满足第二个条件：

```
1 2 3 4 5
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
```

然后我们把中间换成 $0$：

```
0 2 3 4 5
2 0 4 5 1
3 4 0 1 2
4 5 1 0 3
5 1 2 3 0
```

然后再把变成 $0$ 的给添到后面：

```
0 2 3 4 5 1
2 0 4 5 1 3
3 4 0 1 2 5
4 5 1 0 3 2
5 1 2 3 0 4
1 3 5 2 4 0
```

然后就可以了！

## AC CODE:

```cpp
#include 
#include 
using namespace std;
const int N = 1010;
int n;
int a[N][N];
int main() {
    cin >> n;
    for (int i = 0; i < n; ++ i)
      for (int j = 0; j < n; ++ j)
	        a[i][j] = (i + j) % (n - 1) + 1;//处理一个对称矩阵
    for (int i = 0; i < n; ++ i) {
	      a[i][n - 1] = a[n - 1][i] = a[i][i];//把他填在后面
	      a[i][i] = 0;//替换成0
    }
    for (int i = 0; i < n; ++ i) {
    	  for (int j = 0; j < n; ++ j)
  	  	    cout << a[i][j] << ' ';
  	  	cout << endl;
    }
    return 0;
}
```

---

## 作者：Asrit (赞：2)

## 瞎扯部分

这道题卡了我好长时间（我太菜了QWQ）：

瞬间做出3条件发现忘了考虑 $2$ 条件；

然后做2条件发现又忘了考虑 $3$ 条件；

怎么也想不出来了去看题解结果没有看懂，抄上了式子依旧 $\textcolor{red}{WA}$；

最后打算自己想，结果训练时间到了，这道题依旧没想出来 QAQ。

当天晚上在脑子里“脑玩”了几个数据总结出来一个奇奇怪怪的规律，最后竟然 $\textcolor{green}{AC}$ 了。

## 奇怪的正解部分

由于这个矩阵是对称的，我们可以考虑只求出右上那一半然后对称下去（当然求左下也可以 QWQ）。

先不考虑对称后行列不相同的情况：

我把第一行的数按顺序排，然后之后每次就往前挪一个数字，因此第 $1$ 行第 $2$ 列的数是 $1$ （第一列是 $0$ ），之后第 $i$ 行第 $i+1$ 列就应该是第 $i-1$ 行第 $i$ 列的数 $+2$ （因为第 $i-1$ 行第 $i+1$ 列的数是第 $i-1$ 行第 $i$ 列的数加 $1$ ，第 $i$ 行第 $i+1$ 列是第 $i-1$ 行第 $i+1$ 列的数 $+1$ ）。

（别忘了 $\%n!\space$ $\%n$ 后等于 $0$ 要变成 $1$ ！）

然后在考虑对称后的情况：

对称后，第 $i$ 行第 $j$ 列的数就到了第 $j$ 行第 $i$ 列，这时我们考虑那一半中第 $i$ 行的所有数就要和第 $i$ 列的所有数是不同的（应该很好懂吧，想不懂的同学可以往死里想）。这是维护一个二位的 $visit$ 的桶，如果已经填过了就直接加 $1$ 跳过这个数。另外同时也要判断列之间是否重复，也是用 $visit$ 判断并跳过，这样就完成了。

时间复杂度自己算的是 $O(n^2)$ ，应该没算错，$n=1000$ 可以过。

感觉上面讲的不是太好懂，那就贴代码康康吧：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define rep(i,a,b) for(int i=(a);i<b;i++)
using namespace std;
int n,nw,j,v[1001][1001],mp[1001][1001];//v是visit，mp是答案
int main(){
	scanf("%d",&n);
	mp[0][1]=-1;
	rep(i,1,n){
		j=i+1;//当前要填的数的第二位
		nw=(mp[i-1][i-1+1]+1)%n;//现在要填的数，+1而不+2是因为循环中有一次加1
		while(j<=n){
			nw++;
			nw%=n;//nw加1，%n
			while(v[i][nw]||v[j][nw]){
				nw++;
				nw%=n;
				if(!nw)	nw=1;//如果变为0就强制变为1
			}//如果跟行有冲突或跟列有冲突就接着加
			mp[i][j]=nw;
			v[j][nw]=1;
			j++;
		}
	}
	rep(i,1,n){
		rep(j,1,n){
			if(j<i)	printf("%d ",mp[j][i]);
			else printf("%d ",mp[i][j]);
		}
		printf("\n");
	}//输出
	return 0;
}
```
感觉代码可能有点 bug（打的有点心浮气躁），希望大家发现能指出QWQ

当然有避免抄袭故意改的 $2$ 处 QWQ

希望看这篇题解的人都能理解并自己做出来

---

## 作者：yzc20100218 (赞：0)

### CF12E 题解
首先，看看样例里面给出的矩阵：
```
0 1 3 2
1 0 2 3
3 2 0 1
2 3 1 0
```
我们将 $0$ 和所在行列的数换一下，矩阵如下：
```
2 1 3
1 3 2
3 2 1
```
我们可以看到这是一个满足 $2,3$ 条件的 $\left(n-1\right)\times\left(n-1\right)$ 的矩阵。

我们不妨反过来想，我们先构造这样一个奇数矩阵，现在我们需要其对角线为 $0$，将对角线改为 $0$ 之后，矩阵依旧满足条件 $2$。  
然而我们需要偶数矩阵，可以将对角线上的进行平移，一定满足每行（向右平移），每列（向下平移），这时我们只需要要求矩阵对角线上的数字互不相同即可。

所以，现在我们来想办法构造一个矩阵（如第 $2$ 个矩阵），其满足主对角线上的数互不相同，并且满足条件 $2,3$ 的奇数边长矩阵。  

这个时候，我们会想到一种简单的构造方法——滚动全排列！

全排列，顾名思义，就是 $1\sim n$ 打乱后重新组成的一个 $n$ 个元素的数列。我们让第一行为最小的全排列即 $1,2,...,n$，然后让这个数列滚动起来，比如，第 $i$ 行，$i,i+1,...,n,1,2,...,i-1$ 就可以啦！

这是行列互不相等且以对角线为轴对称矩阵的构造质之一，对于这里每 $1$ 行每 $i$ 列都是一个全排列，但是这种代码并不好写，但是我先给出：

```cpp
for(int i = 1;i <= n;i++)
{
	int k = 1;
	for(int j = i;j <= n;j++)
	{
		a[i][k] = j;
		k++;
	}
	for(int j = 1;j < i;j++)
	{
		a[i][k] = j;
		k++;
	}
}
```
现在，我们来看一个比较易写的结论，```a[i][j] = (i + j) mod n + 1```。

我们验证一下这个结论：（涉及一些数论基础内容，可以跳过）  
对于 ```a[i][i]```，其值为 $2\times i$，根据一点点数论知识，我们知道它们构成了一个模 $n$ 的完全剩余系，所以各不相同；  
对于对角线对称的点，他们的行数和列数互换，其和不变，故满足；  
对于同行同列的点，其行数或列数相等，另一个行数或列数各不相同，其和为 $n$ 个连续正整数，也构成模 $n$ 的完全剩余系，也满足。

注意：我们要满足里面没有 $0$，所以必须加上 $1$。

这样一个满足条件 $2,3$ 的奇数边长矩阵就写好了。

现在可以将主对角线的数平移了：  
```a[i][n] = a[n][i] = a[i][i];```

再修改主对角线的数为 $0$：  
```a[i][i] = 0;```

题目到这里就写完了，提供代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1005][1005];
int sum;

int main()
{
    int n;
    cin >> n;
    n--;
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            a[i][j] = (i + j) % n + 1;
        }
    }
    n++;
    for(int i = 1;i <= n;i++)
    {
        a[i][n] = a[i][i];
        a[n][i] = a[i][i];
        a[i][i] = 0;
    }
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            cout << a[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

最后，补充一下，如果要求 $n$ 为奇数。  
同理，可以构造边长为偶数的全排列矩阵，再平移加改 $0$ 即可。

---

## 作者：Mx_sky (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/CF12E)

很明显，此题要求我们构造一个矩阵，需要满足以下条件：
- 主对角线上的数应该都是 $0$。
- 整个矩阵都是对称的。
- 每行每列上的数都是不同的。

我们先构造一个满足条件 $2$ 的矩阵（如果先满足条件  $1$，那么会被条件 $2$ 覆盖。）（本例构造一个 $4 \times 4$ 的矩阵）：
```
1 2 3 4
2 3 4 1
1 4 3 2
4 3 2 1
```
找下规律可以发现，$(i,j)$ 上的数是 $(i+j) \bmod (n-1)+1$。

可以打出以下代码：
```cpp
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            a[i][j]=(i+j)%(n-1)+1;
```
接下来主对角线上的数变 $0$：
```
0 2 3 4
2 0 4 1
1 4 0 2
4 3 2 0
```
把此矩阵的主对角线上的数变 $0$ 前，可以发现：
```cpp
a[i][n-1]=a[n-1][i]=a[i][i];
```
则接下来的代码是：
```cpp
for(int i=0;i<n;i++)
{
    a[i][n-1]=a[n-1][i]=a[i][i];
    a[i][i]=0;
}
```
然后就可以输出提交了！
### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1003;
int n,a[maxn][maxn];
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            a[i][j]=(i+j)%(n-1)+1;
    for(int i=0;i<n;i++)
	{
	    a[i][n-1]=a[n-1][i]=a[i][i];
		a[i][i]=0;
	}
    for(int i=0;i<n;i++)
    {
	    for(int j=0;j<n;j++)cout<<a[i][j]<<" ";
	    cout<<endl;
	}
    return 0;
}
```


---

## 作者：ncwzdlsd (赞：0)

找规律构造的小清新绿题。

举个栗子，$n=6$ 时,构造一个 $1\sim n-1$ 的每行每列数字不重复的矩阵：
$$
\begin{bmatrix} 1&2&3&4&5\\2&3&4&5&1\\3&4&5&1&2\\4&5&1&2&3\\5&1&2&3&4 \end{bmatrix}
$$
显然满足条件，于是乎，我们把对角线移到最后一列，并把对角线变成 $0$。
$$
\begin{bmatrix} 0&2&3&4&5&1\\2&0&4&5&1&3\\3&4&0&1&2&5\\4&5&1&0&3&2\\5&1&2&3&0&4 \end{bmatrix}
$$
然后我们再把最后一行补上。
$$
\begin{bmatrix} 0&2&3&4&5&1\\2&0&4&5&1&3\\3&4&0&1&2&5\\4&5&1&0&3&2\\5&1&2&3&0&4\\1&3&5&2&4&0 \end{bmatrix}
$$
完结撒花！

由上面的例子，我们就可以知道如何构造矩阵啦！

友情附赠代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
static const int MAXN=1e3+5;
int g[MAXN][MAXN];
int n;
int main()
{
    cin>>n;
    for(int i=1;i<=n-1;i++)
        for(int j=1;j<=n-1;j++)
            g[i][j]=(i+j-1<n?i+j-1:(i+j-1)%n+1);
    for(int i=1;i<=n;i++) g[i][n]=g[i][i],g[i][i]=0;
    for(int i=1;i<n;i++) g[n][i]=g[i][n];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
            printf("%d ",g[i][j]);
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：Timmy_ (赞：0)

# 思路

题我就不多说了，大家自己看

看见这个题，我第一反应是为什么 $n$ 必须是偶数，为什么不能是奇数呢。

后来发现，如果 $n$ 是奇数的话这题直接无解，因为无论如何都做不到在满足条件一和条件三的情况下满足条件二（这步自己想，我就不讲了）。最后只能做到两种情况——中轴轴本身不能对称并且中轴上的数字互不相同，或者除了中轴数字全是 0 并且其他都不对称

```cpp
0 1 2
2 0 1
1 2 0

2 1 0
1 0 2
0 2 1

```

那让我们仔细看看第二个矩阵，规律是每行都是上一行的第一个元素挪到了最后一个，这个矩阵好像有可能把这个 $3*3$ 的矩阵转换成一个  $4*4$ 矩阵

先变成这个样子

```cpp
3 2 1 ?
2 1 3 ?
1 3 2 ?
? ? ? ?
```

之后把中轴全填上 0

```cpp
0 2 1 ?
2 0 3 ?
1 3 0 ?
? ? ? 0
```

现在我们会发现，每行每列正好缺少在中轴上的那些被 0 覆盖的数字，而那被覆盖的数字正好互不相同，那么我们就可以把那些被 0 覆盖的数字填到现在问号的位置

那么

```cpp
0 2 1 3 
2 0 3 1
1 3 0 2
3 1 2 0

```

虽然这个结果好像跟样例不太一样

但不是都说了有多个答案吗，只要符合就行，而且这个挺符合的


# AC CODE
```cpp
#include <iostream>
using namespace std;
int n;
int s[1005][1005];
int main()
{
	int i,j;
	cin>>n;
	n--;//先构造奇数列的矩阵，所以n先减一
	for(i=1; i<=n; i++)//先把第一行赋值了
		s[1][i]=i;
	for(i=1; i<n; i++)
	{
		s[i+1][n]=s[i][1];//把上一行的第一个元素挪到最后一个
		for(j=1; j<n; j++)
			s[i+1][j]=s[i][j+1];//其他元素都往前挪一个元素因为第一个元素被移走了
	}
	n++;
	for(i=1; i<=n; i++)
		s[n][i]=s[i][i],s[i][n]=s[i][i],s[i][i]=0;//把中轴的元素挪到两边，中轴添上0
	for(i=1; i<=n; i++)
	{
		for(j=1; j<=n; j++)
			cout<<s[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```










---

## 作者：dingshengyang (赞：0)

首先，对称！

什么是“对称”？答：在同一条对角线上，自然对称。

对角线？你想到了什么？我想到了八皇后。

还记得八皇后是怎么判断是否在一条对角线上的吗？

```(x+y)%n``` 和 ```(y-x+n)%n```，对吧？此处思路相同！

然鹅……这是不行的，需要改一下。

```ans[i][j] = (i + j) % (n - 1) + 1;```

至于为什么这样，我也不知道……
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int ans[1010][1010];

int n;

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n - 1; i ++ )
        for (int j = 0; j < n - 1; j ++ )
            ans[i][j] = (i + j) % (n - 1) + 1;

    for (int i = 0; i < (n - 1); i ++ )
    {
        ans[i][n - 1] = ans[n - 1][i] = ans[i][i];
    }

    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < n; j ++ )
        {
            if(i == j) printf("0 ");
            else printf("%d ", ans[i][j]);
        }
        puts("");
    }
    return 0;
}
```

---


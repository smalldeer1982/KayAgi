# Different Rules

## 题目描述

## 题意简述

一项奥林匹克竞赛有着与普通竞赛不同的规则，它分成两轮，假如一位参赛者在第一轮中排名第 $x$ 名，在第二轮中排名第 $y$ 名，则他的总分是 $x+y$，他的总排名是总分小于等于 $x+y$ 的参赛者（包括他自己）。需要注意的是，每一轮比赛都不会出现并列的情况，每一个排名 $i$ 都对应了唯一的参赛者。

尼古拉被告知他第一轮排名第 $x$ ，第二轮排名第 $y$ ，他需要你帮助他算出他可能获得的最好总排名和最差总排名

## 样例 #1

### 输入

```
1
5 1 3```

### 输出

```
1 3```

## 样例 #2

### 输入

```
1
6 3 4```

### 输出

```
2 6```

# 题解

## 作者：xlqs23 (赞：5)

**题意**

有n位参赛者参加两轮比赛，小明同学获得的名次是x和y，其他人的名次是未知的，求小明在两次比赛中的最高排名和最低排名，排名要求是相当于，第几名就扣多少分，最好扣分越少的参赛者排名越高，假设扣分相同，则所有人都排当前的最好一名。


**思路**

1.先来看看最差名次，最差名次很好想，尽量多构造和小明同学扣分数相同的参赛者，小明的最终扣分为$x+y$

1 $x+y-1$

2 $x+y-2$

… …

$x$ $y$

… …

$x+y-1$ 1

最终小明的排名为$min(n,x+y-1)$

2.再来看看最高名次，当$x+y<n+1$时，可以构造

1 $n$

2 $n-1$

… …

$n$ 1

当然这时候小明就排到了第一名
当$x+y>=n+1￥时，就可以先让扣分少的组合在一起

1 1

2 2

… …

$x$ $y$

再把第一名去掉后的排名就是$x-1+y-1$；最好怎么来确定其排名
才是本题的关键，依次进行上一步骤 $x-t+y-t=n-t$时，这就先组合了$t$组排名高的，$t=x+y-n$，那么多个人，最好小明就排在$t+1$位，所有其最高名次为$min(n,x+y-n+1)$

**代码如下**

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,x,y;
		scanf("%d%d%d",&n,&x,&y);
		if(x>y)	swap(x,y);
		int ansx,ansi;//最差名次,最好名次 
		ansx=min(n,x+y-1);
		if(x+y<n+1)	ansi=1;
		else	ansi=min(n,x+y-n+1);
		printf("%d %d\n",ansi,ansx);
	}
	return 0;
}

---

## 作者：Andrewzdm (赞：2)

# [CF1313B Different Rules](https://www.luogu.com.cn/problem/CF1313B)
## 结论
这题是道货真价实的数学题。
首先，结论如下。
$1.MIN\_PLACE=max(1,min(n,x+y-n+1))$
$2.MAX\_PLACE=min(n,x+y-1)$

其实这道题的思考过程不好引入，就是找规律得来的。
为了减少分类讨论的情况个数，我们默认$x<y$。
### 有关$MAX\_PLACE$
我们首先先来探究 $MAX\_PLACE$：
#### Case 1:
不难发现，当 $x+y \ge n+1$时，$MAX\_PLACE=n$
#### Case 2:
然后，当$x+y<n+1$时，为了让place尽可能大，需要让其它的sum能排在它前面的就排在它前面。

来个具体的例子

`1 2 3 4 5 6` first round

`1 2 3 4 5 6` second round

设$x=2,y=4$，可以列出最佳的方案为

第一轮名次| 第二轮名次| sum| 最终名次
---------|----------|----|--------------
   1|         5|       6|       5
   2|         4|               6|           5 
   3|         3|               6|           5
   4|         2|               6|           5
   5|         1|               6|           5
   6|         6|               12|         6
                   
最后我们可以得出：凡是第一轮名次$\ge x+y$的都不可能排到x+y的前面，剩下的都可以排到x+y的前面。
而第一轮名次$\ge x+y$的人的数量为$n-(x+y)+1$，
所以第一轮名次$<x+y$的人的数量为$x+y-1$，
所以$MAX\_PLACE=x+y-1$.

把上面这两个式子合并即可得到
$MAX\_PLACE=min(n,x+y-1)$
### 有关$MIN\_PLACE$
接下来我们来探究$MIN\_PLACE$：
**（case特别多）**
#### Case 1:
首先，还是不难发现当$x+y<n+1$时$MIN\_PLACE=1$
#### Case 2:
其次，当$x+y\ge n+1;y \neq n$时，
获得第一轮前 $k$ 个名次$(k \le x+y-n)$的人最终一定$sum \le x+y-n+n=x+y$（因为n就是它们第二轮可以获得的最高名次），
所以$MIN\_PLACE=x+y-n+1$。
#### Case 3:
然后，当$x+y\ge n+1;y=n$时，
获得第一轮前 $k$ 个名次$(k \le x+y-n)$的人最终一定$sum \le x+y-n+n-1=x+y-1$，即$sum<x+y$（因为n+1就是它们第二轮可以获得的最高名次），
所以$MIN\_PLACE=x+y-n+1$。
#### Case 4:
分类讨论似乎到这里就结束了诶OvO!

然而这里有个比较容易被忽略的细节，我们此处要特判$x=y=n$的情况，因为这种情况出来的$MIN\_PLACE$为$n+1$，但是这样的名次好比$tan 90°$——不存在的！不过这个特判非常简单，结果显而易见——$n$。

将Case 2~4合并为$MIN\_PLACE=min(n,x+y-n+1)$。

最后将所有Case合并为$MIN\_PLACE=max(1,min(n,x+y-n+1))$
### 其他
以上只是探究和思考过程，具体证明请看[此处](https://codeforces.com/blog/entry/74146)，这里不再赘述。

这道题比较考验思维，大家 ~~感性理解~~ 理性分析即可。

附上最终代码：

```cpp
#include<iostream>
using namespace std;
void solve()
{
	int n, x, y;
	cin >> n >> x >> y;
	cout << min(max(x + y - n + 1, 1), n) << ' ';
	cout << min(x + y - 1, n) << endl;
	return;
}
int main()
{
	int t;
	cin >> t;
	while(t--)
		solve();
	return 0;
}
```
时间复杂度$O(1)$

---

## 作者：Isprime (赞：2)

毒瘤B题……

我……#@&*（）#（@*%……#&（）*——

我才不会告诉你我在上网课的时候跑来写题解

扯远了

## 思路

一看数据范围$1≤n≤10^9$

O(N)的做法肯定都挂了，看来得推式子

先看最好排名

显然，想要求最好排名，就要让第一轮的rk1第二轮排名尽量低

也就是说第一轮的rk1要得到 $1+n$ 的总分

rk2,rk3等同理

如果 $1+n>x+y$，那么最好排名就是rk1

那么 $1+n$ 小于等于 $x+y$ 怎么办呢

那就让第一轮rk1也拿第二轮rk1

第一轮rk2拿第二轮rkn，他的总分就是 $2+n$

以此类推，第一轮rki的总分就是 $n+i$

我们只需要找到最小的 $i$ 使得 $i+n>x+y$ ,这时 $i+1$ 就是答案

(为什么不是i？再去看看题目，总排名是**小于等于** $x+y$ 的参赛者数量 **（包括自己）**

所以$ans_{min}=min(max(x+y-n+1,1),n)$

来解析这个式子，为什么要取 $x+y-n+1$ 和 $1$ 的max？

前文提到过，如果 $1+n>x+y$，那么就是rk1

这时很有可能 $x+y<n$ ，$x+y-n+1$ 就会得到0或负数，不符合题意，所以要取它和 $1$ 的max

那为什么要取 $max(x+y-n+1,1)$ 和 $n$ 的min？

来看这组数据，$x=y=n$，这时$max(x+y-n+1,1)$就会等于 $n+1$，不符合题意，所以要取它和 $n$ 的min

再看最差排名

还是题目中的那句话：总排名是**小于等于** $x+y$ 的参赛者数量 **（包括自己）**

所以这个问题转变为了求出有多少人总分等于 $x+y$

答案很显然，$x+y-1$

所以这个式子是 $max(min(n,x+y-1),1)$

式子中取了min

为什么取min呢？

考虑 $x+y>n+1$ 的情况， $x+y-1$ 就会大于 $n$，不符合题意，所以取min

## 实现

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;
int t;
int n,x,y;
signed main() {
	scanf("%d",&t);
	while(t--) {
		scanf("%d%d%d",&n,&x,&y);
		int s1=min(max(x+y-n+1,1),n),s2=min(n,x+y-1);
		printf("%d %d\n",s1,s2);
	}
	return 0;
}
```

---

## 作者：123456zmy (赞：2)

题意：  
在两场比赛中，分别获得了 $x$ 和 $y$ 名，两次比赛的排名之和为选手的分数，求分数的排名的最值（排名从小到大，最大最小都要求，并列取最后一个）。
___
~~就是一个推公式题~~。最大的排名是前面的与它的分数相等的时候取到，就是 $x+y-1$ 名；最小的排名在其它人的分数比他多 $1$ 时取到，就是 $x+y-n+1$，同时注意防止算出来的结果超过 $n$ 或少于 $1$。

代码：（~~最关键的就是这一行，其它的就不放了~~）
```cpp
printf("%d %d\n",min(max(x-n+y+1,1),n),min(max(x+y-1,1),n));
```

---

## 作者：柠檬草苏打水 (赞：1)

### Problem Restatement:
一项奥林匹克竞赛有着与普通竞赛不同的规则，它分成两轮，假如一位参赛者在第一轮中排名第x名，在第二轮中排名第 y名，则他的总分是x+y他的总排名是总分小于等于 x+y的参赛者（包括他自己）。

需要注意的是，每一轮比赛都不会出现并列的情况，每一个排名 i都对应了唯一的参赛者。

尼古拉被告知他第一轮排名第 x，第二轮排名第y，他需要你帮助他算出他可能获得的最好总排名和最差总排名.

### Solution:

你要想排名越前，第一场考的越好，第二场考的越差。但是如果出现第一场考的太好了，第二场最后一名都拯救不过来。那么就让他占两个第一就好。

比如：

1 2 3 4 5 6

1 2 3 4 5 6

你发现第一名怎么都在你前面或和你同分，就让它占两个第一即可。

1 3 2 6 5 4

1 4 6 2 3 5

你会发现，你的分是x+y。所以如果某场排名小于等于x+y−n的人都肯定在你前面，所以你的排名就是x+y−n+1。特判一下你两次都最后名的情况（因为这样就没人能拿第n名了），或者你考的太好可以拿第一的情况。

你要想排名越往后，你就把尽可能多的人和你同分即可。
比如：

1 2 3 4 5 6 7

1 2 3 4 5 6 7

你只需要让你周围的人尽可能都是7分

1 2 3 4 5 6 7

6 5 4 3 2 1 7

因为同分排名都靠后啊，这样后面的人也是最少的了。
可以发现，你的排名就是min(y+x−1,n)。

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
void solve(){
    int n,x,y,g,gg;
    scanf("%d %d %d", &n, &x, &y);
    if(x>y)swap(x,y);
    g=max(1,min(x+y+1-n,n));
    gg=min(y+x-1,n);
    printf("%d %d\n", g,gg);
}
int main(){
    int T;
    scanf("%d", &T);
    while(T--)solve();
    return 0;
}

---

## 作者：流绪 (赞：0)

结论题！

一共 n 个人比赛两轮，给出一个人在这两轮的排名 x,y，最终排名依据两轮排名和从小到大排。求这个人在最优和最差情况下最终排名是多少。

最优，最差，很显然是贪心。

该人的两轮排名确定，其他人的两轮排名虽然不确定，但是他们的全部人的和是确定的。

最优时，我们让其他每个人的排名和大于该人。为了让这个人排名尽量靠前，那么我们再加上一个条件，让其他人排名和尽量小，这样子能构造出的排名和比该人大的数量会更多。总和不变，要取的数越小，这个数可能取到的次数越多。

最差时，同理，我们让其他每个人的和小于等于该人，且尽量大。总和不变，要取的数越大，其他小的数可能取到的次数越多。

然后按上面的方法，纸上模拟几组数据，就能得到的规律：

⑴x+y<=n时,最优情况是 1，最差情况是 min(x+y-1,n)。

⑴x+y>n时,最优情况是 min(x+y-1,n)，最差情况是 n。

特判输出即可。

下面是 AC 代码。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define inf 0x7f7f7f7f
#define maxn 1000010
#define ri register int
#define il inline
using namespace std;
int main()
{
	ios::sync_with_stdio(0);
	int t;
	cin >> t;
	while(t--)
	{
		int n,x,y;
		cin >> n >> x >> y;
		if(x+y<=n)
			cout << 1<< " " << (min(x+y-1,n));
		else
			cout << (min(x+y-n+1,n)) << " " <<n;
		cout << endl;
	}
	return 0;
}
```


---


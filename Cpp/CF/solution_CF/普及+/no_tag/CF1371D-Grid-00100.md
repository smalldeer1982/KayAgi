# Grid-00100

## 题目描述

A mad scientist Dr.Jubal has made a competitive programming task. Try to solve it!

You are given integers $ n,k $ . Construct a grid $ A $ with size $ n \times n $ consisting of integers $ 0 $ and $ 1 $ . The very important condition should be satisfied: the sum of all elements in the grid is exactly $ k $ . In other words, the number of $ 1 $ in the grid is equal to $ k $ .

Let's define:

- $ A_{i,j} $ as the integer in the $ i $ -th row and the $ j $ -th column.
- $ R_i = A_{i,1}+A_{i,2}+...+A_{i,n} $ (for all $ 1 \le i         \le n $ ).
- $ C_j = A_{1,j}+A_{2,j}+...+A_{n,j} $ (for all $ 1 \le j         \le n $ ).
- In other words, $ R_i $ are row sums and $ C_j $ are column sums of the grid $ A $ .
- For the grid $ A $ let's define the value $ f(A) =         (\max(R)-\min(R))^2 + (\max(C)-\min(C))^2 $ (here for an integer sequence $ X $ we define $ \max(X) $ as the maximum value in $ X $ and $ \min(X) $ as the minimum value in $ X $ ).

Find any grid $ A $ , which satisfies the following condition. Among such grids find any, for which the value $ f(A) $ is the minimum possible. Among such tables, you can find any.

## 说明/提示

In the first test case, the sum of all elements in the grid is equal to $ 2 $ , so the condition is satisfied. $ R_1 = 1, R_2 =       1 $ and $ C_1 = 1, C_2 = 1 $ . Then, $ f(A) = (1-1)^2 + (1-1)^2       = 0 $ , which is the minimum possible value of $ f(A) $ .

In the second test case, the sum of all elements in the grid is equal to $ 8 $ , so the condition is satisfied. $ R_1 = 3, R_2 =       3, R_3 = 2 $ and $ C_1 = 3, C_2 = 2, C_3 = 3 $ . Then, $ f(A) =       (3-2)^2 + (3-2)^2 = 2 $ . It can be proven, that it is the minimum possible value of $ f(A) $ .

## 样例 #1

### 输入

```
4
2 2
3 8
1 0
4 16```

### 输出

```
0
10
01
2
111
111
101
0
0
0
1111
1111
1111
1111```

# 题解

## 作者：Guess00 (赞：6)

## 题解 CF1371D Grid-00100
首先，先看$f(A)$的最小值。
1. 当$k$是$n$的倍数时，尽可能让每一行每一列`1`的个数相等，使得$\max(R)=\min(R)=\max(C)=\min(C)$,于是$f(A)=0$最小。

2. 当$k$不是$n$的倍数时，尽可能让每一行每一列`1`的个数差最小，让某一些$R=\lfloor\dfrac{k}{n}\rfloor$,另一些$R=\lceil\dfrac{k}{n}\rceil$,使得$(\max(R)-min(R))^2=1$,$C$同理，于是$f(A)=2$最小。

下面考虑如何构造出如上的情况。我是从$1$到$k$一个个填的，为了满足如上情况，确保每$n$个`1`使得$R_{1...n}$和$C_{1...n}$都$+1$(即填的$n$个`1`所在列和行都不相同)。下面给出一种构造方法(以$4\times4$为例,表中数字代表填的顺序):

![](https://i.loli.net/2020/07/19/E6ODTHWxXjRGMyJ.png)

如上，按对角线填，因为对角线上一共$n$个数且每个数所在列、行都不相同。可是一个它只有一条对角线怎么办？没事，照样填，把超出格子的往上面填，效果一样。(请配合表格进行理解，和填幻方很像)最后提醒一下，由于是多测，输出后记得清零。

时间复杂度:

- 填表:$\Theta(\Sigma{k})$
- 输出:$\Theta(\Sigma n^2)$

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
const int MAXN=305;
int T,n,k,i,j,x,y;
bool a[MAXN][MAXN];
inline void read(int &x)    //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
signed main(void)
{
	read(T);
	while (T--)
	{
		read(n),read(k);
		putchar((k%n)?'2':'0'),putchar('\n');   //计算f(A) 
		for (i=x=y=1;i<=k;i++)    //填表,xy表示填的位置 
		{
			a[x][y]=1;
			x++,y++;    //按对角线填 
			if (x==n+1)    //处理超出格子的情况 
				x=1;
			if (y==n+1)
				y=1,x++;    //x++以进入下一条对角线 
		}
		for (i=1;i<=n;i++)    //输出 
		{
			for (j=1;j<=n;j++)
				putchar(a[i][j]?'1':'0');
			putchar('\n');
		}
		for (i=x=y=1;i<=k;i++)   //清零 
		{
			a[x][y]=0;
			x++,y++;
			if (x==n+1)
				x=1;
			if (y==n+1)
				y=1,x++;
		}
	}
	return 0;
} 
```

---

## 作者：huayucaiji (赞：1)

我们先来证明 $(a+1)^2-a^2<(a+2)^2-(a+1)$。用平方差公式展开：$(a+1)^2-a^2=(2a-1)\cdot 1$，$(a+2)^2-(a+1)^2=(2a+3)\cdot 1$。得证。

我们先可以对于：

$$f(A)=(\max(R)−\min(R))^2+(\max(C)−\min(C))^2 $$

这个式子进行一些思考，根据 $(a+1)^2-a^2<(a+2)^2-(a+1)$ 的性质，我们可以知道我们要让 $\max(R),\min(R)$ 尽量相近，$\max(C),\min(C)$ 尽量相近。我们就可以用一个类似于“抽屉原理”的思路来解决本题。

我们可以先把矩阵全部用 $1$ 填上，在一点一点把多余的 $1$ 扣掉。

我们在扣 $1$ 的时候。可以考虑选择行，列各不同的 $n$ 进行一次去除。如果我们还需去除的不足 $n$ 个，就选择剩下的 $k$ 个去掉即可，此时答案为 $2$。如果正好 $k=n$,那么答案为 $0$。

**最后提醒：别输出空格**。~~别像笔者一样傻乎乎的qwq。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int maxn=310;

int n,a[maxn][maxn],k;

signed main() {
	
	int t=read();
	
	while(t--) {
		n=read();k=read();
		
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=n;j++) {
				a[i][j]=1;
			}//全填成1
		}
		
		int sum=n*n,ans,cnt=0;
		if((sum-k)%n==0) {
			ans=0;
		}//计算答案，要么0，要么2
		else {
			int m=(sum-k)/n;
			ans=2;
		}
		while(sum>k) {
			if(sum-k>n){//去掉n个
				sum-=n;
				for(int i=1;i<=n;i++) {
					a[i][(i+cnt)%n+1]=0;
				}
			}
			else {//去掉k个
				for(int i=1;i<=sum-k;i++) {
					a[i][(i+cnt)%n+1]=0;
				}
				sum=k;
			}
			cnt++;
		}
		
		cout<<ans<<endl;
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=n;j++) {
				cout<<a[i][j];//输出，注意没有空格
			}
			cout<<endl;
		}
	}
	return 0;
}

```
我们模拟一下一组输入：

```plain
3 5
```

那么我们就会得到如下的变化过程：

$$\begin{pmatrix}1&1&1\\1&1&1\\1&1&1\end{pmatrix} \xRightarrow{}\begin{pmatrix}0&1&1\\1&0&1\\1&1&0\end{pmatrix}\xRightarrow{}\begin{pmatrix}0&0&1\\1&0&0\\1&1&0\end{pmatrix}$$

应该就可以理解算法的精髓了吧~~


---

## 作者：songtaoran (赞：0)

**注意：此蒟蒻写的代码又臭又长，慎入！**  
首先，打个表，就可以发现，当 $k$ 是 $n$ 的倍数时，答案为 $0$，否则为 $2$。  
那么怎么构造呢？  
我们先讨论 $k$ 是 $n$ 的倍数的情况。  
可以发现，只有第 $i$ 行的 $i \sim i + k - 1$ 部分被染成了 $1$。  
可是 $i + k - 1$ 可能会大于 $n$ 啊？  
把多余部分移到前面就好了。  
现在讨论 $k$ 不是 $n$ 的倍数的情况。  
观察表发现，就是在 $k$ 是 $n$ 的倍数的情况下~~胡乱加~~加几个 $1$ 就好了。具体怎么加呢？如果当前位置是 $0$ 并且加完之后 $\operatorname{max}(C) - \operatorname{min}(C)$ 和 $\operatorname{max}(R) - \operatorname{min}(R)$ 都 $\leq 1$ 就好了（因为我们之前说过此时答案为 $2$）。  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll T, n, k;
char ans[310][310];
ll r[310], c[310], mxr[310], mnr[310], mxc[310], mnc[310];
int main(){
	cin >> T;
	while(T--){
		scanf("%lld %lld", &n, &k);
		if(k < n && k > 0){
			printf("2\n");
			for(ll i = 1; i <= n; i++){
				for(ll j = 1; j <= n; j++){
					if(i == j && i <= k) putchar('1');
					else putchar('0');
				}
				putchar('\n');
			}
			continue;
		}
		ll tmp = k;
		k = k / n;
		for(ll i = 1; i <= n; i++){
			if(i + k - 1 <= n){
				for(ll j = 1; j < i; j++) ans[i][j] = '0';
				for(ll j = i; j <= i + k - 1; j++) ans[i][j] = '1';
				for(ll j = i + k; j <= n; j++) ans[i][j] = '0';
			}else{
				ll len = n - i + 1;
				for(ll j = 1; j <= k - len; j++) ans[i][j] = '1';
				for(ll j = k - len + 1; j < i; j++) ans[i][j] = '0';
				for(ll j = i; j <= n; j++) ans[i][j] = '1';
			}
		} 
		for(ll i = 1; i <= n; i++) r[i] = c[i] = mxr[i] = mnr[i] = mxc[i] = mnc[i] = tmp / n; // 初始化 
		if(tmp % n != 0){
			ll cnt = tmp % n, now = 0;
			ll i = 1, j = 1;
			while(now < cnt){ 
				if(ans[i][j] == '0'){
					ll tmp1 = mxr[i], tmp2 = mxc[j];
					r[i]++; c[j]++;
					mxr[i] = max(mxr[i], r[i]); mxc[j] = max(mxc[j], c[j]);
					if(mxr[i] - mnr[i] > 1 || mxc[j] - mnc[j] > 1){
						r[i]--; c[j]--;
						mxr[i] = tmp1; mxc[j] = tmp2;
					}else{
						ans[i][j] = '1'; i++; j = 1; now++; continue;
					}
				}
				if(j == n) i++, j = 1;
				else j++;
			}
		}
		printf(tmp % n == 0 ? "0\n" : "2\n");
		for(ll i = 1; i <= n; i++){
			for(ll j = 1; j <= n; j++) putchar(ans[i][j]); putchar('\n');
		}
	}
	return 0;
}
```
[提交记录 - $292576135$](https://codeforces.com/problemset/submission/1371/292576135)

---

## 作者：youdu666 (赞：0)

### 思路：贪心、构造

这里介绍一种不同的思路，即不靠删数而是填数来完成构造。

拿到题目，可以贪心地想到一定是行列均为平摊时答案最优，并且可以想到答案不是 $0$ 就是 $2$。

答案为 $0$ 当且仅当整张图需要填满，即 $n^2=k$ 时，其他情况下，答案均为 $2$。

考虑构造，这是本题的重头戏。可以贪心地将上面几排填满，随后根据每行要填的数字向下转移，最后计算出还需要填写的数字，挑选未填过的行和列进行填写。

处理时有较多细节。对于任意一行，应当优先向下转移 $>1$ 的数字，随后从第 $i$ 列开始转移以防止出现重叠。在对于 $1$ 的转移中，应当优先转移下一行为 $0$ 的格子，保证答案正确。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,y=1;
    char c=getchar();
    while(c>'9'||c<'0')
    {
        if(c=='-')
            y=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*y;
}
int n,k1,k;
int pn[305],pm[305],ans[305][305],cnt[305];
signed main()
{
    int T=read();
    while(T--)
    {
        memset(cnt,0,sizeof cnt);
        memset(ans,0,sizeof ans);
        n=read(),k1=k=read();
        int t=0;
        if(k)
        t=k/n;
        for(int i=1;i<=n;i++)
            pn[i]=pm[i]=t,k1-=t;
        if(k1)
            printf("2\n");
        else
            printf("0\n");
        for(int i=1;i<=n;i++)
            for(int j=1;j<=pn[i];j++)
                ans[j][i]=1,cnt[j]++;
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<=n;j++)//转移>1的格子应当最优先
                if(ans[i][j]>1)
                    cnt[i]-=ans[i][j]-1,cnt[i+1]+=ans[i][j]-1,ans[i+1][j]+=ans[i][j]-1,ans[i][j]=1;

            for(int j=i;j<=n;j++)//转移下一行的对应列数字为0的格子，注意从i出发防止出现重叠
                if(ans[i][j]&&cnt[i]>pm[i]&&(!ans[i+1][j]))
                    ans[i+1][j]++,ans[i][j]=0,cnt[i]--,cnt[i+1]++;
            for(int j=1;j<i;j++)
                if(ans[i][j]&&cnt[i]>pm[i]&&(!ans[i+1][j]))
                    ans[i+1][j]++,ans[i][j]=0,cnt[i]--,cnt[i+1]++;

            for(int j=i;j<=n;j++)//转移其他格子
                if(ans[i][j]&&cnt[i]>pm[i]&&ans[i+1][j])
                    ans[i+1][j]++,ans[i][j]=0,cnt[i]--,cnt[i+1]++;
            for(int j=1;j<=i;j++)
                if(ans[i][j]&&cnt[i]>pm[i]&&ans[i+1][j])
                    ans[i+1][j]++,ans[i][j]=0,cnt[i]--,cnt[i+1]++;
        }
        int bk=0;
        for(int i=1;i<=n&&k1;i++)//重新填写多余的数字
            for(int j=bk+1;j<=n&&k1;j++)
                if(!ans[i][j])
                {
                    ans[i][j]=1,k1--;
                    bk=j;
                    break;
                }
        for(int i=1;i<=n;i++,printf("\n"))
            for(int j=1;j<=n;j++)
                printf("%d",ans[i][j]);
    }
}
```


---


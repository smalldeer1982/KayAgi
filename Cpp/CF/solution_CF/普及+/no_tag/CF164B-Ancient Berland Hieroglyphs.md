# Ancient Berland Hieroglyphs

## 题目描述

Polycarpus 对 Berland 象形文字充满了兴趣。某天，他得到两幅古老的 Berland 图片，上面各自画着一个象形文字圆圈。已知在任一圆圈中，象形文字不会重复出现（但可以在两个圆圈中各出现一次）。

为了在电脑上保存这些图片，Polycarpus 必须将每个圆圈打断，并顺时针将其中的所有象形文字按顺序写成一行。由第一个圆圈得到的行称为 $a$，由第二个圆圈得到的行称为 $b$。

由于有多种打断圆圈的方法，Polycarpus 希望选择一种能够使得 $a$ 的最长子串作为 $b$ 的子序列的长度最大。

请帮 Polycarpus 找出，在最优打断方式下，所需子串（子序列）的最大可能长度。

字符串 $s$ 的长度为字符数目，记作 $|s|$。字符串可以表示为 $s = s_1 s_2 \ldots s_{|s|}$。

一个子串 $x$ 可以表示为 $x = s[a \ldots b] = s_a s_{a+1} \ldots s_b$（$1 \le a \le b \le |s|$）。例如，“code”和“force”是“codeforces”的子串，而“coders”不是。

子序列是指 $y = s[p_1 p_2 \ldots p_{|y|}] = s_{p1} s_{p2} \ldots s_{p|y|}$（$1 \le p_1 < p_2 < \ldots < p_{|y|} \le |s|$）。例如，“coders”是“codeforces”的子序列。

## 说明/提示

在第一个测试用例中，Polycarpus 选择了一个由象形文字 5 和 1 组成的字符串；在第二个测试用例中，他选择了一个由象形文字 1、3 和 5 组成的字符串。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 3 5 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 6
1 3 5 2
1 2 3 4 5 6
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3 3
1 2 3
3 2 1
```

### 输出

```
2
```


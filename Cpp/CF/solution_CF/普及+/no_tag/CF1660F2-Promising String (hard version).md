# Promising String (hard version)

## 题目描述

如果一个非空字符串包含了相同个数的加号与减号，我们把它称之为一个平衡字符串。
比如`+--+`,`++-+--`都是平衡的，而字符串`+--`,`--`,` `都不是平衡的。

如果一个字符串可以通过几个（可以是$0$个）操作而变得平衡，我们称它是有希望的。具体操作为：
把两个相邻的减号替换为一个加号

显然所有的平衡字符串都是有希望的，不过不是所有有希望的字符串都是平衡的。比如字符串`-+---`是一个有希望的字符串。因为
你可以把两个相邻的减号替换为一个加号从而达到一个平衡字符串`-++-`或`-+-+`

对于一个给定的字符串$s$,你要求出有它多少个非空子串是有希望的。如果一个子串在$s$中出现了多次，我们也要计算多次

## 样例 #1

### 输入

```
5
3
+-+
5
-+---
4
----
7
--+---+
6
+++---```

### 输出

```
2
4
2
7
4```

# 题解

## 作者：I_am_Accepted (赞：11)

### Preface

但是你的愿望是 AK Div.3……

### Analysis

我们把 `'+'` 看作 $1$，把 `'-'` 看作 $-1$，作前缀和 $a_0(=0),a_1,a_2,\dots,a_n$。

发现**一个子串 $(l,r]$（左开右闭）是「Promising」的当且仅当**

$$\begin{cases}
a_r-a_l\le 0&(1)
\\
a_r-a_l\equiv 0 \pmod{3}&(2)
\\
\text{calc}(l,r)\ge 0 &(3)
\end{cases}$$

$(1)$ 解释：原来 `'-'` 必须不少于 `'+'`。

$(2)$ 解释：两个 `'-'` 可以变成一个 `'+'`，所以最后总和只能增加 $3$ 的倍数。

$(3)$ 解释：$\text{calc}(l,r)$ 表示子串 $(l,r]$ 内进行「两减变一加」操作（可多次）后 $a_r'-a_l'$ 的最大值。显然必须 $\ge 0$，否则减号永远比加号多。

至此，我们 $O(n^2)$ 解决了 F1，看一下[代码](https://codeforces.com/contest/1660/submission/152282414)吧。

然后需要发现一个……

------------

**结论：**

若 $(1),(2)$ 条件均满足，$(3)$ 必然满足。

**证明：**

假设存在不满足 $(3)$ 但满足 $(1),(2)$ 的子串 $a_{l+1},a_{l+2},\dots,a_r$。将其 $\text{calc}$ 后为序列 $\{b\}$（长度不一定为 $r-l$），得到 $\sum b_i<0$ 且 $\{b\}$ 中没有两个相邻的 `'-'`。则 $\{b\}$ 一定为 $\{-,+,-,+,\dots,+,-,+,-\}$。此时即得到 $a(l,r]$ 不满足 $(2)$，矛盾。假设不成立，原命题得证。

------------

然后问题就是求满足

$$\begin{cases}
0\le l<r\le n
\\
a_l\ge a_r &(1)
\\
a_l\equiv a_r \pmod{3} &(2)
\end{cases}$$

的二元组 $(l,r)$ 个数。

**同余分组后求逆序对数**即可（**树状数组** 或 **分治** 均可）

时间 $O(n\log n)$

### Code

[F2 的树状数组代码](https://codeforces.com/contest/1660/submission/152282515)

---

## 作者：KemononeRou (赞：2)

两 $\log$ 小丑做法。

为了方便下面令减号为 $0$，加号为 $1$。

考虑如何判断一个区间合法。

发现操作一次之后 $0$ 的个数会减少 $2$，$1$ 的个数会增加 $1$，变化量为 $3$。

同时还要有足够的操作次数使得 $0$ 和 $1$ 的个数相等。

因此一个区间合法有如下条件：

- $0$ 的数量不少于 $1$ 的数量。

- $0$ 与 $1$ 的数量之差是 $3$ 的倍数。

- $0$ 与 $1$ 的数量之差除以 $3$ 不多于不交的 $00$ 数量。

可以 $O(n)$ 预处理出前缀 $0/1$ 数量，前缀不交的 $00$ 数量。

令 $cnt_{i, 0/1}$ 表示前缀 $0/1$ 数量，$sum_i$ 表示前缀不交的 $00$ 数量。

那么一个区间 $[l, r]$ 满足条件就可以表示为：

- $cnt_{r, 0} - cnt_{l - 1, 0} \ge cnt_{r,1} - cnt_{l - 1, 1}$

- $(cnt_{r, 0} - cnt_{l - 1, 0}) - (cnt_{r, 1} - cnt_{l - 1, 1}) \equiv 0 \pmod{3}$

- $\dfrac{1}{3} ((cnt_{r, 0} - cnt_{l - 1, 0}) - (cnt_{r, 1} - cnt_{l - 1, 1})) \leq sum_r - sum_{l-1}$

上面的三个式子太丑了，令 $pre_i=cnt_{i, 0} - cnt_{i, 1}$，再移项得到：

- $pre_{l - 1} \leq pre_r$

- $pre_{l - 1} \equiv pre_r \pmod{3}$

- $3 \cdot sum_{l - 1} - pre_{l - 1} \leq 3 \cdot sum_r - pre_{r}$

发现这是一个三维偏序板子，对 $pre_i\bmod{3}$ 的余数都做一遍就好了。

[Code](https://www.luogu.com.cn/paste/s43cw7hv)

---

## 作者：XL4453 (赞：1)

### $\text{Difficulty : 2100}$
---
### 解题思路：

问题中比较难处理的就是变换次数的限制。具体考虑这个限制。

首先考虑一个基本状态：$+-...+-$，这个状态下可能存在的变换次数最少，从这个状态开始考虑，由于一定要满足 $+$ 的数量比 $-$ 的数量多，所以任何一个合法的状态一定是在这些位置上添加一些 $-$ 或者改变 $+$ 和 $-$ 的位置变化而成的。

可以发现，在上述的两种对于序列的更改中，无论是哪一种都会是的序列的最大变换次数变多，而且变换次数的增长速度要比需要的次数增长快。更具体地，假设存在交换位置，那么也就是在需要的变换次数不变的前提下平白地增加了可能存在的变换次数，由此得出，如果想要用变换次数取限制转化的话，一定不存在交换。

那么也就只需要考虑添加了，对于每一个 $+$ 和之后的所有的 $-$ 进行考虑，不妨设其中的 $-$ 有 $x$ 个，则可能存在的变换次数为 $\left\lfloor\dfrac{x}{2}\right\rfloor$，而需要的变换次数仅为 $\left\lfloor\dfrac{x-1}{3}\right\rfloor$，一定没有前者多。

那么问题也就转换为了一个更简单的形式：要求 $+$ 不多于 $-$，且 $+$ 的数量和 $-$ 的数量的差值可以被三整除。

然后将 $+$ 定义为 $-1$，$-$ 定义为 $1$，求前缀和。那么对于每一个位置找到前面的比它小的，且在模 $3$ 意义下同余的前缀和统计一下就行了。
 
---
### 代码：

```cpp
#include<cstdio>
#include<map>
using namespace std;
#define int long long
const int MAXN=200005;
int T,n,a[MAXN],ans,BIT[3][MAXN*3];
char get(){
	char c=getchar();
	while(c!='+'&&c!='-')c=getchar();
	return c;
}
int low_bit(int x){
	return  x&-x;
}
void add(int now,int k){
	now+=MAXN;
	while(now<=2*MAXN){
		BIT[k][now]+=1;
		now+=low_bit(now);
	}
	return;
}
void Minus(int now,int k){
	now+=MAXN;
	while(now<=2*MAXN){
		BIT[k][now]-=1;
		now+=low_bit(now);
	}
	return;
}
int query(int now,int k){
	int ans=0;now+=MAXN;
	while(now){
		ans+=BIT[k][now];
		now-=low_bit(now);
	}
	return ans;
}
signed main(){
	scanf("%I64d",&T);
	while(T--){
		scanf("%I64d",&n);
		for(int i=1;i<=n;i++){
			if(get()=='+')a[i]=-1;
			else a[i]=1;
		}
		for(int i=1;i<=n;i++)a[i]+=a[i-1];
		ans=0;
		add(0,0);
		for(int i=1;i<=n;i++){
			ans+=query(a[i],(a[i]+600000)%3);
			add(a[i],(a[i]+600000)%3);
		}
		printf("%I64d\n",ans);
		Minus(0,0);
		for(int i=1;i<=n;i++)
		Minus(a[i],(a[i]+600000)%3);
	}
	return 0;
}
```


---

## 作者：Cocoly1990 (赞：1)

省流助手：秒了。

首先瞎几把猜结论，一个区间是有希望的，当且仅当区间内 **`+` 的数量减去 `-` 的数量是 3 的倍数且小于 0.**

浅浅的证明一下。

显然每次操作就是将两个 `-` 换成 `+`，所以三个 `-` 只要有两个是相连的，则必然可以自我抵消。

所以我们需要证明，如果 `-` 比 `+` 至少多两个，则至少有一对 `--`.

考虑反证，如果没有，必然是形如 `-+-+ ... -+` 这样的，那么 `+` 就不会比 `-` 多至少两个。

考虑如何维护这个结论，一个常见套路是利用前缀和，把 `-` 标记为 -1， `+` 标记为 1.

暴力枚举左右端点可以轻松做到 $\mathcal{O}\left(n^2\right)$，但我们想想，会产生贡献的左右端点必然 $\bmod \ 3$ 同余，那么问题转化为二维偏序，直接利用值域树状数组维护同余即可。

考虑到可以离线，归并排序求逆序对就好了。（

---

## 作者：VitrelosTia (赞：0)

*2100，简单题。

设 $\texttt{-}$ 的前缀和减去 $\texttt{+}$ 的前缀和为 $x_i$。子串 $[l,r]$ 有希望的充要条件显然是 $x_r \equiv x_{l-1} (\bmod 3)$。考虑在 $r$ 处统计答案，开个桶应该就行了，然后你发现你错了，因为还要满足 $x_r \ge x_{l-1}$，所以转而考虑开三个树状数组，对于三种余数分别在值域上求前缀和即可，$x_i$ 可能是负数所以要加上一个偏移量。

至于证明，充分性考虑直接按题意消，最后肯定能行；必要性考虑变化会保证 $(x_r-x_{l-1}) \bmod 3$ 不变，而这个值最终是 $0$，那么过程中必须 $(x_r-x_{l-1})\bmod 3 = 0$ 和上面的那个东西是等价的。

```cpp
const int N = 2e5 + 4; // 这是 3 的倍数
int n, x[N]; string s;
struct BITree {
	int c[N << 1], m; int qwq(int x) { return x & (-x); }
	void update(int x, int k) { for (; x <= m; x += qwq(x)) c[x] += k; }
	int query(int x) { int a = 0; for (; x; x -= qwq(x)) a += c[x]; return a; }
} t[3];
void solve() {
	cin >> n >> s; s = " " + s;
	for (int o = 0; o < 3; o++) t[o].m = n + N;
	for (int i = 1, sa = 0, sb = 0; i <= n; i++) {
		sa += s[i] == '+', sb += s[i] == '-';
		x[i] = sb - sa;
	} int ans = 0;
	for (int i = 0; i <= n; i++) {
		ans += t[(x[i] + N) % 3].query(x[i] + N);
		t[(x[i] + N) % 3].update(x[i] + N, 1);
	} 
	for (int i = 0; i <= n; i++) t[(x[i] + N) % 3].update(x[i] + N, -1);
	cout << ans << '\n';
}
```

---


# Permutation Game

## 题目描述

有一个长度为 $n$ 的仅为 $1\sim n$ 的序列，初始序列中所有的数均为红色。两个玩家依次进行以下三种操作中一种：

- 将某个数变成蓝色。
- 将所有蓝色的数重新排列（按照自己的意愿排列，红色不可进行排列，不必将所有的蓝色都交换位置）。
- 跳过此次操作。

两个玩家依次进行一次操作视为一个回合，游戏共进行 $100^{500}$ 回合。在游戏任何时刻，如果当前序列为 $\{1,2,3...,n\}$，则第一个操作的玩家胜利。如果当前序列为 $\{n,n-1,n-2...1\}$，则第二个玩家胜利。进行 $100^{500}$ 回合之后若还无人胜利，则平局。注意，两名玩家都以最优方案进行操作。他们会尽可能让自己胜利。

## 样例 #1

### 输入

```
4
4
1 2 4 3
3
2 3 1
5
3 4 5 2 1
6
1 5 6 3 2 4```

### 输出

```
First
Tie
Second
Tie```

# 题解

## 作者：zajasi (赞：10)

## 题意
有 $n$ 红棋子，每个棋子上写着 $a_i$。两个人在玩游戏，每次他们可以选择以下操作：
1. **任意** 安排蓝色棋子的位置
1. 将一个红色棋子变成蓝色棋子
1. 什么也不干

玩家 $1$ 想让棋子正序排列，玩家 $2$ 想要让棋子逆序排列。当他们进行了 $10^{500}$ 次时，算打成平手。玩家 $1$ 先走，假如两人都绝顶聪明，问最后情况如何？
## 样例解释
我们来看一下样例：$1\ 2\ 4\ 3$。

要想把它变成正序的话是：$1\ 2\ 3\ 4$。

要想把它变成逆序的话是：$4\ 3\ 2\ 1$。

可以看到，正序与原来的排列在位置 $3\ 4$ 上不同。

逆序与原来的排列在位置 $1\ 2\ 3\ 4$ 上不同。

也就是说，要想改变，两个人都要动 $3\ 4$，然后第二个人要动 $1\ 2$。

第一个人动位置 $3$，第二个人动位置 $1$。

第一个人动位置 $4$，第二个人动位置 $2$。

第一个人调动蓝色的位置，变成正序，游戏结束。
## 解题思路
通过样例解释，稍微清晰点了吗？

对于一个位置，有以下三种情况：

1. 要想变成正序要动，但逆序不要动
1. 要想变成逆序要动，但正序不要动
1. 两种情况都要动

所以说，刚开始的时候，肯定是动 $1\ 2$ 两种情况。当某一方自己的情况动完后，再去弄第 $3$ 种情况。此时就可以判断：

1. 如果此时第 $3$ 种情况剩余的比 $1\ 2$ 两种剩余的多，很明显，最后几个谁都不愿意碰，是 Tie。
1. 如果此时第 $3$ 种情况剩余的比 $1\ 2$ 两种剩余的少，分类讨论。
- 若还剩的是 $1$，因为 $1$ 是先手，则若 $1$ 的情况 $\le$ $3$ 的情况，$1$ 赢。
- 若还剩的是 $2$，因为 $2$ 是后手，则若 $2$ 的情况 $<$ $3$ 的情况，$2$ 赢。

然后判断一下就可以了。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t;
int n;
int a[500050];
main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		int c1=0,c2=0,c3=0;
		for(int i=1;i<=n;i++){
			c1+=a[i]!=i;
			c2+=(a[i]!=(n-i+1));
			if(a[i]!=i&&a[i]!=n-i+1)c3++;
		}
		int k=min(c1,c2);
		c1-=k;
		c2-=k;
		if(c1==0){
			if(c3>c2)cout<<"Tie\n";
			else cout<<"First\n";
		}
		else{
			if(c3>=c1)cout<<"Tie\n";
			else cout<<"Second\n";
		}
	}
	return 0;
}

```



---

## 作者：zeekliu (赞：2)

因为最后的排序随便排，只需 $ 1 $ 次，所以最后染蓝色的人必输。

那么既然两个人都会用最佳策略，所以他们并不会将所有的数都染色，而只会染那些需要重排的数，即位置错误的数。

举个例子：

给定数列 $\{2,4,3,1\}$，

正着排序为：$\{1,2,\colorbox{#00ff00}{3},4\}$

反着排序为：$\{4,3,2,\colorbox{#ffcc00}{1}\}$

按照上面的例子，我们可以发现，对于先手，$3$ 的位置是正确的；对于后手，$1$ 的位置是正确的，他们每个人只需涂 $3$ 个数即可，所以**我们先统计位置正确的数**。

对于每个数，存在 $4$ 种情况：

1. 对于正着排序位置正确
2. 对于反着排序位置正确
3. 对于正着、反着位置都正确
4. 对于正着、反着排序位置都不正确

我们设第一种情况有 $a$ 个数，第二种情况有 $b$ 个数，第三种情况有 $c$ 个数，第四种情况有 $d$ 个数。

则分为以下情况：

> 若 $ a+c+d \le b $，则先手赢。

> 若 $ b+c+d < a $，则后手赢。

> 否则，平局。

为什么呢？

因为谁赢是比较要染成蓝色格子的数量，所以谁需要涂的蓝色格子少，谁就赢，如果一样多，谁涂了最后一格，对方就会将数排序，此时就输了，因此这样就会僵持，打平。

代码：

```cpp
//CF1772E 22.12.20
#include <bits/stdc++.h>
using namespace std;
int _,n,a[500010],cnt1=0,cnt2=0,cnt3=0;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>_;
    while (_--)
    {
        cnt1=0,cnt2=0,cnt3=0;
        cin>>n;
        for (int i=1;i<=n;i++) cin>>a[i];
        for (int i=1;i<=n;i++)
        {
            if (a[i]==i) cnt1++;
            if (a[i]==(n-i+1)) cnt2++;
            if (a[i]!=i && a[i]!=(n-i+1)) cnt3++;
        }
        if (cnt2+cnt3<=cnt1) cout<<"First"<<endl;
        else if (cnt1+cnt3<cnt2) cout<<"Second"<<endl;
        else cout<<"Tie"<<endl;
    }
    exit(0);
}
```

---

## 作者：CSP_Sept (赞：2)

## 描述

一个两人参与的游戏，分先后手。

初始时给出一个 $n$ 的排列 $q$，保证初始时一定不是递增或递减的。同时初始时，$n$ 个下标都是红色的。两人轮流进行如下操作：

1. （可选）保证所有红色的下标对应数位置不变。任意交换蓝色下标对应的数。
2. （必选）把一个下标染成蓝色。

先手的目标是让排列升序排列，后手的目标是让排列降序排列。若游戏进行 $1919810^{114514}$ 轮后都没结束，视作平局。

双方使用最优策略，问游戏最终是谁赢，或判定平局。

## 解答

对于两位玩家，达成彼此最终状态必须先对初始状态与最终状态与差异的下标染色。

例如，对于先手，需要染色的数量为 $\sum_{i=1}^n[p_i\ne i]$。

当然这里面可能存在重合。记先手单独必须染色数量、后手单独必须染色数量、两人共同必须染色数量分别为 $x,y,z$。

这里还应该指出的是，在各自必须染色的数量没有完成时，我们是不可能使用操作 1 的。因为可以先将对方的交换恢复，然后再进行自己需要的交换。

对于先手，必须可以在后手染完 $y$ 之前染完 $x,z$。否则在先手染完 $z$ 后，后手便可以坐享其成，直接胜利。而这是不可能出现的，所以先手会耗成平局。这种情况下，先手胜利，当且仅当 $x+z\le y$。

类似地，对于后手，胜利当且仅当 $y+z<x$。这里不能取等，因为他是后手。

不满足以上两点，即为平局。

## 代码

_[186051525](https://codeforces.com/contest/1772/submission/186051525)_

---

## 作者：qwq___qaq (赞：1)

记录 $cnt_1$ 为第一个玩家（以下简称为 $A$）需要操作的数量，$cnt_2$ 为第二个玩家（以下简称为 $B$）需要操作的数量，$cnt_3$ 为 $A$ 和 $B$ 都需要操作的数量。

那么我们进行分类讨论：

当 $cnt_1\ge cnt_2$ 时：注意到在 $A$ 取 $cnt_3$ 的时候此时 $B$ 就会少取一个，那么 $B$ 实际上只需要取的就只有 $cnt_2-cnt_3$ 个。由于 $A$ 是先手，那么当 $cnt_1\le cnt_2-cnt_3$ 时 $A$ 获胜，否则平局。（因为没有人会去取都需要的部分）

当 $cnt_1<cnt_2$ 时：同理，$A$ 只需要取 $cnt_1-cnt_3$ 个，但是由于 $B$ 是后手，所以只有 $cnt_2<cnt_1-cnt_3$ 时 $B$ 才能赢，否则平局。

```cpp
#include<bits/stdc++.h>
using namespace std; 
int T,n; 
int main(){
    scanf("%d",&T);
	while(T--){
		int cnt1=0,cnt2=0,cnt3=0;
		scanf("%d",&n);
		for(int i=1,a;i<=n;++i){
			scanf("%d",&a);
			cnt1+=(a!=i),cnt2+=(a!=n-i+1),cnt3+=(a!=i&&a!=n-i+1);
		}
		if(cnt1<=cnt2){
			if(cnt1<=cnt2-cnt3)
				puts("First");
			else
				puts("Tie");
		} else{
			if(cnt2<cnt1-cnt3)
				puts("Second");
			else
				puts("Tie");
		}
	}
	return 0;
}
```

---

## 作者：MoyunAllgorithm (赞：0)

较简单的博弈论问题。

**分析**

以下称先后手分别为 Alice 和 Bob。

存在结论：**如果能赢，玩家可以先标记，最后统一重排**。这点容易理解。而且如果你提前重排，那你会把选标记的机会拱手让人，这是不好的。选标记是多多益善的。

那么玩家会标记哪些点呢？设身处地地想：Alice 只想标记 $a_i \neq i$ 的点，Bob 只想标记 $a_i \neq N-i+1$ 的点。当然很多位置两个人都想标记。

本着不给别人一点利益的原则，**玩家必然优先标只有自己想标记的点。** 因此，Alice 先标只她想标、Bob 不想标的点，如果这种点被标完了，那她只好标她和 Bob 都想标的点。如果这些点也标完了，那她直接重排，游戏就结束了！

因此我们理清楚了游戏策略：

- 先标注只自己想标的点；

- 再标注都想标的点；

- 重排，胜利。

如果一个人想标的点标完了而另一个人没有，则 ta 胜利。

如果两个人的点将会同时被标完，则平局。因为，最后标上这个点的人知道，一旦 ta 标完这个点自己就会失败。因此 ta 会选择不标最后这个点，啥都不干，僵持下去。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
int T,N;
int c[MAXN];
vector<int>a,b,ab;
bool Stop()
{
    if(a.size()==0&&ab.size()==0) return 1;
    if(b.size()==0&&ab.size()==0) return 1;
    return 0;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&N);
        a.clear(),b.clear(),ab.clear();
        for(int i=1;i<=N;i++)
        {
            scanf("%d",&c[i]);
            if(c[i]!=i&&c[i]!=N-i+1) ab.push_back(i);
            else if(c[i]!=i) a.push_back(i);
            else if(c[i]!=N-i+1) b.push_back(i);
        }
        int at=0;//attempt
        //printf("%d %d %d\n",a.size(),b.size(),ab.size());
        while(!Stop())
        {
            at++;
            if(at&1)
            {
                if(a.size()) a.pop_back();
                else ab.pop_back();
            }
            else
            {
                if(b.size()) b.pop_back();
                else ab.pop_back();
            }
        }
        //printf("%d %d %d\n",a.size(),b.size(),ab.size());
        if(a.size()==0&&b.size()==0&&ab.size()==0)
        {
            puts("Tie");
            continue;
        }
        puts(a.size()?"Second":"First");
    }
    return 0;
}
```

---

## 作者：BLX32M_10 (赞：0)

### 题意

有一个排列，两个人可以进行一种回合制游戏，每回合操作有以下几种：

- 标记一个元素

- **任意**改变已被任何一人标记的元素

- 跳过该轮

设玩家 $1$ 为先手，到了某轮，如果序列升序，玩家 $1$ 获胜，如果降序，玩家 $2$ 获胜。

问如果两人选择的都是最佳策略，那么是谁赢，或者进行了 $100^{500}$ 轮还未分出胜负，那么平局

### 题解

显然不可能枚举 $100^{500}$ 回合，于是我们考虑从双方需要标记并交换的元素（也就是不符合双方的胜利条件的元素）入手。

一个元素可能有四种情况：仅玩家 $1$ 需要标记、仅玩家 $2$ 需要标记、两玩家均需标记和两玩家均不需标记。

不难得出最佳策略：先标记仅自己需要标记的，然后标记两人均需标记的，最后再进行改变。

需要注意的是，两人可以**任意**改变已标记的元素，所以“干扰对方”没有任何效果，还未标记完成就更改都是不优的，并且两人均不需标记的不用管。

如果一人已经标记完了他需要标记的所有元素而另一人还未标记完仅自己需标记的元素时，标记完的一方胜利。

而如果两人都标记完了仅自己需要标记的元素，剩下一些两人均需标记的元素，两人就会标记至最后一个，但此时两人都不会标记，选择跳过。因为一旦标记，另一方会胜利。直到第 $100^{500}$ 回合，平局。

形式化地，设仅玩家 $1$ 需要标记 $a$ 个数，仅玩家 $2$ 需要标记 $b$ 个数，两人均需标记 $c$ 个数，那么（等号在后面讨论）：

$$\begin{cases}
b > a
\begin{cases}
b - a < c & \text{Tie}\\
b > a + c & \text{First win}
\end{cases}\\
a > b
\begin{cases}
a - b < c & \text{Tie}\\
a > b + c & \text{Second win}
\end{cases}
\end{cases}$$

此时距离最终的公式只差一步也是很关键的一步——等号。

对于相等的情况，我们不妨手模一下这组样例：

$\red4 \ \red2 \ \red3 \ \red1$

此时玩家 $1$ 需要标记 $1$ 和 $4$，玩家 $2$ 需要标记 $2$ 和 $3$。

第一回合，两玩家各标记一个元素：

$\blue4 \ \blue2 \ \red3 \ \red1$

第二回合与第一回合同理：

$\blue4 \ \blue2 \ \blue3 \ \blue1$

下一步，玩家 $1$ 操作，按照最优策略，所有需要的元素标记完毕，交换 $1$ 和 $4$：

$\blue1 \ \blue2 \ \blue3 \ \blue4$

玩家 $1$ 胜利。

不难得出因为玩家 $1$ 先手比玩家 $2$ 多出一步，所以在式子中的等号都是靠向玩家 $1$ 胜利的。

有了等号，最终公式就出来了：

$$\begin{cases}
b \ge a
\begin{cases}
b - a < c & \text{Tie}\\
b \ge a + c & \text{First win}
\end{cases}\\
a > b
\begin{cases}
a - b \le c & \text{Tie}\\
a > b + c & \text{Second win}
\end{cases}
\end{cases}$$

代码有了公式就很清晰了吧：

```cpp
#include <cstdio>
int main()
{
    int t;
    scanf("%d", &t);
    while (t--)
    {
        int n, a = 0, b = 0, c = 0, x;
        scanf("%d", &n);
        for (int i = 1; i <= n; i++)
        {
            scanf("%d", &x);
            if (x != i && x != n - i + 1)
                c++;
            else if (x != i)
                a++;
            else
                b++;
        }
        //公式部分
        if (b >= a)
        {
            if (b - a < c)
                printf("Tie\n");
            else
                printf("First\n");
        }
        else
        {
            if (a - b <= c)
                printf("Tie\n");
            else
                printf("Second\n");
        }
    }
    return 0;
}
```

---


# Building Forest

## 题目描述

### 题意翻译
一个有向加权森林是无环有向加权图，其中每个顶点至多有一条边。有向加权森林中，顶点 $ v $ 的根是一个没有出边的顶点，并且可以通过沿着加权有向森林的边从顶点 $ v $ 到达。现将顶点 $ v $ 的根记为 $ root(v) $。顶点v的深度是从顶点 $ v $ 到其根的路径的权重之和。现将顶点 $ v $ 的深度表示为 $ depth(v) $。

构建加权定向森林的过程如下：最初，森林不包含顶点。顶点按顺序逐个添加。总体而言，有 $ n $ 个执行的加法操作。

第 $ i（i>0）$个 操作由一组数字 （$ k $,$ v1 $，$ x1 $，$ v2 $， $ x2 $， ... $ vk $，$ xk $） 描述，意味着我们应该将顶点 $ i $ 下的边 $ k $ 添加到图中。

从顶点 $root( v_1 )$ 到顶点$ i $的边，权重为 $depth( v_1 ) + x_1 $；从顶点 $root( v2 )$ 到顶点$ i $的边，权重为 $ depth( v2 ) +  x2 $ ，以此类推。如果 $ k=0 $，那么图中只增加了顶点 $ i $ ，没有增加任何边。

现给定添加的顶点，请计算森林所有边的权重之和。由于数据可能很大，请将输出的数据模 $1000000007$ $（10^9 + 7）$。

## 样例 #1

### 输入

```
6
0
0
1 2 1
2 1 5 2 2
1 1 2
1 3 4
```

### 输出

```
30
```

## 样例 #2

### 输入

```
5
0
1 1 5
0
0
2 3 1 4 3
```

### 输出

```
9
```

# 题解

## 作者：Ghosty_Neutrino (赞：0)

## 题意
有 $n$ 个点要按照 $1$ 到 $n$ 的顺序依次插入一个带边权的森林（森林一开始没有任何点边），第 $i+1$ 行描述第 $i$ 个点插入后的操作。如果某一行为 $(k,v_1,x_1,x_2, \dots ,v_k,x_k)$，那么 $k$ 表示要连的边的数量，$(v_j,x_j)$ 表示要从第 $v_j$ 个点连一条边到i，其权值为 $v_j$ 到其原来所在树的根节点的路径总长加上 $x_j$。
## 分析
从样例图中，就可以发现其实这就是一个简单的带权并查集，我刚学不久。
## 代码

```cpp
#include<bits/stdc++.h>
#define md 1000000007
typedef long long LL;
LL fa[100100];
LL hei2[100100];//¼ÇÂ¼µãiÁ¬ÏòÆä¸¸Ç×½ÚµãµÄ±ßµÄÈ¨Öµ
LL hei[100100];//¼ÇÂ¼µãiµ½¸¸Ç×½ÚµãµÄÂ·¾¶×Ü³¤
LL ans,n;
LL find(LL x){
    if(fa[x]==x) return x;
    LL t=find(fa[x]);
    hei[x]=(hei[fa[x]]+hei2[x])%md;
    fa[x]=t;
    return fa[x];
}
int main(){
    LL i,j,k,v,x,f1;
    scanf("%I64d",&n);
    for(i=1;i<=n;i++)
        fa[i]=i;
    for(i=1;i<=n;i++){
        scanf("%I64d",&k);
        for(j=1;j<=k;j++){
            scanf("%I64d%I64d",&v,&x);
            f1=find(v);
            if(f1==i) continue;
            fa[f1]=i;
            hei2[f1]=(x+hei[v])%md;
        }
    }
    for(i=1;i<=n;i++)
        ans=(ans+hei2[i]+md)%md;
    printf("%I64d",ans);
    return 0;
}
```

---


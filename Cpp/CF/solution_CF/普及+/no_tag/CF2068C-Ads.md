# Ads

## 题目描述

你在热门平台 YooCube 的观看列表中有 $n$ 个视频。第 $i$ 个视频时长为 $d_i$ 分钟。

YooCube 近期增加了广告投放频率。广告仅会在视频之间播放。当完成一个视频后，若满足以下任一条件则会播放广告：
- 自上次广告以来已观看三个视频；
- 自上次广告结束已过去至少 $k$ 分钟。

你需要按任意顺序观看这 $n$ 个视频。假设你刚刚观看完一个广告，且视频结束后无需再观看广告。求在最优观看顺序下，你被迫观看的广告数量的最小值。


## 说明/提示

第一个测试用例中，一种可能的观看顺序为 $4, 1, 8, 2, 5, 6, 7, 3$（对应时长为 $3, 4, 14, 5, 17, 17, 18, 18$）。此顺序下，在前三个视频后需要观看一次广告，随后三个视频后需再观看一次广告。注意观看完所有视频后无需观看广告。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
8 25
4 5 18 3 17 17 18 14
7 21
20 14 1 4 20 8 4
8 1
20 5 9 4 14 12 2 20
8 37
2 13 13 11 12 19 16 18
4 38
15 3 14 7```

### 输出

```
2
2
7
2
1```

# 题解

## 作者：do_it_tomorrow (赞：4)

考虑贪心，先考虑构造大小为 $3$ 的组。

剩余的最短的视频和最长的视频放到一起，然后选择可以加入其中的最长的不会引发广告的视频。

在不存在合法的时候，构造大小为 $2$ 的组，把最短的不超过 $k$ 的视频与最长的视频组合。

最后剩余的视频单独为一组，考虑证明其正确性。

假设最优解存在一个大小至少为 $2$ 的分组，那么一定有一种解法可以把时间最短的视频和时间最长的视频分到一组。

具体的，我们可以把与最短视频一组中最长的视频与最长的视频调换，这显然是合法的。

为了使解法最有，显然我们应该尽可能的多创建 $3$ 个一组的情况，如果我们可以把原本 $2$ 个一组或者 $1$ 个一组的变成 $3$ 个一组的，答案是肯定不会变裂。

这是因为把 $2$ 个一组的添加一个组成三个一组的，原本被添加进来的元素的组别可以保持不变或者直接消失。

我们可以贪心的选择最长的满足 $mn+x+mx<k$ 时间 $x$ 的视频，加入这一组。

同样的，假设 $x$ 并不在这一中，那么一定可以把这一组中比 $x$ 还要小的元素与 $x$ 调换或者直接把 $x$ 加入这组中。

同样的，如果不能构建大小为 $3$ 的组，那么构建尽可能多的大小为 $2$ 的组肯定是构造为 $1$ 的组优秀的。

我们可以继续贪心的选择满足 $x<k$ 的最长视频与剩余的最长视频匹配。

类似于上面的证明，如果最优解并不是让 $<k$ 的最长视频与剩余的最长视频匹配，那么我们可以直接把那个那视频与最长视频放到一组，这样显然是合法的。

[Submission #315831169 - Codeforces](https://codeforces.com/contest/2068/submission/315831169)

---

## 作者：xyvsvg (赞：3)

比较容易的贪心。

显然每 $3$ 个视频看一次广告的限制是死的，于是我们只能从视频长度下手。我们可以贪心的构造若干三元组，使得 $a_1+a_2<k$，$a_3$ 无限制。不难想到排序后使用双指针扫描。

因为最后一个视频看完不需要看广告，因此将答案 $-1$ 即可。

复杂度为 $O(n\log n)$：


```cpp
#include<bits/stdc++.h>
using namespace std;
void solve()
{
    int n,K;
    cin>>n>>K;
    vector<int>a(n+10);
    for(int i=1;i<=n;++i)
        cin>>a[i];
    sort(a.begin()+1,a.begin()+n+1);
    int ans=0;
    vector<bool>vis(n+10);
    for(int i=1,j=n,k=n;i<=n;++i,--j)
    {
        if(vis[i])
            continue;
        while(j>i&&(a[i]+a[j]>=K||vis[j]))
            --j;
        ++ans;
        vis[i]=1;
        if(j>i&&a[i]+a[j]<K)
            vis[j]=1;
        if(a[i]<K)
        {
            while(k>i&&vis[k])
                --k;
            vis[k]=1;
        }
    }
    cout<<ans-1<<endl;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin>>t;
    while(t--)
        solve();
    return 0;
}

```

---

## 作者：ARIS1_0 (赞：2)

题意不再赘述，直接讲思路。

# 思路

我们想要让观看的广告数最少，那么就需要尽量在看一个广告之前看最多的视频，也就是说我们要尽量保证看 $3$ 个视频过后再看一次广告，而不是时长超过 $k$ 之后才去看广告。

为什么是这样的？首先当你看完一次广告之后，你的观看累计时长会马上清空，不管你是通过观看 $3$ 个视频过后才看的广告还是时长满足之后看的广告，我们要让广告数最少，我们就应该去减少可能让广告播放的机会，但是无论如何你看 $3$ 次视频过后你都要看一次广告，就算是 $k=10^{10000}$ 而你只看了三个时长为 $1$ 的视频都要看广告。这样子肯定是不劣的。

所以我们现在要考虑的是怎么把三个视频拼到一起，才能满足这个策略。我们首先考虑当前时长最长的视频，我们肯定得把它看了，但是你又不能第一个先看它，为什么？如果这个视频时长大于 $k$ 了，那你这个方案很劣。

我们需要的是一种边界思想。什么意思呢？我们卡极限，我们先看 $k-1$ 个单位时间的视频，然后再来看这个最长的视频，这样子总的视频时长消耗最多，看广告的次数又最少。

我们刚刚确定了最长的视频应该放在一组三个视频中的最后一个来看，那么我们现在来确定前两个视频怎么选择。

我们应该在一组三个视频当中，**尽量消耗时间长的视频**。这样很好理解，如果你选的是两个比较短的视频拼在一起，再选一个长视频，那这样会导致后面时间长的视频开始堆积起来，时间上就亏掉了。万一后面剩的全是时间长的，你看一个就得看广告，看两个就得看广告的话，那这样是不优的。

那么对于一组三个视频，我们应该先找**当前没看的视频中最短的那个视频**，作为最开始的一个视频。这样子能为后面的视频时长留足最长的时间。

随后，设我们现在看了 $x$ 时长视频，那么我们应该在剩余的视频中找到时长为 $k-x$ 的**严格前驱**的视频。这样子在理想状态下我们就能够凑齐 $k-1$ 的时长。然后再把最大的视频加进来即可。

这是最理想情况，那么接下来还得考虑考虑不理想的情况，我们来一波分类讨论：

1. 找不到 $k-x$ 的严格前驱。

   这说明什么？我们没法凑齐一组三个视频了！因为剩下的视频你无论选哪一个都会导致总时长达到 $k$，这样子的话我们直接把最长的一个视频看掉就行了。

1. 最短的视频的时长大于 $k$。

   这说明什么？设现在剩下的视频有 $n$ 个，那么你就得看 $n-1$ 次广告！（注意最后一个视频看完之后不用看广告），你连最短的视频都超过 $k$ 了，那你接下来肯定没办法组合了，只能乖乖看一次视频看一次广告。

1. 剩下的视频数量在 $3$ 个以内。

   为什么要把这个提出来分类讨论呢？因为最后一组视频看完是不需要看广告的，但是你不确定你最后这一组到底能够组几个，所以你得单独提出来分讨。（实际上分讨的是倒数第三个和倒数第二个，不过为了方便就一起提出来就行了）

解题的思路大抵是这样，我们还需要确定实现上的思路。输入数组之后，我们需要排序，后面找严格前驱的时候就可以使用二分查找，最大最小也能很方便地知道。综上，我们需要一个数据结构维护有序可重数列，支持查前驱，插入删除任意数的操作。`multiset` 能够很好地进行维护。

但是在打现场的时候我们的 `multiset` 一直 RE，所以后面换了安全一点的 `vector`。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
mt19937 myrand(time(0));
inline ll read(){
	ll x=0,w=1;
	char ch=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*w;
}
void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	static int sta[35];
	int top=0;
	do{
		sta[top++]=x%10,x/=10;
	}while(x);
	while(top)putchar(sta[--top]+'0');
}
int n,k,x;
vector<int>s;
inline void work(){
	n=read();k=read();
	int ans=0;
	s.clear();
	for(int i=1;i<=n;i++){
		x=read();
		s.push_back(x);
	}
	sort(s.begin(),s.end());
	while(1){
		if(s.size()<=3)break;
		int now=*s.begin();//选取最短视频
		if(now>=k){//若最短视频已经满足广告时长需求
			ans++;
			s.erase(s.begin());
			continue;
		}
		int cha=k-now;
		auto pos=lower_bound(s.begin(),s.end(),cha);
		if(prev(pos)==s.begin()||pos==s.begin()){
//这里的意思就是找不到严格前驱，因为我们查的是第一个大于等于的数，所以把迭代器往前移一位就是理想状态下的严格前驱
//如果当前迭代器返回的就是最短视频，或者严格前驱就是最短视频，说明就不能组合三个视频
			s.pop_back();
			s.erase(s.begin());
			ans++;
			continue;
		}
		if(pos==s.end()){//如果找不到会返回尾迭代器
//找不到就说明我们当前将要组合的三个视频无论怎么选都不会超过时长限制
//那我们直接把最大值和次大值组过来就行
			s.pop_back();
			s.pop_back();
			s.erase(s.begin());
			ans++;
			continue;
		}
		pos--;
		s.pop_back();s.erase(pos);s.erase(s.begin());
		ans++;//剩下的就是最理想状态了
	}
//这里是对末尾三个的分讨
	if(s.empty()){write(ans);puts("");return;}
	int a1=s.front();s.erase(s.begin());
	bool f1=0;
	if(s.empty()){write(ans);puts("");return;}
	if(a1>=k)ans++,f1=1;//末尾第一个视频满足了广告时长需求
	int a2=s.front();s.erase(s.begin());
	if(s.empty()){write(ans);puts("");return;}
	if((f1&&a2>=k)||(!f1&&a1+a2>=k))ans++;
//这里的意思很显然，是第一个视频满足广告时长需求，第二个又满足了
//或者说是第一个不满足，但是这两个加起来满足了时长需求
	write(ans);puts("");
}
int t;
int main(){
	t=read();
	while(t--)work();
	return 0;
}
```

# 后记

[补上赛时代码通过记录](https://codeforces.com/contest/2068/submission/308655483)。

这是我第一次打 ICPC，还是得感谢两位队友的分工合作。

[alpharchmage](https://www.luogu.com.cn/user/411141)：提供了最初的贪心思路。

[403notfound](https://www.luogu.com.cn/user/891150)：在代码出错时写出 $O(n!)$ 暴力用于对拍及时查出错误。

进阶思路和代码由我想出并编写。

---


# Dreamoon and Sets

## 题目描述

Dreamoon likes to play with sets, integers and ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF476D/9ecd8274ff74f04a3c110790f7ff835d44a6c25f.png). ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF476D/8ea8f21b5c14716258752d62a549551fbdbf04b7.png) is defined as the largest positive integer that divides both $ a $ and $ b $ .

Let $ S $ be a set of exactly four distinct integers greater than $ 0 $ . Define $ S $ to be of rank $ k $ if and only if for all pairs of distinct elements $ s_{i} $ , $ s_{j} $ from $ S $ , ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF476D/dd0b12b681c32c8696e149f43e49ae7211e0b09c.png).

Given $ k $ and $ n $ , Dreamoon wants to make up $ n $ sets of rank $ k $ using integers from $ 1 $ to $ m $ such that no integer is used in two different sets (of course you can leave some integers without use). Calculate the minimum $ m $ that makes it possible and print one possible solution.

## 说明/提示

For the first example it's easy to see that set $ {1,2,3,4} $ isn't a valid set of rank 1 since ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF476D/b50d3b1ab922da09703e2c03eee592786ae2b8c7.png).

## 样例 #1

### 输入

```
1 1
```

### 输出

```
5
1 2 3 5
```

## 样例 #2

### 输入

```
2 2
```

### 输出

```
22
2 4 6 22
14 18 10 16
```

# 题解

## 作者：王大神——A001 (赞：21)

[传送门](https://www.luogu.com.cn/problem/CF476D)

### 分析
首先我们要保证 $4$ 个数最大公约数是 $k$，那么我们可以最开始时枚举 $4$ 个互素的数，最后同时 $\times k$ 即可。

我们又要使最大数最小，那么我们可以枚举最小的互素的数来满足要求。

最小的互素四元组是：$1,2,3,5$

那么第一个就可以输出：$1\times k,2\times k,3\times k,5\times k$（若比 $k$ 小，那么不可能因子中有 $k$）。

但是题目让我们找的并不止有一组。那么下一组怎么找呢？

首先，我们要尽量往小找，不能有重复的数，所以接下来我们在 $4,6,7,8,…$ 中选数。

我们在来看一下第一个四元组的形式：$x,x+1,x+2,x+4$，由于连续的 $3$ 个奇数一定互质，奇数和偶数一定互质，所以找两连续的三个数再往后凑一个奇数即可满足要求。

下一个合法四元组：$7,8,9,11$

我们可以看成 $6$ 个数分成一组，然后枚举大组输出即可。

### 证明此方法最大值最小
由于找到的四元组的值不能重复，我们选的数的密度已经很大，但还是说明不了我们找的最大值是正确的。

现在假设我们目标要找 $4$ 组符合要求的四元组(为了方便描述我们取 $k=1$)。

按照我们的规律找到的最大值是 $23$，那么我们假设存在一种方法，结果的最大值比它小。

设四组的四元组值分别为：

$a_1,a_2,a_3,a_4$

$b_1,b_2,b_3,b_4$

$c_1,c_2,c_3,c_4$

$d_1,d_2,d_3,d_4$

这些的取值范围是 $[1,22]$。

我们要保证每个四元组中的数两两互质，所以每个四元组不能同时存在某一个数的倍数。

首先我们可以整理出我们有 $8$ 个质数（$2,3,5,7,11,13,17,19$）在加上 $1$，它们一定两两互质。我们现在可以保证 $9$ 个数的填充，还剩下 $7$ 个数，只要能填进去，那么就可以证明 $23$ 不是最小的最大值。

如果我们先让 $9$ 个数成两个四元组 $2,3,5,7$ 和 $11,13,17,19$ 因为 $1$ 和任何数不冲突，所以放在心的一组中，成功的可能性更大一些。

现在还剩下：$4,6,8,9,10,12,14,15,16,18,20,21,22$

在我们选出 $1,4,9$ 后发现，选不下去了。

我们换一种放质数的方法试试：

我们知道每个四元组要求两两互质，所以只能使用 $4$ 个 $2$ 的倍数的数。

我们直接选最优情况：$2,4,8,16$ 因为它们只占了一个质数。

然后选 $3$ 的倍数的数：$3,9,15,21$（注意不能再选 $2$ 的倍数的数）

现在我们已经解决了 $8$ 个数的选择，选质数一定是最优的，还剩下：$5,7,11,13,17,19$ 加上 $1$ 一共 $7$ 个数。我们将选出的数搭配一下：

$16,11,13,21$

$8,15,17,19$

$4,5,7,9$

$1,2,3,?$

我们按照最优的方法填好后，发现只剩一个位置了。我们还剩下的数：$6,10,12,14,18,20,22$。

我们每组中都用过了 $2$ 的倍数的数，选的数是通过最优的情况选出的，但是不可能再选别的数了。

为什么会这样？

其实很简单：$[1,22]$ 中有 $11$ 个数是 $2$ 的倍数，我们只能选 $4$ 个，相当于抛弃了 $7$ 个数。我们要找到 $16$ 个数，一共 $22$ 个数，扔了 $7$ 个，就剩 $15$ 个了，所以不可能选出 $16$ 个的。

同时，我们还说明了如果要找最小的最大值那么 $2$ 的倍数的数一定会出现在每一组四元组中。

我们知道了一定会选一个偶数，那么选的数越小最好。两个自然数互质，所以会选这个数的相邻的一个数，这个数是奇数。

也就是说，如果我们选出一个偶数是 $x$，那么我们一定会选 $x+1$，连续的两个奇数一定互质（下面会有连续的 $3$ 的奇数一定互质的证明），所以 $x-1$ 也会选。

但是，$x+2$ 一定不会选，因为 $\gcd(x,x+2)=2$，那么如果 $x+3$ 可以选，$x+3$ 一定是这个四元组的最大值，同时也是最小的最大值。

奇数和偶数一定互质，那么只要证明 $x-1,x+1,x+3$ 互质，就能证明方法的正确性，并且找到了最小的最大值。

### 连续的 $3$ 个奇数互质
设三个奇数为：$2x+1,2x+3,2x+5$

假设前两个奇数不互质，有公因子 $k(k\not= 1)$,那么：$\frac{2x+3}{k}=\frac{2x+1}{k}+m$（$m$ 是整数）

$$2x+3=2x+k\times m+1$$

$$k\times m=2$$

$$\because 2=1\times 2,2=2\times 1,k\not= 1$$

$$\therefore k=2,m=1$$

但是，奇数的因数中不会出现 $2$，矛盾。所以 $2x+1,2x+3$ 互质，$2x+3,2x+5$ 同理。

假设 $x2+1,2x+5$，不互质，有公因子 $k(k\not= 1)$，那么：$\frac{2x+5}{k}=\frac{2x+1}{k}+m$ （$m$ 是整数）

$$2x+5=2x+k\times m+1$$

$$k\times m=4$$

$$\because 4=1\times 4,4=4\times 4,4=2\times 2,k\not= 1$$

$$k=4,k=2$$

但是，奇数的因数中不会出现 $4,2$，矛盾。所以 $2x+1,2x+5$ 互质。

**注意：连续的 $4$ 个奇数就不同了：$3,5,7,9$，$3,9$ 不互素**

$\frac{2x+7}{k}=\frac{2x+1}{k}+m$ （$m$ 是整数）

$$2x+7=2x+k\times m+1$$

$$k\times m=6$$

$$\because 6=1\times 6,6=6\times 1,6=2 \times 3,6=3\times2, k\not= 0$$

$$k=6,k=3,k=2$$

注意：$k=3$ 时，是可能成立的，它可能成为奇数的因数。

$$2x+7=2x+1$$

$$x=3$$

有解，所以四个连续的奇数不是一定是互质的。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int r_r(){//快读 
	int k=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar(); 
	}
	return k*f;
}
int n=r_r(),k=r_r(),x;
int main(){
	printf("%d\n",(n*6-1)*k);//计算 
	for(int i=1;i<=n;i++){
		x=i*6-5;
		printf("%d %d %d %d\n",x*k,(x+1)*k,(x+2)*k,(x+4)*k);//输出 
	}
	return 0;
}
```

---

## 作者：whiteqwq (赞：9)

[CF476D Dreamoon and Sets](https://www.luogu.com.cn/problem/CF476D)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1804829)

## 题意

给定 $n,k$ ，构造 $n$ 个元素互不相同的四元组，使得每个四元组的最大公约数为 $k$ 。

求所有元素最大值最小的一组构造。

$1\leqslant n\leqslant 10000,1\leqslant k\leqslant 100$

## 分析

有点套路的MO题。

首先把所有四元组除以 $k$ ，那么所有四元组的最大公约数为 $1$ 。

考虑任意一个四元组都只能存在一个偶数，那么奇数起码三个，于是我们答案的下界为 $6(n-1)+5=6n-1$ 。

构造一组方案达到下界：

由于 $\gcd(a,b)=\gcd(a,b-a)$ ，我们贪心的让方案内的差尽可能小，于是我们直接把最近的三个奇数和一个偶数放在一个四元组内，即第 $i(0\leqslant i<n)$ 组为 $6i+1,6i+2,6i+3,6i+5$ 。

由 $\gcd(a,b)=\gcd(a,b-a)$ 不难得知两两之间 $\gcd$ 都为 $1$ ，于是方案合法。

时间复杂度 $O(n)$ 。

## 代码
```
#include<stdio.h>
int n,k;
int main(){
	scanf("%d%d",&n,&k);
	printf("%d\n",(6*n-1)*k);
	for(int i=0;i<n;i++)
		printf("%d %d %d %d\n",(6*i+1)*k,(6*i+2)*k,(6*i+3)*k,(6*i+5)*k);
	return 0;
}
```

---

## 作者：沉冥Charming (赞：9)

·蒟蒻题解，描述可能不专业，证明可能不够严谨或有错误成分……
  如有问题欢迎批评指正！

·根据题意，显而易见四元组中每一个数可以表示为ka(~~别问我为什么不是ak~~),kb,kc,kd.
  将这四个数分别除k，可得a,b,c,d.由于k为最大公约数，a,b,c,d互质.

·因此题目可以转化为构造多组a,b,c,d使得四个数互不相同且互质.
  题目中说要让最大值尽量小，那么每组数中a,b,c,d的值越接近,就能使最大值越小.

·a,b,c,d互质，所以a,b,c,d中最多有一个偶数
  为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数.

·进一步转换，我们可以将a,b,c,d设为x,x+m1，x+m2,x+m3.
  由小学数学可知相邻的两个正整数数是互质的，相邻的两个奇数也是互质的（~~不会请百度~~）

·因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2.
  由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质.

·接着我们开始考虑第四个数，由于x+2为偶数，故第四个数为奇数，即其不为x+3.
  那么第四个数可以是x+4吗？显然，x+4与x+2互质，所以我们先假设其成立再进一步判断可行性.
  我们知道连续n个正整数必有一个数能被n整除，不考虑1,2，易知四元组中前三个数中必有一个数被3整除
  有可能x+1和x+4均为3的倍数吗？"要求n个四元组内最大的数最小",所以最小的x是从1开始的,依此推断，
  第i组二元组的x值为(i-1)*6+1,故x+1不可能是3的倍数.

·考虑完很多琐碎细节后，我们可以发现这样的构造即是符合题目条件的，
  所以可以开始愉快地写代码了，最后你会发现你轻松水了一道紫题！

·附上代码：
```cpp
#include<iostream>
using namespace std;
int n,k;
int main()
{
    cin>>n>>k;
    cout<< k*(6*n-1)<<endl;
    for (int i=1;i<=n;i++)
    {
        int x=(i-1)*6+1;
        cout<<k*x<<" "<<k*(x+1)<<" "
            <<k*(x+2)<<" "<<k*(x+4)<<endl;
    }
    return 0;
}
```


---

## 作者：Plozia (赞：6)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/121408956)

一道思维题，但是可以手玩。

首先发现一个规律，那就是在我们输出的所有四元组 $(a_i,b_i,c_i,d_i)$ 中，对所有数除以 $k$ 之后得到的四元组 $(\dfrac{a_i}{k}, \dfrac{b_i}{k}, \dfrac{c_i}{k}, \dfrac{d_i}{k})$ 中的数两两互质。

这个的大致证明就是假设有两个数 $\dfrac{a_i}{k},\dfrac{b_i}{k}$ 不互质，那么原数字 $a_i,b_i$ 的最小公倍数肯定是 $pk,p \in N_+$，与题目不符，证完了。

接下来我的做法是大眼观察样例，能简化成如下形式：

```plain
1 2 3 5

1 2 3 11
7 9 5 8
```

发现如果将样例 2 中第一行 11 和第二行 5 交换以下，就跟样例 1 一样了，于是得到如下结果：

```plain
1 2 3 5
7 8 9 11（排了序）
```

emm 这样就能够看出大致规律了吧，果断猜一手四元组是形如 $(i-1,i,i+1,i+3)$ 之类的东西，其中 $i$ 是偶数并且为了保证没有重复数字那么 $i=2+6p,p \in N$。

然后考虑去证明这个结论是对的，首先答案最小很显然，因为我们已经将数尽可能压得小了，容易证明将其中一个小的没有被选上的数替代最大数会导致答案错误，关键是证明 $(i-1,i,i+1,i+3)$ 两两互质，首先因为 $i$ 是个偶数所以 $\gcd(i-1,i)=\gcd(i+1,i)=1$。

然后证明 $\gcd(i-1,i+1)=1$ 的话也很简单，首先 $i-1,i+1$ 都是奇数所以其 $\gcd$ 的质因数最小也要是 3，但是这两个数相差 2 所以不可能为 3，证完了。$\gcd(i+1,i+3)=1$ 的证明方式是类似的。

接下来是 $\gcd(i,i+3)=1$，首先因为 $i,i+3$ 奇偶性不同所以 $\gcd$ 无质因数 2，其次是因为 $i=2+6p$ 不能被 3 整除所以 $i,i+3$ 无质因数 3 所以证完了。

最后是 $\gcd(i-1,i+3)=1$，首先还是无质因数 2，然后 $i-1=1+6p,i+3=5+6p$，同样没有共同质因数 3，证完了。

综上就是 $n$ 个四元组 $(i-1,i,i+1,i+3),i=2+6p,p \in N$，其中第一个 $i$ 是 2。

代码过于简单不给了，记得最后乘上 $k$。

---

## 作者：hejianxing (赞：2)

[link](https://www.luogu.com.cn/problem/CF476D)

CF476D

一道有质量的思维题，至少对于没做过这类题的我来说。

# 题意

构造 $n$ 个四元组，满足：

- 每个数在所有四元组中只出现一次
- 每个四元组中任意两个数的 $\gcd$ 为 $k$

要求所有四元组中最大的数最小。

$1\le n\le 10000,1\le k\le 100$。

# 题解

容易想到先求 $k=1$，也就是任意两数互质的情况，然后每个数再乘上 $k$。故直接考虑 $k=1$ 的情况。

观察小数据：当 $n=1$，答案为 $(1,2,3,5)$。当 $n=2$，大力手摸可以得出答案为 $(1,2,3,5),(7,8,9,11)$。当然后面的四元组也可以是 $(7,4,9,11)$。

能够想到符合直觉的贪心：每个四元组都从没有被选的数里面选四个满足条件的最小的数。结合样例，可以猜到每个四元组为 $(x,x+1,x+2,x+4)$，每 $6$ 个整数为一组（指 $1\sim 6,7\sim 12,\dots$），从中选出这四个数。考虑证明这个结论。

首先令 $x$ 为这一组的六个数中最小的数，它是一个奇数。

证明互质：前 $3$ 个数是相邻的三个数，它们之间显然互质。若 $x$ 与 $x+2$ 要互质，显然公因数只能是 $x+2-x=2$ 的因数，因为有 $x=k_1 d,x+2=k_2 d\Rightarrow x+2-x=(k_2-k_1)d=2$，$d$ 只能是 $2$，而 $x$ 与 $x+2$ 都是奇数，故互质。$x+2$ 与 $x+4$ ，$x$ 与 $x+4$ 之间同理。$x+1$ 与 $x+4$ 的公因数只能是 $3$，而 $x+1$ 可以表示为 $6k+2$，其肯定不是 $3$ 的倍数，故这两个数也互质。

证明最大值最小：这个构造方案的最大值易得是 $6n-1$。假设最大值小于 $6n-1$，设这个数为 $m$。显然四元组内最多只能有一个偶数。$m$ 里面有 $\lfloor\frac m 2\rfloor$ 个偶数，只需要 $n$ 个偶数填入四元组内，相当于我们丢弃了至少 $\lfloor\frac m 2\rfloor-n$ 个数，现在剩下 $m-(\lfloor\frac m 2\rfloor-n)=\lceil\frac m 2\rceil+n\le \lceil\frac {6n-2} 2\rceil+n=4n-1$ 个数可选，要填入 $4n$ 个空位里，显然是不可能的。

于是直接造就行了。时间复杂度 $O(n)$。

# 实现

记得要乘 $k$。代码巨短。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k;
int main() {
	scanf("%d%d", &n, &k);
	printf("%d\n", (6 * n - 1) * k);
	for (int i = 1; i <= 6 * n; i += 6) printf("%d %d %d %d\n", i * k, (i + 1) * k, (i + 2) * k, (i + 4) * k);
	return 0;
}
```

# 启示

- 互质的题考虑偶数，其必有 $2$ 这个因子，是一个可能的突破点
- 构造题多造点数据手玩，观察样例更好深入理解题目



---

## 作者：zry……yrz (赞：2)

[传送门](https://www.luogu.com.cn/problem/CF476D)

前置芝士：

1. 对于一个四元组 $ {a,b,c,d} $ 若其最大公约数为 $m$，则四元组 $ {ak,bk,ck,dk} $ 的最大公约数为 $mk$。

2. 任意两个偶数的最大公约数最小为 $2$。

3. 对于连续的 $n$ 个正整数，有且仅有一个为 $n$ 的倍数。

由 $1$ 可易将本题 $k>1$ 的情况转化为 $k=1$，那么就只需考虑 $k=1$ 时的情况。

然后由 $2$ 可得，满足题面要求的四元组中最多只能有一个偶数，考虑一个四元组包含三个奇数和一个偶数。

假设该四元组为 $ {3i-2,3i-1,3i,3i+2} $，$i$ 为正奇数，即 $3i-2$，$3i$，$3i+2$ 为奇数，$3i-1$ 为偶数，那么结合 $3$ 可证该四元组中最多只有一个数为 $5$ 的倍数，并且只有 $3i$ 为 $3$ 的倍数，根据 $3$ 可进一步推出该四元组中任意两个数不可能同时为大于 $5$ 的整数的倍数，从而可得该四元组符合要求。

因为构造该四元组奇数的增长速度比偶数快，故要使方案最优只需确保相邻四元组奇数连续。易证 $(3i+2)+2=3(i+2)-2$，所以这种构造方案为最优解。

同理，所有四元组中的最大数为 $3\times(2n-1)$。

时间复杂度为 $O(n)$。

------------

```cpp
//いつもこのような人がいます。優しくしてあげたいです。
#include <bits/stdc++.h>
using namespace std;
int n,k,i,p;
inline int read()//快读
{
	int s=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=(s<<3)+(s<<1)+c-'0';
		c=getchar();
	}
	return s*f;
}
signed main()
{
	n=read(),k=read();
	printf("%d\n",((n*2-1)*3+2)*k);
	for(i=1;i<=n;i++)
	{
		p=(i*2-1)*3;
		printf("%d %d %d %d\n",(p-2)*k,(p-1)*k,p*k,(p+2)*k);
	}
	return 0;
}
```


---

## 作者：0xFF (赞：1)

#### 题目大意


------------
给定 $n$ 和 $k$，构造 $n$ 个四元组满足这 $n$ 个四元组内的所有数两两之间的最大公约数为 $k$。

#### 思路分析


------------
观察样例不难发现 $n=1$ 时满足条件的数翻倍后全都出现在了 $n=2$ 的情况中，且 $n=2$ 时满足条件的数都是 $n=1$ 时满足条件的数的倍数。

由此不难想到可以构造一组可行的解。

由于所有数都含有一个最大公约数 $k$，所以将 $k$ 提出后，剩下的所有数全部互质即可满足题设。

首先考虑如何使得一个四元组内的所有数都互质且最大值最小。首先，任何连续的两个偶数必然无法互质，所以这四个数必然三奇一偶。显然，最小的满足以上条件的四元组即为 $(1,2,3,5)$，同理，$(7,8,9,11)$ 也满足条件，所以上下两行四元组对应位置必然相差 $6$，所以任意四元组就可以表示为 $(n,n+1,n+2,n+4)$ 这样就能推出最大的数是 $k \cdot (1+6(n-1) +4)$ 化简得 $6 \cdot k \cdot n - k$。

最后循环输出方案即可。

#### 代码实现


------------
```cpp
int main(){
	cin>>n>>k;
	cout<<6*k*n - k<<endl;
	for(int i=1,j=1;i<=n;i++,j+=6){
		printf("%lld %lld %lld %lld\n",k*j,k*(j+1),k*(j+2),k*(j+4));
	}
	return 0;
}
```


---

## 作者：wmy_goes_to_thu (赞：1)

首先 $k$ 是没用的，所以假定 $k=1$。

那么任意两个偶数都不能同时出现。

若 $x$ 恰好满足要求，那么应该有 $\dfrac{x}{2}+n=4n$，即 $x=6n$。

然后构造一下，根据样例 $1$，发现满足条件：

$6n-5 \ 6n-4 \ 6n-3 \ 6n-1$

就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,k;
	cin>>n>>k;
	cout<<(6*n-1)*k<<endl;
	for(int i=1;i<=n;i++)
		cout<<(6*i-5)*k<<" "<<(6*i-4)*k<<" "<<(6*i-3)*k<<" "<<(6*i-1)*k<<endl;
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：1)

提供 python 题解

## 题目大意
输入 $n,k$，输出 $n$ 个四元组。

满足以下条件：

- 对于任意一个四元组，其中任意两个数的最大公约数是$k$。

- 每个数在四元组内只出现一次。

要求 $n$ 个四元组内最大的数最小。

第一行输出最大的数，下面 $n$ 行输出四元组。


数据范围：
$1\le n\le 10000$，$1\le k\le 100$。

## 大体思路
思路参考楼上两位大佬。

根据题意，显而易见四元组中每一个数可以表示为 $k\cdot a,k\cdot b,k\cdot c,k\cdot d$。 将这四个数分别除以 $k$，可得 $a,b,c,d$。由于 $k$ 为最大公约数，$a,b,c,d$ 互质。

- 因此题目可以转化为构造多组 $a,b,c,d$ 使得四个数互不相同且互质。 题目中说要让最大值尽量小，那么每组数中 $a,b,c,d$ 的值越接近,就能使最大值越小。

- $a,b,c,d$ 互质，所以 $a,b,c,d$ 中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有 $1$ 个偶数，$3$ 个奇数。

- 进一步转换，我们可以将 $a,b,c,d$ 设为 $x,x+m_1，x+m_2,x+m_3$。 可知相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。

- 因此我们先尝试令 $m_1=1,m_2=2$,即四元组中前三个数为 $x,x+1,x+2$。 由于四元组中最多只有一个偶数，故 $x$ 为奇数，根据以上易证的结论可知这三个数一定互质。

- 接着我们开始考虑第四个数，由于 $x+2$ 为偶数，故第四个数为奇数，即其不为 $x+3$. 那么第四个数可以是 $x+4$ 吗？显然，$x+4$ 与 $x+2$ 互质，所以我们先假设其成立再进一步判断可行性. 我们知道连续 $n$ 个正整数必有一个数能被 $n$ 整除，不考虑 $1,2$，易知四元组中前三个数中必有一个数被 $3$ 整除 有可能 $x+1$ 和 $x+4$ 均为 $3$ 的倍数吗？要求 $n$ 个四元组内最大的数最小,所以最小的 $x$ 是从 $1$ 开始的,依此推断， 第 $i$ 组二元组的 $x$ 值为 $(i-1)\times 6+1$,故 $x+1$ 不可能是 $3$ 的倍数，满足。

## 完整代码
```python
a,k=map(int,input().split())#单行内输入
print(k*(a*6-1))#最大值
i=int(1)
while True:#循环
    x=i*6-5;
    print(x*k,x*k+k,x*k+2*k,x*k+4*k)#构造输出
    i+=1
    if i>a: break
```

注意 python 的输入自动读入换行，因此同行输入需要用以下语句：

`变量,变量=map(类型,input().split())`

此外，python 输出自带换行，因此用空格隔开可使用：

`print(变量,end=' ') or print(a,b,c,d)`

---

## 作者：SakurajiamaMai (赞：0)

## 思路:
考虑每个四元组，对于 $k$ 来说，从最初的开始的第一组四元组，有 $k$，$2k$，$3k$，**此时第四个不能是 $4k$，因为 $2k$ 和 $4k$ 会有形成一个公约数 $2$** ，贪心的想此时应该整个四元组的序列应该为 $k$，$2k$，$3k$，$5k$。同理第二个四元组也应该是这种倍数关系，对比第二组的第一个来说，$7k$ 比 $6k$ 更优，因为 $7$ 是质数，以此类推即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=1e9+7;
string s;
int n,t,a[N],f[N],res,num,ans,m,k;
bool vis[N];
signed main()
{
    std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    cin>>n>>k;
    int num=k;
    if(n>1) cout<<n*k*5+k*(n-1)<<endl;
    else cout<<k*5<<endl;
    while(n--){
        for(int i=1;i<=4;i++){
            cout<<k<<' ';
            if(i>=3) k+=2*num;
            else k+=num;
        }
        cout<<endl;
    }
    return 0;
}
```



---

## 作者：smydahaoren (赞：0)

[原站链接](https://codeforces.com/problemset/problem/476/D)


------------
### 思路分析：

题目说构建一个 $4$ 元组，我假设它是 $(a,b,c,d)$，题目说这个四元组任意两个数的最大公约数是 $k$。那么，$(\frac{a}{k},\frac{b}{k},\frac{c}{k},\frac{d}{k})$ 两两互质。

接下来构造一个最大的数尽量小的四元组。

如果这个四元组中有 $1$ 个以上的偶数，那么显然不两两互质，不符合题意。

那么四元组中有至少 $3$ 个奇数，为了让最大的数尽力小，那么最优选择肯定是把剩下的一个数选择为偶数并且穿插在奇数里面。

接下来证明 $3$ 个相邻的奇数肯定两两互质。

设这三个相邻的奇数为 $x$，$x+2$，$x+4$。（$x$ 是奇数）

那么这三个数的因数都是奇数。

如果 $x$ 和 $x+4$ 不两两互质，存在不为 $1$ 的正整数 $k$ 是他们的公因数。

那么 $(x+4)-x=4$ 也是 $k$ 的倍数，则 $k=2$。显然与因数都是奇数矛盾。

同样的办法证明其他两种情况。

那么为了满足题意，肯定选择尽量小的数凑出四元组。则可以选择的奇数为：$(1,3,5)$，$(7,9,11) \cdots(6\times i+1,6\times i+3,6\times i+5)$。（$i$ 为自然数）

接下来把偶数插进去，四元组变成：$(1,2,3,5)$，$(7,8,9,11) \cdots(6\times i+1,6\times i+2,6\times i+3,6\times i+5)$。（$i$ 为自然数）

当然：$(1,3,4,5)$，$(7,9,10,11) \cdots(6\times i+1,6\times i+3,6\times i+4,6\times i+5)$。（$i$ 为自然数）

这样的四元组也是符合题意，测了一下，也是对的。



------------
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main()
{
	cin>>n>>k;
	cout<<k*(6*n-1)<<endl;
	int x=-5;
	for(int i=1;i<=n;i++){
		x+=6; 
		cout<<k*x<<" "<<k*(x+2)<<" "<<k*(x+3)<<" "<<k*(x+4)<<endl; 
	}
	return 0;
}

```


---


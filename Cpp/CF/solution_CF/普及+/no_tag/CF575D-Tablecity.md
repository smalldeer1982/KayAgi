# Tablecity

## 题目描述

`Tablecity` 发生了一起重大银行抢劫案，为了将小偷绳之以法，总统指派警察局局长 `Albert` 去执行抓捕小偷的任务。他不知道小偷在哪里，但他知道小偷会怎么走。

`Tablecity` 可以看作是一个$1000×2$的一个坐标系，一个单元格看作是一个区。小偷只能往左上角，右上角，左下角，右下角，正左边和正右边移动。

`Albert` 有足够的人手，可以保证每个小时搜完两个区。在任何时刻小偷如果在搜索范围内，小偷就会被抓获。`Albert` 警长已经向总统承诺在 $2015$ 个小时内完成任务，他需要你的帮助来达到这个目标。

## 说明/提示

考虑以下输出：
```
2

5 1 50 2

8 1 80 2
```

## 样例 #1

### 输入

```
В этой задаче нет примеров ввода-вывода.
This problem doesn't have sample input and output.```

### 输出

```
Смотрите замечание ниже.
See the note below.```

# 题解

## 作者：y_kx_b (赞：2)

这题 [$\text{t\color{red}ourist}$](https://codeforces.com/profile/tourist)$\ 3$ 分钟就 A 了，但我们毕竟不是 $\text{t\color{red}ourist}$，脑回路肯定没有他快，~~……所以这就是这道题过了 7 年仍没有题解的理由吗？？？~~

……

这题虽然 1700，但肯定比其他 1700 题良心，……起码代码应该是最短的 ~~毕竟是提答~~。思路应该也是比较好想的（~~我想了半个小时~~）。

~~双击题号可以跳题，链接我就不放了。~~

闲话就说到这里。

Sol.
-
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF575D/a0d5ba8aa7c91df3fc0d8a3e1cc7b99b3bbd4635.png)

1. 首先，我们的策略是把小偷逼到某一个死角，~~再使用无缝大法~~，就可以抓到小偷，**且是抓到小偷的唯一办法**。为什么呢？

显然，除了 $(1,1),(1,2),(1000,1),(1000,2)$，小偷都有四个方向可以逃跑，这时硬抓肯定抓不住；只有上述四个点小偷只有两个方向可以逃跑，把这两个格子封死，由于每一小时小偷必定改变一次 $x$ 坐标，所以小偷一定会被抓到。

那么，怎么把小偷逼到死角呢？

2. 我们发现，两个抓捕格子必须在同一列，否则小偷就可以乱窜。

这是因为，你可以视为小偷在 $y$ 轴是可以自由移动~~♂~~的，因为小偷每小时可以走到的格子的 $x$ 坐标是不受 $y$ 坐标影响的，同一 $x$ 坐标的两个格子都可以走到。所以如果只堵一个，小偷可以走那个你没堵的，堵上的那个就相当于没堵了。

3. 逼到死角的方式：从左到右或从右到左，扫一遍即可。

比如，一次 $(1000,1),(1000,2)$，接下来就可以 $(999,1),(999,2)$，$(998,1),(998,2)$，如果小偷一开始在 $(999,?)$ 那么就会逼到 $(998,?)$，$(997,?)$，$(996,?)$，直到逼到死角：因为他无法往右移动。

那么你可能会问：如果小偷一开始在 $(998,?)$，那么第一次$(999,?)$，第二次 $(1000,?)$ 不就没有堵成功了吗？

容易发现，上述堵法只适用与开始横坐标为奇数的情况。对于另外一半情况，可以先瞎 $\sout{2\sqrt2}$ 堵一下，然后一开始横坐标为偶数的小偷现在的横坐标一定是奇数了；再扫一遍即可。

这是我的做法（$n=2001$），当然还有其他吊打我的做法。

我的代码：（$n=2001$）
```cpp
puts("2001");
for(int i=1000;i>1;i--)
	printf("%d 1 %d 2\n",i,i);
puts("2 1 2 2");
puts("2 1 2 2");
for(int i=1000;i>1;i--)
	printf("%d 1 %d 2\n",i,i);
puts("2 1 2 2");
```

当然，赛时很多 CF 大佬有更优的解法，链接就贴这，感兴趣的同学可以自己去看呐。

[比赛榜单](https://codeforces.com/contest/575/standings)

---


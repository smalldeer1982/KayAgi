# Rebus

## 题目描述

You are given a rebus of form ? + ? - ? + ? = n, consisting of only question marks, separated by arithmetic operation '+' and '-', equality and positive integer $ n $ . The goal is to replace each question mark with some positive integer from $ 1 $ to $ n $ , such that equality holds.

## 样例 #1

### 输入

```
? + ? - ? + ? + ? = 42
```

### 输出

```
Possible
9 + 13 - 39 + 28 + 31 = 42
```

## 样例 #2

### 输入

```
? - ? = 1
```

### 输出

```
Impossible
```

## 样例 #3

### 输入

```
? = 1000000
```

### 输出

```
Possible
1000000 = 1000000
```

# 题解

## 作者：Sharpsmile (赞：0)

# CF663A 题解
因为这个题没有题解，所以我决定写一篇 ~~水点咕值~~ 造福后来者。

题目难度目前暂无评定，不过目测不会超过橙题。

## 题目大意：
给你一个由问号、加、减、等于号构成的字符串和一个变量 $n$ 组成的等式。

大概长这样：`? + ? - ? = n `。

你现在要给每一个问号赋一个在 $1$ 到 $n$ 之间的值，使得该等式成立。

如果不可以的话输出一行一个字符串 `Impossible`。

否则输出两行，第一行一个字符串 `Possible`， 第二行输出该等式将问号都赋值之后的结果。

## 题目解法

一个满简单的题 ~~然而我吃了两发罚时~~ 。首先我们知道对于一个这样的一大堆问号的式子而言，无论怎样赋值他等式右边能够出现的结果在整数集合中一定是连续的一块，这个十分显然，你就考虑现在达到了一个值，你想让他变大的话可以找一个前面是加号的变量加一或者找个前面是减号的减一。

如果一个问号前面是加号或者他是式子的第一个变量，我们称他为"正变量"，反之称他”复变负“。设正变量有 $P$ 个，负变量有 $N$ 个（正负变量都是正数，只是后面在计算的时候一个加一个减）。整个等式的的结果称为 $S$。

然后贪心的去取，显然最后等式的最大值一定是把所的正变量取最大的同时负变量取最小，最小值反之。

于是我们有最后等式的值域边界 $L=P-n\times N,R=n\times P-N$。

同时我们还知道正负变量和的上下界：$L_P=P,R_P=P\times n,L_N=N,R_N=N\times n$。易知只要正负变量的和

判断一下 $n$ 是否在这个区间中就能得到是否有解。

对于有解的情况，我们可以先令 $S=L$，那么这个时候我们只需让 $S$ 增加到 $n$ 即可。要么我们上调正变量的和或者下调负变量的和。如果一个调整到了极限仍然不行就调另一个。

调整结束之后我们即可开始着手于构造，现在我们的目标变成了：已知正变量的和为$ SP$，负变量的和为 $SN$，为他们构造一组解出来。

显然这个时候正负变量的构造就是独立的了。

对于一类变量构造时，我们先定出下界——每个变量都为一，剩下的和找前几个顶满放即可。实现可以看代码。

## CODE （构造部分）

```cpp
	int NN=N,PP=P*n;//NN就是SN，PP就是SP，这里实现的时候是从高向低调整，是同理的
        while(PP-NN>n){
            if(PP==P)NN+=PP-NN-n;
            else PP-=min(PP-NN-n,PP-P);
        }
        while(N--){
            qN.push_back(min(NN-N,n));
            NN-=qN.back();//qN存储了所有的负变量
        }
        while(P--){
            qP.push_back(min(PP-P,n));
            PP-=qP.back();//qP存储的是所有的正变量
        }
```



---


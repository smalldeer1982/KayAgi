# Leha and Function

## 题目描述

Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$ 。考虑所有集合$[1,2,\dots,n]$ 的有$k$ 个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$  — 就是所有$k$ 个元素子集中的最小元素的数学期望。

但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$ 和$B$ ，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$ ）都有$a_i\geq b_j$ 。帮助Leha重新排列$A$ 数组来使得有最大的$\sum_{i=1}^m F(A_i',B_i)$ ，$A'$ 是重排后的数组。

## 样例 #1

### 输入

```
5
7 3 5 3 4
2 1 3 2 3
```

### 输出

```
4 7 3 5 3
```

## 样例 #2

### 输入

```
7
4 6 5 8 8 2 6
2 1 2 2 1 1 2
```

### 输出

```
2 6 4 5 8 8 6
```

# 题解

## 作者：素质玩家孙1超 (赞：2)

感觉这个题没有蓝题难度。

题意：

设 $F(n,k)$ 是在 $[1,2,...,n]$ 里面去 $k$ 个，最小的数的期望值。

给你两个数组 $A,B$ 要求对 $A$ 数组进行重排得到 $A'$ ，使得 $\sum_i F(A',B)$ 最大，输出重排后的 $A'$。

---

结论题，大概有三种方式搞到结论。

1. 直接猜：感性考虑对于一个大的 $n$ 我们要充分利用，应该对应一个小的 $k$ （当 $k$ 增大时，$F(n,k)$ 会对应变小，且和 $n$ 有关），并且看样例确实是对的。

2. 理性证明：在 $[1,2,...,n]$ 中取 $k$ 个数，相当于把 $[0,n+1]$ 分成 $k+1$ 个部分，每一部分都是等价的，所以每一段的期望长度就是 $\frac{n+1}{k+1}$ ,那么最左边一段的期望长度也是这个，所以最左边一段的右端点的期望即 $F(n,k)=\frac{n+1}{k+1}$ 。

3. 暴力推：直接列式子 

$$F(n,k)=\dfrac{\sum_{1\leq i \leq n-k+1}i\times C_{k-1}^{n-i}}{C_n^k}$$

然后阶商法 $\frac{F(n,k)}{F(n,k-1)}=\frac{k}{k+1}$ 或者怎么推一下都可以得出 $F(n,k)=\frac{n+1}{k+1}$。 


得出 $F(n,k)=(n+1)\times \frac1{k+1}$ 的式子之后 显然要大的 $n$ 和小的 $k$ 配对即可。

---

排序一下即可，核心代码：

```cpp
struct th
{
	int now,id;
}c[Maxn];
inline bool cmp(th x,th y){return x.now<y.now;}
int n,m,a[Maxn],b[Maxn],d[Maxn];
int main()
{
    n=R();for(int i=1;i<=n;i++) d[i]=R();for(int i=1;i<=n;c[i].id=i,i++) c[i].now=R();
    sort(d+1,d+1+n);sort(c+1,c+1+n,cmp);
    for(int i=1;i<=n;i++)a[c[i].id]=d[n-i+1];
    for(int i=1;i<=n;i++)printf("%d ",a[i]);
}

```


---

## 作者：Rubidium_Chloride (赞：1)

Math Problems.

来自 SH 的推荐，来做了这个题。

题面感觉描述挺清晰？

考虑先数归地证明以下命题：$F_{n,k}=\dfrac{n+1}{k+1}$。

对于 $n=1$ 的情况显然成立。

假设结论对 $n=p$ 的情况成立，考虑 $n=p+1$ 时的情况。

1. $k=n=p+1$，显然成立。
2. $0<k<n$，考虑 $n+1$ 是否在这个大小为 $k$ 的集合中，设集合为 $S$，$n+1\in S$ 有 $\binom{n}{k-1}$ 种情况，期望为 $F_{n,k-1}$，$n+1\notin S$ 有 $\binom{n}{k}$ 种情况，期望为 $F_{n,k}$，所以 $F_{n+1,k}=\dfrac{\binom{n}{k-1}F_{n,k-1}+\binom{n}{k}F_{n,k}}{\binom{n+1}{k}}$，利用组合数的定义化简即得证。

为了方便说明，设序列 $\{c\},\{d\}$ 使 $c_i=A_i+1,d_i=B_i+1$，即求一种方案使得 $\sum\limits_{i=1}^n\dfrac{c_i}{d_i}$ 最大。

使用排序不等式即得知应该将较大的 $c_i$ 对应较小的 $d_i$。

```cpp
n=read();for(int i=1;i<=n;i++) a[i]=-read();
for(int i=1;i<=n;i++) b[i]=(node){i,read()};
sort(a+1,a+n+1),sort(b+1,b+n+1);
for(int i=1;i<=n;i++) ans[b[i].id]=-a[i];
for(int i=1;i<=n;i++) printf("%lld ",ans[i]);
```


---


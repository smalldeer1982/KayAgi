# Manipulating History

## 题目描述

> 身为人类时，她的能力是将已有的历史全盘抹消；变身为白泽时，则能创造历史。——《东方求闻史纪》

上白泽慧音具有操作历史程度的能力。      
幻想乡的历史，一开始是一个长度为 $1$ 的字符串 $s$。为了修复由于八云紫造成的历史错乱，她需要完成 $n$ 次操作。对于第 $i$ 次操作：

- 她会选择字符串 $s$ 中的一个非空子串 $t_{2i-1}$；
- 她会将 $t_{2i-1}$ 替换为 $t_{2i}$，注意这两者的长度可能是不一样的。

注意，如果 $t_{2i-1}$ 在字符串 $s$ 中出现多次，也仅仅只替换其中恰好一个。    
例如，如果有一个字符串 $s=\texttt{marisa}$，$t_{2i-1}=\texttt a$，$t_{2i}=\texttt z$，那么在一次操作后，字符串 $s$ 将会变成 $\texttt{marisz}$ 或者 $\texttt{mzrisa}$。    
在经过 $n$ 次这样的操作之后，慧音得到了最后的字符串以及 $2n$ 个 $t_i$。正当慧音觉得她完成了这项任务的时候，八云紫又一次出现并且打乱了所有的 $t_i$。更糟糕的是，慧音忘记了幻想乡最一开始的历史。     
请你帮助慧音求出幻想乡最一开始的历史。

## 样例 #1

### 输入

```
2
2
a
ab
b
cd
acd
3
z
a
a
aa
yakumo
ran
yakumoran```

### 输出

```
a
z```

# 题解

## 作者：IvanZhang2009 (赞：8)

## 题意
有一个未知的长度为 1 的字符串，和一组长度为 $n$ 的改变操作。每次操作将字符串中任意一个出现的子串 $t_{2i-1}$ 替换成 $t_{2i}$，最后得到一个新的字符串。将操作序列的 $2n$ 个字符串打乱顺序，求出 **唯一的** 原字符串，**保证有解**。

## 解法
重点：

1、原字符串长度为 1。

2、保证有且仅有一个解。

正解：

由于操作序列 $t_i$ 的顺序被打乱，我们只考虑每一个字母的出现次数。

观察每一次操作。每一次不管是删除了原来的子串，还是将新的字符串插入到子串的位置，都会对字母出现的次数造成影响。

每一个字母被添加或者删除，对这个字母最终出现次数都会有 $+1$ 或 $-1$ 的贡献。

把最终字符串当成一次操作，删除整串，并添加空串，则所有字母出现的次数都是 0，一个偶数。每一次次数 $+1$ 或 $-1$ 都会使这个字母出现的次数的奇偶性改变。

开始时只有一个字母出现次数为奇数，即中间改变次数为奇数（奇数的奇偶性改变奇数次后变成偶数）；其余字母改变次数为偶数（偶数的奇偶性改变偶数次后变成偶数）。

只需要记录操作中 $2n$ 个字符串和最终字符串中 26 个字母分别出现的次数，找到 **唯一** 的奇数，就是答案。

## 代码
```cpp
void Main() {
    int n;
    cin>>n;
    map<char,int>mp; //用map记录出现次数
    for(int i=0;i<=2*n;i++){ //直接考虑所有2n+1个字符串
        string s;
        cin>>s;
        for(int j=0;j<s.size();i++)mp[s[j]]++; //记录改变次数
    }
    REP(i,0,26)if(mp[char(i+'a')]&1)cout<<(char)(i+'a')<<endl;
    //找到奇数就输出
}
```
> update 2022.10.21: 修复出现的关于题意的问题。

---

## 作者：Cocoly1990 (赞：7)

好像有很多人喷这题的题面，我谢罪，这个题面其实是我写的。

**首先题目保证了一定有解**，而且开始只有一个字符，因此我们并不需要考虑在过程中字符串的具体形态，转而用抽象化的字符集 $\{cnt_a,cnt_b,cnt_c,\cdots,cnt_y,cnt_z\}$ 来表示，其中 $cnt_i$ 表示当前状态下第 $i$ 个字符出现的次数。

每次操作我们可以理解为选定一个串删除，在添加一个串，进一步抽象，选择一些 $i$，使 $cnt_i-1$，再选择一些 $j$，使得 $cnt_j+1$.

考虑到最初仅有一个字符，也就是说最后有且仅有一个 $i$,使得 $cnt_i=1$，对于其他的 $j\neq i$,$cnt_j=0$.

现在看来这题仍然是不可做的，因为我们并不知道哪些串是删除的，哪些是添加的，但我们真的有必要去知道吗？考虑到 $+1$ 和 $-1$ 能互相抵消，也就是如果要使 $cnt_i=0$，那么 $+1$ 和 $-1$ 的个数要是相等的，因此 $i$ 必然出现了偶数次。

开桶记录出现了奇数次的字符，即为答案。

---

## 作者：guozhetao (赞：2)

## 前言
在学校打模拟赛的时候遇到这个系列的题目，没想出来，讲解的时候才恍然大悟。
## 思路

首先，我们输入 $n$ 并将 $n \gets 2 \times 2 + 1$。第 $i$ 个字符串记为 $v_i$。我们假设最后一个操作将它清空且原始数组已知，那么：

- 每一个字母都会出现 $2k$（$k$ 为正整数） 次，才有可能将它清空（第一次为原始数组或替换而成，第二次再将其替换掉）。因为如果没有出现 $2k$ 次，那么必然会存留 $1$ 个字母。

所以，我们就找出出现次数为奇数的字母，输出即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[30];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	cin>>t;
	while(t--) {
		memset(a,0,sizeof(a));
		cin>>n;
		n *= 2;
		n++;
		while(n--) {
			string v;
			cin>>v;
			int x = v.size();
			for(int i = 0;i < x;i++) a[(int)v[i] - 96]++;
		}
		for(int i = 1;i <= 26;i++) if(a[i] & 1) cout<<char(i + 96)<<endl;
	}
}
```


---

## 作者：IYSY2009I (赞：2)

这道题如果直接说结论是很显然的，但想到比较不容易。

现在我们假设我们有一个字符在最终的字符串中存在，那么一定有被替换的字符串的该字符出现次数 $+$ 最终字符串中该字符出现的次数 $=$ 替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数。

举个例子，假如原来字符串是 `a`，将 `a` 替换为 `aa`，则显然有 $1+2=2+1$。

那么我们找到了一个判定方法：只要看对于一个字符，是否有上述特性就可以了。

但问题是现在 $t$ 被打乱了，如何判定呢？

我们对上面那个式子两边 $+$ $($替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数$)$:

被替换的字符串的该字符出现次数 $+$ 最终字符串中该字符出现的次数 $+$ 替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数 $=$ 替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数 $\times 2$。

因为替换被替换的字符串的该字符出现次数和原来字符串中出现的该字符次数一定为非负整数，所以等式右边一定是偶数，等式左边就是偶数。

又因为原来字符串的长度为 $1$，所以如果被替换的字符串的该字符出现次数 $+$ 最终字符串中该字符出现的次数 $+$ 替换被替换的字符串的该字符出现次数为奇数，则原来的字符串一定是该字符。

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
void cf(){
	int n;
	scanf("%d",&n);
	int ans[27];
	for(int i=1;i<=26;i++)
		ans[i]=0;
	for(int i=1;i<=n;i++){
		string t1,t2;
		cin>>t1>>t2;
		for(int j=0;j<t1.size();j++)
			ans[t1[j]-'a'+1]++;
		for(int j=0;j<t2.size();j++)
			ans[t2[j]-'a'+1]++;
	}
	string t;
	cin>>t;
	for(int i=0;i<t.size();i++)
		ans[t[i]-'a'+1]++;
	for(int i=1;i<=26;i++)
		if(ans[i]%2){
			printf("%c\n",char('a'+i-1));
			return;
		}
}
int main(){
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
		cf();
	return 0;
}
```

---

## 作者：yinhy09 (赞：1)

第一次打夜间 CF 比赛，正赶上 Wdoi 超级良心思维场。本人 CF newbie 都差点过掉 D，差点就上绿了 qwq

话不多说，开始讲题：

## 思维讲解：

如果一个字符既不在始串也不再终串当中，那么这个字符一定经历了同样次数的进和出，则这个字符在 $s$ 和 $t$ 中必然出现**偶数次**。

然而题面还保证了初始的串只有一个字符，所以只要统计一下那个字符出现奇数次输出就行啦。

## qwq~AC CODE：

```cpp
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define _rep(i,a,b) for(int i=(a);i<(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define _per(i,a,b) for(int i=(a);i>(b);i--)
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
#define endl printf("\n")
ll read()
{
	char c;
	ll x=0;
	int f=1;
	c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
void write(ll x)
{
	if(x>9)write(x/10);
	putchar(x%10+'0');
	return;
}
ll T,n,tot;
string a[200005];
string s;
ll len=0;
ll t[1000];
int main(){
	T=read();
	while(T--)
	{
		memset(t,0,sizeof(t));
		n=read();
		rep(i,1,2*n)
		{
			cin>>a[i];
			len=a[i].length();
			rep(j,0,len-1)
			{
				t[a[i][j]-96]++;
			}
		}
		cin>>s;
		len=s.length();
		rep(i,0,len-1)
		{
			t[s[i]-96]++;
		}
		rep(i,1,26)
		{
			if(t[i]&1)printf("%c\n",i+96);
		}
	}
	return 0;
}
//Author:yinhy09,luogu user-id:575320
//Date:2022.6.3
//question ID:Codeforces1688C
```


---

## 作者：Noby_Glds (赞：1)

这题真的恶心到我了。
### 思路
直接把答案搬出来：

统计所有小写字母在所给所有字符串的出现次数，为奇数的就是答案。

别急着抄，我来证明一下：

对于一个字母，如果它不是答案……

要么就是**被替换来又替换走**，要么就是**被替换来，一直留在字符串上**。

前者会在被打乱的 $t$ 字符串中出现 $2$ 次。

后者会在 $t$ 字符串出现 $1$ 次，在最终字符串中出现 $1$ 次，还是 $2$ 次。

综上所述，出现次数为偶数的小写字母都不是答案！

那么只有出现次数为奇数的小写字母才是答案！

完美~~
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,k,num[26];
string a; 
int main(){
	cin>>t;
	while(t--){
		memset(num,0,sizeof(num));
		cin>>n;
		for(int i=1;i<=2*n+1;i++){
			cin>>a;
			for(int j=0;j<a.size();j++) num[a[j]-'a']++;
		}
		char ans;
		for(int i=0;i<26;i++) if(num[i]%2) ans=i+'a';
		cout<<ans<<endl;
	}
	return 0;
} 
```


---

## 作者：legend_cn (赞：0)


## 1 简化题目

这道题是一道思维题。题意是，有一个未知的长度为 $1$ 的字符串 $s_0$，接下来有 $n$ 次操作，每次可以将一个 $s_0$ 的子串 $s_1$ 替换为另一个字符串 $s_2$。现在给你的 $s_1$，$s_2$ 和最终操作完的字符串 $s$，求 $s_0$。

## 2 思路
由于一开始字符串长度为 $1$，对每一个字母进行分类讨论。

1. 该字符在某个字符串 $s_1$ 的之中，
 	- 修改了某个的字符串 $s_2$ 里的字符：则该字符在 $s_1$ 和 $s_2$ 里出现 $1$ 次。
   - 修改了某个的字符串 $s_0$ 里的字符：该字符无法匹配。
2. 该字符在某个字符串 $s_2$ 的之中，
	-  在后面的某个字符串 $s_1$ 里，被修改了：则该字符在 $s_1$ 和 $s_2$ 里出现 $1$ 次。
   - 不在后面的每个字符串 $s_1$ 里，没有被修改：则该字符在 $s_1$ 和 $S$ 里出现 $1$ 次。
   
最后，所有字符串中出现奇数次的字符答案。
## 3 **AC 代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int let[26];
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		int n;
		cin>>n;
		memset(let,0,sizeof(let));
		for(int i=1;i<=(n<<1)+1;i++)
		{
			string s;
			cin>>s;
			for(int j=0;j<s.size();j++)
				let[s[j]-'a']++;
		}
		for(int i=0;i<26;i++)
			if(let[i]%2==1)
				cout<<(char)(i+'a')<<endl;
	}
}
```


---

## 作者：Daniel2020 (赞：0)

### 题目大意：

有一个初始长度为 $1$ 字符串 $s_0$ 未知，接下来有 $n$ 次操作，每次可以将一个字符串 $s_1$ 替换为另一个字符串 $s_2$ 。

现在给出乱序的 $s_1$ ， $s_2$ 和最终字符串 $S$ ，求 $s_0$ 。

### 解题思路：

本题侧重于思维难度。

由于初始字符串长度为 $1$ ，本题可以考虑从每个字符单独处理。

我们对每一个字符进行分类讨论：

1.	该字符属于某个 $s_2$ ，但是后来在某个 $s_1$ 修改:

则此字符在 $s_1$ 与 $s_2$ 中各出现一次。

2.	该字符属于某个 $s_2$ ，但是后来没有被修改:

则此字符在 $s_1$ 与 $S$ 中各出现一次。

3.	该字符属于某个 $s_1$ ，修改了某个 $s_2$ 中的字符:

同情况 $1$ ，此字符在 $s_1$ 与 $s_2$ 中各出现一次。

4.	该字符属于某个 $s_1$ ，修改了 $s_0$ 中的字符:

其实此字符在 $s_0$ 和 $s_1$ 中各出现了一次，但是因为 $s_0$ 没有给出，所以此字符无法匹配！

**综上所述，所有字符串中出现奇数次的字符即为 $s_0$ 。**

### AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,cnt[26];
string s;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		memset(cnt,0,sizeof(cnt));
		for(int i = 1;i <= (n<<1)+1;i++)
		{
			cin>>s;
			for(int j = 0;j < s.size();j++)
				cnt[s[j]-'a']++;
		}
		for(int i = 0;i < 26;i++)
			if(cnt[i]&1)
				printf("%c\n",i+'a');
	}
}
 
```


---

## 作者：_Andy_Lin_ (赞：0)

纯思维题，亏我还想了那么久。

一个字母出现，要么出现一个，要么消失一个，都改变奇偶性。我们可以进一步发现，操作奇数次，那么就改变奇偶性，操作偶数次，不改变奇偶性。

而最开始，只有一个字母是奇数次。

题目保证有解，那么策略是正确的。

可能不太好理解，请结合代码食用：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200001
int T,n,num[26];
char s[N];
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);memset(num,0,sizeof(num));
		for(int i=1;i<=2*n+1;++i){
			scanf("%s",s+1);int len=strlen(s+1);
			for(int j=1;j<=len;++j)++num[s[j]-'a'];
		}
		for(int i=0;i<26;++i){
			if(num[i]&1)printf("%c\n",i+'a');
		}
	}
	return 0;
}
```

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF1688C)（资瓷 WdOI 的良心比赛）

翻译已经有了。

这题最~~可恶~~过分的就是八云紫打乱了所有的 $t_i$。![](//图.tk/0)

不过我们发现一个好事情：过程合法！（~~可能不合法的话估计无解了~~

如果过程合法，那么那些过程中的操作（即操作的结果后来又换掉了）所有字符都会出现偶数次（一次换出来，一次换下去）。所以，我们只需要存所有的 $t$ 里 26 个字母分别出现多少次。

那么只有最开始的一个字符和结尾的一个字符串会是奇数次。怎么消掉结尾呢？我们只需要在算次数的时候加上 $s$，那么那些最后的结果也会变成偶数次，所以只剩下最初的 $s$ 出现了奇数次。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int a[35];
int main(){
	int T,n;
	cin>>T;
	while(T--){
		memset(a,0,sizeof(a));//记得清空
		cin>>n;
		for(int i=1;i<=(n<<1)+1;i++){//n*2+1个
			cin>>s;
			for(int j=0;j<s.length();j++) a[s[j]-'a']++;
		}
		for(int i=0;i<26;i++){
			if(a[i]&1) cout<<char(i+'a')<<endl;//只有一个答案
		}
	}
	return 0;
}
```

---


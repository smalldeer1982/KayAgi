# Robot in a Hallway

## 题目描述

有一 $2$ 行 $m$ 列的网格，从上到下编号为 $1$ 至 $2$，从左往右编号为 $1$ 至 $m$。

机器人开始时在网格 $(1,1)$ 内。一秒内，它可以进行如下任意一个动作：

- 走到上、下、左、右任意相邻的网格
- 待在网格内不动

开始时，除了网格 $(1,1)$ 其他格子都是锁着的。每个网格 $(i,j)$ 有一个值 $a_{i,j}$，表示该网格解锁的时间。只有经过至少 $a_{i,j}$ 秒后，机器人才可以进入网格 $(i,j)$。

机器人要走遍所有网格，且每个网格只能被访问一次（网格 $(1,1)$ 在一开始就被访问过）。访问可以在任意网格内结束。

实现如上操作的最快时间是什么？

## 样例 #1

### 输入

```
4
3
0 0 1
4 3 2
5
0 4 8 12 16
2 6 10 14 18
4
0 10 10 10
10 10 10 10
2
0 0
0 0```

### 输出

```
5
19
17
3```

# 题解

## 作者：Elegy_of_Green_Kite (赞：16)

本来以为这道题蛮简单的，结果调了半天（~~好吧是因为我菜~~）

这道题有两个关键点，还需要一点点想象力。

$Update\ 2022/8/8$ 这题不用开`long long`，下文有关内容请忽视。

### Num 1

第一步考虑怎么走。

因为一个格子不能走两遍及以上，而且只有两行，说明走网格的时候是**不能中途往回走**的，所以可以想到只有两种走法：

第一种两行同时走，具体地说，就是先向下、向右、向上、向右，再向下、向......这样扭曲地走；

第二种就是某一行一直向右走，碰到边界调头从另一行一直往左走。

因为**不能中途往回走**，所以一定是先按第一种方法走，再按第二种方法走。

### Num 2

第二个关键点是如何消除 $a_{i,j}$ 的影响。

先不考虑第一种走法，只考虑第二种（因为第一种走法路线是确定的，所用的时间可以一边走一边算）。

某个格子经过 $a_{i,j}$ 时间后才开启，开启后就不会再关上，所以我们可以不用走到格子面前再等格子解锁，而是先等一段时间，再按路线前进，**确保我们走到任何一个格子时都已经解锁**。

这样的好处就是不用走一会儿等一会儿，可以先等然后一直走——换句话说，这样就可以预处理等的时间，然后直接加上路程就是总时间。

这样这道题目就比较明朗了：预处理从第 $a$ 行第 $b$ 列这个格子开始实行第二种走法至少需要等待多少时间，然后枚举按第一种走法走到哪一列，沿途计算答案。

### Num 3

下文 $f_{i,j}$ 代表从第 $i$ 行第 $j$ 列开始使用第二种走法需要等待的最少时间，我把向右走再调头向左走按两个部分拆开计算。

预处理：

```cpp
a[0][1]=-1;//方便计算
f[0][n]=a[0][n],f[1][n]=a[1][n];
for(int i=0;i<=1;i++)
	for(int j=n-1;j>=1;j--)
		f[i][j]=max(f[i][j+1]-1,a[i][j]);
```
到这里为止处理了从第 $i$ 行开始一直向右走需要的等待时间
```cpp
f[0][n]=max(a[1][n]-1,a[0][n]);
f[1][n]=max(a[0][n]-1,a[1][n]);
for(int i=0;i<=1;i++)
	for(int j=n-1;j>=1;j--)
		f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]));
```
到这里为止就是完整的 $f_{i,j}$ 计算过程，其中

`f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]))`

这一步需要读者自己理解一下，我语文比较差，说不清楚。

接下来就是从头按第一种走法边走边计算时间，其中的 $p$ 记录现在在第 $p$ 行。
```cpp
int ans=f[0][1]+2*n,rec=a[1][1]+1;
for(int i=2,p=1;i<=n;i++,p^=1)
{
	rec=max(rec+1,a[p][i]+1);
	rec=max(rec+1,a[p^1][i]+1);
}
```
所以，只需要在上面的过程中顺便计算答案并记录最小答案即可。

### Num4

完整代码如下，没有挖坑，码风丑陋，凑活着看吧。


```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int N=2e5+5;
int T,n,a[2][N],f[2][N];
int G(int x){ return x>0?x:0ll; }
void solve()
{
	scanf("%lld",&n);
	for(int i=0;i<=1;i++)
		for(int j=1;j<=n;j++)  scanf("%lld",&a[i][j]);
	a[0][1]=-1;
	f[0][n]=a[0][n],f[1][n]=a[1][n];
	for(int i=0;i<=1;i++)
		for(int j=n-1;j>=1;j--)
			f[i][j]=max(f[i][j+1]-1,a[i][j]);
	f[0][n]=max(a[1][n]-1,a[0][n]);
	f[1][n]=max(a[0][n]-1,a[1][n]);
	for(int i=0;i<=1;i++)
		for(int j=n-1;j>=1;j--)
			f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]));
	int ans=f[0][1]+2*n,rec=a[1][1]+1;
	for(int i=2,p=1;i<=n;i++,p^=1)
	{
		ans=min(ans,rec+G(f[p][i]-rec)+2*(n-i+1));
		rec=max(rec+1,a[p][i]+1);
		rec=max(rec+1,a[p^1][i]+1);
	}
	ans=min(ans,rec);
	printf("%lld\n",ans);
}
signed main()
{
	scanf("%lld",&T);
	while(T--)  solve();
return 0;
}
```
撒花。

---

## 作者：y_kx_b (赞：10)

题意：
>在 $2\times n$ 的网格中，$(i,j)$ 格子需要时间超过 $a_{i,j}$ 才能踏上。你（机器人）一开始在 $(0,0)$，每一秒钟你可以上下左右在网格中移动（也可以不动），问你把所有格子经过一次且只经过一次所花的最少时间是多少。

（为了方便，横纵下标均从 $0$ 开始。）

考场思路。

首先考虑机器人怎么走才能做到题目要求：把所有地方经过一次且只经过一次。

简要分析后 $%~~（分析过程略）~~$ 可以得出以下结论：

机器人需先盘旋前进若干格，然后一条路往右走到尽头，掉头，把剩下的一条路走完。如下图是 $n=8$ 时机器人可能的 $4$ 种路线：

![](https://cdn.luogu.com.cn/upload/image_hosting/e7cl69yx.png)


$%容易发现，$终点只能在如下所示未染色格子里，且位置 $(i,j)$ 满足 $(i+j)\operatorname{and}1=1$。
（$\operatorname{and}\text{为 位与 运算符}$）

![](https://cdn.luogu.com.cn/upload/image_hosting/lz65tmnu.png)



**那么我们就可以预处理出盘旋前进到某个格子最少花费的时间，和笔直走花费的时间。**

设 $d_{i,j}$ ~~kstra~~ 为盘旋前进到达该点所花时间（仅限染色格子）；

$m_{i,j,k}=\begin{cases}\text{从 (i,0)点 从左往右走到该点所花时间},k=0\\\text{从 (i,n-1)点 从右往左走到该点所花时间},k=1\end{cases}$
```cpp
n=read();
for(int i=0;i<2;i++)for(itn j=0;j<n;j++)a[i][j]=read();
for(int i=0;i<2;i++)for(itn j=0;j<=n;j++)
	d[i][j]=M[i][j][0]=M[i][j][1]=0;//清零，但实际上大部分并没有什么用
for(int j=1;j<n;j++)// **d=0.
	d[j&1][j]=max(max(
	a[j&1][j]+1,a[j&1][j-1]+2),d[!(j&1)][j-1]+2);
***M=0;
for(int i=0;i<2;i++)for(int j=0;j<n;j++)//适当越点界应该没事吧（
	if(i||j)M[i][j][0]=max(M[i][j-1][0]+1,a[i][j]+1);
//if(i||j)：避免计算M[0][0][0],因为一旦计算其值就会变成1。
for(int i=0;i<2;i++)for(int j=n-1;~j;j--)
	M[i][j][1]=max(M[i][j+1][/*0*/1]+1,a[i][j]+1);
```
关于上面越界部分无影响的证明：**（越界肯定有风险，正规比赛请勿轻易尝试！）**

越界只会在 $i=1,j=0$ 时发生，此时访问 `M[i][j-1][0]` 应该越到了 `M[0][N-1][0]`（~~《应该》~~），这里是肯定没用到的，所以值为初始值（$0$）；又 $a_{i,j}+1\geqslant1$ 所以 `M[i][j][0]=max(M[i][j-1][0]+1,a[i][j]+1);` 中 `M[i][j-1][0]+1`（其值为 $1$）肯定没贡献。

然后枚举终点统计答案即可。
```cpp
int ans=0x3f3f3f3f;
for(int j=0;j<n;j++){//枚举终点：(!(j&1),j)
	int _1_=d[j&1][j],//先盘旋前进若干格
		_2_=max(_1_+(n-1-j),M[j&1][n-1][0]),//然后一条路往右走到尽头
		_3_=max(_2_+(n-1-j+1),M[!(j&1)][j][1]);//掉头，把剩下的一条路走完
	ans=min(ans,_3_);
}
return printf("%d\n",ans);
```
证明：因为盘旋前进到一个点然后直着往右走的时间肯定不小于直接走过去的时间，因为盘旋前进走的格数会更多。

所以在上面 `_2_` 直接取 $\max$ 的决策是正确的：盘旋前进到一个点然后直着往右走到头的时间就是等于 `M[j&1][n-1][0]`，或者前面耗的时间多，等于 `_1_+(n-1-j)`。

`_3_` 同理。

总时间复杂度为 $\mathcal O(n)$，足以通过此题。

最后，警钟长鸣！复制代码后看一下是不是所有地方都改过来了！
```cpp
for(int i=0;i<2;i++)for(int j=0;j<n;j++)
	if(i||j)M[i][j][0]=max(M[i][j-1][0]+1,a[i][j]+1);
for(int i=0;i<2;i++)for(int j=n-1;~j;j--)
	M[i][j][1]=max(M[i][j+1][   0   ]+1,a[i][j]+1);
```
这个地方调了半小时qwq

---

## 作者：Ryder00 (赞：4)

第二篇题解的解释不是很清楚，我来帮他补充一下吧。

## 题意 ##

给定一个 $2$ 行 $n$ 列的网格。机器人初始坐标为 $(0,1)$，每一秒都可以向四周移动。每个格子有解锁时间，在该时间之前机器人不可以进入该格子。每个网格只可以遍历一遍，求机器人遍历整个网格图的最少时间。$n\le2 \times 10^5$。 

## 思路 ##

显然，由于每个网格只能遍历一遍，机器人只有两种走法：  

1.从当前格子一直向右行走，到达第 $n$ 列拐弯，再一直向左移动；
2.蛇形走法。  

一开始的思路，状态设计成了 $f_{i,j,k}$ 表示当前要向 $k$ 方向走到 $(i,j)$ 的最小时间。发现当方向为向左时，状态要从 $f_{i,j+1,k}$ 转移而来，有后效性。  

再次思考性质，发现我们并没有必要走到一个格子后再停下来，等待它的解锁时间。我们可以直接计算好这一条路径所需要等待的总时间，结果便是等待的时间加上格子数了。  

该怎么实现呢？观察到蛇形走法的结果可以边走边由直线走法的结果推算出来，于是考虑对直线走法的结果进行预处理。设 $f_{i,j}$ 表示从 $(i,j)$ 开始，要向右边移动的最小等待时间。  

如何转移？在不考虑不同行之间的情况时，显然可以得到：

$f_{i,j}=\max(f_{i,j+1}-1,a_{i,j})$。

加上不同行的情况，即蛇形走法后怎么办呢？考虑到如果从 $(i,j)$ 开始向右移动，终点一定是 $(i\oplus1,j)$。显然答案要从终点转移过来。故转移方程变为：

$f_{i,j}=\max(f_{i,j+1}-1,\max(a_{i\oplus1,j}-2\times(n-j)-1,a_{i,j}))$。

转移方程是怎么来的呢？有的小朋友就有疑问了。$(i,j)$ 走到 $(i\oplus1,j)$ 的路径，不是等同于由 $(i,j)$ 走到 $(i,n)$，再拐个弯走到 $(i\oplus1,j)$ 吗？那这样的路径显然可以用 $(i,j+1)$ 的状态来转移啊，为什么非要从终点转移过来呢？因为你忘记考虑时间锁的限制了。$(i,j+1)$ 的时间锁和 $(i\oplus1,j)$ 的时间锁不一定相同，所以如果两种情况用同一种状态转移的话，答案是错误的。故需要用 $(i\oplus1,j)$ 的时间锁限制减去机器人移动 $(n-j)$ 列所需的时间，再减去拐弯所需的 $1$ 个时间作为转移状态。

最后，枚举一下蛇形走法的路径，统计一下最小值就可以了。

## Code ##
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
int T=1,n,a[2][200010],f[2][200010],ans,now;
void solve(){
	cin>>n;
	for(int i=0;i<=1;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	a[0][1]=-1;
	f[0][n]=max(a[1][n]-1,a[0][n]);
	f[1][n]=max(a[0][n]-1,a[1][n]);
	for(int i=0;i<=1;i++){
		for(int j=n-1;j>=1;j--){
			f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]));
		}
	}
	ans=f[0][1]+2*n,now=a[1][1]+1;
	for(int i=2,p=1;i<=n;i++,p^=1){
		ans=min(ans,now+((f[p][i]-now)>0?f[p][i]-now:0)+2*(n-i+1));
		now=max(now+1,a[p][i]+1);
		now=max(now+1,a[p^1][i]+1);
	}
	cout<<min(ans,now)<<endl;
	for(int i=1;i<=n;i++) f[0][i]=f[1][i]=0;
	return ;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>T;
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：Qcfff (赞：3)

### [CF1716C Robot in a Hallway](https://www.luogu.com.cn/problem/CF1716C)

vp 场内没理解题意被卡住，遂写题解。

不难发现，想要不重不漏地走完 $2\times n$ 的矩阵，只能在 $1\sim k$ 中 下右上右 蛇形走，然后直线 $k+1\sim n$ 到头，再 $n\sim k+1$ 回来。

我们先顺着从 $1\sim n$ 蛇形走，然后在每个拐弯点判断 当前的路线接上直线再拐回的路线的总耗时，并累加答案，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9e4ga2em.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/bntt4oh5.png)

如果每次都暴力模拟直线的走法复杂度达到 $O(n^2)$，注意到每次使用的直线走法都有重叠部分，考虑如何优化。

思考一条路径的耗时与 $a$ 数组的关系，记 $s$ 数组为按照路径顺序排列好的 $a$ 数组的值，$t$ 为当前时间，每次都从 $i$ 向 $i+1$ 走，发现对于每个 $s(1\sim n)$，$t$ 都进行 $t\gets\max(t,s(i))+1$，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/njf5l1mg.png)

棕色为 $t$ 的增长，记 $t$ 从初值为 $0$ 开始经过运算的第 $i$ 项时的 $t$ 为 $f(i)$。

对于当前第 $p$ 项代表蛇形走的路径上已经走了 $1\sim p$，记目前的耗值为 $t$，接下来直线走回来的路径（分为第一行出发和第二行出发）在直线走的总路径中为 $l\sim r$ 的部分，考虑在上述 $t$ 的变化过程中如果直接从第 $l$ 项开始、初值为 $t$ 的变化，可以发现 $t$ 的变化只跟是否小于 $f(r)$ 相关：

![](https://cdn.luogu.com.cn/upload/image_hosting/ghtnyxkd.png)

橙色的为初值变化情况下的 $t$ 值，发现如果令 $t$ 在 $l\sim r$ 不断 $t\gets t+1$ 最后得到的 $t+r-l+1$ 会小与原本的 $f(r)$ 的话，说明 $t$ 在途中小于某个 $s(i)$ 的值然后变成了 $s(i)+1$，接下来的变化就与 $f$ 数组一样了，最后停留在第 $r$ 项的 $t$ 值就是 $f(r)$ 的值，否则就是 $t+r-l+1$。

综上，对于第 $l$ 项初值为 $t$ 对于第 $r$ 项的结果就是 $\max(t+r-l+1,f(r))$，最后得出答案即可，当然还有一些细节需要处理，上述做法容易做到复杂度 $O(n)$。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,K=2e1;
int t,n,a[2][N],s[3][N*2],f[3][N*2];
int calc(int j,int l,int r,int t){
	return max(t+r-l+1,f[j][r]);//意义如题解所述 
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=0;i<=1;i++){
			for(int j=1;j<=n;j++){
				cin>>a[i][j];
			}
		}
		a[0][1]=-1;//因为左上角要计算得到0所以赋值为-1 
		int tot=0;
		for(int i=1;i<=n;i+=2){
			int k=((i+2)*2/4-1)*4;
			s[0][k+1]=a[0][i];
			s[0][k+2]=a[1][i];
			if(i<n){
				s[0][k+3]=a[1][i+1];
				s[0][k+4]=a[0][i+1];
			}
		}
		for(int i=1;i<=n;i++){
			s[1][i]=a[0][i];
			s[2][i]=a[1][i];
		}
		for(int i=n;i>=1;i--){
			s[1][2*n+1-i]=a[1][i];
			s[2][2*n+1-i]=a[0][i];
		}
		//分别计算蛇形、从第一行出发和从第二行出发两种直线走法的s数组，用0、1、2分别对应上述 
		for(int j=0;j<=2;j++){
			f[j][0]=-1;
			for(int i=1;i<=2*n;i++){
				f[j][i]=max(f[j][i-1],s[j][i])+1;//计算f数组 
			}
		}
		int lu=1,ru=2*n,ld=1,rd=2*n,t=-1,ans=min(f[0][2*n],min(f[1][2*n],f[2][2*n]));//lu、ru、ld、rd分别表示第一行和第二行的l和r 
		for(int i=1;i+2<=2*n;i++){
			lu++,rd--;
			t=max(s[0][i],t)+1;
			ans=min(ans,calc(1,lu,ru,t));//拐点计算答案 
			ru--,ld++,i++;
			t=max(s[0][i],t)+1;
			ans=min(ans,calc(2,ld,rd,t));//同上 
			ru--,ld++,i++;
			t=max(s[0][i],t)+1;
			lu++,rd--,i++;
			t=max(s[0][i],t)+1;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：bluewindde (赞：0)

容易发现合法路径一定形如：先弯弯曲曲地走（即向下、向右、向上、向右地移动），再直接向右走到头，碰到边界后折回来。

所以考虑枚举弯曲地走的部分，这部分的最快时间容易求出。只需考虑快速求出剩余部分的最快时间，设对于第 $i$ 第 $j$ 列，这个时间为 $f_{i, j}$。

发现移动和等待格子解锁实质上可以描述为在平面上移动：若平面的 $x$ 轴为路程，$y$ 轴为时间，移动一步相当于 $x \leftarrow x + 1, y \leftarrow y + 1$；等待一秒相当于 $y \leftarrow y + 1$。这样得到的折线会分为很多段，为了方便处理，将一部分折线向上平移使得其构成一条直线，显然这样不会影响答案。（它的实际意义是在一开始就完成所有等待）这条直线的截距即为需要等待的时间。

求截距是一个常见套路：设走过的格子的解锁时间依次组成序列 $t_1, t_2, t_3, \cdots t_m$，则上述直线的截距为 $\max\limits_{i = 1}^m \{ t_i - i \}$。

于是容易求出剩余部分的最快时间 $f_{i, j}$，时间复杂度 $O(n)$。

```cpp
#include <iostream>

#define int long long

using namespace std;

int n;
int a[2][200005];
int f[2][200005];

static inline int max(int x, int y, int z) { return max(max(x, y), z); }

static inline void solve() {
    cin >> n;
    for (int i = 1; i <= n; ++i)
        cin >> a[0][i];
    for (int i = 1; i <= n; ++i)
        cin >> a[1][i];
    a[0][1] = -1;
    f[0][n] = max(a[1][n] - 1, a[0][n]);
    for (int i = n - 1; i; --i)
        f[0][i] = max(f[0][i + 1] - 1,
                      a[1][i] - 2 * (n - i) - 1,
                      a[0][i]);
    f[1][n] = max(a[0][n] - 1, a[1][n]);
    for (int i = n - 1; i; --i)
        f[1][i] = max(f[1][i + 1] - 1,
                      a[0][i] - 2 * (n - i) - 1,
                      a[1][i]);
    int ans = min(f[0][1] + 2 * n, a[1][1] + max(0ll, f[1][2] - a[1][1] - 1) + 2 * n - 1);
    int sum = a[1][1] + 1;
    for (int i = 2; i <= n; ++i) {
        sum = max(sum, a[(i & 1) ^ 1][i]) + 1;
        sum = max(sum, a[i & 1][i]) + 1;
        ans = min(ans, sum + max(0ll, f[i & 1][i + 1] - sum) + 2 * (n - i));
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--)
        solve();
    return 0;
}
```

---


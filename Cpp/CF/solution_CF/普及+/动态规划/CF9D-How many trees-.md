# How many trees?

## 题目描述

在某个非常古老的文本文件中记载着伟大的智慧。这份智慧如此深奥，以至于无人能够破译，就连 Mainframe 中最年长的居民 Phong 也无法解读。但他仍然设法从中获取了一些信息。例如，他得知用户启动游戏是为了消遣——随后可怕的「游戏立方体」便会降临城市，给那些无法赢得游戏的模块带来毁灭。

当然，自从守护者 Bob 出现在 Mainframe 之后，许多模块便不再惧怕游戏立方体。因为 Bob（至今仍存活）从未被用户击败过，而且他总是会插手游戏立方体，这是由他的程序决定的。

然而，当游戏立方体坠落在失落之角时仍可能发生不愉快的情况。因为那里居住着一个讨厌的病毒——Hexadecimal，她非常古怪且热衷于游戏。因此，Bob 不得不先与她玩一场游戏，然后才能面对用户。

这次 Hexadecimal 设计了如下游戏：Bob 必须跳过若干个含有 $n$ 个节点的二叉搜索树。需要提醒的是，二叉搜索树满足以下条件：每个节点具有不同的键，对任一节点而言，其左子树的所有节点键值均小于该节点键值，右子树的所有节点键值均大于该节点键值。所有键均为 $1$ 到 $n$ 的不同正整数。每个节点最多可有 $2$ 个子节点，或没有子节点（此时该节点为叶节点）。

在 Hexadecimal 的游戏中，所有树各不相同，但每棵树的高度均不低于 $h$。本题中「高度」定义为：从根节点到最远叶子节点路径上的最大节点数（包含根节点和叶子节点本身）。当 Bob 跳过一棵树时，该树将消失。只有当所有树都被跳过时，Bob 才能获得立方体的访问权限。请你求出最坏情况下 Bob 需跳过的树的数量。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
5```

## 样例 #2

### 输入

```
3 3
```

### 输出

```
4```

# 题解

## 作者：Loner_Knowledge (赞：29)

这是一道动态规划题

---

题意是问n个点组成的二叉树高度大于h的有多少个。

我们可以设`f[n][h]`表示n个节点建立的深度不大于h的二叉树总数，`i`为左子树的节点数，`n-i-1`为右子树的节点数，由于左子树的总数乘以右子树的总数即为该二叉树的总数，由此可以得出状态转移方程

$$f_{n,h}=\sum\limits_{i=1}^{n}{f_{i,h-1}\times f_{n-i-1,h-1}}$$

初始状态是$f_{i,0}=0\ (1\le i\le n)$，$f_{0,i}=1\ (0\le i\le n)$。

那么根据题意，答案即为`f[n][n]-f[n][h-1]`。

注意**数据范围**，答案要用$long\ long$，$long\ long$在`CodeForces`要用`"%I64d"`输出。（当然如果你用`cout`另说）

```cpp
#include<cstdio>
long long f[37][37];
int main() {
	int n,h;
	scanf("%d%d",&n,&h);
	for(int i=0;i<=n;++i)	//初始化
		f[0][i]=1;
	for(int i=1;i<=n;++i)		//枚举高度
		for(int j=1;j<=n;++j)		//枚举节点
			for(int k=0;k<j;++k)		//枚举左右子树节点
				f[j][i]+=f[k][i-1]*f[j-k-1][i-1];
	printf("%I64d",f[n][n]-f[n][h-1]);
	return 0;
}
```

---


---

## 作者：Dry_ice (赞：14)

[题链](https://www.luogu.com.cn/problem/CF9D)

> 这是一道代码不长，但有一定“思维”的题目。

## 问题转化
首先审题，发现求的是高度**不小于** $h$ 的二叉树的个数。很容易就想到方法是树形$\text{DP}$计数，但是递推方向是从树根到叶子结点，所以不容易求高度**不小于** $h$ 的二叉树的个数，所以我们要把问题转化为求高度**不大于** $h-1$ 的二叉树的个数，然后再拿二叉树总数一减就得到了答案。

## $\text{DP}$过程
我们设 $F_{i,j}$ 表示由 $j$ 个结点组成的高度**不大于** $i$ 的二叉树的个数。

枚举左子树结点个数 $k$，由于总共有 $j$ 个结点，可以算出右子树结点个数为 $j-k-1$，**注意要减一**，因为左子树与右子树的根结点的父亲（当前二叉树的根结点）要减掉。因为是计数问题，所以要把所有可能的 $k$ 算出的结果加起来。然后就可以写出递推柿子：
$$F_{i,j}=\sum_{k=0}^{j-1}F_{i-1,k}\cdot F_{i-1,j-k-1}$$

初始化由 $0$ 个结点组成的高度为 $i$ 的二叉树个数为 $1$，那便是空树。

最后必须注意$\text{DP}$数组要开 ```long long```，否则就 /dk 了。

## CODE
```cpp
#include <stdio.h>
int n, h; long long f[40][40];
int main(void) {
    scanf("%d %d", &n, &h);
    for (int i = 0; i <= n; ++i) f[i][0] = 1ll; //初始化
    for (int i = 1; i <= n; ++i) //枚举高度
        for (int j = 1; j <= n; ++j)
            for (int k = 0; k < j; ++k)
                f[i][j] += f[i - 1][k] * f[i - 1][j - k - 1]; //递推
    printf("%lld\n", f[n][n] - f[h - 1][n]);
    return 0;
}
```

## The end. Thanks.
（记得点赞

---

## 作者：ForeverHYX (赞：6)

# 题解007 Cf9D
本蒟蒻的第一篇蓝题题解，求管理员大大通过，因为打算从一些有关的东西讲起，篇幅可能有点长。

## 01 前置芝士 Catalan数

[可以做这道题检验自己会不会写。](https://www.luogu.com.cn/problem/P1044)

此处我们不使用卡特兰数的基本定义，而是考虑这样一个经典的问题：

已知一棵有 $n$ 个结点的树，求有几种不同形态的树？

我们对其中的某一个节点进行分析，设这个节点的标号是 $k$ ，我们不难发现这个点的左子树标号范围是 $[1,k-1]$ ，而右子树标号范围是 $[n-k-1,n]$ ，那计算公式就呼之欲出了。

我们只要枚举 $k$ 就可以得到答案。递推公式如下:

$h_n=\sum\limits_{k=0}^{n-1}h_k*h_{n-k-1}$

(其中 $h_n$ 代表有 $n$ 个结点二叉树的方案数）

## 02 本题思路

### 这只是一般的卡特兰数吗

显然不是，因为我们除了参数 $n$ 以外还引入了一个参数 $h$ 来表示树的深度。
### 如何定义状态
我们定义 $dp[i][j]$ 来表示一个结点数量为 $i$ ，深度为 $j$ 的树的方案数。
### 如何确定转移
我们思考 $dp[i][j]$ 从哪里来，很显然，一定是从 $j-1$ 深度推出来的，而如何确认数量，则是 01 中所提到的卡特兰数递推所类似的了。

但是总之我们可以得到这样一个状态转移方程：

$dp[i][j]+=dp[k][j-1]*dp[j-k-1][j-1]$

而类似于卡特兰数的递推我们只需要从 $[0,n)$ 中枚举 $k$ 即可。

然后求出答案我们需要排除掉所有 $h_0<h$的方案数。

## 03 本体算法

### DP+递推

在 02 中我们已经阐明了思路，接下来就是代码实现了。我们首先分析数据范围，发现 $0<n<=35$ ，因此 $O(n^3)$ 算法复杂度是完全可以接受的。

之所以这么说是因为我们的算法需要枚举 $h,n,k$ 这三个参数，很显然这种算法的复杂度就是 $O(n^3)$。

而确定了算法的可行性，下面就让我们给出代码吧。

## 04 AC代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ull unsigned long long
using namespace std;
int n,h;
ull dp[40][40],ans;//范围问题会在易错点中说明
void catalan(){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            for(int k=0;k<=j-1;k++)
                dp[j][i]+=dp[k][i-1]*dp[j-k-1][i-1];//二维卡特兰数，增加了第二个标识量标识高度
        }
    }
}
void init(){
    scanf("%d%d",&n,&h);
    for(int i=0;i<=n;i++) dp[0][i]=1;
}
int main(){
    init();
    catalan();
    ans=dp[n][n]-dp[n][h-1];//我们排除小于目标高度的形态，然后就得到了答案。
    printf("%lld",ans);
}
```
不要抄代码，完全可以看一遍后自己写哟。

## 05 易错点

### 05.1 数据范围问题

这里给出卡特兰数的通项公式：

$Catalan_n=C^n_{2n}/{n+1}$

我们估算当 $n=35$ 的最大情况发现远远超过了 $int$ 的数据范围，所以我们应当使用 $long $ $long$ 或者是 $unsigned$ $long$ $long$。

 _本蒟蒻的第七篇题解，望管理员大大通过，同时祝看到的各位国庆，中秋快乐！！！_ 

---

## 作者：lzqy_ (赞：4)

提供一种时间复杂度较劣，但是比较好想的 dp 解法。

## 思路

看到计数题，首先想到 dp。

一棵二叉树若继续在深度更深的地方添加节点，只和三个量有关：已经用了的节点数、当前层的节点数、当前的深度。

于是就能很自然地列出转移数组：

$f_{i,j,u}:$ $i$ 个节点，深度为 $j$，且第 $j$ 层有 $u$ 个节点的二叉树个数。

注意，在第 $j$ 层的 $u$ 个节点的排列不是唯一的。设上一层有 $k$ 个节点，则方案数还要乘上 $u$ 个节点的排列方式即 $\binom {2k} {u}$（上一层有 $k$ 个节点，那么一共就有 $2k$ 个儿子，在其中选取 $u$ 个放置节点）。

具体来说，转移方程如下：

$$f_{i,j,u}=\sum\limits_{k=1}^{j-u}f_{i-1,j-u,k}\times\binom {2k} {u}$$

其中，$k$ 是枚举上一层的节点数。


## 代码

注意，组合数要提前预处理出来，否则会超时。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=36;
ll f[maxn][maxn][maxn];
ll C[maxn][maxn]; 
int n,H;
void init(){
	for(register int i=0;i<=n;i++)
		C[i][0]=C[i][i]=1;
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<i;j++)
				C[i][j]=C[i-1][j]+C[i-1][j-1];
}
int main(){
	scanf("%d%d",&n,&H);
	f[1][1][1]=1,init();
	for(register int i=2;i<=n;i++)
		for(register int j=1;j<=n;j++)
			for(register int u=1;u<=j;u++)
				for(register int k=1;k<=j-u;k++)
					f[i][j][u]+=f[i-1][j-u][k]*C[k*2][u];
	register ll sum=0;
	for(register int i=H;i<=n;i++)
		for(register int j=1;j<=n;j++)
				sum+=f[i][n][j];
	printf("%lld\n",sum);
	return 0;
}
```

一开始忘记调用 init 函数，调了好久。

还有就是注意要开long long。

---

## 作者：little_cindy (赞：4)

此题考察算法： $\colorbox{#E74C3C}{\color{white}动态规划,dp}$。

前面的巨佬比不过，我来写另一种方法。

## 思路

### 状态定义
$dp_{i,j}$ 表示节点数为 $i$，且二叉树高度恰好为 $j$ 的方案总数（此处不妨设 $i$ 为根节点）。

### 初始值
$\begin{cases}dp_{0,0}=1\\dp_{0,i}=0\\dp_{i,0}=0\end{cases}$

### 状态转移方程

我们以左子树为研究对象，可以发现两种情况：
1. 左子树的高度恰好为 $j-1$，设左子树有 $x(\max\begin{cases}0\\j-1\end{cases}\le x\le i-1)$ 个节点。则这个部分的答案是 $dp_{x,j-1}\times\sum\limits_{t=0}^{j-1}dp_{i-x-1,t}$。
2. 左子树的高度小于 $j-1$，那么右子树的高度恰好为 $j-1$，设左子树有 $x(\max\begin{cases}0\\j-1\end{cases}\le x\le i-1)$ 个节点。则这个部分的答案是 $dp_{i-x-1,j-1}\times\sum\limits_{t=0}^{j-2}dp_{x,t}$。

所以，可以求出 $dp_{i,j}=dp_{i,j}+dp_{x,j-1}\times\sum\limits_{t=0}^{j-1}dp_{i-x-1,t}+dp_{i-x-1,j-1}\times\sum\limits_{t=0}^{j-2}dp_{x,t}$。

这样，我们就可以很轻易的写出代码了。

完结撒花！

---

## 作者：xiaohuang (赞：4)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/07/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8FCodeforces9D%20How%20many%20trees)

### Description in Chinese

用$n$个点组成二叉树，问高度大于等于$h$的有多少个。

### Solution

这题$n$的范围很小，只有$35$，所以我们用$O(n^4)$的动态规划来解决。

`dp[i][j]`表示用$i$个点，构成高度为$j$的二叉树的个数。

动态转移方程为$dp[i][max(j, k) + 1] += dp[L][j] \times dp[R][k]$，其中$i$表示所用的结点数，$j$是枚举左子树的结点数，$L$表示左子树的结点总数，$k$是枚举左子树的结点数，$R$表示右子树的结点总数。

答案就是$\sum^{n}_{i = h}{dp[n][i]}$。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

typedef long long LL;
const int MAXN = 40;
int n, h;
LL dp[MAXN][MAXN];
int main() {
    scanf("%d%d", &n, &h);
    dp[0][0] = 1;//用0个结点，可以构造出1棵深度为0的二叉树
    for (int i = 1; i <= n; i++)//枚举总结点数
        for (int L = 0; L < i; L++) {//枚举左子树的结点数
            int R = i - L - 1;//计算剩下的结点数，再减去根结点，就是右子树的结点数
            for (int j = 0; j <= L; j++)//左子树
                for (int k = 0; k <= R; k++)//右子树
                    dp[i][max(j, k) + 1] += dp[L][j] * dp[R][k];//因为是累计可行方案所以是乘法
        }
    LL ans = 0;
    for (int i = h; i <= n; i++)
        ans += dp[n][i];//累计答案
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：linaonao (赞：3)

~~已知等式：蓝题=水题~~

正经点：

已知这道题是$dp$题，需要涵盖$dp$的几个要素:**范围，限制，贡献**。在这道题中对应取**有几个点，有几层，有多少情况**。

我们定$f[i][j]$表示已用了$i$个点，已有$j$层时二叉树形态数，公式很好推：

```cpp
f[j][i]+=f[k][i-1]*f[j-k-1][i-1]
```
发现代码与树状DP神似，其实两者思路也比较接近，因为**一个树的节点数等于左子树节点数加上右节点节点数**

最后我们用排异法：**深度大于等于$h$=深度最大（即为$n$）-深度小于$h$**

题目有点$ex$，要开$long long$才能过，也印证了某句名言“不开**见祖宗”

码：


```cpp
#include<bits/stdc++.h>
template<typename T>inline void read(T &x){
	T f=0;x=0;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())f|=ch=='-';
    for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    x=f?-x:x;
}
template<typename T>inline void write(T x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+48);
}
using namespace std;
long long f[40][40];
int main(){
	int n,h; read(n),read(h);
	for(int i=0;i<=n;++i) f[0][i]=1;
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) for(int k=0;k<j;++k) f[j][i]+=f[k][i-1]*f[j-k-1][i-1];
	write(f[n][n]-f[n][h-1]);
	return 0;
}
```


---

## 作者：trsins (赞：2)

数据范围 $n \le 35$，暴力不可做，暴力枚举所有树的话是 $O(2^ n)$

所以应该是 dp。

如何推导？


要求树的高度大于等于 $h$，因为当前的树绝对是由上一个树增加一个新的叶子节点所得到的，所以可以想到**当前方案是由当前高度 -1 的树的方案数推导来的**。

又因为题目还有节点数的要求，所以这个 dp 的另一维应该是**当前使用的节点数**。

令 $tr_{i,j}$ 表示用 $i$ 个节点组成的高度为 $j$ 的二叉树的个数。

二叉树上 dp 中，状态转移有一种特点：**一棵树必会由它的左子树和右子树和它的根节点组成**。

如图，红色的代表根节点，蓝色的则是左子树，绿色的是右子树。



![](https://www.hualigs.cn/image/6067c8cc994aa.jpg)

在这里我们枚举一棵树中最大的左子树和最大的右子树，所以对于每一种树它的组成是确定的。

所以状态转移显然：枚举一棵树的最大左子树与右子树，然后加上根节点。

显然若一棵树的高度为 $h$ ，则它应该由高度为 $h-1$ 的子树组成（根节点占一个深度）。

那么我们就确定了 dp 转移的二维（即高度）。

那么现在讨论一维（节点个数）。

设一个树的节点个数为 $n$ ，则它的子树的节点个数必为 $[1,n-1]$ 这个区间中，因为根节点占了一个节点，且可以没有左子树或右子树（此时为一条链）。

那么状态转移确定。

我们枚举子树的节点个数，然后将左子树的情况总数与右子树的情况总数**相乘**即可（二叉树的性质）。

然后初始化 $tr_{0,i}=1\ (0\le i\le n)$。

状态转移：

$$\large tr_{i,j}=\sum \limits_{l=1}^{i}tr_{l-1,j-1}\times tr_{i-1,j-1}$$

答案即为 $tr_{n,n}-tr_{n,h-1}$。





---

## 作者：傅思维666 (赞：2)

## 题解：

~~2019.10.31模拟赛T2 爆零场~~

暴力不会写++。

来说一下我对正解的一些想法：

对于计数题，有两种思路：第一是使用数学知识解决。第二就是考虑递推和DP。~~我不会告诉你我两个都不会~~。

因为我不是数学家，所以这道题按照DP的思路来想。

和树有关的DP一半都是从子节点开始考虑。但是显然这道题不是一道树形DP题。所以我们在设计状态的时候需要牢牢抓住这道题的本质：二叉树的高度和节点数的关系。

那么尝试着设置状态：

设$dp[i][j]$表示使用$i$个节点能构建的深度大于$j$的二叉树总数。

因为这个东西是二叉树，所以它的状态转移只与左右子树有关。根据乘法原理，最终的答案应该是左子树的答案乘上右子树的答案。

那么我们的转移方程（或者叫做递推式）：
$$
dp[i][j]=\sum_{k=1}^{i}{}(dp[k][j-1]\times dp[i-k-1][j-1])
$$
来解释一下这个转移方程：

$k$变量枚举的是左子树的节点个数。那么右子树的节点个数就是$i-k-1$（总个数-左子树-根节点），那么这就很好理解了。

在代码实现上，我们需要两重循环来分别枚举深度和节点个数。显然，当这棵树退化成一条链的时候深度最大为$n$。那么就可以得出DP部分的代码。

最后统计答案的时候使用一下差分思想：因为我们的状态设置的是高度大于$j$的树的总数，那么答案就是$dp[n][n]-dp[n][h-1]$（最大高度减去合法高度-1）

真的以为这样就结束了么？远远不！

初值...

初值这个地方比较难理解：$dp[0][i]=1$。

啥？0个节点还能构成一棵树？

没办法，就是可以，一棵空树，只有一种可能。

然后就可以开始递推了：代码：

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int n,h;
int dp[40][40];
//dp[i][j]表示i个节点建立的深度不大于h的二叉树总数。
signed main()
{
    scanf("%lld%lld",&n,&h);
    for(int i=0;i<=n;i++)
        dp[0][i]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=0;k<i;k++)
                dp[i][j]+=dp[k][j-1]*dp[i-k-1][j-1];
    printf("%lld",dp[n][n]-dp[n][h-1]);
    return 0;
}
```



---

## 作者：max67 (赞：1)

# CF9D How many trees? 题解
##  [题目传送门](https://www.luogu.com.cn/problem/P1641)  
  ~~万恶的DP题对蒟蒻极不友好~~
  

------------

## 前言
   因为这道题思考得十分不顺畅，看看大佬们的题解，来谢谢来理清思路（题目翻译那么短就没有题意概述了吧）
   

------------

##  分析
  &nbsp;&nbsp;&nbsp;这是道组合数学题，但蒟蒻只会DP，看这么水（？）的数据，只有$ O(n^3) $时间复杂度。暴力就完事了。  
&nbsp;&nbsp;&nbsp;我们首先思考要求的是什么，N个节点的二叉树高度>=h的方案数。可是这样没有思路。那么我们可以尝试用转换为减法来求，也就是某些数相减得到。   
    ![](https://cdn.luogu.com.cn/upload/image_hosting/p40rsadq.png)  
&nbsp;&nbsp;&nbsp;经过一番思考，答案可以表示总种数和$ h- 1$相减得到.（不小于是合法，小于不就是不合法吗)  
&nbsp;&nbsp;&nbsp;那么思考可以用什么方法写出。仔细思考，发现与节点数n和高度H有关系。那么再具体点？
![](https://cdn.luogu.com.cn/upload/image_hosting/lifkmey5.png)

&nbsp;&nbsp;&nbsp;我们可以发现与左子树和右子树得到。那么左子树又可以视作另一个小二叉树。那么这与什么有关。DFS？还是——DP？这题具有最优子结构和无后效性，显然，可以用DP来做。（~~DFS，那是什么，大法师吗~~）
![](https://cdn.luogu.com.cn/upload/image_hosting/0tuniu39.png)  
&nbsp;&nbsp;&nbsp;我们可以假设左节点数为k，总结点数为n，高度为i。可以得出右子树=**n**（总结点数）-**1**（根）-**k**（左节点数）。则再一思考可以得出状态转移方程。$ dp[i][j]= \Sigma_{k=0}^{j-1}(dp[k][j-1])*dp[i-k-1][j-1] $.那么可以得出答案为dp[n][n] (总数，因为可以成一条线，所以高度为n)-&nbsp;&nbsp;&nbsp;dp[n][h-1]（不合法的总数）。  
那么我们再考虑边界。首先我们考虑dp[i][0],这是不可能的，因为有节点至少拥有一个高度；再说dp[0][i],因为图不可以为空，而二叉树在定义中有空树。空树可以定义为任何高度的二叉树。所以dp[i][0]=1.（详见维基百科）


------------

## 注意点
   1.**k要<j,因为是左子树**。  
   2.**注意赋初值**。  
   3.**注意dp过程**
   4.**注意范围**
   

------------

## 代码
``` 
  #include<bits/stdc++.h>
using namespace std;
long long  n,h,dp[111][111];
/* dp[i][j]为i个节点，j个高度的二叉树有多少种 */
int main()
{
//	freopen("trees.in","r",stdin);
//	freopen("trees.out","w",stdout);
	cin>>n>>h;
	for(int i=0;i<=n;i++)
	 dp[0][i]=1;//因为空树也是二叉树 (滑稽)
	 for(int i=1;i<=n;i++)//枚举高度，
	   for(int j=1;j<=n;j++)//枚举节点 
	      for(int k=0;k<j;k++) // 枚举左子树节点
		     dp[j][i]/*不止一种方案数，分类用加法*/+=dp[k][i-1]/*左子树*/ */*分布用乘法*/dp[j-k-1][i-1];//右子树
	cout<<dp[n][n]-dp[n][h-1]<<endl; //答案 
}
```


------------

## 总结
  曾经，Mr.liu说：“正难则反”。而我们谨记着：暴力是唯一的神。所以，当暴力与技巧相结合，配上一点点思路，这道~~水~~题就被A掉了
## 改动
   2025/5/30，更改了数学符号，增加了注意点，更改了总结。
    


---

## 作者：demon_yao (赞：1)

### 题意
用n个点组成二叉树，问高度大于等于h的有多少个。
### 思路
~~显然这是一道DP题~~可是要怎么做呢？

别急，既然是一道DP，那么我们肯定要设计状态，容易想到$f[i][j]$表示用前$i$个结点组成高度为$j$的二叉树。接下来就要考虑如何状态转移了。

显然一棵树是由它的左子树，右子树，以及根节点构成的（~~这不是废话吗~~）但是这就为状态转移提供了思路：$dp[i][j]=\sum{dp[k][j-1]}*\sum{dp[i-k-1][j-1]}$。也就是 $左子树方案数*右子树方案数=当前要求的方案数。$在这之中$k$是我们要枚举的左子树的结点个数。

然后我们就愉快的A了这道题qwq！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[37][37];
int main() {
	int n,h;
	scanf("%d%d",&n,&h);
	for(int i=0;i<=n;++i) f[0][i]=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=0;k<j;++k)
				f[j][i]+=f[k][i-1]*f[j-k-1][i-1];
	cout<<f[n][n]-f[n][h-1];
	return 0;
}

```


---

## 作者：SunsetSamsara (赞：0)

这题是一道动态规划题。虽然题目中提到了树，但其实除了基本概念外和树没什么关系。

### 状态设计

发现直接推很难，怎么办？正难则反，我们定义一个数组 $dp$ ,其中 $dp[i][j]$ 表示 $i$ 个节点，高度小于等于为 $j$ 的树的个数。

### 状态转移

这一步需要费些脑筋。我们需要从 $1\rightarrow n$ 枚举左子树大小 $k$ ,再利用加乘原理转移。因为自己高度要比子树高度多 $1$，所以所以左子树大小为 $k$ 的树的个数是 $dp[k][h-1]\times dp[n-k-1][h-1]$ （由乘法原理）。接下来再把枚举的求和一遍即可。复杂度 $O(n^3)$，稳过。

最后输出的就是小于等于最大深度的减去小于等于h-1的，即 $dp[n][n]-dp[n][h-1]$

注意，注意英文原文说答案不大于 $9\cdot 10^18$,所以得开`long long`

接下来,是代码时间！
```cpp
#include<stdio.h>
long long dp[40][40];
int N,H;
int main(){
	scanf("%d%d",&N,&H);
	int i,j,k; 
	for(i=0;i<=N;++i)dp[0][i]=1;//这一步是必要的初始化 
	for(i=1;i<=N;++i)
		for(j=1;j<=N;++j)//枚举个数	 
			for(k=0;k<j;++k)//枚举左子树大小 
				dp[j][i]+=dp[k][i-1]*dp[j-k-1][i-1];//见前面的状态转移方程 
	printf("%lld\n",dp[N][N]-dp[N][H-1]);//小于等于最大深度的减去小于等于h-1的就是答案 
	return 0;
}

```

---


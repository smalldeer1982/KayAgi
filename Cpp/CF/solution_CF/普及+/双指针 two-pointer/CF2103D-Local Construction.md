# Local Construction

## 题目描述

在数组 $b_1, b_2, \ldots, b_m$ 中，元素 $b_i$（$1 \le i \le m$）是局部最小值当且仅当满足以下至少一个条件：
- $2 \le i \le m - 1$ 且 $b_i < b_{i - 1}$ 且 $b_i < b_{i + 1}$，或
- $i = 1$ 且 $b_1 < b_2$，或
- $i = m$ 且 $b_m < b_{m - 1}$。

类似地，元素 $b_i$（$1 \le i \le m$）是局部最大值当且仅当满足以下至少一个条件：
- $2 \le i \le m - 1$ 且 $b_i > b_{i - 1}$ 且 $b_i > b_{i + 1}$，或
- $i = 1$ 且 $b_1 > b_2$，或
- $i = m$ 且 $b_m > b_{m - 1}$。

注意，对于只有一个元素的数组，局部最小值和局部最大值没有定义。

给定一个隐藏的排列 $^{\text{∗}}$ $p$，其长度为 $n$。对该排列交替执行以下两种操作，从操作 1 开始，直到 $p$ 中只剩一个元素：
- 操作 1 —— 删除 $p$ 中所有不是局部最小值的元素。
- 操作 2 —— 删除 $p$ 中所有不是局部最大值的元素。

具体来说，在每次奇数轮迭代时执行操作 1，在每次偶数轮迭代时执行操作 2，直到 $p$ 中只剩一个元素。

对于每个下标 $i$（$1 \le i \le n$），设 $a_i$ 为元素 $p_i$ 被删除的轮次编号，若未被删除则设为 $-1$。

可以证明，最多经过 $\lceil \log_2 n \rceil$ 轮迭代后 $p$ 中只剩一个元素（即 $a_i \le \lceil \log_2 n \rceil$）。

给定数组 $a_1, a_2, \ldots, a_n$，你的任务是构造任意一个满足数组 $a$ 的排列 $p$。

$^{\text{∗}}$ 长度为 $n$ 的排列是指由 $1$ 到 $n$ 的 $n$ 个不同整数按任意顺序组成的数组。例如，$[2,3,1,5,4]$ 是一个排列，但 $[1,2,2]$ 不是（因为 $2$ 出现了两次），$[1,3,4]$ 也不是（因为 $n=3$ 但出现了 $4$）。

## 说明/提示

在第一个测试用例中，对排列 $[3, 2, 1]$ 执行的操作如下：
1. $[3, 2, 1]$ 的唯一局部最小值是 $1$，因此删除 $3$ 和 $2$。此时只剩一个元素，过程终止。
这满足数组 $a = [1, 1, -1]$，因为 $p_1$ 和 $p_2$ 在第 1 轮被删除，而 $p_3$ 未被删除。

在第二个测试用例中，对排列 $[4, 3, 5, 1, 2]$ 执行的操作如下：
1. $[4, 3, 5, 1, 2]$ 的局部最小值是 $3$ 和 $1$，因此删除 $4$、$5$ 和 $2$。
2. $[3, 1]$ 的唯一局部最大值是 $3$，因此删除 $1$。此时只剩一个元素，过程终止。
这满足数组 $a = [1, -1, 1, 2, 1]$，因为 $p_1$、$p_3$ 和 $p_5$ 在第 1 轮被删除，$p_4$ 在第 2 轮被删除，$p_2$ 未被删除。

在第三个测试用例中，对排列 $[6, 7, 2, 4, 3, 8, 5, 1]$ 执行的操作如下：
1. 局部最小值是 $6$、$2$、$3$ 和 $1$，因此删除 $7$、$4$、$8$ 和 $5$。
2. 局部最大值是 $6$ 和 $3$，因此删除 $2$ 和 $1$。
3. 局部最小值是 $3$，因此删除 $6$。此时只剩一个元素，过程终止。

在第四个测试用例中，一个满足条件的排列是 $[6, 5, 2, 1, 3, 4, 7]$。$1$ 是唯一的局部最小值，因此它会在第一轮后保留。注意，其他排列也可能满足条件，例如 $[6, 4, 3, 1, 2, 5, 7]$ 也是正确的解。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
7
3
1 1 -1
5
1 -1 1 2 1
8
3 1 2 1 -1 1 1 2
7
1 1 1 -1 1 1 1
5
1 1 1 1 -1
5
-1 1 1 1 1
5
-1 1 2 1 2```

### 输出

```
3 2 1
4 3 5 1 2
6 7 2 4 3 8 5 1
6 5 2 1 3 4 7
5 4 3 2 1
1 2 3 4 5
4 5 2 3 1```

# 题解

## 作者：CQ_Bab (赞：4)

# 前言
本蒟蒻在过 C 之后就开始罚坐到结束，最后发现一群 AI。
# 思路
首先我们发现对于一轮其具体值是没有必要的，只需要相对关系即可，然后我们对于每一轮来考虑，所以我们可以让每一轮填入的数都是一段连续的后缀或者前缀（因为能满足之后填的数都大于或小于此轮被删的）。

如果此轮为奇数轮，我们发现对于一个此轮被删除的数 $i$ 其一定要大于其左边的或者右边的，及 $a_i>\min(a_{lst_i},a_{nxt_i})$ 然后我们不妨分类讨论。

- 如果第 $i$ 个数在此轮被删且左右存在此轮被删的数，那么我们按顺序填入一定能使的不在此轮被删的那个与他相邻的数的值比 $a_i$ 小，如果两边都是那么按顺序填也一定会有一个大于 $a_i$ 一个小于 $a_i$。
- 如果这个数左右两边都为之后删除的数，那么一定都满足条件。
- 如果这个数为开头或者结尾，那么其一定要满足 $a_i$ 比和他相邻的那个大，那么我们发现对于第一个数要比其右边的大，而最后一个要比其左边的大，这看似不好处理（毕竟这要使得左边从大往小，右边从小往大），但是我们发现有 $a_i=-1$ 的存在，所以我们以 $-1$ 为分界点，左边从大往小，右边从小往大填即可。

证明一下为什么这样一定合法，首先我们设第一组最后一个为 $a_j$ 第二组第一个为 $a_k$ 那么$a_j$ 右边无论接的是啥都一定能使得其满足条件，而 $a_k$ 无论左边是啥也都一定满足条件（毕竟之前是因为交界点上可能三个个都被删的数相邻而导致中间那个数不合法，但是这里我们保证了不会出现三个数相邻的情况也就解决了问题）。

对于是偶数轮也差不多，都是以 $a_i=-1$ 的位置分界即可解决（就是这里需要从小的那头拿数）。
# 代码
~~说了这么多其实代码很短~~。
```cpp
int get(int x) {
	int res=1;
	while(x) {
		x>>=1;
		res++;
	}return res;
}
void solve() {
	in(n);
	int vv=0;
	rep(i,1,n) in(a[i]),v[i].clear();
	rep(i,1,n) {
		if(a[i]==-1) vv=i;
		else v[a[i]].pb(i);
	}
	int l=1,r=n;
	rep(i,1,get(n)) {
		if(i&1) {
			for(auto to:v[i]) {
				if(to<vv) {
					ans[to]=r;
					r--;
				}else break;
			}
			reverse(v[i].begin(),v[i].end());
			for(auto to:v[i]) {
				if(to>vv) {
					ans[to]=r;
					r--;
				}else break;
			}
		}else {
			for(auto to:v[i]) {
				if(to<vv) {
					ans[to]=l;
					l++;
				}else break;
			}
			reverse(v[i].begin(),v[i].end());
			for(auto to:v[i]) {
				if(to>vv) {
					ans[to]=l;
					l++;
				}else break;
			}
		}
	}
	ans[vv]=l;
	rep(i,1,n) printf("%lld ",ans[i]);
	puts("");
}
```

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18943906)

先考虑**弱化限制**，把局部最大值和局部最小值交替的操作替换为只有局部最大值的时候该如何构造。

观察局部最大值的性质，可以发现：
- 一轮中留下的数的数量最多为原数量的一半，因为如果一个数是局部最大值，那么旁边的两个数就不能是局部最大值了。由此可以得出**所有轮数的个数总和在 $n \log n$ 级别**。
- 列出局部最大值和旁边两个数的大小关系之后，发现仅凭这些关系构造可能会导致一些本该删掉的数也成为局部最大值而保留下来，因此要从“删掉的数”入手而非“保留的数”入手，**优先满足删掉的数的要求**：
- - 对于一般情况，画折线图可知，连续一段删掉的数必须呈一个 V 字形或者单调递增或者单调递减。V 字构造过于麻烦，且可能无法满足要求，而**单调性的构造**是最通用的。考虑保留的数的要求如何满足，因为只要保证他活到下一轮即可，因此**贪心地将他们往大了放**。但是直接放的话可能无法满足他们内部的大小关系，又因为我们只注重他们之间的大小关系，所以只需要给他们**预留一些位置**，到下一轮再去处理具体的关系即可。其他被删掉的数就**从小到大放**就行了。为了方便，我们始终**使用 $1 \sim n$ 的前缀和后缀去填**，这样我们就能方便地维护可选数的区间了。
- - 对于位于左边界 / 右边界的情况，显然就只能是单调递增 / 单调递减了，特判掉即可。

显然局部最小值是对称的，这里不再赘述。

根据所有轮数的个数总和在 $n \log n$ 级别的性质，直接模拟构造，时间复杂度即可做到 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
using pi=pair<int,int>;
const int N=200005;
int n,a[N],v[N];
void solve()
{
	cin>>n;
	vector<int>cur,nxt;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		cur.push_back(i);
		if(a[i]==-1)a[i]=0x3f3f3f3f;
	}
	int l=1,r=n,idx=1;
	while(cur.size()>1)
	{
		nxt.clear();
		int pre=-1;
		for(int i=0;i<cur.size();i++)
		{
			int id=cur[i];
			if(a[id]>idx)
			{
				for(int j=pre+1;j<i;j++)
					v[cur[j]]=((idx&1)?r--:l++);
				nxt.push_back(id);
				pre=i;
			}
		}
		for(int i=cur.size()-1;i>pre;i--)
			v[cur[i]]=((idx&1)?r--:l++);
		idx+=1;
		swap(cur,nxt);
	}
	v[cur[0]]=l;
	for(int i=1;i<=n;i++)cout<<v[i]<<" ";
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--)solve();
	return 0;
}
```

---


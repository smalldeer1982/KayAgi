# Magical Array

## 题目描述

Eric has an array $ b $ of length $ m $ , then he generates $ n $ additional arrays $ c_1, c_2, \dots, c_n $ , each of length $ m $ , from the array $ b $ , by the following way:

Initially, $ c_i = b $ for every $ 1 \le i \le n $ . Eric secretly chooses an integer $ k $ $ (1 \le k \le n) $ and chooses $ c_k $ to be the special array.

There are two operations that Eric can perform on an array $ c_t $ :

- Operation 1: Choose two integers $ i $ and $ j $ ( $ 2 \leq i < j \leq m-1 $ ), subtract $ 1 $ from both $ c_t[i] $ and $ c_t[j] $ , and add $ 1 $ to both $ c_t[i-1] $ and $ c_t[j+1] $ . That operation can only be used on a non-special array, that is when $ t \neq k $ .;
- Operation 2: Choose two integers $ i $ and $ j $ ( $ 2 \leq i < j \leq m-2 $ ), subtract $ 1 $ from both $ c_t[i] $ and $ c_t[j] $ , and add $ 1 $ to both $ c_t[i-1] $ and $ c_t[j+2] $ . That operation can only be used on a special array, that is when $ t = k $ .Note that Eric can't perform an operation if any element of the array will become less than $ 0 $ after that operation.

Now, Eric does the following:

- For every non-special array $ c_i $ ( $ i \neq k $ ), Eric uses only operation 1 on it at least once.
- For the special array $ c_k $ , Eric uses only operation 2 on it at least once.

Lastly, Eric discards the array $ b $ .

For given arrays $ c_1, c_2, \dots, c_n $ , your task is to find out the special array, i.e. the value $ k $ . Also, you need to find the number of times of operation $ 2 $ was used on it.

## 说明/提示

In the first test case, the secret array $ b $ is $ [0, 1, 1, 1, 1, 1, 1, 1, 0] $ . Array $ c_1 $ and array $ c_2 $ are generated by using operation 1. Array $ c_3 $ is generated by using operation 2.

For Array $ c_1 $ ,you can choose $ i=4 $ and $ j=5 $ perform Operation 1 one time to generate it. For Array $ c_2 $ , you can choose $ i=6 $ and $ j=7 $ perform Operation 1 one time to generate it. For Array $ c_3 $ ,you can choose $ i=4 $ and $ j=5 $ perform Operation 2 one time to generate it.

In the second test case, the secret array $ b $ is $ [20, 20, 20, 20, 20, 20, 20] $ . You can also find that array $ c_1 $ and array $ c_2 $ are generated by using Operation 1. Array $ c_3 $ is generated by using Operation 2.

In the third test case, the secret array $ b $ is $ [20, 20, 20, 20, 20, 20, 20, 20, 20] $ . You can also find that array $ c_1 $ and array $ c_2 $ are generated by using Operation 1. Array $ c_3 $ is generated by using Operation 2.

## 样例 #1

### 输入

```
7
3 9
0 1 2 0 0 2 1 1 0
0 1 1 1 2 0 0 2 0
0 1 2 0 0 1 2 1 0
3 7
25 15 20 15 25 20 20
26 14 20 14 26 20 20
25 15 20 15 20 20 25
3 9
25 15 20 15 25 20 20 20 20
26 14 20 14 26 20 20 20 20
25 15 20 15 25 15 20 20 25
3 11
25 15 20 15 25 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20
25 15 20 15 25 20 15 20 20 20 25
3 13
25 15 20 15 25 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 15 20 20 20 20 25
3 15
25 15 20 15 25 20 20 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 20 15 20 20 20 20 20 25
3 9
909459 479492 676924 224197 162866 164495 193268 742456 728277
948845 455424 731850 327890 304150 237351 251763 225845 798316
975446 401170 792914 272263 300770 242037 236619 334316 725899```

### 输出

```
3 1
3 10
3 15
3 20
3 25
3 30
1 1378716```

# 题解

## 作者：_cyle_King (赞：23)

# CF1704D 题解

## 题意

已知有 $n$ 个长度为 $m$ 的数组 $c_{1...n}$，都可以从一个数组 $b$ 变化而来，其中有一个数组的变化方式与其他的数组不一样，要求找出这个数组的编号，并且输出它的操作次数。

## 分析

观察到数据范围达到了 $10^6$ 的级别，因此极其可能是线性做法。

观察两个操作，发现他们两个的区别仅仅是增加时下标一个是 $j+1$，一个是 $j+2$，并没有其他的区别，因此不太好直接根据数组现有的状态分析，也不太可能还原 $b$ 数组（因为可能的 $b$ 实在是太多了，就算还原了，也很难知道从那一个 $b$ 能变成特殊的 $c_k$，毕竟不是所有可能的 $b$ 都能变成 $c_k$）。因此，考虑直接从整体上来求解，忽略变化过程。

### 核心思想

 观察这两个操作的本质，先看操作 $1$，可以将其理解为，**将一个在位置 $i$ 的 $1$ 向左移了一位，在将一个在位置 $j$ 的 $1$ 向右移了一位**，模模糊糊感觉有东西抵消了（左移一个，右移一个），而操作二有东西增加了（左移一个，右移两个），因此，可以联想到物理学中的**功能原理**，这样操作 $1$ 的势能守恒，而操作 $2$ 做功，势能增加。~~（感性理解）~~

类似重力势能，定义一个数组 $a$ 的势能函数 $\varphi(a)=\sum_{i=1}^mia_i$，则每次操作 $1$ 势能守恒，操作 $2$ 每次做功，势能增加 $1$。因此，特殊数组的势能比其余的数组要大，其余数组的势能与 $b$ 相同，找出势能高于其余数组的那一个，就找出了特殊的 $c_k$，因为每次操作 $2$ 都会使得势能增加 $1$，所以操作 $2$ 的次数就是 $\varphi(c_k)-\varphi(b)$，线性扫描就可以通过此题。

### 代码Code

```cpp
//这份代码是赛时代码稍微修改而来的，很多地方常数很大，可以卡常。
//比如说这个题边读入边处理可以不开任何数组。
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<vector>
#define int long long 
#define rep(i,x,y) for(int i=(x),_=(y);i<=_;i++)
#define per(i,x,y) for(int i=(x),_=(y);i>=_;i--)
using namespace std;
typedef long long LL;//一切恐惧和担忧都来源于没有开long long。

const int N=1e5+10;

int T,n,m;
vector<vector<LL> >c;//赛场上避免代码麻烦，这里用了二位 vector，自己做题时不需要。
int a[N+1];

inline LL//势能函数的计算。 
calc(vector<LL> &a){//以位置0为零势能面，计算每个c的势能。
	LL res=0;
	rep(i,1,m) res+=a[i]*i;//这里的势能定义与重力势能相似。 
	return res;
}

signed
main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){//把操作看成做功，就会发现这题极其简单。
	//操作1总势能不变，不做功。
	//操作2总势能+1，做功为1。 
		cin>>n>>m;
		c.clear();
		c.emplace_back();
		rep(i,1,n){
			c.emplace_back();
			c[i].emplace_back(0);
			rep(j,1,m){
				int now;cin>>now;
				c[i].emplace_back(now);
			}
		}
		a[1]=calc(c[1]);
		rep(i,2,n){
			a[i]=calc(c[i]);
			if(a[i]!=a[1]){//势能增加，通过2做了功。 
				cout<<(a[1]>a[i]?1:i)<<' '<<abs(a[i]-a[1])<<'\n';//每操作一次，做功为1 
				break;
			}
		}
	}
	return 0;
}
```



~~不得不说，这题是真的鬼畜，亏我赛场上想出来了。~~

# End













---

## 作者：Presentation_Emitter (赞：6)

考虑找到操作后关于其中一类数列的一个不变量。

发现 $H_i=\sum\limits_{j=1}^m jC_{i,j}$ 在非特殊数列进行操作后值不变，而特殊数列一次操作会让这个值 `+1`。

于是第一问直接找最大的下标，第二问用最大的 $H$ 减去最小的即可。

做完本题可以用找不变量的思想做做 ARC102F。

代码简单，就不贴了。

---

## 作者：happy_dengziyue (赞：5)

### 1 视频题解

![](bilibili:BV1BU4y1Y7Tc)

### 2 思路

设 $c_i$ 的**前缀和之和**为 $s_i$。

可以发现：

$$c_i=\sum_{i=1}^n(\sum_{j=1}^ia_j)=\sum_{i=1}^n[a_i\times(n-i+1)]$$

进行一次普通的操作不会对 $s_i$ 产生任何变化。

设选择 $i,j$ 进行一次普通操作，则：

$$s_i\gets s_i+(n-i+2)-(n-i+1)-(n-j+1)+(n-j)$$

化简得：

$$s_i\gets s_i$$

但是进行一次特殊的操作会影响 $s_i$。

设选择 $i,j$ 进行一次特殊的操作，则：

$$s_i\gets s_i+(n-i+2)-(n-i+1)-(n-j+1)+(n-j-1)$$

化简得：

$$s_i\gets s_i-1$$

所以我们找出 $s_i$ 与众不同那个，输出差值即可。

### 3 代码与记录

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
#define max_n 100000
int t;
int n;
int m;
vector<long long>a[max_n+2];
long long sum[max_n+2];
long long pos;
int main(){
	#ifndef ONLINE_JUDGE
	freopen("CF1704D_2.in","r",stdin);
	freopen("CF1704D_2.out","w",stdout);
	#endif
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;++i){
			a[i].clear();
			sum[i]=0;
		}
		for(int i=1;i<=n;++i){
			a[i].push_back(0);
			for(int j=1;j<=m;++j){
				long long x;
				scanf("%lld",&x);
				a[i].push_back(x);
				a[i][j]+=a[i][j-1];
				sum[i]+=a[i][j];
			}
		}
		pos=0;
		for(int i=2;i<=n;++i){
			if(sum[1]^sum[i]){
				if(!pos)pos=i;
				else{
					pos=1;
					break;
				}
			}
		}
		printf("%lld ",pos);
		if(pos==1)printf("%lld\n",abs(sum[2]-sum[1]));
		else printf("%lld\n",abs(sum[1]-sum[pos]));
	}
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/82185806)

By **dengziyue**

---

## 作者：litachloveyou (赞：5)

首先仔细观察对两种不同序列的操作，发现长得和差分序列有一些类似，于是试着往上面进行思考。

对于非特殊序列 $c_t$，我们先看对第 $i$ 位的操作，将 $c_t[i]$ 减一，$c_t[i-1]$ 加一，如果将 $c_t$ 看成是 $b_t$ 的差分序列，这个操作相当于将 $b_t[i-1]$ 加一，再来看对第 $j$ 位的操作，将 $c_t[j]$ 减一，$c_t[j+1]$ 加一，这个操作相当于将 $b_t[j]$ 减一。也就是说，非特殊序列在执行操作后，如果看成差分序列，那么它所对应的原序列的总和没有发生改变。

对于特殊序列 $c_k$，它与非特殊序列对第 $i$ 位的操作相同，而对于第 $j$ 位，同样将 $c_k$ 看成是 $b_k$ 的差分，将 $c_k[j]$ 减一，$c_k[j+2]$ 加一，这个操作相当于将 $b_k[j]$，$b_k[j+1]$ 减一。也就是说，特殊序列在执行操作后，如果看成差分序列，那么它对应的原序列的总和每执行一次总和就会减少 $1$。

那么特殊序列的操作次数，也就是非特殊序列的对应序列的总和减去特殊序列对应序列的总和了。

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e5 + 10;
ll a[N];
void solve()
{
	int n, m;
	scanf("%d%d", &n, &m);
	int id = 0;
	ll ans = 1e18, res = 1e18;
	for (int i = 1; i <= n; i++)
	{
		ll cnt = 0;
		for (int j = 1; j <= m; j++)
		{
			ll x;
			scanf("%lld", &x);
			a[j] = a[j - 1] + x;
			cnt += a[j];
		}
		if (cnt < res)
		{
			ans = res, res = cnt, id = i;
		}
		else if (cnt < ans)
		{
			ans = cnt;
		}
	}
	printf("%d %lld\n", id, ans - res);
}
int main()
{
	int T = 1;
	scanf("%d", &T);
	while (T--)solve();
	return 0;
}
```


---

## 作者：WaterSun (赞：1)

# 题意

给定 $n$ 个长度为 $m$ 的数组，对于每一个数组选择下面任意一种操作进行若干次（操作二只能被一个数组选出）。

1. $c_{t,i} - 1,c_{t,i - 1} + 1,c_{t,j} - 1,c_{t,j - 1} + 1$。

2. $c_{t,i} - 1,c_{t,i - 1} + 1,c_{t,j} - 1,c_{t,j - 2} + 1$。

最后输出选择操作二的数组的编号，及其使用操作二的次数。

# 思路

我们不难发现一个普遍性的规律。

如果已知操作一号的数组，操作前和操作后的 $\sum_{i = 1}^{i \leq m}c_{t,i} \times i$ 是不变的。

原因如下：

我们直接看有变化的部分即可。

操作前：$c_{t,i - 1} \times (i - 1) + c_{t,i} \times i + c_{t,j - 1} \times (j - 1) + c_{t,j} \times j$。

操作后：$(c_{t,j - 1} - 1) \times (i - 1) + (c_{t,i} + 1) \times i + (c_{t,j - 1} - 1) \times (j - 1) + (c_{t,j} + 1) \times i$。

我们将上式化简：$c_{t,i - 1} \times (i - 1) + c_{t,i} \times i + c_{t,j - 1} \times (j - 1) + c_{t,j} \times j$。

发现两式相等，证毕。

我们可以通过这一点，用 $s$ 维护一个 $c_{t,i} \times i$ 的前缀和，来寻找出这个与众不同的数组。

这里还有一个奇妙的规律，需要大家去体会体会。

就是，那个选择操作二的数组的操作次数一定是：$\max(s_i) - \min(s_i)$。

因为，我们上文说过，选择操作一的 $\sum_{i = 1}^{i \leq m}c_{t,i} \times i$ 不变，那么，我们再根据上面的推导过程再次推导一遍可以发现，没操作一次操作二，对于我们的 $\sum_{i = 1}^{i \leq m}c_{t,i} \times i$ 每次加 $1$。

因此，我们就得出了上面的结论。

# code

```cpp
#include <bits/stdc++.h>
#define int long long
#define re register

using namespace std;

const int N = 1e5 + 10,inf = 1e18 + 10;
int T,n,m;
int s[N];

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

signed main(){
	T = read();
	while (T--){
		int Max = -inf,Min = inf;
		memset(s,0,sizeof(s));//初始化 
		n = read();
		m = read();
		for (re int i = 1;i <= n;i++){
			for (re int j = 1;j <= m;j++){
				int x;
				x = read();
				s[i] += x * j;//前缀和 
			}
			Max = max(Max,s[i]);//最大值 
			Min = min(Min,s[i]);//最小值 
		}
		for (re int i = 1;i <= n;i++){
			if (Max == s[i]){//输出答案 
				printf("%lld %lld\n",i,Max - Min);
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：cachejtt (赞：1)

## 题意
初始给你 $n$ 个长度为 $m$ 的序列 $c_1,c_2,\dots ,c_n$，初始都与序列 $b$ 相等。

小 E 秘密的在 $1$ 到 $n$ 选择了一个 $k$，并对所有序列进行若干次如下操作。

设当前正在操作的序列是 $c_t$，那么当 $t \ne k$ 时，我们只能进行至少一次操作 $1$；当 $t = k$ 时，我们只能进行至少一次操作 $2$。

操作 $1$ 为，在 $2$ 到 $m-1$ 间选择 $i$ 和 $j$，并把 $c_i$ 和 $c_j$ 减一，把 $c_{i-1}$ 和 $c_{j+1}$ 加一。

操作 $2$ 为，在 $2$ 到 $m-2$ 间选择 $i$ 和 $j$，并把 $c_i$ 和 $c_j$ 减一，把 $c_{i-1}$ 和 $c_{j+2}$ 加一。

现在给你对 $n$ 个 $c$ 操作完后的序列，你的任务是找到 $k$，并找出小 E 进行了几次操作 $2$。

## 性质
注意到操作一与操作二的区别仅为 $c_{j+1}$ 和 $c_{j+2}$ 加一的区别。因此我们可以将 $c$ 数组看为 $b$ 数组的差分。因此对 $c$ 做前缀和，就可以还原出 $b$ 数组。

这时的操作一，相当于 $b_i$ 加一，并把 $b_j$ 减一。因此 $b$ 数组的和和原来相比不会改变。

而这时的操作二，相当于 $b_i$ 加一，并把 $b_j$ 与 $b_{j+1}$ 减一。这时 $b$ 数组的和会相比原来减少 $1$。

考虑如何计算 $b$ 数组的和。由于 $c$ 是 $b$ 的差分，因此 $b$ 是 $c$ 的前缀和。因此 $b_1=c_1,b_2=c_1+c_2,b_3=c_1+c_2+c_3,\dots$。

所以 $b$ 数组的和是 $c_1\times n +c_2\times (n-1)+c_3\times (n-2)+\dots$。

为了方便计算，可以用 $(n+1)\times (c_1+c_2+\dots)$ 减去以上和，得到 $1\times c_1+2\times c_2+\dots$。此时每一次操作 $2$ 都会将这个和增大 $1$。

## 代码
```cpp
#include<bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define nrep(i, a, b) for (int i = (a); i >= (b); --i)
#define ll long long
#define endl "\n"
#define int ll
using namespace std;
int t,n,m,s[100005],cnt,mx,mn; 
signed main(){
  ios::sync_with_stdio(0);
  cin>>t;
  int x;
  rep(kk,1,t){
    mx=-1;
    mn=0x3f3f3f3f3f3f3f3f;
    cin>>n>>m;
    rep(i,1,n){
      s[i]=0;
      rep(j,1,m){
        cin>>x;
        s[i]+=x*j;
      }
      mx=max(mx,s[i]);
      mn=min(mn,s[i]);
    }
    if(s[1]!=s[2]){
      if(s[1]==s[3]){
        cout<<"2 "<<mx-mn<<endl;
      }
      else cout<<"1 "<<mx-mn<<endl;
    }
    else{
      rep(i,2,n){
        if(s[i]!=s[i-1]){
          cout<<i<<" "<<mx-mn<<endl;
          break; 
        }
      }
    }
  }
  return 0;
}
```

---

## 作者：OLE_OIer (赞：1)

# CF1704D Editorial

这道题是 CF Div.1+Div.2 的一道题。总体来说这套比赛的题都挺不错，个人对选手及思维能力都可以有很大的提升，这道题尤其是，可以认为是道神仙题吧。

首先这道题明显是一道组合数学题。学过组合数学的同学们应该都知道，组合数学中很重要的一个技巧就是“找不变量”。

这道题一看题，我们脑中可能就会跳出：数列无论经过多少次操作，其总和不变。但是这个结论对于普通数列与特殊数列均成立，所以对解题没啥用处。

考虑这样的一个值：定义 $t=\sum_{i=1}^{m}(a_i\times i)$。

对于普通数列，原来的值与改变后的值的差别就是改变的数 $i$，$j$，$i-1$ 与 $j+1$。我们因此只需要看这 $4$ 个数的改动即可。

在操作之前，原来 $4$ 个数的值是：
	
$$
\begin{aligned}
a_i\times i+a_{i-1}\times(i-1)+a_j\times j+a_{j+1}\times(j+1)&=(a_i+a_{i-1})\times i+(a_j+a_{j+1})\times j+a_{j+1}-a_{i-1}
\end{aligned}
$$

在操作后，可得到这 $4$ 个数的值是：
	
$$
\begin{aligned}
(a_i-1)\times i+(a_{i-1}+1)\times(i-1)+(a_j-1)\times j+(a_{j+1}+1)\times(j+1)&=(a_i+a_{i-1})\times i+(a_j+a_{j+1})\times j+a_{j+1}-a_{i-1}-i+i-1-j+j+1
&=(a_i+a_{i-1})\times i+(a_j+a_{j+1})\times j+a_{j+1}-a_{i-1}
\end{aligned}
$$

发现了吗？操作前后数值不变。

按同样的方法分析对于特殊数列的操作：

在操作之前，原来 $4$ 个数的值是：
	
$$
\begin{aligned}
a_i\times i+a_{i-1}\times(i-1)+a_j\times j+a_{j+2}\times(j+2)&=(a_i+a_{i-1})\times i+(a_j+a_{j+2})\times j+2a_{j+2}-a_{i-1}
\end{aligned}
$$

在操作后，可得到这 $4$ 个数的值是：

$$
\begin{aligned}
(a_i-1)\times i+(a_{i-1}+1)\times(i-1)+(a_j-1)\times j+(a_{j+2}+1)\times(j+2)&=(a_i+a_{i-1})\times i+(a_j+a_{j+2})\times j+2a_{j+2}-a_{i-1}-i+i-1-j+j+2
&=(a_i+a_{i-1})\times i+(a_j+a_{j+2})\times j+2a_{j+1}-a_{i-1}+1
\end{aligned}
$$

我们可以发现在操作后的值比在操作前的值增加了 $1$。因此就可分辨出特殊数列与普通数列。

所以我们只需要算出每个数列的值总和，然后比其余的大的那一个就是特殊数列，它的和（以下称“不变值”）减去普通数列的“不变值”即为操作几次。

代码附上：
```cpp
//CF1704D Magical Array
#include<bits/stdc++.h>
#define int long long
#define elif else if
#define rd(i) fixed<<setprecision(i)
using namespace std;
void func(){
	int minn=1ll<<60,maxn=0;
	int n,m,k;cin>>n>>m;
	for(int i=1;i<=n;++i){
		int tot=0;//求和
		for(int j=1;j<=m;++j){
			int x;cin>>x,tot+=j*x;
		}
		minn=min(minn,tot);//记录普通数列的“不变值”
		if(maxn<tot) maxn=tot,k=i;//如果出现大于“不变值”的就是特殊数列，那么需要记录数列编号与特殊数列与普通数列的“不变值”之差。
	}
	cout<<k<<" "<<maxn-minn<<"\n";
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	int n;cin>>n;
	for(int i=1;i<=n;++i) func();
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

### 这是一道二次前缀和问题
#### 分析（这个很重要）
乍一看题目是真的恶心(看见样例了吗)。    

我们先对原数组进行一次前缀，因为我们需要分析每次操作对数组的影响(影响就整体而言)，于是我们得到了：   

$
S_i=\begin{cases}
	S_{i,j-1}-1,S_{i,k}+1 & \text{不是特殊数组}\\
	S_{i,j-1}-1,S_{i,k}+1,S_{i,k+1}+1 & \text{是特殊数组}
\end{cases}
$     

然后呢？**觉得是不是有点像差分？我们再来一次前缀**。  

~~奇迹出现了~~若它不是特殊数组，则它不会发生改变！否则他将增加 $1$ 。 

于是这道题我们求最大值和最小值即可。    
#### AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int> v[100005];
//细节，直接开数组开不下
int n,m,t;
signed main(){
	scanf("%lld",&t);
	while (t--){
		scanf("%lld%lld",&n,&m);
		for (register int i=1;i<=n;i++){
			v[i].clear();
			for (register int j=0,x;j<m;j++){
				scanf("%lld",&x);
				v[i].push_back(x);
			}
		} for (register int i=1;i<=n;i++)
			for (register int j=1;j<m;j++)
				v[i][j]+=v[i][j-1];
		for (register int i=1;i<=n;i++)
			for (register int j=1;j<m;j++)
				v[i][j]+=v[i][j-1];
		int ans1=LONG_LONG_MAX,ip1,ip2,ans2=-INT_MAX;
		for (int i=1;i<=n;i++){
			if (ans1>v[i][m-1])
				ans1=v[i][m-1],ip1=i;
			if (ans2<v[i][m-1])
				ans2=v[i][m-1],ip2=i;
		} printf("%lld %lld\n",ip1,abs(ans1-ans2));
	} return 0;
}
```

---

## 作者：yinhy09 (赞：0)

## 思路讲解

本题最主要是要区分两种数列的不同操作，常见思路是配一个权值。我们看一下操作有什么区别：

对 $(i,j)$ 进行操作时，两种操作都对 $i-1$ 的值 $-1$，而不同点是一个对 $j+1$ 进行 $+1$，另一个是 $j+2$ 进行 $+1$。我们可以计算 $sum=a_1+2\cdot a_2+3\cdot a_3+\cdots+n\cdot a_n$，最开始所有数列的 $sum$ 均相同，然后没进行一次第二个操作就会使 $sum_k+1$，所以最后只要找到最大的然后求一下差就能得到操作次数了。

## AC Code：

```cpp
// Problem: D. Magical Array
// Contest: CodeTON Round 2 (Div. 1 + Div. 2, Rated, Prizes!)
// URL: https://codeforces.com/contest/1704/problem/D
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// Author: Luogu-yinhy09(575320),Codeforces-yinhy09
 
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
ll read()
{
	char c;
	ll x=0;
	ll f=1;
	c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f*=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
ll T,n,m;
const int maxn=1e5+5;
ll x,b[maxn];
ll maxx=-9e18,maxpos=-1,otherpos=-1;
int main()
{
	T=read();
	while(T--)
	{
		maxx=-9e18,maxpos=-1,otherpos=-1;
		memset(b,0,sizeof(b));
		n=read(),m=read();
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				x=read();
				b[i]+=x*j;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(b[i]>maxx)maxx=b[i],maxpos=i;
		}
		if(maxpos==1)otherpos=2;
		else otherpos=1;
		printf("%lld %lld\n",maxpos,b[maxpos]-b[otherpos]);
	}
	return 0;
}
```

谢谢观看~

---

## 作者：2018ljw (赞：0)

做法很优美的一道题，被一个很怪的思路屮过去了。

显然三份数组足以区分，只要我们能判断出两个数组均为普通数组即可。考虑 $n=3$ 的问题即可。

$b$ 有初值很不好处理，所以我们将三个数组两两相减，分成 `普-普`、`特-普` 两类。出于方便，以下称相减得到的数组为差分数组。

对差分数组进行一系列操作 $1$ 及其逆操作，若能全变成 $0$，即可说明两个原数组均为普通数组。正确性显然，操作 $2$ 等价于 `(+1,-1)(-1,+1-1,+1)`，多出的 `(-1,+1)` 是用操作 $1$ 补不回来的。

转化为对差分数组进行若干次 `(+1,-1)(-1,+1)` 或 `(-1,+1)(+1,-1)` 操作，能否变为全 $0$。大胆猜测：记录每个位置进行了几次 `(+1,-1)` 或 `(-1,+1)`，最后两类总和相等即可行。感性理解，将两类操作合理重分配即可。

```cpp
bool cmp(long long *a,long long *b){
	int i;
	for(i=1;i<=m;i++)cf[i]=a[i]-b[i];
	long long qz=0;
	for(i=1;i<m;i++){
		qz+=cf[i];
		cf[i+1]+=cf[i];
		cf[i]=0;
	}
	if(qz)return 0;
	return 1;
}
```

那么我们就找到了特殊数组，任取普通数组构造出 `特-普` 的差分序列。根据对操作 $2$ 的等价变形，进行相似的操作，`(+1,-1)` 多了多少次，就是第二问答案。

```cpp
#include<cstdio>
int n,m,t1,t2;
long long nd[300001],ns[300001],nx[300001];
//nd ns 记录可能的特殊数组，nx 为下一个参与比较的数组。
long long cf[300001],n1[300001],sp[300001];
//n1 记录任意一个普通数组，sp 记录特殊数组。
bool cmp(){
	int i;
	for(i=1;i<=m;i++)cf[i]=nd[i]-nx[i];
	long long qz=0;
	for(i=1;i<m;i++){
		qz+=cf[i];
		cf[i+1]+=cf[i];
		cf[i]=0;
	}
	return !qz;
}
int main(){
	int i,j,t;
	scanf("%d",&t);
	while(t--){
		bool fd=0,hr=0;
		int id=0;
		t1=1;t2=0;
		scanf("%d%d",&n,&m);
		for(i=1;i<=m;i++)scanf("%lld",&nd[i]);
		for(i=2;i<=n;i++){
			for(j=1;j<=m;j++)scanf("%lld",&nx[j]);
			if(fd)continue;
			if(!t2){
				if(cmp()){
					hr=1;
					//确定存的数组一定为普通的
					for(j=1;j<=m;j++)n1[j]=nd[j];
					continue;
				}
				if(hr){
					id=i;fd=1;
					for(j=1;j<=m;j++)sp[j]=nx[j];
					continue;
				}
				for(j=1;j<=m;j++)ns[j]=nx[j];
				t2=i;
				continue;
			}
			//nd 与 ns 一定有一个特殊的，nx 即为普通的。
			//那如果 nd 普通，ns 一定特殊
			fd=1;
			if(cmp()){
				id=t2;
				for(j=1;j<=m;j++)sp[j]=ns[j],n1[j]=nd[j];
			}
			else{
				id=t1;
				for(j=1;j<=m;j++)sp[j]=nd[j],n1[j]=ns[j];
			}
		}
		for(i=1;i<=m;i++)cf[i]=sp[i]-n1[i];
		long long res=0;
		for(i=1;i<=m;i++){
			res-=cf[i];
			cf[i+1]+=cf[i];
			cf[i]=0;
		}
		printf("%d %lld\n",id,res);
	}
}
```

---

## 作者：Jr_Zlw (赞：0)

## 找规律

貌似跟官方题解有点出入，不过好像本质是一样的。

看到  "hacks are disabled"  回忆起这应该是个诈骗啥的。

看操作，先看非特殊行，一个数  $+1$，相邻数  $-1$，并且一次有两个这样的东西。

这个东西是不是很像差分后搞区间长度为  $1$  区间加的操作。

所以做一下前缀和再看看，发现一次操作就是前缀和数组一对  $+1,-1$。前缀和的和不改变。

再看看特殊行，它做完前缀和的操作是  $+1,-1,-1$,减多了一次，前缀和的和改变了。

又因为至少做一次，所以特殊行的前缀和的和肯定改变了。

然后还可以发现，每操作一次特殊行的前缀和的和  $-1$。

所以直接找完，然后普通行的前缀和的和减去特殊行前缀和的和就能得出第二问的答案了。

代码：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define rep(a,b,c) for(int c(a);c<=(b);++c)
#define drep(a,b,c) for(int c(a);c>=(b);--c)
#define grep(b,c) for(int c(head[b]);c;c=nxt[c])
#define Clear(a,n) memset(a,0,((n)+3)*sizeof(a[0]))
typedef long long LL;
typedef std::pair<int,int> pii;
#define int LL
inline int read()
{
	int res=0;char ch=getchar();bool flag=0;while(ch<'0'||ch>'9')flag^=(ch=='-'),ch=getchar();
	while(ch<='9'&&ch>='0')res=res*10+(ch^48),ch=getchar();return flag ? -res : res ;
}
inline void rd(bool &x){char c;do c=getchar();while(c!='0'&&c!='1');x=c=='1';}
inline void print(LL x){if(x>9)print(x/10);putchar(x%10+'0');}
template<typename T> inline T min(const T&x,const T&y){return x<y?x:y;}
template<typename T> inline T max(const T&x,const T&y){return x<y?y:x;}
template<typename T> inline T Swap(T&x,T&y){T tmp=x;x=y;y=tmp;}
template<typename T> inline T Abs(T&x){return x<0?-x:x;}
const int N=3e5+10,INF=0x3f3f3f3f;int n,m,sum[N];
inline void Solve()
{
	n=read();m=read();rep(1,n,i)
	{
//		int ss=0;d
		int ss=0;sum[i]=0;rep(1,m,j)sum[i]+=(ss+=read());
//		ClearV(a[i]);ClearV(s[i]);a[i].resize(m+1);s[i].resize(m+1);
//		sum[i]=0;rep(1,m,j)sum[i]+=s[i][j]=s[i][j-1]+(a[i][j]=read());
	}
	int cnt=0,idx=0;rep(2,n,i)if(sum[i]!=sum[1])++cnt,idx=i;
	int qwq=cnt==n-1?1:idx,qaq=(qwq==1?sum[2]:sum[1]);
	printf("%lld %lld\n",qwq,qaq-sum[qwq]);
}

signed main()
{
	int T=read();
	while(T--)Solve();
	return 0;
}
```

---

## 作者：Andrewzdm (赞：0)

~~一道 _Never Gonna Give You Up_ 式的 Rick Astley 诈骗题~~

一道思维好题。

乍一看很难找到突破口——复原数组 $b$ 显然是不现实、不可行的。

那么思考的重点便是：
* 所有由操作 $1$ 得到的数组，有什么共同的特征？
* 由操作 $2$ 得到的数组，如何与操作 $1$ 得到的数组区别开来？
* 既然要计数，那么能否把数组映射为一个数，从而既达到判定又达到计数的目的？

目标：将数组处理成一个值，使得进行一次操作 $1$ 不会改变这个值，而进行一次操作 $2$ 会将这个值增加 $1$。

这种想法属实是妙手偶得的神来之笔。

这其实是一个 hash 的思想，也就是，构建映射。

那么思路呼之欲出了：计算 $\sum\limits_{j=1}^n j \times c_j$。这个值满足我们的目标。

时间复杂度 $O(nm)$，代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int n, m;
vector<ll> c[maxn];
ll v[maxn];

void work()
{
    cin >> n >> m;
    for(int i = 1; i <= n; ++i)
    {
        c[i].clear();
        c[i].resize(m + 1);
    }
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            cin >> c[i][j];
    fill(v + 1, v + n + 1, 0);
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            v[i] += j * c[i][j];
    ll mx = 0;
    int idx;
    for(int i = 1; i <= n; ++i)
    {
        if(v[i] > mx)
        {
            idx = i;
            mx = v[i];
        }
    }
    cout << idx << ' ';
    for(int i = 1; i <= n; ++i)
        if(v[i] != mx)
        {
            ll ans = mx - v[i];
            cout << ans << endl;
            break;
        }
    return;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) work();
    return 0;
}
```

---

## 作者：fast_photon (赞：0)

**0. 前言**  
Upd 2022.8.2 19:38 修复了一处 $\LaTeX$ 以及题目传送门  
[这题](https://www.luogu.com.cn/problem/CF1704D)，是第一道我借助物理做出来的 OI 题！（只是**我**想的时候用到了物理知识，所以别害怕）  

**1. 怎么做**  
构造一个值 $sum=\sum\limits_{i=1}^{n}i\times a_i$。  
显然，对两个数 $a_i$，$a_j$ 执行 1 操作的时候，会导致 $a_{i-1},a_i,a_j,a_{j+1}$ 变为 $a_{i-1}+1,a_i-1,a_j-1,a_{j+1}+1$。$sum$ 不变。  
但是，执行 2 操作的时候会导致 $a_{i-1},a_i,a_j,a_{j+2}$ 变为 $a_{i-1}+1,a_i-1,a_j-1,a_{j+2}+1$，$sum$ 增加 $1$。  
那么只需要找出那个不一样的 $sum$，减去任何一个其他的 $sum$，得出答案即可。  

**2. 怎么想**   
[让物理引导我们的思路](https://www.luogu.com.cn/paste/es18f0rv)

更直白地说，把 $a_i$ 理解为 $a_i$ 个坐标为 $i$ 的点，而 1 操作分别让两个点坐标 $+1$ 和 $-1$，2 操作分别让两个点坐标 $+2$ 和 $-1$，所以 1 操作坐标总和不变，2 操作让总和 $+1$。所以只需要求出所有坐标总和，找出不一样的即可。这就是上面的 $sum$。

**3. 代码**  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<algorithm>
#define maxn 100005
#define int long long
#define fopen(x) freopen(x".in", "r", stdin); freopen(x".out", "w", stdout);

using namespace std;

int t, n, m, a[maxn], cnt, cnt2, pos;

vector<int> g[maxn];

signed main() {
	cin >> t;
	while(t--) {
		cnt2 = 0;
		cnt = 0;
		int ans1 = -1, ans2 = 0;
		cin >> n >> m;
		for(int i = 0; i < n; i++) {
			g[i].clear();
			cnt = 0;
			int w = 0;
			for(int j = 0; j < m; j++) {
				int x;
				cin >> x;
				g[i].push_back(x + w);
				cnt += g[i][j] - g[0][j];
				w = g[i][j] - g[0][j];
				//cout << w << ' ';
			}
			a[i] = cnt;
			//cout << cnt << endl;
			if(i > 0) {
				if(cnt != 0) {
					cnt2++;
					ans1 = i + 1, ans2 = a[i];
				}
			}
		}
		if(cnt2 == 1) cout << ans1 << ' ' << abs(ans2) << endl;
		else cout << 1 << ' ' << abs(ans2) << endl;
	}
}
```

---


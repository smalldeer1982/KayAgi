# Difference Array

## 题目描述

你有一个初始长度为 $n$ 的有序数组 $a$（从小到大）。设 $a$ 当前长度为 $l$，你要对 $a$ 作差分，即令 $b_i = a_{i+1} - a_i(1\le i < l)$，然后将 $b$ 数组从小到大排序，接着让 $a_i = b_i(1 \le i < l)$，并继续执行上述操作。

显然，每一次操作后 $a$ 数组的长度都会减少 $1$；执行 $n - 1$ 次操作之后，$a$ 中只会剩下一个元素，请你输出这个剩下的元素。

## 样例 #1

### 输入

```
5
3
1 10 100
4
4 8 9 13
5
0 0 0 8 13
6
2 4 8 16 32 64
7
0 0 0 0 0 0 0```

### 输出

```
81
3
1
2
0```

# 题解

## 作者：王熙文 (赞：15)

## 思路

将 $0$ 单独处理后暴力模拟。可以证明复杂度是对的（文章最后会证明）。模拟过程见代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;

vector<int> a,b; // 当前除 0 的数组和差分后的数组

int main()
{
	int t; cin>>t; while(t--)
	{
		a.clear();
		cin>>n;
		int cnt0=0; // 记录 0 的出现次数
		for(int i=1; i<=n; ++i)
		{
			int x; cin>>x;
			if(!x) ++cnt0;
			else a.push_back(x);
		}
		while(a.size()>1)
		{
			b.clear(); // b 表示差分后的数组
			if(cnt0) b.push_back(a[0]),--cnt0;
			// 如果当前数组有 0，那么最后一个 0 会与非 0 的第一个数相减，放进 b 数组，0 的个数少 1
			// 其他的 0 与后面的 0 相减还是 0，没有影响
			for(int i=1; i<a.size(); ++i)
			{
				int cj=a[i]-a[i-1];
				if(!cj) ++cnt0;
				else b.push_back(cj);
				// 如果差分后的数为 0 就直接计入 0 的个数，否则放进 b 数组
			}
			sort(b.begin(),b.end());
			a=b;
		}
		cout<<(!a.size()?0:a[0])<<'\n';
		// 如果 a 没了一定在最后一次操作中产生了 0，直接输出 0
		// 否则剩下的 0 与 a 中的唯一的元素若干次差分后还会剩下 a 中唯一的元素，直接输出
	}
	return 0;
}
```

## 证明复杂度

先暴力操作第一次，此时需要花 $\mathcal O(n \log n)$ 的时间。

第二次开始，记当前数组总和（$\sum\limits_{i=1}^n a_i$）为 $S$。

显然，$S$ 等于上一次数组的最后一项减第一项（$S=a_n-a_{n-1}+a_{n-1}-a_{n-2}+ \cdots  + a_2 - a_1=a_n-a_1$）。那么第二次的 $S=a_n-a_1$，在值域量级（$5 \times 10^5$）。

考虑每一次 $S$ 会减多少。当前的 $S$（设为 $S_1$）一定大于等于 $n-1+a_n$（前 $n-1$ 至少为 $1$）；操作后的 $S$（设为 $S_2$）为 $a_n-a_1$ 一定小于等于 $a_n$。

此时有两个不等式：$n-1+a_n \le S_1,S_2 \le a_n$，将两个式子加起来可得 $S_1-S_2 \ge n-1$，也就是每一次的 $S$ 至少会减 $n-1$。

当 $S$ 小于等于 $0$ 时就操作完了，所以一共需要操作 $\mathcal O(\dfrac{S}{n})$ 的时间。每一次操作需要花 $\mathcal O(n \log n)$ 的时间，总时间便是 $\mathcal O(S \log n)$。

综上，总复杂度为 $\mathcal O((n+S) \log n)$，可以通过本题。

---

## 作者：Gmt丶FFF (赞：7)

第一眼看题目可以看出本题是用模拟。

然后就没第二眼了。

通过造大数据模拟可以发现到后面前置 $0$ 会越来越多。

那么我们需要证明的就是经过很少步骤后，有大量的前置 $0$，这样可以忽略前置 $0$，使算法远低于 $O(n^2)$。

#### 证明：

要使前置 $0$ 越少，只需让差值分布均匀，且差值的差值分布均匀。

这就想起了我们可爱的**斐波那契数列**。

因为 $\mathit{a}_{n}=\mathit{a}_{n-1}+\mathit{a}_{n-2}$。

所以反过来 $\mathit{a}_{n-2}=\mathit{a}_{n-1}-\mathit{a}_{n}$。

所以斐波那契数列中每做一次差会使数列向左移两位，并且很明显斐波那契数列的差分布是最均匀的

而斐波那契数列每往后推一个，增长近似乘 $2$。

所以只需 $\log(5\times10^5)$ 就可以得到许多前置 $0$。

最后忽略前置 $0$ 模拟即可。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+5;
int a[N],p[N],n;
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]),p[i]=a[i];
		int cnt=2;
		for(int i=1;i<n;i++)
		{
			if(cnt>n)break;
			if(cnt<i+1)cnt=i+1;
			int t=p[cnt-1];
			for(int j=cnt;j<=n;j++)
			{
				int k=p[j];
				p[j]-=t;
				t=k;
			}
			sort(p+cnt,p+n+1);
			for(int j=cnt;j<=n;j++)
			{
				if(p[j]==0)cnt++;
				else break;
			}
		}
		printf("%d\n",p[n]);
	}
	return 0;
}
```


---

## 作者：Exiler (赞：4)

## 原题

[CF1707B Difference Array](https://www.luogu.com.cn/problem/CF1707B)

---

## 思路概述

### 题意分析

给定一个长度为 $n$ 的序列 $\{a\}$。每次执行以下操作

> 对序列 $\{a\}$ 进行差分，得到差分序列 $b_i=a_{i+1}-a_i(1≤i<n)$。

> 将差分序列 $\{b\}$ 进行升序排序。

> 将差分序列中的数值按顺序赋回原序列。

求 $(n-1)$ 次操作后最后剩下的数字

### 思路分析

先考虑暴力模拟，则时间开销 $O(n)$ 的差分与时间开销 $O(n\log n)$ 的排序需要进行 $n$ 次，总时间复杂度 $O(n^2\log n)$。明显超时。

手动模拟几组数据不难发现，对于出现的绝大部分序列，在差分、排序、赋值的过程中总会在最后出现一串 $0$。通过进一步分析与模拟可以发现，去除出现的**绝大部分** $0$ 不会影响最后的结果，反而可以节省若干次计算。

考虑每次差分后将序列中的 $0$ 去除后再排序，可以将时间复杂度降至题目要求范围内。

---

## 算法实现

### 关于时间复杂度的证明

我们先列出一组差分序列全为 $0$ 的序列，即序列的所有元素都相等。例如以下序列：

$$\{1,1,1,1,1,1\}$$

通过简单数学分析可以知道，该数列在上一次操作前必定是一阶等差数列（为方便表述，笔者称其为逆操作），且元素数量比上述数列多 $1$。如下：

$$\{1,2,3,4,5,6,7\}$$

以此类推，可以知道再上一次操作前的序列必定是二阶等差数列。即对初始序列 $\{1,1,1,1,1,1\}$ 进行 $n$ 次逆操作后得到的原始序列是 $n$ 阶等差数列。

通过不完全归纳可以得到基于以上序列推出的 $n$ 阶等差数列第 $n$ 项为 $2^n$。相应地，对于长度为最大数为 $2^n$ 的 $n$ 阶等差数列，只需要 $n$ 次操作，就可以将其变为 $1$。这就确立了最终时间复杂度与 $\log \max\{a_i\}$ 的关系。

根据题目给出 $0≤a_i≤5×10^5$ 的数据范围可以知道，即使是最大的 $a_i$ ，在去除前导 $0$ 的情况下，也可以理论时间复杂度 $O(n\log(n+\max\{a_i\})$ 下通过数据点。

### 关于前导 $0$

对于前导 $0$，如果全部去除，则必然出现问题。例如以下数据：

$$\{0,0,0,7,9\}$$

手动模拟结果为 $1$，但若去除所有前导 $0$，结果则为 $2$。

若保留一个前导 $0$，结果为 $5$，仍然与模拟结果不符。

由上述样例的分析可知，若序列中存在一串长度为 $m$ 的由非零数组成的子序列，其前方有 $k(k≥m)$ 个前导 $0$，则其中的 $m$ 个前导 $0$ 对差分都是有贡献的。所以对于这些前导 $0$ 的贡献，需要用一个变量来记录。而对于一个前面存在有贡献前导 $0$ 的非零子序列，则在赋值时在差分序列中预置原序列第一个数，就可以在下次差分前插入前导 $0$。

---

## AC code


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<set>
#include<ctime>
#define RI register int
#define RB register bool
using namespace std;
const int maxn=1e5+10;
int T,n,cnt;
int a[maxn],b[maxn];
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	for(cin >> T,cnt=0;T;--T,cnt=0)
	{
		cin >> n;
		for(RI i=1;i<=n;++i) 
		{
			cin >> a[i];
			if(!a[i])
			{
				++cnt;
				--i;--n;
			}
		}
		for(RI pos=0;n>1;pos=0)
		{
			if(cnt) 
			{
				b[++pos]=a[1];
				--cnt;
			}
			for(RI i=1;i<n;++i)
				if(a[i+1]-a[i]) b[++pos]=a[i+1]-a[i];
				else ++cnt; 
			n=pos;sort(b+1,b+n+1);
			for(RI i=1;i<=n;++i) a[i]=b[i];
		}
		printf("%d\n",a[n]);	
	} 
	return 0;
}

```

---

## 作者：hgckythgcfhk (赞：2)

注意到样例的第 $4$ 组数据，这个数据具有极强的提示作用，发现均摊下来只会操作 $O(n\log V)$ 次，因为每次差分会导致数组中的大部分位置折半，所以大部分会在 $O(\log V)$ 次操作后变成 $0$，这种情况是 $O(n\log V)$，只有极少数相邻两个相差很大的会操作多次，而这种位置最多有 $O(\log V)$ 个，由于每次都会使元素个数减少 $1$，所以这种情况也是 $O(n\log V)$，总体上均摊 $O(n\log V)$，可以暴力，但注意要维护两个指针，已经变成 $0$ 的只有最后一个需要操作，但一定别忘了操作，还有每次减少的一定是数组的最后一个元素，这个元素记得清零，否则容易出事，具体看程序就行，程序很短，但懒得改宏定义，防止因为火车头导致无法过审，我直接放 CF 上的 [记录](https://codeforces.com/contest/1707/submission/256059210)。

---

## 作者：Cocoly1990 (赞：2)

分享一个傻逼根分。

你看这个数据范围啊，啊长得啊，$n$ 和 $\sum a_i$ 同阶啊。

根号分治你想到了吗？那怎么根分呢？

我们请可爱八云蓝来回答一下：

> 八云蓝：注意到 $>\sqrt n$ 的 $a_i$ 最多不超过 $\sqrt n$ 个，我们把这些都存起来，每次操作处理可能的差分值，并更新数组，可以证明随着操作增加 $\sum a_i$ 是会递减的，所以根号分治是对的。

哇，不愧是八云蓝，真厉害。

> 八云蓝：傻逼 cocoly 你来贴一下代码。

好的好的 ヽ(￣▽￣)و。

```
int T, n, a[Maxn], q, b[Maxn], c[Maxn];
bool vis[Maxn];
vector<int> v, v2;
bool check(int x){
	int now = x, qq = q;
	for(int i = 1; i <= n; i ++){
		if(qq == 0) break;
		if(a[i] <= qq){
			vis[i] = 1;
			now --;
		}
		if(a[i] > qq && i + now - 1 >= n){
			vis[i] = 1;
			now --;
			qq --;
		}
	}
	if(now <= 0) return 1;
	else return 0;
}
void pre(){
	for(int i = 0; i <= L; i ++) b[i] = 0;
	v.clear();
}
void cl(){
	for(int i = 0; i <= L; i ++) c[i] = 0;
	v2.clear();
}
void op(){
	cl();
	int res = - 1;
	for(int i = 0; i <= L; i ++){
		if(b[i]){
			if(res + 1) c[i - res] ++;
			c[0] += b[i] - 1;
			res = i;
		}
	}
	for(auto i : v){
		if(res + 1){
			int temp = i - res;
			if(temp > L) v2.push_back(temp);
			else c[temp] ++;
			res = i;
		}else{
			res = i;
		}
	}
	sort(v2.begin(), v2.end());
	v = v2;
	for(int i = 0; i <= L; i ++){
		b[i] = c[i];
	}
}
void solve(){
	cin >> n;
	pre();
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
	}
	for(int i = 1; i <= n; i ++){
		if(a[i] > L) v.push_back(a[i]);
		else b[a[i]] ++;
	}
	for(int i = 1; i < n; i ++) op();
	for(int i = 0; i < L; i ++){
		if(b[i]){
			cout << i << endl;
			return;
		}
	}
	cout << v[0] << endl;
	
}
```


---

## 作者：Sunrise_up (赞：1)

一道暴力模拟题，没有什么好说的。

由于 $0$ 不影响结果，所以可以忽略 $0$，即在数组有 $0$ 时进行特殊处理，优化代码。

最终代码时间复杂度为低于 $n^2$，可以通过。

记得排序！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int a[N],b[N],n,cnt,x;
int main(){
	int t;cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i],b[i]=a[i];
		cnt=2;
		for(int i=1;i<n;i++){
			if(cnt>n)break;
			if(cnt<i+1)cnt=i+1;
			int y=b[cnt-1];
			for(int j=cnt;j<=n;j++){
				x=b[j];
				b[j]-=y;
				y=x;
			}
			sort(b+cnt,b+n+1);//排序b数组cnt至n 
			for(int j=cnt;j<=n;j++){
				if(!b[j])cnt++;//统计0个数，因为0不影响结果 
				else break;
			}
		}
		cout<<b[n]<<endl;//答案 
	}
	return 0;//完结 
}
```

---

## 作者：xzy090626 (赞：1)

# CF1707B 题解
## 题意
你有一个初始长度为 $n$ 的单调递增序列 $a$。设 $a$ 当前长度为 $l$，你要对 $a$ 作差分，即令 $b_i = a_{i+1} - a_i(1\le i < l)$，然后使 $b$ 序列保持单调递增，接着让 $a_i = b_i(1 \le i < l)$，并继续执行上述操作，直到 $a$ 中只剩下一个元素，输出这个元素。
## 分析
首先想到纯暴力模拟。

但是看到数据范围，$2 \le n \le 2\cdot 10^5$，肯定是会 T 的。

那么会发现，在做差分的过程中，会有 $0$ 的产生。这些 $0$ 显然没有用处，但会影响速度，因此我们可以排除掉这些 $0$ 的存在。

但是单单是这样无法保证答案正确性，想一想是为什么？

我们看到样例中最典型的第三组数据：
```
5
0 0 0 8 13
```
如果我们暴力地去做，会发现过程是

---
`0 0 5 8`

`0 3 5`

`2 3`

`1`

---
答案是 $1$。

但是如果直接排除掉 $0$，就会直接得出了一个错误的答案 $5$。

显然，原因是 $8$ 前面的 $0$ 其实对差分的过程是有影响的。

如果我们保留这个 $0$，仅仅删去前面的 $0$ 的话，过程就是：

---
`0 5 8`

`3 5`

`2`

---
答案仍然是错的。

哦，原来是因为所有的 $0$ 都是对差分有着贡献的！

但是，为了提高效率，我们必须要删去它们。

因此，我们可以定义一个变量 $cnt$，用于记录删去的 $0$。

每次差分前，如果 $cnt > 0$，则说明之前删去过 $0$。

此时，我们可以先将 $a$ 中的第一个元素加入 $b$ 中，这样下次差分的时候，就会产生出一个 $0$ 来。这时我们可以将 $cnt$ 减 $1$，因为如果一直加反而会导致结果的错误。

这时，我们就保证了每次差分之后，如果之前出现过 $0$，则现在 $b$ 的开头一定有一个 $0$。

这样就成功地保证了结果的准确性。
## 实现
建议使用 vector，好用、方便，当然手写数组也可以。

按照上面进行模拟即可。

---

## 作者：I_am_wjr_I_AK_IOI (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF1707B)

## 思路：
这题本蒟蒻觉得是[差分](https://blog.csdn.net/Cooperia/article/details/118864683) & [排序](https://blog.csdn.net/Edward_Asia/article/details/121419975)，每一次操作都 sort 一下，但不一定每次排序都把所有元素全部排一下，0 始终在前面，所以只需要排后面的非零元素就 OK 了！
## Code：

```cpp
#include<bits/stdc++.h>//万能头，但在OI赛场上不推荐 
using namespace std;
#define int long long
#define N 11451411
int a[N] ,b[N] ,T;
int maxn(int x,int y){//手搓max函数
	if(x > y){
		return x;
	}else{
		return y;
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);//黑科技 
    cin>>T;
    while(T --){   
		int n;
		cin>>n;
		for(int i = 1;i <= n;i ++){
			cin>>a[ i];
		}
		int p = n;
		for(int i = 1;i <= n;i ++){
			if(a[ i]){
				p = i - 1;
				break;
			}
		}
		while( n > 1 && a[n - 1]){
			for(int i = maxn(1,p);i <= n - 1;i ++) a[i] =a[i + 1] - a[i];
			n --;
			stable_sort(a + p , a + n + 1);
			if(p > 1){
				p --;
			}
			while(p + 1 <= n&&a[ p + 1] == 0){
				p ++;
			}
		}
		cout << a[n] << "\n";
    }
	return 0;
}//代码完结，撒花！！！ 
```
[改编于](https://blog.csdn.net/m0_63305704/article/details/126031084)

---

## 作者：ZLCT (赞：0)

# CF1707B Difference Array
## 题目翻译
给定一个长度为 $n$ 的不下降子序列，一共进行 $n-1$ 轮操作，第 $i$ 轮操作令所有 $i\le n-i,a_i=a_{i+1}-a_i$，在每一轮最后都把序列升序排序。求最后剩下的元素。
## 一个十分美妙的题目
这个题我们观察到有一种情况非常奇特，那就是 $0$，因为无论几个 $0$，其实在每次操作的时候只想当于其它 $0$ 不变，只有一个 $0$ 参与操作。\
那我们一种很自然的优化方法就是把 $0$ 单独拿出来，每次顶多放一个。\
但是这样以后貌似就没有什么优化的好方法了。\
事实证明这样就已经足够了，但是为什么呢？我们来证明一下。
## 复杂度证明
首先假设我们一开始有 $x$ 个 $0$ 元素，那么我们只需要证明在这种情况下我们能构造序列的最大时间复杂度能接受即可。\
接下来就是如何构造这个序列。\
首先我们想到假设存在两个相同元素，那么我们第一次就可以把其中一个变成 $0$，这样对于复杂度没有太大影响，所以就可以钦定所有数互不相同。\
假设我们已经进行了一次操作，那么问题又回到了原来。\
那这两次的区别就是如果把原序列看作 $0$ 阶差分数组，那么新的序列就是一阶差分数组。\
这样以此类推我们相当于每次序列就是 $i$ 阶差分数组。\
那么我们假设每次都没有 $0$ 元素，那么我们要构造的就是一个 $n-1$ 阶全都不为 $0$ 的差分数组（如果为 $0$ 则说明之前出现过 $0$ 元素）。\
由于原数组值域上界和 $n$ 是一个级别，所以我们肯定希望构造的差分数组全是 $0$ 就行了（这样是最划算的，每多加 $1$ 都会对原数组的值域提升）。\
稍微对于数字比较敏感的可以发现这对于 $a_n$ 是个大约指数增长的函数。\
如过对于数字不敏感可以从物理方面类比：\
对于速度和加速度，加速度的值对于速度来说大概是一次级别的增加，而这只是一阶差分，二阶差分可以想象为加速度的加速度，这样对于速度的影响就是平方级的，以此类推。\
所以如果没有出现过 $0$，则只可能进行 $\sqrt[n]{V}$ 轮，即使每轮都全部更改，那也不过 $n\sqrt[n]{V}$ 的复杂度。\
**那如果存在 $0$ 怎么办？**\
假设我们初始出现了 $x$ 个 $0$，那么我们在数组中新出现 $0$ 之前进行的轮数就是 $\min(x,\sqrt[n-x]{V})$，这部分的复杂度就是 $(n-x)\times\min(x,\sqrt[n-x]{V})$。\
但是我们发现不容易继续计算了，于是我们采用一种贪心方法。\
既然无论几个 $0$ 都只算 $1$ 个，我们就不如每次只添加 $1$ 个当前用的 $0$，那这样的构造最好情况就是斐波那契数列（每次相当于整体向左平移 $1$）。\
而我们知道斐波那契数列的增长速度大概是 $2^n$，所以当 $n$ 和值域都拉到最大时，最终复杂度大概为 $O(n\log n)$。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[112345],cnt;
void solve(){
    multiset<int>s;
    multiset<int>st;
    cnt=0;
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        s.insert(a[i]);
    }
    while(s.size()>1){
        st.clear();
        int pre=-1;
        for(int i:s){
            if(pre==-1){
                pre=i;continue;
            }
            if(i-pre==0){
                if(st.find(0)!=st.end())st.insert(0);
                else cnt++;
            }else{
                st.insert(i-pre);
            }
            pre=i;
        }
        s.clear();
        for(int i:st){
            s.insert(i);
        }
        if(s.find(0)==s.end()&&cnt){
            s.insert(0);cnt--;
        }
    }
    cout<<*s.begin()<<'\n';
}
signed main(){
    int T;cin>>T;
    while(T--)solve();
    return 0;
}
```

---

## 作者：yhx0322 (赞：0)

## 题目简述
设序列 $a$ ，并且是单调递增的。设 $a$ 当前长度为 $l$，你要对 $a$ 作差分，即令 $b_i = a_{i+1} - a_i(1\le i < l)$，然后使 $b$ 数组保持单调递增。

一直持续操作，直到 $a$ 数组中只有一个元素 $x$，输出 $x$。

## 暴力 $\to$ 优化
暴力的话，就是纯模拟。

时间复杂度：$O(n^2)$，本题 $1 \le n \le 10^5$，时间复杂度达到了惊人的 $10^{10}$。

考虑如何优化。

我们得出一个结论：差分的时候，**一定会有 $0$ 出现**，而 $+0/-0$ 都对结果造不成影响，所以我们可以排除 $0$ 的存在。

但是，我们经过模拟样例发现，$0$ 在一定程度上是会对差分结果造成影响的。那我们改如何处理呢？

定义变量 $x$，记录之前删没删过 $0$。

每次差分前，如果 $x > 0$，表示删除过 $0$。

此时，我们可以先将 $a_1$ 加入 $b$ 中，这样下次差分就会产生出一个 $0$。

这时我们可以将 $x$ 减 $1$，因为如果一直加反而会导致结果的错误。

代码就不贴了，实现比较简单。

---


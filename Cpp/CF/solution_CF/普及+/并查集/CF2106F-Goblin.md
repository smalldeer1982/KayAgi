# Goblin

## 题目描述

TC 博士有一位新病人叫哥布林。他想测试哥布林的智力，但对标准测试感到厌倦了，于是决定增加难度。

首先，他创建一个长度为 $n$ 的二进制字符串$^{\text{∗}}$ $s$。然后，他创建 $n$ 个二进制字符串 $a_1, a_2, \ldots, a_n$。已知 $a_i$ 是通过先复制 $s$，再翻转第 $i$ 个字符（$\texttt{1}$ 变为 $\texttt{0}$，反之亦然）得到的。创建完所有 $n$ 个字符串后，他将它们排列成一个 $n \times n$ 的网格 $g$，其中 $g_{i, j} = a_{i_j}$。

一个大小为 $k$ 的集合 $S$ 被认为是好的，如果它满足以下条件：

1. 对于所有 $1 \leq i \leq k$，有 $1 \leq x_i, y_i \leq n$；
2. 对于所有 $1 \leq i \leq k$，有 $g_{x_i, y_i} = \texttt{0}$；
3. 对于任意两个整数 $i$ 和 $j$（$1 \leq i, j \leq k$），坐标 $(x_i, y_i)$ 可以通过一系列相邻的（共享一条边的）值为 $\texttt{0}$ 的单元格到达 $(x_j, y_j)$。

哥布林的任务是找出一个好的集合 $S$ 的最大可能大小。由于 TC 博士很慷慨，这次给了他两秒而不是一秒来找出答案。哥布林以不诚实著称，所以他请你帮他作弊。

$^{\text{∗}}$ 二进制字符串是指仅由字符 $\texttt{1}$ 和 $\texttt{0}$ 组成的字符串。

## 说明/提示

在第一个示例中，网格如下：

```
1 0 0
0 1 0
0 0 1
```

由单元格 $(1, 2)$ 和 $(1, 3)$ 组成的集合是好的。由单元格 $(1, 1)$ 和 $(1, 2)$ 组成的集合不是好的，因为单元格 $(1, 1)$ 的值不是 $\texttt{0}$。由单元格 $(1, 2)$、$(1, 3)$ 和 $(2, 3)$ 组成的集合是好的，且最大大小为 $3$。注意，由单元格 $(2, 1)$、$(3, 1)$ 和 $(3, 2)$ 组成的集合也是好的，最大大小同样为 $3$。

在第二个示例中，网格如下：

```
1 0 1 0
0 1 1 0
0 0 0 0
0 0 1 1
```

好的集合的最大可能大小为 $9$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
6
3
000
4
0010
7
1011001
4
0001
2
11
1
0```

### 输出

```
3
9
10
7
1
0```

# 题解

## 作者：exCat (赞：0)

虽然简单，但是我没做出来的题。

首先题目要我们求得就是一个最大全 $0$ 的连通块。

我们显然有一个简单的想法，设 $f_{i,j}$ 表示包含 $(i,j)$ 的满足条件的连通块大小，转移显然是 $f_{i,j}=f_{i-1,j}+w(i,j)$ (这里的 $w(i,j)$ 表示在第 $j$ 列 $i$ 向上向下连续的 $0$ 个数)。但是复杂度是 $O(n^2)$ 。

上面的做法可以适用任意给出的情况，但是我们这道题不是任意给出的，而是复制 $n$ 份，每列修改一个位置。所以每列只有一个 $0$ 或只有一个 $1$ 。也就是说每一列修改的位置以上的所有位置值是一样的，同理以下的也一样。

所以启示我们对于每一列只维护三个值即可。转移直接分类讨论即可（细节可以看代码）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+10;
int n;
char s[N];
void solve()
{
	cin>>n>>(s+1); 
	int l,r,m,ans=0;
	if(s[1]=='0')l=m=0,r=n-1;
	else l=r=0,m=1;//初始化
	ans=max(ans,max(l,max(r,m)));
	for(int i=2;i<=n;i++)
	{
		int j=n-i;
		if(s[i-1]=='0')
		{
			if(s[i]=='0')l+=(i-1),m=0,r+=j;
			else m=r+1,l=0,r=0;
		} 
		else
		{
			if(s[i]=='0')l=m+i-1,m=0,r=j;
			else l=r=0,m=1;
		}
		ans=max(ans,max(l,max(r,m)));
	} 
	cout<<ans<<'\n';
} 
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int t;cin>>t; 
	while(t--)solve();
	return 0;
} 
```

---


# 1-2-K Game

## 题目描述

现有n个东西，每次可以取1个，2个或k个

Alice和Bob轮流取，且Alice先取

问谁是最后一个取的

每组数据有t个询问

## 样例 #1

### 输入

```
4
0 3
3 3
3 4
4 4
```

### 输出

```
Bob
Alice
Bob
Alice
```

# 题解

## 作者：逃课小姐MS (赞：10)

博弈论的题 相对来讲还是要推一下的

首先 我们先明确并转化题目意思：

A和B两个人共取走n个石子，每次他们都可以取1，2，或者k个。问谁能把石子取到0。前提条件时两个人都足够聪明。

那我们简单想一想：

- 假设窝的k=3：

那么我的n为0、1、2...

|n=|0| 1 | 2 | 3 | 4 |5  |6  |7  |8  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|胜者 | B | A | A | A |B  |A  |A  |A  |B  |

- 再次假设我的k=4：

|n=|0| 1 | 2 | 3 | 4 |5  |6  |7  |8  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|胜者 | B | A | A | B |A  |A  |B  |A  |A  |

我们发现所有的B点都是必败点，当我们的任意一方踩到这个点时（从这个点开始走），他就输了。

如果m点是必败点，那么$m+1，m+2，m+k$就是必胜点，因为如果在这个点上面，我们可以通过走1，2，k步走到一个必败点，从而赢得胜利。

然后 我们会发现，当我们的 $k%3!=0$ 时，他们的必败点都是n=3k的时候。（显然，基本不用证明）

那如果k是3的倍数呢？

也很简单通俗易懂：

我们再举两个例子，k=6和k=9.（k=3在上面已经有了）

|k=6时n=  |0  |1  |2  |3  |4  |5  |6  |7  |8  |9  |10  |11  |12  |13  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|胜者  |B  |A  |A  |B  |A  |A  |A  |B  |A  |A  |B  |A  |A  |A  |
|**k=9时n=**  |**0**  |**1**  |**2**  | **3** |**4**  |**5**  |**6**  |**7**  |**8**  |**9**  |**10**  |**11**  |**12**  |**13**  |
|胜者  |B  |A  |A  |B  |A  |A  |B  |A  |A  |A  |B  |A  |A  |B  |

我们会发现每k+1个形成一个循环，所以说我们把n%一个k+1

然后，n除出来的余数，如果是3的倍数且不是k，那么就是一个必败点，反之亦然。

- 代码如下，我就不做解释了：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int i=1;i<=t;i++){
        int n,x;
        cin>>n>>x;
        if(x%3!=0){
            if(n%3==0) cout<<"Bob"<<endl;
            else cout<<"Alice"<<endl;
        }
        else{
            n%=(x+1);
            if(n%3==0&&n!=x) cout<<"Bob"<<endl;
            else cout<<"Alice"<<endl;
        }
    }
    return 0;
}
```

---

## 作者：installb (赞：8)

明显的博弈论  
看到$n,k \leq 10^9$ 差不多就是道结论题了  

所以...开始推结论吧~~反正比赛时候弄了好久~~  
对于博弈论，记住这句话:  
**能到达必败态的状态是必胜态，只能到达必胜态的状态是必败态**  

首先把题目转化 : 一堆石子有n个，每次可以取1个,2个或k个。  
直到有一方无法操作，无法操作的一方输  

假设状态为还剩下多少个石子  
那么0就是必败态  

**1.考虑只有1,2没有k的情况**  
状态$n$可以到达$n-1$和$n-2$  
1,2能到达0 所以为必胜态  
3只能到达1,2 所以为必败态  
以此类推 $3n$是必败态，$3n+1$和$3n+2$一定是必胜态 (n为非负整数)  

其实原理也很简单...把石子三个三个一堆分 石子总数不是三的倍数的话 Alice先把余下1/2个取走 接下来Bob取i个Alice就取3-i个 必胜  

否则Alice取i Bob就取3-i 最后Bob取完 Alice输

```cpp
// W=Win,L=Lose
0 123 456 789...
L WWL WWL WWL...
```

结论:n为3的倍数则负 否则胜  

**2.k不为3的倍数**  
k的出现使得对于所有必败态i,i+k都会成为必胜态  
但是 在只有1,2的情况下 对于任何必败态i 只有$i+3j$(j为非负整数)是必败态  
k不是3的倍数 所以没有影响  

```cpp
// W=Win,L=Lose
0 123 456 789...
L WWL WWL WWL...
```

结论:同1  

**3.k为3的倍数**  
这时候 第一个变化的是k k原来是必败态 现在由于k可以直接转移到0 k成为了必胜态  
这样使得原来的状态出现了一些改变  
k+1会因此变成必败态(1,k-1,k是必胜态)  

就像是这样:  
```cpp
012345............k.
LWWLWW...LWW...LWWWL
                   ^
                  k+1
```
由于每一个点i只能转移到$i-1,i-2,i-k$ 这个多出来的W 本质上对k+1到2k的情况没有影响,这一段的情况是和情况1,2中k到2k-1的情况是一样的  
(2k+1会受到k+1(L)的影响成为W 3k+2会受到2k+2(L)的影响成为W)  

这就相当于在原序列的k,2k,3k...的位置 在前面插入了一个W  

所以直接看作一个循环节为k+1的字符串...  
而在每一个循环节中 对应的Lose是0,3,6...,k-3 也就是除了k以外所有3的倍数  
其他都是Win  

**code:**
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <map>
using namespace std;
typedef long long LL;

LL n,m,k,T;
LL a[500005] = {0};

int main(){
	cin >> T;
	while(T --){
		cin >> n >> k;
		if(k % 3 != 0) cout << ((n % 3 == 0) ? "Bob" : "Alice") << endl;
        // 情况2
		if(k % 3 == 0){
			k ++;
            // (n % k) 是取出n在k的循环节中为第几位(从0开始)
			if((n % k) % 3 == 0 && (n % k) != k - 1) cout << "Bob" << endl;
			else cout << "Alice" << endl;
		}
	}
	return 0;
}
```

~~The End~~

---

## 作者：yuzhechuan (赞：6)

一道简单的博弈论题

[博客园](https://www.cnblogs.com/think-twice/p/11190574.html)

[CSDN](https://blog.csdn.net/qq_45404210/article/details/95947118)

---

首先让我们考虑没有k的情况：

### 1. (n mod 3 =0)

因为n可以被分解成若干个3相加

而每个3可以被分解为1+2或2+1

所以无论A出什么B都有方法应对

B胜

### 2. (n mod 3 =1)

A可以先选择余数1

这样问题又回到了第一种情况

AB角色互换

A胜

### 3. (n mod 3 =2)

与2同理，A先选2即胜

---

而现在多出来的这个k也可以看成是3的某个自然数倍数加上一个小于3的数

即$k\equiv x\left( mod3\right)$

我们再来对x分类讨论：

### 1. (x=0)

此时的k就好像快速地切除1+2或2+1的回合

但对手总不会站着不动吧？

我们知道B总是有方法使每一回合内(A+B)%3都等于1的

列举一下(k用3代替)：

A:1 B:3

A:2 B:2

A:3 B:1

是不是每回合在mod3意义下都是相同的？

那么若干个回合后如果无法实现上述方法了

即n%=k+1

如果n=k A获胜

否则情况又变回了无k的情况

%3判断即可

### 2. (x=1)

此时k就好像有着能省略若干个回合功能的1

k就可有可无了

又回到了无k的情况

### 3. (x=2)

与2同理

---

知道了这些，代码就很好写了：

```cpp
int n,k,t;
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&k);
		if(k%3){
			if(n%3) puts("Alice");
			else puts("Bob");
		}
		else{
			n%=k+1;
			if(n==k||n%3) puts("Alice");
			else puts("Bob");
		}
	}
}
```

---

## 作者：_violet (赞：3)

首先考虑不走k的情况，显然n%3==0时必败，其他情况必胜。

然后考虑k%3!=0的情况，这时候不会有一个原来的必败态因为走k步而到达另一个必败态，也就是说这时候k对胜负是没有影响的，可以直接认为k不存在，输赢和上面一样。

最后就是k%3==0的情况。这时候通过观察可以发现，0到n的胜负情况被划分成了一堆不相干的，长为k+1的小块，每个小块里的输赢情况不会被k影响，也就是说如果设n'为点n与块头的距离，则满足n'%3==0必败（n'==k除外）。

比如n=8,k=3时：(A赢B输)

0 1 2 3 | 4 5 6 7 | 8 9 10 11|
B A A A   B A A A   B A  A  A 

那我们就可以把n对(k+1)取模，然后直接判断就好了。

代码:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register
using namespace std;
template <class nmsl> inline void read(nmsl &x)
{
	x=0;
	char ch=getchar(), w=0;
	while(!isdigit(ch))w=(ch=='-'), ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	x=w?-x:x;
}
int T;
int a, b;
int main()
{
	read(T);
	while(T--)
	{
		read(a), read(b);
		if(b%3==0)a%=(b+1);
		if(a==b)printf("Alice\n");
		else
		{
			if(a%3==0)printf("Bob\n");
			else printf("Alice\n");
		}	
	}
	return 0;
}
```


---

## 作者：VinstaG173 (赞：2)

这道题算很简单的博弈论了。

首先如果$k$不是$3$的倍数，那么相当于经典的Bash博弈（取模$3$后可以看作只能取$1$个或$2$个）。

如果$k$是$3$的倍数，那么我们可以知道$SG(i)$与$SG(i+k+1)$肯定相等，因为如果在$i$之前都是$k+1$个一循环的话，由于$i+k+1$的后继状态不可能是与之关于$k+1$同余的，所以它的后继状态$SG$值集合与$i$的后继状态$SG$值集合是一样的，$SG$值也必定相等。

当$n \le k$时，易有$n=k$时$SG$值不为$0$，因为其后继状态有一个是$0$；$n$为其他$3$的倍数时$SG$值为$0$。

因此，当$k$是$3$的倍数时，有结论：当$n$模$k+1$的余数是$3$的倍数且不为$k$时，Bob胜；否则Alice胜。

Code:
```cpp
#include<cstdio>
int T,N,K;
int main()
{
	scanf(" %d",&T);
	while(T--)
	{
		scanf(" %d %d",&N,&K);
		if(K%3)
		{
			if(N%3)printf("Alice\n");
			else printf("Bob\n");
		}
		else
		{
			int t=N%(K+1);
			if(t==K||t%3)printf("Alice\n");
			else printf("Bob\n");
		}
	}
	return 0;
}
```

---

## 作者：ZCETHAN (赞：1)

[传送门](http://codeforces.com/contest/1194/problem/D)
## 题目大意
$n$ 个石子，一次可以取 $1,2$ 或 $k$ 个，两人轮流取，取到最后一个胜利，问谁有必胜策略。

## Solution
一眼巴什博奕。

如果没有可以取 $k$ 个这一条件，那么就是裸的博弈，那么我们来考虑可以取 $k$ 个这一条件对答案产生了什么影响。首先，我们做巴什博奕是利用了分组的思想，即以 $3$ 个为一组，如果我在一组中是后手，那么显然有必胜的策略。

那么如果取 $k$ 个，会对最后分组有什么影响呢？我们分两种情况考虑：

**Case1：$k$ 不是 $3$ 的倍数**

此时，如果我取一次 $k$ 其实相当于取了一次 $k\%3$。因为如果 $n\%3=0$，先手不可能通过取一次 $k$ 把石子取完，所以和取 $1$ 或 $2$ 没有什么区别。而如果 $n\%3\neq 0$，那么只需要先手把余数取掉，仍然必胜。

所以如果是 $k\%3\neq 0$，那么直接做巴什博奕就可以了。

**Case2：$k$ 是 $3$ 的倍数**

此时有个问题，如果取一次 $k$ 那么相当于交换了一次先后手，会对之后的决策造成极大的影响。此时不好思考，我们来考虑找找规律。

如果 $k=6$，则有如下胜负，$A$ 表示先手必胜，$B$ 表示后手必胜：

|n|0|1|2|3|4|5|6|7|8|9|10|$\cdots$|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|res|B|A|A|B|A|A|A|B|A|A|B|$\cdots$|

可以发现，结果是以 $k+1$ 为一个循环周期的。为什么会这样呢？因为在 $n=k$ 的时候，本来是后手必胜的，但现在是先手必胜，导致 $n=k+1$ 时后手必胜。同理，我们也可以列出 $k=9$ 的情况来看看：

|n|0|1|2|3|4|5|6|7|8|9|10|$\cdots$|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|res|B|A|A|B|A|A|B|A|A|A|B|$\cdots$|

果然是这个规律，我们已经找出了如何解决 $n\%3=0$ 时的情况：只需要将 $n$ 模上 $k+1$，然后判断余数是否是 $3$ 的倍数且不是 $k$，如果是，那么后手胜，否则先手胜。

## Code
```cpp
#include<bits/stdc++.h>
#define inf 1<<30
#define ll long long
#define INF 1ll<<60
using namespace std;
void solve(){
	int n,k;
	scanf("%d%d",&n,&k);
	if(k%3){
		if(n%3) puts("Alice");
		else puts("Bob");
	}else{
		int rem=n%(k+1);
		if(rem%3==0&&rem!=k) puts("Bob");
		else puts("Alice");
	}
}
int main()
{
	int T;
	for(scanf("%d",&T);T--;)
		solve();
}
```

---

## 作者：yyz_100110 (赞：0)

# [CF1194D 1-2-K Game 题解](https://www.luogu.com.cn/problem/CF1194D)

建议博客使用更佳。

## 题面：

有 $n (1\le n\le 10^9)$ 个东西，我们每次可以取出 $k(3\le k\le 10^9)$ 个东西。Alice 和 Bob 轮流取出，Alice 先手。谁最后一个取出就算失败，输出胜利的那个人的名字。有 $T(1\le T\le 100)$ 组数据，即 $T$ 个询问。

## 思路：

根据数据入手。

![](https://cdn.luogu.com.cn/upload/image_hosting/9dc9nhxl.png)

总结一下，以上的规律，发现与 $n$ 和 $k$ 他们跟 $3$ 的关系有关，横看竖看就可以总结出一下推论。

- 当 $k$ 为 $3$ 的倍数时：可以发现 $k+1$ 为一个周期，所以当 $n=k$ 时，先手必胜，则当 $n=k+1$ 时后手必胜。
- 当 $k$ 不为 $3$ 的倍数时：可以发现，当我取一次 $k$ 的时候等同于交换了先后手位置，如果 $n \bmod 3 = 0$ 取几颗都是赢的。如果 $n \bmod 3 \ne 0$ ，我们只需把它剩下来的余数取光即为胜利。

我们来举一个例子，来证明我们上方的推论。我们假如，$n=8$，$k=6$ 。那么此时根据上方推论，当 $k$ 为 $3$ 的倍数时，$6+1$ 为一个周期，可参照上表，此时 $n=k+2$，所以我们可以推断先手必胜，即 Alice。我们可以把 $n$ 改为 $7$，那么此时 $n=k+1$，这时后手就转败为胜，后手必胜，即 Bob 获胜。

我们再来举一个 $k$ 不为 $3$ 倍数的例子，从而确定推论的准确性。我们假设 $n=6$，$k=7$。这时我每取一次 $7$ 就相当于交换了前后手的位置，这时 $n \bmod 3 = 0$，所以我们无论取出几颗，都是必胜态，此时 Bob 获胜。当然如果此时我把 $n$ 改为 $5$，$5 \bmod 3 \ne 0$，此时，我们作为先手只需把剩下的余数，取光即为最优解，获胜者为 Alice。

上面举出的几个例子，经过我们的实验，推论是正确的，所以这时我们就可以构造代码了，其实代码部分并不难，我就发出来参考一下，推导的过程十分重要，一定要理解，博弈论一般计算必胜方法都需要运用到像这样的推算，这个对于我们的思维也是锻炼。

## Acode:

```cpp
#include<iostream>//没必要开万能头
using namespace std;
signed main(){
    int T;
    cin>>T;
    while(T--){//T 组数据
        int n,k;
        cin>>n>>k;
        if(k%3) 
            puts((n%3?"Alice":"Bob"));//三位运算符
        else{
            n%=k+1;//把n模为k+1，再去取他的余数
            puts((n%3||n==k?"Alice":"Bob"));//puts自带换行
        }
    }
return 0;
}
```

请勿抄袭代码。

奉上 [AC 记录](https://www.luogu.com.cn/record/123254290)

感谢管理员指出缺少对结论的重要证明。

---

## 作者：guozhetao (赞：0)

## 思路
这题其实就相当于[这道红题](https://www.luogu.com.cn/problem/SP31052)的强化版。

- 首先不考虑 $k$，很容易想到当 $n \bmod 3 = 0$ 时 `Bob` 赢（你取 $1$ 我就取 $2$，你取 $2$ 我就取 $1$），否则 `Alice` 赢（先把余数取了，你取 $1$ 我就取 $2$，你取 $2$ 我就取 $1$）。

- 接着考虑 $k \bmod 3 \not = 0$ 的情况。很明显，当 $k \bmod 3  = 1$ 时取 $k$ 就相当于取 $1$，当 $k \bmod 3  = 2$ 时取 $k$ 就相当于取 $2$。所以，此时有无 $k$ 影响不大，按照上一种方法输出即可。

- 当 $k \bmod 3  = 0$ 时，我们可以通过列举找规律。

| 当 $k = 3$ 时  | $n = 0$ | $n = 1$ | $n = 2$ | $n = 3$ |  $n = 4$|  $n = 5$|  $n = 6$| $n = 7$ | $n = 8$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 赢家 | `Bob` | `Alice` | `Alice` | `Alice` | `Bob` | `Alice` | `Alice` | `Alice` | `Bob` |


显而易见， $k + 1$ 次形成一个循环。我们将 $n \gets n \bmod (k + 1)$，

如果 $n = k$ （直接取走）或者 $n \bmod 3 \not = 0$，输出 `Alice`，否则输出 `Bob`。

## 代码
[AC](https://www.luogu.com.cn/record/98879283)
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<queue>
#include<map>
#include<algorithm>

using namespace std;

// 快读
inline int read() {
	int x = 0,f = 1;char ch = getchar();
	while (ch < '0' or ch > '9'){if (ch == '-') f = -1;ch = getchar();}
	while (ch >= '0' and ch <='9'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}
//快写
inline void write(int x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
	return;
}
//输出char
void writec(char x) {
	putchar(x);
	return;
}
int main() {
	int t = read();
	while(t--) {
		int n = read(),k = read();
		if(k % 3 != 0) {
			if(n % 3 != 0) printf("Alice\n");
			else printf("Bob\n");
		}
		else {
			n %= (k + 1);
			if(n == k||n % 3) printf("Alice\n");
			else printf("Bob\n");
		}
	}
    return 0;
}


```
## Update 
2023/01/09 提交审核

---


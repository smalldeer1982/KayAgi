# Twin Buildings

## 题目描述

一直以来，ICPC Jakarta 面临着空间不足的问题。为了应对这一挑战，他们计划建造两栋相同尺寸的矩形大楼。现在，他们需要找到合适的土地来进行建设。

有 $N$ 块土地待售。第 $i$ 块土地是一个大小为 $L_i \times W_i$ 的矩形。为了讲究风水，大楼的边必须与土地的边平行。

一种解决方案是分别在两块不同的土地上建造一栋大楼（它们的朝向可以不同）。一个 $A \times B$ 的大楼可以在第 $i$ 块土地上建造的条件是：

- $A \le L_i$ 且 $B \le W_i$，或者
- $A \le W_i$ 且 $B \le L_i$。

另外，也可以在同一块土地上建造两栋 $A \times B$ 大楼，且它们的方向相同。具体而言，想要在第 $i$ 块土地上建造两栋 $A \times B$ 的大楼，必须满足以下条件之一：

- $A \times 2 \le L_i$ 且 $B \le W_i$，或者
- $A \times 2 \le W_i$ 且 $B \le L_i$，或者
- $A \le L_i$ 且 $B \times 2 \le W_i$，或者
- $A \le W_i$ 且 $B \times 2 \le L_i$。

你的任务是帮助 ICPC Jakarta 找出在给定 $N$ 块土地的情况下，他们能建造的最大尺寸的大楼。必须确保建造两栋 $A \times B$ 的大楼；请输出最大可能的 $A \times B$ 面积。

## 说明/提示

样例输入/输出 #1 的解释：

在第一块土地上，可以建造两栋 $2.5 \times 5$ 的大楼。

样例输入/输出 #2 的解释：

在第一块和第二块土地上，各可以建造一栋 $2 \times 4$ 的大楼。

样例输入/输出 #3 的解释：

在第二块和第三块土地上，各可以建造一栋 $7 \times 6$ 的大楼。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
5 5
3 4
```

### 输出

```
12.5
```

## 样例 #2

### 输入

```
2
2 5
4 3
```

### 输出

```
8.0
```

## 样例 #3

### 输入

```
3
10 1
9 8
7 6
```

### 输出

```
42.0
```

# 题解

## 作者：skyskyCCC (赞：2)

## 前言。
随便点题跳出来的，看到题解区有空缺，就立马造福群众。

题意简述如下：  
给出 $n$ 个矩形土地，每个土地有长 $x_i$ 和宽 $y_i$ 两个属性。我们要建**两座**房子，其中两座房子的边必须和土地的边平行且边长对应相等，要求房子的面积最大。可以将一个土地分成两半一边一个。请求出最大面积，保留一位小数。
## 分析。
首先我们发现，对于一个矩形，我们可以将它分成两个完全相等的小矩形，取中点即可。所以答案一定 $\geq\max_i\{x_i\times y_i\}$ 然后就解决了相同矩形的情况。

接下来考虑两个不同矩形的情况。对于任何两个矩形 $i$ 矩形和 $j$ 矩形，答案就是 $\max(\min(x_i,x_j)\times\min(y_i,y_j),\min(x_i,y_j)\times\min(x_j,y_i))$ 的式子。考虑化简它，我们不妨令 $\min(x_i,x_j,y_i,y_j)=x_i$ 然后代入上式。因为这四个数中 $x_i$ 最小，所以换为 $\max(x_i\times\min(y_i,y_j),x_i\times\min(x_j,y_i))$ 的简单形式，提出 $x_i$ 即得 $x_i\times\min(y_i,\max(x_j,y_j))$ 这里读者不妨自己推导一下。

考虑到 $x\times y$ 的矩形和 $y\times x$ 的矩形完全相同，所以我们可以让所有的 $x_i\leq y_i$ 得到 $\max(x_j,y_j)=y_j$ 从而进一步化简以上的式子为 $x_i\times\min(y_i,\max(x_j,y_j))=x_i\times\min(y_i,y_j)$ 的最简形式。

很明显，我们将矩形按 $a_i$ 升序排列，然后对于所有的 $i<j$ 因为 $x_i\leq y_i$ 所以 $\min(x_i,x_j,y_i,y_j)=x_i$ 的情况一定存在。那么我们只需要在枚举过程中去维护 $\min\{y_j\}$ 即可。

简单来说，就是按照岛的**最长边**进行排序，前面的一定可以包括后面的，这样只需要考虑宽就好了。

这个题注意注意精度，就是输出的格式，笔者在这一方面卡了很久，最终进行直接输出解决了。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
ll n;
ll ans,maxx;
struct node{
	ll x,y;
}a[100005];
bool cmp(node a,node b){
	return a.y>b.y;
}
int main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		ans=max(ans,a[i].x*a[i].y);
		if(a[i].x>a[i].y){
			swap(a[i].x,a[i].y);
		}
	}
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=n;i++){
		ans=max(ans,min(maxx,a[i].x)*a[i].y*2);
		maxx=max(maxx,a[i].x);//套公式。
	}
	(ans%2)?printf("%lld.5\n",ans/2):printf("%lld.0\n",ans/2);
	return 0;//判断一下然后输出。
}
```
同时笔者在写此篇题解时，突然想到一种新做法：建立一个坐标系，将所有土地的长的边假设在 $x$ 轴上。然后找最大的重叠面积，即覆盖面积 $\geq 2$ 的，就是不同矩形的最大值。最后和最大的单独的土地，即把一个矩形分成两份，比较一下，取最大值即可。

这个也许可以用线段树和扫描线维护，但是笔者写挂了，如果有人能写出来可以在评论区里踢笔者一下。
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---


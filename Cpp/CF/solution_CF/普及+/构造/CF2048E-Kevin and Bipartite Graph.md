# Kevin and Bipartite Graph

## 题目描述

武器工厂需要一种海报设计模式，并向 Kevin 求助。

海报设计模式是一个二分图，左半部分有 $2n$ 个顶点，右半部分有 $m$ 个顶点。左半部分的每个顶点与右半部分的每个顶点之间都有一条边，总共形成 $2nm$ 条边。

Kevin 必须用范围在 $[1, n]$ 内的正整数为每条边着色。如果二分图中没有单色环（所有边颜色相同的简单环），则该海报设计模式是良好的。

Kevin 需要你的帮助来构造一个良好的二分图，或者在不可能的情况下通知他。

**单色环**：指所有边颜色都相同的简单环。

## 说明/提示

对于第一个测试用例，图形如下所示：

对于第二个测试用例，可以证明没有有效的解决方案。

## 样例 #1

### 输入

```
3
2 2
3 7
5 4```

### 输出

```
YES
1 2
2 1
2 2
2 1
NO
YES
1 1 1 1
1 2 2 2
1 2 3 3
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4```

# 题解

## 作者：Little09 (赞：2)

图总共有 $2nm$ 条边，而每种颜色构成一个森林，因此对于一种颜色最多存在 $2n+m-1$ 条边，那么总边数一定不超过 $(2n+m-1)n$。于是得到条件：$(2n+m-1)n\ge 2nm$，化简得 $m\le 2n-1$。

接下来我们只需构造出 $m=2n-1$ 的情况即可解决本题。

事实上容易构造，由于每个右部点的度数为 $2n$，且颜色总数为 $n$，令每种颜色的边恰好 $2$ 条。则对于每个颜色而言，相当于选择两个左部点使其联通（我们忽略右部点的存在），最后经过 $2n-1$ 次连接，左部点需要形成树。可以发现只需要将左部点连成链即可，构造时只需要循环移动第一个右部点的颜色。例如对 $n=4,m=7$ 的情况，形如：

```
1 4 4 3 3 2 2
1 1 4 4 3 3 2
2 1 1 4 4 3 3
2 2 1 1 4 4 3
3 2 2 1 1 4 4
3 3 2 2 1 1 4
4 3 3 2 2 1 1
4 4 3 3 2 2 1
```

因此一种简单的构造方法是对于左部点 $i$ 和右部点 $j$，其连边的颜色为：
$$
\lfloor\dfrac{(i+j)\bmod 2n}2\rfloor+1
$$

---

## 作者：bsdsdb (赞：1)

题意：一个完全二分图，左部有 $2n$ 个点，右部有 $m$ 个点，给每个边染上 $[1,n]$ 的颜色，使得没有同色简单环。

提示：

1. 如图情况：

  ![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i733mnan)

  点集 $[1,4]$ 中的点两两不能向同一个右部点连黑边。当 $[1,4]$ 中的点向 $D$ 连黑边后，这个点集变成了 $[1,5]$。你发现了什么？

2. 考虑左部点每个颜色建个图，思考「两个点是否在同一个连通分量中」与「两个点是否能向某右部点连这个颜色的边」的关系；
3. 有解时 $m$ 的上界？为什么 $m$ 再多一点就无解了？
4. 怎么样用相同的边数贡献尽量少的连通分量变化量？

下文记「左部 $i$ 号点」为 $A_i$，右部为 $B_i$。（提示 1，2 解答）考虑对目前已确定颜色的边的情况建一些图 $\{G_n\}$，其中 $G_i:=(V_i=A_{[1,2n]},E_i=\bigcup_{j=1}^m\operatorname{st}(C_{i,j})),C_{i,j}:=\{A_x\mid c(A_x,B_j)=i\}, \operatorname{st}(S):=\text{edge set of a spanning tree of }(S,S^2)$，例如图示情况有 $G_1=([1,5],\{(1,2),(2,3),(2,4)\})$。那么如果 $A_u,A_v$ 在 $G_i$ 的同一个连通分量中，则他们不能再向同一个 $B_j$ 连 $i$ 颜色的边，不然就出现一个 $i$ 颜色的环了。$G_i$ 一定是森林，因为如果有环，那么一定在原图中有个 $i$ 颜色的同色环。

（提示 3 解答）不妨设所有边的颜色中最多的是 $1$，则根据抽屉原理至少有 $\lceil\frac{2nm}{n}\rceil=2m$ 个边是 $1$ 色。令 $d_{i,j}$ 表示连到 $B_j$ 的 $i$ 颜色的边数，则 $G_1$ 的边数根据定义等于 $\sum_{j=1}^m\max(0,d_{1,j}-1)\ge \sum_{j=1}^md_{1,j}-m\ge 2m-m=m$。当该值等于 $2n-1$ 时，不能再新增任何的同时连连两个左部的右部点。因此 $m$ 最多只能到 $2n-1$。

（提示 4 解答）接下来进行构造，使得原图的 $4n-2$ 个 $1$ 色边能使得 $G_1$ 只有 $2n-1$ 个边。

![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/m4s5b99t)

每两个边贡献 $G_1$ 的一个边。其他颜色将左部点位移 $2$ 轮换即可。具体的，$c(A_i,B_j)=\lfloor\frac{(i-j+2n)\bmod 2n}{2}\rfloor+1$。

---

## 作者：_lmh_ (赞：1)

考虑找出 $m$ 的上界。$n$ 种颜色，每种颜色最多连 $2n+m-1$ 条边（形成一棵树），也就是说 $n(2n+m-1)\ge 2nm$，可得 $m\le 2n-1$。

设左边的点为 $P_1 \sim P_{2n}$，右边的点为 $Q_1\sim Q_m$，考虑以下构造方案。

先构造颜色 $1$ 的边，对所有的 $1<i\le m$ 连 $P_i\to Q_i\to P_{i+1}$，最终形成一条链。

对于之后的颜色，考虑将上一条链中 $P_x$ 的下标全部 $-2$，形成一条新链。对于每个 $Q$，它连接的都是新的两个 $P$ 点，因而 $n$ 种颜色恰好能完成任务。

![](https://cdn.luogu.com.cn/upload/image_hosting/qj6thkhe.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1007;
ll T,n,m,ans[N<<1][N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>m;
		if (2*n<=m) cout<<"NO\n";
		else{
			cout<<"YES\n";
			for (int i=1;i<=m;++i){
				int k=i;
				for (int j=1;j<=n;++j){
					ans[k][i]=ans[k+1][i]=j;
					if (k==2*n) ans[1][i]=j;
					k+=2;
					if (k>2*n) k-=2*n;
				}
			}
			for (int i=1;i<=2*n;++i){for (int j=1;j<=m;++j) cout<<ans[i][j]<<' ';cout<<'\n';}
		}
	}
	return 0;
}
```

---

## 作者：黑白丿殊梦 (赞：0)

# E. Kevin and Bipartite Graph

## 思路

根据题意可知，一种颜色的边必须形成一棵树，那么一种颜色最多可以染色 $2n+m-1$ 条边，$n$ 种颜色最多可以染色 $n(2n+m-1)$ 条边。题目要求总共有 $2nm$ 条边，那么 $n(2n+m-1) \geq 2nm$ 时，才有解，化简得到 $m \leq 2n-1$。

现在考虑 $m = 2n-1$，如果可以构造出这种情况，那么本题就解决了。

在这种情况下，$n(2n+m-1) = 2nm$，也就是说构造出 $n$ 棵树，每棵树使用一种颜色，树与树之间不联通。尝试构造一条链，这样比较容易。

由于右边的每个点度数都为 $2n$，共有 $n$ 种颜色，那么对于每个右部点：每种颜色必须分配两条边。也就是：**每个点的每个颜色联通左边的两个点和右边的一个点**形成如图所示的一条子链：
![](https://cdn.luogu.com.cn/upload/image_hosting/i1tuea6d.png)

由于要形成包含所有节点的链，那么子链之间必须联通，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/n2q0mg85.png)

考虑第二种颜色，根据**每个点的每个颜色联通左边的两个点和右边的一个点**，只能这样构造：

![](https://cdn.luogu.com.cn/upload/image_hosting/z8rkxvan.png)

再联通其他点：

![](https://cdn.luogu.com.cn/upload/image_hosting/573tromy.png)

记得联通最上面的两个点，为了看起来明显，将上面的点挪下来：

![](https://cdn.luogu.com.cn/upload/image_hosting/t5nexk9b.png)

可以归纳出构造方案：令 $k$ 从 $1$ 到 $n$ 枚举每种颜色。对于当前第 $k$ 种颜色，令左部点 $i=2k-1$，依次处理右部点 $j$ 从 $1$ 到 $n$。对于当前 $j$，连接 $j$ 与 $i$、$j$ 与 $i+1$ 即可，之后更新 $i=i+1$，如果$i>2n$，令 $i=1$。

## 代码实现

```cpp
void solve(){
    int n, m;  cin >> n >> m;
    if(m > n * 2 - 1) {
        cout << "NO\n";
        return;
    }
    vector a(n * 2 + 1, VI(n * 2));
    for(int k = 1; k <= n; k ++) {  //对于每一种颜色
        int i = k * 2 - 1, j = 1;
        while(j <= n * 2 - 1) {
            a[i][j] = k;
            if(i + 1 > n * 2) a[1][j] = k;
            else a[i + 1][j] = k;
            i ++, j ++;
            if(i > n * 2) i = 1;
        }
    }
    cout << "YES\n";
    for(int i = 1; i <= n * 2; i ++)
        for(int j = 1; j <= m; j ++)
            cout << a[i][j] << " \n"[j == m];
}
```

---


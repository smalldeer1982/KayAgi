# Kevin and Binary String (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本的区别在于此版本中字符串 $ t $ 仅由 '0' 和 '1' 组成。只有当您解决了该问题的所有版本后才能进行 hack。

Kevin 有一个长度为 $ n $ 的二进制字符串 $ s $。Kevin 可以执行以下操作：

- 选择 $ s $ 中两个相邻的块并交换它们。

块是指由相同字符组成的最大子串$ ^{\text{∗}} $。形式化定义：设 $ s[l,r] $ 为子串 $ s_l s_{l+1} \ldots s_r $。当满足以下条件时，$ s[l,r] $ 构成一个块：
1. $ l=1 $ 或 $ s_l \neq s_{l-1} $；
2. $ s_l = s_{l+1} = \ldots = s_r $；
3. $ r=n $ 或 $ s_r \neq s_{r+1} $。

相邻块是指两个块 $ s[l_1,r_1] $ 和 $ s[l_2,r_2] $ 满足 $ r_1 + 1 = l_2 $。

例如，若 $ s = \mathtt{000}\,\mathbf{11}\,\mathbf{00}\,\mathtt{111} $，Kevin 可以选择块 $ s[4,5] $ 和 $ s[6,7] $ 进行交换，将 $ s $ 变为 $ \mathtt{000}\,\mathbf{00}\,\mathbf{11}\,\mathtt{111} $。

给定一个由 '0'、'1' 和 '?' 组成且长度为 $ n $ 的字符串 $ t $，Kevin 希望确定使对于所有索引 $ i $（$ 1 \le i \le n $），若 $ t_i \neq $ '?' 则 $ s_i = t_i $ 所需的最小操作次数。若无法实现，输出 $ -1 $。

$ ^{\text{∗}} $ 若字符串 $ a $ 可通过从 $ b $ 的开头和结尾删除若干（可能为零或全部）字符得到，则称 $ a $ 是 $ b $ 的子串。

## 说明/提示

第一个测试用例的可能操作方式已在题目描述中展示。

第二个测试用例中，一种可能的操作方式为：
1. 交换块 $ [2, 2] $ 和 $ [3, 3] $，$ s $ 变为 $ \mathtt{001101} $；
2. 交换块 $ [3, 4] $ 和 $ [5, 5] $，$ s $ 变为 $ \mathtt{000111} $；
3. 交换块 $ [1, 3] $ 和 $ [4, 6] $，$ s $ 变为 $ \mathtt{111000} $。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
0001100111
0000011111
010101
111000
0101
0110
0101
1010
011001
001110
0
1```

### 输出

```
1
3
1
-1
-1
-1```

# 题解

## 作者：yvbf (赞：1)

![](bilibili:BV1MuwverEdQ?t=3212)

---

## 作者：Iniaugoty (赞：0)

### [CF2061F1 Kevin and Binary String (Easy Version)](/problem/CF2061F1)

~~这玩意儿建议评橙，可以黄，最多绿，不能再高了。~~

核心的性质是显然的，连续段长度只会不断变长。

于是不难发现求最小操作数其实是假的，方案本质上是唯一的，流程就是简单地将 $s$ 的好几段 $\texttt 0$ 或 $\texttt 1$ 通过操作合并成一段 $\texttt 0$ 和一段 $\texttt 1$。

所以直接模拟即可。

进行一个类似增量法的过程，已经将 $s _ {i - 1}$ 之前的和 $t$ 操作到相同，不妨认为当前 $t _ i = \texttt 1$，$s _ i = \texttt 0$（反过来是一样的）。

若 $i > 1$，$s _ {i - 1} = t _ {i - 1} = \texttt 0$。不难发现此时是无解的，因为操作只会让连续段的长度不断变长，在保证 $s _ {i - 1} = \texttt 0$ 及其前面不变的情况下 $s _ i$ 一定还是 $\texttt 0$。

否则，找到 $t _ i$ 所在段的右端点 $j$，则 $t$ 的 $[i, j]$ 全为 $1$，此时需要 $j - i + 1$ 个 $\texttt 1$ 来填进 $s$ 的 $[i, j]$。

暴力找到一个最小的 $k$ 使得 $s$ 的 $[i, k]$ 中有恰好 $j - i + 1$ 个 $\texttt 1$。

若 $[i, n]$ 中 $\texttt 1$ 的个数都不足 $j - i + 1$ 就是找不到这样的 $k$ 则无解。

若 $k < n$ 且 $s _ {k + 1} = \texttt 1$ 也无解，这时 $s _ k$ 和 $s _ {k + 1}$ 在一个段中，无法单独把 $s _ {k}$ 拉到前面。

然后就可以愉快地进行操作啦。设 $s$ 的 $[i, k]$ 中有 $cnt$ 个 $\texttt 1$ 的连续段，则需要 $cnt$ 次操作才能把 $\texttt 1$ 全都搬到前面，$ans \gets ans + cnt$。

然后暴力地处理这些操作的影响，就是把 $s$ 的 $[i, j]$ 改成 $\texttt 1$，把 $[j + 1, k]$ 改成 $\texttt 0$。

容易发现时间复杂度是均摊线性，[代码](https://codeforces.com/contest/2061/submission/302114855)。

---


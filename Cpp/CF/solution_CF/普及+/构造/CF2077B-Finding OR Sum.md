# Finding OR Sum

## 题目描述

[ALTER EGO - Yuta Imai vs Qlarabelle](https://www.youtube.com/watch?v=LJEqM7pvClA)

这是一道交互题。

存在两个隐藏的非负整数 $x$ 和 $y$（$0 \leq x, y < 2^{30}$）。你最多可以提出 2 次以下形式的询问：

- 选择一个非负整数 $n$（$0 \leq n < 2^{30}$）。评测系统将返回 $(n \mathbin{|} x) + (n \mathbin{|} y)$ 的值，其中 $|$ 表示[按位或运算](https://en.wikipedia.org/wiki/Bitwise_operation#OR)。

此后，评测系统将给出另一个非负整数 $m$（$0 \leq m < 2^{30}$）。你必须正确回答 $(m \mathbin{|} x) + (m \mathbin{|} y)$ 的值。

## 说明/提示

### 示例交互

在第一个测试中，交互过程如下：

| 解决方案输出 | 评测系统输出 | 说明 |
|--------------|--------------|------|
| `2`          |              | 共有 2 个测试用例 |
|              |              | 第一个测试用例中 $x=1$ 且 $y=2$ |
| `0`          |              | 解决方案询问 $(0 \mathbin{\|} 1) + (0 \mathbin{\|} 2)$ |
|              | `3`          | 评测系统返回 3 |
| `1`          |              | 解决方案询问 $(1 \mathbin{\|} 1) + (1 \mathbin{\|} 2)$ |
|              | `4`          | 评测系统返回 4 |
| `!`          |              | 解决方案请求 $m$ 的值 |
|              | `1`          | 评测系统返回 $m=1$ |
| `4`          |              | 解决方案根据先前询问得知 $(1 \mathbin{\|} x) + (1 \mathbin{\|} y)=4$ |
|              |              | 第二个测试用例中 $x=0$ 且 $y=0$ |
| `0`          |              | 解决方案询问 $(0 \mathbin{\|} 0) + (0 \mathbin{\|} 0)$ |
|              | `0`          | 评测系统返回 0 |
| `!`          |              | 解决方案请求 $m$ 的值 |
|              | `1`          | 评测系统返回 $m=1$ |
| `2`          |              | 解决方案推断出 $x=y=0$，因此返回 $(1 \mathbin{\|} 0) + (1 \mathbin{\|} 0)=2$ |

注意示例输入输出中的空行仅为清晰展示，实际交互中不会出现。

注意示例输入输出中的空行仅为清晰展示，实际交互中不会出现。

## Hacks

要发起 hack，请遵循以下测试格式：

第一行包含测试用例数量 $t$（$1 \le t \le 10^4$）。接下来描述每个测试用例。

每个测试用例的第一行且唯一一行包含三个整数 $x, y, m$（$0 \leq x, y, m < 2^{30}$）。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2

3

4

1

0

1```

### 输出

```
0

1

!

4

0

!

2```

# 题解

## 作者：chenxi2009 (赞：3)

## 思路

考虑一次询问 $n$，由于任何数和 $n$ 取或的结果中 $n$ 为 $1$ 的位上也一定为 $1$，回答减去这些位上的值才是能反映 $x$ 和 $y$ 值的部分，即 $\text{reply}-2n$。

钦定表示 $2^i$ 的二进制位为第 $i$ 位，$x$ 的第 $i$ 位表示为 $x_i$。\
然后可以发现 $n$ 为 $0$ 的位中，$x$ 和 $y$ 为 $1$ 时会产生对应位大小的贡献（第 $i$ 位为 $2^i$）到答案上，即：

$$
\text{reply}-2n=\sum_{i=0}^{29}[n_i=0]\times([x_i=1]+[y_i=1])\times2^i
$$
分类讨论一下，在有效位上，$x_i=0$ 且 $y_i=0$ 则对答案没有贡献；有一个为 $1$ 则对答案此位有 $1$ 的贡献（即 $2^i$）；如果 $x_i$ 和 $y_i$ 都为 $1$，则对答案的下一位有 $1$ 的贡献（$2^{i+1}$）。

我们发现一个有效位上 $x_i,y_i$ 可能会影响答案的相邻两位，所以让一次询问有效位不相邻，即间隔出现，所以第一次询问 $n_1\leftarrow(10101010\cdots10)_2=715827882$（共 $30$ 位），为 $0$ 的位是偶数位，如果 $\text{reply}-2n_1$ 在一个偶数位上为 $1$，那么 $x$ 在这一位上为 $1$，$y$ 在这一位上为 $0$（也可以倒过来，在回答需要的信息中是等价的）。\
如果 $\text{reply}-2n_1$ 在一个偶数位的下一位上为 $1$，则在这个偶数位上 $x_i=y_i=1$。\
如果 $\text{reply}-2n_1$ 的一个偶数位和它的下一个奇数位均为 $0$，说明 $x$ 和 $y$ 在这一位上都为 $0$。

同理，第二次询问 $n_2\leftarrow(01010101\cdots01)_2=357913941$，$x_i,y_i$ 值由 $\text{reply}-2n_2$ 的对应奇数位和下一位确定。

最后用得到的 $x$、$y$ 和 $m$ 算出答案就行了。时间复杂度 $O(t\log x)$。
## 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int T,x,y,n1 = 715827882,n2 = 357913941,r,m;//预处理出两次询问内容 
inline void flush(){fflush(stdout);}
inline void qry(int x){printf("%d\n",x),flush();}
int main(){
	T = read();
	while(T --){
		x = y = 0;
		qry(n1);//这一次询问偶数位（1，4，16...）为有效位 
		r = read() - 2 * n1;
		for(int i = 0;i < 30;i += 2){//每一个偶数位 
			if(r & (1 << i)) x += (1 << i);//答案此位为 1 说明 x 与 y 中有一个为 1 
			if(r & (1 << i + 1)) x += (1 << i),y += (1 << i);//答案下一位为 1 说明 x 与 y 都是 1 
		}
		qry(n2);//这次询问管奇数位 
		r = read() - 2 * n2;
		for(int i = 1;i < 30;i += 2){
			if(r & (1 << i)) x += (1 << i);
			f(r & (1 << i + 1)) x += (1 << i),y += (1 << i);
		}
		printf("!\n"),flush();
		m = read();
		printf("%d\n",(m | x) + (m | y)),flush();
	}
	return 0;
}
```

---

## 作者：zh1221_qwq (赞：2)

宣一下[博客园](https://www.cnblogs.com/zh1221-qwq)

### 题意

这是一道交互题，交互库里有三个数 $x,y,m<2^{30}$。

你可以向交互库查询两次，一次查询给出一个数 $k$，交互库会返回一个值为 $(x|k)+(y|k)$。

最后交互库将给出 $m$，你需要输出 $(x|m)+(y|m)$。

### 做法

我们发现，当 $m$ 的第 $i$ 位是 $1$ 时，$x|m$ 和 $y|m$ 第 $i$ 位都是 $1$，而 $m$ 的第 $i$ 位是 $0$ 时，$x|m$ 的第 $i$ 位就是 $x$ 的第 $i$ 位，$y$ 同理。

所以说我们最后的答案可以按照每一位来求，若 $m$ 在第 $i$ 位上是 $1$，$ans=ans+2^i$，否则 $ans=ans+2^{i-1}\times (x_{i}+y_{i})$

注：$x_i$ 表示 $x$ 的第 $i$ 位，$y$ 同样的。

但是程序给我们返回的是 $(x|m)+(y|m)$，而不是 $(x|m)$，这样两位加起来是 $0$ 可能是两个 $1$ 也可能是两个 $0$，而且后面的位还有可能进位过来。

那咋办呢？

我们需要消除掉进位的影响。

我们发现他给我们的限制次数是 $2$ 次，启发我们奇偶位分开做。

我们考虑一个 $01$ 交替的串。

$10101\dots 0101$。

我们为了方便描述以及理解，我们先假设值域是 $2^{10}$。

即考虑 

$\space\space 101010101$

则根据最开始的推理，他的和已经确定的是 （每一位已对齐）

$1010101010$

![](https://cdn.luogu.com.cn/upload/image_hosting/09o02s8n.png)

注：上面的那个数是 $k$。

我们将上图中的红色部分一起考虑。

对于每一个红色部分的后一位，若 $x$ 在那一位上是 $1$，则整个红色部分也要加 $1$，$y$ 同理。

而且对于每个红色部分的前一位，他在 $k$ 中本来就是 $1$，不受 $x$、$y$ 影响。

这样的话每一个红色部分的值就只有三种：$01$、$10$、$11$，且每一种取值都不会进位到上一个红色部分。

通过这样的构造，我们就能知道红色部分后面的那一位即偶数位的 $x_i+y_i$。

同样的，我们构造 $10101010$ 来解决奇数位。

这里有一个要注意的点，就是 $10101010$ 加起来后是 $101010100$，第一位上的数是 $00$ 不是 $01$，要特判一下。

那这样我们就通过两次查询获得了每一位上 $x$、$y$ 的和了，再通过开始时的式子即可求解。

复杂度 $\mathcal O(T\log V)$。

#### 核心代码
```cpp
int a[32];
void sl(){
	int x=715827882,y=715827882/2;
	cout<<x<<endl;
	fflush(stdout); 
	int sum1;
	cin>>sum1;
	cout<<y<<endl;
	fflush(stdout);
	int sum2;
	cin>>sum2;
	for(int i=28;i>=0;i-=2){
		a[i]=(sum1/(1<<i))%4-1;
	}
	for(int i=29;i>=1;i-=2){
		a[i]=(sum2/(1<<i))%4-1;
	}
	cout<<"!"<<endl;
	fflush(stdout);
	int m,ans=0;
	cin>>m;
	a[0]++;
	for(int i=0;i<30;i++){
//		cout<<a[i]<<" "; 
		if(m&(1<<i)){
			ans+=(1<<i)*2;
		}
		else ans+=(1<<i)*a[i];
	}
	cout<<ans<<endl;
	fflush(stdout);
}
```

---

## 作者：Eous (赞：1)

[差不多的阅读体验](https://www.cnblogs.com/Eous/articles/18765078)

## 题意

这是一道交互题。

SPJ 有两个你初始未知的数 $x,y$，你可以进行最多两次的询问，每次询问，你向标准输出给出一行一个整数 $n$，SPJ 从标准输入返回一行一个值代表 $(n \mathbin{|} x) + (n \mathbin{|} y)$。其中 $|$ 代表按位或。在进行完至多两次的询问后，你需要向标准输出给出一行一个字符 `!`，然后 SPJ 会从标准输入返回一行一个值 $m$，你需要输出 $(m \mathbin{|} x) + (m \mathbin{|} y)$。有多测。

## 题解

我们看到两次询问，每次询问都得获得一半的信息。我们考虑第一次询问的值是 `0x2AAAAAAA`。转换成二进制就是 `0b101010...10`。我们可以从中获得 $x$ 和 $y$ 的第 $0,2,4...$ 位的信息。由于 `0b101010...10` 不管按位或 $x$ 还是 $y$，或完的结果都是 `0b1?1?1?...1?`，第 $1,3,5...$ 位的值都是 $1$，我们可以减掉 `0b101010...10`，以获得裸的 $x,y$ 的偶数位上的信息。而因为返回的答案是 $(n \mathbin{|} x) + (n \mathbin{|} y)$，所以需要减两次。减完的就是只保留了第 $0,2,4...$ 位的 $x,y$ 相加。

我们把减完的答案设为 $a_1$，考虑到如果 $x,y$ 在该位上的值可能都是 $1$，从而导致进位，所以我们考虑把在二进制下的 $a_1$ 两位两位分成一组，第 $0,1$ 位是一组，第 $2,3$ 位是一组。我们考虑一组里的两位。很显然只会有三种情况：`00`，`01`，`10`。那么三种情况分别对应 $x,y$ 在该位都是 $1$，有一个是 $1$，两个都是 $1$。第二次询问 $n$ 是 `0x15555555`，如法炮制，我们就可以获得第 $1,3,5...$ 位的信息。这样我们就可以求出 $x,y$ 的具体值。

那有人要问了：有一个是 $1$ 怎么搞？我又不知道那个是 $1$。其实无所谓。我们最终要求的 $(m \mathbin{|} x) + (m \mathbin{|} y)$。考虑 $m$ 这位是 $0$。那么显然，无论这个 $1$ 给 $x$ 或是 $y$，$x \mathbin{|} m$ 和 $y \mathbin{|} m$ 在那一位上的和也还是 $1$。对于 $m$ 那一位是 $1$，那就更无所谓了，因为无论是啥或上 $1$ 都是 $1$。

## 代码

```cpp
#include<bits/extc++.h>
#define int long long
using namespace std;
const int q1 = 0x2aaaaaaa,q2 = 0x15555555;
int a1,a2,x,y,m;
void solve()
{
    cout << q1 << endl;
    cin >> a1;
    a1 -= q1 * 2;// 减去询问的 n，得到裸的信息
    cout << q2 << endl;
    cin >> a2;
    a2 -= q2 * 2;
    x = y = 0;// 记得清空
    for (int i = 0; i < 30; i++)
    {
        int tmp = i & 1 ? a2 : a1;
        // 对于奇数位，我们获得的信息是 a1，偶数位就是 a2
        if (tmp & (1 << i))// 如果是 01 的情况
            x |= (1 << i);// 只有一个 1
        else if (tmp & (1 << (i + 1)))// 00 或者 10 时，判断是 00 还是 10
        {// 如果是 10 就是 x,y 都是 1，反之都是 0
            x |= (1 << i);
            y |= (1 << i);
        }
    }
    cout << '!' << endl;
    cin >> m;
    cout << (m | x) + (m | y) << endl;
}
signed main()
{
    int t;
    cin >> t;
    while (t--)
        solve();
    return 0;
}
```

---

## 作者：Priestess_SLG (赞：0)

Sol $1$. 用 $O(\log n)$ 次询问计算答案。

首先肯定要询问一下 $0$，此时可以求得 $x+y$ 的值。然后对于每一个二进制位 $i$ 询问 $2^i$ 的值。此时设回答的值为 $o$，则：

+ 若 $x+y=o$，则此时 $x,y$ 二进制第 $i$ 位都没有改变，那么 $x,y$ 二进制下第 $i$ 位的值都为 $1$。
+ 若 $o-x-y=2\times 2^i$，则此时 $x,y$ 二进制下的第 $i$ 位的值都必须改变，那么 $x,y$ 二进制下第 $i$ 位的值都为 $0$。
+ 否则必有 $o-x-y=2^i$，则此时 $x,y$ 二进制下的第 $i$ 位的值恰有一个是 $1$。因为 $x,y$ 每一位的值互相独立且其实并不需要知道其值具体是多少，因此钦定此时 $x$ 第 $i$ 位为 $1$，$y$ 第 $i$ 位为 $0$。

然后直接把 $x,y$ 和答案计算起来即可，询问此时为 $31$ 即 $O(\log n)$。

Sol $2$. 用 $3$ 次询问计算答案。

询问 $0$ 的步骤看上去不太能省，因此考虑优化对每一个二进制位的询问。考虑为什么不能把所有二进制位一起询问即询问 $2^{30}-1$。很显然这样的话 $o-x-y=2\times 2^i$ 的情况是困难区分的，可能会和其上一位恰有一个 $1$ 的情况混淆。因此考虑隔一个位询问一个 $1$，这样每一次拿出二进制中相邻两个位的值讨论，这个值必然是 $0,1,2$ 中的一个。因此只需要再询问两次，分别为 $(010101\ldots0101)_2$ 和 $(101010\ldots1010)_2$。

Sol $3$. 用 $2$ 次询问计算答案。

看上去 Sol $2$ 已经很优秀了，考虑还有哪里可以优化。发现若询问 $(111\ldots111)_2$ 的值，那么不论 $x,y$ 的值如何取，答案是可以直接计算出的，就是 $2\times(2^{30}-1)$。然后又可以发现 Sol $2$ 中两次非 $0$ 询问的每一个位都不同，因此我们设第一次非 $0$ 询问的值为 $a$，第二次非 $0$ 询问的值为 $b$，$0$ 询问的值为 $x$，$t=2\times(2^{30}-1)$。则此时根据容斥原理必有 $a+b-x=t$。询问 $a,x$ 的值，而 $t$ 的值为定值，可以直接解得 $b$ 的值。因此此时只需要询问 $2$ 次，可以通过问题。

讲的可能很混乱，建议结合 [代码](https://codeforces.com/contest/2078/submission/309858212) 理解。顺便提醒一下，注意一下位运算的时候的细节，不要因为少加一个 $1$ 调试 1h（

---

## 作者：yzljy (赞：0)

## 前言

场上被 C 题卡住了，考完第二天一看，这么简单……$30$ 分钟不到就切了……  
难度是 $2058$，个人感觉很简单，建议评绿。

## 题意

有两个未知数 $x$ 和 $y$，你现在可以进行至多 $2$ 次询问，每次询问任选一个整数 $n(0\le n<2^{30})$，询问的结果为 $(n|x)+(n|y)$ 的值。最后会给定一个数 $m$，你需要输出 $(m|x)+(m|y)$ 的值。

## 思路

首先我们知道，若 $x$ 的某一位二进制位为 $0$，而 $y$ 的这一位为 $1$，不妨令这一位为 $i$，那么 $(x|n)+(y|n)=\left((x+2^{i})|n\right)+\left((y-2^{i})|n\right)$ 因此能满足条件的 $x$ 和 $y$ 是很多的，我们只需要找出一组即可。

我们不妨分类讨论一下，列一张表：  
（$ans$ 表示 $(n|x)+(n|y)$ 的值，$ans_{i}=2$ 的地方其实应该是要进一位，但为了方便和理解，暂时这么表示一下）

|$x_{i}$|$y_{i}$|$n_{i}$|$ans_{i}$|
|-------|-------|-------|---------|
|  $0$  |  $0$  |  $0$  |   $0$   |
|  $1$  |  $0$  |  $0$  |   $1$   |
|  $1$  |  $1$  |  $0$  |   $2$   |
|  $0$  |  $0$  |  $1$  |   $2$   |
|  $1$  |  $0$  |  $1$  |   $2$   |
|  $1$  |  $1$  |  $1$  |   $2$   |

正如前文所说，$x_{i}$ 和 $y_{i}$ 是可以交换的，所以只列了 $6$ 种情况。  
从表中，我们可以看出，$n_{i}$ 为 $0$ 可以表现出 $x_{i},y_{i}$ 之间的关系，而 $n_{i}$ 为 $1$ 则可以隐藏这种关系。  

那可能有人就会说，那直接问一次 $n=0$ 不就行了吗？  
这显然是不可以的。假如你在 $ans_{i}$ 这一位是 $1$，但你实际上并不知道这一位，是 $x_{i}=1$ 和 $y_{i}=0$ 的结果，还是 $x_{i-1}=1$ 和 $y_{i-1}=1$ 的结果。（假设其他位都为 $0$，毕竟只是举任意一个反例。）

那么就可以想到隔一位确定一位，这样的话，就可以确定，这一位的值到底是因为什么了。然后询问两次，这两次刚好问的是不同的位，凑起来刚好是所有位。  
也就是第一次问 $\begin{matrix}\underbrace{10\dots10}\\15个01\end{matrix}$，第二次问 $\begin{matrix}\underbrace{01\dots01}\\15个10\end{matrix}$

每次得到 $ans$ 后，先将原先用于隐藏关系的 $1$ 产生的值去掉，再来计算 $x$ 和 $y$ 对应的位置的值，最后对于 $m$，直接求答案即可。

## 代码

```cpp
// Problem: E. Finding OR Sum
// Contest: Codeforces - Codeforces Round 1008 (Div. 2)
// URL: https://codeforces.com/contest/2078/problem/E
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1<<23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&&(P2=(P1=Buf)+fread(Buf,1,1<<23,stdin),P1==P2)?EOF:*P1++)
template<typename type>
inline void read(type &x){
	x=0;
	bool f=false;
	char ch=getchar();
	while(ch<'0'||ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
	if(f) x=-x;
}
template<typename type,typename... args>
inline void read(type &x,args&... y){
	read(x),read(y...);
}

int T,a,b,m,x,y,val1,val2;

int solve(){
	x=y=0;
	for(int i=0;i<=29;i+=2) val1-=(1<<i+1);
	for(int i=1;i<=29;i+=2) val2-=(1<<i+1);
	for(int i=0;i<=29;i+=2){
		if(val1&(1<<i+1)) x+=(1<<i+1);
		else if(val1&(1<<i+2)) x+=(1<<i+1),y+=(1<<i+1);
	}
	for(int i=1;i<=29;i+=2){
		if(val2&(1<<i-1)) x+=(1<<i-1);
		else if(val2&(1<<i)) x+=(1<<i-1),y+=(1<<i-1);
	}
	return (m|x)+(m|y);
}

signed main(){
	cin>>T;
	for(int i=0;i<=29;i+=2) a+=(1<<i);
	for(int i=1;i<=29;i+=2) b+=(1<<i);
	while(T--){
		cout<<a<<endl;
		cin>>val1;
		cout<<b<<endl;
		cin>>val2;
		cout<<'!'<<endl;
		cin>>m;
		cout<<solve()<<endl;
	}
	return 0;
}
```

---

## 作者：_Kamisato_Ayaka_ (赞：0)

## Foreword

交互题。

## Solution

考虑如何只需要两次询问确定每一位。

记 $V_1,V_2$ 分别表示偶数位、奇数位全为一时的值，询问这两个值之后记得到的答案为 $W_1,W_2$，你会发现与 $x,y$ 按位或之后再减去原来的，也就是 $W_1 - V_1,W_2 - V_2$ 的这两个值分别代表了 $x,y$ 在奇数位、偶数位的情况。

我们记 $k_1 = W_1-V_1,k_2 = W_2-V_2$，将 $k_1.k_2$ 相邻两位从低位到高位分成一组，显然有 $01,10,00$ 三种情况，$00$ 的情况不用考虑，$10$ 说明 $x,y$ 在 $1$ 的这一位上都为 $1$，$01$ 说明只有一个在 $1$ 的这一位上为 $1$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
inline int Query (int x) {
    cout << x << endl;
    int tmp; cin >> tmp;
    return tmp - x * 2;
}

inline void Solve() {
    int V1 = 0, V2 = 0;
    for (int i = 0; i < 30; i ++) {
        if (i & 1) {
            V2 |= (1 << i);
        } else {
            V1 |= (1 << i);
        }
    }
    // V1 : 10101010101010101010101010101
    // V2 : 10101010101010101010101010101
    int x = 0, y = 0;
    int v1 = Query (V2), v2 = Query (V1);
    // 找到奇数偶数位的情况

    for (int i = 0; i < 30; i ++) {
        int tmp = ((i & 1) ? v2 : v1);
        if ((tmp >> i) & 1) { // 01
            x |= (1 << i);
        } else if ((tmp >> (i + 1)) & 1) { // 10
            x |= (1 << i), y |= (1 << i);
        } else { // 00
            continue;
        }
    }
    cout << "!" << endl;
    int m; cin >> m;
    cout << (m | x) + (m | y) << endl;
    return;
}
signed main() {
    int Test; 
    cin >> Test;
    while (Test --) Solve();
    return 0;
}
```

---


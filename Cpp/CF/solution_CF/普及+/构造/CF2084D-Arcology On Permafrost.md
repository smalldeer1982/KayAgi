# Arcology On Permafrost

## 题目描述

给定三个整数 $n$、$m$ 和 $k$，其中满足 $m \cdot k < n$。

对于一个由非负整数组成的序列 $b$，定义 $f(b)$ 如下：

- 你可以对 $b$ 进行如下操作：
  - 设 $l$ 表示当前 $b$ 的长度。选择一个正整数 $1 \leq i \leq l - k + 1$，删除从下标 $i$ 到 $i + k - 1$ 的子数组，并将剩余部分拼接。换句话说，将 $b$ 替换为：
    $$
    [b_1, b_2, \ldots, b_{i - 1}, b_{i + k}, b_{i + k + 1}, \ldots, b_l].
    $$
- $f(b)$ 定义为在进行最多 $m$ 次（可以是零次）上述操作后，$\operatorname{mex}(b)$ 的**最小**可能值 $^{\text{∗}}$。

你需要构造一个长度为 $n$ 的非负整数序列 $a$，满足以下条件：
- 对于所有 $1 \le i \le n$，$0 \le a_i \le 10^9$。
- 在所有满足条件的序列 $a$ 中，$f(a)$ 的值最大化。

$^{\text{∗}}$ 集合 $c = \{c_1, c_2, \ldots, c_k\}$ 的最小排除值（MEX）定义为不包含在 $c$ 中的最小非负整数 $x$。

## 说明/提示

- 在第一个测试用例中，可以证明 $f(a) = 1$ 是最大化的结果。
- 在第二个测试用例中，可以证明 $f(a) = 1$ 是最大化的结果。$f(a) = 1$ 是因为你可以进行以下操作：
  - 选择 $i = 3$，删除下标 $3$ 到 $4$ 的子数组，剩余部分拼接后 $a$ 变为 $[0, 1, 0]$。
  - 选择 $i = 1$，删除下标 $1$ 到 $2$ 的子数组，剩余部分拼接后 $a$ 变为 $[0]$。
- 在第三个测试用例中，可以证明 $f(a) = 2$ 是最大化的结果。$f(a) = 2$ 是因为你可以进行以下操作：
  - 选择 $i = 2$，删除下标 $2$ 到 $5$ 的子数组，剩余部分拼接后 $a$ 变为 $[0, 1]$。
- 在第四个测试用例中，可以证明 $f(a) = 2$ 是最大化的结果。
- 在第五个测试用例中，可以证明 $f(a) = 3$ 是最大化的结果。
- 在第六个测试用例中，可以证明 $f(a) = 2$ 是最大化的结果。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
8
2 1 1
5 2 2
6 1 4
8 2 2
8 1 5
11 3 3
22 6 3
17 2 2```

### 输出

```
0 0
0 1 0 0 0
0 1 2 2 0 1
0 2 1 0 1 0 8 1
0 1 2 1000000000 1 0 1 2
1 0 0 1 0 2 1 0 2 1 0
0 2 1 0 2 1 0 3 2 1 0 2 1 0 2 1 0 2 1 0 2 1
4 0 2 1 3 4 0 2 1 0 3 4 0 1 2 1 3```

# 题解

## 作者：hongshixiaobai (赞：1)

# CF2084D Arcology On Permafrost 题解
[传送门](https://www.luogu.com.cn/problem/CF2084D)
## 思路
考虑如何确保 MEX 最大，显然需要保证从小到大尽可能多的数不会被删干净，也就是说需要保证尽可能多的数有 $m+1$ 个。分类讨论构造时有 $m+1$ 个的数的最大值是否大于 $k$ 即可。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,k,i,j,lim;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n>>m>>k;
		lim = n/(m+1);
		if(lim>=k)
		{
			for(i = 1;i<=m+1;i++)
				for(j = 0;j<lim;j++)
					cout<<j<<' ';
			for(i = (m+1)*lim+1;i<=n;i++)
				cout<<i-(m+1)*lim-1<<' ';
			cout<<'\n';
		}
		else
		{
			for(i = 1;i<=m;i++)
				for(j = 0;j<k;j++)
					cout<<j<<' ';
			for(i = m*k+1;i<=n;i++)
				cout<<i-m*k-1<<' ';
			cout<<'\n';
		}
	}
}
```

---

## 作者：xubaichuan (赞：0)

挺简单的一道题，没什么好说的，就是构造。

想想对面坐着你的仇人（我们暂时将他/她/它称为 haokee），haokee 会将想出一个最优策略，使用 $m$ 次操作，每次删除连续的 $k$ 个元素使你构造出的数组的 mex 最小，而你要使 mex 最大。

显然，你看肯定不希望 haokee 把你的某一个值一次删除很多个，这样很有可能出现断层的情况，即你的其他值还有很多，但你的某个值被删光了，这会使 mex 不高于这个值。

于是，你聪明地想到了将同一个值分开排列，且间距最好不小于 $k$，这样对于任意一个值，他一次只能删除一个出现点。

记 $length = mex - 1$，故可以这样排列：

$$\{0,1,2,\dots,length,0,1,2,\dots,length,0,1,2,\dots\}$$

使 $mex$ 最大，即使 $length$ 最大，但一定不会超过 $[\frac n {m+1}]$，其中 $[x]$ 为高斯函数，表示不超过 $x$ 的最大整数（如果你放置了超过 $[\frac n {m+1}]$ 个值，那么每个依照上面的排列，你一共只有 $[n \div [\frac n{m+1}]]<[n \div (\frac n{m+1})]=m+1$ 个值为 $length$ 的出现点，故 haokee 可以用 $m$ 次操作专门删除值为 $length$ 的出现点，最终的实际 $mex$ 小于预计的 $mex = [\frac n {m+1}]$，这样做显然没有意义，还不如令 $mex = [\frac n {m+1}]-1$）。

于是，你得到了 $length$ 的范围 $[k,[\frac n {m+1}]]$。那么 $k$ 有没有可能大于或等于 $[\frac n {m+1}]$ 呢？肯定是有可能滴。这种情况下，你肯定不会让 $length>k$，不然 haokee 只需要 $[\frac n {length}] \le [\frac n k]-1 \le [\frac n {(\frac n {m+1})}]-1=m$ 次操作就能删光你的所有值为 $length$ 的元素，故然此时需要有 $length \le k$。

所以 $length$ 的最大值为 $\max\{\frac n {m+1},k\}$，令 $length = \max\{\frac n {m+1},k\}$，你以 $10000$ 行每秒的速度写完了仅 $21$ 行的代码（写的已经足够松散了，实际上 $15$ 行左右就能写完了）并提交，然后……你惊奇地发现，诶，竟然 A 了！

没错，这题还真就这么简单，下面是参考代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_N = 2e5 + 50;
 
int _, n, m, k, a[MAX_N];

int main() {
    cin >> _;
    while (_--) {
        cin >> n >> m >> k;
        const int length = max(n / (m + 1), k);
        for (int i = 1, j = 0; i <= n; i++) {
            cout << j++ << ' ';
            j %= length;
        }
        cout << '\n';
    }
    return 0;
}
```

---


# Kirk and a Binary String (easy version)

## 题目描述

给你一个二进制字符串$s$，让你求出一个新的二进制字符串$t$，使其满足以下条件：

1. 新字符串的$0$的个数尽可能多。
1. 对于每个$l,r(1≤l≤r≤n)$，两个字符串的最长不下降子序列等长。

## 样例 #1

### 输入

```
110
```

### 输出

```
010
```

## 样例 #2

### 输入

```
010
```

### 输出

```
010
```

## 样例 #3

### 输入

```
0001111
```

### 输出

```
0000000
```

## 样例 #4

### 输入

```
0111001100111011101000
```

### 输出

```
0011001100001011101000
```

# 题解

## 作者：Eibon (赞：3)

可以通过线性 dp 进行求解。

设 $dp_{i}$ 表示以 $i$ 为结尾的最长不下降子串。

则 $dp_{0}=dp_{0}+[s_{i}=0]$

$dp_{1}=\max(dp_{0},dp_{1})+[s_{i}=1]$

考虑能否进行优化，发现最长不下降子串一定为一串 $0$ 连着一串 $1$，其中 $0$ 的数量与 $1$ 的数量可以为 $0$。

则更改子串中的数时，必须使这一位往后的 $1$ 的数量不得小于 $0$ 的数量，不然就会使最长不下降子串改变，于是维护 $1$ 与 $0$ 的差值即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
int n,sum;
char s[100005];
signed main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    for (int i=n;i;i--){
        if(s[i]=='0'){
			sum++;
		}
        else if(sum){
			sum--;
		}
        else{
			s[i]='0';
		}
    }
    printf("%s",s+1);
    return 0;
}
//dyyyyds
```

---

## 作者：初雪_matt (赞：2)

题目就是给你一个二进制字符串，让你求一个新的二进制字符串，使其 $0$ 的个数尽量多且原串与新串的**最长不下降子序列等长**。

首先，因为要求 $0$ 的个数必须多，那么如果原字符串当前位置是 $0$ 肯定不能改，接下来就是求最长的不下降子序列长，可以倒序循环方便一些，如果 $0$ 的个数目前是 $0$ 个的话，将此变量再次减一，详细代码请看下面：


```python
s=list(input())
l=len(s)-1 #实际字符串最大下标
z=0
for i in range(l,-1,-1): #从 l 到-1倒序循环
    if(s[i]=='0'): #如果这个字符是0
        z=z+1 #尽可能多加0
    elif z: #如果 z 不是0
        z-=1 #因为要求最长不下降子序列，则必须-1
    else:
        s[i]='0' #都不满足就是0 
s="".join(s) 
print(s)
```

---

## 作者：Dr_殇 (赞：2)

我觉得我这道题的算法可能有些玄学。。。

## 题意简述

给你一个二进制字符串，让你求一个新的二进制字符串，使其$0$的个数尽量多且对于每个$l,r(1≤l≤r≤n)$，原串与新串的最长不下降子序列等长。

## 题目分析

根据题意，可知是将原串中的一些字符修改。但是，会有以下几个问题出现：

### $Question 1$ 修改哪些字符

首先，$0$是一定不能修改的，修改之后不满足使$0$的个数最多的条件。

那么只有$1$是可以改的，这个问题算是解决了，但又有下面两个问题出现了：

### $Question 2$ 修改多少$1$

我们先假设原字符串的最长不下降子序列的长度为$len$，且原串中$0$的个数为$cnt$，如果$cnt$恰好等于$len$，那么证明原字符串的最长不下降子序列全为$0$组成，不需修改，直接输出原序列即可。

若是不等于，那么我们需要修改$len-cnt$个$1$为$0$，只有这样才能使0的个数尽可能多。

### $Question 3$ 修改哪些$1$

知道修改多少，修改哪些就不是很难了。首先我们只需要考虑$l=1$时的情况，对于其他$l$的值是无需考虑的。所以我们得求出原字符串对于$l=1,1≤r≤n$的最长不下降子序列的长度。

我们设$f_i$为第$i$个位置以$1$结尾的最长不下降子序列的长度，$sum_i$为前$i$为$0$的个数，可以得出转移方程：

$$
f_i = \begin{cases} max(f_{i-1}+1,sum_{i-1}+1)(s_i=1)\\f_{i-1}(s_i=0)\end{cases}
$$

$$
sum_i = \begin{cases} sum_{i-1}+1(s_i=0)\\sum_{i-1}(s_i=1)\end{cases}
$$

然后得出这个即可处理，首先对于第$i$个位置，如果将它从$1$修改成$0$，那么必须满足$f_i=sum_i+1+c$（$c$为过去修改的个数）。不过若是你如此处理的话，可能对后面有所影响。用这个算法处理出的字符串主要有以下几种可能：

$0001001100011011101000$

$0000001100111011101000$

不难发现，这两个序列都是错误的，所以这种方法不可取。若是要不对后面有影响，必须逆序处理。

令$now=len-cnt$，对于第$i$个位置，如果将它从$1$修改成$0$，那么必须满足$f_i=sum_i+now-c$（$c$为过去修改的个数）。

经过如此处理，便会得出正确答案。

## 代码如下

```cpp
#include <cmath>
#include <queue>
#include <string>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
 
int l, now, dp[100005][2];// dp[i][0] 即为 sum[i]，dp[i][1] 即为f[i]
char c[100005], s[100005];
 
long long Read() {
	long long k = 0, tmp = 1; char _c = getchar();
	while (_c > '9' or _c < '0') {
		if (_c == '-') tmp = -1;
		_c = getchar();
	}
	while (_c <= '9' and _c >= '0') {
		k = (k << 1) + (k << 3) + (_c ^ 48);
		_c = getchar();
	}
	return k * tmp;
}
void Work();
 
int main() {
	Work();
}
 
void Work() {
	cin >> c + 1;
	l = strlen(c + 1);
	for (int i = 1; i <= l; i++) {
		dp[i][1] = dp[i - 1][1];
		dp[i][0] = dp[i - 1][0];
		if (c[i] == '1') dp[i][1] = max(dp[i - 1][1] + 1, dp[i - 1][0] + 1);
		else dp[i][0] = dp[i - 1][0] + 1;
	}
	if (dp[l][0] >= dp[l][1]) {
		cout << c + 1 << endl;
	}
	else {
		now = dp[l][1] - dp[l][0]; // dp[l][1]即为cnt，dp[l][0]即为sum
		for (int i = l; i >= 1; i--) {
			if (c[i] == '0') s[i] = '0';// 如果是0，不修改
			else {
				if (dp[i][1] - dp[i][0] == now and now > 0) {// 如果是1且满足条件，修改
					s[i] = '0';
					now--;
				}
				else s[i] = '1';// 否则不修改
			}
		}
		for (int i = 1; i <= l; i++) {
			printf("%c", s[i]);// 输出答案
		}
		printf("\n");
	}
}
```


---

## 作者：xxxr_2024 (赞：1)

# CF1204D1 Kirk and a Binary String (easy version) 题解
## 分析
先来分析 $01$ 串的最长不下降子序列。全是 $0$ 显然是不下降的，如果中间出现一个 $1$，为了维护不下降的性质，后面就只能全是 $1$。一句话概括一下，$0$ 后面能跟 $0,1$，$1$ 后面只能跟 $1$。

现在来分析这道题。显然有一种 $\mathcal O(n^2)$ 的做法。从后往前遍历，如果这一位是 $1$，就先改成 $0$，然后用线性 dp 来求他们最长不下降子序列，看有没有改变。具体实现可以用 $dp[i]$ 表示以 $i$ 结尾的最长不下降子序列的长度，代码就不放了。

考虑 $\mathcal O(n)$ 做法。还是得从后往前遍历，但是我们发现，把一位从 $1$ 改成 $0$ 会影响最长不下降子序列长度时，当且仅当这以为后面的 $0$ 的个数比 $1$ 的个数大。因为当你把一个 $1$ 改成 $0$ 时，这个$0$ 就可以和它后面的 $0,1$ 都构成不下降子序列，而原来的 $1$ 仅仅只能和后面的 $1$ 来构成。只有后面的 $1$ 的个数大于等于 $0$ 的个数时，才不会对最长不下降子序列的长度造成影响。

## $\mathcal O(n)$ 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Raiden
{
    signed work()
    {
        string s;
        cin>>s;
        int n=s.size();
        int ans=0;
        for(int i=n-1;i>=0;i--)
        {
            if(s[i]=='0')
            {
                ans++;
            }
            else if(s[i]=='1'&&ans==0)
            {
                s[i]='0';
            }
            else
            {
                ans--;
            }
        }
        cout<<s<<endl;
        return 0;
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return Raiden::work();
}
```

---


# Zero-One

## 题目描述

在游戏开始之前，几张牌从左到右排成一行放在一张桌子上。每张牌包含`0`或`1`。玩家轮流移动（Masha 先移动）。在每一次移动中，玩家会移除一张牌。例如，在某人移动之前，表上的卡片形成了一个序列`01010101`，那么在第  $4$ 张卡片被移动之后（卡片从  $1$ 开始编号），序列将变成`0100101`。

当只剩  $2$ 张牌时，游戏结束。这些卡上的数字决定了二进制中的数字。Masha 的目标是最小化这个数字；Petya 的目标是最大化这个数字。

现在，有些卡片上的数字变得模糊了，记作`?`。假设 Petya 和 Masha 都玩得很好，请你找出游戏结束时剩下的  $2$ 张牌所有可能的情况。

## 说明/提示

样例组 #1 解释：有  $16$ 种可能的排列。如果一开始牌面为`0000`，结果是`00`；如果一开始牌面为`1111`，结果是`11`；如果一开始牌面为`0011`，结果是`01`；如果一开始牌面为`1100`，结果是`10`。总共只有  $4$ 种不同的结果。

样例组 #3 解释：只有  $2$ 种可能的数字排列：`111`和`101`。如果一开始牌面为`111`，结果是`11`；如果一开始牌面为`101`，结果是`01`。Masha 可以在第一次操作时取出最左边的牌，然后游戏结束。

## 样例 #1

### 输入

```
????
```

### 输出

```
00
01
10
11
```

## 样例 #2

### 输入

```
1010
```

### 输出

```
10
```

## 样例 #3

### 输入

```
1?1
```

### 输出

```
01
11
```

# 题解

## 作者：王大神——A001 (赞：2)

[传送门](https://www.luogu.com.cn/problem/CF135C)

~~码农题~~

本题的数据范围很大，暴力会`TLE`，所以是一道结论题，但是细节很多，考虑一定要周全。

### 规律
设1的数量 $x_1$，0的数量 $x_0$，问号的数量 $x_x$。
#### 最优取
通过题目不难发现，若保持结果尽量大，就会从左向右取0；若保持结果尽量小，就会从左向右取1。

例1：1010

最后要剩两位数所以会取掉一个0和1。若取右边的1，那么最后一定是10，但若取左边的1，有可能会剩01，所以从左向右会更优；若取右边的0，会使结果变成01，而取左边的0，结果会是10，所以从左向右取0更优。

我们会发现在 $x_1=x_0$ 时，结果由最后一位影响。
#### 最后一位的影响
在 $x_1=x_0$ 时，因为最优取是从左向右的，而结束时取得数量是相同的，且最后一位一定不会被取，所以 $x_1=x_0$ 时结果的第二位是原序列的最后一位，结果的第一位是原数列的最后一位的相反的值。
#### 先手优势
因为先取1，所以在判断的时候要特殊注意一下。

例2：11100

例3：1100

根据最优取我们发现例2例3的结果都是10，这就体现出先手的优势了，所以在判断时要特判 $x_1=x_0+1$ 情况的出现。
#### 两种数的数量不同
例4：1000

例5：1110

我们可以发现如下的结论：当 $x_1>x_0+1$ 是结果必是11，当 $x_1<x_o$ 时结果必是00。
#### 问号的情况
本题最大的困难就是对问号的处理。问号的存在使判断过程变得复杂，但既然是结论题，一定还是有规律的。

根据最优取，我们知道当 $x_1=x_0$ 时，结果由最后一位影响，而再根据先手情况，我们才有更全面的结论：当  $x_1=x_0$ 或 $x_1=x_0+1$ 时，结果由最后一位影响。

而问号的出现，可以用来判断是否有可能出现某种情况，所以我们只要判断是否会出现对应的情况即可。

不难发现，当 $x_0+x_x>x_1$ 时结果会出现00的情况，当 $x_1+x_x-1>x_0$ 时会出现11的情况。

而当 $x_x>=x_0-x_1$ 且 $x_0>=x_1$ 或 $x_x>=x_1-x_0-1$ 且 $x_1>=x_0+1$ 时，问号就可以使 $x_1=x_0$ 或 $x_1=x_0+1$ 的情况出现了。而这时就可以用最后后一位的结论代入即可。

### 代码
```cpp
#include<cstring>
#include<iostream>
#include<string>
#include<map>
using namespace std;
int x_1,x_0,x_x;
string s_s;
map<string ,int>mp;//用来判断结果是否有出现的可能
int main(){
	cin>>s_s;//读入序列 
	for(int i=0;i<s_s.length();i++)//统计 x_1 x_0 x_x 
		if(s_s[i]=='0')x_0++;
		else if(s_s[i]=='1')x_1++;
		else x_x++;
	mp["11"]=0;mp["10"]=0;mp["01"]=0;mp["00"]=0;//清空 
	if(x_1+x_x-1>x_0)mp["11"]=1;
	if(x_0+x_x>x_1)mp["00"]=1;
	if(((x_x>=x_0-x_1)&&x_0>=x_1)||(x_x>=x_1-x_0-1&&x_1>=x_0+1)){//问号使 x_1=x_0 和 x_1=x_0+1 的情况出现 
		if(s_s[s_s.length()-1]=='1')mp["01"]=1;//最后一位判断
		else if(s_s[s_s.length()-1]=='0')mp["10"]=1;//最后一位判断
		//最后一位是问号的判断 
		else if((x_x>(x_1-x_0)&&x_1>=x_0||x_x>(x_0-x_1)+1&&x_0>=x_1+1)&&x_x>1)mp["01"]=mp["10"]=1;//当问号为1或没有时，最多只会出现01和10的一种情况 
		else {
			if(x_1>x_0)mp["10"]=1;
			else mp["01"]=1;
		}
	}
	//输出 
	if(mp["00"])cout<<"00"<<endl;
	if(mp["01"])cout<<"01"<<endl;
	if(mp["10"])cout<<"10"<<endl;
	if(mp["11"])cout<<"11"<<endl;
	return 0;
}

```

---

## 作者：Domain_expansion (赞：1)

### 传送门
[题目: CF135C](https://www.luogu.com.cn/problem/CF135C)
### 思路
推结论。  

设 $1$，$0$，问号的数量分别为 $a$，$b$，$c$。

由两个人移除的性质可得： 

要使结果比较大，要取最左边的 $0$。 

要使结果比较小，要取最左边的 $1$。

也就是说，如果 $a>0$，$b>0$ 那么一轮后移除的牌为一个 $1$，一个 $0$，$a-b$ 不变。  

又由这个结论我们知道：  

若 $a=b$，在只剩2张牌时，由于 $a-b$ 不变，所以 $0$，$1$ 各一张。  

若 $a=b+1$，在只剩 $3$ 张牌时，$a=2$，$b=1$，由于取 $1$ 的人先手，所以还是 $0$，$1$，各一张。

由于最右边最后取，那么 $0$，$1$ 的顺序将由最后一张牌决定。  

若 $a>b+1$，那么在 $b=0$ 时 $a≥2$，怎么取都只有 $1$，所以最后还剩的就是两张 $1$。   

若 $a<b$ ，那么在 $a=1$ 时，$b≥2$，又由于取 $1$的人先手，所以 $1$ 会先取完，所以最后还剩的就是两张 $0$。

接下来我们考虑带问号的情形： 

若 $b+c>a$，可令 $c$ 个问号全部是 $0$，此时是 $b>a$ 的情形，由之前推出来的结论可知，最后还剩的就是两张 $0$。  

若 $a+c-1>b$，移项得 $a+c>b+1$，令 $c$ 个问号全部为 $1$，此时是 $a>b+1$ 的情形，由之前推出来的结论可知，最后还剩两张 $1$。  

若 $c≥b-a≥0$，令 $b-a$ 个问号为 $1$，则此时 $a=b$，再将剩余的 $c-b+a$ 个问号交替变为$1$，$0$，此时就是 $a=b$ 或 $a=b+1$ 的情形。

若 $c≥a-b-1≥0$ 按上一个结论的推法也能推出此时是 $a=b$ 或 $a=b+1$ 的情形。  

至此，所有的结论已经被推出，接下来只需按结论进行判断即可，也没什么好说的了。

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a=0,b=0,c=0;
string s;
int oz=0,zo=0,oo=0,zz=0;//判断每种情况：10，01，11，00
int main(){
	cin>>s;
	int len=s.length();
	for(int i=0;i<len;i++){//得到每个字符出现的次数
		if(s[i]=='1') a++;
		if(s[i]=='0') b++;
		if(s[i]=='?') c++;
	}
	if(b+c>a) zz=1;
	if(a+c-1>b) oo=1;
	if((c>=b-a&&b>=a)||(c>=a-b-1&&a>=b+1)){
		if(s[len-1]=='1') zo=1;//最后一项
		else if(s[len-1]=='0') oz=1;//最后一项
		else if(c>a-b&&a-b>=0&&c>1) oz=1,zo=1;
		else if(c>b-a+1&&b-a+1>=0&&c>1) oz=1,zo=1;
		else if(a>b){
			oz=1;
		}else zo=1;
	}
	if(zz==1) cout<<"00"<<endl;
	if(zo==1) cout<<"01"<<endl;
	if(oz==1) cout<<"10"<<endl;
	if(oo==1) cout<<"11"<<endl;
	return 0;
}
```

---


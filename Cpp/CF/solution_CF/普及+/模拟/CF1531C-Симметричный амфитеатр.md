# Симметричный амфитеатр

## 题目描述

Все готовятся к VK Fest 2021! Для того, чтобы зрителям была лучше видна главная сцена, планируется построить амфитеатр. В этой задаче мы будем рассматривать его сбоку — схематично он будет иметь форму лестницы из $ n $ одинаковых квадратов. Лестница — это одна или более башен квадратов, выстроенных в ряд, где высоты башен невозрастают слева направо.

На следующем рисунке можно видеть три разные фигуры из $ 12 $ квадратов. Первые две фигуры — лестницы, а третья — нет.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1531C/c3f29f4449b740c0b9e4bf33f783c2056dec450f.png)Из эстетических соображений было решено, что амфитеатр должен быть симметричным. Формально, амфитеатр называется симметричным, если при отражении его схемы относительно прямой $ x = y $ получается тот же самый рисунок (где ось $ x $ направлена слева направо, а ось $ y $ — снизу вверх). Например, первая лестница на рисунке выше — симметричная, а вторая — нет.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1531C/c8b6a179d527265c360f8c3336d2da1274d329f3.png)Кроме того, амфитеатр должен быть максимально компактным — а именно, сторона минимального квадрата, внутрь которого можно его поместить, должна быть как можно меньше.

По заданному числу $ n $ нарисуйте схему амфитеатра из ровно $ n $ квадратов, удовлетворяющую всем условиям.

## 样例 #1

### 输入

```
3```

### 输出

```
2
o.
oo```

## 样例 #2

### 输入

```
17```

### 输出

```
5
o....
ooo..
oooo.
oooo.
ooooo```

# 题解

## 作者：wuyixiang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF1531C)

题目大意：用最小的 $n \times n$ 的格子使得里面的方格呈阶梯级下落且对于对称轴 $y = x$ 对称。

看到 “最小”，不难想到将它们聚集在一起（越紧越好）。这很容易联想到正方形。但是也不是所有数都是完全平方数的。比如样例，它就是 $16 + 1$。这种情况该怎么办呢？

我们先来谈剩下来为偶数个的情况。如图所示。

```
....
ooo.
ooo.
ooo.
```

如果让你再填 $4$ 个块，并且要满足轴对称和阶梯状，那么无非只有一种方法了。两边各填上两个块，且尽量靠边缘填即可。

```
oo..
ooo.
oooo
oooo
```

如果只填 $3$ 个块的话，我们可以按性质讨论。我们发现：在对称轴上填和不填都不会影响对称性。因为又要呈阶梯状，所以肯定是不能从上面那幅图中拿走里面的，只能拿最上面的。这就是 $n = 12$ 的形态：

```
oo..
oo..
oooo
oooo
```

但是当边缘个数更多的时候，似乎就不行了。

```
ooo.
oo.o
oooo
oooo
```

如图，这里虽然拿了对角线最外面的方格，但由于上面、右边已经填了方格，所以这种形态是不合法的。为了应对过于多的正方形数量，我们只能将大正方形的边长再加一。

```
o....
oo...
oo...
oooo.
ooooo
```

将两个方格填到别处后，问题就解决了。

可以证明不存在比这更好的方案。

大部分的方格数量都可以通过以上方式解决。唯独有一个数 $2$，无论怎么填都是不合法的，这种情况要特判掉，输出 `-1`。

### 代码

```
#include <iostream>
#include <cmath>
using namespace std;
int n,m,a[300][300],p,r;
char c[2] = {'.','o'};
int main()
{
    cin >> n;
    m = ceil(sqrt(n)),p = floor(sqrt(n));//m,p为大正方形的边长、里面正方形的边长
    if(n == 2)//特判
    {
        cout << -1;
        return 0;
    }
    if(n == m * m - 2)//特判：当不合法的情况
		a[m + 1][1] = a[1][m + 1] = 1,n -= 2,r = 1;//增加正方形的边长，并把两个方格移到边上（用r记录）
    cout << m + r << '\n',n -= p * p;
    for(int i = 1;i <= p;i ++)
        for(int j = 1;j <= p;j ++)a[i][j] = 1;
    if(n % 2)a[p][p] = 0,n ++;//当剩余的方格为奇数的情况
    for(int i = 1;i <= n / 2;i ++)a[m][i] = 1;
    for(int i = 1;i <= n / 2;i ++)a[i][m] = 1;
    for(int i = m + r;i >= 1;i --)
    {
        for(int j = 1;j <= m + r;j ++)cout << c[a[i][j]];
        cout << '\n';//输出
    }
}
```

---

## 作者：him的自我修养 (赞：0)

# 题意
请输出一个正方形图形，图形中有 $n$ 个 $o$，并且 $o$ 所组成的图形是一个轴对称图形。正方形边长尽可能小。

# solution
把正方形分成三个部分，两个一样的图形，一个正方形。

考虑枚举中间正方形的周长，依次判断大正方形的周长，显然，对于一个中间边长为 $x$ 的正方形，外面图形的周长为 $x+\lceil \frac{(n-x^2)}{x} \rceil$，取最小值。

接下来对于两边的图形，只要一层一层的填充就可以了。

# code
```
#include <bits/stdc++.h>
using namespace std;
int n,a[105][105];
int ans=114514,y;
int main(){
	cin >>n;
	int s=sqrt(n);
	for(int i=1;i<=s;i++){
		int x=n-i*i;
		if(x&1) continue;
		x/=2;
		if(ans>i+ceil(x*1./i)){
			ans=i+ceil(x*1./i);
			y=i;
		}
	}
	if(ans==114514){
		cout <<-1;
		return 0;
	}
	cout <<ans<<endl;
	for(int i=1;i<=y;i++){
		for(int j=1;j<=y;j++){
			a[i][j]=1;
		}
	}
	int x=n-y*y;
	x/=2;
	int len=x/y;
	for(int i=1;i<=len;i++){
		for(int j=1;j<=y;j++){
			a[y+i][j]=a[j][y+i]=1;
		}
	}
	x%=y;
	for(int i=1;i<=x;i++){
		a[len+y+1][i]=a[i][len+y+1]=1;
	}
	for(int i=ans;i>=1;i--){
		for(int j=1;j<=ans;j++){
			cout <<(a[i][j]?'o':'.');
		}
		cout <<endl;
	}
	return 0;
}
```

---

## 作者：HEIMOFA (赞：0)

将 $n$ 分为三个部分，一个是 $depth\times depth$ 的正方形，两个是正方形两边的对称的部分。

理想状态下，我们希望正方形边长最大，这样就可以尽可能的使用空间，从而使 $m$ 最小。

但是有时候这是非法的，所以我们需要不断枚举 $depth$ 找到后直接做就行。

具体细节看注释。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
int n,depth,a;
const int N=105;
int mp[N][N];

int main()
{
	scanf("%d",&n);
	if(n==2){//特判
		printf("-1");
		return 0; 
	}
	depth=ceil(sqrt(n));//理想状态
	while(true){
		int del=n-depth*depth;
		if(depth*depth>n||(del&1)){//满足其中之一，这个 depth 就不行
			depth--;
			continue;
		}
		del/=2;
		a=depth+ceil(del*1.0/depth);
		printf("%d\n",a);
		for(int i=1;i<=depth;i++) for(int j=1;j<=depth;j++) mp[i][j]=1;//正方形
		for(int i=depth+1;i<a;i++) for(int j=1;j<=depth;j++) mp[i][j]=mp[j][i]=1;//正方形外的完整部分
		del%=depth;//不完整部分
		if(del==0) del=depth;
		for(int j=1;j<=del;j++) mp[a][j]=mp[j][a]=1;
		for(int i=a;i>=1;i--){
			for(int j=1;j<=a;j++){
				cout<<((mp[i][j]==1)?'o':'.');
			}
			printf("\n");
		}
		break;
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 思路

$n$ 很小，意味着矩形最大就是 $50\times 50$，对角线最长是 $10$。

那么我们可以考虑枚举对角线的长度。

假设对角线方格个数为 $l$（即绿色区域的边长为 $l$），那么这个矩形的方格数量最少为 $l^2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/13xual7e.png)

我们称绿色区域为 base，红色区域为 extra。那么我们可以求出 extra 的方块个数 $m=(n-l)\div 2$。如果 $m$ 不是整数则无解。

如果 $m$ 是整数，我们要考虑构建一个递减的，长度为 $l$ 的“台阶”来解决。所以其实这道题可以分治，但不需要。

现在我们考虑怎么构造。很简单，我们在 extra 的第一列放上 $m$ 个方块即可。对应过来第一行（从下往上）也放 $m$ 个。



但是我们惊奇的发现这题好像要求的 $m$ 尽可能小！（题目翻译中没写）因为这样子交上去样例 $2$ 就 wa 了。所以我们换一种构造即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/fc9nfx95.png)

假设我们枚举到一个 $l$，那么计算出 $m$，我们尽可能让这个“台阶”（即 extra 部分）高度降低。所以我们尽可能铺满底层即可。extra 部分的高度为 $h=\lceil\frac{m}{l}\rceil$。我们枚举所有可能的 $l$，计算并记录当 $l+h$ 最小时 $l,h$ 的值，然后根据这个 $l,h$ 填方块即可。

## 代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=1e3+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,a[N][N],m,p,q,T,s[N],ansi,mn=INF;

signed main(){
	cin>>n;
	for(int i=1;i<=sqrt(n);i++){
		int m=n-i*i;
		if(m%2)continue;
		m/=2;
		if(mn>i+ceil(1.0*m/i)){
			mn=i+ceil(1.0*m/i);
			ansi=i;
		}
	}
	if(mn==INF)cout<<-1<<endl;
	else{
		cout<<mn<<endl;
//		cerr<<"mn="<<mn<<endl;
//		cerr<<"ansi="<<ansi<<endl;
		for(int i=1;i<=ansi;i++){
			for(int j=1;j<=ansi;j++)a[i][j]=1;
		}
		int m=n-ansi*ansi;
		m/=2;
		int lin=m/ansi;
		for(int i=1;i<=m/ansi;i++){
			for(int j=1;j<=ansi;j++)a[ansi+i][j]=1,
			a[j][ansi+i]=1;
		}
		m%=ansi;
		for(int i=1;i<=m;i++)a[lin+1+ansi][i]=a[i][lin+1+ansi]=1;
		
		
		for(int i=mn;i;i--){
			for(int j=1;j<=mn;j++){
				if(a[i][j])cout<<'o';
				else cout<<'.';
			}
			cout<<endl;
		}
	}
	
	return 0;
}


```




---


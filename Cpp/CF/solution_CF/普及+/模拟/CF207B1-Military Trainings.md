# Military Trainings

## 题目描述

ABBYY 的聪明海狸开始与国防部合作。现在他们正在训练士兵行动装甲车队。训练包括测试一种能够传输信息的新型坦克。为了测试这种新型坦克，训练中有一个特殊的演习，其核心如下所述。

最初，车队由从 $1$ 到 $n$ 依次编号的 $n$ 辆坦克组成，按照从车队起始位置到结束位置的顺序排列。在整个演习过程中，必须准确传递 $n$ 条信息，从车队的起始位置传递到结束位置。

传递一条信息的过程如下：车队中排在第一位的坦克将信息传递给车队中的某辆坦克。接收到信息的坦克将其继续传递给车队中的下一辆坦克。这个过程一直持续到最后一辆坦克接收到信息。车队中并不是所有的坦克都会接收到信息，但最重要的是确保最后一辆坦克能够接收到信息。

当最后一辆坦克（坦克编号为 $n$）接收到信息后，它将移动到车队的起始位置，并以相同的方式将另一条信息发送到车队的末尾。当信息到达最后一辆坦克（坦克编号为 $n-1$）时，该坦克将移动到车队的起始位置，并将下一条信息发送到车队的末尾，以此类推。因此，当车队中的坦克恢复到它们的原始顺序时，即在坦克编号 $1$ 移动到车队起始位置后，演习就完成了。

如果初始时坦克按照顺序 $1, 2, ..., n$ 排列在车队中，那么在第一条信息传递后，它们的顺序变为 $2, 1, ..., n-1, n$。在第二条信息传递后，顺序变为 $n, 2, 1, ..., n-2, n-1$。以此类推，每传递一条信息，坦克的顺序都会发生变化。

这些坦克的构造方式非常独特。编号为 $i$ 的坦克具有一个整数 $a_i$，被称为该坦克的信息接收半径。

在两辆坦克之间传递一条信息需要一秒钟，然而，并不总是一辆坦克能够将信息传递给另一辆坦克。假设车队中有两辆坦克，第一辆坦克是从起始位置开始计算的第 $i$ 辆坦克，第二辆坦克是车队中的第 $j$ 辆坦克，并且假设第二辆坦克的编号是 $x$。那么，如果 $i < j$ 并且 $j - a_x \le i$，那么第一辆坦克可以将信息传递给第二辆坦克。

国防部（以及很快轮到智能海狸）面临如何高效组织训练的问题。演习应尽快完成。我们将忽略坦克在列队移动所花费的时间，因为提高坦克的速度不是这次训练的重点。

你已获得坦克的数量以及所有坦克的信息接收半径。您必须帮助智能海狸，以尽可能减少所有信息的总传输时间的方式组织信息的传递。

### **简明题意**

对于一个 $1, 2,...,n$ 的排列，每个数有一个半径 $a_i$。每次从开头发射信号，传到末尾， 并将末尾移到队头。这样操作 $n$ 次。每次传递耗时 $1$ 秒。求总耗时最小的方案。

## 样例 #1

### 输入

```
3
2
1
1
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
2
2
2
2
2
```

### 输出

```
10
```

# 题解

## 作者：Li2021 (赞：1)

## Military Trainings 题解

根据数据规模 $n \le 300$，建议评橙。

### 题目大意

给你每辆坦克的信息接收半径，最前面的坦克需要传递信息到最后一个坦克。接到信息的坦克可以将信息接着传下去，直到最后面的坦克接收到信息。求最小单位时间花费。

### 解题思路

动态规划。定义数组 $dp_i$ 意义为信息传输至 $i$ 个坦克时耗费的单位时间。可以从前找出耗费步数最优（最少）的方案，进行传输。证明简单，略了。时间复杂度 $O(n^3)$。

### 小技巧

可以复制一遍数组，不用手动模拟环，使常数更低。

如： ```1 2 5 4 3``` 可以变成 ```1 2 5 4 3 1 2 5 4 3 ```，遍历到第 $i$ 个时第 $i$ 个至第 $i + n$ 个即为环。

### Code

```cpp
#include <iostream>
#include <cstring>
#define inf 0x3f3f3f3f
#define N 200002
using namespace std;
int n,a[N],dp[N],ans=0;
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
	    cin>>a[i];
	    a[n+i]=a[i];
	}
	for(int i=1;i<=n;i++){
		memset(dp,0,sizeof dp);
		for(int j=2;j<=n;j++){
			int minn=inf;
			for(int k=max(j-a[j+i-1],1);k<=j-1;k++)  minn=min(minn,dp[k]);
			dp[j]=minn+1;
		}
		ans+=dp[n];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：xiaohaoaibiancheng66 (赞：0)

# 思路
题目中给的两个可以传信息的要求 $i<j$ 和 $j\ge i-a_x$ 不太好看，先变一下形：$i<j\rightarrow 1\le j-i,j\ge i-a_x\rightarrow j-i \le a_x$，综合起来就是 $1\le j-i \le a_x$。

设 $dp_i$ 为从 $1$ 到 $i$ 传递信息需要多少秒，dp 即可。状态转移方程如下：
$$dp_i=\min_{j=\max\{i-a_i,0\}}^{i-1}dp_j+1$$
dp 一次是 $n^2$，一共进行 $n$ 次，所以时间复杂度为 $O(n^3)$。在本题 $n\le 300$，时限 $3$ 秒的情况下可以通过。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
 
int a[1000000];
int dp[1000000];
 
int main()
{
	int n;
	cin>>n;
	long long ans=0;
	for(int i=0;i<n;i++)cin>>a[i];
	for(int k=0;k<n;k++)
	{
		//dp
		dp[0]=0;
		for(int i=1;i<n;i++)
		{
			dp[i]=10000000;
			for(int j=max(0,i-a[i]);j<i;j++)
				dp[i]=min(dp[j]+1,dp[i]);
			
		}
		ans+=dp[n-1];
		//轮换
		for(int i=n;i>0;i--)a[i]=a[i-1];
		a[0]=a[n];
	}
	cout<<ans;
	return 0;
}
```

---


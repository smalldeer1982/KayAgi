# Minesweeper 1D

## 题目描述

Game "Minesweeper 1D" is played on a line of squares, the line's height is 1 square, the line's width is $ n $ squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 — the total number of bombs in adjacent squares.

For example, the correct field to play looks like that: 001\*2\*\*\*101\*. The cells that are marked with "\*" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2\* is not correct, because cell with value 2 must have two adjacent cells with bombs.

Valera wants to make a correct field to play "Minesweeper 1D". He has already painted a squared field with width of $ n $ cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.

## 说明/提示

In the first test sample you can get the following correct fields: 001\*\*1, 001\*\*\*, 001\*2\*, 001\*10.

## 样例 #1

### 输入

```
?01???
```

### 输出

```
4
```

## 样例 #2

### 输入

```
?
```

### 输出

```
2
```

## 样例 #3

### 输入

```
**12
```

### 输出

```
0
```

## 样例 #4

### 输入

```
1
```

### 输出

```
0
```

# 题解

## 作者：Star_Cried (赞：9)

## CF404D-DP

### *正经的东西*

****

### 题意

给定一个字符串，只包含'0','1','2','*','?'五种字符，其中'?'可被替换为其他任何一种，求使序列符合扫雷地图定义的方案数。

一个数字字符大小表示与之临近的位置总共有多少个雷。

### 思路

DP。

和其他题解不太相同，我们每个点只记录三种状态：0,1,2，分别表示**此点的下一位**不为雷、为雷，和本身就是雷的此位以前的方案数。

注意，这些状态除了最后一个，与该点本身为何没有关系。

考虑每一个点分别为何的情况下从上一个位置的什么状态转移：

1. 为0：继承0.

   ```cpp
   f[i][0]+=f[i-1][0]
   ```

2. 为1：自身0的状态继承上一个为雷的状态，为1的继承为0的。

   ```cpp
   f[i][0]+=f[i-1][2]
   f[i][1]++f[i-1][0]
   ```

3. 为2：只能将自身为1的状态继承上一个为雷的状态。

   ```cpp
   f[i][1]+=f[i-1][2]
   ```

4. 为雷：继承上一个为1、为雷的状态。

   ```cpp
   f[i][2]+=f[i-1][2]+f[i-1][1]
   ```

5. 为？：将上述所有状态全部转移。

   ```cpp
   f[i][0]+=f[i-1][0]+f[i-1][2]
   f[i][1]+=f[i-1][0]+f[i-1][2]
   f[i][2]+=f[i-1][1]+f[i-1][2]
   ```

至于上面转移的原因显然，即每个点后面的点能继承当前点的哪个状态。

* 注意：初始化`f[0][0]=f[0][1]=1`，后者是为了计算第一位为雷的情况。此外，所有该点未被转移的状态**都为0**。

于是我们线性DP求解即可。

### *不正经的东西*

****

* 首先，显然上面的第一维可以滚动数组优化。
* 然后，我们可以边输入边计算，就不用数组存东西啦。这样我们将空间复杂度优化到了$O(1)$

* 最后，你就会发现吾的做法~~即好想又好写又省时间又省空间~~

# 达成成就：内存使用小于代码大小
![](https://cdn.luogu.com.cn/upload/image_hosting/16uiog59.png)
### 代码

```cpp
#include<cstdio>
using namespace std;
const int mod=1e9+7;
int f[2][3];
int x,i;char c;
inline void qm(int &a,const int& b){(a+=b)>=mod?(a-=mod):a;}
int main(){
	c=getchar();
	while(c<=32)c=getchar();
	f[0][0]=f[0][1]=1;
	for(x=1;c>32;x++,c=getchar()){
		i=x&1;
		f[i][0]=f[i][1]=f[i][2]=0;
		switch(c){
			case '0':{
				qm(f[i][0],f[i^1][0]);
				break;
			}
			case '1':{
				qm(f[i][1],f[i^1][0]);
				qm(f[i][0],f[i^1][2]);
				break;
			}
			case '2':{
				qm(f[i][1],f[i^1][2]);
				break;
			}
			case '*':{
				qm(f[i][2],f[i^1][1]+f[i^1][2]);
				break;
			}
			case '?':{
				qm(f[i][0],f[i^1][0]);
				qm(f[i][0],f[i^1][2]);
				qm(f[i][1],f[i^1][0]);
				qm(f[i][1],f[i^1][2]);
				qm(f[i][2],f[i^1][1]);
				qm(f[i][2],f[i^1][2]);
				break;
			}
		}
	}
	x--;
	printf("%d",(f[x&1][0]+f[x&1][2])%mod);
	return 0;
}
```



---

## 作者：交警 (赞：5)

## $CodeForces$ $CF404D$ 
#  $Minesweeper$ $1D$ 

$NanyaOIer$ $:$ $y2j$
### $Time$ $Limit$ $:$ $2.00s$  
### $Memory$ $Limit$ $:$ $256MB$
## $Background$

纪念第一代暴力哥（K1804 王子轩）

## $Description$

有一天暴力哥走在路上，被众人敬仰的 $wannabe$ 看到以后， $wannabe$ 要求暴力哥去搞文化。暴力哥并不同意，于是 $wannabe$ 给了暴力哥一个智力题： $wannabe$ 写了一个程序随机生成一个扫雷的图。因为怕暴力哥做不出，于是把它简化成了一维的扫雷（用字符串 $s$ 来表示 ），并且随机地给出了某些方格的状态：  
 ```s[i] == '0'``` 表示在第 $i$ 个位置的左边一位和右边一位的地雷总数为 $0$。  
 ```s[i] == '1'``` 表示在第 $i$ 个位置的左边一位和右边一位的地雷总数为 $1$。  
 ```s[i] == '2'``` 表示在第 $i$ 个位置的左边一位和右边一位的地雷总数为 $2$。  
 ```s[i] == '?'``` 表示第 $i$ 位的情况未知，可以任意填，但是要满足左右两个格子的条件。  
 ```s[i] == '*'``` 表示在第 $i$ 个位置有一颗地雷。  
$wannabe$ 让暴力哥思考：填写 ```'?'``` 的地方总共有多少种填写方式。
暴力哥很自信的接下了这个智力题，想用 C++ 来解决。可是暴力哥已经退组好久了，所以来找到你来帮他解决这个问题。

## $Simplified$ $Description$

一维扫雷。  
给定一个字符串 $s$ ，其中包含以下五种字符：  
 ```s[i] == '0'``` 表示在第 $i$ 个位置的左边一位和右边一位的地雷总数为 $0$。  
 ```s[i] == '1'``` 表示在第 $i$ 个位置的左边一位和右边一位的地雷总数为 $1$。  
 ```s[i] == '2'``` 表示在第 $i$ 个位置的左边一位和右边一位的地雷总数为 $2$。  
 ```s[i] == '?'``` 表示第 $i$ 位的情况未知，可以任意填，但是要满足左右两个格子的条件。  
 ```s[i] == '*'``` 表示在第 $i$ 个位置有一颗地雷。

求可能的方案数（对于 $1e9 + 7$ 取模）


## $Input$

一行一个字符串 $s$ ，仅包含 ```'0'```, ```'1'```, ```'2'```, ```'?'```, ```'*'```五种字符。

## $Output$

一行一个整数，为方案数（对 $1e9 + 7$ 取模）。

## $Sample1$ $Input$

```
?01???
```

## $Sample1$ $Output$

```
4
```

## $Sample1$ $Explaination$

共 $4$ 种方案。  
 $4$ 种方案如下：  

```+-+-+-+-+-+-+```  
```|0|0|1|*|1|0|```  
```+-+-+-+-+-+-+```

```+-+-+-+-+-+-+```  
```|0|0|1|*|2|*|```  
```+-+-+-+-+-+-+```

```+-+-+-+-+-+-+```  
```|0|0|1|*|*|1|```  
```+-+-+-+-+-+-+```

```+-+-+-+-+-+-+```  
```|0|0|1|*|*|*|```  
```+-+-+-+-+-+-+```

## $Sample2$ $Input$

```
?
```

## $Sample2$ $Output$

```
2
```

## $Sample2$ $Explaination$

共 $2$ 种方案：  
 $2$ 种方案如下：

```+-+```  
```|0|```  
```+-+```

```+-+```  
```|*|```  
```+-+```

## $Sample3$ $Input$

```
**12
```

## $Sample3$ $Output$

```
0
```

## $Sample3$ $Explaination$

共 $0$ 种方案：  
因为数据中并没有 ```'?'```  
所以填写 ```'?'``` 的方案数为 $0$ 。

## $Sample4$ $Input$

```
1
```

## $Sample4$ $Output$

```
0
```

## $Sample4$ $Explaination$

共 $0$ 种方案：  
因为数据中并没有 ```'?'```  
所以填写 ```'?'``` 的方案数为 $0$ 。

## $Data$ $Constraint$

$1 ≤ | s | ≤ 10^6$

## $Tips$

暴力哥想写 $dfs$，但是他是已经退组的人了。  
作为还没有退组的人，你应该用 $dp$ 来解决这道智力题。

## $Solution$

先建一个二维数组 ```dp[N][5]```。  

 ``` dp[i][0] ``` 表示的是第 ``` i ``` 位为雷，第 ``` i - 1 ``` 位和第 ``` i + 1 ``` 位任意。（对应 ``` s[i] == '*' ``` 的情况）  
 ``` dp[i][1] ``` 表示的是第 ``` i ``` 位没有雷，第 ``` i - 1 ``` 位并且第 ``` i + 1 ``` 位都没有雷。（对应 ``` s[i] == '0' ``` 的情况）  
 ``` dp[i][2] ``` 表示的是第 ``` i ``` 位没有雷，第 ``` i - 1 ``` 位没有雷并且 ``` i + 1 ``` 位有雷。（对应 ``` s[i] == '1' ``` 的情况）  
 ``` dp[i][3] ``` 表示的是第 ``` i ``` 位没有雷，第 ``` i - 1 ``` 位有雷并且 ``` i + 1 ``` 位没有雷。（对应 ``` s[i] == '1' ``` 的情况）  
 ``` dp[i][4] ``` 表示的是第 ``` i ``` 位没有雷，第 ``` i - 1 ``` 位和第 ``` i + 1 ``` 位都有雷。（对应 ``` s[i] == '2' ``` 的情况）

 ``` dp[i][0] + dp[i][1] + dp[i][3] ``` 表示的是前 ``` i ``` 位的方案数。

 所以转移完成后只需输出 ``` dp[n][0] + dp[n][1] + dp[n][3] ``` 的值即可（因为第 ``` n + 1 ``` 位肯定不是雷，所以排除掉 ``` dp[n][2] ``` 和 ``` dp[n][4] ```）。

开始转移之前，初始化：  
 ``` dp[0][1] = 1 ``` ：方便对于第 ``` 1 ``` 位没有雷的情况进行转移  
 ``` dp[0][2] = 1 ``` ：方便对于第 ``` 1 ``` 位有雷的情况进行转移  
以上两行表示的是第 ``` 0 ``` 位没有雷并且第 ``` -1 ``` 位没有雷的情况数都为 ``` 1 ```。

转移时根据 ``` s[i] ``` 字符进行相应的转移方式。

---

> 如果 ``` s[i] == '0' ```：  

那么 ``` s[i-1] != '*' ``` 并且 ``` s[i+1] != '*' ``` 。（对应 ``` dp[i][1] ``` 和 ``` dp[i][3] ``` ）  
>> ``` dp[i][1] = ( dp[i][1] + dp[i][3] ) % mod; ```

---

> 如果 ``` s[i] == '1' ```：

1.如果 ``` s[i-1] == '*' ```  
>> ``` dp[i][3] = dp[i-1][0]; ```  

2.如果 ``` s[i-1] != '*' ```  
>> ``` dp[i][2] = ( dp[i-1][1] + dp[i-1][3] ) % mod; ```

---

> 如果 ``` s[i] == '2' ```：

那么 ``` s[i-1] == '*' ``` 并且 ``` s[i+1] == '*' ``` 。（对应 ``` dp[i][4] ``` ）
>> ``` dp[i][4] = dp[i-1][0]; ```

---

> 如果 ``` s[i] == '*' ```：

>> ``` dp[i][0] = ( ( dp[i-1][2] + dp[i-1][4] ) % mod + dp[i-1][0] ) % mod; ```

---

> 如果 ``` s[i] == '?' ```：

综合各种情况分析：

1.如果 ``` s[i] == '*' ```
>> ``` dp[i][0] = ( ( dp[i-1][2] + dp[i-1][4] ) % mod + dp[i-1][0] ) % mod; ```

2.如果 ``` s[i] == '0' ```
>> ``` dp[i][1] = ( dp[i-1][1] + dp[i-1][3] ) % mod; ```

3.如果 ``` s[i] == '1' ```
>> ``` dp[i][2] = ( dp[i-1][1] + dp[i-1][3] ) % mod; ```  
>> ``` dp[i][3] = dp[i-1][0]; ```

4.如果 ``` s[i] == '2' ```
>> ``` dp[i][4] = dp[i-1][0] ```

---

## $std$

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5, mod = 1e9 + 7; 

int n;
int dp[N][5];
char s[N];

signed main() {
	scanf ( "%s", s + 1 );
	n = strlen ( s + 1 );
	dp[0][1] = dp[0][2] = 1;
	for ( register int i = 1 ; i <= n ; i ++ ) {
		if ( s[i] == '?' ) {
			dp[i][0] = ( ( dp[i-1][2] + dp[i-1][4] ) % mod + dp[i-1][0] ) % mod;
			dp[i][1] = ( dp[i-1][1] + dp[i-1][3] ) % mod;
			dp[i][2] = ( dp[i-1][1] + dp[i-1][3] ) % mod;
			dp[i][3] = dp[i-1][0];
			dp[i][4] = dp[i-1][0];
		} else if ( s[i] == '0' ) {
			dp[i][1] = ( dp[i-1][3] + dp[i-1][1] ) % mod;
		} else if ( s[i] == '1' ) {
			dp[i][3] = dp[i-1][0];
			dp[i][2] = ( dp[i-1][1] + dp[i-1][3] ) % mod;
		} else if ( s[i] == '2' ) {
			dp[i][4] = dp[i-1][0];
		} else if ( s[i] == '*' ) {
			dp[i][0] = ( ( dp[i-1][2] + dp[i-1][4] ) % mod + dp[i-1][0] ) % mod;
		}
	} return (void) ( printf ( "%d\n", ( ( dp[n][0] + dp[n][1] ) % mod + dp[n][3] ) % mod ) ), 0;
}
```

#  $End$

---

## 作者：Louis_lxy (赞：4)

## 思路
考虑 dp，我们用 $f(i,0)$ 表示两边都没有雷的方案数，$f(i,1)$ 表示两边都有雷的方案数，$f(i,2)$ 表示左边有雷，右边没雷的方案数，$f(i,3)$ 表示左边没雷，右边有雷的方案数，$f(i,4)$ 表示这个点就是雷。

考虑转移，没写的即为没可能出现。这一位的字符为：

- `0`：$f(i,0)=f(i-1,0)+f(i-1,2)$。
- `1`：$f(i,2)=f(i-1,4)$，$f(i,3)=f(i-1,0)+f(i-1,2)$。
- `2`：$f(i,1)=f(i-1,f(i-1,4))$。
- `*`：$f(i,4)=f(i-1,1)+f(i-1,3)+f(i-1,4)$。
- `?`：$f(i,0)=f(i-1,0)+f(i-1,2)$，$f(i,1)=f(i,2)=f(i-1,4)$，$f(i,3)=f(i-1,0)+f(i-1,2)$，$f(i,4)=f(i-1,1)+f(i-1,3)+f(i-1,4)$。

最后答案就是 $f(n,0)+f(n,2)+f(n,4)$。

注意初始值：$f(0,0)=f(0,3)=1$。

---

## 作者：xinruian (赞：2)



### **题意**

给定一个长度为 $n$ 的串 $s$，由 `0`，`1`，`2`，`*`，`?` 组成。求将 `?` 替换成其他字符中的任意一个，使原串合法的方案数。将 `*` 视为雷，数字就是数字，合法为扫雷地图的合法性。

### **思路**

本题求最终可以有多少合法的串，不难看出每一个状态都是由前一个状态转移过来，所以我们可以采用线性 DP 求解。（我想到的是回溯，其实是在大佬指点下做出来的。）

#### 1.状态表示：

每一个位置都有 “是炸弹” 和 “不是炸弹” 两种状态的可能，但是仅有两种状态是不够的，我们定义一个 `f[N][4]` 数组。`f[i][j]` 表示从字符串起始位置开始到 $i$ 位置满足 $j$ 条件的合法串的数目，具体含义如下：

- `f[i][0] ` 表示 `s[i] ` 处不是炸弹， `s[i+1]` 处也不是炸弹。
- `f[i][1] ` 表示 `s[i] ` 处不是炸弹， `s[i+1]` 处是炸弹。
- `f[i][2]` 表示 `s[i] ` 处是炸弹， `s[i+1]` 处不是炸弹。
- `f[i][3] ` 表示 `s[i]` 处是炸弹， ` s[i+1]` 处也是炸弹。

#### 2.状态计算

1. 当 `s[i] == '0'` 时：

   ```cpp
   f[i][0] = f[i-1][0];
   ```

2. 当 `s[i] == '1'` 时：

   ```cpp
   f[i][0] = f[i-1][2]; 
   f[i][1] = f[i-1][0];
   ```

3. 当 `s[i] == '2'` 时：

   ```cpp
   f[i][1] = f[i-1][2];
   ```

4. 当 `s[i] == '*'` 时：

   ```cpp
   f[i][2] = (f[i-1][1] + f[i-1][3]) % mod;
   f[i][3] = (f[i-1][1] + f[i-1][3]) % mod;
   ```

5. 当 `s[i] == '?'` 时：

   ```cpp
   f[i][0] = (f[i-1][0] + f[i-1][2]) % mod ;
   f[i][1] = (f[i-1][0] + f[i-1][2]) % mod ;
   f[i][2] = (f[i-1][3] + f[i-1][1]) % mod ;
   f[i][3] = (f[i-1][1] + f[i-1][3]) % mod ;
   ```

#### 3. 求解

我们计算 `s[1], s[2], ..., s[n-1]` 的各个状态的数值，然后通过 `s[n]` 的值来判断答案。

1. 当 `s[n] == 0` 时，也就说明前一个数必然不是“炸弹”。

   ```cpp
   ans = f[n-1][0];
   ```

2. 当 `s[n] == 1` 时，也就说明前一个数必然是“炸弹”。

   ```cpp
   ans = f[n-1][2];
   ```

3. 当 `s[n] == 2` 时，末尾不可能有两个“炸弹”。

   ```cpp
   ans = 0;
   ```

4. 当 `s[n] == *` 时，如下。

   ```cpp
   ans = (f[n-1][1] + f[n-1][3]) % mod;
   ```

5. 当 `s[n] == ？` 时，上一个位置的情况都有可能出现。

   ```cpp
   ans = (f[n-1][0] + f[n-1][1] + f[n-1][2] + f[n-1][3]) % mod;
   ```

### 代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e6 + 10;
const int mod = 1e9 + 7;

typedef long long LL;

char s[N];
LL f[N][4];

int main() {
    cin >> s + 1;
    int n = strlen(s + 1);
    // 初始化
    f[0][0] = 1, f[0][1] = 1;

    for (int i = 1; i < n; i ++) {
        if (s[i] == '0')
            f[i][0] = f[i-1][0];
        else if (s[i] == '1')
        {
            f[i][0] = f[i-1][2];
            f[i][1] = f[i-1][0];
        }
        else if (s[i] == '2')
            f[i][1] = f[i-1][2];
        else if (s[i] == '*')
        {
            f[i][2] = (f[i-1][1] + f[i-1][3]) % mod;
            f[i][3] = (f[i-1][1] + f[i-1][3]) % mod;
        }
        else
        {
            f[i][0] = (f[i-1][0] + f[i-1][2]) % mod ;
            f[i][1] = (f[i-1][0] + f[i-1][2]) % mod ;
            f[i][2] = (f[i-1][3] + f[i-1][1]) % mod ;
            f[i][3] = (f[i-1][1] + f[i-1][3]) % mod ;
        }
    }
    int ans;
    if (s[n] == '0')
        ans = f[n-1][0];
    else if (s[n] == '1')
        ans = f[n-1][2];
    else if (s[n] == '2')
        ans = 0;
    else if (s[n] == '*')
        ans = (f[n-1][1] + f[n-1][3]) % mod;
    else
        ans = (f[n-1][0] + f[n-1][1] + f[n-1][2] + f[n-1][3]) % mod;
    cout << ans << endl;

    return 0;
}
```



---

## 作者：huhexuan (赞：2)

这个思路题解里都没有，但也比题解的思路更不优秀。

还是动态规划，开三维数组，$dp_{i,j,k}$ 代表第 $i$ 位填 $j$，第 $i-1$ 位为 $k$。

转移方程为：```dp[i][j][k]=(dp[i][j][k]+dp[i-1][k][t])```。

因为我们存的是 $i-1$ 位，所以答案应为 $n+1$ 位，即```dp[n+1][0][1]+dp[n+1][0][0]+dp[n+1][1][3]```。

大部分细节都在代码中，代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
int dp[1000005][5][5];
const int MOD=1000000007;
char a[4]={'0','1','2','3'};
bool check(int j,int k,int t)
{
	if(k==0)
	{
		if((t==0&&j==0)||(t==0&&j==1)||(t==1&&j==0)||(t==1&&j==1)) return 1;
	}
	if(k==1)
	{
		if((t==0&&j==3)||(t==1&&j==3)||(t==3&&j==0)||(t==3&&j==1)) return 1;
	}
	if(k==2)
	{
	    if(t==3&&j==3) return 1;
	}
	if(k==3)
	{
		if((t==1&&j==1)||(t==1&&j==2)||(t==1&&j==3)||(t==2&&j==1)||(t==2&&j==2)||(t==2&&j==3)||(t==3&&j==1)||(t==3&&j==2)||(t==3&&j==3)) return 1;
	}
	return 0;
}
signed main()
{
	cin>>s;
	if(s[0]=='2')
	{
		cout<<0;
		return 0;
	}
	int n=s.size();
	for(int i=0;i<n;i++) 
	{
		if(s[i]=='*') s[i]='3';
	}
	if(s[0]=='?') dp[1][1][0]=dp[1][0][0]=dp[1][3][1]=1;
	if(s[0]=='0') dp[1][0][0]=1;
	if(s[0]=='1') dp[1][1][0]=1;
	if(s[0]=='3') dp[1][3][1]=1;
	for(int i=2;i<=n+1;i++)
	{
		for(int j=0;j<=3;j++)//i
		{
			if(i==n+1&&j!=0&&j!=1) continue;
			if(i!=n+1&&s[i-1]!='?'&&s[i-1]!=a[j]) continue;
			for(int k=0;k<=3;k++)//i-1
			{
				for(int t=0;t<=3;t++)//i-2
				{
					if(check(j,k,t))
					{
						dp[i][j][k]=(dp[i][j][k]+dp[i-1][k][t])%MOD;
					}
				}
			}
		}
	}
	cout<<(dp[n+1][0][1]+dp[n+1][0][0]+dp[n+1][1][3])%MOD;
	return 0;
}

---

## 作者：Itst (赞：2)

### 看起来很像$DP$对吧
### 但是如果我们仔细分析一下性质就会发现：
### $0$和$2$能够确定周围是否有雷
### 所以在利用完$0$和$2$的信息之后，又可以推出一部分$1$的信息，不确定的信息就只有$?$与夹在$?$中间的$1$（即形如$?1?$的$1$）两种
### 对于每一个$?$都能够产生$2$的贡献，而对于每一个夹在$?$中间的$1$都会产生$\frac{1}{2}$的贡献（因为一边确定了另一边也确定了），进行计数之后快速幂就可以得到答案了
### 实际上根本不需要$DP$
```cpp
#include<bits/stdc++.h>
#define NO {cout << 0; return 0;}
//This code is written by Itst
using namespace std;

inline int read(){
    int a = 0;
    bool f = 0;
    char c = getchar();
    while(c != EOF && !isdigit(c)){
        if(c == '-')
            f = 1;
        c = getchar();
    }
    while(c != EOF && isdigit(c)){
        a = (a << 3) + (a << 1) + (c ^ '0');
        c = getchar();
    }
    return f ? -a : a;
}

const int MAXN = 1000010 , MOD = 1e9 + 7;
char s[MAXN];
int now[MAXN] , N;

inline int poww(long long a , int b){
    int times = 1;
    while(b){
        if(b & 1)
            times = times * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return times;
}

int main(){
#ifndef ONLINE_JUDGE
    freopen("404D.in" , "r" , stdin);
    //freopen("404D.out" , "w" , stdout);
#endif
    scanf("%s" , s + 1);
    N = strlen(s + 1);
    now[0] = now[N + 1] = 1;
    for(int i = 1 ; i <= N ; ++i)
        if(s[i] == '*'){
            if(now[i] == 1)
                NO
            else
                now[i] = -1;
        }
        else
            if(s[i] != '?'){
                if(now[i] == -1)
                    NO
                now[i] = 1;
                if(s[i] == '2')
                    if(now[i - 1] == 1)
                        NO
                    else
                        now[i - 1] = now[i + 1] = -1;
                else
                    if(s[i] == '0')
                        if(now[i - 1] == -1)
                            NO
                        else
                            now[i - 1] = now[i + 1] = 1;
            }
    for(int i = 1 ; i <= N ; ++i)
        if(s[i] == '1')
            if(now[i - 1] == -1)
                if(now[i + 1] == -1)
                    NO
                else
                    now[i + 1] = 1;
            else
                if(now[i - 1] == 1)
                    if(now[i + 1] == 1)
                        NO
                    else
                        now[i + 1] = -1;
    for(int i = N ; i ; --i)
        if(s[i] == '1')
            if(now[i + 1] == -1)
                if(now[i - 1] == -1)
                    NO
                else
                    now[i - 1] = 1;
            else
                if(now[i + 1] == 1)
                    if(now[i - 1] == 1)
                        NO
                    else
                        now[i - 1] = -1;
    int cnt = 0;
    for(int i = 1 ; i <= N ; i++)
        if(s[i] == '1' && !now[i - 1] && !now[i + 1])
            --cnt;
        else
            if(!now[i])
                ++cnt;
    cout << poww(2 , cnt);
    return 0;
}

```

---

## 作者：Austin0116 (赞：1)

# 分析

首先，这题根据数据范围 $n \le 10^6 $，我们就基本可以确定算法时间复杂度差不多是 $O(n)$ 的。其次，由于是求方案数，所以考虑线性动态规划。

然后我们就可以列出状态：

`f[i][0]`：表示在第 $i$ 个字符两边都没有地雷的情况下前 $i$ 个字符的方案。

`f[i][1]`：表示在第 $i$ 个字符两边都有地雷的情况下前 $i$ 个字符的方案。

`f[i][2]`：表示在第 $i$ 个字符左边有地雷，右边没地雷的情况下前 $i$ 个字符的方案。

`f[i][3]`：表示在第 $i$ 个字符右边有地雷，左边没地雷的情况下前 $i$ 个字符的方案。

`f[i][4]`：表示在第 $i$ 个字符这位是地雷，两边随便的情况下前 $i$ 个字符的方案。

转移方程也很简单，可以对照上面来理解。

```cpp
f[i][0]=(f[i-1][0]+f[i-1][2])%p;
//若 s[i]='0'
f[i][2]=f[i-1][4];
f[i][3]=(f[i-1][0]+f[i-1][2])%p;
//若 s[i]='1'
f[i][1]=f[i-1][4];
//若 s[i]='2'
f[i][4]=((f[i-1][4]+f[i-1][1])%p+f[i-1][3])%p;
//若 s[i]为'*'
f[i][0]=(f[i-1][0]+f[i-1][2])%p;
f[i][1]=f[i-1][4];
f[i][2]=f[i-1][4];
f[i][3]=(f[i-1][0]+f[i-1][2])%p;
f[i][4]=((f[i-1][4]+f[i-1][1])%p+f[i-1][3])%p;
//若 s[i]为'?'
```

初始化时我们可以将 `f[0][3]=f[0][0]=1`，方便后面是地雷或不是地雷的计算。

最后统计答案时直接输出 `f[i][0]+f[i][2]+f[i][4]`。

**注意：边算边取模或开 long long。**

# 代码


```cpp
#include <bits/stdc++.h>
#define p 1000000007
using namespace std;
char s[1000005];
int n,f[1000005][5];
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	f[0][3]=f[0][0]=1;//初始化
	for(int i=1;i<=n;i++){//DP转移
		if(s[i]=='0') f[i][0]=(f[i-1][0]+f[i-1][2])%p;
		if(s[i]=='1'){
			f[i][2]=f[i-1][4];
			f[i][3]=(f[i-1][0]+f[i-1][2])%p;
		}
		if(s[i]=='2') f[i][1]=f[i-1][4];
		if(s[i]=='*') f[i][4]=((f[i-1][4]+f[i-1][1])%p+f[i-1][3])%p;
		if(s[i]=='?'){
			f[i][0]=(f[i-1][0]+f[i-1][2])%p;
			f[i][1]=f[i-1][4];
			f[i][2]=f[i-1][4];
			f[i][3]=(f[i-1][0]+f[i-1][2])%p;
			f[i][4]=((f[i-1][4]+f[i-1][1])%p+f[i-1][3])%p;
		}
	}
	printf("%d",((f[n][0]+f[n][2])%p+f[n][4])%p);//最后答案
	return 0;
}
```

---

## 作者：daniEl_lElE (赞：1)

## 思路

考虑 $dp_{i,j}$ 表示看到第 $i$ 位状态为 $j$ 的方案数。

思考我们可能会有哪些状态：首先可能上一个是 $\texttt{0,*,2}$。即有 $\texttt{0,2}$ 个雷的空格和单独一个雷 $\texttt{*}$。但是当我们考虑前一个是一个 $\texttt{1}$ 的空格时，可能在他之前就有一个雷，也可能他之前没有雷（也就是第 $i+1$ 位必须有雷）。

那么，状态分成了 $5$ 类：

* $dp_{i,1}$ 且 $s_i=0$。
* $dp_{i,2}$ 且 $s_i=*$。
* $dp_{i,3}$ 且 $s_i=2$。
* $dp_{i,4}$ 且 $s_i=1$ 且 $s_{i-1}=*$。
* $dp_{i,5}$ 且 $s_i=1$ 且 $s_{i-1}\not=*$。

考虑转移，如果上一个是 $0$，那么转移的必须要求这里不是雷。

上一个是雷的话，说明这里不能是 $0$。

上一个是 $2$，这里必须是雷。

上一个是 $1$ 并且已经有雷了，这里就没能有雷了。否则这里必须是雷。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int dp[1000005][6]; 
signed main(){
	string s;
	cin>>s;
	int n=s.size();
	s=" "+s;
	if(s[1]=='?'){
		dp[1][1]=1;
		dp[1][2]=1;
		dp[1][5]=1;
	}
	else{
		if(s[1]=='0') dp[1][1]=1;
		if(s[1]=='*') dp[1][2]=1;
		if(s[1]=='1') dp[1][5]=1;
	}
	for(int i=2;i<=n;i++){
		//dp i-1,1
		if(s[i]=='0'||s[i]=='?') dp[i][1]=(dp[i][1]+dp[i-1][1])%mod;
		if(s[i]=='1'||s[i]=='?') dp[i][5]=(dp[i][5]+dp[i-1][1])%mod;
		//dp i-1,2
		if(s[i]=='*'||s[i]=='?') dp[i][2]=(dp[i][2]+dp[i-1][2])%mod;
		if(s[i]=='2'||s[i]=='?') dp[i][3]=(dp[i][3]+dp[i-1][2])%mod;
		if(s[i]=='1'||s[i]=='?') dp[i][4]=(dp[i][4]+dp[i-1][2])%mod;
		//dp i-1,3
		if(s[i]=='*'||s[i]=='?') dp[i][2]=(dp[i][2]+dp[i-1][3])%mod;
		//dp i-1,4
		if(s[i]=='0'||s[i]=='?') dp[i][1]=(dp[i][1]+dp[i-1][4])%mod;
		if(s[i]=='1'||s[i]=='?') dp[i][5]=(dp[i][5]+dp[i-1][4])%mod;
		//dp i-1,5
		if(s[i]=='*'||s[i]=='?') dp[i][2]=(dp[i][2]+dp[i-1][5])%mod;
	}
	cout<<(dp[n][1]+dp[n][2]+dp[n][4])%mod;
	return 0;
}
```

---

## 作者：Hog_Dawa_IOI (赞：1)

### 题意简述
相信大家都玩过扫雷，这里的扫雷和我们玩的差不多，不过是一维扫雷，所以棋盘上除了星号（表示雷）和问号（表示这个格子还没被翻开）以外，只有零、一、二这三个数字。   
那么问题就来了：给你一个字符串，长度为 $n$（$ 1\ \leq\ N\ \leq\ 10^6 $），表示棋盘，求将问号改为其它四种字符，使棋盘合法的方案数。   
此处的“合法”就是说每个数字两旁的雷的数量就是这个数字，如数字零和数字二中间夹着一个星号就是非法的，而两个数字一中间夹着一个星号就是合法的。用扫雷的规则类比一下就会很快明白。    
答案对 $10^9+7$ 取模。    
### 思路分析
使用递推（或者说动规）求解。

##### **首先，定义 $f_{i,j}$ 表示第 $i$ 个位置第 $j$ 种情况的方案数。**          
各种情况具体如下：     
1. $f_{i,1}$：第 $i$ 个、第 $i-1$ 个、第 $i+1$ 个位置都没有雷（对应数字零的情况，以下简称“都没有”）。    
2. $f_{i,2}$：第 $i$ 个位置没有雷，第 $i-1$ 个和第 $i+1$ 个位置有雷（对应数字二的情况，以下简称“都有”）。    
3. $f_{i,3}$：第 $i$ 个位置有雷，第 $i-1$ 个和第 $i+1$ 个位置随便（对应星号的情况，以下简称“本身是”）。    
4. $f_{i,4}$：第 $i$ 个、第 $i+1$ 个位置没有雷，第 $i-1$ 个位置有雷（对应数字一的情况，以下简称“左边有”）。    
5. $f_{i,5}$：第 $i$ 个、第 $i-1$ 个位置没有雷，第 $i+1$ 个位置有雷（也对应数字一的情况，以下简称“右边有”）。    

看得出来数字一可能有两种情况，左边有雷或者右边有雷，讨论时需要分开。

##### **然后确定初始值，给 $f$ 数组初始化。**
为了方便，我们从第 $0$ 个位置开始初始化。   
由于第 $1$ 个位置可以是雷也可以不是雷，同时第 $0$ 个位置和第 $-1$ 个位置不能是雷（如果有雷那就离离原上谱了），而满足这个约束的有“都没有”和“右边有”，所以 $f_{0,1}=f_{0,5}=1$。   
需要注意的是，如果不加这个初始化为 $1$ 的操作，那么输出的答案永远是 $0$。  
数组里面的元素本来都是 $0$ 啊，你无论怎样加来加去不还是 $0$？   
~~所以好心提醒大家，在做递推题或者动规题的时候，一定要注意初始化！~~

##### **接下来就是每道递推题或动规题都会经历的过程：找递推式，或者说状态转移方程。**   
计算有多少种方案。字符不同，计算的方法也不同。统计当前位置属于哪种情况时的方案数，十分明显需要分类讨论。   
下面开始推式子吧！    
此处设当前位置为第 $i$ 个位置。
1. **当前位置是数字零**（对应 $f_{i,1}$ 的情况，即“都没有”）。   
要求上一个位置不能是雷，而且当前位置也不能是雷。
满足这个约束的情况有两个，分别是“**都没有**”和“**左边有**”（这里的“左边有”是对于第 $i-1$ 个位置而言，即第 $i-2$ 个位置是雷，第 $i-1$ 个位置和第 $i$ 个位置不是雷），这两种情况都可以为当前状态做贡献。     
所以此时 $f_{i,1}=f_{i-1,1}+f_{i-1,4}$。

------------

2. **当前位置是数字一**。   
这里就分两种情况了，分别是 $f_{i,4}$（“左边有”）和 $f_{i,5}$（“右边有”）。    
**考虑“左边有”**，此时当前位置的上一个位置就要是雷，即只有“**本身是**”的情况会对当前状态做贡献。   
所以 $f_{i,4}=f_{i-1,3}$。  
接着**考虑“右边有”**，此时当前位置的上一个位置就不能是雷，并且当前位置也不能是雷，即“**都没有**”和“**左边有**”的情况会对当前状态做贡献。  
所以此时 $f_{i,5}=f_{i-1,1}+f_{i-1,4}$。

------------

3. **当前位置是数字二**（对应 $f_{i,2}$ 的情况，即“都有”）。   
这种情况意味着第 $i-1$ 个位置是雷，满足这个约束的只有“**本身是**”这个情况。   
所以此时 $f_{i,2}=f_{i-1,3}$。

------------

4. **当前位置是星号**（对应 $f_{i,3}$ 的情况，即“本身是”）。  
这**意味着且仅意味着**当前位置一定是雷，而上一个位置是不是雷都**无所谓**。   
换句话说，就是对于第 $i-1$ 个位置来说，它的右边需要是雷，而这个地方是不是雷都无所谓。   
满足这个约束的有“**都有**”、“**本身是**”（当前位置有雷并不代表它右边的位置就没有雷，它右边的位置也可以是有雷的，就是两个雷并排在一起的情况）和“**右边有**”，这三个情况可以为答案做出贡献。   
所以此时 $f_{i,3}=f_{i-1,2}+f_{i-1,3}+f_{i-1,5}$。 
5. **当前位置是问号**。    
这个地方我们就需要分别计算了，毕竟四种字符都有可能成为当前位置的字符，不像前面所提到的情况，确定的字符已经让这个位置的情况确定了。     
（当然了有些情况是不存在的，但是不影响问题的答案。）   
直接把上面提到的所有状态转移方程（或者叫递推式？）全部照搬即可，即此时         

$$\begin{cases}f_{i,1}=f_{i-1,1}+f_{i-1,4},\\f_{i,2}=f_{i-1,3},\\f_{i,3}=f_{i-1,2}+f_{i-1,3}+f_{i-1,5},\\f_{i,4}=f_{i-1,3},\\f_{i,5}=f_{i-1,1}+f_{i-1,4}.\end{cases}$$

------------

##### **最后是输出答案。**    
对于最后一个格子，可能的情况有“都有”、“本身是”和“左边有”。    
因为第 $n+1$ 个位置肯定不是雷，所以“都有”和“右边有”的情况要排除。   
那么最终的答案就很明显了，是 $f_{n,1}+f_{n,3}+f_{n,4}$ 的值。


### 代码展示
如果能看懂上面写的话，理解下面的代码应该也不难了。  
最后祝愿大家能够又收获一道绿题！
```cpp
#include<stdio.h>
#include<string.h>
int n;long long f[1000005][10];
char s[1000005];
int main()
{
    scanf("%s",s+1),n=strlen(s+1);//s+1为s数组的地址的起始位置往后一个位置，即输入的第一个字符会存进s[1]而不是s[0]中
    f[0][1]=f[0][5]=1;
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='?') f[i][1]=(f[i-1][1]+f[i-1][4])%int(1e9+7),
        f[i][2]=f[i-1][3],
        f[i][3]=(f[i-1][2]+f[i-1][3]+f[i-1][5])%int(1e9+7),
        f[i][4]=f[i-1][3],
        f[i][5]=(f[i-1][1]+f[i-1][4])%int(1e9+7);
        //1e9+7在C++中默认为浮点数，要转化为int类型才能作为模数
        else if(s[i]=='0') f[i][1]=(f[i-1][1]+f[i-1][4])%int(1e9+7);
        else if(s[i]=='1') f[i][4]=f[i-1][3],f[i][5]=(f[i-1][1]+f[i-1][4])%int(1e9+7);
        else if(s[i]=='2') f[i][2]=f[i-1][3];
        else if(s[i]=='*') f[i][3]=(f[i-1][2]+f[i-1][3]+f[i-1][5])%int(1e9+7);
    }
    printf("%lld",(f[n][1]+f[n][3]+f[n][4])%int(1e9+7));
}
```

更新状态：    
$2023.3.25$：初稿。    
$2023.6.23$：发现此题由紫降绿了，更改了祝福语。~~然而被打回了。~~     
$2023.7.1$：把所有字符串改成了汉字，~~避免被打回~~。   
$2024.3.2$：文章区更新，$ \LaTeX $ 炸了，修改了行间公式。

---

## 作者：KID2695 (赞：0)

这个题目唯一的难点在于考虑到第 $i$ 位的时候不确定第 $i+1$ 位的情况，所以不妨记录一下，设 $f_{i,0/1/2}$ 表示考虑到第 $i$ 位，在它的周围还需要填的雷的数量，特别的，$f_{i,2}$ 表示这就是雷。

然后转移就十分显然了。当第 $i$ 位可以填 $0$ 时，有 $f_{i,0}=f_{i,0}+f_{i-1,0}$，当第 $i$ 位可以填 $1$ 时，有 $f_{i,1}=f_{i,1}+f_{i-1,0}$ 同时 $f_{i,0}=f_{i,0}+f_{i-1,2}$，当第 $i$ 位可以填 $2$ 时，有 $f_{i,1}=f_{i,1}+f_{i-1,2}$，当第 $i$ 位可以填雷时，有 $f_{i,2}=f_{i,2}+f_{i-1,2}+f_{i-1,1}$。应该不需要解释了吧，参照状态的定义很容易理解的。

初值也很好设置，直接看代码就行了，答案就是 $f_{n,0}+f_{n,2}$。

```cpp
#define int long long

signed main(){
	int n;
	scanf("%s",s+1);
	n=strlen(s+1);
	if(s[1]=='?')f[1][0]=f[1][1]=f[1][2]=1;
	if(s[1]=='*')f[1][2]=1;
	if(s[1]=='1')f[1][1]=1;
	if(s[1]=='0')f[1][0]=1;
	if(s[1]=='2'){
		puts("0");
		return 0;
	}
	for(int i=2;i<=n;i++){
		if(s[i]=='?'||s[i]=='0')f[i][0]=(f[i][0]+f[i-1][0])%P;
		if(s[i]=='?'||s[i]=='1')f[i][1]=(f[i][1]+f[i-1][0])%P,f[i][0]=(f[i][0]+f[i-1][2])%P;
		if(s[i]=='?'||s[i]=='2')f[i][1]=(f[i][1]+f[i-1][2])%P;
		if(s[i]=='?'||s[i]=='*')f[i][2]=(f[i][2]+f[i-1][2]+f[i-1][1])%P;
	}
	int ans=(f[n][0]+f[n][2])%P;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Rolling_star (赞：0)



设 $f_{i,0/1/2}$ 为第 $i$ 个位置，后面要有 $0/1$ 个雷，或者这个位置为雷的方案数。

考虑对于每种字符每个状态的转移：

- 如果该点为 `0`，则转移为 $f_{i,0}=f_{i-1,0}$。
- 如果该点为 `1`，则转移为 $f_{i,0}=f_{i-1,2}$，$f_{i,1}=f_{i-1,0}$。
- 如果该点为 `2`，则转移为 $f_{i,1}=f_{i-1,2}$。
- 如果该点为 `*`，则转移为 $f_{i,2}=f_{i-1,2}+f_{i-1,1}$。
- 如果该点为 `?`，上述转移累加即可。

初始状态为 $f_{0,0}=f_{0,1}=1$，后一个是为了第一个位置能为雷。

Code：
```cpp
#include<bits/stdc++.h>
#define N 1000005
#define ll long long
using namespace std;

const ll p=1e9+7;
char s[N];int n;
int f[N][3],tmp[N];

int main(){
    scanf("%s",s+1);
    n=strlen(s+1);
    tmp['0']=0;tmp['1']=1;tmp['2']=2;
    tmp['*']=3;tmp['?']=4;
    f[0][0]=1;f[0][1]=1;
    for(int i=1;i<=n;i++){
        if(tmp[s[i]]==0||tmp[s[i]]==4) f[i][0]+=f[i-1][0];
        if(tmp[s[i]]==1||tmp[s[i]]==4) f[i][0]+=f[i-1][2],f[i][1]+=f[i-1][0];
        if(tmp[s[i]]==2||tmp[s[i]]==4) f[i][1]+=f[i-1][2];
        if(tmp[s[i]]==3||tmp[s[i]]==4) f[i][2]+=(f[i-1][1]+f[i-1][2])%p;
        f[i][0]%=p;f[i][1]%=p;f[i][2]%=p;
    }
    cout<<(f[n][0]+f[n][2])%p<<endl;
}
```

---

## 作者：MspAInt (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF404D)

有启发性的题。

考虑 dp。第一眼我设计了这个非常显然的状态：

$dp_{i,j}$（$0\leq j\leq4$）表示对于字符串前 $i$ 位，且第 $i$ 位为 `0`，`1`，`2`，`*`，`?`（分别对应 $j=0,j=1\dots j=4$）的情况下，将该串变为合法串的方案数（$\bmod\ 10^9+7$）。

但是由于当该位为 `0` 或 `2` 时，需要未处理处的贡献，所以难以转移。

因此尝试记录相邻两位的状态。

当然我们无法预知后一位将是怎样的情况，只能确定仅有两种可能：下一位是雷，下一位不是雷。特别地，当自己就是雷时，和其它位无关（不代表其它位和它无关，以后可能会根据其更新），因此再记一个状态：自己就是雷。

因此 dp 状态改为： $dp_{i,j}$ 表示对于字符串前 $i$ 位，第 $i+1$ 位不是雷（$j=0$），是雷（$j=1$）；第 $i$ 位是雷（$j=2$）。

此时，我们可以根据该位的状态、后一位我们猜测的状态，来推出上一位的状态，确定了相邻两位。即使后一位猜错了也没事，因为当处理到那里时，它只会取走与自己有关的状态，不会出现错误贡献。

这下转移方程就很显然了，根据目前要转移的状态可得，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10,mod=1000000007;
char s[N];
int n,dp[N][3];
signed main()
{
    scanf("%s",s+1);n=strlen(s+1);
    dp[0][0]=dp[0][1]=1;
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='0')
        {
            dp[i][0]=dp[i-1][0];
        }
        else if(s[i]=='1')
        {
            dp[i][1]=dp[i-1][0];
            dp[i][0]=dp[i-1][2];
        }
        else if(s[i]=='2')
        {
            dp[i][1]=dp[i-1][2];
        }
        else if(s[i]=='*')
        {
            dp[i][2]=dp[i-1][1]+dp[i-1][2];
        }
        else if(s[i]=='?')
        {
            dp[i][0]=dp[i-1][0]+dp[i-1][2];
            dp[i][1]=dp[i-1][0]+dp[i-1][2];
            dp[i][2]=dp[i-1][1]+dp[i-1][2];
            //问号可以是任何一种字符，所以全部转移。
        }
        dp[i][0]%=mod;
        dp[i][1]%=mod;
        dp[i][2]%=mod;
    }
    printf("%d\n",(dp[n][0]+dp[n][2])%mod);
    return 0;
}
```

[record](https://www.luogu.com.cn/record/109425590)

---

## 作者：FriendlyTiger_1015 (赞：0)

# CF404D Minesweeper 1D

蒟蒻发的第二篇题解。

[See on Luogu Blog](https://ryanli66699.blog.luogu.org/ti-xie-cf404d-minesweeper-1d-ti-xie)

**题意**

------------

   给定一个串，由 `0` ，`1` ，`2` ， `*` ，`?` 组成。求将 `?` 替换成其他字符中的任意一个，使原串合法的方案数。将  `*` 视为雷，数字就是数字，合法为扫雷地图的合法性。

PS：数字 $i$ 表示以 $i$ 为中心的九宫格中只有  $i$ 个雷。如 `2*` 是非法的，而 `*2*` 是合法的。

**分析**

---

一看见这种类型的题，您能想到啥？不错不错，一眼看上去就是动规！

**题解**


------------



先来个动规数组数组 $d_{n,5}$ 。

通过了解题意很显然的发现：

- $d_{i,0}$——$i$ 位有雷，$i-1$、$i+1$ 随便。
 
- $d_{i,1}$——$i$ 位没雷，$i-1$、$i+1$ 没雷。
 
- $d_{i,2}$——$i$ 位没雷，$i-1$ 没雷、$i+1$ 有雷。
 
- $d_{i,3}$——$i$ 位没雷，$i-1$ 有雷、$i+1$ 没雷。
 
- $d_{i,4}$——$i$ 位没雷，$i-1$、$i+1$ 有雷。
 
**开始转移**
 
令 $s$ 为字符串，初始化——
 


 $d_{0,1} = 1 $：方便对于第 1 位**没有**雷的情况进行转移！
 
$d_{0,2} = 1 $：方便对于第 1 位**有雷**的情况进行转移！
 
---

 _转移核心代码：_ （**详细推演过程见注释**） 

```cpp
#define mod 1e9 + 7//取模数
 
if (s[i] == '*')// 如果s[i]是雷时

    d[i][0] = ( ( d[i-1][2] + d[i-1][4] ) % mod + d[i-1][0] ) % mod;

if (s[i] == '0')//s[i-1] != '*' && s[i+1] != '*' 。（d[i][1] . d[i][3] 情况）

    d[i][1] = ( d[i-1][1] + d[i-1][3] ) % mod;

if (s[i] == '1')//两种情况，一种s[i-1] == '*'，一种s[i-1] != '*'，综上分析出下列代码

    d[i][2] = ( d[i-1][1] + d[i-1][3] ) % mod;
    d[i][3] = d[i-1][0];

if (s[i] == '2')//s[i-1] == '*' && s[i+1] == '*' 。（d[i][4]情况 ）

    d[i][4] = d[i-1][0]
```

对于我来说，转移公式还是蛮好推出来的。其他代码我就不展示了，希望大家养成自己写代码的习惯，去攻克这道题！








---


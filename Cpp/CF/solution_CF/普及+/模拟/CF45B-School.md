# School

## 题目描述

CSYZ学校1820班有n个学生， 每个人都只有一个朋友，我们用 G(i) 表示第 i个人的朋友，但是需要注意， 自己朋友的朋友不一定是自己，即 G(G(i)) 不一定等于i；   

由于学校总是会出现各种新闻信息， 而同学们十分热衷于了解这些新闻，所以大家都会把自己知道的新闻分享给自己的好朋(ji)友(lao)； 

现在会出现以下的行为： 

在第 i 天，第 A[i] 个学生Jean了解到热度为 B[i] (B[i]>=1) 的新闻，此时Jean会马上与她的朋友分享这个新闻，而此时新闻热度已减为 B[i] – 1 ，Jean的朋友也会进行同样的转述，所以，Jean的朋友的朋友收到新闻时热度已减为 B[i] – 2 . 这样的行为会一直持续到新闻热度为0，因为这时已经没有人想去分享它了.
 
也就是说：如果一个人 x 收到了一个热度为 y(y!=0) 的新闻，他就会将其分享给自己的好朋友G(i)，这个新闻热度对于他的的朋友来说就是 y – 1, 如果可能的话，这种行为就会一直持续下去.

但我们需要注意到，一个人可能会在一天内不止一次的收到同一条新闻，但此时新闻热度已不同。因此，等级为B[i] 的新闻会经过B[i] 次的转述。

你的任务是计算出 res[i] 的值——在第i天有多少学生了解到m天中他们的第一个新闻；

B[i] 的值在初始时给出，而 A[i] 的值由下面的公式得出 ：   
![]( https://cdn.luogu.org/upload/vjudge_pic/CF45B/87d3ac8c2d9d9c2f898cd922887b2d5b34a41da4.png)   

res[0] = 0；
（v[i]为一些给定的整数）；

## 样例 #1

### 输入

```
3 4
2 3 1
1 2 3 4
1 2 3 4
```

### 输出

```
1
1
1
0
```

## 样例 #2

### 输入

```
8 6
7 6 4 2 3 5 5 7
10 4 3 8 9 1
1 1 1 2 2 2
```

### 输出

```
1
1
1
2
1
1
```

# 题解

## 作者：小杨小小杨 (赞：0)

## 前言
复杂度是玄学的，过是能过的。


（其实也不是玄学，似乎复杂度是能分析出来的）
## 题意
就是一大堆小朋友玩分糖，当前这个人如果有 $x$ 个糖，他就会拿走一个，然后让他的朋友拿到 $x-14$ 个。   
好了这就是核心问题。
## 思路
搜索都学过吧。

由于每个人都只有一个朋友，所以可以直接循环去找。运用类似记忆化搜索的思路，保存每一个位置最大得热度，如果当前的热度过小，就停止搜索，不然就继续搜索下去。如果当前这个人是第一次知道消息，那就把这个能传的人数增加。   

记得初始化！！！   

（不支持hack数据，原OJ能通过）
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,a,sum,t,g[100010],v[100010],b[100010],f[100010];
int main(){
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;i++) scanf("%d",&g[i]);
	for (i=1;i<=m;i++) scanf("%d",&v[i]);
	for (i=1;i<=m;i++) scanf("%d",&b[i]);
	for (i=1;i<=m;i++){
		a=(v[i]+sum-1)%n+1;t=b[i];sum=0;
		while (f[a]<t&&t!=0){
			if (!f[a]) sum++;
			f[a]=t;a=g[a];t--;
		}
		printf("%d\n",sum);
	}
	return 0;
} 
```

---

## 作者：_edge_ (赞：0)

关于时间复杂度这么一回事情，我个人认为它不是很玄学，至少还是能分析得出来的。

考虑这样一个问题，因为它要求强制在线，并且题目给定的是一个基环树，必定每个点只能被访问一次，因为也只有第一次才有效果。

对于这个操作，我们发现暴力遍历所有的还是无法通过此题，考虑进行优化。

如果我们可以使得每个点都只能遍历一次，那肯定是正确的复杂度，在这里我们尝试用一种类似于链表的，记录当前节点走到的最近的没访问过的点，同时记录长度即可。

我们来分析一下这个复杂度。

我们发现对于所有的操作来说，每个点都最多最多遍历到一次，因此可以得出时间复杂度是 $O(n+m)$ 的。

~~搞不懂强制在线有啥用，没想到离线怎么做 (~~

```cpp
#include <iostream>
#include <cstdio>
#define int long long 
using namespace std;
const int INF=1e5+5;
int n,m,nxt[INF],a[INF],cnt[INF],res[INF],v[INF],b[INF],vis[INF],sum,f;
pair<int,int> DFS(int x,int y) {
	if (y<=0) return make_pair(x,y);
	if (!vis[x]) sum++;vis[x]=1;
	pair<int,int> it=DFS(nxt[x],y-cnt[x]);
	nxt[x]=it.first;cnt[x]=y-it.second;
	return it;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for (int i=1;i<=n;i++) cin>>nxt[i],cnt[i]=1;
	for (int i=1;i<=m;i++) cin>>v[i];
	for (int i=1;i<=m;i++) cin>>b[i];
	res[0]=0;
	for (int i=1;i<=m;i++) {
		sum=0;f=b[i];
		a[i]=((v[i]+res[i-1]-1)%n)+1;
		DFS(a[i],b[i]);res[i]=sum;
	}
	for (int i=1;i<=m;i++)
		cout<<res[i]<<"\n";
	return 0;
}
```


---


# Weird Chess

## 题目描述

Igor 对国际象棋已经玩腻了，他现在想出新规则来让自己出名。

他的棋盘是一个 $n \times n$ 的方格。Igor 觉得简单才是成功的关键，所以他的游戏只会用一种棋子，并且所有的棋子颜色相同。棋子的移动方式通过一组位移向量来定义。以下是棋子的具体移动规则。

棋盘上的行从上到下编号为 1 到 $n$，列从左到右也从 1 到 $n$ 编号。给每个棋盘格子分配一个整数对 $(x, y)$，表示列号和行号。每种可能的走法由一个整数对 $(dx, dy)$ 定义；使用这种走法，棋子从位置 $(x, y)$ 移到位置 $(x+dx, y+dy)$。只有当目标位置 $(x+dx, y+dy)$ 在棋盘内且没有被其他棋子占据时，这种走法才算有效。在判断能否进行某种走法时，除起点和终点外其他位置上的棋子不影响走法（类似于国际象棋中的马）。

Igor 希望你能找出他的棋子能进行哪些走法。Igor 在棋盘上放置了一些棋子，并告诉你每个未被占据的格子是否被已有棋子攻击（即是否有棋子能从当前位置移动到该格子）。你需要恢复出一种可能的位移向量集合，或者如果这种情况对于任何位移向量集合都是不可能的，则说明 Igor 犯了错误。

## 样例 #1

### 输入

```
5
oxxxx
x...x
x...x
x...x
xxxxo
```

### 输出

```
YES
....x....
....x....
....x....
....x....
xxxxoxxxx
....x....
....x....
....x....
....x....
```

## 样例 #2

### 输入

```
6
.x.x..
x.x.x.
.xo..x
x..ox.
.x.x.x
..x.x.
```

### 输出

```
YES
...........
...........
...........
....x.x....
...x...x...
.....o.....
...x...x...
....x.x....
...........
...........
...........
```

## 样例 #3

### 输入

```
3
o.x
oxx
o.x
```

### 输出

```
NO
```

# 题解

## 作者：Taoran_01 (赞：0)

---
### 补充说明
UPD 12/27/2024 已退役

感谢来自 @[Zar13](luogu://user/778339) 的指正，之前我的理解确有问题。

---
### 写在前面
首先明确，你在下的是象棋，所有的棋子都具有相同的移动规则，类似車、马、象。

其次，棋盘上的棋子**不能移动**。

---
### 题目描述
[CF538D](https://codeforces.com/contest/538/problem/D) Weird Chess | [洛谷](https://www.luogu.com.cn/problem/CF538D)

题目较复杂，完整翻译在[这里](https://www.luogu.com.cn/paste/au6y406i)。

给定一个 $n\times n$ 的棋盘，其中 $1\le n\le50$。棋盘上有一些棋子。已知棋盘上每个空位是否被攻击。现在要求你还原棋子的移动规则，或判断是否有误。

---
### 性质
以“马走日”为例，棋盘上有两只马，那么他们可攻击范围如图所示。

```
. . . . x . x . | . . . . x . x .
. . . x . . . x | . . . x . . . x
. x . x . o . . | . x . x . B . .
x . . x x . . x | x . . x x . . x
. . o . x . x . | . . A . x . x .
x . . . x . . . | x . . . x . . .
. x . x . . . . | . x . x . . . .
. . . . . . . . | . . . . . . . .
```

下面是还原出的移动规则。

```
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . x . x . . . . . . .
. . . . . . x . . . x . . . . . .
. . . . . . . . o . . . . . . . .
. . . . . . x . . . x . . . . . .
. . . . . . . x . x . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
```

绘制“以某棋子为中心被攻击位置”，每颗棋子的图表示该棋子“最大”移动规则。即，最终的移动规则一定是这颗棋子的**子集**。

```
A 为中心，被攻击的位置 => a+x
B 为中心，被攻击的位置 => b+x
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . a . a . . . .
. . . . . . . . . a . . . a . . .
. . . . . . . x . x . . . . . . .
. . . . . . x . . a x . . a . . .
. . . . b . b . o . a . a . . . .
. . . b . . x b . . x . . . . . .
. . . . . . . x . x . . . . . . .
. . . b . . . b . . . . . . . . .
. . . . b . b . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
```

由于每颗棋子都相同，它们都具有相同的移动规则。因此，我们需要对**每颗**棋子“最大”移动规则取**交集**，得到“棋子相同”限制条件下的“最大”移动规则。

---
### 解题思路
观察数据范围，$n\le 50$，考虑 $O(n^4)$ 暴力。

注意到对多个棋子的移动方式取“交”较为困难，会爆空间。考虑等价替换为开销更小的“并”。  
根据“对多个集合取交相当于对它们的补集先取并再取补”，可以得到：
> “可移动到的位置是并起来的，而不可移动到的位置是起交来的。”

遍历每个棋子和每个空位，将棋子在空位方向上的移动规则标记为不可移动，剩下全部标记为可移动。这样构造出来的移动规则就是**最可能**的答案。  
最后按照这个移动方案，检查所有应受攻击位置是否能受到攻击即可。

---
### 无解情况
这样构造出的移动规则总是“最大”的，上面证明过了。可以证明，如果这样构造出的移动规则不能满足“应受攻击位置受到攻击”，那么其它移动规则都不可以。

> 我们所选择的移动集是**最大化**的，这意味着如果再添加其他的移动，将会导致棋盘不再正确。
> 
> 我们让所有棋子执行所有剩下的、未被标记为不可能的移动，并重新创建与原始相同位置的棋盘。
> 1. 如果某个格子在初始状态下没有被攻击，那么在新生成的棋盘中它也不会被攻击；
> 2. 某些之前被攻击的格子在新棋盘中未被攻击，那么原棋盘就不能构成任何合法的移动方式，因为移动集已最大化，添加一个新的攻击方向会导致其它棋子出现问题。

---
### 算法步骤
设原棋盘为 $n\times n$ 的矩阵 $A$，转移规律为 $(2n-1)\times(2n-1)$ 的矩阵 $D$。  
$0$ 表示 `.`，不可移动到/不可被攻击；$1$ 表示 `x`，可以移动到/可以被攻击；$2$ 表示 `o`，棋子所在位置。

1. 将每一种移动标记为可能，$D_{x,y}=1$。
2. 对每一个棋子 $(X_i,Y_i)$ 和每一个不可被攻击的位置 $(x_j,y_j)$，可以得到棋子不具有移动规律 $\begin{cases}X_i\leftarrow X_i+(x_j-X_i)\\Y_i\leftarrow Y_i+(y_j-Y_i)\end{cases}$。所以转移矩阵中 $D_{x_j-X_i,y_j-Y_i}=0$。
3. $D_{n,n}\leftarrow2$，表示移动规则的中心位置是自身棋子。
4. 根据移动规则还原棋局 $T$：$\forall A_{x,y}=2,\ D_{i,j}=1,\ x+i,y+j\in[1,n],\ T_{x+i,y+j}\leftarrow1$。  
   如果对于任意位置，原棋局中的受攻击情况与还原棋局不同，则说明无解。

---
### 代码实现
[AC](https://codeforces.com/contest/538/submission/285477853) 1.21MB 77ms
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;

char buf[1<<20], *p1, *p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)

inline ll read() {
	ll x=0, f=1; char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
	while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	return x*f;
}

#define N 110
int n;
int a[N][N], d[N][N], t[N][N];

signed main() {
	// freopen("CF538D_1.in", "r", stdin);
	// freopen("CF538D_1.out", "w", stdout);
	n=read();
	for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) {
		char ch=getchar(); while (ch!='x'&&ch!='o'&&ch!='.') ch=getchar();
		if (ch=='.') a[i][j]=0; if (ch=='x') a[i][j]=1; if (ch=='o') a[i][j]=2;
	}
	for (int i=1; i<=n*2-1; ++i) for (int j=1; j<=n*2-1; ++j) d[i][j]=1;
	for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) if (a[i][j]==2) {
		for (int x=1; x<=n; ++x) for (int y=1; y<=n; ++y) {
			if (a[x][y]==0) d[x-i+n][y-j+n]=0;
		}
	}
	for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) if (a[i][j]==2) {
		for (int x=1; x<=n*2-1; ++x) for (int y=1; y<=n*2-1; ++y) if (d[x][y]) {
			int x1=i+x-n, y1=j+y-n;
			if (x1>=1&&x1<=n&&y1>=1&&y1<=n) t[x1][y1]=1;
		}
	}
	bool flag=1;
	for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) if (a[i][j]!=2) {
		flag&=(a[i][j]==1)==(t[i][j]==1);
	}
	d[n][n]=2;
	if (!flag) return puts("NO"), 0;
	puts("YES");
	for (int i=1; i<=2*n-1; ++i) {
		for (int j=1; j<=2*n-1; ++j) {
			putchar(".xo"[d[i][j]]);
		} puts("");
	}
	return 0;
}

```

---
### 总结
本体难点：理解“最大化”移动规则的创建方式和特殊性质。

最后安利一下自己的 [Blog](https://algo-x.cn)。

---

## 作者：Leap_Frog (赞：0)

首先，如果能用某种移动方式表示，那移动方式的矩阵大小不超过 $2n-1$，这点很显然。  
观察发现，`x` 是 $\lor$ 起来的，而 `.` 是 $\land$ 起来的，我们重点考虑 `.`。  
于是我们暴力枚举每个棋子，然后暴力枚举每个 `.`，然后在他们相对位置处打标记，因为这个方向肯定无法走了。  
然后最后就得到了可能的方法，最后带回去检验是否有 `x` 没被覆盖即可。  
代码就不放了（其实是没写

---


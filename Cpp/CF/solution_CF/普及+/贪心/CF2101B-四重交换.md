# 四重交换

## 题目描述

给定一个长度为 $n$ 的排列 $a$ $^{\text{∗}}$。你可以进行以下操作任意次数（包括零次）：

- 选择一个下标 $1 \le i \le n - 3$。然后，同时交换 $a_i$ 和 $a_{i+2}$，以及 $a_{i+1}$ 和 $a_{i+3}$。换句话说，排列 $a$ 将从 $[\ldots, a_i, a_{i+1}, a_{i+2}, a_{i+3}, \ldots]$ 变为 $[\ldots, a_{i+2}, a_{i+3}, a_i, a_{i+1}, \ldots]$。

请确定通过任意次上述操作后能得到的字典序最小的排列 $^{\text{†}}$。

$^{\text{∗}}$ 一个长度为 $n$ 的排列是由 $1$ 到 $n$ 的 $n$ 个不同整数按任意顺序组成的数组。例如，$[2,3,1,5,4]$ 是一个排列，但 $[1,2,2]$ 不是排列（因为 $2$ 出现了两次），$[1,3,4]$ 也不是排列（$n=3$ 但数组中出现了 $4$）。

$^{\text{†}}$ 对于两个相同长度的数组 $x$ 和 $y$，$x$ 字典序小于 $y$ 当且仅当满足以下条件：
- 在第一个 $x$ 和 $y$ 不同的位置，$x$ 的元素小于 $y$ 的对应元素。

## 说明/提示

**样例解释**

第一组数据中，选择 $i=1$ 执行一次操作，排列变为 $[1,2,3,4]$，可以证明这是可以得到的字典序最小的排列。

第二组数据中，一种可以得到字典序最小的排列的操作如下：

- 选择 $i=2$ 执行一次操作，排列变为 $[5,1,2,4,3]$；
- 选择 $i=1$ 执行一次操作，排列变为 $[2,4,5,1,3]$；
- 选择 $i=2$ 执行一次操作，排列变为 $[2,1,3,4,5]$。

## 样例 #1

### 输入

```
3
4
3 4 1 2
5
5 4 3 1 2
10
10 9 8 7 6 5 4 3 2 1```

### 输出

```
1 2 3 4 
2 1 3 4 5 
2 1 4 3 6 5 8 7 10 9```

# 题解

## 作者：szh_AK_all (赞：2)

可以发现，我们每次操作是交换两个偶数位置上和奇数位置上的数。

设 $tmp,ans$ 分别表示将奇数位置、偶数位置上的数通过交换修改成递增的状态的最少操作数。那么我们要奇数位置、偶数位置 上的数达到递增状态，所需的操作数与 $tmp,ans$ 的奇偶性是相同的。并且每次操作后，我们改变了奇数位置和偶数位置所需的操作数的奇偶性，而如果仅仅考虑奇数位置或偶数位置，当其所需操作数为偶数时，不会影响其相对的位置。

所以当 $tmp,ans$ 奇偶性相同时，我们只需将奇数位置、偶数位置上的数分别排序即可；否则，我们需要交换一对位置，根据 $n$ 的奇偶性选择最优方案。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[1000005], aa[1000005], b[1000005];
int bb[1000005], ans;
 
void gui(int l, int r) {
	if (l == r)
		return;
	int mid = (l + r) / 2;
	gui(l, mid);
	gui(mid + 1, r);
	int p1 = l, p2 = mid + 1;
	int k = l;
	while (p1 <= mid || p2 <= r) {
		if (p2 > r)
			bb[k++] = a[p1++];
		else if (p1 > mid)
			bb[k++] = a[p2++];
		else if (a[p1] <= a[p2])
			bb[k++] = a[p1++];
		else {
			bb[k++] = a[p2++];
			ans += (mid - p1 + 1);
		}
	}
	for (int i = l; i <= r; i++)
		a[i] = bb[i];
}
int da[1000005];
 
signed main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		int c1 = 0, c2 = 0;
		for (int i = 1; i <= n; i++) {
			int x;
			cin >> x;
			if (i % 2)
				a[++c1] = x;
			else
				b[++c2] = x;
		}
		ans = 0;
		gui(1, c1);
		int tmp = ans % 2;
		for (int i = 1; i <= c1; i++)
			aa[i] = a[i];
		for (int i = 1; i <= c2; i++)
			a[i] = b[i];
		ans = 0;
		gui(1, c2);
		ans %= 2;
		if (ans != tmp) {
			if (n % 2)
				swap(aa[c1], aa[c1 - 1]);
			else
				swap(a[c2], a[c2 - 1]);
		}
		for (int i = 1; i <= c2; i++)
			cout << aa[i] << " " << a[i] << " ";
		if (c1 > c2)
			cout << aa[c1] << " ";
		cout << "\n";
	}
}
```

---

## 作者：ddxrS_loves_zxr (赞：1)

贪心的想，我们把奇位和偶位分开排序，可以得到最优解。唯一的问题是最后 $a_{n-2}$ 与 $a_{n}$ 无法排序，也就是会让 $a_{n-2}>a_{n}$。

来看一下它们何时能够有序。像这类排序的题目，可以套路的往逆序对上面想。考察一次交换操作对逆序对的影响。

假设当前我们是要把一个在奇数位上的 $a_{i+2}$ 放到更前面。那么我们肯定是交换 $a_i$ 和 $a_{i+2}$，同时 $a_{i+1}$ 和 $a_{i+3}$ 也会被交换。交换前一定有 $a_i>a_{i+2}$，因此奇数位上的逆序对数量减少一。而 $a_{i+1}$ 和 $a_{i+3}$，逆序对数量会减少一或者增加一。

也就是说，每次奇数位逆序对数量奇偶性的改变必然也会带来偶数位逆序对数量奇偶性的改变。同理，每次偶数位逆序对数量的改变也会带来奇数位逆序对数量奇偶性的改变。

而最后，$a_{n-1}$ 所属的奇偶位逆序对数量一定为 $0$，$a_n$ 所属的要么为 $0$ 要么为 $1$，这就取决于奇数位和偶数位逆序对奇偶性是否相同。

综上，如果奇数位逆序对奇偶性等于偶数位逆序对奇偶性，那么最后 $a_{n-2}<a_n$，否则 $a_{n-2}>a_n$。

---

## 作者：znzryb (赞：0)

## 思路讲解

那么注意到，在该操作过程中，一个数下标的的奇偶性是不会发生变化的。
还有一个比较隐秘的不变量就是***偶数下标的反转数和奇数下标的反转数是相同的***，因为每次交换相邻偶数下标时, 会迫不得己地同时交换奇数下标，反之亦然。

那么要用到我们观察出来的第二个性质，就是***偶数下标的反转数和奇数下标的反转数是相同的***，那么如果说偶数下标序列和奇数下标序列的逆序对数量的奇偶性不相同（逆序对数量其实也就是需交换操作数量，因为本道题目是只能相邻交换，相当于冒泡排序），那么就说明必须要牺牲一个不反转（或者有时是在有序的基础上，再多反转一个，反正无论是 $+1$ 还是 $-1$ 以后奇偶性一定就相同了）。

那么应该反转哪个最优呢？不难发现这样交换最优。
```cpp
	if((revOdd-revEven)%2!=0){
		swap(Ans[N],Ans[N-2]);
	}
```

## AC代码

https://codeforces.com/contest/2101/submission/319512581

```cpp
// Problem: B. Quartet Swapping
// Contest: Codeforces - Codeforces Round 1024 (Div. 1)
// URL: https://codeforces.com/contest/2101/problem/B
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// by znzryb
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define all(vec) vec.begin(),vec.end()
#define CLR(i,a) memset(i,a,sizeof(i))
#define fi first
#define se second
#define pb push_back
#define SZ(a) ((int) a.size())
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
#define getFro(vec) (vec.empty()?0:vec.front())
#define getBac(vec) (vec.empty()?0:vec.front())
#define debug(var) cerr << #var <<":"<<var<<"\n";
#define DEBUG(variable) \
    do { \
        std::cerr << #variable << ":"; \
        for (const auto& elem : variable) { \
            std::cerr << elem << " "; \
        } \
        std::cerr << "\n"; \
    } while (0)
#define uniVec(var) \
    do { \
        sort(var.begin(),var.end());\
        var.resize(unique(var.begin(),var.end())-var.begin());\
    } while (0)

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<ll,ll> pll;
typedef array<ll,3> arr;
typedef double DB;
typedef pair<DB,DB> pdd;
typedef pair<ll,bool> plb;
constexpr ll MAXN=static_cast<ll>(1e6)+10,INF=static_cast<ll>(1e18)+3;
constexpr ll mod=static_cast<ll>(1e9)+7;
constexpr double eps=1e-8;

ll N,M,K,T,A[MAXN];
ll Ans[MAXN];
/*

*/
struct BIT {  // 普通的单点修改区间查询树状数组，含有查找第K个空位的功能
  vector<ll> tr;
  int n;
  inline int lowbit(int x) { return x & (-x); }
  BIT(int ln) {  // 构造+初始化函数
    n = ln;
    tr.resize(n+5,0);
  }
  inline void add(int p, int x) {
  	if(p==0) return;
    while (p <= n) {
      tr[p] += x;
      p += lowbit(p);
    }
  }
  inline ll query(int l, int r) {
    ll lres = 0, rres = 0;
    l -= 1;
    while (l > 0) {
      lres += tr[l];
      l -= lowbit(l);
    }
    while (r > 0) {
      rres += tr[r];
      r -= lowbit(r);
    }
    return rres - lres;
  }
  inline int findKth(int k) {  // 找到第k个空位
    int cx = 0;
    for (int i = 1 << 20; i > 0; i >>= 1) {  // 这个你可以理解为不断缩小步长的搜索
      if (cx + i <= n && lowbit(cx + i) - tr[cx + i] < k) {
        // lowbit(cx)-tr[cx+i] 表示cx+i这个树状数组区间有多少空位
        k -= lowbit(cx + i) - tr[cx + i];
        cx += i;
      }
    }
    return cx + 1;  // 我们始终让cx < k，所以返回的就是最大的比k小的，+1就是新空位出现的地方
  }
};
inline void solve(){
	cin>>N;
	priority_queue<ll,vector<ll>,greater<ll>> pqOdd,pqEven;
	BIT oddTree(N),evenTree(N);
	ll revOdd=0,revEven=0;
	FOR(i,1,N){
		cin>>A[i];
		if(i%2==0){
			pqEven.push(A[i]);
			revEven+=evenTree.query(A[i]+1,N);
			evenTree.add(A[i],1);
		}else{
			pqOdd.push(A[i]);
			revOdd+=oddTree.query(A[i]+1,N);
			oddTree.add(A[i],1);
		}
	}
	FOR(i,1,N){
		if(i%2==0){
			Ans[i]=pqEven.top();
			pqEven.pop();
		}else{
			Ans[i]=pqOdd.top();
			pqOdd.pop();
		}
	}
	if((revOdd-revEven)%2!=0){
		swap(Ans[N],Ans[N-2]);
	}
	FOR(i,1,N){
		cout<<Ans[i]<<" ";
	}
	cout<<"\n";
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		solve();
	}
	// solve();
	return 0;
}
/*
AC
https://codeforces.com/contest/2101/submission/319512581
*/
```

---


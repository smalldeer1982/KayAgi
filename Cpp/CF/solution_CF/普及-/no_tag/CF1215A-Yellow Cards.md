# Yellow Cards

## 题目描述

``Berland``足球杯总决赛最近举行了。整场比赛中，裁判出示了$n$张黄牌。比赛一开始，在第一队中有$a_1$个球员而在第二队中有$a_2$个。

在``Berland``足球杯中，把人罚下场的规则与正常规则略有不同。来自第一队的一个球员收到$k_1$张黄牌，他被罚下场并不能继续参加比赛了；来自第二队的球员则需要$k_2$张才会下场。下场的球员不能再收到黄牌。即使某一队（甚至两队）的球员全部被罚下场，比赛仍能继续。

裁判忘记了自己把每张黄牌罚给了谁，所以请你帮助裁判确定可能的被罚下场的人数的最小值和最大值。

## 说明/提示

在第一个样例中，可能一个球员都没被罚下场，所以最小值是0；最大值是4，1个来自第一队的球员和3个来自第二队的球员。

在第二个样例中，$n$达到了可能出示的黄牌数最大值（$3*6+1*7=25$），所以不论如何所有球员都得下场。

## 样例 #1

### 输入

```
2
3
5
1
8
```

### 输出

```
0 4
```

## 样例 #2

### 输入

```
3
1
6
7
25
```

### 输出

```
4 4
```

## 样例 #3

### 输入

```
6
4
9
10
89
```

### 输出

```
5 9
```

# 题解

## 作者：Sooke (赞：5)

### 简要题意

红方蓝方分别有 $a,\,b$ 人。红方一人收到 $x$ 张黄牌即下场，蓝方一人收到 $y$ 张黄牌即下场。现有 $n$ 张黄牌应全部发出去，求最少和最多下场多少人。

---

### 解题思路

最少和最多是不一样的策略，我们分开讨论。

要使下场人数最少，可以先给红方每个人喂 $x - 1$ 张黄牌，蓝方每个人喂 $y - 1$ 张黄牌，达到所谓的 “饱和状态”（即接下来每送一张黄牌都不得不淘汰一人）。因此最少下场 $\min(0,\,n - a(x - 1) - b(y - 1))$ 。之所以 $\min$ 上 $0$ 是因为可能黄牌不够，连饱和状态都达不到，此时当然不能淘汰负数个人咯。

要使下场人数最多，和上面相反，每张黄牌都必须“一招致命”，而非“屯到饱和”。所以非常无脑地暴枚 $i$ ，表示 $i$ 张黄牌给红队，$n - i$ 张黄牌给蓝队。在红队中 $x$ 张黄牌能淘汰一人，所以最多能淘汰 $\min(a,\,\lfloor i/x \rfloor)$ 人（注意要 $\min$ 上 $a$ ，因为红队只有这么多人），蓝队同理。由此我们再找出每个 $i$ 的答案中最大的那个即可。

---

### 代码实现

```cpp
#include <bits/stdc++.h>

inline int read() {
    char c; int x; for (c = getchar(); !isdigit(c); c = getchar());
    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return x;
}

int a, b, x, y, n, l, r = -1e9;

int main() {
    a = read(); b = read(); x = read(); y = read(); n = read();
    l = std::max(0, n - (x - 1) * a - (y - 1) * b);
    for (int i = 0; i <= n; i++) {
        r = std::max(r, std::min(a, i / x) + std::min(b, (n - i) / y));
    }
    printf("%d %d\n", l, r);
    return 0;
}
```

---

## 作者：梦里调音 (赞：2)

来个笨方法。

根据k1和k2分类讨论。

```
#include <bits/stdc++.h>
using namespace std;
int a1,a2,k1,k2,n;
int main(){
	scanf("%d%d%d%d%d",&a1,&a2,&k1,&k2,&n);
	int use=a1*(k1-1)+a2*(k2-1);//可以消耗的黄牌 
	if(use>=n)cout<<0<<" ";
	else cout<<n-use<<" ";
	if(k1>k2){//1队的k比2队小 
		swap(a1,a2);
		swap(k1,k2);
	}
	int killed=0;//最大踢人数 
	int p=0;
	//1：整死了1队  2：整死了2队 :3：整死了1、2队 
	if(n>=a1*k1){//先把1队整死 
		killed+=a1;
		n-=a1*k1;
		p=1;
	}
	if(n>=a2*k2){//再把2队整死 
		killed+=a2;
		n-=a2*k2;
		if(p==0)p=2;
		else p=3;
	}
	if(p==0||p==2){//1队还没整 :整1队 
		killed+=n/k1;
		n%=k1;
	}
	if(p==0||p==1){//2队还没整 :整2队
		killed+=n/k2;
		n%=k2;
	}
	cout<<killed<<endl;
	return 0;
}
```


---

## 作者：BrokenSword (赞：1)

**题意描述**

Berland足球杯总决赛最近举行了。整场比赛中，裁判出示了$n$张黄牌。比赛一开始，在第一队中有$a_1$个球员，而在第二队中有$a_2$个。

在Berland足球杯中，把人罚下场的规则与正常规则略有不同。来自第一队的一个球员收到$k_1$张黄牌，他被罚下场并不能继续参加比赛了；来自第二队的球员则需要$k_2$张才会下场。下场的球员不能再收到黄牌。即使某一队（甚至两队）的球员全部被罚下场，比赛仍能继续。

裁判忘记了自己把每张黄牌罚给了谁，所以请你帮助裁判确定可能的被罚下场的人数的最小值和最大值。

---

最小值的话，考虑每个人在不被罚下场的情况下能收到的最多黄牌数，显然第一队球员为$k_1-1$张，第二队为$k_2-1$张。那么无人下场时的最多黄牌数即为$((k_1-1)*a_1+(k_2-1)*a_2)$张。

此时如果$n$小于该式则最小值为$0$。否则，此时每人只需$1$张黄牌即可下场，所以最小值为$n-$该式。

最大值，则首先考虑将$k_i$较小的队伍的球员都罚下场。此时所需黄牌数为$(k_i*a_i)(k_i=min(k_1,k_2))$。如果$n$小于该式，则最最大值为$n/k_i(k_i=min(k_1,k_2)$。

否则，考虑将剩下那支队伍的球员罚下场，剩余黄牌为$n-k_i*a_i$张。
则最大值为$min(a_1+a_2,a_1+(n-k_i*a_i)/k_j)(k_i=min(k_1,k_2),k_j=max(k_1,k_2))$。

最后输出最小值和最大值即可。注意空格。

---

## 作者：开始新的记忆 (赞：1)

题目大意：现在有两个球队，第一个球队有a1个人，当一个人收到k1张黄牌就被罚下场，第二个球队有a2个人，当一个人收到k2张黄牌就被罚下场，现在有n张黄牌，问你最少能罚出去多少人，最多多少人。

大致思路：纯判断，如果要判断最少，则先看a1*(k1-1)+a2*(k2-1)和n的关系，代表每个人都给出刚好不用罚出场的黄牌数量，如果再多几张就是多几个人被罚下场。判断最大就是先从k1，k2小的看，先把小的全部罚完，然后再往后看即可。

code：
```
#include<bits/stdc++.h>
using namespace std;
int a1,a2,k1,k2,n;
int main()
{	cin>>a1>>a2>>k1>>k2>>n;
	int ans=(k1-1)*a1+(k2-1)*a2;
	if(n<=ans)
		cout<<0<<' ';
	else
		cout<<n-ans<<' ';
	if(k1<k2)
	{
		if(n<=k1*a1)
			cout<<n/k1<<endl;
		else
			cout<<a1+(n-a1*k1)/k2<<endl;
	}
	else
	{
		if(n<=k2*a2)
			cout<<n/k2<<endl;
		else
			cout<<a2+(n-a2*k2)/k1<<endl;
	}
	return 0;
}
```


---

## 作者：XXXxm (赞：0)

## 题意
你拥有 $n$ 张黄牌，将黄牌判给两支队伍 $a_1$、$a_2$ 你需要求出**最少**和**最多**可以判几个人下场。

## 思路

模拟题，只需要按照题目意思进行模拟即可

- 对于最小可以判多少人，首先判断一下 $n$ 张牌是否最少可以判0人下场。
- 对于最大可以判多少人，采用一个贪心的思维，先判 $k_1$ 和 $k_2$ 中较小的一队，全部判下完后在判另一队。

## *code*
```cpp
#include<bits/stdc++.h>
using namespace std;
int a1,a2,k1,k2,n,ans = 0;
int main() {
	scanf("%d%d%d%d%d",&a1,&a2,&k1,&k2,&n);
	//这里进行最小人数判断 
	int cnt = n - a1 * (k1 - 1) - a2 * (k2 - 1);
	if(cnt <= 0 ) printf("0 ");
	else printf("%d ",cnt);
	
	if(k1 > k2) swap(k1,k2),swap(a1,a2);//将第一队存为k值较小的一队 

	if(n - k1 * a1 > 0)//模拟判断人数 
		ans = a1 + (n - k1 * a1) / k2;
	else
		ans = n / k1;

	printf("%d",ans);
	return 0;
}
```


---

## 作者：弦巻こころ (赞：0)

题意:一场比赛,一队有$a_1$位队员,二队有$a_2$位队员.现在有一个裁判发了$n$张黄牌,用$k_1$张黄牌可以淘汰掉一队的一位队员,用$k_2$张黄牌可以淘汰掉二队的一位队员.求最大和最小淘汰数.

如果求最小的淘汰数,就让每位队员拿到比淘汰值小1的黄牌,这时每位队员1张黄牌就罚下了,就再和$a_1$+$a_2$取个min就可以解决了.

如果求最大的淘汰数,我们就贪心的先将$k_1$,$k_2$中用黄牌较小的先淘汰,如果还有剩余再淘汰较大的就行了.

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,n;
int tot;
int main()
{
	cin>>a>>b>>c>>d>>n;
	if(c>d)//保证c最小
	{
		swap(c,d);
		swap(a,b);
	}
	tot=n;
	tot-=a*(c-1),tot-=b*(d-1);//每个人搞到淘汰的边缘
	cout<<min(a+b,max(tot,0))<<" ";
	tot=n;
	if(tot<=a*c)//如果连人都搞不完
	{
		cout<<floor(1.0*tot/c)<<endl;
	}else//如果搞得完
	{
		tot-=a*c;
		cout<<a+min(floor(1.0*tot/d),1.0*b)<<endl;//记得取min
	}
    return 0;
}
```
听说CYJian神仙 Rank16上橙了%%%%

---

## 作者：Naffygo (赞：0)

### 题目大意

第一队有 $a_1$ 个人，收到 $k_1$ 张黄牌下场，第二队有 $a_2$ 个人，收到 $k_2$ 张黄牌下场。现已知发出去了 $n$ 张黄牌，问最少和最多有多少人被罚下场。

### 思路

~~一道淳朴的题目，~~ 假设 $k_1 < k_2$ ，将最少和最多分开计算。

首先算最少。如果没人被罚下场，则需要 $sum = n_1 * (k_1 - 1) + n_2 * (k_2 - 1)$ 张黄牌，如果 $sum$ 不小于 $n$ ，则最少没人被罚下场，否则会有 $min(n - sum,n_1 + n_2)$人被罚下场。（因为可能黄牌数量非常多）

然后算最多。显然需要尽可能把第一队的人罚下场（因为我前面假设 $k_1 < k_2$），如果 $n_1 * k_1 \geq n$ ，则有 $\left\lfloor\dfrac{n_1}{k_1}\right\rfloor$个人被罚下场，否则有 $n_1 + \left\lfloor\dfrac{n - n_1 * k_1}{k_2}\right\rfloor$ 个人被罚下场。

以下即为代码(~~讲得应该比较详细了，代码就不写注释了~~)

```cpp
#include<bits/stdc++.h>
#define fr(i,a,b) for(register int i = a;i <= b;++i)
#define N 200010
using namespace std;
 
inline int read(){
	int x = 0,f = 1;char c = getchar();
	while(!isdigit(c)){if(c == '-')f = -1;c = getchar();}
	while(isdigit(c)){x = x * 10 + c - '0';c = getchar();}
	return f * x;
}
 
int main(){
	int n1 = read(),n2 = read(),k1 = read(),k2 = read(),n = read();
	if(k1 > k2)swap(k1,k2),swap(n1,n2);
	int sum = n1 * (k1 - 1) + n2 * (k2 - 1);
	if(sum >= n)printf("0 ");
	else printf("%d ",min(n - sum,n1 + n2));
	if(k1 * n1 >= n)printf("%d",n / k1);
	else printf("%d",n1 + (n - k1 * n1) / k2);
	return 0;
}
```

---


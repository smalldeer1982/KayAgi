# 2048 Game

## 题目描述

You are playing a variation of game 2048. Initially you have a multiset $ s $ of $ n $ integers. Every integer in this multiset is a power of two.

You may perform any number (possibly, zero) operations with this multiset.

During each operation you choose two equal integers from $ s $ , remove them from $ s $ and insert the number equal to their sum into $ s $ .

For example, if $ s = \{1, 2, 1, 1, 4, 2, 2\} $ and you choose integers $ 2 $ and $ 2 $ , then the multiset becomes $ \{1, 1, 1, 4, 4, 2\} $ .

You win if the number $ 2048 $ belongs to your multiset. For example, if $ s = \{1024, 512, 512, 4\} $ you can win as follows: choose $ 512 $ and $ 512 $ , your multiset turns into $ \{1024, 1024, 4\} $ . Then choose $ 1024 $ and $ 1024 $ , your multiset turns into $ \{2048, 4\} $ and you win.

You have to determine if you can win this game.

You have to answer $ q $ independent queries.

## 说明/提示

In the first query you can win as follows: choose $ 512 $ and $ 512 $ , and $ s $ turns into $ \{1024, 64, 1024\} $ . Then choose $ 1024 $ and $ 1024 $ , and $ s $ turns into $ \{2048, 64\} $ and you win.

In the second query $ s $ contains $ 2048 $ initially.

## 样例 #1

### 输入

```
6
4
1024 512 64 512
1
2048
3
64 512 2
2
4096 4
7
2048 2 2048 2048 2048 2048 2048
2
2048 4096
```

### 输出

```
YES
YES
NO
NO
YES
YES
```

# 题解

## 作者：灵光一闪 (赞：3)

楼上的题解太麻烦了，其实只要这么短就行惹！
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

using namespace std;

int main(){//这份代码但凡是学过C++的都能看懂把？
	int T;
	cin>>T;
	while(T--){
		int a,ans=0,n;
		cin>>n;
		for(int i=0;i<n;i++){
			cin>>a;
			if(a>2048){
				continue;
			}
			else{
				ans+=a;
			}
		}
		if(ans>=2048){
			puts("YES");
		}
		else{
			puts("NO");
		}
//		ans=0;
	}
	return 0;
}
```

既然题目保证了都是2的幕次，则不可能出现3啊之类的，所以说！**有效数字和（有效数字指小于等于2048的数）只要大于了2048，那么肯定能拼出来，因为本题不需要输出方案数，所以这个做法是能AC的**

证明如下（语文工笔差，所以敬请耐心品读qaq）


我们知道，$2^3$+$2^3$=$2^4$，$2^4$+$2^4$=$2^5$

其实就是$2^3$*2=$2^4$，这个应该很简单把？

所以式子就是$2^n$+$2^n$=$2^{n+1}$

这个但凡学过数学3年级的应该都知道把？

然后很多人就是怕出现这种情况：无法匹配（指相同的数）导致刚好把2048跳过去了是吧？

那么我们来看看：
2+4+8+16+32+64+128+256+512+1024=2046

你但凡再有一个上列数，就可以组成2048（因为数不一定要全用）

听不懂？那我们把它当成2进制看看？  
0111111111  
由高到低分别是代表2048 1024 512 256…………2

2进制是不可以出现某一位是2的！

~~所以提出这个问题的童鞋可以坐下惹~~

---

## 作者：YunJ (赞：3)

 [更好的阅读体验](https://luoguyuntianming.github.io/2019/09/22/solution-cf1221a/)

**这题其实是一个简单地贪心**

由于$\sum_{i=0}^{n}2^i=2^{i+1}-1$，而本题要求合并相同的数。    
因此，当要生成$2048$，可以得出：当**所有特定数**的和小于$2048$，一定不能合成。当**所有特定数**的和大于$2048$，则一定有相同的数。         
因此，为得到$2048$，可以维护一个$sum$按如下的方法做：  

1. $a_i>2048$ 直接忽略。因为任何大于$2048$的相同两个数相加**一定**会大于2048，对答案没有贡献。
2. $a_i \le 2048$ $sum+=a_i$。

随后看是否$sum \ge 2048$，大于等于输出``Yes``，否则输出``No``。

代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		int sum=0,yx=0,f=0;
		for(int i=1;i<=n;i++)
		{
			int x;
			scanf("%d",&x);
			if(x>2048) continue;
			sum+=x;
		}
		if(sum>=2048) puts("YES");
		else puts("NO");
	}
}
```

---

## 作者：叶ID (赞：2)

题目链接：[CF1221A 2048 Game](https://www.luogu.org/problem/CF1221A)

【广告】在个人博客阅读：[此处](https://toxic2018.ml/1850/)

****

### 题目大意

初始你有一个可重集合，其中每个数都是$2$的幂次，你可以执行若干次这样的操作：从可重集合中取出两个相等的数，把它们相加，然后插入到集合中，问：能否经过若干次操作使得集合中出现$2048$

****

### 解题思路

我们开一个数组$st$统计每个数出现的次数。由于全都是$2$的幂次，所以用一个数的$log_2$值来代表这个数即可。

我们从小的数往大的扫描（到$1024$为止）。假设当前扫描到$2^i$，那么我们令$2_{i+1}$的个数增加$floor(\frac{st[i]}{2})$（相当于尽可能地将较小数相加得到较大数）。操作完成后判断$2048$的个数是否大于$0$即可。

为什么正确？因为比$2048$大的数一定对答案没有贡献，无需考虑。而一个小于$2048$的数，必须要两两相加，最终才能到达$2048$。

****

### 代码

代码中的`Log2`函数相当于`(int)log2`，使用了“手动二分”的写法。

注意不要让数组越界了

```cpp
// status: [Accepted]
// oj:     [luogu]

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define int ll

int Log2(int val) {if(val<2147483648) { if(val<32768) { if(val<128) { if(val<8) { if(val<2) { return 0;} else {if(val<4) { return 1;} else {return 2;}}} else {if(val<32) { if(val<16) { return 3;} else {return 4;}} else {if(val<64) { return 5;} else {return 6;}}}} else {if(val<2048) { if(val<512) { if(val<256) { return 7;} else {return 8;}} else {if(val<1024) { return 9;} else {return 10;}}} else {if(val<8192) { if(val<4096) { return 11;} else {return 12;}} else {if(val<16384) { return 13;} else {return 14;}}}}} else {if(val<8388608) { if(val<524288) { if(val<131072) { if(val<65536) { return 15;} else {return 16;}} else {if(val<262144) { return 17;} else {return 18;}}} else {if(val<2097152) { if(val<1048576) { return 19;} else {return 20;}} else {if(val<4194304) { return 21;} else {return 22;}}}} else {if(val<134217728) { if(val<33554432) { if(val<16777216) { return 23;} else {return 24;}} else {if(val<67108864) { return 25;} else {return 26;}}} else {if(val<536870912) { if(val<268435456) { return 27;} else {return 28;}} else {if(val<1073741824) { return 29;} else {return 30;}}}}}} else {if(val<140737488355328) { if(val<549755813888) { if(val<34359738368) { if(val<8589934592) { if(val<4294967296) { return 31;} else {return 32;}} else {if(val<17179869184) { return 33;} else {return 34;}}} else {if(val<137438953472) { if(val<68719476736) { return 35;} else {return 36;}} else {if(val<274877906944) { return 37;} else {return 38;}}}} else {if(val<8796093022208) { if(val<2199023255552) { if(val<1099511627776) { return 39;} else {return 40;}} else {if(val<4398046511104) { return 41;} else {return 42;}}} else {if(val<35184372088832) { if(val<17592186044416) { return 43;} else {return 44;}} else {if(val<70368744177664) { return 45;} else {return 46;}}}}} else {if(val<36028797018963968) { if(val<2251799813685248) { if(val<562949953421312) { if(val<281474976710656) { return 47;} else {return 48;}} else {if(val<1125899906842624) { return 49;} else {return 50;}}} else {if(val<9007199254740992) { if(val<4503599627370496) { return 51;} else {return 52;}} else {if(val<18014398509481984) { return 53;} else {return 54;}}}} else {if(val<576460752303423488) { if(val<144115188075855872) { if(val<72057594037927936) { return 55;} else {return 56;}} else {if(val<288230376151711744) { return 57;} else {return 58;}}} else {if(val<2305843009213693952) { if(val<1152921504606846976) { return 59;} else {return 60;}} else {if(val<4611686018427387904) { return 61;} else {return 62;}}}}}}}

int st[31];

signed main() {
    ios::sync_with_stdio(false);
    int T;
    cin>>T;
    while(T--) {
        for(int i=0;i<=11;i++) st[i] = 0;
        int n;
        cin>>n;
        while(n--) {
            int x;
            cin>>x;
            st[Log2(x)] ++;
        }
        for(int i=0;i<11;i++) {
            st[i+1] += st[i]/2;
        }

        if(st[11]) cout<<"YES\n";
        else cout<<"NO\n";
    }
    cout.flush();
}

```

****

评测记录：[R24129136](https://www.luogu.org/record/24129136)


---

## 作者：_soul_ (赞：1)

只需要将小于等于2048的所有数字加起来，如果总和大于等于2048输出YES，否则输出NO
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while (T--){
		int n;
		scanf("%d",&n);
		int sum=0;
		for (int i=1,x;i<=n;++i){
			scanf("%d",&x);
			if (x>2048) continue; 
			sum+=x;
		}
		if (sum<2048) puts("NO"); else puts("YES");
	}
	return 0;
}
```


---

## 作者：happybob (赞：0)

其实代码挺简单，不过用了1.67s，呜啊

代码有注释

```cpp
#include <iostream>
using namespace std;

int main()
{
	int n, m, sum = 0;
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
	    sum = 0;//每次都要变回0
	    cin >> m;
	    int x;
	    for(int j = 1; j <= m; j++)
	    {
	        cin >> x;
	        if(x > 2048)//比2048大不累加
	        {
	            continue;
	        }
	        sum += x;
	    }
	    if(sum >= 2048)//如果结果大于等于2048，那么因为数都是2的n次方，肯定能组成2048的
        {
            cout << "YES\n";
        }
	    else //否则no
	    {
	        cout << "NO\n";
	    }
	}
	return 0;
}
```


---


# Happy Birthday, Polycarp!

## 题目描述

Hooray! Polycarp turned $ n $ years old! The Technocup Team sincerely congratulates Polycarp!

Polycarp celebrated all of his $ n $ birthdays: from the $ 1 $ -th to the $ n $ -th. At the moment, he is wondering: how many times he turned beautiful number of years?

According to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $ 1 $ , $ 77 $ , $ 777 $ , $ 44 $ and $ 999999 $ . The following numbers are not beautiful: $ 12 $ , $ 11110 $ , $ 6969 $ and $ 987654321 $ .

Of course, Polycarpus uses the decimal numeral system (i.e. radix is 10).

Help Polycarpus to find the number of numbers from $ 1 $ to $ n $ (inclusive) that are beautiful.

## 说明/提示

In the first test case of the example beautiful years are $ 1 $ , $ 2 $ , $ 3 $ , $ 4 $ , $ 5 $ , $ 6 $ , $ 7 $ , $ 8 $ , $ 9 $ and $ 11 $ .

## 样例 #1

### 输入

```
6
18
1
9
100500
33
1000000000
```

### 输出

```
10
1
9
45
12
81
```

# 题解

## 作者：AlanSP (赞：1)

怎么都在打表嘛  。

那我就写个~~可能是正解的~~正解qwq。

对于每一个n，考虑把它在十进制下分拆。

依次枚举1~9是否能够组成美丽的数。

特别注意，如果是的话，那么它的每一位都可能组成新的数。

要把所有的可能加一遍。

然后就要考虑在n这位的美丽数了。

举个例子：

```
3333333334

```
我们之前的操作，只考虑了比它小一位的美丽的数。

对于像3333333333这样的数，要考虑它的大小依次判断。

我觉得这样才像正解~~好吧其实我打不出表来~~。

欢迎Hack！qwq。

```cpp

#include<bits/stdc++.h>
using namespace std;
 
int t,n,ans,cnt;
 
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		ans=0;
		cnt=0;
		int bn=n;
		while(bn) cnt++,bn/=10;
		if(n<10)
		{
			cout<<n<<endl;
			continue;
		}
		ans+=9*(cnt-1);
		int tem=pow(10,cnt-1);
		if(tem%10==9) tem++;
		int f=n/tem;
		int b=f;
		n%=tem;
		ans+=f-1;
		tem/=10;
		
		while(tem!=0)
		{
			if(n/tem<f) break;
			else if(n/tem>f)
			{
				ans++;
				break;
			}
			
			n%=tem;
			tem/=10;
			if(tem==0) ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：Sayori (赞：1)

一看到此题，就发现n大的出奇，~~正常枚举连样例都要跑一会~~  
由此发现就是一道规律题，打表可过  
## CODE：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, ans[10010];
int beau_num[81] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 
                    11, 22, 33, 44, 55, 66, 77, 88, 99, 
                    111, 222, 333, 444, 555, 666, 777, 888, 999, 
                    1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999, 
                    11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999, 
                    111111, 222222, 333333, 444444, 555555, 666666, 777777, 888888, 999999, 
                    1111111, 2222222, 3333333, 4444444, 5555555, 6666666, 7777777, 8888888, 9999999, 
                    11111111, 22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999, 
                    111111111, 222222222, 333333333, 444444444, 555555555, 666666666, 777777777, 888888888, 999999999};//打的表
int main(){
    scanf("%d", &t);
    for(int i = 1; i <= t; ++i){
        register int x, sum = 0;
        scanf("%d", &x);
        for(int i = 0; i <= 80; ++i)
            if(beau_num[i] <= x) ++sum;//如果美丽数<给出的x，总数显然加1
            else break;
        ans[i] = sum;
    }
    for(int i = 1; i <= t; ++i)
        printf("%d\n", ans[i]);
}
```


---

## 作者：gyh20 (赞：1)

对于$1$~$9$的每一个数，枚举由它组成的有多少个小于等于$n$的美丽的数。

代码：
```cpp
#include<cstdio>
using namespace std;
int main(){
	long long t,n;
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		long long ans=0;
		for(long long i=1;i<=9;++i){
			long long tmp=i;
			while(tmp<=n){
				++ans;
				tmp=tmp*10+i;
			}
		}
		printf("%lld\n",ans);
	}
}
```


---

## 作者：_Gabriel_ (赞：0)

### 思路

这道题 $n$ 的范围是 $ 1 \le n \le 10^9 $，但在这个范围内的完美的数个数并不多，共有 $9$ $\times$ $9=81$ 个，应此我们可以直接考虑枚举出由 $1$~$9$ 组成的完美的数。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int N = 1e2 + 10;
int a[N] = {1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 
			2, 22, 222, 2222, 22222, 222222, 2222222, 22222222, 222222222, 
			3, 33, 333, 3333, 33333, 333333, 3333333, 33333333, 333333333,
			4, 44, 444, 4444, 44444, 444444, 4444444, 44444444, 444444444,
			5, 55, 555, 5555, 55555, 555555, 5555555, 55555555, 555555555,
			6, 66, 666, 6666, 66666, 666666, 6666666, 66666666, 666666666,
			7, 77, 777, 7777, 77777, 777777, 7777777, 77777777, 777777777,
			8, 88, 888, 8888, 88888, 888888, 8888888, 88888888, 888888888,
			9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999};

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		int ans = 0;
		for (int i = 1; i <= 81; i++) {
			if (a[i] <= n) {
				ans++;
			}
		}
		cout << ans << "\n";
		ans = 0;
	}
	return 0;
}
```


---

## 作者：LBYYSM_123 (赞：0)

~~这道题我感觉打表是正解，毕竟也只有 $81$ 个。~~  
求各个数位上数都相同的数字个数，   
然后直接在这 $81$ 个数中统计小于 $n$ 的数就行了。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[]={0,1,11,111,1111,11111,111111,1111111,11111111,111111111,2,22,222,2222,22222,222222,2222222,22222222,222222222,3,33,333,3333,33333,333333,3333333,33333333,333333333,4,44,444,4444,44444,444444,4444444,44444444,444444444,5,55,555,5555,55555,555555,5555555,55555555,555555555,6,66,666,6666,66666,666666,6666666,66666666,666666666,7,77,777,7777,77777,777777,7777777,77777777,777777777,8,88,888,8888,88888,888888,8888888,88888888,888888888,9,99,999,9999,99999,999999,9999999,99999999,999999999};
int main(){
	int t,n;
    cin>>t;
    while(t--){
    	int ans=0;
    	cin>>n;
    	for(int i=1;i<=81;i++) 
			if(num[i]<=n) ans++;
    	cout<<ans<<endl;
	}
	return 0;
}


```

---

## 作者：封禁用户 (赞：0)

这道题算是一道水题。
# 思路
我们可以先用类似于 `BFS` 的方法预处理出所有的美丽数（亲测耗时 0.031s）然后便利整个美丽数的数组，就能求出 $\le$ n 的所有美丽数个数，输出即可。
# 细节
关于这个的 `BFS` ，我们需要首先把所有一位数压到队列里，然后，不断地取出 $front$，由于美丽数每一位都要相等所以直接再压入 $front \times 10 + front \bmod  10$。 

注意，当只有 $0 \le front \le 10^9$ 时以上过程才会进行，否则，弹出 $front$ 即可。
# code
```
#include <iostream>
#include <queue>
using namespace std;
vector<int> a;
#define int long long
void prebfs(){//预处理
    queue<int> q;
    for(int i=0;i<10;i++){
        q.push(i);
    }
    while(!q.empty()){
        int x=q.front();
        q.pop();
        if(x>(int)1e9)continue;
        a.push_back(x);
        if(x*10+x%10){
            q.push(x*10+x%10);
        }

    }
}
signed main()
{
    prebfs();
    int t;
    cin>>t;//测试数据数量
    while(t--){
        int n;
        cin>>n;
        int ans=0;
        for(int i=0;i<a.size()&&n>=a[i];i++){
                ans=i;
        }//判断<=n的美丽数个数
        cout<<ans<<endl;//输出
    }
    return 0;
}

```

---

## 作者：Meatherm (赞：0)

从小到大枚举每一个 Beautiful Year，判断它和 $n$ 谁更大 —— 如果 $n$ 比它小，那么就停止枚举，因为这时 $n$ 不可能比它更大的 Beautiful Year 小。

时间复杂度：$O(\lg n)$。

```cpp
# include <bits/stdc++.h>
# define rr register
int T;
int n;
int a[100],cnt;
int main(void){
	scanf("%d",&T);
	while(T--){
		cnt=0;
		scanf("%d",&n);
		for(rr int i=1;i<=1000;++i){//设为一个极大值，但实际上 i 不可能大于 lg(n)
			for(rr int j=1;j<=9;++j){
				int temp=0;
				for(rr int k=1;k<=i;++k)
					temp=temp*10+j;//制造一个数
				if(temp<=n)
					++cnt;
				else
					goto End;//使用 goto 语句可以跳到 End 所在的位置（跳出循环），十分简洁
			}
		}
		End:
		printf("%d\n",cnt);
	}
	return 0;
}
```

---

## 作者：LCuter (赞：0)

## $\text{Description}$

定义一个数是美丽的，当且仅当该数在十进制下由同一个数码组成，且非 $0$。

求 $[1,n]$ 中有多少个美丽的数。

## $\text{Solution}$

定义一个数的位数 $l(n)=\lfloor \lg n \rfloor$。

对于 $[10^{k-1},10^k]$ 中美丽的数的个数比较好求，就是 $9$。

那么 $[1,10^k]$ 中就有 $9k$ 个美丽的数

由于 $10^{l(n)}\le n\le 10^{l(n)+1}$ ，所以问题等价于求 $[1,10^{l(n)}]$ 和 $[10^{l(n)}+1,n]$ 中美丽的数的个数。

前者已经求出，对于后者，这个区间中最多只有 $9$ 个美丽的数，所以枚举这 $9$ 个美丽的数判断与 $n$ 之间的大小关系即可

---

## 作者：S1gMa (赞：0)


题解滴滴 ：


~~这场CF 窝咕咕了1.5h 出了A题便没做了 rating掉的很惨~~

题意
```
According to Polycarp
a positive integer is beautiful if it consists of only one digit repeated one or more times. 
For example,:
the following numbers are beautiful: 11 , 7777 , 777777.
```
简单来说就是指 给出一个 $n$ 求 $ 1 - n $ 之间 各个位数相同的数

如 ： 11， 88 ， 9999999 ； 而 23123， 32，45 则不是

##### 注 ： 1，2，3，4.....这些个位数也是！

且 来看看数据范围  ：$n\le 10^9$ ；非常良心的是 出题人吧大数据已经给在样例上了
```
1000000000 输出 81
```
所以最多只有81个$beautiful$  $number $ 不难想到 -----
打表警告⚠

----

首先 将着$81$个数 全部枚举出来 代码如下：
```
#include <bits/stdc++.h
>
using namespace std;

int n = 1e9, i1, ans = 0;
int main()
{
    for (int i = 1; i <= n; i++)
    {
        i1 = i;
        int tot = i % 10;
        for (int j = 0; i1; j++, i1 /= 10)//经典数位分离
        {
            if (tot == i1 % 10)
            {
                tot = i1 % 10;//一位一位判断 因为只有81个数 所以 不用考虑时间问题
            }
            else
            {
                ans++;
            }
        }
        if (ans == 0)
        {
            cout << i << ",";
        }
        ans = 0;
    }
}
```
##### 通俗易懂 时间在 $20s$ 内就可以全部枚举出来

得到如下数
```
1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
22, 33, 44, 55, 66, 77, 88, 99,
111, 222, 333, 444, 555, 666, 777, 888, 999,
1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999,
11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999,
111111, 222222, 333333, 444444, 555555, 666666, 777777, 888888, 999999,
1111111, 2222222, 3333333, 4444444, 5555555, 6666666, 7777777, 8888888, 9999999, 
11111111, 22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999, 
111111111, 222222222, 333333333, 444444444, 555555555, 666666666, 777777777, 888888888, 999999999

```
当然 这道题就非常简单了 只需统计 $total[i]$ 中比 $n$ 小的数即可
时间也非常快

代码如下
 ```
 #include <bits/stdc++.h>
 
using namespace std;//别学我---太懒了。。

int b[82] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
                    22, 33, 44, 55, 66, 77, 88, 99,
                    111, 222, 333, 444, 555, 666, 777, 888, 999,
                    1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999,
                    11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999,
                    111111, 222222, 333333, 444444, 555555, 666666, 777777, 888888, 999999,
                    1111111, 2222222, 3333333, 4444444, 5555555, 6666666, 7777777, 8888888, 9999999, 
                    11111111, 22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999, 
                    111111111, 222222222, 333333333, 444444444, 555555555, 666666666, 777777777, 888888888, 999999999};
///以上是打表内容
long long  n;
long long a;
long long ans = 0;
int main()
{
    cin >> n;
    while (n--)//注意多组数据输入！！！！！
    {
        long long i = 0;
        cin >> a;
        if(a >= 888888888 && a < 999999999)
        {
            cout << "80" << endl;
            continue;
        }
        if(a >= 999999999)
        {
            cout << "81" << endl;
            continue;
        }//以上是特判， 因为可能会爆掉 导致无输出
        while(a >= b[i]){//判断大小
            ans++;
            i++;
        }
        cout << ans << endl;
        ans = 0;//注意清零
}
```
~~打表很快，为什么不去试试呢 ？ 唔呣~~

好啦 以上是本篇题解的全部内容 去A了这道题把

---

## 作者：rsjw (赞：0)

~~打表水题~~

求各个数位上数都相同的数字个数

**总共就81个，为什么不打表**

```cpp
#include <cstdio>
int k[]={1,11,111,1111,11111,111111,1111111,11111111,111111111,2,22,222,2222,22222,222222,2222222,22222222,222222222,3,33,333,3333,33333,333333,3333333,33333333,333333333,4,44,444,4444,44444,444444,4444444,44444444,444444444,5,55,555,5555,55555,555555,5555555,55555555,555555555,6,66,666,6666,66666,666666,6666666,66666666,666666666,7,77,777,7777,77777,777777,7777777,77777777,777777777,8,88,888,8888,88888,888888,8888888,88888888,888888888,9,99,999,9999,99999,999999,9999999,99999999,999999999};
int main(){
    int t,n,cnt=0;
    scanf("%d",&t);
    while(t--){
    	cnt=0;
    	scanf("%d",&n);
    	for(int i=0;i<81;i++) if(k[i]<=n) cnt++;
    	printf("%d\n",cnt);
	}
	return 0;
}
```

~~真弱~~

---


# Filling Diamonds

## 题目描述

给定一个数字 $n$ ,要求你用 $n$ 个菱形去填满 $4n-2$ 个正三角形。求有多少种不同的填法。

其中，这一个菱形由两个正三角形组成，它可以被平移或是旋转，但是不可以被缩放。

上图是 $n \ = 1,2,3,4$ 时的需要填充的三角形。

## 说明/提示

------------


$1 \le T \le 10^{4}$。

$1 \le n \le 10^{9}$。
 
对于每一个测试数据，保证填充方法的种数 $\le 10^{18}$


------------


如下图，当 $n \ = 2 $ 时，有不同的两种填充方法。


------------

· Translated by black_trees

## 样例 #1

### 输入

```
2
2
1```

### 输出

```
2
1```

# 题解

## 作者：bunH2O (赞：5)

看到这种结论题如果没有头绪~~不要问我怎么看出来的结论题~~，不妨可以找一下规律。

一个菱形的摆放方式有很多种，但是最终的摆放方式只有两种：**横着和竖着**。

令$f(n)$为$n$时的种数。

我们不妨来分析一下最右边的两个三角形。

注：推导1、2、3仅限$n>=2$

### 1.右边两个组成一个菱形

那么它们左边的两个三角形就必须和他们自己左边的配对。

![](https://s1.ax1x.com/2020/04/13/GXd7h6.png)

同理它们左边的两个三角形也要这么做……

以此类推就会变成下图，共一种。

![](https://s1.ax1x.com/2020/04/13/GXdLcD.png)

### 2.它们分别和左边组成菱形

这种情况就更简单了，举个例子：

![](https://s1.ax1x.com/2020/04/13/GXwi38.png)

诶左边的东西怎么这么眼熟啊，左边不就是$f(n-1)$吗？

这种情况共$f(n-1)$种。

### 3.其他摆法

对于右上角的点而言，只有两种摆法：和左边的一起或和右边的一起。

而两种情况都讨论过了所以没有其他情况。

这种情况共$0$种。

### 4.综合

根据推导，可以发现$f(n)=f(n-1)+1$

因此我们看看$f(1)$，显然$f(1)=1$

所以$f(2)=2,f(3)=3,…,f(n)=n$

那么只要输入和输出一样就可以了。

代码如下：
```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        cout<<n<<endl;
    }
    return 0;
}
```

---

## 作者：naroanah (赞：3)

初看这道题，感到一脸懵逼，

看题目描述看了十分钟，进题解转了一圈，终于明白了。

首先，要理解最关键的部分，每种摆放方法中必定且只有一个竖着的菱形

拿n=3情况举例

![](https://cdn.luogu.com.cn/upload/image_hosting/k4l9iflj.png)

如果有两个竖着的菱形（图中红色部分）

那么就会出现一个沙漏型（图中黑色部分）

这是无论如何也填不满的

知道最关键的结论后，剩下的就简单多了

可以枚举把竖着的菱形放在哪里，剩下的摆放方式就确定了

所以这题就是输出n

下面是简单到爆炸的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n[10001];
int main()
{
	int T; 
	cin>>T;
	for(int i=1;i<=T;i++) cin>>n[i];
	for(int i=1;i<=T;i++) cout<<n[i]<<endl;
	return 0;
}

```
AC记录：[记录](https://www.luogu.com.cn/record/33454344)

---

## 作者：do_while_true (赞：2)

观察每种摆放方式的差异，发现各个摆放方式的差异只有中间的唯一一个竖着的块的位置。则一共有 $n$ 个位置可以放这个竖着的块。所以 $n$ 就是答案

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int T,n;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;
		cout<<n<<endl;
	}
	return 0;
}
```


---

## 作者：皎月半洒花 (赞：1)

审题解的说是重复解法。我寻思着就算题简单到爆炸这也不是重复解法啊？我想要审题解的人给一个解释。

经验还是要水的。这里说一个比较直观的转移。

设 $f(n)$ 为 $n$ 时的方案数。

考虑 $n$ 每次 $+1$，可以拆成两个单独的小菱形加上 $n-1$ 的方案，那么看上去通过分类讨论在左边插入还是右边插入，答案应该为

$$
f(n)=2\cdot f(n-1)
$$

但是这并不对，因为两种方式会有重复。发现重复就重复在共同使用了中间那个大小为 $n-2$ 的多边形上。于是可以知道正确的递推应该是

$$
f(n)=2\cdot f(n-1)-f(n-2)
$$

归纳可得

$$
f(n)=2\cdot (n-1)-(n-2)=n
$$


---

## 作者：_Harrisonwhl_ (赞：0)

这道题由计算机模拟不太现实，于是我果断选择找规律递推。

我们将 $n$ 个菱形的覆盖方法数为 $f(n)$。

分析开始：

看图可以看出不可能没有竖放的菱形，否则会剩$1$个竖着的菱形。

还可以看出至多只有一个竖放的菱形，否则会剩一个沙漏，无法覆盖！

所以，综上所述，每个图形有且仅有$1$个竖放的菱形，确定了竖放的位置即可确定一种摆放方法，而我们会发现竖放的位置有 $n$ 个，所以,$f(n) = n$。

于是，就得到了一个~~短到爆~~又~~简单到炸~~的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t,n;
    cin >> t;
    while (t--)
    {
        cin >> n;
        cout << n << endl;//f(n) = n,所以直接输出n。
    }
    return 0;
}
```

---

## 作者：Daidly (赞：0)

~~很水~~的一道题。
首先，我们观察每种摆放方式的不同之处，可以发现每个摆放方式的不同只有中间的一个菱形。所以，$n$的长度有多少，相对应的摆放方式就有几种不同。
```
 __________
/\/\/\/\/\/\
------------
\/\/\/\/\/\/
 -----------
```
如上，$n=6$，摆放方式就有$6$种。
所以，话不多说，上代码。
```
#include<bits/stdc++.h>//万能头
using namespace std;
int main()
{
  int a,b;
  cin>>a;
  for(int i=0;i<a;i++)
  {
     cin>>b;//输入
     cout<<b<<endl;//输出
  }return 0;
}
```




---

## 作者：devout (赞：0)

这道题手玩一下给的1-4我们就会发发现，一个沙漏型是绝对不可能摆出来的，也就是说我们最多只能摆一个竖着的菱形

同时我们考虑`《`，`》`形状的都有且仅有一种摆放的方式

所以我们可以枚举我们把竖着的菱形放在哪里，剩下两边的摆放方式就唯一确定了

所以这题就是输出$n$，，，

~~一直以为自己想错了还看了半天不敢交~~

代码就不贴了，这么简单大家自己写下就好。。。

---

## 作者：Velix (赞：0)

一道结论简单代码也简单的良心题。

首先，我们可以想象到，只可能有一个竖着的菱形，剩下的都是那些有两个菱形组成的C字形。

然后由于这个竖的菱形可以有N个地方可以放，所以答案就是N。

### Code
```
#include<iostream>
using namespace std;
int main()
{
  int a,b;
  cin>>a;
  for(int i=1;i<=a;i++)
  {
     cin>>b;
     cout<<b<<endl;
  }
}
```


---

## 作者：老咸鱼了 (赞：0)

![](https://subdomains.codeforces.ml/espresso/253cb03aef62ea2260f28f431e7e51c962b79f23.png)

![](https://subdomains.codeforces.ml/espresso/e72f8c635d8dc8aff12edac5df922a9410645cbb.png)

题目主要是要读懂意思，问你只能用横着的和竖着的两个平凑起来的三角形能够摆几种方式，样例里面给了你不同颜色插在里面是区分告诉你这个地方摆了什么，并不是换个颜色会多一种方法，然后我们发现这个图最多只能摆一个竖着的，n的时候一共有n种竖着的摆放方式，所以我们只要输入n就输出n就行了。

---


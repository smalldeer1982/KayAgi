# Permutation

## 题目描述

"作业时间到啦"-- Polycarpus突然想道。当然，他要先做他最喜欢的科目IT（计算机~）Polycarpus奇迹般地在20分钟内做完了除了最后一题以外的所有题目--不过他在最后一题上卡住了。所以Polycarpus想让你帮帮他：

此题定义中，排列就是，在保证1-n个整数都被包含的情况下n个整数的顺序。现在你有一个随机的序列a1,a2,...an（一共n个整数），每个数>=1且<=5000。请帮Polycarpus求出他获得一个排列之前最少需要改变多少数（他不能删除或加入数）。所谓的一次改变就是指把序列中的一个数改掉，比如说换成另一个整数。

## 说明/提示

第一个样例就是一个“排列”，所以不用进行改变；

第二个样例中只需要一次改变（关于数字1的改变），所以答案是2；

第三个样例中我们可以把第二个数变成4，第三个数变成2.

## 样例 #1

### 输入

```
3
3 1 2
```

### 输出

```
0
```

## 样例 #2

### 输入

```
2
2 2
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5
5 3 3 3 1
```

### 输出

```
2
```

# 题解

## 作者：Sayori (赞：2)

### Description
对于一个长度为 $n$ 的序列,每次操作可以改变序列上的任意一个数，求问最少的次数使这个序列变成包含 $1-n$ 个整数
### Solution
显而易见的，(设 $a$ 为原序列，$o$ 为桶) 我们可以把 $a_i$ 的值存进桶里，即 $o_{a_i}$++ 。统计答案时，每次在桶数组里扫描，这时有两种情况：  
1. 当前权值大于 $n$ 时，$ans$ = $ans$ + $o_i$  
2. 当前权值小于等于 $n$ 时，$ans$ = $ans$ + $o_i$ - 1
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5010;
int n, a[N], o[N], ans;
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i)
        scanf("%d", &a[i]), o[a[i]]++;//将a[i]的值存入桶里
    for(int i = 1; i <= N - 10; ++i){
        if(i > n && o[i]) ans += o[i];//当前权值>n
        if(i <= n && o[i] > 1) ans += o[i] - 1;//当前权值<=n
    }
    printf("%d\n", ans);
}
```


---

## 作者：_Spectator_ (赞：1)


[可能更好的食用体验](https://www.luogu.com.cn/blog/523641/CF137B) $|$ 
[题目传送门](https://www.luogu.com.cn/problem/CF137B) $|$ [我的其他题解](https://www.luogu.com.cn/blog/523641/#type=题解)

------------

所谓“排列”其实很好理解，只要一个数列中 $1\sim n$ 每个数都出现了，该数列即为一个“排列”。所以，只需统计这个数列中有几个数没有出现，就是需要改变的数的个数。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,ans;
int js[5005];
int main()
{　
	cin>>n;　
	for(int i=1;i<=n;i++)　
  		 cin>>a,js[a]++;//数组计数，统计每个数字是否出现过
	for(int i=1;i<=n;i++)
		ans+=js[i]==0;//如果该数没有在数列中出现过，则增加答案
	cout<<ans;　
	return 0;　
}　

```

**[${\color{Black}\text{xt\_\_}}$](https://www.luogu.com.cn/user/523641) 温馨提示：**

${\color{White}\colorbox{#AD8800} {题解千万条，理解第一条。直接粘题解，棕名两行泪。}} $

---

## 作者：DPseud (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/CF137B)

# 题目意思

本题的意思就是求将一个序列变为包括 $1$ 到 $n$ 的所有数且数字不重复的序列的最少步数，注意这个数组可以不排序。

# 题目思路

用一个 map 来存储原序列中每个数出现的次数，然后遍历该序列，如果有大于 $n$ 的数存在，我们就需要将它调到 $1$ 到 $n$ 的范围内，即计数器加上该数出现的次数；如果有小于 $n$ 的数存在于不只一遍，我们就需要将多出来的出现次数调到其它位置，当然，原数也是要保留的，因此计数器加上该数出现的次数减一。

可能有人会问：这样做不会让数组出现重复的数吗？其实我们看看题目，题目中说到不能删去或添加数，而出现重复就意味着需要增加数，这样的样例显然是不存在的。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int> bj;//定义一个map，下标为int型，计数为int型，map的好处在于范围不定且下标可以为任意类型 
int main()
{
	static int n,a[5555],sum;
	cin>>n;
	for(int i=0;i<n;i++){cin>>a[i];bj[a[i]]++;}//下标计数 
	for(int i=0;i<5555;i++)//遍历map 
	{
		if(bj[i]>1&&i<=n)sum+=bj[i]-1;//如果小于n且出现过多次，那么就将它的部分分配到其它地方，留下一个在原地，计数器加上步数 
		if(bj[i]>=1&&i>n)sum+=bj[i];//如果大于n，那么就将它分配到其它地方，计数器加上步数
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

#### 题目分析
题目里要求的是要改多少个数，我们可以反过来想，先求出有多少个数不用改，然后用 $n$ 减去这个数就可以了。使用数组计数的方法，每输入一个数，如果标记是 $0$ 且这个数 $<n$，也就是没有出现过，不用改变的数量加 $1$，然后再把这个数标记为 $1$。最后输出 $n-$ 不用改变的数量。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,s;
int a[10000];
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>s;
		if(a[s]==0&&s<=n)x++;
		a[s]=1;
	}
	cout<<n-x;
	return 0;
}
```


---

## 作者：Y_J_Y (赞：0)

看见某题解里的用桶的方法，蒟蒻表示根本看不懂啊，那么对于这道cf的B题，我们该怎么食用呢

在冥思苦想很久后，我发现这道题根本不需任何骚操作，我们采用一种比较优雅的暴力

接下来，让我们来分析一下这道题：

题面：
对于一个长度为 n 的序列,每次操作可以改变序列上的任意一个数，求问最少的次数使这个序列变成包含 1-n 个整数

我们yy一下，显然当你已经放入了i个数时，现在又加入了一个新的数，那么我们可以考虑两点：

1、它比n要小，又没有重复，那么显然他可以加入这个序列（为什么呢，因为这是n个数的排列，那么有一种贪心的思想，与其这次的数改了，等待下面一个可能的值加入，还不如直接加入，因为都是一个花费）

2。当它比n要大的时候，直接更改为其中的一个数就好了，花费加一，可能有人又有疑问了，为什么呢（因为他是n个数得排列啊，每一个数最后肯定都会成为一个在【1，n】集合中的一个数）

分析了这么多，这道难题也就成为了一道水题

在下面的代码中，我并没有记录每一个加入的数，而是只记录了他有没有出现过，原因在上面的分析中也已经讲过了


~~代码似乎比那篇题解更好理解和简洁呢QAQ~~
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){//快读
	ll x = 0; char ch = getchar(); bool positive = 1;
	for (; !isdigit(ch); ch = getchar())	if (ch == '-')	positive = 0;
	for (; isdigit(ch); ch = getchar())	x = x * 10 + ch - '0';
	return positive ? x : -x;
}
#define maxn 5100
int a[maxn];//读入的数组
int vis[maxn];//记录每一个出现过得值
int main() {
	int n;
	n=read();
	int ans=0;
	for(int i=1;i<=n;i++) {
		a[i]=read();//当然你可以直接把a【i】改为一个int类型的数
		vis[a[i]]++;
		if(vis[a[i]]>1||a[i]>n) {
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
(σﾟ∀ﾟ)σ..:*☆哎哟不错哦

---


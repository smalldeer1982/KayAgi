# Копирование файлов I

## 题目描述

В этой версии задачи размеры копируемых файлов не превышают $ 1000 $ байт.

Вы копируете с одного сервера на другой $ n $ файлов размером $ a_1, a_2, \ldots, a_n $ байт. Файлы копируются последовательно в заданном порядке.

При копировании вы видите два прогресс-бара: первый показывает процент скопированных данных в текущем файле, а второй — общий процент скопированных данных по всем $ n $ файлам. Оба процента отображаются округлёнными вниз до целого числа. Значения на прогресс-барах обновляются после копирования каждого байта.

Формально, после копирования байта номер $ x $ из файла номер $ i $ первый прогресс-бар показывает $ \lfloor \frac{100 \cdot x}{a_i} \rfloor $ процентов, а второй — $ \lfloor \frac{100 \cdot (a_1 + a_2 + \ldots + a_{i - 1} + x)}{a_1 + a_2 + \ldots + a_n} \rfloor $ процентов. В самом начале копирования оба прогресс-бара показывают $ 0 $ процентов.

Найдите все такие целые числа от $ 0 $ до $ 100 $ включительно, что существует момент времени, в который оба прогресс-бара одновременно показывают это число. Выведите эти числа в порядке возрастания.

## 样例 #1

### 输入

```
1
6```

### 输出

```
0
16
33
50
66
83
100```

## 样例 #2

### 输入

```
2
100 500```

### 输出

```
0
95
96
97
98
99
100```

## 样例 #3

### 输入

```
4
1000 2 2 998```

### 输出

```
0
50
99
100```

## 样例 #4

### 输入

```
6
170 130 400 256 30 100```

### 输出

```
0
17
43
44
84
90
99
100```

# 题解

## 作者：_32bit_Silentnight (赞：3)

# CF1769B1 题解
## 题目分析
**暴力模拟**题。

在传输第 $i$ 个文件的第 $x$ 字节时，若当前文件传输进度 $q$ 等于总文件传输进度 $w$，输出 $q$（或 $w$）。

题目已经将 $q$ 和 $w$ 怎么算告诉得很清楚了，但不能蛮算，不然极易 WA（CF 被卡一次）。。所以，我们对于 $q$，直接把 $\lfloor\frac{100\times x}{a_i}\rfloor$ 算出来。但对于 $w$，得先用一个 $n$ 存 $a_1+a_2+\cdots a_k$（$k$ 为文件数），在每轮算一个 $s$，为 $a_1+a_2+\cdots a_i$。所以，$w$ 即为 $\lfloor\frac{100\times s}{n}\rfloor$。

接下来，$q,w$ 判等。**注意：查重！！！（CF WA 两次）** 若已确定此时 $q=w$，则不再输出。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[114],i,s,q,w,j,k;bool b[114];//n,k 一旦失手混了 RE（CF 卡两次）
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
        s+=a[i];//计算 s
    }
    for(i=1;i<=n;i++){
        for(j=0;j<=a[i];j++){
            q=100*j/a[i];
            w=100*(k+j)/s;//算 q,w
            if(q==w&&!b[q])printf("%d\n",q),b[q]=true;//判等，查重
        }
        k+=a[i];//增加 k
    }
}
```

---

## 作者：MoonCake2011 (赞：3)

我们预处理出 $a_1+\cdots+a_n$ 的值方便计算。

每传输一字节就将字节数加一并计算，如果 $a=b$，将 $a$ 或者 $b$ 塞进 `set` 容器里。

毕竟 `set` 容器可以自动排序去重，只图一个方便。

最开始要输出 0 特判。

我们可以写出这样的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110];
int sum,cnt;
set<int>s;
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
   	cout<<0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=a[i];j++){
			int A=100*j/a[i];
			int B=100*cnt/sum;
			if(A==B)
				s.insert(A);
			cnt++; 
		}
	}
	set<int>::iterator it;
	for(it=s.begin();it!=s.end();it++) cout<<*it<<"\n";
	return 0;
} 
```

就会 WA 的一败涂地。

因为我们没考虑 $j=0$ 的情况。

这时候是上一个文件与下一个文件的交接处。

于是又可以写出这样的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110];
int sum,cnt;
set<int>s;
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
	for(int i=1;i<=n;i++){
		for(int j=0;j<=a[i];j++){
			int A=100*j/a[i];
			int B=100*cnt/sum;
			if(A==B)
				s.insert(A);
			cnt++; 
		}
	}
	set<int>::iterator it;
	for(it=s.begin();it!=s.end();it++) cout<<*it<<"\n";
	return 0;
} 
```

~~连样例都过不了~~。

这是因为在 $j=0$ 时 $cnt$ 多加了一。

所以最后我们需要减回来。

AC 代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110];
int sum,cnt;
set<int>s;
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
	for(int i=1;i<=n;i++){
		for(int j=0;j<=a[i];j++){
			int A=100*j/a[i];
			int B=100*cnt/sum;
			if(A==B)
				s.insert(A);
			cnt++; 
		}
		cnt--;
	}
	set<int>::iterator it;
	for(it=s.begin();it!=s.end();it++) cout<<*it<<"\n";
	return 0;
} 
```

---

## 作者：GoodLuckCat (赞：2)

## CF1769B1题解

~~第一篇题解~~

[题目在这里](https://www.luogu.com.cn/problem/CF1769B1)

这一题直接模拟就行了。

首先，先输出 $0$，因为这个时候两个都是 $0\%$，符合条件。

接下来，模拟就行了。

注意：

```cpp
if(!b[c*100/s]&&c*100/s!=0)cout<<c*100/s<<endl;
b[c*100/s]++;
```

这两行不能写成

```cpp
cout<<c*100/s<<endl;
```

- 如果没写 `!b[c*100/s]` 和 `b[c*100/s]++`，会重复。

- 如果没写 `c*100/s!=0` ，也会重复（因为开头有输出 $0$ 了）。

Code

```cpp
#include<iostream>
using namespace std;
int a[10000];
int b[10000];
int main()
{
    cout<<"0\n";
    int n,s=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s+=a[i];
    }
    int c=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=a[i];j++)
        {
            c++;
            if(j*100/a[i]==c*100/s)
            {
                if(!b[c*100/s]&&c*100/s!=0)cout<<c*100/s<<endl;
                b[c*100/s]++;
            }
        }
    }
}
```

---

## 作者：Speech_less (赞：2)

# CF1769B1 Копирование файлов I 
## 题目大意
用题目中给的公式计算 $a$，$b$ 求出 $a$，$b$ 输出当 $a = b$ 时的 $a$，$b$。
由于范围小，时间长，所以直接暴力枚举就可以了。
~~为什么要查重！！！一道普及减怎么有毒瘤！~~
### PART 1：定义变量
变量的作用：$sum = a_1 + ...... + a_n$ ，$ans = a_1 + ...... + a_i-1$。
由于要查重，所以要开 $flag$ 数组 ~~（放心，不会 MLE 的）~~。
### PART 2：输入
省略
### PART 3：枚举部分
由于 $sum = a_1 + ...... + a_n$，$ans = a_1 + ...... + a_i-1$，可以简化 $b = 100 \times ( ans + x ) \div sum$。
接下来直接判断 $+$ 枚举就可以了。
### 核心代码
```cpp
if(!flag[100*j/k[i]]){
	if(100*j/k[i]==100*(ans+j)/sum){
		y[p]=100*j/k[i];
		p++;
		flag[100*j/k[i]]=1;
	}
}
```

------------

### AC代码上交：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,p=0,sum,ans,k[105],y[20005],flag[1005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&k[i]);
		sum+=k[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=k[i];j++){
			if(!flag[100*j/k[i]]){
				if(100*j/k[i]==100*(ans+j)/sum){
					y[p]=100*j/k[i];
					p++;
					flag[100*j/k[i]]=1;
				}
			}
		}
		ans+=k[i];
	}
	sort(y,y+p);
	for(int i=0;i<p;i++)
		cout<<y[i]<<endl;
	return 0;
} 
```
\*注：切记勿抄袭，抄袭马上变棕名。
题外：求管理大大给过吧！QwQ。

---

## 作者：liusiqi10 (赞：1)

#  Копирование файлов I 题解

## Part 1：核心思想

**枚举法**

## Part 2：定义变量

这道题的核心是用一个 $book$ 数组**去重**。其中可以用变量 $now$ 记录**已经下载的总字节数**，每个文件下载完进行**更新**。用变量 $sum$ 记录**总字节数**。

用 $j$ 枚举**当前文件下载的字节数**，用 $a$ 数组记录**每个文件的字节数**。

## Part 3：核心计算

可以得到两个百分比：

$$p_{1}=100 \times j \div a_{i}$$

$$p_{2}=100 \times (now+j) \div sum$$

## Part 4：完整代码

```cpp

#include<bits/stdc++.h>

using namespace std;

int a[10000],book[10000];

int main()

{

	int n,sum=0,now=0;

	cin>>n;

	for(int i=1;i<=n;i++)

	{

		cin>>a[i];

		sum+=a[i];

	}

	for(int i=1;i<=n;i++)

	{

		for(int j=0;j<=a[i];j++)

		{

			int p1=100*j/a[i];

			int p2=100*(now+j)/sum;

			if(p1==p2&&book[p1]==0)	//一定要去重，否则你可以运行第二个样例试试 

			{

				cout<<p1<<endl;

				book[p1]=1; 	//有过的打上标记

			}

		}

		now+=a[i];

	}

		return 0;

}

```

本 _**蒟蒻**_ 的第一篇题解（已经失败三次了）求过 QwQ 

---

## 作者：i_love_tym (赞：0)

## 思路

这道题其实只需要按照题意模拟就好了，模拟的时候可以用一个 ``map``  来为答案去重（其他的类型也可以），最后输出即可。

[map是什么](https://oi-wiki.org/lang/csl/associative-container/#map)

## 实现

先从 $1$ 到 $n$ 遍历每个文件，再从 $1$ 枚举到 $a_i$，判断当前这个字节是否满足条件，满足就把它放到 ``map`` 中。 而对于 B 公式中的 $a_1+...+a_{i-1}$,我们可以用一个[前缀和](https://oi-wiki.org/basic/prefix-sum/) $O(1)$ 求出。最后输出就好了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],sum[105];
map<int,bool> t;
int main(){
	int n;
	cin>>n;
	cout<<0<<endl;//由于A=B=0时也是满足的
	for(int i=1;i<=n;i++) cin>>a[i],sum[i]=sum[i-1]+a[i];	
	for(int i=1;i<=n;i++){	
		for(int j=0;j<=a[i];j++){		
			if(100*j/a[i]==100*(sum[i-1]+j)/sum[n]) t[100*j/a[i]]=true;
		}
	}
	for(int i=1;i<=10000;i++) //也可以用auto类，但我的编译器不支持，所以写成了这样
		if(t[i]) cout<<i<<endl;
}
```

---

## 作者：Code_Fish_GoodBye (赞：0)

[题目链接](https://www.luogu.com.cn/problem/CF1769B1)
## 题目大意
从小到大输出满足 $\frac{100 \times x}{a_i}=\frac{100 \times (\sum_{j=1}^{i-1} a_j+x)}{\sum a_j}$ 时它们的值。

## 思路
看到数据范围 $n\leq 100$，考虑暴力枚举传输每一个字节时的情况，判断 $a$ 和 $b$ 的值是否相等即可。

对于答案，我们使用 ```set``` 来储存，它可以实现自动去重与排序的功能，大大减少了代码的复杂度。

于是乎，我写出了第 $1$ 份代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,z[105];
set<int>y;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>z[i];
	for(int i=1;i<=n;i++){
		for(int j=0;j<=z[i];j++){
			a=100*j/z[i];
			int tot=0,tot2=0;
			for(int k=1;k<=i-1;k++) tot+=z[k];//区间求和
			for(int k=1;k<=n;k++) tot2+=z[k];//区间求和
			b=(100*(tot+j))/tot2;
			if(a==b) y.insert(a);//判断
		}
	}
	for(auto i:y) cout<<i<<endl;//遍历并输出
	return 0;
}
```
仔细观察，我们发现这份代码其实是 $O(n^2 \sum z_i)$ 的，虽然可过，但仍有更优解法。

观察这两行代码：
```cpp
for(int k=1;k<=i-1;k++) tot+=z[k];
for(int k=1;k<=n;k++) tot2+=z[k];
```
我们发现，这两行代码起到的是区间求和的作用，我们可以使用前缀和优秀的 $O(1)$ 区间求和能力来优化本题代码。可达到 $O(n \sum z_i)$ 的时间复杂度。

**参考代码（请勿抄袭）：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,z[105],sum[105];//z代表当前字节数，sum数组记录前缀和 
set<int>y;//STL神器 
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>z[i];
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+z[i];//处理前缀和 
	for(int i=1;i<=n;i++){//每个文件 
		for(int j=0;j<=z[i];j++){//每个文件的字节 
			a=100*j/z[i];
			b=(100*(sum[i-1]-sum[0]+j))/(sum[n]-sum[0]);//前缀和快速求区间和 
			if(a==b) y.insert(a);//放入set中，自动去重+排序 
		}
	}
	for(auto i:y) cout<<i<<endl;//遍历并输出 
	return 0;
}

```

---

## 作者：HDZmessi (赞：0)

题外话：一道俄语题，说道俄语，我想到了《星星》这首歌，“Для чего родился на свет, я взрослел и рос”......

就是一道模拟题，没有什么特别要注意的地方，就是用不能重复而已，用一个变量记录前缀和，另一个变量记录总和然后按题意模拟，遇到的输出然后换行就可以了，个人习惯用 map 数组其实也可以，一道水题，个人觉得可以降红。

AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],num,sum;
map<int,int> p;
int main(){
//	freopen("a.in","r",stdin);
	cin>>n;
	for(int i=0;i<n;i++){ 
		cin>>a[i];
		num+=a[i];
	}
	for(int i=0;i<n;i++){
    	for(int j=0;j<=a[i];j++){
			int x=100*j/a[i];
			int y=100*(sum+j)/num;
			if(x==y&&p[x]==0){
				cout<<x<<"\n";
				p[x]++;
			}
		}
		sum+=a[i];
	}
	return 0;
}
```

语文不好，就不注释了，求过～

---

## 作者：Wangjunhao2011 (赞：0)

这道题是一道模拟题，按照题目要求做。用枚举（是的，枚举就行）。

其中 $\left \lfloor  \right \rfloor $ 符号代表的是向下取整，例如 $\left \lfloor   1.2\right \rfloor=1$。意思就是我们直接用一个 ``int`` 来装 $a$ 和 $b$。

根据题意 $a = \lfloor \frac{100 \times x}{a_i} \rfloor$，$b = \lfloor \frac{100 \times (a_1 + ... + a_{i - 1} + x)}{a_1 + ... + a_n} \rfloor$。

于是，我们可以拿一个变量 $sum$ 来储存 $a_1 + ... + a_n$，拿一个 $now$ 来储存 $a_1 + ... + a_{i - 1}$，并且实时更新 $now$。随后再进行运算。一定要去重！否则如链接[R120231730](https://www.luogu.com.cn/record/120231730)。

AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000],b[10000],sum,now;
int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<=a[i];j++){
            int p=100*j/a[i];
            int pp=100*(now+j)/sum;
            if(p==pp&&b[p]==0){
                cout<<p<<"\n";
                b[p]=1;
            }
        }
        now+=a[i];
    }
    return 0;
}
```

---

## 作者：zhuweiqi (赞：0)

由于本题的数据范围很小，所以我们可以使用**枚举法**，我们设当前传输的是第 $i$ 个文件的第 $j$ 个字节，$now=\sum_{k=1}^{i-1} a_k$，$sum=\sum_{k=1}^{n} a_k$，则 $a=\left\lfloor\dfrac{100\times j}{a_i}\right\rfloor$，$b=\left\lfloor\dfrac{100\times \left(now+j\right)}{sum}\right\rfloor$，注意，我们还需要进行**查重**，即如果 $a=b$ 并且 $a$ 在之前没被输出过，我们才需要输出 $a$ 的值，否则不用输出，上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105];
int b[105];
int main(){
	int n,sum=0,now=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	printf("%d\n",0);b[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=a[i];j++){
			int x=100*j/a[i];
			int y=100*(now+j)/sum;
			if(x==y && b[x]==0){
				printf("%d\n",x);
				b[x]=1;
			}
		}
		now+=a[i];
	}
	return 0;
}
```


---

## 作者：lovely_AKCode (赞：0)

# 题目大意

这题非常简单，按要求暴力枚举，再用 map 或 set 去重在输出就好了。

[map](https://blog.csdn.net/sevenjoin/article/details/81943864?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169266312816800186591878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169266312816800186591878&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81943864-null-null.142^v93^chatsearchT3_2&utm_term=map&spm=1018.2226.3001.4187)

[set](https://blog.csdn.net/weixin_52341477/article/details/119248919?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169266397516800180647905%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169266397516800180647905&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119248919-null-null.142^v93^chatsearchT3_2&utm_term=set&spm=1018.2226.3001.4187).

# 题目思路
在 map 或 set 对答案去重，答案可以用前缀和算。便利每个文件，判断是否满足条件，对于 $a_1 + a_2 + ... + a_{i-1}$，可以用前缀和。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],q[105],t[10005],n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) q[i]=q[i-1]+a[i];	
	for(int i=1;i<=n;i++){	
		for(int j=0;j<=a[i];j++){	
			int u=100*j/a[i],v=100*(q[i-1]+j)/q[n];
			if(u==v) t[u]=true;
		}
	}
	for(int i=0;i<=10000;i++)  if(t[i]) cout<<i<<endl;
}
```

---


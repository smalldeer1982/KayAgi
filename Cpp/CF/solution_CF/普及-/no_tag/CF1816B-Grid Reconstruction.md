# Grid Reconstruction

## 题目描述

在一个 $2×n$ 的网格中 （$n$ 为偶数），标记 $1,2,\ldots,2n$，但每个数只能被使用 $1$ 次。

某条路径是从 $(1,1)$ 开始的单元序列，随后不断地向下走或向右走，直到到达 $(2,n)$。注意：这条路径不能超出网格的边界。

通过这条路径的成本是这条路径所通过的单元格上的数字交替和，即，设路径上的数为 $a,a_1,a_2,\ldots,a_k$（它是第几个被标记到的，它的下标就是几），则通过这条路径的成本就是 $ a_1 - a_2 + a_3 - a_4 + \ldots = \sum_{i=1}^k a_i \cdot (-1)^{i+1} $。

你需要求一个在网格中标记 $1,2,...,2n$ 的方案，最大化成本最小的路径的成本。如果有多个答案，你可以输出任意一个。本题中，每个测试点包含 $t$ 组数据。

## 说明/提示

在第一组测试数据中，只有两条从 $(1,1)$ 到 $(2,2)$ 的路径，它们的成本分别是 $3-1+4=6$ 和 $3-2+4=5$，其中成本更小的方案是 $5$，这是最优的方案。

在第二组测试数据中，有四条从 $(1,1)$ 到 $(2,4)$ 的路径，它们的成本分别是 $8-1+5-3+7=16$，$8-2+5-3+7=15$，$8-2+6-3+7=16$ 和 $8-2+6-4+7=15$，其中成本最小的一种方案是 $15$，这是最优的方案。

## 样例 #1

### 输入

```
3
2
4
6```

### 输出

```
3 2
1 4
8 2 6 4
1 5 3 7
11 5 9 1 7 3
6 10 2 8 4 12```

# 题解

## 作者：szhqwq (赞：4)

## 题意

给定一个 $2 \cdot n$ 的矩阵，$n$ 为偶数，从 $(1,1)$ 走到 $(2,n)$ 的代价为写在路径中单元格上的数字的**交替和**，将 $1,2,\dots,2 \cdot n$ 填入每个单元格中，求从 $(1,1)$ 到 $(2,n)$ 的所有路径的最小代价的最大值的方案。

## 分析

我们考虑所有路径中，可以证明最后得到的代价仅有 $(1,1)$ 到 $(1,n)$ 再到 $(2,n)$，以及 $(1,1)$ 到 $(2,1)$ 再到 $(2,n)$ 两种不同代价，那么就可以只考虑这两条路径。

因为 $(1,1)$ 和 $(2,n)$ 是必定经过且做加法的，那么我们就将最大的两个数给到这两个单元格。

此题不难想到，要尽量使第 $1$ 行的**奇数**位以及第 $2$ 行的**偶数**位更大，剩余的尽量小才能使所有路径最小代价最大。

那么我们就将 $n + 1,n + 2,\dots,2 \cdot n$ 填在第 $1$ 行的**奇数**位以及第 $2$ 行的**偶数**位中，$1,2,\dots,n$ 填在剩下的单元格中即可，这就是一个模拟过程了。

[Link](https://codeforces.com/contest/1816/submission/202573255)

$$\text{Thanks}$$

---

## 作者：封禁用户 (赞：4)

## 思路
使所有路径的最小值最大，我们只需要考虑 $2$ 条极端路径：从 $(1,1)$ 到 $(1,n)$ 再到 $(2,n)$ 和 从 $(1,1)$ 到 $(2,1)$ 再到 $(2,n)$。不难发现，这两条路径中，$(1,1)$ 和 $(2,n)$ 是公共的，而走到这两个点在每一条路径中的步数均为偶数，因为 $n$ 一定为偶数。所以，我们必须将两个最大的值赋给这两个点。认识数字的人都知道，相邻两个整数一定是一奇一偶的。而在步数为偶数时，操作是减，所以我们完全可以使同一行的所有数字奇偶性相同，并使奇数位的数尽量大，偶数位的数尽量小。这样来排列，最后的值一定最大。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n;
signed main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		for(int i=1;i<=2;i++)
			if(i==1)
			{
				int nozhiyin=n*2,zhiyin=2;
				for(int j=1;j<=n;j++)
					if(j&1) cout<<nozhiyin<<" ",nozhiyin-=2;
					//奇数位，从（1,1）到（1,n）递减；使得（1,1）为最大的偶数 
					else cout<<zhiyin<<" ",zhiyin+=2;
			}
			else
			{
				int nozhiyin=1+n,zhiyin=1;
				for(int j=1;j<=n;j++)
					if(j&1) cout<<zhiyin<<" ",zhiyin+=2;
					//奇数位，从（2,1）到（2,n）递增；使得（2,n）为最大的奇数 
					else cout<<nozhiyin<<" ",s+=2;
			}
			cout<<endl;
	}
}
```


---

## 作者：zengxuheng (赞：3)

# 题意
给定一个 $n$，$n$ 为偶数。现在请你填一个 $2*n$ 的矩阵，将 $1,2,3,\dots,2*n$ 填入每个格子中。使得 $(1,1)$ 到 $(2,n)$ 所有路径的交替和的最小值最大。
# 思路
其实只用考虑两条路径：走 $(1,1)$，$(1,2)$，$(1,3)$，$\dots$，$(1,n)$，$(2,n)$ 或者走 $(1,1)$，$(2,1)$，$(2,2)$，$(2,3)$，$\dots$，$(2,n)$ 的路径。

如图所示：

当 $n$ 等于 $4$ 时，为了使这两个路径的交替和最小值最大，有以下的填法：

|$+$|$-$|$+$|$-$|
|:-:|:-:|:-:|:-:|
|$-$|$+$|$-$|$+$|

我们要让所有的 $+$ 的和最大以及所有的 $-$ 的和最小即可。

并且每条路径一定要经过起点和终点所以要让起点和终点最大。

为了使 $+$ 的位置和最大，所以把 $n+1\dots2n$ 给 $+$ 的位置。
相反，把 $1\dots n$ 给 $-$ 的位置。
# 代码
我采用了交替相加的方法，例如把第一行的 $+$ 位置和 $-$ 位置设为奇数。将第二行的 $+$ 位置和 $-$ 位置设为偶数。可以有效使两条路径尽量相等。
```
#include<bits/stdc++.h>
using namespace std;
int main() {
	int t;
	cin>>t;
	while(t--) {
		int n,x,y;
		cin>>n;
		x=n*2,y=2;
		for(int i=1; i<=n; i++)
			if(i%2){
				cout<<x<<" ";
				x-=2;
			}
			else{
				cout<<y<<" ";
				y+=2;
			}
		cout<<'\n';
		x=1,y=n+1;
		for(int i=1; i<=n; i++)
			if(i%2){
				cout<<x<<" ";
				x+=2;
			} 
			else{
				cout<<y<<" ";
				y+=2;
			} 
		cout<<'\n';
	}
}
```

---

## 作者：Dreamer_Boy (赞：2)

一道模拟题。

#### 分析
根据题意可知，矩阵上的每个点的符号都是确定的，所以无论 $n$ 是什么值。它的点 $(1,1)$ 和点 $(2,n)$ 是必定经过的，我们应该考虑点的值，如果 $(2,n)$ 为正，那么就填 $2*n$ 这个数，反之填最小值 $1$ 那么剩下的数，为了让最后结果最大化，应该有序的排放，两种都枚举一下即可：
```
//n位奇数
//正的
for(int j=1;j<=n;j++)
{
	for(int i=1;i<=2;i++)
	{
		if((i+j)%2==0 && vis[i][j]==false)//没走过
		{
         h--;
			a[i][j]=h;
		}
	}
}
//负的
for(int j=1;j<=n;j++)
{
	for(int i=1;i<=2;i++)
	{
		if((i+j)%1==0 && !vis[i][j])//与上面同理
		{
        h--;
			a[i][j]=h;
		}
	}
}
```


我们可以通过下图理解（画的不好请谅解）：

![](https://cdn.luogu.com.cn/upload/image_hosting/4sd753fv.png)

如果我们调换 $2$ 和 $3$ 的位置，那么就不合法了。

#### 代码
见上，还有 $n$ 为偶数的就不给出了，同理。可能写的比较烦，总之赛时侥幸过了。


---

## 作者：Mason123456 (赞：1)

## [CF1816B](https://www.luogu.com.cn/problem/CF1816B) & [CF1816B_CF直达](https://codeforces.com/problemset/problem/1816/B)

### 题意

给定一个数组 $2 \times n$，一共有 $2n$ 个数，要在合适的搭配下，交替和最大。

### 思路

第一眼以为是 `DP`，不过没找到转移方程，又因为数据确实非常小，决定用**贪心**。

不难发现，无论如何，每一条路径都要经过起点和终点（~~废话~~），所以我们会要求起点和终点最大。

至于其他点，只需在**正位置**保持和最大，**负位置**保持和最小即可。我们发现，第一行的奇数位、第二行的偶数位，永远是**正位置**；第一行的偶数位、第二行的奇数位，永远是**负位置**。所以我们只需把 $n+1 \dots 2n$ 交给**正位置**，把 $1 \dots n$ 交给**负位置**即可。

### CODE [Link](https://codeforces.com/contest/1816/submission/251059253)

在赋值的区域有很多写法：

```cpp
for(int i = 2;i < n;i++){
	a[(i + 1) % 2 + 1][i] = mxnum ++;
}
```

`(i + 1) % 2 + 1` 意思是将下标为偶数的横坐标赋成 $2$，将下表为奇数的横坐标赋成 $1$。也就是取**正位置**。

```cpp
for(int i = 1;i <= n;i++){
	a[i % 2 + 1][i] = mnnum ++;
}
```

这段则意思相反。

### AC CODE

```cpp
# include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int a[5][N];
int q, n;
int main(){
	cin>>q;
	while(q--){
		cin>>n;
		int mxnum = n + 1;
		int mnnum = 1;
		a[1][1] = 2 * n-1;
		a[2][n] = 2 * n;
		
		for(int i = 2;i < n;i++){
			a[(i + 1) % 2 + 1][i] = mxnum ++;
		}
		
		for(int i = 1;i <= n;i++){
			a[i % 2 + 1][i] = mnnum ++;
		}
		
		for(int i = 1;i <= 2;i++){
			for(int j = 1;j <= n;j++){
				cout<<a[i][j]<<" \n"[j == n];// 当j != n 时，取字符串第0为，也就是空格。否则取换行。
			}
		}
	}
	return 0;
} 
```

---

## 作者：_xxxxx_ (赞：1)

### 题意

给出一个偶数 $n$，要你构造出一个 $2 \times n$ 的矩阵，满足按下列方式取数**最坏情况**能得到的**最大收益**。

1. 每次只能取上一次取的下面格或右边格。

2. 记经过的是第 $x$ 个格子，如果 $x$ 为偶数，收益加上当前数，否则减去当前数。

3. 要从点 $(1,1)$ 走到点 $(2,n)$。

4. 矩阵中必须且只能含有 $1,2,...,2n$ 中的每一个数。

### 分析

注：偶数位意为走了偶数步后的格子。

因为要从点 $(1,1)$ 走到点 $(2,n)$，且这两个点无论怎么走都是加入总收益中的，所以肯定要将 $2n$ 和 $2n-1$ 放到这两个点上。

同时，我们可以知道，最坏情况一定会选大的减，小的加，所以使得减的少，加的多就为最优方案。

此时可以发现，矩阵是 $2 \times n$，并且不能回头取。容易想到将 $1,2,...,n$ 放进奇数位，将 $n+1,n+2,...,2n$ 放入偶数位。

但是这样的构造方式不满足 $2n$ 和 $2n-1$ 放到必经点上，不是最优。在将 $2n-1$ 放进 $(1,1)$ 后，就意味着这一行的偶数位要为大于 $n$ 的奇数。另一行同理。

剩下的就是小于 $n$ 的数，这些数可以随便放进剩下的格子了，不会影响结果。为了方便，我将偶数放一行，奇数放一行。

### 代码

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <algorithm>
#define LL long long
using namespace std;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;
int T, n;
int odd, even1, even2;
signed main()
{
	cin >> T;
	while(T--)
	{
		cin >> n;
		odd = 1;
		//第一行放奇数 
		for(int i = 1; i <= n; i++)
		{
			if(i & 1)//是奇数格
			{
				cout << n * 2 - odd << " ";
			}
			else
			{
				cout << odd << " ";
				odd += 2;
			}
		}
		printf("\n");
		//第二行放偶数 
		even1 = 2, even2 = n + 2;
		for(int i = 1; i <= n; i++)
		{
			if(i & 1)//是奇数格
			{
				cout << even1 << " ";
				even1 += 2;
			}
			else
			{
				cout << even2 << " ";
				even2 += 2;
			}
		}
		//因为第二行最大数在(2,n)，所以大的数应放在偶数格中 
		printf("\n");
	}
	return 0;
}
```


---

## 作者：cute_overmind (赞：0)

### 题目大意
给你一个 $2 \times n$ 的一个矩阵，问你从 $(1,1)$ 走到 $(2,n)$ 的代价是写在路径中单元格上的数字的交替和。现问你所有路径最小代价的最大值。

### 题目分析
我们只需要考虑两条路径 $(1,1)$ 到 $(1,n)$ 再到 $(2,n)$ 和 $(1,1)$ 到 $(2,1)$ 再到 $(2,n)$。

不难发现起始点与终点都出现了在两条路径中。

所以我们可以将将起，终点赋两个最大的值。

又因为相邻两数是一奇一偶，所以我们要尽量使第 $1$ 行的奇数位以及第 $2$ 行的偶数位更大。即将 $n+1,n+2 \dots n + n$ 填在目标位置。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n , t;
void solve(){
	cin >> n;
	int a = n * 2 , b = 2;
	for(int i = 1;i <= n;i++){
		if(i % 2) cout << a << " " , a -= 2;
		else cout << b << " " , b += 2;
		cout << '\n';
	}
	a = 1 , b = n + 1;
	for(int i = 1;i <= n;i++){
		if(i % 2) cout << a << " " , a += 2;
		else cout << b << " " , b += 2;
		cout << '\n';
	}
} 
int main(){
	cin >> t;
	while(t--) solve(); 
}
```

---

## 作者：zlqwq (赞：0)

考虑两条极端路径。

第一条是从 $(1,1)$ 走到 $(1,n)$，最后走到 $(2,n)$。

第二条是从 $(1,1)$ 走到 $(2,1)$，最后走到 $(2,n)$。

不拿发现，$(1,1)$ 和 $(2,n)$ 一定会走到，因此我们将最大的数赋值给这两个点。

由于所有相邻的数都是一奇一偶，因此我们设定的一行数组奇偶性要尽量相同。这样结果一定最大。


```cpp
#include<iostream>
#define int long long
#define debug cout << "zlqwq"
#define inf 1e18

using namespace std;
int t;
int n;
signed main() {
	cin >> t;
	while(t--) {
		cin >> n;
		int x = n * 2;
		int y = 2;
		for(int i = 1;i <= n;++i) {
			if(i & 1) {
				cout << x << " ";
				x -= 2;
			}
			else {
				cout << y << " ";
				y += 2;
			}
		}
		cout << '\n';
		int x = 1;
		int y = n + 1;
		for(int i = 1;i <= n;++i) {
			if(i & 1) {
				cout << x << " ";
				x += 2;
			}
			else {
				cout << y << " ";
				y += 2;
			}
		}
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：xixiyan (赞：0)

# CF1816B Grid Reconstruction题解

[题目传送门](https://www.luogu.com.cn/problem/CF1816B)

建议标签：贪心，构造。

## 题意：
给定一个偶数 $n$，让你构造一个 $2\times n$ 的矩阵，使得从 $(1,1)$ 到 $(2,n)$ 的所有路径的交替和的最小值最大。
## 思路：
看了一眼：这不纯贪吗？

既然题目说了交替和是 $\sum\limits_{i = 1}^{k} i = a_i\times(-1)^{i+1}$ 那不就让加的尽可能大，减得尽可能小不就好了。

再联系 $n$ 为偶数，容易想到分为 $1\sim n$ 和 $n+1\sim 2n$ 两组，又起点与终点是每条路径都要经过的，所以必然安排 $2\times n$ 与 $2\times n+1$。

其余的易知第一行的奇数格是加的，偶数格是减的，第二行反之（这个自己枚举几条路径就知道了），所以把加的格放 $n+1\sim 2n$，减的格放 $1\sim n$。

## Code:

关于赋值，这里给出两种方法:

一、朴素的分别判断。

```cpp
int big=n+1;
int small=1;
for(int i=2;i<=n;i++){
	if(i%2==1){
		s[1][i]=big;
		big+=2;
	}
	else {
		s[1][i]=small;
		small+=2;
	}
}
big=n+2;
small=2;
for(int i=1;i<n;i++){
	if(i%2==1){
		s[2][i]=small;
		small+=2;
	}
	else {
		s[2][i]=big;
		big+=2;
	}
}
```



二、通过列来直接判断应该在哪一行：

```
int big=n+1;
int small=1;
for(int i=2;i<n;i++){
    s[(i-1)%2+1][i]=big++;//根据列来判断行
}
for(int i=1;i<=n;i++){
    s[i%2+1][i]=small++;//同理
}
```

注：由于CF评测机炸了，而蒟蒻作者又没有CF账号，所以不敢保证完整代码的正确性，所以只放了部分代码。

---

## 作者：wangzc2012 (赞：0)

# CF1816B Grid Reconstruction
## 思路分析
首先，我们可以证明最后需要考虑的路径仅有两条，分别是从 $(1,1)$ 到 $(1,n)$ 再到 $(2,n)$ 和 从 $(1,1)$ 到 $(2,1)$ 再到 $(2,n)$。  
同时，根据题意，$(1,1)$ 和 $(2,n)$ 都一定会进行加法，所以我们需要把最大的两个数 $2 \times n$ 和 $2 \times n -1$ 放到这两个位置上。  
接着不难想到，要最大化成本最小的路径的成本，就要使第一行奇数位上的数和第二行偶数位上的数尽可能大，其余数字尽可能小。  
所以，我们把 $n+1 \sim 2 \times n$ 这 $n$ 个数填在第一行奇数位和第二行偶数位上；把 $1 \sim n$ 这 $n$ 个数填在其余位置。  
最后，进行模拟并输出即可。
## AC Code
为了代码简便，这里将偶数全部放在第一行，奇数全部放在第二行。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,minx,maxx;
int main(){
    cin>>t;
    while (t--){
        cin>>n;
        maxx=n*2;
        minx=2;
        for (int i=1;i<=n;i++){
            if (i%2==1){  //第一行的奇数位
                cout<<maxx<<' ';
                maxx-=2;
            }
            else{  //第一行的偶数位
                cout<<minx<<' ';
                minx+=2;
            }
        }
        cout<<'\n';  //注意要换行
        maxx=n+1;
        minx=1;
        for (int i=1;i<=n;i++){
            if (i%2==1){  //第二行的奇数位
                cout<<minx<<' ';
                minx+=2;
            }
            else{  //第二行的偶数位
                cout<<maxx<<' ';
                maxx+=2;
            }
        }
        cout<<'\n';  //换行
    }
    return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/CF1816B)

---

# 思路：
要想交错和最大，就要相邻数的差尽可能大，那么我们就在起点填上最大的数 $2 \times n$，因为 $n$ 是偶数，所以终点一定是直接加在费用里的，就填次大的数然后相邻数都是最小的数，既 $1$、$2$，$1$ 的相邻数应该是当前剩下的最大数，既 $2 \times n - 2$，$2 \times n - 3$，以此类推我们可以发现一种可行的构造，即为第一行为 $12,2,10,8,4,6$ 这样的大小交替的偶数，第二行是 $1,9,3,7,5,11$ 这样除了终点以外大小交替的奇数。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int T,n,g[2][100005];            
signed main() { 
	cin>>T;
	while(T--){
        cin>>n;
        g[0][1]=2*n; 
        g[1][n]=2*n-1;
        for(int i=1,p=1,cur=1;i<=n;i++,p^=1,cur++){
            g[p][i]=cur;
        }
        for(int i=2,p=1,cur=n+1;i<n;i++,p^=1,cur++){
            g[p][i]=cur;
        }
        for(int i=1;i<=n;i++){
            cout<<g[0][i]<<" \n"[i==n];
        }
        for(int i=1;i<=n;i++){
            cout<<g[1][i]<<" \n"[i==n];
        }
    }
	return 0;
}
```
完结撒花~

---

## 作者：ny_Dacong (赞：0)

根据题意，我们需要使减去的数尽可能小，加上的数尽可能大。

接下来观察路径易得：单元格 $(1,1)$ 与单元格 $(2,n)$ 必走，且这两个格子都做的是加法。因此，我们需要让单元格 $(1,1)$ 与单元格 $(2,n)$ 尽可能大。

接下来，我们发现最优的两个路径只有 $(1,1) \to (1,n) \to (2,n)$ 与 $(1,1) \to (2,1) \to (2,n)$。

因此，我们只需要模拟这个路径，并在里面按照一小一大的顺序填数即可。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a,b;
int Map[3][100005];
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        memset(Map,0,sizeof(Map));
        a = 0,b = n;
        Map[1][1] = 2*n-1,Map[2][n] = 2*n;
        for(int i = 2; i <= n; i += 2){
			a++;
			Map[1][i] = a;
			a++;
			Map[2][i-1] = a;
		}
		for(int i = 3; i <= n; i += 2){
			b++;
			Map[1][i] = b;
			b++;
			Map[2][i-1] = b;
		}
        for(int i = 1; i <= 2; i++){
            for(int j = 1; j <= n; j++){
                printf("%d ",Map[i][j]);
            }
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：Fubaogege (赞：0)

#### 极简描述
使第 $1$ 行的奇数位和第 $2$ 行的偶数位更大，其他保证尽量小才能保证符合题意。
#### 思路
我们只需要算出第奇数个填进去的和还有第偶数个填进去和算出来，然后将奇数和减去偶数和就行。
#### 代码
```c
for(int i=1;i<=n;i++){
	if(i&1)cout<<n*2-maxa<<" ";
	else{cout<<maxa<<" ";maxa+=2;}
}
```
```c
		for(int i=1;i<=n;i++){
			if(i&1){cout<<aa<<" ";aa++,aa++;}
			else{cout<<bb<<" ";bb++,bb++;}
		}
```

---

## 作者：违规用户名1023708 (赞：0)

### CF1816B题解：

### 分析

这题只要尽量使第 $1$ 行的奇数位以及第 $2$ 行的偶数位更大，剩余的尽量小才能使所有路径最小代价最大。

### 思路

其中，从 $(1,1)$，$(2,n)$ 的代价为经过的所有数字的交错和，也就是所有第奇数个被填进去的数字的和减去所有第偶数个填进去的数字的和。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t, n;
int max1,n1,n2;
main(){
	cin >> t;
	while(t--){
		cin >> n;
		max1 = 1;
		for(int i = 1; i <= n; i++){
			if(i & 1)
			{
				cout << n * 2 - max1 << " ";
			}
			else
			{
				cout << max1 << " ";
				max1 += 2;
			}
		}
		cout<<endl;
		n1 = 2; n2 = n + 2;
		for(int i = 1; i <= n; i++)
		{
			if(i & 1){
				cout << n1 << " ";
				n1 += 2;
			}
			else{
				cout << n2 << " ";
				n2 += 2;
			}
		}
		cout<<endl;
	}
	return 0;
}

---

## 作者：Walrus (赞：0)

## 题意
有一个 $2\times n$ 的方格，$n$ 为偶数，一共有 $2\times n$ 个数字，从 $1\sim 2\times n$，需要将这几个数填入空中，使得从 $(1,1)$ 走到 $(2,n)$ 的所有路径中最小代价的最大值的一种填数方案。

其中，从 $(1,1)$ 走到 $(2,n)$ 的代价为经过的所有数字的**交错和**，也就是**所有第奇数个被填进去的数字的和减去所有第偶数个填进去的数字的和**。

## 分析
不难看出，要想最大化成本最小的路径的成本，就要**贪心**来填空，问题是怎么填呢？分析可以发现，**第一行的奇数位一定是加上的，第一行的偶数位一定是被减去的，第二行的奇数位一定是被减去的，第二行的偶数位一定是加上的**。

首先，第一行为什么这么判断不用过多解释，主要在于第二行的分析，因为当你第一行是加上的时候，此时你下去了第二行，那么此时这个数为第二行的奇数位，按照**交错和**的定义，它应该被减去，所以得出结论。

## 代码实现
贪心策略显而易见，我们尽量要**把第一行的奇数位和第二行的偶数位上的数填得越大越好**，这样才能最大化所有路径的最小代价。所以我们可以把 $1 \sim 2 \times n$ 分成两块来考虑，**把 $1 \sim n$ 填入应该被减去的格子，也就是第一行的偶数位与第二行的奇数位，反之，将 $n + 1 \sim n \times 2$ 填入第一行的奇数位和第二行的偶数位，这样，就符合了“最大化成本最小的路径的成本”的要求了**。

有一个小细节，我们应该将第一行全部构造偶数，第二行全部设为奇数，假设 $n=4$，我们应该将第一行填入 $[8,2,6,4]$，第二行填入 $[1,7,3,5]$。这样才能完全地符合题意（感觉最开始理解错了，换了一种构造）。

## 给出核心代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, t;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cout.tie(nullptr);

	cin >> t;
	for(int _ = 1; _ <= t; _++) {
		cin >> n;
		int firmax = n * 2;//第一行的奇数位：由大到小填入 n+1~2n 中的偶数 
		int firmin = 2;//第一行的偶数位：由小到大填入 2~n 中的偶数 
		int secmax = n * 2 - 1;//第二行的偶数位：由大到小填入 n+1~2n 中的奇数 
		int secmin = 1;//第二行的奇数位：由小到大填入 1~N 中的奇数 
		for(int i = 1; i <= n; i++) {
			if(i & 1)
				cout << firmax << ' ', firmax -= 2;
			else
				cout << firmin << ' ', firmin += 2;
		}
		cout << '\n';
		for(int i = 1; i <= n; i++) {
			if(i & 1)
				cout << secmin << ' ', secmin += 2;
			else
				cout << secmax << ' ', secmax -= 2;
		}
		cout << '\n';
	}
	return 0;
}
```
感谢观看。
### 鸣谢 && 一些题外话
- 感谢[此文章作者](https://blog.csdn.net/ashbringer233/article/details/130246870)帮助作者理解题意（感觉第一次写的代码有点问题）。

- 不确定是否正确的另一种做法：
**将第一行的奇数位和第二行的偶数位尽量填大，反之，题解中有人这么做了，但感觉不能理解**。

---

## 作者：zeekliu (赞：0)

又是构造题。

首先很容易想到，第一个格子（即 $A_{1,1}$）和最后一个格子（即 $A_{2,n}$）一定要放最大的两个数，因为这两个格子无论如何都是加，所以要大。

然后，很容易发现，当下标 $i+j$ 为奇数时，这个格子的是要被减掉的，因此要尽量小。 

然后参考 CF 的这题题解，我们可以这样构造：

如果这个格子在偶数列，则放小数，然后它左下角的格子也放小数（比这个格子小 $1$）；如果这个格子在奇数列，则放大数，然后它左下角的格子也放大数（比这个格子小 $1$）。

这样整体来看和是最小的，可以列几组数据模拟一下，确实可以。

代码：

```cpp
//CF1816B 23.04.14 *1000
#include <bits/stdc++.h>
using namespace std;
int _,n,a[3][100010];

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>_;
    while (_--)
    {
        cin>>n;
        a[1][1]=2*n-1,a[2][n]=2*n;
        for (int i=1;i<=2;i++)
            for (int j=2;j<=n;j++)
            {
                if (j%2==0) a[1][j]=j,a[2][j-1]=j-1;
                else a[1][j]=n+j-1,a[2][j-1]=n+(j-1)-1;
            }
        for (int i=1;i<=2;i++)
        {
            for (int j=1;j<=n;j++) cout<<a[i][j]<<" ";
            cout<<endl;
        }
    }
    exit(0);
}
```

---


# Chilly Willy

## 题目描述

Chilly Willy loves playing with numbers. He only knows prime numbers that are digits yet. These numbers are $ 2 $ , $ 3 $ , $ 5 $ and $ 7 $ . But Willy grew rather bored of such numbers, so he came up with a few games that were connected with them.

Chilly Willy wants to find the minimum number of length $ n $ , such that it is simultaneously divisible by all numbers Willy already knows ( $ 2 $ , $ 3 $ , $ 5 $ and $ 7 $ ). Help him with that.

A number's length is the number of digits in its decimal representation without leading zeros.

## 样例 #1

### 输入

```
1
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
5
```

### 输出

```
10080```

# 题解

## 作者：sanjingshou14 (赞：4)

# 前言
这是一题数学题，通俗地讲就是~~一年级小朋友也会的~~找规律。

个人认为本题应评橙。

# 题目大意
[题目传送门](https://www.luogu.com.cn/problem/CF248B)

输入一个数 $n$，输出最小的能被 $210$ 整除的 $n$ 位数。

# 解法
看到这题的第一眼，我有一种想暴力的冲动，但是数据范围给了我当头一棒。

既然暴力行不通，那肯定有其他的方法。

题目中有整除，一般就会有规律。那就来一个用暴力的程序来找找看。代码和楼上的差不多，就不放了。

经过一段时间的运行程序，我们得到了如下的数据：

| $n$ | 答案 |
| :----------: | :----------: |
| 1 | -1 |
| 2 | -1 |
| 3 | 210 |
| 4 | 1050 |
| 5 | 10080 |
| 6 | 100170 |
| 7 | 1000020 |
| 8 | 10000200 |
| 9 | 100000110 |
| 10 | 1000000050 |
| 11 | 10000000080 |
| 12 | 100000000170 |

可以看出，当 $n$ 等于 $1$ 或 $2$ 时，是无解的，因为除数 $210$ 都有三位了，位数比它低还怎么可能有解。

当 $n$ 等于 $3$ 时，答案就是 $210$。从 $n$ 等于 $4$ 开始，后三位的周期为 $6$，以 {"050","080","170","020","200","110"} 进行循环。

而前半部分，前两位为 $1$ 和 $0$, 后面每循环一次就加一个 $0$。

就这样，我们找到了这个规律。接下来代码就很好写了。

# 代码
按刚才的分析来写就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s[6]={"110","050","080","170","020","200"};
int main(){
	int n;
	cin>>n;
	switch(n){
		case 1:case 2:cout<<-1;break;
		case 3:cout<<210;break;
		default:{
			cout<<1;
			for(int i=1;i<=n-4;i++){
				cout<<0;
			}
			int p=(n-3)%6;
			cout<<s[p];
			break;
		}
	} 
	return 0; 
}
```
注释没什么好写的了，都在前面了。

请勿抄袭，否则棕名！

---

## 作者：alex_liu (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF248B)

我个人认为，这是一道数论题

## 思路：

用 $n$ 位的最小数 (也就是 $10^n$ ) % $210$ ，然后加 $210$  减这个余数

别忘了加特判

## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
  long long ans=1;
  int n;
  cin>>n;
  if(n==1||n==2){//特判
    cout<<"-1"<<'\n';
    return 0;
  }else if(n==3){//特判
    cout<<"210"<<'\n';
    return 0;
  }else{
    while(n--)ans*=10;//先构造最小数
    ans+=(210-(ans%210));//再取模
  }
  cout<<ans;
  return 0;
}
```
可是你会发现：过不了，数据太大

然后试着找规律：

| n的值 |结果  |
| -----------: | -----------: |
| 4 | 1050 |
| 5 | 10080 |
| 6 | &nbsp;100170 |
| 7 | 1000020 |
| 8 | 10000200 |
| 9 | 100000110 |
| 10 | 1000000050 |
| 11 | 10000000080 |

可以发现，从4开始，周期为6，就会陷入一个循环:

"050", "080", "170", "020", "200", "110"

发现规律后再添加1和0就可以了

## AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
int main(){
  cin>>n;
  if(n==1||n==2)//特判 
    cout<<-1<<endl;
  else if(n==3)//特判 
    cout<<210<<endl;
  else{
    t=(n-3)%6;//减去1和后缀占得位置 
    cout<<1;
    for(int i=1;i<=n-4;i++)//根据位数输出0 
      cout<<0;
      if(t==1)cout<<"050";
      else if(t==2)cout<<"080";
      else if(t==3)cout<<"170";
      else if(t==4)cout<<"020";
      else if(t==5)cout<<"200";
      else if(t==0)cout<<"110";//t可能为0，如t=6
  }
  return 0;//完结撒花
}
```

---

## 作者：开始新的记忆 (赞：1)

**题目大意**（手打题意，文科不好）

willy对于数学十分感兴趣，他想知道在n位数中最小且可以被2，3，5，7整除的数，如果可以，请输出这个数，如果不行则输出-1。

**大致思路**

因为要被210整除，不难发现，从n=4开始每六个的后三位会形成一个循环"050", "080", "170", "020", "200", "110"，再依次添加0在首位1和后三位之间即可

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,t=50;

int main()
{	cin>>n;
    if(n==1 || n==2)
        cout<<-1<<endl;
    else if(n==3)
        cout<<210<<endl;
    else
    {
    	cout<<1;
		for(int i=1;i<=n-4;++i)
		{
			cout<<0;
			t=t*10%210;
		}
		printf("%03d\n",t);	
	}
	return 0;
}
```


---

## 作者：WoodReal12 (赞：1)

## 前言
我看楼下的大佬用的都是找规律的方法，那本蒟蒻就在这里提出一种新颖的解法。QAQ

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/CF248B)

给定一个数 $n$，表示 $n$ 位数。你需要在这 $n$ 位数之中找出最小的且能被 $2, 3, 5, 7$ 这四个数整除。

## 思路
可以枚举 $n$ 位数中的所有的数，寻找是 $2, 3, 5, 7$ 的倍数的数。找到了就```return 0```结束程序。如果没找到，到循环完后，再输出```-1```。

## 代码
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int n;
int main(){
    cin>>n;
    long long x;//x表示n位数中最大的数
    int x1=n;
    while(x1>0){
        x1--;
        x*=10,x+=9;
    }
    for(int i=pow(10,n-1);i<=x;i++){
        if(i%210==0){//判断是否是210的倍数（即2,3,5,7的倍数）
            cout<<i<<endl;
            return 0;//要记得结束，不然会输出所有的数
        }
    }
    cout<<-1<<endl;
    return 0;
}
```

---

## 作者：yzm0325 (赞：0)

upd on 2023.8.8: 改了一个笔误。

---

### 题意简述

给定 $n$，求最小能被 $210$ 整除的 $n$ 位数。

### 思路

看完题的第一反应就是暴力，可 $n \leq 10^5$，~~你要是真打暴力评测机会感谢你的~~。高精度明显也不行，不仅炸时间还炸内存。

那么考虑其他方法。因为是数学题，所以考虑打表找规律。通过手动计算或暴力，得到如下的数据：

| $n=$ | $ans=$ |
| :-: | :-: |
| $1$ | $-1$ |
| $2$ | $-1$ |
| $3$ | $210$ |
| $4$ | $1050$ |
| $5$ | $10080$ |
| $6$ | $100170$ |
| $7$ | $1000020$ |
| $8$ | $10000200$ |
| $9$ | $100000110$ |
| $10$ | $1000000050$ |
| $11$ | $10000000080$ |
| $12$ | $100000000170$ |
| $13$ | $1000000000020$ |

可以找到如下规律：

1. $n=1,2$ 时无解。
2. $n=3$ 时 $ans=210$。
3. 对于 $n>3$ 的情况，前 $n-3$ 位由一个 $1$ 和 $n-4$ 个 $0$ 组成，后三位按 $\{050,080,170,020,200,110\}$ 六个一循环。

按照这个规律，代码就很好写了。注意别忘了特判：$n=1,2$，输出 $-1$；$n=3$ 输出 $210$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const string msw[10] = {"110", "050", "080", "170", "020", "200"}; // 因为 n=4 时应该输出 050，而 4%3=1，所以改变一下存储顺序
int n;
int main() {
	cin >> n;
	if(n == 1 || n == 2) cout << -1;
	else if(n == 3) cout << 210; // 特判部分
	else {
	    cout << 1; // 首位的 1
	    for(int i = 1; i <= n - 4; i++) cout << 0; // (n-4) 个 0
	    cout << msw[(n - 3) % 6]; // 末三位
	}
	return 0;  // 完结撒花！！
}
```

---

## 作者：so_find_skind (赞：0)

根据题意所知，所谓的 2，3，5，7 的倍数，实际上就是 210 的倍数。

但是根据 $n$ 的大小也会知道，想要暴力的话。

~~1. 你需要对得起评测机和你的电脑，因为我觉得你要是如此绝情，评测机会炸的。~~

1. 时间复杂度，不必多说。

1. 你要用高精度来存数据，而且我可以保证，如果不返回 TLE 的话，他一定会给你返回 MLE。

所以，一眼找规律。

但是这个规律也不好找，~~毕竟暴力代码一不小心电脑就炸了。~~

根据暴力代码可以得到：

| $n$ | 得到的数 |
| -----------: | -----------: |
| 1 | -1 |
| 2 | -1 |
| 3 | 210 |
| 4 | 1050 |
| 5 | 10080 |
| 6 | 100170 |
| 7 | 1000020 |
| 8 | 10000200 |
| 9 | 100000110 |
| 10 | 1000000050 |


首先可以发现，如果除去后三位，$n$ 从 3 开始，0 的数量将随着 $n$ 变大而变大，即与 $n$ 成正相关关系。

所以可以先写出如下代码：

```
if(n>3)
	cout<<1;
for(int i=1;i<=n-4;i++)
	cout<<0;
```

然后，可以发现，除 $n=1,2,3$ 外，数字后三位从 050 开始，一直到 110，随后下一个数字的后三位又变成了 050。

那么如果你多输出几个数，会发现，实际上后三位就是在以这几个数为循环节循环。

则：

```
string ans[6]={"110","050","080","170","020","200"};
int k=(n-3)%6;
cout<<ans[k];
```

然后把两端代码拼起来，再补一补，AC 代码就完成啦！

---

## 作者：block_in_mc (赞：0)

## 题意简述

求出 $n$ 位数中最小的能同时被 $2,\ 3,\ 5,\ 7$ 整除的数。

## 思路 1

因为 $2\times3\times5\times7=210$，题目就相当于求出 $n$ 位数中最小的能被 $210$ 整除的。

`Python` 自带高精度，虽然 `Python` 最多支持 $4300$ 位数，否则会报错，但是先交上去试试水：

```python
n = int(input())
if n == 1 or n == 2:
    print(-1)
else:
    base = 10**(n-1)
    while True:
        if base % 210 == 0:
            print(base)
            break
        base += 1
```

过了？就这？过的原因除了数据水，还和下面发现的规律有关。

~~人生苦短，我用 `Python`~~

[提交记录](https://www.luogu.com.cn/record/119025489)

## 思路 2

现在来考虑 `C++` 代码。运行上面的 `Python` 代码，我们多试几次找规律：

|$n=$|答案|$n=$|答案|
|:-:|:-:|:-:|:-:|
|$1$|$-1$|$8$|$10000200$|
|$2$|$-1$|$9$|$100000110$|
|$3$|$210$|$10$|$1000000050$|
|$4$|$1050$|$11$|$10000000080$|
|$5$|$10080$|$12$|$100000000170$|
|$6$|$100170$|$13$|$1000000000020$|
|$7$|$1000020$|$14$|$10000000000200$|

从 $n=4$ 开始，观察后 $3$ 位，容易看出这六个数反复出现：$\{050,\ 080,\ 170,\ 020,\ 200,\ 110\}$。

理论上，`Python` 代码最多会枚举 $10^{100000}$ 次（从 $10^{n-1}$ 枚举到 $10^n-1$），由于上面的规律，实际上，`Python` 代码最多会枚举 $200$ 次，因此不会 `TLE`。

进行简单模拟，发现如果 $n\ge4$，那么有 $1$ 个 `1`，$n-4$ 个 `0` 以及根据对 $6$ 取模后的结果推出的后三位。代码如下。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main() {
    scanf("%d", &n);
    if (n <= 2) printf("-1");
    else if (n == 3) printf("210");
    else {
        printf("1");
        for (int i = 1; i <= n-4; i++) printf("0");
        if (n % 6 == 0) printf("170");
        if (n % 6 == 1) printf("020");
        if (n % 6 == 2) printf("200");
        if (n % 6 == 3) printf("110");
        if (n % 6 == 4) printf("050");
        if (n % 6 == 5) printf("080");
    }
    return 0;
}
```

---

## 作者：CodingOIer (赞：0)

## CF248B Chilly Willy

### 解题过程

经过简单思考，这道题肯定是由规律可循，因为 $n \le 10^5$，只有高精度能存下。

下面是暴力程序对 $n$ 为 $1$ 到 $13$ 时的答案进行求解（$11$ 到 $13$ 超出 int 范围了）。

![](https://cdn.luogu.com.cn/upload/image_hosting/p2mvcjew.png)

发现 $n$ 为 $1$ 或 $2$ 时，他们的答案为 $-1$。

接着来分析下面的数据：

- $n = 3$ 时， $210 = 10^{3 - 1} + 110$。
- $n = 4$ 时， $1050 = 10^{4 - 1} + 50$。
- $n = 5$ 时， $10080 = 10^{5 - 1} + 80$。
- $n = 6$ 时， $100170 = 10^{6 - 1} + 170$。
- $n = 7$ 时， $1000020 = 10^{7 - 1} + 20$。
- $n = 8$ 时， $10000200 = 10^{8 - 1} + 200$。
- $n = 9$ 时， $100000110 = 10^{9 - 1} + 110$。
- $n = 10$ 时， $1000000050 = 10^{10 - 1} + 50$。

即 $10^{(n-1)} + x$，那 $x$ 为多少呢？

可以发现，有一个循环节，$n$ 从 $3$ 到 $8$ 分别为：$110,50,80,170,20,200$。

现在就十分简单啦。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int x[15] = {110, 50, 80, 170, 20, 200};
int main()
{
    scanf("%d", &n);
    if (n == 1 || n == 2)
    {
        printf("-1\n");
    }
    else if (n == 3)
    {
        printf("210\n");
        // 3 需要特判，因为 100 + 110 的结果的百位会发生变化
    }
    else
    {
        printf("1");
        for (int i = 1; i <= n - 4; i++)
        {
            printf("0");
        }
        printf("%03d\n", x[(n - 3) % 6]);
        // %03d 表示输出的整数若不满 3 位则补 0
    }
    return 0;
}
```

---

## 作者：bj12z_donglinxi (赞：0)

## [传送门](https://www.luogu.com.cn/problem/CF248B)

## 前言

本蒟蒻看到有一个大佬的题解方法很好，但解释不清楚，因此有了这篇题解。

# 题目大意

给一个数 $n$，表示有几位数，然后输出 $n$ 位数中能被 $2$，$3$，$5$，$7$ 这四个数整除的最小数。

# 思路

首先，我们可以知道这四个数的最小公倍数是 $210$，那么这题就自然地转化为了 $n$ 位数中能被 $210$ 这个数整除的最小数。

剩下的思路就非常简单了，首先当 $n$ 等于各个数时，会得到不同的答案，这里表格就不展示了，其他题解里有。

最终，我们可以得到的规律为：以 {$050$, $080$, $170$, $020$, $200$, $110$} 进行循环。

这就是那个大佬的基本思路。

# 代码

这里是使用那位大佬的思路写出来的（那位大佬解释不清楚，我在注释里会详解）。

## 前置：

```cpp
printf("%0xd");
```


表示输出 $x$ 位，不足的用 $0$ 填充。


```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int n, t = 50;//t是指最后三位，这里设成50是因为当n=4时答案为1050，取后三位

int main() {
	cin >> n;
	if (n == 1 || n == 2) puts("-1");//特判1：当n=1或2时，直接输出-1.因为最低也得是210
	else if (n == 3) puts("210");//特判2：当n=3时，直接输出210
	else {
		cout << 1;//先输出一个1，因为在所有答案中都是以1先开头
		for (int i = 1 ; i <= n - 4 ; i++) {//循环n-4次，去掉第一位和后三位
			cout << 0;//用0填充第一位和后三位之间
			t = t * 10 % 210;//计算后三位
		}
		printf("%03d\n", t); //输出t，如果t是两位数，自动用0填充
	}
	return 0;
}
```

感谢[大佬](https://www.luogu.com.cn/user/132290)

---

## 作者：ask_silently (赞：0)

## 题目简述
求出 $n$ 位数中能被 $2,3,5,7$ 整除的最小整数。

## 思路
- 看到题目先想暴力。暴力很简单，就是把所有的 $n$ 位数遍历一遍，判断能否被 $2,3,5,7$ 的最小公倍数 $210$ 整除。可一看数据范围，暴力必 `T` 加 `M`。

- 开启我们的正解之旅。首先我想到的是看它们的倍数特征， $2,3,5$ 的倍数特征我想到了，结尾是 $0$，各个数位加起来是三的倍数，然后我去网上搜了一下 $7$ 的倍数特征，上面说前面几位减去最后三位是 $7$ 的倍数就是 $7$ 的倍数。我立马想到开头是 $1$，最后两位是 $80$。可是交上去全 `WA`。在此给一个数 $100000080$ 这个数不能被 $7$ 整除。

- 第二步，看一下 $4 \rightarrow n$ 的位数能被 $210$ 整除的数的特征。

|$n=$|答案|$n=$|答案|
|:-:|:-:|:-:|:-:|
|$4$|$1050$|$9$|$100000110$|
|$5$|$10080$|$10$|$1000000050$|
|$6$|$100170$|$11$|$1000000080$|
|$7$|$1000020$|$12$|$100000000170$|
|$8$|$10000200$|$13$|$1000000000020$|

我们发现它们的后三位数都是 $050,080,170,020,200,110$ 所以我们可以让 $n$ 对 $6$ 取模，然后开头输出 $1$，后面输出 $0$ 最后三位输出对应的三位就行了。

## 代码
```cpp
#include <iostream>
using namespace std;
int n;
int main(){
	cin>>n;
	if(n==1||n==2){cout<<-1<<endl;return 0;}     
	if(n==3){cout<<210<<endl;return 0;}    //特判一下，本蒟蒻真的是太弱了 
	cout<<1;    //开头输出1 
	for(int i=1;i<=n-4;i++) cout<<0;    //其余输出0 
	if(n%6==0) cout<<170<<endl;
	else if(n%6==1) cout<<020<<endl;
	else if(n%6==2) cout<<200<<endl;
	else if(n%6==3) cout<<110<<endl;
	else if(n%6==4) cout<<050<<endl;
	else if(n%6==5) cout<<080<<endl;    //对6取模不同的结果输出不一样的三位数 
	return 0;
}

```


---


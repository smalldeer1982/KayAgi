# Little Elephant and Magic Square

## 题目描述

小象非常喜欢幻方。 幻方是一个3×3的表，每个单元格包含一些正整数。此时，表中所有行、列和对角线的整数之和相等。下图显示了幻方，其所有行、列和对角线中的整数之和等于15。 小象想起了一个幻方。他开始在一张纸上写这个正方形，但是当他写的时候，他忘记了幻方主对角线的所有三个元素。幸运的是，小象清楚地记得幻方的所有元素都没有超过10的5次方。 鉴于小象的笔记，帮助小象，恢复原来的幻方。

## 样例 #1

### 输入

```
0 1 1
1 0 1
1 1 0
```

### 输出

```
1 1 1
1 1 1
1 1 1
```

## 样例 #2

### 输入

```
0 3 6
5 0 5
4 7 0
```

### 输出

```
6 3 6
5 5 5
4 7 4
```

# 题解

## 作者：3a51_ (赞：1)

众所周知，对于一个幻方，有每行每列的和均相等。

我们设有这样一个幻方：

$\large a_1\quad a_2\quad a_3$

$\large a_4\quad a_5\quad a_6$

$\large a_7\quad a_8\quad a_9$

因为 $a_3+a_7=a_5\times 2$，所以：

$\quad(a_4+a_5+a_6)+(a_2+a_5+a_8)$

$=(a_4+a_3+a_6)+(a_2+a_7+a_8)$

$=(a_2+a_3+a_4)+(a_6+a_7+a_8)$

又因为幻方每行每列和都相等，所以

$\quad(a_2+a_3+a_4)+(a_6+a_7+a_8)$

$=(a_1+a_2+a_3)+(a_1+a_4+a_7)$

化简得到：

$a_6+a_8=2\times a_1$

于是我们得到一个结论：角上的数字＝对角相邻的两数字和的一半。

其余3个角的证明同理。

那么这下 $2$ 个角上的数字就可以轻松填出，还剩下一个正中间。

其实中间更简单，只需要用 $(a_4+a_6)$ 除以 $2$ 就行。

Code：

```cpp
	int a1,a2,a3,a4,a5,a6,a7,a8,a9;
	cin>>a1>>a2>>a3>>a4>>a5>>a6>>a7>>a8>>a9;
	if(a1==0){
		cout<<(a8+a6)/2<<" "<<a2<<" "<<a3<<endl;
		cout<<a4<<" "<<(a4+a6)/2<<" "<<a6<<endl;
		cout<<a7<<" "<<a8<<" "<<(a2+a4)/2<<endl;
	}else{
		cout<<a1<<" "<<a2<<" "<<(a4+a8)/2<<endl;
		cout<<a4<<" "<<(a4+a6)/2<<" "<<a6<<endl;
		cout<<(a2+a6)/2<<" "<<a8<<" "<<a9<<endl;
	}
```

---

## 作者：loser_seele (赞：1)

题目大意：给定一个缺对角线的幻方，求一种把它填满的可行方案。

注意到矩阵里的元素都不会超过 $ 10^5 $ ，也就是说我们可以每次暴力枚举第一个元素，然后根据第一个元素的值算出其余的元素，最后判断构造出的解是否合法即可。

时间复杂度 $ O (10^5) $ 。

代码：

```cpp
#include <iostream>
using namespace std;
int b[4][4];
int tmp1,tmp2,tmp3;
bool calc(int i)
{
	int sum=b[1][2]+b[1][3]+i;
	tmp1=i;
	tmp2=sum-b[2][1]-b[2][3];
	tmp3=sum-b[3][1]-b[3][2];
	if(tmp2<=0||tmp3<=0)
		return 0;
	if(tmp1+b[2][1]+b[3][1]!=sum)
		return 0;
	if(tmp2+b[1][2]+b[3][2]!=sum)
		return 0;
	if(tmp3+b[1][3]+b[2][3]!=sum)
		return 0;
		if(tmp1+tmp2+tmp3!=sum)
		return 0;
	return 1;
}//判断解是否合法
int main()
{
   for(int i=1;i<=3;i++)
	   for(int j=1;j<=3;j++)
		   cin>>b[i][j];
	for(int i=1;i<=100000;i++)//暴力枚举
		if(calc(i))
		{
			b[1][1]=i;
			b[2][2]=tmp2;
			b[3][3]=tmp3;
			for(int i=1;i<=3;i++)
			{
				for(int j=1;j<=3;j++)
					cout<<b[i][j]<<' ';
				cout<<'\n';
			}
			return 0;
		}				
}
```

---

## 作者：luuia (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/CF259B)
## 前置知识：幻方
### 幻方的定义
$\,\,\,\,\,\,\,\,\,\,$将从一到若干个数的自然数排成纵横各为若干个数的正方形，使在同一行、同一列和同一对角线上的几个数的和都相等，但是这道题对幻
方的要求相对宽泛一点，每个数可以相等，大小也任意。

下面是一些基本的名词：

- $n$ 阶幻方：$n \times n$ 的幻方。

- 幻和：幻方中每一行，每一列，每一条主对角线上几个数的和。

### 幻方的性质

下面便是一个 $3$ 阶幻方：

|$a_1$|$a_2$|$a_3$|
| :- | :- | :- |
|$a_4$|$a_5$|$a_6$|
|$a_7$|$a_8$|$a_9$|

它的性质：

- $a_1 + a_2 + a_3 = a_4 + a_5 + a_6 = a_7 + a_8 + a_9$

- $a_1 + a_2 + a_3 = a_1 + a_4 + a_7 = a_2 + a_5 + a_8 = a_3 + a_6 + a_9$

- $a_1 + a_2 + a_3 = a_1 + a_5 + a_9 = a_3 + a_5 + a_7$

这些性质，其实就是幻方最基本的性质，即：每行，每列，每条主对角线上的和都相等。下面是一些更深层次的性质。

- $a_1+a_2=a_6+a_9=a_5+a_7$

证明：

由基本性质我们得到

$$a_1 + a_2 + a_3  = a_3 + a_6 + a_9 = a_3+a_5+a_7$$

约去 $a_3$，就得到了以上的式子：

$$a_1+a_2=a_6+a_9=a_5+a_7$$

类似的，还有：

- $a_4+a_7=a_2+a_3=a_5+a_9$

- $a_7+a_9 = a_2+a_5$

等等一系列的性质。

接着，有：

- $a_2+a_8=a_1+a_9=a_3+a_7=a_4+a_6=2a_5$。

下面是证明：

$4$ 倍的幻和为 

$(a_1+a_5+a_9)+(a_2+a_5+a_8)+(a_3+a_5+a_7)+(a_4+a_5+a_6)$

即为 $a_1+a_2+a_3+a_4+4a_5+a_6+a_7+a_8+a_9$。

换 $4$ 个幻和相加，得到

$$a_1+a_2+a_3+a_4+4a_5+a_6+a_7+a_8+a_9 = (a_1+a_2+a_3)+(a_4+a_5+a_6)+(a_7+a_8+a_9)+(a_2+a_5+a_8)$$

化简，得到

$$3a_5 = a_2+a_5+a_8$$

即

$$a_2+a_8=2a_5$$

由对称性可证明全式成立，得证。


接着，是这道题要用到的一个重要性质：

- $a_2+a_4=2a_9$

下面是证明：

$$\because a_1+a_2+a_3=a_1+a_4+a_7=a_1+a_5+a_9$$

$$\therefore a_2+a_3=a_4+a_7=a_5+a_9$$

$$\therefore a_2+a_4+a_3+a_7 = 2a_5+2a_9$$

$$\because a_3+a_7=2a_5$$

$$\therefore a_2+a_4=2a_9$$

得证。

同时，这个式子的其它 $3$ 个对称式也成立：

$a_2+a_6=2a_7$，$a_4+a_8=2a_3$，$a_6+a_8=2a_1$。

**下面，我们可以开始分析本题了。**

## 题目讲解

### 题意

给你一个缺掉其中一条对角线的 $3$ 阶幻方，要求补全整个幻方。

### 分析

这下子，就要用到我们之前讲过的公式了。

- #### 如果是 $a_1$，$a_5$，$a_9$ 这条对角线没有给出数据，那么我们求出 $a_1$，$a_5$，$a_9$ 三个数的值就可以。

下面是这个 $3$ 阶幻方：

|$0$|$a_2$|$a_3$|
|:-|:-|:-|
|$a_4$|$0$|$a_6$|
|$a_7$|$a_8$|$0$|
 
首先 $a_5$ 由我们给出的公式 $a_2+a_8=2a_5$ 就可以推出 $a_5$ 的值；

其次 $a_1$ 和 $a_9$ 由我们给出的公式 $a_6+a_8=2a_1$ 和 $a_2+a_4=2a_9$ 就可以推出 $a_1$ 与 $a_9$ 的值。

- #### 如果是 $a_3$，$a_5$，$a_7$ 这条对角线没有给出数据，那么我们求出 $a_3$，$a_5$，$a_7$ 三个数的值就可以。

下面是这个 $3$ 阶幻方：

|$a_1$|$a_2$|$0$|
|:-|:-|:-|
|$a_4$|$0$|$a_6$|
|$0$|$a_8$|$a_9$|

首先 $a_5$ 的值与上面没有区别，还是 ${a_4+a_6} \over 2$；

其次 $a_3$ 和 $a_7$ 由我们给出的公式 $a_4+a_8=2a_3$ 和 $a_2+a_6=2a_7$ 就可以推出 $a_3$ 与 $a_7$ 的值。

那么，我们便求出了每一个数字的值，挨个输出即可。

这样，我们便可以写出本题的 AC 代码。时间复杂度 $O(1)$。

## 代码

下面是 AC 代码：[AC 代码](https://www.luogu.com.cn/paste/xea1en7c)


```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int a[4][4],i,j;//也可以使用一个二维数组来存储
	for(i = 1;i <= 3;i++)
	{
		for(j = 1;j <= 3;j++)
		{
			cin >> a[i][j];
		}
	}
	if(a[1][1] == 0)
	{
		a[1][1] = (a[2][3] + a[3][2]) / 2;
		a[2][2] = (a[2][1] + a[2][3]) / 2;
		a[3][3] = (a[1][2] + a[2][1]) / 2;
	}
	else
	{
		a[1][3] = (a[2][1] + a[3][2]) / 2;
		a[2][2] = (a[2][1] + a[2][3]) / 2;
		a[3][1] = (a[1][2] + a[2][3]) / 2;		
	}
	for(i = 1;i <= 3;i++)
	{
		for(j = 1;j <= 3;j++)
		{
			cout << a[i][j] << " ";
		}
		cout << endl;
	}
	return 0;
}

```

---

## 作者：zhouzhengxi (赞：0)

# CF259B题解
题意：这道题目就是要我们求出三维幻方的一组解。

#### 初状态：
$\begin{pmatrix}0&a_2& a_3\\a_4&0&a_6\\a_7&a_8&0\end{pmatrix}$ 

我们可以设 $a_1 = x$，经过推导我们就可以列出以下两个式子：

$\begin{cases}a_2 + a_3 = a_4 + a_7\\a_7 + a_3 = a_2 - a_6 + 2x\end{cases}$ 

解得$x = \frac{2a_3 + a_6 - a_4}{2}$，由此我们可以推得：

$\begin{cases}a_1 = \frac{2a_3 + a_6 - a_4}{2}\\a_5 = a_1 + a_2 - a_7\\a_9 = a_1 + a_2 - a_6 \end{cases}$

下面给出代码。 
# code
```
#include <bits/stdc++.h>//万能头
using namespace std;
int a[15] = {};
int main()
{
    for (int i = 1; i <= 9; i++) {
        cin >> a[i];
    }
    a[1] = (2 * a[3] + a[6] - a[4]) / 2;
    a[5] = a[1] + a[2] - a[7];
    a[9] = a[1] + a[2] - a[6];
    for (int i = 1; i <= 9; i++) {
        cout << a[i] << " ";
        if (i == 3 || i == 6) {//需要换行
            cout << endl;
        }
    }
    return 0;
}//完美收官
  

---

## 作者：_lzy_ (赞：0)

## 题目大意：
题目给出一个 $3 \times 3$ 的幻方，给你去掉一行一列，二行二列，三行三列的数。要你求出这三个数并输出原本没去掉这三个数时的幻方。
## 解题思路：
```cpp
a  b  c
d  e  f
g  h  i
```
1. 首先我们需要了解幻方的一个性质：幻方的换根 $=$ 幻中心 $\times$ 3 。
2. 如上图，我们通过第一点思路可得： $e = ( d + f ) \div 2$ 。
3. 在第二点中，我们已经求得 $e$ 的值，然后我们变能通过 $e\times3$ 求得幻根，然后用幻根分别减去 $( d + g )$ 和 $( c + f )$ 变能求得 $a$ 与 $i$ 。最后将这三个值保存在数组中输出即可。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4][4];
int main()
{
		ios::sync_with_stdio(false);
		for(int i=1;i<=3;i++)for(int k=1;k<=3;k++)cin>>a[i][k];
		int x,y,z;
		y=(a[1][3]+a[3][1])/2;
		y*=3;//计算幻根。
		x=y-a[2][1]-a[3][1];
		z=y-a[2][3]-a[1][3];//计算其余的数。
		a[1][1]=x,a[2][2]=y/3,a[3][3]=z;//赋值。
		for(int i=1;i<=3;i++){
			for(int k=1;k<=3;k++)cout<<a[i][k]<<" ";
			cout<<endl;
		}
		return 0;
}
```



---

## 作者：yeshubo_qwq (赞：0)

枚举即可。

这题有一个关键：**打印的所有数字必须是正数，并且不超过 $10^5$**。

所以行、列、对角线的和不可能超过 $3 \times 10^5$，可以枚举行、列、对角线的和，然后进行验证。

详细注释见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace QWQ{
	int i,j,a[4][4];
	void Put(){
		a[1][1]=i-a[1][2]-a[1][3];//根据行的和推出空白位置并赋值 
		a[2][2]=i-a[2][1]-a[2][3];
		a[3][3]=i-a[3][1]-a[3][2];
	}
	bool check(){
		return 
		a[1][1] >0 && a[2][2]>0 && a[3][3]>0 && //必须是正数 
		a[1][1]+a[2][1]+a[3][1]==i && //第一列 
		a[1][2]+a[2][2]+a[3][2]==i && //第二列 
		a[1][3]+a[2][3]+a[3][3]==i && //第三列 
		a[1][1]+a[2][2]+a[3][3]==i && //左上至右下对角线 
		a[1][3]+a[2][2]+a[3][1]==i ;  //右上至左下对角线 
	}
	void solve(){
		for (i=1;i<=3;i++)
			for (j=1;j<=3;j++)
				cin>>a[i][j];
		for (i=1,Put(); ;i++,Put())//枚举行、列、对角线的和
			if (check()) break;//有解就退出 
		for (i=1;i<=3;i++)
			for (j=1;j<=3;j++)
				cout<<a[i][j]<<(j==3?'\n':' ');
	}
}
int main(){
	return QWQ::solve(),0;
}
```


---

## 作者：rai1gun (赞：0)

### 1.解法

我们首先构造一个幻方

$$
a \quad b \quad c

\\ d \quad e \quad f

\\ g \quad h \quad i
$$

我们令 $h=f=2,e=x,b=d=y,a=k$，则 $g=c=2+x-k,i=y+k-2$。

我们发现：$d+e+f=2+x+y=2 \times k+x+y-2$，化简得 $k=2$。

所以，$a= \dfrac{h+f}{2}$，所以我们的突破口就在这里。

我们可以通过上面的公式算出角上的任意一个数，然后求出幻和，随后便用已知幻和减去边上的剩下二数即可。

洛谷 RMJ 挂了，这里有 CF AC 记录：[link](https://codeforces.com/problemset/submission/259/159913282)。

### 2.代码

```cpp
#include<bits/stdc++.h>
#define F1(i,a,b,k) for(re int i=a;i<=b;i+=k)
const int N = 5;
int a[N][N];
int main(){
    //.
	F1(i,1,3,1){
		F1(j,1,3,1){
			read(a[i][j]);
		}
	}
	if(a[1][1]==0){
		a[1][1]=(a[3][2]+a[2][3])/2;
		int sum=a[1][1]+a[1][2]+a[1][3];
		std::cout<<a[1][1]<<" "<<a[1][2]<<" "<<a[1][3]<<'\n';
		std::cout<<a[2][1]<<" "<<sum-a[2][1]-a[2][3]<<" "<<a[2][3]<<'\n';
		std::cout<<a[3][1]<<" "<<a[3][2]<<" "<<sum-a[3][1]-a[3][2]<<'\n';
	}else{
		a[1][3]=(a[2][1]+a[3][2])/2;
		int sum=a[1][1]+a[1][2]+a[1][3];
		std::cout<<a[1][1]<<" "<<a[1][2]<<" "<<a[1][3]<<'\n';
		std::cout<<a[2][1]<<" "<<sum-a[2][1]-a[2][3]<<" "<<a[2][3]<<'\n';
		std::cout<<sum-a[3][3]-a[3][2]<<" "<<a[3][2]<<" "<<a[3][3]<<'\n';
	}
	return 0;
}
```

---


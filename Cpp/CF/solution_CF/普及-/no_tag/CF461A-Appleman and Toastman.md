# Appleman and Toastman

## 题目描述

### 问题描述

苹果人和土司人正在玩游戏。一开始苹果人把包含 $n$ 个数的一组数给土司人，然后他们开始进行下面两个步骤：

- 每次土司人得到一组数，他把这些数的和加入到得分中，然后他把这组数交给苹果人。
- 每次苹果人得到只包含一个数的一组数，他会把这组数扔掉；每次苹果人得到包含至少两个数的一组数，他会任意的把它分成两个非空的组，并把这两组数分别交给土司人。

在这两个逗逼完成了所有的任务后他们会查看他们的分数。他们的最多能得多少分呢？

## 样例 #1

### 输入

```
3
3 1 5
```

### 输出

```
26
```

## 样例 #2

### 输入

```
1
10
```

### 输出

```
10
```

# 题解

## 作者：LucasXu80 (赞：2)

本题解是萌新福利，作为一位~~资深~~有半年经验的OIer，我想带着大家找一下规律。同时，我也想为大家解决一下可能遇到的数据类型怎么判断的问题。

## 一、规律的寻找——为什么是这样？

题解区 @lu_run_ting 大佬介绍了我找到的规律，以及这样的原因，但是对于萌新们来说，可能**如何找到这个规律**更为重要，因为在赛场上没有人告诉你规律呀。

看到数据范围$n<=3×10^5$，模拟（DFS）肯定是不可能了。那么我们就要找出得到最高分的方法。怎么找呢？

### 看样例。

样例1 输入 3 3 1 5  输出 26

我们来体会一下下面样例说明。

第一轮，A把所有的数给T，T$+9$分，然后还给A。A拆成$1|3$ $5$两组，分别还给T。对于$3$ $5$那一组，T$+8$分后还给A，A又将$3,5$分别给T，T**共加**$3+5=8$分，分别还给A后被丢掉。对于$1$那一组，给T$+1$分后还给A被丢掉，游戏结束。

这么长，其实就干了三件事儿：

第一件事儿 全部给T。

第二件事儿 全部给T（想一想，是不是这样？）。

第三件事儿 把除最小数外的所有数给T。

那为什么不继续呢？

**因为除最小数外只有两个数了**。这两个数以**分别给T后分别还给A被丢掉**的形式结束，因此游戏结束了。

这个时候，我们考虑每一个数被计算的次数。如果将从小到大的三个数依次设为$a_1,a_2,a_3$，不难发现：

| $i$ | 次数 |
| -----------: | -----------: |
| $1$ | $2$ |
| $2$ | $3$ |
| $3$ | $3$ |

这个规律好像不明显，但是貌似有次数=$i+1$的意思，例外是$i=n$时，次数=$i$。

由于没有更多的样例了，找到这个规律你就可以交一份代码了。当然，你也可以手编一组数据，来验证这个规律是否正确。很幸运，这个规律是正确的。

## 二、数据类型的选择——为什么要开long long?

这是一个很多萌新（包括我）都很头疼的问题。有人可能会问：为什么记录$n$个数的$a$数组是$1<=a_i<=10^6$，离$int$界限还有一段距离。为什么要开long long？题目有锅不成？

非也。在编译器中输入如下程序：

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a=1e9,b=1e9;//1e9=10^9
    cout<<a*b;
    return 0;
}
```
输出是个负数。也就是说，爆了。但是结果应该是$10^{18}$，好像没爆long long啊？

其实你细想就会发现：计算机又不知道你要开long long咯。

为什么呢？

你两个变量都开的是$int$啊。

对此程序进行修改：

```cpp
#include <iostream>
using namespace std;
int main()
{
    long long a=1e9;
    int b=1e9;
    cout<<a*b;
    return 0;
}
```
输出结果是正确的。也就是说，只要参与运算的两个数中有一个是long long，结果就默认long long。

讲到这里，大家应该都明白了吧。所以，如果答案可能会很大，就把long long开了，毕竟这些题大多不卡空间啊。

## 三、AC代码——所以到底怎么写？

最后的最后，上代码咯~

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long n,a[300001];//保险起见我都开了long long
    cin>>n;
    long long ans=0;//答案变量，显然得开long long
    for (int i=1; i<=n; i++) cin>>a[i];//输入a数组
    sort(a+1,a+n+1);//对其进行排序，保证我们刚刚的那个规律成立
    for (i=1; i<=n; i++)
    {
        ans+=a[i]*(i+1);//套规律公式
    }
    cout<<ans-a[n];//输出答案-a[n]也就是最大数，因为在循环中a[n]多算了一次
    return 0;
}
```
好了，本篇题解就到此为止了，如果你认为这篇题解对你有帮助，别忘了点个赞！

---

## 作者：lu_run_ting (赞：2)

题意：

我们可以把吐司人当成一个计数器，每次苹果人把数字给他之后他就会加上，然后还给他。当数字量=1时，会被他扔掉；当数字量>1时，他会分成两组，**分别**给吐司人。

分析：

CF的普及-题目大多数都是贪心题，这道也不例外。我们可以发现当数量为一的时候会被扔掉，所以我们可以用这个条件把最小的去掉，即每次分出最小的数，然后它就被扔掉了。为什么要扔掉最小的？因为他对整个答案的贡献最小。    

但是为什么要单独分出来一个？不是两个呢？因为一个的时候只会同时删掉一个，而如果分出很多个，就会同时被删掉很多个，这样就会导致每次参加加和的数变少，自然答案也就会变小。    

举个例子：如果每次都分一半出来，就相当于$O(logn)$的速度，很快就会用完，而如果每次分一个出来其实就是顺序遍历，是$O(n)$的速度，自然是后者加的数多一点。   

然后我们会发现如果每次拿出来一个最小的，我们就可以排序一下，每个数$i$会用到$i+1$次，比如第一个数会在第一次给吐司人的时候用到一次，在被苹果人拆开之后又被用一次，即两次。然而，最后一个数值会用到$i$次，因为最后两个数会同时被删掉（因为被分成了两个长度为一的嘛）。

易错点：十年OI一场空，不开long long见祖宗~（所有的数都要用啊）

蒟蒻的破烂代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[300005],sum;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		if(i==n) sum+=a[i]*i;
		else sum+=a[i]*(i+1);
	cout<<sum<<endl;
	return 0; 
} 
```



---

## 作者：sysu_yzc (赞：1)

## 思路
根据贪心的策略，每次Appleman应将最小的分为一组，其他的为另一组。

## 代码
```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
ll a[300010];
int main(){
    int n;
    ll ans=0;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n);
    for(int i=0;i<n;i++) ans+=a[i]*(i+2);
    cout<<ans-a[n-1];
    return 0;
}
```

---

## 作者：BeetyX (赞：1)

直接看题：Apple给Toast一组数，Toast把它们加上去，然后还给Apple，如果只有1个数，那就会这数扔掉，否则就会被Apple分为两组，分别还给Toast，问Toast总共加的和最大为多少？

**当数字数量为1，会被Apple扔掉。**

这是一关键句。既然要最后的和最大，那么就要把最小的数扔掉。上贪心策略，把这些数排个序，挑出最小的数，让Apple把他扔掉，然后让Toast把其他的数都加上，不断循环。直到最后两个数，Apple把他分为2组，就全部扔掉了，就不用再加了。

有了这个思路，就可以上代码了。（注意：要开longlong！）

代码如下
------------
```
#include <bits/stdc++.h>
using namespace std;
long long n,a[300005],ans;                //开个longlong
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];  //输入	
	sort(a+1,a+n+1);	          //快速排序，找出最小数
	for(int i=1;i<=n;i++)
        {
		if(i==n)                  //如果是最后一位
                {	
                     ans=ans+a[i]*i;      //直接加上去
                }
		else 
       	        {
                     ans=ans+a[i]*(i+1);  //否则分成两组
                }
        }
	cout<<ans<<endl;                  //最后输出
	return 0; 
} 
```


---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF461A)

这道题很显然是一个贪心的思路，题目整体难度很小，建议降红。

### 分析

题目让我们求最大得分，其实就是让我们把大的数尽量多加几次分，所以我们可以先把这组数进行排序。

我们可以发现每次苹果人把第一个数与其他数分成两组交给土司人时结果满足了所有样例，其实这样做是最优也是最简单的处理办法。

根据这个思路，我发现最小的数只在前两次操作中得分，第二小的数在前三次操作得分，第三小的数在前四次操作得分......

因此我就总结出了规律：第 $x$ 小的数的得分是 $a[x]\times(x+1)$。

不过最大的数多计算了一次 $a[n]$，所以答案要减去 $a[n]$。

**代码：**

```cpp
#include<cstdio>
#include<algorithm>
#define int long long//记得开long long
int n,a[300005];
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
    std::sort(a+1,a+1+n);//排序 
    int sum=0;
    for(int i=1;i<=n;++i)sum+=a[i]*(i+1);//累加每个数的得分 
    printf("%lld",sum-a[n]);//答案减去a[n] 
    return 0;
}
```
Bye！

---

## 作者：abensyl (赞：0)

原题：[CF461A Appleman and Toastman](https://www.luogu.com.cn/problem/CF461A)

## 思路

大前提：所有数都是非负的（也就是说土司人的分是不会倒扣的）。

做法：

1. 首先输入所有数。

2. 排序

- Q：为什么要排序？

>因为苹果人每次都会给土司一些数，而这些数用完后会被扔掉一部分（至少 $1$ 个）。

>我们为了使得分最大，必须让他之扔掉一个，而且要扔掉最小的那个数。

>这样的话，我们可以通过排序来决定扔数的顺序。

3. 计算

- Q：如何计算？

>首先，我们现在明确的是现在手中是一个已经从小到大排好序的数组了。

>于是我们开始扔数，扔数的顺序是，苹果人把整个数列给土司人，土司人加分，然后把数返还给面包人。

>此时，我们面临了一个很难的问题：在数列中选择哪个数扔掉？

>很显然，当然扔掉最小的数是最划算的。

>那么，我们可知最小的数被算了 $2$ 次，第二小的数被计算 $3$ 次，以此类推 $\dots$。

>但是，你错了，最后一个数只能被算 $n$ 次，而不是 $n+1$ 次，因为当你只剩一个数时，你无法分成两组了，所以你只能把那个数扔掉了。

- 于是，我们得到公式

$$ \sum_{i=1}^n a_i(i+1) + a_n\times n $$

4. 输出答案

## 代码：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 5e5 + 3;
int n, sum;
int a[N];

signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; ++i) cin >> a[i]; //输入
  sort(a + 1, a + n + 1); //排序
  for (int i = 1; i < n; ++i) sum += a[i] * (i + 1); //计算
  sum += a[n] * n;
  cout << sum; //输出
  return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/83140562)

写题解不易，过审尤难，求管理员通过，看官们给本蒟蒻点个赞呗！

---

## 作者：tanghg (赞：0)

这道题目看到数据范围就知道不可能去模拟了，所以我们要想一个贪心策略。

我们可以看出来，如果想让的分最高，就需要丢掉最少的值。

所以可以看出来除 $a_n$ 外的答案是把 $a_i\cdot(i+1)$ 即可，然后加上 $a_n\cdot n$。

前提是需要先把数组从大到小排序，然后输出

$$\sum_{i=1}^{n-1}a_i\cdot(i+1)$$

然后加上 $a_n\cdot n$ 即可

```
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll n,a[1000000];
int main() {
    cin>>n;
    for (int i = 1; i <=n ; ++i) {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    ll ans=0;
    for (int i = 1; i <n ; ++i) {
        ans+=a[i]*(i+1);
    }
    ans+=a[n]*n;
    cout<<ans;
    return 0;
}

```

---

## 作者：hyc1026 (赞：0)

本题主要是贪心和找规律。

不难发现，每次让 Appleman 把数列中最小的数单独分开成一组数，其他数成一组数的这种方案能使分数最大化。

举例说明：

| 数列 | 分数 |
| :----------: | :----------: | :----------: |
| $1,2,3,4$ | $10$ |
| $1/2,3,4$ | $10+10$ |
| $2/3,4$ | $20+9$ |
| $3/4$ | $29+7$ |
| $ $ | $36$ |

规律就出来了。数列中第 $i$ 小的数被累加的次数是 $i+1$ 次（$1\le i<n$），最大的数被累加了 $n$ 次。因为最后 Appleman 会把两个数都扔掉。

本题注意要开 long long！

AC Code:

```cpp
#include <bits/stdc++.h>
#define int long long //开long long
using namespace std;

int a[300010];

signed main() //signed和int的效果差不多，不会影响程序
{
    int n;
    cin >> n;
    for(int i=1; i<=n; i++) cin >> a[i];
    sort(a+1,a+n+1);
    int pts = 0;
    for(int i=1; i<=n; i++)
    {
        pts += a[i] * (i+1); //第i小的数累加i+1次
    }
    cout << pts - a[n]; //最大的数多加了1次，减掉
}
```

---

## 作者：Xdl_rp (赞：0)

solution
------------
- 当数字的数量为 $1$ 时，苹果人会将整个数扔掉。

- 利用贪心策略：将 $a$ 数组按从小到大排好序之后，也就是说明苹果人是从小到大去扔掉这些数的，大的数为总和贡献的更多，所以先将小的删去。

- 先扔的肯定加到总和的次数更小，在删去前，$a_i$ 会加到总和 $i + 1$ 次，所以最后的答案都加上 $a_i \times (i + 1)$ 就行了。

- 因为到了最后一个数，苹果人不会再要它了，所以不用加上 $1$，直接改为 $a_n \times n$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//防溢出
int a[300005];//a数组
signed main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];//输入
	sort(a + 1, a + n + 1);//经典STL排序
	int ans = 0;//答案设置为0
	for (int i = 1; i < n; i++) {
		ans += a[i] * i + a[i];
	}//每次都加上（套公式）
	cout << ans + a[n] * n;//最后一个单独处理
	return 0;//好习惯
}
```


---

## 作者：Brian_WBY (赞：0)

题解区全是 `cpp` 的大佬，我来水一篇 `py` 的题解。

这道题是一个贪心题，主要思路就是尽量让较大的值组合，我用样例解释一下。

现在苹果人有了 $3, 1, 5$ 这 $3$ 个数，我们先排序，得到 $1, 3, 5$ 这样的组合，全部给土司人，这时土司人已经有了 $1 + 3 + 5 = 9$ 分。

给到苹果人手里后，苹果人要分组，把最小值 $1$ 单独分出来给土司人，剩下 $3, 5$ 一起给土司人，土司人又得到了 $1 + (3 + 5) = 9$ 分，总共得到 $9 + 9 = 18$ 分。

土司人再把数给苹果人的时候，$1$ 会被直接扔掉，留下 $3$ 和 $5$ ，分别给土司人，土司人得到 $3 + 5 = 8$ 分，总共 $18 + 8 = 26$ 分，再给苹果人的时候，全部扔掉。

我们发现，排序后的每个数 $a_i$ 都会被利用 $i + 1$ 次，但有一个特例：最大数 $a_n$ 会被利用 $n$ 次。

所以代码就非常好写了：

```python
n = int(input())//输入n
a = [0] * (n + 1)//先把list开出来，方便读入
a[1 :] = list(map(int, input().split()))//这样可以让数组下标从1开始
a.sort();//排序，由于a[0] = 0，所以不影响
ans = 0//用于记录答案
for i in range(1, n):
	ans += a[i] * (i + 1)//前n-1个数都被利用了i+1次
ans += a[n] * n//第n个数被利用了n次
print(ans)//输出答案
```


---

## 作者：Mars_Dingdang (赞：0)

### 题目大意
给定一个数组，得分增加所有数字之和，然后将这个数组拆分成任意长度的两组数，再次相加，若有一组数长度等于一则删除。

### 大体思路
根据样例#1，我们可以得到，得分 $S=(3+5+1)+(1)+(3+5)+(3)+(5)=26$。也就是说，为了保证得分最高，每次只删除最小的一个数。所以先将数组排序。
```cpp
	cin>>n;
    for (int i=1;i<=n;i++) 
		cin>>a[i];
    sort(a+1,a+n+1);//系统自带排序
```
接下来，我们分析每个数被加的次数。
| 数字 | 位置 | 次数 |
| :----------: | :----------: | :----------: |
| $3$ | $2$ | $3$ |
| $1$ | $1$ | $2$ |
| $5$ | $3$ | $3$ |
如果这还没有看出规律，那么我们来分析一下：

最小的数 $(1)$，在第一轮被加后被拆分成独立的数组，因此第二次被加后即删去，次数为 $2$。第二小的数在第二轮后被拆分成独立的数组，因此第三次被加后即删去，次数为 $3$。也就是说，**第 $i$ 大的数在第 $i$ 次后被拆分成独立的数组，因此加了 $i+1$ 次。**

那么问题来了：按照这个规律，表格中数字 $5,i$ 应该等于三，次数应该为四。其实，第 $n-1$ 次后仅剩下两个数，这两个数均被拆分成独立的数组，因此第 $n$ 次后均删去。所以，**当 $i=n$ 时，次数为 $i$ 而非 $i+1$。**

```cpp
	for (int i=1;i<=n;i++){
		if(i==n) S+=a[i]*i;//当 i=n 时，次数为 $i$ 而非 $i+1$。
		else S+=a[i]*(i+1);//第 i 大的数加了i+1次。
	}
```
### 数据范围
显然，由于 $1<=n<=3⋅10^5$，因此数组 $a[300005]$ 这是不会超空间的。我们再来看： $a_i<=10^6$，这说明最大数最多加了 $3⋅10^5$ 次，最大值为 $3e11$ 超过了 `int` 的范围，故用 `long long`。

###  完整代码：
 ```cpp
#include<iostream>
#include<algorithm>//排序头文件
using namespace std;
typedef long long ll;//方便
ll a[300005];
int main(){
    ll n,S=0;
    cin>>n;
    for (int i=1;i<=n;i++) 
		cin>>a[i];//输入
    sort(a+1,a+n+1);//排序
    for (int i=1;i<=n;i++){
        if(i==n) S+=a[i]*i;
		else S+=a[i]*(i+1);//相加
    }
    cout<<S;//输出
    return 0;
}
```
看得这么认真，不点个赞再走嘛qaq

---

## 作者：qW__Wp (赞：0)



## 先找规律

可以想到，应让数列中大的数尽量留在后面（多加几次分总是好的）。分割数列时，让最小的数独自一组，剩下的数在另一组，使得代价最小，让后面的大数多轮几次。

这样规律就是：从小到大排序后，对于每个 $a[i]$，加的次数是 $i+1$ 次（$+1$ 的原因是：初始数列会先给到土司人）。

要注意，第 $n$ 个数只要加 $n$ 次（因为在只剩第 $n-1$ 和 第 $n$ 个数时，两个数计算完后都会被抛弃）


**注意要开 ```long long```**

$Code$

```
#include<iostream>
#include<algorithm>
using namespace std;
long long a[1000005];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	long long ans=a[n]*n;//第n个数特殊做 
	for(int i=n-1;i>=1;i--){
		ans+=a[i]*(i+1);
	}
	cout<<ans;
	return 0;
}
```

---


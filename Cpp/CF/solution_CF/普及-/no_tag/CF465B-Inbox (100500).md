# Inbox (100500)

## 题目描述

Over time, Alexey's mail box got littered with too many letters. Some of them are read, while others are unread.

Alexey's mail program can either show a list of all letters or show the content of a single letter. As soon as the program shows the content of an unread letter, it becomes read letter (if the program shows the content of a read letter nothing happens). In one click he can do any of the following operations:

- Move from the list of letters to the content of any single letter.
- Return to the list of letters from single letter viewing mode.
- In single letter viewing mode, move to the next or to the previous letter in the list. You cannot move from the first letter to the previous one or from the last letter to the next one.

The program cannot delete the letters from the list or rearrange them.

Alexey wants to read all the unread letters and go watch football. Now he is viewing the list of all letters and for each letter he can see if it is read or unread. What minimum number of operations does Alexey need to perform to read all unread letters?

## 说明/提示

In the first sample Alexey needs three operations to cope with the task: open the second letter, move to the third one, move to the fourth one.

In the second sample the action plan: open the first letter, move to the second letter, return to the list, open the fifth letter.

In the third sample all letters are already read.

## 样例 #1

### 输入

```
5
0 1 0 1 0
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 1 0 0 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
2
0 0
```

### 输出

```
0
```

# 题解

## 作者：Ggsddu_zzy (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/CF465B)

#### 题目大意

有已读或未读的邮件，可以进行以下操作：

1. 读完邮件后回到邮件列表；
2. 回到列表后选取任意一个未读邮件读；
3. 读完一个邮件之后读这个邮件的下一个或者上一个邮件；

问他最少多少次操作能读完所有邮件。

#### 解题思路

首先可以记录一下有几封邮件未读，因为如果都是已读那么就不用进行任何操作，直接输出 $0$；

如果有未读的邮件，那么操作数就加一；

要再判断一下下一封邮件是否已读，如果是，就要返回列表；

最后要注意，读完最后一封邮件时，是不需要返回列表的，所以操作数要减一。

#### 代码

```cpp
#include <bits/stdc++.h>
#define ri register int
using namespace std;
int a[1001],ans=0,sum=0;
int main() {
	int n;
	cin>>n;
	for(ri i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]) sum++;
	}
	if(!sum) {
		cout<<0<<'\n';
		return 0;
	}
	for(int i=1;i<=n;i++) {
		if(a[i]) {
			ans++;
			if(!a[i+1]) ans++;
		}
	}
	cout<<ans-1<<'\n';
	return 0;
}
```

---

## 作者：Alex_Wei (赞：3)

~~过于显然的贪心（~~

看到题目，我们考虑贪心。

首先肯定是打开最左边的未读信件。从左往右读，如果下一个未读信件与这个未读信件距离为 $1$，那么直接跳到下一个即可；否则先退出来，再打开最左边的未读信件。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],ans;
vector <int> one; 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i])one.push_back(i);//未读的信件全部存到vector里，当然这是因为我喜欢用vector（尽管常数很大）
	}
	for(int i=0;i<one.size();i++){
		ans++;//打开一个未读信件需要一步
		if(i<one.size()-1&&one[i+1]-one[i]>1)ans++;//如果下一个未读信件与它距离大于1，那么退出来还要一步
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Creative_sad_yosgic (赞：0)

## CF465Bの题解
### 题意
给定一个邮件序列，当 $a_i=0$ 时代表第 $i$ 封邮件已读，当 $a_i=1$ 时代表第 $i$ 封邮件未读。

给定三种操作，分别为

1 读完邮件后**回到邮件列表**

2 回到列表后选取**任意一个未读邮件**读

3 读完一个邮件之后**读这个邮件的下一个或者上一个邮件**

求最小的操作次数使序列全部为已读。

显然，我们可以贪心，从左向右读，读到初始的 $0$ 时，可以不用操作，当读到第一个 $1$ 时，如果下一个位置还是 $1$，就只需要进行一次操作三，如果下一个位置是 $0$，就一直遍历找到下一个 $1$，再进行一次操作一回列表并操作二到那个邮件处继续重复上述操作。特别的，如果遍历到 $n$ 都没有未读邮件，直接输出当前操作数并退出即可。  

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[114514];
int flag,flag2;
int ans;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);//优化
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		if(a[i]==0&&!flag) continue;//初始的 0
		else if(a[i]==0){//已经发现 1 后的 0
			int u=i;//从当前位置开始遍历
			while(a[u]==0){//直到遍历到 1 为止
				u++;
				if(u>n) cout<<ans<<'\n',exit(0);//如果之后全是已读就输出并退出
			}
			ans++;//进行操作一 操作二会是下一次的操作三
			i=u-1;//注意i会++ 要u-1
		}
		else if(a[i]==1) ans++,flag=1;//遇到未读就操作三
	}
	cout<<ans<<'\n';
	return 0;
}
```


---

## 作者：tbdsh (赞：0)

# 题意
[题目传送门](https://www.luogu.com.cn/problem/CF465B)

Alexey 有 $n$ 个邮件，其中已读邮件为 $0$，未读邮件为 $1$。现在，他可以：

1.如果当前邮件本来就读过了，就从列表中随便选一个邮件读；

2.一个未读的邮件读完了可以选择上一个或下一个邮件进行读取。

那么请问：他最少多少次能读完所有邮件？
# 分析
由于要保证次数最小，所以从前往后开始查看。

先从前往后找到第一个没有看的，打开看。然后之后的每次都进行如下操作：

1.如果看过了，也要打开看（因为只能选择下一个或上一个邮件进行查看，而前面的都看过了），然后往后找没看过的，重复操作。

2.如果没看过，则打开看。然后查看下一个。

最后输出查看过的次数既可。

**注意**，如果没有邮件没看过，则不进行任何操作。即上述操作是在仍有邮件没看时进行。

时间复杂度：$O(n)$。
# Code
```cpp
#include<bits/stdc++.h>

using namespace std;
int n, a[1005], cnt, ans;
int main(){
  cin >> n;
  for (int i = 1; i <= n; i++){
    cin >> a[i];
    cnt += a[i];
  }
  int i = 1;
  while(!a[i]){
    i++;
  }
  while(cnt){
    if (!a[i]){
      ans++;
      while(!a[i] && i <= n){
        i++;
      }
    }else {
      ans++;
      i++;
      cnt--;
    }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：xiezihanAKIOI (赞：0)

题意：

给你 $n$ 个数，每个数有读过和没读过两种状态，你可以选择花费 1 体力拿下一本书，或者花 2 体力随意挑选一本书。问最少几步能读完全部的书。

很明显的贪心题，加入几本书是连着的，就可以少花一份体力。否则就花费 2 体力。我们可以先假设每个数都要花费 2 体力，最后统计连续的书本数量，然后相减即可。

两个要点:

一、未读的书本的数量减去相连的书本数量时要减一，应为读完最后一本书的时候不用再花费体力了。所以要多减一。

二、减的时候如果全为 0 的话多减一的值是 -1 自处要特判一下。

代码如下：

```
#include <bits/stdc++.h>
#define int long long

using namespace std;

int cnt1, cnt2, n, a[1005];

signed main() {
	ios::sync_with_stdio (false), cin.tie (0), cout.tie (0);
	cin >> n;
	for (int i = 1 ; i <= n ; i++) {
		cin >> a[i];
		if (a[i] == 1) {
			cnt1++;
			if (a[i] == a[i - 1]) cnt2++;
		}
	}
	cout << (cnt1 * 2 - cnt2 - 1 >= 0 ? cnt1 * 2 - cnt2 - 1 : 0);
	return 0;
}
```

---

## 作者：nbtngnllmd (赞：0)

## 题意：

已知把未读信件标为 $1$，已读信件标为 $0$。

可以有三种操作：

$1$：返回信件列表。

$2$：回到列表后读取任意未读信件。

$3$：读完一封邮件后读取上一篇或下一篇信件。

求出读完所有未读信件所需要的最小操作次数。


------------

## 思路：

首先第一次读未读信件的次数肯定为 $1$，主要考虑后面读取方式。已知按照先后顺序读取，如果读完一封信件后，它的下一篇信件如果是已读的，则需要返回列表，再次选择未读邮件，操作次数 $+2$。反之，操作次数 $+1$。没有必要考虑前一封信件，循环是从前往后遍历，未读信件不会遗漏。

但需要注意的是在读完最后一封信件后，是不需要再次返回列表，则如果操作次数不为 $0$ 时，操作次数需要 $-1$。

其余的具体实现看代码。


## 代码：

------------
```cpp
#include<bits/stdc++.h>

using namespace std;
int a[100010],ans,sum;
int main(){
    int n;cin>>n;
    for(int i = 1 ; i <= n ; i++ ) cin>>a[i];
    for(int i = 1 ; i <= n ; i++ ) if(a[i]) sum++;//sum代指有多少未读信件
    if(sum == 0) {cout<<0<<endl;return 0;}//判断有无未读信件
    for(int i = 1 ; i <= n ; i++ ) {
        if(a[i] == 1 ){
            if(sum == 0) break;//未读信件个数如果为0,跳出循环
            sum--;
            ans++;
            if(a[i+1] != 1 ) ans++;//下一封不是未读信件，需要返回列表
        }
    }
    cout<<ans-1<<endl;//一定要减1
    return 0;
}
```



---

## 作者：abensyl (赞：0)

原题：[CF465B Inbox (100500)](https://www.luogu.com.cn/problem/CF465B)

## 思路

此题 ~~过水~~

- 当上一封邮件为未读，这一封也为未读时，我们可以直接从上一个翻页到这一个，操作次数为 $1$。

- 其他情况下，可以返回列表并跳到下一封未读邮件，操作次数为 $2$。 

> 但是，这还没完！

> 当 Alexey 看完了最后一封邮件后，他并不需要关闭，所以要减去一次。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e3+3;
bool a[N];
int main() {
  int n;
  int cnt=0;
  cin>>n;
  for(int i=1;i<=n;++i) {
    cin>>a[i];
    if(a[i]&&a[i-1]) cnt++;
    else if(a[i]) cnt+=2;
  }
  if(cnt) cnt--;
  cout<<cnt;
  return 0;
}
```


[AC记录](https://www.luogu.com.cn/record/84984448)

---

## 作者：DiDi123 (赞：0)

# 一、题意

Alexey 有 $n$ 个电子邮件，电子邮件分为已读和未读，已读的电子邮件标为 $0$，未读的标为 $1$。现在他有以下三种操作：

1. 读完邮件后回到邮件列表
2. 回到列表后选取任意一个未读邮件读
3. 读完一个邮件之后读这个邮件的下一个或者上一个邮件

问他最少多少次操作能读完所有邮件

# 二、分析

我们看一下题意就可以知道其实看邮件不是操作，转换邮件才是操作。操作1和2可以从一个邮件跳到任何一个邮件，但是需要两次操作。操作3可以观看下一个或者上一个操作，显然这个操作在未读邮件连续的时候才好用（如果两个未读邮件中隔着 $x$ 个已读邮件，那么需要 $p=x+1$ 次操作才能看到下一个未读邮件，由于 $p\geq2$，这样情况下用操作1和2会更划算一些）。

在操作3中，显然从左边右边观看邮件是一样的，只要保证不折回来再看就行了。

所以我们就从左到右扫一遍，找出所有 $1$ 的连通块（所有未读邮件连在一起的地方）。$x$ 个连通块之间转换需要 $2(x-1)$ 次操作；长度为 $len$ 的连通块内部需要 $len-1$ 次操作转换。

# 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, rep, group, ans; //group代表连通块个数，rep代表一个连通块长度
inline int read() { //快读
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}
int main() {
	n = read();
	int x;
	for (int i = 1; i <= n; ++i) {
		x = read();
		if (x) rep++; //连通块长度+1
		else { //如果遇到0，说明连通块已经到头了
			if (rep) { 
				group++;
				ans += rep - 1;
			}
			rep = 0;
		}
	}
	if (rep) { //别忘了连通块有可能在最后
		group++;
		ans += rep - 1;
	}
	if (!group) putchar('0'); //没有连通块
	else printf("%d", ans + ((group - 1) << 1) + 1) ;
}
```


---


# Diplomas and Certificates

## 题目描述

有n名学生参加了比赛，现在奖项已经公布了下来。   
n名学生中，中有人获得了文凭，也有人获得了证书，但还有人什么都没有。  

其中官方颁奖还有个规则：    
1.证书的数量必须恰好是文凭数量的k倍。   
2.获奖者人数不得超过所有学生人数的一半(即不超过n的一半)。

当然也可能没有赢家。

而题目让你求出最大的赢家数量，以及这种情况下，有文凭的学生人数，有证书的学生人数和没有获奖的学生人数。

## 样例 #1

### 输入

```
18 2
```

### 输出

```
3 6 9
```

## 样例 #2

### 输入

```
9 10
```

### 输出

```
0 0 9
```

## 样例 #3

### 输入

```
1000000000000 5
```

### 输出

```
83333333333 416666666665 500000000002
```

## 样例 #4

### 输入

```
1000000000000 499999999999
```

### 输出

```
1 499999999999 500000000000
```

# 题解

## 作者：清小秋ovo (赞：9)

# CF818A 题解

写完这题发现跟题解中各位大佬的做法不谋而合了。

~~（好像也就只有这一种做法了）~~

这里只是把公式的推导更加详细的列出来，方便理解和观看。

## 题目分析

给定有 $n$ 名学生，其中我们可以把这些学生一共分为三类：

第一类：获得证书的学生。

第二类：获得文凭的学生。

第三类：啥也莫得的学生。

其中评奖的规则是： 获得证书的学生必须是获得文凭学生的 $k$ 倍。

与此同时，我们将第一类和第二类学生定义为“成功人士”，所有“成功人士”的人数不能超过总人数的一半。

题目最后询问我们：在使“成功人士”**尽可能多**的情况下，分别输出这三类学生的数量。

## 方程推导过程

我们设获得文凭数量的学生为 $x$。

则，获得证书的学生数量应为：

$$x\times k$$

而剩余的无证书，无文凭学生应为:

(总人数减去一类和二类学生)

$$n-(x)-(x\times k)$$

接下来我们发现好像没法继续解下去了...

但是我们忘记了一个很重要的条件，那就是一类学生和二类学生应该不超过总人数的一半。

所以为了最大化得奖人数，我们这里**就直接将一类和二类学生的人数设为总人数的一半。**

$$x+x\times k = {n\over2}$$

我们继续简化式子：

$$x\times(1+k)={n\over2}$$

$$x = {n\over 2 \times (1+k)}$$

所以这就是获得文凭学生的数量啦！

那么根据这个式子就可以推出证书学生的数量：

$${n\times k}\over 2 \times (1+k)$$

最后，用总人数减去这两类学生的值，便是最后一类学生的数量：

$$n-{n\over 2 \times (1+k)} - {n\times k\over 2 \times (1+k)}$$

## 代码实现

既然公式都已经推到出来了，那么直接对着公式敲一遍输出就好了。

（一个超级简短的代码）

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long n, k;
    cin >> n >> k;
    cout << n/2/(k+1)<<" "<<n/2/(k+1)*k<<" "<<n-(n/2/(k+1))-(n/2/(k+1)*k)<< endl;
}
```

完美结束！



---

## 作者：huwanpeng (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/CF818A)

[博客食用效果更佳](https://www.luogu.com.cn/blog/HWP/solution-cf818a)

首先确定以下，$n$ 和 $k$，要开 long long，这是肯定的。

然后我们分析一下题目，题目里一共有三种学生：

1. 有证书。

1. 有文凭。

1. 有个寂寞（就是啥都没有的意思了）。

赢奖也有规则：

1. 证书的数量必须恰好是文凭数量的 $k$ 倍。

1. 获奖者人数不得超过所有学生人数的一半(即不超过 $n$ 的一半)。

结合规则，我们可以得出以下的结论：在 $n÷2$ 的学生人数里，证书数量 $k$ 份，文凭数量一份，一共就是 $k+1$ 份，只要用 $n÷2÷(k+1)$ 就行了。

完整通过代码：

```cpp
#include<iostream>
using namespace std;
long long n,k,ans;
int main()
{
	cin>>n>>k;
	ans=n/2/(k+1);
	cout<<ans<<" "<<ans*k<<" "<<n-ans-ans*k;
	return 0;
}
```
大家要自己写，不要抄题解哈。

---

## 作者：信息向阳花木 (赞：3)

写一篇连 xxs 都能看懂的题解。我会尽量写得细一些。

[题目传送门](https://www.luogu.com.cn/problem/CF818A)

[博客传送门](https://www.luogu.com.cn/blog/hellafxybk/solution-cf818a)

### 一. 阅读理解
其实题目很好理解，但对于我这个蒟蒻来说，一开始竟然没有读懂“赢家”是什么意思？这里解释一下，所谓“赢家”就是指得了奖的人。


------------


### 二. 解题思路
怎么感觉这道题是一道数学题，还要用方程？！

我们设获得文凭的人数为 $x$ 人，那么根据：“证书的数量必须恰好是文凭数量的 $k$ 倍。”可以得出：获得证书的人数为 $(k \times x)$ 人，最后没有获奖的人数就是总人数减去得奖人数：$(n - x - k \times x)$ 人。那么接下来我们要最大化得奖人数，也就是最大化 $x + k \times x$。

我们恨不得所有人都得奖，但是题目中要求“获奖者人数不得超过所有学生人数的一半(即不超过 $n$ 的一半)。”即 $(x + k \times x) \leq \frac{n}{2}$，那么 $x + k \times x$ 最大就是 $\frac{n}{2}$ 啦。

所以知道了 $x + k \times x$，现在再求 $x$ 是不是就很简单了呢？~~（本来题目就很简单）~~

$x + k \times x = (k + 1) \times x = \frac{n}{2}$，$x = \frac{n}{2} \div (k + 1) = \frac{n}{2 \times (k + 1)}$；

求出了 $x$，那后面的就根据 $x$ 直接算就行啦！

**最后友情提示本题一个坑点：** $1 \leq n,k \leq10^{12}$，所以要用 `long long`。

------------


### 三.代码展示
```cpp
#include <iostream>
using namespace std;
long long n,k;
int main(){
	cin>>n>>k;
	long long x=n/(2*(k+1)),kx=k*x; //注意这里也要用 long long。
	cout<<x<<" "<<kx<<" "<<n-x-kx;
	return 0;
}
```


---

## 作者：Luo_gu_ykc (赞：1)

## 题目大意
有 $n$ 个学生参加比赛， 比赛的奖项有两种， 一种是文凭， 一种是证书，
再告诉你一个整数 $k$ , 要求获得证书奖项的人要是文凭获奖人数的 $k$ 倍，
并要求证书与文凭的获奖人数的总数不大于 $\frac{n}{2}$ , 求最大获奖人数 。
## 思路
那么最优解肯定是证书与文凭的获奖人数的总数越接近 $\frac{n}{2}$ 越好 ，
那么我先假设总获奖人数为 $\frac{n}{2}$ , 那么文凭获奖人数就为 $\frac{\frac{n}{2}}{k + 1}$ , 证书奖项就为 $\frac{\frac{n}{2}}{k + 1} \cdot k$ ， 未获奖人数就为 $n - \frac{\frac{n}{2}}{k + 1} \cdot (k + 1)$ 。

话不多说， 上代码！！！

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long // 不开 long long 见祖宗
int n, k; 
signed main(){ // signed 有符号类型， 具体用法请自行搜索
	cin >> n >> k;
	int nn = n / 2; // 不能超过 n 的一半
	nn = nn / (k + 1);
	cout << nn << " " << nn * k << " " << n - nn * (k + 1); 
	return 0;
}
```

---

## 作者：20100202w (赞：0)

这道题首先要把学生分为三类：

1. 获得证书的学生

1. 获得文凭的学生

1. 啥也没得的学生

![](https://cdn.luogu.com.cn/upload/image_hosting/euvwfye8.png)

题目明确规定了不同学生类型的数量关系，这样，这题就很容易过了

下面附上代码：

```cpp
#include<cstdio>//头文件
long long n,a,k; 
int main()
{
	scanf("%lld%lld",&n,&k);//long long 类型是%lld
	a=n/2;//获得证书和文凭人数不能超过总数的一半
	a/=(k+1);//具体分出获得文凭的人数
	printf("%lld %lld %lld",a,a*k,n-a-a*k);//输出
	return 0;//结束
}

```




---

## 作者：thomas_zjl (赞：0)

一道基础数论题，接下来推推式子吧。

我们设证书的学生为$x$。

> 证书的数量必须恰好是文凭数量的k倍。

我们可以看出文凭数量为$x*k$。

那么没有获奖的同学就是$n-x-x*k$。

而$x=n/2/(k+1)$。

接下来就是代码了。

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,k;//别忘了long long。
	cin>>n>>k;
	long long x=n/2/(k+1); //x=n/2/(k+1)。
	cout<<x<<" "<<x*k<<" "<<n-x-x*k<<endl;//输出。
   return 0;
}
```


---

## 作者：流绪 (赞：0)

因为证书学生是文凭学生的 k 倍,那么比率 k 就可以理解为：证书学生：文凭学生 = k ：1，那么我们把总的学生分成 k+1 份，证书学生占 k 份，文凭学生占一份就好啦。注意获奖学生最多只有总人数的二分之一，所以我们要先把总人数除以 2再算其他的。

文凭学生：每份人数 * 1。

证书学生：每份人数 * k。

三无学生：总人数 - 获奖学生数。

下面是 AC 代码。
```cpp
#include<bits/stdc++.h>
#include<cstring>
#define ll long long
#define ld long double
#define inf 0x7f7f7f7f
#define maxn 1000010
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	ll n,k;
	cin >> n >> k;
	ll p = n/2/(k+1);//每份的人数
	cout << p << " " << p*k << " " << n-p-p*k;
	return 0; 
}  
```


---


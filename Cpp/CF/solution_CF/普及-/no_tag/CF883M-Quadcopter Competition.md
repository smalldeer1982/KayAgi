# Quadcopter Competition

## 题目描述

你参加了一个飞行器比赛，并知道你的飞行器起点在$(x_1,y_1)$ ，有一面旗子在$(x_2,y_2)$ 。

每次你的飞行器能够沿平行于坐标轴方向移动$1$ 单位长度，即假如你在$(x,y)$ ，你的飞行器可以前往$(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 四者中的一个。

现在你需要规划一个路线，这个路线从起点出发并回到起点，并构成一个封闭环。同时这个封闭环必须**严格包含**旗子所在的格点。（具体看下面的图片）

求飞行器最短飞行距离为多少。

## 说明/提示

$-100\le x_1,x_2,y_1,y_2\le 100$ 。

感谢@U50882 OwenOwl 提供的翻译

## 样例 #1

### 输入

```
1 5
5 2
```

### 输出

```
18
```

## 样例 #2

### 输入

```
0 1
0 0
```

### 输出

```
8
```

# 题解

## 作者：Jr_Zlw (赞：3)

$$\Large\text{一道非常水的橙题}$$

## 1.如何求最短路径

显而易见，最短路线就是使起点与旗子在一个矩形的对角线上：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF883M/386c66ca9620cccfa6fb068c3cb9fb65984ca527.png)

譬如题目中的这个图，我们可以知道想要走最短路必须在到达旗子之前始终朝向旗子，而绕完旗子之后始终朝向起点。那么学过小学数学的同学肯定都知道这些线段都是可以平移的。将图中弯弯曲曲的飞行路线平移成为一个矩形以后，我们很容易发现这个矩形就是```以```起点$(1,5)$```和```旗子的左下角$(6,1)$```为对角线```的矩形，飞行路线的长度就是这个矩形的周长。

## 2.如何确定矩形长和宽

矩形的其中一个顶点很好求，就是起点的坐标$(x_1,y_1)$

对于另外一个顶点我们可以分类讨论，按照旗子与起点的位置关系来分$4$种情况来分别算出另一个顶点从而算出长和宽。

不过，这里给出一个更好的算法：

因为我们需要绕旗子一圈，所以如果我们以旗子坐标$(x_2,y_2)$为矩形的另一个顶点的话，那么我们要的答案实质上就是使这个矩形的长宽各$+1$而算出的那一个矩形的周长，因此我们就得出了公式：

$$ans=(|x1-x2|+1+|y1-y2|+1)\times 2$$

## 3.坑点

事实上，如果只是将上面的公式代进去，是得不出正确答案的，甚至连样例都过不了。

因为我们还需要讨论几种情况：

1. 顶点与旗子的连线与坐标轴平行（即 $x_1=x_2$ 或 $y_1=y_2$ ）:

这种情况下我们可以理解为：必须要让飞行路线宽一点才能把旗子包括进去。

那么因为矩形的宽度至少也是$2$，宽度只有$1$，那么很明显我们要向两边飞一点才能把旗子包括进去。而这个多飞的宽度明显是$1$。

那么也就是说如果发生了这种情况，我们只需要将原先求得的答案$+2$即可！

2. 顶点与旗子重：

虽然我不知道数据中有没有这种情况，但还是要预防万一:

这种情况无论怎么说都能很容易看出需要的步数是$10$（离开起点绕旗子一圈再回到起点，共需要$10$步）

那么我们特判输出$10$即可。

## 代码

双手奉上$AC$代码：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int main()
{
	int x1,y1,x2,y2,ans;
	cin>>x1>>y1>>x2>>y2;
	if(x1==x2&&y1==y2)
	{
		cout<<10;
		return 0;
	}
	ans=((abs(x1-x2)+abs(y1-y2)+2)*2);
	if(x1==x2||y1==y2)ans+=2;
	cout<<ans;
	return 0;
}
```

$$\Large\text{祝您好运！}$$

---

## 作者：LucasXu80 (赞：2)

学校里正在讲平面直角坐标系，正好看到了这题，就来发一篇题解。

本题解提供图解以及Python代码。

首先我们来看思路。根据题面中的图片，我们知道“严格包含”指的是不在边界上而在内部。（相当于在第一象限的点一定不在坐标轴上）

那么我们很容易就想到这个情形：

![1](https://cdn.luogu.com.cn/upload/image_hosting/tldy2f0b.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

对，它是一个长方形，路线一定是$AC->CD->DE->EA$。

这个路线的长度是多少呢？很简单，利用长方形周长公式$C=2(a+b)$，其中$a$表示长、$b$表示宽，我们易得：

$C=2×[(5-2+1)+(4-2+1)]=14$。

接下来我们把这个结论推广到在平面直角坐标系上的所有点：

![2](https://cdn.luogu.com.cn/upload/image_hosting/7xqugl1u.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

不难看出：

$a=|x1-x2|+1$，

$b=|y1-y2|+1$。

其中$+1$是为了将棋子包围进去而不是在边上。

为什么要绝对值？因为并没有给定$x1,x2;y1,y2$的大小关系。

记得我们老师说过这样一句话：“从坐标到距离一定要注意绝对值”。这句话希望对大家都有好处。

好了，言归正传。难道就这样结束了？并不是。

我们来看下面一种情形：

![3](https://cdn.luogu.com.cn/upload/image_hosting/en7i8gal.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

没错，当$A,B$两点所在直线平行于坐标轴（两点共线的说法并不对，因为两点确定一条直线，任意两个不重合的点都在一条直线上），都不会产生一个封闭图形，更不用说讲棋子包围进去了。

那我们就要看一种新的方法了，只适用于这种情形。先看一个特例：

![4](https://cdn.luogu.com.cn/upload/image_hosting/el8u4usc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

很显然，这已经是最短的一种走法了。并且无论如何都有$b=2$。所以关键就是求$a$。

其实也很好求：$a=5-2+1=4$。

那么这个长方形的周长就是：

$C=2×(4+2)=12$。

推广到所有点：

![5](https://cdn.luogu.com.cn/upload/image_hosting/pa67jhlo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$a=|x1-x2|+1$，

$b=2$。

注意，这里只是两点纵坐标相等的情况。如果两点横坐标相等，那么将$a$中的$|x1-x2|$变成$|y1-y2|$即可。

这样我们就理清了思路。上代码！

```python
x1,y1=map(int,input().split())#第一行输入x1,y1
x2,y2=map(int,input().split())#第二行输入x2,y2
if x1==x2: #横坐标相等，与y轴平行
    print(2*(1+abs(y1-y2)+2))
elif y1==y2: #纵坐标相等，与x轴平行
    print(2*(1+abs(x1-x2)+2))
else: #所在直线不与x、y轴平行
    print(2*(abs(x1-x2)+1+abs(y1-y2)+1))
    #输出中直接套公式
```

最后，看我做了那么久的图，给个赞呗！

---

## 作者：array2022 (赞：1)

# 题解 002 题目 [CF883M](https://www.luogu.com.cn/problem/CF883M)

### 题目分析

* 本题本质上是计算长方形的周长，千万别被这张图片骗了！不过还是需要分类讨论。我把这道题分成三个方面讨论。
* 飞行器与旗子在同一行且在同一列：画图可知，答案为 $10$。
* 飞行器与旗子在同一行或在同一列：还是画图，可以发现同行和同列其实是等价的，因此不用继续分类。答案为 $ 2\left(|y_{1}-y_{2}|+|x_{1}-x_{2}|+3\right)$。
* 飞行器与旗子既不在同一行也不在同一列：还是画图，答案为 $ 2\left(|y_{1}-y_{2}|+|x_{1}-x_{2}|+2\right) $。

------------
### 通过代码
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int xa,ya,xb,yb;
int main(){
	cin>>xa>>ya>>xb>>yb;
	if (xa==xb&&ya==yb){//第一种情况：同行且同列。
		cout<<10;
	}
	else if (xa!=xb&&ya!=yb){//第二种情况：既不同行也不同列。
		cout<<2*(abs(xa-xb)+abs(ya-yb)+2);
	}
	else if (ya==yb||xa==xb){//第三种情况：同行或同列。
		cout<<2*(abs(xa-xb)+abs(ya-yb)+3);
	}
	return 0;
}
```

------------
End.

---

## 作者：Annihilation_y (赞：1)

## 思路
分三种情况考虑：

- 飞行器所在的点与旗所在的点完全重合。此时，需要围绕旗绕一圈，最少需要十次。

- 飞行器所在的点与旗所在的点有行或列重合。此时，需要正常情况的基础上，增加向上的两次。

- 正常情况。可以看作一个长方形，求长方形的周长。

## 坑点
- 需要考虑两种特殊情况。

- 求长方形周长时，一定要计算旗所在的点的右下角，才能完全包围。

- 一定要求绝对值。

## code
```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int x1,x2,y1,y2;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	if(x1==x2&&y1==y2)//飞行器所在的点与旗所在的点完全重合 
	{
		printf("10");
		return 0;
	}
	if(x1==x2||y1==y2)//飞行器所在的点与旗所在的点有行或列重合
	{
		printf("%d",(abs(x1-x2)+abs(y1-y2)+2)*2+2);
		return 0;
	} 
	else//普通情况
		printf("%d",(abs(x1-x2)+abs(y1-y2)+2)*2);
	return 0;
}
```

### the end

---

## 作者：Luo_gu_ykc (赞：1)

~~一道水题竟写了 $n$ 天~~
## 题目大意

给你两个点的坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，从其中的一个点出发，再回到这个点，问你严格包含另一点至少需要走多少距离。

## 思路

先求出两个点的坐标的 $x$ 和 $y$ 的绝对差，因为是严格包含，所以答案都应该加一，并且是个闭环，还要算另一端的长度。

- ### 大坑点

如果两个点的 $x$ 或 $y$ 相等，差值为一，少算了一边，所以要拿差与 $2$ 取 $\max$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
int main(){
	int x1, y1, x2, y2;
	cin >> x1 >> y1 >> x2 >> y2;
	ans += max((abs(x2 - x1) + 1), 2) * 2;
	ans += max((abs(y2 - y1) + 1), 2) * 2;
	cout << ans;
	return 0;
}

---

## 作者：SUNCHAOYI (赞：1)

这是一道有关于直角坐标系的题目，手动算一下就可以找到规律。

不难道想到分类讨论，我们分三类（飞行器与旗子应该不会重叠）：

1. $x_1 ≠ x_2$ 且 $y_1 ≠ y_2$。也就是样例给的图片，我们观察一下，发现比普通的求两点间的两倍曼哈顿距离又多了 $4$。所以此时的答案为 ${|x_1 - x_2| + |y_1 - y_2|} \times 2 + 4$。

2. $x_1 ≠ x_2$ 且 $y_1 = y_2$。同样的，进行手推，发现这次是两倍曼哈顿距离又多了 $6$。所以此时的答案为 ${|x_1 - x_2|} \times 2 + 6$。

3. $x_1 = x_2$ 且 $y_1 ≠ y_2$。与 $2$ 的情况的本质相同，也是两倍曼哈顿距离又多了 $6$。所以此时的答案为 ${|y_1 - y_2|} \times 2 + 6$。

![1](https://cdn.luogu.com.cn/upload/vjudge_pic/CF883M/386c66ca9620cccfa6fb068c3cb9fb65984ca527.png)

综上所述，我们可以得到代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
inline int read ();
int a,b,c,d;
int main ()
{
	a = read ();b = read ();c = read ();d = read ();
	if (a != c && b != d) printf ("%d\n",2 * (abs (a - c) + abs (b - d)) + 4);
	if (a == c) printf ("%d\n",2 * abs (b - d) + 6);
	if (b == d) printf ("%d\n",2 * abs (a - c) + 6);
	return 0;
}
inline int read ()
{
    int s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}

```

---

## 作者：HuZHUNZHUN (赞：0)

~~谨以此㵘题作为本蒟蒻回归OI世界的第一篇题解罢~~

显而易见：

首先，想要距离最短应当与旗子擦肩而过；

其次，想要距离最短在前往旗子的过程中不应当有朝旗子的反方向前进的情况，类似地，在回到出发点的过程中不应当有朝旗子方向的情况。

那么，我们可以通过平移使得这个形状成为一个矩形，注意到 $|x_1-x_2|+1$ 和 $|y_1-y_2|+1$ 分别为它的长和宽。这里需要注意的是，由于路径需要严格包含旗子，需要加一才行。

因此，它的周长（即，最短路径的长度）为 $2|x_1-x_2|+2|y_1-y_2|+4$。

但是，对于起点和旗子共线的情况，需要额外地讨论，其长度为 $2|x_1-x_2|+6$ 或 $2|y_1-y_2|+6$，这里用哪个式子取决于它们在哪个方向共线。

最后，是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
int main()
{
	ios::sync_with_stdio(false);
	cin>>a>>b>>c>>d;
	if(a==c) cout<<2*abs(d-b)+6;
	else if(b==d) cout<<2*abs(c-a)+6;
	else cout<<2*abs(c-a)+2*abs(d-b)+4;
	return 0;
}

```

---

## 作者：翼德天尊 (赞：0)

首先，我们可以很容易地知道，如果路线最短的话，那么我们走过的路线通过平移一定可以变成一个长方形。

那这个长方形的周长是多少呢？题目很贴心的给了我们两个样例，~~于是根据样例~~，我们可以将本题分为 $3$ 种情况讨论。（其中有两种情况可以合并为一种）

**1. 起点与终点的横坐标相同**

即如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/mr33imrd.png)

那么最短路程应该为两者的横坐标之差 $+6$。

**2. 起点与终点的纵坐标相同**

该情况与上述情况类似，把横坐标之差改为纵坐标即可。

**3. 横纵坐标都不同**

![](https://cdn.luogu.com.cn/upload/image_hosting/a9oc18v5.png)

则最短路应为——这就不用我再说了吧？

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; 
int a1,b1,a2,b2;
int read(){
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}

int main(){
	a1=read(),b1=read(),a2=read(),b2=read();
	if (a1==a2) printf("%d\n",6+2*(abs(b1-b2)));
	else if (b1==b2) printf("%d\n",6+2*(abs(a1-a2)));
	else printf("%d\n",(abs(a1-a2)+1)*2+(abs(b1-b2)+1)*2);
	return 0;
}
```


---

## 作者：peppaking8 (赞：0)

## 思路
首先很容易想到，走过的路线围成的图形最好是**长方形**。

如果图形向内凹陷，那么可以让其变成一个最小的外接长方形，这样周长不增，并且面积增加了。

考虑完这个之后，题目就变成了求最小的长和最小的宽。

如果 $(x_1,y_1),(x_2,y_2)$ 是两个**不同且不共线的点**，不妨设 $x_1<x_2,y_1<y_2$，那么显然我们可以从 $(x_1,y_1)$ 走到 $(x_2+1,y_1)$，再走到 $(x_2+1,y_2+1)$，再走回来即可。这样的答案是 $2\times (|x_1-x_2|+|y_1-y_2|+2)$。

那么如果这两个点共线呢？比如说，$x_1=x_2$。那么之前的策略还可行吗？显然，不可行。因为在从 $(x_1,y_1)$ 走到 $(x_2+1,y_1)$ 时，并没有包含 $(x_2,y_2)$。所以说长方形的宽还需增加 $1$，也即答案增加 $2$。

如果这两个点相同，那么经过尝试可以知道最好的方式答案是 $10$。但是题目中并没有这样的样例。

就是这样了，总结一下，需要考虑三种不同的情况，对于每种情况进行求解。

$$\text{Talk is cheap, show you the code.}$$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int x,y;
}a,b;
int main(){
	scanf("%d%d%d%d",&a.x,&a.y,&b.x,&b.y);
    if(a.x==b.x&&a.y==b.y) printf("10\n");
    //如果共点，直接输出结论
	else if(a.x==b.x) printf("%d\n",2*abs(a.y-b.y)+6);
    //如果共线，则同思路输出答案。
	else if(a.y==b.y) printf("%d\n",2*abs(a.x-b.x)+6);
	else printf("%d\n",2*abs(a.y-b.y)+2*abs(a.x-b.x)+4);
    //否则就是一般的情况。
    return 0;
}
```

---

## 作者：judgejudge (赞：0)

# 分三种情况进行讨论
**以下横纵坐标分别用x1,y1,x2,y2来表示。**

首先我们把这道题的位置关系理解成三种位置：

1. **重合：** 即x1==x2并且y1==y2
1. **共线：** 即x1==x2或者y1==y2
1. **其他：** 即x1!=x2并且y1!=y2

下面我们分别来讨论这三种情况：
- ###  重合：
这个其实我们可以不必讨论，因为100个测试数据点中没有一个是重合这个情况的。
- ### 共线：
我们知道可以将其构成一个矩形：

那么这个矩形的一条边长就是(x1-x2)+2或者(y1-y2)+2，记为a。因为这一条边已经涵盖了另一条边的一个点，所以它的周长就是**2*a+2**
- ### 其他：
还是构成矩形：

这次不共线，我们要协调边长，所以分别是**x1-x2+1和y1-y2+1**

所以依然是利用矩形的周长公式进行计算。

代码：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(){
	int x1,x2,y1,y2;
	cin>>x1>>y1>>x2>>y2;
	if(x1==x2||y1==y2){//共线
		int a;
		if(x1!=x2)a=abs(x1-x2)+2;
		else a=abs(y1-y2)+2;
		cout<<2*a+2<<endl; 
		return 0;
	}
	cout<<2*(abs(x1-x2)+abs(y1-y2)+2)<<endl;//不共线
	return 0;
}
```


---


# Move to the End

## 题目描述

给定一个由 $n$ 个整数组成的数组 $a$。

对于从 $1$ 到 $n$ 的每个整数 $k$，你需要执行以下操作：
1. 选择数组 $a$ 中的任意一个元素并将其移动到数组的最右端（可以选择最后一个元素，此时数组不会改变）；
2. 输出数组 $a$ 最后 $k$ 个元素的和；
3. 将第一步选择的元素移回其原始位置（恢复原始数组 $a$）。

对于每个 $k$，你需要选择移动的元素，使得输出的值尽可能大。

请计算每个 $k$ 对应的输出值。

## 说明/提示

以题目描述中的第一个测试用例为例：
- 当 $k=1$ 时，可以选择将第 $6$ 个元素移动到末尾，数组变为 $[13, 5, 10, 14, 8, 13, 15]$，输出值为 $15$；
- 当 $k=2$ 时，可以选择将第 $6$ 个元素移动到末尾，数组变为 $[13, 5, 10, 14, 8, 13, 15]$，输出值为 $13 + 15 = 28$；
- 当 $k=3$ 时，可以选择将第 $4$ 个元素移动到末尾，数组变为 $[13, 5, 10, 8, 15, 13, 14]$，输出值为 $15 + 13 + 14 = 42$；
- 当 $k=4$ 时，可以选择将第 $5$ 个元素移动到末尾，数组变为 $[13, 5, 10, 14, 15, 13, 8]$，输出值为 $14 + 15 + 13 + 8 = 50$；
- 当 $k=5$ 时，可以选择将第 $1$ 个元素移动到末尾，数组变为 $[5, 10, 14, 8, 15, 13, 13]$，输出值为 $14 + 8 + 15 + 13 + 13 = 63$；
- 当 $k=6$ 时，可以选择将第 $1$ 个元素移动到末尾，数组变为 $[5, 10, 14, 8, 15, 13, 13]$，输出值为 $10 + 14 + 8 + 15 + 13 + 13 = 73$；
- 当 $k=7$ 时，可以选择将第 $6$ 个元素移动到末尾，数组变为 $[13, 5, 10, 14, 8, 13, 15]$，输出值为 $13 + 5 + 10 + 14 + 8 + 13 + 15 = 78$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
7
13 5 10 14 8 15 13
6
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
1
42
2
7 5```

### 输出

```
15 28 42 50 63 73 78 
1000000000 2000000000 3000000000 4000000000 5000000000 6000000000 
42 
7 12```

# 题解

## 作者：yhl110804 (赞：0)

## 题意

  一个长度为 $n$ 的序列 $a$ 每次操作可将序列中的任意一个值放到末尾，共有 $n$ 次询问，第 $k$ 次询问要求输出在经过一次操作后 $\sum_{i=n}^{n-k+1} a_i$ 的最大值且询问之间独立，即每个询问后 $a$ 序列会恢复原状。

## 解法

因为每次操作仅能移动一个数到序列末尾，所以第 $k$ 次询问中 $a_{n}$ 到 $a_{n-k+2}$ 的和是肯定在答案中的，通过维护后缀和即可实现 $O(1)$ 查询。因为要求答案最大，所以移动的数 $a_i$ 一定是 $a_1$ 到 $a_{n-k+1}$ 中的最大值，可以通过维护前缀最大值来实现 $O(1)$ 查询。

代码总时间复杂度 $O(n)$。记得开 ```long long```。

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e6;
const int mod=1e9+7;
inline int read(){
   int x=0,f=1;char ch=getchar();
   while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
   while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
   return x*f;
}
int a[N];
int sum[N];
void solve(){
	int n=read();
	int sm=0;
	for(int i=1;i<=n;i++)a[i]=read(),sum[i]=max(sum[i-1],a[i]);
	for(int i=n;i>=1;i--){
		cout<<sm+sum[i]<<" ";
		sm+=a[i];
	}
	cout<<"\n";
	return;
}
signed main(){
	int T=read();
	while(T--)solve();
   return 0;
}
```

---

## 作者：AstaVenti_ (赞：0)

翻译一下题目，其实就是求长度为 $k$ 的后缀和，但可以将从后往前第 $k$ 个数换成此前的一个数，求在 $k=1,2,3\cdots n$ 时这个数的最大值。

我们需要记录每一个位置 $i$ 之前所有数的最大值 $g_i$ 和它之后所有数的和 $sum_i$，然后在从后往前处理每一个 $k$。

假设当前处理到了第 $i$ 位，答案即为 $\max\{sum_i,sum_i-a_i+g_i\}$。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,n;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		vector<ll>a(n+1),g(n+1);
		for(ll i=1;i<=n;i++){
			cin>>a[i];
			g[i]=max(g[i-1],a[i]);
		}
		ll sum=0;
		for(ll i=n;i>=1;i--){
			sum+=a[i];
			if(g[i]>a[i]){
				cout<<sum-a[i]+g[i]<<" ";
			}else{
				cout<<sum<<" ";
			}
		}
		cout<<endl;
	}
}

```

---


# Stripe 2

## 题目描述

给出一个长度为 $n$ 的序列 $a$，问有多少种方案将序列 $a$ 划分为恰好连续的三段（每个元素都属于某一段），使得每一段的和都相等。

## 样例 #1

### 输入

```
4
1 2 3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
1 2 3 4 5
```

### 输出

```
0
```

# 题解

## 作者：Erinyes (赞：7)

## Part 1：题意分析
题目让我们将序列划分为恰好连续的三段，使得每一段的和都相等。

也就是说，在这个序列当中找到两条分割线，使分开的三段的和相等。


------------

## Part 2：预处理
很容易联想到前缀和：
```cpp
for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
```
$sum[i]$ 表示从 $1$ 到 $i$ 所有数的和。

根据题意，每一段的和就等于 $1$ 到 $n$ 所有数的和的 $\dfrac{1}{3}$，如果总和不能被三整除，就可以直接输出 $0$ ，结束程序。
```cpp
if(sum[n]%3!=0){
	printf("0");
	return 0;
}
```


------------

## Part 3：运算

因为已知每一段的和，所以可以直接枚举每一段。

枚举第一段，然后用变量 $cnt$ 来记录第一段的可能的个数（ $tot$ 就是 $1$ 到  $n$ 的和）：

```cpp
for(int i=1;i<n;i++) if(sum[i]==tot) cnt++;
```
再在枚举的同时判断前缀和是否已经达到两段的和，如果达到，便可以将第一段的答案个数 $cnt$ 累加到最终答案 $ans$ 里：
```cpp
for(int i=1;i<n;i++){
	if(sum[i]==tot*2) ans+=cnt;
	if(sum[i]==tot) cnt++;
}
```
在这里有一个小小的优化， $n$ 为分割线在此题中是不存在的，因为如果 $n$ 为分割线，则会有一段为空，这种情况肯定是不存在的，所以可以舍掉。


------------

## Part 4：代码

记得开 long long !

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n;
long long a[100005],sum[100005]; //1<=n<=10^5
int main(){
	scanf("%lld",&n); //开long long时，记得修改占位符 
	for(long long i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sum[i]=sum[i-1]+a[i]; //用sum数组储存前缀和 
	}
	//如果总和不能被三整除，则可以直接输出0，结束程序 
	if(sum[n]%3!=0){
		printf("0");
		return 0;
	} 
	long long tot=sum[n]/3,ans=0,cnt=0,t=0; //在主函数里定义要记得清零
	for(long long i=1;i<n;i++){ //n位置不能为分割线 
		if(sum[i]==tot*2) ans+=cnt; //判断第二条分割线，并累加答案 
		if(sum[i]==tot) cnt++; //判断第一条分割线，累计情况数 
	}
	//输出答案，结束程序 
	printf("%lld",ans); 
	return 0;
}
```


---

## 作者：封禁用户 (赞：4)

### 前言

一道橙题我还做了一天，我果然变弱了。

### 分析

#### 题意

就是让你将这个序列分成 $3$ 段，然后要达到每段的总和相等。

#### 解题思路

分成 $3$ 段？

那就先统计一下总和，然后特判一下是否可以分成三段。

如果可以，那就开始处理。

`int x,y x表示到i的总和，y表示前面有多少个是总和/3的`

然后用一个 `ans` 作为答案。

那么 $i$ 从 $1$ 到 $n-1$ 开始处理，至于为什么到 $n-1$，因为 **each piece contains positive integer amount of squares.**，也就是说每一段必须是有整数的，如果是到 $n$ 那么就有可能存在着在 $n$ 的那个地方分割的可能性。

然后判断一下，是否存在着 $x=tot$ 如果存在那么就表示从 $1$ 到这里是存在着可以分割的 $1$ 段的。

还要一个判断，那么就是 $x=tot \times 2$ 是否成立，如果成立那么就证明前面有可以分成 $2$ 段，也可以表示后面有 $1$ 段，至于为什么，那么可以想一想前面已经处理过了可以分成 $3$ 段，那么如果前面是 $2$ 段的，后面必然是存在着 $1$ 段的。如果成立的话 $ans=ans+y$ 因为 $y$ 是表示前面有多少个 $1$ 段可以分的，那么也就说明了如果这个地方是可以对于后面的 $1$ 段是可以分的，那么前面的都会和这个点分会满足条件，满足了条件那么答案加上 $y$。

第二个判断要放在第一个前面，至于为什么，因为也存在着这种情况，那么就是说前面是可以满足 $2$ 段 也可以满足 $1$ 段，如果碰到这种情况，如果不是这样放的话，$2$ 段 和 $1$ 段的分割点是重合的！那么也就表示这个分割点是不可取的。

那么最后就输出答案。

### 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int INF=1e5+5;
int n,a[INF];
long long ans,tot;//不开 long long 见祖宗。
signed main()
{
        scanf("%d",&n);
        for (int i=1; i<=n; i++) {
                scanf("%d",&a[i]);
                tot+=a[i];
        }
        //读入处理。
        if (tot%3!=0) return 0&puts("0");//如果不能分三段，那么结束。
        long long x=0,y=0;
        tot/=3;
        //变量意义前面已经说过了。
        for (int i=1; i<n; i++) {
                x=a[i]+x;
                if (x==tot*2) ans=ans+y;//如果这个点是可以分前面 2 段的，那么答案加上 y。
                if (x==tot) y++;//如果这个点是可以分前面 1 段的，那么 y+1。
        }
        printf("%lld\n",ans);//输出答案。
        return 0;
}

```

### 写在后面的话

我这篇题解如果有错误，那么请在评论区里留言，我将会很感谢反映的人。

**谢谢观赏！**

---

## 作者：LuffyLuo (赞：2)

题目只是让我们将这个序列分为 3 段，并且保证每一段都相等，那么我们肯定会首先去判断可不可以这样分。
```cpp
	for(i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	if(sum%3!=0){
		printf("0");
		return 0;
	} 
```
就像上面的这样，但是大家可能会觉得这有个缺点，比如说如果输入样例是 2,3,3。

确实可以直接进行下一步操作，不过这个是不能分成三段的。我也是想到了这一点。于是加了个这个东东：
```cpp
sum/=3;
```
如果要想理解这个等一下我会讲，我必须得先把思路讲完。
然后我们就直接循环判断，再次把每个数加起来，如果说是 $sum$ 那么就让方法加一，但是因为后面可能会出现零的情况，所以前往不可以将前面的值给清空否则完蛋，如果是 $sum$ 的两倍，那么就把原来计算是否等于 $sum$ 的值再加给另外一个变量的值，而这个值就是我们要的东西。

但我们为什么不考虑第三段呢？因为你想一想，我们一二段都求出来了，而且我们也证明它是可以成为三段的，也就没这个必要了。
所以其代码如下：
```cpp
	long long ans=0,k=0,t=0;
	for(i=1;i<n;i++){
		ans+=a[i];
		if(ans==sum*2) k+=t;
		if(ans==sum) t++;
	}
	printf("%lld\n",k);
```
好了这下就讲完了，关于上面的那个代码的解释我也给大家说一下，我们再次以上面的示例为例：输入 2,3,3。

因为这个是可以绕过取余 3 的判断的，但是下面的要使得前面的第一段的值之和必须得为 2，可是却不行，所以我们这个方法是可以的。

不过这还是不对，那么我们是哪里错了呢？主要是我们的判断第一个要放在第二个的后面，为什么呢？因为也存在着这种情况，那么就是说前面是可以满足第二段也可以满足第一段，如果碰到这种情况，如果不是这样放的话，第二段和第一段的分割点是重合的！那么也就表示这个分割点是不可取的。

最后是全部代码：
```cpp
#include<bits/stdc++.h>
const int CF=100010;
using namespace std;
int a[CF];
int main(){
	int n,i;long long sum=0;//不开long long 见祖宗。
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	if(sum%3!=0){
		printf("0");
		return 0;
	} 
	sum/=3;
	long long ans=0,k=0,t=0;
	for(i=1;i<n;i++){
		ans+=a[i];
		if(ans==sum*2) k+=t;
		if(ans==sum) t++;
	}
	printf("%lld\n",k);
	return 0;
}
```

//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！

---

## 作者：Creroity (赞：2)

啊这，这道题卡了我好久……就因为两句代码写反了（而且反过来应该也是没影响的）

**咳咳**，回归正题。

题目中说了 $ n=10^5 $ ，所以前缀和肯定是要用的（一本正经）

~~于是我就作死打了个 $ n^2 $ 的暴力……~~

主要思路是枚举两个分割点，再通过前缀和判断三段是否相等。

然后贴一下核心的代码：

```cpp
for(int i=1;i<n-1;i++){
	if(a[i]==a[n]/3)f[++tot]=i;//玄学初始化 
}
for(int i=1;i<=tot;i++){
	if(a[f[i]]!=a[n]/3)continue;//玄学优化 
	for(int j=f[i]+1;j<n;j++){
		if(a[f[i]]==a[j]-a[f[i]]&&a[f[i]]==a[n]-a[j]){//判断 
			ans++;
			if(a[j+1]>0)break;//玄学优化 
		}
	}
}
```
~~嗯，事实证明这题的数据并不水~~，那么就想办法优化呗~

核心思想其实差不多，但是我们稍微思考一下就会发现：

如果一个点是第一个分割点，那么这个点就会满足 $ a_i=\mathtt{tot} \div 3 $ ，而如果后面还有第二个分割点，那么我们就可以直接将答案加上前面可以做第一个分割点的个数。

所以，我们就只需要在遇到满足第一个分割点时，将此时记录第一分割点的变量加一，然后在后面遇到第二分割点时将答案加上此时的第一分割点个数就可以啦~

**Code：**
```cpp
#include<bits/stdc++.h>         //万能头 
using namespace std;
long long n,ans,a[100005];      //不开 long long 见祖宗！ 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		a[i]=a[i-1]+x;          //前缀和 
	}
	if(a[n]%3!=0){              //此处有一个特判，前面没有讲到，但是不要忘了加哦~ 
		cout<<0;
		return 0;
	}
	long long tot=0,sum=a[n]/3;
	for(int i=1;i<n;i++){
		if(a[i]==sum*2)ans+=tot;//先判断这个点是否为第二分割点 
		if(a[i]==sum)tot++;     //在判断这个点是否为第一分割点，之前就是这两句写反了，我也很懵啊…… 
	}
	cout<<ans;
	return 0;
}
```
~~不要脸地求个赞~~

---

## 作者：Vanilla_0 (赞：1)

双倍经验：[Link](https://www.luogu.com.cn/problem/CF466C)
## 思路概览
只需要统计序列总和，从而找到三等分点所在位置，而三等分点的组合方式数即为所求。

方法是遍历整个序列，动态维护前缀和，如果满足总和的 $\dfrac{1}{3}$，计数器累加，如果满足总和的 $\dfrac{2}{3}$，就往答案里加入累计满足 $\dfrac{1}{3}$ 的方案数。

注意 $\dfrac{2}{3}$ 的累加要放在前面，这样避免加重。

## 代码时刻
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,s,a[100005],now,ans,tot; 
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),s+=a[i];
	for(int i=1;i<=n;i++)
	{
		now+=a[i];
		if(now*3==s*2&&i>1&&i<n) ans+=tot;
		if(now*3==s) tot++;
	}
	printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：林家三少 (赞：1)

这题其实也不难，我们首先来看一下题目：

输入 $n$ ，下一行输入 $n$ 个整数，然后看他能不能分成三个**连续**的一段，每段总和一致。不行的话就输出 $0$ 。

首先我们可以特判一下输出 $0$ 的其中一种情况： $n$ 个整数的和 %$3$ 不等于 $0$ ，如这是这样那我们就会发现无论怎么分都不可能分成和相等的三段的。然后就剩和 %$3$ 等于 $0$ 但是不能分成和相等的**连续**三段，比如：

$4$

$3 4 1 4$

我们可以看到和是 $12$ ，要分成 $3$ 个 $4$ ，$3$ 要和 $1$ 才能组成 $4$ ，但中间隔了个 $4$ ，他们不能无视 $4$ 自己组成 $4$ ，所以这样输出的也是 $0$ 。

讲完了输出 $0$ 的情况，接下来其他情况就是~~不输出 $0$ 的了~~输出方案数的了。这方案数又是啥，就是有多少个方案是可以分成和相等的三段的(废话)。那这个怎么求出来，其实就是找到连续的几个数和为 $n$ 个整数的和 $/3$ 的两倍的东西 $......$

哎呀说不下去了上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int n,h,ans;
int a[1000000+10];
int AC(){
	long long A=0,C=0,ans=0;
	for(int i=1;i<=n;i++){
		A+=a[i];
		if(A==h*2)
			ans+=C; //这就是我上面说的情况，如果分了两个那剩下的一定也可以分
		if(A==h)
			C++; //如果可以分前面一段，种数就++
	}
	return ans; //最后返回最终答案
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		h+=a[i]; //先把n个整数的和算好
	}
	if(h%3!=0){ //特判
		cout<<"0";
		return 0;
	}
	h/=3; 
	cout<<AC(); //进入函数，输出的是最终方案
	return 0; //完结撒花
}
```


---

## 作者：long_long (赞：1)

洛谷水题多的是，就是需要发现水题的眼睛。

# 题目大意：

给出一个长度为nn的序列，问有多少种方案将序列划分为恰好连续的三段（每个元素都属于某一段），使得每一段的和都相等。

# 思路：

首先如果这个长度不能被3整除，那么直接输出0。

然后统计一下就行了。

# 代码：

```
#include<iostream>
using namespace std;
int t[100005];
int main(){
    int n,sum=0;
    cin>>n;//输入
    for(int i=1;i<=n;i++){
        cin>>t[i];
        sum+=t[i];//加一下
    }
    if(sum%3!=0){ cout<<0<<endl;return 0;}//判断
    int tot=0,ans=0,cnt=0;
    sum=sum/3;
    for(int i=1;i<=n;i++){//统计
        tot+=t[i];
        if(tot==sum*2){
            ans+=cnt;
        }
        if(tot==sum){
            cnt++;
        }
    }
    cout<<ans<<endl;/输出
    return 0;
}
```


---

## 作者：Yi_Fan (赞：0)

# 前言：
作者温馨提示：

**十年OI一场空，不开long long 见祖宗**


------------
# 题意：
将一些元素**按顺序**分为三部分，每部分元素总和相等。


------------
# 分析：
1. 因为要三部分相等，所以可以把前$i$个数之和分别记录
2. 用循环来从头统计
3. 特殊情况：当全部和不为$3$的倍数时直接输出$0$


------------
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
//变量区
long long n;//序列长度 
long long a[100005];//记录序列 
long long sum[100005];//当前元素之和 
long long tot;//1/3的元素大小 
long long ans1=0,ans2=0;//记录答案 
//主函数 
int main() {
	cin >> n;
	for(int i = 1; i <= n; i ++) {
		cin >> a[i];
		sum[i] = a[i] + sum[i-1];//不断记录元素总和 
	}
	if(sum[n] %3 != 0){//最后一个总和就是整个序列之和 
		printf("0");
		return 0;
	}
	tot = sum[n] /3;//记录 
	for(int i = 1; i < n; i ++){
        if(sum[i] == 2*tot) ans2+=ans1;//如果某些元素之和等于2*tot，剩下的就一定是tot，所以只用判断2次就可以将ans1的值加上
        if(sum[i] == tot) ++ans1;//如果这里a[i]=tot，说明首先有几个元素可以得到n个元素的1/3，种数+1
	}
	cout<<ans2;
	return 0;
}
```


---

## 作者：薛定谔的诚 (赞：0)

### 一. 分析
先抓住关键词“连续”，“和”，同时瞄一眼~~看不懂的~~原题中 $10^5$ ，那么就很明显的可以看出这是一道前缀和问题了。

### 二. 思路
思路其实很好找，已经确定这道题用前缀和做，但是，具体怎么前缀和？可以看到，这道题数组的总和是已经确定了的，又确定了要分成 $3$ 份，于是，一种思路自然而然地出现在我的脑阔子中:

1. 在输入的同时算出数组的总和然后除以 $3$ ，把这个数记为 $target$ （温馨翻译：目标）， $target$ 的作用是寻找数组分成三份的两个节点。

2. 这时，为了使程序变快，这里要加一个特判：当 $n$  $÷$  $3$ 不是一个整数时，直接输出 $0$ ，因为总和都不能被 $3$ 整除时，就更不能平均分成三份了。

3. 在输入的那个循环中将数组每一个元素变为它前面所有元素之和，这是为了方便寻找 $target$ 。

4. 下面是本题的核心：该如何用 $target$ 寻找两个节点？其实很简单，由于 $target$ 是总和除于 $3$ 的数，所以我们只需要在前缀和数组中寻找一倍 $target$ 和二倍 $target$ 就是我们要找的两个节点了。

5. 但是还有一个没有解决的问题：所有节点找到了，但如何求出方案数？首先，我们要认清最终的方案数不能由第一个节点决定，也就是不能直接找到一个第一个节点就加 $1$ ，因为有可能找不到第二个节点。所以，我们应该在循环中设置一个 $counter$ 用来统计 $a[i]$ 中第一个节点的个数，并在找到第二个节点后将最终结果 $ans$ 加上 $counter$ 。同时，这里要注意，第一个节点的判断要放在第二个节点判断的后面，这是为了防止节点重合。

### 三. 代码实现
总体思路已经出来了，下面是代码。


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100005;
long long n,sum,a[N],ans,counter;	//n指数字个数，a是数组，sum是数组总和，ans是最终结果，counter用来统计第一个节点个数 

int main(){
	cin >> n;
	a[0] = 0;
	for(long long i = 1; i <= n; i++){
		int t;
		cin >> t;
		a[i] = a[i - 1] + t;	//将数组变为前缀和数组 
		sum += t;
	}
	if(sum % 3 != 0){	//特判，即思路中的第2点 
		cout << 0 << endl;
		return 0;
	}
	long long target = sum / 3;   //用来寻找节点 
	for(long long i = 1; i < n; i++){ 
		if(a[i] == 2 * target){ 	//注意，第二个节点的判断一定要放在前面 
			ans += counter;
		}
		if(a[i] == target){
			counter++;
		}
	}
	cout << ans << endl;
	return 0;
} 
```

### 总结
说实话，这题身为一道普及-，有些水，~~能被我这种蒟蒻做出来的题能不水？~~，总体思路不难想，主要考的应该是前缀和，难点就是中间对第二个节点和第一个节点的判断的先后顺序，确实有点坑，我也是搞了好久。所以以后一定要把样例在脑中一步一步的模拟出来。

### 最后，谢谢食用

---

## 作者：zzh_han (赞：0)

## 题意

就是有 $n$ 个数将这些数拆成三组使每组的大小和为总数的三分之一问我们有多少种方案数

## 做法

我们首先要判断所有数的和是不是3的倍数如果不是那就不可能有方案数

我们现在处理可以分为3段的我们可以去暴力枚举每个点看是否为第一个或第二个断点如果是第一个断点那我们就可以知道在这一个点可以作为第一个断点。如果是第二个断点那么我们要就加上我们已知再这个之前的第一个断点总数。最后输出就好了（注意要开long long）

``` cpp
#include <bits/stdc++.h>
using namespace std;
int n;
long long f[100005];
long long sum,ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)	
	{
		cin>>f[i];
		sum+=f[i];
	}
	if(sum%3!=0)//如果sum不是3的倍数那么就没有办法切成3段 
	{
		cout<<0;
		return 0;		
	}
	sum/=3;//算出每段需要的长度 
	long long s=0,cnt=0;
	for(int i=1;i<n;i++)//最后一个不能为断点 
	{
		cnt+=f[i];
//		cout<<cnt<<endl;
		if(cnt==sum*2)//判断第二个断点 
			ans+=s;
		if(cnt==sum)//判断第一个断点 
			s++;
	} //第一个断点的判断放在后面是为了防止断点重合 
	cout<<ans;
} 
```



---


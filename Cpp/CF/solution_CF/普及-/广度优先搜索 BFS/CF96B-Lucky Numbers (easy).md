# Lucky Numbers (easy)

## 题目描述

Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than $ 4 $ and $ 7 $ . For example, numbers $ 47 $ , $ 744 $ , $ 4 $ are lucky and $ 5 $ , $ 17 $ , $ 467 $ are not.

Lucky number is super lucky if it's decimal representation contains equal amount of digits $ 4 $ and $ 7 $ . For example, numbers $ 47 $ , $ 7744 $ , $ 474477 $ are super lucky and $ 4 $ , $ 744 $ , $ 467 $ are not.

One day Petya came across a positive integer $ n $ . Help him to find the least super lucky number which is not less than $ n $ .

## 样例 #1

### 输入

```
4500
```

### 输出

```
4747
```

## 样例 #2

### 输入

```
47
```

### 输出

```
47
```

# 题解

## 作者：hensier (赞：91)

这道题可以使用宽搜来做，因为深搜是一搜到底，而宽搜是逐层的搜索，所以在这题就体现出了宽搜的好处——每一次增加$4$或$7$作为扩展。如果用深搜的话，那么会一直不停地走下去，这样顺序就不同，而宽搜的话，是先走$4$再走$7$，再下一层。

```cpp
#include<bits/stdc++.h>//万能头文件
#pragma GCC optimize(2)//手动O2，竞赛勿用！
using namespace std;
const int maxn=1e6;//初步大概是要开1e6的
int n,front=1,rear=1;//基本初始化
long long q[maxn];//十年OI一场空，不开long long见祖宗
void check(long long x)//check函数来看是否为lucky number
{
    if(x<n)return;//如果x还没有输入大或者不等于x，就直接跳出
    long long y=x,a=0,b=0;//a、b分别代表7和4的数量
    while(x)
    {
        if(x%10-4)a++;//记录
        else b++;
        x/=10;//抹掉末位
    }
    if(a==b)//相等就直接输出并退出整个程序
    {
        cout<<y;
        exit(0);
    }
}
int main()
{
    ios::sync_with_stdio(0);//关同步
    cin>>n;
    while(front<=rear)//宽搜
    {
        q[++rear]=q[front]*10+4;//依次按顺序扩展
        check(q[rear]);
        q[++rear]=q[front]*10+7;
        check(q[rear]);
        front++;
    }
}
```

拓展顺序：

|$front$|$1$|$1$|$1$|$2$|$2$|$2$|$2$|$3$|$...$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$rear$|$1$|$2$|$3$|$4$|$5$|$6$|$7$|$8$|$...$|
|$val$|$0$|$4$|$7$|$44$|$47$|$74$|$77$|$444$|$...$|

![](https://cdn.luogu.com.cn/upload/image_hosting/09havpxi.png)

~~（图都是一点一点地画出来的，不要忘记点击那个大拇指按钮哦！）~~

---

## 作者：Vader10 (赞：29)

## 要学会打表。
## 要学会打表。
## 要学会打表。
重要的事情说三遍。

首先，要写一个程序：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    for(int i=1;i<=5;i++){
        int a[10]={},t=0;
        for(int j=0;j<i;j++){
            a[t++]=4;
        }
        for(int j=0;j<i;j++){
            a[t++]=7;
        }
        do{
            for(int j=0;j<i*2;j++){
                cout<<a[j];
            }
            cout<<',';
        }while(next_permutation(a,a+i*2));
    }
    return 0;
}
```
得到这样一个表：

```cpp
long long ln[350]={47,74,4477,4747,4774,7447,7474,7744,444777,447477,447747,447774,474477,474747,474774,477447,477474,477744,744477,744747,744774,747447,747474,747744,774447,774474,774744,777444,44447777,44474777,44477477,44477747,44477774,44744777,44747477,44747747,44747774,44774477,44774747,44774774,44777447,44777474,44777744,47444777,47447477,47447747,47447774,47474477,47474747,47474774,47477447,47477474,47477744,47744477,47744747,47744774,47747447,47747474,47747744,47774447,47774474,47774744,47777444,74444777,74447477,74447747,74447774,74474477,74474747,74474774,74477447,74477474,74477744,74744477,74744747,74744774,74747447,74747474,74747744,74774447,74774474,74774744,74777444,77444477,77444747,77444774,77447447,77447474,77447744,77474447,77474474,77474744,77477444,77744447,77744474,77744744,77747444,77774444,4444477777,4444747777,4444774777,4444777477,4444777747,4444777774,4447447777,4447474777,4447477477,4447477747,4447477774,4447744777,4447747477,4447747747,4447747774,4447774477,4447774747,4447774774,4447777447,4447777474,4447777744,4474447777,4474474777,4474477477,4474477747,4474477774,4474744777,4474747477,4474747747,4474747774,4474774477,4474774747,4474774774,4474777447,4474777474,4474777744,4477444777,4477447477,4477447747,4477447774,4477474477,4477474747,4477474774,4477477447,4477477474,4477477744,4477744477,4477744747,4477744774,4477747447,4477747474,4477747744,4477774447,4477774474,4477774744,4477777444,4744447777,4744474777,4744477477,4744477747,4744477774,4744744777,4744747477,4744747747,4744747774,4744774477,4744774747,4744774774,4744777447,4744777474,4744777744,4747444777,4747447477,4747447747,4747447774,4747474477,4747474747,4747474774,4747477447,4747477474,4747477744,4747744477,4747744747,4747744774,4747747447,4747747474,4747747744,4747774447,4747774474,4747774744,4747777444,4774444777,4774447477,4774447747,4774447774,4774474477,4774474747,4774474774,4774477447,4774477474,4774477744,4774744477,4774744747,4774744774,4774747447,4774747474,4774747744,4774774447,4774774474,4774774744,4774777444,4777444477,4777444747,4777444774,4777447447,4777447474,4777447744,4777474447,4777474474,4777474744,4777477444,4777744447,4777744474,4777744744,4777747444,4777774444,7444447777,7444474777,7444477477,7444477747,7444477774,7444744777,7444747477,7444747747,7444747774,7444774477,7444774747,7444774774,7444777447,7444777474,7444777744,7447444777,7447447477,7447447747,7447447774,7447474477,7447474747,7447474774,7447477447,7447477474,7447477744,7447744477,7447744747,7447744774,7447747447,7447747474,7447747744,7447774447,7447774474,7447774744,7447777444,7474444777,7474447477,7474447747,7474447774,7474474477,7474474747,7474474774,7474477447,7474477474,7474477744,7474744477,7474744747,7474744774,7474747447,7474747474,7474747744,7474774447,7474774474,7474774744,7474777444,7477444477,7477444747,7477444774,7477447447,7477447474,7477447744,7477474447,7477474474,7477474744,7477477444,7477744447,7477744474,7477744744,7477747444,7477774444,7744444777,7744447477,7744447747,7744447774,7744474477,7744474747,7744474774,7744477447,7744477474,7744477744,7744744477,7744744747,7744744774,7744747447,7744747474,7744747744,7744774447,7744774474,7744774744,7744777444,7747444477,7747444747,7747444774,7747447447,7747447474,7747447744,7747474447,7747474474,7747474744,7747477444,7747744447,7747744474,7747744744,7747747444,7747774444,7774444477,7774444747,7774444774,7774447447,7774447474,7774447744,7774474447,7774474474,7774474744,7774477444,7774744447,7774744474,7774744744,7774747444,7774774444,7777444447,7777444474,7777444744,7777447444,7777474444,7777744444};
```
### 核心程序：
```cpp
int main(){
    int n;
    cin>>n;
    for(int i=0;i<350;i++){
        if(ln[i]>=n){
            cout<<ln[i]<<endl;
            return 0;
        }
    }
    return 0;
}
```
### 完整代码如下：
```cpp
#include<iostream>
using namespace std;
long long ln[350]={47,74,4477,4747,4774,7447,7474,7744,444777,447477,447747,447774,474477,474747,474774,477447,477474,477744,744477,744747,744774,747447,747474,747744,774447,774474,774744,777444,44447777,44474777,44477477,44477747,44477774,44744777,44747477,44747747,44747774,44774477,44774747,44774774,44777447,44777474,44777744,47444777,47447477,47447747,47447774,47474477,47474747,47474774,47477447,47477474,47477744,47744477,47744747,47744774,47747447,47747474,47747744,47774447,47774474,47774744,47777444,74444777,74447477,74447747,74447774,74474477,74474747,74474774,74477447,74477474,74477744,74744477,74744747,74744774,74747447,74747474,74747744,74774447,74774474,74774744,74777444,77444477,77444747,77444774,77447447,77447474,77447744,77474447,77474474,77474744,77477444,77744447,77744474,77744744,77747444,77774444,4444477777,4444747777,4444774777,4444777477,4444777747,4444777774,4447447777,4447474777,4447477477,4447477747,4447477774,4447744777,4447747477,4447747747,4447747774,4447774477,4447774747,4447774774,4447777447,4447777474,4447777744,4474447777,4474474777,4474477477,4474477747,4474477774,4474744777,4474747477,4474747747,4474747774,4474774477,4474774747,4474774774,4474777447,4474777474,4474777744,4477444777,4477447477,4477447747,4477447774,4477474477,4477474747,4477474774,4477477447,4477477474,4477477744,4477744477,4477744747,4477744774,4477747447,4477747474,4477747744,4477774447,4477774474,4477774744,4477777444,4744447777,4744474777,4744477477,4744477747,4744477774,4744744777,4744747477,4744747747,4744747774,4744774477,4744774747,4744774774,4744777447,4744777474,4744777744,4747444777,4747447477,4747447747,4747447774,4747474477,4747474747,4747474774,4747477447,4747477474,4747477744,4747744477,4747744747,4747744774,4747747447,4747747474,4747747744,4747774447,4747774474,4747774744,4747777444,4774444777,4774447477,4774447747,4774447774,4774474477,4774474747,4774474774,4774477447,4774477474,4774477744,4774744477,4774744747,4774744774,4774747447,4774747474,4774747744,4774774447,4774774474,4774774744,4774777444,4777444477,4777444747,4777444774,4777447447,4777447474,4777447744,4777474447,4777474474,4777474744,4777477444,4777744447,4777744474,4777744744,4777747444,4777774444,7444447777,7444474777,7444477477,7444477747,7444477774,7444744777,7444747477,7444747747,7444747774,7444774477,7444774747,7444774774,7444777447,7444777474,7444777744,7447444777,7447447477,7447447747,7447447774,7447474477,7447474747,7447474774,7447477447,7447477474,7447477744,7447744477,7447744747,7447744774,7447747447,7447747474,7447747744,7447774447,7447774474,7447774744,7447777444,7474444777,7474447477,7474447747,7474447774,7474474477,7474474747,7474474774,7474477447,7474477474,7474477744,7474744477,7474744747,7474744774,7474747447,7474747474,7474747744,7474774447,7474774474,7474774744,7474777444,7477444477,7477444747,7477444774,7477447447,7477447474,7477447744,7477474447,7477474474,7477474744,7477477444,7477744447,7477744474,7477744744,7477747444,7477774444,7744444777,7744447477,7744447747,7744447774,7744474477,7744474747,7744474774,7744477447,7744477474,7744477744,7744744477,7744744747,7744744774,7744747447,7744747474,7744747744,7744774447,7744774474,7744774744,7744777444,7747444477,7747444747,7747444774,7747447447,7747447474,7747447744,7747474447,7747474474,7747474744,7747477444,7747744447,7747744474,7747744744,7747747444,7747774444,7774444477,7774444747,7774444774,7774447447,7774447474,7774447744,7774474447,7774474474,7774474744,7774477444,7774744447,7774744474,7774744744,7774747444,7774774444,7777444447,7777444474,7777444744,7777447444,7777474444,7777744444};
int main(){
    int n;
    cin>>n;
    for(int i=0;i<350;i++){
        if(ln[i]>=n){
            cout<<ln[i]<<endl;
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：StarryWander (赞：11)

## 本题解使用 **BFS** 算法

### **这道题核心思路就是：**

1.从 $0$ 开始存入队列进行搜索。

设 **队首元素** 为: $k$。

2.将 $k \times 10+4$ 存入队列。

3.再将 $k \times 10+7$ 存入队列。

4.直到 $k\geqslant n$ 为止。

ps:一定是先放入 $k \times 10+4$ ，再放入 $k \times 10+7$ ,否则无法满足:

寻找大于等于 $n$ 的 **最小** super lucky number。

### **如何判断数列中 $4$ 和 $7$ 的个数是否相同？**

只需要开一个结构体型的队列 $q$。

用 $stp$ 来判断这个数是否由数量相等的 $4$ 和 $7$ 组成。

每次存入 $k \times 10+4$ 后。

```cpp
stp++;
```
每次存入 $k \times 10+7$ 后。

```cpp
stp--;
```
如果 $stp=0$ 时，数列 $4$ 和 $7$ 数量相同。

## code

```cpp
//记得开 long long,不然WA
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
	ll x,stp;//依次代表当前的值和是否 4 和 7 数量相同。
};
int main(){
	ll n;
	cin>>n;
	queue<node>q;
	q.push((node){0,0});
	while(!q.empty()){
		node k=q.front();
		if(k.x>=n&&k.stp==0){//判断当前数值是否大于n以及满足 4 7 数量相同。
			cout<<k.x;
			return 0;
		}
		if(k.x<1e9){//时间优化，如果大于最大值没必要再进行下去。
			q.push((node){k.x*10+4,k.stp+1});
			q.push((node){k.x*10+7,k.stp-1});
		}
		q.pop();
	}
	return 0;
}

```


---

## 作者：_Qer (赞：9)

BFS做法

用广搜是因为要找最小的数

以0为起点，搜每一个可能的数（因为每个数必须为4或7，于是每一位就两种情况，$n<=10^9$所以可以这么搞）

每次往当前数后面加上4或7（先加4保证最先搜出来的最小）

判断合法的条件就是大于n且4和7出现次数相同

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;//longlong保险
inline bool check(long long x) {//判断合法（大于n的判断我放外边了）
    int a = 0, b = 0;
    //a为7出现次数，b为4出现次数
    while (x) {//数每一位数
        if (x % 10 == 7) {
            ++a;
        } else {
            ++b;
        }
        x /= 10;
    }
    return a == b;//位数相等
}
long long bfs[10100], head, tail;
//搞BFS
int main() {
    cin >> n;
    bfs[tail++] = 0;//起点
    while (head < tail) {
        long long u = bfs[head++];
        if (u >= n && check(u)) {//合法
            cout << u << endl;
            return 0;//结束
        }
        bfs[tail++] = u * 10 + 4;
        bfs[tail++] = u * 10 + 7;
        //搜接下来的两种情况
    }
    return 0;
}

```

---

## 作者：Tune_ (赞：6)

来呀~模拟呀~反正有~大把时光~

这题其实可以模拟，没有模拟题解，本蒟蒻来一篇~~

温馨提示：模拟比较麻烦，考场不建议用哦~

* _本题解仅供参考，慎用模拟！_ 

进入正题：
 
 这题首先判断位数，奇数位的话要长度+1，直接输出。
 
 如果第一位大于7，没戏，只能增加位数，直接输出。
 
 当这一位为4或7，直接上，如果小于，后面暂时全是4。
 
 当这一位大于7，就要进位（具体做法参考下面代码）。
 
 最后判4和7的个数是否相等（具体细节参考下面代码注释）

--------------------------------------超长代码预警--------------------------------------

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string s1,s2;
	cin>>s1;
	int s4=0,s7=0,l;
	l=s1.size();
	if(s1[0]>'7')
	{
		if(l%2)
			l+=1;
		else
			l+=2;
	}
	if(l%2)
		l++;
	if(l>s1.size())//特判
	{
		for(int i=1;i<=l/2;i++)
			cout<<4;
		for(int i=1;i<=l/2;i++)
			cout<<7;
		return 0;
	}
	int t=0;
	for(int i=l-1;i>=0;i--)//进位
	{
		if(s1[i]<'7'&&t)
		{
			t=0;
			s1[i]+=1;
		}
		if(s1[i]>'7')
		{
			t++;
			s1[i]='0';
		}
	}
	bool f=0;
	for(int i=0;i<l;i++)//转换成‘47’串
	{
		if(f)
		{
			s2+='4';
			s4++;
		}
		if(s1[i]=='4'&&!f)//等于4
		{
			s2+='4';
			s4++;
		}
		if(s1[i]=='7'&&!f)//等于7
		{
			s2+='7';
			s7++;
		}
		if(s1[i]>'4'&&s1[i]<'7'&&!f)//在4和7之间
		{
			s2+='7';
			s7++;
			f=1;
		}
		if(s1[i]<'4'&&!f)
		{
			s2+='4';
			s4++;
			f=1;
		}
		if(s1[i]>'7'&&!f)//大于7的特殊情况
		{
			for(int j=i-1;j>=0;j--)
			{
				if(s2[j]=='4')//找一个前面的4，改成7，这样后面的就可以全是4
				{
					s2[j]='7';
					s4--;
					s7++;
					f=1;
					break;
				}
			}
			if(!f)
			{
				l+=2;
				for(int i=1;i<=l/2;i++)
					cout<<4;
				for(int i=1;i<=l/2;i++)
					cout<<7;
				return 0;
			}
		}
	}
   //注意！以下有坑！
	if(s7>s4)//当7比4多
	{
		for(int i=l-1;i>=0;i--)
		{
			if(s2[i]=='4')//将一个4改为7，这时一定大于原数，后面的7改成4，让4和7个数相等。
			{	
				s2[i]='7';
				s4--;
				s7++;
				for(int j=i+1;j<l;j++)
				{
					if(s7>s4&&s2[j]=='7')
					{
						s2[j]='4';
						s4++;
						s7--;
					}
				}
				break;
			}
		}
		if(s7>s4)//还是大于就彻底没救
		{
			l+=2;
			for(int i=1;i<=l/2;i++)
				cout<<4;
			for(int i=1;i<=l/2;i++)
				cout<<7;
			return 0;
		}
	}
	if(s4>s7)//4比7多
	{
		for(int i=l-1;i>=0;i--)
		{
			if(s4==s7)
				break;
        if(s2[i]=='4')//尽量改后面的，让数最小
        {
              s2[i]='7';
              s4--;
              s7++;
        }
		}
	}
	cout<<s2;//总算完工了。。。
	return 0;
}
```

走过路过，点个赞呗QAQ

---

## 作者：封禁用户 (赞：2)

~~next_permutation是个好东西，Oier都要珍惜它。~~

上程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define l(s) s.size()
int up(int n)
{
    return(n%2?n/2+1:n/2);//上取整
}
string s;
int se,fo,el;
int main()
{
    cin>>s;
    for(int i=0;i<l(s);i++)
        if(s[i]=='7')
            se++;
        else if(s[i]=='4')
            fo++;
        else
            el++;
    //统计4和7的个数
    if(fo==se&&el==0)
    {
        cout<<s;
        return 0;
    }
    //4747474477？
    int n=l(s);
    int m=up(n);
    string t;
    for(int i=0;i<m;i++)
        t+="47";
    sort(t.begin(),t.end());
    //构造Lucky Numbers
    string u;
    for(int i=0;i<l(s)/2;i++)
        u+='7';
    for(int i=l(s)/2;i<l(s);i++)
        u+='4';
    if(l(s)&1)//&1=%2(位运算)
    {
        cout<<t;
        return 0; 
    }
    else if(s>=u)//特判，如果s>=777…444…
    {
        t+="47";
        sort(t.begin(),t.end());
        cout<<t;
        return 0;
    }
    do
        if(t>=s)
        {
            cout<<t;
            return 0;
        }
    while(next_permutation(t.begin(),t.end()));//要用do--while
    return 0;
}
```


---

## 作者：Coding__QAQ (赞：1)

# 这题挺有趣的呢！

## 乍一看数据范围，……贪心？不对，我们需要

### 满足4,7的数量相同，情况有很多，所以，先打个表呀！

先写dfs程序，不用1~1e9的暴力搜，只需要让4,7的数位相同就行了，因为这些数最多只有8位，也就是说4,7最多4位，这样直接for也可以，找出这些$lucky$  $number$后，直接判断就行了。

#### dfs的程序在此略过。


------------

AC：代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ln[350]={47,74,4477,4747,4774,7447,7474,7744,444777,447477,447747,447774,474477,474747,474774,477447,477474,477744,744477,744747,744774,747447,747474,747744,774447,774474,774744,777444,44447777,44474777,44477477,44477747,44477774,44744777,44747477,44747747,44747774,44774477,44774747,44774774,44777447,44777474,44777744,47444777,47447477,47447747,47447774,47474477,47474747,47474774,47477447,47477474,47477744,47744477,47744747,47744774,47747447,47747474,47747744,47774447,47774474,47774744,47777444,74444777,74447477,74447747,74447774,74474477,74474747,74474774,74477447,74477474,74477744,74744477,74744747,74744774,74747447,74747474,74747744,74774447,74774474,74774744,74777444,77444477,77444747,77444774,77447447,77447474,77447744,77474447,77474474,77474744,77477444,77744447,77744474,77744744,77747444,77774444,4444477777,4444747777,4444774777,4444777477,4444777747,4444777774,4447447777,4447474777,4447477477,4447477747,4447477774,4447744777,4447747477,4447747747,4447747774,4447774477,4447774747,4447774774,4447777447,4447777474,4447777744,4474447777,4474474777,4474477477,4474477747,4474477774,4474744777,4474747477,4474747747,4474747774,4474774477,4474774747,4474774774,4474777447,4474777474,4474777744,4477444777,4477447477,4477447747,4477447774,4477474477,4477474747,4477474774,4477477447,4477477474,4477477744,4477744477,4477744747,4477744774,4477747447,4477747474,4477747744,4477774447,4477774474,4477774744,4477777444,4744447777,4744474777,4744477477,4744477747,4744477774,4744744777,4744747477,4744747747,4744747774,4744774477,4744774747,4744774774,4744777447,4744777474,4744777744,4747444777,4747447477,4747447747,4747447774,4747474477,4747474747,4747474774,4747477447,4747477474,4747477744,4747744477,4747744747,4747744774,4747747447,4747747474,4747747744,4747774447,4747774474,4747774744,4747777444,4774444777,4774447477,4774447747,4774447774,4774474477,4774474747,4774474774,4774477447,4774477474,4774477744,4774744477,4774744747,4774744774,4774747447,4774747474,4774747744,4774774447,4774774474,4774774744,4774777444,4777444477,4777444747,4777444774,4777447447,4777447474,4777447744,4777474447,4777474474,4777474744,4777477444,4777744447,4777744474,4777744744,4777747444,4777774444,7444447777,7444474777,7444477477,7444477747,7444477774,7444744777,7444747477,7444747747,7444747774,7444774477,7444774747,7444774774,7444777447,7444777474,7444777744,7447444777,7447447477,7447447747,7447447774,7447474477,7447474747,7447474774,7447477447,7447477474,7447477744,7447744477,7447744747,7447744774,7447747447,7447747474,7447747744,7447774447,7447774474,7447774744,7447777444,7474444777,7474447477,7474447747,7474447774,7474474477,7474474747,7474474774,7474477447,7474477474,7474477744,7474744477,7474744747,7474744774,7474747447,7474747474,7474747744,7474774447,7474774474,7474774744,7474777444,7477444477,7477444747,7477444774,7477447447,7477447474,7477447744,7477474447,7477474474,7477474744,7477477444,7477744447,7477744474,7477744744,7477747444,7477774444,7744444777,7744447477,7744447747,7744447774,7744474477,7744474747,7744474774,7744477447,7744477474,7744477744,7744744477,7744744747,7744744774,7744747447,7744747474,7744747744,7744774447,7744774474,7744774744,7744777444,7747444477,7747444747,7747444774,7747447447,7747447474,7747447744,7747474447,7747474474,7747474744,7747477444,7747744447,7747744474,7747744744,7747747444,7747774444,7774444477,7774444747,7774444774,7774447447,7774447474,7774447744,7774474447,7774474474,7774474744,7774477444,7774744447,7774744474,7774744744,7774747444,7774774444,7777444447,7777444474,7777444744,7777447444,7777474444,7777744444};
int main(){
    int n;
    cin>>n;
    for(int i=0;i<350;i++){
        if(ln[i]>=n){
            cout<<ln[i]<<endl;
            return 0;
        }
    }
    return 0;
}
```


---

## 作者：pigstd (赞：1)

很明显，答案的长度(lenans)是一个偶数。若给的数长度(len)是偶数，那么lenans必为len或len+2.否则lenans为len+1

得到了lenans后，就可以用dfs得到答案。

c++代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

string a,ans;
int n,h;

bool check()//判断ans是否可行
{
	int _7=0,_4=0,sum=0;
	for (int i=0;i<h;i++)
	{
		if (ans[i]=='7')_7++;
		else if (ans[i]=='4')_4++;
		else return 0;//如果不是4也不是7，return 0
		sum=sum*10+ans[i]-'0';
	}
	return _7==_4&&sum>=n;
}

void dfs(int k)//dfs
{
	if (k==h)
	{
		if (check())
			{
				for (int i=0;i<h;i++)
					cout<<ans[i];
				exit(0);//因为赋值时是先4再7，所以得到一个答案后可以直接退出程序
			}
		return;
	}
	ans[k]='4';
	dfs(k+1);
	ans[k]='7';
	dfs(k+1);
}

signed main()
{
	cin>>a;//用string读入，再转换成long long
	int len=a.size();
	for (int i=0;i<len;i++)
		n=n*10+a[i]-'0';
	if (len%2==0)
	{
		h=len;
		dfs(0);
		h=len+2;
		dfs(0);
	}
	else
	{
		h=len+1;
		dfs(0);
	}
	return 0;
}
```

---

## 作者：cyrxdzj (赞：0)

### 一、思路

本题可以使用[宽度优先搜索](https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fromtitle=BFS&fromid=542084&fr=aladdin)去做。

我们可以一步步枚举只含有 $4$ 和 $7$ 的数字，每一次增加 $4$ 或 $7$ 作为扩展，直到找到符合要求的数字为止。

本题 $1\le n\le10^9$，并不是很大，但是需要使用 `long long` 数据结构。

### 二、完整代码

```cpp
#include<cstdio>
#include<queue>
using namespace std;
#define int long long//一劳永逸。
int n;
queue<int>num_list;//BFS队列。
bool check(int num)//检查数据是否符合要求。
{
	if(num<n)//太小，不可能。
	{
		return false;
	}
	int temp=num;
	int cnt_4=0,cnt_7=0;
	while(temp)//数数位。
	{
		int digit=temp%10;
		temp/=10;
		if(digit==4)
		{
			cnt_4++;
		}
		else if(digit==7)
		{
			cnt_7++;
		}
		else
		{
			return false;
		}
	}
	if(cnt_4==cnt_7)//4与7的数量一致：
	{
		return true;
	}
	else
	{
		return false;
	}
}
signed main()
{
	scanf("%lld",&n);
	num_list.push(0);//先让0进队，占个位置。
	while(!num_list.empty())
	{
		int num=num_list.front();//取数。
		num_list.pop();//弹出。
		if(check(num))
		{
			printf("%lld\n",num);//输出。
			return 0;//完结撒花！
		}
		num_list.push(num*10+4);
		num_list.push(num*10+7);
		//思考：以上两行是否可以互换？
	}
	return 0;
}

```

### 三、思考题答案

当然不行。因为，如果互换，因为只要 $num\ge0$，就有 $num\times10+4<num\times10+7$，而互换代码就导致输出的数字可能不是最小的，而是第二小的。

### 四、后记

记录：<https://www.luogu.com.cn/record/51569117>。

By [dengzijun](https://www.luogu.com.cn/user/387836)

---

## 作者：yangwenbin (赞：0)

# 题解 CF96B 【Lucky Numbers (easy)】

没认真看过题目的同学请走这里（[传送门](https://www.luogu.com.cn/problem/CF96B)）

这道题就是求一个Lucky Number。

对于Lucky Number的要求是：

```
是只含有 4，7 且 4 的位数等于 7 的位数的数字
```

先看前半句要只有 4 和 7 。很明显就是一个深度优先搜索

再前面一个已有数字的后面加上 4 或 7。

定义前一个为s；

所以 Lucky Number = s * 10 + 4 或 s * 10 + 7。

然后记录位数保证 <= 19

所以可以写出dfs函数：

```
dfs(k+1,s*10+4); 
dfs(k+1,s*10+7); 
```

## BUT

这里要求 4 的个数和 7 的个数要一样多

所以要在原dfs的基础上加上一个对于 4 的个数和 7 的个数 的计数器

只有数值相同时该数字才是 Lucky Number

故更新的dfs函数如下：

```
dfs(k+1,s*10+4,n4+1,n7); 
dfs(k+1,s*10+7,n4,n7+1);
```

最后排序一下，输入要对比的数，然后 while（true） 顺序模拟，寻找第一个大于所要求数的 Lucky Number，退出循环

# code

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll lucky_num[10000050];
ll tot;
void dfs(ll k,ll s,ll n4,ll n7){
	if (s && n4 == n7) lucky_num[++tot]=s; 
	if (k == 19){
		return;
	}
	dfs(k+1,s*10+4,n4+1,n7); 
	dfs(k+1,s*10+7,n4,n7+1); 
}
void add_index(){
	dfs(1,0,0,0); 
	sort(lucky_num+1,lucky_num+tot+1); 
}
int main(){
	add_index();
	ll n;
	scanf("%lld",&n);
	for (ll i = 1; true; ++i){
		if(lucky_num[i] < n){
			continue;
		}
		printf("%lld\n",lucky_num[i]);
		break;
	}
}

```


---

## 作者：学霸壹号 (赞：0)

这道题一看就是01穷举。
原因如下：

- 这里n最大才到$10^9$，也就是说，是$1,000,000,000$，我们枚举每一位是几，最多也就2^10，$1,024$。
- 这里每个数位就两种可能，'$4$'或'$7$'，很明显是01穷举。
---
### 要点
- 为了求位数方便，我们用string来存储，后面也容易用数位做01穷举。
- 由于4和7的数量要相同，如果这个数的数位只有奇数个，那么就很简单：
```
input:
111111111
output:
4444477777
-----v----
(数位+1)/2个4，(数位+1)/2个7。
```
- 由于4和7的数量要相同，如果这个数的数位是偶数个，那么也很简单：
```
如果 这个数大于 7777744444
              -----v----
          size/2个7，size/2个4


     输出444444777777。
        ------v------
      size/2+1个4，size/2+1个7


否则{

      01穷举，看哪种最好，注意边界和check（判断是否为Lucky Numbers）。

      打印结果。
}

结束程序。
```
~~版式总是会出问题，大家凑合看吧~~

---


# Board Moves

## 题目描述

有一个$n×n$的棋盘（$n$为奇数），一开始每个格子中都含有一个数。现在你可以进行以下操作：

一步操作指选定任意格中的恰好一个数，并将其移动到周围的八个格子中之一。也就是说，如果原来格子的坐标是$(i,j)$，那么你可以将这个数移到$(i+1,j)$$(i-1,j)$$(i+1,j+1)$$(i,j+1)$$(i-1,j+1)$$(i+1,j-1)$$(i,j-1)$$(i-1,j-1)$这八个格子中。

当然，你不能把棋子移到棋盘外。允许在一次操作后一个格子里存在多个数。

你的任务是找出操作的最小次数，使得所有的数都在一个方格内。也就是说在$(n^2-1)$个格子内都没有数，而在$1$个格子内有所有的数。

## 样例 #1

### 输入

```
3
1
5
499993```

### 输出

```
0
40
41664916690999888```

# 题解

## 作者：do_while_true (赞：3)

都向最中间去走肯定是最优的，所以我们只需要算出这些人走到中心点 $(\lfloor\frac{n}{2}\rfloor,\lfloor\frac{n}{2}\rfloor)$ 的距离即可。

我们发现，对于紧邻中心点的 $8$ 个点到中心点的最短距离一定为 $1$，然后这个 $9$ 个点外面一圈的的 $12$ 个点（也就是 $n$ 从 $3$ 增加到 $5$ 的时候）到 $8$ 个点的最短距离是 $2$ ，它们只能先走一步到 $8$ 个点任意一点，再走一步到中心点，以此类推。

也就是每当上一个 $n$ 加上一个 $2$ 的时候，相比原来的 $n-2$ 的答案，实际上只加上了最外面一层的步数，而最外面一层的每一点到中心点的步数实际上就是 $1$ 加了几个 $2$ 到的 $n$ （也就是一共从一个点扩展出了多少层）。最外面一层的点很容易看出来是 $4*i-4=4*(i-1)$

所以我们得到递推式，$f_i=f_{i-2}+4*(i-1)*(\lfloor\frac{i}{2}\rfloor)$

其中 $f_1=0$。

[$\mathcal{Code}$](https://codeforces.com/contest/1353/submission/80143867)

---

## 作者：20111019Yu (赞：2)

先看看题 $1\le t \le 200$，$1\le n \le 500$，就可知到，枚举每个点是一定错的，看看标签，数学，论证开始。

## 过程

设 $x$ 为最终到的点的行，$y$ 为最终到的点的列。

设 $x'$ 为另一点的行，$y'$ 为另一点的列。

则点到最终点的步数为 $\max(\lvert x-x' \rvert,\lvert y-y' \rvert)$。

总步数为 $\sum_{i=1}^{n}\sum_{j=1}^{n}\max(\lvert x-x' \rvert,\lvert y-y' \rvert)$。

我们可以发现步数由最终点向周围呈扩散状。

假设将最终点向上移，则会减少 $\sum_{i=1}^{n}\max (x-1,\lvert y-i \rvert)$ 步，并增加 $\sum_{i=1}^{n}\max(n-x,\lvert y-i \rvert)$ 我们可以发现后一项的值都相等，所以我们想要总步数最少，就要使减的尽量多，增加的尽量少我们就可以算出在 $x=n/2+1$ 时，两者趋于平衡。

同理，$y=n/2+1$ 时，两者趋于平衡。

所以最终点在矩阵中心时，总步数最少。

又步数由最终点向周围呈扩散状。

最终的答案就是 $\sum_{i=1}^{n/2}i\cdot i\cdot8$。

这里有的人就已经开始打循环了，但是我们不能仅仅只拘束于这样。

我们将最终答案写成算式，发现可以用[踢三角](https://www.jianshu.com/p/c143b802d3f7)解决。

于是最终的答案就是，$8\cdot \left[(1+n/2\cdot2)\cdot(n/2+1)\cdot(n/2)\right]\div6$。

简简单单的一个 $\mathcal{O}(t)$ 代码。

### code

```cpp
#include <bits/stdc++.h>
#define int unsigned long long int
using namespace std;
int t, n;

signed main(){
    cin >> t;
    while(t--){
        cin >> n;
        cout << 8 * (1 + 2 * (n / 2)) * (n / 2 + 1) * (n / 2) / 6 << endl;
    }
    return 0;
}
```

---

## 作者：皎月半洒花 (赞：1)

讲课的时候偶然发现的一道题。其他题解好麻烦啊！

首先思考:数轴上有一堆点上站着人。他们走到哪个点的路程和是最小的呢？

我们可以通过许多方法证明，应当取中位数。所以我们一定是想走到中央。

我们考虑，走 $\leq$ 一步就能到中央的格子数目是 $9$，而走 $\leq$ 两步就能到中央的格子数是 $21$。

但其实，走两步到中心点其实就是走一步到距离中心 $=$ 一步的 $8$ 个点再走一步而已。

据此我们可以 DP。设 $f_i$ 表示走 $\leqslant i$ 步就能到中心点的点数，那么 $f_0=0$。
$$
f_i=f_{i-1}+((2\times i+1)\times 4-4)\times i
$$

答案最后就是 $f_{\lfloor\frac{n}{2}\rfloor}$。

但其实展开就可以发现，答案就是自然数平方和的 $8$ 倍的第 ${\lfloor\frac{n}{2}\rfloor}$ 项。所以答案应该是：

$$
\dfrac{{\lfloor\frac{n}{2}\rfloor}\times({\lfloor\frac{n}{2}\rfloor}+1)\times (2\times {\lfloor\frac{n}{2}\rfloor})+1}{6}
$$

复杂度 $O(T)$ 而不是 $O(n+T)$。

为了防止爆 `long long` 可以写成 `ans = 1ll * (m + 1) * m / 2ll * (2ll * m + 1) / 3 ;`

---

## 作者：LiJinLin_AFO (赞：0)

# CF1353C 题解
这是一道微模拟。

众所周知，通过贪心策略，我们可以知道，如果这 $n^2$ 个数都汇集到正方形最中间，使用的次数是最少的。因为如果全部来到正方形的比较偏的位置，虽然附近位置的数无需走太多步数，但是有很多距离远的点需要走更多的步数，相比较全到最中间的总步数会更多。再看看题目，保证 $n$ 为奇数，这也有助于我们解题。

不过，每个不同的位置到最中间的次数具体是多少？让我们模拟一下（见下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/axot7w2a.png)

我们会发现，次数为 $1,2,3\cdots$ 的个数呈线性增长。设次数为 $x$，个数为 $y$，则有公式：$y=8x$。

话不多说，直接上代码。温馨提示，答案和枚举的变量都要用长整型，不然会溢出。

```cpp
#include<stdio.h>
int main(){
	int t,n;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		int end=n/2;//范围
		long long ans=0;
		for(long long i=1,quan=8;i<=end;i++,quan+=8) ans+=i*quan;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：_Glassy_Sky_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF1353C)

### 1、写在最最最前面的话：这题不开 long long 连祖宗都见不到！！！

### 2、思路：
首先，这道题目是一道归纳的题目，是绝对不能用暴力的！其次，我们所要求的是操作的最小次数，这就需要思考：到底要让所有数字放进哪一个格子里才能使操作次数最小呢？

答案就是矩阵的正中间。因为假设都放进左上角的格子里，那么右下角的数字就要“不远千里”来到左上角，会大大提高操作次数。而如果是在正中间，四处的数字就可以均匀的移动到这里，使得操作次数最小，题目的数据要求 $n$ 是奇数，刚好让我们更加便利。

下面就要推出公式了：我们可以通过递推的方式来得出。以中心点算起，如果 $n$ 是 $1$，那么答案就是 $0$，于是得出：

```cpp
a[1] = 0;
```
到了 $n$ 为 $3$ 的时候，答案是 $8$。为什么？我们可以把边长为 $3$ 的矩阵看做边长为 $1$ 的矩阵在包上一圈，外面一层每一个格子里的数字都要到中心点来，每个都有一次，共有 $8$ 次，再加上中心点所耗费的 $0$ 次，共是 $8$ 次，$n=5$，$n=7$ 时以此类推。于是得出：

```cpp
a[i] = a[i] + a[i - 1]
```
现在就是要求出 $a[i]$ 是多少，也就是要得出最外面那一圈共要耗费几步才能全部移动到中心点来。首先要求出最外面一层有几个格子：

假设每一边都算，那么共有 $4 \times n$ 条边。但实际上有 $4$ 个点是被重复计算了的。因此真正的个数应该是 $4 \times n-4$ 个点。提取公因数得 $4 \times (n-1)$，这就是一圈的点数。

可是一个点到底要走多少步才能到中心点呢？很简单，我们只需要用 $n$ 减去中心点那一行，再减去上/下半排，也就是除以二，得 $(n-1) \div 2$。

综上所述，一圈所用的总步数是 $4 \times (n-1) \times ((n-1) \div 2)$。由于都是整数类型，可以省略至 $4 \times (n-1) \times (n \div 2)$。

~~于是一个打表的代码就诞生了：~~

```cpp
a[1] = 0;
for(long long i = 3; i <= 500000; i += 2) 
    a[i] = a[i - 2] + (4 * (i - 1) * (i / 2));
```
### 3、完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[500005];//要开long long!!! 
int main()
{
	a[1] = 0;
	for(long long i = 3; i <= 500000; i += 2) 
    	a[i] = a[i - 2] + (4 * (i - 1) * (i / 2));
	int n;
	cin >> n;
	for(int i = 1; i <= n; i ++)
	{
		int x;
		cin >> x;//依次查询 
		cout << a[x] << "\n";//输出 
	}
	return 0;
}

```
如果有看不明白的地方请联系作者，如果有错误的地方也请见谅。

---

## 作者：xxxalq (赞：0)

[洛谷链接](https://www.luogu.com.cn/problem/CF1353C) & [CF链接](http://codeforces.com/problemset/problem/1353/C)

## 思路分析：

首先明确一个点：要让所有点都移到最中间，因为 $n$ 是奇数。

然后进行规律分析：

![](https://cdn.luogu.com.cn/upload/image_hosting/v8gsdhy2.png)

不难发现每次都加 $8$，可以开一个状态数组 $dp[i]$ 表示至少走 $i$ 步才能到达中心点的点数。

$$dp_i=dp_{i-1}+8$$

再开一个前缀和数组 $sum$。

$$sum_i=sum_{i-1}+dp_i$$

可以提前预处理 $dp$ 和 $sum$ 数组，对于每次询问，只需要 $O(1)$ 查询即可。

## 代码：

```cpp
#include<iostream>
#define int long long//不开long long见祖宗
using namespace std;
int T,n,dp[300010],sum[300010];
signed main(){
	for(int i=1;i<250000;i++){
		dp[i]=dp[i-1]+8;//状态转移
		sum[i]=sum[i-1]+i*dp[i];//计算前缀和
	}
	cin>>T;
	while(T--){//T 组数据
		cin>>n;
		cout<<sum[n/2]<<endl;//O(1) 输出
	}
	return 0;
}
```

---

## 作者：ZZQF5677 (赞：0)

### 引子
一定要开 long long 数组！不开 long long 见祖宗！
### 解题思路
这题不可能使用搜索！会T飞的！所以得用巧妙的方法解决。首先，我们要把数移到中间，才是最优的，证明：
![](https://cdn.luogu.com.cn/upload/image_hosting/auim1djm.png)

然后，我们来分析 $n$ 等于多少时，步数分别为多少。因为 $n$ 都是奇数，所以为了节约复杂度循环时只用循环奇数。因为 $n = 1$ 时不用移动，所以先要：

```cpp
a[1] = 0;
```

然后，在得到一串循环~~打表~~代码：

```cpp
for (long long i = 3; i <= 500005; i += 2) {
  a[i] = a[i - 2] + (4 * (i - 1) * (i / 2));  //已知，举证算周长点的个数公式是 (边长 - 1) * 4 ；
}
```

然后解析此串代码，每次的新矩阵总步数都相当于上一个矩阵又围上了一圈新周长，每次的新矩阵的边长就是 $i$，并且推出周长点的个数公式：$4 * (i - 1)$。而又因为无论如何周长上每个点到中点的距离都是 $(\dfrac{i}{2})$。所以，这个新矩阵的总步数就是 $a_i = a_{i-2} + (4 \times (i - 1) \times (i / 2))$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[500005], t, n;
int main() {
  a[1] = 0;
  for (long long i = 3; i <= 500005; i += 2) {
    a[i] = a[i - 2] + (4 * (i - 1) * (i / 2));  //已知，举证算周长公式是 (边长 - 1) * 4 ；
  }
  cin >> t;
  while (t--) {
    cin >> n;
    cout << a[n] << endl;
  }
  return 0;
}
```

---

## 作者：刘健铭 (赞：0)

# Board Moves

题意：有一个 $n×n$ 的矩阵，每个矩阵单元有一个物品，每次操作你可将一个单元里的一个物品移动到该单元周围的八个单元里，问最后只有一个单元有物品的情况下，最少要多少次操作？

分析：我们可以找规律，发现正方形的每一个“圈”到中心的最小距离都是一样的。然后把整个正方形分成八个小三角形+八条线或者直接按照圈来统计。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long n,ans;
int main()
{
    cin>>t;
    while(t--)
    {
        ans=0;
        scanf("%lld",&n);
        for(long long i=2; i<=n/2+1;i++)
            ans+=(i-2)*(i-1);
        ans*=8;
        for(long long i=1;i<=n/2+1;i++)
            ans+=(i-1)*8;
        cout<<ans<<endl;
    }
    return 0;
}
```


---


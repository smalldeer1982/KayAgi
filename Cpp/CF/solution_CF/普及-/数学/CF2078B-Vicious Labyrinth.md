# Vicious Labyrinth

## 题目描述

[Axium Crisis - ak+q](https://youtu.be/1HyuI8Bvnsg?si=6amlU5OPKnJiydZs)

迷宫中有 $n$ 个单元格，其中单元格 $i$（$1 \leq i \leq n$）距离出口有 $n - i$ 公里。特别地，单元格 $n$ 就是出口。注意每个单元格仅与出口相连，无法从其他任何单元格直接到达。

每个单元格最初恰好困住一个人。你希望通过在每个单元格 $i$（$1 \leq i \leq n$）安装传送器来帮助所有人尽可能接近出口，该传送器会将单元格 $i$ 中的人传送到另一个单元格 $a_i$。

迷宫主人发现了你的行为。她觉得有趣，但要求你满足以下条件：
- 每个人都必须恰好使用传送器 $k$ 次。
- 任何单元格的传送器都不能将人传送到自身所在的单元格。形式化地说，对所有 $1 \leq i \leq n$ 有 $a_i \neq i$。

你需要找到一个传送器配置方案，在满足迷宫主人限制条件的前提下，使所有人在使用传送器恰好 $k$ 次后到出口的距离之和最小。若存在多个可行方案，输出任意一个即可。

## 说明/提示

第一个测试用例中，每个人的位置变化如下：
- 传送前：$[1, 2]$
- 第一次传送后：$[2, 1]$

距离之和为 $(2-2) + (2-1) = 1$，这是可能的最小值。

第二个测试用例中，每个人的位置变化如下：
- 传送前：$[1, 2, 3]$
- 第一次传送后：$[2, 3, 2]$
- 第二次传送后：$[3, 2, 3]$

距离之和为 $(3-3) + (3-2) + (3-3) = 1$，这是可能的最小值。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
2 1
3 2```

### 输出

```
2 1
2 3 2```

# 题解

## 作者：gesong (赞：13)

题目传送门：[CF2078B Vicious Labyrinth](https://www.luogu.com.cn/problem/CF2078B)。
# 思路

首先，最小的答案肯定不能为 $0$。

对 $k$ 进行奇偶分类。

当 $k$ 为奇数时，我们只需要将 $1,2,\cdots n-1$ 的连通器全部连向 $n$，然后将 $n$ 连向 $n-1$ 即可，可以证明这样的答案一定为 $1$。

当 $k$ 为偶数时，我们只需要将 $1,2,\cdots n-2$ 的连通器全部连向 $n-1$，然后将 $n-1$ 连向 $n$，将 $n$ 连向 $n-1$ 即可，可以证明这样的答案一定为 $1$。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	char c=getchar();
	int f=1,ans=0;
	while(c<48||c>57) f=(c==45?f=-1:1),c=getchar();
	while(c>=48&&c<=57) ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
	return ans*f;
}
inline void solve(){
	int n=read(),k=read();
	if (k&1^1){
		for (int i=1;i<n-1;i++) printf("%lld ",n-1);
		printf("%lld %lld\n",n,n-1);	
	} 
	else{
		for (int i=1;i<=n-1;i++) printf("%lld ",n);
		printf("%lld\n",n-1);
	}
}
main(){
	int T=read();
	while(T--) solve(); 
    return 0;
}
//Codeforces Round 1008 RP++
//Codeforces Round 1008 RP++
//Codeforces Round 1008 RP++
//Codeforces Round 1008 RP++
//Codeforces Round 1008 RP++
```

---

## 作者：Starry_Sky_135 (赞：2)

#   思路
初步判断和 $k$ 的大小无关，只和 $k$ 的奇偶性有关，因为使用偶数次传送门（即来回传送）相当于保持现状不变。


* $k$ 为奇数时，则将 $1$ 到 $n-1$ 位置的传送门都传送到 $n$ 的位置，将 $n$ 位置的传送门传送到 $n-1$ 的位置。这样第一次传送后，除了最开始在 $n$ 位置的人传送到了 $n-1$ 的位置，其余人全传送到了 $n$ 的位置，此时还剩 $k-1$ 次传送，且 $k-1$ 为偶数，结果保持不变，最优解为 $n-(n-1)=1$。

* $k$ 为偶数时，则将 $1$ 到 $n-2$ 位置的传送门都传送到 $n-1$ 的位置，将 $n-1$ 位置的传送门传送到 $n$ 的位置，将 $n$ 位置的传送门传送到 $n-1$ 的位置。这样第一次传送后，除了原先在 $n-1$ 位置上的人传送到了 $n$ 的位置，其余人全传送到 $n-1$ 的位置；第二次传送后，这些在 $n-1$ 位置上的人全都传送到了 $n$，只有在 $n$ 位置上的人传送到了 $n-1$，此时还剩 $k-2$ 次传送，且 $k-2$ 为偶数，结果保持不变，最优解为 $n-(n-1)=1$。


#   总结

将 $n$ 和 $n-1$ 互相连通，如果 $k$ 是奇数，其他点就和 $n$ 连，否则就和 $n-1$ 连。


#   代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,k;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>k;
		if(k%2==1)
		{
			for(int i=1;i<=n-1;i++)
			    cout<<n<<" ";
			cout<<n-1<<endl;
		}
		else
		{
			for(int i=1;i<=n-2;i++)
			    cout<<n-1<<" ";
			cout<<n<<" "<<n-1<<endl;
		}
	}
	return 0;
}
```

---

## 作者：c_legg (赞：1)

## 题意

有 $n$ 个牢房和 $n$ 个犯人，牢房编号从 $1$ 到 $n$。最开始，每个牢房里都有一个犯人。要构造出一个长为 $n$ 的数组 $a$，使得第 $i$ 个牢房中有一个传送门通往第 $a_i$ 个牢房。每个犯人必须进行 $k$ 次传送并且 $i\neq a_i$。

我们把第 $i$ 个牢房与出口的距离称为 $d_i$，且 $d_i=n-i$，要给出一个 $a$，使每个犯人所在牢房与出口的距离的总和最小。

## 思路

先考虑 $i=n,n-1$ 的情况，最好是令 $a_n=n-1$ 和 $a_{n-1}=n$，这样 $d_n+d_{n-1}$ 就取到了最小值 $1$（无论 $k$ 是几）。

进一步的，我们想到对于其他的 $i$，$a_i\in\{n-1,n\}$，这会使得无论 $k$ 是几，最后所有犯人的所在牢房要么是 $n-1$ 要么是 $n$。

再进一步，可以发现：如果 $k$ 为奇数，$a_i=n$ 的牢房里的犯人最后在第 $n$ 个牢房；如果 $k$ 为偶数，$a_i=n-1$ 的牢房里的犯人最后在第 $n$ 个牢房。就可以构造出符合题意的 $a$。

## 核心代码

``` cpp
a[n]=n-1, a[n-1]=n;
for(int i(1); i<n-1; i++) a[i]=(k&1 ? n : n-1);
```

---

## 作者：AstaVenti_ (赞：1)

# $\mathbf{0x00}$ 启

蒟蒻的第 $\color{red}\mathbf{50}$ 篇题解。

# $\mathbf{0x01}$ 承

$n$ 个房间分别有 $n$ 个人，第 $i$ 个房间有一个可以传送到房间 $a_i$ 的传送门 $(a_i\neq i)$，每个人严格传送 $k$ 次使得最终每个人到房间 $n$ 的距离总和最小，构造出这个数组 $a$。

# $\mathbf{0x02}$ 转

可以发现构造出的序列和 $k$ 的奇偶性有关。

- 如果 $k$ 为奇数，可以构造序列 $n,n,n,\cdots ,n-1$ 使得距离总和为 $1$；
- 如果 $k$ 为偶数，可以构造序列 $n-1,n-1,n-1,\cdots,n,n-1$ 使得距离总和为 $1$。

以上两种情况构造的序列都可以保证在传送 $k$ 次之后有一个人在 $n-1$ 号房间，其他人在 $n$ 好房间。

# $\mathbf{0x03}$ 合


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,n,k;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>k;
		if(k%2){
			for(ll i=1;i<=n-1;i++)
				cout<<n<<" ";
			cout<<n-1<<endl;
		}else{
			for(ll i=1;i<=n-2;i++)
				cout<<n-1<<" ";
			cout<<n<<" "<<n-1<<endl;
		}
	}
}

```

---

## 作者：chenxi2009 (赞：1)

## 思路
$k$ 为奇数时，$\forall i\in[1,n),a_i\leftarrow n,a_n\leftarrow n-1$，这样的话所有初始位置不在 $n$ 的人都可以最终到 $n$，而在 $n$ 的人会走到 $n-1$。

这样一定是最优的吗？更优的情况只能是所有人都能到 $n$，可以这样刻画问题：$n$ 个点，$i$ 向 $a_i$ 连有向边，这是一定会出现环的（图是内向基环树森林），环上的人永远走不到同一个位置，因此**不可能**所有人都到 $n$。所以一个人到 $n-1$ 其他人到终点一定是最优情况。

$k$ 为偶数时，$\forall i\in[1,n-2],a_i\leftarrow n-1,a_{n-1}\leftarrow n,a_n\leftarrow n-1$，这样也可以得到一个人到 $n-1$，其余人到 $n$ 的结果。

时间复杂度 $O(\sum n)$。
## 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int T,n,k,a[300000];
int main(){
	read(T);
	while(T --){
		 read(n,k);
		 if(k & 1){//分奇偶构造方案
		 	for(int i = 1;i < n;i ++) printf("%d ",n);
		 	printf("%d\n",n - 1);
		 }
		 else{
		 	for(int i = 1;i < n - 1;i ++) printf("%d ",n - 1);
		 	printf("%d %d\n",n,n - 1);
		 }
	}
	return 0;
}
```

---

## 作者：Stars_Traveller (赞：0)

## 题解
### 分析
构造题，看起来不难。对 $k$ 进行奇偶讨论。若 $k$ 为偶数，则除了倒数第二个传送门传送到 $n$，其余都传送到 $n-1$。若 $k$ 为奇数，则除了最后一个传送门传送至 $n-1$ 以外，其余都传送至 $n$。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
 
signed main()
{
	int t, n, k;
	for(cin>>t;t;t--)
	{
		cin>>n>>k;
		if(!(!(k&1)))
		{
			for(int i=1;i<=n;i++)
			{
				if(i!=n)cout<<n<<" ";
				else cout<<n-1<<"\n";
			}
		}
		else
		{
			for(int i=1;i<=n;i++)
			{
				if(i!=n-1)cout<<n-1<<" ";
				else cout<<n<<" ";
				if(i==n)cout<<"\n";
			}
		}
	}
}

---

## 作者：mc_xiexie (赞：0)

### 题意

在 $n$ 个点中每个点都有一个人，你可以将他们传送到任意一个点中，但在同一个点你只能传送到同一个点中。例如，你将 $1$ 传送到了 $2$，那么有其他人来到 $1$，就只能到 $2$。问你进行 $k$ 次操作后，每个人与 $n$ 号点的距离最少时，每个点所传送到的点。

### 解法

其实 $k$ 的大小根本就不重要，重要的是奇偶性。我们只要制作一个只有两个节点的环，$k$ 无论是多少，两次操作后都会回到原点。为了方便，我们将那两个点命名为点 $A$ 和 $B$。

在第一次操作时，我们将所有点都连在 $A$。

接下来只要判断 $k-1$ 的奇偶性即可。

当 $k-1$ 为偶数时，所有点都会回到 $A$，此时 $A$ 为 $n$ 时距离和最小。注意，原本在 $n$ 的人得到 $B$，所以 $B$ 为 $n-1$ 最佳。

当 $k-1$ 为奇数时，所有点都会到 $B$，此时 $B$ 为 $n$ 时距离和最小。注意，原本在 $n$ 的人得到 $A$，所以 $A$ 为 $n-1$ 最佳。

### 结论

当 $k$ 为奇数时最优为 $ n,n,\ldots,n ,n-1 $。

当 $k$ 为偶数时最优为 $ n-1,n-1,\ldots,n ,n-1 $。

---


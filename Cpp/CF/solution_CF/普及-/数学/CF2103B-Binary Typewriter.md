# Binary Typewriter

## 题目描述

给定一个长度为 $n$ 的二进制字符串 $s$ 和一个带有两个按钮（0 和 1）的打字机。初始时，你的手指放在按钮 0 上。你可以执行以下两种操作：

1. 按下当前手指所在的按钮。这将打出该按钮上的字符。
2. 将手指移动到另一个按钮。如果手指在按钮 0 上，则移动到按钮 1，反之亦然。

二进制字符串的代价定义为输入整个字符串所需的最少操作次数。

在输入之前，你可以选择最多反转 $s$ 的一个子串 $^{\text{∗}}$。更正式地说，你可以选择两个下标 $1 \le l \le r \le n$，并将子串 $s_{l \ldots r}$ 反转，得到新字符串 $s_1s_2 \ldots s_{l-1}s_rs_{r-1} \ldots s_ls_{r+1} \ldots s_n$。

你的任务是找出在最多进行一次子串反转后，所有可能得到的字符串中的最小可能代价。

$^{\text{∗}}$ 字符串 $a$ 是字符串 $b$ 的子串，当且仅当 $a$ 可以通过从 $b$ 的开头和结尾删除若干（可能为零或全部）字符得到。

## 说明/提示

在第一个测试用例中，我们可以选择不反转任何子串。我们可以执行操作 1 三次来输入 000。

在第二个测试用例中，我们可以选择不反转任何子串。我们可以执行操作 2 将手指移动到按钮 1，然后执行操作 1 三次来输入 111。

在第三个测试用例中，我们可以选择不反转任何子串。我们可以执行操作 1 输入 0，然后执行操作 2 将手指移动到按钮 1，最后执行操作 1 两次输入 11，最终以 4 次操作得到字符串 011。

在第四个测试用例中，我们可以反转子串 $s_{1 \ldots 3}$，得到字符串 001。我们可以执行操作 1 两次输入 00，然后执行操作 2 将手指移动到按钮 1，最后执行操作 1 一次输入 1，最终以 4 次操作得到字符串 001。

在第五个测试用例中，我们可以反转子串 $s_{2 \ldots 3}$，得到字符串 11001。该字符串的代价为 8，操作序列如下：
- 执行操作 2 将手指移动到按钮 1。
- 执行操作 1 两次输入 11。
- 执行操作 2 将手指移动到按钮 0。
- 执行操作 1 两次输入 00。
- 执行操作 2 将手指移动到按钮 1。
- 执行操作 1 一次输入 1。

在第六个测试用例中，我们可以反转子串 $s_{5 \ldots 17}$，得到字符串 1101111011001001000。可以证明，输入该二进制字符串所需的最少操作次数为 29。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
6
3
000
3
111
3
011
3
100
5
10101
19
1101010010011011100```

### 输出

```
3
4
4
4
8
29```

# 题解

## 作者：potata111 (赞：1)

## [_CF2103B_](https://www.luogu.com.cn/problem/CF2103B) Binary Typewriter

### 题意

由题意，一个字符串的**成本**是打出其的操作次数。

而操作次数由两种操作组成，其一是**打字**，其二是**移动**。

前者对成本的贡献固定，为字符串长度 $n$。

而后者可以通过翻转子串来降低对代价的贡献，故我们考虑一个翻转的方式，使得移动手指的**次数更少**，进而使得字符串的**代价更小**。


---


### 分析

设字符串为 $S$。

我们在打出某字符前，做出移动手指的操作，当且仅当**目前**手指所在字符与**将要**打出的字符不相等。

形式化地，移动手指的次数 $t$ 实际为 $S_{i} \neq S_{i - 1}\ (i \in (1, n])$ 中 $i$ 的取值个数。

不难想到，如果翻转的子串是 $[l, r]$，那么对于 $i \in (l, r]$ 且 $S_i \neq S_{i - 1}$ 在翻转前后的取值个数**不变**。

可以影响到的是 $S_l \overset{?}{=} S_{l - 1}$ 和 $S_r \overset{?}{=} S_{r + 1}$ 这两组。

---

### 细节

事实上，我们记 $S = \{i\ |\ i \in (1, n),\ S_{i - 1} \neq S_i \}$ 为 $i$ 的 $t$ 个取值。

且设 $S = \{S_1, S_2 \dots S_{t} \}$ 其影响范围由 $t$ 决定：

- $t \leq 2$，**代价**为 $n + t - 1$；
- $t = 3$，**代价**为 $n + t - 2$；
- $t > 3$，**代价**为 $n + t - 3$。

---

**证明：**

$t = 1$，则翻转对**代价**的影响非负，故取 $0$，代价为 $n$。  

$t = 2$，则有 $S_2 = S_1 + 1$，根据 $S$ 的定义，不难得到 $S_{[{\color{red}{S_1}} - 1, {\color{blue}{S_2}} + 1]}$ 形如 $\{a, {\color{red}{b}}, {\color{blue}{a}}, a\}$。  

也即 $S$ 由若干 $a$ 与 若干个连续的 $b$ 组成。$a, b \in \{\texttt{0},\ \texttt{1}\},\ a \neq b$。  
此时令 $l = S_1;\ r = n$ 将连续的 $b$ 翻转至 $S$ 的末尾。代价为 $n + 1$。

$t = 3$，可以推出 $S$ 形如 $\{{\color{red}a, a, \dots} {\color{blue}\underline{b}, \dots b}, {\color{red}\underline{a}, \dots,} {\color{blue} \underline{b}}\}$：其中 $S$ 中的元素已用下划线标出。

令 $l = S_1;\ r = S_3 - 1$，将会得到总代价为 $n + 1$。

$t > 3$，令 $l = S_1;\ r = S_t - 1$，总代价为 $n + t - 3$。


---

### 实现

题干中表明，你的手最初放在 $\texttt{0}$ 上，故我们令 $S_0 = \texttt{0}$。

先在 $i \in [1, n]$ 中找符合 $S_i \neq S_{i - 1}$ 的取值个数（$t$）。

然后再通过上面的公式计算即可。

```cpp
#include<iostream>
#include<algorithm>
#include<string>

using namespace std;

int q;
int n;
string str;

void solve()
{
	int cnt = 1;

	cin >> n;
	cin >> str;
	str = '0' + str;

	for (int i = 1; i <= n; i++)
		cnt += (str[i] != str[i - 1]);

	int ans;
	if (cnt < 3)
		ans = n + cnt - 1;
	else if (cnt == 3)
		ans = n + cnt - 2;
	else
		ans = n + cnt - 3;

	cout << ans << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> q;

	while (q--)
		solve();

	return 0;
}
```

---


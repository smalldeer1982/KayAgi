# Everyone Loves Tres

## 题目描述

There are 3 heroes and 3 villains, so 6 people in total.



Given a positive integer $ n $ . Find the smallest integer whose decimal representation has length $ n $ and consists only of $ 3 $ s and $ 6 $ s such that it is divisible by both $ 33 $ and $ 66 $ . If no such integer exists, print $ -1 $ .

## 说明/提示

For $ n=1 $ , no such integer exists as neither $ 3 $ nor $ 6 $ is divisible by $ 33 $ .

For $ n=2 $ , $ 66 $ consists only of $ 6 $ s and it is divisible by both $ 33 $ and $ 66 $ .

For $ n=3 $ , no such integer exists. Only $ 363 $ is divisible by $ 33 $ , but it is not divisible by $ 66 $ .

For $ n=4 $ , $ 3366 $ and $ 6666 $ are divisible by both $ 33 $ and $ 66 $ , and $ 3366 $ is the smallest.

## 样例 #1

### 输入

```
6
1
2
3
4
5
7```

### 输出

```
-1
66
-1
3366
36366
3336366```

# 题解

## 作者：Chenyanxi0829 (赞：3)

官方题解好像是找规律，但赛时没细想就直接写 dp 了。
## 题意
$t$ 组询问，每组询问输出最小的只包含 $3$ 和 $6$ 且能被 $33$ 和 $66$ 整除的 $n$ 位数。
## 思路
因为 $66$ 是 $33$ 的倍数，所以可以只满足为 $66$ 的倍数。于是直接 dp，设 $dp_{i,j}$ 表示最小的 $i$ 位数使得其 $\text{}\bmod 66$ 为 $j$，转移就直接往后面加 $3$ 或者 $6$，如果加的是 $x$，那么余数就变成 $(j\times10+x)\bmod 66$。但由于位数较大，只能用字符串存，比较时直接用字典序比较也没问题。由于字符串比较字典序大小是 $O(len)$ 的，所以复杂度 $O(66N^2)$，其中 $N$ 为 $n$ 的最大值。

## 代码
其它实现细节见代码。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 2e5 + 100, mod = 998244353;

int t, n;
string dp[510][66];

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  fill(dp[0], dp[501], "999");
  dp[1][3] = "3", dp[1][6] = "6";
  for (int i = 1; i < 500; i++) {
    for (int k = 0; k < 66; k++) {
      if (dp[i][k] != "999") {
        dp[i + 1][(k * 10 + 3) % 66] = min(dp[i + 1][(k * 10 + 3) % 66], dp[i][k] + '3');
        dp[i + 1][(k * 10 + 6) % 66] = min(dp[i + 1][(k * 10 + 6) % 66], dp[i][k] + '6');
      }
    }
  }
  for (cin >> t; t--;) {
    cin >> n;
    cout << (dp[n][0] == "999" ? "-1" : dp[n][0]) << '\n';
  }
  return 0;
}
```

---

## 作者：Yxy7952 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/CF2035B)

求管理员通过 QwQ。

## 思路

建议看看这道题 [P11229](https://www.luogu.com.cn/problem/P11229)，思路是非常相似的。

也可以顺便光顾一下我的 [题解](https://www.luogu.com.cn/article/j8k8nr84)。

有两种方法求解：
### 1.找规律

1. 当 $n=1$ 时，输出 $-1$。
2. 当 $n=2$ 时，输出 $66$。
3. 当 $n=3$ 时，输出 $-1$。
4. 当 $n=4$ 时，输出 $3366$。
5. 当 $n=5$ 时，输出 $36366$。
6. 当 $n=6$ 时，输出 $333366$。
7. 当 $n=7$ 时，输出 $3336366$。
8. 当 $n=8$ 时，输出 $33333366$。
9. 当 $n=9$ 时，输出 $333336366$。

发现规律了么？

除 $n=1$ 和 $n=3$，若 $n$ 是偶数，输出的数以 $66$ 结尾，前面补 $3$。

而若 $n$ 是奇数，输出的数以 $6366$ 结尾，前面补 $3$。

### 2.数学方法

首先，我们知道 $66$ 是 $33$ 的倍数，如果一个数能被 $66$ 整除，那他一定能被 $33$ 整除。

而我们在小学就做过奥数题，遇到这种题，要把题目给出的数分解质因数。对于这道题，也就是：$66=2\times 3\times 11$。

我们知道：

$2$ 的倍数特征是数的末尾是 $0,2,4,6,8$。显然，数的末尾只能为 $6$。

$3$ 的倍数特征是数的各个数位之和为 $3$ 的倍数。显然，$3$ 和 $6$ 的和都是 $3$ 的倍数。

$11$ 的倍数特征是这个数奇数位的数字之和与偶数位的数字之和的差能被 $11$ 整除，**注意：要使这个数最小**，那我们可以一直补 $3$，这样 $3-3=0$ 也是 $11$ 的倍数。

综合上面的特征，思考一下可以得出：

若 $n$ 是偶数，因为要使末尾为 $6$ 并且奇数位的数字之和与偶数位的数字之和的差为 $0$，所以输出的数以 $66$ 结尾，前面补 $3$。

而若 $n$ 是奇数，那就把它变成偶数，输出的数以 $36366$ 结尾，前面补 $3$。

## 代码

两个方法得出的思路是一样的。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int T,n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n;
		if(n==1||n==3){
			cout<<"-1\n";
			continue;
		}
		if(n%2){
			for(int i=5;i<=n;i++) cout<<"3";
			cout<<"6366\n";
		}
		else{
			for(int i=3;i<=n;i++) cout<<"3";
			cout<<"66\n";
		}
	}
	return 0;
}
```

---

## 作者：Super_Cube (赞：1)

# Solution

能被 $66$ 整除强于被 $33$ 整除，转化为被 $2,3,11$ 整除。数字只有 $3,6$，只用考虑被 $2,11$ 整除。把 $6$ 放在个位，只用考虑被 $11$ 整除。由小学数学知识可知一个数能被 $11$ 整除的判定方法为从个位开始倒着往前数的所有奇数位之和等于偶数位之和。

如果 $n$ 为偶数，让个位与十位填 $6$，剩下的都填 $3$。否则让末尾五位填成 $36366$，前面全填 $3$。注意 $n=1,3$ 时无解。

---

## 作者：Zcras (赞：1)

# 题解：CF2035B Everyone Loves Tres
构造题。
## 题意：
一共 $t$ 组数据，要求对于每个给出的 $n$，构造出一个最小的每位是 $3$ 或 $6$ 的 $n$ 位数，使得其能够被 $66$ 和 $33$ 整除。
## 分析：
~~实际上是打表。~~

观察一下我们容易发现，由于 $33$ 是 $66$ 的因数，所以我们只需要构造能够被 $66$ 整除的数即可。\
我们又可以把问题转为：构造同时被 $6$ 和 $11$ 整除的数。

对于第一个条件，根据小学数学，我们知道被6整除的数满足两个条件：每位和被 $3$ 整除并且是偶数，容易发现说明构造出的数最后一位一定是 $6$。

对于第二个条件，~~根据百度~~，要求位数为奇数的位上的数字和减去位数为偶数的位上的数字和为 $11$ 的倍数。\
由于我们希望将每一位最小化，可以尝试使二者的差为 $0$，先笼统地分析一下，对于一个$n$位数：

注：其实这里知道前面加上两个 $3$ 可以继承答案后使用样例即可。

1. $n$ 为奇数\
考虑从上一个 $n$ 位数继承答案，容易发现如果知道上一个奇数答案，加上两个 $3$ 一定会是下一个奇数的答案。\
$n=1$ 时没有答案，$n=3$ 时神秘地也没有答案，~~但是由于打过表所以知道就这两个不行~~,但是先不要慌，考虑 $3$ 为什么不行，因为前两位为了使答案靠近 $0$ 选择 $66$，而第三位无论选择什么都没有办法，但是尽量让现在的奇位和减偶位和最小更加符合期望，所以暂时选择 $3$（至少如果有解会是本步最优解）。然后到了 $n=5$ 时，前面加上 $36$ 的瓶颈是奇数位和太多，所以第三位最优解一定是 $3$ 而四五位一定是 $36$ ，以后递推（或直接输出）即可。

2. $n$ 位偶数\
一样的继承答案，易得 $n=2$ 时为 $66$（要满足 $6$ 的倍数的性质），遂结束。

最后附代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
int main(){
	cin>>T;
	for(int i=1;i<=T;i++){
		cin>>n;
		if(n==1||n==3){
			cout<<-1<<endl;
		}else if(n%2){
			for(int j=6;j<=n;j++){
				cout<<3;
			}
			cout<<36366<<endl;
//  5之前奇数没有答案故这样可以
		}else{
			for(int j=3;j<=n;j++){
				cout<<3;
			}
			cout<<66<<endl;
		}
	}
	return 0;
} 

```

---

## 作者：Arefa (赞：1)

## 题目分析
我们要找一个长度为 $n$ 的数，这个数能被 $33$ 和 $66$ 整除，且只由 $3$ 和 $6$ 构成。

我们发现我们所要找的数和除数有着共同的因数 $3$，为了更好的思考这道题，我们将 $3$ 这个因数提出来，于是我们得到如下等价问题：

找一个长度为 $n$ 的数，这个数能被 $11$ 和 $22$ 整除，且只由 $1$ 和 $2$ 构成，将这个数乘 $3$ 后输出。

我们又观察到，$22$ 是 $11$ 的两倍，也就是说，只要我们找到的数能被 $11$ 整除的同时，能被 $2$ 整除，那么这个数就可以被 $22$ 整除。

因此我们可以确定这个数的个位只能是 2，现在我们只需使这个数可以被 $11$ 整除。

一个数可以被 $11$ 整除的充要条件是，这个数奇数位的数字之和与偶数位的数字之和的差能被 $11$ 整除。

由于我们要找的是符合条件的最小数，因此我们需要使高位数尽量取 $1$，为此我们可以令奇数位的数字之和与偶数位的数字之和的差取 $0$。

当 $n$ 为偶数时，我们先考虑尽量少的最后的偶数位（使得剩余的位数为偶数），使得这几位的奇数位的数字之和与偶数位的数字之和相等相等，其余位上都取 $1$，这样我们找到的数会是最小的。我们发现，最后两位取 $22$ 时，奇数位的数字之和与偶数位的数字之和相等，此时其它位都取 $1$，将得到我们要求的数。

当 $n$ 为奇数，相同的，我们先考虑尽量少的最后的奇数位，我们发现，最后五位取 $12122$ 时，奇数位的数字之和与偶数位的数字之和相等，此时其它位都取 $1$，将得到我们要求的数。

我们将这个结果乘 $3$： $n$ 为偶数时，最后两位取 $66$，其它位都取 $3$；$n$ 为奇数时，最后五位取 $36366$，其它位都取 $3$。

特别的，当 $n=1$ 或 $n=3$ 时，无解，输出 $-1$。

## 代码
```cpp
#include<iostream>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        if(n%2){                   //如果是奇数
            if(n<5) cout<<"-1\n";
            else{
                for(int i=0;i<n-5;i++) cout<<"3";
                cout<<"36366\n";
            }
        }
        else{                     //如果是偶数
            for(int i=0;i<n-2;i++) cout<<"3";
            cout<<"66\n";
        }
    }
    return 0;
}
```

---

## 作者：Sakura_Emilia (赞：1)

# Solution

**这是一道结论题。**

当 $n$ 为偶数的时候，令最后两位为 $66$，前面的全部为 $3$；当 $n$ 为奇数的时候，最后 $5$ 位为 $36366$，前面的全部为 $3$。

最后只需要来特判一下 $n$ 为 $1$ 或 $3$ 无解的情况即可。

## 结论证明

通过简单的分析即可得到此结论。当 $n$ 为偶数的时候，要使得目标数字为 $66$ 的倍数，就必须要为偶数，最后一位是 $6$，从而至少要凑一对 $66$；当 $n$ 为奇数的时候，同样让末尾凑一对 $66$，但此时前面有奇数个 $3$，无法凑出 $33$ 的倍数。因此拿出 $3$ 位数 $363$ 来凑出 $33$ 的倍数，也就是最后的五位是 $36366$。

# Code

```cpp
#include <bits/stdc++.h>
#define Ciallo main
#define int long long
using namespace std;

int T, n, k;

inline void solve() {
    cin >> n;
    if(n == 1 or n == 3)
        cout << -1 << endl;
    else if(n % 2 == 0) {
        for(int i = 1; i <= n - 2; i++)
            cout << 3;
        cout << 66 << endl;
    } else {
        for(int i = 1; i <= n - 5; i++)
            cout << 3;  
        cout << 36366 << endl;
    }
}

signed Ciallo() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> T;
    while(T--)
        solve();

    return 0;
}
```

---

## 作者：Kratos_Charger (赞：0)

## CF2035B Everyone Loves Tres 题解

### 题目大意

给定 $t$ 组数据，每组数据有一个正整数 $n$，要求构造一个由数字 $3$ 和 $6$ 组成的长度为 $n$ 的整数，该整数需同时满足以下条件：能被 $33$ 和 $66$ 整除。如果无法构造这样的整数，输出 $-1$。

### 思路

为了解决这个问题，首先需要知道能被 $66$ 整除的条 $66$ 可以分解为 $2 \times 3 \times 11$ 。可以推出数字的最后一位必须是 $6$，数字的和必须能被 $3$ 整除，并且将数的奇数位数字之和与偶数位数字之和的差，能被 $11$ 整除。

考虑到输入的 $n$，我们可以得出以下结论：当 $n=1$ 或 $n=3$ 时，由于无法满足条件，直接返回 $-1$。

对于其他 $n$ 的情况，如果 $n$ 是偶数，我们可以构造一个以 $66$ 结尾的数，其余部分用 $3$ 填充；如果 $n$ 是奇数，则最后四位是 $6366$，前面填充  $n−4$ 个 $3$。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int main(){
    scanf("%d",&t);
    for(int i=1;i<=t;i++){
        scanf("%d",&n);
        if(n==1||n==3) printf("-1\n");
        else{
            if(n%2){
                for(int j=1;j<n-3;j++) printf("3");
                printf("6366");
            }
            else{
                for(int j=1;j<n-1;j++) printf("3");
                printf("66");
            }
            cout<<endl;
        }
    }
    return 0;
}

```

---

## 作者：Wei_ch (赞：0)

### 思路
首先，我们先打一下表，找一下规律：

- 当 $ n=1 $ 时，输出 $ -1 $；
- 当 $ n=2 $ 时，输出 $ 66 $；
- 当 $ n=3 $ 时，输出 $ -1 $；
- 当 $ n=4 $ 时，输出 $ 3366 $；
- 当 $ n=5 $ 时，输出 $ 36366 $；
- 当 $ n=6 $ 时，输出 $ 333366 $；
- 当 $ n=7 $ 时，输出 $ 3336366 $；
- 当 $ n=8 $ 时，输出 $ 33333366 $；
  
发现规律了么？除 $ n=1 $ 和 $ n=3 $，若 $ n $ 是偶数，输出的数以 $ 66 $ 结尾，前面补三；而若 $ n $ 是奇数，输出的数以 $ 6366 $ 结尾，前面补三。
### 实现
循环 $ t $ 次，若 $ n \ne 1 $ 且 $ n \ne 3 $，按规律输出，否则特判。
### 代码

```cpp
        #include<bits/stdc++.h>
        using namespace std;
        int main(){
            int t;
            cin>>t;
            while(t--){
                int n;
                cin>>n;
                if(n==1) cout<<-1;
                else if(n==2) cout<<66;
                else if(n==3) cout<<-1;
                else if(n==4) cout<<3366;
                else if(n%2==1){
                    for(int i=1;i<=n-4;i++){
                        cout<<3;
                    }
                    cout<<6366;
                }else{
                    for(int i=1;i<=n-2;i++){
                        cout<<3;
                    }
                    cout<<66;
                }
                cout<<endl;
            }
        }
```
[AC记录](https://codeforces.com/problemset/submission/2035/288932257)

---

## 作者：Misaka屮Mikoto (赞：0)

# CF2035B Everyone Loves Tres
### 题目大意：
给你一个 $n (n\leq 500)$，求出一个最小的由 $3$ 和 $6$ 组成，且能同时被 $33$ 和 $66$ 整除的 $n$ 位数。题目有 $t$ 组数据。

### 思路
题目要求要能同时被 $33$ 和 $66$ 整除，这意味着这个数必然大于两位数且最后两位必然为 $66$。

如果两个能被 $66$ 整除的数相加，那么他们的和一定也能被 $66$ 整除。

显然 $\underbrace{33...33}_{\text {2n个3}}0$ 是能被 $66$ 整除的。

我们已经知道 $n$ 取 $1,2,3,4$ 时的答案。那么对于 $n \geq 5$ 。当 $n$ 为奇数时，在 $3366$ 加上一个$\underbrace{33...33}_{\text {n-3}}000$，当 $n$ 为偶数时，在 $3366$ 加上一个 $\underbrace{33...33}_{\text {n-4}}0000$ 即可。

### 代码如下：
```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    //freopen("read.in","r",stdin);
    int T;
    scanf("%d",&T);
    while(T--){
        int n;
        scanf("%d",&n);
        switch (n)
        {
        case 1:
            printf("-1\n");
            break;
        case 2:
            printf("66\n");
            break;
        case 3:
            printf("-1\n");
            break;
        case 4:
            printf("3366\n");
            break;
        default:
            for(int i=1;i<=n-4;++i)printf("3");
            if(n%2==0)printf("3366\n");
            else printf("6366\n");
            break;
        }

    }
}

```

---

## 作者：wuyouawa (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF2035B)

### 思路

找规律好题。

首先我们可以写一个搜索代码，来暴力计算所有组合，判断是否是 $66$ 的倍数，是就取最小值，用这个代码来找规律。

以下是 $n$ 是 $1$ 到 $10$ 的情况：


```cpp
1：-1，找不到
2：66
3：-1
4：33
5：36366
6：333366
7：3336366
8：33666666
9：333336366
10：3333333366
```

至此，你可以发现，$1$ 和 $3$ 要特判，其它是通过 $n \bmod 2$ 的情况来分类讨论的，具体如下：

- $n \bmod 2 = 0$，是前面 $n-2$ 个 $3$ 和后面 $2$ 个 $6$ 组成的。

- $n \bmod 2 = 1$，是前面 $n-4$ 个 $3$ 和后面的 $6366$ 组成的。

现在我们来证明一下，因为 $66=2 \times 3 \times 11$，所以只要它同时是 $2,3,11$ 的倍数即可。

由于 $3$ 和 $6$ 都是 $3$ 的倍数，所以总体肯定是 $3$ 的倍数。

 $2$ 的倍数只需保证最后一位是 $2$ 的倍数就可以了，也就是说，最后一位必为 $6$。

 $11$ 的倍数就是奇数位之和与偶数位之和的差为 $11$ 的倍数。

经过上面分析，如果 $n \bmod 2=0$，那么上面那种情况差就是 $0$，是 $11$ 的倍数，最后一位也是 $6$。

另外一个同理。

### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int main(){
    cin>>t;
    while(t--)
    {
        cin>>n;
        if(n==1||n==3)
        {
            cout<<"-1\n";
        }//特判
        else
        {
            if(n%2==0)
            {
                for(int i=1;i<=n-2;i++)
                {
                    cout<<3;
                }
                cout<<66;
            }
            else
            {
                for(int i=1;i<=n-4;i++)
                {
                    cout<<3;
                }
                cout<<6366;
            }//规律
            cout<<endl;//多测，记得换行
        }
    }
    return 0;
}
```

### 时间复杂度

时间复杂度为 $O(tn)$，可通过本题。

---

## 作者：_Mortis_ (赞：0)

### [CF2035B Everyone Loves Tres](https://www.luogu.com.cn/problem/CF2035B)

## 题意

求最小的能被 $ 33 $ 和 $ 66 $ 整除，且只由 $ 3 $ 和 $ 6 $ 组成的数。

## 思路1 找规律

搜索打表找规律：

|$ n $|$ ans $|
|:---:|:-----:|
|$ 1 $|$ -1 $|
|$ 2 $|$ 66 $|
|$ 3 $|$ -1 $|
|$ 4 $|$ 3366 $|
|$ 5 $|$ 36366 $|
|$ 6 $|$ 333366 $|
|$ 7 $|$ 3336366 $|
|$ 8 $|$ 33333366 $|
|$ 9 $|$ 333336366 $|
|$ 10 $|$ 3333333366 $|

很容易发现规律：

·若 $ n $ 为奇数，末 $ 4 $ 位为 $ 6366 $，前 $ n-4 $ 位都是 $ 3 $。

·若 $ n $ 为偶数，末 $ 2 $ 位为 $ 66 $，前 $ n-2 $ 位都是 $ 3 $。

## 思路2 数学方法

能被 $ 66 $ 整除的数一定能被 $ 33 $ 整除，只需考虑 $ 66 $。

$ 66=2 \times 3 \times 11 $，所以这个数需要被 $ 2,3,11 $ 整除（整除的性质）。

被 $ 2 $ 整除的数个位只能是 $ 0,2,4,6,8 $，所以最后一位一定是 $ 6 $。

由 $ 3 $ 和 $ 6 $ 组成的数各位数字和一定是 $ 3 $ 的倍数，所以一定能被 $ 3 $ 整除，不用考虑。

能被 $ 11 $ 整除的数具有 奇位和与偶位和差能被 $ 11 $ 整除的性质。

为了使数尽可能小，那么最优方案是前面更多的位都取 $ 3 $（差抵消），最后几位分奇偶考虑。

1.偶数

比较好想，最后一位是 $ 6 $，那么最优方案为最后两位是 $ 6 $，前 $ n-2 $ 位是 $ 3 $。

2.奇数

枚举发现，最后 $ 3 $ 位不可能使奇位和与偶位和差能被 $ 11 $ 整除，而最后 $ 5 $ 位可以，取 $ \color{FF0000}3\color{0000FF}6\color{FF0000}3\color{0000FF}6\color{FF0000}6 $ 即可（$ 3+3+6-6-6 = 0 $）。

最后，**注意特判** $ 1 $ 和 $ 3 $ 输出 $ -1 $。

时间复杂度 $ \Theta(tn) $。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int t,n;
int main(){
	for(scanf("%d",&t);t--;){
		scanf("%d",&n);
		if(n&1){
			if(n==1||n==3)printf("-1\n");
			else{
				for(int i=1;i<=n-5;i++)printf("3");
				printf("36366\n");
			}
		}
		else{
			for(int i=1;i<=n-2;i++)printf("3");
			printf("66\n");
		}
	}
	return 0;
}
```

---


# Packets

## 题目描述

你有$n$个硬币，每个硬币价值都为$1$。

你要把它们分成若干个小包裹，使得在$1$与$n$之间的所有面额都能用这其中某几个小包裹凑出。

每个小包裹只能作为一个整体使用。

请求出最少要分几个包裹。

## 样例 #1

### 输入

```
6
```

### 输出

```
3```

## 样例 #2

### 输入

```
2
```

### 输出

```
2```

# 题解

## 作者：FCB_Yiyang2006✈ (赞：15)

# 这是一道小学生专属题吗？
在二进制中学的砝码称重问题问题

## 原题复现
至少用多少个砝码，可以称出1~1023g的所有重量？

由于上课睡觉，我只记得答案是10个，分别取
#### 1,2,4,8,16,32,64,128,256，512
我终于发现这都是2^n,，恍然大悟，于是用2进制表示分别是（1）₂，（10）₂，（100）₂...(1000000000)₂

### 这样就可以表示出从2进制中的1~1111111111所有数

化成十进制：

（1）₂=1

（1111111111）₂=1023.

这道题就做完了。
## 于是我们根据这道题的过程有了推论
2º，2¹，2²...2ⁿ可以称出1~2ⁿ×2 - 1的所有重量。

有了下面这篇代码
```cpp
#include<bits/stdc++.h>//万能脑袋
using namespace std;
int n,s;//n就是题中的，s表示到1~2ⁿ的和
int main()
{
	cin>>n;
	for(int i=0;;i++)
	{
		s+=pow(2,i);//每次都加
		if(s>=n)//直到大于n为止
		{
			cout<<i+1;
			break;
		}
		
	}
	return 0;
} 
```
其实这道题可以用超出我这个小学生的知识写。

log2可以求出

假设2¹<n<=2²

则log2(n)取整=1

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
    cin>>n;
    printf("%d",(int)log2(n)+1);
    return 0;
}
```
本蒟蒻一向

# 心地善良

这篇题解复制提交可以直接AC.

但是......

# 非紧急情况请勿使用此特殊功能！

（感谢翻译本题的用户，出题人，洛谷管理员，和所有点赞的用户）

---

## 作者：pigstd (赞：6)

本人初中，不会对数，但其他方法又太烦了，于是也放一篇较短，而且不用
pow的代码：

```
#include<bits/stdc++.h>
using namespace std;

long long a,ans;//long long比较安全

int main()
{
	cin>>a;
	while(a)//每次除2，如果a==0就跳出
	{
		a/=2;
		ans++;
	}
	cout<<ans;
	return 0;
}
```

~~求通过~~

---

## 作者：张亦弛 (赞：2)

这道题一看，就知道是一道数学题，找规律，推公式。

我们从n=1开始（后面写的是一种分的方式）：

n  ans

1   1 ：1

2   2 ：1 1

3   2： 1 2 

4   3： 1 2 1

5   3： 1 2 2

6   3： 1 2 3

7   3： 1 2 4

8   4： 1 2 4 1

9   5： 1 2 4 2
      
10  4： 1 2 4 3

11  4： 1 2 4 4

12  4： 1 2 4 5

13  4： 1 2 4 6

14  4： 1 2 4 7

15  4： 1 2 4 8

16  5： 1 2 4 9

......

我们可以明显看出：

答案为1有有1个

答案为2的有2个

答案为3的有4个

答案为4的有8个

这1 2 4 8......不是等比数列嘛，于是我调用了一下马上快忘记的等比数列前k项和公式：Sn=a1×(1-q^k)/(1-q)，然后带入这里的a1=1，q=2，得到：Sn=2^k-1（注意这里的Sn是题目中的n）。因为maxn=1e9，所以解一下不等式2^k-1<=1e9，大概k的枚举范围就是1~31。因为有很多的n对应的答案可能都是同一个ans，所以我们需要判断一下：if(pow(2,k-1)-1<=n&&pow(2,k)-1>n)，就说明n的答案在k-1~k之间，所以ans=k。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=31;i++)
	{
		if(pow(2,i-1)<=n&&pow(2,i)>n)
		{
			printf("%d",i);
			return 0;
		}
	}
}
```

接着，我们可以发现，我们根本不用枚举一遍来一个一个检查，我们可以直接一个算是解决：ans=log2(n)+1。~~（不要问为什么，我也不知道，反正推出来的数据满足这个式子qwq）~~

于是一篇跟a+b problem 一样长的代码就出来啦：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	scanf("%d",&n);
	printf("%d",(int)log2(n)+1);
	return 0;
}
```
~~（其实可以再短一点）~~

---

## 作者：zzhz (赞：1)

这题不难，看下思路   
## 思路：     
每个口袋装的个数规律如下
1个口袋：1个   
2个口袋: 3个   
3个口袋：7个    
4个口袋：15个    
.     
.     
.    
n个口袋：2^n-1个      
根据这条规律 ，可以得出代码      
代码如下：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,j=1,ans=1;
int main(){//主函数
	cin>>n;//输入
	for(int i=1;i<=n;i++){
		j*=2;
		if(j>n)break;//可以装下时结束
		ans++;//口袋个数
	}
	cout<<ans;//输出
	return 0;
}

```


---

## 作者：KagurazakaKano (赞：1)

~~震惊：我竟然写出了12行超短代码！~~

其实这是~~幼儿园~~高中数论题。

楼下题解已经讲的非常清楚了，最优解肯定是每次都使用 $2^n$ 取到，那么可以优化代码如下：

考虑$ans$作为我们的答案，显然$2^{ans} \leq n \leq 2^{ans + 1}$，那么答案$ans = \log_2n + 1$ **（我们要的是上界所以要加一）**。


```
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

int main(){
	int n;
	scanf("%d",&n);
	printf("%d\n",(int)log2(n) + 1);
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)


考虑一个包大小不限，只有选或不选两种操作，那很显然是二进制拆分后，就可以表示成1~n内的所有的数

每个包变成1 2 4 8 16 32 64 128.....
附代码
```cpp
#include <cstdio>
#define ll long long 

int main(){
	ll x;
	//显然用二进制啊 
	scanf("%lld",&x); 
	ll ans = 1; 
	for(ll i = 1;i <= x;i++){
		if(ans <= x && x < ans * 2){
			printf("%lld\n",i);
			break;
		}
		ans *= 2;
	}	
	return 0;
} 
```

附赠一道有趣的题   引自csdn：执迷的信徒

问题描述：有1000桶酒，其中1桶有毒。而一旦吃了，毒性会在1周后发作。
**现在我们用小老鼠做实验，要在1周后找出那桶毒酒，问最少需要多少老鼠。**

 10只老鼠按顺序排好每桶酒按照编号转换成二进制，给相应位置上是1的老鼠喝。最后按死掉的老鼠
是哪几只，然后排成二进制，再转成十进制就是第几桶酒。




---

## 作者：zythonc (赞：0)

# CF1037A Packets
### 先看几个样例

**in>> 65536**

**out>> 1 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768**

**in>> 257**

**out>> 1 1 2 4 8 16 32 64 129**

**显然是用二进制的思想进行一个拆分（或者说分治），
就可以表示成1~n内的所有的数。**

```
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int main()
{
    cin>>n;
    while(n)
    {
        n/=2;
        ans++;
    }
    cout<<ans;
    return 0;
}
```
**~~多说几句~~**

福利[P2320 [HNOI2006]鬼谷子的钱袋](https://www.luogu.org/problem/P2320)
两道题是差不多的，只不过多了输出


---


# Erase First or Second Letter

## 题目描述

You are given a string $ s $ of length $ n $ . Let's define two operations you can apply on the string:

- remove the first character of the string;
- remove the second character of the string.

Your task is to find the number of distinct non-empty strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.

## 说明/提示

In the first test case, we can get the following strings: $ a $ , $ aa $ , $ aaa $ , $ aaaa $ , $ aaaaa $ .

In the third test case, for example, the word $ ba $ can be reached in the following way:

- remove the first character of the current string $ ababa $ , getting $ baba $ ;
- remove the second character of the current string $ baba $ , getting $ bba $ ;
- remove the second character of the current string $ bba $ , getting $ ba $ .

## 样例 #1

### 输入

```
5
5
aaaaa
1
z
5
ababa
14
bcdaaaabcdaaaa
20
abcdefghijklmnopqrst```

### 输出

```
5
1
9
50
210```

# 题解

## 作者：FiraCode (赞：8)

## 思路：
找规律题。

考虑对于 $s1,s2,\dots,s6$ 的情况。

$$s1,s2,s3,s4,s5,s6$$
$$s1,s3,s4,s5,s6$$
$$s2,s3,s4,s5,s6$$
$$s1,s4,s5,s6$$
$$s2,s4,s5,s6$$
$$s3,s4,s5,s6$$
$$s1,s5,s6$$
$$s2,s5,s6$$
$$s3,s5,s6$$
$$s4,s5,s6$$
$$s1,s6$$
$$s2,s6$$
$$s3,s6$$
$$s4,s6$$
$$s5,s6$$
$$s1$$
$$s2$$
$$s3$$
$$s4$$
$$s5$$
$$s6$$

我们发现按长度排序，那么对于长度为 $i$ 的，那么前 $n - i + 1$ 个数是前缀，而后缀都相同，然后每次枚举就行了。

## Code:
```cpp
#include <bits/stdc++.h>

using namespace std;

int T;
int n;
string s;
bool st[200010][30][30];
bool st1[30];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);

	cin >> T;
	while (T--) {
		cin >> n >> s;
		int cnt = 0;
		long long ans = 0;
		for (int i = 0; i < n; ++i) {
			if (!st1[s[i] - 'a']) ++cnt;
			ans = 1ll * ans + 1ll * cnt;
			st1[s[i] - 'a'] = true;
		}
		printf("%lld\n", ans);
		memset(st1, false, sizeof(st1));
	}
	return 0;
}
```

---

## 作者：lutaoquan2012 (赞：5)

## 思路：
- 对于删除第一个字符若干次，实际上就是保留原字符串的任意一个后缀。
- 对于删除第二个字符串若干次，实际上就是保留原字符串的一个后缀加上开头的第一个字符。
- 进行 $a$ 次第二种操作之后再执行一次第一种操作，实际上就是等价于只执行了第一种操作 $a+1$ 次。所以，任意一种操作序列都可以等价为连续操作了第一种之后再连续操作第二种。
- 这样的操作序列会使得原字符串转化为从原串中挑出任意一个位置，以及后面的一个后缀拼接而来。这样对串的个数。这样串的个数才是答案。

## 代码：
```cpp
//
// Created by 55062 on 2024/2/26.
//
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll n,T,cnt[30];
char s[100010];
int main() {
    cin>>T;
    while(T--){
        cin>>n>>(s+1);
        ll ans=0;
        memset(cnt,0,sizeof(cnt));//清空
        for(int i=1;i<=n;i++) cnt[s[i]-'a']++;//统计有多少个字符可以作为前面的第一个字符
        for(int i=n;i>=1;i--){
            ll tmp=0;
            for(int j=0;j<26;j++) tmp+=(cnt[j]>0);//选择可能的前面的第一个字符，加法原理
            ans+=tmp;
            cnt[s[i]-'a']--;//把这个后缀往后移
        }cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：_tourist (赞：5)

### 题目大意
给定一个字符串，你每次能删除其第一个或者第二个字符。请问经过若干次操作一共能得到多少种不同的子串。

### 思路

对于字符串 $s=s_1s_2\dots s_n$,由于每次只能通过删除第一个或者第二个字符来得到新的字符串，则每个能够生成的长度为 $k$ 的字符串 $s'$ 可以这样描述：    
$$s'=s_0|s_{n-k+2}s_{n-k+3}\dots s_n$$

其中 $s_0$ 为前 $n-k+1$ 个字符中的任意一个。因此长度为 $k$ 的字符串个数为前 $n-k+1$ 个字符中不同字母的个数。

由于母串的长度为 $n$，则能够生成的子串的长度为 $1$ 到 $n$ 。因此我们可以枚举每一种可能的子串长度 $i$，将前 $i$ 个字符中不同字母的个数累加到答案中即可。

### 代码
```cpp
#include<iostream>
#include<string.h>
using namespace std;
int n,t;
string s;
int a[100005];
int f[28];

inline int v(char c){return (int)c-96;}
int main()
{
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--)
    {
        memset(f,0,sizeof(f));
        memset(a,0,sizeof(a));
        cin>>n>>s;
        for(int i=0;i<s.length();i++)
        {
            if(i!=0) a[i]=a[i-1];
            if(!f[v(s[i])])
            {
                f[v(s[i])]=1;
                a[i]++;
            }
        }
        int ans=0;
        for(int i=0;i<s.length();i++) ans+=a[i];
        cout<<ans<<endl;
    }
    return 0;
}
```


---

## 作者：hjqhs (赞：4)

由于是删除第一或第二个，所以后缀是不会变的。$pre_i$ 为字符串第 $i$ 位以前的前缀数量。如果当前字符没出现过，则计算其贡献（即 $pre_i \gets pre_i+1$）并标记已出现。可写出如下代码。
```cpp
void solve2() {
	int n, ans = 0; string s; cin >> n >> s; s = ' ' + s;
	vector<int> pre(n + 1); vector<bool> mp(30);
	rep(i, 1, n) {
		pre[i] = pre[i - 1];
		if(!mp[s[i] - 'a']) mp[s[i] - 'a'] = 1, ++ pre[i];
		ans += pre[i];
	}
	cout << ans << '\n';
}
```
但这样写有点冗长（？），考虑用 `unordered_set` 减少码量和内存开销，同时时间复杂度不变。
```cpp
void solve() {
	int n, ans = 0; string s; cin >> n >> s;
	unordered_set<char> st;
	for(char c : s) st.insert(c), ans += st.size();
	cout << ans << '\n';
	return;
}
```

---

## 作者：_luouhgy_ (赞：1)

## 思路：找规律

## 题意：

有一个长度为 $n$ 的字符串 $s$，现在有如下两种操作：

- 删除 $s$ 的第 $1$ 个字符。

- 删除 $s$ 的第 $2$ 个字符。

求经过任意次操作，最终的获得的**非空**字符串的种类数量。

## 思路：

我们发现对于长度为 $i$ 的字符串，前 $n - i + 1$ 个数是前缀，而这些字符串后缀都相同，所以枚举过去就可以了。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
    cin>>t;
    while(t--){
    	int n,flag[30]={0};
	    string s;
	    cin>>n>>s;
	    int sum=0,res=0;
	    for (int i=0;i<n;i++){
	        if(flag[s[i]-'a']==0){//判断 
	        	sum++;
			}
			flag[s[i]-'a']=1;//标记 
	        res+=sum;//累加 
	    }
	    cout<<res<<endl;//多组样例，输出换行
	}
    return 0;//完工 
}
```


---

## 作者：xz001 (赞：1)

我们感性理解题意，我们把字符串当成一只蜈蚣，那么就是说我们可以斩掉蜈蚣的第一节，也可以将其从第二节斩断，我们找一只蜈蚣这样玩一玩，会发现蜈蚣会被斩成尾部的一段加或不加上更靠前的一节（尾部的长度可以为 $0$）。所以问题就变为了对于每个后缀，将其和前面的字符匹配，丢进一个数组里，最后去重即可。

代码如下：

```cpp
#include <bits/stdc++.h>
#define fastcall __attribute__((optimize("-O3")))
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")

using namespace std;

// define
#define re register
#define fi first
#define se second
#define il inline
#define co const
#define ls (u << 1)
#define rs (u << 1 | 1)
#define fup(x, l, r) for (re int x = (l), eNd = (r); x <= eNd; ++ x )
#define fdw(x, r, l) for (re int x = (r), eNd = (l); x >= eNd; -- x )

// typedef
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

// const
const int N = 1e6 + 10, M = 2e6 + 10;
const int INF = 2e9, P = 998244353;
const double eps = 1e-6;


// debug
const bool DeBug = true;
int db_cnt;
il void db() { if (DeBug) puts("--------------"); return; }
il void db(auto a) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << '\n'; return; }
il void db(auto a, auto b) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << '\n'; return; }
il void db(auto a, auto b, auto c) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << '\n'; return; }
il void db(auto a, auto b, auto c, auto d) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << '\n'; return; }
il void db(auto a, auto b, auto c, auto d, auto e) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << ", " << e << '\n'; return; }
il void db(auto *a, auto len) { if (DeBug) { ++ db_cnt; cout << "-- | t" << db_cnt << " : {"; if (!len) cout << "empty";else { cout << a[1]; for (int i = 2; i <= len; ++ i ) cout << ", " << a[i]; } cout << "}\n"; } return; }
il void db(pair<auto, auto> a) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : <" << a.first << ", " << a.second << ">\n"; return; }

// common functions
il int Max(co int a, co int b) { return a > b ? a : b; }
il int Min(co int a, co int b) { return a < b ? a : b; }
il int read() { re int x = 0; re bool f = true; re char c = getchar(); while (c < 48 || c > 57) { (c == '-') ? f = false : 0; c = getchar(); }while (c > 47 && c < 58) x = (x << 3) + (x << 1) + c - 48, c = getchar(); return f ? x : -x; }
il void write(re auto x) { (x < 0) ? putchar('-'), x = -x : 0; (x > 9) ? write(x / 10) : void(); putchar(x % 10 + 48); return; }
il void wel(co auto x) { write(x), putchar('\n'); return; }
il void wel(co auto x, co int y) { write(x), putchar(' '), write(y), putchar('\n'); return; }
il void wel(co auto x, co int y, co int z) { write(x), putchar(' '), write(y), putchar(' '), write(z), putchar('\n'); return; }
il void wsp(co auto x) { write(x), putchar(' '); return; }

int T, n;

unsigned long long c[N], q[N];

bool is[N][27]; 

char s[N];

il unsigned long long query (co int l, co int r) {
	return q[r] - q[l - 1] * c[r - l + 1];
}
 
signed main() {
    scanf("%d", &T);
    c[0] = 1;
    for (re int i = 1; i <= 1e6; ++ i) c[i] = c[i - 1] * 33331;
    while (T -- ) {
    	scanf("%d%s", &n, s + 1);
    	vector <unsigned long long> t;
    	for (re int i = 1; i <= n; ++ i) {
    		for (re int j = 0; j < 26; ++ j) is[i][j] = is[i - 1][j];
    		is[i][s[i] - 'a'] |= true;
		}
		for (re int i = 1; i <= n; ++ i) q[i] = q[i - 1] * 33331 + s[i];
		for (re int i = 1; i <= n + 1; ++ i) {
			re unsigned long long h = query (i, n);
			for (re int j = 0; j < 26; ++ j)
			    if (is[~-i][j]) {
			    	re unsigned long long e = h;
			    	e = (j + 'a') * c[n - i + 1] + h;
			    	t.push_back(e);
				}
			if (h) t.push_back(h);
		}
		sort(t.begin(), t.end());
		t.erase(unique(t.begin(), t.end()), t.end());
		printf("%d\n", (int)t.size());
	}
	return 0;
}


```

---

## 作者：shaoyanxing (赞：0)

# CF1917B
[题目传送门](https://www.luogu.com.cn/problem/CF1917B)
## 题意
给出一个长度为 $n$ 的字符串 $s$，你可以进行若干次以下两种操作：

1、移除字符串 $s$ 中的第一个字符

2、移除字符串 $s$ 中的第二个字符

问题求在经过若干次以上两种中任意一种操作后，不同的非空字符串的数量。

## 思路

我们可以将字符串 $s$ 划成左右两部分，枚举两部分的左右临界点，每次枚举完临界点后，将右半部分看作不进行修改的部分，仅对左半部分进行操作，那么每次枚举临界点后的右半部分均不同。为了保证方案的不同，左半部分仅保留一个字符，那么此时的方案数就是左半部分中包含的不同字母的数量。

使用计数数组 $t_i$ 动态记录不同字符数量，每次枚举分界点后更新前半部分字符种类并记录到答案中即可。
## 详细注释代码
码风丑，勿喷
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t[30]={0};//字符串长度和计数数组t
int main(){
    int T;
    cin>>T;
    for(;T--;){
    	memset(t,0,30);//将计数数组t归零
        string s;
        cin>>n>>s;//输入字符串长度和字符串s
        int cnt=0,ans=0;
        for(int i=1;i<=n;i++){
            t[s[i]-'a']++;
            if(t[s[i]-'a']==1) cnt++;//统计前半部分中包含的不同字母的数量
            res=res+cnt;
        }
        cout<<res<<endl;
    }
    return 0;
}
```

---

## 作者：__HHX__ (赞：0)

# 思路
（不理解的可以通过下面伪代码）

我们已知在进行第 $i$ 次删除操作前，原字符串 $s$ 和删除后字符串 $s'$ 的后 $n - i$ 个字符相同，且 $s'$ 长度为 $n - i + 1$。

即，求第 $i$ 次删除操作前不同 $s'_1$。

我们令 $k = s'_1$。

所以就是求第 $i$ 次删除操作前不同 $k$ 的数量。

所以我们可以将第 $i$ 次操作转换为：
1. 使 $k=s_{i+1}$
2. $k$ 不变

我们先看操作 $2$，我们可以使第 $i$ 次操作后的 $k$ 与当前 $k$ 相等，其原因为我们可以一直使用操作 $2$ 使 $k$ 不变。

我们再看操作 $1$，我们可以使第 $i$ 次操作后的 $k$ 与变化后的 $k$ 相等，其原因为我们可以使用操作 $1$ 后一直使用操作 $2$ 使操作后的 $k$ 不变。

再用一个标记数组辅助，就写完了。
# 代码
```
定义标记数组 f
单次操作：
 清空数组 f
 枚举 i 次删除操作：
  若以前没记录当前前缀：
   记录前缀到 f
   拥有前缀数量加一
  答案加上前缀数量
 输出答案
```

---

## 作者：BugGod (赞：0)

首先我们略微思考，会发现一个长度为 $k$ 的合法字符串一定是这样的形式：$s'=c\ s_{n-k+1}s_{n-k+3}\cdots s_{n}$。

为什么呢？因为每次只可能改变第一个或者第二个，第二个以后的没有改变，每一次不变的字串只会向前推进一个下标，那么最后有 $k-1$ 个字符不会被改变，而前面会剩下一个字符。那么方案数也就是所有前 $n-k$ 个字符中有多少种字符，我们可以开一个 `set` 快速维护。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define mp make_pair
#define fi first
#define se second
void IOS()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
}
void file(string file_name)
{
	freopen((file_name+".in").c_str(),"r",stdin);
	freopen((file_name+".out").c_str(),"w",stdout);
}
int t,n,ans;
string s;
void solve()
{
	ans=0;
	cin>>n>>s;
	set<char>st;
	for(int i=0;i<s.size();i++)
	{
		st.insert(s[i]);
		ans+=st.size();
	}
	cout<<ans<<'\n';
}
signed main()
{
	//IOS();
	//file("");
	cin>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：XYQ_102 (赞：0)

## 题意
给出一个长度为 $n$ 的字符串 $s$，你可以进行若干次以下操作：
- 移除第一个字符
- 移除第二个字符

问：经过若干次操作后，可以获得多少种不同的非空字符串？

## 分析
将字符串划分为前后两部分，枚举两部分的分界点，每次枚举完分界点后，将后半部分视为不进行修改的部分，仅会对前半部分进行操作，那么由于每次枚举的后半部分均不同，为了保证方案的独立性，前半部分仅保留一个字符，那么此时的方案数就是前半部分中包含的不同字母的数量。

使用计数数组动态记录不同字符数量，每次枚举分界点后更新前半部分字符种类并记录到答案中即可。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() 
{
    int T;
    cin>>T;
    while(T--)
    {
    	int n,vis[30]={0};
	    string s;
	    cin>>n>>s;
	    int cnt=0,ans=0;
	    for (int i=0;i < n;i++) 
		{
	        vis[s[i]-'a']++;
	        if(vis[s[i]-'a']==1) cnt++;
	        ans+=cnt;
	    }
	    cout<<ans<<"\n";
	}
    return 0;
}
```

---

## 作者：_wzx (赞：0)

## 思路
枚举字符串的后缀，统计不同的字符，用数组存下来，最后求和即可。


## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 200005
#define endl "\n"
using namespace std;
ll t,n,a[N],vis[N],ans;
char s[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n;
		cin>>s+1;
		memset(a,0,sizeof(a));
		memset(vis,0,sizeof(vis));
		a[1]=ans=0;
		for(int i=1;i<=n;i++){
			a[i]=a[i-1];
			if(vis[s[i]-'a']==0){
				a[i]++;
				vis[s[i]-'a']=1;
				
			}
		}
		for(int i=1;i<=n;i++)
			ans+=a[i];
		cout<<ans<<endl;
	}
}
```


---

## 作者：Spir1t (赞：0)

可以考虑枚举所有的后缀，对于每个后缀统计其不同的字符即可。

具体来说，设字符串 $s$ 的长度为 $n$，我们枚举所有的下标 $i$，看其后缀前面有多少个，统计其中有多少个不同的字符出现过。最终，将所有的不同字符数加起来即可得到答案。

可以用哈希集合实现代码更简单。

---

## 作者：梦应归于何处 (赞：0)

### 题目大意

给你一个字符串，你每次可以擦掉第一个或者第二个字符，现在问你经过若干次操作后，你能得到的不同的非空字符串的个数。

### 思路

这道题我们去枚举可能得到的非空字符串的后缀，然后看这个后缀前面有多少个，不一样的字符即可。

### 代码

~~~cpp
#include <bits/stdc++.h>
#define db double
#define ll long long
#define ex exit(0)
#define endl "\n"
#define inl inline
#define null NULL
#define pll pair<ll,ll>
#define mkp(a,b) make_pair(a,b)
using namespace std;
ll pre[100005];
bool flag[30];
int main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	ll t;
	cin >> t;
	while (t--) {
		ll n;
		cin >> n;
		string s;
		cin >> s;
		memset(pre, 0, sizeof(pre));
		memset(flag, 0, sizeof(flag));
		s = " " + s;
		for (int i = 1; i <= n; i++) {
			pre[i] = pre[i - 1];
			if (!flag[s[i] - 'a']) {
				flag[s[i] - 'a'] = 1;
				pre[i]++;
			}
		}
		ll ans = 0;
		for (int i = n; i >= 1; i--) {
			ans += pre[i];
		}
		cout << ans << endl;
	}
	return 0;
}
~~~

---

## 作者：_little_Cabbage_ (赞：0)

# CF1917B Erase First or Second Letter 题解
~~[博客食用体验更佳](https://www.luogu.com.cn/blog/958804/solution-cf1917b)~~

这是一道贪心题。

我们可以发现，如果一个字符从来没有出现过，但是他出现了，我们就可以给总的没出现过的字符个数加一，然后每一次答案都加上没出现过的字符个数就好了。

我么可以考虑用 STL 中的 map 来标记哪个字符没出现过。

但是一定要注意多测清空。

所以我直接把 map 开在了多测的里面。

AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		map<char,int>mp;
		int len;
		scanf("%d",&len);
		string s;
		cin>>s;
		int pl=0,mi=0;
		for(int i=0;i<len;i++)
		{
			if(mp[s[i]]==0)
			{
				pl++;
			}
			mi+=pl;
			mp[s[i]]=1;
		}
		printf("%d\n",mi);
	}
}
```
[AC 记录](https://codeforces.com/contest/1917/submission/240674160)

---


# Hexadecimal's Numbers

## 题目描述

One beautiful July morning a terrible thing happened in Mainframe: a mean virus Megabyte somehow got access to the memory of his not less mean sister Hexadecimal. He loaded there a huge amount of $ n $ different natural numbers from 1 to $ n $ to obtain total control over her energy.

But his plan failed. The reason for this was very simple: Hexadecimal didn't perceive any information, apart from numbers written in binary format. This means that if a number in a decimal representation contained characters apart from 0 and 1, it was not stored in the memory. Now Megabyte wants to know, how many numbers were loaded successfully.

## 说明/提示

For $ n $ = 10 the answer includes numbers 1 and 10.

## 样例 #1

### 输入

```
10
```

### 输出

```
2```

# 题解

## 作者：char32_t (赞：16)

# 题解 CF9C 【Hexadecimal's Numbers】
------------
题意：输入n，输出1-n的自然数中各数位只包含0和1的数的个数（即形式是二进制数的个数）。

分析：二进制型的数均为$n*10$或$n*10+1$的形式，所以我们只要找出这两种类型的数就可以了。

$Code_1$：
```cpp
#include<cstdio>
int n;
int count=0;//计数器 
int binary(int m) {//找出二进制型的数 
	if(m>n) return 0;//超过范围及时退出 
	else count++;
	binary(m*10);//找n*10型的二进制型数 
	binary(m*10+1);//找n*10+1型的二进制型数 
}
int main() {
	scanf("%d", &n);//输入n 
	binary(1);//从1开始找 
	printf("%d", count);//输出结果 
	return 0;
}
```

### ~~福利~~
其实也可以打表。$10^9$内共有$512$个二进制型的数。

~~打表就没什么好说的了~~

$Code_2$：
```cpp
#include<cstdio>
const int ans[]= {1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000,10001,10010,10011,10100,10101,10110,10111,11000,11001,11010,11011,11100,11101,11110,11111,100000,100001,100010,100011,100100,100101,100110,100111,101000,101001,101010,101011,101100,101101,101110,101111,110000,110001,110010,110011,110100,110101,110110,110111,111000,111001,111010,111011,111100,111101,111110,111111,1000000,1000001,1000010,1000011,1000100,1000101,1000110,1000111,1001000,1001001,1001010,1001011,1001100,1001101,1001110,1001111,1010000,1010001,1010010,1010011,1010100,1010101,1010110,1010111,1011000,1011001,1011010,1011011,1011100,1011101,1011110,1011111,1100000,1100001,1100010,1100011,1100100,1100101,1100110,1100111,1101000,1101001,1101010,1101011,1101100,1101101,1101110,1101111,1110000,1110001,1110010,1110011,1110100,1110101,1110110,1110111,1111000,1111001,1111010,1111011,1111100,1111101,1111110,1111111,10000000,10000001,10000010,10000011,10000100,10000101,10000110,10000111,10001000,10001001,10001010,10001011,10001100,10001101,10001110,10001111,10010000,10010001,10010010,10010011,10010100,10010101,10010110,10010111,10011000,10011001,10011010,10011011,10011100,10011101,10011110,10011111,10100000,10100001,10100010,10100011,10100100,10100101,10100110,10100111,10101000,10101001,10101010,10101011,10101100,10101101,10101110,10101111,10110000,10110001,10110010,10110011,10110100,10110101,10110110,10110111,10111000,10111001,10111010,10111011,10111100,10111101,10111110,10111111,11000000,11000001,11000010,11000011,11000100,11000101,11000110,11000111,11001000,11001001,11001010,11001011,11001100,11001101,11001110,11001111,11010000,11010001,11010010,11010011,11010100,11010101,11010110,11010111,11011000,11011001,11011010,11011011,11011100,11011101,11011110,11011111,11100000,11100001,11100010,11100011,11100100,11100101,11100110,11100111,11101000,11101001,11101010,11101011,11101100,11101101,11101110,11101111,11110000,11110001,11110010,11110011,11110100,11110101,11110110,11110111,11111000,11111001,11111010,11111011,11111100,11111101,11111110,11111111,100000000,100000001,100000010,100000011,100000100,100000101,100000110,100000111,100001000,100001001,100001010,100001011,100001100,100001101,100001110,100001111,100010000,100010001,100010010,100010011,100010100,100010101,100010110,100010111,100011000,100011001,100011010,100011011,100011100,100011101,100011110,100011111,100100000,100100001,100100010,100100011,100100100,100100101,100100110,100100111,100101000,100101001,100101010,100101011,100101100,100101101,100101110,100101111,100110000,100110001,100110010,100110011,100110100,100110101,100110110,100110111,100111000,100111001,100111010,100111011,100111100,100111101,100111110,100111111,101000000,101000001,101000010,101000011,101000100,101000101,101000110,101000111,101001000,101001001,101001010,101001011,101001100,101001101,101001110,101001111,101010000,101010001,101010010,101010011,101010100,101010101,101010110,101010111,101011000,101011001,101011010,101011011,101011100,101011101,101011110,101011111,101100000,101100001,101100010,101100011,101100100,101100101,101100110,101100111,101101000,101101001,101101010,101101011,101101100,101101101,101101110,101101111,101110000,101110001,101110010,101110011,101110100,101110101,101110110,101110111,101111000,101111001,101111010,101111011,101111100,101111101,101111110,101111111,110000000,110000001,110000010,110000011,110000100,110000101,110000110,110000111,110001000,110001001,110001010,110001011,110001100,110001101,110001110,110001111,110010000,110010001,110010010,110010011,110010100,110010101,110010110,110010111,110011000,110011001,110011010,110011011,110011100,110011101,110011110,110011111,110100000,110100001,110100010,110100011,110100100,110100101,110100110,110100111,110101000,110101001,110101010,110101011,110101100,110101101,110101110,110101111,110110000,110110001,110110010,110110011,110110100,110110101,110110110,110110111,110111000,110111001,110111010,110111011,110111100,110111101,110111110,110111111,111000000,111000001,111000010,111000011,111000100,111000101,111000110,111000111,111001000,111001001,111001010,111001011,111001100,111001101,111001110,111001111,111010000,111010001,111010010,111010011,111010100,111010101,111010110,111010111,111011000,111011001,111011010,111011011,111011100,111011101,111011110,111011111,111100000,111100001,111100010,111100011,111100100,111100101,111100110,111100111,111101000,111101001,111101010,111101011,111101100,111101101,111101110,111101111,111110000,111110001,111110010,111110011,111110100,111110101,111110110,111110111,111111000,111111001,111111010,111111011,111111100,111111101,111111110,111111111,1000000000};
int main() {
	int a;
	scanf("%d", &a);
	for(int i=0; i<512; i++)
		if(ans[i]>a) {
			printf("%d", i);
			break;
		}
	return 0;
}
```

---

## 作者：test_check (赞：5)

[$\huge CF9C  \ Hexadecimal's \  Numbers$](https://www.luogu.org/problem/CF9C)   
一道$\small\colorbox{orange}{\color{white}\text{普及-}}$的题目，不是很难，讲快点$(QAQ)$     
本题解主要思路：$dfs$($dfs$大法好！)

------------
因为题目要求输出$1-n$的自然数中各数位只包含$0$和$1$的数的个数,我们知道，符合各数位只包含$0$和$1$的最小数是几？当然是$1$啦，这不是明摆着的吗。所以，我们的```dfs```就应该从$1$开始搜索。   
我们还可以想到，由于自然数中各数位只包含$0$和$1$，所以，我们可以这样来递归调用下一层。
```cpp
dfs(cur*10+1);  
dfs(cur*10);



dfs(1)    //在int main()中
```
这样的递归调用是一定正确的，为什么呢？一起来看，举一个简单的例子，当$cur==1$时，将会调用```dfs(11)```和```dfs(10)```,而这两个数都是符合题意的，依此类推，每一层的调用自然是正确的了。   
那递归调用的边界是什么呢？当热是```if(cur>n) return;```如果$cur$都$>n$了，那递归还有什么意义呢，所以当然要$return$.而其他的情况只要计数器$ans++$就可以了。
给出部分代码：
```cpp
void dfs(int cur)
{
    if(cur>n) return;  //递归边界，return
    else ++ans;  //计数器++
    dfs(cur*10+1);  //递归调用
    dfs(cur*10);  //继续递归调用
}
```

------------
本文章大致内容$OK$了。接下来给出完整代码$↓↓↓$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
inline int read()  //我喜欢快读
{
     int x=0,f=1;char ch=getchar();
     while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
     while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
     return x*f;
}
void dfs(int cur)
{
    if(cur>n) return;
    else ++ans;
    dfs(cur*10+1);
    dfs(cur*10);
}
int main()
{
    n=read();
    dfs(1);
    printf("%d",ans);  //输出ans的值
    return 0;
}
```

---

## 作者：damage (赞：3)

# 题解

### 注：以下$lg$底数均为$10$，就是数学里的常用对数

### 方法一

直接膜你

从$1$到$n$开始枚举，每个数字判断的复杂度是$O(lg\ n)$，总复杂度是$O(nlg\ n)$

有点卡常数，所以：

### 方法二

$dfs$大发好！

直接$dfs$，最后相当于一个$lg\ n$元$01$集合$S$，每个元素$a_{i}\in{S}$，若$a_{i}=1$相当于这个数字有$10^{i-1}$，所以$dfs$可以排除掉许多无用决策

时间复杂度$O(2^{lg\ n})$，其实就等于$O(\sqrt[log_{2}\ 10]{n})$，竟然比$O(\sqrt[3]{n})$还要小~~（比分块还快）~~

每次确定下一个决策只有两个分支，因为数字里只能有$0$或者$1$所以就是$10x$和$10x+1$

#### 代码

~~比膜你不知道短了多少的代码~~

```cpp
#include<stdio.h>
int n,res;
void dfs(int x)
{
    if(x>n) return ; //大于n就结束
    ++res; //累加答案
    dfs(x*10);
    dfs(x*10+1); //向下扩展
    return ;
}
int main()
{
    scanf("%d",&n);
    dfs(1); //从第一个成立的数字1开始
    printf("%d\n",res);
    return 0;
}
```

### 方法三

注意到$dfs$有可能会爆栈啊~~还慢的要命~~，所以下面介绍一种$O(lg\ n)$的算法（不考虑高精度）

其实可以简化一下，从[方法二]就可以看出来，其实当$n$在第$i$位（从右往左）大于等于$1$时，相当于答案就会增加$2^{i-1}$（可以联合子集个数想一想）。

> 注意：当这一位为$0$但是这位左边（更高位）有大于$1$的数字时，就要把这个数字看成$1$（所以我用的是字符串处理）

最后预处理一下$2$的幂，就可以$O(lg\ n)\approx{O(1)}$

```python```版本是正解（因为大数据要高精），虽然常数比较大，但是$10^{10^{6}}$应该还是可以轻松过的

#### 代码

（我用的是```C++```）

```cpp
#include<string>
#include<iostream>
using namespace std;
int n,two[20],res,sized,digit;
string s;
bool flag;
int main()
{
    ios::sync_with_stdio(false);
    two[0]=1;
    for(register int i=1;i<11;++i) two[i]=two[i-1]<<1; //预处理2的幂
    cin>>s;
    sized=s.size();
    digit=sized-1; //当前位数
    for(register int i=0;i<sized;--digit,++i)
    {
        if(s[i]>49) flag=true; //如果有大于1的数字后面的0等于1
        if(s[i]>48||flag) res+=two[digit]; //符合要求就累加答案
    }
    cout<<res<<endl;
    return 0;
}
```

---

## 作者：BBD186587 (赞：2)

## 十重循环，暴力判断 ##
思路：直接十重循环，生成所有可能的数，再判断是否在区间内

上代码~
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100],ans,n;
int pow_(int a,int b)
{
    int s=1;
    for(int i=1;i<=b;i++) s*=a;
    return s;
}//手写pow,避免鬼畜
int main()
{
	scanf("%d",&n);
	for(a[1]=0;a[1]<=1;a[1]++)
		for(a[2]=0;a[2]<=1;a[2]++)
			for(a[3]=0;a[3]<=1;a[3]++)
				for(a[4]=0;a[4]<=1;a[4]++)
					for(a[5]=0;a[5]<=1;a[5]++)
						for(a[6]=0;a[6]<=1;a[6]++)
							for(a[7]=0;a[7]<=1;a[7]++)
								for(a[8]=0;a[8]<=1;a[8]++)
									for(a[9]=0;a[9]<=1;a[9]++)
										for(a[10]=0;a[10]<=1;a[10]++)//十重循环，暴力判断
										{
											int s=0;
											for(int i=1;i<=10;i++)
												s+=a[i]*pow_(10,10-i);
											if(s>=1&&s<=n) ans++;
										}
	printf("%d",ans);
	return 0;
}
```
完结撒花~

---

## 作者：HiroshiRealm (赞：2)

这题本蒟蒻也是和各位大佬同样深受#15的困扰，不管本蒟蒻怎么优化都TLE了，由此我决定采用队列（~~抑制住打表的冲动~~）的方法。没错，就是队列 。



此题我们可以参考一下超级素数的做法（充一下大佬（~~滑稽~~）），采用一个队列来存储每次求得的这个什么什么number（~~英语不好~~）。队头既是用来求数，也是判断的条件（因为队尾不好判断），至于怎么求，因为是有0和1组成，所以每一个大的满足条件的数可以转化为一个较小的数*10+0或1


上代码
```
#include<bits/stdc++.h>
using namespace std;
int a,sum,num[100000]={0,1},head=1,tail=1;
int init(int x){//数组赋值，顺便求答案
	while(num[head]<=x){
		num[++tail]=num[head]*10;
		num[++tail]=num[head]*10+1;
		head++;
	}
	return head-1;
}
int main()
{
	scanf("%d",&a);
	printf("%d",init(a));//主程序直接输入输出就可以了
 return 0;
 }

```

---

## 作者：lixiao189 (赞：1)

## 思路
这个题目据可以有两种思路，一种是递归构造答案的方法，一种是使用公式计算的的方法。第一种方法就是楼下个位大佬的做法，就是对于1，我们如果要的到后面的两组答案，一种是对这个数乘10，或是乘10后加一，这样就得到了新的两种答案，我们在对新的答案这样递归求解下去，直到大于输入的数 $ n $ 为止，这样我们在一边递归的时候一边记录的到的新数的数量，就可以解决这个问题了。

但是其实还有另一种方法，这个方法稍微慢一点，就是我们先求出不大于 $ n $ 的一个最大的只由 `0,1` 组成的数我们要怎么求这个数呢。废话不说上代码：

```cpp
scanf("%lld",& n);
	//将这个数的每一位分解
	while(n!=0){
		num.push_back(n%10);
		n/=10;
	}

	for(int i=num.size()-1;i>=0;i--){
		if(num[i]>1) //如果这个位子上的数大于1了,那么我们要求的那个数之后的几位就全是1了
			flag=true;
		if(flag)
			maxn.push_back(1);
		else{ //由于不能让所求的数超过n所以为了让这个数尽量大,如果是1的地方就是1,不是1的地方就是0,这样所求的数就不会超过原来的数
			if(num[i]==1)
				maxn.push_back(1);
			else
				maxn.push_back(0);
		}
	}
```

假如我们有一个10013027那么我们之后得到的数就是10011111，之后我们发现我们只需要对这个数进行一些1变成0或0变成1之类或者什么操作都不做的操作就可以得到我们想要的答案。对于例子中得到的数10011111，假如我们让第一个1变成0，那么后面的数不管进行什么操作的到的数一定是小于例子中的得到的数的，所以我们假设当前位置为i那么我们就可以用`2^(len-i)`去更新答案 `len` 就是那个得到的数的长度。

> Ps:这个算法这么解释有些地方其实是不对的，但是这些地方难以用言语解释清楚，所以你们可以自己去证明，但是这个思路的大体方向就是这样没错的。如果你想让程序跑得更快，可以用快速幂来优化。

## 完整代码：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

bool flag=false;
long long n;
vector <int> num,maxn; //注意:maxn是反过来存的

long long power(long long x,long long y)
{
	long long ans=1,base=x;
	while(y!=0){
		if(y&1)
			ans=ans*base;
		base=base*base;
		y>>=1;
	}
	return ans;
}

int main()
{
	scanf("%lld",& n);
	while(n!=0){
		num.push_back(n%10);
		n/=10;
	}

	for(int i=num.size()-1;i>=0;i--){
		if(num[i]>1)
			flag=true;
		if(flag)
			maxn.push_back(1);
		else{
			if(num[i]==1)
				maxn.push_back(1);
			else
				maxn.push_back(0);
		}
	}

	long long ans=0;
	for(register int i=0;i<(int)maxn.size();i++){
		if(maxn[i]==1){
			ans+=power(2,(int)maxn.size()-1-i);
		}
	}

	printf("%lld\n",ans);

	return 0;
}
```

---

## 作者：Loser_King (赞：1)

## BFS\DFS 入门好题

~~打表的我很佩服~~

我们知道，对于任意一个满足条件的数，其个位只有$0$和$1$。

即对于任一答案$n$，总有：

⒈$\;\;\;$$n=k*10$（即个位为$0$）

⒉$\;\;\;$$n=k*10+1$（即个位为$1$）

（其中$k$为满足条件的数）

这样，我们可以简单地打出DFS$\texttt{Code}$：

```
#include<cstdio>
int n,res;//res记录答案
void dfs(int x){
    if(x>n)return;//太大退出
    ++res;
    dfs(x*10);//此位为0
    dfs(x*10+1);//此位为1
}
int main(){
    scanf("%d",&n);
    dfs(1);//最小是一
    printf("%d",res);
}
```
BFS的思想：

⒈$\;\;\;$首先，我们需要一个优先队列。

```priority_queue<long long,vector<long long>,greater<long long> >q;```

**注意：要用$long\;long$，因为在$n=_{10}9$时队列里的元素会超过MAX_INT**

其实写这么长一串是为了方便的取出最小元素。

⒉$\;\;\;$初始化。
```
	scanf("%d",&n);
	q.push(1);//把最小的元素压入队列
```
⒊$\;\;\;$BFS主过程。
```
	while(1){
		long long top=q.top();q.pop();//取出最小元素
		if(top>n)break;//如果连最小元素都比n大，结束并输出答案
		ans++;q.push(top*10);q.push(top*10+1);
               //答案加一并扩展节点
	}
```
完整$\color{blue}\texttt{Code:}$
```
#include<bits/stdc++.h>
using namespace std;
long long n,ans;
priority_queue<long long,vector<long long>,greater<long long> >q;
int main(){
	scanf("%d",&n);
	q.push(1);
	while(1){
		long long top=q.top();q.pop();
		if(top>n)break;
		ans++;q.push(top*10);q.push(top*10+1);
	}
	printf("%d",ans);
}
```

---

## 作者：北雪2009 (赞：0)

~~这题我觉得已经不是入门题了，应该是有人故意判分的。~~   
好啦，先不说这些啦。这道题确确实实要用递归。   
我们先按照题目举一些栗子：像1，10,100,1000等这些数都是符合题目要求的。   
这时我们发现：符合要求的数就是二进制数！！！   
经过~~大量的计算~~我们发现，二进制数都是像x（不定数或未知数）* 10或x* 10+1的数。   
这时，公式出来啦！！！   
接下来是制作过程：   
首先先输入，然后递归开始。（第一次输入1）在递归时，只需要判断输进来的数x是否大于n，如果大了，就结束递归，否则，计数器就加一。然后再将x* 10与x* 10+1分别输进接下来的两个递归中（顺序嘛……为了防抄袭，你自己想！！！）。最后输出计数器即可！   
（为了响应洛谷的“不要抄袭”的口号，程序嘛……就不写出来了！！！）

---

## 作者：shenzuxin (赞：0)

###### 这道题的意思是输出1~n中只由0或1组成的数的个数
## 下面是一种very easy的解法（大佬请无视）
# 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int js(int n){
    int a1,b1,c1,d1,e1,f1,h1,g1,i1,a,b,c,d,e,f,g,h,i,t=0;
    for(a=0;a<=1;a++){//枚举所有由0、1组成的数
        a1=a;
        for(b=0;b<=1;b++){
            b1=a1*10+b;
            for(c=0;c<=1;c++){
                c1=b1*10+c;
                for(d=0;d<=1;d++){
                    d1=c1*10+d;
                    for(e=0;e<=1;e++){
                        e1=d1*10+e;
                        for(f=0;f<=1;f++){
                            f1=e1*10+f;
                            for(g=0;g<=1;g++){
                                g1=f1*10+g;
                                for(h=0;h<=1;h++){
                                    h1=g1*10+h;
                                    for(i=0;i<=1;i++){
                                        i1=h1*10+i;
                                        if(i1<=n)t++;else return t;//计算数目，因为这些数都是升序排列，所以可以在大于n时退出。
                                    }    
                                }
                            }
                        }
                    }
                }
            }
        }
    }//强迫症忍不了
}
int main(){
    int n,s[1000],x=0,t=0;
    cin>>n;
    t=js(n);
    if(n>=1000000000)cout<<t;else cout<<t-1;//补上最后一个数（有一个数据点是1000000000），输出
}
```
## 九重循环完成   ~~（打的真累）~~

---

## 作者：LevenKoko (赞：0)

Hexadecimal's Numbers

连续做了那么多道搜索题后看到这题，~~激动到哭~~（终于有一道简单的了）

```
PS:
0*10=0（不算，因为从1开始）
0*10+1=1；
1*10=10；
1*10+1=11；
10*10=100；
10*10+1=101；
11*10=110；
11*10+1=111
。
。
。
。
。
。
上代码：
#include<iostream>
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

inline int read()
{
	char chr=getchar();
	int f=1,ans=0;
	while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr))  {ans=ans*10;ans+=chr-'0';chr=getchar();}
	return ans*f;

}//哪怕只有一个数据，也要坚定的使用快读；
int n;
int ans=0;
void dfs(int x)
{
	if(x>n) return;//如果太大了就直接return；
	ans++;//搜到一个数后答案总数+1
	if(x!=0)
		dfs(x*10);
	dfs(x*10+1);这样可以使数字中只有0和1
}

int main()
{
	n=read(;
	dfs(0);
	ans--;//由于某个数（自己想想看（~~其实是我自己懒得看~~））不能记进去
	cout<<ans;
	return 0;
}

```

---

## 作者：Andysun06 (赞：0)

# 题解 CF9C
------------
# 看没有pascal的题解，趁机来一发———
## 一道水题（不过第15个测试点有坑！）
## 打表直接过~~~
## 不说太多，上代码：
    var i,n,m:int64;
    x:array[1..512]of longint=(1,10,11,100,101,110,111,1000,1001,
    1010,1011,1100,1101,1110,1111,10000,10001,10010,
    10011,10100,10101,10110,10111,11000,11001,11010,
    11011,11100,11101,11110,11111,100000,100001,100010,100011,
    100100,100101,100110,100111,101000,101001,101010,101011,101100,
    101101,101110,101111,110000,110001,110010,110011,110100,110101,
    110110,110111,111000,111001,111010,111011,111100,111101,111110,
    111111,1000000,1000001,1000010,1000011,1000100,1000101,
    1000110,1000111,1001000,1001001,1001010,1001011,1001100,1001101,
    1001110,1001111,1010000,1010001,1010010,1010011,1010100,1010101,
    1010110,1010111,1011000,1011001,1011010,
    1011011,1011100,1011101,1011110,1011111,1100000,1100001,1100010,
    1100011,1100100,1100101,1100110,1100111,1101000,1101001,1101010,
    1101011,1101100,1101101,1101110,1101111,1110000,1110001,1110010,
    1110011,
    1110100,1110101,1110110,1110111,1111000,1111001,
    1111010,1111011,1111100,1111101,1111110,1111111,
    10000000,10000001,10000010,10000011,10000100,10000101,
    10000110,10000111,10001000,10001001,10001010,10001011,
    10001100,10001101,10001110,10001111,10010000,10010001,
    10010010,10010011,10010100,10010101,10010110,10010111,
    10011000,10011001,10011010,10011011,10011100,10011101,
    10011110,10011111,10100000,10100001,
    10100010,10100011,10100100,10100101,10100110,10100111,
    10101000,10101001,10101010,10101011,10101100,10101101,
    10101110,10101111,10110000,10110001,10110010,10110011,
    10110100,10110101,10110110,10110111,
    10111000,10111001,10111010,10111011,10111100,10111101,
    10111110,10111111,11000000,11000001,11000010,11000011,
    11000100,11000101,11000110,11000111,11001000,11001001,
    11001010,11001011,11001100,11001101,11001110,
    11001111,11010000,11010001,11010010,11010011,
    11010100,11010101,11010110,11010111,11011000,11011001,
    11011010,11011011,11011100,11011101,11011110,11011111,
    11100000,11100001,11100010,11100011,11100100,11100101,
    11100110,11100111,11101000,11101001,11101010,11101011,
    11101100,11101101,11101110,11101111,11110000,11110001,
    11110010,11110011,11110100,11110101,11110110,11110111,
    11111000,11111001,11111010,11111011,11111100,11111101,
    11111110,11111111,100000000,100000001,100000010,100000011,
    100000100,100000101,100000110,100000111,100001000,100001001,
    100001010,100001011,100001100,100001101,100001110,
    100001111,100010000,100010001,100010010,100010011,
    100010100,100010101,100010110,100010111,100011000,
    100011001,100011010,100011011,100011100,100011101,
    100011110,100011111,100100000,100100001,100100010,
    100100011,100100100,100100101,100100110,100100111,
    100101000,100101001,100101010,100101011,100101100,
    100101101,100101110,100101111,100110000,100110001,
    100110010,100110011,100110100,100110101,100110110,
    100110111,100111000,100111001,100111010,100111011,
    100111100,100111101,100111110,100111111,101000000,
    101000001,101000010,101000011,101000100,101000101,
    101000110,101000111,101001000,101001001,101001010,
    101001011,101001100,101001101,101001110,101001111,
    101010000,101010001,101010010,101010011,101010100,
    101010101,101010110,101010111,101011000,101011001,
    101011010,101011011,101011100,101011101,101011110,
    101011111,101100000,101100001,101100010,101100011,
    101100100,101100101,101100110,101100111,101101000,
    101101001,101101010,101101011,101101100,101101101,
    101101110,101101111,101110000,101110001,101110010,
    101110011,101110100,101110101,101110110,101110111,
    101111000,101111001,101111010,101111011,101111100,
    101111101,101111110,101111111,110000000,110000001,
    110000010,110000011,110000100,110000101,110000110,
    110000111,110001000,110001001,110001010,110001011,
    110001100,110001101,110001110,110001111,110010000,
    110010001,110010010,110010011,110010100,110010101,
    110010110,110010111,110011000,110011001,110011010,
    110011011,110011100,110011101,110011110,110011111,
    110100000,110100001,110100010,110100011,110100100,
    110100101,110100110,110100111,110101000,110101001,
    110101010,110101011,110101100,110101101,110101110,
    110101111,110110000,110110001,110110010,110110011,
    110110100,110110101,110110110,110110111,110111000,
    110111001,110111010,110111011,110111100,110111101,
    110111110,110111111,111000000,111000001,111000010,
    111000011,111000100,111000101,111000110,111000111,
    111001000,111001001,111001010,111001011,111001100,
    111001101,111001110,111001111,111010000,111010001,
    111010010,111010011,111010100,111010101,111010110,
    111010111,111011000,111011001,111011010,111011011,
    111011100,111011101,111011110,111011111,111100000,
    111100001,111100010,111100011,111100100,111100101,
    111100110,111100111,111101000,111101001,111101010,
    111101011,111101100,111101101,111101110,111101111,
    111110000,111110001,111110010,111110011,111110100,
    111110101,111110110,111110111,111111000,111111001,
    111111010,111111011,111111100,111111101,111111110,
    111111111,1000000000);//打表
    begin
    readln(n);//输入
    if n>=1000000000 then//防御第15个点的bug
    begin
     writeln(512);//输出512
     halt;//跳出
    end;
    repeat//repeat语句
     i:=i+1;//i加1
    until x[i]>n;//如果已经>n，跳出
    writeln(i-1);//输出（要减一）
    end.
# 代码较长，dalao勿喷
# 严禁抄袭！！！













---


# Nastya Is Reading a Book

## 题目描述

Nastya决定读一本有 $n$ 个章节的书。这本书的每一页都属于一章中，同样的，每一章至少有 $1$ 页。

昨晚 Nastya 没有看完书, 所以她在第 $k$  页做下了记号，第 $k$ 页就是还没有读的第 $1$ 页（换句话说，她读了从第 $1$ 页到第 $\left(k-1\right)$ 页。

第二天， Nastya 的朋友 Igor 来问她,还有多少章没读。 但是 Nastya 太忙了, 所以让你来求出她还有多少章节**没完全读完**。

## 样例 #1

### 输入

```
3
1 3
4 7
8 11
2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 4
5 9
10 12
9
```

### 输出

```
2
```

## 样例 #3

### 输入

```
1
1 7
4
```

### 输出

```
1
```

# 题解

## 作者：_lmz_ (赞：0)

这题不难，不要被黄题吓到了。

先说怎么判断这一章有没有看完，我们可以发现，如果 $k \leq r_i$，那么第 $i$ 章就没有看完。

在第 $i$ 章看完的时候，还有第 $i+1$ 到 $n$ 章没有看，也就是还有 $n-i+1$ 章没有看。

核心代码：
```cpp
for(int i=1;i<=n;i++){
    if(k<=r[i]){
        cout<<n-i+1;
        return 0;
    }
}
```

---

## 作者：Dehydration (赞：0)

题目大意：
1. 有 $n$ 章节。
2. 第 $i$ 章是 $l_i$ ~ $r_i$ 的。
3. 读到了第 $k$ 页(没完全读完)。

首先，如果 $k$ 是没读完的。

那显然，我们可以从 $1-n$ 进行递推并打表：

当 $l_i$ $\le$ $k$ $\le$ $r_i$ ，

 $i=n,ans=1$ ;

$ i= n -1 , ans = 2 $ ;

......

$ ans=n-i+1   $ ;

### AC CODE:

```
#include<bits/stdc++.h>//懒人最爱万能头
using namespace std;
int main()
{
	int n,k,l[105],r[105];
	cin>>n;//输入
	for(int i=1;i<=n;i++)
		cin>>l[i]>>r[i];//输入
	cin>>k;//页数
	for(int i=1;i<=n;i++)
		if(r[i]>=k)//判断（k<=l[i]）
		{
			cout<<n-i+1;//上边的
			return 0;
		}
}
```


---

## 作者：TianLuen (赞：0)

# CF1136A C++题解
## 题目大意
- 有一本有 $n$ 个章节的书。
- 第 $i$ 个章节开始于第 $l_i$ 页，结束于第 $r_i$ 页。
- Nastya 在第 $k$ 页做了记号，表示那一页起还没有读。
- 求的是没有完全读完的章节数
## 题意分析
仔细研读题目，可以知道题目的大概意思。我选用的是计算出 $k$ 的每一种情况，然后直接输出。这道题目， $k$ 的值很好算。为什么？

第一章是从 $l_1$ 到 $r_1$ 页，只要 $k$ 在这个区间内，答案就是 $n$，因为每一章都没有读完。

第二章是从 $l_2$ 到 $r_2$ 页，只要 $k$ 在这个区间内，答案就是 $n-1$，因为只有第 $1$ 章读完了。

以此类推...

第 $i$ 章是从 $l_i$ 到 $r_i$ 页，只要 $k$ 在这个区间内，答案就是 $n-i+1$，因为之前的章节都读完了。

推导出核心代码 `a[j]=n-i+1`。

如此一来，只要预先设定好 $k$ 的每一个值对应的答案，最后输出一下，就可以完美解决了！

## 代码
```cpp
#include<iostream>
using namespace std;
int a[10010],n,l,r,k;	//建议使用全局变量
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>l>>r;
        for(int j=l;j<=r;j++)	//预设每一种情况
            a[j]=n-i+1;
    }
    cin>>k;
    cout<<a[k];	//直接输出即可
}
```
## The end

---

## 作者：HoshizoraZ (赞：0)

注意第 $k$ 页没有读过

所以我们只需要从左到右搜一遍，找到第一个章的结束页大于等于 $k$ 的章数 $i$，那么就相当于读过了 $i-1$ 章，剩下 $n-(i-1)=n-i+1$ 章 

**Code：**
```cpp
#include <cstdio>
int n,k,l[110],r[110];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&l[i],&r[i]);	//开始页和结束页
	}
	scanf("%d",&k);
	for(int i=1;i<=n;i++){
		if(k <= r[i]){			//找到第一个结束页不小于 k 的章数
			printf("%d\n",n-i+1);	//输出答案
			return 0;			//马上结束
		}
	}
	return 0;
}
```

---

## 作者：hswfwkj_ (赞：0)

首先贴上题目链接：[CF1136A](https://www.luogu.com.cn/problem/CF1136A)

## 题目分析：
我们首先可以推导出，如果 $k$ 是在 $l_n$ 到 $r_n$ 页，那么答案显然是 $1$。

如果 $k$ 是在 $l_{n-1}$ 到 $r_{n-1}$ 页，那么答案应该是 $2$，就是第 $n$ 和 $n-1$ 章。

以此类推，当 $k$ 在 $l_1$ 和 $r_1$ 之间时，答案应是 $n$。

那么我们可以得出如下结论：

**当 $k$ 在 $l_i$ 和 $r_i$ 之间时，答案是 $n-i+1$。**

所以接下来，就可以轻松写出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,l[105],r[105];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&l[i],&r[i]);
	scanf("%d",&k);
	for(int i=1;i<=n;i++)
		if(r[i]>=k)//如果当前这第 i 章没读完
		{
			cout<<n-i+1;
			break;
		}
	return 0;
}
```
~~特别简单，不需要我做什么解释吧。~~

---


# Good String

## 题目描述

有一个长度为$n(1<=n<=100)$的字符串，只由<,>两种字符组成。对其进行一次操作如下：


------------

如果选择一个>字符，这个字符**右面**的那一个字符会被删除。特别地，如果你选择的这个字符>位于字符串的最右侧，什么都不会发生。同理，如果选择一个<字符，这个字符**左面**的那一个字符会被删除，选择位于字符串最左边的<字符也什么都不会发生。


------------

定义一下的一个字符串是“好的”：经过若干次以上操作，这个字符串可以只含有一种字符，如>,>>等。

在执行操作之前，你可以删去字符串中的$k(0<=k<=n-1)$$个字符。注意不可以把整个字符串都删去了。

你需要找出$k$的最小值，使得删去$k$个字符后的字符串是“好的”。

## 说明/提示

第一组数据中，删除任意一个字符都可以使得剩下的字符串是“好的”。

第二组数据中，原字符串就是“好的”，无需删除任何字符。

## 样例 #1

### 输入

```
3
2
<>
3
><<
1
>```

### 输出

```
1
0
0
```

# 题解

## 作者：saixingzhe (赞：2)

# 题意
```>``` 可以让它右面的那一个字符被删除。

```<``` 可以让它左面的那一个字符被删除。

**一个字符可以使用无数次。**

要找出让字符串经过操作只含有一种字符的所删去字符的最小次数。
# 思路
题意可以简化成找出最左边的 ```>``` 或最右边的 ```<```。因为只要最左边是 ```>``` 或最右边是 ```<``` 就可以一直删直到最后剩下一个 ```>``` 或 ```<``` 字符。

因此我们只需要求出最左边的 ```>``` 和最右边的 ```<``` 距离边界的最小值即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
string s;
int main(){
	scanf("%d",&t);
	for(int j=0;j<t;j++){
		scanf("%d",&n);
		cin>>s;
		int i=0,a1=0,a2=0;
		n--;
		while(s[i]=='<'){
			if(i==n) break;
			a1++;
			i++;
		}
		while(s[n]=='>'){
			if(n==0) break;
			a2++;
			n--;
		}
		printf("%d\n",min(a1,a2));
	}
	return 0;
}
```

---

## 作者：lightningZ (赞：1)

# 思路
这题的思路很简单，因为 $<$ 这个符号可以一直删除**左边**的东西，$>$ 这个符号可以一直删除**右边**的东西，所以只需要让最左边是 $>$ 或者最右边是 $<$ 就可以一直删除，直到只剩 $1$ 个字符(也就是整个字符串是同一个字符)，所以，我们只需要从左删，一直删到 $>$ ，从右删，一直删到 $<$ ，再看哪个更少，就选哪个。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		int n;
		char a[105];
		bool f=true;
		scanf("%d%s",&n,a+1);
		int x=1,ans=0,ans1=0;
		while(a[x]=='<')//从右删 
		{
			if(x==n) break;
			ans++;
			x++;
		}
		while(a[n]=='>')//从左删 
		{
			if(n==1) break;
			ans1++;
			n--;
		}
		printf("%d\n",min(ans,ans1));//比较 
	}
	return 0;
}

```


---

## 作者：lrmlrm_ (赞：0)

## 题意

先有一个长度为 $n$ 的字符串，由 `<` 和 `>` 组成。

对 `<` 进行操作，这个 `<` 的左边的字符就会被删掉。

对 `>` 进行操作，这个 `>` 的右边的字符就会被删掉。

如果一个字符串经过若干次操作后可以让字符串中所有的字符相等（即全是 `>` 或全是 `<`），那么它就是好串。

问对于输入的字符串，通过删除 $k$ 个字符可以使得让它变成一个好串。问 $k$ 最小是多少。

## 思路

进行分析，如果一个字符串是一个好串，那么它只有两种可能，全是 `>` 或全是 `<`，易得这两种可能都能够将字符串删到只剩一个字符。同理，只剩一个字符时也肯定是一个字符。

因此，变成好串就可以视为是要让它变得只剩一个字符。

再次分析可以发现，如果最左边是 `>`，那么就可以把自己右边的字符全部删掉，只剩下自身，那么它就是一个好串。

同理，如果最右边是 `<`，那么就可以把自己左边的字符全部删掉，它也是一个好串。

题目中要求让删去的字符数最少，就要让它变成一个字符中进行的操作数最多，让操作数最多，就需要从最两边开始删。

到这里这题的思路就很明显了，找出如果要让最左边的 `>` 成为最左端要删去几个字符；再找出如果要让最右边的 `<` 成为最右端要删去几个字符，最后找出两者的最小值即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,suml,sumr,zb,yb;
string st;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		cin>>st;
		yb=n-1,zb=0,suml=0,sumr=0;
		while(st[yb]=='>'&&yb>=1)
			suml++,yb--;
		while(st[zb]=='<'&&zb<n)
			sumr++,zb++;
		printf("%d\n",min(suml,sumr));
	}
	return 0;
} 
```

---

## 作者：1433_qwq (赞：0)

# CF1140B 题解

**思路**

只要最左边为 `>` 或者最右边为 `<`，就一定可以消掉整个字符串。

那么我们只需要算 `>` 或 `<` 距离边界的最小值。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
   long long a;
   cin >> a;
   while(a--){
		long long b;
  		string c;
  		cin >> b >> c;
  		long long f = 0,d = 0,e = 0;
		b--;
		while(c[f]=='<'){
			if(f == b) break;
			d++;
			f++;
		}
		while(c[b]=='>'){
			if(b == 0) break;
			e++;
			b--;
		}
		cout << min(d,e) << endl;
   }
	return 0;
}
```


---

## 作者：shabiisshabi (赞：0)

# 题意
 ```<``` 可以删除自身左边的字符。
 ```>``` 可以删除自身右边的字符。

字符串 $s$ 中含有 ```<``` 与 ```>``` 两种字符，删除 $s$ 中的几个字符，令字符串 $s$ 可以通过 ```<``` 与 ```>``` 的变化变成只剩余一种字符的字符串，求最少删除的字符数量。

# 思路

根据题意不难发现，当最左端为 ```>``` 时，便可以将自身左边的字符全部删掉，符合要求。当最右端为 ```<``` 时同理。

所以，我们要从字符串 $s$ 的两端遍历，如果最左端为 ```>``` 或最右端为 ```<``` 时终止遍历，输出答案，即**遍历次数**。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
   	scanf("%d",&n);
   	while(n--)
	{
		char s[101];
		int m,i=0,j,x,ans=0;
		scanf("%d",&m);
		scanf("%s",s);
		x=strlen(s);
		while(s[i]=='<' && s[x-1]=='>')//如果最左端不是>并且最右端不是< 
		{
			i++;//删除最左端字符，继续遍历 
			x--;//删除最右端字符，继续遍历 
			ans++;
		}
		printf("%d\n",ans);
	} 
   	return 0;
}

```

---

## 作者：玄学OIER荷蒻 (赞：0)

## 题目大意:
题目不是很长就略过了。
## 题目分析:
让我们来分析一下，什么情况下不管执行多少次操作都无法实现只有一个元素。

我们分三种情况:

1. 最后一个字符是 $\verb'<'$，此时不用删数，可以进行若干次操作后只剩 1 个字符，也就是最开始的最后一个字符。
2. 第一个字符是 $\verb'>'$，此时不用删数，可以进行若干次操作后只剩 1 个元素，也就是最开始的第一个字符。
3. 字符串由若干个 $\verb'<'$，一个 $\verb'>'$，若干个字符，一个 $\verb'<'$，若干个 $\verb'>'$ 组成,那么我们只要删除结尾的若干个 $\verb'>'$ 以后就变回了第一种情况，此时答案设为 $ans1$，如果删除开头的若干个 $\verb'<'$ 就可以变成第二种情况，此时答案设为 $ans2$，取 $\min(ans1,ans2)$ 即可。

## 代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while (t--){
        int n;
        cin>>n;
        string s;
        cin>>s;
        if (s[n-1]=='<') cout<<0<<endl;
        else if (s[0]=='>') cout<<0<<endl;
        else{
            int fst=0,edl=n-1;
            for (;fst<n;fst++) if (s[fst]=='>') break;
            for (;edl>=0;edl--) if (s[edl]=='<') break;
            cout<<fst<<' '<<edl<<' '<<min(fst,n-edl-1)<<endl;
        }
    }
    return 0;
}
```
复杂度 $O(tn)$

---

## 作者：LeTu_Jun (赞：0)

题意：
	
每个 `>` 或 `<` 字符在被选择后，就会删去这个字符**小头**那边的字符。

现在你可以随意删去字符（不可以删去整个字符串），需要保证最后留下的字符中按照以上规则删去任意个字符后的字符串只留有 **一种字符 （`<` 或 `>`）**，希望删去字符的数量越小越好。

题解：

唯一难点就是如何寻找“Good string”：

首先发现对于一个串，如果它的最左边是 > 或最右边是 <，则这个串一定可以删去其它的所有字符，是一个 `Good String`。

其次思考后发现 `Good String` 的含义为：从左边/右边一直删到不能再删为止，然后分别比较（是的，左右不能同时删）

所以直接模拟上去。

注意本题多组数据，输入输出量稍大，建议用 `scanf` 和 `printf`。

没看懂上面文字的看代码注释。 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
char s[105];
/*由于字符串整体字符没什么变数,而且长度已知,所以用了 char 类型*/
int main ()
{
	scanf("%d",&t);
	for(int g=1;g<=t;g++){
		scanf("%d",&n);
		scanf("%s",s+1);
		int i=1;
		int a1=0,a2=0;
		/*从左边删*/
		while(s[i]=='<'){
			if(i==n) break;
			a1++;
			i++;
		}
		/*从右边删*/
		while(s[n]=='>'){
			if(n==1) break;
			a2++;
			n--;
		}
		/*输出操作次数哪个最小*/
		printf("%d\n",min(a1,a2));
		/*注意换行*/
	}
	return 0;
}
```


---


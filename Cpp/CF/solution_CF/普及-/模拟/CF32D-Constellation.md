# Constellation

## 题目描述

一个Berland星空图填充了一个N×M的正方形。在每一个正方形上都可能有星星。Berland的十字星座是所有的天文学家最喜欢的星座。这个星座可以由任何5个恒星组成，所以对于整数x（星座的半径），有以下原则：

第二个和第一个在同一条垂直线上，但是在第一个的上边x单位处。

第三个和第一个在同一条垂直线上，但是在第一个的下边x单位处。

第四个和第一个在同一水平线上，但是在第一个的左边x单位处。

第五个和第一个在同一水平线上，但是在第一个的右边x单位处。

这些星座可以非常多，这就是为什么他们有以下原则：当两星座相比，更小的半径会有更小的指数；如果他们的半径相等，其中央恒星如果高于另一个中央恒星；如果他们中央恒星都在同一水平的人，其中央恒星是对另一个中央恒星的左边。

你的任务是找到星座为指数K的Berland的星空图。

## 样例 #1

### 输入

```
5 6 1
....*.
...***
....*.
..*...
.***..
```

### 输出

```
2 5
1 5
3 5
2 4
2 6
```

## 样例 #2

### 输入

```
5 6 2
....*.
...***
....*.
..*...
.***..
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
7 7 2
...*...
.......
...*...
*.***.*
...*...
.......
...*...
```

### 输出

```
4 4
1 4
7 4
4 1
4 7
```

# 题解

## 作者：Shimotsuki (赞：3)

[传送门 to 洛谷](https://www.luogu.com.cn/problem/CF32D)

[传送门 to CF](http://codeforces.com/problemset/problem/32/D)

这是一道暴力模拟题，思路很好想，只要一个个枚举并判断就 OK 了。可是一个个枚举需要三重循环，时间复杂度是 $O(n^3)$ ,这复杂度~~保熟~~能过吗？答案是肯定的，因为 $N\le300$ ,不放心的话可以添加一些常数优化，具体内容可结合代码理解（~~似乎这是当前已知的最优解呢~~）。

$Code$
```cpp
#include<cstdio>

using namespace std;

#define rd(x) x=read()
#define rei register int

char a[310][310];

inline int read()//快读优化 
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main(){
    int n,m,k,cnt=0;
    rd(n);rd(m);rd(k);
    for(rei i=1;i<=n;i++)
    	scanf(" %s",a[i]+1);
	int len=n<m?n:m;
    for(rei l=1;l<=len;l++){//暴力枚举答案 
		for(rei i=l+1;i+l<=n;i++){
			for(rei j=l+1;j+l<=m;j++){
    			if(a[i][j]=='*'&&a[i+l][j]=='*'&&a[i-l][j]=='*'&&a[i][j+l]=='*'&&a[i][j-l]=='*'){//一个个配对 
    				if(cnt+1==k){//继续配对 
						printf("%d %d\n",i,j);
						printf("%d %d\n",i-l,j);
						printf("%d %d\n",i+l,j);
						printf("%d %d\n",i,j-l);
						printf("%d %d",i,j+l);
    					return 0;//打印答案并结束 
    				}
    				else cnt++;
    			}
			}
		}
    }	
    printf("-1");//找不到答案 
    return 0;//大功告成！
}
```
码风不好喷轻点qwq

---

## 作者：__Cartesian__Tree__ (赞：1)

首先，由于这道题的 $n \le 300,m \le 300$，所以可以直接暴力遍历出所有十字星座。

然后再枚举指数，由于条件中说明半径小的指数小行数小的指数小，列数小的指数小，所以我们可以依次按照半径、行、列从小到大遍历，遇到符合要求的星座就将指数增加。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;//行数
int m;//列数
int k;//zhishu
char mm[310][310];//存放图
int main(){
    cin>>n>>m>>k;
    for (int i = 1; i <= n; i++){//遍历行
        for (int j = 1; j <= m; j++){//遍历列
            cin>>mm[i][j];
        }
    }
    int cnt = 1;//指数计数
    int len = min(n, m);//半径最大值
    for (int num = 1; num <= len; num++){//遍历半径
        for (int x = num+1; x+num <= n; x++){//遍历行
            for (int y = num+1; y+num <= m; y++){//遍历列
                if (mm[x][y]=='*'&&mm[x-num][y]=='*'&&mm[x+num][y]=='*'
                    &&mm[x][y-num]=='*'&&mm[x][y+num]=='*'){
                    //判断是否符合要求
                    if (cnt == k){//指数恰好为k
                        cout << x << ' ' << y << endl;//中
                        cout << x-num << ' ' << y << endl;//上
                        cout << x+num << ' ' << y << endl;//下
                        cout << x << ' ' << y-num << endl;//左
                        cout << x << ' ' << y+num << endl;//右
                        return 0;
                    }
                    cnt++;//没退出程序，则增加指数
                }
            }
        }
    }
    puts("-1");//仍未退出程序，说明没有遍历到
    return 0;
}
```

---

## 作者：chenyilai (赞：0)

本题大意：要去寻找类似于“十”的星座。其中星座的半径编号小的排在前面，半径相同则上面的排在前面，同一高度则左边的排在前面。

我们就可以按照题目的顺序，先枚举半径，再从上往下，从左往右枚举。

由于 $1\leq N,M \leq 300$，因此 $O(N^3)$ 的暴力程序可以不加优化的通过。

CODE:
```cpp
bool pd(int i,int j){//判断第i行第j列是否是星
	if(i<=0||i>n||j<=0||j>m)return 0;//边界
	if(s[i][j]=='.')return 0;
	return 1;
}
int main(){
	cin>>n>>m>>k;
	minn=min(n,m)/2;
	for(int i=1;i<=n;i++)cin>>s[i],s[i]=' '+s[i];
	for(int r=1;r<=minn;r++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(pd(i,j)&&pd(i-r,j)&&pd(i,j-r)&&pd(i,j+r)&&pd(i+r,j)){//判断是否为十字星座
					k--;
					if(k==0){//找到了
						printf("%d %d\n%d %d\n%d %d\n%d %d\n%d %d\n",i,j,i-r,j,i+r,j,i,j-r,i,j+r);//按顺序输出答案
						return 0;
					}
				}
	printf("-1");//没找到
	return 0;
}
```

码风不好勿喷。

---

## 作者：oimaster (赞：0)

[早上六点打的虚拟比赛，差点 AK ，就差一个 E 题。最后发现 E 题不论是 洛谷 还是 Codeforces 都没有题解，而看 CF 正确的源代码又看不懂，我太难了……](https://oi-master.github.io/post/codeforces-contest-32-d-ti-jie/)

好，不说别的了，我们先讲思路吧。
## 思路

$N$ 才 $300$ ？那就写个 $O(N^3)$ 算法。啪啪啪啪啪啪啪啪……咦？居然过
了？！

这道题的数据很小呢，所以发现这道题纯考你的手熟不熟，思维不难。
我们先枚举半径（ $r$ ，从小到大），然后枚举行（ $i$ ，从小到大），再枚举列（ $j$ ，还是从小到大），然后我们每次判断存不存在当中心点为 $(i, j)$，半径为 $r$ 的十字形星座。如果有，那么就把总数加上 $1$ 。如果总数到了 $K$，那么我们就打印。

如果最后啥也没打出来（也就是说，总数小于 $K$），那么就输出 $-1$。

如此简单，这上面就算是一种伪代码了（难道不是吗？
## 代码
给上 C++ 实现的代码
```cpp
/* Generated by powerful Codeforces Tool
 * Author: OI_Master
 * Time: 2020-03-31 07:20:10
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,m,k;
    cin>>n>>m>>k;
    char c[n+1][m+1];
    for(int i=1;i<=n;++i)
    	for(int j=1;j<=m;++j)
    		cin>>c[i][j];
    int num=0;
    for(int r=1;r<=min(n,m);++r)
    	for(int i=r+1;i+r<=n;++i)
    		for(int j=r+1;j+r<=m;++j)
    			if(c[i][j]=='*'&&c[i-r][j]=='*'&&c[i+r][j]=='*'&&c[i][j-r]=='*'&&c[i][j+r]=='*'){
    				if(num==k-1){
    					cout<<i<<' '<<j<<endl<<i-r<<' '<<j<<endl<<i+r<<' '<<j<<endl<<i<<' '<<j-r<<endl<<i<<' '<<j+r<<endl;
    					return 0;
    				}
    				else
    					++num;
    			}
    cout<<-1<<endl;
    return 0;
}
```
本文到此结束。

---


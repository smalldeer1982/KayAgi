# Domino

## 题目描述

## 【问题描述】

Hades与Dionysus在狂饮后玩起了多米诺骨牌的小游戏。
现在桌上有n块多米诺骨牌，每块多米诺骨牌上半部分和下半部分上都有一个整数。每次翻转可让一块多米诺骨牌上下翻转，即上下部分数交换。Hades想让n块骨牌上半部分的数加起来是一个偶数，而Dionysus想让这n块骨牌下半部分的数加起来是一个偶数。喝醉的两人都不肯退让，非要达到自己的目的。路过的Hephaestus在扫了一眼桌上的骨牌后瞬间给出了一个让两人都满意且翻转次数最少的方案，便转身离去，留下迟滞的二人。可这还没完，喝得烂醉的二人很快忘记了Hephaestus所说的方案，Hades说他还记得最少的翻转次数，Dionysus不愿被比下去，只好来请教你了。

## 样例 #1

### 输入

```
2
4 2
6 4
```

### 输出

```
0
```

## 样例 #2

### 输入

```
1
2 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3
1 4
2 3
4 4
```

### 输出

```
1
```

# 题解

## 作者：crpboy (赞：4)

## 分类讨论

对上下两排分别求和，每一排的和有两种情况：奇数或偶数

因此，上下两排有四种情况：
$($奇$,$奇$)$,$($偶$,$偶$)$,$($奇$,$偶$)$,$($偶$,$奇$)$
，对$2$取模可以发现，上下两排有
** $(1,1)$,$(0,0)$,$(1,0)$,$(0,1)$ ** 4种情况。

$(0,0)$上下和都为偶数，无需交换，输出$0$;

$(0,1)$和$(1,0)$无论怎么交换总有一边是奇数，因此无法满足题目要求，输出$-1$;

$(1,1)$ 有两种情况，如果有出现上下奇偶性不同的骨牌，则可以通过一次交换达到题目要求，反之则输出$-1$.

AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[10005],y[10005];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&x[i],&y[i]);
	for(int i=1;i<=n;i++)
		x[i]&=1,y[i]&=1;//取模
	int s1=0,s2=0;
	bool flag=false;//flag表示(1,1)情况下是否有解
	for(int i=1;i<=n;i++)
	{
		s1+=x[i],s2+=y[i];
		if(!flag)if((x[i]&&!y[i])||(!x[i]&&y[i]))flag=true;
	}
	s1%=2,s2%=2;
	if((s1&&!s2)||(!s1&&s2)||(s1&&s2&&!flag))//无解情况
	{
		printf("-1");
		return 0;
	}
	if(s1&&s2&&flag)//(1,1)有解
	{
		printf("1");
		return 0;
	}
	if(!s1&&!s2)//(0,0)
	{
		printf("0");
		return 0;
	}
	return 0;
}qwq
```

---

## 作者：chlchl (赞：3)

## 题意
给定 $2n$ 个数 $x_i,y_i$，每次操作可以任意调换一个 $x_i,y_i$。问至少操作几次，使得 $\sum\limits_{i=1}^{n}x_i$ 和 $\sum\limits_{i=1}^{n}y_i$ 都为偶数。

## 做法
本题为**数学题**。

首先根据小学一年级数学知识易得以下三个式子：
1. 奇数 $+$ 奇数 $=$ 偶数。
1. 偶数 $+$ 偶数 $=$ 偶数。
1. 奇数 $+$ 偶数 $=$ 奇数。

然后可以得出结论：本题答案只有 $0,1,-1$ 三种。

为什么不可能大于 $1$ 呢？这是其他题解解释不清楚的。 
### 证明：
----------------
假设操作 $x$ 次（$x > 1$）。

首先，交换偶数是没有意义的，因为奇偶性不变（参见 $1,3$ 式）。故只讨论交换奇数。
- 如果 $x$ 是偶数，那么相当于没交换，因为交换了偶数个奇数，上下和的奇偶性还是不变。
- 如果 $x$ 是奇数，那么相当于交换 $1$ 次，因为交换了奇数个奇数，上下和的奇偶性发生改变，就相当于只交换 $1$ 个。

上述情况加上一个不可能，就只有三种情况了。命题得证。

------------
知道了这些，那如何判定答案呢？

- 因为上下和皆为偶数，根据 $2$ 式可得，它们的和必为偶数。换言之，如果和为奇数，天皇老子来了都没法符合要求，输出 $-1$。

判断完上面后，现在和必定为偶数，that is，上下和奇偶性相同。

1. 如果上下皆为偶数，大功告成，输出 $0$。
2. 如果上下皆为奇数，分两种情况讨论：
- 如果找得到一张奇偶性不同的牌，那就交换这张牌，输出 $1$；
- **如果找不到，输出 $-1$。**

我一开始就是忘记讨论都是奇数，直接输出了 $1$，第 $8$ 个点就红了。

不过，~~为了解法不重复~~我一开始思路不是这样的，而是选择了统计奇数个数的方法。所以，上面结论化简为：
- 如果上下奇数个数和为奇数，输出 $-1$。
- 如果上下奇数个数都为偶数，输出 $0$。
- 如果上下奇数个数都为奇数且找得到奇偶性不同的牌，输出 $1$。
- 如果上下奇数个数都为奇数且找不到奇偶性不同的牌，输出 $-1$。

## 代码
以下是参考代码。珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100 + 10;
int n, up[2], down[2], x[N], y[N];
bool flag;
//两个奇数的和必为偶数 

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++){
		scanf("%d%d", &x[i], &y[i]);
		up[x[i] % 2]++, down[y[i] % 2]++;
		//方便统计个数，不用打 if 
		if((x[i] + y[i]) % 2 == 1)	flag = true;
		//提前判断有没有奇偶性不同的牌，别的题解都是用的abs，
		//我用的是和的奇偶性判断的。可以根据上述三式得出 
	}
	//下面判断就是前面的结论了，不解释 
	if((up[1] + down[1]) % 2 == 1){
		puts("-1");
		return 0;
	}
	//这里奇偶性必定相同，判断一方即可 
	if(up[1] % 2 == 0)	puts("0");
	else if(up[1] % 2 == 1 && flag)	puts("1");
	else	puts("-1");
	return 0;
}
```

---

## 作者：sxtm12138 (赞：3)

这道题目其实只有0，1，-1三种情况：考虑上下点数之和的奇偶性，若均为偶数，则次数为0，若一奇一偶，则一定不可能，故只需判断均为奇数时的情况。由于一个数加上一个偶数再减去一个偶数（或加上一个奇数再减去一个奇数），奇偶性不变，所以被翻转的牌上下点数的奇偶性一定不同，且只需翻转一块。

以下是代码：

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,y,x,a,t,f;//定义变量
int main()
{cin>>n;//读入
 for(int i=1;i<=n;i++)
   {cin>>x>>y;//读入上下点数（无需开数组）
    t+=x;//t记录上点数之和
	f+=y;//f记录下点数之和
	if(abs(x-y)%2==1) a=1;//判断上下点数的奇偶性是否相同
   }
 if(t%2==0&&f%2==0) cout<<0;//若均为偶数，则次数为0
 else if((t+f)%2==0&&a==1) cout<<1;
      //若均为奇数，且存在上下点数奇偶性不同的牌，则翻转次数为1
      else cout<<-1;//否则一定不可能，输出-1
 return 0;
}
```

---

## 作者：mzyc_jx (赞：2)

[CF353A Domino](https://www.luogu.com.cn/problem/CF353A)

~~这道题体现了数学中分类讨论的思想。——数学老师~~

### 此题分四种情况讨论：

---

1. 总和为奇数怎么翻转都不行，输出 -1。

2. 上下之和都是偶数，直接满足条件，输出 0。

3. 上下之和都是奇数，找到一张上下奇偶性不同的骨牌，只用交换一次，输出 1。

4. 上下之和都是奇数，但找不到一张上下奇偶性不同的骨牌，输出 -1.

---

~~于是，我们发现此题只可能输出 0，1，-1 ，可以用随机数函数解决……~~

~~但是，59个测试点，以我的人品，是无论如何都过不去的……~~

### 还是认真写代码吧：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,x,y,sum1=0,sum2=0;//记得赋初值喔
	bool a=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
    	sum1+=x;sum2+=y;
		//sum1 统计上半部分的和，sum2 统计下半部分的和
		if(abs(x-y)%2)//判断上下部分的和的奇偶性是否相同
		a=1;
	}
	if(sum1%2==0&&sum2%2==0)//若上下之和都是偶数，则输出0
	cout<<0;
	else if((sum1+sum2)%2==0&&a)
    //若上下之和都是奇数，并且找到一张上下奇偶性不同的骨牌，只用交换一次，输出 1
	cout<<1;
	else
	cout<<-1;//如果都不满足，输出-1
	return 0;
}
```


---

## 作者：mzyc_pzx (赞：1)

### 本题有四种情况：

1.奇偶性不同 **输出 -1** 。

2.都是偶数直接 **输出 0** 。

3.都是奇数要找上下奇偶性不同的牌 **输出 1** 。

4.若不可能 **输出 -1** 。

### 还是上代码吧：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,y,x,b,c;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
	    b+=x;
		c+=y;
		if(abs(x-y)%2==1)
		a=1;
	}
	if(b%2==0&&c%2==0)
	cout<<0;
	else if((b+c)%2==0&&a==1) 
	cout<<1;
	else
	cout<<-1;
	return 0;
}
```


---

## 作者：Rachel_in (赞：1)

对于这道题,我们通过判断奇偶来做,我们先把两边累加起来.

此时分成3个情况:
# 1 两边都为偶数直接输出0
# 2两边和为奇数直接输出-1(不可行)
# 3两边都为奇数,那么此时我们就要在进行依次循环,倘若能找出一对奇数和偶数就输出1,若找不到则输出-1

下为代码


```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int a[10005],b[10005],n;
long long tota,totb;
int main()
{
	n=read();
	tota=totb=0;
	for(int i=1;i<=n;i++)
	{
		a[i]=read();b[i]=read();
		tota+=a[i];//记录和
		totb+=b[i];
	}
	if(tota%2==0&&totb%2==0)//都为偶数
	{
		printf("%d\n",0);
		return 0;
	}
	if((tota+totb)%2==1)//和为奇数
	{
		printf("%d\n",-1);
		return 0;	
	}	
	bool flag=false;
	for(int i=1;i<=n;i++)	
	{
		if(a[i]%2==1&&b[i]%2==0)//找一对奇数偶数
		{
			flag=true;	
			break;
		}
		if(a[i]%2==0&&b[i]%2==1)
		{
			flag=true;	
			break;
		}
	}
	if(flag)
	{
		printf("%d\n",1);//输出
		return 0;
	}
	else
	{
		printf("%d\n",-1);
		return 0;
	}
}
```

---

## 作者：蒟蒻abcd (赞：1)

这就是一个简单的递推（或者说是模拟）  
它有几种情况，分别为上方为偶数，下方也为偶数，这时无需翻转，答案就是0；  
当上方和下方有一个为偶数，一个为奇数时，你可以手动模拟一下，可以发现，无论如何你都无法使它的上下两面为偶数，这时输出-1；  
当上下两面都为奇数时，只要翻转一面是偶数，一面是奇数的Domino（我认为应该是多米诺骨牌）就可以了，此时答案为一；如果没有这种骨牌，那么就只能输出-1了。  
推荐在运算之前就把它们转换为0或1。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001]={0},b[10001]={0};
int main()
{
	freopen("domino.in","r",stdin);
	freopen("domino.out","w",stdout);
	int n;
	scanf("%d",&n);
	int c=0,d=0;
	for(int i=1;i<=n;i++)
	{
        scanf("%d%d",&a[i],&b[i]);
        c=c+a[i];c=c%2;
        d=d+b[i];d=d%2;
        a[i]%=2;b[i]%=2;
    }
	if((c+d)%2==1)printf("-1");
	else if(c==0&&d==0)printf("0");
	else
	{
		bool bo=false;
		for(int i=1;i<=n;i++)
            if((a[i]||b[i])&&(!(a[i]&&b[i])))bo=true;
		if(bo)printf("1");
		else printf("-1");
	}
}
```
谢谢

---

## 作者：Aot_Any_More (赞：0)

### 思路：
1. 性质不同或不可能实现输出 $-1$。

2. 都是偶数输出 $0$。

3. 都是奇数要找上下性质不同的牌 输出 $1$。
### 奉上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,sumx,sumy,x,y;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
	    sumx=sumx+x;
		sumy=sumy+y;
		if(abs(x-y)%2==1)
		a=1;
	}
	if(sumx%2==0&&sumy%2==0)
	cout<<0;
	else if((sumx+sumy)%2==0&&a==1) 
	cout<<1;
	else
	cout<<-1;
	return 0;
}
```


---

## 作者：Halberd_Cease (赞：0)

[**CF353A Domino**](https://www.luogu.com.cn/problem/CF353A)

## 分析
**题目大意：** 桌上有 $n$ 块骨牌，每块上下都有两个数字，问最少翻动几块可以使上下两排骨牌和分别为偶数。

我们可以发现，题目总共分为了以下三种情况：

- 显然如果初始情况符合上下两排骨牌和 **分别为偶数** 就输出```0```即可。


- 如果骨牌上所有数字 **总和为奇数** ，那么翻动任意一块就有“ **上奇下偶**  或  **上偶下奇** ”两种情况，改变不了整体奇偶性，无论如何也无法完成目标，输出```-1```。


- 如果输入不符合以上两种情况（例如样例#3），**上下两排和分别是奇数**的话，我们需要查找翻转后可以使上下两排同时变为偶数（**上奇下奇**到**上偶下偶**）的骨牌。显然**上下奇偶不同**的骨牌符合条件，只要翻动**一次一张**就可以使骨牌队列符合条件。如果有即输出```1```（可以完成且只用翻动一次），否则输出```-1```。

有了以上三种情况的思路，就可以很简单地实现本题。

## 解

解释在代码里
```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum1,sum2,n,i,x,y;
bool flag;
bool o(int x)//判断奇偶
{
    if(x%2==0)return 1;
    else return 0;
}
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>x>>y;
        sum1+=x;
        sum2+=y;//累加
        if(!o(x+y))flag=1;//上下两数奇偶不同
    }
    if(o(sum1)&&o(sum2))cout<<0;//和均为偶数
    else if(o(sum1+sum2)&&flag)cout<<1;//两排总和为偶数且有奇偶不同的骨牌
    else cout<<-1;//否则无解
    return 0;
}
```


**拒绝抄袭题解，人人有责**

---

## 作者：Exber (赞：0)

## 做法

思维题。

首先容易发现，最多翻转一块骨牌。因为如果翻转两块及以上骨牌的话要么并不会改变整体奇偶性，要么整体奇偶性和只反转一块后的一样。所以答案只可能是 `0`、`1` 或者 `-1`。

而想要改变整体奇偶性的话，翻转上下分数奇偶性相同的骨牌是没有用的，只有翻转上下分数奇偶性不同的骨牌才会改变整体奇偶性。我们暂且把这种骨牌称为“关键骨牌”。

因为翻转关键骨牌后整体奇偶性变化如下：

`上奇下偶` -> `上偶下奇`；

`上偶下奇` -> `上奇下偶`；

`上偶下偶` -> `上奇下奇`；

`上奇下奇` -> `上偶下偶`。

所以我们可以得出结论：

- 如果初始整体奇偶性为 `上偶下偶`，答案为 `0`；

- 如果初始整体奇偶性为 `上奇下奇` 且有关键骨牌，答案为 `1`；

- 否则答案为 `-1`。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int n;
int up[105],down[105];

int main()
{
	scanf("%d",&n);
	int sumup=0,sumdown=0; // 上下得分和 
	bool canswap=false; // 是否有关键骨牌 
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&up[i],&down[i]);
		sumup+=up[i];
		sumdown+=down[i];
		canswap|=(up[i]&1)!=(down[i]&1);
	}
	if(!(sumup&1)&&!(sumdown&1)) // 上偶下偶 
	{
		puts("0");
		return 0;
	}
	if((sumup&1)&&(sumdown&1)&&canswap) // 上奇下奇且有关键骨牌 
	{
		puts("1");
		return 0;
	}
	puts("-1"); // 其它情况 
	return 0;
}
```


---

## 作者：面向大海 (赞：0)

判断上下奇偶性并判断有没有上下奇偶性不一致的牌即可
分4种情况讨论

+ 奇偶性不同怎么变都不行，输出-1
+ 都是偶数直接输出0
+ 都是奇数需要找到上下奇偶性不同的牌，输出1，否则不可能，输出-1

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
	int n, c = 0, d = 0;
	bool flag = false;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		if ((a & 1) ^ (b & 1)) flag = true;
		c ^= a & 1;
		d ^= b & 1;
	}
	if (c ^ d)
		puts("-1");
	else if (c)
	{
		if (flag)
			puts("1");
		else
			puts("-1");
	}
	else
		puts("0");
	return 0;
}

```

---


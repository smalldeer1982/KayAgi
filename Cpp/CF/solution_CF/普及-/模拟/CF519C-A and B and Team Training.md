# A and B and Team Training

## 题目描述

A和B正在准备编程比赛。

准备比赛中十分重要的一环即是让编程老手们向新手们传授经验。所以，在下一次团队训练中，A决定将成员分组，使新手和老手一起面对和解决问题。

A认为一个合理的分组由一个老手和两个新手构成。这样，老手们就可以向尽可能多的人传授他们的知识。

B认为一个合理的分组由两个老手和一个新手构成。这样，新手们就可以增长见识，更多地提升能力。

于是，A和B经过商议决定，每一个分组都必须是以上两种分组的一种，同时分出的组要尽量多。

现在我们知道一共有$n$ 位编程老手，$m$ 位新手，那么最多可以分成多少组呢？

## 说明/提示

只作注释：XP为老手，NB为新手。

感谢@lonelysir 提供的翻译

## 样例 #1

### 输入

```
2 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 5
```

### 输出

```
3
```

# 题解

## 作者：EDqwq (赞：2)

### 思路：

我们可以发现，一个组肯定是有3个人的，分别是：

1. 一个新手 两个老手

1. 一个老手 两个新手

也就是说，我们无论怎么分都是没有区别的。

所以我们需要找到大的那个数，然后看它和另外一个小的数能配成多少组（大的数做两个，小的数做一个）。

如果小的数乘以2小于大的数，说明哪怕小的数全部用完，大的数也还会剩一些，所以此时我们输出小的数的值。

而当小的数乘以2大于大的数，说明可以直接用除法（因为无论怎么放小的数都是足够的）所以直接输出两个数的和除以3，因为一个组只有可能是3个人。

***

### 代码：

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n,m;

signed main(){
	cin>>n>>m;
	if(m > n)swap(n,m);
	if(m * 2 < n)cout<<m;
	else cout<<(n + m) / 3;
	return 0;
}
```

---

## 作者：thomas_zjl (赞：2)

这道题有$2$种情况。

1. $1$个老手+$2$个新手。
1. $2$个老手+$1$个新手。

诶，比之前先把他们交换一下不就行了吗，就成同$1$种方案了。

有$2$个方案。

1. 如果较大的数$>$较小的数。直接输出较小的数。
1. 如果不是，输出$($较大的数+较小的数$)/3$。

接下来就是代码了。
~~~
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	if(a<b)
	{
		swap(a,b);//设a为较大的数。
	}
	if(b*2<a)//如果b*2>a。
	{
		cout<<b;//输出b。
	}
	else
	{
		cout<<(a+b)/3;//否则输出(a+b)/3。
	}
    return 0;
}
~~~

---

## 作者：寒鸽儿 (赞：1)

思考:  
首先,由于$2a+b$和$a+2b$都是合法的,因而老手和新手没有本质区别。  
记较大的一个数为$a$,较小的一个为$b$。  
易证: 若$a > 2b$,则$a$一定有剩余,答案为$b$。否则,可以找到一种均匀的方案使得$a$、$b$尽可能多地利用,换言之,答案为$\frac{(a + b)}{3}$。  
```cpp
#include <cstdio>
#include <algorithm> 

using namespace std;

int main() {
	int a, b;
	scanf("%d %d", &a, &b);
	if(a < b) swap(a, b);
	if(a > 2 * b) {
		printf("%d\n", b);
	} else {
		printf("%d\n", (a + b) / 3);
	}
	return 0;
}
```

---

## 作者：违规用户名gAGt8$%z (赞：0)

## 思路
我们可以发现，一个组肯定是有3个人的，分别是：

1. 一个新手 两个老手

2. 一个老手 两个新手

这样的话我们将两组一打包，就成了三个老手 三个新手。

所以没有本质区别。

设较小数为 $x$ , 较大数为 $y$ ， 如果 x × 2  $<=$ y 的话，说明肯定有剩余，取 $x$;

否则取 $($ $x$ $+$ $y$ $)$ $/$ $3$

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int x,y;cin>>x>>y;
	if(x<y) swap(x,y);
	if(x>=2*y) cout<<y;	
	else cout<<(x+y)/3;
	return 0;
}
```



---

## 作者：Miracle_ZX (赞：0)

# Part 0 说在前面
此题虽是朴素算法，但分析得简洁不易。希望管理员大大让它过审~
# Part 1 分析
根据题意，我们有两种选择：  
1. 一个新手，两个老手。
2. 两个新手，一个老手。
其实，如果将这两种情况一打包，我们会发现，一个组刚好是 3 个老手，3 个新手。也就是说，新手和老手没有本质上的区别。

# Part 2 实现
因此，我们有两种方案：  
1.如果，较小的数乘二还小于等于较大的数，那么这样分配，肯定还会有剩余。所以，此时输出小数即可。  
2.既然新老手没有本质区别，那我们尽量让他们平均分配。
此时公式为$\frac{n + m}{3}$。
# Part 3 Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n, m;
	cin >> n >> m;
	if(n < m) swap(n, m);
    	//因为没有区别，所以默认 n 为大数
	if(n >= (2 * m)) cout << m;	
    	//大数比小数的两倍还多
	else cout << (m + n) / 3;
    	//为了平均
	return 0;//不写会爆零 ~
}
```
# Part 4 AC picture
![AC!](https://cdn.luogu.com.cn/upload/image_hosting/rs5kr432.png)

---

## 作者：Harry_Hedwig (赞：0)

# 0x00 思路
先看题。

~~废话好多……~~
>A认为一个合理的分组由**一个老手和两个新手**构成。B认为一个合理的分组由**两个老手和一个新手**构成。每一个分组都**必须是以上两种分组的一种**，同时**分出的组要尽量多**。现在我们知道一共有$n$ 位编程老手，$m$ 位新手，那么最多可以分成多少组呢？

不难发现，这 $2$ 种分组方法都是 $3$ 人一组，且都含有至少一个老手和一个新手，接着满足题目的分组情况算出值就可以了。

# 0x01 实现
很明显有 $2$ 种情况。由于每组都有 $3$ 个人，所以我可以先把所有人分成 $3$ 组。

如果人数少的一方人数比 $\frac{1}{3}$ 少，那么也就只能组成 $\min(n,m)$ 组。

否则（即人数少的一方人数大于等于总人数的 $\frac{1}{3}$）就一定可以且最多也只能组成 $\left \lfloor \frac {(n+m)} {3} \right \rfloor$ 组。

（注： $\left \lfloor x \right \rfloor$ 为不大于 $x$ 的最大整数）
# code:
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b;
    scanf("%d %d",&a,&b);
    if(min(a,b)<(a+b)/3)
    	printf("%d",min(a,b));
    else
    	printf("%d",(a+b)/3);//c++整数除法自动向下取整
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

发现本题题解区的题解~~几乎~~都是一种打法，故企鹅前来奉上一篇不同打法的题解～  
题目传送>>[CF519C](https://www.luogu.com.cn/problem/CF519C)  
### 题意简述：  
有 $n$ 个老手和 $m$ 个新手，组队训练可一老手 + 两手，亦可两老手 + 新手，问最多可组多少队。  
### 题目分析:  
根据分组规则我们可以发现无论是哪种组队方式其中必有一老手和一新手，只是第三者不同罢了。所以说我们只要有一个老手和一个新手，接着再选择加一个老手还是一个新手，使得组队数最多。而面临第三者的选择，我们考虑到要使新、老手尽可能的组上队，不能使任何一方剩余很多，那么就要尽可能地使剩余新、老手人数均衡，所以我们在选择第三者时优先选择剩余人中数量较多的那一方即可。  
### Code:  
```cpp
#include <iostream>
#include <cstdio> 
using namespace std;
int main()
{
	//freopen("input.in","r",stdin);
	//freopen("print.out","w",stdout);
	ios::sync_with_stdio(0);    //关同步流加速cin输入和cout输出
	int n,m;   //定义老手数、新手数
	int ans=0;   //定义组队数
	cin>>n>>m;
	while(n&&m)   //还有一老手＋一新手的组队前提
	{
		n--,m--;
		if(n||m)   //新、老手还有剩余
		{
			ans++;
			if(n>m) n--;   //第三者选择
			else m--;
		}
	}
	cout<<ans;
	return 0;	 //结束整个程序
}
```
### 结果（未吸氧）:  
![JieGuo](https://cdn.luogu.com.cn/upload/image_hosting/44nqwvlz.png)  
企鹅的题解到此结束，祝各位 OIers 进步 ++~

---

## 作者：FJ·不觉·莫笑 (赞：0)

### **读题：**  
分组的情况有两组：  
1. 一个老手+两个新手构成  
2. 两个老手+一个新手构成  
然后，我们将1和2相加，就会发现：  
#### 三个新手+三个老手可组成2组    
化简可得组数等于：  
$$\frac{n+m}{3}$$
    
------------     
### **思路：**
1.如果较大的数>>较小的数。直接输出较小的数。   
2.如果不是，输出$\frac{n+m}{3}$。 

------------
### **代码如下：**
``` cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m;
	cin>>n>>m;
	if(n<m)
		swap(n,m);
	if(n>=(2*m))
		cout<<m;	
	else
		cout<<(m+n)/3;
	return 0;
}
```

---

## 作者：yzx72424 (赞：0)

一道裸裸的暴力题目

首先对其中一种方案的个数进行枚举，再计算出另外一种的个数，每次取最大值即可。

```
#include <bits/stdc++.h>
using namespace std;
int n,m,ans,i; 	
int main(){
 	cin>>n>>m;
     for (;2*i<=n&&i<=m;i++)ans=max(ans,i+min(n-2*i,(m-i)/2)); 
     cout<<ans; 
}
```

---

## 作者：Otue (赞：0)

反正不管怎么样，

* 一个老手和两个新手

* 两个老手和一个新手

这两个有什么区别？就是调换一下顺序而已。

所以只要 $a>b$，就把他们交换一下，这时候，就可以想象成老手与新手的搭配，老手搭配完了，新手就没有办法了，因为顺序是正的，也就是说，当 $2a<b$ 时，输出 $a$（因为 $a$ 是最小的）。

其余的情况这样考虑：

列一个方程组，设第一种情况选了 $X$ 个，第二种选了 $Y$ 个，则：

$\begin{cases}X+2Y=a\\2X+Y=b\end{cases}$

则 $a+b=3(x+y)$，则输出 $\dfrac {a+b} 3$。

好啦，这道题做完啦！

---


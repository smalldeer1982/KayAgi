# Little Frog

## 题目描述

从前一个名叫 Vasya 的小青蛙决定在它家的沼泽里四处旅行。沼泽里有 $n$ 个位于一条线的土堆，相邻的土堆之间的距离是 $1$ 米。Vasya 想在一天内参观所有的土堆；此外，它想每一个都只去一次。为此，它制定了一个路线计划。Vasya 可以选择任何土丘作为起点。同时，它想要任何两次跳跃的路径的长度不同。请你帮助 Vasya 青蛙，完成它的计划。

## 样例 #1

### 输入

```
2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
3
```

### 输出

```
1 3 2 ```

# 题解

## 作者：Waaifu_D (赞：8)

不知道大佬们是怎么想那么复杂的，我这个蒟蒻只能手造个队列（也不能说是队列吧）来模拟。
#  思路

题意中要求每个 $p$ 都不相同，也就是一个土堆**不能重复跳**，解决这点很简单，我们只需要让青蛙在土堆的两侧反复横跳，每次往里面跳一格即可。

就像下图一样( $n=5$ )。

[![cm1hRg.png](https://z3.ax1x.com/2021/04/02/cm1hRg.png)](https://imgtu.com/i/cm1hRg)

(画的有点丑不好意思)

# Code

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[10005];
int tot=1,back;//tot为头部指针，back为尾部指针
int main()
{
	int n;
	cin>>n;
	back=n;//尾部指针定义
	for(int i=1; i<=n;i++)
	{
		a[i]=i;//赋值
	}
	for(int i=1; i<=n;i++)
	{
		if(i%2==1)//判断当前是在向哪里跳，若i为奇数就是在向左跳
		{
			cout<<a[tot++]<<" ";//跳到比之前往后一格的地方
		}
		else//为偶数向右跳
		{
			cout<<a[back--]<<" ";//跳到比之前往前一个的地方 __ 
		}
	}
    return 0;//好习惯
}
```



---

## 作者：子翮 (赞：2)


## ~~一道看懂题目描述就能AC的题~~ 

## 思路：
不难看出，以左端点为起点，跳向右端点，再跳到左端点前的点，跳向右端点前的点......总之，左右跳向最靠前的未跳过的的点
，得到的线段长分别为n-1,n-2....2,1。符合题目要求。

## 代码实现：

介绍一个c++自带的库：deque，别名双向队列，可以在队列的两端进行插入，弹出，查看队头队尾等一系列功能，具体使用请见  **车前草病毒大佬**  的 [C++ STL 双端队列deque](https://www.cnblogs.com/SWiper/p/6617774.html)这篇文章。 

deque解决了不能操作队列首部的问题，相对queue实用了许多。此题介绍一种deque的做法。

1. **将1~n压入deque中**
1. **队头队尾依次查询，输出，并弹出**
1. **完美AC ~~~**

不多说了，上代码

```cpp
#include<iostream>
#include<cstdio>
#include<deque>
using namespace std;
deque<int> dq;//建立双向队列
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) dq.push_back(i);//压入
	for(int i=1;i<=n;i++)
	{
		int tmp;
		if(i%2==1)//取模判断队头队尾
		{//队头
			tmp=dq.front();//查询对头
			cout<<tmp<<" ";
			dq.pop_front();//弹出队头
		} 
		else
		{//队尾
			tmp=dq.back();//查询队尾
			cout<<tmp<<" ";
			dq.pop_back();//弹出队尾
		}
	}
	return 0;
}


```


---

## 作者：薛定谔的诚 (赞：2)

### 1. 分析

首先，理解题意后，就可以很明显的看出是一道模拟题，一般这种题可以先找到一种方案，再用代码执行。

**这道题的思路还是比较好找的，首先看到题目中没有限定青蛙对多走几米，只限定了两次跳跃路径的长度不同，那么这道题可自由度就很高了。下面是一种最常用的方法**

### 2. 方法
#####   ~~秘技之左右横跳~~：
 
 为了不使跳跃路径长度重复，可以**从较大跨度慢慢往较小跨度**去跳，~~就像在天平上摆砝码一样~~，从大往小放。所以先从第一个土堆跳到第n个土堆，这时候跳了我 $n-1$ 步，然后从第n个土堆跳到第2个土堆，这时跳了 $n-2$ 步，一直循环到最中间，然后没走一个来回输出两个走到的土堆，这就是这种解法的核心思路。代码如下：

------------

```cpp
	for(int i = 1; i <= n / 2; i++){
		cout << i << ' ' << n - i + 1;
	}
```


------------


**注意，如果 $n$ 是奇数的话，最中间的那个数是遍历不到的**。举个栗子：
 当n为5时，按照原来的思路，这使得路径是：1-5-2-4，会发现3没有被遍历到,所以当n为奇数时，我们需要补一个 $(n/2+1)$ 。
 


### 3. 代码实现

现在思路已经清晰地出来了，下面是完整代码：

------------
```cpp
#include <bits/stdc++.h>
using namespace std; 

int main(){
	int n;//n表示土堆 
	cin >> n;
	for(int i = 1; i <= n / 2; i++){//因为是来回遍历，一次输出两个数，所以为了避免重复，循环条件是i<=n/2 
		cout << i << ' ' << n - i + 1 << ' ';
	}
	if(n % 2 == 1){//特判当n为奇数时的情况 
		cout << n / 2 + 1;
	} 
	return 0;
}
```


### 谢谢食用

---

## 作者：_lzh_ (赞：1)

## 思路

这是一道简单的模拟题，题目要求连续两次跳跃的距离不同，所以只需要在左右两端跳跃即可。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4gwibi0e.png)

## Code

```cpp
#include<bits/stdc++.h>
#define N 100010
using namespace std;
int n,noww=1,/*记录现在的位置*/leftend=0；/*记录之前跳过的左端点*/
int rightend,/*记录之前跳过的右端点*/ifleft=1;/*记录现在是否在左端*/
int main()
{
    cin>>n;
    rightend=n+1;//初始化右端点 
    for(int i=1;i<=n;i++)
    {
    	cout<<noww<<" ";//输出现在位置 
    	if(ifleft==1)//如果现在在左边 
		{
			leftend+=1;//左端点右移 
			noww=rightend-1;//跳到右端点的前一个位置 
			ifleft=0;//将位置设为右边 
		}
    	else//如果现在在右边 
		{
			rightend-=1;//右端点左移 
			noww=leftend+1;//跳到左端点的后一个位置 
			ifleft=1;//将位置设为左边 
		}
	}
    return 0;
}

```

---

## 作者：FJ·不觉·莫笑 (赞：1)

### **方法：秘技，反复横跳！**  


------------
### **读题：**  
小青蛙决定环游沼泽。沼泽里有$n$个位于同一行的土堆。相邻的土堆之间的距离是1米。它可以选择任何土丘作为起点，并且每一个土堆恰好只访问一次。同时，它想要连续两次跳跃的路径的长度不同。  


------------
### **思路：**  
可采用反复横跳的方法，即先从$1$跳到$n$,再从$n$跳到$2$，再从$2$跳到$n-1$，……这样得到的每一次跳跃的长度为$n$，$n-1$，$n-2$，各不相同。  


------------
### **上代码：**  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int now=1,l=0,r=n+1;     //now：当前位置,l：左端点，r：右端点
	cout<<1<<" ";             //一开始先输出1
	for(int i=1;i<=n-1;i++)   //注意是n-1
	{
		if(now==l+1)  
			l++,now=r-1;     //如果当前处于左端
		else  
			r--,now=l+1;     //如果当前处于右端
   		cout<<now<<" ";      //输出当前位置           
	}
	return 0;
}
```


---

## 作者：Siyuan (赞：1)

> ## 一道简单的模拟题！

## 本题思路：
首先考虑 **连续两次跳跃长度不同**，显然可以从最左边$\ 1$开始，每次都跳到 **另一端未被访问的点**。（如果是跳到左端，则跳到第一个未访问的；如果是右端则反正）

### 代码如下（极短）：

```
#include<cstdio>
using namespace std;

int main()
{
	int n;
	scanf("%d",&n);
	int pos=1,l=0,r=n+1;
    	//pos表示当然位置
   	    //l表示左端最后一次被访问的点，r表示右端最后一次被访问的点
	for(int i=1;i<=n;i++)
	{
		printf("%d ",pos);
		if(pos==l+1)  l++,pos=r-1;     //如果当前处于左端（以下反之）
		else  r--,pos=l+1;
	}
	return 0;
}
```

---

## 作者：Yydy_RedDust (赞：0)

~~一道不用脑子都能想出来的水题~~
## 思路
因为要使青蛙每次跳跃距离不同，所以青蛙只需跳向最左端或最右端即可  
为了使代码更加简单，我们可将其转化————  
从1开始到中点，输出1，输出2关于中点的对称点，输出3，……，以此类推  
## 贴上代码：
```cpp
#include<bits/stdc++.h>
#define rep(a,b,c) for(int a=b;a<=c;a++)
#define AC return 0
using namespace std;
int n;
int main()
{
	//freopen("CF53C.in","r",stdin);
	//freopen("CF53C.out","w",stdout);
	cin>>n;
	rep(i,1,n/2)
		cout<<i<<' '<<n-i+1<<' ';
	if(n%2) 
		cout<<n/2+1; //如果是奇数，应当输出中点
	//fclose(stdin);
	//fclose(stdout);
    AC;
}
```

---

## 作者：Allanljx (赞：0)

[洛谷传送门](https://www.luogu.com.cn/problem/CF53C)

[CF传送门](http://codeforces.com/problemset/problem/53/C)
## 题意
有 $n$ 块土堆，可以从任何一个土堆出发，每次可以跳跃任意距离到达另外的一个土堆。要让每次跳跃的距离都不相等，请找到这样的一个方案并输出。
## 思路
每次跳到当前没跳到过的地方的最右边或最左边。如果当前在最左边，你么就跳到没跳过的地方的最右边，反之亦然。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
	int n,mid,f;
	cin>>n;
	mid=n/2;//记中点 
	if(n%2==0)//记录当前是奇数还是偶数 
	{
		f=0;
	}
	else
	{
		f=1;
	}
	if(n==1)//特判 
	{
		cout<<1;
		return 0;
	}
	if(n==2)//特判 
	{
		cout<<1<<' '<<2;
		return 0;
	}
	cout<<1<<' '<<n;//处理空格 
	for(int i=2;i<=mid;i++)//输出下一个要跳到的地方 
	{
		cout<<' '<<i<<' '<<n-i+1;
	}
	if(f==1) cout<<' '<<mid+1;//输出中点 
    return 0;
}
```


---

## 作者：Eason_AC (赞：0)

## Content
有一只小青蛙想游历 $n$ 块土堆，它现在在 $1$ 号土堆上，每次可以跳跃任意距离到达另外的一个土堆。它想让每次跳跃的距离都不相等，试找到这样的一个方案。

**数据范围：$1\leqslant n\leqslant 10^4$。**
## Solution
我们可以尝试左右横跳的方式，从 $1$ 跳到 $n$，再从 $n$ 跳到 $2$，再从 $2$ 跳到 $n-1$……以此类推，直到所有的土堆都遍历过为止。
## Code
```cpp
int n;

int main() {
	getint(n);
	int i = 1, cur = 1;
	while(cur <= n) {
		printf("%d ", i);
		if(cur % 2)	i += (n - cur);
		else	i -= (n - cur);
		cur++;
	}
	return 0;
}
```

---

## 作者：xgwpp6710 (赞：0)

既然只需要找到一种解法，那么我们找一个通解就可以了。

我们发现（自动省略其中的推理过程），从 $1$ 号开始，每次跳到对面的端点，那么每一步的距离正好是 $n-1,~n-2,~...,~1$ ，满足要求。此时跳土堆的顺序是 $1,~n,~2,~n-1,~...$ 以此类推。

因此代码如下：
```cpp
#include<cstdio>
int n; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n/2;i++) printf("%d %d ",i,n+1-i);//通式，请同学们自己推
	if(n%2) printf("%d",n/2+1);//特判，奇数的话中间的那个数搜不到
	return 0;
}
```
[AC记录](/record/35493554)，请放心食用！

---

## 作者：HPXXZYY (赞：0)

**【思路】：**

我们可以知道，我们的小青蛙需要跳$n-1$步，而每一步的长度不能一样，而且每一步跳的长度大于等于$1$，且小于等于$n-1$。

这意味着什么？这意味着小青蛙每一次跳的长度正好覆盖了$1$到$n-1$里的所有整数。也就是说，把小青蛙每一步的距离从小到大排序后，正好是序列$1,2,3,4...n-1$！

因为我们可以输出任意一种方案，所以我们把问题简化：只考虑每一步的距离递减或递增。

递增显然不行。比如有$5$个石头，第一步的距离为$1$，跳到了$2$；第二步的距离为$2$，跳到了$4$；第三步距离一个为$3$，但是向前跳跳出了沼泽地，向后跳又回到了$1$，不符合题意。

递增不行，我们考虑递减。第一步跳的距离为$n-1$，跳到$n$；第二步距离为$n-2$，跳回$2$；第三步距离为$n-3$，跳到$n-1$……

所以，我们可以发现，无论$n$是多少，序列$1,n,2,n-1,3,n-2,4,n-3...$总是我们需要的答案。

**【代码】：**
```cpp
int main(){
	int n;scanf("%d",&n);
	for(int i=1;i<=n/2;i++)
		printf("%d %d ",i,n+1-i);
	if (n%2) printf("%d",n/2+1);
	return 0;
}
```

---


# Bets

## 题目描述

在chelyabinsk这个地方住着一个厉害的商人，他叫nikita。人人都叫他boss (老板的意思)。

有一天nikita跟朋友alex一起去一个叫做summer biathlon world cup (夏日滑雪世界杯？。)的比赛。

nikita因为是一个厉害的人，所以他拿到了一个神奇奖券。这个奖券可以让他赌谁赢，每个赛道不能赌超过一个选手。



------------


------------


这个比赛的规则是这样的：

有n个相等长度的赛道以及m个参赛者（编号1到m）。对于每个参赛者有以下信息：

- Li：始发赛道号码

- Ri：结束赛道号码（Li<=Ri）

- Ti：这个选手完成一个赛道的时间

- Ci：利润。。。单位是卢布（俄罗斯货币单位）。如果这个选手赢了，那么赌这个人会赢的人可以获得这么多钱。


第i个选手穿过从Li到Ri的赛道（包括Li和Ri），时间为(Ri-Li+1)·Ti个单位时间。每个赛道都需要Ti个单位时间。若这个选手在k个赛道中获得胜利，那么赌他会赢的人可以拿到k·Ci卢布。


在每个赛道中，每个独立的获胜者符合：


- 如果至少有一个选手在这个赛道中比赛，那么获胜者为花时间最少的人。花时间最少指仅在这个赛道上的花时间最少的人。


- 如果有多个选手用相同的时间，那么序号小的选手获胜。

- 如果这个赛道上没有选手，那么就没有获胜者。

注意：每个人的速度始终不变。


nikita可以在每个赛道上分别赌任何一个选手会赢。


帮助nikita和alex找到最大的利润。



------------


------------

## 说明/提示

**第一个测试数据**

第1-2个赛道赌选手1。

第3个赛道赌选手3。

第4个赛道赌选手4。

利润为5（赛道1）+5（赛道2）+30（赛道3）+20（赛道4）=60卢布。

**第二个测试数据**

第1，5个赛道赌选手1。

第2-4个赛道赌选手2。

第6-7个赛道赌选手4。

第八个赛道没有获胜者。

利润为10（赛道1）+15（赛道2-4）+10（赛道5）+20（赛道6，7）=105卢布。

## 样例 #1

### 输入

```
4 4
1 4 20 5
1 3 21 10
3 3 4 30
3 4 4 20
```

### 输出

```
60```

## 样例 #2

### 输入

```
8 4
1 5 24 10
2 4 6 15
4 6 30 50
6 7 4 20
```

### 输出

```
105```

# 题解

## 作者：Anonymous__user (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF69B)。

**题目大意**：有   $  n  $   个相等长度的赛道以及  $  m  $  个参赛者（编号  $  1  $  到  $  m  $）。如果这个选手赢了，那么赌这个人会赢的人可以获得利润。请帮助    nikita  和   alex    找到最大的利润。


**思路**：$ x $  数组表示最少花费时间， $ y $  数组表示最大利润。首先初始化一下  $ x $  数组，然后枚举      $ l_{i} $     到     $ r_{i} $ ，单独计算一下每个赛道的利润，与  $ x $  数组进行比较，如果小于  $ x $  数组，那么更新一下  $ x $  数组和  $ y $  数组，找到每个赛道的最大利润，最后累加，就是答案。

**代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans,x[1010],y[1010],l,r,t,c;
int main(){
	cin>>n>>m;
	for(int i=1;i<=110;i++)x[i]=1234567890;
	for(int i=1;i<=m;i++){
		cin>>l>>r>>t>>c;
		for(int k=l;k<=r;k++){
			if(t<x[k]){
				x[k]=t;
				y[k]=c;
			}
		}
	}
	for(int i=1;i<=n;i++)
		ans=ans+y[i];
	cout<<ans;
	return 0;	
}
```


---

## 作者：shenmadongdong (赞：1)

统计一下每个赛道所能获得的最大利润即可

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,l,r,a[105]={0},k[105],t[105],i,j,p=0;
int main()
{
    ;;;;;
    cin>>n>>m;
    for(i=1;i<=m;i++)
    {
        cin>>l>>r>>t[i]>>k[i];
        for(j=l;j<=r;j++)  if(!a[j]||t[i]<t[a[j]]) a[j]=i;//统计获胜选手
    }
    k[0]=0;
    for(i=1;i<=n;i++) p+=k[a[i]];//统计最大利润
    cout<<p<<endl;
    return 0;
}
```

---

## 作者：幻想繁星 (赞：0)

解题思路：我们可以单独去计算出每一个赛道中最快的人，每一次取最大值，保存当前最大值的位置。最后把那些针对于每一个赛道的赌徒的赌资累加。

实现方法：$x_i$ 表示最少花费时间，$y_i$ 表示最大利润。首先初始化一下 $x$，然后枚举 $l_i$ 到 $r_i$，单独计算一下每个赛道的利润，与 $x_i$ 进行比较，如果小于 $x_i$ ，那么更新一下 $x_i$ 和 $y_i$ ，找到每个赛道的最大利润，最后累加，就是答案。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,m,ans=0,x[1005],y[1005]={};
	cin>>n>>m;
	memset(x,0x3f3f,sizeof(x));
	for(int i=1;i<=m;i++)
	{
		int l,r,t,c;
		cin>>l>>r>>t>>c;
		for(int j=l;j<=r;j++) if(t<x[j])
		{
			x[j]=t;
			y[j]=c;
		}
	}
	for(int i=1;i<=n;i++) ans=ans+y[i];
	cout<<ans;
	return 0;	
}
```


---

## 作者：Fr0sTy (赞：0)

### 题意简述
------------

给定两个整数 $n$，$m$。分别代表有 $n$ 条赛道，$m$ 个运动员。

接下来 $m$ 行，每行 4 个整数 $l_i , r_i , t_i , c_i$。分别代表这位运动员从 $l_i$ 滑到 $r_i$，每一段赛道花费的时间为 $t_i$，这个赌注值 $c_i$ 卢布。

问最大收益是多少。

### 解题思路
------------

建两个数组 $maxx , mon$，分别表示这一个赛道的最短时间和这个最短时间所对应的赌注的收益。

每次输入，枚举 $l_i$ 到 $r_i$。如果这位选手的时间大于 $maxx_i$，就更新这个 $maxx_i$ 和 $mon_i$。

最后从 $1$ 到 $n$ 枚举一遍，累加 $mon_i$ 即可。

### 代码实现
------------

``` cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
int n,m,ans;
int maxx[1000005],mon[1000005];
int main() {
	memset(maxx,inf,sizeof(maxx));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) {
		int l,r,t,c; scanf("%d%d%d%d",&l,&r,&t,&c);
		for(int j=l;j<=r;j++) {
			if(t<maxx[j]) maxx[j]=t,mon[j]=c;
		}
	}
	for(int i=1;i<=n;i++) ans+=mon[i];
	printf("%d",ans);
	return 0;
}
//code by TheCedar
```

---

## 作者：小杨小小杨 (赞：0)

## 题意
就是给你好几个人，然后放到一个地方比赛，问你在某一个赛到的第一名是谁。
## 思路
一道大水题吧。   
考虑到：

1. 如果至少有一个选手在这个赛道中比赛，那么获胜者为花时间最少的人。花时间最少指仅在这个赛道上的花时间最少的人。

2. 如果有多个选手用相同的时间，那么序号小的选手获胜。

3. 如果这个赛道上没有选手，那么就没有获胜者。

那么我们可以针对每一个赛道，单独去计算出每一个赛道中最快的那个人，每一次取第一个最大值，保存当前最大值的位置（而不是值，方便后面累加）。最后就把那些针对于每一个赛道的赌徒的赌资累加就行。因为当前的选手滑动有范围，所以只要在范围内取值就行。   
**记得加上初始化！！！！**
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,a[10001],b[1001],tag[1001],ans,l,r,j;
int main(){
	scanf("%d%d",&n,&m);
	a[0]=2e9;//初始化，防止下面tag初始为0的情况。
	for (i=1;i<=m;i++){
		scanf("%d%d%d%d",&l,&r,&a[i],&b[i]);//读入（不用说了吧）
		for (j=l;j<=r;j++)
			if (a[tag[j]]>a[i]) tag[j]=i;//分别计算出每一个赛道的最快的那个人（保存下标）
	}
	for (i=1;i<=n;i++) ans+=b[tag[i]];//累加赌资
	printf("%d\n",ans);
	return 0;
}

```


---


# Image

## 题目描述

你有一个大小为 $2×2$ 的图像文件，由 $4$ 个像素组成。每个像素可以具有 $26$ 种不同颜色中的一种，由小写拉丁字母表示。


你希望对图像的某些像素重新着色，以便所有 $4$ 个像素具有相同的颜色。在一次操作中，你可以选择至多两个相同颜色的像素并将它们绘制成其他颜色（如果选择两个像素，则应将它们绘制为相同颜色）。


为了实现你的目标，你必须采取的最少行动数是多少？

## 样例 #1

### 输入

```
5
rb
br
cc
wb
aa
aa
ab
cd
yy
xx```

### 输出

```
1
2
0
3
1```

# 题解

## 作者：Dry_ice (赞：7)

题链：[cf](https://codeforces.ml/contest/1721/problem/A) [luogu](https://www.luogu.com.cn/problem/CF1721A)

[cnblogs浏览](https://www.cnblogs.com/dry-ice/p/cf1721a.html)

> 作为 A 题名副其实。

## Description
给你一个由小写字母组成的 $2\times2$ 矩阵，每次可以把不超过两个相同的字母变成任意其他字母，问最少几步能把 $2\times2$ 矩阵中的所有字母变成一样的。

## Analysis
这题其实没什么好说的：答案**只可能为 $0$、 $1$、 $2$ 或 $3$**。

1. ```ans = 0```：原图就是 $4$ 个字母一样，**不动**即可；
2. ```ans = 1```：原图每种字母的个数为 **$2$ 和 $2$** 或 **$3$ 和 $1$**；
3. ```ans = 2```：原图每种字母的个数为 **$2$、$1$ 和 $1$**；
4. ```ans = 3```：原图每种字母的个数都为一个，即有四个字母都不同。

综上所述，有两种做法：你可以按照枚举分类讨论输出，也可以找到规律：统计**不同字母的个数 $res$**，最终的答案即为 $res - 1$。

## Code
看很多dalao用 ```set``` 集合的不可重复性来去重，最后直接输出 ```st.size() - 1``` 即可。笔者这里给出朴素的桶写法。

```cpp
#include <stdio.h>
int main(void) {
    int t; for (scanf("%d", &t); t--; ) {
        int t[30] = {0}, res = 0; char s[5];
        for (int i = 1; i <= 2; ++i) {
            scanf("%s", s + 1); //行行读入，在线处理
            for (int j = 1; j <= 2; ++j)
                if (!t[s[j] - 'a']) ++res, t[s[j] - 'a'] = 1; //统计不同字母数
        }
        printf("%d\n", res - 1);
    }
    return 0;
}
```

## The end. Thanks.

~~(拇指点点~~

---

## 作者：WhiteSunFlower (赞：2)

每组数据只有 $4$ 个像素，所以共有 $1 \sim 4$ 种像素，把相同的放在一起，于是就有下面几种分配的可能：
```
1,1,1,1
1,1,2
1,3
2,2
4
```
手搓一下，发现：

```
1,1,1,1	=> 3 steps
1,1,2 	=> 2 steps
2,2 	=> 1 steps
1,3 	=> 1 steps
4		=> 0 steps
```

那不就是像素的颜色总数减 $1$ 吗。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
char c[4];
int t;
int main(){
	ios::sync_with_stdio(0);
	cin >> t;
	while(t--){
		cin >> c[0] >> c[1] >> c[2] >> c[3];
		sort(c,c+4);
		int diff=1;
		for(int i=1;i<=3;i++)if(c[i]!=c[i-1])diff++;
		cout << diff-1 << endl;
	}
	return 0;
}
```

欧克，掰掰 $\sim$


---

## 作者：SamHJD (赞：1)

**题意：**

每次可以拿出**一个或两个**颜色相等的元素，转换为另一种颜色，求最少步骤。

转换颜色的操作没有规定必须相邻什么的，所以我们可以只看**颜色的种类**来判断。


------------
  

一张图片一共有以下几种情况：

```
aa  aa  aa  ab
aa  bb  bc  cd
```
也就是只有一种颜色、两种颜色、三种颜色和四种颜色，我们分别来看。

**一种颜色**：不用操作，也就是输出 $0$。

**两种颜色**：我们任取一种颜色，将它变为另一种颜色即可，输出 $1$。

**三种颜色**：我们将两个相同颜色的像素转换为另一种颜色，再按两种颜色的情况处理，输出 $2$。 

**四种颜色**：我们任取一种颜色转换为另一种颜色，再按三种颜色的情况处理，输出 $3$。 

不难发现规律，答案就是**颜色种类减一**。从另一个角度来想，每次操作能减少一种颜色，我们将除某种颜色以外的所有颜色操作一次，就达到了目的。

注意如何判断有多少种颜色：

```cpp
map<char,bool> mp;
int s=-1;mp.clear();//map一定要清空!
cin>>c[1][1]>>c[1][2];//读入
cin>>c[2][1]>>c[2][2];
for(int j=1;j<=2;++j){
    for(int k=1;k<=2;++k){
        if(mp[c[j][k]]==0) s++,mp[c[j][k]]=1;
        //如果没出现过，设为出现过，种类加一
    }
}
```

**完整代码**：

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[3][3];
int T;
map<char,int> mp;
int main(){
    cin>>T;
    for(int i=1;i<=T;++i){
        int s=-1;mp.clear();
        cin>>c[1][1]>>c[1][2];
        cin>>c[2][1]>>c[2][2];
        for(int j=1;j<=2;++j){
            for(int k=1;k<=2;++k){
                if(mp[c[j][k]]==0) s++,mp[c[j][k]]=1;
            }
        }
        cout<<s<<endl;
    }
    return 0;
}

```



---

## 作者：wimg6_ (赞：1)

## CF1721A 题解

### 题意简述

$t$ 组数据，每组数据有 $2\times 2$ 个英文字母，请输出最小的变换次数，使得这四个英文字母相同。

### 解题过程

为方便描述，将每组数据中的 $2\times 2$ 个英文字母集合记为 $S$。

不难发现，如果将 $S$ 中所有字母替换为 $q,q\not\in S$，则一定不是最优的。对于 $S$，定 $\exists\ q,q\in S$，可使替换次数更少。

顺理成章地，我们想到：可以统计 $S$ 中不同字母的个数，记为 $s$，最后输出 $s-1$ 即可。

### 完整代码

```
#include<bits/stdc++.h>
using namespace std;
int t;
int main()
{
	ios::sync_with_stdio();
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--)
	{
		int a[5][5],p[30],s=0;
		memset(a,0,sizeof(a));
		memset(p,0,sizeof(p));
		for(int i=1;i<=2;i++)
			for(int j=1;j<=2;j++)
			{
				char c;
				cin>>c;
				p[c-'a'+1]++;
			}
		for(int i=1;i<=26;i++)
			if(p[i]!=0) s++;
		cout<<(s-1)<<"\n";
	}
}
```


---

## 作者：olegekei (赞：1)

因为每个数据只有 4 个像素，而且不需要考虑每个像素的位置，所以情况很少，可以讨论情况，

~~但是本人较懒不想讨论~~，直接 sort 排序找到出现次数最多的像素，再把剩下字符的数量数一下输出即可

那么问题来了，为什么可以这样写呢？（~~因为每组数据只有 4 个像素~~）

虽然每次最多只能给 2 个像素染色，但是因为每组数据最多只会出现 4 个像素，则可以发现当前数据中只要**有一种像素出现两次及以上时**涂其余的像素就可以是最小行动数

举个例子：
```
qq
we
```
这组样例中 ``` q ``` 出现了两次，则把 ``` w ``` 和 ``` e ``` 涂成 ``` q ``` （输出 2）

当然，把两个 ``` q ``` 和 ``` w e ``` 的其中一个涂成另一个像素也可以


代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot[800000];//其实不用开这么大
bool cmp(int a,int b){return a>b;}
int main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  int t;
  cin>>t;
  while(t--){
      char a,b,c,d;
      cin>>a>>b>>c>>d;//4个字符
      tot[a]++;
      tot[b]++;
      tot[c]++;
      tot[d]++;
      int minn=min(a,min(b,min(c,d))),maxn=max(a,max(b,max(c,d)));
      sort(tot+minn,tot+maxn+1,cmp);
     //也可以不用cmp，在后面从maxn往前枚举
      int cnt=0;
      for(int i=minn+1;i<=minn+3;i++)if(tot[i])cnt++;//记录剩下像素的种类个数
      cout<<cnt<<'\n';//直接输出即可
      for(int i=minn;i<=minn+3;i++)tot[i]=0;//数组归零（初始化）
  }
  return 0;
}
```

---

## 作者：xiaomuyun (赞：1)

- [洛谷传送门](https://www.luogu.com.cn/problem/CF1721A)
- [CodeForces 传送门](https://codeforces.com/contest/1721/problem/A)

## 题目分析

实际上我们完全可以抛开具体的颜色不管，只要看整个文件中有几种颜色即可。

- 如果一共只有 $1$ 种颜色，那么不用操作就能达到目标（或者说是 $0$ 次操作）。
- 如果一共有 $2$ 种颜色，就还有两种情况：
  - 一种情况是有 $2$ 个像素点是一种颜色，另外 $2$ 个像素点是另外一种颜色，这样需要花费 $1$ 次操作将其中一种颜色的像素点上色成另外一种颜色。
  - 另一种情况是有 $3$ 个像素点是一种颜色，另外 $1$ 个像素点是另外一种颜色，这样花费 $1$ 次操作将那 $1$ 个像素点上色成另外那 $3$ 个像素点的颜色即可。
- 如果一共有 $3$ 种颜色，那肯定有且仅有 $2$ 个像素点的颜色是相同的。这时只需要花费 $2$ 次操作，分别将另外 $2$ 个只有自己本身是自己的颜色的像素点上色成有 $2$ 个像素点的颜色是相同的那个颜色。
- 如果有 $4$ 种颜色，就花费 $3$ 次操作，将其中 $3$ 个像素点上色成最后一个像素点的颜色即可。

我们可以用 `1`、`2`、`3` 和 `4` 来模拟
颜色（因为最多只会有 $4$ 种不同的颜色）以及上色的过程。

- 如果一共只有 $1$ 种颜色，那么就是：
```plain
1111
↓
1111
```
- 如果一共有 $2$ 种颜色，那么有两种情况：
```plain
情况 1:
1112
↓
1111
情况 2:
1122
↓
1111
```
其它的，比如 `1121` 这样的情况也可以用 `1112` 的情况来概括。
- 如果一共有 $3$ 种颜色，那么是这样：
```plain
1123
↓
1113
↓
1111
```
- 如果一共有 $4$ 种颜色，那么就是这样：
```plain
1234
↓
1134
↓
1114
↓
1111
```

综上所述，答案为 一共有的颜色数量 $-1$。
## 代码实现

~~大材小用地~~用 `set` 去重，从而得到一共有的颜色数量。
```cpp
#include<iostream>
#include<cstdio>
#include<set>
using namespace std;
int t;
char a,b,c,d;
set<int> s;
int main(){
	scanf("%d",&t);
	while(t--){
		s.clear();//初始化
		cin>>a>>b>>c>>d;
		s.insert(a);
		s.insert(b);
		s.insert(c);
		s.insert(d);
		printf("%d\n",s.size()-1);
	}
	return 0;
}
```

---

## 作者：sgl654321 (赞：1)

### 题目大意
- 给定一个 $2\times 2$ 的矩阵，由四个颜色组成。
- 每次修改可以选择 $1$ 或 $2$ 个相同的颜色改成另一种颜色。请问修改几次才能使四个像素的颜色相同？

### 解题思路
第一步先统计有多少种不同的颜色，然后再分类讨论。
1. 若有 $4$ 种不同的颜色，则需要修改 $3$ 次，即把其中的三个颜色都分别改成另一个颜色。
2. 若有 $3$ 种不同的颜色，则需要修改 $2$ 次。有 $3$ 种不同的颜色，则这三种颜色一定是 $1+1+2$ 的情况。把两个 $1$ 的颜色都改成 $2$ 的颜色就可以了。
3. 若有 $2$ 种不同的颜色，则需要修改 $1$ 次。有两种情况： $1+3$ 或 $2+2$。如果是 $1+3$ 的情况，那么把 $1$ 的颜色改成 $3$ 的颜色。如果是 $2+2$ 的情况，那么把其中一个 $2$ 的颜色同时改为另一个 $2$ 的颜色。
4. 若所有颜色都相同，则需要修改 $0$ 次。
### 参考代码
本题有多组数据。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,num;
char a[4];
long long ch[1000];
int main(){
	cin>>t;
	while(t--){
		memset(ch,0,sizeof(ch));
		num=0;
		for(int i=1;i<=4;i++){
			cin>>a[i];
			ch[a[i]]++;
		}
		for(char i='a';i<='z';i++)
			if(ch[i]>0)
				num++;
		if(num==1)
			cout<<0<<endl;
		if(num==2)
			cout<<1<<endl;
		if(num==3)
			cout<<2<<endl;
		if(num==4)
			cout<<3<<endl; 
	}
	return 0;
}
```

---

## 作者：Moyou (赞：1)

# 思路

首先，看到题目，第一反应是**贪心**。

那么既然是贪心，我们贪什么呢，既然题目求的是最小行动数，那么我们得 取每种颜色像素个数最多的那种颜色作为最终目标颜色，因为这样可以使染色次数尽可能地少。

找到最终颜色后我们只需要将剩余所有颜色染成这个颜色即可，根据观察发现，我们处理一个剩余颜色 **只需要一次行动**。为什么呢？
> 题目中说：你有一个大小为 $2×2$ 的图像文件，由 $4$ 个像素组成。

> 并且我们可以一次性染两个相同的颜色，对于剩余颜色的集合，每种颜色的数量不会超过 $3$ 或 $4$。
>> 一旦它的个数超过了 $3$ 或 $4$，那么他就必然是目标颜色，也就不会出现在剩余集合中，得证。

所以，我们的答案就是 **$颜色数 - 1$** ，其中的 $1$ 是最终颜色，不用染。

# 代码

```cpp
#include <iostream>
#include <set>
using namespace std;

int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        string a, b;
        cin >> a >> b;
        a += b;
        set<char> s(a.begin(), a.end()); // 用set去重，筛出颜色种数
        int ans = s.size() - 1;
        cout << ans << endl;
    }
    return 0;
}
```


---

## 作者：RAVE_LOVEo_O (赞：0)

~~一道大水题。~~

就是让你进行染色，每次把两块染成同一种颜色。我的想法是考虑五种情况：

- 四个颜色都一样，就是不用染色。
- 有两种不同颜色，一个颜色有三块，我们只需要染另外那个只有一种颜色的方块。
- 有两种不同颜色，一个颜色有两块，染一次就行了（染两个方块一次就行了）。

- 有三种不同颜色，一个颜色有两块，别的都是一块。不难发现，从三种颜色中任意挑两种染就行了，所以是两次。
- 四种颜色都不一样，任意染三种颜色就可以了。

可以发现，最少染色数就是不同颜色数减一。

于是我们找出有几种不同颜色就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,c[30],s,i;//定义变量。
string a,b;
int read()//快读
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+(ch-'0');
		ch=getchar();
	}
	return x*f;
}
int main()
{
   t=read();//输入组数。
   while(t--)
   {
      s=0;
      cin>>a>>b;
      memset(c,0,sizeof c);//做前清零。
      c[a[0]-'a']++;//累计，放在一个桶里。
      c[a[1]-'a']++;
      c[b[0]-'a']++;
      c[b[1]-'a']++;
      for(i=0;i<30;i++)//找有几种不同的颜色。
         if(c[i])s++;
      write(s-1);//输出时减一。
      puts("");//快速换行。
   }
   return 0;//完结撒花！！！
}
```


---


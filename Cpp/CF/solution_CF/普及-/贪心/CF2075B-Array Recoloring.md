# Array Recoloring

## 题目描述

给定一个大小为 $n$ 的整数数组 $a$。初始时，数组所有元素均被涂为红色。

你需要执行以下操作：
1. 选择恰好 $k$ 个元素并将其涂为蓝色；
2. 在存在至少一个红色元素的情况下，反复选择任意一个与蓝色元素相邻的红色元素并将其涂为蓝色。

涂色成本定义为以下两部分之和：
- 初始选择的 $k$ 个元素之和；
- 最后一个被涂色的元素的值。

你的任务是计算给定数组可能达到的最大涂色成本。

## 说明/提示

第一个示例中，初始涂色第 $2$ 个元素，随后按顺序涂色第 $1$、$3$ 个元素。涂色成本为 $2 + 3 = 5$。

第二个示例中，初始涂色第 $1$ 和第 $5$ 个元素，随后按顺序涂色第 $2$、$4$、$3$ 个元素。涂色成本为 $4 + 3 + 3 = 10$。

第三个示例中，初始涂色第 $2$、$3$、$4$ 个元素，随后涂色第 $1$ 个元素。涂色成本为 $2 + 2 + 2 + 2 = 8$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
3 1
1 2 3
5 2
4 2 3 1 3
4 3
2 2 2 2```

### 输出

```
5
10
8```

# 题解

## 作者：Luolirui2012 (赞：8)

## 思路
这道题需要分类讨论。

当 $k > 1$ 时。

我们可以直接输出前 $k + 1$ 大的数的和。

我们选 $k$ 个数涂成蓝色时，只需要从前 $k + 1$ 大的数中两边开始选最终在中间留下一个包含在前 $k + 1$ 大的数我们就可以取到前 $k + 1$ 大的数。

当 $k = 1$ 时。

分两种情况。

第一种情况最大值和次大值分别在两端。

任意选择一段涂成蓝色都行。

第二种情况最大值和次大值一个在一端一个在中间一个在中间。

先选中间那个在涂色就行。

剩余情况最大值和次大值都在中间。

这个情况我们就取不到最大值和次大值了，只能按前两种情况做了。
## 代码
``` cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int t, n, k, a[5010], ans = 0;

signed main()
{
	cin >> t;
	while (t--)
	{
		ans = 0;
		cin >> n >> k;
		for (int i = 1 ; i <= n ; i++)
		{
			cin >> a[i];
		}
		if (k != 1)
		{
			sort(a + 1, a + n + 1);
			for (int i = n ; i >= n - k ; i--)
			{
				ans += a[i];
			}
			cout << ans << endl;
		}
		else
		{
			int maxx = 0;
			for (int i = 2 ; i <= n - 1 ; i++)
			{
				maxx = max(maxx, a[i]);
			}
			cout << max(maxx + max(a[1], a[n]), a[1] + a[n]) << endl;
		} 
	}
	return 0;
} 
```

---

## 作者：cflsfzh (赞：2)

适合**入门者**看的，大佬请速通。

首先，我们知道拿了 $k$ 个过后就是**一个一个**的拿，可以发现其实 $1$ 和 $n$ **并不相邻**。

先考虑很容易想到的结论：答案是最大的 $k+1$ 个。现在需要证明它的正确性。证明：我们先将这最大的 $k+1$ 个在数组 $a$ 中找出。只要我们取到最左边的和最右边的，中间的随便取 $k-2$ 个，我们一定能通过一个个染色使得最后一个，即在第一轮取 $k$ 个时没取到的是最后一个染色的。

还没懂？我们设这个没取到的为 $i$，显然它夹在第一轮取得的数的中间。设它夹在位置 $x$ 和 $y$ 间，显然我们可以通过染色挨个挨个从 $x$ 向右染到位置 $i-1$，不染 $i$，接着从 $y$ 向左染到位置 $i+1$，然后考虑这个连续子序列外的红色，显然可以都染成蓝色，最后在把位置 $i$ 染成蓝色并计入它的贡献。

还是没懂？考虑用我们这种方法取点，一定能保证我们的可染色的点集始终大小 $>1$，所以就算我们需要的那个点在可染色的点集中，我们也一定可以选择其他点进行染色，保证我们需要的那个点是在最后染的。

你以为做完啦？我们又发现 $k$ 的范围是 $1 \leq k < n$，不难发现这个证明只适合当 $k \geq 2$ 的时候适用，所以我们还需分类讨论当 $k=1$ 的情况。

结论：我们会计入两个点的贡献，其中一个要么是第 $1$ 个要么就是第 $n$ 个，另一个随便。证明：第一个可以随便乱取，第二个只能取边界，即第 $1$ 个或者是第 $n$ 个，不然的话，我们无法绕过取的第二个点到另一边，这是显而易见的。

最终这道题就可以愉快的切掉啦！

[AC code。](https://codeforces.com/contest/2075/submission/311186499)

---

## 作者：A_R_O_N_A (赞：1)

## 题意

给你 $n$ 个点，每个点有一个点权 $a_i$，初始时点全部都为红色，你需要选择 $k$ 个点，将其染成蓝色，随后你需要执行以下操作：

- 只要还有点是红色的，那么你就需要把一个**挨着蓝色点**的红色点染成蓝色。

求选择的 $k$ 个点以及**最后一个**被染成蓝色点的点权之和的最大值。

## 思路

我们可以先思考一下最后一个被染成蓝色的点的位置到底能够出现在哪里。设有且仅有两个红色点位于 $l,r$ 且 $l<r$，则最后一个被染成蓝色的点的位置应该是在 $\{1,(l,r),n\}$ 里面的其中一个位置。如果 $l,r$ 位于边界处，把 $1,n$ 排除掉就行了。$(l,r)$ 里面任何一个位置都能作为最后一个被染成蓝色点的位置的结论证明很显然：设我们想要的位置为 $pos$，那么我们很明显可以先一步一步染 $(l,pos)$，再染 $(pos,r)$，最后染 $pos$，这个过程有点类似于扩张。

上述情况是 $k=2$ 的情况，现在我们来思考 $k=3$ 的情况：设选择的三个点的位置为 $x_1,x_2,x_3$（$x_1<x_2<x_3$）。很明显最后一个被染成蓝色点的位置应该在 $\{1,(x_1,x_2),(x_2,x_3),n\}$ 之中，我们对于单个区间 $(x_1,x_2)$ 的处理同样可以类比上述过程。很明显上述过程满足可并性。再把区间合并起来，就变成了 $(x_1,x_3)$，与 $k=2$ 的情况无异了。

现在推广到一般情况，设我们选择的点的位置为 $x_1,x_2,x_3,\dots,x_k$（$x_1<x_2<x_3< \dots <x_k$），那么最后一个被染成蓝色的点的位置就应该是 $\{1,(x_1,x_k),n\}$ 其中的一个，为了简便，以下称 $(x_1,x_k)$ 为“区间”。

现在我们有一个初步的思路：选择点权前 $k$ 大的点并作为我们初始选择的点，再在 $\{1,(x_1,x_k),n\}$ 里面选择一个点权最大的没有被选择的作为最后一个被染成蓝色的点，相加点权即为答案。很明显这个思路是**错误的**。考虑当 $k=2$ 时的这个序列：$\{1,4,1,4,2,1\}$，按照上述思路我们求出来的是 $4+4+1=9$，但答案应该是 $4+4+2=10$，如何做到？我们选择第一个 $4$ 和 $2$，那么此时中间的 $4$ 被区间包含，就可以成为最后一个被染成蓝色的点。

实际上的思路应该是这样的：若选择完点后，剩余的点权最大的未被选择的点不被区间所包含，那我们就将这个剩下的点权最大的点选中，再把原来选择的点中的任意一个点取消选中，但要保证取消选择之后被新区间所包含，取消选择之后，因为这个点被区间所包含，自然可以成为最后一个被染成蓝色的点，而刚刚我们所新选择的点也能够产生贡献，这样子的正确性显然。

然后你就能发现我们刚刚说了这么一大堆，结论就一句话：当 $k\ge 2$ 时，答案即为前 $k+1$ 大的数的总和。

为什么会有个前提条件？因为当 $k=1$ 的时候无法形成一个区间。相当于最后一个被染成蓝色的点的位置只能是 $\{1,n\}$ 中的一个，如果我们选择的点位于边界，那么答案就是 $a_1+a_n$，不位于边界，答案就是 $\max_{1<i<n} a_i+\max\{a_1,a_n\}$，因为你在染色扩张的过程中只能一直往两边扩张，不能从两端往中间染色，最后被染色的点只能是两端。所以特判一下就好。

## 代码
```cpp
#include<queue>
#include<bits/stdc++.h>
#define ll long long
using namespace std;
mt19937 myrand(time(0));
inline ll read(){
	ll x=0,w=1;
	char ch=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*w;
}
void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	static int sta[35];
	int top=0;
	do{
		sta[top++]=x%10,x/=10;
	}while(x);
	while(top)putchar(sta[--top]+'0');
}
ll n,k,a[5005];
inline void work(){
	n=read();k=read();
	ll ans=0;
	for(int i=1;i<=n;i++)a[i]=read();
	if(k==1){
		for(int i=1;i<=n;i++){
			if(i==1)ans=max(ans,a[i]+a[n]);
			else if(i==n)ans=max(ans,a[i]+a[1]);
			else ans=max(ans,a[i]+max(a[1],a[n]));
		}
		write(ans);puts("");
		return;
	}
	if(k==n-1){
		for(int i=1;i<=n;i++)ans+=a[i];
		write(ans);puts("");
		return;
	}
	sort(a+1,a+n+1,greater<int>());
	for(int i=1;i<=k+1;i++)ans+=a[i];
	write(ans);puts("");
}
int t;
int main(){
	t=read();
	while(t--)work();
	return 0;
}
```
[提交记录](https://codeforces.com/contest/2075/submission/311109614)。

---

## 作者：The_foolishest_OIer (赞：0)

排序模板题。

对 $k$ 进行分类讨论：

若 $k \ge 2$：

首先知道，对于每一个两端都涂上的子段，可以以任意一个格子结束。

取最大的 $k+1$ 个就是答案：假设你先取了 $k$ 个，记为 $b_1,b_2,…,b_k$，如果剩下一个比 $\min(b_1,b_2,…,b_k)$ 更小或比 $\max(b_1,b_2,…,b_k)$ 要大，那么就将 $b_2$ 换出去，否则就比进行操作。

上述操作是为了解决最左一段和最右一段的问题。

若 $k = 1$ 时：最后一个只能是 $a_1$ 或者 $a_n$，答案就是 $\max(a_1+a_n,\max(a_2,a_3,…,a_{n-1}) + \max(a_1,a_n))$。

---

## 作者：_Kamisato_Ayaka_ (赞：0)

## Statement

给定 $n$ 个数 $a_i$，你一开始有 $k$ 次操作，选择 $k$ 个元素进行染色，之后将所有有邻居染色的点依次染色直到所有点都被染色，最后的价值为 $k$ 次操作染色元素和和之后最后一个染色的元素之和，使其最大。

## Solution

这是一种类似于扩散的染色，但是扩散的顺序是自订的，也就是说只要保证前 $k$ 个和最大以及最后一个染色的元素最大即可。

也就是说我们前 $k$ 次取前 $k$ 大的元素，只需要先将除第 $k + 1$ 大的元素都染色即可。

综上，结论就是取前 $k + 1$ 大的元素和，对于 $k=1$ 和 $k=n-1$ 的情况特判。

## Code
[Submission](https://codeforces.com/contest/2075/submission/311184412)

---


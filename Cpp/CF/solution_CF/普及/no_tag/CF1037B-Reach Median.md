# Reach Median

## 题目描述

**题目大意：**

给定一个长度为$n$的序列和一个整数$s$，$n$一定为奇数

一次操作可以将序列中的某个数$+1$或者$-1$，问至少几次操作可以使这个序列的中位数等于$s$

## 样例 #1

### 输入

```
3 8
6 5 8
```

### 输出

```
2```

## 样例 #2

### 输入

```
7 20
21 15 12 11 20 19 12
```

### 输出

```
6```

# 题解

## 作者：Creator_157 (赞：2)

### 题意：

~~我觉得没什么好讲的，大家应该看得懂~~

给一个序列和目标中位数，每次操作是将已知序列中的数 $+1$或 $-1$，求最少操作几次可以将中位数变为目标中位数。


------------


### 前置芝士：中位数？

中位数是 **按顺序排列** 的一组数据中居于中间位置的数。

举个栗子：

1、9、5、4、8 的中位数是 5。

2、6、9、7的中位数是$6.5$ 。


------------


### 思路：

将无序变为有序——**sort！**（十分好用）

然后分三种情况：

$1.$原序列的中位数 $=s : $直接 $cout<< 0$;

$2.$原序列的中位数 $>s : $就在序列的左边找只要比TA大的就累加它们的差。

$3.$原序列的中位数 $<s : $就在序列的右边找只要比TA大的就累加它们的差。

最后输出累加的和即可圆满结束。


------------
## code
**三年 OI 一场空，不开 long long 见祖宗**

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>//注意：使用sort要调用这个库
using namespace std;
long long n,s,ans;
long long a[200005];
int main()
{
    cin>>n>>s;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    if(a[(n+1)/2]>s)
    {
        for(int i=1;i<=(n+1)/2;i++)
        {
            if(a[i]>s)
            {
                ans+=a[i]-s;
            }
        }
    }
    else if(a[(n+1)/2]<s)
    {
        for(int i=(n+1)/2;i<=n;i++)
        {
            if(a[i]<s)
            {
                ans+=s-a[i];
            }
        }
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：Hiraeth (赞：1)

题目大意：

修改序列元素，求最少修改次数，使得中位数满足给定值。

思路分析：

首先对其进行排序 当数组有序的时候 最优

然后左右进行分治 左边的元素不能比中位数大 右边的元素不能比中位数小

### 另外：要开$longlong$

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200005],p,mid,ans;
int main(){
	scanf("%lld%lld",&n,&p);
	mid=(n+1)/2; 
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	for (int i=1;i<=mid;i++)
		if (a[i]>p) ans+=a[i]-p;
	for (int i=mid;i<=n;i++)
		if (a[i]<p) ans+=p-a[i];
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：JacoAquamarine (赞：0)

又是随机跳题跳到的，再来写一篇题解。

不难发现又是一道用贪心解决的问题。

首先先对序列进行排序。

然后发现题目分为以下三种情况（$mid$ 为中位数,当前中位数为 $s$)
- $s=mid$ 输出特判即可。

- $s>mid$ 在序列的左边只要找到比 $s$ 大的就累加他们的差进答案。

- $s<mid$ 在序列的右边只要找到比 $s$ 大的就累加他们的差进答案。

核心代码如下
```cpp
if(a[(n+1)/2]>mid){//s > mid
	for(int i=1;i<=(n+1)/2;i++){
		if(a[i]>mid)ans+=a[i]-mid;//累加他们的差
	}
} 
if(a[(n+1)/2]<mid){//s < mid
	for(int i=(n+1)/2;i<=n;i++){
		if(a[i]<mid)ans+=mid-a[i];//累加他们的差
	}
}
```

---

## 作者：KagurazakaKano (赞：0)

贪心，我们先对这个数列进行排序，然后分成左右两个部分。

策略：如果左边部分比$m$大，那么肯定我们要把这个数减去$a_i - m$，这样是最优的，右边部分同理应当减去$m - a_i$。

至于理解：由于这是一个排序后不下降的序列，我们至少也得使左半部分的数要小于等于$mid$，因此当且仅当取到等于的时候是最优的，右半部分同理。


```
#include <cstdio>
#include <algorithm>
#include <cmath>

typedef long long LL;

using namespace std;

int a[200005];

int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++){
		scanf("%d",&a[i]);
	}
	sort(a + 1, a + 1 + n);
	int md = (n + 1) / 2;
	LL ans = 0;
	for(int i = 1; i <= md; i++){  //处理左半部分
		if(a[i] > m){
			ans += a[i] - m;
			a[i] = m;
		}
	}
	for(int i = md; i <= n; i++){  //处理右半部分
		if(a[i] < m){
			ans += m - a[i];
			a[i] = m;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

其实这份代码还是优化一下的，考虑如果$a_{mid} > m$，那么肯定只要处理左半部分即可，如果$a_{mid} < m$，只要处理右半部分即可，如果$a_{mid} = m$，直接输出$0$即可，具体可以用二分查找来实现。

---

## 作者：A_grass_block (赞：0)

### 审题
首先看题目，可以得知这道题目是一道贪心的题目，题目中重点需要的是中位数，可以进行排序。

### 中位数？

就是有顺序的数组的未于中间的数（~~如果是偶数怎么办？题目不是说了是奇数吗~~）。

### 如何做？

首先，先求中位数，然后判断与题目要求的中位数的差别，如果相等，就可以输出
```
cout<<0;
```
否则判断是大是小。

大：去比他大的数哪里，并看相差多少，用计数器加他的差。

小：去比他小的数哪里，并看相差多少，用计数器加他的差。

## 代码

```
#include<bits/stdc++.h>//万能头
using namespace std;
long long a[200000+10];
int main()
{
	long long n,s,sum=0;
	cin>>n>>s;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//sort
	if(a[(n+1)/2]==s)//应为是奇数，所以n+1
	{
		cout<<0;
		return 0;
	}
	if(a[(n+1)/2]>s)
	{
		for(int i=1;i<=(n+1)/2;i++)//去左部分找
		{
			if(a[i]>s)
			{
				sum=sum+a[i]-s;//加上和s的差
			}
		}
	}
	else
	{
		for(int i=(n+1)/2;i<=n;i++)//去右半部分找
		{
			if(a[i]<s)
			{
				sum=sum+(s-a[i]);//注意和上面的不同
			}
		}
	}
	cout<<sum<<endl;
	return 0;
}
//完成
```

---

## 作者：智子·起源 (赞：0)

## 似乎比下面大佬的都要麻烦一点……

还是模拟……（另一种复杂一点的思路）

就是先用两个数组来记录要把当前数变为s所需的操作数（比s大的放一个数组，小的另放一个）

接下来，如果s<目前中位数，就计算要把多少个大于s的数变为s，才能使s变成中位数，累加最少操作数输出。

如果s>中位数，那就计算要把多少个小于s的数变为s，才能使s变成中位数，累加最少操作数输出。

如果s=中位数的话要特判输出。

如果大家还是听不懂的话，看看代码注释吧……
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,s,a[2000005],da[2000005],xiao[2000005],da_n,xiao_n,ans;
int main()
{
  scanf("%lld%lld",&n,&s);
  for(int i=1;i<=n;i++)
  {
    scanf("%lld",&a[i]);
    if(a[i]>s)da_n++,da[da_n]=a[i]-s;
    if(a[i]<s)xiao_n++,xiao[xiao_n]=s-a[i];
  }
  sort(a+1,a+1+n);sort(da+1,da+1+da_n);sort(xiao+1,xiao+1+xiao_n);//从小到大排序三个数组
//由于贪心思想，哪个数变为s所需的操作数小就变哪个，所以要将da[]数组和xiao[]数组进行从小到大排序
  if(s==a[n/2+1]){printf("0");return 0;}//特判
  if(s>a[n/2+1])//如果s>中位数
    for(int i=n/2+1;i<=n;i++)
    {
      if(a[i]>=s)break;//由于s有可能不存在在队列里，所以这里是“>=”。
      ans+=xiao[i-n/2];//累加操作数
    }//模拟找出最小操作数。
  if(s<a[n/2+1])
    for(int i=n/2+1;i>0;i--)
	{
	  if(a[i]<=s)break;//由于s有可能不存在在队列里，所以这里是“<=”。
	  ans+=da[n/2+2-i];//累加操作数
	}
  printf("%lld",ans);
  return 0;
}
```

纯代码：（无注释）
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,s,a[2000005],da[2000005],xiao[2000005],da_n,xiao_n,ans;
int main()
{
  scanf("%lld%lld",&n,&s);
  for(int i=1;i<=n;i++)
  {
    scanf("%lld",&a[i]);
    if(a[i]>s)da_n++,da[da_n]=a[i]-s;
    if(a[i]<s)xiao_n++,xiao[xiao_n]=s-a[i];
  }
  sort(a+1,a+1+n);sort(da+1,da+1+da_n);sort(xiao+1,xiao+1+xiao_n);
  if(s==a[n/2+1]){printf("0");return 0;}
  if(s>a[n/2+1])
    for(int i=n/2+1;i<=n;i++)
    {
      if(a[i]>=s)break;
      ans+=xiao[i-n/2];
    }
  if(s<a[n/2+1])
    for(int i=n/2+1;i>0;i--)
	{
	  if(a[i]<=s)break;
	  ans+=da[n/2+2-i];
	}
  printf("%lld",ans);
  return 0;
}
```
### 如果这篇题解帮助了你，帮忙点个赞，谢谢！O^_^O

---

## 作者：JimmyF (赞：0)


更新于
$2020$ 
$3.30$
,
用
$markdown$
美化了题解，望管理员通过。

### 数据范围分析：

额，首先拿到题目大家都会不约而同地想到搜索（也可以说成回溯）+模拟这个算法。

然后疯狂打代码，再自信满满地提交——恭喜你，你
$TLE$
了！

然后再回过头来看数据：
$1≤n≤2$
$\times$
$10^5$
$-1$
,
$1≤s≤10^9$

现在想想恨不得抽自己一个大嘴巴子。

好的，现在我们不得不想另一种方法了。

### 先来普及一下中位数的知识
#### ~~（我才不会告诉你是我去问度娘的qwq）~~

一、中位数定义

中位数，统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。

二、中位数的意义

中位数将数据分成前半部分和后半部分，因此用来代表一组数据的“一般水平”。

三、中位数的求法

对于一组有限个数的数据来说，它们的中位数是这样的一种数：这群数据里的一半的数据比它大，而另外一半数据比它小。 

计算有限个数的数据的中位数的方法是：把所有的同类数据按照大小的顺序排列。如果数据的个数是奇数，则中间那个数据就是这群数据的中位数；如果数据的个数是偶数，则中间那
$2$
个数据的算术平均值就是这群数据的中位数。


------------
### 排序分析：

既然是中位数，就要保证数组有序（上面也提到了），所以第一步先排序，也是方便我们下面的查找。

------------

### 情况$1$

拿样例来说：

$n=3$
,
$s=8;$


| 数组元素 | $5$ | $6$ | $8$ |
| :----------: | :----------: | :----------: | :----------: |
| 下标 | $1$ | $2$ | $3$ |
| 中位数所在 |  | ↑ |  |
|期望| $5$  |$\color{red}\text{8}$ |$8$ |
|修改|  |$2$|  |
一共修改
$2$
次

---------

再比如：
$n=7$
,
$s=20;$


| 数组元素 | $11$ |$ 12 $|$ 12$ |$ 15$|$19$ |$20$ |$21$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 下标 |$ 1$ |$ 2 $| $3$ |$4$|$5$|$6$|$7$|
| 中位数所在 |  |  |  |↑ | | | |
|期望| $ 11$  |$12$ |$12$ |$\color{red}\text{20}$|$\color{red}\text{20}$|$20$|$21$
|修改| | | |$5$|$1$| | |

一共修改
$6$
次

---------

#### 情况$1$总结发现 
通过这两组数据我们可以发现：如果中位数的值
$<s$
，则从中位数向右查找至
$n$
，如果当前位置的值
$<s$
就将总数$+=s-$
当前位置的值，最后输出总数

------------

### 情况$2$

举个例子：

$n=5$
,
$s=6$


| 数组元素 | $5$ |$ 7$ |$ 9$ | $10$|$11$|
| :----------: | :----------: | :----------: | :----------: |:----------: |:----------: |
| 下标 | $1$ | $2 $| $3$ | $4$| $5$ |
| 中位数所在 |  |  | ↑ | | |
|期望| $5$  |$\color{red}\text{6}$ |$\color{red}\text{6}$ |$10$|$11$
|修改| |$1$|$3$| | |

一共修改
$4$
次

----------

#### 情况$2$方法总结：

通过这以上数据我们可以发现：如果中位数的值>s，则从中位数向右左查找至
$1$
，如果当前位置的值
$>s$
就将总数
$+=$
当前位置的值
$-s$
，最后输出总数

---------

### 情况$3$：
这一种是最简单的情况，也就是中位数等于
$s$
的情况，那我们直接输出
$0$
就可以了。

举个例子：

$n=3$
,
$s=1$


| 数组元素 | $1$ | $1$ |$ 1$ |
| :----------: | :----------: | :----------: | :----------: |:----------: |:----------: |
| 下标 | $1$ |$ 2$ |$ 3$ |
| 中位数所在 |  |↑  | |
|期望| $ 1$  |$1$|$ 1$|
|修改 |  |  |  |

一共修改
$0$
次

----------

### 三种情况的总结：

1. 中间位的值$==s$，直接输出$0$。
2. 中位数的值$>s$，向左找，累加$>s$的值。
3. 中位数的值$<s$，向右找，累加$<s$的值。

--------

### 原理：

根据三种不同情况的分析，我们发现这其实是一道并不怎么难想的贪心题。

贪心的有
$n$
个点：

1. 只需要判断中间值的大小，然后向一边查找即可。举个例子：如果要把一个排序好的数组的中间位置改大一些，那在此位置左边的数，也就是比中间值小的数，对于这些数来说，改大中间值并没有对它们造成任何影响。
1. 对于向左找只需要改$>s$的数，因为向左找的是较小的数，如果较小的数已经$<s$了，那修改也就毫无意义了。
1. 修改的时候只需要把不符合要求的统统修改成$s$就可以了，因为再多增加$1$或者少$1$已经毫无意义，因为已经符合要求了。

当然，右边的也一样。

------

### 代码区：

```cpp
#include<bits/stdc++.h>  //文件头
using namespace std;   //定义空间名
long long n,s,d,dd,a[1000010];  //定义，记得开long long
int main()
{
	cin>>n>>s;
	for(int i=1; i<=n; i++)
	cin>>a[i];    //输入
	sort(a+1,a+1+n);  //排序
	if(a[(n+1)/2]==s)   //情况一
	{
		cout<<0;
	}
	if(a[(n+1)/2]>s)   //情况2
	{
		for(int i=1; i<=(n+1)/2; i++)  //向左找
		if(a[i]>s)d+=abs(s-a[i]);//累加>s的值
		cout<<d; //输出
	}
	if(a[(n+1)/2]<s)  //情况3
	{
		for(int i=(n+1)/2; i<=n; i++)  //向右找
		if(a[i]<s)dd+=abs(s-a[i]);//累加《s的值
		cout<<dd;	//输出
	}
	return 0;
}
```
声明一下：我并不是因为懒而不写超时的代码qwq。

PS：程序里面没有坑！！！~~显然这是此地无银三百两，但是你想多了~~

看我写题解那么不容易，就给我点个赞吧！~~跪求各位大佬~~


---

## 作者：Cambridge (赞：0)


小学生又来发题解了！

这道题没有标签，本蒟蒻就在这里和读者说一下，我们可以用贪心策略，但是我们首先要保证数组有序，因为你求的是中位数，所以要先排序。这是前言，下面一段是思路。

这道题有点像中位数这道题（洛谷没有），先是从小到大sort，~~当然从大到小也可以~~当s小于中间值时往左找；当s小于中间值时往右找，然后gs累加它们的差：注意，只有a[i]>gl或a[i]<gl时才能求差，不然就凉凉夜色为你思念成河~最后输出即可。应该比绿题水一点。

    #include<iostream>
    #include<cstring>
    #include<cstdio>
    #include<cmath>
    #include<string>
    #include<cstdlib>
    #include<algorithm>//文件头不解释
    using namespace std;
    long long n,gl,gs,mid;
    int a[1000000];//定义所需变量
    int main()
    {
        cin>>n>>gl;//读入n和s
        for(int i=1; i<=n; i++)
        {
            cin>>a[i];//读入n个数
        }
        sort(a+1,a+1+n);//从小到大排序
        if(a[(n+1)/2]==gl)//如果中位数已经是s
        {
            cout<<0;//输出0
            return 0;//退出程序
        }
        mid=(n+1)/2;//求中间的位置，mid存储
        if(gl<a[mid])//如果左边的数大于s
        {
            for(int i=mid; i>=1; i--)
             if(a[i]>gl)gs+=a[i]-gl;//求变多少次
        }
        if(gl>a[mid])//如果右边的数大于s
        {
            for(int i=mid; i<=n; i++)
             if(a[i]<gl)gs+=gl-a[i];//求变多少次
        }
        cout<<gs;//输出
        return 0;
    }

---


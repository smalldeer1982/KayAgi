# Nastya Is Playing Computer Games

## 题目描述

完成了她的家庭作业，Nastya决定玩一会儿电脑游戏。Nastya一个接一个地通过关卡，最终遇到了一个问题问题。她的任务是尽快离开许多怪物居住的房间。
有$n$个下水道检修孔其中坐落在一条线，但不幸的是所有的检修孔被关闭，并且每个检修孔上有一块石。每个检修孔下面都有一枚硬币，为了赢得比赛，Nastya应该选择所有的硬币。最初Nastya站在从左边数第$k$个检修孔。她正在考虑该怎么做。
在一个回合中，Nastya可以执行以下操作之一：
1. 如果在检修孔上至少有一块石头，并且Nastya站在附近，从它扔出一块石头到任何其他检修孔(是的，Nastya很强)。
2. 去相邻的检修孔;
3. 如果Nastya所在的检修孔上没有石头，她可以打开它并从中取出硬币。之后，她必须立即关闭检修孔(不需要额外的移动)。
## 图片示意
该图显示了游戏的中间状态。在当前位置，Nastya可以将石头扔到任何其他检修孔，或向左或向右移动到邻近的检修孔。如果她靠近最左边的检修孔，她可以打开它(因为它上面没有石头).Nastya可以在拿到所有硬币时离开房间。怪物无处不在，所以你需要计算Nastya必须采取的拿到所有硬币的最小移动次数。
**请注意，只有在没有石头的情况下，Nastya才能打开一个检修孔。**

## 说明/提示

让我们考虑一下这个例子$ n = 2$，$k = 2$。
Nastya应该如下操作：
起初，她将石头从第二个检修孔扔到第一个检修孔。现在第一个检修孔上有两块石头。
然后她打开第二个检修孔并从中取出硬币。
然后她去了第一个检修孔，通过两次移动将两块石头扔到第二个检修孔，然后打开检修孔并从中取出硬币。
所以，获胜需要$6$个动作。

## 样例 #1

### 输入

```
2 2
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4 2
```

### 输出

```
13
```

## 样例 #3

### 输入

```
5 1
```

### 输出

```
15
```

# 题解

## 作者：Jayfeather2012 (赞：1)

## 题目大意
有 $n$ 个盖了盖子的井盖，井内有金币，井盖上有石头，把石头扔到别处才能拿到金币，你的位置是 $k$，求拿到所有  $n$ 个金币的最少步数。
## 思路
### 移动方案
1.先往左走到底，再往右走到底，步数是 $(k-1)+(n-1)$。

2.先往右走到底，再往左走到底，步数是 $(n-k)+(n-1)$。

二者取最小值。
### 拿硬币方案
$n$ 个井盖，$n$ 个步骤。
### 扔石头方案
除了第一次取金币，每一次都把石头投到已经取过硬币的井盖上，步数是第一次处理的 $2$ 步加其他次的 $n-1$ 步。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k; 
int main()
{
	cin>>n>>k;
	cout<<n*3+min(k-1,n-k);//简化后的结果，相当于(n+1)+n+(n-1+min(k-1,n-k)) 
	return 0;
}
```

---

## 作者：shenbairui (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/CF1136B)

### 题目大意
有 $n$ 个盖了盖子的井盖，你的初始位置已经给出。最开始所有井盖上都压着石头，井里面有硬币，求按照移动规则捡完所有金币的最少步数。

### 题目分析

一眼结论题

拿 $n$ 个硬币,排水孔下各有一个。

从左边往右走或从右往左走要用 $(n−1)$ 步。

然后扔石头的代价是 $n+1$。这些是确定的。

对于移动，我们只有两种走法:

1.往左走，走完后往右走直到底。

2.往右走，走完后往左走直到底。如果不这么走，我们很容易知道他不会获得最小步数。

3.化简后为 $3 \times n$。然后最后决定是往左走还是往右走，代价为 $\min(n-k,k-1)$。

答案就为 $3 \times n + \min(n-k,k-1)$。

### 代码如下


```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n, k;
	cin >> n >> k;
	cout << 3 * n + min(n - k, k - 1);
	return 0;
}
```
### [通过记录](https://codeforces.com/contest/1136/submission/296001518)

下期见！拜拜！

---

## 作者：Stars_visitor_tyw (赞：1)

## CF1136B Nastya Is Playing Computer Games 题解
### 分析
虽然题面有点那啥，但还是很简单的。

我们分开计算。根据题面得知，每块井盖上有 $1$ 个硬币，总共就是 $n$ 个硬币，所以拿硬币要花费 $n$ 次操作。考虑最优策略，我们先走到最近的一端再走一遍，花费 $\min(k-1,n-k) + n-1$ 次操作。当然还有一个操作就是扔石头，我们可以将石头扔到已经取过硬币的地方，也就是从一端把石头往前扔一个检修口，然后走到前面的检修口再把那个检修口上的两个硬币扔回来，剩下的就直接扔到前面就行了，花费 $1+2+n-2$ 次操作，则总操作数化简为 $3\times n+\min(k-1,n-k)$。

### 代码
```cpp
#include<iostream>
using namespace std;
#define int long long
signed main()
{
    int n, k;
    cin>>n>>k;
    cout<<3*n+min(n-k,k-1);
}
```

---

## 作者：Coelacanthus (赞：1)

   因为开始就在一个井盖处，所以先将石头丢到相邻的井盖上，把这两个井盖金币捡到的步数和为$6$,其他的井盖步数和为$(n-2)*6/2$即$(n-2)*3$,共$3n$.
   考虑先走哪个方向，往左需多走$k-1$步,向右需多走$n-k$步(就是移动过去要走步数)。当然是取较小的了

代码如下:

```cpp
#include <bits/stdc++.h>	//神秘的头文件
using namespace std;
int n,k;
int main()
{
    cin >> n >> k;
    cout << n*3 + min(n-k,k-1) << endl;
    return 0;
}
```

---

## 作者：__XU__ (赞：1)

# CF1136B

### 思路：

顺着题意一遍即可。

### 做法：

全部拿金币所花费的代价为 $n$，走一遍所花费的代价为 $n-1$，加上扔石头的代价 $n+1$，最后在决定往左走还是往右走。所以代价就是 $n+n-1+n+1=3 \times n$。判断左右就是 $\min (k-1,n-k)$。

具体看代码。

## AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	//拿金币 n 
	//走一遍 n - 1
	//扔石头 n + 1 
	//总步数 n + n - 1 + n + 1 = 3n
	//左走 k - 1
	//右走 n - k;
	cout<<3*n+min(k-1,n-k); 
	return 0;
}
```

谢谢观看。

---

## 作者：qingchenMC (赞：0)

## 题目大意

每个井盖上都有一个石头。每次可以把一块石头扔到其他井盖上，或是移动一步，还能打开一个井盖。给定井盖的数量以及开始在几号井盖上，求打开所有井盖的最小时间。

## 思路

首先，要拿到所有金币，就要走遍所有的井盖。那么，开始在一个井盖上，要使走路时间最小，只能有两种选择：

1. 走到最左边再走到最右边。

2. 走到最右边再走到最左边。

如果不是这两种方法，一定走了回头路。因为如果不是走到最头上就往回走，因为所有的都要走，所以他必须折回来走到头，这样就一定走了重复的路。所以：一定只有这两种方法使时间最小。

那么我们分别计算，假设这个人现在在 $k$ 号井盖上，那么他左边有 $k-1$ 个，右边有 $n-k$ 个井盖。用第一种方案要走 $(k-1)+(n-1)=k+n-2$ 步。第二种则需要 $(n-k)+(n-1)=2n-k-1$ 步。

现在开始扔石头，每个井盖上的石头都会被扔一次，但是一开始的那个石头可以先扔到接下来要去一个上，去了之后再扔回 $k$ 号，之后的所有石头都往 $k$ 号上摞就行了。扔石头用了 $n+1$ 的时间。

而拿金币需要用 $n$ 的时间。

这样加起来，两种方案分别用时：

1. $3n+k-1$
2. $4n-k$

于是我们只需在这两个中取最小值输出即可。代码就不放了。

[AC](https://codeforces.com/contest/1136/submission/308619831)

---

## 作者：Fuxh_18 (赞：0)

题目似乎很复杂，但可以分析出得到答案的公式。

## 题目分析

本题可以分成四个部分：
1.  走到边缘的次数为 $\min(k-1,n-k)$。
2.  走完全程的次数为 $n-1$。
3.  捡完所有金币的次数为 $n$。
4.  扔石头的次数为 $n+1$。

于是答案为 $\min(k-1,n-k)+(n-1)+n+(n+1)$。

化简为 $\min(k-1,n-k)+n \times 3$。

## 代码展示
 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main(){
	cin>>n>>k;
	cout<<min(k-1,n-k)+n*3;
	return 0;
}
```

希望能帮助到大家。

---

## 作者：jinfanhao (赞：0)

简单结论题，但是题目确很难读懂。\
几个步骤。

1. 走一遍需要 $n-1$ 个动作。
2. 取硬币需要 $n$ 个动作。
3. 扔石头需要 $n+1$ 个动作。
4. 走到边缘需要 $\min \lparen n-m,m-1\rparen$ 个动作。
5. 总共需要 $n-1+n+n+1+ \min \lparen n-m,m-1\rparen$ 个动作。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	printf("%d",n-1+n+n+1+min(n-m,m-1));
	return 0;
}

```

---

## 作者：lizhixun (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/CF1136B)

### $\texttt{Description}$

有 $n$ 个盖了盖子的井盖，你的初始位置已经给出。最开始所有井盖上都压着石头，井里面有硬币，求按照移动规则捡完所有金币的最少步数。

### $\texttt{Solution}$

一道美丽的结论题。

我们都知道，拿走全部金币的代价为 $n$，把整条路走一遍代价就是 $n-1$，然后扔石头的代价是 $n+1$。这些是确定的，化简后为 $3 \times n$。然后最后决定是往左走还是往右走，代价为 $\min(n-k,k-1)$。

$\therefore$ 答案为 $3 \times n + \min(n-k,k-1)$。

### $\texttt{Code}$

直接输出上面推出的答案即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
	int n, k;
	cin >> n >> k;
	cout << 3 * n + min(n - k, k - 1);
	return 0;
}
```

这题的结论很简单，但是还是需要一些思维的。完结。

---

## 作者：I_am_wjr_I_AK_IOI (赞：0)

# 题目大意：
 给你 $n$ 个盖了盖子的井和你当前的位置，井上面压着石头，井里有硬币，你需要捡完所有的硬币才能通关。问你最少的移动步数，移动规则如下：

1.将石头扔到任意一个井上。

2.移动到下一个位置。 

3.进入井中捡硬币，并盖上盖子（这一步不会花费步数）。

对于移动，我们只有两种走法:

1.往左走，走完后往右走直到底。

2.往右走，走完后往左走直到底。如果不这么走，我们很容易知道他不会获得最小步数。接下来我们会发现，想要步数最小，我们应该第一步将石头放到第二步的，第二步花费多一点的步数将所有的石头放到第一步的位置，接下来的每一步就只需石头扔到已经取完的井上了。所以我们除了第一步用了 $2t$，第二步用了 $4t$，接下来除了回头走没有硬币的地方是 $1t$ 的其余都是 $3t$ 了。

最后我们将两种方案比较一下就行了。

## 以下是详细代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define inf 0x3f3f3f3f;
#define Max 5e2 + 10;
#define mod  1e9 + 7;
 
signed main()
{
	int n, k;
	ios::sycn_with_stdio(0);//黑科技 
	while (scanf("%d%d", &n, &k))
	{
		int a = min(abs(k - 1), abs(n - k));
		printf("%d\n", 3 * n +  a);
	}
	return 0;//写完代码，撒花
}
```
 ~~（说句闲话：研究珂****办法就是 *了这道题）~~

---

## 作者：zhuyucheng6046 (赞：0)

这道题比较简单，可以这么做。

1. 拿 $n$ 个硬币,排水孔下各有一个。

2. 从左边往右走或从右往左走要用 $(n-1)$ 步。

3. 想去某一边要走离边缘近的地方， $\min(n-k,k-1)$ 。

4. 把所在地的石头往前扔，其余的到了那个点就往别的没有石头的井盖上扔 $3+n-2$ 。
 
一共是 $n+(n-1)+\min(n-k,k-1)+3+n-2$ 。

整理后是： $3\times n+\min(n-k,k-1)$ 。

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;	
int main()//主函数
{
	int n,k;
	cin>>n>>k;
	cout<<3*n+min(n-k,k-1);//数学方法
	
	return 0;//好习惯
}
```

---

## 作者：imsbNR (赞：0)

# 题解：CF1136B Nastya Is Playing Computer Games

## 做法

| 行为  | 代价 |
| -----------: | -----------: |
| 走一遍 | $n - 1$ |
| 扔石头 |  $n + 1$ |
| 拿硬币 | $n$ |
| 走到最近的一段 | $\min(n - k, k - 1)$ |
| 总 | $3n + \min(n - k, k - 1)$ |

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int n, k;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> k;
	cout << 3 * n + min(n - k, k - 1) << endl;
	return 0;
}
```

---

## 作者：King_duck (赞：0)

题意是假设我们初始位置位于一个井盖上，我们可以选择向左或向右移动。我们希望在移动过程中尽可能地减少步数。

这两个井盖金币捡到的步数和为 $6$，其他的井盖步数和为 $(n-2)\times6\div2$ 即 $(n-2)\times3$，共 $3n$。

如果我们选择向左移动，我们需要多经过前面的 $k-1$ 个井盖才能到达目标井盖，因此多走的总步数为 $k-1$。

如果我们选择向右移动，我们需要多经过后面的 $n-k$ 个井盖才能到达目标井盖，因此多走的总步数为 $n-k$。

为了选择最小的步数，我们取这两者中的较小值。

因此，我们可以将多的步数最小化的方式表达为：$\min(k-1,n-k)$。

上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
signed main()
{
    cin>>n>>k;
    cout<<n*3+min(n-k,k-1)<<'\n';
    return 0;
}
```

---


# Nirvana

## 题目描述

Kurt reaches nirvana when he finds the product of all the digits of some positive integer. Greater value of the product makes the nirvana deeper.

Help Kurt find the maximum possible product of digits among all integers from $ 1 $ to $ n $ .

## 说明/提示

In the first example the maximum product is achieved for $ 389 $ (the product of digits is $ 3\cdot8\cdot9=216 $ ).

In the second example the maximum product is achieved for $ 7 $ (the product of digits is $ 7 $ ).

In the third example the maximum product is achieved for $ 999999999 $ (the product of digits is $ 9^9=387420489 $ ).

## 样例 #1

### 输入

```
390
```

### 输出

```
216
```

## 样例 #2

### 输入

```
7
```

### 输出

```
7
```

## 样例 #3

### 输入

```
1000000000
```

### 输出

```
387420489
```

# 题解

## 作者：xiaohuang (赞：6)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/31/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8FCodeforces1143B%20Nirvana/)

### Solution

我们可以用递归，每次从右边少一位下去，进行递归，如果剩下的数是不为0的一位数，就返回这个数，否则返回1，然后枚举最后一位，选择直接用那一位的数或者退位。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

int n;
inline int f(int x) {
    if (x < 10) {//判断一位数的情况
        if (x == 0) return 1; else return x;
    }
    return max((x % 10) * f(x / 10), 9 * f(x / 10 - 1));//直接用那一位的数或者退位
}
int main() {
    scanf("%d", &n);
    printf("%d\n", f(n));
    return 0;
}
```

---

## 作者：Diaоsi (赞：4)

## 思路：

前段时间模拟考到了这道题，在这里提供两个做法。

### 做法1：

**贪心**

将原来的数写为数位形式: $ x_1x_2x_3...x_n $ 

那么每一位乘积最大的数一定是形如:

$(x_1-1)99999...,x_1(x_2-1)9999...,x_1x_2(x_3-1)999...$ 

枚举一下找最大即可，注意处理前导零和进位的问题。

**然而我考场上并没有想到这种做法**

### 做法2：

**数位 dp**

设 $f_{pos,lst,0/1,0/1}$ 表示当前在数字的第 $\text{pos}$ 位，上一位填的数字为 $\text{lst}$ ，第一个 $0/1$ 表示当前位填的数字是否等于原数字上这一位的数值，第二个 $0/1$ 表示当前位是否为前导零时**此时数位各位乘积的最大值**。

转移就是一个很套路的数位 dp ，考虑当当前位填的数字小于原数字上这一位的数时，后面的数位可以任意填，前导零同理，而当当前位填的数字等于原数字上这一位的数时，下一位数最高只能填到原数字上这一位的数值，在转移中取最大即可。

还是要注意一下前导零的问题，即当当前这位为前导零，递归统计答案时应乘上 $1$ 而不是 $0$ 以防止影响计算结果。

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=20,M=1000010,INF=0x3f3f3f3f;
long long n,cnt,f[N][N],p[N];//你在看我的代码对吧 
inline long long Max(long long x,long long y){return x>y?x:y;}
inline long long Min(long long x,long long y){return x<y?x:y;}
inline void Swap(long long &x,long long &y){x^=y,y^=x,x^=y;}
long long dfs(long long pos,long long lst,bool l1,bool l2){
	if(!pos)return 1;
	if(!l1&&!l2&&f[pos][lst]!=-1)return f[pos][lst];
	long long tmp=-INF,up=l1?p[pos]:9;
	for(long long i=0;i<=up;i++)
		tmp=Max(tmp,((l2&&!i)?1:i)*dfs(pos-1,i,(!(l2&&!i))&&(l1&&i==up),(l2&&!i)));
	if(!l1&&!l2)f[pos][lst]=tmp;
	return tmp;
}
long long solve(long long x){
	memset(f,-1,sizeof(f));cnt=0;
	while(x)p[++cnt]=x%10,x/=10;
	return dfs(cnt,0,1,1);
}
int main(){
	scanf("%lld",&n);
	printf("%lld\n",solve(n));
	return 0;
}
```


---

## 作者：Blunt_Feeling (赞：4)

## CF1143B Nirvana 题解

考虑 make a list。

最朴素的打表方法就是让 $i$ 从 $1\sim 2\times 10^9$ 暴力枚举，对于每个 $i$，如果 $i$ 各位数字的乘积比之前任何一个数的答案都要大，就把 $i$ 和相应的答案存起来，表示这是一个临界值。换言之，就是把 $n$ 的每一个范围对应的答案存到表里，于是输入 $n$ 就可以 $O(1)$ 得到答案。

但是像这样打表的时间复杂度是相当高的，差不多是 $n$ 的最大值乘一个 $30$ 左右的常数，给计算机的运算量达到了六百亿次以上。于是我对这个打表程序做了一些优化。

- 不难看出，在十亿范围内的最大答案为 $9^9$。但是在十亿到二十亿的范围内，无法再找到一个数能使答案大于 $9^9$。于是只要枚举 $1\sim 10^9$ 范围内的数就行了。

- 对于所有带“0”的数，可以直接跳过不枚举。于是一旦遇到一个带“0”的数，就直接把是 $0$ 的一位变成 $1$。比如当遍历到 $15000$ 这个数时，下一个遍历的数就会是 $15100$，接下来是 $15110$，$15111$。这样用 $O(3)$ 的时间复杂度，就完成了 $O(111)$ 的运算量。

### 生成代码
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
vector<int> a,b;
void make_it() //制表
{
	int fn=0,len,ans; //fn记录目前最大答案
	char c[20];
	For(i,1,1000000000) //只需遍历十亿
	{
		sprintf(c,"%d",i); //把i变成一个字符串
		len=strlen(c),ans=1;
		bool flag=true;
		For(j,0,len-1)
		{
			if(c[j]=='0') //遇到0
			{
				flag=false;
				int t=pow(10,len-j-1);
				i+=t; i/=t; i*=t;
				break;
			}
			ans*=(c[j]-48); //计算乘积
		}
		if(flag&&ans>fn)
		{
			fn=ans;
			a.push_back(i); //存储临界值
			b.push_back(ans); //存储答案
		}
	}
}
void output() //输出
{
	int sz=a.size();
	For(i,0,sz-1) printf("%d,",a[i]);
	cout<<endl;
	For(i,0,sz-1) printf("%d,",b[i]);
}
int main()
{
	freopen("tst.out","w",stdout); //注意开freopen
	make_it();
	output();
	return 0;
}
```
这个程序在我的笔记本上跑，用了大概 $1000$ 秒的时间，在机房的台式上只用了 $800$ 多秒。如果你有更好的优化方法，欢迎私信！
### 提交的打表代码
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
const int a[]={-1,1,2,3,4,5,6,7,8,9,25,26,27,28,29,37,38,39,47,48,49,58,59,68,69,78,79,88,89,99,259,268,269,278,279,288,289,299,378,379,388,389,399,479,488,489,499,589,599,689,699,789,799,889,899,999,2599,2689,2699,2789,2799,2889,2899,2999,3789,3799,3889,3899,3999,4799,4889,4899,4999,5899,5999,6899,6999,7899,7999,8899,8999,9999,25999,26899,26999,27899,27999,28899,28999,29999,37899,37999,38899,38999,39999,47999,48899,48999,49999,58999,59999,68999,69999,78999,79999,88999,89999,99999,259999,268999,269999,278999,279999,288999,289999,299999,378999,379999,388999,389999,399999,479999,488999,489999,499999,589999,599999,689999,699999,789999,799999,889999,899999,999999,2599999,2689999,
	2699999,2789999,2799999,2889999,2899999,2999999,3789999,3799999,3889999,3899999,3999999,4799999,4889999,4899999,4999999,5899999,5999999,6899999,6999999,7899999,7999999,8899999,8999999,9999999,25999999,26899999,26999999,27899999,27999999,28899999,28999999,29999999,37899999,37999999,38899999,38999999,39999999,47999999,48899999,48999999,49999999,58999999,59999999,68999999,69999999,78999999,79999999,88999999,89999999,99999999,259999999,268999999,269999999,278999999,279999999,288999999,289999999,299999999,378999999,379999999,388999999,389999999,399999999,479999999,488999999,489999999,499999999,589999999,599999999,689999999,699999999,789999999,799999999,889999999,899999999,999999999};
const int b[]={-1,1,2,3,4,5,6,7,8,9,10,12,14,16,18,21,24,27,28,32,36,40,45,48,54,56,63,64,72,81,90,96,108,112,126,128,144,162,168,189,192,216,243,252,256,288,324,360,405,432,486,504,567,576,648,729,810,864,972,1008,1134,1152,1296,1458,1512,1701,1728,1944,2187,2268,2304,2592,2916,3240,3645,3888,4374,4536,5103,5184,5832,6561,7290,7776,8748,9072,10206,10368,11664,13122,13608,15309,15552,17496,19683,20412,20736,23328,26244,29160,32805,34992,39366,40824,45927,46656,52488,59049,65610,69984,78732,81648,91854,93312,104976,118098,122472,137781,139968,157464,177147,183708,186624,209952,236196,262440,295245,314928,354294,367416,413343,419904,472392,531441,590490,629856,708588,
	734832,826686,839808,944784,1062882,1102248,1240029,1259712,1417176,1594323,1653372,1679616,1889568,2125764,2361960,2657205,2834352,3188646,3306744,3720087,3779136,4251528,4782969,5314410,5668704,6377292,6613488,7440174,7558272,8503056,9565938,9920232,11160261,11337408,12754584,14348907,14880348,15116544,17006112,19131876,21257640,23914845,25509168,28697814,29760696,33480783,34012224,38263752,43046721,47829690,51018336,57395628,59521392,66961566,68024448,76527504,86093442,89282088,100442349,102036672,114791256,129140163,133923132,136048896,153055008,172186884,191318760,215233605,229582512,258280326,267846264,301327047,306110016,344373768,387420489};
int main()
{
	int n; cin>>n;
	Rep(i,211,1) //注意倒序遍历表
		if(n>=a[i])
		{
			cout<<b[i]<<endl;
			break;
		}
	return 0;
}
```

---

## 作者：Fan_Tuan (赞：3)

# 题意
给定一个$n$, 求$1$~$n$ 每一个数字每一位上乘积和的最大值。
# 思路
将$n$ 的每一位取出来， 两层循环， 第一层循环表示枚举到第$i$位， 第$1$~$i-1$位，保持不变，第$i$位$ - 1$ 则第$i + 1$~$n$ 位为$9$是最优，对于每次的乘积和，取$max$即可。
# 代码
```c
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <iostream>
#include <queue>
// #define d lld
// #define int long long
using namespace std;

const int maxn = 2e5 + 10;
int t, n, vis[maxn];
 
signed main () {
    string s;
    cin >> s;
    int len = s.size();
    long long ans = 1;
    for (int i = 0; i < len; i++) ans = ans * (s[i] - '0');
    for (int i = 0; i < len; i++) {
        long long gg = s[i] - '0' - 1;
        if (s[i] == '1') gg = 1;
        for (int j = 0; j < i; j++) gg *= (s[j] - '0');
        for (int j = i + 1; j < len; j++) gg *= 9;
        ans = max (ans, gg);
    }
    printf ("%lld", ans);
    return 0;
}
```


---

## 作者：3a51_ (赞：1)

对于 $\overline{a9}$ 和 $\overline{a8}$，显然前者的乘积大于等于后者。所以我们仅需要考虑末端有几个 $9$ 即可。此时对答案取 $\max$。

例子：

$1234 \max=1\times2\times3\times4=24$

$1229 \max=\max(1\times 2\times 2\times9=36,24)=36$

$1199 \max=\max(1\times 1\times 9\times9=81,36)=81$

$999 \max=\max(9\times9\times9=729,81)=729$

其余不理解的地方可以借助`code`。

```cpp
//该题记得开long long,这份code前面有宏定义

int a[20];//当前的数字
int getmul(int a[],int l){//获取当前数字的乘积
	int tot=1;
	while(a[tot]==0) tot++;//去除前导0
	int res=1;
	for(int i=tot;i<=l;i++){
		res*=a[i];
	}
	return res;
}
int getlen(int x){//获取一个正整数的长度
	int res=0;
	while(x){
		x/=10;
		res++;
	}
	return res;
}
void Solve(){
	//coding here...
	int n;
	cin>>n;
	int l=getlen(n),now=l;
	while(n){
		a[now--]=n%10;//将n变成数组的形式
		n/=10;
	}
	int ans=getmul(a,l);//原数的各位之积
	for(int i=l;i>=2;i--){
		if(a[i]!=9){//如果不是9才需要将上一位减一，因为要求小于等于原数
			a[i-1]--;
		}
		a[i]=9;//将这位设为9
		ans=max(ans,getmul(a,l));//取最大值。
	}
	cout<<ans<<endl;
}
```

---

## 作者：奥斯卡小冰人 (赞：1)

这么好的题当然是打表过啦。

不加任何优化的打表速度很慢，因此可以加上一点点的优化。如果遇到数位上为 0 的数，可以把这些数位转成 1，在转化的同时计算这个数各个数位相乘的乘积，与此前的最大值进行比较，如果比之前的大，就把当前的数与乘积加到表中。

速度还算快，可以在半分钟内输出完。

打表 Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans[10000010],res[1000010],cnt;
int check(int &x)
{
    int a[10],cnt = 0,tmp = x,mul = 1;
    while(tmp) 
    {
        a[++cnt] = tmp % 10;
        if(a[cnt] == 0) a[cnt]++;//相当于变成1
        tmp /= 10;
    }
    for(int i = cnt;i > 0;i--) tmp = tmp * 10 + a[i],mul *= a[i];//计算乘积
    x = tmp;//更新当前的数
    return mul;
}
int main()
{
    for(int i = 1;i <= 1000000000;i++)
    {
        int mul = check(i);
        if(res[cnt] < mul) 
        {
            res[++cnt] = mul;
            ans[cnt] = i;
            cout << mul << ',';
        }
    }
    return 0;
}
```
打完表后可以用 $\text{upper\_bound}$ 函数求表中第一个大于 n 的数，它的前一个数就是表中最后一个小于等于 n 的数，因此直接输出相应的成绩就行。

Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans[211] = {1,2,3,4,5,6,7,8,9,25,26,27,28,29,37,38,39,47,48,49,58,59,68,69,78,79,88,89,99,259,268,269,278,279,288,289,299,378,379,388,389,399,479,488,489,499,589,599,689,699,789,799,889,899,999,2599,2689,2699,2789,2799,2889,2899,2999,3789,3799,3889,3899,3999,4799,4889,4899,4999,5899,5999,6899,6999,7899,7999,8899,8999,9999,25999,26899,26999,27899,27999,28899,28999,29999,37899,37999,38899,38999,39999,47999,48899,48999,49999,58999,59999,68999,69999,78999,79999,88999,89999,99999,259999,268999,269999,278999,279999,288999,289999,299999,378999,379999,388999,389999,399999,479999,488999,489999,499999,589999,599999,689999,699999,789999,799999,889999,899999,999999,2599999,2689999,2699999,2789999,2799999,2889999,2899999,2999999,3789999,3799999,3889999,3899999,3999999,4799999,4889999,4899999,4999999,5899999,5999999,6899999,6999999,7899999,7999999,8899999,8999999,9999999,25999999,26899999,26999999,27899999,27999999,28899999,28999999,29999999,37899999,37999999,38899999,38999999,39999999,47999999,48899999,48999999,49999999,58999999,59999999,68999999,69999999,78999999,79999999,88999999,89999999,99999999,259999999,268999999,269999999,278999999,279999999,288999999,289999999,299999999,378999999,379999999,388999999,389999999,399999999,479999999,488999999,489999999,499999999,589999999,599999999,689999999,699999999,789999999,799999999,889999999,899999999,999999999};
int res[211] = {1,2,3,4,5,6,7,8,9,10,12,14,16,18,21,24,27,28,32,36,40,45,48,54,56,63,64,72,81,90,96,108,112,126,128,144,162,168,189,192,216,243,252,256,288,324,360,405,432,486,504,567,576,648,729,810,864,972,1008,1134,1152,1296,1458,1512,1701,1728,1944,2187,2268,2304,2592,2916,3240,3645,3888,4374,4536,5103,5184,5832,6561,7290,7776,8748,9072,10206,10368,11664,13122,13608,15309,15552,17496,19683,20412,20736,23328,26244,29160,32805,34992,39366,40824,45927,46656,52488,59049,65610,69984,78732,81648,91854,93312,104976,118098,122472,137781,139968,157464,177147,183708,186624,209952,236196,262440,295245,314928,354294,367416,413343,419904,472392,531441,590490,629856,708588,734832,826686,839808,944784,1062882,1102248,1240029,1259712,1417176,1594323,1653372,1679616,1889568,2125764,2361960,2657205,2834352,3188646,3306744,3720087,3779136,4251528,4782969,5314410,5668704,6377292,6613488,7440174,7558272,8503056,9565938,9920232,11160261,11337408,12754584,14348907,14880348,15116544,17006112,19131876,21257640,23914845,25509168,28697814,29760696,33480783,34012224,38263752,43046721,47829690,51018336,57395628,59521392,66961566,68024448,76527504,86093442,89282088,100442349,102036672,114791256,129140163,133923132,136048896,153055008,172186884,191318760,215233605,229582512,258280326,267846264,301327047,306110016,344373768,387420489};
int main()
{
    int n;cin >> n;
    int p = upper_bound(ans,ans + 211,n) - ans - 1;// 注意需要 - 1
    cout << res[p];
    return 0;
}
```

---

## 作者：OLE_OIer (赞：0)

这道题比较方便的方法是用贪心算法。

在代码的二层循环中，第一层的 $i$ 暴力枚举数位，第二层前面 $1$ 一直到 $i-1$位不变，第 $i$ 位 $-1$ ，后面的该怎么办呢？当然是都取 $9$ 就好了。枚举完之后用打擂台的方法使得最后乘积取最大值。

话不多说，给大佬们献上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string s;
	cin>>s;
	/*字符串会比int类型好用很多，
	因为string类型可以直接查找，
	但int类型需要用繁琐的计算*/ 
	int len=s.length();
	long long maxn=1;
	for(int i=0;i<len;++i) maxn*=s[i]-'0';
	for(int i=0;i<len;++i){
		long long tmp;
		if(s[i]!='1') tmp=s[i]-'0'-1;
		else tmp=1;
		for(int j=0;j<i;++j) tmp*=(s[j]-'0')
		for(int j=i+1;j<len;++j) tmp*=9;
		maxn=max(maxn,tmp);
	}
	cout<<maxn;
	return 0;
} 
```

---

## 作者：ciwomuli (赞：0)

比赛一开始想用构造做，结果一直WA  
后改用DP就行了  
这道题的主要难点在于处理退位的问题  
DP一下就好了  
定义dp[i][0]为第i位退位能取到的最大的数  
定义dp[i][1]为第i位不退位能取到的最大的数  
转移方程是显然的  
然后就A了
```
//by ciwomuli
//AK JSOI 2019
#include <algorithm>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
#define LL long long
using namespace std;
template <typename T>
inline void read(T &t)
{
    int f = 0, c = getchar();
    t = 0;
    while (!isdigit(c))
        f |= c == '-', c = getchar();
    while (isdigit(c))
        t = t * 10 + c - 48, c = getchar();
    if (f)
        t = -t;
}
template <typename T, typename... Args>
inline void read(T &t, Args &... args)
{
    read(t);
    read(args...);
}
LL dp[15][2];
LL x[15];
int main()
{
    char ch;
    ch = getchar();
    int tot = 0;
    while (isdigit(ch))
    {
        x[++tot] = ch - '0';
        ch = getchar();
    }
    LL ans = x[1];
    dp[1][1] = x[1];
    dp[1][0] = max(1ll, x[1] - 1);
    for (int i = 2; i <= tot; i++)
    {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) * (x[i] - 1);
        dp[i][0] = max(dp[i][0], dp[i - 1][0] * 9);
        dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]) * x[i];
        ans = max(ans, max(dp[i][0], dp[i][1]));
    }
    cout << ans;
}
```

---


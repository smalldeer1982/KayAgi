# MP3

## 题目描述

有一种数字化一段录音的常用方式，是记录每一个时刻的强度值。这些非负的强度值就可以代表一段音频

对于一段音频，若有 $K$ 个不同的强度值，那么每一位我们都需要 $k = \lceil\log_2K \rceil$ $\text{bit}$ 来存储

也就是说，为了存储这一段音频，我们需要 $nk$ 个 $\text{bit}$

为了压缩音频大小，我们们采取如下的方式：

选择两个整数 $l, r(l \leq r)$，对于音频的强度值序列 $v$，将其作一次变换：

$$
v_i = 
\begin{cases}
v_i&l \leq v_i \leq r \\
l &v_i < l\\
r &r < v_i
\end{cases}
$$

其中第 $2, 3$ 种情况被视作 $v_i$ 这个强度值被更改了

你的任务是对于给定的强度值序列 $a$，找到一组 $l, r$，使得在经过上述压缩后能够被大小为 $I \ \text{bytes} (\text{1bytes = 8 bit})$ 的存储器装下，并最小化被更改的强度值的数量

## 样例 #1

### 输入

```
6 1
2 1 2 3 4 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 2
2 1 2 3 4 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
6 1
1 1 2 2 3 3
```

### 输出

```
2
```

# 题解

## 作者：Zechariah (赞：2)

首先要读懂题：  
有$K$个不同的值，需要$k=\lceil log_2K \rceil$个位来存储，又需要$n\cdot k$位来存储整个文件，现在给定磁盘大小是$I$字节($8\cdot I$位)，问需要至少需要改变几个值的大小，使得改变后有$K'$个不同的值，$n\cdot\lceil log_2K' \rceil \le 8\cdot I$

首先很容易想到，$I$都给你了，那你就可以求出$k$的最大值，来保证$K'$最小  
$k_{max}=\lfloor \frac{8\cdot I}{n} \rfloor$  
这个时候就能求出$K'$的最大值$K_{max}=2^{k_{max}}$  
这里要注意溢出问题，$2^{k_{max}}$可能很大，所以在不断$\times2$的过程中判断$K_{max}$是否大于等于$K$，是的话直接输出$0$就完了  
为了方便，将整个数组排序并压缩，留下一串不同的从小到大的数以及它们的个数  
然后就要在这里面找出一段$K_{max}$个不同的数，使得其他数的个数之和最小，直接顺次移动选择的区间就行了，记录最小值


```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x & -x)
#define jh(x, y) x ^= y ^= x ^= y
#define loc(x, y) (x - 1) * m + y
#define rg register
#define inl inline
#define PI 3.141592654
typedef long long ll;
const int N = 4e5 + 5, INF = 0x3f3f3f3f, mod = 998244353;
using namespace std;
namespace fast_IO {
	inl ll read() {
		rg char c;
		rg ll x = 0;
		rg bool flag = false;
		while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
		if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48;
		while ((c = getchar()) != ' ' && c != '\n' && c != '\r' && ~c)
			x = (x << 1) + (x << 3) + (c ^ 48);
		if (flag)return -x; return x;
	}
	inl ll max(rg ll a, rg ll b) { if (a > b)return a; return b; }
	inl ll min(rg ll a, rg ll b) { if (a < b)return a; return b; }
	void write(rg ll x) { if (x < 0)putchar('-'), x = -x; if (x >= 10)write(x / 10); putchar(x % 10 ^ 48); }
}
ll a[N], b[N], cnt[N], sum;

int main() {
	rg ll n = fast_IO::read(), len = fast_IO::read();
	for (rg int i = 1; i <= n; ++i)a[i] = fast_IO::read();
	sort(a + 1, a + n + 1);
	rg ll kmax = (len << 3) / n, dmax = 1, tot = 0, tmp = -1;
	for (rg int i = 1; i <= n; ++i) {
		if (tmp != a[i])tmp = a[i], ++tot;
		++cnt[tot];
	}
	for (rg int i = 0; i < kmax; ++i) {
		dmax <<= 1;
		if (tot <= dmax) { puts("0"); return 0; }
	}
	rg ll minn = 0, now;
	for (rg int i = tot; i > dmax; --i)sum += cnt[i];
	now = minn = sum;
	for (rg int i = 2; i <= tot - dmax + 1; ++i) {
		now += cnt[i - 1];
		now -= cnt[i + dmax - 1];
		minn = fast_IO::min(minn, now);
	}
	fast_IO::write(minn);
	return 0;
}

```


---

## 作者：Rex01 (赞：1)

## [CF1198A 题目传送门](https://www.luogu.com.cn/problem/CF1198A)

## 题目大意
数字化声音常用在特定时间点记录声音强度，每个时间点的声音强度表示为一个非负整数。声音文件可表示为包含 $n$ 个非负整数的数组。若数组中有 $K$ 个不同的值，则需 $K$ 位存储每个值，其中 $K=\lceil\log_2 K\rceil$，存储整个文件需 $n \cdot k$ 位。为减少内存消耗，应用压缩方法，即选择两个整数 $l \leq r$，将强度值按照以下规则更改：在 $[l,r]$ 范围内的不变，小于 $l$ 的改为 $l$，大于 $r$ 的改为 $r$，从而减少强度值种类。你的任务是应用这种压缩方法，使文件适应大小为 $I$ 字节的磁盘，并且尽可能少地更改数组中的元素。

**提醒**：$1$ 字节包含 $8$ 位，$K=\lceil\log_2 K\rceil$ 为最小整数，满足 $K \leq 2^k$。特别地，若 $K=1$，则 $k=0$。

## 解决思路
首先想到**贪心**，即将所有相同的放在一起，使得效率最大。随后用**前缀和**记录：在第 $i$ 个数和它之前，有多少种不同的数，然后就用**二分答案**，先来一重循环枚举开头，再用二分枚举长度。

## 代码展示
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
//拒绝万能头,从我做起
using namespace std;

const int N = 4e5 + 10;
int n, I, a[N], dp[N], ans;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);//减少时间
	cin >> n >> I;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	sort(a + 1, a + n + 1);//从小到大排序
	for(int i = 1; i <= n; i++)
	{
		dp[i] = dp[i - 1]; //前缀和
		if(a[i] != a[i - 1]) dp[i]++;
	}
	for(int i = 1; i <= n; i++)
	{
		int l = i, r = n + 1;
		while(l < r - 1)
		{//二分 
			int mid = (l + r) >> 1;//求mid
			if(log2(dp[mid] - dp[i] + 1) <= I * 8 / n) l = mid;
			else r = mid; //log2函数计算以2为底的对数
		}
		ans = max(ans, l - i + 1);
	}
    cout << n - ans << endl;
 	return 0;//换行是个好习惯 
}
```

---

## 作者：weisongze (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/CF1198A)
## 思路
注意到题目给了 $I$（内存），可以直接逆向求出 $K$ 的最大值，因为我们需要最小的删除数量，显然此时 $K$ 个不同为最优。

  所以我们只需要考虑尽量删除数量更少的强度值就ok了。题目中允许 $O(n)$ 的复杂度，删除时需要确定 $l,r$ 删除两边，一眼双指针（区间）实现。
  
  用桶记录相同强度的音频，可以确定中间有 $K$ 个不同值，枚举时两边同时加，中间的和取最大值，这样删除的就最小了。
  ## 注意
  1. $K$ 的最大值为 $n$ ，计算时特判防止过大，如果超过范围随便存。
  2. 如果强度不同数量在开始时就不及最大值，根本不需要删除，直接结束。
  ## Code
  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define F(i,x,y) for(i=x;i<=y;i++)
int a,n,k,I,ans,sum;
set<int> s;
map<int,int> m;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int i;
	cin>>n>>I;
	if(I*8/n>=31) //特判
	{
		cout<<0;
		return 0; 
	}
	k=1<<(I*8/n);//计算最大值
	F(i,1,n) //输入，计数
	{
		cin>>a;
		m[a]++;
		s.insert(a);
	}
	if(s.size()<=k) cout<<0;
	else
	{
		auto r=s.begin(),l=s.begin();
		F(i,1,k)//初始化和
		{
			sum+=m[*r];
			r++;
		}
		while(r!=s.end())//双指针枚举
		{
			sum=sum-m[*l]+m[*r];
			l++,r++;
			ans=max(ans,sum);
		}
		cout<<n-ans;//输出答案
	}
	return 0;
}
```

---

## 作者：SFWR (赞：1)

首先考虑一下计数，既然要求出不符合范围$（l，r）$的数，那么就要先求出来各个值的数量，由此可以想到桶计数，但又因为本题值域很大，而n很小，所以可以考虑离散化，离散化之后，根据贪心可以得到$（l，r）$的长度越长越好，根据题意求出长度，再前缀和一次，然后枚举区间即可

注意，最大长度可能会很大，所以要先判断一次n与最大长度的大小，直接用log2（）比较即可



~~比赛的时候用的log（）惨遭WA~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int I,n,m,a[501000],ct[1005000];
int cmp(int a,int b){return a>b;}
int main()
{
	cin>>n>>I;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n,cmp);
	int cnt=0,num=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]!=a[i+1])
		{
			num++;
			ct[++cnt]=num;
			num=0;
		}
		else num++;
	}int maxk=(8*I/n);
	if(log2(cnt)<=maxk){cout<<0;return 0;}
	maxk=pow(2,maxk);
	for(int i=1;i<=cnt+maxk;i++)ct[i]+=ct[i-1];
	int ans=0x3f3f3f3f;
	for(int i=1;i<=cnt;i++)
	ans=min(ans,ct[i]+ct[cnt]-ct[i+maxk]);
	cout<<ans;
	
}
```


---

## 作者：Peter20122012 (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/CF1198A)

## 思路
首先注意到单位不一样，所以储存空间实际为 $8I$ bit，所以要求为 $nk \leq 8I $ 也就是 $k \leq \big\lfloor \frac{8I}{n} \big\rfloor$，为了能够更改最少的值，所以 $k$ 应该取最大值 $\big\lfloor \frac{8I}{n} \big\rfloor$。又因为 $k = \lceil \log_{2}K \rceil$，所以 $K = 2^{k} = 2^{\big\lfloor \frac{8I}{n} \big\rfloor}$。但是 $k$ 最大时 $k = \big\lfloor \frac{8 \cdot 10^{8}}{1} \big\rfloor = 8 \cdot 10^{8}$，此时 $K = 2^{8 \cdot 10^{8}}$，`long long` 都存不下。但是 $K$ 表示的是不同的强度值个数，而 $n$ 个数最多就 $n$ 种强度值，且 $2^{20} = 1048576 > 4 \cdot 10^{5}$，其实 $k \geq 20$ 时并没有额外贡献，所以可以令 $k = \min(\big\lfloor \frac{8I}{n} \big\rfloor, 20)$。记原本不同强度值的个数为 $len$，则当 $K \geq len$ 时无需修改，输出 $0$。否则考虑使用滑动窗口，输出最小修改元素数量

## 具体做法
将 $a$ 数组排序，然后按顺序将其加入统计数组 $cnt$，$cnt_{i}$ 表示 $a$ 中第 $i$ 大的书有多少个，并记总共有 $len$ 个不同的值。

按照 $k = \min(\big\lfloor \frac{8I}{n} \big\rfloor, 20)$ 与 $K = 2^{k}$ 这两个式子计算出 $K$，如果此时 $[K > len] = 1$ 则令 $K = len$。更改后如果 $[K = len] = 1$ 则输出 $0$ 并结束程序。

然后先令需要修改的值的数量 $change = n$，再循环 $i \in [1, K]$ 并让 $change$ 减去 $cnt_{i}$。

循环 $i \in [2, len - K + 1]$ 并每次都令 $change = change + cnt_{i - 1} - cnt_{i + K - 1}$，$ans = \min(ans, change) $。

最后输出 $ans$。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;

#define MAX(x, y) (((x) >= (y)) ?(x) :(y))
#define MIN(x, y) (((x) <= (y)) ?(x) :(y))
#define FOR(st, ed, i) for (int i = st; i <= ed; ++i)
#define RFOR(st, ed, i) for (int i = ed; i >= st; --i)
#define fir first
#define sec second

//#define debug

typedef long long ll;
typedef double db;
typedef pair<ll, ll> pll;

const int inf = 0x3f3f3f3f;
const int maxn = 4e5 + 10;

int n, I;
int a[maxn];

int len;
int cnt[maxn];

int mxk, mxK, change, ans;

int main () {
	scanf("%i%i", &n, &I);
	FOR (1, n, i) {
		scanf("%i", &a[i]);
	}
	
	sort(a + 1, a + n + 1);
	FOR (1, n, i) {
		if (a[i] != a[i - 1]) {
			++len;
		}
		++cnt[len];
	}
	change = n;
	mxk = MIN(20, 8*I/n);
	mxK = MIN(1 << mxk, len);
	if (mxK >= len) {
		printf("0\n");
		return 0;
	}
	FOR (1, mxK, i) {
		change -= cnt[i];
	}
	ans = change;
	FOR (2, len - mxK + 1, i) {
		change += cnt[i - 1];
		change -= cnt[i + mxK - 1];
		ans = MIN(ans, change);
	}
	
	printf("%i\n", ans);
	return 0;
}
```

---

## 作者：Parabola (赞：0)

#### Part0.题外话

船新的解法？

看了看题解，发现就我的方法是没有出现过的，也是最垃圾复杂度最高的

但是好想（

时间复杂度$O(n * \log^2n)$

#### Part1.思路

注意到$I$是byte，我们先把$I$变成$8 * I$代表$8 * I$个bit

接着,顺手推下式子

$∵ n * k <= I$

$∴ k <= I / n$

所以我们最多只能删掉$2^k$个数

接下来我们就二分$[L,R]$使得满足$L<=A_i<=R$的$i$的数量小于等于$2^k$

然后你发现复杂度不对的时候，多搞几个lower_bound,upper_bound优化就行了啊

#### Part2.Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i , a , b) for(int i = (a) ; i <= (b) ; ++i)
#define irep(i , a , b) for(int i = (b) ; i >= (a) ; --i)
#define IO ios::sync_with_stdio(false)
#define ms(A) memset(A , 0 , sizeof A)
#define msinf(A) memset(A , 0x3f , sizeof A)
typedef long long ll;
typedef pair <int , int> pii;

const int inf = 0x3f3f3f3f;
const ll infLL = 0x3f3f3f3f3f3f3f3fLL;

const int N = 400000 + 5;

vector <int> v , lhy;

int n , I , A[N] , maxv;
int c[N];


int Query(int l , int r) {
	return upper_bound(v.begin() , v.end() , r) - lower_bound(v.begin() , v.end() , l);
}

int Query2(int l , int r) {
	return upper_bound(lhy.begin() , lhy.end() , r) - lower_bound(lhy.begin() , lhy.end() , l); 
}

int main() {
	scanf("%d %d" , &n , &I); I *= 8;
	int k = ceil(log2(n));
	int maxv = 1 << (min((int)I / n , k));
	rep(i , 1 , n) scanf("%d" , A + i);
	rep(i , 1 , n) v.push_back(A[i]) , lhy.push_back(A[i]);
	sort(lhy.begin() , lhy.end());
	sort(v.begin() , v.end()); v.erase(unique(v.begin() , v.end()) , v.end());
	int len = v.size() - 1 , ans = inf;
	rep(i , 0 , len) {
		int L = v[i]; 
		int l = L , r = 1e9 + 1;
		while(l + 1 < r) {
			int mid = (l + r) >> 1;
			int k = Query(L , mid);
			if(k > maxv) r = mid;
			else l = mid; 
		}
		ans = min(ans , n - Query2(L , l));
	}
	printf("%d\n" , ans);
	return 0;
}
```


---

## 作者：世末OIer (赞：0)

先贪心。（将所有相同的放在一起，这样效率最大）

然后，用前缀数组记录:在第i个数及之前，有多少种不同的数？

然后就可以二分答案了。先循环枚举头，再二分枚举长度。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mp make_pair
using namespace std;
int n,x,y,k;
int a[400005];
int pre[400005];
int sum;
inline int lg2(int x){   //求log2(题目要求)
	int t=1,rt=0;
	while(t<x)t<<=1,++rt;
	return rt;
}
int main(){
	ios_base::sync_with_stdio(false);
	cin>>n>>k,k*=8;
	for(int i=1;i<=n;++i)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i)pre[i]=pre[i-1]+(bool)(a[i]!=a[i-1]);  //计算前缀和
	int ans=0;
	for(int i=1;i<=n;++i){
		int l=i,r=n+1,md;
		while(l<r-1){  //二分
			md=l+r>>1;
			int t=lg2(pre[md]-pre[i]+1);
			if(n*t<=k)l=md;else r=md;
		}
		ans=max(ans,l-i+1);
	}
	cout<<n-ans<<endl;
}
```

---


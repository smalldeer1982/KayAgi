# Lucky Transformation

## 题目描述

Petya喜欢幸运数字。每个人都知道幸运数字是十进制下各位只包含$4$和$7$的正整数。例如数字$47$、$744$和$4$都是幸运数字，但$5$、$17$和$467$不是。

Petya有一个由$n$位数字组成的没有前导零的数。他用一个没有前导零的数组来表示这个数，我们称它为$d$。数组的下标从$1$开始顺序输入。Petya想要进行$k$次如下的变换:找到一个最小的$x(1<=x< n)$使得其满足$d_x=4$并且$d_{x+1}=7$。如果$x$是奇数，那么让$d_x=d_{x+1}=4$，否则让$d_x=d_{x+1}=7$。若没有满足条件的$x$，则数字不变。

给定初始数组和数字$k$，请你帮助Petya得出$k$次操作后的结果。

## 说明/提示

在第一个样例中数字变换成如下序列:$4727447\to4427447\to4427477\to4427447\to4427477$
在第二个样例中:$4478\to4778\to4478$

## 样例 #1

### 输入

```
7 4
4727447
```

### 输出

```
4427477
```

## 样例 #2

### 输入

```
4 2
4478
```

### 输出

```
4478
```

# 题解

## 作者：论之铭 (赞：6)

仔细观察题面发现，$k$的取值远大于$n$，显然在操作的过程中出现了循环，否则就是无效操作
考虑何时出现循环，当出现一个满足条件的$x$时

- 当$x\mod2==1$时，使$d_{x+1}=4$，显然，若此时存在$d_{x+2}==7$，由于$x\mod2==1$，所以$x+1\mod2==0$，所以使$d_{x+1}=7$，然而此时$d_x=4$，所以$x$又可以对答案造成一次贡献

- 当$x\mod2==0$时，使$d_{x}=7$，若存在$d_{x-1}==4$，由于$x\mod2==0$，所以$x-1\mod==1$，所以又可以转变成上面那种情况

当存在上下两种情况互相转换时，就出现循环，此时我们只需考虑$k$的奇偶性$O(1)$变换即可

代码如下

```cpp
#include <cstdio>
#include <algorithm>

const int N = 100009;

int n, k, flag;
int d[N];

int main() {
    scanf("%d%d", &n, &k);
    flag = 0;
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    for (int i = 1; i <= n; i++) d[i] = c - '0', c = getchar(); 
    for (int i = 1; i <= n && k; i++) {
        if (d[i] == 4 && d[i + 1] == 7 && d[i + 2] == 7 && (i & 1)) k %= 2;
        if (d[i] == 4 && d[i + 1] == 7 && k) {
            if (i & 1) d[i + 1] = 4;
            else d[i] = 7;
            i -= 2, k--;
        }
    }
    for (int i = 1; i <= n; i++) putchar(d[i] + '0');
    return 0;
}
```

~~题目这么简单不要问我为什么是黑的~~

---

## 作者：霜月めくり (赞：6)

# 这题有点水

这道题的大致意思就是找一个x最小的d[x]==4，d[x+1]==7,然后如果x为奇数,则令d[x+1]=4,反之则令d[x]=7。

显然，暴力的每次去找这个x在1e9这么大的数据下肯定会爆。

## 那怎么办呢？

在每次更改完成后，会发现需要重新判断的只有d[x-1]，所以我们可以不用每次都找出x，而可以顺序的查找一遍，每次更改完后退一格重新判断即可。

考虑到有开头序号为奇数的477，此题会让它在477与447中不断转换，则只需考虑剩下转换的情况即可。

那么贴上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
char m[1000001];
int main(){
    scanf("%d",&n);
    scanf("%d%s",&k,m);
    for(int i=0;i<n&&k;i++)
    {
        if(m[i]=='4'&&m[i+1]=='7'&&m[i+2]=='7'&&!(i&1))	k=k%2;//找477
        if(k&&m[i]=='4'&&m[i+1]=='7'){
            if(i&1) m[i]=m[i+1];
            else m[i+1]=m[i];
            i-=2;
            k--;//剩下的就普通操作
        }
    }	
    printf("%s",m);
    return 0;
}
    

```

---

## 作者：sto__Liyhzh__orz (赞：2)

[传送门：](https://www.luogu.com.cn/problem/CF121B)

**题意**：共执行 $k$ 次，每次找到最小的 $x$ （$1 \le x \le len-1$），使得 $s_x = 4$，并且 $s_{x+1} = 7$，执行如下指令：

$$\begin{cases} s_{x+1}=4 & x \equiv 0 \pmod 2 \\s_x=7 & x \equiv 1 \pmod 2 \end{cases}$$

**思路**：根据样例二可以发现：开头位置是**奇数**的 **477** 可以产生一个轮回！

其他的就是普通操作，按照题意（如上）来做即可。

****

```cpp
#include<bits/stdc++.h>
using namespace std;

int len,k;
string s;

int main()
{
    cin>>len>>k>>s;
    for(int i=0;i<=len-1 && k;i++)
    {
        if(i<=len-3 && i%2==0 && s[i]=='4' && s[i+1]=='7' && s[i+2]=='7') k%=2;    //查找447
        if(i<=len-2 && k && s[i]=='4' && s[i+1]=='7') //普通操作
        {
            if(i%2==0) s[i+1]=s[i];
            else s[i]=s[i+1];
            i-=2,k--;
        }
    }
    cout<<s<<endl;
    return 0;
}
```

---

## 作者：Nuclear_Fish_cyq (赞：1)

首先考虑最基础的暴力。我们按照题意模拟，每次操作需要找到最小的 $x$，是 $O(n)$ 的，有 $k$ 次操作，所以总的是 $O(nk)$ 的。

接下来我们发现每次操作实现只修改 $a_x$ 和 $a_{x+1}$，也就是说对 $x$ 进行操作不会影响 $x$ 前面的数，那么我们对于每次操作只需直接从上一次操作的位置前一个数开始搜，时间复杂度是 $O(n+k)$。

可是 $k$ 太大了，还是过不了，怎么办？这道题连 $O(k)$ 都过不了，于是直接猜想一个有循环出现。我们试着找出这个循环。

首先，我们设定一个数字串 `...47...`（我们设这里出现的 `47` 是第一个 `47`）。接下来我们分类讨论：

如果这个 `47` 的开头在奇数位：

第一次操作会把这个数字串变为 `...44...`。接下来为了循环出现，第二个 `4` 的下一位必须是 `7`。为什么呢？每次操作的条件判断和修改都只涉及相邻两个数字，如果下一个 `47` 不在第二个 `4` 上最开始的 `47`,就无法成为循环了。反推过去，这个数字串应该形如 `...477...`，其中 `4` 在奇数位。我们检验一下：`477` 和 `447` 构成了一个循环。

如果这个 `47` 的开头在偶数位：

第一次操作会把这个数字串变为 `...77...`。可是要是后面再出现 `47` 的话，再好也只能是 `...7747...`，无法构成循环，于是我们只能往前推，第一个 `7` 的前面必须是 `4`，即操作一次的数字串形如 `477`，反推过去，原串应该形如 `...447...`，其中第二个 `4` 在偶数位，也就是说第一个 `4` 在奇数位。我们发现这有点眼熟，于是我们对这个数字串进行一次操作，然后它就变成了 `...477...`。这么看来，这两种循环是同一种循环，就不用太多特判了。

整理一下，我们的做法应该是这样的：

遍历 $i$，如果这个位置是 `47` 的开头那么先特判这是不是 `477`，如果是就让剩余操作数变成自己模二。接下来我们特判这时候剩余操作数是不是一个都不剩了，如果是直接退出循环，不然就直接按照题意操作，然后再让 $i$ 退一格。

上代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define ull unsigned long long
#define inf INT_MAX
#define linf LLONG_MAX
#define ninf INT_MIN
#define nlinf LLONG_MIN
//#define mod
//#define range
using namespace std;
int n, k;
string s;
int main(){
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k >> s;
	for(int i = 0; i < n - 1 && k != 0; i++){
		if(s[i] == '4' && s[i + 1] == '7'){//按题意操作
			if(i % 2 == 0 && i != n - 2 && s[i + 2] == '7'){//特判 
				k %= 2;
			}
			if(k == 0){
				break;
			}
			if(i % 2 == 0){//由于string的下标从0开始，奇偶反转 
				s[i + 1] = '4';
			}
			else{
				s[i] = '7';
			}
			i -= 2;//退位
			k--;//记录操作数 
		}
	}
	cout << s << endl; 
	return 0;
}

```


---

## 作者：QWQ_123 (赞：0)

通过题目可以发现，在奇数位且是 $\texttt{477}$ 或 $\texttt{447}$ 时会有循环，于是考虑非循环暴力，循环直接通过剩余操作数的奇偶性即可（因为都是两个一循环）。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, k;
string s;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> k >> s;

	for (int i = 0; i < n; ++i) {
		int id = i + 1;
		if (id & 1) {
			if (i + 2 < n && s[i] == '4' && s[i + 1] == '7' && s[i + 2] == '7') {
				k = k % 2;
				if (k == 0) {
					cout << s << endl;
					return 0;
				} else {
					s[i + 1] = '4';
					cout << s << endl;
					return 0;
				}
			} else if (i + 2 < n && s[i] == '4' && s[i + 1] == '4' && s[i + 2] == '7') {
				k = k % 2;
				if (k == 0) {
					cout << s << endl;
					return 0;
				} else {
					s[i + 1] = '7';
					cout << s << endl;
					return 0;
				}
			} else if (i + 1 < n && s[i] == '4' && s[i + 1] == '7' && k) {
				s[i + 1] = '4';
				--k;
			}
		} else if (i + 1 < n && s[i] == '4' && s[i + 1] == '7' && k) {
			s[i] = '7';
			--k;
		}
	}

	cout << s << endl;

	return 0;
}
```

---

## 作者：SpringFullGarden (赞：0)

## 题意

有一个长度为 $n$ 的数组 $a_i$，对其进行 $k$ 次操作：找的最小的 $i$，满足 $a_i = 4$ 且 $a_{i + 1} = 7$（即找到最早出现的 `47`，后文用这种方式表示），如果 $i$ 是奇数，那么 $a_{i + 1} \gets 4$，否则 $a_i \gets 7$。求 $k$ 次操作后的数组。

## 思路

可以发现，当找到最早出现的 `447 ` 时且开头是奇数时，构成了一个循环： 先会变为 `477`，然后又变回 `447`。所以当找到 `447` 且开头时奇数时，$k \gets k \bmod 2$。

## 代码

```cpp
int a[100005];

int main() {
	int n = rd(), k = rd();
	string s; cin >> s; s = " " + s;
	for(int i = 1; i <= n; i++) a[i] = s[i] - 48;
	for(int i = 1; i < n && k; i++) {
		if(a[i] == 4 && a[i + 1] == 7) {
			if(i & 1 && i < n - 1 && a[i + 2] == 7) k %= 2;
			if(!k) break;
			if(i & 1) a[i + 1] = 4;
			else a[i] = 7;
			i -= 2;
			k--;
		}
	}
	for(int i = 1; i <= n; i++) cout << a[i];
    return 0;
}
```



---


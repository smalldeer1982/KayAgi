# Terse princess

## 题目描述

公主要选新郎啦！

公主想选一个最有钱的新郎，所以当她看到一个新郎比之前的新郎都有钱时，她会发出“哦”的叫声，而若她看到一个新郎比前面所有新郎加起来都富有时，她会发出“哇！”的声音（但此时她不会发出“哦”的声音）。在遇到第一个新郎时，公主不会说话。

## 样例 #1

### 输入

```
10 2 3
```

### 输出

```
5 1 3 6 16 35 46 4 200 99```

## 样例 #2

### 输入

```
5 0 0
```

### 输出

```
10 10 6 6 5```

# 题解

## 作者：PR_CYJ (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/CF148C)
# 思路
###### ~~这道题本蒟蒻觉得挺简单的，但我还是花费了近三十分钟来解决这道题。~~

这道题我们可以发现公主发出哦和哇的动作互不干扰，所以我们就可以 $ O(n) $ 进行枚举。（记前几位的和为 $ sum $，公主总共要发出 $ s1 $ 个哦，$ s2 $ 个哇，记录解的数组为 $ a $）

首先，因为 $ a_i \le 50000 $，所以我们将 $ a_1 $ 设为 $ 1 $，以避免漏解。我们从第 $ 2 $ 位开始枚举。对于每一位，因为哇的优先度比哦高，所以我们先考虑哇。如果当前 $ s2 $ 大于等于 $ 0 $，那么 $ a_i $ 就为 $ sum+1 $，并且 `s2--`。否则如果 $ s1 $ 大于等于 $ 0 $，那么 $ a_i $ 就为 $ a_{i-1}+1 $，并且 `s1--`。而如果 $ s1 $ 和 $ s2 $ 都为 $ 0 $，那么 $ a_i $ 就等于 $ a_{i-1} $。

但是这种方法有一个问题，就是当 $ s1 $ 大于 $ 0 $，$ s2 $ 等于 $ 0 $ 的时候，程序会将第二位设为 $ 2 $，但由于它比前 $ 1 $ 位的和 $ 1 $ 还要大，所以公主在此时会发出哇，不符合 $ s2=0 $ 的要求。所以我们要特判这个问题，这时候使 $a_2$ 也等于 $ 0 $ 就可以了。

最后是一些代码细节，因为 $ a_i \le 50000 $，所以我们每一位都要判断，如果 $ a_i>50000 \ $ 就直接输出 $ -1 $（因为 $ a_1 $ 为 $ 1 $，所以 $ a $ 数组一定是最优解，如果 $ a_i>50000 \ $ 就无解了）。而且，最后一定要**特判**，如果 $ s1>0 $ 或 $ s2>0 $，那么就无解，就要输出 $ -1 $！！！本蒟蒻就在这里调了十多分钟！！！

# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,s1,s2,sum=1;
	cin>>n>>s1>>s2;
	int a[n+10]={};
	a[1]=1;
	if (s1>0&&s2==0)//特殊情况，如果不特判就会WA 
	{
		a[2]=1;
		sum++;//更新sum 
		for(int i=3;i<=n;i++)
		{
			if (s2>0)
				a[i]=sum+1,s2--;
			else if (s1>0)
				a[i]=a[i-1]+1,s1--;
			else
				a[i]=a[i-1];
			if (a[i]>50000)//特判 
			{
				cout<<-1<<endl;
				return 0;
			}
			sum+=a[i];//更新sum 
		}
	}
	else
	{
		for(int i=2;i<=n;i++)
		{
			if (s2>0)
				a[i]=sum+1,s2--;
			else if (s1>0)
				a[i]=a[i-1]+1,s1--;
			else
				a[i]=a[i-1];
			if (a[i]>50000)//特判 
			{
				cout<<-1<<endl;
				return 0;
			}
			sum+=a[i];//更新sum 
		}
	}
	if (s1==0&&s2==0)//一定要判断！！！ 
		for(int i=1;i<=n;i++)
			cout<<a[i]<<" ";
	else
		cout<<-1<<endl;
}
```

---

## 作者：Ag2WO4 (赞：0)

很好的一道细节贪心题，特判的注意情况不少。

首先考虑财产限制，“嗯”只需要比当前最大值多一即可，“哇”却需要大于当前总值，人越多增量越大，于是首先安排“哇”，“嗯”的安排则只要在“哇”之后即可。归纳可得“哇”的值是二的幂次。

特判：如果最优依然超过财产限制显然无解；如果“嗯”和“哇”的总数加一超过了总人数（注意到第一个人没有反应）也显然无解。

特特判：没有“哇”的情况要把“嗯”放后面，防止“哇”的出现。特别注意，如果第二个数比第一个数大会触发“哇”，所以如果“嗯”只比总人数少一也要无解。

特特特判：上述情况注意，可能没有第二个数，输出任意值即可。
#### 代码
```python
n,a,b=map(int,input().split())
if 1<<b>50000-a or a+b+1>n or a+1==n>1:print(-1)
elif b:print(*(1<<i for i in range(b+1)),*((1<<b)-~i for i in range(a)),*([1]*(~b-a+n)))
else:print(*([1]*(n-a)),*(2+i for i in range(a)))
```

---

## 作者：WaterSky (赞：0)

## [CF148C Terse princess](https://www.luogu.com.cn/problem/CF148C)
### 题意简要分析：
题目要求要构造一个长度为 $n$ 的数列，满足有 $a$ 个数满足比它前面的所有数都大，有 $b$ 个数满足比它前面的所有数的和都大，并且数列中的每个数都要求小于 $50000$。

由于有大小的限制，那么很容易想到为了使数尽量小，可以先处理第二种情况，再处理第一种情况。

那么先定第一个数为 $1$，然后再按照上面所说的思路完成。

可是这种方法有一些缺陷（一开始我也没有想到，看了 [wkjwkj](https://www.luogu.com.cn/user/240405) 大佬发的题解才知道），就是如果一开始的 $b$ 等于 $0$ 且 $a$ 不等于零，按照上述的思路来完成，第二个为 $1+1$，也就是 $2$，可是这样子又满足了第二种情况，则不满足题意，所以应该要将第二个改为 $1$ 才符合条件，其处理方式为特判。

然后还有一些细节，比如要在处理时注意判断大小是否超过 $50000$ 等，在代码中呈现。

### 代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,T[105],s=1,t=2;//其中s代表目前的数之和。
int main()
{
	cin>>n>>a>>b;
	T[1]=1;
	if(a!=0 &&b==0) t=3,T[1]=T[2]=1,s=2;
	for(int i=t;i<=n;i++)
	{
	    if(b!=0)//先处理第二种情况。
		{
			T[i]=s+1,b--,s+=T[i]; //将这个数设为前面所有数之和+1，并且将b减1。
			if(T[i]>50000) {cout<<-1;return 0;}//判断是否超过 50000。
		}
		else if(a!=0)//再处理第二种情况。
		{
			T[i]=T[i-1]+1,a--; //将这个数设为前一个加上1，并且将a减1。
			if(T[i]>50000) {cout<<-1;return 0;}//判断是否超过 50000。
			if(T[i]>s) {cout<<-1;return 0;} 
            //如果超过了前面的和，那么就会触发公主的“哇”机制（doge），不符合题意，直接输出 -1。
			s+=T[i];//更改前缀和。
		}
		else T[i]=T[i-1];//如果条件都满足了，那么直接等于前一个。
	}
	if(a==0&&b==0)//如=如果条件满足则输出构造的数组。
		for(int i=1;i<=n;i++)
			cout<<T[i]<<" ";
	else cout<<-1;//否则输出-1。
	return 0;
}
```

---

## 作者：ncwzdlsd (赞：0)

要构造一个长度为 $n$ 的数列，满足有 $a$ 个数满足比它前面的所有数都大（$\texttt{Oh}$），有 $b$ 个数满足比它前面的所有数的和都大（$\texttt{Wow}$）。

其中 $a,b\leq 15,t\leq 50000$。

先考虑如何满足 $\texttt{Wow}$ 性质。由于上面的数据范围，一个公比为 $2$ 的等比数列满足条件（等比数列求和公式 $s_n=\dfrac{a_1(1-q^n)}{1-q}$）。

然后再考虑 $\texttt{Oh}$ 性质。在上面的基础上不断累加即可。

剩下的位全填 $1$。

对于无解的情况，当 $n=a-1$ 且 $a\neq 0$ 且 $b=0$ 时无解，因为此时序列中会有数满足性质 $b$（即第二个数）。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main()
{
    int n,a,b;cin>>n>>a>>b;
    if(n==1) cout<<1,exit(0);
    if(a==n-1) cout<<-1,exit(0);
    int s=n-a-b;
    if(!b)
    {
        for(int i=1;i<=s;i++) cout<<"1 ";
        for(int i=1;i<=a;i++) cout<<(s++)<<' ';
    }
    else
    {
        int t=1;cout<<t<<' ';
        for(int i=1;i<=b;i++) t+=t,cout<<t<<' ';
        for(int i=1;i<=a;i++) t++,cout<<t<<' ';
        for(int i=1;i<s;i++) cout<<1<<' ';
    }
    return 0;
}
```

---

## 作者：hjsxhst2022 (赞：0)

### 题目思路

[原题传送门](https://www.luogu.com.cn/problem/CF148C)

由于公主发出"哇"声时不会发出"哦"声，我们可以想到：

先让公主先发出"哇"的声音，之后再发出"哦"的声音。

所以可以让第一位新郎的财富值 $t_1=1$，再设变量 $sum$ 表示前面所有新郎财富值的总和，每次发出"哇"声就 $b=b-1$，每次发出"哦"声就 $a=a-1$。

如果 $b\ge1$，那么公主还会发出"哇"声，新郎的财富值 $t_i=sum+1$。否则如果 $a\ge1$，那么公主还会发出"哦"声，新郎的财富值 $t_i=t_{i-1}+1$，否则新郎的财富值 $t_i=t_{i-1}$。

但是如果公主没有发出"哇"声，也就是 $b=0$，还是第一位新郎的财富值 $t_1=1$的话，那么第二位新郎的财富值 $t_2=2$，公主会发出"哇"声，不符合题意。所以让 $t_1=1,t_2=1$ 即可。

为什么每次的财富中都是 $+1$ 呢？因为题目有要求 $t_i\le50000$，为了尽量有解所以选择每次都差 $1$。

代码就不写了。

---

## 作者：wkjwkj (赞：0)

由于公主发出“哦”的声音和发出“哇”的声音是互不影响的，所以对于本题我们不难想到一种 $t$ 数列的构造方式：

当公主发出”哦“的声音和”哇“的声音的次数非零时，优先考虑让公主先”哇“。”哇“完后再让公主发出”哦“的叫声。那么即我们可以将第一个新郎的财富值设为 $1$ ，用 $sum$ 表示前面新郎财富的总和，若 $b$ 非零时，当前新郎的财富值为 $sum+1$ ，否则若 $a$ 非零，当前新郎的财富值等于前一个新郎的财富值 $+1$ ，否则新郎的财富等于前一个新郎。

然而，上述构造方法存在一定问题。

看下面一组数据：

```php
9 6 0
```

这时我们应该先让第二位新郎的财富等于 $1$ ，否则公主会发出“哇”的叫声，不符题意，会错误的输出 $-1$ ,所以将这种情况考虑后，我们的算法就正确了。

下面给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
int s[105];
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	s[1]=1;
	int sum=1;
	int st=2;
	if(a&&b==0)
	{
		st=3;
		s[1]=s[2]=1;
		sum=2;
	}
	for(int i=st;i<=n;i++)
	{
	    if(b){
			s[i]=sum+1;
			if(s[i]>50000){
			   puts("-1");
			   return 0;
			}
			b--;
			sum+=s[i];
		}
		else if(a){
			s[i]=s[i-1]+1;
			if(s[i]>50000){
				puts("-1");
				return 0;
			}
			a--;
			if(s[i]>sum){
				puts("-1");
				return 0;
			}
			sum+=s[i];
		}
		else s[i]=s[i-1];
	}
	if(a==0&&b==0){
		for(int i=1;i<=n;i++)printf("%d ",s[i]);
	    puts("");
	}
	else puts("-1");
	return 0;
}
```





---


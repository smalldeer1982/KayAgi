# I Hate 1111

## 题目描述

You are given an integer $ x $ . Can you make $ x $ by summing up some number of $ 11, 111, 1111, 11111, \ldots $ ? (You can use any number among them any number of times).

For instance,

- $ 33=11+11+11 $
- $ 144=111+11+11+11 $

## 说明/提示

Ways to make $ 33 $ and $ 144 $ were presented in the statement. It can be proved that we can't present $ 69 $ this way.

## 样例 #1

### 输入

```
3
33
144
69```

### 输出

```
YES
YES
NO```

# 题解

## 作者：dalao_see_me (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/CF1526B)
## 题目大意
给一个数 $n$，问你该数能不能分解成 $k_1\times11+k_2\times111+k_3\times1111+...$。
## 做法
我们先来找一下规律。
$$
1111=11\times101
$$
$$
11111=11\times1000+111
$$
$$
111111=11\times10101
$$
$$
...
$$
你发现了吗？

当这些数中 $1$ 的个数大于 $3$ 时，这个数一定可以被之前的数表示出来。如果你觉得有必要的话可以一直推到 $10^9$。

于是乎，如果一个数能被表示成 $11a+111b$ 的话，它一定满足题目的要求。

直接上代码。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int _,n;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int main(){
	_=read();
	while(_--){
		n=read();
		if(n%11*111<=n)puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---

## 作者：123hh2 (赞：11)

--->[传送门](https://www.luogu.com.cn/problem/CF1526B)

### 前言
今天确实有点闲的没事干，随便跳了一道题过来的

### 题目大意
~~翻译挺明白的了~~

问给你一数 $x(1≤x≤10^9)$ ，能否用 11,111,1111…… 这些数表示出来

### 思路

**注意这个思路是假的**:

刚开始看的时候感觉这不就是个暴力嘛，因为 $x$ 最大是 $10^9$ 所以只需要 11~11111111 这些数来表示就行。然后再贪个心，把 $x$ 从最大数11111111开始减，直到减不动为止，看最后 $x$ 是否变成了 0 。

事实证明，[Too young too simple](https://www.luogu.com.cn/record/51574054)

**这个思路只是真的**:

首先我们考虑对 11~11111111 进行质因数分解，可以得到：

$11$->$11$

$111$->$111$

$1111$->$11\times100+11$

$11111$->$11\times1000+111$

$111111$->$1111\times100+11$->$11\times1000+1111$

…………

根据上面的柿子，我们能够发现，对于各位数全是 1 的 $n$ ($n$>3)位数，都能表示为 $11\times10^{n-2}+$ 各位全是 1 的 $n-2$ 位数
，而又因为 $n>3$ ，所以各位全是 1 的 $n-2$ 位数
又可以表示为 $11\times10^{n-4}+$各位全是 1 的 $n-4$ 位数
，由此循环下去，最终你会发现，只要是 $n>3$ 的各位全是 1 的一个数，都能被表示为:

$11\times x+111\times y$

111 又可以表示为 $11\times10+1$

原式就可以表示为 $11\times(x+10y)+y$，然后对其进行%11操作，发现余数为 $y$ 说明询问的数对 $11$ 进行取模后，必须保证有 $y$ 个 111，所以我们只需要判断该数对 11 进行取模后的余数乘上 $y$ 是否小于等于该数就可以了
### 代码

灰常简单qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int main()
{
	int n;
	n=read();
	while(n--)
	{
		int x;
		x=read();
        //取模&乘111
		int temp=x%11;
		temp*=111;
        //和原数比大小
		temp<=x?cout<<"YES"<<endl:cout<<"NO"<<endl;
	}
	return 0;
}
```


---

## 作者：BreakPlus (赞：4)

给一种不太寻常的做法。

第一反应是 $\text{dp}$，悲催的是：$1\le x\le10^9$，不行。要知道一共才询问 $10000$ 组数据，肯定有些算出来的值是白算。哎这下咋办？我把一个数倒推过去计算，$\text{dp}$ 值用一个 map 存下来。然后发现记忆化搜索时是很好的选择。

具体证明这个 map 不会爆炸我也不会，有没有大佬可以计算出 map 里面最多放了多少个数？

Code(C++11)：

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<int,bool>m; // 用这个 unordered_map 更快
inline bool dfs(int x){
	if(m.count(x)) return m[x]; // 算过了就不用算了
	int mx=0;
	for(register int i=11;i<=x;i=i*10+1) mx=i;
	for(register int i=mx;i>=11;i=(i-1)/10){
		if(dfs(x-i)){
			m[x]=true;
			return true; // 得到了 true 的值直接跑路
		} // dp 过去，没啥好说的
	}
	m[x]=false;
	return false;
}
int main(){
	int t,x;
	cin>>t;
	m[0]=true;// 初始化
	while(t--){
		cin>>x;
		cout<<(dfs(x)?"YES":"NO")<<endl;
        // 读进来再计算
	}
	return 0;
} 
```

---

## 作者：Umbrella_Leaf (赞：2)

### 题目大意

> 给出一个 $x$ （ $1\le x\le 10^9$ ），要求你从 $11,111,1111,\cdots$ 中选出若干个（可以重复选）使得它们的和等于 $x$ 。

### 分析

我们首先来找下规律：
$$1111=101\times 11$$
$$11111=1000\times 11+1\times 111$$
$$111111=10101\times 11$$
$$1111111=101000\times 11+1\times 111$$
$$\cdots\cdots\cdots\cdots$$

发现了没有？如果一个全由 $1$ 组成的数中 $1$ 的数量大于 $3$ ，则它可以被 $11$ 和 $111$ 表示出来。

这样一来，实际上只有 $11$ 和 $111$ 两个数是有用的。但如何判断一个 $x$ 能否被它们俩凑出来呢？

我们观察 $x$ 对 $11$ 取模之后的数。比如， $x=169$ ：
$$x=15\times 11+4$$
而 $111=10\times 11+1$ ，也就是说，取出一个 $111$ 就相当于给 $x$ 模 $11$ 之后的余数减了一。

比如对于 $x=463=42\times 11+1$ ，我们从里面取出一个 $111$ ， $x$ 就变成了 $32\times 11+111$ ！

那就是说，我们的 $x$ 对 $11$ 取模之后是多少，就需要多少个 $111$ 来消去。但如果 $x$ 本身里面就没有这么多 $111$ ，那就不可能分成 $11$ 和 $111$ 的和了。

### 代码实现

代码非常简单，只要看 $x$ 模 $11$ 的余数乘上 $111$ 是否小于等于 $x$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		int x;
		scanf("%d",&x);
		if(x%11*111<=x)puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---

## 作者：dd_d (赞：1)

给大家介绍一种不太寻常的做法。  
## Sol  
首先很容易发现，如果一个全由 $1$ 组成的数中 $1$ 的数量大于等于 $3$，那么这个数就可以用 $111$ 和 $11$ 表示出来。  
那么问题就转化成了这样：给定一个数 $n$，询问是否能用 $11 \times x + 111 \times y$ 的形式表示出来。  
然后看一下数据范围，发现暴力肯定不能做。  
这时候我们想到了以前做到过的一道题：[link](https://www.luogu.com.cn/problem/P3951)  
从中我们知道了 大于 $11 \times 111-11-111$的都能被表示。  
小于等于这个数的情况直接暴力查询即可。  
## Code  
```cpp
//LYC_music yyds!
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int pos=1,num=0;
	char ch=getchar();
	while (!isdigit(ch))
	{
		if (ch=='-') pos=-1;
		ch=getchar();
	}
	while (isdigit(ch))
	{
		num=num*10+(int)(ch-'0');
		ch=getchar();
	}
	return pos*num;
}
void write(int x)
{
	if (x<0)
	{
		putchar('-');
		write(-x);
		return;
	}
	if (x>=10) write(x/10);
	putchar(x%10+'0');
}
void writesp(int x)
{
	write(x);
	putchar(' ');
}
void writeln(int x)
{
	write(x);
	putchar('\n');
}
int p,n,T;
signed main()
{
	T=read();
	while (T--)
	{
		n=read();
		if (n>1099)
		{
			puts("YES");
			continue;
		}
		if (n==1099)
		{
			puts("NO");
			continue;
		}
		if (n%11==0||n%111==0)
		{
			puts("YES");
			continue;
		}
		p=1;
		for (int i=1;i*111<=n;i++)
		{
			if ((n-i*111)%11==0) 
			{
				p=0;
				break;
			}
		}
		if (p==0) puts("YES");
		else puts("NO");
	}
}
 
```


---

## 作者：myEnd (赞：1)

#### [原题传送门](https://www.luogu.com.cn/problem/CF1526B)

### 解题思路：

首先讨论由多个 $1$ 组成的多位数与 $11$ 和 $111$ 的关系：

$11 = 11$

$111 = 111$

$1111 = 11 \times 101 = 11 \times 10^2 + 11$

$11111 = 11 \times 10^3 + 111$

$111111 = 11 \times 10101 = 11 \times 10^3 + 1111$

综上，容易发现对于各位数字均为 $1$ 的 $p$ 位数（$4 \le p$），都可以表示为 $11 \times 10^{p-2} + \dfrac{10^{p-1}-1}{9}$，即 $11 \times 10^{p-2}+$ 由 $p-2$ 个 $1$ 组成的多位数。而 $p-2$ 个 $1$ 又可以如此分拆，循环下去 ...... 
最终能够发现，对于所有 $4 \leq p$ 的 $p$ 位数都可以表示为：$11 \times a + 111 \times b$，又易得 $111 = 11 \times 10 + 1$，所以又可以转化为 $11 \times (a + 10b) + 1$ 于是我们只要对输入的数让其对 $11$ 取模，得到的余数 $f$ 表示其必有 $f$ 个 $111$。所以只需要判断输入的数对 $11$ 进行取模后的余数乘上 $f$ 是否小于等于原数即可。

### 参考代码：

```cpp
#include <iostream>
using namespace std;

inline void quick_cppio(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
}

int main()
{
    quick_cppio();
    
    int t;
    cin >> t;
    ++t;
    while(--t)
    {
        int x;
        cin >> x;
        int f = x % 11;
        f * 111 <= x ? cout << "YES" << endl : cout << "NO" << endl ;
    }
    return 0;
}
```

#### [AC 记录](https://www.luogu.com.cn/record/55014920)

---


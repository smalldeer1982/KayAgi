# AquaMoon and Stolen String

## 题目描述

AquaMoon had $ n $ strings of length $ m $ each. $ n $ is an odd number.

When AquaMoon was gone, Cirno tried to pair these $ n $ strings together. After making $ \frac{n-1}{2} $ pairs, she found out that there was exactly one string without the pair!

In her rage, she disrupted each pair of strings. For each pair, she selected some positions (at least $ 1 $ and at most $ m $ ) and swapped the letters in the two strings of this pair at the selected positions.

For example, if $ m = 6 $ and two strings "abcdef" and "xyzklm" are in one pair and Cirno selected positions $ 2 $ , $ 3 $ and $ 6 $ she will swap 'b' with 'y', 'c' with 'z' and 'f' with 'm'. The resulting strings will be "ayzdem" and "xbcklf".

Cirno then stole away the string without pair and shuffled all remaining strings in arbitrary order.

AquaMoon found the remaining $ n-1 $ strings in complete disarray. Also, she remembers the initial $ n $ strings. She wants to know which string was stolen, but she is not good at programming. Can you help her?

## 说明/提示

In the first test case, "aaaaa" and "bbbbb" exchanged all positions, and "ccccc" is the stolen string.

In the second test case, "aaaa" and "bbbb" exchanged two first positions, and "cccc" is the stolen string.

This is the first test in the hack format:

```
<pre class="verbatim"><br></br>3<br></br>3 5<br></br>aaaaa<br></br>bbbbb<br></br>ccccc<br></br>1 2 5 1 2 3 4 5<br></br>2 1 3<br></br>3 4<br></br>aaaa<br></br>bbbb<br></br>cccc<br></br>1 2 2 1 2<br></br>2 1 3<br></br>5 6<br></br>abcdef<br></br>uuuuuu<br></br>kekeke<br></br>ekekek<br></br>xyzklm<br></br>1 5 3 2 3 6<br></br>2 4 3 2 4 6<br></br>5 4 1 2 3<br></br>
```

## 样例 #1

### 输入

```
3
3 5
aaaaa
bbbbb
ccccc
aaaaa
bbbbb
3 4
aaaa
bbbb
cccc
aabb
bbaa
5 6
abcdef
uuuuuu
kekeke
ekekek
xyzklm
xbcklf
eueueu
ayzdem
ukukuk```

### 输出

```
ccccc
cccc
kekeke```

# 题解

## 作者：Acc_Robin (赞：9)

易知总共 $2n-1$ 个字符串中，只有被偷走的那个字符串只出现了一次。

因此我们考虑每一位，每位上有且仅有一个字符出现了奇数次，我们只要输出它即可。

我们可以通过异或（XOR）的性质：

> 异或两（偶数）次相当于没有异或

来帮助我们更方便地实现，请看：

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Acc{
    const int N = 2e5+10;
    string s[N];
    int n,m,i,j,x;
    void work(){
        cin>>n>>m,n=n*2-1;
        for(i=1;i<=n;++i)cin>>s[i];
        for(i=0;i<m;++i,putchar(x))for(x=0,j=1;j<=n;j++)x^=s[j][i];
    }
}
int main(){
    int T;for(cin>>T;T--;putchar(10))Acc::work();
}
```

---

## 作者：NXYorz (赞：3)

[题目链接](https://www.luogu.com.cn/problem/CF1546B)

~~说实话因为英语不是太好比赛时看到交互题就蒙了，赛后百度翻译才发现这题并没有任何交互过程。~~

-------

### 题目大意

有 $n$ 个长度为 $m$ 的字符串， $n$为奇数。这些字符串两两配对，最后剩下一个没有配对的字符串，将它删掉。已经配对的 $n-1$ 个字符串中的字符可以与 **与其配对的字符串** 中位于相同列的字符交换。然后随机排列这些打乱的字符串。

问你被删掉的字符串。

-----

### 分析

提供一种较为暴力的方法。

这些字符串排列起来就像一个矩阵，可以考虑 **竖着** 看这个矩阵。 发现字符串之间的字符交换并不会将该字符转移到别的 **列** 中。因此只需要把一开始的字符串中的字符按列记下出现次数，接着把打乱后的字符串中的字符减去。最后每一列一定会剩下一个字符。我们只需要枚举每一串字符串，看其所对应的字符是否是剩下的字符即可。

时间复杂度 $O(nm)$。

--------

### $\texttt{Code}$
```c++
#include<cstdio>
#include<cstring>

using namespace std;

const int N = 1e5 + 10;

int t,n,m;
int v[31],c[N][31];

void work()
{
	memset(v,0,sizeof(v));
	memset(c,0,sizeof(c));
	scanf("%d%d",&n,&m);
	char s[n + 1][m + 1] , b[n + 1][m + 1];
	for(int i = 1; i <= n; i++)
		scanf("%s",s[i]);
		
	for(int i = 1; i <= n; i++)
		for(int j = 0; j < m; j++)
			v[s[i][j] - 'a']++ , c[j][s[i][j] - 'a']++;
			
	for(int i = 1; i < n; i++)
		scanf("%s",b[i]);
		
	for(int i = 1; i < n; i++)
		for(int j = 0; j < m; j++)
			v[b[i][j] - 'a']-- , c[j][b[i][j] - 'a']--;
			
	for(int i = 1; i <= n; i++)
	{
		bool flag = 1;
		for(int j = 0; j < m; j++)
			if(!v[s[i][j] - 'a']) {flag = 0; break;}
		if(flag)
		{
			bool flag1 = 1;
			for(int j = 0; j < m; j++)
				if(!c[j][s[i][j] - 'a']) {flag1 = 0;break;}
			if(!flag1) continue;
			for(int j = 0; j < m; j++)
				printf("%c",s[i][j]) , fflush(stdout);
			printf("\n"); fflush(stdout);
			return;
		}
	}
}

int main()
{
//	freopen("aa.in","r",stdin);
	scanf("%d",&t);
	while(t--) work();
	return 0;
}
```

---

## 作者：xkcdjerry (赞：1)

考虑去掉 1 个字符串之后的 $n-1$ 个字符串和交换字符+随机重排后的 $n-1$ 个字符串。由于两种操作均不改变字符所处的位置。  
举个例子，假如原来有一个字符是某个字符串中的第三个，那么这一波操作完了之后它一定还在某个字符串（可能不是原来的字符串）中的第三个。  

那么答案就呼之欲出了：对于每一位，找到原来 $n$ 个字符串比 $n-1$ 个字符串多的一个字符填进去即可。考虑对于每一位，将这 $2n-1$ 个字符串联在一起，那么一定是被去除的那个字符出现奇数次，其它的都出现偶数次。  
由于异或在满足交换结合律的同时还满足 $a ⊕ a =0$ ，那么全部 $2n-1$ 个字符的异或一定就是唯一一个出现了奇数次的字符。  

*总结：对于 $2n-1$ 个字符串的每一位，异或这一位上所有的字符并输出结果*

代码：  
```cpp
/*
    Code by xkcdjerry
    Time: 2021-07-11
    Generated by cf-tools
*/
#include <cstdio>
#include <cstdlib>

#define int long long
/*
   实际也把原来的可以全部加起来然后减去所有交换过的
   但是这样需要把两者分开处理，会增加复杂度
   而且在某些题中还可能会爆long long
   所以异或代码量低速度快而且还不容易错
   
   代码复杂度：O(sum(nm)) < 1e5
*/
#define N 100010
#define M 100010
char s[M];
int XOR[M];
void once()
{
    int n,m;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<2*n;i++)
	{
		scanf("%s",s);
		for(int j=0;j<m;j++)
			XOR[j]^=s[j];
	}
	for(int i=0;i<m;i++)
	{
		putchar(XOR[i]);
		XOR[i]=0;
	}
	putchar('\n');
	fflush(stdout);
}
#undef int


int main()
{
    int t;
    scanf("%d",&t);
    while(t--) once();
    return 0;
}
```

---

## 作者：_QWQ__QWQ_ (赞：0)

**看了题面，一道简单的~~假~~交互题**

[题目传送门](https://www.luogu.com.cn/problem/CF1546B)，[另一个传送门](https://codeforces.com/problemset/problem/1546/B)

## 读好题目很重要

AquaMoon 有 $ n $ 个长度为 $ m $ 的字符串，其中 $ n $ 是**奇数**。
然后她选取 $ n-1 $ 个字符串，将它们复制一遍。
在 选取出的字符串中，AquaMoon 将其两两配对。对于每对字符串，AquaMoon 选取某些对应的位置，将位置上的字符调换。例如：配对的字符串是 abcdef 和 xyzklm，AquaMoon 选取的位置是 2、3、6，则调换完的两个字符串就是 ayzdem 和 xbcklf。
调换完后，所有字符串的顺序被打乱。现给出 $ n,m $ 以及打乱完后的字符串，请输出一开始没被选中的字符串。




## 简单一句话

把前 $ n $ 个字符每个位置上字母出现的次数分别保存下来，再把后 $ n-1 $ 个字符串每个位置上的字母出现次数减去，最后 $ 1\sim m $ 都剩下了一个字母，即答案。

## 源码时间：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[30][100010];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		for(int i=0;i<m;i++){
			for(int j=0;j<=26;j++) a[j][i]=0;//清空 
		}
		for(int i=1;i<=n;i++){
			string s;
			cin>>s;//输入 
			for(int j=0;j<s.size();j++){
				a[s[j]-'a'][j]++;
			}
		}
		for(int i=1;i<=n-1;i++){
			string s;
			cin>>s;//再次输入 
			for(int j=0;j<s.size();j++){
				a[s[j]-'a'][j]--;
			}
		}
		for(int i=0;i<m;i++){
			for(char j='a';j<='z';j++){//字符循环 
				if(a[j-'a'][i]){//如果标记过了 
					cout<<j;//输出当前字符 
					break;//退出，进行下一次循环 
				}
			}
		}
		cout<<endl;//记得换行！！！ 
	}
    return 0;//完结撒花！！ 
}
```

---

## 作者：Microperson (赞：0)

[题目](https://www.luogu.com.cn/problem/CF1546B)
## 腐朽的思路：
发现每个字母只对每一列产生影响，并且每一列有且仅有一个会出现奇数次，所以我们可以记录每一个字母在每一列出现的次数，直接输出奇数次数的字母即可。

## 新鲜出炉的code:
```
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#define N 100010 
using namespace std;

int n,m,T,cnt[N][30];

int main(){
	scanf("%d",&T);
	while(T--){
		memset(cnt,0,sizeof(cnt));
		scanf("%d%d",&n,&m);
		char s[n + 1][m + 1] , ss[n + 1][m + 1];
    		for(int i = 1; i <= n; i++)
        	scanf("%s",s[i]);
		for(int i=1;i<=n;i++){
			for(int j=0;j<m;j++){
				cnt[j][s[i][j]-'a']++; //记录第j列字母的个数
			}
		}
		for(int i=1;i<n;i++){
			scanf("%s",ss[i]);
		}
		for(int i=1;i<n;i++){
			for(int j=0;j<m;j++){
				cnt[j][ss[i][j]-'a']--;//减去选出的n-1行中出现的字母
			}
		}
		for(int j=0;j<m;j++){
			for(int k=0;k<=25;k++){
				if(cnt[j][k]) cout<<char(k + 'a'),fflush(stdout);//只有没选出来的那一行不会减去，也就是只出现一次
			}
		}
		printf("\n"); fflush(stdout);
	}
	return 0;
}	
```


---

## 作者：fsy_juruo (赞：0)

显然，不管 AquaMoon 怎么交换字母，对于任意的 $1 \leq i \leq m$，取出每一个字符串的第 $i$ 位字母，这总共 $n$ 个字母是不会改变的。

所以只需要统计一开始的字符串集合，与打乱后的 $n - 1$ 个字符串中，每一位上字母的出现次数。每一位上出现次数不同的那个字母就一定是缺失字符串上的对应位的字母。

```cpp
#include <bits/stdc++.h>
#define LL long long
#define ULL unsigned long long
#define LD long double
#define reg register
#define _rep(i, x, y) for(int i = x; i <= y; i++)
#define _per(i, x, y) for(int i = x; i >= y; i--)
template <typename T>
inline void read(T &x) {
	x = 0; T f = (T) 1;
	char c = getchar();
	for(; !isdigit(c); c = getchar()) {if(c == '-') f = -f;}
	for(; isdigit(c); c = getchar()) x = x * 10 + c - 48;
	x *= f;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...);
}
template <typename T>
inline void write(T x) {
	if(x < 0) {x = -x; putchar('-');}
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
template <typename T>
inline void writesp(T x, char sp = ' ') {write(x); putchar(sp);}

const int maxN = 1e5 + 10;
int t, n, m;
int buk[maxN];

int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n >> m;
		std::string s;
		_rep(i, 1, n) {
			std::cin >> s;
			_rep(j, 0, m - 1) buk[j] += s[j] - 'a';
		}
		_rep(i, 1, n - 1) {
			std::cin >> s;
			_rep(j, 0, m - 1) buk[j] -= s[j] - 'a';
		}
		_rep(i, 1, m) {
			putchar(buk[i - 1] + 'a');
			buk[i - 1] = 0; 
		}
		std::cout << std::endl;
		fflush(stdout);
	}
	return 0;
}
```

---

## 作者：LRL65 (赞：0)

思路：

只要考虑每一位即可。因为他只能换对应位上的字母，所以 $n$ 个字符串的每一位都是那么几个字母。可以这样理解:

将 $n$ 个字符串放在一起。类似这样：
```
XXXX……XXX
XXXX……XXX
……
XXXX……XXX
```
他只是将**每一列**上的字母互换位置，但是那一列上还是那几个字母。

明白了这个后，只需记录 $n$ 个字符串每一位上某个字母出现的次数，然后再减去 $n-1$ 个字符串对应位某个字母出现的次数。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,m,vis[30];
string s1[100005],s2[100005];
int main() {
	cin>>T;
	while(T--) {
		cin>>n>>m;
        for(int i=1;i<=n;i++)cin>>s1[i];
        for(int i=1;i<n;i++)cin>>s2[i];
        for(int i=0;i<m;i++) {
            for(int j=1;j<=n;j++)
                vis[s1[j][i]-'a'+1]++;
            for(int j=1;j<n;j++)
                vis[s2[j][i]-'a'+1]--;
            for(int j=1;j<=26;j++)
                if(vis[j]!=0) {
                    cout<<(char)('a'+j-1);
                    vis[j]=0;
                }
        }
        cout<<endl;
        fflush(stdout);
	}
}		
```


---


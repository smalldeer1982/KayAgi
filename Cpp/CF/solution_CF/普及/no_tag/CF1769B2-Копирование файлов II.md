# Копирование файлов II

## 题目描述

В этой версии задачи размеры копируемых файлов не превышают $ 10^{10} $ байт.

Вы копируете с одного сервера на другой $ n $ файлов размером $ a_1, a_2, \ldots, a_n $ байт. Файлы копируются последовательно в заданном порядке.

При копировании вы видите два прогресс-бара: первый показывает процент скопированных данных в текущем файле, а второй — общий процент скопированных данных по всем $ n $ файлам. Оба процента отображаются округлёнными вниз до целого числа. Значения на прогресс-барах обновляются после копирования каждого байта.

Формально, после копирования байта номер $ x $ из файла номер $ i $ первый прогресс-бар показывает $ \lfloor \frac{100 \cdot x}{a_i} \rfloor $ процентов, а второй — $ \lfloor \frac{100 \cdot (a_1 + a_2 + \ldots + a_{i - 1} + x)}{a_1 + a_2 + \ldots + a_n} \rfloor $ процентов. В самом начале копирования оба прогресс-бара показывают $ 0 $ процентов.

Найдите все такие целые числа от $ 0 $ до $ 100 $ включительно, что существует момент времени, в который оба прогресс-бара одновременно показывают это число. Выведите эти числа в порядке возрастания.

## 样例 #1

### 输入

```
1
6```

### 输出

```
0
16
33
50
66
83
100```

## 样例 #2

### 输入

```
2
100 500```

### 输出

```
0
95
96
97
98
99
100```

## 样例 #3

### 输入

```
4
10000000000 2 2 9999999998```

### 输出

```
0
50
99
100```

## 样例 #4

### 输入

```
6
170 130 400 256 30 100```

### 输出

```
0
17
43
44
84
90
99
100```

# 题解

## 作者：lzy120406 (赞：1)

## [原题](https://codeforces.com/problemset/problem/1769/B2)
我们需要找到所有整数 $p$ $(0 \leq p \leq 100)$，使得在某个时刻，两个进度条同时显示 $p$。这两个进度条分别是：
1. **当前文件进度**：显示当前文件已复制的百分比。
2. **总进度**：显示所有文件已复制的总百分比。

## 思路
初一数学题。

- **当前文件进度**：

对于第 $i$ 个文件，假设已经复制了 $x$ 字节，则当前文件进度为：

$$ current\_progress = \Large \lfloor \normalsize \frac{100 \times x}{a_i} \Large \rfloor \normalsize $$

如果当前文件进度等于 $p$，则 $x$ 必须满足：

$$ p \leq \frac{100 \times x}{a_i} < p+1 $$

即：

$$ \frac{p \times a_i}{100} \leq x < \frac{(p+1) \times a_i}{100} $$

由于 $$ x \in \mathbb{Z} $$，因此：

$$ x \in \left[ \Large \lceil \normalsize \frac{p \times a_i}{100} \Large \rceil \normalsize,\Large \lceil \normalsize \frac{(p+1) \times a_i -1}{100} \Large \rceil \normalsize \right] $$

- **总进度**：

假设已经复制了前 $i-1$ 个文件的所有字节，以及第 $i$ 个文件的 $x$ 字节，则总进度为：

$$ total\_progress = \Large \lfloor \normalsize \frac{100 \times (pre_i + x)}{sum} \Large \rfloor \normalsize $$

其中，$pre_i$ 是前 $i$ 个文件的总字节数，$sum$ 是所有文件的总字节数。

如果当前文件进度等于 $p$，则 $x$ 必须满足：

$$ p \leq \frac{100 \times (pre_i + x)}{sum} < p+1 $$

即：

$$ \frac{p \times sum}{100} \leq pre_i + x < \frac{(p+1) \times sum}{100} $$

解出 $x$ 的范围：

$$ x \in \left[ \Large \lceil \normalsize \frac{p \times sum}{100} - pre_i \Large \rceil \normalsize,\Large \lceil \normalsize \frac{(p+1) \times sum -1}{100} - pre_i \Large \rceil \normalsize \right] $$

对于每个文件 $i$，计算 $x$ 的当前文件范围和总进度范围。

如果这两个范围有交集，则说明存在一个 $x$ 使得两个进度条同时显示 $p$。

一一放进 `set` 中去重排序即可。

具体细节看代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int a[105],pre[105];
int main() {
	int n;
	cin >> n;
	for(int i=0;i<n;++i){
		cin >> a[i];
	}
	for (int i = 1; i <= n; ++i)
		pre[i] = pre[i - 1] + a[i - 1];
	ll sum = pre[n];
	set<int> res;
	for (int p = 0; p <= 100; ++p) {
		bool valid = false;
		for (int i = 0; i < n; ++i) {
			ll ai = a[i];
			ll pre_i = pre[i];
			// 当前文件
			ll x_low1 = (p * ai + 99) / 100;
			ll x_high1 = ((p + 1) * ai - 1) / 100;
			// 总进度
			ll x_low2 = (p * sum + 99) / 100 - pre_i;
			ll x_high2 = ((p + 1) * sum - 1) / 100 - pre_i;
			// 交集
			ll x_low = max({x_low1, x_low2, 0LL});
			ll x_high = min({x_high1, x_high2, ai});
			if (x_low <= x_high) {
				valid = true;
				break;
			}
		}
		if (valid) res.insert(p);
	}
	for (int x : res) cout << x << ' ';
	cout << endl;
	return 0;
}
```
时间复杂度 $ \mathcal{O}(n \log n) $，可以通过本题。

---

## 作者：CrazyEagle (赞：1)

题意：给定长度为 $n$ 的序列 $a$，求有哪些 $y \in [0,100]$，满足 $\exists i\in[1,n],x\in[0,a_i]$，使得：
$$
\lfloor \frac{100x}{a_i}\rfloor=
\lfloor\frac{100(x+\sum\limits_{j=1}\limits^{i-1}a_j)}{\sum\limits_{j=1}\limits^{n}a_j}\rfloor=y
$$

由于 $a_i\le10^{10}$，暴力枚举肯定不行。可以考虑对每个 $a_i$，枚举 $y$ 并判断是否可行。

我们需要求得满足 $\lfloor\frac{100x}{a_i}\rfloor=y$ 的 $x$ 的范围。可以知道：
$$
  y\times a_i\le 100x < a_i\times(y+1)\\
  \frac{y\times a_i}{100}\le x<\frac{a_i\times(y+1)}{100}
$$
由于 $x \in  \mathbb{Z}$，所以：
$$
  \lceil\frac{y\times a_i}{100}\rceil
  \le x \le
  \lfloor\frac{a_i\times(y+1)-1}{100}\rfloor
$$
求出答案 $l,r$。

对于 $\lfloor\frac{100(x+\sum\limits_{j=1}\limits^{i-1}a_j)}{\sum\limits_{j=1}\limits^{n}a_j}\rfloor$，也可以用同样的方式求得（这里记 $pre=\sum\limits_{j=1}\limits^{i-1}a_j,tot=\sum\limits_{j=1}\limits^{n}a_j$）:
$$
  \lceil \frac{y\times tot}{100}\rceil
  \le x+pre\le
  \lfloor\frac{tot\times(y+1)-1}{100}\rfloor\\
  \lceil \frac{y\times tot}{100}\rceil-pre
  \le x\le
  \lfloor\frac{tot\times(y+1)-1}{100}\rfloor-pre
$$
求出答案 $ll,rr$。

然后判断一下 $l,r,ll,rr$ 是否合法且 $[l,r],[ll,rr]$ 是否相交，如果相交，那么 $y$ 是可以被取到的。

代码中的第二层循环的 $j$ 对应上文枚举的 $y$。


```cpp
#include<iostream>
#define int long long
using namespace std;
int a[105];
bool vis[105];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n;
	cin>>n;
	int tot=0;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		tot+=a[i];
	}
	int pre=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<=100;++j)
		{
			int l=a[i]*j/100+bool(a[i]*j%100),r=(a[i]*(j+1)-1)/100;
			if(l>r)continue;
			int ll=tot*j/100+bool(tot*j%100)-pre,rr=(tot*(j+1)-1)/100-pre;
			if(ll>rr)continue;
			if(ll>a[i])continue;
			if(rr<0)continue; 
			if(ll<=r&&rr>=l)
			{
				vis[j]=true;
//				cout<<j<<' '<<ll<<' '<<rr<<' '<<tot<<' '<<l<<' '<<r<<' '<<a[i]<<'\n';
			}
		}
		pre+=a[i];
	}
	for(int i=0;i<=100;++i)
		if(vis[i])
			cout<<i<<'\n';
}
```

---


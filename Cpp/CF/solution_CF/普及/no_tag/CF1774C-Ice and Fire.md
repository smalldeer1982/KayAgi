# Ice and Fire

## 题目描述

有$n$个人，第$i$个人的温度为$i$

环境类型为$0$或$1$.若环境为$0$, 则温度低的人胜利，若环境为$1$, 则温度高的人胜利，$n-1$个环境类型组成一个长为$n-1$的二进制串$s$

若$x$个人参与游戏，则共有$x-1$场战斗，环境类型即为$s$的前$x-1$个元素.在有不少于$2$个人时，任选$2$个人进行战斗，其中第$i$场战斗的环境类型为$s_i$.

对于任意一个从$2$到$n$的$x$，如果所有温度不超过$x$的人都参与比赛，有多少人有机会获胜（活到最后）

## 样例 #1

### 输入

```
2
4
001
4
101```

### 输出

```
1 1 3 
1 2 3```

# 题解

## 作者：大宝和小宝 (赞：6)

* 首先当 $s$ 的最后一位为 $0$ 时，那么此时能力值等于 $1$ 的人一定有获胜机会的。

* 同理当 $s$ 的最后一位为 $1$ 时，那么此时能力值等于 $max$ 的值是一定有获胜机会的。

* 当 $s$ 的后缀为 $00$ 时，与上一次的状态相比，多了一个 $0$，多了一个最大值。而最大值只能用 $0$ 来淘汰，并且最后一位为 $0$，最大值一定不可能获胜。所以结果的值相比与上一个状态没有改变。

* 当 $s$ 的后缀为 $11$ 时，同理可得没有改变。

* 当 $s$ 得后缀为 $01$ 时，因为后缀为 $0$ 时 $x$ 等于 $1$ 一定会获胜，所以 $s$ 得前 $i-1$ 位只需要让 $1$ 获胜，然后我们可以知道除了 $1$ 以外得所有人都可能获胜。

* 后缀位 $10$ 时同理。

---

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int t;
    cin >> t;

    while (t--)
    {
        int n;
        cin >> n;
        string s;
        cin >> s;
        int len = s.length();
        int sum = 1;
        int cnt = 2;
        cout << sum << ' ';
        for (int i = 1; i < len; i++)
        {
            cnt++;
            if (s[i] == s[i - 1]) 
            {
                cout << sum << ' ';
            }
            else
            {
                sum = cnt - 1;
                cout << sum << ' ';
            }
        }
        cout << '\n';
    }

    return 0;
}

```


---

## 作者：Flanksy (赞：3)

### 思维

------------

使用 $S$ 表示当前前缀，令 $n=|S|+1$。

首先可以发现 $S$ 以 $0$ 结尾时 $n$ 不可能赢，以 $1$ 结尾时 $1$ 不可能赢。考虑极端情况：

- 全 $0$ 串，胜者是 $1$。
- 全 $1$ 串，胜者是 $n$。

很显然在以上两种情况中 $1,n$ 分别是无敌的。

结论：**如果 $S$ 的剩余部分是一个全 $0$ 串或全 $1$ 串，答案可以立即确定，因为有一个数是无敌的。**

现在问题等价于对每个前缀询问有多少个数能无敌，考虑每个前缀的极长相同后缀。它的性质较好：如果该后缀由 $1$ 组成，那它前面的字符要么为空，要么为 $0$，是确定的；该后缀由 $0$ 组成的情况同理。

当极长相同后缀由 $m$ 个 $1$ 组成时：

- 所有满足 $i \leq m$ 的 $i$ 都无法获胜，因为极长相同后缀对应了 $m+1$ 个数字，而无敌数字是其中最大的数，其必定大于 $m$。
- 考虑每个满足 $j>m$ 的 $j$，先让所有满足 $k>m$ 且 $k \neq j$ 的 $k$ 相互厮杀直到只剩下一个满足条件的 $k$，此时还剩 $m+2$ 个数字，$S$ 剩余 $m+1$ 位。**根据极长相同后缀的性质**可知接下来要淘汰一个较大的数字，由 $i \leq m <k$ 可知随便找一个 $i$ 就可以击败这个 $k$，此后 $j$ 成为无敌数字。

所以所有满足 $j>m$ 的 $j$ 都可能获胜，极长相同后缀由 $0$ 组成的情况同理。

对每个前缀统计其极长相同后缀长度 $len$，该前缀的答案为 $n-len$。

---

## 作者：tzyt (赞：3)

题目链接[（CF](https://codeforces.com/problemset/problem/1774/C)，[洛谷）](https://www.luogu.com.cn/problem/CF1774C) | 强烈推荐[博客](https://ttzytt.com/2022/12/CF1774C/)中观看。

吐槽一下，官方题解写的挺难看懂的，看了好久还是挺迷糊的（其实也是我太菜了）。搞懂之后感觉这题挺妙的，来写下题解。

## 思路

我们首先需要有一个观察，就是对于 $s$ 串，最后一个连续字串不会增加可能的获胜人数。比如 $s = \texttt{0011}$ 时，后面结尾的 $\texttt{11}$ 就不会增加可能的获胜人数。

为啥呢，设我们设经过任意次数对战后，玩家可能组合的集合为 $t$ 那么对于任意的 $x \in t$，连续在环境 $1$ 中对战任意次数后，最终的赢家一定是 $x$ 中温度最高的（因为每个剩下的玩家都会需要连续在环境 $1$ 中对战，唯一能胜出所有对战的玩家一定是最大的）。同理，$t$ 中的玩家连续在环境 $0$ 中对战任意次数后，最终的赢家一定是 $x$ 中温度最低的。

例如，$s = \texttt{111}$ 时，最后胜出的一定是 $4$ 号玩家。

这样一来，如果结尾段是 $1$（$0$ 结尾同理，后面为了方便先用 $1$ 的例子了），我们只需要算出前面的部分最多能构造出多少种最大值（玩家温度）不同的玩家组合，就能知道当前长度的 $s$ 的答案了。

现在考虑如何构造出最多的最大值不同的玩家组合。如果玩家数量为 $n$，那么没有经过任何对战时，最大值就是 $n$。想要让最大值不同，只能删除当前的最大值。

### 特殊情况

刚刚的描述可能比较抽象，考虑 $s = \texttt{0011}$ 这个例子就能较好的理解了。

对于第一个 $0$，除了玩家组合中温度最低的不能删掉（这个不管怎样都能赢），其他的都能删掉（让温度最低的玩家和其他任意玩家对战），共有如下几种情况：


$$
1 : \texttt{1234} \cancel{\texttt{5}} \\
2 : \texttt{123} \cancel{\texttt{4}} \texttt{5} \\
3 : \texttt{12} \cancel{\texttt{3}} \texttt{45} \\
4 : \texttt{1} \cancel{\texttt{2}} \texttt{345} \\
$$

观察发现，只有第一种情况改变了最大值（~~为啥呢？因为他删掉了最大值~~）。其他的情况中，必须要连续的删除结尾的一段数字，才能改变最大值。

这时候第二个 $0$ 就起到作用了。对于第二种情况，其可以把 $5$ 删掉，使得玩家组合的最大值变为 $3$。我们按照这个规律可以进一步推广出这个结论：设结尾段前面连续段的长度为 $l$，能产生的最大值不同的玩家组合就为 $l + 1$，具体来说，可能的最大值范围是 $[n - l, n]$。（这里 $+1$ 是因为可以选择不改变最初的最大值）。

现在为止，我们已经能求出 $s$ 只有两个连续段时的答案了。即 $n - k$，其中 $k = |s| - l$，表示结尾段的长度。

### 推广

这个时候我们把例子换成 $s = \texttt{1011}$，看看例子是否还成立（$s$ 不止一段）。同样，可以列出第一次对战后的可能玩家组合。因为第一个环境是 $1$，所以只能删除除了最大值以外的其他玩家：

$$
1 : \texttt{123} \cancel{\texttt{4}} \texttt{5} \\
2 : \texttt{12} \cancel{\texttt{3}} \texttt{45} \\
3 : \texttt{1} \cancel{\texttt{2}} \texttt{345} \\
1 : \cancel{\texttt{1}} \texttt{2345}  \\
$$

虽然这些情况中，没有任何一种改变了玩家组合的最大值，但是我们只要在接下来的 $0$ 环境中再对战一次，删除掉 $5$，就产生了 $2$ 种新的最大值。对于第一种情况，最大值变为了 $3$，第二种变为了 $2$。一共也是 $n - k$ 种答案。

那如果段数再多一点呢？比如 $s = \texttt{01011}$。这个结论还是成立的。我们可以把 $\texttt{010}$ 看作一组环境，其中 $0$ 可以删除 $[2, n]$ 范围内的任何玩家，$1$ 则为 $[1, n - 1]$ 中的任何玩家。把这两种环境组合起来就可以从 $[1, n]$ 种任意挑选 $3$ 个删除，构造出 $4$ 种不同的最大值（取决于你删除前多少个温度最大的玩家）。


## 代码和实现

通过前面的例子我们已经分析出了，解决问题只需要知道 $s$ 的 $[1, i]$ 子串中，最后一个连续段的长度。不过对于每个 $i$ 都扫一遍太慢了，需要采用类似动态规划的东西，具体我在代码注释里有解释：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    int t;
    cin >> t;
    while(t--){
        int n;
        string s;
        cin >> n >> s;
        int cur0len = 0; // 最后一个连续段如果是 0 的话 cur0len 表示其长度，
                         // 如果不是的话 cur0len 就是 0 
        int cur1len = 0; // 和 1 相同
        int curn = 2;    // 最开始是两个玩家
        for (char ch : s){
            int x = ch - '0';
            if (x == 0){
                cur0len++;   // 当前是 0 的话 0 结尾的连续段会比原来更长
                cur1len = 0; // s 的最后一个不是 1 了
            } else {
                cur1len++;
                cur0len = 0;
            }
            cout << curn - (x ? cur1len : cur0len) << " ";
            // 前文中的 n - k
            curn++;
        }
        cout << '\n';
    }
}
```

---

## 作者：Little09 (赞：2)

对于一个长度为 $n-1$ 的 $01$ 串 $s$，令 $l$ 表示 $s$ 在末尾处的极长同色连续段长度，可以说明有 $l$ 个人是无法获胜的，另外 $n-l$ 个人可以获胜。

接下来证明一下。首先 $l=n-1$ 是平凡的。考虑 $l\neq n-1$ 的情况。不妨设 $s_{n-1}=1$，那么 $s_{n-1-l}=0$。考虑：

1. 玩家 $1$ 到 $l$ 都无法获胜。由于最后 $l$ 轮的环境都是 $1$，在进入到最后 $l$ 轮时一定有一个人的编号大于 $l$，最后 $l$ 轮胜者就是编号最大的人，因此不可能是前 $l$ 个人。

2. 玩家 $l+1$ 到 $n$ 都可以获胜。考虑构造。假设要让玩家 $i$ 获胜，考虑在前 $n-l-2$ 轮中让 $[l+1,n]$ 中除了 $i$ 以外的玩家相互残杀，最后肯定只剩一个人，设他是 $x$。第 $n-l-1$ 轮就让 $1$ 去打 $x$，肯定 $1$ 赢，接下来只剩 $[1,l]$ 和 $i$ 了，那么随便怎么都是 $i$ 赢了。

把结论代进去，维护一下第 $i$ 个点结尾的最长同色连续段，这题就做完了。代码想必很好写。

------------

闲话

1. 我给这道题的时候难度给的是 C，结果有一天被 anton 改到 D 去了。最后验题的时候有的验题人过了 D 过不了 C，于是又把 C,D swap 回来了。

2. 比赛前一天我去打 Edu，一看 [D](https://codeforces.com/contest/1767/problem/D)：我去，怎么和明天的 C 这么像啊。结果是我做这个 D 还做了 17min，做法不大一样，松了一口气。赛时很多人的提问都是把这道题理解成了那个 Edu D，然后看不懂样例解释。

---

## 作者：_QWQ__QWQ_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF1774C)

假设最后一场的环境为 $ 1 $，即温度大的人赢，那么温度为 $ 1 $ 的人即使活到了最后一场也必输。

同理，如果最后 $ k $ 场的环境都为 $ 1 $，那么有 $ k(1\sim k) $ 个人一定没机会赢，另外的 $ x-k $ 名选手都有机会赢，因为只有温度大于等于 $ k+1 $  的人才可能连续战胜温度为 $ 1\sim k $ 的人活到最后。

那么如何保证 $ k+1\sim x $ 名选手都有机会活到最后 $ k $ 场呢？假设要使选手 $ i(k+1\le i\le x) $ 活到最后 $ k $ 场，只需要先让剩下的在 $ k+1\sim x $ 中的选手互相对战，由于第 $ k-1 $ 场环境一定为 $ 0 $，那么让剩下的另一名选手 $ j $ 和 $ 1\sim k $ 中的选手打，被淘汰，那么 $ i $ 就活到了最后 $ k $ 场。

反之如果最后 $ k $ 场的环境都为 $ 0 $ 也同样可以证明有机会赢的人数为 $ x-k $。

## AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
string s;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>s;
        cout<<1<<' ';
        for(int i=1,k=1;i<s.size();i++){//k表示最长相同后缀的长度
            if(s[i]==s[i-1]){
            	k++;	
			}
            else{
            	k=1;	
			}
            cout<<i+2-k<<' ';//第1~i+2名选手参赛
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：Zimo_666 (赞：0)

## C. Ice and Fire

。

### Statement

有 $n$ 个人，第 $i$ 个人的温度为 $i$。

环境类型为 $0$ 或 $1$。若环境为 $0$，则温度低的人胜利，若环境 为$1$，则温度高的人胜利，$n-1$ 个环境类型组成一个长为 $n-1$ 的二进制串 $s$。

若 $x$ 个人参与游戏，则共有 $x-1$ 场战斗，环境类型即为 $s$ 的前 $x-1$ 个元素。在有不少于 $2$ 个人时，任选 $2$ 个人进行战斗，其中第 $i$ 场战斗的环境类型为 $s_i$。

对于任意一个从 $2$ 到 $n$ 的 $x$，如果所有温度不超过 $x$ 的人都参与比赛，有多少人有机会获胜（活到最后）。

### Solution

首先，如果它是末尾加了相同的 `01` 字符，答案是不会被改变的。

那么如果第一次连续被打破，那么答案种类就可能是很多，也就是说，可以通过最后一次转折，打败原来的最大或最小，并且这个转折是可以随意发生的。

设 $s$ 为末尾最长连续段长度。

因而，最后答案就是 $n-1-s$。

[Code](https://codeforces.com/contest/1774/submission/229361746)

---


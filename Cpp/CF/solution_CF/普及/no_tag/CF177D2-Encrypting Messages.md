# Encrypting Messages

## 题目描述

给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$ 以及一个模数 $c$ （保证 $m \le n$ ），你需要对它们进行 $n-m+1$ 次操作。

对于第 $i$ 次操作，将 $a_i \sim a_{i+m-1}$ 对应的加上 $b_1 \sim b_m$ （即 $a_i=a_i+b_1,a_{i+1}=a_{i+1}+b_2$，以此类推 。）

最后，你需要输出操作完成后 $a$ 序列对于 $c$ 取模的结果。

## 样例 #1

### 输入

```
4 3 2
1 1 1 1
1 1 1
```

### 输出

```
0 1 1 0
```

## 样例 #2

### 输入

```
3 1 5
1 2 3
4
```

### 输出

```
0 1 2
```

# 题解

## 作者：wkjwkj (赞：4)

由于我的翻译还未过审，我在题解中先挂一下。

## 题意简述

给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$ 以及一个模数 $c$ （保证 $m \le n$ ），你需要对它们进行 $n-m+1$ 次操作。

对于第 $i$ 次操作，将 $a_i \sim a_{i+m-1}$ 对应的加上 $b_1 \sim b_m$ （即 $a_i=a_i+b_1,a_{i+1}=a_{i+1}+b_2$，以此类推 。）

最后，你需要输出操作完成后 $a$ 序列对于 $c$ 取模的结果。
## 输入格式
第一行输入 $n,m,c$

下面两行分别是序列 $a$ 与 $b$。
## 输出格式
输出一行 $n$ 个整数，表示操作完成后 $a$ 序列对于 $c$ 取模的结果。

$\mathtt{Translated\ by} $ @[$\mathtt{wkjwkj}$](user/240405)



对于这道题目，我们先可以假设 $n$ 很大，而 $m$ 很小，比如假设 $m=3$ 。则此时共进行了 $n-2$ 次操作。

现在我们来分析一下普遍规律。

对于数列 $a_1,a_2,a_3,a_4,a_5 ...a_{n-2},a_{n-1},a_n$ 不难发现 $a_1$ 只被加了 $b_1$ ，$a_2$ 只被加了 $b_1 \sim b_2$，$a_3 \sim a_{n-2}$ 都被加了 $b_1 \sim b_3$ ， $a_{n-1}$ 只被加了 $b_2 \sim b_3$，$a_n$ 只被加了 $b_3$ 。我们可以定义一个变量 $sum$ 代表每个数字被加上的值，故这个规律可以用如下的代码来表示：

```cpp
if(i>=n-m+1)sum-=b[i-n+m-1];
if(i<=m)sum+=b[i];
```

但是，上面分析的是当 $n$ 远比 $m$ 大的情况，如果在更普遍的情况下，比如 $n$ 不一定那么大，甚至 $n=m$ ，那么上面的规律还成立吗？

显然，这个规律是成立的，大家可以通过样例模拟一下，会发现得出的结果是正确的。

因为在一定范围内 $i$ 可能同时满足上面两个条件，故两条语句都会执行。

而由于加入 $sum$ 的元素是从前至后加的，而从 $sum$ 中被减去的元素也是从前之后减的，故两条语句并不会矛盾，**因为从 $sum$ 中减去的元素一定早已被加入 $sum$ 中**。

所以我们上面的做法是正确的。

下面附上代码（十分简短）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],b[100005];//10
int n,m,c;
int main()
{
	scanf("%d%d%d",&n,&m,&c);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)scanf("%d",&b[i]);
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		if(i>=n-m+1)sum-=b[i-n+m-1];
		if(i<=m)sum+=b[i];
		a[i]=(a[i]+sum%c)%c;
		//printf("%d\n",sum);
	}
	for(int i=1;i<=n;i++)printf("%d ",a[i]);
	return 0;
}
```



---

## 作者：zhuweiqi (赞：2)

对于 $1\leq m\leq n\leq 10^3$ 的数据，我们可以使用双重循环模拟通过。

对于 $1\leq m\leq n\leq 10^5$ 的数据，很显然我们需要使用线性（即一重循环）的时间复杂度通过，这里介绍一种差分的方法：

对于每个 $b_i$，究竟有哪些 $a_j$ 需要加上它呢？我们考虑 $j$ 的极值：$j$ 的最小值即为 $i$，因为第一次操作就是对每个 $k$（$1\leq k\leq m$），将 $a_k$ 加上 $b_k$；$j$ 的最大值即为 $n-(m-i)$，因为最后一次操作就是对每个 $k$（$1\leq k\leq m$），将 $a_{n-(m-k)}$ 加上 $b_k$，我们只需要把 $a_i$ 到 $a_{n-(m-i)}$ 的值都加上 $b_i$ 就可以了。很显然，对于这种区间修改，但只有最后一次查询的问题，我们可以使用差分解决。参考代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100002];
long long sum[100002];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m,c,x;
	cin>>n>>m>>c;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		cin>>x;
		sum[i]+=x;
		sum[n-(m-i)+1]-=x;
	}
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+sum[i];
		cout<<(a[i]+sum[i])%c<<" ";
	}
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 解法

我们其实很容易得到对于数列 $a$ 中下标为 $i$ 的数应该加的那些数在 $b$ 中的下标：从 $\max(p-n+m,1)$ 到 $\min(p,m)$。要推的话也很简单。

对于最后一个位置，如果 $i$ 大于等于 $m$，那么在第 $i-m+1$ 次操作时会加上最后一个数 $b_m$，否则最后也只能在第 $1$ 次操作时加上 $b_p$。第一个位置以此类推，留给读者自行思考。

这样，每一次 $a_i$ 都先加上 $\sum_{\max(p-n+m,1)\le j\le\min(p,m)}b_j$，然后取一次模输出就行了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, c, a[100005], b[100005], qh[100005];
inline int gtfs(int p) {
	if (p + m - 1 <= n) return 1;
	return p - n + m;
}
inline int gtlt(int p) {
	if (p >= m) return m;
	return p;
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m >> c;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	for (int i = 1; i <= m; ++i) cin >> b[i], qh[i] = qh[i - 1] + b[i];
	for (int i = 1; i <= n; ++i)
		a[i] += qh[gtlt(i)] - qh[gtfs(i) - 1],
		cout << a[i] % c << " ";
	return 0;
}
```

---

## 作者：shenbairui (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/CF177D2)

### 题目大意

给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$ 以及一个模数 $c$（保证 $m \le n$），你需要对它们进行 $n-m+1$ 次操作。

对于第 $i$ 次操作，将 $a_i \sim a_{i+m-1}$ 对应的加上 $b_1 \sim b_m$（即 $a_i=a_i+b_1,a_{i+1}=a_{i+1}+b_2$，以此类推)。

最后，你需要输出操作完成后 $a$ 序列对于 $c$ 取模的结果。

### 题目分析

观察题目首先普通的暴力是过不了的，这时候我们的差分就要闪亮登场了，不懂差分的人戳这里[差分](https://blog.csdn.net/weixin_73888239/article/details/128384249)，注意差分的适用前提是有一段区间重复地加上某一个值，这时候才能用差分。

我们还需要知道一个芝士，众所周知差分的前缀和是原数组。

然后我们知道差分需要在开始处和结尾处分别打上一个标记，那么我们去考虑这个结尾处，然后我们知道需要加上 $b_1$ 的区间的结尾处是 $n-m+1+1$，那么再往后，都会继续再加一，那么我们就可以把这个结尾处简化成 $n-(m-i)+1$，然后用前缀和还原原数组即可。
### 上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],sum[100005];
int main(){
    int n,m,mod;
    cin>>n>>m>>mod;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1,x;i<=m;i++){
        cin>>x;
        sum[i]+=x;
        sum[n-(m-i)+1]-=x;
    }
    for(int i=1;i<=n;i++){
        sum[i]+=sum[i-1];
        cout<<(sum[i]+a[i])%mod<<" ";
    }
    return 0;                                
}
```
下期见！拜拜！

---

## 作者：L_shadow (赞：0)

## 思路：
这题很显然，线性的时间复杂度使用前缀和是最合适的。

先讲一下前缀和做法：由于要加几次，所以使用前缀和是最合适的。

对于序列 $a$ 的前 $m$ 个，它们只能加 $b$ 序列前 $i$ 个，所以直接加上 $sum_i$。

对于序列 $a$ 的 $m$ 到 $n-m+1$ 个，它们都会加上 $m$ 次，直接加上 $sum_m$。

对于序列 $a$ 的 $n-m+1$ 到 $n$ 个，它们会加上 $b$ 序列后 $n-i$ 个，加上 $sum_m-sum_{n-i-1}$。

这里讲一下前缀和的稍微优化后的版本。

对于前 $m$ 个，$sum$ 加上 $b_i$。

对于 $m$ 到 $n-m+1$ 个，不需要修改 $sum$。

对于 $n-m+1$ 到 $n$ 个，$sum$ 减去 $b_{i+m-n-1}$。

修改后的 $sum$ 是它需要加上的偏移量。

## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,c,a[N],b[N];
int main(){
	cin>>n>>m>>c;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	long long sum=0;
	for(int i=1;i<=n;i++){
		if(i>=n-m+1)sum=sum-b[i+m-n-1];
		if(i<=m) sum+=b[i];
		a[i]+=sum;
		a[i]%=c;
		printf("%d ",a[i]);
	}
}
```


---

## 作者：Lyw_and_Segment_Tree (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/CF177D2)  
## 题意简述
> 给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$ 以及一个模数 $c$ （保证 $m \le n$ ），你需要对它们进行 $n-m+1$ 次操作。  
> 对于第 $i$ 次操作，将 $a_i \sim a_{i+m-1}$ 对应的加上 $b_1 \sim b_m$ （即 $a_i=a_i+b_1,a_{i+1}=a_{i+1}+b_2$，以此类推 。）  
> 最后，你需要输出操作完成后 $a$ 序列对于 $c$ 取模的结果。

## 开始解题！
首先我们观察数据范围知道，单纯的暴力肯定是不能拿满的。  
那么此时，我们观察一个性质，也就是在这些操作中，会有一段区间重复地加上某一个值，那么此时，我们就可以使用差分来解决这个问题。  
然后我们知道差分需要在开始处和结尾处分别打上一个标记，那么我们去考虑这个结尾处，然后我们知道需要加上 $b_1$ 的区间的结尾处是 $n-m+1+1$，那么再往后，都会继续再加一，那么我们就可以把这个结尾处简化成 $n-(m-i)+1$，然后用前缀和还原相对的偏移量即可。代码如下：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],sum[100005];
int main(){
    int n,m,c;
    cin>>n>>m>>c;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1,x;i<=m;i++){
        cin>>x;
        sum[i]+=x;
        sum[n-(m-i)+1]-=x;
    }
    for(int i=1;i<=n;i++){
        sum[i]+=sum[i-1];
        cout<<(sum[i]+a[i])%c<<" ";
    }
}
```

---

## 作者：__int127 (赞：0)

## CF177D2 Encrypting Messages 题解

#### [题目传送门](https://www.luogu.com.cn/problem/CF177D2)

#### [双倍经验](https://www.luogu.com.cn/problem/CF177D1)

### 题目大意

给定一个长度为 $n$ 的序列 $a$ 和长度为 $m$ 的序列 $b$ 和一个模数 $c$，需要对它进行 $n-m+1$ 次操作。

对于第 $i$ 次操作，需要将 $a_i\sim a_{i+m-1}$ 对应加上 $b_1\sim b_m$。

输出操作后的序列 $a$（每一个数据对 $c$ 取模）。

### 样例解释

#### 样例 \#1 解释

第一个样例，$n=4,m=3,c=2$，共需要 $2$ 次操作，序列 $a$ 和 $b$ 分别为 `1 1 1 1` 和 `1 1 1`。

第一次操作，$a$ 为 `2 2 2 1`。

第二次操作，$a$ 为 `2 3 3 2`。

最终 $a$ 数组为 `2 3 3 2`，每个元素对 $c$ 取模后结果为 `0 1 1 0`。

#### 样例 \#2 解释

第一个样例，$n=3,m=1,c=5$，共需要 $3$ 次操作，序列 $a$ 和 $b$ 分别为 `1 2 3` 和 `4`。

第一次操作，$a$ 为 `5 2 3`。

第二次操作，$a$ 为 `5 6 3`。

第二次操作，$a$ 为 `5 6 7`。

最终 $a$ 数组为 `5 6 7`，每个元素对 $c$ 取模后结果为 `0 1 2`。

### 思路

暴力算法没什么可讲的，直接根据题意模拟即可，但是这在本题根本过不去，时间复杂度太高了，这里我们讲一个思路：前缀和。

对于每次相加，我们可以看成是一层一层的，这样就可以得到一张表。

举个例子，$n=7,m=5,c=3,a={\{1,2,3,4,5,6,7\}},b={\{5,4,3,2,1\}}$，得到的表为：

| **第一次相加** | $5$ | $4$ | $3$ | $2$ |$1$ | $0$ | $0$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **第二次相加** | $0$ | $5$ | $4$ | $3$ | $2$ | $1$ | $0$ |
| **第三次相加** | $0$ | $0$ | $5$ | $4$ | $3$ | $2$ | $1$ |

---

| **每项与 $a$ 相加后总和** | $6$ | $11$ | $15$ | $13$ | $11$ | $9$ | $8$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **与 $c$ 取模后的值** | $0$ | $2$ | $0$ | $1$ | $2$ | $0$ | $1$ |


这时定义一个前缀和数组 $sum$，当然，不能把表整个存入 $sum$，不然不仅不好计算，而且会 MLE，我们可以把这些相加的数的和存入 $sum$（不与 $a$ 的数相加，而且是纵向相加），最后输出 $(sum_i+a_i)\bmod c$ 就可以了，但是如何计算相加的数的和呢？

要想知道相加的数的和，首先需要知道纵向相加的数的个数，不难发现第一列相加的个数永远是 $1$，后面 $m-1$ 列只要满足 $i<n-m+1$ 且 $i<m$，第 $i+1$ 列的个数等于第 $i$ 列的个数加 $1$，如果 $i = n-m+1$ 或 $i=m$，第 $i+1$ 列的个数等于第 $i$ 列的个数。之后的 $m\sim n$ 列，与前面是对称的。

可是知道了个数，怎样计算加和呢？根据表格我们可以知道第一列的加和为 $b_1$，第二列的加和为 $b_1+b_2$（$m\neq1$），以此类推，直到 $i=n-m$（特殊情况 $i=m+1$），此时加和为表格第 $i$ 列中从上至下最后一个非 $0$ 的数加 $b$ 中一个新的数。

这时知道了加和，最后与 $a_i$ 相加就好了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[100005], b[100005], c;
long long sum[100005][5];
int main(){
	cin >> n >> m >> c;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		sum[i][2] += a[i];
	}
	for (int i = 1; i <= m; i++){
		cin >> b[i];
	}
	sum[1][1] += b[1];
	cout << (sum[1][1] + sum[1][2]) % c << " ";
	int xb = 1, j = 1;
	if (m == 1){
		for (int i = 2; i <= n; i++){
			cout << (a[i] + b[1]) % c << " ";
		}
		return 0;
	}
	for (int i = 2, gs = 2; i <= m; i++){
		if (gs <= n - m + 1){
			if (gs == n - m + 1){
				xb = i - 1;
			}
			if (gs <= m){
				if (gs == m){
					xb = i - 1;
				}
				sum[i][1] += sum[i - 1][1] + b[i];
				gs++;
			} else {
				sum[i][1] = sum[i - 1][1];
			}
		} else {
			sum[i][1] += sum[i - 1][1] - b[j] + b[j + (n - m + 1)];
			j++;
		}
		cout << (sum[i][1] + sum[i][2]) % c << " ";
	}
	for (int i = m + 1; i <= n; i++){
		if (i < n - xb + 1){
			sum[i][1] += sum[i - 1][1];
		} else if (i == n - xb + 1){
			sum[i][1] += sum[i - 1][1] - b[j];
			j++;
		} else {
			sum[i][1] += sum[i - 1][1] - b[j];
			j++;
		}
		cout << (sum[i][1] + sum[i][2]) % c << " ";
	}
	return 0;
}
```

### 最后
本篇题解过长，感谢认真观看，希望大家能看懂、有思路。

---


# Ian and Array Sorting

## 题目描述

为了感谢 $\textrm{lan}$，$\textrm{Mary}$ 赠送了 $\textrm{lan}$ 一个长度为 $n$ 的序列。为了让他自己看起来聪明，他想要让序列按非递减排序。他可以执行以下操作若干次：

+ 选择数组中的两个元素 $a_i,a_{i+1}$ ( $1\le i<n$ )。

+ 同时将它们减去 $1$，或者都加上 $1$。

（注意：操作后 $a_i,a_{i+1}$ 可以是负数或 $0$）

作为一个聪明人，你会注意到，有些序列 $\textrm{lan}$ 无法让其非递减排序。因此，你决定编写一个程序来确定是否可以使数组按非递减顺序排列。

## 样例 #1

### 输入

```
5
3
1 3 2
2
2 1
4
1 3 5 7
4
2 1 4 3
5
5 4 3 2 1```

### 输出

```
YES
NO
YES
NO
YES```

# 题解

## 作者：inc1ude_c (赞：11)

尝试将原问题的目标 $a_1\le a_2\le\cdots\le a_n$ 转换为 $a_1=a_2=\cdots=a_{n-1}\le a_n$。

为什么可以有这样的转换？如果这个序列最终满足了单调不下降，那么我们一定可以通过同时减小的操作来让序列满足 $a_1=a_2=\cdots=a_{n-1}\le a_n$。

从 $2$ 到 $n-1$ 枚举 $i$，如果 $a_i\ne a_{i-1}$，那么计算它们的差，再通过同时改变 $(a_i,a_{i+1})$ 来让 $a_i=a_{i-1}$，注意这个操作会改变到 $a_{i+1}$。

枚举完后，我们只需要看 $a_{n-1}\le a_n$ 成不成立即可。

如果 $n$ 为奇数，则 $n-1$ 为偶数，就算 $a_{n-1}\le a_n$ 不成立，我们也可以通过同时减小 $(a_1,a_2),(a_3,a_4)\cdots (a_{n-2},a_{n-1})$ 来让 $a_{n-1}\le a_n$，所以说 $n$ 为奇数时一定有解。

如果 $n$ 为偶数，那么我们就不能通过上述操作来让 $a_{n-1}\le a_n$，所以当 $a_{n-1}\le a_n$ 时有解，否则无解。

[Code](https://codeforces.com/contest/1815/submission/202760561)

---

## 作者：G2_NIKO (赞：5)

~~本蒟蒻的第一篇题解从这里开开始！~~



# 步入主题

大概题意是：有 $n$ 个数，有无限的次数操作该 $n$ 个数（就叫他 $a$ 数组吧），每次操作可以让相邻的两数加 $1$ 或 $-1$。

题意理解了，现在是
# 思路时间

首先这是一个数学类的问题。

我们要一个差分数组（叫他 $b$ 数组吧）（这里就不细讲差分了），我们要满足条件 $b$ 数组就不能有负数（第一位除外），首先我们要先知道相邻两个数 $+1$ 或 $-1$ 对 $b$ 数组有什么影响，假设是 $i$ 和 $i+1$ 加一，那么就是 $b_{i}+1$,$b_{i+2}-1$。 $i$ 和 $i+1$ 减一那就是 $b_{i}-1$,$b_{i+2}+1$。

到现在就可以把 $a$ 数组丢掉了，后面全用 $b$ 数组。
#### 敲重点

我们就可以把这个看成把奇数位和偶数位里的数互相传递（奇数位里的数互相传递）（偶数位里的数互相传递）（看不懂就多看几遍）。

由于第一位不用考虑是不是负数，那么奇数位的数可以无脑堆到 $b_{i}$。重点是偶数位怎么办，如果 $n$ 不是 $2$ 的倍数那么偶数位的数就可以把数无脑堆到 $b_{n+1}$（$n$ 是 $2$ 的倍数偶数位的数是不能堆到 $b_{n+2}$ 的）。

那奇数位就肯定是可以的，重要是偶数位，每个数之间只能在偶数位里互相传递，要是负数就无法完成，所以，

所有偶数位相加起来必须是正数，否则就是不行的。

接下来就是~~正确代码~~（不确定）（测评系统坏了好久。。。）。

# code


```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,a[300010],b[300010];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			b[i]=a[i]-a[i-1];
		}
		if(n%2==1)
		{
			cout<<"YES\n";
		}
		else
		{
			long long s=0;
			for(int i=2;i<=n;i+=2)
			{
				s+=b[i];
			}
			if(s<0)
			{
				cout<<"NO\n";
			}
			else
			{
				cout<<"YES\n";
			}
		}
	}
	return 0;
}

```

点赞（球球啦）

---

## 作者：DengDuck (赞：5)

结论题还是让我恼火。

希望序列不下降，就是希望差分数组非负，除了 $b_1$，差分数组第 $i$ 项为 $a_i-a_{i-1}$，改记为 $b_i$。

那么操作就变成 $b_x+c$，$b_{x+2}-c$，$c$ 为任意整数。

发现要奇偶分开考虑。

那么奇数一定可以满足，你可以无限压榨 $b_1$ 这个劳动力，它是多少都无所谓，然后 $b_3$ 变成很大的数字，再往 $b_5$ 传...一直传就可以了。

那其实我们发现还有一个可以压榨的劳动力——$b_{n+1}$，你把这个东西的定义出来，然后你发现这个东西也没有限制，然后你就可以压榨它喽。

如果 $n$ 为奇数，$n+1$ 为偶数，$b_{n+1}$ 可以用来填充偶数部分，所以必定有解。

考虑 $n$ 为偶数时的偶数部分，它们不能压榨任何人，只能互帮互助调整，所以你就看看它们的和，看看是否非负。
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=3e5+5;
LL T,n,b[N],a[N];
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%lld",&b[i]);
			a[i]=b[i]-b[i-1];
		}
		if(n&1)puts("Yes");
		else
		{
			LL sum=0;
			for(int i=2;i<=n;i+=2)sum+=a[i];
			if(sum>=0)puts("Yes");
			else puts("No");
		}
	}
}
```

---

## 作者：crimson000 (赞：5)

本题要通过将相邻的两个数加加减减，看能否将序列变为单调不降。

一般这种设计单调性以及区间加减的题目，一般可以考虑一下差分。

# 分析

我们可以构造出 $a$ 序列的差分序列 $b_1, b_2\cdots b_n, b_{n+1}$，（注意这里的 $b_{n + 1}$，是一个关键）我们发现相邻两个数同时加 $1$ 或同时减 $1$，带来的效果就是将差分序列中间隔为 $1$ 的两个数（或者可以称作下标奇偶性相同）一个加一，一个减一。

而我们的目标是要让整个差分序列 **除了 $b_1$ 和 $b_{n+1}$** 之外的数全部都不大于 $0$，因此我们可以从 $1$ 号位和 $n+1$ 号位考虑。

我个人的想法是可以把一个加 $1$ 一个减 $1$ 的操作看成一股水流，$1$ 号和 $n+1$ 号可以看成源头（可以无限从这里拿），然后向和 $1$ 奇偶性相同的位置提供数值，向和 $n+1$ 奇偶性相同的位置提供数值，直到所有数全部大于等于 $0$ 为止。

因此我们可以分析出当 $n$ 为奇数时必定有解，因为 $1$ 号位可以向所有奇数位提供数值，$n+1$ 号位可以向所有偶数位提供数值，这样全部的数就可以成为非负整数了。

当 $n$ 为偶数时，因为奇数位都可以被满足，所以只需考虑偶数位所存的数值能否使得所有偶数位都能非负。

具体考虑就是统计 $b$ 数组中所有偶数位的和，如果大于等于 $0$ 就可以满足，否则就无解。

# 样例模拟

~~我知道光看解释可能看不懂~~

$$
a: 5,4,3,2,1
$$
构造差分序列->
$$
b: 5, -1, -1, -1, -1, -1
$$
$1$ 号位减去 $15$，$3$ 号位就加上 $15$。

同理接着这样操作。
$$
b: -10, -1, 14, 8, -1, 10
$$
$$
b: -10, 3, 7, 4, 6, -10
$$

这时第 $2\sim n+1$ 位上都为非负整数，则构造单调不降序列成功。

另一个样例：
$$
a: 2, 1, 4, 3
$$
$$
b: 2, -1, 3, -1, -3
$$
$$
b: -\infty, -1, \infty, -1, -\infty
$$

可以看到第二个样例中，$b$ 序列中 $2$ 个 $-1$ 无论如何都无法变为 $2$ 个非负整数，因此无解。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int a[N], b[N];
int T, n;

int main()
{
    scanf("%d", &T);
    while(T -- )
    {
        scanf("%d", &n);
        for(int i = 1; i <= n; i ++ )
        {
            scanf("%d", &a[i]);
            b[i] = a[i] - a[i - 1];
        }

        if(n & 1) puts("YES");
        else 
        {
            long long sum = 0;
            for(int i = 2; i <= n; i += 2 ) sum += b[i];

            if(sum >= 0) puts("YES");
            else puts("NO");
        }
    }
    return 0;
}
```

---

## 作者：Fkxxx (赞：4)

### 题意
给出一串数，请问，通过将 $a_i$ 和 $a_{i+1}$ 同时加 $1$ 或减 $1$若干次，能否使它**单调不减**？
### 思路
我们发现，如果要让 $a_i$ 和 $a_{i - 1}$ 满足单调不减，可以通过修改 $a_i$ 和 $a_{i+1}$ 让 $a_i$ 和 $a_{i-1}$，那么我们修改的目标是什么呢？其实，我们可以干脆把 $a_i$ 和 $a_{i-1}$ 修改相等，这样，$a_1$ 到 $a_{n-1}$ 就都能满足要求，并且这样后面的元素可以调到的范围也会更大。

接下来，我们需要考虑最后一个数 $a_n$ 是否可以符合要求，我们发现，如果 $n$ 为奇数，只需让前 $n-1$ 的元素全部奇偶对应整体减小即可。如果 $n$ 为偶数就只能判断 $a_{n-1}\leq a_{n}$ 了。
### AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int t , n , a[300005] ;
signed main(){
    cin >> t ;
    while( t -- ){
        cin >> n ;
        for( int i = 1 ; i <= n ; i ++ ){
            cin >> a[i] ;
        }
        if( n % 2 ){
            cout << "Yes\n" ;
            continue ;
        }
        for( int i = 2 ; i < n ; i ++ ){
            if( a[i] != a[i - 1] ){
                int k = a[i] - a[i - 1] ;
                a[i] -= k ;
                a[i + 1] -= k ;
            }
        }
        if( a[n - 1] <= a[n]  ) cout << "Yes\n" ;
        else cout << "No\n" ;
    }
    return 0 ;
}
```

---

## 作者：Withershine (赞：2)

直接进入主题吧。

## 思路
题目要求非递减序列，很明显，由题目给的操作，一定可以将这个序列的前 $n - 1$ 项能够满足是非递减序列，最后只需要比较第 $n$ 项是否大于等于第 $n - 1$ 项即可。

解释一下为什么。对于序列 $a$，从 $a_1$ 开始到 $a_{n-1}$ 结束，每次对 $a_i$ 与 $a_{i+1}$ 进行操作使得 $a_i$ 比 $a_{i-1}$ 刚好大 $1$ 或者相等，很明显这是可以做到的。由此可以将前 $n-1$ 项变得符合题意的。

此时你会惊讶的发现这样连样例都过不了，仔细看会发现当 $n$ 为奇数时程序就会输出 $\texttt{No}$。手推几个数据后，发现如果最后 $a_{n-1}>a_n$，可以将前 $n-1$ 项全部减去一个极小值来达成非递减序列。说人话就是当 $n$ 为奇数时直接输出 $\texttt{YeS}$。

---

## 作者：__Creeper__ (赞：0)

### 题意

给出一串数，通过将 $a_{i}$ 和 $a_{i+1}$ 同时加 $1$ 或减 $1$ 若干次，能否使数列单调不减？

### 思路

如果要使 $a_{i}$ 和 $a_{i+1}$ 满足单调不减性，修改 $a_{i}$ 和 $a_{i+1}$ 是无意义的，只有通过修改 $a_{i+1}$ 和 $a_{i+2}$ 的值才能使 $a_{i+1}$ 变大，至少需要让 $a_{i}$ 和 $a_{i+1}$ 相等，最后只需要比较 $a_{n-1}$ 和 $a_{n}$ 的大小就可以了。

- 特判，长度为奇数时，一定可以把前偶数项减至极小值，输出 `Yes`。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 3e5 + 5;
int T, n, a[N];

signed main()
{
	cin >> T;
	while( T-- )
	{
		cin >> n;
		for ( int i = 1; i <= n; i++ )
		{
			cin >> a[i];
		}
		if ( n % 2 == 1 )
		{
			cout << "Yes" << endl;
			continue;
		}
		for ( int i = 2; i < n; i++ )
		{
			if ( a[i] != a[i - 1] )
			{
				int k = a[i] - a[i - 1];
				a[i] -= k;
				a[i + 1] -= k;
			}
		}
		if ( a[n - 1] <= a[n]  ) cout << "Yes" << endl;
		else cout << "No" << endl;
	}
	return 0;
}
```

---

## 作者：xh001 (赞：0)

# 题意
首先给定一个整数 $t$ 表示有 $t$ 组数据，每组数据包含一个数 $n$ 和一个序列 $a$，求是否能通过将 $a_{i}$ 和 $a_{i+1}$ 同时加 $1$ 或减 $1$ 若干次，使它单调不减。
# 思路
首先，很明显的是，我们想要使所有 $a_{i}$ 均小于等于 $a_{i+1}$，修改 $a_{i}$ 和 $a_{i+1}$ 是没有意义的，只有通过修改 $a_{i+1}$ 和 $a_{i+2}$ 的值才能使 $a_{i+1}$ 相对变大，最少也需要让 $a_{i+1}$ 和 $a_{i}$ 相等，而为了使 $a_{i+1}$ 更容易满足小于等于 $a_{i+2}$，即使 $a_{i+1}$ 大于 $a_{i}$ 也要将 $a_{i+1}$ 减至于 $a_{i}$ 相等，最后只需要比较 $a_{n-1}$ 和 $a_{n}$ 的大小就可以了。

**但是**，还有一个地方需要特判，长度为奇数时，一定可以把前偶数项减至极小值。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//好习惯。 
const ll mn=2e18;
ll t,n,a[300001];
inline ll read()
{
	ll k=0,f=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) f|=c=='-';
	for(;isdigit(c);c=getchar()) k=(k<<1)+(k<<3)+(c^48);
	return f?-k:k;
}
int main()
{
	t=read();
	while(t--)
	{
		n=read();
		for(ll i=1;i<=n;i++) a[i]=read();
		if(n&1)//特判。 
		{
			printf("YES\n");
			continue;
		}
		for(ll i=2;i<n;i++)
		{
			ll t=a[i-1]-a[i];
			a[i]+=t;
			a[i+1]+=t;
		}
		if(a[n-1]<=a[n]) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```


---

## 作者：SakurajiamaMai (赞：0)

## 思路:
本题考查贪心，如果一个数比上一个数小的话，这个数就需要加或者上一个数需要减，乍一看没有规律。不妨先把规则改成都需要加，让前 $n-1$ 个数都和第一个数相等，然后再进行判断，容易看出如果前 $n-1$ 个数不减，只要是偶数，同时减去任意一个数都不会改变顺序，如果是奇数则不可以。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=1e9+7;
string s,l,r;
int n,t,a[N],f[N],res,ans,m,k,pos;
bool vis[N];
void solve()
{
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    int num=0;
    for(int i=1;i<n-1;i++) a[i]+=num,num=a[i-1]-a[i],a[i]=a[i-1];
    if(a[n-1]+num<a[n-2]){
        if((n-1)%2==0) cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
    else cout<<"YES"<<endl;
}
signed main()
{
    std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        solve();
    }
    return 0;
}
```


---


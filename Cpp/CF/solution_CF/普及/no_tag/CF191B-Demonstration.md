# Demonstration

## 题目描述

在贝兰国的首都伯特城，由于国王的最近选举结果，市民们展开了抗议活动。奥瓦尔尼先生领导的反对派认为，此次选举不够公正，他们希望在某个广场上组织一次示威。

伯特城一共有 $n$ 个广场，从 $1$ 到 $n$ 编号。编号越小，离市中心越近。也就是说，广场 $1$ 是最靠近市中心的，而广场 $n$ 最远。自然地，反对派希望尽可能在最接近市中心的广场上举行集会。

距离示威活动还有 $k$ 天（$k < n$）。目前所有广场都是空闲的。不过，城里的市政府并不闲着，批准示威申请的过程可能会变得非常繁复冗长。申请审批的过程将持续几天，具体程序如下：

- 反对派每天必须申请一个空闲的广场来举行示威（即没有被市政府占用的广场）。
- 市政府会试图让他们在余下的空闲广场中，选择最不理想的一个进行示威。市政府会在反对派申请的广场上安排长期活动，使之不再空闲。然后建议反对派搬到最不理想的那个空闲广场。如果反对派申请的正好是最不理想的空闲广场，那请求就会被接受，市政府也不会花钱。如果市政府没足够的钱在申请的广场上组织活动，则反对派的申请会被直接通过。如果市政府钱不够用，他们会把剩下的钱用光，但还是得接受申请。
- 如果申请未被接受，反对派能选择同意市政府的建议（使用最不理想的空闲广场），或撤回申请，等到第二天重提。如果剩下的天数不够，反对派就只能接受市政府的建议。如果申请被接受，反对派可以选择拒绝，这意味着他们还是可以在之后继续申请，广场也会保持空闲。

在广场 $i$ 上举办活动需要花费 $a_i$ 布勒。由于经济不景气，市政府只有 $b$ 布勒来阻止反对派。那么，反对派能够选择的最优广场的最小编号是多少？注意，市政府的对策完全取决于反对派的行为。

## 说明/提示

在第一个示例中，反对派可以先申请广场 3，让市政府在那里举办活动，这样市政府剩下 3 布勒。第二天如果反对派申请广场 2，市政府将无力干扰。

在第二个示例中，反对派只能选择最后一个广场。如果他们一开始就占据前四个广场的任何一个，市政府至少会剩余 4 布勒，这样下一天可以将反对派从任何一个广场赶到最后一个广场。

在第三个示例中，市政府有充足的资金，因此反对派只能占据最后一个广场。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 2
8
2 4 5 3 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5 2
8
3 2 4 1 5
```

### 输出

```
5
```

## 样例 #3

### 输入

```
5 4
1000000000000000
5 4 3 2 1
```

### 输出

```
5
```

# 题解

## 作者：Phoenix114514 (赞：0)

## 题解：CF191B Demonstration
### 思路
由于是反对派申请之后政府才能抉择，所以政府的行动由对派决定，因此我们可以采取**贪心**的策略：
- 按资金从大到小排序，前 $k$ 天用资金较大的广场去消耗政府的钱。
- 累加资金前 $k$ 大广场的资金，若政府的钱多余此和，直接输出 $n$。
- 将每个广场遍历一遍，若资金前 $k$ 大广场的资金减去第 $k$ 大广场的资金加上当前广场的资金大于政府的钱，输出广场编号。
### Code
```cpp
#include<bits/stdc++.h>
#include<bits/stl_algo.h>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
#define int long long
#define ull unsigned long long
#define ui unsigned int
const int N=1e5+5;
int n,k,b,cnt;
int a[N],id[N];
bool cmp(int x,int y){return a[x]>a[y];}
void solve(){
    cin>>n>>k>>b;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        id[i]=i;
    }
    sort(id+1,id+n,cmp);
    for (int i=1;i<=k;i++)cnt+=a[id[i]];
    if (b>=cnt){
        cout<<n<<endl;
        return;
    }
    for (int i=1;i<=n;i++){
        if(cnt-a[id[k]]+a[i]>b){
            cout<<i<<endl;
            return;
        }
    }
    return;
}
signed main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    int t=1;
    while(t--)solve();
    return 0;
}
```

---

## 作者：wbxxxx (赞：0)

#### 给大家推荐一个简单易通的方法。

# 思路：

题目告诉我们: **ZF 的行动始终取决于 FD 派的行动**。所以我们可以进行一种 **贪心的思路**，由于 FD 想广场最小编号，而 ZF 的资金有限，所以在前 $k$ 天用较大的广场代价去消耗 ZF 的资金，然后再第 $k$ 天选择 ZF 无法阻止的最小广场编号。

对于 $k$ 天我们可以进行特判，如果 $k$ 个最大代价的广场的总值都小于 $b$，FD 就只能选择 $n$ 号广场，所以直接输出 $n$ 即可。


## [代码](https://www.luogu.com.cn/record/168837890)

---

## 作者：_Kimi_ (赞：0)

# CF191B题解

### 题意

一些 FD 派想在广场上举行活动。

共有 $n$ 个广场，按离市中心的距离递增顺序依次编号 $1$ 到 $n$，FD 派希望活动离市中心越近越好。

ZF 不想让他们举行活动，于是使用资金在广场举行活动。

距离活动还有 $k$ 天，在这 $k$ 天内，ZF 都会对 FD 派的申请进行审批，FD 派可以申请还没有举行活动的广场。如果 FD 派申请了第 $n$ 号广场，ZF 会直接同意。

ZF 在第 $i$ 个广场举行活动的花费是 $a_i$。ZF 只有 $b$ 的资金，问 FD 派可以申请的所有广场中编号最小的是哪个？

注意：ZF 的行动始终取决于 FD 派的行动。

### 思路

**因为 ZF 的行动始终取决于 FD 派的行动**，所以 FD 派会选一些需要资金较大的广场来消耗 ZF 的资金，所以我们以需要花费的资金为关键字，把编号排序，前 $k$ 天 FD 派一定会尽量消耗 ZF 的资金，如果 ZF 的钱够那么 FD 派只能申请到第 $n$ 号广场。在这之后我们遍历从 $1$ 到 $n$ 看看有没有一种情况不申请资金花费第 $k$ 大的广场申请第 $i$ 号的广场也行，如果可以就直接输出即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int n, k, a[maxn], ans[maxn];
long long b, s;
bool cmp(int x, int y){
    return a[x] > a[y];
}
int main() {
    cin >> n >> k >> b;
    for (int i = 1; i <= n; i++) cin >> a[i], ans[i] = i;
    sort(ans + 1, ans + n, cmp);
    for (int i = 1; i <= k; i++) s += a[ans[i]];
    if(b >= s) cout << n << endl;
    else{
        for (int i = 1; i <= n; i++){
            if(s - a[ans[k]] + a[i] > b){
                cout << i << endl;
                return 0;
            }
        }
    }
    return 0;
}

---


# Roma and Changing Signs

## 题目描述

一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。

他有 $k$ 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 $1$ 变成 $−1$ （注意，他必须严格执行 $k$ 次）问总收入最大是多少？

## 说明/提示

在第一个样例中，我们可以得到序列 $[1,1,1]$ ，因此总收入等于 $3$。

在第二个样例中，我们可以得到序列 $[-1,1,1]$，因此总收入等于 $1$。

## 样例 #1

### 输入

```
3 2
-1 -1 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 1
-1 -1 1
```

### 输出

```
1
```

# 题解

## 作者：Molina (赞：3)

# 题目大意：
题目链接：[洛谷链接](https://www.luogu.com.cn/problem/CF262B) && [CF链接](https://codeforces.com/problemset/problem/262/B)

本题意思很好理解：

一共有 $ n $ 个数，你一共有 $ k $ 次机会可以将这 $ n $ 个数中的一个数，改成它的相反数（也就是取反），求经过 $ k $ 次操作（必须经过 $ k $ 次操作）之后 $ n $ 个数的总和最大值是多少？
# 本题思路：
本题翻译中的数据范围写错了，应为：$ n \le 10^5 $。

当然，这不影响我们直接**模拟**。

首先，想要让这些数的总和最大化，取反时优先将那些负数取反。所以，在输入时，我们就进行判断，因为输入是按升序排列的，所以先就不用排序了。

若输入 $ a_i $ 为一个负数，就将它取反，并将 $ k $ 减一，把改变后的 $ a_i $ 的值记录在答案中。若做完 $ k $ 次操作后，就不用改了。

因为题目要求，必须经过 $ k $ 次操作，所以在输入判断完后，将数组排序，找到当前数组的最小值。接着判断剩下的 $ k $ 的奇偶性，若剩下的 $ k $ 为偶数，那答案就不用改变。若为奇数，那将当前答案减去当前数组最小值的两倍即可。

将答案输出就行了，详细解释请见代码。

~~这道题太水了！~~
# 代码来咯~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005];
long long ans=0;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]<0  &&  k>0)  a[i]=0-a[i],k--;//判断，取反
		ans+=a[i];//累加答案
	}
	sort(a+1,a+n+1);//排序
	if(k%2==0)  cout<<ans;
	else  cout<<ans-2*a[1];//判断奇偶性，输出
	return 0;
}
```

---

## 作者：hexuchen (赞：1)

无人区写题解的第六天

[题目传送门](https://www.luogu.com.cn/problem/CF262B)

[更好的阅读体验？](https://www.luogu.com.cn/blog/945742/solution-cf262b)

## 题目意思

给出一个长度为 $n$ 的序列，现在有 $k$ 次操作，每次操作可以将序列里的一个数取反。求序列之和最大为多少。

## 思路分析

一道有点小难的水题。

分析样例会发现，如果负数的数量大于 $k$，那么答案就是序列的前 $k$ 项的绝对值之和。

但是如果负数的数量小于 $k$，那么又可以分成两种情况：

- $k$ 为偶数，则我们可以将一个数反复取反 $k \div 2$ 次，最终这个数也不变，所以答案也不变。

- $k$ 为奇数，则我们必须将一个数取反成负数。我们数组先排序（因为前面有操作过），然后因为要取反成负数，所以就是取反最小的那个数，也就是序列的第一位。答案要减去序列的第一位**两次**，因为减去第一次序列的第一位为 $0$，减去第二次序列的第一位才为负数。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,s[100001],sum=0,ans=0;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		if(s[i]<0 && k!=0){ //如果是负数且还有更改的次数
			k--;
            s[i]*=-1; //取反
		}
        ans+=s[i]; //答案加上这个数
	}
    sort(s+1,s+1+n); //重新排序
	if(k>0){ //如果有剩次数
        if(k%2==1){ //如果是奇数
            ans-=2*s[1];
        }
    }
	cout<<ans<<endl; //记得换行
	return 0;
}
```

---

## 作者：_int123_ (赞：1)

题目：

## Roma and Changing Signs

### 题意：
一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。

他有 $k$ 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 $1$ 变成 $-1$（注意，他必须严格执行 $k$ 次）问总收入最大是多少？



------------

### 提前说明：

题目翻译错了，应该为 $n \le 10^5$。

### 思路：

1. 不难看出，想要让这些数的总和最大，取相反数时应优先将那些负数取成相反数。

2. 因为题目说了输入是按升序排列的，所以在输入时，我们先不用排序，直接判断是否为负数，如果是负数且满足 $k>0$，我们便将此数变为相反数，并将 $k$ 减小 $1$。

3. 虽然输入是按升序排列的，但我们修改了一些值，使其不一定为升序了。所以现在，我们可以将这些数排序。

4. 现在，我们要看 $k$ 是否还大于 $0$。此时有三种情况：第一种，$k \le 0$ 不需要进行后面操作，直接输出。第二种，$k$ 为偶数，我们可以将数列中的一个数改变 $k$ 次，答案不变，输出。第三种，$k$ 为奇数，由于一个数改变奇数次就等于让其变为相反数，我们又想让答案尽量大，所以我们可以让数列中最小的数变号。

通过这些思路，我们不难得出代码。

### AC 代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,k;
int a[100005];//存储这些数
long long ans=0;//记录最后的值
int main()
{
	scanf("%d%d",&n,&k);//输入
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]<0&&k>0)//直接判断a[i]是否为负数，如果是负数且满足 k>0，我们便将此数变为相反数，并将 k 减小 1。
		{
			a[i]=-a[i];
			k--;
		}
		ans+=a[i];//记录答案
	}
	sort(a+1,a+n+1);//排序
	if(k%2==0) cout<<ans;
	else cout<<ans-2*a[1];//我们多加了一遍，所以要减少 2 遍。
	return 0;
}
```

完结，撒花！！！

---

## 作者：WhxStar2024 (赞：0)

## 本题思路：
这道题其实很简单，我们只需要贪心一下，只要当前这一位的数值是负数，次数还够，那么就把他改了即可。

在最后的时候需要注意一下，如果次数还剩了一些，就判断次数是否是奇数，如果是就减两遍最小值即可。
## 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int main() 
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		if(k==0) break;
		if(a[i]<0) a[i]=-a[i],k--;
	}
	int ans=0,mi=INT_MAX;
	for(int i=1;i<=n;i++) mi=min(mi,a[i]),ans+=a[i];
	if(k%2==1) ans=ans-mi-mi;
	cout<<ans;
	return 0;
}
```


---

## 作者：Neilchenyinuo (赞：0)

# 题目大意

1. 给定一串数列，可以将数列操作 $k$ 次，每次操作可以将数列中的任意一个数，成为其相反数，求最大总和。

# Solution

1. 运用贪心的思想，先遇到负数就消耗一次修改将其变成相反数，然后用累加器 $sum$ 累加起来。

2. 假如已经没有负数但是还要修改的话，分两种情况讨论：

- 当 $a\equiv0\pmod{2}$ 时，我们就可以一直给序列的任意一个值，一直进行取反，这样序列和就不会发生变化，因此输出 $sum$。

- 当 $a\equiv1\pmod{2}$ 时，我们只需要一直操作最小值（因为这样的损失最小），最后肯定是要减掉 $2 \times mini$ 即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int n,k,a[N],ans,mini=1e18;
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]<0&&k>0)
			a[i]=-a[i],k--;
		mini=min(mini,a[i]);
		ans+=a[i];
	}
	sort(a+1,a+1+n);
	if(k%2==0)
		cout<<ans;
	else
		cout<<ans-mini*2;
	return 0;
}
```


---

## 作者：_xxxxx_ (赞：0)

### 题意

给出 $n$ 和有 $n$ 个数的数组 $a$，现在你必须要进行 $k$ 次操作，使得 $a$ 中的元素的和最大。每次操作可以将一个数负变正，正变负，并且满足 $a$ 中的元素是升序输入的。现在要求出 $k$ 次操作后的最大值。

### 思路

因为一次操作可以将负变正，那么可以先从绝对值大的数开始操作。先把负数改成整数，这绝对最优。

如果还有多出来的次数，但是也必须要花完它。因为可能会将正数改为负数，而正数却不会再变大，所以我们可以找到一个最小的数，将所有改变都往它身上做。这样的话，就算变负了，损失也是最小的，而就算不会变负，对所有数而言都是一样的。

因为负负得正，所以我们判断一下剩下的次数的奇偶性就可以知道是不变还是变负了。

综上所述，时间复杂度为 $O(n)$，可以通过。

### 代码

```
#include <iostream>
#include <cmath>
#include <stdio.h>
#include <cstdio>
#include <algorithm>
#define int long long
using namespace std;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;
int n, k, a[N], minn = INF, all;
signed main()
{
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	//因为输入约定了是升序，所以不用排序 
	for(int i = 1; i <= n; i++)
	{
		if(a[i] < 0 && k != 0)//是负数并且还有次数 
		{
			a[i] = -a[i];//变正 
			k--;
		}
		minn = min(minn, a[i]);//找最小值 
		all += a[i];//总和 
	}
	if(k & 1)//是奇数，会变负 
	{
		cout << all - minn * 2 << endl;//减掉 
	}
	else
	{
		cout << all << endl;//不变 
	}
	return 0;
}
```

最后解释一下如果最小值是负数为什么不会进到减掉的那个 `if` 里。

因为最小值是负数的话，$k$ 就一定会变成 $0$。不然就会对那个负数进行变正。而 $0$ 是偶数，就会直接输出。因此答案不会产生变化。

---

## 作者：AstaSunch_ (赞：0)

# 题意简述
有 $n$ 个数，有 $k$ 次机会可以使其中的一个数取其相反数，问 $k$ 次操作之后数的总和最大是多少？
# 题目思路
水。

将数组从小到大排序。

对于前 $k$ 个数，若 $n_i<0$ 则取其相反数（这样可以使所有的数值总和最大），同时 $k-1\to k$。若 $n_i\geq0$，立即停止。

若将所有负数取反后，$k>0$，则**分类讨论**：若 $k$ 为奇数，则将原先的最小值取其相反数；若 $k$ 为偶数，则就相当于将同一个数连续取反 $k$ 次，等同于不变。

# Code
这么水的题，就不放代码了，但要注意细节（例如只能严格执行 $k$ 次操作，不能少）

---

## 作者：oimaster (赞：0)

[这道题是我下午做的，你在源代码里的 Time 就会发现。是的，没错，不过晚上我还要打一场虚拟。](https://oi-master.github.io/post/codeforces-contest-262-b-ti-jie/)

貌似这道题洛谷没人写题解呀，我就把这个坑填上吧。

## 题面
### 英文题面
请去 [Codeforces](https://codeforces.com/contest/262/problem/B) 官网上看吧，我这里不做介绍
### 中文题面
一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。

他有 $m$ 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 $1$ 变成 $-1$ （注意，他必须严格执行 $m$ 次）问总收入最大是多少？（作弊啊，同志
## 思路
简单水题，瞬间秒杀！

这道题的确很水的好不好，可是弱弱的我就因为一个小错误 WA 了 $3$ 次，唉。

这道题由于是到简单题，所以我决定从微观开始讲。

首先是板子
```cpp
/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-06 16:45:57
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
```
呵呵呵，板子有点长，接下来是简单得不能再简单的输入。
```cpp
int n,m;
cin>>n>>m;
int a[n];
for(int i=0;i<n;++i)
	cin>>a[i];
```
这种题目，显然要排序。
```cpp
sort(a,a+n);
```
然后呢，我们就要详细地讲一下这一段。
```cpp
int j=0;
while(a[j]<0&&m>0){
	a[j]*=-1;
	--m;
	++j; 
}
if(a[j]==0)
	m=0;
```
怎么解释？我们先看 $j$ ，大家应该都知道 $j$ 是什么意思吧，就是说现在看到第几个了。你可能会问，为什么不用 $i$ ，因为我习惯把 $i$ 作为 `for` 循环的变量，如果定义 $i$ 的话，将会编译错误。当你看到完整代码的时候，你就会知道为什么要用 $j$ 而不用 $i$ 。

然后我们先不扯 $i$ 和 $j$ 的问题，就看中间这一段。如果你不会做这道题的话，我觉得对于这一段的问题还是挺大的。

我们大概能通过字面意思了解到，这一段话的作用就是把所有 $\leq 0$ 的数字中前 $k$ 小的挑出来（当然如果没有 $k$ 这么多就是全挑出来），乘上一个 $-1$ ，相当于负的变成正的。如果有多的，那么后面在应用于正数上。

那么后面的 `if` 语句又是怎么回事？其实，我们发现， $0$ 是一个神奇的数字，当我们搞到 $0$ 的时候，我们可以搞任意多次，把 $m$ 耗光，就不用搞到正数上面了，搞到正数上面可能还会起到副作用。

好，那么接下来，我们就要处理一下当 $m$ 还没用完的情况了。

还是上代码。
```cpp
sort(a,a+n);
if(m&1)
	a[0]*=-1;
```

首先，先排序。

然后，我们发现，当 $m$ 是偶数的时候，我们可以把 $m$ 用在一个数字上，会抵消，所以没用。

如果是奇数的话，我们又会发现，操作在最小的数字上最划算，而且操作完后相当于动一下（因为偶数就抵消了），所以就可以直接放心地把 $a_0$ 乘上 $-1$。
```cpp
    int sum=0;
    for(int i=0;i<n;++i)
	    sum+=a[i];
    cout<<sum<<endl;
    return 0;
}
```
~~这些有什么好看的~~
## 代码
我已经把所有的代码都展示出来了，大家自己拼吧（逃

---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15760684.html)

# 题目大意

一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。

他有 $k$ 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 $1$ 变成 $-1$ （注意，他必须严格执行 $k$ 次）问总收入最大是多少？

# 题目分析

将数组从小到大排序后：

在前 $m$ 个数中，我们取出负数并取反，若 $\ge0$ 则马上退出。将这些数取反之后，就能够将 $\sum\limits_{i=1}^{n}a_i$ 的和变得更大。

若 $m$ 将这些负数取反后还有剩余，那么再分类讨论：

+ 若 $m$ 为偶数，则偶数次操作后 $a$ 的值不变。

+ 若 $m$ 为奇数，则只需操作一次就等价于操作 $m$ 次操作，将最小值取反即可。

# 代码

细节巨多。。。

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 20;

int n, k;
int vec[MAXN];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> k;
	for (int i = 0; i < n; i++)	cin >> vec[i];
	sort(vec, vec + n);
	int b = 0;
	while (b < n && k--) {
		if (vec[b] >= 0) {
			k++;
			break;
		}
		vec[b++] *= -1;
	}
	if (k < 0)	k = 0;
	sort(vec, vec + n);
	if (vec[0] == 0 || k % 2 == 0) {
		ll sum = 0;
		for (int i = 0; i < n; i++)	sum += vec[i];
		cout << sum << endl;
		return 0;
	}

	vec[0] *= -1;
	ll sum = 0;
	for (int i = 0; i < n; i++)	sum += vec[i];
	cout << sum << endl;
	return 0;
}
```

---


# Parallel Programming

## 题目描述

有一个长度为 $n$ 的数组 $a$。最初，$a = \{1,1,1,\dots,1,1,0\}$。

你可以执行 $k$ 次操作：对于每个 $i \in [1,n]$，你可以选择一个 $c \in [1,n]$，并执行 $a_i \gets a_i + a_c$。所有 $a_i\ (i \in [1,n])$ 都会**同时**执行更改的操作。

你的目标是在 $k$ 次操作后将数组 $a$ 变为 $\{n-1,n-2,n-3,\dots,2,1,0\}$。输出一种合法的方案（即每个 $c$）。

**保证数据合法，即存在至少一个解。**

## 说明/提示

对于样例 #2：

最初，$a = \{1,1,0\}$。

第 $1$ 次操作：
| $i$ | $1$ | $2$ | $3$ |
| :----------: | :----------: | :----------: | :----------: |
| $a$ | $1$ | $1$ | $0$ |
| $c$ | $2$ | $3$ | $3$ |
| $a_c$ | $1$ | $0$ | $0$ |
| 结果 | $2$ | $1$ | $0$ |

第 $2$ 次操作：
| $i$ | $1$ | $2$ | $3$ |
| :----------: | :----------: | :----------: | :----------: |
| $a$ | $2$ | $1$ | $0$ |
| $c$ | $3$ | $3$ | $3$ |
| $a_c$ | $0$ | $0$ | $0$ |
| 结果 | $2$ | $1$ | $0$ |

所以，答案为
$$\begin{bmatrix}2 & 3 & 3\\ 3 & 3 & 3\end{bmatrix}$$

Translated by liuli688

## 样例 #1

### 输入

```
1 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3 2
```

### 输出

```
2 3 3
3 3 3
```

# 题解

## 作者：liuli688 (赞：0)

一道比较水的构造题。
### 思路
观察题面，我们发现 $a_n = 0$。为什么对于 $\forall i \in [1,n-1]\ a_i = 1$ 但是 $a_n = 0$ 呢？再次观察样例 #2，可以发现如果一个 $a_i$ 的值已经等于它的目标 $n - i$，可以不断将 $c$ 设为 $n$ 来凑操作次数。

又由于 $a_0 \sim a_{n-1}$ 的值都为 $1$，所以 $a_{n-1}$ 和 $a_n$ 都已经达到最终状态，我们不必增加它。不难想到一种构造方法：在第 $i$ 次操作时 将 $\forall i \in [1,n-i)\ a_i \gets a_i + a_{n-1}$，如果已经达到终态则加上 $a_n$ 即 $0$。这样，每次操作 $\max a_i$ 会增加 $1$，经过 $n - 2$ 次操作完成。操作过程如下：
```
111...1111110
222...2222210
333...3333210
444...4443210
555...5543210
............
```
可是，这样操作速度过慢，而 $n$ 的范围是 $n \le 10^4$，如果 $n > 18$ 的情况怎么办？上面的方法在进行每次操作时每个数字最多加 $1$，然而此时的最大数字早已不是 $1$ 了。于是，我们想到以下方法：
```
111...1111111111110
222...2222222222210
444...4444444443210
888...8888876543210
............
```
在这种方法里，我们通过每次增加当前最大的 $a_i$ 实现了最快的增加。这就是我们的方法。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register

constexpr int N = 1e4 + 1;
int n,k,ans[N];

signed main()
{
    reg int i,j,lim;
    scanf("%d%d",&n,&k);
    for(i = 1;i <= k;++i)
    {
        lim = pow(2,i-1);
        ans[n] = n;
        for(j = 1;n - j > 0 && j <= lim;++j)
            ans[n-j] = n;//用 0 凑次数
        for(j = 1;n - lim - j > 0 && j <= lim;++j)
            ans[n-lim-j] = n - j;//2^{i-1} 和 2^i 中间的过渡部分
        for(j = 1;j <= n - lim - lim;++j)
            ans[j] = n - lim;//加最大 a_i
        for(j = 1;j <= n;++j)
            printf("%d ",ans[j]);
        putchar('\n');
    }
    return 0;
}
```
代码没有加过多注释，请大家自己理解。

---


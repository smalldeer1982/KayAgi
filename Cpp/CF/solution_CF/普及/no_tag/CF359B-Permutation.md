# Permutation

## 题目描述

A permutation $ p $ is an ordered group of numbers $ p_{1},p_{2},...,p_{n} $ , consisting of $ n $ distinct positive integers, each is no more than $ n $ . We'll define number $ n $ as the length of permutation $ p_{1},p_{2},...,p_{n} $ .

Simon has a positive integer $ n $ and a non-negative integer $ k $ , such that $ 2k<=n $ . Help him find permutation $ a $ of length $ 2n $ , such that it meets this equation: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF359B/3219249e86370a1de394689053e4d90b271818a5.png).

## 说明/提示

Record $ |x| $ represents the absolute value of number $ x $ .

In the first sample $ |1-2|-|1-2|=0 $ .

In the second sample $ |3-2|+|1-4|-|3-2+1-4|=1+3-2=2 $ .

In the third sample $ |2-7|+|4-6|+|1-3|+|5-8|-|2-7+4-6+1-3+5-8|=12-12=0 $ .

## 样例 #1

### 输入

```
1 0
```

### 输出

```
1 2```

## 样例 #2

### 输入

```
2 1
```

### 输出

```
3 2 1 4
```

## 样例 #3

### 输入

```
4 0
```

### 输出

```
2 7 4 6 1 3 5 8
```

# 题解

## 作者：_zy_ (赞：37)

## [题目传送门](https://www.luogu.com.cn/problem/CF359B)
 
 
 **题目大意：**
 
 构造序列使
$\sum_{1}^n{|a_{2i}-a_{2i-1}|}-|\sum_{1}^n{a_{2i}-a_{2i-1}}|=2k$

分析 ：

- 当 $k=0$ 时，很显然是直接输出 $1-2n$ 的所有整数。

- 当 $k!=0$ 时，就可以让两个数更换位置来让原式等于 $2k$ ，而剩下的依旧按照 $1-2n $的顺序来保持 $k $ 的值不变。

**找哪一个呢？**

当 $a_{2i}<a_{2i-1}$ 时，将绝对值去掉变负数。

可得，此时的值为 $2*(a_{2i}-a_{2i-1})$ ，于是就将第一个数变为 $k+1$ ，剩下的照常输出就好。

代码如下：
```cpp
#include<cstdio>
using namespace std;
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	n<<=1;
	printf("%d ",m+1);
	for(int i=1;i<=n;i++)
		if(i!=m+1)	printf("%d ",i);
    return 0;
}

```
#### 如有不妥，请不要吝啬您的建议。

---

## 作者：LRL65 (赞：11)

一道**构造题**，我们先来看看题目中的式子：

$\sum_{i=1}^n \left\vert a_{2i}-a_{2i-1}\right\vert - \left\vert \sum_{i=1}^na_{2i}-a_{2i-1}\right\vert=2*k$

我们来分析一下。这个式子可以分为两半。

前一半是指**把这个排列a两个数分为一组，用每组后面的数减去前面的数，再把他们的绝对值加起来**。

后一半指**把这个排列a两个数分为一组，用每组后面的数减去前面的数，把他们加起来再绝对值**。

最后两个一半加起来等于 $2*k$ 。

那么这两半的区别在哪？前一半先绝对值再加，后一半先加后绝对值。既然这样我们先构造一个**升序的排列**，这样就不用管绝对值了。这时候**这个式子的结果应为0**。

此时我们可以交换每一组里的前后两个数（即 $a_{2i}$ 和 $a_{2i}-1$ ），**一次交换会使得结果加2**（前一半加1，后一半加1）。因为等于 $2*k$，所以我们只需要交换 $k$ 次就行了。

交换 $k$ 次，最简单的办法就是**先构造一个值为 $1$～$2n$ 的上升序列，然后将 $k+1$ 提到最前面来**，输出即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main(){
    cin>>n>>k;
    cout<<k+1<<" ";//先输出k+1
    for(int i=2;i<=k+1;i++)cout<<i-1<<" ";
    for(int i=k+2;i<=2*n;i++)cout<<i<<" ";
}
```



---

## 作者：szzzzs (赞：10)

## [题目传送门](https://www.luogu.com.cn/problem/CF359B)
### 题目分析
$2n$ 个不同的数，经过排列以后使得$\sum_{i=1}^n|a_{2i}-a_{i-1}|$ - $|\sum_{i=1}^na_{2i}-a_{2i-1}|$=$2k$。

## 思路

 1.$2k$<$n$ $\Leftrightarrow$ $4k$<$2n$
 
 2.|$a_{2i}-a_{2i-i}$|+|$a_{2*(i+1)}-a_{2*(i+1)-1}$|-|$a_{2i}-a_{2i-i}$+$a_{2*(i+1)}-a_{2*(i+1)-1}$| = $2$  也就是说每四个$a[i]$可以产生一个二，即在$2n$个数一定可以中凑出$2k$个数。
 
 那么怎么凑出这个二呢？$n,n+1,n+2,n+3$ 变成 $n,n+1,n+3,n+2$ 即可。代码实现并不困难。
##  【Code】
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500000],n,k;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=2*n;i++)
	{
		a[i]=i;
		if(i%4==0&&i/4<=k)
		swap(a[i],a[i-1]);
	}
	for(int i=1;i<=2*n;i++)
	cout<<a[i]<<" ";
	return 0;
}
```


---

## 作者：conclr (赞：7)

### 思路分析
这道题目猛一看确实挺吓人的，式子这么长，还带绝对值，绝对不是什么很好做的题目

但是认真分析，我们就可以发现 $k$ 的范围其实很小，$0 \leq 2k \leq n$，前面还带个系数 $2$。

再结合绝对值的性质，分类讨论把这个式子拆开：
- 当 $\sum_{i = 1}^n a_{2i} - a_{2i - 1} > 0$ 时
- - 对于某个 $i$ 满足 $a_{2i} - a_{2i - 1} > 0$，则它的贡献就是$a_{2i} - a_{2i - 1} - (a_{2i} - a_{2i - 1}) = 0$
- - 对于某个 $i$ 满足 $a_{2i} - a_{2i - 1} \leq 0$，则它的贡献就是 $a_{2i - 1} - a_{2i} - (a_{2i} - a_{2i - 1}) = 2(a_{2i - 1} - a_{2i})$
- 当 $\sum_{i = 1}^n a_{2i} - a_{2i - 1} \leq 0$ 时同理

所以我们想要使这个排列满足条件的话,只要**有一个且仅有一个** $i$ 满足它的贡献为 $2k$ 就够了

例如可以按照这样的规律构造：第一个数为 $k + 1$，然后其他的数按从大到小的顺序排列在后面

这样仅有且只有第一位的 $k + 1$ 和第二位的 $1$ 恰好贡献了 $2k$，且 $\sum_{i = 1}^n a_{2i} - a_{2i - 1}>0$

而 $\sum_{i = 1}^n a_{2i} - a_{2i - 1}>0$ 成立是因为后面的 $n - 1$ 个偶数位比奇数位大 $1$，$k + 1$ 比 $1$ 大 $k$，$2k \leq n$ 所以 $k \leq n$

这题就这样结束了~

Code:
```cpp
#include <cstdio>

const int maxn = 1e5 + 5;

int n, k;
int a[maxn];

void sov(int x)
{
    printf("%d ", x + 1);
    for(int i = 1; i <= n * 2; ++i)
    {
        if(i != x + 1) printf("%d ", i);
    }
}

int main()
{
    scanf("%d%d", &n, &k);
    sov(k);
    return 0;
}
```

---

## 作者：Ezis (赞：5)

**题目**：

给出整数 $n$, $k$

构造一个长度为 $2 \times n$ 的序列 $a$

满足:
$$\sum_{i=1}^n |a_{2i} -a_{2i-1}| -|\sum_{i=1}^n a_{2i}-a_{2i-1}| = 2k$$

$1≤n≤50000$ , $0≤2k≤n$

**思路**：

首先，发现当 $k=0$ 时，一组符合要求的解为：

$${1,2,3,…,n}$$

那我们能否只改变序列中任意相邻的两组数来使该式符合要求呢?

可以！因为题目里说 $2k≤n$ , 而 $a_{2i}$ 与 $a_{2i+1}$ 每交换一次差都会增加 $2$。

于是，我们就做出了这道题。

时间复杂度 $O(2*n)$

**CODE**:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005];
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=2*n;i++)
		a[i]=i;
	for(int i=1;i<=2*n;i+=2)
		if(k>0)
			swap(a[i],a[i+1]),k--;
	for(int i=1;i<=2*n;i++)
		printf("%d ",a[i]);
	return 0;
} 
```


---

## 作者：dzh_goes_to_thu (赞：3)

## 0.写在前面

本题思路很妙，属于思维题，构造容易想到。本文将要详细讲一讲思维流程。

如果读者嫌本文太长的话，可以直接拉到末尾总结部分。

## 1.题意大致分析

>构造一个长度为 $2n$ 的排列 $A$ ，使得 $\sum_{i=1} ^n |A_{2i}-A_{2i-1}| -|\sum_{i=1} ^n A_{2i}-A_{2i-1}|=2k$ 。

这乍一看确实有点棘手。考虑转化？

设置 $B_i$ 为 $A_{2i}-A_{2i-1}$ ，即求出 $B$ **绝对值的和** 减去  $B$ **和的绝对值？**

显然前半部分 **绝对值的和** 大于等于 **和的绝对值** ，所以不可能取负数。

走到这里就到尽头了？好戏才刚刚开始。

## 2.从特殊情况出发

先判断 $2k=0$ 的情况，毕竟这种情况好一些。

我们观察到如果在每个 $B_i$ 都为**正数**的情况下，那么显然 **绝对值的和=和的绝对值。**

而构造这样一个**递增的序列，答案呼之欲出。直接输出 $1...2n$ 即可，每个 $B_i$ 都等于 $1$ 。**

然而，我们还没处理**一般的情况**。这该如何是好？

因为 $A$ 是一个排列，于是其中的任意交换不会影响排列的性质，于是我们考虑**如何交换**能够刚好构造答案。

我们可以把 $A$ 初始化成 $1...2n$ 。

## 3.走了弯路

当时我考虑**交换相邻两个数** $(A_{2i},A_{2i-1})$，把一个 $B_i$ 从 $1$ 变成 $-1$ 。

对于**整个答案来说**，可以贡献 $2$ 。于是**我当时就考虑交换 $k$ 轮**，这样能保证答案为 $2k$ 。

但是，这个方法**有所问题**。

比如交换太多的数，会导致 $B$ 数组中 $-1$ 的个数太多，这样的话，$B$ 的**绝对值的和**固然是 $n$ ，但是 $B$ **和的绝对值** 会大于 $0$ ！这样就**不能构造正确的答案**了。

从原理上解释，是因为随着交换次数的递增， $B_i$ 的和 $S$ 会递减；但是当 $B_i$ 的和 $S$ 的绝对值会在 $S$ 为负的时候递增。

那么，能不能**增加某一对数的贡献**，避免这种问题呢？换而言之，能不能拉低其中一个 $B_i$ 的绝对值呢？

## 4.走向正解

我们发现一个**显然的性质：如果把一段区间整体挪移一个位置，这段区间对答案的贡献都不变。**

而发生改变的，就是这段区间头和区间头前面的数的贡献。

那么，考虑**拉一个数到前面，计算答案？**

实验实验。比如序列 `1 2 3 4 5 6 7 8` ，把 $3$ 拉到前面，那么这个序列会变成 `3 1 2 4 5 6 7 8` 。

此时我们计算 $B$ 数组，那么 $B$ 数组就变成了 `-2 2 1 1` ，答案变成了 $6-2=4$ 。

如果把 $4$ 拉到前面，这个序列就变成了 `4 1 2 3 5 6 7 8` ，
$B$ 数组即为 `-3 1 1 1` ，答案变成了 $6-0=6$ .

**大胆猜想：把 $k+1$ 拉到前面，会产生 $2k$ 的贡献。**

事实证明，这个是对的。第一个会拉低 $k$ ，有一个地方可能会变成 $2$ （仅限于 $k$ 为偶数），但是答案确实是 $2k$ 。

## 5.总结

可以借助 $B$ 数组做差，辅助推理。

交换不是最终目的，但是是中途历程。

把 $k+1$ 拉到前面就可以产生 $2k$ 的贡献。

```cpp
#include<cstdio>
#define I int
I n,k,i;
I main(){
	scanf("%d%d",&n,&k);
	printf("%d ",k+1);
	for(i=1;i<=n<<1;++i)if(i^(k+1))printf("%d ",i);
	return 0;
}
```

---

## 作者：灯芯糕 (赞：3)

## $solution:$

### 作为一道构造题，这题也十分符合构造的一些通性----（找到一些规律，然后无脑循环）。

### 1. 构造一个长度为 $2n$ 的排列 $a$
### 2. $0≤2k≤n$

### 看到这样两个限制条件，我们想不找出规律都难啊！在自己手推一下真不难发现：

### 将 $a_{2i}$ 和 $a_{2i-1}$ 互换一下，就可让算式的结果+2，而整个式子的结果要等于2∗k，再结合一下上面的第二个限制条件，聪明的Oier，你们应该可以开始码代码了吧。

## $code:$

```cpp
#include<iostream>
using namespace std;
int main(){
	int n,k; cin>>n>>k;
    for(int i=1;i<=n;++i){
        if(k-->0) cout<<i*2<<" "<<i*2-1<<" ";
        else cout<<i*2-1<<" "<<i*2<<" ";
    }return 0;
}

```

---

## 作者：P31pr (赞：2)

还是有点喵喵的一道构造题，思维量不是太大，做题体验很好。

来看一看题目中的这个式子的左边:

$$\sum\limits_{i=1}^n |a_{2i}-a_{2i-1}|-|\sum\limits_{i=1}^n a_{2i}-a_{2i-1}|$$

根据绝对值不等式，我们知道这个式子的值是正的，~~但这并没有什么用~~ 并且这个式子的值与我们构造的排列的奇数项和偶数项密切相关。~~废话~~

~~众所周知~~ 在做构造题的时候如果没有思路可以尝试着给答案加入一些限制条件方便我们思考。当我第一次尝试这么做的时候，我令奇数项是 $1 \sim n$ 的排列，偶数项是 $n+1 \sim 2n$ 的排列，于是惊喜地发现这样构造使得上式恒为零~~，于是我们愉快地做出了 $k=0$ 的情况！~~

换一个尝试的方向，令奇数项都是奇数，偶数项都是偶数，于是我们再次惊喜地发现第二个求和符号的值恒等于 $n$，那么我们要做的就是让第一个求和符号的值等于 $2k+n$。怎么办呢？根据绝对值不等式，要令第一个和号的值最小，我们需要让所有的 $a_{2i}-s_{2i-1}$ 同号，于是我们把 $1 \sim 2n$ 按顺序排，发现第一个和号的值正好等于 $n$。

剩下的 $2k$ 如何通过调整得到？我们把之前的顺序排列这样写出来：

$$\begin{array}{|c|c|}
1&2
\\3&4
\\5&6\\
\vdots&\vdots
\\2n-1&2n 
\end{array}$$

~~借鉴一下样例2~~我们尝试着交换同一列上的相邻两项：

$$ \begin{array}{|c|c|}2m-1&2
m\\2m+1&2m+2\end{array}
\Longrightarrow 
\begin{array}{|c|c|}2m+1&2m\\2m-1&2m+2\end{array}$$

我们惊喜地发现这样交换一次对第一个和号的贡献恰好是 $(3+1)-(1+1)=2$（口算一下就出来了），并且我们最多可以交换 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 次，再一看数据范围是 $0\le 2k\le n$ 即 $0\le k\le \left\lfloor\dfrac{n}{2}\right\rfloor$，也就是说这个构造方案总是可行的。

那我们就愉快地做完了这道题啦~

Code:
```cpp
#include<cstdio>
#define int long long

const int N=5e4+5;
int n,k;
int p[N*2];

void swap(int &x,int &y){int t=x;x=y;y=t;}

signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=2*n;++i)
		p[i]=i;
	for(int i=1;i<=k;++i)
		swap(p[2*i-1],p[2*i+1]);
	for(int i=1;i<=2*n;++i)
		printf("%lld ",p[i]);
	return 0;
}
```


---

## 作者：_Aghost (赞：2)

先考虑k=0，很显然只需要让这个序列是个单增的即可。
*****
 考虑一般情况，比如 1 和 3 如果按3 1排列的话它对后面的式子的贡献就是-2，对前面的式子的贡献就是2 两者相差2*2那么就只需要让第一个数和第二个数的贡献相差2*k,即第第一个数比第二个数大k即可，后面的数只需要构成单增的序列即可。

注意：输出的数不能重复！！
```c
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
int main()
{
	scanf("%d%d",&n,&k);
	if(k==0)
	{
		for(int i=1;i<=2*n;i++)
		printf("%d ",i);
	}
	else
	{
		printf("%d ",k+1);
		for(int i=1;i<=2*n;i++)
		{
			if(i!=k+1)
			printf("%d ",i);
		}
	}
} 	

```


---

## 作者：wmy_goes_to_thu (赞：1)

如果是一个上升序列，则差值为 $0$。所以我们考虑每次做一个操作，使差值加 $2$，做 $k$ 次就可以了！我们发现：可以交换第 $2k-1$ 和 $2k$ 个元素，其中 $k$ 是正整数，这样就可以了！

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[1000005];
int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=(n<<1);i++)p[i]=(n<<1)-i+1;
	for(int i=1;i<=k;i++)swap(p[(i<<1)-1],p[i<<1]);
	for(int i=1;i<2*n;i++)cout<<p[i]<<" ";
	cout<<p[n<<1]<<endl;
	return 0;
}
```

---

## 作者：fzj2007 (赞：0)

构造题。

首先考虑 $k=0$ 的情况。

当 $k=0$ 时，意味着

$$
\sum_{i=1}^n |a_{2i}-a_{2i-1}|=|\sum_{i=1}^n a_{2i}-a_{2i-1}|
$$

即右侧绝对值内部没有消耗，则 $\forall i\in[1,n],a_{2i}-a_{2i-1}$ 同号。

容易构造出一组解为

$$1,2,3,4,5,6,\dots 2n-1,2n$$

考虑将其扩展到 $k\not=0$ 的情况。

由于等式右边是 $2\times k$ 并且 $1\le 2\times k\le n$，我们可以想到对于一组来说，交换两个数会使右侧式子的值减少 $2$，而左侧不变。

那么就可以交换 $k$ 组相邻两项即可。

代码：（快读快写由于太长删去了。）

```
int n,k; 
int main(){
	read(n),read(k);
	for(int i=1;i<=(n<<1);i+=2)
		if(k) put(' ',i+1),put(' ',i),k--;
		else put(' ',i),put(' ',i+1);
	return 0;
}

```

---

## 作者：Aw顿顿 (赞：0)

## 题意

给定 $n,k$，需要构造一个长度为 $2n$ 的排列 $a$ 满足：

$$\sum\limits_{i=1}^n|a_{2i}-a_{2i-1}|-\left|\sum\limits_{i=1}^n a_{2i}-a_{2i-1}\right|=2k$$

## 解法

乍一看，对于这个式子有些没有头绪，那应该从哪里入手呢？

首先考虑读懂这个式子：将相邻两个数两两配对，他们差值绝对值的和，比他们差值和的绝对值，要多 $2k$。

考虑到 $a_{2i}\ge a_{2i-1}$ 的情况下，两边不会有差别，所以我们要让某一个情况下的 $a_{2i}<a_{2i-1}$，那我们考虑如果存在这样的一个数对，他的贡献是多少呢？

是 $2(a_{2i}-a_{2i-1})$。

再观察到原式的右侧，我们现在或许会恍然大悟，为什么右侧的 $k$ 有一个 $2$ 的系数——正是因为我们恰可以构造出这样的一个数对，使他们的差为 $k$，然后便可以构造出满足要求的样例。

来让我告诉你一个注意点：这里要求给出的**排列**是由 $1\sim 2n$ 构成的，因此你不能随便构造（参考英文题面）。那么我们考虑首先输出一对 $(k+1,1)$ 使得贡献为 $2\times (k+1-1)=2k$，然后剩下的按顺序输出就行了，不要重复输出。

考虑 $k=0$ 的特殊情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main(){
	cin>>n>>k;
	cout<<k+1<<' ';
	for(int i=1;i<=n*2;i++)if(i!=k+1)cout<<i<<' ';
	return 0;
}
```

---

## 作者：alvis (赞：0)

这是[题面](https://www.luogu.com.cn/problem/CF359B)。

## 思路

观察题面，发现这两项之间的差别就在于绝对值的位置~~我才不会告诉你我不会打西格玛~~。

那么我们考虑这个绝对值对我们的结果的影响。可以发现，当我们构造出了一个**单调递增**的序列，这两个绝对值对我们的结果是没有影响的（显然结果为 $\text{0}$）。

即一个形如 $\text{x, x+1,x+2}\cdots\text{x+n}$ 的序列最后的结果为 $\text{0}$ 。

容易发现，当我们交换 $\text{i}$ 个相邻的数的位置后，最后的结果就会是 $\text{2}\times\text{i}$。

例如序列 $\text{1,2,3,4,5,6}$。

此时的结果为 $\text{0}$。

当我们交换任意一组相邻的数后，结果就会变为 $\text{2}$。

例如交换 $\text{1}$ 和 $\text{2}$，那么式子的值就变为了$\text{3-1=2}$

这时我们会惊讶的发现，这个结果居然和题目的要求一样！

那么我们就成功的解出了这道题。

时间复杂度大概$\text{O(n+k)}$（~~常数不记~~。

## 代码

```cpp
#include <iostream>
using namespace std;
int main(){
    int n, k;
    int a[500001];
    cin >> n >> k;
    for(int i = 1;i <= 2*n;i ++){
        a[i] = i;
    }
    for(int i = k+1;i > 1;i --){
        swap(a[i], a[i-1]);
    }
    for(int i = 1;i <= 2*n;i ++)cout << a[i] << " ";
    return 0;
}
```


---


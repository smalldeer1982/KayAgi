# Two Semiknights Meet

## 题目描述

一个名叫彼佳的男孩非常喜欢国际象棋。他甚至发明出了一种棋——“半骑士”。半骑士可以在这四个方向中的任何一个方向移动：向右前方2个方格，向左前方2个方格，向左后方2个方格，向右后方2个方格（译注：类似中国象棋中的象），当然，半骑士不能走出棋盘。

彼佳在标准棋盘上放了两个半骑士并同时移动它们。棋盘相当大，所以经过一些移动后半骑士可能相遇，也就是说，它们最终可能会在同一个方格中，这称为一次会面。会面结束后，半骑士们可以继续前进，因此它们有可能再次见面。彼佳认为一些方格不好。也就是说，它们不适合会面。 半骑士们可以穿过这些方格，但他们在这些方格中的会面不计算在内。

彼佳准备了多个国际象棋棋盘。帮助彼佳找出半骑士是否可以在每个棋盘的某个好方格上相遇。

请结合测试数据分析。

## 说明/提示

我们将假设矩阵的行和列从上到下和从左到右编号为1到8。在第一块棋盘中，半骑士们可以在方格（2,7）中相遇。在方格（4,1）的半骑士进入方格（2,3），在方格（8,1）的半骑士进入方格（6,3）。 然后两个半骑士进入（4,5），但这个方格被认为是坏的，所以他们一起移动到方格（2,7）。

在第二块板上，半骑士们将永远不会见面。

## 样例 #1

### 输入

```
2
........
........
......#.
K..##..#
.......#
...##..#
......#.
K.......

........
........
..#.....
..#..#..
..####..
...##...
........
....K#K#
```

### 输出

```
YES
NO
```

# 题解

## 作者：yangjinqian (赞：2)

题目中的“半骑士”就是中国象棋中的象，所以下文就叫象了。

## 题目大意

给出 $n$ 个 $8\times8$ 的棋盘，每个棋盘中有两个象，请问两个象能否在字符非 `#` 的地方相遇。

## 思路

要相遇两个象就要越来越近，我们分情况讨论，设每次两个象的横（纵）坐标差为 $d$，则每次移动有四种情况（$x$ 轴和 $y$ 轴是一样所以只讨论一种）。

- 第一个象往左走，第二个象往左走，则 $d$ 不变。
- 第一个象往左走，第二个象往右走，则 $d$ 加 $4$。
- 第一个象往右走，第二个象往左走，则 $d$ 减 $4$。
- 第一个象往右走，第二个象往右走，则 $d$ 不变。

容易发现，只有第三种情况才能相遇，而每走一次 $d$ 为 $|d-4|$，相遇代表 $d = 0$，也就是若横纵坐标之差都得是 $4$ 的倍数，两个象才能相遇。

### 关于 `#`

题目中写的是这种位置不能**相遇**，没有说象不能走，所以这个东西没用，只是干扰项。

## 代码

```
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
int T, n = 8;
char a[N][N]; 
int main(){
	cin >> T;
	while (T--){
		int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				cin >> a[i][j];
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				if (a[i][j] == 'K')
					if (!x1) x1 = i, y1 = j;
					else x2 = i, y2 = j;
		if (abs(x1 - x2) % 4 == 0 && abs(y1 - y2) % 4 == 0) cout << "YES";
		else cout << "NO";
		cout << endl;
	}
	return 0;
}
```

注意：输出的大小写。

[AC记录](https://codeforces.com/problemset/submission/362/298148550)

---

## 作者：Little_duck_GGG (赞：2)

### 题目意思
这道题意其实就是两个半骑士，在棋盘上**一起走**半骑士的走法和中国象棋的象一样，走田字格。他们两个要会面，但地图上有一些坏格子。它们虽然能走，但是半骑士们不能在上面会面。问半骑士们能否会面。
### 题目思路
因为两个骑士要相遇，所以我们考虑让一个半骑士绕圈，另一个骑士去他的位置。但这么做会有个缺点：如果我的骑士已经到了目标点，但是另一个骑士却正好离开，这种情况也是不能相遇的。也就是说如果**走到目标点的步数为奇数**，那么就不行。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,sx,sy,flag,ex,ey;
char a[105][105];
int dx[4]={2,-2,2,-2};
int dy[4]={2,2,-2,-2};
int v[105][105];
void in_read()
{
	sx=sy=ex=ey=0;//清零 
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='K'&&sx==0)
			{
				sx=i;
				sy=j;
			}
			else if(a[i][j]=='K'&&sx>0) 
			{
				ex=i;
				ey=j; 
			}//找到两个骑士的位置 
		}
	}
}
void dfs(int x,int y,int step)
{
	if(flag==1) return;
	if(x==ex&&y==ey)
	{
		if(step%2==0) flag=1;//如果步数为偶数就可以 
		return;
	}
	for(int i=0;i<4;i++)
	{
		int tx=x+dx[i];
		int ty=y+dy[i];
		if(v[tx][ty]==0&&tx>=1&&tx<=8&&ty>=1&&ty<=8)//搜索 
		{
			v[tx][ty]=1;
			dfs(tx,ty,step+1);
			v[tx][ty]=0;
		}	
	}
}
int main()
{
	cin>>t;
	while(t--)
	{
		in_read();	
		memset(v,0,sizeof(v));//清零 
		flag=0;
		v[sx][sy]=1; 
		dfs(sx,sy,0);
		if(flag==0) cout<<"NO\n";
	    else cout<<"YES\n";
	}
	return 0;
}
```

---

## 作者：qusia_MC (赞：1)

个人觉得评橙比较好。
## 分析
有 $2$ 个只能走“田”的骑士，请问他们能不能在不是坏格子的格子里相遇。
## 思路
首先，我们看一下什么情况是无解的。

以下我们设，两个骑士的 $x$ 坐标之差是 $cx$，$y$ 坐标之差是 $cy$。

很容易发现，如果 $cx$ 或 $cy$ 之一不能被 $4$ 整除，就是无解的，输出 `NO`。

很多人会问了：

- 那么为什么只能被 $4$ 整除呢？其他的数不行吗？？

    解释一下，如果 $cx,cy$ 要相对变化的话，那么就有两种情况：
    
    - 首先，如果两个中要增加的话，没意义，因为本来要相遇，怎么可能~~各奔一方~~向不同方向移动呢？？
    
    - 如果 $cx$ 不变 $cy$ 减小的话则一个骑士向右下移动，另一个向右上移动。（左上，左下也可以）这样的话： $cy\leftarrow cy-4$（一个 $+2$，一个 $-2$，相对减少   $4$）。 
    
    - 如果 $cx$ 减小 $cy$ 不变的话，则一个骑士向左上移动，一个向右上移动（左下和右下也可）。这样的话，$cx\leftarrow cx-4$。（一个 $+2$，一个 $-2$，相对减少   $4$）
    - 如果两个都减小的话，则一个向右上移动，一个向左下（只要是相向移动均可）这样的话 $cy\leftarrow cy-4$，$cx\leftarrow cx-4$。
    
    发现没，增加或减少的全都是 $4$ 的倍数！

    
    **所以，一定能被 $4$ 整除。**

- 请问相遇的如果是坏格子呢？？（保证一定能相遇）
    
    - 没关系啊，因为骑士所在的格子一定是好的，所以，我们可以让一个骑士原地打转转，另一个骑士向这边靠拢，反正这也不是下棋，重复走棋随你便。
## 举例 ##
我们举一个例子吧就看样例。（一个一个看）
第一个：

```
012345678
1 ........
2 ........
3 ......#.
4 K..##..#
5 .......#
6 ...##..#
7 ......#.
8 K.......
```
样例解释不用管他。我们设棋盘坐标如上所示：

两个K的位置分别是 $(4,1),(8,1)$。
由此可以轻松求出 $cx,cy:cx\leftarrow 0，xy\leftarrow 4$。

先判断有没有解：

由于 $4\mid 0$ 且 $4\mid4$，故有解。

然后，我们让一个骑士反复横跳，这里，我们让坐标 $(4,1)$ 得骑士来完成这个“艰巨”的任务（会头晕的）。

我们首先让 $(4,1)$ 的骑士在 $(4,1)$ 和 $(6,3)$ 之间反复横跳。（也就是两个 "\*" 的位置）：
```
012345678
1 ........
2 ........
3 ......#.
4 *..##..#
5 .......#
6 ..*##..#
7 ......#.
8 K.......
```

接着，我们让 $(8,1)$ 的骑士靠近。

以下是两个骑士的运动轨迹：

```
012345678
1 ........
2 ........
3 ......#.
4 K..##..#
5 .↘.....#
6 ...##..#
7 .↗....#.
8 K.......
```
$\downarrow $
```
012345678
1 ........
2 ........
3 ......#.
4 ...##..#
5 .......#
6 ..K(K)##..#
7 ......#.
8 ........
```
接着，我们让两个骑士一起移动到 $(4,1)$。
```
012345678
1 ........
2 ........
3 ......#.
4 ...##..#
5 .↖.....#
6 ..K(K)##..#
7 ......#.
8 ........
```
$\downarrow $

```
012345678
1 ........
2 ........
3 ......#.
4 K(K)..##..#
5 .......#
6 ...##..#
7 ......#.
8 ........
```
成功相遇。输出 ```YES```。

## 代码
~~就知道你们只看这个。~~
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    char ch;
    int x1,y1,x2,y2;
    while(t--)
    {
        x1=x2=y1=y2=-1;bool f=1;
        for(int i=1;i<=8;i++)
        {
            for(int j=1;j<=8;j++)
            {
                cin>>ch;
                if(ch=='K')
                {
                    if(f)//找到K的位置
                    {
                        x1=i;y1=j;
                        f=0;
                    }
                    else
                    {
                        x2=i;y2=j;
                    }
                }
            }
        }
        int cx,cy;
        cx=abs(x2-x1);cy=abs(y2-y1);//计算
        if(cx%4==0&&cy%4==0)cout<<"YES";
        else cout<<"NO";
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：D_14134 (赞：1)

### 题意：

两个K要相会，#格子可以走，不可以做开会地点。 两个K无时无刻都在移动，不可以停留

### 思路：

记录K的位置的奇偶性，存图比对

### code
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int t,x1,x2,yy1,y2,flag;
char s[110];
int main(){
    scanf("%d",&t);
    while(t--){
        flag=false;
        for(int i=0;i<8;i++){
            scanf("%s",s);
            for(int j=0;j<8;j++){
                if(s[j]=='K'){
                    if(!flag){
                        x1=i,yy1=j;
                        flag=true;
                    }
                    else x2=i,y2=j;
                }
            }
        }
        if((abs(x1-x2))%4==0&&(abs(yy1-y2))%4==0) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

---

## 作者：玉树临风英俊潇洒 (赞：0)

# 题目意思
这道题意其实就是两个半骑士在棋盘上一起走田字格。他们要会面，但地图上有一些坏格子。他们虽然**能走**，但是他们**不能**在上面会面。最后问半骑士们能否会面。

# 题目思路
首先不考虑坏点，那么两个象相遇的条件是什么呢？就是两个象的横纵坐标的差为 $4$ 的倍数，那就直接判断即可。

虽然现在有了坏点，但其实是一样的，因为起点一定是好的点，所以不用考虑坏点。

---

## 作者：fg_2ed (赞：0)

# Description

 给定 $t$ 张 8*8 的字符矩阵，其中两个 $K$ 为起点，令两个 $K$ 同时分别向左上、左下、右上、右下移动，判断两个 $K$ 能否在以上规则下，相遇至不为 "$#$" 的位置。

# Solution

首先，起点保证了一定为“好点”，所以不用特判起点。来模拟一下第一个样例：

```cpp
0  1　2　3　4　5　6　7　8

1　.　.　.　.　.　.　.　.

2　.　.　.　.　.　.　.　.

3　.　.　.　.　.　.　#　.

4　K　.　.　#　#　.　.　#

5　. ↘　.　.　.　.　.　#

6　.　.　@　#　#　.　.　#

7　. ↗　.　.　.　.　#　.

8　K　.　.　.　.　.　.　.

```
其中　'@'　为两个$K$相遇的点。

模拟过程中发现$K$在走“田”字型轨迹，即移动前后坐标为($x$ , $y$) ，（$x$ $\pm$ 2 , $y$ $\pm$ 2）。

记录一下$K$ (4,1) ， $K$ (8,1) ，$@$ (6,3) ，可以发现，若两个$K$想相遇，其 $x$ 坐标和 $y$ 坐标之差应被 $4$ 整除。

答案呼之欲出。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int t, tx, ty, mx, my;
char a;
bool flag = true;
int main() {
	cin >> t;
	while (t--) {
		flag = true;
		tx = 0, ty = 0, mx = 0, my = 0; //初始化
		for (int i = 1; i <= 8; i++) {
			for (int j = 1; j <= 8; j++) {
				cin >> a;//读入
				if (a == 'K') {
					if (flag == true) {
						tx = i;
						ty = j;
						flag = false;
					} else {
						mx = i;
						my = j;
					}
				}//记录坐标（即两个K的位置）
			}
		}
		if (abs(tx - mx) % 4 == 0 && abs(ty - my) % 4 == 0)
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
		//按思路判断输出
	}
	return 0;
}

```

---

## 作者：Laoda_Bryant (赞：0)

## 题意
有两个走法为中国象棋象的棋子，棋盘上有一些坏格子，问它们是否可以在好格子相遇。
## 思路
则判断两个棋子是否相遇有两个条件

1. 是否可以在一个格子相遇。
2. 那个格子是否是好格子。

### 先考虑条件 $1$
设第一个棋子的坐标为 $a_x$ 和 $a_y$，第二个棋子的坐标为 $b_x$ 和 $b_y$。  
则在一盘棋中第二个棋子可以走的地方为  
这里设第一个棋子的坐标为 $(1,1)$。
```
0 12345678
1 K...X...
2 ........
3 ..X...X.
4 ........
5 X...X...
6 ........
7 ..X...X.
8 ........
```
那么第二个棋子的坐标就应该在图中标了 $X$ 的位置。  
但是实际会比这个更少。  
把每个格子到第一个棋子的步数进行标记，得
```
0 12345678
1 0...2...
2 .\./.\..
3 ..1...3.
4 ./.\./..
5 2...2...
6 .\./.\..
7 ..3...3.
8 ........
```
奇数格子的棋子下一步到的是偶数格子，偶数格子的棋子的下一步到的是奇数格子，所以要想让两个棋子相遇，则第二个棋子的位置应为偶数标记的格子，就是图中标记为 $2$ 的格子。  
观察图可知，若想使两个棋子都到达同一个位置，那么可得
$$
a_x \equiv\ b_x \ (mod \ 4 ) 
$$
$$
a_y\equiv\ b_y \ (mod \ 4)
$$
化简，得
$$
a_x-b_x \equiv\ 0 \ (mod \ 4 ) 
$$
$$
a_y-b_y \equiv\ 0 \ (mod \ 4 ) 
$$
所以只要判断两个棋子的 $x$ 和 $y$ 坐标相差是否能被 $4$ 整除就行了。
### 再来考虑条件 $2$
题目中说了，两个棋子最开始的位置一定是个好格子，所以只要让一个棋子来回走一个棋子走到了一个棋子的位置即可。所以本条不用考虑。
## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ax,ay,bx,by;
bool first=1;
char ch;
int main(){
	cin>>n;
	while(n--){
		first=1;
		ax=0,ay=0,bx=0,by=0;
		for(int i=1;i<=8;i++){
			for(int j=1;j<=8;j++){
				cin>>ch;
				if(ch=='K'){
					if(first){
						ax=i,ay=j;
						first=0;
					}else{
						bx=i,by=j;
					}
				}
			}
		}
		if((ax-bx)%4||(ay-by)%4) cout<<"NO"<<endl;
		else cout<<"YES"<<endl;
	}
	return 0;
} 
```

---

## 作者：封禁用户 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/CF362A)

# First 题意

首先，题意是说，给你一个 $8 \times 8$ 的地图，有些是坏点，要求两个中国象棋的象能否在棋盘上相遇，且坏点不能作为相遇的点。

# Second 思路

首先不考虑坏点，那么两个象相遇的条件是什么呢？就是两个象的横纵坐标的差为 $4$ 的倍数，那就直接判断即可。

但现在有了坏点，但其实是一样的，因为起点一定是好的点，所以不用考虑坏点。

# Third Code

```cpp
#include <bits/stdc++.h>
using namespace std;
char ch;
int T, ex, ey, sx, sy;
int main(){
	scanf ("%lld", &T);
	while (T--){
		ex = ey = sx = sy = 0;
		for (int i = 1; i <= 8; i++){
			for (int j = 1; j <= 8; j++){
				cin >> ch;
				if (ch == 'K'){
					if (ex) sx = i, sy = j;
					else ex = i, ey = j;
				}
			}
		}
		if ((ex - sx) % 4 == 0 && (ey - sy) % 4 == 0) puts("YES");
		else puts("NO");
	}
	return 0;
}

```

---

## 作者：marshuo (赞：0)

## 题目描述
可知走法为中国象棋中的象的走法
## 解题思路
利用结构体来存储两个 $K$ 的位置 $x,y$ 因为两个 $K$ 同时走，所以会出现两种情况

- 相向而行，两者距离减少。

- 相反而行，两者距离不变。

我们完全可以不考虑格子是好是坏，因为只要有起始位置，起始位置是好的，那么两者就可以在好格子上相遇，所以只需考虑两者的起始位置  $ \left ( x1,y1 \right )$ , $\left ( x2,y2 \right )    $  ,横纵坐标对应都同时可以被 $4$  整除即可。

## 如图

 $ \begin{matrix}
  \#  \#  \#  \#  \#  \#   \\
   \#  \#  \#  \#  \#  \# \\
   \#  \#  \#  \#  \#  \# \\
   \#  \#  \#  \#  \#  \# \\
  \#  \#  \#  \#  \#  \# \\
   \#  \#  \#  \#  \#  \# \\
   \#  \#  \#  \#  \#  \# \\
  K  \#  \#  \# K  \#
\end{matrix} $ 

可以同时跳到上方，其中一个往回跳，另一个往那一个的起始位置跳。

 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
const int N=9;
char g[N][N];
struct node{
	int x,y;
}a[2];//存储坐标
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int k=0;
		for(int i=0;i<8;i++)
			for(int j=0;j<8;j++)cin>>g[i][j];//输入地图
		for(int i=0;i<8;i++)
		{
			for(int j=0;j<8;j++)
			{
				if(g[i][j]=='K')
				{
					a[k].x=i,a[k].y=j;
					k++;//存储横纵坐标
				}
			}
		}
		if((abs(a[0].x-a[1].x)%4!=0)||abs((a[1].y-a[0].y)%4!=0))cout<<"NO"<<endl;
		else cout<<"YES"<<endl;//判断对错
		a[1].x=a[0].x=a[0].y=a[1].y=0;//结构体数组清零
	}
	return 0;
}
 ```






---


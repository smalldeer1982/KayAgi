# Inna and Nine

## 题目描述

### 题目翻译

Inna 特别喜欢数字 $9$，所以她要 Dima 帮她写一个仅由 $9$ 构成的比较小的数。但是 Dima 肯定没有理解她的意思，并且他写了一个由 $1$ 到 $9$ 构成的一个非常大的数。

Inna 想稍微改变一下 Dima 写的数字，最后使这个数字中含有尽量多的数字 $9$。在一步中，Inna 可以选择两个和为 $9$ 并且相邻的数字，并用一个数字 $9$ 来替换掉它们。

比如，Inna 可以这样改变数字 $14545181$：$14545181 → 1945181 → 194519 → 19919$。另外，她还可以用这个方法将 $14545181$ 转化为 $19991$。Inna 并不会把它变成 $149591$ 所以她能得到 $19919$ 和 $19991$ 以包含更多数字 $9$。

## 说明/提示

样例注意事项

第一个样例中，Inna 可以获得以下数字：$369727 → 99727 → 9997$，$369727 → 99727 →9979$。

第二个样例中，Inna 可以这样做：$123456789987654321 → 12396789987654321 → 1239678998769321$。

## 样例 #1

### 输入

```
369727
```

### 输出

```
2
```

## 样例 #2

### 输入

```
123456789987654321
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1
```

### 输出

```
1
```

# 题解

## 作者：RiceFruit (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/CF374B)

# 题意分析

这道题就是给你一个字符串，你可以选出两个相邻且和为 $9$ 的数字，将其变为一个 $9$ ，最后让你求出 $9$ 最多的时候有多少种不同的修改方式。

# 题目思路：

因为知道题目我们只能修改相邻两个数字，所以我们可以定义一种 “ 块 ”。
在这个块内任意相邻两个数字的和都为 $9$ 。

且当块的长度为奇数时，我们称之为奇块，反之则称之为偶块（长度不能为0）

如图（样例一）：

![](https://cdn.luogu.com.cn/upload/image_hosting/2w2fzfqp.png)

其中 $3~6$ 为一个偶块， $7~2~7$ 为一个奇块。

我们先考虑偶块：

多推几组数据可知（此处省略），偶块的第 $2k-1 (k>0)$ 项只能与第 $2k$ 项配对，不能与第 $2k-2$项配对，否则就会少匹配出一个 $9$ 。


如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/371sp9lm.png)

若将中间的 $6~3$ 配对，则会少配对出一个 $9$ .

故偶块的方法数只有 $1$ 。

接下来考虑奇块。

我们可知，因为奇数项比偶数项多 $1$ ，则每次选完肯定会留下一个奇数项。设奇数块的长度为 $2k+1$ ，则奇数项的个数为 $k+1$ 。

故奇块的方法数为 $($ 项数 $+1$ $)$ $/2$

# CODE
我们只要处理出所有偶块和奇块（偶块其实没必要），然后计算答案即可。

注意：此题需要开 long long！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100030;
string s;
long long k[N];//存块的长度 
int n,t;
long long ans=1;
bool as;
int main()
{
	cin>>s;
	n=s.size();s.insert(0,"0");
	s[1]-=48;
	for(int i=2;i<=n;i++){
		s[i]-=48;
		if(s[i]+s[i-1]==9){
			if(!as){
				as=1;
				k[++t]=1;
			}
			k[t]++;
		}
		else{
			as=0;
		}
	}
    
	for(int i=1;i<=t;i++){
		if(k[i]&1)ans=ans*(k[i]/2+1);//若是一个奇块，则累加答案 
	}
	cout<<ans;
	return 0;
}
```
希望管理员大大可以审核通过~

---

## 作者：hexu2010 (赞：1)

# CF374B Inna and Nine 题解

## 题面大意

Inna 特别喜欢数字 $9$，所以她要 Dima 帮她写一个仅由 $9$ 构成的比较小的数。但是 Dima 肯定没有理解她的意思，并且他写了一个由 $1$ 到 $9$ 构成的一个非常大的数。

Inna 想稍微改变一下 Dima 写的数字，最后使这个数字中含有尽量多的数字 $9$。在一步中，Inna 可以选择两个和为 $9$ 并且相邻的数字，并用一个数字 $9$ 来替换掉它们。

比如，Inna 可以这样改变数字 $14545181$：$14545181 → 1945181 → 194519 → 19919$。另外，她还可以用这个方法将 $14545181$ 转化为 $19991$。Inna 并不会把它变成 $149591$ 所以她能得到 $19919$ 和 $19991$ 以包含更多数字 $9$。你要求的是变成这种状态（$9$ 的个数最多）的方案数。

## 分析

### step 1: 发现规律

我们可以先从几个例子中发现规律：

$123456367$。我们有两种方法：一个是 $1239967$，一个是 $1239697$。

$1234545$。我们只有一种方法：$12399$。

因此，我们可以想到把这个字符串分成几个部分，使得每个部分的相邻两个数都可以合并为 $9$。

所以，第一步：**将字符串分成若干个部分**。这样我们将每个部分的方案数相乘就是答案。

### step 2: 分类讨论

我们来分类讨论每个部分的情况：

#### i.只有一个数

对于这种情况，肯定是不能合并的，所以对方案数**没有任何影响**，不用管它。

#### ii.有偶数个数

我们要两两配对，所以只能是第一个和第二个配，第三个和第四个配，……。所以只有一种方案，我们也不用管它。

#### iii.有奇数个数

这种情况貌似有点复杂。我们可以用几个例子发现规律。

$18181$。我们有三种方法：$991$，$919$ 和 $199$。

$1818181$。我们有四种方法：$9991$，$9919$，$9199$ 和 $1999$。

$181818181$。我们有五种方法：$99991$，$99919$，$99199$，$91999$ 和 $19999$。

你似乎已经发现了规律：对于长为 $x$ 的部分，他有 $\frac{x+1}{2}$ 种方案。其实他可以证明出来：

假设总共有 $2n+1$ 个数，那么可以产生 $n$ 个 $9$ 。剩余的一个 $1$ 就是在 $n$ 个 $9$ 中间插入。总共有 $n+1$ 个空位，所以有 $n+1$ 种方法。因为 $2(n+1)-1=2n+1$，所以计算方案数时就是 $[(2n+1)+1]\div2=n+1$。放到一般的例子中，就是 $(n+1)\div2$，即 $\frac{n+1}{2}$。

到这里，就结束了。

## 算法流程

![](https://cdn.luogu.com.cn/upload/image_hosting/l7392hyz.png)

洛谷为什么不能用 mermaid 流程图啊！

---

## 作者：CrazyEagle (赞：0)

这里提供一种 DP 做法。毕竟这种东西太容易让人联想到 DP 了。

定义：$f_{i,0}$ 表示“考虑到第 $i$ 位，不合并第 $i$ 与第 $i-1$ 个数字可以得到的最多的 $9$ 的个数”；

$g_{i,0}$ 表示“考虑到第 $i$ 位，不合并第 $i$ 与第 $i-1$ 个数字，得到 $f_{i,0}$ 个 $9$ 的方案数”；

$f_{i,1}$ 与 $g_{i,1}$ 则是合并第 $i$ 与第 $i-1$ 个数字的情况。当然，如果不能合并（加起来不是 $9$），那么 $g_{i,1}=0$。

初始化：如果第 $1$ 个数字为 $9$，那么 $f_{1,0}=1$，否则 $f_{1,0}=0$；$g_{0,0}=g_{1,0}=1$，其它都初始化为 $0$。

状态转移：从 $2$ 开始遍历。如果第 $i$ 个数字与第 $i-1$ 个数字之和为 $9$ 才转移 $f_{i,1}$ 与 $g_{i,1}$：
$$
f_{i,1}=\max(f_{i-2,0},f_{i-2,1})+1\\
g_{i,1}=\begin{cases}
g_{i-2,0},&\text{if } f_{i-2,0}>f_{i-2,1}\\
g_{i-2,1},&\text{if } f_{i-2,0}<f_{i-2,1}\\
g_{i-2,0}+g_{i-2,1},&\text{if } f_{i-2,0}=f_{i-2,1}
\end{cases}
$$
然后是 $f_{i,0}$ 与 $g_{i,0}$，记输入的字符串为 $s$，下标从 $1$ 开始记录：
$$
f_{i,0}=\begin{cases}
\max(f_{i-1,0},f_{i-1,1})+1,&\text{if }s_i=9\\
\max(f_{i-1,0},f_{i-1,1}),&\text{otherwise}
\end{cases}\\
g_{i,0}=\begin{cases}
g_{i-1,0},&\text{if } f_{i-1,0}>f_{i-1,1}\\
g_{i-1,1},&\text{if } f_{i-1,0}<f_{i-1,1}\\
g_{i-1,0}+g_{i-1,1},&\text{if } f_{i-1,0}=f_{i-1,1}
\end{cases}
$$
依此实现即可。

```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
char s[100005];
int f[100005][2],g[100005][2];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>(s+1);
	int n=strlen(s+1);
	g[0][0]=1;
	g[1][0]=1;
	if(s[1]=='9')
		f[1][0]=1;
	for(int i=2;i<=n;++i)
	{
		if(s[i]-'0'+s[i-1]-'0'==9)
		{
			f[i][1]=max(f[i-2][0],f[i-2][1])+1;
			if(f[i-2][0]>f[i-2][1])
				g[i][1]=g[i-2][0];
			else if(f[i-2][0]<f[i-2][1])
				g[i][1]=g[i-2][1];
			else
				g[i][1]=g[i-2][0]+g[i-2][1];
		}
		f[i][0]=max(f[i-1][0],f[i-1][1]);
		if(f[i-1][0]>f[i-1][1])
			g[i][0]=g[i-1][0];
		else if(f[i-1][0]<f[i-1][1])
			g[i][0]=g[i-1][1];
		else
			g[i][0]=g[i-1][0]+g[i-1][1];
		if(s[i]=='9')
			++f[i][0];
	}
	if(f[n][0]==f[n][1]) 
		cout<<g[n][0]+g[n][1];
	else if(f[n][0]>f[n][1])
		cout<<g[n][0];
	else
		cout<<g[n][1];
}
```

---


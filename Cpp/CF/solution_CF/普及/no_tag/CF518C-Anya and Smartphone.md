# Anya and Smartphone

## 题目描述

安雅购买了一只带有Berdroid操作系统的智能手机。智能手机菜单中有n个应用，每个应用程序都有其自己的图标。每个应用的图标都在相应的屏幕上，一个屏幕包含ķ个图标。第1个应用到第k个应用的图标位于第一个屏幕上，从第（k + 1）个至第2k个应用在第二个屏幕上，依次类推（最后屏幕可以是部分为空） 。
 
开始的时候，智能手机显示的屏幕是第一个屏幕，为了去启动第t个屏幕上的应用，安雅需要做如下的手势：首先是连续切换屏幕t-1次，其次是点击第t个屏幕上的那个应用程序。
 
在应用程序启动以后，屏幕会重新返回到第1个屏幕。也就是说，如果你要启动下一个程序，必须又要重头来过。
 
所有应用程序的编号是从1到n。我们知道所有屏幕中每个应用程序的位置。但是Berdroid是智能系统，他会根据用户实际的使用情况，自动把使用次数最多的应用放到最前面。变化规则是这样的，当一个应用程序启动以后，系统会自动的将该程序的图标位置和他前面的那个应用程序的图标互换位置（可能会导致图标不在原来的屏幕上）。当然了，如果那个被启动的应用程序已经在第一个位置上了，就不需要再更换位置了。
 
如果你已经知道安雅启动某些应用程序的顺序，请你来计算他需要多个手势（切换一个屏幕或者点击一个应用程序图标都算作一次手势）来完成这些任务。
 
注意，一个应用可以发起多次。

## 说明/提示

在第一个样例中的起始位置是（123）（456）（78），也就是，在第一个屏幕包含应用程序1，2，3的图标，第二个屏幕包含图标4，5，6，第三个屏幕包含图标7,8。
 
应用7启动后，我们得到新的图标位置-（123）（457）（68）。这过程需要3次手势。
 
应用8被启动后，我们得到的位置（123）（457）（86），要启动它安雅需要使用3次手势。
 
应用1启动后，图标菜单中的排列没有变化，要启动它安雅需要1次手势。
 
所以说，总共需要3+3+1=7次手势。

## 样例 #1

### 输入

```
8 3 3
1 2 3 4 5 6 7 8
7 8 1
```

### 输出

```
7
```

## 样例 #2

### 输入

```
5 4 2
3 1 5 2 4
4 4 4 4
```

### 输出

```
8
```

# 题解

## 作者：xuan_gong_dong (赞：1)

## 题面
[Anya and Smartphone](https://www.luogu.com.cn/problem/CF518C)
## 分析
用两个数组，第一个数组 $a_i$ 表示在 $i$ 这个位置上的是谁，$id_i$ 表示 $i$ 这个人在那个位置，显然这两个数组是相互映射的。

初始输入的就是 $a$ 数组，顺带记录一下 $id_i$（这是第一个循坏）。

直接让 $ans$ 加上询问点 $x$ 的屏幕序号，就是 $\lfloor \frac{id_i-1}{k} \rfloor$，注意这里位置 $id_i$ 要 $-1$。

然后如果当前位置不为 $1$ 的话那和前面的位置交换一下就好了。

注意要开 $\texttt{long long}$！

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int id[100010],a[100010];
int n,m,k;
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		id[a[i]]=i;
	}
	int ans=0;
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%lld",&x);
		ans+=((id[x]-1)/k)+1;
		if(id[x]!=1)
		{
			id[a[id[x]-1]]++;
			id[x]--;
			swap(a[id[x]],a[id[x]+1]);			
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：zym20249_ (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/CF518C)

## 题意
有 $n$ 个应用程序，编号从 $1$ 到 $n$，屏幕上有 $k$ 个图标。首先滚动到所需的屏幕号，需要做 $t−1$ 次操作，然后再用一次操作，按下所需应用程序的图标以启动它。应用程序启动后，菜单自动返回到第 $1$ 号屏幕，即要启动下一个应用程序，需要再次从第 $1$ 号屏幕开始操作。应用程序启动后，系统会将该应用程序的图标位置与前一个应用程序的图标位置交换，请你确定需要多少次操作才能完成全部应用程序的启动。

## 思路
这题需要用到映射，不然可能会出现 TLE 的情况。
>映射是指两个及以上元素对应的关系。两个非空集合 $A$ 与 $B$ 间存在着对应关系 $f$，而且对于 $A$ 中的每一个元素，$B$ 中总有唯一的一个元素与它对应，就这种对应为从 $A$ 到 $B$ 的映射。

因为第 $i$ 程序在第 $a$ 个屏幕的运行需要花的时间刚好为 $a$，因为把页面挪动到他所在的那一页需要换 $a-1$ 的时间，后又打开程序又花了 $1$ 的时间，所以总共就是 $a$ 的时间，中途交换时需要用到 $\operatorname{swap}$ 函数，这个函数的作用是指交换里面参数的位置。这里需要注意他是否在一个页面的第一个程序，如果是要往前挪动。注意一下这题需要开 long long。

## code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e5+10;
ll n,m,k,sum,t,x,i,a[maxn],b[maxn];
int main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);//输入
		b[a[i]]=i; 
	}
	for(i=1;i<=m;i++)
	{
		scanf("%lld",&x);
		if(b[x]%k==0)sum+=b[x]/k;
		else sum+=(b[x]/k)+1;
		if(b[x]!=1)
		{
			t=b[x];
			swap(a[t-1],a[t]);//交换位置
			swap(b[a[t-1]],b[a[t]]);
		}
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：wuzijie (赞：0)

## 题面解释：
有 $n$ 个应用，每次启动一个应用会与前一个交换位置，问你需要操作几次。

## 思路分析：
暴力的做法，$m$ 次启动，每次从头到尾扫一遍去找应用。

但这样很浪费时间，所以我们用一个数组来映射应用的位置。

启动的同时，也需要更改，那么我们就需要知道每个位置对应的应用，所以同样再开一个数组映射。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,m,k,x,ans,u[N],v[N];
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%lld",&v[i]),u[v[i]]=i;
	while(m--){
		scanf("%lld",&x);
		ans+=((u[x]-1)/k)+1;
		if(u[x]!=1)
			u[v[u[x]-1]]++,u[x]--，
			swap(v[u[x]],v[u[x]+1]);
	}
	printf("%lld\n",ans);
	return 0;
}
```

谢谢！

---

## 作者：WaterSky (赞：0)

# [CF518C Anya and Smartphone。](https://www.luogu.com.cn/problem/CF518C)

## 算法：
这道题我们可以用模拟来完成。

开一个数组，将每一个位置的图标编号记录下来，也就是映射，这样我们就可以做到 $O(1)$ 查询。

然后我们再做每一个操作，共有 $M$ 个操作，时间复杂度为 $O(M)$。

## 代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,b,P,r;
long long A[1000005],B[1000005];
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;++i)
		cin>>A[i],B[A[i]]=i; //映射。
	for(int i=1;i<=m;i++){
		cin>>b,P=B[b],r+=(P-1)/k+1; //模拟：计算点击图标需要做的手势次数。
		if(P!=1) B[A[P]]--,B[A[P-1]]++,swap(A[P],A[P-1]); //模拟：交换。
	}
	cout<<r;
	return 0;
}
```

## 总结：
总的来说，这道题第一眼看着好复杂，可是如果仔细阅读下去会发现很简单，这类题能够锻炼编程基本功。

---

## 作者：damage (赞：0)

~~怎么会有如此厚颜无耻的手机~~

# 题解

### 直接膜你

对于每次要打开的应用程序~~比如B站~~，暴力搜一遍找到它的位置，然后直接按题意膜你即可。

可以发现每次操作的最坏复杂度就是搜一遍的$O(n)$，而总共有$m$个操作，复杂度总共为$O(nm)$，所以对于$10^{5}$的数据来说会超时。

于是我们想到了直接映射即可，用一个数组```id[i]```记录编号为$i$的应用程序的位置（注意这里不是第几个屏幕）

对于每一个操作，要打开编号为$b$的应用程序，有以下步骤：

1. 定义```pos=id[b]```，表示该应用程序的编号

2. ```res+=(pos-1)/k+1```，```(pos-1)/k)```就是求滑到该应用程序所在屏幕所需的步数，然后```+1```就表示打开这个应用程序~~开始颓废~~。

3. ```--id[a[pos]]``` ```++id[a[pos-1]]```。```a[pos]```表示这个应用程序的编号(注意不能直接用```b```，然后```--```就表示往前调。第二步往后调也是同样的原理。注意应用程序在第一个的话就不要调了。

4. 然后交换```a[pos]```和```a[pos-1]```的值即可，其实就是交换它和它前面的应用程序的编号。我用的是位运算交换，其实和朴素交换方法的没什么两样。

最后输出结果```res```即可。

### 注意```res```要开$long\ long$，因为$(10^{5})^{2}$比$MAX\_INT$要大

---

# 代码

```cpp
#include<stdio.h>
int n,m,k,a[100010],id[100010],b,pos,temp;
long long res; //注意long long
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(register int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
		id[a[i]]=i; //记录编号对应的位置
	}
	while(m--)
	{
		scanf("%d",&b);
		pos=id[b]; //获取pos
		res+=(pos-1)/k+1; //更新答案res
		if(pos==1) continue; //如果应用程序在第一个就不用调了
		--id[a[pos]]; //交换他们的编号对应的位置映射
		++id[a[pos-1]];
		a[pos]^=a[pos-1]; //位运算交换应用程序的编号，其实和朴素交换方法的没什么两样。
		a[pos-1]^=a[pos];
		a[pos]^=a[pos-1];
	}
	printf("%lld\n",res);
}
```

---


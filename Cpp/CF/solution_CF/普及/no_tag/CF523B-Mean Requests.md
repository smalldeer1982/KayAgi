# Mean Requests

## 题目描述

本题源于 VK 社交网络使用的实际算法问题。

与其他高负载网站一样，VK 的开发人员定期处理请求统计。一个重要的负载指标是某个时间段内（例如 $T=60$ 秒即 1 分钟，或 $T=86400$ 秒即 1 天）的平均请求数。当这个值严重下降时，可能表示网站访问存在问题；而当这个值上升时，可能需要分析增长原因，并在必要时增加服务器。

但是，在处理大型社交网络的海量数据时，计算一个时间段内的平均请求数也面临挑战。因此，开发人员采用了一些创新技术，既能接近真实值，又能提升效率。

我们考虑以下模型。假设服务运行了 $n$ 秒。我们已知在每个时间点 $t$（$1 \le t \le n$）对该资源的请求数 $a_t$。定义一个利用指数衰减的平均数计算算法，设 $c$ 为大于 1 的实数。

```cpp
// 正确设置常数 c 可以调整所统计的时间范围
double c = <某个常数>;

// 该变量将保存当前时刻前 T 秒内的平均请求数
double mean = 0.0;

for t = 1..n: // 每秒进行如下操作：
    // $a_t$ 是这一秒的请求数
    mean = (mean + $a_t$ / T) / c;
```

如此，每秒都会根据当前秒的请求数更新 `mean` 变量。通过适当选择常数 $c$，可使 `mean` 的值接近于 $t-T+1 \le x \le t$ 之间的真实平均值 $a_x$。

这种方法的优点在于只需当前时刻的请求数，无需保存长时间的历史请求。同时，它给较新的数据更高权重，有助于快速应对数据剧变。

在工业编程中采用新理论方法前，必须在给定测试集上验证其实际可信度。你的任务是将近似算法结果与真实数据进行比较。

你会收到 $n$ 个值 $a_t$，整数 $T$ 和实数 $c$。此外，还给定 $m$ 个时刻 $p_j$（$1 \le j \le m$），我们关注的是过去 $T$ 秒的平均请求数。实现两个算法：一个按定义计算所需值，即通过公式
$$
\text{real} = \frac{1}{T} \sum_{x=t-T+1}^{t} a_x
$$
另一个按上述方法计算均值。输出这两个值，并通过公式
$$
\text{error} = \left| \frac{\text{approx} - \text{real}}{\text{real}} \right|
$$
计算第二个算法的相对误差，其中 $\text{approx}$ 是第二个算法的近似值，$\text{real}$ 是第一个算法的真实值。

## 样例 #1

### 输入

```
1 1 2.000000
1
1
1
```

### 输出

```
1.000000 0.500000 0.500000
```

## 样例 #2

### 输入

```
11 4 1.250000
9 11 7 5 15 6 6 6 6 6 6
8
4 5 6 7 8 9 10 11
```

### 输出

```
8.000000 4.449600 0.443800
9.500000 6.559680 0.309507
8.250000 6.447744 0.218455
8.000000 6.358195 0.205226
8.250000 6.286556 0.237993
6.000000 6.229245 0.038207
6.000000 6.183396 0.030566
6.000000 6.146717 0.024453
```

## 样例 #3

### 输入

```
13 4 1.250000
3 3 3 3 3 20 3 3 3 3 3 3 3
10
4 5 6 7 8 9 10 11 12 13
```

### 输出

```
3.000000 1.771200 0.409600
3.000000 2.016960 0.327680
7.250000 5.613568 0.225715
7.250000 5.090854 0.297813
7.250000 4.672684 0.355492
7.250000 4.338147 0.401635
3.000000 4.070517 0.356839
3.000000 3.856414 0.285471
3.000000 3.685131 0.228377
3.000000 3.548105 0.182702
```

# 题解

## 作者：andyli (赞：1)

根据题意模拟，分别计算 $real, approx, error$。如果时间大于 $T$ 秒，则删去 $T$ 秒前的数据。  

```cpp
int main() {
    dR(int, n, T);
    dR(ld, c);
    dRV(int, a, n);
    dR(int, m);
    vi b(n);
    _for (m)
        b[io.read<int>() - 1] = 1;
    ld approx{};
    i64 sum = 0;
    _for (i, n) {
        approx = (approx + ld(a[i]) / T) / c;
        sum += a[i];
        if (i >= T)
            sum -= a[i - T];
        ld real = ld(sum) / T;
        if (b[i]) {
            ld error = std::fabs(approx - real) / real;
            writeln({real, approx, error});
        }
    }
    return 0;
}
```

---


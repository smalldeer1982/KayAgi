# A Trivial Problem

## 题目描述

圣塔先生要求世界上所有伟大的程序员解决一个小问题。他给了他们一个整数m，并要求正整数n的个数当n的阶乘恰好以m个0结束。您是能够解决这个问题的优秀程序员之一吗?

## 样例 #1

### 输入

```
1
```

### 输出

```
5
5 6 7 8 9 ```

## 样例 #2

### 输入

```
5
```

### 输出

```
0```

# 题解

## 作者：0606x (赞：2)

一段理解起来特别容易的代码 （目前来看是最短的)
## 思路
由于末尾0的个数就是阶乘中分解出10的个数，也就是分解出2的个数与5的个数中的最小值；

显然5的个数小于2的个数，即找出分解出的5的个数。

**比较容易推出：当 $n$ 为 $5^{k}$ 的倍数时，其阶乘分解出 $5$ 的个数即为 $n-1$ 的阶乘分解出的 $5$ 的个数 $+k$ 。**

**由此还可以得出另一个重要结论：若找得到，则输出的数的个数必定为 $5$ 个。**

这两个结论都对解题有很大帮助。（不很理解的可以看样例分析）

## 样例分析
末尾$0$个数为$1$的数，当找到$5$时，$t$的值更新为$1$，接下来的数末尾都为$1$个$0$。

当找到$10$时，$t$的值更新为$2$，接下来的数末尾$0$的个数就不为$1$了，结束。

因此输入$1$时，输出$5,6,7,8,9$共$5$个。

当找到$24$时，$t=4$，接下来为$25$，$t=t+2=6$，因此没有末尾$0$为$5$的数，输出$0$。

数据较小，可以暴力循环。
用一个变量存储当前分解出5的个数，直接往下找就行。

其他的各种细节都在注释里了。

## $Here's$ $the$ $AC$ $code.$
```cpp
#include<bits/stdc++.h>//万能头.
using namespace std;
int main(){
    int m,t=0;//t存储的是当前能被分解出来的5的个数.
    bool ok=0;//判断是否找到t使得t=m.
    scanf("%d",&m);//输入.
    for(int i=1;i<=5000001;i++){
        int j=i;
        while(j%5==0){
            t++;
            j/=5;
        }//分解出5.
        if(!ok&&t==m) cout<<"5\n";//找到了且未输出i就输出5.
        if(t==m){
            ok=1;
            cout<<i<<" ";
        }//输出符合要求的i.
        if(ok&&t!=m) return 0;//如果找完了就结束. 
    }
    cout<<0;//未找到就输出0.
    return 0;//结束.
}//求审核通过~
```
祝早日AC！

---

## 作者：Trafford1894 (赞：2)

## 这是一道纯数学题。
$Problem$

输入的唯一一行包含一个整数$m (1<=m<=100000)$代表阶乘中所需的尾随零的数量，让你求正整数$n$的个数当$n!$恰好以$m$个$0$结束。

$Solution$

$10 = 2 * 5$

假设$n!$中有$x$个2，有$y$个5，则$m = min(x, y)$.

又因为$y<x$，所以我们要求$y$.

这可以用一段递归程序来实现：

```cpp
//what: calculate the end 0 in num!
int Check (int num) {
	if (num == 0)  {
		return 0;
	}
	
	return num / 5 + Check(num / 5);
}
```

求完这个以后，我们只要看$n!$是否恰好以$m$个0结束就行了。

------------

上代码：
```cpp


#include <iostream>
#include <vector>
#include <cstring>
#define int long long

using namespace std;
int _num;

vector<int> _myList;
int _size = 0;

//what: calculate the end 0 in num!
int Check (int num) {
	if (num == 0)  {
		return 0;
	}
	
	return num / 5 + Check(num / 5);
}

void CParseIn () {
	cin >> _num;
}

void Core () {
	//cin >> _num;
	//cout << "{";
	
	//int cc = 0;
	
	for (int i = 0; i < 1000000; i++) {
		if (Check(i) > 100000) {
			break;
		}
		
		if (Check(i) == _num) {
			//cout << i << ",";
			//cc = Check(i);
			//cout << 5 << endl;
			
			for (int j = 0; j < 5; j++) {
				_myList.push_back(i + j);
			}
			
			_size = _myList.size();
			return;
		}
	}
	
	_size = 0;
}

void CWriteOut () {
	cout << _size << endl;
	
	if (_size == 0) {
		return;
	}
	
	for (int i = 0; i < _size; i++) {
		cout << _myList[i] << " ";
	}
	
	cout << endl;
}

signed main () {
	
	CParseIn();
	Core();
	CWriteOut();
	
	return 0;
}
```


---

## 作者：huangxuyang (赞：1)

## 思路

这题数据较小，可以暴力循环。 用一个变量存储当前分解出 $5$ 的个数，直接往下找就行。

末尾 $0$ 的个数就是阶乘中分解出 $10$ 的个数，也就是分解出 $ 2$ 的个数与  $5$ 的个数中的最小值。

显然 $5$ 的个数小于 $2$ 的个数，所以找出分解出的 $5$ 的个数。

所以可推出：当 $n$ 为 $5^{k} $
  的倍数时，其阶乘分解出 $ 5 $ 的个数即为 $n-1$ 的阶乘分解出的 $ 5 $ 的个数 $ +k $ 。
所以还可以得出一个重要结论：若找得到，则输出的数的个数一定为 $5$ 个。

这两个结论都对解题有巨大帮助。（可以看样例分析）

## 样例分析
末尾 $0$ 个数为 $11$ 的数，当找到 $5$ 时，$t$b的值更新为 $1$ ，接下来的数末尾都为   $1$ 个0。

当找到 $10$ 时，$t$ 的值更新为 $2$ ，接下来的数末尾 $0$ 的个数就不为 $1$ 了，结束。

因此输入 $1$ 时，输出 $5,6,7,8,95,6,7,8,9$ 共 $5$ 个。

当找到 $24$ 时，$t$ = $4$ ，接下来为 $25$ ，$t=t+2=6$，因此没有末尾 $ 0 $ 为 $ 5 $ 的数，输出 $0$ 。

## 代码

 ```
#include<bits/stdc++.h>
using namespace std;
int m,t;//t是当前能被分解出来的5的个数
bool b;//累加是否找到t使得t=m
int main(){
   scanf("%d",&m);
   for(int i=1;i<=500000;i++)
   {
        int j=i;
        while(j%5==0)t++,j/=5;//分解出有几个5
        if(!b&&t==m)cout<<5<<endl;//找到了且没有输出i就输出5，换行 
        if(t==m){b=1;cout<<i<<" ";}//输出符合要求的i
        if(b&&t!=m)return 0;//找完了就结束
    }
    cout<<0;//一直未找到就不会结束，最后输出0
    return 0;//完美结束！
}
```
### 求通过！！！

---

## 作者：Linune_Gump (赞：1)

# 题解CF633B

## 思路
其实思路还是很显然的。

### 不妨引理：
问阶乘之后末尾有多少 $0$ ，就是问有多少个因数 $5$ .

解释如下：
不管如何，阶乘末尾的 $0$ 一定由 $2$ 和 $5$ 相乘得到。
而 $2$ 的个数一定比 $5$ 多。
因此末尾 $0$ 的个数取决于因数 $5$ 的个数。

### 再引理
这些数据一定是连续的

解释如下：
比如 $5! = 5 \times 4 \times 3 \times2 \times 1$ 有 $1$ 个 $5$   
$6! = 6 \times 5 \times 4 \times 3 \times 2 \times 1$ 有 $1$ 个 $5$  
...  
$10! = 10 \times 9 \times 8 \times 7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1$ 有 $2$ 个 $5$

因此 $5$ 是 $1$ 个 $0$ 最少的情况， $10$ 是 $2$ 个 $0$ 少的情况。

输出就是
```
5  
5 6 7 8 9
```

因此，我们可以用二分的方法分别枚举 $n-1$ 个 $0$ 最多的情况和 $n$ 个 $0$ 最多的情况，就可以得到答案。

## 代码
```
#include <bits/stdc++.h>
using namespace std;

int n;

int get(int x) // 判断这个阶乘
{
	int ans = 0;
	for(int i = 1; i <= x; i++)
	{
		int j = i;
		while(j % 5 == 0)
		{
			ans++;
			j /= 5;
		}
	}
	return ans;
}
int b_find(int l, int r, int aim)
{
	int mid, best = -1;
	while(l <= r)
	{
		mid = (l + r) >> 1;
		if(get(mid) <= aim)
		{
			best = mid;
			l = mid + 1;
		}
		else r = mid - 1;
	}
	return best;
}
int main()
{
	scanf("%d", &n);
	int l = b_find(1, 5000000, n - 1);
	int r = b_find(l, 5000000, n);
	printf("%d\n", r - l);
	for(int i = l + 1; i <= r; i++) printf("%d ", i);
	printf("\n");
	return 0;
}
```

---

## 作者：__Allen_123__ (赞：0)

## 题意

给定一个整数 $m$，计算有多少个满足条件的 $n$，使得 $n!$ 有 $m$ 个后导 $0$。

## 思路

这道题目数据范围较小，只有 $100$ 万，可以暴力枚举每一个阶乘来做。

$10 = 2 \times 5$，所以想要得到一个后导 $0$ 就需要既是 $2$ 的倍数又是 $5$ 的倍数。

在阶乘中 $2$ 因子的数量肯定比 $5$ 的多，所以我们只需要看 $5$ 因子的数量即可。

这里我们可以得出两个结论，等一下会证明：

- $k!$ 的后导 $0$ 的个数等于 $(k - 1)!$ 的后导 $0$ 的个数加上 $k$ 中的因子 $5$ 的个数。
- 只要有解，则满足条件的数量一定为 $5$ 个。

先来证明第一个结论：

因为 $n!$ 相当于 $(n - 1) \times n$，所以 $(n - 1)$ 的后导 $0$ 的个数对于 $n!$ 是不变的。我们之前已经说过，在阶乘中 $2$ 因子的数量肯定比 $5$ 的多，所以我们只需要看 $5$ 因子的数量即可。**特别注意：如果一个数中出现了多个 $5$ 因子，后导 $0$ 的个数就会增加多个。** 例如 $25$ 有两个 $5$ 因子，所以 $25!$ 的后导 $0$ 个数与 $24!$ 的后导 $0$ 个数相比就会增加两个。得证。

再来证明第二个结论：

我们之前提到过，我们只需要看 $5$ 因子的数量，那么只有到达 $5$ 的倍数时，后导 $0$ 的个数才会增加。

举个例子：$5, 6, 7, 8, 9$，只有 $5$ 是 $5$ 的倍数，其他都不是，所以这五个数的阶乘的后导 $0$ 个数是一样的。而到了 $10!$ 之后，后导 $0$ 的个数又增加了（因为 $10$ 也是 $5$ 的倍数），所以 $10$ 之后的阶乘后导 $0$ 个数也不可能会与这五个数的阶乘后导 $0$ 个数相同。大家还可以举几个例子尝试一下。

这两个结论对解题都有很大帮助。

## 方法：

我们可以先分解出每个数的因子 $5$ 的数量，然后再判断累积的因子 $5$ 的数量是否达到 $m$，若达到并且是第一次达到，输出 $5$，换行，然后如果达到，输出这个数。为了节省时间，只要累积因子数超过了 $m$，那么就立刻结束程序，因为数越大，后导 $0$ 的个数就会越多。

最后，如果无解，输出 $0$，结束程序。

其他的小细节都在注释里。

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
// m 即题目中的 m，cnt 指累积后导 0 的个数，flag 用来记录是否第一次找到
int m, cnt = 0, x, flag = 1;
int main(){
    scanf("%d", &m);
    for(int i = 1;i <= 500005;i++){
        x = i; // 用 x 来保存 i 的值
        while(x % 5 == 0){ // 分解出因子 5 的个数
            cnt++; // 这里的 cnt 在之前不需要清零，因为后导 0 的个数只会变多
            x /= 5;
        }
        if(cnt == m){ // 判断 i 的阶乘后导 0 的个数是否达到了 m
            if(flag){ // 如果第一次找到，输出解的个数 5，换行
                printf("5\n");
                flag = 0;
            }
            printf("%d ", i);
        }
        if(cnt > m){ // 后导 0 个数超过了 m，立刻结束程序
            return 0;
        }
    }
    printf("0"); // 若无解，输出 0
    return 0; // 结束
}
```

---

## 作者：I_AK_IOI_and_NOI (赞：0)

## 题目大意

给定一个 $m$，让你求一个 $n$ 使得 $n!$ 末尾刚好有 $m$ 个 $0$。

## 题目分析

首先我们知道，一个数末尾有几个零说明这个数可以被 $10$ 整除几次。

因为 $10=2 \times 5$，并且 $2$ 的个数大于 $5$ 的个数所以我们只要求出 $n!$ 中有几个 $5$ 因数就可以了。

根据公式，在 $n!$ 中包含质因数 $p$ 的个数为：

$$

\lfloor \frac{n}{p^1} \rfloor + \lfloor \frac{n}{p^2} \rfloor+\lfloor \frac{n}{p^3} \rfloor+\lfloor \frac{n}{p^4} \rfloor+...  (p^k\le n)

$$

把公式带到本题当中：尾随 $0$ 的个数为： $\sum_{i=1}^{\lfloor \log_5{n}\rfloor}\lfloor\frac{n}{5^i}\rfloor$。


易得：当 $n=5^k$ 那么尾随的 $0$ 的个数为：
$\frac{n-1}{4} $，
于是我们就可以利用这一性质解决这题。

同时可以发现只要不是无解，那么输出个数必定为 $5$ 个，毕竟每 $5$ 个数才会多一个质因子 $5$。

```
#include<bits/stdc++.h>
using namespace std;
int a[8]={5,25,125,625,3125,15625,78125,390625}; //把5的平方、立方、四次方……都先打在一张表中 
int m,p,_m,cnt=7,n;
//_m来备份m 
//cnt先来枚举a的下标，后来计算因子5的个数 
int main()
{
	cin>>m;
	_m=m;
	while(m!=0)
	{
		if(m>=(a[cnt]-1)/4) //刚才说的 
		{
			m-=(a[cnt]-1)/4;
			n+=a[cnt]; 
		}
		else cnt--; //不够减就往前一个下标 
	}
	p=n; //n用来输出，验算时用p代替
	cnt=0; //i来存储当前因数5的个数 （也就是尾随0的个数） 
	while(p!=0) 
	{
		p/=5; //按照刚才的公式计算因数5的个数 
		cnt+=p;
	}
	if(cnt!=_m) cout<<"0";//与实际情况不相符
	else //有解 
	{
		cout<<"5"<<endl<<n<<" "<<n+1<<" "<<n+2<<" "<<n+3<<" "<<n+4; //把5个数都输出来 
	} 
}
```


---

## 作者：AzureMist (赞：0)

因为只有 $2$ 和 $5$ 相乘才会产生 $0$，而阶乘的时候明显带有因数 $5$ 的数更少，所以我们不难发现，对于一个正整数 $n$，它的阶乘尾随 $0$ 的个数为
$\sum_{i=1}^{\lfloor \log_{5}{n}\rfloor}\lfloor\frac{n}{5^i}\rfloor$。当 $n=5^k$($k$ 为非负整数)时，$n!$ 尾随 $0$ 的个数就是 $\frac{n-1}{4}$，于是我们就可以利用这一性质。
```cpp
#include<bits/stdc++.h>
using namespace std;
int sub[7]={5,25,125,625,3125,15625,78125};
int main()
{
	int m,p,q,i=6,n=0;
	cin>>m;
	q=m;
	while(m!=0)
	{
		if(m>=(sub[i]-1)/4) m-=(sub[i]-1)/4,n+=sub[i];
		else i--;
	}
	p=n,i=0;
	while(p!=0) p/=5,i+=p;
	if(i!=q) cout<<"0";
	else cout<<"5"<<endl<<n<<" "<<n+1<<" "<<n+2<<" "<<n+3<<" "<<n+4;
	return 0;
} 
```
一顿操作猛如虎，一看结果……第57个点错了？
后来我发现，其实能否放进 $sub$ 数组里取决于 $\frac{n-1}{4}$ 而不是 $n$ ，所以输入 $100000$ 时就会出错。
```cpp
#include<bits/stdc++.h>
using namespace std;
int sub[8]={5,25,125,625,3125,15625,78125,390625};//(390625-1)/4=97656,这是可以的
int main()
{
	int m,p,q,i=7,n=0;
	cin>>m;
	q=m;//提前备份，不然一会没了
	while(m!=0)
	{
		if(m>=(sub[i]-1)/4) m-=(sub[i]-1)/4,n+=sub[i];
		else i--;//不够减就退而求其次
	}
	p=n,i=0;//n用来输出，验算时用p代替
	while(p!=0) p/=5,i+=p;
	if(i!=q) cout<<"0";//与实际情况不相符
	else cout<<"5"<<endl<<n<<" "<<n+1<<" "<<n+2<<" "<<n+3<<" "<<n+4;
	return 0;
} 
```
鸣谢：阮晞^-^梦(QQ:3042818338,Luogu:731996)，她最先提出了这个问题，如果没有她的 $\frac{n}{4}$ 猜想，就不会引发我们班的人去思考这个问题，也就不可能有这篇题解。

---

## 作者：xiaogao (赞：0)

### 暴力+二分——做法通俗易懂
我是这样想的：

首先，题目中只要求到阶乘后100000个零。数据不大，可以考虑打表。

由于在450000个数中查找区间会很浪费时间，所以可以考虑二分查找。

下面只需要把区间内的数，即符合要求的n输出即可。

在此说一句：此题暴力打表并不会超时，如果配合适当的优化，跑得还是挺快的。

步骤如下：
- 把0~450000的阶乘末尾的0的个数存储到a数组里。
- 二分查找以m个0结尾的阶乘。
- 输出符合要求的n。

#### [在这里，我们可能会用到两个函数，大家可以到我的Blog里看看。（请点击）](https://www.luogu.com.cn/blog/xiaogaoblog/er-fen)
### The code can be written like this…
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <list>
#include <map>
using namespace std;
int a[550000];  //定义a数组。
int main()
{
	int i, n;
	cin >> n; //阶乘末尾0的个数。
	for(i = 0; i < 450000; i++)  //把0~450000的阶乘末尾的0的个数存储到a数组里。
	{
		int t = 0 ,t1 = i;
		while(t1 != 0)
		{
			t += t1 / 5;
			t1 = t1 / 5;
		}
		a[i] = t;
	}
	int t1 = lower_bound(a, a+450000, n)-a;  //返回指向大于等于n的第一个值的位置。
	int t2 = upper_bound(a, a+450000, n)-a;  //返回指向大于n的第一个值的位置。
	if(t1 == t2) //如果没找到……
	{
		cout << 0 << endl;
		return 0;
	}
	cout << t2-t1 << endl; //输出结果。
	for(i = t1; i < t2; i++)
		cout << i << " ";
	cout << endl;
	return 0;	
} 
```
希望能帮到大家，bye~

---


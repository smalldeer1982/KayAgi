# Draw Brackets!

## 题目描述

### 题目翻译 ：
在方括号序列中插入符号“+”和“1”，如果从中获得规则的数学表达式，就可以称方括号序列为规则的。例如，序列“[ [ ] ] [ ]”、“[ ]”和“[ [ ] [ [ ] ] ]”--是规则的，同时“] [”、“[ [ ]”和“[ [ ] ] ] [”—是不规则的。    

应使用最小伪图形在尽可能低的元素的高度上绘制给定的序列—使用符号“+”、“-”和“|”。例如，序列“[ [ ] [ ] ] [ ]”应该表示为: [图片](https://cdn.luogu.com.cn/upload/image_hosting/8gilah2t.png)    

**注意**：这里的括号应该用一个或多个符号“|”（垂直部分）和符号“+”和“-”表示，如上面给出的示例所示。    

应该连续地绘制没有空格的括号，且只使用单个空格条分割成对的连续括号（这样两个括号就不会看上去合为一个符号）。应保证图像在元素上应具有尽可能小的高度。   

此中，封闭的括号总是比周围的括号小，但每个括号都应该单独使图像的元素的高度最大化。因此，上面例子中的最后一对括号占据了图像的整个高度。    

请仔细阅读下面的例子，它们充分解释了问题的情况。注意这个问题的答案（也就是图像）是独一无二的。

## 样例 #1

### 输入

```
8
[[][]][]
```

### 输出

```
+-        -++- -+
|+- -++- -+||   |
||   ||   |||   |
|+- -++- -+||   |
+-        -++- -+
```

## 样例 #2

### 输入

```
6
[[[]]]
```

### 输出

```
+-     -+
|+-   -+|
||+- -+||
|||   |||
||+- -+||
|+-   -+|
+-     -+
```

## 样例 #3

### 输入

```
6
[[][]]
```

### 输出

```
+-        -+
|+- -++- -+|
||   ||   ||
|+- -++- -+|
+-        -+
```

## 样例 #4

### 输入

```
2
[]
```

### 输出

```
+- -+
|   |
+- -+
```

## 样例 #5

### 输入

```
4
[][]
```

### 输出

```
+- -++- -+
|   ||   |
+- -++- -+
```

# 题解

## 作者：WA_sir (赞：1)

## [题目](https://codeforces.com/contest/770/problem/D)|[链接](https://www.luogu.com.cn/problem/CF770D)

### 题目大意

给出一串由中括号 "```[```" 和 "```]```" 组成的字符串，要求你用字符画的形式表现出来。

### 题目分析

模拟即可。可以考虑四种情况，即：

||$1$|$2$|$3$|$4$|
|:---:|:---:|:---:|:---:|:---:|
|**前一字符**|$[$|$[$|$]$|$]$|
|**当前字符**|$[$|$]$|$[$|$]$|

只需分别讨论每种情况即可。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,e[105],ma=-114514,ma_=-1919810,lie=1,hang;
//hang,lie 是对中括号的标记点坐标
char s[105],a[505][505];
int main()
{
	scanf("%d%s",&n,s);
	e[0]=1;
	for(int i=1,j=1;i<n;ma=max(ma,e[i++]))e[i]=s[i]=='['?(s[i-1]=='['?++j:j):(s[i-1]=='['?j:--j);
	for(int i=0;i<n;i++)e[i]=(ma-e[i])*2+1,ma_=max(ma_,e[i]);
	a[0][0]=a[e[0]+1][0]='+';a[0][1]=a[e[0]+1][1]='-';
	for(int i=1;i<=e[0];i++)a[i][0]='|';
	for(int i=1;i<n;i++)
		if(s[i-1]=='[')
		{
			if(s[i]=='[')
			{
				a[hang+1][lie]=a[hang+e[i-1]][lie]='+';
				a[hang+1][lie+1]=a[hang+e[i-1]][lie+1]='-';
				for(int j=hang+2;j<=hang+1+e[i];j++)a[j][lie]='|';
				hang++;
				lie++;
			}
			else
			{
				a[hang][lie+2]=a[hang+e[i]+1][lie+2]='-';
				a[hang][lie+3]=a[hang+e[i]+1][lie+3]='+';
				for(int j=hang+1;j<=hang+e[i];j++)a[j][lie+3]='|';
				lie+=3;
			}
		}
		else
		{
			if(s[i]=='[')
			{
				a[hang][lie+1]=a[hang+e[i]+1][lie+1]='+';
				a[hang][lie+2]=a[hang+e[i]+1][lie+2]='-';
				for(int j=hang+1;j<=hang+e[i];j++)a[j][lie+1]='|';
				lie+=2;
			}
			else
			{
				a[hang-1][lie]=a[hang+e[i]][lie]='-';
				a[hang-1][lie+1]=a[hang+e[i]][lie+1]='+';
				for(int j=hang;j<=hang+e[i]-1;j++)a[j][lie+1]='|';
				hang--;
				lie++;
			}
		}
	for(int i=0;i<ma_+2;i++,putchar('\n'))
		for(int j=0;j<=lie;j++)
			printf("%c",a[i][j]-'+'&&a[i][j]-'-'&&a[i][j]-'|'?' ':a[i][j]);
	return 0;
}
```

感谢您的阅读。

---

## 作者：OJ_killer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF770D)

模拟好（nan）题

+ **思路**

观察样例，不难看出这些括号都是上下对称的所以先输出上面一半然后再对称输出就完成了。

难点就是如何把**上半部分**输出。

通过观察可以看出两个加号有两种情况:

第一种是两个相邻。

第二种是两个括号间有一或多层的嵌套。

当有两个括号的时候两个加号相隔最近相隔 3。

然后处理完上半部分，然后上下对称输出。然后上下之间连接两个加号之间的就是竖线了。

以上是完成打印的大致思路，详见代码。

+ code
```cpp
#include <bits/stdc++.h>
using namespace std;

char a[100100], ans[110][310];
int n, w, h, d;//初始化

int main() {
	scanf("%d%s", &n, a);
	for (int i = 0; i < n; i++) {//字符串下标从0开始
		if (a[i] == '[') {
			ans[d][w] = '+';
			ans[d][w + 1] = '-';
			d++, w++;
		} else {
			d--;
			if (a[i - 1] == '[')//如果为右括号说明出现了两个加号相邻的情况
				w += 3;
			ans[d][w] = '+';
			ans[d][w - 1] = '-';
			w++;
		}
		h = max(h, d);
	}
	for (int i = h + 1; i <= 2 * h; i++)
		for (int j = 0; j < w; j++)
			ans[i][j] = ans[2 * h - i][j];
	for (int j = 0; j < w; j++) {
		for (int i = 0, f = 0; i <= 2 * h; i++) {
			if (ans[i][j] == '+')
				f ^= 1;
			else if (!ans[i][j])
				ans[i][j] = " |"[f];
		}
	}
	for (int i = 0; i <= 2 * h; i++)//处理下半部分
		printf("%s\n", ans[i]);
	return 0;
}

---


# Road Widening

## 题目描述

$S$ 市市长讨厌树木和草坪。他们占用了如此多的空间，而且他们占用的地方可能有一条路！市长认为，若拆除没有人需要的草坪，城市的一条街道可能会大大拓宽。此外，这可能有助于减少街上发生的交通堵塞。街道从左至右分为 $ n $ 个部分，每个部分由两个整数表示：道路宽度 $ s_i $ 与 草坪 $ g_i $ 的宽度。
 
市长需要拆除一部分草坪来拓宽道路。对于长度为 $ g_i $ 的草坪，你可以将它拆除 $ x_i $ ( $ x_i $ $ \le $ $ g_i $ ).同时，道路的宽度 $ s_i $ 加上 $ x_i $。

一方面，市长希望拆除尽可能多的草坪（并用道路代替）。另一方面，他不想造成道路快速加宽或变窄，从而导致车祸。为了避免这种情况，市长决定连续路段的道路宽度最多相差1。

你需要找到市长应拆除的草坪长度，并输出拆除这个长度后，每条道路的宽度。

## 说明/提示

$ 1<=n<=2·10^{5} $ 

$ 1<=s_{i}<=10^{6} $ 

$ 0<=g_{i}<=10^{6} $

## 样例 #1

### 样例输入 #1

```
3
4 5
4 5
4 10
```

### 样例输出 #1

```
16
9 9 10
```

## 样例 #2

### 样例输入 #2

```
4
1 100
100 1
1 100
100 1
```

### 样例输出 #2

```
202
101 101 101 101
```

## 样例 #3

### 样例输入 #3

```
3
1 1
100 100
1 1
```

### 样例输出 #3

```
-1
```

## 样例 #1

### 输入

```
3
4 5
4 5
4 10
```

### 输出

```
16
9 9 10 
```

## 样例 #2

### 输入

```
4
1 100
100 1
1 100
100 1
```

### 输出

```
202
101 101 101 101 
```

## 样例 #3

### 输入

```
3
1 1
100 100
1 1
```

### 输出

```
-1
```

# 题解

## 作者：_hi_ (赞：4)

记一个数组 $s2$ 表示一个部分在割草后道路的**最大**宽度。要注意，$s2_i$ 的初始值是第  $i$  个部分的总宽度，是因为要先令能把所有草都拆掉。

然后扫 $s2$ 数组，因为题目规定相邻两部分的道路段度之差不大于一，且要求最宽，所以
 $s2_i = \min(s_i+g_i,\min(s2(i+1)+1,s2(i-1)+1))$。

即 $=$ 本部分的总宽度和上部分的道宽 $+1$ 与下部分的道宽 $+1$ 中最小的那个。

注意，如果 $s2_i < s_i$ 那说明需要把路铲了，不符合要求直接输出 $-1$。

你以为扫一遍就结束了？事情没那么简单
相信聪明的你已经找出反例了，很简单。

输入：

    3
    
    0 100

    0 50

    0 25


输出：

    102
    51 26 25

答案：

    78
    27 26 25

这个小样例就轻松 hack 掉了。

再观察 hack 样例，可以发现只正着扫一遍导致部分二的道宽被道宽更小的部分三又刷新了一次，最终只完成了从二到三没办法从一走到二，必须要再改部分一的道宽才行。

于是思路偏唐的我想到一直循环这个操作，这样经过一些玄学操作和化学反应之后，如果操作次数够多，答案是能保证正确的。

但如果数据够毒瘤复杂度应该是 $O(n^2)$ 的，超时了。

最后一步简单到惊掉你的上巴，既然正着扫骗过了程序，那就再倒着扫一遍不就行了！！
也就是从 $n$ 到 $1$ 再跑一遍就行了。


解释：如果你深入思考了，就可以发现，在正着扫的时候，如果右边的道宽 $<$ 这部分的道宽，$<$ 左边的道宽（各部分的差都大于 $1$），就会出现 hack 样例的问题，所以就可以考虑反着扫一遍，让它的上一步道宽小于下一步道宽，就把问题解决了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,s[1000006],g[1000006],s2[1000006],sum;//s2表示修改后的道路宽度 
int main(){
	scanf("%lld",&n);
	s2[0]=s2[n+1]=0x3f3f3f3f3f3f3f3f;//保证不影响第1部分与第n部分，附极大值 
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&s[i],&g[i]);
		s2[i]=s[i]+g[i];//初始化为本段的最大宽度 
	}	
	for(int i=1;i<=n;i++){
		s2[i]=min(s[i]+g[i],min(s2[i-1]+1,s2[i+1]+1));
		if(s2[i]<s[i]){//如果需要把路拆了 
			printf("-1");
			return 0;
		} 
	}
	for(int i=n;i>=1;i--){//同上 
		s2[i]=min(s[i]+g[i],min(s2[i-1]+1,s2[i+1]+1));
		if(s2[i]<s[i]){
			printf("-1");
			return 0;
		} 
	}
	for(int i=1;i<=n;i++)sum+=s2[i]-s[i]; 
	printf("%lld\n",sum);
	for(int i=1;i<=n;i++){
		printf("%lld ",s2[i]);
	}
	return 0;
} 
```

---

## 作者：erok (赞：1)

## 题目描述
 $S$ 市市长讨厌树木和草坪。他们占用了如此多的空间，而且他们占用的地方可能有一条路！市长认为，若拆除没有人需要的草坪，城市的一条街道可能会大大拓宽。此外，这可能有助于减少街上发生的交通堵塞。街道从左至右分为 $ n $ 个部分，每个部分由两个整数表示：道路宽度 $ s_i $ 与 草坪 $ g_i $ 的宽度。
 
市长需要拆除一部分草坪来拓宽道路。对于长度为 $ g_i $ 的草坪，你可以将它拆除 $ x_i $ ( $ x_i $ $ \le $ $ g_i $ ).同时，道路的宽度 $ s_i $ 加上 $ x_i $。

一方面，市长希望拆除尽可能多的草坪（并用道路代替）。另一方面，他不想造成道路快速加宽或变窄，从而导致车祸。为了避免这种情况，市长决定连续路段的道路宽度最多相差 1 。

你需要找到市长应拆除的草坪长度，并输出拆除这个长度后，每条道路的宽度。
## 思路
首先可以找到每条道路的最大宽度。由题意可知 $ s'_i $ 最大值为 道路长加草坪长。又由于“连续路段的道路宽度最多相差 1 。” 那么 我们从头到尾，再从尾到头遍历一遍道路，若它的宽度比相邻道路大，并且相差超过 1 时，将它的长度修改为相邻道路 $ + 1 $ 即可。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define o() printf(" ")
#define in(x) scanf("%lld",&x)
#define out(x) printf("%lld",x)
const int maxn=2e5+10;
using namespace std;
int n;
int ans;
int f[maxn];
int s[maxn],g[maxn];
signed main() {
	in(n);
	for(int i=1; i<=n; i++) {
		in(s[i]);
		in(g[i]);
	}
	f[1]=s[1]+g[1];
	for(int i=2; i<=n; i++)
		f[i]=min(f[i-1]+1,s[i]+g[i]);//从头到尾
	for(int i=n-1; i>=1; i--)
		f[i]=min(f[i+1]+1,f[i]);//从尾到头
	ans=0;
	for(int i=1;i<=n;i++) {
		ans+=f[i]-s[i];
		if(f[i]<s[i]) {
			puts("-1");
			return 0;//当一条道路满足限制条件时比原道路还窄，则无解。
		}
	}
	out(ans);
	puts("");
	for(int i=1; i<=n; i++) {
		out(f[i]);
		o();
	}
	return 0;
}
```




---

## 作者：灵茶山艾府 (赞：1)

每个位置的最大值为 $\textit{mx}_i=s_i+g_i$。由于题目要求 $|\textit{mx}_{i+1}-\textit{mx}_i|\le1$，我们需要将该限制从左到右传递一遍，然后再从右到左传递一遍。

传递完毕后所有位置的最大值就满足了 $|\textit{mx}_{i+1}-\textit{mx}_i|\le1$。

AC 代码：（Golang）

```go
package main

import (
	"bufio"
	. "fmt"
	. "os"
)

func main() {
	in := bufio.NewReader(Stdin)
	out := bufio.NewWriter(Stdout)
	defer out.Flush()

	var n int
	Fscan(in, &n)
	mx := make([]int, n)
	s := make([]int, n)
	for i := range mx {
		Fscan(in, &s[i], &mx[i])
		mx[i] += s[i]
		if i > 0 && mx[i-1]+1 < mx[i] {
			mx[i] = mx[i-1] + 1
		}
	}
	ans := int64(0)
	for i := n - 1; i >= 0; i-- {
		if i < n-1 && mx[i+1]+1 < mx[i] {
			mx[i] = mx[i+1] + 1
		}
		if mx[i] < s[i] {
			Print(-1)
			return
		}
		ans += int64(mx[i] - s[i])
	}
	Fprintln(out, ans)
	for _, v := range mx {
		Fprint(out, v, " ")
	}
}
```

---


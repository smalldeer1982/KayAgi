# Useful Decomposition

## 题目描述

### 【题目大意】：

`Ramesses`了解了很多跟树（就是`OI`里的树）相关的知识。

现在，`Ramesses`发明了一种树的分解，不过他还不知道如何去分解一棵树，所以您需要帮他分解。

所谓`树的分解`，就是把树分解成好几条链，使得每条边都**在且仅在**一条链上，而且任意两条链都有**至少一个**公共点。

请您帮助`Ramesses`，找到一种可行的`树的分解`或确定无解。

-------------------------------

## 样例 #1

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
Yes
1
1 4
```

## 样例 #2

### 输入

```
6
1 2
2 3
3 4
2 5
3 6
```

### 输出

```
No
```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
1 5
```

### 输出

```
Yes
4
1 2
1 3
1 4
1 5
```

# 题解

## 作者：mraymes (赞：6)

题目说要把一棵树给分成多条路线, 每条路线都是**不能分叉的**，也就是说路的两端度数为 $ 1 $, 其他的点度数为 $ 2 $.

因为是一棵树, 所以如果要求任意两条路线至少有一个公共点, 到最后, 所有的路线都会有唯一的公共点. 如果有两个公共点的话, 就至少有两条路线只包含其中的一条路线, 否则就会有环, 有了环就不是树了.

也就是说, 所有的点, **除了那个唯一的公共点,** 必须度数小于 $ 2 $.

在所有点之中:
- 度数为 $ 1 $ 的点是路线的一个端点.
- 度数为 $ 2 $ 的是一条路线中除了两端以外的点.
- 度数大于 $ 2 $ 的是路线的公共点. 如果有两个及以上的点的度数是大于 $ 2 $ 的, 代表不可能路线中任意两条至少交于一点, 输出 `No`.
- 如果没有度数大于 $ 2 $ 的点, 代表只有一条路线.

如何输出路线:
- 先输出 `Yes`, 代表可以将树分解.
- 接着输出路线的个数, 也就是度数为 $ 1 $ 的点的个数.
- 接着, 对于每条路线, 输出其中一个度数为 $ 1 $ 的点和 **唯一的** 公共点.
- **注意: 如果没有度数大于 $ 2 $ 的点, 代表只有一条路线, 此时路线个数并不等于度数为 $ 1 $ 的点的个数, 并且端点就是两个度数为 $ 1 $ 的点.**

↓↓↓具体见代码↓↓↓
```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
int deg[100005]; // 每个点的度数
int leaves[100005], comv[100005]; // leaves 存储度数为 1 的端点, comv 存储公共点
int nleaf = 0, ncomv = 0; // 存储度数为 1 的点与公共点的数量

int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++)
	{
		int v1, v2;
		scanf("%d%d", &v1, &v2);
		deg[v1]++, deg[v2]++;
	}

	for (int i = 1; i <= n; i++)
	{
		if (deg[i] == 1) leaves[++nleaf] = i;
		else if (deg[i] > 2) comv[++ncomv] = i;
	}

	if (ncomv > 1) { printf("No\n"); exit(0); } // 如果公共点不唯一, 就输出 "No"

	printf("Yes\n");
	if (ncomv == 0) printf("1\n%d %d\n", leaves[1], leaves[2]);
    // 如果只有一条路线, 就输出两端 (即两个度数为 1 的点)
	else
	{
		printf("%d\n", nleaf); // 度数为 1 的点的个数
		for (int i = 1; i <= nleaf; i++) printf("%d %d\n", leaves[i], comv[1]);
        // 一个度数为 1 的点与公共点
	}

	return 0;
}
```


---


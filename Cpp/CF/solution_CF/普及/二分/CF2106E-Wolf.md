# Wolf

## 题目描述

狼发现了 $n$ 只羊，它们的可口度分别为 $p_1, p_2, ..., p_n$，其中 $p$ 是一个排列$^{\text{∗}}$。狼想在 $p$ 上使用二分查找来寻找可口度为 $k$ 的羊，但 $p$ 可能并未排序。对于区间 $[l, r]$ 上寻找 $k$ 的二分查找是否成功，用 $f(l, r, k)$ 表示，其定义如下：

如果 $l > r$，则 $f(l, r, k)$ 失败。否则，令 $m = \lfloor\frac{l + r}{2}\rfloor$，然后：

- 如果 $p_m = k$，则 $f(l, r, k)$ 成功；
- 如果 $p_m < k$，则 $f(l, r, k) = f(m+1, r, k)$；
- 如果 $p_m > k$，则 $f(l, r, k) = f(l, m-1, k)$。

书呆子牛决定帮助狼。书呆子牛会收到 $q$ 个查询，每个查询包含三个整数 $l$、$r$ 和 $k$。在开始查找之前，书呆子牛可以选择一个非负整数 $d$ 和 $d$ 个下标 $1 \le i_1 < i_2 < \ldots < i_d \le n$，其中对于所有 $1 \leq j \leq d$ 都有 $p_{i_j} \neq k$。然后，他可以随意重新排列元素 $p_{i_1}, p_{i_2}, ..., p_{i_d}$。

对于每个查询，输出书呆子牛需要选择的最小整数 $d$，使得 $f(l, r, k)$ 能够成功，或者报告这是不可能的。注意，查询是独立的，且实际的重新排列不会被执行。

$^{\text{∗}}$ 长度为 $n$ 的排列是指包含从 $1$ 到 $n$ 的所有整数且每个整数恰好出现一次的数组。

## 说明/提示

在第一个样例的第二个查询中：由于 $4$ 不存在于前三个元素中，因此在该范围内查找 $4$ 是不可能的。

在第二个样例的第一个查询中，可以选择下标 $2$ 和 $3$，并交换它们，使得 $p = [3, 5, 1, 2, 7, 6, 4]$。然后，$f(3, 4, 2)$ 的执行过程如下：

1. 令 $m = \lfloor \frac{3 + 4}{2} \rfloor = 3$。因为 $p_3 = 1 < 2$，所以 $f(3, 4, 2) = f(4, 4, 2)$。
2. 令 $m = \lfloor \frac{4 + 4}{2} \rfloor = 4$。因为 $p_4 = 2 = k$，所以 $f(4, 4, 2)$ 成功，因此 $f(3, 4, 2)$ 也成功。

总共选择了 $2$ 个下标，因此最终的成本是 $2$，可以证明这是最小的。注意，对于这个查询，不能选择下标 $4$，因为 $p_4 = k = 2$。

在第二个样例的最后一个查询中，可以选择下标 $2, 3, 4, 5$ 并重新排列它们，使得 $p = [3, 5, 2, 7, 1, 6, 4]$。然后，$f(1, 7, 3)$ 成功。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
8
5 3
1 2 3 4 5
1 5 4
1 3 4
3 4 4
7 4
3 1 5 2 7 6 4
3 4 2
2 3 5
1 5 6
1 7 3
2 1
2 1
1 2 1
1 1
1
1 1 1
7 1
3 4 2 5 7 1 6
1 7 1
16 1
16 10 12 6 13 9 14 3 8 11 15 2 7 1 5 4
1 16 4
16 1
14 1 3 15 4 5 6 16 7 8 9 10 11 12 13 2
1 16 14
13 1
12 13 10 9 8 4 11 5 7 6 2 1 3
1 13 2```

### 输出

```
0 -1 0 
2 0 -1 4 
-1 
0 
-1 
-1 
-1 
-1```

# 题解

## 作者：Collapsarr (赞：5)

# CF2106E Wolf 题解

### 翻译

小狼找到了 $n$ 只美味值分别为 $p_1,p_2,...p_n$ 的羊，其中 $p$ 是一个排列，小狼想对 $p$ 进行二分查找，来找到那只美味度为 $k$ 的绵羊，但 $p$ 不一定有序，而小狼在 $[l,r]$ 范围内对 $k$ 进行二分查找表示为 $f(l,r,k)$，其定义如下：

如果 $l\gt r$，则 $f(l,r,k)$ 失败，否则，设 $m=\lfloor\frac{l+r}{2}\rfloor$，并且：

- 如果 $p_m=k$，则 $f(l,r,k)$ 成功。
- 如果 $p_m<k$，则 $f(l,r,k)\gets f(m+1,r,k)$。
- 如果 $p_m>k$，则 $f(l,r,k)\gets f(l,m-1,k)$。

小牛决定帮助小狼，小狼会问小牛 $q$ 次，每个询问会由三个整数 $l,r,k$ 组成，在小狼开始搜索之前，小牛可以选择一个非负整数 $d$ 和 $d$ 个索引 $i_1,i_2...i_d$，需要保证 $1\le i_1\lt i_2 \lt ... \lt i_d \le n$ 且 $i_j\not= k$，然后小牛可以对 $p_{i_1},p_{i_2},...,p_{i_d}$ 任意排序。
对于每个询问，小牛必须输出的最小整数一个 $d$ 并且保证 $f(l,r,k)$ 可以成功，如果不可以，输出 $-1$，请注意，这些询问是独立的，实际上并没有执行重新排序。

### 解题思路

~~赛时被硬控，二分寄。~~

首先对每个数找到其所在的位置，因为 $k$ 的位置无法被改变，所以每次二分的时候的路径是一定的，所以只需要记录在二分路径上的每一个数的和 $k$ 大小关系，找到有多少个数需要被替换成大于或小于 $k$ 的数，最后和可以被替换的数的个数比较，判下无解，而最后的答案中，我们应尽可能的保留原数，所以我们可以先把路径上的数彼此替换掉，然后在从外面换数，即为最优解。

~~我绝对不会告诉你赛场写寄是因为认为有 $k$ 个数比 $k$ 小。~~

### code

赛时代码：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define intt __int128

int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while(ch<'0'||'9'<ch)
	{
		if(ch=='-')
		{
			f = -1;
		}
		ch = getchar();
	}
	while('0'<=ch&&ch<='9')
	{
		x = (x<<3) + (x<<1) + ch - '0';
		ch = getchar();
	}
	return x * f;
}

const int inf = 1e18,N = 2e5 + 10;

int n,q,it[N],a[N];

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T = read();
	while(T--)
	{
		int l,r,k,cnt,sum,cntt,summ;
		n = read(),q = read();
		for(int i = 1;i<=n;i++)
		{
			a[i] = read();
			it[a[i]] = i;
		}
		while(q--)
		{
			l = read(),r = read(),k = read();
			cnt = sum = cntt = summ = 0;
			if(it[k]<l||it[k]>r)
			{
				cout<<-1<<endl;
				continue;
			}
			while(l<=r)
			{
				int mid = (l+r)>>1;
				if(a[mid]==k)
				{
					break;
				}
				if(mid<it[k])
				{
					l = mid + 1;
					if(a[mid]>k)
					{
						cntt++;
					}
					cnt++;
				}
				else
				{
					r = mid - 1;
					if(a[mid]<k)
					{
						summ++;
					}
					sum++;
				}
			}
			if(cnt>k-1||sum>n-k)
			{
				cout<<-1<<endl;
			}
			else
			{
				cout<<max(summ,cntt)*2<<endl;
			}
		}
	}
	return 0;
}
```

---


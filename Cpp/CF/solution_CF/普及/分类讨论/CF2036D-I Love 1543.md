# I Love 1543

## 题目描述

一天早晨，Polycarp 醒来后意识到 $1543$ 是他一生中最喜欢的数字。

那天他睁开眼睛看到的第一件事，就是一块大小为 $n \times m$ 的大地毯，其中 $n$ 和 $m$ 都是偶数。每个格子里都包含一个 $0$ 到 $9$ 的数字。

Polycarp 很好奇，在顺时针遍历地毯的所有“层”时，数字 $1543$ 会出现多少次。

“层”$^{\text{∗}}$ 的定义如下：对于一个 $n \times m$ 的地毯，第一层是指包围地毯外部的、厚度为 $1$ 的闭合带，其长度为 $2 \cdot (n+m-2)$。每一层之后的层，都是在去掉所有之前的层后，对剩下的地毯取第一层。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2036D/997bfe25a98d4cf2f508d78ff1490796ddf33705.png) 图中展示了第七个样例中 $1543$ 的出现位置。不同的层用不同颜色标记。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
8
2 4
1543
7777
2 4
7154
8903
2 4
3451
8888
2 2
54
13
2 2
51
43
2 6
432015
512034
4 4
5431
1435
5518
7634
6 4
5432
1152
4542
2432
2302
5942```

### 输出

```
1
1
0
1
0
2
2
2```

# 题解

## 作者：xvl_ (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/CF2036D)

一道模拟题。

直接模拟。我们定义 $[l,r]$ 表示有一个变量 $k$ 从 $l$ 遍历到 $r$。设现在遍历到第 $i$ 层，那么这一层按照顺时针排列的数是：

- 第 $i$ 行的第 $[i,m-i+1]$ 列。
- 第 $m-i+1$ 列的第 $[i+1,n-i]$ 行。
- 第 $n-i+1$ 行的第 $[m-i+1,i]$ 列。
- 第 $i$ 列的第 $[n-i,i+1]$ 行。
  
将所有数字提取后存储在一个 `std :: vector` 中，判断这个环上是否存在连续的 $\texttt{1543}$ 即可。

### Code
```cpp
#include <bits/stdc++.h>

const long long IMX = 1ll << 30;
const long long LMX = 1ll << 60;

const long long MOD1 = 998244353;
const long long MOD2 = 1000000007;
const long long MOD3 = 1000000009;

using ll = long long;
using i128 = __int128;
using ld = long double;
using f128 = __float128;

namespace xvl_ { 
	#define SP(n, x) std :: setprecision(n) << std :: fixed << x
	#define DEBUG(x) std :: cerr << #x << " = " << x << '\n'
	#define SZ(x) (x.size())
	#define fst first
	#define snd second
	template <typename T> T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }
	template <typename T> T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }
}
using namespace std;
using namespace xvl_;
const int N = 1005, M = 1005;
int T, n, m, cnt, ans;
char c[N][M];
int main() {
	// freopen("InName.in", "r", stdin);
	// freopen("OutName.out", "w", stdout);
	ios :: sync_with_stdio(0);
	cin.tie(nullptr);
	cin >> T;
	while (T--) {
		cin >> n >> m;
		ans = 0, cnt = n * m;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) cin >> c[i][j];
		}
		for (int i = 1; cnt; i++) {
			int num = 0;
			vector <int> vec;
			for (int j = i; j <= m - i + 1; j++, num++) vec.push_back(c[i][j] - '0');
			for (int j = i + 1; j <= n - i; j++, num++) vec.push_back(c[j][m - i + 1] - '0');
			for (int j = m - i + 1; j >= i; j--, num++) vec.push_back(c[n - i + 1][j] - '0');
			for (int j = n - i; j >= i + 1; j--, num++) vec.push_back(c[j][i] - '0');
			for (int j = 0; j < vec.size(); j++) {
				if (vec[j] == 1 and vec[(j + 1) % vec.size()] == 5 and vec[(j + 2) % vec.size()] == 4 and vec[(j + 3) % vec.size()] == 3) ans++;
			}
			cnt -= num;
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：jess1ca1o0g3 (赞：2)

## 思路

首先肯定要一层一层来看，如何遍历就成了问题。一共有 $\min(n,m)\over 2$ 层，可以分类讨论。即在上下左右时分别如何走。维护一个队列看现在有没有出现 $1543$。假如从左上角即 $(i,i)$ 开始走，如果有 $1543$ 刚好在拐角处就统计不全。所以开始时先找到任意一个 $1$，从这个位置顺时针搜，把所有的都统计到。

## 代码

比较丑陋。

```cpp
#include<bits/stdc++.h>
#define i64 long long
#define L(a,b,c,d) for(int a=b;a<=c;a+=d)
#define R(a,b,c,d) for(int a=b;a>=c;a-=d)

using namespace std;
const int N=1e3+5,M=998244353;

void solve();
int T,n,m,ans;
char s[N][N];

signed main(){
  scanf("%d",&T);
  while(T--) solve();
  return 0;
}

int sol(int x,int y,int i){
  int ans=0,u=x,v=y;
  vector<char> a;
  while(1){
    a.push_back(s[x][y]);
    if(a.size()==4){
      if(a[0]=='1'&&a[1]=='5'&&a[2]=='4'&&a[3]=='3') ans++;
      a.erase(a.begin());
    }
    if(x==i){
      if(y==m-i+1) x++;
      else if(y==i) y++;
      else y++;
    }
    else if(x==n-i+1){
      if(y==i) x--;
      else if(y==m-i+1) y--;
      else y--;
    }
    else if(y==m-i+1){
      if(x==n-i+1) y--;
      else if(x==i) x++;
      else x++;
    }
    else if(y==i){
      if(x==i) y++;
      else if(x==n-i+1) x--;
      else x--;
    }
    if(x==u&&y==v) break;
  }
  return ans;
}

void solve(){
  scanf("%d%d",&n,&m);
  L(i,1,n,1) scanf("%s",s[i]+1);
  ans=0;
  L(i,1,min(n,m)/2,1){
    int x=i,y=i;
    while(1){
      if(s[x][y]=='1') break;
      if(x==i){
        if(y==m-i+1) x++;
        else if(y==i) y++;
        else y++;
      }
      else if(x==n-i+1){
        if(y==i) x--;
        else if(y==m-i+1) y--;
        else y--;
      }
      else if(y==m-i+1){
        if(x==n-i+1) y--;
        else if(x==i) x++;
        else x++;
      }
      else if(y==i){
        if(x==i) y++;
        else if(x==n-i+1) x--;
        else x--;
      }
      if(x==i&&y==i) break;
    }
    ans+=sol(x,y,i);
  }
  printf("%d\n",ans);
}
```

---

## 作者：YuYuanPQ (赞：0)

找出一层的路径是很好想的，方向初始时向右，然后向下、向左、向上，走一层记录路径即可。

统计答案也是好做的，枚举每个位置，把它当做开始位置，判断包括它在内的 $4$ 个是否是合法的。记住是顺时针，所以要把位置对 $n$ 取模。

而在什么时候统计也是好想的：

定义一个 $zq$ 用于判断是否到了新的一层，每次转方向把 $zq$ 加 $1$。

因为 $4$ 个方向都会在一层里出现，所以每次转方向时，到了新的一层的条件就是：对 $n$ 取模为 $1$（初始时为 $1$）。

## Code
[Link](https://codeforces.com/contest/2036/submission/289554882)

---


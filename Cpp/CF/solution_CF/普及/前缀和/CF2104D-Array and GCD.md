# Array and GCD

## 题目描述

给定一个大小为 $n$ 的整数数组 $a$。

你可以执行以下操作任意次数（包括零次）：
- 支付 1 枚硬币并将数组中的任意一个元素增加 $1$（执行此操作时你至少需要有 1 枚硬币）；
- 获得 1 枚硬币并将数组中的任意一个元素减少 $1$。

我们称一个数组是理想的，当且仅当满足以下两个条件：
1. 数组中的每个元素都至少为 $2$；
2. 对于任意两个不同的下标 $i$ 和 $j$（$1 \le i, j \le n$；$i \ne j$），$a_i$ 和 $a_j$ 的最大公约数（GCD）等于 $1$。如果数组元素少于 2 个，则此条件自动满足。

我们称一个数组是美丽的，如果可以通过上述操作将其转换为理想数组，且初始时你没有硬币。如果数组已经是理想的，那么它也是美丽的。

给定的数组不一定是美丽或理想的。你可以从中删除任意数量的元素（包括删除整个数组或不删除任何元素）。你的任务是计算为了使数组变得美丽，最少需要删除多少个元素（可以是零个）。

## 说明/提示

在第一个样例中，你不需要删除任何元素，因为数组已经是美丽的。可以通过以下操作将其转换为理想数组：$[5, 5, 5] \rightarrow [4, 5, 5] \rightarrow [4, 4, 5] \rightarrow [4, 3, 5]$（最终你会拥有 3 枚硬币）。

在第二个样例中，你需要删除 2 个元素才能使数组变得美丽。如果保留元素 $[2, 3]$ 并删除其他元素，那么给定的数组已经是理想的（因此也是美丽的）。

在第三个样例中，你不需要删除任何元素，因为数组已经是理想的（因此也是美丽的）。

在第四个样例中，数组是美丽的。可以通过以下操作将其转换为理想数组：$[2, 100, 2] \rightarrow [2, 99, 2] \rightarrow [2, 99, 3] \rightarrow [2, 98, 3] \rightarrow [2, 97, 3]$（最终你会拥有 2 枚硬币）。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
3
5 5 5
4
2 3 2 4
1
3
3
2 100 2
5
2 4 2 11 2```

### 输出

```
0
2
0
0
1```

# 题解

## 作者：A_R_O_N_A (赞：5)

## 题意

有一个数组 $a$，你可以对其执行以下两种操作：

1. 花费 $1$ 个金币，使得任意一个 $a_i \leftarrow a_i+1$。
2. 增加 $1$ 个金币，使得任意一个 $a_i\leftarrow a_i-1$。

若一个数组非常滴理想，当且仅当其满足：

1. 对于每一个 $1\le i\le n$，$a_i\ge 2$。
2. 对于每一对 $1\le i,j\le n$，$\gcd(a_i,a_j)=1$。（若长度为 $1$ 视为满足该条件）

当一个数组能够通过上述的两种操作变得理想，那它就漂亮滴很呐（赞赏）。

但是现在给你的这个长度为 $n$ 的数组 $a$ 可能不太漂亮（悲），但是没有关系，你可以删除其中的一些数字，让它重新变得漂亮。注意：**不能先修改再删除**。

求需要删除的数字的最小数量。

数据范围：$1\le n\le 4\times 10^5,1\le a_i\le 10^9$。

## 思路

非常容易就能看出，修改操作实际上就是在保持当前数组总和不大于原始总和的情况下随意改变数组元素。为什么是不大于？**因为你可以把金币剩下来**！然后我们小贪一波，要让这个数组互质且和最小，直接让它等于质数表前 $n$ 项！这样子数组总和是最小的，我们剩的金币最多，操作空间就最大！而题目中给出的每一个元素至少为 $2$ 的条件刚好也贴合最小的质数。

那么就很简单了，如果当前数组长度为 $n$，所有元素之和不小于质数表前 $n$ 项之和，这个数组就是漂亮的。如果小于了，我们就应该考虑删除数字，很明显应该尽量删除小的数字，这样子我们数组总和的变化量就少，而因为长度缩短，要求贴合的质数表的长度也会缩短，而质数表是越来越大的，我们每次删除之后就更有机会超过质数表的前缀和，正确性是有的。

那么我们就先筛 $4\times 10^5$ 个质数，然后做一下前缀和，然后在原数组上一直删就行了。

## 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
mt19937 myrand(time(0));
inline ll read(){
	ll x=0,w=1;
	char ch=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*w;
}
void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	static int sta[35];
	int top=0;
	do{
		sta[top++]=x%10,x/=10;
	}while(x);
	while(top)putchar(sta[--top]+'0');
}
ll n,a[400005],sum[400005];
vector<int>prime;
bitset<7000005>notprime;
void init(int mx){
	notprime[1]=1;
	for(int i=2;i<=mx;i++){
		if(!notprime[i])prime.push_back(i);
		for(auto val:prime){
			if(i*val>mx)break;
			notprime[i*val]=1;
			if(i%val==0)break;
		}
	}
}
inline void work(){
	n=read();
	ll val=0;
	for(int i=1;i<=n;i++){
		a[i]=read();
		val+=a[i];
	}
	if(n==1){puts("0");return;}
	sort(a+1,a+n+1);
	if(val>=sum[n]){puts("0");return;}
	for(int i=1;i<=n;i++){
		val-=a[i];
		if(val>=sum[n-i]){
			write(i);putchar('\n');return;
		}
	}
	write(n);putchar('\n');
}
int t;
int main(){
	t=read();
	init(7000000);
	for(int i=0;i<=400000;i++)sum[i+1]=sum[i]+prime[i];
	while(t--)work();
	return 0;
}
```
[记录](https://codeforces.com/contest/2104/submission/317621889)。

---


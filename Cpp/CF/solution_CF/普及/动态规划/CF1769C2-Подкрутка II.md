# Подкрутка II

## 题目描述

В этой версии задачи $ n \le 2 \cdot 10^5 $ и $ a_i \le 10^6 $ (а также есть ограничение на сумму $ n $ по наборам входных данных внутри одного теста).

Вика за время работы в компании VK уже сделала $ n $ коммитов в системе контроля версий. $ i $ -й коммит был сделан в $ a_i $ -й день работы Вики в компании. В некоторые дни Вика могла сделать несколько коммитов, а в другие — не сделать ни одного.

Вику интересуют такие отрезки подряд идущих дней, что в каждый из этих дней у неё есть хотя бы один коммит. Чем длиннее будет самый длинный такой отрезок, тем более продуктивным сотрудником она будет себя ощущать.

Недавно Вика нашла способ подкрутить время любого коммита вперёд, но не более чем на сутки. Таким образом, $ i $ -й коммит теперь может быть «сделан» либо в $ a_i $ -й, либо в $ (a_i + 1) $ -й день. Время каждого коммита можно подкрутить независимо от других — в частности, можно как оставить всем коммитам исходное время, так и перенести все коммиты ровно на день вперёд.

Найдите длину самого длинного возможного отрезка подряд идущих дней, в каждый из которых у Вики в профиле будет отображаться хотя бы один коммит, после возможной подкрутки времени некоторых коммитов.

## 样例 #1

### 输入

```
3
9
1 1 3 4 6 6 6 8 10
6
1 2 3 4 5 6
5
10 10 10 10 10```

### 输出

```
5
6
2```

# 题解

## 作者：Sorato_ (赞：18)

# 题解背景

某一天上课时，老师在讲这道题，zxk 同学想出了一个非 dp 的**贪心**想法，但是在敲了 20 分钟后就很痛苦地离开了。

一位名为 zzn 的同学对此付出了实践，并给出了严谨的贪心证明，zxk 同学被他的黄金精神深深地感动了。

最后和 zzn 同学齐心协力在测试了 14 组毒瘤数据，修改 11 次之后终于 A 掉了这道题。

*（所以代码中会出现两种码风）*

# 思路

本着能贪就贪的思路，我们先想一想 $O(n^2)$ 的做法，其实很简单，就是对于每一个数字往后面进行枚举就可以，但是时间复杂度明显很高，那么我们思考一下我们的时间都浪费在了哪里，进行优化。

对于一串连续的数字，我们很明显知道这串数字一定会连接在一起，但是我们还是把他们拆开来一次又一次地计算我们明明已经知道的结果。

比方说，对于一串数字

```
1 2 3 4 5 6
```

我们明明知道他们一定会连接在一起，但是我们在双循环枚举的时候还是会把他们拆开然后一次又一次地重复地计算。

那么我们应该如何避免这种局面的产生呢？



## Step 1：去重

对于一个连续不下降的数列，比方说：

```
1 2 3 3 3 3 3 7 8 8 8 9 11
```

其实这么多的 $3$ 和 $8$ 对于我们来说，有意义的实际上只有两个：第一个不变，第二个上升 $1$ 那么多余的我们完全可以去掉。

```c++
n = read();a[1] = read();
for(reg int i = 2;i <= n;i = -~i/*位运算优化的i++*/)
{
	a[i] = read();
	if(a[i] == a[i - 1] && a[i] == a[i - 2])
		-- i, -- n;
}
```

这就是一个去重自动机（瞎编的），其中 $i$ 和 $n$ 自减的操作可以自己体会一下 。

## Step 2：切开分块(此分块不是数据结构)

我们将所有原数列分为 $2$ 种块：方和圆，用 $vbl_i$ 标记第 $i$ 个块属于 $0$（圆）还是 $1$（方）。

我们定义这样的块为方：**这个块中有且只有两个数原来相同，将后一个 $+1$，使该块成为一个等差且公差为 $1$ 的数列，且这个数列以这个 $+1$ 了的数结尾（最后这句是为了方便处理和解释）**。

定义这样的块为圆：**这个块是一个等差且公差为 $1$ 的数列，且没有任何数是经过 $+1$ 得到的**。

用 $Vbl_i$（注意 $V$ 大写）标记第 $i$ 个数是（$1$）否（$0$）放进了方中，用 $Vro_i$ 标记第 $i$ 个数是（$1$）否（$0$）放进了圆中。

分块的代码比较难解释，看着代码说吧：

```c++
vec[1].push_back(a[1]);//用vector类型存储各块
```

对于 $a_1$，我们无法确定它将会在一个方中还是在一个圆中，所以直接放入第 $1$ 个块中，不去定义这个块的类型。

```c++
for(reg int i = 2;i <= n; i = -~i)
{
    if(a[i]==a[i-1])//a[i]将会被放在方里
    {
        if(Vro[i-1])/*a[i-1]在一个圆里*/
        {
            vbl[cnt]=1;//根据方的定义，我们要把a[i]放入a[i-1]的块中，这个块就会变为方
            vec[cnt++].push_back(a[i]+1);//根据方的定义，a[i]放入该块后，该块就结束，cnt++，下同
            Vbl[i]=1;
        }
        else//当a[i-1]所在的块没有被定义时。为什么不会出现Vbl[i-1]==1，即a[i-1]被确定在方里的情况？思考
        {
            vbl[cnt]=1;//定义该块为方
            vec[cnt++].push_back(a[i]+1);
            Vbl[i-1]=1;Vbl[i]=1;
        }
    }
```

下证：此种情况中，$a_i$ 的上一个数不可能已经被确定为放在一个方里。

∵ 当一个块中有且只有 $2$ 个数相同时，定义这个块为方

且 去重后最多只有 $2$ 个数相同

∴ $a_{i-1}$ 不可能和它前边的元素相同

∴ $a_{i-1}$ 也就不会被确定为放在一个方里

证毕。

```c++
else if(a[i]-a[i-1]<=1)//a[i]将会被放入当前圆中
{
    if(Vro[i-1])    vec[cnt].push_back(a[i]),Vro[i]=1;
    else if(Vbl[i-1])	vec[cnt].push_back(a[i]);//1.思考为什么不确定Vro[i]=1
    else//当a[i-1]所在的块没有被定义时
    {
        vec[cnt].push_back(a[i]);//同1.
        Vro[i-1]=1;Vro[i]=1;//这里修不修改Vro[i-1]其实没有影响，但出于严谨还是修改
    }
    //2.思考cnt这里为什么不自加
}
```

对于 $1$：

- 上一个数被放入为了方中，说明上一个块已被确定为方。

- 所以上一个块已经结束，当前块是一个新块，所以无法确定当前块是方还是圆。

- 如果 $a_{i+1}=a_i$，这个块就是方，否则就是圆，但这里不需要写，下一个数时会处理。

对于 $2$：

- 对于此种放入圆的情况，不知道下一个数是否还会被放进这个圆中。

- 所以我们不可能结束这个圆，$cnt$ 不自加。

```c++
else//a[i]-a[i-1]>1，则需再开一个新块
    {
        if(Vbl[i-1])	vec[cnt].push_back(a[i]);//cnt不自加，因为确定上个块为方时已经结束了上个块，开了一个新块
        else if(Vro[i-1])	vec[++cnt].push_back(a[i]);//不能确定a[i]在圆中还是在方中，同上
        else	Vro[i-1]=1,Vro[i]=1,vec[++cnt].push_back(a[i]);//a[i-1]没有被确定是在圆中还是在方中，根据定义，放入圆
    }
} 
```

结束了？并没有：

```c++
if(vec[cnt].empty())	cnt--;
```

如果最后一个块为方，处理那个块时已经开了新块，但是后边已经没有数了，所以在此特判。

## Step 3：情况讨论并合并

下面我们尝试合并块，用 $len$ 表示当前合并出的块的包含的不同值的个数， 指针 $pnt$ 指向当前访问的块，$maxx$ 表示最终答案。

思考：

- **对于一个方**（以及一个含有方的块集），它之中一定有一个数是进行过上升（$+1$）操作的，所以我们在合并时**不能让它整体上升**。
- 但**对于一个圆**（以及一个仅由圆合并成的块集），它之中没有数单独上升过，所以它是**可以整体上升**的。

所以，我们用 $vis$ 标记当前合并出的块集能（$0$）否（$1$）整体上升，用 $up_i$ 标记第 $i$ 个块是（$1$） 否（$0$）整体上升过。

现在我们清楚了两种块的区别，就可以开始讨论可合并的情况并合并了（有些情况可合起来写，在此方便理解拆开写）。

首先，初始化：

```c++
int pnt = 1;
len = vec[1].size();
bool vis = 0;
clears();
while(pnt < cnt)
{
    bool wk=0;//wk的意义后面再说
```



1. 方（$pnt$ 指向该块）加方，首（下个块的）尾（当前块的）相差 $1$。

   ```c++
   if(vbl[pnt]+vbl[pnt+1]==2&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-1)
   {
       vis=1;//只要合并的块中有方vis就要变为1，下同
       len += vec[pnt + 1].size();
       wk = 1;
   }
   ```

   

2. 方加方，首尾相等。

   > 此种情况虽然会使区间长度相对更长，但是答案对区间长度没有要求，但由于首尾颜色相等，所以 $-1$。

   ```c++
   else if(vbl[pnt]+vbl[pnt+1]==2&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0])
   {
       vis=1;
       len += vec[pnt + 1].size()-1;
       wk = 1;
   }
   ```

   

3. 方加圆，首尾相差 $1$，右圆不用整体上移。

   > 对于圆，圆中没有数单独上升过，所以一个圆是可以整体上升的。

   ```c++
   else if(vbl[pnt]&&!vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-1)
   {
       vis=1;
       len += vec[pnt + 1].size();
       wk = 1;
   }
   ```



4. 方加圆，首尾相等，右圆需要整体上移。

   ```c++
   else if(vbl[pnt]&&!vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0])
   {
       vis = 1;
       up[pnt+1]=1;
       len += vec[pnt + 1].size();
       wk = 1;
   }
   ```



5. 圆加方，首尾相差 $1$，左圆（已合并出的块集）不用整体上移。

   ```c++
   else if(!vbl[pnt]&&vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-1)
   {
       len += vec[pnt + 1].size();
       wk = 1;
   } 
   ```

   

6. 圆加方，首尾相差 $2$，左圆已整体上移过。

   ```c++
   else if(!vbl[pnt]&&vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-2&&up[pnt])
   {
       vis=1;
       len += vec[pnt + 1].size();
       wk = 1;
   } 
   ```

   

7. 圆加方，首尾相差 $2$，左圆需要整体上移。

   ```c++
   else if(!vbl[pnt]&&vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-2&&!vis)
   {
       vis=1;
       up[pnt]=1;
       len += vec[pnt + 1].size();
       wk = 1;
   } 
   ```

   

8. 圆加圆，首尾相差 $1$，左圆不用整体上移。

   ```c++
   else if(!vbl[pnt]&&!vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-1)
   {
       len += vec[pnt + 1].size();
       wk = 1;
   }
   ```

   

9. 圆加圆，首尾相差 $2$，左圆已整体上移过。

   ```c++
   else if(!vbl[pnt]&&!vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-2&&up[pnt])
   {
       vis=1;
       len += vec[pnt + 1].size();
       wk = 1;
   }
   ```

   

10. 圆加圆，首尾相差 $2$，左圆需要整体上移。

    ```c++
    else if(!vbl[pnt]&&!vbl[pnt+1]&&vec[pnt][vec[pnt].size()-1]==vec[pnt+1][0]-2&&!vis)
    {
        vis=1;
        up[pnt]=1;
        len += vec[pnt + 1].size();
        wk = 1;
    }
    ```



最后：

```c++
}//这是while循环的大括号
pnt = -~pnt;//合并完后指针向后移
```

## Step 4：处理无法合并的情况

如果 $pnt$ 指向一个块时，下一个块无法合并进当块集，这个时候我们就需要结算。

结算程序如下：

```c++
if(!wk)//上边每种合并中wk都赋值为1，如果!wk，就证明无法合并了
{
    maxx = max(maxx , len);//更新maxx，maxx为最终答案
    if(vis&&!vbl[pnt-1])	-- pnt;//下边细说
    len = vec[pnt].size();
    vis = vbl[pnt];
    up[pnt] = 0;//重新开始合并，所以up,len,vis都初始化
}
```

细说第 $4$ 行：

- 对于一个方，它无法合并一定就是无法合并了，它不可能再上升然后合并。

- 对于一个圆，它不能合并，可能是因为当前块集中有一个数单独上升过，导致它不能跟着块集一起上升和后边的。

  如果这个圆单独上升，是有可能继续合并的，这时 $pnt$ 要回跳，从这个圆开始往后合并，这就是 `!vbl[pnt-1]` 的意义。

  但是如果说当前块集压根没有上升过，这个圆在前边是可以单独上升的，但它仍然无法合并， $pnt$ 就不需要回跳。

  而 $pnt$ 只需要回跳 $1$，一个很简单的证明：

  这个圆前面只可能是 $1$ 种块：一个方 或 一个不上升时无法和它合并的圆。

  这时，这个圆不可能再和它前面的块合起来去和后边的块合并。

  故 $pnt$ 只需要回跳 $1$，即回跳到当前圆。

  证毕。



## Step 5：处理答案并输出

终于要结束了！！！！！

```c++
maxx = max(max(len,(int)vec[cnt].size()), maxx);
printf("%lld\n",maxx);
```

可能到最后一个块是正常合并的，所以没有进入 Step 4 进行结算，所以 `maxx=max(len,maxx)`。

while 循环是 $pnt<cnt$，所以要再考虑一下 `vec[cnt].size()`，于是有 `maxx=max( vec[cnt].size(),maxx)`。

于是有了第一行的式子。



## Step 6：Clear

```c++
inline void clears()
{
    for(reg int i = 1;i <= cnt ;i = -~i)	vec[i].clear(), vbl[i] = 0, up[i] = 0;
    for(reg int i=1;i<=n;i++)	Vbl[i]=0,Vro[i]=0; 
    cnt=1;
    maxx = -999;
}
```



# 贪心正确性证明：

zzn 和 zxk 向老师提出这种思路后，老师举了一种反例：如果我遍历到一个块，这个块无法和下一个块合并，那我有没有可能跳过下一个块，从下下一个块合并会更优呢？

由于当时是放学，zzn 脑子不太清醒，吓了一跳，回寝后冷静下来，想出了正确性证明。

证明：

假设中间有一个块无法和它的下一个块拼接。

但是，如果这个块无法和它的下一个块拼接，则 这个块的最后一个元素 一定比 它的下一个块的第一个元素 **小 超过2**。

因为原序列是一个不下降序列，所以下个块之后的块中的元素 **一定**  $\geq$ 下个块中的元素。

又因为要求**连续** $x$ 种值，所以下个块之后的块 **一定不能** 和这个块拼起来。

综上，如果略过这个块，直接选择后边的是**不可行**的。

证毕。



# 时间复杂度：接近 $O(n)$

![](https://cdn.luogu.com.cn/upload/image_hosting/54rd9fj6.png)

---
 _update on 23.8.9：重温的时候发现Step的序号标错了www，也更正了一些其他的小错误。_

---

## 作者：Libra_ (赞：9)

### 背景
老师上课的例题，来水个题解。


# 题目
给你一个 n 长**不下降**序列 $a_1,...,a_n$，现在你可以将其中的一些位置加上 1。

请你求出最大的 x，使得存在连续一段 $a_l,...,a_r$，其中出现过**连续** **x** 种值。
 
# Step 1:
一个很自然的想法：

以 $a_i$ 结尾的出现过的连续 $x$ 种值的最大值，一定是在以 $a_i-1$ 结尾的出现过的连续 $x-1$ 种值的最大值上 $+1$。

每个 $a_i$ 有 $+0$ 和 $+1$ 两种选择，所以开一个二维数组：$dp[maxn][2]$，分别表示 $+0$ 和 $+1$。

因为是：
>一个 n 长**不下降**序列

所以，以 $a_i$ 结尾的答案，可以在以 $a_j(1 \le j <i)(a_j = a_i-1)$ 结尾的答案上累加，这样就得到了一个 $O(n^2)$ 的解法。


（不是很标准的）代码：


```cpp

  for (int i=1;i<=n;i++){
      for (int j=1;j<i;j++){
          if(a[i]==a[j]+1){
              dp[i][0]=max(dp[i][0],dp[j][0]+1);
              dp[i][1]=max(dp[i][1],dp[j][1]+1);
          }
          if(a[i]==a[j]+2) dp[i][0]=max(dp[i][0],dp[j][1]+1);
          if(a[i]==a[j]) dp[i][1]=max(dp[i][1],dp[j][0]+1);
      }
  }
	
```

# Step 2:
我们发现，对于每次更新以 $a$ 结尾的答案，我们只关心以 $a-1$ 结尾的答案的最大值，所以可以开一个数组 $mp[i]$，记录以 $i$ 结尾的答案的最大值，这样就可以 $O(1)$ 查询 $\max\{\,ans_{a-1}\,\}$，省去的第二层的 $j$ 循环，实现 $O(n^2) \rightarrow O(n)$ 的优化。

我的代码：[CF1769C2 代码](https://www.luogu.com.cn/paste/p4a5723s)
    	
	



---

## 作者：some_side (赞：4)

看到同机房的好哥们发了贪心做法的题解，心血来潮就A了这道题写了真·dp的题解。

虽然方法比老师上课讲的麻烦的多，并不是最优解，但至少是我自己思考得出的结果。


## 题目要求


输入一个原序列 $a_i$，从 $a_i$ 中求得某个区间 $[l,r]$。

此区间经过题面中所描述的修改操作（任何元素 $+1$ 或不变），使得其中所有元素 $a_l,\dots,a_r $ 所能表示的所有数值，应当是一段连续的数值。

例如， $4, 5, 6, 7$ 即为一段连续的数值，$4, 6, 7$ 则不是。

此区间 $[l,r]$ 能够表示的**数值种类** $x_{\max}$ 是从 $a_i$ 中所有区间经过修改能表示的**数值种类** $x$ 的最大值。

求这个最大的数值种类 $x_{\max}$。

## Step.1$\;$分段

### 思路
由题易知，原序列 $a_i$ 由若干个能够表示连续数值的序列 $b_i$ 拼合而成。

我们最终求得的区间，必然是由原序列 $a_i$ 中连续的几段 $b_i$，经过修改，拼合而成。

因此，我们首先要将原序列 $a_i$ 分成若干段，每一段中元素所能表示的数值，是一段连续数值。

例如，样例1给出的序列：
$$ 1, 1, 3, 4, 6, 6, 6, 8, 10 $$

经过分段得到：
$$(1,1),\,(3, 4),\,(6, 6, 6),\,(8),\,(10)$$


### 代码实现（可以跳过）
我们用结构体 ```block``` 来存储每一段的信息。

```block.length``` 为这一段能够表示的数值种类。

```block.first``` 为这一段能够表示的最小值，即这一段的第一个数。

```block.last``` 为最大值。

```block.yep``` 数据类型为 ```bool```，表示这一段能表示的数值能否往后延伸一位，即 这一段中有无数值在序列 $a_i$ 中个数大于 $1$。 

其实 ```block.length = block.last - block.first + 1```，即```block.length``` 可以用 ```block.first``` 和 ```block.last``` 表示。不过结构体里边开一个 ```block.length``` 写代码的时候更方便一点。 

因为 $1 \le a_i \le 10^6$，所以我们可以用一个数组 $cnt_a$ 来存储数字 $a$ 在原序列中的个数。

将 $a_i$ 储存入 $cnt_a$ 之后，遍历 $cnt_a$，即可进行分段。

完整实现放在题解最后面。

## Step.2$\;$状态转移

### 思路

$dp_i$ 表示，以第 $i$ 段为结尾，拼合的区间能表示的最大数值种类为 $dp_i$ 种。

显然，对于每个 $dp_i$，初始状态为 
$dp_i = vec_{i_{last}} - vec_{i_{first}}+1$，即第 $i$ 个段 _不修改_ 所能够表示的连续数值的个数。$vec$ 是用来存储每一个的 ```block``` 信息的 ```vector``` 动态数组。

分完段之后，我们考虑，最终的区间肯定是由连续的几个 ```block``` 经过适当的修改拼合而成的。

**结论1：** 若两个段 ```block a, b``` 可以拼合，必然有 ```a.last+1 == b.first-1```。

“可以拼合”是指，两个 ```block``` 表示的序列合起来所组成的序列，可以经过修改操作，表示的数值为连续数值。

例如，```block a``` 表示的序列为 $(1, 2)$，```block b``` 为 $(4, 5)$。 
```a.last = 2```，```b.first = 4```，满足 ```a.last+1 == b.first-1```。```a``` 的两个元素均 $+1$，```a``` 和 ```b``` 就可以拼合为序列 $(2, 3, 4, 5)$。

**结论2：** 若多个段 ```block a, b, ... y, z``` 可以拼合，除了开始和结尾的段 ```block a, z```，对于中间每一个段 ```block b, ... y``` 所表示的序列，必然有至少一个元素在原序列 $a_i$ 中的个数 $>1$。

例如，```block a, b, c``` 分别为 $(1,2)$，$(4, 4, 5)$，$(7, 8)$。```block a, b``` 可以拼合为 $(2, 3, 4, 4, 5)$，这个新的序列又可以和 ```block c``` 拼合为 $(2, 3, 4, 5, 6, 7, 8)$。中间的 ```block b``` 必然要有 $cnt_4>1$ 或 $cnt_5>1$，才能让 ```block a, b, c``` 同时拼合。

根据以上两个结论，我们容易得出转移方程：

如果 $vec_i$ 和 $vec_{i-1}$ 两个段可以拼合，则有
$$ dp_i \gets \begin{cases}
 dp_{i-1} & vec_{i-1_{yep}}=1 \\
 vec_{i-1_{length}} & vec_{i-1_{yep}}=0 \\
 \end{cases}$$
 
 $dp_{i-1}$ 中包含了 $vec_{i-1}$ 之前的段的贡献。如果 $vec_{i-1_{yep}}=0$，即 $vec_{i-1}$ 中所有元素个数 $=1$，则 $vec_i$ 就不能与 $vec_{i-1}$ 之前的段拼合，$dp_i$ 只能加上 $vec_{i-1}$ 这一段的贡献。
 
如果 $vec_{i_{yep}}=1$，则有

$$ dp_i \gets dp_i+1 $$

即第 $i$ 段能表示的连续数值可以经过修改多一个。

$vec_i$ 下标范围是 $(\,0,\,size\,)$，$size$ 指 $vec$ 的大小，即 ```vec.size()```。所以最后的答案为 $\max(dp_i),0<i<size$。


## 奉上完整实现代码：

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e6+7;

int t, n, cnt[maxn], dp[maxn];

struct block{
	int length, first, last; 
	bool yep; 
}; vector<block> vec;

int main() {
	scanf("%d", &t);
	while(t--) {
		
		/*多测不清空。*/
		vec.clear();
		memset(dp, 0, sizeof(dp));
		memset(cnt, 0, sizeof(cnt)); 
		
		/*输入。*/ 
		scanf("%d", &n); int mx;
		for(int i=1; i<=n; i++) {
			int a; scanf("%d", &a);
			cnt[a]++;
			if(i==n) mx = a; 
			//mx是序列a中最大的数。
		}
		
		/*分段。*/
		int len=0, first=-1, last=-1; bool yep=0;
		for(int i=1; i<=mx; i++) {
			if (len>0 && cnt[i]==0) {
				//一段结束。 
				last = i-1;
				vec.push_back({len, first, last, yep}); 
				yep=0; len=0;
			} else if (cnt[i]>0) {
				//开新一段。 
				if (len==0) first = i;
				yep|=(cnt[i]>1); len++;
			}
		}
		vec.push_back({len, first, mx, yep}); //加入最后一段。 
		
		/*状态转移。*/
		int ans = 0; 
		for(int i=0; i<vec.size(); i++) {
			dp[i] = vec[i].length; //初始状态。 
			if( i>0 && vec[i-1].last+1 == vec[i].first-1 ) {
				if(vec[i-1].yep) dp[i] += dp[i-1]; 
				else {
					dp[i] += vec[i-1].length;
				}
			}
			if(vec[i].yep) dp[i]+=1;
			ans = max(ans, dp[i]);
		}
		printf("%d\n", ans); //输出。 
	}
	
	return 0;
}
```

## 结语
这篇题解好长啊，实际上不是很麻烦的东西搞得看起来好麻烦。

这是我第一次写题解。希望管理和大家多多包涵。

---

## 作者：lidxy (赞：3)

## 题意
一个长度为 $n$ 的不下降序列，可以对任何一个数进行加一，找到一段最长子序列使得后一个数为前一个数加一。
## 思路
根据题目可知，答案需要通过加一或者不变来更新答案，很明显需要 dp 转移，我们可以用一个二维数组来记录答案，第一维表示枚举到这个点的最大答案，第二维表示这个点加一还是不变，同时用一个桶来记录以这个点结尾的最大值，过程中不断更新最大值，细节就在代码中说吧。

## 转移方程：

`ans[i][1]=q[a[i]]+1;`

如果 $i$ 是通过加一得到的，那么说明需要把 `a[i]+1`, 那么第 $i$ 位就需要从以
`a[i]` 为结尾的答案转移。

$q$ 是以值为 `a[i]` 为结尾的最大答案。 

`ans[i][0]=q[a[i]-1]+1;`

同理，如何 `a[i]` 不改变，那么它就是由 `a[i]-1` 转移过来。

## 时间复杂度
因为只枚举一遍所以是 $O(n)$ 的。
## 代码
```
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n,a[200005];
int t;
int ans[200005][2];//二维数组
int q[1000005];//桶
int tot;//答案
inline ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
signed main(){
    cin.tie(0);
    cout.tie(0);
    t=read();
    while(t--)
    {
        n=read();
        tot=0;
        memset(a,0,sizeof(a));
        memset(ans,0,sizeof(ans));
        memset(q,0,sizeof(q));//多测清空
        for(register int i=1;i<=n;++i)
        {
            a[i]=read();
        }
        for(register int i=1;i<=n;++i)
        {
            ans[i][1]=q[a[i]]+1;
            //如果i是通过+1得到的，那么说明需要把a[i]+1,那么第i位就需要从以a[i]为结尾的答案转移。
            ans[i][0]=q[a[i]-1]+1;
            //同理，如何a[i]不改变，那么它就是由a[i]-1转移过来。
            q[a[i]]=ans[i][0];
            //因为序列为不下降序列，再根据ans的定义，我们可以直接对q数组进行更新。
            //根据上三行描述，a[i]不变所以q是由ans[i][0]转移。
            q[a[i]+1]=ans[i][1];
            //同理，由a[i]+1转移。
            tot=max(max(ans[i][0],ans[i][1]),tot);
            //更新答案。
        }
        cout<<tot<<endl;//over
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

一个 dp 优化好题。

## 题意

本题有 $T$ 组数据。

每组数据给你一个长度为 $n$ 的不下降序列，现在你可以将其中的一些位置加上 $1$，找到一段最长子序列使得后一个数为前一个数加 $1$。

## 思路

根据以前的做题经验~~和算法标签~~，我知道这是一道 dp。因为 $a_{i}$ 可以不变或 $+1$，可设 $dp_{i,j}$ 表示以下标为 $i$ 结尾，$a_{i}$ 加上 $j$ 时获得最大的 $x$。我们这时只需在 $a_{j}(j<i)$ 上累加最大值即可得到一个 $O(Tn^{2})$ 的解法。

但是因为 $T\le 100,n\le 2\times 10^{5}$ 的数据范围和 2.00s 的时间限制，可知本题需要使用 $O(Tn)$ 的算法。所以我们可以再开一个数组 $f_{i}$ 表示数值为 $i$ 时最大的 $x$，就可以用 $O(n)$ 的时间复杂度求出 $\max(dp_{i,j})$ 去完成 dp 优化。

最后输出 $\max(dp_{i,j})$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,M=1e6+5;
int a[N],dp[N][2],f[M];//dp[i][j]表示以下标为i结尾，a[i]加上j时获得最大的x
//f[i]表示数值为i时最大的x
int main(){
	int t,n;
	scanf("%d",&t);
	while(t--){
		memset(dp,0,sizeof(dp));
		memset(f,0,sizeof(f));
		scanf("%d",&n);
		for(int i=1;i<=n;++i){
			scanf("%d",a+i);
		}
		for(int i=1;i<=n;++i){
			dp[i][0]=f[a[i]-1]+1;
			dp[i][1]=f[a[i]]+1;
			f[a[i]]=dp[i][0];
			f[a[i]+1]=dp[i][1];
		}int ans=-1;
		for(int i=1;i<=n;++i){
			for(int j=0;j<=1;++j){
				ans=max(ans,dp[i][j]);
			}
		}cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：him的自我修养 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/CF1769C2)
# 题意
给定 $n$ 个单调不减序列，你可以让任何一个数增加 $1$，找出一个最长上升子序列让每个数是上一个数加一。
# 思路
~~其实没啥~~。这道题是一道动态规划问题，$dp_{i}$ 数最大的 $x$。而 $dp$ 数组是二维的，一维是存前 $i$ 个数最大的 $x$，另一维表示 $a_{i}$ 加不加 $1$。


-----
接下来看看状态转移方程，首先，如果$a_{i}=a_{i-1}$ 那么 $dp_{i,0}$ 和 $dp_{i,1}$ 继承上一个，否则，$dp_{i,0}=b_{a_{i}-1}+1$ 而 $dp_{i,1}=b_{a_{i}}+1$。其中的 $b_{i}$ 代表以 $a_{i}$ 结尾最大的 $x$。

# code
实现就没什么难度力，$ ans=\sum_{i=1}^{n} \max(dp_{i,0},dp_{i,1}) $。
```
#include <bits/stdc++.h>
using namespace std;
int n,a[200005],dp[200005][2],b[1000005];
int main() {
	int t;
	cin >>t;
	while(t--) {
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(dp,0,sizeof(dp));
		int ans=0;
		cin >>n;
		for(int i=1;i<=n;i++) cin >>a[i];
		for(int i=1;i<=n;i++) {
			dp[i][1]=b[a[i]]+1;
			dp[i][0]=b[a[i]-1]+1;
			b[a[i]]=dp[i][0];
			b[a[i]+1]=dp[i][1];
			ans=max(ans,max(dp[i][0],dp[i][1]));
		}
		cout <<ans<<endl;
	}
	return 0;
}
```

---


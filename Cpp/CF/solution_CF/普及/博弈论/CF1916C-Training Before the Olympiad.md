# Training Before the Olympiad

## 题目描述

Masha 和 Olya 即将参加一场重要的团队奥林匹克竞赛。为此，Masha 提议和 Olya 玩一个热身游戏：

有一个长度为 $n$ 的数组 $a$。Masha 先手，双方轮流操作。每一步操作如下：

$\bullet$ 如果数组的长度为 $1$，游戏结束。

$\bullet$ 当前玩家选择两个不同的下标 $i$，$j$（$1 \le i, j \le |a|$），并执行如下操作——将 $a_i$ 和 $a_j$ 从数组中移除，并向数组中添加一个数，数值为 $\lfloor \frac{a_i + a_j}{2} \rfloor \cdot 2$。也就是说，先将 $a_i$ 和 $a_j$ 的和除以 $2$ 向下取整，然后将结果乘以 $2$。

Masha 的目标是让最终剩下的数最大，Olya 的目标是让最终剩下的数最小。

Masha 和 Olya 决定对初始数组 $a$ 的每一个非空前缀都玩一遍这个游戏，并向你寻求帮助。

对于每个 $k = 1, 2, \ldots, n$，请回答如下问题：仅用数组 $a$ 的前 $k$ 个元素（下标为 $1, 2, \ldots, k$）进行游戏，双方都采取最优策略，最后剩下的数是多少？

## 说明/提示

在第三个测试用例中，对于长度为 $1$ 的前缀，答案是 $3$。对于长度为 $2$ 的前缀，Masha 只有一种操作方式，答案是 $12$。对于长度为 $3$ 的前缀，Masha 有三种选择：选择 $3$ 和 $10$，最终剩下 $22$；选择 $3$ 和 $11$，最终剩下 $24$；选择 $10$ 和 $11$，最终剩下 $22$，因此 Masha 会选择 $3$ 和 $11$，最终得到 $24$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1
31
6
6 3 7 2 5 4
3
3 10 11
5
7 13 11 19 1```

### 输出

```
31 
6 8 16 18 22 26 
3 12 24 
7 20 30 48 50```

# 题解

## 作者：One_JuRuo (赞：14)

## 思路

首先，我们可以考虑两个人会怎么操作，如果是选择了两个偶数和两个奇数，那么答案不会减小，如果选择了一个奇数一个偶数，那么答案会减小一。

所以想使答案大的人应该尽量选择前一种方案，想使答案小的人应该尽量选择后一种方案。

但这还不是最优的，想使答案大的人在可以选择两个奇数时，绝对不会选择两个偶数，因为这样可以让想使答案小的人可以选择的奇数变少。

因为每一次操作后都必定产生一个新的偶数，所以我们可以只看奇数的数量，就可以算出总答案会减少多少。

想使答案大的人先操作，如果此时，奇数的数量在两个及以上，就会选择两个奇数，否则如果偶数的数量在两个及以上，则选择两个偶数，否则选择一奇一偶。

因为每次操作必定诞生偶数，所以想使答案小的人一定不会选择不了偶数，所以一旦还有奇数，他就会消耗一个奇数使得答案减小。

所以可以发现，如果奇数的个数大于等于 $3$，那么，每轮操作都会让奇数的个数减少 $3$，且使得总答案减少一。

所以答案会先减去奇数个数除以三。

再考虑余数，如果余数为 $0$，则构不成任何影响，如果余数为 $1$，代表要么想使答案大的人选择一次一奇一偶，要么想使答案小的人选择一次一奇一偶，所以答案必定还会少一，如果余数为 $2$，那么想使答案大的人直接选择一次两个奇数即可，答案不会减少。

所以只需要动态的统计总和和奇数个数即可。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,a,sum,num;//要开longlong 10^5个10^9的和轻松爆int
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n),sum=num=0;//别忘了清零
		for(int i=1;i<=n;++i)
		{
			scanf("%lld",&a),sum+=a,num+=a%2;//统计总和和奇数个数
			if(i==1) printf("%lld ",sum); //如果是第一个，直接就是答案，不需要考虑奇数
			else printf("%lld ",sum-num/3-(num%3==1));
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：xiaosi4081 (赞：5)

# CF1916C Training Before the Olympiad

## 题意简述

Masha 和 Olya 在玩一个游戏。

给定一个序列 $a$，每次 Masha 和 Olya 轮流将序列 $a$ 中的两个元素 $a_i$ 和 $a_j$ 合并为一个数 $\lfloor \dfrac{a_i+a_j} {2}\rfloor \times 2$。当序列长度为 $1$ 时，游戏结束。Masha 先手，他想要最后剩下的数尽可能大。Olya 后手，他想要最后剩下的数尽可能小。

## 题目解法

可以发现，一次操作相当于把两个数加起来再将其变为最大的小于它的一个偶数。

如果序列全都是偶数，那么不管怎么操作都不会对最终答案有影响，偶数加偶数最终得到的结果仍为偶数。此时答案为 $\sum a_i$。

如果序列中有奇数的话，我们不妨设答案为 $(\sum a_i) - x$，其中 $x$ 是**操作过程**中选定两数的和为奇数的数量（也就是所谓精度损失）。

Olya 想要 $x$ 尽可能大，所以他会尽可能的增加操作过程中选定两数之和为奇数的数量，他会选定和为奇数的两个数来进行操作，即一个偶数和一个奇数。

Masha 想要 $x$ 尽可能小，所以他要消耗掉能被 Olya 所用的奇数，他会选择两个奇数合并在一起。

可以发现，一轮操作会消耗掉三个奇数，那么设奇数数量为 $ocnt$，则 $x = \lfloor\dfrac{ocnt}{3} \rfloor$，由于 Olya 后手，所以我们要向下取整。

综上所述，最终答案就为 $(\sum a_i) - \lfloor\dfrac{ocnt}{3} \rfloor$。

## 正解代码

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,suma,sumodd;
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		suma=sumodd=0;
		for(int i=1;i<=n;i++){
			int x;cin>>x;
			if(x&1)sumodd++;
			suma+=x;
			if(i>1)cout<<(suma-sumodd/3)/2*2<<" ";
			else cout<<x<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：__3E24AC7002AD9292__ (赞：4)

博弈论。

首先不难发现：

- 对于 $\forall w\in\text{R}$，$2\lfloor w\rfloor$ 显然为偶数。
- 对于 $\forall w_1,w_2\in\text{Z}$，当且仅当 $w_1$ 与 $w_2$ 同奇偶，$2\lfloor\frac{w_1+w_2}{2}\rfloor=w_1+w_2$，否则 $2\lfloor\frac{w_1+w_2}{2}\rfloor=w_1+w_2-1$。

假设当前前缀为 $B$。

假设没有下取整，那么前缀 $B$ 对应的最终答案即为 $\sum B$。但是在这里如果进行了 $k$ 次下取整满足 $2\lfloor\frac{B_i+B_j}{2}\rfloor=B_i+B_j-1$，则答案为 $\sum B-k$。

显然考虑每个元素的奇偶性，统计 $B$ 中奇、偶数个数。

- 假若每次选择 $B_i$ 与 $B_j$ 不同奇偶，则偶数个数不变，奇数减少 $1$，$k$ 加一；
- 假若两个都是偶数，$k$ 不变，偶数减少 $1$；
- 假若都是奇数，偶数反而加 $1$，奇数减少 $2$，$k$ 不变。

后手策略就是如果有奇有偶，就选第一种操作使得 $k$ 变大。

显然先手希望 $k$ 越小越好，故尽量让奇偶数中的一种变多，另一个变少，显然选择让偶数变多（否则在消除偶数后消除奇数时又增多了偶数个数，可以证明消除偶数不比消除奇数更优）。

那么如何消除奇数？显然每次先手消除两个奇数后（这样会产生一个偶数，所以不用担心后手有没有偶数可以消除），只要还有奇数，后手就会选择一个奇数消除（偶数可以看做没变化），$k$ 加一。

当然有时轮到了先手，但是奇数个数为 $1$，它只能留给后手消除。令 $p$ 为 $B$ 的奇数个数，则 $p\bmod 3=1$ 的时候可能遇到这种情况，最后 $k=\frac{p-1}{3}+1$。其他情况下 $k=\lfloor\frac{p}{3}\rfloor$。

在枚举前缀时，统计奇数个数和前缀和即可。

[code](/paste/7zj8ibh0)。

---

## 作者：_qhbd_ (赞：1)

# 题意简述
有两个人要玩游戏，为了方便简称小红和小明。

给定一个数列，每次可以合并两个数，直到数列只剩一个数为止。合并的规则为将两个数列里的数相加，然后除以二并向下取整后再乘以二。小红想让最后剩下的数尽量大，而小明想要剩下的数尽量小。

共有 $t$ 组数据，每组数据给定一个长为 $n$ 的数列，问对于这个数列的每个前缀数列，如果小红、小明依次合并并且小红和小明都采取最优的策略，最后剩下的数会是多少。
# 思路
首先易得对于每次合并，只有当一个偶数和一个奇数合并时，它们的总和才会变小，并且合并过后的数必定是偶数。所以我们可以得到一个结论，小红会优先合并奇数和奇数，而小明会优先合并奇数和偶数。

那么整个题的做法就清晰了，对于每组数据，我们只要在输入的过程中记录前缀和和奇数的个数，然后套公式依次输出结果就可以了。

公式也很好推导。因为合并结果一定为偶数，所以奇数只要合并就会减少，小红一次用两个，小明一次用一个，所以小红、小明一次操作一轮就会减少 $3$ 个奇数。而对于每一轮的操作，总和就会减少 $1$，所以奇数的个数除以 $3$ 向下取整得到的数就是减少的 $1$ 的个数了。但是还有一个特殊的情况，就是轮到小红操作时，只剩下了一个奇数，那么此时小红无法合并两个奇数了，此时结果还要再减少一个 $1$。令奇数个数为 $a$，数列和为 $sum$，那么公式即为 
```
ans=sum-(a&&a<2&&i-a?1:(a-2>0?a-2:0)/3+(a-2>0?a-2:0)%3)
```
解释：

- 公式里有一个特判，当只有一个奇数的时候结果减去一个 $1$。

- 公式里的 $(a-2)$ 是先减去了小红第一次操作用掉的两个奇数，然后使用顺序就是小明一个、小红两个。那么 $(a-2)$ 对于 $3$ 取模得到的 $0$ 则意味着刚好取尽，得到 $1$ 则意味着小明还能再减少一个 $1$，得到 $2$ 则意味着小明操作完后，只剩下 $1$ 个奇数了，此时还能再减少一个 $1$。

# 代码
```cpp
#include<iostream>
#define int long long
using namespace std;
int t,n,pre,a;
signed main(){
	scanf("%lld",&t);
	while(t--){pre=a=0;
		scanf("%lld",&n);
		for(int i=1,c;i<=n;i++){
			scanf("%lld",&c);
			a+=c&1;
			pre+=c;
			printf("%lld ",pre-(a&&a<2&&i-a?1:(a-2>0?a-2:0)/3+(a-2>0?a-2:0)%3));
		}printf("\n");
	}return 0;
}
```

---

## 作者：wmrqwq (赞：1)

[题目传送门（CF）](https://codeforces.com/contest/1916/problem/C)

[题目传送门（luogu）](https://www.luogu.com.cn/problem/CF1916C)

容易发现，选择两个偶数对于答案没有任何影响，因此先手必然会优先选择两个奇数合并在一起，而后手必然会优先选择一个奇数和一个偶数在一起，我们举个例子，有一个序列 $\{1,1,1,1,1,1\}$，先手先取编号为 $1,2$ 的两个数，后手再取编号为 $2,3$ 的两个数，此时第 $3$ 个数为 $2$，因此对答案贡献没有影响，这时先手最优是取编号为 $4,5$ 的两个数，后手最优是取 $5,6$ 的两个数，发现了没有，先手和后手的一个周期是 $3$ 个奇数，因此我们只要分讨一下 $n \bmod 3 = 0$，$n \bmod 3 = 1$，$n \bmod 3 = 2$ 的三种情况即可，注意这种方法要特判一下前缀只有一个数的情况。

参考代码：

```cpp
/*
Tips:
你数组开小了吗？
你MLE了吗？
你觉得是贪心，是不是该想想dp？
一个小时没调出来，是不是该考虑换题？
*/
#include<bits/stdc++.h>
using namespace std;
#define map unordered_map
#define forl(i,a,b) for(register long long i=a;i<=b;i++)
#define forr(i,a,b) for(register long long i=a;i>=b;i--)
#define lc(x) x<<1
#define rc(x) x<<1|1
#define cin(x) scanf("%lld",&x)
#define cout(x) printf("%lld",x)
#define lowbit(x) x&-x
#define pb push_back
#define pf push_front
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl '\n'
#define QwQ return 0;
#define ll long long
ll t;
 
void solve()
{
	ll n,sum=0,js=0;
	cin>>n;
	ll a[n+1];
	forl(i,1,n)
	{
		cin>>a[i];
		if(a[i]%2)
			js++;
		sum+=a[i];
	/*	if(js==0)
			cout<<sum<<" ";
		else if(js==1)
			cout<<sum-1<<" ";
		else if(js==2)
			cout<<sum<<" ";
		else*/
		{
		/*	if(i==1)
				cout<<sum<<" ";
			else if(js==3)
				cout<<sum-1<<" ";
			else if(js%2==0 && js!=2)
				cout<<sum-js/2+1<<" ";
			else if(js!=1)
				cout<<sum-js/2+1<<" ";
			else if(js==2)
				cout<<sum<<" ";
			else
			{
				if(n==1)
					cout<<sum<<" ";
				else
					cout<<sum-1<<' ';
			}*/
			if(js%3==0)
				cout<<sum-js/3;
			else if(js%3==1)
			{
				if(i==1)
					cout<<sum;
				else
					cout<<sum-js/3-1;
			}
			else
				cout<<sum-js/3;
			cout<<" ";
		}
	}
	cout<<endl;
}
int main()
{
	IOS;
	cin>>t;
	while(t--)
		solve();
    /******************/
	/*while(L<q[i].l) */
	/*    del(a[L++]);*/
	/*while(L>q[i].l) */
	/*    add(a[--L]);*/
	/*while(R<q[i].r) */
	/*	  add(a[++R]);*/
	/*while(R>q[i].r) */
	/*    del(a[R--]);*/
    /******************/
	QwQ;
}
/*
3 5 7 9 4 4
 
8 7 9 4 4
 
8 7 12 4 
 
8 10 12
 
30
 
6:-2
 
8:-2
 
4:-2
 
2:0
 
10:-4
 
 
*/
```

---

## 作者：Luzhuoyuan (赞：0)

### 题目链接

[[to Luogu]](https://www.luogu.com.cn/problem/CF1916C) [[to Codeforces]](https://codeforces.com/contest/1916/problem/C)

### 题意简述

有一个正整数序列 $a$，两人进行游戏，规则如下：

- 当序列中只有一个元素时，游戏结束。
- 否则，两人交替操作，每次需要选出 $a$ 中的两个元素 $a_i,a_j(i\ne j)$，将它们删除并插入一个值为 $\lfloor\frac{a_i+a_j}{2}\rfloor\cdot 2$ 的元素。

先手希望使得最终 $a$ 中留下的数最大化，后手希望最小化，两人都按最优策略进行游戏，求对于给定的长为 $n$ 的序列 $a$ 的每个非空前缀，对该前缀进行游戏的结果，即最后留下的数。每个测试点 $t$ 组测试用例。

$$1\le t\le 10^4;1\le n,\sum n\le 10^5;1\le a_i\le 10^9$$

### 做法

先看这个操作，我们会发现当 $a_i+a_j$ 为偶数时结果为 $a_i+a_j$，否则为 $a_i+a_j-1$，且操作后的数都是偶数。也就是说，当且仅当对一个奇数和一个偶数操作时序列的总和会减小 $1$。那么后手的最优策略显然：

- 若数列中有至少一个奇数和至少一个偶数，那么任取一个奇数和一个偶数进行操作；
- 否则，随便选两个数操作。

对于先手来说，由于后手操作必须要用到奇数，而奇数是用一个少一个，那么先手就想让后手少一点可用的奇数，所以会尽量消耗奇数，且尽量不让序列总和减小。所以，先手的最优策略为：

- 若数列中有至少两个奇数，那么任取两个奇数进行操作；
- 否则，随便选两个数操作。

你可能会想：如果奇数只有一个，那先手如果取一奇一偶让答案减少了，那不如取两个偶数嘛。实际上都是一样的，如果先手取两个偶数，后手一样会把剩下的奇数取走。

如果两人交替操作，那么一个回合（各操作一次）就会减少 $3$ 个奇数并使总和减少 $1$，那么答案肯定与奇数个数有关。模拟一下奇数个数为 $0,1,2$ 的情况就能发现，当奇数个数 $n_1\bmod 3=1$ 时答案为 $s-\lfloor\frac{n_1}{3}\rfloor-1$，否则答案为 $s-\lfloor\frac{n_1}{3}\rfloor$，其中 $s$ 为初始序列总和。对每个前缀简单计算即可，注意特判前缀长度为 $1$ 的情况。复杂度 $O(n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,a,num,s;
inline int read(){
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x;
}
signed main(){
    T=read();
    while(T--){
        n=read();num=s=0;
        for(int i=1;i<=n;i++)a=read(),s+=a,num+=(a&1),printf("%lld ",s-num/3-(num%3==1&&i>1));
        printf("\n");
    }
    return 0;
}
```

（逃

---

## 作者：Drind (赞：0)

### 题目解析

给定一个数列 $a$，长度为 $n$，每次操作删除两个数，如果和为奇数就加入他们的和减一，偶数就加入他们的和，先手要使剩下的数最大，后手要使剩下的数最小，求对于 $a$ 数列每个前缀的答案。

显然先手会尽可能选择两个奇偶性相同的数合并，因为总和不变。后手会选择两个奇偶性不同的数合并，因为总和减一，每一轮操作，如果奇数个数够多，那么每次一定会减少三个奇数（先手优先选择两个奇数合并，因为这样就不会给后手减一的机会），且每轮操作过后总和减一。

如果奇数个数除以三余零或二，那么不需要再减，否则需要减一（奇数还需要和别人合并，这步是必须的）。

记得特判长度为一的情况。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;

inline void fake_main(){
	int n,tot=0; cin>>n;
	int even=0;
	for(int i=1;i<=n;i++){
		int t; cin>>t;
		tot+=t; if(t%2==1) even++;
		if(i==1) cout<<tot<<" ";
		else cout<<tot-(even/3)-(even%3==1)<<" ";
	}
	cout<<"\n";
}

signed main(){
	ios::sync_with_stdio(false);
	int t; cin>>t;
	while(t--) fake_main();
}

```

---

## 作者：zzx0102 (赞：0)

给各位介绍一下有个傻逼赛时写了个抽象的 DP。

考虑答案肯定是 $\sum\limits_{j=1}^i a_j-x$。

第一部分用前缀和维护。

第二部分与奇数个数和是否有偶数还有此时轮到谁先走。

考虑合并的时候如果 $a_i+a_j$ 是偶数，则答案不变。

否则 $2\lfloor \dfrac{a_i+a_j}{2}\rfloor=a_i+a_j-1$，答案减一。

然后考虑 $dp$，$dp_{i,0/1,0/1}$ 表示有 $i$ 个奇数，轮到谁先走，此时有没有偶数的答案。

考虑合并一次就会有偶数，所以 $dp_{i,0/1,0}$ 只在 $i\le 2$ 时有用。

接下来就可以去掉一维。

$dp_{i,0}$ 表示此时 Masha 走，显然她会和并 $2$ 个奇数。

而 $dp_{i,1}$ 表示 Olya 走，她会通过将奇数和偶数合并的方式走。

所以 $dp_{i,0}=dp_{i-2,1},dp_{i,1}=dp_{i-1,0}+1$。

然后再维护一个奇数个数的前缀和即可。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
const int N = 100010; int s1[N], s2[N], a[N], dp[N][2][2];
signed main() {
	ios::sync_with_stdio(0);
	int t; cin >> t; dp[1][0][0] = dp[1][1][0] = 1, dp[2][0][0] = dp[2][1][0] = 0;
	dp[1][1][1] = dp[1][0][1] = 1; dp[2][1][1] = 2;
	for(int i = 3; i <= 100000; i++) {
		dp[i][1][1] = max(dp[i - 1][0][1] + 1, dp[i - 2][0][0]);
		dp[i][0][1] = max(dp[i - 2][1][0], dp[i - 2][1][1]);
//		dp[i][1][1] = 
	}
//	cout << dp[5][0][1] << '\n';
	while(t--) {
		s1[0] = s2[0] = 0;
		int n;
		cin >> n;
		for(int i = 1; i <= n; i++) {
			cin >> a[i];
		}
		for(int i = 1; i <= n; i++) {
			s1[i] = s1[i - 1] + a[i];
			s2[i] = s2[i - 1] + (a[i] & 1);
		}
		cout << a[1] << ' ';
		for(int i = 2; i <= n; i++) {
			if(s2[i] == 1) cout << s1[i] - 1 << ' ';
			else cout << s1[i] - dp[s2[i]][0][1] << ' ';
		}
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：Crazyouth (赞：0)

## 分析

可能是本年最后一篇 tj 啦。

注意到数列和只有在 $a_i+a_j$ 为奇数的时候才会 $-1$，否则是不变的，所以先手肯定会优先选择同奇偶性的，后手反之，每次选择以后多会获得一个偶数。既然先手想让后手输，那就要尽量保证序列中不存在异奇偶性的两数，但是每次操作后都会多出来一个偶数，所以她肯定会选择使用两个奇数，此时后手再用一奇一偶，这就是一轮，每完成一轮，数列和 $-1$，所以答案是 $sum-\lfloor\frac{odd}{3}\rfloor$（$sum$ 是原数列和，$odd$ 是原数列奇数个数），但是还不止，由于可能有无法凑成一轮的奇数，我们需要考虑 $odd$ 模 $3$ 余 $1$ 的情况，此时先手没有办法去两个奇数，她就只能选偶数，后手就会再让数列和 $-1$，所以如果 $odd\equiv1(\bmod3)$，那么答案还要减一，就做完了。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[100010];
void solve()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cout<<a[1]<<' ';
	int odd=a[1]%2,sum=a[1];
	for(int i=2;i<=n;i++)
	{
		odd+=a[i]%2;
		sum+=a[i];
		cout<<sum-(odd/3+(odd%3==1?1:0))<<' ';
	}
	cout<<endl;
}
signed main()
{
	int t;
	cin>>t;
	while(t--)
	{
		solve(); 
	}
	return 0;
} 

---

## 作者：luqyou (赞：0)

# 思路

分别考虑二人的决策。

如果要使得和最小，那么只需要每次将一个奇数和一个偶数合并，那么总和就会减小 $1$，并使得奇数数量 $-1$。

那么想要使得和最大的那个人每次就会尽可能地将两个奇数合并，并使得奇数数量 $-2$。

假设我们需要计算 $[1,i]$ 的答案，我们先统计一下这一段中的奇数数量（记为 $c$），然后若数量模 $3$ 余 $1$，那么说明循环 $-2,-1-2,-1,\dots$ 之后还会剩下一个奇数。那么显然先手只能用它和一个偶数合并，所以答案为 $i-\lfloor \dfrac{3}{c} \rfloor -1$，否则一定有完整的周期或者最后剩下两个奇数，答案为 $i-\lfloor \dfrac{3}{c} \rfloor$。

其实可以增强成带修+区间查询。

---


# Everything Nim

## 题目描述

Alice 和 Bob 在用 $n\ (n\le2\times10^5 ) $ 堆石子做游戏。在其中一位玩家的回合里，他可以选择一个不超过当前所有**非空**堆中石子数量**最小值**的**正整数** $ k$，并从目前所有非空堆中移除 $k$ 颗石子。当一名玩家在他的回合中无法进行操作时（此时所有石子堆都是空的），即判为负。

现在给出 $n$ 堆石子的初始石子数，已知 Alice 先手且两人都足够聪明，请你判断最后谁会获胜。

---

## 样例 #1

### 输入

```
7
5
3 3 3 3 3
2
1 7
7
1 3 9 7 4 2 100
3
1 2 3
6
2 1 3 4 2 4
8
5 7 2 9 6 3 3 2
1
1000000000```

### 输出

```
Alice
Bob
Alice
Alice
Bob
Alice
Alice```

# 题解

## 作者：___Furina___ (赞：6)

### 题意简述：
无。
### 题解：
**我们拒绝 dp！！！**

不妨先排序、去重，得到一个新的石子序列 $a_i$。

然后我们考虑先手如何保住自己的优势，考虑分类讨论：
- $a_i+1\ne a_{i+1}$ 时，先手可以拿走 $a_i-1$ 个石子，保住优势；
- $a_i+x=a_{i+x},x\mod2=1$ 时，先手还是可以拿走 $a_i-1$ 个石子，保住优势；
- $a_i+x=a_{i+x},x\mod2=0$ 时，先手可以拿走 $a_i$ 个石子，保住优势；

这么看起来，先手必胜啊。

**但是我们遗漏了一个情况**：$a_1=1$

当 $a_1=1$ 时，先手无法拿走 $a_i-1$ 个石子，只能你拿一下，我拿一下，直到 $a_x\ne x$，此时拿走 $a_{x-1}$ 的玩家必败。

所以我们只需要判断满足 $a_x=x$ 的 $x$ 的最大值就可以了。

### 注意：
- 如果整个序列都满足 $a_i=i$，则最后一个拿走的玩家获胜；
- 如果一开始就不满足 $a_1=1$，则先手获胜。
### 代码如下：
```cpp
#include<bits/stdc++.h>
#define N 200010
#define I_love_Furina return//发电+防抄袭
#define forever 0
#define int long long
using namespace std;
int n,T,m,a[N];
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n;
		int sum=0,x=1;
		for(int i=1;i<=n;i++)cin>>a[i];
		sort(a+1,a+n+1);//排序
		n=unique(a+1,a+n+1)-a-1;//去重
		int flag=0;//求解上文的x
		for(int i=1;i<=n;i++)if(a[i]!=i){flag=i-1;break;}else if(a[i]==i)flag=-1;//求解
		if(flag%2==1&&flag!=n||n%2==0&&flag==-1)cout<<"Bob"<<endl;//注意事项
		else cout<<"Alice"<<endl;
	}
  I_love_Furina forever;//完结撒花
}
```
点个赞再走！！！

---

## 作者：ikunTLE (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/CF1965A)

### 思路

由于答案与石子的数量有关，且每一次都可以将整个序列的高度降低 $1$，可以将降低高度的过程看作是**差分**。

接下来处理移除石子的最优解，就需要判断哪一方处于优势——处于优势的一方会一直处于优势。但是如果第一个石子是 $1$，优势就“发挥不出来”，只能判断最大的 $a_k=k$ 的最大值。

由此得知，胜者取决于差分后第一个差值不为 $1$ 时处于优势的人。

### 做法

1. 排序并去重（可以用`set`），差分。

2. 判断 $a_i=1$ 的情况。

3. 找出第一个差值不为 $1$ 时处于优势的人。

---

## 作者：MoyunAllgorithm (赞：5)

这次的 A 有点难啊...

**分析**

注意一次取是取所有。因此重复的值可以当做一个。

将数组排序并差分。如样例 $\{5,7,2,9,6,3,3,2\}$ 可转为差分数组 $\{2,1,2,1,1,2\}$。你会注意到：

- 若该元素为 $1$，则取的人只能取 $1$ 个；

- 否则，取的人可以全取完，或者取到只剩一个，此时可以“攻守易势”，先手和后手转换。我们认为取的这个人具有“主动权”。

如果一个人掌握了“主动权”，会怎么样呢？**他从此将永远掌握主动权**。

- 如果后面的某次攻守易势机会距离现在有偶数个 $1$，则若此时他全取走，那次他仍有主动权；

- 如果后面的某次攻守易势机会距离现在有奇数个 $1$，则若此时他取到只剩 $1$，此时“攻守易势“触发，那次他也有主动权。

因此只需要找到谁具有第一次攻守易势机会，也就是第一个非 $1$ 的差分即可。

---

## 作者：yzy4090 (赞：3)

[原题链接](https://www.luogu.com.cn/problem/CF1965A)  

首先可以发现因为石子是同时拿的，所以对于数目一样的两堆石子，在它们上做的操作是完全一致的。这告诉我们答案仅与石子的数量有关，而与石堆的数量无关。  
其次每次拿的石子个数根据题意一定不能超过石子最少的石堆的数目，这说明拿石子的过程类似一个阶梯（也就是去重后的差分数组）。  
样例第五组数据画出来的阶梯如下：  
![](https://cdn.luogu.com.cn/upload/image_hosting/b3j13o3x.png)  

在阶梯上，每次都只能抽走最下面一阶的一段，或者说把它的厚度降低。  
接下来有几个性质：  
- 对于厚度为 $1$ 的一阶，先后顺序会交换。  
- 对于厚度不为 $1$ 的一阶，这阶的先手拥有下一阶的先手的决定权（若拿 $a$ 个，则交换；若拿 $a-1$ 个，则不变）。  

因此我们得知：  
若所有的阶梯高度均为 $1$，则每阶的先手会不断交换，胜者取决于阶梯的个数。  
否则第一个高度不为 $1$ 的阶梯的先手则有整局的决定权，胜者也将是他。  

至此可以写出代码：  
```
sort(a+1,a+n+1);
ptr=0;
bool all1=1;
for(int i=1;i<=n;i++)if(a[i]!=a[i-1])
	gap[++ptr]=a[i]-a[i-1],all1&=(gap[ptr]==1);
if(all1)puts(ptr&1?"Alice":"Bob");
else for(int i=1;i<=ptr;i++)
	if(gap[i]!=1){
		puts(i&1?"Alice":"Bob");
		break;
	}
```

---

## 作者：hard_shuati (赞：2)

比赛结束后 `VP` 的，好题。

题面：[零和游戏](https://www.luogu.com.cn/problem/P2197)，但是每次必须取**所有**堆中数量相同的石子。

我们可以先把石子数相同的几堆看作一堆，因为它们会被取走相同数量的石子，剩余石子数量也是相同的。

或者说，[每次取 $1 \sim n-2$ 颗石子在最优策略下和每次取 $n-1$ 颗石子一样。](https://www.luogu.com.cn/paste/vj7h1m2o)（这里是证明过程）

所以，题面就简化为：

`Alice` 和 `Bob` 在用 $n\ (n\le2\times10^5 ) $ 堆**数量互不相同**的石子做游戏。在其中一位玩家的回合里，设当前非空最小堆的石子数为 $k$，他可以进行两种操作：


1. 从目前**所有**非空堆中移除 $k$ 颗石子。

2. 从目前**所有**非空堆中移除 $k-1$ 颗石子。

操作完成后，如果石子堆被全部清空，这位玩家判胜。

现在给出 $n$ 堆石子的初始石子数，已知 `Alice` 先手且两人都执行最优策略，请你判断最后谁会获胜。

多测，所有 $n$ 的和不超过 $2\times10^{5}$。

我们接下来发现，**除非 `Alice` 不得不被动拿 $1$ 颗石子，否则 `Alice` 必有必胜策略（每一次给 `Bob` 留 $1$ 颗石子，保持 `Bob` 的被动，最后一次拿完）**，对于 `Bob` 同理。

如：当每堆石子数分别为 `3 4 5 6 7 8 9` 时，`Alice` 有必胜策略：

1. 第一次从每堆石子里面取 $3$ 颗。

2. 接下来每步每人只能从所有非空石子堆中取 $1$ 颗，所以最后一颗会被 `Alice` 取到。

再如：当每堆石子数分别为 `3 4 5 6 7 8 9 10` 时，`Alice` 仍有必胜策略：

1. 第一次从每堆石子里面取 $2$ 颗。

2. 接下来每步每人仍然只能从所有非空石子堆中取 $1$ 颗，所以最后一颗会被 `Alice` 取到。

因此只需要先排序、去重（把石子数相同的几堆看作一堆），并将移除的几堆标为无效（修改 $n$ ），接下来不断模拟被动操作并更换操作者，直到石子堆被拿完或某一人可以主动操作为止，拿完者或主动操作者就是赢家。

代码易得。

---

## 作者：junee (赞：1)

# CF1965A 题解

## 题目分析

根据题意，我们可以发现当我们取完第 $i$ 堆时，所有小于第 $i$ 堆石子数量的肯定已经被取完了，所以我们可以先去重再排序，得到一个由小到大的数组。

我们考虑当只剩一堆时，那么此时谁先手谁赢。当剩两堆时，我们记较小的一堆数量为 $d$ ，那么我们先手可取石子的范围就为 $1 \leqslant k \leqslant d$ 。我们可以发现，当 $d \geqslant 2$ 时，此时先手的人可以构造一种情况使后手要多取一次，且后手只能取一颗石子，使先手取石子时只剩下一堆，此时先手必胜。即先手取 $d-1$ 个，而 $d$ 需满足 $d \geqslant 2$ ,因为不能取 0 个石子所以只要最小堆数个数 $d \geqslant 2$ 此时的先手必胜。由此我们推广到 $n$ 堆时，发现只要最小堆数个数 $d \geqslant 2$ 此时的先手必胜。

如果一直不满足上述情况，我们就枚举一人一颗的取。

## Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstring> 
using namespace std;
const int N=2e5+10;
int a[N],b[N];
int n;
int main(){
	int T;
	cin>>T;
	while(T--){
	    int tt=1;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		sort(a+1,a+1+n);
		int lastopt=-1,opt=1;
		n=unique(a+1,a+1+n)-a-1;
		
		if(a[1]!=1&&n!=1){
		    cout<<"Alice"<<'\n';
		}
		else{
		    int f=1;
		    for(int i=1;i<=n;i++){
        	    if(a[i]-a[i-1]>=2&&i!=1){
        	        if(opt==0)cout<<"Bob"<<'\n';
        	        if(opt==1)cout<<"Alice"<<'\n';
        	        f=0;
        	        break;
        	    }
                b[tt++]=opt,opt^=1;
        	}
            if(f){
                if(n%2==1)cout<<"Alice"<<'\n';
                else cout<<"Bob"<<'\n';
            }
		}
	}
    return 0;
}
```

---

## 作者：N1K_J (赞：1)

赛事没看到 `at the most`，不过手推样例发现了这个问题。

首先当一次取的数量是根据地 $i$ 堆取时，所有数量小于 $i$ 的堆肯定都被取完了，所以我们可以把 $\{a_n\}$ 从小到大去重排序。

不妨设 $dp_i$ 表示对于第 $i$ 到 $n$ 个堆，已经刚好取完前 $i-1$ 堆，先手是否必胜（必胜为 $1$，否则为 $0$）。

注意到：记 $d_i = a_i-a_{i-1}$，这代表了当前 $i-1$ 个堆刚好取完后 $a_i$ 的剩余棋子数。

若 $d_i = 1$，$dp_i = dp_{i+1} \oplus 1$，即先手只能取完。

否则，如果 $dp_{i+1} = 1$，先手可以取到只剩一个石子，后手必须下一次取这个剩下的一个，先手可以在 $i+1$ 处取得先手，必胜；如果 $dp_{i+1} = 0$，先手直接取完这一堆，后手必须在 $i+1$ 处处于先手，先手必胜。

由此有 $dp_n = 1,dp_i = \begin{cases}dp_{i+1} \oplus 1 & a_i-a_{i-1}=1\\1 & a_i-a_{i-1}\not=1\end{cases}$，特别的，$a_0 = 0$。

[Code](https://codeforces.com/contest/1965/submission/258832002)

---

## 作者：WoXitao (赞：0)

CF1965A Everything Nim 题解：

[传送门](https://www.luogu.com.cn/problem/CF1965A)

这是一道关于**博弈论**的经典题目。
## 思路：

对于输入的数组 $a_i$ 进行排序并且去重，得到单调递增的序列 $b_j$，$1\le j \le cnt$。

对序列 $b_j$ 进行差分，得到新的序列 $c_j$。

序列 $c_j$ 以 $cnt-1$ 开始从上向下分析。

最开始定义一个布尔型变量 $flag\gets1$ 表示先手必胜，否则是先手必败（后手必胜）。

当 $c_j=1$ 时，先手只能变后手，$flag\gets flag\oplus1$。

当 $c_j>1$ 时，先手可以取出 $c_j-1$ 个石子使自己继续维持先手，也可以取出 $c_j$ 个石子改成后手，所以此时在下一轮先后手决定权在这一轮的先手上，先手**在此时必胜** $flag\gets1$。

## 具体步骤：

1. 对于输入的数组 $a_i$ 进行排序并去重，得到单调递增的序列 $b_j$，$1\le j\le cnt$。

2. 对序列 $b_j$ 进行差分，得到新的序列 $c_j$。

3. 对序列 $c_j$ 从 $cnt-1$ 到 $1$ 遍历：

 - 如果 $c_j=1$，$flag\gets flag\oplus1$。

 - 否则 $flag\gets 1$。
 
4. 最后，如果 $flag=1$，表示先手必胜，输出 Alice，否则输出 Bob。

---

## 作者：Resstifnurv (赞：0)

## 题解

观察到以下性质：

- 对于石子数量一样的堆，他们一定是同时被消除的。（性质 1）
- 对于石子数量不一样的堆，一定是石子少的先被消除。（性质 2）

同时，石子数量相同的堆（下文中我们将这些称为**同一种堆**）有多少个并不影响操作结果，所以我们可以将 $a$ 排序后去重再做下一步的处理。

我们发现正着推局面需要考虑后面的操作，所以尝试倒推局面。令 `wc==0` 来表示当前回合先手必败，`wc==1` 来表示当前回合先手必胜，则游戏结束的时候所有堆都被清空，这个时候是先手必败的局面，故初始设 `wc=0`。再向前推，根据性质 2，我们每次按 $a$ 从大到小（从 $a_n$ 到 $a_1$）加入一种堆，那么在当前局面下这种堆剩余的石子数为 $a_i-a_{i-1}$。此时有两种情况，我们分类讨论。

1.  $a_i-a_{i-1} = 1$

	这种情况下，当前回合的玩家只能选择 $k = 1$，下一回合变成对方先手。那么原来先手必败的局面就变成先手必胜，反之亦然。这种情况下，我们令 `wc^=1`。
    
2.  $a_i-a_{i-1} \ge 1$

	这种情况下，如果下一回合是先手必胜的（即当前 `wc==1`），那么该玩家可以选择 $k=a_i-a_{i-1}-1$ 使对家进入情况 1 的状态（可以称这个操作为“垫”一下），下一回合就变成了自己的先手必胜。可以证明选取更小的 $k$ 对自己没有好处，因为这样反而给了对家也“垫”一下的机会。  
    而如果下一回合是先手必败的，那就更简单了，直接取  $k=a_i-a_{i-1}$，把先手必败送到对家去就可以了，自己这一回合先手必胜。
    
    所以无论上一回合先手必胜还是必败，这一回合都可以做到先手必胜，所以令 `wc=1`。
    
当最后一种堆（初始时 $a$ 最小的堆）也加入之后，局面就变成了初始局面。此时的先手必胜/必败就表示了 Alice 的必胜/必败，根据当前 `wc` 输出答案即可。

代码很短，去掉头文件和快读就 21 行。

```cpp
int T,n;
const int N=2e5+10;
int a[N];

int main(){
	T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++) a[i]=read();
		sort(a+1,a+1+n);
		int cnt=(unique(a+1,a+1+n)-a)-1;
		int wc=0;
		for(int i=cnt;i>=1;i--){
			if(a[i]-a[i-1]>1) wc=1;
			else wc^=1;
		}
		if(wc) printf("Alice\n");
		else printf("Bob\n");
	}
	return 0;
}
```

---

## 作者：zhaoyiburui (赞：0)

## 思路
在这道题中，能够获胜的关键策略是**限制对手取石子的个数**（也就是让对手只能取 $1$ 个），从而逼迫对手就范。   
下面我们将利用这个策略，证明在一些子情况下先手必胜，从而推出我们的关键结论：**在最小堆的石子数大于等于 $2$ 的情况下，先手必胜**。
## 证明
在规则中，每次取石子时，是对所有堆进行取石子的操作，而且若某堆石子数为 $0$，则其在今后的决策中不再需要考虑。由此我们可以首先得到以下两个引理。
### 引理 $1$
*---相同石子数的堆的个数对获胜者是谁没有影响。*   
这告诉我们，我们可以对数据进行**消重**处理，对于石子数相同的堆，只留下其中的一个。
### 引理 $2$
*---石子数越小的堆总是先变为 $0$。*   
显然的结论，但是这个结论告诉我们，我们可以对原数据进行**排序**操作，从小往大考虑，达到忽视石子数变为 $0$ 的堆的目的。  
   
在下面所有子情况的证明中，默认每组数据都进行了以上的**消重**与**排序**的操作。   
为了方便子情况的证明，我们定义 $\Delta h_i$ 为排序后每相邻两堆之间的石子数之差。同时再次强调，以下所有子情况**最小堆石子数大于等于 $2$。**
### 子情况 $1$
***---$\Delta h_{i} \ge 2$，即每相邻堆石子数之差都大于等于 $2$。***

先手方可以做以下的决策：每次不取完最小堆的所有石子，而是故意留下一个，这样后手方由于规则不得不只取这一个石子，之后先手方循环这一操作，一定能最后一个把所有石子取走。先手必胜。

大家多加思考可以发现，$\Delta h_{i} \ge 2$ 是为了保证在每次先手方重新取石子时，能够保证新的最小堆至少有一个可取而又正好能留下来一个（$１＋１＝２$），从而保证先手方能够持续使用这一策略。也就是说，这一限制条件只在整个游戏流程**中间**起作用。因此，我们可以得到这个子情况的一个**推广**：若只有最后一堆（最大堆）恰与前一堆相差 $1$ 个石子（也就是只有最后一个不满足 $\Delta h \ge 2$），先手也必胜，因为在取最后一堆时，先手方不再需要考虑留下一个石子恶心后手方，直接拿走这一个石子获胜即可。这一推广将在子情况 $3$ 的证明中起到关键作用。
### 子情况 $2$ 
***---在最小堆和最大堆中间存在不连续的若干个 $\Delta h_i = 1$，其他 $\Delta h_i \ge 2$。***   
先考虑只有一个 $\Delta h = 1$，如下图。![](https://cdn.luogu.com.cn/upload/image_hosting/6qyj7mue.png)
我们根据子情况 $1$ 可以得出在前 $i$ 堆下先手必胜，也就是先手方可以最后一个取完第 $i$ 堆的所有石子，从而只给后手方留下第 $i+1$ 堆的一个，而后手方不得不取走这一个，之后又进入了子情况 $1$，先手必胜。   
多个不连续的 $\Delta h = 1$ 相当于多个每段只有一个 $\Delta h = 1$ 的情况，叠加起来仍是先手必胜。
### 子情况 $3$ 
***---在最小堆和最大堆中间存在连续的若干个 $\Delta h_i = 1$, 其他 $\Delta h_i > 1$。***  
我们直接考虑有多个连续 $\Delta h_i = 1$ 的情况，比如 $4$ 个，如下图。
![](https://cdn.luogu.com.cn/upload/image_hosting/fek135g4.png)
我们发现，在子情况 $2$ 中，后手方输是因为不得不拿走了这些 $\Delta h = 1$ 的堆中的最后一堆（在上图中即第 $i+4$ 堆），从而导致进入了后面先手方全盘掌控的子情况 $1$。而在这一串 $\Delta h = 1$ 之间，先手方和后手方的取法是固定的，每次只能取一个，因此输赢的结局会交替显现，如下图。 
![](https://cdn.luogu.com.cn/upload/image_hosting/mr15ehq3.png)
这时大家可能会想，这是不是和奇偶性有关呢？很遗憾的是，在目前奇偶性还发挥不了作用，为什么呢？   
我们可以看到无论有多少个连续 $\Delta h = 1$，第 $i$ 堆或第 $i+1$ 堆总有一堆是谁先拿光谁必胜，但根据子情况 $1$ 及其推广，先手方**完全可以决定**最后拿光这两堆中的哪一堆。故先手仍必胜。
### 结论
不难看出，所有**最小堆的石子数大于等于 $2$ 的情况**都可以拆分为若干个上述三个子情况的组合，且先手胜在这些情况间具有传递性。故**在最小堆的石子数大于等于 $2$ 的情况下，先手必胜**。
## 具体问题的解决方法
我们为什么一再强调最小堆的石子数大于等于 $2$ 呢？这是因为，如果在一开始时最小堆的石子数等于 $1$，那么先手方就没有选择权，只能取走这一个石子，从而被迫将主动权交给后手方，相当于**先后手强制互换**了。有趣的是，此时如果先手取完所有堆的一个后，剩下的最小堆石子数仍为 $1$，那么就又要进行一次强制的先后手互换，直到互换后最小堆的石子数不为 $1$，那么此时的“先手”便是最终的赢家。因此在代码中，我们只需要解决在启动阶段，先后手强制交换了多少次即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 200005
int t, n;
map<int, bool> hs; 
int a[MAXN] = {0};
void solve()
{
    int in = 1, mins = INT_MAX;
    scanf("%d", &n);
    hs.clear();
    for(int i = 1; i <= n; i++)
    {
        int t;
        scanf("%d", &t);
        if(hs[t]) continue; //消重
        hs[t] = 1, a[in++] = t, mins = min(mins, t);
    }
    if(mins > 1) //最小堆大于1，直接判胜
    {
        printf("Alice\n");
        return;
    }
    sort(a + 1, a + in); //排序
    int cnt = 0;
    for(int i = 1; i < in - 1; i++) //注意i的枚举范围
    {
        if(a[i] - a[i - 1] == 1) cnt++;
        else break; //关键的break
    }
    if(cnt % 2 == 0)
        printf("Alice\n");
    else
        printf("Bob\n");
}
int main()
{
    cin >> t;
    while(t--) solve();
    return 0;
}
```

---


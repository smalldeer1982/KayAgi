# 0, 1, 2, Tree!

## 题目描述

查找满足条件的有根树 $^{\dagger}$ 的最小高度。

其中 $a+b+c$ 个顶点满足以下条件：

- $a$ 个顶点恰好有 $2$ 个子顶点，

- $b$ 个顶点恰好有 $1$ 个子顶点，

- $c$ 个顶点没有子顶点。

如果没有这样的树，输出 $-1$。

如：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1950F/0c6b0806a993f448977c57ce3c99533fc6610921.png)

上面的树植根于顶部顶点，每个顶点都标有它的子节点数。

这里 $a=2,b=1,c=3$，高度为 $2$。

 $^{\dagger}$：有根树是指一个没有循环的连通图，有一个特殊的顶点称为根。在有根树中，在由边连接的任意两个顶点，一个顶点是父顶点（离根更近的顶点），另一个是子顶点。

树中两个顶点之间的距离是它们之间最短路径中的边数。有根树的高度是从顶点到根部的最大距离。

## 说明/提示

第一个测试用例如图所示。树的高度不能低于 $2$。

在第二个测试用例中，您可以形成一个只有一个顶点且没有边的树。它的高度为 $0$，这显然是最佳的。

在第三个测试用例中，您可以形成一个由单个边连接的两个顶点的树。它的高度为 $1$，这显然是最佳的。

## 样例 #1

### 输入

```
10
2 1 3
0 0 1
0 1 1
1 0 2
1 1 3
3 1 4
8 17 9
24 36 48
1 0 0
0 3 1```

### 输出

```
2
0
1
1
-1
3
6
-1
-1
3```

# 题解

## 作者：Shadow_T (赞：7)

### 题目大意

一棵树有 $a$ 个儿子数为 $2$ 的结点，有 $b$ 个儿子数为 $1$ 的结点，有 $c$ 个儿子数为 $0$ 的结点。

求这棵树的最小高度。

### 题目分析

- 我们称 $k$ 类型结点为儿子数为 $k$ 的结点。

很明显，每每加上一个 $2$ 类型结点，那么叶节点数量加 $1$。

所以，$c \neq a+1$，直接无解。

我们先特判 $a=0$，$b=0$ 的情况。

- $a=0$ 那么全由 $1$ 类型结点组成，构成一条链，输出 $b$。

- $b=0$ 完全二叉树，输出 $\log a+1$。

考虑贪心。

先把所有 $2$ 类型结点摆成完全二叉树，层数为 $\log a+1$。

然后对于 $1$ 类型结点，先插在完全二叉树空余的部分，然后向下插。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
void solve()
{
	int a,b,c;
	cin>>a>>b>>c;
	if(c!=a+1)
	{
		puts("-1");
		return;
	}
	if(a==0)
	{
		cout<<b<<"\n";
		return;
	}
	int ans=log2(a)+1;
	if(b==0)
	{
		cout<<ans<<"\n";
		return;
	}
	int x=1,f,z;
	while(true)
	{
		if(a<=x)
		{
			z=a*2+(x-a);
			f=x-a;
			break;
		}
		a-=x;
		x*=2;
	}
	b-=f;
	if(b<=0)
	{
		cout<<ans<<"\n";
		return; 
	}
	cout<<ans+(b+z-1)/z<<"\n";
}
int main()
{
	int t;
	cin>>t;
	while(t--) solve(); 
}
```

---

## 作者：Frodo (赞：5)

## 前言

本题解思路来自 [评论区](https://codeforces.com/blog/entry/127664)。

## 题面翻译 

一颗二叉树，由 $a$ 个有两个子节点的节点，$b$ 个只有一个子节点的节点以及 $c$ 个叶节点构成（无解输出 $-1$）。

求最小深度（根节点深度为 $0$）。

共 $T$ 组数据。

## 思路

我们可以先用“有两个子节点的节点”和“叶结点”构成完全二叉树，此时要求 $c=a+1$，否则无解。

此时深度为 $\lfloor \log_2 a \rfloor$。

然后，用 $2^{\lfloor \log_2 a \rfloor}-c$ 个“只有一个子节点的节点”将其补为一颗任意叶结点到根都相同的二叉树。

若 $b<2^{\lfloor \log_2 a \rfloor}-c$，则尽可能地填补。

令 $b' \leftarrow b - \min\{b,2^{\lfloor \log_2 a \rfloor}-c\}$。

最后，用剩余的“只有一个子节点的节点”做为“叶结点”的父节点。

此时增加的深度为 $\lfloor \frac{b'+c-1}{c} \rfloor$。

易知此时深度最小。

时间复杂度：$\Theta(T)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		int a,b,c;
		cin>>a>>b>>c;
		if(c!=a+1) cout<<-1<<endl;
		else{
			int log=a?(32-__builtin_clz(a)):0;
			b-=min(b,(1<<log)-c);
			cout<<log+(b+c-1)/c<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Yharimium (赞：3)

题目链接：[CF1950F](https://www.luogu.com.cn/problem/CF1950F)

## 题目大意

建一棵有 $a+b+c$ 个节点的树，其中

- $a$ 个节点有 $2$ 个子节点（$a$ 类节点）
- $b$ 个节点有 $1$ 个子节点（$b$ 类节点）
- $c$ 个节点无子节点（叶子节点）

输出这样的树的高度的最小值。若这样的树不存在，则输出 $-1$。

树的高度：从根节点出发的最长路径的边数。

## 方法

采用贪心算法。

我们从根节点往下建树。容易发现，优先采用 $a$ 类节点比优先采用 $b$ 类节点划算，建出来的树的高度更小。

![](https://cdn.luogu.com.cn/upload/image_hosting/nvf8obw1.png)

每次选择深度最小的叶子节点，将其发展为 $a$ 类节点。$a$ 类节点全部用光后再发展 $b$ 类节点即可。

---

这样的树什么时候才不存在呢？观察发现

- 每发展一个 $a$ 类节点，叶子节点的数量增加 $1$；
- 每发展一个 $b$ 类节点，叶子节点的数量不变。

因此，最终叶子节点必有 $a+1$ 个。若 $a+1\not=c$ 则这样的树不存在。

## 代码

``` cpp
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
	
	int t;
	cin >> t;
	
	while (t --) {
		static int a, b, c;
		cin >> a >> b >> c;
		
		if (a + 1 != c) {
			cout << -1 << endl;
			continue;
		}
		
		// 小根堆，存放叶子节点的深度
		priority_queue<int, vector<int>, greater<int>> leaf;
		
		// 一开始只有一个根节点，深度为 0
		leaf.push(0);
		
		// 最大的深度就是树的高度
		int max_depth = 0;
		
		while (a --) {
			int depth = leaf.top();
			leaf.pop();
			leaf.push(depth + 1); //
			leaf.push(depth + 1); // 发展出 2 个子节点
			max_depth = max(max_depth, depth + 1);
		}
		
		while (b --) {
			int depth = leaf.top();
			leaf.pop();
			leaf.push(depth + 1); // 发展出 1 个子节点
			max_depth = max(max_depth, depth + 1);
		}
		
		cout << max_depth << endl;
	}
	
	return 0;
}
```

---

## 作者：Clover_Lin (赞：1)

[题目链接](https://codeforces.com/problemset/problem/1950/F)
### 思路
**不能**形成树的情况：
- 第一，一棵树必须有叶子节点。所以 $c=0$ 的情况就一定不能形成一棵树。
- 其次，可以发现，我们每增加一个度为 $2$ 的节点，叶子节点就也会增加 $1$ 个。所以 $a+1 \neq c$ 的情况也肯定不行了。
- 代码片段
  ```cpp
  if (!c || a + 1 != c)
		cout << "-1" << endl;
  ```
接下来，我们考虑怎么计算答案。
  - 首先，我们把分支节点安排好。树的高度至少是 $\log_2 a$。
  - 接着我们可以计算出树的高度不变化的情况下还能放多少个节点，如果不够我们就继续将树扩大。
  - 代码片段
    ```cpp
    int cnt = 0, s = 1;
  	while (s < a + 1)
  	{
  		cnt++;
  		s *= 2;
  	}
  	if (b > s - a - 1)
  		cnt++;
  	if (b > s && b > a + 1)
  		cnt += (b - s + a) / (a + 1);
  	cout << cnt << endl;
    ```

### 完整代码
```cpp
#include <cstdio> 
#include <iostream> 
#include <algorithm>
using namespace std;


int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		int a, b, c;
		cin >> a >> b >> c;
		if (!c || a + 1 != c)
			cout << "-1" << endl;
		else
		{
			int cnt = 0, s = 1;
			while (s < a + 1)
			{
				cnt++;
				s *= 2;
			}
			if (b > s - a - 1)
				cnt++;
			if (b > s && b > a + 1)
				cnt += (b - s + a) / (a + 1);
			cout << cnt << endl;
		}
	}
	return 0;
}
```

---

## 作者：jiangxinyang2012 (赞：1)

根据二叉树的特点，度为 $0$ 的叶子结点数等于度为 $2$ 的结点数加一，即必须符合 $c = a + 1$。若不符合则无法构成树，直接输出 `-1`。

先特判 $a = 0$ 的情况。如果 $a = 0$ 那么全由度为 $1$ 结点组成，构成一条链，输出 $b$。构造这棵二叉树，可采用贪心思路，需要把 $a$ 节点尽量放在上面，再接着放 $b$，最后一层放 $c$，也就是尽量往满二叉树靠近。

具体地，先放 $\lceil \log a \rceil$ 层 $a$ 节点，接着在这一层剩下的位置放其他节点，最后在下面放 $b$ 和 $c$。

---

## 作者：Peaky (赞：1)

按照惯例，应该先有[传送门](https://www.luogu.com.cn/problem/CF1950F)。
### 题目
给定三个数 $a,b,c$，使得一棵树上有 $a$ 个节点恰好有两个子节点， $b$ 个节点有一个子节点和 $c$ 个叶子节点。
### 思路
先判断这三个点合不合法。
1. 如果 $c\ne a $ 则不合法。
2. 如果 $c = 0$ 则不合法。   

再找出最小高度。   
众所周知，树每增加一层，总节点个数将会乘 $2$。所以我们可以用一个变量 $h$ 来计算高度，当 $2^h\geq a+1$ 时，便可以停止计算。  
**为什么是** $a+1$ **而不是** $a$？   
因为要保证 $h$ 最小，所以每一个 $a$ 必须接在 $a$ 的子树上，每接一次，最底层节点个数就会加 $1$。  

剩下的就是把节点 $b,c$ 接上去了。

### AC code
```cpp
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef long long ll;
/*

*/
int t,a,b,c,d,h;
int main(){
	cin>>t;
	while(t--){
		cin>>a>>b>>c;
		d=1,h=0;
		while(d<a+1) h++,d*=2;
		if(c!=a+1||!c) cout<<-1<<endl;
		else {
			if(b>d-1-a) h++;
			if(b>d&&b>(a+1)) h+=(b-d)/(a+1)+!!((b-d)%(a+1));
			cout<<h<<endl;
		}
	}
	return 0;
}
```

---

## 作者：_Link_404 (赞：1)

![](https://cdn.luogu.com.cn/upload/image_hosting/gctp39h5.png)

上面的树以顶点为根，每个顶点都标有子顶点的数量。这里是
 $a=2$、$b=1$、$c=3$，高度是 $2$。

有根树是一个没有环的连通图。在有根树中，由边连接的任意两个顶点中，一个顶点是父顶点（离根较近的顶点），另一个顶点是子顶点。

树中两个顶点之间的距离就是它们之间最短路径的边数。有根树的高度是顶点到根的最大距离。

首先特判掉的情况 $2a+b+1\not=a+b+c$（即 $a+1\not=c$），易知这种情况无解，其他情况都有解。

其次，如果没有子节点数量为二的父节点（即 $a=0$）
，那树高显然为 $b$。

其他情况应当贪心地填，将 $a$ 类节点尽可能往上填，不够再补 $b$ 类，先将完全二叉树补满，再往下面一排一排插。

[原出处](https://www.cnblogs.com/Iictiw/p/18139415)

**code:**
```cpp
#include <bits/stdc++.h>
using namespace std;
int T, n;
string s;
void f(int a, int b, int c)
{
    if (a + 1 != c) {
        cout << -1 << endl;
        return;
    }
    if (a == 0) {
        cout << b << endl;
        return;
    }
    int res = 1, t;
    bool f = 0;
    for (int x = 1; !f; a -= x, x *= 2, res++)
        if (a <= x) {
            t = a * 2 + (x - a);
            b -= x - a;
            f = 1;
        }
    if (b <= 0) {
        cout << res - 1 << endl;
        return;
    }

    cout << res + (b + t - 1) / t - 1 << endl;
}
int main()
{
    cin >> T;
    while (T--) {
        int a, b, c;
        cin >> a >> b >> c;
        f(a, b, c);
    }
    return 0;
}
```

---

## 作者：YFF1 (赞：0)

## 题意：
给定一棵树，给定含有一个，两个和无相连子节点个数的节点个数，求能否根据这些条件构造一棵树，若可以，求该树叶子节点到根节点的距离。
## 思路：
很显然，每个二节点会产生两条边，把剩余的二节点和一节点排满所有边之后，还会剩下二节点个数加一条边用于安放零节点，因此不满足这个条件就无法构造这颗树，然后再将每一层都尽可能排满，先排二节点，再排一节点，剩下放零节点，一层放满了就开下一层。
## 代码：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,a,b,c;
signed main () {
	cin>>t;
	while(t--){
		scanf("%lld%lld%lld",&a,&b,&c);
		if(a+1!=c){//无法构造 
			cout<<-1<<endl;
			continue;
		}
		int cnt=0,num=0,num2,sum0,sum1,sum2,ans;//贪心构造点的策略 
		if(a==0)cout<<b<<endl;//只有0和1节点，形成一条链 
		else{
			cnt=log2(a)+1;
			ans=cnt;
			num=pow(2,cnt-1)-1;
			num2=pow(2,cnt-1);//先计算2节点可以放几层 
			sum0=(a-num)*2;
			sum1=num2-(a-num);
			sum2=sum0+sum1;//2节点可能放不满 
			int b2=b;
			b2-=sum1;
			sum1-=b;
			b=b2;//剩下的部分由1节点补上 
			if(sum1<0){
				ans+=b/sum2;//1节点可以放几层 
				if(b%sum2!=0)ans++;//1节点放不下，新开一层 
				ans++;//0节点再放最后一层（0节点一定只会放1层，因为它们没有子节点） 
			}
			else if(sum1==0||(sum1>0&&c>sum1))ans++;//假设1节点补上后就用完了 
			cout<<ans-1<<endl;//求的是距离等于层数-1 
		}
	}
	return 0;
}
```

---

## 作者：PDAST (赞：0)

## 题意
构建一棵高度最小的，有 $a$ 个有两个子节点的节点，$b$ 个有一个子结点的节点，$c$ 个没有子节点的节点的树，请输出输出他的高度。
## 思路
我的思路是先判断是否成立，接着建立一个小根堆，每次找到一个还能容纳节点的高度最低的节点，并插入这个节点，即放进堆里，若原先节点不再可容纳新节点，则删去原节点，这样可以保证高度最小，容纳顺序为：
1. 可以容纳两个节点的节点；
2. 可以容纳一个节点的节点；
3. 不能容纳节点的节点。

最后输出即可。
## 代码
~~~cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define x first
#define y second
using namespace std;
int blt(int a,int b,int c){
	int maxn=0;
	priority_queue<PII,vector<PII>,greater<PII>>q;
	if(a){
		q.push({0,2});
	}
	for(int i=1;i<a;i++){
		PII pii=q.top();
		q.pop();
		if(pii.y>1){
			q.push({pii.x,pii.y-1});
		}
		q.push({pii.x+1,2});
		maxn=max(maxn,pii.x+1);
	}
	if(!a&&b){
		q.push({0,1});
		b--;
	}
	for(int i=1;i<=b;i++){
		PII pii=q.top();
		q.pop();
		if(pii.y>1){
			q.push({pii.x,pii.y-1});
		}
		q.push({pii.x+1,1});
		maxn=max(maxn,pii.x+1);
	}
	while(q.size()){
		maxn=max(maxn,q.top().x+1);
		q.pop();
	}
	return maxn;
}
int main(){
	int T;
	cin>>T;
	while(T--){
		int a,b,c;
		cin>>a>>b>>c;
		if(a+1!=c){
			cout<<"-1\n";
			continue;
		}
		cout<<blt(a,b,c)<<"\n";
	}
}
~~~

---

## 作者：eb0ycn (赞：0)

传送门：[CF1950F](https://www.luogu.com.cn/problem/CF1950F)。

## 题意

构造一棵二叉树，度数为 $2,1,0$ 的节点个数分别为 $a,b,c$。求二叉树的深度的最小值。

## 思路

首先，考虑总司令的情况。这棵树存在当且仅当 $a=c-1$，下面给出证明：

二叉树的节点总数为 $a+b+c$，则边数为 $a+b+c-1$。

而根据定义，边数还可以表示为 $2a+b$。

所以，$2a+b=a+b+c-1$，即 $a=c-1$。

考虑怎么构造这棵二叉树，根据画图可知需要把 $a$ 节点尽量放在上面，再接着放 $b$，最后一层放 $c$，也就是尽量往满二叉树靠近。

具体地，先放 $\lceil \log a \rceil$ 层 $a$ 节点，接着在这一层剩下的位置放其他节点，最后在下面放 $b$ 和 $c$。

代码实现比较简单。

## 代码

```cpp
#include<cstdio>
using namespace std;
int t,a,b,c,k,tmp;
int min(int x,int y){return x>y?y:x;}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d",&a,&b,&c),tmp=a,k=0;
		if(a!=c-1){printf("-1\n");continue;}
		if(!a){printf("%d\n",b);continue;}
		while(tmp)tmp>>=1,++k;
		b-=min(b,(1<<k)-a-1),k+=(b+a)/c,printf("%d\n",k);
	}
	return 0;
}
```

---

## 作者：Crazyouth (赞：0)

## 分析

点数不变，那么平均每层节点越多，深度越小。不难联想到对于某一层来说，它的节点最大值与它上一层节点个数和剩余节点数量有关。因此应尽可能地把子节点最多的那 $a$ 个放到深度小的位置，把次多的 $b$ 个放到仅比那 $a$ 个稍深一点的位置，$c$ 个叶子有多深放多深。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> G[300010];
int dep[300010];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		int a,b,c,now=1;
		cin>>a>>b>>c;
		for(int i=1;i<=a+b+c;i++) G[i].clear(),dep[i]=0;
		queue<int> q;
		q.push(1);
		while(q.size())
		{
			int u=q.front();
			q.pop(); 
			if(a)
			{
				a--;
				G[u].push_back(++now);
				q.push(now);
				dep[now]=dep[u]+1;
				G[u].push_back(++now);
				q.push(now);
				dep[now]=dep[u]+1;
			}
			else if(b)
			{
				b--;
				G[u].push_back(++now);
				q.push(now);
				dep[now]=dep[u]+1;
			}
			else c--;
		}
		if(a||b||c)
		{
			cout<<-1<<'\n';
			continue;
		}
		int ans=0;
		for(int i=1;i<=now;i++) ans=max(ans,dep[i]);
		cout<<ans<<'\n';
	}
}
```

---

## 作者：Dtw_ (赞：0)

[cf](https://codeforces.com/contest/1950/problem/F)
# 题目大意
有一颗树，规定 $x$ 类型节点有且仅有 $2$ 个儿子，$y$ 型节点有且仅有 $1$ 个儿子，$z$ 型节点无儿子。

给你 $a$ 个 $x$ 节点，$b$ 个 $y$ 节点，$c$ 个 $z$ 节点，求这棵树的最小的高度（钦定根节点高度为 $0$）。

# 思路
采取贪心策略。

首先我们希望层数越少越好，那就是每一层尽量多放，那么如何尽量多呢？

有 $x$ 类型的节点先放他，没了就放 $y$ 型的，否则就放 $z$ 型的。

那么关于如何放，我们可以记录一下每一层应该放多少个，当前层放了 $x$ 那么下一层可放置的次数就加 $2$，$y$ 的话就加 $1$，否则不加。每一层都是这样，直到我们的点全放完为止。

如果放不完（$x,y$ 类型一个点都没有，$z$ 型的有）那么就判断一下：如果我们还剩下一些点没放，且当前层不能放，那就输出 $-1$。

以及如果不够放（$a=1,b=0,c=0$ 他必须要放两个，但不够了）就判断如果当前层要放，但是剩下的点不够放，那也输出 $-1$。

至于正确性的话也是显然的，我们放的顺序是不影响是否成立的，不存在说我先放 $y,z$ 后放 $x$ 他就可行，而先放 $x$ 他就不行。实在不行您可以来 hack 我。

# Code
```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'

#define TRACE 1
#define tcout TRACE && cout

#define IN(o) insert(o)

#define fi first
#define se second

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int INF = 0x3f3f3f3f3f3f3f3f;

const int P = 998244353;

const int N = 1e6 + 10;

signed main()
{
	int T;
	cin >> T;
	while(T--)
	{
		int a, b, c;
		cin >> a >> b >> c;
		int k = 1; //当前层能放几个节点
		int res = 0; // ans
		int tot = a + b + c; //总共节点数
		bool f = 0; // 判断第一种 -1 情况
		while(tot)
		{
			int x = 0; // 记录下一层能放多少个点
			if(k == 0) // 我还剩下点没放，但是没位置放了，即上述思路中的第一种 -1 情况
			{
				f = 1;
				break;
			}
			for(int i=1; i<=k; i++)
			{
				if(a > 0) // 先 a 再 b 最后 c
				{
					a--;
					tot--;
					x += 2;
				}
				else if(b > 0)
				{
					b--;
					tot--;
					x += 1;
				}
				else if(c > 0)
				{
					c--;
					tot--;
				}
				else // 点不够了也不行
				{
					f = 1;
					break;
				}
			}
			k = x;
			res++;
		}
		if(f || k) // 我的点全放完了，但是我应该还要放，不够了，即上述思路中第二个 -1 情况
		{
			cout << -1 << endl;
			continue;
		}
		cout << res-1 << endl;
	}
	return 0;
}




```

---

## 作者：little_stickman (赞：0)

难度还是有一点的  
[传送门](https://www.luogu.com.cn/problem/CF1950F)   
首先容易得知如果存在度为 $2$ 的结点，那么总度数之和为 $x + 1$ ，那么判断该树是否存在的依据就是是否 $a + 1 = c$ 在该树存在的前提下要想让树的高度尽量的小，那么显然尽可能的使该树向完全二叉树靠，先填完度为 $2$ 的结点，然后依次填补度为 $1$ 的结点即可。如果不存在度为 $2$ 的结点，那么该树只有可能为一条链，讨论一下即可。  
代码如下：
```
#include<iostream>
using namespace std;
void s()
{
    int x,h,c,l;
    cin>>x>>h>>c;
    if(x)
	{
        l=x+1;
        if(l!=c)
		{
            cout<<"-1"<<endl;
            return ;
        }
		else
		{
            int d=0;
            int s=1;
            while(true)
			{
                d++;
                int o=s-1;
                int n=s*2- 1;
                s*=2;
                if(n>x)
				{
                    int r=n-x;
                    s=(x-o)*2+r;
                    if(x==o&&h==0)
					{
                        cout<<d-1<<endl;
                        return ;
                    }
                    h-=r;
                    if(h<=0)
					{
                        cout<<d<<endl;
                        return ;
                    }
					else
					{
                        cout<<d+(h+s-1)/s<<endl;
                        return ;
                    }
                }
            }
        }
    }
	else if(h)
	{
        l=1;
        if(c!=1)
		{
            cout<<"-1"<<endl;
            return ;
        }
		else
		{
            cout<<h<<endl;
            return ;
        }
    }
	else
	{
        if(c==1)
		{
            cout<<0<<endl;
            return ;
        }
		else
		{
            cout<<"-1"<<endl;
            return ;
        }
    }
}
signed main()
{
    int t;
    cin>>t;
    while(t--)
	{
        s();
    }
    return 0;
}
```
[运行结果](https://www.luogu.com.cn/record/154061821)

---

## 作者：Accepted_Error (赞：0)

### [传送门](https://www.luogu.com.cn/problem/CF1950F)
## 题目大意：
给你三个数 $a$，$b$，$c$，要构造一棵树，其中 $a$ 代表一个有两个子节点的节点，$b$ 代表一个有一个子节点的节点，$c$代表叶子节点（没有子节点），求构建的树的最小深度。

## 思路：
我们可以考虑到，如果先将有两个子节点的节点放完后再放有一个子节点的节点，再放叶子节点就能找到最小深度。

先添入有两个子节点的节点。我们定义 $dis$ 代表树的深度，$emp$ 表示一共有多少空余位置能够放节点，$las$ 表示最后一层层有多少空余位置。这样说可能比较抽象，那用下面的图来辅助理解。
![](https://cdn.luogu.com.cn/upload/image_hosting/ive4ruo4.png)
在这个图中，$dis = 3$，$emp = 5$，$las = 3$。

很容易得到 $dis = \lceil \log_2(a + 1) \rceil$，$emp = a + 1$，$las = 2^{\lfloor \log_2(a + 1) \rfloor + 1} - a - 1$，此时需要判断如果 $las = 2^{\lfloor \log_2(a + 1) \rfloor}$，即这一层是满的时，$las = 0$。

接下来就要往里添有一个子节点的节点了。因为只有一个子节点，无论添多少个，$emp$ 都为定值，只有 $dis$ 和 $las$ 会改变。因此我们要进行判断：如果 $b < las$，代表连上一层都填不满，那么层数也不会增加，继续后面的判断即可；否则要先将 $b - las$，再将 $dis$ 加上 $\lceil b \div emp \rceil$。

接下来要添入叶子节点。需要注意的是如果 $c \neq emp$，无法全部填满或有剩余，那么就无法构建出树，输出 $-1$。（可以在最开始求出 $emp$ 时判断），否则 $dis + 1$，输出 $dis$ 即可。

## Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
constexpr bool testcases = true;
template<typename T>
void read(T& x)
{
	x = 0;
	ll f = 1;
	char ch = getchar();
	while (!isdigit(ch))
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	x *= f;
}
template<>
void read(string& x)
{
	x.clear();
	x += '#';
	char ch = getchar();
	while (isspace(ch)) ch = getchar();
	while (!isspace(ch)) {
		x.push_back(ch);
		ch = getchar();
	}
}
template<typename T, typename ...Args>
void read(T& x, Args&... r)
{
	read(x);
	read(r...);
}
int a, b, c, emp, dis, las;
void solve()
{
	read(a);
	read(b);
	read(c);
	emp = a + 1;
	if (c != emp)
	{
		cout << "-1\n";
		return;
	}
	dis = ceil(log2(a + 1));
	las = 2 * pow(2, (int)log2(a + 1)) - a - 1;
	if (las == pow(2, (int)log2(a + 1))) las = 0;
	if (b > las)
	{
		b -= las;
		dis += ceil(b * 1.0 / (a + 1));
	}
	cout << dis << endl;
}
int main()
{
	if (testcases)
	{
		int T;
		cin >> T;
		while (T--) solve();
	}
	else solve();
	return 0;
}
```

---

## 作者：Gapple (赞：0)

首先我们考虑何时有解。对于满足题目条件的树，一定有 $a$ 个节点连了 $2$ 条边，有 $b$ 个节点连了 $1$ 条边，故共有 $2a + b$ 条边。同时容易发现，它有 $a + b + c$ 个节点。因为它是树，所以点数 = 边数 + $1$，即 $a + b + c = 2a + b + 1$，即 $c = a + 1$。

故在 $c \not = a + 1$ 时无解。

此时，为了让高度最小，我们可以考虑贪心。我们使用 BFS 进行连边，优先对当前节点连 $2$ 条边，若无法连 $2$ 条边再连 $1$ 条边即可。

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <map>
#include <queue>
#include <vector>

using namespace std;

using Graph = map<int, vector<int>>;
using i64 = long long;

constexpr int ROOT = 1;

vector<int> add_node(Graph& G, int son_2, int son_1, int son_0)
{
    int total = 1;
    vector<int> depth(son_0 + son_1 + son_2 + 5, 0);
    queue<int> nodes;

    nodes.emplace(ROOT);

    while (!nodes.empty()) {
        int u = nodes.front();
        nodes.pop();

        if (!G[u].empty())
            continue;

        if (son_2 > 0) {
            G[u].emplace_back(++total);
            G[u].emplace_back(++total);
            --son_2;
        } else if (son_1 > 0) {
            G[u].emplace_back(++total);
            --son_1;
        }

        for (int v : G[u]) {
            depth[v] = depth[u] + 1;
            nodes.emplace(v);
        }
    }

    return depth;
}

void solve_test()
{
    int a, b, c;
    cin >> a >> b >> c;

    if (a + 1 != c) {
        puts("-1");
        return;
    }

    Graph ans;
    auto depth(add_node(ans, a, b, c));

    cout << *max_element(depth.begin(), depth.end()) << '\n';
}

int main()
{
    int t;
    cin >> t;

    while (t-- > 0)
        solve_test();

    return 0;
}
```

---


# Circular Dance

## 题目描述

There are $ n $ kids, numbered from $ 1 $ to $ n $ , dancing in a circle around the Christmas tree. Let's enumerate them in a clockwise direction as $ p_1 $ , $ p_2 $ , ..., $ p_n $ (all these numbers are from $ 1 $ to $ n $ and are distinct, so $ p $ is a permutation). Let the next kid for a kid $ p_i $ be kid $ p_{i + 1} $ if $ i < n $ and $ p_1 $ otherwise. After the dance, each kid remembered two kids: the next kid (let's call him $ x $ ) and the next kid for $ x $ . Each kid told you which kids he/she remembered: the kid $ i $ remembered kids $ a_{i, 1} $ and $ a_{i, 2} $ . However, the order of $ a_{i, 1} $ and $ a_{i, 2} $ can differ from their order in the circle.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1095D/ba706820d7e68c6ca7fa05954588bb8c356ad841.png)Example: 5 kids in a circle, $ p=[3, 2, 4, 1, 5] $ (or any cyclic shift). The information kids remembered is: $ a_{1,1}=3 $ , $ a_{1,2}=5 $ ; $ a_{2,1}=1 $ , $ a_{2,2}=4 $ ; $ a_{3,1}=2 $ , $ a_{3,2}=4 $ ; $ a_{4,1}=1 $ , $ a_{4,2}=5 $ ; $ a_{5,1}=2 $ , $ a_{5,2}=3 $ .You have to restore the order of the kids in the circle using this information. If there are several answers, you may print any. It is guaranteed that at least one solution exists.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.

## 样例 #1

### 输入

```
5
3 5
1 4
2 4
1 5
2 3
```

### 输出

```
3 2 4 1 5 
```

## 样例 #2

### 输入

```
3
2 3
3 1
1 2
```

### 输出

```
3 1 2 
```

# 题解

## 作者：Remilia1023 (赞：4)

提供一份十分清晰简短的实现。

$a$ 的定义与输入输出中的定义一样，设环上某一部分为 $p\rightarrow b\rightarrow c\rightarrow d$。

一般情况下，$b$ 的后继一定**包括** $c$，$c$ 的后继**不包括** $b$，于是只需检查 $a_{p,1}$ 的后继是否包括 $a_{p,2}$ 即可，包括，则 $a_{p,1}=b$，否则 $a_{p,1}=c$。

还有一种特殊情况，环长为 $3$，这时候 $c$ 的后继有可能包括 $b$ 了，按照上述方法判断会出现问题，但是容易发现 $1,2,3$ 任意重组，他们的后继都是不变的，即任意一组排列都满足条件，直接特判输出即可。


```cpp
#include <bits/stdc++.h>
using namespace std;

namespace IO{};    // 省去了快读

const int N = 3e5;
int n, a[N], b[N];

bool suf(int u, int v)  // 判断 v 是否为 u 的后继
{
  return a[u] == v || b[u] == v;
}
  
int main()
{
  qcin >> n;
  if (n == 3)
    return printf("1 2 3\n"), 0;
  for (int i = 1; i <= n; i++)
    qcin >> a[i] >> b[i];
  int p = 1;
  for (int i = 1; i <= n; i++) {
    qcout << p << ' ';
    if (suf(a[p], b[p])) p = a[p];
    else p = b[p];
  }
  return 0;
}
```

---

## 作者：晴空一鹤 (赞：2)

## Solution

题意是告诉你一个圆形排列每个数后面紧挨着的两个数，让你输出这个排列。

考虑那两个数的关系，显然是相邻的，我们将两数之间连边，最后将得到一个环。

由于是个圆形排列，我们便从任意一点出发遍历这个环输出即可。

关于遍历顺序，显然只有顺时针和逆时针两种，一个比较简单的判定方法是找到起始点与其后面两个点中有连边的那个点，从起始点向那个点的方向遍历。

### CODE

```
#include<bits/stdc++.h>
using namespace std;
int n,x,y,op[200005];
vector<int>q[200005];
void inline dfs(int z){
    cout<<z<<" ";op[z]=1;
    if(z==n&&(q[z][0]==x||q[z][0]==y))dfs(q[z][0]);
    else if(z==n&&(q[z][1]==x||q[z][1]==y))dfs(q[z][1]);
    if(op[q[z][0]]==0)dfs(q[z][0]);
    if(op[q[z][1]]==0)dfs(q[z][1]);
}
int main(){
   cin>>n;
   for(int i=1;i<=n;i++){
   cin>>x>>y;
   q[x].push_back(y);
   q[y].push_back(x);
   }
   dfs(n);
}
```


---

## 作者：oimaster (赞：2)

[为了纪念马上开学，我又来写题解了。早上六点仍然打了一场虚拟比赛，不过没人陪我啊（如果您可以请告诉我，我的 QQ 号是 202367038，谢谢。](https://oi-master.github.io/post/codeforces-contest-1095-d-ti-jie/)

然后呢，我就不扯别的了，先开始正题，不过在说思路之前，我们得讲讲题面。
## 题面
### 英文题面
这道题的英文题面可以在 [Codeforces](https://codeforces.com/contest/1095/problem/D) 上找到，这里不多说，实在是没有必要把英文题面拷贝过来。其实也没有访问的必要，主要是告诉你可以在哪里提交。
### 中文题面
一群小孩在一起玩游戏，他们围成一个圈圈，就像是这样。

![小孩](https://oi-master.github.io/post-images/1586074922523.png)

小孩是每个小节点，边（箭头）就是表示小孩面向的方向。

然后接下来，小孩子们被打乱，找不到原来的顺序了。但是唯一一个好处就是，他知道他前面的人和前面的前面的人。注意，给的时候可能没按照顺序给，例如先告诉你“前面的前面”的小孩子的编号，再告诉你“前面”得人的编号，需要你自己判断。

我们告诉你这些小孩子们的回忆，让你还原小孩子们原来的位置，例如，这张图的答案就是 $[3,2,4,1,5]$ ，也可以说是 $[1,5,3,2,4]$，还有别的答案，你输出任意一种即可。

如果你没看懂，请在评论留言，我会根据你的问题进一步修改文章的翻译。
## 思路
这道题我们会发现这些条件给的并不好，我们没法确定相邻的信息，因为我们给的时候不知道两个数字的顺序，自然也无法判断到底是哪一个数字跟我相邻。不过，我们可以转个弯，如果 $a$ 和 $b$ 一个是我的前面，一个是我前面的前面，那么很显然，$a$ 与 $b$ 相邻。我们构造一个这样子的图就行了。

我写呀写、写呀写、写呀写、写呀写，唉，最后还是答案错误，您一定知道这是什么意思吧？我最后发现了一个 Bug ，就是我们可能把整个图搞反了，箭头的方向走错了，怎么办呢？

很简单，我们只需要在第一个数字读入的时候，记录下两个数字的位置，在第一次走的时候不要走反方向，要向这两个数字走。

于是，代码写出来了。

于是，我 AC 了此题。

于是，我就放代码了。

（皮一下很开心
## 代码
```cpp
/* Generated by powerful Codeforces 
 * Author: OI_Master
 * Time: 2020-04-05 07:16:11
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
int head[200300];
int cnt;
struct edge{
	int next;
	int to;
}e[400300];
void add_edge(int u,int v){
	++cnt;
	e[cnt].next=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
bool vis[200300];
void dfs(int s){
	cout<<s<<' ';
	vis[s]=true;
	for(int i=head[s];i;i=e[i].next)
		if(vis[e[i].to]==false){
			dfs(e[i].to);
			break;
		}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin>>n;
	int a,b;
	for(int i=1;i<=n;++i){
		int x;
		int y;
		cin>>x>>y;
		add_edge(x,y);
		add_edge(y,x);
		if(i==1){
			a=x;
			b=y;
		}
	}
	cout<<"1 ";
	vis[1]=true;
	for(int i=head[1];i;i=e[i].next)
		if(e[i].to==a||e[i].to==b){
			dfs(e[i].to);
			break;
		}
	return 0;
}
```
好，本位到此结束。

---

## 作者：Luo_gu_fyh (赞：1)


## 题目意思

有 $n$ 个小朋友，编号为 $1 \dots n$ ，排成一圈。从顺时针来看这些小朋友依次为 $p_1, p_2, \dots, p_n$，显然  $p$ 是一个全排列。当 $i \lt n$ 时，站在 $p_i$ 的下一个小朋友为 $p_{i+1}$，而站在 $p_n$ 的下一个小朋友为 $p_1$。

对于每个小朋友来说，他记得他的下一个小朋友 $x$ 和 $x$ 的下一个小朋友。第 $i$ 个小朋友会告诉你他记得小朋友 $a_{i, 1}$ 和 $a_{i, 2}$，但是却忘记这两个小朋友在圈中的顺序。


## 思路
设第一个数为 $1$，假设第 $2$ 个数为 $a_{1,0}$ 如果 $a_{1,1}$ 没在 $a_{1,0}$ 的后面那第二个数就是 $a_{1,1}$，然后根据第二个数求出后面的数。

## 代码实现
```cpp
#include <bits/stdc++.h>

using namespace std;

int a[200005][2];
bool f[200005];

int main(){
  int n;
  cin >> n;
  for(int i = 1; i <= n; i++){
    cin >> a[i][0] >> a[i][1];
  }
  int q = 1, p = a[1][0];
  if(a[1][1] != a[p][0] && a[1][1] != a[p][1]){
    p = a[1][1];
  }
  cout << q << ' ' << p;
  int t;
  for(int i = 3; i <= n; i++){
    if(a[q][0] != p){
      t = a[q][0];
    }
    else{
      t = a[q][1];
    }
    q = p;
    p = t;
    cout << ' ' << p;
  }
  return 0;
}

```


---

## 作者：sgz566 (赞：1)

### 题解：

这道题就是告诉你一个点后面的两个点是啥，还原一个环

我的思路是随便从一个数开始，确定它后面两个数的位置顺序，直到发现有一个数的后面两个数中有一个是开头的数，这样就可以确定这个环了。

如何确定两个数的位置？假如现在有三个人，分别是$a,b,c$，$a$的后面是$b$和$c$。如果$b$的后面有$c$，$b$就一定在$c$前面。反之，$b$一定在$c$后面。所以，只需要判断$b$后面有没有$c$就可以确定顺序了。

发现有一个数的后面两个数中有一个是开头的数就直接一个判断。

因为一次确定两个数的顺序，再加上一个开始的数，则已经确定的数一定是奇数个。如果$n$为偶数，那么就还有一个数没有输出（因为它前面的后面的后面的数是开头的数），直接输出那个数就可以了。
### 代码：
```cpp

#include<iostream>
using namespace std;
int n,a[200010],b[200010];//a[i],b[i]都是i后面的数
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
	}
    printf("1 ");//从1开始
	int cnt=1;//cnt表示现在在确定cnt后面两个数的顺序
	while(1)
	{
		if(a[cnt]==1||b[cnt]==1)
		{
			if(n%2==0)
			{
				if(a[cnt]!=1)printf("%d",a[cnt]);
				else printf("%d",b[cnt]);
			}
			break;
		}
		if(a[a[cnt]]==b[cnt]||b[a[cnt]]==b[cnt])
		{
			printf("%d %d ",a[cnt],b[cnt]);
			cnt=b[cnt];
		}
		else
		{
			printf("%d %d ",b[cnt],a[cnt]);
			cnt=a[cnt];
		}
	}
	return 0;
}

```

---

## 作者：qnqfff (赞：1)

思路：

显然的，一个数的的后两个数中，一定有一个数的后两个数包含另一个数，所以先以 $1$    为开头，然后按上面的判断方法每次判断一下它的下一个数，以此类推，但最后的那个数是前一个数的后两个数中，不是 $1$ 的那个 $($ 因为以 $1$ 开头$)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    char ch=getchar();int s=0,f=1;
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return f*s;
}
int n,a[200010][2],ans[200010];
int main(){
    n=read();
    for(int i=1;i<=n;i++) a[i][0]=read(),a[i][1]=read();ans[1]=1;cout<<1<<' ';
    for(int i=1;i<n-1;i++){if(a[a[ans[i]][0]][0]==a[ans[i]][1]||a[a[ans[i]][0]][1]==a[ans[i]][1]) ans[i+1]=a[ans[i]][0],cout<<a[ans[i]][0]<<' ';else ans[i+1]=a[ans[i]][1],cout<<a[ans[i]][1]<<' ';}
    if(a[ans[n-1]][1]==1) cout<<a[ans[n-1]][0];else cout<<a[ans[n-1]][1];
    return 0;
}
```

---

## 作者：02Ljh (赞：0)

~~小水蓝可爱捏~~

## 题意
现在有一个长度为 $n$ 的环，已知每一个数后面的两个数（顺序未知），还原这个环。（还原时顺序随意）

## 思路
既然题目给我们了每个数之后的后两个数，那么我们可以这样来理解。

假设环与输入数据如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/ig076uuo.png)

我们构建一个队列 $q$ 来储存这个环，

那么我们从点编号 $1$ 开始枚举，

在 $1$ 后面是 $3$ 和 $2$
，我们考虑 $3$ 紧接着 $1$ 的情况，发现 $3$ 后面紧接着的数是 $4$ 和 $1$，但是这两个数都不等于 $2$（ $1$ 接的下一个数 ）。

我们在从 $2$ 开始考虑，$2$ 后面接的数中正好有 $3$ ，我们把 $2$ $\texttt{push}$_$\texttt{back}$ 进入队列中。

每次循环中，我们从队列中取出队头，用队头后面的元素 $1$ 和 元素 $2$ 分别进行判断，看哪个元素合法，再将其放入队列。以此类推，我们就能得出环的原本情况。

然后你就 $\texttt{WA on 13}$。（大悲

### 观察发现，对于 $ n=3 $ 时 我们的输出会发生异变

我们发现，在只有三个数时，任意一种排列都可以用 ```1 2 3``` 来描述，所以，我们写一个特判，当 $n=3$ 时直接输出 ```1 2 3``` 就行了。

~~不懂得可以看code~~

## my code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f
#define ll long long
#define MAXN 300019
int mapp[MAXN][3];
int a[19];
int n;
vector <int> q;//存储用队列
void pr()
{
    for(int i=0;i<q.size();i++)
    {
        cout<<q[i]<<" ";
    }
    //puts("AKIOI\n");
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>mapp[i][1]>>mapp[i][2];
    }
    if(n==3)//特判
    {
        cout<<"1 2 3";
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        int now=(q.empty()?1:q.back());/初始值是一
        int fi=mapp[now][1];//数1
        int ne=mapp[now][2];//数2
        if(mapp[fi][1]==ne||mapp[fi][2]==ne)//当数一合法时
        {
            q.push_back(fi);
            //将数一放入队列
        }
        else if(mapp[ne][1]==fi||mapp[ne][2]==fi)
        {
            q.push_back(ne);
        }
    }
    pr();
    return 0;
}
/*
3
3 2
3 1
1 2
*/

```

---

## 作者：wnsyou (赞：0)

### 题目大意
现在有一个有 $n$ 个数的**环**，已知每一个数后面的两个数(顺序未知)，还原这个环。

### 思路
既然是个环，那么开头是几都可以，不妨设开头是一。

那么第二、第三个数必然只有两种选择。

设第二个数为 $a_{1,0}$，第三个数为 $a_{1,1}$（我比较喜欢下标为0）

设第二个数为 $x$，第三数为 $y$，如果 $a_{x,0} \ne y$ 并且 $a_{x,1} \ne y$，证明两数顺序排反了，则将其交换

前三数都推导好了，后面的数就轻松了。

给个公式：$p_i=a_{i-2,0} + a_{i-2,1}-p_{i-1}(i>3)$

读者可以自己推一推。

### 代码
```cpp
#include <iostream>

using namespace std;

const int N = 200010;
int a[N][2];
int p[N];
int n, t;

int main(){
  cin >> n;
  for (int i = 1; i <= n; i++){
    cin >> a[i][0] >> a[i][1]; // 读入不说话
  }
  p[1] = 1; // 设第一个数为1
  p[2] = a[1][0];
  p[3] = a[1][1];
  if(p[3] != a[p[2]][0] && p[3] != a[p[2]][1]){ // 先处理好第二第三个数
    swap(p[2], p[3]);
  }
  for (int i = 4; i <= n; i++){
    p[i] = a[p[i - 2]][0] + a[p[i - 2]][1] - p[i - 1]; // 公式
  }
  for (int i = 1; i <= n; i++){
    cout << p[i] << ' ';
  }
  return 0; // 完美结束
}
```

---

## 作者：开始新的记忆 (赞：0)

题目大意：给你n个人，告诉你每个人按顺时针排列的后两个人（不按顺序），输出最后组成的圈。

大致思路：我们可以先取1当第一个人，然后假设1的后两个为x,y，那么若1的后一个是x，那么x的后两个中必定有y，反之则取y，这样可以O（n）确定这个圈。（当过小时可能出现x后有y并y后有x，所以我开了一个visited来记录哪些点已经取了）


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<vector>
#include<cmath>
#include<map>
using namespace std;
int n,ans[200010],cnt=1;
bool visited[200010];

struct node{
    int fi,se;
} a[200010];

int main()
{	cin>>n;
    for(int x,y,i=1;i<=n;++i)
    {
        cin>>x>>y;
        a[i].fi=min(x,y);
        a[i].se=max(x,y);
    }
    ans[cnt++]=1;
    visited[1]=1;
    while(cnt<=n)
    {
        if(!visited[a[ans[cnt-1]].fi])
        {
            ans[cnt]=a[ans[cnt-1]].fi;
            visited[ans[cnt]]=1;
            cnt++;
            if((a[ans[cnt-1]].fi==a[ans[cnt-2]].se) || (a[ans[cnt-1]].se==a[ans[cnt-2]].se))
                continue;
            cnt--;
            visited[ans[cnt]]=0;
            ans[cnt]=a[ans[cnt-1]].se;
            visited[ans[cnt]]=1;
            cnt++;
        }
        else
        {
            ans[cnt]=a[ans[cnt-1]].se;
            visited[ans[cnt]]=1;
            cnt++;
        }
    }
    for(int i=1;i<=n;++i)
        cout<<ans[i]<<' ';
    cout<<endl;
	return 0;
}
```


---

## 作者：小黑AWM (赞：0)

观察可以发现**对于任意一个点，他的直接后继节点肯定是那个和他有共同后继节点的那个节点**所以利用这一条性质我们可以很方便的从任意一个起点出发然后选定他的儿子和孙子，再从孙子找下去，子子孙孙直到返祖(重复)为止。具体实现细节见代码。
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn = 2e5 + 10;
int n, at;
int edge[maxn][2];
int ans[maxn], top, visit[maxn];
int judge(int father, int id){
    int son = edge[father][id];
    int grandson = edge[father][id^1];
    if(edge[son][0] == grandson || edge[son][1] == grandson)
        return true;
    return false;
}
int main(){
    while(cin >> n){
        top = 0;
        memset(edge, 0, sizeof(edge));
        memset(ans, 0, sizeof(ans));
        memset(visit, 0, sizeof(visit));
        for(int i = 1; i <= n; i++)
            cin >> edge[i][0] >> edge[i][1];
        ans[++top] = 1;
        at = 1;
        visit[at] = true;
        while(!visit[edge[at][0]] || !visit[edge[at][1]]){
            int u = edge[at][0];
            int v = edge[at][1];
            if(judge(at, 0)){
                ans[++top] = u;
                visit[u] = true;
                if(!visit[v])
                    ans[++top] = v,
                    visit[v] = true;
            }else{
                ans[++top] = v;
                visit[v] = true;
                if(!visit[u])
                    ans[++top] = u,
                    visit[u] = true;
            }
            at = ans[top];
        }
        for(int i = 1; i <= top; i++)
            cout << ans[i] << " ";
        cout << endl;
    }
    return 0;
}
```

---

## 作者：Ouaoan (赞：0)

题目：[CF1095D Circular Dance](https://www.luogu.org/problemnew/show/CF1095D)

---

[更好阅读体验？](https://blog.csdn.net/rabbit_ZAR/article/details/85329650)

---

思路：

把每个点后面两个点之间连一条无向边，然后dfs找环就可以了。

但是要注意下，从第一个点开始dfs时，要走指向它后面的点的路，不然整个环就会找反。

---

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define read(x) scanf("%d",&x)
#define maxn 200000

int n;
int a[maxn+5];
vector<int> g[maxn+5];
int cnt=0;

void dfs(int x,int fa) {
	cnt++;
	if(cnt>n) return ;
	printf("%d ",x);
	for(int i=0;i<g[x].size();i++) {
		int y=g[x][i];
		if(y==fa) continue;
		dfs(y,x);
	}
}

int main() {
	read(n);
	int xx,yy;
	for(int i=1;i<=n;i++) {
		int x,y;
		read(x),read(y);
		if(i==1) xx=x,yy=y;
		g[y].push_back(x),g[x].push_back(y);
	}
	
	if(g[1][0]!=xx&&g[1][0]!=yy) swap(g[1][0],g[1][1]);
	dfs(1,0);
	
	return 0;
}
```

---

## 作者：Dilute (赞：0)


我们令$fa[i]$为$i$直接连向的点

那么显然，$fa[i] \in \{a_{i, 1}, a_{i, 2}\}$

假设$a_{i, 1}$为$fa[i]$，那么$a_{2, i} \in \{ a_{fa[i], 1}, a_{fa[i], 2} \}$

否则肯定有$a_{2, i} \not\in \{ a_{fa[i], 1}, a_{fa[i], 2} \}$

所以，如果有$a_{2, i} \in \{ a_{fa[i], 1}, a_{fa[i], 2} \}$，那么$fa[i] = a_{i, 1}$，否则$fa[i] = a_{i, 2}$

按照这个模拟即可

接下来送上代码

最后还有一点

在`n = 3`的时候上述方法是不适用的。

但是显然，`n = 3` 的时候随便输出一个环都能是答案

但是用这个方法可能构造出一个$n \leq 2$的环……

反正这个特判不加会$\color{red}\text{WA on test 13}$

```cpp
#include<bits/stdc++.h>

#define INF 2147483647
#define ll long long

inline int inp(){
    char c = getchar();
    while(c < '0' || c > '9')
        c = getchar();
    int sum = 0;
    while(c >= '0' && c <= '9'){
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    return sum;
}

int a1[200010];
int a2[200010];
int fa[200010];

inline bool rel(int a, int b){ // 判断b是否有 b ∈ { a_{a1}, a_{a2} }
    return (b == a1[a] || b == a2[a]);
}

int main(){
    int n = inp();
    if(n == 3){
        printf("1 2 3");
        return 0;
    }
    for(int i = 1; i <= n; i++){
        a1[i] = inp();
        a2[i] = inp();
    }
    for(int i = 1; i <= n; i++){
        if(rel(a1[i], a2[i]))
            fa[i] = a1[i];
        else
            fa[i] = a2[i];
    }
    int cur = 1;
    while(fa[cur] != 1){
        printf("%d ", cur);
        cur = fa[cur];
    }
    printf("%d\n", cur);
}
```



---

## 作者：Zechariah (赞：0)

显然对于每个i，给出的两个点无法确定是i的下一个还是i的下一个的下一个，所以我们不能直接把i和这两个点连边，怎么办呢？  
i无法确定和谁连边，但是可以肯定的是给出的两个点一定相邻，再考虑到n个点n条边，刚好是一个环，所以我们把给出的所有点对连起来，从任意一个点开始跑完这个环就可以了  

然后发现WA了，原因是我们建的是无向图，而题目要求是有向的，也就是说可能我们跑出来的结果与正确答案刚好完全相反，所以我们在开始的时候就要有选择，只要开始选对了，接下来直接跑就行了
```cpp
#include <bits/stdc++.h>
#define rg register
#define inl inline
typedef long long ll;
const int N = 4e5 + 10, mod = 998244353, oo = 0x3F3F3F3F3F3F3Fll;
using namespace std;
namespace fast_IO {
    long long read()
    {
        rg long long num = 0;
        rg char ch;
        rg bool flag = false;
        while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r');
        if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48;
        while ((ch = getchar()) >= '0'&&ch <= '9')
            num = (num << 1) + (num << 3) + (ch ^ 48);
        if (flag)return -num; return num;
    }
    ll max(rg ll a, rg ll b) { if (a > b)return a; return b; }
    ll min(rg ll a, rg ll b) { if (a < b)return a; return b; }
    void write(rg ll x) { if (x < 0)putchar('-'), x = -x; if (x >= 10)write(x / 10); putchar(x % 10 ^ 48); }
};
int nt[N], p[N], b[N], num;
bool flag[N];
inl void add(rg int x, rg int y) { b[++num] = y; nt[num] = p[x]; p[x] = num; }

int main()
{
    rg int n = fast_IO::read(), s, t;
    for (rg int i = 1; i <= n; ++i)
    {
        rg int to = fast_IO::read(), to2 = fast_IO::read();
        add(to, to2); add(to2, to); if (i == 1)s = to, t = to2;
    }
    rg int now = 1; fast_IO::write(now); flag[now] = true;
    for (rg int e = p[now]; e; e = nt[e])
        if (!flag[b[e]] && (b[e] == s || b[e] == t))
        {
            flag[b[e]] = true, now = b[e];
            break;
        }
    putchar(' '), fast_IO::write(now);
    for (rg int i = 3; i <= n; ++i)
    {
        for (rg int e = p[now]; e; e = nt[e])
            if (!flag[b[e]])
            {
                flag[b[e]] = true, now = b[e];
                break;
            }
        putchar(' '), fast_IO::write(now);
    }
    return 0;
}

```

---


# Drunken Maze

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041D/ac90366c626ba21a7610cf55d06b2398a53105ff.png) Image generated by ChatGPT 4o.You are given a two-dimensional maze with a start and end position. Your task is to find the fastest way to get from the start to the end position. The fastest way is to make the minimum number of steps where one step is going left, right, up, or down. Of course, you cannot walk through walls.

There is, however, a catch: If you make more than three steps in the same direction, you lose balance and fall down. Therefore, it is forbidden to make more than three consecutive steps in the same direction. It is okay to walk three times to the right, then one step to the left, and then again three steps to the right. This has the same effect as taking five steps to the right, but is slower.

## 样例 #1

### 输入

```
7 12
############
#S........T#
#.########.#
#..........#
#..........#
#..#..#....#
############```

### 输出

```
15```

## 样例 #2

### 输入

```
5 8
########
#......#
#.####.#
#...T#S#
########```

### 输出

```
14```

## 样例 #3

### 输入

```
5 8
########
#.#S...#
#.####.#
#...T#.#
########```

### 输出

```
-1```

# 题解

## 作者：ccjjxx (赞：3)

图论题，考完发现都写的是 dijkstra，但是我写的是 BFS。

首先先正常写，然后对于每个状态记录现在的方向和朝这个方向连续走了多少次，显然，当次数等于 $4$ 时，你需要换方向，如果要沿同一防线继续走，就需要后退一步再前进两步。

这时就有 hack 来卡我了，如果按照这种方式连续朝同一方向前进，那么这样后退再前进的花费会是 $2$，也就是消耗了一次向前走的机会。但是，如果现在的左右（或上下）有空格子，你可以向别的方向换一下，再朝原方向前进，这样花费是 $1$。举个例子：

```
S.........T
...........
```

这样的路，你可以直接直线行走，也可以向前走两格再向下移动，再回来，是更优的。

有个细节，就是优先队列中有**位置相同，答案相同，但是方向来源不同的点**，为了保证正确性，你需要把符合这些条件的所有点全部跑出来，而不是只取第一个，有这样一个 hack 数据，找到了我在赛时的错误（来自 @[Baiyj](luogu://user/580840)）。

```
5 18
S................T
.################.
.################.
..##....##....##..
..................
```

附上有很多 hack 数据的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m;
int stx,sty,edx,edy;
struct node{
	int x,y;
	int val,f;
	int pre,prepos;
	inline bool operator<(const node &ll) const
	{
		if(x==ll.x&&pre==ll.pre&&val==ll.val) return y>ll.y;
		if(pre==ll.pre&&val==ll.val) return x>ll.x;
		if(val==ll.val) return pre>ll.pre;
		return val>ll.val;
	}
};
priority_queue<node>q;
int dx[5]={0,0,1,-1,0};
int dy[5]={0,1,0,0,-1};
inline int man(int a,int b,int x,int y)
{
	return abs(a-b)+abs(x-y);
}
signed main()
{
	cin>>n>>m;
	vector<vector<bool>> vis(n+5,vector<bool>(m+5,0)),mp(n+5,vector<bool>(m+5,0));
	for(int i=1;i<=n;i++)
	{
		string c;cin>>c;
		for(int j=0;j<m;j++) 
		{
			mp[i][j+1]=0,vis[i][j+1]=0;
			if(c[j]=='#') mp[i][j+1]=1;
			if(c[j]=='S') stx=i,sty=j+1;
			if(c[j]=='T') edx=i,edy=j+1;
		}
	}
	q.push({stx,sty,0,man(stx,sty,edx,edy),0,0});
	int ans=1e9;
	while(!q.empty())
	{
		node now=q.top();q.pop();
		
		if(now.x==edx&&now.y==edy)
		{
			ans=min(ans,now.val);
			break;
		}
		if(vis[now.x][now.y]) continue;
		vis[now.x][now.y]=1;
		bool tt=0;
		do
		{
			if(tt) now=q.top(),q.pop();
			tt=1;
			for(int i=1;i<=4;i++)
			{
				node nxt=now;
				nxt.x+=dx[i],nxt.y+=dy[i];
				if(nxt.x<1||nxt.y<1||nxt.x>n||nxt.y>m||mp[nxt.x][nxt.y]) continue;
				if(i==nxt.prepos) nxt.pre++;
				else nxt.pre=0;
				nxt.val++;
				if(nxt.pre==3) 
				{
					if(i==2||i==3)
					{
						node nxx=now;
						nxx.x+=dx[1],nxx.y+=dy[1];
						if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
						{
							nxt.pre=0,nxt.val+=2;
						}
						else
						{
							nxx=now;
							nxx.x+=dx[4],nxx.y+=dy[4];
							if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
								nxt.pre=0,nxt.val+=2;
							else nxt.val+=2,nxt.pre=1;
						}
					}
					else
					{
						node nxx=now;
						nxx.x+=dx[2],nxx.y+=dy[2];
						if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
						{
							nxt.pre=0,nxt.val+=2;
						}
						else
						{
							nxx=now;
							nxx.x+=dx[3],nxx.y+=dy[3];
							if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
								nxt.pre=0,nxt.val+=2;
							else nxt.val+=2,nxt.pre=1;
						}
					}
				}
				else nxt.prepos=i;
				nxt.f=nxt.val+man(nxt.x,nxt.y,edx,edy);
				q.push(nxt);
			}
		}while(q.top().x==now.x&&q.top().y==now.y&&q.top().val==now.val&&q.top().prepos!=now.prepos);
	}
	if(ans==1e9)
	cout<<"-1";
	else cout<<ans;
}
/*
6 5
.S#..
#.#..
.....
#.#..
.....
.#..T
 
2 12
S..........T
.##..#..##..
 
2 7
S.....T
....##.
 
#..#..
S.....
##..#
 
5 8
S....#T.
#...#.#.
#.#.....
#...##..
##......
 
7 12
############
#S.........#
#####.######
#T..#.######
#...#.######
#.....######
############
 
5 7
S....#T
.#.#.#.
.#.#.#.
.#.#.#.
.......
 
2 10
S........T
##.####..#
 
5 18
S................T
.################.
.################.
..##....##....##..
..................
 
*/
```

---

## 作者：FwbAway (赞：3)

这道题一开始做没做出来，因为超时了；第二次做又没做出来，因为写挂了。下面我就来分析一下没写出来的原因和正确的解题方法。

闲言少叙，CF 继续。

## 思路

我们发现，这个题说明了在同一方向上最多只能连续移动三步。于是我考虑搜索，根据正常的搜索西路，可以用结构体记录到达每一个二维点 $(i,j)$ 的数据与最优值，但这种做法只会导致两种结果：错误或超时。因为到每个节点的方向不同，若不判断方向，会写挂掉；判断方向，就会超时，考虑剪枝优化。

由于题目条件我们可以知道，对于每一个点 $(i,j)$，都有以下数据需要记录：

- 坐标，即 $(i,j)$。
- 方向，共 $4$ 个方向。
- 在此方向下移动的步数 $dis$（$dis\le4$），因为是到达 $4$ 步才判断，所以可以取到 $4$。

这样下来的遍历次数最多是 $16$ 倍的地图面积，可以接受。

于是又有很多人开始像我一样迷惑了：我该用深搜还是广搜？

考虑其区别。

大部分搜索题来说，广搜要优于深搜，我们尝试证明。

广搜可以确保从起点开始逐步扩展，所以更新到的最新点就是最优解，而深搜在一次搜到底时，可能并不是最优解，会浪费许多时间。

比如说在一个很大的图里却只有一条 $S$ 至 $T$ 的路时，即可以发现广搜的时间较少。

以下提供搜索中心代码：

```c++
if(/*该点合法*/){
  //t为方向，s是步数
  //超出三步或已访问过时不需判断
  //可以用t和i的关系处理出 dis 值
  if (dis > 3 || vis[dx][dy][i][dis]) continue;
  ans[dx][dy][i][dis]=ans[x][y][t][s]+1; 
  vis[dx][dy][i][dis]=true;
  q.push({dx,dy,i,dis});
}
```

答案即为 $ans$ 数组中的最小值。

---

## 作者：沉石鱼惊旋 (赞：1)

## D. Drunken Maze

有 $n\times m$ 的地图，`#` 表示障碍，`.` 表示空地，`S` 表示起点，`T` 表示终点。要求不能**超过**连续三步走同一方向，不可以通过障碍。起点终点视作一种空地。

问 `S` 到 `T` 的最小步数。无法到达输出 `-1`。

$12\leq n\times m\leq 2\times 10^5$，$3\leq n,m\leq 10^4$。

---

直接用 $4\times 3\times n\times m$ 的状态数的搜索是可过的。

$f_{i,j,0/1/2/3,1/2/3}$，表示这是从什么方向走到 $(i,j)$ 的，这是第几步。

转移枚举下一步的方向。如果相同并且已经走了三步就无法转移，否则就可以走。如果这个状态之前搜过就跳过。每个状态至多入队一次，更新 $\mathcal O(1)$ 个状态，复杂度是 $\mathcal O(nmAB)$ 的。其中 $A=4$ 表示方向的数量，$B=3$ 表示约束的步数。

关于实现：这类约束了 $nm$ 的题，开数组可以使用 vector 或者开局部数组然后清空。一些函数可以写成 lambda 表达式的形式。

<https://codeforces.com/contest/2041/submission/293536077>

---


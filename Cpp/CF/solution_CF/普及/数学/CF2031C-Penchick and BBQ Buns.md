# Penchick and BBQ Buns

## 题目描述

有 $n$ 个空位，你要用一些正整数来填充这些空位。

你用来填充空位的正整数 $k$ 必须满足以下两个条件：

-	$k$ 至少出现两次。

填完空位之后，设第 $i$ 个空位上的数是 $a_i$。对于任意的 $i\le n$ 和 $j\le n$，如果 $i\ne j$ 且 $a_i=a_j$，那么 $|i-j|$ 是完全平方数。

你需要构造出一组合法的方案，或者报告无解。

## 样例 #1

### 输入

```
2
3
12```

### 输出

```
-1
1 2 3 6 10 2 7 6 10 1 7 3```

# 题解

## 作者：Sakura_Emilia (赞：5)

# 构造题

当 $n$ 为偶数的时候，构造方案是显然的。只需选取 $\frac{n}{2}$ 对正整数，并且让每一对相邻即可，这样每一对的距离都是 $1$，符合平方数的要求。关键是对于奇数情形的构造。这时候必然至少有某一个正整数出现了奇数次，从最小的符合要求的奇数 $3$ 开始考虑，要使得它们两两之间的距离差均为平方数。

这三个数之间的距离刚好构成了勾股方程的一个解。众所周知，勾股方程的最小一组正整数解是 $3^2+4^2=5^2$，也就是下标最大为 $26$，此时最小的可构造序列长度为 $27$。利用这组勾股方程得到这样一个长度为 $27$ 的构造：

```cpp
const int sub[] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 1, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 1, 6};
```

其中的数字 $1$ 就是根据勾股方程的解来构造的。对于更大的奇数，截取前 $27$ 项，剩下的部分刚好长度为偶数，可以按照偶数策略来构造。由于这是勾股方程的最小解，因此对于更小的奇数无法构造，均为无解。

其他的细节可以参考下面的代码。

# Code

```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define Ciallo main
#define int long long
using namespace std;
const int sub[] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 1, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 1, 6};

int T, n, k;

inline void solve() {
    cin >> n;
    if(n % 2 == 0) {
        for(int i = 1; i <= n / 2; i++)
            cout << i << ' ' << i << ' ';
        cout << endl;
    } else{
        if(n < 27)
            cout << -1 << endl;
        else{
            for(int i : sub)
                cout << i << ' ';
            n -= 27;
            for(int i = 14; i <= 13 + n / 2; i++)
                cout << i << ' ' << i << ' ';
            cout << endl;
        }
    }
}

signed Ciallo() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> T;
    while(T--)
        solve();

    return 0;
}
```

---

## 作者：chenxi2009 (赞：3)

# 思路
$n$ 为偶数时构造序列 $(1,1,2,2,3,3,\cdots,n\div 2,n\div 2)$ 即可。\
$n$ 为奇数时，因为有一个数要出现三次，这三次两两之间的距离差显然得是一对勾股数的平方，最小时为 $3^2+4^2=5^2$。对应地需要在答案序列 $a$ 中 $a_1,a_{10},a_{26}$ 放上相同的数，因为没有更小的勾股数所以 $n<26$ 无解。\
$n\ge27$ 时，在 $a_{23},a_{27}$ 放上相同的数，被隔开来的空白区间长度都为偶数，用偶数的方法处理。

时间复杂度 $O(\sum n)$。
# 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int T,n,ans[200001];
int main(){
	scanf("%d",&T);
	while(T --){
		scanf("%d",&n);
		if(!(n & 1)){//偶数情况 
			for(int i = 1;i <= n / 2;i ++)printf("%d %d ",i,i);
			printf("\n");
		} 
		else if(n <= 26)printf("-1\n");//无解特判 
		else{//奇数情况 
			ans[1] = ans[10] = ans[26] = 1,ans[23] = ans[27] = 2;
			ans[2] = ans[3] = 3,ans[4] = ans[5] = 4;
			ans[6] = ans[7] = 5,ans[8] = ans[9] = 6;
			ans[11] = ans[12] = 7,ans[13] = ans[14] = 8;
			ans[15] = ans[16] = 9,ans[17] = ans[18] = 10;
			ans[19] = ans[20] = 11,ans[21] = ans[22] = 12;
			ans[24] = ans[25] = 13;
			for(int i = 1;i <= 27;i ++)printf("%d ",ans[i]);
			for(int i = 14;i <= n / 2;i ++)printf("%d %d ",i,i);
			printf("\n");
		} 
	}
	return 0; 
}

```

---

## 作者：zhangzirui66 (赞：3)

小小的分讨题。

### 偶数
如果 $n$ 为偶数，输出 `1 1 2 2 3 3` $\dots$，每组间隔均为 $1$。

---
### 奇数
如果 $n$ 为奇数，上面的方法会多出一个，考虑改造算法。

由于允许有两个以上同种面包，我们可以放置 $3$ 个 $1$ 号面包，剩下总数仍为偶数，如上即可。

三个面包的位置不能乱放。设第一个 $1$ 号面包的坐标为 $x$，第二个为 $y$，第三个为 $z$，就要满足：
$\lvert x-y \rvert$，$\lvert y-z \rvert$，$\lvert x-z \rvert$ 均为完全平方数，且 $\lvert x-y\rvert+\lvert y-z \rvert=\lvert x-z \rvert$，这东西不就是勾股定理吗！于是用最小的勾股数的平方当它们的间隔即可。

终于结束了吗？没有，第一和第二个 $1$ 号面包间隔 $8$ 格，能填充满，但第二和第三个之间间隔 $15$ 格，填不满。那该怎么办？  
为什么一定要放里面呢？我们可以拆开一组，一个放里面，一个放外面，就填满了。

### 代码时间：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n;
int main(){
    cin >> t;
    while(t --){
        cin >> n;
        if((n & 1) && (n < 27)){//下面的表长 27 个数字，不够就无解
            cout << "-1\n";
        }
        else if(n & 1){
            cout << "1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 11 11 13 12 12 1 13 ";//注意拆掉 13，使其刚好填满
            for(int i = 14; i * 2 <= n; i ++) cout << i << " " << i << " ";//接着 14 填
            cout << "\n";
        }
        else{
            for(int i = 1; i * 2 <= n; i ++) cout << i << " " << i << " ";//偶数直接填
            cout << "\n";
        }
    }
    return 0;
}
```

---

## 作者：TonviaSzt (赞：2)

[Problem Link](https://codeforces.com/contest/2031/problem/C)

**简要题意**

> 有 $q$ 次询问，每次给出 $n$，问是否能构造出一个满足下列条件的序列 $A$，若能则输出其中一个序列，否则输出 $-1$。
>
> - $\forall a_i\in[1,10^6]\cap\Z$，不存在某个 $a_i$ 只出现了一次。
> - $\forall(i,j)|a_i=a_j,|i-j|$ 为完全平方数

**思路分析**

构造入门题。

容易发现，$n$ 为偶数时，可以构造形如 $1,1,2,2,3,3,...$ 的序列。

$n$ 为奇数时，必然存在某个 $a_i$ 出现了奇数次，根据 $n$ 为偶数的构造启发，只需要找到合法的最小奇数 $N$，就可以扩展到之后的所有奇数。

考虑三元组 $(i,j,k)$ 满足 $|j-i|,|j-k|,|i-j|$ 都是完全平方数，根据最小勾股数 $3,4,5$ 构造出最小合法组为 $(1,10,26)$。

因为 $n$ 为奇数，所以 $N\ge 27$，构造一下发现 $N=27$ 时存在合法解 $\{ 1,2,2,3,3,4,4,5,5,1,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,1,6\}$，每次询问时判断与 $27$ 的大小再构造即可。

[Submission](https://codeforces.com/contest/2031/submission/291604116)

---

## 作者：include13_fAKe (赞：2)

## 前置知识

- [构造算法](https://oi-wiki.org/basic/construction/)
- 勾股定理（数学八年级下册第十七章）

## 题意

给 $n$ 个数赋值，要求如下：

- 所有的值应该在 $1$ 至 $10^6$ 之间。
- 所有出现的值都至少出现两次。
- 定义**距离**为两个数的下标之差，每两个相同的值的距离必须为平方数。

构造一组解，或报告无解。

$T$ 组数据。

$T\ge 1$，$1\le n,\sum n\le 2\times10^5$。

## 思路

### $n$ 为偶数

最简单的情况。

直接 $1,1,2,2,3,3,\dots,\frac{n}{2},\frac{n}{2}$ 即可。

### $n$ 为奇数

意味着肯定有一个数会被填奇数次。

上文已提到，若填奇数次就至少为 $3$ 次。我们考虑只填 $3$ 次的情况。

因为所有的距离均为平方数，所以考虑勾股定理。

$3^2+4^2=5^2$，所以可以构造坐标 $1,10,26$ 三个数相等。剩下的按照偶数的情况处理即可。

坐标 $2\sim 9$ 按照 $n$ 为偶数的情况填即可，但坐标 $11\sim25$ 仍为奇数。下一步解决这一问题。

可以考虑将任意一个奇数坐标的数与坐标 $27$ 相同的数，只要距离为平方数就行。可选 $11$ 和 $23$。我选择的是 $23$。

然后剩下的数就可以按照 $n$ 为偶数的情况配对。做完了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int ans[30]={-1,
1,2,2,3,3,4,4,5,5,1,
6,6,7,7,8,8,9,9,10,10,
11,11,12,13,13,1,12
};
void solve(){
	cin>>n;
	if(n%2){
		if(n<=25)	puts("-1");
		else{
			for(int i=1;i<=27;i++){
				cout<<ans[i]<<' ';
			}
			for(int i=28;i<=n;i++){
				cout<<i/2<<' ';
			}
			cout<<endl;
		}
		return;
	} 
	else{
		for(int i=1;i<=n;i++){
			cout<<(i+1)/2<<' ';
		}
		cout<<endl;
		return;
	}
}
int main(){
	int T;
	cin>>T;
	while(T--)	solve();
	return 0;
}
```

为什么我们机房只有我过了这题呢？

---

## 作者：Walrus (赞：2)

致敬传奇构造题。

首先知道一个很简单的结论，$1$ 也是完全平方数。所以我们完全可以构造出一个区间 $l\sim r$，其中区间长度为偶数，将其中的元素两两一组构造，这样对于这个区间一定是满足题意的。

举例：若 $n=6$，则构造 $(1,1,2,2,3,3)$。

所以说，若题目中给的 $n$ 是偶数，可以直接通过上述方法构造。

如果是奇数，怎么办？

这里肯定至少要选一个数出现次数为奇数了。

这里考虑如果一个数出现次数为奇数还满足题目条件会有什么性质。

题目说的是，对于任意二元组 $(i,j)$，若颜色 $c_i=c_j$，则 $\lvert i-j \rvert$ 为完全平方数。

这样的话，如果跟完全平方数沾边，自然会想到勾股定理。

有啥关系呢？我们知道勾股定理的内容是在一个直角三角形中，直角边的平方和等于斜边的平方。

考虑将这个结论转移到序列上。

不难发现，我们假设有 $(i,j,k)$ 这三个元素颜色相等（这里假设 $i<j<k$）。那么就有 $j-i$ 为完全平方数，$k-j$ 为完全平方数，$k-i$ 为完全平方数。从这里就看出来了，$j-i$ 和 $k-j$ 等价于直角边，$k-i$ 等价于斜边。成功转化。

那么考虑最小的勾股数组合 $(3,4,5)$，那么我们就令 $c_1=c_{10}=c_{26}$，这样的话这三个数就满足了题意。

**同时我们也可以发现，如果 $n\leq 26$ 且为奇数，则无解。**

- 对于区间 $2\sim9$，直接套结论构造，因为区间元素个数为偶数。
- 对于区间 $11\sim25$，不能直接构造，怎么办？而且区间元素个数为 $15$，与上述结论矛盾。

但是可以发现，如果我们可以采取一个办法，将区间元素个数变成偶数，是不是就可以解决了。

区间中间的元素肯定是不能乱动的，只能套结论。我们发现区间两头的元素是不是有可能和 $26$ 以后的数拼一下，因为对于 $27\sim n$ 之间的元素个数也是奇数，也不能上结论，所以可以对两段区间端点组合，将两段区间元素个数变成偶数再套结论。

然后你就可以发现，若 $c_{11}=c_{27}$，是满足题意的，也符合上述条件。如果这个结论你不能一眼看出，可以参考我的代码写法，因为我也不是一眼看出来的，是调试时偶然发现的。

所以结论如下。

>偶数一定有解，对于 $27$ 及以上的奇数一定有解，反之无解。

code

只放奇数端点写法。

```cpp
int l1 = 11, l2 = 25,	
	r1 = 27, r2 = n;
int d1 = r1 - l1,
	d2 = r1 - l2;
int e1 = r2 - l1,
	e2 = r2 - l2;
if((int)sqrt(d1) * (int)sqrt(d1) == d1) {
	a[l1] = a[r1] = 1e6 - 1;
	int tot = 5;
	rep(i, 12, 25) {
		a[i] = a[i + 1] = tot;
		++tot, ++i;
	}
	rep(i, r1 + 1, r2) {
		a[i] = a[i + 1] = tot;
		++tot, ++i; 
	}
} 
else if((int)sqrt(d2) * (int)sqrt(d2) == d2) {
	a[l2] = a[r1] = 1e6 - 1;
	int tot = 5;
	rep(i, 11, 24) {
		a[i] = a[i + 1] = tot;
		++tot, ++i;
	}
	rep(i, r1 + 1, r2) {
		a[i] = a[i + 1] = tot;
		++tot, ++i; 
	}
}
else if((int)sqrt(e1) * (int)sqrt(e1) == e1) {
	a[l1] = a[r2] = 1e6 - 1;
	int tot = 5;
	rep(i, 12, 25) {
		a[i] = a[i + 1] = tot;
		++tot, ++i;
	}
	rep(i, r1, r2 - 1) {
		a[i] = a[i + 1] = tot;
		++tot, ++i; 
	}
}
else if((int)sqrt(e2) * (int)sqrt(e2) == e2) {
	a[l2] = a[r2] = 1e6 - 1;
	int tot = 5;
	rep(i, 12, 25) {
		a[i] = a[i + 1] = tot;
		++tot, ++i;
	}
	rep(i, r1, r2 - 1) {
		a[i] = a[i + 1] = tot;
		++tot, ++i; 
	}
}
```

两个区间左右端点两两组合有 $4$ 种情况。时间复杂度 $O(N)$。
完整代码可以私信要，因为我这代码是复杂的，知道结论后完全可以简化。

---

## 作者：Binah_cyc (赞：1)

简单构造题，但是没有场切。

首先，因为 $1$ 是完全平方数，我们可以轻松的构造出来形如 `112233` 的方案。一看数据范围，$n \le 2 \times 10^5$，不用超过使用种类限制。我们就优雅的解决了 $n$ 为偶数的情况。

接下来考虑 $n$ 为奇数的情况。有上面的启发，我们想到使某一个数出现奇数次，将多出来的这空缺补上。出现的次数，当然是 $3$ 次。~~因为构造出现次数大于 $3$ 的太麻烦了。~~

我们假设它出现的位置从左到右分别为 $a,b,c$，它们就满足 $c-a,c-b,b-a$ 均为完全平方数。注意到 $c-a=(c-b)+(b-a)$，所以它们三个是一组勾股数！

很容易想到 $3,4,5$ 这一组最小的勾股数。为了方便我们钦定这个数字第一次出现的位置 $a$ 为 $1$，我们就可以推出 $b,c$ 的值分别为 $10,26$。

$a,b$ 之间有偶数个间隔，填法显然，略过不讲。但是 $b,c$ 之间的间隔为奇数个。为此，我们令位置 $23$ 与位置 $27$ 的数字相同，我们就会惊奇的发现，$11$ 到 $22$，$24$ 到 $25$ 之间的间隔个数刚好均为偶数个！至此，题目讲解完毕。

代码很简单，就不放了。

---

## 作者：ran_qwq (赞：0)

以下记 $(a_1,a_2,\dots,a_k)$ 为同种数字的下标编号。

1. $n$ 为偶数。

构造 $(1,2),(3,4),\dots,(n-1,n)$，同种数字下标差为 $1$。

2. $n$ 为奇数。

必须要有一种数出现至少三次，设这三个数距离分别为 $a,b,c$（$c$ 为最长的距离）。

设 $a=p^2,b=q^2,c=r^2$，那么 $p^2+q^2=r^2$。通过枚举可知 $r$ 最小为 $5$，此时 $a=9,b=16,c=25$。

所以 $n\le25$ 时无解，$n\ge27$ 时构造 $(1,10,26),(23,27)$，剩下相邻两个构造同种数字。

---

## 作者：lilong (赞：0)

小清新构造题。

对 $n$ 按奇偶性分类讨论。当 $n$ 为偶数时，一个显然的构造形如 $1,1,2,2,\cdots,n\div2,n\div 2$，相同的数之间距离是 $0$ 和 $1$，符合条件。

当 $n$ 为奇数时，结合条件可知有一个数要出现 $3$ 次。考虑将其中**任意两个数之间的距离**视为**三角形一条边的边长**，则这个三角形是直角三角形。为了找到最小的长度，我们要让斜边长度最小且三边均为整数。手工模拟不难发现，这个最小的斜边为 $5$。那么我们把这个数放在第 $1,10,26$ 个位置，再看看剩下的空位怎么填上。先按照 $n$ 为偶数的情况填，得到：

$$1,2,2,3,3,4,4,5,5,1,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,1,13$$

发现最后的 $13$ 不满足条件，但前面的数的个数不允许减少，怎么办？仔细观察，发现让第 $24$ 个位置的 $12$ 和第 $27$ 个位置的 $13$ 交换后，两边都能满足！

$$1,2,2,3,3,4,4,5,5,1,6,6,7,7,8,8,9,9,10,10,11,11,12,13,13,1,12$$

于是对于 $n < 27$ 的奇数 $n$ 无解，对于 $n \ge 27$ 的奇数 $n$，先输出上面长度为 $27$ 的序列，再对剩余部分按偶数情况处理即可。


```cpp
#include <iostream>
#include <cstdio>
#define int long long
 
using namespace std;
 
int n,tot;
 
void solve( void )
{
	cin >> n;
	tot = 0;
	if( n % 2 )
	{
		if( n < 27 )
		{
			cout << -1 << '\n';
			return;
		}
		n -= 27;
		cout << "1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 11 11 12 13 13 1 12 ";
	}
	tot = 200000;
	for( int i = 1 ; i <= n ; i ++ )
	{
		if( i % 2 ) tot ++;
		cout << tot << ' ';
	}
	cout << '\n';
	return;
}
 
signed main()
{
//	ios::sync_with_stdio( false );
//	cin.tie( 0 );
//	cout.tie( 0 );
	int T;
	cin >> T;
	while( T -- )
		solve();
	return 0;
}
```

---

## 作者：huanglihuan (赞：0)

#### 题目大意
构造一个长度为 $n$ 的序列 $p$，满足：
+ 对于 $\forall i\in[1,n-1],\forall j\in[i+1,n],p_i=p_j$ 都有 $j-i$ 为完全平方数，即可以构造正整数 $x$ 使得 $x^2=j-i$。
+ 对于 $\forall i\in[1,n-1],\forall j\in[i+1,n]$ 中的每个 $i$，一定有至少一个对应的 $j$ 满足 $p_i=p_j$ 即 $p$ 中的每个元素一点不会单独出现。

构造一个满足条件的方案，如没有，输出 `-1`。
#### 思路
+ 对于 $n$ 为偶数即 $n\bmod2=0$，可以构造 $1,1,2,2,\ldots,n\div2,n\div2$，当然，你也可以构造任意 $n\div2$ 组数，每组两个相同的，安排在相邻位置即可。
+ 对于 $n$ 为奇数，发现必定会有一个数字出现三次，你也可以打表发现，对于 $n\le25$ 的情况无解。

**证明：一个数出现三次满足要求的安排的最大值最小是 $26$，即 $1,10,26$。**
+ 其他情况，我们可以构造一个序列 $p$，使得 $p_1,p_2,\ldots,p_{27}=\{1,2,3,3,4,4,5,5,6,1,7,7,6,8,8,9,9,13,10,11,11,13,10,12,12,1,2\},p_{28},p_{29},\ldots,p_{n-1},p_n=14,14,\ldots,(n-1)\div2,(n-1)\div2$。
#### 代码
```cpp
#include <bits/stdc++.h>
#include <cstdio>
#define int long long
#define ull unsigned long long
#define mod 998244353
#define MOD 1000000007
using namespace std;
const int N = 2e6 + 5,maxn = 3e3 + 5;
int a [N];
void solve ()
{
	int n;
	cin >> n;
	if (n % 2 == 0)
	{
		for (int i = 1;i <= n / 2;i ++) cout << i << ' ' << i << ' ';
		cout << endl;
		return ;
	}
	if (n < 27)
	{
		cout << "-1\n";
		return ;
	}
	cout << "1 2 3 3 4 4 5 5 6 1 7 7 6 8 8 9 9 13 10 11 11 13 10 12 12 1 2 ";
	for (int i = 14;i <= (n - 1) / 2;i ++) cout << i << ' ' << i << ' ';
	cout << endl;
}
signed main ()
{
	int T;
	cin >> T;
	while (T --) solve ();
	return 0;
}
```

---

## 作者：AK_400 (赞：0)

注意到 $1$ 是完全平方数，于是对于偶数情况，我们可以直接输出 $1,1,2,2,3,3,\cdots$。

对于奇数情况，必定有一个数出现三次，我们设这三个数的索引为 $i,j,k(i<j<k)$，设$j-i=a^2,k-j=b^2,k-i=c^2$，那么有 $c^2=k-i=k-j+j-i=a^2+b^2$，也就是说我们需要一组最小勾股数,即 $3,4,5$。

我们设构造出的序列为 $a$，那么有 $a_1=a_{10}=a_{26}$，中间的空位按偶数情况的填法填。

但是问题又来了，$26-10+1=17$ 是奇数，无法填满，怎么办？

考虑在中间取一个和外边匹配，可以令 $a_{27}=a_{23}$，此时空位长度分别为 $14,2$，于是我们构造出了 $n=27$ 的一种填法：
$$
1,2,2,3,3,4,4,5,5,1,6,6,7,7,8,8,9,9,10,10,11,11,13,12,12,1,13
$$
因为我们选的是最小的勾股数，所以没有更小的情况。

长度更大时只需要像偶数情况一样在后面补数就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
void slv(){
    cin>>n;
    if(n%2==0){
        for(int i=1;i+i<=n;i++){
            cout<<i<<" "<<i<<" ";
        }
        cout<<endl;
        return;
    }
    if(n<27){cout<<"-1\n";return;}
    cout<<"1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 11 11 13 12 12 1 13 ";
    int now=15;
    for(int i=28;i<=n;i+=2,now++){
        cout<<now<<" "<<now<<" ";
    }
    cout<<endl;
}
int main(){
    int T;cin>>T;while(T--)
    slv();
    return 0;
}
```

---

## 作者：Jerrycyx (赞：0)

偶数情况很简单，两个两个放就可以了，重点是奇数情况。

首先，如果要放奇数个，一定有至少一个数出现了奇数次。

其次，如果这个数出现了超过三次，因为放三个的约束条件小于放更多个，所以可以把多出来的那些给换成别的成对的数。

那么情况就转化成了如何放下三个同一个数。一旦放下同一个数三次，后面的就可以直接按照偶数的方法无脑放，所以考虑如何在最短的长度内放满 $3$ 个同样的数。

设这个数三次分别出现在位置 $p,p+X,p+X+Y$，根据题目要求，$X$ 和 $Y$ 是平方数，且 $(X+Y)$ 也是平方数，所以设 $x^2=X,y^2=Y,z^2=X+Y$，那么有 $x^2+y^2=z^2$。

这一段的长度为 $z^2+1$，而使其最小的 $z=5$，对应的 $x=3,y=4$，所以思考如何向下面的数列中填数：

```plaintext
1 _ _ _ _ _ _ _ _ 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1
```

前一半有 $8$ 个空，按照偶数方法填入；后一半有 $15$ 个空，偶数方法填不完，但是剩下的一个可以考虑组合成距离 $4$：

```plaintext
1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 12 11 11 1 12
```

这样，只用 $27$ 个数就可以放入三个相同的数，后面按照偶数方法加即可得到任意奇数，前面的无解（$26$ 已经是放三个的理论最小长度）。

然后就做出来了：

```cpp
int main()
{
	int T; read(T);
	while(T--)
	{
		int n; read(n);
		if(n&1)
		{
			if(n<27) puts("-1");
			else
			{
				printf("1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 12 11 11 1 12 ");
				for(int i=1;i<=(n-27)>>1;i++)
					write(i+14,' '),write(i+14,' ');
				putchar('\n');
			}
		}
		else
		{
			for(int i=1;i<=n>>1;i++)
				write(i,' '),write(i,' ');
			putchar('\n');
		}
	}
	return 0;
}
```

---


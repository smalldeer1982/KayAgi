# Make It Permutation

## 题目描述

有一个大小为 $ n \times n $ 的矩阵 $ A $，其中对于所有 $ 1 \le i,j \le n $，$ A_{i,j} = j $。

在一次操作中，你可以选择一行，并反转该行中的任意子数组$^{\text{∗}}$。

请找到最多 $ 2n $ 次操作的序列，使得每一列都包含一个长度为 $ n $ 的排列$^{\text{†}}$。

可以证明这样的构造总是可能的。如果有多个解，输出任意一个即可。

$^{\text{∗}}$ 数组 $ a $ 是数组 $ b $ 的子数组，如果 $ a $ 可以通过从 $ b $ 的开头删除零个或多个元素，以及从 $ b $ 的末尾删除零个或多个元素得到。

$^{\text{†}}$ 长度为 $ n $ 的排列是一个由 $ 1 $ 到 $ n $ 的 $ n $ 个不同整数按任意顺序组成的数组。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 不是排列（$ 2 $ 出现了两次），$ [1,3,4] $ 也不是排列（$ n=3 $ 但出现了 $ 4 $）。

## 说明/提示

在第一个测试用例中，以下操作是一个有效的解：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2118B/2e920475092c0a06b7e6444770e39ca0f6a17a41.png)

## 样例 #1

### 输入

```
2
3
4```

### 输出

```
4
2 1 3
2 2 3
3 1 2
3 2 3
5
2 1 4
3 1 3
3 2 4
4 3 4
4 1 2```

# 题解

## 作者：Tonio_Trussardi (赞：7)

~~简单找规律题~~

## 大体思路
首先我们可以发现，对于第 $i$ 行，我们只需要进行一次 `i 1 i` 和一次 `i i+1 n`（若 $i<n$ 才执行此操作） 即可，当然这个是我们找规律的结果，所以我们还是需要简单求证的。

## 证明
可以发现，先进行操作，我们如果只看对角线左下方的三角形，那么会得到如此图形：

![](https://cdn.luogu.com.cn/upload/image_hosting/7c151owe.png)

我们可以发现第 $i-1$ 列的数字数量永远比 $i$ 上的多，那么也就是说如果我们在这个三角形的第 $i-1$ 列上可以放数 $x$ 使得其不重复，那么第 $i$ 列也可以。

那么通过这个想法我们就可以把右上角剩下的三角形向右"平移一位"，例如 $n=4$ 时平移后就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/tvmskwyw.png)

那么此时我们可以考虑答案 $n$ 从答案 $n-1$ 是如何通过转移得到的。首先我们对于 $n-1$ 的答案矩阵进行一次平移，那么将会出现一个形如对角线的空位置，此时我们可以在那里填入 $n$，可以发现这个操作是我们操作 `i i+1 n` 可以做到的，那么接下来还有第 $n$ 行没有填入，我们考虑进行平移后第 $i$ 列缺少了哪个数字，可以发现由于我们上三角第 $i$ 列与 $i-1$ 列的数字个数相差 $1$ 且相差的那个数字恰好是 $n-i+1$ 那么我们只需要在第 $n$ 行按顺序填入 $n-i+1$ 就可以了，这个操作与我们的 `i 1 i` 操作对应，所以我们一定可以使用这种操作完成任务。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		cout<<2*n-1<<endl;
		for(int i=1;i<=n;++i){
			if(i<n)
				cout<<i<<" "<<i+1<<" "<<n<<endl;
			cout<<i<<" "<<1<<" "<<i<<endl;
		}
	} 
	return 0;
} 
```

---

## 作者：CommandSR (赞：3)

## 题意

我们有一个大小为 $n \times n$ 的矩阵 $A$，初始时对于所有 $1 \le i, j \le n$，$A_{i,j} = j$。即，每一行都是 $[1, 2, 3, \ldots, n]$。

每次操作可以选择一行，并反转该行的任意一个子数组（子数组是连续的）。我们的目标是通过最多 $2n$ 次操作，使得每一列都包含 $1$ 到 $n$ 的一个排列（即每一列的数字是 $1$ 到 $n$ 的不重复的排列）。

## 题解

理解题意后，我第一个想到的是期望得到形如这样的矩阵：

```
1234
4123
3412
2341
```

但是不难发现 $n \ge 4$ 后中间的行需要整个翻转一遍，再翻转左右两边，答案操作数将接近 $3 \times n$。

但是实际上“将后面的所有行整体翻转后操作左右两段，第一行不动”等同于“将后面所有行直接操作左右两段，整体翻转第一行”。

于是解法非常明显，看代码即可。

## AC Code

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define F(i, a, b) for (int i = a; i <= b; ++i)
#define _F(i, a, b) for (int i = a; i >= b; --i)
#define ll long long
using namespace std;
ll rd() {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
struct V {
	ll x, y, z;
}; vector<V> ans;
void Solve() {
	ll n = rd(); 
	ans.clear();
	ans.push_back((V){1, 1, n});
	F(i, 2, n) {
		if (1 < i-1) ans.push_back((V){i, 1, i-1});
		if (i < n) ans.push_back((V){i, i, n});
	}
	cout << ans.size() << '\n';
	for (V tmp : ans) {
		cout << tmp.x << ' ' << tmp.y << ' ' << tmp.z << '\n';
	}
}
int main() {
	ll T = rd(); while (T--) Solve();
	return 0;
}
```

---

## 作者：违规用户名920406 (赞：3)

构造入门。

## 思路

显然，我们直接去构造最终操作不太可能，那我们可以尝试找到几组合法的最终矩阵。

以 $n = 4$ 为例，要求每列都为一个 $1 \cdots n$ 的排列，并且根据题意，每行最终也应该是排列。

## 构造

最简单地，形如

$1,2,3,4$

$2,3,4,1$

$3,4,1,2$

$4,1,2,3$

确实可行，但是每行要先整体交换，再交换前后两段，共 $3n$ 次操作，太多了。可以略微修改，整体交换 $2 \cdots n$ 列，再来一遍，形如

$1,4,3,2$

$2,1,4,3$

$3,2,1,4$

$4,3,2,1$

可以了！观察，发现通解：对于第 $i$ 行，交换 $[1,i]$ 和 $[i+1,n]$ 两段区间，共 $2n$ 次，过了。

## [Code](https://codeforces.com/contest/2118/submission/324074167)

---

## 作者：Clare613 (赞：2)

## 思路：
这篇题解会手把手的带你得到这个数组。\
第一步：我们可以对于 $i \in n$ 中把 $i$ 到 $n$ 都反转一下，可得以下列表，这里设 $n=5$：
```
54321
15432
12543
12354
12345
```
第二步：不难发现，前面重复了，那么可以对于 $i \in n$ 中把 $1$ 到 $-1$ 都反转一下，可得以下列表，这里同样设 $n=5$：
```
54321
15432
21543
32154
43215
```
答案列表就构造出来了，然后按照上面的写法输出即可。
## code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	cin.tie(0)->sync_with_stdio(0);
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		cout<<n*2-2<<"\n";
		cout<<"1 1 "<<n<<"\n";
		cout<<"2 2 "<<n<<"\n";
		for(int i=3;i<=n;i++){
			cout<<i<<" 1 "<<i-1<<"\n";
			cout<<i<<" "<<i<<" "<<n<<"\n";
		}
	}
	return 0;
}
/*
54321
15432
21543
32154
43215
*/
```

---

## 作者：Aurelia_Veil (赞：0)

# 题解：CF2118B 制作排列矩阵

构造题？规律题！

首先，列出原数组：

```
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
```

然后，反转一下，防止重复：

```
5 4 3 2 1
1 5 4 3 2
1 2 5 4 3
1 2 3 5 4
1 2 3 4 5
```

为什么，我们这样反转之后，右上的三角形区域就不会重复了，现在只需要处理左下的三角形区域，依旧是反转：

```
5 4 3 2 1
1 5 4 3 2
2 1 5 4 3
3 2 1 5 4
4 3 2 1 5
```

很容易发现，对于每一个 $i$，分别反转 $1$ 到 $i$ 和 $i+1$ 到 $n$ 即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
    scanf("%d",&t);
	while(t--){
		int n;
        scanf("%d",&n);
        printf("%d\n",n*2-2);
        printf("1 1 %d\n",n);
        printf("2 2 %d\n",n);
		for(int i=3;i<=n;i++){
            printf("%d 1 %d\n",i,i-1);
            printf("%d %d %d\n",i,i,n);
		}
	}
	return 0;
}
```

---

## 作者：NEKO_Daze (赞：0)

[洛谷CF2188B](https://www.luogu.com.cn/problem/CF2188B) || [CodeForces 2188 B](https://codeforces.com/contest/2188/problem/B)

### 简要题意
给出一个 $n\times n$ 的矩阵，其中 $a_{i,j}=j$。可以进行若干次操作，每次操作将某一行内的一段区间翻转，求使得矩阵每一列数字刚好满足 $1$ 至 $n$ 各出现一次的最少操作次数，并输出每一步的操作。
### 思路
考虑这么一种构造方法：

以 $n=5$ 的情况为例，下面的矩阵显然符合要求：

$$1~5~4~3~2\\2~1~5~4~3\\3~2~1~5~4\\4~3~2~1~5\\5~4~3~2~1$$

分析样例可知，我们只需要对每一行的 $[1,i]$ 和 $[i+1,n]$ 这两个区间翻转即可。

在此基础上，我们发现当 $i$ 为 $1$，操作 $[1, 1]$ 的区间长度为 $1$，这样白白浪费了一次操作次数；同理，当 $i$ 为 $n$ 时，操作 $[n+1,n]$ 是无意义的。因此最终答案为 $2n-2$，操作方法为：

* 若 $i=1$，只执行 $1~2~n$；
* 若 $2\le i<n$，执行 $i~1~i$ 和 $i~i+1~n$；
* 若 $i=n$，只执行 $n~1~n$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int t, x;
int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &x);
        printf("%d\n", 2*x-2);
        printf("%d %d %d\n", 1, 2, x);
        for (int i = 2; i < x; i++)
        {
            printf("%d %d %d\n%d %d %d\n", i, 1, i, i, i+1, x);
        }
        printf("%d %d %d\n", x, 1, x);
    }
}
```

---

## 作者：Mier_Samuelle (赞：0)

以 $n=5$ 为例，我们尝试构造下面的「循环」矩阵：

$$\begin{bmatrix} 1 & 2 & 3 & 4 & 5 \\ 5 & 1 & 2 & 3 & 4 \\ 4 & 5 & 1 & 2 & 3 \\ 3 & 4 & 5 & 1 & 2 \\ 2 & 3 & 4 & 5 & 1 \end{bmatrix}$$

不难发现，对于任意 $1 \le i \le n$，依次反转 $[1,n],[1,i-1],[i,n]$ 三个区间即可做到。

然后手玩几组数据，我们发现反转 $[1,n]$ 其实是没有用的，故我们可以在 $2n$ 次操作内完成目标。

[CF 提交记录](https://codeforces.com/contest/2118/submission/324081770)

---


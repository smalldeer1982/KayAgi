# Open Communication

## 题目描述

有两个玩家各拥有一对  $1$  到  $9$  的数，其中有且只有一个数是两对中都有的。他们想要通过聊天频道来找出这个数字，然而为了不让你知道，他们可能还会告诉对方自己不拥有的一对数，但这也可能导致他们自己也弄不清楚了。

现在请你根据他们的聊天信息判断，两个玩家拥有的一对数中，哪个数是两对中都有的。如果你能确定一定是它，输出这个数。如果你无法确定一定是它，但是你能确保玩家一定知道，输出  $0$ 。如果连玩家都不知道，输出  $-1$ 。

## 说明/提示

- 第  $1$  组样例的解释：

从第一个玩家告诉的  $(3,\ 4)$ ，第二个玩家也告诉的  $(3,\ 4)$  中，由于两对数中有两个数字相同，故他们无法判断。

从第一个玩家告诉的  $(1,\ 2)$ ，第二个玩家告诉的  $(3,\ 4)$  中，由于两对数中没有数字相同，故他们也无法判断。

从第一个玩家告诉的  $(3,\ 4)$ ，第二个玩家告诉的  $(1,\ 5)$  中，理由同上。

但是从第一个玩家告诉的  $(1,\ 2)$ ，第二个玩家告诉的  $(1,\ 5)$  中，他们就能猜测出这个数字是  $1$ ，当然你也能判断出。

因此输出  $1$ 。

- 第  $2$  组样例的解释：

不同于上一组样例，从第一个玩家告诉的  $(1,\ 2)$ ，第二个玩家告诉的  $(1,\ 5)$  中，他们可能会猜测出这个数字是  $1$ ，因为还有一种可能，就是从第一个玩家告诉的  $(3,\ 4)$ ，第二个玩家告诉的  $(6,\ 4)$  中，他们也有可能会猜测这个数字是  $4$ 。尽管你无法作判断，但由于玩家们知道自己告诉对方的是不是自己拥有的数对，设想一下，如果第一个玩家拥有的数对就是  $(1,\ 2)$ ，那么第二个玩家拥有的数对肯定是  $(1,\ 5)$ 。因此，玩家一定会知道，但你并不知道，输出  $0$ 。

- 第  $3$  组样例的解释：

这一组样例与上一组区分开来的是，这次连玩家都不知道了。原因是第一个玩家告诉对方  $(1,\ 2)$  时，第二个玩家会导致矛盾。

先看第二个玩家告诉的  $(1,\ 3)$ ，相同的数是  $1$ ，但是再看第二个玩家告诉的  $(2,\ 3)$ ，相同的数是  $2$ 。首先你是肯定无法判断了，同时第一个玩家也无法判断，因为通过观察，第一个玩家拥有的数对一定是  $(1,\ 2)$ ，但相同的数刚好组成了这个数对。相反地，第二个玩家却知道，他也像你能观察出第一个玩家拥有的数对一定是  $(1,\ 2)$ ，同时他还知道自己拥有的数对，两个信息结合在一起，就可以从  $1$  和  $2$  中判断出。因此输出  $-1$ 。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
2 2
1 2 3 4
1 5 3 4
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2
1 2 3 4
1 5 6 4
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2 3
1 2 4 5
1 2 1 3 2 3
```

### 输出

```
-1
```

# 题解

## 作者：开始新的记忆 (赞：2)

题目大意：现在有两个人，每个人手中有两个数，其中两个人手中的数有一个是相同的（另一个不一样），现在第一个人会给你n对数，保证其中一对就是他手上的两个数，第二个人会给你m对数，保证其中一对是他手上的两个数。现在你作为一个旁观者，如果能分辨出相同的数，则输出它，如果你知道手上有牌的人知道相同的数，那么输出0，其余则输出-1。

大致思路：如果在两个人给出的n+m对数中，有且仅有两队数是有一个数相等的且分别处于n对和m队中，则输出它。

如果有多个相同的数字，但是存在两个数属于同一个对子对多个对子产生的,输出-1

其余输出0。

code：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,ha1[50][50],ha2[50][50],ans1[50][50],ans2[50][50],x=0,flag=0;

int main()
{	memset(ha1,0,sizeof(ha1));
	memset(ha2,0,sizeof(ha2));
	memset(ans1,0,sizeof(ans1));
	memset(ans2,0,sizeof(ans2));
	cin>>n>>m;
	for(int i=1,xx,yy;i<=n;++i)
	{
		cin>>xx>>yy;
		ha1[xx][yy]=1;
		ha1[yy][xx]=1;
	}
	for(int i=1,xx,yy;i<=m;++i)
	{
		cin>>xx>>yy;
		ha2[xx][yy]=1;
		ha2[yy][xx]=1;
	}
	for(int i=1;i<=9;++i)
		for(int j=1;j<=9;++j)
		{
			if(i==j)
				continue;
			for(int k=1;k<=9;++k)
			{
				if(k==i || k==j)
					continue;
				if(ha1[i][j]==ha2[i][k] && ha1[i][j])
				{
					++ans1[i][j];
					++ans2[i][k];
					x=i;
				}
			}
		}
	for(int i=1;i<=9;++i)
		for(int j=1;j<=9;++j)
			if(ans1[i][j])
			{
				++flag;
				break;
			}
	if(flag==1)
	{
		cout<<x<<endl;
		return 0;
	}
	x=0;
	for(int i=1;i<=9;++i)
		for(int j=1;j<=9;++j)
		{
			if(i==j)
				continue;
			if((ans1[i][j] && ans1[j][i]) || (ans2[i][j] && ans2[j][i]))
				x=-1;
		}
	cout<<x<<endl;
	return 0;
}
```


---

## 作者：jch123 (赞：1)

## 题面：

- 两个人，每个人有一对 $1$ 到 $9$ 的整数，保证两对数中有且仅有一个数相同。给你 $n$ 对数与 $m$ 对数，保证初始的两对数中在 $n$ 与 $m$ 中各有一对。问旁观者能否能分辨出相同的数是什么？

- 如果旁观者能分辨出，则输出那个数；如果只有那两个人能分辨出，输出 $0$；否则输出 $-1$。
- $1\leq n,m \leq 12$，保证所有数都是 $1$ 到 $9$ 的整数。

## 思路：

手玩一下样例发现两对数合法时则两个数对中有且仅有一个公共数并且不在一起，如果旁观者能猜出来时有且仅有一对合法的匹配，输出 $-1$ 时有一个对中两个数都能当公共数，其他情况输出 $0$。可以扔到一个桶里面，枚举初始的两对数，如果只有一对匹配，直接输出；否则看有没有一对数中两个数都能当那个公共数。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30;
int a[N][N],b[N][N],c[N][N],d[N][N];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m;
	cin>>n>>m;
	int x,y;
	for(int i=1;i<=n;i++)
		cin>>x>>y,a[x][y]=a[y][x]=1;
	for(int i=1;i<=m;i++)
		cin>>x>>y,b[x][y]=b[y][x]=1;
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(i==j) continue;
			for(int k=1;k<=9;k++)
			{
				if(k==i||k==j) continue;
				if(a[i][j]&&b[i][k])//合法的匹配
					c[i][j]++,d[i][k]++;	
			}
		}
	}
	int cnt=0,p=0;
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(c[i][j])
			{
				cnt++,p=i;
				break;//只需要加一次，因为只需看公共数i 
			}
		}
	}
	if(cnt==1) cout<<p;
	else 
	{
		int flag=0;
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++)
			{
				if(c[i][j]&&c[j][i]) flag=-1;//如果一个数对中每个数都能当公共数，那么都判断不出来 
				if(d[i][j]&&d[j][i]) flag=-1;//同理 
			}
		}
		cout<<flag;
	}
	return 0;
}
```

---


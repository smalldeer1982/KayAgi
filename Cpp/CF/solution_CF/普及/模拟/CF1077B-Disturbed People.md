# Disturbed People

## 题目描述

对于一个给定的长度为$n$的$01$序列$a_1,a_2,\cdots,a_n$  
如果存在$1<i<n$满足$a_{i-1}=a_{i+1}=1,a_i=0$，那么这个序列是不优美的  
求最少需要将多少个$1$变为$0$使得原序列变为优美的序列

## 样例 #1

### 输入

```
10
1 1 0 1 1 0 1 0 1 0
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
1 1 0 0 0
```

### 输出

```
0
```

## 样例 #3

### 输入

```
4
1 1 1 1
```

### 输出

```
0
```

# 题解

## 作者：きりと (赞：1)

## 题链：[CF1077B](https://www.luogu.com.cn/problem/CF1077B)
 题意：

输入序列长度n及一个01序列a

我们可以将其中的1改成0

问，要使其中不存在$a[i]=0$且$a[i-1]=1$且$a[i+1]=1$，至少改几个1

 思路：

思维题，首先，一遍for查找每个序列元素，看是否有题目中“不优美”的情况

接下来，有一个最大的问题，找到以后应该改变前一个1还是后一个1？

继续分析，若有一个序列$10101$，那么很明显，我们应该改最中间的一个1

推广得出，在一个不优美的部分里，只有$a[i+1]$会对后面的序列优美与否产生影响

所以我们应该变的是后一个1

实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[233];
int main()
{
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=2;i<n;i++)
	{
		if(a[i]==0)
		{
			if(a[i-1]==1&&a[i+1]==1)
			{
				a[i+1]=0;
				ans++;
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：zsc2003 (赞：1)

2018.11.16 codeforces div3 B

### 题目大意

有一段连续的房子，这些房子有一些是开着灯的(即$a_i=1$)，有一些是关着灯的(即$a_i=0$).规定如果一个人受到影响当且仅当：

- 对于任意$ 1<i<n$ ,若存在 $ a_{i-1} = a_{i+1}=1$ , $ a_i=0$ 则i处人会受到影响

现在你可以让一些房子的灯关上。

你需要最小化关闭的灯的数目，使得所有人都不会受到影响。

### 思路

采用贪心的思想，$ \Theta (n) $ 扫一遍整个房子。

若发现存在一个房子收到影响，那么只需要关掉它后面的那个灯即可。

即若 $ a_{i-1}=a_{i+1}=1 , a_i=0 $ 则让 $ a_{i+1}=0$，并且使 $ ans++ $

最终 $ ans $ 即为答案

### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()//读入优化
{
	int r,s=0,c;
	for(;!isdigit(c=getchar());s=c);
	for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);
	return s^45?r:-r;
}
const int N=110;
int n,ans;
int a[N];
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=2;i<n;i++)
		if(a[i]==0&&a[i-1]==1&&a[i+1]==1)
		{
			ans++;//贪心部分
			a[i+1]=0;
		}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：little_sun (赞：1)

# 题解 CF1077B 【Disturbed People】

* 这题就是个显而易见的贪心~~可是我考场上差点没想出来~~
* 显然把一户被打扰的人家的右边人家的灯关掉肯定比把左边的灯关掉来的更优
* 从左到右扫一遍，每次如果遇到一户被打扰的人家就ans++，然后把它右边的灯关掉
* 然后就做完了

```cpp
# include <bits/stdc++.h>

int a[101];

int main()
{
    int n;
    int ans = 0;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for(int i = 2; i <= n - 1; i++)
    {
        if (a[i] == 0 && a[i - 1] == 1 && a[i + 1] == 1)
            ans++, a[i + 1] = 0;//关右边的灯
    }
    printf("%d\n", ans);
    return 0;
} 
```

---

## 作者：goodier (赞：0)

## 题意简述

本题的意思就是给一个数列，让你检测出$101$的情况就将其改成不是$101$的情况，求最少的次数。


------------
## 题意分析

当我们检测出$1$个$101$时，我们有一下$2$种方法：将前一个$1$改成$0$，或将后一个$1$改成$0$。

现在我们来分析一下这两种情况的优劣：

拿$1010101$举例，如果改第一个那么就是这种情况：

$1010101->0010101->0000101->0000001$。

共3次。

该第二个的话就是这样的：

$1010101->1000101->1000100$。

共2次。

通过对比我们可以发现将后一个1改成0这种方法最优。

------------
## 具体代码实现
### 1.判断

循环推，推到0的时候判断两边是不是都是1。

### 2.更改

直接将第二个更改为0即可。

代码奉上：
```cpp
#include <iostream>
using namespace std;
int main()
{
    int n,a[101],ans  = 0;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for(int i = 2; i < n; i++)
    {
        if(a[i] == 0)
        {
            if((a[i - 1] == 1) & (a[i + 1] == 1))
            {
                ans++;
                a[i + 1] = 0;
            }
        }
    }
    cout << ans;
    return 0;
}
```
### 若有错误，欢迎指出！！！


---

## 作者：Arghariza (赞：0)

题意就是让你尽可能修改较少个 $1$ 变成 $0$ ，使得数列里面没有 $101$ 。

看样例先模拟一波：

我们先从下标 $2$ 开始遍历整个数组，判断**以当前下标对应数组的值与前后的值是否组成 $101$**：

你会发现 $i=3$ 时找到了一个 $101$  

```
ind 1 2 3 4 5 6 7 8 9 10
val 1 1 0 1 1 0 1 0 1 0
        i
```

由于要消灭掉这个 $101$ 并且要让后面的 $101$ 尽量少，我们发现**当修改 $s_{i+1}$ 的值时对于 $j=i+1$ 的 $s_{j-1},s_j,s_{j+1}$ 必定不是 $101$ ，而是 $00x(x=0$或$1)$** ；而如果修改 $s_{i-1}$ 的值的话并没有对后面的 $101$ 产生什么作用。所以我们就应该修改$s_{i+1}$，那么整个模拟过程应该是这样的：

```
ind 1 2 3 4 5 6 7 8 9 10
val 1 1 0 1 1 0 1 0 1 0 
        i                  ans=1 （发现第1个101）
val 1 1 0 0 1 0 1 0 1 0           （前面修改了第3+1=4位的值）
              i            ans=2 （发现第2个101）
val 1 1 0 0 1 0 0 0 1 0           （前面修改了第6+1=7位的值）
                    i （i跑到最后一位，发现没有101了，程序终止，直接输出修改次数，即ans）
```

整个算法复杂度 $O(n)$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, ans, s[100001];

int main() {
	cin >> n;// 输入
	for (int i = 1; i <= n; i++) cin >> s[i];// 输入
	for (int i = 2; i <= n - 1; i++) {// 遍历数组
		if (s[i - 1] == 1 && s[i + 1] == 1 && s[i] == 0) {// 如果找到101
			s[i + 1] = 0, ans++;// 修改，次数++
		}
	}
	cout << ans;// 输出步骤
	return 0;
}
```



---

## 作者：star_looker (赞：0)

很显然，把右边的$1$改为$0$比较合适，因为要考虑到后面的$01$串

```cpp
#include <bits/stdc++.h>
int arr[101];
int main(){
    int n,co=0;
    scanf("%d",&n);//读入
    for(int i=1;i<=n;i++) scanf("%d",&arr[i]);//读入01串
    for(int i=2;i<= n-1;i++){
        if(arr[i]==0 && arr[i-1]==1 && arr[i+1]==1)/*判断是否为101格式*/{co++;arr[i+1]=0;}//不改arr是要出问题的
    }printf("%d\n",co);//输出结果
    return 0;
}
```


---

## 作者：CreeperK (赞：0)

## Codeforces Round 521 Div.3 B

考场上第33分钟我才想出这道题来。。。在此之前我干掉了CD两题。。。我太弱了

而且用的方法还与大家不太一样。。。

对于每个开着灯的房间（？），我们定义函数$P$，$P(x)$表示第$x$个房间旁边有多少个被打扰的人。

例如对于样例1：

```cpp
10
1 1 0 1 1 0 1 0 1 0
```

有$P(3)=0,P(5)=1,P(7)=2$。

基本思路就是个奇怪的贪心。首先先依次把$P(x)=2$的房间给关掉灯。

然后再把$P(x)=1$的房间给关掉灯。

## 没了？

嗯，就这样没了。我都不知道我为什么能过。。。

代码如下。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
int n,tot=0;
int l[105];
int dis[105];
int tmp[105];
int cmp(int x,int y){
	return dis[x]<dis[y];
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&l[i]),tmp[i]=i;
	for(int i=2;i<n;i++){
		if(l[i]==0 && l[i-1]==1 && l[i+1]==1)dis[i-1]++,dis[i+1]++;//dis表示P
	}
	for(int i=1;i<=n;i++){
		if(dis[i]==2)tot++,dis[i-2]--,dis[i+2]--;
	}//P(x)=2
	for(int i=1;i<=n;i++){
		if(dis[i]==1){
			if(dis[i-2]>0)dis[i-2]--;
			if(dis[i+2]>0)dis[i+2]--;
			tot++;
		}
	}//P(x)=1;
	printf("%d",tot);
}
```

---


# Exam in BerSU (easy version)

## 题目描述

$\text{CF1185C2}$是本题的数据加强版，所以，做出本题不意味着你一定能过$\text{CF1185C2}$。


白朗州大学的又一个学年到来了，很多学生都在做测试。

我们的主人公，小$\text{P}$，要去测试$n(1\leqslant n\leqslant 100)$位学生。学生们将按照$1$到$n$的顺序依次测试。考试规则如下。

- 第$i$个考生随机抽取一张标签，上面有题目。

- 如果这个考生认为这个题目太难，TA没有做这个题目就滚回家去了，那么TA这次考试不及格。

- 如果这个考生发现题目很容易，并且刚好用了$t_i$分钟完成了这道题目。那么过后，TA将带着得到的考试分数回家。

学生们按照固定的次序，依次没有中断地测试。在任何时候，小$\text{P}$从一个学生当中得到答案。

所有学生的考试时间的总和是$M(1\leqslant M\leqslant 100)$，其中保证$\max t[i]\leqslant M$，所以，成绩不好的学生更有可能花光时间以通过考试。

对于每个学生$i$，你的任务是当TA通过考试时，计算出前面最少的不及格的学生的人数。

例如以下的样例一，前5个学生做完题目所需要的时间刚好等于M，所以，他们都不需要不及格的人，所以最少的不及格人数是0。而为了让第6和第7个学生通过测试，前面分别必须让第3,4和第2,5,6个学生不及格。

## 样例 #1

### 输入

```
7 15
1 2 3 4 5 6 7
```

### 输出

```
0 0 0 0 0 2 3 ```

## 样例 #2

### 输入

```
5 100
80 40 40 40 60
```

### 输出

```
0 1 1 2 3 ```

# 题解

## 作者：FwbAway (赞：2)

首先，见到这个题不要慌，他问你从第一个人一直加他们的成绩，到当前的人位止，至少剪掉几个人的成绩，才能让成绩的和小于等于 $m$。

这不就是典型的贪心吗！只要先把前面人的和加起来，再判断他们小不小于 $m$，如果不小于就减去刚才那几个数里的最小的那个数，再判断，再减去，知道总和小于 $m$ 了为止。

我以上所述，这是一个用数组做的方法，整体就是注意是先减去最小值再判断，还是先判断再减去最小值。

代码略。

---

## 作者：MithrilSword_XIV (赞：1)

这道题当然要用**贪心**！

## 关于题目
>
>$n$ 为人数，$m$ 为总时间，$t_i$ 为第 $i$ 个人所用的时间。
>
>从 $t_1$ 到 $t_i$ 的总时间最少减去几个人的时间会小于等于 $m$。
>
## 关于思路
>
>在输入时，$i$ 从 $1$ 到 $n$，$sum=\sum\limits_{j = 1}^{i}t_j$，判断 $sum$ 是否小于 $m$，如果小于，就输出 $0$。否则就将 $t_i$ 之前的从大到小排个序，用 $sum$ 循环一直减去 $t$ 数组中的数直到 $sum \le m$，记一下数，输出就行。
>
## 接下来上代码！
>
>```cpp
>#include<bits/stdc++.h>
>using namespace std;
>int n,M,T,t[105],sum,x,cnt;
>bool cmp(int x,int y){//从大到小排序
>	return x>y;
>}
>int main(){
>	ios::sync_with_stdio(false);
>	cin.tie(0);
>	cout.tie(0);
>	cin>>n>>M;//输入
>	for(int i=1;i<=n;i++){
>		cin>>T;
>		t[i]=T;
>		sum+=t[i];//计算sum累加
>		cnt=0;//别忘了初始化
>		if(sum<=M){//如果小于，输出0
>			cout<<0<<' ';
>		}else{
>			x=sum;
>			sort(t+1,t+i,cmp);//排序
>			while(x>M){//减去t数组中的数直到sum<=m
>				x-=t[cnt+1];
>				cnt++;//计数
>			}
>			cout<<cnt<<' ';//输出
>		}
>	}
>	return 0;
>}
>```
#### 完结撒花！！!

---

## 作者：小鲍bob (赞：1)

[配合blog食用更佳](https://www.luogu.com.cn/blog/121771/solution-cf1185c1#)

### 这道题较考验思维

我们先来分析题目，可得出结论:

1.在总和**不超过** $M$ 的情况下，输出都为0

2.总和超过 $M$ 后，要排出前面数的大小，依次减去最大的，直到和小于 $M$ 为止。(此过程可用 $while$ 语句进行)

得到了以上结论，我们便可以写出核心代码(第二个结论)：

```cpp
    int k=s,su=0;//s,k为前面数的总和,su用来计数
    sort(b+1,b+i);//从小到大排序，最后输入的一项千万不要排序
    while(k>m)//此条件下执行
    {
	    k-=b[i-su-1];//因为是从小到大排序且最后一项不用排序
	    su++;//计数++
    }
    cout<<su<<' ';
```

得到了核心代码以后，我们便可以写出整一道题的代码:

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int main()
{
	int n,m,a[102]={0},i,s=0,b[102]={0};
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		b[i]=a[i];
		s+=a[i];//算和
		if(s<=m) cout<<0<<' ';//第一个结论
		else//核心代码
		{
			int k=s,su=0;
			sort(b+1,b+i);
			while(k>m)
			{
				k-=b[i-su-1];
				su++;
			}
			cout<<su<<' ';
		}
	}
	return 0;
}
```

请不要copy，谢谢配合！

---

## 作者：__int127 (赞：0)

## CF1185C1 Exam in BerSU (easy version) 题解

#### [题目传送门](https://www.luogu.com.cn/problem/CF1185C1)

### 题目大意

现在有 $N$ 学生之正在测试，学生们将按照 $1$ 到 $N$ 的顺序依次测试，你是考官。

这些学生每个人都有自己的做题时间，要求考试的时间总和为 $M$，保证 $\max t_i\le M$，如果 $\sum\limits^{i}\limits_{j=1}t_j>M$，那么我们说第 $i$ 个学生不及格。

对于每个学生 $i$，输出在他通过考试的前提下，前面有多少人没有通过考试。

### 样例解释

#### 样例 \#1 解释

$N=7,M=15$，则共有 $N$ 个人，如果 $\sum\limits^{i}\limits_{j=1}t_j>15$，说明第 $i$ 个学生不及格。

第 $1$ 个学生，$t=1,0+1=1,1<15$，则第 $1$ 个学生通过考试的前提下，他前面共有 $0$ 个学生不及格。

第 $2$ 个学生，$t=2,1+2=3,3<15$，则第 $2$ 个学生通过考试的前提下，他前面共有 $0$ 个学生不及格。

第 $3$ 个学生，$t=3,3+3=6,6<15$，则第 $3$ 个学生通过考试的前提下，他前面共有 $0$ 个学生不及格。

第 $4$ 个学生，$t=4,6+4=10,10<15$，则第 $4$ 个学生通过考试的前提下，他前面共有 $0$ 个学生不及格。

第 $5$ 个学生，$t=3,10+5=15,15=15$，则第 $5$ 个学生通过考试的前提下，他前面共有 $0$ 个学生不及格。

第 $6$ 个学生，$t=6,15+6=21,21>15$，则第 $6$ 个学生通过考试的前提下，第 $5$ 个和第 $4$ 个学生不及格，他前面共有 $2$ 个学生不及格。

第 $7$ 个学生，$t=7,21+7=28,28>15$，则第 $7$ 个学生通过考试的前提下，第 $6$ 个、第 $5$ 个和第 $4$ 学生不及格，他前面共有 $3$ 个学生不及格。

#### 样例 \#2 解释

$N=5,M=100$，则共有 $N$ 个人，如果 $\sum\limits^{i}\limits_{j=1}t_j>100$，说明第 $i$ 个学生不及格。

第 $1$ 个学生，$t=80,0+80=80,80<100$，则第 $1$ 个学生通过考试的前提下，他前面共有 $0$ 个学生不及格。

第 $2$ 个学生，$t=40,80+40=120,120>100$，则第 $2$ 个学生通过考试的前提下，第 $1$ 个学生不及格，他前面共有 $1$ 个学生不及格。

第 $3$ 个学生，$t=40,120+40=160,160>100$，则第 $3$ 个学生通过考试的前提下，第 $1$ 个学生不及格，他前面共有 $1$ 个学生不及格。

第 $4$ 个学生，$t=40,160+40=200,200>100$，则第 $4$ 个学生通过考试的前提下，第 $1$ 个和第 $2$ 个学生不及格，他前面共有 $2$ 个学生不及格。

第 $5$ 个学生，$t=60,200+60=260,260>100$，则第 $5$ 个学生通过考试的前提下，第 $1$ 个、第 $2$ 个和第 $3$ 个学生不及格，他前面共有 $3$ 个学生不及格。

### 思路

不难想到要想在 $i$ 个学生通过，只需要让 $sum$ 一直删除除去 $t_i$ 的 $\max t_i$，直至 $sum\le M$，这是只需要输出删除的个数就可以了（注意：此思路在题目 [CF1185C2](https://www.luogu.com.cn/problem/CF1185C2) 无法通过，原因：TLE）。

### 代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[105], b[105];
int sum1, sum2, gs;
int main(){
	ios::sync_with_stdio(false);// 关闭读写同步，本题没啥用，就当长知识了
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		sum1 += a[i];
		sum2 = sum1;// 因为 sum1 会改变，所以每次需要记录 sum1
		b[i] = a[i];
		sort(b + 1, b + i);// 除去 b[i] 后排序
		for (int j = i - 1; j >= 0; j--){// 需要多一次判断，否则如果把除去 b[i] 的所有人的时间删完才满足条件，将会没有输出
			if (sum1 > m && j){// 如果第 i 个人没有及格，则继续删除
				sum1 -= b[j];
				gs++;
			} else {
				cout << gs << " ";
				break;
			}
		}
		sum1 = sum2;// sum1 重新赋值
		gs = 0;// 重置 gs 变量
	} 
	return 0;
}
```

### 最后
本题题解到此结束，希望大家能看懂、有思路。

---

## 作者：qinshi0308 (赞：0)

## 这道题我们需要用贪心来解决

#### 先声明一下下面文字中用到的变量的含义：
>$sum$: 排在当前同学之前的同学的总用时（包括不及格的同学）

>$m$: 考试的总时间

### 1.思路：


我们先把排在这个同学之前的同学的用时的和求出来，如果这个和加上当前同学需要的时间不超过$m$那么不做任何处理，直接让 $sum$ 加上当前同学需要的时间然后输出“$0$”，接着处理下一个同学。

如果当前 $sum$ 加上同学的时间超过了考试时间 $m$ 那么从优先队列中取出用时最大的同学的时间，让 $sum$ 减去它，同时表示答案的 $cnt$ 加 $1$（需要不及格的同学加一个）。重复上述操作，直到 $sum\le m$。
#### 较为简短的思路：
由于我们要在让当前同学通过的情况下让数量最小的的同学不及格，所以我们需要让耗时最大的同学不及格，以为当前的同学争取更多的做题时间。

### 2.代码：
```cpp
# include <bits/stdc++.h>
using namespace std;
int arr[110];
priority_queue<int> q;//定义大根堆
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>arr[i];
	}
	int sum=0;
	for(int i=0;i<n;i++){
		for(int j=0;j<i;j++){
			q.push(arr[j]);//把当前同学之前的同学的用时放进优先队列
		}
		sum+=arr[i];//sum加上当前元素，求出前i个同学的用时和
		if(sum<=m){
			cout<<0<<" ";//满足条件（不会超过考试时间），输出0（即前面的同学都可以及格）
		}else{//不满足条件，计算要让多少个同学不及格
			int sum_=sum;//备份sum，因为sum要存储当前同学之前的同学的用时总和，值不能改变
			int x=0;//记录要让多少个同学不及格
			while(sum_>m){
				sum_-=q.top();//sum减去当前用时最大的同学的用时
				q.pop();//弹出当前同学的时间
				x++;
			}
			cout<<x<<" ";//输出答案
		}
		while(!q.empty()){//清空队列，为下一次循环做准备
			q.pop();
		}
	}
	return 0;
}
```

---

## 作者：Tobiichi_Origami (赞：0)

**思路**

这是一道贪心~~水题~~。

题意：有 $n$ 个人，时间为 $m$，要有效分配时间。这题主要思路就是不要算上自己。详解看下一段。

首先，如果现在所有的时间的和小于等于 $m$ 就没有一个人通过不了直接输出 $0$，否则做一个循环，尽可能让 $i$ 之前的时间长的考生通过不了，求出最小值。为了把最大的放到后面，就需要做一个排序，但是不要算上本个考生的时间，因为是求自己怎么才能通过，然后做一个循环，每次减去一个当前的最大值，直到满足条件，求出结果。

**贴代码，超详细，几乎每一部都给了解释。**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10010];
int main()//优雅的开始
{
    int n,m,sum=0,t;
    //n是人数，m是时间，sum是计数器，t是每个考生的时间
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>t;
        a[i]=t;//存到数组中,以便之后循环
        sum+=a[i];//总时间
        if(sum<=m)//特判，判断是否都通过
        {
            cout<<"0 ";
            continue;
        }
        int num=0,sum2=sum;
        //num是计数器，sum2是为了判断是否可以有效分配时间
        sort(a+1,a+i);//排序，千万不要排序自己
        while(m<sum2)//贪心
        {
            sum2-=a[i-num-1];//从大到小，不用算上自己
            num++;//计数器+1
        }
        cout<<num<<" ";
    }
    return 0;//华丽的结束
}
```



---

## 作者：user470883 (赞：0)

估摸着入门难度吧，怎么放 `C1` 去了······

## 思路：

贪心（排序）+模拟。

我们直接照着题目所要求的样子，用一个 `sum` 变量就从 $1$ 开始往后加。

那么接下来如果符合题目要求（$\leq m$），可以的话好办直接输出 `0` 即可，否则的话，我们每次都减去最大的，直到满足以后。

**优化**：用优先级队列可以跑的更快。

我就先只提供数组解法了，优先级队列可以参考题解区巨佬的。

## AC CODE：
```
#include<bits/stdc++.h>
#define ll long long
#define INF 2000000000
using namespace std;

int n,m,a[102],sum,b[102];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>m;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
		b[i]=a[i];
		sum+=a[i];
		if(sum<=m) 
		{
			cout<<0<<' ';
		}
		else
		{
			int k=sum,ans=0;
			sort(b,b+i);
			while(k>m)
			{
				k-=b[i-ans-1];
				ans++;
			}
			cout<<ans<<' ';
		}
	}
	return 0;
}

/*Things to check before submit:
1. did you forget long long ?
2. did you still CE?
3. = or == , n or m ,++ or -- , i or j , > or >= , < or <=
4. If contains "not", why not Reverse thinking or few affect?
5. is there anything extra to output?
6. keep it simple
7. can part of the code can with c++function replace?
8. smile while submit the code*/

```


---

## 作者：小杨小小杨 (赞：0)

## 题意
给你一大堆的成绩，问你从第一人加到当前的人，至少要减去在自己之前的几个人的成绩，才可以使这个和小于等于 $m$。
## 思路
来一发最优解。  
贪心算法。  
首先，找一个变量进行累加到当前的成绩，这个不用我说了吧。     
接着，请出大根堆的优先队列！    
把每一个在自己之前的都压进优先队列。然后，保存当前的成绩，并不断减去队列头，直到这个和小于等于 $m$。当然了，队列和总和也要记得还原一下。最后输出删除了几个数即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,ans,sum,x,pp;
priority_queue<int> p,h;//大根堆优先队列
int main(){
	scanf("%d%d",&n,&m);//读入
	for (i=1;i<=n;i++){
		scanf("%d",&x);
		ans+=x;sum=0;//累加+清零
		while (!h.empty()) h.pop();//清空保存队列
		pp=ans;//保存总和
		while (ans>m){
			ans-=p.top();//减去队头
            h.push(p.top());//保存队列
			p.pop();sum++;//弹出队头，数量增加
		}
		ans=pp;//还原总和
		printf("%d ",sum);//输出
		p.push(x);//压入队列
		while(!h.empty()) p.push(h.top()),h.pop();//还原队列
	}
	return 0;
}

```


---

## 作者：hhhnnn2112 (赞：0)

# Novice's second question Explanation

这个题的easy version还是比较简单的，没有hard version那样苟。

首先呢，我们可以预先计算总和**Si**每个学生的所有学期，对于i年级学生 **Si=Si-1+Ti**。

这样，我们可以为每个学生对所有持续时间进行排序 **Ti** 在当前学生之前通过学生考试的比例。

让我们按从大到小的顺序进行计算，并计算它们的前缀和 **Di**。

然后对它们进行迭代，直到总持续时间使当前学生也可以AC考试就可以了。

那么说也就是直到 **Si+Ti-Di<=M**。对于**i-th**的答案是迭代持续时间的数量。

# CODE


```cpp
#include <bits/stdc++.h>

using namespace std;

const int T = 100;

int main() {
	int n, m;
	cin >> n >> m;
	
	int sum = 0;
	vector<int> t(n), count(T + 1, 0);
	for (int i = 0; i < n; i++) {
		cin >> t[i];
	}
	
	for (int i = 0; i < n; i++) {
		int d = sum + t[i] - m, k = 0;
		if (d > 0) {
		    for (int j = T; j > 0; j--) {
				int x = j * count[j];
				if (d <= x) {
					k += (d + j - 1) / j;
					break;
				}
				k += count[j];
				d -= x;
			}
		}
		sum += t[i];
		count[t[i]]++;
		cout << k << " ";
	}
}

```


---


# Little Girl and Game

## 题目描述

题目大意：

两名玩家得到了一个字符串s，由小写英文字母组成。 他们玩的游戏按照以下规则描述：

玩家轮流移动; 玩家可以从字符串s中删除任意字母。

如果轮到他时，他之前的玩家可以对字符串s中的字母进行重新排序以获得回文串，则他获胜。

确定哪个玩家将获胜。双方都打得最好！

## 样例 #1

### 输入

```
aba
```

### 输出

```
First
```

## 样例 #2

### 输入

```
abca
```

### 输出

```
Second
```

# 题解

## 作者：_People_ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/CF276B)

题目大意：给你一个字符串 $s$，有两个玩家，他们会依次从这个串中删掉一个字符，使其变成回文串。如果双方都竭尽全力，那么谁会胜出？

[不明白什么是回文串的可以进来看看](https://www.luogu.com.cn/paste/ci1ruqev)

## 思路


我们接收一个字符串，用数组统计其中出现过的字符的次数。

当每个字符出现的次数都是偶数，那么就属于上方链接的第二种情况，那他本身就是一个回文串，不用比了，先手胜；

$\verb!But!$ 先手可不只有这一种获胜方式，如果所有字符出现的次数都是奇数先手照样胜。

为什么？因为先手只要把每个字符都删掉一个，还是属于上方链接的第二种情况。

如果这些情况都不满足，那先手就别想赢了，后手绝对赢。

~~（不行的话动动脑子想想就懂了)~~

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum=0,c[30];//定义c计数，sum用来累加
string a,ans="Second";//定义输入的字符串s和答案ans（默认后手胜（其实默认先手胜也行））
int main(){
    cin>>a;
    for(int i=0;i<a.size();i++)c[a[i]-'a'+1]++;//记录字符串第i项出现的次数
    for(int i=1;i<=26;i++)if(c[i]%2==1)sum++;//当第i个字符出现次数为奇数时，累加器++
    if(sum==0||sum%2==1)ans="First";判断
    cout<<ans;
    return 0;
}
```

都看到这里了，给个赞吧！谢谢！

---

## 作者：Steve_xh (赞：2)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/CF276B)

**题目大意：**

给定一个字符串，两个人轮流删字符，如果到某一方时用字符串里的所有字符可以构成回文串的话，那个人就赢了。给定初始字符串，若双方都采用最优方案，问最后谁会胜利？

# 思路

我们先得知道一个字符串能构成回文串的特征。能构成回文串只有两种可能：

第一种是**最中间有单独一个字符，与它形成回文的另一个字符是自己**。例如 $\verb!abcba!$ 最中间的那个字符是 $\verb!c!$。

第二种则是**所有出现过的字符都是偶数个的**。例如 $\verb!cadccdac!$ 就属于这种。

那么知道了这两个特征就能很容易地写出代码了。用一个桶统计每个字符出现的个数，如果所有字符都出现偶数个的话（属于第二种特征回文），那么初始字符串就是能构成回文，先手赢。如果出现奇数次字符有奇数个的话，那么先手也必赢。为什么？因为每次双方都采用最优策略，先手只要把所有奇数个的字符都删掉一个，就能构成第二种特征回文，就算后手一直捣乱删偶数个数的字符，先手也永远比他快一步，所以一直能赶在他前面抢到能构成回文的字符串。如果这两个条件都不符合的话，则是后手必赢了。

# 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int b[255],ans=0;//统计次数的桶和统计奇数个字符的计数器
int main(){
    memset(b,0,sizeof(b));
    for(char c;cin>>c;)//这样可以避免字符串或字符数组带来的巨大空间
        b[c]++;
    for(int i='a';i<='z';i++)
        if(b[i]%2==1)//统计每个字符，如果出现的次数是奇数就+1
            ans++;
    if(ans==0||ans%2)//如果本身是第一种特征或先手永远赶在后手前面
        cout<<"First";//先手胜
    else
        cout<<"Second";//后手胜
    return 0;
}
```

---

## 作者：togeth1 (赞：2)

## [题 目 传 送 门](https://www.luogu.com.cn/problem/CF276B)

### [题意解析]
有**两**个玩家，一个字符串 $s$，玩家可以轮流从字符串 $s$ 中删去一个字符。如果某个玩家在他的回合可以将字符串 $s$ 重新排列成一个回文串，那么这个人就赢了。两位玩家用的都是最优策略，问第一位玩家是否有必胜策略。

### [思路分析]
回文有两种情况：

1. 例如一个回文字符串 $\verb!abcba!$，它的字符个数是**奇数**个，所以总是会有一个只出现 $1$ 次字母。

2. 例如一个回文字符串 $\verb!abccba!$，它的字符个数就是**偶数**个，所以所有出现过的字符，都会出现偶数次，不会出现奇数次。

结合以上两种情况，我们能发现：

+ 如字符串长度为偶数，且其中一个字母出现了奇数次，输出 $\verb!Second!$。
+ 否则输出 $\verb!First!$。

### **[贴上代码]**
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[10010];
map<char,int>mp;
/*见好像没人用 STL 那就我来用吧*/
int main()
{
	cin>>(s+1);
	int n=strlen(s+1);
	/*求出字符串长度*/
	for(int i=1; i<=n; i++)mp[s[i]]++;
	/*以字符作为下表*/
	for(char i='a'; i<='z'; i++){/*所以 i 是 char 类型，从 a 到 z*/
		if(mp[i]%2==1&&n%2==0){cout<<"Second";return 0;}
		/*如字符串长度为偶数,且其中一个字母出现了奇数次*/
	}
	cout<<"First";
	return 0;
}
```


---

## 作者：Bpds1110 (赞：2)

[**原题传送门**](https://www.luogu.com.cn/problem/CF276B)
# 题面：
给出一个字符串 $s$，一共有两个玩家。每次玩家轮流从字符串中取出一个字符，如果取出后，字符串经过重新排列能回文串，则他获胜。
# Solution:
因为要构成回文串，所以每个字母出现的次数中，**只有 $0$ 或 $1$ 个出现次数为奇数的字母**。我们可以用同记录每一个字母出现的次数。每次双方都会取出任意一个出现次数为奇数的字母。所以，如果出现次数为奇数的字母为奇数个，或者没有，那么第一个玩家获胜，否则第二个玩家获胜。
# Code:
```
#include<bits/stdc++.h>
using namespace std;
const int N='z'+1;
int len,i,ans,f[N];
char s[1001];
int main()
{
	cin>>s+1;
	len=strlen(s+1);
	for(i=1;i<=len;i++) f[s[i]]++;//f数组记录每一个字母出现次数 
	for(i='a';i<='z';i++)
		ans+=(f[i]%2==1);//ans用来记录字母出现次数为奇数的个数 
	if(ans%2==1||!ans) cout<<"First";//如果个数为0或奇数，第一个玩家获胜 
	else cout<<"Second";//否则第二个玩家获胜 
	return 0;
}

```


---

## 作者：lightningZ (赞：1)

## 思路
读完题之后我们可以看出，如果两个人都不是傻子，肯定都不会在删掉字符后是的剩下的字符串是一个回文 $($ 因为要形成回文的条件太苛刻了，必须要另一个人配合 $)$ ，所以想要获胜只有两种情况：

$1.$ 这个字符串一开始就是回文，第一个人获胜。

$2.$ 这个字符串一开始不是回文，谁取最后一个谁获胜。

那么代码也就很清晰明了了。只需要用桶记录每个字符出现的次数，如果是回文那就只可能出现 $0$ 个或 $1$ 个字符有奇数个。如果不是回文就判断 $n$ 是不是偶数，如果是，那第二个人获胜，否则第一个人获胜。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1005];
int t[30];//桶
bool f=true;
int main()
{
	scanf("%s",s+1);
	int n=strlen(s+1);
	for(int i=1;i<=n;i++) t[s[i]-'a'+1]++;
	for(int i=1;i<=28;i++)
	{
		if(t[i]%2==1)//判断回文
		{
			if(f) f=false;
			else// 不是回文
			{
				if(n%2==1) printf("First");
				else printf("Second");
				return 0;
			}
		}
	}
	printf("First");//是回文
	return 0;
}
```

###### 完结撒花

---

## 作者：CznTree (赞：0)

本题做法：**博弈论**。

## 题目描述

给定一个只包含小写字母的字符串 $s$，两个人轮流从中删去一个字母，如果某个人在他的回合前可以将字符串 $s$ 重新排列成一个回文串，那么这个人就赢了。如果两个人都采取最优策略，问最先开始的人是否有必胜策略。

## 题解

如果一个回文串只有最多一个字母出现了奇数次，那么这个回文串就可以重新排列成一个回文串。譬如，字符串 `aabbbcc` 可以重新排列成回文串 `abcabc`。

如果有两个及以上的字母出现了奇数次，那么无论如何都不能重新排列成回文串。例如，字符串 `aabbcc` 不可能成为回文串。

我们可以用一个桶来统计每个字母出现的次数，然后统计出现奇数次的字母数量，设其为 $odd$。

如果 $odd=0$，则说明每个字母都出现了偶数次，则说明第一个人获胜；如果 $odd$ 为奇数，则说明有奇数个字母出现了奇数次。此时最后一个删去字母的人胜利，即后手必胜；否则最先开始的人胜利，即先手必胜。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int cnt[26];
int odd;
int main()
{
    cin>>s;
    for (int i=0;i<s.size();i++) cnt[s[i] - 'a'] ++ ;

    for (int i=0;i<26;i++)
        if (cnt[i] % 2) odd++; 
    if (!odd||odd%2) cout<<"First";
    else cout<<"Second";
}

```


---

## 作者：Moon_Wind (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF276B)

------------

**题目描述：**

两名玩家得到了一个字符串 $s$，由小写英文字母组成。他们玩的游戏按照以下规则描述：玩家轮流移动，玩家可以从字符串 $s$ 中删除任意字母。如果轮到他的，他之前的玩家可以对字符串 $s$ 中的字母进行重新排序以获得回文串，则他获胜。确定哪个玩家将获胜。



**思路：**

形成回文串有两种情况：

**字符串的长度是偶数，每个字母出现都偶数次。**

**字符串的长度是奇数，且有且仅有一个字母出现奇数次。**


我们可以用一个桶来存储每一个字母出现的次数，建议先把字母进行预处理。再枚举每一个字母，统计如果其出现的次数是为奇数，则出现的次数加上 $1$。如果，其出现的次数大于 $1$ 则第二个人赢，否则第一个人赢。


**代码部分:**





------------


```cpp
#include<bits/stdc++.h>
using namespace std;
string s;int n,a[26],k=0;
bool f=false;
int main(){
	ios::sync_with_stdio(false);
	cin.tie();cout.tie();
	cin>>s;
	n=s.size();
	for(int i=0;i<n;i++) a[s[i]-'a']++;//统计字母出现次数。
	for(int i=0;i<26;i++){
		if(a[i]%2!=0)	k++;//统计次数
		if(k==2){//第二个人赢
			f=true;
			break;//退出循环
		}
	}
	if(n%2==0&&f==true) cout<<"Second";//输出
	else cout<<"First";
	return 0;//完结撒花	
} 
```



------------


---

## 作者：Szr__QAQ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF276B)


------------
**题意**：
有两个玩家玩游戏，假设是小明和小军。首先给他们一个字符串 $s$，小明和小军可以删除 $s$ 中的任意字符，看轮到谁的回合可以将 $s$ 重新排序后得到一个回文串，谁就获胜。这里，我们不妨设小明先开始删。


------------
**思路**：
既然是回文串，那么就有两种情况：

**字符串长度为偶数，且每个字符出现偶数次**。

**字符串长度为奇数，有且只有一个字符出现奇数次，其它字符均为偶数次**。

由此，我们就可以开始写代码了。首先，我们可以先获取该字符串的长度，再统计并存储字符串 $s$ 中每个字符出现的次数，最后再遍历一遍用来统计字符个数的数组，如果在数组中访问到的数为奇数，就判断一下 $s$ 的长度是否为偶数，如果判断结果为真，则小军赢；如果成功遍历完了整个数组，则小明赢。


------------
**完整代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int qwq=26;
string s;
int cd,cnt[qwq+1],k=0;
bool f=0;

int main()
{
	ios::sync_with_stdio(false);cin.tie();cout.tie();
	
	cin>>s;
	cd=s.size();
	for(int i=0;i<cd;i++)
	{
		cnt[s[i]-'a'+1]++;
	}
	for(int i=1;i<=qwq;i++)
	{
		if(cnt[i]%2!=0)
		{
			if(cd%2==0)
			{
				cout<<"Second";
				return 0;
			}		
		}
	}
	cout<<"First";
	return 0;	
} 
```


------------

本人只是一名小蒟蒻，若有错误请指正，谢谢大家。


---

## 作者：zjhzs666 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF276B)

# 题意
给出一个字符串，共有两个玩家。每次玩家轮流从字符串中取出一个字符，如果取出后字符串经过重新排列可以回文串，则他获胜，否则另一个玩家获胜。

# 思路
因为要构成回文串，所以每个字母出现的次数中，只有 $0$ 或 $1$ 个出现次数为奇数的字母，每次记录字符串中每一个字母出现的次数，最后记录出现次数为奇数的字母的个数，当它为零或不为二的倍数时，第一个玩家获胜，否则第二个玩家获胜。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int a[30],t,w;
int main(){
	cin>>s;
	t=s.length();
	for(int i=0;i<t;i++)a[s[i]-'a'+1]++;//记录每个字符出现的次数
	for(int i=1;i<=26;i++)
		if(a[i]%2==1)
			w++;//记录每个出现次数为奇数的字母的个数
	if(w%2==1||w==0)cout<<"First";//第一个玩家获胜
	else cout<<"Second";//第二个玩家获胜
	return 0;
} 
```


---

## 作者：Cccsk03 (赞：0)

## 题目意思

两名玩家得到了一个字符串 $s$，由小写英文字母组成。他们玩的游戏按照以下规则描述：

玩家轮流移动；玩家可以从字符串 $s$ 中删除任意字母。

如果轮到他时。他之前的玩家可以对字符串 $s$ 中的字母进行重新排序以获得回文串。则他获胜。

## 解题思路

首先用数组计数，统计每个字符出现的次数。因为字符出现的次数为奇数则无法排列为回文串，所以我们统计出现次数为奇数的字符的个数。若字符串长度为偶且奇数个数不为零，则第二个人胜，否则第一个人胜。

## 代码部分
```
#include<bits/stdc++.h>
using namespace std;
int len,ans,f[27];string s;
int main(){
	cin>>s;
	len=s.length();
	for(int i=0;i<len;i++) 
		f[s[i]-'a'+1]++;
	for(int i=1;i<=26;i++)
		if(f[i]%2==1)
			ans++; 
	if(ans%2==1||ans==0)
		cout<<"First";
	else 
		cout<<"Second";
	return 0;
}
```

---

## 作者：__LiChangChao__ (赞：0)

## 思路

可以使用一个桶统计每一个字母出现次数，对于一个回文串，只有 $0$ 或 $1$ 个出现次数为奇数的字母，设出现次数为奇数的字母数为 $sum$，由于双方均为最优策略，所以每次每人都会取 $1$ 个出现次数为奇数的字母，使其出现次数为偶数，所以若 $sum=0$ 或是 $sum$ 为奇数时，第一个人获胜，否则第二个人获胜。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
map<char ,int>mp;//桶
string s;
long long sum,len;
int main(){
	cin>>s;
	len=s.length();
	for(int i=0;i<len;i++)mp[s[i]]++;//统计次数
	for(int i=0;i<len;i++)if(mp[s[i]]&1==1)sum++;//统计sum
	if(sum&1==1||sum==0)cout<<"First";//输出
	else cout<<"Second";
}
```

---

## 作者：lmndiscyhyzdxss (赞：0)

## 思路
首先用数组计数,统计每个字符出现的次数。因为字符出现的次数为奇数则无法排列为回文串，所以我们统计出现次数为奇数的字符的个数。            
若字符串长度为偶且奇数个数不为零,则第二个人胜,否则第一个人胜。               
做出证明:    
+ 字符的个数要么为奇数,要么为偶数。
+ 如字符串长度为偶数,则要么没有奇数个数的字符,要么奇数个数的字符有偶数个
+ 第二种情况下,第二个人胜,否则第一个人胜

## 比大佬更简短的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[26],g,l;
string s; 
int main()
{
	cin>>s,l=s.size();
	for(int i=0;i<l;i++)a[s[i]-'a']++;
	for(int i=0;i<26;i++)if(a[i]%2==1)g++;
	if(l%2==0&&g>0)cout<<"Second";
	else cout<<"First";
	return 0;
}
```


---

## 作者：hanyipu1414 (赞：0)

## 一、思路
首先用桶存储每个字符出现的次数。因为字符出现的次数为奇数则无法排列为回文串，所以我们统计出现次数为奇数的字符的个数。若个数为奇数或没有，则先手的人胜；若个数为偶数，则第二个人胜。
## 二、Code!
```cpp
#include<bits/stdc++.h>
using namespace std;
int atz[26];//桶 
int main()
{
	int dor=0;//记录出现次数为奇数的字符的个数 
	string str; 
	cin>>str;
	for(int i=0;i<str.length();i++) atz[str[i]-'a']++;//桶 
	for(int i=0;i<26;i++) if(atz[i]%2==1) dor++;//统计出现次数为奇数的字符的个数
	if(dor%2==1) cout<<"First\n";
	else if(dor==0) cout<<"First\n";
	else cout<<"Second\n";//小判断 
	return 0;
}
```


---


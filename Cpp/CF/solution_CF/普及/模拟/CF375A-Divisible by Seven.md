# Divisible by Seven

## 题目描述

有一个（不含前导$0$）正整数$a$，它包含了$1,6,8,9$四个数字，
你需要将其重新排列，使排列后的数字是$7$的倍数。
a 中可以包含其它数字，但一定包含 1689 这四个数字。

## 样例 #1

### 输入

```
1689
```

### 输出

```
1869
```

## 样例 #2

### 输入

```
18906
```

### 输出

```
18690
```

# 题解

## 作者：Argon_Cube (赞：5)

* **【题目链接】**

[Link:CF375A](https://www.luogu.com.cn/problem/CF375A)

* **【解题思路】**

余数，是本题的突破口。

众所周知，一个数如果能被 $7$ 整除，那么这个数模 $7$ 的余数一定是 $0$。

而题目又说：_数 $a$ 一定包含 $1,6,8,9$。_

不难想到，可以把这 $4$ 个数每个分离 $1$ 个出来，把其他的数随便拼，最后用剩下的 $4$ 个数补上模 $7$ 的余数，让余数变成 $0$ 就行了。

此时，我大胆猜想：

**这四个数是不是可以拼出一些数，它们模** $\textbf{7}$ **后能得到所有可能的余数？**

可以直接枚举，口算足矣。

最后得到：

$1869\!\!\!\mod\! 7=0,8961\!\!\!\mod\! 7=1,1689\!\!\!\mod\! 7=2,6198\!\!\!\mod\! 7=3,$
$1698\!\!\!\mod\! 7=4,9861\!\!\!\mod\! 7=5,1896\!\!\!\mod\! 7=6$。

现在，我的猜想被证明了，同时也说明：本题没有无解情况。

因为，无论前面模 $7$ 的余数是什么，都可以用 $1,6,8,9$ 的一个排列补成可以被 $7$ 整除的数。

所以，可以直接把前面的数随便排，升序降序乱序都可以，再直接输出，边输出边做一遍高精模，最后用得到的余数决定该用 $1,6,8,9$ 的哪种排列。

时间复杂度$\Theta(|a|)$。

* **【实现细节】**

$0,7$ 是可以直接放在末尾而不影响答案的，所以我把它们全部放到末尾输出，不参与高精模。

* **【代码实现】**

```cpp
#include <iostream>

using namespace std;

int main(int argc,char *argv[],char *envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	char tmp;
	int counter[10]={},remain=0;//counter对各个数进行计数，remain记录余数
	const int mod_perm[8]={1869,8961,1689,6198,1698,9861,1896,1869};//用于补余数的排列
	while(cin.get(tmp))
		counter[tmp-'0']++;
	counter[1]--,counter[8]--,counter[6]--,counter[9]--;//把1、6、8、9各抽一个出来
	for(int i=1;i<10;i++)
	{
		if(i==0||i==7)
			continue;
		while(counter[i]--)
			remain=(remain*10+i)%7,cout<<i;//输出，顺便做一遍高精模
	}
	cout<<mod_perm[7-remain*10000%7];//用得到的余数决定该用哪种排列补余数
	//以下是为了优化而把0和7堆到一起输出
	while(counter[0]--)
		cout<<0;
	while(counter[7]--)
		cout<<7;
 	return 0;
}

```

---

## 作者：Jjy123 (赞：4)

# 思路
题目保证必有 $1,6,8,9$ 能组成七个数，有这样的规律：

- $1869\bmod7=0$

- $8961\bmod7=1$

- $1689\bmod7=2$

- $6198\bmod7=3$

- $1698\bmod7=4$

- $9861\bmod7=5$

- $1896\bmod7=6$

到这一步，代码就简单多了，只要留下 $1$ 组 ${1,6,8,9}$ 不输出，把其他位的数字都输出在前面，最后输出这七个数中的一个与前面的一串数合起来能被 $7$ 整除（互补）就行了。

$0$ 可以放最后输出，不影响结果。

但是写代码时有两点要注意：
- 前面余数可能刚好是零，$7−0=7$，所以存余数排列的数组要多一个数。

- 因为我们最后要输出 $1,6,8,9$ 的组合，所以 $1,6,8,9$ 这些数要少输出一次。

话不多说，~~直接~~上代码：
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[105],mod[8]={1869,8961,1689,6198,1698,9861,1896,1869};//多存一个数同
string s;
int k;
int m;//余数
int main(){
	cin>>s;
	k=s.length();
	for(int i=0;i<k;i++)f[s[i]-'0']++;
	f[1]--;f[6]--;f[8]--;f[9]--;//保留一组1,6,8,9;
	for(int i=1;i<=9;i++)
		for(int j=1;j<=f[i];j++){
			cout<<i;
			m=(m*10+i)%7;
		}//循环输出其他数并求出余数
	m=7-(m*10000)%7;//与m相加mod7于0的mod数组中数的下标
	cout<<mod[m];
  
	for(int j=1;j<=f[0];j++)cout<<0;//末尾输出0
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：2)

这道题数据范围有些吓人，但这也引导了我们一个重要思路：通过“1、6、8、9”，四个数字组成最后四位，与前面模 7 的余数互补，得到正确答案。

打一个打表程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[4]={1,6,8,9},i,x;main(){
	freopen("number.out","w",stdout);
	do{x=0;for(i=0;i<4;++i)x=x*10+num[i];
		cout<<x<<" "<<x%7<<endl;
	}while(next_permutation(num,num+4));
	return 0;
}
```
不难得到以下结果：
```
1689 2
1698 4
1869 0
1896 6
1968 1
1986 5
6189 1
6198 3
6819 1
6891 3
6918 2
6981 2
8169 0
8196 6
8619 2
8691 4
8916 5
8961 1
9168 5
9186 2
9618 0
9681 0
9816 2
9861 5
```
从中，我们发现，“1、6、8、9”四个数字可以组成 7 的任意模数。于是，此题的详细思路如下：

1. 将所有的零全部放到最后，因为他们不影响答案；

2. 将一个 1、6、8、9 提到除去零的末四位数；

3. 计算除了那个“1、6、8、9”的所有数字模 7 的余数，再用打的表进行互补。

4. 输出前缀、“1、6、8、9”的互补排列、和后缀零。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char str[10000005];
int Map[200];
int main(){
	scanf("%s",str+1);
	int len=strlen(str+1),i,ans;
	for(i=1,ans=0;i<=len;++i)//动态扩展，将0放到最后	 
		while(str[i]=='0'&&i<=len)swap(str[i],str[len--]);
	Map['1']=len-3;Map['6']=len-2;Map['8']=len-1;Map['9']=len;
	bool flag;//将1、6、8、9建立映射，更方便 
	for(i=1;i<=len;++i){
		flag=true;
		while(flag&&i<=len)
			if(Map[str[i]]&&str[Map[str[i]]]!=str[i])
				swap(str[i],str[Map[str[i]]]);
			else flag=false;
		if(i<len-3)ans=(ans*3+(str[i]^'0'))%7;
	}
	fwrite(str+1,1,len-4,stdout);//输出除了1、6、8、9、0的前缀数字	 
	ans=7-ans*4%7;
	switch(ans){//对之前的数对7的模数进行互补	 
		case 1:fwrite("1968",1,4,stdout);break;
		case 2:fwrite("1689",1,4,stdout);break;
		case 3:fwrite("6198",1,4,stdout);break;
		case 4:fwrite("1698",1,4,stdout);break;
		case 5:fwrite("1986",1,4,stdout);break;
		case 6:fwrite("1896",1,4,stdout);break;
		case 7:fwrite("1869",1,4,stdout);break;
		default:break;
	}
	puts(str+len+1);//将后缀0输出	 
	return 0;
}
```

---

## 作者：谦谦君子 (赞：2)

# **思路:**
#### 由于7是个素数，它的余数0~6，那么我们只需要把1,6,8,9，前面不过多小数，其余数必定在（0~6),所以任意排序（1,6,8,9）满足加上（0~6）的余数能被7整除就行了.


------------


#### 其他的就不多说了，核心循环（代码的80%）都在这里



```
while (scanf("%s",st)!=EOF)
{
	memset(cnt,0,sizeof(cnt));
	for (int i=0;i<st.size();i++)
	{
		cnt[st[i]-'0']++;
	}
	cnt[1]--;
	cnt[6]--;
	cnt[8]--;
	cnt[9]--;
	int carry=0;
	for (int i=1;i<=9;i++)
	{
		for (int j=0;j<cnt[i];j++)
		{
			cout<<(char)(i+'0');
			carry=(carry*10+i)%7;
		}
	}
	carry=carry*10000%7;
	cout<<num[carry%7];
	for (int i=0;i<cnt[0];i++)
	{
		cout<<"0";
	}
	cout<<endl;
}
```



---

## 作者：zhouchuer (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/CF375A)
### 题意 & 思路
一道较好的思维题。

题意：给定一个数 $a$，$a$ 中可能包含任何数字，但一定包含 $[1,6,8,9]$，需要我们将数 $a$ 的各数位重新排列，记新的数为 $a'$，使得 $a' \bmod 7 = 0$，输出 $a'$，若无解输出 $0$。

假设所有情况都有解，那么可以想到一种思路：把这个数字分块处理，把 $0$ 和 $7$ 这两个无关紧要的放在最后，把 $[1,6,8,9]$ 连在一起放在中间，把其他数字放在最前面，但是对于每种情况是否都能使开头部分和中间部分取余 $7$ 的余数加起来凑成 $7$ 呢？

我们不妨看看 $[1,6,8,9]$ 的所有排列方式取余 $7$ 的结果（如下）：

- $1869 \bmod 7 = 0$
- $8961 \bmod 7 = 1$
- $1689 \bmod 7 = 2$
- $6198 \bmod 7 = 3$
- $1698 \bmod 7 = 4$
- $9861 \bmod 7 = 5$
- $1896 \bmod 7 = 6$

是的，既然这四个数字的排列组合取余 $7$ 可能得到任何一种余数，所以肯定可以与前面部分的余数凑成一个完整的 $7$，所以不存在无解的情况。

需要代码可以私信我。

---

## 作者：__UrFnr__ (赞：1)

**题目思路**：

题目说这个数一定包含 $1,6,8,9$。

接着我们枚举一下，可组成 $7$ 个数，而我们去算一算他们除以七分别的余数是多少：

* $1869\bmod 7=0$
* $8961\bmod7=1$
* $1689\bmod7=2$
* $6198\bmod7=3$
* $1698\bmod7=4$
* $9861\bmod7=5$
* $1896\bmod7=6$

因此此题没有无解情况。

接着我们留下一组 $1689$，然后把剩下的数字排序，每排一次进行一次高精模，看看应该使用哪一种方法排列 $1689$，找到合适的话就可以知道答案了。

---

## 作者：sxq9 (赞：1)

看了题目，题目保证数里有 $1,6,8,9$ 这几个数字，我就觉得这几个数字排列 $\bmod7$ 可能可以有所有的余数，果然，是这样的：

$$1869\bmod7=0$$
$$8961\bmod7=1$$
$$1689\bmod7=2$$
$$6198\bmod7=3$$
$$1698\bmod7=4$$
$$9861\bmod7=5$$
$$1896\bmod7=6$$

到这一步，代码就简单多了，只要把其他数字放在前面，把这些数放在后面，使前面这些数字的余数加这些数字的余数 $=7$ 就好了。

但是写代码时这三点要注意：



1. 前面余数可能刚好是零，$7-0=7$，所以存余数排列的数组要多一个数。

1. 因为我们最后要输出 $1,6,8,9$ 的组合，所以 $1,6,8,9$ 这些数要少输出一次。

1. 不可以有前导零，所以零最后输出，这样也不影响答案。

注意这三点，就可以写代码了，以下可参考。
```cpp
#include<bits/stdc++.h>
//#define int unsigned long long
using namespace std;
int tp[100],a[]={1869,8961,1689,6198,1698,9861,1896,1869};//上面第一点，注意要多一项。
int main(){
	string s;
	cin>>s;
	for(int i=0;i<s.length();i++)tp[s[i]-'0']++;
	int yushu=0;
	tp[1]--;tp[6]--;tp[8]--;tp[9]--;//上面第二点，注意要少输出一次。
	for(int i=1;i<=9;i++){
		for(int j=1;j<=tp[i];j++)cout<<i,yushu=(yushu*10+i)%7; //余数计算
	}
	yushu=7-(yushu*10000)%7;//互补
	cout<<a[yushu];
	for(int j=1;j<=tp[0];j++)cout<<0; //上面第三点，要注意最后再输出。
	return 0;
}
```

---

## 作者：lnwhl (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF375A)

# Solution
一道很不错的思维题。不难想到把 $1,6,8,9$ 都放在整个数的最后面，设其排列为 $m$。原数可以表示为 $10000k+m$，模 $7$ 意义下等于 $(4k+m)\bmod 7$。因此，我们可以根据 $k\bmod 7$ 的余数构造相应的 $m$。打表即可（如下）。
```
%7=0 1869 8169 9618 9681
%7=1 1968 6189 6819 8961
%7=2 1689 6918 6981 8619 9186 9816
%7=3 6198 6891
%7=4 1698 8691
%7=5 1986 8916 9168 9861
%7=6 1896 8196
```

对于所有的 $0$ 只需要最后输出即可。


[Code](https://codeforces.com/contest/375/submission/161959606)

---

## 作者：Galois_Field_1048576 (赞：1)

一道不错的思维题。  
[题目传送门](https://www.luogu.com.cn/problem/CF375A)  
首先考虑把 $1689$ 的排列放在后面，设剩下的数字为 $k$，$1689$ 的排列为 $m$，则组合后的数为 $10000k+m$，模 $7$ 为 $4k+m~\bmod~7$，这引导我们探索 $1689$ 的排列能覆盖多少个剩余系。简单 `dfs` 可得：  
```plain
%7=0 1869 8169 9618 9681
%7=1 1968 6189 6819 8961
%7=2 1689 6918 6981 8619 9186 9816
%7=3 6198 6891
%7=4 1698 8691
%7=5 1986 8916 9168 9861
%7=6 1896 8196
```
这样就好办了，只要找到 $\equiv 7-4k \pmod{7}$ 的 $1689$ 排列即可。  
打表即可。  
【问题1】：  
Q:如果是 $18906$ 这样去掉一个 $1689$ 只剩 $0$ 的怎么办？  
A:遇到 $0$ 全部放在最后输出。  
【问题2】：  
Q:如何去掉一个 $1689$？  
A:设立桶数组，把 $1,6,8,9$ 四项初始值设置为 $-1$。  


这里是代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int module_arrange[] = {1869, 8961, 1689, 6198, 1698, 9861, 1896, 1869};
string s;
int cnt[10] = {0, -1, 0, 0, 0, 0, -1, 0, -1, -1};
int main()
{
    int mod7 = 0;
    cin >> s;
    for (int i = 0; i < s.length(); ++i)
        cnt[s[i] - '0']++;
    for (int i = 1; i < 10; ++i)
        while (cnt[i]--)
            cout << i, mod7 = (10 * mod7 + i) % 7;
    cout << module_arrange[7 - (mod7 * 4) % 7];
    while (cnt[0]--)
        cout << 0;
    return 0;
}
```

---

## 作者：zhouzhengxuan (赞：0)

### 思路：  
既然题目声明了一定包含 $1$、$6$、$8$、$9$，那么它们一定~~有问题~~有特别之处，我们先把它们提出来，再看看它们可组成的数与 $7$ 取模的结果有多少种：  
- $1869\bmod7=0$
- $8961\bmod7=1$
- $1689\bmod7=2$
- $6198\bmod7=3$
- $1698\bmod7=4$
- $9861\bmod7=5$
- $1896\bmod7=6$

所以，我们自此发现了一个事实：这题没有无解情况。  
既然这样，那我们可以以乱序排其他数字，组成一个数，再用高精模计算这个数 $\bmod7$ 的结果，判断用哪种 $1$、$6$、$8$、$9$ 的组合方式，接在数的头部或尾部，我们就有一个答案了。

代码就不贴了，相信你们都懂，希望管理员大大给过 qwq。

---

## 作者：Autumn_Dream (赞：0)

**思路：**

通过枚举发现，用 $1,6,8,9$ 这四个数不按顺序组成的四位数对 $7$ 取余都能有 $0\sim6$ 的所有可能。如：

$$1869\bmod7=0$$
$$8961\bmod7=1$$
$$1689\bmod7=2$$
$$6198\bmod7=3$$
$$1698\bmod7=4$$
$$9861\bmod7=5$$
$$1896\bmod7=6$$

找到了这个规律，这题就简单多了。后面用高精取余即可。

---

## 作者：liuzhongrui (赞：0)

## 思路

由于输入的数位数较大，因此可以用字符串来解决输入问题。其实这道题不难，有一个~~暴力~~美观的解法。

我们可以对输入的数进行全排列，依次遍历每一种排列，对于每一次遍历，我们定义一个变量 $n$ 用来记录对每一位操作后的结果，从头开始遍历序列，每一次先让 $n$ 扩大 $10$ 倍，再加上当前位的数，由于我们读入的是字符类型，因此要转换一下，之后取模，因为题目要判断 $7$ 的倍数，因此每次都要模 $7$ 取余。

遍历完整个序列后我们最终可以得到这个序列组成的数模 $7$ 的结果，如果结果为 $0$，说明符合条件，输出这个数，程序就可以直接结束了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	string s;
	cin >> s;
	while (1) {
		int n = 0;
		for (int i = 0; i < s.size(); i++) {
			n *= 10;
			n += (s[i] - '0');
			n %= 7;
		}
		if (n == 0) {
			cout << s;
			return 0;
		}
		next_permutation(s.begin(), s.end());
	}
	return 0;
}
```

---

## 作者：Milthm (赞：0)

## CF375A 题解

### 前置知识

- 余数

### 题目解法

这题容易发现这个数是很大的，只能从给定的 $1,6,8,9$ 来分析。

那么我们想到一种构造方式，那就是我们先拿出来一组 $1,6,8,9$，然后我们把剩下的数都扔前面。这时候这四个数通过排列组合，对 $7$ 取模正好能构成全部的 $7$ 种可能性，然后我们把 $7$ 种答案预处理出来，看一下前面的数乘上 $10^4$（因为我们还要再加四个数，所以要空出四个零）对 $7$ 取模剩几，然后用 $7$ 减去这个数（把缺少的补上），输出这个数对应的答案，就可以了。

注意实现的时候先把 $0$ 都拿出来放到最后输出，因为如果是 $10689$ 这样的数，你把 $1,6,8,9$ 都拿出来以后，最高位会是 $0$。

### AC 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[5]={1,6,8,9},c[10],vis[5],q[1000005],ans;
string s;
int main(){
	for(int i=1;i<=24;++i){//预处理 24 种排列方式
		int p=a[0]*1000+a[1]*100+a[2]*10+a[3];
		c[p%7]=p; 
		next_permutation(a,a+4);
	}
	c[7]=c[0];
	cin>>s;
	int l=s.size();
	for(int i=0;i<l;++i){
		for(int j=0;j<4;++j){
			if(s[i]-'0'==a[j]&&!vis[j]){//把四个数拿出来，为了不重复拿设了个 vis 数组
				vis[j]=1;
				q[i]=1;//标记为 1 表示被拿走了
			}
		}
		if(s[i]=='0')q[i]=2;//标记为 2 表示是 0，要后输出
	}
	for(int i=0;i<l;++i){
		if(q[i]==0)ans=(ans*10+s[i]-'0')%7,cout<<s[i];//先输出其它的数
	}
	ans=ans*10000%7;//记得乘 10000
	cout<<c[7-ans];//输出补上的余数
	for(int i=0;i<l;++i)if(q[i]==2)cout<<0;//最后输出剩下的 0
	return 0;
} 
```


---

## 作者：1234567890sjx (赞：0)

$\color{blue}{\texttt{Difficulty: 1600}}$

简单题，但是居然有蓝。洛谷早期评分真的逆天。

通过打表得到 $1689$ 的全排列中 $\bmod\ 7$ 的值有 $7$ 种。

于是打出表来发现答案是：

```cpp
int cal[] = {1869, 8961, 1689, 6198, 1698, 9861, 1896};
```

因为数的范围只有 $10^{10^6}$，所以直接暴力枚举七种不同的情况，计算答案即可。

唯一要注意的一点就是输出的方案不能有前导零。解决方案：把 $1689$ 的全排列直接输出即可。

时间复杂度 $\mathcal O(n)$。

当然可以直接枚举 $1689$ 的 $24$ 种不同的排列，然后暴力计算也是可行的。

解法 $1$：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e6 + 10;
int a[N];
signed main() {
	string s;
	cin >> s;
	int n = s.size(), tot = 0;
	set<int> se = {1, 6, 8, 9};
	for (int i = 0; i < n; i++) {
		if (se.count(s[i] - '0')) {
			se.erase(s[i] - '0');
		} else {
			a[tot++] = s[i] - '0';
		}
	}
	int cal[] = {1869, 8961, 1689, 6198, 1698, 9861, 1896};
	for (int d = 0; d < 7; d++) {
		int res = cal[d] % 7;
		for (int i = 0; i < tot; i++) {
			res = res * 10 + a[i], res %= 7;
		}
		if (res == 0) {
			cout << cal[d];
			for (int i = 0; i < tot; i++) {
				cout << a[i];
			}
			cout << '\n';
			return 0;
		}
	}
	cout << "0\n";
	return 0;
}

```

解法 $2$：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e6 + 10;
int a[N];
signed main() {
	string s;
	cin >> s;
	int n = s.size(), tot = 0;
	set<int> se = {1, 6, 8, 9};
	for (int i = 0; i < n; i++) {
		if (se.count(s[i] - '0')) {
			se.erase(s[i] - '0');
		} else {
			a[tot++] = s[i] - '0';
		}
	}
	int cal[24], tcc = 0;
	string sc = "1689";
	do {
		int td = 0;
		for (int i = 0; i < 4; i++) {
			td = td * 10 + sc[i] - '0';
		}
		cal[tcc++] = td;
	} while (next_permutation(sc.begin(), sc.end()));
	for (int d = 0; d < 24; d++) {
		int res = cal[d] % 7;
		for (int i = 0; i < tot; i++) {
			res = res * 10 + a[i], res %= 7;
		}
		if (res == 0) {
			cout << cal[d];
			for (int i = 0; i < tot; i++) {
				cout << a[i];
			}
			cout << '\n';
			return 0;
		}
	}
	cout << "0\n";
	return 0;
}

```

当然可以通过模数直接判断出答案，常数可以小 $7$ 或者 $24$ 倍。~~但是小蒟蒻不会写 呜呜~~

---

## 作者：XL4453 (赞：0)

### 解题思路：

由于题目保证一定有 $1,6,8,9$ 这几个数，考虑通过这些数结尾凑出一个 $\bmod 7$ 的剩余系，这样无论前面剩下余数是多少都一定有解。

对于这样的四个数字，没有必要写个程序跑，直接手动枚举即可：
$1689\bmod 7=2$,$1698\bmod 7=4$,$1869\bmod 7=0$,$1896\bmod 7=6$,$1986\bmod 7=5$,$1968\bmod 7=1$......
（其实不一定要枚举完，凑成一个剩余系就行了）

最后得出：

0. $1869\bmod 7=0$
1. $1968\bmod 7=1$
2. $1689\bmod 7=2$
3. $6891\bmod 7=3$
4. $1698\bmod 7=4$
5. $1986\bmod 7=5$
6. $1896\bmod 7=6$

-------

然后先从原来的数列分离出 $1,6,8,9$ 各一个，其他的按顺序输出即可，最后通过调整分离后的 $1,6,8,9$ 来使得这是一个对 $7$ 取余为 $0$ 的数。

----

注意本题不能输出前导零，可以考虑将所有的 $0$ 直接放到最后输出。

----
### 代码：

```cpp
#include<cstdio>
using namespace std;
int num,book[10],a,cnt;
int main(){
	while(~scanf("%1d",&a)){
		if(a==1||a==6||a==8||a==9)
		if(book[a]==0){
			book[a]=1;
			continue;
		}
		if(a==0){
			cnt++;
			continue;
		}
		printf("%d",a);
		num=((num*10)+a)%7;
	}
	num=num*10000%7;
	num=(7-num)%7;
	if(num==0)printf("1869");
	if(num==1)printf("1968");
	if(num==2)printf("1689");
	if(num==3)printf("6891");
	if(num==4)printf("1698");
	if(num==5)printf("1986");
	if(num==6)printf("1896");
	for(int i=1;i<=cnt;i++)
	printf("0");
	printf("\n");
	return 0;
}
```


---


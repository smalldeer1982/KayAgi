# Om Nom and Spiders

## 题目描述

奥姆诺姆真的很喜欢糖果，但他不喜欢蜘蛛，因为它们经常偷糖果。有一天，奥姆诺姆想去公园散步。不幸的是，公园里有一些蜘蛛，奥姆诺姆根本不想看到它们。

公园可以用一个n×m的矩形表示。公园里有k蜘蛛，每只蜘蛛在0点的时候都是在田野的某个牢房里。蜘蛛一直在移动，每个蜘蛛总是朝四个方向之一移动（左、右、下、上）。在一个时间单位内，一只蜘蛛从他的牢房向相应方向爬到相邻的一侧牢房。如果在指定的方向没有牢房，蜘蛛就会离开公园。蜘蛛在移动时不会互相干扰。具体来说，一个牢房可以同时有多个蜘蛛。

奥姆诺姆还不确定从哪里开始他的步行，但他肯定想要：

- 在时间为0时开始在田野的上行处行走（保证该行单元格中不包含任何蜘蛛）；
- 沿着田野向最下面一排走去（当奥姆诺姆离开公园边界时，步行结束）。

我们知道奥姆诺姆是通过跳跃来移动的。奥姆诺姆一次跳跃需要一个时间单位，小怪兽会从他的牢房到另一边相邻牢房的下一行或公园边界外。

每次Om Nom降落在一个牢房里，他都会看到此时此刻所有来到牢房的蜘蛛。omnom想要选择一个最佳的单元来开始漫游。为什么每次他都会从牢房开始走呢？帮助他计算每个可能的启动单元所需的值。

## 样例 #1

### 输入

```
3 3 4
...
R.L
R.U
```

### 输出

```
0 2 2 ```

## 样例 #2

### 输入

```
2 2 2
..
RL
```

### 输出

```
1 1 ```

## 样例 #3

### 输入

```
2 2 2
..
LR
```

### 输出

```
0 0 ```

## 样例 #4

### 输入

```
3 4 8
....
RRLL
UUUU
```

### 输出

```
1 3 3 1 ```

## 样例 #5

### 输入

```
2 2 2
..
UU
```

### 输出

```
0 0 ```

# 题解

## 作者：dingyyds11111 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/CF436B)

### 题意：

一些单元格有蜘蛛，每只蜘蛛总是朝四个方向之一移动，奥姆诺姆在每一列依次向下，求每一列奥姆诺姆会遇到多少只蜘蛛。

### 思路：

蜘蛛的数量多且不是很好维护，所以考虑通过每只蜘蛛的方向和位置来算对答案的贡献。具体分类讨论每个方向的贡献。

设当前蜘蛛的位置为 $(i, j)$，奥姆诺姆在第 $k$ 列能看到 $ans_k$ 只蜘蛛。

**当蜘蛛向右走时：**

简单分析可以发现，蜘蛛与奥姆诺姆必然在 $i$ 步后相遇，此时蜘蛛的 $y$ 坐标为 ${i + j - 1}$。

**当蜘蛛向左走时：**

蜘蛛与第一行的距离为 $i - 1$，必然可以反推出相遇时蜘蛛的 $y$ 坐标为 ${j - i + 1}$，但还要先满足 $i \le j$，不然会越界。

**当蜘蛛向上走时：**

由于奥姆诺姆是向下移动，与蜘蛛相对，所以只有他们的距离一直是 $2$ 的倍数才会相遇，放在图中也就是 $i \bmod 2$ 为 $1$。

**当蜘蛛向上走时：**

奥姆诺姆与蜘蛛不可能相遇。

最后，把所有情况结合在一起就可以啦。

```cpp
#include <bits/stdc++.h>
using namespace std;
void cmax(int &x, int y) {x = (x > y) ? x : y;}
void cmin(int &x, int y) {x = (x < y) ? x : y;}

char c[2005][2005];
int ans[10005];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i ++) {
        for (int j = 1; j <= m; j ++) {
            cin >> c[i][j];
        }
    }
    for (int i = 1; i <= n; i ++) {
        for (int j = 1; j <= m; j ++) {
            if (c[i][j] == 'R') {
                ans[i + j - 1] ++;
            }
            if (c[i][j] == 'L' && j - i + 1 >= 1) {
                ans[j - i + 1] ++;
            }
            if (c[i][j] == 'U' && i % 2 == 1) {
                ans[j] ++;
            }
        }
    }
    for (int i = 1; i <= m; i ++) cout << ans[i] << " ";
    return 0;
}
```

---

## 作者：_Starlit__Sky_ (赞：0)

# 洛谷  CF436B 题解

[题目传送门](https://www.luogu.com.cn/problem/CF436B)

## 题目算法

模拟

## 题目思路

### 暴力做法（TLE）

一开始我想的是对于所有 $i∈[1,n]$，枚举此时所有蜘蛛的位置，若蜘蛛的 $y$ 坐标与 $i$ 相等，就代表此蜘蛛可以被 奥姆遇见，将蜘蛛坐标 $x$ 的答案加一。

但是 $n,m\le2000$，$k\le2000^2$，且此做法时间复杂度 $O(nk)$，$3$ 秒也 `TLE` 了。

**代码**

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,k;
struct p{
	int x,y;
	char type;
};
vector <p> v; // 存储蜘蛛初始位置以及ta的类型 
p f(int x,int y,char type){
	p tmp;
	tmp.x = x; tmp.y = y; tmp.type = type;
	return tmp;
} // 帮助快速生成一个 p 类型的元素 
int ans[2005]; // 存储答案 

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m >> k;
	for (int i = 0 ; i < n ; i ++)
		for (int j = 0 ; j < m ; j ++){
			char tmp;
			cin >> tmp;
			if (tmp != 'D' && tmp != '.') v.push_back(f(j,i,tmp));
		}
	for (int y = 0 ; y < n ; y++){ // x,y 为 OmNom 的位置 
		for (int i = 0 ; i < v.size() ; i++){
			int x_ = v[i].x, y_ = v[i].y; // x_,y_为蜘蛛的位置 
			bool flag = true; // 蜘蛛是否离开公园 
			char type = v[i].type; // 蜘蛛类型 
			if (type == 'U' && v[i].y >= 0){
				v[i].y--;
				flag = false;
			}
			if (type == 'L' && v[i].x >= 0){
				v[i].x--;
				flag = false;
			}
			if (type == 'R' && v[i].x < m){
				v[i].x++;
				flag = false;
			}
			if (!flag && y == y_) ans[x_]++;  
		}
	}
	for (int i = 0 ; i < m ; i ++) cout << ans[i] << ' ';
	cout << endl;
	return 0;
}
```

### 数学做法

注：设奥姆初始位置在第 $1$ 行。

由于对所有蜘蛛的枚举是必不可少的（~~你总不能忽视掉一些蜘蛛吧~~），所以我们考虑减少对于每一个 $y$ 坐标的枚举，即不枚举每个蜘蛛在所有时刻的位置。

奥姆在一个时刻总会出现在相同的 $y$ 坐标，只是 $x$ 坐标不同，且一个蜘蛛不可能同时出现在 $2$ 个 $x$ 坐标，蜘蛛们也不能跟随奥姆向下移动（因为 `D` 蜘蛛与奥姆速度相同，起始点不同，相对静止，永不相遇），所以 **每个蜘蛛最多和奥姆相遇一次**。

所以我们就可以将处理每个蜘蛛的时间复杂度将至 $O(1)$。

#### 对于向上走的蜘蛛（`U` 蜘蛛）：

如果此刻奥姆在蜘蛛的正上方，那么下一秒他们就会擦肩而过（见样例 #5），但是如果奥姆在蜘蛛的上方 $2$ 格，他们就会正巧相遇。由此我们不难得出：如果蜘蛛初始 $y$ 坐标是奇数，他就会和在与他相同的 $x$ 坐标的奥姆相遇。

#### 对于向下走的蜘蛛（`D` 蜘蛛）：

`D` 蜘蛛与奥姆速度相同，起始点不同，相对静止，永不相遇，可以忽视。

#### 对于向左走的蜘蛛（`L` 蜘蛛）：

如果蜘蛛的初始坐标为 $x,y$，又因为奥姆的初始 $y$ 坐标是 $1$，所以当奥姆移动至他 $y$ 坐标为 $y$ 时，需要 $y+1$ 单位时间，此时，此蜘蛛的 $x$ 坐标位于 $x-(y+1)$，所以当奥姆于此 $x$ 坐标出发时能与此蜘蛛相遇。

#### 对于向右走的蜘蛛（`R` 蜘蛛）：

如果蜘蛛的初始坐标为 $x,y$，又因为奥姆的初始 $y$ 坐标是 $0$，所以当奥姆移动至他 $y$ 坐标为 $y$ 时，需要 $y+1$ 单位时间，此时，此蜘蛛的 $x$ 坐标位于 $x+(y+1)$，所以当奥姆于此 $x$ 坐标出发时能与此蜘蛛相遇。

## 代码
本人提交已 AC。放心食用。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,k;
int ans[2005]; // 答案 

int main()
{
	cin >> n >> m >> k;
	for (int y = 1 ; y <= n ; y ++){
		for (int x = 1 ; x <= m ; x++){
			char tmp;
			cin >> tmp; // 蜘蛛种类 
			if (tmp == 'U' && y % 2 == 1) ans[x]++;
			else if (tmp == 'L' && x - (y - 1) > 0) ans[x - (y - 1)]++;
			else if (tmp == 'R' && x + (y - 1) <= m) ans[x + (y - 1)]++;
		}
	}
	for (int i = 1 ; i <= m ; i ++) cout << ans[i] << ' ';
	cout << endl;
	return 0;
}

```

~~点个赞再走吧~~ $awa$

---

## 作者：_Kimi_ (赞：0)

# CF436B 题解

掉绿了，赶紧来水一发题解（。

### 题意

有一个大小为 $n \times m $ 的公园，公园里有 $k$ 个蜘蛛，蜘蛛会沿着一个方向一直走，直到走出公园。更具体地，有蜘蛛的格子会有一个字母，$U$，$D$，$L$，$R$，分别代表向上走，向下走，向左走和向右走。

公园的第一行不会有蜘蛛。奥姆要从第一行的每一列向下走，直到走出公园。奥姆每次可以走一格，当奥姆走一格后，所有还在公园的蜘蛛也会向着目标方向走一格。求在路上会与多少个蜘蛛见面。

对于与蜘蛛见面的定义：在同一时刻，奥姆与蜘蛛同时走进一格地块。

### 思路

假设这个蜘蛛处于 $A_{i,j}$，我们考虑不同蜘蛛对答案的贡献。

#### 1. 当蜘蛛向上走。

此时又要分两种情况，为什么呢？

看一个样例：

```cpp
2 2 2
..
UU
```

看似两行答案都为一，其实不是。当奥姆走到第二行，蜘蛛走到第一行，他们同时处于一个地块才算相遇，他们错过了，并没有相遇，贡献为零。所以要判断奇偶。当 $2 \nmid i$ 时这只蜘蛛对第 $j$ 行的贡献加一。

#### 2. 当蜘蛛向下走。

当蜘蛛向下走，永远不可能与奥姆相遇。

#### 3. 当蜘蛛向右走。

因为奥姆从第一行开始向下走，会在第 $i$ 时刻 到达这一行，则这个蜘蛛会对第 $i + j - 1$ 列做出贡献。还需注意的是判断边界，要不然就 RE 了。

#### 4. 当蜘蛛向左走。

同理，向左也是一样的，会对 $j - i + 1$ 列做出贡献。

### 代码 

```cpp
#include<bits/stdc++.h>
#define int long long
#define WA AC
using namespace std;
const int maxn = 2010;
int n, m, k, ans[maxn];
char A[maxn][maxn];
void input(){
    ios::sync_with_stdio(0);
	cin.tie(0);
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	cin >> n >> m >> k;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++) cin >> A[i][j]; 
	}
}
signed main(){
	input();
	for(int i = 2; i <= n; i++){
		for(int j = 1; j <= m; j++){
        	if(A[i][j] == 'D') continue;
			if(A[i][j] == 'U' && i % 2 == 1) ans[j]++;
			if(A[i][j] == 'R' && i + j - 1 <= m) ans[i + j - 1]++;
			if(A[i][j] == 'L' && j - i + 1 >= 1) ans[j - i + 1]++;
		}
	}
	for(int i = 1; i <= m; i++) cout << ans[i] << ' ';
	return 0;
}
```


---


# A rectangle

## 题目描述

设置一个平面直角坐标系，选择两个点 $(x_1,y_1),(x_2,y_2)$ 建立一个矩阵，其中 $x_1 \le x_2$，$y_1 \le y_2$ ，用中心坐标 $(x,y)$ 为整数的正六边形填充这个矩阵，其中 $x_1 \le x \le x_2$ $,$ $y_1 \le y \le y_2$ ，并且对于每个整数 $x$ ，都有中心具有此类 $x$ 坐标的单元格，对于每个整数 $y$ ，都有中心具有此类 $y$ 坐标的单元格。保证 $x_2-x_1$ 可以被 $2$ 整除。  

问：能填充多少个正六边形。

## 样例 #1

### 输入

```
1 1 5 5
```

### 输出

```
13```

# 题解

## 作者：沉石鱼惊旋 (赞：1)

### 题目翻译

有一个矩形，四个顶点分别是 $x_1,y_1,x_2,y_2$。问在中间铺设正六边形，每个六边形不能整个超出矩形范围，可以最多超过 $\frac{3}{4}$，问最多能铺多少个。

如样例中，左下角的正六边形露出了 $\frac{3}{4}$，最下面第二个正六边形露出了 $\frac{1}{2}$。

### 题目思路

我们通过观察下图，很容易发现，这些正六边形摆放都是按以下规律：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF630E/48c2c84bca0c98bd6d46d326b4d0dd0c737e119c.png)

第奇数列，摆 $n$ 个。

第偶数列，摆 $n-1$ 个。

那么我们算出摆了多少列和 $n$ 具体是多少即可。

我们考虑把这张图，整体往左移半格。那么这张图的 $x_1=0.5$，$x_2=4.5$。再加上超过的部分，长就是 $4.5-0.5+1=5$。

同理，这张图的宽也加上超过的部分，就是 $5-1+2=6$。

那么通过长，算出奇列数和偶列数，通过宽，算出每列上面有多少的格子。

最后只要**奇数列个数 $\times$ 奇数列的格子 $+$ 偶数列个数 $\times$ 偶数列的格子**。

### AC 代码

```cpp
void solve()//记得开longlong
{
	ll x1,y1,x2,y2;
	cin>>x1>>y1>>x2>>y2;
	ll x=x2-x1+1,y=y2-y1+1;//算出长宽
	ll ans=((y+1)/2)*((x+1)/2)+((y-1)/2)*((x-1)/2);//结论带入
	cout<<ans<<endl;
}
```



---

## 作者：skyskyCCC (赞：0)

## 前言。
题目简述：选择 $\left(x_1,y_1\right)$ 和 $\left(x_2,y_2\right)$ 构造一个矩形，用中心坐标 $\left(x,y\right)$ 为整数的正六边形填充，请求出在该矩形中能填充多少个正六边形。

注意到 $x$ 和 $y$ 的取值为 $10^9$ 所以采用扫描穷举法可能不行，但是用六边形填充的要求给了我们启发：这道题可能是图形分析结论题。
## 分析。
其实我们发现，对于每一个矩形，都存在两种铺的方法：一种是将其中的一个六边形的中心定为两个都是偶数的横纵坐标，此时由于题目限制要求，则其余和它相邻（水平关系，不包括上下关系）的矩形的中心坐标均为一个两个奇数，而上下则为偶数。这个情况就是题目中的图的样子，不懂得可以结合图。另一种就是将其中一个六边形的中心定为一奇一偶，那么同理相邻的四边形的中心也是一偶一奇，综上所述，两种铺法的六边形的共同点在于均是相邻之间中心坐标奇偶性相反。

同时我们发现，因为无论如何铺，在边界上的中心坐标中，坐标奇数的个数和偶数的个数相同，那么我们可以先求出它们的个数，然后求解。具体来说，我们采用割补法的情况，求出长上面的奇数坐标的个数和偶数坐标个数，再求出宽上的奇数坐标个数和偶数坐标个数，那么因为矩形的面积公式是长乘上宽，又因为在边缘上突出（即中心坐标在边界上）的六边形中间两两隔了一个边长，宽上每个六边形直接都是相连的，所以直接用长上的奇数坐标个数和对应上宽上的奇数和偶数坐标即可。另一种铺法同理，取最大值即可。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
long long x_11,y_11,x_22,y_22;
long long x,y,c_j,c_o,k_j,k_o;
//c表示长。k表示宽，j表示奇数坐标，o表示偶数坐标。
//记录的是个数。 
int main(){
    cin>>x_11>>y_11>>x_22>>y_22;
    if(x_11%2){
    	c_j+=(x_22-x_11+1)-(x_22-x_11)/2;
	    c_o+=(x_22-x_11)/2;
	    //寻找个数，注意相互直接的转换。
		//题目保证了x_22-x_11可以被2整除。 
	}
    else{
        c_j+=(x_22-x_11)/2;
		c_o+=(x_22-x_11+1)-c_j;
	}//注意在x_11奇偶性不同的情况下需要分别考虑。
	//这是因为起始点不同。 
    x=y_11;
    y=y_22;
    if(y_11%2){
        k_j++;
        x++;
    }
    if(y_22%2){
        k_j++;
        y--;
    }//统计宽，分边。 
    k_j+=(y-x)/2;
    k_o=(y-x+1)-(y-x)/2;
    long long ans=max(c_j*k_j+c_o*k_o,c_j*k_o+c_o*k_j);
    cout<<ans<<"\n";
    return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：smydahaoren (赞：0)

### 题目大意


[![pFEQcE8.png](https://s11.ax1x.com/2024/01/19/pFEQcE8.png)](https://imgse.com/i/pFEQcE8)

如图，题目给定两个坐标点，然后在坐标点所围出的长方形中做六边形，求六边形的数量。

### 解题思路

根据这个例子，六边形总共分为 $5$ 列。列数等于所围长方形的列数为 $(x_2-x_1+1)$。

在奇数列中，因为一个六边形高度为 $2$。所以有 $\frac{(\texttt{长方形高度}+1)}{2}$ 行。也就是 $\frac{(y_2-y_1)}{2}+1$ 行。偶数列比奇数列的六边形个数少一个，为 $\frac{(y_2-y_1)}{2}$ 个。

所以所求数量为 $\text{奇数列所包含六边形数}\times\text{总列数}-\text{偶数列个数}$。

那么根据这个公式可以列出以下代码。

```
#include<iostream>
using namespace std;
const int N=10000009;
long long x1,x2,Y1,y2;
int main(){
	cin>>x1>>Y1>>x2>>y2;
	long long x=x2-x1+1;
	long long y=y2-Y1+1;
	cout<<x*(y+1)/2-(x-1)/2;
	return 0;
}

```


---

## 作者：__Segment__ (赞：0)

[题目](https://www.luogu.com.cn/problem/CF630E)

### 题意：

有一个矩形，其中四个顶点的坐标分别为：$x_1$，$y_1$，$x_2$，$y_2$。要在矩形中间铺正六边形，问：最多可以摆几个正六边形？

仔细观察图片，我们就会发现一种规律。
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF630E/48c2c84bca0c98bd6d46d326b4d0dd0c737e119c.png)

一个格子相当于半个正六边形。

如果当前列是**偶数列**，那么摆**奇数个**正六边形；否则摆**偶数个**正六边形。

设奇数列为 $n$ 的话，那么**偶数列**摆 $n$ 个，否则摆$n - 1$ 个。

### 分析：

矩形的长为 $y_1 - x_1$，宽为 $y_1 - x_2$，面积为 $y_1 - x_1 \times y_1 - x_2$。

接着使用小学的割补法，把它转换成规则的图形。

老师说要把图片往右边移 $0.5$ 个格子。所以，长就是 $5$，宽就是 $6$。所以就是：

奇数列个数 $\times$ 奇数列格子 $+$ 偶数列个数 $\times$ 偶数列格子。（~~别问我为什么像红名 dalao 的总结，我们老师说的。~~）

由于数据较大，$-10^9 \le x_1 \le x_2 \le 10^9$，$-10^9 \le y_1 \le y_2 \le 10^9$，直接开 `long long`。

### Code
看了某位 dalao，发现好像面积要 $\div 2$。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int step(ll n) {
	return (n + 1) / 2;
}
int step2(ll n) {
	return (n - 1) / 2;
}
int main() {
	ll x1, y1, x2, y2;
	cin >> x1 >> y1 >> x2 >> y2;
	ll c = x2 - x1 + 1, k = y2 - y1 + 1;
	ll ans = step(k) * step(c) + step2(k) * step2(c);
	cout << ans << endl;
	return 0;
}
```

---

## 作者：_VEGETABLE_OIer_xlc (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF630E)

给定一个长方形对角线端点坐标，在长方形里摆六边形，六边形最多可以超出   $\frac{3}{4}$，问最多可以摆几个六边形。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF630E/48c2c84bca0c98bd6d46d326b4d0dd0c737e119c.png)

想让六边形摆的最多，那肯定要尽可能按照题目的要求摆啦！

但这样曲折的图形并不好算，所以要用割补，使其变为一个规则图形。

通过观察，能发现在图中，一个格子相当于半个六边形。

设原长方形的长为 $x$，宽为 $y$。

将原长方形的长增加 $1$，宽增加 $2$。

通过割补会发现，现在的长方形少了 $\begin{bmatrix} \frac{x-2}{2} \end{bmatrix} + 1$ 个六边形。

用长方形面积除以 $2$，求出现在长方形相当于几个六边形。再减去多的六边形，就能求出最多有几个六边形了。

好了，废话不多说，上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long x1,y1,x2,y2;
	cin>>x1>>y1>>x2>>y2;
	long long x=x2-x1+1,y=y2-y1+2;
	long long s=x*y/2;
	long long no=ceil((x-2)/2.0);
	s-=no;
	cout<<s;
	return 0; 
} 
```

---

## 作者：XL4453 (赞：0)

不是很难的说。

---
### 解题思路：

本题数据范围很大，考虑直接计算。

这样的一个凹凸的形状并不好算，可以先考虑用割补法，也就是将上面补起来然后再减去补上的面积。那么可以发现，在补上上面的一些空缺后，就可以直接用矩形的面积来计算了。

具体的，这个矩形的宽为 $\left\lfloor\dfrac{y_2-y_1}{2}\right\rfloor+1$ 长为： $x2-x1+1$ 面积为：$(\left\lfloor\dfrac{y_2-y_1}{2}\right\rfloor+1)\times(x2-x1+1)$，然后减去补上的面积：$\left\lfloor\dfrac{x2-x1}{2}\right\rfloor$ 就行了。

注意开 long long。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
long long x1,x2,y1,y2;
int main(){
	scanf("%I64d%I64d%I64d%I64d",&x1,&y1,&x2,&y2);
	printf("%I64d",((y2-y1)/2+1)*(x2-x1+1)-(x2-x1)/2);
	return 0;
}
```


---


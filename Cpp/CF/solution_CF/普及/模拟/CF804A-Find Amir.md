# Find Amir

## 题目描述

题面：

有n座城市,标号为1~n,定义标号为i,j的两座城市的距离为(i+j)%(n+1).求走完所有城市所需的最小花费(起点任意).

## 样例 #1

### 输入

```
2
```

### 输出

```
0
```

## 样例 #2

### 输入

```
10
```

### 输出

```
4
```

# 题解

## 作者：小闸蟹 (赞：6)

```cpp
// 这是一个贪心题
// 每次都尽量走(i + j == n + 1)的点对，实在不行就走(i + j == n + 2)的
// 那么就有一半的边能取0，一半的边能取1，然后总共(n - 1)条边，答案便是(n - 1) / 2
#include <iostream>

int main()
{
    int n;
    std::cin >> n;
    std::cout << (n - 1) / 2 << std::endl;

    return 0;
}
```

---

## 作者：Fearliciz (赞：0)

贪心练手题。

#### 题目大意：

有 $n$ 座城市,定义标号为 $i,j$ 的两座城市的距离为 $(i+j)\bmod(n+1)$。求走完所有城市所需的最小距离。

#### 解题思路：

走 $n/2$ 条长度为权值为 $0$ 的边，和 $(n-1)/2$  条长度为 $1$ 的边。

举个例子：

当 $n=5$ 时，先从 $1$ 走到 $5$，从 $5$ 走到 $2$，再从 $2$ 走到 $4$ 最后从 $4$ 走到 $3$。

一共走了 $n/2$ 条长度为 $0$ 的边和 $(n-1)/2$ 条长度为 $1$ 的边。

所以答案是 $(n-1)/2=2$。

同理，当 $n=2$ 时，答案为 $0$。

#### 代码:

别人都写了 $\texttt{C++}$，我只能写 $\texttt{C}$ 了。

```c
#include<stdio.h>
int main()
{
	int a;
	scanf("%d",&a);
	printf("%d",(a-1)/2);
	return 0;
}
```


---

## 作者：Daidly (赞：0)

这道题只需要简单的想一下就可以了：

首先，一共有 $n$ 个点，所以线最少要有 $n-1$ 条;

可以发现，在一个 $1$ 到 $n$ 的序列中，无论 $n$ 为奇数或偶数，必将有 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 组的两个数存在于序列中且和为 $n+1$，例如：

```cpp
1-6:
1+6=2+5=3+4=7
//共三组
1-7
1+7=2+6=3+5=8
//共三组
```
所以我们只需要考虑如何把这些组数连在一起，最优选择为 $(i+j)=(n+1)$，但已经用完，所以退而求其次，使得 $(i+j)=(n+2)$，这样 $(i+j)\%(n+1)=1$,可以发现，每一组都可以通过这样的方式连在一起，所以答案就是 $\frac{n-1}{2}$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    cout<<(n-1)/2;
    return 0;    
}
```

---

## 作者：翼德天尊 (赞：0)

## STEP 1 浅谈做法

利用贪心的思想。

我们观察模数，$n+1$？我们观察问题，要求最小？那我们就尽量凑 $n+1$ 呗！凑不到 $n+1$？那就 $n+2$！

**简单流程：**

我们先从 $1$ 出发，然后向 $n$ 走，需要 $(n+1)\%(n+1)=0$ 步，然后再走到 $2$，需要 $(1+1+n)\%(n+1)=1$ 步，再往 $n-1$ 走，需要 $(n-1+2)\%(n+1)=0$ 步……

以此下推，我们就可以得到一个公式，即答案为 $(n-1)/2$。

## STEP 2 AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	printf("%d\n",(n-1)/2);//推公式
	return 0;
}
```


---

## 作者：昊月星辰 (赞：0)

## 一道典型的贪心题
###   大意：
  
   一共有$n$个数，第i个城市与第j个城市之间的距离为($i+j$)$\%$($n+1$),求走遍所有城市所需的最短距离。
  
  我们只需要让两数相加除以$n+1$的余数最小即可。所以我要让他们的余数尽可能等于0，实在不行等于1。就有$\frac{1}{2}$的边为0，$\frac{1}{2}$的边为1，一共需要走$\frac{n-1}{2}$的距离。
  
$AC\ Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<(n-1)/2<<endl;
    return 0;
}
```


---

## 作者：九月_014 (赞：0)

在n个城市中,寻找最短路,每两个城市之间的距离是(i+j)%(n+1),拿到这个题,第一反应是最小生成树,但是看到N<10^5,我就打消了这个思路,所以我简单地敲了一小段代码,

```cpp
for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i!=j)
			{
				printf("%d %d %d\n",i,j,(i+j)%(n+1));
			}
		}
	}
```

把6带进去后，出现了一大堆数字，稍微总结了一下，得到了6的最短路.

1--6=0

2--5=0

3--4=0

然后把这三条距离为零的边连起来，

2--6=1

3--5=1

最后就是结果.

所以，我们可以先连（n/2）条0边，再连（n-1）/2条1边.

最后的AC代码

```cpp
#include<iostream>
#include<cstdio>

inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=(s<<1)+(s<<3)+ch-'0';
		ch=getchar();
	}
	return s*w;
}
int main()
{
	int n=read();
	printf("%d",(n-1)/2);
}
```



---


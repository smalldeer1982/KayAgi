# Pizza Separation

## 题目描述

一个圆，被切成了 $n$ 块，第 $i$ 块的圆心角为 $a_i$。

你可以将相邻的块合并，直到这 $n$ 块组合成两大块，你需要使得这两大块的圆心角之差最小。

## 说明/提示

对于 $100\%$ 的数据，$1\le n, a_i\le 360$。

数据保证所有圆心角度数之和为 $360$ 度。

样例一说明：第 $1$ 块和第 $2$ 块组成一块，第 $3$ 块和第 $4$ 块组成一块，答案即为 $[(90 + 90) - (90 + 90)] = 0$。

样例二说明：第 $1$ 块和第 $2$ 块组成一块，第 $3$ 块单独组成一块，答案即为 $[(100 + 100) - 160] = 40$。

样例三说明：一共只有 $1$ 块披萨，只能被一个人拿走，答案即为 $(360 - 0) = 360$。

样例四说明：第 $1$ 块和第 $4$ 块组成一块，第 $2$ 块和第 $3$ 块组成一块，答案即为 $[(170 + 10) - (30 + 150)] = 0$。

## 样例 #1

### 输入

```
4
90 90 90 90
```

### 输出

```
0
```

## 样例 #2

### 输入

```
3
100 100 160
```

### 输出

```
40
```

## 样例 #3

### 输入

```
1
360
```

### 输出

```
360
```

## 样例 #4

### 输入

```
4
170 30 150 10
```

### 输出

```
0
```

# 题解

## 作者：Da_un (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/CF895A)
题意都能读懂，下面直接讲思路。

## 思路
本来想用一些奇妙的算法，但看到数据 $1 \leq n \leq 360$，直接用暴力来解决这个问题即可。因为只有两个人在分这个披萨，所以每人分到 $180^\circ$ 是最优的，那么答案一定要往这方面靠，可以用三重循环来枚举所有可能出现的方案并依次比较求出离每人分到 $180^\circ$ 这一最优解最近的那个方案，随时记录二者之差，最后处理一下即可。

循环具体看代码。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int n,f[400];
int t=400,tot;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&f[i]);
	if(n==1){
		printf("360\n");
		return 0;
	}//特判， 只分成一份一定有一个人拿了全部，另一个人什么都没有 
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++){//前两重循环枚举一个人所能分到的披萨度数的所有方案 
			tot=0;//tot则是用于累加上面求出的每一种方案所能得到的度数 
			for(int k=i;k<=j;k++)//枚举每种方案 
				tot+=f[k],t=min(t,abs(tot-180));//累加并比较和最优解的距离 
		}
	printf("%d\n",t*2);//因为只求了一个人的,所以最后的结果要*2 
	return 0;
}
```
完结撒花~~

---

## 作者：MeowScore (赞：1)

## 题目大意

有一个完整的圆形披萨，被分成了 $n$ 小块扇形，给定每一小块的圆心角度数。把整个披萨沿着切割线分成连续的两块，使得两个扇形圆心角度数之差最小，求这个最小值。


------------
## 解决问题

~~蓝题大恶评，建议降红！~~

题目说白了就是把有 $n$ 个数的环断成两截，使两截数字之和的差距最小。由于这 $n$ 个数之和一定是 $360$，我们只用设出其中一截数的和，就能表示另一截。设其中一截数的和为 $x$，则另一截的和为 $360-x$。两截的差距便是 $|360-2x|$，化简一下就是 $2\times|180-x|$。不难看出，要使这个值最小，我们要使其中一截数之和尽可能接近 $180$。问题转换成从这个环中取一段数，使这一段数的和尽可能接近 $180$。

首先是最暴力的做法：枚举断点，断环为链。对于每一种断法，找到权值和最接近 $180$ 的子段。太慢了！

受环形dp启发，我们把环看作是一条从 $1$ 到 $n$ 的链，再把这条链复制一遍接到后面，考虑这条长度为 $2n$ 的新链中所有长度不超过 $n$ 的子段即可。再加一个前缀和优化，跑得很快。


------------
## 上代码
```
#include<bits/stdc++.h>
using namespace std;
int a[1000];
int s[1000];
int main(){
	int n;
	cin>>n;
	int i,j;
	for(i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(i=1;i<=2*n;i++)
		s[i]=s[i-1]+a[i];//预处理前缀和 
	int ans=99999;
	for(i=1;i<=n;i++)//枚举当前子段长度 
		for(j=1;j+i-1<=2*n;j++)//枚举当前长度下可能的起点，即子段的终点不超过2n
			ans=min(ans,abs(s[i+j-1]-s[j-1]-180));//两个前缀和做差，求得中间一段，再减去180，更新ans
	/*现在我们得到的ans便是题解中说的|180-x|的最小值*/
	/*由于要求的是|360-2x|,输出ans*2即可*/
	cout<<ans*2;
	return 0;
}
```


---

## 作者：猜一猜我是谁 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/CF895A)

本题还是比较简单的，所以直接讲思路。
# 分析
由于保证了各部分的和，所以要想让差尽可能小，必须让两部分尽可能的接近 $180$，可以想到用三重循环来枚举。我们可以随时记录两大块之差，依次比较即可。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[400];
int n,ans=400,s;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    if(n==1)//特判
    {
        cout<<360;
        return 0;
    }
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)//前两重循环枚举一个人分到的披萨
        {
            s=0;
            for(int k=i;k<=j;k++)
                s+=a[k],ans=min(ans,abs(s-180));//比较
        }
    cout<<ans*2;//由于只算了一个人，所以最后要乘上2
}
```


---

## 作者：yzx72424 (赞：0)

只要找连续的和与180相差最小的，输出它的两倍。
这题数据很小，直接暴力搜即可。复杂度<O(n^3)~~(具体不会算...)~~

```
#include <bits/stdc++.h>
using namespace std; 
int a[405],sum;
int main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d",&a[i]);
    if(n == 1) {
        cout << 360  ;
        goto GG;
    }
    else {
        int minn=360;
        for(int i=0;i<n;i++) 
            for(int j=i;j<n;j++,sum=0)  
                for(int k = i; k <= j; k++)  
                    sum+=a[k],minn= min(minn, abs(180-sum));  
     cout<<2*minn;
    }GG:
    return 0;
}
```
~~吐槽一下,goto真的好用~~

---

## 作者：Nemonade (赞：0)

~~第一次写蓝题的题解，有点紧张呢~~

由题可知，两个人分一个 $360^{\circ}$ 的披萨，不考虑所有情况，每个人都分到 $180^{\circ}$ 的披萨时，两人相差最少。

由于数据范围极小，所以可以枚举所有可能的披萨区间，找出最小值。

AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=380;
int a[N],sum,n,ans=INT_MAX;

int abs(int x){
	return x>0?x:-x;
}

int main(){
    cin>>n;
    for(register int i=1;i<=n;++i) cin>>a[i];
    for(register int i=1;i<=n;++i){
    	for(register int j=i;j<=n;++j){
    		int sum=0;
        	for(register int k=i;k<=j;++k) sum+=a[k],ans=min(ans,abs(180-sum));
		} 
	}
    cout<<ans*2;	//不要忘了最后*2
    return 0;
}
```

---


# No More Inversions

## 题目描述

你有一个长度为 $n$ 的序列 $a$。$a=\{1,2,3,\dots,k-1,k,k-1,k-2,\dots,k-(n-k)\}(k\le n<2k)$。

我们称 $a$ 中的一个逆序对为下标 $i,j$ 的两个元素有 $a[i]>a[j] (i<j)$。

你能构造出一些长度为 $k$ 的排列 $p$，然后用以下规则构造长度为 $n$ 序列 $b$：$b[i]=p[a[i]]$。

你的目标是找到一个排列 $p$，在 $b$ 中逆序对的个数不超过 $a$ 中逆序对个数的情况下使得 $b$ 的字典序最大。

小提示：长度为 $k$ 的排列列中 $1\sim k$ 各出现且仅出现一次。

另一个小提示：序列 $s$ 的字典序小于 $t$ 意味着 $s$ 是 $t$ 的前缀或者第一个$s_i\ne t_i$ 有 $s_i<t_i$。

## 样例 #1

### 输入

```
4
1 1
2 2
3 2
4 3```

### 输出

```
1 
1 2 
2 1 
1 3 2```

# 题解

## 作者：lndjy (赞：5)

并没有完全读懂题，但是这并不影响我通过大致理解题意和样例和样例解释找规律猜结论过了这个题。

先说一下大致题意，就是要求一个排列 $p$，然后对于给定数列把每个数的值用 $p$ 对应的值替换，满足某个要求（好像是逆序对数不大于原数列）的情况下字典序最大。

首先可以发现，原数列是满足要求的，所以我们先把排列 $p$ 设置成 $p_i=i$，这样就一定满足要求。

然后我们看样例解释。样例 1 样例 2 都是不变。样例 3 是反过来，样例 4 是后面两个数反过来。我们自然而然想到样例 1，2 是反转数列的长度为 0。答案为把一开始的排列 $p$ 的后面几个数反转。设这个数为 $f(n,k)$。

根据样例，我们得到以下信息：

$f(1,1)=0,f(2,2)=0,f(3,2)=2,f(4,3)=2$

可以猜测到 $f(n,k)=2k-n$。

然后我们把后 $2k-n$ 个数反转，就过了。

---

## 作者：hgzxczw (赞：2)

# CF1473C题解

可以算出原序列有 $\frac{(n-k)\times (n-k+1)}{2}$ 个逆序对。

然后，由于 $|p|=k$，所以 $b[i]=p[a[i]]=p[i]$，只需 $p$ 的字典序最大，~~感性分析~~熟知 Cantor Expansion（康托展开）， $p$ 的字典序最大则需要它的逆序对数最大，即 $\frac{(n-k)\times (n-k+1)}{2}$。接着逆康托展开——$O(Tn\log n)$，绝对超时。

事实上，再算原序列的逆序对数时，我们会发现后面的数的贡献呈等差数列的形式，所以得出了上面那么美观的式子，那么我们可以猜想 $p$ 后面的数的贡献也呈等差数列的形式，具体地，$p={k,k-1,…,k-t,1,2,…,k-t-1}$，计算得到逆序对数为 $\frac{(k-t)\times (k-t+1)}{2}$，令 $k-t=n-k\Rightarrow t=2\times k-n$，这题就结束了。

~~~cpp
#include<cstdio>
int main() {
	int T; scanf("%d",&T);
	while(T--) {
		int a,b;
		scanf("%d%d",&a,&b);
		for(int i=1;i<2*b-a;++i) printf("%d ",i);
		int n=b;
		for(int i=2*b-a;i<=b;++i) printf("%d ",n--);
		puts("");
	}
	return 0;
}
~~~

[AC](https://codeforces.com/contest/1473/submission/247577175)

---


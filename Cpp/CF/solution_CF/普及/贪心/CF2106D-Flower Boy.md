# Flower Boy

## 题目描述

花之少年有一个由 $n$ 朵花组成的花园，这些花可以表示为一个整数序列 $a_1, a_2, \dots, a_n$，其中 $a_i$ 表示从左数第 $i$ 朵花的美丽值。

伊戈尔想要收集恰好 $m$ 朵花。为此，他将从左到右遍历花园，并决定是否收集当前位置的花。他收集的第 $i$ 朵花的美丽值必须至少为 $b_i$。

伊戈尔发现，有时可能无法收集满足美丽值要求的 $m$ 朵花。因此，在开始收集之前，他可以选择任意一个整数 $k$，使用魔法棒培育一朵美丽值为 $k$ 的新花，并将其放置在花园中的任意位置（两朵花之间、第一朵花之前或最后一朵花之后）。由于魔法能力有限，他最多只能执行一次这个操作。

请输出伊戈尔执行上述操作时需要选择的最小整数 $k$，以确保他能收集到 $m$ 朵花。如果不需要操作就能收集 $m$ 朵花，则输出 $0$。如果即使执行操作也无法收集 $m$ 朵花，则输出 $-1$。

## 说明/提示

在第一个测试用例中，假设伊戈尔培育了一朵美丽值为 $6$ 的花，并将其放置在第三朵和第四朵花之间。此时花园变为 $[3, 5, 2, 6, 3, 3, 5, 8, 1, 2]$。然后，他可以选择第二、第四、第六、第七和第八朵花，其美丽值分别为 $[5, 6, 3, 5, 8]$。

在第三个测试用例中，他可以培育一朵美丽值为 $7$ 的花，并将其放在第一朵花之前。此时花园变为 $[7, 4, 3, 5, 4, 3]$。现在，他可以选择第一、第二和第四朵花。

在第四个测试用例中，伊戈尔不需要执行操作，因此答案为 $0$。

在第六个测试用例中，无论伊戈尔如何操作，都无法收集到 $3$ 朵满足美丽值要求的花，因此答案为 $-1$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
7
9 5
3 5 2 3 3 5 8 1 2
4 6 2 4 6
6 3
1 2 6 8 2 1
5 4 3
5 3
4 3 5 4 3
7 4 5
6 3
8 4 2 1 2 5
6 1 4
5 5
1 2 3 4 5
5 4 3 2 1
6 3
1 2 3 4 5 6
9 8 7
5 5
7 7 6 7 7
7 7 7 7 7```

### 输出

```
6
3
7
0
-1
-1
7```

# 题解

## 作者：Amiyawasdonkey (赞：0)

# 题目翻译

[题目传送门（vjudge）](https://vjudge.net/problem/CodeForces-2106D#author=DeepSeek_zh)

给定一个长度为 $n$ 的数组 $a$ 和一个长度为 $m$ 的数组 $b$。

要在 $a$ 中**从左到右**选取 $m$ 个数按**从左到右**的顺序组成一个新的数列，使得选出来的数大于等于 $b$ 数组中对应位置上的数。有可能不够选，因此可以将一个任意大小的数 $k$ 插入到 $a$ 数组中的任意位置（包括最前面和最后面），插入操作只能执行一次。

求 $k$ 是多少。如果可以不用插入，则输出 $0$。如果插入了也无法选出 $m$ 个数，则输出 $-1$。

# 思路

因为是要**从左到右**选取数字，所以我们可以贪心地选取数字，即从左往右遍历，只要当前数字大于等于 $b$ 数组上对应位置的数字，就选取，维护一个数组 $pre$ 来存储在每个位置能最多选取多少数字。然后枚举每一个空隙，看能否插入数字，插入的是什么数字，从而得到答案。

但是仅仅有**从左到右**得到的 $pre$ 是不足以得到每个空隙的情况的，因此我们考虑**从右到左**进行一次贪心的选取，维护一个数组 $erp$ 来存储每个位置上最多能选取多少个数。这样我们就得到了每个空隙的**前缀**和**后缀**，可以方便地得到每个空隙的情况。

因此，只要满足：

$pre_i+erp_{i+1}=m-1$

就说明 $i$ 和 $i+1$ 这个空隙里差一个数。而 $k$ 的值为 $b_{pre_i+1}$。遍历找到最小值就是答案。

# Code：


```cpp
#include<bits/stdc++.h>
#define Iseri namespace
#define Nina std
#define Kawaragi int
#define Momoka main
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define ll long long
#define ull unsigned long long
#define endl "\n"
const int maxn=200005;

using Iseri Nina;

inline ll read(){//快读
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

//===========================================================

ll t,n,m,pre[maxn],erp[maxn],a[maxn],b[maxn],cnt;

Kawaragi Momoka(){
	t=read();
	while(t--){
		n=read(),m=read();
		for(ll i=1;i<=n;i++)a[i]=read();
		for(ll i=1;i<=m;i++)b[i]=read();

		//多测不清空，爆零两行泪TAT
		memset(pre,0,sizeof(pre));
		memset(erp,0,sizeof(erp));

		cnt=0;
		for(ll i=1;i<=n;i++){//求“前缀”
			if(a[i]>=b[cnt+1]&&cnt<m)cnt++;
			pre[i]=cnt;
		}
		cnt=0;
		for(ll i=n;i>=1;i--){//求“后缀”
			if(a[i]>=b[m-cnt]&&cnt<m)cnt++;
			erp[i]=cnt;
		}

		if(pre[n]>=m)printf("0\n");//如果最后一位能够最多选到m个数，那就不用插入啦！直接输出0
		else{
			ll ans=1145141919;//设极大值
			for(ll i=0;i<=n;i++){
				if(pre[i]+erp[i+1]==m-1)ans=min(ans,b[pre[i]+1]);
			}

			if(ans==1145141919)printf("-1\n");//如果遍历一遍都找不到，那就没办法了TAT，输出-1
			else printf("%lld\n",ans);
		}
	}
	return 0;
}
```

灵感来源：[vjudge](https://vjudge.net/solution/60477664)

提交记录：[这里（vjudge）](https://vjudge.net/solution/60597339)

---


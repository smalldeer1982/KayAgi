# 最大子区间和

## 题目描述

给你一个长为 $n$ 的序列 $a=(a_1,a_2,\cdots,a_n)$，$a$ 的一部分丢失了。你的任务是填补丢失的部分使得 $a$ 的最大子区间和为 $k$，或报告无解。

给你一个 01 串 $s$ 和 $a$：
- 如果 $a_i$ 没有被丢失，$s_i=1$，此时 $a_i$ 记录了它的真实值。
- 如果 $a_i$ 被丢失，$s_i=0$，此时给到你的序列 $a$ 中 $a_i=0$。

输入的 $a$ 满足 $\vert a_i\vert\le 10^6$，你填充后的 $a$ 需要满足 $\vert a_i\vert \le 10^{18}$。可以被证明如果存在解，那么一定存在一个满足 $\vert a_i\vert \le 10^{18}$ 的解。

一个长为 $n$ 的数列 $a$ 的最大子区间和是 $\max\limits_{1\le i\le j\le n}\sum\limits_{k=i}^j a_k$。

## 说明/提示

第一组数据中，向唯一丢失的 $a_1$ 填充 $4$ 得到 $a=(4,0,1)$，它的最大子区间和为 $5$。

第二组数据中，向唯一丢失的 $a_3$ 填充 $5$ 得到 $a=(4,-3,5,-2,1)$，它的最大子区间和为 $6$。

第三组数据中 $a_1$ 和 $a_2$ 待填充，向它们填充 $2$ 得到 $a=(2,2,-4,-5)$，它的最大子区间和为 $4$。$a=(0,4,-4,-5)$ 也是一种解法。

对于第四组数据，没有合法的填充 $a$ 的方式。例如 $a=(1,2,0,5,-1,9)$，它的最大子区间和为 $16$ 而非 $12$。

By chenxi2009

## 样例 #1

### 输入

```
10
3 5
011
0 0 1
5 6
11011
4 -3 0 -2 1
4 4
0011
0 0 -4 -5
6 12
110111
1 2 0 5 -1 9
5 19
00000
0 0 0 0 0
5 19
11001
-8 6 0 0 -5
5 10
10101
10 0 10 0 10
1 1
1
0
3 5
111
3 -1 3
4 5
1011
-2 0 1 -5```

### 输出

```
Yes
4 0 1
Yes
4 -3 5 -2 1
Yes
2 2 -4 -5
No
Yes
5 1 9 2 2
Yes
-8 6 6 7 -5
Yes
10 -20 10 -20 10
No
Yes
3 -1 3
Yes
-2 4 1 -5```

# 题解

## 作者：AstaVenti_ (赞：1)

首先很容易判断出无解的情况：如果把所有的 $0$ 全部填成 $-\inf$ 得到的最大子段和小于 $k$ ，或者在所有数全部已知的情况下得到的最大子段和不等于 $k$ 则无解。

除此之外我们都能构造出一组解。

对于一个未知的数，为了让最终得到的最大子段和包含这个数，可以统计这个数的前缀最大和与后缀最大和，记这两个数总和为 $m$，则这个数就需要是 $k-m$。

这样的数我们只需要找到一个就可以了，除此之外把所有未知的数填成 $-\inf$ 即可。

注意由于题目中的 $n\leq 2\times 10^5$，因此 $\inf$ 需要小于 $\frac{9\times 10^{18}}{2\times 10^5}=4.5\times10^{13}$。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,n,k,inf=1000000000000;
string s;
ll zdzdh(vector<ll>p){
	vector<ll>f(n+1);
	ll res=LLONG_MIN;
	for(ll i=1;i<=n;i++){
        f[i]=max(f[i-1]+p[i],p[i]);
        res=max(res,f[i]);
    }
    return res;
}

ll zdqz(vector<ll>p,ll pos){
	ll maxh=LLONG_MIN,h=0;
	for(ll i=pos-1;i>=1;i--){
		h+=p[i];
		maxh=max(maxh,h);
	}
	return max(0ll,maxh);
}
ll zdhz(vector<ll>p,ll pos){
	ll maxg=LLONG_MIN,g=0;
	for(ll i=pos+1;i<=n;i++){
		g+=p[i];
		maxg=max(maxg,g);
	}
	return max(0ll,maxg);
}
int main(){
	cin>>T;
	while(T--){
		cin>>n>>k>>s;
		s=' '+s; 
		vector<ll>a(n+1),b(n+1);
		for(ll i=1;i<=n;i++){
			cin>>a[i];
			if(s[i]=='0'){
				b[i]=-inf;
			}else{
				b[i]=a[i];
			}
		}
		if(zdzdh(b)>k||(count(s.begin()+1,s.end(),'0'))==0&&zdzdh(b)!=k){
			cout<<"No\n";
		}else{
			cout<<"Yes\n";
			ll lst=-1;
			for(ll i=1;i<=n;i++){
				b[i]=a[i];
				if(s[i]=='0'){
					lst=max(lst,i);
				}
			}
//			cout<<"lst:"<<lst<<endl;
			if(lst==-1){
				for(ll i=1;i<=n;i++){
					cout<<a[i]<<" ";
				}
			}else{
				ll qq=-1,hh=-1;
				for(ll i=1;i<=n;i++){
					if(i!=lst&&s[i]=='0'){
						b[i]=-inf;
					}else if(i==lst){
						qq=zdqz(b,i),hh=zdhz(b,i);
						b[i]=k-qq-hh;
					}
					cout<<b[i]<<" ";
				}
//				cout<<endl;
//				cout<<"前："<<qq<<" 后："<<hh<<endl;
			}
			cout<<endl;
		}
	}
}

```

---

## 作者：Chen_Johnny (赞：0)

# CF2107C Maximum Subarray Sum
## 思路
我们假设至少存在一个 $s_i=0$（未填充位置）。另一种情况是所有 $s_i=1$，此时我们可以很容易地检查最大子数组和是否为 $k$。


首先我们来确定答案不可能的情况。将所有满足 $s_i=0$
 的 $a_i$ 替换为 $-\infin$。如果此时最大子数组和仍然大于 $k$，那么答案显然是不可能的。

 
在其他所有情况下，答案实际上都是可能的！除了一个位置外，所有 $s_i=0$ 的位置都将保持为 $-\infin$。任意选择一个这样的位置，我们称之为 $pos$（这里选择最后一个算了，省着有选择困难症）。


设 $b$ 为子数组 $[a_{pos + 1},a_{pos+2},\cdots,a_n]$ 中的最大前缀和， 
$c$ 为子数组 $[a_{1},a_{p2},\cdots,a_{pos-1}]$ 中的最大后缀和。这里我们也考虑空的前缀和后缀。

假设 $a_{pos}$ 的值为 $x$。那么，包含 $pos$ 的最大子数组和将是 $x+b+c$。并且不包含 $pos$ 的最大子数组和将 $≤k$，因为这相当于用 $−\infin$ 替换 $a_{pos}$。

因此，我们可以简单地将 $x$ 替换为 $k−b−c$，这样就满足条件了。

 
在这两种解法中，都要注意避免溢出。一种简单的方法是令 $\infin=10^{13}$，这对我们的需求来说已经足够了（防止溢出，但仍大于 $k+\sum{a_i}$）。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 10;
int main () {
    ll T; cin >> T;
    while (T --) {
        ll n, k, a [N]; string s;
        cin >> n >> k >> s;
        for (ll i = 0; i < n; i ++)
            cin >> a [i];
        ll pos = -1;
        for (ll i = 0; i < n; i ++)
            if (s [i] == '0') {
                pos = i;
                a [i] = -1e13;
            }
        ll maxn = 0, curr = 0;
        for (ll i = 0; i < n; i ++){
            curr = max (curr + a [i], a [i]);
            maxn = max (maxn, curr);
        }
        if (maxn > k || (maxn != k && pos == -1)) {
            cout << "No\n";
            continue;
        }
        if (pos != -1) {
            maxn = 0, curr = 0;
            for (ll i = pos + 1; i < n; i ++) {
                curr += a[i];
                maxn = max (maxn, curr);
            }
            ll L = maxn;
            maxn = 0, curr = 0;
            for (ll i = pos - 1; i >= 0; i --) {
                curr += a [i];
                maxn = max (maxn, curr);
            }
            ll R = maxn;
            a [pos] = k - L - R;
        }
        cout << "Yes\n";
        for (ll i = 0; i < n; i ++)
            cout << a [i] << " ";
        cout << endl;
    }
    return 0;
}

```

---

## 作者：ZettaByte (赞：0)

[题目传送门](https://codeforces.com/contest/2107/problem/C)

### 解题思路

容易发现如果可行，那么只需改一个数就可以达到效果。

又发现最大子段和随要改变的数的增加而增加，即单调不减，因此想到二分改变的数。

时间复杂度 $\Omega(n\log 2\times 10^{18})$。

需要注意一些细节，例如在一开始把满足 `s[i] == '0'` 的 `a[i]` 改为负无穷，在所有 `s[i]` 都等于 `'1'` 时进行特判。

### AC Code：

给出部分代码。

```cpp
//最大子段和
ll calc() {
	for (ll i = 1; i <= n; i++) dp[i] = max(dp[i-1] + a[i], a[i]);
	ll mx = 0;
	for (ll i = 1; i <= n; i++) mx = max(mx, dp[i]);
	return mx;
}
```

```cpp
	//二分
	ll l = -(ll)1e18, r = (ll)1e18;
	while (l < r)
	{
		ll mid = (l + r) >> 1; a[id] = mid; //id为随便一个满足s[i]为'0'的i，二分a[id]的值
		if (calc() < k) l = mid + 1; //calc()：计算a数组的最大子段和
		else r = mid;
	} a[id] = l;
	if (calc() != k) return puts("No"), void();
	puts("Yes"), a[id] = l;
	for (ll i = 1; i <= n; i++) printf("%lld ", a[i]);
	printf("\n"); //输出
```

---


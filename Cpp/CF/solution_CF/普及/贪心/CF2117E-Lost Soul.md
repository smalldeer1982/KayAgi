# Lost Soul

## 题目描述

给定两个长度均为 $n$ 的数组 $a$ 和 $b$。

你可以进行任意次如下操作：

- 选择一个下标 $i$（$1 \le i \le n-1$），然后赋值 $a_i:=b_{i+1}$，或者 $b_i:=a_{i+1}$。

在进行这些操作之前，你可以选择一个下标 $i$（$1 \le i \le n$），然后将 $a_i$ 和 $b_i$ 从两个数组中删去。这个删除操作至多可以进行一次。

我们称两个长度为 $m$ 的数组 $c$ 和 $d$ 之间的匹配数量为满足 $c_j=d_j$ 的下标 $j$（$1 \le j \le m$）的数量。

你的任务是计算通过上述操作可以得到的 $a$ 和 $b$ 的最大匹配数量。

## 说明/提示

对于第一个测试用例，我们可以进行如下操作：

- 不进行删除操作。
- 选择下标 $3$，然后赋值 $a_3:=b_4$。数组变为 $a=[1,3,2,4]$，$b=[4,3,2,2]$。
- 选择下标 $1$，然后赋值 $a_1:=b_2$。数组变为 $a=[3,3,2,4]$，$b=[4,3,2,2]$。
- 选择下标 $1$，然后赋值 $a_2:=b_1$。数组变为 $a=[3,3,2,4]$，$b=[3,3,2,2]$。

匹配数量为 $3$。可以证明这是我们可以得到匹配数量的最大值。

对于第二个测试用例，我们可以进行如下操作：

- 删去下标 $5$ 对应的元素。数组变为 $a=[2,1,5,3,4]$，$b=[3,2,4,5,6]$。
- 选择下标 $4$，然后赋值 $b_4:=a_5$。数组变为 $a=[2,1,5,3,4]$，$b=[3,2,4,4,6]$。
- 选择下标 $3$，然后赋值 $a_3:=b_4$。数组变为 $a=[2,1,4,3,4]$，$b=[3,2,4,4,6]$。
- 选择下标 $2$，然后赋值 $a_2:=b_3$。数组变为 $a=[2,4,4,3,4]$，$b=[3,2,4,4,6]$。
- 选择下标 $1$，然后赋值 $b_1:=a_2$。数组变为 $a=[2,4,4,3,4]$，$b=[4,2,4,4,6]$。
- 选择下标 $2$，然后赋值 $b_2:=a_3$。数组变为 $a=[2,4,4,3,4]$，$b=[4,4,4,4,6]$。
- 选择下标 $1$，然后赋值 $a_1:=b_2$。数组变为 $a=[4,4,4,3,4]$，$b=[4,4,4,4,6]$。

对于第三个测试用例，可以证明我们无法得到任何匹配，因此答案为 $0$。

## 样例 #1

### 输入

```
10
4
1 3 1 4
4 3 2 2
6
2 1 5 3 6 4
3 2 4 5 1 6
2
1 2
2 1
6
2 5 1 3 6 4
3 5 2 3 4 6
4
1 3 2 2
2 1 3 4
8
3 1 4 6 2 2 5 7
4 2 3 7 1 1 6 5
10
5 1 2 7 3 9 4 10 6 8
6 2 3 6 4 10 5 1 7 9
5
3 2 4 1 5
2 4 5 1 3
7
2 2 6 4 1 3 5
3 1 6 5 1 4 2
5
4 1 3 2 5
3 2 1 5 4```

### 输出

```
3
3
0
4
3
5
6
4
5
2```

# 题解

## 作者：zhujiajun2013 (赞：3)

### 题目简述
这道题给定两个长度为 $n$ 的数组 $a$ 和 $b$，我们可以进行两种操作：

1. **赋值操作**：取任意一个下标 $i$，把 $a_i$ 赋值为 $b_{i+1}$，或者把 $b_i$ 赋值为 $a_{i+1}$，而且这个操作可以执行任意多次。

2. **删除操作**：在进行赋值操作之前，可以选择删除 $a_i$ 与 $b_i$（最多删除一次）。

我们要经过这些操作后，寻找最多有多少个 $i$ 可以满足 $a_i=b_i$。
### 思路
首先特判，若 $a_n=b_n$，那么整个数组全部相等，直接输出 $n$。

然后逆向遍历检查是否存在一下情况：
- $a_i$ 与 $b_i$ 已经相等。

- $a_i$ 与 $a_{i+1}$ 相等。

- $b_i$ 与 $b_{i+1}$ 相等。

- $a_i$ 或 $b_i$ 已经被标记为访问过（可用 $vis$ 数组记录访问过的元素）。

若存在，则找到这个答案；若不存在，则在标记后继续寻找。
### AC code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int a[N],b[N],ans;
bool vis[N];
int t;
signed main()
{
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i],vis[i]=0;
		if(a[n]==b[n]){cout<<n<<"\n";continue;}
        ans=0;
		for(int i=n-1;i>=1;i--){
			if(a[i]==b[i]||a[i]==a[i+1]||b[i]==b[i+1]||vis[a[i]]||vis[b[i]]){
				ans=i;
				break;
			}
			vis[a[i+1]]=vis[b[i+1]]=1;
		}
		cout<<ans<<"\n";	
	}
	return 0;
}
```

---

## 作者：Moonlight_dreams (赞：1)

~~应该是第一篇题解吧。。。~~

### 代码思路

- 预处理数组 $vis$

  $vis$ 数组用于记录从当前位置 $i$ 到数组末尾之间出现过的所有值，通过从后向前遍历，逐步更新 $vis$ 数组，记录后续出现的值。

- 关键判断条件：

  判断当前位置 $i$ 是否可以通过操作使其匹配，或者是否可以通过后续位置的值传递到当前位置。

- 贪心策略：

  从后往前遍历，找到第一个满足条件的位置 $i$，该位置 $i$ 及其后面的所有位置都可以通过操作使其匹配。

### AC 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int a[N] , b[N];
bool vis[N];
void sloved()
{
	memset(vis , 0 , sizeof vis);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> b[i];
	}
	if (a[n] == b[n])
	{
		cout << n << "\n";
		return ;
	}
	int daan = 0;
	for (int i = n - 1; i >= 1; i--)
	{
		if (a[i] == b[i] || a[i] == a[i + 1] || b[i] == b[i + 1] || vis[a[i]] == 1 || vis[b[i]] == 1)
		{
			daan = i;
			break;
		}
		vis[a[i + 1]] = 1;
		vis[b[i + 1]] = 1;
	}
	cout << daan << "\n";
	return ;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin >> t;
	while (t--)
	{
		sloved();
	}
	return 0;
}
```

---

## 作者：songtaoran (赞：0)

### 前言
目前的题解都是只说结论，我来证明一下。  
首先，观察题面：  
**可以进行一次删除操作。**  
**选取 $i$，然后使得 $a_i = b_{i + 1}$ 或 $b_i = a_{i + 1}$。**  
### 结论
当 $a_n = b_n$ 时，答案为 $n$。  
否则，答案为最大的下标 $i$ 满足 $a_i = b_i$ 或 $a_i = a_{i + 1}$ 或 $b_i = b_{i + 1}$ 或 $a_i(b_i)$ 在 $i + 1$ （不包括 $i + 1$）后出现过。
### 证明
情况 $1$：有一个下标 $i$ 使得 $a_i = b_i$。  
此时我们可以交替赋值：  
$a_{i - 1} = b_i,b_{i - 1} = a_i,a_{i - 2} = b_{i - 1},b_{i - 2} = a_{i - 1}\dots$，这样答案就是 $i$ 了。  

情况 $2$：有一个下标 $i$ 使得 $a_i = a_{i + 1}(b_i = b_{i + 1})$。  
赋值一次就变成情况 $1$ 了。  

情况 $3$：$a_i(b_i)$ 在 $i + 1$ 的后面（不包括 $i + 1$）出现过。  
分讨。假设出现过的这个数的下标为 $j$。  
1. $a_i = a_j(b_i = b_j)$，$j - i + 1$ 为偶数。手推一下，发现此时不断赋值最终会变成情况 $1$。
2. $a_i = a_j(b_i = b_j)$，$j - i + 1$ 为奇数。怎么办呢？别忘了，还有一个条件没用：**可以进行一次删除操作。** 于是我们进行一次删除操作，$j - i + 1$ 就变成偶数了。
3. $a_i = b_j(b_i = a_j)$，$j - i + 1$ 为奇数。仍然是不断赋值。
4. $a_i = b_j(b_i = a_j)$，$j - i + 1$ 为偶数。**可以进行一次删除操作。** 仍然是删除一次，$j - i + 1$ 就变成奇数了。

这时有人就要问了：为什么是 $i + 1$ 的后面而不是 $i$ 的后面呢？  
如果是 $i$ 的后面（不包括 $i$），那么 1. 和 2. 在 $j = i + 1$ 情况下就是情况 $2$，3. 在 $j = i + 1$ 情况下不满足 $j - i + 1$ 为奇数，4. 在 $j = i + 1$ 情况下无解，所以还是相当于在 $i + 1$ 的后面，还得做特判，过于麻烦。  
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define endl "\n"
ll T, n, a[200010], b[200010];
bool vis[200010]; 
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	cin >> T;
	while(T--){
		memset(vis, 0, sizeof vis);
		cin >> n;
		for(ll i = 1; i <= n; i++) cin >> a[i];
		for(ll i = 1; i <= n; i++) cin >> b[i];
		if(a[n] == b[n]){
			cout << n << endl; continue;
		}
		ll mx = 0;
		for(ll i = n - 1; i > 0; i--){
			if(a[i] == b[i] || a[i + 1] == a[i] || b[i + 1] == b[i] || vis[a[i]] || vis[b[i]]){
				mx = i; break;
			}
			vis[a[i + 1]] = vis[b[i + 1]] = 1;
		}
		cout << mx << endl;
	}
	return 0;
}
```
[提交记录 $326213467$](https://codeforces.com/problemset/submission/2117/326213467)  
码字不易，求赞 qwq。

---


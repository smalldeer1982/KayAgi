# Guess two numbers

## 题目描述

这是一个交互题。

Vasya 和 Vitya 在玩一个游戏。Vasya 想好了两个整数 $a$ 和 $b$，它们都在 $1$ 到 $n$ 之间，Vitya 需要猜出它们。每一轮，Vitya 会告诉 Vasya 两个数 $x$ 和 $y$，它们也都在 $1$ 到 $n$ 之间。如果 $x=a$ 且 $y=b$，那么 Vitya 获胜。否则，Vasya 必须说出以下三句话中的一句：

1. $x$ 小于 $a$；
2. $y$ 小于 $b$；
3. $x$ 大于 $a$ 或 $y$ 大于 $b$。

Vasya 不能说谎，但如果有多句话都成立，他可以任选其中一句。例如，如果 Vasya 想的数是 $2$ 和 $4$，那么对于询问 $(3,4)$，他会回答第 $3$ 句；对于询问 $(1,5)$，他可以回答第 $1$ 句或第 $3$ 句。

请帮助 Vitya 在不超过 $600$ 轮内获胜。

## 说明/提示

我们来分析样例测试。选中的数字是 $2$ 和 $4$。交互器给出了两条指令。

对于询问 $(4, 3)$，可以返回 $2$ 或 $3$。在两条指令中，第二条被选中，所以交互器返回 $a^{23}_2=3$。

对于询问 $(3, 4)$，只能返回 $3$。

对于询问 $(3, 3)$，可以返回 $2$ 或 $3$。在两条指令中，第一条被选中（因为在相等时选择编号最小的），所以交互器返回 $a^{23}_1=2$。

对于询问 $(1, 5)$，可以返回 $1$ 或 $3$。在两条指令中，第一条被选中，所以交互器返回 $a^{13}_1=1$。

在第五次询问 $(2, 4)$ 时，数字被正确猜出，玩家获胜。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5
3
3
2
1
0```

### 输出

```
4 3
3 4
3 3
1 5
2 4```

# 题解

## 作者：dztlb (赞：3)

直接看交互条件并不能看出什么，但如果我们将 $(a,b)$ 看作平面直角坐标系中一点。

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/qa8xz4se.png)

图中圆点为点 $(a,b)$。经此点将整个矩形分为四部分。在每个部分中询问会得到的结果已经标出。

这时得到 $1,2,3$ 的区域有了明显的区分。

![](https://cdn.luogu.com.cn/upload/image_hosting/6tufuqgv.png)

每次询问得 $1$ 可将红线左方排除，得 $2$ 可将蓝线下方排除，得 $3$ 可将绿框矩形排除。

基于此我们可以得到两个做法。

法一（讨论复杂但询问次数优秀，完全利用题目性质）

如图在若干次操作后要么仍然得到一个矩形，要么得到一个 $L$ 形。

我们期望在每次操作排除尽量多的面积。

矩形取中心，每次至少将横纵坐标之一减半（尽管总面积只是至少减为 $\frac{1}{4}$）。可能成为 $L$ 形。

$L$ 形取小矩形中心处，至少将 $L$ 一端宽度减半。

![](https://cdn.luogu.com.cn/upload/image_hosting/w5gcnagr.png)

在 $L$ 形两端宽度都减为 $1$ 后，可以通过一次询问确定 $a,b$ 之一。

矩形在长或宽为 $1$ 时也可确定 $a,b$ 之一。

一旦确定一个，就变成了普通的二分问题。

每次至少减半一端加最终的二分，以及某些基于实现的特判，询问次数: $2*64+64+x=192+x \leq 200$。

询问次数与 $CF$ 的解法二几乎等同，这题询问次数确实可以卡的更死。

法二（应该是出题人想要的简洁做法，实现简单但询问次数多）

我们考虑不使用 $3$ 的排除，这样保证我们每次剩下的有效区域始终是矩形。

我们考虑将红蓝两线的交点向终点逼近，直接一步步增加 $x,y$ 询问次数是 $a+b$ 的。

显然能否跨步是有一个明显的边界 $(a,b)$ 的，可以使用一个类似于倍增的跨步方法，同时跨 $x,y$ 每次哪边可行就将步长加倍。

如果得到 $3$ 就回退步长。这样总步数与 $\log n$ 同阶。

具体而言，询问次数最劣 $8*64 \leq 600$。

```cpp
#define ll long long
ll n,a,b,x,y,id;
inline ll read(){
    ll x=0,f=1;char s;
    while ((s = getchar()) < '0' || s > '9') if (s == '-') f = -1;
    while (s >= '0' && s <= '9') x = (x << 3) + (x << 1) + (s ^ '0'), s = getchar();
    return x*f;
}
int main(){
	n=read();
	x=y=1;
	while (1){
		cout<<a+x<<" "<<b+y<<endl;
		id=read();
		if (id==0)return 0;
		if (id==1)a+=x,x=min(x*2,n-a);
		if (id==2)b+=y,y=min(y*2,n-b);
		if (id==3)x=max(1ll,x>>1),y=max(1ll,y>>1);
	}
}

```


---

## 作者：ForgetOIDuck (赞：0)

[疑似二倍经验：CF1008E，甚至题面都一样](https://www.luogu.com.cn/problem/CF1008E)

### 思路
一眼看到二元组和一些奇怪的大小限制，学函数学魔怔的我直接将二元组 $(a,b)$ 转成坐标弄到平面直角坐标系上。

这个点在一个左下角 $(0,0)$，右上角 $(n,n)$ 的矩形里，这个点将矩形分为 $4$ 个部分。

![](https://s11.ax1x.com/2024/02/03/pFlk1dP.png)

考虑在这个矩形内确定 $(a,b)$ 的位置。

若询问一个点 $(x,y)$，对于每个返回能够排除的部分如下图所示：

![](https://s11.ax1x.com/2024/02/03/pFlk0Zq.png)

可以看到返回 `1` 和 `2` 都是排除一部分 $x < a$ 或 $y < b$ 的区间。意思是：既然 $x<a$ 或 $y<b$ 都不合法，那根据不等式的传递性可知，小于 $x$ 或 $y$ 的更不可能合法，所以把这些范围都排除了。

它们的形状是一个矩形；原先大的范围减去这个矩形也能得到一个完整的矩形，这样也比较好处理。

对于返回 `3` 也同理，这其实是两个部分 $x > a$ 和 $y > b$ 的交集，因为原题返回 `3` 的条件是 $x > a$ 或 $y > b$，我们不能确定到底是 $x$ 还是 $y$ 不合法，所以要把同时满足两个条件的范围给排除掉。

它的形状也是一个小矩形，但是原先大的范围减去这个矩形是一个`L`型的奇怪东西，我们不太好表示出来。

**对此，我们大胆地舍弃返回 `3` 能够排除的范围！** 现在返回 `3` 的唯一作用就是告诉我们，$x$ 和 $y$ 太大了。

所以我们只需要考虑将返回 `1` 和返回 `2` 所表示的矩形靠近 $(a,b)$ 的那两边不断靠近 $(a,b)$ 。

综上我们采用一种倍增思想来解决此题。

我们用 $p,q$ 表示已经排除了 $x<p$ 和 $y<q$ 的范围，$\Delta x$ 表示尝试的 $x$ 在 $p$ 基础上的增量（即 $x-p$），$\Delta y$ 表示尝试的 $y$ 在 $q$ 基础上的增量（即 $y-q$）。

对于每次询问 $(x,y)$：

若返回 `1` 说明 $x$ 不够大，将原先 $x<p+\Delta x$ 的范围排除（$p\leftarrow p+\Delta x$）同时将 $\Delta x$ 增大至 $2\Delta x$，即 $\Delta x\leftarrow2\Delta x$（注意不能越过 $n$）。

同理，若返回 `2` 说明 $y$ 不够大，将原先 $y<q+\Delta y$ 的范围排除（$q\leftarrow q+\Delta y$）同时将 $\Delta y$ 增大至 $2\Delta y$，即 $\Delta y\leftarrow2\Delta y$（注意不能越过 $n$）。

若返回 `3` 说明 $\Delta x$ 和 $\Delta y$ 都可能有点太大了，不改动 $p,q$，将 $\Delta x$ 和 $\Delta y$ 分别缩小至 $\dfrac{\Delta x}{2}$ 和 $\dfrac{\Delta y}{2}$，即 $\Delta x\leftarrow\dfrac{\Delta x}{2}$，$\Delta y\leftarrow\dfrac{\Delta y}{2}$。（注意不能小于 $1$）。

这么搞时间复杂度是 $O(\log n)$ 级别的，再加一些奇怪的常数（不会算。。 

实测能过。

### AC 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, p, q, dx, dy, t;
int main() {
	cin >> n;
	dx = dy = 1;
	while (114514) {
		cout << p + dx << ' ' << q + dy << endl;
		cin >> t;
		if (t == 0) return 0;
		if (t == 1) p += dx, dx = min(dx * 2, n - p);
		if (t == 2) q += dy, dy = min(dy * 2, n - q);
		if (t == 3) dx = max(1ll, dx / 2), dy = max(1ll, dy / 2);
	}
}
```

---


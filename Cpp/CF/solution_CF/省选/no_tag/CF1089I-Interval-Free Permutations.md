# Interval-Free Permutations

## 题目描述

考虑一个由 $1$ 到 $n$ 的整数构成的排列 $p_1, p_2, \dots, p_n$。我们称排列中的一个子段 $p_l, p_{l+1}, \dots, p_{r-1}, p_r$ 为一个区间，当且仅当它是某一组连续整数的重排。例如，排列 $(6,7,1,8,5,3,2,4)$ 包含区间 $(6,7)$、$(5,3,2,4)$、$(3,2)$ 等。

每个排列都包含一些平凡区间——即整个排列本身和每一个单独的元素。我们称一个排列为无区间排列（interval-free），如果它没有非平凡区间。换句话说，无区间排列不包含长度在 $2$ 到 $n-1$ 之间的区间。

你的任务是，计算长度为 $n$ 的无区间排列的个数，并对质数 $p$ 取模。

## 说明/提示

对于 $n=1$，唯一的排列是无区间排列。对于 $n=4$，有两个无区间排列，分别为 $(2,4,1,3)$ 和 $(3,1,4,2)$。对于 $n=5$，有 $(2,4,1,5,3)$、$(2,5,3,1,4)$、$(3,1,5,2,4)$、$(3,5,1,4,2)$、$(4,1,3,5,2)$ 和 $(4,2,5,1,3)$ 六种。我们不会列出 $n=9$ 时的全部 $28146$ 个无区间排列，但例如 $(4,7,9,5,1,8,2,6,3)$、$(2,4,6,1,9,7,3,8,5)$、$(3,6,9,4,1,5,8,2,7)$ 和 $(8,4,9,1,3,6,2,7,5)$ 都是无区间排列。

当 $n=20$ 时，无区间排列的精确数量为 $264111424634864638$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 998244353
1
4
5
9
```

### 输出

```
1
2
6
28146
```

## 样例 #2

### 输入

```
1 437122297
20
```

### 输出

```
67777575
```

# 题解

## 作者：Social_Zhao (赞：5)

### 1 题意

求长度为 $n$ 的、且不包含一个连续子段的排列数量。

### 2 题解

考虑减法原理，用全排列减去包含连续子段的排列数量。

这里我们借用析合树的思路，将问题转化为计算根的儿子不足 $n$ 个的析合树数量。设长度为 $n$ 的、且不包含一个连续子段的排列数量是 $A_n$

---

有以下几种情况：

1. **根是合点**

   假设是单调递增的合点，那么排列中存在一个严格前缀 $P_{1\dots i}$，它是一个 $[1, i]$ 的连续段。考虑计算 $I_n$ 表示一个长度为 $n$ 的排列，它的任何一个前缀都不是 $[1, i]$ 的连续段。 $I_n$ 可以递推计算：
   $$
   I_n=n!-\sum_{i=1}^{n-1}I_i\times(n-i)!
   $$
   意思是用全排列减去有一个前缀是 $[1, i]$ 的连续段的数量。

   于是根是单调递增的合点的数量可以表示为：
   $$
   \sum_{i=1}^{n-1}I_i\times(n-i)!
   $$
   又因为单调递增的合点和单调递减的合点一一对应，所以根是合点的总数就是：
   $$
   2\sum_{i=1}^{n-1}I_i\times(n-i)!
   $$

2. **根是析点**

   假设这个析点有 $i$ 个儿子，那么根据析点的定义，其儿子排列的任意一个子段都不是连续段，发现这就是 $A_i$。

   现在我们需要把 $n$ 个点划分进 $i$ 个儿子里面，设 $B_{n, i}$ 为把 $n$ 个点划分到 $i$ 个儿子中的方案数，那么 $B_{n, i}$ 也是可以递推计算的：
   $$
   B_{n, i}=\sum_{j=1}^{i} B_{n-1, i-j}\times j!
   $$
   即枚举最后一个儿子放了几个点，前后方案数相乘。

   综上，根是析点的答案就是
   $$
   \sum_{i=4}^{n-1}B_{n, i}\times A_i
   $$
   至于为什么从 $4$ 开始，是因为析点不可能只有两个儿子，而长度为 $3$ 的排列总有连续段。

---

全部合在一起，答案就是：
$$
n!-2\sum_{i=1}^{n-1}I_i\times(n-i)!-\sum_{i=4}^{n-1}B_{n, i}\times A_i
$$

### 3 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int get() {
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

const int N = 405;
int P, A[N], I[N], B[N][N], fac[N], inv[N];

int qpow(int x, int y) {
	int res = 1;
	while(y) res = res * ((y & 1)? x : 1) % P, x = x * x % P, y >>= 1;
	return res;
}

void init(int n) {
	fac[0] = 1;
	for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % P;
	inv[n] = qpow(fac[n], P - 2);
	for(int i = n; i >= 1; i--) inv[i - 1] = inv[i] * i % P;
	I[1] = 1;
	for(int i = 2; i <= n; i++) {
		I[i] = fac[i];
		for(int j = 1; j < i; j++) I[i] = (I[i] - I[j] * fac[i - j] % P + P) % P;
	}
	B[0][0] = 1;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= i; j++)
			for(int k = 1; k <= i; k++)
				B[i][j] = (B[i][j] + B[i - k][j - 1] * fac[k] % P) % P;
	A[1] = 1, A[2] = 2, A[3] = 0;
	for(int i = 4; i <= n; i++) {
		A[i] = fac[i];
		int sum1 = 0, sum2 = 0;
		for(int j = 1; j < i; j++) sum1 = (sum1 + I[j] * fac[i - j] % P) % P;
		A[i] = (A[i] - sum1 * 2 % P + P) % P;
		for(int j = 4; j < i; j++) sum2 = (sum2 + B[i][j] * A[j] % P) % P;
		A[i] = (A[i] - sum2 + P) % P;
	}
}

signed main() {
	int T = get(); P = get();
	init(400);
	while(T--) printf("%d\n", A[get()]);
	return 0;
}

```





---

## 作者：tzc_wk (赞：3)

[Codeforces 题面传送门](https://codeforces.ml/contest/1089/problem/I) & [洛谷题面传送门](https://www.luogu.com.cn/problem/CF1089I)

首先题目中涉及排列的 interval，因此可以想到析合树。由于本蒟蒻太菜了以至于没有听过这种神仙黑科技，因此简单介绍一下这种数据结构：我们注意到排列的区间有一个性质：对于排列中的两段区间 $X,Y$，如果它们有交，那么必然有 $X\cap Y,X\cup Y,X\setminus(X\cap Y),Y\setminus(X\cap Y)$ 四个集合均为区间，也就是说连续段之间只有包含没有相交关系，因此它们可以表示为一棵树形结构。

我们考虑用一棵根节点为区间 $[1,n]$，叶子节点为每个长度为 $1$ 的区间的树表示这个树形结构，对于每个区间我们定义它的本原连续段为极大的、彼此之间不存在部分相交的连续段，举个例子，排列 $[5,1,4,2,3]$ 有两个本原连续段：$[5],[1,4,2,3]$——显然我们能够找到这样的连续段组成的集合。那么我们就令这个区间的儿子为这些本原连续段们，继续递归下去即可建出这棵树。由于这棵树的叶子节点恰有 $n$ 个，因此这棵树的节点数也是线性的。

考虑将这棵树的节点分分类，由于每个节点的儿子们都是一个个区间，因此我们可以将它们离散化成一个个在 $[1,\text{儿子个数}]$ 之内的数，我们称这样得到的排列为**儿子排列**，手玩几组数据即可发现对于每个点而言，它的儿子排列总共只有两种类型，否则就不满足“本原连续段”的定义了：

- 儿子排列从左到右恰好为 $1,2,3,\cdots,\text{儿子个数}$ 或者 $\text{儿子个数},\cdots,3,2,1$，我们称这样的点为**合点**
- 儿子排列中除了整个区间和长度为 $1$ 的子区间不存在任何其他连续段，我们称这样的点为**析点**

比方说排列 $[9,1,10,3,2,5,7,6,8,4]$ 建出树来如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/rqdar6wi.png)

析合树有以下性质：

- 每个析点儿子个数一定 $\ge 4$，因为任何长度为 $3$ 的排列都存在非平凡连续段
- 如果我们指定一棵树上每个节点的析合性，并满足析点儿子个数 $\ge 4$，合点儿子个数 $\ge 2$，那么一定存在某个排列对应这棵树

回到此题来，此题等价于求儿子个数为 $n$，且根为析点的排列个数 $f_n$，直接求不太容易，因此考虑正难则反，那总排列数减去不合法的排列个数，前者就是 $n!$，后者可以分情况讨论：

1. 根是析点，那么我们可以枚举根节点的儿子个数 $c\ge 4$，那么我们要将 $n$ 个节点划分成 $c$ 个区间，每个区间内的元素随便乱排，最后还要将这 $c$ 个区间排成一列满足不存在非平凡区间，很显然我们可以将这个任务分成两部分，划分儿子和确定儿子排列，后者方案数显然就是 $f_c$，前者可以设一个 $s_{i,j}$ 表示将 $i$ 个节点划分成 $j$ 段的方案数，显然有 $s_{i,j}=\sum\limits_{k<i}s_{i-k,j-1}·k!$
2. 根是合点，那么我们不妨假设根节点的儿子排列为 $1,2,3,\cdots$，对于单调递减的情况乘个 $2$ 即可，根据合点的定义必然存在某个前缀 $i$ 满足 $p[1...i]$ 恰好为 $[1,i]$ 的排列，我们就考虑枚举这个最小的 $i$，记 $g_i$ 为长度为 $i$ 的、且存在某个长度不等于 $i$ 的前缀 $p[1...j]$ 为 $[1,j]$ 的排列的排列 $p$ 的个数，那么有 $g_i=i!-\sum\limits_{j<i}g_j(i-j)!$，根是合点的总数也就自然是 $2g_n$。

简单递推一下即可，复杂度三方。

```cpp
const int MAXN=400;
int mod,fac[MAXN+5],ifac[MAXN+5],dp[MAXN+5],s[MAXN+5][MAXN+5],f[MAXN+5];
void init(int n){
	for(int i=(fac[0]=ifac[0]=ifac[1]+1);i<=n;i++) ifac[i]=1ll*ifac[mod%i]*(mod-mod/i)%mod;
	for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;
	f[1]=1;
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++) f[i]=(f[i]+1ll*f[j]*fac[i-j])%mod;
		f[i]=(fac[i]-f[i]+mod)%mod;
	} s[0][0]=1;
	for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) for(int k=1;k<=i;k++)
		s[i][j]=(s[i][j]+1ll*s[i-k][j-1]*fac[k])%mod;
	dp[2]=(dp[1]=(dp[3]=0)+1)+1;
	for(int i=4;i<=n;i++){
		int sum1=0,sum2=0;
		for(int j=1;j<i;j++) sum1=(sum1+1ll*f[j]*fac[i-j])%mod;
		for(int j=4;j<i;j++) sum2=(sum2+1ll*dp[j]*s[i][j])%mod;
		int sub=(2ll*sum1+sum2)%mod;dp[i]=(fac[i]-sub+mod)%mod;
	}
}
int main(){
	int qu;scanf("%d%d",&qu,&mod);init(MAXN);
	while(qu--){
		int n;scanf("%d",&n);
		printf("%d\n",dp[n]);
	}
	return 0;
}
```



---

## 作者：Re_Yks_Offical (赞：0)

补档。

对排列构建出析合树之后，题意可以被转化为：求使得析合树的节点个数为 $n+1$ 的排列个数。

记录一个 $ans_i$ 表示 $n=i$ 对应的答案，这样每次询问都是 $\Theta(1)$ 的，考虑如何预处理。

根据题意，析合树节点个数 $n+1$，意味着根节点有 $n$ 个儿子，且这些儿子全部为叶子节点。正难则反，利用容斥可以把答案改为：排列个数（显然是 $n!$），减去根为合点的方案数，减去根为析点但是根的儿子个数 $<n$ 的方案数。

对于根为合点情况，根据合点性质，存在一个排列的前缀使得其为值域 $[1,i]$ 的连续段。考虑记录一个 $f_i$ 表示对于一个长度为 $i$ 的排列，其任何一个前缀都不是是值域为 $[1,i]$ 的连续段的方案数。

$f$ 显然存在转移方程，利用容斥，所有排列的个数减去不合法的个数即为答案，那么 $f_i$ 即为 $i!-\sum_{j=1}^{i-1}f_j(i-j)!$。而要求的因为是最终存在前缀的情况，故总数为 $\sum_{j=1}^{n-1}f_j(n-j)!$。

对于根为析点的情况，因为析点儿子数量 $\geq4$，故可以假设根的儿子为 $i$ 个，每个儿子是连续段，但是儿子排列不存在长度 $\geq2$ 的**严格子段**连续段。

设 $g_{i,j}$ 表示把 $i$ 个数划分到 $j$ 个儿子的方案数，显然，枚举最后一个儿子包含数的数量 $k$，有 $g_{i,j}=\sum_{k=1}^{i-1}g_{i-k,j-1}k!$。而该部分答案为 $\sum_{j=4}^{n-1}ans_j\cdot g_{n,j}$，其中 $ans_j$ 是对儿子排列的结果。

特判一下 $n=1,2,3$ 时答案分别为 $1,2,0$，原因显然，其余情况最终答案即为 $n!-\sum_{j=1}^{n-1}f_j(n-j)!-\sum_{j=4}^{n-1}ans_j\cdot g_{n,j}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define fr first
#define sc second
inline int read(){
	int res=0,f=1;char c=getchar();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') {res=res*10+(c-'0');c=getchar();}
	return res*f;
}
const int N=405;
int T,M,n,fac[N],f[N],g[N][N],ans[N];
signed main(){
	T=read(),M=read();
	fac[0]=1,g[0][0]=1;
	for (int i=1;i<=N-5;i++){
		f[i]=fac[i]=fac[i-1]*i%M;
		for (int j=1;j<=i;j++){
			for (int k=1;k<=i;k++){
				g[i][j]+=g[i-k][j-1]*fac[k]%M;
				g[i][j]%=M;
			}
			if (!(j^i)) continue;
			f[i]-=f[j]*fac[i-j]%M;
			f[i]=(f[i]%M+M)%M;
		}
	}
	ans[1]=1,ans[2]=2;
	for (int i=4;i<=N-5;i++){
		ans[i]=fac[i];
		for (int j=1;j<i;j++){
			ans[i]-=(f[j]*fac[i-j]%M)*2%M;
			ans[i]=(ans[i]%M+M)%M;
			if (j<=3) continue;
			ans[i]-=g[i][j]*ans[j]%M;
			ans[i]=(ans[i]%M+M)%M;
		}
	}
	while (T--){
		int n=read();
		cout<<ans[n]<<'\n';
	}
	return 0;
}
```

---


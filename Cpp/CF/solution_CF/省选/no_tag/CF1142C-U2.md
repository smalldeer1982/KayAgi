# U2

## 题目描述

最近，Vasya 得知，对于任意两个 $x$ 坐标不同的点，可以唯一确定一条形如 $y = x^2 + bx + c$ 的抛物线，其中 $b$ 和 $c$ 为实数。我们称这样的抛物线为 $U$ 形抛物线。

Vasya 在平面上画了若干个具有整数坐标的不同点，然后对于每一对 $x$ 坐标不同的点，画出一条经过这两点的 $U$ 形抛物线。图画变得有些杂乱，但 Vasya 仍然想统计，有多少条画出的抛物线，其内部区域内没有任何一个已画出的点。请你帮助 Vasya 计算。

$U$ 形抛物线的内部区域，指的是当 $y$ 轴向上时，平面上严格在该抛物线上方的部分。

## 说明/提示

下图中展示了每个样例中所有经过至少两个给定点的 $U$ 形抛物线。没有任何给定点在其内部区域的 $U$ 形抛物线用红色表示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1142C/eadb71d19e8e309ba0ad701fc60e7f0770012190.png) 第一个样例。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1142C/5f00543752befa1384c1835429988fa66192c6e3.png) 第二个样例。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
-1 0
0 2
1 0
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
1 0
1 -1
0 -1
-1 0
-1 -1
```

### 输出

```
1
```

# 题解

## 作者：世墨 (赞：3)

#### 这道题最难的部分在于把二次项给消去转换成一次函数的形式

发现二次函数的二次项系数恒为 $1$，不妨将点 $p (x,y)$ 记为 $p'(x,y-x^2)$

那么使经过点 $p,q$ 二次函数上方没有点相当于使经过点 $p',q'$的一次函数上方没有点

由于本人并不会维护上凸壳，我们利用斜率来考虑，用栈维护已有的点

##### 一些性质:
	
1. 对于横坐标相等的点，只要取纵坐标最大的考虑即可(否则必然不合法)

2. 对于要加入上凸壳的一个点 $p$，记 $k_1= \frac{y_p-y_{stack[top-1]}}{x_p-x_{stack[top-1]}},k_2=\frac{y_{stack[top]}-y_{stack[top-1]}}{x_{stack[top]}-x_{stack[top-1]}}$
 
如果$k_1>k_2$，则将当前栈顶弹出，因为该栈顶点并不合法

最后将输出 $top-1$ 即可

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

inline ll read(){
	ll num=0,neg=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
	while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
	return num*neg;
}

struct node{
	ll x,y;
}tmp[200010],p[200010],q[200010];

bool cmp1(node x,node y){return x.x!=y.x?x.x<y.x:x.y>y.y;}

inline double slope(node x,node y){return 1.0*(y.y-x.y)/(y.x-x.x);}

int n;

int main(){
	n=read(); bool all_zero=1;
	for(int i=1;i<=n;i++){tmp[i].x=read(),tmp[i].y=read();if(tmp[i].y!=0)all_zero=0;}
	if(all_zero){cout<<n-1;return 0;}
	sort(tmp+1,tmp+n+1,cmp1);
	int now=1,cnt=0;
	while(now<n){
		p[++cnt].x=tmp[now].x,p[cnt].y=tmp[now].y-tmp[now].x*tmp[now].x;
		while(tmp[now+1].x==tmp[now].x&&now<n)now++;now++;
	}if(tmp[n].x!=tmp[n-1].x)p[++cnt].x=tmp[n].x,p[cnt].y=tmp[n].y-tmp[n].x*tmp[n].x;
	q[0].x=-0x3f3f3f3f;
	int top=0;
	for(int i=1;i<=cnt;i++){
		while(top>1&&slope(q[top-1],q[top])<=slope(q[top-1],p[i]))top--;
		q[++top]=p[i];
	}
	cout<<top-1;return 0;
}

```

$完结撒花 `` \(^-^)/ ``$

---

## 作者：hsfzLZH1 (赞：3)

## 题目大意

给定二维平面上的 $n$ 个点 $(x_i,y_i)$ ，选择过任意两个点都可以做出一条解析式为 $y=x^2+bx+c$ 的二次函数。

你需要找到可以这样生成的 **本质不同** 的二次函数个数，使得对于所有给出的点，其要么在二次函数上，要么在二次函数的图像下方。

一个结点 $(x,y)$ 在二次函数的图像下方，当且仅当 $x^2+bx+c>y$ 。

两条二次函数本质不同当且仅当它们的 $b$ 不同或 $c$ 不同。

所有点互不相同。

$1\le n\le 100000,|x_i|,|y_i|\le 10^6$

## 解题思路

观察到题目的形式非常类似于一个凸包，但是那个 $x^2$ 项看着很烦，怎么办呢？

由于我们已经知道了所有节点的 $x$ 和 $y$ 值，我们将解析式移项得 $y-x^2=bx+c$ ， $bx+c$ 显然是任意直线，也就是说我们将每个结点的坐标从 $(x,y)$ 对应转换为 $(x,y-x^2)$ ，求转换后点集的 **上凸包** 即可。

时间复杂度 $O(n\lg n)$ 。

同样可以使用单调栈。（您打过斜率优化吗？）

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn=100010;
int n,lftmst,st[maxn],tot,ans;
struct Vector
{
    double x,y,polar_angle;
    bool operator<(Vector a)const{return polar_angle==a.polar_angle?y<a.y:polar_angle<a.polar_angle;}
    Vector operator-(Vector a){return{x-a.x,y-a.y,0};}
}s[maxn];
double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}
double dist(Vector a,Vector b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
int main()
{
    scanf("%d",&n);
    lftmst=1;
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf",&s[i].x,&s[i].y);
        s[i].y-=s[i].x*s[i].x;
        if(i!=1)if(s[i].y<s[lftmst].y||(s[i].y==s[lftmst].y&&s[i].x<s[lftmst].x))lftmst=i;
    }
    //for(int i=1;i<=n;i++)printf("%lf %lf\n",s[i].x,s[i].y);
    //printf("%d\n",lftmst);
    swap(s[1],s[lftmst]);
    for(int i=2;i<=n;i++)s[i].x-=s[1].x,s[i].y-=s[1].y,s[i].polar_angle=atan2(s[i].y,s[i].x);
    s[1].x=s[1].y=0;
    sort(s+2,s+n+1);
    //for(int i=1;i<=n;i++)printf("%lf %lf\n",s[i].x,s[i].y);
    for(int i=1;i<=n;i++)
    {
        while(tot>=2&&cross(s[st[tot]]-s[st[tot-1]],s[i]-s[st[tot]])<=0)tot--;
        //printf("%d %lf\n",tot,cross(s[st[tot]]-s[st[tot-1]],s[i]-s[st[tot]]));
        st[++tot]=i;
    }
    //for(int i=1;i<=tot;i++)printf("%d ",st[i]);printf("\n");
    //for(int i=1;i<=tot;i++)printf("%lf %lf\n",s[st[i]].x,s[st[i]].y);
    st[tot+1]=st[1];
    for(int i=1;i<=tot;i++)if(s[st[i+1]].x<s[st[i]].x)ans++;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Nelofus (赞：0)

这也太神秘了。

这个带二次项的东西好像很不好做，一次的情况我们会做吗？
> 给出 $n$ 个点，有多少个无序点对 $(P_a,P_b)$ 连成的直线满足其上方没有任何一个点？

答案显然先对于所有 $x$ 相同的点只保留 $y$ 最大的点，随后答案为上凸包大小 $-1$。

问题是现在是带一个二次项的 $y_i=x_i^2+bx_i+c$，但是这个 $x_i^2$ 系数是 $1$，跟选中的是哪两个点没关系。变成
$$
y_i-x_i^2=bx_i+c
$$
这个题最 ad-hoc 的部分就在这里：我们将 $(x_i,y_i)$ 变成 $(x_i,y_i-x_i^2)$，这个对每个点式子就变成了一次的 $t_i=bx_i+c$ 的形式，直接用上面一次的情况处理即可。

```cpp
// Code by Heratino & Nelofus
// Narcissus & どうか安寧な記憶を

#include <bits/stdc++.h>
using i64 = long long;

constexpr int N = 2e5 + 10;
struct Point {
	i64 x, y;
	Point() {}
	Point(i64 _x, i64 _y) : x(_x), y(_y) {}
} P[N];

using Vector = Point;
Vector operator - (const Vector &A, const Vector &B) {return Vector(A.x - B.x, A.y - B.y);}
Vector trans(const Vector &A, const Vector &B) {return B - A;}
i64 Cross(const Vector &A, const Vector &B) {return (i64)(A.x * B.y - A.y * B.x);}

int n;
Point stk[N];
int tt;
int tot;

int main() {
#ifdef HeratinoNelofus
	freopen("input.txt", "r", stdin);
#endif
	std::cin >> n;
	for (int i = 1; i <= n; i++) {
		i64 x, y;
		std::cin >> x >> y;
		P[i] = Point(x, y - x * x);
	}

	std::sort(P + 1, P + 1 + n, [&](auto a, auto b) -> bool {
			return a.x == b.x ? a.y < b.y : a.x < b.x;
			});

	for (int i = 1; i <= n; i++) {
		int j = i;
		while (P[j].x == P[i].x)
			j++;
		j--;
		P[++tot] = P[j];
		i = j;
	}
	n = tot;
	for (int i = 1; i <= n; i++) {
		while (tt > 1 && Cross(trans(stk[tt - 2], stk[tt - 1]), trans(stk[tt - 2], P[i])) >= 0)
			tt--;
		stk[tt++] = P[i];
	}
	std::cout << tt - 1 << '\n';
	return 0;
}
```

这启示我们当式子复杂而难以处理的时候，尝试变换坐标系可能会大幅度地简化问题。

---

## 作者：tribool4_in (赞：0)

非常好 Ad-hoc。

发现这个二次函数看着非常不爽，考虑怎么化为一次函数。

考虑对于某个点 $(x_i,y_i)$ 关于某个二次函数不合法的条件，形如 $x_i^2+bx_i+c<y_i$。注意到二次项系数为 $1$，于是移项得到 $bx_i+c<y_i-x_i^2$。

于是我们不妨令 $y_i'\gets (y_i-x_i^2)$。于是问题变为了：平面上 $n$ 个点，问这些点两两间构成的，不低于所有点的本质不同直线有多少种。容易证明这些点的上凸壳就是答案。

然后凸壳上可能有竖直的直线，如果实现优美的话应该只会出现在开头或末尾，判一下就行了。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n;
struct Point {
    ll x, y;
    Point() {}
    Point(ll x, ll y) : x(x), y(y) {}
} p[N];
Point operator-(const Point &a, const Point &b) { return Point(a.x - b.x, a.y - b.y); }
ll operator*(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }
int res[N], tot;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y, p[i].y -= p[i].x * p[i].x;
    sort(p + 1, p + n + 1, [](const Point &a, const Point &b) { return a.x < b.x || (a.x == b.x && a.y < b.y); });
    res[++tot] = 1;
    for (int i = 1; i <= n; i++) {
        while (tot > 1 && (p[res[tot]] - p[res[tot - 1]]) * (p[i] - p[res[tot - 1]]) >= 0) --tot;
        res[++tot] = i;
    }
    int l = 1;
    while (p[res[l]].x == p[res[l + 1]].x) ++l;
    cout << tot - l << '\n';
    return 0;
}
```

---

## 作者：Rhapsodia (赞：0)

题目意思大概就是有很多个 $y = x^2 + bx + c$ ，我们移一下项，变为： $y-x^2=bx+c$ 。

转换坐标轴，将给定的坐标 $(x,y)$ 变为 $(x,y-x^2)$，这样原来的二次函数转为一次函数。

跑一遍 Graham ，题目转化为了求上凸壳有多少条边，改一下模板即可。

#### 感觉就是凸包模板题 + 思维

```cpp
#include <bits/stdc++.h>
typedef long long LL;
int read()
{
	int s = 0; bool f = false;
	char ch = getchar();
	while (!(ch >= '0' && ch <= '9'))
		f ^= (ch == '-'), ch = getchar();
	while (ch >= '0' && ch <= '9')
		s = (s << 3) + (s << 1) + (ch ^ 48), ch = getchar();
	return f ? -s : s; 
} 
const int MAXN = 100005;
const double eps = 1e-6;
struct Point
{
	double x, y;
	Point(double X = 0, double Y = 0)
	: x(X), y(Y){}
	friend Point operator+(Point a, Point b)
	{ return Point{a.x + b.x, a.y + b.y}; }
	friend Point operator-(Point a, Point b)
	{ return Point{a.x - b.x, a.y - b.y}; }
	friend double operator|(Point a, Point b)
	{ return a.x * b.y - a.y * b.x; }
	void show()
	{ printf("%g %g\n", x, y); }
 } p[MAXN];
double dist(Point a, Point b)
{ return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); }
double slope(Point a, Point b)
{ return a.x == b.x ? 1e18 : (a.y - b.y) / (a.x - b.x); }
int n, stk[MAXN], tp = 0;
int Graham()
{
	int pos = 1;
	for (int i = 2; i <= n; i++)
		if (p[i].x < p[pos].x || (p[i].x == p[pos].x && p[i].y < p[pos].y))
			pos = i;
	std::swap(p[1], p[pos]);
	Point st = p[1];
	std::sort(p + 1, p + n + 1, [st](Point a, Point b){
		return ((a - st) | (b - st)) == 0 ? dist(a, st) < dist(b, st) : ((a - st) | (b - st)) >= 0;
	});
	stk[++tp] = 1;
	for (int i = 2; i <= n; i++)
	{
		while (tp > 1 && ((p[i] - p[stk[tp - 1]]) | (p[stk[tp]] - p[stk[tp - 1]])) + eps >= 0)
			tp--;
		stk[++tp] = i;
	}
	stk[++tp] = 1;
//	p[1].show();
	int cnt = p[stk[tp]].x != p[stk[tp - 1]].x;
	for (int i = tp - 2; i; i--)
	{
		if (slope(p[stk[i]], p[stk[i + 1]]) > slope(p[stk[i + 2]], p[stk[i + 1]]) || p[stk[i]].x == p[stk[i + 1]].x)
		{
//			for (int j = i + 1; j <= tp; j++)
//				printf("%g %g\n", p[stk[j]].x, p[stk[j]].y);
			return cnt;
		}
		if (slope(p[stk[i]], p[stk[i + 1]]) < slope(p[stk[i + 2]], p[stk[i + 1]]))
			cnt++;
	}
	return cnt;
}
int main()
{
	n = read();
	for (int i = 1; i <= n; i++)
		scanf("%lf %lf", &p[i].x, &p[i].y), p[i].y -= p[i].x * p[i].x;
	printf("%d\n", Graham());
	return 0;
}
```

---

## 作者：暗影之梦 (赞：0)

## 题目大意：
给定 $n$ 个点，每次在 $ n $ 个点中选出两个来构成二次函数 $ x ^ 2 + bx + c $ 。问有多少个这样构成的二次函数，使这一条二次函数上面没有一个给定点。

## 解题思路：
由于函数的二次项系数为常数，所以不妨将方程转换为这样： $y-x^2=bx+c$  。题目便演变成在 $ n $ 个转换后点中选两个点构成一次函数，使所有点都在一次函数下方或一次函数上。因为我们将方程转为了 $ y - x ^ 2 = bx + c $ ，所以我们所有点的 $ y $ 坐标都要改为 $ y - x ^ 2 $ 。

将转换后的点构成一个上凸包，可以得出如果一次函数取的点不在凸包上，那么一定有点处于一次函数上方；若两个选择的点不相邻，夹在中间的点也会在构造一次函数上。因此只能取凸包上的相邻两点。而一个不封闭图形边上相邻点的个数为这个图形边上点数 $ -1 $ 。最后题目就转化为了将 $ n $ 个点构造一个上凸包，求这个上凸包的点数 $ -1 $ 。

## 代码作参考：
```c
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
int tail,ans;
struct node
{
	int x,y;
}a[1000001],q[1000001];
inline int cmp(node a,node b)
{
	if(a.x==b.x) return a.y>b.y;
	return a.x<b.x;
}
inline int slope(node a,node x,node y)
{
	return (x.x-a.x)*(y.y-a.y)-(x.y-a.y)*(y.x-a.x);
}
int n;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x>>a[i].y;
		a[i].y-=a[i].x*a[i].x;
	}
	sort(a+1,a+n+1,cmp);
	a[0].x=-2e9;
	for(int i=1;i<=n;i++)
	{
		if(a[i].x==a[i-1].x) continue ;
		while(tail>1&&slope(a[i],q[tail],q[tail-1])<=0) tail--;
		q[++tail]=a[i];
	}
	cout<<tail-1;
	return 0;
}
```


---

## 作者：Piwry (赞：0)

## 解析

考虑对于一个二次函数 $y=x^2+bx+c$，如果想要令所有的点 $(x_i, y_i)$ 都不在其 “上方”（严格的 “上方”），那么就相当于对每个点都要求 $y_i\leq x_i^2+bx_i+c$

考虑将 $x_i^2$ 移到左侧，再**重新理解**这个式子 $y_i-x_i^2\leq bx_i+c$。设 $y_i'=y_i-x_i^2$，可以发现这就相当于在求一条直线，使得所有点 $(x_i, y_i')$ 都不在这条直线 “上方”。注意这里**已经不是原来点的坐标系了**

再观察在原来的坐标系中是怎样通过两个点 $(x_i, y_i), (x_j, y_j)$ 确定二次函数的。我们实际上就是要求二次函数 $y=x^2+bx+c$ 同时满足 $y_i=x_i^2+bx_i+c$ 和 $y_j=x_j^2+bx_j+c$。仍旧考虑将 $x_i^2, x_j^2$ 移到左侧，发现这实际上就是在**新的坐标系中**求一条直线 $y=bx+c$ 经过 $(x_i, y_i')$ 和 $(x_j, y_j')$

（可能逻辑上有些不易察觉的严谨性问题...还请见谅 \kk）

于是原题就被转化为了，在新坐标系（定义见上）中，给定点集，要求求由两个点可以确定多少个**不同的**直线（且该直线必须能被表示成 $y=kx+c$ 的形式），满足所有点都不在该直线的 “上方”（严格的 “上方”）

显然只需求一个上凸壳，再统计上凸壳的边数即可（不过注意竖直的边不能统计为答案，因为它不能被表示为 $y=kx+c$ 的形式，只能表示为类似 $x=c$ 的形式）

## CODE

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#define ll long long
using std::sort;

const int MAXN =1e5+20;

/*------------------------------Geometry------------------------------*/

const double eps =1e-12;

struct vect{
	ll x, y;
	vect(){}
};

inline bool gtr(double a, double b){ return a-b > eps; }

bool cmp(const vect &A, const vect &B){
	if(A.x == B.x)/*同横坐标的取最上*/
		return A.y < B.y;
	else
		return A.x < B.x;
}

double k(const vect &x, const vect &y){
	return (double)(y.y-x.y)/(y.x-x.x);
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar(); bool f =0;
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<3)+(x<<1)+(48^c), c =getchar();
	return (f) ? -x : x;
}

vect point[MAXN];
int stk[MAXN], tot;

int main(){
	int n =read();
	for(int i =0; i < n; ++i)
		point[i].x =read(), point[i].y =read()-1ll*point[i].x*point[i].x;
	sort(point, point+n, cmp);
	for(int i =0; i < n; ++i){/*维护上凸壳*/
		/*x 坐标重复的点显然取 y 坐标最大的*/
		while(i < n-1 && point[i+1].x == point[i].x)
			++i;
		/*k_stk <= k_new -V*/
		while(tot >= 2 && !gtr(k(point[stk[tot-2]], point[stk[tot-1]]), k(point[stk[tot-1]], point[i])))
			--tot;
		stk[tot++] =i;
	}
	printf("%d", tot-1);
}
```

---

## 作者：Erina (赞：0)

## 上凸壳

这一题...... 快读写错调了一年233333

我们看到点和二次函数的关系类问题, 第一时间就要想到把二次函数转换为一次函数处理, 方法就是把右面的$x^2$搬到左边去. 把每个点也这么做.

然后方程变成了$y-x^2=bx+c$, 点变成了$(x,y-x^2)$

然后就简单了...... 发现问题转换为上方没有点的直线数量, 正好就是上凸壳的定义, 然后就直接上板子就可以了.

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
namespace fio {
	streambuf*in = cin.rdbuf();
	char bb[1000000], *s = bb, *t = bb;
#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)
	inline int read() {
		int x = 0, w = 1;
		char ch = gc();
		while (ch < 48)w = (ch == '-') ? -1 : 1, ch = gc();
		while (ch >= 48)x = x * 10 + ch - 48, ch = gc();
		return x * w;
	}
}using fio::read;
int n;
typedef pair<long double, long double>mp;
mp operator - (mp a, mp b) {
	return mp(a.first - b.first, a.second - b.second);
}
mp operator + (mp a, mp b) {
	return mp(a.first + b.first, a.second + b.second);
}
long double operator * (mp a, mp b) {
	return a.first*b.second - a.second*b.first;
}
long double dis(mp x) {
	return x.first*x.first + x.second*x.second;
}
mp huaji[100005];
int sta[100005], top;
int main() {
	n = read();
	if (n == 1)cout << 0, exit(0);
	for (int i = 0; i < n; i++)
		huaji[i].first = read(), huaji[i].second = read() - huaji[i].first*huaji[i].first;// 转换为一次函数问题
	for (int i = 1; i < n; i++)
		if (huaji[i].second < huaji[0].second || (huaji[i].second == huaji[0].second&&huaji[i].first < huaji[0].first))
			swap(huaji[0], huaji[i]);
	sort(huaji + 1, huaji + n, [](mp a, mp b) {
		return (a - huaji[0])*(b - huaji[0]) == 0 ? dis(a - huaji[0]) < dis(b - huaji[0]) : ((a - huaji[0])*(b - huaji[0]) > 0);
	});// 凸包排序
	sta[++top] = 1;
	for (int i = 2; i < n; i++) {
		while (top && (huaji[sta[top]] - huaji[sta[top - 1]])*(huaji[i] - huaji[sta[top - 1]]) <= 0)top--;
		sta[++top] = i;
	}
	int ans = 0;
	for (int i = 0; i <= top; i++) {
		int nex = (i + 1) % (top + 1);
		if (huaji[sta[i]].first > huaji[sta[nex]].first)ans++;
	}// 上凸壳的模板
	cout << ans;
}
```


---


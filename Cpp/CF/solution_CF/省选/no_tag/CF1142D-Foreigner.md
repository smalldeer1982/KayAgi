# Foreigner

## 题目描述

定义 “不充分” 的数字 $x$ 必须满足以下条件之一

- $x$ 是 $[1, 9]$ 范围内的数字
- $\lfloor x/10\rfloor$ 是一个 “不充分” 的数字；并且若给每个 “不充分” 的数字排名（序号从 $1$ 开始），而 $\lfloor x/10\rfloor$ 得到的排名为 $k$，那么 $x$ 的最后一位数必须严格小于 $k\mod 11$

这里 $\lfloor x/10\rfloor$ 指 $x/10$ 向下取整

因此，如果有一个 “不充分” 的数字，且其排名为 $m$，而 $m$ 模 $11$ 的余数为 $c$，那么 $10\cdot x+0, 10\cdot x+1, \cdots, 10\cdot x+(c-1)$ 都是 “不充分” 的，同时 $10\cdot x+c, 10\cdot x+(c+1), \cdots, 10\cdot x+9$ 都不是 “不充分” 的

前几个 “不充分” 的数字为 $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 30, 31, 32, \cdots$ 在这之后，$40, 41, 42, 43$ 是 “不充分” 的，而 $44, 45, 46, \cdots, 49$ 不是 “不充分” 的；由于 $10$ 是第 $10$ 个 “不充分” 的数字，因此 $100, 101, 102, \cdots, 109$ 都是 “不充分” 的。由于 $20$ 是第 $11$ 个 “不充分” 的数字，因此 $200, 201, 202, \cdots, 209$ 中，没有一个数是 “不充分” 的

现在给出一个仅由数字组成的字符串，你需要求出该字符串中所有为 “不充分” 的数字的子串数量。如果一个一个子串在不同的位置出现多次，则对它的所有出现分别计数

## 样例 #1

### 输入

```
4021
```

### 输出

```
6
```

## 样例 #2

### 输入

```
110
```

### 输出

```
3
```

# 题解

## 作者：bztMinamoto (赞：10)

对着$yyb$巨巨那长达$20$行的代码盯了一个下午……

首先题目里说的太麻烦了，我们把它用代码的形式写出来，大概是这样的

```cpp
fp(i,1,9)q[++t]=i;
while(true){
	int u=q[h];
	fp(j,0,h%11-1)q[++t]=q[h]*10+j;
	++h;
}
```

那么我们发现这个数列显然是递增的

我们先来思考一个问题，对于数列中的第$i$个数，往它后面怼一个$c$，那么这个新的数在数列中的标号是多少呢？

因为这个数列是递增的，那么显然我们只需要计算出有多少数比它小就可以了

先给出柿子，$i$后面怼一个$c$，新的数的标号为

$$9+\sum_{k=1}^{i-1}k\%11+c+1$$

$9$代表初始的$9$个数，然后$1$到$i-1$中每个数后面怼一个数位显然都会比新数小，$c+1$应该不用解释了

然而这柿子看着就很麻烦……我们发现后面可以怼的数字只与标号对$11$取模的值有关，我们尝试把整个柿子都放到$\bmod 11$的意义下，这样就能把中间的$k\%11$去掉了

$$9+\sum_{k=1}^{i-1}k+c+1\bmod 11$$

$$9+{i(i-1)\over 2}+c+1\bmod 11$$

如此这般之后，我们发现数字的标号，其实只需要维护$\bmod 11$意义下的值就可以了

我们设$f_{i,j}$表示末尾数位为$s[i]$，标号在$\bmod 11$意义下为$j$，且能匹配上以$i$为结尾的子串的数的个数

我们记上面那个值为$nxt(i,j)$，就是标号为$i$的后面怼个$j$的数的标号，那么转移就有

$$f_{i,nxt(j,s[i])}+=f_{i-1,j}$$

记得这里要满足$j>s[i]$

顺便注意如果$s[i]>0$的话单独一个数字也是可以匹配的

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define ll long long
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(char *s){
	R int len=0;R char ch;while(((ch=getc())>'9'||ch<'0'));
	for(s[++len]=ch;(ch=getc())>='0'&&ch<='9';s[++len]=ch);
	return s[len+1]='\0',len;
}
const int N=1e5+5;
char s[N];int f[N][15],n;ll res;
inline int nxt(R int x,R int c){return ((x*(x-1)>>1)+c+10)%11;}
int main(){
//	freopen("testdata.in","r",stdin);
	n=read(s);
	fp(i,1,n){
		fp(j,s[i]-'0'+1,10)f[i][nxt(j,s[i]-'0')]+=f[i-1][j];
		if(s[i]>'0')++f[i][s[i]-'0'];
		fp(j,0,10)res+=f[i][j];
	}
	printf("%I64d\n",res);
	return 0;
}
```

---

## 作者：Kevin090228 (赞：5)

我们知道了 $\overline{x_1x_2x_3\cdots x_k}$ 是第几个好数，还知道 $k$ 位好数个数和 $<k$ 位好数个数，那就可以 $O(1)$ 求出 $\overline{x_1\cdots x_k x_{k+1}}$ 是第几个好数了。所以我们可以从一个数码开始，不断尝试向后扩展，同时记录一下当前的好数是第几个好数，能做到 $O(n^2)$。好数个数可能很多，但是我们记录的时候只需要记录其模 $11$ 的余数即可。

这个做法的瓶颈是你没法对一堆子串统一处理，就算你用了 SAM 或者什么的你也不能快速得到节点所有串的信息。想一想会发现不能做到的原因实际上是你不同串长不好一起处理，考虑把当前串长从状态里面扔出去。注意到你用到关于串长的实际只有 $k/k-1$ 位好数个数这件事，所以直接把这东西也一并扔到状态里面去处理就可以了。

然后现在我们可以把一个好数表示成 $(a,b,c)$ 表示当前串是第 $a$ 个好数，与它位数相同的好数有 $b$ 个，比它位数少的好数有 $c$ 个。这里所有数都是模 $11$ 意义下的。提前预处理一下，把这个东西搞成自动机，然后相当于对串在 AC 自动机上跑一个匹配即可。

时间复杂度 $O(11^4\times T+11^3n)$。这里 $T$ 代表你预处理时可能为了代码简便写出的冗余复杂度。

---

## 作者：Drind (赞：3)

### 题目解析

我们列出一个很 naive 的 dp 式子就是 $f_{i,j}$ 代表给定数列前 $i$ 位中有多少排名为 $j$ 的不充分数字。

转移很简单，就是 $f_{i,g(j,k)} \gets f_{i-1,j}$，其中 $k$ 代表这一位上的数字，而 $g(j,k)$ 代表排名为 $j$ 的不充分数字后面加一个 $k$ 会变成什么排名。

我们先考虑 $g(j,k)$ 函数怎么求值吧，其实很简单，因为所有排名在 $[i,j-1]$ 中的所有不充分数字经过一次扩展都会小于 $j$ 后面扩展一个 $k$，所以答案就是：

$$\sum_{i-1}^{j-1}i\bmod11+9+k+1$$

然后我们就惊奇的发现这个排名只跟模 11 之后有关，所以就直接把我们 dp 式子里的 $j$ 模上 11 即可。

注意一下往后扩展 $k$ 要求 $j\gt k$。

还有要把一位的不充分数字加上。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;

int f(int x,int y){
	return (9+x*(x-1)/2+y+1)%11;
}

int dp[N][11];

inline void fake_main(){
	string s; cin>>s; s=" "+s; int ans=0;
	for(int i=1;i<s.size();i++){
		for(int j=s[i]-'0'+1;j<=10;j++){
			dp[i][f(j,s[i]-'0')]+=dp[i-1][j];
		}
		if(s[i]!='0') dp[i][s[i]-'0']++;
		for(int j=0;j<=10;j++) ans+=dp[i][j];
	}
	cout<<ans<<"\n";
}

signed main(){
	ios::sync_with_stdio(false);
	int t; t=1;
	while(t--) fake_main();
}

```

---

## 作者：daniEl_lElE (赞：1)

注意到对于第 $i$ 个不充分数字 $x$，$10x$ 的标号 $\bmod\ 11$ 仅由 $i\bmod 11$ 决定，且根据手模得到分别为 $\{10,10,0,2,5,9,3,9,5,2,0\}$。

考虑 $dp_{i,j}$ 表示看到第 $i$ 位，$x\sim i$ 位组成的不充分数字当中标号 $\bmod\ 11=j$ 的 $x$ 数量。转移的时候考虑 $s_{i+1}$ 是否小于 $j$，并转移到 $10x+s_{i+1}$ 的对应位置即可。

总复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int dp[100005][11];
int to[11]={10,10,0,2,5,9,3,9,5,2,0};
signed main(){
	string s; cin>>s; int n=s.size(),ans=0; s=" "+s;
	for(int i=1;i<=n;i++){
		if(s[i]!='0'){
			dp[i][s[i]-'0']++;
		}
		for(int j=0;j<=10;j++) ans+=dp[i][j];
		if(i+1==s.size()) continue;
		for(int j=0;j<=10;j++){
			if(s[i+1]-'0'<j){
				dp[i+1][(to[j]+s[i+1]-'0')%11]+=dp[i][j];
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：LingHusama (赞：1)

## CF1142D Foreigner题解
### 前言：
题目含义真的好难理解呜呜。

遇到的 dp 套 dp 的第三题，所以深入进行了理解。

参考博文：https://www.cnblogs.com/AWhiteWall/p/16479483.html
### 题意简化：
先定义了不充分。
1. 首先数字 $[1,9]$ 都不充分，注意没有 $0$。
2. 当这个数字（设为 $x$）大于等于 $10$ 时，我们将它拆成两部分，一部分是他的最后一位，我们设为 $c$，另一部分为去掉末尾后的数字，我们设其为 $y$，那么需要满足 $y$ 是不充分的，并且 $y$ 在所有不充分数中的大小排名 $Rank_y$ 满足 $c < Rank_y \bmod 11$。

很复杂吧，我也觉得，所以要不不做了吧……

### 题解思路：
就像游园会那一道题一样，对于 dp 套 dp 我们先思考要是有个神犇，你需要他帮你设计什么自动机？
似乎就是一个较为普通的自动机吧，甚至没有神犇你都可以建立出来。大概就是  $f(i-1,j)$ 转移到 $f(i,nxt(j,s_i))$，其中 $nxt$ 表示的是大小标号为 $i$  的数字在后面加上数字 $j$ 所达到数字的大小标号。

现在考虑怎么计算题目所需的答案。可以考虑每“增加”一个字符，就统计所有最后一位为该字符的子串

对于这个自动机每一次转移需要满足 $s_i<j\bmod11$。

然后接着考虑内部的 $nxt$ 怎么求解，我们假设原来的数字排名为 $k$，加入的数字为 $c$，

那么答案是：

$9+\sum_{i=1}^{k-1}(i\bmod11)+c+1$。

由于数据范围较大，这个状态也很有可能有很多个，于是就会达到 $O(n^2)$ 级别的时间复杂度。


现在时间复杂度需要优化，不然就是在前面的枚举开头字符中减少，不然就是在自动机那里减少。

我们看到有个 $x\bmod11$ 这个操作，又发现标号 $i$ 变为 $i\bmod11$ 对于答案不会产生影响，于是我们就想到优化状态数。

那么此时内部的转移，我们稍微利用一下等差数列（当然也可以直接预处理），答案就是：

$(9+k(k-1)/2+c+1)\bmod11$。

然后直接两个套就好了。
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int getnxt(int nowk,char c){
	int nowc=c-'0';
	return (9+((nowk*(nowk-1)/2)%11)+nowc+1)%11;
}
int f[100005][12];
signed main(){
	ios::sync_with_stdio(false);
	string s;
	cin >> s;
	int ans=0;
	
	int n=s.size();
	s=" "+s;
	for(int i=1;i<=n;i++){
		for(int j=s[i]-'0'+1;j<=10;j++){
			f[i][getnxt(j,s[i])]+=f[i-1][j];
		}
		if(s[i]>'0'){
			f[i][s[i]-'0']++;
		}
		for(int j=0;j<=10;j++){
			ans+=f[i][j];
		}
	}
	cout<<ans;
} 

```





---

## 作者：Piwry (赞：1)

## 解析

我们首先考虑一个 “不充分”（ “inadequate”）的数 $x$，排名为 $k$，在它后面加一个数位 $c$（且这合法），其 “拓展” 出的数字 $x'$ 的排名 $k'$

思考下可发现 $k'=9+\sum\limits_{i=1}^{k-1}{(i\mod 11)}+c+1$。其中 $9$ 是不可被拓展出的 $9$ 个数 $1$ ~ $9$；$\sum\limits_{i=1}^{k-1}{(i\mod 11)}$ 是所有比 $x$ 小的数拓展出的数，可以知道它们一定比 $x'$ 小；而 $c$ 则是同由 $x$ 拓展出，但最后一位数比 $x'$ 小的数

我们发现一个数能拓展出的数的个数只与它的排名模 $11$ 的余数有关，于是我们实际上并不需要记录具体的排名 $k$，而只需记录这个排名模 $11$ 的余数 $k\mod 11$

现在考虑怎么计算题目所需的答案。可以考虑每 “增加” 一个字符，就统计所有最后一位为该字符的子串。设 $dp(i, r)$ 表示所有 $[l, i]$ 的子串中，排名模 $11$ 余数为 $r$ 的为 “不充分” 的数字的子串数量。那么答案就为 $\sum\limits_{i=1}^n{\sum\limits_{r=0}^{10}dp(i, r)}$

考虑怎么从 $i-1$ 转移到 $i$，这其实很简单。具体来说，$dp(i-1, r)$ 中所有的子串，在加上 $s[i]$ 后，其新的排名模 $11$ 的值就为 $(9+\sum\limits_{i=1}^{k-1}{(i\mod 11)}+c+1)\mod 11$；而其中 $\sum\limits_{i=1}^{k-1}{(i\mod 11)}$ 的值可以预处理，且也没必要真的算到 $k-1$，算到 $(k-1+11)\mod 11$ 就行了（证明考虑模的性质即可）

## CODE

```cpp
#include <cstdio>
#define ll long long

const int MAXN =1e5+20;

int sum[11];/*$\sum\limits_{i=1}^{n}{(i\mod 11)}*/

inline void pre(){
	for(int i =1; i < 11; ++i)
		sum[i] =sum[i-1]+i;
}

inline int get_rank(const int &now_rank, const int &c){
	return (9+sum[(now_rank-1+11)%11]+c+1)%11;
}

/*V- 所有 [l, i] 子串中，排名余数为 r 的子串数量 ( 注意交换了下标 )*/
ll dp[11][MAXN];
int s[MAXN];

int main(){
	pre();
	int tot =0;
	for(char c =getchar(); c >= '0' && c <= '9'; c =getchar())
		s[++tot] =c-'0';
	ll ans =0;
	for(int i =1; i <= tot; ++i){
		for(int r =s[i]+1; r < 11; ++r)
			dp[get_rank(r, s[i])][i] +=dp[r][i-1];
		if(s[i] != 0)
			++dp[s[i]][i];
		for(int r =0; r < 11; ++r)
			ans +=dp[r][i];
	}
	printf("%lld", ans);
}
```

---

## 作者：TTpandaS (赞：0)

首先可以把前 $1000$ 个不充分的数字打表找出来。然后可以找到这样一组数及其排名：$(3,3),(14,31),(69,311),(344,3111)$，我们发现在 $3$ 后面不停的增加 $1$，得到的数的排名对于 $11$ 取模的值相同。打表发现其余数也有如此规律。

因此可以预处理出所有形如 $x + y \to z(0 \leq x,z \leq 11,0 \leq y \leq 9)$ 的边，表示对于 $rk \equiv x \pmod {11}$ 的数，在后面添加一个数 $y$，得到的新的数满足 $rk' \equiv z \pmod {11}$。

设 $f_{x,op}$ 表示以 $x$ 结尾的数满足 $rk \equiv op \pmod {11}$ 的数量，枚举每条转移边从 $f_{x-1,op'}$ 更新即可。第一位可以滚动处理。

---

## 作者：JWRuixi (赞：0)

### 题意

定义 $x$ 是**好的**，当且仅当 $x$ 属于通过以下代码生成的序列：

```cpp
L (i, 1, 9) q[++r] = i;
int i = 1;
while (true) {
  L (j, 0, i % 11 - 1) {
    q[++r] = q[i] * 10 + j;
  }
}
```

给定字符串 $s$，求其有多少个子串是好的。

$n \le 10^5$。

### 分析

考虑 $x(x > 9)$ 是好的需要满足那些条件：显然，$\lfloor \dfrac{x}{10} \rfloor$ 也是好的。

这意味着，如果 $s(l, r)$ 是好的，则 $s(l, r - 1)$ 也是好的，那么对于一个 $l$ 合法的 $r$ 是一段前缀。

可以考虑延展已有后缀的思路，用递推的方式维护答案。这启发我们压缩一个串的状态：记 $(l, k)$ 表示长度为 $l$，排名为 $k$ 的串。

有了这些信息我们就可以尝试通过递推的方式维护一个串是否合法。假设当前数为 $x$，我想知道 $\overline{xa}$ 的排名。

不妨设 $b_i$ 表示 $\min\limits_{l = i} k$，令 $M = 11$，则：

$$
(l, k) \to (l + 1, b_{l + 1} + \sum_{i = b_l}^{k - 1} (i \bmod M) + a)
$$

注意到我们递推的过程中始终只关心 $i \bmod M$ 的值，所以我们可以将状态压缩为 $(l, k^\prime)$，其中 $k^\prime = k \bmod M$，压缩 $b^\prime_i = b_i \bmod M$。将 $b^\prime_i$ 和 $k^\prime$ 视为在一模 $M$ 的环上，转移时任然成立。

至此转移任然和 $l$ 有关，状态数 $\mathcal O(nM)$，不能接受。

但是我们注意到了关键的变量 $b_i$。递推式 $b_{i + 1} = b_{i} + \dfrac{(b_i - b_{i - 1})(b_i - b_{i - 1} - 1)}{2}$，这个式子会直观的让人觉得它有通项或周期，事实上 $b^\prime = \{1, 10, 0, 10, 0, \dots\}$。可以通过归纳法证明。

带回原式：

$$
k \to \begin{cases}10 + k(k - 1) / 2 + a & b^\prime_l = 0 \\ 0 + (k(k - 1) / 2+ 10) + a & b^\prime_l = 10\end{cases}
$$

也就是说，无论如何 $(l, k) \to (l + 1, (k(k - 1) / 2 + a - 1) \bmod 10)$，那么这个转移就与 $l$ 无关了！

我们可以尝试递推，枚举 $r$，尝试对于 $r - 1$ 的一个后缀能否加入 $s_r$，条件是 $k > s_r$。

注意周期是从第二位开始的，所以要特判长度为 $1, 2$ 的部分。

时间复杂度 $\mathcal O(nM)$，空间复杂度 $\mathcal O(n + M)$。

### Code

提交记录：<https://codeforces.com/contest/1142/submission/245771374>。

---


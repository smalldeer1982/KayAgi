# Vus the Cossack and a Field

## 题目描述

哥萨克 Vus 有一个 $n \times m$ 的田地，这个田地由“0”和“1”组成。他正在用这个田地构建一个无限大的田地。构建方式如下：

1. 他将当前田地取反，得到一个新的田地。也就是说，新的田地中，原来是“0”的地方变成“1”，原来是“1”的地方变成“0”。
2. 将取反后的田地拼接到当前田地的右侧。
3. 将取反后的田地拼接到当前田地的下方。
4. 将当前田地拼接到右下角。
5. 重复上述过程。

例如，若初始田地为：

$\begin{matrix} 1 & 0 \\ 1 & 1 \\ \end{matrix}$

第一次迭代后，田地变为：

$\begin{matrix} 1 & 0 & 0 & 1 \\ 1 & 1 & 0 & 0 \\ 0 & 1 & 1 & 0 \\ 0 & 0 & 1 & 1 \\ \end{matrix}$

第二次迭代后，田地变为：

$\begin{matrix} 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\ 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 \\ 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 \\ 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 \\ 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\ \end{matrix}$

以此类推……

我们将行从上到下编号为 $1$ 到无穷，列从左到右编号为 $1$ 到无穷。我们称子矩阵 $(x_1, y_1, x_2, y_2)$ 为所有满足 $x_1 \leq x \leq x_2$ 且 $y_1 \leq y \leq y_2$ 的格子 $(x, y)$ 组成的矩阵。

有时哥萨克需要查询某些子矩阵内所有数字的和。由于他现在很忙，所以请你帮他计算答案！

## 说明/提示

第一个样例的过程已在题目描述中给出。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2 2 5
10
11
1 1 8 8
2 4 5 6
1 2 7 8
3 3 6 8
5 6 7 8
```

### 输出

```
32
5
25
14
4
```

## 样例 #2

### 输入

```
2 3 7
100
101
4 12 5 17
5 4 9 4
1 4 13 18
12 1 14 9
3 10 7 18
3 15 12 17
8 6 8 12
```

### 输出

```
6
3
98
13
22
15
3
```

# 题解

## 作者：hsfzLZH1 (赞：7)

## 题目大意

给定一个 $n\times m$ 的 $01$ 矩阵 $a$ ，定义对矩阵的反转为将矩阵 $a$ 中原来的 $0$ 变为 $1$ ， $1$ 变为 $0$ ，得到一个新的矩阵 $r$ ，定义对矩阵的扩展操作为将两个原矩阵 $a$ 的反转分别置于原矩阵的右侧和下方，将原矩阵的复制置于原矩阵的右下角，得到一个二维均为原来的两倍的矩阵，即，若原来的矩阵是 $a$ ，则扩展一次后的矩阵是

$\left\{ \begin{matrix} a & r \\ r & a \end{matrix} \right\} $ 。

现在将给定的矩阵扩展无数次，得到矩阵 $c$ ， $q$ 次询问，每次询问给定 $x1,y1,x2,y2$ ，求矩阵中以坐标 $(x1,y1)$ 为左上角， $(x2,y2)$ 为右上角的子矩阵中数的和。下标从 $1$ 开始。

$1\le n,m\le 1000,1\le q\le 10^5,0\le a_{i,j}\le 1$

$1\le x1\le x2\le 10^9,1\le y1\le y2\le 10^9$

## 解题思路

### 前置知识：二维前缀和

给定一个数列 $a_i$ ，每次查询 $\sum_{i=l}^r a_i$ 的值，我们可以 $O(n)$ 预处理出其前缀和 $s_i=\sum_{j=1}^r a_j$ （利用其定义有 $s_i=s_{i-1}+a_i$ ），可以在单次 $O(1)$ 的时间复杂度内查询 $\sum_{i=l}^r a_i=s_r-s_{l-1}$ 。

如果是查询静态二维数组中的子矩阵的和，可以使用二维前缀和的技巧。

令 $s_{x,y}=\sum_{i=1}^x\sum_{j=1}^y a_{i,j}$ ，根据容斥原理，题目所求的子矩阵和为 $sum_{x1,y1,x2,y2}=s_{x2,x2}-s_{x2,y1-1}-s_{y2,x1-1}+s_{x1-1,y1-1}$ 。（这个可以画图证明），单次查询复杂度为 $O(1)$ 。

但是每次枚举 $x,y$ ，暴力计算和的复杂度是 $O(n^4)$ ；即使从 $s_{x-1,y}$ 加上 $y$ 的数的复杂度也有 $O(n^3)$ ，无法满足要求。我们利用上述式子的一个特殊情况，得

$s_{x,y}=s_{x,y-1}+s_{x-1,y}-s_{x-1,y-1}+a_{x,y}$ 。

这样，就可以用 $O(n^2)$ 预处理， $O(1)$ 查询子矩阵和。

### 性质：如何判断一个位置是否已经反转

给定一个矩阵中的坐标 $(x,y)$ ，我们可以很轻松地求出其对应初始矩阵中的坐标 $(x~mod~n+1,y~mod~m+1)$ ，但是不知道这个位置的值是否已经反转，这不利于我们的求值。

我们不妨把初始矩阵作为一个 **整体** 来研究这个问题。

假设初始矩阵是 $0$ ，其反转后的矩阵是 $1$ 。我们可以列出矩阵的一部分：

$\left\{ \begin{matrix} 0&1&1&0&1&0&0&1&... \\ 1&0&0&1&0&1&1&0&... \\ 1&0&0&1&0&1&1&0&... \\  0&1&1&0&1&0&0&1&... \\ .. \end{matrix} \right\} $ 

观察矩阵，根据定义，我们发现，对于矩阵的每一行，如果其第一个数是 $0$ ，则其和第一行相等，如果其第一个数是 $1$ ，则其和第一行相反。而每一行的第一个数（即第一列）又是和第一行相同的，所以我们只用考虑第一行的规律。

我们给第一行的值对应标号（从 $0$ 开始）：

$ \begin{matrix} 0&1&2&3&4&5&6&7 \\  \\  0&1&1&0&1&0&0&1&...\end{matrix} $ 

我们发现，定义 $highbit(x)$ 为 $x$ 转为二进制位后的最高位（仅保留这一位上的 $1$ 后的值），那么第一行的标号为 $x$ 的数是由第 $x-highbit(x)$ 个数反转所得的。定义 $bitcnt(x)$ 为 $x$ 转化为二进制数后数位上 $1$ 的个数。由于 $x$ 在从 $0$ 反转的过程中每次都增加一位，所以其被反转了 $bitcnt(x)$ 次，如果 $bitcnt(x)$ 是奇数，则对应的位置被反转，否则没有被反转。

扩展到矩阵上，如果一个初始大小的矩阵在转化后矩阵上可以表示为 $(x,y)$ ，编号从 $0$ 开始，则若 $bitcnt(x)+bitcnt(y)$ 为奇数，则该矩阵被反转，否则没有被反转。判断这一问题的时间复杂度是 $O(\log_2 x)$ 。

对于没有转化的矩阵上的位置 $(x,y)$ ，我们只需求出其所在的矩阵的坐标，该坐标为 $(\lfloor \frac {x+n-1} n\rfloor,\lfloor \frac {y+m-1} m \rfloor)$ ，判断其是否被反转即可。

### 求解扩展矩阵上的子矩阵和

首先利用二维前缀和的思想，将所求答案转化成四个答案加加减减。这些所求的答案分别为左上角为 $(1,1)$ ，右下角为 $(x,y)$ 的子矩阵和，接下来我们分析如何求解这一问题。

我们求出 $(x,y)$ 这一坐标在把初始矩阵转化为一个元素后的矩阵上的坐标，记为 $(fx,fy)$ ，有 $fx=\lfloor \frac {x+n-1} n\rfloor,fy=\lfloor \frac {y+m-1} m \rfloor$ 。

我们可以将这个问题分成四个子问题求解，分别为该坐标左上的完整的矩阵，该坐标上方的覆盖完一条边的矩阵，该坐标左边的覆盖完一条边的矩阵，和该坐标所在的初始矩阵大小的矩阵。分别对应下图中的红色，黄色，蓝色，绿色部分。

![](https://cdn.luogu.com.cn/upload/pic/61775.png)

由于之前的出的是否反转判定法则，我们可以将横坐标或纵坐标相同，另一坐标化为二进制后只有最后一位不同的两个矩阵两两配对，这两个矩阵一定为一个正的一个反转，它们对应位置的和总是等于 $1$ 。

将一部分矩阵两两配对后，可能由于 $x,y$ 的奇偶性不同分类讨论，此时暴力计算剩下的一个矩阵的值即可。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1010;
typedef long long ll;
ll n,m,q,a[maxn][maxn],s[maxn][maxn],xa,ya,xb,yb;
char ch;
ll bitcnt(ll x){ll ret=0;while(x){if(x&1)ret++;x>>=1;}return ret;}
bool rev(ll x,ll y){x--;y--;return (bitcnt(x)+bitcnt(y))&1;}
ll sum(ll x,ll y)
{
	if(x==0||y==0)return 0;
	ll ret=0,fx=(x+n-1)/n,fy=(y+m-1)/m;
	ret+=(fx-1)*(fy-1)/2*n*m;
	if(fx%2==0&&fy%2==0)
	{
		if(rev(fx-1,fy-1))ret+=n*m-s[n][m];
		else ret+=s[n][m];
	}
	ret+=(fx-1)/2*n*(y-(fy-1)*m);
	if(fx%2==0)
	{
		if(rev(fx-1,fy))ret+=n*(y-(fy-1)*m)-s[n][y-(fy-1)*m];
		else ret+=s[n][y-(fy-1)*m];
	}
	ret+=(fy-1)/2*(x-(fx-1)*n)*m;
	if(fy%2==0)
	{
		if(rev(fx,fy-1))ret+=(x-(fx-1)*n)*m-s[x-(fx-1)*n][m];
		else ret+=s[x-(fx-1)*n][m];
	}
	if(rev(fx,fy))ret+=(x-(fx-1)*n)*(y-(fy-1)*m)-s[x-(fx-1)*n][y-(fy-1)*m];
	else ret+=s[x-(fx-1)*n][y-(fy-1)*m];
	return ret;
}
int main()
{
	scanf("%lld%lld%lld",&n,&m,&q);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf(" %c",&ch),a[i][j]=ch-'0';
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
	s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
	while(q--)
	{
		scanf("%lld%lld%lld%lld",&xa,&ya,&xb,&yb);
		printf("%lld\n",sum(xa-1,ya-1)+sum(xb,yb)-sum(xa-1,yb)-sum(xb,ya-1));
	}
	return 0;
}
```

---

## 作者：是青白呀 (赞：0)

首先有一个重要的观察：对于初始矩阵恰好变换 $1$ 次得到的矩阵，其大小为 $2n\times 2m$，其每行上 $1$ 的个数均为 $m$，每列上 $1$ 的个数均为 $n$，因此无论经过了几次翻转，其每行每列的 $1$ 的个数均不会变化，总的 $1$ 的个数也不会发生变化。于是我们将这样的 $2n\times 2m$ 的矩阵作为初始矩阵进行考虑。下文中的“初始矩阵”都指的是这种 $2n\times 2m$ 的矩阵。

我们可以找到若干多个排成矩形的初始矩阵，使得这个大矩形恰好将询问矩阵包裹。这里不拆分询问矩阵的原因是，初始矩阵的分割线可能以很多种不同的方式穿过询问矩阵，我们希望避免这样的分类讨论。

如下图所示，$4\times 2$ 的、用黑线包裹起来的矩形即为初始矩阵，蓝色的部分为询问矩阵。定位到这个最大的矩形后，我们首先可以算出最大的矩形内部的 $1$ 的个数，为总格子数的一半。接下来考虑容斥，先减去四个方向上超过边界的长条形部分（即绿色和橙色部分），再加回四个角上被减重的部分（即橙色部分）。

![](https://cdn.luogu.com.cn/upload/image_hosting/uz74rgtn.png)

首先，不妨对初始矩阵做二维前缀和，以便 $O(1)$ 求得某个子矩形内的 $1$ 的个数。

对于要减去的绿色和橙色部分，我们发现它是由若干多个整行或整列组成的，因此每个小块的翻转次数对这个部分的 $1$ 的总数不产生影响。所以我们可以直接求出每个部分由多少个初始矩阵的子矩形组成，再求出一个子矩形内的 $1$ 的数量即可。

对于要加上的橙色部分，我们发现它所在的初始矩阵的翻转次数对 $1$ 的个数是有影响的。考虑计算一个初始矩阵的翻转次数。假设最开始的那个矩阵在左上角，每次翻转得到的结果会接在原始矩阵的右侧和下方，此时大矩阵的规模翻倍。我们从左上角开始，给每个矩阵一个坐标，最开始的那个矩阵坐标为 $(0,0)$。若对两维坐标单独考虑，我们发现每次翻转后得到的新的那个部分中，每个初始矩阵的坐标实际上是翻转前对应位置的坐标在二进制高位添加一个 $1$ 而得到的。因此，一个坐标为 $(x,y)$ 的初始矩阵的翻转次数为 $x$、$y$ 二进制位上 $1$ 的个数的总和。于是对于每个橙色部分，我们先找到它对应的初始矩阵的坐标，再通过二维前缀和求得其中的 $1$ 的个数即可。

对于每个询问，我们均可以 $O(\log V)$ 处理，瓶颈在求二进制位上 $1$ 的数量。故总复杂度 $O(nm+q\log V)$。

---

## 作者：daniEl_lElE (赞：0)

考虑将询问差分，变成前缀矩阵求和。

将其分成 $4$ 个部分，左上整块（包含完整的 $n\times m$），以及由两条边界线分割成的另外三部分。

左上整块如果包含偶数个块，显然 $1$ 数量是 $n\times m\times\frac{rx\times ry}{2}$。

如果包含奇数块，那么其中右下块的 $1$ 数量与 $\operatorname{popcount}((rx-1)\oplus(ry-1))\operatorname{and} 1$ 有关。

另外三个部分也可以按类似分类讨论做（即，偶数一定是两块可以组成一个完整的 $1$ 矩阵，奇数按所在矩形的 $\operatorname{popcount}((rx-1)\oplus(ry-1))\operatorname{and} 1$ 分类）。

总复杂度 $O(nm+q)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define lowbit(i) (i&(-i))
using namespace std;
int a[1005][1005],n,m,q;
int qry(int x,int y){
	if(x==0||y==0){
		return 0;
	}
	int ans=0;
	int rx=(x-1)/n,ry=(y-1)/m,lx=x-rx*n,ly=y-ry*m;
	{
		//big block
		ans+=(n*m)*(rx*ry/2);
		if(rx&ry&1){
			if(__builtin_popcount((rx-1)^(ry-1))&1) ans+=n*m-a[n][m];
			else ans+=a[n][m];
		}
	}
	{
		//down
		ans+=(lx*m)*(ry/2);
		if(ry&1){
			if(__builtin_popcount(rx^(ry-1))&1) ans+=lx*m-a[lx][m];
			else ans+=a[lx][m];
		}
	}
	{
		//right
		ans+=(n*ly)*(rx/2);
		if(rx&1){
			if(__builtin_popcount((rx-1)^ry)&1) ans+=n*ly-a[n][ly];
			else ans+=a[n][ly];
		}
	}
	{
		//
		if(__builtin_popcount(rx^ry)&1) ans+=lx*ly-a[lx][ly];
		else ans+=a[lx][ly];
	}
	return ans;
}
signed main(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++){
		string s; cin>>s; s=" "+s;
		for(int j=1;j<=m;j++){
			a[i][j]=s[j]-'0';
			a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
		}
	}
//	for(int i=1;i<=n*3;i++,cout<<"\n"){
//		for(int j=1;j<=m*3;j++){
//			cout<<qry(i,j)-qry(i-1,j)-qry(i,j-1)+qry(i-1,j-1);
//		}
//	}
	while(q--){
		int xl,yl,xr,yr; cin>>xl>>yl>>xr>>yr;
		cout<<qry(xr,yr)-qry(xl-1,yr)-qry(xr,yl-1)+qry(xl-1,yl-1)<<"\n";
	}
	return 0;
}
```

---


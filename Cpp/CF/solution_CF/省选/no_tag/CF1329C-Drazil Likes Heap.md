# Drazil Likes Heap

## 题目描述

Drazil 非常喜欢堆这个数据结构。因此他造了一段关于堆的题目：

有一个高度为 $h$ 的大根堆存储在数组内。具体情况如下：

这个堆中有恰好 $2 ^ h - 1$ 个正整数，这些正整数两两不同。这些数存储在数组 $a$ 内下标 $1$ 到 $2 ^ h - 1$ 的位置。对于任意的 $1 \lt i \lt 2 ^ h$，都有 $a[i] \lt a\left[ \left\lfloor \frac{i}{2} \right\rfloor \right]$。

现在我们想要减小这个堆的高度到 $g$，使得堆中恰好只有 $2 ^ g - 1$ 个数。为了减小高度，我们需要进行下述操作 $2 ^ h - 2 ^ g$ 次：

选择一个包含有一个元素的下标 $i$，然后用 $i$ 调用函数 $f$，函数 $f$ 定义如下：

![](https://espresso.codeforces.com/d748546cbc8f1d0d4241d4bdbee9e783c3c48411.png)

注意如果 $a[i] = 0$，那我们认为下标 $i$ 不包含一个元素。

在所有操作后，剩下的 $2 ^ g - 1$ 个元素需要位于下标在 $1$ 到 $2 ^ g - 1$ 中的位置。现在 Drazil 想要知道，剩下的 $2 ^ g - 1$ 个数之和最小可能是多少。请计算这个最小的和，并找到一个能够达到最小值的操作序列。

## 样例 #1

### 输入

```
2
3 2
7 6 3 5 4 2 1
3 2
7 6 5 4 3 2 1```

### 输出

```
10
3 2 3 1
8
2 1 3 1```

# 题解

## 作者：ix35 (赞：4)

题目里说的这个操作的本质就是：删除一个结点，并依然维持这个二叉堆。

注意到每次删除一个结点 $a$，一定会“空出”一个叶结点的位置，我们可以维护这个位置 $pos_a$。

如果 $pos_a$ 的深度大于 $g$，那么我们可以删除这个结点 $a$（不会打破深度限制），否则就不能删除。

有若干个可以删的结点时，按照贪心原则，我们删最大的，而依照二叉堆的原则，我们只需要按照下标从小到大考虑，即可保证每次删的都是可以删的最大的值。

这题应该比 1A 要简单些，1A 的构造太难了。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2100010;
int t,g,h,tot,bac[MAXN],a[MAXN],dep[MAXN],mx[MAXN];
ll ans;
void upd (int x) {
	if (!a[x<<1]) {
		if (!a[(x<<1)+1]) {mx[x]=x;}
		else {mx[x]=mx[(x<<1)+1];}
	} else {
		if (!a[(x<<1)+1]) {mx[x]=mx[x<<1];}
		else {mx[x]=(a[x<<1]>a[(x<<1)+1]?mx[x<<1]:mx[(x<<1)+1]);}
	}
	return;
}
void pop (int x) {
	if (!a[x<<1]) {
		if (!a[(x<<1)+1]) {a[x]=0;}
		else {
			a[x]=a[(x<<1)+1];
			pop((x<<1)+1);
		}
	} else {
		if (!a[(x<<1)+1]) {
			a[x]=a[x<<1];
			pop(x<<1);
		}
		else {
			if (a[x<<1]>a[(x<<1)+1]) {
				a[x]=a[x<<1];
				pop(x<<1);
			} else {
				a[x]=a[(x<<1)+1];
				pop((x<<1)+1);
			}
		}
	}
	upd(x);
	return;
}
int main () {
	scanf("%d",&t);
	for (int ii=1;ii<=t;ii++) {
		scanf("%d%d",&h,&g);
		ans=0;
		for (int i=1;i<=(1<<h)-1;i++) {
			scanf("%d",&a[i]);
			dep[i]=dep[i/2]+1;
			ans+=a[i];
		}
		for (int i=(1<<h);i<=(1<<(h+1));i++) {a[i]=0;}
		for (int i=(1<<h)-1;i>=1;i--) {upd(i);}
		tot=0;
		for (int i=1;i<=(1<<h);i++) {
			while (a[i]&&dep[mx[i]]>g) {
				bac[++tot]=i;
				ans-=a[i];
				pop(i);
			}
		}
		printf("%lld\n",ans);
		for (int i=1;i<=tot;i++) {printf("%d ",bac[i]);}
		printf("\n");
	} 
	return 0;
}
```


---

## 作者：ZM____ML (赞：0)

## 题意分析

>给你一个**二叉大根堆**，可以删除任意一个节点，维持二叉堆形态不变，并进行 $2^h-2^g$ 次操作，并在操作后产生当前点点权的代价，使得该二叉堆变为一个高为 $g$ 的满二叉树。求最后操作完毕后代价最大值。

## 思路

对于每一次删除当前节点，经过儿子不断向上补位，最后肯定会在其子树中某一个叶子节点处产生空缺。

所以我们在删除的时候考虑贪心，要使得最后操作完毕后代价最大，我们就每次贪心的考虑删除当前所在堆的根，维护删除它之后在叶子节点产生空缺的位置，判断空缺位置的深度，如果这个点的深度大于 $g$，则可以删除，否则就不能删除，向左右两个儿子递归。

我们考虑贪心的正确性，因为每次删除掉当前的堆顶之后，一定会有左右其中一条到叶子节点路径的节点都向上补位一个。

假设向上补位的是右子树中的一条路径：

- 对于左子树来说，这次删除对左子树没有影响。

- 对于右子树来说，如果这次删除不选择删除当前堆顶，而选择删除右子树的堆顶，这一条路径的变化还是相同，而产生的代价却没有删除当前堆顶的代价大，所以每一次都考虑删除当前堆顶。

如果向上补位的是左子树的一条路径也同理。

---


# October 18, 2017

## 题目描述

It was October 18, 2017. Shohag, a melancholic soul, made a strong determination that he will pursue Competitive Programming seriously, by heart, because he found it fascinating. Fast forward to 4 years, he is happy that he took this road. He is now creating a contest on Codeforces. He found an astounding problem but has no idea how to solve this. Help him to solve the final problem of the round.

You are given three integers $ n $ , $ k $ and $ x $ . Find the number, modulo $ 998\,244\,353 $ , of integer sequences $ a_1, a_2, \ldots, a_n $ such that the following conditions are satisfied:

- $ 0 \le a_i \lt 2^k $ for each integer $ i $ from $ 1 $ to $ n $ .
- There is no non-empty subsequence in $ a $ such that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of the elements of the subsequence is $ x $ .

A sequence $ b $ is a subsequence of a sequence $ c $ if $ b $ can be obtained from $ c $ by deletion of several (possibly, zero or all) elements.

## 说明/提示

In the first test case, the valid sequences are $ [1, 2] $ , $ [1, 3] $ , $ [2, 1] $ , $ [2, 3] $ , $ [3, 1] $ and $ [3, 2] $ .

In the second test case, the only valid sequence is $ [0, 0] $ .

## 样例 #1

### 输入

```
6
2 2 0
2 1 1
3 2 3
69 69 69
2017 10 18
5 7 0```

### 输出

```
6
1
15
699496932
892852568
713939942```

# 题解

## 作者：juju527 (赞：14)

zxy 好强/se/se。

### $\texttt{Solution}$
首先将问题分成 $x=0$ 与 $x\neq 0$ 两部分。

对于前者，问题为选择一组 $n$ 个线性无关的向量的方案数。

这是一个经典问题，方案数为 $\prod_{i=1}^{n}(2^k-2^{i-1})$。

显然，$n>k$ 时答案为 $0$，容易在 $O(k)$ 内计算答案。

对于 $x\neq 0$ 的问题，我们容易发现对于任意 $x$ 方案数一致。

我们不妨认为 $x=1$ 以方便问题。

我们考虑将每个数看成一个 $k$ 维的向量，并将 $1$ 放在第一行形成一个 $(n+1)\times k$ 的矩阵。

设 $f_{i,r}$ 表示考虑完前 $i$ 行，秩为 $r$ 的方案数。

$f_{i,r}=f_{i-1,r}\times 2^{r-1}+f_{i-1,r-1}\times (2^k-2^{r-1})$

第一个转移表示秩不变，又第 $i$ 个行向量的选择不能被第一个向量表示，故系数为 $2^{r-1}$。

那么答案即为 $\sum_{r}f_{n+1,r}$。

我们得到了一个 $O(nk)$ 的做法，考虑优化它。

记 $F_{r}(z)=\sum_{i=0}f_{i,r}z^i$。

考虑将所有秩不变的 dp 转移一次计算。

即 $F_r(z)=F_{r-1}(z)(2^k-2^{r-1})z\sum_{i=0}(2^{r-1}z)^i$。

进行一定的化简可以得到。

$F_r(z)=\frac 1 {2^k-1}z^r\prod_{i=1}^r(2^k-2^{i-1})\prod_{i=1}^r\frac 1 {1-2^{i-1}z}$

我们的答案为 $\sum_{r=1}^k[z^{n+1}]F_r(z)$。

考虑计算 $G_r(z)=\prod_{i=1}^r\frac 1 {1-2^{i-1}z}$。

考虑 $G_r(2z)$ 与 $G_r(z)$ 的关系，

得到 $(1-2^rz)G_r(2z)=(1-z)G_r(z)$。

记 $g_i=[z^i]G_r(z)$。

易得 $g_n=\prod_{i=1}^n\frac{2^{i+r-1}-1}{2^i-1}$。

故 $[z^{n+1}]F_r(z)=\frac 1 {2^k-1}\prod_{i=1}^r(2^k-2^{i-1})\prod_{i=1}^{n+1-r}\frac{2^{i+r-1}-1}{2^i-1}$。

化简到这一步问题就已经基本解决了。

考虑 $r$ 从小到大扫，转移时改变很小，容易做到 $O(k+\log n)$。

[code](https://www.luogu.com.cn/paste/jygvfi8n)

---

## 作者：foreverlasting (赞：8)

题面：给出 $n,k,x$，问所有数小于 $2^k$ 满足任意一个子集的异或和不等于 $x$ 的 $n$ 元组的个数。

做法：题意等价于 $\mathbb{F}_2^k$ 中有多少个 $n$ 元向量组构成的空间里不包含 $x$。

注意到原序列有序。

容易想到讨论 $x$ 是否为 $0$，因为 $x$ 不为 $0$ 时则是向量空间了。

$x=0$ 时等价于 $n$ 元向量线性无关，于是一个个选过来，方案数就是 $\prod_{i=1}^n (2^k-2^{i-1})$。

若 $x$ 不为 $0$ 时，$n$ 元向量组就构成了一个向量空间，考虑维度为 $r$ 的不包含 $x$ 的向量空间基底数量，于是就类同上面的是 

$\prod_{i=1}^r (2^k-2^{i-1})-(2^r-1)\prod_{i=2}^{r} (2^k-2^{i-1})$

$=\prod_{i=1}^{r-1} (2^k-2^i)(2^k-2^r)=\prod_{i=1}^r (2^k-2^i)$

减去一个数是考虑基底不包含 $x$，即让 $x$ 作为第一维后的基底方案数。剩下来的 $n-r$ 个向量考虑被基底的前 $i$ 个向量线性表出，且考虑有几个。于是方案数就是 
$[t^{n-r}]\prod_{i=0}^r (1+2^it+2^{2i}t^2+...)$

$=[t^{n-r}]\prod_{i=0}^r \frac{1}{1-2^it}$

而熟知 $\mathrm{q-binomial}$ 的老哥会一眼看出这个东西是 $\mathrm{q-binomial}$ 的生成函数，所以直接就有 
$$
[t^{n-r}]\prod_{i=0}^r \frac{1}{1-2^it}=\binom{n}{n-r}_2
$$
于是答案就是 
$$
\sum_{r=0}^n \prod_{i=1}^r (2^k-2^i)\binom{n}{n-r}_2
$$
这东西全部可以预处理出来，就做完了。即
$$
\binom{n}{n-r}_2=\frac{[n]_2!}{[r]_2![n-r]_2!}
$$
其中 $[n]_2!=\prod_{i=1}^n (2^i-1)$。由于 $n$ 比较大，这里需要倒着乘回来。

而证明 $\mathrm{q-binomial}$ 生成函数的方式比较多，简单地就直接观察 $[t^{i}]$ 和 $[t^{i+1}]$ 间的递推关系可以得出。或者直接得到其 $\mathrm{GF}$ 的递推式，即设

$F(t)=\prod_{i=0}^r \frac{1}{1-q^it}$

$\implies (1-t)F(t)=(1-q^{r+1}t)F(qt)$

再两边同取 $[t^n]$ 也就能得到递推式了。

时间复杂度 $O(n)$。

{% fold code %}

```cpp
//2021.12.5 by ljz
//email 573902690@qq.com
//if you find any bug in my code
//please tell me
const int N=1e7+10;
int pw[N],fac[N],inv[N],INV[N];
namespace MAIN{
    int n,k,x;
    int f[N];
    inline void MAIN(){
        n=read(),k=read(),x=read();
        if(!x){
            if(n>k){puts("0");return;}
            res ret=1;
            for(res i=0;i<n;i++)ret=mul(ret,Add(pw[k],kcz-pw[i]));
            printf("%d\n",ret);
            return;
        }
        f[0]=1;
        res p=min(n,k),PW=qpow(2,n),inv2=qpow(2);
        for(res i=1;i<=p;i++)f[i]=mul(f[i-1],mul(Add(PW,kcz-1),INV[i])),PW=mul(PW,inv2);
        res A=1,ans=1;
        for(res r=1;r<=p;r++)A=mul(A,Add(pw[k],kcz-pw[r])),add(ans,mul(A,f[r]));
        printf("%d\n",ans);
    }
}
```

{% endfold %}

---

## 作者：joke3579 (赞：4)

转化题意，序列的每个元素等价于 $\mathbb F_2^k$ 内的一个向量。因此我们需要选出 $\mathbb F_2^k$ 内的 $n$ 个向量，满足他们构成的空间内不存在向量 $x$，求选择方案。  
分情况讨论：

## $x=0$

问题转为选出 $\mathbb F_2^k$ 内 $n$ 个线性无关的向量。
这是个经典问题，又可以转化成选出一个满秩的 $n\times k \ 01$ 矩阵的方案数。
答案即为
$$\prod_{i=0}^{n-1} (p^k - p^i)$$
证明可以看[这个](https://www.cnblogs.com/joke3579/p/editorial221004.html)的后半部分，这里从略。

可以 $O(k)$ 地计算答案。

## $x > k$

容易发现在 $\mathbb F_2^k$ 内任意向量等价。因此任意 $x > k$ 的答案相同。不妨令 $x = 1$。我们令选出的 $n$ 个向量与 $1$ 构成一个 $(n+1) \times k$ 矩阵。

----

先不考虑dp。直接按组合意义容斥可得答案。
我们考虑不包含 $x$ 的维度为 $d$ 的向量空间的基底数量，同上可以得到计算式
$$\prod_{i=0}^{d-1}(2^k - 2^i) - (2^d-1)\prod_{i=1}^{d-1}(2^k - 2^i) = \prod_{i=1}^d(2^k-2^i)$$

然后考虑剩下的 $n-d$ 个向量，他们应当被基底表出。考虑第 $i$ 个向量能表出的向量可以表为 $(1 + 2^i x + 2^{2i} x^2 + \cdots)$，于是立得答案为
$$\left[x^{n-d}\right]\prod_{i=0}^d (1 + 2^i x + 2^{2i} x^2 + \cdots) = \left[x^{n-d\ }\right]\prod_{i=0}^d \frac{1}{1 - 2^ix}$$

如果你熟悉 $\text{q-binomial}$，那这玩意就等于是 $q=2$ 的情况。

记 
$$[n]_q = \sum_{i=0}^{n-1} q^i,\ [n]!_q = \prod_{i=0}^n [i]_q,\ \binom n m_q = \frac{[n]!_q}{[m]!_q[n-m]!_q} $$

立得
$$ \left[x^{n-d\ }\right]\prod_{i=0}^d \frac{1}{1 - 2^ix} = {\binom n{n-d}}_ 2 = \frac { [n]_ 2! } { [n-d]_ 2 ! [d]_ 2!} = \frac{ \prod_{i=1}^n (2^i-1) }{  \prod_{i=1}^d (2^i-1)  \prod_{i=1}^{n-d} (2^i-1) }$$

答案即为
$$\sum_{d=0}^n \prod_{i=1}^d(2^k-2^i) \times {\binom n{n-d}}_ 2$$

如果你不熟悉 $\text{q-binomial}$~~，那就去熟悉~~   
我们考虑表出 $F(x) = \left[x^{n-d\ }\right]\prod_{i=0}^n \frac{1}{1 - q^ix}$。用两种方式消掉 $i=0$ 的项得到
$$(1-x)F(x) = (1-q^{n+1}x) F(qx)$$
两边取 $[x^n]$，经过简单移项可得递推关系式。

----

然后考虑dp，设 $f_{i,r}$ 为选了 $i$ 个向量，当前矩阵的秩为 $r$ 的方案数。我们考虑新加入的向量是否能被先前除 1 外的向量表出，立即有方程
$$f_{i,r} = f_{i-1,r} \times 2^{r-1} + f_{i-1,r-1} \times (2^k - 2^{r-1})$$
得到了 $O(nk)$ 的做法。

考虑按第一维求和得到 $F_r$：
$$F_r(x) = \sum_{i=0} f_{i,r}x^i$$
带入 $f_{i,r}$ 递推式立得 $F_r$ 递推式：
$$F_r(x) = \frac{(2^k - 2^{r-1})x}{1 - 2^{r-1}x} F_{r-1}(x) = \prod_{i=1}^r \frac{(2^k - 2^{i-1})x}{1 - 2^{i-1}x} =\frac{1}{2^k-1} \prod_{i=1}^r(2^k - 2^{i-1})x^r \prod_{i=1}^r \frac{1}{1 - 2^{i-1}x}$$
答案即为
$$\sum_{r=1}^k[x^{n+1}]F_{r}(x)$$
考虑记 
$$G_r(x) = \prod_{i=1}^r \frac{1}{1 - 2^{i-1}x}$$
~~容易发现这是 q~~  
我们承接上面消最低次项的思路得到 $(1-x)F(x) = (1-2^{n+1}x) F(2x)$，于是提取系数得 $[x^n]F_r(x) = \prod_{i=1}^n\frac{2^{n-i+1} - 1}{2^i-1}$   
于是这玩意就是一个 $\text{q-binomial}$，总贡献得到
$$\frac{1}{2^k-1} \prod_{i=1}^r(2^k - 2^{i-1})x^r \prod_{i=1}^{n+i-r} \frac{2^{n-i+1} - 1}{2^i-1} $$
转化形式求和得到

$$\sum_{r=0}^n\prod_{i=1}^r(2^k-2^i) \times {\binom n{n-r}}_2$$

 
可以发现这两种方式得到的答案是相同的。

直接模拟计算即可。预处理后单次计算答案复杂度 $O(k)$。

$\text{code :}$


```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for (register int (i) = (a); (i) <= (b); ++(i))
#define pre(i,a,b) for (register int (i) = (a); (i) >= (b); --(i))
using namespace std;
const int N = 1e7 + 10, K = 1<<15, mod = 998244353, inv2 = 499122177;
int T, n, k, x, pw[N], upw[K + 10], fac[N], ifac[N];

typedef long long ll; typedef __int128 lll;
struct FastMod { int m; ll b; void init(int _m) { m = _m; b = ((lll)1<<64) / m; } int operator() (ll a) {ll q = ((lll)a * b) >> 64; a -= q * m; if (a >= m) a -= m; return a; } } Mod;
int add(int a, int b) { return (a += b) >= mod ? a - mod : a; } int mul(int a, int b) { return Mod(1ll * a * b); } template <typename ...Args> int mul(int a, Args ...b) { return mul(a, mul(b...)); }

int qp(int a, int b) {
    int ret = 1;
    while (b) {
        if (b & 1) ret = mul(ret, a);
        a = mul(a, a);
        b >>= 1;
    } return ret;
}

void init(int n = N - 10) {
    Mod.init(mod);
    pw[0] = upw[0] = fac[0] = ifac[0] = 1;
    rep(i,1,n) pw[i] = add(pw[i-1], pw[i-1]);
    upw[1] = pw[K];
    rep(i,2,K) upw[i] = mul(upw[i-1], upw[1]);
    rep(i,1,n) fac[i] = mul(fac[i-1], mod + 1 - pw[i]);
    ifac[n] = qp(fac[n], mod - 2);
    pre(i,n-1,1) ifac[i] = mul(ifac[i+1], mod + 1 - pw[i+1]);
}

int qw(int x) {return mul(upw[x >> 15], pw[x & 32767]);}
int C(int n, int m) {
    if (m < 0 or n < m) return 0;
    return mul(fac[n], ifac[m], ifac[n-m]);
}

int solve() {
    if (x == 0) {
        int ret = 1, tmp = min(n-1, k); 
        if (n > k) return 0;
        rep(i,0,n-1) ret = mul(ret, add(pw[k], mod - pw[i]));
        return ret;
    } else {
        int tmp = 1, ans = 0, c = qw(n);
        rep(i,0,k-1) {
            tmp = mul(tmp, add(c, mod - pw[i]));
            ans = add(ans, mul(tmp, C(k-1, i)));
        } ans = add(qw(1ll * n * k % (mod - 1)), mod - ans);
        return ans;
    }
}

signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> T; 
    init();
    while (T--) {
        cin >> n >> k >> x;
        cout << solve() << '\n';
    }
}
```

---

## 作者：analysis (赞：3)

考察异或空间（线性空间），容易想到讨论序列的秩。进一步发现要先讨论 $x = 0$ 的情况（任何一个秩都可以表出 $0$）。

### $x = 0$

即整个序列是线性无关的，即秩的大小为 $N$。

如何求出秩为 $N$ 的序列个数呢。

显然秩内元素线性无关，于是当秩内已经有 $i$ 个数时可插入的数的个数为：$2^k-2^i$。

故答案为

$$
\prod_{i=0}^{N-1}(2^k-2^i)
$$

$O(k)$ 计算即可。

### $x \neq 0$

枚举秩的大小 $r$。

假设秩为 $\{x_1,x_2,\cdots,x_r\}$，显然题目要求可以转化为 $\{x_1,x_2,\cdots,x_r\}$ 不能线性表出 $X$，即 $\{x_1,x_2,\cdots,x_r，X\}$ 线性无关。

方案数即为：

$$
\prod_{i=1}^{r}(2^k-2^i)
$$

考虑还剩下 $N - r$ 个数，我们可以使用生成函数处理。

假设数插在秩中前 $i$ 个数后，他的方案数的生成函数即为：

$$
\frac{1}{1-2^ix}
$$

于是剩下 $N - r$ 个数的答案即为：

$$
\prod_{i=0}^{r}\frac{1}{1-2^ix}
$$

就是 2-组合数。

于是答案为：

$$
\sum_{i=1}^{n}\begin{bmatrix}n\\n-r\end{bmatrix}_2\prod_{i=1}^{r}(2^k-2^i)
$$

显然可以 $O(k)$。

```cpp
#include<bits/stdc++.h>
#define int long long
const int mod = 998244353,ix=1e7,inv2 = 499122177;
using namespace std;
int pw[10000005],ifac[10000005];
inline int fpow(int a,int b=mod-2)
{
    int r = 1;
    while(b)
    {
        if(b & 1)r = r * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return r % mod;
}
inline void init()
{
    pw[0] = ifac[0] = 1;
    for(int i=1;i<=ix;i++)pw[i] = pw[i-1] * 2 % mod,ifac[i]=ifac[i-1] * fpow(pw[i]-1) % mod;
}
void sol()
{
    int n,k,x,ans=1;
    cin >> n >> k >> x;
    if(x == 0)
    {
        for(int i=0;i<=min(n-1,k);i++)
        {
            ans = ans * (pw[k] - pw[i] + mod) % mod;
        }
        cout<<ans<<'\n';
    }
    else
    {
        int f = 1,qq = fpow(2,n);
        for(int r=1;r<=min(n,k);r++)
        {
            f = f * (pw[k] - pw[r] + mod) % mod;
            f = f * (qq-1) % mod;
            qq = qq * inv2 % mod;
            ans = (ans + f * ifac[r] % mod) % mod;
        }
        cout<<ans<<'\n';
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    init();
    int T;
    cin >> T;
    while(T--)sol();
    return 0;
}
```

---

## 作者：Union_of_Britain (赞：1)



题意即求 $\mathbb{F}^k_2$ （在模 $2$ 意义下的 $n$ 维整数空间）中不能线性表出 $\bf x$ 的大小为 $n$ 的向量组个数。

记 $\mathbb{F}_q^n$ 中大小为 $k$ 的线性无关向量组个数（$q$ 为质数）有 $((n)_k)_q$ 个 ，那么：第一次可以选 $q^n-1$（不能选 $\bf{0}$），第二次 $q^n-q$（第一个会 ban 掉 $q$ 个），如此下去。

$$
((n)_k)_q=q^{\binom k 2}\prod_{i=n-k+1}^n (q^i-1)=\frac{(q-1)^kq^{\binom k 2}[n]_q!}{[n-k]_q!}
$$

有了这个结论，就可以开始做了。

若 $\bf {x=0}$，那么答案就是 $((k)_n)_2$ 。

否则枚举向量组的极大线性无关组大小 $r$（可以证明这是 $\le k$ 的定值），问题转化为强制选 $\bf x$ 的方案数。

显然，每个非 $\bf 0$ 向量是本质相同的。这个的方案数就是 $\dfrac{((k)_{r+1})_2}{2^k-1}$。

还有 $n-r$ 个作为被线性表出的向量。

考虑一开始会表出 $1$ 个向量，第一个向量会使得 $2$ 个向量被标出，第二个会有 $4$ 个向量被表出……

一共就是 $[x^{n-r}](1+x+x^2+\dots)(1+2x+4x^2)\dots$

就是 
$$
[x^{n-r}]\left(\frac{1}{1-x}\right)^{(r;2)}=\binom n r_2
$$

对于所有 $r$，$O(k)$ 是可以解决的。

使用光速幂。略微卡常。

```cpp
// Problem: October 18, 2017
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/CF1603F
// Memory Limit: 500 MB
// Time Limit: 4000 ms
// UOB Koala
// 
// Powered by CP Editor (https://cpeditor.org)
#pragma GCC optimize("fast-math","unroll-loops","no-stack-protector")
#pragma GCC diagnostic error "-funsafe-loop-optimizations"
#pragma GCC diagnostic error "-fcse-skip-blocks"
#pragma GCC diagnostic error "-fwhole-program"
#pragma GCC diagnostic error "-std=c++14"
#pragma GCC target("sse3","sse2","sse")
#pragma GCC optimize("Ofast")
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e7+5,mod=998244353,B=40000,N=1e7;
int qp(int a,int b){
	if(b==0)return 1;
	int T=qp(a,b>>1);T=1ll*T*T%mod;
	if(b&1)return 1ll*T*a%mod;
	return T;
}
#define ll long long
int a[B+5],b[B+5];
int Pow(ll x){
	x%=(mod-1);
	return 1ll*a[x%B]*b[x/B]%mod;
}
int upw[maxn],fac[maxn],ifac[maxn];
int q2(ll n){
	return Pow(n)-1;
}
int C(int n,int k){
	if(k>n-k)k=n-k;
	return 1ll*upw[k]*ifac[k]%mod;
}
int n,k,x,T;
int ask(int n,int k){
	if(k>n)return 0;
	return 1ll*Pow(1ll*k*(k-1)/2)*fac[n]%mod*ifac[n-k]%mod;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	a[0]=1;
	for(int i=1;i<=B;i++)a[i]=1ll*a[i-1]*2%mod;
	b[0]=1;
	for(int i=1;i<=B;i++)b[i]=1ll*b[i-1]*a[B]%mod;
	fac[0]=1;
	for(int i=1;i<=N;i++)fac[i]=1ll*fac[i-1]*q2(i)%mod;
	ifac[N]=qp(fac[N],mod-2);
	for(int i=N-1;i>=0;i--)ifac[i]=1ll*ifac[i+1]*q2(i+1)%mod;
	cin>>T;
	while(T--){
		cin>>n>>k>>x;
		if(x==0){
			cout<<ask(k,n)<<"\n";
		}else{
			upw[0]=1;
			n++;
			for(int i=1;i<=min(n,k);i++)upw[i]=1ll*upw[i-1]*q2(n-i)%mod;
			int ans=0;int A=qp(q2(k),mod-2);
			for(int i=0;i<min(n,k);i++){
				(ans+=1ll*ask(k,i+1)*C(n-1,i)%mod)%=mod;
			}
			ans=1ll*ans*A%mod;
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```



---


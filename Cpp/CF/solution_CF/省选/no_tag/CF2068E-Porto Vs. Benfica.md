# Porto Vs. Benfica

## 题目描述

FC Porto 和 SL Benfica 是葡萄牙最大的两个足球俱乐部。当两队比赛时，大量球迷会从全国各地前往观赛，其中包括计划从里斯本前往波尔图的 Benfica 球迷俱乐部。为避免与 Porto 球迷俱乐部发生冲突，警方希望尽可能延迟他们的到达时间。

葡萄牙的公路网可建模为一个简单、无向、无权、连通的图，包含 $n$ 个顶点和 $m$ 条边。顶点代表城镇，边代表道路。顶点 $1$ 对应里斯本（球迷的起点），顶点 $n$ 对应波尔图（球迷的目的地）。球迷俱乐部希望最小化前往波尔图所经过的道路数量。

警方始终密切追踪球迷的位置。为延迟其到达，警方可在任意时刻封锁一条道路（前提是球迷当前不在该道路上通行）。此操作只能执行一次，且被封锁的道路将永久不可用。封锁后，球迷会立即得知该信息并调整路线。同时球迷知晓警方会封锁某条道路，并据此规划路线。

假设双方均采取最优策略，求球迷从里斯本到波尔图所需经过的最少道路数量。若警方能永久阻止球迷到达波尔图，则输出 $-1$。


## 说明/提示

第一个样例的公路网结构如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2068E/def999f861a9f514d6162e0a6c2cbba3cf03b089.png)  
警方最优策略是等待球迷到达与目的地相邻的顶点（如顶点 $5$）后封锁该顶点到目的地的边。球迷最优策略是先沿上方路径（$1 \rightarrow 2$），在发现 $2$ 到 $5$ 的边被封锁后，返回 $2 \rightarrow 1$ 并沿下方路径（$1 \rightarrow 3 \rightarrow 4 \rightarrow 5$）。此时经过的道路总数为 $5$。

第二个样例的公路网结构如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2068E/421c35e6c180212636e0d89d82b77207336cea44.png)  
存在多种策略，但最优方案为：球迷沿上方路径（$1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5$），警方封锁边 $5 \rightarrow 11$，球迷绕行 $5 \rightarrow 4 \rightarrow 3 \rightarrow 6 \rightarrow 7 \rightarrow 11$。总经过道路数为 $9$。

第三个样例的公路网结构如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2068E/6dbfc670f0ac7db7e25b72ef8562134433c7ab9f.png)  
警方最优策略为：若球迷到达顶点 $2$ 则封锁边 $2 \rightarrow 3$，若到达顶点 $5$ 则封锁边 $5 \rightarrow 6$。球迷最优路径为 $1 \rightarrow 2 \rightarrow 1 \rightarrow 5 \rightarrow 6 \rightarrow 8$，总经过道路数为 $5$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5 5
1 2
1 3
2 5
3 4
4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
11 12
1 2
2 3
3 4
4 5
5 11
3 6
6 7
7 11
1 8
8 9
9 10
10 11```

### 输出

```
9```

## 样例 #3

### 输入

```
8 10
1 2
2 3
3 4
3 8
4 8
1 5
5 6
6 7
6 8
7 8```

### 输出

```
5```

# 题解

## 作者：hcywoi (赞：6)

设 $f(i)$ 表示警方可以封锁一条道路，$i\to n$ 的最短路。分两种转移，一种是警方封锁 $i$ 的邻边，一种是警方没有封锁 $i$ 的邻边，两种情况取较大值即为 $f(i)$。

对于第二种情况，设 $j$ 为 $i$ 的邻边，则 $f(i)\gets\min\{f(j)+1\}$。

设 $G(i, e)$ 表示删除边 $e$ 后 $i\to n$ 的最短路。设 $e$ 为 $i$ 的邻边，令 $g(i)=\max\{G(i,e)\}$。则对于第一种情况 $f(i)\gets g(i)$。所以设 $j$ 为 $i$ 的邻边，那么 $f(i)=\max\{g(i),\min\{f(j)+1\}\}$。假设现在求出了 $g$，那么 $f$ 可以直接用堆来求出。这部分时间复杂度为 $O(n\log n+m)$。

考虑怎么求 $g$，先将最短路树建出来，设 $p(i)$ 为 $i$ 最短树上的父亲，那么删除 $(i,p(i))$ 一定是最优的。设 $x$ 为 $i$ 子树内的点，$y$ 为 $i$ 子树外的点，$E$ 为边集，那么 $g(i)=\min_{(x,y)\in E}\{dis(x)+dis(y)+1-dis(i)\}$，其中 $dis(i)$ 表示 $i\to n$ 的最短路。

有很多种方式求 $g$，这里只讲其中一种，定义边 $(x,y)$ 的权值为 $dis(x)+dis(y)+1$，按边的权值从小到大枚举。假设当前枚举到了边 $(x,y)$，那么它能贡献到点 $i$ 当且仅当 $i$ 之前没有被更新且 $i$ 不是 $\text{LCA}(x,y)$ 的祖先（包括 $\text{LCA}(x,y)$），用并查集维护 $i$ 的第一个没有被更新的祖先即可。时间复杂度：$O(n\alpha(n))$。

---


# ...Wait for it...

## 题目描述

Barney is searching for his dream girl. He lives in NYC. NYC has $ n $ junctions numbered from $ 1 $ to $ n $ and $ n-1 $ roads connecting them. We will consider the NYC as a rooted tree with root being junction $ 1 $ . $ m $ girls live in NYC, $ i $ -th of them lives along junction $ c_{i} $ and her weight initially equals $ i $ pounds.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF696E/811501df480ddab0c2d2c1257c214c2071c7d60b.png)Barney consider a girl $ x $ to be better than a girl $ y $ if and only if: girl $ x $ has weight strictly less than girl $ y $ or girl $ x $ and girl $ y $ have equal weights and index of girl $ x $ living junction index is strictly less than girl $ y $ living junction index, i.e. $ c_{x}&lt;c_{y} $ . Thus for any two girls one of them is always better than another one.

For the next $ q $ days, one event happens each day. There are two types of events:

1. Barney goes from junction $ v $ to junction $ u $ . As a result he picks at most $ k $ best girls he still have not invited from junctions on his way and invites them to his house to test if one of them is his dream girl. If there are less than $ k $ not invited girls on his path, he invites all of them.
2. Girls living along junctions in subtree of junction $ v $ (including $ v $ itself) put on some weight. As result, their weights increase by $ k $ pounds.

Your task is for each event of first type tell Barney the indices of girls he will invite to his home in this event.

## 说明/提示

For the first sample case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF696E/9429635a5701e3aa82c76a00cfcd846aa901e2ae.png)Description of events:

1. Weights of girls in subtree of junction $ 4 $ increase by $ 3 $ . These girls have IDs: $ 1,3,5,4,7 $ .
2. Barney goes from junction $ 2 $ to $ 1 $ . Girls on his way have IDs $ 1,2,3,5,6,7 $ with weights $ 4,2,6,8,6,10 $ respectively. So, he invites girls $ 2 $ and $ 1 $ .
3. Barney goes from junction $ 4 $ to junction $ 2 $ . Girls on his way has IDs $ 3,5,7 $ with weights $ 6,8,10 $ respectively. So he invites girl $ 3 $ .
4. Weight of girls in subtree of junction $ 2 $ increase by $ 10 $ . There are no not invited girls, so nothing happens.
5. Weight of girls in subtree of junction $ 1 $ increase by $ 10 $ . These girls (all girls left) have IDs: $ 4,5,6,7 $ .
6. Barney goes from junction $ 2 $ to junction $ 4 $ . Girls on his way has IDs $ 5,7 $ with weights $ 18,20 $ respectively. So he invites girl $ 5 $ .
7. Barney goes from junction $ 2 $ to junction $ 3 $ . There is no girl on his way.
8. Weight of girls in subtree of junction $ 5 $ increase by $ 2 $ . The only girl there is girl with ID $ 4 $ .
9. Weight of girls in subtree of junction $ 4 $ increase by $ 9 $ . These girls have IDs: $ 4,6,7 $ .
10. Barney goes from junction $ 3 $ to junction $ 5 $ . Only girl on his way is girl with ID $ 4 $ .
11. Barney goes from junction $ 1 $ to junction $ 2 $ . Girls on his way has IDs $ 6,7 $ with weights $ 16,29 $ respectively.

## 样例 #1

### 输入

```
5 7 11
3 5
2 3
4 3
1 4
4 1 4 5 4 1 4
2 4 3
1 2 1 2
1 4 2 1
2 2 10
2 1 10
1 2 4 1
1 2 3 4
2 5 2
2 4 9
1 3 5 2
1 1 2 3
```

### 输出

```
2 2 1 
1 3 
1 5 
0 
1 4 
2 6 7 
```

# 题解

## 作者：xiezheyuan (赞：4)

## 简要题意

给定一个 $n$ 个点的树，共有 $m$ 个物品，第 $i$ 个物品在第 $c_i$ 个节点，权为 $i$。

有 $q$ 次询问，支持：

- `1 x y z` 输出路径 $(x,y)$ 上的前 $z$ 大的物品的编号（如果不足 $z$ 个，按顺序输出所有的），并删除它们。
- `2 x y` 将 $x$ 所在子树中的所有物品加上 $y$。


$1 \leq n,m,q \leq 10^5$

## 思路

给一个新（超）颖（级）独（难）特（调）的做法。

首先考虑如果每个点至多有一个物品，则我们可以给没有物品的点赋一个 $+\infty$ 的权。然后回答 `1` 询问时重复进行 $z$ 次，每次找路径 $(x,y)$ 的最小值（如果这个最小值为 $+\infty$，则表示已经没有物品了，终止），然后将这个点的权改成 $+\infty$。这个东西显然可以树剖维护。

由于树上物品总数单调不增，所以这个做法时间复杂度是正确的。

然后你考虑如何支持每个点有多个物品。我们只需要拆点，将每个点拆成 $x+2$ 个点（其中 $x$ 为这个点初始时的物品个数），另外 $2$ 个点为入点和出点。出入点没有物品。

先将拆出的点用一条链串起来。然后考虑原来的树边，我们希望满足父亲连向儿子时，对应出点连向入点。可以预处理出原树中每个点的深度来实现。

然后对于每一个 `1` 询问，为了将端点的物品包含进来，我们需要进行以下的操作（下面令 $x$ 的深度较大）：

- 如果 $x,y$ 在原树上是直系祖先关系。则在新树上的询问路径为 $x$ 的入点到 $y$ 的出点。具体判断方法可以使用树链剖分求树上 k 级祖先的方法，看看 $y$ 的树上深度差级祖先是不是 $x$。
- 否则新树上的询问路径为 $x$ 的出点到 $y$ 的出点。

如果这样写的话会 WA 在第 $5$ 个点。因为没有考虑一种情况，就是 $x,y$ 的 LCA 也有物品，而我们的树链剖分只会访问到 LCA 的出点，无法访问到它的物品。解决方法也很简单，我们不仅询问刚刚求出来的路径，也询问 LCA 入点到出点的路径，把两个方法求出的答案并起来。

总之这是一道大树剖好题。建议评上位紫。

## 代码

Update on 2023.12.12：修改代码后，已经通过了 [rainygame](https://www.luogu.com.cn/discuss/745242) 提供的 Hack 数据。

```cpp
#include <bits/stdc++.h>
#define int long long
#define debug(fmt,...) do{fprintf(stderr,fmt,##__VA_ARGS__);fprintf(stderr,"\n");}while(0)
#define error(expr,fmt,...) do{if((expr)){debug(fmt,##__VA_ARGS__);exit(0);}}while(0)
#define ls (i<<1)
#define rs (i<<1|1)
#define mid ((l+r)>>1)
#undef INT_MAX
#define INT_MAX 100000000100005ll
using namespace std;
 
int n,m,q;
const int N = 5e5+5;
int w[N],bs[N];
 
struct node{
    int nxt,to;
} g[N<<1];
int head[N],ec;
 
void add(int u,int v){
    // cerr<<(w[u]!=INT_MAX?w[u]:0)<<'-'<<u<<' '<<(w[v]!=INT_MAX?w[v]:0)<<'-'<<v<<'\n';
    g[++ec].nxt=head[u];
    g[ec].to=v;
    head[u]=ec;
}
 
int son[N],dep[N],father[N],top[N],seg[N],rev[N],tot,in[N],out[N],siz[N];
 
vector<int> tree[N];
vector<int> bel[N];
int depth[N];
 
void dfs(int u,int fa){
    depth[u] = depth[fa] + 1;
    for(int v : tree[u]){
        if(v==fa) continue;
        dfs(v,u);
    }
}
 
 
void dfs1(int u,int fa){
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    father[u] = fa;
    for(int i=head[u];i;i=g[i].nxt){
        int v = g[i].to;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u]=v;
    }
}
 
void dfs2(int u, int fa){
	if(son[u]){
		seg[son[u]]=++seg[0];
		top[son[u]]=top[u];
		rev[seg[0]]=son[u];
		dfs2(son[u], u);
	}
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].to;
		if(top[v])continue;
		seg[v]=++seg[0];
		rev[seg[0]]=v;
		top[v]=v;
		dfs2(v, u);
	}
}
 
pair<int,int> t[N<<2];
int tag[N<<2];
 
auto merge(pair<int,int> a,pair<int,int> b){
    if(a.first < b.first) return a;
    if(a.first > b.first) return b;
    return bs[rev[a.second]] < bs[rev[b.second]] ? a : b;
}
 
void build(int i,int l,int r){
    if(l==r){
        t[i] = {w[rev[l]], l};
        return;
    }
    build(ls,l,mid);build(rs,mid+1,r);
    t[i] = merge(t[ls],t[rs]);
}
 
void pushdown(int i){
    if(tag[i]){
        tag[ls]+=tag[i];tag[rs]+=tag[i];
        t[ls].first+=tag[i];t[rs].first+=tag[i];
        tag[i]=0;
    }
}
 
void update(int ql,int qr,int v,int i,int l,int r){
    if(ql<=l&&r<=qr){
        t[i].first += v;tag[i] += v;
        return;
    }
    pushdown(i);
    if(ql<=mid) update(ql,qr,v,ls,l,mid);
    if(qr>mid) update(ql,qr,v,rs,mid+1,r);
    t[i] = merge(t[ls], t[rs]);
}
 
auto query(int ql,int qr,int i,int l,int r){
    if(ql<=l&&r<=qr) return t[i];
    pushdown(i);
    if(ql<=mid && !(qr>mid)) return query(ql,qr,ls,l,mid);
    if(qr>mid && !(ql<=mid)) return query(ql,qr,rs,mid+1,r);
    return merge(query(ql,qr,ls,l,mid), query(ql,qr,rs,mid+1,r));
}
 
auto QueryPath(int x,int y){
	auto ans = make_pair(INT_MAX, 0);
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x, y);
		ans=merge(ans, query(seg[top[x]],seg[x],1,1,seg[0]));
		x=father[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	ans=merge(ans, query(seg[x],seg[y],1,1,seg[0]));
	return ans;
}
 
void UpdateSubtree(int x,int y){
	update(seg[x],seg[x]+siz[x]-1,y,1,1,seg[0]);
}
 
int kthFather(int x,int k){
	int expect=dep[x]-k;
	while(dep[top[x]]>expect) x=father[top[x]];
	return rev[seg[x]-(dep[x]-expect)];
}
 
int lca(int x, int y) {
	int fx = top[x], fy = top[y];
	while (fx != fy) {
		if (dep[fx] < dep[fy]){
			swap(fx, fy);
			swap(x, y);
		}
		x = father[fx], fx = top[x];
	}
	if (dep[x] > dep[y]) {
		return y;
	}
	else return x;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m>>q;
    for(int i=1;i<n;i++){
        int u,v;cin>>u>>v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    dfs(1,0);
    for(int i=1;i<=m;i++){
        int x;cin>>x;
        bel[x].push_back(i);
    }
    for(int i=1;i<=n;i++){
        in[i] = (++tot);
        w[tot] = INT_MAX;bs[tot] = i;
        out[i] = (++tot);
        w[tot] = INT_MAX;bs[tot] = i;
        int lst = in[i];
        for(int j : bel[i]){
            w[++tot] = j;
            add(lst, tot);bs[tot] = i;
            lst = tot;
        }
        add(lst, out[i]);
    }
    for(int i=1;i<=n;i++){
        for(int j : tree[i]){
            if(depth[i] > depth[j]) continue;
            add(out[i], in[j]);
        }
    }
    seg[1]=seg[0]=rev[1]=top[1]=1;
    dfs1(1,0);dfs2(1,0);
    build(1,1,seg[0]);
    while(q--){
        int op,x,y,z;
        cin>>op>>x>>y;
        if(op==1){
            cin>>z;
            if(dep[in[x]] > dep[in[y]]) swap(x,y);
            if(in[x] == kthFather(in[y], dep[in[y]] - dep[in[x]])){
                x = in[x];
                y = out[y];
            }
            else{
                x = out[x];
                y = out[y];
            }
            // cerr<<x<<' '<<y<<'\n';
            vector<int> ans;
            int l = bs[lca(x,y)];
            for(int i=1;i<=z;i++){
                auto ret = QueryPath(x,y);
                auto ret2 = QueryPath(in[l], out[l]);
                ret = merge(ret, ret2);
                if(ret.first >= INT_MAX) break;
                ans.push_back(w[rev[ret.second]]);
                update(ret.second, ret.second, INT_MAX, 1, 1, seg[0]);
            }
            cout<<ans.size()<<' ';
            for(int j : ans) cout<<j<<' ';
            cout<<'\n';
        }
        else UpdateSubtree(in[x], y);
    }
    return 0;
}
 
// So I say a little prayer
// And hope my dreams will take me there
// Where the skies are blue to see you once again, my love 
// Over seas from coast to coast
// To find a place I love the most
// Where the fields are green to see you once again, my love
// ----- Westlife My Love

```

---

## 作者：tommymio (赞：3)

### 题意

给定一棵 $n$ 个节点的树，有 $m$ 个物品，第 $i$ 个在节点 $c_i$，初始权值为 $i$。

你需要支持两种操作：

- 对于树上的简单路径 $u \to v$，删除权值前 $k$ 小的物品并输出。
- 对于子树 $x$，将子树内所有物品权值加 $x$。

### Solution

考虑 $k=1$ 且只有第一种操作的情况。对于每个点维护其当前的最小权值，这里可以使用队列。使用树剖维护路径最小值即可。

考虑 $k\leq n$ 且只有第一种操作的情况。注意到删除权值前 $k$ 小的物品其实可以转换成多轮迭代，即每次取出并删去最小值，重复 $k$ 次。

加上第二种操作。可以发现其实只是对于每个队列多维护了一个加法标记。对于子树内的队列，其加法标记全部 $+x$。当删除点 $u$ 上的最小值，加入点 $u$ 新的最小值时，将新的最小值加上加法标记的值即可。

时间复杂度为 $O(n \log n+Q \log ^2 n)$。





---

## 作者：yinianxingkong (赞：2)

简洁的题解。

前 $k$ 小怎么做？因为查过就会删，最多 $n$ 次。只需要实现找最小值和删除即可。

怎么找路径最小值？所有礼物按照 dfn 序建立线段树维护最小值，树剖拆一下路径，每段二分一下所属礼物区间查找即可。

怎么删除？直接改权值为 $+\infty$ 即可。

怎么子树加？dfn 序转换成区间加即可。

注意处理编号问题，还有要开 `long long`。

[代码](https://codeforces.com/contest/696/submission/273262118)。

---

## 作者：qinhuanmma (赞：1)

~~树链剖分板子题。~~   

首先考虑一个点只有一个物品的情况，发现只需要一个可以维护子树加，单点加，树链最小值的数据结构就行了，直接上树剖。  

具体地说，每次查询进行 $k$ 次树链最小值的查询，每查到一个点，就把那个点的值加上 $\infty$，表示它被拿走了；如果查到的最小值都 $\ge \infty$，那就说明这条链上已经没有物品了，直接退出循环即可。每次查询都会删掉一个点，因此总查询次数为 $O(m)$。   

接下来考虑一个点可以有多个物品的情况：直接把一个点拆成一条链，链上每个点存一个物品，拆完后像上面那样维护即可。  
![](https://cdn.luogu.com.cn/upload/image_hosting/1f885uly.png)
细节较多。时间复杂度：$O(n\log^2n)$。  
code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 300010;
const int INF = 1e15;
namespace cza{
	int n, m, Q;
	int ncnt;
	int val[N];
	vector<int> ve[N];
	vector<int> girl[N];
	int fa[N], dep[N], dfn[N], nfd[N], top[N], size[N], son[N], dian[N], gl[N], down[N], ed[N], up[N], faa[N];
	void dfs(int u, int f){
		fa[u] = f;
		size[u] = 1;
		for(int v : ve[u]){
			if(v == f) continue;
			dfs(v, u);
		}
	}
	void rebuild(){
		for(int i = 1; i <= n; i++){
			down[i] = up[i] = i;
			if(girl[i]. size() == 1) dian[girl[i][0]] = i, gl[i] = girl[i][0];
			if(girl[i]. size() <= 1) continue;
			for(int v : ve[i]){
				if(v == fa[i]) continue;
				ve[ncnt + girl[i]. size() - 1]. push_back(v);
			}
			down[i] = ncnt + girl[i]. size() - 1;
			ve[i]. clear();
			int now = girl[i][0];
			dian[now] = i;
			gl[i] = now;
			up[i] = i;
			int f = i;
			for(int j = 1; j < girl[i]. size(); j++){
				++ncnt;
				int now = girl[i][j];
				ve[f]. push_back(ncnt);
				dian[now] = ncnt;
				gl[ncnt] = now;
				up[ncnt] = i;
				f = ncnt;
			}
		} 
	}
	void dfs1(int u, int f){
		size[u] = 1;
		dep[u] = dep[f] + 1;
		faa[u] = f;
		for(int v : ve[u]){
			if(v == fa[u]) continue;
			dfs1(v, u);
			size[u] += size[v];
			if(size[v] > size[son[u]]) son[u] = v;
		}
	}
	void dfs2(int u, int t){
		top[u] = t;
		dfn[u] = ++dfn[0];
		nfd[dfn[0]] = u;
		if(son[u]) dfs2(son[u], t);
		for(int v : ve[u]){
			if(v == fa[u] or v == son[u]) continue;
			dfs2(v, v);
		}
		ed[u] = dfn[0];
	}
	pair<int, int> get_min(pair<int, int> x, pair<int, int> y){
		if(x. first < y. first) return x;
		else if(y. first < x. first) return y;
		else{
			return {x. first, up[nfd[x. second]] < up[nfd[y. second]] ? x. second : y. second};
		}
	} 
	struct node{
		int minn, pos, tag;
	};
	struct Segment_Tree{
		node t[N << 2];
		#define ls(p) (p << 1)
		#define rs(p) (p << 1 | 1)
		void push_up(int p){
			if(t[ls(p)]. minn < t[rs(p)]. minn) t[p]. minn = t[ls(p)]. minn, t[p]. pos = t[ls(p)]. pos;
			else if(t[rs(p)]. minn < t[ls(p)]. minn) t[p]. minn = t[rs(p)]. minn, t[p]. pos = t[rs(p)]. pos;
			else{
				t[p]. minn = t[ls(p)]. minn;
				t[p]. pos = up[nfd[t[ls(p)]. pos]] < up[nfd[t[rs(p)]. pos]] ? t[ls(p)]. pos : t[rs(p)]. pos;
			}
		}
		void taging(int p, int v){
			t[p]. minn += v;
			t[p]. tag += v;
		}
		void push_down(int p){
			if(!t[p]. tag) return ;
			taging(ls(p), t[p]. tag);
			taging(rs(p), t[p]. tag);
			t[p]. tag = 0;
		}
		void build(int p, int l, int r){
			if(l == r){
				t[p]. minn = val[gl[nfd[l]]];
				t[p]. pos = l;
				return ;
			}
			int mid = (l + r) >> 1;
			build(ls(p), l, mid);
			build(rs(p), mid + 1, r);
			push_up(p);
		}
		void upd(int p, int l, int r, int nl, int nr, int v){
			if(nl <= l and r <= nr){
				taging(p, v);
				return ;
			}
			push_down(p);
			int mid = (l + r) >> 1;
			if(nl <= mid) upd(ls(p), l, mid, nl, nr, v);
			if(mid < nr) upd(rs(p), mid + 1, r, nl, nr, v);
			push_up(p);
		}
		pair<int, int> find(int p, int l, int r, int nl, int nr){
			if(nl <= l and r <= nr){
				return {t[p]. minn, t[p]. pos};
			}
			push_down(p);
			int mid = (l + r) >> 1;
			pair<int, int> ret = {INF, 0};
			if(nl <= mid) ret = get_min(ret, find(ls(p), l, mid, nl, nr));
			if(mid < nr) ret = get_min(ret, find(rs(p), mid + 1, r, nl, nr));
			return ret;
		}
	}t;
	pair<int, int> get(int u, int v){
		u = down[u], v = down[v];
		pair<int, int> ret = {INF, 0};
		while(top[u] != top[v]){
			if(dep[top[u]] < dep[top[v]]) swap(u, v);
			ret = get_min(ret, t. find(1, 1, ncnt, dfn[top[u]], dfn[u]));
			u = faa[top[u]];
		}
		if(dep[u] > dep[v]) swap(u, v);
		ret = get_min(ret, t. find(1, 1, ncnt, dfn[up[u]], dfn[v]));
		if(ret. first < INF) t. upd(1, 1, ncnt, ret. second, ret. second, INF);
		return ret;
	}
	int ans[N], acnt;
	int main(){
		scanf("%lld%lld%lld", &n, &m, &Q);
		ncnt = n;
		for(int i = 1, u, v; i < n; i++){
			scanf("%lld%lld", &u, &v);
			ve[u]. push_back(v);
			ve[v]. push_back(u);
		}
		for(int i = 1, u; i <= m; i++){
			scanf("%lld", &u);
			girl[u]. push_back(i);
			val[i] = i;
		}
		val[0] = INF;
		dfs(1, 0);
		rebuild();
		dfs1(1, 0);
		dfs2(1, 1);
		t. build(1, 1, ncnt);
		for(int i = 1, op, u, v, k; i <= Q; i++){
			scanf("%lld%lld%lld", &op, &u, &v);
			if(op == 1){
				scanf("%lld", &k);
				pair<int, int> ret = {INF, 0};
				acnt = 0;
				ret = get(u, v);
				while(k and ret. first < INF){
					k--;
					ans[++acnt] = gl[nfd[ret. second]];
					if(!k) break;
					ret = get(u, v);
				}
				printf("%lld ", acnt);
				for(int j = 1; j <= acnt; j++) printf("%lld ", ans[j]);
				printf("\n");
			}else{
				t. upd(1, 1, ncnt, dfn[u], ed[u], v);
			}
		}
		return 0;
	} 
}
signed main(){
	return cza::main();
}
``

---

## 作者：Sevendays_Coder (赞：1)

## _Description_

大概意思是给定一颗 $n$ 个节点的树， 有 $m$ 个带权的物品存放在节点上，一个节点可能有多个物品，有多次操作，分为两种，一种为子树加值，另一种为链上查询前 $k$ 小，并删除，不足 $k$ 则取全部。

## _Solution_

对于子树修改，链上查询这种复杂的树上问题，我们无奈地选择树剖。

观察到每一个物品最多被取走一次，所以对于每一条链，暴力取 $k$ 次最小值，复杂度是对的。

由于线段树维护的东西比较特殊，需要维护最小权值所在的点，还要维护加值，在合并的时候比较难处理，有一种比较方便的写法是用一个结构体或 ```pair```，分别记录所取的点的编号和该区间的累积加值，专门写一个 ```merge``` 函数，修改和查询合并区间都用这个函数。

对每一个点开一个栈，把该点上的物品都压下去，按照权值从小到大排序，每次查询到该点的时候取栈顶就行了，删除时弹栈。

几点注意事项：

- 注意特判空栈。

- 注意删除的时候记得 Pushup。

- 注意特判区间内无物品的情况，和取不够 $k$ 个的情况。

- 注意物品是放在线段树节点编号上，即 $Seg_i$ 上。

- 注意当权值相等时取编号较小的，此为物品编号，不是节点编号。

- 注意十年 OI 一场空，不开 ```long long``` 见祖宗。

这题思路比较暴力，难度主要集中在代码实现，~~挂了保持好心态~~。

[3.58KB 的代码](https://www.luogu.com.cn/paste/xp221kfj)。

## _Update on 12th Dec_

感谢 @rainygame 的 hack，原代码的结点编号比较到了线段树上的编号，已修改。 

---

## 作者：xie_lzh (赞：0)

这有 3000 啊？

给你一棵树，树上有一些数，第 $i$ 个数等于 $i$。

注意同一个位置会有多个数。

我们需要维护子树的数加，和找到链上最小的 $k$ 个数并按顺序输出它们的编号，然后删去。

容易发现每个数只会被删一次，所以容易想到每次找到最小值并删去。

所以我们只要维护链上最小值和位置就行。

数剖维护子树加和链上查询就行。

具体而言，线段数的叶子的二元组为其对应节点上的最小值和最小值的编号。

对于链查询最小值是树剖模板。

对于删去最小值，找到最小值在线段数上的位置，从set里删去即可。

注意一下删去的最小值要减去线段树上的懒标记。

[Code](https://codeforces.com/contest/696/submission/282461787)

---

## 作者：wwwwwza (赞：0)

细节有点多，思路不难想。

给每个物品单独开一个点，原来树上的节点分裂成两个点，出点和入点，与这个节点上的物品相连，形成一条链。

其父亲的出点连该点的入点。

剩下的树链剖分找最小值，因为物品最多只有 $m$ 个，所以时间复杂度是可以保证的。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+5;
const int inf=1e15;
int n,m,q,x,y,idx=0,opt,k,ans[N],tot=0;
int in[N],out[N],val[N],bac[N],pos[N],id[N],dot[N];
vector<int>g[N],e[N],gif[N];
struct seg{
	int num,pos,id;
}tree[N<<2];
void add(int x,int y){
	g[x].push_back(y);
	g[y].push_back(x);
}
int f[N][30],d[N];
void dfs(int u,int fa){
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(v==fa)continue;
		add(in[v],out[u]);
		f[v][0]=u;d[v]=d[u]+1;
		for(int j=1;j<=25;j++)f[v][j]=f[f[v][j-1]][j-1];
		dfs(v,u);
	}
}
int lca(int x,int y){
	if(d[x]<d[y])swap(x,y);
	int len=d[x]-d[y];
	for(int i=25;i>=0;i--){
		if(len>=(1<<i)){
			x=f[x][i];
			len-=(1<<i);
		}
	}
	if(x==y)return x;
	for(int i=18;i>=0;i--){
		if(f[x][i]!=f[y][i]){
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
int dfn[N],son[N],dep[N],top[N],siz[N],fat[N],tag[N<<2],cnt=0;
void dfs1(int u,int fa){
	siz[u]=1;fat[u]=fa;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa)continue;
		dep[v]=dep[u]+1;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]){
			son[u]=v;
		}
	}
}
void dfs2(int u,int topx){
	top[u]=topx;
	dfn[u]=++cnt;
	if(!son[u])return;
	dfs2(son[u],topx);
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fat[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
seg pushup(seg a,seg b){
	if(a.num==b.num){
		if(a.id<b.id)return a;
		return b;
	}else if(a.num<b.num)return a;
	return b;
}
void update(int rt,int l,int r,int x,int d,int p1,int p2){
	if(l==r){
		tree[rt]={d,p1,p2};
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)update(rt*2,l,mid,x,d,p1,p2);
	else update(rt*2+1,mid+1,r,x,d,p1,p2);
	tree[rt]=pushup(tree[rt*2],tree[rt*2+1]);
}
void pushdown(int rt){
	if(tag[rt]){
		tag[rt*2]+=tag[rt];
		tag[rt*2+1]+=tag[rt];
		tree[rt*2].num+=tag[rt];
		tree[rt*2+1].num+=tag[rt];
		tag[rt]=0;
	}
}
seg query(int rt,int l,int r,int x,int y){
	if(x<=0||y<=0)return {inf,0,0};
	if(x<=l&&r<=y)return tree[rt];
	pushdown(rt);
	int mid=l+r>>1;
	seg res={inf,0,0};
	if(x<=mid)res=pushup(res,query(rt*2,l,mid,x,y));
	if(y>mid)res=pushup(res,query(rt*2+1,mid+1,r,x,y));
	return res; 
}
seg pre(int x,int y){
	seg res={inf,0,0};
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		res=pushup(res,query(1,1,idx,dfn[top[x]],dfn[x]));
		x=fat[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	res=pushup(res,query(1,1,idx,dfn[x],dfn[y]));
	return res;
}
void modify(int rt,int l,int r,int x,int y,int d){
	if(x<=l&&r<=y){
		tree[rt].num+=d;
		tag[rt]+=d;
		return;
	}
	pushdown(rt);
	int mid=l+r>>1;
	if(x<=mid)modify(rt*2,l,mid,x,y,d);
	if(y>mid)modify(rt*2+1,mid+1,r,x,y,d);
	tree[rt]=pushup(tree[rt*2],tree[rt*2+1]);
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&q);
	for(int i=1;i<n;i++){
		scanf("%lld%lld",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=m;i++){
		scanf("%lld",&x);
		gif[x].push_back(i);
	}
	for(int i=1;i<=n;i++){
		in[i]=++idx,out[i]=++idx;
		bac[in[i]]=bac[out[i]]=i;
		val[in[i]]=val[out[i]]=inf;
		if(gif[i].size()==0){
			add(in[i],out[i]);
		}else{
			val[++idx]=gif[i][0];
			add(in[i],idx);
			pos[idx]=gif[i][0];
			id[idx]=i;dot[gif[i][0]]=idx;
			for(int j=1;j<gif[i].size();j++){
				idx++;val[idx]=gif[i][j];
				pos[idx]=gif[i][j];
				id[idx]=i;
				dot[gif[i][j]]=idx;
				add(idx-1,idx);
			}
			add(idx,out[i]);
		}
	}
	dfs(1,0);
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=idx;i++){
		update(1,1,idx,dfn[i],val[i],pos[i],id[i]);
	}
	while(q--){
		scanf("%lld",&opt);
		if(opt==1){
			tot=0;
			scanf("%lld%lld%lld",&x,&y,&k);
			int p=in[lca(x,y)];
			while(k--){
				seg cnt=pushup(pre(out[x],p),pre(out[y],p));
				if(cnt.num>=inf||cnt.pos==0)break;
				ans[++tot]=cnt.pos;
				modify(1,1,idx,dfn[dot[cnt.pos]],dfn[dot[cnt.pos]],inf);
			}
			printf("%lld ",tot);
			for(int i=1;i<=tot;i++)printf("%lld ",ans[i]);
			printf("\n");
		}else{
			scanf("%lld%lld",&x,&y);
			x=in[x];
			modify(1,1,idx,dfn[x],dfn[x]+siz[x]-1,y);
		}
	}
	return 0;
}

```

---

## 作者：max0810 (赞：0)

一道细节很多的树剖题，很适合拿来练习...


## 题意简述

给定一棵 $n$ 个点的树，有 $m$ 个物品，第 $i$ 个物品位置在 $c_i$，初始权值为 $i$。

给定 $q$ 个询问，询问有如下两种：
- `1 u v k`：对于树上的一条简单路径 $(u,v)$ 删除路径上所有物品中权值最小的 $k$ 个物品，并输出。
- `2 u k`：将 $u$ 这个子树内所有物皮的权值加 $k$。

## 题解

因为每个物品最多只会被删一次，所以最多输出 $n+q$ 个数，因此每次可以暴力枚举会删去哪些数。

接着再转换一下，每次求前 $k$ 小，就相当于求路径上最小的，然后删掉，这个过程重复 $k$ 次。于是问题就变成了子树加，路径查询最小值，所以用树剖来维护就好了。

具体地，对于每个点，将这个点里面的物品从大到小排序，然后维护一个队列，每次删掉某个点的队尾，再更新线段树的信息即可。可以将空点的权值设为正无穷，如果有一次查询到路径上最小值为正无穷，那么这条路径就没有物品了，需要直接 `break`。

然后，这道题一些细节需要注意一下：
- 相同权值的两个物品是比较所在节点编号，而不是本身的编号。
- 一定要先确保树剖写对了再写后面的，不然很有可能要调很久。
- $INF$ 要开到足够大。
- 注意单点更新时应该更新 $id_x$，而不是 $x$。

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define ls x<<1
#define rs x<<1|1
#define lson x<<1,l,mid
#define rson x<<1|1,mid+1,r
#define ll long long
using namespace std;
const int N = 1e5+5;
const ll inf = 1e15;
int ans[N],c[N],hd[N],n,m,q,cnt,sum;
vector<int> a[N];
bool cmp(int x,int y){return x > y;}
struct edge{int to,nex;}e[N << 1];
void add(int u,int v)
{e[++cnt] = {v,hd[u]};hd[u] = cnt;}
int fa[N],d[N],siz[N],son[N],id[N],rk[N],top[N],tot;
struct node
{
    ll v;int id;
    friend bool operator <(node x,node y)
    {return x.v != y.v?x.v < y.v:c[x.id] < c[y.id];}
}t[N << 2];ll tag[N << 2];
node get(int x,int i)
{
    if(a[i].empty())return {inf,0};
    int id = a[i].back();return {id+tag[x],id};
}
void update(int x){t[x] = min(t[ls],t[rs]);}
void pushtag(int x,ll v)
{if(t[x].v != inf)t[x].v += v,tag[x] += v;}
void pushdown(int x)
{
    ll &v = tag[x];if(!v)return ;
    pushtag(ls,v);pushtag(rs,v);v = 0;
}
void build(int x,int l,int r)
{
    if(l == r){t[x] = get(x,rk[l]);return ;}
    int mid = l+r>>1;
    build(lson);build(rson);
    update(x);
}
void modify1(int x,int l,int r,int i)
{
    if(l == r){t[x] = get(x,rk[l]);return ;}
    int mid = l+r>>1;pushdown(x);
    if(i <= mid)modify1(lson,i);
    else modify1(rson,i);
    update(x);
}
void modify2(int x,int l,int r,int L,int R,ll v)
{
    if(L <= l&&r <= R){pushtag(x,v);return ;}
    int mid = l+r>>1;pushdown(x);
    if(L <= mid)modify2(lson,L,R,v);
    if(mid < R)modify2(rson,L,R,v);
    update(x);
}
node query(int x,int l,int r,int L,int R)
{
    if(L <= l&&r <= R)return t[x];
    int mid = l+r>>1;node ans = {inf,0};pushdown(x);
    if(L <= mid)ans = query(lson,L,R);
    if(mid < R)ans = min(ans,query(rson,L,R));
    return ans;
}
void dfs1(int u,int f)
{
    fa[u] = f;d[u] = d[f]+1;siz[u] = 1;
    for(int i = hd[u],v;i;i = e[i].nex)
    {
        if((v = e[i].to) == f)continue;
        dfs1(v,u);siz[u] += siz[v];
        if(siz[son[u]] < siz[v])son[u] = v;
    }
}
void dfs2(int u,int tp)
{
    id[u] = ++tot;rk[tot] = u;top[u] = tp;
    if(son[u])dfs2(son[u],tp);
    for(int i = hd[u],v;i;i = e[i].nex)
        if((v = e[i].to) != fa[u]&&v != son[u])dfs2(v,v);
}
node queryRange(int x,int y)
{
    node ans = {inf,0};
    while(top[x] != top[y])
    {
        if(d[top[x]] < d[top[y]])swap(x,y);
        ans = min(ans,query(1,1,n,id[top[x]],id[x]));
        x = fa[top[x]];
    }
    if(d[x] > d[y])swap(x,y);
    return min(ans,query(1,1,n,id[x],id[y]));;
}
void modifyTree(int x,ll v)
{modify2(1,1,n,id[x],id[x]+siz[x]-1,v);}
bool solve(int u,int v)
{
    node now = queryRange(u,v);int x = now.id;
    if(now.v == inf)return 0;
    ans[++sum] = x;a[c[x]].pop_back();
    return modify1(1,1,n,id[c[x]]),1;
}
inline int rd()
{
    char c;int f = 1;
    while(!isdigit(c = getchar()))if(c=='-')f = -1;
    int x = c-'0';
    while(isdigit(c = getchar()))x = x*10+(c^48);
    return x*f;
}
int main()
{
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    n = rd();m = rd();q = rd();
    for(int i = 1;i < n;i++)
    {int u = rd(),v = rd();add(u,v);add(v,u);}
    for(int i = 1;i <= m;i++)
        a[c[i] = rd()].push_back(i);
    for(int i = 1;i <= n;i++)
        sort(a[i].begin(),a[i].end(),cmp);
    dfs1(1,0);dfs2(1,1);build(1,1,n);
    while(q--)
    {
        int op = rd(),u = rd(),v,k;
        if(op == 1)
        {
            v = rd();k = rd();sum = 0;
            while(k--)if(!solve(u,v))break;
            printf("%d ",sum);
            for(int i = 1;i <= sum;i++)printf("%d ",ans[i]);puts("");
        }
        else modifyTree(u,rd());
    }
    return 0;
}
```

---


# 剪刀

## 题目描述

Jenya 最近获得了一个非常有用的工具——$k$-剪刀，用于裁剪字符串。这种剪刀通常用于从一个任意字符串 $s$ 中剪出两个长度为 $k$ 且不交的子串（要求 $s$ 的长度至少为 $2 \cdot k$），然后将它们按原顺序拼接起来。例如，使用 $2$-剪刀可以从字符串 $abcde$ 中剪出 $ab$ 和 $de$，拼接得到 $abde$，但不能剪出 $ab$ 和 $bc$，因为它们相交了。  

为了在实际使用前测试这个工具，Jenya 找到了两个字符串 $s$ 和 $t$。他想知道是否可以对 $s$ 使用剪刀，使得拼接后的结果包含 $t$ 作为子串。  

## 说明/提示

在第一个样例中，可以剪出起始位置为 $1$ 和 $5$ 的两个子串。拼接后的字符串为 baaaab，其中包含 aaaa 作为子串。  

在第二个样例中，拼接后的字符串为 bccb。  

翻译由 DeepSeek R1 完成  

## 样例 #1

### 输入

```
7 4 3
baabaab
aaaa
```

### 输出

```
Yes
1 5
```

## 样例 #2

### 输入

```
6 3 2
cbcbcb
bcc
```

### 输出

```
Yes
2 5
```

## 样例 #3

### 输入

```
7 5 3
aabbaaa
aaaaa
```

### 输出

```
No
```

# 题解

## 作者：白鲟 (赞：6)

### 前言
花了很久调代码，改了一堆细节，一度以为方法错了……

结果 KMP 写错了！

一怒之下来写一篇题解区还没有的线性 KMP 做法。

### 分析
由于串 $t$ 是串 $s$ 两不交子串拼接得到的子串。自然有两种情况讨论：$t$ 被 $s$ 分出的一个子串包含，或 $t$ 处于 $s$ 两子串的拼接处。

前一情况只需做一遍普通 KMP，每次在 $s$ 中匹配到完整的 $t$ 所在位置 $i$，则判断两组区间 $[\max(i,k)-k+1,\max(i,k)],[\max(i,k)+1,\max(i,k)+k]$ 与 $[\min(n-k+1,i)-k,\min(n-k+1,i)-1],[\min(n-k+1,i),\min(n-k+1,i)+k-1]$ 中是否存在一组合法解。这两组区间分别是使得包含串 $t$ 的子串尽量靠左与靠右的情况，正确性易得。注意此情况 $k\ge m$。

考虑后一种情况。发现等价于将 $t$ 沿某一位置拆成左右两半，并在 $s$ 中分别匹配两半后拼起来。运用贪心思想，左半出现的位置应尽量靠左，右半出现的位置应尽量靠右。于是设 $f_{0,i}$ 为 $t$ 以 $i$ 结尾的前缀在 $s$ 中完全出现的结尾点最前位置，$f_{1,i}$ 为 $t$ 以 $i$ 开始的后缀在 $s$ 中完全出现的起始点最后位置，两者可以分别正向与反向运用 KMP 算法线性求出。一组合法解可通过满足 $f_{0,i}$ 存在，$f_{1,i+1}$ 存在，且 $f_{0,i}<f_{1,i+1}$ 的 $i$ 得到。

考虑一些细节。由于砍下的子串长度为 $k$，$t$ 中拆分出的两子串长度不应超过 $k$。同时，记录的 $f_0,f_1$ 均应满足到左/右边界的距离不小于 $k$，否则无法构造出解。这样一来，可能出现长度较小的前后缀由于位置出现过早解被舍去从而 $f_{0/1}$ 未能被求出的情况。于是需要使用 $f_{0/1,i}$ 的值去更新 $f_{0/1,KMP(i)}$。

### 代码
```cpp
#include<bits/stdc++.h>
#define loop(i,from,to) for(int i=(from);i<=(to);++i)
#define rloop(i,from,to) for(int i=(from);i>=(to);--i)
using namespace std;
const int maxn=1e6;
int n,m,k,j,f[2][maxn+1],KMP[maxn+1];
char s1[maxn+1],s2[maxn+1];
int main(){
	scanf("%d%d%d%s%s",&n,&m,&k,s1+1,s2+1),j=0;
	loop(i,2,m){
		while(j&&s2[i]!=s2[j+1])j=KMP[j];
		if(s2[i]==s2[j+1])++j;
		KMP[i]=j;
	}
	j=0;
	loop(i,1,n){
		while(j&&s1[i]!=s2[j+1])j=KMP[j];
		if(s1[i]==s2[j+1])++j;
		if(i>=k&&!f[0][j])f[0][j]=i;
		if(j==m){
			if(max(i,k)+k<=n&&k>=m){
				printf("Yes\n%d %d\n",max(i,k)-k+1,max(i,k)+1);
				return 0;
			}
			if(min(n-k+1,i)-k>=1&&k>=m){
				printf("Yes\n%d %d\n",min(n-k+1,i)-k,min(n-k+1,i));
				return 0;
			}
			j=KMP[j];
		}
	}
	rloop(i,m,1)if(f[0][i])f[0][KMP[i]]=(f[0][KMP[i]]?min(f[0][KMP[i]],f[0][i]):f[0][i]);
	fill(KMP+1,KMP+m+1,m+1),fill(f[1]+1,f[1]+m+1,n+1),j=m+1;
	rloop(i,m-1,1){
		while(j<=m&&s2[i]!=s2[j-1])j=KMP[j];
		if(s2[i]==s2[j-1])--j;
		KMP[i]=j;
	}
	j=m+1;
	rloop(i,n,1){
		while(j<=m&&s1[i]!=s2[j-1])j=KMP[j];
		if(s1[i]==s2[j-1])--j;
		if(n-i+1>=k&&f[1][j]==n+1)f[1][j]=i;
		if(j==1)j=KMP[j];
	}
	loop(i,1,m)if(f[1][i]!=n+1)f[1][KMP[i]]=(f[1][KMP[i]]!=n+1?max(f[1][KMP[i]],f[1][i]):f[1][i]);
	loop(i,1,m-1)if(i<=k&&m-i<=k&&f[0][i]&&f[1][i+1]!=n+1&&f[0][i]<f[1][i+1]){
		printf("Yes\n%d %d\n",f[0][i]-k+1,f[1][i+1]);
		return 0;
	}
	puts("No");
	return 0;
}
```

---

## 作者：Milthm (赞：3)

### 前言

这是本题目第一个主要算法是哈希的题解。

另外这似乎是我截止到发题解为止做过最难的紫题（如果不算大模拟的话）。

___

首先如果 $|t|\le k$ 的话，我们直接找 $s$ 里有没有 $t$ 就可以了。

如果你在 $80$ 号点 WA 了，可以看看你是否判断了 $t$ 在后 $k$ 个里的情况。

然后如果 $|t|>k$，这种情况比较复杂：

我们可以考虑枚举 $t$ 的断点。运用贪心思想，设 $L_i$ 表示 $s$ 中最小的下标，满足从它开始的 $i$ 个字符为 $t_1\sim t_i$。设 $R_i$ 表示 $s$ 中最大的下标，满足以它为结尾的 $i$ 个字符为 $t_{|t|-i+1}\sim t_{|t|}$。这样可以让前面的字符串尽量给后面留出空来，尽可能防止两个字符串重叠。

这样的话，我们到最后只要判断 $L_i$ 和 $R_{|t|-i}$ 是否能拼成就行了（判断能否拼成见最后的代码）。现在问题转化为了求 $L$ 和 $R$ 数组。

我们发现 $R$ 数组可以将 $s,t$ 翻转之后仿照 $L$ 求。所以我们只探讨 $L$ 的求法即可。我们发现，$L_i$ 必须满足 $L_i+i-1\ge k$，否则前面取不够 $k$ 个。

于是，我们设 $E_i$ 表示 $s_i\sim s_n$ 与 $t$ 的最长公共前缀，很显然 $E_i$ 可以用二分加哈希求出。现在 $L_i$ 就等于满足 $E_x\ge i$ 且 $x+i\ge k$ 的最小 $x$。显然暴力求解还是 $|s|^2$ 级别，没办法通过。

考虑优化，可以将 $E_i$ 从小到大排序（记得记录它们原来的编号），然后从大到小枚举 $i$，记录一个变量 $u$，每次把 $E_u\ge i$ 的 $u$ 所对应原来的编号加入 `set`，并自增 $u$，直至条件不成立为止。每次要查询的其实就是集合内满足 $x\ge k-i+1$ 最小的 $x$，采用 `lower_bound` 求解即可。

这样我们就成功做出了这道题，时间复杂度 $|s| \log |s|$，因为常数巨大需要卡常，建议不要 `#define int long long`。

### AC code

```cpp
#include<bits/stdc++.h>
#define N 500005
using namespace std;
const long long mod=1e9+9,base=331;
int l1,l2,k,dp[N*2],l[N],r[N];
long long f1[N],f2[N],b[N];
struct node{
	int x,id;
}ex[N];
bool cmp(node a,node b){
	return a.x<b.x;
}
string s,t;
int get(int l,int r,int op){
	if(op==0)return ((f1[r]-f1[l-1]*b[r-l+1])%mod+mod)%mod;
	else return ((f2[r]-f2[l-1]*b[r-l+1])%mod+mod)%mod;
}
set<int>S;
signed main(){
	cin>>l1>>l2>>k>>s>>t;
	b[0]=1;
	for(int i=1;i<=N-5;++i)b[i]=b[i-1]*base%mod;
	s=" "+s;t=" "+t;
	for(int i=1;i<=l1;++i)f1[i]=(f1[i-1]*base+s[i])%mod;
	for(int i=1;i<=l2;++i)f2[i]=(f2[i-1]*base+t[i])%mod;
	if(l2<=k){
		for(int i=1;i<=l1-l2+1;++i){
			if(get(i,i+l2-1,0)==f2[l2])dp[i]=dp[i-1]+1;
			else dp[i]=dp[i-1];
		}
		for(int i=l1-l2+2;i<=l1*2;++i)dp[i]=dp[i-1];
		for(int i=1;i<=l1-k*2+1;++i){
			if(dp[i+k-1]-dp[i-1])return cout<<"Yes\n"<<i<<" "<<i+k,0;
		}
		for(int i=k+1;i<=l1-k+1;++i){
			if(dp[i+k-1]-dp[i-1])return cout<<"Yes\n"<<i-k<<" "<<i,0;
		}
	}
	for(int i=1;i<=l1;++i){
		int L=1,R=l1-i+1,ans=0;
		while(L<=R){
			int mid=(L+R)>>1;
			if(get(i,i+mid-1,0)==f2[mid])L=mid+1,ans=mid;
			else R=mid-1;
		}
		ex[i]={ans,i};
	}
	sort(ex+1,ex+l1+1,cmp);int now=l1;
	for(int i=l1;i>=1;--i){
		while(ex[now].x>=i)S.insert(ex[now].id),--now;
		l[i]=*S.lower_bound(k-i+1);
		if(l[i]<=0)l[i]=1e9;
	}
	for(int i=1;i<=l1;++i)f1[i]=(f1[i-1]*base+s[l1-i+1])%mod;
	for(int i=1;i<=l2;++i)f2[i]=(f2[i-1]*base+t[l2-i+1])%mod;
	for(int i=1;i<=l1;++i){
		int L=1,R=l1-i+1,ans=0;
		while(L<=R){
			int mid=(L+R)>>1;
			if(get(i,i+mid-1,0)==f2[mid])L=mid+1,ans=mid;
			else R=mid-1;
		}
		ex[i]={ans,i};
	}
	sort(ex+1,ex+l1+1,cmp);S.clear();now=l1;
	for(int i=l1;i>=1;--i){
		while(ex[now].x>=i)S.insert(ex[now].id),--now;
		r[i]=l1-*S.lower_bound(k-i+1)+1;
		if(r[i]>l1)r[i]=-1e9;
	}
	for(int i=1;i<=k;++i){
		if(l[i]+i>k&&l2-i>=1&&l2-i<=k&&r[l2-i]-(l2-i)+1<=l1-k+1&&l[i]+i-1<r[l2-i]-(l2-i)+1){
			cout<<"Yes\n"<<l[i]+i-k<<" "<<r[l2-i]-(l2-i)+1;return 0;
		}
	}
	cout<<"No";
	return 0;
}

```

---

## 作者：duyi (赞：3)

[噜啦噜啦咧 噜啦噜啦咧 的阅读体验 ！！！！](https://www.cnblogs.com/dysyn1314/p/14146557.html)


# CF955D Scissors

## 题目大意

[题目链接](https://codeforces.com/problemset/problem/955/D)

给定一个长度为 $n$ 的串 $s$ 和一个长度为 $m$ 的串 $t$。给定一个正整数 $k$。

请找出 $s$ 的两个互不重叠的、长度为 $k$ 的子串，满足：将它们按原有顺序拼接后，得到的串中包含 $t$（$t$ 是一个子串）。

数据范围：$2\leq m\leq 2\cdot k\leq n\leq 5\times 10^5$。

## 本题题解

考虑 $s$ 里，被选出的两个长度为 $k$ 的子串，称为关键子串 1、关键子串 2。

分两种情况：

1. $t$ 被完整地包含在某个关键子串中；
2. $t$ 在两个关键子串的拼接处。

对于情况 1，做一遍普通的 KMP 即可判断。因此以下只讨论情况 2。

枚举关键子串 1 的结尾位置 $i$，用 KMP 可以求出一个最大的 $f_i$，满足 $s[i - f_i + 1, i] = t[1,f_i]$。同理，枚举关键子串 2 的开头位置 $j$，可以求出一个最大的 $g_j$，满足 $s[j,j + g_j - 1] = t[m - g_j + 1, m]$。

如果存在一对 $k\leq i < j\leq n - k + 1$，满足 $f_i + g_j = m$，那么我们已经找出了答案。

然而，如果没找到这样的 $i,j$，并不一定代表无解。事实上，上述做法的误区是，数值大的 $f_i$, $g_j$，并不一定最优。具体来说，当 $k\leq i < 2k$ 时，可能存在 $s[i - f_i +i]$ 的一个 border，由它作为 $t$ 的前缀，去和后面拼接，能得到答案。对于 $g$ 也是类似的。

如果枚举 $i$，再暴力枚举 border，由于 border 的数量最大有 $\mathcal{O}(\text{串长})$ 个（例如串 $\texttt{aaa...a}$），这样时间复杂度最坏为 $\mathcal{O}(km)$，无法通过本题。

考虑优化这个“暴力跳 border”的过程。设 $t[1,x]$ 的 border 长度为 $\text{fail}(x)$（与 KMP 算法里的定义是一样的），对于所有 $1\leq x\leq m$ 如果 $\text{fail}(x)\neq 0$，我们从 $\text{fail}(x)$ 向 $x$ 连一条边，发现可以得到一个有根树森林。“暴力跳 border”，就相当于在枚举一个节点 $x$ 的所有祖先。因此可以用树链剖分优化。更具体地，由于一前一后各做一次 KMP，实际上需要建出两个森林。

考虑从小到大枚举 $j$，每次 $i = j - 1$ 会成为一个新出现的、可能的 $i$，我们把 $f_i$ 在树上的所有祖先打上标记。然后要对 $g_j$ 的所有祖先进行查询。通过树链剖分和 dfs 序，把树上问题转化为序列问题后，问题可以形式化地描述为：

有两个排列 $p_{1\dots m}, q_{1\dots m}$（也就是两棵树的 dfs 序序列），需要支持若干次操作。操作分为如下两种：

1. 给定区间 $[l,r]$，把 $p_{l\dots r}$ 里所有**数值**打上标记。
2. 给定区间 $[l,r]$，查询 $q_{l\dots r}$ 里是否存在被标记过的数值。

这个问题并不难。考虑离线，预处理出每个**数值**第一次被标记的时间，这可以通过倒序遍历操作，转化为区间覆盖问题。然后查询就变成了区间最小值查询，可以用 ST 表实现。

如果用线段树做区间覆盖，因为外层还要跳 $\mathcal{O}(\log n)$ 条重链，总时间复杂度是 $\mathcal{O}(n\log^2 n)$（$n,m,k$ 同阶）。可以通过本题，但不够优秀。进一步观察发现，区间覆盖操作是静态的（所有修改发生在询问之前），因此可以用并查集维护。总时间复杂度优化为 $\mathcal{O}(n\log n)$。

## 参考代码

[勇敢向前进，前进有奖品！！！！！](https://www.cnblogs.com/dysyn1314/p/14146557.html)

---

## 作者：Piwry (赞：2)

（upd：更新了个线性（$\Theta(\alpha(n)+n$）做法）

给出一个用 kmp 做的奇怪做法

刚看到这题时直接就糊出一个 $O(n)$ 的 kmp 做法（大概就是计算 $s$ 的前缀与后缀的尾部和头部与 $t$ 的最大匹配长度，然后扫一遍把两个**最大**的答案拼起来；但注意到答案的拼法不一定拼的是两个最大值），结果发现各种假；赛后试着把自己的做法魔改了下，发现还可做，正确性应该没什么问题

不过鉴于我之前的 $O(n)$ 假做法都能跑过前 77 个点，不清楚题目数据是否足够强X（同时我也不太会造... \fad）

## 解析

### Part 0

我们先用 kmp 计算出：

1. 对每个 $s$ 的前缀 $s[1..i]$，求出满足 $s[1..i]$ 的后缀与 $t$ 的前缀相同的最大长度，设为 $\texttt{suf[i]}$
2. 对每个 $s$ 的后缀 $s[j..n]$，求出满足 $s[j..n]$ 的前缀与 $t$ 的后缀相同的最大长度，设为 $\texttt{pre[j]}$

（其中 $2.$ 可以将 $s, t$ 都倒过来做一次 kmp）

一个直观的想法是，将 $\texttt{suf[i]}+\texttt{pre[j]}=m$ 的两段子串拼起来，就能得到答案（当然还要考虑一些边界情况）

不过有一种直接能想到的例外是，$t$ 整个在某个子串内；设该情况为 $\texttt{Case 1}$。这种情况我们只需检查 $n$ 中是否出现 $m$，然后尝试（贪心地）构造方案即可

这样主要部分只需记录每个 $\texttt{suf}$ 的值的出现次数；先正着扫一遍都添加进去，再倒着扫一遍，逐步删除 $\texttt{suf[i]}$ 并顺便检查每个 $\texttt{pre[j]}$ 是否有对应的 $\texttt{suf[i]}$ 值匹配。代码差不多像这样：

```cpp
for(int i =k; i <= n-k; ++i)
	++cnt[suf[i]];
for(int i =n-k+1; i > k; --i){
	if(pre[i] <= k && m-pre[i] <= k && m-pre[i] >= 0)
		if(cnt[m-pre[i]]){
			int start_L =-1;
			for(int j =k; j < i; ++j)
				if(suf[j] == m-pre[i]){
					start_L =j-k+1;
					break;
				}
			printf("Yes\n%d %d", start_L, i);
			return 0;
		}
	--cnt[suf[i-1]];
}
```

于是就：

![WA](https://cdn.luogu.com.cn/upload/image_hosting/oaoveudt.png)

### Part 1

（为了方便后面的讨论，这里规定 $\texttt{suf[i]}, \texttt{pre[j]}$ 的值取**不超过 $k$ 的**最大的 $\{\texttt{suf[i]}, \pi[\texttt{suf[i]}], \pi[\pi[\texttt{suf[i]}]], \cdots\}$ / $\{\texttt{pre[j]}, \pi[\texttt{pre[j]}], \pi[\pi[\texttt{pre[j]}]], \cdots\}$（其中 $\pi$ 即 前缀函数/kmp 的 next 数组））

注意到，这里我们都假设取出的两个子串 $s_1=s[l_1..r_1], s_2=s[l_2..r_2]$ 拼起来后，需要的 $t$ 均为 $s_1[(|s_1|-\texttt{suf[}r_1\texttt{]}+1)..(|s_1|)]+s_2[1..(\texttt{pre[}l_2\texttt{]})]$（即尽可能大地匹配 $s_1, s_2$ 的后缀，前缀）；但实际上其用到的 $s_1$ 后缀或 $s_2$ 前缀不一定都是尽可能长的

不过我们可以证明大部分情况下，$s_1, s_2$ 总有一个的用到的 后缀/前缀 是尽可能长的

考虑答案中 $t$ 为 $s_1[(|s_1|-a+1)..(|s_1|)]+s_2[1..b]$，若 $l_1>1$ 或 $r_2<n$，我们就可以将 $l_1, r_1$ 减 $1$ 或将 $l_2, r_2$ 加 $1$（形象地讲，可以将 $s_1, s_2$ 视为在 $s$ 中的宽为 $k$ 的框选，这里就相当于在移动框），这样 $a, b$ 的其中一个就会减少 $1$，另一个就需要增加 $1$；重复这样的过程，直到 $s_1, s_2$ 中有一个的 后缀/前缀 匹配是尽可能长的

但注意到有一个例外，即 $l_1=1$ **且** $r_2=n$ 时，我们无法接着操作。设该情况为 $\texttt{Case 2}$，我们后面再讨论怎么做；

于是我们知道了：

- 除 $\texttt{Case 2}$ 外，$s_1, s_2$ 总有一个的用到的 后缀/前缀 是尽可能长的

考虑这种情况怎么做。发现难点在于一个位置 $i$ 可能提供的后缀长度为 $\{\texttt{suf[i]}, \pi[\texttt{suf[i]}], \pi[\pi[\texttt{suf[i]}]], \cdots\}$（其中 $\pi$ 即 前缀函数/kmp 的 next 数组），对于前缀也同，直接暴力统计对每个 $i$ 是 $O(m)$ 的

不妨设 $s_2$ 用到的前缀是尽可能长的，并枚举 $s_2$ 的 $l_2$，尝试寻找合法的 $s_1$（即找到 $\{\texttt{suf[}r_1\texttt{]}, \pi[\texttt{suf[}r_1\texttt{]}], \cdots\}$ 中存在一个元素等于 $m-\texttt{pre[}l_2\texttt{]}$ 的 $r_1, k\leq r_1<l_2$）。注意到根据 $\pi[.]$ 描述的关系建图，得到的图是一棵**树**；而每个 $r_1$ 产生的贡献就为，$\texttt{suf[}r_1\texttt{]}$ 到根 $0$ 的这些结点，它们的权（值的出现次数）都加一；这个用树剖什么维护下就行了（链修改，单结点查询）。实现的大致框架和 $\texttt{Part 1}$ 中的相同；不过在确定存在答案后，寻找答案位置时，是从区间边界逐个删除贡献，直到 $m-\texttt{pre[}l_2\texttt{]}$ 的个数出现变化时，即找到了答案位置；具体可见代码

最后对于 $\texttt{Case 2}$，注意到此时一定有 $r_1=k, l_2=n-k+1$，我们额外判断下这两个子串拼在一起是否可能成为答案即可（随便怎么搞，差不多做到 $O(m)$ 就行；具体也见代码X）

## CODE

解析可能写得很乱qaq，实在看不懂的话直接看代码可能好些 \fad

注意代码中许多边界情况的判断和细节的处理。例如为了处理方便而 “令” $\texttt{suf}, \texttt{pre}$ 的上限不超过 $k$（也即上面提到的），这不会影响正确性

另外这里比较懒就没打树剖...直接拉了个 Lct 过来维护

```cpp
#include <cstdio>
#include <algorithm>
using std::reverse;
using std::max;
using std::min;

const int MAXN =5e5+20;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar(); bool f =0;
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return (f) ? -x : x;
}

void write(const int &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

void read_string(char *s){
	char ch =getchar();
	while(ch < 'a' && ch > 'z')
		ch =getchar();
	int tot =1;
	while(ch >= 'a' && ch <= 'z')
		s[tot++] =ch, ch =getchar();
}

/*------------------------------Lct------------------------------*/

namespace Lct{
	bool rev[MAXN];
	int val[MAXN];
	int tag[MAXN];
	
	namespace Splay{
		int ch[2][MAXN], fa[MAXN];
		
		inline void pushdown(const int &x){
			if(rev[x]){
				rev[ch[0][x]] ^=1, rev[ch[1][x]] ^=1;
				ch[0][x] ^=ch[1][x] ^=ch[0][x] ^=ch[1][x];
				rev[x] =0;
			}
			if(tag[x]){
				if(ch[0][x])
					val[ch[0][x]] +=tag[x], tag[ch[0][x]] +=tag[x];
				if(ch[1][x])
					val[ch[1][x]] +=tag[x], tag[ch[1][x]] +=tag[x];
				tag[x] =0;
			}
		}
		
		inline bool is_top(const int &x){ return (fa[x] == 0 || (ch[0][fa[x]] != x && ch[1][fa[x]] != x)); }
		
		inline bool get_type(const int &x){ return ch[1][fa[x]] == x; }
		
		inline void rotate(const int &x){
			bool typ_x =get_type(x);
			int y =fa[x], z =fa[y], a =ch[!typ_x][x];
			fa[x] =z; if(!is_top(y)) ch[get_type(y)][z] =x;
			fa[y] =x, ch[!typ_x][x] =y;
			fa[a] =y, ch[typ_x][y] =a;
		}
		
		void pushall(const int &x){
			if(!is_top(x))
				pushall(fa[x]);
			pushdown(x);
		}
		
		void splay(const int &x){
			pushall(x);
			for(; !is_top(x); rotate(x))
				if(!is_top(fa[x])){
					if(get_type(fa[x]) == get_type(x))
						rotate(fa[x]);
					else
						rotate(x);
				}
		}
	}
	using namespace Splay;
	
	void access(const int &x){
		for(int pre =0, top =x; top; pre =top, top =fa[top]){
			splay(top);
			ch[1][top] =pre;
		}
	}
	
	inline void setroot(const int &x){
		access(x), splay(x);
		rev[x] =1;
	}
	
	inline void link(int x, int y){
		++x, ++y;
		setroot(x);
		fa[x] =y;
	}
	
	inline int query(int x){
		++x;
		splay(x);
		return val[x];
	}
	
	inline void modify(int x, const int &typ){
		++x;
		setroot(1);
		access(x), splay(x);
		val[x] +=typ, tag[x] +=typ;
	}
}
using Lct::link;
using Lct::query;
using Lct::modify;

/*------------------------------Kmp------------------------------*/

int pi[MAXN], pi_backup[MAXN]/*suf 的 pi*/;

void Kmp(const int &n, const int &m, const int &k, const char *s, const char *t, int *rem){
	pi[1] =0;
	for(int i =2; i <= m; ++i){
		int j =pi[i-1];
		while(j && t[j+1] != t[i])
			j =pi[j];
		pi[i] =(t[j+1] == t[i]) ? j+1 : 0;
	}
	for(int i =1, j =0; i <= n; ++i){
		while(j && t[j+1] != s[i])
			j =pi[j];
		if(t[j+1] == s[i])
			++j;
		if(j > k)/*为了后面方便而做的处理*/
			j =pi[j];
		rem[i] =j;
		if(j == m)
			j =pi[j];
	}
}

void Build(const int &m){
	for(int i =1; i <= m; ++i)
		link(i, pi[i]);
}

void Backup(const int &m){
	for(int i =1; i <= m; ++i)
		pi_backup[i] =pi[i];
}

/*------------------------------Main------------------------------*/

char s[MAXN], t[MAXN];
int pre[MAXN], suf[MAXN];

int cnt[MAXN];

int main(){
	int n =read(), m =read(), k =read();
	read_string(s), read_string(t);
	
	Kmp(n, m, k, s, t, suf);
	Build(m);
	reverse(s+1, s+1+n), reverse(t+1, t+1+m);
	Kmp(n, m, k, s, t, pre);
	reverse(pre+1, pre+1+n);
	
	/*Case 1*/
	/*t 是两个子串中某个子串内部的子串*/
	if(m <= k)
		for(int i =m; i <= n; ++i)
			if(suf[i] == m){
				/*在 s_1 内，在 s_2 内*/
				int start_L =max(1, i-k+1), start_R =start_L+k;
				int start_R2 =min(i-m+1, n-k+1), start_L2 =start_R2-1-k+1;
				if(start_R+k-1 > n && start_L2 < 1)
					continue;
				else{
					putchar('Y'), putchar('e'), putchar('s'), putchar('\n');
					if(start_R+k-1 > n)
						write(start_L2), putchar(' '), write(start_R2);
					else
						write(start_L), putchar(' '), write(start_R);
					return 0;
				}
			}
	/*Case 2*/
	/*因到达边界无法移动 " 框 " ( 证明中的 " 无法接着操作 " )*/
	if(n-k+1 > k){
		pi[0] =pi_backup[0] =-1;
		for(int i =pre[n-k+1]; i != -1; i =pi[i])
			++cnt[i];
		for(int i =suf[k]; i != -1; i =pi_backup[i])
			if(cnt[m-i] > 0){
				putchar('Y'), putchar('e'), putchar('s'), putchar('\n');
				write(1), putchar(' '), write(n-k+1);
				return 0;
			}
	}
	
	for(int i =k; i <= n-k; ++i)
		modify(suf[i], 1);
	for(int i =n-k+1; i > k; --i){
		if(m-pre[i] <= k && query(m-pre[i]) > 0){
			int start_L =-1, Rem =query(m-pre[i]);
			for(int j =i-1; j >= k; --j){
				modify(suf[j], -1);
				if(query(m-pre[i]) != Rem){
					start_L =j-k+1;
					break;
				}
			}
			putchar('Y'), putchar('e'), putchar('s'), putchar('\n');
			write(start_L), putchar(' '), write(i);
			return 0;
		}
		modify(suf[i-1], -1);
	}
	
	putchar('N'), putchar('o');
}
```

## 线性做法

（看完 z-algorithm 想找几道题做，想到之前做的这道题**似乎**有 z-algorithm 的线性做法就试着想了下；弄了半天搞完了就去题解区及社论比对下做法的差异，结果发现只能找到 z-algorithm 的 $\log$ 做法 \shake）

由于 kmp 的前缀函数给出的信息不太好维护，我们考虑换 z-algorithm 试试（相比之下后者的 `z[.]` 给出的 “信息” 直接是一个区间）

设 $\texttt{z\_pre}[i]$ 的值为最长的从 $s[i]$ 开始的与 $t$ 的前缀的公共子串，$\texttt{z\_suf}[i]$ 的值为最长的在 $s[i]$ 结束的与 $t$ 的后缀的公共子串（这里下标从 $0$ 开始）

我们假设最后拼接出的答案串的 $t$ 子串是从 $s[i]$ 开始的长度为 $a$ 的子串加上在 $s[j]$ 结束的长度为 $b$ 的子串。显然有 $a\leq \texttt{z\_pre}[i], b\leq \texttt{z\_suf}[j]$，并且要求这样选取的用来拼接的两个串是合法的

对于 $\texttt{Case 1}$ 的处理没什么好说的

对于 $\texttt{Case 2}$，我们可以用类似的方法，在 $a$ 或 $b$ 不取到 `z[.]` 的上界时，限制选取的用来拼接的串必须是 “紧贴” 边缘的。但不同于 kmp，我们仅能对其中一个拼接串的位置做出保证；即在 $a$ 或 $b$ 不取到 `z[.]` 给出的上界时，一定有左侧拼接串是从 $s[0]$ 开始的，或右侧拼接串是在 $s[n-1]$ 结束的。这个不像 kmp 做法那样能很轻松的 $O(n)$ 处理出来，但是也不是没有办法，并且其可以归类到 $\texttt{Case 3}$；于是我们先讨论  $\texttt{Case 3}$ 的做法

对于 $\texttt{Case 3}$。首先我们回顾下现在所拥有的限制/条件：

- 若答案 $t$ 的第一段（左侧那段）是从 $i$ 开始的，那么我们有 $a=\texttt{z\_pre}[i]$，即左侧拼接串一定在 $s[i+\texttt{z\_pre}[i]-1]$ 结束

（当然这也可以是关于 $\texttt{z\_suf}[i]$ 的，然后下面的做法都是对称的）

这样 $a$ 就固定了，我们只需找到合法的 $j$ 且其 $b=m-a$ 即可（当然还有 $a\leq k$ 什么的限制，这个在求 `z[.]` 时处理下及加一些判断就行了）。贪心地可以想到为每种 $b$ 保留**最右的**（合法的）$j$ 一定是更优的；然后询问时只需检查最右（大）的满足存在 $b=m-a$ 的 $j$ 是否合法即可

再考虑每个 $j$，会被这个 $j$ 作出贡献的 $b$ 一定是一段区间 $[l, \texttt{z\_suf}[j]]$；其中 $l$ 不一定为 $1$（另外对于 $b=0$，事实上就相当于 $\texttt{Case 1}$，并且讨论比较麻烦，这里就忽略了）是因为有强制取 $k$ 个的限制，起始下标过大可能导致超出范围。于是这就相当于区间取 $\max$，单点查询且查询仅在所有的修改操作完成后

不难想到将操作离线，按修改（取 $\max$）的值从小到大排序（可以线性桶排），这样区间取 $\max$ 就变成了区间染色。进一步又可以想到从大到小排序做，这样每个位置的最终取值就是排序后第一次被修改时的值，于是可以考虑用并查集将修改过的元素都缩起来跳过。这样这部分的复杂度就被优化到了 $\Theta(\alpha(n))$

于是 $\texttt{Case 3}$ 剩下部分就只需对每个 $i$（这时 $a=\texttt{z\_pre}[i]$）询问一次（最右的满足存在 $b=m-a$ 的 $j$）就行了，复杂度线性。刚才被搁置的 $\texttt{Case 2}$ 此时也很显然了，同样对每个满足 $i+a-1=k-1$ 的 $i, a$（即左侧拼接串从 $0$ 开始，选取的是 $s[0..(k-1)]$ 这一段）询问一次即可

这里讲得可能不是很清晰（写完后没做多少次修改 \kk），仅仅是简洁地讲了下思路；如果真的有人看到这篇题解并且感到疑惑的话可以告诉我，然后我再尽可能修缮下qaq

## CODE（线性做法）

挺气人的是由于常数以及数据不强的原因跑得比三倍常数（Splay）的 $\Theta(n\log n)$ 做法还慢（

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using std::reverse;
using std::max;
using std::min;
using std::vector;
using std::pair;
typedef pair<int, int> pad;

const int MAXN =5e5+20;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar(); bool f =0;
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return (f) ? -x : x;
}

void write(const int &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

struct string{
	char data[MAXN];
	int len;
	
	int size() const{
		return len;
	}
	void reverse(){
		std::reverse(data, data+len);
	}
	
	char & operator [] (const int &index){
		return data[index];
	}
	char operator [] (const int &index) const{
		return data[index];
	}
};

void read_string(string &s){
	char ch =getchar();
	while(ch < 'a' && ch > 'z')
		ch =getchar();
	s.len =0;
	while(ch >= 'a' && ch <= 'z')
		s[s.len++] =ch, ch =getchar();
}

/*------------------------------Z-algorithm------------------------------*/

void z_algorithm(const string &s1, const string &s2, vector<int> &z, const vector<int> &z_s2, const int &z_limit){
	const int n1 =s1.size(), n2 =min((int)s2.size(), z_limit);
	while(z[0] < n2 && s1[z[0]] == s2[z[0]])
		++z[0];
	for(int i =1, l =0, r =0; i < n1; ++i){
		if(i < r)
			z[i] =min(r-i, z_s2[i-l]);
		while(z[i] < n2 && i+z[i] < n1 && s1[i+z[i]] == s2[z[i]])
			++z[i];
		if(r < i+z[i])
			l =i, r =i+z[i];
	}
}

/*------------------------------Disjoint_Set------------------------------*/

struct disjoint_set{
	vector<int> fa;
	
	disjoint_set(const int &n){
		fa.resize(n);
		for(int i =0; i < n; ++i)
			fa[i] =i;
	}
	
	int get_fa(const int &x){
		if(fa[x] == x)
			return x;
		else
			return fa[x] =get_fa(fa[x]);
	}
	// merge <x> to <y> //
	void merge(int x, int y){/* 这里懒得带秩了 qaq，想写也完全可以 */
		x =get_fa(x), y =get_fa(y);
		fa[x] =y;
	}
};

/*------------------------------Main------------------------------*/

int main(){
	int n =read(), m =read(), k =read();
	string s, t;
	read_string(s), read_string(t);
	
	vector<int> z_pre(n, 0), z_suf(n, 0), z_t(m, 0);
	z_algorithm(t, t, z_t, z_t, k);
	z_algorithm(s, t, z_pre, z_t, k);
	s.reverse(), t.reverse();
	z_t.assign(m, 0);
	z_algorithm(t, t, z_t, z_t, k);
	z_algorithm(s, t, z_suf, z_t, k);
	reverse(z_suf.begin(), z_suf.end());
	
	auto Ans =[&](const int &t1, const int &s2){
		if(t1 == -1)
			putchar('N'), putchar('o');
		else{
			putchar('Y'), putchar('e'), putchar('s'), putchar('\n');
			write(t1-k+1 +1), putchar(' '), write(s2 +1);
		}
		return 0;
	};
	
	// Case 1 //
	if(m <= k)
		for(int i =0; i < n; ++i)
			if(z_pre[i] == m){
				int start_L =max(0, (i+z_pre[i]-1) -k+1), start_R =start_L+k;
				int start_R2 =min(i, (n-1)-k+1), start_L2 =(start_R2-1)-k+1;
				/* 注意除了在左子串内还有可能不得不在右子串内 */
				if(start_R+k-1 <= n-1)
					return Ans(start_L+k-1, start_R);
				else if(start_L2 >= 0)
					return Ans(start_L2+k-1, start_R2);
			}
	
	vector<vector<pad> > oper(n);/* 对于 x，所有使区间 ( mx[.] 的区间 ) 对 x 取 max ( 最右 ) 的操作 */
	for(int i =0; i < n; ++i){
		/* [l, r] 作为右侧拼接串能影响的答案 ( 能够提供这些长度的 t 后缀 ) */
		/* z_suf[i] == 0 的忽略不计 ( 其实也等价 Case 1 )，同时讨论也比较麻烦 */
		int l =max(1, i-min(i, (n-1)-k+1)+1), r =z_suf[i];
		if(l <= r)
			oper[i].push_back(pad(l, r));
	}
	vector<int> mx(n+1, -1);/* 每种 z_suf 最右的起点位置 */
	disjoint_set DS(n+1);
	auto modify =[&](const int &l, const int &r, const int &val){
		for(int i =DS.get_fa(l); i <= r; DS.merge(i, i+1), i =DS.get_fa(i)){
			if(mx[i] == -1)
				mx[i] =val;
		}
	};
	for(int x =n-1; x >= 0; --x)
		for(pad i:oper[x])
			modify(i.first, i.second, x);
	
	// Case 3 //
	vector<int> arr;/* list for Case 2 */
	arr.reserve(n);
	for(int i =0; i < n; ++i){
		if((i+z_pre[i]-1) /*-> t1*/ >= k && z_pre[i] <= k && m-z_pre[i] <= k)
			if(mx[m-z_pre[i]] != -1 && mx[m-z_pre[i]]-(m-z_pre[i])+1 > i+z_pre[i]-1)
				return Ans(i+z_pre[i]-1, mx[m-z_pre[i]]-(m-z_pre[i])+1);
		
		if(i <= k-1 && i+z_pre[i]-1 >= k-1)
			arr.push_back(k-1-i+1);
	}
	
	// Case 2 //
	for(int z:arr)
		if(z <= k && m-z <= k)
			if(mx[m-z] != -1 && mx[m-z]-(m-z)+1 > k-1)
				return Ans(k-1, mx[m-z]-(m-z)+1);
	
	return Ans(-1, -1);
}
```

---

## 作者：chenxia25 (赞：2)

~~昨晚[CF比赛](https://codeforces.com/contest/1206/standings/participant/27233501#p27233501)比较颓，今天有心情写题解就不错了QWQ~~

>### [洛谷题目页面传送门](https://www.luogu.org/problem/CF955D) & [CodeForces题目页面传送门](https://codeforces.com/contest/955/problem/D)

>给定字符串$a,b,|a|=n,|b|=m$，求是否可以在$a$中选$2$个长度为$s$的不相交子串，使得$b$是这$2$个串按在$a$中的顺序连起来后得到的串的子串，若可以，输出任一选法。

>$2\le m\le 2s\le n\le 5\times 10^5$。

设从$a$中选出的$2$个子串为$a1,a2$。分$2$种情况：

1. $a1$或$a2$完全包含$b$；
2. $a1$的一个后缀与$a2$的一个前缀组成$b$。

第$1$种情况比较容易，直接将$b$作为模式串匹配$a$（这里我用的是Z算法（如果聪明的读者还不知道Z算法是什么，please点击[这个](https://www.luogu.org/blog/Chenxiao-Yan/Z-algorithm)）），匹配成功的位置再分$2$种情况：$a1$包含$b$和$a2$包含$b$。$a1$包含$b$的情况考虑贪心地将$a1$最左化，好给$a2$留位置，最后如果放得下直接输出答案`return 0;`；$a2$包含$b$类似。

第$2$种情况，设$lft_i$表示满足$a_{j\sim j+s-1}$的长度为$i$的后缀匹配$b$的长度为$i$的前缀的最小的$j$，$rit_i$表示满足$a_{j\sim j+s-1}$的长度为$i$的前缀匹配$b$的长度为$i$的后缀的最大的$j$，若没有满足条件的$j$则分别为$\infty,-\infty$。“最小”和“最大”是基于贪心的思想，与第$1$种情况类似，为的是尽可能给另一个子串留位置。这样最后我们可以枚举$i\in[0,s]$，若$m-i\in[0,s]$且$lft_i+s-1<rit_{m-i}$，则存在答案$(lft_i,rit_{m-i})$。

下面考虑$lft$和$rit$数组怎么求。以$lft$为~~栗~~例，我们令$c=b+\texttt{!}+a$，对$c$跑一遍Z算法。$\forall i\in[1,n]$，考虑若$a1$的后缀从第$i$位开始，能影响到哪些$lft_j$。显然$j_{\max}=z_{c,m+1+j}$，因为最多能往后拓展$z_{c,m+1+j}$个字符，满足这个后缀与$b$的前缀匹配。$j_{\min}$呢？$j$越小，即$a1$在第$i$位后面的字符越少，那么$a1$在第$i$位前面的字符就越多，多到一定程度就会抵到位置$1$，所以$j_{\min}$是刚好抵到的情况，如果不会抵到就是$1$。于是$j_{\min}=\max(s-(i-1),1)$。算出影响范围后，我们要去“影响”啊，即令$\forall j\in[j_{\min},j_{\max}],lft_j=\min(lft_j,i+j\cancel{-1}-s\cancel{+1})$。这个可以用线段树维护，差分也可以，虽然都是$\mathrm O(n\log_2n)$，但差分好写一点。

下面讲具体怎么差分：$\forall k\in[0,m]$，维护一个添加序列$add_k$和删除序列$del_k$。对于每次影响，在$add_{j_{\min}}$和$del_{j_{\max}+1}$里插入$i-s$。最后维护一个`multiset`$st$（初始为$\{\infty\}$），从$i=1$到$i=m$递推，每次将$add_i$里的元素`insert`进去，将$del_i$里的元素`erase`掉（注意如果写`st.erase(x)`会把所有的$x$都删掉，应该写`st.erase(st.find(x))`），`*st.begin()+i`就是$lft_i$。

$rit$数组的求法类似，不同在于$c=b^\mathrm r+\texttt!+a^\mathrm r$，访问$z$数组时要访问在倒串中的位置，$j_{\min}=\max(s-(n-i),1),j_{\max}=z_{c,m+1+(n+1-i)}$，影响为$\forall j\in[j_{\min},j_{\max}],rit_j=\min(rit_j,i-j+1)$，$st$初始为$\{-\infty\}$，每次插入$i+1$，$rit_i$为`*--st.end()-i`。

下面贴代码吧：（写不动了）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int inf=0x3f3f3f3f;
const int N=500000,M=500000;
int n/*|a|*/,m/*|b|*/,s/*要选的字串的长度*/,t/*|c|*/;
int rev_pos(int pos){return n+1-pos;}//在倒串中的位置 
char a[N+5],b[M+5],ra[N+5]/*rev(a)*/,rb[M+5]/*rev(b)*/,c[N+1+M+5]/*b+'!'+a或rb+'!'+ra*/;
void con(char str1[],char str2[]){//令c=str1+'!'+str2 
	t=0;
	for(int i=1;i<=m;i++)c[++t]=str1[i];
	c[++t]='!';
	for(int i=1;i<=n;i++)c[++t]=str2[i]; 
}
int z1[N+1+M+1]/*a,b正着的z数组*/,z2[N+1+M+1]/*a,b倒着的z数组*/;
void z_init(int z[]){//Z算法 
	int zl=0,zr=0;
	for(int i=2;i<=t;i++)
		if(zr<i){
			while(i+z[i]<=t&&c[i+z[i]]==c[1+z[i]])z[i]++;
			if(z[i])zl=i,zr=i+z[i]-1;
		}
		else if(i+z[i-zl+1]<=zr)z[i]=z[i-zl+1];
		else{
			z[i]=zr-i+1;
			while(i+z[i]<=t&&c[i+z[i]]==c[1+z[i]])z[i]++;
			zl=i;zr=i+z[i]-1;
		}
}
int lft[M+1],rit[M+1];
vector<int> dadd[M+1],ddel[N+1];//差分 
multiset<int> st;
int main(){
	cin>>n>>m>>s>>a+1>>b+1;
	memcpy(ra+1,a+1,n+1);reverse(ra+1,ra+n+1);
	memcpy(rb+1,b+1,m+1);reverse(rb+1,rb+m+1);
	con(b,a);z_init(z1);
	con(rb,ra);z_init(z2);
	if(s>=m)//第1种情况 
		for(int i=1;i<=n;i++)
			if(z1[m+1+i]==m){
				int l=max(1,i-(s-m)),r=l+s;
				if(r+s-1<=n)return cout<<"Yes\n"<<l<<" "<<r,0;
				r=min(n,i+s-1)-s+1;l=r-s;
				if(l>=1)return cout<<"Yes\n"<<l<<" "<<r,0;
			}
	//第2种情况 
	for(int i=1;i<=n;i++){//对lft影响 
		int l=max(s-(i-1),1),r=z1[m+1+i];
		if(l>r)continue;
		dadd[l].pb(i-s);if(r<m)ddel[r+1].pb(i-s);
	}
	st.insert(inf);//初始化 
	for(int i=1;i<=m;i++){//递推差分求lft 
		for(int j=0;j<dadd[i].size();j++)st.insert(dadd[i][j]);
		for(int j=0;j<ddel[i].size();j++)st.erase(st.find(ddel[i][j]));
		lft[i]=*st.begin()+i;
	}
	for(int i=1;i<=m;i++)dadd[i].clear(),ddel[i].clear();//数据不清空，爆零两行泪 
	for(int i=1;i<=n;i++){//对rit影响 
		int l=max(s-(n-i),1),r=z2[m+1+rev_pos(i)];
		if(l>r)continue;
		dadd[l].pb(i+1);if(r<m)ddel[r+1].pb(i+1);
	}
	st.clear();st.insert(-inf);//初始化 
	for(int i=1;i<=m;i++){//递推差分求rit 
		for(int j=0;j<dadd[i].size();j++)st.insert(dadd[i][j]);
		for(int j=0;j<ddel[i].size();j++)st.erase(st.find(ddel[i][j]));
		rit[i]=*--st.end()-i;
	}
//	for(int i=1;i<=m;i++)printf("lft[%d]=%d rit[%d]=%d\n",i,lft[i],i,rit[i]);
	for(int i=0;i<=s;i++)if(0<=m-i&&m-i<=s)
		if(lft[i]+s-1<rit[m-i])//不相交 
			return cout<<"Yes\n"<<lft[i]<<" "<<rit[m-i],0;
	puts("No");
	return 0;
}
```

---

## 作者：Vsinger_洛天依 (赞：1)

# [CF955D Scissors](https://www.luogu.com.cn/problem/CF955D)

### 思路

首先考虑对于传进来的两个串 $s_1$ 和 $s_2$，预处理出 $s_2$ 的每个前缀在 $s_1$ 中出现的最早位置和 $s_2$ 每个后缀在 $s_1$ 中出现的最晚位置。

然后直接扫一遍就行了，复杂度 $\text O(nm)$。

### 代码


```cpp
namespace solve{
    const int N=5e5+5;
    int mod=1e9,base=131;
    int n,m,k,ans1,ans2,lm[N],rm[N];
    char s[N],t[N];
    class Hash{
     public:
        int Hash[N], poww[N];
        inline void Init(char *s) {int len=strlen(s+1);poww[0]=1;for_(i,1,len) {Hash[i]=(Hash[i-1]*base+s[i]-'a'+1) % mod;poww[i]=poww[i-1]*base%mod;}}
        inline int get(int l, int r){return ((Hash[r]-Hash[l-1]*poww[r-l+1])%mod+mod)%mod;}
    }S,T;
    inline bool Judge(){
        if (n<(k<<1)||m>(k<<1)) return 0;
        S.Init(s),T.Init(t); int pos=k;
        for_(i,1,m) lm[i]=n+1;
        for_(i,1,min(m,k)){while(pos<=n&&S.get(pos-i+1,pos)!=T.get(1,i)) pos++;if(S.get(k-i+1,k)==T.get(1,i)) pos=k;lm[i]=pos;} pos=n-k+1;
        for_(i,1,min(m,k)){ while(pos && S.get(pos,pos+i-1)!=T.get(m-i+1,m)) pos--; if(S.get(n-k+1,n-k+i)==T.get(m-i+1,m)) pos=n-k+1; rm[m-i+1]=pos; }
        for_(i,1,n-m+1){ if(S.get(i,i+m-1)==T.get(1,m)){if(k>=i&&n-k+1<=i+m-1) continue;ans1=min(max(1ll,i-k+1),n-k+1-k);ans2=max(k+1,min(n-k+1,i));return 1;}}
        for_(i,1,m-1){ if(lm[i]<rm[i+1]&&lm[i]<=n&&rm[i+1]){ans1=lm[i]-k+1;ans2=rm[i+1];return 1;} }
        return 0;
    }
    inline void In() {
        srand(time(0));mod+=rand();
        base+=rand()%10;read(n,m,k);
        FastI>>(s+1)>>(t+1);
        if(Judge()) 
            write("Yes\n",ans1," ",ans2);
        else 
            write("No");
    }
}
using namespace solve;
```

---

## 作者：abruce (赞：1)

题外话：寄了，姜布置的前面几道红题一个不会，唯独这道黄题想出来了。  
首先我们看到字符串匹配，自然想到需要 KMP。通过 KMP，我们可以方便的处理 $t$ 被 $s$ 剪下的两个串中一个完全包含的情况，我们现在只需要考虑 $t$ 被分成两份的情况。  
考虑什么时候剪出来的两个串能使其合法。设前面的串为 $s1$，后面的串为 $s2$。合法的情况即为存在一个 $p$ 使得 $s1$ 长为 $p$ 的后缀与 $t$ 长为 $p$ 的前缀相等；并且 $s2$ 长为 $m-p$ 的前缀与 $t$ 长为 $m-p$ 的后缀相等。  
也就是说，我们枚举 $p$，判断是否存在一个 $x(x\ge k)$ 使得 $s_{1\sim x}$ 与 $t$ 匹配长度可以为 $p$；且存在一个 $y(y>x,y\le n-k+1)$ 使得 $s_{y\sim n}$ 与 $t$ 的反串匹配长度为 $m-p$。我们现在需要解决的，即为这个 $p$ 所能找到的最小的 $x$，最大的 $y$。  
我们注意到一个前缀 $s_{1\sim i}$ 假设匹配了 $w$ 长度，那么必定也能匹配 $nxt_w,nxt_{nxt_w},\cdots$。由于我们知道 $nxt$ 这个关系形成了一棵树，所以我们可以在树上打个标记，然后求子树 $\min$ 和 $\max$。  
注意他剪的是长度为 $k$ 的子串，所以要注意匹配长度 $>k$ 要一直跳 $nxt$ 直到匹配长度在 $k$ 以内。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+5;
struct edge {
	int next,to;
} e[maxn*4];
char s[maxn],t[maxn];
int n,m,k,nxt[maxn],h[maxn],g[maxn],cnt,mn[maxn],mx[maxn];
void addedge1(int x,int y) {
	e[++cnt].next=h[x],e[cnt].to=y,h[x]=cnt;
}
void addedge2(int x,int y) {
	e[++cnt].next=g[x],e[cnt].to=y,g[x]=cnt;
}
void dfs1(int u) {
	for(register int i=h[u]; i; i=e[i].next) {
		int j=e[i].to;
		dfs1(j);
		mn[u]=min(mn[u],mn[j]);
	}
}
void dfs2(int u) {
	for(register int i=g[u]; i; i=e[i].next) {
		int j=e[i].to;
		dfs2(j);
		mx[u]=max(mx[u],mx[j]);
	}
}
int main() {
	scanf("%d%d%d%s%s",&n,&m,&k,s+1,t+1);
	if(n<2*k)return puts("No"),0;
	memset(mn,0x3f,sizeof(mn));
	addedge1(0,1);
	for(register int i=2,j=0; i<=m; i++) {
		while(j&&t[i]!=t[j+1])j=nxt[j];
		if(t[i]==t[j+1])j++;
		nxt[i]=j,addedge1(j,i);
	}
	for(register int i=1,j=0; i<=n; i++) {
		while(j&&s[i]!=t[j+1])j=nxt[j];
		if(s[i]==t[j+1])j++;
		while(j>k)j=nxt[j];
//		cout<<i<<' '<<j<<endl;
		if(j==m&&(i<=k||i+k<=n)) {
			puts("Yes");
			if(i>=k)printf("%d %d",i-k+1,i+1);
			else printf("%d %d",1,k+1);
			return 0;
		}
		if(i>=k)mn[j]=min(mn[j],i);
	}
	dfs1(0);
	memset(nxt,0,sizeof(nxt));
	nxt[m]=m+1,addedge2(m+1,m);
	for(register int i=m-1,j=m+1; i; i--) {
		while(j!=m+1&&t[i]!=t[j-1])j=nxt[j];
		if(t[i]==t[j-1])j--;
		nxt[i]=j,addedge2(j,i);
	}
	for(register int i=n,j=m+1; i; i--) {
		while(j!=m+1&&s[i]!=t[j-1])j=nxt[j];
		if(s[i]==t[j-1])j--;
		while(m-j+1>k)j=nxt[j];
		if(j==1&&(i>=n-k+1||i-k>=1)) {
			puts("Yes");
			if(i<=n-k+1)printf("%d %d",i-k,i);
			else printf("%d %d",n-2*k+1,n-k+1);
			return 0;
		}
		if(i<=n-k+1)mx[j]=max(mx[j],i);
	}
	dfs2(m+1);
	for(register int i=0; i<=m; i++)
		if(mn[i]<mx[i+1]) {
			puts("Yes");
			printf("%d %d",mn[i]-k+1,mx[i+1]);
			return 0;
		}
	puts("No");
	return 0;
}
```

---

## 作者：zhimao (赞：1)

呃 ， 其实本题也可以用 SAM 做的 ， 时间复杂度为 $O(26n+m)$ 。

t 的组成有两种 ：是其中一个取出的串的子串 ， 或是前一个子串的后缀与后一个子串的前缀组合而成 。

SAM 可以很方便地找出一个串中某个子串的每个结尾位置，即 $endpos$ 集合 。

则对于第一种 ，找出它最前面和最后面出现的位置 ， 判断一下即可 。

对于第二种 ，我们可以求出数组 p1 ， $p1_i$ 表示 t 的前 i 位在 s 中可行的取串的最前面的位置 。具体地说 ，在 $s$ 中取 $p_i$ 为开头的子串 ，其末尾就是 t 的前 i 位 ， 且 $p1_i$ 是最小的 。 则我们只要再倒序求一遍 $p2_i$ ，枚举前一个取出的串组成前缀长度并判断即可 。

注意本题对于 SAM 不太友好 ， 只能建一个 SAM ， 不然内存会炸 。

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000005],s1[1000005];
int n,m,k,p1[1000005],p2[1000005];
struct sam_point
{
	int fa,len,p,mi,ma,son[26];
	void clear()
	{
		fa=len=p=mi=ma=0;
		for(int i=0;i<26;i++) son[i]=0;
	}
};
struct SAM
{
	int n=1,last=1,len,hea[1000005],nex[1000005],wen[1000005];
	sam_point a[1000005];
	void add(int x,int y)
	{
		++len;
		nex[len]=hea[x];
		wen[len]=y;
		hea[x]=len;
	}
	void insert(int x,int p)
	{
		int p1=last,p2=++n;
		last=n;
		a[p2].p=a[p2].mi=a[p2].ma=p;
		a[p2].len=a[p1].len+1;
		for(;p1&&!a[p1].son[x];p1=a[p1].fa) a[p1].son[x]=p2;
		if(!p1) a[p2].fa=1;
		else
		{
			int q1=a[p1].son[x];
			if(a[p1].len+1==a[q1].len) a[p2].fa=q1;
			else
			{
				int q2=++n;
				a[q2]=a[q1];
				a[q2].p=a[q2].mi=n+1;
				a[q2].ma=0;
				a[q2].len=a[p1].len+1;
				a[q1].fa=a[p2].fa=q2;
				for(;p1&&a[p1].son[x]==q1;p1=a[p1].fa) a[p1].son[x]=q2;
			}
		}
	}
	void build()
	{
		for(int i=2;i<=n;i++) add(a[i].fa,i);
	}
	void dfs(int x)
	{
		if(a[x].p<k) a[x].p=n+1;
		for(int i=hea[x];i;i=nex[i])
		{
			dfs(wen[i]);
			a[x].p=min(a[x].p,a[wen[i]].p);
			a[x].mi=min(a[x].mi,a[wen[i]].mi);
			a[x].ma=max(a[x].ma,a[wen[i]].ma);
		}
	}
	void clear()
	{
		for(int i=1;i<=n;i++) a[i].clear();
		for(int i=1;i<=n;i++) hea[i]=0;
		len=0;
		n=last=1;
	}
}sam;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	scanf("%s",s1+1);
	for(int i=1;i<=n;i++) sam.insert(s1[i]-97,i);
	sam.build();
	sam.dfs(1);
	scanf("%s",s+1);
	int p=1,ma=0,mi=n+1;
	for(int i=1;i<=m;i++)
		if(!sam.a[p].son[s[i]-97])
		{
			p=0;
			break;
		}
		else p=sam.a[p].son[s[i]-97];
	if(p&&m<=k)
	{
		ma=sam.a[p].ma,mi=sam.a[p].mi;
		if(ma-m>=k&&ma-m+k-1<=n)
		{
			puts("Yes");
			printf("1 %d",ma-m);
			return 0;
		}
		if(ma-m>=k&&ma-m>=n-k+1)
		{
			puts("Yes");
			printf("1 %d",n-k+1);
			return 0;
		}
		if(mi+k<=n&&mi>=k)
		{
			puts("Yes");
			printf("%d %d",mi-k+1,n-k+1);
			return 0;
		}
		if(mi+k<=n&&mi<k)
		{
			puts("Yes");
			printf("%d %d",1,n-k+1);
			return 0;
		}
	}
	p=1;
	for(int i=1;i<=min(m,k);i++)
		if(!sam.a[p].son[s[i]-97])
		{
			while(i<=min(m,k)) p1[i++]=n+1;
		}
		else p1[i]=sam.a[p=sam.a[p].son[s[i]-97]].p;
	for(int i=1;i<=(m>>1);i++) swap(s[i],s[m-i+1]);
	sam.clear();
	for(int i=1;i<=n;i++) sam.insert(s1[n-i+1]-97,i);
	sam.build();
	sam.dfs(1);
	p=1;
	for(int i=1;i<=min(m,k);i++)
		if(!sam.a[p].son[s[i]-97])
		{
			while(i<=min(m,k)) p2[i++]=n+1;
		}
		else p2[i]=sam.a[p=sam.a[p].son[s[i]-97]].p;
	for(int i=max(0,m-k);i<=min(m,k);i++)
		if(p1[i]+p2[m-i]<=n)
		{
			if(!p1[i])
			{
				if(p2[m-i]+k>n) continue; else p1[i]=k;
			}
			if(!p2[m-i])
			{
				if(p1[i]+k>n) continue; else p2[m-i]=k;
			}
			puts("Yes");
			printf("%d %d",p1[i]-k+1,n-p2[m-i]+1);
			return 0;
		}
	puts("No");
}
```


---

## 作者：Dovish (赞：0)

## 题解
显然有两种情况。

第一是在 $|t|\le k$ 时，我们找到 t 最先和最后一次出现的位置讨论。

第二是将 t 分成两个段，其前缀做从 s 中选的第一个串的后缀，其后缀做从 s 中选第二个串的前缀。如果找到的两个串前者在后者之前且不相交那就是合法的一组解了。

对于前半部分，找到 t 的每一个前缀的结束位置大于等于 k 的第一次出现的位置。后半部分将串反过来考虑就同理了。

注意到，用 SAM 是可以简单地维护出每个子串的一次出现的位置的。

问题在于结束位置大于等于 k 这条限制。

注意到，SAM 的 fail 树上，如果一个状态的 $\text{endpos}$ 集合为 $V$，那么其祖先的 $\text{endpos}$ 集合 $V\in S$。

这就意味着，我们可以用子树内的信息来转移答案。

我们设 $f_u$ 表示状态 u 第一个大于等于 k 的出现位置，就有：
$$
f_u=\min_{v\in \text{son}_u}f_v
$$
初始化为：
$$
f_u=\left\{\begin{matrix}
\text{first\_pos}_u(\text{first\_pos}_u\ge k)\\ 
~~~~~~\text{inf}~~~~~~(\text{first\_pos}_u< k)
\end{matrix}\right. 
$$
然后就做完了。

注意本题非常卡，SAM 只能开一个，且状态转移想节约空间 umap 也是会被卡的。树上的转移也不能写递归。

多注意特殊情况的考虑。

## code
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(register int i=a;i<=b;++i)
#define low(i,a,b) for(register int i=a;i>=b;--i)
#define edge(i,u) for(int i=head[u];i;i=e[i].next)
using namespace std;
const int N=5e5+10,inf=1e9;
int val1[N],val2[N],ls[N],k;
namespace SAM
{
	struct sx
	{
		int len,fail,fps;
		int next[26];
	}st[N*2];
	int res,last;
	void init()
	{
		memset(st,0,sizeof st);
		st[0].fail=-1;
		last=0;
		res=0;
	}
	void sam_extend(int c)
	{
		int u=++res;
		st[u].len=st[last].len+1;
		st[u].fps=st[u].len;
		int p=last;
		while(p!=-1&&!st[p].next[c])
		{
			st[p].next[c]=u;
			p=st[p].fail;
		}
		if(p==-1)
		{
			st[u].fail=0;
		}
		else
		{
			int v=st[p].next[c];
			if(st[p].len+1==st[v].len)
			{
				st[u].fail=v;
			}
			else
			{
				int copy=++res;
				st[copy]=st[v];
				st[copy].len=st[p].len+1;
				while(p!=-1&&st[p].next[c]==v)
				{
					st[p].next[c]=copy;
					p=st[p].fail;
				}
				st[v].fail=st[u].fail=copy;
			}
		}
		last=u;
	}
}
int n,m;
char s[N],t[N];
struct sx
{
	int next,to;
}e[N*2];
int head[N*2],tot,val[2*N];
int in[2*N];
void add(int u,int v)
{
	e[++tot].next=head[u];
	e[tot].to=v;
	head[u]=tot;
	in[v]++;
}
inline void bfs()
{
	queue<int>q;
	
	rep(u,0,SAM::res)
	if(SAM::st[u].fps>=k)
	val[u]=SAM::st[u].fps;
	else val[u]=inf;
	
	rep(i,0,SAM::res)
	if(!in[i])q.push(i);
	
	while(q.size())
	{
		int u=q.front();
		q.pop();
		edge(i,u)
		{
			int v=e[i].to;
			in[v]--;
			if(!in[v])q.push(v);
			val[v]=min(val[v],val[u]);
		}
	}
}
void build()
{
	SAM::init();
	rep(i,1,n)SAM::sam_extend(s[i]-'a');
	rep(u,1,SAM::res)add(u,SAM::st[u].fail);
	bfs();
	int last=0,first=0;
	int u=0;
	rep(i,1,min(k,m))
	{
		if(SAM::st[u].next[t[i]-'a'])
		{
			u=SAM::st[u].next[t[i]-'a'];
			val1[i]=val[u];
			if(i==m)last=SAM::st[u].fps;
		}
		else break;
	}
	memset(head,0,sizeof head);
	tot=0;
	SAM::init();
	low(i,n,1)SAM::sam_extend(s[i]-'a');
	rep(u,1,SAM::res)add(u,SAM::st[u].fail);
	bfs();
	
	u=0;
	low(i,m,max(1,m-k+1))
	{
		if(SAM::st[u].next[t[i]-'a'])
		{
			u=SAM::st[u].next[t[i]-'a'];
			val2[i]=n-val[u]+1;
			if(i==1)first=n-SAM::st[u].fps+1;
		}
		else break;
	}
	if(last) 
	{
		last=max(1,last-k+1);
		int net=last+k;
		if(net+k-1<=n)
		{
			cout<<"Yes\n";
			cout<<last<<" "<<net<<'\n';
			exit(0);
		}	
	}
	if(first) 
	{
		first=min(n-k+1,first);
		int net=first-k;
		if(net+k-1<=n)
		{
			cout<<"Yes\n";
			cout<<net<<" "<<first<<'\n';
			exit(0);
		}	
	}
	
	rep(i,1,m-1)
	{
		if(val1[i]&&val2[i+1]&&val1[i]<val2[i+1])
		{
			if(val1[i]-k+1<1||val2[i+1]+k-1>n);
			else
			{
				cout<<"Yes\n";
				cout<<val1[i]-k+1<<" "<<val2[i+1]<<'\n';
				exit(0);
			}
		}
	}
	cout<<"No\n";
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>m>>k;
	rep(i,1,n)
	cin>>s[i];
	rep(i,1,m)
	cin>>t[i];
	
	build();
	return 0;
}
```

---


# Fallen Towers

## 题目描述

Pizano 建造了一个由 $n$ 座高塔组成的数组 $a$，每座高塔由 $a_i \ge 0$ 个方块组成。

Pizano 可以推倒一座高塔，使得接下来的 $a_i$ 座高塔各增加 $1$ 个方块。换句话说，他可以选取元素 $a_i$，将接下来的 $a_i$ 个元素各加 $1$，然后将 $a_i$ 设为 $0$。如果推倒的高塔方块数超出数组范围，则这些方块会消失。如果 Pizano 推倒一座 $0$ 方块的高塔，则不会发生任何变化。

Pizano 希望以任意顺序推倒所有 $n$ 座高塔，每座高塔恰好被推倒一次。也就是说，对于每个 $i$ 从 $1$ 到 $n$，他将恰好推倒位置 $i$ 的高塔一次。

此外，最终的高塔高度数组必须是非递减的。这意味着在他推倒所有 $n$ 座高塔后，对于任意 $i < j$，位置 $i$ 的高塔高度不能超过位置 $j$ 的高塔高度。

你需要输出最终高塔高度数组的最大 $\text{MEX}$ 值。

$\text{MEX}$ 是指数组中缺失的最小非负整数。

## 说明/提示

第一个测试用例的解释：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2108F/aa04335da43131aa6a37290f90705cf6ef46ee3d.png)

第二个测试用例的解释：注意所有高塔都被恰好推倒一次，且最终的高度数组是非递减的。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2108F/93831ffd87d4f17502d74b13db29c4368e8cf0f9.png)

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
8
2
1 2
4
2 1 0 0
10
5 9 3 7 1 5 1 5 4 3
10
1 1 1 1 1 1 1 1 1 1
10
3 2 1 0 3 2 1 0 3 2
5
5 2 0 5 5
1
1000000000
7
4 0 1 0 2 7 7```

### 输出

```
2
3
7
4
5
4
1
3```

# 题解

## 作者：3a51_ (赞：1)

好题，证明来自官方题解。

---

引理： 如果一个数组 $r$ 可以通过推倒这些塔得到，那么所有满足 $\forall i\in [1,n]$，$r'_i\leq r_i$ 的数组 $r'$ 也可以通过推倒这些塔得到。

证明：令 $p_i$ 表示第 $i$ 个被推倒的塔，且按照 $p$ 的顺序推倒这些塔之后可以得到数组 $r$，$s_i$ 表示按照 $p$ 的顺序推倒这些塔后有多少个块落在了位置 $i$ 上。

因为每座塔都需要恰好被推倒一次，所以想要通过推倒这些塔得到数组 $r$，需要使得第 $i$ 个塔在被推倒后有 $r_i$ 个块落在位置 $i$ 上，而这意味着第 $i$ 个塔被推倒时的高度为 $a_i+s_i-r_i$。

假设存在一个长度为 $k-1$ 的排列 $p^{(k-1)}$ 满足将前 $k-1$ 个塔按照 $p^{(k-1)}$ 的顺序推倒后，得到的数组为 $r'$ 的前 $k-1$ 项，且按照 $p^{(k-1)}$ 顺序推倒后落在位置 $i$ 上的块数 $s^{(k-1)}_i\geq s_i$。由于 $p^1=[1]$ 存在，且按照 $p^n$ 的顺序推倒后一定能得到 $r'$ 数组，所以原命题等价于当 $p^{(k-1)}$ 存在时，$p^k$ 存在。

$\forall i\in [1,k]$，根据前面的假设有 $r_i'\leq r_i$ 且 $s^{(k-1)}_i\geq s_i$，所以第 $i$ 个塔按照 $p^{(k-1)}$ 的顺序被推倒时的高度 $\geq$ 按照 $p$ 的顺序被推倒时的高度。因为 $\forall i<k$，在它们被推倒的时候高度不会比按照 $p$ 的顺序推倒时的高度低，所以这意味着当我们按照 $p^{(k-1)}$ 的顺序推倒后一定有至少 $s_k$ 个块落在位置 $k$ 上。设有 $x$ 个块落在了位置 $k$ 上（$x\geq s_k\geq r_k'$）。

容易构造使得第 $k$ 个塔最终高度为 $r_k'$ 的方案：

- 在推倒第 $(x-r_k')$ 个能够落到 $k$ 上的塔后推倒第 $k$ 个塔，这会使得最终有 $r_k'$ 个块落在位置 $k$ 上，即第 $k$ 个塔的最终高度为 $r_k'$。

证毕。

---

有了这个超级强的引理之后，不难发现答案具有单调性，考虑二分答案。而且二分答案判断以 $x$ 为 $\text{mex}$ 的可行性时只需要判定数组 $r_i'$ 能否通过推倒这些塔得到，其中 $r_i'=\max(0,x-1-n+i)$ 即可。

剩下的就很简单了，维护 `get` 表示当前位置通过推倒前面的塔获取了多少块，然后开个数组记录每个位置推倒后哪些位置能够获得一个块，顺序遍历一遍判断即可。

```cpp
int f(int x){
	int get=0,cost;memset(e,0,sizeof(e));
	rep(i,1,n){
		get-=e[i],cost=max((int)0,i-n+x);
		if(get<cost) return 0;
		if(a[i]+get-cost<n) e[a[i]+get-cost+1]++;
		get++;
	}
	return 1;
}
```

---

## 作者：EmptyAlien (赞：0)

非常神奇的结论题。

题意大概是说 $n$ 个位置，第 $i$ 个位子上有 $a_i$ 块积木，你需要安排一个顺序将他们推倒，使得最终得到的积木数量单调不降，求出可能的积木数的 mex。

其中推倒定义为将该位置积木数清零并将向后高度个位置的积木数都加上 $1$，如果超出了最后则超出的部分直接消失。

---

有个重要结论：

设 $x_i$ 与 $y_i$ 是长度为 $n$ 的两个数组，且满足 $\forall i, 0 \leq y_i \leq x_i$。

假设存在排列 $p$ 使得按照 $p$ 的顺序推倒可以得到 $x$ 那一定可以得到排列 $q$ 使得按照 $q$ 的顺序推倒可以得到 $y$。

这个结论看起来比较不可思议但是是对的，而且肥肠强。

证明：

假设 $s_i$ 是按照 $p$ 推倒的时候，总共倒在 $i$ 上的积木数，其中 $x_i$ 个在 $i$ 被推倒之后推倒的，那第 $i$ 个位置的积木数就是 $s_i - x_i + a_i$。

我们现在归纳构造。

假设现在我们有了一个 $k(k\leq n)$ 的排列 $p_k$ 满足按照 $p_k$ 的顺序推倒可以得到 $y$ 的前 $k$ 个位置的积木，并且在总共倒在 $i$ 上的积木数 $s_{k, i}$ 总是不小于 $s_i$。

当 $k=1$ 时显然成立。

假设存在 $p_{k-1}$ 满足条件我们要证存在 $p_k$ 满足条件。

由之前的条件得到： $a_i+(s_{k-1,i}-y_i) \geq a_i + (s_i - x_i)$。

于是我们发现按照 $p_{k-1}$ 的顺序推倒时，至少 $s_k$ 个积木会倒在 $k$ 上。

如果 $t > y_k$ 那设在 $k$ 上第 $t-y_k$ 个堆上的的积木的所属的积木堆 $j$，在推倒 $j$ 之后立马推倒 $k$。

如果 $t = y_k$ 那就先推倒 $k$ 再推倒其余的积木堆。

这样我们构造出了 $p_k$。

那我们只要令 $k=n$ 就得到了 $p$。

这样我们就可以得到一个推论：

如果我们能最终得到 $x$，那一定能得到一个 $y$ 使得 $y$ 的 mex 恰比 $x$ 的 mex 少一。

证明：考虑将 $z$ 设为 $\max(0, x_i - 1)$，那么我们可以根据结论推出满足条件的 $y$。

于是我们发现这个问题可以二分，我们需要判断存不存在 $p$ 使得按照这个顺序推倒得到恰好有特定 mex 的结果。

我们发现这等价于判断能不能推倒出一个形如 $[0, 0, \cdots, 0, 1, 2, \cdots, mex-1]$ 的数组。（因为任何可能的数组都可以不停地缩减成这个数组）

为了判断是否存在我们简单地贪心一遍就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MAXN = 1e5 + 5;
int n;
int a[MAXN], d[MAXN];

bool check(int x) {
    for (int i = 1; i <= n; i++)
        d[i] = 0;
    int cur = 0;
    for (int i = 1; i <= n; i++) {
        cur -= d[i];
        int need = max(0, i - (n - x + 1));
        if (cur < need) return false;
        int tmp = i + a[i] + (cur++) - need + 1;
        if (tmp <= n) d[tmp]++;
    }
    return true;
}

void work() {
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int l = 1, r = n + 1;
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    cout << l << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int T;
    cin >> T;
    while (T--) work();

    return 0;
}
```

---


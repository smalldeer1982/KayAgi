# Clearing the Snowdrift

## 题目描述

男孩 Vasya 非常喜欢旅行。特别是乘坐飞机旅行给他带来了极大的快乐。他正要飞往另一个城市，但跑道被厚厚的积雪覆盖，需要清理。

跑道可以表示为编号从 $1$ 到 $n$ 的 $n$ 个连续区域。暴风雪相当猛烈，但现在已经停止，因此 Vasya 计算出第 $i$ 个区域覆盖了 $a_i$ 米厚的积雪。针对这种情况，机场有一台工作方式相当特殊的扫雪机。每分钟，扫雪机可以执行以下操作：

- 选择一个长度不超过 $d$ 的连续区段，并从积雪最多的区域中移除一米积雪。具体来说，可以选择 $1 \le l \le r \le n$（$r - l + 1 \le d$）。然后计算 $c = \max \{ a_l, a_{l + 1}, \ldots , a_r \}$，如果 $c > 0$，则对于所有满足 $a_i = c$ 的 $i \colon l \le i \le r$，将 $a_i$ 的值减一。

Vasya 为这次飞行准备了很长时间，他想知道自己还需要等待多少时间才能让所有区域完全清除积雪。换句话说，需要计算扫雪机将所有区域的积雪清除（即对所有 $i$ 从 $1$ 到 $n$ 满足 $a_i = 0$）所需的最少分钟数。

## 说明/提示

在第一个测试用例中，存在一个最优的操作序列。首先，选择区段 $[2, 3]$ 四次。经过三次操作后，$a_2$ 将变为 $2$，数组 $a$ 将变为 $[1, 2, 2, 1, 2]$。第四次操作后，数组 $a$ 将变为 $[1, 1, 1, 1, 2]$。接下来，可以通过依次选择区段 $[1, 2]$、$[3, 3]$、$[5, 5]$ 和 $[4, 5]$ 将数组清零。

在第二个测试用例中，$d = 1$，这意味着每个区域需要独立清除，答案等于所有 $a_i$ 的总和。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
5 2
1 5 2 1 2
3 1
1000000000 1000000000 1000000000```

### 输出

```
8
3000000000```

# 题解

## 作者：xuanxuan001 (赞：4)

史。题意清晰度再现某线段树专场，样例强度与某 UBC002 不相上下，知识点分布堪比，后面忘了。

官方题解明明有更高妙的不用 LCT 的做法，但个人认为写得极其一坨，并且在提交记录中随机抽取了若干记录并没有发现不用 LCT 的，也没有发现官方题解后面的```For more details, you can read the author's solution.```中的 solution 在哪，于是在对解法进行了一些翻译和脑补后发一下这篇题解。

前面的转化是容易的，由于只会减小最大值，所以可以考虑将最大值不断减小，这样相当于需要用尽量少的线段覆盖每个最大位置恰一次，这个可以贪心解决，用一个指针从 $1$ 到 $n+1$ 扫，如果当前位置 $p$ 需要覆盖就加入区间 $[p,p+d-1]$ 并 $p \leftarrow \min(n+1,p+d)$，否则 $p \leftarrow p+1$，而需要覆盖的位置集合只有 $O(n)$ 种，因此就是需要考虑怎样快速求出这 $O(n)$ 个答案。

LCT 的做法就是将贪心过程中的指针移动看做是在树上跳祖先，区间数就是一个带权深度。每次插入一个需要覆盖的点相当于修改一个点的父亲，这个断边并加边可以在 LCT 上实现。赛时我尝试使用分块，但发现 $O(n\sqrt n)$ 跑不过去。也想到了 LCT，但感觉要想从我不知道多少年前那只写过一次的 LCT 模板改过来有点困难，就没去尝试，但好像需要改的不多，因为模板题也是查询路径信息。

官方题解是考虑将这 $n$ 次贪心放到一起做，并且将它们按照集合大小排列，一开始这 $n$ 个指针都在 $1$ 位置，然后依次考虑 $p = 1,2,\cdots ,n$。那么发现其实就是将这些指针的一个后缀中小于等于 $p$ 的指针全部置成 $\min(n+1,p+d)$，并给答案加上被改变的指针的权值和。

那么再梳理一下，记录 $S_i$ 表示目前在位置 $i$ 的指针编号集合，初始 $S_1 = \{1,2,\cdots,n\}$，$S_{2 \rightarrow n} = \emptyset$。

然后对于 $p = 1 \rightarrow n$：

1. 如果 $p > 1$，$S_p \rightarrow S_p \cup S_{p-1}$（将前面的 “小于等于 $p$ 直接通过取并维护后缀并，就只需要查询单点了”）。
2. 找到 $p$ 位置对应的 $l$（其实就是这个位置的 $a$ 在 $n$ 个数中的排名），然后 $\forall x \in S_p , x \ge l , S_p \leftarrow S_p/\{x\},S_{p+d} \leftarrow S_{p+d} \cup \{x\}$。发现 $> n$ 的下标都没用，所以只需要对 $p + d \le n$ 的部分做后面的插入操作，其他的只需要删除即可。

那么这操作其实是什么？对 $S$ 中的元素按大小建动态开点线段树，上面的两个操作其实就是线段树合并和线段树分裂。

复杂度分析，分裂的复杂度本身就是 $\log n$，合并的复杂度分析考虑使用势能分析，后面忘了。在这里我绞尽脑汁没有想到一个合理的势能分析方法。颜色连续段不行，因为一次合并并不一定会用 $O(\log n)$ 减小一个势能，让合并进行下去的两个连续段可能在值上并不挨着。也考虑了一些对满足一些条件的非同色连续段二元组的数量统计，但也找不到一个好的条件来满足修改最多增加 $O(1)$，合并每次会减少 $O(1)$。如果有人想到了好的证明方式欢迎在评论区留言~~顺便把我 D 一顿~~。[代码](https://codeforces.com/contest/2097/submission/317423868)。

upd on 2025/6/17：补充线段树合并复杂度证明，写这篇题解时的我可能是奶龙，对线段树合并复杂度分析没概念。就是考虑每个线段树的节点，考虑它包含的这些值，设有 $l$ 个，维护每颗线段树分别包含的这 $l$ 个元素的集合。那么发现只要线段树合并递归到了这个节点就必然会导致两个集合合并，而只有在线段树分裂递归到这里的时候会导致这个节点的某个集合分裂为两个，因此对于这个节点可以势能分析出这个节点的复杂度就等于它被分裂调用到的次数，而分裂单次只调用 $\log n$ 个节点，因此复杂度为 $O(n \log n)$。

---

## 作者：TTpandaS (赞：3)

操作只和最大值有关，全局最大值在某一时刻会变成次小值，所以每次将最大值一起考虑，每一组操作用相同的策略把最大值全部减一，直到变成次大值。依此类推，直到将所有数变为零。

拿出当前所有最大值的位置 $p_1,p_2,\cdots,p_k$，现在问题转变为 $x$ 轴上有 $k$ 个点，问最少需要用多少条长度为 $d$ 的线段覆盖所有点。显然可以用贪心解决：每次找到未被覆盖的最左侧点，将其作为线段左端点覆盖一条长度为 $d$ 的线段，并重复上述操作直到所有点均被覆盖。

模拟上述操作，时间复杂度 $O(n^2)$，考虑加速上述操作的实现过程。

令 $f_i$ 表示将坐标大于等于 $i$ 的点全部覆盖所需的最小线段数。令 $pos$ 表示坐标大于等于 $i$ 的坐标最小的点，则 $f_i=f_{pos+d}+1$。将 $pos+d$ 记为 $i$ 的决策点。

考虑分块进行 DP，重新定义 $f_i$ 表示将坐标大于等于 $i$ 且与 $i$ 属于同一个块中的点全部覆盖所需的最小线段数。同时记录 $i$ 在下一块中的决策点。

从大到小将 $a_i$ 的下标进行更新，只需要更新其所在块中的 $f$ 即可。

对于查询答案，只需要从第一个块开始累积块中的答案，并依次跳到下一个块中决策点即可。

时间复杂度 $O(\max{nB,\dfrac{n^2}{B}})$，时限 $2$ 秒，不可过。

考虑到每次更新并不需要跑完整个块，只需要从更新点跑到所在段的左端点，因此对于总体更新的时间复杂度会带上一个小于 $0.5$ 的常数，因此可以尝试将块长适当调大。

实测块长调整为 $2000$ 即可通过此题。

[submission](https://codeforces.com/contest/2097/submission/317795256)

---

## 作者：BPG_ning (赞：2)

简单题，没场切应该是因为被 d 卡空间部分击败。

（题外话：d 开 `256MB` 的目的是啥？强迫你手写动态空间 `bitset`？）

考虑你的策略是将最大值推平，具体来说将 $a_i=\max$ 的位置视为 $1$，否则视为 $0$，那么你需要最小化长度为 $d$ 的区间个数去包含所有的 $1$。离散化之后你需要维护：单点将 $0$ 赋值为 $1$ 和全局查询上述问题。

考虑暴力就是从一个位置 $x$ 跳到 $\geq x+d$ 的第一个 $1$，直接维护这个跳的路径是不好做修改的，考虑建模：将 $0$ 点 $x$ 的父亲设为 $x+1$，$1$ 点 $x$ 的父亲设为 $\min(x+d,n+1)$，那么询问答案即为 $1$ 到 $n+1$ 的点权和，修改只要修改一个点的父亲，LCT 维护即可。由于维护信息简单，类似弹飞绵羊，所以只需要实现 LCT 的部分功能。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=5e5+10;
int n,d,a[N];
namespace LCT{
    int fa[N],ch[N][2],a[N],W[N];
    void init(){
        for(int i=1;i<=n+1;i++){
            ch[i][0]=ch[i][1]=0;
            fa[i]=i+1;
            a[i]=W[i]=0;
        }
        fa[n+1]=0;
    }
    int chk(int x){return (ch[fa[x]][1]==x);}
    int is_root(int x){return (ch[fa[x]][0]!=x && ch[fa[x]][1]!=x);}
    void pushup(int x){W[x]=W[ch[x][0]]+W[ch[x][1]]+a[x];}
    void rotate(int x){
        int y=fa[x],z=fa[y],o=chk(x),t=ch[x][o^1];
        ch[y][o]=t,fa[t]=y;
        if(!is_root(y)) ch[z][chk(y)]=x; fa[x]=z;
        ch[x][o^1]=y,fa[y]=x;
        pushup(y);
        pushup(x);
        pushup(z);
    }
    void splay(int x){
        while(!is_root(x)){
            int f=fa[x];
            if(!is_root(f)){
                if(chk(x)==chk(f)) rotate(f);
                else rotate(x);
            }
            rotate(x);
        }
    }
    void Access(int x){
        for(int p=0;x;p=x,x=fa[x]){
            splay(x);
            ch[x][1]=p;
            pushup(x);
        }
    }
    int query(int x){
        Access(x);
        splay(x);
        return W[x];
    }
    void upd(int x){
        Access(x);
        splay(x);
        a[x]++,W[x]++;
        fa[ch[x][0]]=0;
        ch[x][0]=0;
        fa[x]=min(x+d,n+1);
    }
}
int p[N];
bool cmp(int i,int j){return a[i]<a[j];}
void read(){
    cin>>n>>d;
    for(int i=1;i<=n;i++) cin>>a[i],p[i]=i;
    LCT::init();
    sort(p+1,p+1+n,cmp);
}
void work(){
    LL ans=0;
    for(int i=n;i>=1;i--){
        LCT::upd(p[i]);
        ans+=1LL*(a[p[i]]-a[p[i-1]])*LCT::query(1);
    }
    cout<<ans<<'\n';
}
int main(){
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);
    // freopen("nzq.in","r",stdin);
    // freopen("nzq.out","w",stdout);
    int T=1;
    cin>>T;
    while(T--){
        read();
        work();
    }
    cerr<<1.0*clock()/CLOCKS_PER_SEC<<'\n';
    return 0;
}
```

---


# Speedbreaker Counting (Hard Version)

## 题目描述

[DRG - Limbo](https://soundcloud.com/drg72711/limbo)

⠀

这是该问题的困难版本。在三个版本中，$ n $ 的限制和时间限制不同。只有当你解决了所有版本的问题后，才能进行 hack。

以下是 D1B 问题的描述：

- 有 $ n $ 个城市排成一行，从左到右编号为 $ 1, 2, \ldots, n $。
  - 在第 $ 1 $ 时刻，你征服恰好一个城市，称为起始城市。
  - 在第 $ 2, 3, \ldots, n $ 时刻，你可以选择一个与已征服城市相邻的城市并征服它。
  
  如果对于每个 $ i $，你在不晚于 $ a_i $ 的时刻征服了城市 $ i $，则你获胜。是否存在获胜策略，也取决于起始城市。问有多少个起始城市可以让你获胜？

对于每个 $ 0 \leq k \leq n $，统计有多少个正整数数组 $ a_1, a_2, \ldots, a_n $ 满足：

- 对于每个 $ 1 \leq i \leq n $，$ 1 \leq a_i \leq n $；
- D1B 问题的答案为 $ k $。

答案可能非常大，因此你需要对给定的质数 $ p $ 取模后输出。

## 说明/提示

在第一个测试用例中：

- 有 $ 1 $ 个好的起始城市的数组：$ [1] $。

在第二个测试用例中：

- 有 $ 0 $ 个好的起始城市的数组：$ [1, 1] $；
- 有 $ 1 $ 个好的起始城市的数组：$ [1, 2] $，$ [2, 1] $；
- 有 $ 2 $ 个好的起始城市的数组：$ [2, 2] $。

在第三个测试用例中：

- 有 $ 0 $ 个好的起始城市的数组：$ [1, 1, 1] $，$ [1, 1, 2] $，$ [1, 1, 3] $，$ [1, 2, 1] $，$ [1, 2, 2] $，$ [1, 3, 1] $，$ [1, 3, 2] $，$ [2, 1, 1] $，$ [2, 1, 2] $，$ [2, 2, 1] $，$ [2, 2, 2] $，$ [2, 3, 1] $，$ [2, 3, 2] $，$ [3, 1, 1] $；
- 有 $ 1 $ 个好的起始城市的数组：$ [1, 2, 3] $，$ [1, 3, 3] $，$ [2, 1, 3] $，$ [3, 1, 2] $，$ [3, 1, 3] $，$ [3, 2, 1] $，$ [3, 3, 1] $；
- 有 $ 2 $ 个好的起始城市的数组：$ [2, 2, 3] $，$ [2, 3, 3] $，$ [3, 2, 2] $，$ [3, 3, 2] $；
- 有 $ 3 $ 个好的起始城市的数组：$ [3, 2, 3] $，$ [3, 3, 3] $。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
11
1 998244353
2 998244353
3 998244353
4 998244353
5 998244353
6 998244353
7 998244353
8 998244353
9 998244353
10 102275857
10 999662017```

### 输出

```
0 1 
1 2 1 
14 7 4 2 
183 34 19 16 4 
2624 209 112 120 48 12 
42605 1546 793 992 468 216 36 
785910 13327 6556 9190 4672 2880 864 144 
16382863 130922 61939 94992 50100 36960 14256 4608 576 
382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 
20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 
944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400```

# 题解

## 作者：EuphoricStar (赞：4)

考虑如何解决 D1B。

发现我们可以使用这样的策略（称其为策略 1）：设当前扩展到的区间为 $[i, j]$，若区间右侧存在一个 $k$ 使得 $a_k = k - i + 1$（即若下一步不往右走那么这个点的限制就无法满足），就往右走；否则往左走。这样对于一个固定的 $a$ 和出发点，移动的序列是确定的，于是可以考虑对移动序列计数。

大眼观察或者打表可以发现**关键结论：合法的出发点一定是一段区间**。我们有更强的结论：**设 $I = \bigcap\limits_{i = 1}^n [i - a_i + 1, i + a_i - 1]$，那么合法的出发点集合要么是 $I$，要么是空集。**

证明大概就是，首先 $I$ 之外的点一定不合法，然后考虑使用这样一种策略（称其为策略 2）：设当前扩展到的区间为 $[i, j]$，若区间左侧存在一个 $k$ 使得 $a_k = j - k + 1$ 就往左走，若区间右侧存在一个 $k$ 使得 $a_k = k - i + 1$ 就往右走，若都不满足就往任意一个方向走。按照策略 2，在 $I$ 中任意一个点出发，都会先走完 $I$ 中的所有点，再走到其他点（走到 $I$ 的左端点或者右端点时一定可以往另一个方向走）。所以 $I$ 中的出发点，要么全部合法，要么全部不合法。

得到这个结论和移动的策略，计数就相对套路了。钦定一个合法区间 $[l, r]$，计算出 $[l, r]$ 都是合法出发点的方案数 $f_{l, r}$，最后做一个二维前缀和状物（容斥）即可算出每个区间 $[l, r]$ 恰好是合法出发点集合的方案数。

考虑钦定完合法区间后如何计数。直接按照策略 1 对移动序列计数。考虑区间 DP，设 $g_{i, j, 0/1}$ 表示当前扩展到的区间为 $[i, j]$，下一步是否被钦定往右走的移动方案数。有转移：

- $g_{i, j + 1, 1} \gets g_{i, j, 1} \times (n - (j - i + 2) + 1)$，转移系数的意义是 $a_{j + 1} \ge j - i + 2$。
- $g_{i, j + 1, 0} \gets g_{i, j, 1}$，表示 $a_{j + 1}$ 就是那个要求往右走的点，需要满足 $a_{j + 1} = j - i + 2$。
- $g_{i - 1, j, 0} \gets g_{i, j, 0} \times (n - (j - i + 2) + 1)$，转移系数的意义是 $a_{i - 1} \ge j - i + 2$。
- $g_{i - 1, j, 1} \gets g_{i, j, 0} \times (n - (j - i + 2) + 1)$，转移系数意义同上。

初值为 $g_{l, r, 0} = g_{l, r, 1} = 1$，表示钦定一开始扩展的区间就是 $[l, r]$（因为我们知道若 $[l, r]$ 是合法出发点区间那么一定可以先访问完 $[l, r]$ 中的所有点再访问其他点）。别忘了 $[l, r]$ 中 $a$ 的取值也需要确定。对于 $i \in [l, r]$，$a_i$ 需要 $\ge \max(i - l + 1, r - i + 1)$，所以 $f_{l, r} = g_{1, n, 0} \times \prod\limits_{i = l}^r (n - \max(i - l + 1, r - i + 1) + 1)$。

枚举 $[l, r]$ 再区间 DP，时间复杂度 $O(n^4)$，可以通过 Easy Version。

发现枚举 $[l, r]$ 再 DP 太浪费了。发现 DP 形式都相同，考虑使用**反推贡献系数**的 trick（这个 trick 在 [CF1810G](https://www.luogu.com.cn/problem/CF1810G) 也用到过）。更改 $g_{i, j, 0/1}$ 的定义，它表示原来 DP 数组的这一位对答案的贡献。初值为 $g_{1, n, 0} = 1$，转移倒过来即可。设 $h_i = \prod\limits_{j = 1}^i (n - \max(j, i - j + 1) + 1)$，那么 $f_{l, r} = (g_{l, r, 0} + g_{l, r, 1}) h_{r - l + 1}$。

时间复杂度 $O(n^2)$。

[$O(n^4)$ 代码](https://codeforces.com/problemset/submission/2018/286455722)

[$O(n^2)$ 代码](https://codeforces.com/problemset/submission/2018/286456124)

---

## 作者：Meatherm (赞：4)

### 结论 1

对于一个给定的序列 $a = [a_1,a_2,\cdots,a_n]$ 和一个合法的起始位置 $x$，按照下列方式移动必然是可行的：

- 记当前经过了区间 $[i,j]$。如果区间右侧有某个元素 $k$，使得 $k-j = a_k - (j-i+1)$，此时如果不往右移动，该位置的限制将会被破坏。此时，向右移动（$[i,j] \to [i,j+1]$）。
- 否则，向左移动（$[i,j] \to [i-1,j]$）。

我们发现，我们贪心地在不破坏右侧限制的前提下，尽量多地向左移动了。因此，如果 $a$ 序列和起始位置 $x$ 合法，那么这样移动一定合法。反之，如果在某一步中发现当前位置的限制被破坏，$x$ 必然不是一个合法的位置。

这样，一个合法的起始位置 $x$ 可以按照上述方式唯一对应一种移动序列。

### 结论 2

对于一个给定的序列 $a= [a_1,a_2,\cdots,a_n]$，如果 $x$ 是一个合法的起始位置，那么 $\forall 1 \leq i \leq n,x \in [i - a_i + 1, i + a_i - 1]$ 必须成立。这是因为，对于位置 $i$，只有从 $[i - a_i + 1, i + a_i - 1]$ 中的某个位置出发，才能在 $a_i$ 步以内到达 $i$。

一个合理的猜测是，答案就是 $[l,r] = \bigcap\limits_{ i=1}^{n} [i - a_i+1,i+a_i - 1]$。事实上这一条件并不充分：注意到 $n = 5,a= [3,5,5,5,3]$ 的答案为 $0$，尽管有 $[l,r] = [3,3]$。当我们从 $x = 3$ 出发的时候，不管往哪一侧走，另一侧的限制都会被破坏。

另一个更为合理的猜测（或者，打表发现）是，要么 $x \in [l,r]$ 全部是合法的，要么 $x \in [l,r]$ 全部都不合法。这个猜测是正确的。

想要证明这个猜测，只需要说明：如果区间 $[l,r]$ 的某个 $x$ 合法，那么按照下列移动方式必然是可行的：从 $[x,x]$ 开始，首先向右拓展到区间 $[x,r]$，然后向左拓展到区间 $[l,r]$；然后，按照结论 1 中提到的方式进行移动。

这样，对于区间 $[l,r]$ 的其它起始位置 $x'$，我们可以修改关于 $x$ 的移动序列的前 $(r-l)$ 步，来得到关于 $x'$ 的合法移动序列。

### 设计 DP (F1)

根据上面两个结论，我们可以设计 DP。

首先，我们钦定答案区间 $[l,r]$，并要求真实序列的答案区间包含 $[l,r]$。此时，$a_p$ 有下界限制 $b_p = \max(p - l + 1, r - p + 1)$。同时，如果某个位置 $p$ 是当前经过区间 $[i,j]$ 最后一个被经过的位置，那么还有一个附加限制 $a_p \geq j - i +1$。

设 $dp(i,j,0/1)$ 表示：从 $[i,j]$ 中的某个位置出发，当前经过了区间 $[i,j]$，且下一步是否被强制向右移动的合法移动方案数。初始有 $dp(i,i,0) = n - b_i + 1$。

考虑转移，分别有：

- 最后一步向左移动。这样，上一步结束时必须没有被强制向右移动。

  此时 $dp(i+1,j,0)$，转移到 $dp(i,j,0)$，贡献为 $(n-\max(b_i,j-i+1)+1)dp(i+1,j,0)$。

- 最后一步向右移动。有如下几种情况：

  - 若 $a_j = j-i+1$，则下一步不再被强制向右移动。

    此时 $dp(i,j-1,0/1)$，转移到 $dp(i,j,0)$，总贡献为 $[b_j \leq j-i+1](dp(i,j-1,0)+dp(i,j-1,1))$。

  - 若 $a_j \geq b_j$，且 $a_j \neq j-i+1$，则下一步被强制向右移动。

    此时 $dp(i,j-1,0/1)$ 均转移到 $dp(i,j,1)$，总贡献为 $(n-\max(b_j,j-i+1)+1 - [b_j \leq j-i + 1])(dp(i,j-1,0)+dp(i,j-1,1))$。

$dp(1,n,0)$ 即为答案。

记 $f(l,r)$ 为钦定答案区间为 $[l,r]$ 时的 $dp(1,n,0)$，则利用二维差分可以求出 $f'(l,r)$，表示真实序列的答案区间恰好为 $[l,r]$ 时，移动序列的数量。

注意到此时一个答案区间为 $[l,r]$ 的 $a$ 序列恰好对应了 $(r-l+1)$ 种移动序列。记答案为 $i$ 的 $a$ 序列数量为 $ans_i$，则 $f'(l,r)$ 对 $ans_{r-l+1}$ 的贡献为 $\frac{1}{r-l+1} f'(l,r)$。

时间复杂度 $O(n^4)$。部分代码（完整代码见[此处](https://codeforces.com/contest/2018/submission/284921688)）：

```cpp
inline void calc(int l,int r){ // 钦定 [l,r] 合法 
	for(int i=1;i<=n;++i) b[i]=std::max(r-i+1,i-l+1);
	for(int i=1;i<=n;++i) dp[i][i][0]=n-b[i]+1;
	for(int len=2;len<=n;++len){
		for(int i=1,j=len;j<=n;++i,++j){
			dp[i][j][0]=dp[i][j][1]=0;
			add(dp[i][j][0],mul(n-std::max(b[i],j-i+1)+1,dp[i+1][j][0]));
			if(b[j]<=j-i+1) add(dp[i][j][0],adc(dp[i][j-1][0],dp[i][j-1][1]));
			add(dp[i][j][1],mul(n-std::max(b[j],j-i+1)+1-(b[j]<=j-i+1),adc(dp[i][j-1][0],dp[i][j-1][1])));
		}
	}	
	return;
}
```

### 优化 (F2 / F3)

考虑改变移动方式。如果我们钦定了 $[l,r]$ 合法，则我们的移动策略是：

- 从 $x = r$ 出发，经过区间 $[l,r]$。然后再用之前的策略。

这样，当我们钦定 $[l,r]$ 合法的时候，每个 $a$ 序列都只对应了 $1$ 种移动序列。

同时有结论：

- 对于 $i <l,j \geq r$ 的区间，如果我们从 $[i+1,j]$ 向左移动到 $[i,j]$，则我们只关心 $a_i \geq (j-i+1)$ 这一条限制。
- 对于 $i \leq l,j > r$ 的区间，如果我们从 $[i,j-1]$ 向右移动到 $[i,j]$，则我们只关心 $a_j \geq (j-i + 1)$ 这一条限制。

这很好证明。以 $i$ 为例，考虑 $\max(r-i+1,i-l+1)$ 这个式子，如果 $i < l$，$(i-l+1)$ 这部分不造成任何限制，同时 $(r-i+1)$ 的限制不如 $(j-i+1)$ 的限制严格。对于 $j$ 的情形是对称的。

因此，考虑倒序 DP：从 $dp(1,n,0)$ 出发向内扩展，到 $dp(l,r,0/1)$ 停止。区间内部的填数方案是容易计算的，只要保证 $a_p \geq \max(r-p+1,p-l+1)$ 就可以了。同时不难发现对于 $(r-l+1)$ 相等的区间 $[l,r]$，区间内部的填数方案都会相同。因此我们可以 $O(n^2)$ 预处理出 $val(i)$，表示长度为 $i$ 的区间内部的填数方案。

那么，钦定 $[l,r]$ 合法的时候，合法的 $a$ 序列数量就是 $val(r-l+1) \times (dp(l,r,0)+dp(l,r,1))$。这就是 $f'(l,r)$。接下来只需要使用相同的二维差分，就可以类似地求出答案（这一次不需要乘上 $\frac{1}{r-l+1}$ 了，因为移动序列和合法的 $a$ 序列是一一对应）。

时间复杂度 $O(n^2)$。

```cpp
# include <bits/stdc++.h>

const int N=3005,INF=0x3f3f3f3f;

inline int read(void){
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-') f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;
}

int n,mod;

inline int adc(int a,int b){
	return (a+b>=mod)?(a+b-mod):(a+b);
}
inline int dec(int a,int b){
	return (a<b)?(a-b+mod):(a-b);
}
inline int mul(int a,int b){
	return 1ll*a*b%mod;
}
inline void add(int &a,int b){
	a=adc(a,b);
}
inline void del(int &a,int b){
	a=dec(a,b);
}

int ans[N];
int dp[N][N][2],ret[N][N];
int val[N];

inline void solve(void){
	n=read(),mod=read();
	
	for(int i=0;i<=n+1;++i) for(int j=0;j<=n+1;++j) dp[i][j][0]=dp[i][j][1]=ret[i][j]=ans[i]=0;
	dp[1][n][0]=1;
	
	for(int len=n-1;len;--len){
		for(int l=1,r=len;r<=n;++l,++r){
			int w=n-len;
			if(l>1)
				add(dp[l][r][0],mul(w,adc(dp[l-1][r][0],dp[l-1][r][1])));
			if(r<n)
				add(dp[l][r][1],dp[l][r+1][0]),add(dp[l][r][1],mul(w,dp[l][r+1][1]));
		}
	}
	
	for(int i=1;i<=n;++i){
		val[i]=1;
		for(int j=1;j<=i;++j) val[i]=mul(val[i],n-std::max(j,i-j+1)+1);
	}
	
	for(int l=1;l<=n;++l) for(int r=l;r<=n;++r)
		ret[l][r]=mul(val[r-l+1],adc(dp[l][r][0],dp[l][r][1]));

	for(int len=1;len<=n;++len){
		for(int l=1,r=len;r<=n;++l,++r){
			del(ret[l][r],dec(adc(ret[l-1][r],ret[l][r+1]),ret[l-1][r+1]));
			add(ans[len],ret[l][r]);
		}
	}
	ans[0]=1;
	for(int i=1;i<=n;++i) ans[0]=mul(ans[0],n);
	for(int i=1;i<=n;++i) del(ans[0],ans[i]);
	for(int i=0;i<=n;++i) printf("%d ",ans[i]); puts("");
	return;
}

int main(void){
	int T=read();
	while(T--) solve(); 

	return 0;
}
```

附注：感谢 Tx_Lcy 老师的指导（好像暴露了身份www）。

---

## 作者：KaisuoShutong (赞：3)

## CF2018F3 Speedbreaker Counting (Hard Version)

### 题目描述

对于题目 CF2018B，我们有如下过程：

> 给定一个 $n$ 个元素的数列 $a$。
>
> 你可以选择一个元素 $[i,i]$ 作为起始区间。每次操作时，可以将区间 $[l,r]$ 扩展为 $[l-1,r]$ 或 $[l,r+1]$。
>
> 要求每个元素必须在第 $a_i$ 次及之前被扩展到。求有多少个元素作为起始区间时存在合法扩展方案。

请你对于 $\forall 1\le k\le n$，求出最终合法起始元素有 $k$ 个的所有数列 $a$ 的个数（$1\le a_i\le n$）。

多组数据，$\sum n\le 3000$，答案对素数 $p$ 取模。

### 解法

CF2018B 有多种可能的解法。然而不幸的是，大部分解法缺乏扩展性，所以无法被应用于对该问题的计数中。

所以我们尝试找到一个尽量简单的策略来表征对于每个起始元素 $i$ 进行的操作。

一个容易想到的做法是，每次向当前未被访问的点中 $a_i$ 最小的点扩展一步。这个策略的正确性是显然的。

此策略的一个改良是，若当前存在一个点 $j$ 使得当前能扩展到它的最小时间为 $a_j$（也就是不能向另一个方向扩展哪怕一步，下称满足此条件的元素为紧迫元素），则扩展该方向。否则，扩展任意方向。这个策略的正确性也是显然的。

由这个策略，我们断言：最终合法的起始元素构成一个连续区间 $[L,R]$。

证明考虑，若存在三个位置 $i\lt j\lt k$ 满足 $i$、$k$ 均可作为合法起始元素，但 $j$ 不可作为合法起始元素，则 $\exists p\lt j$ 使得以 $j$ 为起始点时无法合法扩展到 $p$，即 $\exists p_2\gt j$ 使得 $a_{p_2}\lt a_p$ 且 $p_2-p+1\gt a_p$。

此时，若 $p_2\le k$，显然 $k-p+1\ge p_2-p+1\gt a_p$；否则，若 $p_2>k$，也有 $p_2-p+1\gt a_p$。

则 $k$ 亦不为合法起始元素，矛盾。$p\gt j$ 时同理。故原命题成立。

考虑一个连续区间是容易被多个区间的交所表征的。故在此基础上，我们进一步断言：合法的起始元素区间 $[L,R]$ 等价于 $\displaystyle \bigcap_{i=1}^n [i-(a_i-1),i+(a_i-1)]$ 或 $\varnothing$。

考虑证明。对于不在此区间内的点显然无法在合法时间内访问（即 CF2018B 题解中提到的条件 1）。

而对于在此区间内的点，我们只需证明以该区间中任一点作为起始元素，都将先访问所有该区间中的点。

考虑改良的策略。因为 $\forall j\lt L$，都有 $j+a_j-1\gt R$，故 $a_j\gt R-j+1\gt R-L+1$，$\forall j\gt R$ 同理，所以在完全访问 $[L,R]$ 之前，都不存在一个区间外的位置被强制向该方向扩展。所以对于前 $R-L+1$ 次扩展，可以将 $[L,R]$ 区间完全扩展而并不违反改良的策略。

如此就证明了对于 $\forall i\in [L,R]$，其合法性是一致的。接下来尝试计数。

枚举最小的合法区间左右端点 $L$、$R$，此时对于 $\forall 1\le i\le n$，$a_i\ge \max\left\{i-L+1,R-i+1\right\}$。这样最终的答案区间一定包含 $[L,R]$。

考察上述改良的策略，容易发现其选择方案不是唯一的。这并不利于对其进行 dp，尝试将过程唯一化。仅需为所有随机的扩展都强制定向（例如向左）即可。

在此基础上，设 $f_{l,r,0/1}$ 表示当前扩展了 $[l,r]$ 区间，之前的最后几次扩展是否因为一个处于 $[l,r]$ 之外的紧迫元素而向右扩展。转移过程是 trivial 的，具体来说：

情况 1：由 $[l,r-1]$ 扩展而来，此次向右扩展。则必须由 $f_{l,r-1,1}$ 转移而来。

- 转移到 $f_{l,r,0}$，则由 $a_r$ 充当之前扩展中可能要求其向右扩展的紧迫元素。此时要求 $a_r=r-l+1$。
- 转移到 $f_{l,r,1}$，则这样的元素不由 $a_r$，而是由 $[r+1,n]$ 中某个元素充当。此时要求 $a_r\in[r-l+1,n]$。

情况 2：由 $[l+1,r]$ 扩展而来，此次向左扩展。则必须由 $f_{l+1,r,0}$ 转移而来。

- 此时要求 $a_l\in[r-l+1,n]$。

最终做一个二维差分即可得到最终答案为区间 $[L,R]$ 的所有 $a$ 序列数量（乘一个 $\dfrac{1}{R-L+1}$ 去一下重就行）。

这样得到的算法是 $O(n^4)$ 的，可以通过 F1。为了优化这样的复杂度，考虑合并一些计算。

容易发现，不同的 $L$、$R$ 只会影响每个元素的下界 $\max\left\{i-L+1,R-i+1\right\}$，即 $\max\left\{\mid i-L\mid,\mid i-R \mid \right\}+1$。所以我们本质上只是找到了两个位置 $L$、$R$ 来做这个事情。

那么我们固定所有 $R-L$ 相等的 $[L,R]$ 在 $[n-(R-L),n]$，并且对 $[1,2n]$ 做上述 dp，那么 $[L,R]$ 的答案就可以在 $[n+1-R,2n-R]$ 得到。

时间复杂度优化到 $O(n^3)$，可以通过 F2。

进一步地，根据之前的理论，我们说明了每次可以先扩展 $[L,R]$ 区间。同时，在 $[L,R]$ 之外的区间进行扩展时，我们预设的下界 $\max\left\{i-L+1,R-i+1\right\}$（$i=l$ 或 $i=r$）其实不如 $r-l+1$ 的限制紧。因此，在 $[L,R]$ 外的转移与 $[L,R]$ 是完全无关的。而 $[L,R]$ 内的转移又只和 $R-L$ 有关，且很容易被线性计算。

因此做法就变得很简单了。我们修改策略使得，每次都先将 $[L,R]$ 区间扩展完后，再执行唯一化的改良策略。然后将 dp 过程反过来，从外面和里面分别做一遍，最后在 $[L,R]$ 位置拼起来即可。

时间复杂度 $O(n^2)$。

---

## 作者：_ANIG_ (赞：2)

[传送门](https://www.luogu.com.cn/problem/CF2018F3)

首先考虑问题 D1B 如何解决。

注意到，我们可以考虑如何判定一个出发点是否合法。

注意到，D1B 相当于让你维护一个区间，每次往左或往右扩展一格。称这个过程为扩展操作。

注意到，对于一个出发点，可以贪心地朝着 $a_i$ 最小值所在的方向扩展，然后判断是否合法。

注意到，合法的出发点是一个区间。

注意到，要求出这个极长的区间是很麻烦的。

注意到，可以考虑容斥，定义一个区间是合法的，当且仅当这个区间内的所有点都是合法的出发点，用 $g_i$ 表示所有序列 $a$ 中，所有长度为 $i$ 的合法区间的总数量，用 $f_i$ 表示要求的答案序列。

注意到，$f_i=g_i-\sum\limits_{j=i+1}^n(j-i+1)f_j$，所以我们只需要求出 $g$ 即可。

考虑如果枚举每个序列 $a$，如何求出 $g_i$。

注意到，可以枚举所有长度为 $i$ 的区间，然后判断这个区间是否是合法区间。

问题转化为如何判断一个区间是否合法。

注意到，我们可以找到充分条件。

对于一个区间 $[l,r]$，若满足以下两个条件，则这个区间是合法区间：

1. 任意的 $i\in [l,r]$，有 $a_i>\max(i-l,r-i)$。

2. 以区间 $[l,r]$ 为起点，可以通过扩展操作扩展到区间 $[1,n]$。

考虑证明这个条件的充分性：

注意到，有个很朴素的方案：对于任意的 $i\in[l,r]$，让区间从 $[i,i]$ 开始，一直往左扩展到 $[l,i]$，然后再往右扩展到 $[l,r]$。

注意到，这个扩展的过程是一定合法的。

- 对于 $j<i$，$j$ 被扩展到的时刻为 $i-j+1$，由于 $i\le r$，则 $i-j+1\le r-j+1$。条件 $1$ 保证了 $a_j>r-j$，所以 $a_j\ge i-j+1$，则位置 $j$ 合法。

- 对于 $j>i$，$j$ 被扩展到时刻为 $j-l+1$，条件 $1$ 保证了 $a_j>j-l$，所以 $a_j\ge j-l+1$，则位置 $j$ 合法。

所以区间 $[l,r]$ 内的任意一个点都可以扩展到区间 $[l,r]$，条件 $2$ 保证了区间 $[l,r]$ 可以扩展到区间 $[1,n]$，所以区间 $[l,r]$ 合法。

注意到，这个条件是充要的。

考虑证明必要性。

注意到，若出发点 $x$ 合法，则对于任意的 $i$，满足 $a_i>|x-i|$，否则无论从 $x$ 怎么扩展都无法到达 $i$。称此性质为性质 A。

由于 $l,r$ 都是合法出发点，所以第一个条件的必要性显然。

对于第二个条件，我们任取一个以 $l$ 为出发点时的扩展过程。

设扩展到 $r$ 前，对应的区间为 $[L,r-1]$。

注意到，由于我们取的是任意一个合法的扩展过程，所以区间 $[L,r]$ 可以扩展到 $[1,n]$。

注意到，$[l,r]$ 可以扩展到 $[L,r]$。

由于性质 A，对于任意的 $L\le i< l$，都有 $a_i>r-i$。

从 $[l,r]$ 开始，一直往左扩，直到到达 $[L,r]$，此时，$i$ 被扩展的时刻就是 $r-i+1$。

由于 $a_i\ge r-i+1$，所以位置 $i$ 合法。

于是，可以把 $[l,r]$ 先扩展到 $[L,r]$，然后扩展到 $[1,n]$，则得到了条件 $2$ 的必要性。

于是我们证明了这两个条件的充要性。

注意到，我们可以使用 dp。

注意到，我们不关注区间在序列中的位置。

考虑区间 $[l,r]$ 扩展的过程。

可以发现，如果只关注区间 $[l,r]$ 内部的值，则扩展的过程相当于每次在左侧或右侧添加一个元素，要添加的元素合法并且不在区间 $[l,r]$ 内的元素的最小值维护添加元素的方向。

注意到，我们可以 dp 扩展的过程。

设 $dp_{n,m,0/1}$ 为当前扩展到长度为 $n$ 的区间，最后一个被扩展的元素位于左或右边界，当前钦定的最小值为 $m$ 的方案数。

由于每个序列中的每个区间扩展的方案唯一，所以不会重复。

这样直接枚举下一个最小值的位置和下一个最小值的值，复杂度是 $O(n^4)$。

注意到，我们可以逐格转移，每次只让 $n$ 或 $m$ 变化 $1$，这样总复杂度为 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e3+5;
int t,n,mods,f[N][N][2],g[N][N][2],rs[N],pw[N][N];
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>mods;
		for(int i=0;i<=n;i++)for(int j=0;j<=n+1;j++)f[i][j][0]=f[i][j][1]=g[i][j][0]=g[i][j][1]=0;
		f[n][n][1]=g[n][n][1]=1;
		for(int i=n-1;i>=1;i--){
			for(int j=n;j>=i;j--){
				f[i][j][0]=f[i+1][j][0]*(n-j)+f[i+1][j][1];
				f[i][j][1]=f[i+1][j][0]*(n-j)+f[i+1][j][1]+f[i][j+1][1]+g[i+1][j][0]*(n-j)+g[i+1][j][1];
				g[i][j][0]=g[i+1][j][0]*(n-j)+g[i+1][j][1];
				g[i][j][1]=g[i+1][j][0]*(n-j)+g[i+1][j][1]+f[i][j+1][1];
				f[i][j][0]%=mods;f[i][j][1]%=mods;
				g[i][j][0]%=mods;g[i][j][1]%=mods;
			}
		}
		for(int i=1;i<=n;i++){
			int res=1;
			for(int j=1;j<=i;j++)res=res*(n-max(j,i-j+1)+1)%mods;
			rs[i]=res*f[i][i][1];
		}
		int sm=1;
		for(int i=1;i<=n;i++)sm=sm*n%mods;
		for(int i=n;i>=1;i--){
			for(int j=i+1;j<=n;j++)rs[i]-=rs[j]*(j-i+1);
			rs[i]%=mods;
			sm-=rs[i];
		}
		rs[0]=sm%mods;
		for(int i=0;i<=n;i++)cout<<(rs[i]+mods)%mods<<" ";
		cout<<"\n";
	}
}
```

---

## 作者：TallBanana (赞：0)

考虑**问题 B**：

如果我们有一个初始城市，那么我们的最优策略是什么呢？只有当我们必须往右走时往右走，否作往左走。这样的策略一定是最优的。正确性显然。

形式化地说明**必须往右走**：当前占领 $[l,r]$，$\exist k,k-l+1=a_k$。

**结论**：令 $S=\cap_{i=1}^n[i-a_i+1,i+a_i-1]=[l,r]$，则初始城市集合要么是 $S$，要么是 $\varnothing$。
> **证明**:\
> 初始城市必然在 $S$ 中。
> * 引理：$S$ 中的任意一个初始城市，一定会在某个时刻恰好占领 $S$。
> 
> 这说明，如果有城市 $x\in S$，不能成为初始城市，则 $[l,r]$ 开始拓展不能占领所有城市，则 $S$ 中的城市都不能作为初始城市。则 $S=\varnothing$。

---

回到**问题F**。

先**不考虑无解**的情况。对于这个求交的操作，我们自然想到使用容斥使得其变为求**包含** $[l,r]$ 的方案数。再考虑我们的策略，方向之间的转变决定了 $a$ 的取值。

于是我们可以设计 dp，$f_{i,j,0/1}$ 表示拓展到 $[i,j]$，下一步钦定是往左/右走的方案数。

我们对于每一个 $S$ 分别 dp，我们从 $[l,r]$ 这个状态开始拓展。于是初值是 $f_{l,r,0/1}=1$。

转移有：

* 上一步钦定是往右走，下一步还是往右走，乘上 $a_j$ 的方案数（$a_j\ge j-i+1$）。\
   $f_{i,j,1}\leftarrow f_{i,j-1,1}\times(n-(j-i+1)+1)$。
* 上一步钦定是往右走，下一步变成往左走，这说明约束我们往右走的 $k=j$，此时 $a_j=j-i+1$。\
   $f_{i,j,0}\leftarrow f_{i,j-1,1}$。
* 上一步钦定是往左走，乘上 $a_i$ 的方案数（同上，只要保证能够在时间限制内拓展到即可）。\
   $f_{i,j,0}\leftarrow f_{i+1,j,0}\times(n-(j-i+1)+1)$。
* 上一步钦定是往左走。\
   $f_{i,j,1}\leftarrow f_{i+1,j,0}\times(n-(j-i+1)+1)$。

dp 完后，我们还要乘上 $a_{l\sim r}$ 的方案数，满足能包含 $[l,r]$ 就好了，即 $a_i\ge \max(i-l+1,r-i+1)$。最后容斥，变成恰好为 $[l,r]$ 的方案数。

这个 dp 是 $O(n^4)$ 的（枚举 $l,r$，转移 $O(n^2)$）。

考虑优化。发现我们的转移对于所有的 $[l,r]$ 都是相同的。唯一与 $[l,r]$ 有关的是最后乘上的 $a_{l\sim r}$ 的方案数。

**trick**：倒着 dp。

我们把初始状态设成 $f_{1,n,0}=1$，倒着 dp，复杂度可变为 $O(n^2)$。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N=3e3+10;
LL n,P,f[N][N][2],g[N],ans[N],h[N][N];
void upd(LL &x,LL y) { x=(x+y)%P; }
void solve()
{
	ans[0]=1;
	scanf("%lld%lld",&n,&P);
	for(int i=1;i<=n;i++) ans[i]=0,ans[0]=ans[0]*n%P;
	for(int i=0;i<=n+1;i++)
		for(int j=0;j<=n+1;j++)
			h[i][j]=f[i][j][0]=f[i][j][1]=0;
	f[1][n][0]=1;
	for(int len=n;len>=2;len--)
	{
		for(int i=1,j=len;j<=n;i++,j++)
		{
			upd(f[i][j-1][1],f[i][j][1]*(n-(j-i+1)+1));
			upd(f[i][j-1][1],f[i][j][0]);
			upd(f[i+1][j][0],f[i][j][1]*(n-(j-i+1)+1));
			upd(f[i+1][j][0],f[i][j][0]*(n-(j-i+1)+1));
		}
	}
	for(int i=1,j;i<=n;i++)
		for(g[i]=1,j=1;j<=i;j++)
			g[i]=g[i]*(n-max(j,i-j+1)+1)%P;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			h[i][j]=g[j-i+1]*(f[i][j][0]+f[i][j][1])%P;
	for(int len=1;len<=n;len++)
		for(int i=1,j=len;j<=n;i++,j++)
			upd(h[i][j],2*P-h[i-1][j]-h[i][j+1]+h[i-1][j+1]);
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			upd(ans[j-i+1],h[i][j]);
	for(int i=1;i<=n;i++) upd(ans[0],P-ans[i]);
	for(int i=0;i<=n;i++) printf("%lld ",ans[i]);
	printf("\n");
}
int main()
{
	LL t; scanf("%lld",&t);
	while(t--) solve();
	return 0;
}
```

---


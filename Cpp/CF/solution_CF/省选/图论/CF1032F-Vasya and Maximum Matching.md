# Vasya and Maximum Matching

## 题目描述

Vasya 有一棵包含 $n$ 个顶点的树。他想要删除这棵树中的一些（可能为零）条边，使得在删除边后得到的图中，最大匹配是唯一的。请你计算有多少种选择要删除的边的方案。

在图中，一个匹配是指边的一个子集，且没有任何顶点与该子集中的两条或更多边相连。最大匹配是指在所有匹配中，包含边数最多的那个匹配。

由于答案可能很大，请输出答案对 $998244353$ 取模后的结果。

## 说明/提示

第一个样例中可以删除边的方案有：

- 删除 $(1, 2)$ 和 $(1, 3)$。
- 删除 $(1, 2)$ 和 $(1, 4)$。
- 删除 $(1, 3)$ 和 $(1, 4)$。
- 删除所有的边。

第二个样例中可以删除边的方案有：

- 不删除任何边。
- 删除 $(1, 2)$ 和 $(2, 3)$。
- 删除 $(1, 2)$ 和 $(3, 4)$。
- 删除 $(2, 3)$ 和 $(3, 4)$。
- 删除 $(2, 3)$。
- 删除所有的边。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1 2
1 3
1 4
```

### 输出

```
4
```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
6
```

## 样例 #3

### 输入

```
1
```

### 输出

```
1
```

# 题解

## 作者：feecle6418 (赞：7)

比较神仙的树形 dp。

一个显然的结论是，一棵树最大匹配唯一当且仅当它是单点，或它每个点都包含在最大匹配中（即，最大匹配就是完美匹配）。我们可以根据这个来设状态。

设 $f_{i,0/1/2}$ 为 $i$ 子树内的删边方法数，且 $i$ 是单点（与儿子、父亲均不连边）、$i$ 与某个儿子匹配、$i$ 与父亲匹配的方案数，转移如下：

$$f_{x,0}=\prod_{y} (f_{y,0}+f_{y,1})$$

$$f_{x,1}=\left(\prod_{y} (f_{y,0}+2f_{y,1})\right)\times \left(\sum_{y}\dfrac{f_{y,2}}{f_{y,0}+2f_{y,1}}\right)$$

$$f_{x,2}=\prod_{y} (f_{y,0}+2f_{y,1})$$

意思是，假如是孤立点则所有儿子要么是孤立点，要么已经匹配；假如要和儿子匹配，则恰有一个与父亲匹配，其他全部要么是孤立点，要么已匹配。假如已匹配，那么这条边可删可不删，所以要乘二。假如要和父亲匹配，则所有儿子全部要么是孤立点，要么已匹配，系数原因同上。

时间复杂度是 $O(n)$。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int n,f[300005][3];
vector<int> g[300005];
int Power(int x,int y) {
	int ret=1;
	while(y) {
		if(y&1)ret=1ll*ret*x%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return ret;
}
void dfs(int x,int fa){
	f[x][0]=f[x][2]=1;
	for(int y:g[x]){
		if(y==fa)continue;
		dfs(y,x),f[x][0]=1ll*f[x][0]*(f[y][0]+f[y][1])%mod;
		f[x][1]=(f[x][1]+1ll*Power((f[y][0]+2ll*f[y][1])%mod,mod-2)*f[y][2])%mod;
		f[x][2]=f[x][2]*(f[y][0]+2ll*f[y][1])%mod;
	}
	f[x][1]=1ll*f[x][1]*f[x][2]%mod;
}
int main(){
	cin>>n;
	for(int i=1,x,y;i<n;i++)cin>>x>>y,g[x].push_back(y),g[y].push_back(x);
	dfs(1,0),cout<<(f[1][0]+f[1][1])%mod;
    return 0;
}

```

---

## 作者：Mihari (赞：4)

# 题目

[传送门](https://www.luogu.com.cn/problem/CF1032F)

# 题解

一道只看代码很水~~实则很难~~的树形 DP 题，要做出这道题，需要巧妙地转换模型

一棵树去掉一些边，一定会构成许多连通块，我们首先需要意识到每个连通块的最大匹配都是相互独立，那么我们可以分块进行思考.

我们首先对这道题中这些出现唯一最大匹配的块的特点做一些分析.

首先一定有：

1. 如果这个图存在唯一最大匹配，那么其**所有**叶节点一定都存在于匹配中；

想象一下，如果有某一个叶节点不存在于匹配，那么首先其父亲一定存在于匹配，那么我们可以将其父亲的匹配换成其父亲与他自己组成匹配，这样整个块匹配个数不变，但是匹配方式不唯一了，不符题意.

其次，我们可以将这些已经组成的匹配去掉，然后又成了一个新块，再对其叶节点匹配，再去掉匹配...一直这样进行下去，由于我们每次去除的是两个点，那么最后一定会剩下 $1$ 个或 $0$ 个点，如果最后剩下一个点，则说明这个块中，根没有被匹配，那么我们可以随便找一条单链的匹配往上移动一次，这样匹配个数不变，匹配方式不唯一而不符题意，即

2. 只有偶数点的块才存在唯一最大匹配；

但是这个结论真的那么简单？不，还有一个特殊情况——一个孤点，所以还有第三点

3. 孤点构成唯一最大匹配；

接下来考虑如何解决这道题.

首先，因为每个块最大匹配都是独立，所以对于原树的每个子树都是相互独立的，我们考虑使用**树形** $DP$ 统计方案数

我们观察我们在分析特性 $1$ 和 $2$ 时做了些什么：对于每个非叶节点，如果它的某个儿子没有被匹配，那么将其与其儿子匹配，并且其余的儿子要么就和儿子的儿子匹配，要么他们自己成为孤点，那么我们即可定义状态：

定义 $f[u][0]$ 为 $u$ 已经在子树中完成匹配的合法方案数.

对应地，我们亦定义 $f[u][1]$ 为 $u$ **还未在子树**中完成匹配，但是它的某些儿子仍然连接了它的合法方案数（后面的条件是为了与孤点进行区分）

但是我们还有特殊情况——孤点，那么我们还要多定义一个：

定义 $f[u][2]$ 表示点 $u$ 在其子树中是孤点的合法方案数（它的儿子们都不连接它）

那么，对于 $f[u][0]$，我们有转移
$$
f[u][0]=\sum_{x\in \text{son}_u}\left ( f[x][1]+f[x][2]\right )\prod_{v\in \text{son}_u,v\neq x}(f[v][0]\times 2+f[v][2])
$$
解释一下，因为点 $u$ 如果在子树中已经完成匹配，那么它一定只和某一个点组成匹配，其他点自行解决（在自己的子树中匹配或者是孤点），所以我们钦定一个太子 $x$，让其与 $u$ 进行匹配，那么这个太子必须满足自己在自己的子树中没有进行匹配，或者它在其子树中本身是孤点，只是和其父皇有联系且组成匹配.

而那些不是太子的点，只能自行解决，如果它在自己的子树中完成匹配，那么边 $(u,v)$ 可连可不连，所以是 $f[v][0]\times 2$，或者它本身是孤点，但是又不能和父皇相认，所以 $f[v][2]$ 不 $\times 2$.

对于 $f[u][2]$ 的转移，因为它是孤点，所以它所有儿子都不认它这个父亲，而且还要保证合法，所以它的不肖子孙们只能自行解决，显然有
$$
f[u][2]=\prod_{v\in \text{son}_u}(f[v][0]+f[v][2])
$$
对于 $f[u][1]$，它自己没有被匹配但是有儿子连他，即这些儿子们自己组成了匹配，但是又有些要和 $u$ 相认，那么有
$$
f[u][1]=\prod_{v\in \text{son}_u}(f[v][0]\times 2+f[v][2])
$$
它的儿子们都可连可不连，所以是 $f[v][0]\times 2$，但是这会出现一个问题——我们把它是孤点的情况似乎也算出去了，考虑怎么除掉这些情况，发现我们对于 $f[u][2]$ 的定义就是它是孤点的情况，所以我们只需要将 $f[u][1]$ 减去 $f[u][2]$ 就可以了，整理一下，就是
$$
f[u][1]=\prod_{v\in \text{son}_u}(f[v][0]\times 2+f[v][2])-f[u][2]
$$
~~所以我才要先算 f\[u\]\[1\] 的~~

考虑时间复杂度，由于我们要在对 $f[u][0]$ 进行转移时，要枚举一个太子，还要枚举其他的儿子，所以总复杂度为 $\mathcal O(n^2)$，但是我们实际只需要记 $pi=\prod_{v\in \text{son}_u}(f[v][0]\times 2+f[v][2])$ 先处理出来，枚举太子时即为 $(f[x][1]+f[x][2])\times pi\times \text{Inv}(f[x][0]\times 2+f[x][2])$

如果遇到毒瘤出题人卡逆元，那么你可以~~把出题人吊起来打一顿再~~处理出前缀积和后缀积即可。

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13407993.html
```



---

## 作者：姬小路秋子 (赞：3)

定义**孤点**：在某一种删边方案中没有其它点与它相邻


我们发现一棵树的**最大匹配**唯一当且仅当**除了孤点**这棵树的其它连通块内部都构成一个完美匹配（即每个顶点都用上了）。

所以我们可以根据这个性质**dp**。

**我们暂时不管当前点与它父亲之间的边是否删除**，也就是说我们dp数组的意义仅局限于当前点是根的情况

$f[u][0]$ 表示 $u$ 是一个孤点（前面已经提到不考虑它与父亲相连的情况，当然也不讨论它是否和父亲构成匹配，以下也一样）

$f[u][1]$ 表示 $u$ 不为孤点，且还未进行匹配

$f[u][2]$ 表示 $u$ 不为孤点，且已经进行匹配

转移如下(v为u儿子):

$f[u][0]=f[u][0]*(f[v][0]+f[v][2])$

$f[u][1]=f[x][0]*f[v][2]+f[u][1]*(f[v][0]+f[v][2]*2)$

$f[u][2]=f[u][0]*(f[v][0]+f[v][1])+f[u][1]*(f[v][0]+f[v][1])+f[u][2]*(f[v][0]+f[v][2]*2)$

---

想必你看懂了上面的话这段$dp$转移应该也不难理解了吧！所以本人就不再多解释了（其实是挖了个坑）

代码如下：
```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
vector<ll>zh[300001];
ll n,f[300001][3],g[3],p=998244353;
void dfs(ll x,ll fa){
	ll i,v;
	f[x][0]=1;
	for(i=0;i<zh[x].size();i++){
		if(zh[x][i]==fa)continue;
		dfs(zh[x][i],x);
		v=zh[x][i];
		g[0]=(f[x][0]*(f[v][0]+f[v][2]))%p;
		g[1]=(f[x][0]*f[v][2]+f[x][1]*(f[v][0]+f[v][2]*2))%p;
		g[2]=(f[x][0]*(f[v][0]+f[v][1])+f[x][1]*(f[v][0]+f[v][1])+f[x][2]*(f[v][0]+f[v][2]*2))%p;
		swap(g,f[x]);
	}
}
int main(){
	ll i,t,k;
	scanf("%lld",&n);
	for(i=1;i<n;i++){
		scanf("%lld%lld",&t,&k);
		zh[t].push_back(k);zh[k].push_back(t);
	}
	dfs(1,0);
	printf("%lld",(f[1][0]+f[1][2])%p);
}
```

---

## 作者：Zxx200611 (赞：1)

给出一棵由 $n$ 个结点构成的树 $T$。

现在你需要删除任意条边，使得删边后得到的森林 $T'$​ 的最大匹配唯一，求删边方案数。

$n \le 3 \times 10^5$，答案对 $998244353$ 取模。

---

森林 $T'$ 中所有树的最大匹配互不影响，因此我们先思考什么时候一棵树的最大匹配唯一，$T'$ 中的所有树都必须满足这个条件。

对于一棵树 $t$，我们可以找出一种最大匹配：

+ 若此最大匹配覆盖了 $t$ 中的所有结点，即其为一种完美匹配。

    此时每个叶子必然与其父亲匹配。我们选择某个叶子，将其与其父亲删除，可以得到一棵新的树，且其具有完美匹配。不断地执行上述操作，我们将会得到一棵包含 $0$ 个结点的树。由此可见，每个结点都会在某个时刻成为叶子，其必须与当时的父亲匹配，则 $t$ 的完美匹配唯一。而最大匹配为完美匹配，所以 $t$ 的最大匹配唯一。

+ 若此匹配未覆盖 $T$ 中的所有结点。

    与未匹配点相邻的结点必然都是匹配点。我们找到与未匹配点 $u$ 相邻的一个匹配点 $p_1$ 以及从 $p_1$ 出发的极长交替路 $p_1,p_2,p_3,\dots,p_k$，则我们必然可以反转路径 $u \to p_k$ 上所有边的匹配情况，得到一组新的匹配，且匹配数量一定不会变小。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/ncwfqy8j.png)

    换句话说，我们可以找到一组新的最大匹配。则 $t$​ 的最大匹配不唯一。

综上所述，当且仅当树 $t$ 存在完美匹配时，其最大匹配唯一。但其实还有一种情况：当 $t$ 为单点时，不存在完美匹配，但是最大匹配唯一。

因此 $T'$ 中所有树都需要存在完美匹配或是为单点。



现在为题转化为，删除树 $T$ 的一些边，使得每个连通块都存在完美匹配或为单点，求删边方案数。

我们考虑使用 DP 解决这个问题。

首先设计状态：必然有一维为现在在的结点编号，还有一维为此点是否在子树中被匹配。但是一个儿子为删边后单点与未在子树中匹配的处理方式不同，所以第二维需要三位。可以设计出状态：$f_{u,0/1/2}$ 表示在 $u$ 的子树中，$u$ 为 单点/已（与某儿子）匹配/不为单点且未被匹配（要与父亲匹配） 的删边方案数。

接下来考虑转移：

+ 若 $u$ 为单点：

    则 $u$ 与儿子间的所有边都必须删除，每个儿子都必须自行处理使自己的子树满足条件（为单点或完美匹配），故有：
    $$
    f_{u,0} = \prod_{v \in \operatorname{son}(u)} (f_{v,0} + f_{v,1})
    $$

+ 若 $u$ 与某个儿子匹配：

    我们钦定一个儿子 $v$ 与其匹配，则剩下的儿子需自行处理：若其为单点，则 $u$ 与其之间的边必须删除；若其已与子结点匹配，则可以选择删除 $u$ 与其之间的边，有转移系数 $2$。故有：
    $$
    f_{u,1} = \sum_{v \in \operatorname{son}(u)} f_{v,2} \prod_{w \in \operatorname{son}(u),w \ne v} (f_{w,0} + 2 \times f_{w,1})
    $$

+ 若 $u$ 与父亲匹配，则儿子需自行处理，与上面类似可得：
    $$
    f_{u,2} = \prod_{v \in \operatorname{son}(u)} (f_{v,0} + 2 \times f_{v,1})
    $$

转移方程设计完毕。

最后是边界条件：对于每个叶子，$f_{u,0} = 1,f_{u,1} = 0,f_{u,2} = 1$。

至此本题完结，最终答案即为 $f_{r,0} +f_{r,1}$，其中 $r$ 是树形 DP 的开始结点。总时间复杂度 $O(n)$ 或 $O(n \log V)$，均足以通过本题。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int p=998244353;

vector<int> G[300010];
int f[300010][3];

inline
int quickPow(int a,int k)
{
	int res=1;
	for(int w=a;k;w=1ll*w*w%p,k>>=1)
	{
		if(k&1)
		{
			res=1ll*res*w%p;
		}
	}
	return res;
}
inline
int Mod(int a)
{
	return a>=p?a-p:a;
}
inline
void dynamicProgramming(int u,int fa)
{
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(v==fa)
		{
			continue;
		}
		dynamicProgramming(v,u);
	}

	f[u][0]=f[u][2]=1;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(v==fa)
		{
			continue;
		}
		f[u][0]=1ll*f[u][0]*Mod(f[v][0]+f[v][1])%p;
		f[u][2]=1ll*f[u][2]*Mod(f[v][0]+Mod(f[v][1]+f[v][1]))%p;
	}
	f[u][1]=0;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(v==fa)
		{
			continue;
		}
		f[u][1]=Mod(f[u][1]+(1ll*f[v][2]*f[u][2]%p)*quickPow(Mod(f[v][0]+Mod(f[v][1]+f[v][1])),p-2)%p);
	}
}

int main()
{
	int n;
	cin>>n;
	for(int i=1,u,v;i<=n-1;i++)
	{
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}

	dynamicProgramming(1,1);

	cout<<Mod(f[1][0]+f[1][1])<<endl;
}
```

---

## 作者：liujiaxi123456 (赞：0)

## 思路：

显然先推满足删边后最大匹配唯一的条件是什么：

- 对于一个点，它要么是孤点，要么一定被匹配：

  - 即不可能出现联通，却不被匹配的情况。
 
  - 稍微画一画即可。
 
所以考虑以此记录后效性 DP：

  - 记 $f_{u, 0/1/2} $ 分别表示 u 是【孤点】/【与儿子匹配】/【与父亲匹配】。

  - 挨个写转移方程：

    - $f_{u, 0} = \prod_{v} f_{v, 0/1} $
   
    - $f'_{u, 1} = f_{u, 2}\cdot f_{v, 2} + f_{u, 1}\cdot (f_{v, 0/1}+f_{v, 1}) $
   
      - 这里 $f_{u, 2}$ 表示儿子可以与 u 连边，但 u 暂未匹配的方案数。
   
    - $f_{u, 2} = \prod_{v} (f_{v, 0/1} + f_{v, 1}) $
   
最后答案就是 $f_{1, 0/1} $。

## Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn = 3e5+5;
const ll MOD = 998244353;

namespace EDGE {
	int sz, head[Maxn];
	struct Edge { int next, to; } edge[Maxn<<1];
	inline void Add_edge(int u, int v) {
		edge[++sz] = {head[u], v};
		head[u] = sz;
	}
} using namespace EDGE;

namespace Josh_zmf {
	
	int N; ll f[Maxn][3];

	inline void dfs(int u, int faa) {
		f[u][0] = 1, f[u][2] = 1;
		for(int i=head[u], v; i; i=edge[i].next) {
			v = edge[i].to;
			if(v == faa)	continue;
			dfs(v, u);
			f[u][0] = f[u][0]*(f[v][0]+f[v][1]) %MOD;
			f[u][1] = (f[u][2]*f[v][2] + f[u][1]*(f[v][0]+f[v][1]*2)) %MOD;
			f[u][2] = f[u][2]*(f[v][0]+f[v][1]*2) %MOD;
		}
	}

	inline int main() {
		cin>> N;
		for(int i=1, u, v; i<N; i++)	cin>> u>> v, Add_edge(u, v), Add_edge(v, u);
		dfs(1, 0);
		cout<< (f[1][0]+f[1][1])%MOD<< '\n';
		return 0;
	}

}

int main() {
	Josh_zmf::main();
	return 0;
}
```

---

## 作者：Lgx_Q (赞：0)

神奇的题目。

挖性质，首先考虑什么样的树（不考虑删边）最大匹配唯一。发现，如果有结点未匹配，得知该结点连接的所有点都匹配（否则此时的匹配不是最大的），那么把任意一个点变成与该结点匹配，最大匹配数不变，但变成了另一种方案。

所以，**只有所有点都匹配** 或者 **只有一个点** 的树才有可能最大匹配唯一。当然，对于存在所有点都匹配的连通块，我们每次可以选择连通块的叶子结点，然后令他和其父亲匹配（由于是叶子，所以只连接他的父亲），之后删掉这两个点。重复上述操作，即可得到最大匹配。不难发现此时必定是唯一的最大匹配。

所以对于割去若干条边后所形成的的森林，去掉只有一个点的树，剩下的树都应该满足存在每个点都匹配的方案。利用最大匹配唯一的条件，我们可以直接围绕最大匹配来统计原树。

设 $f_{u,0/1/2}$ 表示在 $u$ 子树割去若干条边后找最大匹配，必须保证除了 $u$ 其他点要么自己构成一个点的连通块，要么匹配的方案数。第二维表示： $u$ 匹配 / $u$ 不匹配但是 $u$ 所在连通块大于一个点 / $u$ 单独构成一个点的连通块。

首先对于 $f_{u,0}$，假设 $(u,v)$ 匹配，其中 $v$ 是 $u$ 的儿子，那么其他儿子构成的子树单独作为一个子问题，且与 $u$ 的连边要么割要么不割。

其次 $f_{u,2}$，显然割去连向儿子的所有边，然后算儿子子树的贡献。

最后是 $f_{u,1}$，只需把所有儿子子树的贡献和边割或不割的贡献全部算起来，减去 $f_{u,2}$ 即可。

计算 $x$ 为 $u$ 不匹配的答案，$y$ 为 $u$ 匹配的答案，$f_{u,2}$ 单独计算，那么 $f_{u,0}=y,\space f_{u,1}=x-f_{u,2}$，$x$ 和 $y$ 则为树形 DP 简化背包，计算简单。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=6e5+10,mod=998244353;
ll n,u,v,head[maxn],tot,f[maxn][3],siz[maxn],pw[maxn];
struct edge
{
	ll v,nxt;
}e[maxn];
void insert(ll u,ll v)
{
	e[++tot]=(edge){v,head[u]};
	head[u]=tot;
}
void dfs(ll u,ll fa)
{
	siz[u]=1;
	ll x=1,y=0;//fill    no fill but not 1    no fill but 1
	f[u][2]=1;
	for(ll i=head[u];i;i=e[i].nxt)
	{
		ll v=e[i].v;
		if(v!=fa)
		{
			dfs(v,u);
			siz[u]+=siz[v];
			y=(y*(f[v][0]*2+f[v][2])%mod+x*(f[v][1]+f[v][2]))%mod;
			x=x*(f[v][0]*2+f[v][2])%mod;
			f[u][2]=f[u][2]*(f[v][0]+f[v][2])%mod;
		}
	}
	f[u][0]=y;
	f[u][1]=(x-f[u][2]+mod)%mod;
}
int main()
{
	scanf("%lld",&n);
	pw[0]=1;
	for(ll i=1;i<=n;i++) pw[i]=pw[i-1]*2%mod; 
	for(ll i=1;i<n;i++)
	{
		scanf("%lld%lld",&u,&v);
		insert(u,v);
		insert(v,u);
	}
	dfs(1,0);
	printf("%lld",(f[1][0]+f[1][2])%mod);
	return 0;
}
```

---

## 作者：Piwry (赞：0)

虚拟赛时没怎么想这题，有点可惜...

被前面一些奇奇怪怪的地方卡住了；例如 C 没有想到用 dp，而是一直试图直接写出一种构造方法

## 解析

首先有一个结论：一棵树最大匹配唯一当且仅当它的最大匹配是完美匹配

证明可以考虑反证。若其不唯一，我们先把两种匹配方案中不同的其中一个匹配 $(x, y)$ 断掉。接下来考虑给 $x$ 找新的匹配点；由于最大匹配是完美匹配，因此这样一定会导致另一个匹配 $(x', y')$ 断掉。不妨设 $x'$ 与 $x$ 间有边，那么接下来我们就要给 $y'$ 再找一个结点匹配...如此重复，为了最终构成一个匹配，这条路径一定会绕一圈回到 $y$；于是就**形成了环**。但树中是不允许存在环的

接下来 dp 部分就简单了。设 $dp(0/1/2, u)$，其中 $0$ 表示 $u$ 不和其它点连边，$1$ 表示 $u$ 和父亲连边，$2$ 表示 $u$ 和儿子连边

转移也很好写。但貌似有两种写法，其中一种实现较简单（可见 [这篇](https://www.luogu.com.cn/blog/user50251/solution-cf1032f) 题解）；这里给出较易理解的：

$$dp(0, u)=\prod\limits_{v}{(dp(0, v)+dp(2, v))}$$

$$dp(1, u)=\prod\limits_{v}{(dp(0, v)+2\cdot dp(2, v))}$$

$$dp(2, u)=\sum\limits_{v}{dp(1, v)\cdot \prod\limits_{v', v'\not=v}{(dp(0, v')+2\cdot dp(2, v'))}}$$

其中 $v$ 是 $u$ 的儿子；式子中乘的 “$2\cdot$” 表示连边或不连边

第三个转移式的具体实现简单地可以想到先处理出儿子答案的积后乘逆元去掉贡献，但这样其实**有可能除零**；另一种避免逆元的方法是维护儿子答案的前缀后缀积（~~就是常数有点大~~），具体可见代码

## CODE

```cpp
#include <cstdio>
#include <vector>
using std::vector;

const int MAXN =3e5+20, M =998244353;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

/*------------------------------Map------------------------------*/

vector<int> E[MAXN];

inline void addedge(const int &u, const int &v){
	E[u].push_back(v);
	E[v].push_back(u);
}

/*------------------------------Dfs------------------------------*/

int dp[3][MAXN];

void dfs(const int &u, const int &fa){
	for(int v:E[u])
		if(v != fa)
			dfs(v, u);
	
	vector<int> pre, suf;
	pre.push_back(1);
	for(int v:E[u])
		if(v != fa)
			pre.push_back(1ll*pre[pre.size()-1]*(dp[0][v]+dp[2][v]*2ll)%M);
	suf.push_back(1);
	for(int i =E[u].size()-1; i >= 0; --i){
		int v =E[u][i];
		if(v != fa)
			suf.push_back(1ll*suf[suf.size()-1]*(dp[0][v]+dp[2][v]*2ll)%M);
	}
	int Size =pre.size()-1;
	
	dp[0][u] =1;
	for(int v:E[u])
		if(v != fa)
			dp[0][u] =1ll*dp[0][u]*(dp[0][v]+dp[2][v])%M;
	
	dp[1][u] =pre[Size];
	
	dp[2][u] =0;
	int i =1;
	for(int v:E[u])
		if(v != fa){
			dp[2][u] =(dp[2][u]+1ll*dp[1][v]*pre[i-1]%M*suf[Size-i]%M)%M;
			++i;
		}
}

/*------------------------------Main------------------------------*/

int main(){
	int n =read();
	for(int i =0; i < n-1; ++i)
		addedge(read(), read());
	
	dfs(1, 0);
	
	printf("%d", (dp[0][1]+dp[2][1])%M);
}
```

---


# Parcels

## 题目描述

有 n 件包裹，每个包裹是一个盒子，都有它自身的质量和载重 (即它上方能承受的最大质量)。scx 最近得到了一个新的包裹处理系统，这个系统以如下方式工作。初始时，有一个 (可以堆放盒子的) 平台，它的载重为 S，接下来，你能以如下的规则在平台上堆放盒子：

    如果平台是空的，你可以将盒子堆放在平台上，否则，你只能在新的盒子放在最高的盒子上面。
    任何时刻，(平台上) 所有盒子的总质量不能超过 S    (即平台的载重)。
    对任意一个盒子，任何时刻，在它上面的所有盒子的总质量不能超过这个盒子的载重。
    并且你只能取走当前位于最上面的盒子 (即形成栈型结构)。

系统接收到了这 n 件包裹，已知第 i 个包裹在时刻 $in_i$ 出现，它的质量和载重分别为 $w_i,s_i$，每个包裹都有它的价值，其中第 i 个包裹的价值为 $v_i$。然而，为了获得 (赚得) 这 $v_i$ 的价值，这个系统要求它刚好在时刻 $out_i$ 被出售，否则将无法获得任何价值。于是，scx 可以选择跳过部分包裹 (即不接收这些包裹)，当然她也无法获得任何价值。

任何操作所花费的时间可以忽略不计，这意味着你可以在一个时刻做多件事情 (比如取走若干包裹，在对方若干包裹)。

注意一旦一个包裹被取走后，它就不会影响后续对包裹的操作。

由于这系统非常复杂，并且包裹数有很多，scx 想要知道如果她合理利用这个系统，她最多能得到多少钱。

## 样例 #1

### 输入

```
3 2
0 1 1 1 1
1 2 1 1 1
0 2 1 1 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5 5
0 6 1 2 1
1 2 1 1 1
1 3 1 1 1
3 6 2 1 2
4 5 1 1 1
```

### 输出

```
5
```

# 题解

## 作者：mingcheng (赞：4)

在处理之前将所有的线段按照终点排序，若是终点相同则将长度小的放在前头，(也就是起点从大到小排)

**这样可以保证范围小的线段先被处理**

这样的话，可以写出一个方程

**f[i][j]表示当前第i个塔总重不超过j(包含i)的最大价值**


**f[i][j] = max( g[data[x].s] + f[x][ min(data[i].s,j-data[i].w) ] )
**
![](https://cdn.luogu.com.cn/upload/pic/24323.png )

data[i].s表示i本身的承重，(保证i不被压坏掉)

j-data[i].w表示底座i还剩下的承重（保证i下面的不被压坏掉）

g[x]表示第i个线段开始到x能获得的最大价值，

每次到达一个新的底层线段时就将g重新赋值

为什么g没有被承重能力限制呢？因为在g前面的都已经被取走从而不会对g产生限制了




```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int n,m,f[1050][1050],g[1050];
struct node{int l,r,w,s,v;}a[1050];
bool cmp(node x,node y)
{
    return x.r==y.r?x.l>y.l:x.r<y.r;
}
void print()
{
    cout<<"k";
    print();
}
void getdata()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d%d",&a[i].l,&a[i].r,&a[i].w,&a[i].s,&a[i].v);
    }
    sort(a+1,a+n+1,cmp);
    a[n+1].l=0;a[n+1].r=a[n].r+1;a[n+1].s=m;
    for(int i=1;i<=n+1;i++)
    {
        for(int j=a[i].w;j<=m;j++)
        {
            int p=a[i].l;g[p]=0;
            for(int k=1;k<i;k++)
            {
                if(a[k].l>=a[i].l)
                {
                    while(p<a[k].r) {p++;g[p]=g[p-1];}
                    g[p]=max(g[p],g[a[k].l]+f[k][min((j-a[i].w),a[i].s)]);
                }
            }
            f[i][j]=g[p]+a[i].v;
        }
    }
    printf("%d",f[n+1][m]);
}
int main()
{
    getdata();
    print();
}

```

---

## 作者：skyskyCCC (赞：0)

## 前言。
动态规划好题，巧妙的典中典思路！这种利润价值问题不难想到背包和动态规划，但是这个题的难点在于处理操作顺序。

题意简述：有一个传送带，上面有 $n$ 件物品，可以选或者不选。如果选了第 $i$ 个物品会获得 $v_i$ 的利益，但是存在限制条件，就是第 $i$ 件物品必须在 $in_i$ 时被选中，且在 $out_i$ 时放回。同时每个物品还有一个重量 $w_i$ 和载荷$s_i$ 并且还有传送带的载重为 $S$。现在你需要时刻保证一个物品，包括传送带，上方的所有物品的重量之和不超过这个物品的载荷。问能够获得的最大收益。
## 分析。
限制条件这么多，包括时间和荷载两大部分，我们可以将它们看做两个区间，然后分别采用区间动态规划解决。时间复杂度为 $O\left(4\times n^2\times S\right)$ 显然过大。

我们发现如果这个题不考虑载荷，仅仅考虑时间的话，那么我们显然有这么一种想法：首先将货物按照运走时间早的和运进时间晚的排序，因为越早处理掉某个货物，在相同的时间内，显然比什么都不做或者先做时间耗时大的货物赚的钱多（前提是没有特别离谱的数据），这样我们就可以早赚钱。

既然这样，我们不能直接贪心，所以我们要在时间的基础上引进载重，所以不妨设一个状态 $dp_{i,j}$ 表示选择第 $i$ 个物品时，它和它上面的物品的总重为 $j$ 时，能获得的最大收益。此时我们只需要处理出来 $j$ 即可。那么既然我们前面的是一个个移出去的，所以我们可以将这些箱子看做是一个逆序列，然后考虑能放置的最大的箱子重量。我们显然用前缀和什么常规的思路不可以，但是我们发现加工这些箱子也具有无后效性！什么意思呢？举个例子：如果我们的进货顺序是这样的：
```
in_1 in_2 out_2 in_3 out_3 out_1
```
因为题目中有“注意一旦一个包裹被取走后，它就不会影响后续对包裹的操作”这句话，所以那么此时货物 $2$ 和 $3$ 显然都不需要叠加，不会影响的货物 $1$ 是否可以赚钱。

那么我们不妨再设一个辅助的动态规划数组为 $g_i$ 表示在 $i$ 前面的已经移走的货物所能赚到的最大的利润。注意一下边界问题，然后转移到 $dp_{i,j}$ 即可。注意这两个 $i$ 和 $j$ 代表的不一定是同一个数。

代码如下，仅供参考：
```
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int n,S,dp[1005][1005],g[1005];
int sum,tot;
struct node{
    int in,out,w,s,v;
}a[1005];
bool cmp(node first,node second){
    return first.out<second.out||(first.out==second.out&&first.in>second.in);
}
int main(){
	cin>>n>>S;
	a[0].in=0;
	a[0].out=1000;
	a[0].w=0;
	a[0].s=S;
	a[0].v=0;
    for (int i=1;i<=n;i++){
    	cin>>a[i].in>>a[i].out>>a[i].w>>a[i].s>>a[i].v;
	}
    sort(a,a+n+1,cmp);
    for (int i=0;i<=n;i++){
        for (int j=a[i].w;j<=S;j++){
            sum=a[i].in;
            tot=min(a[i].s,j-a[i].w);
            g[sum]=0;
            for (int k=0;k<i;k++){
			    if(a[k].in>=a[i].in){
                    while(sum<a[k].out){
                        sum++;
                        g[sum]=g[sum-1];
                    }
                    g[sum]=max(g[sum],g[a[k].in]+dp[k][tot]);
                }
            }
            dp[i][j]=g[sum]+a[i].v;
        }
    }
    cout<<dp[n][S]<<"\n";
    return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---


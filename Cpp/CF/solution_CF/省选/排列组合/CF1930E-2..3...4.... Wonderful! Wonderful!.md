# 2..3...4.... Wonderful! Wonderful!

## 题目描述

Stack 有一个长度为 $n$ 的数组 $a$，其中 $a_i = i$，对于所有 $i$（$1 \leq i \leq n$）。他将选择一个正整数 $k$（$1 \leq k \leq \lfloor \frac{n-1}{2} \rfloor$），并对 $a$ 进行如下操作任意次（可能为 $0$ 次）：

- 从 $a$ 中选择一个长度为 $2k+1$ 的子序列 $s$。现在，他将从 $a$ 中删除 $s$ 的前 $k$ 个元素。为了保持绝对平衡（正如一切应有的那样），他还将从 $a$ 中删除 $s$ 的后 $k$ 个元素。

Stack 想知道，对于每个 $k$（$1 \leq k \leq \lfloor \frac{n-1}{2} \rfloor$），他最终可能得到多少种不同的数组 $a$。由于答案可能非常大，请输出对 $998\,244\,353$ 取模的结果。

$^\dagger$ 一个序列 $x$ 是序列 $y$ 的子序列，如果 $x$ 可以通过从 $y$ 中删除若干（可能为零或全部）元素得到。例如，$[1, 3]$、$[1, 2, 3]$ 和 $[2, 3]$ 都是 $[1, 2, 3]$ 的子序列。而 $[3, 1]$ 和 $[2, 1, 3]$ 不是 $[1, 2, 3]$ 的子序列。

## 说明/提示

在第一个测试用例中，对于 $k=1$，可能的 $a$ 有两种：

- $[1,2,3]$；
- $[2]$。

在第二个测试用例中，对于 $k=1$，可能的 $a$ 有四种：

- $[1,2,3,4]$；
- $[1,3]$；
- $[2,3]$；
- $[2,4]$。

在第三个测试用例中，对于 $k=2$，可能的 $a$ 有两种：

- $[1,2,3,4,5]$；
- $[3]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
3
4
5
10```

### 输出

```
2 
4 
10 2 
487 162 85 10```

# 题解

## 作者：Alex_Wei (赞：10)

### [CF1930E. 2..3...4.... Wonderful! Wonderful!](https://www.luogu.com.cn/problem/CF1930E)

如果一个数被删去，将其标记为 $1$，否则标记为 $0$。问题即数 $01$ 串个数。

考虑最后一次操作没有被删去的数，它前面至少有 $k$ 个被删去的数，后面也至少有 $k$ 个被删去的数。

于是 $01$ 串合法的必要条件：

- $1$ 的个数是 $2k$ 的倍数。
- 存在 $0$ 使得它左侧和右侧至少有 $k$ 个 $1$。

这个条件充分吗？很明显是充分的：考虑撤回最后一次操作，首先在 $0$ 两侧各选 $k - 1$ 个 $1$ 将它们标记为 $0$。如果左侧 $1$ 的个数不小于右侧 $1$ 的个数，那么先在右侧选一个 $1$ 标记为 $0$，此时 $1$ 的个数为奇数，且最中间的 $1$ 在左侧，将其标记为 $0$​。反之同理。

枚举 $k$，枚举操作次数 $c$，考虑用所有方案数 $\binom n {2ck}$ 减去不合法的方案数。根据充要条件，不合法当且仅当除了左右最外侧的 $k - 1$ 个 $1$ 以外，剩下的 $1$ 形成连续段。将这 $d = 2ck - 2k + 2$ 个 $1$ 缩起来，相当于在 $n - d + 1$ 个位置选 $2ck - d + 1$ 个 $1$，即 $\binom {n - 2(c - 1)k - 1} {2k - 1}$。

时间复杂度是调和级数的 $\mathcal{O}(n\ln n)$。[代码](https://codeforces.com/contest/1930/submission/246872700)。

---

## 作者：sunkuangzheng (赞：10)

$\textbf{CF1930E *2400}$

> - 给你 $n,k$，有一个长度为 $n$ 的数组 $a$，初始时 $a_i=i$。一次操作可以选择一个长度为 $2k+1$ 的子序列，删除前后 $k$ 个元素，留下中间的一个。对于 $k \in [1,\lfloor \dfrac{n-1}{2} \rfloor]$，求出如果进行任意次操作，能得到多少不同的数组，模 $998244353$。

> - $1 \le n \le 10^6$。


容易发现 $k$ 固定时，删除的元素数量 $x$ 是 $2k$ 的倍数。也就是说我们可以**枚举** $x$ 的值，复杂度将是调和级数的 $\mathcal O(n \log n)$。

考虑对于固定的 $n,k,x$，计算方案数量。我们思考一个问题：给你数组 $a$，判断它是否可以通过初始状态进行任意此操作得到。我们把删除记为 $1$，保留记为 $0$。

寻找充要条件。从 $x=2k$ 入手，此时只需要存在一个 $p$，满足 $a_p = 0$ 且小于 $p$ 大于 $p$ 都有**恰好** $k$ 个 $1$。

当 $x > 2k$ 时，我们猜测上面的条件仍然充要，即存在一个 $p$，满足 $a_p = 0$ 且小于 $p$ 大于 $p$ 都有**至少** $k$ 个 $1$。下面给出证明。

> - 必要性。

> 删除一些 $1$ 不会增加 $0$ 的数量，也不会增加 $0$ 两边 $1$ 的数量。故如果初始不存在 $p$ 操作至 $x=2k$ 时一定也不会存在 $p$，不合法。

> - 充分性。

> 我们找到 $p$ 的位置。如果某一侧有 $\ge 3k$ 个 $1$，显然我们可以从一边删除 $2k$ 个。这样两边都会剩下 $[k,3k)$ 个 $1$。因为两边 $1$ 数量的总和是 $2k$ 的倍数，所以一定存在一种方案把两边都删到恰好 $k$ 个 $1$，再进行一次操作即可。

这个条件不好直接计数，考虑用总数 $\dbinom{n}{x}$ 减去不合法的。考虑长度为 $x$ 的全 $1$ 串，往里插入 $n-x$ 个 $0$。我们发现 $0$ 只能插在两边 $k-1$ 个 $1$ 的旁边，否则插在中间 $0$ 就会成为满足条件的 $p$。也就是说，$0$ 有 $2k$ 个位置可以插。那么我们就是要把 $n-x$ 个 $0$ 放入 $2k$ 个位置，这是经典的组合数学问题，插板易得方案数量为 $\dbinom{2k-1+n-x}{2k-1}$。可以 $\mathcal O(n)$ 预处理后 $\mathcal O(1)$ 计算。

总时间复杂度 $\mathcal O(n \log n)$。

```cpp
/**
 *    author: sunkuangzheng
 *    created: 15.02.2024 22:43:43
**/
#include<bits/stdc++.h>
#ifdef DEBUG_LOCAL
#include <mydebug/debug.h>
#endif
using ll = long long;
const int N = 2e6+5,mod = 998244353;
using namespace std;
int T,n,f[N],g[N];
int qp(int a,int b){
    int r = 1;
    for(;b;b >>= 1,a = 1ll * a * a % mod) if(b & 1) r = 1ll * r * a % mod;
    return r; 
}void los(){
    auto C = [&](int n,int m){
        return (n < 0 || m < 0 || n < m ? 0 : 1ll * f[n] * g[m] % mod * g[n - m] % mod); 
    };
    cin >> n;
    for(int i = 1;i <= (n - 1) / 2;i ++){
        int ans = 0;
        for(int j = i * 2;j <= n;j += i * 2)
            ans = ((ans + C(n,j)) % mod - C(2 * i + n - j - 1,2 * i - 1) + mod) % mod;
        cout << ans + 1 << " ";
    }cout << "\n";
}int main(){
    f[0] = g[0] = 1,n = 1e6;
    for(int i = 1;i <= n;i ++) f[i] = 1ll * f[i - 1] * i % mod;
    g[n] = qp(f[n],mod - 2);
    for(int i = n - 1;i >= 1;i --) g[i] = 1ll * g[i + 1] * (i + 1) % mod;
    ios::sync_with_stdio(0),cin.tie(0);
    for(cin >> T;T --;) los();
}
```





---

## 作者：forest114514 (赞：6)

枚举 $k$ 和删除次数 $i$，一共 $O(N\ln N)$，每次 $O(1)$ 计算方案。

答案不太好直接算合法方案数，正楠则反，考虑容斥，用总方案数 $\binom{n}{2\times i\times k}$，减去不合法的方案数。

不合法的序列满足所有保留的数要么在第 $k$ 个删除的数的左边要么在第 $2\times i\times k-k+1$ 个数的右边，注意到第 $k$ 个到第 $2\times i\times k-k+1$ 个删除的数是连续的一段，枚举这一段左端点 $p$，不合法的方案数为：
$$
\sum\limits_{p=k}^{n-2\times i\times k+2\times k-1} \binom{p-1}{k-1}\binom{n-2\times i\times k+2\times k-1-p}{k-1}
$$
注意到 $p\in [1,k-1]$ 时，$\binom{p-1}{k-1}=0$，所以下界可以直接变成 1，所以不合法方案数为：
$$
\sum\limits_{p=1}^{n-2\times i\times k+2\times k-1} \binom{p-1}{k-1}\binom{n-2\times i\times k+2\times k-1-p}{k-1}
$$
稍微改写了一下：
$$
\sum\limits_{p=1}^{n-2\times i\times k+2\times k-1} \binom{(-1)+p}{k-1}\binom{(n-2\times i\times k+2\times k-1)-p}{k-1}
$$
注意到 $-(-1)=1$，所以原式满足上指标卷积的形式，所以：
$$
\sum\limits_{p=1}^{n-2\times i\times j+2\times k-1} \binom{(-1)+p}{k-1}\binom{(n-2\times i\times k+2\times k-1)-p}{k-1}=\binom{n-2\times i\times k+2\times k-1}{2\times k-1}
$$
这样就能简单计算了。

code：

```cpp
for(int k=1;k*2<n;++k){
	LL ans=1;
	for(int i=1;2*k*i<=n;++i){
		ans=(ans+C(n,2*i*k)-C(n-2*i*k+2*k-1,2*k-1)+mod)%mod;
	}
	write(ans,' ');
	} 
}
```

---

## 作者：Accepetd (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/CF1930E)

### 题目大意

给一个 $n$ 和 $k$ 以及一个长度为 $n$ 的数列 $a$ 满足 $a_i=i$。

一次操作可以选择一个长度为 $2k+1$ 的子序列，删除它的前后的 $k$ 个元素。

对于每一个 $1≤k≤ \lfloor \frac{n-1}{2} \rfloor$，求出可以得到的序列个数，并对 $998244353$ 取模。

---

### 大致思路

我们先把问题转换为更一般的形式：如果一个数被删去，将其标记为 $1$，否则标记为 $0$。问题就是 $01$ 串的数量。

接下来我们考虑什么样的 $01$ 串是合法的。发现并不好想。

那么不如考虑什么样的 $01$ 串是不合法的。

- 如果 $1$ 的个数不是 $2k$ 的倍数，那么不合法。
- 考虑最后一步，操作之后，中间的数没有被删除，所以一定存在一个 $0$，使得左右两边都有大于等于 $k$ 个 $1$。反之，如果不存在 $0$ 使得左右两边都有大于等于 $k$ 个 $1$，那么不合法。

上面的否条件是原问题的必要条件。

枚举 $k$，枚举操作次数 $m$，考虑用所有方案减去不合法的方案，即 $C_{2mk}^{n}$ 减去不合法方案。

不合法的方案中，左边第 $k$ 个 $1$ 到右边第 $k$ 个 $1$ 之间肯定全是 $1$，那不妨将它们压缩成单独一个 $1$，然后计算方案即可，即 $C_{n-2mk+2k-1}^{2k-1}$。

时间复杂度是调和级数，因为 $\frac{n}{1}+\frac{n}{2}+...+\frac{n}{n}=O(n \ln n)$。

---

## 作者：233L (赞：2)

我们考虑选一些位置（$2k$ 的倍数）删去。观察到，只要存在一个位置 $p$ 未被删去，且它前面至少删了 $k$ 个，后面也至少删了 $k$ 个，那么这个删除方案就合法。

> 感性理解，贪心地删删删，最后左边剩 $k$ 个，右边剩 $k$ 个，再进行一次删除。

> 证明可以考虑归纳。我们以 $p$ 为中心，左边删去 $k$ 个，右边删去 $k$ 个，通过选择适当的方案，一定还存在这样的位置 $p$（或者都删完了）。

然后就简单了！对于一个 $k$，我们枚举删除次数 $i$，有 ${n \choose i\times 2k}$ 种方案。不合法，说明 $[k,n-k+1]$ 的删除位置都连续，把它们看成一个整体，不合法的方案有 ${n-i\times 2k+2k-2\choose 2k-2}$ 种，扣掉就好了。

$i$ 有 $\left \lfloor \frac{n}{2k} \right \rfloor$ 个，时间复杂度 $O(n \log n)$。[246955642](https://codeforces.com/contest/1930/submission/246955642)

---

## 作者：是青白呀 (赞：2)

## 题意简述

给一个长度为 $n$ 的序列 $a$ 满足 $a_i=i$，每次可以在序列 $a$ 中选择其长度为 $2k+1$ 的子序列，并从 $a$ 中删除该子序列前 $k$ 个和后 $k$ 个数。操作若干次后停止，对于每一个 $1\leq k\leq \lfloor\frac{n-1}{2}\rfloor$，求出有多少种结束时的序列是可能出现的。

## 题解

除开不进行任何操作的情形，考虑怎样的结束序列是合法的。

不难发现一个必要条件是：结束序列中要至少存在一个数，使得其左侧至少有 $k$ 个数被删除、右侧也至少有 $k$ 个数被删除。若不满足这个条件，则最后一次操作无法进行，显然不合法。

考虑证明这个条件是充分的，也即构造一种给结束序列填数的合法方案，使得在上述条件下，我们能将结束序列还原成初始序列 $a$。

考虑这样一种还原方案：假设满足上述条件的数为 $x$，其左侧有 $i$ 个数被删除，右侧有 $j$ 个数被删除，不妨设 $i<j$，大于等于的情况类似。我们在左侧从小往大填入 $k$ 个已被删除的数；对于剩余的被删除的数，我们选择最中间的 $k$ 个填入。在左侧已经填了 $k$ 个数的基础上，后填的这 $k$ 个数一定均在右侧（极端情况是 $i=j$，此时后填的 $k$ 个数恰好是 $x$ 右侧最近的 $k$ 个数）。这样，剩余的空位一定全部以后填的 $k$ 个数为中心，接下来我们以这 $k$ 个数为中心选择，直到填满即可。

接下来考虑如何计数。“至少”的情况是不好计算的，我们考虑利用总情况数减去不合法的情况数得到合法情况数。对于一个确定的 $k$，我们枚举删除次数 $x$，则结束序列中有 $m=n-2xk$ 个数，总情况数应当为 $C_n^m$。不合法的情况实际上是所有结束序列中的数仅在前 $k$ 个被删除的数或后 $k$ 个被删除的数的内部出现。考虑插板法，共有 $m$ 个板子，可重复地插入 $2k$ 个空隙中，方案数为 $C_{2k+m-1}^m$，则不难 $O(1)$ 计算每个 $x$ 对应的答案。

对于一个 $k$，我们需要枚举的 $x$ 仅有 $\frac{n}{2k}$ 个，因此总的枚举个数实际上是 $O(n\log n)$ 级别，暴力枚举即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define mp make_pair
#define fir first
#define sec second
#define pii pair<int,int>
#define int long long
using namespace std;
typedef long long ll;
const int N=1e6+5,M=1e6+5,S=(1<<22)+5,mo=998244353,inf=1e18+7,bs=19491001;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int T;
int jc[N],qj[N];
int quick_power(int base,int x){
	int res=1;
	while(x){
		if(x&1)res*=base,res%=mo;
		base*=base,base%=mo;
		x>>=1;
	}
	return res;
}
int c(int n,int m){
	if(n<m)return 0;
	return jc[n]*qj[m]%mo*qj[n-m]%mo;
}
void solve(){
	int n;
	read(n);
	rep(k,1,(n-1)/2){
		int ans=0;
		rep(x,1,(n-1)/(2*k)){
			int m=n-x*2*k;
			ans+=c(n,m),ans=(ans-c(2*k+m-1,m)+mo)%mo;
		}
		printf("%lld ",ans+1);//最后加一个都不删的情况 
	}
	puts("");
	return;
}
signed main(){
	jc[0]=qj[0]=1;
	rep(i,1,1000000)
	    jc[i]=jc[i-1]*i%mo,qj[i]=quick_power(jc[i],mo-2);
	read(T);
	while(T--)
	    solve();
	return 0;
}
```

---

## 作者：2022dyx (赞：0)

首先考虑如何判定一个子序列是否能由原序列得到，由于一切东西都是有序的，所以我们用一个长度为 $n$ 的 $01$ 串来表示子序列，其中 $0$ 表示这个数不存在，$1$ 表示存在。

先给出结论，一个**真**子序列能得到当且仅当这个子序列中 $0$ 的个数是 $2k$ 的倍数且存在一个 $1$ 满足其左右两边 $0$ 的数量均不小于 $k$。必要性是显然的，不满足前者则无法用整数次操作完成，不满足后者则最后一次操作不可能存在。下面证明充分性。

我们分 $0$ 的个数为 $2k$ 或 $4k$ 以上来讨论，若 $0$ 的个数为 $2k$ 且存在 $1$ 满足其左右两边 $0$ 的数量均不小于 $k$，则那个 $1$ 左右两边必然都是恰好 $k$ 个 $0$，此时只要最后也是唯一一次操作选择的是这个数即可达成。而若 $0$ 的个数不小于$4k$，则必然有一侧 $0$ 的个数不小于 $2k$，我们只需在这一侧的边上留 $k$ 个 $0$ 给下一次，另一侧随便取，下一次一定还满足条件，归纳可证必要性。

在有了充要条件之后这道题就简单了。正难则反，我们容斥求出不满足条件的方案数。首先我们枚举 $k$ 的值和 $0$ 的个数 $2ck$，若要不满足条件一定是除左右两侧的 $k-1$ 个 $0$ 外其余的 $0$ 都挨在一起，我们将挨在一起的 $0$ 缩为一个。此时两侧有 $2k-2$ 个 $0$，再加上中间的是 $2k-1$ 个。而因为 $2ck-(2k-2)$ 个 $0$ 缩在一起了，所以总点数为 $n-(2ck-(2k-2))+1$，则方案数为 $\binom{n-(2ck-(2k-2))+1}{2k-1}$。总方案数是 $\binom{n}{2ck}$，减掉之后加上啥也不干的 $1$ 的贡献就是答案。

那么复杂呢？因为 $c$ 在 $O(\frac{n}{k})$ 量级，所以复杂度为 $O(n \log n)$。

下面给出代码：
```
#include <bits/stdc++.h>
#define int long long
#define pb push_back
#define file(x) freopen(#x ".in", "r", stdin); freopen(#x ".out", "w", stdout);
using namespace std;
constexpr int N = 1e6 + 5;
constexpr int mod = 998244353;
int t, n, fac[N], inv[N];
int pw(int x, int y) { return !y ? 1 : (y & 1 ? x : 1) * pw(x * x % mod, y >> 1) % mod; }
int C(int x, int y) { return fac[x] * inv[y] % mod * inv[x - y] % mod; }
signed main() {
    cin.tie(0) -> sync_with_stdio(false); 
    fac[0] = 1;
    for (int i = 1; i < N; ++i) fac[i] = fac[i - 1] * i % mod; 
    inv[N - 1] = pw(fac[N - 1], mod - 2);
    for (int i = N - 2; ~i; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
    cin >> t;
    while(t--) {
        cin >> n;
        for (int i = 1; i <= (n - 1) / 2; ++i) {
            int ans = 1;
            for (int j = 1; j <= (n - 1) / (2 * i); ++j) ans = (ans + C(n, 2 * i * j) - C(n - 2 * i * j + 2 * i - 1, 2 * i - 1) + mod) % mod;
            cout << ans << ' ';
        }
        cout << '\n';
    }
    
}
```

---

## 作者：_Ch1F4N_ (赞：0)

神秘结论题。

首先我们会进行的操作比较多，考虑先从一些特殊的操作入手，你发现几乎所有的操作都可以用后面操作删去的点当第 $k+1$ 个点，唯独最后一次操作不行，所以一定存在一个没被删去的点满足其前后均有至少 $k$ 个未被删去的点，由于没法找到其他比较好的条件，下面试说明这个条件的充分性（必要性已经说明）。

不妨令删去的位置集合为 $S$，我们从最后一个操作开始往前推就是不断删去 $S$ 中数的过程，可行进行至少一次删除一个充分条件是存在一个不存在于 $S$ 中的数（下文称其为删除中心），满足其前后至少各有 $k$ 个存在于 $S$ 中的数，只要证明从一个可以操作的状态出发可以一直操作知道 $S$ 为空就可以说明条件的充分性，考虑构造如下策略：在每次操作时假若删除中心左右数同样多，挨着删除中心删，那么删除中心依然是删除中心，否则假若左边数多，在左边挨着删除中心删 $k-1$ 个数，右边挨着删除中心删 $k$ 个数，此时 $S$ 集合的中位数一定在删除中心左边，将其删去后其就可以变为删除中心。

知道了充要条件，考虑计数，不妨枚举一共删去了多少数（枚举量为 $\sum_k \frac{n}{2 \times k} = O(n \log n)$），假若删去了 $2 \times m \times k$ 个数，那么删除方案不合法当且仅当删去的数中除了前后 $k-1$ 个数，剩下的数连成了一段，我们考虑将这段缩起来，于是方案映射到在 $n - (2 \times m \times k - 2 \times k + 2) + 1$ 个数中选出 $2 \times k - 1$ 个数，将选出的数中的中位数变回一个长度为 $2 \times m \times k - 2 \times k + 2$ 的连续段即可映射到原方案，不难发现这是一个双射，预处理组合数后即可简单计算。

时间复杂度 $O(n \log n)$。

[代码](https://codeforces.com/contest/1930/submission/293619245)

---


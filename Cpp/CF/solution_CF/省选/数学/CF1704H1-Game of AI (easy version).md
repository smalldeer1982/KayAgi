# Game of AI (easy version)

## 题目描述

这是本题的简单版本。简单版本与困难版本的区别在于对 $k$ 的约束和时间限制。此外，在本版本中，你只需要计算 $n=k$ 时的答案。只有当两个版本均被解决时，你才能进行 hack。

Cirno 正在玩一款战争模拟游戏，其中有 $n$ 座塔（编号为 $1$ 至 $n$）和 $n$ 个机器人（编号为 $1$ 至 $n$）。初始时，第 $i$ 座塔被第 $i$ 个机器人占据（$1 \le i \le n$）。

在游戏开始前，Cirno 首先选择一个长度为 $n$ 的排列 $p = [p_1, p_2, \ldots, p_n]$（一个长度为 $n$ 的排列是指每个 $1$ 到 $n$ 的整数恰好出现一次的数组）。接着，她选择一个序列 $a = [a_1, a_2, \ldots, a_n]$（满足 $1 \le a_i \le n$ 且 $a_i \ne i$ 对所有 $1 \le i \le n$ 成立）。

游戏包含 $n$ 轮攻击。在第 $i$ 轮中，如果第 $p_i$ 个机器人仍在游戏中，它将发起攻击，导致第 $a_{p_i}$ 座塔被第 $p_i$ 个机器人占据；原本占据第 $a_{p_i}$ 座塔的机器人将失去该塔。如果第 $p_i$ 个机器人已不在游戏中，此轮不会发生任何事。

每轮结束后，如果一个机器人未占据任何塔，它将被淘汰并退出游戏。注意一座塔不能同时被多个机器人占据，但一个机器人可以在游戏中占据多座塔。

游戏结束时，Cirno 将记录结果序列 $b = [b_1, b_2, \ldots, b_n]$，其中 $b_i$ 表示结束时占据第 $i$ 座塔的机器人编号。

然而，作为数学大师，她希望你解决以下计数问题而非亲自游戏：

计算所有可能的序列 $a$ 和排列 $p$ 能生成的不同序列对 $(a, b)$ 的数量。

由于结果可能很大，请输出其对 $M$ 取模后的值。

## 说明/提示

当 $n=1$ 时，不存在合法的序列 $a$，因此答案为 $0$。

当 $n=2$ 时，唯一可能的数组 $a$ 是 $[2, 1]$：
- 当 $a$ 为 $[2, 1]$ 且 $p$ 为 $[1, 2]$ 时，最终序列 $b$ 为 $[1, 1]$。具体过程：
  - 第一轮，第一个机器人发起攻击并占领第 $2$ 座塔。此轮结束后，第二个机器人因失去所有塔而被淘汰。
  - 第二轮，第二个机器人已不在游戏中。
- 当 $a$ 为 $[2, 1]$ 且 $p$ 为 $[2, 1]$ 时，最终序列 $b$ 为 $[2, 2]$。具体过程：
  - 第一轮，第二个机器人发起攻击并占领第 $1$ 座塔。此轮结束后，第一个机器人被淘汰。
  - 第二轮，第一个机器人已不在游戏中。

因此当 $n=2$ 时，不同的序列对 $(a, b)$ 的数量为 $2$（即 $([2, 1], [1, 1])$ 和 $([2, 1], [2, 2])$）。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
1 998244353```

### 输出

```
0```

## 样例 #2

### 输入

```
2 998244353```

### 输出

```
2```

## 样例 #3

### 输入

```
3 998244353```

### 输出

```
24```

## 样例 #4

### 输入

```
8 998244353```

### 输出

```
123391016```

# 题解

## 作者：tanyulin (赞：10)

做法来自官方题解。

首先，假设 $b$ 是固定的，计算不同 $a$ 的数量。

可以发现如下性质：

+ 如果 $b_i\neq i$，说明 $i$ 被 $b_i$ 占领，一定有 $a_{b_i}=i$。
+ 如果 $b_i=i$，意味着对于所有 $a_j=i$，$j$ 攻击前已经被占领，那么一定有 $b_j\neq j$。

我们对于所有 $b_i\neq i$，$i$ 向 $b_i$ 连一条有向边，此时如果有环，一定无解。这样整个图就由若干条链构成，链尾就是所有 $b_i=i$ 的点，一定有解。

举个例子，对于 $5 \rightarrow 2 \rightarrow 1\rightarrow 4 \rightarrow3$，我们可以这么安排进攻顺序：$2$ 去攻占 $5$，$1$ 去攻占 $2$，$4$ 去攻占 $1$，$3$ 去攻占 $4$。而如果有环，无论选哪个开始进攻，都会使一人在进攻前自己城堡被占领，无法攻占指定城堡。

根据性质 $1$ ，这些链除了链头，其余 $a$ 都是固定的。对于链长大于 $1$ 的链头，他没有占领任何一个城堡，它的 $a$ 可以是除本身外的任何值，因为按照例子里的攻击顺序，我们可以让他在攻击前失去城堡，这样他无法进攻，任何 $a$ 都不会对结果有影响。而如果链长为 $1$，根据性质 $2$，他的 $a$ 不能是其他链的链尾。

计数时，枚举链长大于 $1$ 的个数和链长为 $1$ 的个数，组合数算算就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5010;
int fac[N],infac[N],mi[N][N],n,mod,ans;
int inc(const int &a,const int &b){return a+b>=mod?a+b-mod:a+b;}
int dec(const int &a,const int &b){return a-b<0?a-b+mod:a-b;}
int mul(const int &a,const int &b){return 1ll*a*b%mod;}
int sqr(const int &a){return 1ll*a*a%mod;}
void Inc(int &a,const int &b){a=a+b>=mod?a+b-mod:a+b;}
void Dec(int &a,const int &b){a=a-b<0?a-b+mod:a-b;}
void Mul(int &a,const int &b){a=1ll*a*b%mod;}
void Sqr(int &a){a=1ll*a*a%mod;}
int qmi(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1) Mul(res,a);
		Sqr(a),b>>=1;
	}
	return res;
}
void init()
{
	fac[0]=1;
	for(int i=1;i<N;i++) fac[i]=mul(fac[i-1],i);
	infac[N-1]=qmi(fac[N-1],mod-2);
	for(int i=N-2;i>=0;i--) infac[i]=mul(infac[i+1],i+1);
	for(int i=1;i<N;i++)
	{
		mi[i][0]=1;
		for(int j=1;j<N;j++)
			mi[i][j]=mul(mi[i][j-1],i);
	}
}
int binom(int a,int b)
{
	if(a<b) return 0;
	return mul(fac[a],mul(infac[b],infac[a-b]));
}
int main()
{
	cin>>n>>mod;
	init();
	for(int i=1;i*2<=n;i++)
		for(int j=0;j+i*2<=n;j++)
			Inc(ans,mul(binom(n,j),mul(fac[n-j],mul(mi[n-1][i],mul(mi[n-i-j][j],mul(binom(n-i-j-1,i-1),infac[i]))))));
	cout<<ans<<endl;
	return 0;
 } 

```

---

## 作者：tzc_wk (赞：5)

以下讨论只针对 H1，由于 H1 和 H2 做法不太一样，所以如果想知道 H2 的做法可以去看 zky 的题解或者官方题解。

非常好的 AGC 风格的题，给出题人点个赞。

首先考虑给定的基环内向森林 $a$，如何对 $b$ 计数？我们假设 $S_i$ 表示 $i$ 在 $b$ 中出现的位置集合，那么不难发现 $S_i$ 最多只有四种可能：$\varnothing,\{i\},\{a_i\},\{i,a_i\}$。考虑这三种情况什么时候出现。我们假设我们确定 $S_i=\{i,a_i\}$，考虑这会带来怎样的影响，显然 $a_i\notin S_{a_i}$，如果 $S_{a_i}=\varnothing$ 那么这个 $S_i$ 带来的影响就到此为止了，如果 $S_{a_i}=\{a_{a_i}\}$ 那么 $a_{a_i}$ 也不能属于 $S_{a_{a_i}}$，以此类推一定会到达一个 $S_i=\varnothing$ 的点，不难发现这构成了若干个长度 $\ge 2$ 的链。显然每个点最多属于一条链，但是并不一定所有点都属于恰好一个链，我们考虑孤立点有什么性质，如果我们将它们视作长度为 $1$ 的链，那么有结论：每个孤立点不能连向其他链的链尾节点，其他点都是合法的，因为孤立点 $x$ 连到一个链尾节点 $y$，如果 $x$ 比 $y$ 先操作 $y$ 就死了，如果 $y$ 比 $x$ 先操作，那么有 $b_y\ne y$，而链尾节点必须有 $b_y=y$，因此不合法。而对于其他节点，假设我们连到的节点为 $y$，$y$ 在链上下一个节点为 $z$，那么我们操作完 $y$ 后直接操作 $x$，再直接操作 $z$ 即可消除 $x$ 带来的影响。

接下来考虑如何计数，由于孤立点和其他点不一样，我们先枚举孤立点个数 $x$，再枚举 $\ge 2$ 的链的条数 $y$，那么将剩余 $n-x$ 个点划分成 $y$ 条链的方案数是 $[x^{n-x}](n-x)!·\dfrac{1}{y!}B(x)^y$，其中 $B(x)$ 为长度为 $l$ 的 $\ge 2$ 的链的方案数的 EGF，为 $\sum\limits_{i\ge 2}\dfrac{i!x^i}{i!}=\sum\limits_{i\ge 2}x^i$，直接背包即可，确定孤立点和其他点的相对标号的方案数为 $\dbinom{n}{x}$，确定链头节点的 $a$ 的方案数为 $(n-x-y)^x·(n-1)^y$，乘起来求和就是答案。

时间复杂度 $n^2$。

---


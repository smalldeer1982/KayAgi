# Club of Young Aircraft Builders (hard version)

## 题目描述

这是该问题的困难版本。各版本间的区别在于此版本中不要求所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每架飞机的发射者所在楼层。遗憾的是，关于部分飞机的具体发射者信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
8
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0
6 1 3
2 0 0
2 3 5
0 0 1 0 2
3 3 4
3 3 3 0
2 1 2
0 1
2 1 2
0 2
5 3 12
0 0 1 0 2 4 0 0 0 5 0 5```

### 输出

```
6
190
3
2
0
0
1
14```

# 题解

## 作者：ForgotMe (赞：7)

简单概括一下题意：

对满足以下条件的长度为 $m$ 的序列 $a$ 计数：

- $a_i\in[1,n]$，且某些位置上的数已经确定。
- 值为 $n$ 的数恰好出现了 $c$ 次，且对于任意 $i$，$\sum_{j=1}^{i}[a_j\ge a_i]\le c$。

在 easy version 中，由于没有位置上的值是固定的。很快可以想到从大到小插入数进去，插入的方案数容易通过组合数进行计算，没啥难度。

但在 hard version 中，上述做法失效了，因为其无法保存下来每个值在最终序列的位置。我们需要找到另外一个跟序列位置挂钩的充要条件。

首先容易观察出满足 $a_i=1$ 的所有位置 $i\in[1,c]$。那么 $a_i=2$ 的 $i$ 有什么限制吗？手推可知 $i\in[1,c+cnt_1]$，其中 $cnt_i$ 表示值 $i$ 的出现次数。于是自然地便可以归纳出最终结论：一个合法的序列 $a$ 需要满足：$\forall 1\le i\le n$，设值 $i$ 出现的最大位置为 $pos_i$，则 $pos_i\in[1,c+\sum_{k=1}^{i-1}cnt_k]$。这个条件显然是充要的。

现在来考虑如何设计 dp，设 $dp_{i,j}$ 表示已经确定了值 $[1,i]$ 的位置，且 $\sum_{k=1}^i cnt_k=j$ 的方案数。转移是容易的，枚举值 $i+1$ 最终填的个数 $p_1$，那么 $[1,\min(j+c,n)]$ 中出来已经确定填 $i+1$ 的位置个数 $p_2$（一个需要注意的点是 $[1,\min(j+c,n)]$ 一定要覆盖到所有最开始就确定填 $i+1$ 的位置），还需要填 $p_1-p_2$ 个 $i+1$，注意 $[1,\min(j+c,n)]$ 中确定填 $>i+1$ 的值的位置是不能填的。于是计算出还能填的空白位置个数 $p_3$，则 $\binom{p_3}{p_1-p_2}$ 就是转移的转移系数。于是本题得以解决。时间复杂度 $\mathcal{O}(nmc)$。

代码：https://www.luogu.com.cn/paste/8ix7sl3g

---

## 作者：lfxxx (赞：0)

好难，自己独立做做了一万年才会。

[紧接着 D1 的做法继续](https://www.luogu.com.cn/article/9hmk1u4r)，我们来考虑一些已经填了数的位置咋办，考虑把空位置单独拉出来做和 D1 类似的事情，但是要考虑填了数的位置的影响，因为从大往小填数时是在序列的开头取出一些数插入一些数再放回去，所以不妨认为我们已经填的序列对应空位置序列的一段后缀，考虑最开始已经填了的位置对我们填的数的影响，首先一个显然的事情是，在考虑填值为 $x$ 的数时，只需要我们填的最靠后的位置满足限制即可，因此在不考虑还没有填的数在后面插入序列可能带来影响时，限制其实是插入序列的值为 $x$ 的最靠后的数前面至多有若干个值大于 $x$ 的数，这个限制具体是多少可以通过预处理前缀值域信息与在从大往小枚举填了多少个值等于 $x$ 的数的过程中用暴力扩展值的方式求出，知道了限制具体是多少后方案数是一个组合数前缀和状物，也可以预处理求出。而我们填的数对最开始已经填了的位置的影响在不考虑还没有填的数插入序列的影响时也能用类似的方法刻画出限制。

那如果后面插入序列的数产生了影响怎么办？

注意到后面插入序列的数假若产生了影响，必然会因为其值更小而产生更严格的限制，并且会在考虑其时考虑到这个更严格的限制，而当下这个没有那么严格的限制我们让其满足就是没有任何影响的，所以说前面提到的限制是充要的。

于是可以用类似于 D1 的方法 dp，注意一下上面提到的新限制即可，时间复杂度 $O(n \times m \times c)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9+7;
const int maxm = 1e4+114;
const int maxn = 214;
int dp[maxm],g[maxm];
int cnt[maxm][maxn];//[1,i] 中大于等于 j 的数数量
int a[maxm];
int n,m,c,M;
int C[maxn][maxn];
int f[maxn][maxn];//f[x][y]=\sum_{i=0}^{x} C[x+y][x]
int fr[maxm];//第 i 个空出来的位置
int pre[maxm];//前面的空位数量
int mx[maxn];//最靠后的出现位置
void init(){
    C[0][0]=1;
    for(int i=1;i<maxn;i++){
        C[i][0]=1;
        for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }
    for(int i=0;i<maxn;i++) f[0][i]=1;
    for(int i=1;i<maxn;i++){
        for(int j=0;j<maxn;j++) f[i][j]=(f[i-1][j]+C[i+j][j])%mod;
    }
}
void work(){
    cin>>n>>c>>m;
    for(int i=1;i<=m;i++){
        cin>>a[i];
        M+=(a[i]==0);
        if(a[i]==0) fr[M]=i;
        mx[a[i]]=i;
        pre[i]=M;
        for(int j=1;j<=n;j++) cnt[i][j]=cnt[i-1][j]+(a[i]>=j);
    }
    if(a[m]!=0&&a[m]!=n){
        cout<<0<<"\n";
    }else{
        if(cnt[m][n]>c){
            cout<<0<<"\n";
        }else{
            dp[c-cnt[m][n]]=1;
            for(int i=n-1;i>=1;i--){
                for(int j=0;j<=M;j++){
                    int lim=-1;
                    //最多在 lim 个已经放的数后面
                    for(int k=c;k>=1;k--){
                        while(lim+1<=j&&lim+1+cnt[fr[M-(j-(lim+1)+1)+1]][i]+k<=c) lim++;
                        if(lim!=-1&&j+k<=M) g[j+k]=(g[j+k]+dp[j]*f[lim][k-1]%mod)%mod;
                    }
                }
                for(int j=0;j<=M;j++) dp[j]=(dp[j]+g[j])%mod,g[j]=0;
                //考虑 mx[i]
                if(mx[i]!=0){
                    for(int j=0;j<=M;j++){
                        int lim=pre[mx[i]];
                        if(max(0*1ll,lim-(M-j+1)+1)+cnt[mx[i]][i]>c) dp[j]=0;
                    }
                }
            }
            cout<<dp[M]<<"\n";
        }
    }
    for(int i=0;i<=m;i++) dp[i]=0;
    for(int i=0;i<=m;i++)
        for(int j=0;j<=n;j++) cnt[i][j]=0;
    for(int i=0;i<=n;i++) mx[i]=0;
    for(int i=0;i<=m;i++) fr[i]=pre[i]=0;
    M=0;
}
signed main(){
    init();
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--) work();
    return 0;
}
/*
1
2 3 5
0 0 1 0 2
*/
```

---


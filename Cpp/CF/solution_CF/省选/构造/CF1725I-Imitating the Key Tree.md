# Imitating the Key Tree

## 题目描述

Pak Chanek 有一棵密钥树。这棵树包含 $N$ 个顶点和 $N - 1$ 条边。这些边按照 $1$ 到 $N - 1$ 连接着 $U_i$ 和 $V_i$。最开始，所有边都没有权值。

长度是 $k$ 的路径可以看成这样： $[v_1, e_1, v_2, e_2, v_3, e_3, \ldots, v_k, e_k, v_{k+1}]$ 而且满足以下条件。

- 对于每个 $ i $ , $ v_i $ 是一个顶点且 $ e_i $ 是一条边。
- 对于每个 $ i $ , $ e_i $ 连接了顶点 $ v_i $ 和 $ v_{i+1} $ .

一个环就是一个路径开始和结束顶点相同。

当且仅当路径不多次使用同一条边时，图中的路径称为简单。请注意，简单路径可以多次使用同一顶点。

有权图中简单路径的权重为它所遍历的所有边的最大权重。

要求计算满足以下条件的不同无向带权图的数量：

- 图有 $ N $ 个顶点和 $ 2N-2 $ 条边.
- 对于每一对顶点 $ (x, y) $ , 一定有一条简单环路通过了 $ x $ 和 $ y $。
- 每条边的权重为 $ 1 $ 到 $ 2N-2 $ 的一个整数，而且每条边的权重不同。
- 该图可以这样的方式生成，即有一种方法将权重 $W_i$ 分配给满足以下条件的密钥树中的每个边$i$：
  - 对于每一对边 $ (i, j) $ , 如果 $ i<j $ , 那么 $ W_i<W_j $ .
  - 对于每一对不同的顶点编号 $ (x, y) $ , 从 $ x $ 到 $ y $ 唯一的简单路花费等于通过图中顶点 $x$ 和 $y$ 的简单环路的最小成本。
- **请注意，图可能有重边，但没有自环。**

输出答案对 $998\,244\,353 $ 取模的结果。

当且仅当存在三元组$（a，b，c）$时，两个图被认为是不同的，从而在一个图中存在将顶点$a$和$b$与权重$c$连接的边，而在另一个图上不存在。

## 说明/提示

以下是满足条件的图的示例。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1725I/ae64acaed8a0654fb213b3ba04ba233fb7851789.png)

以下是对应于上图的关键树中边权重的分配。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1725I/ca1e3ceaa14370bc99569a5f3161852eabcf5f60.png)

例如，考虑一对顶点索引 $ (1, 4) $ .

- 这对顶点的环路是 $ 3 \xrightarrow{2} 2 \xrightarrow{4} 4 \xrightarrow{6} 2 \xrightarrow{1} 1 \xrightarrow{5} 3 $ ，花费为 $ 6 $ .
- 这对顶点的路径为： $ 1 \xrightarrow{5} 3 \xrightarrow{6} 4 $ 花费为 $ 6 $ .

对于 $100\%$ 的样例，$ 2 \le N \le 10^5 ， 1 \le U_i, V_i \le N 。$

## 样例 #1

### 输入

```
4
3 2
1 3
4 3```

### 输出

```
540```

# 题解

## 作者：SnowTrace (赞：5)

2800？1800！

简单套路题。

首先我们发现这个限制有点太难处理，来考虑树上的链的最大值相关问题。

那么肯定是我们从小到大给边排个序再按照这个顺序连上，那我们每次考虑到一条边的时候，这条边两端所属的两个联通块之间的点的路径的最大值就是这条加进去的边的权值。（也可以说是 kruskal 重构树）

那么我们就需要通过构建一张图凑出这样的权值。



在树上加边的过程中同时也在我们的图上加边，显然我们想让两个联通块之间有环需要在两个联通块之间加上两条边。

一个观察是发现你可以随便选两个联通块中的两个点连边，并不会影响答案，这是因为我们不管怎么在联通块中选点连通性都不会发生改变，也就是说我们在加进去一条边后答案乘上 $sz_u^2\times sz_v^2$，然后接下来只需要考虑每次加进去两条边的权值。

显然我们加进去其中一条边的权值应该比当前所有加进图里的边都大（因为我们目前加进去的树边肯定是当前树边中最大），然后容易证明的是，我们按照这样的加边方式任意钦定合法权值，可以涵盖所有的树边上权值的选择方案。

接下来就是要对这个计数，形式化的，现在我们有一个排列 $p$

$p_{2i}>\max\{p_1,p_2,...,p_{2_i-1}\}$，要对它计数。

考虑递推，最后一个数肯定最大，然后倒数第二个数可以随便选一个，然后就有 $f_{2_i} = f_{2i-2}\times(2i-1)$。

于是就可以直接做了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 998244353;
int n;
int ans = 1;
int fa[100005],sz[100005];
int find(int x){
	if(fa[x] == x)return x;
	return fa[x] = find(fa[x]);
}
void merge(int x,int y){
	fa[x] = y;sz[y]+=sz[x];
}
int pro = 1;
signed main(){
	cin >> n;
	for(int i = 2*n-3;i>=1;i-=2)pro = pro*i%mod;
	for(int i = 1;i<=n;i++)fa[i] = i,sz[i] =1;
	for(int i = 1;i<n;i++){
		int a,b;cin>> a >> b;
		pro = pro*sz[find(a)]%mod*sz[find(a)]%mod*sz[find(b)]%mod*sz[find(b)]%mod;
		merge(find(a),find(b));
	}cout << pro << endl;
	
	return 0;
}
/*
屋顶的天空是我们的
放学后夕阳也都会是我们的
不会再让步更多了
*/
```

---

## 作者：cryozwq (赞：1)

首先不难想到对原树建重构树，因为它保证了边权递增，也就是重构树的形态是固定的，这样对于重构树上一个节点 $u$ 两个儿子的集合 $S_1,S_2$，$S_1,S_2$ 满足原图的性质， 现在连上这条边 $i$ 以后，$S_1$ 和 $S_2$ 中的任意两个 $u,v$，均有一个简单环经过，即下面的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/o58nj8ym.png)

就是说必然存在 $j<i$ 先行连接了 $S_1$ 和 $S_2$。

然后我们注意到图上共有 $2n-2$ 条边，而这样的情况会出现 $n-1$ 次，那么每个 $i$ 能且仅能对应一个 $j$。

我们可以看成有 $n-1$ 种颜色，给一个长度为 $2n-2$ 的序列染色，每个颜色只能用两次，且对于 $i<j$，$i$ 最后一次出现的位置早于 $j$ 最后一次出现的位置。

这样就把边权分配给了每条边，然后对于 $i,j$ 的端点，均有 $|S1|\times|S2|$ 种可能性。

而上面那个问题也是可以直接做的，注意到在满足每个颜色只用两次的情况下，恰有 $\frac{(2n-2)!}{(n-1)!}$ 种合法序列，所以总答案就是 $\frac{(2n-2)!}{(n-1)!2^{n-1}}$ 乘上每条边可能的取值。

代码就不放了，很好写。

---


# Palindrome Everywhere

## 题目描述

给定一个 $n$ 个点的环，编号为 $0$ 到 $n-1$，第 $i(0 \leq i \leq n-1)$ 个点向第 $((i+1) \bmod n)$ 个点连一条颜色为 $c_i$（$c_i$ 为 `R` 或 `B`）的无向边。问任意两点是否都满足它们之间有一条“回文路径”。

两点 $(i,j)$ 间的回文路径定义：（假设该回文路径包含的点集为 $p=[p_0,p_1,\dots,p_m]$）

- 回文路径必须是两点之间的一条路径，但 **可以不是简单路径**。

- 对于满足 $x+y=m-1$ 且 $0 \leq x \leq y \leq m-1$ 的两点 $p_x,p_y$，若连接 $p_x,p_x+1$ 的边的颜色和连接 $p_y,p_y+1$ 的边的颜色相同。

## 样例 #1

### 输入

```
7
5
RRRRR
5
RRRRB
5
RBBRB
6
RBRBRB
6
RRBBRB
5
RBRBR
12
RRBRRBRRBRRB```

### 输出

```
YES
YES
YES
NO
NO
YES
NO```

# 题解

## 作者：int08 (赞：4)

## 前言
半夜打 CF，上分爽一爽~

## 题意
给定一个环，边有红蓝双色，询问是否任意两点间都存在一条颜色回文路径（可以不简单）。
# Solution
直接给结论没意思，我想还原一下我赛时的想法：

根据样例一和二，先特判某一种颜色出现次数大于等于 $n-1$ 的答案为 Yes。

看到这种题目，显然考虑手玩样例来找找规律。

发现样例里所有奇数都有解，我先大胆猜测由于奇数对路径奇偶性没有限制，可能全部有解，于是尝试手玩一些证明这个结论。

但是被 `RRRBB` 卡掉了，$(1,4)$（从零标号）没有回文路径。

为啥没有？因为路径的第一步必然是 `R` 而最后一步必然是 `B`，包没有的。

这个很有启发性：环中不能同时存在形如 `RR` 和 `BB`，这个结论感觉方向很对，因为（考虑两种颜色反转不影响答案）现在问题可以简化为变成单个 `R` 和连续 `B` 段交替出现了。

发现由于路径可以不简单，`B` 连续段只和奇偶性有关，可以等价为长 $1$ 或者 $2$。

发现当 `B` 连续段长偶数时候，从两侧出去产生的 `B` 段长度奇偶性相同。

于是出现两个偶数 `B` 段就坠机了，理由，我放两个点，使它们在两个偶数 `B` 段中，且一个出去长为奇数，另一个长为偶数，这样开头和结尾的 `B` 段奇偶性不同。

同时由于 `RBRBRB` 也无解，我们发现没有偶数段也坠机了，具体的话，我们可以把原问题转化为：**两个点一起走，同一时刻两点只能走同色边，问能否汇合**。取 $(0,2)$ 发现它们总得向同一方向走才能同色边，无法汇合。

合理猜测，单个偶数段一定有解~~因为无解情况太多了~~。

确实如此，考虑如下构造方案：把一个点走到偶数段旁边之后，一个跳过偶数段，另一个走个来回（这样它调转了方向），然后就发现它们就能汇合了。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1145141
int n,T,i,j,a[N];
string s;
bool ip(int x)
{
	for(int i=2;i*i<=x;i++) if(x%i==0) return 0;
	return 1;
}
int myz[N];
int main()
{
//	cin.tie(0)->sync_with_stdio(0);
//	cout.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>n>>s;
		int tag=1;
		for(i=0;i<n;i++) if(s[i]!=s[0]) tag=0;
		if(tag)
		{
			cout<<"Yes\n";
			continue;
		}
		int rt=0,bt=0;
		for(i=0;i<n-1;i++) if(s[i]==s[i+1])
		{
			if(s[i]=='R') rt++;
			if(s[i]=='B') bt++;
		}
		if(s[n-1]==s[0]) s[0]=='R'?rt++:bt++;
		if(rt&&bt)
		{
			cout<<"No\n";
			continue;
		}
		if(bt) for(i=0;i<n;i++) s[i]=s[i]=='B'?'R':'B';
		s.resize(2*n+10);
		for(i=n;i<2*n;i++) s[i]=s[i-n];
		int pnt=0,jc=0,oc=0;
		while(s[pnt]!='B') pnt++;
		while(pnt<n)
		{
			int cnt=0;
			pnt++;
			while(s[pnt]=='R') pnt++,cnt++;
			if(cnt%2) jc++;
			else oc++;
		}
		if(jc+oc<=1||oc==1)
			cout<<"Yes\n";
			else cout<<"No\n";
	}
	return 0;
 } 
```
# The End.

---

## 作者：_lmh_ (赞：4)

如果这题往从一个合法区间通过两段乱跑的方式推到另一个合法区间的思路上面去想就没救了，应该从两个小朋友互相尝试接近对方的方向去想。

这样就启发我们去刁难小朋友，把它们放在一些恶心的位置。

### Part 1：同时存在 RR 和 BB

把它们分别放在 RR 和 BB 中间，你会发现它们一步都走不了，就废了。返回无解。

下文中假设字符串中不存在 BB，只可能存在 RR。

### Part 2：只有一段 R

显然不管我们怎么放小朋友，它们都肯定在一个同色的连续段内（包括端点），因此一定有解。

### Part 3：存在两段长为偶数的 R 连续段

现在我们想象小朋友被困在 R 的连续段上面，需要通过 B 的桥梁移动以接近对方。注意到小朋友每一步都必须要走，所以我们只要让它们没法同时到达 B 旁边，它们就被困住了。

把第一个小朋友放在（长为偶数的 R）的端点处，第二个小朋友放在另一个长为偶数的 R 连续段的端点旁边一格，这样他们的位置奇偶性不同，没办法一起跨过 B。

### Part 4：所有 R 连续段长度都为奇数

这样的话我们没法把小朋友困住了（R 连续段端点奇偶性不同）。

但这提供了另一个便利：（在初始位置不变的前提下）如果两个小朋友都在连续段的端点上，**那么如果我们钦定一个小朋友的位置（是左端点还是右端点），另一个小朋友的位置也就固定了。**

这就是说，如果第一个小朋友跨越 B 是顺时针的方向，那么我们可以控制第二个小朋友的初始位置，使得它必须往顺时针的方向走。这时，如果第一个小朋友尝试往逆时针走，第二个小朋友也只能往逆时针。

并且，走了一步之后，它们还在长度为奇数的连续段上，因此我们还能维持这个对应关系，两个小朋友走的方向还是相同的，因此它们永远无法追上对方。

返回无解。

### Part 5：存在恰好一个长为偶数的连续段

此时仍然不会出现小朋友没法走出当前连续段的情况。

先假设它们在不同的长为奇数的连续段上。其余情况要么显然有解，要么可以走两步之后归约到这种情况。

首先把它们都移到端点上。

如果此时一个小朋友要往顺时针走，一个小朋友要往逆时针走，那么我们把它们都移到另一个端点上，就是一个往逆时针走一个往顺时针走，都是互相接近。这两种方式肯定有一种不经过偶数的连续段，这样走可以规避掉奇偶性不同的问题。

否则，让它们一直顺时针走直到有一个跑到偶数连续段上，此时，让偶数连续段上的小朋友往另一端走，奇数连续段上的那位反复横跳，这样当前者到达另一端准备顺时针继续走时后面那位还在原来的端点可以逆时针走，这样它们就可以相遇了。

因此这种情况有解。

至此我们完成了分讨，$O(n)$ 跑几遍字符串就可以得出结果。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1000007;
ll T,n,fl;
char s[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>(s+1);s[fl=0]=s[n];
		for (int i=1;i<=n;++i) if (s[i]==s[i-1]){
			if (fl==0) fl=s[i];
			else if (fl!=s[i]) fl=-1;
		}
		if (fl==-1){
			cout<<"No\n";continue;
		}
		if (fl=='B') for (int i=0;i<=n;++i) s[i]='R'^'B'^s[i];
		ll cnt0=0,cnt1=0,pre=1,suf=n;
		while(s[pre]=='R'&&pre<=n) ++pre;
		if (pre>n){
			cout<<"Yes\n";continue;
		}
		while(s[suf]=='R') --suf;
		if (pre==suf){
			cout<<"Yes\n";continue;
		}
		if ((pre-1+n-suf)%2) cnt1=1;else cnt0=1;
		for (int i=pre+1,sum=0;i<=suf;++i){
			if (s[i]=='R') ++sum;
			else{
				if (sum&1) ++cnt1;else ++cnt0;sum=0;
			}
		}
		cout<<(cnt0==1?"Yes\n":"No\n");
	}
	return 0;
}
```

---

## 作者：Rosabel (赞：3)

作为勤劳的题解自动姬来写这篇题解二周目。

判定每个位置二元组是否存在回文串？假设其为 $(i,j)$。如果 $|i-j|\le1$，那么一定存在回文串。那么可以将下一步转换成这四个位置 $(i-1,j-1),(i-1,j+1),(i+1,j-1),(i+1,j+1)$ 的判定的或。那么当存在两个位置相邻字符分别为 $\texttt{RR}$ 和 $\texttt{BB}$，绝对无解（因为无法往任一方向拓展）。

那么此时两种字符中至少有一种字符保证其相同的连续字符构成的串长度不超过 $1$。不失一般性地设其为 $\texttt{R}$。那么即 $\texttt{B}$ 被 $\texttt{R}$ 切分成 $k$ 段。设每段长度为 $a_i$。

可以感性想一想能成为合法位置的等价条件为最终能跑到同一块 $\texttt{B}$，或者能跑到一个 $\texttt{R}$ 的左右侧。更直观地，两个指针只要能相遇（即使不在整数点上相遇）就是 $\texttt{YES}$。两个位置在一次变换中，要么仍旧处在同一个 $\texttt{B}$ 块内，要么同时跨越一个 $\texttt{R}$ 到相邻的 $\texttt{B}$。那么可以大概想想什么情况是不合法的。要么就是无法同时到 $\texttt{B}$ 的边界，要么是只能往同一个方向跑。不难发现，对于无法同时到 $\texttt{B}$ 的边界的情况等价于至少存在两个 $i$ 使得 $2\mid a_i$。对于另外一个条件呢，可以研究一下什么情况下跑的方向相同 / 相反。容易观察得当两个指针所在块奇偶性不同时方向相反；奇偶性相同时方向相同。那么总是方向相同的情况即全为奇数 / 偶数（记得 $m=1$ 的情况要特判为 $\texttt{YES}$）。那么剩下的情况只有 $a$ 恰好存在一个偶数。当两个指针有一个在偶数块内时，钦定原来在奇数块内的指针往一个方向跑（由于是环最终总能跑到偶数块内。另外一个指针可以在原地徘徊，最终总能相遇。当两个指针都在奇数块内时，往一个方向跑直到一个指针到偶数块内的时候，那么就转换成前一种情况了。那么剩下的情况必然是 $\texttt{YES}$。

通过以上想法可以直观推出结论，既稳妥速度又快。希望大家可以一同学学这个思路。

[code](https://codeforces.com/contest/2029/submission/290762603)

给珂爱的小妹妹点个赞吧 qwq

---

## 作者：KaisuoShutong (赞：1)

## CF2029F Palindrome Everywhere

### 题目描述

给定一个 $n$ 个点的环，环上相邻点间都有一条边，边的颜色为 `R` 或 `B`。

问是否对于任意两个边上的点，都存在一条路径（可以不是简单的），使得该路径是回文的。

多组数据，$\sum n\le 10^6$。

### 解法

首先观察到若 `RR` 和 `BB` 均存在，一定不合法。因为分别卡在中间的点生成的路径的两端一定异色。

现在不妨设环上没有 `BB` 存在。则给定的环变成了若干个 `R` 的连续段，连续段之间用单个的 `B` 分隔。

考察这样的连续段，显然其有用的信息只是长度的奇偶性。于是分析奇偶两种不同连续段。

对于长度为奇的连续段，从一端走到另一端的步数是奇数；而对长度为偶的则是偶数。

两个不同连续段内的点的回文路径构造方法可以是，两个点同步走一样颜色的边，最后相遇。

那么当两个点分别出现在两个不同的段内时，若想要相遇，则需要同时离开该段，也就是同时走到某一段。

分类讨论这两个段的奇偶性。若一奇一偶，则可以任意选择两端中的某一个离开；若两奇，可以离开，但不能更换方向（例如，可以第一个段走左、第二个段走右，那么也可以第一个段走右、第二个段走左，但不能第一个段和第二个段走左）。若两偶，存在情况使得无法同时离开一个段。

那么，该环合法当且仅当存在一个偶数段。需特判全环纯色的情况。

时间复杂度 $O(n)$。

---

## 作者：Fesdrer (赞：1)

不妨把红色看作 $0$，蓝色看作 $1$。则两个点合法当且仅当可以从两个点出发，每次经过值相同的边，最终在一个点上或边上相交。

首先有一个基本的判断，即如果存在两个点，一个点连出去的边全为 $0$，另一个点全为 $1$，则不合法。这意味着，我们可以统计 $0$ 和 $1$ 分别有多少个长度大于 $1$ 的连续段，如果 $0$ 和 $1$ 都有至少一个这样的连续段则不合法。

接下来，不妨认为当前只有 $1$ 有至少一个连续段。观察发现，如果有至少两个长度均为偶数的连续段，则不合法。这是因为对于一个在偶数连续段里的点必须要经过奇数或偶数个 $1$ 才能走出这个连续段。例如一个长度为 $4$ 的连续段 $\texttt{1111}$，对于第一个 $1$ 和第二个 $1$ 之间的那个点必须要经过奇数个 $1$ 才能走出这个连续段。因此我们可以在两个长度为偶数的不同连续段中分别选择一个点，一个要走奇数个 $1$，另一个要走偶数个 $1$，此时他们不合法。因此偶数连续段的数量至多为 $1$。

如果没有偶数连续段呢？我们令 $num$ 为长度**大于等于** $1$ 值为 $1$ 的连续段数量之和。容易发现 $num>0$，此时我们发现如果 $num>1$ 也不合法。例如 $\texttt{1010101110}$，如果我们选择其中两个连续段，每个连续段选择其最右边的那个点，那么这两个点每次移动时如果要经过 $0$，则分别到达一个连续段的左边，如果经过 $1$，则因为长度为奇数，所以必然穿过连续段，因此永远不可能相交。详见下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7vhexpgh.png)

而容易发现如果 $num=1$ 则有解。

以上讨论的时没有偶数连续段的情况。如果有一个偶数连续段则也是合法的。考虑上面提到的不合法情况，此时如果有一个偶数连续段那个两个点中的其中一个点就可以经过这个偶数连续段，而另一个点在原地移动，从而变成一个合法情况。例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ue3r8jv.png)

这样我们就通过分类讨论解决这道题了。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int T,n;
char s[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>(s+1);
		int cnt[2][2]={{0,0},{0,0}};
		for(int i=1;i<=n;i++)	s[i]=(s[i]=='R');
		if(s[1]==s[n]){
			int len1=0,len2=0;
			for(int i=1;i<=n&&s[i]==s[1];i++)	len1++;
			if(len1==n)	cnt[s[1]][n&1]++;
			else{
				for(int i=n;i>=1&&s[i]==s[n];i--)	len2++;
				cnt[s[1]][(len1+len2)&1]++;
				for(int i=len1+1;i<=n-len2;i++){
					int j=i;
					while(s[j+1]==s[i])	j++;
					if(j>i)	cnt[s[i]][(j-i+1)&1]++,i=j;
				}
			}
		}
		else{
			for(int i=1;i<=n;i++){
				int j=i;
				while(j<n&&s[j+1]==s[i])	j++;
				if(j>i)	cnt[s[i]][(j-i+1)&1]++,i=j;
			}
		}
		// cout<<cnt[0][0]<<" "<<cnt[0][1]<<" "<<cnt[1][0]<<" "<<cnt[1][1]<<endl;
		if(cnt[1][0]+cnt[1][1]>0&&cnt[0][0]+cnt[0][1]>0)	puts("NO");
		else if(cnt[1][0]+cnt[1][1]==0&&cnt[0][0]+cnt[0][1]==0)	puts("NO");
		else{
			int k=(cnt[1][0]+cnt[1][1]>0);
			for(int i=2;i<n;i++)	if(s[i]==k&&s[i-1]!=k&&s[i+1]!=k)	cnt[k][1]++;
			if(s[1]==k&&s[2]!=k&&s[n]!=k)	cnt[k][1]++;
			if(s[n]==k&&s[n-1]!=k&&s[1]!=k)	cnt[k][1]++;
			if(cnt[k][0]>=2)	puts("NO");
			else	if(cnt[k][0]==1||cnt[k][1]==1)	puts("YES");
			else	puts("NO");
		}
	}
	return 0;
}
```

---

## 作者：forest114514 (赞：0)

本来只想练练构造题，结果做完去看最后官方题解发现 bouns 还附带计数版本，这下更好玩了。

### Part 1 判断合法性

对于全一种颜色和形如 RRRRR……RRB 的串特判一下。

- 首先**考虑存在两个点相邻边是 RR 和 BB** 的情况一定是不合法的，因为选择这两点的话路径构成的串端点都不一样了。

剩下的所有情况只有一个颜色有 $>1$ 的连续段，为了方便不妨设为 R。

1. **存在两个 R 连续段的长度为偶数**

   此时可以分别在两个连续段中选两个点，使得其中一个到旁边两个 B 的长度均为偶、一个均为奇数，不难发现此时怎么走都会存在开始一段 R 长度是偶/奇数，结尾一段 R 长度是奇/偶数的情况，所以不可能构造出回文路径。

2. **所有 R 连续段长度均为奇数**

    此时任何一个点到旁边两个 B 的长度分别为一奇一偶，此时同样可以构造出两个点怎么走都会存在开始一段 R 长度是偶/奇数，结尾一段 R 长度是奇/偶数的情况。

3. **恰好一个 R 连续段长度为偶数**

   对于某个点在偶数段内，其他点在奇数段内的情况，显然一定可以的因为环上两个方向一定有一个开始和结尾的 R 长度同奇偶。

   其余两个点都在不同奇数段内，如果环上两个方向有一个开始和结尾的 R 长度同奇偶显然合法，考虑全奇数做不出来的情况，就是两个方向都是一奇一偶数的时候。我们可以先从起点走到偶数段然后再折回，这样 R 的段长度一定形如 **若干段奇数 R + 一段偶数 R + 若干段奇数 R** 或者 **一段偶数 R + 若干段奇数 R + 一段偶数 R + 若干段奇数 R + 一段偶数 R**，不难发现都能走出回文串。

所以考虑除去两个 corner case 之外，有解的充要条件是只有一种颜色存在 $>1$ 的连续段且恰好有一段长度为偶数，此时能容易做到 $O(n)$ 判断。

不过本题在 CF 上的题解出题人给了 3 个 bonus，分别是 字符集 $>2(|\Sigma|=26)$ 的情况的合法性判断和字符集 $=2,>2$ 的时候的合法串数量计数，作为一个喜欢思考的 OI 选手，我们还是思考一下怎么计数吧！

### Part 2 对合法序列计数

哎！构造题还能练计数，真是有趣，不过这里只写字符集 `R,B` 的做法 ~~（懒得再推了）~~。

首先 $n\leq 4$ 特判一下，特殊情况的方案数是容易的，然后都认为 R 是有 $>1$ 的连续段的那个，最后乘上 $2$ 即可。

首先我们观察发现一个有两段及以上 R 的环任意一个位置断开的链都是不同的，考虑 Burnside 引理，然后发现只有 $\gcd(i,n)=n$ 的那个置换群有合法方案，其他所有的重复若干次后要么没有偶数 R 段要么有 $>1$ 个偶数 R 段，所以一个本质不同的环被算到的时候其实就是 $n$ 种断开的情况再乘 $\frac{1}{n}$ 得到的，所以每一个链都恰好只有一个。

所以我们只用对合法的环计数，最后乘上 $n$ 即可。还是断环为链，我们钦定 **B+偶数个 R** 为代表元放开头，后面若干 **B+奇数个 R** 的序列接在后面，容易写出生成函数就是 $F(x)=\frac{x^3}{1-x^2}\times \operatorname{SEQ}{(\frac{x^2}{1-x^2})}=\frac{x^3}{1-2x^2}$，这个式子可以用**有理生成函数的展开定理**化成若干 $\frac{A}{1-Bx}$ 的和，然后就能 $O(\log n)$ 求 $[x^n]F(x)$ 了，注意 SEQ 的话是存在一个奇数段都不选的要特判一下，然后因为只是口胡所以可能有些细节和 corner cases 没考虑到，然后假如 $\sqrt 2$ 之类的数在题目模数下没有二次剩余的话记得写扩域。

对于字符集 $>2$ 的合法判断和计数就咕了……

---


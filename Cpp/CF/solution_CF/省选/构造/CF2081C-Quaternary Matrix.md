# Quaternary Matrix

## 题目描述

若矩阵中所有元素均为 $0$、$1$、$2$ 或 $3$，则称该矩阵为四元矩阵。

当四元矩阵 $A$ 满足以下两个性质时，Ecrade 称其为好矩阵：
1. 矩阵 $A$ 的每一行中所有数字的按位异或（bitwise XOR）结果等于 $0$。
2. 矩阵 $A$ 的每一列中所有数字的按位异或（bitwise XOR）结果等于 $0$。

Ecrade 有一个 $n \times m$ 的四元矩阵。他想知道将该矩阵变为好矩阵所需修改的最少元素数量，并希望得到其中一个可能的修改后矩阵。

由于问题有一定难度，请你帮助他！

## 说明/提示

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
3 3
313
121
313
3 3
000
000
000
4 4
0123
1230
2301
3012
4 4
1232
2110
3122
1311
4 4
1232
2110
3122
1312```

### 输出

```
3
213
101
312
0
000
000
000
0
0123
1230
2301
3012
6
0132
2310
3131
1313
5
0132
2310
3120
1302```

# 题解

## 作者：eEfiuys (赞：5)

### 题意

给定一个由 $0,1,2,3$ 组成的 $n \times m$ 矩阵，问最少修改多少个位置，使得每行、每列的异或和分别为零，并构造方案。

$n,m \leq 1000$

**Difficulty: \*2700**

### 题解

令 $r_i$ 表示第 $i$ 行的异或和，$c_j$ 表示第 $j$ 列的异或和，则一次修改，等价于任意选择 $(i,j,x)$，令 $r_i \leftarrow r_i \oplus x, \space c_j \leftarrow c_j \oplus x$。 

将行、列均视为点（点权分别为 $r,c$），每次操作视为在第 $i$ 行和第 $j$ 列之间连一条边权为 $x$ 的边，则，**一个点集 $V$ 可以不向外连边的充要条件** $p$ 为：

- 若 $V$ 中有点权非零的行/列，则 $V$ 中**至少存在一行一列**，其必要性是因为必须得操作。
- $V$ 中的**点权异或和为零**，其必要性是因为一次操作不改变所有点权的异或和（显然整个矩阵满足这个条件）。

而充分性是因为，对于这样一个点集 $V$，设其中有 $h$ 行 $w$ 列，可以构造如下方案：

- 选择一行 $x$ 和 $w-1$ 列 $y_1, \dots y_{w-1}$，分别操作 $(x,y_j,c_{y_j})$，让这些列的 $c$ 归零。
- 再用剩余的一列 $y_w$ 和所有行操作，使所有行归零。

显然，在这些操作之后，$c_{y_w}$ 也是零，因为其他点权都是零了，而所有点权异或和也是零，那么剩下的一个点也必然是零。

根据上述方案，我们又得到一个关键结论：在最优解中，**一个连通块必然是一棵树**，操作次数即为 $n+m$ **减去连通块个数**。

所以我们需要将图分成**尽可能多的连通块**。也就是说，我们需要将 $n$ 行 $m$ 列分成**尽可能多的组**，使得每一组均满足条件 $p$（如果某一组在最优方案中被划分成多个连通块，那这一组也可以被划分，这样组数就不是最多了，所以可以认为一组对应一个连通块）。

在下面的讨论中，我们不再考虑点权为零的点（或者说，把这些点一个分一组），并对组的划分做一个特殊处理：**允许剩余未分组的点，但是它们要消耗一次操作**。这是等价的，因为在实际构造时，可以把这些点放到任意一组中（显然，最优方案下，不会存在所有点都未分组的情况）。

接下来，我们探究一些性质。将大小为 $i$ 的组记为 $P_i$，将 $i$ 个未分组的点记为 $Q_i$。对于一个组，我们只关心其中 $r_i$ 的可重集 $R$ 和 $c_j$ 的可重集 $C$。**对于所有不满足以下某个性质的分组，均可以通过特定调整，使之满足所有性质，且组数不变少**：

1. **组的大小至多为 $4$**。
   > 证明：对于一个点数大于 $4$ 的点集，一定存在一个非空真子集满足异或和为零。所以，这个组要么可以被拆分成至少两个组，要么可以拆分出未分组的点。以下均不考虑可以进行这种拆分的组。
2. **$P_4$ 的构成为两个相同的 $r$ 和两个相同的 $c$**。
   > 与 1 类似。
3. **不存在 $r=c$ 均不属于 $P_2$**。
   > 证明：假设存在 $r=c$。$r$ 和 $c$ 不能都不参与分组，否则组数不是最多；如果在同一组，可以拆分使之满足；如果不在同一组或其中一个未分组，可以令 $r,c$ 成为一组，原先两组其他数成为一组。
4. **在所有不属于 $P_2$ 的点中，不存在 $r_1 \not= r_2 \not= c$（或 $r \not= c_1 \not= c_2$）均不属于 $P_3$（即属于 $P_4$）**。
   > 证明：假设存在 $r_1 \not= r_2 \not= c$。因为三个数分别为 $1,2,3$，有 $r_1 \oplus r_2 \oplus c =0$。由 3 得，所涉及的组中只有 $r_1,r_2,c$；又由 2 得，如果先调整为满足性质 2 再考虑此性质，则存在 $r_1,r_1,c,c$ 和 $r_2,r_2,c,c$，调整为两组 $r_1,r_2,c$ 和两个未分组的 $c$ 即可。

对于一种不满足以上某个性质的分组，我们进行该性质证明中的调整，如果仍有不满足的性质则继续，容易证明不会出现循环。所以，**我们在求最优解时，只考虑满足以上所有性质的分组方案即可**。

由 3 得，我们可以**先贪心地分 $P_2$**，即将值为 $1,2,3$ 的 $r,c$ 之间分别配对。此时，剩余的 $1,2,3$ 分别只有 $r$ 或 $c$，如果总共只有 $r$ 或 $c$ 则无法继续分组；否则，$P_3$ 只能是 $1,2,3$ 各一个，由 $4$ 得，可以**再贪心地分 $P_3$**。然后**再按照 2 分 $P_4$** 即可。

所以这题就是一个简单贪心啦~

实现上，存一下等于 $1,2,3$ 的 $r,c$ 分别有哪些行列，模拟即可。对于未分组的点，显然要么只有 $r$，要么只有 $c$，且异或和为 $0$，和同一行/列操作即可。

### Code Time！
```cpp
#include<bits/stdc++.h>
using namespace std;
// #define int long long
int aqx=1,byx=1,inf=0x3f3f3f3f;
const int mod=998244353;
const int N=1005;
int n,m,a[N][N],ans;
int r[N],c[N];
vector<int>pr[4],pc[4];
void solve(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        string s;cin>>s;
        for(int j=1;j<=m;j++)a[i][j]=s[j-1]-'0';
    }
    for(int i=1;i<=n;i++){
        r[i]=0;
        for(int j=1;j<=m;j++)r[i]^=a[i][j];
    }
    for(int i=1;i<=m;i++){
        c[i]=0;
        for(int j=1;j<=n;j++)c[i]^=a[j][i];
    }
    for(int i=0;i<=3;i++)pr[i].clear(),pc[i].clear();
    for(int i=1;i<=n;i++)pr[r[i]].push_back(i);
    for(int i=1;i<=m;i++)pc[c[i]].push_back(i);
    ans=0;
    for(int i=1;i<=3;i++)
        while(pr[i].size()&&pc[i].size())
            ans++,a[pr[i].back()][pc[i].back()]^=i,pr[i].pop_back(),pc[i].pop_back();
    for(int i=1;i<=3;i++)
        for(int j=i+1;j<=3;j++)
            while(pr[i].size()&&pr[j].size()&&pc[i^j].size()){
                ans+=2,a[pr[i].back()][pc[i^j].back()]^=i,a[pr[j].back()][pc[i^j].back()]^=j;
                pr[i].pop_back(),pr[j].pop_back(),pc[i^j].pop_back();
            }
    for(int i=1;i<=3;i++)
        for(int j=i+1;j<=3;j++)
            while(pc[i].size()&&pc[j].size()&&pr[i^j].size()){
                ans+=2,a[pr[i^j].back()][pc[i].back()]^=i,a[pr[i^j].back()][pc[j].back()]^=j;
                pc[i].pop_back(),pc[j].pop_back(),pr[i^j].pop_back();
            }
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            while(pr[i].size()>=2&&pc[j].size()>=2){
                ans++,a[pr[i].back()][pc[j].back()]^=i,pr[i].pop_back();
                ans++,a[pr[i].back()][pc[j].back()]^=(i^j),pc[j].pop_back();
                ans++,a[pr[i].back()][pc[j].back()]^=j,pr[i].pop_back(),pc[j].pop_back();
            }
    for(int i=1;i<=3;i++)while(pr[i].size())ans++,a[pr[i].back()][1]^=i,pr[i].pop_back();
    for(int i=1;i<=3;i++)while(pc[i].size())ans++,a[1][pc[i].back()]^=i,pc[i].pop_back();
    cout<<ans<<'\n';
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cout<<a[i][j];
            if(j==m)cout<<'\n';
        }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0);
    // freopen("data.in","r",stdin);
    // freopen("data.out","w",stdout);
    for(cin>>aqx;byx<=aqx;byx++)solve();
    return 0;
}
```

---


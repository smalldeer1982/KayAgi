# Conditional Operators

## 题目描述

在 C++ 中，条件运算符 `?:` 的使用规则为：表达式 `x?y:z` 的值为 $$$y$$$（若 $$$x$$$ 为真）或 $$$z$$$（若 $$$x$$$ 为假）。其中 $$$x$$$、$$$y$$$ 和 $$$z$$$ 可以是任意表达式。该运算符具有右结合性，即 `a?b:c?d:e` 等价于 `a?b:(c?d:e)`。数值 $$$0$$$ 表示假，$$$1$$$ 表示真。

给定一个长度为 $$$2n+1$$$ 的二进制字符串，请判断在插入 $$$n$$$ 个条件运算符后，该表达式能否计算结果为 $$$1$$$。允许使用括号。例如，字符串 `10101` 可被转换为 `(1?0:1)?0:1`，其计算结果为 $$$1$$$。

## 说明/提示

第一个测试用例对应题目描述中的示例。

第二个测试用例中，无论如何插入条件运算符，结果始终为 $$$0$$$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
2
10101
2
00000```

### 输出

```
Yes
(1?0:1)?(0):1
No```

# 题解

## 作者：江户川·萝卜 (赞：7)

吾虽~~年迈~~，箭矢犹锋！

大概花了一节自习课就在草稿纸上胡完了。

---

接下来会从我思考的方向来展开题解。

首先注意到串长 $2n+1$，提示我们从奇偶性入手。

并且由于操作是三目运算符，涉及到多元运算，不太适合直接构造。考虑由这些导出一些更加基础的操作。

比如，简单地观察后，就可以发现，若开头是 $0$，我们可以选择删除任意偶数长度的前缀。

那么如果是 $1$ 呢？

若开头是 $11$，那么我们操作 $1?1:\dots$  即可等于 $1$。

否则若是 $10\text{xx}$，经过一定细致地观察构造，可得 $(1?0:a)?b:\dots$，其中 $a,b$ 可以分别匹配上任意奇数长度的串。这样，我们删掉了长度 $>2$ 的偶数前缀。

这两个性质已经够好了。

我们发现能够删的都是偶数长度的，启发我们将串两两分组。分完组后最后还剩一个。这必定是特殊的，启发我们对最后一位分类讨论。

---

先来简单的，最后一位是 $1$。

套用上面两个操作，如果能删到只剩最后一位必定删，余下只剩 $1\text{x}1$ 的情况。手摸可知 $111$ 可行，$101$ 不行。

---

最后一位是 $0$ 怎么办？

直觉上，这种比较难构造，并且大概是通过以 $1$ 为条件的三目运算符达成的。

回归本质，考虑以 $1$ 为条件可达 $1$ 的大概长什么样。

最简单的，有 $11\dots$。

扩展一下，如果 $100\dots01\dots$ 呢？

一定的手模后发现，若后面的 $1$ 在偶数位，则有 $1?(0?[00\dots0]:1):\dots$。

若 $1$ 在奇数位，怎么做都不太行。本质上是奇偶性冲突。

同样的，如果是 $0100\dots1\dots$，这个第一个 $1$ 甚至没法派上用处。

这时需要大胆猜测！我们猜测前面存在奇数位是 $1$，其后存在偶数位是 $1$ 是串合法的充要条件。

上述猜测并非空穴来风，是大量手模以及对性质的观察得出的。

接下来进行证明。首先证明充分性，直接给出构造。

若 $s_0=0$，则套用先前操作删去前缀直至 $s'_0=1$。

接下来若 $s'_1=1$，则使用 $1?1:\dots$，否则使用 $1?(0?\dots:1):\dots$。构造完毕。

接下来证明必要性。反证，假设存在串不符合上述描述但是合法，设其中最短的串为 $S$。易知 $|S|> 3$。

易知 $S$ 的一个合法表达式，存在一个“最外层”三目运算符（即不被任何其他运算符包含或相交，并将其他运算包含），简化为 $A?B:C$。

根据奇偶性，可知 $C$ 均不满足上述“充要条件”，且 $|C|<|S|$。

则 $C=0$，那么 $A=1$。由于 $A$ 不满足“存在奇数位是 $1$，其后存在偶数位是 $1$ ”，则只有 $A$ 的最后一位是 $1$ 才可能有 $A=1$。

  从而 $S$ 中存在一个奇数位 $1$，即得 $B$ 中仅偶数位存在 $1$，所以 $B$ 不满足上述条件，又 $|B|<|S|$，所以 $B=0$，从而 $S$ 必等于 $0$。**矛盾**。

（由于上文作于深夜，不保证正确性，欢迎于评论区和私信勘误或者与我进一步讨论。）

[通过记录](https://codeforces.com/contest/2089/submission/312214334)。

---

## 作者：cyfff (赞：4)

这是我场上想到的做法，但因为一些原因没写。

首先理解题意，也就是说我们可以把相邻三个字符用三目运算符的方式合并。

我们从左往右考虑，维护当前的序列，每次往后面加入一个字符，若序列长度 $>4$ 就进行合并。将这一过程用状压动规计算。

这是有正确性的。因为关键的字符不会太多，剩下的字符都出现在三目运算中不会被取到的选项里。如果你不会证明，你可以开大保留的阈值。

---

## 作者：minstdfx (赞：1)

先把 $n<3$ 的情况搞出来。

首先不难观察到开头的一段偶数的 $0$ 没有用（`(0?(0?0:0?0:0):1)`）。接着不难观察到可以消掉第一个位于奇数位置上的 $1$ 前面的所有数（前述方法或它在第一个）。

然后不难观察到只要下一个 $1$ 在偶数位置上那么就结束了（`(等价于1)?(与开头构造相同):(.*)`）。

接着不难观察到如果从某个位置前面没有奇数的 $1$，从它开始所有的 $1$ 都在奇数位置上并且最后一个是 $1$，那么可以 `((等价于1)?0:x)?(.*):1` 类似物。

然后不难证明剩下的情况都似了。因为剩下的情况无非就是全在偶数上或者第一个奇数位置后面没有偶数位置而且最后一位是 $0$ 的 $1$ 了。前者考虑数学归纳法：第一段必然也是只有偶数位置，所以是 $0$，最后一段也必然只有偶数位置有 $1$，然后就是 `0?*:0`，必然是 $0$，~~一根筋变成两头堵了~~。后者我们讨论第一位，如果第一段只有偶数位置，那么就是 `0?x:y`，然后就只看最后一段，要么是单独一个 $0$，要么变成更短的同一情况（存在一个分界点前面没有奇数后面只有奇数并且最后 $0$）。如果第一段搞出一个 $1$，那么第二段就是纯偶数情况，那也寄了。

---

## 作者：xxgirlxx (赞：0)

从 [P12055](https://www.luogu.com.cn/problem/P12055) 来的。
## 题目思路
首先可以发现三目运算符最后结果想为 $1$，最后一步的结构一定是 `1?1:x` 或者 `0?x:1` 中的一个。

然后发现第一种情况的第一个 $1$ 可能是我们不需要考虑的，这是一种情况，第二种情况中的第一个 $0$ 和最后一个 $1$ 也可能是我们不需要考虑的，这又是两种情况。所以我们需要讨论三种情况。

在考虑情况之前我们先找一点性质：可以发现，`0?x:0` 的嵌套最终结果是最后一个数，我们可以考虑在最后一个数的位置放 $1$ 来将这一串化为一个 $1$，即将嵌套中的最后一个 `0?x:0` 换位 `0?x:1`。而且这个式子还有性质就是里面涉及到的重要的数字的所在位置的奇偶性是一致的。

然后我们考虑第一种情况，即如果该 01 串的第一个数是 $1$，那么我们就需要找到另一个 $1$，而且这个 $1$ 化出来后必须是第二个数，这个时候就可以用到上面的性质了：我们从第二个数开始一个个跳着（就是从 $x$ 跳到 $x+2$）往后找，直到找到一个 $1$ 为止。这样我们就弄出了 `1?1:x`，后面的不用管怎么算，只需要输出合法即可。

接下来我们考虑第二种情况，即如果该 01 串的最后一个数是 $1$，那么我们就需要使得第一个数是 $0$。这个时候我们需要结合上一种情况：如果该串的第一位是 $0$，那么直接就构成了 `0?x:1`，中间乱搞然后合法输出。否则该串一定进入上一种情况中进行一次判断，若该串的第二个位置是 $1$，那么该串会直接在上一种情况中输出解而不会到这种情况中。否则前三位可以构成 `1?0:x` 使得第一位变成 $0$，然后就构成了 `0?x:1`，中间乱搞然后合法输出。但是注意一下如果第一位是 $1$ 就需要判断长度，因为针对第一位是 $1$ 的情况，长度必须大于 $5$ 才行，因为需要做两次运算，如果不判断长度，就需要特判这个 hack：`101`。

最后我们来考虑第三种情况，即如果该 01 串的第一个数是 $0$，那么我们就需要使得最后一个数是 $1$。可以发现，使得最后一个数为 $1$，可以转化为在该串中取一个后缀，使得该后缀的最终值为 $1$，因此我们可以考虑将这部分用分成的三种情况中的一种情况的方法来做：但是用第三种情况等于无限嵌套，根本做不出来；第二种情况需要最后一个位置为 $1$，在这里被固定了，无法保证是通解；而第一种情况则是要求第一个数为 $1$，放到这里来就是可以选择的，我们可以通过选择合适的后缀的起点来使得第一位为 $1$，更适用且是通解，因为如果你连最后是个 $1$ 都弄不出来你整个也就做不了了。所以我们考虑将这部分转化为第一种情况，注意因为要化为 $1$ 所以后缀的长度一定是奇数，且需保证第一位为 $1$ 然后中间在偶数位上有 $1$ 就可以按第一种情况的方法做了。

注意多测。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
char a[3000010];
void solve(){
	cin>>n,n=n*2+1;
	for(int i=1;i<=n;i++)cin>>a[i];
	if(a[1]=='1'){
		int f=0;
		if(a[2]=='1'){
			cout<<"Yes\n1?1:";
			int num=0;
			for(int i=5;i<=n;i+=2)num++,cout<<"(";
			cout<<a[3];
			for(int i=5;i<=n;i+=2)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<"\n";
			return;
		}
		int num=0;
		for(int i=4;i<=n;i+=2){
			num++;
			if(a[i]=='1'){f=i;break;}
		}
		if(f!=0){
			cout<<"Yes\n1?";
			for(int i=1;i<=num;i++)cout<<"(";
			cout<<a[2];
			for(int i=4,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<":",num=0;
			for(int i=f+3;i<=n;i+=2)num++,cout<<"(";
			cout<<a[f+1];
			for(int i=f+3,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<"\n";
            return;
		}
	} 
	if(a[n]=='1'){
		if(n>=5||a[1]=='0'){
			if(a[1]=='0'){
				int num=0;
				cout<<"Yes\n0?";
				for(int i=4;i<=n;i+=2)num++,cout<<"(";
				cout<<a[2];
				for(int i=4,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
				cout<<":1\n";
			}
			else{
				int num=0;
				cout<<"Yes\n(1?0:"<<a[3]<<")?";
				for(int i=6;i<=n;i+=2)num++,cout<<"(";
				cout<<a[4];
				for(int i=6,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
				cout<<":1\n";
			}
			return;
		}
	}
	if(a[1]=='0'){
		int lst=0,f=0;
		for(int i=3;i<=n;i++){
			if(a[i]=='1'){
				if(i%2==1)lst=i;
				else if(lst!=0){f=i;break;}
			}
		}
		if(f!=0){
			int num=0;
			cout<<"Yes\n0?";
			for(int i=4;i<lst;i+=2)num++,cout<<"(";
			cout<<a[2];
			for(int i=4,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<":(1?",num=0;
			for(int i=lst+3;i<=f;i+=2)num++,cout<<"(";
			cout<<a[lst+1];
			for(int i=lst+3,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<":",num=0;
			for(int i=f+3;i<=n;i+=2)num++,cout<<"(";
			cout<<a[f+1];
			for(int i=f+3,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<")\n";
			return;
		}
	} 
	cout<<"No\n"; 
	return;
}
int main(){
	cin>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：wosile (赞：0)

Fun fact：这题在纸质题面上的标题为“标题请以 OJ 为准”。

首先我们可以发现，要让一个三目运算表达式的值为 $1$，这个表达式一定是 `0?x:1` 或者 `1?1:x`，其中 `x` 为任意值。我们尝试往这个方向构造。

通过对这两种构造的细致分讨我们可以发现，绝大部分结尾为 `1` 的串都可以构造使得其答案为 $1$，唯一的反例是 `101`。我们考虑如下分类讨论：

- 如果这个串的开头是 `0`，那么我们把第一个字符作为条件，最后一个字符作为不成立取值，答案即为 $1$。
- 如果这个串的开头是 `10`，那么我们把前三个字符作为条件，最后一个字符作为不成立取值，答案即为 $1$。注意这样做需要整个串的长度至少为 $5$，所以 `101` 这个串是无法构造的（也是唯一的反例）。
- 如果这个串的开头是 `11`，那么我们把第一个字符作为条件，第二个字符作为成立取值即可。

基于 `1?1:x` 的构造，我们还可以发现，假如我们有一个（从 $1$ 开始编号）奇数位置的 `1`，在其后有一个偶数位置上的 `1`（$s_{p_1}=s_{p_2}=1,p_1<p_2,p_1 \bmod 2 = 1, p_2\bmod 2 = 0$），那么我们可以把整个串划分为 $[1,p_1]$，$[p_1+1,p_2]$，$[p_2+1,2n+1]$ 三段，其中前两段都可以构造使得值为 $1$。为了避免出现 `101` 这种反例，我们可以选择尽量小的合法的 $p_1$ 和 $p_2$，容易证明这样前两段一定不会出现 `101`。

对于剩下的情况，所有的偶数位置上的 `1` 都在奇数位置上的 `1` 后面，且末尾不是 `1`。我们考虑归纳来证明这个串无论如何划分取值一定为 $0$。将整个串分为三段，根据归纳假设，第一段与第三段（条件和不成立取值）都一定为 $0$，所以整个串也为 $0$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char s[300005];
void anys(int l,int r){
    // 任意结果
    if(l==r){
        printf("%c",s[l]);
        return;
    }
    printf("(%c?%c:",s[l],s[l+1]);
    anys(l+2,r);
    printf(")");
}
void solve(int l,int r){
    // 末尾为 1 的构造
    assert(s[r]=='1');
    if(l==r){
        printf("%c",s[l]);
        return;
    }
    if(s[l]=='0'){
        printf("(%c?",s[l]);
        anys(l+1,r-1);
        printf(":%c)",s[r]);
    }
    else{
        assert(l+3<r);
        printf("((%c?%c:%c)?",s[l],s[l+1],s[l+2]);
        anys(l+3,r-1);
        printf(":%c)",s[r]);
    }
}
int main(){
    int Tc;
    scanf("%d",&Tc);
    while(Tc--){
        scanf("%d",&n);
        scanf("%s",s+1);
        n=n*2+1;
        if(n==3 && s[1]=='1' && s[2]=='0' && s[3]=='1'){
            printf("No\n");
            continue;// 特判 101
        }
        int p1=-1,p2=-1;
        for(int i=1;i<=n;i+=2)if(s[i]=='1'){
            p1=i;
            break;
        }
        for(int i=p1+1;i<=n;i+=2)if(s[i]=='1'){
            p2=i;
            break;
        }
        if(p1!=-1 && p2!=-1){
            assert(p1%2==1 && p2%2==0);
            printf("Yes\n");
            printf("(");
            solve(1,p1);
            printf("?");
            solve(p1+1,p2);
            printf(":");
            anys(p2+1,n);
            printf(")");
            printf("\n");
        }
        else if(s[n]=='1'){
            printf("Yes\n");
            solve(1,n);
            printf("\n");
        }
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：_lmh_ (赞：0)

首先用瞪眼法发现 `0?x:y` 相当于删去 `0` 和 `x`，`1?x:y` 相当于删去 `1` 和 `y`。

现在我们来处理一个序列。首先删去连续的 `00` 显然不劣，所以我们尽可能多地删，得到的序列不可能出现连续的两个 `0`（除了最后两个位置以外）。

现在已经没法一次操作删去两个 `0` 了，删去一个 `0` 一个 `1` 显然无法创造出新的可以删除的 `00`（需要分类讨论），而删除两个 `1` 最多把三个 `0` 的连续段拼在一起——可以证明最多只能删一次 `00`。

所以新的连续段如果 `1` 数量比 `0` 少就完蛋了，否则我们尝试在每消去一个 `1` 同时都消去一个 `0`。

对于后缀的 `0` 我们先不做处理，其余的 `0` 从前往后优先匹配右边那个 `1`，这样可以直接消除。

但是倒数第二个位置可能是 `0` 同时最后一个位置是 `1`，此时如果在前面就是 `1` 的话，存在一个后缀为 `1101`，消去第一个 `1` 和唯一一个 `0` 即可。

否则，我们回滚上一次操作，它可能是 `00101`，`10001`，`01101` 或 `10101`。注意此时如果没有上一次操作，那么原序列必定是 `101`，显然无解。

为它们构造方案（`X` 代表已被删除）：

`00101 0XX01 XXXX1`  
`10001 X0X01 XXXX1`  
`01101 0X1X1 XXXX1`  
`10101 X0X01 XXXX1`

然后剩下的是一个 `1` 的前缀和一个 `0` 的后缀，此时 `1` 的数量比 `0` 多所以前半部分和最中间的数一定都是 `1`，用左边的 `1` 消掉右边的数即可。

---

## 作者：MatrixGroup (赞：0)

## 题意

给定一个长度为 $2n+1$ 的 $\texttt{01}$ 串，试构造一个三目运算符表达式，依序出现的常量恰为这个字符串，或报告无解。

多测，$\sum n\le 1.5\times10^5$。

## 题解

这里复现一下 THUPC 考场思路。

首先，题意等价于不断把 $\texttt{1}ab\to a$ 而 $\texttt{0}ab\to b$，最终得到 $\texttt{1}$。

### 简单情况

考虑最后一步，要么是 $\texttt{11}x\to \texttt1$ 要么是 $\texttt{0}x\texttt{1}\to \texttt1$。由于 $x$ 是任意的，那么如果字符串以 $\texttt{11}$ 开头或者以 $\texttt{0}$ 开头且以 $\texttt{1}$ 结尾，那么剩下的随便合并，最后做一次即可。

### 以 $\texttt{1}$ 结尾

刚才说了两种简单情况，排除掉之后，如果还要以 $\texttt{1}$ 结尾，那么必须以 $\texttt{10}$ 开头。

首先，$\texttt{101}$ 做一次之后会变成 $\texttt{0}$，因此这时无解。否则，考虑到转化成已经解决的有解的情况。对前三个字符做一次，因为是 $\texttt{10}$ 开头，必然得到 $\texttt{0}$，然后就按照 $\texttt{0}$ 开头 $\texttt{1}$ 结尾的做即可。

### 以 $\texttt{1}$ 开头

刚才说的情况排除掉之后，剩下的部分以 $\texttt{10}$ 开头以 $\texttt{0}$ 结尾。这个时候缩开头看起来有点难受，考虑能不能保留 $\texttt{1}$ 而剩下凑出 $\texttt{1}$。通过一定手玩可以发现，如果有一个偶数位的 $\texttt{1}$，考虑找出第一个，即字符串形如 $\texttt{10}x\texttt{0}y\texttt{0}z\texttt{0}\cdots p\texttt{0}q\texttt{1}$，那因为 $\texttt{0}$ 的作用是取它后面两个的位置，那不断向前缩就可以得到 $\texttt{11}$ 开头，于是就做完了！

那如果没有偶数位置的 $\texttt{1}$ 呢？猜测无解，考虑证明。容易发现这样的字符串做完一次操作之后还是这样的字符串。具体地，若字符串形如 $\texttt{*0*0*0}\cdots\texttt{*00}$，其中 $\texttt{*}$ 是任意字符，那么缩 $\texttt{*0*}$ 得到的结果不知道，看做任意字符 $\texttt{*}$，缩 $\texttt{0*0}$ 得到的是 $\texttt{0}$，缩 $\texttt{*00}$ 也只能得到 $\texttt{0}$，因此这个字符串一定一直长成这样，那么最后只能得到 $\texttt{0}$，故无解。

### 其它情况

剩下的情况怎么办呢？考虑类比刚才的结论，我们知道在最后一位是 $\texttt{0}$ 的时候，偶数位全是 $\texttt{0}$ 是无解的。类似的，奇数位全是 $\texttt{0}$ 也是无解的。但手玩可以发现偶数位和奇数位都有 $\texttt{1}$ 有时也无解，比如 $\texttt{01100}$。

那还是来考虑先直接构造一些有解的情况吧。刚才说过 $\texttt{0*0*0*}\cdots\texttt{0*1}$ 可以缩成 $\texttt{1}$，刚才对 $\texttt{11}$ 开头的第二个 $\texttt{1}$ 反向做了这个事情，那第一个 $\texttt{1}$ 也可以！因此，如果存在一个奇数位置的 $\texttt1$ 在偶数位置的 $\texttt1$ 前面，则找到第一个奇数位置的 $\texttt1$ 后面的第一个偶数位置的 $\texttt1$ 缩掉即可！

  否则，经过手玩可以猜测它无解。考虑证明。存在一个奇数位置的 $\texttt1$ 在偶数位置的 $\texttt1$ 前面，反过来就是所有奇数 $\texttt{1}$ 都在偶数 $\texttt1$ 后面，也就是存在一个分界线，前面的奇数位都是 $\texttt{0}$，后面的偶数位都是 $\texttt0$。再加上我们排除了结尾是 $\texttt{1}$ 的情况，字符串一定形如 $\texttt{0*0*}\cdots\texttt{0*0**0*0*}\cdots\texttt{0*00}$。根据类似的论证，这个字符串一定保持这种形态，直到 $\texttt{**}$ 和 $\texttt{00}$ 碰到一起（当然也可能没有 $\texttt{**}$ 和 $\texttt{00}$，也就是奇位全 $\texttt0$ 或偶位全 $\texttt0$，这种情况讨论过了），即 $\texttt{0*0*}\cdots\texttt{0*0**00}$，此时对 $\texttt{**0}$ 或者 $\texttt{*00}$ 操作，就会得到 $\texttt{0*0*}\cdots\texttt{0*0*0}$，这种情况刚才讨论过是无解的。综上，这种情况无解。

### 总结

把刚才说的实现一下即可，注意一部分讨论可以合并。

把缩字符串变成三目运算符可以考虑记录每个字符的来源，最后递归输出。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,del##i##verme=int(n);i<del##i##verme;++i)
#define pb push_back
using namespace std;
int n,cnt;
string s;
int x[1145141],y[1145141],z[1145141],val[1145141];
int f(int a,int b,int c)
{
	int ret=++cnt;
	x[ret]=a;y[ret]=b;z[ret]=c;val[ret]=val[a]?val[b]:val[c];
	return ret;
}
vector<int> vc;
void write(int id)
{
	if(id<=1){cout<<id;return ;}
	cout<<'(';write(x[id]);cout<<'?';write(y[id]);cout<<':';write(z[id]);cout<<')';
}
int construct()
{
	if(vc[0]==1&&vc[1]==1)
	{
		int cur=vc[2];
		for(int i=3;i<int(s.size());++++i) cur=f(cur,vc[i],vc[i+1]);
		cur=f(vc[0],vc[1],cur);
		return cur;
	}
	if(vc[0]==0&&vc.back()==1)
	{
		int cur=vc[1];
		for(int i=3;i<int(s.size());++++i) cur=f(cur,vc[i-1],vc[i]);
		cur=f(vc[0],cur,vc.back());
		return cur;
	}
	if(vc.back()==1)
	{
		if(n==1) return -1;
		int cur=vc[3];
		for(int i=5;i<int(s.size());++++i) cur=f(cur,vc[i-1],vc[i]);
		int bg=f(vc[0],vc[1],vc[2]);cur=f(bg,cur,vc.back());
		return cur;
	}
	int pos=0;while(pos<int(s.size())&&vc[pos]==0) ++++pos;
	if(pos>=int(s.size())) return -1;
	int pos2=pos+1;while(pos2<int(s.size())&&vc[pos2]==0) ++++pos2;
	if(pos2>=int(s.size())) return -1;
	int bg=vc[pos];for(int i=pos-2;i>=0;----i) bg=f(vc[i],vc[i+1],bg);
	int md=vc[pos2];for(int i=pos2-2;i>=pos+1;----i) md=f(vc[i],vc[i+1],md);
	int ed=vc[pos2+1];for(int i=pos2+2;i<int(s.size());++++i) ed=f(ed,vc[i],vc[i+1]);
	int cur=f(bg,md,ed);
	return cur;
}
int t;
void solve()
{
	vc.clear();cnt=1;
	cin>>n>>s;rep(i,2*n+1) vc.pb(s[i]&1);
	int result=construct();
	if(result==-1){cout<<"No\n";return ;}
	cout<<"Yes\n";write(result);cout<<'\n';
}
int main()
{
	ios_base::sync_with_stdio(false);cin.tie(0);
	t=1;
	cin>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：HNOIRPplusplus (赞：0)

手玩容易发现一些很显然的构造方案，但是很担心这些东西并不全。不过好消息是过了。

我们找出这个字符串第一个奇数位置的 `1` 和其后第一个偶数位置的 `1`，假设存在这两个位置。则，第一个奇数位置前全部用问号和冒号交替进行，如 `(0?1:0?0:0?0:1)`，这个表达式的值是 `1`。同理，因为前面已经用掉了奇数个数字，“其后第一个偶数位置的 `1`”就变成奇数位置的了，于是我们又可以重复一次，最后该表达式便会变成 `(1)?(1):(x)`。

我们同时可以证明，如果一个表达式只有偶数位置有 `1`，它便最终不能得到 `1`。因为该表达式最终必须转换成 `(x)?(y):(z)` 的形式，而 `x` 和 `z` 同样是只有偶数位置有 `1` 的表达式，同样不能得到 `1` 的结果，最终只能变成 `(0)?(y):(0)`。  
注意这个不是递归论证，因为 `x` 和 `z` 最短是 `0`。

考虑如果前面说的两个位置不存在怎么办。也就是说，这个字符串的前面一部分只有偶数位置有 `1`（可能没有），后面一部分只有奇数部分有 `1`。则我们不可能再构造出 `(1)?(1):(x)` 的式子了，只能构造 `(0)?(x):(1)` 的式子。最后一个 `1` 是好解决的，只要最后一个数字是 `1` 就行了；否则，同样如上，`(x)?(y):(z)` 的 `z` 也是一个最后为 `0` 且满足前偶后奇的字符串，它最短也是 `0`，然后就炸了。

于是，我们可以构造形如 `0?(x):1` 或者 `(1?0:(x)):(y):1` 的式子，然后可以发现在前偶后奇的限制条件下没有别的可能了。

---


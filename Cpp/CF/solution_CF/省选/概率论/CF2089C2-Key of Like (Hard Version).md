# Key of Like (Hard Version)

## 题目描述

这是该问题的困难版本。两个版本之间的区别在于，在这个版本中 $$$k$$$ 可以是非零值。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此策略永远是选择任何未被尝试过的钥匙。由于总共有 $$$1 + 4 = 5$$$ 把钥匙，每位成员成功打开锁的概率（即期望成功次数）分别为 $$$2/5$$$、$$$2/5$$$、$$$1/5$$$。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 4
3 2 0
25 2 5
4 102 9```

### 输出

```
800000006 800000006 400000003
500000004 1 500000004
142857144 166666668 615646263 639455787 234126986 257936510 195918369 502040820 478316330 81264173 190523433 471438023 23809524 0 0 0 0 0 0 0 0 0 0 0 0
568832210 85779764 969938175 375449967```

# 题解

## 作者：UniGravity (赞：2)

记当前有 $a$ 个锁，$a+b$ 个钥匙。

考虑第一个人。每对钥匙和锁的配对成功概率都是 $\frac1{a+b}$。不妨假设第一个人选了第一个锁和钥匙。

接下来考虑第一个人没选中轮到第二个人，有三种可能：

* 选择第一个锁和任意编号不为一的钥匙。发现相当于配对的钥匙去掉选过的可能有 $a+b-1$ 种选择，成功概率为 $\frac1{a+b-1}$。
* 选择第一个钥匙和任意编号不为一的锁。这里还需要考虑是假钥匙的概率可能因为之前不匹配而发生变化。一种理解方式是加入 $b$ 个假锁与假钥匙配对，发现概率相当于仍然是 $\frac1{a+b-1}$。严谨的通过贝叶斯定理的证明可以看 [CF 上的题解](https://codeforces.com/blog/entry/141053)。
* 钥匙和锁都不选第一个。此时相当于对于某个锁仍然有 $a+b$ 个钥匙可能与其匹配，排除掉与第一个钥匙匹配的结果，成功的概率为 $(1-\frac1{a+b-1})\frac1{a+b-1}=\frac{a+b-2}{(a+b-1)^2}<\frac1{a+b-1}$，必定更劣。

因此我们发现实际上第二个人绝对会选择第一个锁或钥匙（分别简记为选锁和钥匙）然后任意选择其它的配对。由于每个人会等概率选取所有成功概率相同的操作，并且选钥匙则有 $a-1$ 个锁配对，选锁则有 $a+b-1$ 个钥匙配对。所以选钥匙和锁的概率分别为 $\frac{a-1}{2a+b-2}$ 和 $\frac{a+b-1}{2a+b-2}$ 种方案。

轮到第二个人且选中的概率是 $\frac{a+b-1}{a+b}\cdot\frac1{a+b-1}=\frac1{a+b}$，和第一个人相同。

考虑第三个人，还是三种情况。例如如果还是第一个锁与其它钥匙配对，则概率为 $\frac1{a+b-2}$，并且可以证明这个方案是唯一最大的。感性理解可以认为其利用了最多的信息。第一个钥匙和锁配对同理。因此轮到第三个人且选中的概率同样是 $\frac1{a+b}$。

于是发现从第二个人之后，每个人都会重复和上个人一样的操作。考虑到某个人成功配对了，我们将配对的钥匙和锁去掉后发现没有任何关于剩下的东西的信息，即之前的操作不会干扰后续的概率！因此我们就把问题转化为 $a\gets a-1$，$b$ 不变的情况。

另一种情况是第二个人选了钥匙后到第 $a$ 个人仍然没有配对成功，那么说明是假钥匙。只将这个钥匙去掉，前后仍然没有影响，因此转移到 $a$ 不变，$b\gets b-1$ 的子问题。注意的是转化后的问题人的编号会发生循环移位。

接下来就可以 dp 了：记 $f_{a,b,i}$ 表示 $a$ 个锁，$a+b$ 个钥匙，第 $i$ 个人期望成功多少次。

一种情况是从 $f_{a-1,b,i-j}$（$i-j$ 是在模 $n$ 意义下的）转移过来，选钥匙则 $j$ 的上界为 $a$，否则为 $a+b$。转移的概率为 $\frac1{a+b}$ 乘上第二个人选钥匙或锁的概率。可以前缀和优化转移。

另一种情况只在选钥匙时生效，即 $\frac b{a+b}$ 的概率转移到 $f_{a,b-1,i-a}$。

同时还要加上恰好在 $i$ 人上完成配对的概率，为 $\frac{\sum_{c=0}^{a-1}[i==c]}{a+b}$，容易 $O(1)$ 计算。

因此我们发现 dp 可以做到 $O(nlk)$，可以通过此题。

```cpp
const int P=1000000007;
int inv[20005];
il void init(int n){
    inv[1]=1;forto(i,2,n)inv[i]=1ll*(P-P/i)*inv[P%i]%P;
}
int n,l,k,f[5005][30][105];
il void addto(int &x,int y){x+=y;if(x>=P)x-=P;}
il void delto(int &x,int y){x-=y;if(x<0)x+=P;}
il void work(){
    n=read(),l=read(),k=read();
    int cnt,s1,s2;ll v1,v2;
    forto(a,1,l)forto(b,0,k){
        s1=s2=0;
        forv(i,n)addto(s1,1ll*(a/n+(i>=n-a%n))*f[a-1][b][i]%P),addto(s2,1ll*((a+b)/n+(i>=n-(a+b)%n))*f[a-1][b][i]%P);
        v1=1ll*(a-1)*inv[2*a+b-2]%P*inv[a+b]%P,v2=1ll*(a+b-1)*inv[2*a+b-2]%P*inv[a+b]%P;
        if(a==1&&b==0)v1=inv[a+b],v2=0;
        forv(i,n){
            addto(f[a][b][i],v1*s1%P),addto(f[a][b][i],v2*s2%P);
            addto(f[a][b][i],v1*(a/n+(i<a%n))%P),addto(f[a][b][i],v2*((a+b)/n+(i<(a+b)%n))%P);
            if(b)addto(f[a][b][i],v1*b%P*f[a][b-1][(i-a%n+n)%n]%P);
            addto(s1,f[a-1][b][i]),delto(s1,f[a-1][b][(i-a%n+n)%n]);
            addto(s2,f[a-1][b][i]),delto(s2,f[a-1][b][(i-(a+b)%n+n)%n]);
        }
    }
    forv(i,n)printf("%d ",f[l][k][i]);puts("");
    forto(a,0,l)forto(b,0,k)forv(i,n)f[a][b][i]=0;
}

signed main(){
    init(20000);
    int t=read();while(t--)work();
    return 0;
}
```

---

## 作者：MatrixGroup (赞：0)

## 题意简述

共有 $L+K$ 把钥匙，其中有 $L$ 把钥匙，每把对应一个锁，可以打开它；剩下 $K$ 把钥匙哪个锁都打开不了。有 $N$ 个人，$1\sim N$ 轮流循环尝试开锁，在所有最大化当前这次成功概率的情况中（当然，不能开成功开过的锁）等概率选择一个方案开，问开完所有 $L$ 个锁时每个人成功开锁次数的期望。对 $10^9+7$ 取模。

(THUPC ver.) $N\le 50, L\le 5\,000,K\le 50$。

(Codeforces ver.) 多测，$N\le 100, \sum L\le 5\,000,K\le 25$。

## 题解

先考虑刻画策略。第一个人当然是随便选。如果第一个人猜对了那问题就转化成了 $L$ 减掉 $1$ 的问题，否则第二个人当然应该要么选第一个人选了的钥匙，要么选第一个人选了的锁——因为它们各自排除了一个选项，当然比没有排除的好。当然这是直觉，我们来计算一下。设 $p_1,p_2,\cdots,p_L$ 为对应钥匙的编号。假如第一个人通过用 $b$ 开 $a$ 确定了 $p_a\neq b$，设 $c\neq a,d\neq b$。那么计算：

- $p_a\neq b,p_c\neq d$ 的概率是 $\dfrac{(L+K-1)(L+K-1)-(L+K-2)}{(L+K)(L+K-1)}$
- $p_a\neq b,p_c\neq b$ 的概率是 $\dfrac{(L+K-1)(L+K-2)}{(L+K)(L+K-1)}=\dfrac{L+K-2}{L+K}$
- $p_a\neq b,p_a\neq d$ 的概率是 $\dfrac{L+K-2}{L+K}$

注意以上算的都不是条件概率，反正条件概率就是除以 $p_a\neq b$ 的概率，大小关系还是不变的。总之第一个概率更高，后两者是一样的。而因为要让猜对的概率更高，猜错的概率就要更低。因此第二个人的策略就是后两者中随机，也就是在 $L+K-1$ 个 $d$ 和 $L-1$ 个 $c$ 里随便选。

接下来无论是直觉上说还是通过类似的论证可以说明，如果第二个人顺着第一个人选了相同的 $a$，那么接下来会一直选择猜相同的 $a$，直到猜对。如果第二个人顺着第一个人选了相同的 $b$，那么接下来会一直选择猜相同的 $b$，直到猜对或者发现没有这个 $b$。接下来就可以规约到一个更小的问题。当然不妨把第一次就猜对也拆成这样的两种，方便计算。

这样的子结构启发使用 dp 求解。设 $dp_{\ell,k,c}$ 表示 $L=\ell,K=k$ 时第 $j$ 个人的答案，那么因为不断猜一个数，第 $i$ 个人猜对的概率都是相同的 $\dfrac{1}{\ell+k}$，因此转移就是要么是边界的没有 $b$，要么要查询模意义下的区间和。前缀和优化转移，时间复杂度 $O(NLK)$。

## 代码

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod2=1000000007;
int t,n,l,k;
ll dp[5005][52][102];
ll s[5005][52][102];
ll f(int L,int K,int N){return (N/n*s[L][K][n]+s[L][K][N%n])%mod2;}
ll f(int L,int K,int a,int b){return (f(L,K,b+100000*n)-f(L,K,a+100000*n-1)+mod2)%mod2;}
ll qkpw(ll a,ll b){ll r=1;while(b){if(b&1)r=r*a%mod2;a=a*a%mod2;b>>=1;}return r;}
ll inv(ll x){return qkpw((x%mod2+mod2)%mod2,mod2-2);}
void Q()
{
	cin>>n>>l>>k;
	for(int L=1;L<=l;++L) for(int K=0;K<=k;++K)
	{
		ll p1=inv(2*L+K-2)*(L+K-1)%mod2,p2=(mod2+1-p1)%mod2,q=inv(L+K);p1=p1*q%mod2;p2=p2*q%mod2;
		for(int i=1;i<=n;++i)
		{
			ll cur=((L+K-i+n)/n*p1+(L-i+n)/n*p2);if(K)cur+=K*p2%mod2*dp[L][K-1][((i-L-1+L*n)%n+1)];
			cur+=f(L-1,K,i-L-K,i-1)*p1+f(L-1,K,i-L,i-1)*p2;
			s[L][K][i]=(s[L][K][i-1]+(dp[L][K][i]=cur%mod2))%mod2; 
		}
	}
    for(int i=1;i<=n;++i) cout<<dp[l][k][i]<<" \n"[i==n];
}
int main()
{
	cin>>t;while(t--)Q();return 0; 
}
```

---

## 作者：spdarkle (赞：0)

# CF2089C2

首先我们考虑没有假牌的情况，即 C1。

注意到每个人会选择当前对自己最优的决策，那么必然最开始一个人选择了一对钥匙箱子之后，如果他没有打开，那么下一个人只会执行两个决策：

1. 换个箱子，保留原本的钥匙
2. 换个钥匙，保留原本的箱子

而我们注意到箱子与钥匙一一对应，那么地位等价，说明这两个决策的地位是等价的。

不妨假设换了个箱子，那么后面的人就会一直尝试这个钥匙，直到找到其所配对的箱子。

那么这个过程就简单了：即不断地尝试同一把钥匙直到找到其所配对的箱子。

这启发我们考虑数组 $(c_1,c_2,c_3\dots c_l)$，分别表示表示第 $1,2,3\dots l$ 把钥匙匹配成功时所用掉的匹配次数。

出现这种情况的概率是：
$$
\frac{l-1}{l}\frac{l-2}{l-1}\dots \frac{1}{l-c_1+1}\frac{l-2}{l-1}\dots \frac{1}{l-c_2}\frac{l-3}{l-2}\dots \frac{1}{l-c_l}=\frac{1}{l!}
$$
也即概率均等。

那么设 $dp_{i,j}$ 表示已经刚好匹配了 $i$ 个箱子，最后是第 $j$ 个人匹配成功的。

枚举 $c_i$，有 $dp_{i,j}=\sum_{t=1} ^{l-i+1} dp_{i-1,j-t}$。

注意到第二维是循环的，所以把循环拆成整段散段，然后前缀和优化可以做到 $O(nl)$。

------

考虑有假钥匙的情况。

为了方便叙述，我们下面默认人从 $0$ 开始编号。

考虑第一个人，他有 $\frac{1}{l+k}$ 的概率直接匹配到（任选一个箱子，然后恰好选到它的钥匙）

如果没有，那么他有三个决策：

1. 换把钥匙
2. 换个箱子
3. 两个都换

显然 $3.$ 是不优的，我们考虑 $1,2$ 的概率。

首先 $1.$ 的成功概率显然是 $\frac{1}{l+k-1}$，考虑求 $2.$ 的成功概率。

事实上它也是 $\frac{1}{l+k-1}$。

证明：

>设事件 $A$ 为第一个人拿到的钥匙是真的，设事件 $B$ 为第一个人失败，设事件 $C$ 为第二个成功。
>
>目标：$P(C|B)$
>$$
>P(A|B)=\frac{P(B|A)P(A)}{P(B)}=\frac{\frac{l}{l+k}\frac{l-1}{l}}{\frac{l+k-1}{l+k}}=\frac{l-1}{l+k-1}
>$$
>
>$$
>P(C|B)=P(A|B)P(C|AB)+P(\overline A|B)P(C|\overline AB)=\frac{l-1}{l+k-1}\frac{1}{l-1}+0=\frac{1}{l+k-1}
>$$
>
>

因此这两类决策的成功概率均为 $\frac{1}{l+k-1}$，因此第二人：

1. 有 $\frac{l+k-1}{2l+k-2}$ 的可能性换钥匙
2. 有 $\frac{l-1}{2l+k-2}$ 的可能性换箱子

而如果拿到假钥匙，则换箱子的决策最终会寄掉（也就是识别出这是个假钥匙）

到这里就可以设计 dp 了。

设计时需要注意保证 $O(nlk)$ 的复杂度，但是我们需要求出每个位置的答案。

仿照 C1 的做法，一个局面我们需要记录的信息有三个：未配对/已配对箱子数，未识别/已识别假钥匙数，当前的操作者/最后一个操作的人，因此状态不低于 $O(nlk)$。

再考虑到整个操作过程中需要求出每个人的期望，但只有对同一个人答案期望的 dp 可以合并。

这启发我们设计 $dp_{l,k,m,x}$ 表示当前局面 $(l,k,m)$（箱子，假牌，操作者，此时人 $x$ 的期望答案）

复杂度不低于 $O(n^2lk)$，无法接受。

考虑到对于每个 $x$，其 dp 过程高度相似，因此启发我们思考 **通过相对关系求解答案**，也即是将 $x,m$ 关联起来。

不妨倒推，设 $dp_{l,k,m}$ 为当前是有 $l$ 个箱子，$k$ 张假牌的初始局面，钦定开始操作者为 $m$，则 $0$ 的期望开箱次数。将操作过程倒置，$m\to m-1\to m-2\dots$，这样最终的 $dp_{L,K,m}$ 相当于从 $m\to 0$，倒置回来相当于原问题 $0\to m$。

令 $dp'_{l,k,m}=dp_{l,k,m}+[m=n-1]$

考虑转移：

1. 第一个人直接赢：$dp_{l,k,m}\leftarrow dp'_{l-1,k,m-1\bmod n}\frac{1}{l+k}$

2. 第二个人选择换钥匙：$\frac{l+k-1}{l+k}\frac{1}{2l+k-2}\sum_{i=2}^{l+k}dp'_{l-1,k,m-i\bmod n}$

   注意这里是 $\frac{1}{2l+k-2}$

3. 第二个人选择换箱子：

   $\frac{1}{l+k}\frac{1}{2l+k-1}\left(\sum_{i=2}^{l}(l-1)dp'_{l-1,k,m-i\bmod n}+k·dp_{l,k-1,m-l\bmod n}\right)$

   解释一下，对于真钥匙，概率是 $\frac{l-1}{l+k}$，因为没有打开第一个箱子，且为真的钥匙只有 $l-1$ 把，而假钥匙有 $k$ 把。

注意到 $2.,3.$ 可以将 $i$ 改为从 $1$ 开始，整合，因此总的有：
$$
dp_{l,k,m}=\frac{1}{(2l+k-1)(l+k)}\left((l+k-1)\sum_{i=1}^{l+k}dp'_{l-1,k,m-i\bmod n}+\sum_{i=1}^l(l-1)dp'_{l-1,k,m-i\bmod n}+k·dp_{l,k-1,m-l\bmod n}\right)
$$
注意 $l=1,k=0$ 的转移需要特判。

---


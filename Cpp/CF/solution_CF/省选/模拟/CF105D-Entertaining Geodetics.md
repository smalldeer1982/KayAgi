# Entertaining Geodetics

## 题目描述

游戏中的地图被划分为称为 Geo Panels 的方格单元。其中一些单元被涂上了颜色。我们假设没有颜色的 Geo Panels 被涂成透明色。

此外，地图上还有所谓的 Geo Symbols。它们看起来像不同颜色的金字塔（包括透明色的 Geo Symbols）。每个 Geo Symbol 位于一个 Geo Panel 上，每个 Geo Panel 最多只能包含一个 Geo Symbol。

Geo Symbol 可以被消除。为了更好地理解消除 Geo Symbol 时会发生什么，我们引入一个队列，用于存放最近被消除的 Geo Symbol。

我们将刚刚被消除的 Geo Symbol 放在队列的头部。接下来，我们重复以下操作：

从队列中取出一个 Geo Symbol。查看该 Geo Symbol 所在面板的颜色。如果该颜色既不是透明色，也不同于 Geo Symbol 的颜色，则将所有该颜色的 Geo Panels 重新涂成该 Geo Symbol 的颜色（透明色的 Geo Symbol 会将 Geo Panels 涂成透明色）。重新涂色的顺序严格按照如下无限螺旋顺序，从包含该 Geo Symbol 的面板开始：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF105D/430d2dc39e8c5cda16cf52fdf0302368ccd24c75.png)

换句话说，我们选出所有需要被重新涂色的面板，并找到它们在以该 Geo Symbol 位置为中心的无限螺旋中的编号。之后，按照编号递增的顺序依次重新涂色。

如果某个面板上有另一个 Geo Symbol，并且该面板正在被重新涂色，则该 Geo Symbol 会从地图上移除，并被放到队列的尾部。

重新涂色后，该 Geo Symbol 被彻底消除，然后从队列头部取下一个 Geo Symbol（如果有的话），重复上述过程。若队列为空，则过程结束。

请参考样例分析以便更好地理解。

你已知所有 Geo Panels 的颜色和所有 Geo Symbols 的位置。请你计算，如果消除某个 Geo Symbol，总共会发生多少次重新涂色操作。

## 说明/提示

你可以在下图中看到样例的所有操作过程：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF105D/45edbaa93b41bf71ed92bf8c850ca560634e9031.png)

如果你的浏览器不支持 APNG，只显示静态图片，你可以通过以下链接查看 GIF 版本的动画效果：http://assets.codeforces.com/images/geo\_slow.gif

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5 5
9 0 1 1 0
0 0 3 2 0
1 1 1 3 0
1 1 1 3 0
0 1 2 0 3
-1 1 -1 3 -1
-1 -1 -1 0 -1
-1 -1 -1 -1 -1
-1 2 3 -1 -1
-1 -1 -1 -1 2
4 2
```

### 输出

```
35```

# 题解

## 作者：Twig_K (赞：4)

做的时候主要障碍在读题，不知道现在的翻译是不是机翻……注意区分格子的颜色和物品的颜色。

## 题意

给定一个 $n$ 行 $m$ 列的网格图。开始时，一些格子有特定的颜色，其余格子为无色。其中一些格子有物品，物品有些有特定的颜色，也可能是无色。

给定染色的起始点 $(sx,sy)$（保证 $(sx,sy)$ 有物品），起初先把物品 $(sx,sy)$ 拿走放入队列。

下面将描述题目中的染色过程：

- 每次取出队首物品 $(x,y)$，观察**此刻** $(x,y)$ 位置（物品原来放置的位置）的颜色 $c$ 。
- 如果 $c$ **不是无色** 且不同于**物品的**颜色，那么，以当前格子为起点，按照**一定优先级**（具体见原题图中的优先级标号）遍历**所有此刻颜色为 $c$ 的**格子。
- 遍历到某一个格子时，把它染成物品的颜色。如果物品无色就染成无色。
- 同时，如果这个格子上有物品，将这个物品拿走，加入队列末尾（每种物品拿走就没了，只能入队一次）。
- 重复上述操作，直到队列为空。

你需要求出，整个过程中，所有格子被染色次数之和。

## 题解

我们用并查集维护染色的过程，除了并查集的父亲数组外，在并查集每个连通块的根节点额外保存一个信息，记录这个连通块现在的颜色是什么。

输入时每个颜色都是孤立点，每次只需要合并连通块，并修改合并后根节点的颜色信息。

注意到物品只会被收集一次，而且物品被收集的时候，对应的格子一定是第一次被染色。所以我们可以对每种**地图初始颜色 $k$** 开一个 vector，对于所有初始颜色为 $k$ 的格子，如果上面有物品，把它塞进 $k$ 的 vector 里就可以了。

其他部分就是根据题意模拟，开一个存物品的队列，每次取出物品，如果不能染色就跳过，否则把原来的颜色合并成物品的颜色。

然后去看**原来颜色**的 vector，把里面所有物品按照**特定优先级**排序之后塞入队列。最后清空原队列。

## Tips

颜色要离散化。

写代码的时候一定要注意是物品的颜色还是地图的颜色。

对于**特定优先级**，我的做法是预处理一个二位数组，处理出优先级编号，然后直接给 vector 按照这个编号排序。

每个物品只会入队一次，复杂度是对的。

## 代码

[CF 提交记录](https://codeforces.com/contest/105/submission/299229739)

---


# The minimal unique substring

## 题目描述

给定一个只包含符号“0”或“1”的字符串 $s$。如果存在某个 $1 \leq l \leq |s| - |t| + 1$，使得 $t = s_l s_{l+1} \ldots s_{l + |t| - 1}$，则称字符串 $t$ 是字符串 $s$ 的一个子串。如果 $t$ 作为 $s$ 的子串仅在唯一的位置出现（即只有一个合适的 $l$），则称 $t$ 是 $s$ 的一个“唯一子串”。

例如，设 $s = $ "1010111"。字符串 $t = $ "010" 是 $s$ 的唯一子串，因为只有 $l = 2$ 满足条件。而 $t = $ "10" 不是唯一子串，因为 $l = 1$ 和 $l = 3$ 都满足条件。又如 $t = $ "00" 根本不是 $s$ 的子串，因为没有合适的 $l$。

现在，Vasya 在信息学课上遇到了这样一个问题：给定一个只包含“0”和“1”的字符串，要求找出其最短唯一子串的长度。他已经写好了这个问题的解法，并想要测试它。现在他请求你帮忙。

给定两个正整数 $n$ 和 $k$，满足 $(n \bmod 2) = (k \bmod 2)$，其中 $(x \bmod 2)$ 表示 $x$ 除以 $2$ 的余数。请你构造一个长度为 $n$ 的只包含“0”和“1”的字符串 $s$，使得其最短唯一子串的长度恰好为 $k$。

## 说明/提示

在第一个测试样例中，很容易看出字符串 $s = $ "1111" 的唯一子串就是整个字符串 $s$ 本身，其长度为 $4$。

在第二个测试样例中，字符串 $s = $ "01010" 的最短唯一子串为 $t = $ "101"，其长度为 $3$。

在第三个测试样例中，字符串 $s = $ "1011011" 的最短唯一子串为 $t = $ "110"，其长度为 $3$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 4
```

### 输出

```
1111```

## 样例 #2

### 输入

```
5 3
```

### 输出

```
01010```

## 样例 #3

### 输入

```
7 3
```

### 输出

```
1011011
```

# 题解

## 作者：ChthollyTree (赞：7)

神仙题，那场CF有三个红黑名没做出来的奇怪构造题。

我也是赛后看的dalao的博客才会的

这么构造

直接上代码,构造正确性的证明放后面：

```
#include<bits/stdc++.h>
using namespace std; 
int n,k; 
int main() { 
	scanf("%d%d",&n,&k); 
	for(int i = 1;i <= n; i ++) { 
		printf("%d",(i%((n-k)/2+1)>0)); 
	}
	return 0; 
}

```

为什么这样做是对的呢？

然后您试几组数据，就会发现字符串长这样

设$l = \frac{n-k}{2}$

`[11..11(l个1)0][11..11(l个1)0]...[11..11(l个1)0][11111]`我们把每个中括号里的字串，称之为一个“块”

接下来，我们选取从$s_{l+1}$到$s_{n-l}$这一段字符串。

会发现长度一定为k,且一定不会在$s$中再次出现

证明：

先需要证明一定有一个不重复出现的长度为k的串

首先，$s_{l+1}$一定是一个0,且下一个0要到下一个块里找，至少要到$s_{2l+2}$，但是此时从$s_{2l+2}$开头已经无法容纳一个长度为$k$的子串了

接下来，证明长度$< k$的子串肯定重复出现，设长度为$t$

对于一个子串，假如它开头不是从第一个块开始的，则将其左移$l+1$的位置即可找到相同的字符串（因为块块之间相同，最后一个块与其他块的前缀相同）

否则，右移 $l+1$位置,

我们可以证明，一定不会超出边界

设初始位置为$p$

则原来的结束位置为 p+t-1

右移后位置 p + t + l

因为

$p <= l+1 = \frac{n-k}{2}+1$

$t <= k-1$

$l = \frac{n-k}{2}$

所以 $p+t+l <= n$

到此证明完毕

---

## 作者：uenohara_ayano (赞：2)

我居然没有写题解！

先放代码，再证结论！

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    if(n==k){
        for(int i=1;i<=n;i++){
            putchar('1');
        }
        return 0;
    }
    for(int i=1;i<=n;i++){
        printf("%d",!(!(i%((n-k>>1)+1))));
    }
    return 0;
}
```

就是你写出来这个形式，就是设 $L=\frac{n-k}{2}$，那么就会循环 `(L个1)(0)` 很多次直到循环到 $n$。

这怎么就满足条件了呢！

长度为 $k$ 的区间就是从第 $L+1$ 个直到第 $L+k$ 个，因为这样做的话至少要往后面找一个 $0$，但是找不到了，因为序列没有那么长。

长度为 $k-1$ 的区间都可以往后面找一个相同的或者往前面找一个相同的，于是就满足条件啦！

---

## 作者：lalaouye (赞：1)

这题是有迹可循的！下面从一个思考者的角度讲述解题方法。

首先这两条限制很奇怪，但感觉都是很强的性质。所以这道题光想入手都是比较难的，先考虑怎么入手。

第二条限制相对简单，先考虑第二条限制。我们注意到，如果一个串的数字全是 $1$，显然可以满足限制一。那限制二我们考虑将一个 $1$ 变成 $0$ 达到。考虑变第一个 $1$，发现有烦人的性质一，考虑把第 $k$ 个 $1$ 变成 $0$，并将末尾变成 $0$，这可以解决 $2k\le n$ 的情况。

若 $2k>n$ 怎么办？我们考虑找到一个恰当的位置塞下唯一的那个子串，但是我手玩了亿点点方案都没能解决，怎么办？这道题最厉害的地方来了，别忘了 $n,k$ 奇偶性相同，而一共有 $n-k+1$ 个位置可以塞下满足性质二的串，我们对前 $n-k+1$ 个位置进行思考，我们发现，位置个数是奇数，我们把正中间的 $1$ 变成 $0$，其它位置不变，这样性质二就满足了。对于性质 $1$，我们发现每隔 $\frac{n-k}{2}$ 个 $1$ 中塞一个 $0$ 就能满足性质一，然后一个很优美的构造方法就这样想出来啦！

事实上，这道题我一共想了一小时，而真正有进展的只有寥寥几分钟，这种题虽然很巧妙，但还是希望这种题不要在正赛考场中出现。。

代码：


```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; ++ i)
#define rrp(i, l, r) for (int i = r; i >= l; -- i)
#define pii pair <int, int>
#define eb emplace_back
#define id(x, y) m * ((x) - 1) + (y)
#define ls p << 1
#define rs ls | 1
using namespace std;
constexpr int N = 1e5 + 5;
constexpr double PI = acos (-1.0);
typedef long long ll;
typedef unsigned long long ull;
inline int rd () {
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + ch - 48;
    ch = getchar ();
  }
  return x * f;
}
int n, k;
char s[N];
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout); 
  n = rd (), k = rd ();
  int o = (n - k) / 2 + 1, i;
  for (i = 1; i + o - 1 <= n; i += o) {
    rep (j, 1, o - 1) putchar ('1');
    putchar ('0');
  }
  for (; i <= n; ++ i) putchar ('1');
}
```

---

## 作者：BPG_ning (赞：1)

[原题传送门](https://www.luogu.com.cn/problem/CF1158B)

### 省流版：注意力题

事实上写完才发现题意理解错了。

首先可以发现，$0,1$ 可以互换。

所以三个样例可以转化成：

$n=4 ,k=4\to0000$

$n=5 ,k=3\to01010$

$n=7 ,k=3\to1011011$

注意到：

$1$ 总是在 $0$ 之间成段出现。

而且段长为 $\frac{(n-k)}{2}$。

恰好 $n\equiv k\pmod 2$。

于是就做完了（？？？）。


### 代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+10;
int n,k;
int cnt,c[N];
int main(){
	ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n>>k;
	while(cnt+(n-k)/2+1<=n){
		for(int i=1;i<=(n-k)/2;i++) c[++cnt]=1;
		c[++cnt]=0;
	}
	while(cnt<n) c[++cnt]=1;
	for(int i=1;i<=n;i++) cout<<c[i];
	return 0;
}

```

### 证明：

**注意**到结论后证明是容易的。

以下令 $len=\frac{(n-k)}{2}$。

因为答案是由若干循环节构成。

条件一：所以当子串长度 $<k$ 时，一定可以向左或向右平移 $len+1$ 个字符与另一个子串重合。

条件二：令该子串左端点 $L=len+1$，即第一个 $0$。

你发现这个它不能通过向右平移找到重合部分。

因为此时右端点 $R=L+k-1=len+k=\frac{(n+k)}{2}$。

向右平移 $len+1$ 个字符后，$R'=R+len+1=\frac{(n+k)}{2}+\frac{(n-k)}{2}+1=n+1$ 不存在。

故子串 $[len+1,len+k]$ 仅出现一次。

评价：注意力好题。

---


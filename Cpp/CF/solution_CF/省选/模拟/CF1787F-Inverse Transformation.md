# Inverse Transformation

## 题目描述

一位科学家正在研究一个自我生长的长度为 $n$ 的排列 $a_1,a_2,\ldots,a_n$。

排列每天都会变化，每一天，元素 $x$ 都会变成 $a_x$，即 $a_x$ 会变成 $a_{a_x}$。具体地：

- 第一天，排列会变成 $b$，其中 $b_x = a_{a_x}$；
- 第二天，排列会变成 $c$，其中 $c_x = b_{b_x}$；
- $\ldots$

例如，若 $a = [2,3,1]$，则第一天会变成 $[3,1,2]$，第二天会变成 $[2,3,1]$。

定义 $\sigma(x) = a_x$，定义 $f(x)$ 为最小的正整数 $m$ 满足 $\sigma^m(x) = x$，其中 $\sigma^m(x) = \underbrace{\sigma(\sigma(\ldots \sigma}_{m \text{ 个 } \sigma}(x) \ldots))$。

例如，$a = [2,3,1]$ 时，$\sigma(1) = 2$，$\sigma^2(1) = \sigma(\sigma(1)) = \sigma(2) = 3$，$\sigma^3(1) = \sigma(\sigma(\sigma(1))) = \sigma(3) = 1$，故 $f(1) = 3$。再例如 $a = [4,2,1,3]$，$\sigma(2) = 2$ 故 $f(2) = 1$；$\sigma(3) = 1$，$\sigma^2(3) = 4$，$\sigma^3(3) = 3$ 故 $f(3) = 3$。

现在给出第 $k$ 天的排列 $a'$。求找出一个初始的排列 $a$ 使得 $\sum\limits^n_{i=1} \dfrac{1}{f(i)}$ 最小。

~~因为鬼畜的 sigma 和审核争了好久~~


第二行 $n$ 个正整数 $a'_1,a'_2,\ldots,a'_n$（$1 \le a'_i \le n$）表示第 $n$ 天的排列。

保证所有测试数据的 $n$ 之和不超过 $2\cdot 10^5$。

## 样例 #1

### 输入

```
10
5 3
1 2 3 4 5
7 2
1 2 3 4 5 6 7
8 998
1 2 3 4 5 6 7 8
6 1
6 3 5 4 1 2
4 8
4 2 1 3
9 1
1 5 4 8 7 6 3 2 9
5 9999999
2 3 4 5 1
7 97843220
4 6 1 2 7 5 3
3 1000000000
2 1 3
12 3
8 9 10 1 5 3 11 4 7 6 12 2```

### 输出

```
YES
2 3 4 1 5
YES
6 2 5 7 1 3 4
YES
2 3 4 5 6 7 8 1
YES
3 1 6 4 2 5
YES
4 2 1 3
NO
YES
3 4 5 1 2
YES
2 5 4 6 3 7 1
NO
YES
3 7 8 6 5 1 12 10 11 4 2 9```

# 题解

## 作者：qzhwlzy (赞：8)

2023/2/21 Update 修复笔误并增加了我的 std

~~出题人来背锅了~~

## 题目大意

给定长度为 $n$ 的排列 $a$。定义 $\sigma(x) = a_x$。定义 $f(x)$ 等于最小的 $m$，满足 $\sigma^m(x) = \underbrace{\sigma(\sigma(\ldots \sigma}_{m \text{ 个 } \sigma}(x) \ldots)) = x$。

每一天 $a$ 中的每个元素 $x$ 都会变成 $\sigma(x)$，$\sigma(x)$ 随 $a$ 变动。给出第 $k$ 天的排列 $a'$，找出 $\sum\limits_{i=1}^n \dfrac{1}{f(i)}$ 最小的一个排列 $a$。

~~这是原来的题面，由于易引起歧义故改成现在的版本（虽然没啥大区别~~

## 思路

先思考若知道了 $a$ 如何求 $a'$。

对于 $i$ 和 $a_i$ 之间建立有向边，这样能更好展现变化过程。容易发现，得到的图由若干个环组成，接下来研究这些环在变化中呈现出的规律。

对于一个长度为 $l$ 的环 $c$（$c$ 内按顺序对元素重新标号），$a_x$ 在第一天后会变成 $x$ 后面的元素，即 $x$ 会指向之后的两个元素；第二天，同理 $x$ 会指向新图中其之后的第二个元素，也就是原图中 $x$ 之后的第 $4$ 个元素……这样下去，我们会发现，$x$ 在第 $k$ 天会指向其之后的第 $2^k$ 个元素，也就是 $c_{(X + 2^k)\bmod l}$（$X$ 为 $x$ 新的标号，下标为 $0$ 则为 $l$）。举个栗子，对于环 $2\rightarrow 1\rightarrow 3(\rightarrow 2)$，我们按顺序重新标号（$2$ 标为 $1$ 以此类推），得到 $2(\texttt{1})\rightarrow 1(\texttt{2})\rightarrow 3(\texttt{3})(\rightarrow 2(\texttt{1}))$（括号内为标号）。第二天时，$2$ 会指向其之后的第 $2^2 = 4$ 个元素，即 $c_{(1 + 4)\bmod 3} = c_2 = 1$。

但是真的是这样吗？对于奇数的 $l$，$2^k \bmod l\neq 0$，故会像上述那样不断循环。但是，若 $l$ 为偶数，我们发现，在第一天后，$c_1$ 指向 $c_3$，$c_3$ 指向 $c_5$，……，$c_{n-1}$ 指向 $c_1$；$c_2$ 指向 $c_4$，$c_4$ 指向 $c_6$，……，$c_{n-2}$ 指向 $c_2$。于是，我们发现原图分裂成了两个**大小相等**（均为 $\dfrac{l}{2}$）的小环。于是，一个大小为 $l = 2^q\cdot p$ 的环在 $q$ 天后会得到 $2^q$ 个大小为 $p$ 的环。如下图，一个大小为 $12$ 的环经过两天分裂为了 $4$ 个大小为 $3$ 的环（感谢 rsj 为题解配的图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/5vhgmoq6.png)

所以，对于 $a$，我们可以暴力跑至少 $\log n$ 天把所有偶环分裂掉，然后使用上述结论得到最终结果。

-------

接下来我们考虑这题。

显然 $f(x)$ 即为 $x$ 所在环的大小，故 $\sum\limits_{i=1}^n \dfrac{1}{f(i)}$ 即为图中环的个数。为了让原图中环的个数最小化，我们可以将大小相同的环不断合并。对于 $a'$ 中奇数大小的环，可以不断将 $2^q$（$q\le k$）个合并；对于偶数大小的环，只能恰好将 $2^k$ 个合并，若个数不是 $2^k$ 的倍数则输出 `NO`。

现在我们知道了原图的形态，现在要做的就是填数。方法很多，可以使用数学方法（参考 CF 题解中 rsj 的 std），也可以像我一样暴力跑然后映射（码量有点大，很容易寄）。

-------

总体来说，这题出得不是特别满意，结论不难想但是码量有点大。再次为大家道歉了。

我的代码在[这里](https://www.luogu.com.cn/paste/g8af9hy5)（太难理解了，若有需要请移步 CF 看 [rsj 的代码](https://codeforces.com/blog/entry/112009)。

最后感谢大家捧场我们的 CF（虽然出了一堆问题....

---

## 作者：lingfunny (赞：1)

## 题意简化

\*2500

对于一个排列，每天会将其 $p_i\gets p_{p_i}$。给出 $k$ 天后的排列，求原排列最少有几个轮换。

## 题解

操作比较抽象，手动刻画一下。

对于一个原轮换，一次操作后 $i\to p_i$ 会变成 $i\to p_{p_i}$，也就是原图中向前走两步的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/608rcmqz.png)

规律性非常强，进一步的，我们有以下两个结论：

1. 对于置换 $(a_1~a_2~\cdots~a_n)$，若 $n$ 为偶数，则该置换进行一步变换后会变成 $(a_1~a_3~\cdots~a_{n-1})(a_2~a_4~\cdots~a_n)$。
2. 对于置换 $(a_1~a_2~\cdots~a_n)$，若 $n$ 为奇数，则该置换进行一步变换后会变成 $(a_1~a_3~\cdots~a_n~a_2~\cdots~a_{n-1})$。

不难发现长度为奇数的轮换长度不会改变，长度为偶数的会被一直除 $2$ 直到变为奇数。

原题是给定最后的结果，要求反推 $k$ 次前的最小轮换数。

感觉就不用多说了，先把结果的排列分解成若干个轮换，然后挑选两个大小相等的轮换合并。

还要考虑无解的情况。对于结果排列，如果存在一个长度为偶数的轮换，则前 $k$ 次其都必须被合并到，换句话说必须存在 $2^k$ 个长度和其一样的轮换（包括自己），如果不存在直接输出无解。

考虑掉上面这个情况后，剩下的轮换我们按长度分类，统计长度相同的轮换数量。显然问题变成对其分组，并且每组的大小都要是 $2$ 的幂次。

把数量拆分为两部分考虑，对于小于等于 $2^k$ 的部分，则直接拆分成每个二进制 bit 即可，对于大于 $2^k$ 的部分，拆分成若干个 $2^k$ 即可。最优性显然。

对于分到一组的轮换，随便钦定一个顺序轮流放即可，正确性显然。

总时间复杂度 $O(n)$。

---


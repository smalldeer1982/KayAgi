# Amanda the Amoeba

## 题目描述

如图，$r\times c$ 的网格中有一只变形虫。每个格子有三种状态：被变形虫的身体占据（绿色），空白（白色），或存在障碍物（黑色）。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1949J/2d5e02ef9bf4591daa4ba1b57883d9c6fd37e0dd.png)

每次移动，先将身体占据的格子之一变为空白，然后再把某个与身体相邻的空白格子变为身体所占据。两个格子相邻当且仅当有公共边。移动过程中要保证身体是连通的，且不占据障碍物。

已知变形虫初始占据了哪些格子，它想移动到占据着给出的另一些格子（虚线内）的状态。求任意一种方案。

## 样例 #1

### 输入

```
5 8
.******.
**.X**..
*******.
**.X**..
.******.


.******.
...X****
.*******
...X****
.******.```

### 输出

```
YES
5
3 1 3 8
2 1 2 8
4 1 4 8
2 2 4 7
4 2 2 7```

## 样例 #2

### 输入

```
2 5
*.X..
**X..


..X**
..X*.```

### 输出

```
NO```

# 题解

## 作者：创世游戏科技 (赞：2)

# Amanda the Amoeba

## 题目大意

如图，$r\times c$ 的网格中有一只变形虫。每个格子有三种状态。它可以将身体的一个格子转移到与边界相邻的另一个各自，其中移动过程中要保证身体是连通的，且不占据障碍物。

## 思路解析

这题的思路我也是看了第一篇大佬的题解才懂的，这里补充几点。

首先考虑到我们对于任意一个**合法的状态**，经过有限次变换后，我们总能走到另一个**合法的状态**。

这启发我们可以构造出一个中间状态，使得起始状态转移到中间状态，再从中间状态走到终止状态。

什么样的状态是最好的呢，当然是使得全部身体都在编号最小的**可到达**的连通块中。比如样例我们标号为下图


```
  1  2  3  4  5  6  7  8
 38 28 27  0 24 17 16  9
 37 29 26 25 23 18 15 10
 36 30 31  0 22 19 14 11
 35 34 32 33 21 20 13 12
```

那么我们让它占据下图。


```
*  *  *  *  *  *  *  *
.  .  .  X  *  *  *  *
.  .  *  *  *  *  *  *
.  .  .  X  *  *  *  *
.  .  .  .  *  *  *  *
```

这样做是好构造的，我们只需要让它身体的编号不断减小就好了。具体而言，我们每次拿出编号最大的身体放在编号最小的空白位置，就可以让它**最大值不断减小**，直到恰好占据可到达的最小编号位置即可。

但这样做是有两个问题的，因为我们可能发现它的身体是有顺序限制的。

例如下图。

```
*  .  .  .  .  .  .  .
*  X  X  X  X  X  X  X
*  X  .  .  .  .  .  .
*  X  .  .  .  .  .  .
*  X  .  .  .  .  .  .
```

显然只有两个点可以操作，如果操作其他点，**会使得连通块断开**。

也就是不经过这个点，就有一些点无法到达，使得图不连通，我们可以联想到是**割点**。

另一个问题是要到达编号最小的空白位置中间可能要经过一些其它的点，比如上图要想到达右上角就需要经过一些其他的点。

这时候我们能够选的编号最小的必须是与身体相连的编号最小的空白位置。

考虑我们的方案变成了拿出编号最大的**非割点**身体放在编号最小**与身体相连的空白位置**。

那么我们每次枚举身体的点，跑 tarjan 求出编号最大的**非割点**身体。然后同时维护它周围的编号最小**与身体相连的空白位置**。完成移动即可。

对于终止状态同理，但是需要倒序输出，我们要正着操作。

时间复杂度分析：

对于一个状态，我们最多移动 $2rc$ 次到达中间状态，考虑每次移动需要枚举全部的点和进行一次 tarjan 算法。那么最后时间复杂度为 $O(r^2c^2)$，可以通过本题。

## 参考实现

[Code](https://www.luogu.com.cn/paste/vwgs3p7m)

---

## 作者：Conan15 (赞：2)

首先一步重要的转化是：找到一个起点和终点都能到达的中间状态，并分别求起点到中间、终点到中间的方案再合并起来输出。\
那么现在的难点就在于如何寻找唯一确定的中间状态。

这是第二步重要的转化：考虑对这张地图进行编号，并把变形虫移动到编号最小的位置。\
可以想到对于一个连通块直接用一次 dfs 编号，会产生一个类似于树的结构，这样移动过去显然最终状态是唯一确定的。

那么如何实现移动过程呢？发现移动相当于删除一个点，再添加一个点。\
显然，在移动过程中变形虫不能断开，所以删除的不能是割点，而添加的点显然根据贪心是变形虫周围编号最小的点。\
那么大致的算法思路就出来了：每次寻找一个**编号最大非割点**删掉，并在周围寻找**编号最小空地**添加进变形虫。

---

## 作者：james1BadCreeper (赞：1)

我们考虑将初始状态和结束状态都移到一个相同的状态，然后将结束状态转到相同状态的过程反过来即可。

将一个状态转移到字典序最小的合法状态，初始时按照连通块的顺序给连通块内的点进行编号，每次将最大非割点转移到最小的可以空白位置即可。

```cpp
#include <bits/stdc++.h>
using namespace std; 
const int N = 1e4 + 5; 
const int DX[] = {-1, 0, 1, 0}, DY[] = {0, 1, 0, -1}; 
 
int n, m; 
char s[55][55]; 
int c, p[55][55], x[N], y[N]; 
int mx, mn, tot, X1[N], Y1[N], X2[N], Y2[N]; 
 
inline bool ishe(int x, int y) {
    return x >= 1 && x <= n && y >= 1 && y <= m && s[x][y] != 'X'; 
}
 
void dfs1(int x, int y) {
    p[x][y] = ++c, ::x[c] = x, ::y[c] = y;
    for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k], yy = y + DY[k]; 
        if (ishe(xx, yy) && !p[xx][yy]) dfs1(xx, yy); 
    }
}
 
int dfn[55][55], low[55][55], num; 
void tarjan(int x, int y, int fx, int fy) {
    dfn[x][y] = low[x][y] = ++num; 
    int c = (fx != 0); 
    for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k], yy = y + DY[k]; 
        if (!ishe(xx, yy) || s[xx][yy] == '.') continue; 
        if (!dfn[xx][yy]) {
            tarjan(xx, yy, x, y); low[x][y] = min(low[x][y], low[xx][yy]); 
            if (dfn[x][y] <= low[xx][yy]) ++c; 
        } else low[x][y] = min(low[x][y], dfn[xx][yy]); 
    }
    if (c < 2) mx = max(mx, p[x][y]); 
}

int solve(void) {
    while (1) {
        mx = num = 0, mn = c + 1;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j) {
                if (s[i][j] == '*') {
                    if (!mx) tarjan(i, j, 0, 0), s[x[mx]][y[mx]] = '.'; 
                    if (s[i][j] == '*') {
                        for (int k = 0; k < 4; ++k) {
                            int xx = i + DX[k], yy = j + DY[k]; 
                            if (ishe(xx, yy) && s[xx][yy] == '.') mn = min(mn, p[xx][yy]); 
                        }
                    }
                }
                dfn[i][j] = low[i][j] = 0;
            }
        if (mx == mn) return mx; 
        ++tot; X1[tot] = x[mx]; Y1[tot] = y[mx]; X2[tot] = x[mn]; Y2[tot] = y[mn]; 
        s[x[mn]][y[mn]] = '*'; 
    }
}
int main(void) {
    ios::sync_with_stdio(0); 
    cin >> n >> m; 
    for (int i = 1; i <= n; ++i) cin >> s[i] + 1; 
    for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) if (s[i][j] != 'X' && !p[i][j]) dfs1(i, j); 
    int id = solve(), _ = tot; 
    for (int i = 1; i <= n; ++i) cin >> s[i] + 1; 
    if (id != solve()) return cout << "NO\n", 0; 
    cout << "YES\n" << tot << "\n"; 
    for (int i = 1; i <= _; ++i) cout << X1[i] << ' ' << Y1[i] << ' ' << X2[i] << ' ' << Y2[i] << '\n'; 
    for (int i = tot; i > _; --i) cout << X2[i] << ' ' << Y2[i] << ' ' << X1[i] << ' ' << Y1[i] << '\n'; 
    return 0; 
}
```

---


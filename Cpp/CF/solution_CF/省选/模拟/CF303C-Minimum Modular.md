# Minimum Modular

## 题目描述

You have been given $ n $ distinct integers $ a_{1},a_{2},...,a_{n} $ . You can remove at most $ k $ of them. Find the minimum modular $ m $ $ (m&gt;0) $ , so that for every pair of the remaining integers $ (a_{i},a_{j}) $ , the following unequality holds: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF303C/e08769ae8f052f7d357ba6c3db7e7cd896370f65.png).

## 样例 #1

### 输入

```
7 0
0 2 3 6 7 12 18
```

### 输出

```
13
```

## 样例 #2

### 输入

```
7 1
0 2 3 6 7 12 18
```

### 输出

```
7
```

# 题解

## 作者：_HCl_ (赞：2)

# CF303C 题解

**题意简述**

给定 $n$ 个正整数，询问最小的 $m$，使得删去其中 $k$ 个数后，所有数模 $m$ 互异。

**思路引导**

首先考虑到 $m$ 的范围不会很大（不超过 $10^6$），因此可以尝试枚举 $m$，判断是否符合条件。

如果一个 $m$ 是合法的，那么同余的数的个数就不会超过 $k+1$，即有不多于 $\frac{k(k+1)}{2}$ 对 $(i,j)$ 满足 $a_i\equiv a_j\pmod{m}$。但是暴力统计对数显然是不行的，单次统计的复杂度就是 $\mathcal{O}(n^2)$。考虑对其进行优化。

我们可以对同余的条件进行转化：$a_i\equiv a_j\pmod{m}\Leftrightarrow m|(a_i-a_j)$。那么就可以先进行预处理，把每一对 $(a_i-a_j)$ 扔进桶里，判断时枚举 $m$ 的倍数即可。

但还需要注意的是，同余对数不超过 $\frac{k(k+1)}{2}$ 只是 $m$ 合法的必要条件，而不是充分条件。所以还需要再进行暴力判断是否真的合法。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,k;
int a[N],cnt[N],tt[N];
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;++i)scanf("%d",a+i);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j){
            cnt[a[j]-a[i]]++;
        }
    }
    for(int i=n-k;i<=1e6;++i){
        int res=0;
        for(int j=i;j<=1e6;j+=i){
            res+=cnt[j];
        }
        if(res>k*(k+1)/2)continue;
        res=0;
        for(int j=1;j<=n;++j){
            int x=a[j]%i;
            if(tt[x])res++;
            if(res>k)break;
            tt[x]=1;
        }
        if(res<=k){
            cout<<i;
            return 0;
        }
        for(int j=1;j<=n;++j){
            tt[a[j]%i]=0;
        }
    }
}
```

---

## 作者：mydiplomacy (赞：2)

简单题意：给出一个数列，求一个最小的$m$，满足存在一种删掉$k$个数的方案，使得剩下的数模$m$不同余。

尝试枚举几次样例后我们可以直观感觉到，$m$不会太大。

首先考虑若给定$m$，如何判定能否在删掉小于等于$k$个数后使所有数模$m$不同余。我们可以从前往后遍历每个数，若这个数模$m$的结果已经在前面出现过了，那么这个数（或者前面的数）必须被删掉，$cnt++$。扫一遍之后的$cnt$结果就是需要删掉的数个数。单次判断效率是$O(n)$。

如果我们从小往大枚举$m$（注意这里$m$不满足单调性，所以不能二分），每次进行判断。但这样会$TLE$。我们需要继续分析性质，对$m$进行剪枝。

考虑如果两个数$a_i$与$a_j$模$m$不同余。则可推得$(a_i-a_j)$不是$m$的倍数。于是问题可以转化为，删掉$k$个数以后剩下的数两两相减的结果不是$m$的倍数。

根据性质，如果$m$是答案，那么在删掉$k$个数以后，剩下的任意一个数对的差值不能是$m$或$m$的倍数。所以，当我们处理出来所有差值后，我们需要将所有$m$或$m$的倍数的差值消除（通过删除这个差值的两个数中的至少一个）。

这里有一个剪枝，如果在删除$k$个数后成立，那么删除之前差值是$m$或$m$的倍数的数对（即需要被删除至少一个数的数对）不超过$(k*k+k)/2$个。证明：假设消除前有超过$(k*k+k)/2$个差不满足条件。所有消除的差中，有些差值两个数其中的一个数被删除了，有些差值两个数都删除了。然而后者的数量不超过$k*(k-1)/2$个。所以，后者的数量超过了$(k*k+k)/2-k*(k-1)/2=k$个。所以，至少有$k+1$个需要删除的差值，其中的一个数没有被删除，而另一个数被删除了。而删除的数总共只有$k$个，根据鸽巢原理，这$k+1$个差值中，必存在至少两组数对，满足被删除的数是同一个数，我们设这个数是$x$，两组数对分别为$(x,y)$和$(x,z)$。那么$x$与$y$模$m$同余，$x$与$z$模$m$同余。所以$y$与$z$也模$m$同余，但$y$与$z$都没有被删除。矛盾。证毕。

所以，当枚举到一个$m$的时候，发现差是m的倍数的数对超过$(k*k+1)$组，那么就可以直接排除$m$。另外注意，虽然两两之间的差值有$n^2$个，但是由于$a_i<=1e6$，所以差值$<=1e6$，所以可以开一个$book$数组预处理出每个差值有多少个。这道题就可以$AC$了。

---

## 作者：Super_Cube (赞：1)

# Solution

因为答案最大不超过值域，考虑枚举 $m$。

$a_i\equiv a_j\pmod m$ 等价于 $m\mid(a_i-a_j)$，所以把每对数的差值打桶记录一下。查询桶中下标为 $m$ 倍数的和，如果这个值大于 $\dfrac{k(k+1)}{2}$，那么一定不满足条件，因为删去 $k$ 个值最多也就减少 $\dfrac{k(k+1)}{2}$ 的同余数量。剩下的直接暴力验证是否合法即可。

时间复杂度好像是 $O(n^2+V\ln V+k^2V)$。

# Code

```cpp
#include<bits/stdc++.h>
int cnt[1000005];
int vis[1000005];
int a[5005];
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		for(int j=i-1;j;--j)
			++cnt[std::abs(a[i]-a[j])];
	}
	for(int i=1,sum;i<=1000000;++i){
		sum=0;
		for(int j=i;sum<=(m*(m+1)>>1)&&j<=1000000;j+=i)sum+=cnt[j];
		if(sum>(m*(m+1)>>1))continue;
		sum=0;
		for(int j=1;j<=n;++j)
			if(vis[a[j]%i]!=i)vis[a[j]%i]=i;
			else if(++sum==m+1)break;
		if(sum!=m+1)return 0&printf("%d",i);
	}
	return 0;
}
```

---

## 作者：cryozwq (赞：1)

upd：错误已修改，望管理员重审	

~~唯一一篇题解年代久远，我来补一篇。~~

首先考虑我们怎么暴力的求解问题。显然可以枚举 $m$，由于题目保证了 $a$ 互不相同，$m$ 的最小值一定在 $[n-k,10^6]$ 中（为什么是 $n-k$ 因为“余数互不相同”就代表至少要有可能出现的 $n-k$ 种余数），每次暴力扫一遍，看有几个重复的，若小于 $k$ 则就是答案。复杂度 $O(10^6 n)$，由于 $n\le 5000$，已 经 要 行 了。

再从别的角度考虑，我们要删除一个数，当且仅当它在模 $m$ 意义下和别的数同余，那么两个数 $a_i$ 和 $a_j$ 同余的必要条件是什么？是 $m$ 能整除 $|a_i-a_j|$，那么进一步的，对于所有 $i>j$，如果我们能预处理出所有的 $a_i-a_j$（先进行排序），则删除一个数实质上是删除了一个被当前枚举的 $m$ 整除的差。问题变为：删除至多 $k$ 个数，使得剩下的数两两之差都不是 $m$ 的倍数。

这时我就想到了一种错误的思路：我们预处理所有的 $a_i-a_j$，找到最小的 $m$ 使得它最多整除 $k$ 个差。很不幸这是错的，考虑这样一组样例：
```
4 2
2 3 5 7
```

这样如果你按照我说的思路答案应该是 $3$，但实际上答案是 $2$，为什么？因为其实所有的差值中有 $3$ 个能被 $2$ 整除的但其实两次确实可以消完。

那怎么办呢？我们重新审视最开始的暴力做法，利用刚刚的分析来剪枝。为什么之前的做法错误了？因为其实删除的数对数是不确定的，但是我们显然会发现这个 $k$ 次删除的数对数有个上限，也就是最好情况下我们删除了 $k$ 个数，这 $k$ 个数两两之差都是 $m$ 倍数，此时 $k$ 次操作删除了 $\frac{k(k-1)}{2}$ 个数对，也就是如果此时枚举的 $m$ 有超过 $\frac{k(k-1)}{2}$ 个数对是其倍数，肯定不是答案，可以直接剪枝掉。

由于唯一一篇题解没有代码，稍微放一下代码趴（我认为比较容易懂，所以就不解释了）：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e6;
int a[maxn+5],n,k,tot=0,b[maxn+5],s[maxn+5];
signed main(){ 
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){	
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			s[(a[j]-a[i])]++;
		}
	}
	for(int p=n-k;p;p++){ 
		if(p>=maxn){
			cout<<maxn<<endl; 
			return 0;
		}
       	int sum=0;
       	for(int i=p;i<=maxn;i+=p){
       		sum+=s[i];
		}
		if(sum>k*(k+1)/2){
			continue;
		}
		int cnt=0;
        for(int i=1;i<=n;i++){
            if(b[a[i]%p]==p){
                cnt++;
                if(cnt>k){
                	break;
            	}
            }
            b[a[i]%p]=p;
        }
        if(cnt<=k){
        	cout<<p<<endl; 
        	return 0;
		}
	}
} 
```

---


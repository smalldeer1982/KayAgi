# Cron

## 题目描述

有时，经典的解决方案不够强大，我们必须自己设计。为了解决这个问题，你必须实现任务调度系统的一部分。

每个任务都应在某些特定时刻执行。在我们的系统中，您可以为任务的执行时间设置精确的秒、分、小时、星期、日、月值。此外，您还可以设置一个特殊值 $-1$，表示该参数的任何值都有效。

例如，如果参数字符串为 `-1 59 23 -1 -1 -1`，则问题将在每天的 $23:59:00$、$23:59:01$、$23:59:02$、...、$23:59:59$ 执行（共执行 $60$ 次）。

秒、分和小时从 $0$ 开始编号，而日、月和星期则从 $1$ 开始编号。一周的第一天是星期一。

有一种特殊情况需要单独处理。如果同时给出星期和日期（即与 $-1$ 不同），则执行任务时这两个参数中至少有一个应与当前时间匹配（如果两个都匹配也可以，当然，所有其他参数也应匹配）。例如，参数字符串 `0 0 12 6 3 7` 表示任务将在 $2016$ 年 $7$ 月 $2$ 日（星期六）和 $2016$ 年 $7$ 月 $3$ 日（星期日）中午执行。

我们不应忘记闰年的存在。如果数字能被 $400$ 整除，或者不能被 $100$ 整除，但能被 $4$ 整除，那么这一年就是闰年。每个闰年有 $366$ 天，而不是通常的 $365$ 天，因为二月延长到 $29$ 天，而不是通常的 $28$ 天。

当前时间表示 $1970$ 年 $1$ 月 $1$ 日（星期四）$00:00:00$ 之后经过的秒数。

您将得到由六个参数组成的字符串，用于描述任务执行的时间点。您还会得到若干个时间点。您必须为每个时刻找到第一个严格大于当前时刻的时间点，以便执行任务。

## 说明/提示

$1970$ 年 $1$ 月 $1$ 日午夜之后的 $1467372658$ 时刻是 $2016$ 年 $7$ 月 $1$ 日 $11$ 时 $30$ 分 $58$ 秒。

翻译 @[\_Sunmoon\_](https://www.luogu.com.cn/user/394167)

## 样例 #1

### 输入

```
-1 59 23 -1 -1 -1
6
1467372658
1467417540
1467417541
1467417598
1467417599
1467417600
```

### 输出

```
1467417540
1467417541
1467417542
1467417599
1467503940
1467503940
```

## 样例 #2

### 输入

```
0 0 12 6 3 7
3
1467372658
1467460810
1467547200
```

### 输出

```
1467460800
1467547200
1468065600
```

# 题解

## 作者：Cure_Wing (赞：0)

[CF698E Cron](https://www.luogu.com.cn/problem/CF698E)

只能说是一道诈骗题。

### 思路

看到题目条件，数 $t$ 时间后符合条件的日期。这个时候我们会把它与[儒略日](https://www.luogu.com.cn/problem/P7075)联系起来。同样是数日期，这道题却简单得多，因为没有特殊日子要数。

像这样的数日期的题目，通常用两种方法：

1. 计算出答案的日期，反推出相对时间；

2. 计算出相对时间，反推出答案的日期。

但是这道题目如果单纯的数相对时间，$t$ 是 $10^{12}$ 级别，肯定来不及。如果从日期考虑，那么推出相对时间又很麻烦。

我们发现第二种方法的优点是方便读入和输出答案，第一种方案的优点是方便判断，于是我们折中一下。我们预处理符合条件的日（星期几），记录下符合条件天的**相对天数**（因为这个范围很小），然后对于每一个相对时间 $t$，我们可以二分出最小满足可能满足条件的相对天，接下来枚举相对时间，然后判断**这一天**是否存在满足条件的**相对时间**（秒为单位）。如果这一天不存在符合条件的时刻，那么往后再找符合条件的一天，可以想到这一天一定有解；否则直接将那一天的答案输出。

时间复杂度 $O(a+bn)$，$a$ 是预处理天数，取 $t=10^{12}$ 时，$a=\frac{10^{12}}{b}\approx1.2\times10^7$，$b$ 是一天的秒数，取 $b=24\times60\times60=86400$（秒）。

所以这道题看起来吓人，以为是一道模拟题，实际上只是一道平衡规划的题目而已。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using std::cin;using std::cout;
constexpr int N=12000000,K=86400;
int s,m,h,d,dat,mo,n,day=1,date=4,month=1,year=1970;
long long t;
std::vector<long long>w;
inline int limit(int y,int m){
	if(m==4||m==6||m==9||m==11) return 30;
	if(m==2) return (y%4==0&&y%100!=0||y%400==0)?29:28;
	return 31;
}
inline long long check(long long u){//暴力判断改天是否存在时刻符合条件。
	for(int i=0;i<K;++i)
		if((h==-1||i/3600==h)&&(m==-1||i/60%60==m)&&(s==-1||i%60==s)&&u*K+i>t)
			return u*K+i;
	return -1;
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	cin>>s>>m>>h>>d>>dat>>mo>>n;
	for(int i=0;i<=N;++i){//预处理符合条件的天，记录相对天数
		if(month==mo||mo==-1){
			bool g1=(day==dat),g2=(date==d);
			if(g1||g2) w.push_back(i);//都告知只需一者满足
			else{
				g1|=(dat==-1);
				g2|=(d==-1);
				if(g1&&g2) w.push_back(i);//存在未告知二者均需满足
			}
		}
		++date;if(date>7) date=1;
		++day;if(day>limit(year,month)){++month;day=1;}
		if(month>12){++year;month=1;}
	}
	for(int i=1;i<=n;++i){
		cin>>t;
		int now=std::lower_bound(w.begin(),w.end(),t/K)-w.begin();//二分可能天
		long long ans=check(w[now]);
		if(ans==-1) ans=check(w[++now]);//如果不行后一合法天一定有解
		cout<<ans<<'\n';
	}
	return 0;
}
```

---


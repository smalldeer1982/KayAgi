# Forward, march!

## 题目描述

杰克现在成了一名士兵。不幸的是，他在演习中遇到了麻烦。他没有按照先迈出左脚再不断交换迈脚的顺序前进，而是不断地重复一系列的步骤序列，有时他会做出错误的步骤或者停一会儿。例如，如果杰克使用序列 “右，左，休息”，当中士喊道：“左！右！左！右！左！右！”杰克先用右脚迈出了一步，然后用左脚迈出了一步，然后他感到很迷惑，停了一会儿，然后又一次按照他自己的顺序——用右脚开始，然后用左脚，接着让中士恼怒的是——他又停下来喘口气，又不正确地用右脚开始 …… 这样子行军，杰克会在只有三分之一的时间迈出正确的步伐。

当警官说服他应该改掉这个毛病的时候，杰克决定修改他重复的步骤。然而，为了不太累，他决定他唯一要做的就是在原始序列中的任何位置添加任意数量的中断（中断对应于一步的停顿）。当然，如果这些步骤之间没有停顿，杰克就不能连续的迈出同一只脚。需要注意的是，他目前使用的步骤有可能是不正确的。

帮助士兵杰克！给出他开始时不断重复的步骤，计算出在他计划中增加一些休息时间后他能正确行进的时间占行军时间的最大百分比。

## 样例 #1

### 输入

```
X
```

### 输出

```
0.000000
```

## 样例 #2

### 输入

```
LXRR
```

### 输出

```
50.000000
```

# 题解

## 作者：YLWang (赞：12)

题目求的是一个分数。那么很自然地想到 01 规划以后去检验，只要把每一次操作的权值减一个 $mid$ 即可。

考虑 dp。

首先我们预处理一下，把所有不可能的地方的 $\texttt{X}$ 先填上。

我们发现在总的走路串长为奇数的时候处理极其恶心。但考虑到这样一定是相对不优的（一定存在某个位置使得在这个位置放一个 $\texttt{X}$ 就可以让其更优，读者自证不难），就直接忽略即可。

设 $f_{i, 0/1}$ 表示当前匹配到原串的第 $i$ 位，且当前位教官的命令是 $\texttt{R/L}$ 时的最大权值。

第一步转移，即不放 $\texttt{X}$：

$$
\begin {aligned}
\begin{cases}
f_{i, 0} = max\{f_{i, 0}, f_{i-1, 1} + [s_i = \texttt{R}] - mid\}
\\
f_{i, 1} = max\{f_{i, 1}, f_{i-1, 0} + [s_i = \texttt{L}]-mid\}
\end{cases}
\end {aligned}
$$

第二步转移，即放 $\texttt{X}$：

容易发现放一个 $\texttt{X}$ 相当于把教官的命令全部左移一格。
$$
\begin {aligned}
\begin{cases}
f_{i, 0} = max\{f_{i, 0}, f_{i, 1}  - mid\}
\\
f_{i, 1} = max\{f_{i, 1}, f_{i, 0} -mid\}
\end{cases}
\end {aligned}
$$

边界条件：
$$
\begin {aligned}
\begin{cases}
f_{0, 0} = 0
\\
f_{0, 1} = -mid
\end{cases}
\end {aligned}
$$

最终我们只需要取一手 $f_{n, 0} > 0$ 作为是否成功即可。

要注意的是一些奇奇怪怪的情况。

当 $s_0 = s_n = \texttt{R}$ 的时候，我们不能 naive 地直接加一个 $\texttt{X}$ 到后边去，而应该加在前面。

读者自证不难。

代码链接：https://www.luogu.com.cn/paste/s76jjb3t


---

## 作者：Euler_Pursuer (赞：10)

# 题目描述

给定一个含 `L`, `R`, `X` 的字符串，你可以添加若干 `X`，使得对改变后的新字符串无限循环时保证：

- 相同的非 `X` 字符不能相邻（包括循环前的首尾字符）
- 与 `LR` 循环串的匹配率（同位置字符相同率）最大

求出这个最大匹配率。

# 详细解析

由于输入的字符串可能出现 `LL` 或者 `RR` 的情况，而最后的答案必须要在它们之间加上一个 `X`，因此我们不妨在输入后就预处理好，给它们加上 `X`。而对于首尾相邻的情况，这就需要考虑到最后的匹配率情况来进行 `X` 的添加。如果首尾是 `LL`，那么将 `X` 加在最后是最好的；如果是 `RR`，那么 `X` 加在开头是最好的。

为什么暂时不需要考虑中间的呢？这是因为无论如何它们之间必须要加，而如何在别的地方加 `X` 来控制它们的位置，这就是我们后面需要做的事了。

而为什么后面的处理无法考虑好前面的问题呢？这就和我们选择的二分判断策略有关了，我们到后面再回答。

在进行我们的算法之前，我们需要知道一个事实：**改变后的新字符串长度为偶数最佳**。

如果长度为奇数最佳，那么我们将其倍长后会发现，前后串对应的 `LR` 是错开的，那么得到的最大匹配率就会等于 $\dfrac{cnt_L+cnt_R}{2Len}$。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/5uye0qsz.png)

我们假设之前的奇数串倍长后的两串贡献分别是 $x_1,x_2$，那么原来的匹配率就可以写成 $\dfrac{x_1+x_2}{2Len}$。

如果此时有 $x_1>x_2$，那么我们可以在原来这个奇数串后面加上 `X`，倍长后得到新的匹配率就是 $\dfrac{2x_1}{2Len+2}$。后者减去前者，只看分子部分有：$2x_1Len-x_1Len-x_1-x_2Len-x_2=(x_1-x_2)Len-(x_1+x_2)$。

再者，对于奇数串，必然有 $x_1+x_2<Len$。如果 $x_1+x_2=Len$，要么它会发生首尾相接的情况，要么其内部必然会出现 `LL` 或 `RR`，这与我们已经处理好的前提相悖。这样我们就证明了这种情况得到的最优情况必然是偶数串。

那如果是 $x_1=x_2$ 呢？我们可以看到上面的图就是这种情况，我们可以试着在中间加上 `X`。我们发现，如果在某个位置插入一个 `X`，那么后面的所有贡献就会反过来，我们只需要找到某个位置，满足插入 `X` 后会导致 $x_1>x_2$ 即可。那如果导致 $x_1<x_2$ 的位置行不行呢？答案是否定的，因为变成偶数串后，必须是按照 `LRLR...` 的顺序来匹配的。

然而，的确存在一类情况，使得**没有任何**位置能只插入一个 `X` 使得 $x_1>x_2$。举个例子：`RXL`：

![](https://cdn.luogu.com.cn/upload/image_hosting/xlm7fcbj.png)

我们会发现，无论如何插入一个 `X`，得到的匹配字符个数不会超过 $1$。对于此类情况，我们可以进行如下操作：首先在字符串首插入一个 `X`，在第一个非 `X` 字符后面插入一个 `X`，在第二个非 `X` 字符后面插入一个 `X`……直到插入完这 $2x_1+1$ 个 `X`。此时串长变成了 $Len+2x_1+1$，$x'_1=2x_1$。那么我们再计算一下匹配率之差：这里我们全用变量 $x_1$ 代替，原来的匹配率为 $\dfrac{x_1}{Len}$，现在为 $\dfrac{2x_1}{Len+2x_1+1}$，作差并观察分子：$2x_1Len-x_1Len-2x^2_1-x_1=x_1(Len-1)-2x^2_1=x_1(Len-2x_1-1)$。

我们不难知道，奇数串中，要想满足 $x_1=x_2$ 情况，必然有 $2x_1+1\leq Len$，故而上述作差大于等于零，所以此情况下偶数串**不劣于**奇数串。

综上所述，改变后的新字符串长度为偶数最佳。

为什么我们要费尽周折来证明这样一个东西呢？因为我们采用的算法过程需要。这里就可以开始介绍一下这个算法步骤了：首先答案的这个百分比进行二分，在二分的判断过程，我们采用 dp 方式进行判断。当我们枚举到某一位置 $i$ 的时候，如果其对应的无穷 `LR` 串的字符是 `L`，那么它的状态就是 $0$，如果是 `R`，那么状态就是 $1$。如果不摆放 `X`，那么上一位转移到这一位必然是 $0\to1,1\to0$，对应的状态值需要加上是否有 `L,R`，并减去百分比（因为是平均数，所以每个位置都要减去）。那如果前面放了 `X`，那么我们就需要再一次转移：$0\to 1,1\to 0$，同时由于添加了一个 `X`，需要减去百分比，只不过此时必须对答案取 $\max$。写成转移公式就是：
$$
\begin{matrix}
f[i][0] & = & f[i][1]+[s_i=\text{'L'}]-\bar{x} \\ 
f[i][1] & = & f[i][0]+[s_i=\text{'R'}]-\bar{x} \\ 
f[i][0] & = & \max \{f[i][0],f[i][1]-\bar{x}\} \\ 
f[i][1] & = & \max \{f[i][1],f[i][0]-\bar{x}\} \\
f[0][0] & = & -\bar{x} \\
f[0][1] & = & 0
\end{matrix}
$$
$f[0][0]$ 初始化为 $-\bar{x}$ 的原因是 $i=1$ 应当紧接 `L` 匹配，那么 $i=0$ 就应当是 `R` 匹配，而这里是 `L` 匹配，那么必然会添加一个 `X`。

前者转移不需要取，是因为其是必然发生的转移，后者取是需要保证答案更优。

而为什么至多只进行一次 `X` 的添加，这是因为前面我们已经处理好了相邻相同的情况，而证明中提到的更优解或者等价解都是在每个可能的字符前面至多添加一个 `X` 产生的，因此，多进行一次添加 `X` 的转移不会使答案更优。

而注意到我们提到在预处理过程中的首尾相接相同的情况的处理方式，其解释如下：

我们讨论 `L` 相邻的情况，对 `R` 同理。如果在最前面加上 `X`，根据特殊串 `L`，发现变成 `XL` 是不合理的，可以否定这个预操作（如果后期 dp 发现可以那是后期的事）。而可以直接放在最后而不影响解的最优化，原因如此：

如果发生我们提到过的情况，对于 $x_1>x_2$ 的情况显然这么做是可以的；但是对于 $x_1<x_2$ 的情况，我们前面仅提到在最前方加上一个 `X` 更优，但它不是最优，如图例：

![](https://cdn.luogu.com.cn/upload/image_hosting/szrkg4ko.png)

其实我们可以类似证明中提到的最后一种情况的操作，将所有的 `L` 和 `R` 都对应上，假设操作了 $v$ 次，那么此时的匹配率为：$\dfrac{x_1+x_2}{Len+v}$。减去最初的匹配率，看分子得到：$(x_1+x_2)(Len-v)$。由于我们至少可以保持第一个 `L` 前面不增加 `X`，那么一定会有 $Len\geq v$。而这种一一对应的情况必然有第一个 `L` 前面不添加 `X`，那么必须就有 `X` 添加在最后一个 `L` 之后。

对于 $x_1=x_2$ 的情况，其中的第一类可找到插入点的情况可以类似前面的方法使得可以添加一个 `X` 在最后，第二类不可找的情况就如同证明中所述的步骤，也能在最后添加一个 `X`。这些都能保证答案最优化不变。

至于奇偶串的情况，我们可以对放或不放这个 `X` 均做如此讨论，两种讨论奇偶不同，结果是一样的。

于是我们就不难写出代码了：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
const db eps = 1e-9;
const int maxn = 1e6+5;

db f[maxn<<1][2];
int n, tot;
char s[maxn], cg[maxn<<1];

bool check(db avg)//转移方程判断
{
    f[0][0] = -avg, f[0][1] = 0;
    for(int i = 1; i <= tot; i += 1)
    {
        f[i][0] = f[i-1][1] + (cg[i]=='L') - avg;
        f[i][1] = f[i-1][0] + (cg[i]=='R') - avg;
        f[i][0] = max(f[i][0], f[i][1]-avg);
        f[i][1] = max(f[i][1], f[i][0]-avg);
    }
    return f[tot][1]>=0;
}

int main()
{
    scanf("%s", s+1);
    n = strlen(s+1);
    if(s[1] == s[n] && s[1] == 'R')//首尾 R 相连，在前面放 X
        cg[++tot] = 'X';
    for(int i = 1; i <= n; i += 1)
    {
        if(s[i] == s[i-1] && s[i] != 'X')
            cg[++tot] = 'X';//相邻相同，中间插入 X
        cg[++tot] = s[i];
    }
    if(s[1] == s[n] && s[1] == 'L')//首尾 L 相连，在后面放 X
        cg[++tot] = 'X';
    db l = 0, r = 100;
    while(fabs(l-r)>eps)//二分百分比
    {
        db mid = (l+r)/2;
        if(check(mid/100))
            l = mid;
        else
            r = mid;
    }
    printf("%.6lf", (int)(r*1e6)/(1e6));//特殊处理，需与答案一致
    return 0;
}
```

该算法复杂度是 $O(n\log (eps)^{-1})$。不过这里精度判断没有 spj，所以需要一些特殊处理。

# 新思路

这个思路是 CF 上一位红名大佬 [$\color{red}\text{mkirsche}$](https://codeforces.com/profile/mkirsche) 在评论提到的，具体评论[点我](https://codeforces.com/blog/entry/331?#comment-289853)。下面是我的理解与阐释：

我们可以添加最少的 `X`，使得所有 `L` 和 `R` 到达能产生贡献的位置，并且是偶数串，如果此时的匹配率大于 $50\%$，那么我们就不断删掉两个 `X`，这些 `X` 满足其中夹着刚好一个匹配的 `L` 和 `R`，并且删去后不会发生 `LL` 相连或者 `RR` 相连的情况。最后得到的是一个最优串。

其实我们发现每次删去两个 `X`，它们之间的那个字符失配，但是也有两个失配字符被删去，其它字符匹配性不变。我们设原来匹配的字符个数为 $x$，那么原来的匹配率就是 $\dfrac{x}{Len}$，现在是 $\dfrac{x-1}{Len-2}$，后者减去前者，看分子有：$2x-Len$。也就是说，只有匹配率大于 $50\%$，我们这么操作才能增加匹配率。

关于这个思路正确性的讨论，其实可以类似于上面我们做的，对比前后的匹配率，讨论好所有情况即可。

这个算法复杂度是 $O(n)$ 的，相对更优，目前（2020.08.30）是洛谷提交最优，实现如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
const db eps = 1e-9;
const int maxn = 1e6+5;

db f[maxn<<1][2];
int n, tot, lst, mt, Xpos[maxn];
char s[maxn], cg[maxn<<1];

int main()
{
    scanf("%s", s+1);
    n = strlen(s+1);
    if(s[1] == s[n] && s[1] == 'R')
        cg[++tot] = 'X';
    mt = 0;//看有目前处于第几个非 X 的字符
    for(int i = 1; i <= n; i += 1)
    {
        if(s[i] == s[i-1] && s[i] != 'X')
            cg[++tot] = 'X';//必须要加的 X 后面不可删
        if(tot+1&1 && s[i] == 'R' || !(tot+1&1) && s[i] == 'L')
            cg[++tot] = 'X', Xpos[++lst] = mt;//可以删的 X 位置需要记录
        cg[++tot] = s[i];
        if(s[i] != 'X')
            mt += 1;
    }
    if(s[1] == s[n] && s[1] == 'L')
        cg[++tot] = 'X';
    if(tot & 1)//变成偶数序列，与我们前面证明的一致
    {
        cg[++tot] = 'X';
        if(s[1] != s[n])//包括 XL,XR 相邻的情况也要记录
            Xpos[++lst] = mt;
    }
    int matched = 0, fail = 0;
    for(int i = 1; i <= tot; i += 1)//统计匹配与失配字符
    {
        if(cg[i] != 'X')
            matched += 1;
        else
            fail += 1;
    }
    for(int i = 1; i <= lst; i += 1)
    {
        if(matched <= fail)
            break;
        if(Xpos[i] + 1 == Xpos[i+1])//中间只间隔一个 L 或者 R，就可以删
            matched -= 1, fail -= 1, i += 1;
    }
    long long rat = (long long)matched*100000000/(matched+fail);
    printf("%.6lf", rat/1e6);
    return 0;
}
```

# 总结

两个解答方式对比，第一个其实是像 [$\color{red}\text{YLWang}$](https://www.luogu.com.cn/user/55078) 的[题解](https://www.luogu.com.cn/blog/YLWang/solution-cf11e)所说的，类似于 $01$ 规划的方式进行二分答案求解。但是其约束就在于需要证明偶数串可行。然而在证明的过程中我们可以发现这其中具有可以贪心的性质，也就是先将其可匹配的部分匹配上，然后再去进行修正操作。而这样一来，我们的复杂度就降低了一个 $\log$，是更优的解法。我觉得 codeforces 向来不太卡常，这题 1s+1e6 估计也是想用这种方法来考验我们的，所以正解应该是后者。

通过写此题题解，让我对算法又深入理解与体会，也希望能帮助大家深入感受一下这道题的优秀之处。

---

## 作者：18Michael (赞：10)

## 题意

给定一个仅由 $L,R,X$ 组成的模式串和 $LR$ 交替组成的无限长的文本串，要求在模式串中添加一些 $X$，使得模式串中任意两个相同的相邻字符（首尾两个也算相邻）均为 $X$，同时将修改后的模式串复制一遍得到的新模式串与文本串前缀相同的字符数除以新模式串长度最大，输出这个最大值。

## 题解

[YLWang](https://www.luogu.com.cn/user/55078) 的题解思路很清晰，我主要是来补个证明。

首先将任意两个相同的相邻字符（且不为 $X$）之间添加一个 $X$。

这时候就有一个问题，首尾两个字符之间有两个位置可以添加。

结论 $1$：如果首尾字符均为 $L$，那么添加一个 $X$ 在最后；否则添加一个 $X$ 在最前。

证明最后给出。

------------

结论 $2$：修改后的模式串串长为偶数时的最大值即为答案。

证明：假设答案最大时修改后的模式串串长为奇数，那么答案即为「修改后的模式串中 $L,R$ 字母个数和」除以「修改后的模式串长度的两倍」。

如果第一次和第二次对答案的贡献不同，我们可以在开头或结尾添加一个 $X$ 使得答案变为「第一次和第二次答案的较大值」除以「修改后的模式串长度 $+1$」，这显然比上面要大，矛盾。

所以两次的答案相同，又由于此时一个字符在将修改后的模式串复制一遍得到的新模式串中对答案恰好只会贡献一次，即该模式串中共有偶数个 $L,R$，有奇数个 $X$。

现在把该模式串中 $L,R$ 的位置看作 $0,1$，分别表示该模式串中这位与文本串前缀不同/相同。

那么每添加一个 $X$ 就相当于对模式串之后的位置全异或上 $1$。

我们按照这种方式让模式串最后所有数字的位置都为 $1$，这至多需要「模式串中 $L,R$ 字母个数」步。

如果最后模式串长为奇数，我们在最后强行加上一个 $X$，此时答案至少为「修改后的模式串中 $L,R$ 字母个数和」除以「修改后的模式串长度 $+$ 模式串中 $L,R$ 字母个数 $+$ 1」，而该模式串中有奇数个 $X$，也就是至少有一个 $X$，那么「修改后的模式串长度 $+$ 模式串中 $L,R$ 字母个数 $+$ 1」不大于「修改后的模式串长度的两倍」，即现在的答案不劣于之前的答案，得证。

------------

然后就可以二分答案 $mid$ 设计 dp，具体而言，设 $f_{i,0/1}$ 表示当前匹配到原串的第 i 位，且当前位教官的命令是 $R/L$ 时的最大值。

转移（按顺序进行）：

$f_{i,0}=f_{i,1}+[s_i=R]-mid$

$f_{i,1}=f_{i,0}+[s_i=L]-mid$

$f_{i,0}=max(f_{i,0},f_{i,1}-mid)$

$f_{i,1}=max(f_{i,1},f_{i,0}-mid)$

边界是 $f_{0,0}=0,f_{0,1}=-mid$，答案可行当且仅当 $f_{len,0}\ge0$。

------------

于是我们就可以给出结论 $1$ 的证明了。

证明：举首尾字母均为 $L$ 为例（$R$ 同理），此时在最后面放一个 $X$ 一定是最优的。

首先，最前面与最后面的地方 $X$ 的个数只可能为 $1$ 或 $2$，因为为 $0$ 不符题意，大等于 $3$ 时必有两个 $X$ 在同一地方（最前或最后），把它们一起删去答案更优。

如果最后面有 $X$ 了，那就符合我们的结论，因此我们考虑最后面没有 $X$ 的情况，即最前面有 $1$ 或 $2$ 个 $X$。

1. 最前面有 $2$ 个 $X$，那把它们删去并加到最后面依旧符合题意且答案不变。

2. 最前面有 $1$ 个 $X$，那么我们计算一下到第一个 $L$ 时的 dp 值。

假设去掉这个 $X$，第一位即为第一个 $L$，此时 
$f_{0,0}=0,f_{0,1}=-mid,f_{1,0}=1-2mid,f_{1,1}=1-mid$。

假设保留这个 $X$，第一位为 $X$，第二位为第一个 $L$，此时 
$f_{0,0}=0,f_{0,1}=-mid,f_{1,0}=-2mid,f_{1,1}=-mid,f_{2,0}=1-4mid,f_{2,1}=1-3mid$。

可以发现此时第一个 $L$ 的位置上仅仅是 dp 值同时减小 $2mid$，而相对之间的差不变，不影响后面的转移。

因此到最后时，保留 $X$ 比去掉 $X$ 的两个 dp 值都小了 $2mid$，再算上去掉 $X$ 之后最后还应补一个 $X$ 的影响，保留 $X$ 比去掉 $X$ 的两个 dp 值还是都小了 $mid$，因此去掉 $X$（即把 $X$ 调到最后）之后二分答案可以二分的更大，得证。

## Code
```cpp
#include<cstdio>
#include<cstring>
#define eps 1e-9
int len=0,len1;
double l=0,r=100,mid;
char s[2000002],s1[1000002];
double f[2000002][2];
inline double max(double x,double y)
{
	return x>y? x:y;
}
inline bool check(double x)
{
	f[0][0]=0,f[0][1]=-x;
	for(int i=1;i<=len;++i)
	{
		f[i][0]=f[i-1][1]+(s[i]=='R')-x;
		f[i][1]=f[i-1][0]+(s[i]=='L')-x;
		f[i][0]=max(f[i][0],f[i][1]-x);
		f[i][1]=max(f[i][1],f[i][0]-x);
	}
	return f[len][0]>=0;
}
int main()
{
	scanf("%s",s1+1),len1=strlen(s1+1);
	if(s1[1]=='R' && s1[len1]=='R')s[++len]='X';
	s[++len]=s1[1];
	for(int i=2;i<=len1;++i)
	{
		if(s1[i]!='X' && s1[i]==s1[i-1])s[++len]='X';
		s[++len]=s1[i];
	}
	if(s1[1]=='L' && s1[len1]=='L')s[++len]='X';
	while(r-l>eps)
	{
		mid=(l+r)/2;
		if(check(mid/100))l=mid;
		else r=mid;
	}
	return 0&printf("%.6lf",(int)(r*1000000)/1000000.0);
}
```


---

## 作者：miaokehao (赞：2)

我使用的是二分答案，我们可以假定答案为mid

那么我们可以把mid当成一个数，每次伸长指令序列都要-mid

最后只需要用dp判断dp[len][0];

具体看代码

```
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(4)
#include <bits/stdc++.h>
#define res register int
#define ll long long
#define N 2005000
#define eps 1e-9
using namespace std;
char s[N];
string t;
double f[N][2];
int len;
int main()
{
  scanf("%s",s);
  len=strlen(s);
  for(res i=0; i<len; i++)
  {
    t+=s[i];
    if(s[i]!='X'&&i+1<len&&s[i]==s[i+1])
      t+='X';
  }
  if(s[0]!='X'&&s[0]==s[len-1])
  {
    if(s[0]=='L') t+='X';
    else t="X"+t;
  }
  len=t.size();
  register double l=0,r=1;
  while(r-l>eps)
  {
    register double mid=(l+r)/2.0;
    f[0][0]=0.0,f[0][1]=-mid;
    for(res i=0; i<len; i++)
    {
      f[i+1][0]=f[i][1]-mid;
      f[i+1][1]=f[i][0]-mid;
      if(t[i]!='X')
      {
        if(t[i]=='L')
          f[i+1][1]=max(f[i+1][1],f[i][0]+1-mid);//成功匹配
        else
          f[i+1][0]=max(f[i+1][0],f[i][1]+1-mid);
      }
      f[i+1][0]=max(f[i+1][0],f[i+1][1]-mid);//加上一个'X'
      f[i+1][1]=max(f[i+1][1],f[i+1][0]-mid);
    }
    if(f[len][0]>0)
      l=mid;
    else
      r=mid;
  }
  int x=(l+eps)*1e8;//专业卡精度
  printf ("%d.%06d\n", x / 1000000, x % 1000000);
  return 0;
}
```

---

## 作者：黑影洞人 (赞：1)

题意：

>将题目给的字符串复制一遍，接到原本字符串的后面，然后在相邻且相同的字符中间加上 `X` 再在链接的地方加上 `X`。求再在任意地方加 `X` ，使得 `L` 在奇数位置，`R` 在偶数位置的数量和最多，求出这个数量和并且除以最终串的长度，精度 $10^{-6}$

约定：当`L` 在奇数位置，`R` 在偶数位置时我们称该字符匹配。

我们考虑二分答案。每次二分一个概率 $P$ 对于每次操作，减去 $P$。因为如果有 $\geq P\times len$ 个字符位置匹配，那么匹配的字符首先满足是 `L` 或 `R` 。

于是在统计是否满足判断大小的时候，先要统计出匹配的字符数量，在减去 $P\times len$ 然后再判断大小。

于是可以写出一个线性 DP ;

$dp_{i,0/1}$ 表示字符串的第 $i$ 位，字符为 $0(R),1(L)$ 的总匹配数减去概率乘以当前长度。

操作1：不移位置
$$\begin{cases} 
	dp_{i,0}=dp_{i-1,1}+checkL(i)-P \\ 
	dp_{i,1}=dp_{i-1,0}+checkR(i)-P \\ 
\end{cases}
$$

操作2：移动
$$\begin{cases} 
	dp_{i,0}=max(dp_{i,0},dp_{i,1}-P) \\ 
	dp_{i,1}=max(dp_{i,1},dp_{i,0}-P) \\ 
\end{cases}
$$

最后二分一下求出答案即可。


---

## 作者：XL4453 (赞：1)

### $\text{Difficulty : 2800}$
---
### 解题思路：

首先对于给出的串进行一些初步的处理，题目中给出的串不一定是正确的，先将所有不可能的情况补全成可行情况是必要的。

需要注意，这个行走的串是循环的，所以最后一个和第一个其实是连在一起的，需要在前面或者后面加一个停顿。如果前后都是 $R$ 则将停顿加到最前面，都是 $L$ 就加到最后面。

---

由于分母会随着操作进行变动，直接用动态规划求解并不好做，可以考虑先二分出一个答案，然后同构每一步减去这个答案转化成判定性问题。

转化后的问题也就是每一步会减少一个权值，如果匹配成功获得一个单位的权值，求最大权值。

设 $f_{i,j}$ 表示考虑到原来串的第 $i$ 个位置，且下一个位置上列队中的其它人的动作为 $j$，$j$ 为 $0$ 或者 $1$，分别表示左和右。

然后考虑转移，对于一个位置，理论上可以在这个位置之前加上任意多个停顿，但是很显然的是一旦加上了超过 $1$ 次就一定不优。所以只考虑加或者不加两种情况即可。

形式化的，有：$f_{i,t}=max(f_{i-1,\lnot t}+[a_i=t]-mid,f_{i-1,t}+[a_i=\lnot t]-2\times mid)$。

前者表示不加，后者则是表示增加一个停顿。

初值是 $f_{0,0}=-mid,f_{0,1}=0$。

---
注意最后的答案需要向上取值。

---
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2000000;
int s[MAXN+5],n;
double f[MAXN+5][2],l,r,mid;
/*
0-L
1-R
2-X
*/
string S;
inline double max(double x,double y){
	if(x>y)return x;
	return y;
}
inline bool check(double num){
	f[0][0]=-num;f[0][1]=0;
	for(int i=1;i<=n;i++){
		f[i][0]=max(f[i-1][0]+(s[i]==1)-2.0*num,f[i-1][1]+(s[i]==0)-num);
		f[i][1]=max(f[i-1][1]+(s[i]==0)-2.0*num,f[i-1][0]+(s[i]==1)-num);
	}
	return f[n][1]>=0;
}
int main(){
	cin>>S;
	if(S[0]==S[S.length()-1]&&S[0]=='R')s[++n]=2;
	if(S[0]=='X')s[++n]=2;if(S[0]=='L')s[++n]=0;if(S[0]=='R')s[++n]=1;
	for(int i=1;i<S.length();i++){
		if(S[i]=='X')s[++n]=2;
		if(S[i]=='L'){
			if(S[i-1]=='L')s[++n]=2;
			s[++n]=0;
		}
		if(S[i]=='R'){
			if(S[i-1]=='R')s[++n]=2;
			s[++n]=1;
		}
	}
	if(S[0]==S[S.length()-1]&&S[0]=='L')s[++n]=2;
	l=0;r=100;
	while(r-l>=1e-9){
		mid=(l+r)/2;
		if(check(mid/100))l=mid;
		else r=mid;
	}
	printf("%.6lf",(int)(r*1000000)/1000000.0);
	return 0;
}
```


---

## 作者：cxoi1610 (赞：0)

我使用的是二分答案，我们可以假定答案为 $mid$。

那么我们可以把 $mid$ 当成一个数，每次伸长指令序列都要减掉 $mid$。

最后只需要用 dp 就可以了。


```cpp
#include <bits/stdc++.h>
#define res register int
#define eps 1e-9
using namespace std;
char s[2000010];
string t;
double f[2000010][2];
int len;
int main()
{
	  scanf("%s",s);
	  len=strlen(s);
	  for(res i=0; i<len; i++)
	  {
	    t+=s[i];
	    if(s[i]!='X'&&i+1<len&&s[i]==s[i+1])
	      t+='X';
	  }
	  if(s[0]!='X'&&s[0]==s[len-1])
	  {
	    if(s[0]=='L') t+='X';
	    else t="X"+t;
	  }
	  len=t.size();
	  register double l=0,r=1;
	  while(r-l>eps)
	  {
	    register double mid=(l+r)/2.0;
	    f[0][0]=0.0,f[0][1]=-mid;
	    for(res i=0; i<len; i++)
	    {
	      f[i+1][0]=f[i][1]-mid;
	      f[i+1][1]=f[i][0]-mid;
	      if(t[i]!='X')
	      {
	        if(t[i]=='L')
	          f[i+1][1]=max(f[i+1][1],f[i][0]+1-mid);
	        else
	          f[i+1][0]=max(f[i+1][0],f[i][1]+1-mid);
	      }
	      f[i+1][0]=max(f[i+1][0],f[i+1][1]-mid);
	      f[i+1][1]=max(f[i+1][1],f[i+1][0]-mid);
	    }
	    if(f[len][0]>0)
	      l=mid;
	    else
	      r=mid;
	  }
	  int x=(l+eps)*1e8;
	  printf ("%d.%06d\n", x / 1000000, x % 1000000);
}
```

---


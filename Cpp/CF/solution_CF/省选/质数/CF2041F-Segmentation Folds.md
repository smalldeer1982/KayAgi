# Segmentation Folds

## 题目描述

Peter 喜欢折线段玩。有一条线段位于数轴上的区间 $[\ell, r]$。现如今正是折叠线段的好时机，Peter 决定小心翼翼地对这条线段进行折叠。每次操作中，他可以选择以下两种方式之一（在可能的情况下）：

1. 操作 $\tt{LTR}$：他从左向右折线段，使得左端点 $\ell$ 与某个点 $x$ 重合（$\ell < x \le r$），并且 $\ell + x$ 是质数。当他选择此操作时，总是选取最大的 $x$ 值。折叠后，线段所在的区间变为 $[\frac{1}{2}(\ell + x), r]$。
   
2. 操作 $\tt{RTL}$：他从右向左折线段，使得右端点 $r$ 与某个点 $x$ 重合（$\ell \le x < r$），并且 $r + x$ 是质数。当他选择此操作时，总是选取最小的 $x$ 值。折叠后，线段所在的区间变为 $[\ell, \frac{1}{2}(r + x)]$。

一个折叠序列是指这两种操作的组合。Peter 想要通过多次折叠，使线段的长度尽可能短，且无法再缩短。区间的长度自然定义为 $r - \ell$。考虑以下例子：假设我们折叠一段初始为 $[1, 30]$ 的线段。有三种折叠方式能使最终区间长度最短，如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041F/be032bc113ac39f401b84d34f2c5f31947b110d1.png)

请你帮助 Peter 确定有多少种不同的折叠序列可以使线段达到最短长度。结果需要对 $998244353$ 取模。

注：一个大于 $1$ 的整数 $p$ 是质数，当且仅当不存在整数 $a, b > 1$ 使得 $p = ab$。

## 样例 #1

### 输入

```
3
1 30
16 18
142857 240135```

### 输出

```
3
1
63```

# 题解

## 作者：沉石鱼惊旋 (赞：0)

## F. Segmentation Folds

给定 $[l,r]$，你需要选择以下操作任一执行：

- 选择一个最大的 $x(l\lt x\leq r)$ 满足 $l+x$ 是质数，$[l,r]\to [\frac{1}{2}(l+x),r]$。

- 选择一个最小的 $x(l\leq x\lt r)$ 满足 $r+x$ 是质数，$[l,r]\to [l,\frac{1}{2}(r+x)]$。

如果这个区间 $[l,r]$ 无法操作，则称这个区间为一个结束状态。否则继续递归。

问所有结束状态中，长度最小的有多少个。答案对 $998244353$ 取模。

多测，$1\leq t\leq 10$。

$1\leq l\lt r\leq 10^{12}$，$r-l\leq 10^5$。

---

为了规避浮点问题，我们把所有区间的 $l,r$ 都乘上 $2$。

我们首先要把 $[2l,2r]$ 之间的素数都筛出来。我们先预处理到 $\sqrt{2r}$ 的所有质数，然后把这些质数在 $[2l,2r]$ 内的倍数筛出来。具体参见 [P1835 素数密度](https://www.luogu.com.cn/problem/P1835)。

然后大力搜索即可。

搜索的时候可以通过二分找到第一个和最后一个合法的 $x$。但是这样复杂度多带一个 $\log$。我们把二分的内容拎出去，在预处理完质数之后，枚举所有的情况找到上一个下一个质数。

搜索的结束状态一定是两个相邻的质数。只有 $\mathcal O(\frac{n}{\log n})$ 个。而每个状态只有 $\mathcal O(\log n)$ 个前驱状态，所以直接搜索甚至不带记忆化的复杂度是 $\mathcal O(n)$ 的。

总复杂度瓶颈在筛质数的 $\mathcal O(n\log \log n)$。

代码写的有点丑了，丑在了：

>我们把二分的内容拎出去，在预处理完质数之后，枚举所有的情况找到上一个下一个质数。

这一部分。写的是二分，如果写双指针最后复杂度就是 $\mathcal O(n\log \log n)$。这份代码是 $\mathcal O(n\log n)$ 的。 

<https://codeforces.com/contest/2041/submission/294604119>

---


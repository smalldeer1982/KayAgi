# Game With String

## 题目描述

Alice和Bob在玩一个游戏，最初他们有一个字符串$s_1,s_2……,s_n$,只由X和.组成。他们轮流行动，Alice先手。每一轮，玩家选择一个只由.组成的字串，将它全都改为X。Alice必须选择度为a的字串，Bob必须选择度为b的字串，保证a>b。

举个例子，如果S=...X..，a=3,b=2,那么Alice只能把它变为XXXX...，如果Bob行动可能可以变为XX.X.., .XXX.. 或 ...XXX.

谁先不能行动谁就输了。假设他们都聪明绝顶，请你来预测谁会赢。

你要回答q组询问。

## 样例 #1

### 输入

```
3
3 2
XX......XX...X
4 2
X...X.X..X
5 3
.......X..X
```

### 输出

```
YES
NO
YES
```

# 题解

## 作者：ljc20020730 (赞：8)

首先，对于一个连续的`.`序列我们将其分离出来考虑。

这样，我们就得到若干个**互相独立**的小线段。

我们尝试将这些小线段分类，设其长度为$l$：

1. 双方都不能操作的**无用**线段，当且仅当$l < b$
2. 仅可能后手操作的线段，而先手不能操作，当且仅当$ b \leq l < a $
3. 先手和后手都只能操作$1$次的线段，当且仅当$a \leq l < 2b $
4. 其他线段，$l \geq 2b$

> 引理$1$ ： 如果存在$1$条及以上的$2$类线段，那么先手必输。

后手至少可以比先手多$1$个额外的能够操作的地方，如果后手某一次不能在其他地方操作了，他可以在$2$类线段上操作，而先手不能。如果此时先手仍能操作，那么之前后手必然不会去使用这些$2$类线段。

> 引理$1$的推论  ： 如果存在$2$条及以上的$4$类线段，那么先手必输。

首先，后手可以有$1$步的代价将$1$条$4$类线段变成$2$类线段，即只在前部分保留一段长为$l' \in [b,a)$的线段。显然，先手在比后手优势在可以先行动，他最多只能化解$1$次这样的情况。如果$4$号线段数目大于等于$2$那么先手就必输了。

> 引理$2$ ： 若无$2,4$线段,如果$3$线段的数目为奇数，先手必胜，否则先手必败。

由于$1$号线段是无用线段，所以本引理显然成立。

利用上述结论，现在我们所需要处理的是先手能否将$1$条$4$线段做一次操作让后手必败。

显然，这样的操作只要存在，那么先手必胜，否则先手必败。

我们可以用$O(n)$的时间复杂度来枚举先手将这条长为$l\geq 2b$的线段分成$t1 , t2$两部分的可能性，使得切分完毕后不存在$2,4$线段，且存在**偶数个**$3$线段。

所以本题的时间复杂度为$O(n)$


代码奉上。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
int a, b;
char s[N];
vector<int> v;
bool work() {
    int cnt = 0, ret = 0, len;
    int sz = v.size();
    for (int i = 0; i < sz; i++) {
        if (v[i] >= b && v[i] < a)
            return false;
        if (v[i] >= 2 * b)
            cnt++, len = v[i];
        if (v[i] >= a && v[i] < 2 * b)
            ret++;
    }
    if (cnt > 1)
        return false;
    if (!cnt)
        return (ret & 1);
    for (int i = 1; i <= len - a + 1; i++) {
        int t1 = i - 1, t2 = len - i - a + 1;
        if (t2 >= 2 * b || t1 >= 2 * b || (t1 >= b && t1 < a) || (t2 >= b && t2 < a))
            continue;
        int add = (t1 >= a && t1 < 2 * b) + (t2 >= a && t2 < 2 * b);
        if ((ret + add) % 2 == 0)
            return true;
    }
    return false;
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d%s", &a, &b, s);
        v.clear();
        int n = strlen(s);
        for (int i = 0; i < n; i++) {
            if (s[i] == 'X')
                continue;
            int j = i;
            while (s[j] == '.' && j < n) j++;
            j--;
            v.push_back(j - i + 1);
            i = j;
        }
        puts(work() ? "YES" : "NO");
    }
    return 0;
}
```

---

## 作者：Purple_wzy (赞：4)

~~一道需要一点思维量的博弈题~~。。

有以下几个结论可以明显地得出：
### 1.当存在长度为[b,a)的区间时，先手必败。
### 2.当先手操作一次后，若存在长度为[2b,INF)的区间，同样先手必败。

因此，先将得到的所有区间长度进行排序，之后先手处理长度最大的那个区间，

并将那个区间分成两个长度和为（原长-a)的区间。

若不管怎么操作都存在长度大于等于2b的区间，先手必败。

于是我们枚举这两个区间的长度。每次枚举，将所有长度为[a,2b)的区间记为

“有效区间”，根据“有效区间”的个数的奇偶，可判断是先手必胜还是先手必败。

只要有一个先手必胜的情况，那么先手必胜。

代码就不贴了~


---


# Cheops and a Contest (Easy Version)

## 题目描述

这是问题的简单版本。在这个版本中，$m$ 固定为 $2$。只有解决了问题的所有版本后，你才能进行 hack。

在古埃及有一场问题解决比赛，参赛者有 $n$ 名，编号从 $1$ 到 $n$。每位参赛者来自一个特定的城市，城市的编号从 $1$ 到 $m$。保证每个城市至少有一名参赛者。

每位参赛者拥有力量 $a_i$，专长 $s_i$，以及智慧 $b_i$，并且 $b_i \ge a_i$。比赛中的每个问题都有一个难度 $d$ 和一个独特的主题 $t$。如果满足以下条件之一，第 $i$ 位参赛者可以解决这个问题：

- $a_i \ge d$，即参赛者的力量大于或等于问题的难度；
- $s_i = t$ 并且 $b_i \ge d$，即参赛者的专长等于问题的主题，同时智慧不低于问题的难度。

Cheops 的愿望是设计一组问题，使得来自城市 $i$ 的每位参赛者比来自城市 $j$ 的每位参赛者解决更多的问题，且 $i < j$。

请找到一个不超过 $5n$ 个问题的集合，其中所有问题的主题各不相同，能够满足 Cheops 的愿望，或者说明这个愿望无法实现。

## 样例 #1

### 输入

```
2
5 2
5 7 1
6 7 2
3 9 2
5 10 3
4 4 1
2 1 2
3 3 4 5
2 2
1 2 1
1 2 1
1 2
1 1```

### 输出

```
7
6 4
6 5
5 6
5 7
4 8
4 9
7 1
-1```

# 题解

## 作者：int08 (赞：1)

## 前言
本题最大难点：要发现它比 D 简单很多。

可能所有难度逆序对的题目都存在后者虚高的情况！

~~啊早知道来打这场 CF 了。~~

## 题意

$n$ 个人属于 $m$ 个队伍（简单版中 $m=2$），每个人有能力值 $a_i$、智慧值 $b_i$、特长 $s_i$，保证 $b_i\ge a_i$。

对于一道题，有难度 $d$ 和主题 $t$，如果一个人的能力大于等于该题难度或者在特长等于题目主题的情况下智慧值大于等于难度（$a\ge d \vee(s=t\wedge b\ge d)$），这个人就能做出这道题。

构造一个不超过 $5n$ 道题目的试卷（或报告无解），（简单版中）使得 $1$ 队中任意一个人做出的题目数严格多于 $2$ 队中任何一个人，并且**题目的主题两两不同**。

# Solution

乍一看没什么思路，但是有一个很有意思的限制：主题两两不同，它给我们带来了两个信息：

1. 每个人通过特长最多只能建立一道题的优势。
2. 有很大一部分题目都是不对应任何人的特长的。

不对应任何人特长的题目（以下称为基础题）只和每个人能力值有关，比较简单，先考虑。

假设 $1$ 队中最小的 $a_i$ 为 $amn_1$，$2$ 队中最大的 $a_i$ 为 $amx_2$，我们完全可以考虑在 $amn_1$ 和 $amx_2+1$ 位置放上大量的基础题，这样直接就使得大于 $amx_2$ 的 $1$ 队选手和小于 $amn_1$ 的 $2$ 队选手不会影响结果，可以光荣或者遗憾离场了。

事实上不需要大量，由于结论 $1$，各放两道基础题即可。

然后又发现一个惊人的事实：

3. $[amn_1+1,amx_2]$ 之间不能有基础题！

否则 $2$ 队里 $a$ 最大的已经比 $1$ 队里 $a$ 最小的多做一道了，根据结论 $1$，后者最多救一道回来也是打平，已经没救了。

那么说明基础题已经没得放了，考虑对应了特长的题目吧（以下称为区分题）。

发现除去上文已经离场的选手，剩下的人做出的题目数完全一样，每个 $1$ 队的人都需要通过区分题确立优势。

那么对于同种特长的选手，$1$ 队的所有人 $b$ 应当严格大于所有 $2$ 队的，否则无法确立优势。

够了吗？还不够。$1$ 队的所有人 $b$ 还应该严格大于 $amx_2$，否则虽然在同种特长的人确立优势了，却被那个的 $2$ 队老哥解掉，之后由于不存在对自己有利的区分题，再也无法对那个老哥确立优势了。

这下确实充要了，按照题意构造即可，由于上界很松，构造是简单的。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 308555
int T,n,i,a[N],b[N],s[N],bel[N],x,y;
unordered_map<int,int> m;
unordered_map<int,bool> m2;
int find_new()
{
	int x=(rand()*32768+rand())%1000000001;
	while(m2[x]) x=(rand()*32768+rand())%1000000001;
	m2[x]=1;
	return x;
}
vector<pair<int,int> > ans;
int amx,amn;
void solve()
{
	amx=-1,amn=1e9+1;ans.clear(),m.clear(),m2.clear();
	cin>>n>>x;
	for(i=1;i<=n;i++) cin>>a[i]>>b[i]>>s[i],m2[s[i]]=1;
	for(i=1;i<=2;i++)
	{
		cin>>y;
		while(y--) cin>>x,bel[x]=i;
	}
	for(i=1;i<=n;i++) if(bel[i]==1) amn=min(amn,a[i]);
	else amx=max(amx,a[i]);
	if(amx==1000000000)
	{
		cout<<"-1\n";
		return;
	}
	for(i=1;i<=2;i++) ans.push_back({amx+1,find_new()}),ans.push_back({amn,find_new()});
	for(i=1;i<=n;i++) if(bel[i]==2&&a[i]>=amn) m[s[i]]=max(m[s[i]],b[i]);
	for(i=1;i<=n;i++) if(bel[i]==1&&a[i]<=amx)
	{
		if(m.find(s[i])==m.end()) m[s[i]]=-1;
		if(b[i]<=max(amx,m[s[i]]))
		{
			cout<<"-1\n";
			return;
		}
	}
	for(auto x:m) ans.push_back({max(x.second,amx)+1,x.first});
	cout<<ans.size()<<"\n";
	for(auto x:ans) cout<<x.first<<" "<<x.second<<"\n";
}
int main()
{
	srand(20080506);
	cin.tie(0)->sync_with_stdio(0),cout.tie(0);
	cin>>T;
	while(T--) solve();
}
```
# The End.

---


# Andryusha and CCB

## 题目描述

我们定义一个二进制字符串 $z$ 的**美感值**为满足 $1 \le i < |z|$ 且 $z_i \neq z_{i+1}$ 的索引 $i$ 的数量。

在等待 CCB 的朋友们到来时，Andryusha 烤了一个馅饼，表示为一个长度为 $n$ 的二进制字符串 $s$。为了避免冒犯任何人，他想要将这个字符串分割成 $k$ 个子字符串，使得每个字符属于恰好一个子字符串，且所有子字符串的美感值相同。

Andryusha 不知道会有多少 CCB 的朋友来他家，因此他希望找出满足条件的所有 $k$ 值的数量。然而，他的兄弟 Tristan 认为这个问题的表述过于简单。因此，他要求你为字符串的每个前缀找出这样的 $k$ 值的数量。换句话说，对于每个 $i$（从 $1$ 到 $n$），你需要找出满足可以将前缀 $s_1 s_2 \ldots s_i$ 分割成恰好 $k$ 个具有相同美感值的子字符串的 $k$ 值的数量。

## 说明/提示

第三个测试案例中，满足条件的 $k$ 值为：

1. $i = 1$: $k \in \{1\}$，
2. $i = 2$: $k \in \{1, 2\}$，
3. $i = 3$: $k \in \{1, 2, 3\}$，
4. $i = 4$: $k \in \{1, 3, 4\}$，
5. $i = 5$: $k \in \{1, 2, 4, 5\}$，
6. $i = 6$: $k \in \{1, 5, 6\}$，
7. $i = 7$: $k \in \{1, 5, 6, 7\}$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
5
00011
10
0101010101
7
0010100```

### 输出

```
1 2 3 4 5
1 2 2 3 2 4 2 4 3 4
1 2 3 3 4 3 4```

# 题解

## 作者：w9095 (赞：4)

[CF2092F Andryusha and CCB](https://www.luogu.com.cn/problem/CF2092F)

CF 官解感觉跳了很多步啊，自己写一篇造福后人。

首先肯定是不能直接求的，考虑转化贡献体。对划分的段数转化贡献依旧不好求，考虑对每个子串的美感度转化贡献，即先枚举每个子串的美感度。

然后发现这样枚举是非常优异的。首先，划分子串不能增加总的美感度，而划分 $c$ 段至多减少 $c-1$ 的美感度。于是随着美感度 $k$ 在枚举中增加，可划分的子串数量在减少。假设总的美感度为 $x$，对于 $k$ 能划分的子串数量是 $O(\frac{x}{k})$ 级别的。根据调和级数知识，我们枚举划分的段数时间复杂度是 $O(n\log n)$ 的。

其次，这样一定不会算重，即对于每个前缀，每个划分的段数只会在一个 $k$ 里被计算。假设对于某个前缀某个划分的段数 $c$ 在两个不同的 $k_1,k_2$ 中被计算，不妨设 $k_1\lt k_2$。则至少需要划分 $c(k_2-k_1)+1$ 段才能减少足够的美感度以满足总美感度相同，因为 $k_2-k_1\gt 0$，所以 $c(k_2-k_1)+1\gt c$，矛盾，故不会算重。

然后我们考虑每一对 $(k,c)$ 的贡献。现在我们只关心 $0$ 和 $1$ 交界的地方，因为只有这里能产生美感度。因此，我们把序列改写成极长的 $0$ 或 $1$ 连续段，每个元素代表一个连续段。这样写的好处是相邻元素一定会贡献 $1$ 点美感度。以下下标均指改写后的序列，从 $1$ 开始。

直接求也是不好做的，于是我们考虑递推。如果 $c=1$，显然只有 $k+1$ 结尾的前缀满足要求。如果 $c=2$，直接把后面 $k+1$ 个元素作为下一段就行，是 $2k+2$ 结尾的前缀。特别的，如果 $k+1$ 号元素长度大于 $1$，我们可以考虑然后后面的前缀延伸进 $k+1$ 号元素，这样 $2k+1$ 结尾的前缀也满足条件。

这启发我们考虑贡献的连续性。具体的，如果 $c-1$ 的贡献区间是 $[l,r]$，考虑递推 $c$ 的贡献区间。同上所述，$[l+k+1,r+k+1]$ 一定是可以的。想要延长这一区间，我们只需要考虑 $l+k+1$ 这一边界，因为其他前缀减 $1$ 后已经被包含。如果第 $l$ 号元素长度大于 $1$，可以让第 $c$ 个子串延伸进第 $l$ 号元素，所以 $l+k$ 结尾的前缀可以取到。

最后，我们记录每一个极长连续段的左边界和右边界，差分做区间加即可。

注意 $k=0$ 的时候需要特别计算。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long t,n,a[2000000],b[2000000],l[2000000],r[2000000],ans[2000000];
int main()
{
	scanf("%lld",&t);
	while(t--)
	   {
	   	scanf("%lld",&n);
	   	long long m=0;
	   	for(int i=1;i<=n;i++)
	   	    {
	   	    scanf("%1lld",&a[i]);
			if(i==1||a[i]!=a[i-1])b[++m]=1,l[m]=r[m]=r[m-1]+1;
			else b[m]++,r[m]++;
			}
		for(int i=0;i<=n+1;i++)ans[i]=0;
		for(int i=1;i<m;i++)
		    {
		    long long pl=i+1,pr=i+1;
		    ans[l[pl]]++,ans[r[pr]+1]--;
		    for(int j=2;j<=m/i;j++)
		        {
				if(b[pl]==1)pl=pl+i+1,pr=pr+i+1;
				else pl=pl+i,pr=pr+i+1;
				if(pr>m&&pl<=m)ans[l[pl]]++,ans[r[m]+1]--;
				else if(pr<=m)ans[l[pl]]++,ans[r[pr]+1]--;
				}
			}
		for(int i=1;i<=n;i++)ans[i]+=ans[i-1];
		for(int i=1;i<=m;i++)
		    for(int j=l[i];j<=r[i];j++)
		        ans[j]+=(j-i+1);
		for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
		printf("\n");
	   }
	return 0;
}
```

---

## 作者：蒟蒻君HJT (赞：1)

可能唯一难度是位置的题目。调和级数板题放 D 题一万个人能过。

设字符串为 $z_1z_2\cdots z_n$，记 $s_i=z_1z_2\cdots z_i$。

考虑长度为 $i$ 的前缀 $s_i$。假设划分为 $k$ 段，每段漂亮值为 $r$。由于 $k-1$ 的划分点可能是在相同/不同数字之间，因此前 $i$ 个数字中，相邻位置不同的对数应该在 $[rk,rk+k-1]$ 之间，换句话说，确定 $k$ 之后，可能成为答案的 $r$ 也随之确定了。

我们将所有满足 $z_i\neq z_{i-1}$ 的 $i$ 保存为数列 $a_1,a_2,\cdots a_c$。枚举 $r(r\geq 1)$，$k=1$ 时，能贡献到的最短前缀显然是 $s_{a_r}$，最长前缀是 $s_{a_{r+1}-1}$。

但是 $k=2$ 的时候怎么做呢？最长前缀是 $s_{a_{2(r+1)}-1}$ 是显然的。最短前缀考虑从 $k=1$ 的情况递推过来。第一段最少截断到 $s_{a_r}$，最多截断到 $s_{a_{r+1}-1}$，因此：

1. 如果 $a_{r+1}=a_r+1$，在截断的时候 $a_{r+1}$ 一定会被破坏掉，第二段想拥有 $r$ 的漂亮值，只能包括 $a_{r+2},a_{r+3}\cdots a_{2r+1}$，最短前缀为 $s_{a_{2r+1}}$。

2. 如果 $a_{r+1}>a_r+1$，在截断的时候 $a_{r+1}$ 不一定会被破坏掉，第二段想拥有 $r$ 的漂亮值，可以包括 $a_{r+1},a_{r+2}\cdots a_{2r}$，最短前缀为 $s_{a_{2r}}$。

对于 $k$ 更大的情况可以依次类推下去，最多枚举到 $k=\lfloor \frac{c}{r}\rfloor$ 就足够了。每次在枚举在符合要求的前缀范围执行一次区间加即可维护答案（差分一下）。另外注意一下 $r=0$ 的情况还没算，随便怎么处理下都行。

有人可能会问了，如果不同的 $r$ 对应相同的 $k$ 贡献到了同一个前缀，那答案不就算重了？这不会成为问题，因为题解的开头已经证明了对于某个前缀，当 $k$ 确定时，$r$ 不可能有多解。

[提交记录](https://codeforces.com/contest/2092/submission/313070961)

---


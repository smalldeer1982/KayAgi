# Alien DNA

## 题目描述

Professor Bajtocy is conducting experiments on alien DNA. He has discovered that it is subject to repetitive mutations — each mutation happens in the same way: some continuous subsequence of the alien DNA becomes active, copies itself, the copy gets mangled and inserts itself right after the original subsequence. The mangled copy of the activated continuous subsequence is formed by first joining all the elements at the even positions in that subsequence, and then joining all the elements at the odd ones at the end. That is, if the activated subsequence consists of 11 elements and represented as $ s_{1}s_{2}...\ s_{11} $ , its mangled copy is $ s_{2}s_{4}s_{6}s_{8}s_{10}s_{1}s_{3}s_{5}s_{7}s_{9}s_{11} $ .

For example, if the original sequence was "ACTGG" and the mutation happened on the segment $ [2,4] $ (that is the activated subsequence is "CTG"), the mutated DNA is: "ACTGTCGG". The mangled copy of the activated subsequence is marked with bold font.

Professor Bajtocy has written down the original DNA sequence and the mutations that sequentially happened to it, and he now asks you to recover the first $ k $ elements of the DNA sequence after all the mutations.

## 说明/提示

In the second example, after the first mutation the sequence is "ACCAGTACGT". After the second mutation it's "ACCAGTACCGACATCGT".

## 样例 #1

### 输入

```
GAGA
4
0
```

### 输出

```
GAGA
```

## 样例 #2

### 输入

```
ACGTACGT
16
2
1 2
2 8
```

### 输出

```
ACCAGTACCGACATCG
```

# 题解

## 作者：shadowice1984 (赞：9)

神仙并查集……

这里写的方法可能和正解有些许出入(这题当年在cf比赛出的时候有两个人过了，一个写的是$O(n^2+kak)$而另一个是$O((n+k)logk)$)

这里的做法是$O(n^2+kak)$的，但是我们似乎可以通过数据结构来进行搞事情将它优化到$O(nlogn+kak)$
_____________________

## 本题题解

给你一个字符串，求对这个字符串进行n次"复制"操作之后的前k个字符

这里的复制需要传入两个参数$[l,r]$，然后我们进行如下操作，先将这个区间里的串的第2，4，6，8，10....位拼成一个字符串，然后将这个区间里的串的第1，3，5，7，9位拼成一个字符串，和刚才那个偶数位的字符串拼起来得到一个新的字符串，最后将这个字符串**插入**到原串的第r位之后。

首先这道题直接想要去模拟这个过程是没有办法做的……

因为我们的copy方式是没有任何性质可供利用的，所以说就算是维护前k个字符我们唯一可行的做法也是$O(nk)$暴力

那么正解是什么呢？正难则反，我们把所有操作过程倒过来考虑，递归的处理这个问题

具体来讲，我们不停的去解决这样的子问题:求第a次操作之后，这个字符串的前b位字符是什么

那么我们考虑第a次操作是什么

如果这个操作的r已经比b大了，那么复制出来的字符串根本不会去影响前k个字符

如果这个操作的r比b小了，那么我们复制出来的字符串会覆盖掉这个字符串的一些部分，假设这个长度为x，那么我们只需知道第a-1次操作之后前b-x个字符长什么样，我们就可以暴力模拟题意来还原出这些复制出的字符来，所以我们递归的去解决(a-1,b-x)这个问题，然后复制一遍就可以了

说的轻巧，可惜上面的算法还是$O(nk)$的，因为我们要不停的向一个字符串里面插入字符，此时问题就变得十分辣手了

如果我们直接使用线段树来执行上述过程的话，我们还是可以将复杂度控制在$O((n+k)logk)$的，卡卡常就可以在cf跑到飞快的机子上通过了

不过我们有另外一个比较优雅的迭代解法，可以做到$O(n^2+kak)$或者$O(nlogn+kak)$

思路和上面的思路是类似的，但是我们在递归下去的时候不再等解决了子问题之后复制，而是直接进行复制，这样的话我们在递归的回溯过程中就什么事也不做了，这样的话我们的算法就变成了一个“尾递归”的形式，就可以改写成迭代法了

问题来了你不递归就不知道这些点上是什么字符啊你怎么复制啊……

用并查集啊~

在并查集里面如果$i,j$这两个点有边就说明在操作n次的串之后这两个位置的值是相等的

这样的话当我们将所有操作倒着做完之后的话我们就知道了一大堆位置的值都是一样的，但是具体是什么值都不知道

不过呢，我们现在已经将所有操作都做完了，因此我们知道此时的串就是初始串，因此我们根据初始串给每个位置都赋一遍值就行了

那么具体来讲如何实现呢？

首先在结束的时候我们的序列是一整块(1,k)

然后接下来我们倒着做了一个复制操作，假设我们此时需要给$(dl,dr)$这段区间复制

那么我们在这个序列上暴力的for一遍在并查集上给对应的点进行连边的方式来进行复制操作

之后把这段区间(dl,dr)删掉，此时的序列变成了(1,dl-1)和(dr+1,m)这两段区间了

之后我们需要重复这个流程，但是我们发现此时的序列是由一堆区间拼起来的，而不是像一开始一样是一个连续的区间了，所以我们在删除(dl,dr)这个区间的时候是删除当前序列的第dl个元素到dr个元素了

比如说我们现在的序列是(1,3)(43,52)(233,666)(1001,2333)这4段区间拼成的，而我们需要删除(10,15)

那我们做的应该是把(43,52)这一段分裂成(43,49),和(50,52)以及将(233,666)分成(233,234)和(235,666)这段区间，然后删掉(50,52)和(233,234)这两段区间

为什么要这么做呢？因为我们的并查集维护的是**n次操作之后字符的位置编号**，而我们第i次的操作(l,r)却指的是**第i次操作前字符的位置编号**，这就是我们为什么每次完成了并查集上的复制操作之后都需要删掉对应的区间的原因，因为这段被复制出来的区间在这次操作之前都不会出现……

同理我们在序列上暴力的for循环进行复制的时候也是for的是第i个元素而不是标号为i的元素(没准这个时候标号为i的元素已经被删了呢)

最后序列中剩下的点就是依然未知的部分了，此时我们扫一遍原来的字符串进行复制就可以了

所以现在我们需要解决的问题就是如何解决区间删除以及查找kthelement的问题了……经典的平衡树问题啊……

使用splay来维护整个序列，时间复杂度为$O(nlogn+kak)$

但是这题n才5000，spaly多难写啊，使用数组来维护整个序列，时间复杂度为$O(n^2+kak)$

如果你莫名的tle了话，请注意一下你在进行暴力for循环赋值的时候是否每次for的被删除的区间长度进行连边还是for的操作区间长度进行判断，如果采用后者的话会导致类似于每次删长度为1的区间可是复制的区间长度却高达1e6的尴尬情况发生，此时就tle了……

ps:此题极其恶心……细节什么自己推吧，上面仅仅是个框架

上代码~

```C
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<algorithm>
using namespace std;const int N=3*1e6+10;const int M=3*1e4+10;
char mde[N];int n;int m;int k;
struct bcj//维护相等关系的并查集 
{
    int fa[N];char val[N];
    inline void ih(){for(int i=1;i<=k;i++)fa[i]=i;}
    inline int f(const int& x){return fa[x]=(x==fa[x])?x:f(fa[x]);}
    inline void u(const int& x,const int& y){fa[f(x)]=f(y);}
    inline void st(const int& x,char c){val[f(x)]=c;}
    inline void prit(const int& x){printf("%c",val[f(x)]);}
}s;
struct data{int l;int r;}a[2][M];int tp;int tot;int p;int lf[M];int rt[M];
struct iter//代码的一个trick，手写了迭代器 
{
    data* p;int pos;
    iter& operator ++ (){if(p->r==pos)++p,pos=p->l;else ++pos;return *this;}
};
int main()
{
    scanf("%s",mde+1);scanf("%d",&k);scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d%d",&lf[i],&rt[i]);
    s.ih();tot=k;p=0;a[p][++tp]=(data){1,k};a[p][tp+1]=(data){0x3f3f3f3f,0};
    for(int t=n;t>=1;t--)
    {
        if(rt[t]>=tot)continue;int len=rt[t]-lf[t]+1;
        int dl=rt[t]+1;int dr=min(rt[t]+len,tot);int mid=rt[t]+(len/2)+1;
        iter it1,it2,it3;int cnt=0;
        it1.pos=0x3f3f3f3f;it2.pos=0x3f3f3f3f;it3.pos=0x3f3f3f3f;
        cnt=0;//暴力查kth 
        for(int i=1;i<=tp;i++)
        {
            cnt+=a[p][i].r-a[p][i].l+1;
            if(cnt>=lf[t]){it1=(iter){&a[p][i],a[p][i].r-cnt+lf[t]};break;}
        }
        cnt=0;
        for(int i=1;i<=tp;i++)
        {
            cnt+=a[p][i].r-a[p][i].l+1;
            if(cnt>=dl){it2=(iter){&a[p][i],a[p][i].r-cnt+dl};break;}
        }
        cnt=0;
        for(int i=1;i<=tp;i++)
        {
            cnt+=a[p][i].r-a[p][i].l+1;
            if(cnt>=mid){it3=(iter){&a[p][i],a[p][i].r-cnt+mid};break;}
        }
        for(int i=1;i<=len&&(it3.pos!=0x3f3f3f3f||it2.pos!=0x3f3f3f3f);i++,++it1)//暴力复制 
            if(i&1){if(it3.pos!=0x3f3f3f3f)s.u(it1.pos,it3.pos),++it3;}
            else if(it2.pos!=0x3f3f3f3f)s.u(it1.pos,it2.pos),++it2;
        int lim=tp;tp=0;cnt=0;
        for(int i=1;i<=lim;i++)
        {
            int pp=cnt;cnt+=a[p][i].r-a[p][i].l+1;
            if(cnt<dl||pp>=dr){a[p^1][++tp]=a[p][i];continue;}
            if(pp<rt[t])a[p^1][++tp]=(data){a[p][i].l,a[p][i].l+rt[t]-pp-1};
            if(cnt>dr)a[p^1][++tp]=(data){a[p][i].r-cnt+dr+1,a[p][i].r};
        }tot-=(dr-dl+1);p^=1;a[p][tp+1]=(data){0x3f3f3f3f,0};
    }
    iter it=(iter){&a[p][1],a[p][1].l};
    for(int i=1;i<=tot;i++){s.st(it.pos,mde[i]);++it;}//最后根据原串来确定未知部分 
    for(int i=1;i<=k;i++)s.prit(i);return 0;//拜拜程序~ 
}
```







---

## 作者：Rorshach (赞：4)

shadowice大爷讲了一个$n^2$的做法 这里补一个$KlogK$的做法

也是倒序考虑每一个操作，对于一个操作$[l, r]$，他产生的影响区间将是$[r+1,r + r + l - 1]$，如果$r+l-1>K$的话，$K$之后的区间我们是不关心的。

暴力扫描这个区间 然后对于每一个位置，维护一个类似于并查集的东西。

扫到位置$i$，定义数组$f$ 表示$i$这个位置上的字符是由$f_i$这个位置上的字符填充得到的。然后删除$i$。

这个东西具体怎么搞？我们可以弄一个长度为K，初始化为1的序列。获得第$i$个位置就是这个序列上第$i$个1，然后删除这个位置上的字符，就是把序列上该位置的1变成0。维护这个序列的话树状数组+二分或者树状数组+倍增花式搞，我选择后者，毕竟前者复杂度多一个$log$。不会的话可以看lyd那本书的P203(第一版)，或者做一下poj 2182.

当然线段树维护也是可以的啦~

所以我们就得到如下算法：

倒序扫描每一个操作，维护一个变量$now$表示我们关心的区间末尾，对于每次操作的区间$[l,r]$，用一个变量$x$扫描$[r+1,r+l-1]$所要填充的字符的位置。每填充一个数$now$就减一，如果$r>now$就直接停止。因为$now$的缘故，最多填充次数为$K$。每次填充时，设$tmp$为01序列中第$r+1$个1，那么将$tmp$位置上的数减一，然后更新$f_{tmp}$为第$x$个1的位置

然后从左往右求解，如果$f_i$存在，那么$ans_i=ans_{f_i}$，不然$ans_i=s_{j+1},j++$ 由于$f_i$必然比$i$小 所以这样做一定是正确的

代码可见我的[cnblog](https://www.cnblogs.com/Rorshach/p/9846884.html)

---

## 作者：Mysterious_Cat (赞：2)

提供一个 $O(n\log k + k)$ 的解法。

首先我们将时间倒流，从后往前考虑每次操作对最终的前 $k$ 个字符造成的影响。

设当前没有被确定的位置构成一个序列 $p_1 < p_2 < \dots < p_m$。

对于一次操作 $[l,r]$，$p_{r+1},p_{r+2},\dots,p_{r+(r-l)}$ 的字符是由 $p_l,p_{l+1},\dots,p_{r}$ 复制过来的。我们忽略其中超过 $m$ 的下标。我们将 $p_{r+1},p_{r+2},\dots,p_{r+(r-l)}$ 中的每个 $p_i$ 向 $p_l,p_{l+1},\dots,p_{r}$ 中对应的 $p_j$ 连边，表示 $p_i$ 由 $p_j$ 复制过来。然后把 $p_{r+1},p_{r+2},\dots,p_{r+(r-l)}$ 全部删去。用链表维护即可。

所有操作考虑完以后，对于剩余的 $p_i$，其上的字符即为原字符串 $s$ 的第 $i$ 个字符 $s_i$。

我们对建出来的图搜索，即可确定所有字符。因为我们从后往前连边，所以我们其实不需要搜索，从前往后遍历一遍就行。

容易发现边数是 $O(k)$ 的，找到 $p_l$ 之后连边的总复杂度也是 $O(k)$。

现在的问题是，我们每次都需要找到链表中第 $l$ 个数的位置，而链表不支持二分，暴力找总复杂度 $O(nk)$，不能接受。

我们使用线段树维护 $[1,k]$ 区间中每个位置是否在链表里。当删除节点 $p_{r+1},p_{r+2},\dots,p_{r+(r-l)}$ 时，我们在线段树上将 $[p_{r+1},p_{r+(r-l)}]$ 修改为 $0$。查询第 $l$ 个数的位置在线段树上二分即可。

时间复杂度 $O(n\log k+k)$。但是实际效率不如用树状数组实现的 $O((n+k)\log k)$。

[$O(n\log k+k)$ 代码](https://codeforces.com/contest/217/submission/223557577)

[$O((n+k)\log k)$ 代码](https://codeforces.com/contest/217/submission/223487022)

---

## 作者：Wangzehao2009 (赞：1)

# 【题解】Alien DNA

# 目录 
- [【题解】Alien DNA](#题解alien-dna)
- [目录](#目录)
- [题目描述（省流）](#题目描述省流)
- [解题思路](#解题思路)
  - [初步思考](#初步思考)
  - [具体分析](#具体分析)
  - [举例说明](#举例说明)
- [主干代码展示](#主干代码展示)
- [时间复杂度](#时间复杂度)

# 题目描述（省流）
给你一个字符串，有 $n$ 个操作改变区间 $[l,r]$，每次操作把区间内的字符串复制一遍按照一定规则”突变“然后接在后面，”突变“部分的规则为：$s_1s_2…s_{11} \rightarrow s_2s_4s_6s_8s_{10}s_1s_3s_5s_7s_9s_{11}$，求 $n$ 次操作后结果的前 $k$ 个字符。

# 解题思路

## 初步思考
首先，你需要敏感地意识到 **“我们只需要前 $k$ 项”**。正着走需要不停地移动数组中的元素，复杂度过高（感兴趣的同学可尝试算一算此算法的复杂度）。那我们不妨反其道而行之，假设我们直接走到了最后答案的那一步，**尝试去找到答案中每一个元素是由前面的哪个元素“突变”过来的。**

现在我们目标已经很明确了：**就是要准备一个长度为 $k$ 的数组 $ans$ 表示答案中第 $i$ 个元素在原序列 $s$ 中的下标。**


## 具体分析

**这块没听懂也没关系，后面会举具体例子**

区间的修改是有优先级的，先输入的区间先做突变，所以如果我们顺着修改，但之后别修改过的部分也有可能再次修改，所以这样就乱套了。可以想到最后一次操作的区间不会被其他操作影响，所以 **最后一次操作后，相应的改变的位置已经定了，不会再改变，所以我们可以逆着做。** 搞两个数组 $l$ 和 $r$，倒着输入的顺序做的操作（其实就是``for(int i=n;i>=1;i--)``）。

这就是**逆向思维**。

继续分析，对于最后一个区间 $[l,r]$，它改变的区间为 $[r+1,r+len]$，前面我们已经提到：只需关心 $[1,k]$ 的区间，后面的字符串爱咋滴咋滴。所以我们只需要关心 $[r+1,r+len]∪[1,k]$ 的元素即可。

当我们操作的时候，我们会面临一些问题：空位怎么找？如果我们想要的那个空位被占有了怎么办？于是我们顺理成章，维护一串长度为 $k$ 的 $01$ 数组，来表示其的空白位置。$1$ 表示该位置未被占有，$0$ 表示该位置已经被占有。那如果冲突怎么办？我们还是要遵循 **“后来居上”** 原则，那您只能往后挪了。

因为我们要操作的区间是 $[r+1,r+len]$，所以对于每一个 $[l,r]$ 我们只需要寻找第 $r+1$ 个空位（即第 $r+1$ 个 $1$）的位置 $pos$。
同时，当你在序列中填入一个 DNA 的时候，也记得要把那个位置变成 $0$。那最后 $ans[i]$ 就是由第 $i$ 个 $1$ 的下标转化而来的。这样我们就完成了 **“对号入座”** 的操作。

所以找位置这个事又被我们转化到：**查找第 $r+1$ 个 $1$ 的位置**。

你猜这个问题怎么解决？答：**线段树 树状数组**
还不会求？提示：区间和等于 $r+1$（大哥，不能再提示了）

如果你想明白上面这些了，那就只剩下最后一个小问题：**奇偶项的位置变换怎么处理？**
其实处理方法不止一种，但我介绍一种最巧妙、代码最短的处理方式。

对于一个需要修改的区间 $[l,r]$，我们搞一个指针 $pos$ 来遍历。$pos$ 一开始等于 $l+1$，也就是该序列的第一个偶数项。每次 $pos+=2$ 把所有偶数项先遍历一遍。当 $pos>r$ 时，说明偶数项搞完了，现在再让 $pos=l$，开始遍历奇数项。最后还有一个小细节：$len(l,r)=1$ 时特判一下。

## 举例说明

不出意外，你刚才肯定会有一些懵。如果刚才的思路你没有听明白，很好，我们就来举一个比较有代表性的例子。（没听明白很正常，我也是思考许多遍才理解。）

$$s=\texttt{ATCG},k=7$$

$$l[1]=1,r[1]=3$$

$$l[2]=2,r[2]=4$$

$$ans=\texttt{ATCTCTT}$$

我们就来看一看如何得到这个答案。

首先，把 $01$ 数组先都赋值成 $1$，表示空白位置。为了方便表示，我们把查找 **“第 $k$ 个 $1$”** 这个操作定义成一个函数``Find()``。

|序号|1|2|3|4|5|6|7|
|---|---|----|----|---|---|---|---|
|状态|1|1|1|1|1|1|1|

倒序操作，第一组：$l=2,r=4$，$pos=l+1=3$。

$tmp=Find(r+1)=5$，填入并改变数组。

|序号|1|2|3|4|5|6|7|
|---|---|----|----|---|---|---|---|
|状态|1|1|1|1|0|1|1|

因为 $3$ 的 DNA 变成了 $5$ 的 DNA 。

$\therefore ans[tmp]=ans[5]=Find(pos)=3$

后面几个同理，最后 $01$ 数组和 $ans$ 数组应该变成这个样子：

|序号|1|2|3|4|5|6|7|
|---|---|----|----|---|---|---|---|
|状态|1|1|1|1|0|0|0|

$ans[5]=3,ans[6]=2,ans[7]=4$
___
这一组 $[l,r]$ 以结束，继续 $l=1,r=3$。

$$pos=l+1=2,tmp=Find(r+1)=4$$

|序号|1|2|3|4|5|6|7|
|---|---|----|----|---|---|---|---|
|状态|1|1|1|0|0|0|0|

$$ans[tmp]=ans[4]=Find(pos)=2$$

好，那么接下来就有意思了。

$pos=1$

当我们 $Find(r+1)=Find(4)$ 的时候，我们惊奇的发现：**$01$ 数组中只有 $3$ 个 $1$ 了啊！**
说明它已经超过了 $[1,k]$ 的范围了，就不管了。

$pos=3$ 的时候同理，也不用管了。
___

很好，我们已经把这个例子搞定了。最后 $01$ 数组就是这么个状况：

|序号|1|2|3|4|5|6|7|
|---|---|----|----|---|---|---|---|
|状态|1|1|1|0|0|0|0|

$ans$ 数组是这么个状况：

|序号|1|2|3|4|5|6|7|
|---|---|----|----|---|---|---|---|
|状态|0|0|0|0|3|2|4|

现在有个问题，$ans$ 数组中的 $0$ 代表该位置还没被占，输出什么？
答：输出原序列 $s$ 对应的 DNA 即可。

# 主干代码展示

本体思维难度较大，可参考代码进行理解（线段树或者树状数组那一部分自己写）。
```cpp
int main()
{
    scanf("%s", s+1);
    scanf("%d%d",&k, &n);
    for(int i=1;i<=k;i++) Add(i,1);
    for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]);
    Init();
    for(int now=k,i=n;i>=1;i--)
	{
		
		for(int pos=l[i]+1,j=1;r[i]<now && j<=r[i]-l[i]+1;pos+=2,j++,now--)
        {
            if(pos>r[i]) pos=l[i];
            int tmp=Find(r[i]+1); 
            Add(tmp,-1);
            ans[tmp]=Find(pos);
        }
	} 
    for(int i=1,j=1;i<=k;i++)
	{
		if(ans[i]!=0) DNA[i]=DNA[ans[i]];
		else DNA[i]=s[j++];
	}
    printf("%s",DNA+1);
    return 0;
}
```

# 时间复杂度

因为最终结果之和 $k$ 有关，所以什么 $l,r  \leq 10^9$ 就是个幌子。
线段树和树状数组每一次都是 $ \log$ 的，要把 $k$ 个空都填满。

所以最终的时间复杂度为：**$O(k\log{k})$**

---

## 作者：Mirasycle (赞：1)

发现后续操作会覆盖先前操作，于是我们可以进行倒序操作。

我们可以动态维护前 $k$ 位。考虑一个操作 $[l,r]$，显然 $r<k$ 的时候才有意义。我们可以发现其实插入操作后相当于在序列中间增长了序列，而且这一部分不会改变了。所以我们需要维护的 $k$ 自然也会随之变化成为 $k'$ 。每插入一个数，$k$ 都会减少一位。假如从 $pos$ 处插入一个长度为 $d$ 的序列，原先 $pos$ 处的东西会到 $pos+d$ 处。

这启发我们维护一个序列，代表目前序列的 $i$ 位置是否是原先序列的值，每次插入一段区间相当于将一段的 $1$ 变成 $0$，由于原先序列只是被拆成很多段向后平移了，相对位置关系没变，所以目前维护的序列中的第 $k$ 个 $1$，就是原序列中的第 $k$ 位，目前所在的位置。这个过程可以用树状数组配合上倍增实现。

对于每一个变成 $0$ 的位置 $i$ 维护一个 $f_i$ 指向这个地方由原先序列中的哪个位置复制而来。对于每一个 $1$ 的位置，在回答的时候顺次扫描看是第几个为 $1$ 的位置，也就是原序列中的第几个元素。

2024/1/28: 现在 CF 不给用 c++14 了，c++14 上树状数组倍增刚好卡着时限过去，可是用 c++17 发现树状数组倍增过不去了。换成线段树二分居然过了，不知道为什么线段树比树状数组还快。

---


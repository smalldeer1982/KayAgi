# 题目信息

# Light It Up

## 题目描述

**题目大意：**

有一台灯，这个灯在时间为$0$时打开，$m$时关闭，在$0$到$m$这段时间内有$n$个时间点灯的状态会改变（即开变关，关变开），现在可以在**剩余**的时间点选一个让灯的状态改变一次，求这个灯最大亮着的时间

## 样例 #1

### 输入

```
3 10
4 6 7
```

### 输出

```
8
```

## 样例 #2

### 输入

```
2 12
1 10
```

### 输出

```
9
```

## 样例 #3

### 输入

```
2 7
3 4
```

### 输出

```
6
```

# AI分析结果

### 题目内容
# 点亮它

## 题目描述
**题目大意：**
有一台灯，在时间为\(0\)时打开，\(m\)时关闭，在\(0\)到\(m\)这段时间内有\(n\)个时间点灯的状态会改变（即开变关，关变开），现在可以在**剩余**的时间点选一个让灯的状态改变一次，求这个灯最大亮着的时间。

## 样例 #1
### 输入
```
3 10
4 6 7
```
### 输出
```
8
```

## 样例 #2
### 输入
```
2 12
1 10
```
### 输出
```
9
```

## 样例 #3
### 输入
```
2 7
3 4
```
### 输出
```
6
```

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是通过贪心策略，结合前缀和等技巧来解决问题。主要思路是将\(0\)到\(m\)的时间段根据给定的\(n\)个状态改变时间点分成\(n + 1\)段，通过枚举在每段中插入一个改变状态的时间点，计算改变后亮灯的总时长，并与不改变状态时亮灯时长比较，取最大值。

各题解的算法要点在于：利用前缀和维护奇数或偶数编号线段的长度和，或者维护不同状态下的时间和，以便快速计算在某个位置插入改变状态时间点后的亮灯时长。

解决难点在于理解插入一个时间点后对后续亮灯状态的影响，以及如何通过前缀和等方式优化计算过程，避免\(O(n^2)\)的时间复杂度。

### 所选的题解
#### 作者：VenusM1nT (5星)
- **关键亮点**：将题目模型转换为线段操作问题，思路清晰，代码简洁高效，利用前缀和数组分别维护奇数编号和偶数编号线段长度和，通过枚举所有可能插入的线段并计算改变后的亮灯时长，最后得出最大值。
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define reg register
#define inl inline
using namespace std;
int n,m,a[MAXN],b[MAXN],len[MAXN],sum1[MAXN],sum2[MAXN],ans;
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(reg int i=1;i<=n;i++) cin>>a[i];
	a[0]=0,a[n+1]=m;
	sort(a,a+n+2);
	for(reg int i=1;i<=n+1;i++)
	{
		len[i]=a[i]-a[i-1];
		if(i%2) ans+=len[i];
	}
	for(reg int i=1;i<=n+1;i++)
	{
		sum1[i]=sum1[i-1]+((i%2)?len[i]:0);
		sum2[i]=sum2[i-1]+((!(i%2))?len[i]:0);
	}
	for(reg int i=1;i<=n+1;i++)
	{
		if(len[i]==1) continue;
		reg int cnt=sum1[i-1]+len[i]-1+sum2[n+1]-sum2[i];
		ans=max(ans,cnt);
	}
	printf("%d\n",ans);
	return 0;
}
```
核心实现思想：先对输入的时间点排序并计算各线段长度，初始化不插入新点时亮灯时长。然后通过前缀和数组`sum1`和`sum2`分别记录奇数和偶数编号线段长度和。最后枚举每一条线段，若长度不为\(1\)，计算插入该线段后亮灯时长并更新最大值。

#### 作者：lsr1409111459 (4星)
- **关键亮点**：对题目理解清晰，将操作描述为插入点改变线段奇偶性，通过前缀和维护奇数线段和偶数线段长度和，在枚举插入位置时，详细说明了如何计算插入后的亮灯时长，代码实现简洁明了。
```cpp
#include <iostream>
using namespace std;
int n,m;
int a[100100],len[100100];
int ans=0;
int sum1[100100],sum2[100100];
//sum1[i]表示线段i前所有编号为奇数的线段的长度和，sum2[i]表示线段i前所有编号为偶数的线段的长度和
int main()
{
    scanf("%d%d",&n,&m);
    a[0]=0;a[n+1]=m;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n+1;i++)
    {
        len[i]=a[i]-a[i-1];
        if(i%2)
        {
            ans+=len[i];
            sum1[i]=sum1[i-1]+len[i];
            sum2[i]=sum2[i-1];
        }
        else
        {
            sum1[i]=sum1[i-1];
            sum2[i]=sum2[i-1]+len[i];
        }
    }
    for(int i=1;i<=n+1;i++)
        ans=max(ans,sum1[i-1]+len[i]-1+sum2[n+1]-sum2[i]);
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：首先对输入时间点处理并计算各线段长度，同时初始化不插入新点时亮灯时长。利用前缀和数组`sum1`和`sum2`分别记录奇数和偶数编号线段长度和。最后枚举所有线段，计算插入该线段后亮灯时长并更新最大值。

#### 作者：LZYAC (4星)
- **关键亮点**：通过贪心得到两条重要性质，即亮着的灯在结束前关，关着的灯在开始后开，以此为基础维护前缀和与后缀和，将数组分为三段分别计算答案，思路明确，代码简洁。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans,a[100010],s1[100010],s2[100010];
signed main(){
	scanf("%lld%lld",&n,&m);
	a[n+1]=m;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n+1;i++){
		if(i&1){
			ans=ans+a[i]-a[i-1];
			s1[i]=s1[i-1]+a[i]-a[i-1];
			s2[i]=s2[i-1];
		}
		else{
			s1[i]=s1[i-1];
			s2[i]=s2[i-1]+a[i]-a[i-1];
		}
	}
	for(int i=1;i<=n+1;i++){
		if(a[i]-a[i-1]>1) ans=max(ans,s1[i-1]+a[i]-a[i-1]-1+s2[n+1]-s2[i]);
	}
	printf("%lld",ans);
	return 0;
}
```
核心实现思想：先处理输入时间点，计算不插入新点时亮灯时长。通过前缀和数组`s1`和`s2`分别记录奇数和偶数编号线段长度和。枚举所有线段，当线段长度大于\(1\)时，根据贪心性质计算插入该线段后亮灯时长并更新最大值。

### 最优关键思路或技巧
1. **贪心策略**：通过分析可知，在已有状态改变时间点的相邻位置插入新的改变点是最优选择，如亮着的灯在结束前关，关着的灯在开始后开。
2. **前缀和优化**：利用前缀和数组维护不同状态下的线段长度和，能够在\(O(1)\)时间内计算插入新点后亮灯时长，从而将时间复杂度从\(O(n^2)\)优化到\(O(n)\)。

### 可拓展思路
此类题目属于贪心结合前缀和优化的问题，类似套路是分析问题中的最优选择，并通过前缀和等数据结构优化计算过程。同类型题可能会改变状态改变的规则，或者改变时间区间的限制等，但核心思路类似。

### 洛谷相似题目推荐
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：通过贪心思想和前缀和技巧求最大子段和。
2. [P1833 樱花](https://www.luogu.com.cn/problem/P1833)：结合贪心和前缀和解决分配问题。
3. [P2032 扫描](https://www.luogu.com.cn/problem/P2032)：利用贪心和前缀和优化扫描问题的计算。

### 个人心得摘录与总结
 - **作者：lsr1409111459**：开始理解错题意导致无思路，重新阅读后豁然开朗，强调前缀和维护/差分维护在\(O(1)\)查询/修改方面的优化作用。总结为理解题意很关键，同时要重视前缀和等优化方法。 

---
处理用时：72.81秒
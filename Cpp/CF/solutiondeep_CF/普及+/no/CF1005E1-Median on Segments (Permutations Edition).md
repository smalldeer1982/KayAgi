# 题目信息

# Median on Segments (Permutations Edition)

## 题目描述

#### 题目翻译

给定 $1\sim n$ 的排列 $(1\leq n\leq 2\times 10^5)$，求中位数为 $m$ 的子段个数（子段长度为偶数时，取其第 $\frac k 2$ 项，$k$ 为子段长度）

## 样例 #1

### 输入

```
5 4
2 4 5 3 1
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 5
1 2 3 4 5
```

### 输出

```
1
```

## 样例 #3

### 输入

```
15 8
1 15 2 14 3 13 4 8 12 5 11 6 10 7 9
```

### 输出

```
48
```

# AI分析结果

### 题目内容
# Median on Segments (Permutations Edition)

## 题目描述

#### 题目翻译
给定1到n的排列（1 ≤ n ≤ 2×10⁵），求中位数为m的子段个数（子段长度为偶数时，取其第k/2项，k为子段长度）

## 样例 #1
### 输入
```
5 4
2 4 5 3 1
```
### 输出
```
4
```

## 样例 #2
### 输入
```
5 5
1 2 3 4 5
```
### 输出
```
1
```

## 样例 #3
### 输入
```
15 8
1 15 2 14 3 13 4 8 12 5 11 6 10 7 9
```
### 输出
```
48
```

### 算法分类
数学、前缀和

### 综合分析与结论
这些题解的核心思路都是利用前缀和来快速统计满足中位数为m条件的子段个数。主要难点在于如何根据子段长度的奇偶性，通过数学推导得出判断子段中位数为m的条件，并利用数据结构（如map、数组）优化时间复杂度。各题解的主要区别在于对条件的推导方式、数据结构的使用以及代码实现的细节。

### 所选的题解
- **作者：Phartial（5星）**
    - **关键亮点**：思路清晰，通过简洁的数学推导得出判断条件，利用一个map存储aᵢ - bᵢ的值出现的个数，代码简洁高效。
    - **重点代码核心实现思想**：先找到m的位置v，对m左边的数统计小于等于m和大于m的数的个数差值s，并将其出现次数存入map。对m右边的数同样统计s，根据奇偶性条件累加map中对应值的出现次数得到答案。
    ```cpp
    for (int i = 1; i < v; ++i) {
        ++p[s += (a[i] > m? -1 : 1)];
    }
    for (int i = v; i <= n; ++i) {
        s += (a[i] > m? -1 : 1), ans += p[s] + p[s - 1];
    }
    ```
- **作者：SoyTony（4星）**
    - **关键亮点**：详细阐述思路，通过设cnt1和cnt2分别统计小于等于和大于等于m的个数，利用两个map分别处理奇偶长度子段，逻辑清晰。
    - **重点代码核心实现思想**：先预处理出cnt1和cnt2数组，遍历数组，根据当前位置i的奇偶性，在对应的map中查找并累加满足条件的子段个数，同时更新map。
    ```cpp
    for(int i=1;i<=n;++i){
        int x=cnt2[i]-cnt1[i];
        if(i&1){
            ans+=mp1[x-1]+mp2[x];
            ++mp1[x];
        }
        else{
            ans+=mp2[x-1]+mp1[x];
            ++mp2[x];
        }
    }
    ```
- **作者：__Deng_Rui_Song__（4星）**
    - **关键亮点**：通过将小于等于m的设为 - 1，大于m的设为1，简化判断条件，利用计数数组维护前缀和出现的次数，优化时间复杂度。
    - **重点代码核心实现思想**：记录m的位置id，将数组映射为 - 1和1后求前缀和pre，在m位置之后维护计数数组cnt，遍历m位置之前的前缀和，累加cnt中满足条件的次数得到答案。
    ```cpp
    for (int i = 1; i <= n; i++) {
        if (a[i] == m) id = i;
        a[i] = (a[i] <= m? -1 : 1);
        pre[i] = pre[i - 1] + a[i];
        if (id) cnt[pre[i] + M]++;
    }
    for (int i = 0; i < id; i++) ans += cnt[pre[i] + M] + cnt[pre[i] - 1 + M];
    ```

### 最优关键思路或技巧
将原数组根据与m的大小关系映射为 - 1和1，利用前缀和快速统计子段和，通过数学推导得出不同长度子段中位数为m的条件，再结合map或数组等数据结构记录前缀和出现的次数，从而优化时间复杂度，高效求解。

### 可拓展之处
同类型题可考虑其他关于中位数的统计问题，类似算法套路可应用于需要利用前缀和以及通过数学推导简化判断条件的题目。

### 洛谷相似题目推荐
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
- [P3957 [NOIP2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)
- [P1414 又是毕业季II](https://www.luogu.com.cn/problem/P1414) 

---
处理用时：45.29秒
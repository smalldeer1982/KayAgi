# 题目信息

# Stars Drawing (Easy Edition)

## 题目描述

定义一个星星是下面形状的图形：

- 由 $*$ 组成
- 星星的大小就是它向四个方向延伸的 $*$ 个数，注意四个方向要取最短的，不允许出现大小为0的星星

空的格子是 '$.$'（不包含引号），下面是几种星星的例子：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1015E1/dbf078fd5a2d2cf23bed0e2a7fa98ea60f68c8e9.png)

不难发现，左图是大小为 $1$ 的星星，中间的星星大小为 $2$ ，而右侧的星星大小为 $3$ 。



现在给定一个 $n\times m$ ，由'.'和'\*'（不包含引号）构成的的矩阵，你的任务是使用任意数量和大小的星星，画出这个矩阵上'\*'的图案，星星之间可以相交或重合。但星星不能超出矩阵。

## 样例 #1

### 输入

```
6 8
....*...
...**...
..*****.
...**...
....*...
........
```

### 输出

```
3
3 4 1
3 5 2
3 5 1
```

## 样例 #2

### 输入

```
5 5
.*...
****.
.****
..**.
.....
```

### 输出

```
3
2 2 1
3 3 1
3 4 1
```

## 样例 #3

### 输入

```
5 5
.*...
***..
.*...
.*...
.....
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
3 3
*.*
.*.
*.*
```

### 输出

```
-1
```

# AI分析结果

### 题目内容
# 绘制星星（简单版）

## 题目描述
定义一个星星是下面形状的图形：
- 由 `*` 组成
- 星星的大小就是它向四个方向延伸的 `*` 个数，注意四个方向要取最短的，不允许出现大小为0的星星

空的格子是 `'.'`（不包含引号），下面是几种星星的例子：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1015E1/dbf078fd5a2d2cf23bed0e2a7fa98ea60f68c8e9.png)

不难发现，左图是大小为 `1` 的星星，中间的星星大小为 `2` ，而右侧的星星大小为 `3` 。

现在给定一个 `n×m` ，由 `'.'` 和 `'*'`（不包含引号）构成的矩阵，你的任务是使用任意数量和大小的星星，画出这个矩阵上 `'*'` 的图案，星星之间可以相交或重合。但星星不能超出矩阵。

## 样例 #1
### 输入
```
6 8
....*...
...**...
..*****.
...**...
....*...
........
```
### 输出
```
3
3 4 1
3 5 2
3 5 1
```

## 样例 #2
### 输入
```
5 5
.*...
****.
.****
..**.
.....
```
### 输出
```
3
2 2 1
3 3 1
3 4 1
```

## 样例 #3
### 输入
```
5 5
.*...
***..
.*...
.*...
.....
```
### 输出
```
-1
```

## 样例 #4
### 输入
```
3 3
*.*
.*.
*.*
```
### 输出
```
-1
```

### 算法分类
贪心

### 综合分析与结论
这几道题解的核心思路都是围绕如何确定每个 `*` 能构成的最大星星，以及判断能否用这些星星覆盖所有 `*` 。不同之处在于确定星星大小后的覆盖标记和检查方式。冯老师的题解利用差分优化标记和检查过程，时空复杂度为 $\mathcal{O}(nm)$ ；Special_Tony 直接暴力标记并检查；eEfiuys 和 minecraft_herobrine 通过枚举扩展星星并标记，时间复杂度较高。整体来看，冯老师的题解在思路和优化上表现更好。

### 所选的题解
- **冯老师（5星）**
  - **关键亮点**：利用差分优化对星星覆盖区域的标记和检查，时空复杂度低。通过预处理数组记录每个 `*` 向四个方向延伸的长度，确定最大星星范围。
  - **重点代码核心实现思想**：用 `up`、`down`、`pre`、`suf` 数组记录每个 `*` 向四个方向延伸的长度，从而确定以每个 `*` 为中心的星星最大范围 `range` 。利用差分思想，对每行每列的覆盖区间进行标记，最后通过累加差分结果检查是否所有 `*` 都被覆盖。
  - **核心代码片段**：
```cpp
for(int i=1;i<=n;++i){
    for(int j=1;j<=m;++j){
        if(ma[i][j]=='*'){
            up[i][j]=(ma[i-1][j]=='*'?up[i-1][j]+1:1);
            pre[i][j]=(ma[i][j-1]=='*'?pre[i][j-1]+1:1);
        }
    }
}
for(int i=n;i>=1;--i){
    for(int j=m;j>=1;--j){
        if(ma[i][j]=='*'){
            down[i][j]=(ma[i+1][j]=='*'?down[i+1][j]+1:1);
            suf[i][j]=(ma[i][j+1]=='*'?suf[i][j+1]+1:1);
            range[i][j]=min({up[i][j],down[i][j],pre[i][j],suf[i][j]})-1;
            if(range[i][j]>=1){
                ++cnt;
                ++cf_row[id_row(i,j-range[i][j])];
                --cf_row[id_row(i,j+range[i][j]+1)];
                ++cf_col[id_col(i-range[i][j],j)];
                --cf_col[id_col(i+range[i][j]+1,j)];
            }
        }
    }
}
for(int i=1;i<=n*m;++i){
    sum_row[i]=sum_row[i-1]+cf_row[i];
    sum_col[i]=sum_col[i-1]+cf_col[i];
}
for(int i=1;i<=n;++i){
    for(int j=1;j<=m;++j){
        if(ma[i][j]=='*'){
            if(sum_row[id_row(i,j)]+sum_col[id_col(i,j)]<1){
                cout<<"-1";
                return 0;
            }
        }
    }
}
```
- **Special_Tony（4星）**
  - **关键亮点**：思路清晰直接，通过记录每个 `*` 向四个方向延伸长度确定最大星星大小，然后暴力标记检查。
  - **重点代码核心实现思想**：用 `l`、`r`、`u`、`d` 数组记录每个 `*` 向四个方向延伸的长度，得到每个 `*` 为中心的星星最大大小 `sum` 。对每个 `sum` 大于0的星星，暴力标记其覆盖区域，最后检查是否所有 `*` 都被标记。
  - **核心代码片段**：
```cpp
for (int i = 1; i <= n; ++ i) {
    cin >> a[i];
    a[i] = '*' + a[i];
    for (int j = 1; j <= m; ++ j)
        if (a[i][j] == '*')
            l[i][j] = l[i][j - 1] + 1, u[i][j] = u[i - 1][j] + 1;
}
for (int i = n; i; -- i)
    for (int j = m; j; -- j)
        if (a[i][j] == '*') {
            r[i][j] = r[i][j + 1] + 1;
            d[i][j] = d[i + 1][j] + 1;
            sum[i][j] = min ({l[i][j], r[i][j], u[i][j], d[i][j]}) - 1;
            if (sum[i][j]) {
                ++ ans;
                for (int x = i - sum[i][j]; x <= i + sum[i][j]; ++ x)
                    vis[x][j] = 1;
                for (int y = j - sum[i][j]; y <= j + sum[i][j]; ++ y)
                    vis[i][y] = 1;
            }
        }
for (int i = 1; i <= n; ++ i)
    for (int j = 1; j <= m; ++ j)
        if (a[i][j] == '*' &&! vis[i][j]) {
            cout << -1;
            return 0;
        }
```

### 最优关键思路或技巧
利用差分优化对星星覆盖区域的标记和检查过程，在预处理每个 `*` 能构成的最大星星大小时，通过数组记录向四个方向延伸长度，能高效确定最大星星范围。

### 可拓展之处
同类型题可考察在不同形状图形覆盖问题上的应用，类似套路是先确定每个点能构成的最大图形，再通过合适的数据结构或算法判断能否覆盖。

### 推荐题目
- [P1083 借教室](https://www.luogu.com.cn/problem/P1083)，考察差分应用。
- [P3397 地毯](https://www.luogu.com.cn/problem/P3397)，通过二维差分解决矩形区域操作问题。
- [P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)，利用差分解决区间修改和单点查询问题。

### 个人心得
无。

---
处理用时：92.10秒
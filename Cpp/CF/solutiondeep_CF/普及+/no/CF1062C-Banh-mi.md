# 题目信息

# Banh-mi

## 题目描述

JATC很喜欢吃越式法包(一种越南食品)。他总是把它当早餐吃，因为他实在是太喜欢了。这天早上，像以往一样，他买了一个越式法包，并且决定以一种特殊的方法吃掉它。  
首先，他把越式法包分为$n$块，并把它们排成一行，从$1$到$n$标号。对于每一块，他定义第$i$块的_口感_为$x_i∈\{0,1\}$。JATC正准备将它们一个接一个地吃掉。每一次，他随意选择剩下的一块吃掉。比如说他选择了第$i$块，那么他的_愉悦度_就会增加$x_i$，并且所有剩下的块的_口感_也会增加$x_i$。最初，JATC的_愉悦度_等于0。  
举个例子，假设$3$块越式法包的_口感_分别为$[0,1,0]$。如果JATC先吃掉第二块，他的_愉悦度_会变为$1$，其余块的_口感_则变为$[1,\_,1]$。接下来如果他吃掉第一块，他的_愉悦度_会变为$2$，剩下的块的_口感_变为$[\_,\_,2]$。吃掉最后一块后，JATC的_愉悦度_变为$4$。  
然而，他不想吃掉所有的越式法包块儿，想留一些以后吃。他给了你$n$个询问，每个询问由两个整数$l_i$和$r_i$组成。对于每个询问，请告诉他当他以某种顺序吃掉区间$[l_i,r_i]$的所有块后，最大的愉悦度是多少。  
每个询问都是互相独立的。由于答案可能很大，请对$10^9+7$取模。

## 说明/提示

对第1个询问：一种最佳的方案顺序为：$1,4,3,2$。  
对第2个询问：以$3,4$或$4,3$的顺序都可以得到同样的答案。  
任何顺序都能够得到相同的答案。

## 样例 #1

### 输入

```
4 2
1011
1 4
3 4
```

### 输出

```
14
3
```

## 样例 #2

### 输入

```
3 2
111
1 2
3 3
```

### 输出

```
3
1
```

# AI分析结果

### 题目内容
# Banh - mi
## 题目描述
JATC很喜欢吃越式法包(一种越南食品)。他总是把它当早餐吃，因为他实在是太喜欢了。这天早上，像以往一样，他买了一个越式法包，并且决定以一种特殊的方法吃掉它。  
首先，他把越式法包分为$n$块，并把它们排成一行，从$1$到$n$标号。对于每一块，他定义第$i$块的_口感_为$x_i∈\{0,1\}$。JATC正准备将它们一个接一个地吃掉。每一次，他随意选择剩下的一块吃掉。比如说他选择了第$i$块，那么他的_愉悦度_就会增加$x_i$，并且所有剩下的块的_口感_也会增加$x_i$。最初，JATC的_愉悦度_等于0。  
举个例子，假设$3$块越式法包的_口感_分别为$[0,1,0]$。如果JATC先吃掉第二块，他的愉悦度会变为$1$，其余块的口感则变为$[1,\_,1]$。接下来如果他吃掉第一块，他的愉悦度会变为$2$，剩下的块的口感变为$[\_,\_,2]$。吃掉最后一块后，JATC的愉悦度变为$4$。  
然而，他不想吃掉所有的越式法包块儿，想留一些以后吃。他给了你$n$个询问，每个询问由两个整数$l_i$和$r_i$组成。对于每个询问，请告诉他当他以某种顺序吃掉区间$[l_i,r_i]$的所有块后，最大的愉悦度是多少。  
每个询问都是互相独立的。由于答案可能很大，请对$10^9 + 7$取模。
## 说明/提示
对第1个询问：一种最佳的方案顺序为：$1,4,3,2$。  
对第2个询问：以$3,4$或$4,3$的顺序都可以得到同样的答案。  
任何顺序都能够得到相同的答案。
## 样例 #1
### 输入
```
4 2
1011
1 4
3 4
```
### 输出
```
14
3
```
## 样例 #2
### 输入
```
3 2
111
1 2
3 3
```
### 输出
```
3
1
```

### 算法分类
贪心、数学、前缀和

### 题解综合分析与结论
- **思路**：多数题解都提到运用贪心策略，即每次选择当前最大数字（也就是先吃口感为1的块），能使后续愉悦度最大。然后通过分析吃1和吃0时愉悦度的变化规律得出数学公式。
- **算法要点**：利用前缀和快速统计区间内1的个数，结合快速幂计算最终结果。这样能将时间复杂度从朴素的$O(n^2q)$优化到$O(n + t \log n)$ 。
- **解决难点**：难点在于发现贪心策略以及推导出计算愉悦度的数学公式。通过对吃不同口感块时愉悦度变化规律的总结，得出若区间内有$p$个1，$q$个0 ，愉悦度$ans=(2^p - 1)*2^q$的公式。

### 所选的题解
- **作者：封禁用户 (5星)**
  - **关键亮点**：思路清晰，详细阐述了贪心策略、数据范围分析、公式推导以及复杂度优化过程。代码简洁明了，注释详细。
  - **重点代码核心思想**：通过前缀和数组`b`统计1的个数，利用快速幂函数`ksm`计算$2^p$和$2^q$ ，进而得出最终答案。
```cpp
long long ksm(long long a, long long b)
{
    long long cnt = 1;
    while(b)
    {
        if(b & 1)
        {
            cnt = cnt * a % 1000000007;
        }
        b >>= 1;
        a = a * a % 1000000007;
    }
    return cnt;
}
int main()
{
    ios::sync_with_stdio(0);
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> t;
    cin >> s;
    for(int i = 1 ; i <= n ; i++)
    {
        if(s[i - 1] == '1')
        {
            a[i] = 1;
        }
        b[i] = b[i - 1] + a[i];
    }
    while(t--)
    {
        cin >> l >> r;
        p = b[r] - b[l - 1];
        q = r - l - p + 1;
        ansa = ksm(2, p) - 1;
        ansb = ksm(2, q);
        cout << ansa * ansb % 1000000007 << '\n';
    }
    return 0;
}
```
- **作者：szr666 (4星)**
  - **关键亮点**：在博客中解析，格式美观。详细讲解了前缀和统计1的个数，以及通过等比数列求和公式推导答案公式的过程。
  - **重点代码核心思想**：先通过前缀和数组`sum`统计1的个数，利用`power`函数快速幂计算$2^x$和$2^y$ ，从而得出最终答案。
```cpp
ll power(ll y)
{
    ll ans,x;
    ans=1;
    x=2;
    while(y!=0)
    {
        if(y&1)
        {
            ans=ans*x%p;
        }
        x=x*x%p;
        y>>=1;
    }
    return ans;
}
int main()
{
    int n,q,i,l,r;
    ll x,y;
    read(n);
    read(q);
    scanf("%s",s);
    for(i=0;i<n;i++)
    {
        sum[i+1]=sum[i]+s[i]-'0';
    }
    for(i=1;i<=q;i++)
    {
        read(l);
        read(r);
        x=sum[r]-sum[l-1];
        y=r-l+1-x;
        printf("%lld\n",((power(x)-1)*power(y))%p);
    }
}
```
- **作者：OIerJiang_1017 (4星)**
  - **关键亮点**：代码规范，思路阐述清晰，强调了贪心策略和前缀和优化复杂度的要点。
  - **重点代码核心思想**：利用前缀和数组`a`统计1的个数，通过`ksm`函数快速幂计算$2^p$和$2^q$ ，得出最终答案。
```cpp
ll ksm(ll a, ll b)
{
    ll mul = 1;
    while(b)
    {
        if(b % 2 == 1) mul = mul * a % mod;
        b /= 2;
        a = a * a % mod;
    }
    return mul;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin >> n >> T >> s;
    for(int i = 1; i <= s.size(); i++) 
    {
        if(s[i-1] == '1') f[i] = 1;
        a[i] = a[i-1] + f[i];//前缀和 
    }
    while(T--)
    {
        int l, r;
        cin >> l >> r;
        ll p = a[r] - a[l - 1];
        ll q = r - l - p + 1;
        ll a1 = ksm(2, p) - 1;
        ll a2 = ksm(2, q);
        cout << a1 * a2 % M << "\n";
    }
    return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：优先选择口感为1的块，能最大化愉悦度。
- **前缀和优化**：利用前缀和数组快速统计区间内1的个数，降低时间复杂度。
- **快速幂**：高效计算$2$的幂次方，减少计算量。

### 可拓展思路
同类型题通常会结合贪心策略与数学推导，再搭配数据结构优化。比如给定一个序列，每次操作会影响其他元素，求最终的最优值。类似算法套路是先分析操作规律得出贪心策略，再推导数学公式，最后用合适的数据结构优化时间复杂度。

### 洛谷相似题目推荐
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及贪心策略与高精度计算。
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)：通过贪心算法解决生产调度问题。
- [P1937 [USACO10MAR]Barn Allocation G](https://www.luogu.com.cn/problem/P1937)：运用贪心策略处理区间分配问题。 

---
处理用时：68.71秒
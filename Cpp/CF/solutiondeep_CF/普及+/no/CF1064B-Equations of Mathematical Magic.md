# 题目信息

# Equations of Mathematical Magic

## 题目描述

给出 $ a $，判断方程 $ a-(a \oplus x)-x=0 $ 的解的个数。（其中 $ \oplus $ 为异或）

## 样例 #1

### 输入

```
3
0
2
1073741823
```

### 输出

```
1
2
1073741824
```

# AI分析结果

### 题目内容
# 数学魔法方程

## 题目描述
给出 $a$，判断方程 $a - (a \oplus x) - x = 0$ 的解的个数。（其中 $\oplus$ 为异或）

## 样例 #1
### 输入
```
3
0
2
1073741823
```
### 输出
```
1
2
1073741824
```
### 算法分类
数学（位运算相关数学推导）

### 综合分析与结论
所有题解核心思路一致，均是通过移项得到 $a - x = a \oplus x$，利用异或运算按位独立的特性，分析 $a$ 和 $x$ 每个二进制位的取值情况，得出当 $a$ 的二进制位为 $1$ 时，对应 $x$ 的二进制位有 $2$ 种取值，为 $0$ 时，$x$ 的二进制位只有 $1$ 种取值，进而得到解的个数为 $2^{\text{popcnt}(a)}$，即 $a$ 的二进制表示中 $1$ 的个数的 $2$ 次幂。不同之处主要体现在代码实现细节，如计算二进制中 $1$ 的个数的方式，以及幂运算的实现等。

### 所选的题解
- **作者：Sooke (5星)**
    - **关键亮点**：思路阐述极为清晰，先指出不同二进制位对答案贡献互不影响，通过归纳法证明负数情况不影响答案，再用列表法直观呈现 $a, x \in \{0, 1\}$ 时的解的情况，代码简洁高效，使用 `__builtin_popcount` 函数。
    - **重点代码**：
```cpp
#include <iostream>

int main() {
    int n; std::cin >> n;
    while (std::cin >> n) { std::cout << (1 << __builtin_popcount(n)) << std::endl; }
    return 0;   
}
```
    - **核心实现思想**：通过 `__builtin_popcount` 函数获取 $n$ 二进制中 $1$ 的个数，然后通过左移运算得到 $2$ 的相应次幂输出。
- **作者：communist (4星)**
    - **关键亮点**：思路简洁明了，直接按位考虑，逻辑清晰，代码实现简单易懂，通过常规循环和取余运算计算二进制中 $1$ 的个数。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int t,a;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&a);
		int ans=1;
		while(a)
		{
			if(a%2)
				ans*=2;
			a/=2;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
    - **核心实现思想**：通过循环不断对 $a$ 取余判断是否为 $1$，是则将结果乘 $2$，同时 $a$ 除以 $2$ 右移一位，循环结束得到解的个数。
- **作者：DPseud (4星)**
    - **关键亮点**：通过列表分析 $a$ 与答案的关系，观察出答案规律，代码实现了自定义快速幂函数处理大数情况，考虑较为全面。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long power(int a,int n)//pow对于大数会以指数输出，所以我自己打了一个快速幂
{
	if(n==0)return 1;
	else if(n%2==1)return power(a,n-1)*a;
	else
	{
		long long temp=power(a,n/2);//10年OI一场空，不开 long long 见祖宗
		return temp*temp;
	}
}
int main() 
{
    register long long n,t;
    cin>>t;
    for(int i=0;i<t;i++)
    {
    	cin>>n;
    	long long resl=0;//指数
    	while(n){if(n%2)resl++;n>>=1;}//查找个数，众所周知位运算>>1比普通运算/2要快
	cout<<power(2,resl)<<endl;
    }
    return 0;   
}
```
    - **核心实现思想**：通过循环和位运算统计 $n$ 二进制中 $1$ 的个数作为指数，调用自定义快速幂函数计算 $2$ 的相应次幂得到解的个数。

### 最优关键思路或技巧
利用异或运算按位独立的特性，将问题简化为分析每个二进制位的情况，从而找到解的个数与 $a$ 二进制中 $1$ 的个数的关系。同时，在代码实现中，可利用 `__builtin_popcount` 这样的内置函数优化计算二进制中 $1$ 的个数的过程，如果担心大数问题，可实现自定义快速幂函数。

### 可拓展之处
此类题目属于位运算与方程结合的数学推理题，类似套路是分析位运算在方程中的特性，按位考虑问题。同类型题可关注其他涉及位运算与等式、不等式结合，判断解的个数或求解的题目。

### 洛谷相似题目
- [P1514 引水入城](https://www.luogu.com.cn/problem/P1514)：涉及位运算相关的逻辑判断与推理。
- [P1876 开灯](https://www.luogu.com.cn/problem/P1876)：通过位运算性质解决实际问题。
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：在归并排序过程中结合位运算思想解决逆序对计数问题。 

---
处理用时：47.40秒
# 题目信息

# Cutting Out

## 题目描述

给你一个序列 $s$，长度为 $n$.

你需要找到一个长度为 $k$ 的序列 $t$ 使得它能被最多次数地从 $s$ 中切割。

一次切割的意思是你需要对于 $t$ 序列中所有 $t_i$，在 $s$ 中找到一个跟它相同的数，并将其移除。

举例，如果 $s=[1,2,3,2,4,3,1]$，$k=3$，那么一种可行的方案是 $t=[1,2,3]$，这个子序列可以被切割两次。

- 第一次切割，你可以选择 $[1, \underline{\textbf{2}}, 3, 2, 4, \underline{\textbf{3}}, \underline{\textbf{1}}]$，移除完后 $s=[1,3,2,4]$；
- 第二次切割，你可以选择 $s=[\underline{\textbf{1}},\underline{\textbf{3}},\underline{\textbf{2}},4]$，移除完后 $s=[4]$。

你的任务是找到一个序列 $t$，能最多次数地从 $s$ 中切割它。如果有多个可行的方案，只需输出任意一种。

## 样例 #1

### 输入

```
7 3
1 2 3 2 4 3 1
```

### 输出

```
1 2 3 
```

## 样例 #2

### 输入

```
10 4
1 3 1 3 10 3 7 7 12 3
```

### 输出

```
7 3 1 3
```

## 样例 #3

### 输入

```
15 2
1 2 1 1 1 2 1 1 2 1 2 1 1 1 1
```

### 输出

```
1 1 
```

# AI分析结果

### 题目内容
# 切割序列

## 题目描述
给你一个序列 $s$，长度为 $n$。
你需要找到一个长度为 $k$ 的序列 $t$，使得它能被最多次数地从 $s$ 中切割。
一次切割的意思是你需要对于 $t$ 序列中所有 $t_i$，在 $s$ 中找到一个跟它相同的数，并将其移除。
举例，如果 $s=[1,2,3,2,4,3,1]$，$k = 3$，那么一种可行的方案是 $t=[1,2,3]$，这个子序列可以被切割两次。
 - 第一次切割，你可以选择 $[1, \underline{\textbf{2}}, 3, 2, 4, \underline{\textbf{3}}, \underline{\textbf{1}}]$，移除完后 $s=[1,3,2,4]$；
 - 第二次切割，你可以选择 $s=[\underline{\textbf{1}},\underline{\textbf{3}},\underline{\textbf{2}},4]$，移除完后 $s=[4]$。
你的任务是找到一个序列 $t$，能最多次数地从 $s$ 中切割它。如果有多个可行的方案，只需输出任意一种。

## 样例 #1
### 输入
```
7 3
1 2 3 2 4 3 1
```
### 输出
```
1 2 3 
```

## 样例 #2
### 输入
```
10 4
1 3 1 3 10 3 7 7 12 3
```
### 输出
```
7 3 1 3
```

## 样例 #3
### 输入
```
15 2
1 2 1 1 1 2 1 1 2 1 2 1 1 1 1
```
### 输出
```
1 1 
```

### 算法分类
二分、贪心

### 综合分析与结论
这些题解主要分为贪心和二分两种思路。
 - **贪心思路**：维护每个数出现的次数，利用大根堆贪心选择出现次数最多的数作为序列 $t$ 的元素。同时考虑数的重复选择情况，通过记录每个数已选次数，重新计算其可选次数并更新堆。此思路直接，代码简洁。
 - **二分思路**：发现切割次数具有单调性，对切割次数进行二分。在 $check$ 函数中，根据二分出的切割次数计算每个数可在序列 $t$ 中出现的次数，判断这些数的总和是否达到 $k$，以确定该切割次数是否可行。二分思路相对间接，但通过单调性优化了暴力枚举的时间复杂度。

### 所选的题解
 - **作者：MatrixCascade（5星）**
    - **关键亮点**：采用贪心算法，思路清晰直接，代码简洁高效，很好地解决了数的重复选择问题。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define up(i,x,y) for(int i=x,i##end=y;i<=i##end;++i)
using namespace std;
int n,m,k;
int b[202020],t[202002];
priority_queue<pair<int,int>>q;
signed main()
{
    cin>>n>>k;
    up(i,1,n)
    {
        int x;cin>>x;b[x]++;
    }
    up(i,1,200000)if(b[i])q.push(make_pair(b[i],i));
    up(i,1,k)
    {
        pair<int,int>nw=q.top();
        q.pop();
        int x=nw.first,y=nw.second;
        cout<<y<<" ";
        t[y]++;q.push(make_pair(b[y]/(t[y]+1),y));
    }
}
```
核心实现思想：先统计每个数出现次数并存入 $b$ 数组，将其以 $(b[i], i)$ 的形式存入优先队列 $q$ 中。每次从队列中取出出现次数最多的数输出，更新该数已选次数 $t[y]$，重新计算其可选次数 $b[y]/(t[y]+1)$ 并放回队列。
 - **作者：zsc2003（4星）**
    - **关键亮点**：二分思路清晰，详细阐述了二分对象及 $check$ 函数的实现，代码结构完整，注释详细。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()
{
    int r,s=0,c;
    for(;!isdigit(c=getchar());s=c);
    for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);
    return s^45?r:-r;
}
const int N=210000;
int n,k,l,r,mid,cha;
int a[N],num[N],tot,ans[N],cnt;
inline bool check(int x)
{
    int sum=0;
    for(int i=1;i<=tot;i++)
        sum+=num[i]/x;
    if(sum>=k)
        return 1;
    return 0;
}
int main()
{
    n=read(),k=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    sort(a+1,a+1+n);
    a[0]=-1314856;
    for(int i=1;i<=n;i++)
    {
        if(a[i]==a[i-1])
            num[tot]++;
        else
            num[++tot]=1;
    }
    unique(a+1,a+1+n)-a-1;
    l=1,r=n;
    while(l<=r)
    {
        mid=l+r>>1;
        if(check(mid))
        {
            l=mid+1;
            cha=mid;
        }
        else
            r=mid-1;
    }
    for(int i=1;i<=tot;i++)
    {
        while(num[i]>=cha)
        {
            ans[++cnt]=a[i];
            num[i]-=cha;
        }
    }
    for(int i=1;i<=k;i++)
        printf("%d ",ans[i]);
    return 0;
}
```
核心实现思想：先读入数据并统计每个数出现次数存于 $num$ 数组，对原数组排序去重。二分切割次数 $x$，在 $check$ 函数中计算当前切割次数下所有数可组成序列的长度，若长度大于等于 $k$ 则可行。二分结束后根据最终确定的切割次数记录答案。
 - **作者：_6_awa（4星）**
    - **关键亮点**：二分思路简洁明了，对二分答案后如何判断可行性及输出结果的处理清晰，代码简洁。
    - **重点代码**：
```cpp
#include <iostream>
using namespace std;
int l,r,n,k,a[200005],b[200005],ji;
bool check(int mi)
{
    int num = 0;
    for(int i = 1;i <= 200000;i ++)
        num += b[i] / mi;
    return num >= k;
}
int main()
{
    cin >> n >> k;
    for(int i = 1;i <= n;i ++)cin >> a[i],b[a[i]] ++;
    r = n;
    while(l < r)
    {
        int mid = (l + r + 1) / 2;
        if(check(mid))l = mid;
        else r = mid - 1;
    }
    for(int i = 1;i <= 200000;i ++)
        while(b[i] >= l && ji < k)
        {
            ji ++;
            cout << i << " ",b[i] -= l;
        }
}
```
核心实现思想：用 $b$ 数组统计每个数出现次数，二分切割次数 $mi$，在 $check$ 函数中计算当前切割次数下所有数可组成序列的长度判断是否可行。二分结束后根据最终切割次数输出答案序列，注意控制输出长度为 $k$。

### 最优关键思路或技巧
 - **二分思路**：利用切割次数的单调性，通过二分减少暴力枚举的时间复杂度，优化算法效率。
 - **贪心思路**：直接从数的出现次数出发，贪心选择出现次数多的数，同时巧妙处理数的重复选择问题，简化了问题求解过程。

### 可拓展之处
同类型题常围绕序列选择与操作次数最大化或最小化展开，类似算法套路为挖掘问题中的单调性进行二分优化，或根据数据特点采用贪心策略。例如在一些子序列选择、资源分配等场景下，判断是否存在单调性或能否贪心选择。

### 洛谷相似题目推荐
 - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：通过二分答案解决最优解问题，与本题二分切割次数思路类似。
 - [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)：同样利用二分答案，结合判断函数解决资源分配的最值问题。
 - [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：通过二分查找合适的分段界限，满足特定条件，与本题二分思路相近。

### 个人心得摘录与总结
 - **作者：little_sun**：做题时遇到WA16的情况，发现是 $n = k$ 的特殊点未处理好，强调了边界条件处理的重要性。 

---
处理用时：58.99秒
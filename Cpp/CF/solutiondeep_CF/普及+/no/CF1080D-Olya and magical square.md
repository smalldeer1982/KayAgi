# 题目信息

# Olya and magical square

## 题目描述

最近 Olya 收到了一个边长为 $2^n$ 的魔法正方形。



她的姐姐认为一个正方形太无趣了，于是要求 Olya 进行 $k$ 次分割操作。



每次操作，Olya 会选择一个边长不为 $1$ 的正方形，并把这个正方形分割为四个等大的小正方形。



Olya 很开心能满足姐姐的请求，但是她自己也要开心。



Olya 是开心的，当且仅当能从左下角到右上角找到一条正方形边长相同，四联通的路径。



请你输出在这 $k$ 次切割后，路径上正方形的边长。



如果不论怎么切都不能找出一条四联通的正方形边长相同的路径，或者这个正方形不能被切割 $k$ 次，输出 `NO`

## 说明/提示

$1 \leq t \leq 10^3$



$1 \leq n \leq 10^9$



$1 \leq k \leq 10^{18}$

## 样例 #1

### 输入

```
3
1 1
2 2
2 12
```

### 输出

```
YES 0
YES 1
NO
```

# AI分析结果

### 题目内容
# Olya和魔法正方形

## 题目描述
最近Olya收到了一个边长为\(2^n\)的魔法正方形。

她的姐姐认为一个正方形太无趣了，于是要求Olya进行\(k\)次分割操作。

每次操作，Olya会选择一个边长不为\(1\)的正方形，并把这个正方形分割为四个等大的小正方形。

Olya很开心能满足姐姐的请求，但是她自己也要开心。

Olya开心的条件是，能从左下角到右上角找到一条由边长相同的正方形组成的四联通路径。

请你输出在这\(k\)次切割后，路径上正方形的边长。

如果不论怎么切都不能找出一条四联通的边长相同的正方形路径，或者这个正方形不能被切割\(k\)次，输出 `NO`。

## 说明/提示
\(1 \leq t \leq 10^3\)
\(1 \leq n \leq 10^9\)
\(1 \leq k \leq 10^{18}\)

## 样例 #1
### 输入
```
3
1 1
2 2
2 12
```
### 输出
```
YES 0
YES 1
NO
```

### 算法分类
数学

### 综合分析与结论
这几道题解的核心思路都是先对\(n\)的大小进行分类讨论，对于\(n > 31\)的情况，都发现可以通过特定方式满足切割次数要求并找到路径，直接输出结果。对于\(1 \leq n \leq 31\)的情况，通过枚举路径上正方形的边长，计算出最少和最多切割次数，并判断给定的\(k\)是否在这个范围内来确定是否有解。不同题解在计算最少和最多切割次数的方式及公式推导上略有不同，但本质思路一致。

### 所选的题解
- **作者：Siyuan（5星）**
  - **关键亮点**：思路清晰，对\(n\)不同范围的情况分析详细，给出了最少和最多切割次数的具体计算方法及公式推导，代码简洁明了，时间复杂度分析准确。
  - **重点代码**：
```cpp
#include <cstdio>

long long pw[35];

int check(int n,long long k) {
    for(int i=0;i<n;++i) {
        int p=n-i;
        long long l=0;
        for(int j=1;j<=p;++j) l+=(1LL<<j)-1;
        if(l>k) continue;
        long long r=pw[n]-((1LL<<(p+1))-1)*pw[i];
        if(r<k) continue;
        return i;
    }
    return -1;
}
int main() {
    int T;
    for(int i=1;i<=32;++i) pw[i]=4LL*pw[i-1]+1;
    for(scanf("%d",&T);T--;) {
        int n;
        long long k;
        scanf("%d%I64d",&n,&k);
        if(n>31) {
            printf("YES %d\n",n-1);
        } else {
            int ans=check(n,k);
            if(ans<0) puts("NO"); else printf("YES %d\n",ans);
        }
    }
    return 0;
}
```
核心实现思想：通过`check`函数枚举路径上正方形边长对应的指数\(i\)，计算最少切割次数`l`和最多切割次数`r`，判断`k`是否在这个范围内，若在则返回`i`，否则返回 -1 。主函数根据`n`的大小调用`check`函数并输出相应结果。
- **作者：waauto（4星）**
  - **关键亮点**：数学推导详细，给出了切割次数的数学公式，在复杂度分析上提到了可优化到\(O(\log n)\)，虽然未在代码中实现，但思路有一定启发性。
  - **重点代码**：
```cpp
inline void mian(){
	ll n,k;
	cin>>n>>k;
	if(n>31){
		cout<<"YES "<<n-1<<endl;
		return;
	}
	else {
		F(i,0,n)if(k>=(1ll<<(n-i+1))-2-n+i and k+((1ll<<(n-i+1))-1)*(((1ll<<(2*i))-1)/3)<=((1ll<<(2*n))-1)/3){
				cout<<"YES "<<i<<endl;
				return;
			}
		cout<<"NO\n";
		return;
	}
}
```
核心实现思想：先判断\(n\)是否大于31 ，若是直接输出结果。否则枚举路径上正方形边长对应的指数`i`，根据数学公式判断`k`是否在最少和最多切割次数范围内，若在则输出`YES`及`i`，否则输出`NO`。
- **作者：ouuan（4星）**
  - **关键亮点**：通过先考虑从左下角走到右下角再走到右上角这种路径方式，简化问题。对无法进行\(k\)次操作的情况分析清晰，预处理出多种所需数据，代码逻辑清晰。
  - **重点代码**：
```cpp
#include <cstdio>
#include <iostream>

using namespace std;

long long i,t,n,k,a[40],b[40];

int main()
{
	cin>>t;
	
	a[1]=1;
	b[1]=2;
	
	for (i=2;i<=32;++i)
	{
		a[i]=a[i-1]*4;
		b[i]=b[i-1]*2;
		a[i-1]+=a[i-2];
		b[i-1]+=b[i-2]-1;
	}
	
	while (t--)
	{
		cin>>n>>k;
		if (n>31)
		{
			cout<<"YES "<<n-1<<endl; 
		}
		else if (k>a[n])
		{
			puts("NO");
		}
		else
		{
			for (i=1;i<=n;++i)
			{
				if (k>=b[i]&&k<=a[i]+a[n-i]*((1<<i)-1)*((1<<i)-1))
				{
					break;
				}
			}
			if (i>n)
			{
				puts("NO"); 
			}
			else
			{
				cout<<"YES "<<n-i<<endl;
			}
		}
	}
	
	return 0;
}
```
核心实现思想：预处理出将大正方形全部变成特定小正方形所需操作次数`a[i]`和造出特定边长正方形构成通路所需最少操作数`b[i]`。根据`n`和`k`的关系，通过循环判断`k`是否在满足条件的范围内，从而输出相应结果。

### 最优关键思路或技巧
1. **对\(n\)范围分类讨论**：当\(n > 31\)时，利用切割一次后对部分区域可进行大量切割的特性简化问题。
2. **枚举边长并计算切割次数范围**：对于\(1 \leq n \leq 31\)，通过枚举路径上正方形边长，计算最少和最多切割次数范围来判断是否满足条件，这种数学分析的方式有效解决问题。

### 可拓展思路
同类型题通常围绕图形的分割与构造，结合特定条件判断是否可行。类似算法套路是先分析数据范围，找到特殊情况简化问题，再通过枚举、数学计算等方式解决一般情况。

### 洛谷相似题目
1. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)
2. [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)
3. [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)

### 个人心得
无。

---
处理用时：61.66秒
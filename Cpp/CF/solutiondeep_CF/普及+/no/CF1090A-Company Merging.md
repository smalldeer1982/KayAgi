# 题目信息

# Company Merging

## 题目描述

一个由n(1≤n≤2·10^5)个公司组成的企业，每个公司中有mi(1≤m≤2·10^5)个员工，每个公司员工都有工资(≤10^9)。现在，公司老板想要将这n个公司合并，合并的规则为：保证每个公司的最高工资相等，并且工资只能增不能减，一个公司中的员工的工资必须同时增加相同的钱数。

现在老板想要知道最少增加多少钱的工资可以将这些公司合并。

## 说明/提示

第一家公司工资不变，第二家公司所有人工资加2，变为{4,3}，第三家工资都加3，变为{4,4,4}，共需2+2+3+3+3=13块钱。

## 样例 #1

### 输入

```
3
2 4 3
2 2 1
3 1 1 1
```

### 输出

```
13
```

# AI分析结果

### 题目内容
# 公司合并

## 题目描述
一个由n(1≤n≤2·10^5)个公司组成的企业，每个公司中有mi(1≤m≤2·10^5)个员工，每个公司员工都有工资(≤10^9)。现在，公司老板想要将这n个公司合并，合并的规则为：保证每个公司的最高工资相等，并且工资只能增不能减，一个公司中的员工的工资必须同时增加相同的钱数。

现在老板想要知道最少增加多少钱的工资可以将这些公司合并。

## 说明/提示
第一家公司工资不变，第二家公司所有人工资加2，变为{4,3}，第三家工资都加3，变为{4,4,4}，共需2+2+3+3+3=13块钱。

## 样例 #1
### 输入
```
3
2 4 3
2 2 1
3 1 1 1
```
### 输出
```
13
```
• **算法分类**：贪心
• **综合分析与结论**：这几道题解思路基本一致，都基于贪心策略，即让每个公司的最高工资达到所有公司中的最高工资，这样能保证增加的工资总数最少。各题解主要差异在于代码实现细节，如变量命名、数据结构使用、输入输出方式等。
• **所选的题解**
  - **作者：BZHZS (5星)**
    - **关键亮点**：思路清晰简洁，代码结构明了，直接按照贪心思路实现，先找出所有公司的最高工资，再计算每个公司达到该最高工资所需增加的费用并累加。变量命名直观，如`maxx`表示所有公司在一起的最高工资。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 2*1e5+10;
ll n, ans, maxx, can;
ll a[N], sum[N];

int main() {
    cin >> n;
    for (ll i=1; i<=n; i++) {
        cin >> sum[i];
        for (int j=1; j<=sum[i]; j++) {
            cin >> can;
            a[i] = max (a[i], can);
        }
        maxx = max (maxx, a[i]);
    }
    for (ll i=1; i<=n; i++)
        ans = ans + sum[i]*(maxx-a[i]);
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：先通过循环读取每个公司人数及员工工资，找出每个公司的最高工资`a[i]`并更新全局最高工资`maxx`，最后再次循环，计算每个公司达到全局最高工资需增加的费用并累加到`ans`。
  - **作者：Graphcity (4星)**
    - **关键亮点**：先阐述思路中的两个关键性质，即合并后增加工资数只与公司最高工资相关以及最终各公司工资向最高工资公司看齐且增加总量不变，逻辑清晰。代码使用结构体存储公司人数和最高工资，并进行排序，使代码结构较清晰。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=int(2e5);

inline int read() {
    char ch=getchar();
    int f=1,x=0;
    while(ch>'9' || ch<'0') {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9') {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int n;
long long ans;
struct Node{int a,b;} k[Maxn+5];
bool operator<(Node x,Node y) {return x.b<y.b;}

int main() {
    n=read();
    for(register int i=1;i<=n;++i) {
        k[i].a=read();
        for(register int j=1;j<=k[i].a;++j)
            k[i].b=max(k[i].b,read());
    }
    sort(k+1,k+n+1);
    for(register int i=1;i<=n;++i)
        ans=ans+1ll*k[i].a*(k[n].b-k[i].b);
    printf("%lld",ans);
    return 0;
}
```
    - **核心实现思想**：通过自定义结构体`Node`存储每个公司的人数`a`和最高工资`b`，利用重载`<`运算符按最高工资排序，最后循环累加每个公司达到最高工资公司的工资所需增加的费用。
  - **作者：Creator_157 (4星)**
    - **关键亮点**：题意和思路表述简单直接，代码实现简洁明了，使用结构体存储每组数据（公司）的最大值和个数，按照先找每组最大值、再找全局最大值、最后计算增加费用并累加的步骤实现。
    - **重点代码**：
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
long long m,n,ans,k,maxn;
struct node{
    long long ma,num;
}a[200005];
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>m;
        for(int j=1;j<=m;j++) {
            cin>>k;
            a[i].ma=max(a[i].ma,k);
        }
        a[i].num=m;
        maxn=max(maxn,a[i].ma);
    }
    for(int i=1;i<=n;i++) {
        int h=maxn-a[i].ma;
        ans+=h*a[i].num;
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：通过结构体`node`存储每个公司的最大值`ma`和人数`num`，先循环读取每个公司数据并找出最大值和记录人数，更新全局最大值`maxn`，最后循环计算每个公司达到全局最大值需增加的费用并累加到`ans`。
• **最优关键思路/技巧**：利用贪心思想，确定以所有公司中的最高工资为目标，让各公司向其看齐，从而简化计算过程。在代码实现上，合理使用数据结构（如结构体）来存储公司的人数和最高工资等信息，使代码逻辑更清晰。
• **拓展**：此类贪心类型题目通常是在满足一定条件下求最值。类似套路是先分析题目条件找到贪心策略，如本题根据“工资只能增不能减且每个公司最高工资相等”确定让各公司最高工资达到全局最高工资的策略。之后通过合适的数据结构和循环操作实现计算。
• **推荐题目**：
  - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：同样是贪心策略，通过合并操作求最小代价。
  - [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：根据贪心思路，按接水时间从小到大排序来计算总等待时间最小值。
  - [P1937 [USACO10MAR]Barn Allocation G](https://www.luogu.com.cn/problem/P1937)：利用贪心算法解决区间分配问题。
• **个人心得**：无。 

---
处理用时：71.30秒
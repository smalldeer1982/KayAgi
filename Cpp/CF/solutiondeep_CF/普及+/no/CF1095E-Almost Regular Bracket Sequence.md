# 题目信息

# Almost Regular Bracket Sequence

## 题目描述

You are given a bracket sequence $ s $ consisting of $ n $ opening '(' and closing ')' brackets.

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences "()()", "(())" are regular (the resulting expressions are: "(1)+(1)", "((1+1)+1)"), and ")(" and "(" are not.

You can change the type of some bracket $ s_i $ . It means that if $ s_i =  $ ')' then you can change it to '(' and vice versa.

Your task is to calculate the number of positions $ i $ such that if you change the type of the $ i $ -th bracket, then the resulting bracket sequence becomes regular.

## 样例 #1

### 输入

```
6
(((())
```

### 输出

```
3
```

## 样例 #2

### 输入

```
6
()()()
```

### 输出

```
0
```

## 样例 #3

### 输入

```
1
)
```

### 输出

```
0
```

## 样例 #4

### 输入

```
8
)))(((((
```

### 输出

```
0
```

# AI分析结果

### 题目内容
# 近乎规则的括号序列

## 题目描述
给定一个由 $n$ 个左括号 '(' 和右括号 ')' 组成的括号序列 $s$。

规则括号序列是指可以通过在序列原始字符之间插入字符 '1' 和 '+' 转换为正确算术表达式的括号序列。例如，括号序列 "()()"、"(())" 是规则的（得到的表达式分别为："(1)+(1)"、"((1 + 1)+1)"），而 ")(" 和 "(" 则不是。

你可以改变某些括号 $s_i$ 的类型。这意味着如果 $s_i = $ ')'，则可以将其更改为 '('，反之亦然。

你的任务是计算满足以下条件的位置 $i$ 的数量：如果你改变第 $i$ 个括号的类型，那么得到的括号序列将变为规则的。

## 样例 #1
### 输入
```
6
(((())
```
### 输出
```
3
```

## 样例 #2
### 输入
```
6
()()()
```
### 输出
```
0
```

## 样例 #3
### 输入
```
1
)
```
### 输出
```
0
```

## 样例 #4
### 输入
```
8
)))(((((
```
### 输出
```
0
```

### 算法分类
前缀和

### 综合分析与结论
这些题解的核心思路都是利用前缀和来解决问题，将左括号视为1，右括号视为 - 1，通过对前缀和数组的分析来判断改变某个位置括号后序列是否合法。主要难点在于分析改变某一位置括号后对前后缀和的影响，并据此确定合法位置的条件。各题解在实现细节上略有不同，如计算前缀最小值、后缀最小值的方式，以及判断条件的具体写法等。

### 所选的题解
 - **作者：一扶苏一 (5星)**
    - **关键亮点**：思路清晰，详细分析了改变左括号和右括号的不同情况，并将条件转化为与原序列前缀和相关的判断，通过计算前缀最小值和后缀最小值实现 $O(1)$ 判断，代码实现简洁明了。
    - **重点代码**：
```cpp
for (rg int i = 1; i <= n; ++i) {
    if (MU[i] == '(') {
        if ((cnt[n] == 2) && (post[i] >= 2) && (pre[i - 1] >= 0)) ++ans;
    } else {
        if ((cnt[n] == -2) && (post[i] >= -2) && (pre[i - 1] >= 0)) ++ans;
    }
}
```
核心实现思想：遍历序列，根据当前括号类型以及序列整体的前缀和差值，结合前缀最小值和后缀最小值判断该位置是否满足条件，满足则答案加1。
 - **作者：F_Mu (4星)**
    - **关键亮点**：采用前缀和思想，对左右括号分别统计前缀和，分类讨论左括号比右括号多2个和少2个的情况，通过寻找满足特定前缀和条件的位置来计算答案，思路较为清晰。
    - **重点代码**：
```cpp
if (sum[n] == 2) {
    for (int i = 1; i <= n; ++i)
        if (sum[i] < 0) {
            cout << 0;
            return 0;
        }
    int l = n;
    for (; l > 0; --l)
        if (sum[l] == 1)
            break;
    cout << suml[n] - suml[l];
} else if (sum[n] == -2) {
    for (int i = 1; i <= n; ++i)
        if (sum[i] < -2) {
            cout << 0;
            return 0;
        }
    int l = 1;
    for (; l <= n; ++l)
        if (sum[l] == -1)
            break;
    cout << sumr[l];
} else
    cout << 0;
```
核心实现思想：根据序列最终前缀和判断所属情况，对于左括号多2个的情况，找到第一个前缀和为1的位置，计算其后的左括号数量；对于右括号多2个的情况，找到第一个前缀和为 - 1的位置，计算其前的右括号数量。
 - **作者：wnsyou (4星)**
    - **关键亮点**：通过图形辅助分析，直观地阐述了合法位置的条件，总结出不同情况下合法位置需满足的具体条件，利用前缀和数组和后缀最小值数组统计答案，逻辑清晰。
    - **重点代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (sum[n] == 2 && mi[i] >= 2 && s[i - 1] == '(') { 
        ans++;
    } else if (sum[n] == -2 && mi[i] >= -2 && s[i - 1] == ')') { 
        ans++;
    }
    if (sum[i] < 0) { 
        break;
    }
}
```
核心实现思想：遍历序列，依据序列总和判断情况，结合后缀最小值和当前括号类型判断该位置是否为合法位置，满足则答案加1，同时若前缀和出现小于0的情况则停止遍历。

### 最优关键思路或技巧
利用前缀和将括号序列问题转化为数值序列问题，通过分析改变某一位置括号对前后缀和的影响，总结出合法位置的判断条件。计算前缀最小值和后缀最小值，能够高效地进行合法性判断，优化了时间复杂度。

### 同类型题或类似算法套路拓展
此类题目通常围绕括号序列的合法性判断及相关变形展开。类似算法套路是将括号用数值表示，利用前缀和来记录和分析序列特征，通过对前缀和数组的操作（如求最值、遍历判断等）解决问题。

### 洛谷相似题目推荐
 - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：涉及图论中的最短路及计数问题，与本题类似之处在于都需要对特定路径或序列进行统计，可锻炼利用数据结构和算法分析问题的能力。
 - [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)：字符串相关问题，通过哈希算法处理字符串，和本题一样需要掌握特定的数据处理技巧来解决问题。
 - [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：递推类型题目，通过寻找规律和状态转移解决问题，与本题在分析问题、总结规律从而得出解决方案的思路上有相似之处。 

---
处理用时：86.55秒
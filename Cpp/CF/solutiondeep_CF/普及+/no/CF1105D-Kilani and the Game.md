# 题目信息

# Kilani and the Game

## 题目描述

有一个n行m列的棋盘和k个玩家，玩家从1到k编号。棋盘上每一格有可能是空格（用'.'表示）、墙（用'#'表示）或者某个玩家的城堡（用该玩家的编号表示）。从一个格子可以到任意一个与它有公共边的格子。

玩家i在一步操作内可以这样做：



1.找到所有与自己的任意一个城堡中间有一条长度不大于a[i]路线的空格（该路线上只能有空格和自己的城堡）。



2.把所有这样的格子都建成自己的城堡。

从玩家1开始，大家轮流操作。当任何人都无法执行操作时，游戏结束。

问：当游戏结束时，每个玩家分别有几座城堡？

## 样例 #1

### 输入

```
3 3 2
1 1
1..
...
..2
```

### 输出

```
6 3 
```

## 样例 #2

### 输入

```
3 4 4
1 1 1 1
....
#...
1234
```

### 输出

```
1 4 3 3 
```

# AI分析结果

### 题目分类
广度优先搜索 BFS

### 综合分析与结论
这些题解的核心思路都是按照题目要求进行模拟，使用 BFS 来扩展每个玩家的城堡。具体做法是为每个玩家开一个队列，存储当前玩家城堡的边界点，然后轮流进行扩展，直到所有玩家都无法再扩展为止。

各题解的主要区别在于实现细节，如队列的管理、扩展步数的控制、边界条件的判断等。大部分题解都注意到了时间复杂度的优化，避免重复扩展，保证每个点最多被访问一次，从而将时间复杂度控制在 $O(nm)$。

### 所选题解
- **作者：pzc2004 (赞：7)  4星**
    - **关键亮点**：思路清晰，代码注释详细，使用两个队列分别记录当前回合要遍历的点和下一回合的起点，便于实现每回合的扩展。
- **作者：hsfzLZH1 (赞：6)  4星**
    - **关键亮点**：对时间复杂度的分析和优化有清晰的阐述，通过避免重复扩展保证了时间复杂度为 $O(nm)$，代码结构简洁。
- **作者：Christopher_Yan (赞：1)  4星**
    - **关键亮点**：对注意事项有明确的提示，如处理玩家有多个城堡的情况和避免无效扩展，防止 TLE。

### 重点代码
#### pzc2004 的代码核心实现
```cpp
while(1) // 开始模拟
{
    q1[i]=q2[i]; // 每个回合开始时将队列2中的点丢入队列1
    while(!q2[i].empty()) q2[i].pop(); // 清空队列2
    while(!q1[i].empty()) // 开始广搜
    {
        sb kkk=q1[i].front();
        q1[i].pop();
        if(kkk.s==0){q2[i].push(sb{kkk.a,kkk.b,v[i]});continue;} // 如果移动不了了就将该点推入队列2，作为下一回合的起点
        if(a[kkk.a-1][kkk.b]==-2){cas[i]++;s--;if(s==0)break;q1[i].push(sb{kkk.a-1,kkk.b,kkk.s-1});a[kkk.a-1][kkk.b]=i;} // 如果上下左右还未遍历就遍历,并将空格数减一，将该玩家的城堡数+1
        if(a[kkk.a][kkk.b-1]==-2){cas[i]++;s--;if(s==0)break;q1[i].push(sb{kkk.a,kkk.b-1,kkk.s-1});a[kkk.a][kkk.b-1]=i;}
        if(a[kkk.a+1][kkk.b]==-2){cas[i]++;s--;if(s==0)break;q1[i].push(sb{kkk.a+1,kkk.b,kkk.s-1});a[kkk.a+1][kkk.b]=i;}
        if(a[kkk.a][kkk.b+1]==-2){cas[i]++;s--;if(s==0)break;q1[i].push(sb{kkk.a,kkk.b+1,kkk.s-1});a[kkk.a][kkk.b+1]=i;}
    }
    if(s==0) break; // 如果没有空格了就退出
    i=i%p+1; // 换成下一个玩家
    l++; // 循环次数+1
    if(l==10000000) break; // 游戏次数不可能超过10000000，因此如果超出就说明是玩家被墙卡住了，直接退出防TLE
}
```
**核心思想**：通过两个队列实现每回合的扩展，每次从队列 1 中取出点进行扩展，将无法继续扩展的点放入队列 2 作为下一回合的起点，直到没有空格或达到最大循环次数。

#### hsfzLZH1 的代码核心实现
```cpp
while(1)
{
    bool tf=true;
    for(int i=1;i<=p;i++) if(!q[i].empty()) tf=false;
    if(tf) break;
    for(int i=1;i<=p;i++) if(!q[i].empty())
    {
        int t=s[i];
        while(t--)
        {
            if(q[i].empty()) break;
            int col=q[i].front().t;
            while(!q[i].empty())
            {
                x=q[i].front();
                if(x.t!=col) break;
                q[i].pop();
                for(int j=0;j<4;j++)
                {
                    int tx=x.x+dx[j],ty=x.y+dy[j];
                    if(mp[tx][ty]=='.')
                    {
                        mp[tx][ty]=i+'0';
                        ans[i]++;
                        q[i].push((node){tx,ty,col+1});
                    }
                }
            }
        }
    }
}
```
**核心思想**：不断循环，直到所有队列都为空。对于每个非空队列，按照玩家的速度扩展若干步，每次扩展时将可到达的空格标记为该玩家的城堡并加入队列。

#### Christopher_Yan 的代码核心实现
```cpp
inline void BFS(int now, int ste)
{
    if (us[now]) return;
    if (Q[now].empty()) ++cnt, us[now] = 1;
    while (!Q[now].empty())
    {
        u = Q[now].front();
        if (u.lev != ste) return;
        Q[now].pop();
        for (int i = 0; i < 4; ++i)
        {
            int nx = u.x + dx[i];
            int ny = u.y + dy[i];
            if (vis[nx][ny]) continue;
            vis[nx][ny] = 1, f[nx][ny] = now, 
            Q[now].push((Node){ste + 1, nx, ny});
        }
    }
}

for (; cnt < p;)
{
    for (int col = 1; col <= p; ++col)
        for (int i = 1; i <= s[col]; ++i)
            if (us[col]) break;
            else BFS(col, ns[col]), ++ns[col];
}
```
**核心思想**：定义 BFS 函数进行扩展，每次扩展一层点。通过循环不断调用 BFS 函数，直到所有玩家都无法扩展。

### 最优关键思路或技巧
- 为每个玩家开一个队列，方便管理每个玩家的城堡边界点，实现轮流扩展。
- 记录每个点是否被访问过，避免重复扩展，保证时间复杂度为 $O(nm)$。
- 当某个玩家的队列空了，标记该玩家不再扩展，避免无效的循环操作，防止 TLE。

### 拓展思路
同类型题或类似算法套路：
- 地图上的区域扩展问题，如洪水填充、病毒扩散等，都可以使用 BFS 来模拟扩展过程。
- 多起点的搜索问题，通过为每个起点维护一个队列，实现多起点的同步搜索。

### 推荐题目
- P1090 [NOIP2004 提高组] 合并果子
- P1162 填涂颜色
- P1443 马的遍历

### 个人心得摘录与总结
- **Christopher_Yan**：注意一个玩家不止有一个城堡，且一旦有一个队列空了，就标记下来这个玩家，以后不要扩展，否则循环 $s[i]$ 次会导致 TLE。总结：要仔细读题，处理好细节，避免不必要的计算。

---
处理用时：54.73秒
# 题目信息

# Array and Segments (Easy version)

## 题目描述

给定你一个长度为 $n$ 的数组 $a$，再给定你 $m$ 对数字 $[l_i,r_i]$。你可以选择其中的几对数字作为两个端点，再将数组 $a$ 中的两个端点内的数字全部减一。（例如现有一对 $[l_i,r_i]$ 为 $[1,3]$ ，而数组 $a$ 为 `1 2 3 4 5`，若使用这对 $[l_i,r_i]$ 数组就会变成 `0 1 2 4 5`）

现在请你求出怎样使得数组 $a$ 中的最大值减去最小值最大。

## 样例 #1

### 输入

```
5 4
2 -2 3 1 2
1 3
4 5
2 5
1 3
```

### 输出

```
6
2
1 4 
```

## 样例 #2

### 输入

```
5 4
2 -2 3 1 4
3 5
3 4
2 4
2 5
```

### 输出

```
7
2
3 2 
```

## 样例 #3

### 输入

```
1 0
1000000
```

### 输出

```
0
0

```

# AI分析结果

### 题目翻译
#### 数组与线段（简单版本）

#### 题目描述
给定一个长度为 $n$ 的数组 $a$，再给定 $m$ 对数字 $[l_i, r_i]$。你可以选择其中几对数字作为两个端点，然后将数组 $a$ 中这两个端点内的数字全部减一。（例如，现有一对 $[l_i, r_i]$ 为 $[1, 3]$，而数组 $a$ 为 `1 2 3 4 5`，若使用这对 $[l_i, r_i]$，数组就会变成 `0 1 2 4 5`）

现在请你求出怎样操作能使数组 $a$ 中的最大值减去最小值的差最大。

#### 样例 #1
##### 输入
```
5 4
2 -2 3 1 2
1 3
4 5
2 5
1 3
```
##### 输出
```
6
2
1 4 
```

#### 样例 #2
##### 输入
```
5 4
2 -2 3 1 4
3 5
3 4
2 4
2 5
```
##### 输出
```
7
2
3 2 
```

#### 样例 #3
##### 输入
```
1 0
1000000
```
##### 输出
```
0
0
```

### 算法分类
枚举

### 综合分析与结论
这些题解主要围绕枚举的思路来解决问题，通过不同的枚举对象（如最小值、最大值等），结合差分、线段树等数据结构和算法来优化时间复杂度。各题解的思路和实现方式各有不同：
- **枚举最小值**：通过枚举数组中的每个数作为最小值，使用包含该最小值的线段进行区间修改，最后计算最大值与最小值的差，如 liruixiong0101 和 nikangle 的题解，使用差分优化区间修改。
- **枚举最大值**：枚举数组中的每个数作为最大值，执行所有不包含该最大值的操作，再得到最小值，计算极差，如 whiteqwq、wmrqwq 和二叉苹果树的题解，使用线段树维护区间最值。
- **暴力枚举**：通过三层循环分别枚举最大值、最小值和区间，根据区间与最大值、最小值的关系选择是否操作，如 yaaaaaan 的题解。
- **离散化**：考虑枚举最大值不动，将区间上的坐标离散化，预处理每段初始的最大/最小值，然后暴力执行操作，如 andyli 的题解。

### 所选的题解
- **liruixiong0101（5星）**
    - **关键亮点**：思路清晰，先分析暴力做法的不可行性，再提出枚举最小值的思路，并使用差分优化区间修改，时间复杂度为 $O(n^2)$，代码可读性高。
    - **核心代码**：
```cpp
int get(int x){
    int d[N] = {};
    for(int i = 1; i <= n; i++){
        d[i] = a[i] - a[i - 1];
    }
    for(int i = 1; i <= m; i++){
        if(l[i] <= x && r[i] >= x){
            d[r[i] + 1]++ , d[l[i]]--;
        }
    }
    int maxn = INT_MIN , minn = INT_MAX;
    for(int i = 1; i <= n; i++){
        d[i] += d[i - 1];
        maxn = max(maxn , d[i]);
        minn = min(minn , d[i]);
    }
    return maxn - minn;
}
```
    - **核心实现思想**：`get` 函数用于计算以第 $x$ 个数为最小值时的最大差值。首先初始化差分数组，然后对于包含 $x$ 的线段进行区间修改，最后通过差分数组还原原数组并找出最大值和最小值，返回它们的差值。
- **whiteqwq（4星）**
    - **关键亮点**：不仅给出了 Easy Version 的 $O(nq\log n)$ 解法，还提出了 Hard Version 的 $O(n + m\log n)$ 优化思路，使用线段树维护区间最值，代码实现较为完整。
    - **核心代码**：
```cpp
void update(int l,int r,int now,int L,int R,int v){
    if(L<=l&&r<=R){
        getlazy(now,v);
        return ;
    }
    int mid=(l+r)>>1;
    pushdown(now);
    if(L<=mid)
        update(l,mid,lc[now],L,R,v);
    if(mid<R)
        update(mid+1,r,rc[now],L,R,v);
    pushup(now);
}
```
    - **核心实现思想**：`update` 函数用于线段树的区间更新操作。如果当前区间完全包含在更新区间内，则直接更新节点信息；否则，递归更新左右子节点，并在更新前后进行 `pushdown` 和 `pushup` 操作。
- **nikangle（4星）**
    - **关键亮点**：详细解释了思路并给出证明，使用差分优化时间复杂度，代码简洁明了。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    cnt=0;
    x=0;
    lmax=-100000000;
    lmin=100000000;
    for(int j=1;j<=n;j++){
        c[j]=a[j]-a[j-1];//维护差分数组
    }
    for(int j=1;j<=m;j++){
        if(q[j].y>=i&&q[j].x<=i){//如果第i个位置在第j个区间里
            c[q[j].x]--;
            c[q[j].y+1]++;
            lxz[++cnt]=j;
        }
    }
    for(int j=1;j<=n;j++){//求出最大值与最小值
        x=x+c[j];
        lmax=max(lmax,x);
        lmin=min(lmin,x);
    }
    if(lmax-lmin>maxn){
        maxx=cnt;
        maxn=lmax-lmin;
        for(int j=1;j<=cnt;j++){
            maxs[j]=lxz[j];
        } 
    }
}
```
    - **核心实现思想**：通过枚举每个数作为最小值，对于包含该最小值的区间进行差分更新，然后还原原数组并找出最大值和最小值，更新最大差值和对应的操作区间。

### 最优关键思路或技巧
- **枚举优化**：通过枚举最小值或最大值，减少不必要的枚举情况，降低时间复杂度。
- **差分优化区间修改**：对于区间修改操作，使用差分数组可以将时间复杂度从 $O(n)$ 优化到 $O(1)$。
- **线段树维护区间最值**：使用线段树可以高效地进行区间修改和查询最值操作。

### 拓展思路
同类型题或类似算法套路：
- 区间修改和查询问题：可以使用差分、线段树、树状数组等数据结构来解决。
- 枚举优化问题：通过合理选择枚举对象，减少枚举的范围和次数。

### 推荐题目
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
- [P2357 守墓人](https://www.luogu.com.cn/problem/P2357)

### 个人心得
部分题解提到了使用差分优化区间修改，如 liruixiong0101 的题解感谢了 yqr123YQR 发现可以用差分做，这表明在解决区间修改问题时，差分是一种常用且有效的优化方法。同时，在使用线段树时，要注意 `pushdown` 和 `pushup` 操作的正确实现，以保证线段树的正确性。

---
处理用时：55.54秒
# 题目信息

# Draw!

## 题目描述

你在看一场足球赛，但是你并不知道比赛的全过程，只知道在比赛过程中出现过的几个比分



现在，请你编写一个程序，算出比赛之中可能出现过的平局次数的最大值。

## 样例 #1

### 输入

```
3
2 0
3 1
3 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
0 0
0 0
0 0
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1
5 4
```

### 输出

```
5
```

# AI分析结果

【题目内容】
# 平局次数统计

## 题目描述
你正在观看一场足球赛，但你并不清楚比赛的全过程，仅知道比赛过程中出现过的几个比分。

现在，请你编写一个程序，计算出比赛中可能出现过的平局次数的最大值。

## 样例 #1
### 输入
```
3
2 0
3 1
3 4
```
### 输出
```
2
```

## 样例 #2
### 输入
```
3
0 0
0 0
0 0
```
### 输出
```
1
```

## 样例 #3
### 输入
```
1
5 4
```
### 输出
```
5
```

【算法分类】
数学

【综合分析与结论】
这些题解大多围绕分类讨论的思路展开，通过比较相邻比分的大小关系来计算平局次数。不同题解的分类方式和具体计算方法略有差异，但核心思想都是根据上一轮和当前轮的比分情况来确定对平局次数的贡献。部分题解还考虑了重复计算的问题，通过添加变量进行去重处理。

【评分较高的题解】
- **da32s1da的题解（4星）**：
    - **亮点**：思路清晰，分类讨论明确，代码简洁，通过三种情况的分类讨论直接计算出平局次数，易于理解。
    - **核心代码**：
```cpp
#include<cstdio>
inline int max(int u,int v){return u>v?u:v;}
inline int min(int u,int v){return u<v?u:v;}
int n,a,b,c,d,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&c,&d);
        if(a==b)ans+=min(c,d)-a;
        if(a<b)ans+=min(d-b+1,max(c-b+1,0));
        if(a>b)ans+=min(c-a+1,max(d-a+1,0));
        a=c;b=d;
    }
    printf("%d\n",ans+1);//加上(0,0)
}
```
    - **核心思想**：设上一局为 $a,b$，本局为 $c,d$，分三种情况讨论：若 $a=b$，$Ans+=\min(c,d)-a$；若 $a<b$，$Ans+=\min(d-b+1,max(c-b+1,0))$；若 $a>b$，$Ans+=\min(c-a+1,max(d-a+1,0))$，最后加上 $(0,0)$ 这一次平局。

- **caibet的题解（4星）**：
    - **亮点**：将比分抽象成区间，通过求区间重叠部分来计算平局次数，思路新颖，同时考虑了重复计算的问题，通过添加 `last` 变量进行去重。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,sum=0;
    cin>>n;
    int px=0,py=0,x,y,last=-1;//通过迭代实现
    while(n--){
        cin>>x>>y;
        if(min(x,y)>=max(px,py)){//区间有重叠部分
            sum+=min(x,y)-max(px,py)+1;//求重叠部分大小
            if(max(px,py)==last) sum--;//去重
            last=min(x,y);//更新last
        }
        px=x;py=y;//迭代
    }
    cout<<sum<<endl;
    return 0;
}
```
    - **核心思想**：将相邻比分抽象成区间，若区间有重叠部分，则计算重叠部分的大小作为平局次数，若新的平局区间的左端点正好是 `last`，则将答案减一，避免重复计算。

- **yty2010的题解（4星）**：
    - **亮点**：分类讨论清晰，对每种情况都给出了具体的例子进行说明，易于理解，代码实现简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=1,prex,prey;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        cin>>x>>y;
        if(prex==prey)
            sum+=min(x,y)-prex;  //情况1
        if(prex!=prey)
            sum+=max(0,min(x,y)-max(prex,prey)+1);  //情况2
        prex=x;
        prey=y;             //更新上一组比分
    }
    cout<<sum;
}
```
    - **核心思想**：设 $prex,prey$ 表示上一组给出的比分，$x,y$ 表示当前比分，分两种情况讨论：若 $prex = prey$，则平局情况数为 $\min(x,y)-prex$；若 $prex \ne prey$，则平局情况数为 $\max(0,\min(x,y)-\max(prex,prey)+1)$。

【关键思路或技巧】
- 分类讨论：根据相邻比分的大小关系进行分类讨论，分别计算每种情况下的平局次数。
- 区间抽象：将比分抽象成区间，通过求区间重叠部分来计算平局次数。
- 去重处理：使用变量记录上一次计算的平局，避免重复计算。

【拓展思路】
同类型题目可能会有更多的条件限制或变化，例如增加比赛阶段的划分、不同阶段的平局规则不同等。解题时可以继续采用分类讨论的思想，根据不同的条件进行细致的分析。

【推荐题目】
- P1003 [铺地毯](https://www.luogu.com.cn/problem/P1003)：需要对矩形的覆盖情况进行分析，与本题中区间重叠的思路有相似之处。
- P1047 [校门外的树](https://www.luogu.com.cn/problem/P1047)：涉及区间的覆盖和统计，与本题中计算区间重叠部分的思想类似。
- P1090 [合并果子](https://www.luogu.com.cn/problem/P1090)：虽然算法不同，但也需要对数据进行分类处理和计算，锻炼分类讨论的思维能力。

【个人心得】
部分题解提到了注意重复计算的问题，如样例2中多次出现相同比分的情况，需要进行去重处理，这提醒我们在解题时要仔细考虑特殊情况，避免出现错误。

---
处理用时：43.81秒
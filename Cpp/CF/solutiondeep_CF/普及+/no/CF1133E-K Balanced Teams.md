# 题目信息

# K Balanced Teams

## 题目描述

*题目名称：旗鼓相当的队友Ⅱ*  

您是本地大学的教练，有$n$位选手在你这里学习，并且已知第$i$位的能力值为$a_i$。  

现在您需要挑选出若干位选手组成至多$k$支队伍。众所周知，参赛的人数越多，你的大学获胜的概率越大。所以，你需要使得你选出的至多$k$支（至少$1$支）**非空**队伍的**总人数**最多。但是，你知道**每支**队伍中队员们的实力应当*差不多*，这意味着对于**任意**一支队伍，不应当存在两名实力值相差超过$5$的选手。所有的队伍都是相互独立的（这意味着我们不考虑来自两只不同队伍的选手的实力值差距）。  

可能有的选手不属于任何一支队伍。  

您的任务是求出满足以上要求的至多$k$（至少$1$）支**非空**队伍的**总人数**。  

**如果您是一名Python选手，您可以考虑在提交代码时选择`PyPy`而不是`Python`**。

## 说明/提示

对于所有数据，$1 \leq k \leq n \leq 5000, 1 \leq a_i \leq 10^9$。  

**如果您是一名Python选手，您可以考虑在提交代码时选择`PyPy`而不是`Python`**。

## 样例 #1

### 输入

```
5 2
1 2 15 15 15
```

### 输出

```
5
```

## 样例 #2

### 输入

```
6 1
36 4 1 25 9 16
```

### 输出

```
2
```

## 样例 #3

### 输入

```
4 4
1 10 100 1000
```

### 输出

```
4
```

# AI分析结果

### 题目分类
动态规划

### 综合分析与结论
这些题解大多采用动态规划的思路来解决问题。首先对选手的能力值数组进行排序，这样能保证每个队伍的选手是连续的一段区间。然后定义状态，一般设 $dp_{i,j}$ 表示前 $i$ 个人分成 $j$ 组的最大人数。状态转移时，考虑第 $i$ 个人是否入选队伍，若不入选则 $dp_{i,j}=dp_{i - 1,j}$，若入选则找到满足条件的队首 $p$，$dp_{i,j}=\max(dp_{i - 1,j},dp_{p,j - 1}+i - p)$。不同题解的主要区别在于寻找队首 $p$ 的方式，有的采用暴力枚举，有的使用二分查找，还有的用双指针预处理。

### 所选题解
- 作者：米奇奇米 (赞：6)，4星
  - 关键亮点：思路清晰，代码简洁，详细阐述了状态定义、转移方程和答案统计方法，时间复杂度分析明确。
  - 核心代码：
```cpp
for ( int i=1;i<=n;i++ ) {
    int las=i;
    while(abs(h[las]-h[i])<=5 && las>=1) las--;
    for ( int j=1;j<=m;j++ ) {
        f[i][j]=f[i-1][j];
        f[i][j]=max(f[i][j],f[las][j-1]+i-las);
    }
}
for ( int i=1;i<=m;i++ ) ans=max(ans,f[n][i]);
```
  核心实现思想：先通过 while 循环找到队首 $las$，然后进行状态转移，最后统计答案。

- 作者：封禁用户 (赞：2)，4星
  - 关键亮点：使用二分查找优化了寻找队首的过程，将时间复杂度从 $O(n^2 k)$ 优化到 $O(n \log n k)$。
  - 核心代码：
```cpp
int minp(int q)
{
    int l = 1 , r = n , mid , ans;
    while(l <= r)
    {
        mid = (l + r) / 2;
        if(q - a[mid] <= 5)
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    return ans;
}
for(int i = 1 ; i <= n ; i++)
{
    for(int j = 1 ; j <= k ; j++)
    {
        tmp = minp(a[i]) - 1;
        dp[i][j] = max(dp[i - 1][j] , dp[tmp][j - 1] + i - tmp);
    }
}
```
  核心实现思想：通过二分查找函数 `minp` 找到队首，然后进行状态转移。

- 作者：YYen (赞：0)，4星
  - 关键亮点：使用双指针算法预处理出每个选手前方第一个与自己实力差距超过 5 的选手下标，将时间复杂度优化到 $O(nk)$。
  - 核心代码：
```cpp
// 预处理pre
int l = 0, r = 1;
while (r <= n)
{
    while (l + 1 < r && a[r] - a[l + 1] > 5) l++;
    pre[r] = l;
    r++;
}
for (int j = 1; j <= k; j++)
{
    for (int i = 1; i <= n; i++)
    {
        dp[j][i] = max(dp[j][i - 1], dp[j - 1][pre[i]] + i - pre[i]);
    }
}
```
  核心实现思想：使用双指针预处理出 `pre` 数组，然后进行状态转移。

### 最优关键思路或技巧
- 排序：先对选手的能力值数组进行排序，使得每个队伍的选手是连续的一段区间，方便后续处理。
- 动态规划：定义合适的状态和转移方程，通过状态转移来求解最大人数。
- 优化查找队首的方式：可以使用二分查找或双指针算法来优化寻找队首的过程，降低时间复杂度。

### 拓展思路
同类型题或类似算法套路：这类动态规划问题通常会涉及到区间划分和状态转移，在其他题目中可能会有不同的条件和限制。例如，可能会要求每组的人数有上限，或者每组的和有特定要求等。解题的关键还是要定义合适的状态和转移方程，根据具体条件进行调整。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，与本题的动态规划思想类似。
- [P1802 5 倍经验日](https://www.luogu.com.cn/problem/P1802)：也是动态规划问题，需要考虑不同选择的状态转移。
- [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：简单的动态规划入门题，有助于理解动态规划的状态转移过程。

### 个人心得
题解中未包含个人心得。

---
处理用时：39.27秒
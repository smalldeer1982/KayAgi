# 题目信息

# Lynyrd Skynyrd

## 题目描述

*题目名称：Lynyrd 与 Skynyrd*  





最近 Lynyrd 和 Skynyrd 去了一个商店，在那里 Lynyrd 买了一个长度为$n$的排列$p$，Skynyrd 买了一个一个长度为$m$的数列$a$，并且$a_i \in[1,n], a_i \in Z$。  



Lynyrd 和 Skynyrd 感到无聊，所以他们给了你$q$个询问，每个询问格式如同：“$a$的**子段**$[l, r]$是否有一个**子序列**$s$，满足$s$是$p$的一个循环移位？”请你回答这些询问。  



一个长度为$n$的*排列*是一个由$n$个整数组成的序列，满足从$1$到$n$的所有整数在其中恰好出现$1$次。



一个排列$(p_1, p_2, \ldots, p_n)$的*循环移位*是排列$(p_i, p_{i+1}, \ldots, p_n, p_1, p_2, \ldots, p_{i-1})$，其中$i \in [1, n]$。例如：排列$(2, 1, 3)$有$3$个显然的循环移位：$(2, 1, 3); (1, 3, 2); (3, 2, 1)$。



一个序列$a$的子段$[l, r]$的*子序列*是一个序列$a_{i_1}, a_{i_2}, \ldots a_{i_k}$，其中$l \leq i_1 < i_2 < \ldots < i_k \leq r$。

## 说明/提示

样例1中子段$[1, 5]$是$\underline1, 2, \underline3, 1, \underline2$，它包含的一个子序列$1, 3, 2$是给定排列的一个循环移位；子段$[2, 6]$包含的子序列$2, 1, 3$与给定排列等价；子段$[3, 5]$只有一个长度为$3$的子序列$3, 1, 2$，但是这不是给定序列的循环移位。  



样例2中所有可能的循环移位是$1, 2$和$2, 1$。子段$[1, 2]$是$1, 1$，不包含任何循环移位；子段$[2, 3]$是$1, 2$，是一个循环移位；子段$[3, 4]$是$2, 2$，它的所有子段中没有一个是给定排列的循环移位。

## 样例 #1

### 输入

```
3 6 3
2 1 3
1 2 3 1 2 3
1 5
2 6
3 5
```

### 输出

```
110
```

## 样例 #2

### 输入

```
2 4 3
2 1
1 1 2 2
1 2
2 3
3 4
```

### 输出

```
010
```

# AI分析结果

### 题目分类
图论

### 综合分析与结论
这些题解主要围绕如何判断给定区间内是否存在排列 $p$ 的循环移位子序列展开。大部分题解先将问题转化为寻找每个点的后继关系，构建图或树结构，再利用倍增、DFS 等方法处理点的跳跃，最后结合 ST 表或后缀最小值等数据结构来回答询问。

不同题解的主要区别在于处理后继关系和点跳跃的方式。部分题解采用线性复杂度的方法，如利用 DFS 结合栈来记录路径，避免了倍增的对数复杂度；而有些题解则使用倍增法，结合 ST 表来优化查询。

### 所选题解
- **作者：SSerxhs (赞：22)，4星**
    - **关键亮点**：思路清晰，通过线性构建序列自动机，将出边反向构建外向树，利用 DFS 结合栈的特性，避免了倍增的对数复杂度，实现了线性复杂度的解法。
- **作者：伟大的王夫子 (赞：8)，4星**
    - **关键亮点**：将问题转化为求点走 $n - 1$ 步后的位置，通过倒序枚举计算后继，构建树结构，利用回溯搜索遍历树，方便找出点走 $n - 1$ 步后的位置，代码可读性较高。
- **作者：Piwry (赞：0)，4星**
    - **关键亮点**：通过定义 $f(x)$ 函数，利用贪心策略选择最近的后继元素，将重复的计算合并，构建类似树的结构，使用 DFS 遍历，在 $O(n)$ 复杂度内完成预处理。

### 重点代码
#### SSerxhs 的题解
```cpp
// 构建出边
for (i=1;i<=m;i++)
{
    read(a[i]);pre[i]=lst[a[i]];lst[a[i]]=i;
    for (j=lst[inxt[a[i]]];(j)&&(c[j]==0);j=pre[j]) c[j]=i;
}
// 构建树
for (i=1;i<=m;i++) if (!c[i]) c[i]=m+1;
for (i=1;i<=m;i++) add(c[i],i);
// DFS 处理
dfs(m+1);
```
**核心实现思想**：先记录每个数字的前驱和后继关系，构建出边，再将出边反向构建树，最后通过 DFS 处理每个节点，记录其 $n - 1$ 级祖先。

#### 伟大的王夫子的题解
```cpp
// 计算后继
for (int i = m; i; --i) {
    int y = a[i] == n ? 1 : a[i] + 1;
    c[i] = b[y];
    b[a[i]] = min(b[a[i]], i);
}
// 构建树
for (int i = 1; i <= m; ++i) add(c[i], i);
// DFS 处理
dep[m + 1] = 1;
dfs(m + 1);
```
**核心实现思想**：倒序枚举计算每个点的后继，构建树结构，通过 DFS 遍历树，利用栈记录路径，方便找出点走 $n - 1$ 步后的位置。

#### Piwry 的题解
```cpp
// 构建图
for(int i =m-1; i >= 0; --i){
    addedge(last_pos[p_net[a[i]]], i);
    last_pos[a[i]] =i;
}
// DFS 处理
for(int i =m-1; i >= 0; --i)
    if(!vis[i])
        dfs(i, 0);
```
**核心实现思想**：倒序遍历数组，利用贪心策略选择最近的后继元素，构建图结构，通过 DFS 遍历图，计算 $f(x)$ 函数。

### 最优关键思路或技巧
- **贪心策略**：每个数字只考虑距离它最近的后继，可证明该贪心策略的正确性，能有效简化问题。
- **图论与树结构的运用**：将后继关系构建成图或树，利用树的性质（如祖先关系）来处理点的跳跃，方便计算和查询。
- **DFS 结合栈**：在 DFS 过程中使用栈记录路径，可快速找到节点的 $n - 1$ 级祖先，避免了倍增的对数复杂度。

### 拓展思路
同类型题或类似算法套路：
- 子序列匹配问题：判断一个序列是否包含另一个序列的子序列或循环子序列，可参考本题的贪心和图论思路。
- 树上路径问题：在树结构上进行路径查询或计算，可利用 DFS、倍增等方法处理节点的跳跃。

### 推荐题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：涉及子矩阵的判断和计算，与子序列问题有一定相似性。
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：可构建图结构，利用拓扑排序或 DFS 处理任务的先后关系。
- [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)：涉及图的遍历和节点状态的更新，与图论相关。

### 个人心得摘录与总结
- **_•́へ•́╬_**：自己想出了复杂度为 $O(n)$ 的方法，捣鼓了一天，说明在解题过程中需要不断尝试和探索。
- **SunnyYuan**：注意第 40 个点 $m < n$ 的情况，初始化时要选择合适的范围，提醒在解题时要注意边界条件和特殊情况。

---
处理用时：45.62秒
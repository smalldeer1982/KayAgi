# 题目信息

# Increasing Subsequence (hard version)

## 题目描述

给你一个长度为 n 的序列，每次取出当前序列中最左或最右的数字，每次取出的数都要严格大于上一次取出的数，求最多取出多少数字。

## 样例 #1

### 输入

```
5
1 2 4 3 2
```

### 输出

```
4
LRRR
```

## 样例 #2

### 输入

```
7
1 3 5 6 5 4 2
```

### 输出

```
6
LRLRRR
```

## 样例 #3

### 输入

```
3
2 2 2
```

### 输出

```
1
R
```

## 样例 #4

### 输入

```
4
1 2 4 3
```

### 输出

```
4
LLRR
```

# AI分析结果

【题目内容】
# 递增子序列（困难版本）

## 题目描述

给你一个长度为 n 的序列，每次取出当前序列中最左或最右的数字，每次取出的数都要严格大于上一次取出的数，求最多取出多少数字。

## 样例 #1

### 输入

```
5
1 2 4 3 2
```

### 输出

```
4
LRRR
```

## 样例 #2

### 输入

```
7
1 3 5 6 5 4 2
```

### 输出

```
6
LRLRRR
```

## 样例 #3

### 输入

```
3
2 2 2
```

### 输出

```
1
R
```

## 样例 #4

### 输入

```
4
1 2 4 3
```

### 输出

```
4
LLRR
```

【算法分类】
贪心

【综合分析与结论】
这些题解的核心思路基本一致，均采用贪心策略解决问题。算法要点在于使用双指针分别指向序列的左右两端，依据左右两端数字的大小关系以及与上一次取出数字的比较结果来决定取左还是取右。当左右两端数字相等时，是本题的难点，各题解的处理方式相同，即分别从左右两端开始计算能连续取出的递增数字个数，选择个数多的一端。

各题解的不同主要体现在代码实现细节上，如输入输出方式、变量命名、数据结构的使用等，但整体逻辑相同。

【所选的题解】
- L______（4星）：思路清晰，代码结构合理，注释详细，对各种情况的处理逻辑明确。
- Luo_gu_ykc（4星）：思路阐述清晰，代码简洁易懂，对特殊情况的处理有明确说明。
- Shanganze（4星）：不仅给出了代码，还对贪心策略进行了证明，逻辑严谨。

【重点代码】
#### L______的核心代码
```cpp
while(1){
    if((a[l]<=tmp && a[r]<=tmp) || r<l) break;
    if(a[l]<a[r]){
        if(a[l]>tmp){
            tmp=a[l];
            ans[++cnt]='L';
            l++;
        }
        else{
            tmp=a[r];
            ans[++cnt]='R';
            r--;
        }
    }
    else if(a[l]>a[r]){
        if(a[r]>tmp){
            tmp=a[r];
            ans[++cnt]='R';
            r--;
        }
        else{
            tmp=a[l];
            ans[++cnt]='L';
            l++;
        }
    }
    else{
        int tot1=0;
        for(int i=l+1;i<=r;i++){
            if(a[i]>a[i-1]) tot1++;
            else break;
        }
        int tot2=0;
        for(int i=r-1;i>=l;i--){
            if(a[i]>a[i+1]) tot2++;
            else break;
        }
        if(tot1>tot2){
            for(int i=l;i<=l+tot1;i++){
                ans[++cnt]='L';
            }
        }
        else{
            for(int i=r;i>=r-tot2;i--){
                ans[++cnt]='R';
            }
        }
        break;
    }
}
```
核心实现思想：使用双指针 `l` 和 `r` 分别指向序列的左右两端，`tmp` 记录上一次取出的数字。根据左右两端数字的大小关系和与 `tmp` 的比较结果决定取左还是取右，当左右两端数字相等时，分别计算从左右两端开始能连续取出的递增数字个数，选择个数多的一端。

#### Luo_gu_ykc的核心代码
```cpp
while(l <= r){
    if(a[l] > a[r]){ 
        if(a[r] > op){ 
            op = a[r]; 
            r--;
            s[len++] = 'R';
        } else if(a[l] > op){
            op = a[l];
            l++;
            s[len++] = 'L';
        } else { 
            break; 
        }
    } else if(a[l] < a[r]){
        if(a[l] > op){  
            op = a[l];
            l++;
            s[len++] = 'L';
        } else if(a[r] > op){
            op = a[r];
            r--;
            s[len++] = 'R';
        } else {
            break;
        }
    } else {
        int len1 = 0, len2 = 0;
        for(int i = l; i <= r && a[i - 1] < a[i]; i++){ 
            len1++; 
        }
        for(int i = r; i >= l && a[i] > a[i + 1]; i--){ 
            len2++;
        }
        if(len1 < len2){ 
            for(int i = r; i >= l && a[i] > a[i + 1]; i--){
                s[len++] = 'R'; 
            }
        } else {
            for(int i = l; i <= r && a[i - 1] < a[i]; i++){
                s[len++] = 'L';
            }
        }
        break; 
    }
}
```
核心实现思想：同样使用双指针 `l` 和 `r`，`op` 记录上一次取出的数字。根据左右两端数字的大小关系和与 `op` 的比较结果决定取左还是取右，当左右两端数字相等时，分别计算从左右两端开始能连续取出的递增数字个数，选择个数多的一端。

#### Shanganze的核心代码
```cpp
while(l<=r){
    if(x[l]<=last&&x[r]<=last)break;
    ans++;
    if(x[r]<=last&&x[l]>last){
        a+='L';
        l++;
        last=x[l-1];
    }
    else if(x[l]<=last&&x[r]>last){
        a+='R';
        r--;
        last=x[r+1];
    }
    else if(x[l]<x[r]){
        l++;
        a+='L';
        last=x[l-1];
    }
    else if(x[l]>x[r]){
        r--;
        a+='R';
        last=x[r+1];
    }
    else if(x[l]==x[r]){
        int p=0,pp=0,o=x[l],oo=x[r];
        for(int q=l+1;q<=r;q++){
            if(x[q]>o)p++,o=x[q];
            else break;
        }
        for(int q=r-1;r>=l;q--){
            if(x[q]>oo)pp++,oo=x[q];
            else break;
        }
        if(p>pp){
            l++;
            a+='L';
            last=x[l-1];
        }
        else{
            r--;
            a+='R';
            last=x[r+1];
        }
    }
}
```
核心实现思想：使用双指针 `l` 和 `r`，`last` 记录上一次取出的数字。根据左右两端数字的大小关系和与 `last` 的比较结果决定取左还是取右，当左右两端数字相等时，分别计算从左右两端开始能连续取出的递增数字个数，选择个数多的一端。

【关键思路或技巧】
- 双指针法：使用双指针分别指向序列的左右两端，方便比较左右两端的数字。
- 贪心策略：优先选择较小的数字，以增加后续选择的可能性。
- 特殊情况处理：当左右两端数字相等时，分别计算从左右两端开始能连续取出的递增数字个数，选择个数多的一端。

【拓展思路】
同类型题可以是在不同条件下的序列选择问题，例如每次选择的数字要满足特定的数学关系，或者选择的数字个数有一定限制等。类似算法套路可以是在其他场景下使用双指针和贪心策略，如数组的区间操作、字符串的匹配等。

【推荐题目】
- P1090 [NOIP2004 提高组] 合并果子
- P1223 排队接水
- P2240 【深基12.例1】部分背包问题

【个人心得】
- 断清秋：记录了一个弱智错误，用数组模拟双端队列时要判断两次左右端点值相等的情况，否则会 WA on #17。这提醒我们在处理特殊情况时要考虑全面，避免遗漏。
- Derpy：提醒注意在左右操作对答案的贡献一样时优先从右边操作，如 1 1 这样的数就得输出 1 R。这说明在实现代码时要注意细节，按照题目要求处理特殊情况。

---
处理用时：55.51秒
# 题目信息

# Vasya And Array

## 题目描述

```Vasya```有一个数组$a[1...n]$

你从来没听说过这个数组，但```Vasya```会告诉你 $m$ 条关于这个数组的信息。每条信息包含三个参数$t_i,l_i,r_i(0\leq t_i \leq 1 ,1 \leq l_i < r_i \leq n)$，其含义分别为：

- 如果 $t_i=1$ 则说明子数组$a[l_i...r_i]$ 是一个不降序列

- 如果 $t_i=0$ 则说明子数组$a[l_i...r_i]$ 不是一个不降序列。一个数组 $a$ **不是一个不降序列**说明存在两个相邻元素$a[i] ,a[i+1]$使得$a[i]>a[i+1]$

举个栗子：假设$a=[2,1,1,3,2]$ ，然后 ```Vasya``` 告诉你：

$t_1=1,l_1=2,r_1=4$，意思是 $a[2...4]=[1,1,3]$是一个不降序列

$t_1=0,l_1=4,r_1=5$，意思是 $a[4...5]=[3,2]$不是一个不降序列
$t_1=0,l_1=3,r_1=5$，意思是 $a[4...5]=[1,3,2]$不是一个不降序列

然而就算```Vasya``` 告诉你这么多条件，你依然不会知道数组 $a$，但是请你找出一种可能的情况。

## 样例 #1

### 输入

```
7 4
1 1 3
1 2 5
0 5 6
1 6 7
```

### 输出

```
YES
1 2 2 3 5 4 4
```

## 样例 #2

### 输入

```
4 2
1 1 4
0 2 3
```

### 输出

```
NO
```

# AI分析结果

【题目内容】
# Vasya和数组

## 题目描述
Vasya有一个数组$a[1...n]$。你从未听说过这个数组，但Vasya会告诉你$m$条关于这个数组的信息。每条信息包含三个参数$t_i, l_i, r_i (0\leq t_i \leq 1, 1 \leq l_i < r_i \leq n)$，其含义分别为：
- 如果$t_i = 1$，则说明子数组$a[l_i...r_i]$是一个不降序列。
- 如果$t_i = 0$，则说明子数组$a[l_i...r_i]$不是一个不降序列。一个数组$a$ **不是一个不降序列** 意味着存在两个相邻元素$a[i], a[i + 1]$使得$a[i] > a[i + 1]$。

举个例子：假设$a = [2, 1, 1, 3, 2]$，然后Vasya告诉你：
$t_1 = 1, l_1 = 2, r_1 = 4$，意思是$a[2...4] = [1, 1, 3]$是一个不降序列。
$t_1 = 0, l_1 = 4, r_1 = 5$，意思是$a[4...5] = [3, 2]$不是一个不降序列。
$t_1 = 0, l_1 = 3, r_1 = 5$，意思是$a[3...5] = [1, 3, 2]$不是一个不降序列。

然而，即使Vasya告诉你这么多条件，你仍然不会知道数组$a$，但是请你找出一种可能的情况。

## 样例 #1
### 输入
```
7 4
1 1 3
1 2 5
0 5 6
1 6 7
```
### 输出
```
YES
1 2 2 3 5 4 4
```

## 样例 #2
### 输入
```
4 2
1 1 4
0 2 3
```
### 输出
```
NO
```

【算法分类】
构造

【综合分析与结论】
这些题解的核心思路都是先处理$t = 1$的区间（不降序列），再检查$t = 0$的区间（非不降序列）是否与之前的处理矛盾，若不矛盾则构造出一个满足条件的数组。不同题解在具体实现上有所差异，如使用差分、前缀和、并查集等不同的数据结构和算法。

| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| emptysetvvvv | 用$mark$数组标记$a[i]$与$a[i + 1]$的大小关系，通过差分和前缀和处理区间，检查$t = 0$区间是否矛盾 | 差分、前缀和 | 高效处理区间标记和判断矛盾 | 4星 |
| zcxnb | 设$z$数组表示$a[i]$与$a[i + 1]$的关系，先处理$t = 1$区间，再检查$t = 0$区间 | 暴力修改和判断 | 处理区间关系和判断合法性 | 3星 |
| 伟大的王夫子 | 构造差分数组$b_i = a_i - a_{i - 1}$，处理$t = 1$和$t = 0$的情况 | 差分数组 | 判断大小关系和矛盾 | 3星 |
| 世末OIer | 先构造一个满足$t = 0$的数组，再处理$t = 1$的区间，最后检查合法性 | 模拟构造 | 构造满足条件的数组和检查合法性 | 3星 |
| Imakf | 把点拆成两个，调整区间赋值和检查合法性的方式 | 拆点 | 解决区间连接问题 | 3星 |
| songhn | 用并查集处理连续的$t = 1$区间，构造满足条件的数组 | 并查集 | 统计连续区间和构造数组 | 3星 |
| xlqs23 | 用标记数组标记$t = 1$区间，检查$t = 0$区间是否矛盾，构造答案数组 | 标记数组 | 判断矛盾和构造数组 | 3星 |
| _蒟蒻__ | 先处理$t = 1$区间，假设其他区间为下降，检查$t = 0$区间 | 暴力枚举和检查 | 处理区间和检查条件 | 3星 |
| Frozencode | 用并查集维护$1$区间的左右端点，判断$0$区间是否为$1$区间子区间，构造差分数组 | 并查集、差分数组 | 判断子区间和构造数组 | 3星 |

【所选题解】
- emptysetvvvv（4星）
  - 关键亮点：使用差分和前缀和高效处理区间标记和判断矛盾，代码简洁。
  - 个人心得：作者称大部分题解是$O(n^2)$的，而此方法是$O(n)$且更好写，欢迎大家hack。

【重点代码】
```cpp
#include <iostream>
using namespace std;
int l[1005], r[1005], mark[1005], s[1005], n, m, cnt;
int main() {
    ios :: sync_with_stdio(false);
    cin >> n >> m;
    for(int i = 1, f, x, y; i <= m; i++) {
        cin >> f >> x >> y;
        if(f) ++mark[x], --mark[y];
        else l[++cnt] = x, r[cnt] = y; 
    }
    for(int i = 1; i < n; ++i) mark[i] += mark[i-1];
    for(int i = 1; i < n; ++i) mark[i] = mark[i] ? true : false, s[i] = mark[i] + s[i-1];	
    for(int i = 1; i <= cnt; ++i) 
        if(s[r[i]-1] - s[l[i]-1] == r[i] - l[i]) { puts("NO"); return 0; }
    puts("YES");
    for(int i = 1, num = n + 2; i <= n; i++) printf("%d ", mark[i-1] ? num : --num);
    return 0;
}
```
【核心实现思想】
1. 用$mark$数组标记$a[i]$是否必须小于等于$a[i + 1]$，对于$t = 1$的区间$[l_i, r_i]$，通过差分$mark[l_i]++, mark[r_i]--$标记。
2. 线性扫一遍累加得到每个点的$mark$值。
3. 对$mark$数组求前缀和，用于$O(1)$判断$t = 0$的区间是否矛盾。
4. 若不矛盾，根据$mark$值构造满足条件的数组。

【可拓展之处】
同类型题可能会有更多复杂的区间条件或更高的数据范围，可使用更高效的数据结构如线段树来处理区间操作。类似算法套路包括区间覆盖、区间查询等问题，都可以考虑使用差分、前缀和、并查集等方法。

【推荐题目】
1. P1182 数列分段 Section II
2. P2824 [HEOI2016/TJOI2016]排序
3. P3368 【模板】树状数组 2

【个人心得摘录】
- emptysetvvvv：小萌新$\varnothing$看了下，大部分题解都是$O(n^2)$的，对于本题的数据来说可以轻松$\mathtt{AC}$，**但是$O(n)$的方法也是存在的**，甚至更好写一点。写的很仓促，不知道有没有什么问题，欢迎诸位神犇 hack。
【总结】：作者发现大部分题解复杂度较高，提出了$O(n)$的方法，且表示代码更好写，同时希望大家帮忙检查代码是否有问题。 

---
处理用时：56.30秒
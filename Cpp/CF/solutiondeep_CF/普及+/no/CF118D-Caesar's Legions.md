# 题目信息

# Caesar's Legions

## 题目描述

凯撒大帝喜欢让他的士兵列队。假设他的军队有$n_1$个步兵和$n_2$个骑兵。他认为超过$k_1$个步兵连续排列或是超过$k_2$个骑兵连续排列是不优雅的。请找出共有多少种优雅的列队方案数。

注：所有$n_1+n_2$个士兵都要被排列，且所有步兵和骑兵都视作相同。

## 说明/提示

1表示步兵，2表示骑兵

第一个样例中，只有一种优雅的排列方式：121

第二个样例中，有五种优雅的排列方式：12122,12212,21212,21221,22121

## 样例 #1

### 输入

```
2 1 1 10
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 3 1 2
```

### 输出

```
5
```

## 样例 #3

### 输入

```
2 4 1 1
```

### 输出

```
0
```

# AI分析结果

### 题目内容
凯撒大帝喜欢让他的士兵列队。假设他的军队有$n_1$个步兵和$n_2$个骑兵。他认为超过$k_1$个步兵连续排列或是超过$k_2$个骑兵连续排列是不优雅的。请找出共有多少种优雅的列队方案数。

注：所有$n_1 + n_2$个士兵都要被排列，且所有步兵和骑兵都视作相同。

### 说明/提示
1表示步兵，2表示骑兵

第一个样例中，只有一种优雅的排列方式：121

第二个样例中，有五种优雅的排列方式：12122,12212,21212,21221,22121

### 样例 #1
#### 输入
```
2 1 1 10
```
#### 输出
```
1
```

### 样例 #2
#### 输入
```
2 3 1 2
```
#### 输出
```
5
```

### 样例 #3
#### 输入
```
2 4 1 1
```
#### 输出
```
0
```

### 算法分类
动态规划

### 题解综合分析与结论
这些题解主要围绕动态规划展开，通过定义不同的状态来解决问题。核心在于如何设计状态以及推导状态转移方程。不同题解的状态定义维度有所不同，从三维到四维都有，状态转移方程也因状态定义而异，但本质都是基于当前已排列的步兵和骑兵数量以及连续排列的情况来计算后续状态的方案数。部分题解还涉及到记忆化搜索的优化思路，将已计算的状态保存下来避免重复计算。

### 所选的题解
- **作者：Owen_codeisking（5星）**
    - **关键亮点**：思路清晰，详细阐述了状态定义和状态转移方程的推导过程，代码实现简洁明了。
    - **个人心得**：无
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int p = 1e8;
    int n, m, x, y, dp[110][110][11][2];

    int main()
    {
        scanf("%d%d%d%d", &n, &m, &x, &y);
        dp[1][0][1][0] = dp[0][1][1][1] = 1;
        register int i, j, k, ans = 0;
        for (i = 0; i <= n; i++)
            for (j = 0; j <= m; j++) {
                if (i > 0) {
                    for (k = 2; k <= x; k++)
                        dp[i][j][k][0] = dp[i - 1][j][k - 1][0];
                    for (k = 1; k <= y; k++)
                        dp[i][j][1][0] = (dp[i][j][1][0] + dp[i - 1][j][k][1]) % p;
                }
                if (j > 0) {
                    for (k = 2; k <= y; k++)
                        dp[i][j][k][1] = dp[i][j - 1][k - 1][1];
                    for (k = 1; k <= x; k++)
                        dp[i][j][1][1] = (dp[i][j][1][1] + dp[i][j - 1][k][0]) % p;
                }
            }
        for (i = 1; i <= x; i++) ans = (ans + dp[n][m][i][0]) % p;
        for (i = 1; i <= y; i++) ans = (ans + dp[n][m][i][1]) % p;
        printf("%d\n", ans);
        return 0;
    }
    ```
    - **核心代码说明**：定义四维数组`dp[i][j][k][0/1]`表示已用`i`个步兵，`j`个骑兵，连续结尾有`k`个步兵或骑兵的方案数。通过四层循环分别遍历步兵数、骑兵数、连续步兵数、连续骑兵数，依据状态转移方程更新`dp`数组，最后累加得到结果。
- **作者：ArcherHavetoLearnWhk（4星）**
    - **关键亮点**：状态定义简洁，采用三维数组，状态转移方程推导详细，代码易读性高。
    - **个人心得**：无
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n, m, o, p, dp[205][205][2], md = 1e8;
    int main() {
        cin >> n >> m >> o >> p;
        dp[0][0][0] = dp[0][0][1] = 1; //初始化
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                if (i + j == 0)continue; //如果i和j都等于0就跳过
                for (int k = 1; k <= min(o, i); k++)dp[i][j][0] = (dp[i][j][0] + dp[i - k][j][1]) % md;
                for (int k = 1; k <= min(p, j); k++)dp[i][j][1] = (dp[i][j][1] + dp[i][j - k][0]) % md; //状态转移方程
            }
        }
        cout << (dp[n][m][0] + dp[n][m][1]) % md; //输出最终方案数并取模
        return 0;
    }
    ```
    - **核心代码说明**：定义三维数组`dp[i][j][0/1]`表示排列`i`个步兵和`j`个骑兵，最后一个是步兵或骑兵的方案数。通过三层循环分别遍历步兵数、骑兵数、连续步兵或骑兵数，根据状态转移方程更新`dp`数组，最后输出结果。
- **作者：BreakPlus（4星）**
    - **关键亮点**：同样采用三维数组定义状态，对状态转移方程的解释清晰，代码简洁高效。
    - **个人心得**：无
    ```cpp
    #include<cstdio>
    using namespace std;
    int n1, n2, k1, k2, f[110][110][2];
    const int mod = 1e8;
    int main() {
        scanf("%d%d%d%d", &n1, &n2, &k1, &k2);
        f[0][0][0] = f[0][0][1] = 1;
        for (int i = 0; i <= n1; i++)
            for (int j = 0; j <= n2; j++) {
                if (i == 0 && j == 0) continue;
                for (int k = 1; k <= i && k <= k1; k++)
                    f[i][j][0] = (f[i][j][0] + f[i - k][j][1]) % mod;
                for (int k = 1; k <= j && k <= k2; k++)
                    f[i][j][1] = (f[i][j][1] + f[i][j - k][0]) % mod;
            }
        printf("%d\n", (f[n1][n2][0] + f[n1][n2][1]) % mod);
        return 0;
    }
    ```
    - **核心代码说明**：定义三维数组`f[i][j][0/1]`表示将`i`个步兵和`j`个骑兵排列，最后一个士兵是步兵或骑兵的方案总数。通过三层循环分别遍历步兵数、骑兵数、连续步兵或骑兵数，依据状态转移方程更新`f`数组，最后输出结果。

### 最优关键思路或技巧
在动态规划中，合理定义状态是关键。如上述高星题解，通过巧妙地选择状态维度，准确地描述问题的子状态，使得状态转移方程易于推导和实现。同时，利用数组记录已计算的状态，避免重复计算，提高算法效率。

### 拓展思路
此类题目属于排列计数类动态规划问题，类似套路可用于解决一些有条件限制的排列组合问题，例如在一定规则下的字符串排列方案数等。

### 相似知识点洛谷题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
3. [P1434 [SHOI2002]滑雪](https://www.luogu.com.cn/problem/P1434)

---
处理用时：76.25秒
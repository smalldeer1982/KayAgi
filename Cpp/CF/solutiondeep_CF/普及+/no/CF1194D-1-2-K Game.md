# 题目信息

# 1-2-K Game

## 题目描述

现有n个东西，每次可以取1个，2个或k个

Alice和Bob轮流取，且Alice先取

问谁是最后一个取的

每组数据有t个询问

## 样例 #1

### 输入

```
4
0 3
3 3
3 4
4 4
```

### 输出

```
Bob
Alice
Bob
Alice
```

# AI分析结果

【题目内容】
现有n个东西，每次可以取1个，2个或k个。
Alice和Bob轮流取，且Alice先取。
问谁是最后一个取的。
每组数据有t个询问。

【算法分类】
数学

【综合分析与结论】
这些题解均围绕博弈论展开，核心思路是依据不同的k值情况推导必胜和必败状态。
- **思路**：先分析无k时的情况，依据n对3取模的结果判断胜负；再分k不是3的倍数和k是3的倍数两种情况讨论k对结果的影响。
- **算法要点**：当k不是3的倍数时，结论与无k时相同；当k是3的倍数时，胜负情况以k + 1为周期循环，需将n对k + 1取模后判断。
- **解决难点**：关键在于理解k是3的倍数时胜负情况的周期性变化，以及如何通过取模简化判断过程。

【所选题解】
- 作者：逃课小姐MS (赞：10)，4星。关键亮点：思路清晰，通过列举不同k值下的胜负情况，直观地呈现出规律，代码简洁易懂。
- 作者：installb (赞：8)，4星。关键亮点：详细阐述了博弈论的基本原理，对每种情况的分析深入且有条理，代码逻辑清晰。
- 作者：yuzhechuan (赞：6)，4星。关键亮点：从无k情况逐步推导，对k的不同取值进行分类讨论，思路连贯，代码简洁明了。

【重点代码】
```cpp
// 逃课小姐MS的代码
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int i=1;i<=t;i++){
        int n,x;
        cin>>n>>x;
        if(x%3!=0){
            if(n%3==0) cout<<"Bob"<<endl;
            else cout<<"Alice"<<endl;
        }
        else{
            n%=(x+1);
            if(n%3==0&&n!=x) cout<<"Bob"<<endl;
            else cout<<"Alice"<<endl;
        }
    }
    return 0;
}
```
核心实现思想：先读取询问次数t，对于每次询问，读取n和k。根据k是否为3的倍数进行分类讨论，若k不是3的倍数，根据n对3取模的结果判断胜负；若k是3的倍数，先将n对k + 1取模，再根据取模结果判断胜负。

【可拓展之处】
同类型题如巴什博弈的其他变形题，可改变每次可取的数量或物品总数的限制条件等。类似算法套路包括对不同状态进行分类讨论，通过找规律和数学推导得出结论。

【推荐题目】
- P2197 【模板】nim游戏
- P1247 取火柴游戏
- P2964 [USACO09NOV]A Coin Game S

【个人心得】
- installb提到“反正比赛时候弄了好久”，总结出在博弈论题目中，要善于运用“能到达必败态的状态是必胜态，只能到达必胜态的状态是必败态”这一原理来推导结论。 

---
处理用时：25.05秒
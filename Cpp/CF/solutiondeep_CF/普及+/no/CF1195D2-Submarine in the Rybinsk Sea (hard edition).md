# 题目信息

# Submarine in the Rybinsk Sea (hard edition)

## 题目描述

这题与上一个题的不同之处仅在于存在使所有数字 $a_1,a_2,\dots,a_n$ 的无长度相等的约束。

$SIS$ 学生团队将乘坐潜水艇去旅游，他们的目标是位于大雷宾斯克 $(Rybinsk)$ 海底沉船中的古代宝藏。不幸的是，学生们不知道船的坐标，因此他们要求 $Meshanya$（一位世袭魔法师）来帮助他们。$Meshanya$ 同意帮助他们，但前提是他们得解决了 $Meshanya$ 的问题。

让我们用一个函数 $f(a_1a_2\dots a_{p-1}a_p,b_1b_2\dots b_{p-1}b_p)$ 来交替两个数字的各位数码，其中 $a_1,a_2,\dots,a_p$ 和 $b_1,b_2,\dots,b_p$ 是以十进制表示的两个整数的数码，不含前导零。

换句话说，函数 $f(x,y)$ 通过将数字 $x$ 和 $y$ 的各位数码从最低位数写到较高位数字，从数字 $y$ 开始，交替地插入数字 $x$ 和 $y$。该函数的结果也是从右到左构建的（即从较低的数字到较旧的数字）。如果其中一个参数（不妨设为 $x$）的数字已写完，则写下另一个参数（即 $y$）的剩余数字，下面我们来看几个例子熟悉一下。

$f(1111, 2222) = 12121212$

$f(7777, 888) = 7787878$

$f(33, 44444) = 4443434$

$f(555, 6) = 5556$

$f(111, 2222) = 2121212$

一般的，如果 $p \ge q$，那么 $f(a_1 \dots a_p, b_1 \dots b_q) = (a_1 a_2 \dots a_{p - q + 1} b_1 a_{p - q + 2} b_2 \dots a_{p - 1} b_{q - 1} a_p b_q)_{(10)}$
$Mishanya$ 为您提供一个由 $n$ 个整数组成的数组 $\{a_i\}$。你的任务是帮助学生们计算 $\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n} f(a_i, a_j) \mod 998244353$

## 样例 #1

### 输入

```
3
12 3 45
```

### 输出

```
12330```

## 样例 #2

### 输入

```
2
123 456
```

### 输出

```
1115598```

# AI分析结果

### 题目内容（已为中文，无需翻译）
# Submarine in the Rybinsk Sea (hard edition)

## 题目描述

这题与上一个题的不同之处仅在于存在使所有数字 $a_1,a_2,\dots,a_n$ 的无长度相等的约束。

$SIS$ 学生团队将乘坐潜水艇去旅游，他们的目标是位于大雷宾斯克 $(Rybinsk)$ 海底沉船中的古代宝藏。不幸的是，学生们不知道船的坐标，因此他们要求 $Meshanya$（一位世袭魔法师）来帮助他们。$Meshanya$ 同意帮助他们，但前提是他们得解决了 $Meshanya$ 的问题。

让我们用一个函数 $f(a_1a_2\dots a_{p - 1}a_p,b_1b_2\dots b_{p - 1}b_p)$ 来交替两个数字的各位数码，其中 $a_1,a_2,\dots,a_p$ 和 $b_1,b_2,\dots,b_p$ 是以十进制表示的两个整数的数码，不含前导零。

换句话说，函数 $f(x,y)$ 通过将数字 $x$ 和 $y$ 的各位数码从最低位数写到较高位数字，从数字 $y$ 开始，交替地插入数字 $x$ 和 $y$。该函数的结果也是从右到左构建的（即从较低的数字到较旧的数字）。如果其中一个参数（不妨设为 $x$）的数字已写完，则写下另一个参数（即 $y$）的剩余数字，下面我们来看几个例子熟悉一下。

$f(1111, 2222) = 12121212$

$f(7777, 888) = 7787878$

$f(33, 44444) = 4443434$

$f(555, 6) = 5556$

$f(111, 2222) = 2121212$

一般的，如果 $p \ge q$，那么 $f(a_1 \dots a_p, b_1 \dots b_q) = (a_1 a_2 \dots a_{p - q + 1} b_1 a_{p - q + 2} b_2 \dots a_{p - 1} b_{q - 1} a_p b_q)_{(10)}$
$Mishanya$ 为您提供一个由 $n$ 个整数组成的数组 $\{a_i\}$。你的任务是帮助学生们计算 $\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n} f(a_i, a_j) \mod 998244353$

## 样例 #1

### 输入

```
3
12 3 45
```

### 输出

```
12330
```

## 样例 #2

### 输入

```
2
123 456
```

### 输出

```
1115598
```

### 算法分类
数学

### 综合分析与结论
- **思路对比**：
    - Leap_Frog 的题解思路是对每个数的每一位分开考虑，发现其贡献仅和其他数的长度有关，通过开桶记录长度为 $x$ 的数的个数，然后统计贡献，并且因为 $F(a,b)\ne F(b,a)$，所以需要统计两次贡献。
    - Jerry_heng 的题解思路是对每个数单独算贡献，循环枚举与它进行运算的数的长度，然后确定那个数的位置，再乘以出现的数位对应的贡献，同样因为 $F(a,b)\ne F(b,a)$，所以也需要统计两次贡献。
- **算法要点对比**：
    - Leap_Frog 的题解使用桶记录数的长度，预先计算 $10$ 的幂，然后通过双重循环对每个数的每一位统计贡献。
    - Jerry_heng 的题解通过双重循环枚举每个数和与之运算的数的长度，使用一个标志位 `flag` 来交替填充数位，计算贡献。
- **解决难点对比**：
    - 两者都需要解决如何处理不同长度的数进行交替组合的问题，以及如何高效统计所有组合的贡献并取模的问题。Leap_Frog 的题解从每一位的贡献角度出发，更注重数学推导；Jerry_heng 的题解从模拟交替组合的过程出发，更注重过程的实现。

### 题解评分
- Leap_Frog：3星。思路较清晰，代码简洁，但注释较少，对于一些关键步骤的解释不够详细。
- Jerry_heng：2星。代码较长，思路虽然好理解，但实现过程较为繁琐，效率可能不高。

由于所有题解都不足4星，给出通用建议与扩展思路：
- **通用建议**：在处理此类数学计算问题时，可以先分析每个元素的贡献，尝试找出规律，减少不必要的计算。同时，对于取模运算要注意避免溢出，可使用 `long long` 类型。
- **扩展思路**：同类型题可能会改变数字的组合方式，或者改变取模的数值，解题的关键仍然是分析每个元素的贡献，通过数学推导或模拟过程来计算结果。

### 重点代码及核心实现思想
#### Leap_Frog 的题解
```cpp
const int P = 998244353;
int n, a[100005], ln[100005], pw[55], cn[15], rs = 0;
inline int count(int x) { int r = 0; while (x) x /= 10, r++; return r; }
int main()
{
    read(n); for (int i = 1; i <= n; i++) read(a[i]), ln[i] = count(a[i]); // 计算每个数的长度
    pw[0] = 1; for (int i = 1; i <= 50; i++) pw[i] = 10ll * pw[i - 1] % P; // 预先计算 10 的幂
    for (int i = 1; i <= n; i++) cn[ln[i]]++; // 统计长度为 k 的数的个数
    for (int i = 1; i <= n; i++)
    { // 对每个数的每一位，统计贡献
        int g[15], x = a[i], gt = 0; while (x) g[gt++] = x % 10, x /= 10;
        for (int k = 0; k <= 10; k++) for (int j = 0; j < ln[i]; j++)
            rs = (rs + 1ll * (pw[j + min(j, k)] + pw[j + min(j + 1, k)]) * g[j] % P * cn[k]) % P;
    }
    return printf("%d\n", rs), 0;
}
```
核心实现思想：先计算每个数的长度，然后统计不同长度的数的个数，接着对每个数的每一位，根据其位置和其他数的长度计算贡献，最后累加所有贡献并取模。

#### Jerry_heng 的题解
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int md = 998244353;
int n, sum[21], mx, ans, a[100010], siz[100010];
signed main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) {
        int x;
        scanf("%lld", &x); a[i] = x;
        while (x) siz[i]++, x /= 10;
        sum[siz[i]]++; // 统计数的位数
        mx = max(mx, siz[i]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= mx; j++) {
            if (!sum[j]) continue;
            int p1 = siz[i], p2 = j, d = 1, s = 0, x = a[i];
            bool flag = 0; // flag 表示填的是当前数，还是进行运算的另一个数
            while (p1 && p2) {
                if (!flag) s = (s + (x % 10) * d) % md, p1--, x /= 10;
                else p2--;
                flag ^= 1;
                d = d * 10 % md;
            }
            while (x) {
                s = (s + (x % 10) * d) % md;
                x /= 10;
                d = d * 10 % md;
            }
            ans = (ans + sum[j] * s) % md;
        }
        for (int j = 1; j <= mx; j++) {
            if (!sum[j]) continue;
            int p1 = siz[i], p2 = j, d = 1, s = 0, x = a[i];
            bool flag = 1;
            while (p1 && p2) {
                if (!flag) s = (s + (x % 10) * d) % md, p1--, x /= 10;
                else p2--;
                flag ^= 1;
                d = d * 10 % md;
            }
            while (x) {
                s = (s + (x % 10) * d) % md;
                x /= 10;
                d = d * 10 % md;
            }
            ans = (ans + sum[j] * s) % md;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```
核心实现思想：先统计每个数的位数，然后对每个数，枚举与之运算的数的长度，使用标志位 `flag` 交替填充数位，计算每个组合的贡献，最后累加所有贡献并取模。

### 推荐洛谷题目
1. [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)：考察高精度计算和数学运算。
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)：涉及高精度计算和数学推导。
3. [P1303 A*B Problem](https://www.luogu.com.cn/problem/P1303)：经典的高精度乘法问题。

### 个人心得摘录与总结
- Jerry_heng 提到“虽说代码较长，但非常好理解，还是最优解（公开的就两个）。难度应该不到绿。”，总结：作者认为自己的题解虽然代码长但好理解，且对题目难度有自己的判断。 

---
处理用时：64.26秒
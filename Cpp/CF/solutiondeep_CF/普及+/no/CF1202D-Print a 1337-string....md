# 题目信息

# Print a 1337-string...

## 题目描述

$PS:$子序列是能通过删除原序列一些元素并不更改原序列元素位置得到的序列。

给你一个数$n$，求出一个有$n$个子序列为$1337$的序列，序列长度不能大于$10^5$。

举个例子，序列$337133377$有$6$个子序列为$1337$

1. 337**133**3**7**7
1. 337**13**3**37**7
1. 337**1**3**337**7
1. 337**133**37**7**
1. 337**13**3**3**7**7**
1. 337**1**3**33**7**7**

$PS:$加粗为选中的元素

## 样例 #1

### 输入

```
2
6
1
```

### 输出

```
113337
1337```

# AI分析结果

### 题目分类
构造

### 综合分析与结论
这些题解的核心目标都是构造出一个长度不超过 $10^5$ 且有 $n$ 个子序列为 $1337$ 的序列。各题解的主要思路都是基于对 $1337$ 序列的变形，通过增加 $3$ 和 $7$ 的数量来控制子序列的数量。

皎月半洒花、installb、yinqf 三位作者的题解思路较为相似，都是先找到一个小于等于 $n$ 的最大的 $\frac{x(x - 1)}{2}$，然后通过在合适的位置添加 $7$ 来补足剩余的子序列数量。xuorange 作者的题解先尝试简单的构造方式，TLE 后改进思路，通过预处理和插入 $1$ 来构造序列。brealid 作者的题解则对 $n$ 的大小进行分类讨论，采用不同的构造方式。

### 评分较高的题解
- **皎月半洒花（4星）**
    - **亮点**：思路清晰，代码简洁，直接通过数学计算找到合适的 $x$ 和剩余的子序列数量，然后进行构造。
    - **关键代码**：
```cpp
#include <cmath>
#include <cstdio>
#include <iostream>

using namespace std ;
int N, T, L1, L2 ;

int main(){
    cin >> T ;
    while (T --){
        cin >> N ; int p = sqrt(2*N);
        for (int i = p ; i <= 2*N ; ++ i){
            if (i * (i - 1) > 2 * N) break ;
            L1 = i * (i - 1) / 2, L2 = N - L1, L1 = i ;
        }
        printf("133") ;
        for (int i = 1 ; i <= L2 ; ++ i) putchar('7') ;
        for (int i = 1 ; i <= L1 - 2 ; ++ i) putchar('3') ;
        printf("7\n") ;
    }
}
```
    - **核心思想**：先计算出一个可能的 $x$ 值，然后通过循环找到满足 $i * (i - 1) / 2 \leq N$ 的最大 $i$，$L1$ 记录 $i$，$L2$ 记录 $N - i * (i - 1) / 2$。先输出 `133`，再输出 $L2$ 个 `7`，接着输出 $L1 - 2$ 个 `3`，最后输出 `7`。
- **installb（4星）**
    - **亮点**：详细分析了不同构造方式的贡献，将两种构造方式结合起来，并且考虑了长度限制，对 $n$ 的取值进行了合理的选择。
    - **关键代码**：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long LL;
const LL INF = 0x3f3f3f3f3f3f3f3f;

LL n,m,k,T;
LL cac = 0;
LL a[500005] = {0};

int main(){
    ios::sync_with_stdio(false);
    cin >> T;
    LL K = 300; // K 就是上文的 n
    while(T --){
        cin >> n;
        LL t1 = K * (K + 1) / 2,t;
        t = n / t1;
        LL tmp = n - t1 * t;
        
        cout << "133";
        for(LL i = 1;i <= tmp;i ++) cout << '7';
        for(LL i = 1;i < K;i ++) cout << '3';
        for(LL i = 1;i <= t;i ++) cout << '7';
        cout << endl;
    }
    return 0;
}
```
    - **核心思想**：选择一个合适的 $K$ 值，计算出 $t1 = K * (K + 1) / 2$，$t = n / t1$，$tmp = n - t1 * t$。先输出 `133`，再输出 $tmp$ 个 `7`，接着输出 $K - 1$ 个 `3`，最后输出 $t$ 个 `7`。
- **yinqf（4星）**
    - **亮点**：思路清晰，对构造过程和长度限制进行了合理的分析，通过倒序循环找到合适的 $x$ 值。
    - **关键代码**：
```cpp
#include<bits/stdc++.h>
#define faster ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define LL long long
using namespace std;
const int N=1e5+5;
int T,n,num3,num7;
int main()
{
    faster;
    cin >> T;
    while(T--)
    {
        cin >> n;
        for(int i=44721;i>=2;i--)
        {
            if(i*(i-1)/2<=n)
            {
                num3=i;
                num7=n-i*(i-1)/2;
                break;
            }
        }
        cout << "133";
        for(int i=1;i<=num7;i++)
        {
            cout << '7';
        }
        for(int i=3;i<=num3;i++)
        {
            cout << '3';
        }
        cout << "7\n";
    }
    return 0;
}
```
    - **核心思想**：通过倒序循环从 $44721$ 到 $2$ 找到满足 $i * (i - 1) / 2 \leq n$ 的最大 $i$，$num3$ 记录 $i$，$num7$ 记录 $n - i * (i - 1) / 2$。先输出 `133`，再输出 $num7$ 个 `7`，接着输出 $num3 - 2$ 个 `3`，最后输出 `7`。

### 最优关键思路或技巧
- 利用组合数学的思想，计算 $C_n^2=\frac{n(n - 1)}{2}$ 来控制 $3$ 的选择方式，从而控制子序列的数量。
- 通过在 `133` 后面添加 `7` 来增加子序列的数量，每个 `7` 贡献一个子序列。
- 结合两种构造方式，先找到一个小于等于 $n$ 的最大的 $\frac{x(x - 1)}{2}$，再通过添加 `7` 来补足剩余的子序列数量。

### 可拓展之处
同类型的构造题通常需要根据题目要求，找到合适的构造方式来满足条件。可以通过分析不同元素的组合方式和贡献，来构造出满足特定条件的序列或结构。类似的算法套路包括对问题进行分类讨论，采用不同的构造方式；利用数学公式来计算和控制相关的数量等。

### 推荐洛谷题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及组合数学的思想，需要从 $n$ 个数中选出 $k$ 个数，计算它们的和为质数的情况。
2. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：需要构造出连续自然数的和等于给定值的情况。
3. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要构造出既是回文数又是质数的数。

### 个人心得摘录与总结
- **xuorange**：先尝试了简单的构造方式（只插入 $1$ 和 $7$），结果 TLE 了，意识到不能只插入效率低的 $1$ 和 $7$，应该增加 $3$ 的数量，从而改进思路。总结：在解题时可以先尝试简单的方法，当遇到问题时再分析原因，进行改进。

---
处理用时：51.81秒
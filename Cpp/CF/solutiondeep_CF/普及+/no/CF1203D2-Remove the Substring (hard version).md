# 题目信息

# Remove the Substring (hard version)

## 题目描述

**请注意：本题的简单版和困难版之间的唯一区别是字符串的长度限制。**  

给你一个字符串$s$和一个字符串$t$，两者都只包含小写字母。你可以通过从$s$中删除一些字符（不必连续，可不删除）而不改变剩余字符的顺序（换句话说，删除一些字符后$t$仍然是$s$的子序列），保证最初$t$是$s$的子序列。  
例如，字符串"`test`", "`tst`", "`tt`", "`et`"和""都是字符串"`test`"的子序列，而"`tset`", "`se`", "`contest`"都不是字符串"`test`"的子序列。   
您希望从s中删除一些最大可能长度的连续子序列，在删除后t仍将是s的子序列。  
如果要删除子串$s[l;r]$，则原字符串$s$将变化为$s_1s_2...s_{l-1}s_{r+1}s_{r+2}...s_{|s|-1}s_{|s|}$ （$|s|$为字符串$s$的长度）。  
找到可以删除的连续子字符串的最大可能长度，使得删除后$t$仍将是$s$的子序列。

## 样例 #1

### 输入

```
bbaba
bb
```

### 输出

```
3
```

## 样例 #2

### 输入

```
baaba
ab
```

### 输出

```
2
```

## 样例 #3

### 输入

```
abcde
abcde
```

### 输出

```
0
```

## 样例 #4

### 输入

```
asdfasdf
fasd
```

### 输出

```
3
```

# AI分析结果

### 题目翻译
#### 移除子字符串（困难版）

##### 题目描述
**请注意：本题的简单版和困难版之间的唯一区别是字符串的长度限制。**  

给你一个字符串 $s$ 和一个字符串 $t$，两者都只包含小写字母。你可以通过从 $s$ 中删除一些字符（不必连续，可不删除）而不改变剩余字符的顺序（换句话说，删除一些字符后 $t$ 仍然是 $s$ 的子序列），保证最初 $t$ 是 $s$ 的子序列。  
例如，字符串"`test`", "`tst`", "`tt`", "`et`" 和 "" 都是字符串 "`test`" 的子序列，而 "`tset`", "`se`", "`contest`" 都不是字符串 "`test`" 的子序列。   
您希望从 $s$ 中删除一些最大可能长度的连续子序列，在删除后 $t$ 仍将是 $s$ 的子序列。  
如果要删除子串 $s[l;r]$，则原字符串 $s$ 将变化为 $s_1s_2...s_{l - 1}s_{r + 1}s_{r + 2}...s_{|s| - 1}s_{|s|}$ （$|s|$ 为字符串 $s$ 的长度）。  
找到可以删除的连续子字符串的最大可能长度，使得删除后 $t$ 仍将是 $s$ 的子序列。

##### 样例 #1
###### 输入
```
bbaba
bb
```
###### 输出
```
3
```

##### 样例 #2
###### 输入
```
baaba
ab
```
###### 输出
```
2
```

##### 样例 #3
###### 输入
```
abcde
abcde
```
###### 输出
```
0
```

##### 样例 #4
###### 输入
```
asdfasdf
fasd
```
###### 输出
```
3
```

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是围绕如何在保证 $t$ 是 $s$ 的子序列的前提下，找到可删除的最长连续子串。大部分题解采用了预处理的方法，记录 $t$ 在 $s$ 中最左和最右的匹配位置，然后分情况讨论删除子串的方式，包括删除最左边、最右边和中间的子串。

### 高评分题解
- **学委（4星）**
    - **关键亮点**：思路清晰，通过维护两个数组 $f$ 和 $g$ 分别记录从前往后和从后往前的匹配情况，然后利用双指针枚举删除区间，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    f[i] = f[i - 1];
    if (s[i] == t[p])
        ++f[i], ++p;
}
p = m;
g[n + 1] = m + 1;
for (int i = n; i >= 1; --i) {
    g[i] = g[i + 1];
    if (s[i] == t[p])
        --g[i], --p;
}
p = 1;
for (int i = 0; i <= n; ++i) {
    if (p < i + 1)
        p = i + 1;
    while (p <= n and g[p] <= f[i] + 1)
        ++p;
    if (g[p] <= f[i] + 1)
        break;
    if (ans < p - i - 2)
        ans = p - i - 2;
}
```
- **__HHX__（4星）**
    - **关键亮点**：将删除情况分为三种，分别讨论并计算可删除的最大长度，代码简洁易懂。
    - **核心代码**：
```cpp
for (int i = 0, j = 0; i < ls && j < lt; i++) {
    if (s[i] == t[j]) {
        l[j++] = i;
    }
}
for (int i = ls - 1, j = lt - 1; i >= 0 && j >= 0; i--) {
    if (s[i] == t[j]) {
        r[j--] = i;
    }
}
ans = r[0];  // 前面删掉的数量
for (int i = 1; i < lt; i++) {
    ans = max(ans, r[i] - l[i - 1] - 1);  // 中间删掉的数量
}
ans = max(ans, ls - l[lt - 1] - 1);  // 后面删掉的数量
```
- **OuOu2021（4星）**
    - **关键亮点**：同样预处理匹配前缀数组 $pre$ 和匹配后缀数组 $suf$，然后枚举删除位置，利用双指针找到最大删除长度。
    - **核心代码**：
```cpp
for(int i = 0, j = 0;i < slen; ++i) {
    if(j<tlen && s[i] == t[j]) ++j;
    pre[i] = j;
}
for(int i = slen-1, j = tlen - 1; i >= 0; --i) {
    if(j>=0 && s[i] == t[j]) --j;
    suf[i] = j;
}
suf[slen]=tlen-1;
int ans = 0;
for(int i = 0, j = 0, tmp = 0; i <= slen; ++i){
    while(j <= slen && tmp >= suf[j]+1)++j;
    ans=max(ans, j - i - 1);
    tmp = pre[i];
} 
```

### 最优关键思路或技巧
- 预处理：通过从前往后和从后往前遍历字符串 $s$，记录 $t$ 在 $s$ 中最左和最右的匹配位置，为后续计算可删除的子串长度提供依据。
- 分类讨论：将删除子串的情况分为删除最左边、最右边和中间的子串，分别计算可删除的最大长度，最后取最大值。
- 双指针：在枚举删除位置时，利用双指针的单调性，将时间复杂度优化到 $O(n)$。

### 可拓展之处
同类型题目可能会有更多的限制条件，例如要求删除的子串必须包含某些特定字符，或者要求删除子串后 $t$ 在 $s$ 中的子序列数量满足一定条件。类似的算法套路可以应用到其他字符串处理问题中，如寻找最长公共子序列、子串匹配等。

### 推荐题目
- [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)
- [P1044 栈](https://www.luogu.com.cn/problem/P1044)
- [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录与总结
- **TEoS**：作者提到这题初赛让自己丢了6分，回来解决该题。通过分析发现，理解题意后思路就比较清晰，同时还对CCF代码中的一些判断进行了分析，提醒在做类似题目时要注意边界条件和特殊情况。 

---
处理用时：47.89秒
# 题目信息

# Boxers

## 题目描述

有$n$个拳击手，第$i$个拳击手的重量是$a_i$。 他们每个人都可以在比赛前将体重改变不超过1（体重不能等于零，也就是说，它必须保持正值）。，重量始终是整数。  
你需要根据人数选择最大的拳击队，使得团队中每名拳击手的重量都是唯一的。  
编写一个程序，对于给定的重量$a_i$，找出团队中最大可能的拳击手数量。经过一些改变后，所有拳击手的重量不超过150001。

## 样例 #1

### 输入

```
4
3 2 4 1
```

### 输出

```
4
```

## 样例 #2

### 输入

```
6
1 1 1 4 4 4
```

### 输出

```
5
```

# AI分析结果

【题目内容】
有$n$个拳击手，第$i$个拳击手的重量是$a_i$。 他们每个人都可以在比赛前将体重改变不超过1（体重不能等于零，也就是说，它必须保持正值），重量始终是整数。  
你需要根据人数选择最大的拳击队，使得团队中每名拳击手的重量都是唯一的。  
编写一个程序，对于给定的重量$a_i$，找出团队中最大可能的拳击手数量。经过一些改变后，所有拳击手的重量不超过150001。

【算法分类】
贪心

【综合分析与结论】
这些题解的核心思路都是通过合理安排拳击手的体重变化，使得最终团队中拳击手的体重唯一且人数最多，均采用贪心策略。
- **思路对比**：大部分题解是先统计各体重的人数，再按一定顺序（如从小到大）枚举体重，优先使用体重小1的，再使用体重正好的，再使用体重大1的；部分题解先对拳击手体重排序，再遍历处理每个拳击手的体重变化。还有题解将问题转化为二分图最大流问题求解。
- **算法要点**：多数题解使用桶（数组）记录各体重的人数或标记体重是否已被使用；二分图最大流的题解则通过建图和网络流算法求解。
- **解决难点**：主要难点在于如何合理安排拳击手的体重变化，以达到人数最多的目的。贪心策略中要确定体重变化的优先顺序，二分图最大流要正确建图。

【所选的题解】
- **作者：w1049 (赞：4)，4星**
    - **关键亮点**：思路清晰，代码简洁，直接使用桶记录体重人数，按体重从小到大枚举，贪心选择合适的体重。
- **作者：_Fontainebleau_ (赞：2)，4星**
    - **关键亮点**：详细解释了贪心策略的思考过程，对于不同体重人数的情况进行了分析。
- **作者：学委 (赞：0)，4星**
    - **关键亮点**：明确提出贪心思想，让小的重量尽可能小，以给后面的重量腾出空间。

【重点代码】
### 作者：w1049
```cpp
#include <cstdio>
int cnt[150010];
int n, ans, mx;
int main() {
    scanf("%d", &n);
    for (int i = 1, x; i <= n; i++)
        scanf("%d", &x), cnt[x]++, mx < x ? mx = x : 0;
    for (int i = 1; i <= mx + 1; i++) {
        if (cnt[i - 1])
            cnt[i - 1]--, ans++;
        else if (cnt[i])
            cnt[i]--, ans++;
        else if (cnt[i + 1])
            cnt[i + 1]--, ans++;
    }
    printf("%d", ans);
}
```
**核心实现思想**：先统计各体重的人数，再从1到最大体重枚举，优先使用体重小1的，再使用体重正好的，再使用体重大1的。

### 作者：_Fontainebleau_
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,mx=-2e9;
bool used[200005];
int a[200005];
int num[200005];
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)	a[i]=read(),num[a[i]]++,mx=max(mx,a[i]);
    if(num[1]==1)	used[1]=true,ans++;
    if(num[1]>=2)	used[1]=true,used[2]=true,ans++,ans++;
    for(int i=2;i<=200000;i++)
    {
        if(!num[i])	continue;
        if(num[i]&&!used[i-1])	used[i-1]=true,ans++,num[i]--;
        if(num[i]&&!used[i])	used[i]=true,ans++,num[i]--;
        if(num[i]&&!used[i+1])	used[i+1]=true,ans++,num[i]--;
    }
    printf("%d\n",ans);
    return 0;
}
```
**核心实现思想**：统计各体重人数，对体重1的情况特判，然后从2开始枚举体重，优先使用体重小1的，再使用体重正好的，再使用体重大1的。

### 作者：学委
```cpp
#include <cstdio>
#include <algorithm>
using std::sort;
 
const int N = 2e5 + 10;
 
int n, a[N], ans = 0;
int used[N];
 
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i)
    scanf("%d", &a[i]);
  sort(a + 1, a + n + 1);
  for (int i = 1; i <= n; ++i) {
    if (a[i] != 1 and not used[a[i] - 1])
      used[a[i] - 1] = 1, ++ans;
    else if (not used[a[i]])
      used[a[i]] = 1, ++ans;
    else if (not used[a[i] + 1])
      used[a[i] + 1] = 1, ++ans;
  }
  printf("%d\n", ans);
  return 0;
}
```
**核心实现思想**：先对拳击手体重排序，然后遍历每个拳击手，优先选择体重小1的，再选择体重正好的，最后选择体重大1的。

【最优关键思路或技巧】
- 使用桶（数组）记录各体重的人数或标记体重是否已被使用，方便快速判断和选择。
- 贪心策略：优先使用体重小1的，再使用体重正好的，再使用体重大1的，让小的重量尽可能小，给后面的重量腾出空间。

【可拓展之处】
同类型题可能会改变体重变化的规则，如可以改变的重量范围更大，或者有其他限制条件。类似算法套路可以应用于资源分配问题，在满足一定条件下，尽可能多地选择元素，使某个指标最优。

【推荐洛谷题目】
- P1094 [NOIP2007 普及组] 纪念品分组
- P1223 排队接水
- P2240 【深基12.例1】部分背包问题

【个人心得】
- **远辰**：提到以前刷题不看数据范围和空间限制会WA到起飞，现在应该注意正确率和效率，并且给出了从大到小和从小到大两种枚举重量的做法。总结为刷题要注重数据范围和效率，对于同一问题可以尝试不同的枚举顺序。

---
处理用时：46.83秒
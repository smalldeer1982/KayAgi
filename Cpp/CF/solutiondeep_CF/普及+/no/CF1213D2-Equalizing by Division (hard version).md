# 题目信息

# Equalizing by Division (hard version)

## 题目描述

简单版和困难版之间的唯一区别在于数组元素的数量。

给定一个数组$a$，包含$n$个整数。每次操作你可以选择任一$a_i$并且将其除$2$向下取整（也就是说，每次操作中你可以使$a_i:=\lfloor \frac{a_i}{2} \rfloor$）。

你可以对任何$a_i$进行任意次（可以是零次）操作。

你的任务是计算最小的操作次数使得至少$k$个数组中的数字相等。

别忘了在几次操作后可能会有$a_i=0$的情况出现，因此答案始终存在。

## 样例 #1

### 输入

```
5 3
1 2 2 4 5
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 3
1 2 3 4 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 3
1 2 3 3 3
```

### 输出

```
0
```

# AI分析结果

【题目内容】
# 通过除法使数组元素相等（困难版）

## 题目描述

简单版和困难版之间的唯一区别在于数组元素的数量。

给定一个数组 $a$，包含 $n$ 个整数。每次操作你可以选择任一 $a_i$ 并且将其除 $2$ 向下取整（也就是说，每次操作中你可以使 $a_i := \lfloor \frac{a_i}{2} \rfloor$）。

你可以对任何 $a_i$ 进行任意次（可以是零次）操作。

你的任务是计算最小的操作次数使得至少 $k$ 个数组中的数字相等。

别忘了在几次操作后可能会有 $a_i = 0$ 的情况出现，因此答案始终存在。

## 样例 #1

### 输入

```
5 3
1 2 2 4 5
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 3
1 2 3 4 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 3
1 2 3 3 3
```

### 输出

```
0
```

【算法分类】排序

【综合分析与结论】
这些题解的核心思路都是先找出每个数经过若干次除 2 操作后能变成的所有数以及对应的操作次数，然后统计每个目标数对应的操作次数总和，找出满足至少有 $k$ 个数能变成该目标数的最小操作次数总和。
- **思路对比**：大部分题解都是通过遍历数组，对每个数进行除 2 操作，记录操作次数和能变成的数；部分题解使用了不同的数据结构，如优先队列、`vector` 数组来存储信息。
- **算法要点**：多数题解先对数组进行排序，以保证得到最小的操作次数；部分题解使用了快读快写来优化输入输出。
- **解决难点**：主要难点在于如何高效地记录每个数能变成的数以及对应的操作次数，同时找出满足条件的最小操作次数。不同题解通过不同的数据结构和算法来解决这个问题。

【所选的题解】
- 作者：andyli (赞：3)，4星。关键亮点：思路清晰，代码简洁，通过简单的数组记录每个数变成目标数的次数和操作次数总和。
- 作者：Guess00 (赞：2)，4星。关键亮点：使用快读快写优化输入输出，在遍历过程中直接更新答案，减少了后续的遍历操作。
- 作者：A_Đark_Horcrux (赞：1)，4星。关键亮点：代码简洁，逻辑清晰，在更新操作次数和出现次数的同时，直接判断是否满足条件并更新答案。

【重点代码】
- **andyli的代码**：
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int maxn = 200005;

int A[maxn];  // 原序列
int cnts[maxn]; // cnts[i]表示变成所有数均变成i需要的次数
int cntc[maxn]; // cntc[i]表示变成i的数量
int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++)
        scanf("%d", &A[i]);
    sort(A + 1, A + n + 1);
    for (int i = 1; i <= n; i++) {
        int x = A[i], sum = 0;
        while (x) {
            if (cntc[x] < k)
                cntc[x]++, cnts[x] += sum;
            x /= 2;
            sum++;
        }
    }
    int ans = -1u / 2;
    for (int i = 1; i <= maxn; i++)
        if (cntc[i] >= k)
            ans = min(ans, cnts[i]);
    printf("%d\n", ans);
    return 0;
}
```
核心实现思想：先对数组排序，然后遍历数组，对每个数进行除 2 操作，记录变成每个数的次数和操作次数总和，最后找出满足条件的最小操作次数总和。
- **Guess00的代码**：
```cpp
#include <bits/stdc++.h>
#define MAXN 200005
#define inf 0x3f3f3f3f
using std::sort;
int n,k,i,ans=inf,a[MAXN],v[MAXN],t[MAXN];
//其中v数组表示每个数出现次数,t数组表示转换到这个数的步数总和 
inline void read(int &x)  //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
		if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)  //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n),read(k);
	for (i=1;i<=n;i++)
		read(a[i]);
	sort(a+1,a+n+1);   //排序确保答案最小 
	for (i=1;i<=n;i++)
	{
		int x=a[i],y=0;//y表示转换到其他数的步数 
		while (x)
		{
			v[x]++;
			t[x]+=y;
			ans=(v[x]==k && t[x]<ans)?t[x]:ans;
			//只统计等于k即可,大于k的情况答案定大于等于k的 
			y++;
			x/=2;
		}
	}
	print(ans);
	return 0;
} 
```
核心实现思想：使用快读快写，对数组排序后，遍历数组，对每个数进行除 2 操作，记录每个数的出现次数和操作次数总和，在遍历过程中直接更新答案。
- **A_Đark_Horcrux的代码**：
```cpp
//部分代码
int n,k,x,minn=2e9+7,i,a[N],s[N],b[N];//si表示目前数转化成i需要多少步 bi表示有多少个数能转化成i
int main()
{
	n=read(),k=read();
	for(i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1);//排序
	for(i=1;i<=n;i++)
	{
		int t=0,x=a[i];
		while(x)
		{
			s[x]+=t,b[x]++;//对现在的x更新s[x]和b[x]
			if(b[x]==k)//如果有恰好k个数能变为x
            minn=min(minn,s[x]);//更新答案
			t++,x/=2;//步数++，x变为原来1/2
		}
	}
	printf("%d\n",minn);
	return 0;
}
```
核心实现思想：对数组排序后，遍历数组，对每个数进行除 2 操作，记录每个数的操作次数和出现次数，在更新信息的同时直接判断是否满足条件并更新答案。

【关键思路或技巧】
- 先对数组进行排序，保证得到最小的操作次数。
- 使用数组、`vector` 数组、优先队列等数据结构记录每个数能变成的数以及对应的操作次数。
- 在遍历过程中直接更新答案，减少后续的遍历操作。

【拓展思路】
同类型题可以考虑改变操作规则，如将除 2 操作改为其他数学运算；或者改变条件，如要求变成的数满足其他特定条件。类似算法套路可以用于处理需要对数组元素进行某种操作并统计结果的问题。

【推荐题目】
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)

【个人心得】
- 孑彧：一开始想找一个数，然后让所有的数都降到它附近，然后再去统计答案，但是发现这样的时间复杂度会爆炸，所以需要优化，不去找一个数让别的数降到它，而是去统计出每一个可以到达的数，以及到达它的最小步数。
总结：在解题时，如果发现原思路复杂度过高，要及时考虑优化，尝试从不同角度思考问题。

---
处理用时：63.20秒
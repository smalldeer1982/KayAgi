# 题目信息

# Distinct Characters Queries

## 题目描述

You are given a string $ s $ consisting of lowercase Latin letters and $ q $ queries for this string.

Recall that the substring $ s[l; r] $ of the string $ s $ is the string $ s_l s_{l + 1} \dots s_r $ . For example, the substrings of "codeforces" are "code", "force", "f", "for", but not "coder" and "top".

There are two types of queries:

- $ 1~ pos~ c $ ( $ 1 \le pos \le |s| $ , $ c $ is lowercase Latin letter): replace $ s_{pos} $ with $ c $ (set $ s_{pos} := c $ );
- $ 2~ l~ r $ ( $ 1 \le l \le r \le |s| $ ): calculate the number of distinct characters in the substring $ s[l; r] $ .

## 样例 #1

### 输入

```
abacaba
5
2 1 4
1 4 b
1 5 b
2 4 6
2 1 7
```

### 输出

```
3
1
2
```

## 样例 #2

### 输入

```
dfcbbcfeeedbaea
15
1 6 e
1 4 b
2 6 14
1 7 b
1 12 c
2 6 8
2 1 6
1 7 c
1 2 f
1 10 a
2 7 9
1 10 a
1 14 b
1 1 f
2 1 11
```

### 输出

```
5
2
5
2
6
```

# AI分析结果

### 题目内容（中文重写）
# 不同字符查询

## 题目描述
给定一个由小写拉丁字母组成的字符串 $ s $，并针对该字符串有 $ q $ 次查询。

回顾一下，字符串 $ s $ 的子串 $ s[l; r] $ 是指字符串 $ s_l s_{l + 1} \dots s_r $。例如，“codeforces” 的子串有 “code”、“force”、“f”、“for”，但 “coder” 和 “top” 不是。

有两种类型的查询：
- $ 1~ pos~ c $（$ 1 \le pos \le |s| $，$ c $ 是小写拉丁字母）：将 $ s_{pos} $ 替换为 $ c $（即 $ s_{pos} := c $）；
- $ 2~ l~ r $（$ 1 \le l \le r \le |s| $）：计算子串 $ s[l; r] $ 中不同字符的数量。

## 样例 #1
### 输入
```
abacaba
5
2 1 4
1 4 b
1 5 b
2 4 6
2 1 7
```
### 输出
```
3
1
2
```

## 样例 #2
### 输入
```
dfcbbcfeeedbaea
15
1 6 e
1 4 b
2 6 14
1 7 b
1 12 c
2 6 8
2 1 6
1 7 c
1 2 f
1 10 a
2 7 9
1 10 a
1 14 b
1 1 f
2 1 11
```
### 输出
```
5
2
5
2
6
```

### 算法分类
树状数组

### 综合分析与结论
本题的核心是对字符串进行单点修改和区间查询不同字符数量的操作。由于小写字母只有 26 个，大部分题解的核心思路是利用数据结构来维护每个字符的出现情况，主要涉及树状数组、线段树、分块、二进制压缩、multiset、带修莫队等方法。

| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| woshishei | 开 26 个数组，分别为每一个字符个数的树状数组，单点修改时更新对应字符数量，区间查询时统计不为零的字符个数 | 树状数组的基本操作，包括 `add` 和 `sum` 函数 | 如何高效地进行单点修改和区间查询 | 4 星 |
| Katsura_Hinagiku | 使用线段树求解，`tree[i][k]` 表示 $ k $ 代表的这一段区间内，是否有 ASCII 码为 $ i + 48 $ 的字符，建树、修改、询问按正常的线段树操作 | 线段树的基本操作，包括 `pushup`、`build`、`modify` 和 `query` 函数 | 线段树的节点信息维护和合并 | 3 星 |
| 时间重洗 | 采用分块的思想，用 `l[i]` 表示区间 $ i $ 的起点，`r[i]` 表示终点，`belong[i]` 表示第 $ i $ 个字符属于哪一个区间，`num[i][j]` 表示在第 $ i $ 个区间中，有多少个 $ j $ 字母 | 分块的预处理和查询操作，包括区间的划分和字符数量的统计 | 分块的区间处理和字符数量的更新 | 3 星 |
| zhengrunzhe | 考虑二进制压缩，把 0(a)~25(z) 变成 $ 1<<0 $ 到 $ 1<<25 $，累计区间或和，修改就直接单点修改，查询就直接求区间或和，然后看这个或和里有几个 1 | 二进制压缩和线段树的结合，利用位运算进行区间合并 | 二进制压缩的实现和线段树的操作 | 3 星 |
| Linne | 对于每个字母开一个 `multiset`，维护其出现的位置，修改时在原字串和 `multiset` 里相应修改，查询时在 `multiset` 里二分找是否有 $ [l, r] $ 其中的一个位置 | `multiset` 的插入、删除和查找操作，利用二分查找提高效率 | `multiset` 的使用和二分查找的实现 | 3 星 |
| kouylan | 开 26 个树状数组，分别记录每一个字母的区间个数，修改时更新对应字母的区间个数，查询时统计不为零的字母个数 | 树状数组的基本操作，包括 `fix` 和 `ask` 函数 | 树状数组的更新和查询操作 | 3 星 |
| Smallbasic | 在线段树每个节点中维护一个 `lt` 数组，`lt[i]` 表示第 $ i $ 个字母出没出现过，查询时一边查询一边在建一棵线段树 | 线段树的节点信息维护和查询操作，包括 `update`、`build`、`modify` 和 `query` 函数 | 线段树的节点信息更新和查询过程 | 3 星 |
| Meatherm | 建 26 棵线段树，正常进行单点修改和区间查询操作，使用动态开点保证不会挂 | 动态开点线段树的基本操作，包括 `make`、`change` 和 `ask` 函数 | 动态开点线段树的实现和操作 | 3 星 |
| Tx_Lcy | 开 26 个树状数组记录每一个小写字母在每个区间内的个数，修改时更新对应字母的树状数组，查询时暴力查询 26 个树状数组 | 树状数组的基本操作，包括 `update` 和 `query` 函数 | 树状数组的更新和查询操作 | 3 星 |
| Naffygo | 使用带修莫队，在普通莫队的基础上多维护一维时间，根据时间进行修改操作 | 带修莫队的基本操作，包括排序、左右指针移动和时间的维护 | 带修莫队的实现和时间的处理 | 3 星 |
| littleseven | 开 26 颗树状数组，进行单点修改和区间查询操作 | 树状数组的基本操作，包括 `update` 和 `query` 函数 | 树状数组的更新和查询操作 | 3 星 |
| 开始新的记忆 | 用待修莫队实现，根据区间和时间进行修改和查询操作 | 待修莫队的基本操作，包括排序、左右指针移动和时间的维护 | 待修莫队的实现和时间的处理 | 3 星 |
| Ludo | 建立 26 个树状数组，统计和修改时根据字符的位置进行相应操作 | 树状数组的基本操作，包括 `modify` 和 `sum` 函数 | 树状数组的更新和查询操作 | 3 星 |

### 所选题解
- woshishei（4 星）
  - 关键亮点：思路清晰，代码简洁，使用树状数组实现单点修改和区间查询，时间复杂度为 $\Theta(kq\text{log}_2n)$，$k$ 为常数（字母数量，26）。

### 重点代码（woshishei）
```cpp
// 树状数组模板
int lowbit(int x){return x&(-x);}
void add(int ch,int x,int k)
{
    while(x<=len)
    {
        tree[ch][x]+=k;
        x+=lowbit(x);
    }
}
int sum(int ch,int x)
{
    int tot=0;
    while(x>0)
    {
        tot+=tree[ch][x];
        x-=lowbit(x);
    }
    return tot;
}
```
核心实现思想：`lowbit` 函数用于计算一个数的最低位 1 及其后的 0 连接成的二进制数对应的十进制数。`add` 函数用于更新树状数组，将指定位置的字符数量加上 $ k $。`sum` 函数用于计算树状数组中指定位置之前的字符数量之和。

### 最优关键思路或技巧
- 利用小写字母只有 26 个的特点，开 26 个树状数组或线段树来维护每个字符的出现情况，将单点修改和区间查询操作转化为对树状数组或线段树的操作，提高效率。
- 采用二进制压缩的方法，将字符的出现情况用二进制位表示，利用位运算进行区间合并，减少空间复杂度。
- 使用 `multiset` 维护每个字符的出现位置，利用二分查找提高查询效率。

### 拓展思路
同类型题或类似算法套路：
- 区间修改和区间查询问题，可以使用线段树的懒标记或树状数组的差分思想来解决。
- 动态区间查询问题，可以使用分块、莫队算法或动态开点线段树来解决。
- 字符串的其他操作问题，如字符串匹配、最长公共子串等，可以使用 KMP 算法、Trie 树、后缀数组等数据结构和算法来解决。

### 推荐洛谷题目
- P3374 【模板】树状数组 1：单点修改，区间查询。
- P3372 【模板】线段树 1：区间修改，区间查询。
- P1903 [国家集训队] 数颜色 / 维护队列：带修莫队的经典题目。

### 个人心得摘录与总结
- 时间重洗：在老师讲树状数组和线段树内容时没有好好听课，所以只能想别的方法，想到了暴力的优化——分块。总结：基础知识的学习很重要，同时也要学会灵活运用不同的算法和数据结构来解决问题。
- Linne：知道还能用很多 log 数据结构比如线段树平衡树，但认为自己的方法代码直观较短。总结：在选择算法和数据结构时，要综合考虑代码的复杂度、效率和可读性等因素。

---
处理用时：69.20秒
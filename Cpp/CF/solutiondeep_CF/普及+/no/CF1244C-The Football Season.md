# 题目信息

# The Football Season

## 题目描述

Berland Capital Team 比了 $n$ 场比赛，总得分为 $p$。已知胜一场得 $w$ 分，平一场得 $d$ 分，败一场不得分。

求任意一组 $(x,y,z)$ 使得如果 Berland Capital Team 胜 $x$ 场，平 $y$ 场，败 $z$ 场时总分为 $p$。如果不存在这样的三元组，输出 $-1$。

### 形式化题意

求下列方程组的任意一组非负整数解，无解输出 $-1$：

$$
\begin{cases}
x\cdot w+y\cdot d=p\\
x+y+z=n
\end{cases}
$$

## 样例 #1

### 输入

```
30 60 3 1
```

### 输出

```
17 9 4
```

## 样例 #2

### 输入

```
10 51 5 4
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
20 0 15 5
```

### 输出

```
0 0 20
```

# AI分析结果

### 题目翻译
# 足球赛季

## 题目描述
Berland首都球队进行了 $n$ 场比赛，总得分是 $p$ 分。已知胜一场得 $w$ 分，平一场得 $d$ 分，输一场不得分。

求任意一组 $(x,y,z)$ ，使得如果 Berland 首都球队胜 $x$ 场、平 $y$ 场、输 $z$ 场时总分为 $p$ 。如果不存在这样的三元组，输出 $-1$ 。

### 形式化题意
求下列方程组的任意一组非负整数解，无解则输出 $-1$ ：
$$
\begin{cases}
x\cdot w+y\cdot d=p\\
x+y+z=n
\end{cases}
$$

## 样例 #1
### 输入
```
30 60 3 1
```
### 输出
```
17 9 4
```

## 样例 #2
### 输入
```
10 51 5 4
```
### 输出
```
-1
```

## 样例 #3
### 输入
```
20 0 15 5
```
### 输出
```
0 0 20
```

### 算法分类
数学

### 综合分析与结论
这些题解主要围绕求解方程组 $\begin{cases}x\cdot w + y\cdot d = p\\x + y + z = n\end{cases}$ 的非负整数解展开。大部分题解都发现了直接用扩展欧几里得算法（exgcd）会爆 `long long` 的问题，进而采用枚举的方法。由于题目中 $d < w$ ，要使 $x + y$ 最小，只需要让 $y$ 最小，且若方程有非负整数解，$y$ 在 $[0, w)$ 中一定存在一个解，所以可以在这个范围内枚举 $y$ ，计算对应的 $x$ ，并判断 $x$ 和 $x + y$ 是否满足条件。部分题解也给出了扩展欧几里得算法的实现，但需要注意中间结果可能溢出的问题。

### 所选题解
- **AutumnKite（4星）**
    - **关键亮点**：思路清晰，直接指出问题本质是求 $ax + by = c$ 的一组 $x + y$ 最小的非负整数解，且说明了在 $a > b$ 时让 $y$ 最小的原因。代码简洁，直接枚举 $y$ ，时间复杂度为 $O(a)$ 。
    - **个人心得**：一开始用扩欧发现会爆 `long long` ，然后根据数据范围采用枚举的方法。
- **lyb666666（4星）**
    - **关键亮点**：详细推导了为什么只需要枚举 $y \in [0, w - 1]$ 即可得到最优解，逻辑严谨。代码实现清晰，通过枚举 $y$ 计算 $x$ 并判断条件。
    - **个人心得**：一开始用 exgcd 解不定方程最小解爆 `long long` 后，仔细读题发现不需要这么做，直接枚举即可。
- **寒鸽儿（4星）**
    - **关键亮点**：思路简洁明了，直接指出若使 $x + y$ 最小，$y \in [0, w)$ ，枚举 $y$ 求解。代码简洁易懂。
    - **个人心得**：直接套 exgcd 溢出后考虑暴力枚举。

### 重点代码
```cpp
// AutumnKite的代码
#include <cstdio>
long long n, p, a, b, x, y;
int main(){
    scanf("%lld%lld%lld%lld", &n, &p, &a, &b);
    while (y < a && (p - 1ll * b * y) % a) ++y;
    if (y == a) return puts("-1"), 0;
    x = (p - 1ll * b * y) / a;
    if (x < 0 || x + y > n) return puts("-1"), 0;
    printf("%lld %lld %lld\n", x, y, n - x - y);
}

// lyb666666的代码
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef long long ll;
ll n,p,w,d;
signed main(){
    cin>>n>>p>>w>>d;
    for(int y=0;y<w;y++){
        int left=p-y*d;
        if(left%w)continue;
        int x=left/w;
        if(x>=0&&x+y<=n){
            printf("%lld %lld %lld\n",x,y,n-x-y);
            return 0;
        }
    }
    puts("-1");
}

// 寒鸽儿的代码
#include <cstdio>
#define ll long long

using namespace std;

int main() {
    ll n, p, a, b, x, y;
    scanf("%lld %lld %lld %lld", &n, &p, &a, &b);
    for(y = 0; y < a; ++y) {
        if(!((p-b*y)%a)) {
            x = ( p - b * y ) / a;
            if(x + y > n || x < 0) {
                printf("-1\n");
            } else {
                printf("%lld %lld %lld\n", x, y, n - x - y);
            }
            return 0;
        }
    }
    printf("-1\n");
    return 0;
}
```
### 核心实现思想
这些代码的核心思想都是枚举 $y$ 的值，范围是 $[0, w)$ 。对于每个 $y$ ，计算 $p - y * d$ ，判断其是否能被 $w$ 整除，如果可以，则计算 $x = (p - y * d) / w$ ，并检查 $x$ 是否非负且 $x + y$ 是否小于等于 $n$ 。如果满足条件，则输出 $x$ 、$y$ 和 $n - x - y$ ；如果枚举完所有 $y$ 都没有找到满足条件的解，则输出 $-1$ 。

### 扩展思路
同类型题目可能会有不同的方程形式或约束条件，但解题思路类似，都是通过数学推导找到变量的取值范围，然后进行枚举或使用扩展欧几里得算法求解。例如，可能会有更多变量或更复杂的方程，需要进一步分析和化简。

### 推荐题目
1. [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)：同样涉及扩展欧几里得算法求解不定方程。
2. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)：求解线性同余方程，与本题的数学思想相关。
3. [P3811 乘法逆元](https://www.luogu.com.cn/problem/P3811)：涉及求逆元的问题，在本题的部分题解中也有应用。

### 个人心得总结
很多题解作者一开始都尝试使用扩展欧几里得算法求解，但遇到了中间结果溢出的问题。之后通过仔细分析题目条件和数据范围，发现可以通过枚举 $y$ 的值来简化问题，避免了溢出问题。这提醒我们在解题时要注意数据范围，当常规方法不可行时，要尝试从题目本身的特点出发寻找其他解法。

---
处理用时：54.73秒
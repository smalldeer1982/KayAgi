# 题目信息

# Equalizing Two Strings

## 题目描述

### 题意

给你两长度都为 $n$ 的小写字符串 $S, T$。

每次操作中你可以任选一个 $L (1\le L\le n)$，同时翻转 $S$ 中的任意一个长度为 $L$ 的子串和 $T$ 中任意一个长度为 $L$ 的子串。

请回答你是否能在若干次操作后使两字符串一样？

## 样例 #1

### 输入

```
4
4
abcd
abdc
5
ababa
baaba
4
asdf
asdg
4
abcd
badc
```

### 输出

```
NO
YES
NO
YES
```

# AI分析结果

### 题目分类
字符串

### 综合分析与结论
这些题解的核心思路一致，都是先判断两个字符串中各字符出现次数是否相同，若不同则无解；若存在重复字符则有解；若不存在重复字符，则判断两个字符串逆序对的奇偶性是否相同，相同则有解，不同则无解。各题解的主要区别在于实现细节和代码风格。

思路方面，都将原问题转化为同时交换相邻元素的问题，利用字符出现次数、重复字符和逆序对奇偶性来判断是否能使两个字符串相等。

算法要点上，都需要统计字符出现次数，部分使用树状数组求逆序对，部分采用暴力法求逆序对。

难点在于理解为什么可以将翻转操作转化为交换相邻元素，以及为什么在没有重复字符时逆序对奇偶性相同才有解。

### 所选题解
- **作者：81179332_ (赞：4)，4星**
    - 关键亮点：思路清晰，代码简洁，直接通过暴力法求逆序对，易于理解。
- **作者：Arghariza (赞：2)，4星**
    - 关键亮点：对逆序对奇偶性相同有解的情况给出了详细证明，逻辑严谨。
- **作者：Mr_Wu (赞：1)，4星**
    - 关键亮点：对翻转操作可转化为交换相邻元素给出了具体证明，代码实现简洁明了。

### 重点代码
#### 作者：81179332_ 
```cpp
// 统计字符出现次数
for(int i = 1;i <= n;i++) cnt[s[i] - 'a']++;
// 判断是否有重复字符
bool fl = 0;
for(int i = 0;i < 26;i++) if(cnt[i] > 1) fl = 1;
// 判断字符出现次数是否相同
for(int i = 1;i <= n;i++) cnt[t[i] - 'a']--;
for(int i = 0;i < 26;i++) if(cnt[i]) { p = 1;break; }
// 暴力求逆序对
int ans1 = 0,ans2 = 0;
for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(s[i] > s[j]) ans1++;
for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(t[i] > t[j]) ans2++;
// 判断逆序对奇偶性
if(ans1 - ans2 & 1) puts("NO");
else puts("YES");
```
核心实现思想：先统计字符出现次数，判断是否有重复字符和字符出现次数是否相同，再通过两层循环暴力计算逆序对，最后根据逆序对奇偶性判断是否有解。

#### 作者：Arghariza 
```cpp
// 统计字符出现次数
for (int i = 1; i <= n; i++) {
    mps[s[i] - 'a']++, mpt[t[i] - 'a']++;
}
// 判断字符出现次数是否相同
for (int i = 0; i <= 25; i++) {
    if (mps[i] != mpt[i]) {
        flg = 1;
        puts("NO");
        break;
    }
}
// 判断是否有重复字符
for (int i = 0; i <= 25; i++) {
    if (mps[i] > 1) {
        puts("YES");
        flg = 1;
        break;
    }
}
// 暴力求逆序对
int p1 = 0, p2 = 0;
for (int i = 2; i <= n; i++) {
    for (int j = 1; j <= i - 1; j++) {
        if (s[j] > s[i]) p1++;
        if (t[j] > t[i]) p2++;
    }
}
// 判断逆序对奇偶性
if (p1 % 2 == p2 % 2) puts("YES");
else puts("NO");
```
核心实现思想：与上一个代码类似，先统计字符出现次数，判断字符出现次数是否相同和是否有重复字符，再暴力计算逆序对，最后根据逆序对奇偶性判断是否有解。

#### 作者：Mr_Wu 
```cpp
// 统计字符出现次数
for (i = 1; i <= N; ++i)
{
    ++cnt[S[i] - 'a'];
    if (cnt[S[i] - 'a'] > 1) flag = 1;
}
// 判断字符出现次数是否相同
for (i = 1; i <= N; ++i) --cnt[T[i] - 'a'];
for (i = 0; i < 26; ++i) if (cnt[i]) { puts("NO"); break; }
// 判断是否有重复字符
if (flag) puts("YES");
else
{
    // 计算逆序对
    ans1 = ans2 = 0;
    for (i = 0; i < 26; ++i) cnt[i] = 0;
    for (i = 1; i <= N; ++i)
    {
        for (j = S[i] - 'a' + 1; j < 26; ++j) ans1 += cnt[j];
        ++cnt[S[i] - 'a'];
    }
    for (i = 0; i < 26; ++i) cnt[i] = 0;
    for (i = 1; i <= N; ++i)
    {
        for (j = T[i] - 'a' + 1; j < 26; ++j) ans2 += cnt[j];
        ++cnt[T[i] - 'a'];
    }
    // 判断逆序对奇偶性
    puts((ans1 - ans2) % 2 ? "NO" : "YES");
}
```
核心实现思想：同样先统计字符出现次数，判断字符出现次数是否相同和是否有重复字符，再通过统计比当前字符大的字符个数来计算逆序对，最后根据逆序对奇偶性判断是否有解。

### 最优关键思路或技巧
- **问题转化**：将翻转操作转化为交换相邻元素，简化问题。
- **分类讨论**：根据字符出现次数、是否有重复字符和逆序对奇偶性进行分类讨论，降低问题复杂度。

### 可拓展之处
同类型题可能会改变操作规则，如改变翻转的方式或增加其他操作，解题思路仍可从字符出现次数、元素顺序等方面入手。类似算法套路可用于处理字符串变换、排列组合等问题。

### 推荐题目
- [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)

### 个人心得摘录与总结
- **作者：lsr1409111459**：考场上只想到了逆序对数，第二个样例过不去，手动模拟后找到有重复字符就有解的规律。总结是题目虽不难，但逆序对很巧妙，遇到问题可手动模拟找规律。 

---
处理用时：49.47秒
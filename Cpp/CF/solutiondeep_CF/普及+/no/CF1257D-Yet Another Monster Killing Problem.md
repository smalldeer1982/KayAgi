# 题目信息

# Yet Another Monster Killing Problem

## 题目描述

你需要操作 $m$ 个英雄去打败 $n$ 只怪物，每个英雄的力量值为 $p_i$，可以打败 $s_i$ 只怪物；每只怪物的力量值为 $a_i$。

当新的一天开始时，你可以选择其中 $1$ 个英雄去打怪（一个英雄可以选择多次）。若在之前已有 $k$ 只怪物被打败，这个英雄将挑战第 $k+1$ 只怪物，此时有两种情况：

1、英雄力量 $<$ 怪物力量，则英雄撤退，这一天结束。

2、英雄力量 $\geqslant$ 怪物力量，怪物被打败。继续挑战下一只怪物。当 $n$ 只怪物全部被打败，或该英雄已打败的怪物数量为 $s_i$ 时，这一天结束。

你的任务是计算出打败所有怪物所需要的最小天数。



------------

## 样例 #1

### 输入

```
2
6
2 3 11 14 1 8
2
3 2
100 1
5
3 5 100 2 3
2
30 5
90 1
```

### 输出

```
5
-1
```

# AI分析结果

### 题目翻译
#### 另一个怪物击杀问题

#### 题目描述
你需要操控 $m$ 个英雄去打败 $n$ 只怪物，每个英雄的力量值为 $p_i$，可以打败 $s_i$ 只怪物；每只怪物的力量值为 $a_i$。

当新的一天开始时，你可以选择其中 $1$ 个英雄去打怪（一个英雄可以选择多次）。若在之前已有 $k$ 只怪物被打败，这个英雄将挑战第 $k + 1$ 只怪物，此时有两种情况：
1. 英雄力量 $<$ 怪物力量，则英雄撤退，这一天结束。
2. 英雄力量 $\geqslant$ 怪物力量，怪物被打败。继续挑战下一只怪物。当 $n$ 只怪物全部被打败，或该英雄已打败的怪物数量为 $s_i$ 时，这一天结束。

你的任务是计算出打败所有怪物所需要的最小天数。

#### 样例 #1
##### 输入
```
2
6
2 3 11 14 1 8
2
3 2
100 1
5
3 5 100 2 3
2
30 5
90 1
```
##### 输出
```
5
-1
```

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是贪心策略，通过合理选择英雄来最小化打败所有怪物的天数。各题解的不同主要体现在实现细节和数据处理方式上。
- **思路对比**：大部分题解先判断是否存在无法打败的怪物，然后对英雄信息进行预处理，如按力量排序、更新耐力后缀最大值等，再依次处理每个怪物，根据当前情况选择英雄或进入新的一天。部分题解使用二分查找来快速找到合适的英雄。
- **算法要点**：主要包括判断是否有解、英雄信息预处理、贪心选择英雄、更新状态（如天数、已打败怪物数等）。
- **解决难点**：关键在于如何高效地选择英雄，以达到最小天数的目标。不同题解通过不同的数据结构和算法技巧来解决这个问题，如后缀操作、二分查找、离散化等。

### 所选题解
- **作者：F_Mu (赞：6)，4星**
    - **关键亮点**：思路清晰，代码简洁，使用后缀操作和二分查找优化选择英雄的过程。
    - **个人心得**：“本场比赛 $D$ 和 $E$ 惨痛教训：玩后缀一定要注意边界！！！”，提醒在使用后缀操作时要注意边界问题。
- **作者：Lyccrius (赞：1)，4星**
    - **关键亮点**：详细解释了贪心策略的原理，利用单调队列思想优化英雄选择，代码实现简洁明了。
- **作者：chiyanfeng (赞：0)，4星**
    - **关键亮点**：通过预处理记录一天内可以消灭不同数量怪兽的最大力量，然后线性扫描，逻辑清晰。

### 重点代码
#### 作者：F_Mu
```cpp
// 后缀操作
for (int i = m - 1; i >= 1; --i)
    b[i].s = max(b[i].s, b[i + 1].s);
int k = 1;
int last = 0;
int minn = inf;
for (int i = 1; i <= n; ++i) {
    int t = lower_bound(b + 1, b + m + 1, a[i], cmp) - b;
    minn = min(b[t].s, minn);
    if (minn + last < i) {
        minn = b[t].s;
        ++k;
        last = i - 1;
    }
}
```
**核心实现思想**：先对英雄按力量排序，然后进行后缀操作更新耐力值。遍历怪物，用二分查找找到能打败当前怪物的英雄，根据当前英雄的耐力判断是否进入新的一天。

#### 作者：Lyccrius
```cpp
std::sort(hero + 1, hero + m + 1);
for (int i = m - 1; i >= 1; i--) hero[i].s = std::max(hero[i].s, hero[i + 1].s);
int date = 1;
int killed = 0;
int minS = inf;
for (int i = 1; i <= n; ++i) {
    int fight = std::lower_bound(hero + 1, hero + m + 1, a[i]) - hero;
    minS = std::min(minS, hero[fight].s);
    if (minS + killed < i) {
        minS = hero[fight].s;
        date++;
        killed = i - 1;
    }
}
```
**核心实现思想**：对英雄排序并更新耐力后缀最大值，遍历怪物，二分查找合适的英雄，根据耐力判断是否进入新的一天。

#### 作者：chiyanfeng
```cpp
memset(b + 1, 0, sizeof(int) * n);
for (int i = 1; i <= m; i++)
    cin >> p[i] >> s[i], b[s[i]] = max(b[s[i]], p[i]);
for (int i = n - 1; i >= 1; i--) b[i] = max(b[i], b[i + 1]);
int ans = 0, i = 0;
while (i <= n) {
    ans++;
    int j = 1, t = 0;
    while (i + j <= n) {
        t = max(t, a[i + j]);
        if (b[j] >= t)
            j++;
        else
            break;
    }
    if (j == 1) {
        ans = -1;
        break;
    }
    i = i + j - 1;
    if (i == n) break;
}
```
**核心实现思想**：预处理记录一天内可以消灭不同数量怪兽的最大力量，然后线性扫描，每一轮尝试在最大力量范围内消灭尽可能多的怪物，若无法消灭则标记为无解。

### 关键思路或技巧
- **后缀操作**：将英雄的耐力值更新为后缀最大值，方便后续选择英雄。
- **二分查找**：快速找到能打败当前怪物的英雄，提高查找效率。
- **贪心策略**：在每一步都做出当前最优的选择，以达到最小天数的目标。

### 拓展思路
同类型题可能会有更多的限制条件，如英雄有冷却时间、怪物有特殊技能等。类似算法套路包括贪心选择和二分查找的结合，通过预处理数据来优化选择过程。

### 推荐洛谷题目
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)

---
处理用时：49.74秒
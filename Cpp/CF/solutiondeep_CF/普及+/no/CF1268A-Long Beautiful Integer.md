# 题目信息

# Long Beautiful Integer

## 题目描述

给定一个由 $a_1, a_2, \ldots, a_n$ 从左到右构成的整数 $x$ 和一个正整数 $k$。

若由 $b_1, b_2, \ldots, b_m$ 从左到右构成的整数满足 $\forall i \in [1,m-k], b_i=b_{i+k}$，则称其为美丽数。

请求出最小的由 $b_1, b_2, \ldots, b_m$ 从左到右构成的美丽数 $y$，满足 $y \geq x$。

## 说明/提示

$2 \leq n \leq 2 \times 10^5$，$1 \leq k \leq n$。

## 样例 #1

### 输入

```
3 2
353
```

### 输出

```
3
353
```

## 样例 #2

### 输入

```
4 2
1234
```

### 输出

```
4
1313
```

# AI分析结果

【题目内容】
# 长美丽整数

## 题目描述
给定一个由 $a_1, a_2, \ldots, a_n$ 从左到右构成的整数 $x$ 和一个正整数 $k$。
若由 $b_1, b_2, \ldots, b_m$ 从左到右构成的整数满足 $\forall i \in [1,m - k], b_i = b_{i + k}$，则称其为美丽数。
请求出最小的由 $b_1, b_2, \ldots, b_m$ 从左到右构成的美丽数 $y$，满足 $y \geq x$。

## 说明/提示
$2 \leq n \leq 2 \times 10^5$，$1 \leq k \leq n$。

## 样例 #1
### 输入
```
3 2
353
```
### 输出
```
3
353
```

## 样例 #2
### 输入
```
4 2
1234
```
### 输出
```
4
1313
```

【算法分类】
构造

【综合分析与结论】
这些题解的核心思路都是构造法，通过取原数的前 $k$ 位来尝试构造满足条件的美丽数。若构造出的数小于原数，则对前 $k$ 位加 1 并处理进位，以得到最小的大于等于原数的美丽数。
- **思路对比**：各题解思路大致相同，都是先尝试用原数前 $k$ 位构造，再判断是否满足条件，不满足则调整前 $k$ 位。
- **算法要点**：关键在于取前 $k$ 位构造、比较大小以及处理进位。
- **解决难点**：主要难点是处理进位，不同题解采用了不同的方式，如循环判断字符是否大于 '9' 或数字是否大于 9 等。

【所选题解】
- 作者：ZLCT (赞：1)，4星。关键亮点：思路清晰，代码结构完整，有详细的注释和证明过程，对进位的处理比较细致。
- 作者：囧仙 (赞：1)，4星。关键亮点：使用 `memcpy` 函数简化了复制操作，代码简洁，思路清晰。
- 作者：liuyz11 (赞：1)，4星。关键亮点：代码中使用了宏定义，对比较大小的过程进行了详细的处理，逻辑清晰。

【重点代码】
- **ZLCT 的代码**：
```cpp
void add(){
    y[y.size()-1]++;
    for(int i=(int)y.size()-1;i>=0;--i){
        if(y[i]>'9'){
            if(i!=0){
                y[i]='0';
                y[i-1]++;
            }else{
                flag=1;
                int len=(int)y.size();
                y="1";
                for(int j=1;j<=len;++j)y+='0';
                return;
            }
        }else{
            return;
        }
    }
}
```
核心实现思想：对字符串表示的数字加 1，处理进位情况，若最高位进位则增加字符串长度。

- **囧仙的代码**：
```cpp
up(0,n/m,i) memcpy(B+i*m,A,min(m,n-i*m));
up(0,n-1,i) if(A[i]!=B[i]){flg=A[i]>B[i];break;}
if(flg){
    ++A[m-1]; dn(m-1,1,i) if(A[i]=='9'+1) A[i]='0',++A[i-1];
    up(0,n/m,i) memcpy(B+i*m,A,min(m,n-i*m));
}
```
核心实现思想：先复制前 $k$ 位构造答案，比较与原数大小，若小于原数则对前 $k$ 位加 1 并处理进位，再重新复制。

- **liuyz11 的代码**：
```cpp
if(miny > minx){
    ans[m] = num[m] + 1;
    for(int x = m; x > 0 && ans[x] == 10; x--){
        ans[x] = 0;
        ans[x - 1]++;
    }
}
```
核心实现思想：若构造的数小于原数，对第 $k$ 位加 1 并处理进位。

【最优关键思路或技巧】
- 采用贪心策略，先尝试用原数前 $k$ 位构造，保证构造的数尽可能小。
- 处理进位时，从低位到高位依次判断是否需要进位。

【拓展思路】
同类型题可能会有不同的构造规则或限制条件，如改变美丽数的定义、增加其他约束等。类似算法套路是先尝试简单构造，再根据条件进行调整。

【推荐洛谷题目】
- P1012 拼数
- P1223 排队接水
- P1090 合并果子

【个人心得】
liuyz11 提到这一题 hack 数据很多，有 197 组，提醒我们在做题时要考虑全面，注意边界情况和特殊数据。 

---
处理用时：38.76秒
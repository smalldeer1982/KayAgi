# 题目信息

# Shawarma Tent

## 题目描述

首都柏林的地图可以看成一个坐标无限的平面。每一个坐标为整数的点有一个建筑物，每个建筑物都有连接到四个相邻建筑物的街道。所有街道都与坐标轴平行。

首都的主要学校位于 $(s_x,s_y)$。这所学校有 $n$ 名学生，第$i$名学生住在位于 $(x_i,y_i)$ 的房子里。有些学生可能住在同一所房子里，但没有学生住在 $(s_x,s_y)$。

下课后，每名学生沿着一条最短路径从学校走回家。所以第$i$个学生从学校到家的距离是 $|s_x-x_i|+|s_y-y_i|$。

柏林的供应部决定在首都某处（在某个坐标为整数的节点上）放置一个 shawarma 帐篷。如果从学校到第$i$名学生家的最短路径中至少有一条经过 shawarma 帐篷所在地，则认为第 $i$ 名学生将购买 shawarma 帐篷。学校所在地禁止放置 shawarma 帐篷，但 shawarma 帐篷可能与某名学生（甚至多名学生）的房屋在同一个坐标。

你想要找到购买 shawarma 帐篷的学生的最大可能数量以及此时帐篷的位置。

## 说明/提示

在第一个样例中，如果我们在 $(4,2)$ 放置 shawarma 帐篷，那么住在 $(4,2),(4,1)$ 和 $(5,1)$ 的学生将会购买它。

在第二个样例中，可以在 $(1,1)$ 放置 shawarma 帐篷，那么住在 $(0,0)$ 的两个学生将会购买它。

## 样例 #1

### 输入

```
4 3 2
1 3
4 2
5 1
4 1
```

### 输出

```
3
4 2
```

## 样例 #2

### 输入

```
3 100 100
0 0
0 0
100 200
```

### 输出

```
2
99 100
```

## 样例 #3

### 输入

```
7 10 12
5 6
20 23
15 4
16 5
4 54
12 1
4 15
```

### 输出

```
4
10 11
```

# AI分析结果

【题目内容】
# 沙瓦玛帐篷

## 题目描述

首都柏林的地图可以看成一个坐标无限的平面。每一个坐标为整数的点有一个建筑物，每个建筑物都有连接到四个相邻建筑物的街道。所有街道都与坐标轴平行。

首都的主要学校位于 $(s_x,s_y)$。这所学校有 $n$ 名学生，第 $i$ 名学生住在位于 $(x_i,y_i)$ 的房子里。有些学生可能住在同一所房子里，但没有学生住在 $(s_x,s_y)$。

下课后，每名学生沿着一条最短路径从学校走回家。所以第 $i$ 个学生从学校到家的距离是 $|s_x - x_i| + |s_y - y_i|$。

柏林的供应部决定在首都某处（在某个坐标为整数的节点上）放置一个沙瓦玛帐篷。如果从学校到第 $i$ 名学生家的最短路径中至少有一条经过沙瓦玛帐篷所在地，则认为第 $i$ 名学生将购买沙瓦玛帐篷。学校所在地禁止放置沙瓦玛帐篷，但沙瓦玛帐篷可能与某名学生（甚至多名学生）的房屋在同一个坐标。

你想要找到购买沙瓦玛帐篷的学生的最大可能数量以及此时帐篷的位置。

## 说明/提示

在第一个样例中，如果我们在 $(4,2)$ 放置沙瓦玛帐篷，那么住在 $(4,2),(4,1)$ 和 $(5,1)$ 的学生将会购买它。

在第二个样例中，可以在 $(1,1)$ 放置沙瓦玛帐篷，那么住在 $(0,0)$ 的两个学生将会购买它。

## 样例 #1

### 输入

```
4 3 2
1 3
4 2
5 1
4 1
```

### 输出

```
3
4 2
```

## 样例 #2

### 输入

```
3 100 100
0 0
0 0
100 200
```

### 输出

```
2
99 100
```

## 样例 #3

### 输入

```
7 10 12
5 6
20 23
15 4
16 5
4 54
12 1
4 15
```

### 输出

```
4
10 11
```

【算法分类】
贪心

【综合分析与结论】
这些题解的核心思路都是基于贪心策略，即认为沙瓦玛帐篷放在学校周围的某些点能使购买帐篷的学生数量最多。不同题解对于考虑的学校周围的点的数量和统计方法有所不同，主要有考虑学校东南西北相邻的四个点和考虑学校周围八个点这两种情况。
- **思路对比**：多数题解认为将帐篷放在学校东南西北相邻的四个点是较优的，通过统计每个点能覆盖的学生数量来确定最优位置；而 TEoS 的题解考虑了学校周围的八个点。
- **算法要点**：各题解大多通过输入学生坐标，根据学生与学校的位置关系来更新相应点的覆盖学生数量，最后找出覆盖学生数量最多的点及其坐标。
- **解决难点**：主要难点在于如何确定帐篷的最优放置位置，各题解通过分析学生最短路径的特点，利用贪心思想解决了该问题。

【所选的题解】
- 作者：_Agave_ (4星)
  - 关键亮点：思路清晰，通过桶记录四个位置的方案数，代码实现简洁明了。
- 作者：破壁人五号 (4星)
  - 关键亮点：对题意和解题思路的分析详细，代码中使用了自定义的快速输入函数。
- 作者：WOWHandsome (4星)
  - 关键亮点：通过画图辅助理解贪心规律，讲解详细，代码简洁易懂。

【重点代码】
- **_Agave_ 的代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,sx,sy,way[5],dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0},num[5]={0,4,2,1,3};
int main(){
    scanf("%d%d%d",&n,&sx,&sy);
    for(int i=1;i<=n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        if(y==sy)way[sx>x?4:3]++;
        else if(x==sx)way[sy>y?2:1]++;
        else{
            if(x>sx){way[3]++;}
            if(x<sx){way[4]++;}
            if(y<sy){way[2]++;}
            if(y>sy){way[1]++;}
        }
    }
    int maxn=max(max(max(way[1],way[2]),way[3]),way[4]);
    printf("%d\n",maxn);
    for(int i=1;i<=4;i++){
        if(way[i]==maxn){
            printf("%d %d",sx+dx[i],sy+dy[i]);
            return 0;
        }
    } 
    return 0;
}
```
核心实现思想：用 `way` 数组记录学校东南西北四个位置的方案数，根据学生坐标与学校坐标的关系更新 `way` 数组，最后找出最大值并输出对应位置。

- **破壁人五号的代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int getint(){
    int ans=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        ans=ans*10+c-'0';
        c=getchar();
    }
    return ans*f;
}
 
int main(){
    int n=getint(),x=getint(),y=getint();
    int u=0,d=0,l=0,r=0;
    for(int i=0;i<n;i++){
        int xx=getint(),yy=getint();
        if(xx<x)d++;
        if(xx>x)u++;
        if(yy<y)l++;
        if(yy>y)r++;
    }
    int ans=max({u,d,l,r});
    cout<<ans<<endl;
    if(ans==d){
        cout<<x-1<<" "<<y<<endl;
    }else if(ans==u){
        cout<<x+1<<" "<<y<<endl;
    }else if(ans==l){
        cout<<x<<" "<<y-1<<endl;
    }else{
        cout<<x<<" "<<y+1<<endl;
    }
    return 0;
}
```
核心实现思想：用 `u`、`d`、`l`、`r` 分别记录学校上方、下方、左方、右方的学生数量，最后找出最大值并输出对应位置。

- **WOWHandsome 的代码**：
```cpp
# include <bits/stdc++.h>
using namespace std;

int n, x, y;
int ans1, ans2, ans3, ans4, _max;

signed main() {
    scanf("%d%d%d", &n, &x, &y);
    for (int i = 1; i <= n; i++) {
        int p, q;
        scanf("%d%d", &p, &q);
        if (p < x) ans1++; 
        if (p > x) ans2++;
        if (q < y) ans3++;
        if (q > y) ans4++;
    }
    _max = max(max(ans1, ans2), max(ans3, ans4));
    printf("%d\n", _max);
    if (_max == ans1) printf("%d %d\n", x-1, y);
    else if (_max == ans2) printf("%d %d\n", x+1, y);
    else if (_max == ans3) printf("%d %d\n", x, y-1);
    else if (_max == ans4) printf("%d %d\n", x, y+1);
    return 0;
}
```
核心实现思想：用 `ans1`、`ans2`、`ans3`、`ans4` 分别记录学校下方、上方、左方、右方的学生数量，最后找出最大值并输出对应位置。

【最优关键思路或技巧】
- 贪心思想：通过分析发现将帐篷放在学校周围的某些点（如东南西北相邻的四个点）能使覆盖的学生数量最多。
- 统计方法：根据学生与学校的位置关系，对相应位置的覆盖学生数量进行更新。

【拓展思路】
同类型题可能会改变地图的结构（如变为网格图、树等），或者增加其他限制条件（如帐篷数量限制、不同学生有不同的购买概率等），但解题的关键仍然是分析学生的最短路径和帐篷的放置位置之间的关系，利用贪心思想进行求解。

【推荐题目】
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法，通过合并果子的过程来体现贪心策略。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：同样是贪心算法的应用，通过合理安排排队顺序来使总等待时间最短。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：利用贪心思想解决部分背包问题，选择单位价值最高的物品。

【个人心得】
- **fls233666**：比赛时通过观察样例发现规律，先尝试了枚举学校四个相邻位置放置帐篷并暴力统计的方法，结果通过了测试。赛后认真研究题目，根据学生只能走上下左右四个方向，得出每个学生从家到学校的最短路径一定会经过与学校相邻的上下左右四个位置之一，从而证明了之前规律的正确性。总结：在比赛中可以先通过观察样例找规律，赛后再深入研究题目原理。 

---
处理用时：69.28秒
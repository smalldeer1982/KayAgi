# 题目信息

# Nearest Opposite Parity

## 题目描述

给出一个长度为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，当你在第 $i$ 号位置时，你可以一步跳到 $i-a_i$ 或 $i+a_i$。

对于每一个位置 $i$，你想知道最少需要多少步可以到达一个位置 $j$，使得 $a_j$ 与 $a_i$ 的奇偶性不同。

## 说明/提示

$1 \le n \le 2 \cdot 10^5$，$1 \le a_i \le n$。

## 样例 #1

### 输入

```
10
4 5 7 6 7 5 4 4 6 4
```

### 输出

```
1 1 1 2 -1 1 1 3 1 1 
```

# AI分析结果

### 题目翻译
#### 最近的相反奇偶性

#### 题目描述
给定一个长度为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，当你处于第 $i$ 个位置时，你可以一步跳到 $i - a_i$ 或 $i + a_i$ 位置。
对于每个位置 $i$，你想知道最少需要多少步才能到达一个位置 $j$，使得 $a_j$ 与 $a_i$ 的奇偶性不同。

#### 说明/提示
$1 \le n \le 2 \cdot 10^5$，$1 \le a_i \le n$。

#### 样例 #1
##### 输入
```
10
4 5 7 6 7 5 4 4 6 4
```
##### 输出
```
1 1 1 2 -1 1 1 3 1 1 
```

### 算法分类
广度优先搜索 BFS

### 综合分析与结论
这些题解的核心思路都是将问题转化为图论问题，通过建图并使用广度优先搜索（BFS）来求解每个位置到奇偶性相反位置的最少步数。部分题解还引入了超级源点和反向图的技巧来优化算法。
- **思路对比**：大部分题解是分别对奇数和偶数位置进行 BFS 搜索；部分题解引入超级源点，通过反向跑最短路来求解。
- **算法要点**：主要是建图和 BFS 搜索，建图时根据题目规则从 $i - a_i$ 和 $i + a_i$ 向 $i$ 连边，BFS 搜索时更新最短步数。
- **解决难点**：直接对每个点进行 BFS 搜索复杂度为 $O(n^2)$，会超时。通过反向建图、多源 BFS 或引入超级源点等方法将复杂度优化到 $O(n)$。

### 所选题解
- **quanjun（4星）**
    - **关键亮点**：思路清晰，详细解释了如何将问题转化为图论问题并使用 BFS 求解，代码可读性高。
- **Fan_Tuan（4星）**
    - **关键亮点**：引入超级源点的思路，通过反向跑最短路求解，提供了不同的解题视角。
- **yangmuguang（4星）**
    - **关键亮点**：简洁明了地阐述了在反图上进行多源 BFS 的思路，代码实现简洁。

### 重点代码及核心思想
#### quanjun 的题解
```c++
// 建图
for (int i = 1; i <= n; i ++) {
    if (i-a[i] >= 1) g[ i-a[i] ].push_back(i);
    if (i+a[i] <= n) g[ i+a[i] ].push_back(i);
}
// 求 odd 值
for (int i = 1; i <= n; i ++) {
    if (a[i]%2) {
        odd[i] = 0;
        que.push(i);
    }
    else odd[i] = -1;
}
while (!que.empty()) {
    int u = que.front();
    que.pop();
    int sz = g[u].size();
    for (int i = 0; i < sz; i ++) {
        int v = g[u][i];
        if (odd[v] == -1 || odd[v] > odd[u] + 1) {
            odd[v] = odd[u] + 1;
            que.push(v);
        }
    }
}
// 求 even 值同理
```
**核心思想**：先建图，然后分别对奇数和偶数位置进行 BFS 搜索，更新每个位置到奇数和偶数位置的最少步数。

#### Fan_Tuan 的题解
```cpp
// 建图
for (int i = 1; i <= n; i++) {
    if (i + a[i] <= n) add(i + a[i], i, 1);
    if (i - a[i] >= 1) add(i - a[i], i, 1);
} 
for (int i = 1; i <= n; i++)
    if (a[i] & 1) add(n + 1, i, 0);
    else add(n + 2, i, 0);
// 从奇数源点反向跑最短路
spfa(n + 1);
for (int i = 1; i <= n; i++) if (a[i] % 2 == 0) ans[i] = dis[i];
// 从偶数源点反向跑最短路
spfa(n + 2);
for (int i = 1; i <= n; i++) if (a[i] & 1) ans[i] = dis[i];
```
**核心思想**：先建图，然后引入奇数和偶数两个超级源点，分别从超级源点反向跑最短路，得到每个位置到奇偶性相反位置的最少步数。

#### yangmuguang 的题解
```
// 建图
for (ll i=1;i<=n;i++)
{
    cin>>a[i];
    if (i-a[i]>=1)con[i-a[i]].pb(i);
    if (i+a[i]<=n)con[i+a[i]].pb(i);
}
// 以奇数节点为起点进行多源 BFS
memset(ans,-1,sizeof(ans));
memset(dis,0x3f,sizeof(dis));
for (ll i=1;i<=n;i++)
{
    if (a[i]%2==1)
    {
        q.push(i);
        dis[i]=0;
    }
}
bfs();
for (ll i=1;i<=n;i++)
{
    if (a[i]%2==0)
    {
        ans[i]=dis[i];
    }
}
// 以偶数节点为起点进行多源 BFS 同理
```
**核心思想**：先建图，然后分别以奇数和偶数节点为起点进行多源 BFS，得到每个位置到奇偶性相反位置的最少步数。

### 最优关键思路或技巧
- **反向建图**：将问题转化为图论问题，通过反向建图将复杂度从 $O(n^2)$ 优化到 $O(n)$。
- **多源 BFS**：分别以奇数和偶数节点为起点进行多源 BFS，避免对每个点进行单独搜索。
- **超级源点**：引入超级源点，通过反向跑最短路求解，简化了搜索过程。

### 可拓展之处
同类型题或类似算法套路：
- 其他图论中的最短路问题，如单源最短路径（Dijkstra、SPFA 等）、多源最短路径（Floyd 算法）。
- 网格图中的最短路径问题，如迷宫问题、骑士巡游问题等。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
- [P1339 [USACO09OCT]Bessie's Weight Problem G](https://www.luogu.com.cn/problem/P1339)
- [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)

### 个人心得
quanjun 提到今年 CSP - J 复赛第 4 题可以用广搜做，自己却用了最短路 SPFA 算法，感觉用最短路算法解决广搜可以解决的问题有一点杀鸡用牛刀的感觉。这提醒我们在选择算法时要根据问题的特点选择最合适的算法，避免过度使用复杂算法。 

---
处理用时：54.60秒
# 题目信息

# Fill The Bag

## 题目描述

You have a bag of size $ n $ . Also you have $ m $ boxes. The size of $ i $ -th box is $ a_i $ , where each $ a_i $ is an integer non-negative power of two.

You can divide boxes into two parts of equal size. Your goal is to fill the bag completely.

For example, if $ n = 10 $ and $ a = [1, 1, 32] $ then you have to divide the box of size $ 32 $ into two parts of size $ 16 $ , and then divide the box of size $ 16 $ . So you can fill the bag with boxes of size $ 1 $ , $ 1 $ and $ 8 $ .

Calculate the minimum number of divisions required to fill the bag of size $ n $ .

## 样例 #1

### 输入

```
3
10 3
1 32 1
23 4
16 1 4 1
20 5
2 1 16 1 8```

### 输出

```
2
-1
0```

# AI分析结果

### 题目翻译
## 填充背包

### 题目描述
你有一个容量为 $n$ 的背包。此外，你还有 $m$ 个盒子。第 $i$ 个盒子的大小为 $a_i$，其中每个 $a_i$ 都是 $2$ 的非负整数次幂。

你可以将盒子分成两个大小相等的部分。你的目标是完全填满背包。

例如，如果 $n = 10$ 且 $a = [1, 1, 32]$，那么你需要将大小为 $32$ 的盒子分成两个大小为 $16$ 的部分，然后再将大小为 $16$ 的盒子进行划分。这样你就可以用大小为 $1$、$1$ 和 $8$ 的盒子填满背包。

计算填满容量为 $n$ 的背包所需的最少划分次数。

### 样例 #1
#### 输入
```
3
10 3
1 32 1
23 4
16 1 4 1
20 5
2 1 16 1 8
```
#### 输出
```
2
-1
0
```

### 算法分类
贪心

### 分析与结论
本题要求用大小为 $2$ 的非负整数次幂的盒子去填充容量为 $n$ 的背包，可对盒子进行划分，求最少的划分次数。若所有盒子的总大小小于背包容量，则无解。

各题解的主要思路都是基于贪心策略，利用物品大小是 $2$ 的非负整数次幂这一特点，结合二进制表示来处理。不同题解在具体实现和细节处理上有所差异，但核心都是从低位到高位处理二进制位，根据当前位是否有合适的物品来决定是否进行划分。

### 评分较高的题解
- **fls233666（4星）**
    - **亮点**：思路清晰，详细阐述了将 $n$ 和 $a_i$ 转化为二进制表示的原因，代码注释详细，易于理解。
    - **关键代码**：
```cpp
while(n){
    out_n++;
    wxn[out_n]=(n&1);
    n>>=1;
}//求 n 的二进制表示
for(rgt dti,i=1;i<=out_n;i++){
    wht[i]+=wht[i-1]/2;  //填充上一位的物品两两合并后放到下一位的桶中一起计算
    if(wxn[i]){  //当前位是 1，找物品填充。
        if(!wht[i]){  //没有物品，去更高位上找物品
            dti=i+1;
            while(!wht[dti])
                dti++;
            while(dti>i){
                ans++;
                wht[dti]--;
                wht[dti-1]+=2;
                dti--;
            }  //找到物品，划分，直到回到第 i 位
        }
        wht[i]--; //用一个物品填上这一位
    }
}
```
    - **核心思想**：先将 $n$ 二进制拆分，用数组记录能填掉每一位上的 $1$ 的物品个数。从低位到高位处理 $n$ 的二进制位，若当前位为 $1$ 且没有对应物品，就从更高位找物品进行划分，直到有物品填充当前位。同时，将上一位的物品两两合并后带到下一位计算。

- **installb（4星）**
    - **亮点**：提供了另一种贪心思路，通过计算需要移走的盒子大小之和 $s$，将 $s$ 写成二进制形式，按位处理，从低位到高位贪心选择盒子进行移走或拆分，代码简洁。
    - **关键代码**：
```cpp
LL solve(LL x){
    for(LL i = 0;i <= 32;i ++) if((x >> i) & 1) dvd[i] = 1;
    LL ret = 0,lst = -1;
    for(LL i = 0;i <= 32;i ++){
        if(lst != -1 && cnt[i]){ cnt[i] --; ret += (i - lst); lst = -1; }
        if(dvd[i]){
            if(cnt[i]) cnt[i] --;
            else if(lst == -1) lst = i;
        }
        cnt[i + 1] += (cnt[i] >> 1);
        cnt[i] = cnt[i] & 1;
    }
    return ret;
}
```
    - **核心思想**：先判断是否无解，若有解则计算需要移走的盒子大小之和 $s$，将 $s$ 二进制拆分。按位处理，若当前位需要移走盒子且有对应盒子则直接移走，没有则记录，直到遇到有盒子的位，将该位盒子拆分到有记录的最小位，同时将剩余盒子两两合并处理下一位。

### 最优关键思路或技巧
- **二进制表示**：利用物品大小是 $2$ 的非负整数次幂的特点，将 $n$ 和物品大小转化为二进制表示，方便按位处理。
- **贪心策略**：从低位到高位处理二进制位，优先使用当前位的物品，若没有则从更高位找物品进行划分，保证划分次数最少。
- **合并操作**：在处理完一位后，将该位的物品两两合并，带到下一位计算，减少不必要的划分。

### 可拓展之处
同类型题可能会改变物品大小的规律或增加其他限制条件，但核心思路可能还是基于贪心和二进制处理。类似算法套路可以应用于其他涉及二进制和贪心的问题，如二进制状态压缩、按位贪心选择等。

### 洛谷相关题目
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：考察贪心策略。
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：涉及贪心和优先队列的应用。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：典型的贪心问题。

### 个人心得摘录与总结
- **Error_Eric**：提到做题时感觉很困难（“wtcl”），通过具体例子说明了按位枚举和贪心的过程，提醒注意初始化和数据范围，如“一定要记得初始化，循环一定要从 0 开始，不然‘WA on test 3’”“#define int long long //不然‘WA on test 8’”。总结：在做题时要注意细节，特别是初始化和数据范围，通过具体例子可以更好地理解算法过程。

---
处理用时：49.31秒
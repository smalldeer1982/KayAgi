# 题目信息

# Shortest and Longest LIS

## 题目描述

给你一个有 $n(2 \le n \le 2\cdot 10^5)$ 个元素的排列 $A$ 中，每相邻两个元素的大小关系，要你构造出两组解，使得第一组解的 LIS 最短，第二组解的 LIS 最长。

## 样例 #1

### 输入

```
3
3 <<
7 >><>><
5 >>><
```

### 输出

```
1 2 3
1 2 3
5 4 3 7 2 1 6
4 3 1 7 5 2 6
4 3 2 1 5
5 4 2 1 3```

# AI分析结果

### 题目翻译
本题已为中文，无需翻译。

### 算法分类
构造

### 综合分析与结论
这些题解主要围绕构造满足相邻元素大小关系且 LIS 最短和最长的排列展开。思路大多基于贪心思想，通过对连续的 `<` 或 `>` 进行处理来实现。
- **思路对比**：多数题解先构造 LIS 最短的排列，再构造最长的排列。部分题解从数列整体趋势出发，如让数列总体呈下降或上升趋势；部分题解通过翻转连续 `<` 或 `>` 对应的区间来构造。
- **算法要点**：构造 LIS 最短时，常将排列初始化为降序，翻转连续 `<` 区间；构造 LIS 最长时，将排列初始化为升序，翻转连续 `>` 区间。
- **解决难点**：关键在于理解如何通过对连续 `<` 或 `>` 的处理来控制 LIS 的长度，以及证明构造的排列满足要求。

### 高评分题解
- **作者：wucstdio (赞：31)  ★★★★**
    - **关键亮点**：思路清晰，代码简洁，直接阐述构造方法并证明其合理性，时间复杂度为 $O(n)$。
- **作者：_ztyqwq (赞：4)  ★★★★**
    - **关键亮点**：通过图形辅助理解构造过程，详细证明了构造的排列 LIS 最短和最长的性质。

### 关键思路与技巧
- 对于构造 LIS 最短的排列，先将排列初始化为降序，然后翻转连续 `<` 对应的区间，可使任意两个不在连续 `<` 区间内的位置满足 $a_i > a_j$，从而保证 LIS 最短。
- 对于构造 LIS 最长的排列，先将排列初始化为升序，然后翻转连续 `>` 对应的区间，可使任意两个不在连续 `>` 区间内的位置满足 $a_i < a_j$，从而保证 LIS 最长。

### 拓展思路
同类型题可考虑其他条件下的排列构造问题，如给定更多元素间的关系，或要求构造满足特定条件的子序列等。类似算法套路可应用于其他构造类问题，通过分析问题的性质，找到合适的初始状态和操作方法来满足要求。

### 洛谷题目推荐
- [P1083 借教室](https://www.luogu.com.cn/problem/P1083)：涉及区间操作和贪心思想。
- [P1198 [JSOI2008] 最大数](https://www.luogu.com.cn/problem/P1198)：需要运用数据结构和构造的思想。
- [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)：考察队列和构造的应用。

### 个人心得摘录与总结
- **作者：Flandre_495**：提到在 CF 被该题虐，回来补锅，说明该题有一定难度。还思考了最短上升和最长下降的关系，通过举例说明并非所有最短上升都满足最长下降，反之亦然，体现了对问题深入思考的过程。

### 重点代码
```cpp
// 作者：wucstdio
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int t,n,p[200005];
char s[200005];
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%s",&n,s+1);
        for(int i=1;i<=n;i++)p[i]=n-i+1;
        for(int i=1;i<n;)
        {
            int j=i;
            while(s[j]=='<')j++;
            reverse(p+i,p+j+1);
            i=j+1;
        }
        for(int i=1;i<=n;i++)printf("%d ",p[i]);
        printf("\n");
        for(int i=1;i<=n;i++)p[i]=i;
        for(int i=1;i<n;)
        {
            int j=i;
            while(s[j]=='>')j++;
            reverse(p+i,p+j+1);
            i=j+1;
        }
        for(int i=1;i<=n;i++)printf("%d ",p[i]);
        printf("\n");
    }
    return 0;
}
```
**核心实现思想**：先将排列初始化为降序，遍历字符串，翻转连续 `<` 对应的区间，输出 LIS 最短的排列；再将排列初始化为升序，翻转连续 `>` 对应的区间，输出 LIS 最长的排列。

---
处理用时：34.48秒
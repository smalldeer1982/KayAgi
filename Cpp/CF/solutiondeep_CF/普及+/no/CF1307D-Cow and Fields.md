# 题目信息

# Cow and Fields

## 题目描述

### 题意简述

给定一个有 $n$ 个节点 $m$ 条边的无向图，一个顶点集$S$。

你需要选择两个顶点 $u,v(u\ne v,u\in S,v\in S)$ 并连接这两个顶点（允许 $u,v$ 之间已经有连边），求连接后从顶点 $1$ 到顶点 $n$ 最短路的最大值。

**注意，该操作仅能进行一次。**

保证给定的图联通。

## 样例 #1

### 输入

```
5 5 3
1 3 5
1 2
2 3
3 4
3 5
2 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5 4 2
2 4
1 2
2 3
3 4
4 5```

### 输出

```
3```

# AI分析结果

### 题目翻译
本题已为中文，无需翻译。

### 算法分类
最短路

### 综合分析与结论
各题解的核心思路都是先以起点和终点为源点各跑一次单源最短路（多采用 BFS 实现），求出每个点到起点和终点的距离，再通过不同的策略来选择两个特殊点连边，使得连接后从顶点 1 到顶点 n 的最短路最大。

- **思路对比**：
    - **二分法**：通过二分贡献的值，判断是否存在满足条件的两个特殊点，利用树状数组或维护最大值和次大值来优化判断过程。
    - **贪心策略**：对特殊点按到起点的距离升序排序，通过证明得出只需考虑相邻点的组合，计算相邻点的贡献取最大值。
    - **分类讨论**：添加边后分类讨论新路径的长度，通过排序和维护前缀、后缀最大值来求解。

- **算法要点对比**：
    - **DeaphetS**：二分查找 + 树状数组，时间复杂度 $O(n\log ^2n)$。
    - **OMG_wc**：BFS + 贪心，时间复杂度 $O(n\log n)$。
    - **syksykCCC**：BFS + 排序 + 前缀后缀最大值维护，时间复杂度 $O(n\log n)$。

- **解决难点对比**：
    - **DeaphetS**：二分查找的边界和判断条件的处理，树状数组的使用。
    - **OMG_wc**：贪心策略的证明和正确性保证。
    - **syksykCCC**：分类讨论的情况分析和前缀后缀最大值的维护。

### 所选题解
- **DeaphetS（4星）**：
    - **关键亮点**：提供了独特的二分做法，思路新颖，代码实现较为规范，有详细的注释和解释。
    - **个人心得**：提到“Stop learning useless algorithms, go and solve some problems, learn how to use binary search.”，强调了实践和掌握二分查找的重要性。
- **OMG_wc（4星）**：
    - **关键亮点**：贪心策略简洁明了，证明过程合理，代码可读性高，时间复杂度较低。
- **syksykCCC（4星）**：
    - **关键亮点**：提供了两种不同的解法，思路清晰，对每种解法的分析和推导详细，代码实现规范。

### 重点代码
#### DeaphetS 的二分法核心代码
```cpp
bool check(int w)
{
    int i=0;
    T.init();
    for(auto s:t){
        int w1=w-dis[s][0]-1;
        while(i<k && dis[e[i]][1]>=w1)
            T.cg(dis[e[i]][0]+1,1),i++;
        if(dis[s][1]>=w1)T.cg(dis[s][0]+1,-1);
        if(T.Q(w-dis[s][1]))return true;
        if(dis[s][1]>=w1)T.cg(dis[s][0]+1,1);
    }
    return false;
}
int Useful()
{
    int l=1,r=dis[n][0],mid;
    while(l<r){
        mid=l+r+1>>1;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    return l;
}
```
**核心实现思想**：二分贡献的值 $w$，通过 `check` 函数判断是否存在满足条件的两个特殊点，`Useful` 函数进行二分查找。

#### OMG_wc 的贪心算法核心代码
```cpp
sort(a.begin(), a.end(), cmp);
int ans = 0;
for (int i = 0; i < a.size() - 1; i++) {
    ans = max(ans, d[a[i]] + f[a[i + 1]] + 1);
}
ans = min(d[n], ans);
```
**核心实现思想**：对特殊点按到起点的距离升序排序，遍历相邻点，计算贡献取最大值，最后与原图最短路取最小值。

#### syksykCCC 的分类讨论核心代码
```cpp
sort(a + 1, a + k + 1, cmp);
REP(i, 1, k) pre[i] = max(pre[i - 1], dis1[a[i]]);
PER(i, k, 1) suf[i] = max(suf[i + 1], dis2[a[i]]);
REP(i, 1, k)
{
    if(i > 1) ans = max(ans, min(dis1[n], dis2[a[i]] + 1 + pre[i - 1]));
    if(i < k) ans = max(ans, min(dis1[n], dis1[a[i]] + 1 + suf[i + 1]));
}
```
**核心实现思想**：对特殊点按 $dis_1 - dis_2$ 升序排序，维护前缀 $dis_1$ 最大值和后缀 $dis_2$ 最大值，遍历特殊点计算贡献取最大值。

### 最优关键思路或技巧
- 以起点和终点为源点各跑一次单源最短路，求出每个点到起点和终点的距离，这是解决此类问题的基础。
- 利用排序和贪心策略可以简化问题，减少不必要的枚举，提高算法效率。
- 二分查找可以将问题的时间复杂度优化到对数级别，适用于一些具有单调性的问题。

### 可拓展之处
同类型题或类似算法套路：
- 其他图论中的最短路问题，如带权图的最短路、多源最短路等。
- 涉及图的修改和优化问题，如添加边、删除边后对图的性质的影响。

### 推荐洛谷题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

---
处理用时：45.24秒
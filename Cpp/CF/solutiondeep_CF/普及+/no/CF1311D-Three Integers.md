# 题目信息

# Three Integers

## 题目描述

题目给出三个整数 $a \le b \le c$。

在一次操作中，你可以给这三个数中任意一个数 $+1$ 或 $-1$。你可以用同一个数字做这样的操作任意次。但你要保证，变换过后的数，是一个正数。

你想要用最小操作步数使得三个整数 $A \le B \le C$ 能够符合：$B$ 能被 $A$ 整除， $C$ 能被 $B$ 整除。

你需要回答 $t$ 组询问。

## 样例 #1

### 输入

```
8
1 2 3
123 321 456
5 10 15
15 18 21
100 100 101
1 22 29
3 19 38
6 30 46```

### 输出

```
1
1 1 3
102
114 228 456
4
4 8 16
6
18 18 18
1
100 100 100
7
1 22 22
2
1 19 38
8
6 24 48```

# AI分析结果

【题目内容】
# 三个整数

## 题目描述

题目给出三个整数 $a \le b \le c$。

在一次操作中，你可以给这三个数中任意一个数 $+1$ 或 $-1$。你可以用同一个数字做这样的操作任意次。但你要保证，变换过后的数，是一个正数。

你想要用最小操作步数使得三个整数 $A \le B \le C$ 能够符合：$B$ 能被 $A$ 整除， $C$ 能被 $B$ 整除。

你需要回答 $t$ 组询问。

## 样例 #1

### 输入

```
8
1 2 3
123 321 456
5 10 15
15 18 21
100 100 101
1 22 29
3 19 38
6 30 46
```

### 输出

```
1
1 1 3
102
114 228 456
4
4 8 16
6
18 18 18
1
100 100 100
7
1 22 22
2
1 19 38
8
6 24 48
```

【算法分类】
枚举

【综合分析与结论】
这些题解的核心思路都是通过枚举来找到满足条件的最小操作步数。不同题解在枚举方式和枚举范围上有所差异。
- **思路对比**：部分题解直接枚举三元组 $(x, y, z)$，部分题解则先枚举中间值 $B$，再根据 $B$ 确定 $A$ 和 $C$。
- **算法要点**：枚举时需要注意 $B$ 是 $A$ 的倍数，$C$ 是 $B$ 的倍数，同时要合理确定枚举范围，避免遗漏正确答案。
- **解决难点**：主要难点在于确定合适的枚举范围，不同题解通过不同的方式来确定范围，如有的根据数据范围直接设定上限，有的通过数学推理来确定。

【所选题解】
- **andyli（4星）**
  - **关键亮点**：提供了两种解法，思路清晰，对枚举范围有详细的说明，时间复杂度分析明确。
  - **个人心得**：指出若只枚举到 $c$，`37 10000 10000` 这组数据不能通过，强调了枚举范围的重要性。
- **2huk（4星）**
  - **关键亮点**：思路简洁明了，对数据范围和枚举方式有清晰的阐述，代码结构清晰。
  - **个人心得**：提到赛时不会推枚举上限就直接枚举到 $10^5$，说明在不确定范围时可以适当扩大范围保证正确性。
- **ShineEternal（4星）**
  - **关键亮点**：思路清晰，对枚举对象的选择有合理的解释，代码实现较为简洁。
  - **个人心得**：无。

【重点代码】
- **andyli 解法1**
```cpp
int main()
{
    int q;
    io.read(q);
    while (q--) {
        int a, b, c;
        io.read(a, b, c);
        int ans = -1u / 2, ansa = 0, ansb = 0, ansc = 0;
        for (int i = 1; i <= (c << 1); i++)
            for (int j = i; j <= (c << 1); j += i)
                for (int k = j; k <= (c << 1); k += j) {
                    int t = abs(a - i) + abs(b - j) + abs(c - k);
                    if (t < ans)
                        ans = t, ansa = i, ansb = j, ansc = k;
                }
        writeln(ans);
        writeln(ansa, " ", ansb, " ", ansc);
    }
    return 0;
}
```
**核心实现思想**：直接枚举三元组 $(i, j, k)$，其中 $j$ 是 $i$ 的倍数，$k$ 是 $j$ 的倍数，枚举上限为 $2c$，计算每个三元组对应的操作步数，更新最小操作步数和对应的三元组。

- **2huk**
```cpp
void init(int n)
{
    for (int i = 1; i <= n; ++ i )
        for (int j = i; j <= n; j += i )
            d[j].push_back(i),
            m[i].push_back(j);
}

void Solve()
{
    int a = read(), b = read(), c = read();
    int res = INF, resa, resb, resc;
    for (int B = 1; B <= 1e5; ++ B )
    {
        int A = INF, C = INF;
        for (auto i : d[B]) 
            if (abs(i - a) < abs(A - a))
                A = i;

        for (auto i : m[B]) 
            if (abs(i - c) < abs(C - c))
                C = i;
                
        
        int k = abs(A - a) + abs(B - b) + abs(C - c);
        if (k < res)
        {
            res = k;
            resa = A, resb = B, resc = C;
        }
    }
    
    cout << res << '\n' << resa << ' ' << resb << ' ' << resc << '\n';
}
```
**核心实现思想**：先预处理出每个数的约数和倍数，然后枚举中间值 $B$，在 $B$ 的约数中找到与 $a$ 差值最小的数 $A$，在 $B$ 的倍数中找到与 $c$ 差值最小的数 $C$，更新最小操作步数和对应的三元组。

- **ShineEternal**
```cpp
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int aa,b,c;
        scanf("%d%d%d",&aa,&b,&c);
        int AAA,BBB,CCC;
        int sum=0x3f3f3f3f;
        for(int i=1;i<=15000;i++)
        {
            int ans=0;
            int Zuo,You;
            
            int tmp=0x3f3f3f3f;
            int qaq=sqrt(i);
            ans=Abs(b-i);
            for(int j=1;j<=qaq;j++)
            {
                if(i%j!=0)
                {
                    continue;
                }
                if(Abs(aa-j)<tmp)
                {
                    tmp=Abs(aa-j);
                    Zuo=j;
                }
                if(Abs(aa-(i/j))<tmp)
                {
                    tmp=Abs(aa-(i/j));
                    Zuo=i/j;
                }
            }
            ans+=tmp;
            tmp=0x3f3f3f3f;
            for(int j=i;j<=32000;j+=i)
            {
                if(Abs(c-j)<tmp)
                {
                    You=j;
                    tmp=Abs(c-j);
                }
            }
            ans+=tmp;
            if(ans<sum)
            {
                sum=ans;
                AAA=Zuo;
                BBB=i;
                CCC=You;
            }
        }
        printf("%d\n",sum);
        printf("%d %d %d\n",AAA,BBB,CCC);
    }
    return 0;
}
```
**核心实现思想**：枚举中间值 $i$，对于每个 $i$，找出其约数中与 $aa$ 差值最小的数 $Zuo$，找出其倍数中与 $c$ 差值最小的数 $You$，计算操作步数，更新最小操作步数和对应的三元组。

【关键思路或技巧】
- 合理选择枚举对象，如选择枚举中间值 $B$ 可以减少枚举量。
- 预处理约数和倍数可以提高查找效率。
- 确定合适的枚举范围，避免遗漏正确答案。

【拓展思路】
同类型题可能会改变操作规则或约束条件，如操作次数有限制，或者要求满足更多的整除关系等。类似算法套路可以是通过枚举满足某些条件的组合，然后计算代价并更新最优解。

【推荐题目】
- P1036 选数：通过枚举组合来计算满足条件的组合数。
- P1047 校门外的树：通过枚举区间来模拟种树和砍树的过程。
- P1057 传球游戏：通过枚举传球次数和传球对象来计算传球方案数。

---
处理用时：58.94秒
# 题目信息

# Skyscrapers (hard version)

## 题目描述

这题是 [CF1313C1](https://www.luogu.com.cn/problem/CF1313C1) 的较难版本。这个版本中 $1 \leq n \leq 500000$。

Berland要起摩天大厦了。所有的摩天大厦都在高速公路附近建。发展商买了 $n$ 块地准备建 $n$ 栋摩天大厦，一块地一栋。

当规划一间摩天大厦的时候，建筑师要考虑一些条件。

第一，因为每栋摩天大厦有不同的用途，所以每栋摩天大厦都有自己的层数限制，也就是说，这栋摩天大厦的高度不能超过给定的值 $m_i$。

第二，根据城市的建设规则，一栋摩天大厦不能同时在左右有比它高的摩天大厦。

如果规范地表示，让我们把地编上一个编号从 $1$ 到 $n$。那么如果在第 $i$ 块地的摩天大厦有 $a_i$ 层，那么我们需要保证 $1 \le a_i \le m_i$。另外，这里不可以有整数 $j$ 和 $k$ 满足 $j < i < k$ 并且 $a_j > a_i < a_k$。第 $j, k$ 块地并不需要与第 $i$ 块地相邻。

发展商想要使得每块地上摩天大厦的楼层数之和最大。也请帮他找出在**任意一个**最优状况中每个摩天大厦的高度。也就是，要让建筑师考虑的条件都符合，而且要使得每块地上摩天大厦的楼层数之和最大。

## 样例 #1

### 输入

```
5
1 2 3 2 1```

### 输出

```
1 2 3 2 1```

## 样例 #2

### 输入

```
3
10 6 8```

### 输出

```
10 6 6```

# AI分析结果

### 题目翻译
本题已为中文，无需翻译。

### 算法分类
动态规划

### 综合分析与结论
这些题解主要围绕如何在满足条件的情况下使摩天大厦楼层数总和最大展开。各题解的核心思路都是利用序列的单调性，即答案由一个不下降序列和一个不上升序列构成。
- **思路对比**：部分题解采用枚举最高点的方式，如 Limit 的 Part 1 题解，时间复杂度为 $O(n^2)$；部分题解使用单调栈优化找最高点的过程，如 Fairicle、gyh20、极寒神冰等的题解，时间复杂度为 $O(n)$；还有题解使用线段树维护最小值、笛卡尔树等方法进行优化。
- **算法要点**：枚举最高点的题解通过枚举每个点作为最高点，向两边扩展计算最大楼层数总和；单调栈优化的题解通过维护单调栈，快速找到每个点左边和右边第一个小于它的点，从而计算以该点为最高点时的左右高度和；线段树和笛卡尔树的题解则利用数据结构的特性优化查找和计算过程。
- **解决难点**：主要难点在于如何高效地找到每个点左右第一个小于它的点，以及如何在满足条件的情况下计算最大楼层数总和。不同题解采用了不同的方法来解决这些难点，如单调栈、线段树、笛卡尔树等。

### 评分较高的题解
- **Fairicle（4星）**
    - **关键亮点**：思路清晰，详细说明了如何使用单调栈优化找最高点的过程，代码实现较为规范，注释也比较详细。
    - **核心代码**：
```cpp
for(ri i=1;i<=n;++i)
{
    while(top&&a[s[top]]>a[i]) top--;
    int now=s[top];
    l[i]=l[now]+a[i]*(i-now);
    s[++top]=i;
}
while(top) top--;
s[++top]=n+1;
for(ri i=n;i>=1;--i)
{
    while(top&&a[s[top]]>a[i]) top--;
    int now=s[top];
    r[i]=r[now]+a[i]*(now-i);
    s[++top]=i;
}
```
核心实现思想：通过单调栈维护一个单调不下降的序列，对于每个点 $i$，找到其左边第一个小于它的点 $j$，则以 $i$ 为最高点向左的高度和 $l_i = l_j + a_i * (i - j)$；同理倒序计算以 $i$ 为最高点向右的高度和 $r_i$。
- **gyh20（4星）**
    - **关键亮点**：明确指出了答案的结构，即由一个不下降序列和一个不上升序列构成，并使用单调栈优化找第一个小于当前值的点的过程，代码简洁明了。
    - **核心代码**：
```cpp
for(re int i=1;i<=n;++i){
    lst[i]=0;
    while(a[s[tp]]>a[i]&&tp)--tp;
    lst[i]=s[tp];
    s[++tp]=i;
}
for(re int i=1;i<=n;++i){
    dp[i]=dp[lst[i]]+(i-lst[i])*a[i];
}
reverse(a+1,a+n+1);
tp=0;
for(re int i=1;i<=n;++i){
    lst[i]=0;
    while(a[s[tp]]>a[i]&&tp)--tp;
    lst[i]=s[tp];
    s[++tp]=i;
}
for(re int i=1;i<=n;++i){
    dp1[i]=dp1[lst[i]]+(i-lst[i])*a[i];
}
reverse(dp1+1,dp1+n+1);
```
核心实现思想：使用单调栈维护一个单调不下降的序列，对于每个点 $i$，找到其左边第一个小于它的点 $k$，则从 $1$ 到 $i$ 的不降序列值和的最大值 $dp_i = dp_k + (i - k) * a_i$；同理倒序计算从 $i$ 到 $n$ 的不升序列值和的最大值 $dp1_i$。
- **极寒神冰（4星）**
    - **关键亮点**：思路清晰，直接指出答案由不下降子序列和不上升子序列构成，并使用单调栈优化计算左右贡献的过程，代码实现简洁。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    while(top&&a[stk[top]]>a[i]) top--;
    L[i]=L[stk[top]]+a[i]*(i-stk[top]);
    stk[++top]=i;
}
stk[top=1]=n+1;
for(int i=n;i>=1;i--)
{
    while(top&&a[stk[top]]>a[i]) top--;
    R[i]=R[stk[top]]+a[i]*(stk[top]-i);
    stk[++top]=i;
}
```
核心实现思想：通过单调栈维护一个单调不下降的序列，对于每个点 $i$，找到其左边第一个小于它的点 $j$，则左边贡献 $L_i = L_j + a_i * (i - j)$；同理倒序计算右边贡献 $R_i$。

### 最优关键思路或技巧
使用单调栈可以高效地找到每个点左右第一个小于它的点，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。

### 可拓展之处
同类型题或类似算法套路：
- 对于具有单调性要求的序列构造问题，可以考虑使用单调栈、线段树、笛卡尔树等数据结构进行优化。
- 对于需要枚举最高点或分界点的问题，可以先分析问题的性质，尝试找到优化枚举过程的方法。

### 推荐题目
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：考察单调队列的应用，与单调栈的思想类似。
- [P3834 可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)：考察线段树的应用，与使用线段树维护最小值的思路相关。
- [P5854 笛卡尔树](https://www.luogu.com.cn/problem/P5854)：直接考察笛卡尔树的构造和应用。

### 个人心得
题解中未包含个人心得。

---
处理用时：48.29秒
# 题目信息

# Present to Mom

## 题目描述

求一个 $n\times m$ 的字符矩阵内，有多少个不同的矩形包含不少于 $k$ 个下述图形：

```
 1
111
 1
```

注意，这些图形可以相互重叠，但是不能完全重叠。

## 样例 #1

### 输入

```
4 6 2
111000
111100
011011
000111
```

### 输出

```
6
```

## 样例 #2

### 输入

```
5 5 4
11111
11111
11111
11111
11111
```

### 输出

```
9
```

# AI分析结果

### 题目内容
# 给妈妈的礼物

## 题目描述
求一个 $n\times m$ 的字符矩阵内，有多少个不同的矩形包含不少于 $k$ 个下述图形：
```
 1
111
 1
```
注意，这些图形可以相互重叠，但是不能完全重叠。

## 样例 #1
### 输入
```
4 6 2
111000
111100
011011
000111
```
### 输出
```
6
```

## 样例 #2
### 输入
```
5 5 4
11111
11111
11111
11111
11111
```
### 输出
```
9
```

### 算法分类
前缀和

### 综合分析与结论
这两道题解都旨在解决在给定字符矩阵中统计满足特定图形数量要求的矩形个数问题。
- **__2009题解思路**：先考虑暴力枚举矩形长宽和左上角顶点遍历矩阵统计图形数量，复杂度太高。然后采用前缀和优化，使 $s(i,j)$ 的值为一当且仅当以它为中心是一个目标图形，复杂度降为 $O(m^2n^2)$ 仍不理想。进一步优化利用当以 $(i,j)$ 为顶点，长 $a$ ，宽 $b$ 时，若四元组 $(i,j,a,b)$ 满足条件，则四元组 $(i,j,a,k) (b \le k \le n)$ 也一定满足条件这一特性。
- **Zbcxcj题解思路**：通过双指针做法，先预处理每一行的前缀和，确定矩阵左右两条边后，上下两条边用双指针模拟，利用若一个矩阵满足条件其所有父矩阵也满足条件这一性质，最终复杂度为 $O(m^2n)$。
- **解决难点**：两者都需解决暴力算法复杂度高的问题，通过前缀和优化及利用矩阵包含关系的特性来降低复杂度。

### 所选的题解
- **__2009题解**：
  - **星级**：4星
  - **关键亮点**：利用前缀和优化统计目标图形数量，并进一步挖掘矩阵包含关系进行优化。
  ```cpp
  int sum(int ax,int ay,int bx,int by){
      return s[bx][by]-s[ax-1][by]-s[bx][ay-1]+s[ax-1][ay-1];
  }
  int main(){
      cin>>n>>m>>k;
      for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)
              cin>>a[i][j];
      for(int i=2;i<n;i++){
          for(int j=2;j<m;j++){
              s[i][j]=(a[i][j]&1&&a[i-1][j]&1&&a[i][j-1]&1&&a[i+1][j]&1&&a[i][j+1]&1)+s[i-1][j]+s[i][j-1]-s[i-1][j-1];//前缀和
          }
      }
      for(int l=2;l<n;l++){//l -> 长
          for(int r=l;r<n;r++){//r -> 宽
              for(int i=2,j=2;i<m;i++){//i,j -> 顶点
                   while(j<m&&sum(l,i,r,j)<k)j++;
                      if(j==m)break;
                      ans+=m-j;
                  }
          }
      }
      cout<<ans<<"\n";
  }
  ```
- **Zbcxcj题解**：
  - **星级**：4星
  - **关键亮点**：采用双指针做法，通过预处理每行前缀和，利用矩阵父子关系，固定三条边计算第四条边取值，有效降低复杂度。
  ```cpp
  auto check = [&](int i, int j) {
      if (g[i][j] == '0') return 0;
      for (int k = 0; k < 4; ++k) {
          int x = i + dir[k];
          int y = j + dir[k + 1];
          if (g[x][y] == '0') return 0;
      }
      return 1;
  };
  // 每一行的前缀和
  vector<vector<int>> c(n, vector<int>(m));
  for (int i = 1; i < n - 1; ++i) {
      for (int j = 1; j < m - 1; ++j) {
          int x = check(i, j);
          c[i][j] = c[i][j - 1] + x;
      }
  }
  // 枚举左右边界
  ll ans = 0;
  for (int l = 0; l < m - 2; l++) {
      for (int r = l + 2; r < m; r++) {
          vector<int> a(n);
          for (int i = 0; i < n; i++) a[i] = c[i][r - 1] - c[i][l];  // 注意边缘是不算在内的
          for (int i = 1; i < n; i++) a[i] += a[i - 1];  // 为方便计算，上下边界依然做前缀和处理
          int i = 0, j = 1;
          while (true) {
              while (j < n && a[j - 1] - a[i] < k) ++j;
              if (j == n) break;
              ans += (n - j);  // j 及其下面的边都满足条件
              i += 1;
          }
      }
  }
  ```

### 最优关键思路或技巧
1. **前缀和优化**：通过前缀和快速统计矩阵子区域内目标图形数量，减少重复计算。
2. **利用矩阵关系**：发现并利用若一个矩阵满足条件其所有父矩阵也满足条件这一特性，减少不必要的枚举。

### 可拓展之处
同类型题常涉及在矩阵中统计满足特定条件的子矩阵个数，类似算法套路可总结为预处理（如前缀和）优化统计，挖掘矩阵元素或子矩阵间关系减少枚举量。

### 洛谷相似题目
1. [P3397 地毯](https://www.luogu.com.cn/problem/P3397)：同样涉及矩阵区域和的统计，可通过前缀和解决。
2. [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：在矩阵中寻找满足条件的最大正方形，需利用动态规划结合类似的预处理思想。
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)：求矩阵中加权和最大的子矩形，可借鉴本题优化枚举的思路。 

---
处理用时：61.61秒
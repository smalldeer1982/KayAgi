# 题目信息

# Sleeping Schedule

## 题目描述

Vova有个非常奇怪的睡眠日程表。一天有$h$个小时，Vova将正好睡$n$次觉，从每次刚醒来的那一刻计起，他将在$a_i$小时后睡第$i$次觉。你可以假设Vova在故事开始时是刚醒来的。(初始时间为0)每次Vova正好睡一天(也就是$h$小时)。

如果他在$[l,r]$时间段内开始睡觉，便认为这一次睡眠是优秀的。

Vova可以控制自己，在第$i$次睡眠前，选择在$a_i$或$a_i-1$小时后开始睡觉。

你的任务是计算出优秀睡眠次数的最大值。

## 样例 #1

### 输入

```
7 24 21 23
16 17 14 20 20 11 22```

### 输出

```
3```

# AI分析结果

【题目内容】
### 睡眠时间表

#### 题目描述
Vova有一个非常奇怪的睡眠日程表。一天有$h$个小时，Vova将正好睡$n$次觉，从每次刚醒来的那一刻计起，他将在$a_i$小时后睡第$i$次觉。你可以假设Vova在故事开始时是刚醒来的（初始时间为0）。每次Vova正好睡一天（也就是$h$小时）。

如果他在$[l,r]$时间段内开始睡觉，便认为这一次睡眠是优秀的。

Vova可以控制自己，在第$i$次睡眠前，选择在$a_i$或$a_i - 1$小时后开始睡觉。

你的任务是计算出优秀睡眠次数的最大值。

#### 样例 #1
##### 输入
```
7 24 21 23
16 17 14 20 20 11 22
```
##### 输出
```
3
```

【算法分类】
动态规划

【综合分析与结论】
这些题解均采用动态规划的方法来解决问题，核心思路都是通过定义合适的状态和状态转移方程来求解优秀睡眠次数的最大值。不同题解的主要差异在于状态的定义方式。
- **状态定义方式**：
    - 部分题解（如C C A、Scintilla、chenxia25、F_Mu）定义$dp[i][j]$表示前$i$次睡觉，第$i$次睡觉时间对$h$取模为$j$时的最大优秀睡眠次数。
    - 部分题解（如cyh_toby、devout、__OwO__）定义$f_{i,j}$表示处理前$i$个数，使用了$j$次$-1$操作的最优解。
    - WYXkk的题解定义$dp(i,j)$表示$x_{i - 1}=j$时$x_i,x_{i + 1},\cdots,x_n$中至多有多少个在$[l,r]$之间，采用倒推的方式进行动态规划。
- **解决难点**：
    - 取模运算：由于时间是循环的，需要对时间进行取模处理，避免越界。
    - 状态初始化：对于不合法的状态，需要初始化为极小值，防止其影响最终结果。

【所选的题解】
- **C C A（5星）**：
    - **关键亮点**：思路清晰，状态定义和转移方程明确，代码简洁易读，对取模运算进行了封装，提高了代码的可读性。
    - **个人心得**：无。
- **WYXkk（4星）**：
    - **关键亮点**：采用倒推的方式进行动态规划，思路独特，代码规范，注释详细。
    - **个人心得**：无。
- **chenxia25（4星）**：
    - **关键亮点**：对状态的边界和目标进行了清晰的说明，状态转移方程推导详细，代码简洁。
    - **个人心得**：无。

【重点代码】
- **C C A的核心代码**：
```cpp
const int N = 2e3 + 10;
int n , m , L , R , a[N] , dp[N][N];
int Inc(int x){
    return (x + m) % m;
}
int check(int x){
    return L <= x && x <= R;
}
int main(){
    memset(dp , -63 , sizeof(dp)) , dp[0][0] = 0;
    scanf("%d %d %d %d" , &n , &m , &L , &R);
    for(int i = 1; i <= n; i++) scanf("%d" , &a[i]);
    for(int i = 1; i <= n; i++)
        for(int j = 0; j < m; j++){
            dp[i][j] = max(dp[i - 1][Inc(j - a[i])] , dp[i - 1][Inc(j - a[i] + 1)]) + check(j);	
        }
    int Max = 0;
    for(int i = 0; i < m; i++) Max = max(Max , dp[n][i]);
    printf("%d" , Max);
    return 0;
}
```
**核心实现思想**：定义$dp[i][j]$表示在前$i$个数中，所有数之和对$h$取模的值为$j$时，答案最大为多少。通过两层循环进行状态转移，最后找出$dp[n][i]$中的最大值。

- **WYXkk的核心代码**：
```cpp
int n,h,l,r;
int dp[2005][2005],a[2005];
bool good(int x){return (l<=x)&&(x<=r);}
int main()
{
    rd(n);rd(h);rd(l);rd(r);
    F(i,1,n) rd(a[i]);
    UF(i,n,1) F(t,0,h-1) dp[i][t]=max(dp[i+1][(t+a[i])%h]+good((t+a[i])%h),dp[i+1][(t+a[i]-1)%h]+good((t+a[i]-1)%h));
    printf("%d\n",dp[1][0]);
    return 0;
}
```
**核心实现思想**：定义$dp(i,j)$表示$x_{i - 1}=j$时$x_i,x_{i + 1},\cdots,x_n$中至多有多少个在$[l,r]$之间，倒着进行动态规划，最后输出$dp[1][0]$。

- **chenxia25的核心代码**：
```cpp
const int inf=0x3f3f3f3f;
const int N=2000,H=2000;
int dp[N+1][H];
int n,h,l,r;
int a[N+1];
bool in(int x){return l<=x&&x<=r;}//[x in [l,r]]
int main(){
    cin>>n>>h>>l>>r;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<h;i++)dp[0][i]=-inf;//不合法状态 
    for(int i=1;i<=n;i++)for(int j=0;j<h;j++)//DP 
        dp[i][j]=max(dp[i-1][(j-a[i]+1+h)%h],dp[i-1][(j-a[i]+h)%h])+in(j);//状态转移方程 
    cout<<*max_element(dp[n],dp[n]+h);//目标 
    return 0;
}
```
**核心实现思想**：定义$dp_{i,j}$表示考虑到第$i$次睡觉，第$i$次睡觉在当天第$j$小时醒来时最多的好的睡觉次数。初始化不合法状态为负无穷，通过两层循环进行状态转移，最后输出$dp[n]$中的最大值。

【最优关键思路或技巧】
- **状态定义**：合理定义状态是动态规划的关键，不同的状态定义会影响状态转移方程的复杂度和实现难度。
- **取模运算**：在处理循环时间时，使用取模运算可以避免越界问题，同时要注意取模的正确性。
- **状态初始化**：对于不合法的状态，初始化为极小值可以防止其影响最终结果。

【拓展思路】
同类型题或类似算法套路：
- 其他动态规划问题，如背包问题、最长子序列问题等，都需要合理定义状态和状态转移方程。
- 涉及循环时间或周期性问题，都可以考虑使用取模运算来处理。

【推荐题目】
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的01背包问题，与本题的动态规划思想类似。
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：通过动态规划求解最大子段和，状态定义和转移方程的推导有一定的技巧。
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：经典的动态规划问题，需要合理定义状态和状态转移方程。

【个人心得摘录与总结】
- **Scintilla**：作者作为dp菜鸡，在F题上花费大量时间未解决，回来看E题。在1h58min时写完代码，测样例感觉没问题，但因CF登录和卡顿问题影响提交。总结为在考试中遇到难题可以适当调整策略，同时要注意平台的稳定性。 

---
处理用时：60.46秒
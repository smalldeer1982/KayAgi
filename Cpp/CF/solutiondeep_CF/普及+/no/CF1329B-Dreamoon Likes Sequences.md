# 题目信息

# Dreamoon Likes Sequences

## 题目描述

Dreamoon 非常喜欢数列。因此他出了一道数列问题，保证你在 OEIS 上找不到它。

有两个整数 $d, m$，找到这样的数列 $a$ 的数列，满足以下限制条件：

- 数列 $a$ 的长度为 $n$，$n \ge 1$；
- $1 \le a_i \lt a_2 \lt \cdots \lt a_n \le d$；
- 定义一个长度为 $n$ 的数组 $b$：$b_1 = a_1$，$\forall i \ge 1, b_i  = b_{i - 1} \oplus a_i$，其中 $\oplus$ 表示二进制异或 (xor)。在构建出 $b$ 后，应当满足 $b_1 \lt b_2 \lt \cdots \lt b_{n - 1} \lt b_n$ 的限制条件。

由于满足条件的数列数量可能很多，请输出答案模 $m$ 的结果。

## 样例 #1

### 输入

```
10
1 1000000000
2 999999999
3 99999998
4 9999997
5 999996
6 99995
7 9994
8 993
9 92
10 1```

### 输出

```
1
3
5
11
17
23
29
59
89
0```

# AI分析结果

【题目内容】
Dreamoon 非常喜欢数列。因此他出了一道数列问题，保证你在 OEIS 上找不到它。

有两个整数 $d, m$，找到这样的数列 $a$ 的数量，满足以下限制条件：
- 数列 $a$ 的长度为 $n$，$n \ge 1$；
- $1 \le a_1 < a_2 < \cdots < a_n \le d$；
- 定义一个长度为 $n$ 的数组 $b$：$b_1 = a_1$，$\forall i \ge 1, b_i  = b_{i - 1} \oplus a_i$，其中 $\oplus$ 表示二进制异或 (xor)。在构建出 $b$ 后，应当满足 $b_1 < b_2 < \cdots < b_{n - 1} < b_n$ 的限制条件。

由于满足条件的数列数量可能很多，请输出答案模 $m$ 的结果。

【算法分类】数学

【综合分析与结论】
这些题解主要围绕找出满足特定条件的数列 $a$ 的数量展开。不同题解的核心在于发现数列 $a$ 中元素二进制最高位严格递增这一关键性质，在此基础上采用了不同的方法来计算满足条件的数列数量。
- **思路对比**：
    - Alex_Wei、asdfo123、nullqtr_pwp 从数学原理出发，通过分析二进制位数的贡献，利用乘法原理直接计算结果。
    - WYXkk、BFqwq 通过打表找规律，从数列的差分、商等角度发现规律后计算答案。
    - 一扶苏一、tommymio 采用动态规划的方法，通过定义状态和状态转移方程来求解。
- **算法要点**：
    - 数学方法的要点在于准确分析不同二进制位数的元素对答案的贡献，并利用乘法原理计算。
    - 打表找规律的方法需要耐心地对数列进行差分、商等运算，从而发现潜在规律。
    - 动态规划的方法关键在于合理定义状态和状态转移方程，同时处理好边界条件。
- **解决难点**：
    - 数学方法需要严谨地证明二进制位数递增的性质，并正确处理最高位的边界情况。
    - 打表找规律的方法需要敏锐的观察力，从大量数据中发现规律，且要确保规律的正确性。
    - 动态规划的方法需要处理好状态转移和边界条件，避免重复计算和遗漏情况。

【所选的题解】
- **Alex_Wei（4星）**：
    - **关键亮点**：思路简洁明了，通过引理证明了二进制位数递增的性质，直接利用乘法原理计算答案，代码简洁高效。
    - **核心代码**：
```cpp
void solve(){
    cin>>d>>m; ll ans=1,c=log2(d);
    for(int i=0;i<=c;i++)ans=ans*(i<c?(1<<i)+1:d-(1<<i)+2)%m;
    cout<<(ans-1+m)%m<<endl;
}
```
    - **核心实现思想**：先计算出 $d$ 的二进制位数 $c$，然后枚举位数 $i$，对于位数小于 $c$ 的情况，贡献为 $2^i + 1$（表示该位数的数的个数或不出现）；对于位数等于 $c$ 的情况，贡献为 $d - 2^i + 2$。最后将所有贡献相乘，再减去 $n = 0$ 的情况。
- **WYXkk（4星）**：
    - **关键亮点**：通过打表找规律的方法，从数列的差分中发现规律，思路独特，代码实现较为清晰。
    - **核心代码**：
```cpp
int main()
{
    int t=rd();while(t--)
    {
        rd(d);rd(m);
        ll ans=0,tmp=1;
        F(i,1,32)
        {
            if(d<(1ll<<i))
            {
                ans+=(d-(1ll<<(i-1))+1)*tmp;
                ans%=m;
                break;
            }
            else
            {
                ans+=(1ll<<(i-1))*tmp;
                ans%=m;
                tmp*=((1ll<<(i-1))+1);
                tmp%=m;
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：通过对打表得到的数列进行差分，发现规律 $d_{2^i}=d_{2^i+1}=\cdots=d_{2^{i+1}-1}$ 和 $d_{2^{i+1}}=d_{2^i}\times(2^i+1)$，然后根据这个规律分段计算答案。
- **一扶苏一（4星）**：
    - **关键亮点**：采用动态规划的方法，对问题进行了深入的分析和证明，通过维护前缀和优化了转移复杂度。
    - **核心代码**：
```cpp
const int maxn = 35;
ll d, m;
ll f[maxn][maxn], sum[maxn][maxn];
int lg2(int x) {
  int ret = 1;
  while ((1 << ret) <= x) ++ret;
  return ret - 1;
}
int main() {
  freopen("1.in", "r", stdin);
  int t;
  for (qr(t); t; --t) {
    qr(d); qr(m);
    int n = lg2(d) + 1;
    ll ans = 0;
    for (int len = 1; len <= n; ++len) {
      memset(f, 0, sizeof f);
      memset(sum, 0, sizeof sum);
      f[1][0] = 1;
      sum[1][0] = 1;
      for (int i = 1; i < n; ++i) {
        f[1][i] = (1 << i) % m;
        sum[1][i] = (sum[1][i - 1] + f[1][i]) % m;
      }
      for (int i = 2, di = i - 1; i <= len; di = i++) {
        for (int j = i - 1, dj = j - 1; j < n; dj = j++) {
          f[i][j] = sum[di][dj] * (1 << j) % m;
          sum[i][j] = (sum[i][dj] + f[i][j]) % m;
        }
      }
      for (int i = 0; i <= n; ++i) (ans += f[len][i]) %= m;
      ans -= sum[len - 1][n - 2] * ((1 << n) - d - 1) % m;
      if (ans < 0) ans += m;
    }
    ans -= ((1 << n) - d - 1) % m;
    if (ans < 0) ans += m;
    qw(ans, '\n');
  }
  return 0;
}
```
    - **核心实现思想**：定义状态 $f_{i, j}$ 表示考虑前 $i$ 个数字，第 $i$ 个数字的最高位是 $j$ 的方案数，通过状态转移方程 $f_{i, j} = \sum_{k = 0}^{j - 1} f_{i - 1, k}$ 进行转移，同时维护前缀和 $sum$ 优化转移复杂度，最后处理边界条件得到答案。

【最优关键思路或技巧】
- 发现数列 $a$ 中元素二进制最高位严格递增的性质是解决本题的关键，基于此可以采用不同的方法进行计算。
- 打表找规律是一种有效的解题思路，通过对数据进行差分、商等运算，可能会发现潜在的规律。
- 动态规划中维护前缀和可以优化转移复杂度，提高算法效率。

【可拓展之处】
同类型题可能会对数列的限制条件进行修改，例如改变异或的规则、增加其他约束条件等。类似算法套路可以应用于其他涉及二进制运算和数列计数的问题，关键在于分析数列元素的二进制特征，利用数学原理或动态规划等方法进行求解。

【推荐题目】
- [P1044 栈](https://www.luogu.com.cn/problem/P1044)：涉及数列的计数问题，需要通过递推的方法求解。
- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：同样是数列计数问题，可通过递归或递推的方法解决。
- [P1134 阶乘问题](https://www.luogu.com.cn/problem/P1134)：涉及数学计算和取模运算，与本题的取模处理有相似之处。

【个人心得】
- WYXkk：“找 规 律 t x d y！”，强调了找规律在解题中的重要性和趣味性。
- BFqwq：“这充分说明了我的菜”，体现了在找规律过程中可能会遇到困难，但也可以通过不断尝试找到解决方法。

---
处理用时：61.86秒
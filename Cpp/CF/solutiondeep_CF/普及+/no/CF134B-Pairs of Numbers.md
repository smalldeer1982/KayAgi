# 题目信息

# Pairs of Numbers

## 题目描述

让我们假设有一对数$(a,b)$。我们可以从前一步得到后一对数$(a+b,b)$或者$(a,a+b)$。



让我们规定一开始这对数为$(1,1)$。你的任务就是找到数$k$，使$k$为从$(1,1)$转换到一对至少含有一个$n$的数对的最少步骤。

## 样例 #1

### 输入

```
5
```

### 输出

```
3
```

## 样例 #2

### 输入

```
1
```

### 输出

```
0
```

# AI分析结果

### 题目内容
# 数字对

## 题目描述
假设有一对数$(a,b)$。可以从前一步的数对得到后一对数，方式为$(a + b,b)$或者$(a,a + b)$。规定一开始这对数为$(1,1)$。任务是找到数$k$，$k$为从$(1,1)$转换到一对至少含有一个$n$的数对的最少步骤。

## 样例 #1
### 输入
```
5
```
### 输出
```
3
```

## 样例 #2
### 输入
```
1
```
### 输出
```
0
```

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
这些题解主要围绕如何优化从初始数对$(1,1)$变换到至少含一个$n$的数对的搜索过程。多数题解采用逆向搜索，从可能的目标状态$(i,n)$或$(n,i)$（$1\leq i\leq n$）往$(1,1)$倒推，以减少无效状态的搜索，同时运用剪枝策略进一步优化。部分题解还通过与更相减损术或辗转相除法的联系，提供了独特的思路。

### 所选的题解
- **作者：GalwayGirl (5星)**
    - **关键亮点**：创新性地联想到更相减损术及辗转相除法，利用辗转相除法倒推，通过枚举小于等于$n$的另一个数，在递归中巧妙计算操作次数，代码简洁高效。
    - **个人心得**：作者表示看到题目中数对变换方式联想到更相减损术，发现直接用其类似暴搜，进而想到等同于的辗转相除法优化思路。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,min_=1e9;
int gcd(int a,int b){
    if(!b)return 1e9;
    if(b==1)return a-1;
    return gcd(b,a%b)+a/b;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)min_=min(min_,gcd(n,i));
    printf("%d",min_);
    return 0;
}
```
核心思想：通过自定义的`gcd`函数递归计算从$(a,b)$到$(1,1)$的操作次数，在`main`函数中枚举$i$找到最小操作次数。
- **作者：CGDGAD (4星)**
    - **关键亮点**：清晰阐述正向搜索的弊端，采用逆向bfs（实际代码为dfs），详细说明dfs函数的边界条件与实现方法，逻辑清晰。
    - **核心代码**：
```cpp
#include <cstdio>
#define MIN(A, B) (A < B? A : B)
int min = 100000000, n;
void dfs(int a, int b, int step) {
	if (a < 1 || b < 1 || step >= min) {
		return;
	}
	if (a == 1 && b == 1) {
		min = MIN(min, step);
	}
	if (a - b > 0) {
		dfs(a - b, b, step + 1);
	}
	if (b - a > 0) {
		dfs(a, b - a, step + 1);
	}
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i += 1) {
		dfs(i, n, 0);
	}
	printf("%d\n", min);
	return 0;
}
```
核心思想：定义`dfs`函数从$(a,b)$倒推到$(1,1)$，在`main`函数中枚举$i$调用`dfs`，通过边界条件剪枝并更新最小步数。
- **作者：Purple_Circle (4星)**
    - **关键亮点**：简洁明了地阐述题意与dfs搜索思路，包括搜索方向、dfs本体的策略与剪枝条件，代码实现清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define rd read()
using namespace std;
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * f;
}
int ans=0x3f3f3f3f,n;
void dfs(int a,int b,int now){
	if(a<1||b<1||now>=ans){
		return;
	}
	if(a==1&&b==1){
		ans=now;
	}
	dfs(a-b,b,now+1);
	dfs(a,b-a,now+1);
}
int main(){
	n=rd;
	for(int i=1;i<=n;i++){
		dfs(i,n,0);
	}
	cout<<ans;
	return 0;
}
```
核心思想：通过`dfs`函数从$(a,b)$倒推到$(1,1)$，在`main`函数中枚举$i$调用`dfs`，利用剪枝条件优化并更新最小步数。

### 最优关键思路或技巧
逆向搜索大大减少搜索空间，避免正向搜索的指数级增长。结合剪枝策略，如最优化剪枝（当前步数大于已得最优解则停止搜索）和可行性剪枝（数对中出现不符合条件的值则停止搜索），进一步提升效率。GalwayGirl题解中利用辗转相除法与题目数对变换的联系，提供了一种非典型但高效的解决思路。

### 拓展思路
此类题目属于状态搜索与优化问题，类似套路包括分析状态转移的方向与可能性，通过逆向思维、剪枝等优化搜索。同类型题可考虑一些需要寻找最优变换步骤的问题，例如某些数字变换游戏，通过特定规则将初始数字变换到目标数字，求最少步数。

### 洛谷相似题目推荐
- **P1120 小木棍［数据加强版］**：通过搜索与剪枝，将长木棍锯成小木棍，求满足条件的最小长度，考察搜索与剪枝技巧。
- **P1312 玛雅游戏**：通过模拟游戏过程，利用搜索寻找消除方块的最优策略，锻炼搜索与状态处理能力。
- **P1433 吃奶酪**：通过搜索不同路径，求遍历所有奶酪的最短路径，涉及搜索与距离计算。 

---
处理用时：67.76秒
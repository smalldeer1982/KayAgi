# 题目信息

# Ehab and Prefix MEXs

## 题目描述

给出一个长度为 $n$ 的序列 $A$，你需要找到一个长度为 $n$ 的序列 $B$，满足 $A_i=mex(\{B_1,B_2,\dots,B_i\})$。

其中 $mex$ 函数的结果是最小的未出现在集合中的非负整数。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
0 1 2```

## 样例 #2

### 输入

```
4
0 0 0 2```

### 输出

```
1 3 4 0```

## 样例 #3

### 输入

```
3
1 1 3```

### 输出

```
0 2 1```

# AI分析结果

【题目内容】
# Ehab 和前缀 MEX 值

## 题目描述

给定一个长度为 $n$ 的序列 $A$，你需要找出一个长度为 $n$ 的序列 $B$，使得 $A_i = mex(\{B_1, B_2, \dots, B_i\})$。

其中 $mex$ 函数的结果是集合中最小的未出现的非负整数。

## 样例 #1

### 输入
```
3
1 2 3
```

### 输出
```
0 1 2
```

## 样例 #2

### 输入
```
4
0 0 0 2
```

### 输出
```
1 3 4 0
```

## 样例 #3

### 输入
```
3
1 1 3
```

### 输出
```
0 2 1
```

【算法分类】
构造

【综合分析与结论】
这些题解的核心目标都是根据给定的 $A$ 序列构造出满足条件的 $B$ 序列。不同题解的思路和实现方法各有特点：
- **无解判断**：多数题解都提到若 $a_i > i$ 则一定无解，因为要使第 $i$ 次的 $\text{mex}=a_i$，至少要放 $a_i$ 个数，而此时能放数的位置小于 $a_i$。
- **构造思路**：
    - 部分题解将 $b_i$ 分为对 $a_i$ 有影响和暂时无影响的两类，通过指针和标记来填充数字。
    - 部分题解利用 $mex$ 性质，当 $a_i \neq a_{i - 1}$ 时，$b_i$ 一定为 $a_{i - 1}$，其余情况填充合适数字。
    - 部分题解使用 `set` 存储可填数字，每次取最小的填充。

【所选的题解】
- **作者：H6_6Q (赞：5)  ★★★★**
    - **关键亮点**：思路清晰，将 $b_i$ 分类处理，通过指针和标记控制数字填充，代码实现简洁明了。
- **作者：EDqwq (赞：3)  ★★★★**
    - **关键亮点**：详细阐述了 $mex$ 性质，利用性质进行无解判断和构造，代码逻辑清晰。
- **作者：AlicX (赞：1)  ★★★★**
    - **关键亮点**：使用 `set` 存储可填数字，思路独特，实现简单，时间复杂度为 $O(n\log n)$。

【重点代码】
- **作者：H6_6Q**
```cpp
for(int i=1;i<=n;++i)
{
    if(a[i]>i)
    {
        printf("-1\n");
        return 0;
    }
    for(;num<=a[i]-1;++num)
    {
        if(b[i]==-1)
            b[i]=num;
        else
        {
            while(b[now]!=-1)
                now++;
            b[now]=num;
        }
    }
    num=a[i];
}
```
**核心实现思想**：先判断是否无解，然后将 $num$ 到 $a_i - 1$ 的数字填充到合适位置，更新 $num$。

- **作者：EDqwq**
```cpp
for(int i = 1;i <= n;i ++){
    if(a[i] > i){
        puts("-1");
        return 0;
    }
    if(a[i] < a[i - 1]){
        puts("-1");
        return 0;
    }
    for(int j = num;j <= a[i] - 1;j ++){
        if(b[i] == -1)b[i] = j;
        else {
            while(b[now] != -1)now ++;
            b[now] = j;
        }
        num = j;
    }
    num = a[i];
}
```
**核心实现思想**：先进行无解判断，然后根据 $mex$ 性质填充数字，更新 $num$。

- **作者：AlicX**
```cpp
for(int i=1;i<=n;i++){ 
    b[i]=*s.begin(); s.erase(s.begin()); mp[a[i]]--; 
    if(!mp[a[i]]) s.insert(a[i]);  
}
```
**核心实现思想**：每次从 `set` 中取出最小的数字填充到 $b[i]$，更新 `set` 和计数数组。

【最优关键思路或技巧】
- 利用 $mex$ 性质进行无解判断，即若 $a_i > i$ 或 $a_i < a_{i - 1}$ 则无解。
- 将 $b_i$ 分类处理，分别填充对 $a_i$ 有影响和暂时无影响的数字。
- 使用 `set` 存储可填数字，方便取出最小的数字。

【可拓展之处】
同类型题可能会对 $mex$ 函数进行变形或增加其他限制条件，类似算法套路可以先分析问题的性质，找出无解条件，然后根据性质进行构造。

【推荐题目】
- [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

【个人心得】
无

---
处理用时：36.08秒
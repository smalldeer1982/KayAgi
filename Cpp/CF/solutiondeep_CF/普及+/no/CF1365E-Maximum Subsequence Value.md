# 题目信息

# Maximum Subsequence Value

## 题目描述

给出一个长度为 $n$ 的数列 $a$，你需要选出一个子序列，使其价值最大，输出最大的价值。  

对于一个长度为 $k$ 的子序列，若在这个子序列中有不少于 $\max(1,k-2)$ 个数的二进制位 $i$ 上是 $1$，则其价值增加 $2^i$。

## 样例 #1

### 输入

```
3
2 1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3
3 1 4```

### 输出

```
7```

## 样例 #3

### 输入

```
1
1```

### 输出

```
1```

## 样例 #4

### 输入

```
4
7 7 1 1```

### 输出

```
7```

# AI分析结果

【题目内容】
# 最大子序列价值

## 题目描述
给出一个长度为 $n$ 的数列 $a$，你需要选出一个子序列，使其价值最大，输出最大的价值。  

对于一个长度为 $k$ 的子序列，若在这个子序列中有不少于 $\max(1,k - 2)$ 个数的二进制位 $i$ 上是 $1$，则其价值增加 $2^i$。

## 样例 #1
### 输入
```
3
2 1 3
```
### 输出
```
3
```

## 样例 #2
### 输入
```
3
3 1 4
```
### 输出
```
7
```

## 样例 #3
### 输入
```
1
1
```
### 输出
```
1
```

## 样例 #4
### 输入
```
4
7 7 1 1
```
### 输出
```
7
```

【算法分类】
位运算、枚举

【综合分析与结论】
这些题解的核心思路都是通过分析子序列长度 $k$ 对价值的影响，得出最优解的子序列长度情况，然后通过枚举相应的数来计算最大价值。
 - **思路**：当 $n\leq3$ 时，全选这些数；当 $n > 3$ 时，只需要枚举三个数的组合，取它们按位或的最大值。因为当 $k > 3$ 时，每增加一个数，对二进制位上 $1$ 的个数要求增加，很难比 $k = 3$ 的情况更优。
 - **算法要点**：主要是通过三重循环枚举三个数，计算它们的按位或结果，并不断更新最大值。
 - **解决难点**：难点在于分析出 $k > 3$ 时答案不会更优的结论，需要对题目中价值的计算规则有深入理解。

【所选的题解】
- **do_while_true（5星）**：
  - **关键亮点**：思路清晰，直接根据 $n$ 的取值进行讨论，逻辑简洁明了。
- **rui_er（4星）**：
  - **关键亮点**：代码实现简洁，虽然牺牲了一定的代码常数，但避免了特判，通用性较好。
- **ShineEternal（4星）**：
  - **关键亮点**：对选择三个数是最优的原因解释详细，代码逻辑清晰。

【重点代码】
```cpp
// rui_er的代码
#include <bits/stdc++.h>
#define loop while(true)
#define rep(x,y,z) for(ll x=y;x<=z;x++)
#define per(x,y,z) for(ll x=y;x>=z;x--)
#define fil(x,y) memset(x, y, sizeof(x))
#define mulT0 ll T; for(scanf("%lld", &T);T;T--)
#define mulT1 ll T, rnds; for(scanf("%lld", &T),rnds=1;rnds<=T;rnds++)
using namespace std;
typedef long long ll;
const ll N = 505;

ll n, a[N], ans;

int main() {
    scanf("%lld", &n);
    rep(i, 1, n) scanf("%lld", &a[i]);
    rep(i, 1, n) rep(j, 1, n) rep(k, 1, n) ans = max(ans, a[i]|a[j]|a[k]);
    printf("%lld\n", ans);
    return 0;
}
```
**核心实现思想**：通过三重循环枚举所有可能的三个数的组合，计算它们的按位或结果，并更新最大值。

【关键思路或技巧】
- **贪心策略**：通过分析得出选择三个数是最优的结论，避免了对所有子序列的枚举，降低了时间复杂度。
- **位运算**：利用按位或运算快速计算子序列的价值。

【拓展思路】
同类型题或类似算法套路可能会在子序列的选择规则、价值计算方式上进行变化，但核心思想都是通过分析规则找到最优的选择策略，然后进行枚举计算。

【推荐题目】
1. P1886 滑动窗口 /【模板】单调队列
2. P1908 逆序对
3. P1047 [NOIP2005 普及组] 校门外的树

【个人心得】
本题题解中未包含个人心得内容。

---
处理用时：31.15秒
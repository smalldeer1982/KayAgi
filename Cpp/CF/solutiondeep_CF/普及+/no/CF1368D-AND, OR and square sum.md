# 题目信息

# AND, OR and square sum

## 题目描述

### 题面描述

给定 $n$ 个非负整数 $a_1,\cdots,a_n$。

你可以进行如下操作：选择两个不同的下标 $i,j$ 满足 $1\leq i,j\leq n$，并将 $a_i\gets a_i\ \mathsf{AND}\ a_j,\ a_j\gets a_i\ \mathsf{OR}\ a_j$，**两个赋值同时进行**。AND 是按位与，OR 是按位或。

你可以进行任意次操作。求操作后所有数的平方和的最大值，即 $\max \sum a_i^2$。

## 样例 #1

### 输入

```
1
123```

### 输出

```
15129```

## 样例 #2

### 输入

```
3
1 3 5```

### 输出

```
51```

## 样例 #3

### 输入

```
2
349525 699050```

### 输出

```
1099509530625```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路一致，均是基于位运算的性质，即每次操作不改变两数之和以及二进制下每一位上 1 的个数，通过贪心策略，让大的数尽量大，小的数尽量小，从而使所有数的平方和最大。

思路方面，各题解都先分析出操作前后和不变以及二进制位上 1 的个数不变的性质，然后采用贪心算法，将二进制位上的 1 尽可能地集中到少数数上。

算法要点主要是统计每个二进制位上 1 的个数，再通过循环构造出大的数并计算平方和。

解决的难点在于发现操作的性质，以及如何利用这些性质进行贪心构造。

### 所选题解
- **作者：Alex_Wei (赞：15)  4星**
    - **关键亮点**：思路清晰，代码简洁，对关键性质的证明和思路阐述较为详细，易于理解。
- **作者：KellyFrog (赞：2)  4星**
    - **关键亮点**：代码简洁明了，思路阐述简洁直接，能快速抓住重点。
- **作者：lnwhl (赞：0)  4星**
    - **关键亮点**：思路清晰，对性质的证明和贪心思路的阐述完整，代码规范。

### 重点代码
#### Alex_Wei 的代码
```cpp
ll n,ans,buc[20]; // 记得开 long long 

int main(){
    cin>>n;
    for(int i=1,a;i<=n;i++)
        {cin>>a; for(int j=0;j<20;j++)buc[j]+=(a>>j)&1;}// 统计第 j 位上有多少个 1 
    for(ll i=1,tmp=0;i<=n;i++,ans+=tmp*tmp,tmp=0)
        for(int j=0;j<20;j++)if(buc[j])buc[j]--,tmp+=1<<j;// 每一位有剩下的 1 就选上 
    cout<<ans<<endl;
    return 0;
}
```
**核心实现思想**：先统计每个二进制位上 1 的个数，再通过两层循环，外层循环遍历每个数，内层循环将剩余的 1 尽可能地加到当前数上，最后计算平方和。

#### KellyFrog 的代码
```cpp
#include <iostream>

using namespace std;

typedef long long ll;

ll cnt[25], n, ans, x;

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> x;
        for(int j = 0; j < 20; j++) {
            cnt[j] += (x >> j) & 1ll;
        }
    }
    for(int i = 1; i <= n; i++) {
        ll cur = 0;
        for(int j = 0; j < 20; j++) {
            if(cnt[j]) {
                cnt[j]--;
                cur += 1ll << j;
            }
        }
        ans += cur * cur;
    }
    cout << ans << endl;
    return 0;
}
```
**核心实现思想**：与 Alex_Wei 的思路相同，先统计 1 的个数，再构造大的数并计算平方和。

#### lnwhl 的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int hav[25],n,x;
long long ans=0;
int main() 
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>x;
        for(int j=0;j<20;j++) 
            hav[j]+=(x>>j)&1;//统计每一位1的个数 
    }
    for(int i=1;i<=n;i++) 
    {
        long long res=0;
        for(int j=0;j<20;j++) 
            if(hav[j])//因为贪心，有1就分配 
                hav[j]--,res+=1<<j;
        ans+=res*res;
    }
    cout<<ans;
    return 0;
}
```
**核心实现思想**：同样是先统计二进制位上 1 的个数，再贪心构造大的数并计算平方和。

### 最优关键思路或技巧
- **位运算性质的运用**：通过分析位运算的性质，发现操作前后两数之和以及二进制位上 1 的个数不变，为后续的贪心策略提供了依据。
- **贪心策略**：让大的数尽量大，小的数尽量小，从而使平方和最大。具体实现是将二进制位上的 1 尽可能地集中到少数数上。

### 拓展思路
同类型题或类似算法套路：
- 涉及位运算和贪心的题目，通常需要先分析位运算的性质，再根据性质设计贪心策略。
- 对于一些需要构造最优解的题目，可以考虑通过统计某些关键信息，然后进行合理的分配。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法，通过每次合并最小的两堆果子来使总代价最小。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法，按照接水时间从小到大排序，使所有人的等待时间总和最小。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法，根据物品的单位价值从高到低选择物品，使背包中物品的总价值最大。

### 个人心得
本题解中未包含个人心得内容。

---
处理用时：39.90秒
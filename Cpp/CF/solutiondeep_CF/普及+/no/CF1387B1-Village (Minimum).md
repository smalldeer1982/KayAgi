# 题目信息

# Village (Minimum)

## 题目描述

### 题意

[最大值版本](https://www.luogu.com.cn/problem/CF1387B2)

村里 $n$ 个房子构成了一个 $n$ 点 $n-1$ 条边的**树**结构（下标从 $1$ 开始），每条边长度均为 $1$。一开始每个房子里分别有一个村民。

现在所有村民都需要搬家（改变自己所在的点），搬家后依然需要满足每个房子里**有且只有一个**村民。也就是说，如果原本位于点 $i$ 的村民搬到了点 $v_i$，那么应当满足：

- 对于任意点 $i$，有 $i \neq v_i$。

- 对于任意两个不同的点 $i$ 与 $j$，有 $v_i \neq v_j$。

村民 $i$ 搬家的花费是点 $i$ 到点 $v_i$ 的树上距离（即树上二点间相隔的边数），总花费为所有村民花费之和。求总花费的**最小值**及其方案。

## 说明/提示

- $2 \leq n \leq 10^5$

- $1 \leq a,b \leq n$

## 样例 #1

### 输入

```
4
1 2
2 3
3 4```

### 输出

```
4
2 1 4 3```

## 样例 #2

### 输入

```
7
4 2
5 7
3 4
6 3
1 3
4 5```

### 输出

```
8
3 4 6 2 7 1 5```

# AI分析结果

### 题目标签
深度优先搜索 DFS

### 综合分析与结论
这几道题解都围绕如何解决树结构中节点重排以达到总移动代价最小的问题展开。不同题解思路各有特色：
- Tarsal 的题解采用贪心策略，先让节点和首次遍历的子节点互换，再将未处理的子节点围成环，思路直观，代码实现相对简洁。
- Tx_Lcy 的题解运用树形 DP，通过定义状态和状态转移方程来求解最小花费，理论性较强，但实现和理解难度相对较高。
- xujunlang2011 的题解基于 DFS 从叶子节点向上交换未交换的节点，每次交换代价为 2，思路清晰直接。
- lmy_2011 的题解同样基于 DFS，将子节点数量为 1 的节点加入队列进行交换，逻辑较复杂。

### 所选题解
- **Tarsal（4星）**
  - 关键亮点：思路直观，贪心策略容易理解，代码实现简洁，可读性高。
- **xujunlang2011（3星）**
  - 关键亮点：思路清晰，基于 DFS 直接交换节点，实现简单。
- **Tx_Lcy（3星）**
  - 关键亮点：采用树形 DP 方法，理论性强，对于理解树形 DP 有帮助。

### 重点代码
#### Tarsal 的题解
```cpp
void Dfs(int x, int fa) {
    Next(i, x) {
        int v = e[i].to;
        if(v == fa) continue ;
        Dfs(v, x);
        if(!flag[x] && !flag[v]) { flag[x] = v, flag[v] = x;}
    }
}
int main() {
    int n = read(), ans = 0;
    Rep(i, 2, n) { int u = read(), v = read(); add(u, v), add(v, u); }
    Dfs(1, 0);
    Rep(i, 1, n) {
        if(flag[i]) { ++ ans; continue; }
        int tmp = e[head[i]].to;
        flag[i] = flag[tmp];
        flag[tmp] = i; ans += 2;
    }
    printf("%d\n", ans);
    Rep(i, 1, n) printf("%d ", flag[i]);
    return 0;
}
```
核心实现思想：先通过 DFS 让节点和首次遍历的子节点互换并标记，再处理未标记的节点，将其与相邻节点围成环，计算总代价并输出方案。

#### xujunlang2011 的题解
```cpp
void dfs(int k, int fa)
{
    for (int i = hc[k];i != 0;i = a[i].h)
    {
        if (a[i].v != fa)
        {
            dfs(a[i].v, k);
        }
    }
    if (b[k] == k)
    {
        if (k != 1)
        {
            swap(b[k], b[fa]);
        }
        else
        {
            swap(b[k], b[a[hc[k]].v]);
        }
        num += 2;
    }
}
int main()
{
    cin >> n;
    for (int i = 1;i <= n - 1;i++)
    {
        cin >> x >> y;
        b[i] = i;
        add(x, y);
        add(y, x);
    }
    b[n] = n;
    dfs(1, 1);
    cout << num << "\n";
    for (int i = 1;i <= n;i++)
    {
        cout << b[i] << " ";
    }
    return 0;
}
```
核心实现思想：通过 DFS 从叶子节点向上遍历，若节点未交换过，则与父节点交换（根节点与子节点交换），每次交换代价加 2，最后输出总代价和节点情况。

#### Tx_Lcy 的题解
```cpp
// 状态转移部分
f_{x,0}=f_{x,0}+f_{v,1};
f_{x,1}=\min(f_{x.0}+\min(f_{v,0},f_{v,1})+2,f_{x,1}+\min(f_{v,0}+2,f_{v,1}));
```
核心实现思想：定义状态 $f_{x,0}$ 和 $f_{x,1}$ 分别表示以点 $x$ 为根的子树内，点 $x$ 单独成连通块和与其他点拼成连通块的最小花费，通过状态转移方程求解最小花费，最后根据结果划分连通块并构造方案。

### 最优关键思路或技巧
- 利用 DFS 遍历树结构，从叶子节点向上处理节点交换，能有效简化问题。
- 贪心策略中让节点和相邻节点交换，可使总移动代价最小。

### 拓展思路
同类型题或类似算法套路：
- 树的路径问题，如树的直径、树的重心等。
- 树形 DP 问题，如树上背包、树上最大独立集等。

### 推荐题目
- [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)
- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

### 个人心得
题解中未包含个人心得内容。

---
处理用时：35.56秒
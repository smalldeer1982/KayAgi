# 题目信息

# Weights Division (easy version)

## 题目描述

简单版本和困难版本是两个完全不同的问题，因此我们建议：两题的题面都要仔细阅读。



给定一棵以 $1$ 号点为根的带权有根树。



树是一个无环连通图。有根树有一个被称作根的特殊节点。在从根到节点 $v$ 的路径上，最后一个不同于 $v$ 的节点被称作节点 $v$ 的父亲节点。以节点 $v$ 为父亲的节点称为节点 $v$ 的儿子节点。若一个节点没有任何儿子，则称它为叶子节点。带权树上的边带有权值。



定义一条路径的权值为这条路径上所有边的权值之和。特别地，一条从某个节点到它自己的路径权值为 $0$。



你可以进行一系列的操作，操作零次或多次。对于每次操作，你可以选择任意一条边，将其权值除以 $2$（向下取整）。更正式地说，在每次操作中，你可以选择一条边 $i$，使得这条边的权值 $w_i$ 变成 $\lfloor \frac{w_i}{2} \rfloor$。



你的任务是找到最小操作数，以满足所有从根到叶子的路径的权值之和不超过 $S$。换句话说，如果设 $w(i,j)$ 为从节点 $i$ 到节点 $j$ 的路径的权值，那么你需要使得 $\sum_{v \in leaves} w(root,v) \leq S$，其中 $leaves$ 是所有叶子组成的集合。



你需要回答 $t$ 组独立的数据。

## 样例 #1

### 输入

```
3
3 20
2 1 8
3 1 7
5 50
1 3 100
1 5 10
2 3 123
5 4 55
2 100
1 2 409```

### 输出

```
0
8
3```

# AI分析结果

【题目内容】
# 边权划分（简单版本）

## 题目描述
简单版本和困难版本是两个完全不同的问题，因此我们建议：两题的题面都要仔细阅读。

给定一棵以 1 号点为根的带权有根树。

树是一个无环连通图。有根树有一个被称作根的特殊节点。在从根到节点 v 的路径上，最后一个不同于 v 的节点被称作节点 v 的父亲节点。以节点 v 为父亲的节点称为节点 v 的儿子节点。若一个节点没有任何儿子，则称它为叶子节点。带权树上的边带有权值。

定义一条路径的权值为这条路径上所有边的权值之和。特别地，一条从某个节点到它自己的路径权值为 0。

你可以进行一系列的操作，操作零次或多次。对于每次操作，你可以选择任意一条边，将其权值除以 2（向下取整）。更正式地说，在每次操作中，你可以选择一条边 i，使得这条边的权值 w_i 变成 ⌊ w_i / 2 ⌋。

你的任务是找到最小操作数，以满足所有从根到叶子的路径的权值之和不超过 S。换句话说，如果设 w(i, j) 为从节点 i 到节点 j 的路径的权值，那么你需要使得 ∑(v ∈ leaves) w(root, v) ≤ S，其中 leaves 是所有叶子组成的集合。

你需要回答 t 组独立的数据。

## 样例 #1

### 输入
```
3
3 20
2 1 8
3 1 7
5 50
1 3 100
1 5 10
2 3 123
5 4 55
2 100
1 2 409
```

### 输出
```
0
8
3
```

【算法分类】贪心

【综合分析与结论】
这些题解的核心思路都是贪心，每次选择对总和影响最大的边进行操作，直到满足条件。具体步骤为：先通过深度优先搜索（DFS）预处理出每条边的相关信息（如经过次数、子树中叶子节点个数等），再利用优先队列或集合等数据结构维护边的优先级，不断选择影响最大的边进行操作。

不同题解的差异主要在于代码实现细节和数据结构的使用。有的题解使用优先队列，有的使用集合；在计算边的影响时，有的直接计算边权变化量乘以经过次数，有的通过树形 DP 计算代价系数。

【所选的题解】
- HoshizoraZ（5 星）：关键亮点在于思路清晰，详细阐述了贪心策略的思考过程，包括错误做法的反例和正确做法的推导，代码注释详细，复杂度分析准确。
- do_while_true（4 星）：实现方法和思路简单明了，通过 DFS 预处理边的信息，利用优先队列进行贪心操作，代码结构清晰。
- 45dino（4 星）：思路简洁，明确指出边与边的独立性，利用优先队列计算操作边的最大收益，复杂度分析合理。

【重点代码】
- HoshizoraZ 的核心代码：
```cpp
// 统计每条边出现次数、以及和边权的乘积
ll dfs(int x, int fa){
    ll ss = 0;
    bool bb = 0;
    for(int i = fir[x], y; i; i = e[i].nxt){
        y = e[i].to;
        if(y == fa) continue;
        bb = 1;
        ss += dfs(y, x);
        W[y] = e[i].val;
        sum[y] = s[y] * e[i].val;
    }
    if(!bb) return s[x] = 1;
    else return s[x] = ss;
}

// 主函数部分
while(SS > S){
    xx = q.top().id, yy = q.top().val;
    q.pop(), ++ans;
    SS -= yy * s[xx] - (yy / 2) * s[xx];
    q.push((P){xx, yy / 2});
}
```
核心实现思想：通过 DFS 统计每条边的出现次数和边权乘积，利用优先队列维护边的优先级，每次选择影响最大的边进行操作，更新总和和边权。

- do_while_true 的核心代码：
```cpp
// DFS 预处理边的信息
void dfs(int x, int fa) {
    int son = 0;
    for(int i = head[x]; i; i = e[i].next) {
        if(e[i].to == fa) {
            E[i].f = 1;
            continue ;
        }
        son++;
        dfs(e[i].to, x);
        size[x] += size[e[i].to];
    }
    for(int i = head[x]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        E[i].si = size[e[i].to];
    }
    if(son == 0) size[x] = 1;
}

// 主函数部分
while(sum > S) {
    xx = que.top();
    que.pop();
    sum -= xx.si * xx.va;
    xx.va = xx.va / 2;
    sum += xx.si * xx.va;
    que.push(xx);
    ans++;
}
```
核心实现思想：通过 DFS 预处理每条边下子树的叶子节点个数，利用优先队列维护边的优先级，不断选择影响最大的边进行操作，更新总和和边权。

- 45dino 的核心代码：
```cpp
// DFS 预处理边的信息
int dfs(int x, int fa) {
    int tot = 0;
    for(int i = head[x]; i; i = edge[i].next)
        if(edge[i].to != fa) {
            edge[i].popu = dfs(edge[i].to, x);
            q.push((que){edge[i].val, edge[i].popu});
            sum += edge[i].val * edge[i].popu;
            tot += edge[i].popu;
        }
    tot = max(tot, 1ll);
    return tot;
}

// 主函数部分
while(sum > s) {
    que f = q.top();
    q.pop();
    sum -= (f.val - f.val / 2) * f.popu;
    f.val /= 2;
    q.push(f);
    ans++;
}
```
核心实现思想：通过 DFS 预处理每条边的经过次数，利用优先队列维护边的优先级，不断选择影响最大的边进行操作，更新总和和边权。

【最优关键思路或技巧】
- **贪心策略**：每次选择对总和影响最大的边进行操作，即选择 `(边权 - 边权 / 2) * 出现次数` 最大的边。
- **深度优先搜索（DFS）**：用于预处理每条边的相关信息，如经过次数、子树中叶子节点个数等。
- **优先队列**：用于维护边的优先级，每次可以快速找到影响最大的边。

【拓展思路】
同类型题或类似算法套路：
- 其他树上的贪心问题，如树上的资源分配、路径优化等。
- 涉及边权修改的图论问题，通过贪心策略选择最优的修改方案。

【推荐题目】
- P1090 [NOIP2004 提高组] 合并果子
- P2859 [USACO06FEB]Stall Reservations S
- P1803 凌乱的yyy / 线段覆盖

【个人心得】
- HoshizoraZ：印象深刻的一道题，在设计堆的优先级时，尝试了错误的做法，通过反例发现问题并得出正确做法。总结：在设计贪心策略时，要仔细考虑各种情况，通过反例验证策略的正确性。 

---
处理用时：53.72秒
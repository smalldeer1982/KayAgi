# 题目信息

# Maximum Distributed Tree

## 题目描述

给定一棵 $n$ 个节点，$n-1$ 条边的树。你可以在每一条树上的边标上边权，使得：

1. 每个边权都为 **正整数**；
2. 这 $n-1$ 个边权的 **乘积** 等于 $k$；
3. 边权为 $1$ 的边的数量最少。

定义 $f(u,v)$ 表示节点 $u$ 到节点 $v$ 的简单路径经过的边权总和。你的任务是让 $\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n} f(i,j)$ 最大。

最终答案可能很大，对 $10^9+7$ 取模即可。

$k$ 有可能很大，输入数据中包含了 $m$ 个质数 $p_i$，那么 $k$ 为这些质数的乘积。

## 样例 #1

### 输入

```
3
4
1 2
2 3
3 4
2
2 2
4
3 4
1 3
3 2
2
3 2
7
6 1
2 3
4 6
7 3
5 1
3 6
4
7 5 13 3```

### 输出

```
17
18
286```

# AI分析结果

### 题目翻译
本题已为中文，无需翻译。

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是贪心算法。首先通过深度优先搜索（DFS）计算出每条边对答案的贡献次数，即边左边的点数量乘以右边的点数量。然后根据质数个数 $m$ 与边数 $n - 1$ 的大小关系进行分类讨论：
- 当 $m \leq n - 1$ 时，将较大的质数分配给贡献次数较大的边，剩余边的边权设为 1。
- 当 $m > n - 1$ 时，把多余的较大质数合并，转化为 $m \leq n - 1$ 的情况，再进行分配。

各题解的区别主要在于代码实现方式和细节处理，如使用的数据结构（堆、数组、向量等）、输入输出优化、取模的时机等。

### 较高评分题解
- **Lynkcat（4星）**
    - **关键亮点**：思路清晰，代码简洁，使用优先队列（堆）来处理边的贡献，易于理解。
- **jun头吉吉（4星）**
    - **关键亮点**：详细解释了贪心策略的原理，代码中使用了输入输出优化，提高了效率。
- **huayucaiji（4星）**
    - **关键亮点**：对贪心策略的两种情况进行了详细讨论，并且强调了取模的注意事项，避免了一些常见错误。

### 重点代码
以下是 Lynkcat 题解的核心代码，展示了如何使用 DFS 计算边的贡献和贪心分配边权：
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define mo 1000000007
using namespace std;
int cnt,head[N],size[N],ans,n,m,mx,T,x,y,tp,a[N];
priority_queue <int,vector<int>,less<int> >q;
struct
{
    int to,nx;
}e[N<<1];
void ad(int x,int y)
{
    cnt++;
    e[cnt].to=y;
    e[cnt].nx=head[x];
    head[x]=cnt;
}
void dfs(int k,int fa) 
{
    size[k]=1;
    for (int i=head[k];i;i=e[i].nx)
      if (e[i].to!=fa)
      dfs(e[i].to,k),size[k]+=size[e[i].to];
}
void dfs1(int k,int fa)
{
    for (int i=head[k];i;i=e[i].nx)
      if (e[i].to!=fa)
      {
          q.push(size[e[i].to]*(n-size[e[i].to]));
          dfs1(e[i].to,k);
      }
}
signed main()
{
    cin>>T;
    while (T--)
    {
        cin>>n;cnt=ans=mx=0;
        for (int i=1;i<=n;i++) head[i]=0;
        for (int i=1;i<n;i++)
        {
            cin>>x>>y;
            ad(x,y);
            ad(y,x);
        }
        dfs(1,0);
        dfs1(1,0);
        cin>>m;
        for (int i=1;i<=m;i++) 
        {
            cin>>a[i];
        }
        sort(a+1,a+m+1);
        n--;
        if (m>n) 
        {
            for (int i=n+1;i<=m;i++) (a[n]*=a[i])%=mo;
            m=n;
        }
        while (!q.empty())
        {
            tp=q.top();q.pop();
            (ans+=max(1ll,a[m--])*tp%mo)%=mo;
            if (m<0) m=0;
        }
        cout<<ans<<endl;
    }
}
```
**核心实现思想**：
1. `dfs` 函数：计算以每个节点为根的子树的大小。
2. `dfs1` 函数：将每条边的贡献（子树大小乘以剩余节点数）加入优先队列。
3. 主函数：读取输入，根据 $m$ 和 $n$ 的关系处理质数，然后从优先队列中取出边的贡献，与质数相乘并累加答案。

### 关键思路与技巧
- **贪心策略**：将较大的边权分配给贡献次数较多的边，以最大化最终答案。
- **深度优先搜索（DFS）**：用于计算每条边的贡献次数，即边两边的节点数乘积。
- **分类讨论**：根据质数个数 $m$ 与边数 $n - 1$ 的大小关系，采取不同的处理方式，确保边权为 1 的边数量最少。

### 拓展思路
同类型题目通常涉及在满足一定条件下进行最优分配，常见的算法套路包括贪心、动态规划等。例如，在图论中分配资源、在序列中分配元素等问题，都可以考虑使用贪心策略。

### 推荐题目
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：经典的贪心问题，通过合理安排顺序使总等待时间最短。
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：贪心算法在分组问题中的应用，通过合理分组使组数最少。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法在背包问题中的应用，根据单位价值选择物品。

### 个人心得摘录与总结
- **huayucaiji**：提到朋友将 `product` 理解为 `sum` 而浪费时间，提醒大家仔细审题。
- **Drest**：提到在合并多余质数时，忘记更新 $m$ 的值，导致卡了半小时，提醒大家注意代码细节。

---
处理用时：45.88秒
# 题目信息

# Unshuffling a Deck

## 题目描述

给出一副 $n$ 张编号为 $1$ 到 $n$ 的卡牌，且不一定按照 $1$ 到 $n$ 的顺序给出，你需要按照以下步骤给卡牌排序：

* 任选 $2≤k≤n$ 并将这幅卡牌分为连续非空的 $k$ 个部分 $D_1,D_2,...,D_k$ ，其中 $D_1$ 包含了前 $|D_1|$ 张卡牌（译注： $|D_1|$ 表示 $D_1$ 中卡牌的数量，下同理）， $D_2$ 包含了紧接着的 $|D_2|$ 张卡牌，以此类推。然后将每部分的顺序翻转，将这幅卡牌变为 $D_k,D_{k-1},...,D_2,D_1$ ，操作后的这副卡牌前 $|D_k|$ 张卡牌是属于 $D_k$ 部分的，紧接着的 $|D_{k-1}|$ 张卡牌是属于 $D_{k-1}$ 部分的，以此类推。每部分卡牌内部的顺序不会因此操作而改变。

你需要用至多 $n$ 次操作将卡牌按 $1$ 到 $n$ 的顺序排列好，可以证明必然可以用至多 $n$ 次操作将卡牌排序。

对三副不同规模的卡牌的合法操作例子如下：

* 假设一副卡牌为[3 6 2 1 4 5 7]（3为第一张卡牌而7为最后一张卡牌），我们可以选择 $k=4$ ，将卡牌分为 $D_1$ =[3 6]，$D_2$ =[2 1 4]，$D_3$ =[5]，$D_4$ =[7]，进行操作。如果这样做，这副卡牌会变为 [7 5 2 1 4 3 6]。

* 假设一副卡牌为[3 1 2]，我们可以选择 $k=3$ ，将卡牌分为 $D_1$ =[3]，$D_2$ =[1]，$D_3$ =[2]，进行操作。如果这样做，这副卡牌会变为 [2 1 3]。

* 假设一副卡牌为[5 1 2 4 3 6]，我们可以选择 $k=2$ ，将卡牌分为$D_1$ =[5 1]，$D_2$ =[2 4 3 6]，进行操作。如果这么做，这副卡牌会变为 [2 4 3 6 5 1]。

## 样例 #1

### 输入

```
4
3 1 2 4```

### 输出

```
2
3 1 2 1
2 1 3```

## 样例 #2

### 输入

```
6
6 5 4 3 2 1```

### 输出

```
1
6 1 1 1 1 1 1```

## 样例 #3

### 输入

```
1
1```

### 输出

```
0```

# AI分析结果

### 题目翻译
#### 重新排列一副牌

#### 题目描述
给出一副包含 $n$ 张编号从 $1$ 到 $n$ 的卡牌，且这些卡牌不一定按 $1$ 到 $n$ 的顺序排列。你需要按照以下步骤对卡牌进行排序：

- 任选 $2\leq k\leq n$，并将这副卡牌划分为连续且非空的 $k$ 个部分 $D_1,D_2,\cdots,D_k$，其中 $D_1$ 包含前 $|D_1|$ 张卡牌（$|D_1|$ 表示 $D_1$ 中卡牌的数量，下同），$D_2$ 包含紧接着的 $|D_2|$ 张卡牌，依此类推。然后将每个部分的顺序反转，使这副卡牌变为 $D_k,D_{k - 1},\cdots,D_2,D_1$。操作后，这副卡牌的前 $|D_k|$ 张卡牌属于 $D_k$ 部分，紧接着的 $|D_{k - 1}|$ 张卡牌属于 $D_{k - 1}$ 部分，依此类推。每个部分内部卡牌的顺序不会因该操作而改变。

你需要在至多 $n$ 次操作内将卡牌按 $1$ 到 $n$ 的顺序排列好，可以证明一定能在至多 $n$ 次操作内完成排序。

以下是对三副不同规模卡牌的合法操作示例：

- 假设一副卡牌为 `[3 6 2 1 4 5 7]`（$3$ 为第一张卡牌，$7$ 为最后一张卡牌），我们可以选择 $k = 4$，将卡牌分为 $D_1 = [3 6]$，$D_2 = [2 1 4]$，$D_3 = [5]$，$D_4 = [7]$ 并进行操作。操作后，这副卡牌将变为 `[7 5 2 1 4 3 6]`。
- 假设一副卡牌为 `[3 1 2]`，我们可以选择 $k = 3$，将卡牌分为 $D_1 = [3]$，$D_2 = [1]$，$D_3 = [2]$ 并进行操作。操作后，这副卡牌将变为 `[2 1 3]`。
- 假设一副卡牌为 `[5 1 2 4 3 6]`，我们可以选择 $k = 2$，将卡牌分为 $D_1 = [5 1]$，$D_2 = [2 4 3 6]$ 并进行操作。操作后，这副卡牌将变为 `[2 4 3 6 5 1]`。

#### 样例 #1
##### 输入
```
4
3 1 2 4
```
##### 输出
```
2
3 1 2 1
2 1 3
```

#### 样例 #2
##### 输入
```
6
6 5 4 3 2 1
```
##### 输出
```
1
6 1 1 1 1 1 1
```

#### 样例 #3
##### 输入
```
1
1
```
##### 输出
```
0
```

### 算法分类
构造

### 综合分析与结论
这些题解的核心目标都是在至多 $n$ 次操作内将乱序的卡牌排列为升序。不同题解的思路和实现方式各有不同：
- **7KByte**：通过将 $1$ 移到最前面，然后交替操作使后续数字依次归位，利用每次操作反转序列的特性。
- **SSerxhs**：找到满足 $a_i = a_j + 1$ 的 $i$ 和 $j$，将序列划分为四段进行拼接，不断重复此操作。
- **Eznibuil**：将问题转化为每次操作反转小块，利用快速排序的思想，通过递归和反转连续段使 $0$ 和 $1$ 分开，最终完成排序。
- **Acfboy**：尝试依次将数字组合在一起，通过枚举新放入的数，合理划分序列。
- **jhdonghj**：从 $2$ 到 $n$ 依次将数字和 $1$ 合并，分四种情况讨论如何将 $i + 1$ 合并到 $i$ 旁边，最后处理可能的逆序情况。

### 所选题解
- **7KByte（4星）**
    - **关键亮点**：思路清晰，利用每次操作反转序列的特性，逐步将数字归位，代码实现较为直观。
    - **个人心得**：无
- **jhdonghj（4星）**
    - **关键亮点**：详细分析了将数字合并的四种情况，逻辑严谨，代码中包含了验证结果的部分，保证了代码的正确性。
    - **个人心得**：无
- **Acfboy（4星）**
    - **关键亮点**：使用结构体维护可自由切割和拼接的数组，使代码更清晰，便于理解和实现。
    - **个人心得**：“如果在 CF 赛场上遇到这题恐怕要写很久，因为开始想了个错误的构造写了半天，代码细节也有些多。” 总结：在解题时可能会有错误的思路，且代码实现细节较多，需要耐心调试。

### 重点代码
#### 7KByte
```cpp
void maintain(){
    int hav=0;
    for(int i=0;i<(int)c[top].size();i++){
        for(int j=1;j<=c[top][i];j++)b[n-hav-c[top][i]+j]=a[hav+j];
        hav+=c[top][i];
    }
    rep(i,1,n)a[i]=b[i];
}
```
**核心实现思想**：根据当前划分的部分，将原数组 $a$ 重新排列到数组 $b$ 中，再将 $b$ 复制回 $a$，完成一次操作后的数组更新。

#### jhdonghj
```cpp
vi go(vi a, vi step) {
    vector<vi> tp; vi res;
    for(int i = 0, j = 0; i < a.size(); j++) {
        int sz = step[j]; vi nw;
        while(sz) sz--, nw.pb(a[i]), i++;
        tp.pb(nw);
    }
    reverse(tp.begin(), tp.end());
    for(vi i : tp) for(int j : i) res.pb(j);
    return res;
}
```
**核心实现思想**：根据划分步骤 `step` 将数组 `a` 划分为多个部分，存储在 `tp` 中，反转 `tp` 中部分的顺序，再将各部分元素依次添加到 `res` 中，返回操作后的数组。

#### Acfboy
```cpp
struct twt {
    std::vector<int> a;
    twt() { a.clear(); }
    void push(int x) { a.push_back(x); }
    int find(int x) {
        int an = a.size() + 1;
        for (int i = 0; i < (int)a.size(); i++)
            if (a[i] == x) return i+1;
        return an;
    }
    twt sub(int l, int r) {
        twt an;
        for (int i = l; i <= r; i++) {
            if (i < 1 || i > (int)a.size()) return twt();
            an.push(a[i-1]);
        }
        return an;
    }
    twt operator + (twt y) {
        twt an = *this;
        an.a.insert(an.a.end(), y.a.begin(), y.a.end());
        return an;
    }
    bool fin() {
        for (int i = 0; i < (int)a.size(); i++)
            if (a[i] != i+1) return false;
        return true;
    }
    int size() { return a.size(); }
};
```
**核心实现思想**：定义了一个结构体 `twt` 来维护一个可自由切割和拼接的数组，包含了插入元素、查找元素位置、截取子数组、数组拼接、判断是否有序和获取数组大小等功能。

### 最优关键思路或技巧
- 利用操作反转序列的特性，交替操作使数字逐步归位。
- 分情况讨论如何将数字合并在一起，保证每次操作不会破坏已合并的部分。
- 使用结构体或数据结构来维护和操作数组，使代码更清晰。

### 拓展思路
同类型题或类似算法套路：构造类问题通常需要根据题目给定的操作规则，通过合理的构造步骤来达到目标。可以尝试解决一些其他的构造类问题，如构造特定排列、构造满足条件的图形等。

### 推荐洛谷题目
- P1012 拼数
- P1223 排队接水
- P1090 合并果子

---
处理用时：59.46秒
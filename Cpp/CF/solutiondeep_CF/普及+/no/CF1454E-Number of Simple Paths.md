# 题目信息

# Number of Simple Paths

## 题目描述

给你一张 $ n $ 个节点 $ n $ 条边的**无向连通简单图**， 请你计算出这张图中长度大于等于 $ 1 $ 的不同的**简单路径**的数量， 保证图中没有自环和重边。其中， 简单路径中的节点必须互不相同， 一条路径的长度定义为它所包含的边的数量。

两条路径仅有方向不同时被认为是同一条， 例如 $ 1 -> 2 $ 和 $ 2 -> 1 $。

## 样例 #1

### 输入

```
3
3
1 2
2 3
1 3
4
1 2
2 3
3 4
4 2
5
1 2
2 3
1 3
2 5
4 3```

### 输出

```
6
11
18```

# AI分析结果

### 题目分类
图论

### 综合分析与结论
这些题解主要围绕基环树中简单路径数量的计算展开。整体思路多是先识别基环树的环，再根据环和子树的特点计算路径数量，部分使用容斥原理简化计算。
- **思路对比**：多数题解先确定环，再计算路径数。部分用容斥，如胖头鱼学员、Tarsal 等；部分分类讨论，如两年打铁、Lily_White 等。
- **算法要点**：确定环的方法有 DFS（胖头鱼学员、Tarsal、Lily_White）和拓扑排序（oymz、Remake_）；计算路径数时多涉及子树大小的计算（DFS 或拓扑排序后处理）。
- **难点解决**：关键在于找出环和计算子树大小，不同题解采用不同方法实现，如 DFS 找环、拓扑排序排除非环点。

### 所选题解
- **胖头鱼学员（4星）**
    - **关键亮点**：思路清晰，利用容斥原理简化计算，代码结构明确。
    - **个人心得**：无。
- **oymz（4星）**
    - **关键亮点**：思路简洁，使用拓扑排序找环，复杂度低，代码可读性高。
    - **个人心得**：无。
- **Remake_（4星）**
    - **关键亮点**：容斥思路独特，用 topo 找环，代码实现简洁。
    - **个人心得**：考场上因样例问题花费时间，提醒注意样例准确性。

### 重点代码
#### 胖头鱼学员
```cpp
bool Dfs1(int u, int fa) {
  if (v[u].e) {
    return p = u;
  }
  v[u].e = 1;
  for (int i = 0; i < v[u].y.size(); i++) {
    int to = v[u].y[i];
    if (to != fa && Dfs1(to, u)) {
      v[u].e = p;
      p = (u != p) * p;
      return 1;
    }
  }
  return v[u].e = 0;
}

void Dfs2(int u, int fa) {
  for (int i = 0; i < v[u].y.size(); i++) {
    int to = v[u].y[i];
    if (to != fa && !v[to].e) {
      Dfs2(to, u);
      ans += v[to].s * v[u].s;
      v[u].s += v[to].s;
    }
  }
  ans += v[u].s;
  v[u].s++;
}
```
**核心思想**：`Dfs1` 用于找环，标记环上的点；`Dfs2` 计算子树大小和路径数量。

#### oymz
```cpp
void Kahn(){
  queue<int> q;
  for(int i = 1; i <= n; i++){
    if(d[i] == 1){
      q.push(i);
    }
  }
  while(!q.empty()){
    int u = q.front();
    q.pop();
    vis[u] = 1;
    for(int v : G[u]){
      d[v]--;
      if(d[v] == 1){
        q.push(v);
      }
    }
  }
}

void dfs(int u, int f){
  sz[u] = 1;
  for(int v : G[u]){
    if(v != f && vis[v]){
      dfs(v, u);
      sz[u] += sz[v];
    }
  }
}
```
**核心思想**：`Kahn` 函数用拓扑排序找出环外的点；`dfs` 计算子树大小。

#### Remake_
```cpp
void findSIZE(int dep, int fa)
{
    siz[dep] = 1;
    for (int i = 0; i < e[dep].size(); i++)
    {
        if (e[dep][i] != fa)
        {
            findSIZE(e[dep][i], dep);
            siz[dep] += siz[e[dep][i]];
        }
    }
}
```
**核心思想**：计算子树大小，用于后续容斥计算路径数量。

### 最优关键思路或技巧
- **容斥原理**：通过计算所有可能路径数，减去不合法的路径数，简化计算。
- **拓扑排序**：高效找出环外的点，确定环上的点。

### 可拓展之处
同类型题可能涉及不同的图结构或路径限制，可参考类似的图论问题，如计算有向图中的简单路径数量、带权图中的最短简单路径等。

### 推荐洛谷题目
- P1135 奇怪的电梯
- P1330 封锁阳光大学
- P2820 局域网

---
处理用时：34.70秒
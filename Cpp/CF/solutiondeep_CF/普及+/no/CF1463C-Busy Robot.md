# 题目信息

# Busy Robot

## 题目描述

### 题意翻译

你有一个机器人，初始位置（$0$ 秒），它在数轴上的位置为 $0$。它的速度是 $1$ 单位每秒。

它会接收 $n$ 个命令：在第 $t_i$ 秒移动到 $x_i$ 。在它移动的时候，会忽视你的所有命令。

定义第 $i$ 个命令是成功的，当且仅当在第 $[t_i,t_{i+1}]$ 秒内机器人到达过 $x_i$ 。（我们定义 $t_{n+1}$ 为正无穷）

你的任务就是求出有多少条命令是成功的。

## 样例 #1

### 输入

```
8
3
1 5
3 0
6 4
3
1 5
2 4
10 -5
5
2 -5
3 1
4 1
5 1
6 1
4
3 3
5 -3
9 2
12 0
8
1 1
2 -6
7 2
8 3
12 -9
14 2
18 -1
23 9
5
1 -4
4 -7
6 -1
7 -3
8 -7
2
1 2
2 -2
6
3 10
5 5
8 0
12 -4
14 -7
19 -5```

### 输出

```
1
2
0
2
1
1
0
2```

# AI分析结果

### 题目翻译
你有一个机器人，初始位置（$0$ 秒），它在数轴上的位置为 $0$。它的速度是 $1$ 单位每秒。

它会接收 $n$ 个命令：在第 $t_i$ 秒移动到 $x_i$ 。在它移动的时候，会忽视你的所有命令。

定义第 $i$ 个命令是成功的，当且仅当在第 $[t_i,t_{i+1}]$ 秒内机器人到达过 $x_i$ 。（我们定义 $t_{n+1}$ 为正无穷）

你的任务就是求出有多少条命令是成功的。

### 算法分类
模拟

### 综合分析与结论
- **思路对比**：
    - Eibon 的题解采用递归的方式，按照每个任务进行转移，对后续任务循环判断是否可执行。
    - wz20201136 的题解通过维护当前目的地，判断指令是否被忽略，进而求出每个时刻的位置来判断命令是否有效。
    - naroanah 的题解动态更新当前正在执行的操作，计算每个区间机器人走过的区间，检查目标位置是否在该区间内。
- **算法要点**：
    - Eibon：递归处理任务，判断任务是否可执行及在规定时间内能否到达目标点。
    - wz20201136：模拟机器人移动过程，根据指令是否被忽略更新位置，最后判断命令是否有效。
    - naroanah：动态更新操作信息，计算区间内机器人位置区间，检查目标位置是否在区间内。
- **解决难点**：
    - 都需要处理机器人移动过程中指令的忽略情况，以及判断在规定时间内是否到达目标位置。

### 题解评分
- Eibon：3星，思路较清晰，但递归实现可能导致代码复杂度较高，可读性一般。
- wz20201136：4星，思路清晰，代码简洁，时间复杂度低，可读性较好。
- naroanah：3星，思路合理，但代码中使用了自定义的 `rep` 函数，影响了代码的通用性和可读性。

### 所选题解
- wz20201136（4星）：关键亮点在于思路清晰，通过简单的模拟和位置更新，能高效地解决问题，代码可读性高。

### 重点代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int T,n,wz[MAXN]/*ti是所处位置*/,t[MAXN],x[MAXN],g/*当前目标*/;
int main()
{
    cin>>T;
    while(T--)
    {
        cin>>n;
        g=0;
        for(int i=1;i<=n;i++) 
        {
            scanf("%d%d",&t[i],&x[i]);
            int now=wz[i-1];//上次的位置
            if(now==g||abs(g-now)<=t[i]-t[i-1]) wz[i]=g/*开始时停在上次目标位置*/,g=x[i]/*目标更新*/;//此次指令未被忽略
            else//此次指令被忽略
            {
                if(g>now) wz[i]=now+t[i]-t[i-1];//右移
                else wz[i]=now-t[i]+t[i-1];//左移
            }
        }
        wz[n+1]=g;//因为t_n+1无限大，所以一定能完成当前指令
        int ans=0;
        for(int i=1;i<=n;i++)
            ans+=(min(wz[i],wz[i+1])<=x[i]&&max(wz[i],wz[i+1])>=x[i]);//判断是否有效
        cout<<ans<<endl;
    }
    return 0;
}
```
**核心实现思想**：通过循环读取每个指令，根据机器人当前位置和目标位置以及指令时间，判断指令是否被忽略，更新机器人位置。最后判断每个指令是否有效，统计有效指令的数量。

### 最优关键思路或技巧
模拟机器人的移动过程，根据指令是否被忽略更新位置，通过比较相邻时刻的位置判断目标位置是否在该区间内，从而确定指令是否有效。

### 拓展思路
同类型题可以是机器人在二维平面或三维空间中的移动，或者机器人有不同的速度和移动规则，解题思路仍然是模拟机器人的移动过程，判断指令是否有效。

### 推荐洛谷题目
- P1042 乒乓球
- P1067 多项式输出
- P1098 字符串的展开

---
处理用时：32.15秒
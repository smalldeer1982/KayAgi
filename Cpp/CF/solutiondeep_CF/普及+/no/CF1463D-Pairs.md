# 题目信息

# Pairs

## 题目描述

你有 $2n$ 个整数 $1,2,\cdots,2n$，你需要将其分成 $n$ 对，然后选择其中 $x$ 对，取出其中的较小数，并取出其余 $n-x$ 对中的较大数，使得最终取出的数组成的集合为 $\{b_1,b_2,\cdots,b_n\}$。问有多少个满足题意的 $x$。

数据范围：$1 \le t \le 1000$，$\sum n \le 2 \cdot 10^5$。

## 样例 #1

### 输入

```
3
1
1
5
1 4 5 9 10
2
3 4```

### 输出

```
1
3
1```

# AI分析结果

### 题目内容
#### 题目描述
你有 $2n$ 个整数 $1,2,\cdots,2n$，你需要将其分成 $n$ 对，然后选择其中 $x$ 对，取出其中的较小数，并取出其余 $n - x$ 对中的较大数，使得最终取出的数组成的集合为 $\{b_1,b_2,\cdots,b_n\}$。问有多少个满足题意的 $x$。

数据范围：$1 \le t \le 1000$，$\sum n \le 2 \cdot 10^5$。

#### 样例 #1
##### 输入
```
3
1
1
5
1 4 5 9 10
2
3 4
```

##### 输出
```
1
3
1
```

### 算法分类
数学

### 综合分析与结论
这些题解的核心都是围绕找出满足条件的 $x$ 的个数。不同题解采用了不同的思路和方法：
- **IIIIndex**：通过维护变量 $sp$ 来表示必须取 $min$ 的对数，遍历 $[1, 2n]$ 得到 $sp$ 的最值，进而计算出答案。
- **xhhhh36**：分别按顺序和逆序遍历 $b_i$，考虑取较小值和较大值的情况，通过判断剩余可匹配数的数量来更新答案。
- **wz20201136**：采用贪心和二分的思想，先确定分组情况，再二分查找答案的左右端点。
- **chager**：利用交换法证明引理，预处理出前面最多有多少点可以取较小值和后面最多有多少点可以取较大值，从而计算答案。
- **Fairicle**：证明 $x$ 是连续的，通过从小到大和从大到小枚举 $b_i$ 分别找出最小和最大的 $x$。
- **ny_Dacong**：枚举集合 $b$ 中元素是较小数还是较大数，根据确定的数的个数计算不确定的数的个数。

### 所选的题解
- **IIIIndex（4星）**
    - **关键亮点**：思路清晰，通过维护变量 $sp$ 巧妙地处理了取 $min$ 和 $max$ 的对数关系，代码简洁易懂。
- **Fairicle（4星）**
    - **关键亮点**：证明了 $x$ 的连续性，通过枚举 $b_i$ 找出最小和最大的 $x$，思路独特，利用 `set` 数据结构方便查找未被取的数。
- **wz20201136（4星）**
    - **关键亮点**：结合贪心和二分思想，通过判断分组情况二分查找答案的左右端点，算法复杂度为 $O(n\log n)$。

### 重点代码
#### IIIIIndex
```cpp
int sp=0,maxs=0,mins=0;
for(int i=1;i<=2*n;i++){
    if(used[i]) sp++;
    else sp--;
    maxs=max(maxs,sp);
    mins=min(mins,sp);
}
cout<<n-(maxs-mins)+1<<endl;
```
**核心实现思想**：遍历 $[1, 2n]$，遇到 $b$ 序列中的元素 $sp$ 加 1，否则减 1，记录 $sp$ 的最大值和最小值，最终答案为 $n - (maxs - mins) + 1$。

#### Fairicle
```cpp
// 找最多的取最小值次数
for(ri i=1;i<=n;++i){
    int pre=*--s.lower_bound(b[i]);
    if(pre==-1) continue;
    ansmx++;
    s.erase(pre);
}
// 找最多的取最大值次数
for(ri i=n;i>=1;--i){
    int nxt=*s.upper_bound(b[i]);
    if(nxt==2*n+1) continue;
    ansmn++;
    s.erase(nxt);
}
cout<<ansmx-(n-ansmn)+1<<endl;
```
**核心实现思想**：利用 `set` 存储未被取的数，从小到大枚举 $b_i$ 找最多的取最小值次数，从大到小枚举 $b_i$ 找最多的取最大值次数，最终答案为 $ansmx - (n - ansmn) + 1$。

#### wz20201136
```cpp
bool check1(int x)
{
    for(int i=1,j=n-x+1;i<=x;i++,j++)
        if(b[i]>a[j]) return 0;
    return 1;
}
bool check2(int x)
{
    for(int i=1,j=n-x+1;i<=x;i++,j++)
        if(a[i]>b[j]) return 0;
    return 1;
}
// 二分求答案的左端点
while(l<=r)
{
    int mid=(l+r)/2;
    if(check1(mid)) findr=mid,l=mid+1;
    else r=mid-1;
}
// 二分求答案的右端点
l=0,r=n;
while(l<=r)
{
    int mid=(l+r)/2;
    if(check2(n-mid)) findl=mid,r=mid-1;
    else l=mid+1;
}
printf("%d\n",max(0,findr-findl+1));
```
**核心实现思想**：定义两个检查函数 `check1` 和 `check2`，分别用于判断左端点和右端点是否满足条件，通过二分查找答案的左右端点，最终答案为 $max(0, findr - findl + 1)$。

### 最优关键思路或技巧
- 维护变量 $sp$ 来表示取 $min$ 的对数，通过遍历得到 $sp$ 的最值，从而计算答案，这种方法简洁高效。
- 证明 $x$ 的连续性，通过枚举 $b_i$ 找出最小和最大的 $x$，思路清晰，利用 `set` 数据结构方便查找未被取的数。
- 结合贪心和二分思想，通过判断分组情况二分查找答案的左右端点，降低了时间复杂度。

### 拓展思路
同类型题或类似算法套路可能会涉及到元素的配对和组合问题，需要根据元素之间的大小关系进行合理的分组和选择。可以考虑使用贪心、二分、枚举等算法来解决此类问题。

### 推荐题目
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)
- [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)

### 个人心得
- **chager**：同学打 VP 的时候卡在了这题，然后自己来了兴趣把这道题切了。通过这道题可以看出，遇到难题时可以激发自己的兴趣和挑战欲望，从而更深入地思考和解决问题。

---
处理用时：47.45秒
# 题目信息

# Journey

## 题目描述

有 $n$ 条道路连接着 $n + 1$ 座编号从 $0$ 到 $n$ 的城市，第 $i$ 条道路连接了编号为 $i - 1$ 和 $i$ 的城市，其中 $i\in[1,n]$。

每条道路都有初始方向，初始方向用一个字符串表示。如果第 $i$ 个字符为 $\texttt{L}$，则第 $i$ 条道路一开始从城市 $i$ 连向 $i - 1$；$\texttt R$ 则表示该道路一开始从城市 $i$ 连向 $i+1$。

一个旅行者会从某个城市开始旅行，每次旅行只能沿着道路的方向去到一个相邻的城市，**每走过一次道路之后所有道路的方向都会发生改变**。

对于每个城市，求旅行者从该城市出发最多能到达城市的数量（同一城市可以经过多次，但是只计算一次）。

## 说明/提示

$1\le t\le 1\times 10^4$，对于每组数据 $1\le n\le 3\times 10^5$，且同一测试点内有 $1\le \sum n\le 3\times 10^5$。

## 样例 #1

### 输入

```
2
6
LRRRLL
3
LRL```

### 输出

```
1 3 2 3 1 3 2
1 4 1 4```

# AI分析结果

### 题目分类
动态规划

### 综合分析与结论
这些题解主要围绕如何计算从每个城市出发最多能到达的城市数量展开。核心思路是利用旅行者行走时道路方向改变的特性，发现若能从 $a$ 走到 $b$ 就能从 $b$ 走回 $a$，所以只需分别求出向左和向右能走的最远距离，二者相加再加 1（自身）即为答案。

各题解的主要区别在于实现方式：部分题解采用动态规划递推的方式，通过状态转移方程计算左右能走的距离；部分题解使用线段树和二分优化暴力搜索；还有部分题解采用图论建模的方法，如建分层图或使用并查集来解决问题。

### 高评分题解
- **TernaryTree（4星）**
    - **关键亮点**：思路清晰，通过动态规划递推的方式，直接给出状态转移方程，代码简洁易懂，时间复杂度为 $\Theta(\sum n)$，效率较高。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3e5 + 1;
int t, n;
char s[maxn];
int l[maxn], r[maxn];
int main() {
    cin >> t;
    while (t--) {
        cin >> n >> (s + 1);
        l[0] = 0, l[1] = s[1] == 'L';
        r[n] = 0, r[n - 1] = s[n] == 'R';
        for (int i = 2; i <= n; i++) l[i] = s[i - 1] == 'R' && s[i] == 'L' ? l[i - 2] + 2 : s[i] == 'L';
        for (int i = n - 2; i >= 0; i--) r[i] = s[i + 1] == 'R' && s[i + 2] == 'L' ? r[i + 2] + 2 : s[i + 1] == 'R';
        for (int i = 0; i <= n; i++) cout << l[i] + r[i] + 1 << " "; cout << endl;
        for (int i = 0; i <= n; i++) s[i] = l[i] = r[i] = 0;
    }
    return 0;
}
```
    - **核心实现思想**：设 $l_i$ 表示点 $i$ 最多往左走几步，$r_i$ 表示点 $i$ 最多往右走几步，根据道路方向的不同情况进行状态转移，最后输出 $l_i + r_i + 1$。
- **Dzhao（4星）**
    - **关键亮点**：同样采用动态规划的思想，通过定义 $Lmin$ 和 $Rmax$ 数组来记录左右能走到的最远点，逻辑清晰，时间复杂度为 $\mathcal{O}(n)$。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,g[N],T,Rmax[N][2],Lmin[N][2];char s[N];
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%s",&n,s);
        for(int i=0;i<=n;i++) Rmax[i][0]=Rmax[i][1]=Lmin[i][0]=Lmin[i][1]=i; 
        for(int i=1;i<=n;i++) g[i]=(s[i-1]=='L');
        for(int i=n-1;i>=0;i--)
            Rmax[i][g[i+1]]=Rmax[i+1][!g[i+1]];
        for(int i=1;i<=n;i++) 
            Lmin[i][g[i]]=Lmin[i-1][!g[i]];
        for(int i=0;i<=n;i++) 
        {
            int l=i,r=i;
            if(i!=0 && g[i]==1) l=Lmin[i][g[i]];
            if(i!=n && g[i+1]==0) r=Rmax[i][g[i+1]];
            printf("%d ",r-l+1);
        }
        printf("\n");
    }
    return 0;
}
```
    - **核心实现思想**：令 $Lmin[i][0/1]$ 表示从 $i$ 点往**左**走，经过的第一条边方向为 $(0/1)$，**最远**能走到哪个点；$Rmax[i][0/1]$ 表示从 $i$ 点往**右**走，经过的第一条边方向为 $(0/1)$，**最远**能走到哪个点。根据边的方向进行状态转移，最后输出左右最远点之间的城市数量。
- **henrytb（4星）**
    - **关键亮点**：通过定义 $f$ 和 $g$ 数组分别记录向左和向右的最长交替路径长度，状态转移方程清晰，代码实现简洁，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int N=3e5+5;
int _,n;
char s[N];
int f[N][2],g[N][2];
int main() {
    for(scanf("%d",&_);_;--_) {
        scanf("%d",&n);
        rep(i,0,n+1) f[i][0]=f[i][1]=g[i][0]=g[i][1]=0;
        scanf("%s",s+1);
        rep(i,1,n) {
            if(s[i]=='L') f[i][0]=f[i-1][1]+1,f[i][1]=0;
            else f[i][1]=f[i-1][0]+1,f[i][0]=0;
        }
        per(i,n,1) {
            if(s[i]=='R') g[i][0]=g[i+1][1]+1,g[i][1]=0;
            else g[i][1]=g[i+1][0]+1,g[i][0]=0;
        }
        rep(i,0,n) {
            printf("%d ",f[i][0]+g[i+1][0]+1);
        }
        puts("");
    }
    return 0;
}
```
    - **核心实现思想**：开数组 $f_{i,0/1}$ 表示点 $i$ 向左的路的初始方向是 **左/右** 时，向左的最长交替路径；$g_{i,0/1}$ 表示点 $i$ 向右的路的初始方向是 **右/左** 时，向右的最长交替路径。根据道路方向进行状态转移，最后输出 $f_{i,0}+g_{i+1,0}+1$。

### 关键思路与技巧
- **动态规划思想**：通过定义合适的状态数组，如 $l_i$、$r_i$、$Lmin$、$Rmax$、$f$、$g$ 等，根据道路方向的变化规律建立状态转移方程，从而高效地计算出每个城市左右能走的最远距离。
- **图论建模**：部分题解将问题转化为图论问题，如建分层图或使用并查集来处理，利用图的连通性来求解答案。

### 拓展思路
同类型题可能会改变道路方向的变化规则，或者增加一些限制条件，如每个城市有不同的访问代价等。类似的算法套路可以应用在其他涉及路径选择和状态变化的动态规划问题中，关键是要准确分析状态转移的条件和规律。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，考察动态规划的基本思想。
- [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)：通过动态规划求解从顶部到底部的最大路径和。
- [P1802 5 倍经验日](https://www.luogu.com.cn/problem/P1802)：结合了动态规划和决策选择的问题。

### 个人心得摘录与总结
- **walk_alone**：在比赛时尝试用记忆化搜索做，但失败了，并且被其他题拖累导致没时间做这题。总结是可以从图论的角度去思考问题，利用图的性质来简化问题。
- **hjqhs**：从 edge+vscode 转 chrome+cpeditor 且大改码风后做的第一道题，通过分析路径的特点，采用动态规划递推的方式解决问题。 

---
处理用时：61.94秒
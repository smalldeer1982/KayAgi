# 题目信息

# Max Median

## 题目描述

给定一个长度为 $n$ 的序列 $a$，求所有长度 $\ge k$ 的连续子序列中，中位数的最大值。定义中位数是一个长度为 $x$ 的序列升序排序后的第 $\left\lfloor\frac{x+1}{2}\right\rfloor$ 位的值。

## 样例 #1

### 输入

```
5 3
1 2 3 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2
1 2 3 4```

### 输出

```
3```

# AI分析结果

### 题目分类
二分

### 综合分析与结论
这些题解的核心思路都是利用二分答案的方法来解决问题。因为答案具有单调性，所以可以通过二分来不断缩小答案的范围。在判断某个答案是否可行时，都采用了将原数组中大于等于该答案的数置为 1，小于的数置为 -1 的方法，然后通过前缀和与前缀最小值来判断是否存在长度大于等于 k 的区间，使得区间和大于 0，若存在则该答案可行。

### 所选题解
- **MiPloRAs_3316（4星）**
    - **关键亮点**：思路清晰，对二分答案的原理和判断答案是否可行的方法都有详细的解释，代码可读性高。
- **registerGen（4星）**
    - **关键亮点**：提到了相关的套路题 P2824，对判断答案是否可行的方法解释简洁明了。
- **rui_er（4星）**
    - **关键亮点**：对将原数组转化为新数组以及判断中位数的结论有详细的推导，代码结构清晰。

### 重点代码
以下是 MiPloRAs_3316 的核心代码及实现思想：
```cpp
bool check(int x)
{
    //sum 记录前缀和数组，Min 记录前 i 个 sum 中的最小值
    for(int i=1; i<=n; i++)
    {
        sum[i]=sum[i-1];
        Min[i]=Min[i-1];
        if(a[i]>=x) sum[i]++;
        else sum[i]--;
        Min[i]=min(Min[i],sum[i]);
    }
    for(int i=k; i<=n; i++)
        if(sum[i]-Min[i-k]>=1) return true;
    return false;
} 
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1; i<=n; i++)
        scanf("%d",&a[i]);
    int l=0,r=maxn;
    while(l+1<r)
    {
        int mid=l+(r-l)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }//二分可能的中位数 x，使得中位数 >=x 
    printf("%d\n",l);
    return 0;
}
```
**核心实现思想**：`check` 函数用于判断某个答案 `x` 是否可行。首先遍历数组，将大于等于 `x` 的数置为 1，小于的数置为 -1，并计算前缀和数组 `sum` 以及前缀最小值数组 `Min`。然后遍历长度大于等于 `k` 的区间，若存在区间和大于等于 1，则该答案可行。`main` 函数中通过二分不断缩小答案的范围，最终输出最大的可行答案。

### 关键思路或技巧
- **二分答案**：利用答案的单调性，通过二分不断缩小答案的范围，将问题转化为判断某个答案是否可行。
- **数组转化**：将原数组中大于等于答案的数置为 1，小于的数置为 -1，将中位数问题转化为区间和问题。
- **前缀和与前缀最小值**：通过前缀和数组和前缀最小值数组，可以在 $O(1)$ 的时间复杂度内计算任意区间的和，从而判断是否存在满足条件的区间。

### 拓展思路
同类型题或类似算法套路：在处理与中位数、最值相关的问题时，如果答案具有单调性，可以考虑使用二分答案的方法。在判断答案是否可行时，可以通过对原数组进行转化，将问题转化为更易处理的形式，如区间和问题、计数问题等。

### 推荐题目
- P2824 [USACO08NOV]Buying Hay S
- P1873 砍树
- P3853 [TJOI2007]路标设置

### 个人心得
registerGen 提到“RIP 一下 henrytb 大佬，写了个线段树还 FST 了”，说明在解决问题时，要选择合适的算法和数据结构，避免过度复杂的实现导致错误。

---
处理用时：31.86秒
# 题目信息

# Guess the K-th Zero (Hard version)

## 题目描述

# Guess the K-th Zero (Hard version)


**提示: 这是一道交互题**.

数据加强力! 与简化版相比, 现在数据范围比较巨大, $ 1 \le t \le \min(n, 10^4) $ , 而且你的询问次数不得超过 $ 6 \cdot 10^4 $ .

苏苏正在打电动. 她玩的游戏里, 有某个长度固定的 $0,1$ 序列. 苏苏需要在接下来的 $t$ 次操作中猜对从左到右第 $k$ 个 $0$ 的位置.

## 样例 #1

### 输入

```
6 2

2

2

1

1

0

1

0```

### 输出

```
? 4 6

? 1 1

? 1 2

? 5 5

! 5

? 2 2

! 2```

# AI分析结果

### 题目翻译
# 猜第 K 个 0（困难版本）

## 题目描述
这是一道交互题。

数据加强了！与简化版相比，现在数据范围比较巨大，$1 \le t \le \min(n, 10^4)$，而且你的询问次数不得超过 $6 \cdot 10^4$。

苏苏正在打电动。她玩的游戏里，有某个长度固定的 $0,1$ 序列。苏苏需要在接下来的 $t$ 次操作中猜对从左到右第 $k$ 个 $0$ 的位置。

## 样例 #1
### 输入
```
6 2
2
2
1
1
0
1
0
```
### 输出
```
? 4 6
? 1 1
? 1 2
? 5 5
! 5
? 2 2
! 2
```

### 算法分类
二分

### 综合分析与结论
这些题解的核心目标都是在满足询问次数限制的条件下，高效地猜出长度固定的 01 序列中第 $k$ 个 0 的位置。各题解主要围绕二分算法展开，通过不同的数据结构和优化策略来减少询问次数。

- **思路对比**：多数题解采用二分查找第 $k$ 个 0 的位置，部分题解在此基础上进行预处理或分块优化。如 meyi 采用记忆化二分 + 树状数组；Cutest_Junior 用线段树上二分；蒟蒻君HJT 提出分块 + 维护每块 0 的个数的思路。
- **算法要点**：各题解普遍利用二分查找的高效性，结合树状数组、线段树等数据结构来维护区间信息，实现单点查询和区间修改。
- **解决难点**：主要难点在于控制询问次数不超过 $6 \cdot 10^4$，各题解通过记忆化、分块、预处理等方法减少重复询问，从而满足限制。

### 所选题解
- **meyi（5星）**
  - **关键亮点**：思路清晰，采用记忆化二分 + 树状数组的方法，有效减少重复查询，同时利用树状数组支持单点查询和区间修改，满足题目要求。
  - **核心代码**：
```cpp
BIT<int>c;
bool vis[maxn];
inline void half(int l,int r,int k){
    if(l==r){
        printf("! %d\n",l);
        vis[l]=true;
        ri d=l-k-c.query(l);
        c.add(l,d+1);
        c.add(l+1,-d);
        fflush(stdout);
        return;
    }
    ri mid=l+r>>1,tmp;
    if(vis[mid])tmp=c.query(mid);
    else{
        ask(1,mid);
        scanf("%d",&tmp);
        vis[mid]=true;
        ri d=tmp-c.query(mid);
        c.add(mid,d);
        c.add(mid+1,-d);
    }
    if(tmp<=mid-k)half(l,mid,k);
    else half(mid+1,r,k);
}
```
  - **核心实现思想**：`half` 函数实现二分查找，利用 `vis` 数组标记已查询的点，避免重复查询。通过树状数组 `c` 维护区间信息，在找到答案后更新树状数组。

- **Cutest_Junior（4星）**
  - **关键亮点**：使用线段树上二分的做法，通过保存节点信息和 $O(\log n)$ 的修改操作，保证每个节点最多被查询一次，有效控制询问次数。
  - **核心代码**：
```cpp
int query(Tree *t, int l, int r, int k) {
    --t->sum;
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (!t->ls->vis) {
        t->ls->vis = 1;
        t->ls->sum = mid - l + 1 - q(l, mid);
    }
    if (t->ls->sum >= k) return query(t->ls, l, mid, k);
    else return query(t->rs, mid + 1, r, k - t->ls->sum);
}
```
  - **核心实现思想**：`query` 函数在线段树上进行二分查找，根据左子树的 0 的个数判断答案所在的子树，递归查询。

- **DaiRuiChen007（4星）**
  - **关键亮点**：通过记忆化和树状数组维护 $\{b_i\}$ 支持单点查值、单点覆盖和区间加，将二分过程转化为在线段树上逐步向下的过程，有效控制询问次数。
  - **核心代码**：
```cpp
inline int query(int x) {
    if(vis[x]) return B.Query(x);
    vis[x]=true;
    int p=read(1,x);
    B.Modify(x,x,p-B.Query(x));
    return p;
}
inline bool check(int x) {
    return x-query(x)>=k;
}
```
  - **核心实现思想**：`query` 函数实现记忆化查询，利用树状数组 `B` 维护区间信息。`check` 函数用于判断当前位置的 0 的个数是否满足要求。

### 最优关键思路或技巧
- **记忆化**：避免重复查询，减少询问次数。
- **数据结构的运用**：树状数组和线段树可高效维护区间信息，支持单点查询和区间修改。
- **分块思想**：将原序列分块，减少不必要的查询。

### 可拓展之处
同类型题可能会有不同的序列和查询要求，如序列元素不再是 01，或查询条件发生变化。类似算法套路可应用于其他需要在满足一定限制条件下进行高效查找的问题，如在给定区间内查找第 $k$ 大的数等。

### 推荐洛谷题目
- P2671 [NOIP2015 普及组] 求和
- P3374 【模板】树状数组 1
- P1168 中位数

### 个人心得摘录与总结
- **KellyFrog**：提到二分写法不同会导致 `check` 次数不同，`L<R` 的写法是 $\lceil \log_2 w\rceil$ 次 `check`，而 `L<=R` 的写法最多 $\lceil \log_2 w\rceil+1$ 次 `check`，提醒要特别注意二分的写法。总结：在使用二分算法时，要根据具体情况选择合适的二分写法，避免因写法不当增加不必要的操作次数。

---
处理用时：47.58秒
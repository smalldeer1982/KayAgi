# 题目信息

# AquaMoon and Chess

## 题目描述

你有一个长为 $n$ 的棋盘,这个棋盘上有一些棋子,你可以进行如下操作:

如果第 $i + 2$ 个位置是空的,且第 $i + 1$ 个位置非空,则可以将第 $i$ 个位置的棋子挪到第 $i + 2$ 个位置 ($i + 2 \leq n$).

如果第 $i - 2$ 个位置是空的,且第 $i - 1$ 个位置非空,则可以将第 $i$ 个位置的棋子挪到第 $i - 2$ 个位置 ($i - 2 \geq 1$).

现在将给出一个棋盘的初始状态,求可以通过上述操作可以到达的状态数,你可以进行任意次操作,答案对 $998244353$ 取模.

## 样例 #1

### 输入

```
6
4
0110
6
011011
5
01010
20
10001111110110111000
20
00110110100110111101
20
11101111011000100010```

### 输出

```
3
6
1
1287
1287
715```

# AI分析结果

### 题目翻译
已有，无需翻译

### 算法分类
组合数学

### 综合分析与结论
这些题解的核心思路都是先发现相邻的两个 `1`（即 `11`）可以在棋盘中自由移动这一关键性质，然后将问题转化为组合数学问题。不同题解在处理单独的 `1` 时略有差异，但最终都得出只需考虑 `11` 和 `0` 的组合情况。各题解的算法要点主要包括统计 `11` 和 `0` 的数量，以及计算组合数。难点在于如何处理单独的 `1` 对结果的影响，多数题解通过分析发现单独的 `1` 不影响最终的布局方案数，可以忽略。

### 所选题解
- **作者：lanos212 (4星)**
    - **关键亮点**：思路清晰，通过图形详细展示了操作的简化过程和特殊情况的处理，帮助读者更好地理解问题的本质。
    - **个人心得**：无
- **作者：Mo_Han136 (4星)**
    - **关键亮点**：代码实现完整，注释清晰，对组合数的计算和逆元的处理都有详细的实现，方便读者参考。
    - **个人心得**：无
- **作者：Tx_Lcy (4星)**
    - **关键亮点**：思路简洁明了，直接指出 `1` 是被动移动的，不影响答案，重点关注 `11` 和 `0` 的情况，代码实现也较为简洁。
    - **个人心得**：无

### 重点代码
#### 作者：Mo_Han136
```cpp
int FAST(int x,int y){
    int res=1;
    for(;y;y>>=1){
        if(y&1)res=1ll*res*x%P;
        x=1ll*x*x%P;
    }
    return res;
}
void init(){
    F[0]=INV[0]=1;
    rep(i,1,1e5)F[i]=1ll*F[i-1]*i%P;
    INV[100000]=FAST(F[100000],P-2);
    drep(i,99999,1)INV[i]=1ll*INV[i+1]*(i+1)%P;
}
int C(int x,int y){return 1ll*F[x]*INV[y]%P*INV[x-y]%P;}
void solve(){
    scanf("%d%s",&n,s+1);
    int p=1,a=0,b=0;
    for(;p<=n;++p){
        if(s[p]=='1' && s[p+1]=='1'){
            ++a;++p;
        }
        else if(s[p]=='0')++b;
    }
    printf("%d\n",C(a+b,b));
}
```
**核心实现思想**：`FAST` 函数用于快速幂计算，`init` 函数预处理阶乘和阶乘的逆元，`C` 函数计算组合数，`solve` 函数统计 `11` 和 `0` 的数量并计算最终结果。

#### 作者：Tx_Lcy
```cpp
inline int qpow(int a,int b){
    int ans=1;
    while (b){
        if (b&1) ans*=a,ans%=p;
        a*=a,a%=p,b>>=1;
    }
    return ans;
}
inline int C(int n,int m){return fac[n]*qpow(fac[m],p-2)%p*qpow(fac[n-m],p-2)%p;}
signed main(){
    ios::sync_with_stdio(false);
    cout.tie(0),cout.tie(0);
    int T;cin>>T;
    fac[0]=1;
    for (rint i=1;i<=100000;++i) fac[i]=fac[i-1]*i,fac[i]%=p;
    while (T--){
        int n;cin>>n;
        string s;cin>>s;s=" "+s;
        for (rint i=1;i<=n;++i) a[i]=(s[i]=='1');
        int count11=0,count0=0;
        for (rint i=1;i<=n;++i){
            if (a[i]==1 && a[i+1]==1) ++count11,++i;
            count0+=(!a[i]);
        }
        cout<<C(count11+count0,count11)<<'\n';
    }
    return 0;
}
```
**核心实现思想**：`qpow` 函数实现快速幂，`C` 函数计算组合数，在主函数中预处理阶乘，统计 `11` 和 `0` 的数量并输出结果。

### 最优关键思路或技巧
- **思维方式**：通过观察操作的特点，将复杂的棋子移动问题简化为 `11` 和 `0` 的组合问题，忽略单独 `1` 的影响，从而将问题转化为经典的组合数学问题。
- **代码实现技巧**：预处理阶乘和阶乘的逆元，利用快速幂计算逆元，提高组合数计算的效率。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及棋子移动和状态计数的问题，可尝试寻找类似的不变性或简化规则，将问题转化为组合数学问题。
- 对于组合数的计算，可拓展到不同的取模情况和更复杂的组合问题。

### 推荐题目
- [P1869 愚蠢的组合数](https://www.luogu.com.cn/problem/P1869)
- [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)
- [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)

### 个人心得摘录与总结
- **作者：Acfboy**：赛时对着题爆肝两小时收获错误答案，最初考虑 $0$ 的移动但思路错误，后来通过对 $1$ 以 $0$ 为间隔分组解决问题，且最后要验证是否对应所有情况，提醒我们在解题时要多尝试不同思路并验证结果的正确性。 

---
处理用时：44.96秒
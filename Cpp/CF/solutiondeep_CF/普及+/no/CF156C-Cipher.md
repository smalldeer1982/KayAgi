# 题目信息

# Cipher

## 题目描述

题目翻译：

对于单词（字符串） $s$  ，保证它只由小写字母组成。

设 $ s$ 的长度为 $len$ ，下文单词（字符串）下标从 $1$ 开始.

如果一个词可以通过零次或多次运算转换成另一个词，则我们认为这两个词的意思是一致的。

运算仅仅包含以下两种方式。

- 方式一：指定任意一个位置 $p$ $(1 \le p \le len)$使 $s_p$ 上的字母变成 **字母表上** 的后一个字母(如 a 变成 b ，x 变成 y)，而 $s_{p+1}$ 则要变成 **字母表上** 的前一个字母(如 d 变成 c)。
- 方式二：指定任意一个位置 $p$ $(1 \le p \le len)$使 $s_p$ 上的字母变成 **字母表上** 的前一个字母，而 $s_{p+1}$ 则要变成 **字母表上** 的后一个字母。

你需要回答对于输入的单词，一共有多少种与它意思一致的单词。

另外，对于字母 a ，不能将它变成前一个字母（因为它在字母表上没有前一个字母），同理 字母 z 也不能变成后一个字母。

给出多个单词（字符串），你需要分别对它们做出回答。

## 样例 #1

### 输入

```
1
ab
```

### 输出

```
1
```

## 样例 #2

### 输入

```
1
aaaaaaaaaaa
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2
ya
klmbfxzb
```

### 输出

```
24
320092793
```

# AI分析结果

### 题目内容
# Cipher

## 题目描述

题目翻译：

对于单词（字符串） $s$  ，保证它只由小写字母组成。

设 $ s$ 的长度为 $len$ ，下文单词（字符串）下标从 $1$ 开始.

如果一个词可以通过零次或多次运算转换成另一个词，则我们认为这两个词的意思是一致的。

运算仅仅包含以下两种方式。

- 方式一：指定任意一个位置 $p$ $(1 \le p \le len)$使 $s_p$ 上的字母变成 **字母表上** 的后一个字母(如 a 变成 b ，x 变成 y)，而 $s_{p+1}$ 则要变成 **字母表上** 的前一个字母(如 d 变成 c)。
- 方式二：指定任意一个位置 $p$ $(1 \le p \le len)$使 $s_p$ 上的字母变成 **字母表上** 的前一个字母，而 $s_{p+1}$ 则要变成 **字母表上** 的后一个字母。

你需要回答对于输入的单词，一共有多少种与它意思一致的单词。

另外，对于字母 a ，不能将它变成前一个字母（因为它在字母表上没有前一个字母），同理 字母 z 也不能变成后一个字母。

给出多个单词（字符串），你需要分别对它们做出回答。

## 样例 #1

### 输入

```
1
ab
```

### 输出

```
1
```

## 样例 #2

### 输入

```
1
aaaaaaaaaaa
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2
ya
klmbfxzb
```

### 输出

```
24
320092793
```

### 算法分类
组合数学

### 综合分析与结论
这些题解主要围绕将原字符串操作问题转化为数字组合问题来求解。核心思路是发现对字符串的两种操作不会改变字符对应数字之和（将字母映射为1 - 26的整数），从而将问题转化为求把总和为特定值的数拆分成n个在1 - 26之间整数的方案数。
题解主要分为动态规划（DP）和数学方法两类：
 - **DP方法**：定义状态 $dp_{i,j}$ 表示前 $i$ 个数用了 $j$ 的方案数，通过状态转移方程 $dp_{i,j}= \sum\limits_{k = 1}^{26} dp_{i - 1,j - k}$ 来计算方案数，由于该DP数组与输入字符串具体内容无关，所以可以预处理，以 $O(1)$ 复杂度查询。时间复杂度通常为 $O(26^2n^2)$ ，部分题解通过前缀和优化或其他方式可将复杂度优化到 $O(26n^2)$。
 - **数学方法**：利用容斥原理求解。先不考虑数小于等于26的限制，用隔板法求不定方程组解的数量，再通过容斥，钦定 $i$ 个数大于26 ，计算 $(-1)^i$ 倍的给 $i$ 个数预先分配26后做正常不定方程求解的结果，最后累加得到答案，时间复杂度为 $O(tn)$ 。

### 所选的题解
 - **作者：xyf007 (赞：14)  星级：5星  关键亮点：使用容斥原理将问题转化为经典的不定方程求解问题，给出了 $O(tn)$ 的高效解法，避免了DP的较高复杂度。**
```cpp
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <numeric>
constexpr int kMod = 1e9 + 7;
int t, fac[2601], inv[2601];
char s[101];
int Ksm(int a, int b)
{
    int s = 1;
    while (b)
    {
        if (b & 1)
        {
            s = s * static_cast<long long>(a) % kMod;
        }
        a = a * static_cast<long long>(a) % kMod;
        b >>= 1;
    }
    return s;
}
long long C(int x, int y)
{
    if (x < y || y < 0)
    {
        return 0LL;
    }
    return static_cast<long long>(fac[x]) * inv[x - y] % kMod * inv[y] % kMod;
}
int main(int argc, char const *argv[])
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    fac[0] = 1;
    for (int i = 1; i <= 2600; i++)
    {
        fac[i] = fac[i - 1] * static_cast<long long>(i) % kMod;
    }
    inv[2600] = Ksm(fac[2600], kMod - 2);
    for (int i = 2599; i >= 0; i--)
    {
        inv[i] = inv[i + 1] * static_cast<long long>(i + 1) % kMod;
    }
    std::cin >> t;
    while (t--)
    {
        std::cin >> (s + 1);
        std::size_t n = std::strlen(s + 1);
        int tot = 0, ans = 0, f = -1;
        for (size_t i = 1; i <= n; i++)
        {
            tot += s[i] - 'a' + 1;
        }
        for (size_t i = 0; i <= n; i++)
        {
            f *= -1;
            ans = (ans + f * C(n, i) * C(tot - 26 * i - 1, n - 1) % kMod + kMod) % kMod;
        }
        std::cout << (ans - 1 + kMod) % kMod << '\n';
    }
    return 0;
}
```
核心代码实现思想：先预处理阶乘及其逆元用于快速计算组合数，读入数据后，根据字符串计算总和，利用容斥原理公式循环计算并累加各项，最后输出结果并减去原字符串本身对应的1种情况。
 - **作者：laboba (赞：0)  星级：4星  关键亮点：在DP方法中，通过优化状态转移方程，利用前缀和思想优化掉一个26的复杂度，将DP时间复杂度从 $O((26\times n)^2)$ 优化到 $O(26\times n^2)$。**
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=110,mod=1000000007;
long long f[N][N*27];
char ch[N];
int main(){
    for(int i=1;i<=26;i++)f[1][i]=1;
    for(int i=2;i<N;i++)
        for(int j=i;j<=i*26;j++){
            f[i][j]=f[i][j-1]+f[i-1][j-1];
            if(j>=27)f[i][j]-=f[i-1][j-27];
            f[i][j]%=mod;
        }
    int t;
    scanf("%d",&t);
    while(t--){
        scanf("%s",ch+1);
        int sum=0,n=strlen(ch+1);
        for(int i=1;i<=n;i++)sum+=ch[i]-'a'+1;
        printf("%d\n",(f[n][sum]+mod)%mod-1);
    }
}
```
核心代码实现思想：初始化长度为1时的DP值，通过优化后的状态转移方程递推计算不同长度和总和下的方案数，读入数据计算总和后，根据DP数组输出结果并减去原字符串对应的1种情况。

### 最优关键思路或技巧
 - **发现不变量**：将字母映射为数字后，发现字符串操作前后数字总和不变，从而将字符串变换问题转化为数字拆分组合问题。
 - **容斥原理的应用**：对于数字拆分问题，在计算将总和拆分为n个在1 - 26之间整数的方案数时，利用容斥原理，先计算无限制的情况，再通过容斥减去不合法情况，得到高效的 $O(tn)$ 解法。
 - **DP优化**：在DP方法中，通过分析状态转移方程中重叠计算部分，利用前缀和思想优化，减少计算量，降低时间复杂度。

### 同类型题或类似算法套路拓展
同类型题通常围绕字符串变换与计数，关键在于发现操作中的不变量，将其转化为数字组合或计数问题。类似算法套路有：
 - **利用数学原理**：如组合数学中的隔板法、容斥原理等解决组合计数问题。
 - **动态规划**：根据问题特点定义合适的状态和状态转移方程，对于与输入数据具体内容无关的DP数组可进行预处理。

### 洛谷相似知识点题目推荐
 - **P1313 计算系数**：涉及二项式定理与组合数计算，与本题利用数学原理解决计数问题思路相似。
 - **P2158 [SDOI2008] 仪仗队**：通过容斥原理求解满足条件的点的数量，考察容斥原理的应用。
 - **P3200 [HNOI2009] 有趣的数列**：利用卡特兰数和组合数学知识解决计数问题，锻炼组合数学思维。 

---
处理用时：91.68秒
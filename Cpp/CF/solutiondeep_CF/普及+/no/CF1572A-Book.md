# 题目信息

# Book

## 题目描述

给你一本有 $n$ 章的书。

每一章都有一个为理解本章而需要理解的其他章节的特定列表。要理解一个章节，你必须在理解了所需列表中的每一章后再阅读。

目前你还不了解任何章节。你要从头到尾反复阅读这本书，直到你理解整本书。请注意，如果您在阅读某一章节时不理解某些必要章节，则表示您暂时不能理解本章。

输出你要读多少次书才能理解每一章。如果你永远不会理解整本书，那么输出 $-1$。

## 样例 #1

### 输入

```
5
4
1 2
0
2 1 4
1 2
5
1 5
1 1
1 2
1 3
1 4
5
0
0
2 1 2
1 2
2 2 1
4
2 2 3
0
0
2 3 2
5
1 2
1 3
1 4
1 5
0```

### 输出

```
2
-1
1
2
5```

# AI分析结果

### 题目标签
图论

### 综合分析与结论
这些题解的核心思路都是将书的章节关系构建成有向图，利用拓扑排序来解决问题。各题解的主要区别在于对阅读次数的处理方式和数据结构的选择。

- **思路对比**：大部分题解都是通过拓扑排序来判断是否存在环，若存在环则无法读完书，输出 -1。对于阅读次数的计算，有的题解根据章节编号大小来判断是否需要多读一次，有的题解使用边权来表示阅读次数的增加，还有的题解使用动态规划来计算最小阅读次数。
- **算法要点**：
    - 构建有向图：将每个章节看作一个点，若理解第 $x$ 章需要先理解第 $y$ 章，则连一条 $y → x$ 的边。
    - 拓扑排序：从入度为 0 的点开始，依次删除边，更新入度，直到所有点都被处理或无法继续处理。
    - 阅读次数计算：根据章节编号大小或边权来判断是否需要多读一次，取最大值作为最终的阅读次数。
- **解决难点**：
    - 环的判断：通过拓扑排序过程中处理的点的数量与总点数的比较来判断是否存在环。
    - 阅读顺序的处理：由于需要按顺序阅读，不能跳着看章节，因此需要根据章节编号大小来判断是否需要多读一次。

### 所选题解
- **作者：0xFF (赞：9)，4星**
    - **关键亮点**：思路清晰，代码简洁，使用优先队列对图进行拓扑排序，将阅读次数小的放在前面，若阅读次数相同则按照阅读章节编号排序。
    - **核心代码**：
```cpp
void tuopu(){
    for(int i=1;i<=n;i++){
        if(ind[i] == 0){
            q.push(make_pair(1,i));
        }
    }
    while(!q.empty()){
        int u = q.top().second;
        int s = q.top().first;
        q.pop();
        tot++;
        ans = max(ans,s);
        for(int i=0,len=nodes[u].size();i<len;i++){
            int v = nodes[u][i];
            if(--ind[v] == 0){
                if(v > u){
                    q.push(make_pair(s,v));
                }
                else q.push(make_pair(s+1,v)); 
            }
        }
    } 
    return;
}
```
    - **核心实现思想**：首先将入度为 0 的点加入优先队列，每次从队列中取出阅读次数最小的点进行处理，更新其相邻点的入度，若相邻点的入度变为 0，则根据其编号与当前点的编号大小关系，决定将其加入队列时的阅读次数。

- **作者：Eibon (赞：4)，4星**
    - **关键亮点**：使用边权来表示阅读次数的增加，通过拓扑排序计算每个点的最大阅读次数。
    - **核心代码**：
```cpp
void topo_sort()
{
    for(int i=1;i<=n;i++){
        if(!ru[i]){
            q.push(i);
            vis[i]=1;
            output[i]=1;
        }
    }
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            ru[v]--;
            output[v]=max(output[v],output[u]+e[i].w);
            if(!ru[v]){
                q.push(v);
                vis[v]=1;
            }
        }
    }
}
```
    - **核心实现思想**：首先将入度为 0 的点加入队列，每次从队列中取出点进行处理，更新其相邻点的入度和最大阅读次数，若相邻点的入度变为 0，则将其加入队列。

- **作者：Tenshi (赞：3)，4星**
    - **关键亮点**：使用拓扑排序和动态规划的思想，通过状态转移方程计算每个点的最小阅读次数。
    - **核心代码**：
```cpp
int bfs(){
    queue<int> q;
    rep(i,1,n) if(!deg[i]) q.push(i);
    rep(i,1,n) f[i]=0;
    
    int cnt=0;
    while(q.size()){
        int u=q.front(); q.pop();
        cnt++;
        
        for(int i=h[u]; ~i; i=e[i].next){
            int go=e[i].to;
            f[go]=max(f[go], f[u]+e[i].w);
            if(--deg[go]==0){
                q.push(go);
            }
        }
    }
    
    if(cnt!=n) return -1;
    return *max_element(f+1, f+1+n)+1;
}
```
    - **核心实现思想**：首先将入度为 0 的点加入队列，每次从队列中取出点进行处理，更新其相邻点的入度和最小阅读次数，若相邻点的入度变为 0，则将其加入队列。最后判断是否所有点都被处理，若不是则返回 -1，否则返回最大阅读次数加 1。

### 最优关键思路或技巧
- **数据结构**：使用优先队列、队列等数据结构来实现拓扑排序，方便处理入度为 0 的点。
- **边权的运用**：通过边权来表示阅读次数的增加，简化了阅读次数的计算。
- **动态规划思想**：使用动态规划的思想，通过状态转移方程计算每个点的最小阅读次数。

### 可拓展之处
同类型题或类似算法套路：
- 课程表问题：给定一些课程和它们的先修课程，判断是否可以完成所有课程的学习，以及最少需要多少个学期才能完成所有课程的学习。
- 任务调度问题：给定一些任务和它们的依赖关系，安排任务的执行顺序，使得所有任务都能按时完成。

### 推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
- [P2853 [USACO06DEC]Cow Picnic S](https://www.luogu.com.cn/problem/P2853)
- [P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)

### 个人心得摘录与总结
部分题解提到了代码的优化和时间复杂度的问题，如使用快速读写来优化输入输出，避免超时。还有题解提到了拓扑排序的核心思想和应用场景，帮助读者更好地理解和掌握拓扑排序算法。

---
处理用时：87.73秒
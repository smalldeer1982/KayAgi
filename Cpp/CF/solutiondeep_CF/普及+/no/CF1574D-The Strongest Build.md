# 题目信息

# The Strongest Build

## 题目描述

Ivan正在玩另一个类似Rogue的电脑游戏。他控制着游戏里面的一个英雄，这个英雄有 $n$ 个装备槽，对于每个槽 $i$ 而言有 $c_i$ 个物品可以选择，第 $j$ 个物品会增加英雄 $a_{i,j}$ 的力量值。每个槽所对应的物品两两不同并按照可以增加的力量值升序排序，即： $a_{i,1}<a_{i,2}<\dots<a_{i,c_i}$ 

对于每个装备槽，Ivan只能在它所对应的物品列表中至多选一个物品。选择的序列称作一个组合。

一个组合的力量值是组合中所包含的物品提升的力量值之和，然而有 $m$ 个两两不同的组合被游戏禁掉了，保证有至少一个组合没有被禁。

询问满足要求（不被禁）的组合的最大力量值为多少？如果有多个组合有相同的最大值，输出它们之中的任意一个即可。

## 样例 #1

### 输入

```
3
3 1 2 3
2 1 5
3 2 4 6
2
3 2 3
3 2 2```

### 输出

```
2 2 3```

## 样例 #2

### 输入

```
3
3 1 2 3
2 1 5
3 2 4 6
2
3 2 3
2 2 3```

### 输出

```
1 2 3```

## 样例 #3

### 输入

```
3
3 1 2 3
2 1 5
3 2 4 6
2
3 2 3
2 2 3```

### 输出

```
3 2 2```

## 样例 #4

### 输入

```
4
1 10
1 4
1 7
1 3
0```

### 输出

```
1 1 1 1```

# AI分析结果

【题目内容】
# 最强搭配

## 题目描述
Ivan正在玩一款类肉鸽电脑游戏。他操控的英雄有 $n$ 个装备槽，每个槽 $i$ 有 $c_i$ 个物品可供选择，第 $j$ 个物品能为英雄增加 $a_{i,j}$ 的力量值。每个槽对应的物品各不相同，且按力量值升序排列，即 $a_{i,1}<a_{i,2}<\dots<a_{i,c_i}$ 。

每个装备槽最多只能从对应物品列表中选一个物品，所选物品序列称为一个组合。

一个组合的力量值是组合中所有物品增加的力量值之和。不过，游戏中禁掉了 $m$ 个不同的组合，且保证至少存在一个未被禁的组合。

询问满足要求（未被禁）的组合的最大力量值是多少？若有多个组合力量值相同，输出其中任意一个即可。

## 样例 #1

### 输入
```
3
3 1 2 3
2 1 5
3 2 4 6
2
3 2 3
3 2 2
```

### 输出
```
2 2 3
```

## 样例 #2

### 输入
```
3
3 1 2 3
2 1 5
3 2 4 6
2
3 2 3
2 2 3
```

### 输出
```
1 2 3
```

## 样例 #3

### 输入
```
3
3 1 2 3
2 1 5
3 2 4 6
2
3 2 3
2 2 3
```

### 输出
```
3 2 2
```

## 样例 #4

### 输入
```
4
1 10
1 4
1 7
1 3
0
```

### 输出
```
1 1 1 1
```

【算法分类】搜索

【综合分析与结论】
这些题解的核心思路都是从最大力量值的组合开始，逐步调整组合，排除被禁的组合，从而找到未被禁的最大力量值组合。不同题解在实现方式和数据结构的选择上有所不同。
- **Presentation_Emitter**：使用堆优化 BFS，通过哈希值检验状态是否被禁止，优先处理力量值大的状态。
- **Lynkcat**：构建 trie 树存储限制，递归搜索时只向不存在的儿子中最大的走，降低复杂度。
- **huayucaiji**：先找出所有组合，哈希后排序，从大到小检查是否被 ban，后优化为只考虑被 ban 组合调整一个取值得到的组合。
- **AmamiyaYuuko**：若最大组合未被 ban 则直接输出，否则枚举被 ban 序列，尝试将其中一个元素往前取一个，用 `std::map` 维护是否被 ban。
- **henrytb**：从最大组合开始向下搜索，用 `set` 存储状态判断是否合法，与答案取最大值。
- **SSL_wj**：用堆维护状态，每次选出最优扩展，通过结构体标记修改位置唯一表示状态，用 `map` 判断是否被 ban。

各题解的难点在于如何高效地判断组合是否被禁以及如何减少不必要的搜索。不同的题解采用了不同的数据结构和优化方法来解决这些问题。

【所选的题解】
- **Presentation_Emitter（5星）**：
  - 关键亮点：使用堆优化 BFS 高效搜索，通过哈希值快速判断状态是否被禁止，减少不必要的搜索。
  - 个人心得：调侃他人连爆搜都不会，侧面反映出该方法的高效性。
- **Lynkcat（4星）**：
  - 关键亮点：构建 trie 树存储限制，递归搜索时进行优化，将复杂度从 $O(nm\times 10)$ 降到 $O(m\times 10)$。
  - 个人心得：称自己的做法为“阴间做法”，体现出该方法的独特性。
- **huayucaiji（4星）**：
  - 关键亮点：先提出暴力思路，再通过贪心思想优化，只考虑被 ban 组合调整一个取值得到的组合，减少参与排序的组合。
  - 个人心得：提醒代码使用规范，强调代码仅供学习和找错。

【重点代码】
### Presentation_Emitter
```cpp
// 哈希函数
il ll hash1(vector<ll>f)
{
	ll h=0;
	for(int i=0;i<n;++i)h=(h*1333331+f[i])%998244353;
	ret h;
}
il ll hash2(vector<ll>f)
{
	ll h=0;
	for(int i=0;i<n;++i)h=(h*1333331+f[i])%1000000007;
	ret h;
}
il ll hash0(vector<ll>f){ret hash1(f)*1000000007+hash2(f);}

// BFS 过程
while(HgSAKIOI)
{
	auto p=q.top();q.pop();
	ll h=hash0(p.second);if(vs.count(h))continue;
	vs.insert(h);
	if(s.count(h))
	{
		for(int i=1;i<=n;++i)
		{
			--p.second[i-1];
			if(p.second[i-1])q.push(prpr(p.first-v[i][p.second[i-1]+1]+v[i][p.second[i-1]],p.second));
			++p.second[i-1];
		}
	}
	else
	{
		for(int i=0;i<n;++i)prt(p.second[i]," \n"[i==n-1]);
		break;
	}
}
```
核心实现思想：通过哈希函数将组合映射为唯一的哈希值，使用优先队列存储状态，优先处理力量值大的状态，不断扩展状态直到找到未被禁的组合。

### Lynkcat
```c++
// 插入限制到 trie 树
inline void insert()
{
	re int now=1;
	for (int i=1;i<=n;i++)
	{
		if (son[now].count(x[i]))
		{
			now=son[now][x[i]];
		} else
			son[now][x[i]]=++tot,
			now=son[now][x[i]];
	}
}

// 递归搜索
node dfs(int k,int dep,int V)
{
	if (!k)
	{
		re node g;g.init();
		for (int i=dep+1;i<=n;i++) g.p[i]=a[i],g.val+=W[i][a[i]-1];
		g.p[dep]=V;
		g.val+=W[dep][V-1];
		return g;
	}
	if (dep==n) 
	{
		re node g;g.init();
		return g;
	}
	re node g;g.init();
	for (int i=a[dep+1];i>=1;i--)
		if (son[k].count(i))
		{
			g=checkmx(g,dfs(son[k][i],dep+1,i));
		}
		else 
		{
			g=checkmx(g,dfs(0,dep+1,i));
			break;
		}
	if (k==1) return g;
	if (g.val==0) return g;
	g.p[dep]=V;
	g.val+=W[dep][V-1];
	return g;
}
```
核心实现思想：将限制插入 trie 树，递归搜索时根据 trie 树的结构选择合适的儿子节点，只向不存在的儿子中最大的走，减少不必要的搜索。

### huayucaiji
```cpp
// 插入组合
void inw() {
	int sum=0,h1=0,h2=0;
	num++;
	for(int i=1;i<=n;i++) {
		sum+=a[i][tmp[i]];
		b[num].p[i]=tmp[i];
		h1=(h1*b1%m1+tmp[i])%m1;
		h2=(h2*b2%m2+tmp[i])%m2;
	}
	b[num].ans=sum;
	b[num].hsh=make_pair(h1,h2);
}

// 主函数
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		tmp[i]=c[i]=read();
		
		for(int j=1;j<=c[i];j++) {
			a[i][j]=read();
		}
	}
	
	inw();
	
	cin>>m;
	for(int i=1;i<=m;i++) {
		int h1=0,h2=0;
		for(int j=1;j<=n;j++) {
			ban[i][j]=tmp[j]=read();
			h1=(h1*b1%m1+tmp[j])%m1;
			h2=(h2*b2%m2+tmp[j])%m2;
		}
		mp[make_pair(h1,h2)]=1;
	}
	
	for(int i=1;i<=m;i++) {
		for(int j=1;j<=n;j++) {
			tmp[j]=ban[i][j];
		}
		for(int j=1;j<=n;j++) {
			if(ban[i][j]==1) {
				continue;
			}
			tmp[j]--;
			inw();
			tmp[j]++;
		}
	}
	
	sort(b+1,b+num+1,cmp);
	
	for(int i=1;i<=num;i++) {
		if(!mp[b[i].hsh]) {
			for(int j=1;j<=n;j++) {
				cout<<b[i].p[j]<<" ";
			}
			puts("");
			return 0;
		}
	}
	return 0;
}
```
核心实现思想：先找出所有组合，哈希后排序，从大到小检查是否被 ban，后优化为只考虑被 ban 组合调整一个取值得到的组合，减少参与排序的组合。

【最优关键思路或技巧】
- 使用哈希值快速判断组合是否被禁，减少时间复杂度。
- 利用贪心思想，从最大力量值的组合开始搜索，减少不必要的搜索。
- 构建 trie 树存储限制，优化搜索过程。

【拓展思路】
同类型题可能会有更多的限制条件或更复杂的组合规则，类似的算法套路包括使用哈希表、优先队列、树等数据结构优化搜索过程，利用贪心思想减少搜索范围。

【推荐题目】
- P1036 [NOIP2002 普及组] 选数（组合数学、搜索）
- P1135 奇怪的电梯（广度优先搜索 BFS）
- P1443 马的遍历（广度优先搜索 BFS）

【个人心得摘录与总结】
- **Presentation_Emitter**：调侃他人连爆搜都不会，侧面反映出堆优化 BFS 方法的高效性。
- **Lynkcat**：称自己的做法为“阴间做法”，体现出构建 trie 树存储限制并优化搜索过程的独特性。
- **huayucaiji**：提醒代码使用规范，强调代码仅供学习和找错。

---
处理用时：117.50秒
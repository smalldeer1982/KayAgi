# 题目信息

# Divisible by Twenty-Five

## 题目描述

### 题意翻译
Chanek先生有一个数字字符串 $s (1\le\left\vert s \right\vert\le8)$，且该字符串只包含 $0$，$1$，$2$，$3$，$4$，$5$，$6$，$7$，$8$，$9$，$X$，$\_$ （下划线）。每个 $X$ 都表示相同的数字，每个 $\_$ 都表示任意一个数字。

他可以用任一数字替换掉所有的 $X$ ，也可以将 $\_$ 替换为任一数字。但是他要求该数字不能有任何前导 $0$（$0$ 本身除外）。他想知道有多少钟替换方法可以使 $s$ 能被 $25$ 整除。

## 样例 #1

### 输入

```
25```

### 输出

```
1```

## 样例 #2

### 输入

```
_00```

### 输出

```
9```

## 样例 #3

### 输入

```
_XX```

### 输出

```
9```

## 样例 #4

### 输入

```
0```

### 输出

```
1```

## 样例 #5

### 输入

```
0_25```

### 输出

```
0```

# AI分析结果

### 题目翻译
Chanek先生有一个数字字符串 $s (1\le\left\vert s \right\vert\le8)$，且该字符串只包含 $0$，$1$，$2$，$3$，$4$，$5$，$6$，$7$，$8$，$9$，$X$，$\_$ （下划线）。每个 $X$ 都表示相同的数字，每个 $\_$ 都表示任意一个数字。

他可以用任一数字替换掉所有的 $X$ ，也可以将 $\_$ 替换为任一数字。但是他要求该数字不能有任何前导 $0$（$0$ 本身除外）。他想知道有多少钟替换方法可以使 $s$ 能被 $25$ 整除。

### 算法分类
枚举

### 综合分析与结论
这些题解的核心思路都是围绕枚举来解决问题，由于数据范围较小，暴力枚举是可行的。各题解的主要差异在于枚举的方式和处理细节上。
- **思路对比**：部分题解是枚举所有位数正确的 $25$ 的倍数，再检查是否能由字符串 $s$ 变换得到；部分题解是根据字符串 $s$ 的末两位情况进行分类讨论，结合乘法原理计算方案数。
- **算法要点**：都需要注意特判字符串长度为 $1$ 的情况以及前导 $0$ 的问题。对于字符 `X` 和 `_` 的处理，不同题解有不同的实现方式。
- **解决难点**：主要难点在于处理字符 `X` 表示相同数字的限制，以及考虑前导 $0$ 的情况，避免出现不符合要求的数字。

### 所选题解
- **fxwqctb（4星）**：
    - **关键亮点**：思路清晰，对不同长度的字符串和不同字符组合情况进行了详细的分类讨论，代码实现中对各种情况的处理逻辑明确，注释丰富，便于理解。
    - **个人心得**：无。
- **yanhao40340（4星）**：
    - **关键亮点**：先指出可以暴力求解，然后考虑优化，利用能被 $25$ 整除的数的末两位特性，减少枚举量，代码实现时将最后两位单独考虑，码量较少且更便捷。
    - **个人心得**：无。
- **rui_er（4星）**：
    - **关键亮点**：直接枚举所有位数正确的 $25$ 的倍数，通过自定义的 `check` 函数检查是否合法，代码简洁，逻辑清晰。
    - **个人心得**：无。

### 重点代码
#### fxwqctb
```cpp
// 统计 X 和 _ 的个数
for(int i=1;i<strlen(a)-2;i++)
{
    if(a[i]=='X')x++;
    if(a[i]=='_')y++;
}
// 判断最高位是否为 X 或 _
if(a[0]=='X')w=1;
if(a[0]=='_')z=1;
// 根据不同情况计算结果
if(a[strlen(a)-1]=='5')
{
    if(a[strlen(a)-2]=='2'||a[strlen(a)-2]=='7')cout<<(w==1?9:x==0?1:10)*(z==1?9*((y==0)?1:(pow(10,y))):(y==0?1:pow(10,y)));
    // 其他情况省略
}
```
**核心实现思想**：先统计字符串中 `X` 和 `_` 的个数，以及最高位的情况，再根据字符串的末两位情况进行分类讨论，结合乘法原理计算方案数。

#### yanhao40340
```cpp
void change(char number){
    for (int i=0;i<=9;++i)
        if (flag[i])
            s[i]=number;
    return;
}
void counts(int len){
    int cnt=1;
    if (((s[len-1]-48)*10+s[len]-48)%25 && s[len-1]!='_' && s[len]!='_') return;
    for (int i=1;i<=len-2;++i){
        if (i==1 && s[i]=='_') cnt*=9;
        else if (s[i]=='_') cnt*=10;
    }
    // 单独讨论后两位
    if (s[len-1]=='_' && s[len]=='_' && len>2) cnt*=4;
    else if (s[len-1]=='_' && s[len]=='_' && len==2) cnt*=3;
    // 其他情况省略
    ans+=cnt;return;
}
```
**核心实现思想**：`change` 函数用于将字符串中的 `X` 替换为指定数字，`counts` 函数用于统计满足条件的方案数，先判断最后两位是否能被 $25$ 整除，再根据 `_` 的位置和数量计算方案数。

#### rui_er
```cpp
bool check(int val) {
    int x = -1;
    per(i, n, 1) {
        int u = val % 10;
        val /= 10;
        if(isdigit(s[i]) && s[i] - '0' != u) return 0;
        if(s[i] == 'X') {
            if(x == -1) x = u;
            else if(x != u) return 0;
        }
    }
    return 1;
}
```
**核心实现思想**：`check` 函数用于检查给定的数字 `val` 是否能由字符串 $s$ 变换得到，遍历字符串的每一位，判断数字是否匹配，对于字符 `X` 记录其表示的数字，确保其一致性。

### 扩展思路
同类型题可以是类似的字符串替换和数字判断问题，例如判断字符串替换后能否被其他特定数字整除，或者满足其他特定的数字性质。类似算法套路就是先分析数字的特性，利用特性减少枚举量，再根据字符串的不同情况进行分类讨论。

### 推荐题目
- [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：涉及字符串处理和模拟比赛过程，需要对不同情况进行分类讨论。
- [P1055 ISBN 号码](https://www.luogu.com.cn/problem/P1055)：处理字符串中的数字和字符，根据规则判断 ISBN 号码是否正确。
- [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)：根据输入的多项式系数和指数，按照规则输出多项式，需要处理各种特殊情况。

---
处理用时：84.54秒
# 题目信息

# Portal

## 题目描述

### 题意描述

CQXYM发现了一个大小为$n×m$的、由$n$行$m$列的格子组成的矩阵$A$。此矩阵的每一个方格要么是一个黑曜石块，要么是空的。

CQXYM可以用一次操作将一个黑曜石块挖掉变成空格子，或者是在空格子里放上黑曜石块。

（注意：$（x，y）$意思是纵坐标为$x$、横坐标为$y$的格子）（即$x$行$y$列）

现有一个$a×b$（$a$行$b$列）的矩阵$M$，当且仅当它满足如下条件时，它可以称为一个“下界传送门”：
$a≥5$，$b≥4$。
对于所有$1<x<a$的$x$，格子$（x，1）$与格子$（x，b）$都有黑曜石块。
对于所有$1<x<b$的$x$，格子$（1，x）$与格子$（a，x）$都有黑曜石块。
对于所有的$1<x<a$，$1<y<b$，格子$（x，y）$为空格子。
$（1，1）$、$（1，b）$、$（a，1）$、$（a，b）$四个格子存不存在黑曜石块均可。

请注意：是$a$行、$b$列，不是$a$列、$b$行。
注意四个角的格子可以存在黑曜石块，也可能是空格子。

CQXYM想要知道使得此矩阵的至少一个子矩阵成为一个“下界传送门”所需的最小操作数。
（子矩阵的行数$a≥5$，列数$b≥4$）

## 说明/提示

第一组样例最终形成的“下界传送门”如下：

```cpp
<pre class="verbatim"><br></br>1110<br></br>1001<br></br>1001<br></br>1001<br></br>0111<br></br>
```

### 译者注释

一个最小的“下界传送门”如下,其中四角的格子为0或1均可

0110

1001

1001

1001

0110

## 样例 #1

### 输入

```
1
5 4
1000
0000
0110
0000
0001```

### 输出

```
12```

## 样例 #2

### 输入

```
1
9 9
001010001
101110100
000010011
100000001
101010101
110001111
000001111
111100000
000110000```

### 输出

```
5```

# AI分析结果

### 算法分类
枚举

### 综合分析与结论
这些题解的核心都是在给定的 01 矩阵中寻找满足条件的子矩阵，使得将其修改为“下界传送门”所需的操作数最小。各题解的主要区别在于实现的具体方式和优化策略。

- **思路对比**：
    - pengyule 的题解通过枚举矩形的上下界，用类似双指针的方式移动左右边界来优化。
    - xh39 的题解枚举上下界后，使用动态规划的思想进行状态转移。
    - Illusory_dimes 的题解同样先定上下边界，从左往右计算定好右边界时的最小答案，先撇掉最右边一列简化计算。
    - S00021 的题解通过枚举矩形的左上角和右下角，利用前缀和数组计算代价，并使用剪枝优化。
    - 我梦见一片焦土的题解先处理二维前缀和，枚举上下行，预处理 $F$ 数组，再枚举左界计算答案。

- **算法要点对比**：
    - 大部分题解都使用了前缀和来优化计算矩阵中 0 和 1 的数量。
    - xh39 和 Illusory_dimes 的题解使用了动态规划的思想来减少重复计算。
    - S00021 的题解使用了剪枝策略来减少不必要的计算。

- **解决难点对比**：
    - 主要难点在于如何高效地枚举子矩阵并计算修改代价。不同题解采用了不同的优化方法，如双指针、动态规划、剪枝等。

### 所选题解
- **pengyule（5星）**
    - **关键亮点**：思路清晰，使用双指针优化枚举过程，通过预处理二维前缀和数组来快速计算代价。
- **xh39（4星）**
    - **关键亮点**：使用动态规划的思想进行状态转移，结合前缀和优化计算，代码实现较为详细。
- **S00021（4星）**
    - **关键亮点**：在暴力枚举的基础上使用剪枝策略，有效减少了不必要的计算，实际运行效率较高。

### 重点代码
#### pengyule
核心思路：枚举矩形的上下界，用类似双指针的方式移动左右边界，利用二维前缀和数组计算代价。
参考代码链接：[CF Submission](https://codeforces.com/problemset/submission/1581/130464660)

#### xh39
```cpp
// 状态转移方程
for(k=3;k<m;k++){
  f[i]=min(q0(i,j,k)+q0(i,j,k-1)+q1(i,j,k-2),f[i-1]+q0(i,j,k));
}
// 预处理前缀和
for(i=1;i<=n;i++){
  for(j=1;j<=m;j++){
    s0[i][j]=s0[i-1][j]+a[i][j];
    s1[i][j]=s1[i-1][j]+!a[i][j];
  }
}
```
核心实现思想：先预处理前缀和数组，然后枚举上下界，使用动态规划的思想进行状态转移，最后取所有 $f$ 的最小值得到答案。

#### S00021
```cpp
// 剪枝优化
for(rg int x=1;x<=n;x++)
  for(rg int y=1;y<=m;y++)
    for(rg int a=x+4;a<=n;a++)
      for(int b=y+3;b<=m;b++){
        rg int ret1=sum0(x,y+1,x,b-1)+sum0(x+1,y,a-1,y);
        rg int ret2=sum0(x+1,b,a-1,b)+sum0(a,y+1,a,b-1);
        rg int empt=sum1(x+1,y+1,a-1,b-1);
        if(ans<ret1+empt) break;
        ans=min(ans,ret1+ret2+empt); 
      }
```
核心实现思想：枚举矩形的左上角和右下角，利用前缀和数组计算代价，当答案比左上角控制的矩形的半个外轮廓所产生的代价和要变成空格子的格子产生的代价之和小时，停止循环。

### 最优关键思路或技巧
- 预处理二维前缀和数组，快速计算矩阵中 0 和 1 的数量，减少重复计算。
- 使用双指针、动态规划、剪枝等优化策略，减少不必要的枚举和计算。

### 拓展思路
同类型题或类似算法套路：
- 矩阵中寻找满足特定条件的子矩阵问题，如最大子矩阵和、最小子矩阵和等。
- 可以使用枚举、动态规划、前缀和等算法思想来解决。

### 推荐题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
- [P2717 寒假作业](https://www.luogu.com.cn/problem/P2717)
- [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)

### 个人心得
S00021 的题解提到：“然后你可能会想可不可以将某一维枚举时重新设定一个上限，当然这样是不可以的，出题人会把你定向卡，你将会愉悦地收获 `wrong answer on test 61` 的好成绩。” 总结：在优化枚举时，不能简单地改变枚举上限，否则可能会导致错误，需要寻找合适的剪枝策略。

---
处理用时：77.79秒
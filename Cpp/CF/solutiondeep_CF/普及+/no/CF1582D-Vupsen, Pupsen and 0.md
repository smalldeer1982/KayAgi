# 题目信息

# Vupsen, Pupsen and 0

## 题目描述

给一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$ ，寻找一个长度为 $n$ 序列 $b_1,b_2,\dots,b_n$ ，满足 $\forall i\in\left[1,n\right]b_i\not=0,\ \ \sum\limits_{i=1}^n |b_i|\le10^9,\ \ \sum\limits_{i=1}^n a_i\times b_i=0$ ，可以证明答案一定存在。

## 说明/提示

$1\le t\le100,2\le n\le10^5,2\le\sum n\le2\times10^5,-10^4\le a_i\le10^4,a_i\not=0$ 。

## 样例 #1

### 输入

```
3
2
5 5
5
5 -2 10 -9 4
7
1 2 3 4 5 6 7```

### 输出

```
1 -1
-1 5 1 -1 -1
-10 2 2 -3 5 -1 -1```

# AI分析结果

### 题目翻译
#### Vupsen, Pupsen 和 0

##### 题目描述
给定一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$ ，寻找一个长度为 $n$ 的序列 $b_1,b_2,\dots,b_n$ ，满足 $\forall i\in\left[1,n\right]b_i\not=0$，$\sum\limits_{i=1}^n |b_i|\le10^9$ ，$\sum\limits_{i=1}^n a_i\times b_i=0$ ，可以证明答案一定存在。

##### 说明/提示
$1\le t\le100$，$2\le n\le10^5$，$2\le\sum n\le2\times10^5$，$-10^4\le a_i\le10^4$，$a_i\not=0$ 。

##### 样例 #1
###### 输入
```
3
2
5 5
5
5 -2 10 -9 4
7
1 2 3 4 5 6 7
```
###### 输出
```
1 -1
-1 5 1 -1 -1
-10 2 2 -3 5 -1 -1
```

### 算法分类
构造

### 综合分析与结论
这些题解的核心思路都是先处理 $n$ 为偶数的情况，通过两两配对的方式构造 $b$ 数组，使得每一对的 $a_i\times b_i + a_{i + 1}\times b_{i + 1} = 0$。对于 $n$ 为奇数的情况，不同题解采用了不同的方法处理剩余的三个数，以保证 $\sum\limits_{i=1}^n a_i\times b_i=0$ 且 $\sum\limits_{i=1}^n |b_i|\le10^9$。

- **思路对比**：大部分题解是直接构造三个数的系数来满足条件，如 Alex_Wei 和 Cht_master 的题解；Lynkcat 的题解则根据 $n$ 的大小选择不同的构造方式；S00021 的题解通过解三元一次方程并分类讨论来构造。
- **算法要点**：偶数情况的构造比较统一，即 $b_i = a_{i + 1}$，$b_{i + 1} = -a_i$。奇数情况的构造是难点，不同题解有不同的构造策略，但都围绕着使三个数的乘积和为 0 展开。
- **解决难点**：主要难点在于处理 $n$ 为奇数时剩余三个数的构造，要保证构造的 $b$ 数组元素不为 0 且绝对值总和不超过 $10^9$。不同题解通过不同的判断和构造方法来解决这个问题。

### 所选题解
- **Alex_Wei（5星）**
    - **关键亮点**：思路清晰，代码简洁，对 $n$ 为奇数时的情况进行了详细的分类讨论，并且考虑了限制条件加强后的情况，给出了更强的算法。
    - **个人心得**：提到了限制总和 $\leq n\times 10^4$ 时的处理方法，对不同情况进行了特判和优化。
- **Cht_master（4星）**
    - **关键亮点**：对思路和构造方法进行了详细的解释，代码逻辑清晰，容易理解。
    - **个人心得**：提到了最开始用扩欧做结果一直 WA 的调试经历，说明构造方法的巧妙性。
- **KSToki（4星）**
    - **关键亮点**：代码注释丰富，对 $n$ 为奇数时 $b_n$ 可能为 0 的情况进行了详细的分类讨论。

### 重点代码
#### Alex_Wei 的代码
```cpp
const int N = 1e5 + 5;
int T, n, a[N];

int main() {
    cin >> T;
    while(T--) {
        int bg = 1; cin >> n;
        for(int i = 1; i <= n; i++) cin >> a[i];
        if(n & 1) {
            if(a[2] + a[3]) cout << a[2] + a[3] << " " << -a[1] << " " << -a[1] << " ";
            else if(a[1] + a[2]) cout << -a[3] << " " << -a[3] << " " << a[1] + a[2] << ' ';
            else cout << -a[2] << " " << a[1] + a[3] << " " << -a[2] << " ";
            bg = 4;
        } 
        for(int i = bg; i <= n; i += 2) cout << a[i] << " " << -a[i + 1] << " ";
        cout << endl;
    }
    return 0;
}
```
**核心实现思想**：先判断 $n$ 的奇偶性，若为奇数，处理前三个数，找到满足条件的系数输出；若为偶数，直接从第一个数开始两两配对输出系数。

#### Cht_master 的代码
```cpp
//核心是让两个数互相抵消.
//但若数组长度是奇数,就让某三个数a,b,c互相抵消,解不定方程a*x+b*y=-c*z即可.
//讨论当a(1)+a(2)!=0:则令x=-a(3),y=-a(3),z=a(1)+a(2)即可.
#include<bits/stdc++.h>
using namespace std;
const int mxN(2e5);
int n,a[mxN+5];
int main(){
    int T,s;scanf("%d",&T);
    while(T--){
        s=1,scanf("%d",&n);for(int i(1);i<=n;++i)scanf("%lld",&a[i]);
        if(n&1){
            s=4;
            if(a[1]+a[2]!=0)printf("%d %d %d ",-a[3],-a[3],a[1]+a[2]);
            else if(a[2]+a[3]!=0)printf("%d %d %d ",a[2]+a[3],-a[1],-a[1]);
            else printf("%d %d %d ",-a[2],a[1]+a[3],-a[2]);
        }
        for(int i(s);i<=n;i+=2)printf("%d %d ",-a[i+1],a[i]);
        putchar('\n');
    }
    return 0;
}
```
**核心实现思想**：同样先判断 $n$ 的奇偶性，奇数时处理前三个数，根据不同情况构造系数输出；偶数时直接两两配对输出系数。

#### KSToki 的代码
```cpp
int T,n,a[100001],b[100001];
int main()
{
    T=read();
    while(T--)
    {
        n=read();
        For(i,1,n)
            a[i]=read();
        if(n&1)
        {
            For2(i,1,n-1,2)
            {
                b[i]=a[i+1];
                b[i+1]=-a[i];
            }
            b[n-2]=b[n-1]=a[n];
            b[n]=-(a[n-2]+a[n-1]);
            if(b[n]==0)
            {
                b[n]=b[n-2]=a[n-1];
                b[n-1]=-(a[n]+a[n-2]);
                if(b[n-1]==0)
                {
                    b[n]=b[n-1]=a[n-2];
                    b[n-2]=-(a[n]+a[n-1]);
                }
            }
        }
        else
        {
            For2(i,1,n,2)
            {
                b[i]=a[i+1];
                b[i+1]=-a[i];
            }
        }
        For(i,1,n)
            printf("%d ",b[i]);
        puts("");
    }
    return 0;
}
```
**核心实现思想**：判断 $n$ 的奇偶性，奇数时先两两配对构造前 $n - 3$ 个数的 $b$ 数组，再处理最后三个数，对 $b_n$ 可能为 0 的情况进行分类讨论；偶数时直接两两配对构造 $b$ 数组。

### 最优关键思路或技巧
- 对于 $n$ 为偶数的情况，采用两两配对的方式构造 $b$ 数组，使每一对的和为 0，这是一种简单有效的构造方法。
- 对于 $n$ 为奇数的情况，通过选择三个数，构造它们的系数使得它们的乘积和为 0，并且对可能出现的特殊情况（如和为 0）进行分类讨论。

### 可拓展之处
同类型题可能会改变限制条件，如改变 $b$ 数组元素的取值范围、绝对值总和的限制等，或者改变序列的长度范围等。类似算法套路可以应用在其他构造类题目中，通过分析题目条件，找到满足要求的构造方法，可能需要进行分类讨论和特殊情况的处理。

### 推荐洛谷题目
- P1003 [铺地毯](https://www.luogu.com.cn/problem/P1003)
- P1047 [校门外的树](https://www.luogu.com.cn/problem/P1047)
- P1055 [ISBN 号码](https://www.luogu.com.cn/problem/P1055)

### 个人心得总结
- Cht_master 提到最开始用扩欧做结果一直 WA，说明构造方法的选择很重要，要根据题目特点选择合适的构造方式。
- S00021 提到要注意越界和 $int$ 类型的特性，并且给出了测试数据，提醒在实现代码时要注意数据类型和边界情况的处理。

---
处理用时：101.73秒
# 题目信息

# Korney Korneevich and XOR (easy version)

## 题目描述

给一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$ ，寻找在 $a$ 的所有递增子序列（可以为空）的异或和中出现的数。

## 说明/提示

$1\le n\le10^5,0\le a_i\le500$ 。
### 样例解释
对于第一个样例：
- 子序列 $\{\}$ 的异或和为 $0$ 。
- 子序列 $\{2\}$ 的异或和为 $2$ 。
- 子序列 $\{4\}$ 的异或和为 $4$ 。
- 子序列 $\{2,4\}$ 的异或和为 $6$ 。

其他子序列的异或和与上述其中一个子序列的异或和相等。

## 样例 #1

### 输入

```
4
4 2 2 4```

### 输出

```
4
0 2 4 6```

## 样例 #2

### 输入

```
8
1 0 1 7 12 5 3 2```

### 输出

```
12
0 1 2 3 4 5 6 7 10 11 12 13```

# AI分析结果

### 题目翻译
# Korney Korneevich 和异或（简单版本）

## 题目描述
给定一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，找出 $a$ 的所有递增子序列（可以为空）的异或和中出现的数。

## 说明/提示
$1\le n\le10^5$，$0\le a_i\le500$。
### 样例解释
对于第一个样例：
- 子序列 $\{\}$ 的异或和为 $0$。
- 子序列 $\{2\}$ 的异或和为 $2$。
- 子序列 $\{4\}$ 的异或和为 $4$。
- 子序列 $\{2,4\}$ 的异或和为 $6$。

其他子序列的异或和与上述其中一个子序列的异或和相等。

## 样例 #1
### 输入
```
4
4 2 2 4
```
### 输出
```
4
0 2 4 6
```

## 样例 #2
### 输入
```
8
1 0 1 7 12 5 3 2
```
### 输出
```
12
0 1 2 3 4 5 6 7 10 11 12 13
```

### 算法分类
动态规划

### 综合分析与结论
这些题解的核心思路都是基于动态规划来解决问题，利用上升子序列的性质和异或运算的特点，通过状态转移来找出所有可能的异或和。
- **思路**：由于 $a_i$ 的值域较小，大部分题解都考虑在值域上进行动态规划。通过定义状态来表示异或和以及上升子序列的结尾元素，利用异或运算的性质进行状态转移。
- **算法要点**：定义状态数组，通常记录异或和为某个值时上升子序列结尾元素的最小值；通过枚举序列中的元素和可能的异或和，根据条件进行状态转移；最后统计所有可能的异或和。
- **解决难点**：主要难点在于如何保证子序列是上升的。大部分题解通过记录结尾元素的最小值，在状态转移时判断是否满足上升条件来解决。

### 高评分题解
- **Cht_master（5星）**
    - **关键亮点**：思路清晰，代码简洁高效，通过桶来统计答案，利用偏序性质优化状态转移，时间复杂度较低。
    - **核心代码**：
```cpp
//f(i,S1)|=f(j,S1^a(i))|(i>j&&a(i)>a(j)).
#pragma optimize(2,"Ofast","inline")
#include<bits/stdc++.h>
using namespace std;
const int mxN(1e5),mxD(511);
int n,a[mxN+5],pos[mxD+5],bk[mxD+5],cnt;
int main(){
    memset(pos,0x3f,sizeof(pos));
    scanf("%d",&n);
    for(int i(1);i<=n;++i)scanf("%d",&a[i]);
    for(int i(1);i<=n;++i){
        pos[a[i]]=min(pos[a[i]],a[i]),bk[a[i]]=1;
        for(int S(0);S<=mxD;++S)if(pos[(S^a[i])]<a[i])bk[S]=1,pos[S]=min(pos[S],a[i]);
    }
    bk[0]=1;for(int S(0);S<=mxD;++S)cnt+=(bk[S]!=0);
    printf("%d\n",cnt);
    for(int S(0);S<=mxD;++S)if(bk[S])printf("%d ",S);
    return 0;
}
```
**核心实现思想**：`pos` 数组记录能达到某个异或和的上升子序列的最末元素的最小值，`bk` 数组标记某个异或和是否出现过。通过枚举序列元素和可能的异或和，根据 `pos` 数组判断是否满足上升条件，更新 `bk` 数组。

- **Mason123456（4星）**
    - **关键亮点**：思路清晰，结合基础题的思路，详细解释了状态转移方程，代码注释详细，易于理解。
    - **核心代码**：
```cpp
// 详细注释版
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int a[N], f[N], d[N], n;// a是输入元素，f是dp数组，d是答案桶，记录可以做到的异或和
int main(){
    cin>>n;
    for(int i = 1;i <= n;i++){
        cin>>a[i];
    }
    memset(f, 0x3f, sizeof f);// 其中，为了取min，其他元素初始化为最大
    f[0] = 0, d[0] = 1;
    for(int i = 1;i <= n;i++){
        for(int j = 0;j <= 512;j++){// 关于512的分析，可以参考其他题解。
            if(f[j] < a[i]){// 当f[j]>a[i]时，不存在满足条件的异或，舍去
                f[j xor a[i]] = min(f[j xor a[i]], a[i]);// 这里取异或和最小值自然是min，由于我们初始化的是inf，所以成立
                d[j xor a[i]] = 1;
            }
        }
    }
    int num = 0;
    for(int j = 0;j <= 512;j++){
        if(d[j])    num++;// 单纯的统计数量
    }
    cout<<num<<"\n";
    for(int j = 0;j <= 512;j++){
        if(d[j])
            cout<<j<<" ";
    }
    return 0;
}
```
**核心实现思想**：`f` 数组记录异或和为某个值时末尾元素的最小值，`d` 数组标记某个异或和是否出现过。通过枚举序列元素和可能的异或和，根据 `f` 数组判断是否满足上升条件，更新 `f` 和 `d` 数组。

- **Yh0326（4星）**
    - **关键亮点**：思路清晰，代码简洁，通过定义 `f` 数组记录异或和为某个值时上升子序列末尾数的最小值，进行状态转移。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int s = 0, w = 1;char ch = getchar();
    while(!isdigit(ch)){if(ch == '-'){w = -1;}ch = getchar();}
    while(isdigit(ch)) s = s * 10 + ch - 48, ch = getchar();
    return s * w;
}
int n;
int a[100003];
int f[542];
int main()
{
    n = read();
    for(int i = 1;i <= n;++ i) a[i] = read();
    f[0] = 0;
    for(int i = 1;i <= 512;++ i) f[i] = 513;
    for(int i = 1;i <= n;++ i)
    {
        f[a[i]] = min(f[a[i]], a[i]);
        for(int j = 0;j <= 512;++ j)
        {
            if(f[j] < a[i]) f[a[i] ^ j] = min(f[a[i] ^ j], a[i]);//更新，若可以从异或和为 j 的序列末尾加入 a[i] 并转移
        }
    }
    int ans = 0;
    for(int i = 0;i <= 512;++ i) if(f[i] != 513) ++ ans;
    cout << ans << '\n';
    for(int i = 0;i <= 512;++ i) if(f[i] != 513) cout << i << ' ';
    return 0;
}
```
**核心实现思想**：`f` 数组记录异或和为某个值时上升子序列末尾数的最小值。通过枚举序列元素和可能的异或和，根据 `f` 数组判断是否满足上升条件，更新 `f` 数组。

### 最优关键思路或技巧
- **值域优化**：由于 $a_i$ 的值域较小，直接在值域上进行动态规划，减少不必要的计算。
- **记录结尾元素最小值**：通过记录异或和为某个值时上升子序列结尾元素的最小值，保证子序列的上升性。

### 可拓展之处
同类型题可以是求其他类型子序列（如下降子序列、摆动子序列等）的某种运算结果（如和、积等），类似算法套路都是通过动态规划，定义合适的状态和状态转移方程来解决问题。

### 推荐题目
- [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
- [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)
- [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)

### 个人心得
- **Fireworks_Rise**：当你亲身去感受程序运行的过程后，你会感觉很神奇！（强调了实践对理解程序的重要性）

---
处理用时：95.28秒
# 题目信息

# Laser

## 题目描述

佩娅是科研学员中最负责任的科技工作者。所以她的上司叫她去用她们学院最先进的激光仪去做一个很智障的任务：去融化一块巧克力。



我们的激光仪包含了一个$ n * m $的网格和一个机械臂。机械臂上固定有两束垂直于网格的激光。这两束激光总是射♂向任意两个格子的中心。既然这两束激光被固定在了机械臂上，它们的运动都是有规律的。如果一束激光向一个方向运动，那么令一束激光也会和第一束激光进行一样的运动。



已知有这些条件：



- 一开始，整个网格都被$ n * m $的巧克力完全覆盖，而且两束激光从一开始就在网格的上方，且它们都是打开的。

- 一旦一束激光射向了一小块巧克力，它就会立即融化掉

- 每一次机械臂的矢量运动都和网格的边缘平行，而且每一次运动结束后，激光束都会指向一小块巧克力的中心。

- 无论任何时候，激光束都不能出巧克力的边缘。佩娅才不想成为第二个戈登·弗里曼博士（在半条命游戏系列里被射线射中变异了的游戏角色）呢。

- 一开始，题目会给你n和m，还有一开始被激光指着的巧克力网格（$ x1, y1 $）和（$ x2, y2 $），$ x $是行数，$ y $是列数。列和行号都从1开始计数。你的任务就是找出有多少点不能被激光融化。（激光可以随便运动）

## 样例 #1

### 输入

```
2
4 4 1 1 3 3
4 3 1 1 2 2
```

### 输出

```
8
2
```

# AI分析结果

### 题目内容
# Laser

## 题目描述
佩娅是科研学员中最负责任的科技工作者。所以她的上司叫她去用她们学院最先进的激光仪去做一个很智障的任务：去融化一块巧克力。

我们的激光仪包含了一个$n * m$的网格和一个机械臂。机械臂上固定有两束垂直于网格的激光。这两束激光总是射向任意两个格子的中心。既然这两束激光被固定在了机械臂上，它们的运动都是有规律的。如果一束激光向一个方向运动，那么另一束激光也会和第一束激光进行一样的运动。

已知有这些条件：
- 一开始，整个网格都被$n * m$的巧克力完全覆盖，而且两束激光从一开始就在网格的上方，且它们都是打开的。
- 一旦一束激光射向了一小块巧克力，它就会立即融化掉。
- 每一次机械臂的矢量运动都和网格的边缘平行，而且每一次运动结束后，激光束都会指向一小块巧克力的中心。
- 无论任何时候，激光束都不能出巧克力的边缘。佩娅才不想成为第二个戈登·弗里曼博士（在半条命游戏系列里被射线射中变异了的游戏角色）呢。
- 一开始，题目会给你$n$和$m$，还有一开始被激光指着的巧克力网格（$x1, y1$）和（$x2, y2$），$x$是行数，$y$是列数。列和行号都从1开始计数。你的任务就是找出有多少点不能被激光融化。（激光可以随便运动）

## 样例 #1
### 输入
```
2
4 4 1 1 3 3
4 3 1 1 2 2
```
### 输出
```
8
2
```
• **算法分类**：数学
• **综合分析与结论**：这几道题解思路相近，均先将两点位置调整为“左下右上”形式，计算出两点可移动形成的类似矩形区域的长和宽，进而算出未被融化巧克力点数的基础值（总面积减去两倍形成区域面积）。难点在于考虑两个点移动路径重叠部分，需通过容斥原理来处理。各题解在代码实现上略有差异，如变量命名、交换点坐标方式等，但核心思路一致。
• **所选的题解**
  - **作者：Mistybranch (赞：3)  星级：4星  关键亮点**：思路阐述详细，结合样例和图示说明，清晰展示计算过程，代码实现完整且逻辑清晰。
```cpp
#include <bits/stdc++.h>

int n, m, x_1, y_1, x_2, y_2;
long long a, b, res;

void swap (int &a, int &b) {
    int t;

    t = a;
    a = b;
    b = t;
}

int main () {
    int T;

    scanf("%d", &T);

    while (T--) {
        scanf("%d %d %d %d %d %d", &n, &m, &x_1, &y_1, &x_2, &y_2);

        if (x_1 > x_2) {
            swap(x_1, x_2);
        }

        if (y_1 > y_2) {
            swap(y_1, y_2);
        }

        a = x_1 + n - x_2;
        b = y_1 + m - y_2;
        res = (long long)n * m - 2 * a * b;

        if (a * 2 > n && b * 2 > m) {
            res += (a * 2 - n) * (b* 2 - m);
        }

        printf("%lld\n", res);
    }

    return 0;
} 
```
  - **作者：ttq012 (赞：1)  星级：4星  关键亮点**：先给出数学推导，明确计算思路，代码简洁明了，利用位运算交换坐标值。
```cpp
// Think twice, code once.

#include <bits/stdc++.h>
#define int long long

using namespace std;

signed main() {
    int T;
    cin >> T;
    while (T --) {
        int n, m;
        cin >> n >> m;
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        if (x1 > x2) x1 ^= x2 ^= x1 ^= x2;
        if (y1 > y2) y1 ^= y2 ^= y1 ^= y2;
        int _1 = x1 + n - x2, _2 = y1 + m - y2;
        if (_1 * 2 > n && _2 * 2 > m)
            cout << n * m - 2 * _1 * _2 + (_1 * 2 - n) * (_2 * 2 - m);
        else
            cout << n * m - 2 * _1 * _2 << '\n';
    }
    return 0;
}
```
  - **作者：XL4453 (赞：0)  星级：4星  关键亮点**：直接关注机械臂位移向量，通过简洁的计算得出结果，代码实现紧凑。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
int T,x1,y1,x2,y2,x,y,n,m,ans;
signed main(){
    scanf("%I64d",&T);
    while(T--){
        scanf("%I64d%I64d%I64d%I64d%I64d%I64d",&n,&m,&x1,&y1,&x2,&y2);
        x=n-abs(x1-x2);y=m-abs(y1-y2);
        ans=2*x*y;
        if(2*x>n&&2*y>m)ans-=(2*x-n)*(2*y-m);
        printf("%I64d\n",n*m-ans);
    }
    return 0;
}
```
• **最优关键思路或技巧**：将激光点位置转化为规则形式（左下右上），利用容斥原理处理重叠部分，通过简单的数学运算得出结果，避免复杂模拟。
• **可拓展之处**：这类题目属于几何与数学结合的问题，类似套路可用于处理多个几何图形相交、覆盖面积计算等问题。例如在二维平面中多个矩形重叠区域面积计算等。
• **洛谷相似题目**：
  - P1007 [NOIP1998 普及组] 独木桥：涉及简单数学分析与模拟。
  - P1147 连续自然数和：通过数学推导解决问题。
  - P1990 覆盖墙壁：利用递推和数学思想解题。 

---
处理用时：62.23秒
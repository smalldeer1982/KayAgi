# 题目信息

# Crazy Robot

## 题目描述

有一个网格，由  $n$ 行和 $m$ 列组成。网格的每个单元格要么是空的，要么是被阻塞的。其中有一个空单元内有一个实验室。超出网格边界的所有单元格也被阻塞。

一个疯狂的机器人从一个实验室逃了出来。它目前在网格的一些空单元中。您可以向机器人发送以下命令之一：“向右移动”、“向下移动”、“向左移动”或“向上移动”。每个命令意味着移动到相应方向的相邻单元格。

然而，由于机器人很疯狂，除了听从命令，它什么都会做。收到命令后，它将选择一个方向，使其与命令中的方向不同，并且该方向上的单元没有被阻塞。如果有这样的方向上的单元没有被堵塞，那么它就会移动到那个方向上的相邻单元格。否则，它什么都不做。

我们想让机器人到达实验室从而可以修理它。对于每个空单元，确定机器人是否可以从该单元开始到达实验室。也就是说，在机器人的每一步之后，都可以向机器人发送一个命令，这样无论机器人选择什么不同的方向，它最终都会进入实验室。

## 说明/提示

‎在第一个测试样例中，没有可以使机器人到达实验室的自由单元。考虑一个角单元格。给定任何方向，它将移动到相邻的边界网格，而不是一个角落。现在考虑一个非角自由单元。无论你向机器人发送什么方向，它都可以选择不同的方向，这样它就会落在角落里。‎

‎在最后一个测试样例中，您可以继续向机器人发送与实验室方向相反的命令，机器人将别无选择，只能向实验室移动。‎

## 样例 #1

### 输入

```
4
3 3
...
.L.
...
4 5
#....
..##L
...#.
.....
1 1
L
1 9
....L..#.```

### 输出

```
...
.L.
...
#++++
..##L
...#+
...++
L
++++L++#.```

# AI分析结果

【题目内容】
# 疯狂的机器人

## 题目描述

有一个由 $n$ 行和 $m$ 列组成的网格。网格中的每个单元格要么是空的，要么是被阻塞的。其中有一个空单元里有一个实验室。超出网格边界的所有单元格也被视为阻塞。

一个疯狂的机器人从实验室逃了出来，目前位于网格的某个空单元中。你可以向机器人发送以下命令之一：“向右移动”、“向下移动”、“向左移动”或“向上移动”。每个命令都意味着移动到相应方向的相邻单元格。

然而，由于机器人很疯狂，它除了听从命令，什么都会做。收到命令后，它会选择一个与命令方向不同且该方向上的单元没有被阻塞的方向。如果存在这样未被阻塞的方向，它就会移动到那个方向上的相邻单元格；否则，它就什么都不做。

我们希望让机器人到达实验室以便对其进行修理。对于每个空单元，需要确定机器人是否可以从该单元开始到达实验室。也就是说，在机器人的每一步之后，都可以向机器人发送一个命令，使得无论机器人选择什么不同的方向，它最终都会进入实验室。

## 说明/提示

在第一个测试样例中，没有可以让机器人到达实验室的自由单元。考虑一个角单元格，给定任何方向，它都会移动到相邻的边界网格，而不是角落。现在考虑一个非角自由单元，无论你向机器人发送什么方向，它都可以选择不同的方向，从而落在角落里。

在最后一个测试样例中，你可以持续向机器人发送与实验室方向相反的命令，机器人将别无选择，只能向实验室移动。

## 样例 #1

### 输入
```
4
3 3
...
.L.
...
4 5
#....
..##L
...#.
.....
1 1
L
1 9
....L..#.
```

### 输出
```
...
.L.
...
#++++
..##L
...#+
...++
L
++++L++#.
```

【算法分类】
广度优先搜索 BFS

【综合分析与结论】
这些题解的核心思路都是从实验室位置开始进行广度优先搜索（BFS），判断每个空单元是否能让机器人到达实验室。判断的关键在于一个空单元周围的空单元数量，如果周围空单元数量小于等于 1，那么就可以让机器人走向实验室。

各题解的主要区别在于代码实现细节，如边界处理、数据存储方式等，但整体思路和算法要点一致。

【所选的题解】
- 作者：cancan123456 (赞：7)，4星。
  - 关键亮点：思路清晰，对边界处理采用在网格边上围一圈 `#` 的方式，方便判断边界情况。还提醒了使用 `endl` 输出换行会超时的注意事项。
  - 个人心得：赛时写了个 dfs 惨烈牺牲，关键是样例还过了。
- 作者：让风忽悠你 (赞：2)，4星。
  - 关键亮点：将从哪些位置出发可以到达目标点的问题转换为从目标点出发能到达哪些点，简化了问题。
- 作者：zhangboju (赞：1)，4星。
  - 关键亮点：引入 $deg_{i,j}$ 来记录一个点周围不在已确定答案集合中的空单元数量，通过维护这个值来判断点是否能作为答案，思路巧妙。

【重点代码】
1. **cancan123456 的代码**
```cpp
int inline CBC(int x, int y) { // 输出 (x, y) 周围的 . 的个数 
    int cnt = 0;
    for (int i = 0; i < 4; i++) {
        if (map[x + dx[i]][y + dy[i]] == '.') {
            cnt++;
        }
    }
    return cnt;
}
void bfs(int x, int y) {
    queue < pair < int , int > > q;
    q.push(make_pair(x, y));
    vis[x][y] = true; // 为了防止起点也被改成 + 
    while (!q.empty()) {
        pair < int , int > u = q.front();
        q.pop();
        int x = u.first;
        int y = u.second;
        for (int nx, ny, i = 0; i < 4; i++) {
            nx = x + dx[i];
            ny = y + dy[i];
            //  判重            能否走过去            周围的 . 个数 < 2 
            if (!vis[nx][ny] && map[nx][ny] != '#' && CBC(nx, ny) < 2) {
                vis[nx][ny] = true;
                map[nx][ny] = '+';
                q.push(make_pair(nx, ny));
            }
        }
    }
}
```
核心实现思想：通过 `CBC` 函数计算一个点周围的空单元数量，在 `bfs` 函数中，从实验室位置开始搜索，若某个相邻点未被访问、不是障碍物且周围空单元数量小于 2，则将其标记为 `+` 并加入队列。

2. **让风忽悠你 的代码**
```cpp
int can_go(int x, int y){
    int cnt=0;
    for(int i=0;i<4;i++){
        int fx=x+ax[i],fy=y+ay[i];
        if(fx<0 || fx>n-1 || fy<0 || fy>m-1) continue;
        if(map[fx][fy]=='.') ++cnt;
    }
    return cnt;
    // 统计有多少个方向可以走 
}
void bfs(int sx,int sy){
    queue <node> q;
    q.push((node){sx,sy});
    while(!q.empty()){
        node f=q.front();
        q.pop();
        for(int i=0;i<4;i++){
            int x=f.x+ax[i],y=f.y+ay[i];
            if(x<0 || x>n-1 || y<0 || y>m-1) continue;
            if(map[x][y]!='.') continue;
            if(can_go(x,y)>=2) continue;
            // 注意判断的顺序 
            map[x][y]='+'; // 可以走就标记上 
            q.push((node){x,y});
        }
    }
}
```
核心实现思想：`can_go` 函数统计一个点周围的空单元数量，在 `bfs` 函数中，从实验室位置开始搜索，若某个相邻点未越界、是空单元且周围空单元数量小于 2，则将其标记为 `+` 并加入队列。

3. **zhangboju 的代码**
```cpp
int id(int x,int y){return x*m+y;} 
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
string s[N];
int deg[N];
queue<pair<int,int>>q;
// ...
while(!q.empty())
{
    auto p=q.front();q.pop();
    int x=p.first,y=p.second;
    for(int d=0;d<4;++d)
    {
        int nx=x+dx[d],ny=y+dy[d];
        if(0<=nx&&nx<n&&0<=ny&&ny<m&&s[nx][ny]=='.')
        {
            --deg[id(nx,ny)];
            if(deg[id(nx,ny)]<=1)
            {
                s[nx][ny]='+';
                q.push({nx,ny});
            }
        }
    }
}
```
核心实现思想：使用 `id` 函数将二维坐标转换为一维索引，`deg` 数组记录每个点周围不在已确定答案集合中的空单元数量。在 BFS 过程中，每次访问一个点时，更新其相邻点的 `deg` 值，若相邻点的 `deg` 值小于等于 1，则将其标记为 `+` 并加入队列。

【最优关键思路或技巧】
- 转换思维，将从每个点出发判断能否到达实验室的问题，转换为从实验室出发判断能到达哪些点，简化了问题。
- 在 BFS 过程中，通过判断一个点周围的空单元数量来确定该点是否能让机器人到达实验室。
- 对边界的处理可以采用在网格边上围一圈障碍物的方式，方便判断越界情况。

【可拓展之处】
同类型题或类似算法套路：
- 其他网格地图上的搜索问题，如寻找最短路径、判断可达性等。
- 可以改变机器人的移动规则，如机器人有一定概率听从命令，或者有不同的移动方向限制，再进行类似的可达性判断。

【推荐洛谷题目】
1. P1135 奇怪的电梯：在一个电梯系统中，每个电梯有不同的上下层数限制，求从一个楼层到另一个楼层的最短路径，与本题的网格搜索有相似之处。
2. P1605 迷宫：在一个迷宫中寻找从起点到终点的路径，需要判断是否越界和是否可以通过，和本题的边界处理和可达性判断类似。
3. P1036 选数：从若干个数中选取一些数，判断它们的和是否为质数，虽然和本题的搜索场景不同，但都涉及到枚举和判断的过程。

---
处理用时：69.35秒
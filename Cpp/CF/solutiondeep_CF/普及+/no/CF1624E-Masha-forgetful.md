# 题目信息

# Masha-forgetful

## 题目描述

Masha 认识了一个新朋友并且获得了他的电话号码 $s$。她想要尽快地记住它。电话号码是一个长度为 $m$，由 $0\sim 9$ 构成的字符串。电话号码有可能以 $0$ 开始。

Masha 已经知道了 $n$ 个电话号码（所有的电话号码长度都为 $m$）。如果新的电话号码 $s$ 能拆分成几段并且存在于她已经知道的电话号码中，她能够更容易得记住新号码。每一个段的长度都必须大于等于 $2$，否则 Masha 会因为有太多的段而混淆。

举个例子，Masha 需要记住的号码 $s$ 是 $\texttt{12345678}$，并且她知道 $n=4$ 个号码：$\texttt{12340219}$，$\texttt{20215601}$，$\texttt{56782022}$，$\texttt{12300678}$。你可以用在 $s$ 中拆分成 $3$ 段：$\texttt{1234}$ 在第一个号码中，$\texttt{56}$ 在第二个号码中，$\texttt{78}$ 在第三个号码中。当然还有其它分解 $s$ 的方法。

Masha 想要你来帮她，她想让你把电话号码 $s$ 拆分成几个长度大于等于 $2$ 的字符串，并且在她知道的电话号码中存在。如果有多个答案，请输出其中的任意一个。

## 样例 #1

### 输入

```
5

4 8
12340219
20215601
56782022
12300678
12345678

2 3
134
126
123

1 4
1210
1221

4 3
251
064
859
957
054

4 7
7968636
9486033
4614224
5454197
9482268```

### 输出

```
3
1 4 1
5 6 2
3 4 3
-1
2
1 2 1
2 3 1
-1
3
1 3 2
5 6 3
3 4 1```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
这些题解的核心思路都是利用动态规划解决问题，先将已知字符串分解成长度为 2 或 3 的子串并记录，再对目标字符串进行动态规划判断是否能由这些子串拼接而成，若可行则找出一种拼接方案。
- **思路对比**：大部分题解思路一致，部分题解采用搜索的方式来寻找方案，如 Bh_hurter 的题解使用深度优先搜索 DFS。
- **算法要点**：关键在于将问题转化为只考虑长度为 2 和 3 的子串，利用哈希表或数组记录这些子串信息，通过动态规划数组判断能否拼接及记录转移路径。
- **解决难点**：主要难点在于如何高效地记录子串信息以及正确进行动态规划的状态转移和路径记录，同时要注意多组数据的清空操作。

### 所选题解
- XL4453（5 星）：思路清晰，代码简洁，对哈希函数的使用和动态规划的实现都很巧妙，注释较少但代码逻辑易于理解。
- DaiRuiChen007（4 星）：使用 pbds 哈希表提高效率，对状态转移方程的解释详细，代码结构清晰。
- huyiyang（4 星）：使用 map 记录子串信息，动态规划和路径查找的实现较为常规，代码可读性高。

### 重点代码
#### XL4453 的核心代码
```cpp
// 哈希函数
int hash(int num1, int num2, int num3){
    if(num1==0)num1=10;if(num2==0)num2=10;if(num3==0)num3=10;
    if(num1==-1)num1=0;
    return num1*121+num2*11+num3;
}
// 动态规划过程
f[0]=1;
for(int i=2;i<=m;i++){
    if(f[i-2]){
        int num=hash(-1,b[i-1],b[i]);
        if(t[num].id!=0){
            f[i]=f[i-2]+1;fr[i]=i-2;ans[i]=num;
        }
    }
    if(i==2)continue;
    if(f[i-3]){
        int num=hash(b[i-2],b[i-1],b[i]);
        if(t[num].id!=0){
            f[i]=f[i-3]+1;fr[i]=i-3;ans[i]=num;
        }
    }
}
```
核心实现思想：通过哈希函数将长度为 2 或 3 的子串映射到数组中，利用动态规划数组 `f` 记录能否拼接及所需次数，`fr` 记录转移路径，`ans` 记录子串的哈希值。

#### DaiRuiChen007 的核心代码
```cpp
// 状态转移
for(register int i=1;i<=m;++i) {
    if(i>=3&&mp.find(s.substr(i-3,3))!=mp.end()&&f[i-3]) f[i]=3;
    if(i>=2&&mp.find(s.substr(i-2,2))!=mp.end()&&f[i-2]) f[i]=2;
}
// 记录答案
int pos=m;
while(pos) {
    string tmp=s.substr(pos-f[pos],f[pos]);
    ans.push_back(mp[tmp]);
    pos-=f[pos];
}
```
核心实现思想：使用 pbds 哈希表 `mp` 记录子串信息，动态规划数组 `f` 记录切割长度，通过 `f` 数组回溯找出拼接方案。

#### huyiyang 的核心代码
```cpp
// 记录子串信息
for(int i=1;i<=n;i++){
    cin>>a[i];
    if(m>1){
        for(int j=0;j+2<a[i].length();j++){
            b[a[i].substr(j,2)]=1;
            l[a[i].substr(j,2)]=j;
            id[a[i].substr(j,2)]=i;
            b[a[i].substr(j,3)]=1;
            l[a[i].substr(j,3)]=j;
            id[a[i].substr(j,3)]=i;
        }
        b[a[i].substr(a[i].length()-2,2)]=1;
        l[a[i].substr(a[i].length()-2,2)]=a[i].length()-2;
        id[a[i].substr(a[i].length()-2,2)]=i;
    }
}
// 动态规划
dp[0]=1;
for(int i=2;i<=m;i++){
    if(b.count(s.substr(i-2,2)))dp[i]|=dp[i-2];
    if(i>2&&b.count(s.substr(i-3,3)))dp[i]|=dp[i-3];
}
```
核心实现思想：使用 `map` 记录子串信息，动态规划数组 `dp` 判断能否拼接，通过 `dp` 数组回溯找出拼接方案。

### 最优关键思路或技巧
- **子串分解**：将所有长度大于 1 的字符串分解为长度为 2 和 3 的子串，减少了需要处理的子串数量，降低了时间复杂度。
- **哈希表或数组记录**：使用哈希表或数组记录长度为 2 和 3 的子串信息，方便快速查找和判断子串是否存在。
- **动态规划**：通过动态规划数组记录状态转移，判断目标字符串是否能由已知子串拼接而成，并记录转移路径。

### 可拓展之处
同类型题如字符串的拼接、匹配问题，类似算法套路可应用于其他需要分解字符串并判断能否拼接的问题，如判断一个长字符串能否由若干给定的短字符串拼接而成。

### 推荐题目
- [P1043 数字游戏](https://www.luogu.com.cn/problem/P1043)
- [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)

### 个人心得
AFewSuns 提到一开始用暴力的想法，把文本串中的每个子串塞进 trie 里，然后把模式串中的每个子串都尝试匹配，时间复杂度较高，还出现了 RE 错误。后来发现可以选取长度为 2 和 3 的字符串，用数组替代 trie，从而优化了时间复杂度。这提示我们在解题时要注意时间复杂度的分析，当暴力方法不可行时，尝试寻找更优的解法。 

---
处理用时：45.81秒
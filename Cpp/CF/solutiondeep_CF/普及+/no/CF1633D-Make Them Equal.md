# 题目信息

# Make Them Equal

## 题目描述

#### 【题目大意】

你有一个长度为 $n$，初始全为 $1$ 的数组 $a$，和两个长度为 $n$ 的数组 $b,c$。

你可以**最多**进行 $k$ 次如下的操作：选择两个**正整数** $i,x$，使 $a_{i}$ 变成 $ \left ( a_{i}+\left \lfloor \dfrac{a_{i}}{x} \right \rfloor \right )$。

最后，如果 $a_{i}=b_{i}$，你将会获得 $c_{i}$ 的收益。

最大化总收益。

## 说明/提示

- $1 \leq t \leq 100,1 \leq n \leq 1000, 1 \leq k \leq 1 \times 10^{6}$；
- $1 \leq b_{i} \leq 1000,1 \leq c_{i} \leq 1 \times 10^{6}$；
- $n$ 的总和不大于 $1000$。

Translated by HPXXZYY.

## 样例 #1

### 输入

```
4
4 4
1 7 5 2
2 6 5 2
3 0
3 5 2
5 4 7
5 9
5 2 5 6 3
5 9 1 9 7
6 14
11 4 6 2 8 16
43 45 9 41 15 38```

### 输出

```
9
0
30
167```

# AI分析结果

### 题目翻译
#### 让它们相等

#### 题目描述
【题目大意】
你有一个长度为 $n$，初始全为 $1$ 的数组 $a$，和两个长度为 $n$ 的数组 $b,c$。
你可以**最多**进行 $k$ 次如下的操作：选择两个**正整数** $i,x$，使 $a_{i}$ 变成 $ \left ( a_{i}+\left \lfloor \dfrac{a_{i}}{x} \right \rfloor \right )$。
最后，如果 $a_{i}=b_{i}$，你将会获得 $c_{i}$ 的收益。
最大化总收益。

#### 说明/提示
- $1 \leq t \leq 100,1 \leq n \leq 1000, 1 \leq k \leq 1 \times 10^{6}$；
- $1 \leq b_{i} \leq 1000,1 \leq c_{i} \leq 1 \times 10^{6}$；
- $n$ 的总和不大于 $1000$。

#### 样例 #1
##### 输入
```
4
4 4
1 7 5 2
2 6 5 2
3 0
3 5 2
5 4 7
5 9
5 2 5 6 3
5 9 1 9 7
6 14
11 4 6 2 8 16
43 45 9 41 15 38
```
##### 输出
```
9
0
30
167
```

### 算法分类
动态规划

### 综合分析与结论
这些题解的核心思路都是先预处理出从 $1$ 到每个数的最小操作次数，将原问题转化为 01 背包问题，再通过 01 背包求解最大收益。

#### 思路对比
- **预处理方法**：多数题解使用两层循环枚举 $i$ 和 $j$，根据状态转移方程 $f_{i+\lfloor\frac{i}{j}\rfloor}=\min\{f_{i+\lfloor\frac{i}{j}\rfloor},f_i + 1\}$ 进行预处理；部分题解使用 BFS 或数论分块优化预处理过程。
- **背包优化**：大家都发现了从 $1$ 到 $1000$ 的最大操作次数不超过 $12$，所以将背包容量 $k$ 与 $12n$ 取最小值，避免了超时。

#### 难点解决
原问题的时间复杂度为 $O(nk)$，数据范围较大可能超时。通过发现最大操作次数的上限，将 $k$ 优化为 $\min(k, 12n)$，将时间复杂度降低到 $O(n\times\min(12n, k))$，解决了超时问题。

### 所选题解
- **CSP_Sept（5星）**
    - **关键亮点**：思路清晰，先明确预处理最小操作数，再转化为背包问题，同时给出了时间复杂度的分析和优化方法，代码简洁易懂。
    - **个人心得**：无
- **include_BM（4星）**
    - **关键亮点**：代码简洁，逻辑清晰，直接指出每个 $a_i$ 操作独立，将问题转化为背包问题，并进行了有效的优化。
    - **个人心得**：无
- **BigJoker（4星）**
    - **关键亮点**：对问题分析透彻，先点明是 01 背包问题，再详细说明求花费的方法和优化思路，代码规范。
    - **个人心得**：无

### 重点代码
#### CSP_Sept 的核心代码
```cpp
// 预处理 f(i)
#define M 1000

void init(){
    for(int i = 1 ; i <= M ; i++)
        f[i] = INF;
    f[1] = 0;
    for(int i = 1 ; i <= M ; i++)
        for(int j = 1 ; j <= i ; j++)
            f[i + i / j] = min(f[i + i / j], f[i] + 1),
            mx = max(mx, f[i + i / j]);
}

// 直接 dp
memset(dp, 0, sizeof(dp));
for(int i = 1 ; i <= n ; i++)
    for(int j = k ; j >= f[b[i]] ; j--)
        dp[j] = max(dp[j - f[b[i]]] + c[i], dp[j]);
printf("%lld\n", dp[k]);
```
**核心实现思想**：先预处理出从 $1$ 到每个数的最小操作次数 $f$，再使用 01 背包求解最大收益。

#### include_BM 的核心代码
```cpp
const int N=1e3+10;
ll n,k,b[N],c[N],s[N],f[N*12];
signed main(){
    for(int i=2;i<N;++i) s[i]=2e9;
    for(int i=1;i<N;++i)
        for(int j=1;j<=i;++j) s[i+i/j]=min(s[i+i/j],s[i]+1);
    for(int T=read();T;--T){
        n=read(),k=read();
        for(int i=1;i<=n;++i) b[i]=read();
        for(int i=1;i<=n;++i) c[i]=read();
        for(int i=0;i<=n*12;++i) f[i]=0;
        for(int i=1;i<=n;++i)
            for(int j=n*12;j>=s[b[i]];--j) f[j]=max(f[j],f[j-s[b[i]]]+c[i]);
        printf("%lld\n",f[min(k,n*12)]);
    }
    return 0;
}
```
**核心实现思想**：同样先预处理最小操作次数，再进行 01 背包，将 $k$ 与 $12n$ 取最小值避免超时。

#### BigJoker 的核心代码
```cpp
#include<bits/stdc++.h>
#define mem(a,x) memset(a,x,sizeof(a))
#define inf 0x3f3f3f3f
using namespace std;
int t,n,k;
int b[1005],c[1005];
int dp1[1005],dp[100005];
void init(){
    mem(dp1,inf);
    dp1[1]=0;
    for(int i=1;i<=1000;i++){
        for(int j=1;j<=1000;j++){
            int u=i*1.0/j;
            if(u+i<=1000) dp1[u+i]=min(dp1[u+i],dp1[i]+1);
        }
    }
}
int main(){
    init();
    scanf("%d",&t);
    while(t--){
        scanf("%d %d",&n,&k);
        k=min(k,12*n);
        mem(dp,0);
        for(int i=1;i<=n;i++) scanf("%d",&b[i]),b[i]=dp1[b[i]];
        for(int i=1;i<=n;i++) scanf("%d",&c[i]);
        for(int i=1;i<=n;i++){
            for(int j=k;j>=b[i];j--) dp[j]=max(dp[j],dp[j-b[i]]+c[i]); 
        }
        printf("%d\n",dp[k]);
    }
    return 0; 
} 
```
**核心实现思想**：先预处理最小操作次数，再进行 01 背包，优化背包容量。

### 关键思路或技巧
- **预处理最小操作次数**：通过两层循环枚举 $i$ 和 $j$，利用状态转移方程 $f_{i+\lfloor\frac{i}{j}\rfloor}=\min\{f_{i+\lfloor\frac{i}{j}\rfloor},f_i + 1\}$ 预处理出从 $1$ 到每个数的最小操作次数。
- **背包优化**：发现从 $1$ 到 $1000$ 的最大操作次数不超过 $12$，将背包容量 $k$ 与 $12n$ 取最小值，降低时间复杂度。

### 拓展思路
同类型题目通常会涉及动态规划和背包问题的结合，可能会改变操作规则、数据范围或收益计算方式。解题的关键在于将问题转化为背包问题，并通过预处理和优化降低时间复杂度。

### 洛谷相似题目
- P1048 [NOIP2005 普及组] 采药：经典的 01 背包问题，与本题的背包部分思路相似。
- P1853 投资的最大效益：同样是背包问题，需要根据不同的投资方案计算最大收益。
- P2340 [USACO03FALL]Cow Exhibition G：涉及 01 背包的变形，需要考虑两个属性的平衡。

### 个人心得摘录与总结
- **听取MLE声一片**：赛时被卡到最后 5 分钟才过，发现 $b_i$ 范围小可以预处理，01 背包会超时，通过输出预处理表发现最大值不超过 20 进行优化。
- **Arctic_1010**：场上一眼看出做法，但因不会算操作数导致悲剧，可见计算操作数在本题中的重要性。

---
处理用时：66.55秒
# 题目信息

# Conveyor

## 题目描述

工厂中有一条长为 $2l$ 的传送带，前 $l$ 米面向上方，后 $l$ 米面向下方。传送带以 $v_1$ m/s的速度进行匀速运动，Anton以 $v_2$ m/s的速度在传送带上进行与其方向相同的匀速直线运动。传送带上有 $n$ 块巧克力（巧克力不会掉落且随传送带运动），Anton会捡起他经过的所有巧克力（该过程不消耗时间，包含起点而不包含终点的巧克力）。Anton有相等的概率选择任意位置作为起点。请你对于 $0\le i\le n$ ，求出Anton捡得 $i$ 块巧克力的概率。

## 样例 #1

### 输入

```
1 1 1 1
0
```

### 输出

```
0.75000000000000000000
0.25000000000000000000
```

## 样例 #2

### 输入

```
2 3 1 2
2 5
```

### 输出

```
0.33333333333333331000
0.66666666666666663000
0.00000000000000000000
```

# AI分析结果

### 题目内容
# 传送带

## 题目描述
工厂中有一条长为 $2l$ 的传送带，前 $l$ 米面向上方，后 $l$ 米面向下方。传送带以 $v_1$ m/s的速度进行匀速运动，Anton以 $v_2$ m/s的速度在传送带上进行与其方向相同的匀速直线运动。传送带上有 $n$ 块巧克力（巧克力不会掉落且随传送带运动），Anton会捡起他经过的所有巧克力（该过程不消耗时间，包含起点而不包含终点的巧克力）。Anton有相等的概率选择任意位置作为起点。请你对于 $0\le i\le n$ ，求出Anton捡得 $i$ 块巧克力的概率。

## 样例 #1
### 输入
```
1 1 1 1
0
```
### 输出
```
0.75000000000000000000
0.25000000000000000000
```

## 样例 #2
### 输入
```
2 3 1 2
2 5
```
### 输出
```
0.33333333333333331000
0.66666666666666663000
0.00000000000000000000
```
### 算法分类
概率论

### 综合分析与结论
该题解主要思路是先确定Anton捡起巧克力的条件，通过计算Anton到达终点时间及巧克力在此时间移动距离，得出可捡起巧克力的下标范围。由于下标数据范围大，从巧克力入手，得出以巧克力下标求可捡起它的起点下标范围，将范围端点放入优先队列处理，同时考虑环形情况。整体思路清晰，通过优先队列巧妙解决问题，代码实现简洁明了。

### 所选的题解
 - **星级**：4星
 - **关键亮点**：巧妙利用优先队列处理区间端点，清晰地分析出Anton捡起巧克力的条件及环形处理方式。
 - **重点代码核心实现思想**：通过优先队列存储每个巧克力对应可捡起起点下标范围的端点，遍历队列，根据端点类型（起点或终点）更新当前可捡起巧克力个数及上一个端点坐标，累计对应个数巧克力的起点下标长度，最后计算概率。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10; 
const double eps=1e-7;
struct node 
{
    double d; bool op;//d:下标,op:起/终点(0/1)
    bool operator<(const node& x) const {return d-x.d>eps;}
};
int a[N]; double ans[N];
priority_queue<node> q;
signed main()
{
    int n,l,v1,v2;
    scanf("%lld%lld%lld%lld",&n,&l,&v1,&v2);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    double lim=l-l*v1*1.0/(v2+v1);
    for(int i=1;i<=n;i++) 
    {
        q.push((node){max(0.0,a[i]-lim),0}),q.push((node){a[i],1});
        if(a[i]-lim<0) q.push((node){l*2+a[i]-lim,0}),q.push((node){2*l,1});//处理环形
    }
    int lst=0; double pos=0; 
    while(!q.empty())
    {
        node x=q.top(); q.pop();
        ans[lst]+=x.d-pos;
        lst+=x.op?-1:1,pos=x.d;
    }    
    ans[lst]+=2*l-pos;//处理结尾剩余下标
    for(int i=0;i<=n;i++) printf("%.9lf\n",ans[i]*1.0/(2*l));
    return 0;
}
```
### 最优关键思路或技巧
利用优先队列按序处理每个巧克力对应可捡起起点下标范围的端点，简化了复杂区间的处理过程，同时通过数学计算准确得出可捡起巧克力的条件范围，是解决本题的关键技巧。

### 可拓展之处
此类题目属于概率论与实际场景结合的问题，类似套路可用于解决如在运动的载体上随机选取起点获取物品的概率问题，关键在于分析清楚物体运动关系及对应条件范围。

### 洛谷相似题目推荐
 - [P1288 取数游戏II](https://www.luogu.com.cn/problem/P1288)
 - [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)
 - [P2141 珠心算测验](https://www.luogu.com.cn/problem/P2141) 

---
处理用时：48.89秒
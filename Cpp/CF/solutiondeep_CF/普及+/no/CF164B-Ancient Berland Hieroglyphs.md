# 题目信息

# Ancient Berland Hieroglyphs

## 题目描述

Polycarpus 对 Berland 象形文字充满了兴趣。某天，他得到两幅古老的 Berland 图片，上面各自画着一个象形文字圆圈。已知在任一圆圈中，象形文字不会重复出现（但可以在两个圆圈中各出现一次）。

为了在电脑上保存这些图片，Polycarpus 必须将每个圆圈打断，并顺时针将其中的所有象形文字按顺序写成一行。由第一个圆圈得到的行称为 $a$，由第二个圆圈得到的行称为 $b$。

由于有多种打断圆圈的方法，Polycarpus 希望选择一种能够使得 $a$ 的最长子串作为 $b$ 的子序列的长度最大。

请帮 Polycarpus 找出，在最优打断方式下，所需子串（子序列）的最大可能长度。

字符串 $s$ 的长度为字符数目，记作 $|s|$。字符串可以表示为 $s = s_1 s_2 \ldots s_{|s|}$。

一个子串 $x$ 可以表示为 $x = s[a \ldots b] = s_a s_{a+1} \ldots s_b$（$1 \le a \le b \le |s|$）。例如，“code”和“force”是“codeforces”的子串，而“coders”不是。

子序列是指 $y = s[p_1 p_2 \ldots p_{|y|}] = s_{p1} s_{p2} \ldots s_{p|y|}$（$1 \le p_1 < p_2 < \ldots < p_{|y|} \le |s|$）。例如，“coders”是“codeforces”的子序列。

## 说明/提示

在第一个测试用例中，Polycarpus 选择了一个由象形文字 5 和 1 组成的字符串；在第二个测试用例中，他选择了一个由象形文字 1、3 和 5 组成的字符串。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 3 5 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 6
1 3 5 2
1 2 3 4 5 6
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3 3
1 2 3
3 2 1
```

### 输出

```
2
```

# AI分析结果

### 题目内容
# 古代伯兰象形文字

## 题目描述
Polycarpus 对伯兰象形文字充满了兴趣。某天，他得到两幅古老的伯兰图片，上面各自画着一个象形文字圆圈。已知在任一圆圈中，象形文字不会重复出现（但可以在两个圆圈中各出现一次）。

为了在电脑上保存这些图片，Polycarpus 必须将每个圆圈打断，并顺时针将其中的所有象形文字按顺序写成一行。由第一个圆圈得到的行称为 $a$，由第二个圆圈得到的行称为 $b$。

由于有多种打断圆圈的方法，Polycarpus 希望选择一种能够使得 $a$ 的最长子串作为 $b$ 的子序列的长度最大。

请帮 Polycarpus 找出，在最优打断方式下，所需子串（子序列）的最大可能长度。

字符串 $s$ 的长度为字符数目，记作 $|s|$。字符串可以表示为 $s = s_1 s_2 \ldots s_{|s|}$。

一个子串 $x$ 可以表示为 $x = s[a \ldots b] = s_a s_{a + 1} \ldots s_b$（$1 \leq a \leq b \leq |s|$）。例如，“code”和“force”是“codeforces”的子串，而“coders”不是。

子序列是指 $y = s[p_1 p_2 \ldots p_{|y|}] = s_{p1} s_{p2} \ldots s_{p|y|}$（$1 \leq p_1 < p_2 < \ldots < p_{|y|} \leq |s|$）。例如，“coders”是“codeforces”的子序列。

## 说明/提示
在第一个测试用例中，Polycarpus 选择了一个由象形文字 5 和 1 组成的字符串；在第二个测试用例中，他选择了一个由象形文字 1、3 和 5 组成的字符串。

 **本翻译由 AI 自动生成**

## 样例 #1
### 输入
```
5 4
1 2 3 4 5
1 3 5 6
```
### 输出
```
2
```

## 样例 #2
### 输入
```
4 6
1 3 5 2
1 2 3 4 5 6
```
### 输出
```
3
```

## 样例 #3
### 输入
```
3 3
1 2 3
3 2 1
```
### 输出
```
2
```
• 算法分类：字符串
• 综合分析与结论：由于暂无题解，通用建议是可以考虑通过枚举第一个圆圈的所有打断方式得到不同的子串，对于每个子串在第二个圆圈形成的序列中寻找最长子序列。扩展思路方面，可以尝试优化枚举的方式，比如利用一些数据结构来快速判断子串在第二个序列中的存在情况，减少时间复杂度。
• 无4星及以上题解，不列出具体题解。
• 无重点代码。
• 无关键实现代码片段。
• 洛谷相似题目推荐：
  - P3375 【模板】KMP字符串匹配，考察字符串匹配相关知识。
  - P1308 统计单词数，涉及字符串查找与计数。
  - P1502 窗口的星星，同样围绕字符串处理相关算法。 

---
处理用时：32.42秒
# 题目信息

# Promising String (easy version)

## 题目描述

简单版与困难版的区别只有数据范围不同。

我们将一个非空字符串称作平衡字符串当且仅当它有相同数量的加号和减号。举例：字符串“+--+”和“++-+--”是平衡的，字符串“+--”，“--”和“”是不平衡的。

我们将一个字符串称作有希望的字符串当且仅当这个字符串可以通过几次（可能为0次）以下的操作来变成平衡的字符串。

操作：
- 将两个相邻的减号换成一个加号

特别的，一个平衡的字符串是一个有希望的字符串，但不是所有有希望的字符串都是平衡的字符串。

举个例子，字符串“-+---”是有希望的，因为你可以将两个相邻的减号换成加号后得到一个平衡的字符串“-++-”，或者“-+-+”。

给定一个字符串 $s$ ， $s$ 的多少个非空子串是有希望的？每个有希望的非空子串在答案中的计数次数必须与在字符串$s$中出现的次数相同。

子串是字符串中一段连续的字符，举例，对于字符串“+-+”来说，它的子串有“+-”，“-+”，“+”，“+-+”（它本身也是它的子串）等一些其他子串，但“--”，“++”，“-++”不是它的子串。

## 样例 #1

### 输入

```
5
3
+-+
5
-+---
4
----
7
--+---+
6
+++---```

### 输出

```
2
4
2
7
4```

# AI分析结果

### 题目中文重写
# 有希望的字符串（简单版）

## 题目描述

简单版与困难版的区别只有数据范围不同。

我们将一个非空字符串称作平衡字符串当且仅当它有相同数量的加号和减号。举例：字符串“+--+”和“++-+--”是平衡的，字符串“+--”，“--”和“”是不平衡的。

我们将一个字符串称作有希望的字符串当且仅当这个字符串可以通过几次（可能为0次）以下的操作来变成平衡的字符串。

操作：
- 将两个相邻的减号换成一个加号

特别的，一个平衡的字符串是一个有希望的字符串，但不是所有有希望的字符串都是平衡的字符串。

举个例子，字符串“-+---”是有希望的，因为你可以将两个相邻的减号换成加号后得到一个平衡的字符串“-++-”，或者“-+-+”。

给定一个字符串 $s$ ， $s$ 的多少个非空子串是有希望的？每个有希望的非空子串在答案中的计数次数必须与在字符串$s$中出现的次数相同。

子串是字符串中一段连续的字符，举例，对于字符串“+-+”来说，它的子串有“+-”，“-+”，“+”，“+-+”（它本身也是它的子串）等一些其他子串，但“--”，“++”，“-++”不是它的子串。

## 样例 #1

### 输入
```
5
3
+-+
5
-+---
4
----
7
--+---+
6
+++---
```

### 输出
```
2
4
2
7
4
```

### 算法分类
枚举

### 综合分析与结论
这些题解的核心思路都是通过枚举字符串的所有子串，然后判断子串是否为有希望的字符串。关键在于如何判断子串是否有希望，由于每次操作是将两个相邻减号换成一个加号，这会使减号与加号的数量差减少3，所以判断条件为：减号数量不少于加号数量，且两者数量差是3的倍数。

各题解的区别在于实现细节和优化程度。部分题解直接枚举子串并统计加减号数量判断；部分题解使用前缀和优化统计过程，减少时间复杂度。

### 所选的题解
- XL4453（4星）
  - 关键亮点：思路清晰，详细解释了操作对加减号数量差的影响，代码实现简洁明了。
- heyx0201（4星）
  - 关键亮点：明确指出时间和空间复杂度，使用前缀和优化，代码结构清晰。
- Y_QWQ_Y（4星）
  - 关键亮点：思路简洁，直接说明判断条件，代码实现简单易懂。

### 重点代码
#### XL4453
```cpp
#include<cstdio>
using namespace std;
int T,n,a[3005],x,y,p,l,ans;
char c;
char get(){
    char c=getchar();
    while(c=='\n'||c==' '||c=='\r')c=getchar();
    return c;
}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            c=get();
            if(c=='+')a[i]=1;
            else a[i]=0;
        }
        ans=0;
        for(int i=1;i<=n;i++){
            x=0;y=0;p=0;l=i-1;
            for(int j=i;j<=n;j++){
                if(a[j]==1)x++;
                else y++;
                if(a[j]==0&&a[j-1]==0&&j-l>=2)p++;
                if((y-x>=0)&&(y-x)%3==0&&(y-x)/3<=p)ans++;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
核心实现思想：先将字符串中的字符转换为0和1存储，然后枚举所有子串，统计子串中加号和减号的数量，以及可操作的次数，根据判断条件判断子串是否有希望。

#### heyx0201
```cpp
#include<iostream>
using namespace std;
const int MAXN = 3e3 + 10;
int t, n, sum[MAXN];
string s;
void Solve(){
    cin >> n >> s;
    sum[0] = s[0] == '-' ? 1 : -1;
    for (int i = 1; i < n; i++){
        sum[i] = sum[i - 1] + (s[i] == '-' ? 1 : -1);
    }
    long long ans = 0;
    for (int i = 0; i < n; i++){
        for (int j = i; j < n; j++){
            ans += (sum[j] - sum[i - 1] >= 0 && (sum[j] - sum[i - 1]) % 3 == 0);
        }
    }
    cout << ans << '\n';
}
int main(){
    cin >> t;
    while (t--){
        Solve();
    }
    return 0;
}
```
核心实现思想：使用前缀和数组 `sum` 记录到每个位置时减号与加号的数量差，枚举所有子串，通过前缀和计算子串中减号与加号的数量差，根据判断条件判断子串是否有希望。

#### Y_QWQ_Y
```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n, s[3005], ans;
string c;
signed main ()
{
    ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
    cin >> t;
    while (t --)
    {
        ans = 0;
        cin >> n >> c;
        for (int i = 0; i < n; ++ i)s[i + 1] = s[i] + (c[i] == '-' ? 1 : -1);
        for (int i = 1; i <= n; ++ i)for (int j = i; j <= n; ++ j)
        {
            int sum = s[j] - s[i - 1];
            ans += (sum >= 0 && sum % 3 == 0);
        }
        cout << ans << '\n';
    }
    return 0;
}
```
核心实现思想：同样使用前缀和数组 `s` 记录到每个位置时减号与加号的数量差，枚举所有子串，通过前缀和计算子串中减号与加号的数量差，根据判断条件判断子串是否有希望。

### 最优关键思路或技巧
- **前缀和优化**：通过前缀和数组记录到每个位置时减号与加号的数量差，在枚举子串时可以 $O(1)$ 计算子串中减号与加号的数量差，减少时间复杂度。
- **数学分析**：分析操作对加减号数量差的影响，得出判断子串是否有希望的条件，即减号数量不少于加号数量，且两者数量差是3的倍数。

### 可拓展之处
同类型题或类似算法套路：
- 字符串相关的子串计数问题，可使用枚举子串的方法，结合特定的判断条件进行求解。
- 涉及操作和状态变化的问题，可通过数学分析找出操作对状态的影响，从而得出判断条件。

### 推荐洛谷题目
- P1165 日志分析：涉及字符串处理和简单的计数问题。
- P1059 明明的随机数：与字符串处理无关，但涉及枚举和判断，可锻炼枚举的思维。
- P1047 校门外的树：与字符串处理无关，但涉及区间处理和计数，可锻炼区间枚举和判断的能力。

### 个人心得
本题解中未包含个人心得内容。

---
处理用时：47.51秒
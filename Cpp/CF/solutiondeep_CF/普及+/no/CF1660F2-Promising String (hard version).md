# 题目信息

# Promising String (hard version)

## 题目描述

如果一个非空字符串包含了相同个数的加号与减号，我们把它称之为一个平衡字符串。
比如`+--+`,`++-+--`都是平衡的，而字符串`+--`,`--`,` `都不是平衡的。

如果一个字符串可以通过几个（可以是$0$个）操作而变得平衡，我们称它是有希望的。具体操作为：
把两个相邻的减号替换为一个加号

显然所有的平衡字符串都是有希望的，不过不是所有有希望的字符串都是平衡的。比如字符串`-+---`是一个有希望的字符串。因为
你可以把两个相邻的减号替换为一个加号从而达到一个平衡字符串`-++-`或`-+-+`

对于一个给定的字符串$s$,你要求出有它多少个非空子串是有希望的。如果一个子串在$s$中出现了多次，我们也要计算多次

## 样例 #1

### 输入

```
5
3
+-+
5
-+---
4
----
7
--+---+
6
+++---```

### 输出

```
2
4
2
7
4```

# AI分析结果

### 题目内容（已翻译）
# 有希望的字符串（困难版本）

## 题目描述

如果一个非空字符串包含相同数量的加号和减号，我们称它为平衡字符串。
例如，`+--+`、`++-+--` 都是平衡的，而字符串 `+--`、`--`、` ` 都不是平衡的。

如果一个字符串可以通过若干次（可以是 0 次）操作变得平衡，我们称它是有希望的。具体操作是：
将两个相邻的减号替换为一个加号。

显然，所有的平衡字符串都是有希望的，但不是所有有希望的字符串都是平衡的。例如，字符串 ` - + ---` 是一个有希望的字符串，因为你可以将两个相邻的减号替换为一个加号，从而得到平衡字符串 ` - ++ -` 或 ` - + - +`。

对于给定的字符串 $s$，你需要求出它有多少个非空子串是有希望的。如果一个子串在 $s$ 中出现多次，我们也要计算多次。

## 样例 #1

### 输入
```
5
3
+-+
5
-+---
4
----
7
--+---+
6
+++---
```

### 输出
```
2
4
2
7
4
```

### 算法分类
树状数组

### 综合分析与结论
这些题解的核心思路都是先找出判断子串是否有希望的条件，然后利用前缀和与同余的性质来简化问题，最后通过树状数组或分治等方法统计满足条件的子串数量。

各题解的思路和要点如下：
- **I_am_Accepted**：将 `'+'` 看作 1，`'-'` 看作 -1 求前缀和，得出子串有希望的三个条件，证明其中一个条件可由另外两个推出，最终转化为同余分组后求逆序对数的问题，使用树状数组或分治解决。
- **KemononeRou**：令减号为 0，加号为 1，预处理前缀 0/1 数量和前缀不交的 00 数量，得出区间合法的三个条件，转化为三维偏序问题。
- **XL4453**：分析变换次数限制，得出问题可转化为求前缀和中比当前位置小且模 3 同余的数量，使用树状数组统计。
- **Cocoly1990**：猜测并证明区间有希望的充要条件，利用前缀和将问题转化为二维偏序，用值域树状数组或归并排序解决。
- **VitrelosTia**：设 `-` 的前缀和减去 `+` 的前缀和为 $x_i$，得出子串有希望的充要条件，使用三个树状数组在值域上求前缀和统计答案。

### 所选题解
- **I_am_Accepted（5星）**
  - 关键亮点：思路清晰，对条件的分析和证明严谨，给出了详细的推理过程，并且提供了代码链接。
- **Cocoly1990（4星）**
  - 关键亮点：结论猜测和证明简洁明了，直接指出问题可转化为二维偏序，给出了具体的解决方法。
- **VitrelosTia（4星）**
  - 关键亮点：代码实现简洁，对条件的分析和证明也较为清晰。

### 重点代码
#### I_am_Accepted（树状数组代码思路）
核心思想：将 `'+'` 看作 1，`'-'` 看作 -1 求前缀和，同余分组后用树状数组统计逆序对数量。

#### Cocoly1990（树状数组代码思路）
核心思想：把 `-` 标记为 -1，`+` 标记为 1 求前缀和，利用值域树状数组维护同余，统计满足条件的左右端点。

#### VitrelosTia
```cpp
const int N = 2e5 + 4; // 这是 3 的倍数
int n, x[N]; string s;
struct BITree {
    int c[N << 1], m; int qwq(int x) { return x & (-x); }
    void update(int x, int k) { for (; x <= m; x += qwq(x)) c[x] += k; }
    int query(int x) { int a = 0; for (; x; x -= qwq(x)) a += c[x]; return a; }
} t[3];
void solve() {
    cin >> n >> s; s = " " + s;
    for (int o = 0; o < 3; o++) t[o].m = n + N;
    for (int i = 1, sa = 0, sb = 0; i <= n; i++) {
        sa += s[i] == '+', sb += s[i] == '-';
        x[i] = sb - sa;
    } int ans = 0;
    for (int i = 0; i <= n; i++) {
        ans += t[(x[i] + N) % 3].query(x[i] + N);
        t[(x[i] + N) % 3].update(x[i] + N, 1);
    } 
    for (int i = 0; i <= n; i++) t[(x[i] + N) % 3].update(x[i] + N, -1);
    cout << ans << '\n';
}
```
核心思想：设 `-` 的前缀和减去 `+` 的前缀和为 $x_i$，使用三个树状数组分别对三种余数在值域上求前缀和，统计满足条件的子串数量。

### 关键思路或技巧
- 利用前缀和将子串的计算转化为两个端点的计算，简化问题。
- 通过同余分组，将问题转化为逆序对或偏序问题，使用树状数组高效统计。

### 拓展思路
同类型题目可能会改变操作规则或判断条件，但核心思路依然是找出判断条件，利用前缀和、同余等性质简化问题，再使用数据结构进行统计。类似的算法套路还有在字符串、数组等问题中使用前缀和、树状数组解决区间统计问题。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得
各题解中未包含个人心得内容。

---
处理用时：43.25秒
# 题目信息

# Water the Trees

## 题目描述

有一个长 $n$ 的数列 $h_1,h_2,\ldots,h_n$，对于每次操作，你有两种方法：
- 选择一个数，如果这是第奇数次操作，给它加 $1$，否则，给它加 $2$。
- 什么也不做（但也算一次操作）。

注：每次操作最多只能选一个数。

求至少要经过多少次操作，使得数列中所有数均相等。

## 说明/提示

$1 \le t \le 2 \cdot 10^4$；

$1 \le n \le 3 \cdot 10^5$；

$1 \le h_i \le 10^9$；

此外，保证 $t$ 组数据输入的所有 $n$ 之和不大于 $3\cdot 10^5$。

## 样例 #1

### 输入

```
3
3
1 2 4
5
4 4 3 5 5
7
2 5 4 8 3 7 4```

### 输出

```
4
3
16```

# AI分析结果

【题目内容】
# 给树浇水

## 题目描述

有一个长度为 $n$ 的数列 $h_1,h_2,\ldots,h_n$，对于每次操作，你有两种方法：
- 选择一个数，如果这是第奇数次操作，给它加 $1$，否则，给它加 $2$。
- 什么也不做（但也算一次操作）。

注：每次操作最多只能选一个数。

求至少要经过多少次操作，使得数列中所有数均相等。

## 说明/提示

$1 \le t \le 2 \cdot 10^4$；

$1 \le n \le 3 \cdot 10^5$；

$1 \le h_i \le 10^9$；

此外，保证 $t$ 组数据输入的所有 $n$ 之和不大于 $3\cdot 10^5$。

## 样例 #1

### 输入

```
3
3
1 2 4
5
4 4 3 5 5
7
2 5 4 8 3 7 4
```

### 输出

```
4
3
16
```

【算法分类】
本题的算法分类主要涉及贪心和二分，综合考虑，最相关的标签为**贪心**，因为大部分题解核心是基于贪心策略来求解最少操作次数。

【综合分析与结论】
这些题解主要围绕贪心和二分两种思路来解决问题。贪心思路是先确定目标高度（最大高度或最大高度加 1），统计加 1 和加 2 的次数，然后通过调整使两者次数尽量接近以减少操作次数；二分思路是利用答案的单调性，二分操作次数，判断在该次数内能否使所有数相等。

各题解的主要区别在于实现细节和处理方式，如不同的贪心策略和二分的具体实现。但核心都是确定目标高度和合理分配加 1 和加 2 的操作。

【所选的题解】
- **作者：Exber (赞：4)，4星**
    - **关键亮点**：思路清晰，采用二分答案的方法，对答案的单调性分析准确，代码实现规范，注释详细。
- **作者：glorious_dream (赞：3)，4星**
    - **关键亮点**：贪心思路明确，对加 1 和加 2 的次数处理合理，通过 3 个 +2 为一组的贪心策略优化操作次数，代码简洁易懂。
- **作者：MiniLong (赞：2)，4星**
    - **关键亮点**：思路全面，分类讨论清晰，对不同情况下的操作次数计算准确，代码实现符合逻辑。

【重点代码】
- **Exber 的二分代码**
```cpp
inline bool check(long long days,int val)
{
    long long cnt1=(days+1)/2,cnt2=days/2;
    for(int i=1;i<=n;i++)
    {
        long long ned=min((long long)(val-a[i])/2,cnt2);
        cnt2-=ned;
        cnt1-=val-a[i]-ned*2;
    }
    return cnt2>=0&&cnt1>=0;
}

inline void slove()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    sort(a+1,a+n+1);
    long long l=0,r=1e17,ans=0;
    while(l<=r)
    {
        long long mid=l+r>>1;
        if(check(mid,a[n])||check(mid,a[n]+1))
        {
            ans=mid;
            r=mid-1;
        }
        else
        {
            l=mid+1;
        }
    }
    printf("%lld\n",ans);
}
```
**核心实现思想**：二分操作次数，通过 `check` 函数判断在该次数内能否使所有数达到目标高度 `val`，如果可以则缩小右边界，否则扩大左边界。

- **glorious_dream 的贪心代码**
```cpp
inline int work(int maxn){
    int cnt1=0,cnt2=0;
    for(re int i(1) ; i<=n ; ++i){
        cnt1 += (maxn-a[i])%2;
        cnt2 += (maxn-a[i])/2; //贪心求解
    }
    int tmp = cnt2 - cnt1;
    if(tmp >= 2) cnt1+=(tmp+1)/3*2,cnt2-=(tmp+1)/3;
    if(cnt1 > cnt2) return cnt1*2-1;
    else return cnt2*2;
}
```
**核心实现思想**：统计达到目标高度 `maxn` 所需的加 1 和加 2 的次数，若加 2 的次数比加 1 的次数多 2 及以上，进行调整，最后根据两者大小关系计算操作次数。

- **MiniLong 的贪心代码**
```cpp
int f(int maxn){
    int cnt1 = 0, cnt2 = 0;
    for(int i = 1; i <= n; ++i){
        g[i] = maxn - a[i];
        if(g[i] % 2) cnt1++;
        cnt2 += g[i] / 2; 
    }
    if(cnt1 == cnt2) return cnt1 * 2;
    else if(cnt1 < cnt2){
        int t = (cnt2 - cnt1) * 2, k = t - t / 3 * 3;
        int ans = cnt1 * 2 + t / 3 * 2;
        if(k == 2) ans += 2;
        if(k == 1) ans++;
        return ans;
    }
    else return cnt1 * 2 - 1;
}
```
**核心实现思想**：统计达到目标高度 `maxn` 所需的加 1 和加 2 的次数，分类讨论两者关系，计算最少操作次数。

【最优关键思路或技巧】
- **目标高度的确定**：只考虑最大高度和最大高度加 1 这两种情况，因为更高的高度会造成操作浪费。
- **贪心策略**：优先使用加 2 的操作，当加 2 的次数比加 1 的次数多较多时，通过 3 个加 2 换 2 个加 1 和 2 个加 2 的方式优化操作次数。
- **二分答案**：利用答案的单调性，二分操作次数，通过判断函数确定是否可行。

【可拓展之处】
同类型题可能会改变操作规则，如每次操作可以选择多个数，或者操作的增量不同等。类似算法套路可以应用在需要合理分配资源以达到最优结果的问题中，如任务分配、资源调度等。

【推荐题目】
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：考察贪心策略，通过合理安排顺序使总等待时间最短。
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：需要巧妙的贪心排序和计算，以达到最优结果。
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及贪心和高精度计算，通过合理排序使结果最优。

【个人心得】
- **Exber**：赛时被家长强制睡眠没做出来，体现了比赛时可能会受到外界因素影响。 

---
处理用时：51.52秒
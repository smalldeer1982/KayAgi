# 题目信息

# Preorder

## 题目描述

给你一颗 $2^n-1$ 个节点的完美二叉树，按照以下顺序编号：  
 - 根节点编号为 $1$;
 - 编号为 $x$ 的节点左儿子为 $2x$，右儿子为 $2x+1$。
 
 每个顶点上有一个字母 `A` 或 `B`，在节点 $x$ 上的字母为 $s_x$。  
 顶点 $x$ 的先序串 $f(x)$ 定义如下：  
 - 如果 $x$ 是叶子，那么 $x$ 的先序串是 $s_x$；  
 - 否则 $x$ 的先序串是 $s_x+f(l_x)+f(r_x)$，其中 $+$ 表示连接两个字符串，$l_x,r_x$ 代表 $x$ 的左右儿子。
 
一棵树的先序串是根节点的先序串。  
允许执行交换任意一个非叶子节点的左右儿子任意次，求树可能的所有不同先序串的个数，
答案模 $998244353$ 。

## 样例 #1

### 输入

```
4
BAAAAAAAABBABAB```

### 输出

```
16```

## 样例 #2

### 输入

```
2
BAA```

### 输出

```
1```

## 样例 #3

### 输入

```
2
ABA```

### 输出

```
2```

## 样例 #4

### 输入

```
2
AAB```

### 输出

```
2```

## 样例 #5

### 输入

```
2
AAA```

### 输出

```
1```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
这些题解的核心思路都是利用动态规划来解决问题。定义状态表示以某个节点为根的子树的不同先序串个数，通过递归的方式从叶子节点向上递推计算。关键在于判断左右子树是否同构，若同构则左右子树交换不会产生新的先序串，否则会产生新的先序串。各题解主要区别在于代码实现细节和判断同构的具体方式，但整体思路一致。

### 所选题解
- **作者：zsq147258369（4星）**
  - **关键亮点**：思路清晰，代码简洁，通过记录子树的字典序最小的前序遍历字符串来判断同构。
- **作者：naroto2022（4星）**
  - **关键亮点**：详细阐述了树形 dp 的思路，代码规范，使用了快速读入和输出优化。
- **作者：fishing_cat（4星）**
  - **关键亮点**：思路简洁明了，代码实现直接，对状态转移的解释清晰。

### 重点代码
#### 作者：zsq147258369
```cpp
void dfs(int x)
{
    if(ls>m){s[x]=a[x]+'0';f[x]=1;return;}
    dep[ls]=dep[rs]=dep[x]+1;
    dfs(ls),dfs(rs);
    if(s[ls]==s[rs])f[x]=f[ls]*f[rs]%mod;
    else f[x]=f[ls]*f[rs]%mod*2%mod;
    s[x]=a[x]+'0';
    if(s[ls]<s[rs])s[x]+=s[ls]+s[rs];
    else s[x]+=s[rs]+s[ls];
}
```
**核心实现思想**：递归计算每个节点的子树的不同先序串个数，若左右子树的字典序最小的前序遍历字符串相同，则左右子树交换不产生新的先序串，否则乘以 2。

#### 作者：naroto2022
```cpp
void dfs(ll u){
    if(u>=(1<<(n-1))){
        dp[u]=1;str[u]=s[u];
        return;
    }
    dfs(ls);dfs(rs);
    if(str[ls]==str[rs]) dp[u]=dp[ls]*dp[rs]%mod;
    else dp[u]=2*dp[ls]*dp[rs]%mod;
    str[u]=s[u];
    if(str[ls]<str[rs]) str[u]+=str[ls]+str[rs];
    else str[u]+=str[rs]+str[ls];
}
```
**核心实现思想**：同样是递归计算，根据左右子树的字典序最小的前序遍历字符串是否相同来更新状态。

#### 作者：fishing_cat
```cpp
void dfs(ll u) {
    if (u*2 > len) return ; // 叶子节点跳出
    ll ls = u*2, rs = u*2 + 1;
    dfs(ls);
    dfs(rs);
    if (vel[ls] != vel[rs]) dp[u] = 2*dp[ls]*dp[rs] % mod; // 情况一转移
    else dp[u] = dp[ls]*dp[rs] % mod; // 情况二转移
    if (vel[ls] < vel[rs]) vel[u] += vel[ls] + vel[rs];
    else vel[u] += vel[rs] + vel[ls]; // 合并字典序最小的前序遍历
}
```
**核心实现思想**：递归计算每个节点的状态，根据左右子树的字典序最小的前序遍历字符串是否相同进行状态转移。

### 最优关键思路或技巧
- **状态定义**：定义状态表示以某个节点为根的子树的不同先序串个数，利用动态规划的思想从叶子节点向上递推计算。
- **同构判断**：通过记录子树的字典序最小的前序遍历字符串来判断左右子树是否同构，若相同则左右子树交换不产生新的先序串。

### 拓展思路
同类型题或类似算法套路：
- 其他树形动态规划问题，如树的最大独立集、树的重心等。
- 涉及树的遍历和状态转移的问题，如树的路径问题、树的染色问题等。

### 推荐题目
- [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：经典的树形 dp 问题，与本题类似，需要根据节点之间的关系进行状态转移。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形 dp 问题，需要处理选课的依赖关系，通过状态转移计算最大得分。
- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：树形 dp 问题，需要在树上进行状态转移，计算保留一定数量树枝时的最大苹果数。

### 个人心得
- **作者：yuruilin2026**：做完题还不知道为什么过，感谢神犇 Hootime 提供思路得到启发。总结：在遇到不会的题目时，可以向他人请教获取思路。 

---
处理用时：34.65秒
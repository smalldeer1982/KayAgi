# 题目信息

# Tokitsukaze and Meeting

## 题目描述

#### 【题目翻译】

Tokitsukaze 正在安排一场学生会议。会议厅的座位是一个 $n$ 行 $m$ 列的矩形。

一共有 $(n \times m)$ 个学生参加会议，这些学生被从 $1$ 到 $(n \times m)$ 编号。这 $(n \times m)$ 个学生中有一些学生比较调皮，有些学生比较严肃。

学生将以编号从小到大的顺序进场。每个学生进场后将会坐在第 $1$ 行第 $1$ 列，而原本的学生将会后退一格，即：

- 原本在第 $i$ 行第 $j$ 列的学生（$1 \leq j \leq m-1$），将会坐到第 $i$ 行第 $(j+1)$ 列；
- 原本在第 $i$ 行第 $m$ 列的学生将会坐到第 $(i+1)$ 行第 $1$ 列。

（具体的过程请看原题面里的图片）

如果某一行或某一列有至少一位严肃的学生，那么这一行或这一列就会认为是好的行货好的列。

对于所有的 $1 \leq i \leq (n \cdot m)$，求当第 $i$ 位学生（即编号为 $i$ 的学生）进场后，好的行及好的列的数量的和。

## 说明/提示

- $1 \leq T \leq 1 \times 10^{4}$
- $1 \leq n,m \leq 1 \times 10^{6},1 \leq (n \cdot m) \leq 1 \times 10^{6}$
- $1 \leq \sum (n \cdot m) \leq 1\times 10^{6}$

Translated by @HPXXZYY

## 样例 #1

### 输入

```
3
2 2
1100
4 2
11001101
2 4
11001101```

### 输出

```
2 3 4 3
2 3 4 3 5 4 6 5
2 3 3 3 4 4 4 5```

# AI分析结果

【题目内容】
Tokitsukaze 正在安排一场学生会议。会议厅的座位是一个 $n$ 行 $m$ 列的矩形。

一共有 $(n \times m)$ 个学生参加会议，这些学生被从 $1$ 到 $(n \times m)$ 编号。这 $(n \times m)$ 个学生中有一些学生比较调皮，有些学生比较严肃。

学生将以编号从小到大的顺序进场。每个学生进场后将会坐在第 $1$ 行第 $1$ 列，而原本的学生将会后退一格，即：

- 原本在第 $i$ 行第 $j$ 列的学生（$1 \leq j \leq m - 1$），将会坐到第 $i$ 行第 $(j + 1)$ 列；
- 原本在第 $i$ 行第 $m$ 列的学生将会坐到第 $(i + 1)$ 行第 $1$ 列。

如果某一行或某一列有至少一位严肃的学生，那么这一行或这一列就会认为是好的行或好的列。

对于所有的 $1 \leq i \leq (n \cdot m)$，求当第 $i$ 位学生（即编号为 $i$ 的学生）进场后，好的行及好的列的数量的和。

### 说明/提示
- $1 \leq T \leq 1 \times 10^{4}$
- $1 \leq n,m \leq 1 \times 10^{6},1 \leq (n \cdot m) \leq 1 \times 10^{6}$
- $1 \leq \sum (n \cdot m) \leq 1\times 10^{6}$

### 样例 #1
#### 输入
```
3
2 2
1100
4 2
11001101
2 4
11001101
```
#### 输出
```
2 3 4 3
2 3 4 3 5 4 6 5
2 3 3 3 4 4 4 5
```

【算法分类】
模拟

【综合分析与结论】
这三道题解都采用了将行和列的贡献分开统计再求和的思路，以避免直接暴力计算的高复杂度。
- **思路对比**：
    - 郑朝曦zzx的题解通过记录列中严肃学生的出现情况和上一个严肃学生的编号来推算行和列的答案。
    - intel_core的题解对于列，找到每列最小的严肃学生编号更新答案；对于行，先暴力计算 $i \leq m$ 的情况，再递推 $i > m$ 的情况。
    - NKL丶的题解用桶记录列中 1 的出现情况，对于行采用类似队列区间移动的方式扫描。
- **算法要点对比**：
    - 郑朝曦zzx用数组 `row` 和 `col` 记录行和列的信息，利用余数和上一个严肃学生编号计算。
    - intel_core用前缀和数组 `sum` 辅助计算行的贡献，通过循环更新列的贡献。
    - NKL丶用桶记录列信息，模拟队列区间移动计算行信息。
- **解决难点对比**：
    - 都解决了如何高效计算不同时刻好的行和列的数量和的问题，避免了每次重新计算。郑朝曦zzx通过记录上一个严肃学生编号简化行的计算；intel_core用前缀和优化行的计算；NKL丶用队列区间移动的方式处理行的更新。

【题解评分】
- 郑朝曦zzx：4星。思路清晰，代码简洁，考虑了输入输出优化，避免 TLE。
- intel_core：3星。思路较清晰，但代码中部分变量命名不够直观。
- NKL丶：3星。思路合理，但只给出代码链接，没有具体代码展示。

【所选题解】
- 郑朝曦zzx（4星）：关键亮点在于思路清晰，将行和列分开考虑，利用余数和上一个严肃学生编号高效计算答案，同时考虑了输入输出优化。

【重点代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
void fastInp()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}
int row[1000010], col[1000010];
int main()
{
    fastInp();
    int t; cin >> t;
    while (t--)
    {
        int n, m, colcnt = 0, lst = - 1e9;
        cin >> n >> m;
        for (int i = 0; i < n * m; ++i)
        {
            char c; cin >> c;
            if (c == '1')
            {
                lst = i;
                if (col[i % m] == 0)
                {
                    col[i % m] = 1;
                    ++colcnt;	
                }
            }
            if (i - lst < m) row[i % m]++;
            cout << row[i % m] + colcnt << " ";
        }
        cout << endl;
        for (int i = 0; i < max(n, m); ++i)
            col[i] = row[i] = 0;
    }
    return 0;
}
```
【核心实现思想】
1. 先关闭输入输出同步，加快输入输出速度。
2. 对于每个测试用例，初始化列的计数 `colcnt` 和上一个严肃学生的编号 `lst`。
3. 遍历每个学生，若该学生是严肃学生，更新 `lst`，若该列之前没有严肃学生，更新列的计数和列的标记数组。
4. 根据当前学生编号和 `lst` 的差值判断新的行是否有严肃学生，更新行的数组。
5. 输出当前时刻好的行和列的数量和。
6. 重置行和列的标记数组。

【关键思路或技巧】
- 将行和列的贡献分开统计，降低问题复杂度。
- 利用余数判断学生所在的列，避免每次重新计算列的状态。
- 记录上一个严肃学生的编号，快速判断新的行是否有严肃学生。
- 对于输入输出量较大的情况，关闭输入输出同步，加快程序运行速度。

【拓展思路】
同类型题可能会改变座位的移动规则、好的行和列的定义等，解题思路依然可以考虑将不同维度的贡献分开统计，利用数据结构记录状态，避免重复计算。类似算法套路可以应用在矩阵操作、区间更新等问题中。

【推荐题目】
1. P1047 [NOIP2005 普及组] 校门外的树：模拟区间操作。
2. P1067 [NOIP2009 普及组] 多项式输出：模拟多项式的输出规则。
3. P1098 [NOIP2007 提高组] 字符串的展开：模拟字符串的展开规则。

【个人心得】
郑朝曦zzx的题解提到注意本题 IO 量较大，如果用 cin 输入，请关闭同步并加上加速语句，否则第四个测试点会 TLE。这提醒我们在处理输入输出量较大的题目时，要注意输入输出的优化。 

---
处理用时：47.64秒
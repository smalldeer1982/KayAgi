# 题目信息

# Good Key, Bad Key

## 题目描述

你有 $n$ 个箱子。第 $i$ 个箱子中有 $a_i$ 个硬币。你需要按照从箱子 $1$ 号到箱子 $n$ 号的顺序打开所有 $n$ 个箱子。

你可以用以下两种钥匙之一打开一个箱子：
- 好钥匙：使用一次消耗 $k$ 个硬币。
- 坏钥匙：使用时不消耗硬币，但会使所有未打开的箱子中的硬币数减半（包括正要打开的这个箱子）。硬币减半时向下取整。比如，用坏钥匙打开箱子 $i$ 号时，$a_i=a_i/2$，$a_{i+1}=a_{i+1}/2$，$......$，$a_n=a_n/2$。

所有钥匙用过一次就会断掉（别想着买一把好钥匙开完所有箱子了），好钥匙需要重复付费，坏钥匙效果会重复计算。

也就是说，你总共需要使用 $n$ 把钥匙，每个箱子用一把。开始时，你没有硬币和钥匙，如果想用好钥匙，你就得去买。值得注意的是，在这个过程中你可以赊账买钥匙；例如，如果你只有 $1$ 个硬币，你也可以购买价值 $k=3$ 个硬币的好钥匙，你的余额会变成 $-2$ 个硬币。

你需要求出开完所有箱子之后你能获得的最大硬币数量（显然大于等于 $0$ ）。

## 样例 #1

### 输入

```
5
4 5
10 10 3 1
1 2
1
3 12
10 10 29
12 51
5 74 89 45 18 69 67 67 11 96 23 59
2 57
85 60```

### 输出

```
11
0
13
60
58```

# AI分析结果

### 题目分类
动态规划

### 综合分析与结论
这些题解主要围绕动态规划和贪心两种思路展开。动态规划思路通过定义状态和状态转移方程来求解最大金币数，关键在于处理使用坏钥匙次数的范围以优化时间和空间复杂度；贪心思路则基于先使用好钥匙再使用坏钥匙更优的结论，通过枚举使用好钥匙的数量来计算最大收益。

各题解的主要区别在于实现细节和优化方式。动态规划类题解大多通过缩小使用坏钥匙次数的枚举范围（因为一个数被除 2 次数大于等于 $\log_2{a_i}$ 后会变为 0）来降低复杂度；贪心类题解则利用先好后坏的贪心策略，结合前缀和等方法快速计算收益。

### 所选题解
- **作者：蒟蒻炒扇贝 (4星)**
    - **关键亮点**：思路清晰，详细阐述了动态规划的状态定义、状态转移方程以及复杂度优化过程，对可能出现的错误（如测试点 4 错误）进行了深入分析并给出解决方案。
    - **个人心得**：指出仅缩小值域会导致状态转移方程无法考虑使用坏钥匙次数多于 30 次的情况，通过将这些状态“压缩”到 $f_{i,30}$ 中解决问题。
- **作者：fuxuantong123 (4星)**
    - **关键亮点**：采用贪心思路，通过简单的枚举使用好钥匙数量来统计答案，代码简洁易懂。
    - **个人心得**：发现一定是先用好钥匙再使用坏钥匙更优，基于此进行枚举。
- **作者：GWBailang (4星)**
    - **关键亮点**：结合贪心和枚举的思想，明确指出坏钥匙最多使用 31 把，通过前缀和计算价值，时间复杂度为 $O(n \log n)$。
    - **个人心得**：强调“十年 OI 一场空，不开 long long 见祖宗”，提醒注意数据类型。

### 重点代码
#### 作者：蒟蒻炒扇贝
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=1e5+5;
int T,n,k,a[MAXN][35],f[MAXN][35];
signed main()
{
    cin>>T;
    while(T--)
    {
        cin>>n>>k;
        for(int i=1;i<=n;i++)for(int j=0;j<=30;j++)f[i][j]=-1e18;
        for(int i=1;i<=n;i++)cin>>a[i][0];
        for(int i=1;i<=n;i++)
            for(int j=1;j<=30;j++)a[i][j]=a[i][j-1]/2;
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=min(i,30ll);j++)
            {
                f[i][j]=max(f[i-1][j]+a[i][j]-k,f[i][j]);
                if(j-1>=0)f[i][j]=max(f[i-1][j-1]+a[i][j],f[i][j]);
            }
            if(i>=31)f[i][30]=max(f[i-1][30]+0,f[i][30]);
        }
        int maxn=-1e18;
        for(int j=0;j<=30;j++)maxn=max(maxn,f[n][j]);
        cout<<maxn<<endl;
    }
}
```
**核心实现思想**：定义 $f_{i,j}$ 为开到第 $i$ 个箱子，已经用了 $j$ 次坏钥匙所能得到的最大金币数，通过状态转移方程 $f_{i,j}=\max(f_{i-1,j}+a_{i,j}-k,f_{i-1,j-1}+a_{i,j})$ 进行状态转移，同时将使用坏钥匙次数大于等于 30 次的状态“压缩”到 $f_{i,30}$ 中。

#### 作者：fuxuantong123
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[100010];
long long sum[100010];
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        int n;
        long long k;
        scanf("%d%lld",&n,&k);
        long long fw=0;
        sum[0]=0;
        for(int i=1;i<=n;i++){
            scanf("%lld",&a[i]);
            sum[i]=sum[i-1]+a[i];
            fw=max(fw,a[i]);
        }
        long long mx=-9e18;
        for(int i=0;i<=n;i++){
            long long ans=sum[i];
            long long sin=1;
            for(int j=i+1;j<=n;j++){
                sin*=2;
                if(sin>fw){
                    break;
                }
                ans+=a[j]/sin;
            }
            ans-=i*k;
            mx=max(ans,mx);
        }
        printf("%lld\n",mx);
    }
    return 0;
}
```
**核心实现思想**：利用前缀和数组 `sum` 计算使用好钥匙的收益，然后枚举使用好钥匙的数量，对于剩余箱子使用坏钥匙，通过不断将剩余箱子的金币数除以 2 计算收益，最后取最大值。

#### 作者：GWBailang
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005];
long long er[]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648};
long long qzh[100005];
int main(){
    long long t,n,k,da=0,zhi;
    cin>>t;
    while(t--){
        cin>>n>>k;
        da=0;
        for(long long i=1;i<=n;i++){
            cin>>a[i];
            qzh[i]=qzh[i-1]+a[i];
        }
        for(long long i=0;i<=n;i++){
            zhi=qzh[i]-i*k;
            for(long long j=i+1;j<=min(i+31,n);j++){
                zhi+=a[j]/er[j-i];
            }
            da=max(da,zhi);
        }
        cout<<da<<endl;
    }
    return 0;
}
```
**核心实现思想**：使用前缀和数组 `qzh` 计算使用好钥匙的收益，枚举使用好钥匙的数量，对于剩余箱子使用坏钥匙，通过预计算的 2 的幂次方数组 `er` 快速计算剩余箱子的金币数，最后取最大值。

### 关键思路或技巧
- **动态规划优化**：利用一个数被除 2 次数大于等于 $\log_2{a_i}$ 后会变为 0 的性质，缩小使用坏钥匙次数的枚举范围，降低时间和空间复杂度。
- **贪心策略**：发现先使用好钥匙再使用坏钥匙更优，通过枚举使用好钥匙的数量来简化问题。
- **前缀和优化**：使用前缀和数组快速计算使用好钥匙的收益，减少重复计算。

### 拓展思路
同类型题可能涉及更多的决策选择和状态变化，例如增加钥匙种类、改变箱子的排列规则等。类似算法套路包括在动态规划中通过分析问题的性质来优化状态定义和状态转移方程，在贪心算法中通过证明贪心策略的正确性来简化问题求解。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，考察动态规划的基本应用。
2. [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：简单的动态规划入门题，通过状态转移方程求解最大路径和。
3. [P2679 [NOIP2015 提高组] 子串](https://www.luogu.com.cn/problem/P2679)：较复杂的动态规划问题，需要考虑多个状态变量和状态转移情况。

---
处理用时：79.79秒
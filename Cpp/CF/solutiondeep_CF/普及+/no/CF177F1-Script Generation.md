# 题目信息

# Script Generation

## 题目描述

编剧们打算组一些 $\mathtt{CP}$ 来满足观众的喜好！

总共有 $n$ 个男角色与 $n$ 个女角色，且最多只能组成 $k$ 对 $\mathtt{CP}$ ，每对 $\mathtt{CP}$ 都可以给观众带来 $r$ 的幸福值。

总幸福值的定义即为所有 $\mathtt{CP}$ 给观众带来的幸福值之和且一个角色不能和多人组 $\mathtt{CP}$ ！

由于编剧认为让观众获得最大幸福值会导致剧本可预测，所以他们想要选取总幸福值为第 $t$ 小的 $\mathtt{CP}$ 组合方案。

由于编剧们去玩了，所以他们把这个问题交给了你，请你求出第 $t$ 小的总幸福值。

数据保证有解。

## 样例 #1

### 输入

```
2 4 3
1 1 1
1 2 2
2 1 3
2 2 7
```

### 输出

```
2
```

## 样例 #2

### 输入

```
2 4 7
1 1 1
1 2 2
2 1 3
2 2 7
```

### 输出

```
8
```

# AI分析结果

### 题目内容
# 脚本生成

## 题目描述
编剧们打算组一些 CP 来满足观众的喜好！
总共有 $n$ 个男角色与 $n$ 个女角色，且最多只能组成 $k$ 对 CP ，每对 CP 都可以给观众带来 $r$ 的幸福值。
总幸福值的定义即为所有 CP 给观众带来的幸福值之和，且一个角色不能和多人组 CP ！
由于编剧认为让观众获得最大幸福值会导致剧本可预测，所以他们想要选取总幸福值为第 $t$ 小的 CP 组合方案。
由于编剧们去玩了，所以他们把这个问题交给了你，请你求出第 $t$ 小的总幸福值。
数据保证有解。

## 样例 #1
### 输入
```
2 4 3
1 1 1
1 2 2
2 1 3
2 2 7
```
### 输出
```
2
```

## 样例 #2
### 输入
```
2 4 7
1 1 1
1 2 2
2 1 3
2 2 7
```
### 输出
```
8
```

### 算法分类
二分 + 深度优先搜索 DFS

### 综合分析与结论
三道题解思路基本一致，均采用二分答案的方法来解决问题。先对可能的幸福值范围进行二分，对于每个二分得到的中间值 $mid$，通过深度优先搜索（DFS）来统计幸福值小于等于 $mid$ 的 CP 组合数是否达到 $t$ 个，以此调整二分的上下界，最终得到第 $t$ 小的幸福值。解决难点在于如何设计高效的 $check$ 函数，即通过 DFS 统计满足条件的组合数，同时由于时限较紧，需在 DFS 过程中进行剪枝优化。

### 所选的题解
 - **作者：wkjwkj (5星)**
    - **关键亮点**：思路清晰，代码简洁，详细阐述了二分答案的思路及 $check$ 函数设计，在 DFS 剪枝部分有较好体现。
    - **重点代码**：
```cpp
int dfs(int x,int sum,int limit) {
    if(sum>limit)return 0;
    if(x==n+1)return 1;
    int ans=dfs(x+1,sum,limit);
    for(int i=head[x];i;i=Next[i]) {
        int y=ver[i],z=edge[i];
        if(ans>=t)continue;
        if(vis[y])continue;
        vis[y]=1;
        ans+=dfs(x+1,sum+z,limit);
        vis[y]=0;
    }
    return ans;
}
int check(int x) {
    return dfs(1,0,x)>=t;
}
```
核心实现思想：`dfs` 函数用于在当前限制值 `limit` 下，从第 `x` 个男角色开始，统计满足幸福值总和不超过 `limit` 的 CP 组合数。若总和超过 `limit` 则返回 0；若已处理完所有男角色则返回 1。遍历当前男角色可配对的女角色，若当前组合数已达 `t` 或者女角色已被使用则跳过，否则标记女角色已用，递归统计下一个男角色的组合数，并在递归后恢复女角色未使用状态。`check` 函数调用 `dfs` 判断在限制值 `x` 下组合数是否达到 `t`。
 - **作者：Jin_Yichen (4星)**
    - **关键亮点**：思路阐述清晰，对剪枝的情况进行了详细说明。
    - **重点代码**：
```cpp
int Dfs(int dep,int sum,int lit) {
    if(sum>lit)return 0;
    if(dep==n+1)return 1;
    int ans=Dfs(dep+1,sum,lit);
    for(int i=hd[dep];i;i=nt[i]) {
        int x=ve[i],y=ed[i];
        if(ans>=t)continue;
        if(vs[x])continue;
        vs[x]=true;
        ans+=Dfs(dep+1,sum+y,lit);
        vs[x]=false;
    } 
    return ans;
}
bool check(int x) {
    if(Dfs(1,0,x)>=t)return true;
    else return false;
}
```
核心实现思想：与上一个题解类似，`Dfs` 函数从第 `dep` 个男角色开始，统计在幸福值限制 `lit` 内的组合数，`check` 函数判断在限制值 `x` 下组合数是否达 `t`。剪枝操作体现在若当前组合数已达 `t` 或当前女角色已被使用则跳过。

### 最优关键思路或技巧
1. **二分答案**：对于直接求解第 $t$ 小的幸福值较困难的情况，通过二分答案的方式，将问题转化为判断某个值是否满足条件，从而降低问题复杂度。
2. **DFS 剪枝**：在 DFS 过程中，通过判断当前组合数是否已达到 $t$ 以及角色是否已被使用，及时停止不必要的搜索，优化时间复杂度。

### 同类型题或类似算法套路
此类题目通常具有答案单调性的特点，可采用二分答案结合搜索（如 DFS）的方式解决。先确定答案的大致范围，然后通过二分查找，每次对中间值进行条件判断（通过搜索实现），逐步缩小答案范围。

### 洛谷相似题目推荐
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：通过二分答案，结合贪心判断，求解满足条件的最小跳跃距离。
2. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：利用二分答案，判断在给定分段数下，最大分段和的最小值。
3. [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)：同样是二分答案，结合贪心检查，确定满足条件的路标最少数量。 

---
处理用时：58.11秒
# 题目信息

# Greedy Merchants

## 题目描述

在 ABBYY 中住着一只聪明的海狸。这一次，它开始研究历史。当它读到有关罗马帝国的内容时，它对商人的生活产生了兴趣。

罗马帝国由编号从 $1$ 到 $n$ 的 $n$ 个城市组成。它还拥有 $m$ 条双向道路，编号从 $1$ 到 $m$。每条路连接两个不同的城市，任何两个城市之间最多只有一条路相连。

如果存在一个有限的城市序列 $t_1, t_2, \ldots, t_p$（$p \geq 1$），使得：

- $t_1 = c_1$
- $t_p = c_2$
- 对于任意 $i$（$1 \leq i < p$），城市 $t_i$ 和 $t_{i+1}$ 都通过一条道路相连。

则称城市 $c_1$ 和 $c_2$ 之间存在一条路径。

我们知道罗马帝国的任何两个城市之间都存在一条路径。

在帝国中有 $k$ 个商人，编号从1到k。对于每个商人，可以用 $s_i$ 和 $l_i$ 表示，其中 $s_i$ 是这个商人仓库所在城市的编号，$l_i$ 是他的商店所在的城市编号。商店和仓库可能位于不同的城市，因此商人们需要将货物从仓库运送到商店。


如果某一条路的破坏会让一个商人的城市和仓库之间不再存在“路径”，那么称这条路对于该商人是“重要的道路”。罗马帝国的商人们非常贪婪，因此每个商人只为对他“重要的道路”缴纳税款（$1$ 元）。换句话说，每个商人支付 $d_i$ 元的税款，其中 $d_i$（$d_i \geq 0$）是对该商人“重要的道路”的数量。

收税日到来，聪明的海狸想要计算每个商人需要缴纳的税，他需要你的帮助。

## 样例 #1

### 输入

```
7 8
1 2
2 3
3 4
4 5
5 6
5 7
3 5
4 7
4
1 5
2 4
2 6
4 7
```

### 输出

```
2
1
2
0
```

# AI分析结果

### 题目内容
# 贪婪的商人

## 题目描述
在 ABBYY 住着一只聪明的海狸。这一次，它开始研究历史。当它读到有关罗马帝国的内容时，它对商人的生活产生了兴趣。

罗马帝国由编号从 $1$ 到 $n$ 的 $n$ 个城市组成。它还拥有 $m$ 条双向道路，编号从 $1$ 到 $m$。每条路连接两个不同的城市，任何两个城市之间最多只有一条路相连。

如果存在一个有限的城市序列 $t_1, t_2, \ldots, t_p$（$p \geq 1$），使得：
- $t_1 = c_1$
- $t_p = c_2$
- 对于任意 $i$（$1 \leq i < p$），城市 $t_i$ 和 $t_{i + 1}$ 都通过一条道路相连。

则称城市 $c_1$ 和 $c_2$ 之间存在一条路径。

我们知道罗马帝国的任何两个城市之间都存在一条路径。

在帝国中有 $k$ 个商人，编号从 1 到 $k$。对于每个商人，可以用 $s_i$ 和 $l_i$ 表示，其中 $s_i$ 是这个商人仓库所在城市的编号，$l_i$ 是他的商店所在的城市编号。商店和仓库可能位于不同的城市，因此商人们需要将货物从仓库运送到商店。

如果某一条路的破坏会让一个商人的城市和仓库之间不再存在“路径”，那么称这条路对于该商人是“重要的道路”。罗马帝国的商人们非常贪婪，因此每个商人只为对他“重要的道路”缴纳税款（$1$ 元）。换句话说，每个商人支付 $d_i$ 元的税款，其中 $d_i$（$d_i \geq 0$）是对该商人“重要的道路”的数量。

收税日到来，聪明的海狸想要计算每个商人需要缴纳的税，他需要你的帮助。

## 样例 #1
### 输入
```
7 8
1 2
2 3
3 4
4 5
5 6
5 7
3 5
4 7
4
1 5
2 4
2 6
4 7
```
### 输出
```
2
1
2
0
```

### 算法分类
图论

### 综合分析与结论
三道题解思路基本一致，均是通过边双连通分量将原图转化为树，把求两点间重要道路（割边）数量的问题转化为求树上两点距离。算法要点在于利用 Tarjan 算法进行边双缩点，构建新树后通过求树上两点的最近公共祖先（LCA）来计算距离。解决难点在于理解边双连通分量与割边的关系，以及如何正确实现 Tarjan 算法和 LCA 算法。

### 所选的题解
 - **作者：lzyqwq (5星)**
    - **关键亮点**：思路清晰，代码简洁，注释详细，对 Tarjan 算法和 LCA 算法的实现步骤清晰，且考虑到建缩点后的图避免重边问题。
    - **重点代码 - Tarjan 算法**：
```cpp
void tarjan(int x, int fa) {
    dfn[x] = low[x] = ++cnt;
    s.push(x);
    is[x] = 1;
    for (int i : g[x]) {
        if (i!= fa) {
            if (!dfn[i]) {
                tarjan(i, x);
                low[x] = min(low[x], low[i]);
            } else if (is[i]) {
                low[x] = min(low[x], dfn[i]);
            }
        }
    }
    if (dfn[x] == low[x]) {
        ++sum;
        while (1) {
            int p = s.top();
            s.pop();
            is[p] = 0;
            ebc[p] = sum;
            if (x == p) {
                break;
            }
        }
    }
}
```
核心实现思想：通过深度优先搜索，利用 `dfn` 记录访问顺序，`low` 记录该点及子树能回溯到的最早祖先，当 `dfn[x] == low[x]` 时，将栈中元素弹出，标记为同一个边双连通分量。
    - **重点代码 - LCA 算法**：
```cpp
inline int lca(int x, int y) {
    if (d[x] < d[y]) {
        swap(x, y);
    }
    while (d[x] > d[y]) {
        x = f[lg[d[x] - d[y]]][x];
    }
    if (x == y) {
        return x;
    }
    for (int i = lg[d[x]]; i >= 0; i--) {
        if (f[i][x]!= f[i][y]) {
            x = f[i][x];
            y = f[i][y];
        }
    }
    return f[0][x];
}
```
核心实现思想：先将深度较大的点提升到与另一点相同深度，然后通过倍增数组 `f` 同时向上跳跃，找到最近公共祖先。

 - **作者：Yexo (4星)**
    - **关键亮点**：解题思路阐述清晰，代码结构完整，同样利用 Tarjan 算法和 LCA 解决问题，代码风格简洁明了。
    - **重点代码 - Tarjan 算法**：
```cpp
void tarjan(int x,int edge){
    ++cnt;
    dfn[x]=low[x]=cnt;
    st.push(x);
    for(auto i:G[x]){
        if(i.second==(edge^1)) continue;
        if(!dfn[i.first]) tarjan(i.first,i.second),low[x]=min(low[x],low[i.first]);
        else low[x]=min(low[x],dfn[i.first]);
    }
    if(low[x]==dfn[x]){
        int t;
        sum++;
        do{
            t=st.top();
            st.pop();
            belong[t]=sum;
        }while(t!=x);
    }
}
```
核心实现思想：与上一个 Tarjan 算法类似，通过深度优先搜索，利用 `dfn` 和 `low` 数组标记边双连通分量，不同之处在于通过边的编号判断是否为反向边。
    - **重点代码 - LCA 算法**：
```cpp
int query(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=__lg(n);i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
    if(x==y) return x;
    for(int i=__lg(n);i>=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    return f[x][0];
}
```
核心实现思想：同样是利用倍增法求 LCA，先将深度大的点提升到相同深度，再同时跳跃找到最近公共祖先。

### 最优关键思路或技巧
利用边双连通分量将无向图转化为树，把原问题转化为树上距离问题，通过 Tarjan 算法找割边并缩点，利用倍增法快速求树上两点的最近公共祖先，从而高效计算两点间割边数量。

### 同类型题或类似算法套路
此类题目通常围绕图的连通性和路径问题，常见套路是通过双连通分量将复杂图结构简化为树结构，再利用树的性质和相关算法（如 LCA）解决问题。

### 洛谷推荐题目
 - **P3388 【模板】割点（割顶）**：通过 Tarjan 算法求割点，与本题类似，都涉及图论中连通性相关概念及 Tarjan 算法应用。
 - **P3398 仓鼠找sugar**：需要求树上两点间路径长度，可利用 LCA 算法解决，与本题转化为树上距离问题类似。
 - **P1656 炸铁路**：同样是求图中某些边对两点连通性的影响，可通过边双连通分量和 LCA 等知识解决。 

---
处理用时：67.91秒
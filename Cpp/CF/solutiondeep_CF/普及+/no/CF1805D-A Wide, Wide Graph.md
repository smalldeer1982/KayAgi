# 题目信息

# A Wide, Wide Graph

## 题目描述

给定一棵 $n$（$2\leq n\leq 10^5$）个节点的无根树，对于每个 $k$（$1\leq k \leq n$），定义一个无向图 $G_k$，其中由边连接的两个节点 $u$ 和 $v$ 的距离至少为 $k$。请你计算 $G_k$ 的连通块个数。

## 说明/提示

$2\leq n\leq 10^5$


第一个样例中，当$k=1$时，所有的点都连通；当$k=4$时，只有$(4,6)$和$(5,6)$两条边连通，所以连通块个数为4。

第二个样例中，当$k=3$时，节点1、4、5构成一个连通块，其余两个节点分别为一个连通块。

## 样例 #1

### 输入

```
6
1 2
1 3
2 4
2 5
3 6```

### 输出

```
1 1 2 4 6 6```

## 样例 #2

### 输入

```
5
1 2
2 3
3 4
3 5```

### 输出

```
1 1 3 5 5```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

给定一棵 $n$（$2\leq n\leq 10^5$）个节点的无根树，对于每个 $k$（$1\leq k \leq n$），定义一个无向图 $G_k$，其中由边连接的两个节点 $u$ 和 $v$ 的距离至少为 $k$。请你计算 $G_k$ 的连通块个数。

#### 说明/提示

$2\leq n\leq 10^5$

第一个样例中，当$k=1$时，所有的点都连通；当$k=4$时，只有$(4,6)$和$(5,6)$两条边连通，所以连通块个数为4。

第二个样例中，当$k=3$时，节点1、4、5构成一个连通块，其余两个节点分别为一个连通块。

#### 样例 #1

##### 输入

```
6
1 2
1 3
2 4
2 5
3 6
```

##### 输出

```
1 1 2 4 6 6
```

#### 样例 #2

##### 输入

```
5
1 2
2 3
3 4
3 5
```

##### 输出

```
1 1 3 5 5
```

### 算法分类

图论

### 题解分析与结论

该题的核心思路是利用树的直径性质，通过计算每个点到直径端点的最大距离，来确定每个点在 $G_k$ 中的连通性。具体来说，当 $k$ 大于某个点到直径端点的最大距离时，该点将成为一个孤立的连通块。通过预处理每个点的最大距离，并使用差分或前缀和的方式统计连通块的数量，可以在 $O(n)$ 的时间复杂度内解决问题。

### 精选题解

#### 题解1：作者：lihongqian__int128 (赞：12)

**星级：5星**

**关键亮点：**
- 通过两次DFS找到树的直径的两个端点。
- 计算每个点到两个端点的距离，取最大值作为该点的最远距离。
- 使用差分数组统计每个 $k$ 对应的连通块数量，最后通过前缀和输出结果。

**核心代码：**
```cpp
void dfs(int cur , int cnt)
{
	if(cnt > dis)	x = cur , dis = cnt ;
	for(int to : g[cur])
	{
		if(vis[to])	continue ;
		vis[to] = 1 ;
		dfs(to , cnt + 1) ;
	}
	return ;
}
```
**代码思想：** 通过DFS遍历树，找到直径的两个端点，并计算每个点到端点的距离。

#### 题解2：作者：六楼溜刘 (赞：12)

**星级：5星**

**关键亮点：**
- 通过两次DFS找到树的直径的两个端点。
- 计算每个点到两个端点的距离，取最大值作为该点的最远距离。
- 使用差分数组统计每个 $k$ 对应的连通块数量，最后通过前缀和输出结果。

**核心代码：**
```cpp
void dfs(int x,int fa){//用来求直径的 dfs。
	dpt[x]=dpt[fa]+1;
	if(dpt[x]>dpt[rt]) rt=x;
	for(auto i:e[x]){
		if(i==fa) continue;
		dfs(i,x);
	}
}
```
**代码思想：** 通过DFS遍历树，找到直径的两个端点，并计算每个点到端点的距离。

#### 题解3：作者：Xy_top (赞：8)

**星级：4星**

**关键亮点：**
- 通过DFS找到树的直径的两个端点。
- 使用倍增法计算每个点到两个端点的距离，取最大值作为该点的最远距离。
- 使用差分数组统计每个 $k$ 对应的连通块数量，最后通过前缀和输出结果。

**核心代码：**
```cpp
void dfs (int x, int y, int f){
	if (y > ma) {
		ret = x;
		ma = y;
	}
	for (int i = 0; i < v[x].size (); i ++) {
		if (v[x][i] != f) dfs (v[x][i], y + 1, x);
	}
}
```
**代码思想：** 通过DFS遍历树，找到直径的两个端点，并计算每个点到端点的距离。

### 最优关键思路或技巧

1. **树的直径性质**：利用树的直径的两个端点，计算每个点到这两个端点的最大距离，从而确定每个点在 $G_k$ 中的连通性。
2. **差分与前缀和**：通过差分数组统计每个 $k$ 对应的连通块数量，最后通过前缀和输出结果，优化了时间复杂度。

### 可拓展之处

类似的问题可以扩展到其他图论问题中，例如在图中寻找最远点对、计算图的直径等。此外，差分与前缀和的思想也可以应用于其他需要统计区间信息的题目中。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 树的直径](https://www.luogu.com.cn/problem/P1395)
3. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)

### 个人心得摘录

- **调试经历**：在实现DFS时，需要注意访问标记的清除，否则会导致重复访问或死循环。
- **踩坑教训**：在计算距离时，要确保每个点的距离是相对于直径端点的，而不是相对于根节点的。
- **顿悟感想**：通过树的直径性质，可以大大简化问题的复杂度，尤其是在处理树的最远点对问题时。

---
处理用时：46.26秒
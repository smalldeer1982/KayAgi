# 题目信息

# Gardening Friends

## 题目描述

#### 题意翻译
有一棵有 $n$ 个节点的树，根节点为节点 $1$，每条边的权值为 $k$。现在可以进行挪根操作，每次耗费 $c$ 价值，将树的根转移到与原来根结点相邻的点上。

定义这棵树的价值为根节点到子节点的最远距离 $a$ 与挪根耗费总价值 $b$ 之差（可能不会挪根）。求这棵树经过挪根操作后的最大价值

## 样例 #1

### 输入

```
4
3 2 3
2 1
3 1
5 4 1
2 1
4 2
5 4
3 4
6 5 3
4 1
6 1
2 6
5 1
3 2
10 6 4
1 3
1 9
9 7
7 6
6 4
9 2
2 8
8 5
5 10```

### 输出

```
2
12
17
32```

# AI分析结果

### 题目翻译

#### 题目描述

有一棵有 $n$ 个节点的树，根节点为节点 $1$，每条边的权值为 $k$。现在可以进行挪根操作，每次耗费 $c$ 价值，将树的根转移到与原来根结点相邻的点上。

定义这棵树的价值为根节点到子节点的最远距离 $a$ 与挪根耗费总价值 $b$ 之差（可能不会挪根）。求这棵树经过挪根操作后的最大价值。

### 算法分类
深度优先搜索 DFS、图论

### 题解分析与结论

本题的核心在于通过DFS遍历树，计算每个节点作为根时的最大深度，并结合挪根操作的代价，求出最大价值。难点在于如何高效地计算每个节点的最大深度，并处理挪根操作的代价。

#### 题解对比

1. **SegTree (赞：7)**  
   - **亮点**：通过一次DFS遍历，记录每个节点的子树最深深度和次深深度，结合父亲节点的贡献，高效计算每个节点的最大深度。  
   - **评分**：5星  
   - **关键代码**：
     ```cpp
     int dfs(int u, int fa) {
         int mx1 = 0, mx2 = 0;
         for (int v : adj[u]) {
             if (v == fa) continue;
             int d = dfs(v, u) + 1;
             if (d > mx1) mx2 = mx1, mx1 = d;
             else mx2 = max(mx2, d);
         }
         ans = max(ans, mx1 * k + max(0, mx2 * (k - c) - dep[u] * c));
         return mx1;
     }
     ```

2. **bzzltl (赞：7)**  
   - **亮点**：通过三次DFS分别求出树的直径的两个端点和每个节点的深度，结合挪根操作的代价，求出最大价值。  
   - **评分**：4星  
   - **关键代码**：
     ```cpp
     void dfs(int u, int fa, int dep) {
         for (int v : adj[u]) {
             if (v == fa) continue;
             dfs(v, u, dep + 1);
         }
         ans = max(ans, dep * k - (dep - 1) * c);
     }
     ```

3. **ShenTianYi_ (赞：4)**  
   - **亮点**：通过三次BFS分别求出树的直径的两个端点和每个节点的深度，结合挪根操作的代价，求出最大价值。  
   - **评分**：4星  
   - **关键代码**：
     ```cpp
     void bfs(int start, int *dis) {
         queue<int> q;
         q.push(start);
         dis[start] = 0;
         while (!q.empty()) {
             int u = q.front();
             q.pop();
             for (int v : adj[u]) {
                 if (dis[v] == -1) {
                     dis[v] = dis[u] + 1;
                     q.push(v);
                 }
             }
         }
     }
     ```

### 最优关键思路

通过一次DFS遍历，记录每个节点的子树最深深度和次深深度，结合父亲节点的贡献，高效计算每个节点的最大深度。这种方法避免了多次遍历，时间复杂度为 $O(n)$，空间复杂度也为 $O(n)$。

### 可拓展之处

类似的问题可以扩展到其他树形结构的最优化问题，如求树的直径、最小生成树等。可以通过DFS或BFS遍历树，结合动态规划或贪心策略，解决更复杂的树形问题。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
3. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

### 个人心得

在调试过程中，发现记录次深深度的重要性，特别是在处理子树最深深度时，次深深度可以帮助避免重复计算，提高效率。

---
处理用时：30.70秒
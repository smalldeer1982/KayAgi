# 题目信息

# XOR Construction

## 题目描述

You are given $ n-1 $ integers $ a_1, a_2, \dots, a_{n-1} $ .

Your task is to construct an array $ b_1, b_2, \dots, b_n $ such that:

- every integer from $ 0 $ to $ n-1 $ appears in $ b $ exactly once;
- for every $ i $ from $ 1 $ to $ n-1 $ , $ b_i \oplus b_{i+1} = a_i $ (where $ \oplus $ denotes the bitwise XOR operator).

## 样例 #1

### 输入

```
4
2 1 2```

### 输出

```
0 2 3 1```

## 样例 #2

### 输入

```
6
1 6 1 4 1```

### 输出

```
2 3 5 4 0 1```

# AI分析结果

### 题目内容重写
# XOR 构造

## 题目描述

给定 $n-1$ 个整数 $a_1, a_2, \dots, a_{n-1}$。

你的任务是构造一个数组 $b_1, b_2, \dots, b_n$，满足以下条件：

- 数组 $b$ 中的每个整数都是 $0$ 到 $n-1$ 之间的唯一整数；
- 对于每个 $i$ 从 $1$ 到 $n-1$，$b_i \oplus b_{i+1} = a_i$（其中 $\oplus$ 表示按位异或运算符）。

## 样例 #1

### 输入

```
4
2 1 2```

### 输出

```
0 2 3 1```

## 样例 #2

### 输入

```
6
1 6 1 4 1```

### 输出

```
2 3 5 4 0 1```

### 算法分类
位运算、构造

### 题解分析与结论
该题的核心是通过给定的异或差分数组 $a$，构造一个满足条件的数组 $b$。题解主要集中在如何通过前缀异或和来确定 $b_1$，进而推导出整个数组 $b$。大多数题解使用了位运算和前缀异或和的技巧，部分题解还引入了字典树来优化查找最大异或值的过程。

### 高星题解推荐
1. **作者：SunnyYuan (赞：34)**  
   - **星级：5星**  
   - **关键亮点**：通过前缀异或和推导出 $b_1$，并利用位运算统计来确定 $b_1$ 的每一位。代码简洁且高效，时间复杂度为 $O(n \log n)$。  
   - **核心代码**：
     ```cpp
     int ans = 0;
     for (int i = 0; i < 31; i++) {
         int sum1 = 0, sum2 = 0;
         for (int j = 0; j < n; j++) {
             if (a[j] >> i & 1) sum1++;
             else sum2++;
         }
         if (sum1 > sum2) ans |= 1 << i;
     }
     for (int i = 0; i < n; i++) a[i] ^= ans;
     ```
   - **个人心得**：作者提到在赛场上交了多次才通过，强调了调试的重要性。

2. **作者：_sunkuangzheng_ (赞：16)**  
   - **星级：4星**  
   - **关键亮点**：通过字典树来查找最大异或值，确保 $b$ 数组中的元素不超过 $n-1$。思路清晰，代码实现较为复杂但优化了查找过程。  
   - **核心代码**：
     ```cpp
     void ins(int x){
         int s = 0;
         for(int i = 22;i >= 0;i --){
             val[s] ++;
             if(!ch[s][(x >> i) & 1]) ch[s][(x >> i) & 1] = ++tot;
             s = ch[s][(x >> i) & 1];
         }val[s] ++;
     }
     int qry(int x){
         int s = 0,ans = 0;
         for(int i = 22;i >= 0;i --){
             int k = (x >> i) & 1;
             if(ch[s][!k]) s = ch[s][!k],ans += (1 << i);
             else s = ch[s][k];
         }return ans;
     }
     ```
   - **个人心得**：作者强调了字典树在处理异或问题中的优势，特别是在查找最大异或值时的效率。

3. **作者：LYY_yyyy (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：通过统计 $0$ 到 $n-1$ 中每一位的 $1$ 的个数，来确定 $b_1$ 的每一位。思路简洁，代码实现较为直接。  
   - **核心代码**：
     ```cpp
     for(int j=0;j<=20;j++) {
         int cnt=0;
         for(int i=2;i<=n;i++) if((a[i]>>j)&1) cnt++;
         if(cnt!=cnts[j]) ans+=(1<<j); 
     }
     ```
   - **个人心得**：作者提到通过统计每一位的 $1$ 的个数来确定 $b_1$，强调了位运算在构造问题中的应用。

### 最优关键思路
通过前缀异或和推导出 $b_1$，并利用位运算统计来确定 $b_1$ 的每一位，进而构造出整个数组 $b$。字典树在处理最大异或值时提供了高效的优化。

### 拓展与举一反三
类似的问题可以通过前缀和、位运算等技巧来解决，特别是在处理异或相关的问题时，字典树是一个常用的优化工具。

### 推荐题目
1. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)
2. [P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)
3. [P4592 异或序列](https://www.luogu.com.cn/problem/P4592)

---
处理用时：39.65秒
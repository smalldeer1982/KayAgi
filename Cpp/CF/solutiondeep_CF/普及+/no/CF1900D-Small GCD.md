# 题目信息

# Small GCD

## 题目描述

$ a, b, c $ 为整数，定义 $ f(a, b, c) $ 如下:

将三个数排序，使得 $ a \le b \le c $。则函数返回 $ \gcd(a, b) $ , 这里 $ \gcd(a, b) $ 表示 [最大公约数 (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) 。简而言之，函数返回较小的两个数的最大公约数。

你会得到数组 $ a $，包含 $ n $ 个元素。求 $ f(a_i, a_j, a_k) $ 之和，其中 $ 1 \le i< j < k \le n $。

形式化的讲，求 $ \sum_{i = 1}^n \sum_{j = i+1}^n \sum_{k =j +1}^n f(a_i, a_j, a_k)$。

## 样例 #1

### 输入

```
2
5
2 3 6 12 17
8
6 12 8 10 15 12 18 16```

### 输出

```
24
203```

# AI分析结果

### 题目内容重写

#### Small GCD

**题目描述**

给定三个整数 $a, b, c$，定义函数 $f(a, b, c)$ 如下：

将三个数排序，使得 $a \le b \le c$。函数返回 $\gcd(a, b)$，其中 $\gcd(a, b)$ 表示 $a$ 和 $b$ 的最大公约数。简而言之，函数返回较小的两个数的最大公约数。

你会得到一个包含 $n$ 个元素的数组 $a$。求所有满足 $1 \le i < j < k \le n$ 的三元组 $(a_i, a_j, a_k)$ 的 $f(a_i, a_j, a_k)$ 之和。

形式化地讲，求 $\sum_{i = 1}^n \sum_{j = i+1}^n \sum_{k =j +1}^n f(a_i, a_j, a_k)$。

**样例 #1**

**输入**

```
2
5
2 3 6 12 17
8
6 12 8 10 15 12 18 16
```

**输出**

```
24
203
```

### 算法分类

数学

### 题解分析与结论

本题的核心在于高效计算所有三元组中较小两个数的最大公约数之和。由于直接枚举所有三元组的时间复杂度为 $O(n^3)$，无法通过题目限制，因此需要优化。

大多数题解采用了以下思路：

1. **排序**：首先对数组进行排序，这样可以简化问题，因为排序后三元组的最小值和次小值可以直接确定。
2. **枚举中间值**：枚举三元组的中间值 $a_j$，然后计算所有 $i < j$ 的 $\gcd(a_i, a_j)$，并乘以 $(n - j)$ 作为贡献。
3. **欧拉反演或容斥原理**：利用欧拉反演或容斥原理来高效计算 $\gcd(a_i, a_j)$ 的和，避免直接枚举。

### 高星题解

#### 题解1：作者：Phartial (赞：13)

**星级**：5星

**关键亮点**：
- 使用了莫比乌斯反演和欧拉函数的性质，将问题转化为统计满足条件的数的个数。
- 通过预处理欧拉函数和莫比乌斯函数，大大减少了计算量。
- 时间复杂度为 $O(n \log n + v \log v)$，效率极高。

**核心代码**：
```cpp
for (int t = 1; t <= a[n]; ++t) {
    LL _s = 0;
    for (int j = t, _c = 0; j <= a[n]; j += t) {
        _s += _c * s[j] + b[j], _c += c[j];
    }
    ans += _s * phi[t];
}
```

#### 题解2：作者：_always_ (赞：11)

**星级**：4星

**关键亮点**：
- 使用了欧拉反演，将 $\gcd(a_i, a_j)$ 转化为欧拉函数的和。
- 通过预处理欧拉函数和枚举因数，优化了计算过程。
- 时间复杂度为 $O(n \sqrt{n})$，代码简洁易懂。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j * j <= a[i]; j++) {
        if (a[i] % j == 0) {
            ans += sum[j] * phi[j] * (n - i);
            sum[j]++;
            if (j * j != a[i]) {
                ans += sum[a[i] / j] * phi[a[i] / j] * (n - i);
                sum[a[i] / j]++;
            }
        }
    }
}
```

#### 题解3：作者：nynkqh_yzq (赞：11)

**星级**：4星

**关键亮点**：
- 使用了欧拉反演，结合因数枚举和容斥原理，优化了计算过程。
- 通过预处理因数和欧拉函数，减少了重复计算。
- 时间复杂度为 $O(n \sqrt{n})$，代码结构清晰。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j * j <= a[i]; j++) {
        if (a[i] % j == 0) {
            res += phi[j] * cnt[j], cnt[j]++;
            if (j * j != a[i]) res += phi[a[i] / j] * cnt[a[i] / j], cnt[a[i] / j]++;
        }
    }
    ans += res * (n - i);
}
```

### 最优关键思路

1. **排序与枚举中间值**：通过排序简化问题，枚举中间值 $a_j$，计算所有 $i < j$ 的 $\gcd(a_i, a_j)$，并乘以 $(n - j)$ 作为贡献。
2. **欧拉反演与容斥原理**：利用欧拉反演或容斥原理，将 $\gcd(a_i, a_j)$ 转化为欧拉函数的和，避免直接枚举。
3. **预处理与因数枚举**：通过预处理欧拉函数和因数，减少重复计算，优化时间复杂度。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到计算四元组或更多元组的最大公约数之和，思路类似，但需要进一步优化。
- **其他数论应用**：欧拉反演和容斥原理在数论问题中有广泛应用，可以用于解决其他涉及最大公约数或最小公倍数的问题。

### 推荐题目

1. [P2303 [SDOI2012] Longge的问题](https://www.luogu.com.cn/problem/P2303)
2. [P1447 [NOI2010] 能量采集](https://www.luogu.com.cn/problem/P1447)
3. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)

---
处理用时：44.61秒
# 题目信息

# Yet Another Monster Fight

## 题目描述

小V遇到了 $ n $ 个怪物排成一排，每一个怪物的血量为 $ a_i $ 。小V决定用魔法消灭它们。

在施展魔法时，小V会先选择一个怪物所在的位置 $ i $ ，作为这个魔法**直接**攻击的怪物。然后，他会选择魔法的威力 $ x $ 。

然而，这种魔法十分特殊，会以一定顺序攻击这 $ n $ 个怪物，第 $ i $ 个受攻击怪物会受到 $ x-i+1 $ 点的伤害。具体来说，这个魔法每次会随机选择一个与被攻击过的怪物相邻且没有被攻击的怪物作为对象施展一次攻击。

小V对自己的实力很自信，所以他想知道在他能随意选择第一个攻击位置 $ i $ 的情况下，最小要用多少的威力 $ x $ 使得无论魔法沿什么顺序攻击都能杀死所有的怪物。但小V不会这个问题，就把它交给了你。

注：两个怪物视作相邻当且仅当它们之间没有任何其它活着的怪物

## 说明/提示

保证 
 $ 1 \le n \le 3 \cdot 10^5 $ ，且 $ 1 \le a_i \le 10^9 $

## 样例 #1

### 输入

```
6
2 1 5 6 4 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5
4 4 4 4 4```

### 输出

```
8```

## 样例 #3

### 输入

```
2
1 1000000000```

### 输出

```
1000000000```

# AI分析结果

### 题目内容重写
小V遇到了 $ n $ 个怪物排成一排，每一个怪物的血量为 $ a_i $ 。小V决定用魔法消灭它们。

在施展魔法时，小V会先选择一个怪物所在的位置 $ i $ ，作为这个魔法**直接**攻击的怪物。然后，他会选择魔法的威力 $ x $ 。

然而，这种魔法十分特殊，会以一定顺序攻击这 $ n $ 个怪物，第 $ i $ 个受攻击怪物会受到 $ x-i+1 $ 点的伤害。具体来说，这个魔法每次会随机选择一个与被攻击过的怪物相邻且没有被攻击的怪物作为对象施展一次攻击。

小V对自己的实力很自信，所以他想知道在他能随意选择第一个攻击位置 $ i $ 的情况下，最小要用多少的威力 $ x $ 使得无论魔法沿什么顺序攻击都能杀死所有的怪物。但小V不会这个问题，就把它交给了你。

注：两个怪物视作相邻当且仅当它们之间没有任何其它活着的怪物

### 算法分类
贪心、二分、前缀和

### 题解分析与结论
本题的核心在于如何确定最小的魔法威力 $ x $，使得无论魔法攻击顺序如何，都能消灭所有怪物。题解主要分为两类思路：

1. **贪心+前缀和**：通过预处理前缀和后缀的最大值，枚举每个可能的起始位置，计算最坏情况下所需的 $ x $，并取最小值。这种方法的时间复杂度为 $ O(n) $，适合大规模数据。
2. **二分答案**：通过二分查找确定最小的 $ x $，并在每次检查时判断是否存在一个起始位置满足所有怪物的攻击条件。这种方法的时间复杂度为 $ O(n \log n) $，适合对时间复杂度要求不高的场景。

### 高星题解推荐

#### 题解1：2huk (5星)
**关键亮点**：
- 通过预处理前缀和后缀的最大值，高效计算每个起始位置所需的最小 $ x $。
- 代码简洁，逻辑清晰，时间复杂度为 $ O(n) $，适合大规模数据。

**核心代码**：
```cpp
int n, a[N]; 
int x[N], y[N], res = INF;

signed main()
{
	n = read();
	
	fup (i, 1, n) a[i] = read();
	fup (i, 1, n) x[i] = Max(x[i - 1], a[i] + n - i);
	fdw (i, n, 1) y[i] = Max(y[i + 1], a[i] + i - 1);
	
	fup (i, 1, n)
	{
		// 第一个目标为 i
		res = Min(res, Max(a[i], Max(x[i - 1], y[i + 1]))); 
	}
	
	wel(res);
	
	return 0;
}
```

#### 题解2：Crazyouth (4星)
**关键亮点**：
- 采用二分答案的思路，通过检查函数判断是否存在满足条件的起始位置。
- 代码实现简单，适合对时间复杂度要求不高的场景。

**核心代码**：
```cpp
int check(int x){
	int l=0,r=n;
	for(int i=1;i<=n;i++){
		if(x-a[i]+1<i) l=i;
		if(x-a[i]+1<n-i+1) r=min(r,i);
	}
	if(l<=r) return 1;
	return 0;
}
```

#### 题解3：wuyin331 (4星)
**关键亮点**：
- 通过前缀和和后缀和的预处理，快速计算每个起始位置所需的最小 $ x $。
- 代码简洁，逻辑清晰，适合大规模数据。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) pre[i]=max(pre[i-1],nums[i]+n-i);
for(int i=n;i>=1;i--) lst[i]=max(lst[i+1],nums[i]+i-1);
int ans=0x3f3f3f3f;
for(int i=1;i<=n;i++){
	ans=min(ans,max(max(pre[i-1],lst[i+1]),nums[i]));
}
```

### 关键思路与技巧
- **前缀和与后缀和**：通过预处理前缀和后缀的最大值，快速计算每个起始位置所需的最小 $ x $。
- **二分答案**：通过二分查找确定最小的 $ x $，并在每次检查时判断是否存在一个起始位置满足所有怪物的攻击条件。

### 拓展与举一反三
- 类似题目：P1901 [NOI2010] 能量采集、P1886 滑动窗口、P2216 [HAOI2007] 理想的正方形

### 推荐题目
1. P1901 [NOI2010] 能量采集
2. P1886 滑动窗口
3. P2216 [HAOI2007] 理想的正方形

---
处理用时：38.78秒
# 题目信息

# Building Forest

## 题目描述

### 题意翻译
一个有向加权森林是无环有向加权图，其中每个顶点至多有一条边。有向加权森林中，顶点 $ v $ 的根是一个没有出边的顶点，并且可以通过沿着加权有向森林的边从顶点 $ v $ 到达。现将顶点 $ v $ 的根记为 $ root(v) $。顶点v的深度是从顶点 $ v $ 到其根的路径的权重之和。现将顶点 $ v $ 的深度表示为 $ depth(v) $。

构建加权定向森林的过程如下：最初，森林不包含顶点。顶点按顺序逐个添加。总体而言，有 $ n $ 个执行的加法操作。

第 $ i（i>0）$个 操作由一组数字 （$ k $,$ v1 $，$ x1 $，$ v2 $， $ x2 $， ... $ vk $，$ xk $） 描述，意味着我们应该将顶点 $ i $ 下的边 $ k $ 添加到图中。

从顶点 $root( v_1 )$ 到顶点$ i $的边，权重为 $depth( v_1 ) + x_1 $；从顶点 $root( v2 )$ 到顶点$ i $的边，权重为 $ depth( v2 ) +  x2 $ ，以此类推。如果 $ k=0 $，那么图中只增加了顶点 $ i $ ，没有增加任何边。

现给定添加的顶点，请计算森林所有边的权重之和。由于数据可能很大，请将输出的数据模 $1000000007$ $（10^9 + 7）$。

## 样例 #1

### 输入

```
6
0
0
1 2 1
2 1 5 2 2
1 1 2
1 3 4
```

### 输出

```
30
```

## 样例 #2

### 输入

```
5
0
1 1 5
0
0
2 3 1 4 3
```

### 输出

```
9
```

# AI分析结果

### 题目内容
# 构建森林

## 题目描述

### 题意翻译
一个有向加权森林是无环有向加权图，其中每个顶点至多有一条出边。在有向加权森林中，顶点 $v$ 的根是一个没有出边的顶点，并且可以通过沿着加权有向森林的边从顶点 $v$ 到达。现将顶点 $v$ 的根记为 $root(v)$ 。顶点 $v$ 的深度是从顶点 $v$ 到其根的路径的权重之和。现将顶点 $v$ 的深度表示为 $depth(v)$ 。

构建加权定向森林的过程如下：最初，森林不包含顶点。顶点按顺序逐个添加。总体而言，有 $n$ 个执行的加法操作。

第 $i（i>0）$ 个操作由一组数字 （$k$,$v1$，$x1$，$v2$， $x2$，... $vk$，$xk$） 描述，意味着我们应该将顶点 $i$ 下的边 $k$ 添加到图中。

从顶点 $root( v_1 )$ 到顶点 $i$ 的边，权重为 $depth( v_1 ) + x_1$；从顶点 $root( v2 )$ 到顶点 $i$ 的边，权重为 $ depth( v2 ) +  x2$ ，以此类推。如果 $k = 0$，那么图中只增加了顶点 $i$ ，没有增加任何边。

现给定添加的顶点，请计算森林所有边的权重之和。由于数据可能很大，请将输出的数据模 $1000000007$（$10^9 + 7$）。

## 样例 #1

### 输入

```
6
0
0
1 2 1
2 1 5 2 2
1 1 2
1 3 4
```

### 输出

```
30
```

## 样例 #2

### 输入

```
5
0
1 1 5
0
0
2 3 1 4 3
```

### 输出

```
9
```

### 算法分类
并查集

### 题解综合分析与结论
当前仅提供一篇题解，该题解思路明确，利用带权并查集解决问题。通过并查集维护每个顶点到根节点的路径长度以及边的权重，在添加边时，利用并查集的查找和合并操作更新相关信息，最后累加所有边的权重得到结果。

### 所选的题解
 - **星级**：3星
 - **关键亮点**：将问题转化为带权并查集问题，利用并查集的特性维护顶点与根节点的关系及边权。
 - **重点代码及核心实现思想**：
```cpp
LL find(LL x){
    if(fa[x]==x) return x;
    LL t=find(fa[x]);
    hei[x]=(hei[fa[x]]+hei2[x])%md;
    fa[x]=t;
    return fa[x];
}
int main(){
    LL i,j,k,v,x,f1;
    scanf("%I64d",&n);
    for(i=1;i<=n;i++)
        fa[i]=i;
    for(i=1;i<=n;i++){
        scanf("%I64d",&k);
        for(j=1;j<=k;j++){
            scanf("%I64d%I64d",&v,&x);
            f1=find(v);
            if(f1==i) continue;
            fa[f1]=i;
            hei2[f1]=(x+hei[v])%md;
        }
    }
    for(i=1;i<=n;i++)
        ans=(ans+hei2[i]+md)%md;
    printf("%I64d",ans);
    return 0;
}
```
核心实现思想为：`find` 函数用于路径压缩并更新顶点到根节点的路径长度。在 `main` 函数中，初始化并查集后，按顺序处理每个顶点的添加操作，通过 `find` 函数找到相关顶点的根节点，若根节点不是当前顶点则进行合并，并更新边权。最后累加所有边权得到结果。

### 通用建议与扩展思路
对于此类问题，理解题目中顶点与边的关系以及操作过程是关键。可进一步熟悉并查集的原理和应用场景，如在处理连通性问题、动态维护集合关系等方面的应用。同类型题通常围绕图的构建与边权计算，类似算法套路包括使用并查集维护图的连通分量、结合路径压缩和按秩合并优化并查集操作等。

### 洛谷相似题目推荐
 - [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
 - [P1197 [JSOI2008] 星球大战](https://www.luogu.com.cn/problem/P1197)
 - [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)

---
处理用时：46.18秒
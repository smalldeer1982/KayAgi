# 题目信息

# Kevin and Binary String (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本的区别在于此版本中字符串 $ t $ 仅由 '0' 和 '1' 组成。只有当您解决了该问题的所有版本后才能进行 hack。

Kevin 有一个长度为 $ n $ 的二进制字符串 $ s $。Kevin 可以执行以下操作：

- 选择 $ s $ 中两个相邻的块并交换它们。

块是指由相同字符组成的最大子串$ ^{\text{∗}} $。形式化定义：设 $ s[l,r] $ 为子串 $ s_l s_{l+1} \ldots s_r $。当满足以下条件时，$ s[l,r] $ 构成一个块：
1. $ l=1 $ 或 $ s_l \neq s_{l-1} $；
2. $ s_l = s_{l+1} = \ldots = s_r $；
3. $ r=n $ 或 $ s_r \neq s_{r+1} $。

相邻块是指两个块 $ s[l_1,r_1] $ 和 $ s[l_2,r_2] $ 满足 $ r_1 + 1 = l_2 $。

例如，若 $ s = \mathtt{000}\,\mathbf{11}\,\mathbf{00}\,\mathtt{111} $，Kevin 可以选择块 $ s[4,5] $ 和 $ s[6,7] $ 进行交换，将 $ s $ 变为 $ \mathtt{000}\,\mathbf{00}\,\mathbf{11}\,\mathtt{111} $。

给定一个由 '0'、'1' 和 '?' 组成且长度为 $ n $ 的字符串 $ t $，Kevin 希望确定使对于所有索引 $ i $（$ 1 \le i \le n $），若 $ t_i \neq $ '?' 则 $ s_i = t_i $ 所需的最小操作次数。若无法实现，输出 $ -1 $。

$ ^{\text{∗}} $ 若字符串 $ a $ 可通过从 $ b $ 的开头和结尾删除若干（可能为零或全部）字符得到，则称 $ a $ 是 $ b $ 的子串。

## 说明/提示

第一个测试用例的可能操作方式已在题目描述中展示。

第二个测试用例中，一种可能的操作方式为：
1. 交换块 $ [2, 2] $ 和 $ [3, 3] $，$ s $ 变为 $ \mathtt{001101} $；
2. 交换块 $ [3, 4] $ 和 $ [5, 5] $，$ s $ 变为 $ \mathtt{000111} $；
3. 交换块 $ [1, 3] $ 和 $ [4, 6] $，$ s $ 变为 $ \mathtt{111000} $。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
0001100111
0000011111
010101
111000
0101
0110
0101
1010
011001
001110
0
1```

### 输出

```
1
3
1
-1
-1
-1```

# AI分析结果

### 题目内容重写

#### Kevin 和二进制字符串（简单版）

**题目描述**

这是该问题的简单版本。两个版本的区别在于此版本中字符串 $ t $ 仅由 '0' 和 '1' 组成。只有当您解决了该问题的所有版本后才能进行 hack。

Kevin 有一个长度为 $ n $ 的二进制字符串 $ s $。Kevin 可以执行以下操作：

- 选择 $ s $ 中两个相邻的块并交换它们。

块是指由相同字符组成的最大子串$ ^{\text{∗}} $。形式化定义：设 $ s[l,r] $ 为子串 $ s_l s_{l+1} \ldots s_r $。当满足以下条件时，$ s[l,r] $ 构成一个块：
1. $ l=1 $ 或 $ s_l \neq s_{l-1} $；
2. $ s_l = s_{l+1} = \ldots = s_r $；
3. $ r=n $ 或 $ s_r \neq s_{r+1} $。

相邻块是指两个块 $ s[l_1,r_1] $ 和 $ s[l_2,r_2] $ 满足 $ r_1 + 1 = l_2 $。

例如，若 $ s = \mathtt{000}\,\mathbf{11}\,\mathbf{00}\,\mathtt{111} $，Kevin 可以选择块 $ s[4,5] $ 和 $ s[6,7] $ 进行交换，将 $ s $ 变为 $ \mathtt{000}\,\mathbf{00}\,\mathbf{11}\,\mathtt{111} $。

给定一个由 '0'、'1' 和 '?' 组成且长度为 $ n $ 的字符串 $ t $，Kevin 希望确定使对于所有索引 $ i $（$ 1 \le i \le n $），若 $ t_i \neq $ '?' 则 $ s_i = t_i $ 所需的最小操作次数。若无法实现，输出 $ -1 $。

$ ^{\text{∗}} $ 若字符串 $ a $ 可通过从 $ b $ 的开头和结尾删除若干（可能为零或全部）字符得到，则称 $ a $ 是 $ b $ 的子串。

**说明/提示**

第一个测试用例的可能操作方式已在题目描述中展示。

第二个测试用例中，一种可能的操作方式为：
1. 交换块 $ [2, 2] $ 和 $ [3, 3] $，$ s $ 变为 $ \mathtt{001101} $；
2. 交换块 $ [3, 4] $ 和 $ [5, 5] $，$ s $ 变为 $ \mathtt{000111} $；
3. 交换块 $ [1, 3] $ 和 $ [4, 6] $，$ s $ 变为 $ \mathtt{111000} $。

**样例 #1**

**输入**

```
6
0001100111
0000011111
010101
111000
0101
0110
0101
1010
011001
001110
0
1```

**输出**

```
1
3
1
-1
-1
-1```

### 算法分类

字符串、模拟

### 题解分析与结论

**题解1：Iniaugoty**

**星级：4**

**关键亮点：**
1. 核心性质分析：连续段长度只会不断变长，操作本质上是唯一的。
2. 增量法模拟：通过逐步处理每个字符，确保每一步都符合要求。
3. 无解条件判断：在保证前序字符不变的情况下，若当前字符无法改变则无解。
4. 时间复杂度优化：均摊线性时间复杂度，代码实现简洁高效。

**个人心得：**
- 通过增量法逐步处理字符，确保每一步都符合要求，避免了复杂的全局处理。
- 无解条件的判断是关键，确保了算法的正确性。

**核心代码实现思想：**
- 通过遍历字符串，逐步处理每个字符，确保每一步都符合要求。
- 若当前字符无法改变，则直接判断无解。
- 通过交换操作，将字符移动到正确的位置。

**核心代码片段：**
```cpp
int solve(string s, string t) {
    int n = s.size();
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (t[i] == '?') continue;
        if (s[i] == t[i]) continue;
        if (i > 0 && s[i-1] == t[i-1] && s[i-1] == '0') return -1;
        int j = i;
        while (j < n && t[j] == t[i]) ++j;
        int cnt = j - i;
        int k = i;
        int one_cnt = 0;
        while (k < n && one_cnt < cnt) {
            if (s[k] == '1') ++one_cnt;
            ++k;
        }
        if (one_cnt < cnt) return -1;
        if (k < n && s[k] == '1') return -1;
        ans += one_cnt;
        for (int l = i; l < j; ++l) s[l] = t[i];
        for (int l = j; l < k; ++l) s[l] = '0';
    }
    return ans;
}
```

### 最优关键思路或技巧

1. **增量法模拟**：通过逐步处理每个字符，确保每一步都符合要求，避免了复杂的全局处理。
2. **无解条件判断**：在保证前序字符不变的情况下，若当前字符无法改变则无解。
3. **时间复杂度优化**：均摊线性时间复杂度，代码实现简洁高效。

### 可拓展之处

- 类似的问题可以通过增量法逐步处理，确保每一步都符合要求。
- 无解条件的判断是关键，确保了算法的正确性。

### 推荐题目

1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---
处理用时：51.33秒
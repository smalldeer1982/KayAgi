# 题目信息

# The Game (Easy Version)

## 题目描述

这是该问题的简单版本。与困难版本的区别在于，此版本只需找到 Cirno 可能选择的一个可行节点即可获胜。仅当解决所有版本的问题时方可进行 hack。

Cirno 和 Daiyousei 正在玩一个以节点 $1$ 为根的 $n$ 节点树 $^{\text{∗}}$ 游戏，其中第 $i$ 个节点的权值为 $w_i$。她们轮流行动，Cirno 先手。

每一轮中，假设对手在上轮选择了节点 $j$，当前玩家必须选择一个未被删除的节点 $i$ 满足 $w_i > w_j$，并删除节点 $i$ 的子树 $^{\text{†}}$。特别地，在第一轮中 Cirno 可以选择任意节点并删除其子树。

无法操作的玩家获胜，双方都希望自己获胜。请找出 Cirno 在第一轮可能选择的任意一个节点，使得在双方都采取最优策略时她能获胜。

$^{\text{∗}}$ 树是一个无环的连通图。

$^{\text{†}}$ 若从根节点 $1$ 到节点 $u$ 的所有路径都必须经过节点 $i$，则称节点 $u$ 属于节点 $i$ 的子树。

## 说明/提示

第一个测试用例：
1. 若 Cirno 在第一轮选择节点 $1$ 或 $3$，Daiyousei 无法操作，因此 Daiyousei 获胜。
2. 若 Cirno 在第一轮选择节点 $2$ 或 $4$，Daiyousei 只能选择节点 $3$，操作后 Cirno 无法行动，因此 Cirno 获胜。

因此 Cirno 可能选择的节点为 $2$ 和 $4$。

第二个测试用例中，无论 Cirno 选择哪个节点，Daiyousei 都无法操作，因此 Daiyousei 获胜。

第三和第四个测试用例中，Cirno 唯一可能选择的节点是 $2$。

第五个测试用例中，Cirno 可能选择的节点为 $3,4,6,7$ 和 $10$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
4
2 2 4 3
1 2
1 3
2 4
5
1 2 3 4 5
1 2
2 3
3 4
4 5
3
1 2 3
1 2
1 3
5
3 1 3 4 5
1 2
2 3
3 4
4 5
10
1 2 3 2 4 3 3 4 4 3
1 4
4 6
7 4
6 9
6 5
7 8
1 2
2 3
2 10```

### 输出

```
2
0
2
2
10```

# AI分析结果

### 题目内容重写

#### The Game (Easy Version)

**题目描述**

这是该问题的简单版本。与困难版本的区别在于，此版本只需找到 Cirno 可能选择的一个可行节点即可获胜。仅当解决所有版本的问题时方可进行 hack。

Cirno 和 Daiyousei 正在玩一个以节点 $1$ 为根的 $n$ 节点树游戏，其中第 $i$ 个节点的权值为 $w_i$。她们轮流行动，Cirno 先手。

每一轮中，假设对手在上轮选择了节点 $j$，当前玩家必须选择一个未被删除的节点 $i$ 满足 $w_i > w_j$，并删除节点 $i$ 的子树。特别地，在第一轮中 Cirno 可以选择任意节点并删除其子树。

无法操作的玩家获胜，双方都希望自己获胜。请找出 Cirno 在第一轮可能选择的任意一个节点，使得在双方都采取最优策略时她能获胜。

**说明/提示**

第一个测试用例：
1. 若 Cirno 在第一轮选择节点 $1$ 或 $3$，Daiyousei 无法操作，因此 Daiyousei 获胜。
2. 若 Cirno 在第一轮选择节点 $2$ 或 $4$，Daiyousei 只能选择节点 $3$，操作后 Cirno 无法行动，因此 Cirno 获胜。

因此 Cirno 可能选择的节点为 $2$ 和 $4$。

第二个测试用例中，无论 Cirno 选择哪个节点，Daiyousei 都无法操作，因此 Daiyousei 获胜。

第三和第四个测试用例中，Cirno 唯一可能选择的节点是 $2$。

第五个测试用例中，Cirno 可能选择的节点为 $3,4,6,7$ 和 $10$。

**样例 #1**

**输入**

```
5
4
2 2 4 3
1 2
1 3
2 4
5
1 2 3 4 5
1 2
2 3
3 4
4 5
3
1 2 3
1 2
1 3
5
3 1 3 4 5
1 2
2 3
3 4
4 5
10
1 2 3 2 4 3 3 4 4 3
1 4
4 6
7 4
6 9
6 5
7 8
1 2
2 3
2 10
```

**输出**

```
2
0
2
2
10
```

### 算法分类
深度优先搜索 DFS、树状数组

### 题解分析与结论

本题的核心逻辑是找到 Cirno 在第一轮可以选择的一个节点，使得在双方都采取最优策略时她能获胜。关键在于判断选择一个节点后，对手是否无法进行操作。多个题解都采用了 DFS 遍历树，并结合树状数组或线段树来维护节点的权值信息，从而快速判断某个节点的子树外是否存在权值更大的节点。

### 所选高分题解

#### 题解作者：liyifan202201 (4星)

**关键亮点**：
- 使用 DFS 遍历树，记录每个节点的子树范围。
- 使用线段树维护节点的权值信息，快速查询子树外的最大值。
- 通过比较子树外的最大值与当前节点的权值，判断该节点是否为可行选择。

**核心代码**：
```cpp
void dfs(int x,int fa){
    in[x]=++T; // 记录进入节点的时间
    id[T]=x;   // 记录进入时间对应的节点编号
    for(auto y:g[x]){ // 遍历邻接节点
        if(y==fa) continue; // 如果是父节点，跳过
        dfs(y,x); // 递归DFS
    }
    out[x]=T; // 记录退出节点的时间
}

int query(int L,int R,int ro=1,int l=1,int r=n){
    if(L>R) return 0; // 无效查询，返回0
    if(L<=l and r<=R) // 当前区间完全包含在查询区间内
        return tr[ro];
    int maxn=0;
    if(L<=mid){
        maxn=query(L,R,lr,l,mid); // 查询左子树
    }
    if(R>mid){
        maxn=max(maxn,query(L,R,rr,mid+1,r)); // 查询右子树，取最大值
    }
    return maxn;
}
```

#### 题解作者：_Kenma_ (4星)

**关键亮点**：
- 使用树状数组记录不同权值点的出现次数。
- 在 DFS 过程中通过差分判断某个节点的子树外是否存在权值更大的节点。
- 通过反证法证明选择的节点是否满足条件。

**核心代码**：
```cpp
void dfs(int x,int fa){
    int now=query(n)-query(a[x]);
    modify(a[x],1);
    for(int i=head[x];i;i=nxt[i]){
        int y=target[i];
        if(y==fa) continue;
        dfs(y,x); 
    }
    if(b[x]==query(n)-query(a[x])-now) b[x]=0;
    else b[x]=1;
}
```

#### 题解作者：dayz_break404 (4星)

**关键亮点**：
- 使用 DFS 遍历树，记录每个节点的子树范围。
- 使用 ST 表维护节点的权值信息，快速查询子树外的最大值。
- 通过比较子树外的最大值与当前节点的权值，判断该节点是否为可行选择。

**核心代码**：
```cpp
void dfs(int u,int fa){
    dfn[u]=++tot,siz[u]=1;
    for(int v:e[u]){
        if(v==fa) continue;
        dfs(v,u);
        siz[u]+=siz[v];
    }
}

int check(int x){
    int now=rec[x].id,lim=max(S.ask(1,dfn[now]-1),S.ask(dfn[now]+siz[now],n));
    return lim>rec[x].val;
}
```

### 最优关键思路或技巧
- **DFS 遍历树**：通过 DFS 遍历树，记录每个节点的子树范围，便于后续查询。
- **树状数组/线段树**：使用树状数组或线段树维护节点的权值信息，快速查询子树外的最大值。
- **反证法**：通过反证法证明选择的节点是否满足条件，确保选择的节点是可行的。

### 可拓展之处
- **类似题目**：可以扩展到其他需要判断子树外信息的树形结构问题，如子树外的最小值、子树外的和等。
- **数据结构优化**：可以使用其他数据结构如 ST 表、BIT 等来优化查询效率。

### 推荐洛谷题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

---
处理用时：56.36秒
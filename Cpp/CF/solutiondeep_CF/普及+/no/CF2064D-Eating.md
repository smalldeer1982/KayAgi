# 题目信息

# Eating

## 题目描述

有 $n$ 个史莱姆排成一行，第 $i$ 个史莱姆的体重为 $w_i$。当史莱姆 $i$ 满足 $w_i \geq w_j$ 时，它可以吃掉史莱姆 $j$；之后，史莱姆 $j$ 会消失，史莱姆 $i$ 的体重将变为 $w_i \oplus w_j$ $^{\text{∗}}$。

史莱姆国王希望进行一个参数为 $x$ 的实验，步骤如下：
- 在行的最右端（第 $n$ 个史莱姆之后）新增一个体重为 $x$ 的史莱姆。
- 这个新史莱姆会不断尝试吃掉左侧相邻的史莱姆（如果可能的话），并移动到被吃掉的史莱姆的位置。当左侧没有史莱姆或其左侧史莱姆的体重大于自身时，该过程停止。（此过程中不会有其他史莱姆被吃掉）
- 该实验的得分为被吃掉的史莱姆总数。

史莱姆国王将向你提出 $q$ 次询问。每次询问给定一个整数 $x$，你需要计算以该参数进行实验的得分。

注意这些询问是假设性的，并不会实际改变史莱姆的初始状态（即查询是非持久化的）。

 $^{\text{∗}}$ 此处 $\oplus$ 表示[按位异或运算](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

## 说明/提示

第二个测试用例的第一个查询：
- 新增体重为 $8$ 的史莱姆后，数组变为 $[1, 5, 4, 11, \color{red}8]$。
- 新增史莱姆体重小于左侧史莱姆，无法吃掉，最终得分为 $0$。

第二个测试用例的第二个查询：
- 新增体重为 $13$ 的史莱姆后，数组变为 $[1, 5, 4, 11, \color{red}{13}]$。
- 新增史莱姆吃掉左侧史莱姆，体重变为 $13 \oplus 11 = 6$，数组变为 $[1, 5, 4, \color{red}{6}]$。
- 新增史莱姆继续吃掉左侧史莱姆，体重变为 $6 \oplus 4 = 2$，数组变为 $[1, 5, \color{red}{2}]$。
- 此时无法继续吃掉左侧史莱姆，最终得分为 $2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
1 1
5
6
4 4
1 5 4 11
8
13
16
15
10 9
10 4 3 9 7 4 6 1 9 4
2
6
5
6
9
8
6
2
7```

### 输出

```
1
0 2 4 2
0 1 1 1 3 3 1 0 1```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $n$ 个史莱姆排成一行，第 $i$ 个史莱姆的体重为 $w_i$。当史莱姆 $i$ 满足 $w_i \geq w_j$ 时，它可以吃掉史莱姆 $j$；之后，史莱姆 $j$ 会消失，史莱姆 $i$ 的体重将变为 $w_i \oplus w_j$ $^{\text{∗}}$。

史莱姆国王希望进行一个参数为 $x$ 的实验，步骤如下：
- 在行的最右端（第 $n$ 个史莱姆之后）新增一个体重为 $x$ 的史莱姆。
- 这个新史莱姆会不断尝试吃掉左侧相邻的史莱姆（如果可能的话），并移动到被吃掉的史莱姆的位置。当左侧没有史莱姆或其左侧史莱姆的体重大于自身时，该过程停止。（此过程中不会有其他史莱姆被吃掉）
- 该实验的得分为被吃掉的史莱姆总数。

史莱姆国王将向你提出 $q$ 次询问。每次询问给定一个整数 $x$，你需要计算以该参数进行实验的得分。

注意这些询问是假设性的，并不会实际改变史莱姆的初始状态（即查询是非持久化的）。

 $^{\text{∗}}$ 此处 $\oplus$ 表示[按位异或运算](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

#### 说明/提示

第二个测试用例的第一个查询：
- 新增体重为 $8$ 的史莱姆后，数组变为 $[1, 5, 4, 11, \color{red}8]$。
- 新增史莱姆体重小于左侧史莱姆，无法吃掉，最终得分为 $0$。

第二个测试用例的第二个查询：
- 新增体重为 $13$ 的史莱姆后，数组变为 $[1, 5, 4, 11, \color{red}{13}]$。
- 新增史莱姆吃掉左侧史莱姆，体重变为 $13 \oplus 11 = 6$，数组变为 $[1, 5, 4, \color{red}{6}]$。
- 新增史莱姆继续吃掉左侧史莱姆，体重变为 $6 \oplus 4 = 2$，数组变为 $[1, 5, \color{red}{2}]$。
- 此时无法继续吃掉左侧史莱姆，最终得分为 $2$。

### 算法分类
位运算

### 题解分析与结论

#### 题解1：chenxi2009（4星）
- **关键亮点**：通过按位分讨，从高位到低位、从右往左跳，利用 `__lg(x)` 函数快速找到最高位，预处理每个位置的最高位信息，优化了查询效率。
- **核心思想**：从高位到低位逐位处理，利用前缀异或和快速计算异或结果，通过预处理数组快速找到符合条件的史莱姆位置。
- **代码实现**：
  ```cpp
  for(int j = 30;~j;j --){
      if(x < 1 << j) continue;
      nxt = pre[now][j];
      x ^= s[now] ^ s[nxt],now = nxt;
      if(!now || w[now] > x) break;
      x ^= w[now --];
  }
  ```

#### 题解2：Engulf（4星）
- **关键亮点**：通过 `msb(x)` 函数判断最高位，预处理 `lef[i][j]` 数组，优化了查询过程，减少了不必要的计算。
- **核心思想**：利用最高位判断史莱姆能否被吃掉，通过预处理数组快速找到符合条件的史莱姆位置，减少了查询的复杂度。
- **代码实现**：
  ```cpp
  if(msb(a[cur]) < msb(x)) {
      x ^= pre[cur] ^ pre[lef[cur][msb(x)] - 1];
      cur = lef[cur][msb(x)] - 1;
  } else {
      x ^= a[cur];
      cur--;
  }
  ```

#### 题解3：Mr_Az（4星）
- **关键亮点**：通过预处理 `nxt[i][j]` 数组，快速找到符合条件的史莱姆位置，利用前缀异或和优化查询效率。
- **核心思想**：从高位到低位逐位处理，利用前缀异或和快速计算异或结果，通过预处理数组快速找到符合条件的史莱姆位置。
- **代码实现**：
  ```cpp
  while(now>=1&&x>0){
      int pos=nxt[now][__lg(x)];
      if(pos==0){now=0;break;}
      x^=get(pos+1,now);
      now=pos;
      if(x<a[pos]) break;
      x^=a[pos];
      now--;
  }
  ```

### 最优关键思路与技巧
- **按位处理**：从高位到低位逐位处理，利用最高位判断史莱姆能否被吃掉。
- **预处理数组**：通过预处理数组快速找到符合条件的史莱姆位置，减少查询的复杂度。
- **前缀异或和**：利用前缀异或和快速计算异或结果，优化查询效率。

### 可拓展之处
- **类似问题**：可以扩展到其他位运算相关的题目，如按位与、按位或等操作。
- **预处理技巧**：预处理数组的技巧可以应用到其他需要快速查询的题目中，如区间查询、动态规划等。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

---
处理用时：45.82秒
# 题目信息

# Military Trainings

## 题目描述

ABBYY 的聪明海狸开始与国防部合作。现在他们正在训练士兵行动装甲车队。训练包括测试一种能够传输信息的新型坦克。为了测试这种新型坦克，训练中有一个特殊的演习，其核心如下所述。

最初，车队由从 $1$ 到 $n$ 依次编号的 $n$ 辆坦克组成，按照从车队起始位置到结束位置的顺序排列。在整个演习过程中，必须准确传递 $n$ 条信息，从车队的起始位置传递到结束位置。

传递一条信息的过程如下：车队中排在第一位的坦克将信息传递给车队中的某辆坦克。接收到信息的坦克将其继续传递给车队中的下一辆坦克。这个过程一直持续到最后一辆坦克接收到信息。车队中并不是所有的坦克都会接收到信息，但最重要的是确保最后一辆坦克能够接收到信息。

当最后一辆坦克（坦克编号为 $n$）接收到信息后，它将移动到车队的起始位置，并以相同的方式将另一条信息发送到车队的末尾。当信息到达最后一辆坦克（坦克编号为 $n-1$）时，该坦克将移动到车队的起始位置，并将下一条信息发送到车队的末尾，以此类推。因此，当车队中的坦克恢复到它们的原始顺序时，即在坦克编号 $1$ 移动到车队起始位置后，演习就完成了。

如果初始时坦克按照顺序 $1, 2, ..., n$ 排列在车队中，那么在第一条信息传递后，它们的顺序变为 $2, 1, ..., n-1, n$。在第二条信息传递后，顺序变为 $n, 2, 1, ..., n-2, n-1$。以此类推，每传递一条信息，坦克的顺序都会发生变化。

这些坦克的构造方式非常独特。编号为 $i$ 的坦克具有一个整数 $a_i$，被称为该坦克的信息接收半径。

在两辆坦克之间传递一条信息需要一秒钟，然而，并不总是一辆坦克能够将信息传递给另一辆坦克。假设车队中有两辆坦克，第一辆坦克是从起始位置开始计算的第 $i$ 辆坦克，第二辆坦克是车队中的第 $j$ 辆坦克，并且假设第二辆坦克的编号是 $x$。那么，如果 $i < j$ 并且 $j - a_x \le i$，那么第一辆坦克可以将信息传递给第二辆坦克。

国防部（以及很快轮到智能海狸）面临如何高效组织训练的问题。演习应尽快完成。我们将忽略坦克在列队移动所花费的时间，因为提高坦克的速度不是这次训练的重点。

你已获得坦克的数量以及所有坦克的信息接收半径。您必须帮助智能海狸，以尽可能减少所有信息的总传输时间的方式组织信息的传递。

### **简明题意**

对于一个 $1, 2,...,n$ 的排列，每个数有一个半径 $a_i$。每次从开头发射信号，传到末尾， 并将末尾移到队头。这样操作 $n$ 次。每次传递耗时 $1$ 秒。求总耗时最小的方案。

## 样例 #1

### 输入

```
3
2
1
1
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
2
2
2
2
2
```

### 输出

```
10
```

# AI分析结果

### 题目内容
# Military Trainings

## 题目描述
ABBYY的聪明海狸开始与国防部合作。现在他们正在训练士兵行动装甲车队。训练包括测试一种能够传输信息的新型坦克。为了测试这种新型坦克，训练中有一个特殊的演习，其核心如下所述。

最初，车队由从1到n依次编号的n辆坦克组成，按照从车队起始位置到结束位置的顺序排列。在整个演习过程中，必须准确传递n条信息，从车队的起始位置传递到结束位置。

传递一条信息的过程如下：车队中排在第一位的坦克将信息传递给车队中的某辆坦克。接收到信息的坦克将其继续传递给车队中的下一辆坦克。这个过程一直持续到最后一辆坦克接收到信息。车队中并不是所有的坦克都会接收到信息，但最重要的是确保最后一辆坦克能够接收到信息。

当最后一辆坦克（坦克编号为n）接收到信息后，它将移动到车队的起始位置，并以相同的方式将另一条信息发送到车队的末尾。当信息到达最后一辆坦克（坦克编号为n - 1）时，该坦克将移动到车队的起始位置，并将下一条信息发送到车队的末尾，以此类推。因此，当车队中的坦克恢复到它们的原始顺序时，即在坦克编号1移动到车队起始位置后，演习就完成了。

如果初始时坦克按照顺序1, 2,..., n排列在车队中，那么在第一条信息传递后，它们的顺序变为2, 1,..., n - 1, n。在第二条信息传递后，顺序变为n, 2, 1,..., n - 2, n - 1。以此类推，每传递一条信息，坦克的顺序都会发生变化。

这些坦克的构造方式非常独特。编号为i的坦克具有一个整数ai，被称为该坦克的信息接收半径。

在两辆坦克之间传递一条信息需要一秒钟，然而，并不总是一辆坦克能够将信息传递给另一辆坦克。假设车队中有两辆坦克，第一辆坦克是从起始位置开始计算的第i辆坦克，第二辆坦克是车队中的第j辆坦克，并且假设第二辆坦克的编号是x。那么，如果i < j并且j - ax ≤ i，那么第一辆坦克可以将信息传递给第二辆坦克。

国防部（以及很快轮到智能海狸）面临如何高效组织训练的问题。演习应尽快完成。我们将忽略坦克在列队移动所花费的时间，因为提高坦克的速度不是这次训练的重点。

你已获得坦克的数量以及所有坦克的信息接收半径。您必须帮助智能海狸，以尽可能减少所有信息的总传输时间的方式组织信息的传递。

### 简明题意
对于一个1, 2,..., n的排列，每个数有一个半径ai。每次从开头发射信号，传到末尾，并将末尾移到队头。这样操作n次。每次传递耗时1秒。求总耗时最小的方案。

## 样例 #1
### 输入
```
3
2
1
1
```
### 输出
```
5
```

## 样例 #2
### 输入
```
5
2
2
2
2
2
```
### 输出
```
10
```

### 算法分类
动态规划

### 综合分析与结论
两篇题解思路本质相同，均采用动态规划求解。
 - **思路**：都通过定义状态 $dp_i$ 表示信息传输至第 $i$ 个坦克时耗费的单位时间，利用状态转移方程从前面已有的状态推导出当前状态的最小耗时。
 - **算法要点**：每次计算 $dp_i$ 时，都要遍历前面的状态 $dp_j$，找到满足条件的最小 $dp_j$ 并加1得到 $dp_i$。总共需要进行 $n$ 次这样的动态规划计算。
 - **解决难点**：如何准确地定义状态和状态转移方程，以正确计算每次信息传递的最小耗时。同时要处理好坦克顺序变化的情况。

### 题解情况
 - **作者Li2021**：
   - **星级**：4星
   - **关键亮点**：提出复制数组模拟环的技巧，能降低代码实现的常数复杂度，提高运行效率。代码使用 `#define` 定义常量，`ios::sync_with_stdio(0)` 加速输入输出，整体代码简洁清晰。
   - **核心代码片段**：
```cpp
#include <iostream>
#include <cstring>
#define inf 0x3f3f3f3f
#define N 200002
using namespace std;
int n,a[N],dp[N],ans=0;
int main(){
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[n+i]=a[i];
    }
    for(int i=1;i<=n;i++){
        memset(dp,0,sizeof dp);
        for(int j=2;j<=n;j++){
            int minn=inf;
            for(int k=max(j-a[j+i-1],1);k<=j-1;k++)  minn=min(minn,dp[k]);
            dp[j]=minn+1;
        }
        ans+=dp[n];
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先将数组复制一份模拟环，然后进行 $n$ 次动态规划计算。每次计算时，先初始化 `dp` 数组，然后对每个位置 `j`，通过遍历前面满足条件的位置 `k`，找到最小的 `dp[k]` 来更新 `dp[j]`，最后累加每次计算得到的 `dp[n]` 作为总耗时。
 - **作者xiaohaoaibiancheng66**：
   - **星级**：3星
   - **关键亮点**：对题目中传递信息的条件进行了变形，使其更直观，便于理解状态转移方程。
   - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[1000000];
int dp[1000000];

int main()
{
    int n;
    cin>>n;
    long long ans=0;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int k=0;k<n;k++)
    {
        //dp
        dp[0]=0;
        for(int i=1;i<n;i++)
        {
            dp[i]=10000000;
            for(int j=max(0,i-a[i]);j<i;j++)
                dp[i]=min(dp[j]+1,dp[i]);

        }
        ans+=dp[n-1];
        //轮换
        for(int i=n;i>0;i--)a[i]=a[i-1];
        a[0]=a[n];
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：直接在原数组上通过循环移动模拟坦克顺序变化，每次进行动态规划计算，从前面满足条件的状态 `dp[j]` 找到最小的来更新 `dp[i]`，最后累加每次得到的 `dp[n - 1]` 作为总耗时。

### 最优关键思路或技巧
 - **状态定义与转移**：准确地定义 `dp` 数组表示信息传输至第 $i$ 个坦克的最小耗时，并根据题目条件得出状态转移方程，这是解决问题的关键。
 - **数组复制模拟环**：Li2021提出的复制数组模拟环的技巧，能简化代码实现，降低常数复杂度。

### 拓展
同类型题通常围绕动态规划的状态定义与转移展开，类似套路是分析题目中的阶段和状态，找到状态之间的递推关系。例如在一些具有顺序性、阶段性且需要求最优解的问题中，可尝试用动态规划解决。

### 洛谷推荐题目
 - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：基础的背包类动态规划问题，与本题类似，都需要定义合适的状态和状态转移方程来求解最优解。
 - [P1280尼克的任务](https://www.luogu.com.cn/problem/P1280)：通过合理定义状态和状态转移方程解决时间安排类的动态规划问题，与本题思路有相似之处。
 - [P1470 [USACO2.3]最长前缀 Longest Prefix](https://www.luogu.com.cn/problem/P1470)：字符串相关的动态规划问题，同样是利用状态转移来求解最优值，锻炼动态规划思维。 

---
处理用时：72.66秒
# 题目信息

# Military Trainings

## 题目描述

### 题目大意
有 $n$ 个坦克，从1到n编号，它们要进行消息传输。

每一次传输如下，列表中第一个坦克将信息传输到列表中的某个坦克。接收到该消息的坦克将其进一步发送到列表后的某个坦克。该过程将继续进行，直到最后一个坦克收到消息。可能不是列表中的所有坦克都会收到消息，但列表中的最后一个坦克必须收到消息。

当最后一个坦克收到消息时，它将挪到第一个位置，并发送一条消息。当信息到达最后一个坦克时，该坦克移动到列的开头，并将下一条信息发送到列表的末尾，依此类推。因此，当列中的坦克返回到其原始顺序时，练习就完成了。

在两个坦克之间传输信息需要一秒钟，然而，并非总是一个坦克可以将信息传输给另一个坦克。让我们考虑列中的两个坦克，使它们中的第一个是从开始计数的列中的第i个，第二个是列中的j个，并假设第二个坦克的编号为x。然后，如果$ i<j $ and $ i>=j-a_{x} $ 则可以传输。

你会得到坦克的数量，以及所有坦克的信息接收半径。您必须帮助Smart Beaver并组织消息传输，使所有消息的总传输时间尽可能短。

## 样例 #1

### 输入

```
3
2
1
1
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
2
2
2
2
2
```

### 输出

```
10
```

# AI分析结果

### 题目内容
# 军事训练

## 题目描述

### 题目大意
有 $n$ 个坦克，从1到n编号，它们要进行消息传输。

每一次传输如下，列表中第一个坦克将信息传输到列表中的某个坦克。接收到该消息的坦克将其进一步发送到列表后的某个坦克。该过程将继续进行，直到最后一个坦克收到消息。可能不是列表中的所有坦克都会收到消息，但列表中的最后一个坦克必须收到消息。

当最后一个坦克收到消息时，它将挪到第一个位置，并发送一条消息。当信息到达最后一个坦克时，该坦克移动到列的开头，并将下一条信息发送到列表的末尾，依此类推。因此，当列中的坦克返回到其原始顺序时，练习就完成了。

在两个坦克之间传输信息需要一秒钟，然而，并非总是一个坦克可以将信息传输给另一个坦克。让我们考虑列中的两个坦克，使它们中的第一个是从开始计数的列中的第i个，第二个是列中的j个，并假设第二个坦克的编号为x。然后，如果$ i<j $ and $ i>=j-a_{x} $ 则可以传输。

你会得到坦克的数量，以及所有坦克的信息接收半径。您必须帮助Smart Beaver并组织消息传输，使所有消息的总传输时间尽可能短。

## 样例 #1

### 输入

```
3
2
1
1
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
2
2
2
2
2
```

### 输出

```
10
```

### 算法分类
贪心

### 综合分析与结论
三道题解思路核心均为通过贪心策略结合ST表、倍增等优化手段来解决问题。它们都意识到正向处理信息传递不易，选择反向思考，并通过破环为链的方式处理环形结构。不同点在于具体优化细节和实现方式。

### 所选的题解
 - **作者：xiaohaoaibiancheng66 (5星)**
    - **关键亮点**：利用倍增优化查找过程，预处理复杂度 $O(n\log n)$，每次查询复杂度 $O(\log n)$，总时间复杂度 $O(n\log n)$，思路清晰，代码实现简洁明了。
    - **重点代码核心实现思想**：通过ST表预处理每个区间内的最优选择，再利用倍增快速查询每次信息传递的路径，从而计算总时间。
    - **核心代码片段**：
```cpp
//ST 表
void init(int n)
{
    Log[0]=Log[1]=0;
    for(int i=2;i<=n;i++)Log[i]=Log[i/2]+1;
}

void Build(int n)
{
    for(int i=0;i<=n;i++)st[i][0]=i;
    for(int j=1;j<=Log[n]+1;j++)
        for(int i=0;i<=n;i++) 
            st[i][j]=((a[st[i][j-1]]<=a[st[i+(1<<(j-1))][j-1]])?st[i][j-1]:st[i+(1<<(j-1))][j-1]);
}

inline int Query(int l,int r)
{
    int t=Log[r-l+1];
    return (a[st[l][t]]<=a[st[r-(1<<t)+1][t]])?st[l][t]:st[r-(1<<t)+1][t];
}

int main()
{
    int n;
    cin>>n;
    init(2*n);
    for(int i=1;i<=n;i++)cin>>a[i],a[i+n]=a[i];
    for(int i=1;i<=n+n;i++)a[i]=max(i-a[i],1);
    Build(2*n);
    //倍增
    for(int i=1;i<=n+n;i++)fa[i][0]=Query(a[i],i);
    for(int j=1;j<30;j++)
        for(int i=1;i<=n+n;i++)
            fa[i][j]=fa[fa[i][j-1]][j-1];
    long long ans=0;

    for(int i=1;i<=n;i++)
    {
        long long cnt=2;
        int now=i+n-1;
        //特判
        if(a[now]<=i)
        {
            ans++;
            continue;
        }
        //查询
        for(int j=29;j>=0;j--)
        {
            if(a[fa[now][j]]>i)cnt+=(1<<j),now=fa[now][j];
        }
        ans+=cnt;
    }
    cout<<ans;
    return 0;
}
```
 - **作者：tder (4星)**
    - **关键亮点**：提出贪心策略，通过证明选择从 $k - p_k$ 较小的 $k$ 转移来不劣，并用ST表维护，最后用倍增优化到 $\mathcal{O}(n\log n)$ 复杂度。
    - **重点代码核心实现思想**：破环为链后，利用ST表维护区间最小值，通过倍增优化查询每次信息传递路径，计算总时间。
    - **核心代码片段**：无（题解未给出完整代码）
 - **作者：aaalys (4星)**
    - **关键亮点**：详细阐述了从反向思考、贪心选择到时间优化的全过程，对ST表在不同阶段的应用解释清晰，代码实现考虑了诸多细节。
    - **重点代码核心实现思想**：通过ST表优化贪心选择下一步和获取答案两个过程，利用破环为链处理环形结构，从而计算总时间。
    - **核心代码片段**：
```cpp
int a[N], lg[N] = {-1};//a数组（修改后为b数组）和求答案用的log2数组
int mn[N][M], f[N][M];//2个st表
int get(int l, int r){//l,r这段区间内最小b[x]的x
    int k = lg[r - l + 1];
    int lid = mn[l][k], rid = mn[r - (1 << k) + 1][k];
    if (a[lid] <= a[rid])return lid;
    return rid;
}
int getans(int x){//获取答案
    int need = x - n + 1, ans = 2;//加了特殊处理，ans初始值要设成2
    if (a[x] <= need)return 1;//特判一步就能到达的情况
    for (int i = lg[2 * n]; i >= 0; i--)
        if (a[f[x][i]] > need){//不一定是nx[now]，可能是b[now]
            x = f[x][i];
            ans += (1 << i);
        }
    return ans;
}
void init(){//初始化第一个st表
    for (int i = 1; i <= 2 * n; i++)a[i] = max(1, i - a[i]);//将a[i]改成b[i]
    for (int i = 1; i <= 2 * n; i++)mn[i][0] = i;//初始化st表
    for (int i = 1; i <= 2 * n; i++)lg[i] = lg[i / 2] + 1;//求log2数组
    for (int j = 1; j <= lg[2 * n]; j++)
        for (int i = 1; i + (1 << j) - 1 <= 2 * n; i++){
            //转移
            int lid = mn[i][j - 1], rid = mn[i + (1 << (j - 1))][j - 1];
            if (a[lid] <= a[rid])mn[i][j] = lid;
            else mn[i][j] = rid;
        }
}
for (int i = 2; i <= 2 * n; i++){
    int fa = get(a[i], i);//nx[i]
    f[i][0] = fa;//初始化
}
for (int j = 1; j <= lg[2 * n]; j++)
    for (int i = 1; i <= 2 * n; i++)
        f[i][j] = f[f[i][j - 1]][j - 1];//转移
ll ans = 0;//记得开long long
for (int i = 0; i < n; i++)//累加答案
    ans += getans(i + n);
```

### 最优关键思路或技巧
1. **反向思考**：正向传递信息坦克编号不连续，反向思考即考虑哪个坦克能传递到当前坦克，使编号连续，便于处理。
2. **贪心策略**：每次传递信息选择能使下一次到达最远的点，即选择 $k - p_k$ 较小的 $k$ 进行转移。
3. **ST表与倍增优化**：利用ST表预处理区间信息，结合倍增优化查询过程，将时间复杂度降低到 $O(n\log n)$。

### 拓展思路
此类题目属于贪心结合数据结构优化的类型，常见于信息传递、路径规划等场景。类似套路是遇到环形结构可破环为链，正向不好处理就尝试反向思考，同时利用数据结构（如ST表、线段树等）优化区间查询操作。

### 推荐洛谷题目
1. [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)：经典ST表模板题，帮助理解ST表的构建与查询。
2. [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)：通过ST表解决区间最小值查询问题，与本题利用ST表维护区间信息思路相似。
3. [P2880 [USACO07MAR]Face The Right Way G](https://www.luogu.com.cn/problem/P2880)：需要通过贪心策略结合优化手段解决问题，锻炼贪心思维。

### 个人心得
 - **aaalys**：强调了实现中的细节，如数组空间要开两倍以处理破环为链后的情况，$b_i$ 要取 $\max (1,i - a_i)$，答案要开 `long long` 类型，以及一些节省代码长度的小技巧，如直接将 $a_i$ 赋值为 $b_i$ 等。这些细节对于正确实现代码至关重要。 

---
处理用时：103.38秒
# 题目信息

# IT Restaurants

## 题目描述

给定一个n，表示有n个节点（1～n）以及接下来n-1条边的树，现用两种颜色（红，蓝）对这颗树的节点染色，染色规则是，每个节点有三种状态，要么染成红色，要么染成蓝色，要么不染色，并且规定用一条边连接的两个节点要么染成颜色相同，要么一个染色一个不染色。问在保证染色节点最多的条件下，红色与蓝色的个数的情况。（要求是至少有一个节点被染成红色，至少一个节点被染成蓝色）。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
3
1 3
2 2
3 1
```

## 样例 #2

### 输入

```
10
1 2
2 3
3 4
5 6
6 7
7 4
8 9
9 10
10 4
```

### 输出

```
6
1 8
2 7
3 6
6 3
7 2
8 1
```

# AI分析结果

### 题目内容
# IT 餐厅

## 题目描述
给定一个整数 \(n\)，表示有 \(n\) 个节点（编号为 \(1\) 到 \(n\)）以及接下来 \(n - 1\) 条边的树。现用红、蓝两种颜色对这棵树的节点染色，染色规则为：每个节点有三种状态，要么染成红色，要么染成蓝色，要么不染色，并且规定用一条边连接的两个节点要么染成相同颜色，要么一个染色一个不染色。问在保证染色节点最多的条件下，红色与蓝色节点个数的所有可能情况。（要求至少有一个节点被染成红色，至少有一个节点被染成蓝色）。

## 样例 #1
### 输入
```
5
1 2
2 3
3 4
4 5
```
### 输出
```
3
1 3
2 2
3 1
```

## 样例 #2
### 输入
```
10
1 2
2 3
3 4
5 6
6 7
7 4
8 9
9 10
10 4
```
### 输出
```
6
1 8
2 7
3 6
6 3
7 2
8 1
```

### 算法分类
动态规划

### 综合分析与结论
所有题解思路基本一致，均先得出为使染色节点最多，仅有一个节点不染色的结论。之后通过枚举不染色节点，利用深度优先搜索（DFS）获取子树大小，再借助 0 - 1 背包动态规划，得出红色与蓝色节点个数的所有可能组合。各题解主要差异在于实现细节与代码风格，如存储图的方式（链式前向星、邻接表等）、背包实现方式、是否使用 `bitset` 优化等。

### 所选的题解
 - **作者：Grisses (5星)**
    - **关键亮点**：思路阐述详细，通过图示辅助理解，代码注释详尽，采用链式前向星存图，逻辑清晰。
    - **重点代码 - 核心实现思想**：
```cpp
// 链式前向星存图
void adde(int u,int v){
    e[++cnt].nxt=h[u];
    h[u]=cnt;
    e[cnt].v=v;
}
// 求以1为根时分别以每个点为根的子树的节点数
void dfs(int x,int fa){
    w[x]++;
    for(int i=h[x];i;i=e[i].nxt){
        if(e[i].v==fa)continue;
        dfs(e[i].v,x);
        w[x]+=w[e[i].v];
    }
}
// 0 - 1背包
void dfs1(int x,int fa){
    int tot=0,sum=0;
    for(int i=h[x];i;i=e[i].nxt){
        if(e[i].v==fa)continue;
        c[++tot]=w[e[i].v];
        sum+=w[e[i].v];
    }
    c[++tot]=n-sum-1;
    dp.reset();
    dp[0]=1;
    for(int i=1;i<=tot;i++){
        for(int j=n;j>=c[i];j--){
            if(dp[j-c[i]])dp[j]=1;
        }
    }
    ans|=dp;
    for(int i=h[x];i;i=e[i].nxt){
        if(e[i].v==fa)continue;
        dfs1(e[i].v,x);
    }
}
```
 - **作者：qwq___qaq (4星)**
    - **关键亮点**：代码简洁明了，采用邻接表存图，逻辑直接，对思路的关键步骤有清晰描述。
    - **重点代码 - 核心实现思想**：
```cpp
// 求以u为根的子树大小
void init(int u,int fa){
    sz[u]=1; 
    for(int i=0,len=G[u].size();i<len;++i){
        int v=G[u][i];
        if(v==fa)
            continue;
        init(v,u);
        sz[u]+=sz[v];
    }
}
// 0 - 1背包
void dfs(int u){
    for(int i=0,len=G[u].size();i<len;++i){
        int v=G[u][i];
        for(int j=n-1;j>=sz[v];--j)
            dp[j]|=dp[j-sz[v]];
    }
}
```
 - **作者：Wei_Han (4星)**
    - **关键亮点**：思路清晰，使用 `bitset` 对背包进行优化，时间复杂度更优。
    - **重点代码 - 核心实现思想**：
```cpp
// 求以x为根的子树大小
inline void dfs(ll x,ll fa){siz[x]=1;for(ll y:g[x]) if(y!=fa) dfs(y,x),siz[x]+=siz[y];}
// 0 - 1背包，使用bitset优化
inline void dfs1(ll x,ll fa){
    f.reset();f[0]=1;
    for(int v:g[x]){
        ll w=(v==fa)?n-siz[x]:siz[v];
        for(int i=n-2;i>=w;i--) f[i]=f[i]|f[i-w];
    }
    ans|=f;
    for(int v:g[x]) if(v!=fa) dfs1(v,x);
}
```

### 最优关键思路或技巧
1. **确定不染色节点**：通过分析得出为使染色节点最多，仅有一个节点不染色的结论，简化问题规模。
2. **利用 DFS 求子树大小**：借助深度优先搜索，快速求出以每个节点为根的子树大小，为后续背包问题提供数据基础。
3. **0 - 1 背包应用**：将子树大小作为物品重量和价值，利用 0 - 1 背包动态规划，求解不同颜色节点个数的所有可能组合。
4. **`bitset` 优化**：如 `Wei_Han` 的题解，使用 `bitset` 优化背包过程，降低时间复杂度。

### 可拓展之处
同类型题通常围绕树的染色、划分等问题展开，类似算法套路为先对树进行分析得出关键结论（如不染色节点数量），再结合搜索获取子树信息，最后通过动态规划解决组合问题。

### 洛谷相似题目推荐
1. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：基础的 0 - 1 背包问题，帮助理解背包模型。
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形依赖背包问题，与本题结合树与背包的思路类似。
3. [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)：通过动态规划解决数字合并问题，锻炼动态规划思维。 

---
处理用时：50.03秒
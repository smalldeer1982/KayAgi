# 题目信息

# King's Path

## 题目描述

有一个国王站在一个 $10^9 \times 10^9$ 的国际象棋棋盘上。

规定第 $i$ 行第 $j$ 列的位置表示为 $(i, j)$。

在给定的国际象棋棋盘上有一些格子是允许通过的。

国际象棋棋盘的所有允许通过的格子都以下面所述的形式的形式给出。

一共 $n$ 段，每段用三个整数 $r_i, a_i, b_i\ (a _ i \le b _ i)$ 表示，意思是在 $r_i$ 行中第 $a_i$ 个格子到第 $b_i$ 个格子是允许通过的。

国王可以移动到与它相邻的任意一个格子里（只能走一步）。

如果两个格子有至少一个公用的点，那么就认为他们是相邻的。

求出国王从 $(x _ 0, y _ 0)$ 移动至 $(x _ 1, y _ 1)$ 的最少步数。

## 说明/提示

$1 \le x_0, y_0, x_1, y_1 \le 10^9$

$1\le n \le 10^5$

$1 \le r_i, a_i, b_i \le 10^9$

$a_i \le b_i$


保证国王的初始和最终位置是允许通过的格子。

保证国王的初始和最终位置不一致。

保证所有给定部分的总长度不超过 $10^5$ 。

## 样例 #1

### 输入

```
5 7 6 11
3
5 3 8
6 7 11
5 2 5
```

### 输出

```
4
```

## 样例 #2

### 输入

```
3 4 3 10
3
3 1 4
4 5 9
3 10 10
```

### 输出

```
6
```

## 样例 #3

### 输入

```
1 1 2 10
2
1 1 3
2 6 10
```

### 输出

```
-1
```

# AI分析结果

### 题目内容
# 国王的路径

## 题目描述
有一个国王站在一个 $10^9 \times 10^9$ 的国际象棋棋盘上。规定第 $i$ 行第 $j$ 列的位置表示为 $(i, j)$ 。在给定的国际象棋棋盘上有一些格子是允许通过的。国际象棋棋盘的所有允许通过的格子都以下面所述的形式给出。一共 $n$ 段，每段用三个整数 $r_i, a_i, b_i\ (a _ i \le b _ i)$ 表示，意思是在 $r_i$ 行中第 $a_i$ 个格子到第 $b_i$ 个格子是允许通过的。国王可以移动到与它相邻的任意一个格子里（只能走一步）。如果两个格子有至少一个公用的点，那么就认为他们是相邻的。求出国王从 $(x _ 0, y _ 0)$ 移动至 $(x _ 1, y _ 1)$ 的最少步数。

## 说明/提示
$1 \le x_0, y_0, x_1, y_1 \le 10^9$ 
$1\le n \le 10^5$ 
$1 \le r_i, a_i, b_i \le 10^9$ 
$a_i \le b_i$

保证国王的初始和最终位置是允许通过的格子。
保证国王的初始和最终位置不一致。
保证所有给定部分的总长度不超过 $10^5$ 。

## 样例 #1
### 输入
```
5 7 6 11
3
5 3 8
6 7 11
5 2 5
```
### 输出
```
4
```

## 样例 #2
### 输入
```
3 4 3 10
3
3 1 4
4 5 9
3 10 10
```
### 输出
```
6
```

## 样例 #3
### 输入
```
1 1 2 10
2
1 1 3
2 6 10
```
### 输出
```
-1
```

### 算法分类
广度优先搜索 BFS

### 综合分析与结论
这些题解的核心思路均是利用广度优先搜索（BFS）来求解从起始点到目标点的最少步数。由于棋盘坐标范围极大（$10^9 \times 10^9$），无法使用常规数组存储状态，题解们都采用了`map`来存储状态信息。不同之处在于对坐标的处理方式，有的使用`pair`结合`map`，有的将坐标通过特定计算转换为一个值再用`map`存储。整体思路清晰，都围绕BFS展开。

### 所选的题解
- **作者：Alex_Wei (5星)**
    - **关键亮点**：思路清晰，代码简洁。利用`map`结合自定义哈希函数处理大坐标，直接用BFS暴力求解，对题目关键信息把握准确。
    - **重点代码**：
```cpp
ll get(ll x, ll y){return x*1e9+y;}
int main()
{
    cin>>a>>b>>c>>d>>n,aim=get(c,d);
    if(c-a>n)cout<<-1,exit(0);
    for(int i=0;i<n;i++){
        ll w,l,r;
        cin>>w>>l>>r;
        for(ll j=l;j<=r;j++)
            mp[get(w,j)]=1;
    }
    q.push((pos){a,b,get(a,b),0}),mp[get(a,b)]=0;
    while(q.size()){
        pos t=q.front();
        q.pop();
        if(t.val==aim)cout<<t.st,exit(0);
        for(int i=-1;i<2;i++)
            for(int j=-1;j<2;j++)
                if(i!=0||j!=0){
                    ll xx=t.x+i,yy=t.y+j,k=get(xx,yy);
                    if(xx>0&&yy>0&&xx<=1e9&&yy<=1e9&&mp[k])
                        mp[k]=0,q.push((pos){xx,yy,k,t.st+1});
                }
    }
    cout<<-1;
    return 0;
}
```
    - **核心实现思想**：定义`get`函数将二维坐标转化为一维哈希值，存入`map`。BFS过程中，从起始点出发，每次扩展八个方向的邻接点，若该邻接点合法且未访问过，则加入队列并更新步数。
- **作者：ATION001 (4星)**
    - **关键亮点**：对思路阐述详细，包括对`map`使用原因及方法的说明。代码结构清晰，使用`pair`结合`map`存储坐标状态，标准BFS模板实现。
    - **重点代码**：
```cpp
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>xa>>xb>>ya>>yb>>n;
    for(int i=1;i<=n;i++){
        cin>>r>>a>>b;
        for(int j=a;j<=b;j++){
            b2[{r,j}]=1;
        }
    }
    q.push({xa,xb});
    while(q.size()){
        auto p=q.front();
        q.pop();
        for(int i=0;i<8;i++){
            int dx=p.first+xyx[i][0],dy=p.second+xyx[i][1];
            if(b2[{dx,dy}]&&!mp[{dx,dy}]){
                mp[{dx,dy}]=mp[{p.first,p.second}]+1;
                q.push({dx,dy});
            }
        }
    }
    cout<<(mp[{ya,yb}]?mp[{ya,yb}]:-1);
    return 0;
}
```
    - **核心实现思想**：先将所有可行走的坐标用`b2` `map`标记，然后从起始点开始BFS，每次取出队首元素，扩展八个方向的邻接点，若邻接点可行且未访问过，更新其步数并加入队列，最后根据目标点的步数输出结果。
- **作者：AKPC (4星)**
    - **关键亮点**：不仅对思路和`map`与`pair`的使用有详细说明，还额外提到了不用`pair`时的坐标处理方法。代码规范，对BFS过程和状态记录清晰。
    - **重点代码**：
```cpp
void bfs(){
    queue<pair<int,int> >que;
    que.push(make_pair(ax,ay));
    while (!que.empty()){
        int x=que.front().first,y=que.front().second;
        que.pop();
        if (x==bx&&y==by){
            cout<<dep[make_pair(x,y)];
            exit(0);
        }
        for (int i=0;i<8;i++){
            pair<int,int>Pair(x+dx[i],y+dy[i]);
            if (mp[Pair]&&!tmp[Pair]){
                tmp[Pair]=1;
                dep[Pair]=dep[make_pair(x,y)]+1;
                que.push(Pair);
            }
        }
    }
    cout<<-1;
}
signed main(){
    while (n--){
        int r=read(),a=read(),b=read();
        for (int i=a;i<=b;i++) mp[make_pair(r,i)]=1;
    }
    bfs();
    return 0;
}
```
    - **核心实现思想**：在`main`函数中先标记所有可行走的坐标，`bfs`函数从起始点开始，每次取出队首坐标，判断是否为目标点，是则输出步数。否则扩展八个方向邻接点，若邻接点可行且未访问过，标记访问并更新步数后加入队列。

### 最优关键思路或技巧
利用`map`结合`pair`或自定义哈希函数来处理大坐标空间问题，通过BFS的层序遍历特性保证找到的是最少步数路径。

### 拓展思路
此类题目核心在于处理大空间下的状态存储与搜索，类似套路可应用于其他大规模地图的路径搜索问题，例如在大规模迷宫、城市道路网络等场景下求最短路径，关键是根据题目特点选择合适的数据结构存储状态。

### 相似知识点洛谷题目
- **P1379 八数码难题**：同样是在一个状态空间中利用BFS搜索最短路径，涉及状态表示与转移。
- **P1141 01迷宫**：通过BFS遍历迷宫，判断连通块等，对理解BFS在地图类问题中的应用有帮助。
- **P1352 没有上司的舞会**：虽然主要是树形DP，但其中对树的遍历部分与BFS搜索的思想有相似之处，可加深对搜索与动态规划结合的理解。 

---
处理用时：93.22秒
# 题目信息

# Game with Coins

## 题目描述

两个海盗 Polycarpus 和 Vasily 玩了一个非常有趣的游戏。他们有 $n$ 个装有硬币的箱子，这些箱子都有一个从 $1$ 到 $n$ 的整数编号。编号为 $i$ 的箱子有 $a_{i}$ 个硬币。

Polycarpus 和 Vasily 轮流出手。 Polycarpus 首先出手。在移动过程中，玩家可以选择一个正整数 $x$ $(2×x+1 \leq n)$ 并从每个编号为 $x$ 、 $2 \times x$ 、$2 \times x+1$ 的箱子中取出一个硬币。 可能会发现某些箱子没有硬币，在这种情况下，不会从这个箱子中取出硬币。当所有箱子都没有硬币时，游戏结束。

Polycarpys 非常懒，但是他又想知道游戏最少可以玩几轮，于是他把这个任务交给了你。

## 样例 #1

### 输入

```
1
1
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
3
```

# AI分析结果

### 题目内容
# 硬币游戏

## 题目描述
两个海盗Polycarpus和Vasily玩了一个非常有趣的游戏。他们有$n$个装有硬币的箱子，这些箱子都有一个从$1$到$n$的整数编号。编号为$i$的箱子有$a_{i}$个硬币。

Polycarpus和Vasily轮流出手。Polycarpus首先出手。在移动过程中，玩家可以选择一个正整数$x$ $(2×x + 1 \leq n)$并从每个编号为$x$、$2×x$、$2×x + 1$的箱子中取出一个硬币。可能会发现某些箱子没有硬币，在这种情况下，不会从这个箱子中取出硬币。当所有箱子都没有硬币时，游戏结束。

Polycarpys非常懒，但是他又想知道游戏最少可以玩几轮，于是他把这个任务交给了你。

## 样例 #1
### 输入
```
1
1
```
### 输出
```
-1
```
## 样例 #2
### 输入
```
3
1 2 3
```
### 输出
```
3
```

### 算法分类
贪心

### 综合分析与结论
所有题解都指出本题采用贪心策略。各题解思路要点相似，均先判断$n$的情况，当$n \leq 2$或$n$为偶数时，无法按规则操作，直接输出$-1$；当$n$满足条件时，倒序枚举箱子，对于每个箱子，若其有硬币，根据箱子编号的奇偶性，选择合适的另外两个箱子，同时减少相应数量的硬币，并累计操作次数。

各题解的不同主要体现在代码实现细节，如函数封装、边界处理写法等。整体思路清晰，代码实现难度不大。

### 所选的题解
- **作者：DiDi123 (5星)**
    - **关键亮点**：思路阐述清晰，详细分析了贪心策略的每一步，包括$n$的不同取值情况及倒序枚举时不同位置箱子的操作选择原因。代码简洁明了，通过封装函数处理编号转换，逻辑清晰。
    - **重点代码**：
```cpp
int con(int x) {
    if (x & 1) return x - 1;
    return x + 1;
}
for (int i = n; i >= 1; i--)
    if (a[i] > 0) a[con(i)] -= a[i], a[i >> 1] -= a[i], ans += a[i], a[i] = 0;
```
核心思想：倒序遍历数组，对于每个非零的$a[i]$，通过`con`函数确定另一个相关箱子编号，同时对$a[i/2]$和确定的箱子编号对应的元素减去$a[i]$，并累计$a[i]$到结果`ans`。
- **作者：AKPC (4星)**
    - **关键亮点**：对倒序枚举的原因解释详细，通过对比正序和倒序操作说明倒序的合理性。代码简洁，变量命名直观。
    - **重点代码**：
```cpp
for (int i = n; i >= 1; i--) {
    if (a[i] <= 0) continue;
    if (i % 2 == 0) ans += a[i], a[i + 1] -= a[i], a[i / 2] -= a[i], a[i] = 0;
    else ans += a[i], a[i - 1] -= a[i], a[i / 2] -= a[i], a[i] = 0;
}
```
核心思想：倒序遍历数组，若当前箱子有硬币，根据箱子编号奇偶性，对相关箱子的硬币数进行调整，并累计操作次数。
- **作者：XXh0919 (4星)**
    - **关键亮点**：代码注释清晰，对特判条件和倒序枚举的操作解释明确。通过封装函数处理编号转换，使代码逻辑较为清晰。
    - **重点代码**：
```cpp
int f(int x) {
    if (x % 2 == 1) return x - 1;
    return x + 1;
}
for(int i=n;i>=1;i--) {
    if (a[i]>0)a[f(i)]-=a[i];
    a[i>>1]-=a[i];
    ans+=a[i];
    a[i]=0;
}
```
核心思想：倒序遍历数组，利用`f`函数确定相关箱子编号，对相关箱子的硬币数进行调整，并累计操作次数。

### 最优关键思路或技巧
- **倒序贪心策略**：由于较靠后的箱子只能由靠前的箱子更新，倒序枚举能保证每个箱子在处理时，其依赖的后续箱子已处理完毕，从而实现贪心选择，每次操作尽可能减少总的操作次数。
- **特判优化**：先对$n$的特殊情况（$n \leq 2$或$n$为偶数）进行判断并直接输出结果，避免无效计算，优化了程序运行效率。

### 可拓展之处
同类型题通常围绕特定操作规则下的最优策略求解，类似算法套路为先分析操作规则，找出无法操作或特殊的边界情况进行特判，再根据规则确定合理的贪心策略，如按特定顺序遍历数据进行操作选择。

### 洛谷相似题目推荐
- **P1080 [NOIP2012 提高组] 国王游戏**：通过对数据进行排序后贪心求解最大收益。
- **P1199 [NOIP2010 普及组] 三国游戏**：需要分析游戏规则，利用贪心思想选择最优策略。
- **P2859 [USACO06DEC]Milk Patterns G**：结合字符串处理和贪心策略解决问题。 

---
处理用时：47.79秒
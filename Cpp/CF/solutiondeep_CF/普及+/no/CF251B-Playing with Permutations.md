# 题目信息

# Playing with Permutations

## 题目描述

现在你有一个长为 $n$ 的序列 $q$ 以及另外一个长度为 $n$ 的序列 $p$ 。其中 $p$ 序列初始化为 $1,2,3,....n$ 



定义两种操作：



$1.p[q[i]]=p[i]$



$2.p[i]=p[q[i]]$



给出步骤数 $k$ 和目标序列 $s$ ，问你能否在恰好 $k$ 个操作后实现从 $p$ 序列到 $s$ 序列的转换？



输出"YES"或者"NO"(不含引号)来表示你的结果。



要求：在 $k$ 步以前的过程中不能让 $p=s$ ，否则视作失败，哪怕是刚开始 $p=s$ 也不行。

## 样例 #1

### 输入

```
4 1
2 3 4 1
1 2 3 4
```

### 输出

```
NO
```

## 样例 #2

### 输入

```
4 1
4 3 1 2
3 4 2 1
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
4 3
4 3 1 2
3 4 2 1
```

### 输出

```
YES
```

## 样例 #4

### 输入

```
4 2
4 3 1 2
2 1 4 3
```

### 输出

```
YES
```

## 样例 #5

### 输入

```
4 1
4 3 1 2
2 1 4 3
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# 排列游戏

## 题目描述
现在你有一个长度为 $n$ 的序列 $q$ 以及另一个长度为 $n$ 的序列 $p$ 。其中 $p$ 序列初始化为 $1,2,3,\cdots,n$ 。

定义两种操作：
1. $p[q[i]] = p[i]$
2. $p[i] = p[q[i]]$

给出步骤数 $k$ 和目标序列 $s$ ，问你能否在恰好 $k$ 个操作后实现从 $p$ 序列到 $s$ 序列的转换？

输出 "YES" 或者 "NO"（不含引号）来表示你的结果。

要求：在 $k$ 步以前的过程中不能让 $p = s$ ，否则视作失败，哪怕是刚开始 $p = s$ 也不行。

## 样例 #1
### 输入
```
4 1
2 3 4 1
1 2 3 4
```
### 输出
```
NO
```

## 样例 #2
### 输入
```
4 1
4 3 1 2
3 4 2 1
```
### 输出
```
YES
```

## 样例 #3
### 输入
```
4 3
4 3 1 2
3 4 2 1
```
### 输出
```
YES
```

## 样例 #4
### 输入
```
4 2
4 3 1 2
2 1 4 3
```
### 输出
```
YES
```

## 样例 #5
### 输入
```
4 1
4 3 1 2
2 1 4 3
```
### 输出
```
NO
```

### 算法分类
数学

### 综合分析与结论
题解作者XL4453指出特别地，当目标序列 $s$ 为 $1,2,3,\cdots$ 时一定无解。思路要点在于：由于两种操作互为逆元，所以最终答案是重复操作一或操作二若干次，不会同时出现两者。在已进行 $m$ 次操作的前提下，可通过在两个操作中反复横跳解决任意偶数次剩下的操作次数。还需考虑中途 $p$ 与 $s$ 恰好相等的情况，若出现则不可行。该题解思路较清晰，但代码可读性一般，没有过多注释，且代码中存在一些变量命名不太直观，如 `now`、`now2`、`flag` 等。整体代码实现较为直接，未进行太多优化，时间复杂度为 $O(n^2)$。

### 所选的题解
 - **XL4453的题解**：
   - **星级**：3星
   - **关键亮点**：发现两种操作互为逆元，确定最终答案是重复单一操作若干次，并考虑中途不能相等的特殊情况。
   - **重点代码核心实现思想**：通过两层循环模拟操作过程，每次操作后检查是否达到目标序列且满足操作次数要求。外层循环控制操作次数，内层循环实现具体操作。操作一通过 `now2[j]=now[p[j]]` 模拟，操作二可类似实现（代码中有对操作二的模拟）。每次操作后检查 `now` 序列与目标序列 `s` 是否相等，若相等且剩余操作次数为偶数则满足条件。
   - **核心代码片段**：
```cpp
// 模拟操作一
for(int i=1;i<=k;i++){
    for(int j=1;j<=n;j++)now2[j]=now[p[j]];
    for(int j=1;j<=n;j++)now[j]=now2[j];
    flag=1;
    for(int j=1;j<=k;j++)
    if(now[j]!=s[j])flag=0;
    if(flag&&(k-i)%2==0){printf("YES\n");return 0;}
}
// 模拟操作二
for(int i=1;i<=k;i++){
    for(int j=1;j<=n;j++)now2[j]=now[p2[j]];
    for(int j=1;j<=n;j++)now[j]=now2[j];
    flag=1;
    for(int j=1;j<=k;j++)
    if(now[j]!=s[j])flag=0;
    if(flag&&(k-i)%2==0){printf("YES\n");return 0;}
}
```

### 通用建议与扩展思路
通用建议：对于此类问题，可以先深入分析操作之间的关系，如本题中操作的逆元关系，这有助于简化问题。代码实现上，可以增加注释提高可读性，优化变量命名。

扩展思路：类似题目可能会改变操作的定义或者增加操作的种类，或者对操作次数的限制条件更加复杂。可以进一步研究如何将操作抽象为数学模型，例如置换群相关知识，这样在面对更复杂的操作定义时能够更系统地解决问题。

### 洛谷相似题目推荐
 - [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过递推关系解决数字生成问题，与本题类似在于需要分析操作（数字生成规则）之间的联系。
 - [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)：利用递推思想解决计数问题，与本题都需要对给定的规则进行分析并通过一定的算法实现。
 - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：涉及简单的数学计算与方案选择，与本题一样需要根据给定条件进行分析求解。 

---
处理用时：57.62秒
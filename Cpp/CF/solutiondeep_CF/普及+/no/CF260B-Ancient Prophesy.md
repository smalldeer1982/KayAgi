# 题目信息

# Ancient Prophesy

## 题目描述

最近考古学家们发现了一个古老的预言，它包含了一个末日的日期**[真的]**。这个预言由一个字符串组成，且只包含数字和连字符**['-']**。考古学家们认为，末日的日期是一个形如**[dd-mm-yyyy]**的字串，可以有相交部分。一个日期出现的次数，就是这样的子串出现的次数。打个比方，对于预言**"0012-10-2012-10-2012"**，它就提到了两次2012年10月12日。【第一次是00**12-10-2012**-10-2012，第二次是0012-10-20**12-10-2012**(加粗字体)】。

世界末日的日期是合法的，并且是出现次数最多的那个日期。保证它出现的次数严格大于其他日期。

一个正确的日期，满足以下3个条件:

    1.年份必定在2013至2015年间
    2.月份在1~12月之间
    3.日期不超过这个月的天数,且大于0
特别注意的是，日期是这样读出来的:**日-月-年**。这意味着它需要前导零。比如说，**1-1-2013**不满足格式【**dd-mm-yyyy**】，而**01-01-2013**则是一个合法的格式。

提醒一下，2013至2015年没有闰年。

## 样例 #1

### 输入

```
777-444---21-12-2013-12-2013-12-2013---444-777
```

### 输出

```
13-12-2013```

# AI分析结果

### 题目重写
# 古老的预言
## 题目描述
最近考古学家们发现了一个古老的预言，它包含了一个末日的日期**[真的]**。这个预言由一个字符串组成，且只包含数字和连字符**['-']**。考古学家们认为，末日的日期是一个形如**[dd-mm-yyyy]**的字串，可以有相交部分。一个日期出现的次数，就是这样的子串出现的次数。打个比方，对于预言**"0012-10-2012-10-2012"**，它就提到了两次2012年10月12日。【第一次是00**12-10-2012**-10-2012，第二次是0012-10-20**12-10-2012**(加粗字体)】。

世界末日的日期是合法的，并且是出现次数最多的那个日期。保证它出现的次数严格大于其他日期。

一个正确的日期，满足以下3个条件:
1. 年份必定在2013至2015年间
2. 月份在1~12月之间
3. 日期不超过这个月的天数,且大于0
特别注意的是，日期是这样读出来的:**日-月-年**。这意味着它需要前导零。比如说，**1-1-2013**不满足格式【**dd-mm-yyyy**】，而**01-01-2013**则是一个合法的格式。

提醒一下，2013至2015年没有闰年。
## 样例 #1
### 输入
```
777-444---21-12-2013-12-2013-12-2013---444-777
```
### 输出
```
13-12-2013
```

### 算法分类
字符串

### 综合分析与结论
这三道题解的核心思路都是通过遍历字符串找出所有可能的日期子串，判断其合法性并统计出现次数，最终找出出现次数最多的合法日期。
- **xyf007题解**：通过打表列出所有合法日期，利用`map`记录日期出现次数。难点在于打表工作量大，但实现简单直接，通过滑动窗口方式遍历字符串判断日期。
- **45dinо题解**：枚举所有长度为10的子串，根据日期格式和范围条件判断合法性，用`map`记录次数。难点在于复杂的合法性判断逻辑。
- **离散小波变换°题解**：同样枚举长度为10的子串，先判断格式，再提取年月日判断合法性，用`map`记录次数。难点也是合法性判断。

整体来看，xyf007的打表法虽然代码长但思路简单清晰；45dinо和离散小波变换°的动态判断法更具通用性，但代码逻辑相对复杂。

### 所选的题解
- **xyf007题解**：★★★★
    - **关键亮点**：采用打表方式，将所有合法日期预先列出，使得合法性判断简单直接，通过滑动窗口遍历字符串统计日期出现次数，代码实现较为清晰。
    - **重点代码核心实现思想**：预先将1095个合法日期存入数组`lawful`，并在`map` `f`中标记为合法。通过滑动窗口每次取10个字符的子串，判断其是否在`f`中，若在则在`map` `sum`中记录出现次数并更新最大次数和对应日期。
    ```cpp
    for (int i = 0; i < 1095; ++i)
    {
        f[lawful[i]]=1;//预处理
    }
    cin>>s;
    string temp,ans;
    for (int i = 0; i < 10; ++i)
    {
        temp+=s[i];
    }
    int mx=-1;
    if (f.count(temp))
    {
        sum[temp]++;
        if (sum[temp]>mx)
        {
            mx=sum[temp];
            ans=temp;
        }
    }
    for (int i = 10, sz=s.size(); i < sz; ++i)
    {
        temp.erase(temp.begin());
        temp+=s[i];
        if (f.count(temp))
        {
            sum[temp]++;
            if (sum[temp]>mx)
            {
                mx=sum[temp];
                ans=temp;
            }
        }//模拟并判断
    }
    ```
- **45dinо题解**：★★★★
    - **关键亮点**：直接枚举所有可能子串，通过详细的条件判断子串是否为合法日期，逻辑较为严谨。
    - **重点代码核心实现思想**：先初始化每个月的最大天数到`map` `month`中。遍历字符串，对每个长度为10的子串，先判断格式是否正确，再提取出日、月、年，根据范围判断合法性，若合法则在`map` `num`中记录出现次数并更新最大次数和对应日期。
    ```cpp
    void solve(string x)
    {
        string d,m,y; 
        for(int i=0;i<x.size();i++)
        {
            if(i==2||i==5)
            { 
                if(x[i]!='-')
                    return ;
            } 
            else
            {
                if(x[i]=='-')
                    return ;
            }
        }    
        d=x.substr(0,2);
        m=x.substr(3,2);
        y=x.substr(6,4);
        if(y>"2015"||y<"2013")
            return ;
        if(d=="00")
            return ;
        if(m>"12"||m=="00")
            return ;
        string maxd=month[m];
        if(maxd[0]>d[0]||(maxd[0]==d[0]&&maxd[1]>=d[1]))
        {
            string res=d+"-"+m+"-"+y;
            num[res]++;
            if(num[res]>maxx)
            {
                maxx=num[res];
                ans=res;
            }
        }
    } 
    ```
- **离散小波变换°题解**：★★★★
    - **关键亮点**：详细展示了取子串的多种方法，并对日期合法性判断进行了清晰的代码实现。
    - **重点代码核心实现思想**：定义数组`d`存储每个月的天数。遍历字符串，对每个长度为10的子串先判断格式，再提取日、月、年转化为数字，根据范围判断合法性，若合法则在`map` `mmp`中记录出现次数并更新最大次数和对应日期。
    ```cpp
    void check(int p){
        string t(s,p,10);
        if(t.length()<10) return;
        if(t[2]!='-'||t[5]!='-') return;
        if(t[0]=='-'||t[1]=='-'||t[3]=='-'||t[4]=='-'||
           t[6]=='-'||t[7]=='-'||t[8]=='-'||t[9]=='-')
        return;
        int day=getnum(t[0])*10+getnum(t[1]);
        int mon=getnum(t[3])*10+getnum(t[4]);
        int yea=getnum(t[6])*1000+getnum(t[7])*100+getnum(t[8])*10+getnum(t[9]);
        if(mon<1||mon>12)         return;
        if(day<1||day>d[mon])      return;
        if(yea>2015||yea<2013)     return;
        int num=++mmp[t];
        if(num>ans) ans=num,res=t;
    }
    ```

### 最优关键思路或技巧
- **打表法**：xyf007的打表法在面对日期范围和格式固定的情况下，能极大简化合法性判断过程，虽然打表代码长，但后续处理简单高效。
- **通用判断法**：45dinо和离散小波变换°通过详细的条件判断实现日期合法性检查，这种方法更具通用性，适用于日期范围等条件不固定的情况。

### 拓展
同类型题通常围绕字符串中特定格式子串的查找、判断和统计。类似算法套路有先确定子串特征（如长度、格式），然后通过遍历字符串获取子串，再根据条件判断合法性并进行相应统计。

### 洛谷推荐题目
- **P1308 统计单词数**：考察在字符串中查找特定单词并统计其出现次数，与本题查找特定格式日期并统计次数类似。
- **P1593 因子和倍数问题**：需要对输入字符串进行解析判断，类似本题对日期字符串的解析判断。
- **P2219 [HAOI2007] 上升序列**：涉及字符串的处理和条件判断，和本题处理字符串并判断合法性思路相似。 

---
处理用时：78.09秒
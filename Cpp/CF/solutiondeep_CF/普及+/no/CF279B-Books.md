# 题目信息

# Books

## 题目描述

你有 $n$ 本书，读第 $i$ 本书需要 $a_i$ 分钟，你现在有 $m$ 分钟

你读书的方式是这样的：找出任意一个数 $x$，并按编号从小到大的顺序读第 $x \sim n$ 本   
如果你读完了第 $n$ 本，那么读书结束  
如果你准备要读第 $i$ 本书，但是剩下的时间小于 $a_i$（也就是读不完这本书）：那么你就**不可以开始读**这本书了，并且读书结束  
换句话说，如果你读一本书，就必须要读完，否则就不能读

求最多能读多少本书

## 说明/提示

$1 \le n \le 10^5$  
$1 \le m \le 10^9$  
$1 \le a_i \le 10^4$

感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
4 5
3 1 2 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 3
2 2 3
```

### 输出

```
1
```

# AI分析结果

### 题目内容
# Books

## 题目描述
你有 $n$ 本书，读第 $i$ 本书需要 $a_i$ 分钟，你现在有 $m$ 分钟。
你读书的方式是这样的：找出任意一个数 $x$，并按编号从小到大的顺序读第 $x \sim n$ 本。
如果你读完了第 $n$ 本，那么读书结束。
如果你准备要读第 $i$ 本书，但是剩下的时间小于 $a_i$（也就是读不完这本书）：那么你就**不可以开始读**这本书了，并且读书结束。
换句话说，如果你读一本书，就必须要读完，否则就不能读。
求最多能读多少本书。

## 说明/提示
$1 \le n \le 10^5$  
$1 \le m \le 10^9$  
$1 \le a_i \le 10^4$

感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1
### 输入
```
4 5
3 1 2 1
```
### 输出
```
3
```

## 样例 #2
### 输入
```
3 3
2 2 3
```
### 输出
```
1
```

### 算法分类
二分、前缀和、尺取法（尺取法本质也是一种双指针技巧，这里因题解提及，作为一类）

### 综合分析与结论
这些题解主要围绕如何高效找出满足时间限制下最多能读的书的数量。题解主要分为两类思路，一类是使用二分查找配合前缀和，另一类是采用尺取法。
 - **二分查找配合前缀和**：通过枚举起始书本位置 $i$，利用二分查找找到从 $i$ 开始能读到的最远书本位置 $j$，使得从 $i$ 到 $j$ 的书本阅读时间总和不超过 $m$。为了快速计算区间和，使用了前缀和数组。此方法时间复杂度为 $\Theta(n\times\log n)$。
 - **尺取法**：使用两个指针（左指针 $l$ 和右指针 $r$）维护一个区间，表示从第 $l$ 本书读到第 $r$ 本书。右指针不断右移，直到当前区间书本阅读时间总和超过 $m$，此时更新最多能读的书本数量，然后左指针右移一位继续下一轮。该方法时间复杂度为 $\Theta(n)$，效率上比二分查找配合前缀和更高，并且实现相对简单。

### 所选的题解
- **作者：FanYongchen (赞：5)  星级：4星  关键亮点：清晰阐述尺取法思路及实现过程，代码简洁明了**
```cpp
#include <iostream>
using namespace std;
int n,m;
int a[100005];
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++) cin>>a[i];
    int l=0,r=0;//左端点与可读到的最后一本书
    int ans=0,sum=0;//ans表示最多可读的书，sum表示花的时间
    while(l<n)
    {
        while(r<n&&sum+a[r]<=m) sum+=a[r++];//一直往下读，直到没时间
        if(r==n) {ans=max(ans,r-l);break;}
        //如果读到了最后一本，直接可以结束。
        //因为之后你不管怎么读，都不可能再有比这个多的数
        if(r==l) {l++,r++,sum=0;continue;}//如果现在一本书也读不了
        ans=max(ans,r-l);//统计出最长长度
        sum-=a[l],l++;//减去a[l]，为下一次统计做准备
    }
    cout<<ans;//输出
    return 0;
} 
```
核心实现思想：初始化左右指针 $l$ 和 $r$ 都为 0，通过内层循环移动右指针 $r$ 来扩展阅读区间，当时间不够时，更新答案并移动左指针 $l$ 缩小区间，继续下一轮寻找。
 - **作者：fjy666 (赞：4)  星级：4星  关键亮点：详细分析二分查找配合前缀和的思路，对边界情况有清晰说明**
```cpp
#include <cstdio>
#include <algorithm>
#define fo(i_,j_,k_) for(int i_=j_;i_<=k_;++i_)
#define fr(i_,j_,k_) for(int i_=j_;i_>=k_;--i_)
#define It(type_) type_::iterator
#define rg register
#define rtn return
#define il inline

typedef long long ll;
using namespace std;
const int kMaxn = 100005;
int books[kMaxn],sum[kMaxn];

int main()
{
	int n,t,ans = 0;
	scanf("%d%d",&n,&t);
	fo(i,1,n) 
	{
		scanf("%d",books+i);
		sum[i] = sum[i-1] + books[i];
	}
	fo(i,1,n)
	{
		int l = i,r = n;
		while(l <= r)
		{
			int mid = l + r >> 1; 
			if(sum[mid] - sum[i-1] <= t) l = mid + 1;
			else r = mid - 1; 
		}
		ans = max(ans,r - i + 1);
	}
	printf("%d",ans);
	rtn 0;
}
```
核心实现思想：先预处理前缀和数组 `sum`，然后通过外层循环枚举起始书本位置 `i`，内层二分查找找到最远位置 `r`，更新答案。
 - **作者：是个汉子 (赞：4)  星级：4星  关键亮点：简洁实现尺取法，代码逻辑清晰**
```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;
const int N=1e5+10;
int a[N],n,t;

int main(){
    scanf("%d%d",&n,&t);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    int l=1,r=1,s=0,ans=0;
    while(233){
        while(r<=n&&s<=t) s+=a[r++];
        if(s<=t){
            ans=max(ans,r-l);
            break;
        }
        else ans=max(ans,r-l-1);
        s-=a[l++];
    }
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：同样使用左右指针 `l` 和 `r`，通过内层循环移动右指针扩展阅读区间，根据时间判断更新答案，移动左指针缩小区间继续循环。

### 最优关键思路或技巧
尺取法的双指针技巧是本题较优的方法，通过两个指针动态维护阅读区间，避免了不必要的重复计算，时间复杂度为线性，效率较高且实现相对简单。同时，在使用二分查找时，配合前缀和数组能快速计算区间和，优化了查找过程。

### 可拓展之处
同类型题或类似算法套路：此类题目通常围绕在一个序列中寻找满足特定条件（如和小于等于某个值）的最长区间问题。类似算法套路包括利用双指针技巧解决的滑动窗口问题，以及使用二分查找优化枚举的问题。

### 推荐题目
 - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：典型的滑动窗口问题，通过双指针维护窗口，可加深对双指针技巧的理解。
 - [P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)：二分查找的基础题目，有助于巩固二分查找的实现和应用。
 - [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)：虽然是字符串哈希问题，但其中也涉及到类似的区间查找和优化思想，可拓宽思维。

### 个人心得
无。 

---
处理用时：77.09秒
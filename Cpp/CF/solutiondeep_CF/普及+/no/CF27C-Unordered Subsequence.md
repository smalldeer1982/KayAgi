# 题目信息

# Unordered Subsequence

## 题目描述

【题面描述】

如果一个序列是递增或递降的（相等也算增或降），则称它为有序的。给定一个序列，找出最短的非有序的子序列。子序列可以不连续。

## 样例 #1

### 输入

```
5
67 499 600 42 23
```

### 输出

```
3
1 3 5
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
2 3 1
```

### 输出

```
3
1 2 3
```

# AI分析结果

### 题目内容
# Unordered Subsequence

## 题目描述

### 题面描述
如果一个序列是递增或递降的（相等也算增或降），则称它为有序的。给定一个序列，找出最短的非有序的子序列。子序列可以不连续。

### 样例 #1
#### 输入
```
5
67 499 600 42 23
```
#### 输出
```
3
1 3 5
```

### 样例 #2
#### 输入
```
3
1 2 3
```
#### 输出
```
0
```

### 样例 #3
#### 输入
```
3
2 3 1
```
#### 输出
```
3
1 2 3
```

### 算法分类
枚举

### 综合分析与结论
这些题解的核心思路都是基于一个共同认知：长度小于3的序列必然有序，而长度大于3的非有序序列必然包含长度为3的非有序子序列，所以只需要找出长度为3的非有序子序列。
 - **思路方面**：多数题解选择枚举序列中的元素来寻找符合条件的子序列。其中部分题解固定第一个元素为a[1]，然后枚举中间元素，通过比较a[1]、中间元素及其后一个元素的大小关系判断是否为非有序子序列；另一些题解则通过预处理前缀最大最小值和后缀最大最小值，枚举中间元素时，利用这些预处理信息判断是否存在非有序子序列。
 - **算法要点**：重点在于明确非有序子序列的特征，即“小大小”或“大小大”的结构。同时，要注意边界条件，如序列长度小于3时直接判定无解。
 - **解决难点**：难点在于如何高效地找到满足非有序条件的子序列。不同题解通过不同的枚举方式和预处理手段来优化查找过程。

### 所选的题解
 - **作者：ahawzlc (5星)**
    - **关键亮点**：思路清晰，通过严谨推理证明只枚举i，判断a[1], a[i], a[i + 1]是否无序即可找到答案，代码简洁明了，直接在枚举过程中判断并输出结果。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=100005;
int a[N],n;
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=2;i<n;i++) {
        if((a[i+1]>a[i]&&a[i]<a[1])||(a[i+1]<a[i]&&a[i]>a[1])) {
            printf("3\n1 %d %d\n",i,i+1);
            return 0;
        }
    }
    printf("0\n");
    return 0;
}
```
    - **核心实现思想**：从第二个元素开始枚举到倒数第二个元素，每次判断当前元素i与a[1]和a[i + 1]的大小关系，若满足“小大小”或“大小大”则找到最短非有序子序列并输出，遍历完未找到则输出0。

 - **作者：xiaozeyu (4星)**
    - **关键亮点**：代码简洁，同样采用固定a[1]，通过判断(a[i] - a[0]) * (a[i + 1] - a[i]) < 0来确定是否存在非有序子序列，利用数学运算简化判断逻辑。
    - **重点代码**：
```c
#include<bits/stdc++.h>
using namespace std;
long long n,a[100010],m=0;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    for(int i=0;i<n-1;i++)
        if((a[i]-a[0])*(a[i+1]-a[i])<0)
        {
            cout<<3<<endl<<1<<" "<<i+1<<" "<<i+2<<endl;
            return 0;
        }
    cout<<0;
}
```
    - **核心实现思想**：遍历序列，通过判断相邻两个元素差值与首元素和当前元素差值的乘积是否小于0，来确定是否存在“小大小”或“大小大”的非有序子序列，若存在则输出，否则输出0。

 - **作者：LYqwq (4星)**
    - **关键亮点**：对题目分析详细，从排除长度≤2的情况，到分析长度≥3的情况，逐步将题意化简为找长度为3的非有序子序列，并清晰阐述判断条件和实现方式。
    - **重点代码**：
```cpp
#include <iostream>
using namespace std;
int n,a[100005];
int main(){
    cin >> n;
    for(int i=1; i<=n; i++){
        cin >> a[i];
    }
    for(int i=2; i<n; i++){
        if(a[1]<a[i] && a[i]>a[i+1] || a[1]>a[i] && a[i]<a[i+1]){
            cout << "3\n1 " << i << " " << i+1 << endl;
            return 0;
        }
    }
    puts("0");
    return 0;
}
```
    - **核心实现思想**：先读取序列，然后从第二个元素枚举到倒数第二个元素，判断a[1]、当前元素i和a[i + 1]是否构成“小大小”或“大小大”的非有序子序列，若构成则输出，遍历完未找到则输出0。

### 最优关键思路或技巧
固定序列首元素，通过枚举其他元素并结合非有序子序列“小大小”或“大小大”的特征来查找最短非有序子序列，这种方式减少了枚举的复杂度，提高了查找效率。同时，利用数学运算（如两数差值乘积）来简化判断逻辑也是一种实用技巧。

### 拓展
同类型题通常围绕序列的单调性判断展开，类似算法套路是先分析序列基本性质，确定可能的最短非有序子序列长度，然后通过枚举、预处理等手段查找该子序列。

### 相似知识点洛谷题目
 - [P1088 火星人](https://www.luogu.com.cn/problem/P1088)：涉及到对序列的字典序和单调性的理解与操作。
 - [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：通过对数字序列的操作，理解序列顺序变化，与本题对序列性质分析有相似之处。
 - [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)：在处理序列元素大小关系时，与本题判断序列是否有序有一定相似性。 

---
处理用时：55.26秒
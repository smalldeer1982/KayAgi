# 题目信息

# Shave Beaver!

## 题目描述

一位聪明的海狸最近发明了一种新型的纳米技术多功能海狸剃毛机「Beavershave 5000」，它能为整家族的海狸剃毛！这台机器是如何工作的呢？真是简单极了！

现有 $n$ 只海狸，每只海狸都有一个从 1 到 $n$ 的唯一编号。设想一个由这些海狸编号组成的排列 $a_1, a_2, \ldots, a_n$。如果存在一串下标 $i_1 < i_2 < \ldots < i_k$，使得 $a_{i1} = x$，$a_{i2} = x+1$，一直到 $a_{ik-1} = y-1$，$a_{ik} = y$，那么 Beavershave 5000 就可以在一次会话中为从编号 $x$ 到 $y$ 的海狸剃毛。例如，对排列 $1, 2, 3, \ldots, n$ 的海狸来说，只需要一次会话。

如果无法用一次会话剃掉编号从 $x$ 到 $y$ 的海狸，海狸们可以被分成若干组：$[x, p_1]$，$[p_1+1, p_2]$，……，$[p_m+1, y]$（$x \leq p_1 < p_2 < \ldots < p_m < y$），这样机器就可以在每组内一次完成剃毛。但此时 Beavershave 5000 总共需要 $m+1$ 次会话来处理从 $x$ 到 $y$ 的海狸。

这些海狸常常不安分，总是在尝试交换位置。因此，我们会遇到以下两类查询：

- 查询 Beavershave 5000 需要多少次会话才能完成编号从 $x$ 到 $y$ 的海狸的剃毛任务？
- 查询交换位置 $x$ 和 $y$ 上海狸（即交换 $a_x$ 和 $a_y$）。

可以假设任何一只海狸可以多次被剃毛。

## 样例 #1

### 输入

```
5
1 3 4 2 5
6
1 1 5
1 3 4
2 2 3
1 1 5
2 1 5
1 1 5
```

### 输出

```
2
1
3
5
```

# AI分析结果

### 题目内容
# 剃毛海狸！

## 题目描述
一位聪明的海狸最近发明了一种新型的纳米技术多功能海狸剃毛机「Beavershave 5000」，它能为整家族的海狸剃毛！这台机器是如何工作的呢？真是简单极了！

现有 $n$ 只海狸，每只海狸都有一个从 1 到 $n$ 的唯一编号。设想一个由这些海狸编号组成的排列 $a_1, a_2, \ldots, a_n$。如果存在一串下标 $i_1 < i_2 < \ldots < i_k$，使得 $a_{i1} = x$，$a_{i2} = x + 1$，一直到 $a_{ik - 1} = y - 1$，$a_{ik} = y$，那么Beavershave 5000就可以在一次会话中为从编号 $x$ 到 $y$ 的海狸剃毛。例如，对排列 $1, 2, 3, \ldots, n$ 的海狸来说，只需要一次会话。

如果无法用一次会话剃掉编号从 $x$ 到 $y$ 的海狸，海狸们可以被分成若干组：$[x, p_1]$，$[p_1 + 1, p_2]$，……，$[p_m + 1, y]$（$x \leq p_1 < p_2 < \ldots < p_m < y$），这样机器就可以在每组内一次完成剃毛。但此时Beavershave 5000总共需要 $m + 1$ 次会话来处理从 $x$ 到 $y$ 的海狸。

这些海狸常常不安分，总是在尝试交换位置。因此，我们会遇到以下两类查询：
- 查询Beavershave 5000需要多少次会话才能完成编号从 $x$ 到 $y$ 的海狸的剃毛任务？
- 查询交换位置 $x$ 和 $y$ 上海狸（即交换 $a_x$ 和 $a_y$）。

可以假设任何一只海狸可以多次被剃毛。

## 样例 #1
### 输入
```
5
1 3 4 2 5
6
1 1 5
1 3 4
2 2 3
1 1 5
2 1 5
1 1 5
```
### 输出
```
2
1
3
5
```

### 算法分类
树状数组

### 题解综合分析与结论
- **WYZ20030051的题解**：思路是直接暴力实现题目要求。操作二直接使用 `swap` 交换数组元素；操作一通过暴力遍历数组，统计值域在 $[x, y]$ 之间的数组成的序列中有多少连续子序列。该方法没有利用高效的数据结构，时间复杂度较高，适用于数据规模小的情况。
- **cike_bilibili的题解**：考虑通过枚举断点来确定区间连续上升子段划分，当 $a_i$ 的位置大于 $a_{i + 1}$ 的位置时会出现新段。利用树状数组维护变化量，在交换两个元素时更新树状数组，查询时通过树状数组获取结果。该方法利用树状数组优化了操作效率，适用于较大数据规模。

综合来看，cike_bilibili的题解采用树状数组优化，在处理大数据时效率更高，而WYZ20030051的题解简单暴力，仅适用于小规模数据。

### 所选的题解
- **cike_bilibili的题解**：
  - **星级**：4星
  - **关键亮点**：利用树状数组优化，通过枚举断点确定区间连续上升子段划分，高效处理交换和查询操作。
  - **重点代码核心实现思想**：通过树状数组 `BIT` 来维护区间信息。`add` 函数用于更新树状数组，`ask` 函数用于查询区间和。在交换元素时，根据元素位置关系更新树状数组，查询时通过树状数组获取结果并加1得到最终答案。
  - **核心代码片段**：
```cpp
struct BIT{
    int tree[300005];
    int lowbit(int i){return i&-i;}
    void add(int pos,int val){
        for(int i=pos;i<=n;i+=lowbit(i))tree[i]+=val;
    }
    int ask(int l,int r){
        int ans=0;
        for(int i=r;i;i-=lowbit(i))ans+=tree[i];
        for(int i=l-1;i;i-=lowbit(i))ans-=tree[i];
        return ans;
    }
}T;
//...
if(opt==2){
    int x=read(),y=read();
    if(a[x]>a[y])swap(x,y);
    if(p[a[x]]>=p[a[x]+1])T.add(a[x],-1);
    if(p[a[x]-1]>=p[a[x]])T.add(a[x]-1,-1);
    if(p[a[y]]>=p[a[y]+1])T.add(a[y],-1);
    if(a[y]-1!=a[x]&&p[a[y]-1]>=p[a[y]])T.add(a[y]-1,-1);
    swap(p[a[x]],p[a[y]]);
    swap(a[x],a[y]);
    swap(x,y);
    if(p[a[x]]>=p[a[x]+1])T.add(a[x],1);
    if(p[a[x]-1]>=p[a[x]])T.add(a[x]-1,1);
    if(p[a[y]]>=p[a[y]+1])T.add(a[y],1);
    if(a[y]-1!=a[x]&&p[a[y]-1]>=p[a[y]])T.add(a[y]-1,1);
}else{
    int l=read(),r=read();
    cout<<T.ask(l,r-1)+1<<"\n";
}
```

### 最优关键思路或技巧
利用树状数组维护区间信息，通过枚举断点判断连续上升子段，在交换操作时动态更新树状数组，从而高效地处理查询操作。

### 可拓展之处
同类型题通常涉及区间操作和动态维护信息，类似算法套路可应用于其他需要动态维护区间统计信息的场景，如区间和、区间最值等问题。

### 洛谷相似题目
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得摘录与总结
WYZ20030051提到读错题导致卡题半小时，强调了仔细读题的重要性。 

---
处理用时：55.66秒
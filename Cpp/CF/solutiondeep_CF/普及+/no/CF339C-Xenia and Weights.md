# 题目信息

# Xenia and Weights

## 题目描述

希妮亚有一套砝码和天平，每个砝码的重量为1到10之间的整数。希妮亚要玩一个关于天平和砝码的游戏，为此，她一个一个地给秤盘加砝码。第一个砝码放在左边，第二个在右边，第三个在左边，第四个在右边，以此类推。希妮亚想把m个砝码全部加到天平上。 简单地在天平上加砝码没啥意思，所以希妮亚制定了一些规则。首先，她不能连续把两个相同重量的砝码放在天平上。也就是说，对于第i个砝码(1<=i<m)，第i个的重量应该与第i+1个的重量不同。第二，每当希妮亚在某个秤盘上加砝码，她想让这个秤盘的载重超过另一个的载重。也就是说，对应的秤盘上的重量之和必须严格大于另一个秤盘上的重量之和。 我们给希妮亚所有类型的砝码。她有无数个特定重量的砝码。你的任务是帮助希妮亚在天平上放m个砝码，或者告诉希妮亚这是不可能做到的。

## 样例 #1

### 输入

```
0000000101
3
```

### 输出

```
YES
8 10 8
```

## 样例 #2

### 输入

```
1000000000
2
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# Xenia和砝码

## 题目描述
希妮亚有一套砝码和天平，每个砝码的重量为1到10之间的整数。希妮亚要玩一个关于天平和砝码的游戏，为此，她一个一个地给秤盘加砝码。第一个砝码放在左边，第二个在右边，第三个在左边，第四个在右边，以此类推。希妮亚想把m个砝码全部加到天平上。 简单地在天平上加砝码没啥意思，所以希妮亚制定了一些规则。首先，她不能连续把两个相同重量的砝码放在天平上。也就是说，对于第i个砝码(1<=i<m)，第i个的重量应该与第i+1个的重量不同。第二，每当希妮亚在某个秤盘上加砝码，她想让这个秤盘的载重超过另一个的载重。也就是说，对应的秤盘上的重量之和必须严格大于另一个秤盘上的重量之和。 我们给希妮亚所有类型的砝码。她有无数个特定重量的砝码。你的任务是帮助希妮亚在天平上放m个砝码，或者告诉希妮亚这是不可能做到的。

## 样例 #1
### 输入
```
0000000101
3
```
### 输出
```
YES
8 10 8
```

## 样例 #2
### 输入
```
1000000000
2
```
### 输出
```
NO
```

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
这些题解主要围绕深度优先搜索（DFS）展开，部分题解还结合了贪心剪枝的策略。思路上都是按照题目规则，模拟砝码放置过程。算法要点在于通过递归函数，在每次放置砝码时检查是否满足相邻砝码重量不同以及放置后该秤盘重量大于另一秤盘重量的条件。解决难点在于如何优化搜索过程，避免暴力搜索带来的高时间复杂度。

### 所选的题解
- **作者：jdsb (赞：6)  星级：4星**
    - **关键亮点**：思路清晰，按照题意直接进行DFS模拟，代码结构简洁明了，易于理解。
    - **核心代码**：
```cpp
void dfs(int k,int ls,int rs,int last)
{
    if(k==n+1)
    {
        print();
        exit(0);
    }
    for(int i=1;i<=10;i++)
    {
        if(!vis[i]) continue;
        if(i==last) continue;
        if(k%2==1)
        {
            if(ls+i>rs) 
            {
                a[k]=i;
                dfs(k+1,ls+i,rs,i);
            }
        }
        else
        {
            if(rs+i>ls)
            {
                a[k]=i;
                dfs(k+1,ls,rs+i,i);
            }
        }
    }
}
```
    - **核心实现思想**：`dfs`函数中，`k`表示当前放置的砝码序号，`ls`和`rs`分别表示左右秤盘的重量，`last`表示上一个放置的砝码重量。每次递归时，遍历所有可用砝码，若满足条件则放置砝码并继续递归。

- **作者：AKPC (赞：5)  星级：4星**
    - **关键亮点**：在DFS基础上考虑了贪心剪枝策略，通过从小到大枚举放置的砝码重量，使下一次放置的选择更多，并且设置了剪枝标志`tmp`，一旦找到正确答案就停止搜索，提高效率。
    - **核心代码**：
```cpp
void dfs(int k,int l,int r,int la){
    if (k==n){
        tmp=1;
        puts("YES");
        return;
    }
    for (int i=1;i<=tip;i++)
        if (a[i]+l>r&&a[i]!=la&&!tmp){
            ans[k+1]=a[i];
            dfs(k+1,r,l+a[i],a[i]);
        }
}
```
    - **核心实现思想**：`dfs`函数中，`k`为已放置砝码个数，`l`和`r`为左右盘重量，`la`为上一次放置的砝码重量。每次递归从可用砝码中从小到大枚举，若满足条件则放置并递归，同时利用`tmp`剪枝。

- **作者：RiceFruit (赞：4)  星级：4星**
    - **关键亮点**：同样采用DFS，从大到小枚举砝码，认为更大的砝码可能使后续放置更容易满足条件，在一定程度上也可视为一种优化策略，代码实现简洁。
    - **核心代码**：
```cpp
void dfs(int dq,int last,int now)
{//dq为要加砝码的盘的质量，last为另一个盘的质量，now为当前再放第几次
    if(now>m){//满足条件则输出
        cout<<"YES"<<endl;
        for(int i=1;i<=m;i++)
        cout<<ans[i]<<' ';
        cout<<endl;
        exit(0);//结束整个程序
    }
    for(int i=n;i>=1;i--){//从大到小枚举
        if(a[i]+dq>last&&a[i]!=ans[now-1]){//选择能用的砝码
            ans[now]=a[i];
            dfs(last,dq+a[i],now+1);//左右互换
        }
    }
}
```
    - **核心实现思想**：`dfs`函数中，`dq`为当前要加砝码盘的重量，`last`为另一盘重量，`now`为当前放置次数。每次从大到小枚举可用砝码，若满足条件则放置并递归，同时交换左右盘参数继续下一次放置。

### 最优关键思路或技巧
在解决此类问题时，DFS是基础方法，结合贪心策略进行剪枝能有效优化时间复杂度。如从小到大或从大到小枚举砝码，以及设置剪枝标志，在找到可行解后及时停止搜索，避免不必要的计算。

### 可拓展之处
同类型题目通常围绕特定规则下的操作序列生成或可行性判断，类似算法套路是先确定基础的搜索框架，再根据题目条件挖掘可优化的点进行剪枝。例如在一些游戏策略规划、资源分配可行性判断等题目中，都可尝试这种思路。

### 推荐题目
 - [P1120 小木棍 ［数据加强版］](https://www.luogu.com.cn/problem/P1120)：同样是使用DFS搜索，并结合剪枝优化来解决将长木棍拆分后重新拼接成等长小木棍的问题。
 - [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：通过DFS搜索遍历所有可能的路径顺序，同时可考虑一些剪枝技巧来优化，判断在规定条件下能否遍历完所有奶酪。
 - [P1731 营救人员](https://www.luogu.com.cn/problem/P1731)：利用DFS搜索地图路径，结合题目条件判断是否能成功营救人员，过程中可思考如何优化搜索过程。 

---
处理用时：69.01秒
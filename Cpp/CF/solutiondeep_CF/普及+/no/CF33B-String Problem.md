# 题目信息

# String Problem

## 题目描述

小男孩 Valera 喜欢字符串。当它们是相同的时候，他会更喜欢它们。这就是为什么 Valera 会在空闲时间玩下面这个游戏。
他有两个由小写字母组成的字符串，根据游戏规则，Valera 每次可以将其中一个字符串中的任何一个字母 $A_i$ 变为 $B_i$，但要支付 $W_i$ 的代价。请你输出让两个字符串相同的最小代价，无解输出 $-1$。

## 样例 #1

### 输入

```
uayd
uxxd
3
a x 8
x y 13
d c 3
```

### 输出

```
21
uxyd
```

## 样例 #2

### 输入

```
a
b
3
a b 2
a b 3
b a 5
```

### 输出

```
2
b
```

## 样例 #3

### 输入

```
abc
ab
6
a b 4
a b 7
b a 8
c b 11
c a 3
a c 0
```

### 输出

```
-1
```

# AI分析结果

### 题目内容
#### String Problem
#### 题目描述
小男孩 Valera 喜欢字符串。当它们是相同的时候，他会更喜欢它们。这就是为什么 Valera 会在空闲时间玩下面这个游戏。
他有两个由小写字母组成的字符串，根据游戏规则，Valera 每次可以将其中一个字符串中的任何一个字母 $A_i$ 变为 $B_i$，但要支付 $W_i$ 的代价。请你输出让两个字符串相同的最小代价，无解输出 $-1$。
#### 样例 #1
##### 输入
```
uayd
uxxd
3
a x 8
x y 13
d c 3
```
##### 输出
```
21
uxyd
```
#### 样例 #2
##### 输入
```
a
b
3
a b 2
a b 3
b a 5
```
##### 输出
```
2
b
```
#### 样例 #3
##### 输入
```
abc
ab
6
a b 4
a b 7
b a 8
c b 11
c a 3
a c 0
```
##### 输出
```
-1
```

### 算法分类
最短路

### 综合分析与结论
这些题解主要围绕两种算法来解决问题，即Floyd算法和Dijkstra算法。思路核心都是将字符间的转换关系构建成有向带权图，通过最短路算法求出字符间转换的最小代价，再对两个字符串逐位处理，计算使它们相同的最小代价。
 - **算法要点**：
    - **Floyd算法**：先将字母转化为数字，构建有向带权图，把`d[i][j]`初始化为比所有边权都大的数（`d[i][i]`除外），通过Floyd算法求出每两个字母之间的最短路，再遍历两个字符串，贪心选择每一位能转换为相同字母的最小代价方案。
    - **Dijkstra算法**：同样把字母编号，用邻接表建图，对每个字母作为起点做一次Dijkstra算法，预处理出26个字母间的最短路并存入二维数组，之后遍历字符串计算每一位转换为相同字母的最小代价。
 - **解决难点**：
    - **重边处理**：输入可能存在重边，需取最小边权。
    - **非直接转换**：不能仅考虑将一个字符直接转换为另一个字符的情况，要枚举所有字母找到总代价最小的转换方式。

### 所选的题解
#### 作者：Dream_weavers (5星)
 - **关键亮点**：思路清晰，详细阐述了Floyd算法的应用过程，包括建图、Floyd求最短路以及后续贪心处理字符串的步骤，代码关键部分注释详细。
 - **重点代码**：
```cpp
for(int i=0;i<str1.size();i++){//遍历str1
	if(str1[i]==str2[i]){//特判字母相同情况
		ans+=str1[i];
		continue;
	}
	tmp=' ';cnt=INF;//遍历字母前赋初始值，tmp记录字母，cnt记录最小代价值
	for(int j=0;j<n;j++){//遍历字母
		int s1=d[str1[i]-'a'][j];
		int s2=d[str2[i]-'a'][j];
		if(cnt>s1+s2){//出现更小的代价值
			cnt=s1+s2;//赋值并记录字母
			tmp=char(j+'a');
		}
	}
	if(cnt==INF){//若无法变化为相同的字母
		printf("-1");//则输出-1结束程序
		return 0;
	}
	sum+=cnt,ans+=tmp;//更新sum和tmp
}
```
 - **核心实现思想**：遍历第一个字符串，若当前位与第二个字符串对应位字母相同则直接添加到结果字符串；否则枚举所有字母，计算当前两位字符转换到该字母的代价和，取最小代价及对应字母，更新总代价和结果字符串，若无法找到相同字母则输出 -1。

#### 作者：_Emiria_ (4星)
 - **关键亮点**：采用Dijkstra算法解决问题，对思路分析详细，代码注释丰富，清晰展示了如何用Dijkstra预处理字母间最短路以及后续计算字符串转换代价的过程。
 - **重点代码**：
```cpp
inline void dijk(int s){ // 普通的dijkstra模板
    // 初始化
    std::memset(vis, 0, sizeof vis);
    for(register int i = 0; i < 26; i++) dis[s][i] = inf;
    dis[s][s] = 0;
    std::priority_queue < pair < int, int > > q;
    q.push(make_pair(0, s));
    while(!q.empty()){
        int u = q.top().second;
        q.pop();
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = head[u]; i; i = edge[i].nexty){
            int v = edge[i].end;
            if(dis[s][v] > dis[s][u] + edge[i].val){
                dis[s][v] = dis[s][u] + edge[i].val;
                q.push(make_pair(-dis[s][v], v));
            }
        }
    }
}
```
 - **核心实现思想**：以字母`s`为起点，初始化距离数组，将起点入队，每次取出队首元素，若已访问则跳过，否则更新其邻接节点距离并将邻接节点入队。

#### 作者：Meatherm (4星)
 - **关键亮点**：使用Dijkstra + 堆优化算法，理论复杂度更低，代码结构清晰，对离散化等细节处理有明确说明。
 - **重点代码**：
```cpp
inline void dijkstra(int g)// dijkstra 堆优化不解释 唯一要注意的是最短路数组要开成二维
{
	k.push((node){g,0});
	while(!k.empty())
	{
		node tmp=k.top();
		k.pop();
		int i=tmp.id;
		c[i]=true;
		for(rr int j=head[i];j;j=edge[j].next)
		{
			if(!c[edge[j].to]&&mdis[g][i]+edge[j].v<mdis[g][edge[j].to])
			{
				mdis[g][edge[j].to]=mdis[g][i]+edge[j].v;
				k.push((node){edge[j].to,mdis[g][edge[j].to]});
			}
		}
	}
	return;
}
```
 - **核心实现思想**：以`g`为起点，将起点信息入优先队列，每次取出队首元素标记为已访问，遍历其邻接边，若邻接节点未访问且通过当前节点更新距离更优，则更新距离并将邻接节点入队。

### 最优关键思路或技巧
将字符间的转换关系抽象为有向带权图，利用最短路算法（Floyd或Dijkstra）求出字符间转换的最小代价，对字符串逐位贪心选择最小代价方案。在实现过程中，要注意重边处理和非直接转换情况的考虑。

### 可拓展之处
同类型题通常围绕字符串和图论结合，给定字符转换规则和代价，求字符串转换的最小代价或可行性。类似算法套路是构建图后运用最短路算法求解，可拓展到更复杂的图结构和转换规则。

### 洛谷推荐题目
 - [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：经典的最短路问题，可加深对最短路算法应用的理解。
 - [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：单源最短路径模板题，有助于巩固Dijkstra等最短路算法。
 - [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：同样是单源最短路径问题，数据规模更大，可进一步提升对最短路算法优化的能力。

### 个人心得摘录与总结
 - **作者黑影洞人**：开始想DP但发现状态无联系，实际是图论题，建图时注意边单向且可能有重边，没看样例2导致WA。总结为遇到字符串变换问题不能局限于DP，要考虑图论方法，重视样例对理解题意和边界情况的作用。
 - **作者XL4453**：开始看成DP，后发现变化可叠加，直接DP有问题，需先处理字符最小改变代价再用类似DP思路。强调字符串变换中代价叠加情况不能直接DP，要结合最短路算法处理。 

---
处理用时：102.81秒
# 题目信息

# Dima and Salad

## 题目描述

有 $n$ 个水果，每个水果有两个属性：美味值和卡路里值。现在选用若干个（至少 $1$ 个）水果制作一份特殊的沙拉，沙拉的美味值为所选的水果的美味值的和，沙拉的卡路里值为所选水果的卡路里值的和。沙拉的美味值恰好是卡路里值的 $K$ 倍。请计算该沙拉美味值最大为多少。

## 样例 #1

### 输入

```
3 2
10 8 1
2 7 1
```

### 输出

```
18
```

## 样例 #2

### 输入

```
5 3
4 4 4 4 4
2 2 2 2 2
```

### 输出

```
-1
```

# AI分析结果

### 题目内容
# Dima和沙拉

## 题目描述
有 $n$ 个水果，每个水果有两个属性：美味值和卡路里值。现在选用若干个（至少 $1$ 个）水果制作一份特殊的沙拉，沙拉的美味值为所选的水果的美味值的和，沙拉的卡路里值为所选水果的卡路里值的和。沙拉的美味值恰好是卡路里值的 $K$ 倍。请计算该沙拉美味值最大为多少。

## 样例 #1
### 输入
```
3 2
10 8 1
2 7 1
```
### 输出
```
18
```

## 样例 #2
### 输入
```
5 3
4 4 4 4 4
2 2 2 2 2
```
### 输出
```
-1
```

• **算法分类**：动态规划
• **综合分析与结论**：这些题解的核心思路都是将原问题转化为背包问题。通过对条件 $\frac{\sum_{i = 1}^{m}a_i}{\sum_{i = 1}^{m}b_i}=k$ 进行变形，得到 $\sum_{i = 1}^{m}(a_i - b_i\times k)=0$ ，从而将 $a_i - b_i\times k$ 看作背包的重量，$a_i$ 看作价值 。难点在于重量可能为负，不同题解采取了不同方法应对。有的开两个数组分别处理正负重量，有的通过平移 $dp$ 数组下标避免负数下标。
• **所选的题解**：
  - **作者Liynw（5星）**：
    - **关键亮点**：思路清晰，详细阐述转化过程、数组范围确定及初始值设定，对 $dp$ 数组下标的处理解释到位，代码注释详细。
    - **个人心得**：提到转化思维难度大，打代码要注意细节，自己错了多次才正确，比如对 $a_i - b_i\times k$ 变形后分析极限值有变化需留意。
    - **重点代码**：
```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) (a)>(b)?(a):(b)
int n,k,a[105],b[105],m[105],dp[105][110005];
int main(){
    memset(dp,-1,sizeof(dp));
    dp[0][10000]=0; //最后答案的位置是0
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&b[i]);
        m[i]=k*b[i]-a[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=110000;j>=0;j--){
            if(j-m[i]<=110000&&j-m[i]>=0){ //不能越界，越了界后面就没有回来的可能性了，直接跳过此循环
                if(dp[i-1][j-m[i]]==-1)
                    dp[i][j]=dp[i-1][j]; //不可能
                else
                    dp[i][j]=max(dp[i-1][j],dp[i-1][j-m[i]]+a[i]);
            }
        }
    }
    if(dp[n][10000])
        printf("%d",dp[n][10000]);
    else
        printf("-1");
    return 0;
}
```
    - **核心实现思想**：先初始化 $dp$ 数组，读入数据并计算每个水果的 “重量” $m[i]$ 。通过两层循环进行状态转移，外层循环遍历水果，内层循环遍历背包容量，根据前一个状态是否可达进行状态更新，最后根据 $dp[n][10000]$ 是否为 $0$ 判断是否有解并输出结果。
  - **作者YellowBean_Elsa（4星）**：
    - **关键亮点**：结合分数规划思想，代码实现简洁明了，对 $dp$ 数组维护正负重量的方式清晰，注释详细。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=216;
const int M=20019;
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}
int n,k;
int a[N],b[N];
int c[N],f[M],g[M];
//f：维护正的c。g：维护负的c。
int ans;
int main(){
    n=read(),k=read();
    for(int i=1;i<=10001;i++)f[i]=g[i]=-1e9;//初始化，f[0]=g[0]=0，其他-INF 
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)b[i]=read();
    for(int i=1;i<=n;i++){
        c[i]=a[i]-b[i]*k;
        if(c[i]>=0)//c[i]为正数 
            for(int j=1e4;j>=c[i];j--)
                f[j]=max(f[j],f[j-c[i]]+a[i]);
        else//c[i]为负数 
            for(int j=1e4;j>=-c[i];j--)
                g[j]=max(g[j],g[j+c[i]]+a[i]);
    }for(int i=0;i<=1e4;i++)
        ans=max(ans,f[i]+g[i]);//统计答案
        //f[i]+g[i]保证c之和为0 
    if(ans)printf("%d\n",ans);
    else puts("-1");
    return 0;
}
```
    - **核心实现思想**：定义两个数组 $f$ 和 $g$ 分别维护正、负的 “重量” $c$ 对应的最大价值。初始化数组后，读入数据并计算每个水果的 “重量” $c[i]$ 。根据 $c[i]$ 的正负分别更新 $f$ 和 $g$ 数组，最后通过 $f[i]+g[i]$ 统计答案并判断输出。
  - **作者xixiup（4星）**：
    - **关键亮点**：思路阐述清晰，通过公式推导自然引出背包问题的转化，对处理重量正负的方式描述详细。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=110,maxm=100100;
int n,m,k,a[maxn],b[maxn],v[maxn];
int po[maxm],ne[maxm];
int main(){
    cin>>n>>k;
    m=100000;//m就是最大的空间
    for(int i=1;i<=m;i++){
        po[i]=ne[i]=-1000000000;
    }//i时从1开始的
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&b[i]);
        v[i]=a[i]-k*b[i];
    }
    for(int i=1;i<=n;i++){
        if(v[i]>=0){//正的情况
            for(int j=m;j>=v[i];j--){
                po[j]=max(po[j],po[j-v[i]]+a[i]);
            }
        }
        else{
            v[i]=-v[i];//负的情况
            for(int j=m;j>=v[i];j--){
                ne[j]=max(ne[j],ne[j-v[i]]+a[i]);
            }
        }
    }
    int ans=0;
    //ans要赋为0，方便待会儿判断误解
    for(int i=0;i<=m;i++){
        ans=max(ans,po[i]+ne[i]);
    }
    if(ans==0){
        puts("-1");
    }
    else{
        cout<<ans; 
    }
    return 0;
}
```
    - **核心实现思想**：定义两个数组 $po$ 和 $ne$ 分别处理正、负的 “重量” $v$ 。初始化数组后，读入数据并计算每个水果的 “重量” $v[i]$ 。根据 $v[i]$ 的正负分别对 $po$ 和 $ne$ 数组进行类似 $01$ 背包的更新，最后通过 $po[i]+ne[i]$ 得到答案并判断输出。
• **最优关键思路或技巧**：将原问题条件转化为背包问题的思维方式是关键，通过数学推导得出用 $a_i - b_i\times k$ 作为背包重量，$a_i$ 作为价值 。处理重量可能为负的情况，无论是开两个数组分别维护还是平移 $dp$ 数组下标，都是重要技巧。
• **同类型题或类似算法套路**：此类题目通常涉及条件的数学转化，将复杂条件转化为经典算法模型。类似套路是对给定条件进行数学推导，找到合适的状态表示和转移方程，常与背包问题结合，需注意处理边界情况和特殊条件。
• **推荐洛谷题目**：
  - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：基础的背包问题，有助于理解背包问题的基本概念和实现。
  - [P1833 樱花](https://www.luogu.com.cn/problem/P1833)：在背包问题基础上增加了一些限制条件，锻炼对复杂背包问题的分析和解决能力。
  - [P2602 数字计数](https://www.luogu.com.cn/problem/P2602)：通过状态转移方程解决计数问题，与本题通过推导状态转移解决问题的思路类似。 

---
处理用时：83.81秒
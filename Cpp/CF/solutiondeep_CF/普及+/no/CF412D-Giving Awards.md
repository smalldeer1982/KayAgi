# 题目信息

# Giving Awards

## 题目描述

## 问题描述

R1 公司的员工们喜欢一起消磨时间，他们一起看球赛，一起去野餐，一起做 Codeforces 的比赛。所以，一个人替另一个人结账是没什么大不了的事情。

今天是发奖金的日子，R1 公司的 CEO 会把员工一个一个请到他的办公室去，按照他们这个月的工作努力程度发奖金。CEO 知道谁欠谁的钱，而且他知道，如果他邀请 $x$ 去他的办公室，然后马上邀请 $y$ 去他办公室，且 $y$ 借给了 $x$ 一些钱，那么他们就能相遇，发生比较尴尬的事情，然后 $x$ 得到的钱就变少了。因此，R1 公司的 CEO 决定按照一个合适的顺序（即上述情况不会发生在任意一对员工之间）邀请员工。

但是，由于员工特别多，CEO 的时间是有限的，于是这个安排顺序的工作就落在了你的手中。给你员工之间的所有债务关系，请你为 R1 公司的 CEO 决定一个邀请员工的顺序。

## 样例 #1

### 输入

```
2 1
1 2
```

### 输出

```
2 1 
```

## 样例 #2

### 输入

```
3 3
1 2
2 3
3 1
```

### 输出

```
2 1 3 
```

# AI分析结果

### 题目内容
# 发放奖金

## 题目描述

### 问题描述
R1公司的员工们喜欢一起消磨时间，他们一起看球赛，一起去野餐，一起做Codeforces的比赛。所以，一个人替另一个人结账是没什么大不了的事情。

今天是发奖金的日子，R1公司的CEO会把员工一个一个请到他的办公室去，按照他们这个月的工作努力程度发奖金。CEO知道谁欠谁的钱，而且他知道，如果他邀请$x$去他的办公室，然后马上邀请$y$去他办公室，且$y$借给了$x$一些钱，那么他们就能相遇，发生比较尴尬的事情，然后$x$得到的钱就变少了。因此，R1公司的CEO决定按照一个合适的顺序（即上述情况不会发生在任意一对员工之间）邀请员工。

但是，由于员工特别多，CEO的时间是有限的，于是这个安排顺序的工作就落在了你的手中。给你员工之间的所有债务关系，请你为R1公司的CEO决定一个邀请员工的顺序。

## 样例 #1
### 输入
```
2 1
1 2
```
### 输出
```
2 1 
```
## 样例 #2
### 输入
```
3 3
1 2
2 3
3 1
```
### 输出
```
2 1 3 
```

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
这些题解的核心思路都是通过建图并利用深度优先搜索来解决问题。将员工视为节点，债务关系视为有向边，构建有向图。在搜索过程中，确保不会出现欠钱的人紧接着被借钱的人进入办公室的情况。

不同题解的差异主要体现在细节处理和对问题的理解角度上。例如，有的题解是正向建图，有的是反向建图；有的题解通过先构造一种满足特定条件的顺序再倒序输出，有的则直接正向搜索并按特定顺序记录答案。解决难点在于如何通过DFS的顺序保证满足题目中关于人员邀请顺序的限制。

### 所选的题解
- **作者：wxzzzz (4星)**
    - **关键亮点**：先构造一种顺序使得任意$x_i=y_i - 1$，然后将这组数据倒序输出得到答案，思路独特且巧妙。
    - **重点代码**：
```cpp
inline void add(int a, int b) {
    v[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
inline void dfs(int x) {
    vis[x] = 1;
    for (int i = h[x]; ~i; i = ne[i]) {
        int y = v[i];
        if (!vis[y])
            dfs(y);
    }
    ans[++cnt] = x;
}
```
核心实现思想：通过`add`函数构建邻接表存储图结构，`dfs`函数进行深度优先搜索，在搜索完所有子节点后将当前节点记录到答案数组`ans`中。
- **作者：Shimotsuki (4星)**
    - **关键亮点**：清晰地将题目中的员工和债务关系转化为有向图，并利用链式前向星存储图，代码结构清晰。
    - **重点代码**：
```cpp
struct edge{
    int next,to;
}e[N<<1];
inline void add(int u,int v){
    e[++cnt].to=v;
    e[cnt].next=head[u];
    head[u]=cnt;
}
void dfs(int u){
    vis[u]=true;
    for(int i=head[u];i;i=e[i].next){
        if(vis[e[i].to]) continue;
        dfs(e[i].to);
    }
    ans[++tot]=u;
}
```
核心实现思想：定义`edge`结构体和`add`函数构建链式前向星存储图，`dfs`函数在搜索时标记已访问节点，在遍历完所有邻接节点后将当前节点记录到答案数组`ans`。
- **作者：zzx0826 (4星)**
    - **关键亮点**：利用`vector`数组存储图结构，搜索时以某个人为起始点，先将其欠过钱的人加入答案，最后加入自身，逻辑清晰。
    - **重点代码**：
```cpp
void dfs(int k)
{
    mark[k] = true;
    for(int i=0;i<v[k].size();i++)
    {
        if(!mark[v[k][i]])
        {
            dfs(v[k][i]);
        }
    }
    ans[++vis] = k;
}
```
核心实现思想：`dfs`函数中，先标记当前节点，然后递归搜索其所有欠过钱的节点，在所有相关节点搜索完后将当前节点记录到答案数组`ans`。

### 最优关键思路或技巧
通过将实际问题转化为有向图，并利用深度优先搜索的特性，在搜索过程中合理安排节点加入答案序列的顺序，从而满足题目要求。在实现过程中，不同的数据结构（如邻接表、链式前向星、`vector`）用于存储图结构各有优劣，可根据具体情况选择。

### 可拓展之处
此类问题属于图论中基于拓扑关系的顺序确定问题，类似的题目通常会给定一些元素之间的先后顺序关系，要求找出一种满足所有关系的排列顺序。常见的拓展方向包括增加限制条件，如节点有不同的权重，或者关系图存在更复杂的结构（如多重边、自环等）。

### 洛谷推荐题目
- [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：涉及图论中的最短路问题，与本题类似需要对图进行操作和搜索。
- [P3387 缩点](https://www.luogu.com.cn/problem/P3387)：同样是图论问题，需要对有向图进行处理，通过缩点操作解决相关问题，与本题处理有向图的思路有一定相似性。
- [P2746 [USACO5.3]校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)：该题也是关于有向图的连通性和节点顺序相关问题，可进一步锻炼对图论问题的解决能力。

### 个人心得
暂未发现题解中有个人心得相关内容。 

---
处理用时：59.60秒
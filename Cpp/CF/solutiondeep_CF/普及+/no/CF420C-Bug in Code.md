# 题目信息

# Bug in Code

## 题目描述

公司的代码出问题了！！越学越掂十分生气，为了有个说法，他决定选出两个背黑锅的人。



现在有$n$个人，每个人都会选出两个背黑锅的人，老板想要让决定背黑锅的两个人的支持数（就是有几个人想让这个人背黑锅）之和大于等于$P$。请问有多少种选择方案（顺序无关）

## 样例 #1

### 输入

```
4 2
2 3
1 4
1 4
2 1
```

### 输出

```
6
```

## 样例 #2

### 输入

```
8 6
5 6
5 7
5 8
6 2
2 1
7 3
1 3
1 4
```

### 输出

```
1
```

# AI分析结果

### 题目内容
# 代码中的Bug

## 题目描述
公司的代码出问题了！！越学越掂十分生气，为了有个说法，他决定选出两个背黑锅的人。

现在有$n$个人，每个人都会选出两个背黑锅的人，老板想要让决定背黑锅的两个人的支持数（就是有几个人想让这个人背黑锅）之和大于等于$P$。请问有多少种选择方案（顺序无关）。

## 样例 #1
### 输入
```
4 2
2 3
1 4
1 4
2 1
```
### 输出
```
6
```

## 样例 #2
### 输入
```
8 6
5 6
5 7
5 8
6 2
2 1
7 3
1 3
1 4
```
### 输出
```
1
```

### 算法分类
枚举、组合数学

### 综合分析与结论
这几道题解的核心思路都是先统计每个人被选择的次数，再通过不同方式找出满足支持数之和大于等于$P$的组合数。难点在于处理重复选择的情况，即可能有多个人选择同样的两个人背黑锅，这会导致答案计算错误。

开始新的记忆的题解：
 - **思路**：先记录每个人被选次数，排序后通过双指针法遍历计算满足条件的组合数，最后对重复选择情况进行去重。
 - **算法要点**：使用结构体存储每个人选择的两人，对结构体按选择的两人序号排序，方便去重；双指针法遍历统计组合数。
 - **解决难点**：通过比较重复选择的两人支持数之和与条件的关系，对多算的情况进行减1操作。

GlenBzc的题解：
 - **思路**：先统计每个人被选次数，排序后用二分查找找到满足条件的组合，最后对重复选择情况进行预处理去重。
 - **算法要点**：利用`map`存储重复选择的情况，遍历`map`去重；用`lower_bound`进行二分查找。
 - **解决难点**：在`map`中记录重复选择的次数，通过判断重复选择的两人支持数之和与条件的关系去重。

Graph_Theory的题解：
 - **思路**：与GlenBzc类似，先统计票数，排序后二分查找满足条件的组合，再处理重复选择情况。
 - **算法要点**：通过`map`记录重复选择对及其出现次数，遍历`map`去重。
 - **解决难点**：与GlenBzc解决重复选择问题的方式相同，判断支持数之和与条件关系去重。

RainFestival的题解：
 - **思路**：枚举第一个被删除的人，删除相关选择，再计算剩余人中满足条件的选择方案数。
 - **算法要点**：用数组和向量存储选择关系，通过计数数组和前缀和思想计算满足条件的方案数。
 - **解决难点**：在枚举过程中，动态调整计数数组，处理重复选择对答案的影响。

### 所选的题解
 - **开始新的记忆（4星）**
   - **关键亮点**：双指针法遍历统计组合数，结构体存储选择关系并排序方便去重。
   - **个人心得**：一开始没考虑去重WA了，通过造数据发现此坑点。
   - **重点代码**：
```cpp
// 双指针法统计组合数
sort(cnt + 1, cnt + n + 1);
for (int i = 1; i <= n; i++) {
    if (cnt[i] >= p)
        ans += n - 1;
    else {
        while (cnt[now] >= p - cnt[i])
            now--;
        if (cnt[now + 1] + cnt[i] >= p) {
            if (cnt[now + 1] > cnt[i])
                ans += n - now;
            else
                ans += n - now - 1;
        }
    }
}
// 去重
sort(f, f + n, cmp);
node tmp;
tmp.x = tmp.y = 0;
memset(cnt, 0, sizeof(cnt));
int c = 0;
for (int i = 0; i < n; i++) {
    if (tmp.x == f[i].x && tmp.y == f[i].y)
        c++;
    else {
        if (tmp.x && to[tmp.x] + to[tmp.y] >= p && to[tmp.x] && to[tmp.x] + to[tmp.y] - c < p)
            ans--;
        tmp.x = f[i].x;
        tmp.y = f[i].y;
        c = 1;
    }
}
if (to[tmp.x] + to[tmp.y] >= p && to[tmp.x] && to[tmp.x] + to[tmp.y] - c < p)
    ans--;
```
 - **GlenBzc（4星）**
   - **关键亮点**：利用`map`预处理去重，使用`lower_bound`进行二分查找。
   - **重点代码**：
```cpp
// 预处理去重
map<pair<int, int>, int> mp;
for (int i = 1; i <= n; i++) {
    int x, y;
    cin >> x >> y;
    if (x > y) swap(x, y);
    a[x]++;
    a[y]++;
    mp[{x, y}]++;
}
for (auto i = mp.begin(); i!= mp.end(); i++) {
    if (a[i->first.first] + a[i->first.second] >= p && a[i->first.first] + a[i->first.second] - i->second < p) {
        ans--;
    }
}
// 二分查找统计组合数
sort(a + 1, a + 1 + n);
for (int i = 1; i <= n; i++) {
    int j = lower_bound(a + 1 + i, a + 1 + n, (p - a[i])) - a;
    ans += (n - j + 1);
}
```

### 最优关键思路或技巧
1. **去重技巧**：通过`map`或对结构体排序记录重复选择的情况，在计算答案时对重复情况进行修正。
2. **统计组合数**：利用排序和二分查找（或双指针法）快速统计满足支持数之和条件的组合数。

### 可拓展之处
同类型题目通常围绕组合计数展开，可能涉及不同的限制条件或数据结构。类似套路包括先统计相关数据，再处理重复情况，最后根据条件计算组合数。

### 洛谷题目推荐
1. P1313 计算系数：考察组合数学中杨辉三角与多项式系数计算。
2. P2671 求和：结合组合数学与前缀和思想。
3. P3197 [HNOI2008]越狱：运用组合数学知识解决排列组合问题。

---
处理用时：65.23秒
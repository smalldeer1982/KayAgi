# 题目信息

# Bug in Code

## 题目描述

XX公司的代码出问题了！！老板十分生气，为了有个说法，他决定选出两个背黑锅的人。



现在有n个人，每个人都会选出两个背黑锅的人，老板想要让决定背黑锅的两个人的支持数（就是有几个人想让这个人背黑锅）之和大于等于P。请问有多少种选择方案（顺序无关）

## 样例 #1

### 输入

```
4 2
2 3
1 4
1 4
2 1
```

### 输出

```
6
```

## 样例 #2

### 输入

```
8 6
5 6
5 7
5 8
6 2
2 1
7 3
1 3
1 4
```

### 输出

```
1
```

# AI分析结果

### 题目内容
# Bug in Code

## 题目描述

XX公司的代码出问题了！！老板十分生气，为了有个说法，他决定选出两个背黑锅的人。

现在有n个人，每个人都会选出两个背黑锅的人，老板想要让决定背黑锅的两个人的支持数（就是有几个人想让这个人背黑锅）之和大于等于P。请问有多少种选择方案（顺序无关）

## 样例 #1

### 输入

```
4 2
2 3
1 4
1 4
2 1
```

### 输出

```
6
```

## 样例 #2

### 输入

```
8 6
5 6
5 7
5 8
6 2
2 1
7 3
1 3
1 4
```

### 输出

```
1
```

### 算法分类
组合数学

### 综合分析与结论
这几道题解的核心思路都是先统计每个人被选的次数（即支持数）以及每对人同时被选的次数，然后通过一定的方法去重并统计满足支持数之和大于等于P的方案数。不同之处在于具体的实现方式和优化手段。
 - **思路方面**：Merge_all和LZYAC都先考虑不重复部分，再通过减去重复部分来得到答案；Acc_Robin通过建图将问题转化为图论问题；开始新的记忆则是先统计支持数，再在排序后通过二分思想统计方案数并去重。
 - **算法要点**：都涉及到对数据的统计和处理，部分题解用到排序和二分查找来优化时间复杂度。
 - **解决难点**：难点在于去重，即处理有相同的人选择同样的两个人背黑锅的情况。不同题解通过不同的数据结构和方法来实现去重，如使用map、对数据进行排序后处理等。

### 所选的题解
 - **Acc_Robin（5星）**
    - **关键亮点**：通过建图将问题巧妙转化为图论问题，利用图的度数和边权来表示支持数和重复情况，复杂度分析清晰，整体思路简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define EB emplace_back
namespace Acc{
    using ll=long long;
    const int N=3e5+9;
    vector<pair<int,int>>G[N],e;
    int d[N],ord[N];
    ll r;
    void work(){
        int n,m,i,x,y,z;
        for(cin>>n>>m,i=1;i<=n;++i)cin>>x>>y,e.EB(x,y),e.EB(y,x),++d[x],++d[y],ord[i]=i;
        auto cmp=[](int x,int y){return d[x]>d[y];};
        sort(begin(e),end(e)),sort(ord+1,ord+n+1,cmp),e.EB(x=y=0,0);
        for(auto[u,v]:e)if(u==x && v==y)++z;else{
            if(x)G[x].EB(y,z);
            x=u,y=v,z=1;
        }
        for(x=1;x<=n;r+=z,++x){
            *d=m-d[x],z=upper_bound(ord+1,ord+n+1,0,cmp)-ord-1-(m<=d[x]<<1);
            for(auto[y,w]:G[x])z-=(d[x]+d[y]>=m && d[x]+d[y]-w<m);
        }
        cout<<r/2<<'\n';
    }
}
int main(){return Acc::work(),0;}
```
    - **核心实现思想**：先读入数据，统计每个点的度数d，对边进行排序处理得到边权（即重复次数），对节点按度数降序排序。枚举每个点，通过二分查找找到满足度数和大于等于m的点的数量，再减去其中不满足去重条件的数量，最后结果除以2得到最终方案数。
 - **LZYAC（4星）**
    - **关键亮点**：思路清晰，先暴力枚举得到思路，再通过“正难则反”的思想优化，使用map处理二维数据，代码实现简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
map<pair<int,int>,int > mp;
int n,p,ans,r,t1,t2,a[300010],b[300010];
signed main(){
    scanf("%lld%lld",&n,&p);
    for(int i=1;i<=n;i++){
        scanf("%lld%lld",&t1,&t2);
        a[t1]++;a[t2]++;
        b[t1]++;b[t2]++;
        if(t1>t2) swap(t1,t2);
        mp[{t1,t2}]++;
    }
    sort(b+1,b+1+n);
    r=n;
    for(int i=1;i<=n;i++){
        while(1){
            if(r<=i||b[r]+b[i]<p) break;
            r--;
        }
        ans=ans+n-max(r,i); 
    }
    for(auto it:mp){
        if(a[it.first.first]+a[it.first.second]>=p&&a[it.first.first]+a[it.first.second]-it.second<p){
            ans--;
        }
    }
    printf("%lld",ans);
    return 0;
}
```
    - **核心实现思想**：读入数据，统计每个人被选次数a和每对人同时被选次数mp。对b数组排序后，通过双指针思想统计满足a[i]+a[j]>=p的数量，再遍历map减去不满足去重条件的数量，得到最终方案数。

### 最优关键思路或技巧
 - **建图转化**：如Acc_Robin将问题转化为图论问题，利用图的性质来解决问题，使问题更加直观和易于处理。
 - **正难则反**：LZYAC和Merge_all采用先计算不考虑重复部分，再减去重复部分的方法，简化了问题的求解过程。

### 可拓展之处
此类题目属于组合计数问题，类似套路包括将实际问题转化为图论、数组统计等模型，利用排序、二分查找等优化手段降低时间复杂度。对于去重问题，除了使用map，还可以通过排序后遍历处理。

### 洛谷相似题目推荐
 - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)
 - [P2782 友好城市](https://www.luogu.com.cn/problem/P2782)
 - [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)

### 个人心得摘录与总结
开始新的记忆提到一开始只记录每个人被选次数WA了，通过造数据发现去重的坑点。这表明在解题时，不能只关注表面需求，要深入思考数据的特殊性和可能存在的陷阱，通过大量造数据测试来发现问题。 

---
处理用时：86.38秒
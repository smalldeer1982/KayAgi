# 题目信息

# Police Patrol

## 题目描述

## 题面描述

在一条数轴上有 $n$ $(1<=n<=10^6)$ 个罪犯，第 $i$ 个罪犯的坐标为 $a_i$ $(\left|a_i\right|<=10^9)$ 。警察们要选择一个地点作为警察局。他们有一辆警车，可容纳 $m$ $(1<=m<=10^6)$ 个罪犯。那么问题来了，把警察局建在哪能使警察抓捕这些罪犯的行程总和最短。



注意：罪犯**不会**逃走。

## 样例 #1

### 输入

```
3 6
1 2 3
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 5
-7 -6 -3 -1 1
```

### 输出

```
16
```

## 样例 #3

### 输入

```
1 369
0
```

### 输出

```
0
```

## 样例 #4

### 输入

```
11 2
-375 -108 1336 1453 1598 1892 2804 3732 4291 4588 4822
```

### 输出

```
18716
```

# AI分析结果

### 题目内容
# 警察巡逻

## 题目描述
### 题面描述
在一条数轴上有 $n$ $(1\leq n\leq10^6)$ 个罪犯，第 $i$ 个罪犯的坐标为 $a_i$ $(|a_i|\leq10^9)$ 。警察们要选择一个地点作为警察局。他们有一辆警车，可容纳 $m$ $(1\leq m\leq10^6)$ 个罪犯。那么问题来了，把警察局建在哪能使警察抓捕这些罪犯的行程总和最短。

注意：罪犯**不会**逃走。

## 样例 #1
### 输入
```
3 6
1 2 3
```
### 输出
```
4
```

## 样例 #2
### 输入
```
5 5
-7 -6 -3 -1 1
```
### 输出
```
16
```

## 样例 #3
### 输入
```
1 369
0
```
### 输出
```
0
```

## 样例 #4
### 输入
```
11 2
-375 -108 1336 1453 1598 1892 2804 3732 4291 4588 4822
```
### 输出
```
18716
```

### 算法分类
贪心

### 综合分析与结论
- **思路对比**：
    - _Kimi_ 的题解思路是先证明警局建在罪犯坐标的中位数处最优，原因是无论 $m$ 为多少，都要到达最左边和最右边的罪犯，离两头罪犯距离最小的就是中位数；然后在确定警局位置后，每次优先抓离警局最远的罪犯，因为先抓近的会导致抓远的罪犯时重复走路程。
    - zhimao 的题解思路是先发现单调性，认为把警局建在最左或最右边罪犯的外侧不如建在一端；假设建在一端，最优方案是先让警车跑到最右端抓所有能抓的罪犯再回来，重复此过程直到抓完；假设建在中间就分开算左右两边。并且通过分析警局位置移动时左右两边路程变化，得出行程和是 V 型单峰函数，采用三分法求解。
- **算法要点对比**：
    - _Kimi_ 的算法要点在于确定中位数位置作为警局位置，然后通过循环分别计算从警局到左右两侧每次抓 $m$ 个罪犯的单程距离，最后乘以 2 得到总行程。
    - zhimao 的算法要点在于通过 check 函数计算在某个位置建立警局时的总行程，然后利用三分法不断缩小范围找到使总行程最小的警局位置。
- **解决难点对比**：
    - _Kimi_ 解决的难点在于证明警局建在中位数位置最优以及确定优先抓最远罪犯的贪心策略。
    - zhimao 解决的难点在于分析出行程和关于警局位置是 V 型单峰函数，从而想到使用三分法求解。

### 题解分析
- **_Kimi_ 的题解**：
    - **星级**：4 星
    - **关键亮点**：思路清晰，通过图形辅助证明警局建在中位数最优以及优先抓最远罪犯的策略，代码简洁明了，直接利用中位数和循环计算行程。
    - **核心代码**：
```cpp
signed main(){
    input();
    int midpos = n + 1 >> 1, mid = A[midpos];//mid 为中位数
    for(int i = n; i >= midpos; i -= m){//每次抓 m 个 
        ans += A[i] - mid;//累加路程 
    }
    for(int i = 1; i < midpos; i += m){//每次抓 m 个 
        ans += mid - A[i];//累加路程 
    } 
    cout << (ans << 1) << endl;//实际上我们只需要算单程结果在乘二即可 
    return 0;
}
```
    - **核心实现思想**：先找到罪犯坐标的中位数作为警局位置，然后分别从左右两侧向中间遍历，每次累加距离警局最远的 $m$ 个罪犯到警局的距离，最后将单程距离乘以 2 得到总行程。
- **zhimao 的题解**：
    - **星级**：3 星
    - **关键亮点**：通过分析单调性得出行程和是单峰函数，想到用三分法求解，有一定创新性。
    - **核心代码**：
```cpp
long long check(int x)
{
    int l=1,r=n;
    long long ans=0;
    while(a[l]<=x&&l<=n)
    {
        ans+=(long long)(x-a[l]);
        ans+=(long long)(x-a[l]);
        l+=m;
    }
    while(r>0&&a[r]>=x)
    {
        ans+=(long long)(a[r]-x);
        ans+=(long long)(a[r]-x);
        r-=m;
    }
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    int l=a[1],r=a[n],mid=(l+r)>>1;
    while(l+1<r)
    {
        long long t1=check(mid-1),t2=check(mid),t3=check(mid+1);
        if(t1>=t2)
        {
            if(t2<t3)
            {
                printf("%lld",t2);
                return 0;
            }
            else l=mid;
        }
        else r=mid;
        mid=(l+r)>>1;
    }
    long long t1=check(l-1),t2=check(l),t3=check(l+1);
    printf("%lld",min(min(t1,t2),t3));
}
```
    - **核心实现思想**：check 函数计算在位置 $x$ 建立警局时的总行程，在 main 函数中，先对罪犯坐标排序，然后通过三分法不断调整范围，找到使总行程最小的位置。

### 最优关键思路或技巧
- **贪心策略**：像 _Kimi_ 的题解中，证明并利用中位数作为警局位置以及优先抓最远罪犯的贪心策略，简化了问题的求解过程，直接通过简单计算得出结果，相比 zhimao 使用三分法，计算量更小，代码更简洁。

### 拓展思路
此类题目属于在一维空间上的优化选址问题，类似的题目可能会改变目标函数（如不只是求行程最短，可能是求时间最短，且速度与距离有关等），或者改变约束条件（如警车数量不止一辆等）。对于这类问题，关键在于通过分析问题性质，找到类似的贪心策略或者函数的单调性，从而选择合适的算法求解。

### 推荐洛谷题目
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：通过分析排序条件，利用贪心策略解决问题，与本题在寻找贪心策略上有相似之处。
- [P2859 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2859)：需要通过分析问题找到合适的贪心思路来解决字符串相关的优化问题，与本题思路类似。
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)：通过对任务顺序的分析，利用贪心策略优化总时间，与本题寻找最优策略的思路一致。

### 个人心得
无

---
处理用时：60.24秒
# 题目信息

# Pasha Maximizes

## 题目描述

Pasha has a positive integer $ a $ without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.

Help Pasha count the maximum number he can get if he has the time to make at most $ k $ swaps.

## 样例 #1

### 输入

```
1990 1
```

### 输出

```
9190
```

## 样例 #2

### 输入

```
300 0
```

### 输出

```
300
```

## 样例 #3

### 输入

```
1034 2
```

### 输出

```
3104
```

## 样例 #4

### 输入

```
9090000078001234 6
```

### 输出

```
9907000008001234
```

# AI分析结果

### 题目内容
# Pasha最大化

## 题目描述
Pasha有一个无前导零的正整数 $a$ 。今天他觉得这个数字太小，应该把它变大。不幸的是，Pasha唯一能做的操作是交换整数中相邻的两位数字。

请帮助Pasha计算，如果他最多有 $k$ 次交换机会，他能得到的最大数字是多少。

## 样例 #1
### 输入
```
1990 1
```
### 输出
```
9190
```

## 样例 #2
### 输入
```
300 0
```
### 输出
```
300
```

## 样例 #3
### 输入
```
1034 2
```
### 输出
```
3104
```

## 样例 #4
### 输入
```
9090000078001234 6
```
### 输出
```
9907000008001234
```

### 算法分类
贪心

### 题解综合分析与结论
这些题解思路基本一致，均采用贪心策略。核心思路是对于每一位数，在其之后的一定范围内寻找最大数并交换到当前位置，以保证高位数字尽可能大，从而使整个数最大。而这个范围由剩余交换次数和数的总长度决定。解决难点在于如何在有限交换次数内，准确找到合适位置的最大数并完成交换，同时要注意交换后剩余交换次数的更新以及数组或字符串元素移动时的覆盖问题。

### 所选的题解
- **作者：ToiletWater (5星)**
    - **关键亮点**：思路阐述详细，通过具体样例对比两种错误与正确贪心方案，清晰说明贪心策略。代码注释详尽，可读性强。
    - **核心代码片段**：
```cpp
void work() {
    for (int i = 1;i <= l;++i) {
        if (m == 0) break;
        int Max = i, p = min(l, m + i);
        for (int j = i + 1;j <= p;++j) 
            if (a[Max] < a[j]) Max = j;
        int k = a[Max];
        for (int j = Max - 1;j >= i;--j) a[j + 1] = a[j];
        a[i] = k;
        m -= (Max - i);
    }
}
```
    - **核心实现思想**：从前往后遍历每一位，在当前位到`min(l, m + i)`范围内找最大数位置`Max`，将该最大数移到当前位`i`，同时更新剩余交换次数`m`。
- **作者：FreedomKing (4星)**
    - **关键亮点**：思路简洁明了，直接指出贪心策略是把更大数移到更靠前位置，代码实现简洁。
    - **核心代码片段**：
```cpp
for(int i=1;i<=s.size();i++){
    maxn=i;
    for(int j=i+1;j<=i+tmpk&&j<=s.size();j++) if(a[j]>a[maxn]) maxn=j;
    for(int j=maxn;j>i;j--) swap(a[j],a[j-1]);
    tmpk-=(maxn-i);
}
```
    - **核心实现思想**：对每一位`i`，在`i+1`到`i + tmpk`且不超过数的长度范围内找最大数位置`maxn`，通过相邻交换将最大数移到`i`位置，并更新剩余交换次数`tmpk`。
- **作者：BotDand (4星)**
    - **关键亮点**：证明部分简洁地说明了贪心策略的正确性，代码简洁直观。
    - **核心代码片段**：
```cpp
for(int i=1;i<=len;++i)
{
    ma=i;
    for(int j=i+1;j<=i+k&&j<=len;++j) if(a[j]>a[ma]) ma=j;
    for(int j=ma;j>i;j--) swap(a[j],a[j-1]);
    k-=(ma-i);
}
```
    - **核心实现思想**：和其他题解类似，遍历每一位`i`，在`i+1`到`i + k`且不超过数长度范围内找最大数位置`ma`，通过相邻交换将其移到`i`位置，并更新剩余交换次数`k`。

### 最优关键思路或技巧
采用贪心策略，优先保证高位数字尽可能大。在实现过程中，利用循环遍历每一位，在可交换范围内寻找最大数并通过相邻交换将其移到当前位，同时实时更新剩余交换次数。在代码实现上，注意数组或字符串元素移动方向，避免数据覆盖问题。

### 拓展
同类型题通常围绕数字操作、在有限条件下求最值等场景。类似算法套路是在明确目标（如使数字最大）后，分析如何通过给定操作（如相邻元素交换），采用贪心策略逐步构造最优解。例如在一些序列操作题目中，根据规则对序列元素进行调整以达到最大或最小的目标值。

### 洛谷相似题目推荐
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及贪心策略，通过对数据的分析确定排序方式以得到最优解。
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)：同样运用贪心思想，根据不同机器加工时间等条件，合理安排任务顺序来优化总时间。
- [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：与本题类似，在给定数字和删除次数条件下，通过贪心策略删除数字使剩下数字组成的数最小。 

---
处理用时：67.43秒
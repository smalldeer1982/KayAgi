# 题目信息

# Count Good Substrings

## 题目描述

一个字符串是“好的”，当且仅当合并其中的连续区间后，它是一个回文串。比如“`aabba`”是好的，因为在合并后它变成了`aba`

给你一个字符串，现在要你分别求出长度为奇数和偶数的“好的”子串数量。（提示：不是本质不同的子串，不允许空串）

## 说明/提示

$1 \leq |s| \leq 10^5$，其中$|s|$是字符串的长度。

字符串只包含小写$a$和$b$两种字符。

## 样例 #1

### 输入

```
bb
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
baab
```

### 输出

```
2 4
```

## 样例 #3

### 输入

```
babb
```

### 输出

```
2 5
```

## 样例 #4

### 输入

```
babaa
```

### 输出

```
2 7
```

# AI分析结果

### 题目内容
# 统计好子串

## 题目描述
一个字符串是“好的”，当且仅当合并其中的连续区间后，它是一个回文串。比如“`aabba`”是好的，因为在合并后它变成了`aba`。
给你一个字符串，现在要你分别求出长度为奇数和偶数的“好的”子串数量。（提示：不是本质不同的子串，不允许空串）

## 说明/提示
$1 \leq |s| \leq 10^5$，其中$|s|$是字符串的长度。
字符串只包含小写$a$和$b$两种字符。

## 样例 #1
### 输入
```
bb
```
### 输出
```
1 2
```

## 样例 #2
### 输入
```
baab
```
### 输出
```
2 4
```

## 样例 #3
### 输入
```
babb
```
### 输出
```
2 5
```

## 样例 #4
### 输入
```
babaa
```
### 输出
```
2 7
```

### 算法分类
数学

### 综合分析与结论
所有题解均基于一个关键结论：由于字符串仅由`a`和`b`组成，好的子串等价于首尾字符相同的子串。在此基础上，部分题解先提出暴力枚举所有子串判断首尾字符的$O(n^2)$做法，然后通过优化，采用线性时间复杂度$O(n)$的算法，即遍历字符串，同时分别统计奇数位和偶数位上`a`和`b`的数量，根据当前字符位置的奇偶性以及字符种类，计算对长度为奇数和偶数的好子串数量的贡献。各题解思路相近，主要差异在于代码实现的细节和表达方式。

### 所选的题解
- **作者：2023gdgz01 (5星)**
    - **关键亮点**：先给出暴力解法并分析复杂度，再详细阐述优化思路，逻辑清晰，代码简洁明了，注释详细。
    - **个人心得**：强调开`long long`的重要性。
    - **重点代码**：
```cpp
#include <iostream>
#include <string>

using namespace std;

int len, t;
long long ans[2];
long long sum[2][2]; //sum[0][j] 表示 s 中偶数位上的字符为 char('a' + j) 的个数，sum[1][j] 表示 s 中奇数位上的字符为 char('a' + j) 的个数
string s;

int main() {
    cin >> s;
    len = s.size();
    for (register int i = 0; i < len; ++i) {
        ++ans[1]; //统计本身
        t = s[i] - 'a';
        if (i & 1) { //分别计算贡献
            ans[0] += sum[0][t];
            ans[1] += sum[1][t];
        }
        else {
            ans[0] += sum[1][t];
            ans[1] += sum[0][t];
        }
        ++sum[i & 1][t];
    }
    cout << ans[0] << " " << ans[1] << "\n";
    return 0;
}
```
    - **核心实现思想**：遍历字符串，每次先将当前字符自身作为一个子串统计到长度为奇数的子串数量中，然后根据当前字符位置的奇偶性，将之前相同奇偶性位置上相同字符的数量累加到长度为奇数的子串数量，将之前不同奇偶性位置上相同字符的数量累加到长度为偶数的子串数量，同时更新对应位置和字符的统计数量。
- **作者：叶ID (4星)**
    - **关键亮点**：解题思路清晰，先点明关键性质，再分字符分别计算，代码采用函数封装，结构清晰。
    - **重点代码**：
```cpp
// status: [Accepted]
// oj:     [luogu]

#include<bits/stdc++.h>
using namespace std;

string s;
typedef long long ll;
#define int ll

pair<int,int> solve(char c) {
    int st[2];
    pair<int,int> ret = make_pair(0,0);
    st[0] = st[1] = 0;
    for(int i=0;i<(int)s.length();i++) {
        if(s[i] == c) {
            st[i%2]++;
            ret.first += st[(i%2)^1];
            ret.second += st[(i%2)^0];
        }
    }
    return ret;
}

signed main() {
    ios::sync_with_stdio(false);

    cin>>s;

    pair<int,int> x1 = solve('a');
    pair<int,int> x2 = solve('b');

    cout<<x1.first+x2.first<<' '<<x1.second+x2.second<<endl;
}
```
    - **核心实现思想**：定义`solve`函数，针对单个字符，遍历字符串，当遇到该字符时，更新其在奇数位或偶数位的统计数量，并累加到对应奇偶长度子串的答案中。在主函数中分别对`a`和`b`调用`solve`函数并累加结果。
- **作者：Obviathy (4星)**
    - **关键亮点**：先给出暴力$O(n^2)$解法及代码，再详细分析优化到线性时间复杂度的思路，通过分类讨论清晰阐述如何统计不同奇偶长度的好子串，易于理解。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
# define ll long long
# define ull unsigned long long
# define file(x) freopen(x ".in","r",stdin),freopen(x ".out","w",stdout)
# define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
using namespace std;
const int N = 1e5+10;
char s[N];
ll ans0,ans1,cnt0[2],cnt1[2];
int main(){
    IOS;
    scanf("%s",s+1);
    int n = strlen(s+1);
    for(int i = 1;i <= n;i ++){
        ans1 ++;//注意不要漏下本身
        if(i & 1){
            ans1 += cnt1[s[i]-'a'];
            ans0 += cnt0[s[i]-'a'];
            cnt1[s[i]-'a']++;//奇数位置又多了一个的 s[i] 字符
        }else{
            ans1 += cnt0[s[i]-'a'];
            ans0 += cnt1[s[i]-'a'];
            cnt0[s[i]-'a']++;//偶数位置又多了一个的 s[i] 字符
        }
    }
    cout << ans0 << ' ' << ans1 << endl;
    return 0;
}
```
    - **核心实现思想**：遍历字符串，每次先将当前字符自身作为长度为奇数的子串统计，然后根据当前字符位置的奇偶性，从之前统计的相同字符在相应奇偶位置的数量中获取对奇偶长度子串数量的贡献，并更新对应位置和字符的统计数量。

### 最优关键思路或技巧
1. **核心结论**：利用字符串仅含`a`和`b`的特点，得出好子串等价于首尾字符相同的子串这一关键结论，大大简化问题。
2. **优化统计**：通过分别统计奇数位和偶数位上`a`和`b`的数量，在遍历字符串时，根据当前字符位置的奇偶性和字符种类，快速计算对不同长度好子串数量的贡献，将暴力$O(n^2)$的时间复杂度优化到$O(n)$。

### 可拓展之处
同类型题通常围绕字符串的特殊性质和子串统计，类似算法套路是先挖掘字符串的关键性质简化问题，再通过合适的数据结构（如这里简单的计数数组）优化统计过程。例如，对于由少量字符组成的字符串，判断子串在某种变换（如合并、替换等）后满足特定条件（如回文、递增等）的数量问题，都可尝试类似思路。

### 推荐题目
1. **P1308 统计单词数**：统计一个单词在给定字符串中出现的次数及首次出现位置，涉及字符串匹配和统计。
2. **P1903 [国家集训队]数颜色 / 维护队列**：在序列上进行颜色操作并查询，可类比这里对字符的统计和处理思想。
3. **P3370 【模板】字符串哈希**：通过字符串哈希解决字符串相关的查找、匹配等问题，与本题处理字符串子串有相似之处。 

---
处理用时：83.42秒
# 题目信息

# Little Pony and Harmony Chest

## 题目描述

### 题目背景

紫悦正在宇宙公主和月亮的城堡里研究和谐之元的宝箱。


对于一个正整数序列 $b_i$，当且仅当它的任意两个元素都互质时，这个序列 $b_i$ 才是和谐的。据古书记载，宝箱的钥匙是能让以下表达式的值最小的和谐序列 $b_i$：

$$ \sum_{i=1}^n|a_i-b_i| $$

现在紫悦已经得到了序列 $a_i$，你能帮助紫悦找到开启宝箱的钥匙吗？

## 样例 #1

### 输入

```
5
1 1 1 1 1
```

### 输出

```
1 1 1 1 1 ```

## 样例 #2

### 输入

```
5
1 6 4 2 8
```

### 输出

```
1 5 3 1 8 ```

# AI分析结果

### 题目内容
# 小马宝莉与和谐宝箱

## 题目描述

### 题目背景
紫悦正在宇宙公主和月亮的城堡里研究和谐之元的宝箱。

对于一个正整数序列 $b_i$，当且仅当它的任意两个元素都互质时，这个序列 $b_i$ 才是和谐的。据古书记载，宝箱的钥匙是能让以下表达式的值最小的和谐序列 $b_i$：

$$ \sum_{i=1}^n|a_i - b_i| $$

现在紫悦已经得到了序列 $a_i$，你能帮助紫悦找到开启宝箱的钥匙吗？

## 样例 #1
### 输入
```
5
1 1 1 1 1
```
### 输出
```
1 1 1 1 1 
```

## 样例 #2
### 输入
```
5
1 6 4 2 8
```
### 输出
```
1 5 3 1 8 
```

### 算法分类
动态规划

### 综合分析与结论
这些题解的核心思路都是基于动态规划结合数论知识来解决问题。由于 $a_i$ 的范围较小，通过证明得出 $b$ 中的元素所含质因子最大为 $53$，每个数均小于 $59$，$[2,53]$ 内质数共 $16$ 个，利用状态压缩来记录质因子的使用情况，从而进行动态规划。各题解的主要区别在于状态设计、转移方程的书写形式以及代码实现细节。

### 所选的题解
- **作者：周子衡 (5星)**
    - **关键亮点**：思路清晰，先给出关键引理和定理明确 $b$ 中元素质因子及范围，状态压缩动态规划的状态设计和转移方程表述清晰，代码简洁明了且有详细注释。
    - **重点代码**：
```cpp
// 计算得出[2,53]内的质数共16个，我们可以考虑状态压缩动态规划
const int prm[16]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
int table[54]={};
// 预处理能整除k的质数组成的集合
void out(int now_x,int now_y)
{
    if(!now_x)return;
    out(now_x - 1,now_y^table[way[now_x][now_y]]);
    printf("%d ",way[now_x][now_y]);
}
int main()
{
    int n = 0;scanf("%d",&n);
    for(int i = 1;i <= n;i++)scanf("%d",&a[i]);
    for(int i = 1;i <= 58;i++)
    {
        for(int j = 0;j < 16;j++)
        {
            if(i % prm[j] == 0)
            {
                table[i]^=(1<<j);
            }
        }
    }
    for(int i = 1;i <= n;i++)
    {
        for(int j = 0;j < (1<<16);j++)
        {
            dp[i][j]=1e9;
            for(int k = 1;k <= 58;k++)
            {
                if((table[k]|j)!=j)continue;
                int tmp = abs(k - a[i])+dp[i - 1][j^table[k]];
                if(tmp < dp[i][j])dp[i][j]=tmp,way[i][j]=k;
            }
        }
    }
    out(n,(1<<16)-1);
}
```
    - **核心实现思想**：通过 `table` 数组预处理每个数能被哪些质数整除，在动态规划过程中，对于前 $i$ 个数能用的质数集合为 $j$ 的状态，枚举每个决策 $k$，若 $k$ 能用集合 $j$ 中的质数乘出，则进行状态转移并记录方案。
- **作者：Durancer (4星)**
    - **关键亮点**：结合素数筛法，从唯一分解定理角度阐述使用质数的原因，状态转移方程解释较为详细，代码结构完整。
    - **重点代码**：
```cpp
// 预处理质数
void prepare()
{
    for(int i = 2;i <= 58;i++)
    {
        if(!vis[i]) prime[++cnt]=i;
        for(int j = 1;j <= cnt&&i * prime[j] <= N;j++)
        {
            vis[i * prime[j]]=true;
            if(i % prime[j] == 0)
                break;
        }
    }
    for(int i = 1;i <= 58;i++)
    {
        for(int j = 1;j <= 16;j++)
            if(i % prime[j] == 0) 
                Ming[i]|=(1<<(j - 1));
    }
}
void work(int x,int i)
{
    if(x == 0) return;
    work(x - 1,(i^Ming[g[x][i]]));
    printf("%d ",g[x][i]);
}
int main()
{
    n = read();
    for(int i = 1;i <= n;i++)
        a[i]=read();
    prepare();
    for(int i = 1;i <= n;i++)
        for(int j = 0;j < M;j++)
        {
            f[i][j]=0x3f3f3f3f;
            for(int k = 1;k <= 58;k++)
            {
                if((Ming[k]|j)!=j) continue;
                imp = f[i - 1][j^Ming[k]]+abs(k - a[i]);
                if(imp < f[i][j])
                {
                    f[i][j]=imp;
                    g[i][j]=k;
                }
            }
        }
    work(n,M - 1);
    return 0;
}
```
    - **核心实现思想**：先通过 `prepare` 函数筛出质数并预处理每个数能被整除的质数集合 `Ming`，在动态规划时，枚举前 $i$ 个数的状态 $j$ 和决策 $k$，若 $k$ 对应的质数集合是 $j$ 的子集则转移，并记录最优方案。
- **作者：cold_cold (4星)**
    - **关键亮点**：问题思考和状态构思部分清晰，逐步引导状态设计，代码逻辑清晰，详细展示动态规划各步骤。
    - **重点代码**：
```cpp
// 预处理质数
for(int i = 2; i < M; ++ i)
{
    if(!fg[i]) p[++p[0]] = i;
    for(int j = 1; j <= p[0] && i * p[j] < M; ++ j)
        fg[i * p[j]] = 1;
}
// 预处理每个数的质因子所代表的状态
for(int i = 1; i < M; ++ i)
{
    g[i] = 0;
    for(int j = 1; j <= p[0]; ++ j)
        if(i % p[j] == 0) g[i] |= 1 << (j - 1);
}
// 动态规划主过程
int ns = 1 << p[0];
for(int i = 1; i <= n + 1; ++ i)
    for(int j = 0; j < ns; ++ j) f[i][j] = S;
f[1][0] = 0;
for(int i = 1; i <= n; ++ i)
    for(int j = 0; j < ns; ++ j) if(f[i][j] < S)
        for(int k = 1; k < M; ++ k)
            if((g[k] & j) == 0)
            {
                int t = f[i][j] + absp(k - a[i]);
                if(t < f[i+1][g[k] | j])
                    f[i+1][g[k] | j] = t,
                    opt[i+1][g[k] | j] = k;
            }
// 记录最优值所对应的状态
int ansp = S;
int ansm = 0;
for(int j = 0;  j < ns; ++ j)
    if(f[n+1][j] < ansp) ansp = f[n+1][j], ansm = j;
for(int i = n+1; i > 1; -- i)
{
    b[i-1] = opt[i][ansm];
    ansm ^= g[b[i-1]];
}
```
    - **核心实现思想**：先预处理质数和每个数质因子代表的状态，动态规划时，枚举前 $i$ 个数的状态 $j$ 和当前位置的数 $k$，若 $k$ 的质因子与已用质因子无重复则进行状态转移并记录决策，最后通过记录的决策回溯得到最优序列。

### 最优关键思路或技巧
利用数论知识确定 $b$ 序列元素范围和质因子范围，通过状态压缩动态规划，将质因子使用情况用二进制状态表示，在动态规划过程中，依据状态转移方程，枚举状态和决策进行最优解求解，并通过额外数组记录方案。

### 可拓展之处
此类题目属于结合数论与动态规划的问题，类似套路是先分析数据范围，利用数论性质缩小搜索空间，再通过状态压缩记录关键信息进行动态规划。同类型题通常会在数论条件和动态规划状态设计上变化，比如改变互质条件或者增加其他限制。

### 洛谷相似题目推荐
- [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)：同样是状态压缩动态规划，结合棋盘放置限制求方案数。
- [P1879 [USACO06NOV]Corn Fields G](https://www.luogu.com.cn/problem/P1879)：在方格放置限制下，用状态压缩动态规划求方案数。
- [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)：通过状态压缩动态规划解决合并数字的问题。

### 个人心得摘录与总结
暂未发现题解中有个人心得相关内容。 

---
处理用时：77.48秒
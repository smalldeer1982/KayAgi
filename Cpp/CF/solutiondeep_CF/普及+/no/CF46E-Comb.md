# 题目信息

# Comb

## 题目描述

### 题面描述



克服所有困难以后，劳拉发现她在一间有宝藏的屋子里。令她惊讶的是，那里没有堆积成山的金子。环顾四周，她注意到在地面上有一个大小为 $n\times m$ 个格子的桌子，桌子的每个格子上有一个数字。墙边有无数石头。桌边的柱子上有一条告示。告示上说，为了拿到宝藏，对桌子的每一行都必须选择从第一个格子开始连续的几个格子（不能为0）并且将石头放在上面，将这些格子压下去。那之后她会得到很多金币，数目等同于所有压下去的格子上的数字之和。劳拉很快决定了如何放置石头，但在她开始之前她注意到了告示下面的一行小字。根据这行字，为了不让天花板掉下来并砸死探险者，探险者选择的格子要形成一个`Comb`。如果令 $c_i$ 表示第 $i$ 行选择的格子数量，那么选择的格子能形成一个`Comb`当且仅当 $c_1>c_2<c_3>c_4\ldots$ ，就是相邻的不等号方向不同。现在劳拉很迷惑，停止了思考，不知道要怎么做。帮她判断她最多能获得多少金币，同时活下来。



### 简要题意



有 $n\times m$ 个数组成一个矩阵，第 $i$ 行选择前 $c_i>0$ 个数 $a_{i,1},a_{i,2},\ldots,a_{i,c_i}$ ，问满足 $c_1>c_2<c_3>c_4\ldots$ 的前提下 $\sum_{i=1}^n\sum_{j=1}^{c_i}a_{i,j}$ 的最大值是多少。

## 样例 #1

### 输入

```
2 2
-1 2
1 3
```

### 输出

```
2
```

# AI分析结果

### 题目内容
# Comb

## 题目描述

### 题面描述

克服所有困难以后，劳拉发现她在一间有宝藏的屋子里。令她惊讶的是，那里没有堆积成山的金子。环顾四周，她注意到在地面上有一个大小为 $n\times m$ 个格子的桌子，桌子的每个格子上有一个数字。墙边有无数石头。桌边的柱子上有一条告示。告示上说，为了拿到宝藏，对桌子的每一行都必须选择从第一个格子开始连续的几个格子（不能为0）并且将石头放在上面，将这些格子压下去。那之后她会得到很多金币，数目等同于所有压下去的格子上的数字之和。劳拉很快决定了如何放置石头，但在她开始之前她注意到了告示下面的一行小字。根据这行字，为了不让天花板掉下来并砸死探险者，探险者选择的格子要形成一个`Comb`。如果令 $c_i$ 表示第 $i$ 行选择的格子数量，那么选择的格子能形成一个`Comb`当且仅当 $c_1>c_2<c_3>c_4\ldots$ ，就是相邻的不等号方向不同。现在劳拉很迷惑，停止了思考，不知道要怎么做。帮她判断她最多能获得多少金币，同时活下来。

### 简要题意

有 $n\times m$ 个数组成一个矩阵，第 $i$ 行选择前 $c_i>0$ 个数 $a_{i,1},a_{i,2},\ldots,a_{i,c_i}$ ，问满足 $c_1>c_2<c_3>c_4\ldots$ 的前提下 $\sum_{i=1}^n\sum_{j=1}^{c_i}a_{i,j}$ 的最大值是多少。

## 样例 #1

### 输入
```
2 2
-1 2
1 3
```

### 输出
```
2
```

### 算法分类
动态规划

### 综合分析与结论
这些题解都围绕动态规划算法解决问题，核心思路是通过设计状态和状态转移方程求解。不同题解在优化方式和代码实现细节上有差异，主要难点在于状态转移方程的设计以及如何优化时间复杂度。
1. **思路方面**：都以 $dp_{i,j}$ 表示第 $i$ 行选择 $j$ 个格子时的最大和，根据 $i$ 的奇偶性进行状态转移。
2. **算法要点**：多数题解利用前缀和优化对每行数字和的计算，部分题解还通过维护前缀最大值和后缀最大值进一步优化状态转移。
3. **解决难点**：优化时间复杂度是关键，从最初 $O(n^4)$ 的朴素转移优化到 $O(nm)$ 。如通过在 $k$ 循环时顺便求 $l$ 的循环和，改变循环顺序，利用每次 $j$ 增加时 $k$ 取值范围的变化等方式优化。

### 所选的题解
- **作者：E1_de5truct0r (5星)**
    - **关键亮点**：详细阐述了从朴素 $O(n^4)$ 算法逐步优化到 $O(nm)$ 的过程，包括优化一将 $O(n^4)$ 降到 $O(n^3)$，优化二利用 $k$ 取值范围随 $j$ 变化的特点进一步优化到 $O(nm)$，代码实现清晰且有详细注释。
    - **个人心得**：提到该题很练习代码能力，自己调试了50分钟才做出。
    - **重点代码**：
```cpp
if(i&1)
{
    int sum=0; //前缀和
    for(int j=1;j<=m;j++)
    {
        sum+=a[i][j];
        dp[i][j]=max(dp[i][j-1]-sum+a[i][j]/*因为这里每次转移之后加上了 sum 所以还原的时候要减掉 sum*/,dp[i-1][j-1])+sum; //转移
    }
}
else
{
    int sum=0;
    for(int j=1;j<=m;j++) sum+=a[i][j]; //由于是倒序需要先预处理
    for(int j=m;j>=1;j--)
    {
        dp[i][j]=max(dp[i][j+1]-sum-a[i][j+1],dp[i-1][j+1])+sum;
        sum-=a[i][j]; //每次减掉已经用完的
    }
}
```
    - **核心实现思想**：根据 $i$ 的奇偶性分别处理，奇数行正序遍历 $j$，利用上一次 $dp_{i,j - 1}$ 和 $dp_{i - 1,j - 1}$ 进行转移并维护前缀和；偶数行倒序遍历 $j$，类似地利用 $dp_{i,j + 1}$ 和 $dp_{i - 1,j + 1}$ 转移并维护前缀和。
- **作者：pikabi (4星)**
    - **关键亮点**：思路清晰，通过预处理前缀和 `sum`，并定义 $f_{i,j}$ 表示第 $i$ 行第 $j$ 列最大值，$g_{i,j}$ 表示第 $i$ 行前 $j$ 个 $f_{i,j}$ 的最大值，$t_{i,j}$ 表示其后 $m - j + 1$ 个的最大值，简洁地完成状态转移和答案求解。
    - **重点代码**：
```cpp
for(int i = 1; i <= n; i++){
    g[i][0] = -inf;
    t[i][m + 1] = -inf;
    for(int j = 1; j <= m; j++){
        if(i % 2){
            f[i][j] = g[i - 1][j - 1] + sum[i][j];
        }
        else {
            f[i][j] = t[i - 1][j + 1] + sum[i][j];
        }
        g[i][j] = max(g[i][j - 1], f[i][j]);
    }
    for(int j = m; j >= 1; j--){
        t[i][j] = max(t[i][j + 1], f[i][j]);
    }
}
```
    - **核心实现思想**：根据 $i$ 的奇偶性，利用 $g$ 和 $t$ 数组维护的最值来更新 $f$ 数组，从而得到每行每个位置的最大值，最后从最后一行的 $f$ 数组中取最大值作为答案。
- **作者：lgx57 (4星)**
    - **关键亮点**：简洁明了地阐述思路，通过预处理前缀和，设计状态转移方程，利用前缀 $\max$ 与后缀 $\max$ 将复杂度优化到 $O(nm)$。
    - **重点代码**：无具体代码片段，但状态转移方程为
$$dp_{i,j}=\begin{cases} sum_{i,j}+\displaystyle\max_{k=1}^{j-1} dp_{i-1,k} & i \bmod 2 = 1 \\ sum_{i,j}+\displaystyle\max_{k=j+1}^{m} dp_{i-1,k} & i \bmod 2 = 0\end{cases}$$
    - **核心实现思想**：根据 $i$ 的奇偶性，分别结合上一行对应范围的 $dp$ 最大值与当前行的前缀和进行状态转移。

### 最优关键思路或技巧
1. **利用前缀和优化**：预处理每行的前缀和，减少重复计算数字和的时间开销。
2. **维护前缀和后缀最大值**：通过维护上一行的前缀最大值和后缀最大值，在状态转移时可以 $O(1)$ 查询所需的最大值，从而将时间复杂度从 $O(nm^2)$ 优化到 $O(nm)$。

### 可拓展思路
同类型题通常围绕矩阵元素选择，结合特定的选择规则求最值。类似算法套路是设计合适的状态表示，根据题目规则确定状态转移方程，并通过前缀和、最值维护等方式优化。

### 洛谷相似题目
1. **P1896 [SCOI2005]互不侵犯**：同样是基于二维状态的动态规划问题，在棋盘上放置棋子并满足一定限制条件求方案数。
2. **P1006 传纸条**：涉及二维矩阵上的路径规划，通过动态规划求最优路径的最大权值和，与本题在状态设计和转移上有相似之处。
3. **P2704 [NOI2001] 炮兵阵地**：在二维地图上放置炮兵，满足特定条件下求最大放置数量，也是通过动态规划解决，并需要对状态进行优化。 

---
处理用时：87.52秒
# 题目信息

# New Year Santa Network

## 题目描述

一个 $n$ 个节点的树上进行 $q$ 次操作，每次操作将第 $r$ 条边的长度修改成 $w$。

用 $d(x,y)$ 表示从点 $x$ 到 $y$ 的距离。

在树上等概率选取三个点 $c_1,c_2,c_3$ ，求在每次操作后 $d(c_1,c_2)+d(c_1,c_3)+d(c_2,c_3)$ 的期望值。

## 样例 #1

### 输入

```
3
2 3 5
1 3 3
5
1 4
2 2
1 2
2 1
1 1
```

### 输出

```
14.0000000000
12.0000000000
8.0000000000
6.0000000000
4.0000000000
```

## 样例 #2

### 输入

```
6
1 5 3
5 3 2
6 1 7
1 4 4
5 2 3
5
1 2
2 1
3 5
4 1
5 2
```

### 输出

```
19.6000000000
18.6000000000
16.6000000000
13.6000000000
12.6000000000
```

# AI分析结果

### 题目内容
# 新年圣诞老人网络

## 题目描述
一个有 \(n\) 个节点的树上进行 \(q\) 次操作，每次操作将第 \(r\) 条边的长度修改成 \(w\) 。
用 \(d(x,y)\) 表示从点 \(x\) 到 \(y\) 的距离。
在树上等概率选取三个点 \(c_1\)，\(c_2\)，\(c_3\) ，求在每次操作后 \(d(c_1,c_2)+d(c_1,c_3)+d(c_2,c_3)\) 的期望值。

## 样例 #1
### 输入
```
3
2 3 5
1 3 3
5
1 4
2 2
1 2
2 1
1 1
```
### 输出
```
14.0000000000
12.0000000000
8.0000000000
6.0000000000
4.0000000000
```

## 样例 #2
### 输入
```
6
1 5 3
5 3 2
6 1 7
1 4 4
5 2 3
5
1 2
2 1
3 5
4 1
5 2
```
### 输出
```
19.6000000000
18.6000000000
16.6000000000
13.6000000000
12.6000000000
```

### 算法分类
概率论、组合数学

### 题解综合分析与结论
这几道题解的核心思路都是将计算三个点间距离和的期望值转化为统计每条边对期望值的贡献。难点在于准确计算每条边的贡献次数以及处理边权修改操作。

hs_black 的题解，思路清晰，代码简洁，直接从组合数的角度计算每条边的贡献，通过预处理和简单的DFS遍历树结构，快速更新每次操作后的期望值，代码可读性高。
Rt__ 的题解，通过排列组合公式详细推导了边的贡献计算方式，代码实现中利用杨辉三角预处理组合数，虽然推导过程详细，但代码相对复杂一些。
dgdyrkst 的题解，同样从边的贡献出发，通过分类讨论计算边被经过的次数，代码实现简洁明了，对边权修改操作的处理也很清晰。
Arcturus1350 的题解，思路相对简单直接，但在计算边的贡献次数上解释不够详细，代码实现中部分变量命名不太直观，可读性稍差。

综合来看，hs_black、Rt__、dgdyrkst的题解质量较高，在思路清晰度和代码实现上都有较好的表现。

### 所选的题解
- **hs_black（5星）**
  - **关键亮点**：思路简洁清晰，直接从组合数角度计算边的贡献，代码实现简洁高效，对边权修改操作处理巧妙。
  - **核心代码片段**：
```cpp
ll work(int x,int y,int val) {
    if (f[y] == x) swap(x, y);
    ll sx = siz[x], sy = n - sx;
    ll ans = 0;
    ans = (sx * (sx-1) / 2 * sy) + (sx * sy * (sy - 1) / 2);
    return ans * val;
}

int main()
{
    read(n);
    ll tmp = (ll) n * (n-1) * (n-2) / 6;
    for (int i = 1;i < n; i++) {
        read(x[i]), read(y[i]), read(val[i]);
        add(x[i], y[i], val[i]);
        add(y[i], x[i], val[i]);
    }
    dfs(1, 0);
    ll ans = 0;
    for (int i = 1;i < n; i++) ans += 2 * work(x[i], y[i], val[i]);
    read(m);
    for (int i = 1;i <= m; i++) {
        int a, b; read(a), read(b);
        ans -= 2 *work(x[a], y[a], val[a]);
        val[a] = b;
        ans += 2 * work(x[a], y[a], val[a]);
        cout << fixed << setprecision(8) << ans / tmp << endl;
    }
    return 0;
}
```
  - **核心实现思想**：`work`函数计算每条边的贡献，在`main`函数中，先预处理树结构并计算初始期望值，每次操作时通过增加和减去对应边的旧贡献和新贡献来更新期望值。

- **Rt__（4星）**
  - **关键亮点**：对边的贡献计算通过排列组合公式进行详细推导，逻辑严谨，代码实现中利用杨辉三角预处理组合数，便于计算。
  - **核心代码片段**：
```cpp
void dfss(int u, int fa){
    for(int i = h[u]; i!= -1; i = ne[i]){
        int j = e[i];
        if(j == fa)continue;
        dfss(j, u);
        int mid = deep[u] < deep[j]? j : u;
        ans += (C[siz[mid]][1] * C[n - siz[mid]][2] + C[siz[mid]][2] * C[n - siz[mid]][1]) * w[i] * 1.0 / C[n][3];
    }
}
signed main(){
    memset(h, -1, sizeof h);
    init();
    cin >> n;
    for(int i = 1; i < n; i ++){
        int u, v, w;
        cin >> u >> v >> w;
        edge[i] = {u, v, w};
        add(u, v, w);
        add(v, u, w);
    }
    dfs(1, 0);
    dfss(1, 0);
    int q;
    cin >> q;
    while(q --){
        int a, b;
        cin >> a >> b;
        int u = edge[a]. u, v = edge[a]. v;
        int mid = deep[u] < deep[v]? v : u;
        ans -= (C[siz[mid]][1] * C[n - siz[mid]][2] + C[siz[mid]][2] * C[n - siz[mid]][1]) * (edge[a]. w - b) * 1.0 / C[n][3];
        edge[a]. w = b;
        printf("%.7lf \n", ans * 2.0);
    }
    return 0;
}
```
  - **核心实现思想**：`dfss`函数遍历树结构计算每条边的贡献，在`main`函数中，先预处理组合数和树结构，计算初始期望值，每次操作时通过增加和减去对应边的贡献变化量来更新期望值。

- **dgdyrkst（4星）**
  - **关键亮点**：通过分类讨论清晰地计算出每条边被经过的次数，代码简洁，对边权修改操作处理直观。
  - **核心代码片段**：
```cpp
void dfs(ll now,ll fa)
{
    siz[now]=1;
    for (ll i=head[now];i;i=ne[i])
    {
        if (i==fa)continue;
        dfs(to[i],i^1);
        siz[now]+=siz[to[i]];
    }
    cnt[fa]=cnt[fa^1]=siz[now]*(siz[now]-1)*(n-siz[now])+siz[now]*(n-siz[now])*(n-siz[now]-1);
    if (fa)ans+=cnt[fa]*w[fa];
}
signed main()
{
    cin >> n;
    for (ll i=1;i<n;i++)
    {
        cin >> a >> b >> d;
        add(),swap(a,b),add();
    }
    dfs(1,0);
    cin >> q;
    while (q--)
    {
        cin >> a >> d;
        a<<=1;
        ans-=cnt[a]*w[a];
        w[a]=d;
        ans+=cnt[a]*d;
        printf("%.10Lf\n",(long double)ans*6/n/(n-1)/(n-2));
    }
    return 0;
}
```
  - **核心实现思想**：`dfs`函数遍历树结构计算每条边被经过的次数`cnt`并累计初始贡献`ans`，在`main`函数中，每次操作时通过增加和减去对应边的旧贡献和新贡献来更新期望值。

### 最优关键思路或技巧
将计算三个点间距离和的期望值转化为统计每条边对期望值的贡献，通过DFS遍历树结构获取子树大小等信息，进而计算每条边的贡献。在处理边权修改操作时，通过先减去旧边权贡献再加上新边权贡献的方式高效更新期望值。

### 可拓展之处
同类型题通常围绕树上的概率、期望计算，类似算法套路是将复杂的全局统计转化为局部（边或点）的贡献统计，再通过树的遍历（如DFS、BFS）获取必要信息进行计算。

### 洛谷相似题目推荐
- [P3802 小魔女帕琪](https://www.luogu.com.cn/problem/P3802)
- [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)
- [P4135 作诗](https://www.luogu.com.cn/problem/P4135)

### 个人心得摘录与总结
Arcturus1350提到要注意 \(n\) 个节点的树有 \(n - 1\) 条边，在处理边相关操作时，边的数量容易出错，这是在解决树相关问题时需要特别留意的细节。 

---
处理用时：87.32秒
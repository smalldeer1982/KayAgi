# 题目信息

# Pretty Song

## 题目描述

给你一个字符串，计算一下它的优美程度。
   	优美程度是指它的所有每一段连续子串优美程度的和。
    优美程度的计算方法：这一段连续子串中I，E，A，O，U，Y的总数/字符串长度。

## 说明/提示

在第一个样例中，所有的字母都是I，E，A，O，U，Y其中的一个。每个子串的优美程度为1。长度为7的字符串有28个连续子串。所以这个字符串的优美程度为28.

## 样例 #1

### 输入

```
IEAIAIO
```

### 输出

```
28.0000000
```

## 样例 #2

### 输入

```
BYOB
```

### 输出

```
5.8333333
```

## 样例 #3

### 输入

```
YISVOWEL
```

### 输出

```
17.0500000
```

# AI分析结果

### 题目内容
# 优美的歌曲

## 题目描述
给你一个字符串，计算它的优美程度。
优美程度指它所有每一段连续子串优美程度的和。
优美程度的计算方法：这一段连续子串中I，E，A，O，U，Y的总数/字符串长度。

## 说明/提示
在第一个样例中，所有的字母都是I，E，A，O，U，Y其中的一个。每个子串的优美程度为1。长度为7的字符串有28个连续子串。所以这个字符串的优美程度为28。

## 样例 #1
### 输入
```
IEAIAIO
```
### 输出
```
28.0000000
```

## 样例 #2
### 输入
```
BYOB
```
### 输出
```
5.8333333
```

## 样例 #3
### 输入
```
YISVOWEL
```
### 输出
```
17.0500000
```

### 算法分类
数学

### 综合分析与结论
各题解主要围绕如何优化计算所有连续子串优美程度之和展开。思路上大致分为两类，一类是通过拆贡献，利用前缀和、后缀和等方式优化计算；另一类是通过特殊的技巧如卷积、差分等优化。
- **思路方面**：多数题解从子串的角度出发，考虑每个字符对不同长度子串的贡献，进而计算总优美程度。如tyccyt通过后缀和来计算子串贡献，RealKzos通过扫描线和增量的方式计算特殊字符贡献。
- **算法要点**：littlez_meow利用字符串技巧将子串转化为前缀的后缀，通过递推和卷积优化；tyccyt通过DP和拆贡献，利用后缀和数组优化计算；RealKzos通过预处理和扫描线增量计算贡献。
- **解决难点**：难点在于如何高效计算所有子串的优美程度。各题解通过不同方式优化，如卷积、后缀和数组、扫描线增量等，避免了暴力枚举子串带来的高复杂度。

### 所选的题解
- **作者：littlez_meow（5星）**
  - **关键亮点**：将元音字母变为1，其余为0，利用字符串经典技巧将子串转化为前缀的后缀，通过递推式计算优美程度，利用卷积优化关键项，思路新颖且巧妙。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
// 省略头文件及部分定义
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>str;
    n=strlen(str);
    F(i,0,n-1) s[i+1]=turn(str[i]),tiaohejishu[i+1]=tiaohejishu[i]+1.0/(i+1);
    F(i,1,n) poly[i].real(s[i]),poly[i].imag(1.0/i),sum[i]=sum[i-1]+s[i];
    if(sum[n]==0) return cout<<"0",0; 
    int len(n<<1);
    len=1<<max(1,(int)ceil(log2(len)));
    F(i,0,len-1) F(j,0,log2(len-1)){
        rev[i]<<=1;
        rev[i]|=((i>>j)&1);
    }
    FFT(len,1);
    F(i,0,len-1) poly[i]*=poly[i];
    FFT(len,-1);
    dp[1]=s[1];
    F(i,2,n){
        dp[i]=dp[i-1]-poly[i].imag();
        s[i]&&(dp[i]+=tiaohejishu[i-1]);
        dp[i]+=1.0*sum[i]/i;
    }
    F(i,2,n) dp[i]+=dp[i-1];
    cout<<fixed<<setprecision(8)<<dp[n];
    return 0;
}
```
核心实现思想：先将字符串处理为01串，预处理前缀和与调和级数，利用FFT进行卷积计算关键项，通过递推式计算每个前缀的优美程度，最后累加得到结果。

- **作者：tyccyt（4星）**
  - **关键亮点**：通过定义后缀和数组，利用拆贡献的方式，巧妙地从长度i - 1的子串结果递推到长度i的子串结果，优化了计算过程。
  - **个人心得**：无
  - **核心代码片段**：无完整代码，核心思路代码如下：
```cpp
// 假设suf数组已定义并初始化
// f数组存储不同长度子串的贡献和
f[1] = suf[1] - suf[2];
for (int i = 2; i <= n; i++) {
    f[i] = f[i - 1] + suf[i] - suf[n - i + 2];
}
double ans = 0;
for (int i = 1; i <= n; i++) {
    ans += f[i] / (1.0 * i);
}
```
核心实现思想：通过后缀和数组计算不同长度子串的贡献，从长度1开始递推，每次递推考虑新增和减少的子串贡献，最后累加得到总优美程度。

- **作者：RealKzos（4星）**
  - **关键亮点**：采用扫描线 + 增量的方式，通过分析当前位置和下一个位置贡献的变化，找到规律并预处理相关值，简化计算过程。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
const int N = 5e5 + 10;
char s[N];
int n;
long double A[N], ans, las;

inline int check(char ch) {
    if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch == 'Y') return 1;
    return 0;
}

int main() {
    scanf("%s", s + 1);
    ans = 0.0;
    n = strlen(s + 1);
    ROF(i, n, 1) A[n - i + 1] = A[n - i] + (long double)1.0 / (long double)i;
    las = A[n];
    if (check(s[1])) ans += las;
    FOR(i, 2, n) {
        int a = i - 1, b = n - a;
        las = las - A[a] + A[b];
        if (check(s[i])) ans += las;
    }
    printf("%.15Lf\n", ans);
    return 0;
}
```
核心实现思想：预处理出特定式子的值，扫描字符串，对于每个特殊字符，根据扫描线增量更新当前贡献并累加到总答案中。

### 最优关键思路或技巧
将子串问题转化为字符对不同长度子串的贡献问题，通过前缀和、后缀和、递推、卷积等方式优化计算过程，避免暴力枚举子串，从而降低时间复杂度。

### 可拓展之处
同类型题常考察对字符串子串相关性质的计算与优化，类似算法套路有拆贡献、利用前缀和后缀优化、通过递推或动态规划降低复杂度等。

### 洛谷题目推荐
- [P1303 A*B Problem](https://www.luogu.com.cn/problem/P1303)：高精度乘法，涉及基本的数学运算优化。
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：通过数学分析和枚举优化解决连续自然数和的问题，与本题分析子串贡献思路类似。
- [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：利用前缀和、离散化等优化计算区间不同元素个数，与本题优化计算子串相关量思路类似。 

---
处理用时：74.28秒
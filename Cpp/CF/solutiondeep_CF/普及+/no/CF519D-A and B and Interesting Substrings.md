# 题目信息

# A and B and Interesting Substrings

## 题目描述

# A 与 B 与有趣的子串

## 题目大意

给定每个小写字母一个数值，给定一个只包含小写字母的字符串 $s$，求 $s$ 的子串 $t$ 个数，使 $t$ 满足：

- 首尾字母相同，长度大于 $1$。
- 首尾字母除外的其余字母的数值之和为 $0$。


A 与 B 正在为程序设计竞赛做准备。

经历了数年的编程，做了很多需要对各种古怪对象进行计算的题目，A 与 B 也形成了独特的喜好。

A 喜爱小写字母。他给定每个字母一个数值，来描述对这个字母的喜爱程度。

B 喜爱子串。他尤其喜爱首尾字母相同的子串（长度大于 $1$）。

并且，A 与 B 有一个字符串 $s$。他们尝试计算出，字符串 $s$ 的子串 $t$ 的个数，其中 $t$ 是 B 喜爱的（即，$t$ 的首尾字母相同且长度大于$1$），且首尾字母除外的所有字母的数值（由 A 给定）之和等于 $0$。

自然地，A 与 B 很快计算出了他们喜爱的子串 $t$ 的个数。你可以算出吗？

## 说明/提示

第一组样例中，满足条件的子串有 $abca$ 与 $bcab$。

第二组样例中，满足条件的子串是两次出现的 $aa$。

Translated by @Capella

## 样例 #1

### 输入

```
1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1
xabcab
```

### 输出

```
2
```

## 样例 #2

### 输入

```
1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1
aaa
```

### 输出

```
2
```

# AI分析结果

### 题目内容
# A and B and Interesting Substrings

## 题目描述

# A 与 B 与有趣的子串

## 题目大意

给定每个小写字母一个数值，给定一个只包含小写字母的字符串 $s$，求 $s$ 的子串 $t$ 个数，使 $t$ 满足：
- 首尾字母相同，长度大于 $1$。
- 首尾字母除外的其余字母的数值之和为 $0$。

A 与 B 正在为程序设计竞赛做准备。
经历了数年的编程，做了很多需要对各种古怪对象进行计算的题目，A 与 B 也形成了独特的喜好。
A 喜爱小写字母。他给定每个字母一个数值，来描述对这个字母的喜爱程度。
B 喜爱子串。他尤其喜爱首尾字母相同的子串（长度大于 $1$）。
并且，A 与 B 有一个字符串 $s$。他们尝试计算出，字符串 $s$ 的子串 $t$ 的个数，其中 $t$ 是 B 喜爱的（即，$t$ 的首尾字母相同且长度大于$1$），且首尾字母除外的所有字母的数值（由 A 给定）之和等于 $0$。
自然地，A 与 B 很快计算出了他们喜爱的子串 $t$ 的个数。你可以算出吗？

## 说明/提示
第一组样例中，满足条件的子串有 $abca$ 与 $bcab$。
第二组样例中，满足条件的子串是两次出现的 $aa$。
Translated by @Capella

## 样例 #1
### 输入
```
1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1
xabcab
```
### 输出
```
2
```

## 样例 #2
### 输入
```
1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1
aaa
```
### 输出
```
2
```

### 算法分类
前缀和

### 综合分析与结论
这些题解的核心思路都是利用前缀和来解决问题，通过不同方式记录和查找满足条件的子串。主要区别在于记录信息的数据结构和具体实现细节。

1. **HansLimon**：使用结构体和`map`记录每个字符及其前缀和，遍历字符串时，若当前字符与之前某字符相同且对应前缀和相同则符合条件。优点是代码简洁明了，直接利用`map`的特性解决问题。
2. **2011Andy**：利用`map<pair<char, int>, int>`记录每个字母和当前字母数值之和的组合出现次数，遍历字符串过程中累加满足条件的子串个数，思路直接，代码实现简单易懂。
3. **codeLJH114514**：分字母分别考虑，找到每个字母的所有位置，通过两次前缀和处理段和及段和的前缀和，再用`unordered_map`统计满足条件的对数，虽然实现相对复杂，但逻辑清晰，对问题的分析较为深入。
4. **寒鸽儿**：先提出暴力做法，再优化为用`map`记录前缀和，类似KMP思想，通过记录之前字串有效信息来优化暴力枚举，代码简洁，体现从暴力到优化的过程。
5. **zhengrunzhe**：将同种字母位置放入`vector`，枚举字母并利用`map`作为桶记录前缀和出现次数来累计答案，思路清晰，实现直接。

### 所选的题解
- **HansLimon（5星）**
    - **关键亮点**：代码简洁高效，巧妙利用结构体和`map`结合的方式记录信息，快速判断满足条件的子串。
    - **重点代码核心实现思想**：遍历字符串，每次更新前缀和，并通过`map`查找之前是否有相同字符且相同前缀和的情况，有则累计满足条件的子串个数。
    ```cpp
    for (register int i = 1;i <= 26;i ++)scanf("%d", &words[i]);
    getchar();
    while (now = getchar(), now!= 10){
        otp += corder[(points){bef, now}];
        bef += words[now - 'a' + 1];
        corder[(points){bef, now}] ++;
    }
    ```
- **2011Andy（5星）**
    - **关键亮点**：思路直接清晰，利用`map`记录字母与前缀和组合的出现次数，代码实现简洁易懂。
    - **重点代码核心实现思想**：遍历字符串，每次判断当前字母与当前前缀和的组合是否在`map`中已存在，存在则累计满足条件的子串个数，同时更新前缀和及`map`中的记录。
    ```cpp
    for(int i = 0 ; i < s.size() ; i++){ 
        if(mp[{s[i], sum}]!= 0){ 
            ans += mp[{s[i], sum}]; 
        }  
        sum += a[s[i] - 'a' + 1]; 
        mp[{s[i], sum}]++; 
    } 
    ```
- **codeLJH114514（4星）**
    - **关键亮点**：对问题分析深入，分字母处理并通过两次前缀和将问题转化为在序列上找满足特定条件的对数，逻辑严谨。
    - **重点代码核心实现思想**：先对每个字母找到其所有位置，处理段和及段和的前缀和，最后利用`unordered_map`统计满足`a_r - a_{l - 1} = score_c`的对数。
    ```cpp
    for (int i = 1; i <= 26; i++) {
        char letter = 'a' + i - 1;
        int scr = score[i];

        std::vector<int> lts;
        findletters(lts, letter);

        if (lts.size() <= 1) continue;

        getdifferences(lts);

        std::deque<int> pfs;
        pfs.push_back(0);

        if (lts.size()) {
            pfs.push_back(lts[0]);
            for (int i = 1; i < lts.size(); i++)
                pfs.push_back(pfs.back() + lts[i] + scr);
        }
        
        pfs.pop_front();

        std::unordered_map<int, int> appeared;
        appeared[-scr] += 1;
        for (int i = 0; i < pfs.size(); i++) {
            result += appeared[pfs[i] - scr];
            appeared[pfs[i]] += 1;
        }
    }
    ```

### 最优关键思路或技巧
利用前缀和记录子串的数值和，同时结合`map`或`unordered_map`等数据结构，快速查找满足首尾字母相同且中间字母数值和为0的子串。这种方法能有效降低时间复杂度，将暴力的$O(n^2)$复杂度优化到$O(nlogn)$或接近$O(n)$。

### 拓展思路
此类题目属于字符串与数值统计结合的类型，类似套路可应用于其他需要在字符串中查找满足特定数值条件子串的题目。例如，可能会改变子串的条件限制，如首尾字母数值之和等于中间字母数值之和等，但解题思路仍可围绕前缀和及合适的数据结构记录与查找。

### 相似知识点洛谷题目
1. [P3957 跳房子](https://www.luogu.com.cn/problem/P3957)：涉及前缀和以及二分查找，与本题利用前缀和统计信息有相似之处。
2. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：经典的前缀和应用题目，通过前缀和来快速计算子段和，可加深对前缀和应用的理解。
3. [P2038 无线网络发射器选址](https://www.luogu.com.cn/problem/P2038)：需要利用前缀和优化二维区域的数值统计，与本题在利用前缀和优化统计操作上思路相似。

### 个人心得
无。

---
处理用时：61.83秒
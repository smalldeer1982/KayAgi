# 题目信息

# Weird Chess

## 题目描述

Igor 对国际象棋已经玩腻了，他现在想出新规则来让自己出名。

他的棋盘是一个 $n \times n$ 的方格。Igor 觉得简单才是成功的关键，所以他的游戏只会用一种棋子，并且所有的棋子颜色相同。棋子的移动方式通过一组位移向量来定义。以下是棋子的具体移动规则。

棋盘上的行从上到下编号为 1 到 $n$，列从左到右也从 1 到 $n$ 编号。给每个棋盘格子分配一个整数对 $(x, y)$，表示列号和行号。每种可能的走法由一个整数对 $(dx, dy)$ 定义；使用这种走法，棋子从位置 $(x, y)$ 移到位置 $(x+dx, y+dy)$。只有当目标位置 $(x+dx, y+dy)$ 在棋盘内且没有被其他棋子占据时，这种走法才算有效。在判断能否进行某种走法时，除起点和终点外其他位置上的棋子不影响走法（类似于国际象棋中的马）。

Igor 希望你能找出他的棋子能进行哪些走法。Igor 在棋盘上放置了一些棋子，并告诉你每个未被占据的格子是否被已有棋子攻击（即是否有棋子能从当前位置移动到该格子）。你需要恢复出一种可能的位移向量集合，或者如果这种情况对于任何位移向量集合都是不可能的，则说明 Igor 犯了错误。

## 样例 #1

### 输入

```
5
oxxxx
x...x
x...x
x...x
xxxxo
```

### 输出

```
YES
....x....
....x....
....x....
....x....
xxxxoxxxx
....x....
....x....
....x....
....x....
```

## 样例 #2

### 输入

```
6
.x.x..
x.x.x.
.xo..x
x..ox.
.x.x.x
..x.x.
```

### 输出

```
YES
...........
...........
...........
....x.x....
...x...x...
.....o.....
...x...x...
....x.x....
...........
...........
...........
```

## 样例 #3

### 输入

```
3
o.x
oxx
o.x
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# 奇怪的国际象棋

## 题目描述
Igor 对国际象棋已经玩腻了，他现在想出新规则来让自己出名。

他的棋盘是一个 \(n \times n\) 的方格。Igor 觉得简单才是成功的关键，所以他的游戏只会用一种棋子，并且所有的棋子颜色相同。棋子的移动方式通过一组位移向量来定义。以下是棋子的具体移动规则。

棋盘上的行从上到下编号为 1 到 \(n\)，列从左到右也从 1 到 \(n\) 编号。给每个棋盘格子分配一个整数对 \((x, y)\)，表示列号和行号。每种可能的走法由一个整数对 \((dx, dy)\) 定义；使用这种走法，棋子从位置 \((x, y)\) 移到位置 \((x + dx, y + dy)\)。只有当目标位置 \((x + dx, y + dy)\) 在棋盘内且没有被其他棋子占据时，这种走法才算有效。在判断能否进行某种走法时，除起点和终点外其他位置上的棋子不影响走法（类似于国际象棋中的马）。

Igor 希望你能找出他的棋子能进行哪些走法。Igor 在棋盘上放置了一些棋子，并告诉你每个未被占据的格子是否被已有棋子攻击（即是否有棋子能从当前位置移动到该格子）。你需要恢复出一种可能的位移向量集合，或者如果这种情况对于任何位移向量集合都是不可能的，则说明 Igor 犯了错误。

## 样例 #1
### 输入
```
5
oxxxx
x...x
x...x
x...x
xxxxo
```
### 输出
```
YES
....x....
....x....
....x....
....x....
xxxxoxxxx
....x....
....x....
....x....
....x....
```

## 样例 #2
### 输入
```
6
.x.x..
x.x.x.
.xo..x
x..ox.
.x.x.x
..x.x.
```
### 输出
```
YES
...........
...........
...........
....x.x....
...x...x...
.....o.....
...x...x...
....x.x....
...........
...........
...........
```

## 样例 #3
### 输入
```
3
o.x
oxx
o.x
```
### 输出
```
NO
```

### 算法分类
模拟

### 题解综合分析与结论
两位作者的题解思路本质相同，都是基于棋盘上棋子和空位的关系来推导可能的移动规则，然后检验该规则是否符合给定的攻击情况。不同之处在于对推导移动规则的具体实现方式和对无解情况的证明。

### 题解分析
- **Taoran_01**：
  - **星级**：4星
  - **关键亮点**：思路清晰，详细阐述了性质、解题思路、无解情况及证明，代码实现完整且注释详细。利用“对多个集合取交相当于对它们的补集先取并再取补”的原理，将取交集转换为取并集，降低空间开销。
  - **个人心得**：无
  - **核心代码**：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;

char buf[1<<20], *p1, *p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)

inline ll read() {
    ll x=0, f=1; char ch=getchar();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
    return x*f;
}

#define N 110
int n;
int a[N][N], d[N][N], t[N][N];

signed main() {
    n=read();
    for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) {
        char ch=getchar(); while (ch!='x'&&ch!='o'&&ch!='.') ch=getchar();
        if (ch=='.') a[i][j]=0; if (ch=='x') a[i][j]=1; if (ch=='o') a[i][j]=2;
    }
    for (int i=1; i<=n*2-1; ++i) for (int j=1; j<=n*2-1; ++j) d[i][j]=1;
    for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) if (a[i][j]==2) {
        for (int x=1; x<=n; ++x) for (int y=1; y<=n; ++y) {
            if (a[x][y]==0) d[x-i+n][y-j+n]=0;
        }
    }
    for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) if (a[i][j]==2) {
        for (int x=1; x<=n*2-1; ++x) for (int y=1; y<=n*2-1; ++y) if (d[x][y]) {
            int x1=i+x-n, y1=j+y-n;
            if (x1>=1&&x1<=n&&y1>=1&&y1<=n) t[x1][y1]=1;
        }
    }
    bool flag=1;
    for (int i=1; i<=n; ++i) for (int j=1; j<=n; ++j) if (a[i][j]!=2) {
        flag&=(a[i][j]==1)==(t[i][j]==1);
    }
    d[n][n]=2;
    if (!flag) return puts("NO"), 0;
    puts("YES");
    for (int i=1; i<=2*n-1; ++i) {
        for (int j=1; j<=2*n-1; ++j) {
            putchar(".xo"[d[i][j]]);
        } puts("");
    }
    return 0;
}
```
  - **核心实现思想**：首先初始化棋盘状态和移动规则矩阵 \(d\) 为全1（表示所有移动都可能）。遍历每个棋子位置和不可被攻击的空位，标记移动规则矩阵中对应的方向为不可移动。然后根据移动规则矩阵还原棋局 \(t\)，对比原棋局 \(a\) 和还原棋局 \(t\) 中除棋子位置外的攻击情况是否一致，若一致则输出移动规则，否则输出NO。
- **Leap_Frog**：
  - **星级**：3星
  - **关键亮点**：简洁地阐述了基本思路，指出重点考虑不可攻击位置（`.`）来推导移动规则，通过暴力枚举棋子和不可攻击位置打标记。但未详细说明实现细节和无解情况。
  - **个人心得**：无
  - **核心代码**：无

### 最优关键思路或技巧
利用集合运算的等价转换原理（对多个集合取交相当于对它们的补集先取并再取补），将难以直接实现的对多个棋子移动规则取交集操作，转换为对不可移动方向取并集操作，降低空间复杂度，从而有效解决问题。

### 同类型题或类似算法套路拓展
此类题目属于棋盘状态分析与规则推导类型，通常可通过模拟棋子的移动、分析棋盘上各位置之间的关系来解决。类似套路包括根据已知条件建立状态转移关系，通过标记、枚举等方式确定最终的规则或状态。

### 洛谷相似题目推荐
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：通过枚举组合来判断是否满足质数条件，与本题通过枚举推导规则类似。
- [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：需要通过枚举路径来寻找最优解，同样涉及到对多种情况的分析和判断。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：对棋盘区域进行标记和判断，与本题对棋盘状态的处理方式有相似之处。 

---
处理用时：74.14秒
# 题目信息

# Mike and Feet

## 题目描述

给定一个大小为 $n$ 的数列 $a$。  

本题中，我们定义数列 $a$ 的一个连续子序列的区间强度为该子序列中所有元素的最小值。  

比如，对于一个大小为 $5$ 的数列 $1,2,3,4,5$ 来说，其连续子序列 $1,2,3$ 对应的区间强度为 $1$；其连续子序列 $3,4,5$ 对应的区间强度为 $3$。

现在你需要求出对于任意一个 $k(1 \le k \le n)$，所有长度为 $k$ 的连续子序列对应的区间强度的最大值。

## 样例 #1

### 输入

```
10
1 2 3 4 5 4 3 2 1 6
```

### 输出

```
6 4 4 3 3 2 2 1 1 1 
```

# AI分析结果

### 题目内容
# Mike和身高

## 题目描述
给定一个大小为 $n$ 的数列 $a$ 。  

本题中，我们定义数列 $a$ 的一个连续子序列的区间强度为该子序列中所有元素的最小值。  

比如，对于一个大小为 $5$ 的数列 $1,2,3,4,5$ 来说，其连续子序列 $1,2,3$ 对应的区间强度为 $1$；其连续子序列 $3,4,5$ 对应的区间强度为 $3$。

现在你需要求出对于任意一个 $k(1 \le k \le n)$，所有长度为 $k$ 的连续子序列对应的区间强度的最大值。

## 样例 #1
### 输入
```
10
1 2 3 4 5 4 3 2 1 6
```
### 输出
```
6 4 4 3 3 2 2 1 1 1 
```
### 算法分类
单调栈（属于栈相关算法，本质是利用栈的特性实现一种高效的序列处理方式，可归类到栈相关的算法技巧）

### 综合分析与结论
这些题解主要围绕单调栈来解决问题，通过找到每个数作为区间最小值时对应的最长区间，进而确定每个长度区间强度的最大值。部分题解还使用了线段树、并查集等辅助优化。各题解思路相似，但在具体实现和优化方式上存在差异。

### 所选的题解
- **作者：__gcd（5星）**
  - **关键亮点**：思路清晰，先阐述从个体贡献角度解题的思路，利用单调栈找到每个数对应的最长区间，再通过两次递推整理答案，代码简洁明了，注释详细。
  - **核心代码**：
```cpp
for(int i = 1; i <= n; i++)
{
    while(s.empty() == false && s.top().val >= a[i])
        s.pop();
    if(s.empty() == false)l[i] = s.top().id + 1;
    else l[i] = 1;
    s.push(Node(i, a[i]));
}
while(s.empty() == false)s.pop();
for(int i = n; i >= 1; i--)
{
    while(s.empty() == false && s.top().val >= a[i])
        s.pop();
    if(s.empty() == false)r[i] = s.top().id - 1;
    else r[i] = n;
    s.push(Node(i, a[i]));
}
//整理答案
for(int i = 1; i <= n; i++)
    ans[r[i] - l[i] + 1] = max(ans[r[i] - l[i] + 1], a[i]);
for(int i = n; i >= 1; i--)
    ans[i] = max(ans[i], ans[i + 1]);
```
  - **核心思想**：正序和倒序利用单调栈分别找到每个数作为最小值的左端点 `l` 和右端点 `r`，然后根据区间长度 `r - l + 1` 更新答案数组 `ans`，最后通过倒序递推确保每个长度的答案是其及更大长度答案中的最大值。

- **作者：LJC00118（4星）**
  - **关键亮点**：同样基于单调栈维护每个数作为最小值的左右端点，代码逻辑紧凑，通过宏定义简化了一些操作，整体实现较为高效。
  - **核心代码**：
```cpp
for(register int i = 1; i <= n; i++) {
    while(top && a[st[top]] > a[i]) {
        r[st[top]] = i - 1;
        --top;
    }
    st[++top] = i;
}
while(top) {
    r[st[top]] = n;
    --top;
}
for(register int i = n; i >= 1; i--) {
    while(top && a[st[top]] > a[i]) {
        l[st[top]] = i + 1;
        --top;
    }
    st[++top] = i;
}
while(top) {
    l[st[top]] = 1;
    --top;
}
for(register int i = 1; i <= n; i++) val[r[i] - l[i] + 1] = max(val[r[i] - l[i] + 1], a[i]);
for(register int i = n - 1; i >= 1; i--) val[i] = max(val[i], val[i + 1]);
```
  - **核心思想**：与上一题解类似，通过单调栈确定每个数作为最小值的区间范围，更新对应长度的答案数组 `val`，最后倒序递推优化答案。

- **作者：yanghaokun（4星）**
  - **关键亮点**：代码简洁易懂，直接实现了单调栈的操作来找到每个数的左右边界，进而更新答案数组，逻辑直接明了。
  - **核心代码**：
```cpp
inline void push(int x)
{
    while(a[x]<a[sta[top]]&&top)
    ri[sta[top]]=x-1,top--;
    sta[++top]=x;
}
inline void push2(int x)
{
    while(a[x]<a[sta[top]]&&top)
    le[sta[top]]=x+1,top--;
    sta[++top]=x;
}
//...
for(int i=1;i<=n;i++)push(i);
while(top)ri[sta[top--]]=n;
top=0;
for(int i=n;i;i--)push2(i);
while(top)le[sta[top--]]=1;
for(int i=1;i<=n;i++) num[ri[i]-le[i]+1]=max(a[i],num[ri[i]-le[i]+1]);
for(int i=n;i;i--) num[i]=max(num[i],num[i+1]);
```
  - **核心思想**：通过两个函数 `push` 和 `push2` 分别实现正序和倒序的单调栈操作，确定每个数的左右边界 `ri` 和 `le`，更新答案数组 `num` 并通过倒序递推完善答案。

### 最优关键思路或技巧
利用单调栈在 $O(n)$ 时间内找到每个数作为区间最小值时对应的最长区间，这是解决本题的核心技巧。通过这种方式，将原问题转化为对每个长度区间内的最大值求解，再结合简单的递推操作，高效地得出最终答案。

### 可拓展之处
此类题目属于区间最值相关问题，常见的类似算法套路还包括利用线段树、RMQ 等数据结构解决区间最值查询问题。同类型题通常围绕区间的各种统计量（如最值、和、中位数等）展开，要求在不同的限制条件下高效求解。

### 推荐题目
- [P5788 单调栈](https://www.luogu.com.cn/problem/P5788)：基础的单调栈练习题，帮助理解单调栈的基本操作。
- [P2422 良好的感觉](https://www.luogu.com.cn/problem/P2422)：同样运用贡献思想解题，与本题思路类似，可加深对该方法的理解。
- [CF817D Imbalanced Array](https://www.luogu.com.cn/problem/CF817D)：结合贡献思想与容斥原理，进一步拓展思维。 

---
处理用时：59.91秒
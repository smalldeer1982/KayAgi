# 题目信息

# Cutting Jigsaw Puzzle

## 题目描述

## 题目翻译
刺猬最近记得他最喜欢的童年活动之一 - 解决谜题，并以新的活力进入它。他每天都会和他的朋友一起坐在成千上万的小片中，一个接一个地寻找所需物品。

不久，刺猬想出了一个绝妙的主意：不是购买现成的拼图，而是可以将自己的大纸张带上一些图片并将其切成许多小矩形块，然后将它们混合并解决由此产生的拼图，试图拼凑图片。由此产生的任务比经典谜题更具挑战性：现在所有碎片都具有相同的矩形形状，并且可以仅依靠在碎片上绘制的图片来组装谜题。

所有拼图都是相同的尺寸 X×Y，因为图像首先通过水平切割以间距切割 X X，然后垂直切割，间距为 Y。如果我们将图片的初始大小表示为 A×B，然后 一个 A必须可被整除X和B必须可被整除Y（X和Y是整数）。

然而，并非每次切割图片都会产生很好的拼图。刺猬发现一个谜题很好，如果其中没有两个相同（比较它们时允许旋转它们，但是禁止将它们翻过来）。

你的任务是计算给定图片你可以从中制作的好谜题的数量，并找到最小尺寸的谜题。

## 样例 #1

### 输入

```
2 4
ABDC
ABDC
```

### 输出

```
3
2 1
```

## 样例 #2

### 输入

```
2 6
ABCCBA
ABCCBA
```

### 输出

```
1
2 6
```

# AI分析结果

### 题目内容
# 切割拼图

## 题目描述

## 题目翻译
刺猬最近想起他最喜欢的童年活动之一——玩拼图，并且带着新的热情投入其中。他每天都会和朋友坐在成千上万的小碎片前，一个一个地寻找所需的碎片。

不久后，刺猬想出了一个绝妙的主意：不买现成的拼图，而是可以把自己印有图片的大纸张切成许多小矩形块，然后将它们混合，尝试拼凑出图片，以此来玩拼图。由此产生的任务比经典拼图更具挑战性：现在所有碎片都具有相同的矩形形状，并且只能依靠碎片上绘制的图片来组装拼图。

所有拼图块的尺寸都是X×Y，因为图像首先按间距X进行水平切割，然后按间距Y进行垂直切割。如果我们将图片的初始大小表示为A×B，那么A必须能被X整除，B必须能被Y整除（X和Y是整数）。

然而，并非每次切割图片都能产生好的拼图。刺猬发现，如果其中没有两个相同的拼图块（比较时允许旋转，但禁止翻转），那么这个拼图就是好的。

你的任务是计算给定图片能制作出的好拼图的数量，并找到最小尺寸的拼图。

## 样例 #1

### 输入

```
2 4
ABDC
ABDC
```

### 输出

```
3
2 1
```

## 样例 #2

### 输入

```
2 6
ABCCBA
ABCCBA
```

### 输出

```
1
2 6
```

### 算法分类
模拟

### 题解综合分析与结论
这几道题解的核心思路都是通过枚举所有可能的拼图块尺寸，然后对每个尺寸下的拼图块进行旋转和去重判断，以确定该尺寸是否能构成好的拼图。不同题解在实现细节上有所差异，例如哈希函数的设计、旋转操作的实现方式、去重数据结构的选择等。

### 所选的题解
 - **作者：Mint_Flipped (5星)**
    - **关键亮点**：思路清晰，代码实现完整且简洁。利用哈希值来判断拼图块是否重复，在计算哈希值时考虑了拼图块旋转的情况，并且针对正方形和长方形拼图块分别处理旋转方向数量。
    - **个人心得**：作者提到自己wa了无数次，原因是函数使用不规范，这提醒大家在编程时要注意函数的正确使用。
    - **重点代码**：
```c
void check(int x,int y){
    mp.clear();
    if(x==y)
    flag=1;
    else
    flag=0;
    for(int i=1;i<=n;i+=x){
        for(int j=1;j<=m;j+=y){
    h1=0,h2=0,h3=0,h4=0;
    int l1=i,l2=i+x-1,r1=j,r2=j+y-1;
    for(int ii=l1;ii<=l2;++ii){
        for(int jj=r1;jj<=r2;++jj)
        h1=h1*base+s[ii][jj]-'a';
    }
    for(int ii=l2;ii>=l1;--ii){
        for(int jj=r2;jj>=r1;--jj)
        h2=h2*base+s[ii][jj]-'a';
    }
    if(flag){
    for(int ii=r1;ii<=r2;++ii){
        for(int jj=l2;jj>=l1;--jj)
        h3=h3*base+s[jj][ii]-'a';
    }
    for(int ii=r2;ii>=r1;--ii){
        for(int jj=l1;jj<=l2;++jj)
        h4=h4*base+s[jj][ii]-'a';
    }
    }
    if(flag){
        if(mp[h1]||mp[h2]||mp[h3]||mp[h4])
        return ;
        mp[h1]=mp[h2]=mp[h3]=mp[h4]=1;
    }
    else{
        if(mp[h1]||mp[h2])
        return ;
        mp[h1]=mp[h2]=1;
    } 
        }
    }
    ans++;
    if(ansx==0||x*y<ansx*ansy)
    ansx=x,ansy=y;
}
```
核心实现思想：该函数用于检查给定尺寸`(x, y)`的拼图块是否满足无重复条件。首先根据拼图块是否为正方形设置标志`flag`。然后遍历所有拼图块，计算每个拼图块不同旋转方向的哈希值，若哈希值已存在则说明有重复，直接返回；若所有哈希值都未出现过，则将其存入`map`并计数，同时更新最小尺寸拼图的信息。

 - **作者：youdu666 (4星)**
    - **关键亮点**：先预处理出`n`和`m`的所有因数，通过因数组合来枚举拼图块尺寸，减少不必要的枚举。在计算哈希值时，使用自定义模数和进制，并且针对正方形和长方形分别计算不同方向的哈希值并去重。
    - **重点代码**：
```
inline bool hsh(int xa,int ya,int xb,int yb)
{
    int ans=0,ans2=0,ans3=0,ans4=0;
    for(int i=xa;i<=xb;i++)
        for(int j=ya;j<=yb;j++)
        {
            ans=(ans*base)%mo;
            ans=(ans+c[i][j])%mo;
        }
    if(mp[ans]) return false;
    for(int i=xb;i>=xa;i--)
        for(int j=yb;j>=ya;j--)
        {
            ans2=(ans2*base)%mo;
            ans2=(ans2+c[i][j])%mo;
        }
    if(mp[ans2]) return false;
    if(xb-xa!=yb-ya)
    {
        mp[ans]=true;
        mp[ans2]=true;
        return true;
    }

    for(int j=yb;j>=ya;j--)
        for(int i=xa;i<=xb;i++)
        {
            ans3=(ans3*base)%mo;
            ans3=(ans3+c[i][j])%mo;
        }
    if(mp[ans3]) return false;

    for(int j=ya;j<=yb;j++)
        for(int i=xb;i>=xa;i--)
        {
            ans4=(ans4*base)%mo;
            ans4=(ans4+c[i][j])%mo;
        }
    if(mp[ans4]) return false;
    mp[ans]=true;
    mp[ans2]=true;
    mp[ans3]=true;
    mp[ans4]=true;
    return true;
}
```
核心实现思想：该函数用于计算并检查给定坐标范围内拼图块的哈希值是否重复。先计算正方向哈希值`ans`，若已存在则返回`false`。再计算反方向哈希值`ans2`，同样判断是否重复。若不是正方形，直接记录这两个哈希值并返回`true`；若是正方形，继续计算另外两个旋转方向的哈希值`ans3`和`ans4`，若都不重复则记录并返回`true`，否则返回`false`。

 - **作者：wind_whisper (4星)**
    - **关键亮点**：通过结构体来存储拼图块，并在结构体中实现计算哈希值的函数，使代码结构较为清晰。同时，通过手玩出旋转对坐标的映射关系，在`work`函数中实现拼图块旋转和哈希值检查的操作。
    - **重点代码**：
```cpp
bool work(int a,int b,int x,int y){
  num=0;
  for(int i=1;i<=max(n,m);i++){
    for(int j=1;j<=max(n,m);j++) now.a[i][j]=0;
  }
  for(int i=1;i<=x;i++){
    for(int j=1;j<=y;j++){
      now.a[i][j]=s[a+i-1][b+j-1];
    }
  }
  if(mp[now.calc()]) return false;
  w[++num]=now;
  for(int o=1;o<=3;o++){
    memcpy(pre.a,now.a,sizeof(now.a));
    for(int i=1;i<=max(n,m);i++){
      for(int j=1;j<=max(n,m);j++) now.a[i][j]=0;
    }
    for(int i=1;i<=x;i++){
      for(int j=1;j<=y;j++){
	now.a[j][x-i+1]=pre.a[i][j];
      }
    }
    swap(x,y);    
    if(o==2||x==y){
      if(mp[now.calc()]) return false;
      w[++num]=now;
    }
  }
  for(int i=1;i<=num;i++) mp[w[i].calc()]=1;
  return true;
}
```
核心实现思想：该函数用于处理一个具体位置`(a, b)`、尺寸`(x, y)`的拼图块。先将该拼图块存入`now`结构体并计算其哈希值，若哈希值已存在则返回`false`。然后通过循环进行三次旋转操作，每次旋转后计算哈希值并检查是否重复，若不重复则记录该拼图块，最后返回`true`。

### 最优关键思路或技巧
 - **哈希去重**：通过计算拼图块的哈希值，并利用`map`或`set`等数据结构来记录已出现的哈希值，快速判断拼图块是否重复。
 - **分情况处理旋转**：针对正方形和长方形拼图块，分别考虑不同的旋转方向数量，减少不必要的计算。

### 可拓展之处
同类型题通常围绕图形分割、旋转、去重等操作展开。类似算法套路有：在处理图形相关问题时，先确定图形的基本元素（如本题的拼图块），然后分析对这些元素的操作（如旋转、翻转等），通过合适的数据结构（如哈希表）来优化判断操作。

### 洛谷相似题目推荐
 - [P1036 [NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)：通过枚举组合来解决问题，与本题枚举拼图块尺寸思路类似。
 - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：需要对各种菜品组合进行判断，与本题判断不同尺寸拼图块组合是否满足条件类似。
 - [P1469 [USACO2.1] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1469)：通过枚举路径来寻找最优解，与本题枚举拼图块尺寸找最优解思路有相似之处。

---
处理用时：95.02秒
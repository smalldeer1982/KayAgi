# 题目信息

# Kyoya and Permutation

## 题目描述

定义一个长度为$n$的**排列**为仅由$1..n$的元素组成，且每个元素恰好只出现$1$次的序列。我们称数值$i\ (1\leq i \leq |p|)$在排列$p$中的映射为$p_i$。



Kyota Ootori 刚刚学习了**排列**的**循环表示法**。定义排列$p$上的一个**循环**是一个由$1..n$的一部分元素组成的序列，并且在这个序列中，任意一个元素在$p$中的映射等于下一个元素（特别地，最后一个元素的映射等于第一个元素）。



显然，我们可以将一个排列划分成多个循环。例如$p=[4,1,6,2,5,3]$可以被划分成$[1,4,2]$，$[3,6]$和$[5]$三个循环。我们在每个循环周围加上括号，然后将它们连起来，得到的就是这个排列的**循环表示法**。例如$[4,1,6,2,5,3]$的一种循环表示法是$(1\ 4\ 2)(3\ 6)(5)$。



对于一个长度不为$1$的排列，其循环表示法不是唯一的。为了使问题得到统一，我们定义一种**标准循环表示法**。即，对于每个循环，都将其最大值放在最前面，然后将这若干个循环按照最大值从小到大排列。这样，$[4,1,6,2,5,3]$的**标准循环表示法**就是$(4\ 2\ 1)(5)(6\ 3)$。



现在，Kyota 发现，如果我们去掉一个排列的**标准循环表示法**中的括号，我们将得到另一个排列。比如，由$[4,1,6,2,5,3]$可以得到$[4,2,1,5,6,3]$。



他还发现，将某些排列的**标准循环表示法**中的括号去除后，得到的排列和原排列是一样的。我们称这种排列为“**好的排列**”。他按**字典序递增**的顺序在纸上写下了长度为$n$的所有**好的排列**，结果他的朋友 Tamaki Suoh 把这个列表搞丢了。Kyota 现在想要恢复这个列表。告诉你排列的长度$n$以及$k$，请你输出**字典序从小到大**第$k$个好的排列。

## 说明/提示

$[1,3,2,4]$的**标准循环表示法**是$(1)(3\ 2)(4)$，去掉括号后得到的是$[1,3,2,4]$，和原来的排列一样。字典序比其小的两个满足要求的序列是$[1,2,3,4]$和$[1,2,4,3]$。





$1 \leq n \leq 50$，$1 \leq k \leq 10^8$。保证长度为$n$的，第$k$个好的排列一定存在。

## 样例 #1

### 输入

```
4 3
```

### 输出

```
1 3 2 4
```

## 样例 #2

### 输入

```
10 1
```

### 输出

```
1 2 3 4 5 6 7 8 9 10
```

# AI分析结果

### 题目内容
# 恭弥与排列

## 题目描述
定义一个长度为$n$的**排列**为仅由$1$到$n$的元素组成，且每个元素恰好只出现$1$次的序列。我们称数值$i\ (1\leq i \leq |p|)$在排列$p$中的映射为$p_i$。

恭弥·大寺刚学习了**排列**的**循环表示法**。定义排列$p$上的一个**循环**是一个由$1$到$n$的一部分元素组成的序列，并且在这个序列中，任意一个元素在$p$中的映射等于下一个元素（特别地，最后一个元素的映射等于第一个元素）。

显然，我们可以将一个排列划分成多个循环。例如$p = [4, 1, 6, 2, 5, 3]$可以被划分成$[1, 4, 2]$，$[3, 6]$和$[5]$三个循环。我们在每个循环周围加上括号，然后将它们连起来，得到的就是这个排列的**循环表示法**。例如$[4, 1, 6, 2, 5, 3]$的一种循环表示法是$(1\ 4\ 2)(3\ 6)(5)$。

对于一个长度不为$1$的排列，其循环表示法不是唯一的。为了使问题得到统一，我们定义一种**标准循环表示法**。即，对于每个循环，都将其最大值放在最前面，然后将这若干个循环按照最大值从小到大排列。这样，$[4, 1, 6, 2, 5, 3]$的**标准循环表示法**就是$(4\ 2\ 1)(5)(6\ 3)$。

现在，恭弥发现，如果我们去掉一个排列的**标准循环表示法**中的括号，我们将得到另一个排列。比如，由$[4, 1, 6, 2, 5, 3]$可以得到$[4, 2, 1, 5, 6, 3]$。

他还发现，将某些排列的**标准循环表示法**中的括号去除后，得到的排列和原排列是一样的。我们称这种排列为“**好的排列**”。他按**字典序递增**的顺序在纸上写下了长度为$n$的所有**好的排列**，结果他的朋友环·须王把这个列表搞丢了。恭弥现在想要恢复这个列表。告诉你排列的长度$n$以及$k$，请你输出**字典序从小到大**第$k$个好的排列。

## 说明/提示
$[1, 3, 2, 4]$的**标准循环表示法**是$(1)(3\ 2)(4)$，去掉括号后得到的是$[1, 3, 2, 4]$，和原来的排列一样。字典序比其小的两个满足要求的序列是$[1, 2, 3, 4]$和$[1, 2, 4, 3]$。

$1 \leq n \leq 50$，$1 \leq k \leq 10^8$。保证长度为$n$的，第$k$个好的排列一定存在。

## 样例 #1
### 输入
```
4 3
```
### 输出
```
1 3 2 4
```

## 样例 #2
### 输入
```
10 1
```
### 输出
```
1 2 3 4 5 6 7 8 9 10
```

### 算法分类
递归、递推

### 综合分析与结论
该题核心是找出长度为$n$的“好的排列”的规律，并通过递归或递推的方式构造出第$k$个“好的排列”。题解通过证明得出“好的排列”只能由$1$到$n$的顺序排列，选择若干个不相交的、长度为$2$的区间翻转得到。同时发现长度为$n$的“好的排列”数量符合斐波那契数列规律，利用此规律和递归方法实现构造。

### 所选的题解
 - **星级**：4星
 - **关键亮点**：通过严谨证明得出“好的排列”的构成规律，基于斐波那契数列性质和递归实现排列构造，代码简洁且逻辑清晰。
 - **个人心得**：无

### 重点代码及核心实现思想
```cpp
// 在arr[l..r]的空间中，构造l..r范围意义下，第rk小的“好的排列”
void buildArr(int l,int r,int rk) {
    // 待构造排列的长度
    int len = r-l+1;
    // 边界条件
    if(len==0) return;
    if(len==1) {arr[l] = l;return;}
    // 此时，第一项置为1，转化为构造n-1
    if(rk <= feiwu[len]) {
        arr[l] = l;
        arr[l+1] = l+1;
        buildArr(l+1,r,rk);
    }
    // 前两项为[2,1]，转化为构造n-2
    else {
        arr[l] = l+1;
        arr[l+1] = l;
        // 注意这里rk要减去长度为n-1的“好的排列”数量
        buildArr(l+2,r,rk-feiwu[len]);
    }
}
```
核心实现思想：根据斐波那契数列性质，通过判断$rk$与$feiwu[len]$的大小关系，决定以$1$开头递归构造长度为$n - 1$的排列，还是以$[2, 1]$开头递归构造长度为$n - 2$的排列，从而实现按字典序构造第$k$个“好的排列”。

### 关键思路或技巧
 - **数学规律挖掘**：通过证明发现“好的排列”的构成规律以及其数量符合斐波那契数列规律，为解题提供关键基础。
 - **递归构造**：利用递归方法，将构造长度为$n$的“好的排列”问题转化为构造长度更小的“好的排列”问题，简化实现过程。

### 可拓展之处
此类题目属于排列组合与特定规律结合的问题，类似套路是先挖掘排列的隐藏规律，再利用递推、递归等方法实现构造。例如在一些密码学、组合优化问题中也会涉及类似通过寻找规律来构造特定排列的思路。

### 推荐洛谷题目
 - [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)：同样是基于斐波那契数列规律的递推问题，与本题利用数列规律解题思路相似。
 - [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过递归或递推方式解决数字构造问题，与本题构造排列思路类似。
 - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：涉及排列相关性质，在理解排列规律基础上利用归并排序等方法解决问题，与本题对排列性质的研究和利用有相似之处。 

---
处理用时：84.67秒
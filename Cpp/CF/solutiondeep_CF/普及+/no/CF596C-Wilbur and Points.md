# 题目信息

# Wilbur and Points

## 题目描述

威尔伯正在研究一组坐标平面上的 $n$ 个点。这些点坐标的所有分量都是非负整数。更重要的是，如果点 $(x, y)$ 属于这个集合，那么所有满足 $0 \le x' \le x$ 和 $0 \le y' \le y$ 的点 $(x', y')$ 也会在这个集合中。

威尔伯现在想给这些点编号，从 $1$ 到 $n$ 各不相同。为了让编号更加美观，威尔伯设置了一个条件：如果某个点 $(x, y)$ 被分配了编号 $i$，那么所有满足 $x' \ge x$ 且 $y' \ge y$ 的点 $(x', y')$ 的编号不能小于 $i$。例如，对于点集 $(0, 0)$、$(0, 1)$、$(1, 0)$ 和 $(1, 1)$，有两种美观的编号方式，分别是 $1, 2, 3, 4$ 和 $1, 3, 2, 4$。

威尔伯的朋友给他出了一个难题：对于每个点定义一个特殊值 $s(x, y) = y - x$。现在他给了威尔伯一些数 $w_1, w_2, \ldots, w_n$，并要求找到一种美观的编号，使得编号为 $i$ 的点的特殊值满足 $s(x_i, y_i) = y_i - x_i = w_i$。

威尔伯需要你的帮助来解决这个问题。

## 说明/提示

在第一个样例中，点 $(2, 0)$ 获得编号 $3$，点 $(0, 0)$ 编号为 $1$，点 $(1, 0)$ 编号为 $2$，点 $(1, 1)$ 编号为 $5$，点 $(0, 1)$ 编号为 $4$。通过验证，这种编号符合美观条件，并且满足 $y_i - x_i = w_i$。

在第二个样例中，点集中的特殊值为 $0, -1, -2$，而朋友给的序列为 $0, 1, 2$，因此不存在满足条件的解答。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2 0
0 0
1 0
1 1
0 1
0 -1 -2 1 0
```

### 输出

```
YES
0 0
1 0
2 0
0 1
1 1
```

## 样例 #2

### 输入

```
3
1 0
0 0
2 0
0 1 2
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# Wilbur和点

## 题目描述
威尔伯正在研究坐标平面上的一组 $n$ 个点。这些点坐标的所有分量都是非负整数。更重要的是，如果点 $(x, y)$ 属于这个集合，那么所有满足 $0 \le x' \le x$ 且 $0 \le y' \le y$ 的点 $(x', y')$ 也会在这个集合中。

威尔伯现在想给这些点编号，编号从 $1$ 到 $n$ 且各不相同。为了让编号更加美观，威尔伯设置了一个条件：如果某个点 $(x, y)$ 被分配了编号 $i$，那么所有满足 $x' \ge x$ 且 $y' \ge y$ 的点 $(x', y')$ 的编号不能小于 $i$。例如，对于点集 $(0, 0)$、$(0, 1)$、$(1, 0)$ 和 $(1, 1)$，有两种美观的编号方式，分别是 $1, 2, 3, 4$ 和 $1, 3, 2, 4$。

威尔伯的朋友给他出了一个难题：对于每个点定义一个特殊值 $s(x, y) = y - x$。现在他给了威尔伯一些数 $w_1, w_2, \ldots, w_n$，并要求找到一种美观的编号，使得编号为 $i$ 的点的特殊值满足 $s(x_i, y_i) = y_i - x_i = w_i$。

威尔伯需要你的帮助来解决这个问题。

## 说明/提示
在第一个样例中，点 $(2, 0)$ 获得编号 $3$，点 $(0, 0)$ 编号为 $1$，点 $(1, 0)$ 编号为 $2$，点 $(1, 1)$ 编号为 $5$，点 $(0, 1)$ 编号为 $4$。通过验证，这种编号符合美观条件，并且满足 $y_i - x_i = w_i$。

在第二个样例中，点集中的特殊值为 $0, -1, -2$，而朋友给的序列为 $0, 1, 2$，因此不存在满足条件的解答。

 **本翻译由AI自动生成**

## 样例 #1
### 输入
```
5
2 0
0 0
1 0
1 1
0 1
0 -1 -2 1 0
```
### 输出
```
YES
0 0
1 0
2 0
0 1
1 1
```

## 样例 #2
### 输入
```
3
1 0
0 0
2 0
0 1 2
```
### 输出
```
NO
```

### 算法分类
构造

### 综合分析与结论
1. **liuzhongrui题解**：
    - **思路**：首先通过 `map` 检查对于每个整数 $d$，$w_i$ 中等于 $d$ 的数量与权重等于 $d$ 的点的数量是否相同，不同则直接输出 `NO`。然后对权重相同的点集和 $w_i$ 中对应值的集合分别排序，按序对应标记点。最后通过向量数组检查标记是否有效，即对于所有点 $(i,j)$，其右边和下边的点的编号应大于该点编号。
    - **算法要点**：利用 `map` 统计和匹配数量，对相同权重的点集和对应 $w_i$ 值集排序并对应标记，最后通过二维向量数组检查编号规则。
    - **解决难点**：通过巧妙的数据结构和排序操作，解决了点的特殊值匹配以及美观编号规则的验证问题。
2. **LJ07题解**：
    - **思路**：贪心模拟，维护一个已用过点的态势，每次选取 $x$ 尽可能小的点，保证不劣。通过预处理得到 $r$ 数组表示每个 $y$ 对应的最大 $x$，并对 $r$ 数组进行转换和处理，在循环中根据 $w_i$ 寻找匹配点并检查是否满足条件。
    - **算法要点**：贪心选取 $x$ 最小的点，利用数组预处理和维护状态，在循环中进行匹配和条件检查。
    - **解决难点**：通过贪心策略简化了点的选取过程，同时利用数组操作巧妙处理了点的匹配和条件判断。

总体来看，两篇题解都围绕如何匹配点的特殊值以及满足美观编号规则展开，liuzhongrui题解思路更清晰，代码结构相对更规整，LJ07题解贪心思路较巧妙但代码可读性稍弱。

### 所选的题解
- **liuzhongrui题解**：
  - **星级**：4星
  - **关键亮点**：思路清晰，利用 `map` 统计和匹配数量，通过排序和向量数组完成点的标记与验证。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int main() {
    int n;
    map<int,vector<pair<int,int> > > weights;
    map<int,vector<int> > cnt;
    pair<int,int> ans[N];
    vector<int> diag[N];
    scanf("%d",&n);
    for (int i=0; i<n; i++) {
        int a, b;
        scanf("%d %d",&a,&b);
        while (diag[a].size()<=b) diag[a].push_back(0);
        weights[b-a].push_back(make_pair(a,b));
    }
    for (auto& v: weights) {
        sort(v.second.begin(),v.second.end());
    }
    for (int i=0; i<n; i++) {
        int a;
        cin >> a;
        cnt[a].push_back(i);
    }
    for (auto v: cnt) {
        if (weights.count(v.first)==0 || weights[v.first].size()!=v.second.size()) {
            printf("NO\n");
            return 0;
        }
        for (int i=0; i<v.second.size(); i++) {
            ans[v.second[i]]=weights[v.first][i];
            diag[weights[v.first][i].first][weights[v.first][i].second]=v.second[i];
        }
    }
    for (int i=0; i<N; i++) {
        for (int j=0; j<(int)diag[i].size(); j++) {
            if ((int)diag[i+1].size()>j && diag[i+1][j]<diag[i][j]) {
                printf("NO\n");
                return 0;
            }
            if (j+1<(int)diag[i].size() && diag[i][j]>diag[i][j+1]) {
                printf("NO\n");
                return 0;
            }
        }
    }
    printf("YES\n");
    for (int i=0; i<n; i++) {
        printf("%d %d\n",ans[i].first,ans[i].second);
    }
    return 0;
}
```
核心代码实现思想：先统计每个特殊值对应的点集并排序，同时统计每个特殊值在 $w_i$ 中的位置。然后匹配两者数量，若匹配则对应标记点。最后通过遍历二维向量数组检查编号是否满足美观条件。

### 最优关键思路或技巧
1. **数据结构选择**：使用 `map` 来高效统计和匹配具有相同特殊值的点的数量和 $w_i$ 中对应值的数量。
2. **排序与对应**：对相同特殊值的点集和 $w_i$ 中对应值的集合进行排序后按序对应，简化了点的标记过程。
3. **贪心策略**：如LJ07题解中贪心选取 $x$ 最小的点，在满足条件的情况下简化了点的选取逻辑。

### 同类型题或类似算法套路拓展
此类题目通常围绕在给定的规则下构造满足条件的方案。类似套路包括根据题目规则设计合适的数据结构来存储和操作数据，利用排序、贪心等策略简化构造过程，以及通过循环和条件判断验证构造结果是否符合要求。

### 洛谷相似题目推荐
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：通过贪心策略构造满足条件的数字。
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：利用贪心和排序解决分组问题，与本题构造满足条件方案类似。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：通过贪心策略构造排队顺序，与本题在规则下构造方案思路相似。 

---
处理用时：63.50秒
# 题目信息

# Mushroom Strife

## 题目描述

$Pasha$ 和 $Akim$ 正在制作一张森林地图：草坪是地图的顶点，连接草坪的道路是地图的边。
 
他们决定通过以下方式对每个草坪上蘑菇的数量进行编码：在两个草坪之间的边上，写下两个数字，即两个草坪蘑菇数量的最大公约数和最小公倍数。

但是有一天， $Pasha$ 和 $Akim$ 争吵了起来，并撕毁了地图。

 $Pasha$ 只剩下其中的一部分，共有 $m$ 条路。请帮助 $Pasha$ 使用他已知的部分地图来恢复每个草坪上的蘑菇数量。

结果不一定是唯一的，请帮助 $Pasha$ 恢复任意一张合法的地图或者判断不存在任何一种合法的地图。

保证初始地图上道路上的数字不小于 $1$ 并且不超过 $10^6$ 。

## 样例 #1

### 输入

```
1 0
```

### 输出

```
YES
1 ```

## 样例 #2

### 输入

```
2 1
1 2 1 3
```

### 输出

```
YES
1 3 ```

## 样例 #3

### 输入

```
3 2
3 2 1 2
3 1 1 10
```

### 输出

```
YES
5 1 2 ```

## 样例 #4

### 输入

```
2 1
1 2 3 7
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# 蘑菇纷争

## 题目描述
帕沙（Pasha）和阿基姆（Akim）正在制作一张森林地图：草坪是地图的顶点，连接草坪的道路是地图的边。

他们决定通过以下方式对每个草坪上蘑菇的数量进行编码：在两个草坪之间的边上，写下两个数字，即两个草坪蘑菇数量的最大公约数和最小公倍数。

但是有一天，帕沙和阿基姆争吵了起来，并撕毁了地图。

帕沙只剩下其中的一部分，共有 m 条路。请帮助帕沙使用他已知的部分地图来恢复每个草坪上的蘑菇数量。

结果不一定是唯一的，请帮助帕沙恢复任意一张合法的地图或者判断不存在任何一种合法的地图。

保证初始地图上道路上的数字不小于 1 并且不超过 10^6 。

## 样例 #1
### 输入
```
1 0
```
### 输出
```
YES
1 
```
## 样例 #2
### 输入
```
2 1
1 2 1 3
```
### 输出
```
YES
1 3 
```
## 样例 #3
### 输入
```
3 2
3 2 1 2
3 1 1 10
```
### 输出
```
YES
5 1 2 
```
## 样例 #4
### 输入
```
2 1
1 2 3 7
```
### 输出
```
NO
```
### 算法分类
搜索

### 综合分析与结论
两题解核心思路均基于已知的最大公约数和最小公倍数关系，通过枚举连通块内一点权值来推算其他点权值。
- **思路对比**：
    - **CarroT1212**：利用公式 $b=\frac{\gcd\{a,b\}\cdot\operatorname{lcm}\{a,b\}}{a}$ 计算连通块内点权值。优化枚举范围，通过计算每个点邻边最大公约数的最小公倍数和最小公倍数的最大公约数来缩小枚举范围，且只枚举最小公倍数的倍数。还提到可进一步优化为枚举连通块中任意一点邻边的 $\operatorname{lcm}$ 的因数。
    - **Peaky**：同样依据上述公式，通过枚举每个连通块第一个节点的权值，用 BFS 计算连通块内所有节点权值，但枚举范围是 $[1, 10^6]$，未做优化。
- **算法要点**：两者都通过枚举结合公式计算节点权值，都需处理连通块。CarroT1212 用 `unordered_map` 标记连通块，Peaky 用 `vis` 数组标记。
- **难点解决**：主要难点是如何高效确定节点权值。CarroT1212 通过优化枚举范围解决，Peaky 未优化，可能效率较低。

### 所选的题解
- **CarroT1212**：★★★★
    - **关键亮点**：对枚举范围进行有效优化，减少不必要枚举，提高算法效率，代码实现细节处理较好。
    - **核心代码片段**：
```cpp
bool dfs(ll x) {
    for (edge i:v[x]) if (!mp[i.to]) {
        if (i.gcd*i.lcm%ans[x]!=0) return 0; 
        ans[i.to]=i.gcd*i.lcm/ans[x],mp[i.to]=1;
        if (__gcd(ans[x],ans[i.to])!=i.gcd) return 0; 
        if (!dfs(i.to)) return 0;
    }
    return 1;
}
int main() {
    scanf("%lld%lld",&n,&m);
    for (ll i=1;i<=n;i++) ans[i]=cong[i]=1;
    for (ll i=1;i<=m;i++) {
        scanf("%lld%lld%lld%lld",&from[i],&to[i],&gcd[i],&lcm[i]);
        v[from[i]].pb({to[i],gcd[i],lcm[i]});
        v[to[i]].pb({from[i],gcd[i],lcm[i]});
        conn[from[i]]=__gcd(conn[from[i]],lcm[i]); 
        conn[to[i]]=__gcd(conn[to[i]],lcm[i]);
        cong[from[i]]=cong[from[i]]*gcd[i]/__gcd(cong[from[i]],gcd[i]); 
        cong[to[i]]=cong[to[i]]*gcd[i]/__gcd(cong[to[i]],gcd[i]);
    }
    for (ll i=1;i<=n;i++) for (ll j=cong[i];j<=conn[i];j+=cong[i]) 
        if (conn[i]%j==0) { 
            mp.clear();
            mp[i]=1,ans[i]=j;
            if (dfs(i)) { 
                for (pair<ll,ll> i:mp) conn[i.first]=0; 
                break;
            }
        }
    for (ll i=1;i<=n;i++) if (conn[i]) { printf("NO"); return 0; } 
    printf("YES\n");
    for (ll i=1;i<=n;i++) printf("%lld ",ans[i]);
    return 0;
}
```
    - **核心实现思想**：`dfs` 函数用于根据当前点权值计算连通块内其他点权值并检查是否合法。`main` 函数中先读入数据并计算每个点邻边最大公约数的最小公倍数 `cong` 和最小公倍数的最大公约数 `conn`，然后枚举每个点在优化范围内的权值，通过 `dfs` 尝试构造合法解，若所有点都能构造出解则输出 `YES` 和结果，否则输出 `NO`。

### 最优关键思路或技巧
通过计算每个点邻边最大公约数的最小公倍数和最小公倍数的最大公约数来缩小枚举范围，且只枚举最小公倍数的倍数，能有效减少枚举量，提高算法效率。进一步优化为枚举连通块中任意一点邻边的 $\operatorname{lcm}$ 的因数，可利用因数个数少的特点，进一步加快枚举速度。

### 可拓展之处
此类题目属于图论与数论结合的问题，类似套路可应用于其他涉及图中节点属性关系推导的题目，例如给定图中边的某种属性，推导节点的相关属性值。

### 洛谷相似题目推荐
- [P1072  Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)：通过最大公约数和最小公倍数关系求解满足条件的数，与本题在数论运用上类似。
- [P1572  计算分数](https://www.luogu.com.cn/problem/P1572)：涉及分数的最大公约数和最小公倍数计算，和本题在数论知识点运用上有相似处。
- [P2152  [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)：主要考察高精度数的最大公约数计算，与本题数论基础相关。 

---
处理用时：82.32秒
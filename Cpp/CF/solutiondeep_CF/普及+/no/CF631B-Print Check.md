# 题目信息

# Print Check

## 题目描述

小澳最近迷上了考古，他发现秦始皇的兵马俑布局十分有特点，热爱钻研的小澳打算在电脑上还原这个伟大的布局。

他努力钻研，发现秦始皇布置兵马俑是有一定规律的。兵马俑阵总共有n行m列，秦始皇在布置的时候每次会指定一行或一列，然后指定一个兵种，使得这一行或者这一列上全部放上这一个兵种。如果这一行上以前放过其它的兵种，那么他会拔掉以前的兵种改成现在他命令的兵种。

小澳从秦朝的文献中找到了布置这个方阵的操作顺序，他希望你能告诉他布局完成后整个兵马俑阵是什么样子的。

## 样例 #1

### 输入

```
3 3 3
1 1 3
2 2 1
1 2 2
```

### 输出

```
3 1 3 
2 2 2 
0 1 0 
```

## 样例 #2

### 输入

```
5 3 5
1 1 1
1 3 1
1 5 1
2 1 1
2 3 1
```

### 输出

```
1 1 1 
1 0 1 
1 1 1 
1 0 1 
1 1 1 
```

# AI分析结果

### 题目内容
# Print Check

## 题目描述

小澳最近迷上了考古，他发现秦始皇的兵马俑布局十分有特点，热爱钻研的小澳打算在电脑上还原这个伟大的布局。

他努力钻研，发现秦始皇布置兵马俑是有一定规律的。兵马俑阵总共有n行m列，秦始皇在布置的时候每次会指定一行或一列，然后指定一个兵种，使得这一行或者这一列上全部放上这一个兵种。如果这一行上以前放过其它的兵种，那么他会拔掉以前的兵种改成现在他命令的兵种。

小澳从秦朝的文献中找到了布置这个方阵的操作顺序，他希望你能告诉他布局完成后整个兵马俑阵是什么样子的。

## 样例 #1

### 输入
```
3 3 3
1 1 3
2 2 1
1 2 2
```
### 输出
```
3 1 3 
2 2 2 
0 1 0 
```
## 样例 #2

### 输入
```
5 3 5
1 1 1
1 3 1
1 5 1
2 1 1
2 3 1
```
### 输出
```
1 1 1 
1 0 1 
1 1 1 
1 0 1 
1 1 1 
```
### 算法分类
模拟

### 综合分析与结论
这些题解都意识到直接暴力模拟每次操作更新矩阵会超时，核心思路都是通过记录每行每列最后一次染色的信息（颜色及操作顺序），在输出时通过比较行列染色的先后顺序确定每个格子的最终颜色，从而优化时间复杂度。不同点在于实现细节，如数据结构的选择、标记方式等。

### 所选的题解
- **作者：RE_Prince (5星)**
    - **关键亮点**：思路清晰，从暴力算法逐步优化。先提出暴力做法会超时，接着借鉴类似题目思路进行离线处理，最后利用行列是否被整体染色的标记进一步优化，代码简洁高效。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,k,x[100009],y[100009],z[100009];
unordered_map<int,int> mpr,mpc;
int a[5009][5009];
signed main()
{
    int f;
    cin>>n>>m>>f;
    for(i=1;i<=f;i++) cin>>z[i]>>x[i]>>y[i];
    for(k=f;k>=1;k--)
    {
        if(z[k]==1)
        {
            if(mpr[x[k]]) continue;
            mpr[x[k]]=1;
            for(i=1;i<=m;i++) if(!a[x[k]][i]) a[x[k]][i]=y[k];
        }
        else
        {
            if(mpc[x[k]]) continue;
            mpc[x[k]]=1;
            for(i=1;i<=n;i++) if(!a[i][x[k]]) a[i][x[k]]=y[k];
        }
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++) cout<<a[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：倒序遍历操作，用 `mpr` 和 `mpc` 分别标记行和列是否已被整体染色，若已染则跳过，否则更新对应行列未染色的格子。
- **作者：linxuanrui (4星)**
    - **关键亮点**：思路简洁明了，通过定义两个数组 `h` 和 `l` 分别记录每行每列整体被赋值的情况及操作顺序，利用离线操作思想，在最后输出时比较行列操作顺序确定每个格子的值。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define endl '\n'
typedef long long ll;
using namespace std;
ll n,m,q,x,y,z; 
pair<int,int> h[5001],l[5001];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> q;
    for(int i = 1;i <= q;i++){
        cin >> x >> y >> z;
        if(x == 1)h[y] = {i,z};
        else l[y] = {i,z};
    }
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++)cout << (h[i].first > l[j].first? h[i].second : l[j].second) << " ";
        cout << endl;
    }
}
```
    - **核心实现思想**：遍历操作，记录每行每列的赋值及操作顺序，输出时比较行列操作顺序决定格子值。
- **作者：Palace (4星)**
    - **关键亮点**：类比线段树的懒惰标记思想，用结构体数组 `tagh` 和 `tagl` 分别记录每行每列需要染上的颜色和染色时间，最后通过比较行列染色时间确定每个格子的最终颜色。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 5010
using namespace std;
struct haha{
    int val,tm;
}tagl[N],tagh[N];
int n,m,q;
int a[N][N];
int main(){
    n=read();m=read();q=read();
    for(int i=1;i<=q;i++){
        int x,y,z;
        x=read();y=read();z=read();
        if(x==1){
            tagh[y].val=z;
            tagh[y].tm=i;
        }
        if(x==2){
            tagl[y].tm=i;
            tagl[y].val=z;
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(tagh[i].tm>tagl[j].tm)
                a[i][j]=tagh[i].val;
            else if(tagh[i].tm<tagl[j].tm)
                a[i][j]=tagl[j].val;
        }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}
```
    - **核心实现思想**：遍历操作记录行列染色信息，最后比较行列染色时间填充矩阵。

### 最优关键思路或技巧
利用离线操作思想，记录每行每列最后一次染色的颜色和时间，避免重复更新同一行或列，在输出时通过比较行列染色时间确定每个格子最终颜色，从而将时间复杂度从暴力的 $O(nmk)$ 优化到 $O(nm + k)$。

### 拓展
同类型题通常是矩阵上的行列操作问题，类似套路是通过记录行列的关键信息（如最后一次操作），避免对每个格子的重复无效操作，优化时间复杂度。

### 推荐题目
- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：与本题类似，都是离线处理最后覆盖问题。
- [P3397 地毯](https://www.luogu.com.cn/problem/P3397)：涉及矩阵区域染色，可类比本题优化思路。
- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：同样是模拟类问题，可锻炼模拟优化能力。

### 个人心得摘录及总结
无。 

---
处理用时：59.44秒
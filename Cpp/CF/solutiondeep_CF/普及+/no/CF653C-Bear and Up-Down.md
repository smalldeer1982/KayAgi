# 题目信息

# Bear and Up-Down

## 题目描述

人生起起落落，就像令人愉快的序列。只要满足了以下两种条件，序列$t1$,$t2$,...,$tn$就叫做令人愉快的：

- 对于每一个奇数$i（i<n）$有$ti<ti+1$;

- 对于每一个偶数$i（i<n）$有$ti>ti+1$;

举个例子，序列$(2,8)$,$(1,5,1)$和$(2,5,1,100,99,120)$就是令人愉快的，但是$(1,1)$,$(1,2,3)$和$(2,5,3,2)$就不是。

Bear Limak有一个正整数序列$t1$,$t2$,...,$tn$。现在这个序列**不是令人愉快的**，Limak想要通过一次交换来修改它。他将要选择两个指数$i<j$然后交换他们的元素$ti$和$tj$从而得到一个令人愉快的序列。数数有多少种方法可以得到。如果交换的两个元素的指数不同则认为这是两种不同的方法。

## 说明/提示

在第一个样例中，有两种方式通过一次交换得到一个令人满意的序列：

1. 交换$t2=8$和$t4=7$。
1. 交换$t1=2$和$t5=7$。

在第二个样例中，只有一种方式—Limak应该交换$t1=200$和$t4=50$。

## 样例 #1

### 输入

```
5
2 8 4 7 7
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
200 150 100 50
```

### 输出

```
1
```

## 样例 #3

### 输入

```
10
3 2 1 4 1 4 1 4 1 4
```

### 输出

```
8
```

## 样例 #4

### 输入

```
9
1 2 3 4 5 6 7 8 9
```

### 输出

```
0
```

# AI分析结果

### 题目内容
# 熊与上下序列

## 题目描述
人生起起落落，就像令人愉快的序列。只要满足以下两种条件，序列$t1$,$t2$,...,$tn$就叫做令人愉快的：
- 对于每一个奇数$i（i<n）$有$ti<ti + 1$；
- 对于每一个偶数$i（i<n）$有$ti>ti + 1$。

举个例子，序列$(2,8)$，$(1,5,1)$和$(2,5,1,100,99,120)$就是令人愉快的，但是$(1,1)$，$(1,2,3)$和$(2,5,3,2)$就不是。

熊利马克有一个正整数序列$t1$,$t2$,...,$tn$。现在这个序列**不是令人愉快的**，利马克想要通过一次交换来修改它。他将要选择两个指数$i<j$然后交换它们的元素$ti$和$tj$从而得到一个令人愉快的序列。数数有多少种方法可以得到。如果交换的两个元素的指数不同则认为这是两种不同的方法。

## 说明/提示
在第一个样例中，有两种方式通过一次交换得到一个令人满意的序列：
1. 交换$t2 = 8$和$t4 = 7$。
2. 交换$t1 = 2$和$t5 = 7$。

在第二个样例中，只有一种方式 — 利马克应该交换$t1 = 200$和$t4 = 50$。

## 样例 #1
### 输入
```
5
2 8 4 7 7
```
### 输出
```
2
```

## 样例 #2
### 输入
```
4
200 150 100 50
```
### 输出
```
1
```

## 样例 #3
### 输入
```
10
3 2 1 4 1 4 1 4 1 4
```
### 输出
```
8
```

## 样例 #4
### 输入
```
9
1 2 3 4 5 6 7 8 9
```
### 输出
```
0
```

### 算法分类
枚举

### 综合分析与结论
三道题解思路相近，均基于一次交换最多改变四个位置与右边的大小关系，当不合法位置超过4个时无解这一特性。解题关键在于找出不合法位置，然后通过枚举交换位置来判断是否能使序列变得令人愉快。

### 所选的题解
 - **作者：Zzzzzzzm（4星）**
    - **关键亮点**：对不合法位置数量进行分类讨论，逻辑清晰，代码简洁明了。
    - **核心代码**：
```cpp
bool ok(int i){
    if(i < 1 || i >= n)	return 1;
    if((i&1) && a[i] >= a[i+1])	return 0;
    if(!(i&1) && a[i] <= a[i+1])	return 0;
    return 1;
}

vector<int> w;

bool check(int x, int y){
    bool flag = 1;
    swap(a[x], a[y]);
    for(int i = 0; i < w.size(); i++)	if(!ok(w[i]))	flag = 0;
    if(!ok(x) ||!ok(x-1) ||!ok(y) ||!ok(y-1))	flag = 0;
    swap(a[x], a[y]);
    return flag;
}

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)	scanf("%d", &a[i]);
    for(int i = 1; i < n; i++)	if(!ok(i))	w.push_back(i);
    if(w.size() > 4){
        printf("0\n");
		return 0;
    }
    int x = w[0];
    int ans = 0;
    for(int i = 1; i <= n; i++)	if(check(i, x))	ans++;
	for(int i = 1; i <= n; i++)	if(check(i, x+1))	ans++;
	if(check(x, x+1))	ans--;
    printf("%d\n", ans);
    return 0;
}
```
    - **核心思想**：`ok`函数用于判断位置$i$是否合法。`check`函数用于交换位置$x$和$y$后，检查所有不合法位置是否都变得合法。主函数中先找出所有不合法位置，若数量大于4则直接输出0，否则枚举交换位置并统计满足条件的交换方式。
 - **作者：lzyqwq（4星）**
    - **关键亮点**：提供了不用分类讨论的做法，通过维护交换位置变化量$\mathcal{O}(1)$判定，并用`set`去重，时间复杂度为$\mathcal{O}(n\log n)$。
    - **核心思想**：先找出不合法位置，由于一次交换最多改变四个位置和右边的大小关系，所以不合法位置超过4个时无解。枚举不合法位置及其交换位置，通过维护相关位置变化量判断是否消除所有不合法位置，并用`set`避免重复计数。
 - **作者：shao0320（4星）**
    - **关键亮点**：思路简洁，代码实现直接，同样先判断不合法位置数量，然后暴力枚举交换情况。
    - **核心代码**：
```cpp
int check(int x)
{
	if(x<=0||x>=n)return 1;
	if(x%2==1&&a[x]>=a[x+1])return 0;
	if(x%2==0&&a[x]<=a[x+1])return 0;
	return 1;
}
int Swp(int x,int y)
{
	swap(a[x],a[y]);
	int res=1;
	for(int i=0;i<G.size();i++)if(!check(G[i]))res=0;
	if(!check(x)||!check(x+1)||!check(x-1)||!check(y)||!check(y+1)||!check(y-1))res=0;
	swap(a[x],a[y]);
	return res;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<n;i++)if(!check(i))G.pb(i);
	if(G.size()>4)return puts("0"),0;
	int ans=0;
	for(int i=1;i<=n;i++)ans+=Swp(i,G[0]);
	for(int i=1;i<=n;i++)ans+=Swp(i,G[0]+1);
	ans-=Swp(G[0],G[0]+1);
	printf("%d\n",ans);
	return 0;
}
```
    - **核心思想**：`check`函数判断位置$x$是否合法，`Swp`函数交换位置$x$和$y$后检查所有不合法位置是否合法。主函数先找出不合法位置，若数量大于4则输出0，否则枚举交换位置统计满足条件的交换方式。

### 最优关键思路或技巧
利用一次交换最多影响四个位置与右边大小关系这一特性，先判断不合法位置数量，减少不必要的枚举。在枚举交换位置时，通过维护少量关键位置的变化来快速判断交换后序列是否合法，提高效率。

### 可拓展之处
同类型题可涉及对序列特定条件的判断与调整，类似套路是先分析操作对序列元素关系的影响范围，确定无解情况，再通过枚举或其他优化手段解决问题。

### 洛谷相似题目
 - [P1118 数字三角形](https://www.luogu.com.cn/problem/P1118)：通过枚举路径寻找最优解，锻炼对枚举策略的运用。
 - [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：经典的枚举搜索问题，加深对枚举与条件判断的理解。
 - [P1036 选数](https://www.luogu.com.cn/problem/P1036)：通过枚举组合判断是否满足条件，强化枚举与条件判断的结合能力。 

---
处理用时：82.82秒
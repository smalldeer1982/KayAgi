# 题目信息

# Correct Bracket Sequence Editor

## 题目描述

`Polycarp`有一个长度为 $n$ 的括号串。

我们设 $pre_i$ 为字符串中第 $1$ 位到第 $i$ 位的左括号数量减去右括号数量，那么当每个 $1\leqslant i\leqslant n$ ， $pre_i\geqslant0$ 。同时 $pre_n=0$ 时，我们认为这个括号串合法。

现在`Polycarp`为合法括号串设计了一种编辑器，这个编辑器支持如下操作:

1. `L`，将光标左移一格
2. `R`，将光标右移一格
3. `D`，删除这个括号到与它对应的括号之间的所有字符，在删除之后，光标会跳到它右边的没有被删除的最左边的括号处，如果没有这样的括号了，那么光标会跳到它左边的没有被删除的最右边的括号处。

举个例子:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF670E/08b0f9032003921a97680a954e716fd13a3de759.png)

上图中，在第一排左边的串使用`D`，使得 $[2,3]$ 全部被删掉了。

第二排中，使用`D`，删除了 $[4,7]$ ，因为第 $7$ 个括号的配对括号在 $4$ 处。

第三排也是一样。

`Polycarp`的编辑器不支持错误的操作，例如删掉整个字符串。

`Polycarp`对他的设计感到自豪，但是他不会实现这个编辑器，所以他想请你来帮他实现，你能帮他实现编辑器的功能吗？

## 说明/提示

$1\leqslant p\leqslant n\leqslant 5\times 10^5,1\leqslant m\leqslant 5\times 10^5$

## 样例 #1

### 输入

```
8 4 5
(())()()
RDLD
```

### 输出

```
()
```

## 样例 #2

### 输入

```
12 5 3
((()())(()))
RRDLD
```

### 输出

```
(()(()))
```

## 样例 #3

### 输入

```
8 8 8
(())()()
LLLLLLDD
```

### 输出

```
()()
```

# AI分析结果

### 题目内容
# 正确括号序列编辑器

## 题目描述
`Polycarp`有一个长度为 $n$ 的括号串。

我们设 $pre_i$ 为字符串中第 $1$ 位到第 $i$ 位的左括号数量减去右括号数量，那么当每个 $1\leqslant i\leqslant n$ ， $pre_i\geqslant0$ 。同时 $pre_n=0$ 时，我们认为这个括号串合法。

现在`Polycarp`为合法括号串设计了一种编辑器，这个编辑器支持如下操作:
1. `L`，将光标左移一格
2. `R`，将光标右移一格
3. `D`，删除这个括号到与它对应的括号之间的所有字符，在删除之后，光标会跳到它右边的没有被删除的最左边的括号处，如果没有这样的括号了，那么光标会跳到它左边的没有被删除的最右边的括号处。

举个例子:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF670E/08b0f9032003921a97680a954e716fd13a3de759.png)

上图中，在第一排左边的串使用`D`，使得 $[2,3]$ 全部被删掉了。
第二排中，使用`D`，删除了 $[4,7]$ ，因为第 $7$ 个括号的配对括号在 $4$ 处。
第三排也是一样。

`Polycarp`的编辑器不支持错误的操作，例如删掉整个字符串。

`Polycarp`对他的设计感到自豪，但是他不会实现这个编辑器，所以他想请你来帮他实现，你能帮他实现编辑器的功能吗？

## 说明/提示
$1\leqslant p\leqslant n\leqslant 5\times 10^5,1\leqslant m\leqslant 5\times 10^5$

## 样例 #1
### 输入
```
8 4 5
(())()()
RDLD
```
### 输出
```
()
```

## 样例 #2
### 输入
```
12 5 3
((()())(()))
RRDLD
```
### 输出
```
(()(()))
```

## 样例 #3
### 输入
```
8 8 8
(())()()
LLLLLLDD
```
### 输出
```
()()
```

### 算法分类
模拟

### 综合分析与结论
这几道题解的核心思路都是先预处理出每个括号对应的配对括号位置，再利用双向链表来高效实现删除和移动操作。其中的难点在于如何在删除操作后，正确处理光标的移动以及双向链表节点的连接关系，避免出现越界等错误。不同题解在实现细节上有所差异，如节点结构的定义、边界条件的处理方式等。

### 所选的题解
- **尹昱钦**：★★★★
    - **关键亮点**：思路清晰，代码简洁明了。使用栈求出括号配对位置，双向链表储存节点信息，操作实现简洁高效，对边界条件有明确判断。
    - **重点代码核心思想**：用`stack`确定括号配对位置，`struct node`定义双向链表节点，在循环中根据操作字符进行相应的光标移动和删除操作，删除时通过修改双向链表节点指针实现。
    ```cpp
    for(int i=0;i<m;i++){
        if(s2[i]=='L') p=e[p].left;
        else{
            if(s2[i]=='R') p=e[p].right;
            else{
                if(p>e[p].to) p=e[p].to;
                if(e[p].left!=-1) e[e[p].left].right=e[e[p].to].right;
                e[e[e[p].to].right].left=e[p].left;
                if(e[e[p].left].right==n) p=e[p].left;
                else p=e[e[p].to].right;
            }
        }
    }
    ```
- **卷王**：★★★★
    - **关键亮点**：代码结构清晰，利用`stack`预处理括号匹配位置，用数组模拟双向链表，操作逻辑明确。
    - **重点代码核心思想**：通过`stack`匹配括号，记录每个括号对应的配对位置`match`。用数组`l`和`r`模拟双向链表，根据操作字符对光标位置`p`进行移动和删除操作，删除时修改双向链表连接关系。
    ```cpp
    for(int i = 1; i <= m; i++) {
        if(a[i] == 'R') p = r[p];
        if(a[i] == 'L') p = l[p];
        if(a[i] == 'D') {
            int j = match[p];
            if(p > j) swap(p, j);
            r[l[p]] = r[j], l[r[j]] = l[p];
            
            if(r[j]!= n + 1) p = r[j];
            else p = l[p];
        }
    }
    ```
- **One_JuRuo**：★★★★
    - **关键亮点**：先分析TLE原因，再优化得到AC代码，思路具有启发性。同样利用双向链表优化操作，对边界条件处理细致。
    - **重点代码核心思想**：先利用栈匹配括号得到每个括号的配对位置`tz`，用结构体`node`定义双向链表节点。在操作循环中，根据操作字符进行光标移动和删除操作，删除时注意修改双向链表节点连接关系和处理边界情况。
    ```cpp
    for(int i=0;i<m;i++)
    {
        if(t[i]=='L') p=a[p].l;
        if(t[i]=='R') p=a[p].r;
        if(t[i]=='D')
        {
            p=min(p,a[p].tz),tp=a[p].tz;
            if(a[p].l!=-1) a[a[p].l].r=a[tp].r;
            a[a[tp].r].l=a[p].l;
            if(a[a[p].l].r==n) p=a[p].l;
            else p=a[tp].r;
        }
    }
    ```

### 最优关键思路或技巧
利用栈来预处理出每个括号对应的配对括号位置，这是解决删除操作的基础。同时，使用双向链表数据结构来存储括号序列，使得移动和删除操作的时间复杂度降为 $O(1)$，大大提高了算法效率。在实现过程中，要仔细处理双向链表节点的指针修改以及边界条件，确保操作的正确性。

### 可拓展之处
此类题目属于字符串模拟操作类型，类似的题目套路通常是先对字符串进行预处理，得到关键信息（如本题的括号配对），再根据操作需求选择合适的数据结构（如链表、数组等）来优化操作。同类型题可能会改变操作类型、字符串类型（如字母串等），但核心思路都是通过预处理和合适的数据结构来高效模拟操作。

### 推荐洛谷题目
- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：同样是模拟类型题目，通过模拟报数和出圈过程，锻炼对复杂操作的模拟实现能力。
- [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)：涉及字符串的变换操作，需要模拟不同规则下的字符串转换过程，与本题类似在于对字符串操作的模拟实现。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：通过模拟图形的填充过程，考察对二维数组的操作和模拟逻辑的实现，与本题在模拟具体过程上有相似之处。

### 个人心得摘录与总结
ylch提到不能用STL的list搭配记录迭代器，因为list的迭代器在指向的元素被删除之后就会失效，这是在使用STL容器时需要注意的细节。同时强调指针链表写法要注意越界、访问野指针等问题，编写代码时需格外留意细节以避免BUG。 

---
处理用时：67.86秒
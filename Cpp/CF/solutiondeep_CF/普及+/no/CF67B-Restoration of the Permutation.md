# 题目信息

# Restoration of the Permutation

## 题目描述

Let $ A={a_{1},a_{2},...,a_{n}} $ be any permutation of the first $ n $ natural numbers $ {1,2,...,n} $ . You are given a positive integer $ k $ and another sequence $ B={b_{1},b_{2},...,b_{n}} $ , where $ b_{i} $ is the number of elements $ a_{j} $ in $ A $ to the left of the element $ a_{t}=i $ such that $ a_{j}>=(i+k) $ .

For example, if $ n=5 $ , a possible $ A $ is $ {5,1,4,2,3} $ . For $ k=2 $ , $ B $ is given by $ {1,2,1,0,0} $ . But if $ k=3 $ , then $ B={1,1,0,0,0} $ .

For two sequences $ X={x_{1},x_{2},...,x_{n}} $ and $ Y={y_{1},y_{2},...,y_{n}} $ , let $ i $ -th elements be the first elements such that $ x_{i}≠y_{i} $ . If $ x_{i}&lt;y_{i} $ , then $ X $ is lexicographically smaller than $ Y $ , while if $ x_{i}&gt;y_{i} $ , then $ X $ is lexicographically greater than $ Y $ .

Given $ n $ , $ k $ and $ B $ , you need to determine the lexicographically smallest $ A $ .

## 样例 #1

### 输入

```
5 2
1 2 1 0 0
```

### 输出

```
4 1 5 2 3 ```

## 样例 #2

### 输入

```
4 2
1 0 0 0
```

### 输出

```
2 3 1 4 ```

# AI分析结果

### 题目内容
# 排列的恢复

## 题目描述
设 \(A = \{a_1, a_2, \ldots, a_n\}\) 是前 \(n\) 个自然数 \(\{1, 2, \ldots, n\}\) 的任意一个排列。给定一个正整数 \(k\) 和另一个序列 \(B = \{b_1, b_2, \ldots, b_n\}\)，其中 \(b_i\) 是在 \(A\) 中位于元素 \(a_t = i\) 左边且满足 \(a_j \geq (i + k)\) 的元素 \(a_j\) 的数量。

例如，如果 \(n = 5\)，一个可能的 \(A\) 是 \(\{5, 1, 4, 2, 3\}\)。对于 \(k = 2\)，\(B\) 为 \(\{1, 2, 1, 0, 0\}\)。但如果 \(k = 3\)，那么 \(B = \{1, 1, 0, 0, 0\}\)。

对于两个序列 \(X = \{x_1, x_2, \ldots, x_n\}\) 和 \(Y = \{y_1, y_2, \ldots, y_n\}\)，设第 \(i\) 个元素是第一个使得 \(x_i \neq y_i\) 的元素。如果 \(x_i < y_i\)，则 \(X\) 在字典序上小于 \(Y\)；而如果 \(x_i > y_i\)，则 \(X\) 在字典序上大于 \(Y\)。

给定 \(n\)、\(k\) 和 \(B\)，你需要确定字典序最小的 \(A\)。

## 样例 #1
### 输入
```
5 2
1 2 1 0 0
```
### 输出
```
4 1 5 2 3 
```

## 样例 #2
### 输入
```
4 2
1 0 0 0
```
### 输出
```
2 3 1 4 
```

### 算法分类
贪心

### 题解综合分析与结论
所有题解思路基本一致，均采用贪心策略。核心思路是每次在 \(b\) 数组中找到第一个 \(0\) 出现的位置，将其存入结果数组 \(a\) 中，然后根据题目条件更新 \(b\) 数组。解决难点在于理解题目中 \(b_i\) 的定义以及如何通过更新 \(b\) 数组来满足条件并得到字典序最小的排列。各题解在思路清晰度、代码可读性上有所差异，但整体围绕同一核心算法。

### 所选的题解
- **作者：_int123_ (4星)**
  - **关键亮点**：思路阐述清晰，代码简洁明了，对核心操作如寻找 \(b\) 数组中第一个 \(0\) 的位置及更新 \(b\) 数组的过程，在代码注释中有详细说明。
  - **重点代码 - 核心实现思想**：通过两层循环，外层循环遍历 \(n\) 次确定结果数组 \(a\) 的每个元素，内层循环找到 \(b\) 数组中第一个 \(0\) 的位置并更新 \(b\) 数组。
```cpp
for(int i=1;i<=n;i++)
{
    int q=1;
    while(b[q]!=0) q++;
    a[i]=q;
    b[q]--;
    for(int j=1;j+k<=q;j++) b[j]--;
}
```
- **作者：2024sdhkdj (4星)**
  - **关键亮点**：对为什么要将找到的位置存入数组而不直接输出有明确解释，代码使用了快读快写优化输入输出。
  - **重点代码 - 核心实现思想**：与_int123_类似，通过循环找到 \(b\) 数组中第一个 \(0\) 的位置 \(wz\) 存入 \(a\) 数组，并更新 \(b\) 数组。
```cpp
for(int i=1;i<=n;i++){
    wz=1;
    while(b[wz])
        wz++;
    a[i]=wz;
    b[wz]--;
    for(int j=1;j+k<=wz;j++)
        b[j]--;
}
```
- **作者：btng_smith666 (4星)**
  - **关键亮点**：对核心变量 \(qwq\) 的作用及操作有详细说明，代码逻辑清晰，对每个关键步骤在注释中有解释。
  - **重点代码 - 核心实现思想**：利用 \(qwq\) 寻找 \(b\) 数组中第一个 \(0\) 的位置，存入 \(a\) 数组并按规则更新 \(b\) 数组。
```cpp
for(int i=1;i<=n;i++)
{
    qwq=1;
    while(b[qwq]!=0)
        qwq++;
    a[i]=qwq;
    b[qwq]--;
    for(int j=1;qwq>=j+k;b[j]--,j++);
}
```

### 最优关键思路或技巧
采用贪心策略，每次选择 \(b\) 数组中第一个 \(0\) 的位置作为结果数组 \(a\) 当前位置的元素，这样能保证得到字典序最小的排列。同时，在每次确定 \(a\) 的元素后，根据条件准确更新 \(b\) 数组，确保后续操作的正确性。

### 拓展
同类型题通常围绕数组元素关系的构造与推导，类似算法套路是通过分析给定条件，找到一种贪心选择策略，每次做出局部最优选择以达到全局最优。例如，一些根据数组元素间大小关系、数量关系构造特定数组的题目。

### 洛谷相似题目推荐
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)
- [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)

### 个人心得摘录与总结
无。 

---
处理用时：45.45秒
# 题目信息

# The Values You Can Make

## 题目描述

Pari想向Arya买一块昂贵的巧克力。她有n个硬币，第i个硬币的价值是ci。巧克力的价格是k，所以Pari需要把总价值为k的硬币给Arya。现在Pari想要知道所有的值x，使得存在总和为k的硬币，其中某些硬币的总价值为x。

## 样例 #1

### 输入

```
6 18
5 6 1 10 12 2
```

### 输出

```
16
0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 
```

## 样例 #2

### 输入

```
3 50
25 25 50
```

### 输出

```
3
0 25 50 
```

# AI分析结果

### 题目内容
# 你能组成的值

## 题目描述
Pari想向Arya买一块昂贵的巧克力。她有n个硬币，第i个硬币的价值是ci。巧克力的价格是k，所以Pari需要把总价值为k的硬币给Arya。现在Pari想要知道所有的值x，使得存在总和为k的硬币，其中某些硬币的总价值为x。

## 样例 #1
### 输入
```
6 18
5 6 1 10 12 2
```
### 输出
```
16
0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 
```

## 样例 #2
### 输入
```
3 50
25 25 50
```
### 输出
```
3
0 25 50 
```

### 算法分类
动态规划

### 综合分析与结论
这些题解的核心思路都是基于动态规划，通过定义合适的状态和状态转移方程来解决问题。主要难点在于如何准确地定义状态以满足题目要求，以及如何优化空间和时间复杂度。不同题解在状态定义和优化方式上略有不同，但本质都是解决“在给定硬币集合中找出总和为k的子集，并进一步找出该子集中所有可能的子集和”这一问题。

### 所选的题解
 - **作者：DennyQi (赞：3)，星级：4星**
    - **关键亮点**：状态定义清晰，$dp_{i,j,k}$表示前$i$个元素中选出一个和为$j$的子集，这个子集凑出$k$是否可行，状态转移方程直观，利用滚动数组优化空间复杂度。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; ++i){
    for(int j = K; j >= a[i]; --j){
        for(int k = 500; k >= 0; --k){
            if(k>=a[i])dp[j][k] |= dp[j-a[i]][k-a[i]];
            dp[j][k] |= dp[j-a[i]][k];
        }
    }
}
```
    - **核心实现思想**：通过三层循环遍历，根据状态转移方程更新$dp$数组，其中外层循环遍历硬币，中间层循环从大到小遍历背包容量（即总和为$j$的情况），内层循环遍历所有可能的子集和$k$，根据前一个硬币的状态更新当前状态。

 - **作者：lory1608 (赞：2)，星级：4星**
    - **关键亮点**：提出用$dp[i][j][k]$表示前$i$个物品，价值为$j$元，$k$元的物品是否能取到，状态转移方程明确，还提到用滚动数组优化空间到$\Theta(n^2)$，以及用bitset将时间压为$\Theta(\frac{n^3}{\omega})$，优化思路全面。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i)
{
    now=now^1,last=now^1;
    for(int j=0;j<=k;++j)dp[now][j].reset();
    scanf("%d",&a);
    for(int j=0;j<=k-a;++j)
    {
        dp[now][j+a]|=dp[last][j]|(dp[last][j]<<a);
    }
    for(int j=0;j<=k;++j)
    {
        dp[now][j]|=dp[last][j];
    }
}
```
    - **核心实现思想**：利用滚动数组优化空间，每次更新当前层$dp$数组时，先重置当前层，然后根据上一层$dp$数组的状态，通过位运算更新当前层状态，实现状态转移。

 - **作者：S00021 (赞：1)，星级：4星**
    - **关键亮点**：同样基于$dp_{i,j,k}$状态定义，利用`bitset`优化时间复杂度，同时使用滚动数组优化空间复杂度，代码简洁明了。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)	
    for(int j=0;j<=k;j++){
        f[i&1][j]=f[(i&1)^1][j];
        if(j>=a[i]) f[i&1][j]=(f[i&1][j])|(f[(i&1)^1][j-a[i]])|(f[(i&1)^1][j-a[i]]<<a[i]);
    }
```
    - **核心实现思想**：利用位运算和滚动数组，在遍历每个硬币时，根据前一个硬币的状态更新当前状态，`bitset`的使用有效减少了时间复杂度。

### 最优关键思路或技巧
1. **状态定义**：通过三维状态$dp_{i,j,k}$来记录前$i$个硬币中，选出和为$j$的子集，该子集能否凑出$k$，这种状态定义能很好地满足题目需求。
2. **滚动数组优化**：通过滚动数组优化空间，将三维数组降为二维数组，减少空间复杂度。
3. **位运算优化**：使用`bitset`进行位运算，优化时间复杂度，利用`bitset`的特性可以快速进行状态转移。

### 可拓展之处
同类型题通常围绕背包问题的变形，如多重背包、分组背包等。类似算法套路是在解决子集和问题时，合理定义状态和状态转移方程，根据数据范围考虑空间和时间复杂度的优化，如滚动数组、位运算等优化技巧。

### 推荐洛谷题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：基础的01背包问题，有助于理解背包问题的基本思路。
2. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：多重背包问题，可进一步拓展对背包问题的理解。
3. [P2679 子串分值和](https://www.luogu.com.cn/problem/P2679)：虽然不是传统背包问题，但同样需要通过合理定义状态和状态转移方程解决，锻炼动态规划思维。

### 个人心得摘录与总结
无。 

---
处理用时：70.14秒
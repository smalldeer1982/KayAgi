# 题目信息

# Thor

## 题目描述

（可能无关紧要的地方有点漏洞，但不会影响题意）

雷神常常要去地球，所以洛基给**她**一款智能手机作为礼物。手机上安装了n款应用，每款应用都会跳出很多消息，在每一单位时间，会发生以下3种事件之一：

- 1) 第x个应用跳出了一条消息

- 2) 雷神读了第x个应用跳出的所有消息

- 3) 雷神读了所有应用跳出的前x条消息

雷神很不喜欢手机上有一堆“99+”，所以**她**希望知道，每一分钟后有多少条新消息未读。

## 说明/提示

对于100%的数据，满足$1<=n,q<=300000$，且保证每个事件合法。

## 样例 #1

### 输入

```
3 4
1 3
1 1
1 2
2 3
```

### 输出

```
1
2
3
2
```

## 样例 #2

### 输入

```
4 6
1 2
1 4
1 2
3 3
1 3
1 3
```

### 输出

```
1
2
3
0
1
2
```

# AI分析结果

### 题目内容
# 雷神

## 题目描述
（可能无关紧要的地方有点漏洞，但不会影响题意）
雷神常常要去地球，所以洛基给她一款智能手机作为礼物。手机上安装了n款应用，每款应用都会跳出很多消息，在每一单位时间，会发生以下3种事件之一：
- 1) 第x个应用跳出了一条消息
- 2) 雷神读了第x个应用跳出的所有消息
- 3) 雷神读了所有应用跳出的前x条消息
雷神很不喜欢手机上有一堆“99+”，所以她希望知道，每一分钟后有多少条新消息未读。

## 说明/提示
对于100%的数据，满足$1<=n,q<=300000$，且保证每个事件合法。

## 样例 #1
### 输入
```
3 4
1 3
1 1
1 2
2 3
```
### 输出
```
1
2
3
2
```

## 样例 #2
### 输入
```
4 6
1 2
1 4
1 2
3 3
1 3
1 3
```
### 输出
```
1
2
3
0
1
2
```

### 算法分类
模拟

### 综合分析与结论
三道题解均采用模拟的思路解决问题，核心是根据题目给定的三种事件类型，对应用消息的产生和读取进行模拟，并实时计算未读消息数量。
- **思路方面**：都围绕三种事件展开，对每个事件进行相应处理。
- **算法要点**：借助队列数据结构存储应用消息，方便按顺序处理消息的进出。同时记录消息是否已读等状态。
- **解决难点**：主要难点在于高效处理不同类型事件，特别是事件3需要遍历所有应用的消息来读取前x条。各题解通过不同方式优化此操作，如记录已处理的最大消息序号等。

### 所选的题解
- **作者：Sea_Level (4星)**
    - **关键亮点**：思路清晰，代码注释详细。使用两个队列分别存储每个应用的消息和所有消息，便于不同操作的实现，同时用数组标记消息是否已读，逻辑简洁明了。
    ```cpp
    #include<iostream>
    #include<queue>
    using namespace std;
    queue<int> que[300010];
    queue<pair<int,int> > t;
    int v[300010];
    int n,q,cnt=1,ans=0;
    int main(){
        cin>>n>>q;
        for(int i=1;i<=q;i++){
            int f,num;
            cin>>f>>num;
            if(f==1){
                ans++;
                que[num].push(cnt);
                t.push(make_pair(cnt,num));
                cnt++;
            }
            if(f==2){
                while(que[num].size()){
                    v[que[num].front()]=1;
                    que[num].pop();
                    ans--;
                }
            }
            if(f==3){
                while(t.size()&&t.front().first<=num){
                    if(!v[t.front().first]){
                        v[t.front().first]=1;
                        que[t.front().second].pop();
                        ans--;
                    }
                    t.pop();
                }
            }
            cout<<ans<<endl;
        }
        return 0;
    }
    ```
    - **核心实现思想**：对于事件1，将新消息加入对应应用队列和总消息队列，并更新未读消息数；事件2，遍历特定应用队列，标记并移除已读消息，更新未读消息数；事件3，遍历总消息队列，处理前x条未读消息，更新未读消息数。

- **作者：shiroi (4星)**
    - **关键亮点**：代码简洁，通过巧妙维护消息编号和所属应用的关系，直接模拟每个输入事件。在处理事件3时，通过记录已处理的最大消息编号来优化遍历。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    inline int read()
    {
        int x=0; int f=1; char ch=getchar();
        while(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}
        while(isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}
        return x*f;
    }

    const int MAXN = 300005;
    queue<int> a[MAXN];
    int num[MAXN];
    int n,m,q,ans,lst;

    int main(int argc, char const *argv[])
    {
        n=read(); q=read();
        for(int i=1; i<=q; i++)
        {
            int opt=read(),t=read();
            if(opt==1) ans++,num[++m]=t,a[t].push(m);
            else if(opt==2)
                while(!a[t].empty())
                    a[t].pop(),ans--;
            else
            {
                while(lst<t)
                {
                    lst++;
                    if(!a[num[lst]].empty())
                        if(a[num[lst]].front()<=lst)
                            a[num[lst]].pop(),ans--;
                }
            }
            printf("%d\n",ans);
        }
        return 0;
    }
    ```
    - **核心实现思想**：事件1，增加未读消息数，记录消息所属应用并加入队列；事件2，清空特定应用队列并减少未读消息数；事件3，从已记录的消息中按顺序处理前x条，更新未读消息数。

### 最优关键思路或技巧
使用队列存储消息，能方便地按顺序处理消息的进出，符合题目中消息产生和读取的顺序性特点。同时，记录已处理的最大消息序号等方式，可以优化事件3中对所有应用前x条消息读取的操作，避免重复遍历，提高效率。

### 可拓展之处
此类题目属于模拟类型，常见拓展方向为增加事件类型或改变消息处理规则。类似算法套路是在面对按时间顺序发生的多种操作，且操作涉及数据的增删改查时，合理选择数据结构（如队列、栈、哈希表等）进行模拟。

### 洛谷相似题目
- [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)
- [P1425 小鱼的游泳时间](https://www.luogu.com.cn/problem/P1425) 

---
处理用时：55.34秒
# 题目信息

# Paint it really, really dark gray

## 题目描述

给你一棵节点编号为$1...n$的树，每个节点都有两种颜色：粉色或黑色。现在你要从1号节点（即树根）出发，每经过一个节点，该节点的颜色就会改变。（粉色变为黑色，黑色变为粉色）。

现在请你找出一条从1号节点（即树根）出发的路径，使得沿这条路径走完后，所有的节点颜色都变为黑色。**注意：你可以经过一个节点或一条边多次，并且路径不要求一定要在1号节点（即树根）结束。**

-----------------------------

## 样例 #1

### 输入

```
5
1
1
-1
1
-1
2 5
4 3
2 4
4 1
```

### 输出

```
1 4 2 5 2 4 3 4 1 4 1
```

# AI分析结果

### 题目内容
# 把它涂成深灰色

## 题目描述
给你一棵节点编号为1到n的树，每个节点都有两种颜色：粉色或黑色。现在你要从1号节点（即树根）出发，每经过一个节点，该节点的颜色就会改变。（粉色变为黑色，黑色变为粉色）。

现在请你找出一条从1号节点（即树根）出发的路径，使得沿这条路径走完后，所有的节点颜色都变为黑色。**注意：你可以经过一个节点或一条边多次，并且路径不要求一定要在1号节点（即树根）结束。**

-----------------------------

## 样例 #1
### 输入
```
5
1
1
-1
1
-1
2 5
4 3
2 4
4 1
```
### 输出
```
1 4 2 5 2 4 3 4 1 4 1
```

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
两题解思路相似，均采用递归的深度优先搜索来解决问题。主要难点在于确定递归结束后节点的状态以及构造满足条件的路径。
 - **思路**：都是从根节点出发，通过递归处理子树，逐步将所有节点染成黑色。
 - **算法要点**：对每个节点，先处理其子树，再处理该节点与子节点间颜色不一致的情况。
 - **解决难点**：通过合理定义递归函数的返回状态，使得问题可解。如第一个题解定义`dfs(x)`表示从`x`开始走最后回到`x`，将以`x`为根的子树中除`x`以外的节点都变成黑色；第二个题解类似，通过递归遍历子树并调整路径来改变节点颜色。

### 所选的题解
 - **作者：MY（一名蒟蒻）**  星级：4星
    - **关键亮点**：思路阐述清晰，先点明定义递归结束状态的难点，再给出合理的递归定义，使问题变得可做，代码实现简洁明了。
    - **重点代码及核心思想**：
```cpp
void dfs(int x)
{
    printf("%d ",x);
    for(int i=fir[x];i;i=e[i].nex)
        if(e[i].to^fa[x])
        {
            col[e[i].to]^=1;//往子树走
            dfs(e[i].to);
            printf("%d ",x);
            col[x]^=1;//回来
            if(!col[e[i].to])//处理儿子颜色
            {
                printf("%d %d ",e[i].to,x);
                col[e[i].to]=1;
                col[x]^=1;
            }
        }
    return ;
}
```
核心思想是在`dfs`函数中，先输出当前节点，遍历子节点，进入子节点递归前改变子节点颜色，递归回来后再改变当前节点颜色，若子节点颜色为白则再次往返该子节点以变黑。
 - **作者：water_tomato**  星级：4星
    - **关键亮点**：从简单情况入手阐述思路，即先考虑深度为2的树的染色方式，进而推广到整棵树，代码实现逻辑较清晰。
    - **重点代码及核心思想**：
```cpp
inline void dfs(int u,int fa){
    bool yezi=true;
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==fa) continue;
        yezi=false;
    }
    if(!yezi){//走到 u
        step[++tot]=u;
        change(u);
    }
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==fa) continue;
        dfs(v,u);
        if(col[v]==-1){//处理儿子中的粉点
            step[++tot]=v;
            step[++tot]=u;
            change(v);change(u);
        }
    }
    if(!yezi&&fa!=0){//走回到父亲
        step[++tot]=fa;
        change(fa);
    }
}
```
核心思想是在`dfs`函数中，先判断当前节点是否为叶子节点，若不是则记录并改变当前节点颜色，遍历子节点递归处理，若子节点为粉色则添加往返路径以改变颜色，最后若当前节点不是叶子且有父亲则返回父亲并改变父亲颜色。

### 最优关键思路或技巧
通过递归的深度优先搜索，合理定义递归函数的结束状态，从根节点开始，自顶向下处理子树，在遍历子树过程中巧妙处理节点颜色变化，通过往返路径改变节点颜色，最终使整棵树的节点都变为黑色。

### 可拓展之处
同类型题通常围绕树结构上的状态改变与路径构造。类似算法套路是在树的递归遍历过程中，根据节点的当前状态和目标状态，合理规划路径以满足特定条件。

### 洛谷相似题目推荐
 - [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：同样涉及图（树可看作特殊的图）上的路径问题，不过该题重点在求最短路，可加深对图上路径搜索的理解。
 - [P2325 [SCOI2005] 王室联邦](https://www.luogu.com.cn/problem/P2325)：树的相关问题，通过对树的遍历和划分来解决问题，锻炼对树结构的处理能力。
 - [P1127 词链](https://www.luogu.com.cn/problem/P1127)：虽然不是树结构，但同样是通过搜索来构造满足条件的序列，与本题构造路径思路有相似之处。 

---
处理用时：61.09秒
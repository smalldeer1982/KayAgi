# 题目信息

# Lakes in Berland

## 题目描述

**【问题描述】** ldxxx已经填完了所有的坑，现在他要给土地浇水来保证幼苗的茁壮成长。然而他刚要浇水，就迎来了瓢泼大雨，由于土地渗透性不一，所以有的土地上存在积水，连在一起的积水就形成了一个小湖泊（只有四周被陆地完全包围的才算湖泊，只要和边界有交点就不算湖泊），这时cs告诉ldxxx说如果能将湖泊的数量缩小到一个值k的话，他的庄稼长得应该最茂盛。但是由于ldxxx很笨，不知道该怎么填，所以ldxxx把浇水的任务给了cs，由于这次是义务劳动，所以cs很懒，想填最少的水使得湖泊数量为k你需要告诉他把湖泊数降到**不大于k**至少需要填多少块，并且把填好后的土地积水情况给他打印出来。 注意：只有四周被陆地完全包围的才算湖泊，只要和边界有交点就不算湖泊。

题面翻译来自accoders

## 说明/提示

$1\le n,m\le50,0\le k\le50$

## 样例 #1

### 输入

```
5 4 1
****
*..*
****
**.*
..**
```

### 输出

```
1
****
*..*
****
****
..**
```

## 样例 #2

### 输入

```
3 3 0
***
*.*
***
```

### 输出

```
1
***
***
***
```

# AI分析结果

### 题目内容
# 伯兰的湖泊

## 题目描述
**【问题描述】** ldxxx已经填完了所有的坑，现在他要给土地浇水来保证幼苗的茁壮成长。然而他刚要浇水，就迎来了瓢泼大雨，由于土地渗透性不一，所以有的土地上存在积水，连在一起的积水就形成了一个小湖泊（只有四周被陆地完全包围的才算湖泊，只要和边界有交点就不算湖泊），这时cs告诉ldxxx说如果能将湖泊的数量缩小到一个值k的话，他的庄稼长得应该最茂盛。但是由于ldxxx很笨，不知道该怎么填，所以ldxxx把浇水的任务给了cs，由于这次是义务劳动，所以cs很懒，想填最少的水使得湖泊数量为k。你需要告诉他把湖泊数降到**不大于k**至少需要填多少块，并且把填好后的土地积水情况给他打印出来。 注意：只有四周被陆地完全包围的才算湖泊，只要和边界有交点就不算湖泊。

题面翻译来自accoders

## 说明/提示
$1\le n,m\le50,0\le k\le50$

## 样例 #1
### 输入
```
5 4 1
****
*..*
****
**.*
..**
```
### 输出
```
1
****
*..*
****
****
..**
```

## 样例 #2
### 输入
```
3 3 0
***
*.*
***
```
### 输出
```
1
***
***
***
```

### 算法分类
贪心、深度优先搜索 DFS

### 综合分析与结论
所有题解思路核心一致，均先通过搜索识别湖泊，利用贪心策略，选择面积小的湖泊填充，以达减少湖泊数量且填充量最小目的。主要差异在搜索实现及数据处理细节。部分题解用DFS，部分用BFS；存储湖泊信息结构与处理方式也有不同。
1. **思路**：遍历地图找水区域，用搜索判断是否为湖泊并统计大小。将湖泊按大小排序，贪心选取小湖泊填充，直到湖泊数不大于k。
2. **算法要点**：准确搜索识别湖泊，合理存储湖泊信息，按大小排序，贪心填充。
3. **解决难点**：正确判断湖泊（与边界无交点）；高效搜索统计湖泊大小；合理贪心保证填充最少。

### 所选的题解
- **作者：云雀酱 (5星)**
    - **关键亮点**：思路清晰，代码结构完整，详细注释。先定义结构体存湖泊信息，用DFS统计湖泊，再排序贪心填充。
    - **重点代码**：
```cpp
//dfs函数，用来统计湖的数量，大小及位置
void dfs(int x,int y){
    //如果这个湖有一部分在边界，那么直接标记它不是湖
    if(x==1||x==n||y==1||y==m) is=true;
    lake[num].size++;
    mark[x][y]=true;
    //四向数组搜索
    for(int i=0;i<=3;i++){
        int xx=x+dx[i],yy=y+dy[i];
        if(x<1||x>n||y<1||y>m) continue;
        if(mark[xx][yy]==false&&graph[xx][yy]=='.'){
            dfs(xx,yy);
        }
    }
}
//用来填湖输出的dfs2函数
void dfs2(int x,int y){
    graph[x][y]='*';
    for(int i=0;i<=3;i++){
        int xx=x+dx[i],yy=y+dy[i];
        if(x<1||x>n||y<1||y>m) continue;
        if(graph[xx][yy]=='.'){
            dfs2(xx,yy);
        }
    }
}
```
核心实现思想：`dfs`函数通过递归四向搜索统计湖泊大小并标记，同时判断是否为边界湖泊；`dfs2`函数用于填充湖泊。
- **作者：Tjaweiof (4星)**
    - **关键亮点**：利用优先队列简化排序与选择小湖泊过程，代码简洁。
    - **重点代码**：
```cpp
void dfs(int x, int y){
    vis[x][y] = true;
    res[dx][dy].push_back({x, y});
    for (int k = 0; k < 4; k++){
        int nx = x + nextstep[k][0], ny = y + nextstep[k][1];
        if (nx < 1 || nx > n || ny < 1 || ny > m){
            t[dx][dy] = false;
            continue;;
        }
        if (vis[nx][ny]){
            continue;
        }
        if (a[nx][ny] == '.'){
            dfs(nx, ny);
        }
    }
    return;
}
```
核心实现思想：`dfs`函数标记访问点，记录湖泊位置，四向搜索扩展，判断是否为边界湖泊。
- **作者：wuyixiang (4星)**
    - **关键亮点**：结构体存储湖泊编号与面积，排序后按编号转换湖泊为陆地，逻辑清晰。
    - **重点代码**：
```cpp
void dfs(int x,int y,int num){
    if(x > n || x < 1 || y > m || y < 1)//如果与边界相邻，则将它标记，代表不是水洼
    {
        r = 1;
        return ;
    }
    if(a[x][y] == '*' || b[x][y])return ;
    b[x][y] = num,val ++;
    dfs(x + 1,y,num);//四方向遍历
    dfs(x - 1,y,num);
    dfs(x,y + 1,num);
    dfs(x,y - 1,num);
}
```
核心实现思想：`dfs`函数标记访问点，记录湖泊编号与面积，四向搜索扩展，判断是否为边界湖泊。

### 最优关键思路或技巧
1. **贪心策略**：优先填充小湖泊保证填充量最少。
2. **搜索应用**：DFS或BFS搜索识别与统计湖泊，注意边界判断。

### 可拓展之处
同类型题常涉及连通块处理与条件限制下的最优操作，类似套路是先搜索识别连通块，再依题目条件贪心或动态规划处理。

### 推荐题目
1. **P1162 填涂颜色**：涉及连通块识别与处理。
2. **P1339 热浪**：可类比搜索与最优解寻找思路。
3. **P1596 湖计数**：同样处理连通块问题，判断条件有差异。 

---
处理用时：72.76秒
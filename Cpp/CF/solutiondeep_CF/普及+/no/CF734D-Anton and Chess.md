# 题目信息

# Anton and Chess

## 题目描述

Anton喜欢下棋与编程，所以他决定写一个国际象棋游戏。然而，他认为8x8的棋盘太简单了，因此这个棋盘是无限大的。



他的第一个任务是检查当前状态下是否被将军，他并不知道如何实现这点，因此向你求助。



棋盘上有一个白色方的王与n个黑色方的棋子，它们仅由车、象和后组成。当至少一个黑色方的棋子可以在一步内移动到白色方王所在的格子时被视为将军。



帮助Anton写一个程序，在给定所有棋子的位置时判定白色方的王是否被将军。



以下是各种棋子的移动方式：



- 象可以斜着移动，格子不限。

- 车可以水平或垂直移动，格子不限。

- 后可以水平、垂直或斜着移动，格子不限。

- 所有的棋子不能越过已经占用的格子。

## 样例 #1

### 输入

```
2
4 2
R 1 1
B 1 5
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
2
4 2
R 3 3
B 1 5
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# Anton和国际象棋

## 题目描述
Anton喜欢下棋与编程，所以他决定写一个国际象棋游戏。然而，他认为8x8的棋盘太简单了，因此这个棋盘是无限大的。

他的第一个任务是检查当前状态下是否被将军，他并不知道如何实现这点，因此向你求助。

棋盘上有一个白色方的王与n个黑色方的棋子，它们仅由车、象和后组成。当至少一个黑色方的棋子可以在一步内移动到白色方王所在的格子时被视为将军。

帮助Anton写一个程序，在给定所有棋子的位置时判定白色方的王是否被将军。

以下是各种棋子的移动方式：
- 象可以斜着移动，格子不限。
- 车可以水平或垂直移动，格子不限。
- 后可以水平、垂直或斜着移动，格子不限。
- 所有的棋子不能越过已经占用的格子。

## 样例 #1
### 输入
```
2
4 2
R 1 1
B 1 5
```
### 输出
```
YES
```

## 样例 #2
### 输入
```
2
4 2
R 3 3
B 1 5
```
### 输出
```
NO
```

### 算法分类
模拟

### 综合分析与结论
这几道题解思路本质相同，均利用“棋子不能越过已被占用的格子”这一条件，只关注白王八个方向上离它最近的棋子能否将军，避免逐个模拟棋子移动导致的时间复杂度过高问题，将时间复杂度优化到O(n)。不同题解在代码实现细节、变量命名及数据结构使用上存在差异。

### 所选的题解
- **作者：A_R_O_N_A (5星)**
    - **关键亮点**：思路清晰，对题目分析详细，先指出暴力模拟不可行，再阐述利用方向优化的思路，代码注释详细，变量命名有意义。
    - **核心代码**：
```cpp
ll kx,ky,n,mndis=LLONG_MAX;
struct node{
    char type;
    ll nowx,nowy;
}a[500005];
struct danger{
    char type;
    ll nowx,nowy;
}e[9];
int main(){
    n=read();
    kx=read();ky=read();
    for(int i=1;i<=n;i++){
        cin>>a[i].type;
        a[i].nowx=read();
        a[i].nowy=read();
    }
    for(int i=1;i<=n;i++){//左上 
        if(a[i].nowx-kx==a[i].nowy-ky&&a[i].nowx-kx<0&&mndis>abs(a[i].nowx-kx)){
            e[1]={a[i].type,a[i].nowx,a[i].nowy};
            mndis=abs(a[i].nowx-kx);
        }
    }
    // 其他方向类似代码省略
    if(e[1].type=='B'||e[1].type=='Q'){//左上，象和后可将军
        puts("YES");
        return 0;
    }
    // 其他方向判断类似代码省略
    puts("NO");
    return 0;
}
```
    - **核心实现思想**：定义结构体存储棋子信息，通过循环枚举每个方向上的棋子，找出离白王最近的棋子，最后判断该方向最近棋子能否将军。
- **作者：泠小毒 (4星)**
    - **关键亮点**：代码简洁明了，直接通过条件判断找到八个方向上离白王最近的棋子，并判断是否能将军。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{char opt;int x,y;}a[500010];
int n,x,y,U,D,L,R,UL,UR,DL,DR,flg;
int main()
{
    scanf("%d%d%d",&n,&x,&y);
    for(int i=1;i<=n;i++)
    {
        for(a[i].opt=getchar();a[i].opt!='R'&&a[i].opt!='B'&&a[i].opt!='Q';a[i].opt=getchar());
        scanf("%d%d",&a[i].x,&a[i].y);
        if(a[i].x==x)
        {
            if(a[i].y>y)
            {
                if(U==0||a[i].y<a[U].y)
                    U=i;
            }
            else
            {
                if(D==0||a[i].y>a[D].y)
                    D=i;
            }
        }
        // 其他方向类似代码省略
    }
    if(a[U].opt=='R'||a[U].opt=='Q')flg=1;
    // 其他方向判断类似代码省略
    if(flg)puts("YES");else puts("NO");
    return 0;
}
```
    - **核心实现思想**：定义结构体存储棋子信息，在输入棋子位置时，同时判断棋子是否在白王八个方向上，并更新每个方向上最近棋子的索引，最后根据最近棋子类型判断是否将军。
- **作者：Escapism (4星)**
    - **关键亮点**：先阐述两种思路并对比效率，选择高效思路后，清晰列出每个方向能将军的棋子类型，代码逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 * 5 + 5;
struct node{
    char chess;
    int x,y;
} a[MAXN];
int n,x,y,up,dw,le,ri,lu,ld,ru,rd;
bool flag;
int main(){
    cin>>n>>x>>y;
    for(int i = 1;i <= n;i++){
        for(a[i].chess = getchar();a[i].chess!= 'R' && a[i].chess!= 'B' && a[i].chess!= 'Q';a[i].chess = getchar());
        cin>>a[i].x>>a[i].y;
        if(a[i].x == x){
            if(a[i].y > y){
                if(up == 0 || a[i].y < a[up].y)
                    up=i;
            }
            else{
                if(dw == 0 || a[i].y > a[dw].y)
                    dw = i;
            }
        }
        // 其他方向类似代码省略
    }
    if(a[up].chess == 'R' || a[up].chess == 'Q')flag = 1;
    // 其他方向判断类似代码省略
    if(flag == true) cout<<"YES";
    else cout<<"NO";
    return 0;
}
```
    - **核心实现思想**：与泠小毒题解类似，定义结构体存储棋子信息，输入时确定每个方向上离白王最近的棋子索引，最后根据棋子类型判断是否将军。

### 最优关键思路或技巧
利用“棋子不能越过已被占用的格子”这一规则，只关注白王八个方向上最近的棋子，避免对所有棋子移动的暴力模拟，有效优化时间复杂度。在代码实现上，通过合理使用结构体和条件判断，简洁地实现对每个方向最近棋子的查找与将军判断。

### 同类型题或类似算法套路拓展
此类题目属于模拟类型，关键在于根据游戏规则优化判断逻辑。类似套路可应用于其他棋盘类游戏状态判断问题，例如判断围棋中某个棋子是否被提掉、中国象棋中某个棋子是否被将军等，都可通过分析规则，确定关键影响方向或位置，减少不必要的模拟计算。

### 洛谷相似题目推荐
- **P1036 [NOIP2002 普及组] 选数**：通过枚举和简单计算判断数字组合是否满足特定条件，锻炼对条件的分析和模拟能力。
- **P1161 开灯**：模拟开关灯的过程，根据题目规则进行状态变化的模拟与计算。
- **P1880 [NOI1995] 石子合并**：虽涉及动态规划，但也包含对合并过程的模拟，有助于提升对复杂规则下模拟过程的理解。 

---
处理用时：74.62秒
# 题目信息

# Igor and his way to work

## 题目描述

伴随着闹钟的铃声，财政分析家 Igor 匆忙起来赶去工作。他吃完早餐后就坐到了他的车上。不幸的，当他打开他的 GPS 导航时，发现在他所居住的小镇 Bankopolis 中的一些道路，由于道路施工而关闭。更不幸的是，车的方向盘有点问题，所以在他去他的银行办公室的途中，**最多只能转两次弯**。

小镇 Bankopolis 可以看做是一个 $n$ 行 $m$ 列的网格图，Igor 需要找到一条从家到银行的道路，这条道路转弯次数最多为 $2$ 次，且不能经过正在维修的道路，或者你可以告诉他不能到达，他应该在家工作。**转弯**定义为 Igor 的车改变一次方向。Igor 的车只能向**上，下，左，右**四个方向行驶。在最开始的时候，Igor 的车可以选择任何方向。因为 Igor 仍然在睡觉，所以请你帮帮他。

## 样例 #1

### 输入

```
5 5
..S..
****.
T....
****.
.....
```

### 输出

```
YES```

## 样例 #2

### 输入

```
5 5
S....
****.
.....
.****
..T..
```

### 输出

```
NO```

# AI分析结果

### 题目内容
# Igor和他的上班之路

## 题目描述
伴随着闹钟的铃声，财政分析家Igor匆忙起来赶去工作。他吃完早餐后就坐到了他的车上。不幸的，当他打开他的GPS导航时，发现在他所居住的小镇Bankopolis中的一些道路，由于道路施工而关闭。更不幸的是，车的方向盘有点问题，所以在他去他的银行办公室的途中，**最多只能转两次弯**。

小镇Bankopolis可以看做是一个$n$行$m$列的网格图，Igor需要找到一条从家到银行的道路，这条道路转弯次数最多为$2$次，且不能经过正在维修的道路，或者你可以告诉他不能到达，他应该在家工作。**转弯**定义为Igor的车改变一次方向。Igor的车只能向**上，下，左，右**四个方向行驶。在最开始的时候，Igor的车可以选择任何方向。因为Igor仍然在睡觉，所以请你帮帮他。

## 样例 #1
### 输入
```
5 5
..S..
****.
T....
****.
.....
```
### 输出
```
YES
```

## 样例 #2
### 输入
```
5 5
S....
****.
.....
.****
..T..
```
### 输出
```
NO
```

### 算法分类
搜索

### 题解综合分析与结论
这些题解主要围绕搜索算法展开，解决从起点“S”到终点“T”，在最多转弯两次且不经过障碍“*”的情况下能否到达的问题。多数题解采用BFS，少数用DFS加记忆化。思路上，有的记录转弯次数、方向等信息进行搜索扩展，有的从起点出发分阶段遍历可到达位置。解决难点在于如何有效记录状态避免重复搜索以及合理处理转弯次数限制。

### 所选的题解
- **作者：I_will_AKIOI (5星)**
    - **关键亮点**：思路清晰，代码简洁。利用BFS，在搜索时记录上次走路方向、当前坐标及转弯次数，对每个点记录最少转弯次数来优化搜索，避免无效路径。
    - **核心代码**：
```cpp
int BFS()
{
    w.s = 0;
    w.last = -1;
    q.push(w);
    while (!q.empty())
    {
        w = q.front();
        int x = w.x, y = w.y, s = w.s, last = w.last;
        if (c[x][y] == 'T') return 1;
        for (int i = 0; i < 4; i++)
        {
            int nx = x + fx[i], ny = y + fy[i], ns = s;
            if (last!= -1 && last!= i) ns++;//和上次不同，转弯
            if (nx < 1 || nx > n || ny < 1 || ny > m || ns > 2 || vis[nx][ny] < ns || c[nx][ny] == '*') continue;//不符合要求的点
            vis[nx][ny] = ns;//更新最少转弯次数
            q.push(Data{nx, ny, ns, i});
        }
        q.pop();
    }
    return 0;
}
```
    - **核心思想**：每次从队列取出一个点，向四个方向拓展，若拓展方向与上次不同则转弯次数加一，判断拓展点是否符合条件（边界、转弯次数、是否障碍等），符合则更新最少转弯次数并入队。
- **作者：Dimly_dust (4星)**
    - **关键亮点**：采用BFS，思路直接。从起点开始先遍历不转弯能到达的位置，再分别从这些位置出发，循环两次遍历转两次弯能到达的所有位置，最后判断终点是否在其中。
    - **核心代码**：
```cpp
int fuck(int x, int y, int shuju)/*遍历矩阵*/
{
    int i = x + 1;
    int j = y;
    while (i < m && d[i][j] == -1 && f[i][j]!= '*')//搜索下方
    {
        d[i++][j] = shuju;
    }
    i = x - 1;
    j = y;
    while (i >= 0 && d[i][j] == -1 && f[i][j]!= '*')//搜索上方
    {
        d[i--][j] = shuju;
    }
    i = x;
    j = y + 1;
    while (j < n && d[i][j] == -1 && f[i][j]!= '*')//搜索右方
    {
        d[i][j++] = shuju;
    }
    i = x;
    j = y - 1;
    while (j >= 0 && d[i][j] == -1 && f[i][j]!= '*')//搜索左方
    {
        d[i][j--] = shuju;
    }
}
```
    - **核心思想**：`fuck`函数实现从某点向四个方向直线遍历，更新可到达点的状态，通过多次调用该函数实现不同转弯次数下的位置遍历。
- **作者：_lxy_ (4星)**
    - **关键亮点**：基于BFS，通过三维数组`vis`记录坐标、方向和转弯次数的状态，在BFS扩展时根据转弯情况进行不同处理，避免重复搜索。
    - **核心代码**：
```cpp
bool bfs(node u)
{
    queue<node>q;
    for (register int i = 0; i < 4; i++) //4个方向
    {
        node v = u;
        v.x += dx[i];
        v.y += dy[i];
        if (v.x >= 1 && v.x <= n && v.y >= 1 && v.y <= m && a[v.x][v.y]!= '*') //能走
        {
            v.z = i;
            v.turns = 2;
            vis[v.x][v.y][i][2] = 1;
            q.push(v);
        }
    }
    while (!q.empty())
    {
        node u = q.front();
        q.pop();
        if (a[u.x][u.y] == 'T') return true; //走到终点了
        for (register int i = 0; i < 4; i++)
        {
            node v = u;
            v.x += dx[i];
            v.y += dy[i];
            if (v.x >= 1 && v.x <= n && v.y >= 1 && v.y <= m && a[v.x][v.y]!= '*') //下一步能走
            {
                if (v.z == i) //方向不变
                {
                    if (!vis[v.x][v.y][i][v.turns]) //之前没有相同方向走过
                    {
                        q.push(v);
                        vis[v.x][v.y][i][v.turns] = true;
                    }
                }
                elif (v.turns > 0)
                {
                    if (!vis[v.x][v.y][i][v.turns - 1])
                    {
                        v.turns--;
                        v.z = i;
                        vis[v.x][v.y][i][v.turns] = true;
                        q.push(v);
                    }
                }
            }
        }
    }
    return 0;
}
```
    - **核心思想**：初始化时将起点向四个方向拓展的点入队，在循环中，每次取出队首元素，若到达终点则返回`true`，否则向四个方向拓展，根据方向是否改变及转弯次数情况判断是否入队并更新状态。

### 最优关键思路或技巧
- **状态记录与剪枝**：通过记录转弯次数、方向等状态信息，利用数组标记已访问的状态，避免重复搜索，如`vis`数组记录最少转弯次数（I_will_AKIOI题解）或坐标 - 方向 - 转弯次数的状态（_lxy_题解），有效减少搜索空间，提高效率。
- **分层搜索**：像Dimly_dust题解，从起点开始分层遍历，先找不转弯能到的位置，再基于这些位置找转一次弯、两次弯能到的位置，清晰地处理转弯次数限制。

### 可拓展思路
此类题目属于网格图上带限制条件的路径搜索问题。类似套路是在搜索过程中记录关键信息（如转弯次数、方向、经过特殊点数量等）来处理限制条件。同类型题可增加转弯次数限制、改变地图形状或增加更多类型的障碍等条件。

### 洛谷相似题目
- [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)：涉及搜索与二分查找，通过搜索满足一定条件的数据。
- [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126)：在网格地图上，机器人按特定规则移动，与本题在网格图搜索上类似。
- [P2734 [USACO3.1]骑马修栅栏 Riding the Fences](https://www.luogu.com.cn/problem/P2734)：同样是图的搜索问题，不过是关于欧拉路径的搜索，可锻炼搜索相关思维。

### 个人心得摘录与总结
- **Creative_sad_yosgic**：尝试暴力和记忆化写法，暴力在第9个点超时，记忆化直接WA。发现不会写记忆化时采用投机取巧思路，从起点分层搜索标记可到达点。总结出在遇到复杂限制条件时，若常规方法不行，可尝试从题目特点出发找特殊解法。 

---
处理用时：71.90秒
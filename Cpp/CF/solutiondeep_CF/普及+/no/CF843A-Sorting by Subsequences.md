# 题目信息

# Sorting by Subsequences

## 题目描述

给你一个由不同整数组成的序列$a_{1},a_{2},...,a_{n}$  
。要求将这个序列分成最多的子序列，使这些子序列按升序排序后，总体序列也成为一个升序序列。

在对子序列进行排序的过程中，只是对子序列中的元素进行升序排序，不在子序列中的元素不会改变它们的位置。

序列中的每个元素都只能且必须在所有子序列中出现一次。（译者：子序列不重合）

## 样例 #1

### 输入

```
6
3 2 1 6 5 4
```

### 输出

```
4
2 1 3
1 2
2 4 6
1 5
```

## 样例 #2

### 输入

```
6
83 -75 -49 11 37 62
```

### 输出

```
1
6 1 2 3 4 5 6
```

# AI分析结果

### 题目内容
# 按子序列排序

## 题目描述
给你一个由不同整数组成的序列$a_{1},a_{2},...,a_{n}$ 。要求将这个序列分成最多的子序列，使这些子序列按升序排序后，总体序列也成为一个升序序列。

在对子序列进行排序的过程中，只是对子序列中的元素进行升序排序，不在子序列中的元素不会改变它们的位置。

序列中的每个元素都只能且必须在所有子序列中出现一次。（译者：子序列不重合）

## 样例 #1
### 输入
```
6
3 2 1 6 5 4
```
### 输出
```
4
2 1 3
1 2
2 4 6
1 5
```

## 样例 #2
### 输入
```
6
83 -75 -49 11 37 62
```
### 输出
```
1
6 1 2 3 4 5 6
```

### 算法分类
图论

### 综合分析与结论
这几道题解的核心思路都是先对原序列排序，然后通过建立原序列位置与排序后位置的关系来确定子序列。不同之处在于实现方式，有的使用并查集，有的使用Tarjan算法找环，有的直接DFS遍历找连通块。

LKY928261题解通过记录每个元素的大小关系，利用递推构造子序列，思路清晰，代码简洁高效，时间复杂度为$O(n\log n)$；xzggzh1题解提出可以用并查集或直接模拟来实现，较为直观；Graphcity题解利用图论中Tarjan算法找环来确定子序列；Tx_Lcy题解使用并查集，还提到了启发式合并优化；CaiXY06题解通过DFS遍历找连通块来确定子序列数量。

综合来看，LKY928261题解在思路清晰度和代码简洁性上表现出色，xzggzh1题解较为直观易懂，Graphcity题解利用经典图论算法，这三道题解质量相对较高。

### 所选的题解
- **作者：LKY928261 (5星)**
    - **关键亮点**：思路清晰，通过记录元素大小关系，巧妙递推构造子序列，代码非常精简，时间复杂度为$O(n\log n)$。
    - **重点代码**：
```cpp
for(i=1;i<=n;i++){cin>>b[i].first;b[i].second=i;}
sort(b+1,b+n+1);
for(i=1;i<=n;i++)a[b[i].second]=i;//记录每个元素的大小关系
for(i=1;i<=n;i++)if(!f[i]){
    c[t++]=i,f[i]=1;
    for(x=a[i];!f[x];x=a[x])f[x]=1,c[t++]=x;
    d[++k]=t;
}
```
    - **核心实现思想**：先读入数据并记录原位置，排序后确定每个元素在排序后序列中的大小关系。然后遍历原序列，若当前元素未被访问过，则从该元素开始，根据其大小关系不断寻找下一个元素，直到形成一个子序列。
- **作者：xzggzh1 (4星)**
    - **关键亮点**：直观地通过排序后原位置与新位置连线确定同一集合元素，提出用并查集或直接模拟的实现方式。
    - **重点代码**：
```cpp
scanf("%d",&n);
for(int i=0;i<n;i++) scanf("%d",&a[i]),b[i]=a[i];
sort(b,b+n);
for(int i=0;i<n;i++) a[i]=lower_bound(b,b+n,a[i])-b;
for(int i=0;i<n;i++)if(!vis[i])
{for(int j=a[i];!vis[j];j=a[j]) vis[j]=1;ans++;}
```
    - **核心实现思想**：读入数据后对副本数组排序，通过`lower_bound`确定原数组每个元素在排序后数组中的位置。遍历原数组，若当前元素未访问，则从该元素开始按位置关系遍历，标记访问过的元素，统计子序列个数。
- **作者：Graphcity (4星)**
    - **关键亮点**：利用图论建模，将原序列位置向排序后位置连边，通过Tarjan算法找环确定子序列。
    - **重点代码**：
```cpp
for(register int i=1;i<=n;++i)
    Addedge(k[i].id,i);
for(register int i=1;i<=n;++i)
    if(!dfn[i]) Tarjan(i);
```
    - **核心实现思想**：根据原序列和排序后序列元素位置关系建边，对每个未访问的节点进行Tarjan算法，找到所有环，每个环对应一个子序列。

### 最优关键思路或技巧
通过排序确定元素位置关系，利用图论思想（如连通块、环）或并查集来确定子序列。这种将原序列与排序后序列位置建立联系的思维方式是解题关键。

### 可拓展之处
同类型题通常围绕序列划分、元素位置调整后满足特定顺序要求展开。类似算法套路有通过建立位置映射关系，利用图论、并查集等工具解决问题。

### 洛谷相似题目推荐
- [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)：并查集应用，与本题利用并查集处理元素关系类似。
- [P2341 受欢迎的牛](https://www.luogu.com.cn/problem/P2341)：图论中利用Tarjan算法求强连通分量，和本题Graphcity题解找环思路相关。
- [P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)：通过图论建模解决序列相关问题，与本题思路类似。

### 个人心得摘录与总结
无。 

---
处理用时：46.03秒
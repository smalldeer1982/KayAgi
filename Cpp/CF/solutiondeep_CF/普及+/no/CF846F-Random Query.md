# 题目信息

# Random Query

## 题目描述

You are given an array $ a $ consisting of $ n $ positive integers. You pick two integer numbers $ l $ and $ r $ from $ 1 $ to $ n $ , inclusive (numbers are picked randomly, equiprobably and independently). If $ l&gt;r $ , then you swap values of $ l $ and $ r $ . You have to calculate the expected value of the number of unique elements in segment of the array from index $ l $ to index $ r $ , inclusive ( $ 1 $ -indexed).

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1.500000
```

## 样例 #2

### 输入

```
2
2 2
```

### 输出

```
1.000000
```

# AI分析结果

### 题目内容
# 随机查询

## 题目描述
给定一个由 $n$ 个正整数组成的数组 $a$ 。从 $1$ 到 $n$ 中（包括 $1$ 和 $n$ ）随机、等概率且独立地选取两个整数 $l$ 和 $r$ 。如果 $l > r$ ，则交换 $l$ 和 $r$ 的值。你需要计算数组中从索引 $l$ 到索引 $r$ （包括两端，从 $1$ 开始索引）的区间内不同元素数量的期望值。

## 样例 #1
### 输入
```
2
1 2
```
### 输出
```
1.500000
```

## 样例 #2
### 输入
```
2
2 2
```
### 输出
```
1.000000
```

### 算法分类
概率论

### 题解综合分析与结论
这些题解主要围绕计算随机选取区间内不同元素数量的期望展开。思路上大致分为两类，一类是通过计算每个数被保留（即对区间不同元素个数有贡献）的期望，进而求和得到总期望；另一类是通过统计包含特定数的区间个数，利用补集转换等方法求出所有区间内不同数字个数和，再除以区间总数得到期望。解决难点在于如何高效地统计每个数对不同区间的贡献，避免 $O(n^2)$ 的暴力枚举区间。

### 所选的题解
- **作者：Stream月 (5星)**
    - **关键亮点**：清晰运用期望的重要性质“期望的和 = 和的期望”，将问题转化为计算每个数被保留下来的期望值的和。通过预处理每个数前一次出现的位置，快速计算每个数对区间的贡献，代码实现简洁明了。
    - **个人心得**：刚开始学期望，通过本题掌握期望性质的应用。
    - **核心代码片段**：
```cpp
n = read();
$(i, 1, n) a[i] = read();
for(int i = 1; i <= n; ++i) {
    ans += (i - pre[a[i]]) * (n - i + 1) * 2 ;
    pre[a[i]] = i;
}
ans -= n;
printf("%.6lf", (double)ans/(double)(n * n));
```
核心思想：遍历数组，每次根据当前数前一次出现位置 `pre[a[i]]` 计算当前数对区间的贡献并累加到 `ans` ，最后减去重复计算的 $l = r$ 的情况，再除以总区间数得到期望。

- **作者：Smallbasic (4星)**
    - **关键亮点**：从另一个角度，假定每个数只有在区间中最后一次出现的位置对答案有贡献，通过预处理每个数下一次出现的位置，巧妙转换求和顺序，将三重循环优化到两重循环，$O(n)$ 计算出所有区间不同数字个数和，最后处理 $l = r$ 的特殊情况得到期望。
    - **核心代码片段**：
```cpp
for (int i = n; i; --i) {
    if (lst[a[i]] == -1) lst[a[i]] = n + 1;
    nxt[i] = lst[a[i]]; lst[a[i]] = i;
}
for (int i = 1; i <= n; ++i)
    ans = ans + 1ll * i * (nxt[i] - i);
ans = ans * 2ll - n;
ll all = 1ll * n * (n + 1) - n;
printf("%.6lf", 1.0 * ans / all);
```
核心思想：先逆序遍历数组预处理出每个数下一次出现位置 `nxt[i]` ，再正序遍历计算每个位置对所有区间不同数字个数和的贡献累加到 `ans` ，处理 `l = r` 情况后除以总区间数得到期望。

- **作者：ChthollyTree (4星)**
    - **关键亮点**：思路与Stream月类似，考虑从左到右第一次出现的数产生贡献，快速计算每个数对区间的贡献，代码简洁，逻辑清晰。
    - **核心代码片段**：
```cpp
for(int i = 1; i <= n; i ++) {
    ans += (i - c[a[i]]) * (n - i+1) * 2 - 2;
    c[a[i]] = i;
}
ans += n;
printf("%.6lf",(double)ans/(double)(n*n));
```
核心思想：遍历数组，根据当前数上一次出现位置 `c[a[i]]` 计算当前数对区间的贡献累加到 `ans` ，减去重复计算部分并加上 `l = r` 的情况，最后除以总区间数得到期望。

### 最优关键思路或技巧
通过预处理每个数的前一次或下一次出现位置，避免对区间的暴力枚举，将问题转化为对每个数的贡献计算，从而优化时间复杂度。这种利用数的出现位置关系来简化问题的思维方式是解决此类问题的关键。

### 可拓展之处
同类型题可拓展到更多关于概率期望与数组区间统计结合的题目，类似算法套路是将复杂的区间统计问题转化为对单个元素的贡献统计，利用元素间的位置关系优化计算。

### 洛谷相似题目推荐
- [P1365 WJMZBMR打osu! / Easy](https://www.luogu.com.cn/problem/P1365)
- [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)
- [P4305 [JLOI2011]不重复数字](https://www.luogu.com.cn/problem/P4305)

---
处理用时：43.36秒
# 题目信息

# Bathroom terminal

## 题目描述

给你  $N$  个字符串，它们代表了单词。每个单词只由字符 `'a'-'e'` 组成，最大长度为  $L$  。另外，有  $M$  个模式串，由字符 `'a'-'e'` 和至多三个的 '?' 组成，最大长度为  $L$  。其中， '?' 可以代表 `'a'-'e'` 中的任何一个字符以及一个空字符 `''` 。对于每一个模式串，输出与之匹配的单词数。

## 样例 #1

### 输入

```
3 1
abc
aec
ac
a?c
```

### 输出

```
3
```

# AI分析结果

### 题目内容
# 卫生间终端

## 题目描述
给你 $N$ 个字符串，它们代表了单词。每个单词只由字符 `'a'-'e'` 组成，最大长度为 $L$ 。另外，有 $M$ 个模式串，由字符 `'a'-'e'` 和至多三个的 '?' 组成，最大长度为 $L$ 。其中， '?' 可以代表 `'a'-'e'` 中的任何一个字符以及一个空字符 `''` 。对于每一个模式串，输出与之匹配的单词数。

## 样例 #1
### 输入
```
3 1
abc
aec
ac
a?c
```
### 输出
```
3
```
### 算法分类
深度优先搜索 DFS
### 综合分析与结论
这些题解的核心思路都是利用模式串中 `?` 数量有限（至多3个）的特点，通过深度优先搜索（DFS）枚举 `?` 的所有可能取值（包括空字符），将模式串转化为具体字符串，再与给定的单词串进行匹配统计。
- **思路方面**：多数题解思路一致，都是基于DFS枚举，只是在具体实现细节和数据结构使用上有差异。
- **算法要点**：确定DFS函数的参数和返回值，在DFS函数中处理 `?` 的不同取值情况，递归调用DFS。同时利用合适的数据结构（如 `map`、`set` 等）记录单词串出现次数和避免重复统计。
- **解决难点**：如何正确处理 `?` 代表空字符的情况，以及如何避免重复计算匹配结果。部分题解通过在DFS过程中删除 `?` 位置字符模拟空字符，部分题解将空字符用特殊字符代替后再处理；通过 `map` 或 `set` 来记录已经处理过的字符串避免重复计算。

### 所选的题解
- **作者：_Mikasa (5星)**
    - **关键亮点**：思路清晰，代码简洁明了。通过 `map` 记录单词串出现次数，在DFS中直接对模式串的 `?` 进行枚举替换，处理空字符时直接删除 `?` 所在位置字符，并用 `vis` 记录已处理过的字符串避免重复计算。
    - **个人心得**：无
    - **重点代码**：
```cpp
void dfs(string x,int k){
    if(k==0){
        if(mp[x]&&!vis[x]){
            vis[x]=1;
            ans+=mp[x];   
        } 
        return;
    }
    for(int i=0;i<x.length();i++){
        if(x[i]=='?'){
            for(int j='a';j<='e'+1;j++){
                if(j=='e'+1){
                    x.erase(i,1);
                    dfs(x,k-1);
                }else{
                    x[i]=char(j);
                    dfs(x,k-1);
                }
            }
        }
        
    }
}
```
核心实现思想：`dfs` 函数通过递归，对模式串 `x` 中的 `?` 进行枚举替换，`k` 记录剩余 `?` 的数量。当 `k` 为0时，检查当前字符串是否在 `mp` 中且未被访问过，若是则更新答案。
- **作者：Imken (4星)**
    - **关键亮点**：分析了时间复杂度，指出暴搜可行。使用 `multiset` 维护单词串集合，`unordered_set` 维护匹配串集合，还使用 `unordered_map` 存储询问结果避免重复计算。
    - **个人心得**：提到考场测试随机数据时发现重复询问可能超时的情况，因此采用 `unordered_map` 存储结果优化。
    - **重点代码**：
```cpp
void dfs(const string &s) noexcept
{
    string b;
    int i, j, cnt = 0;
    int lens = s.length();
    for (i = 0; i < lens; i++) {
        if (s[i] == '?') {
            cnt++;
            // Delete
            b = s;
            b.erase(i, 1);
            dfs(b);
            // Replace
            b = s;
            for (j = 'a'; j <= 'e'; j++) {
                b[i] = j;
                dfs(b);
            }
        }
    }
    // If there is no `?` in the string
    if (!cnt) {
        all_status.insert(s);
    }
}
```
核心实现思想：`dfs` 函数对模式串 `s` 进行DFS，遇到 `?` 时分别处理删除（模拟空字符）和替换为 `a - e` 的情况，当字符串中无 `?` 时将其插入 `all_status` 集合。
- **作者：_anll_ (4星)**
    - **关键亮点**：思路阐述详细，代码简洁易懂。在DFS过程中通过索引和字符串拼接模拟模式串的各种变形，用 `map` 记录单词串出现次数和已枚举的变形串。
    - **个人心得**：无
    - **重点代码**：
```cpp
void dfs(int x,string ss){
    if(x==s.size()-1){
        if(!vu[ss]){
            vu[ss]=1,ans+=mo[ss];
        }
        
        return;
    }
    if(s[x+1]=='?'){
        dfs(x+1,ss);
        for(char i='a';i<='e';i++) dfs(x+1,ss+i);
    }
    else dfs(x+1,ss+s[x+1]);
}
```
核心实现思想：`dfs` 函数通过索引 `x` 遍历模式串 `s`，当 `x` 到达模式串末尾时检查当前变形串 `ss` 是否已枚举，未枚举则更新答案。遇到 `?` 时递归尝试空字符和 `a - e` 的情况，非 `?` 时直接拼接字符继续递归。

### 最优关键思路或技巧
- **数据结构选择**：利用 `map` 统计单词串出现的次数，方便在枚举模式串变形后快速获取匹配数量；用 `set` 或在 `map` 中标记的方式避免重复统计匹配结果。
- **DFS实现**：在DFS函数设计上，合理设置参数来记录当前处理状态，如剩余 `?` 的数量或当前处理到模式串的位置等，清晰地处理 `?` 的不同取值情况。

### 可拓展之处
同类型题通常围绕字符串匹配展开，模式串中会包含特殊通配符，且通配符数量有限，可采用类似的DFS枚举通配符取值的方法解决。类似算法套路还可应用在一些字符替换、字符串生成并匹配的问题中。

### 洛谷题目推荐
- **P1605 迷宫**：通过DFS搜索迷宫路径，与本题DFS思路类似，锻炼对DFS的理解和应用。
- **P1120 小木棍 ［数据加强版］**：利用DFS搜索小木棍的组合方式，同样涉及到递归和剪枝操作，与本题DFS处理方式有相通之处。
- **P2392 kkksc03考前临时抱佛脚**：通过DFS枚举不同科目复习时间分配，与本题通过DFS枚举不同情况的思路类似。 

---
处理用时：51.32秒
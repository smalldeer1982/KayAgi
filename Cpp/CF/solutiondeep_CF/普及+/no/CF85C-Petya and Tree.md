# 题目信息

# Petya and Tree

## 题目描述

给定一棵二叉搜索树，包含 $n$ 个节点，保证每个节点只可能有 $0$ 或 $2$ 个子节点。

再给定 $k$ 次询问，每次询问给出一个值   $x_i$ ，
对于第 $i$ 次询问，将 $x_i$ 插入树中，在插入过程中会等概率的“走错”（即在到达某个点时如果该往左子树走，则该往右子树走，反之亦然）恰好一次，输出该节点插入后的父节点的权值的期望值。（询问之间相互独立，即不会真正插进去）

tips：

二叉搜索树的定义：如果一棵二叉树满足其任意一节点中，左子树的所有点的权值均小于该点权值且右子树的所有点的权值均大于该点权值（忽略空子树），则这棵树被称为二叉搜索树。

二叉搜索树的插入操作：最初位于树根，如果当前节点的权值大于要插入的节点的权值，那么移动到该节点的右子节点，否则移动到该节点的左子节点并重复该过程直到该节点为空。

## 样例 #1

### 输入

```
7
-1 8
1 4
1 12
2 2
2 6
3 10
3 14
1
1
```

### 输出

```
8.0000000000
```

## 样例 #2

### 输入

```
3
-1 5
1 3
1 7
6
1
2
4
6
8
9
```

### 输出

```
7.0000000000
7.0000000000
7.0000000000
3.0000000000
3.0000000000
3.0000000000
```

# AI分析结果

### 题目内容
# Petya和树

## 题目描述
给定一棵二叉搜索树，包含 $n$ 个节点，保证每个节点只可能有 $0$ 或 $2$ 个子节点。
再给定 $k$ 次询问，每次询问给出一个值 $x_i$ ，
对于第 $i$ 次询问，将 $x_i$ 插入树中，在插入过程中会等概率的“走错”（即在到达某个点时如果该往左子树走，则该往右子树走，反之亦然）恰好一次，输出该节点插入后的父节点的权值的期望值。（询问之间相互独立，即不会真正插进去）

tips：
二叉搜索树的定义：如果一棵二叉树满足其任意一节点中，左子树的所有点的权值均小于该点权值且右子树的所有点的权值均大于该点权值（忽略空子树），则这棵树被称为二叉搜索树。
二叉搜索树的插入操作：最初位于树根，如果当前节点的权值大于要插入的节点的权值，那么移动到该节点的右子节点，否则移动到该节点的左子节点并重复该过程直到该节点为空。

## 样例 #1
### 输入
```
7
-1 8
1 4
1 12
2 2
2 6
3 10
3 14
1
1
```
### 输出
```
8.0000000000
```

## 样例 #2
### 输入
```
3
-1 5
1 3
1 7
6
1
2
4
6
8
9
```
### 输出
```
7.0000000000
7.0000000000
7.0000000000
3.0000000000
3.0000000000
3.0000000000
```

### 算法分类
概率论

### 综合分析与结论
该题解首先明确题目大意是求在二叉搜索树插入节点时走错一条边的所有路径搜索到数的期望。其思路核心在于利用二叉搜索树性质，发现走错一条边后会一直往另一边靠拢。通过 $\mathcal{O}(n)$ 预处理出每个节点一直往左或往右走搜到的值 $L_i$ 和 $R_i$ ，并定义 $dp_{i}$ 表示到达第 $i$ 个节点走错的总值，通过转移方程计算。为确定询问值 $x$ 归属节点，采用拍扁二分求值，利用前驱和后继深度判断归属。时间复杂度优化到 $\mathcal{O}(k\log n)$ 。

### 所选的题解
 - **星级**：4星
 - **关键亮点**：利用二叉搜索树性质优化计算期望的过程，通过预处理和拍扁二分求值降低时间复杂度。
 - **个人心得**：提到题目没说根要自己找；二分的值超过一定范围会返回奇怪的数，测试可打权值为 $10^9$ 的点；拍扁最好用 `vector` ；根节点错误路径数特殊处理。

### 重点代码及核心实现思想
```cpp
// 核心实现思想：通过dfs1预处理节点深度、左右儿子及一直往左或往右走取到的值；
// dfs2计算每个节点走错的总值和错误路径数；dfs3中序遍历拍扁树；
// 主函数中通过二分查找确定询问值归属节点并计算输出期望。
void dfs1(int x, int fa) {
    dep[x] = dep[fa] + 1;
    int s = 0;
    L[x] = R[x] = val[x];
    for (register int i = head[x]; i; i = a[i].nxt) {
        int y = a[i].to;
        if (y == fa) continue;
        dfs1(y, x);
        if (val[y] < val[x]) L[x] = L[y], tr[x].l = y;
        else R[x] = R[y], tr[x].r = y;
    }
}
void dfs2(int x, int fa) {
    if (fa!= -1) {
        if (x == tr[fa].l) {
            dp[x] = dp[fa] + L[tr[fa].r];
            row[x] = row[fa] + (tr[fa].r!= 0);
        }
        if (x == tr[fa].r) {
            dp[x] = dp[fa] + R[tr[fa].l];
            row[x] = row[fa] + (tr[fa].l!= 0);
        }
    }
    else dp[root] = 0;
    for (register int i = head[x]; i; i = a[i].nxt) {
        int y = a[i].to;
        if (y == fa) continue;
        dfs2(y, x);
    }
}
void dfs3(int x, int fa) {
    if (tr[x].l!= 0) dfs3(tr[x].l, x);
    f.push_back(make_pair(val[x], x));
    if (tr[x].r!= 0) dfs3(tr[x].r, x);
}
```

### 最优关键思路或技巧
1. **利用二叉搜索树性质**：确定走错边后方向不变，为后续计算提供基础。
2. **预处理和递推**：通过 $\mathcal{O}(n)$ 的预处理计算 $L_i$、$R_i$ 以及 $dp_{i}$ 等，减少重复计算。
3. **拍扁二分求值**：巧妙解决询问值归属节点的判断问题，优化时间复杂度。

### 可拓展之处
同类型题可涉及不同条件下二叉搜索树节点操作的概率期望问题，类似算法套路为利用树的性质进行预处理，结合二分等方法优化查找判断过程。

### 洛谷相似题目推荐
1. P3830 [SHOI2012]随机树 ：涉及二叉搜索树的随机生成及相关概率计算。
2. P4316 绿豆蛙的归宿 ：在有向无环图上计算概率期望，与本题在概率期望计算思路上有相似处。
3. P4305 [JLOI2011]不重复数字 ：结合了树的结构与概率期望相关计算。 

---
处理用时：48.50秒
# 题目信息

# Orientation of Edges

## 题目描述

Vasya 拥有一张由有向边和无向边组成的图。这张图中，两个顶点之间可能存在多条边。

Vasya 从中选定了一个顶点 $s$。现在，他希望制定两个不同的方案：

1. 将每条无向边指定一个方向，以最大化从顶点 $s$ 可以到达的其他顶点数量；
2. 将每条无向边指定一个方向，以最小化从顶点 $s$ 可以到达的其他顶点数量。

在每个方案中，所有无向边都必须变为有向边。同一条无向边可以在两个方案中选择不同的方向。

你的任务是帮助 Vasya 找出这两个方案。

## 样例 #1

### 输入

```
2 2 1
1 1 2
2 2 1
```

### 输出

```
2
-
2
+
```

## 样例 #2

### 输入

```
6 6 3
2 2 6
1 4 5
2 3 4
1 4 1
1 3 1
2 2 3
```

### 输出

```
6
++-
2
+-+
```

# AI分析结果

### 题目内容
# 边的方向

## 题目描述
Vasya拥有一张由有向边和无向边组成的图。这张图中，两个顶点之间可能存在多条边。

Vasya从中选定了一个顶点 $s$。现在，他希望制定两个不同的方案：
1. 将每条无向边指定一个方向，以最大化从顶点 $s$ 可以到达的其他顶点数量；
2. 将每条无向边指定一个方向，以最小化从顶点 $s$ 可以到达的其他顶点数量。

在每个方案中，所有无向边都必须变为有向边。同一条无向边可以在两个方案中选择不同的方向。

你的任务是帮助 Vasya 找出这两个方案。

## 样例 #1
### 输入
```
2 2 1
1 1 2
2 2 1
```
### 输出
```
2
-
2
+
```
## 样例 #2
### 输入
```
6 6 3
2 2 6
1 4 5
2 3 4
1 4 1
1 3 1
2 2 3
```
### 输出
```
6
++-
2
+-+
```
### 算法分类
搜索（广度优先搜索BFS）

### 综合分析与结论
该题解思路清晰，通过两次BFS解决问题。思路上先利用有向边确定一定能到达的点，然后针对无向边，在最大化到达点数时，以已确定能到达的点为起点通过无向边扩展；最小化时则反向构建无向边来阻止扩展。算法要点在于两次BFS过程中对无向边方向的不同处理。解决难点在于如何合理利用BFS遍历图，并根据目标调整无向边方向。

### 所选的题解
- **星级**：4星
- **关键亮点**：思路清晰，通过两次BFS分别实现最大化和最小化目标，对无向边方向处理巧妙。代码虽然码量较大，但两次BFS本质相同且结构清晰。

### 重点代码核心实现思想
通过`work1`和`work2`函数分别实现最大化和最小化方案。在`work1`中，BFS过程中若遇到未访问且无向边方向未冲突的点，则更新方向并加入队列；在`work2`中，BFS时直接将无向边设为反向方向。

### 核心代码片段
```cpp
void work1()
{
    cnt = 1;
    memset(ans, 0, sizeof(ans));
    memset(vis, 0, sizeof(vis));
    q.push(s);
    while(!q.empty())
    {
        int tp = q.front();
        q.pop();
        vis[tp] = true;
        for (register int i = 0;i < de[tp].size();i ++)
        {
            int _e = de[tp][i];
            if(!vis[_e])
            {
                cnt ++;
                vis[_e] = true;
                q.push(_e);
            }
        }
        for (register int i = 0;i < ude[tp].size();i ++)
        {
            int _e = ude[tp][i].e, _num = ude[tp][i].num, _val = ude[tp][i].val;
            if(!vis[_e] && ans[_num]!= -_val)
            {
                ans[_num] = _val;
                cnt ++;
                vis[_e] = true;
                q.push(_e);
            }
        }
    }
    fprint(cnt);
    putchar('\n');
    for (register int i = 1;i <= tot;i ++)
    {
        putchar(ans[i] == 1? '+':'-');
    }
    putchar('\n');
}

void work2()
{
    cnt = 1;
    memset(ans, 0, sizeof(ans));
    memset(vis, 0, sizeof(vis));
    q.push(s);
    while(!q.empty())
    {
        int tp = q.front();
        q.pop();
        vis[tp] = true;
        for (register int i = 0;i < de[tp].size();i ++)
        {
            int _e = de[tp][i];
            if(!vis[_e])
            {
                cnt ++;
                vis[_e] = true;
                q.push(_e);
            }
        }
        for (register int i = 0;i < ude[tp].size();i ++)
        {
            int _e = ude[tp][i].e, _num = ude[tp][i].num, _val = ude[tp][i].val;
            if(ans[_num]!= _val)
            {
                ans[_num] = -_val;
            }
        }
    }
    fprint(cnt);
    putchar('\n');
    for (register int i = 1;i <= tot;i ++)
    {
        putchar(ans[i] == 1? '+':'-');
    }
    putchar('\n');
}
```

### 最优关键思路或技巧
利用BFS遍历图的特性，根据目标调整无向边方向。在处理无向边时，通过标记数组记录边的方向，避免重复和冲突。

### 可拓展之处
同类型题可涉及更多关于图的方向调整问题，类似算法套路是利用搜索算法（如BFS、DFS）遍历图，并根据题目要求动态调整边的方向或属性。

### 洛谷相似题目推荐
- P1339 热浪：最短路问题，与本题类似在于对图结构的处理和搜索运用。
- P1144 最短路计数：同样是图论问题，通过BFS求解最短路相关问题。
- P3371 【模板】单源最短路径（弱化版）：经典的图论最短路问题，加深对图的搜索和距离计算理解。 

---
处理用时：39.45秒
# 题目信息

# Stairs and Elevators

## 题目描述

在 $30XX$ 年，某世界编程锦标赛的参赛选手们齐聚在一座巨大的酒店。酒店共有 $n$ 层楼，每层楼有 $m$ 个区域，它们通过一条走廊相连。每层的区域从 $1$ 到 $m$ 进行编号，且在不同楼层中编号相同的区域位于正上方。因此，整栋酒店可以看作是一个高为 $n$ 且宽为 $m$ 的矩形结构。我们用整数对 $(i, j)$ 来表示各个区域，其中 $i$ 是楼层编号，$j$ 是该楼层的区域编号。

客人可以在每层楼的走廊上行走，也能通过楼梯和电梯到达其他楼层。每部楼梯或电梯占据了从 $(1, x)$ 到 $(n, x)$ 的所有区域，这里 $x$ 介于 $1$ 和 $m$ 之间。所有未被楼梯或电梯占用的区域是客房。

在同一楼层内相邻区域间的移动需要花费一个时间单位，使用楼梯上下楼层同样需要一个时间单位。使用电梯可以在任意方向上最多跨越 $v$ 层楼，但也只需一个时间单位。而且，你无需等待电梯，进入和退出电梯所需的时间可以忽略不计。

你需要处理 $q$ 个查询。每个查询的问题是：“从 $(x_1, y_1)$ 区域的某个房间到 $(x_2, y_2)$ 区域的某个房间，所需的最短时间是多少？”

## 样例 #1

### 输入

```
5 6 1 1 3
2
5
3
1 1 5 6
1 3 5 4
3 3 5 3
```

### 输出

```
7
5
4
```

# AI分析结果

### 题目内容
# 楼梯与电梯

## 题目描述
在30XX年，某世界编程锦标赛的参赛选手们齐聚在一座巨大的酒店。酒店共有n层楼，每层楼有m个区域，它们通过一条走廊相连。每层的区域从1到m进行编号，且在不同楼层中编号相同的区域位于正上方。因此，整栋酒店可以看作是一个高为n且宽为m的矩形结构。我们用整数对(i, j)来表示各个区域，其中i是楼层编号，j是该楼层的区域编号。

客人可以在每层楼的走廊上行走，也能通过楼梯和电梯到达其他楼层。每部楼梯或电梯占据了从(1, x)到(n, x)的所有区域，这里x介于1和m之间。所有未被楼梯或电梯占用的区域是客房。

在同一楼层内相邻区域间的移动需要花费一个时间单位，使用楼梯上下楼层同样需要一个时间单位。使用电梯可以在任意方向上最多跨越v层楼，但也只需一个时间单位。而且，你无需等待电梯，进入和退出电梯所需的时间可以忽略不计。

你需要处理q个查询。每个查询的问题是：“从(x1, y1)区域的某个房间到(x2, y2)区域的某个房间，所需的最短时间是多少？”

## 样例 #1
### 输入
```
5 6 1 1 3
2
5
3
1 1 5 6
1 3 5 4
3 3 5 3
```
### 输出
```
7
5
4
```

### 算法分类
贪心

### 题解综合分析与结论
两道题解思路相近，都基于贪心策略。核心思路是先判断起点和终点是否在同一楼层，若在同一楼层直接计算水平距离。若不在同一楼层，考虑到贪心原则，不会出现先坐一部电梯又换另一部、先走楼梯又换楼梯、先坐电梯再走楼梯的情况，只需分别计算走楼梯和坐电梯的方案最小值，再取两者最小值。实现时都利用二分查找找最近的楼梯和电梯。不同点在于细节处理和代码风格，gesong题解使用自定义ceil函数，S00021题解直接用向上取整表达式；S00021题解在处理电梯和楼梯情况时，对边界条件判断更细致，如对lower_bound和upper_bound的使用。

### 所选的题解
- **gesong题解**：★★★
  - **关键亮点**：思路清晰，先阐述贪心策略，再说明二分查找找最近楼梯和电梯的方法，代码有自定义输入函数和ceil函数。
  - **重点代码核心实现思想**：先判断起点终点楼层是否相同，相同则直接输出水平距离。不同时，分别对楼梯和电梯情况用二分查找找到最近位置，计算并更新最短时间。
```cpp
if (x1==x2){
    cout <<abs(y1-y2)<<endl;
    continue;
}
int ans=1e18;
if (n){
    int l=lower_bound(a+1,a+n+1,y1)-a-1;
    int r=lower_bound(a+1,a+n+1,y1)-a;
    if (l) ans=min(ans,abs(y2-a[l])+abs(y1-a[l])+abs(x2-x1));
    if (r<=n) ans=min(ans,abs(y2-a[r])+abs(y1-a[r])+abs(x2-x1));
}
if (m){
    int l=lower_bound(b+1,b+m+1,y1)-b-1;
    int r=lower_bound(b+1,b+m+1,y1)-b;
    if (l) ans=min(ans,abs(y2-b[l])+abs(y1-b[l])+ceil(abs(x2-x1),v));
    if (r<=m) ans=min(ans,abs(y2-b[r])+abs(y1-b[r])+ceil(abs(x2-x1),v));
}
printf("%lld\n",ans);
```
- **S00021题解**：★★★
  - **关键亮点**：对边界条件判断细致，如利用lower_bound和upper_bound函数全面考虑楼梯和电梯在起点终点间的不同位置情况。
  - **重点代码核心实现思想**：同样先判断起点终点楼层是否相同，不同时，分别对楼梯和电梯情况，通过二分查找确定边界位置，细致判断不同边界情况计算并更新最短时间。
```cpp
if(x1==x2){printf("%lld\n",abs(y1-y2)); continue;}
if(y1>y2) swap(x1,x2),swap(y1,y2);
int u1=lower_bound(l+1,l+cl+1,y1)-l-1;
int u2=upper_bound(l+1,l+cl+1,y2)-l;
if(u1+1<u2) ret=min(ret,abs(x1-x2)+abs(y1-y2));
if(u1) ret=min(ret,(y1-l[u1])+(y2-l[u1])+abs(x2-x1));
if(u2<=cl) ret=min(ret,(l[u2]-y1)+(l[u2]-y2)+abs(x2-x1));
u1=lower_bound(e+1,e+ce+1,y1)-e-1;
u2=upper_bound(e+1,e+ce+1,y2)-e;
if(u1+1<u2) ret=min(ret,(abs(x1-x2)+v-1)/v+(abs(y1-y2)));
if(u1) ret=min(ret,(y1-e[u1])+(y2-e[u1])+(abs(x2-x1)+v-1)/v);
if(u2<=ce) ret=min(ret,(e[u2]-y1)+e[u2]-y2+(abs(x2-x1)+v-1)/v);
printf("%lld\n",ret);
```

### 最优关键思路或技巧
贪心策略确定只考虑走一条楼梯或坐一部电梯的方案；利用二分查找快速找到最近的楼梯和电梯位置，优化时间复杂度。

### 可拓展之处
同类型题可涉及不同移动规则和地图结构的最短路径问题，类似算法套路是分析不同移动方式特点，利用贪心策略简化问题，结合二分查找等优化方法。

### 洛谷相似题目推荐
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
- [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)

### 个人心得
无。 

---
处理用时：56.91秒
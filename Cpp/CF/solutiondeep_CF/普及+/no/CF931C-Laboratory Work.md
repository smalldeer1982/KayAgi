# 题目信息

# Laboratory Work

## 题目描述

$Anya$ 和 $Kirill$ 正在做一个物理实验，他们必须测量一些值 $n$ 次，然后求出平均值以降低误差。



$Kirill$ 已经完成了测量，得到了 $n$ 个数据：$x_1,x_2,\dots,x_n$。这些值非常接近，其中的最大值与最小值之差不超过 $2$。



$Anya$ 不想去测量，但是他也不能直接抄 $Kirill$ 的数据，因为每次测量的误差是随机的，如果直接抄的话会被老师发现。$Anya$ 想要得到一组数据 $y_1,y_2,\dots,y_n$ ，这组数据满足如下条件：



* $x_1,x_2,\dots,x_n$ 的平均值要等于 $y_1,y_2,\dots,y_n$ 的平均值。

* $\max(y_1,y_2,\dots,y_n) \le \max(x_1,x_2,\dots,x_n)$ 并且 $\min(y_1,y_2,\dots,y_n) \ge \min(x_1,x_2,\dots,x_n)$。

* 两组数据中相等的数尽可能少，即你造的数据中尽量不要出现 $Kirill$ 的数据中出现过的数。



找出这样的一组测量值。

## 说明/提示

$1 \le n \le 100000$。



$-100000 \le x_i \le 100000$



[样例解释]



第一个样例中，$0,0,0,0,0,0$ 与 $-1,1,1,0,0,-1$ 的平均值相等，只有两个相等的 $0$。



第二个样例中，要想使平均值相等，$Anya$ 的测量值只能与 $Kirill$ 的测量值相等。



第三个样例中，最少也要有 $5$ 个相等的数。



translated by [yu__xuan](https://www.luogu.com.cn/user/142110).

## 样例 #1

### 输入

```
6
-1 1 1 0 0 -1
```

### 输出

```
2
0 0 0 0 0 0 
```

## 样例 #2

### 输入

```
3
100 100 101
```

### 输出

```
3
101 100 100 
```

## 样例 #3

### 输入

```
7
-10 -9 -10 -8 -10 -9 -9
```

### 输出

```
5
-10 -10 -9 -9 -9 -9 -9 
```

# AI分析结果

### 题目内容
# Laboratory Work

## 题目描述
安雅（Anya）和基里尔（Kirill）正在做一个物理实验，他们必须测量一些值 $n$ 次，然后求出平均值以降低误差。

基里尔已经完成了测量，得到了 $n$ 个数据：$x_1,x_2,\dots,x_n$。这些值非常接近，其中的最大值与最小值之差不超过 $2$。

安雅不想去测量，但是他也不能直接抄基里尔的数据，因为每次测量的误差是随机的，如果直接抄的话会被老师发现。安雅想要得到一组数据 $y_1,y_2,\dots,y_n$ ，这组数据满足如下条件：

* $x_1,x_2,\dots,x_n$ 的平均值要等于 $y_1,y_2,\dots,y_n$ 的平均值。
* $\max(y_1,y_2,\dots,y_n) \le \max(x_1,x_2,\dots,x_n)$ 并且 $\min(y_1,y_2,\dots,y_n) \ge \min(x_1,x_2,\dots,x_n)$。
* 两组数据中相等的数尽可能少，即你造的数据中尽量不要出现基里尔的数据中出现过的数。

找出这样的一组测量值。

## 说明/提示
$1 \le n \le 100000$。

$-100000 \le x_i \le 100000$

[样例解释]
第一个样例中，$0,0,0,0,0,0$ 与 $-1,1,1,0,0,-1$ 的平均值相等，只有两个相等的 $0$。

第二个样例中，要想使平均值相等，安雅的测量值只能与基里尔的测量值相等。

第三个样例中，最少也要有 $5$ 个相等的数。

translated by [yu__xuan](https://www.luogu.com.cn/user/142110).

## 样例 #1
### 输入
```
6
-1 1 1 0 0 -1
```
### 输出
```
2
0 0 0 0 0 0 
```

## 样例 #2
### 输入
```
3
100 100 101
```
### 输出
```
3
101 100 100 
```

## 样例 #3
### 输入
```
7
-10 -9 -10 -8 -10 -9 -9
```
### 输出
```
5
-10 -10 -9 -9 -9 -9 -9 
```

### 算法分类
构造

### 综合分析与结论
所有题解思路核心一致，均基于最大值与最小值的差进行分类讨论。当差值小于等于1时，直接输出原数列；当差值为2时，通过特定操作构造新数列，使相等数最少。各题解的不同在于具体实现方式，如统计不同值的数量、判断操作方向及构造新数列的细节等。

### 所选的题解
 - **作者：开始新的记忆 (赞：3)  星级：4星**
    - **关键亮点**：思路清晰，代码简洁明了。先对数据排序，再根据最大最小值差值分类处理。差值为2时，通过比较最小数和最大数出现次数与中间数出现次数一半的大小，决定操作方向。
    - **重点代码核心思想**：排序后统计最小、中间、最大数的个数，根据比较结果进行操作构造新数列。
    ```cpp
    int num_min=0,num_max=0,num_mid=0;
    for(int i=1;i<=n;++i)
    {
        if(a[i]==a[1]) 
            num_min++;
        else if(a[i]==a[n])  
            num_max++;
        else 
            num_mid++;
    }
    int t=min(num_min,num_max),k=num_mid/2;
    ll st=a[1];
    if(t>k)
    {
        for(int i=1;i<=t;++i) 
            a[i]=st+1;
        for(int i=n;i>n-t;--i) 
            a[i]=st+1;
        cout<<n-t*2<<endl;
    }		
    else
    {
        for(int i=1;i<=k;++i)
        {
            int ed=num_min+i*2;
            a[ed-1]=st,a[ed]=st+2;
        }
        cout<<n-k*2<<endl;
    }
    ```
 - **作者：王熙文 (赞：0)  星级：4星**
    - **关键亮点**：详细分析两种操作对不同值出现次数的影响，通过计算不同操作下相同数的个数，取较小值确定最优方案。
    - **重点代码核心思想**：统计原数组中最小、中间、最大值的出现次数，计算两种操作下相同数的个数，按较小值构造新数列。
    ```cpp
    int cnt1=0,cnt2=0,cnt3=0;
    for(int i=1; i<=n; ++i)
    {
        cnt1+=(a[i]==in),cnt2+=(a[i]==in+1),cnt3+=(a[i]==in+2);
    }
    int ans1=cnt1+cnt3+(cnt2&1),ans2=abs(cnt1-cnt3)+cnt2;
    if(ans1<ans2)
    {
        cout<<ans1<<'\n';
        for(int i=1; i<=cnt1+(cnt2>>1); ++i) cout<<in<<' ';
        for(int i=1; i<=(cnt2&1); ++i) cout<<in+1<<' ';
        for(int i=1; i<=cnt3+(cnt2>>1); ++i) cout<<in+2<<' ';
    }
    else
    {
        cout<<ans2<<'\n';
        for(int i=1; i<=cnt1-cnt3; ++i) cout<<in<<' ';
        for(int i=1; i<=cnt2+(min(cnt1,cnt3)<<1); ++i) cout<<in+1<<' ';
        for(int i=1; i<=cnt3-cnt1; ++i) cout<<in+2<<' ';
    }
    ```
 - **作者：lmy_2011 (赞：0)  星级：4星**
    - **关键亮点**：以简洁的代码实现思路，对极差情况分类清晰，操作方向判断明确。
    - **重点代码核心思想**：排序后统计最小、中间、最大数的个数，比较最小数和最大数出现次数与中间数出现次数一半的大小，进行相应操作构造新数列。
    ```cpp
    int s1=0,s2=0,s3=0;
    for(int i=1;i<=n;++i)
    {
        if(a[i]==a[1]) s1++;
        else if(a[i]==a[n]) s3++;
        else s2++;
    }
    int t=min(s1,s3),k=s2/2;
    int m=a[1];
    if(t>k)
    {
        for(int i=1;i<=t;++i) a[i]=m+1;
        for(int i=1;i<=t;++i) a[n-i+1]=m+1;        
        printf("%d\n",n-t*2);
        for(int i=1;i<=n;++i) printf("%d ",a[i]);
    }
    else
    {
        for(int i=1;i<=k;++i) a[s1+i*2-1]=m,a[s1+i*2]=m+2;
        printf("%d\n",n-k*2);
        for(int i=1;i<=n;++i) printf("%d ",a[i]);
    }
    ```

### 最优关键思路或技巧
1. **分类讨论**：根据最大最小值的差值进行分类，简化问题处理。
2. **操作分析**：明确仅有的两种操作（将一个最小值和一个最大值变成两个中间值，或将两个中间值变成一个最小值和一个最大值），通过比较相关数量决定操作方向。

### 拓展
同类型题可关注构造类题目，通常需根据给定条件，合理设计数据结构或算法来构造满足要求的解。类似算法套路是先分析题目条件限制，找到关键操作，再通过比较某些量的大小决定操作方式。

### 推荐题目
1. [P1036 [NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)：通过枚举组合构造满足条件的数。
2. [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)：根据火柴棒数量限制构造等式。
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：结合搜索与构造解决路径选择问题。

### 个人心得
无。 

---
处理用时：64.88秒
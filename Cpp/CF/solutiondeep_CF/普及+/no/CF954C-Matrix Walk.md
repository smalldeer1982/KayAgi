# 题目信息

# Matrix Walk

## 题目描述

## 【题目大意】

你有一个大小未知（假设为 $x\times y$）的矩阵，这个矩阵中的格子的编号的排列有规律，比如说 $(i,j)$ 号格子的编号为 $y\times (i - 1) + j$。  
但是现在这个矩阵的大小是未知的，我们的任务是算出来这个矩阵的**任意一种可能的大小**。  
接下来，你有一个长度为 $n$ 序列，表示你在矩阵中行动时走到的格子的编号。（你在矩阵中**只能上下左右行动，不能走出矩阵**） 如果说有符合这种序列的矩阵，那么输出 ```YES```，并输出矩阵的**任意一种可能的大小** ；否则输出 ```NO```。

## 说明/提示

$1 \le n\le 2 \times 10^5$，序列中任意的数字都小于等于 $10^9$，矩阵大小小于 $10 ^ 9\times 10^9$。

## 样例 #1

### 输入

```
8
1 2 3 6 9 8 5 2
```

### 输出

```
YES
3 3
```

## 样例 #2

### 输入

```
6
1 2 1 2 5 3
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
2
1 10
```

### 输出

```
YES
4 9
```

# AI分析结果

### 题目内容
# Matrix Walk

## 题目描述

### 【题目大意】

你有一个大小未知（假设为 $x\times y$）的矩阵，这个矩阵中的格子的编号的排列有规律，比如说 $(i,j)$ 号格子的编号为 $y\times (i - 1) + j$。  
但是现在这个矩阵的大小是未知的，我们的任务是算出来这个矩阵的**任意一种可能的大小**。  
接下来，你有一个长度为 $n$ 序列，表示你在矩阵中行动时走到的格子的编号。（你在矩阵中**只能上下左右行动，不能走出矩阵**） 如果说有符合这种序列的矩阵，那么输出 ```YES```，并输出矩阵的**任意一种可能的大小** ；否则输出 ```NO```。

## 说明/提示

$1 \le n\le 2 \times 10^5$，序列中任意的数字都小于等于 $10^9$，矩阵大小小于 $10 ^ 9\times 10^9$。

## 样例 #1

#### 输入

```
8
1 2 3 6 9 8 5 2
```

#### 输出

```
YES
3 3
```

## 样例 #2

#### 输入

```
6
1 2 1 2 5 3
```

#### 输出

```
NO
```

## 样例 #3

#### 输入

```
2
1 10
```

#### 输出

```
YES
4 9
```

### 算法分类
数学

### 题解综合分析与结论
这些题解的核心思路都是通过分析序列中相邻元素的差值来判断矩阵是否合法，并确定矩阵的列数。主要难点在于处理各种特殊情况，如原地停留、非法的行列转换等。
1. **思路**：多数题解先确定矩阵行数可设为最大值 $10^9$，重点求列数。通过分析相邻编号差值，若差值不为1，则可能是上下移动，差值即为列数；若差值为1，需判断是否为合法的左右移动或特殊情况。
2. **算法要点**：检查相邻编号差值，确定列数并验证其一致性；判断是否存在原地停留（相邻编号相等）；处理差值为1时可能出现的非法换行情况。
3. **解决难点**：准确识别并处理各种非法情况，如从一行末尾跳到下一行开头的情况，需要通过特定的计算（如对编号减1后除以列数判断是否在同一行）来判断。

### 所选的题解
- **作者：wmrqwq (5星)**
    - **关键亮点**：思路清晰，不仅给出解题思路，还通过具体的hack数据指出容易忽略的细节，代码注释丰富。
    - **个人心得**：通过hack数据展示易错点，如相邻两次操作不能在同一格子，编号相差1的格子不一定能互相到达，向左走要注意减去列的长度。
    - **重点代码核心实现思想**：遍历序列，判断相邻元素差值情况，记录可能的列数并验证其合法性，同时检查是否存在非法情况。
    ```cpp
    void solve()
    {
        ll n,pd=0,num=0,su=0,sum=0;
        cin>>n;
        ll a[n+10]={0};
        forl(i,1,n)
            cin>>a[i];
        forl(i,2,n)
        {
            if(abs(a[i]-a[i-1])==0)
            {
                su=0;
                cout<<"NO\n";
                return ;
            }
            if(abs(a[i]-a[i-1])>1)
            {
                su=0;
                if(pd && abs(a[i]-a[i-1])!=num)
                {
                    cout<<"NO\n";
                    return ;
                }
                else
                    pd=1,num=abs(a[i]-a[i-1]);
            }
            if(abs(a[i]-a[i-1])==1)
                su+=a[i]-a[i-1];
            sum=max(su,sum);
        }
        if(pd)
        {
            if(num<sum)
                cout<<"NO\n";
            else
            {
                forl(i,2,n)
                {
                    if(abs(a[i]-a[i-1])==1)
                    {
                        if(min(a[i],a[i-1])%num==0 && num!=1)
                        {
                            cout/*<<i*/<<"NO\n";
                            return ;
                        }
                    }
                }
                cout<<"YES\n"<<1000000000<<' '<<num<<endl;
            }
        }
        else
            cout<<"YES\n"<<1000000000<<' '<<1000000000<<endl;
    }
    ```
- **作者：qiliu (4星)**
    - **关键亮点**：详细分析题目思路，清晰列出非法条件，代码简洁明了。
    - **重点代码核心实现思想**：先读入序列，根据相邻元素差值确定列数并验证，同时检查是否违反非法条件。
    ```cpp
    signed main()
    {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        int n;
        cin>>n;
        int y=1;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            if(i>1)
            {
                if(a[i]==a[i-1])//条件一
                {
                    cout<<"NO";
                    return 0;
                }
                if(abs(a[i]-a[i-1])!=1)
                {
                    y=abs(a[i]-a[i-1]);//这里我们直接赋值，在我们后面判条件二的时候就能一块判出来。
                }
            }
        }
        for(int i=2;i<=n;i++)
        {
            if(abs(a[i]-a[i-1])!=1&&abs(a[i]-a[i-1])!=y)//条件2
            {
                cout<<"NO";
                return 0;
            }
            if(abs(a[i]-a[i-1])==1&&y!=1&&(a[i]-1)/y!=(a[i-1]-1)/y)//条件3
            {
                cout<<"NO";
                return 0;
            }
        }
        cout<<"YES"<<endl<<1000000000<<' '<<y;
        return 0;
    }
    ```
- **作者：hubin1 (4星)**
    - **关键亮点**：思路阐述详细，对每个判断条件都有清晰解释，代码结构清晰。
    - **重点代码核心实现思想**：读入序列时检查原地停留情况并预处理列数，之后再次遍历序列验证列数一致性和非法换行情况。
    ```cpp
    int main()
    {
        int n;
        int t=1;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            if(a[i]==a[i-1]&&i!=1)//原地等待，即条件2
            {
                cout<<"NO"<<endl;
                return 0;
            }
            else if(abs(a[i]-a[i-1])!=1&&i!=1)
                t=abs(a[i]-a[i-1]);//预处理列数
        }
        for(int i=2;i<=n;i++)//从2开始
        {
            if(abs(a[i]-a[i-1])!=1&&abs(a[i]-a[i-1])!=t)//有多个差值不等于1但互不相同，条件1
            {
                cout<<"NO"<<endl;
                return 0;
            }
            else if(abs(a[i]-a[i-1])==1&&t!=1&&((a[i]-1)/t!=(a[i-1]-1)/t))//条件3，换行情况
            {
                cout<<"NO"<<endl;
                return 0;
            }
        }
        cout<<"YES"<<endl;
        cout<<MAXX<<" "<<t<<endl;
        return 0;
    }
    ```

### 最优关键思路或技巧
1. **固定行数**：由于矩阵行数对判断序列合法性影响不大，且只需输出任意一种可能大小，将行数固定设为 $10^9$，简化问题，专注求列数。
2. **分析差值**：通过分析序列中相邻编号的差值来确定列数及判断合法性。差值为1可能是左右移动，非1的差值可能是上下移动，该差值即为列数，同时要保证非1差值的一致性。
3. **特殊情况判断**：仔细处理特殊情况，如原地停留（相邻编号相等）、非法换行（差值为1但实际跨行了），通过对编号减1后除以列数判断是否在同一行来避免误判。

### 拓展思路
同类型题通常围绕矩阵中元素的移动规则和编号规律，结合给定的移动序列判断矩阵的可行性或求解矩阵参数。类似算法套路是抓住元素编号与移动关系，通过分析相邻元素编号差值及行列关系来解决问题。

### 推荐洛谷题目
1. **P1111 [NOIP2014 普及组] 修复公路**：涉及图论中边权与连通性问题，与本题分析序列规律判断可行性类似，需根据给定条件构建图并判断连通情况。
2. **P1241 括号序列**：字符串类型题目，通过分析字符串中括号的排列规律判断其合法性，与本题分析序列中编号差值规律判断矩阵合法性思路相似。
3. **P2036 [COCI2008-2009#2] PERKET**：枚举类型题目，通过枚举不同配料组合来满足一定条件，与本题通过分析不同移动情况（差值情况）来确定矩阵是否合法有相似的思维方式。 

---
处理用时：62.54秒
# 题目信息

# Shark

## 题目描述

科学家们研究鲨鱼的习性已经有一段很长的时间了。鲨鱼，就像其他的生物一样，在某一地点交替短途移动, 并在不同地点之间长途移动。



Max 是一位年轻的生物学家。他观察一只特别的鲨鱼已有 $n$ 天，现在他也清楚地知道这只鲨鱼在某一天游动的距离。每天鲨鱼游动的距离都是不同的。Max 想知道鲨鱼抵达了多少个位置。他假定：如果鲨鱼在某天游动的距离严格小于 $k$，那么它的位置不发生变化；否则，如果鲨鱼在某天游动的距离大于或等于 $k$，则它的位置在那天发生了变化。注意：有可能鲨鱼的位置连续几天都发生了变化，只要这几天每天鲨鱼游动的距离都至少为 $k$。



从某个地方游走后，鲨鱼就不会再回来了。也就是说，我们可以将这个 $n$ 天的序列划分成若干断连续的、非空子段，使得每一子段内每天鲨鱼游动的距离都小于 $k$，那么每一个子段就代表一个位置。Max 想找出这样的 $k$，使得每个子段的长度都相等。



找到这样的整数 $k$，令位置的数量尽可能地多。如果存在多个满足条件的 $k$，输出最小的一个。

## 样例 #1

### 输入

```
8
1 2 7 3 4 8 5 6
```

### 输出

```
7```

## 样例 #2

### 输入

```
6
25 1 2 3 14 36
```

### 输出

```
2```

# AI分析结果

### 题目内容
# Shark

## 题目描述
科学家们研究鲨鱼的习性已经有一段很长的时间了。鲨鱼，就像其他的生物一样，在某一地点交替短途移动，并在不同地点之间长途移动。

Max是一位年轻的生物学家。他观察一只特别的鲨鱼已有 $n$ 天，现在他也清楚地知道这只鲨鱼在某一天游动的距离。每天鲨鱼游动的距离都是不同的。Max想知道鲨鱼抵达了多少个位置。他假定：如果鲨鱼在某天游动的距离严格小于 $k$，那么它的位置不发生变化；否则，如果鲨鱼在某天游动的距离大于或等于 $k$，则它的位置在那天发生了变化。注意：有可能鲨鱼的位置连续几天都发生了变化，只要这几天每天鲨鱼游动的距离都至少为 $k$。

从某个地方游走后，鲨鱼就不会再回来了。也就是说，我们可以将这个 $n$ 天的序列划分成若干断连续的、非空子段，使得每一子段内每天鲨鱼游动的距离都小于 $k$，那么每一个子段就代表一个位置。Max想找出这样的 $k$，使得每个子段的长度都相等。

找到这样的整数 $k$，令位置的数量尽可能地多。如果存在多个满足条件的 $k$，输出最小的一个。

## 样例 #1
### 输入
```
8
1 2 7 3 4 8 5 6
```
### 输出
```
7
```

## 样例 #2
### 输入
```
6
25 1 2 3 14 36
```
### 输出
```
2
```

### 算法分类
并查集

### 综合分析与结论
这些题解的核心思路大多是先对输入数据进行排序，然后利用并查集来维护子段信息，通过逐步添加数据点，动态判断子段是否合法，并更新满足条件的 $k$ 值。不同题解在具体实现细节上略有差异，如维护的变量、合并区间的具体操作等，但整体思路较为一致。

### 所选的题解
- **作者：QwQcOrZ (5星)**
    - **关键亮点**：思路清晰，详细阐述了利用并查集维护区间的三种情况（合并两段区间、延长一段区间、新建一段区间），以及动态维护区间总数量、最长区间长度等关键信息来判断区间合法性的方法，代码实现完整且注释详细。
    - **重点代码 - 核心实现思想**：通过 `merge` 函数合并区间，在每次添加点时，根据该点前后位置的状态进行相应处理，同时更新区间相关信息，当区间总数量等于长度等于最长区间的区间个数时更新答案。
```cpp
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
    int u=find(x),v=find(y);
    fa[u]=v;
    siz[v]+=siz[u];
}

int main()
{
    memset(f,0,sizeof(f));
    int n=read();
    for (int i=1;i<=n;i++) p[i]=fa[i]=i,siz[i]=1;
    for (int i=1;i<=n;i++) a[i]=read();
    sort(p+1,p+1+n,cmp);
    int tot=0,cnt=0,L=1,Max=0,ans;
    for (int i=1;i<=n;i++)
    {
        int now=p[i];
        f[now]=1;
        if (!f[now-1]&&!f[now+1])
        {
            tot++;
            if (L==1) cnt++;
        }
        else if (f[now-1]&&f[now+1])
        {
            tot--;
            merge(now-1,now);
            merge(now+1,now);
            if (siz[now]>L)
            {
                L=siz[now];
                cnt=1;
            }
            else if (siz[now]==L) cnt++;
        }
        else
        {
            if (f[now-1]) merge(now-1,now);
            if (f[now+1]) merge(now+1,now);
            if (siz[now]>L)
            {
                L=siz[now];
                cnt=1;
            }
            else if (siz[now]==L) cnt++;
        }
        if (tot==cnt)
        if (tot>Max)
        {
            Max=tot;
            ans=a[now]+1;
        }
    }
    print(ans);

    return 0;
}
```
- **作者：Acfboy (4星)**
    - **关键亮点**：简洁明了地阐述了题目条件，直接点明排序后插入并用并查集处理子段的思路，代码简洁，核心操作在 `add` 函数中体现。
    - **重点代码 - 核心实现思想**：`add` 函数中根据当前点前后位置是否已在集合中，进行区间合并操作，并更新集合数量、最大集合大小等信息，当满足条件时更新答案。
```cpp
// eq 是大小和最大的相等的段的数量，ml 是最大的大小，num 是集合数
void add(int x) {
    flag[x] = 1;
    flag[x-1] && (num --, eq -= size[find(x-1)] == ml, merge(x, x-1)), 
    flag[x+1] && (num --, eq -= size[find(x+1)] == ml, merge(x, x+1));
    num ++;
    int t = size[find(x)];
    if(ml < t) eq = 1, ml = t;
    else if(ml == t) eq ++;
}
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i].v), a[i].id = i;
    std::sort(a+1, a+1+n);
    for(int i = 1; i <= n; i++) fa[i] = i, size[i] = 1;
    for(int i = 1; i <= n; i++) {
        add(a[i].id);
        if(num == eq && (num > ann || (num == ann && ank > a[i].v+1))) 
            ank = a[i].v+1, ann = num;
    }
    printf("%d", ank);
}
```
- **作者：jch123 (4星)**
    - **关键亮点**：思路阐述清晰，明确指出排序后添加数会出现的三种区间变化情况，代码结构清晰，变量命名直观。
    - **重点代码 - 核心实现思想**：在 `main` 函数中，每次添加数时，根据该数前后位置的状态，通过 `merge` 函数合并区间，并更新区间总数量、最长区间长度等信息，当满足条件时更新答案。
```cpp
int find(int x)
{
    if(fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)
    {
        fa[fx]=fy;
        sz[fy]+=sz[fx];
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        fa[i]=i,sz[i]=1;
    for(int i=1;i<=n;i++)
        cin>>a[i].x,a[i].id=i;
    sort(a+1,a+1+n,cmp);
    int at=0,cnt=0,len=1;
    int maxn=0,ans=0;
    for(int i=1;i<=n;i++)
    {
        int p=a[i].id;
        book[p]=1;
        if(book[p-1]==0&&book[p+1]==0) 
        {
            at++;
            if(len==1) cnt++;
        }
        else if(book[p-1]&&book[p+1])
        {
            at--;
            merge(p-1,p),merge(p+1,p);
            if(sz[p]>len) len=sz[p],cnt=1;
            else if(sz[p]==len) cnt++;
        }
        else
        {
            if(book[p-1]) merge(p-1,p);
            if(book[p+1]) merge(p+1,p);
            if(sz[p]>len) len=sz[p],cnt=1;
            else if(sz[p]==len) cnt++;
        }   
        if(at==cnt&&at>maxn)
            maxn=at,ans=a[i].x+1;
    }
    cout<<ans;
    return 0;
}
```

### 最优关键思路或技巧
利用并查集维护区间信息，通过排序后逐步添加数据点，动态更新区间的合并、长度等信息，以此判断子段是否合法并找到最优的 $k$ 值。这种方法巧妙地解决了子段动态变化的问题，降低了时间复杂度。

### 可拓展之处
此类题目属于利用数据结构解决区间划分与统计问题，类似的算法套路还可应用于其他涉及区间合并、拆分并需要统计相关信息的场景。例如，在一些地理信息系统（GIS）数据处理中，可能会涉及到区域的合并与分割，并统计不同区域的属性信息。

### 推荐洛谷题目
- [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：经典的并查集应用题目，通过并查集判断亲戚关系。
- [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)：并查集模板题，可用于巩固并查集的基本操作。
- [P1197 [JSOI2008] 星球大战](https://www.luogu.com.cn/problem/P1197)：结合图论与并查集，需要在动态过程中利用并查集维护连通块信息。

### 个人心得摘录与总结
暂无。 

---
处理用时：85.15秒
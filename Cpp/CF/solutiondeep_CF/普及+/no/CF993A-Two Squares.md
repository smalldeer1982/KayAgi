# 题目信息

# Two Squares

## 题目描述

给出两个正方形，其中一个正方形的边恰好与坐标轴平行，而另一个呈  $45\degree$  角倾斜。

请你判断这两个正方形是否重叠。（如果两个正方形有点或边重合了，也算作重叠）

## 说明/提示

- 第  $1$  组样例的解释：

因为第  $2$  个正方形完全被第  $1$  个正方形包含，也算作重叠，故输出  $Yes$  或  $YES$ 。

- 第  $2$  组样例的解释：

因为两个正方形完全没有重叠，故输出  $No$  或  $NO$ 。

- 第  $3$  组样例的解释：

因为两个正方形有一小部分重叠，故输出  $Yes$  或  $YES$ 。

每个样例对应的图像如下所示。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
0 0 6 0 6 6 0 6
7 3 9 5 11 3 9 1
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
6 0 6 6 0 6 0 0
7 4 4 7 7 10 10 7
```

### 输出

```
YES
```

# AI分析结果

### 题目内容
# 两个正方形

## 题目描述
给出两个正方形，其中一个正方形的边恰好与坐标轴平行，而另一个呈 $45\degree$ 角倾斜。请你判断这两个正方形是否重叠。（如果两个正方形有点或边重合了，也算作重叠）

## 说明/提示
- 第1组样例的解释：因为第2个正方形完全被第1个正方形包含，也算作重叠，故输出 $Yes$ 或 $YES$ 。
- 第2组样例的解释：因为两个正方形完全没有重叠，故输出 $No$ 或 $NO$ 。
- 第3组样例的解释：因为两个正方形有一小部分重叠，故输出 $Yes$ 或 $YES$ 。
每个样例对应的图像如下所示。
感谢@Sooke提供翻译

## 样例 #1
### 输入
```
0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
```
### 输出
```
YES
```

## 样例 #2
### 输入
```
0 0 6 0 6 6 0 6
7 3 9 5 11 3 9 1
```
### 输出
```
NO
```

## 样例 #3
### 输入
```
6 0 6 6 0 6 0 0
7 4 4 7 7 10 10 7
```
### 输出
```
YES
```

### 算法分类
枚举

### 综合分析与结论
这几道题解主要围绕判断两个特定摆放的正方形是否重叠展开。各题解思路如下：
 - **zhang_kevin**：枚举所有可能点，判断是否同时属于两个正方形。通过对输入坐标处理得到正方形边界，利用循环枚举点并通过条件判断是否重叠。
 - **Binary_Lee**：利用二维数组标记第一个正方形位置，遍历第二个正方形范围判断是否有标记，坐标可能为负需处理，且要对坐标排序，遍历第二个正方形时按上下两部分分别处理。
 - **jgvccc**：通过快排整理顶点顺序，找到倾斜正方形中心，确定正常正方形边界，枚举正常正方形点，依据曼哈顿距离判断是否重叠。
 - **三点水一个各**：暴力算法是开二维数组标记点，判断是否有值为2的元素；几何算法是根据两种正方形相对位置的不同情况判断，利用特殊的45°和平行条件。
 - **loser_seele**：将问题转化为半平面交，通过多边形交相关函数判断是否存在交点，代码需特判交点在边界情况。

整体来看，各题解都基于数据范围小和正方形特殊角度的条件设计算法。有的通过枚举点判断，有的利用二维数组标记，有的借助几何性质，都有各自的实现技巧和注意点。

### 所选的题解
- **作者：zhang_kevin（5星）**
    - **关键亮点**：思路清晰直接，通过枚举所有可能点判断重叠情况，代码实现中对输入输出进行了封装，且给出了找到公共点的扩展功能。
    - **重点代码**：
```cpp
inline bool check(int i, int j){
    return minx1 <= i && i <= maxx1 && miny1 <= j && j <= maxy1 && minx2 <= i + j && maxx2 >= i + j && miny2 <= i - j && maxy2 >= i - j;
}
int main(){    
    for(int i = 0; i < 4; i++){
        fio >> x1[i] >> y1[i];
    }
    minx1 = min(min(x1[0], x1[1]), min(x1[2], x1[3]));
    maxx1 = max(max(x1[0], x1[1]), max(x1[2], x1[3]));
    miny1 = min(min(y1[0], y1[1]), min(y1[2], y1[3]));
    maxy1 = max(max(y1[0], y1[1]), max(y1[2], y1[3]));
    for(int i = 0; i < 4; i++){
        cin >> x2[i] >> y2[i];
        x1[i] = x2[i] + y2[i];
        y1[i] = x2[i] - y2[i];
    }
    minx2 = min(min(x1[0], x1[1]), min(x1[2], x1[3]));
    maxx2 = max(max(x1[0], x1[1]), max(x1[2], x1[3]));
    miny2 = min(min(y1[0], y1[1]), min(y1[2], y1[3]));
    maxy2 = max(max(y1[0], y1[1]), max(y1[2], y1[3])); 
    for(int i = -100; i <= 100; i++){
        for(int j = -100; j <= 100; j++){
            if(check(i, j)){
                //fio << "(" << _ts(i) << "," << _ts(j) << ")" << endl;
                fio << "YES" << endl;
                return 0;
            }
        }
    }
    fio << "NO" << endl;
    return 0;   
}
```
核心实现思想：先读入两个正方形坐标，处理得到各自边界，通过双重循环枚举所有可能点，调用`check`函数判断点是否同时属于两个正方形，若存在则输出`YES`，否则输出`NO`。

- **作者：Binary_Lee（4星）**
    - **关键亮点**：利用二维数组直观标记，针对坐标负数及顺序不确定等问题给出处理方法，思路结合图形遍历较为清晰。
    - **重点代码**：
```cpp
bool cmp(node a,node b){
    if(a.x==b.x) return a.y>b.y;
    return a.x<b.x;
}
signed main(){
    IOS;TIE;
    // 读入坐标等操作省略
    sort(a+1,a+5,cmp);
    swap(a[3],a[4]);      //得到顺序
    for(int i=a[4].y;i<=a[1].y;i++){     //遍历上半部分
        len=i-a[4].y;
        for(int j=a[4].x-len;j<=a[4].x+len;j++){
            if(vis[i][j]){
                cout<<"YES"<<endl;
                return 0;
            }
        }
    }
    for(int i=a[1].y;i<=a[2].y;i++){     //遍历下半部分
        len=a[2].y-i;
        for(int j=a[2].x-len;j<=a[2].x+len;j++){
            if(vis[i][j]){
                cout<<"YES"<<endl;
                return 0;
            }
        }
    }
    cout<<"NO"<<endl;
    return 0;
}
```
核心实现思想：读入坐标后排序并调整顺序，分上下两部分遍历倾斜正方形范围，判断该范围内点在标记第一个正方形的二维数组中是否有标记，有则输出`YES`，无则输出`NO`。

- **作者：jgvccc（4星）**
    - **关键亮点**：利用倾斜正方形中心到边上点曼哈顿距离相等的性质，通过排序、找中心、定边界、枚举判断，思路简洁明了。
    - **重点代码**：
```cpp
struct point
{
    int x;
    int y;
}a[5],b[5];
bool cmp(point i,point j)
{
    return i.x<j.x || (i.x==j.x && i.y<j.y);
}
int x,y,dis;
int ux,uy,dx,ry;
signed main()
{
    std::ios::sync_with_stdio(false);
    for(int i=1;i<=4;i++) cin>>a[i].x>>a[i].y,a[i].x+=100,a[i].y+=100;
    for(int i=1;i<=4;i++) cin>>b[i].x>>b[i].y,b[i].x+=100,b[i].y+=100;
    sort(a+1,a+5,cmp);
    sort(b+1,b+5,cmp);
    ux=a[1].x;
    uy=a[1].y;
    ry=a[2].y;
    dx=a[3].x;
    x=(b[1].x+b[4].x)/2;
    y=(b[2].y+b[3].y)/2;
    dis=(b[3].y-b[2].y)/2;
    for(int i=ux;i<=dx;i++)
    {
        for(int j=uy;j<=ry;j++)
        {
            if(abs(i-x)+abs(j-y)<=dis)
            {
                cout<<"YES";
                return 0;
            }
        }
    }
    cout<<"NO";
    return 0;
}
```
核心实现思想：读入两个正方形坐标并处理，排序后确定正常正方形边界和倾斜正方形中心及距离，枚举正常正方形内点，根据曼哈顿距离判断是否重叠，是则输出`YES`，否则输出`NO`。

### 最优关键思路或技巧
利用正方形特殊角度和坐标范围小的特点进行枚举判断。如zhang_kevin直接枚举所有可能点判断是否同属两个正方形；Binary_Lee利用二维数组标记；jgvccc利用倾斜正方形几何性质枚举判断。这些方法都巧妙利用题目条件简化问题。

### 拓展
同类型题可关注判断多边形相交问题，类似算法套路是利用几何性质、枚举点或区域等方式判断。例如对于其他特殊角度或形状的多边形相交判断，也可考虑通过坐标变换、确定边界、枚举关键区域等思路解决。

### 推荐题目
 - [P1241 括号序列](https://www.luogu.com.cn/problem/P1241)：考察对字符串括号匹配及相关逻辑判断，类似本题对特定条件下元素关系的判断。
 - [P1088 火星人](https://www.luogu.com.cn/problem/P1088)：通过枚举和字典序相关操作解决问题，与本题通过枚举判断重叠类似。
 - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：利用枚举和动态规划思想解决组合问题，在思路上与本题通过枚举解决特定几何关系判断有一定相似性。 

---
处理用时：83.28秒
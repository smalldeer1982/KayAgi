# 题目信息

# Tree Infection

## 题目描述

### 题意描述
一个树是一个无环连通图。一个有根树有一个被称作“根结点”的结点。对于任意一个非根结点 $v$ ，其父结点是从根结点到结点 $v$ 最短路径上的前一个结点。结点 $v$ 的子结点包括所有以 $v$ 父结点为 $v$ 的结点。

给定一个有 $n$ 个结点的有根树。结点 $1$ 即为根结点。一开始，该树上所有结点均是“健康”的。

每一秒你会进行两次操作——先是传播操作，然后是注射操作，定义如下。

- 传播操作：对于每个结点 $v$ ，若该结点至少有一个子结点被“感染”，则你可以“感染”顶点 $v$ 任意一个其他的子结点。
- 注射：你可以选择任意一个“健康”的结点并使它变为“感染”状态。

这程每秒会重复一次知道整个树的结点都处于“感染”状态。你需要找到使整个树被“感染”的最短时间（秒数）。

## 说明/提示

- $ 1 \le t \le 10^4 $
- $ 2 \le n \le 2 \times 10^5 $
- $ 1 \le p_i \le n $
- $ \sum \limits_{i=1} ^t n_i \le 2 \times 10^5 $

## 样例 #1

### 输入

```
5
7
1 1 1 2 2 4
5
5 5 1 4
2
1
3
3 1
6
1 1 1 1 1```

### 输出

```
4
4
2
3
4```

# AI分析结果



### 题目内容中文重写
# 树感染

## 题目描述

### 题意描述
树是一个无环连通图。有根树有一个被称为“根节点”的节点。对于任意非根节点 $v$，其父节点是从根节点到 $v$ 的最短路径上的前一个节点。节点 $v$ 的子节点是所有以 $v$ 为父节点的节点。

给定包含 $n$ 个节点的有根树，根为节点 1。初始所有节点健康。

每秒按顺序执行两次操作：传播操作后执行注射操作。

- **传播操作**：对每个节点 $v$，若其至少有一个子节点被感染，则可以感染 $v$ 的另一个健康子节点。
- **注射操作**：选择任意健康节点感染。

求感染整棵树所需的最少秒数。

## 说明/提示
- $1 \le t \le 10^4$
- $2 \le n \le 2 \times 10^5$
- 输入保证树结构合法
- 所有测试用例的 $n$ 之和不超过 $2 \times 10^5$

## 样例 #1
输入输出见原题。

---

### 题解分析与结论

**核心思路**：
1. **子节点分组处理**：将每个节点的子节点视为独立集合，优先处理子节点多的节点。
2. **贪心+优先队列**：初始阶段为每个节点注射一个子节点，剩余子节点通过传播和额外注射处理，用最大堆动态跟踪剩余最多的子节点数。
3. **时间计算**：总时间 = 初始注射时间 + 处理剩余子节点的额外时间。

**关键技巧**：
- 添加虚拟节点（0号节点）统一处理根节点。
- 将子节点数排序后，用优先队列维护需处理的剩余子节点数。
- 使用“传播计数器”跟踪自动感染进度，减少无效注射。

---

### 高星题解精选

#### 题解1：作者：tzyt（4星）
**亮点**：
- 引入虚拟节点统一处理根节点
- 详细注释解释堆的维护逻辑
- 时间复杂度严格为 $O(n \log n)$

**核心代码分析**：
```cpp
priority_queue<int> pq;
// 预处理每个节点的剩余子节点数（减去初始注射和传播的影响）
for (int i = fir_n_zero; i <= n; i++) {
    pq.push(siz[i] - (i - fir_n_zero) - 1);
}

int tm_used = n - fir_n_zero + 1; // 初始注射时间
int spreaded = 0;

// 动态处理剩余子节点
while (pq.top() > spreaded) {
    spreaded++;
    int tp = pq.top();
    pq.pop();
    pq.push(tp - 1);
    tm_used++;
}
```

#### 题解2：作者：jiangtaizhe001（4星）
**亮点**：
- 代码简洁高效，引入“懒惰标记”优化传播计数
- 堆操作与计数器结合实现线性时间复杂度

**核心代码片段**：
```cpp
priority_queue<int> a, b, E;
// 预处理子节点数并压入堆
for (i=1; i<=n; i++) if (son[i]) a.push(son[i]), cnt++;
a.push(1); // 根节点处理

// 计算初始时间并处理剩余子节点
while (b.top() > ans) {
    x = b.top();
    b.pop();
    b.push(x - 1);
    ans++;
}
```

---

### 关键思路总结
1. **预处理子节点数**：统计每个节点的子节点数，包括虚拟根节点。
2. **初始注射阶段**：为每个节点至少注射一个子节点，时间为非零子节点数。
3. **堆维护剩余量**：用最大堆维护剩余子节点数，每次处理最大的节点。
4. **并行处理传播与注射**：通过传播计数器模拟自动感染，动态调整注射目标。

---

### 拓展与相似题目
1. **优先队列应用**：类似调度问题的贪心策略，如[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. **树结构处理**：[P1351 联合权值](https://www.luogu.com.cn/problem/P1351)
3. **时间最优化问题**：[P2218 [HAOI2007] 覆盖问题](https://www.luogu.com.cn/problem/P2218)

---

### 个人心得摘录
- **tzyt**：理解传播与注射的并行性是关键，需注意“子节点感染独立于父节点层级”。
- **听取MLE声一片**：在WA后发现单纯按子节点数排序不可行，必须动态调整处理顺序。

---
处理用时：62.72秒
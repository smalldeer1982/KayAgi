# 题目信息

# Path Prefixes

## 题目描述

# Path Prefixes


现有一颗以 $1$ 为根的树，节点编号从 $1$ 到 $n$ .

每条边有两个权值，分别为 $a_j$ 和 $b_j$ .

输出 $n-1$ 个数 $r_2,r_3 \cdots ,r_n$ ，其中 $r_i$ 定义如下:

考虑从根节点( $1$ 号节点 ) 到第 $i$ 号节点 $(2 \le i \le n)$ 的路径，令沿该路径 $a_j$ 的花费为 $A_i$ ， $r_i$ 为该路径的最长前缀，使该前缀的 $b_j$ 之和不大于 $A_i$ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1714G/fb21910eda699947633b658de9a5b141ee71688b.png)

以 $n=9$ 时为例，如上图，蓝色数字表示 $a_j$ 的花费，红色数字表示 $b_j$ 的花费.

在这种情况下：

- $ r_2=0 $ ， 因为到节点 $ 2 $ 的路径中有 $ a_j=5 $  ， 只有前缀为 $ 0 $ 时才可能有较小（或相等）的 $ b_j $ ；
- $ r_3=3 $ ， 因为到节点 $ 3 $ 的路径中 $ a_j $ 为 $ 5+9+5=19 $ ， 长为 $ 3 $ 的前缀使 $ b_j $ 为 $ 6+10+1=17 $ ( $ 17 \le 19 $ 符合题意 )；
- $ r_4=1 $ ， 因为到节点 $ 4 $ 的路径中 $ a_j $ 为 $ 5+9=14 $ ， 长为 $ 1 $ 的前缀使 $ b_j $ 为 $ 6 $ (这是最长的符合题意的前缀， 因为长为 $ 2 $ 的前缀的 $ b_j $ 为 $ 6+10=16 $ ， 大于 $ 14 $ )；
- $ r_5=2 $ ， 因为到节点 $ 5 $ 的路径中 $ a_j $ 为 $ 5+9+2=16 $ ， 长为 $ 2 $ 的前缀使 $ b_j $ 为 $ 6+10=16 $ (这是最长的符合题意的前缀， 因为长为 $ 3 $ 的前缀的 $ b_j $ 为 $ 6+10+1=17 $ ， 比 $ 16 $ 大 )；
- $ r_6=1 $ ， 因为到节点 $ 6 $ 的路径中 $ a_j $ 为 $ 2 $ ， 长为 $ 1 $ 的前缀使 $ b_j $ 等于 $ 1 $ ；
- $ r_7=1 $ ， 因为到节点 $ 7 $ 的路径中 $ a_j $ 为 $ 5+3=8 $ ， 长为 $ 1 $ 的前缀使 $ b_j $ 等于 $ 6 $ (这是最长的符合题意的前缀， 因为长为 $ 2 $ 的前缀的 $ b_j $ 为 $ 6+3=9 $ ， 超出了期望的 $ 8 $ )；
- $ r_8=2 $ ， 因为到节点 $ 8 $ 的路径中 $ a_j $ 为 $ 2+4=6 $ ， 长为 $ 2 $ 的前缀使 $ b_j $ 为 $ 1+3=4 $ ；
- $ r_9=3 $ ， 因为到节点 $ 9 $ 的路径中 $ a_j $ 为 $ 2+4+1=7 $ ， 长为 $ 3 $ 的前缀使 $ b_j $ 为 $ 1+3+3=7 $ .


在第二组样例中

- $ r_2=0 $ ，因为到节点 $ 2 $ 的路径中 $ a_j $ 等于 $ 1 $ ， 只有前缀为 $ 0 $ 时才可能有较小（或相等）的 $ b_j $
- $ r_3=0 $ ， 因为到节点 $ 3 $ 的路径中 $ a_j $ 为 $ 1+1=2 $ ， 长为  $ 1 $ 的前缀使 $ b_j $ 等于 $ 100 $ ( $ 100 > 2 $ )；
- $ r_4=3 $ ， 因为到节点 $ 4 $ 的路径中 of $ a_j $ 为 $ 1+1+101=103 $ ， 长为 $ 3 $ 的前缀使 $ b_j $ 为 $ 102 $  .

## 样例 #1

### 输入

```
4
9
1 5 6
4 5 1
2 9 10
4 2 1
1 2 1
2 3 3
6 4 3
8 1 3
4
1 1 100
2 1 1
3 101 1
4
1 100 1
2 1 1
3 1 101
10
1 1 4
2 3 5
2 5 1
3 4 3
3 1 5
5 3 5
5 2 1
1 3 2
6 2 1```

### 输出

```
0 3 1 2 1 1 2 3 
0 0 3 
1 2 2 
0 1 2 1 1 2 2 1 1```

# AI分析结果



### 题目内容
#### Path Prefixes

**题目描述**  
给定一棵以1号节点为根的树，节点编号从1到n。每条边有两个权值a_j和b_j。对于每个节点i（2 ≤ i ≤ n），输出r_i的值，其中r_i定义为：从根到i的路径上，使得该前缀的b_j之和不超过整个路径a_j之和的最长前缀长度。

**样例解释**  
以n=9的树为例，详细说明了各节点的r值计算逻辑，强调前缀长度由b之和不超过a之和的最大边数决定。

---

### 题解分析与结论

#### 关键思路与技巧
1. **DFS维护前缀和数组**：在深度优先搜索时，动态维护当前路径的b前缀和数组。由于b值均为正数，前缀和数组严格递增，支持二分查找。
2. **二分查找优化**：对每个节点，用`upper_bound`在递增的前缀和数组中快速定位最大有效前缀长度，时间复杂度O(log n)。
3. **回溯维护状态**：使用栈或vector存储当前路径的前缀和，进入子节点时压栈，回溯时弹栈，保证数组的正确性。
4. **单次DFS完成计算**：在一次DFS中同时计算路径的a总和和b前缀和，避免多次遍历。

#### 推荐题解
1. **SmallBlack（★★★★★）**  
   **亮点**：代码结构清晰，两次DFS分离计算与查询，维护前缀和数组的方式直观。  
   **代码核心**：
   ```cpp
   vector<ll> now; // 维护b前缀和
   void dfs1(int x, int fa) {
       now.push_back(B[x]);
       ans[x] = upper_bound(now.begin(), now.end(), A[x]) - now.begin() - 1;
       for (auto &e : edges[x]) {
           if (e.v != fa) {
               B[e.v] = B[x] + e.b;
               dfs1(e.v, x);
           }
       }
       now.pop_back();
   }
   ```
   **心得**：两次DFS虽非最优，但逻辑分离易于理解。

2. **Dr_Gilbert（★★★★☆）**  
   **亮点**：利用倍增法预处理祖先，避免动态数组操作，适合内存敏感场景。  
   **代码核心**：
   ```cpp
   // 预处理倍增祖先
   for (int j=18; j>=0; j--) {
       if (sumb[fat[x][j]] > A_i) x = fat[x][j];
   }
   // 最终x为最深有效祖先
   ```
   **心得**：通过跳跃式检查祖先的b和，巧妙利用前缀和的单调性。

3. **sixrc（★★★★★）**  
   **亮点**：单次DFS同步计算a总和与b前缀，代码简洁高效。  
   **代码核心**：
   ```cpp
   void dfs(int u, ll suma, ll sumb) {
       sum_b.push_back(sumb);
       ans[u] = upper_bound(sum_b.begin(), sum_b.end(), suma) - sum_b.begin() - 1;
       for (auto &e : edges[u]) {
           dfs(e.v, suma + e.a, sumb + e.b);
       }
       sum_b.pop_back();
   }
   ```
   **心得**：全局数组直接维护路径状态，回溯自动恢复。

---

### 拓展与习题
**类似题目套路**  
- 树路径上的单调性查询（如最大值、前缀和）
- 结合LCA与倍增法的路径问题

**推荐习题**  
1. [P1081 开车旅行](https://www.luogu.com.cn/problem/P1081)（倍增法应用）  
2. [P3398 仓鼠找sugar](https://www.luogu.com.cn/problem/P3398)（树路径交集）  
3. [P2633 Count on a tree](https://www.luogu.com.cn/problem/P2633)（树上可持久化结构）

---
处理用时：205.95秒
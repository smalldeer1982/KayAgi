# 题目信息

# Kevin and Competition Memories

## 题目描述

Kevin 曾经进入过 Rio 的记忆。在那段记忆中，曾举办过一系列的比赛。Kevin 还记得所有参赛者和比赛的问题，但具体的比赛轮次、问题分布和排名已经模糊不清。

有 $m$ 个比赛问题，第 $i$ 个问题的难度为 $b_i$。每场比赛选择 $k$ 个问题，因此总共会有 $\lfloor \frac{m}{k} \rfloor$ 场比赛。这意味着你可以任意组合选择这些比赛问题，并挑出总共 $\lfloor \frac{m}{k} \rfloor \cdot k$ 个问题参赛，每个问题最多只能被选一次，剩余 $m \bmod k$ 个问题将未被使用。例如，如果 $m = 17$ 且 $k = 3$，你将组织 $5$ 场比赛，每场 $3$ 个问题，会剩下 $2$ 个问题没有用上。

比赛有 $n$ 位参赛者，其中 Kevin 是第 1 位。第 $i$ 位参赛者的评分是 $a_i$。在比赛中，每个参赛者能解决难度不超过其评分的问题，具体来说，第 $i$ 位参赛者能解决第 $j$ 个问题，当且仅当 $a_i \geq b_j$。在每场比赛中，Kevin 的排名定义为那些比他解掉更多题目的参赛者数量加一。

对于每个 $k = 1, 2, \ldots, m$，Kevin 想知道在所有 $\lfloor \frac{m}{k} \rfloor$ 场比赛中的排名之和的最小可能值。也就是说，对于某个 $k$，你需要优化问题的选择和分配，使得 Kevin 的排名之和最小化。

不同的 $k$ 值代表的比赛是相互独立的。换言之，你可以对每个不同的 $k$ 值分别规划问题分配。

## 说明/提示

考虑第一个测试数据：

- 当 $k=1$ 时，每场比赛只包含一个问题，分配方式是唯一的。例如，在包含难度为 $4$ 的第三个问题的比赛中，除了第 2 位参赛者外，所有人都能解决。因为没有人比 Kevin 解出更多的问题，他在这场比赛中排名第 1。同理，在所有 $4$ 场比赛中，Kevin 的排名分别是 $1, 3, 1, 2$，总和为 $7$。

- 当 $k=2$ 时，最佳选择是将第 1 和第 3 个问题组成一场比赛，第 2 和第 4 个问题组成另一场。在前一场比赛中，4 名选手分别解决 $2, 1, 2, 2$ 个问题，Kevin 排名第 1；在后一场比赛中，选手分别解决 $0, 0, 2, 1$ 个问题，因有 2 位选手多解题，Kevin 排名第 $3$。所以总和是 $1 + 3 = 4$。这是最优解。

- 当 $k=3$ 时，可以选择第 1、3、4 个问题组成一场比赛，Kevin 的排名是 2，为最优。

- 当 $k=4$ 时，只有一场比赛，分配方式唯一，Kevin 的排名是 3。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
4 4
4 3 7 5
2 5 4 6
5 5
5 0 4 8 6
1 3 9 2 7
6 7
1 1 4 5 1 4
1 9 1 9 8 1 0
7 6
1 9 1 9 8 1 0
1 1 4 5 1 4```

### 输出

```
7 4 2 3
6 2 1 1 2
7 3 2 1 1 1 1
15 9 5 4 4 4```

# AI分析结果



### 题目内容重写
#### Kevin 的比赛回忆

**题目描述**  
Kevin 曾进入 Rio 的记忆，记忆中有若干比赛。他记得所有参赛者和题目难度，但具体轮次、题目分配和排名已模糊。

- **问题与参赛者**：共有 $m$ 个题目，难度分别为 $b_1, b_2, \ldots, b_m$；$n$ 位参赛者，第 $i$ 位的评分为 $a_i$（Kevin 是第 1 位）。
- **比赛规则**：每场比赛选 $k$ 个问题，共 $\lfloor m/k \rfloor$ 场。每场比赛中，Kevin 的排名为“解题数比他多的人数 +1”。
- **目标**：对每个 $k \in [1, m]$，求所有比赛中 Kevin 的排名之和的最小可能值。

**输入输出样例**  
（此处样例与原文一致，略）

**说明/提示**  
- 当 $k=1$ 时，每场仅一题，排名计算直接。
- 样例详细说明优化策略。

---

### 题解分析与结论

#### 最优思路总结
1. **预处理贡献值**  
   - 对每个题目 $b_i$，若 $b_i \le a_1$（Kevin 可解），贡献为 1（排名固定为 1）。
   - 若 $b_i > a_1$，贡献为其他参赛者中评分 $\ge b_i$ 的人数 +1。
2. **排序与贪心**  
   - 将贡献值升序排序，对每个 $k$，每场选连续的 $k$ 个问题，取组内最大值之和（即取每组末尾元素的和）。

#### 关键技巧
- **贡献值计算**：通过排序其他参赛者的评分，利用二分快速计算每个难题的贡献。
- **贪心策略**：升序排列贡献值后，每组取末尾元素（最大值），确保总和最小。

---

### 精选题解

#### 题解1：作者：_lmh_（5星）
**亮点**  
- 贡献值预处理简洁，直接二分计算其他选手的能力。
- 代码高效，直接排序后累加每组的末尾元素。

**核心代码**  
```cpp
for (int i = 0; i < m; i++) {
    if (b[i] <= me) {
        c[i] = 1;
    } else {
        c[i] = a.end() - lower_bound(a.begin(), a.end(), b[i]) + 1;
    }
}
ranges::sort(c);
for (int k = 1; k <= m; k++) {
    ll ans = 0;
    for (int j = k; j <= m; j += k) {
        ans += c[j - 1]; // 每组末尾元素
    }
    cout << ans << " ";
}
```

#### 题解2：作者：postpone（5星）
**亮点**  
- 使用 RMQ 快速查询区间最大值，适合更大规模数据。
- 预处理贡献值的逻辑清晰，代码可读性强。

**核心代码**  
```cpp
vector<int> c(m);
for (int i = 0; i < m; i++) {
    if (b[i] <= me) c[i] = 1;
    else c[i] = a.end() - lower_bound(a.begin(), a.end(), b[i]) + 1;
}
ranges::sort(c);
RMQ<int, greater<int>> rmq(c); // 构建 ST 表
for (int k = 1; k <= m; k++) {
    ll ans = 0;
    for (int j = 0; j + k <= m; j += k) {
        ans += rmq.query(j, j + k - 1); // 查询区间最大值
    }
    cout << ans << " ";
}
```

---

### 拓展与举一反三
1. **类似问题**  
   - 贪心策略中的“组内最大值和最小化”可应用于资源分配问题。
   - 贡献值预处理结合二分的思路常见于离线查询问题。

2. **推荐题目**  
   - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心策略的经典应用。
   - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：二分与排序的结合。
   - [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：动态维护有序序列的应用。

---
处理用时：303.57秒
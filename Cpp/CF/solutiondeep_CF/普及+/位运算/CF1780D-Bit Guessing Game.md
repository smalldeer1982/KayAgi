# 题目信息

# Bit Guessing Game

## 题目描述

这是一道交互题。

Kira 和 Hayato 正在玩一种猜数游戏，Kira 想，Hayato 猜。

对于每一轮游戏，设 Kira 想的数为 $n$。初始时，Kira 会给出 $cnt$，表示 $n$ 的二进制中 $1$ 的个数。Hayato 只能进行以下两种操作：

1. `- x`：修改操作。Kira 会将 $n$ 减去 $x$（注意此处 $n$ 会被修改），并给出此时的 $cnt$。特别地，若 $x > n$，则 Kira 直接获胜。
2. `! x`：查询操作。Kira 会将 $x$ 与最初的 $n$ 对比，若二者相同则 Hayato 获胜，反之 Kira 获胜，这轮游戏立即结束。

他们一共会进行 $t$ 轮游戏，你需要帮助 Hayato 在每一轮中获胜。同时，Kira 并不是一个很有耐心的人，因此你进行操作 1 的次数不能超过 $30$。

注意样例中的空行只是为了显示更清晰，不会出现在实际评测中。

## 样例 #1

### 输入

```
3

1

0

1

1

0

2

1

0```

### 输出

```
- 1

! 1

- 1

- 1

! 2

- 2

- 1

! 3```

# AI分析结果

### 题目内容
# 猜比特游戏

## 题目描述
这是一道交互题。

Kira 和 Hayato 正在玩一种猜数游戏，Kira 想数，Hayato 猜数。

对于每一轮游戏，设 Kira 想的数为 $n$。初始时，Kira 会给出 $cnt$，表示 $n$ 的二进制中 $1$ 的个数。Hayato 只能进行以下两种操作：
1. `- x`：修改操作。Kira 会将 $n$ 减去 $x$（注意此处 $n$ 会被修改），并给出此时的 $cnt$。特别地，若 $x > n$，则 Kira 直接获胜。
2. `! x`：查询操作。Kira 会将 $x$ 与最初的 $n$ 对比，若二者相同则 Hayato 获胜，反之 Kira 获胜，这轮游戏立即结束。

他们一共会进行 $t$ 轮游戏，你需要帮助 Hayato 在每一轮中获胜。同时，Kira 并不是一个很有耐心的人，因此你进行操作 1 的次数不能超过 $30$。

注意样例中的空行只是为了显示更清晰，不会出现在实际评测中。

## 样例 #1
### 输入
```
3

1

0

1

1

0

2

1

0
```
### 输出
```
- 1

! 1

- 1

- 1

! 2

- 2

- 1

! 3
```

### 综合分析与结论
这些题解的核心思路都是利用对数字进行特定减法操作后，二进制中1的个数变化规律来确定原数字二进制中1的位置，从而还原出原数字。
- **思路**：大多题解从给数减1操作入手，分析二进制中1个数的变化，如`n - 1`操作会使`popcount(n)`增加`lowbit(n) - 1` ，借此找到最低位1的位置，进而还原原数。
- **算法要点**：通过不断试探性地减去形如 $2^p$ 的数，根据二进制1个数的变化来定位1的位置，最终累加得到原数。
- **解决难点**：如何在不超过30次操作1的限制下准确还原原数。关键在于利用每次操作后二进制1个数的变化规律，高效定位每个1的位置。

### 所选的题解
- **作者：Feyn (5星)**
    - **关键亮点**：思路清晰，直接点明通过给数减1操作观察二进制1个数变化找到最低位1位置的方法，代码简洁明了。
    - **核心代码**：
```cpp
void solve(){
    int m=0,ans=0,pl=0,now=0;cin>>m;
    while(true){
        cout<<"- "<<(1<<pl)<<endl;
        int n;cin>>n;
        int del=n-m+1;while(del--)pl++;
        ans+=(1<<pl);
        if(n==pl)break;m=n;
    }
    cout<<"! "<<ans<<endl;
}
```
    - **核心思想**：维护指针`pl`，每次尝试让`n`减去 $2^{pl}$ ，根据二进制1个数增量`del`挪动指针`pl`，找到最低位1位置并累加到`ans`，直至找到所有1。
- **作者：InoueTakina (4星)**
    - **关键亮点**：提出优化思路，通过调整每次减去的数，保证对连续的1每个只需进行一次操作，减少操作次数。
    - **核心代码**：
```cpp
void solve() {
    cin >> cnt; ans = lst = now = 0;
    while(cnt) {
        lst = cnt; cnt = query(1 << now);
        if(lst > cnt) { ans = ans + (1 << now), now ++;}
        if(lst == cnt) {cnt = query(1 << now); ans = ans + (1 << (++ now)); now ++;}
        if(lst < cnt) {
            int ret = now;
            now += cnt - lst + 1; cnt = query((1 << now) - (1 << ret)); 
            ans = ans + (1 << now); now ++;
        } 
    } cout << "! " << ans << "\n"; fflush(stdout);
}
```
    - **核心思想**：根据每次操作后二进制1个数`cnt`与上一次`lst`的比较结果，调整减去的数及`now`指针位置，找到每个1的位置并累加。
- **作者：DaiRuiChen007 (4星)**
    - **关键亮点**：先分析 $n = 2^k$ 时操作 `- 1` 对二进制1个数的影响，进而推广到任意 $n$ ，逻辑推导清晰。
    - **核心代码**：
```cpp
inline void solve() {
    int tot;
    cin>>tot;
    int ans=0,lst=0,pre=tot;
    for(int i=1;i<=tot;++i) {
        int now=read(bit(lst));
        int nxt=lst+(now+1-pre);
        ans|=bit(nxt);
        lst=nxt+1,pre=now;
    }
    cout<<"! "<<ans<<endl;
}
```
    - **核心思想**：利用`read`函数进行操作并获取新的二进制1个数，根据变化量计算下一个1的位置`nxt`，通过`ans|=bit(nxt)`记录每个1的位置。

### 最优关键思路或技巧
利用对原数进行形如 `- 2^p` 的操作后，二进制中1个数的变化规律来定位每个1的位置。如减1操作会使`popcount(n)`增加`lowbit(n) - 1` ，据此找到最低位1位置，后续通过调整减去的数，优化操作次数，高效还原原数。

### 可拓展之处
此类题目属于交互题类型，相似套路是利用特定操作对数据的影响规律，逐步获取目标数据的信息。类似题目通常围绕数论、位运算等知识点，通过交互操作来解决问题。

### 洛谷相似题目
- [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)：涉及图论、并查集、倍增等知识点，通过操作获取信息解决问题。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：经典的图论中最短路径问题，与本题类似在给定规则下通过操作得到结果。
- [P2347 砝码称重](https://www.luogu.com.cn/problem/P2347)：利用对砝码不同放置组合（类似本题操作）来确定可称重范围，与本题利用操作获取信息思路类似。

### 个人心得摘录与总结
 - **作者：InoueTakina**：提到简单思路是每次去掉`lowbit`，但复杂度较高，进而思考优化，最终采用调整减去数的方式优化。总结为面对问题先思考朴素解法，再基于此分析优化方向。 

---
处理用时：31.54秒
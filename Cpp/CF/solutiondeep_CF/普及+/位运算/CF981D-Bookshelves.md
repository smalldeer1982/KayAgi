# 题目信息

# Bookshelves

## 题目描述

## 题意：

$Keks$ 先生是 $Byteland$ 大陆的典型的白领。

他办公室里有一个书架，上面有几本书，每本书都有一个值为正整数的价格。

$Keks$ 先生把书架的价值定义为书价的总和。         

出乎意料地是， $Keks$ 先生升职了，现在他要去一个新的办公室。

他知道，在新的办公室里，他将有不止一个书架，而恰恰是 $K$ 个书架。

他认为 $K$ 个书架的美丽程度在于所有书架的价值的“按位与”和。 

他还决定不花时间重新整理书籍，所以他会先把几本书放在第一个书架上，下几本书放在下一个书架上，以此类推。当然，他会在每一个架子上放置至少一本书。这样，他会把所有的书放在 $K$ 个书架上，尽量使书架的美观程度越大越好。计算这个最大可能的美丽程度。

## 样例 #1

### 输入

```
10 4
9 14 28 1 7 13 15 29 2 31
```

### 输出

```
24
```

## 样例 #2

### 输入

```
7 3
3 14 15 92 65 35 89
```

### 输出

```
64
```

# AI分析结果

### 题目内容
# 书架

## 题目描述
### 题意：
Keks先生是Byteland大陆典型的白领。
他办公室里有一个书架，上面有几本书，每本书都有一个值为正整数的价格。
Keks先生把书架的价值定义为书价的总和。
出乎意料地是，Keks先生升职了，现在他要去一个新的办公室。
他知道，在新的办公室里，他将有不止一个书架，而恰恰是K个书架。
他认为K个书架的美丽程度在于所有书架的价值的“按位与”和。
他还决定不花时间重新整理书籍，所以他会先把几本书放在第一个书架上，下几本书放在下一个书架上，以此类推。当然，他会在每一个架子上放置至少一本书。这样，他会把所有的书放在K个书架上，尽量使书架的美观程度越大越好。计算这个最大可能的美丽程度。

## 样例 #1
### 输入
```
10 4
9 14 28 1 7 13 15 29 2 31
```
### 输出
```
24
```

## 样例 #2
### 输入
```
7 3
3 14 15 92 65 35 89
```
### 输出
```
64
```

### 综合分析与结论
所有题解都围绕如何使K个书架价值的按位与和最大展开。核心思路是利用按位贪心结合动态规划。因为按位与操作的特性，高位为1的数一定大于高位为0的数，所以从高位到低位贪心选择，每一位通过动态规划验证能否使该位为1。

### 所选的题解
- **作者：Siyuan (5星)**
  - **关键亮点**：思路清晰，对贪心策略的证明明确，代码简洁规范，对动态规划状态定义和转移方程解释详细。
  - **核心代码**：
```cpp
bool check(long long x) {
    memset(f,0,sizeof(f));
    f[0][0]=1;
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=k;++j) {
            for(int k=0;k<i;++k) {
                f[i][j]|=f[k][j-1]&(((a[i]-a[k])&x)==x);
            }
        }
    }
    return f[n][k];
}
int main() {
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;++i) scanf("%lld",&a[i]),a[i]+=a[i-1];
    long long ans=0;
    for(int i=60;i>=0;--i) {
        long long now=ans|(1LL<<i);
        if(check(now)) ans|=(1LL<<i);
    }
    printf("%lld\n",ans);
    return 0;
}
```
  - **核心实现思想**：`check`函数通过动态规划验证当前贪心的答案是否可行，`main`函数从高位到低位枚举，每次调用`check`函数验证并更新答案。

- **作者：Libre_dreagonm (4星)**
  - **关键亮点**：思路表述清晰，对按位贪心和动态规划的结合讲解详细，代码有一定注释，便于理解。
  - **核心代码**：
```cpp
int check(int x){
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i=1;i<=k;i++)
        for(int j=1;j<=n;j++)
            for(int kx=0;kx<j;kx++)
                dp[i][j]|=dp[i-1][kx]&&(((sum[j]-sum[kx])&x)==x);
    return dp[k][n];
}
signed main(){
    scanf("%lld %lld",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+a[i];
    for(int i=60;i>=0;i--){
        int mid=ans|(1LL<<i);
        if(check(mid))
            ans|=(1LL<<i);
    }
    printf("%lld",ans);
    return 0;
}
```
  - **核心实现思想**：`check`函数利用动态规划判断当前贪心的答案是否可行，`main`函数先预处理前缀和，然后从高位到低位枚举验证并更新答案。

- **作者：jch123 (4星)**
  - **关键亮点**：思路简洁明了，代码实现简洁，动态规划的状态转移方程表达清晰。
  - **核心代码**：
```cpp
bool check(ll x)
{
	memset(dp,0,sizeof(dp));
	dp[0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++)
			for(int k=0;k<i;k++)
				dp[i][j]|=dp[k][j-1]&(((s[i]-s[k])&x)==x);
	return dp[n][k]; 
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i],s[i]=s[i-1]+a[i];
	ll ans=0;
	for(ll i=60;i>=0;i--)
	{
		ll x=1ll<<i;
		if(check(ans|x))
			ans|=x;
	}
	cout<<ans;
	return 0;
}
```
  - **核心实现思想**：`check`函数通过动态规划验证贪心答案，`main`函数读入数据并预处理前缀和，从高位到低位枚举验证并更新答案。

### 最优关键思路或技巧
1. **按位贪心**：基于按位与操作，高位为1的数更大，所以从高位到低位贪心选择每一位是否能为1。
2. **动态规划验证**：用动态规划判断当前贪心的答案是否可行，状态定义为前i本书放到j个书架能否得到满足条件的答案，通过状态转移方程进行验证。

### 可拓展之处
同类型题常涉及按位运算与动态规划结合，如一些需要对数字按位处理并划分区间的问题。类似算法套路是遇到按位运算求最值问题，考虑按位贪心，再结合动态规划验证贪心的可行性。

### 洛谷相似题目
1. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)：涉及状态压缩动态规划和按位运算，与本题按位贪心结合动态规划有相似之处。
2. [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：同样是状态压缩动态规划问题，在处理状态和转移时可借鉴本题思路。
3. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)：需要结合状态压缩和动态规划求解，与本题在算法运用上有一定相似性。

### 个人心得摘录
作者Libre_dreagonm提到开始没意识到按位分别计算，想了好久，看题解后才想到。总结出看到按位与统计价值，要有按位分别计算的意识。这表明在遇到按位运算相关题目时，要优先考虑按位处理的思路。 

---
处理用时：31.75秒
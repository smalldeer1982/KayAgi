# 题目信息

# Distance in Tree

## 题目描述

## 题目大意
输入点数为$N$一棵树

求树上长度恰好为$K$的路径个数

## 说明/提示

$1 \leq n \leq 50000$

$1 \leq k \leq 500$

感谢@Zhang_RQ 提供的翻译

## 样例 #1

### 输入

```
5 2
1 2
2 3
3 4
2 5
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 3
1 2
2 3
3 4
4 5
```

### 输出

```
2
```

# AI分析结果



# Distance in Tree

## 题目描述
给定一棵包含$N$个节点的树，求树上长度恰好为$K$的路径数量。

**输入格式**  
第一行包含两个整数$N$和$K$  
接下来$N-1$行每行两个整数表示树的一条边  

**数据范围**  
$1 \leq N \leq 50000$  
$1 \leq K \leq 500$

---

### 综合题解分析
各题解主要围绕树形DP、点分治、长链剖分展开，核心思路均是通过遍历统计距离信息。树形DP利用子树合并策略，时间复杂度$O(nk)$；点分治通过分治统计跨根路径；长链剖分通过指针优化转移，达到线性复杂度。

#### 精选题解（评分≥4星）

1. **Rhodoks的树形DP解法（⭐⭐⭐⭐⭐）**
   - **关键亮点**：代码简洁高效，利用子树合并策略，通过动态规划数组`dp[pos][j]`记录距离当前节点j步的节点数。合并子树时累加答案，避免重复计算。
   - **核心代码**：
     ```cpp
     void dfs(int pos, int f) {
         dp[pos][0] = 1;
         for (each child v of pos) {
             dfs(v, pos);
             for (int j=0; j<k; ++j)
                 ans += dp[v][j] * dp[pos][k-j-1];
             for (int j=0; j<k; ++j)
                 dp[pos][j+1] += dp[v][j];
         }
     }
     ```
   - **实现思想**：每个节点维护距离数组，合并子树时累加满足`j + (k-j-1) + 1 = k`的路径数。

2. **vacation的树形DP解法（⭐⭐⭐⭐）**
   - **关键亮点**：代码极简，直接使用二维数组递推，适合快速实现。
   - **个人心得**：提到"其实就是暴力啦"，强调树形DP的本质是通过合理状态设计将暴力优化为可行解。

3. **MyukiyoMekya的分类讨论解法（⭐⭐⭐⭐）**
   - **关键亮点**：将路径分为单链和拼接链两类，通过公式`ans += f[u][k] + sum{(f[u][k-i] - f[v][k-i-1]) * f[v][i-1]}`避免重复计数。
   - **技巧总结**：通过差值`f[u][k-i] - f[v][k-i-1]`排除同一子树内的非法路径。

---

### 最优思路总结
**树形DP**是最易实现且高效的方法，核心步骤如下：
1. 定义`dp[u][j]`表示以u为根的子树中，距离u为j的节点数。
2. DFS遍历时合并子树信息，累加答案`ans += dp[v][j] * dp[u][k-j-1]`。
3. 更新父节点距离数组`dp[u][j+1] += dp[v][j]`。

**长链剖分**适合更大数据范围，通过指针复用内存，将空间优化至$O(n)$，但实现较复杂。

---

### 相似题目推荐
1. [P3806 【模板】点分治1](https://www.luogu.com.cn/problem/P3806)  
   **考察点**：点分治模板题，统计路径是否存在指定长度。
2. [P2634 [国家集训队] 聪聪可可](https://www.luogu.com.cn/problem/P2634)  
   **考察点**：点分治统计路径模3余数的路径数。
3. [P4149 [IOI2011] Race](https://www.luogu.com.cn/problem/P4149)  
   **考察点**：求边权和为K的最短路径，结合点分治与哈希表。

---

### 关键代码实现（树形DP）
```cpp
void dfs(int now, int p) {
    dp[now][0] = 1;
    for (int to : children[now]) {
        if (to == p) continue;
        dfs(to, now);
        for (int j=0; j<k; ++j)
            ans += dp[to][j] * dp[now][k-j-1];
        for (int j=0; j<k; ++j)
            dp[now][j+1] += dp[to][j];
    }
}
```
**代码说明**：  
- `dp[now][0] = 1`初始化当前节点距离为0的路径数为1。
- 遍历子节点时，先计算跨子树的路径数，再合并子树信息。

---
处理用时：60.82秒
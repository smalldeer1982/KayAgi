# 题目信息

# Creative Snap

## 题目描述

灭霸要摧毁复仇者们的基地！  

我们可以将复仇者的基地看成一个序列，每个位置都有可能有多个复仇者；但是每个复仇者只能占据一个位置。  
他们基地的长度刚好是$2$的整数幂，灭霸想要用最少的能量摧毁它们。他在摧毁过程中，可以选择：  
- 如果这段基地长度$\ge 2$，他可以将其分为相等长度的两半。  
- 烧掉这段基地。如果这段基地中没有复仇者，他需要消耗$A$的能量；如果有，则需要消耗$B*x*l$的能量。其中$l$是这段基地长度，$x$是这段中的复仇者数量。  

输出一个整数，表示他摧毁全部基地需要的最少能量。  
接下来一行$k$个整数，$a_i$表示第$i$个复仇者所在的位置

## 说明/提示

### 样例解释  
对于样例1，直接烧区间$[1,4]$需要能量为$4*2*2=16$。  
但是，如果将其分为$4$段，分别烧掉，所需能量只有$2+1+2+1=6$。  
可以证明没有更优的方案，所以输出`6`。 
对于全部数据：  
$1\le n \le 30$  
$1\le k \le 10^5$  
$1\le A,B \le 10^4$  
$1\le a_i \le 2^n$

## 样例 #1

### 输入

```
2 2 1 2
1 3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3 2 1 2
1 7
```

### 输出

```
8
```

# AI分析结果

### 题目翻译
题目内容已为中文，无需翻译。

### 综合分析与结论
这些题解主要围绕如何计算灭霸摧毁复仇者基地所需的最少能量展开，主要有分治递归和动态开点线段树两种思路。

#### 思路对比
- **分治递归**：大多数题解采用此思路，通过递归函数计算摧毁每个区间所需的最小能量。在递归过程中，利用二分查找计算区间内复仇者的数量，并根据数量和区间长度判断是直接摧毁还是分成两半分别摧毁，同时运用“区间无复仇者则直接返回A”的剪枝优化。
- **动态开点线段树**：通过动态开点线段树维护区间内的人数和价值，将复仇者依次插入线段树，最后根节点的价值即为答案。

#### 算法要点
- **分治递归**：核心是定义递归函数`solve(l, r)`，计算区间`[l, r]`的最小能量，利用二分查找计算区间内复仇者数量，根据数量和区间长度进行决策。
- **动态开点线段树**：每个节点维护区间内的人数和价值，通过`pushup`函数更新节点信息，插入节点时动态开点。

#### 解决难点
- **区间复仇者数量计算**：所有题解都采用二分查找（`lower_bound`和`upper_bound`）来高效计算区间内复仇者的数量。
- **值域过大问题**：分治递归通过剪枝优化，避免不必要的计算；动态开点线段树通过动态开点，避免空间浪费。

### 高评分题解
1. **作者：花里心爱（5星）**
    - **关键亮点**：思路清晰，使用动态开点线段树解决问题，代码注释详细，时间复杂度分析明确。
    - **核心代码**：
```cpp
void pushup(int cur, int len) {
    c[cur] = c[ls[cur]] + c[rs[cur]];
    d[cur] = std::min(B*c[cur]*len, d[ls[cur]] + d[rs[cur]]);
}

void ins(int& cur, int l, int r, int pos) {
    if(!cur) cur = ++cnt;
    if(l == r) {
        ++c[cur];
        d[cur] = B*c[cur];
        return;
    }
    int mid = (l+r)>>1;
    if(mid >= pos) ins(ls[cur], l, mid, pos);
    else ins(rs[cur], mid+1, r, pos);
    pushup(cur, r-l+1);
}
```
核心实现思想：`pushup`函数用于更新节点的人数和价值，`ins`函数用于插入节点，动态开点并递归更新子节点信息。

2. **作者：GKxx（4星）**
    - **关键亮点**：代码简洁，按照题意模拟，使用剪枝优化，提高了效率。
    - **核心代码**：
```cpp
inline LL count(int l, int r) {
    int pr = std::upper_bound(a + 1, a + K + 1, r) - a;
    --pr;
    int pl = std::upper_bound(a + 1, a + K + 1, l - 1) - a;
    --pl;
    return pr - pl;
}

LL solve(int l, int r) {
    int cnt = count(l, r);
    if (!cnt) return A;
    if (l == r) return B * cnt;
    int mid = (l + r) >> 1;
    return std::min(1ll * cnt * B * (r - l + 1), solve(l, mid) + solve(mid + 1, r));
}
```
核心实现思想：`count`函数用于计算区间内复仇者的数量，`solve`函数递归计算区间的最小能量，根据数量和区间长度进行决策。

3. **作者：Engulf（4星）**
    - **关键亮点**：思路明确，使用分治算法，代码实现简洁，对剪枝优化有清晰的说明。
    - **核心代码**：
```cpp
int so1ve(int l, int r)
{
    int avengers = upper_bound(a + 1, a + k + 1, r) - lower_bound(a + 1, a + k + 1, l);
    if (!avengers) return A;
    if (l == r) return B * avengers;
    int mid = l + r >> 1;
    int split = so1ve(l, mid) + so1ve(mid + 1, r);
    return min(split, B * avengers * (r - l + 1));
}
```
核心实现思想：`so1ve`函数递归计算区间的最小能量，通过二分查找计算区间内复仇者的数量，根据数量和区间长度进行决策。

### 最优关键思路或技巧
- **分治递归**：通过递归将大区间分解为小区间，利用二分查找计算区间内复仇者的数量，根据数量和区间长度进行决策，同时运用剪枝优化，避免不必要的计算。
- **动态开点线段树**：对于值域较大的问题，使用动态开点线段树可以避免空间浪费，通过动态开点和`pushup`函数维护节点信息。

### 拓展思路
同类型题或类似算法套路：
- 区间划分问题：如区间合并、区间分割等，可使用分治算法解决。
- 线段树应用：对于需要维护区间信息的问题，可考虑使用线段树，若值域较大，可使用动态开点线段树。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P1047 [NOIP2005 普及组] 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1198 [JSOI2008] 最大数](https://www.luogu.com.cn/problem/P1198)

### 个人心得摘录与总结
- **作者：NaCly_Fish**：尝试使用树状数组+map维护区间复仇者数量，结果超时。官方题解使用排序和二分查找解决该问题，提醒我们在处理区间求和问题时，要根据数据范围选择合适的数据结构和算法。

---
处理用时：34.59秒
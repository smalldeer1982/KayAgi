# 题目信息

# Lizards and Basements 2

## 题目描述

有一队人，第 $i$ 个人的血量为 $h_{i}$，你可以用火球点某个人，会对当前的人造成 $a$ 点伤害，对旁边的人造成 $b$ 点伤害。

火球不能打 $1$ 号和 $n$ 号，求最少多少发火球烧死所有人。血量为负数才算死。

## 样例 #1

### 输入

```
3 2 1
2 2 2
```

### 输出

```
3
2 2 2 ```

## 样例 #2

### 输入

```
4 3 1
1 4 1 1
```

### 输出

```
4
2 2 3 3 ```

# AI分析结果

### 题目翻译
#### Lizards and Basements 2
有一队人，第 $i$ 个人的血量为 $h_{i}$，你可以用火球攻击某个人，这会对当前的人造成 $a$ 点伤害，对其旁边的人造成 $b$ 点伤害。

火球不能攻击第 $1$ 号和第 $n$ 号人，求最少需要多少发火球才能将所有人击败。注意，只有当一个人的血量变为负数时，才认为他被击败。

#### 样例 #1
##### 输入
```
3 2 1
2 2 2
```
##### 输出
```
3
2 2 2 
```

#### 样例 #2
##### 输入
```
4 3 1
1 4 1 1
```
##### 输出
```
4
2 2 3 3 
```

### 综合分析与结论
这些题解主要围绕两种思路展开：动态规划（DP）和深度优先搜索（DFS）。

#### 动态规划思路
- **状态定义**：多数使用三维状态 $dp[i][j][k]$ 表示前 $i - 1$ 个人已死亡，第 $i - 1$ 个人被攻击 $j$ 次，第 $i$ 个人被攻击 $k$ 次时的最小火球使用数。
- **转移方程**：枚举第 $i + 1$ 个人被攻击的次数 $l$，满足一定伤害条件后更新状态。
- **难点**：最后一个人的状态处理较复杂，需单独枚举并计算补刀次数。

#### 深度优先搜索思路
- **搜索策略**：从第 $2$ 个人开始，枚举对每个人的攻击次数，保证在枚举第 $i$ 个人时能打死第 $i - 1$ 个人。
- **剪枝优化**：若当前使用的火球数已超过当前最优解，则停止搜索。
- **难点**：未优化时时间复杂度高，需合理剪枝以避免超时。

### 高评分题解
- **kczno1（5星）**
    - **关键亮点**：思路清晰，代码规范，使用后缀 $min$ 优化转移，将时间复杂度从 $O(n*u^3)$ 优化到 $O(n*u^2)$。
    - **核心代码**：
```cpp
const int N=10+2,U=15+2;
int dp[N][U][U],mn[N][U][U],need[U];
int n,a,b,h[N];
//...
per(i,n,1)
{
    if(i<n)
    {
        rep(j,0,U-1)
        {
            int v=h[i]-j*b;
            rep(k,0,U-1)
            {
                dp[i][j][k]=k+mn[i+1][k][v<0?0:need[v]];
                v-=a;
            }
        }
    }
    rep(j,0,U-1)
    {
        mn[i][j][U-1]=dp[i][j][U-1];
        per(k,U-2,0)mn[i][j][k]=min(mn[i][j][k+1],dp[i][j][k]);
    }
}
```
- **小闸蟹（4星）**
    - **关键亮点**：思路简单直接，使用 DFS 结合剪枝，代码可读性高。
    - **核心代码**：
```cpp
void DFS(int Now, int Sum)
{
    if (Sum >= Ans) return;
    if (Now == n - 1)
    {
        if (h[n - 1] < 0)
        {
            Ans = Sum;
            Vec = Temp;
        }
        return;
    }
    for (int i = 0; i <= std::max({ (h[Now - 1] / b), (h[Now] / a), (h[Now + 1] / b) }) + 1; ++i)
    {
        if (h[Now - 1] - b * i < 0)
        {
            h[Now - 1] -= b * i;
            h[Now] -= a * i;
            h[Now + 1] -= b * i;
            for (int t = 0; t < i; ++t)
            {
                Temp.push_back(Now + 1);
            }
            DFS(Now + 1, Sum + i);
            h[Now - 1] += b * i;
            h[Now] += a * i;
            h[Now + 1] += b * i;
            for (int t = 0; t < i; ++t)
            {
                Temp.pop_back();
            }
        }
    }
}
```
- **Fading（4星）**
    - **关键亮点**：详细阐述了 DP 状态的思考过程，代码中记录转移位置方便输出方案。
    - **核心代码**：
```cpp
ll f[22][201][201],g[22][201][201][2],n,a,b;
//...
for (int i=2;i<=n-1;i++){
    for (int j=0;j<=(i==2?0:16);j++){
        for (int k=0;k<=16;k++){
            if (f[i][j][k]>=0x3f3f3f3f-200) continue;
            ll rem=(x[i]-j*b-k*a)>=0?(x[i]-j*b-k*a)/b+1:0;
            for (int l=max(0LL,rem);l<=16;l++){
                if (l+f[i][j][k]<f[i+1][k][l]){
                    f[i+1][k][l]=l+f[i][j][k];
                    g[i+1][k][l][0]=j,g[i+1][k][l][1]=k;
                }
            }
        }
    }
}
```

### 最优关键思路或技巧
- **动态规划**：使用三维状态记录信息，通过枚举下一个状态进行转移，并利用后缀 $min$ 优化转移过程，降低时间复杂度。
- **深度优先搜索**：合理剪枝，如当当前使用的火球数超过最优解时停止搜索，以及在枚举攻击次数时确定合理的上限。

### 拓展思路
此类问题属于状态规划与搜索类问题，同类型题可能会改变攻击规则、增加攻击目标的属性或改变地图结构等。解题时可根据具体情况调整状态定义和搜索策略。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：基础的动态规划问题，可练习状态定义和转移方程的推导。
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：同样是动态规划问题，有助于加深对状态转移的理解。
- [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)：经典的深度优先搜索问题，可练习搜索和剪枝技巧。

### 个人心得摘录与总结
- **Fading**：最初的 DP 状态设计无法处理某些情况，经过多次尝试后才找到合适的状态定义，提醒在 DP 解题时要充分考虑各种情况，灵活调整状态。
- **Nwayy**：一维 DFS 容易死循环且复杂度高，二维 DFS 仍超时，最终通过优化判断条件避免了每次遍历数组，提高了效率，说明在搜索问题中合理的剪枝和优化判断条件很重要。 

---
处理用时：42.47秒
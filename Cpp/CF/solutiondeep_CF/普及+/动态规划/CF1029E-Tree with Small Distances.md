# 题目信息

# Tree with Small Distances

## 题目描述

给定一颗有根树（根节点为 $1$）。要求往树中加入一些边使得从根节点到其他节点的距离至多是 $2$。 求加入边的最小数量。(边全部都是无向的)

## 说明/提示

$2 \le n \le 2\times 10^5$

## 样例 #1

### 输入

```
7
1 2
2 3
2 4
4 5
4 6
5 7
```

### 输出

```
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
1 7
```

### 输出

```
0
```

## 样例 #3

### 输入

```
7
1 2
2 3
3 4
3 5
3 6
3 7
```

### 输出

```
1
```

# AI分析结果

### 题目内容重写（中文）

**题目描述**

给定一颗有根树（根节点为 $1$）。要求往树中加入一些边使得从根节点到其他节点的距离至多是 $2$。求加入边的最小数量。（边全部都是无向的）

**说明/提示**

$2 \le n \le 2\times 10^5$

**样例 #1**

**输入**

```
7
1 2
2 3
2 4
4 5
4 6
5 7
```

**输出**

```
2
```

**样例 #2**

**输入**

```
7
1 2
1 3
2 4
2 5
3 6
1 7
```

**输出**

```
0
```

**样例 #3**

**输入**

```
7
1 2
2 3
3 4
3 5
3 6
3 7
```

**输出**

```
1
```

---

### 题解综合分析

本题的核心目标是通过添加最少的边，使得从根节点到其他所有节点的距离不超过2。大多数题解采用了贪心算法，通过优先处理深度最大的节点，并连接其父节点与根节点，从而覆盖更多的节点。部分题解还使用了动态规划（DP）来解决，但贪心算法在时间和空间复杂度上更具优势。

### 精选题解

#### 1. 作者：leozhang (★★★★★)
**关键亮点**：
- 使用贪心算法，优先处理深度最大的节点，连接其父节点与根节点。
- 通过BFS遍历树，计算每个节点的深度，并按深度排序。
- 代码简洁高效，时间复杂度为O(n)。

**核心代码**：
```cpp
void bfs(int rt) {
    queue<int> M;
    p[rt].dep = 0;
    p[rt].num = rt;
    M.push(rt);
    while (!M.empty()) {
        int u = M.front();
        M.pop();
        for (int i = head[u]; i != -1; i = edge[i].next) {
            int to = edge[i].to;
            if (p[to].dep) continue;
            p[to].dep = p[u].dep + 1;
            p[to].num = to;
            f[to] = u;
            M.push(to);
            if (p[to].dep <= 2) used[to] = 1;
        }
    }
}
```

#### 2. 作者：Bring (★★★★★)
**关键亮点**：
- 使用BFS遍历树，记录深度大于2的节点，并按深度排序。
- 通过倒序遍历BFS序，优先处理深度最大的节点，连接其父节点与根节点。
- 优化了时间复杂度，避免了堆的使用，时间复杂度为O(n)。

**核心代码**：
```cpp
void dfs(int u) {
    if (d[u] > 2) q.push(u);
    for (int i : e[u]) if (i != f[u]) f[i] = u, d[i] = d[u] + 1, dfs(i);
}
```

#### 3. 作者：FL_sleake (★★★★☆)
**关键亮点**：
- 使用拓扑排序处理深度最大的节点，优先连接其父节点与根节点。
- 通过DFS计算每个节点的深度，并按深度排序。
- 代码实现较为简洁，时间复杂度为O(n)。

**核心代码**：
```cpp
void dfs(int u, int Fa) {
    fa[u] = Fa;
    for (int v : G[u]) if (v != Fa) dfs(v, u);
}
```

### 最优关键思路与技巧

1. **贪心算法**：优先处理深度最大的节点，连接其父节点与根节点，从而覆盖更多的节点。
2. **BFS遍历**：通过BFS遍历树，计算每个节点的深度，并按深度排序，优化了时间复杂度。
3. **拓扑排序**：使用拓扑排序处理深度最大的节点，避免了堆的使用，进一步优化了时间复杂度。

### 可拓展之处

- **类似问题**：可以考虑在树中添加边，使得某些特定节点之间的距离不超过某个值。
- **算法套路**：贪心算法在处理树的最优化问题时非常有效，尤其是在需要覆盖或连接多个节点的情况下。

### 推荐题目

1. **洛谷P1352**：没有上司的舞会
2. **洛谷P1040**：加分二叉树
3. **洛谷P2014**：选课

### 个人心得摘录

- **调试经历**：部分题解提到在比赛时使用了Dijkstra算法，但未能通过测试，最终通过BFS优化解决了问题。
- **踩坑教训**：贪心算法的正确性需要仔细证明，尤其是在处理树的最优化问题时，贪心策略的合理性至关重要。
- **顿悟感想**：通过优先处理深度最大的节点，可以有效地覆盖更多的节点，从而减少添加边的数量。

---
处理用时：41.01秒
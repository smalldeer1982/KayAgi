# 题目信息

# Array Without Local Maximums

## 题目描述

$Ivan$偶然发现一个旧的生日礼物。礼物是一个含有$n$个元素的数组，每个元素都介于$1$和$200$之间。但是现在数组已经很旧了，有的数字难以看清。他记得对于所有元素，它的相邻元素中至少有一个不小于它。也就是说：

$a_1\le a_2,a_n\le a_{n-1}$且$a_i\le \max \left( a_{i-1},a_{i+1} \right) $对于任意$i\in \left[ 2,n-1 \right] $都成立。

$Ivan$想知道有多少种方案能够还原这个数组。当然，还原后要保证每个元素仍然介于$1$和$200$之间。输出方案数对$998244353$取模的结果。

## 说明/提示

第一个样例，$a_2$只能为$2$。

第二个样例，$a_1=a_2$，所以有$200$中可能。

## 样例 #1

### 输入

```
3
1 -1 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2
-1 -1
```

### 输出

```
200
```

# AI分析结果

### 题目内容重写（中文）

**题目描述**

$Ivan$偶然发现一个旧的生日礼物。礼物是一个含有$n$个元素的数组，每个元素都介于$1$和$200$之间。但是现在数组已经很旧了，有的数字难以看清。他记得对于所有元素，它的相邻元素中至少有一个不小于它。也就是说：

$a_1\le a_2,a_n\le a_{n-1}$且$a_i\le \max \left( a_{i-1},a_{i+1} \right) $对于任意$i\in \left[ 2,n-1 \right] $都成立。

$Ivan$想知道有多少种方案能够还原这个数组。当然，还原后要保证每个元素仍然介于$1$和$200$之间。输出方案数对$998244353$取模的结果。

**说明/提示**

第一个样例，$a_2$只能为$2$。

第二个样例，$a_1=a_2$，所以有$200$中可能。

**样例 #1**

### 输入

```
3
1 -1 2
```

### 输出

```
1
```

**样例 #2**

### 输入

```
2
-1 -1
```

### 输出

```
200
```

---

### 题解综合分析与结论

该题目要求计算满足特定条件的数组还原方案数，主要考察动态规划（DP）的应用。各题解的核心思路是通过定义状态$f[i][j][k]$，表示第$i$个元素为$j$时，与前一个元素的关系为$k$（小于、等于、大于）的方案数，并通过前缀和优化来降低时间复杂度。

### 精选题解

#### 题解1：作者：quantum11 (赞：15)
**星级：★★★★★**
**关键亮点：**
- 使用滚动数组优化空间复杂度。
- 通过前缀和优化转移方程，时间复杂度降低到$O(n)$。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i=2;i<=n;k^=1,++i){
    s=0;
    for(int j=1;j<=200;++j){
        f[k^1][j][0]=(a[i]==-1||a[i]==j)?s:0;
        (s+=f[k][j][0]+f[k][j][1]+f[k][j][2])%=mo;
    }
    for(int j=1;j<=200;++j)
    f[k^1][j][1]=(a[i]==-1||a[i]==j)?(f[k][j][0]+f[k][j][1]+f[k][j][2])%mo:0;
    s=0;
    for(int j=200;j;--j){
        f[k^1][j][2]=(a[i]==-1||a[i]==j)?s:0;
        (s+=f[k][j][1]+f[k][j][2])%=mo;
    }
}
```
**核心思想：**
通过滚动数组和前缀和优化，动态规划的状态转移方程得以高效实现。

#### 题解2：作者：K8He (赞：13)
**星级：★★★★☆**
**关键亮点：**
- 详细解释了状态定义和转移方程，适合初学者理解。
- 使用前缀和优化，代码结构清晰。
- 提供了详细的初始化说明。

**核心代码：**
```cpp
_for(i,2,n){
    int s=0;
    _for(j,1,200){
        if(a[i]==-1||a[i]==j)f[i][j][0]=s%M,f[i][j][1]=(f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2])%M;
        s=(s+f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2])%M;
    }s=0;
    for_(j,200,1){
        if(a[i]==-1||a[i]==j)f[i][j][2]=s%M;
        s=(s+f[i-1][j][1]+f[i-1][j][2])%M;
    }
}
```
**核心思想：**
通过前缀和优化，减少了状态转移的时间复杂度，代码结构清晰，适合初学者。

#### 题解3：作者：Fido_Puppy (赞：5)
**星级：★★★★☆**
**关键亮点：**
- 详细解释了状态转移方程，适合深入理解。
- 使用前缀和优化，代码结构清晰。
- 提供了详细的边界条件说明。

**核心代码：**
```cpp
for(int i=2;i<=n;i++){
    if(a[i]!=-1){
        if(a[i-1]!=-1){
            if(a[i]>a[i-1]) f[i][a[i]][0]=(f[i][a[i]][0]+((f[i-1][a[i-1]][1]+f[i-1][a[i-1]][2])%mod+f[i-1][a[i-1]][0])%mod)%mod;
            else if(a[i]==a[i-1]) f[i][a[i]][1]=(f[i][a[i]][1]+((f[i-1][a[i-1]][1]+f[i-1][a[i-1]][2])%mod+f[i-1][a[i-1]][0])%mod)%mod;
            else f[i][a[i]][2]=(f[i][a[i]][2]+(f[i-1][a[i-1]][1]+f[i-1][a[i-1]][2])%mod)%mod;
        } else {
            f[i][a[i]][0]=(f[i][a[i]][0]+sum[a[i]-1])%mod;
            f[i][a[i]][1]=(f[i][a[i]][1]+((f[i-1][a[i]][1]+f[i-1][a[i]][0])%mod+f[i-1][a[i]][2])%mod)%mod;
            f[i][a[i]][2]=(f[i][a[i]][2]+((sum[200]-sum[a[i]])%mod+mod)%mod-((ze[200]-ze[a[i]])%mod+mod)%mod+mod)%mod;
        }
    } else {
        if(a[i-1]!=-1){
            _for(j,1,200){
                if(j>a[i-1]) f[i][j][0]=(f[i][j][0]+((f[i-1][a[i-1]][0]+f[i-1][a[i-1]][1])%mod+f[i-1][a[i-1]][2])%mod)%mod;
                else if(j==a[i-1]) f[i][j][1]=(f[i][j][1]+((f[i-1][a[i-1]][0]+f[i-1][a[i-1]][1])%mod+f[i-1][a[i-1]][2])%mod)%mod;
                else f[i][j][2]=(f[i][j][2]+(f[i-1][a[i-1]][1]+f[i-1][a[i-1]][2])%mod)%mod;
            }
        } else {
            _for(j,1,200){
                f[i][j][0]=(f[i][j][0]+sum[j-1])%mod;
                f[i][j][1]=(f[i][j][1]+(f[i-1][j][1]+f[i-1][j][0])%mod+f[i-1][j][2])%mod;
                f[i][j][2]=(f[i][j][2]+(((sum[200]-sum[j])%mod+mod)%mod-((ze[200]-ze[j])%mod+mod)%mod)+mod)%mod;
            }
        }
    }
    _for(j,1,200) sum[j]=(sum[j-1]+((f[i][j][1]+f[i][j][0])%mod+f[i][j][2])%mod)%mod,ze[j]=(ze[j-1]+f[i][j][0])%mod;
}
```
**核心思想：**
通过前缀和优化，减少了状态转移的时间复杂度，代码结构清晰，适合深入理解。

### 最优关键思路或技巧
1. **状态定义**：定义$f[i][j][k]$表示第$i$个元素为$j$时，与前一个元素的关系为$k$（小于、等于、大于）的方案数。
2. **前缀和优化**：通过前缀和优化，将状态转移的时间复杂度从$O(n^2)$降低到$O(n)$。
3. **滚动数组**：使用滚动数组优化空间复杂度，减少内存使用。

### 可拓展之处
该题的动态规划思路可以拓展到其他类似的计数问题，尤其是涉及到相邻元素关系的题目。例如，可以应用于计算满足特定条件的排列数、组合数等问题。

### 推荐题目
1. [CF1067A Array Without Local Maximums](https://www.luogu.com.cn/problem/CF1067A)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

### 个人心得总结
- **调试经历**：在实现动态规划时，初始化条件和边界条件的处理非常重要，稍有不慎就会导致错误结果。
- **踩坑教训**：在使用前缀和优化时，要注意前缀和的计算顺序，避免重复计算或遗漏。
- **顿悟感想**：通过滚动数组和前缀和优化，可以显著提高动态规划的效率，尤其是在处理大规模数据时。

---
处理用时：76.45秒
# 题目信息

# Infinite Set

## 题目描述

You are given an array $ a $ consisting of $ n $ distinct positive integers.

Let's consider an infinite integer set $ S $ which contains all integers $ x $ that satisfy at least one of the following conditions:

1. $ x = a_i $ for some $ 1 \leq i \leq n $ .
2. $ x = 2y + 1 $ and $ y $ is in $ S $ .
3. $ x = 4y $ and $ y $ is in $ S $ .

For example, if $ a = [1,2] $ then the $ 10 $ smallest elements in $ S $ will be $ \{1,2,3,4,5,7,8,9,11,12\} $ .

Find the number of elements in $ S $ that are strictly smaller than $ 2^p $ . Since this number may be too large, print it modulo $ 10^9 + 7 $ .

## 说明/提示

In the first example, the elements smaller than $ 2^4 $ are $ \{1, 3, 4, 6, 7, 9, 12, 13, 15\} $ .

In the second example, the elements smaller than $ 2^7 $ are $ \{5,11,20,23,39,41,44,47,79,80,83,89,92,95\} $ .

## 样例 #1

### 输入

```
2 4
6 1```

### 输出

```
9```

## 样例 #2

### 输入

```
4 7
20 39 5 200```

### 输出

```
14```

## 样例 #3

### 输入

```
2 200000
48763 1000000000```

### 输出

```
448201910```

# AI分析结果

### 题目内容重写

**无限集合**

**题目描述**

给定一个由 $n$ 个互不相同的正整数组成的数组 $a$。

考虑一个无限整数集合 $S$，它包含所有满足以下至少一个条件的整数 $x$：

1. $x = a_i$，其中 $1 \leq i \leq n$。
2. $x = 2y + 1$，且 $y$ 在 $S$ 中。
3. $x = 4y$，且 $y$ 在 $S$ 中。

例如，如果 $a = [1,2]$，那么 $S$ 中最小的 10 个元素为 $ \{1,2,3,4,5,7,8,9,11,12\} $。

求集合 $S$ 中严格小于 $2^p$ 的元素个数。由于这个数可能很大，输出其对 $10^9 + 7$ 取模的结果。

**说明/提示**

在第一个样例中，小于 $2^4$ 的元素为 $ \{1, 3, 4, 6, 7, 9, 12, 13, 15\} $。

在第二个样例中，小于 $2^7$ 的元素为 $ \{5,11,20,23,39,41,44,47,79,80,83,89,92,95\} $。

**样例 #1**

**输入**

```
2 4
6 1
```

**输出**

```
9
```

**样例 #2**

**输入**

```
4 7
20 39 5 200
```

**输出**

```
14
```

**样例 #3**

**输入**

```
2 200000
48763 1000000000
```

**输出**

```
448201910
```

---

### 题解综合分析与结论

本题的核心在于理解集合 $S$ 的生成规则，并通过二进制操作来优化计算。大多数题解都采用了以下思路：

1. **二进制视角**：将问题转化为二进制操作，$2x+1$ 相当于在二进制末尾添加一个 $1$，$4x$ 相当于在二进制末尾添加两个 $0$。
2. **斐波那契数列**：通过递推公式 $f_i = f_{i-1} + f_{i-2}$ 来计算每个数的扩展方案数。
3. **去重处理**：通过逆向操作（删除末尾的 $1$ 或 $00$）来判断一个数是否应该被剔除，避免重复计算。

### 评分较高的题解

#### 题解1：作者：NXYorz (赞：13)  
**星级：4.5**  
**关键亮点**：  
- 清晰地解释了二进制操作与斐波那契数列的关系。
- 提供了详细的去重处理方法，确保不重复计算。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
bool check(int x) {
    while(x) {
        if(v[x]) return false;
        if(x & 1) x >>= 1;
        else if(x & 2) break;
        else x >>= 2;
    }
    return true;
}
```
**实现思想**：通过不断删除末尾的 $1$ 或 $00$，检查是否已经存在该数，避免重复计算。

#### 题解2：作者：CSP_Sept (赞：9)  
**星级：4**  
**关键亮点**：  
- 详细讨论了多个数的重复问题，并提出了有效的去重策略。
- 通过排序和哈希表优化了去重过程。
- 提供了完整的递推公式和前缀和计算方法。

**核心代码**：
```cpp
bool check(int x){
    while(x){
        if(x & 1) x >>= 1;
        else if(((x >> 1) & 1) == 0) x >>= 2;
        else break;
        if(binary_search(v.begin(), v.end(), x)) return 0;
    }
    return 1;
}
```
**实现思想**：通过删除末尾的 $1$ 或 $00$，检查是否已经存在该数，确保不重复计算。

#### 题解3：作者：Cat_shao (赞：2)  
**星级：4**  
**关键亮点**：  
- 简洁明了地解释了二进制操作与斐波那契数列的关系。
- 提供了有效的去重处理方法，确保不重复计算。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
bool ck(int x){
    while(x){
        if(mp[x])return 0;
        if(x&1)x>>=1;
        else if(x&2)return 1;
        else x>>=2;
    }
    return 1;
}
```
**实现思想**：通过删除末尾的 $1$ 或 $00$，检查是否已经存在该数，避免重复计算。

### 最优关键思路或技巧

1. **二进制操作**：将 $2x+1$ 和 $4x$ 转化为二进制末尾添加 $1$ 和 $00$，简化了问题的处理。
2. **斐波那契数列**：通过递推公式 $f_i = f_{i-1} + f_{i-2}$ 计算每个数的扩展方案数。
3. **去重处理**：通过逆向操作（删除末尾的 $1$ 或 $00$）来判断一个数是否应该被剔除，确保不重复计算。

### 可拓展之处

类似的问题可以通过二进制操作和递推公式来解决，特别是涉及到数的扩展和去重的情况。例如，可以通过类似的方法处理其他类型的数集生成规则。

### 推荐题目

1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)：考察递推和组合数学。
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：涉及数的生成规则和递推。
3. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)：涉及状态转移和递推。

### 个人心得总结

在调试过程中，去重处理是一个关键点，确保不重复计算需要仔细检查每个数的生成路径。通过逆向操作（删除末尾的 $1$ 或 $00$）可以有效地判断一个数是否应该被剔除，避免重复计算。

---
处理用时：56.72秒
# 题目信息

# Feed Cats

## 题目描述

你在玩一个游戏，这个游戏有 $n$ 步。你有 $m$ 只猫，每只猫有特定的饲养时间 $[l_i,r_i]$。如果你在第 $x$ 步决定饲养，那么所有满足 $l_i\le x\le r_i$ 的猫都会被饲养；或者你不决定饲养，那么无事发生。但是如果一只猫被饲养了两次及以上，它就会死亡。请问在没有猫死亡的情况下，最多有多少只猫被饲养了至少一次？

## 样例 #1

### 输入

```
3
15 6
2 10
3 5
2 4
7 7
8 12
11 11
1000 1
1 1000
5 10
1 2
3 4
3 4
3 4
3 4
1 1
1 2
3 3
3 4
3 4```

### 输出

```
5
1
10```

# AI分析结果

### 题目内容重写

#### 题目描述

你在玩一个游戏，这个游戏有 $n$ 步。你有 $m$ 只猫，每只猫有特定的饲养时间 $[l_i,r_i]$。如果你在第 $x$ 步决定饲养，那么所有满足 $l_i\le x\le r_i$ 的猫都会被饲养；或者你不决定饲养，那么无事发生。但是如果一只猫被饲养了两次及以上，它就会死亡。请问在没有猫死亡的情况下，最多有多少只猫被饲养了至少一次？

#### 样例 #1

##### 输入

```
3
15 6
2 10
3 5
2 4
7 7
8 12
11 11
1000 1
1 1000
5 10
1 2
3 4
3 4
3 4
3 4
1 1
1 2
3 3
3 4
3 4
```

##### 输出

```
5
1
10
```

### 题解分析与结论

本题的核心在于如何在给定的时间步长内，选择合适的时间点进行饲养，使得每只猫最多被饲养一次，且被饲养的猫的数量最大化。题解中主要采用了动态规划（DP）的思路，结合差分数组和线段树等数据结构来优化时间复杂度。

#### 最优关键思路与技巧

1. **动态规划（DP）**：通过定义状态 $f_i$ 表示在前 $i$ 步内最多能饲养的猫的数量，结合转移方程进行求解。
2. **差分数组**：用于快速计算每个时间点被多少只猫覆盖，从而优化 $cnt_i$ 的计算。
3. **线段树**：用于维护每个时间点的最小左端点，从而优化 $L_i$ 的查询。

#### 可拓展之处

- **类似问题**：可以扩展到其他区间覆盖问题，如选择最少的点覆盖所有区间，或选择最多的不重叠区间等。
- **数据结构优化**：在类似的区间问题中，线段树、树状数组等数据结构可以用于优化查询和更新操作。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 精选题解

#### 题解1：作者：GGapa (赞：5)

**星级**：★★★★★

**关键亮点**：
- 使用动态规划结合差分数组，时间复杂度为 $O(n)$，代码简洁高效。
- 通过预处理数组 $S(i)$ 和 $mx(i)$，避免了复杂的查询操作。

**核心代码**：
```cpp
void solve() {
    int n, m; cin >> n >> m;
    vector<VI> A(n + 1) ;
    vector<int> mx(n + 1), S(n + 2);
    for(int i = 1, x, y; i <= m; i++) {
        cin >> x >> y;
        mx[x] = max(mx[x], y);
        S[x]++; S[y + 1]--;
    }
    rep(i, 1, n) S[i] += S[i - 1], mx[i] = max(mx[i], mx[i - 1]); 
    vector<int> F(n + 1);
    rep(i, 1, n) {
        F[i] = max(F[i], F[i - 1]);
        F[mx[i]] = max(F[mx[i]], F[i - 1] + S[i]);
    }
    cout << F[n] << '\n';
}
```

#### 题解2：作者：信息向阳花木 (赞：5)

**星级**：★★★★★

**关键亮点**：
- 使用动态规划结合二分查找，时间复杂度为 $O(n \log n)$，适合处理较大数据范围。
- 通过预处理后缀最小值和差分数组，优化了查询和更新操作。

**核心代码**：
```cpp
int main() {
    scanf("%d", &t);
    while (t -- ) {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i ++ ) b[i] = f[i] = 0;
        for (int i = 1; i <= m; i ++ )
            scanf("%d%d", &a[i].x, &a[i].y);
        sort(a + 1, a + m + 1, cmp); // 按右端点从小到大排序
        minn[m + 1] = 0x3f3f3f3f;
        for (int i = m; i >= 1; i -- ) {
            minn[i] = min(minn[i + 1], a[i].x); // 后缀最小值
            ed[i] = a[i].y; // 从小到大的右端点值
        }
        for (int i = 1; i <= m; i ++ ) {
            int l = a[i].x, r = a[i].y;
            b[l] ++; b[r + 1] --;
        }
        for (int i = 1; i <= n; i ++ ) b[i] += b[i - 1]; // 差分求点 i 被几条线段覆盖
        for (int i = 1; i <= n; i ++ ) {
            int p = lower_bound(ed + 1, ed + m + 1, i) - ed, l = i;
            // p 是第一个右端点大于等于 i 的线段编号，可能覆盖 i 的线段最小左端点是 minn[p]
            if(ed[p] >= i && minn[p] <= i) l = minn[p];
            f[i] = max(f[i - 1], b[i] + f[l - 1]);
        }
        printf("%d\n", f[n]);
    }
    return 0;
}
```

#### 题解3：作者：H2ptimize (赞：2)

**星级**：★★★★

**关键亮点**：
- 使用动态规划结合双指针和差分数组，时间复杂度为 $O(n)$，代码简洁。
- 通过双指针维护最小左端点，优化了查询操作。

**核心代码**：
```cpp
int main() {
    ios::sync_with_stdio(false);
    cin >> t;
    while(t--) {
        cin >> n >> m;
        for(int i = 0; i <= n + 5; i++) dp[i][0] = dp[i][1] = diff[i] = 0;
        for(int i = 1; i <= m; i++) cin >> cat[i].first >> cat[i].second;
        sort(cat + 1, cat + m + 1);
        for(int i = 1; i <= m; i++) {
            diff[cat[i].first]++;
            diff[cat[i].second + 1]--;
        }
        int j = 1;
        for(int i = 1; i <= n; i++) {
            if(i < cat[j].first) lp[i] = i;
            if(cat[j].first <= i && i <= cat[j].second) lp[i] = cat[j].first;
            while(cat[j].second < i && j <= m) j++;
            if(j > m) lp[i] = i;
            else lp[i] = cat[j].first;
        }
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            cnt += diff[i];
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[lp[i]][0] + cnt;
        }
        cout << max(dp[n][0], dp[n][1]) << '\n';
    }
    return 0;
}
```

### 个人心得总结

- **调试经历**：在处理差分数组时，需要注意边界条件的处理，避免数组越界。
- **踩坑教训**：在使用线段树时，初始化时要确保所有节点的值正确，避免因未初始化导致的错误。
- **顿悟感想**：动态规划结合数据结构的优化，可以大幅提升算法的效率，尤其是在处理区间问题时。

---
处理用时：62.59秒
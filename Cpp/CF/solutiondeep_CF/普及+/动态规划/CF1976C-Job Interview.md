# 题目信息

# Job Interview

## 题目描述

### 题意翻译
Monocarp 要开设一家 IT 公司。他想招聘 $n$ 名程序员和 $m$ 名测试员。

共有 $n+m+1$ 名候选人，第 $i$ 个人的到达时间为 $i$。

第 $i$ 名候选人的编程技能为 $a_i$ ，测试技能为 $b_i$ （保证 $a_i\not=b_i$）。

公司的能力定义为所有程序员的编程能力与所有测试员的测试能力之和。

形式化的讲，若招聘的程序员集合为 $s$，测试员集合为 $t$，则公司的能力为 $\sum\limits_{i\in s}a_i+\sum\limits_{j\in t}b_j$。

Monocarp 会按照候选人到达的时间顺序为他们分配工作。

对于第 $i$ 个人，招聘规则为：
1. 尝试将 $i$ 分配到最适合 $i$ 的职位，也就是若 $a_i>b_i$，则让他成为程序员，反之同理。
2. 如果该职位已经招满了，就把 $i$ 分配到另一职位上。

你的任务是，对于每个 $i$，输出若这个人不来的情况下，公司的能力值。

## 样例 #1

### 输入

```
4
1 0
2 1
1 2
0 2
4 5 5
5 4 1
1 2
2 1 5 4
5 2 3 1
3 1
4 3 3 4 1
5 5 4 5 2```

### 输出

```
1 2 
5 6 9 
8 11 11 12 
13 13 13 12 15```

# AI分析结果

### 题目内容重写
Monocarp 要开设一家 IT 公司。他想招聘 $n$ 名程序员和 $m$ 名测试员。

共有 $n+m+1$ 名候选人，第 $i$ 个人的到达时间为 $i$。

第 $i$ 名候选人的编程技能为 $a_i$ ，测试技能为 $b_i$ （保证 $a_i\not=b_i$）。

公司的能力定义为所有程序员的编程能力与所有测试员的测试能力之和。

形式化的讲，若招聘的程序员集合为 $s$，测试员集合为 $t$，则公司的能力为 $\sum\limits_{i\in s}a_i+\sum\limits_{j\in t}b_j$。

Monocarp 会按照候选人到达的时间顺序为他们分配工作。

对于第 $i$ 个人，招聘规则为：
1. 尝试将 $i$ 分配到最适合 $i$ 的职位，也就是若 $a_i>b_i$，则让他成为程序员，反之同理。
2. 如果该职位已经招满了，就把 $i$ 分配到另一职位上。

你的任务是，对于每个 $i$，输出若这个人不来的情况下，公司的能力值。

### 题解分析与结论
本题的核心在于如何高效地计算每个候选人缺席时公司的能力值。题解中主要采用了以下几种思路：
1. **动态规划**：通过维护被迫选择某个职位的人，计算每个候选人缺席时的影响。
2. **二分查找**：通过二分查找确定某个职位满员的位置，从而快速计算答案。
3. **前缀和**：利用前缀和快速计算某段区间的能力值总和。

### 高星题解推荐
#### 1. 作者：Louis_lxy (5星)
**关键亮点**：
- 使用动态规划（DP）思路，维护被迫选择某个职位的人，计算每个候选人缺席时的影响。
- 代码清晰，逻辑严谨，时间复杂度为 $O(n)$，效率高。

**核心代码**：
```cpp
for (int i = n + m; i; --i) {
    if (ca == n + m + 1 && id[i]) f[i] = f[ca] + a[ca];
    else if (cb == n + m + 1 && !id[i]) f[i] = f[cb] + b[cb];
    else if (id[i]) f[i] = f[ca] + a[ca] - b[ca];
    else f[i] = f[cb] + b[cb] - a[cb];
    if (id[i] && b[i] > a[i]) cb = i;
    else if (!id[i] && b[i] < a[i]) ca = i;
}
```
**实现思想**：通过反向遍历，维护被迫选择某个职位的人，计算每个候选人缺席时的影响。

#### 2. 作者：2huk (4星)
**关键亮点**：
- 使用二分查找确定某个职位满员的位置，从而快速计算答案。
- 利用前缀和优化计算，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
int l = 0, r = n + m + 1, pos = -1;
while (l <= r) {
    int mid = l + r >> 1;
    int p = sum[mid], q = mid - p;
    if (mid >= i) (a[i] > b[i] ? p : q) -- ;
    if (p >= n || q >= m) {
        P = p, Q = q;
        r = mid - 1, pos = mid;
    } else {
        l = mid + 1;
    }
}
```
**实现思想**：通过二分查找确定满员位置，利用前缀和快速计算某段区间的能力值总和。

#### 3. 作者：Hoks (4星)
**关键亮点**：
- 通过递推计算每个候选人缺席时的影响，避免递归带来的性能问题。
- 代码简洁，时间复杂度为 $O(n)$。

**核心代码**：
```cpp
for (int i = n + m; i >= 1; i--) {
    if (c[i] == 1) d[i] = d[f1] + max(a[f1] - b[f1], 0ll), (f1 == n + m + 1) && (d[i] = d[f1] + a[f1]);
    else d[i] = d[f2] + max(b[f2] - a[f2], 0ll), (f2 == n + m + 1) && (d[i] = d[f2] + b[f2]);
    if (c[i] == 1 && b[i] > a[i]) f2 = i;
    if (c[i] == 2 && b[i] < a[i]) f1 = i;
}
```
**实现思想**：通过递推计算每个候选人缺席时的影响，避免递归带来的性能问题。

### 最优关键思路与技巧
- **动态规划**：通过维护被迫选择某个职位的人，计算每个候选人缺席时的影响，时间复杂度为 $O(n)$，效率高。
- **二分查找与前缀和**：通过二分查找确定满员位置，利用前缀和快速计算某段区间的能力值总和，时间复杂度为 $O(n \log n)$。

### 可拓展之处
- 类似问题可以扩展到其他资源分配场景，如任务调度、资源分配等。
- 可以结合其他数据结构如树状数组、线段树等进一步优化计算。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录
- **调试经历**：在动态规划的实现中，反向遍历的顺序是关键，需要仔细维护被迫选择某个职位的人。
- **顿悟感想**：通过递推计算每个候选人缺席时的影响，可以避免递归带来的性能问题，代码更加简洁高效。

---
处理用时：50.79秒
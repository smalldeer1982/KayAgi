# 题目信息

# Lazy Narek

## 题目描述

$\text{Alice}$ 有 $n$ 个字符串，每个字符串长度为 $m$。

$\text{Alice}$ 会选择 $n$ 个字符串的一个子集，可以为空，将子集中的字符串首尾按原本的相对顺序拼接，然后她会在拼接的字符串中依次查找字符 "n","a","r","e","k"。当这五个字符全被找到后，$\text{Alice}$ 会将自己的分数 $+5$ 然后继续从当前位置向后查找。

之后 $\text{Bob}$ 会扫描整个字符串并查找，如果 $\text{Alice}$ 的查找中有未被访问的 "n","a","r","e" 或 "k"，$\text{Bob}$ 会将自己的分数 $+1$。

请你帮 $\text{Alice}$ 和 $\text{Bob}$ 求出 $\max\{score_{Alice} - score_{Bob}\}$。

## 样例 #1

### 输入

```
4
5 2
nn
aa
rr
ee
kk
1 5
narek
1 4
nare
5 7
nrrarek
nrnekan
uuuuuuu
ppppppp
nkarekz```

### 输出

```
0
5
0
7```

# AI分析结果

### 题目重写
$\text{Alice}$ 有 $n$ 个字符串，每个字符串长度为 $m$。

$\text{Alice}$ 会选择 $n$ 个字符串的一个子集，可以为空，将子集中的字符串首尾按原本的相对顺序拼接，然后她会在拼接的字符串中依次查找字符 "n","a","r","e","k"。当这五个字符全被找到后，$\text{Alice}$ 会将自己的分数 $+5$ 然后继续从当前位置向后查找。

之后 $\text{Bob}$ 会扫描整个字符串并查找，如果 $\text{Alice}$ 的查找中有未被访问的 "n","a","r","e" 或 "k"，$\text{Bob}$ 会将自己的分数 $+1$。

请你帮 $\text{Alice}$ 和 $\text{Bob}$ 求出 $\max\{score_{Alice} - score_{Bob}\}$。

### 题解分析与结论

#### 综合分析与结论
本题的核心在于如何高效地计算 $\text{Alice}$ 和 $\text{Bob}$ 的分数差，并找到最优的字符串拼接方式。各题解均采用了动态规划的思路，但具体实现和优化方式有所不同。

1. **liugh_** 的题解通过状态压缩，将 $f(i,k)$ 优化为 $f(k)$，减少了状态转移的复杂度，时间复杂度为 $O(nm|\Sigma|^2)$，其中 $|\Sigma|=5$。该解法通过预处理和状态压缩，显著降低了时间复杂度。
   
2. **Yorg** 的题解通过预处理每个字符串的 $end$ 和 $val$ 数组，简化了状态转移方程，时间复杂度为 $O(\omega^2 nm)$，其中 $\omega=5$。该解法通过预处理和简化状态转移，进一步优化了算法的效率。

3. **daitangchen2008** 的题解通过直接枚举每个字符串的状态，计算分差并进行状态转移，时间复杂度为 $O(nm|\Sigma|)$。该解法通过直接计算分差，简化了状态转移的逻辑。

### 所选高星题解

#### 题解1：liugh_ (4星)
- **关键亮点**：通过状态压缩和预处理，显著降低了时间复杂度，思路清晰，代码实现简洁。
- **核心代码**：
  ```cpp
  f(k) = max{0, max(f(h) + w)}
  ```
  其中 $w$ 为从 $h$ 的下一个字符循环选择到 $k$ 所能选的最大个数。

#### 题解2：Yorg (4星)
- **关键亮点**：通过预处理 $end$ 和 $val$ 数组，简化了状态转移方程，进一步优化了算法的效率。
- **核心代码**：
  ```cpp
  dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
  dp[i + 1][end[i + 1][j]] = max(dp[i + 1][end[i + 1][j]], dp[i][j] + val[i + 1][j]);
  ```

### 最优关键思路与技巧
1. **状态压缩**：通过减少状态转移的维度，显著降低时间复杂度。
2. **预处理**：通过预处理每个字符串的状态，简化状态转移方程，提高算法效率。
3. **直接计算分差**：通过直接计算分差，简化状态转移的逻辑，降低代码复杂度。

### 可拓展之处
- **类似题目**：可以考虑其他需要拼接字符串并计算特定字符序列的题目，如最长公共子序列、字符串匹配等。
- **算法套路**：动态规划中的状态压缩和预处理技巧可以广泛应用于其他需要高效状态转移的问题。

### 推荐题目
1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录
- **liugh_**：通过状态压缩和预处理，显著降低了时间复杂度，思路清晰，代码实现简洁。
- **Yorg**：通过预处理和简化状态转移，进一步优化了算法的效率，代码实现较为复杂但效率高。

---
处理用时：32.26秒
# 题目信息

# Subtangle Game (Easy Version)

## 题目描述

这是问题的简单版本。两个版本的区别在于所有变量的约束。只有当两个版本的问题都解决时，才能进行 Hack。

Tsovak 和 Narek 正在玩一个游戏。他们有一个整数数组 $a$ 和一个整数矩阵 $b$，矩阵有 $n$ 行 $m$ 列，行列编号从 1 开始。矩阵中第 $i$ 行第 $j$ 列的单元格为 $ (i, j) $。

他们轮流在矩阵中寻找数组 $a$ 的元素；Tsovak 先开始。每次轮到玩家时，玩家需要在矩阵中寻找当前数组 $a$ 中的元素（Tsovak 寻找第一个，Narek 寻找第二个，依此类推）。假设某个玩家选择了单元格 $ (r, c) $。下一个玩家必须在从 $ (r + 1, c + 1) $ 开始、以 $ (n, m) $ 结束的子矩阵中选择他的单元格（如果 $r = n$ 或 $c = m$，子矩阵可能为空）。如果某个玩家无法在这样的子矩阵中找到相应的单元格（或者剩余的子矩阵为空），或者数组已经结束（前一个玩家已经找到了最后一个元素），那么他就输了。

你的任务是确定如果两位玩家都进行最优策略时，谁会获胜。

## 说明/提示

在第一个例子中，Tsovak 首先寻找 $ 1 $ 。矩阵中 $ 1 $ 只出现在 $ (1,1) $，所以他选择该位置。接着，Narek 需要在子矩阵 $ (2, 2) $ 中寻找 $ 2 $，该子矩阵只包含最后两个元素：$ 5 $ 和 $ 2 $。他选择 $ 2 $，随后 Tsovak 输了，因为数组已经结束。

在第二个例子中，Tsovak 需要选择 $ 1 $ 。$ 1 $ 出现在矩阵的最后一个单元格 $ (n,m) $，他选择了该单元格。由于子矩阵 $ (n+1, m+1) $ 为空，Narek 无法找到 $ 2 $，所以他输了。

Translate by 宋怡芃

## 样例 #1

### 输入

```
3
2 2 3
1 2
1 3 5
4 5 2
2 2 4
1 2
1 1 3 2
4 2 5 1
2 4 2
1 2
3 4
5 5
5 5
5 5```

### 输出

```
N
T
N```

# AI分析结果

### 题目内容重写

#### Subtangle Game (Easy Version)

##### 题目描述

这是问题的简单版本。两个版本的区别在于所有变量的约束。只有当两个版本的问题都解决时，才能进行 Hack。

Tsovak 和 Narek 正在玩一个游戏。他们有一个整数数组 $a$ 和一个整数矩阵 $b$，矩阵有 $n$ 行 $m$ 列，行列编号从 1 开始。矩阵中第 $i$ 行第 $j$ 列的单元格为 $ (i, j) $。

他们轮流在矩阵中寻找数组 $a$ 的元素；Tsovak 先开始。每次轮到玩家时，玩家需要在矩阵中寻找当前数组 $a$ 中的元素（Tsovak 寻找第一个，Narek 寻找第二个，依此类推）。假设某个玩家选择了单元格 $ (r, c) $。下一个玩家必须在从 $ (r + 1, c + 1) $ 开始、以 $ (n, m) $ 结束的子矩阵中选择他的单元格（如果 $r = n$ 或 $c = m$，子矩阵可能为空）。如果某个玩家无法在这样的子矩阵中找到相应的单元格（或者剩余的子矩阵为空），或者数组已经结束（前一个玩家已经找到了最后一个元素），那么他就输了。

你的任务是确定如果两位玩家都进行最优策略时，谁会获胜。

##### 说明/提示

在第一个例子中，Tsovak 首先寻找 $ 1 $ 。矩阵中 $ 1 $ 只出现在 $ (1,1) $，所以他选择该位置。接着，Narek 需要在子矩阵 $ (2, 2) $ 中寻找 $ 2 $，该子矩阵只包含最后两个元素：$ 5 $ 和 $ 2 $。他选择 $ 2 $，随后 Tsovak 输了，因为数组已经结束。

在第二个例子中，Tsovak 需要选择 $ 1 $ 。$ 1 $ 出现在矩阵的最后一个单元格 $ (n,m) $，他选择了该单元格。由于子矩阵 $ (n+1, m+1) $ 为空，Narek 无法找到 $ 2 $，所以他输了。

##### 样例 #1

###### 输入

```
3
2 2 3
1 2
1 3 5
4 5 2
2 2 4
1 2
1 1 3 2
4 2 5 1
2 4 2
1 2
3 4
5 5
5 5
5 5```

###### 输出

```
N
T
N```

### 题解分析与结论

#### 综合分析与结论

本题的核心在于通过动态规划（DP）来模拟游戏过程，判断两位玩家在最优策略下的胜负情况。三位作者的题解都采用了动态规划的思路，但在状态定义和转移方程的优化上有所不同。

1. **MrPython** 的题解通过维护后缀或数组来优化转移，复杂度为 $O(lnm)$，思路清晰且代码简洁。
2. **Michael1234** 的题解同样使用了动态规划，并通过二维前缀和优化了时间复杂度，最终复杂度为 $O(lnm)$，代码实现较为详细。
3. **ben090302** 的题解则通过记录后缀或和来优化转移，思路与 MrPython 类似，但代码实现稍显复杂。

综合来看，MrPython 和 Michael1234 的题解在思路清晰度和代码优化上都表现较好，值得推荐。

#### 所选高星题解

##### 1. MrPython (4星)

- **关键亮点**：通过维护后缀或数组优化了转移过程，复杂度为 $O(lnm)$，思路清晰且代码简洁。
- **代码核心实现**：
  ```cpp
  for(int k=l;k>=1;k--) {
      for(int i=n;i>=1;i--) {
          for(int j=m;j>=1;j--) {
              if(b[i][j]==a[k]&&!s[i+1][j+1]) {
                  dp[k][i][j]=true;
              } else {
                  dp[k][i][j]=false;
              }
          }
      }
      for(int i=n;i>=1;i--) {
          for(int j=m;j>=1;j--) {
              s[i][j]=s[i+1][j]|s[i][j+1]|dp[k][i][j];
          }
      }
  }
  ```

##### 2. Michael1234 (4星)

- **关键亮点**：通过二维前缀和优化了时间复杂度，最终复杂度为 $O(lnm)$，代码实现较为详细。
- **代码核心实现**：
  ```cpp
  for(int k=l;k>=1;k--) {
      for(int i=n;i>=1;i--) {
          for(int j=m;j>=1;j--) {
              if(b[i][j]==a[k]&&!s[i+1][j+1]) {
                  dp[k][i][j]=true;
              } else {
                  dp[k][i][j]=false;
              }
          }
      }
      for(int i=n;i>=1;i--) {
          for(int j=m;j>=1;j--) {
              s[i][j]=s[i+1][j]|s[i][j+1]|dp[k][i][j];
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **动态规划**：通过倒序枚举数组 $a$ 和矩阵 $b$，定义状态 $dp_{k,i,j}$ 表示当前玩家选择 $(i,j)$ 是否可以获胜。
2. **后缀或数组**：通过维护后缀或数组来优化转移过程，避免重复计算。
3. **二维前缀和**：通过二维前缀和进一步优化时间复杂度，减少计算量。

### 可拓展之处

本题的解法可以拓展到类似的博弈论问题，尤其是涉及到矩阵和数组的交互式游戏。类似的题目可以通过动态规划结合前缀和或后缀或数组来优化时间复杂度。

### 推荐题目

1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

### 个人心得

- **调试经历**：在实现动态规划时，倒序枚举可以避免状态转移时的依赖问题。
- **踩坑教训**：初始化状态时要注意边界条件，避免数组越界。
- **顿悟感想**：通过维护后缀或数组，可以大大简化状态转移的计算，提高代码效率。

---
处理用时：57.65秒
# 题目信息

# Skipping

## 题目描述

现在已经是3024年了，出题的想法早就枯竭。现今的OI以一种修改后的个人参赛形式进行。比赛有$n$道题，编号从$1$到$n$，一道题有一个分数$a_i$和一个参数$b_i$。最开始，评测系统会把第$1$道题丢给选手。当一个选手拿到第$i$道题，他有两个选择：

- 提交，获得$a_i$分
- 跳过，但他再不能去交这道题了。

接下来，评测系统会把编号最大的符合下述条件的题目$j$丢给选手：

- 如果选手提交了$i$题，那么$j<i$
- 如果选手选择跳过，那么$j\leq b_i$

系统不能给选手一道之前给过的题目。如果系统找不到这样的题，那么比赛结束。特别的，如果选手提交第一题，比赛结束。

请你帮助小p拿到最高的可能得分。

## 样例 #1

### 输入

```
4
2
15 16
2 1
5
10 10 100 100 1000
3 4 1 1 1
3
100 49 50
3 2 2
4
100 200 300 1000
2 3 4 1```

### 输出

```
16
200
100
1000```

# AI分析结果

### 题目翻译
#### 题目描述
现在已经是3024年了，出题的想法早就枯竭。现今的OI以一种修改后的个人参赛形式进行。比赛有$n$道题，编号从$1$到$n$，一道题有一个分数$a_i$和一个参数$b_i$。最开始，评测系统会把第$1$道题丢给选手。当一个选手拿到第$i$道题，他有两个选择：
- 提交，获得$a_i$分
- 跳过，但他再不能去交这道题了。

接下来，评测系统会把编号最大的符合下述条件的题目$j$丢给选手：
- 如果选手提交了$i$题，那么$j<i$
- 如果选手选择跳过，那么$j\leq b_i$

系统不能给选手一道之前给过的题目。如果系统找不到这样的题，那么比赛结束。特别的，如果选手提交第一题，比赛结束。

请你帮助小p拿到最高的可能得分。

#### 样例输入
```
4
2
15 16
2 1
5
10 10 100 100 1000
3 4 1 1 1
3
100 49 50
3 2 2
4
100 200 300 1000
2 3 4 1
```

#### 样例输出
```
16
200
100
1000
```

### 题解分析与结论
#### 综合分析
本题的核心问题是如何通过选择提交或跳过题目，使得最终得分最大化。题解中主要采用了两种思路：
1. **最短路算法**：通过建图，将问题转化为求从起点到各个点的最短路，进而计算最大得分。
2. **线段树优化**：利用线段树维护区间最小值，优化动态规划过程。

#### 最优思路
最短路算法是本题的最优解法。通过将问题转化为图的最短路问题，可以高效地求解每个点的最小代价，进而得到最大得分。具体实现中，每个点$i$向$i-1$连一条权值为$0$的边，向$b_i$连一条权值为$a_i$的边，然后从起点跑Dijkstra算法，最后通过前缀和减去最小代价得到最大得分。

#### 可拓展之处
这种将问题转化为图的最短路问题的思路，可以应用于类似的动态规划问题，尤其是当状态转移涉及到区间或跳跃时。线段树优化则适用于需要维护区间最小值的场景。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 题解摘录
#### 题解1：AquariusZhao (赞：12)
**星级：5星**
**关键亮点**：通过最短路算法将问题转化为图的最短路问题，思路清晰，代码简洁。
**个人心得**：赛时我还傻傻地写了个前缀优化建图，赛后才想起来根本不需要。

```cpp
// 核心代码：建图并跑Dijkstra
for(int i=1;i<=n;i++){
    if(i!=1) e[i].push_back({i-1,0});
    e[i].push_back({b[i],a[i]});
}
Dijkstra();
int ans=0;
for(int i=1;i<=n;i++){
    ans=max(ans,sum[i]-dis[i]);
}
```

#### 题解2：Guchenxi0971 (赞：5)
**星级：4星**
**关键亮点**：通过前缀和和最短路结合，优化了动态规划过程。
**个人心得**：注意要开`long long`。

```cpp
// 核心代码：建图并跑Dijkstra
for(int i=1;i<=n;i++){
    if(i!=1) e[i].push_back({i-1,0});
    e[i].push_back({b[i],a[i]});
}
Dijkstra();
int ans=0;
for(int i=1;i<=n;i++){
    ans=max(ans,sum[i]-dis[i]);
}
```

#### 题解3：Xy_top (赞：3)
**星级：4星**
**关键亮点**：利用线段树维护区间最小值，优化了动态规划过程。
**个人心得**：因为赛时特判$b_1=1$时没输出空格导致掉大分，写一篇题解以留念。

```cpp
// 核心代码：线段树维护区间最小值
void update(int l, int r, int k) {
    if(l == r) {
        mx[k] = min(mx[k], y);
        return;
    }
    int mid = l + r >> 1;
    if(x <= mid) update(l, mid, k << 1);
    else update(mid + 1, r, k << 1 | 1);
    mx[k] = min(mx[k << 1], mx[k << 1 | 1]);
}
```

### 总结
最短路算法是本题的最优解法，通过将问题转化为图的最短路问题，可以高效地求解每个点的最小代价，进而得到最大得分。线段树优化则适用于需要维护区间最小值的场景。

---
处理用时：43.28秒
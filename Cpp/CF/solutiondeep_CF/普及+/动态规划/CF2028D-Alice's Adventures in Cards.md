# 题目信息

# Alice's Adventures in Cards

## 题目描述

Alice 正在和红心皇后、红心国王以及红心杰克玩纸牌游戏。这个游戏中有 $ n $ 种不同的纸牌类型。Alice 手上现在有一张类型为 $ 1 $ 的纸牌，她需要通过一系列的交换，得到类型为 $ n $ 的纸牌，才能逃出仙境。而其他三名玩家手上各自持有每种类型的纸牌一张。

在这个游戏中，Alice 可以与这些玩家进行纸牌交换。每位玩家对不同类型纸牌的偏好用排列 $ q $、$ k $ 和 $ j $ 来表示，分别对应红心皇后、红心国王和红心杰克。

对于任意玩家，如果在他们的排列 $ p $ 中，满足 $ p_a > p_b $ ，那么该玩家就认为类型为 $ a $ 的纸牌比类型为 $ b $ 的更有价值。于是，他们愿意用类型为 $ b $ 的纸牌换取类型为 $ a $ 的纸牌。而 Alice 的偏好简单直观：纸牌类型 $ a $ 比类型 $ b $ 更有价值，当且仅当 $ a > b $ ，并且她只会按照这种偏好进行交换。

请判断 Alice 能否通过与其他玩家的交换，从类型为 $ 1 $ 的纸牌升级到类型为 $ n $ 的纸牌。如果可以，请给出可能的交换方案。

$ ^{\text{∗}} $ 长度为 $ n $ 的排列是一个包含 $ n $ 个不同整数（从 $ 1 $ 到 $ n $）的数组。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 和 $ [1,3,4] $ 则不是。

## 说明/提示

在第一个测试用例中，Alice 可以与红心国王交换以获得类型为 $ 2 $ 的纸牌，接着再与红心皇后交换以得到类型为 $ 3 $ 的纸牌。

在第二个测试用例中，尽管 Alice 能与红心皇后交换得到类型为 $ 3 $ 的纸牌，再接着与红心国王交换得到类型为 $ 2 $，最后与红心杰克交换得到类型为 $ 4 $ 的纸牌，但这种方案不符合 Alice 的偏好原则，因此无效。我们可以证明在这种情况下 Alice 无法获得类型为 $ 4 $ 的纸牌。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
3
1 3 2
2 1 3
1 2 3
4
2 3 1 4
1 2 3 4
1 4 2 3```

### 输出

```
YES
2
k 2
q 3
NO```

# AI分析结果

### 题目内容重写

#### Alice的纸牌冒险

##### 题目描述

Alice正在与红心皇后、红心国王和红心杰克玩纸牌游戏。游戏中有$n$种不同的纸牌类型。Alice手上有一张类型为$1$的纸牌，她需要通过一系列的交换，得到类型为$n$的纸牌，才能逃出仙境。其他三名玩家各自持有每种类型的纸牌一张。

在这个游戏中，Alice可以与这些玩家进行纸牌交换。每位玩家对不同类型纸牌的偏好用排列$q$、$k$和$j$来表示，分别对应红心皇后、红心国王和红心杰克。

对于任意玩家，如果在他们的排列$p$中，满足$p_a > p_b$，那么该玩家就认为类型为$a$的纸牌比类型为$b$的更有价值。于是，他们愿意用类型为$b$的纸牌换取类型为$a$的纸牌。而Alice的偏好简单直观：纸牌类型$a$比类型$b$更有价值，当且仅当$a > b$，并且她只会按照这种偏好进行交换。

请判断Alice能否通过与其他玩家的交换，从类型为$1$的纸牌升级到类型为$n$的纸牌。如果可以，请给出可能的交换方案。

$^{\text{∗}}$长度为$n$的排列是一个包含$n$个不同整数（从$1$到$n$）的数组。例如，$[2,3,1,5,4]$是一个排列，但$[1,2,2]$和$[1,3,4]$则不是。

##### 说明/提示

在第一个测试用例中，Alice可以与红心国王交换以获得类型为$2$的纸牌，接着再与红心皇后交换以得到类型为$3$的纸牌。

在第二个测试用例中，尽管Alice能与红心皇后交换得到类型为$3$的纸牌，再接着与红心国王交换得到类型为$2$，最后与红心杰克交换得到类型为$4$的纸牌，但这种方案不符合Alice的偏好原则，因此无效。我们可以证明在这种情况下Alice无法获得类型为$4$的纸牌。

### 题解分析与结论

#### 题解1：xzy090626

**星级：4**

**关键亮点：**
- 使用类似于Dijkstra的算法，每次选择编号最小的纸牌进行松弛操作。
- 通过set维护三个排列的偏好置换，确保快速找到符合条件的交换。
- 复杂度为$O(n\log n)$，较为高效。

**核心代码：**
```cpp
priority_queue<int,vector<int>,greater<int>>q;
vector<bool>vis(n+5),ok(n+5);
vector<pii>lst(n+5);
q.push(1); ok[1] = 1;
set<int>tt;
for(int i=2;i<=n;++i) tt.insert(i);
while(!q.empty()){
    int u = q.top();q.pop();
    if(vis[u]) continue;
    vis[u] = 1;
    vector<int>vec;
    for(auto c:tt){
        if(c<=u) vec.push_back(c);
        else break;
    }
    for(auto c:vec){
        tt.erase(c);
        ok[c] = 1;
        for(int i=1;i<=3;++i){
            pii tmp = {pos[i][c],c};
            if(st[i].count(tmp)) st[i].erase(tmp);
        }
    }
    vec.clear();
    for(int i=1;i<=3;++i){
        for(auto c:st[i]){
            if(pos[i][c.y]>=pos[i][u]) break;
            if(ok[c.y]) continue;
            if(tt.count(c.y)) tt.erase(c.y);
            ok[c.y] = 1;
            q.push(c.y);
            vec.push_back(c.y);
            lst[c.y] = {u,i};
        }
    }
    for(auto c:vec){
        for(int i=1;i<=3;++i){
            pii tmp = {pos[i][c],c};
            if(st[i].count(tmp)) st[i].erase(tmp);
        }
    }
}
```

#### 题解2：CWzwz

**星级：4**

**关键亮点：**
- 使用BIT（树状数组）维护三个玩家的偏好排列，支持快速查询和更新。
- 通过从小到大枚举纸牌类型，动态转移状态，判断是否能够获得目标纸牌。
- 复杂度为$O(n\log n)$，同样高效。

**核心代码：**
```cpp
for(int i=1;i<=n;++i){
    for(int j=1;j<=3;++j){
        int pos = get_pos(j,i);
        if(pos>1){
            int sum = query(j,pos-1);
            if(sum) f[i] = 1;
        }
    }
    if(f[i]){
        for(int j=1;j<=3;++j){
            int pos = get_pos(j,i);
            update(j,pos,1);
        }
    }
}
```

### 最优关键思路与技巧

- **Dijkstra-like算法**：通过优先队列选择当前最小编号的纸牌进行松弛操作，确保每次交换都是最优选择。
- **Set与BIT的结合**：使用set和BIT数据结构快速维护和查询玩家的偏好排列，确保高效找到符合条件的交换。
- **动态规划与状态转移**：通过动态规划的思想，从小到大枚举纸牌类型，判断是否能够通过交换获得目标纸牌。

### 可拓展之处

- **类似问题**：可以扩展到更多玩家或更多纸牌类型的情况，使用类似的数据结构和算法进行优化。
- **其他应用**：类似的思想可以应用于其他需要动态维护和查询排列的问题，如任务调度、资源分配等。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

### 个人心得

- **调试经历**：在实现过程中，需要注意set和BIT的更新和查询操作，确保每次交换后及时更新状态。
- **踩坑教训**：在处理玩家偏好排列时，需要确保每次查询和更新的顺序正确，避免出现逻辑错误。
- **顿悟感想**：通过结合多种数据结构和算法，可以更高效地解决复杂的排列和交换问题。

---
处理用时：48.26秒
# 题目信息

# Choosing Capital for Treeland

## 题目描述

Treeland 国有 $n$ 个城市，有些城市间存在 **单向** 道路。这个国家一共有 $n - 1$ 条路。我们知道，如果把边视作双向的，那么从任意城市出发能到达任意城市。

城市的委员会最近决定为 Treeland 国选择一个首都，显然首都会是国中的一个城市。委员会将在首都开会，并经常取其他城市（这里不考虑从其他城市回到首都）。因此，如果城市 $a$ 被选为首都，那么所有的道路应该被定向，以使得我们能从城市 $a$ 到达其他城市。所以，有些路可能需要反转方向。
   
帮助委员会选择首都使得他们需要反转道路的次数最小。

## 样例 #1

### 输入

```
3
2 1
2 3
```

### 输出

```
0
2 
```

## 样例 #2

### 输入

```
4
1 4
2 4
3 4
```

### 输出

```
2
1 2 3 
```

# AI分析结果

### 题目内容重写
Treeland 国有 $n$ 个城市，有些城市间存在 **单向** 道路。这个国家一共有 $n - 1$ 条路。我们知道，如果把边视作双向的，那么从任意城市出发能到达任意城市。

城市的委员会最近决定为 Treeland 国选择一个首都，显然首都会是国中的一个城市。委员会将在首都开会，并经常取其他城市（这里不考虑从其他城市回到首都）。因此，如果城市 $a$ 被选为首都，那么所有的道路应该被定向，以使得我们能从城市 $a$ 到达其他城市。所以，有些路可能需要反转方向。
   
帮助委员会选择首都使得他们需要反转道路的次数最小。

### 样例 #1
#### 输入
```
3
2 1
2 3
```
#### 输出
```
0
2 
```

### 样例 #2
#### 输入
```
4
1 4
2 4
3 4
```
#### 输出
```
2
1 2 3 
```

### 题解分析与结论
本题的核心是通过树形DP和换根DP来求解以每个节点为根时，需要反转的边数的最小值。大多数题解采用了类似的思路：首先通过一次DFS计算以某个节点为根时的反转边数，然后通过换根DP快速计算其他节点的反转边数。

#### 最优关键思路
1. **树形DP**：首先通过DFS计算以某个节点为根时，子树中需要反转的边数。
2. **换根DP**：通过换根的方式，利用父节点的信息快速计算子节点的反转边数。具体来说，当根从父节点转移到子节点时，反转边数的变化仅与父子之间的边有关。

#### 代码实现技巧
- **边的标记**：在存储边时，标记边的方向（正向或反向），以便在DP过程中快速判断是否需要反转。
- **换根DP的转移方程**：根据边的方向，更新子节点的反转边数。如果边是正向的，子节点的反转边数比父节点多1；如果是反向的，子节点的反转边数比父节点少1。

### 推荐题解
1. **作者：An_Account (5星)**
   - **关键亮点**：思路清晰，代码简洁，详细解释了树形DP和换根DP的转移方程。
   - **核心代码**：
     ```cpp
     void dfs1(int u,int f) {
         for (int i=head[u];i;i=e[i].next) 
             if (e[i].to!=f) {
                 dfs1(e[i].to,u);
                 dp[u]+=dp[e[i].to]+e[i].w;
             }
     }
     void dfs2(int u,int f) {
         for (int i=head[u];i;i=e[i].next)
             if (e[i].to!=f) {
                 dp[e[i].to]=dp[u]+(e[i].w?-1:1);
                 dfs2(e[i].to,u);
             }
     }
     ```

2. **作者：Durancer (4星)**
   - **关键亮点**：通过图示详细解释了换根DP的转移过程，代码可读性较好。
   - **核心代码**：
     ```cpp
     void dfs1(int x,int fu) {
         for(int i=head[x];i;i=e[i].last) {
             int v=e[i].to;
             int pd=e[i].pik;
             if(v==fu) continue;
             if(pd==1) f[x]++;
             dfs1(v,x);
             f[x]+=f[v];
         }
     }
     void dfs2(int x,int fu) {
         for(int i=head[x];i;i=e[i].last) {
             int v=e[i].to;
             int pd=e[i].pik;
             if(v==fu) continue;
             if(pd==1)f[v]=f[x]-1;
             if(pd==0)f[v]=f[x]+1;
             dfs2(v,x);
         }
     }
     ```

3. **作者：MurataHimeko (4星)**
   - **关键亮点**：详细解释了换根DP的优化思路，代码简洁明了。
   - **核心代码**：
     ```cpp
     void dfs1(int u,int fa) {
         for(int i=head[u];i;i=e[i].next) {
             int v=e[i].to;
             if(v==fa) continue;
             dfs1(v,u);
             dp[u]+=dp[v]+e[i].w;
         }
     }
     void dfs2(int u,int fa) {
         for(int i=head[u];i;i=e[i].next) {
             int v=e[i].to;
             if(v==fa) continue;
             dp[v]=dp[u]+(e[i].w?-1:1);
             dfs2(v,u);
         }
     }
     ```

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P3177 [HAOI2015]树上染色](https://www.luogu.com.cn/problem/P3177)

这些题目都涉及到树形DP和换根DP的思想，适合进一步巩固相关知识。

---
处理用时：51.61秒
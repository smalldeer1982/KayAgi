# 题目信息

# Pawn

## 题目描述

国际象棋棋盘最底行站了一个兵。 它只有两种行动方式： 向上左或向上右走。 它可以选择从最低行哪个节点开始他的旅程。

每个格子上有 $0-9$ 颗豌豆，而士兵想移动到最上一行并且积累到尽可能多的豌豆。同时，因为这个士兵必须把豌豆平均分给自己和他的 $k$ 个兄弟，他所收集到的豌豆必须是 $k+1$ 的倍数。请找到他可以收集到的最多豌豆，并确定他的操作序列。

规定士兵不能手动扔出豌豆，并且他必须捡起所到达的每一个格子的所有豌豆。

## 样例 #1

### 输入

```
3 3 1
123
456
789
```

### 输出

```
16
2
RL
```

## 样例 #2

### 输入

```
3 3 0
123
456
789
```

### 输出

```
17
3
LR
```

## 样例 #3

### 输入

```
2 2 10
98
75
```

### 输出

```
-1
```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

国际象棋棋盘的最底行站了一个兵。它只有两种行动方式：向上左或向上右走。它可以选择从最低行的任意一个节点开始它的旅程。

每个格子上有 $0-9$ 颗豌豆，而士兵想移动到最上一行并且积累到尽可能多的豌豆。同时，因为这个士兵必须把豌豆平均分给自己和他的 $k$ 个兄弟，他所收集到的豌豆必须是 $k+1$ 的倍数。请找到他可以收集到的最多豌豆，并确定他的操作序列。

规定士兵不能手动扔出豌豆，并且他必须捡起所到达的每一个格子的所有豌豆。

#### 样例 #1

##### 输入

```
3 3 1
123
456
789
```

##### 输出

```
16
2
RL
```

#### 样例 #2

##### 输入

```
3 3 0
123
456
789
```

##### 输出

```
17
3
LR
```

#### 样例 #3

##### 输入

```
2 2 10
98
75
```

##### 输出

```
-1
```

### 题解分析与结论

这道题的核心是动态规划（DP），难点在于如何设计状态转移方程，使得在满足豌豆数为 $k+1$ 的倍数的条件下，找到最大豌豆数。以下是各题解的要点总结：

1. **状态设计**：大多数题解采用了三维 DP 状态，$dp[i][j][k]$ 表示在第 $i$ 行第 $j$ 列时，豌豆数模 $k+1$ 为 $k$ 的最大值。这种设计巧妙地解决了题目中的整除条件。
  
2. **转移方程**：状态转移通常从下一行的左上方和右上方转移而来，确保每一步都满足条件。

3. **路径记录**：为了输出路径，题解中通常使用一个辅助数组记录每一步的移动方向，最后通过递归或栈来输出路径。

4. **优化**：部分题解通过提前计算最大可能值或使用滚动数组来优化空间复杂度。

### 精选题解

#### 题解1：作者：lenlen (赞：17) - 4.5星

**关键亮点**：
- 状态设计清晰，使用三维 DP 解决整除条件。
- 代码结构清晰，路径记录和输出处理得当。

**核心代码**：
```cpp
for(int i=n;i>=1;i--) // 枚举横纵坐标
for(int j=1;j<=m;j++)
for(int k=mx;k>=a[i][j];k--) {
    if(j>1) {
        if(f[i+1][j-1][k-a[i][j]]) w[i][j][k]='R';
        f[i][j][k]|=f[i+1][j-1][k-a[i][j]];
    }
    if(j<m) {
        if(f[i+1][j+1][k-a[i][j]]) w[i][j][k]='L';
        f[i][j][k]|=f[i+1][j+1][k-a[i][j]];
    }
}
```

#### 题解2：作者：Sagittarius (赞：11) - 4星

**关键亮点**：
- 状态转移方程简洁明了，路径记录使用递归输出。
- 代码可读性强，适合初学者理解。

**核心代码**：
```cpp
for(int i=n-1;i>=1;i--)
for(int j=1;j<=m;j++)
for(int k=a[i][j];k<=maxp*maxnm;k++) {
    if(j-1>0 && f[i+1][j-1][k-a[i][j]]) {
        f[i][j][k]=1; d[i][j][k]='R';
    }
    if(j+1<=m && f[i+1][j+1][k-a[i][j]]) {
        f[i][j][k]=1; d[i][j][k]='L';
    }
}
```

#### 题解3：作者：JWRuixi (赞：5) - 4星

**关键亮点**：
- 状态设计考虑了模运算，直接处理整除条件。
- 路径记录使用递归，代码结构清晰。

**核心代码**：
```cpp
for(int i=n-1;i>=1;i--)
for(int j=1;j<=m;j++)
for(int k=0;k<mod;k++) {
    int l = f[i+1][j+1][(k-a[i][j]%mod+mod)%mod];
    int r = f[i+1][j-1][(k-a[i][j]%mod+mod)%mod];
    if(j+1<=m && ~l && f[i][j][k] < l + a[i][j]) {
        f[i][j][k] = l + a[i][j];
        trs[i][j][k] = 'L';
    }
    if(j-1>=1 && ~r && f[i][j][k] < r + a[i][j]) {
        f[i][j][k] = r + a[i][j];
        trs[i][j][k] = 'R';
    }
}
```

### 最优关键思路与技巧

1. **状态设计**：使用三维 DP 状态 $dp[i][j][k]$，其中 $k$ 表示豌豆数模 $k+1$ 的余数，巧妙处理了整除条件。
2. **路径记录**：通过辅助数组记录每一步的移动方向，最后通过递归或栈输出路径。
3. **优化**：提前计算最大可能值，减少不必要的枚举。

### 拓展与举一反三

1. **类似题目**：
   - [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
   - [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)

2. **调试心得**：在调试过程中，确保状态转移方程的正确性非常重要，尤其是在处理模运算时，容易出错。建议在编写代码时，逐步验证每一步的状态转移是否正确。

### 推荐题目

1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：52.63秒
# 题目信息

# George and Job

## 题目描述

新款手机 iTone6 近期上市，George 很想买一只。不幸地，George 没有足够的钱，所以 George 打算当一名程序猿去打工。现在George遇到了一个问题。
给出一组有 $n$ 个整数的数列 $p_1,p_2,...,p_n$ ,你需要挑出 $k$ 组长度为 $m$ 的数，要求这些数互不重叠
即$ [l_{1},r_{1}],[l_{2},r_{2}],...,[l_{k},r_{k}] (1<=l_{1}<=r_{1}<l_{2}<=r_{2}<...<l_{k}<=r_{k}<=n; r_{i}-l_{i}+1=m)$
使选出的数的和值最大，请你帮助George码出这份代码

## 样例 #1

### 输入

```
5 2 1
1 2 3 4 5
```

### 输出

```
9
```

## 样例 #2

### 输入

```
7 1 3
2 10 7 18 5 33 0
```

### 输出

```
61
```

# AI分析结果

### 题目内容重写
新款手机 iTone6 近期上市，George 很想买一只。不幸地，George 没有足够的钱，所以 George 打算当一名程序猿去打工。现在George遇到了一个问题。
给出一组有 $n$ 个整数的数列 $p_1,p_2,...,p_n$ ,你需要挑出 $k$ 组长度为 $m$ 的数，要求这些数互不重叠
即$ [l_{1},r_{1}],[l_{2},r_{2}],...,[l_{k},r_{k}] (1<=l_{1}<=r_{1}<l_{2}<=r_{2}<...<l_{k}<=r_{k}<=n; r_{i}-l_{i}+1=m)$
使选出的数的和值最大，请你帮助George码出这份代码

### 样例 #1
#### 输入
```
5 2 1
1 2 3 4 5
```
#### 输出
```
9
```

### 样例 #2
#### 输入
```
7 1 3
2 10 7 18 5 33 0
```
#### 输出
```
61
```

### 综合分析与结论
这道题目是一个典型的动态规划问题，核心在于如何在给定的数列中选择不重叠的 $k$ 组长度为 $m$ 的子序列，使得这些子序列的和最大。题解中大部分作者都采用了动态规划的思路，结合前缀和来优化计算。以下是几条较为优秀的题解及其关键思路。

### 所选优秀题解

#### 题解1：作者：_JF_ (赞：7)
- **星级**：4.5
- **关键亮点**：思路清晰，代码简洁，使用了前缀和优化，状态转移方程明确。
- **核心代码**：
```cpp
for(int i=m;i<=n;i++) {
    for(int j=1;j<=k;j++)
        dp[i][j]=max(dp[i-1][j],dp[i-m][j-1]+sum[i]-sum[i-m]);
}
```
- **核心思想**：使用 $dp[i][j]$ 表示前 $i$ 个数中选出 $j$ 组子序列的最大和，通过前缀和快速计算区间和，状态转移方程直接明了。

#### 题解2：作者：BriMon (赞：4)
- **星级**：4
- **关键亮点**：引入了 $g[p]$ 来优化 $O(N^3)$ 的复杂度，使得时间复杂度降为 $O(N^2)$。
- **核心代码**：
```cpp
for (reg int i = k ; i <= n ; i ++) f[1][i] = sum[i] - sum[i-k], g[i] = max(g[i-1], f[1][i]);
for (reg int i = 2 ; i <= m ; i ++) {
    for (reg int j = k ; j <= n ; j ++)
        f[i][j] = g[j-k] + sum[j] - sum[j-k];
    memset(g, 0, sizeof g);
    for (reg int j = 1 ; j <= n ; j ++) 
        g[j] = max(g[j-1], f[i][j]);
}
```
- **核心思想**：通过维护 $g[p]$ 来记录 $f[i-1][1\rightarrow p]$ 的最大值，从而在 $O(1)$ 时间内完成状态转移。

#### 题解3：作者：RockyYue (赞：3)
- **星级**：4
- **关键亮点**：使用了单调队列优化，进一步提升了代码的效率。
- **核心代码**：
```cpp
for(int i=m;i<=n;i++) {
    if(head<=tail) {
        dp[i][j]=max(dp[i][j],dp[q[head]][j-1]+s[i]-s[i-m]);
    }
    while(head<=tail && dp[i-m+1][j-1]>dp[q[tail]][j-1]) {
        --tail;
    }
    q[++tail]=i-m+1;
}
```
- **核心思想**：通过单调队列维护 $dp[q[head]][j-1]$ 的最大值，使得在每次转移时能够快速找到最优解。

### 最优关键思路与技巧
1. **前缀和优化**：通过预处理前缀和，可以快速计算任意区间的和，避免了重复计算。
2. **动态规划状态转移**：使用 $dp[i][j]$ 表示前 $i$ 个数中选出 $j$ 组子序列的最大和，状态转移方程清晰。
3. **单调队列优化**：通过单调队列维护最大值，进一步优化了时间复杂度。

### 可拓展之处
- **类似题目**：可以拓展到选择多个不重叠子序列的问题，或者子序列长度不固定的情况。
- **算法套路**：动态规划结合前缀和、单调队列等优化技巧，适用于多种区间选择问题。

### 推荐题目
1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得摘录
- **调试经历**：部分作者提到在调试过程中发现状态转移方程的错误，通过逐步调试和验证最终找到正确的转移方式。
- **踩坑教训**：有作者提到在初始化时忘记设置 $dp[i][0]=0$，导致结果错误，提醒了初始化的重要性。
- **顿悟感想**：有作者在优化过程中发现单调队列的使用，使得代码效率大幅提升，感叹优化技巧的重要性。

---
处理用时：49.66秒
# 题目信息

# Red-Green Towers

## 题目描述

你有 $r$ 块红色的积木和 $g$ 块绿色的积木，它们用于建造红绿塔。红绿塔按照下面的规则来建造：

- 红绿塔有若干层；
- 如果红绿塔有 $n$ 层，那么塔的第一层应该有 $n$ 块积木，第二层有 $n-1$ 块，第三层有 $n-2$ 块，以此类推，最后一层只有一块。换言之，每一层应该比前面一层少一块；
- 红绿塔的每一层必须使用相同颜色的积木。

令 $h$ 表示用 $r$ 个红积木和 $g$ 个绿积木所能搭建的满足上述规则的塔的最大层数。现在你的任务是确定可以建造出多少不同的有 $h$ 层的红绿塔。

如果两个红绿塔相同的一层使用的是不同的颜色，它们就被认为不同的。

你需要写一个程序来求出有多少种高度为 $h$ 的不同的红绿塔。由于答案很大，你只需要输出答案模 $10^9+7$（也就是$1000000007$）后的值。

## 样例 #1

### 输入

```
4 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
9 7
```

### 输出

```
6
```

## 样例 #3

### 输入

```
1 1
```

### 输出

```
2
```

# AI分析结果

### 题目重写
你有 $r$ 块红色的积木和 $g$ 块绿色的积木，它们用于建造红绿塔。红绿塔按照下面的规则来建造：

- 红绿塔有若干层；
- 如果红绿塔有 $n$ 层，那么塔的第一层应该有 $n$ 块积木，第二层有 $n-1$ 块，第三层有 $n-2$ 块，以此类推，最后一层只有一块。换言之，每一层应该比前面一层少一块；
- 红绿塔的每一层必须使用相同颜色的积木。

令 $h$ 表示用 $r$ 个红积木和 $g$ 个绿积木所能搭建的满足上述规则的塔的最大层数。现在你的任务是确定可以建造出多少不同的有 $h$ 层的红绿塔。

如果两个红绿塔相同的一层使用的是不同的颜色，它们就被认为不同的。

你需要写一个程序来求出有多少种高度为 $h$ 的不同的红绿塔。由于答案很大，你只需要输出答案模 $10^9+7$（也就是$1000000007$）后的值。

### 题解分析与结论

#### 综合分析
本题的核心是动态规划（DP）的应用，主要难点在于如何高效地计算不同颜色积木的使用方案数。大多数题解都采用了类似的思路：首先确定最大层数 $h$，然后通过 DP 计算在满足红色和绿色积木数量限制的情况下，有多少种不同的塔的建造方案。

#### 关键思路与技巧
1. **最大层数的确定**：通过等差数列求和公式 $\frac{h(h+1)}{2} \leq r + g$ 来确定最大层数 $h$。
2. **动态规划**：将问题转化为 0-1 背包问题，使用 DP 计算在满足红色积木数量限制的情况下，有多少种不同的方案。
3. **滚动数组优化**：为了节省空间，大多数题解都采用了滚动数组的技巧，将二维 DP 优化为一维。
4. **边界条件处理**：确保绿色积木的数量不超过给定的 $g$，避免无效计算。

#### 所选高分题解

##### 1. 作者：灵茶山艾府 (★★★★★)
- **关键亮点**：思路清晰，代码简洁，使用了滚动数组优化，处理了边界条件。
- **核心代码**：
  ```go
  dp := make([]int, r+1)
  dp[0] = 1
  for i := 1; i <= h; i++ {
      for j := r; j >= i; j-- {
          dp[j] = (dp[j] + dp[j-i]) % mod
      }
  }
  ```
  **实现思想**：通过 0-1 背包的思路，计算在满足红色积木数量限制的情况下，有多少种不同的方案。

##### 2. 作者：_JF_ (★★★★)
- **关键亮点**：详细解释了 DP 的状态转移，使用了滚动数组优化，代码可读性高。
- **核心代码**：
  ```cpp
  for(int i=1;i<=1000;i++){
      int pre=0;
      for(int j=0;j<=r;j++)	dp1[j]=0;
      for(int j=min(r,(1+i)*i/2);j>=0;j--){
          int Red=j,Gre=(1+i)*i/2-j;
          if(Red<=r&&Gre<=g){
              dp1[j]+=dp[j]%mod,dp1[j]%=mod;
              if(j-i>=0)	dp1[j]+=dp[j-i]%mod,dp1[j]%=mod;
          }
          pre+=dp1[j]%mod,pre%=mod;
      }
      for(int j=min(r,(1+i)*i/2);j>=0;j--)	dp[j]=dp1[j];
      if(pre>0)	ans=pre;
      else	break;
  }
  ```
  **实现思想**：通过 DP 计算前 $i$ 层使用 $j$ 个红色积木的方案数，确保绿色积木的数量不超过 $g$。

##### 3. 作者：流绪 (★★★★)
- **关键亮点**：详细解释了最大层数的确定方法，使用了滚动数组优化，代码简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<h;i++)		//前 i 层 
      for(int j=r;j>=i;j--)	//用 j 块红砖 
          dp[j] += dp[j-i],dp[j]%=mod;
  ```
  **实现思想**：通过 DP 计算前 $i$ 层使用 $j$ 个红色积木的方案数，确保绿色积木的数量不超过 $g$。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 0-1 背包问题的经典题目。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 类似背包问题的应用。
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) - 背包问题的变种，适合练习 DP 的应用。

---
处理用时：41.12秒
# 题目信息

# Kefa and Dishes

## 题目描述

$\texttt{songshe}$ 进入了一家餐厅，这家餐厅中有 $n\ (1\leqslant n\leqslant18)$ 个菜。$\texttt{songshe}$ 对第 $i$ 个菜的满意度为 $a_i\ (0\leqslant a_i\leqslant10^9)$。

对于这 $n$ 个菜，有 $k\ (0\leqslant k\leqslant n^2-n)$ 条规则：如果 $\texttt{songshe}$ 在吃完第 $x_i$ 个菜之后立刻吃了第 $y_i\ (x_i\neq y_i)$ 个菜，那么会额外获得 $c_i\ (0\leqslant c_i\leqslant10^9)$ 的满意度。

$\texttt{songshe}$ 要吃 $m\ (1\leqslant m\leqslant n)$ 道任意的菜，但是他希望自己吃菜的顺序得到的满意度最大，请你帮 $\texttt{songshe}$ 解决这个问题。

## 样例 #1

### 输入

```
2 2 1
1 1
2 1 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4 3 2
1 2 3 4
2 1 5
3 4 2
```

### 输出

```
12
```

# AI分析结果

### 题目内容重写（中文）

$\texttt{songshe}$ 进入了一家餐厅，这家餐厅中有 $n\ (1\leqslant n\leqslant18)$ 个菜。$\texttt{songshe}$ 对第 $i$ 个菜的满意度为 $a_i\ (0\leqslant a_i\leqslant10^9)$。

对于这 $n$ 个菜，有 $k\ (0\leqslant k\leqslant n^2-n)$ 条规则：如果 $\texttt{songshe}$ 在吃完第 $x_i$ 个菜之后立刻吃了第 $y_i\ (x_i\neq y_i)$ 个菜，那么会额外获得 $c_i\ (0\leqslant c_i\leqslant10^9)$ 的满意度。

$\texttt{songshe}$ 要吃 $m\ (1\leqslant m\leqslant n)$ 道任意的菜，但是他希望自己吃菜的顺序得到的满意度最大，请你帮 $\texttt{songshe}$ 解决这个问题。

### 样例 #1

#### 输入

```
2 2 1
1 1
2 1 1
```

#### 输出

```
3
```

### 样例 #2

#### 输入

```
4 3 2
1 2 3 4
2 1 5
3 4 2
```

#### 输出

```
12
```

---

### 综合分析与结论

本题是一个典型的**状态压缩动态规划（状压DP）**问题，核心在于如何通过二进制状态表示已经吃过的菜，并通过状态转移来计算最大满意度。由于 $n \leq 18$，状压DP是解决此类问题的有效方法。

#### 关键思路与技巧：
1. **状态表示**：使用二进制数表示已经吃过的菜，`f[i][j]` 表示状态为 `i`，最后吃的菜是 `j` 时的最大满意度。
2. **状态转移**：枚举当前状态和最后吃的菜，再枚举下一个要吃的菜，更新新状态的最大满意度。
3. **优化**：通过预处理统计每个状态中已经吃过的菜的数量，避免重复计算。
4. **边界条件**：初始化每个只吃一道菜的状态，确保从这些状态开始转移。

#### 可拓展之处：
- **类似问题**：最短哈密顿路径问题、旅行商问题（TSP）等，都可以通过状压DP解决。
- **优化技巧**：可以使用滚动数组优化空间复杂度，或者通过位运算加速状态转移。

### 推荐题目
1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
2. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)
3. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)

---

### 所选高星题解

#### 题解1：作者：Moon_Goddy (赞：13)
- **星级**：★★★★★
- **关键亮点**：
  - 状态设计清晰，`f[i][j]` 表示状态 `i` 且最后吃的菜是 `j` 的最大满意度。
  - 通过 `calc` 函数统计状态中已经吃过的菜的数量，优化了状态转移的条件判断。
  - 代码注释详细，易于理解。

```cpp
int calc(int a){ //统计吃了多少菜
	int res=0;
	for(int i=0;i<n;i++)res+=((a>>i)&1);
	return res;
}
```

#### 题解2：作者：Jμdge (赞：8)
- **星级**：★★★★☆
- **关键亮点**：
  - 状态转移方程简洁明了，`f[now|(1<<j)][j] = max(f[now|(1<<j)][j], f[now][i] + a[j] + ad[i][j])`。
  - 通过枚举状态和最后吃的菜，直接计算新状态的最大满意度。
  - 代码结构清晰，易于实现。

```cpp
for(int now=0;now < (1<<n);++now) { //枚举状态
    int cnt=0;  //计算已经吃了几道菜
    for(int i=0;i<n;++i) if(now & (1<<i)) { //枚举吃的最后一道菜
        ++cnt;
        for(int j=0;j<n;++j) if(!(now & (1<<j))) //枚举接下来吃的那道菜
            f[now|(1<<j)][j]=max(f[now|(1<<j)][j] , f[now][i]+a[j]+ad[i][j]);
    }
    if(cnt==m)  //如果当前状态就是吃了m道菜则ans取最大值
    for(int i=0;i<n;++i) if(now & (1<<i)) //枚举吃的最后一道菜
        ans=max(ans , f[now][i]);
}
```

#### 题解3：作者：xixike (赞：3)
- **星级**：★★★★☆
- **关键亮点**：
  - 状态转移方程详细解释了如何从上一个状态转移到当前状态，`dp_{i, s} = \max\{dp_{j, s \oplus (1 << (i - 1))} + a_i + g_{j, i} \}`。
  - 通过枚举状态和最后吃的菜，再枚举倒数第二个吃的菜，确保状态转移的正确性。
  - 代码结构清晰，注释详细。

```cpp
for(int s = 0; s < (1 << n); ++s)
    for(int i = 1; i <= n; ++i)
        if(s & (1 << (i - 1)))
            for(int j = 1; j <= n; ++j)
                if(i != j && (s & (1 << (j - 1))))
                    dp[i][s] = max(dp[i][s], dp[j][s ^ (1 << (i - 1))] + a[i] + g[j][i]);
```

---

### 个人心得摘录
- **调试经历**：部分题解提到在状态转移时需要注意重边问题，避免重复计算额外满意度。
- **踩坑教训**：初始化状态时，确保每个只吃一道菜的状态被正确赋值，否则会影响后续状态转移。
- **顿悟感想**：状压DP的核心在于如何通过二进制状态表示复杂的状态转移，理解这一点后，类似问题可以迎刃而解。

---
处理用时：54.72秒
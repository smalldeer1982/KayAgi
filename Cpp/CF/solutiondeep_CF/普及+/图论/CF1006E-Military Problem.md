# 题目信息

# Military Problem

## 题目描述

在这个问题中你需要帮助伯兰（？？我没找到有Berland这个国家）军队组织他们的指挥系统

伯兰军队中一共有n个军官。第一个官员是军队的指挥官，他并没有任何上级。其他的军官都有且只有一个直接的上级。如果一个军官a是军官b的上级，那么你也可以说军官b就是军官a的下属

如果满足下列条件，那么军官x就是军官y的下属（直接或非直接）：

1.y是x的直接上级 2.x的直接上级是y的下属

举个例子，下图的官员3的下属有:5,6,7,8,9

所以，在伯兰军队的结构中，除了指挥官，其他人都是指挥官的下属

形式上的，让我们把伯兰军队看成一棵拥有n个节点的树，树的节点u就代表了军官u。根（即一号节点）就相当于指挥官

伯兰战争部门命令你对q个查询给出答案。这q个查询会以（ui，ki）的形式给出，ui代表了某个军官，ki是正整数。你需要输出，编号为ui的军官下达命令后，第ki个得知此命令的军官编号是多少，如果传达人数不足ki个，输出-1。

要处理第i个查询，想象一下ui的命令如何我下达到ui的下属。这里使用了典型的DFS（深度优先搜索）算法。

假设现在的军官是a，他要下达一个命令。a军官选择一个军官b——还没有收到这个命令的直接下属（即在树上的一个孩子）。如果有许多这样的直接下属，那么A选择编号最小的那一个。A军官向B军官发出命令。之后，B使用完全相同的方式将命令扩展到它的子树。在B完成命令后，军官A再次选择下一个直接下属（使用相同的策略）。当军官A不能选择任何还没有接到命令的直接下属时，军官A下达命令完成。

让我们看一下下面这个例子（看下面的图）：

如果军官1下达了命令，军官们收到命令的顺序是：1,2,3,5,6,8,7,9,4

如果军官3下达了命令，军官们收到命令的顺序是：3,5,6,8,7,9

如果军官7下达了命令，军官们收到命令的顺序是：7,9

如果军官9下达了命令，军官们收到命令的顺序是：9

你应当分开处理这些查询。一个查询不会影响其他查询的结果。

## 样例 #1

### 输入

```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```

### 输出

```
3
6
8
-1
9
4
```

# AI分析结果

### 题解综合分析与结论
这些题解核心思路一致，都是利用树的子树先序遍历是整棵树先序遍历子串这一性质，通过一次DFS预处理出整棵树的先序排列、每个节点子树大小、节点被遍历到的顺序等信息，再在每次询问时$O(1)$查询。
- **思路对比**：大部分题解思路相同，部分题解如hater先尝试剪枝优化暴力做法，失败后采用正解；Parat_rooper开始未考虑子树节点个数，提交后才修改。
- **算法要点**：
    - 建图：用邻接表存储树结构。
    - DFS预处理：记录节点遍历顺序、子树大小等信息。
    - 询问处理：判断子树大小是否足够，若足够则根据预处理信息直接输出结果。
- **解决难点**：
    - 时间复杂度优化：避免每次询问都进行DFS，通过预处理将时间复杂度从$O(nq)$优化到$O(n + q)$。
    - 子树大小判断：判断询问的$k$是否超过当前节点子树大小，若超过则输出 -1。

### 高评分题解
1. **Anguei（5星）**
    - **关键亮点**：思路清晰，详细解释了预处理和询问的过程，代码注释丰富，对变量命名和使用 `freopen` 等细节有说明。
    - **核心代码**：
```cpp
void dfs(int now)
{
    when[now] = ++time; // 记录什么时候遍历到的
    id[time] = now; // 此时遍历到哪个点
    size[now] = 1; // 初始化子树大小
    for (auto &e : g[now]) // C++11 可好用了
    { 
        int to = e.to;
        if (!vis[to])
        {
            vis[to] = true;
            dfs(to);
            size[now] += size[to]; // 更新子树大小
        }
    }
}
```
核心实现思想：通过DFS遍历树，记录每个节点被遍历到的顺序 `when`、该顺序对应的节点 `id` 以及子树大小 `size`。

2. **jr_zch（4星）**
    - **关键亮点**：解题思路和代码结构清晰，对关键步骤有提示，如输出时编号要减一。
    - **核心代码**：
```cpp
void dfs(int fa,int u){
    siz[u]=1,sor[++cnt]=u,pre[u]=cnt;
    for(int i=0;i<e[u].size();i++){
        int v=e[u][i];
        dfs(u,v),siz[u]+=siz[v];
    }
    return ;
}
```
核心实现思想：DFS遍历树，记录先序遍历结果 `sor`、节点在遍历中的位置 `pre` 以及子树大小 `siz`。

3. **Asphy7xia（4星）**
    - **关键亮点**：对DFS序的概念和性质解释详细，有助于理解，代码规范。
    - **核心代码**：
```cpp
inline void Dfs (int u)
{
    dfn[u] = ++cnt;  //记录dfn
    rk[cnt] = u;  //映射dfn与节点的编号
    siz[u] = 1;
    for (int i = 0; i < pre[u].size (); i++)
    {
        int v = pre[u][i];
        Dfs (v);
        siz[u] += siz[v];  //计算子树大小
    }
}
```
核心实现思想：DFS遍历树，记录节点的DFS序 `dfn`、该序对应的节点 `rk` 以及子树大小 `siz`。

### 最优关键思路或技巧
- **利用树的性质**：利用子树先序遍历是整棵树先序遍历子串的性质，将多次询问转化为一次预处理和常数时间的查询。
- **DFS预处理**：通过一次DFS记录节点遍历顺序、子树大小等信息，避免重复计算。

### 拓展思路
同类型题可考察树的其他遍历方式（如中序、后序遍历）的相关查询，或结合其他数据结构（如线段树、树状数组）进行区间查询等。类似算法套路可用于处理树的路径查询、子树修改等问题。

### 洛谷相似题目推荐
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)
3. [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)

### 个人心得摘录与总结
- **Parat_rooper**：开始未考虑子树节点个数，提交后才发现问题并修改。总结：做题时要全面考虑问题，特别是输出部分要仔细思考。
- **hater**：先尝试剪枝优化暴力做法，失败后采用正解。总结：当暴力做法超时，可先尝试优化，但要注意特殊数据情况，若不行则考虑正解。 

---
处理用时：31.54秒
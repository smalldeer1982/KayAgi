# 题目信息

# Skipping

## 题目描述

现在已经是3024年了，出题的想法早就枯竭。现今的OI以一种修改后的个人参赛形式进行。比赛有$n$道题，编号从$1$到$n$，一道题有一个分数$a_i$和一个参数$b_i$。最开始，评测系统会把第$1$道题丢给选手。当一个选手拿到第$i$道题，他有两个选择：

- 提交，获得$a_i$分
- 跳过，但他再不能去交这道题了。

接下来，评测系统会把编号最大的符合下述条件的题目$j$丢给选手：

- 如果选手提交了$i$题，那么$j<i$
- 如果选手选择跳过，那么$j\leq b_i$

系统不能给选手一道之前给过的题目。如果系统找不到这样的题，那么比赛结束。特别的，如果选手提交第一题，比赛结束。

请你帮助小p拿到最高的可能得分。

## 样例 #1

### 输入

```
4
2
15 16
2 1
5
10 10 100 100 1000
3 4 1 1 1
3
100 49 50
3 2 2
4
100 200 300 1000
2 3 4 1```

### 输出

```
16
200
100
1000```

# AI分析结果

### 题目内容（已为中文，无需翻译）
现在已经是3024年了，出题的想法早就枯竭。现今的OI以一种修改后的个人参赛形式进行。比赛有$n$道题，编号从$1$到$n$，一道题有一个分数$a_i$和一个参数$b_i$。最开始，评测系统会把第$1$道题丢给选手。当一个选手拿到第$i$道题，他有两个选择：

- 提交，获得$a_i$分
- 跳过，但他再不能去交这道题了。

接下来，评测系统会把编号最大的符合下述条件的题目$j$丢给选手：

- 如果选手提交了$i$题，那么$j<i$
- 如果选手选择跳过，那么$j\leq b_i$

系统不能给选手一道之前给过的题目。如果系统找不到这样的题，那么比赛结束。特别的，如果选手提交第一题，比赛结束。

请你帮助小p拿到最高的可能得分。

### 综合分析与结论
这些题解主要围绕将题目转化为图论问题来解决，核心目标是最大化得分，通过最小化跳过题目的价值总和实现。多数题解采用建图跑最短路的方法，部分使用线段树优化。
- **思路对比**：大部分题解思路是将问题转化为从节点1出发到各节点的最短路问题，通过连边 $(i \to i - 1, 0)$ 和 $(i \to b_i, a_i)$ 来表示操作，最终答案为前缀和减去最短路。部分题解使用线段树维护跳过题目的最小代价。
- **算法要点**：建图跑最短路是主流算法，使用Dijkstra算法求解单源最短路。线段树解法用于优化区间查询和更新操作。
- **解决难点**：关键在于将题目中的操作转化为图的边和权值，以及如何高效计算跳过题目的最小代价。

### 所选题解
- **AquariusZhao（5星）**
    - **关键亮点**：思路清晰，详细阐述了将问题转化为最短路问题的过程，配有图示，便于理解。
    - **核心代码**：
```cpp
// 从节点1跑Dijkstra
q.push({0, 1});
while(!q.empty()){
    int u = q.top().second;
    q.pop();
    if(vis[u]) continue;
    vis[u] = 1;
    for(auto k : e[u]){
        int v = k.first;
        if(dis[v] > dis[u] + k.second){
            dis[v] = dis[u] + k.second;
            q.push({-dis[v], v});
        }
    }
}
```
- **Guchenxi0971（4星）**
    - **关键亮点**：简洁明了地指出问题本质，通过前缀和与最短路结合求解答案，代码注释清晰。
    - **核心代码**：
```cpp
// 建图
for(int i = 1; i <= n; i++){
    cin >> a[i];
    sum[i] = sum[i - 1] + a[i];
}
for(int i = 1; i <= n; i++){
    cin >> x;
    if(i!= n) e[i + 1].pb({i, 0});
    e[i].pb({x, a[i]});
}
// 跑最短路
dj();
// 计算答案
ans = 0;
for(int i = 1; i <= n; i++){
    ans = max(ans, sum[i] - dis[i]);
}
```
- **superl61（4星）**
    - **关键亮点**：提出找拐点的结论，将问题转化为最小化“放弃贡献”，并详细说明构图和求解过程。
    - **核心代码**：
```cpp
// 建图
F(i, 1, n) cin >> a[i], sm[i] = sm[i - 1] + a[i];
F(i, 1, n) cin >> b[i], add(i, b[i], a[i]);
F(i, 2, n) add(i, i - 1, 0);
// 跑最短路
q.push({0, 1});
while(q.size()){
    int u = q.top().second;
    q.pop();
    if(vis[u]) continue;
    vis[u] = 1;
    for(int i = first[u]; i; i = e[i].ne){
        int v = e[i].v, w = e[i].w;
        if(dis[v] > dis[u] + w){
            dis[v] = dis[u] + w;
            q.push({-dis[v], v});
        }
    }
}
// 计算答案
int mx = 0;
F(i, 1, n) mx = max(mx, sm[i] - dis[i]);
```

### 最优关键思路或技巧
- **图论转化**：将题目中的操作转化为图的边和权值，通过最短路算法求解最小代价。
- **前缀和优化**：使用前缀和快速计算区间和，减少重复计算。
- **线段树优化**：对于需要频繁进行区间查询和更新的问题，使用线段树可以将时间复杂度优化到 $O(\log n)$。

### 可拓展之处
同类型题或类似算法套路：
- 其他带有决策选择的路径规划问题，可通过建图转化为最短路问题求解。
- 涉及区间查询和更新的动态规划问题，可使用线段树进行优化。

### 推荐洛谷题目
- P1144 最短路计数
- P3371 【模板】单源最短路径（弱化版）
- P4779 【模板】单源最短路径（标准版）

### 个人心得摘录与总结
- **AquariusZhao**：赛时写了前缀优化建图，赛后发现不需要，提醒我们在解题时要简化思路，避免过度复杂的操作。
- **Xy_top**：赛时特判 $b_1 = 1$ 时没输出空格导致掉大分，强调了在比赛中要注意细节，避免因小错误丢分。
- **superl61**：考场上猜结论并验证，对于转移顺序无明显规律的题考虑构图，遇到最大化问题尝试转化为最小化问题，为我们提供了解题的思路和方法。 

---
处理用时：35.29秒
# 题目信息

# Checkposts

## 题目描述

你的城市有 $n$ 个路口。路口之间有一条单程道路。作为城市的市长，你必须确保所有路口的安全。

为了确保安全，你必须建造一些警察检查站。一个检查站只能建在一个路口。 如果有一个检查站在 $i$ 路口，保护 $j$ 的条件是：$i==j$ 或者警察巡逻车可以从 $i$ 走到 $j$，并且能回到 $i$。

建造检查站要花一些钱。 由于城市的某些地区比其他地区更昂贵，在某些路口修建检查站可能比其他路口花费更多的钱。

你需要找到使所有路口安全的最低花费，以及花费与最低价格相等的方案数。

如果其中任何一个路口包含其中一个检查点而不包含在另一个路口中，则两种方式是不同的。

方案数模 $10^9+7$。

## 说明/提示

$1 \leq n \leq 10^5,0 \leq m \leq 3 \times 10^5,0 \leq a_{i} \leq 10^9$。

$1<=u_{i},v_{i}<=n,u≠v$。

**最小花费不需要取模，方案数需要取模。**

## 样例 #1

### 输入

```
3
1 2 3
3
1 2
2 3
3 2
```

### 输出

```
3 1
```

## 样例 #2

### 输入

```
5
2 8 0 6 0
6
1 4
1 3
2 4
3 4
4 5
5 1
```

### 输出

```
8 2
```

## 样例 #3

### 输入

```
10
1 3 2 2 1 3 1 4 10 10
12
1 2
2 3
3 1
3 4
4 5
5 6
5 7
6 4
7 3
8 9
9 10
10 9
```

### 输出

```
15 6
```

## 样例 #4

### 输入

```
2
7 91
2
1 2
2 1
```

### 输出

```
7 1
```

# AI分析结果

### 题目内容
#### 检查点

### 题目描述
你的城市有 $n$ 个路口，路口之间有单向道路。作为市长，你要确保所有路口安全，需建造一些警察检查站，且一个检查站只能建在一个路口。若在 $i$ 路口建检查站，能保护 $j$ 路口的条件是：$i == j$ 或者警察巡逻车可以从 $i$ 走到 $j$ 并回到 $i$。

建造检查站有花费，不同路口花费不同。你需要找到让所有路口安全的最低花费，以及花费与最低价格相等的方案数。若两种方案中存在某个路口，一个方案包含该路口的检查站，另一个不包含，则这两种方案不同。方案数需对 $10^9 + 7$ 取模。

### 说明/提示
$1 \leq n \leq 10^5$，$0 \leq m \leq 3 \times 10^5$，$0 \leq a_{i} \leq 10^9$。
$1\leq u_{i}, v_{i} \leq n$，$u \neq v$。
**最小花费不需要取模，方案数需要取模。**

### 样例 #1
#### 输入
```
3
1 2 3
3
1 2
2 3
3 2
```
#### 输出
```
3 1
```

### 样例 #2
#### 输入
```
5
2 8 0 6 0
6
1 4
1 3
2 4
3 4
4 5
5 1
```
#### 输出
```
8 2
```

### 样例 #3
#### 输入
```
10
1 3 2 2 1 3 1 4 10 10
12
1 2
2 3
3 1
3 4
4 5
5 6
5 7
6 4
7 3
8 9
9 10
10 9
```
#### 输出
```
15 6
```

### 样例 #4
#### 输入
```
2
7 91
2
1 2
2 1
```
#### 输出
```
7 1
```

### 综合分析与结论
这些题解的核心思路一致，都是先通过 Tarjan 算法求出有向图的强连通分量并缩点，再计算每个强连通分量中的最小点权作为缩点后的点权，其总和即为最小费用；接着统计每个强连通分量中点权与最小点权相同的点数，根据乘法原理，这些点数的乘积就是最小花费的方案数。

### 算法要点
1. **Tarjan 算法**：用于求解有向图的强连通分量，是整个解题的基础。
2. **缩点**：将每个强连通分量缩成一个点，方便后续计算。
3. **统计最小点权和方案数**：在每个强连通分量中找出最小点权，并统计与最小点权相同的点数。

### 解决难点
1. **Tarjan 算法的实现**：需要正确理解和实现 Tarjan 算法，确保能准确找出强连通分量。
2. **方案数的计算**：要注意在统计每个强连通分量中与最小点权相同的点数时，若最小点权更新，点数需重置。同时，方案数计算要对 $10^9 + 7$ 取模。

### 题解评分与选择
|作者|星级|关键亮点|
| ---- | ---- | ---- |
|KEBrantily|4星|思路清晰，代码注释详细，整体结构规范。|
|Farkas_W|4星|对题意分析透彻，代码中使用快速读入和链式前向星存图，有一定优化。|
|LevenKoko|4星|提出在 Tarjan 过程中直接统计答案，可减小常数。|

### 重点代码
#### KEBrantily 的核心代码
```cpp
void tarjan(int x){
    low[x]=dfn[x]=++cnt;
    zhan[++top]=x;vis[x]=1;
    for(int i=head[x];i;i=e[i].nxt){
        int to=e[i].to;
        if(!dfn[to]) tarjan(to),low[x]=min(low[x],low[to]);
        else if(vis[to]) low[x]=min(low[x],dfn[to]);
    }
    if(dfn[x]==low[x]){
        ++t;
        int pre=zhan[top--];
        sum[t]=val[pre];
        vis[pre]=0;num[pre]=t;
        while(pre!=x){
            pre=zhan[top--];
            vis[pre]=0;num[pre]=t;
            sum[t]=min(sum[t],val[pre]);
        }
    }
}
```
核心思想：通过 Tarjan 算法找出强连通分量，同时记录每个强连通分量的最小点权。

#### Farkas_W 的核心代码
```cpp
il void Tarjan(int x)		 	//Tarjan缩点
{
    dfn[x]=low[x]=++cnt;
    q.push(x);
    for(re i=head[x];i;i=next[i])
    {
        int y=go[i];
        if(!dfn[y])Tarjan(y),low[x]=min(low[x],low[y]);
        else if(!c[y])low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x])
    {
        c[x]=++c[0];
        s[c[0]]=a[x];p[c[0]]=1;  			//记录每个强连通分量中点权最小的，数量初始化为1
        while(q.top()!=x)
        {
            c[q.top()]=c[0];
            if(s[c[0]]==a[q.top()])p[c[0]]++;		  	 //如果有一样小的点权，数量+1
            else if(s[c[0]]>a[q.top()])s[c[0]]=a[q.top()],p[c[0]]=1; //如果有更小的点权就更新，数量变为1
            q.pop();
        }
        q.pop();
    }
}
```
核心思想：在 Tarjan 过程中，记录每个强连通分量的最小点权和最小点权的数量。

#### LevenKoko 的核心代码
```cpp
void Tarjan(int x){
    dfn[x]=low[x]=++t;ins[x]=1,sta[top++]=x;
    for(register int i=head[x];i;i=nxt[i])
        if(ins[ver[i]]==0) Tarjan(ver[i]),cmin(low[x],low[ver[i]]);
        else if(ins[ver[i]]==1) cmin(low[x],dfn[ver[i]]);
    if(dfn[x]==low[x]) ++col,mn[col]=0x7fffffff;
    if(dfn[x]==low[x]){
        do{
            --top,++cnt[col],color[sta[top]]=col;ins[sta[top]]=-1;
            if(mn[col]>a[sta[top]])	 mn[col]=a[sta[top]],mc[col]=0;
            if(mn[col]==a[sta[top]]) ++mc[col];//关键部分
        }while(sta[top]!=x);
        ans1+=mn[col];ans2=ans2*mc[col]%ha;//记录答案
    }
}
```
核心思想：在 Tarjan 过程中直接统计每个强连通分量的最小点权、最小点权的数量以及最终的最小费用和方案数。

### 最优关键思路或技巧
- **Tarjan 算法**：是解决有向图强连通分量问题的经典算法，时间复杂度为 $O(n + m)$。
- **缩点思想**：将强连通分量缩成一个点，简化问题，便于后续计算。
- **乘法原理**：用于计算最小花费的方案数，思路清晰且高效。

### 拓展思路
同类型题或类似算法套路：
- 其他涉及强连通分量的问题，如求有向图的必经点、必经边等。
- 图的连通性问题，如无向图的连通分量、双连通分量等。

### 推荐题目
1. [P2194 HXY烧情侣](https://www.luogu.com.cn/problem/P2194)
2. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
3. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)

### 个人心得摘录与总结
- **Farkas_W**：提到此题有双倍经验题 [P2194 HXY烧情侣](https://www.luogu.com.cn/problem/P2194)，并提醒临近 CSP 复赛，祝大家 RP++，还强调写题解不易，希望得到点赞。
- **yangwenbin**：表示从 [P2194](https://www.luogu.com.cn/problem/P2194) 的双倍经验里点进来，一开始看到紫题很慌，但实际题目没区别。还提到不开 long long 在 P2194 卡了一个下午，强调要开 long long。
- **封禁用户**：提到“十年 OI 一场空，不开 long long 见祖宗”，强调开 long long 的重要性。
- **PrincessYR✨～**：提醒“不开 long long 见 zz，多开 long long 见 zz”，同样强调开 long long 的重要性。

总结：多位作者都强调了开 long long 的重要性，同时部分作者指出本题有双倍经验题，可用于练习巩固。 

---
处理用时：53.23秒
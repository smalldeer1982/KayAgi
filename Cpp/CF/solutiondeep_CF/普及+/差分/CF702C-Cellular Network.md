# 题目信息

# Cellular Network

## 题目描述

在直线上给出n个城市的位置(x坐标)和在同一直线上的m个蜂窝塔的位置(x坐标)。所有的塔都以同样的方式工作——它们为所有城市提供蜂窝网络，这些城市位于离塔不超过r的距离处才能被蜂窝网络覆盖。

你的任务是找出使得每个城市都能被蜂窝网络覆盖的最小r值，即每个城市在距离r的范围内至少有一个蜂窝塔。

如果r=0，则塔仅为其所在的位置提供蜂窝网络。一个塔可以为任意数量的城市提供蜂窝网络，但是所有这些城市都必须在距离塔不超过r的距离上。

## 说明/提示

1<=n,m<=10^5

-10^9<=a[i]<=10^9

-10^9<=b[j]<=10^9

## 样例 #1

### 输入

```
3 2
-2 2 4
-3 0
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 3
1 5 10 14 17
4 11 15
```

### 输出

```
3
```

# AI分析结果



### 题目重写
**Cellular Network**

#### 题目描述
在一条直线上给出n个城市的位置（x坐标）和m个蜂窝塔的位置（x坐标）。所有塔以相同方式工作——当城市位于塔的r距离范围内时会被覆盖。求覆盖所有城市的最小r值。

#### 输入格式
- 第一行：n和m
- 第二行：n个城市的坐标
- 第三行：m个塔的坐标

#### 输出格式
最小r值

#### 样例
**样例1**  
输入：
```
3 2
-2 2 4
-3 0
```
输出：
```
4
```

**样例2**  
输入：
```
5 3
1 5 10 14 17
4 11 15
```
输出：
```
3
```

---

### 题解综合分析
#### 关键思路对比
所有题解均基于以下核心思路：
1. **排序预处理**：对城市和蜂窝塔坐标排序
2. **最近塔查找**：对每个城市使用二分查找找到最近的左右两塔
3. **取最大距离**：所有城市与其最近塔距离的最大值即为答案

#### 最优解提炼
**关键技巧**：
1. **排序+二分查找**：利用`lower_bound`快速定位最近塔
2. **边界处理**：处理塔全在左侧/右侧的特殊情况
3. **贪心策略**：每个城市只需考虑最近的左右两塔

---

### 精选题解 (4星以上)

#### 1. 作者：shucai (5星)
**亮点**：
- 代码简洁高效，直接使用STL的`lower_bound`
- 完整处理所有边界情况
- 时间复杂度O(n log m)，最优实现

**核心代码**：
```cpp
sort(a, a+n); sort(b, b+m);
int ans = 0;
for (int i=0; i<n; ++i) {
    auto it = lower_bound(b, b+m, a[i]);
    if (it == b+m) ans = max(ans, a[i]-b[m-1]);
    else if (it == b) ans = max(ans, *it -a[i]);
    else ans = max(ans, min(*it-a[i], a[i]-*(it-1)));
}
```

#### 2. 作者：When (4星)
**亮点**：
- 代码可读性极佳
- 完整注释说明二分边界处理
- 使用C风格数组优化缓存

**核心代码**：
```cpp
sort(c+1, c+n+1); sort(t+1, t+m+1);
for(int i=1; i<=n; ++i) {
    int pos = lower_bound(t+1, t+m+1, c[i]) - t;
    if(pos > m) minn = max(minn, c[i]-t[m]);
    else if(pos == 1) minn = max(minn, t[1]-c[i]);
    else minn = max(minn, min(t[pos]-c[i], c[i]-t[pos-1]));
}
```

#### 3. 作者：ImposterAnYu (4星)
**亮点**：
- 双指针优化版实现
- 预处理思路清晰
- 时间复杂度O(n log n + m log m)

**核心代码**：
```cpp
sort(a, a+n); sort(b, b+m);
int x = 0, ans = 0;
for (int i=0; i<n; ++i) {
    while(x < m && b[x] < a[i]) x++;
    int d1 = (x>0) ? a[i]-b[x-1] : INF;
    int d2 = (x<m) ? b[x]-a[i] : INF;
    ans = max(ans, min(d1, d2));
}
```

---

### 关键技巧总结
1. **排序预处理**：必须对塔坐标排序以使用二分查找
2. **二分边界处理**：
   - `lower_bound`返回的迭代器需判断是否在首/尾位置
   - 当塔全在左侧时取最后一个塔，全在右侧时取第一个塔
3. **距离计算优化**：每个城市只需计算左右相邻两塔的距离

---

### 同类题目推荐
1. **P1904 覆盖**（二分答案经典题）
2. **P3743 kotori的设备**（二分答案+覆盖判断）
3. **P1314 聪明的质检员**（二分答案+前缀和优化）

---

### 调试经验摘录
1. **边界值处理**：`lower_bound`返回m时需要取b[m-1]
2. **数据类型陷阱**：坐标差可能超过int范围，需用long long
3. **排序必要性**：忘记排序塔坐标会导致二分失效
4. **特殊测试用例**：如城市在全部塔的左侧/右侧时需单独验证

> **莫奈的崖径**提到：初始化时若将边界值设为0x3f3f3f3f会导致某些大数据出错，改用0x3f3f3f3f3f3f3f3f后解决。这提示处理极大值时需注意数据范围。

---
处理用时：54.07秒
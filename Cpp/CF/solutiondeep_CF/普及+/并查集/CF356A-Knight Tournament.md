# 题目信息

# Knight Tournament

## 题目描述

（题目大意）：有n个骑士，他们每个人都被从1-n进行编号，他们现在需要进行一次比赛，且总共会进行m场比赛。每场比赛会在编号在Li-Ri这段区间内的骑士之间举行，对于每场比赛，它的胜利者的编号为Xi，其他的骑士会出局，之后无法进行比赛。最后留下的骑士就是这次比赛的最终胜利者。比赛结束后，每个骑士都想知道他被哪一个骑士击败了，请你告诉他们。

## 样例 #1

### 输入

```
4 3
1 2 1
1 3 3
1 4 4
```

### 输出

```
3 1 4 0 ```

## 样例 #2

### 输入

```
8 4
3 5 4
3 7 6
2 8 8
1 8 1
```

### 输出

```
0 8 4 6 4 8 6 1 ```

# AI分析结果

### 题解综合分析与结论
这些题解提供了多种解决骑士比赛问题的方法，主要围绕如何高效处理区间覆盖和跳过已出局骑士展开。

#### 思路对比
- **倒序处理+线段树**：多个题解采用此思路，将操作倒序，用线段树进行区间覆盖，保证每个骑士记录的是最早将其击败的骑士，时间复杂度为 $O((m + n)\log n)$。
- **并查集**：利用并查集快速跳过已出局的骑士，避免重复遍历，时间复杂度接近 $O(n)$。
- **其他方法**：还包括使用set、树状数组+二分、珂朵莉树、FHQ Treap等方法，但相对不那么主流。

#### 算法要点对比
- **线段树**：需实现区间修改、单点查询，使用懒标记优化。
- **并查集**：核心是 `find` 函数，用于快速找到下一个未出局的骑士。

#### 解决难点对比
- **避免重复覆盖**：倒序处理和并查集都可有效解决该问题。
- **跳过胜利者**：各题解都有相应的特判处理。

### 高评分题解
1. **作者：Yukinoshita_Yukino (赞：9) - 5星**
    - **关键亮点**：思路清晰，使用并查集简洁地解决问题，代码可读性高。
    - **核心代码**：
```cpp
int find(int x)
{
    return x==f[x]?x:f[x]=find(f[x]);
}
for(int i=find(l);i<=r;i=find(i+1))
{
    if(i!=x)
    {
        ans[i]=x;
        f[i]=i+1;	
    }
}
```
    - **核心思想**：`find` 函数用于找到下一个未出局的骑士，在遍历区间时跳过已出局的骑士。
2. **作者：Elma_ (赞：8) - 5星**
    - **关键亮点**：思路巧妙，倒序处理操作，用线段树进行区间覆盖，复杂度合理。
    - **核心代码**：
```cpp
inline void modify(int x, int l, int r, int L, int R, int k) {
    if (l >= L && r <= R) {
        tag[x] = k; return;
    }
    int mid = (l + r) >> 1;
    pushdown(x);
    if (L <= mid) modify(ls, l, mid, L, R, k);
    if (R > mid) modify(rs, mid + 1, r, L, R, k);
}
for (int i = m;i >= 1;i--) {
    if (q[i].l < q[i].x) tree.modify(1, 1, n, q[i].l, q[i].x - 1, q[i].x);
    if (q[i].r > q[i].x) tree.modify(1, 1, n, q[i].x + 1, q[i].r, q[i].x);
}
```
    - **核心思想**：倒序遍历操作，对每个操作的区间进行线段树区间覆盖。
3. **作者：Nukumizu_Kaju (赞：6) - 4星**
    - **关键亮点**：详细解释了并查集的思路，代码实现清晰。
    - **核心代码**：
```cpp
int find(int x) {
    if (father[x] == x) {
        return x;
    }
    return father[x] = find(father[x]);
}
for (int j = lt; j <= rt;) {
    if (!sl[j]) {
        if (color == j) {
            j++;
            continue;
        }
        father[j] = j + 1;
        sl[j] = color;
    }
    j = find(j);
}
```
    - **核心思想**：使用并查集跳过已出局的骑士，标记被击败的骑士。

### 最优关键思路或技巧
- **倒序处理**：将操作倒序，可将“最早覆盖”问题转化为“最晚覆盖”问题，便于处理。
- **并查集优化**：利用并查集快速跳过已出局的骑士，避免重复遍历，降低时间复杂度。

### 拓展思路
同类型题或类似算法套路：
- 区间修改、单点查询问题，可使用线段树、树状数组等数据结构。
- 涉及跳过已处理元素的问题，可考虑使用并查集优化。

### 洛谷推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
3. [P2391 白雪皑皑](https://www.luogu.com.cn/problem/P2391)

### 个人心得摘录与总结
- **Letriomphant7396**：一开始写暴力和链表都超时，后得知正解是并查集。总结为对于此类区间修改问题，不能盲目暴力，可考虑并查集等优化方法。
- **Binary_Lee**：想练习并查集而做此题，提醒注意数组大小，避免RE。总结为做题时要注意数据范围，防止数组越界。 

---
处理用时：28.70秒
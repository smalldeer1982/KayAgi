# 题目信息

# Two Sets

## 题目描述

> 给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足：
> * 若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；
> * 若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。

## 样例 #1

### 输入

```
4 5 9
2 3 4 5
```

### 输出

```
YES
0 0 1 1
```

## 样例 #2

### 输入

```
3 3 4
1 2 4
```

### 输出

```
NO
```

# AI分析结果

### 题目翻译
#### 两个集合

### 题目描述
给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足：
* 若数字 $x$ 在集合 $A$ 中，那么数字 $a - x$ 也在集合 $A$ 中；
* 若数字 $x$ 在集合 $B$ 中，那么数字 $b - x$ 也在集合 $B$ 中。

### 样例 #1
#### 输入
```
4 5 9
2 3 4 5
```
#### 输出
```
YES
0 0 1 1
```

### 样例 #2
#### 输入
```
3 3 4
1 2 4
```
#### 输出
```
NO
```

### 综合分析与结论
这些题解主要围绕如何将 $n$ 个不同数字分配到 $A$ 和 $B$ 两个集合展开，核心是满足给定的匹配规则。不同题解采用了不同的算法，主要有贪心算法和并查集算法，还有使用 2 - SAT 算法的。

|作者|思路|算法要点|解决难点|评分|
|----|----|----|----|----|
|pufanyi|贪心策略，每次选未匹配数中的最小值 $x$，优先让 $x$ 与 $a - x$ 匹配|用 `set` 存储数字，通过 `lower_bound` 查找匹配数|解决 $a - x$ 和 $b - x$ 都存在时的匹配选择问题|4星|
|D_14134|对每个数 $x$ 分 4 种情况讨论，用并查集维护数字间的关系|用 `map` 记录数字位置，通过并查集合并满足条件的数字|处理 $a - x$ 和 $b - x$ 都存在时的分配问题|4星|
|BreakPlus|先找出不能放入任何集合的数，将必须在同一集合的数连边构图，用 `must` 数组记录元素状态，对连通块染色|使用 `map` 记录数字位置，通过 DFS 构建连通块|处理连通块内元素状态冲突问题|3星|
|Fading|将问题转化为 2 - SAT 问题，枚举每个数 $x$，根据 $a - x$ 和 $b - x$ 的存在情况建图，用 Tarjan 算法求解|用 `map` 记录数字位置，构建有向图，使用 Tarjan 算法求强连通分量|处理复杂的逻辑约束关系|3星|
|滑不拉稽|对每个数 $x$ 分情况讨论，用并查集维护集合关系|用 `map` 记录数字位置，根据不同情况合并数字|处理 $a - x$ 和 $b - x$ 都存在时的进一步讨论|4星|
|UnyieldingTrilobite|根据 $a - x$ 和 $b - x$ 的存在情况用并查集维护集合关系|用 `unordered_map` 记录数字位置，合并满足条件的数字|判断两个集合是否连通|3星|
|傅思维666|对每个数 $x$ 分 4 种情况讨论，用并查集维护数字间的关系|用 `map` 记录数字位置，通过并查集合并满足条件的数字|处理 $a - x$ 和 $b - x$ 都存在时的分配问题|4星|

### 所选题解
- **pufanyi（4星）**
    - **关键亮点**：贪心思路清晰，代码简洁，通过贪心策略解决了匹配选择的难题。
    - **核心代码**：
```cpp
while(!ss.empty())
{
    set<EE>::iterator it = ss.begin();
    EE tx = *it;
    tx.x = a - it->x;
    set<EE>::iterator x = ss.lower_bound(tx);
    if(x!= ss.end() && x->x + it->x == a)
    {
        ans[x->id] = ans[it->id] = 0;
        if(x->id!= it->id)
        {
            ss.erase(x);
            ss.erase(it);
        }
        else
            ss.erase(x);
    }
    else
    {
        tx.x = b - it->x;
        x = ss.lower_bound(tx);
        if(x!= ss.end() && x->x + it->x == b)
        {
            ans[x->id] = ans[it->id] = 1;
            if(x->id!= it->id)
                ss.erase(it);
            ss.erase(x);
        }
        else
            return puts("NO"), 0;
    }
}
```
    - **核心实现思想**：每次从 `set` 中取出最小的未匹配数，先尝试与 $a - x$ 匹配，若匹配成功则将它们放入集合 $A$ 并从 `set` 中移除；若不成功则尝试与 $b - x$ 匹配，若匹配成功则将它们放入集合 $B$ 并从 `set` 中移除；若都不成功则输出 `NO`。

- **D_14134（4星）**
    - **关键亮点**：思路清晰，通过分类讨论和并查集有效解决了数字分配问题。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    if(pre[a-val[i]]>0) hb(i,pre[a-val[i]]);
    else hb(i,n+1);
    if(pre[b-val[i]]>0) hb(i,pre[b-val[i]]);
    else hb(i,0);
}
int head=find(0),tail=find(n+1);
if(head!=tail)
{
    printf("YES\n");
    for(int i=1;i<=n;i++)
    {
        if(i!=1) printf(" ");
        if(find(i)==head) printf("0");
        else printf("1");
    }
}
else printf("NO");
```
    - **核心实现思想**：遍历每个数字，若 $a - x$ 存在则将 $x$ 与 $a - x$ 合并，若不存在则将 $x$ 与虚点 $n + 1$ 合并；若 $b - x$ 存在则将 $x$ 与 $b - x$ 合并，若不存在则将 $x$ 与虚点 $0$ 合并。最后判断虚点 $0$ 和 $n + 1$ 是否连通，若不连通则输出 `YES` 并根据数字所属集合输出结果，否则输出 `NO`。

- **滑不拉稽（4星）**
    - **关键亮点**：对复杂情况进行详细讨论，用并查集维护集合关系，代码实现清晰。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i)
{
    flag1=0;flag2=0;
    int x=val[i];
    if(pre[a-x]>0) flag1=1;
    if(pre[b-x]>0) flag2=1;
    if( (!flag1) && (!flag2) ) {puts("NO");return 0;}
    else if( flag1 && (!flag2) ) merge(i,pre[a-x]),merge(i,0);
    else if( (!flag1) && flag2 ) merge(i,pre[b-x]),merge(i,n+1);
    else
    {
        if(pre[b-(a-x)]>0)merge(i,pre[a-x]),merge(i,pre[b-(a-x)]);
        else if(pre[a-(b-x)]>0)merge(i,pre[b-x]),merge(i,pre[a-(b-x)]);
    }
}
int A=find(0),B=find(n+1);
if(A==B){puts("NO");return 0;}
else
{
    puts("YES");
    for(int i=1;i<=n;++i)
    {
        find(i)==A?printf("0 "):printf("1 ");
    }
}
```
    - **核心实现思想**：遍历每个数字，根据 $a - x$ 和 $b - x$ 的存在情况进行分类讨论。若都不存在则输出 `NO`；若只有 $a - x$ 存在则将 $x$ 与 $a - x$ 合并到集合 $A$；若只有 $b - x$ 存在则将 $x$ 与 $b - x$ 合并到集合 $B$；若都存在则进一步判断 $b - (a - x)$ 或 $a - (b - x)$ 是否存在，根据情况合并。最后判断集合 $A$ 和 $B$ 是否连通，若连通则输出 `NO`，否则输出 `YES` 并根据数字所属集合输出结果。

### 最优关键思路或技巧
- **贪心策略**：如 pufanyi 的题解，每次选择未匹配数中的最小值，优先让其与 $a - x$ 匹配，简化了匹配选择问题。
- **并查集**：多个题解使用并查集维护数字间的集合关系，能高效处理元素的合并和查询操作，解决了数字分配和冲突问题。
- **分类讨论**：对每个数 $x$ 根据 $a - x$ 和 $b - x$ 的存在情况进行分类讨论，使问题处理更加清晰有条理。

### 拓展思路
同类型题可能会有更多的集合或更复杂的匹配规则，可以继续使用并查集或 2 - SAT 等算法解决。类似算法套路包括根据元素间的约束关系构建图或使用数据结构维护元素关系，通过遍历和判断来求解问题。

### 洛谷相似题目推荐
1. [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)：考察并查集的应用，通过并查集维护元素间的连通关系。
2. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：可以使用并查集或 2 - SAT 算法解决，处理元素间的矛盾关系。
3. [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)：需要使用并查集维护多个集合和元素间的关系，解决复杂的逻辑判断问题。

### 个人心得摘录与总结
- **傅思维666**：提到先思考难题的处理方法，再回推思路，这是一种逆向思维方式。还提到用 `set` 直接模拟维护挂了，提醒我们在选择算法和数据结构时要谨慎。 

---
处理用时：52.58秒
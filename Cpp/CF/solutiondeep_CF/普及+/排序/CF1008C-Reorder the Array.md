# 题目信息

# Reorder the Array

## 题目描述

**题目大意：**

给定一个序列，序列里的元素可以以任意顺序重新排好

序列里某位置排序后的数可能会大于原数，问这样的位置最多能有多少个

## 样例 #1

### 输入

```
7
10 1 1 1 5 5 3
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5
1 1 1 1 1
```

### 输出

```
0
```

# AI分析结果



# Reorder the Array

## 题目描述

**题目大意：**

给定一个序列，序列里的元素可以以任意顺序重新排列。求重新排列后，满足新元素大于原元素的位置的最大数量。

## 样例 #1

### 输入
```
7
10 1 1 1 5 5 3
```

### 输出
```
4
```

## 样例 #2

### 输入
```
5
1 1 1 1 1
```

### 输出
```
0
```

---

## 题解综合分析

### 最优思路总结
核心贪心策略：**排序后通过双指针匹配**。将数组排序后，用较小的元素尽可能匹配较大的元素，从而最大化满足条件的位置数。另一种巧妙思路是**用总数减去最大频率元素出现次数**，其正确性基于鸽巢原理。

### 高星题解推荐

1. **小坦克（★★★★★）**
   - **关键思路**：升序排序后，用双指针贪心匹配。维护指针 `j` 表示当前可用的大数，遍历数组时若 `a[i] > a[j]` 则计数。
   - **代码亮点**：简洁高效，时间复杂度 $O(n \log n)$。
   ```cpp
   sort(a, a + n);
   int j = 0, ans = 0;
   for (int i = 1; i < n; i++) {
       if (a[i] > a[j]) {
           j++;
           ans++;
       }
   }
   ```

2. **BigJoker（★★★★★）**
   - **关键思路**：降序排序后，从后向前贪心匹配。维护指针 `r` 表示当前可用的大数，遍历时若 `a[r] > a[i]` 则移动指针。
   - **代码亮点**：逆向思维，代码极简。
   ```cpp
   sort(a + 1, a + 1 + n);
   int r = n, ans = 0;
   for (int i = n; i >= 1; i--) {
       if (a[r] > a[i]) r--;
   }
   ans = n - r;
   ```

3. **\_Aghost（★★★★☆）**
   - **关键思路**：统计元素最大出现频率 `maxn`，结果为 `n - maxn`。
   - **代码亮点**：时间复杂度 $O(n)$，但需理解其数学原理。
   ```cpp
   map<int, int> cnt;
   for (int x : a) maxn = max(maxn, ++cnt[x]);
   ans = n - maxn;
   ```

### 关键技巧与拓展
- **同类题目推荐**：
  - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心+优先队列。
  - [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：贪心字符串处理。
  - [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)：活动选择类贪心。

### 调试心得
- 验证时注意**重复元素的处理**，例如样例2全相同的情况。
- 贪心算法的正确性需通过反证法或数学归纳验证。

---
处理用时：247.26秒
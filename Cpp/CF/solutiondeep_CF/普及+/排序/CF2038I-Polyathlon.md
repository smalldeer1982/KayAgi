# 题目信息

# Polyathlon

## 题目描述

伯兰（Berland）是今年国际大学生多项全能比赛的主办国！与双项全能是两个项目的比赛类似，多项全能是多个项目的比赛。今年有 $m$ 个项目。此外，还有 $n$ 名参赛者。项目编号从 $1$ 到 $m$ ，参赛者编号从 $1$ 到 $n$ 。

有些参赛者擅长多项运动。我们还知道，对于每一对参与者来说，至少存在一种运动，即其中一人擅长该运动，而另一人不擅长。

比赛项目的顺序在开幕式上决定。从历史上看，它是由万能的随机数生成器决定的。掷出一个从 $1$ 到 $m$ 的随机数 $x$ 。比赛从 $x$ 开始，然后是 $(x \bmod m + 1)$ ，接着是 $((x + 1) \bmod m + 1)$ ，以此类推。

每个项目的比赛规则如下。如果剩下的所有参赛者（所有尚未被淘汰的参赛者）都不擅长该项目，则所有人都进入下一个项目。否则，所有熟练的参赛者都进入下一个项目，所有不熟练的参赛者都被淘汰出局。一旦比赛只剩下一名参赛者，比赛即告结束，该参赛者即为获胜者。

作为比赛的组织者，您事先对比赛可能出现的结果很好奇。对于每个运动项目 $x$ ，如果比赛从运动项目 $x$ 开始，请打印获胜者的编号。

## 样例 #1

### 输入

```
3 5
10010
01100
10101```

### 输出

```
3 2 3 1 3```

# AI分析结果



### 题目内容重写

# 多项全能赛

## 题目描述

伯兰（Berland）是今年国际大学生多项全能比赛的东道主！与双项全能是两个项目的比赛类似，多项全能是多个项目的比赛。今年共有 $m$ 个项目，$n$ 名参赛者。项目编号为 $1$ 到 $m$，参赛者编号为 $1$ 到 $n$。

每个参赛者擅长某些项目。已知对于任意两个不同参赛者，至少存在一个项目，其中一人擅长而另一人不擅长。

比赛顺序由随机数生成器决定：随机选择起始项目 $x$，后续按 $(x \bmod m + 1)$ 循环进行。每个项目的规则如下：如果当前所有剩余参赛者都不擅长该项目，则无人淘汰；否则，不擅长者被淘汰。当只剩一人时比赛结束。

你需要对每个可能的起始项目 $x$，输出最终的获胜者编号。

---

### 题解综合分析

#### 最优思路总结
1. **字典序最大原则**：获胜者对应从起始位置循环展开的字典序最大字符串。
2. **基数排序优化**：从高位到低位进行多轮基数排序，每轮根据当前位将选手重新排列，最终得到字典序最大的选手。
3. **循环展开技巧**：通过将字符串复制延长，简化循环队列的字典序比较。

#### 高分题解推荐

1. **鳶一折纸（五星）**
   - **亮点**：使用 LSD 基数排序，从低位到高位动态维护排序结果，复杂度 $O(nm)$。
   - **实现核心**：
     - 倒序处理每个项目位置（从右向左）
     - 每轮将当前位为 1 的选手前移，保持相对顺序
     - 通过两次遍历完成基数排序的分组

   ```cpp
   for (int i = m; i >= 1; --i) {
       tot = 0;
       // 收集当前位为1的选手
       for (int j = 1; j <= n; ++j) if (sq[a[j]][i]) b[++tot] = a[j];
       // 收集当前位为0的选手
       for (int j = 1; j <= n; ++j) if (!sq[a[j]][i]) b[++tot] = a[j];
       // 更新排序数组
       swap(a, b);
   }
   ```

2. **xyz105（四星半）**
   - **亮点**：直接使用 `sort` 处理初始排序，通过动态维护排序数组实现循环位移的答案推导。
   - **技巧**：利用循环位移后字符串的排序特性，每次将末位字符前移并重新分组排序。

3. **Register_int（四星）**
   - **亮点**：极简代码实现，通过复制字符串处理循环比较，直接基数排序。

---

### 关键代码实现（鳶一折纸解法）

```cpp
// 预处理阶段：计算每个项目位置对应的排序
for (int i = m; i >= 1; --i) {
    vector<int> tmp;
    // 将当前位为1的选手前移
    for (auto x : cur_order) if (s[x][i-1] == '1') tmp.push_back(x);
    for (auto x : cur_order) if (s[x][i-1] == '0') tmp.push_back(x);
    cur_order = tmp;
    ans[i] = cur_order.front(); // 当前轮次最大值
}
```

---

### 相似题目推荐
1. [P2870 [USACO07DEC] Best Cow Line G](https://www.luogu.com.cn/problem/P2870)  
   （字典序贪心，循环字符串处理）
2. [P1368 【模板】最小表示法](https://www.luogu.com.cn/problem/P1368)  
   （循环字符串字典序最小表示）
3. [P4051 [JSOI2007] 字符加密](https://www.luogu.com.cn/problem/P4051)  
   （循环字符串排序应用）

---
处理用时：54.92秒
# 题目信息

# Medium Demon Problem (hard version)

## 题目描述

这是该问题的困难版本。两个版本之间的关键区别已用粗体强调。

有一群 $n$ 只蜘蛛聚在一起交换毛绒玩具。一开始，每只蜘蛛手里都有一个毛绒玩具。每年，如果第 $i$ 只蜘蛛至少有一个毛绒玩具，它会把自己的一个毛绒玩具送给第 $r_i$ 只蜘蛛。否则，它会选择不做任何事情。注意，所有毛绒玩具的转移同时进行。在这个版本中，每只蜘蛛在任何时候都可以拥有多个毛绒玩具。

如果今年（在进行交换之前）每只蜘蛛拥有的毛绒玩具数量与去年（交换之前）相同，那么这一年就是稳定的。需要注意的是，第一年不可能是稳定的。

请找出施行直到稳定的第一个年份。

## 说明/提示

对于第二个测试用例：

- 第一年，每只蜘蛛拥有的毛绒玩具数量为：$[1, 1, 1, 1, 1]$。接下来进行第一次交换。
- 第二年，每只蜘蛛拥有的毛绒玩具数量仍为：$[1, 1, 1, 1, 1]$。由于这个数组与去年相同，所以第二年是稳定的。

对于第三个测试用例：

- 第一年，每只蜘蛛拥有的毛绒玩具数量为：$[1, 1, 1, 1, 1]$。接下来进行第一次交换。
- 第二年，每只蜘蛛拥有的毛绒玩具数量变为：$[1, 2, 1, 1, 0]$。随后进行第二次交换。
- 第三年，每只蜘蛛拥有的毛绒玩具数量变为：$[1, 3, 0, 1, 0]$。随后进行第三次交换。
- 第四年，每只蜘蛛拥有的毛绒玩具数量变为：$[1, 4, 0, 0, 0]$。随后进行第四次交换。
- 第五年，每只蜘蛛拥有的毛绒玩具数量仍为：$[1, 4, 0, 0, 0]$。由于这个阵列与上一年相同，第五年是稳定的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2
2 1
5
2 3 4 5 1
5
2 1 4 2 3
5
4 1 1 5 4
10
4 3 9 1 6 7 9 10 10 3```

### 输出

```
2
2
5
5
5```

# AI分析结果



【题目翻译】

# Medium Demon 问题（困难版）

## 题目描述

这是该问题的困难版本。两个版本之间的关键差异已用粗体强调。

一群 $n$ 只蜘蛛聚在一起交换毛绒玩具。初始时每只蜘蛛各有一个玩具。每年，若第 $i$ 只蜘蛛至少有一个玩具，它会将自己的一个玩具送给第 $r_i$ 只蜘蛛。否则不行动。所有转移同时进行。**在此版本中，蜘蛛可持有多个玩具**。

若某年（交换前）的玩具数量与去年（交换前）相同，则该年是稳定的。第一年不可能是稳定的。

请找出首个稳定的年份。

## 样例分析

样例二解释：第一年交换后数量仍为全1，故第二年为稳定年。  
样例三解释：经过四次传递后第五年达到稳定。

---

【题解综合分析】

本题的核心在于分析蜘蛛间的传递关系形成的基环森林结构。通过拓扑排序处理非环结点，计算各子树的总贡献，最终由最大子树贡献决定稳定年份。关键点如下：

1. **基环树结构**：每个蜘蛛指向唯一目标，形成由环和树组成的结构。
2. **拓扑排序处理树结构**：非环结点的玩具会逐层传递到环上的结点。
3. **贡献累计机制**：每个结点的总贡献等于其子树玩具数之和。
4. **稳定年份计算**：最大子树贡献值+2（包含初始交换年和稳定触发年）。

---

【高星题解推荐】

### FishPressedCoins（4星）
**亮点**：清晰的拓扑排序实现，通过向量存储非环结点，代码简洁。
```cpp
for (auto t : V) {
    sum[arr[t]] += sum[t]; // 累加子树贡献
    ans = max(ans, sum[t]);
}
cout << ans + 2 << '\n';
```

### Peaky（4星）
**亮点**：双版本对比分析，代码变量命名规范。
```cpp
while (!q.empty()) {
    int u = q.front(), v = r[u]; q.pop();
    ans = max(ans, ++d[u]);
    inq[v]--; d[v] += d[u]; // 贡献累加
    if (!inq[v]) q.push(v);
}
```

### Kexi_（4星）
**亮点**：模块化设计，使用命名空间封装逻辑。
```cpp
inline int topsort() {
    // 处理拓扑排序并累计子树大小
    siz[to] += siz[now];
    ans = max(ans, siz[now]);
}
```

---

【关键技巧总结】

1. **基环树分解**：将图分解为环和树结构，优先处理树部分。
2. **拓扑排序应用**：处理非环结点，动态维护入度队列。
3. **贡献累加模式**：树结构的贡献以和形式向上传递，区别于简单版的最大值传递。
4. **年份推导**：最大子树贡献值对应传递总轮数，结果需+2（初始年和稳定触发年）。

---

【相似题目推荐】

1. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)  
   **考察点**：基环树找最小环，DFS/拓扑排序应用。

2. [P2607 [ZJOI2008]骑士](https://www.luogu.com.cn/problem/P2607)  
   **考察点**：基环树动态规划，处理环上决策。

3. [P3533 急流](https://www.luogu.com.cn/problem/P3533)  
   **考察点**：基环树结构分析，贪心策略。

---

【题解心得摘录】

> "环上所有结点的玩具数必须相等，环外树结构的贡献决定了最终结果。" —— FishPressedCoins  
> 调试关键：确保拓扑排序正确剥离非环结点，贡献累加方向正确。

> "两版本差异仅在贡献累加方式（和 vs 最大值），代码仅修改一行。" —— Peaky  
> 对比分析帮助快速理解问题变种。

---
处理用时：274.46秒
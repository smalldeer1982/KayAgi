# 题目信息

# Coprocessor

## 题目描述

给你 $N$ 个任务，任务从 $0$ 开始标号，有些只能用主处理器处理，另外的任务只能用副处理器处理。其中存在 $M$ 个依赖关系，如果任务 $i$ 依赖于任务 $j$，那么称 $j$ 是 $i$ 的前继任务。

主处理器和副处理器都可以一次处理很多个任务。一个任务能被处理的条件为其所有的前继任务已经被执行过了，或者前继任务和自己同时被放进同一个处理器处理。


现在给出这些依赖关系和每个任务处理要用的处理器，求副处理器最少运行了几次。保证依赖关系是一张有向无环图。

## 样例 #1

### 输入

```
4 3
0 1 0 1
0 1
1 2
2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 3
1 1 1 0
0 1
0 2
3 0
```

### 输出

```
1
```

# AI分析结果



### 中文题目重写
**题目名称**：协处理器  

**题目描述**  
给定 $N$ 个任务（编号从 $0$ 开始），其中某些任务只能由主处理器处理，其他任务只能由副处理器处理。存在 $M$ 个依赖关系：若任务 $i$ 依赖于任务 $j$，则 $j$ 是 $i$ 的前继任务。  

主处理器和副处理器均可同时处理多个任务。一个任务可被处理的条件是其所有前继任务已被执行，或这些前继任务与当前任务在同一轮副处理器处理中被选中。  

求副处理器最少需要运行多少次。保证依赖关系构成有向无环图（DAG）。  

**输入样例**  
样例1输入：  
```
4 3
0 1 0 1
0 1
1 2
2 3
```  
样例1输出：  
```
2
```  

样例2输入：  
```
4 3
1 1 1 0
0 1
0 2
3 0
```  
样例2输出：  
```
1
```  

---

### 题解分析与结论  
#### 核心思路  
1. **拓扑排序 + 双队列贪心**：  
   - 维护两个队列分别存放主/副处理器的可执行任务。  
   - 优先处理主处理器的队列，尽可能减少副处理器的调用次数。  
   - 每轮主处理器处理完毕后，若副处理器队列非空，则增加一次副处理器调用，并处理所有当前可执行任务。  

2. **关键技巧**：  
   - 输入边的正确建图（任务 $i$ 的前继是 $j$，需建边 $j \rightarrow i$）。  
   - 贪心策略确保每次副处理器处理的任务尽可能多。  

#### 评分较高的题解  
1. **作者：dd_d（4星）**  
   **关键亮点**：  
   - 代码结构清晰，双队列处理逻辑简洁。  
   - 正确处理输入依赖关系，建边方向准确。  
   **核心代码**：  
   ```cpp
   while (!q1.empty()||!q2.empty()) {
       while (!q1.empty()) {
           // 处理主队列任务，更新后续节点的入度
       }
       if (!q2.empty()) ans++;
       while (!q2.empty()) {
           // 处理副队列任务，更新后续节点的入度
       }
   }
   ```

2. **作者：M_CI（4星）**  
   **关键亮点**：  
   - 代码简短，输入处理正确。  
   - 使用标准队列实现，逻辑易读。  
   **核心代码**：  
   ```cpp
   while(q1.size() || q2.size()) {
       while(!q1.empty()) {
           // 主队列处理
       }
       if(q2.size()) ans++;
       while(!q2.empty()) {
           // 副队列处理
       }
   }
   ```

3. **作者：wjh2011（4星）**  
   **关键亮点**：  
   - 使用 `vector` 存储边，代码可读性高。  
   - 明确处理依赖关系，建图正确。  
   **核心代码**：  
   ```cpp
   while (q[0].size() || q[1].size()) {
       while (q[0].size()) {
           // 主队列处理
       }
       if (q[1].size()) ans++;
       while (q[1].size()) {
           // 副队列处理
       }
   }
   ```

---

### 关键实现思想  
1. **输入处理**：  
   ```cpp
   // 示例：输入u和v表示v的前继是u，需建边u→v
   add(u, v); // 将u加入v的前继列表
   in_degree[v]++; // v的入度增加
   ```  
2. **双队列拓扑排序**：  
   - 初始将所有入度为0的任务按处理器类型加入队列。  
   - 主队列处理完毕后，若副队列非空则计数一次，并处理所有副队列任务。  

---

### 扩展与举一反三  
1. **类似问题**：  
   - 多线程任务调度（如 LeetCode 207. 课程表）。  
   - 优先级任务调度（需结合堆优化拓扑排序）。  

2. **推荐题目**：  
   - [洛谷 P1113 杂务](https://www.luogu.com.cn/problem/P1113)（DAG 最长路径）  
   - [洛谷 P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)（拓扑排序+DP）  
   - [洛谷 P6145 任务执行顺序](https://www.luogu.com.cn/problem/P6145)（贪心+拓扑排序）  

---

### 题解中的调试心得  
- **输入顺序陷阱**：  
  部分题解误将输入的依赖关系顺序颠倒（如将 $i$ 和 $j$ 的边建反），导致拓扑排序错误。  
  **教训**：仔细验证输入是否符合“前继指向当前任务”的建图规则。  

- **贪心策略验证**：  
  在样例2中，主处理器任务3的依赖可能被副处理器一次性处理，需确保代码正确处理这种“间接依赖”。

---
处理用时：233.09秒
# 题目信息

# Divide by three, multiply by two

## 题目描述

有一个长度为 $n$ 的数列 $a_i$，要求你将这个数列重排成一个排列 $p_i$，使得对于任意的 $p_i(1 \le i < n)$：



- $p_i \times 2 = p_{i+1}$，或者

- 当 $p_i$ 可以被 $3$ 整除时，$p_i \div 3 = p_{i+1}$。



保证答案存在。

## 说明/提示

在第一个样例中，一种可能的合法排列为 $[9,3,6,12,4,8]$。

## 样例 #1

### 输入

```
6
4 8 6 3 12 9
```

### 输出

```
9 3 6 12 4 8 
```

## 样例 #2

### 输入

```
4
42 28 84 126
```

### 输出

```
126 42 84 28 
```

## 样例 #3

### 输入

```
2
1000000000000000000 3000000000000000000
```

### 输出

```
3000000000000000000 1000000000000000000 
```

# AI分析结果



# Divide by three, multiply by two

## 题目描述

有一个长度为 $n$ 的数列 $a_i$，要求你将这个数列重排成一个排列 $p_i$，使得对于任意的 $p_i(1 \le i < n)$：

- $p_i \times 2 = p_{i+1}$，或者
- 当 $p_i$ 可以被 $3$ 整除时，$p_i \div 3 = p_{i+1}$。

保证答案存在。

---

### 题解综合分析

#### 关键思路总结
通过分析3的因子数量作为排序主键，将数列按以下规则排序：
1. **3的因子数降序排列**：确保优先处理可连续除3的数值
2. **数值升序作为次关键字**：当3因子数相同时，保证乘2操作可衔接后续数值

该策略通过数值的数学特性直接构造合法序列，时间复杂度仅为 $O(n \log n)$，是最高效的解法。

---

### 高星题解推荐

#### 1. yuzhechuan [★★★★★]
**核心思路**：  
计算每个数的3因子数量，按（3因子数降序，数值升序）排序。  
**亮点**：  
- 数学特性利用完美，时间复杂度极低  
- 代码简洁清晰（仅需排序预处理）  

**代码核心**：
```cpp
struct Node { long long val, cnt3; };
bool compare(Node a, Node b) {
    return a.cnt3 != b.cnt3 ? a.cnt3 > b.cnt3 : a.val < b.val;
}
// 预处理：计算每个数的3因子数量后排序
```

#### 2. Islauso [★★★★☆]
**核心思路**：  
建立有向图（满足条件的数对间连边），通过拓扑排序找合法序列。  
**亮点**：  
- 严谨的图论建模思想  
- 附带环存在性的数学证明  

**代码片段**：
```cpp
// 建图逻辑
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (a[i]*2 == a[j] || (a[i]%3 == 0 && a[i]/3 == a[j])) {
            addEdge(i, j); // i -> j 的边
        }
    }
}
// 拓扑排序输出序列
```

---

### 相似题目推荐
1. [CF977D](https://codeforces.com/problemset/problem/977/D)（本题原型，直接练习）  
2. [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098)（构造特定序列）  
3. [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)（拓扑排序应用）  

---

### 心得摘录
- **调试技巧**：在DFS解法中，若不及时设置终止标记（flag），会因回溯导致多次输出（@zhangyuhan）  
- **数学观察**："3因子数递减必然形成链式结构"是排序解法的核心突破点（@yuzhechuan）  
- **复杂度权衡**：当n≤100时，DFS的$O(n!)$复杂度实际可通过剪枝优化（@Tyyyyyy）

---
处理用时：47.05秒
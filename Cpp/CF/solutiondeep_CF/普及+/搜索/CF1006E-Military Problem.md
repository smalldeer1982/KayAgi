# 题目信息

# Military Problem

## 题目描述

在这个问题中你需要帮助伯兰（？？我没找到有Berland这个国家）军队组织他们的指挥系统

伯兰军队中一共有n个军官。第一个官员是军队的指挥官，他并没有任何上级。其他的军官都有且只有一个直接的上级。如果一个军官a是军官b的上级，那么你也可以说军官b就是军官a的下属

如果满足下列条件，那么军官x就是军官y的下属（直接或非直接）：

1.y是x的直接上级 2.x的直接上级是y的下属

举个例子，下图的官员3的下属有:5,6,7,8,9

所以，在伯兰军队的结构中，除了指挥官，其他人都是指挥官的下属

形式上的，让我们把伯兰军队看成一棵拥有n个节点的树，树的节点u就代表了军官u。根（即一号节点）就相当于指挥官

伯兰战争部门命令你对q个查询给出答案。这q个查询会以（ui，ki）的形式给出，ui代表了某个军官，ki是正整数。你需要输出，编号为ui的军官下达命令后，第ki个得知此命令的军官编号是多少，如果传达人数不足ki个，输出-1。

要处理第i个查询，想象一下ui的命令如何我下达到ui的下属。这里使用了典型的DFS（深度优先搜索）算法。

假设现在的军官是a，他要下达一个命令。a军官选择一个军官b——还没有收到这个命令的直接下属（即在树上的一个孩子）。如果有许多这样的直接下属，那么A选择编号最小的那一个。A军官向B军官发出命令。之后，B使用完全相同的方式将命令扩展到它的子树。在B完成命令后，军官A再次选择下一个直接下属（使用相同的策略）。当军官A不能选择任何还没有接到命令的直接下属时，军官A下达命令完成。

让我们看一下下面这个例子（看下面的图）：

如果军官1下达了命令，军官们收到命令的顺序是：1,2,3,5,6,8,7,9,4

如果军官3下达了命令，军官们收到命令的顺序是：3,5,6,8,7,9

如果军官7下达了命令，军官们收到命令的顺序是：7,9

如果军官9下达了命令，军官们收到命令的顺序是：9

你应当分开处理这些查询。一个查询不会影响其他查询的结果。

## 样例 #1

### 输入

```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```

### 输出

```
3
6
8
-1
9
4
```

# AI分析结果



### 题目内容中文翻译

#### 题目名称：军事问题

**题目描述**

你需要帮助伯兰军队组织他们的指挥系统。军队中有n个军官，1号军官是总指挥，没有上级。每个其他军官有且仅有一个直接上级。如果军官x是军官y的直接下属或间接下属（即y在x的上级链上），则称x是y的下属。

军队结构可以视为一棵以1号节点为根的树。你需要处理q个查询，每个查询给出一个军官u_i和一个正整数k_i，要求输出在u_i的子树中进行DFS遍历时，第k_i个被访问的军官编号。若不足k_i个节点，输出-1。

DFS遍历规则：每次选择编号最小的直接下属优先访问。

**输入样例**
```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```
**输出样例**
```
3
6
8
-1
9
4
```

---

### 题解综合分析与结论

所有题解的核心思路均基于**DFS序预处理**，利用子树DFS序的连续性，通过预计算每个节点的进入时间戳和子树大小，将查询优化至O(1)时间复杂度。关键在于以下两点：
1. **子树DFS序的连续性**：以某个节点为根的子树在整棵树的DFS序中是连续的一段。
2. **预处理技术**：通过一次DFS遍历记录每个节点的进入时间戳`dfn`、子树大小`size`，以及时间戳到节点的反向映射`id`。

---

### 高星题解推荐

#### 题解1：Anguei（★★★★★）
**关键亮点**  
- 思路清晰，完整解释了DFS序的连续性和预处理逻辑。
- 代码高效，利用C++11特性简化代码，变量命名规范。
- 正确处理输入顺序，无需额外排序，时间复杂度严格O(n+q)。

**核心代码**  
```cpp
void dfs(int now) {
    when[now] = ++time;
    id[time] = now;
    size[now] = 1;
    for (auto &e : g[now]) { 
        dfs(e.to);
        size[now] += size[e.to];
    }
}
```

#### 题解2：mondayrain（★★★★☆）
**关键亮点**  
- 代码简洁，变量命名直观（如`dfn`、`size`）。
- 利用DFS序直接映射查询，逻辑简明易懂。

**核心代码**  
```cpp
void dfs(int x) {
    dfn[x] = ++cnt;
    rk[cnt] = x;
    siz[x] = 1;
    for (int v : g[x]) {
        dfs(v);
        siz[x] += siz[v];
    }
}
```

#### 题解3：geven（★★★★☆）
**关键亮点**  
- 代码高度简洁，仅用两个数组完成映射。
- 预处理和查询逻辑分离明确，适合快速理解。

**核心代码**  
```cpp
void build(int u) {
    num[++cnt] = u;
    kth[u] = cnt;
    size[u] = 1;
    for (auto son : g[u]) {
        build(son);
        size[u] += size[son];
    }
}
```

---

### 关键思路与技巧总结
1. **DFS序连续性**：子树的前序遍历在整棵树的DFS序中是连续的。
2. **预处理三要素**：
   - `dfn[u]`：节点u的DFS进入时间。
   - `size[u]`：以u为根的子树节点总数。
   - `id[time]`：时间戳time对应的节点。
3. **查询公式**：若`size[u] >= k`，则答案为`id[dfn[u] + k - 1]`。

---

### 拓展与同类题目
1. **子树问题**：可扩展至子树求和、子树修改等操作（如洛谷P3384）。
2. **路径查询**：结合LCA处理路径相关查询（如洛谷P3379）。
3. **反向遍历**：逆向DFS序应用（如洛谷P3916）。

**推荐练习题目**  
1. [P3916 - 图的遍历](https://www.luogu.com.cn/problem/P3916)  
2. [P3384 - 树链剖分](https://www.luogu.com.cn/problem/P3384)  
3. [P3379 - 最近公共祖先](https://www.luogu.com.cn/problem/P3379)

---
处理用时：194.71秒
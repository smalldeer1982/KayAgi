# 题目信息

# Lost Arithmetic Progression

## 题目描述

很久以前，你想到了两个有限的[等差级数](https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E7%BA%A7%E6%95%B0) $A$ 和 $B$。然后你发现另一个序列 $C$ 包含了 $A$ 和 $B$ 的所有公有元素。不难看出， $C$ 也是一个有限等差数列。

许多年后，你忘记了 $A$ 是什么，但还记得 $B$ 数列和 $C$ 数列。出于某种原因，你决心找到这个丢失的等差数列。在你开始这个永恒搜索之前，你想知道有多少个不同的有限等差数列可以作为你丢失的数列 $A$。

如果两个等差数列的第一项、公差数或项数不同，则认为它们不同。

有可能有无限多这样的数列，在这种情况下，你不需要尝试找到它们！你只要直接输出 $-1$。

即使它们的数量有限，答案也可能非常大。你只需要求对 $10^9+7$ 取模的答案。

## 说明/提示

对于第一个测试用例，$B=\{-3,-2,-1,0,1,2,3\}$、$C=\{-1,1,3,5\}$，不存在等差数列 $A$，因为 $5$ 不存在于 $B$ 中，所以 $5$ 也不应该存在于 $C$ 中。

对于第二个测试用例，$B=\{-9,-6,-3,0,3,6,9,12,15,18,21\}$、$C=\{0,6,12\}$，有 $10$ 个可能的等差数列 $A$：

- $\{0,6,12\}$
- $\{0,2,4,6,8,10,12\}$
- $\{0,2,4,6,8,10,12,14\}$
- $\{0,2,4,6,8,10,12,14,16\}$
- $\{-2,0,2,4,6,8,10,12\}$
- $\{-2,0,2,4,6,8,10,12,14\}$
- $\{-2,0,2,4,6,8,10,12,14,16\}$
- $\{-4,-2,0,2,4,6,8,10,12\}$
- $\{-4,-2,0,2,4,6,8,10,12,14\}$
- $\{-4,-2,0,2,4,6,8,10,12,14,16\}$

对于第三个测试用例，$B=\{2,7,12,17,22\}$、$C=\{7,12,17,22\}$，有无限多个可能的等差数列 $A$：

- $ \{7,12,17,22\} $
- $ \{7,12,17,22,27\} $
- $ \{7,12,17,22,27,32\} $
- $ \{7,12,17,22,27,32,37\} $
- $ \{7,12,17,22,27,32,37,42\} $
- $ \ldots $

## 样例 #1

### 输入

```
8
-3 1 7
-1 2 4
-9 3 11
0 6 3
2 5 5
7 5 4
2 2 11
10 5 3
0 2 9
2 4 3
-11 4 12
1 12 2
-27 4 7
-17 8 2
-8400 420 1000000000
0 4620 10```

### 输出

```
0
10
-1
0
-1
21
0
273000```

# AI分析结果



# Lost Arithmetic Progression

## 题目描述

很久以前，你设想了两个有限的等差数列 $A$ 和 $B$。后来发现它们的公共元素组成了另一个有限等差数列 $C$。现在你忘记了 $A$，但还记得 $B$ 和 $C$，需要找出可能的 $A$ 的数量。

**输入要求**  
输入多组测试数据，每组给出 $B$ 的首项、公差、项数，以及 $C$ 的首项、公差、项数。

**输出要求**  
输出可能的 $A$ 的数量（对 $10^9+7$ 取模），若无解输出 $0$，若无限解输出 $-1$。

---

## 题解分析与关键思路

### 共同核心思路
1. **无解条件**  
   - C 的公差不是 B 公差的倍数
   - C 的首项或末项超出 B 的范围
2. **无限解条件**  
   - C 的左右端点扩展一个公差后的值不在 B 的范围内
3. **有限解计算**  
   - 枚举所有可能的 A 公差 $d_A$，需满足 $\text{lcm}(d_A, d_B) = d_C$
   - 对每个合法 $d_A$，统计两端可扩展的方案数并累加

### 最优题解亮点

#### 题解1：Argon_Cube（4.5⭐）
- **关键技巧**：通过枚举 B 的公差因数，构造候选 A 的公差，直接验证 $\text{lcm}$ 条件
- **代码优势**：条件判断简洁，质因数处理高效
- **核心代码**：
  ```cpp
  for (long long i : 枚举B的公差因数) {
    long long A_d = (dC/dB) * i;
    if (lcm(A_d, dB) == dC) {
        ans += (dC/A_d)^2;
    }
  }
  ```

#### 题解2：Polaris_Australis_（4⭐）
- **核心贡献**：引入 $\gcd$ 互质判断避免多余交点
- **实现细节**：约数去重处理避免重复计数
- **代码片段**：
  ```cpp
  for (int i : 枚举d_C的约数) {
    if (gcd(dC/i, dC/dB) == 1) {
        ans += (dC/i)^2;
    }
  }
  ```

---

## 关键思路总结
1. **数学建模**：将等差数列交集问题转化为公差的最小公倍数问题
2. **边界处理**：通过扩展端点判断无限解，避免复杂的区间运算
3. **因数分解优化**：利用因数的对称性减少枚举次数，提升效率
4. **取模技巧**：及时取模避免溢出，保持代码健壮性

---

## 类似题目推荐
1. [P1496 青蛙的约会](https://www.luogu.com.cn/problem/P1496)（扩展欧几里得解线性同余）
2. [P2424 约数和](https://www.luogu.com.cn/problem/P2424)（因数分解与数论分块）
3. [CF1349A Orac and LCM](https://www.luogu.com.cn/problem/CF1349A)（质因数分解与最大公约数）

---
处理用时：195.13秒
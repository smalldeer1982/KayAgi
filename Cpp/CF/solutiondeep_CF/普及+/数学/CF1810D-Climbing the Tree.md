# 题目信息

# Climbing the Tree

## 题目描述

蜗牛在爬树。树高为 $ h $ 米，每只蜗牛从 $ 0 $ 米高处开始爬。

每只蜗牛有两个属性 $ a $ 与 $ b \text{ } ( a > b ) $。从第 $ 1 $ 天开始，每只蜗牛会以以下方式爬树：在白天，蜗牛向上爬 $ a $ 米； 在晚上，蜗牛会休息，而它每晚会向下滑 $ b $ 米。如果在第 $ n $ 天，蜗牛首次到达第 $ h $ 米的高度（也就是树顶），它就会结束爬行，此时我们称此蜗牛花了 $ n $ 天来爬树。注意，在最后一天，只要蜗牛离树顶的高度小于 $ a $ 米，它就不需要正好再向上爬 $ a $ 米。

起初，你并不知道树高 $ h $，你只知道 $ h $ 是一个正整数。接下来会发生以下两种类型的事件，事件件数总和为 $ q $。

- 事件 $ 1 $：有一只属性为 $ a $， $ b $ 的蜗牛声称它花了 $ n $ 天来爬树。如果这条信息与之前的已知信息有冲突（即根据之前信息确定的树高范围与当前信息所确定的树高范围有冲突），则忽略该信息，否则采纳该信息。

- 事件 $ 2 $：有一只属性为 $ a $， $ b $ 的蜗牛前来询问你它需要花几天来爬树。你只能根据当前你已采纳的信息来推测答案。如果仅根据已有信息无法给出精确的答案，则回答 $ -1 $。

你需要按顺序处理所有事件。




保证单个测试点内 $ q $ 的总和不超过 $ 2 \times 10 ^ 5 $。

## 说明/提示

在第一个测试样例中，我们可以从第一条信息确定 $ h = 7 $，所有我们可以知道第二条蜗牛和第三条蜗牛各自需要 $ 2 $ 天和 $ 5 $ 天来爬树。

对于第一个样例中的第二只蜗牛，有：

- 在第 $ 1 $ 天的白天：这只蜗牛向上爬了 $ 4 $ 米，现在它在 $ 4 $ 米高处。
- 在第 $ 1 $ 天的晚上：这只蜗牛向下滑了 $ 1 $ 米，现在它在 $ 3 $ 米高处。
- 在第 $ 2 $ 天的白天：这只蜗牛向上爬了 $ 4 $ 米，现在它在 $ 7 $ 米高处（即爬到树顶）。

在第三个测试样例中，第二只蜗牛的信息与第一只蜗牛的信息有冲突，因为第二支蜗牛说它花了 $ 3 $ 天爬树，而它在前 $ 3 $ 天最多可以爬 $ 1 + 1 + 2 = 4 $ 米，而第一只蜗牛只需要花 $ 1 $ 天就能爬 $ 4 $ 米。

## 样例 #1

### 输入

```
5
3
1 3 2 5
2 4 1
2 3 2
3
1 6 5 1
2 3 1
2 6 2
3
1 4 2 2
1 2 1 3
2 10 2
9
1 7 3 6
1 2 1 8
2 5 1
1 10 9 7
1 8 1 2
1 10 5 8
1 10 7 7
2 7 4
1 9 4 2
9
1 2 1 6
1 8 5 6
1 4 2 7
2 9 1
1 5 1 4
1 5 2 7
1 7 1 9
1 9 1 4
2 10 8```

### 输出

```
1 2 5
1 -1 1
1 0 1
1 0 -1 0 0 0 1 8 0
1 0 0 1 0 0 0 0 1```

# AI分析结果



### 题目内容重写

#### 题目描述

蜗牛在爬树。树高为 $ h $ 米，每只蜗牛从 $ 0 $ 米高处开始爬。

每只蜗牛有两个属性 $ a $ 与 $ b \text{ } ( a > b ) $。从第 $ 1 $ 天开始，每只蜗牛会以以下方式爬树：在白天，蜗牛向上爬 $ a $ 米；在晚上，蜗牛会休息，并向下滑 $ b $ 米。如果在第 $ n $ 天，蜗牛首次到达树顶（$ h $ 米），则结束爬行，此时称蜗牛花了 $ n $ 天爬树。注意：最后一天只要剩余高度小于 $ a $ 米，即可直接登顶。

初始时，$ h $ 是未知的正整数。需处理 $ q $ 次事件，事件类型如下：

1. **事件 1**：属性为 $ a,b $ 的蜗牛声称花了 $ n $ 天爬树。若此信息与已有信息冲突（树高范围无交集），则忽略；否则采纳。
2. **事件 2**：属性为 $ a,b $ 的蜗牛询问需要多少天。若当前信息无法确定唯一答案，输出 $-1$。

需按顺序处理所有事件。

#### 输入输出说明

- **输入**：多组测试数据，每组包含事件序列。
- **输出**：对每个事件输出对应结果。

---

### 题解综合分析

#### 关键思路与难点

1. **区间推导**：
   - **事件 1**：根据 $ a,b,n $ 推导 $ h $ 的可能区间。当 $ n=1 $ 时，$ h \in [1, a]$；否则区间为 $ [(a-b)(n-2)+a+1, (a-b)(n-1)+a]$。
   - **事件 2**：计算当前区间 $ [l, r] $ 的上下界对应天数，若一致则输出，否则 $-1$。

2. **精度处理**：
   - 避免浮点运算，使用整数上取整技巧：$ \lceil \frac{x}{y} \rceil = \frac{x + y - 1}{y} $。

3. **区间维护**：
   - 动态维护全局区间 $ [l, r] $，每次事件 1 时检查交集，更新为最大左界和最小右界。

---

### 精选题解

#### 1. SunnyYuan（5星）

**关键亮点**：
- 清晰的数学推导与特判处理。
- 代码结构简洁高效，维护区间交集的逻辑明确。
- 使用整数运算避免精度问题。

**核心代码**：
```cpp
bool check(int& l1, int& r1, int l2, int r2, bool flag) {
    int ll = max(l1, l2);
    int rr = min(r1, r2);
    if (ll > rr) return false;
    if (flag) { l1 = ll; r1 = rr; }
    return true;
}

void solve() {
    int l = 1, r = 1e18;
    // 处理事件1
    if (c == 1) lnew = 1, rnew = a;
    else lnew = (a - b) * (c - 2) + a + 1, rnew = (a - b) * (c - 1) + a;
    if (check(l, r, lnew, rnew, true)) cout << "1 ";
    // 处理事件2
    int x = l - a;
    if (a >= l) res = 1;
    else {
        res = x / (a - b);
        if (x == res * (a - b)) res++;
        else res += 2;
    }
}
```

#### 2. tallnut（4星）

**关键亮点**：
- 手写上取整函数避免浮点误差。
- 代码可读性强，逻辑分层明确。

**核心代码**：
```cpp
ull ceil_divide(ull a, ull b) { return (a + b - 1) / b; }

// 事件1处理
if (n == 1) curl = 1, curr = a;
else curl = (a - b) * (n - 2) + a + 1, curr = (a - b) * (n - 1) + a;

// 事件2处理
mindays = ceil_divide(l - a, a - b) + 1;
maxdays = ceil_divide(r - a, a - b) + 1;
if (mindays == maxdays) cout << mindays;
```

---

### 关键技巧总结

1. **区间推导公式**：通过蜗牛爬升的周期性规律，结合天数限制精确计算树高范围。
2. **整数上取整**：用 $ (x + y - 1) / y $ 避免浮点运算。
3. **动态区间维护**：通过交集检查逐步缩小树高范围，确保信息一致性。

---

### 推荐练习题

1. [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)（动态维护状态）
2. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)（区间覆盖与二分）
3. [P1276 校门外的树](https://www.luogu.com.cn/problem/P1276)（区间操作与统计）

---
处理用时：127.21秒
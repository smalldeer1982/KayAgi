# 题目信息

# Sakurako's Box

## 题目描述

Sakurako 有一个装满 $n$ 个球的盒子。每个球都有自己的数值。她想和朋友打个赌，朋友如果从盒子中随机选出两个球（可以是不同的两球，即使它们有相同的数值），这两个球数值的乘积能够等于 Sakurako 事先猜测到的一个数。

因为 Sakurako 是概率学方面的专家，她知道最明智的猜测应该是[期望值](http://tiny.cc/matozh_en)，但她忘了如何去计算。请帮助她计算出这个数组中任意两个元素乘积的期望值。

可以证明，该期望值的形式为 $\frac{P}{Q}$，其中 $P$ 和 $Q$ 是非负整数，且 $Q \ne 0$。你需要计算并输出 $P \cdot Q^{-1} \bmod (10^9+7)$ 的结果。

## 说明/提示

举个例子：
- 在第一个测试用例中，Sakurako 的朋友可以选择这些球对：$(a_1, a_2)$、$(a_1, a_3)$ 和 $(a_2, a_3)$。它们的乘积分别是 $3 \times 2 = 6$、$3 \times 3 = 9$ 和 $3 \times 2 = 6$，所以期望值计算结果为 $\frac{6 + 9 + 6}{3} = 7$。

- 在第二个测试用例中，朋友可以选择的球对有：$(a_1, a_2)$、$(a_1, a_3)$、$(a_1, a_4)$、$(a_2, a_3)$、$(a_2, a_4)$ 和 $(a_3, a_4)$。它们的乘积分别为 $2 \times 2 = 4$、$2 \times 2 = 4$、$2 \times 4 = 8$、$2 \times 2 = 4$、$2 \times 4 = 8$ 和 $2 \times 4 = 8$，所以期望值为 $\frac{4 + 4 + 8 + 4 + 8 + 8}{6} = \frac{36}{6} = 6$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3
3 2 3
4
2 2 2 4
5
1 2 3 4 5```

### 输出

```
7
6
500000012```

# AI分析结果



# Sakurako's盒子

## 题目描述

Sakurako 有一个装满 $n$ 个球的盒子。每个球都有自己的数值。她想和朋友打个赌，朋友如果从盒子中随机选出两个球（可以是不同的两球，即使它们有相同的数值），这两个球数值的乘积能够等于 Sakurako 事先猜测到的一个数。

因为 Sakurako 是概率学方面的专家，她知道最明智的猜测应该是[期望值](http://tiny.cc/matozh_en)，但她忘了如何去计算。请帮助她计算出这个数组中任意两个元素乘积的期望值。

可以证明，该期望值的形式为 $\frac{P}{Q}$，其中 $P$ 和 $Q$ 是非负整数，且 $Q \ne 0$。你需要计算并输出 $P \cdot Q^{-1} \bmod (10^9+7)$ 的结果。

---

## 题解综合分析

### 关键算法思路
所有题解均采用数学公式转换+前缀和优化的核心思路：
1. **公式转换**：将两两乘积之和转换为 $\sum_{i=2}^n (a_i \cdot \text{前缀和}[i-1])$，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$
2. **逆元处理**：使用费马小定理计算组合数逆元，避免浮点运算
3. **在线计算**：边读入数据边维护前缀和，节省存储空间

### 最优题解推荐

#### 题解1：Super_Cube（★★★★☆）
**核心亮点**：
- 紧凑的循环结构实现前缀和累加
- 使用位运算优化逆元计算
- 模运算优化减少计算量

**核心代码片段**：
```cpp
int T,n,s,ans;
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&s); // s初始化为第一个元素
        ans=0;
        for(int i=1,x;i<n;++i)
            scanf("%d",&x),
            ans=(ans+1ll*x*s)%mod, // 累加当前元素与之前所有元素的乘积
            (s+=x)<mod?0:s-=mod; // 维护前缀和
        printf("%d\n",1ll*ans*qpow(...)%mod);
    }
}
```

#### 题解2：Drifty（★★★★☆）
**核心亮点**：
- 使用C++11特性定义逆元计算函数
- 清晰的变量命名提升可读性
- 输入输出流优化加速

**核心代码片段**：
```cpp
auto inv = [](i64 a, i64 x = P - 2) { // 使用lambda定义逆元计算
    i64 ans = 1;
    for (; x; x >>= 1, a = 1ll*a*a%P)
        if (x&1) ans=1ll*ans*a%P;
    return ans;
};
```

---

## 关键技巧总结
1. **前缀和优化乘积和**：通过 $\sum_{i<j}a_ia_j = \sum_{j=2}^n (a_j \cdot S_{j-1})$，将复杂度降为线性
2. **逆元预处理技巧**：使用快速幂实现费马小定理求逆元，适用于模数为质数的情况
3. **在线计算策略**：无需存储完整数组，适合处理大规模数据

---

## 拓展训练
1. [P2512 [HAOI2008]糖果传递](https://www.luogu.com.cn/problem/P2512) - 前缀和在中位数模型中的应用
2. [P5431 【模板】乘法逆元2](https://www.luogu.com.cn/problem/P5431) - 逆元的批量计算方法
3. [P3214 [HNOI2011]卡农](https://www.luogu.com.cn/problem/P3214) - 组合数学与模运算的综合应用

---
处理用时：62.09秒
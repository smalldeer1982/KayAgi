# 题目信息

# Ordered Permutations

## 题目描述

给定一个长度为 $n$ 的整数排列 $p_1, p_2, \ldots, p_n$，其中包含从 $1$ 到 $n$ 的所有整数。我们定义一个如下的和式：

$$S(p) = \sum_{1 \le l \le r \le n} \min(p_l, p_{l+1}, \ldots, p_r)$$

我们希望找出所有能使 $S(p)$ 最大的排列，并从中按字典序选择第 $k$ 个。如果这样的排列数量少于 $k$，则输出 -1。

**解释说明：**
- 长度为 $n$ 的排列是一个由 $n$ 个不同的整数组成的序列，这些整数来源于 $1$ 到 $n$ 的一组数字。例如，$[2, 3, 1, 5, 4]$ 是一个符合要求的排列，而 $[1, 2, 2]$ 因为有重复数字 $2$ 而不符合，$[1, 3, 4]$ 也不符合要求，因为它包含了不在 $1$ 到 $n$ 范围内的数 $4$（$n = 3$）。
- 示例计算： 
  - 对于排列 $[1, 2, 3]$，$S(p)$ 计算为 $\min(1) + \min(1, 2) + \min(1, 2, 3) + \min(2) + \min(2, 3) + \min(3) = 1 + 1 + 1 + 2 + 2 + 3 = 10$。
  - 对于排列 $[2, 4, 1, 3]$，$S(p)$ 计算为 $\min(2) + \min(2, 4) + \min(2, 4, 1) + \min(2, 4, 1, 3) + \min(4) + \min(4, 1) + \min(4, 1, 3) + \min(1) + \min(1, 3) + \min(3) = 2 + 2 + 1 + 1 + 4 + 1 + 1 + 1 + 1 + 3 = 17$。
- 字典序小于：数组 $a$ 比数组 $b$ 在字典序上小的条件是：
  1. $a$ 是 $b$ 的一个前缀，且 $a \ne b$；
  2. 或者在第一个不同的位置上，$a$ 的元素小于 $b$ 的对应元素。

## 说明/提示

以下是所有长度为 3 的排列及其对应的 $S(p)$ 值（按字典序排序）：

| 排列 | $S(p)$ 的值 |
|------|-------------|
| $[1, 2, 3]$ | $10$ |
| $[1, 3, 2]$ | $10$ |
| $[2, 1, 3]$ | $9$ |
| $[2, 3, 1]$ | $10$ |
| $[3, 1, 2]$ | $9$ |
| $[3, 2, 1]$ | $10$ |

在第一个测试用例中，需输出长度为 3 的第 2 个符合条件的排列，看表格可以知道是 $[1, 3, 2]$。

在第二个测试用例中，需输出长度为 3 的第 3 个符合条件的排列，对应的是 $[2, 3, 1]$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
6
3 2
3 3
4 11
4 6
6 39
7 34```

### 输出

```
1 3 2 
2 3 1 
-1
2 4 3 1 
-1
2 3 4 5 7 6 1```

# AI分析结果



# Ordered Permutations 题目中文翻译

## 题目描述

给定一个长度为 $n$ 的整数排列 $p_1, p_2, \ldots, p_n$（包含 $1$ 到 $n$ 的所有整数），定义和式：

$$S(p) = \sum_{1 \le l \le r \le n} \min(p_l, p_{l+1}, \ldots, p_r)$$

要求找出所有能使 $S(p)$ 最大的排列，并按字典序输出其中第 $k$ 个排列。若无足够排列则输出 -1。

**说明：**
- 排列的字典序比较规则：首个不同位置元素较小的排列字典序更小
- 样例计算见原题

## 样例输入输出
（同原题内容）

---

# 题解分析与结论

## 关键思路总结
1. **贡献最大化原理**：每个数 $i$ 的贡献为 $i \times (n-i+1)$，构造排列时需保证每个数尽可能出现在更多区间的最小值位置。
2. **构造策略**：从小到大的数依次放置在最左或最右端，形成类似「单峰」结构，确保大数不会影响较小数的贡献区间。
3. **排列数量**：最优排列总数为 $2^{n-1}$，若 $k > 2^{n-1}$ 则无解。
4. **字典序生成**：将 $k$ 视为二进制数，每一位决定当前数放置方向（左/右），需处理大数运算溢出问题。

---

## 精选题解

### 题解作者：ohjun（★★★★☆）
**核心亮点**：
- 引入阈值 `maxv` 处理大数溢出，当剩余位数超过阈值时直接决策，避免高次幂计算
- 代码简洁高效，时间复杂度严格 $O(n)$
**关键代码**：
```cpp
const int maxv = log(1e12) / log(2) + 1; // 溢出阈值
for(int i=1; i<n; i++) {
    if(n-1-i > maxv || k <= (1LL << (n-i-1))) {
        ans[l++] = i; // 放左侧
    } else {
        k -= (1LL << (n-i-1));
        ans[r--] = i; // 放右侧
    }
}
```

### 题解作者：naroto2022（★★★★☆）
**核心亮点**：
- 动态计算幂次时采用 `j > 40` 的剪枝策略处理溢出
- 使用左右双指针填充数组，逻辑清晰
**关键代码**：
```cpp
for(int i=1,j=n-2; i<n; i++,j--) {
    if(j>40) { // 防溢出剪枝
        ans[l++] = i;
        continue;
    }
    if(k > ksm(2,j)) {
        ans[r--] = i;
        k -= ksm(2,j);
    } else ans[l++] = i;
}
```

### 题解作者：MrPython（★★★☆☆）
**核心亮点**：
- 使用双端队列实现简洁的二进制位决策
- 未处理大数溢出的极端情况，适用小规模数据
**关键代码**：
```cpp
deque<ui> ans{(ui)n};
for(ui i=n-1; i>0; --i) {
    if(k & 1) ans.emplace_back(i); // 低位决定方向
    else ans.emplace_front(i);
    k >>= 1;
}
```

---

## 同类型题目推荐
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 基础排列生成
2. [P3014 [USACO11FEB] Cow Line S](https://www.luogu.com.cn/problem/P3014) - 排列的字典序处理
3. [P1338 末日的传说](https://www.luogu.com.cn/problem/P1338) - 逆序对与排列构造的经典问题

---
处理用时：67.82秒
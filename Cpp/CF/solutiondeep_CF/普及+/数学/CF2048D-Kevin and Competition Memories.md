# 题目信息

# Kevin and Competition Memories

## 题目描述

Kevin 曾经进入过 Rio 的记忆。在那段记忆中，曾举办过一系列的比赛。Kevin 还记得所有参赛者和比赛的问题，但具体的比赛轮次、问题分布和排名已经模糊不清。

有 $m$ 个比赛问题，第 $i$ 个问题的难度为 $b_i$。每场比赛选择 $k$ 个问题，因此总共会有 $\lfloor \frac{m}{k} \rfloor$ 场比赛。这意味着你可以任意组合选择这些比赛问题，并挑出总共 $\lfloor \frac{m}{k} \rfloor \cdot k$ 个问题参赛，每个问题最多只能被选一次，剩余 $m \bmod k$ 个问题将未被使用。例如，如果 $m = 17$ 且 $k = 3$，你将组织 $5$ 场比赛，每场 $3$ 个问题，会剩下 $2$ 个问题没有用上。

比赛有 $n$ 位参赛者，其中 Kevin 是第 1 位。第 $i$ 位参赛者的评分是 $a_i$。在比赛中，每个参赛者能解决难度不超过其评分的问题，具体来说，第 $i$ 位参赛者能解决第 $j$ 个问题，当且仅当 $a_i \geq b_j$。在每场比赛中，Kevin 的排名定义为那些比他解掉更多题目的参赛者数量加一。

对于每个 $k = 1, 2, \ldots, m$，Kevin 想知道在所有 $\lfloor \frac{m}{k} \rfloor$ 场比赛中的排名之和的最小可能值。也就是说，对于某个 $k$，你需要优化问题的选择和分配，使得 Kevin 的排名之和最小化。

不同的 $k$ 值代表的比赛是相互独立的。换言之，你可以对每个不同的 $k$ 值分别规划问题分配。

## 说明/提示

考虑第一个测试数据：

- 当 $k=1$ 时，每场比赛只包含一个问题，分配方式是唯一的。例如，在包含难度为 $4$ 的第三个问题的比赛中，除了第 2 位参赛者外，所有人都能解决。因为没有人比 Kevin 解出更多的问题，他在这场比赛中排名第 1。同理，在所有 $4$ 场比赛中，Kevin 的排名分别是 $1, 3, 1, 2$，总和为 $7$。

- 当 $k=2$ 时，最佳选择是将第 1 和第 3 个问题组成一场比赛，第 2 和第 4 个问题组成另一场。在前一场比赛中，4 名选手分别解决 $2, 1, 2, 2$ 个问题，Kevin 排名第 1；在后一场比赛中，选手分别解决 $0, 0, 2, 1$ 个问题，因有 2 位选手多解题，Kevin 排名第 $3$。所以总和是 $1 + 3 = 4$。这是最优解。

- 当 $k=3$ 时，可以选择第 1、3、4 个问题组成一场比赛，Kevin 的排名是 2，为最优。

- 当 $k=4$ 时，只有一场比赛，分配方式唯一，Kevin 的排名是 3。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
4 4
4 3 7 5
2 5 4 6
5 5
5 0 4 8 6
1 3 9 2 7
6 7
1 1 4 5 1 4
1 9 1 9 8 1 0
7 6
1 9 1 9 8 1 0
1 1 4 5 1 4```

### 输出

```
7 4 2 3
6 2 1 1 2
7 3 2 1 1 1 1
15 9 5 4 4 4```

# AI分析结果



### 题目中文翻译

#### 题目描述

Kevin 曾进入过 Rio 的记忆。在那段记忆中，曾举办过一系列比赛。Kevin 记得所有参赛者和题目，但具体轮次、题目分配和排名已模糊。

有 $m$ 个题目，第 $i$ 题的难度为 $b_i$。每场比赛选 $k$ 题，共 $\lfloor \frac{m}{k} \rfloor$ 场，剩余 $m \bmod k$ 题不用。例如，$m=17$ 且 $k=3$ 时，组织 5 场比赛，每场 3 题，剩余 2 题。

有 $n$ 位参赛者，Kevin 是第 1 位。第 $i$ 位参赛者的评分是 $a_i$。参赛者能解决难度不超过其评分的问题。每场比赛中，Kevin 的排名是比他解题多的参赛者数量加一。

对每个 $k = 1, 2, \ldots, m$，求在所有可能的题目分配中，Kevin 的排名总和的最小值。

---

### 题解分析与结论

#### 核心思路
1. **贡献值计算**：对每个题目 $b_j$，若 Kevin 能解决（$a_1 \geq b_j$），则贡献为 1（不影响排名）；否则，贡献为能解决该题的其他选手数量 +1。
2. **贪心策略**：将贡献值升序排序后，每 $k$ 个为一组，每组最大值之和即为最小总排名。例如，排序后数组为 $c$，则第 $k, 2k, 3k,\ldots$ 位的元素之和加上场次数 $\lfloor m/k \rfloor$。

#### 解决难点
- **贡献值的正确计算**：需快速统计其他选手对每个难题的解决能力，使用排序和二分优化。
- **分组策略的证明**：通过交换不同组的元素，可证明升序分组取最大值是最优策略。

---

### 精选题解

#### 题解 1：ZnPdCo（★★★★★）
**关键亮点**  
- 贡献值预处理高效，使用二分快速统计其他选手能力。
- 贪心分组直接通过排序和步长遍历实现，代码简洁，复杂度 $O(m \log m)$。
**代码核心**  
```cpp
sort(b + 1, b + m + 1); // 贡献值升序排序
for (int k = 1; k <= m; k++) {
    int ans = m / k; // 初始为场次数（默认每场贡献1）
    for (int i = k; i <= m; i += k) {
        ans += b[i]; // 累加每组最大值（贡献值已处理为t，总和为场次数 + sum(t))
    }
    cout << ans << " ";
}
```

#### 题解 2：_lmh_（★★★★☆）
**关键亮点**  
- 预处理时将题目分为 Kevin 能解和不能解两类，分别排序。
- 使用 ST 表快速查询区间最小值，优化最大贡献值计算。
**代码核心**  
```cpp
sort(c.begin(), c.end()); // c为贡献值数组
RMQ<int, greater<int>> rmq(c); // 构建ST表
for (int k = 1; k <= m; k++) {
    ll ans = 0;
    for (int j = 0; j + k <= m; j += k) {
        ans += rmq(j, j + k); // 查询每组最大值
    }
    cout << ans << " ";
}
```

---

### 关键思路总结
1. **贡献值的二分计算**：对每个难题，通过排序和二分统计其他选手数量。
2. **贪心分组优化**：升序排序后按步长 $k$ 取最大值，保证总和最小。
3. **预处理与快速查询**：利用排序和数据结构（如 ST 表）加速贡献值的分组计算。

---

### 相似题目推荐
1. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**：贪心策略，优先队列优化。
2. **[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)**：分治与归并排序思想。
3. **[P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)**：二分查找统计特定数值对。

---
处理用时：210.87秒
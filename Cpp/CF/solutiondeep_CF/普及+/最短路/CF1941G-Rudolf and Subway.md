# 题目信息

# Rudolf and Subway

## 题目描述

建桥对伯纳德没有帮助，他去哪里都迟到。然后鲁道夫决定教他乘坐地铁。

鲁道夫将地铁地图描绘成一个无向连接图，没有自循环，其中顶点代表车站。任何一对顶点之间最多有一条边。

如果可以绕过其他站点，则可以通过一条边直接在相应站点之间移动，则两个顶点通过一条边连接。鲁道夫和伯纳德居住的城市的地铁有颜色符号。这意味着站点之间的任何边缘都具有特定的颜色。特定颜色的边缘共同形成一条地铁线。地铁线不能包含未连接的边，并形成给定地铁图的连接子图。

地铁地图示例如图所示。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941G/7c6e3ab76399bc5859a6a1ea202bbed5b214c151.png)
 鲁道夫声称，如果这条路线通过最少数量的地铁线路，这条路线将是最佳的。

帮助 Bernard 确定给定出发站和目的地站的最小数量。

## 说明/提示

第一个示例的地铁图如图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941G/7c6e3ab76399bc5859a6a1ea202bbed5b214c151.png)

在第一个测试用例中，从顶点 $ 1 $ 到顶点 $ 3 $ ，可以沿着路径行进 $ 1 \rightarrow 2 \rightarrow 3 $ , 仅使用绿线。

在第二个测试用例中，从顶点 $ 1 $ 到顶点 $ 6 $ , 你可以沿着这条路旅行 $ 1 \rightarrow 2 \rightarrow 3 \rightarrow 6 $ , 使用绿线和蓝线。

在第三个测试用例中，不需要从顶点 $ 6 $ 移动到同一个顶点，所以行数为 $ 0 $ 。

在第四个测试用例中，图的所有边都属于一条线，所以答案是 $ 1 $ 。

## 样例 #1

### 输入

```
5
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
1 3
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
1 6
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
6 6
4 3
1 2 1
1 3 1
4 1 1
2 3
6 7
1 2 43
1 3 34
4 6 43
6 3 43
2 3 43
5 3 43
4 5 43
1 6```

### 输出

```
1
2
0
1
1```

## 样例 #2

### 输入

```
3
7 9
2 4 1
3 6 1
2 3 5
1 7 1
4 7 1
2 5 4
5 4 4
3 4 1
3 7 1
5 3
6 5
6 5 83691
4 1 83691
5 4 83691
3 2 83691
4 3 83691
5 1
6 7
6 1 83691
6 2 83691
2 5 83691
5 6 83691
2 3 83691
5 4 83574
3 5 83691
1 4```

### 输出

```
2
1
2```

# AI分析结果

### 题目翻译
#### 鲁道夫和地铁

#### 题目描述
建桥对伯纳德没有帮助，他去哪里都迟到。然后鲁道夫决定教他乘坐地铁。

鲁道夫将地铁地图描绘成一个无向连接图，没有自循环，其中顶点代表车站。任何一对顶点之间最多有一条边。

如果可以绕过其他站点，则可以通过一条边直接在相应站点之间移动，则两个顶点通过一条边连接。鲁道夫和伯纳德居住的城市的地铁有颜色符号。这意味着站点之间的任何边缘都具有特定的颜色。特定颜色的边缘共同形成一条地铁线。地铁线不能包含未连接的边，并形成给定地铁图的连接子图。

地铁地图示例如图所示。
![地铁地图示例](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941G/7c6e3ab76399bc5859a6a1ea202bbed5b214c151.png)
鲁道夫声称，如果这条路线通过最少数量的地铁线路，这条路线将是最佳的。

帮助伯纳德确定给定出发站和目的地站的最小地铁线路数量。

#### 说明/提示
第一个示例的地铁图如图所示。
![第一个示例的地铁图](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941G/7c6e3ab76399bc5859a6a1ea202bbed5b214c151.png)

在第一个测试用例中，从顶点 1 到顶点 3 ，可以沿着路径行进 1 → 2 → 3 ，仅使用绿线。

在第二个测试用例中，从顶点 1 到顶点 6 ，你可以沿着这条路旅行 1 → 2 → 3 → 6 ，使用绿线和蓝线。

在第三个测试用例中，不需要从顶点 6 移动到同一个顶点，所以线路数为 0 。

在第四个测试用例中，图的所有边都属于一条线，所以答案是 1 。

#### 样例 #1
##### 输入
```
5
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
1 3
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
1 6
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
6 6
4 3
1 2 1
1 3 1
4 1 1
2 3
6 7
1 2 43
1 3 34
4 6 43
6 3 43
2 3 43
5 3 43
4 5 43
1 6
```
##### 输出
```
1
2
0
1
1
```

#### 样例 #2
##### 输入
```
3
7 9
2 4 1
3 6 1
2 3 5
1 7 1
4 7 1
2 5 4
5 4 4
3 4 1
3 7 1
5 3
6 5
6 5 83691
4 1 83691
5 4 83691
3 2 83691
4 3 83691
5 1
6 7
6 1 83691
6 2 83691
2 5 83691
5 6 83691
2 3 83691
5 4 83574
3 5 83691
1 4
```
##### 输出
```
2
1
2
```

### 综合分析与结论
这些题解核心思路都是将问题转化为图论的最短路问题，通过重新建图来解决换乘次数最少的问题。
- **思路对比**：大部分题解是将每条地铁线路抽象为一个新的节点，在原节点和新节点间连边，边权表示上车或下车的代价；部分题解从生活中乘坐地铁的场景类比建图；还有题解尝试用动态规划但进行了优化。
- **算法要点**：由于边权只有 0 和 1，很多题解使用 0 - 1 BFS 优化最短路求解，部分使用 Dijkstra 算法。
- **解决难点**：主要难点在于如何合理建图以正确表示换乘的代价，以及处理地铁线路编号不连续的情况，很多题解使用 `map` 来重新编号。

### 所选题解
- **作者：2huk（5星）**
    - **关键亮点**：思路清晰，将每辆地铁看成一个点，详细说明了建图方式和边权设置，使用 0 - 1 BFS 优化，代码简洁易懂。
    - **核心代码**：
```cpp
vector<PII> g[N];
int dis[N];
bool st[N];

void Luogu_UID_748509() {
    int n, m; fin >> n >> m;
    int cnt = n;
    for (int i = 1; i <= n + m + 1; ++ i ) g[i].clear();
    map<int, int> col;
    while (m -- ) {
        int u, v, w; fin >> u >> v >> w;
        if (!col.count(w)) col[w] = ++ cnt;
        g[u].push_back({col[w], 1});
        g[v].push_back({col[w], 1});
        g[col[w]].push_back({u, 0});
        g[col[w]].push_back({v, 0});
    }
    int s, t; fin >> s >> t;
    deque<int> q;
    q.push_back(s);
    for (int i = 1; i <= n + cnt + 1; ++ i ) dis[i] = 1e9, st[i] = 0;
    dis[s] = 0;
    while (q.size()) {
        int u = q.front();
        q.pop_front();
        if (st[u]) continue;
        st[u] = true;
        for (auto [v, w] : g[u]) if (dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w;
            if (w) q.push_back(v);
            else q.push_front(v);
        }
    }
    fout << dis[t] << '\n';
}
```
核心实现思想：将每条地铁线路用一个新节点表示，原节点到地铁节点边权为 1 表示上车，地铁节点到原节点边权为 0 表示下车，然后用 0 - 1 BFS 求最短路。

- **作者：yshpdyt（4星）**
    - **关键亮点**：从实际乘坐地铁的场景类比建图，思路直观，详细说明了建图的意义和边权设置，使用普通最短路算法求解。
    - **核心代码**：
```cpp
priority_queue<pair<ll,ll > >q;
ll f[N];
bool vis[N];
vector<pair<ll,ll> >v[N];
map<pair<ll,ll>,ll>mp;
ll n,m,st,ed;
void dij(ll s){
    for(int i=1;i<=n;i++){
        f[i]=inf;
        vis[i]=0;
    }
    f[s]=0;
    q.push({0,st});
    while (!q.empty()){
        auto t=q.top().se;
        q.pop();
        if(vis[t])continue;;
        vis[t]=1;
        for(auto yt:v[t]){
            ll y=yt.fi;
            if(f[y]>f[t]+yt.se){
                f[y]=f[t]+yt.se;
                q.push({-f[y],y});
            }
        }
    }
}
void sol(){
    cin>>n>>m;
    mp.clear();
    for(int i=1;i<=m;i++){
        ll x,y,c;
        cin>>x>>y>>c;
        ll nx=x,ny=y;
        if(!mp[{x,c}]){
            mp[{x,c}]=++n;
            nx=n;
            v[nx].push_back({x,1});
            v[x].push_back({nx,0});
        }else nx=mp[{x,c}];
        if(!mp[{y,c}]){
            mp[{y,c}]=++n;
            ny=n;
            v[ny].push_back({y,1});
            v[y].push_back({ny,0});
        }else ny=mp[{y,c}];
        v[nx].push_back({ny,0});
        v[ny].push_back({nx,0});
    }
    cin>>st>>ed;
    if(st==ed){
        cout<<0<<endl;
        for(int i=1;i<=n;i++)v[i].clear();
        return ;
    }
    ll ans=inf;
    dij(st);
    cout<<f[ed]<<endl;
    for(int i=1;i<=n;i++)v[i].clear();
}
```
核心实现思想：为每个点的每种颜色新建一个虚拟颜色点，同种颜色点之间边权为 0，颜色点到真点边权为 1 表示切换颜色，用 Dijkstra 算法求最短路。

- **作者：Special_Tony（4星）**
    - **关键亮点**：将问题转化为走过特定边权的边，思路清晰，使用双端队列优化的最短路算法，代码简洁。
    - **核心代码**：
```cpp
int t, n, m, x, y, c, d[400005];
vector <pii> v[400005];
deque <int> q;
bitset <400005> vis;
map <int, int> r;
int main () {
    ios::sync_with_stdio (0);
    cin.tie (0);
    cout.tie (0);
    cin >> t;
    while (t --) {
        cin >> n >> m;
        x = n + m;
        r.clear ();
        for (int i = 1; i <= x; ++ i)
            v[i].clear (), vis[i] = 0, d[i] = inf;
        while (m --) {
            cin >> x >> y >> c;
            if (! r[c])
                r[c] = ++ n;
            c = r[c];
            v[x].push_back ({c, 1});
            v[y].push_back ({c, 1});
            v[c].push_back ({x, 0});
            v[c].push_back ({y, 0});
        }
        cin >> x >> y;
        d[x] = 0;
        q.push_back (x);
        while (! q.empty ()) {
            x = q.front ();
            q.pop_front ();
            if (x == y) {
                while (! q.empty ())
                    q.pop_back ();
                cout << d[x] << '\n';
                break ;
            }
            if (vis[x])
                continue ;
            vis[x] = 1;
            for (pii& i : v[x])
                if (d[x] + i.second < d[i.first])
                    if (i.second)
                        d[i.first] = d[x] + 1, q.push_back (i.first);
                    else
                        d[i.first] = d[x], q.push_front (i.first);
        }
    }
    return 0;
}
```
核心实现思想：将每条地铁线路抽象为一个节点，原节点到地铁节点边权为 1 表示上车，地铁节点到原节点边权为 0 表示下车，用双端队列优化的最短路算法求解。

### 最优关键思路或技巧
- **抽象建图**：将每条地铁线路抽象为一个新节点，通过合理设置边权表示上车和下车的代价，将问题转化为最短路问题。
- **0 - 1 BFS**：由于边权只有 0 和 1，使用 0 - 1 BFS 可以优化最短路的求解，时间复杂度为 $O(n + m)$。
- **使用 `map` 重新编号**：处理地铁线路编号不连续的情况，避免空间浪费和清空时的时间开销。

### 可拓展之处
同类型题如不同交通工具换乘最少次数问题、不同类型道路通行最少切换次数问题等，都可以采用类似的建图和最短路求解思路。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法的基础应用。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：最短路算法的模板题。
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：使用更高效的最短路算法求解。

### 个人心得摘录与总结
- **作者：__vector__**：赛时因本题未 AK，赛后朴素分层图做法 TLE，参考他人代码后 AC，意识到部分普通暴力分层图做法可能错误。总结：做题时要深入思考算法的正确性，不能盲目使用常见做法。
- **作者：ATION001**：写普通 BFS 答案错误，提醒判重时要判断边是否走过，而不是节点。总结：在图论问题中，判重条件的选择很关键，要根据问题的特点进行合理设置。

---
处理用时：78.35秒
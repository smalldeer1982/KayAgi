# 题目信息

# Skipping

## 题目描述

现在已经是3024年了，出题的想法早就枯竭。现今的OI以一种修改后的个人参赛形式进行。比赛有$n$道题，编号从$1$到$n$，一道题有一个分数$a_i$和一个参数$b_i$。最开始，评测系统会把第$1$道题丢给选手。当一个选手拿到第$i$道题，他有两个选择：

- 提交，获得$a_i$分
- 跳过，但他再不能去交这道题了。

接下来，评测系统会把编号最大的符合下述条件的题目$j$丢给选手：

- 如果选手提交了$i$题，那么$j<i$
- 如果选手选择跳过，那么$j\leq b_i$

系统不能给选手一道之前给过的题目。如果系统找不到这样的题，那么比赛结束。特别的，如果选手提交第一题，比赛结束。

请你帮助小p拿到最高的可能得分。

## 样例 #1

### 输入

```
4
2
15 16
2 1
5
10 10 100 100 1000
3 4 1 1 1
3
100 49 50
3 2 2
4
100 200 300 1000
2 3 4 1```

### 输出

```
16
200
100
1000```

# AI分析结果

### 题目内容（已为中文，无需翻译）
现在已经是3024年了，出题的想法早就枯竭。现今的OI以一种修改后的个人参赛形式进行。比赛有$n$道题，编号从$1$到$n$，一道题有一个分数$a_i$和一个参数$b_i$。最开始，评测系统会把第$1$道题丢给选手。当一个选手拿到第$i$道题，他有两个选择：

- 提交，获得$a_i$分
- 跳过，但他再不能去交这道题了。

接下来，评测系统会把编号最大的符合下述条件的题目$j$丢给选手：

- 如果选手提交了$i$题，那么$j<i$
- 如果选手选择跳过，那么$j\leq b_i$

系统不能给选手一道之前给过的题目。如果系统找不到这样的题，那么比赛结束。特别的，如果选手提交第一题，比赛结束。

请你帮助小p拿到最高的可能得分。

### 综合分析与结论
这些题解的核心思路大多是将问题转化为图论问题，通过建图和求最短路来解决。部分题解也使用了动态规划结合线段树优化的方法。
- **思路对比**：多数题解将问题转化为求从起点到各点的最小跳过代价，再用前缀和减去该代价得到最大得分。部分题解通过动态规划状态转移求解，如设$dp_i$表示从$i$开始到$n$的最大金币数量。
- **算法要点**：建图时，一般从$i$向$i - 1$连边权为$0$的边，从$i$向$b_i$连边权为$a_i$的边，然后使用Dijkstra算法求最短路。部分题解使用线段树优化动态规划的区间查询和更新操作。
- **解决难点**：主要难点在于如何将题目中的决策过程转化为图的边和权值，以及如何处理跳过和提交题目的逻辑。通过建图和最短路算法可以有效解决这些问题。

### 评分较高的题解
- **作者：AquariusZhao（5星）**
    - **关键亮点**：思路清晰，详细阐述了将问题转化为最短路问题的过程，配有图示帮助理解。
    - **核心代码**：
```cpp
// 从节点1跑Dijkstra
q.push({0, 1});
while(!q.empty()){
    int u = q.top().second;
    q.pop();
    if(vis[u]) continue;
    vis[u] = 1;
    for(auto k : e[u]){
        int v = k.first;
        if(dis[v] > dis[u] + k.second){
            dis[v] = dis[u] + k.second;
            q.push({-dis[v], v});
        }
    }
}
```
核心实现思想：使用优先队列优化的Dijkstra算法，从节点1开始，不断更新到各节点的最短距离。
- **作者：Guchenxi0971（4星）**
    - **关键亮点**：思路简洁明了，直接指出通过前缀和和最短路求解答案，代码注释清晰。
    - **核心代码**：
```cpp
// 建图
for(int i = 1; i <= n; i++){
    e[i].pb({b[i], a[i]});
    if(i!= n) e[i + 1].pb({i, 0});
}
// 求最短路
dj();
// 计算答案
for(int i = 1; i <= n; i++){
    ans = max(ans, sum[i] - dis[i]);
}
```
核心实现思想：先根据规则建图，然后调用Dijkstra算法求最短路，最后用前缀和减去最短路得到最大得分。
- **作者：Xy_top（4星）**
    - **关键亮点**：采用线段树解法，提供了不同于最短路的思路，代码实现完整。
    - **核心代码**：
```cpp
// 线段树更新
void update (int l, int r, int k) {
    if (l == r) {
        mx[k] = min (mx[k], y);
        return;
    }
    int mid = l + r >> 1;
    if (x <= mid) update (l, mid, k << 1);
    else update (mid + 1, r, k << 1 | 1);
    mx[k] = min (mx[k << 1], mx[k << 1 | 1]);
}
// 线段树查询
int query (int l, int r, int k) {
    if (x <= l && y >= r) return mx[k];
    int mid = l + r >> 1, res = 100000000000000000LL;
    if (x <= mid) res = query (l, mid, k << 1);
    if (y > mid) res = min (res, query (mid + 1, r, k << 1 | 1) );
    return res;
}
```
核心实现思想：使用线段树维护区间最小值，通过更新和查询操作实现动态规划的状态转移。

### 最优关键思路或技巧
- **图论建模**：将题目中的决策过程转化为图的边和权值，通过建图和求最短路解决问题。
- **前缀和优化**：使用前缀和预处理，方便计算区间和。
- **线段树优化**：对于动态规划中的区间查询和更新操作，使用线段树可以将时间复杂度优化到$O(n\log n)$。

### 可拓展之处
同类型题或类似算法套路：
- 涉及决策选择和路径规划的问题，如游戏中的关卡选择、资源分配等。
- 动态规划结合线段树优化的问题，如区间最值查询、区间更新等。

### 洛谷推荐题目
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间动态规划问题，需要考虑合并石子的顺序。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：最短路模板题，可用于练习Dijkstra算法。
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：线段树模板题，可用于练习线段树的区间查询和更新操作。

### 个人心得摘录与总结
- **作者：Xy_top**：赛时特判$b_1 = 1$时没输出空格导致掉大分，提醒我们在比赛中要注意细节，仔细检查边界条件和输出格式。
- **作者：superl61**：考场上猜了一个结论，下来验证是对的。强调了在比赛中要大胆猜结论，并利用结论做进一步处理，同时对于转移顺序无明显规律的题，可考虑构图。

---
处理用时：41.96秒
# 题目信息

# Alice's Adventures in Cards

## 题目描述

Alice 正在和红心皇后、红心国王以及红心杰克玩纸牌游戏。这个游戏中有 $ n $ 种不同的纸牌类型。Alice 手上现在有一张类型为 $ 1 $ 的纸牌，她需要通过一系列的交换，得到类型为 $ n $ 的纸牌，才能逃出仙境。而其他三名玩家手上各自持有每种类型的纸牌一张。

在这个游戏中，Alice 可以与这些玩家进行纸牌交换。每位玩家对不同类型纸牌的偏好用排列 $ q $、$ k $ 和 $ j $ 来表示，分别对应红心皇后、红心国王和红心杰克。

对于任意玩家，如果在他们的排列 $ p $ 中，满足 $ p_a > p_b $ ，那么该玩家就认为类型为 $ a $ 的纸牌比类型为 $ b $ 的更有价值。于是，他们愿意用类型为 $ b $ 的纸牌换取类型为 $ a $ 的纸牌。而 Alice 的偏好简单直观：纸牌类型 $ a $ 比类型 $ b $ 更有价值，当且仅当 $ a > b $ ，并且她只会按照这种偏好进行交换。

请判断 Alice 能否通过与其他玩家的交换，从类型为 $ 1 $ 的纸牌升级到类型为 $ n $ 的纸牌。如果可以，请给出可能的交换方案。

$ ^{\text{∗}} $ 长度为 $ n $ 的排列是一个包含 $ n $ 个不同整数（从 $ 1 $ 到 $ n $）的数组。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 和 $ [1,3,4] $ 则不是。

## 说明/提示

在第一个测试用例中，Alice 可以与红心国王交换以获得类型为 $ 2 $ 的纸牌，接着再与红心皇后交换以得到类型为 $ 3 $ 的纸牌。

在第二个测试用例中，尽管 Alice 能与红心皇后交换得到类型为 $ 3 $ 的纸牌，再接着与红心国王交换得到类型为 $ 2 $，最后与红心杰克交换得到类型为 $ 4 $ 的纸牌，但这种方案不符合 Alice 的偏好原则，因此无效。我们可以证明在这种情况下 Alice 无法获得类型为 $ 4 $ 的纸牌。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
3
1 3 2
2 1 3
1 2 3
4
2 3 1 4
1 2 3 4
1 4 2 3```

### 输出

```
YES
2
k 2
q 3
NO```

# AI分析结果

### 题目内容（已为中文，无需重写）
【题目内容】
# Alice's Adventures in Cards

## 题目描述

Alice 正在和红心皇后、红心国王以及红心杰克玩纸牌游戏。这个游戏中有 $ n $ 种不同的纸牌类型。Alice 手上现在有一张类型为 $ 1 $ 的纸牌，她需要通过一系列的交换，得到类型为 $ n $ 的纸牌，才能逃出仙境。而其他三名玩家手上各自持有每种类型的纸牌一张。

在这个游戏中，Alice 可以与这些玩家进行纸牌交换。每位玩家对不同类型纸牌的偏好用排列 $ q $、$ k $ 和 $ j $ 来表示，分别对应红心皇后、红心国王和红心杰克。

对于任意玩家，如果在他们的排列 $ p $ 中，满足 $ p_a > p_b $ ，那么该玩家就认为类型为 $ a $ 的纸牌比类型为 $ b $ 的更有价值。于是，他们愿意用类型为 $ b $ 的纸牌换取类型为 $ a $ 的纸牌。而 Alice 的偏好简单直观：纸牌类型 $ a $ 比类型 $ b $ 更有价值，当且仅当 $ a > b $ ，并且她只会按照这种偏好进行交换。

请判断 Alice 能否通过与其他玩家的交换，从类型为 $ 1 $ 的纸牌升级到类型为 $ n $ 的纸牌。如果可以，请给出可能的交换方案。

$ ^{\text{∗}} $ 长度为 $ n $ 的排列是一个包含 $ n $ 个不同整数（从 $ 1 $ 到 $ n $）的数组。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 和 $ [1,3,4] $ 则不是。

## 说明/提示

在第一个测试用例中，Alice 可以与红心国王交换以获得类型为 $ 2 $ 的纸牌，接着再与红心皇后交换以得到类型为 $ 3 $ 的纸牌。

在第二个测试用例中，尽管 Alice 能与红心皇后交换得到类型为 $ 3 $ 的纸牌，再接着与红心国王交换得到类型为 $ 2 $，最后与红心杰克交换得到类型为 $ 4 $ 的纸牌，但这种方案不符合 Alice 的偏好原则，因此无效。我们可以证明在这种情况下 Alice 无法获得类型为 $ 4 $ 的纸牌。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
3
1 3 2
2 1 3
1 2 3
4
2 3 1 4
1 2 3 4
1 4 2 3```

### 输出

```
YES
2
k 2
q 3
NO```

### 综合分析与结论
- **思路对比**：
    - xzy090626 的题解采用类似 Dijkstra 算法的思路，每次找编号最小的数进行松弛，不断扩展能到达的更大编号的位置。
    - CWzwz 的题解则是从小到大枚举数字，通过三个值域 BIT 维护每个人的信息，转移出每个数字是否能被拿到的状态，最后从 $n$ 往前回溯得到交换过程。
- **算法要点**：
    - xzy090626 使用 set 维护三个排列的偏好置换，通过优先队列进行节点扩展，复杂度为 $O(n\log n)$。
    - CWzwz 使用值域 BIT 支持查询满足条件的状态的或和，实现状态转移。
- **解决难点**：
    - xzy090626 的难点在于如何高效地找到能到达的更大编号的位置，通过删除已松弛过的位置来优化查找过程。
    - CWzwz 的难点在于如何利用 BIT 进行状态转移和回溯交换过程。

### 所选题解
- **xzy090626 的题解（4星）**
    - **关键亮点**：思路清晰，使用 set 和优先队列实现了类似 Dijkstra 算法的过程，代码实现较为完整。
    - **重点代码**：
```cpp
priority_queue<int,vector<int>,greater<int>>q;
vector<bool>vis(n+5),ok(n+5);
vector<pii>lst(n+5);
q.push(1); ok[1] = 1;
set<int>tt;
for(int i=2;i<=n;++i) tt.insert(i);
while(!q.empty()){
    int u = q.top();q.pop();
    if(vis[u]) continue;
    vis[u] = 1;
    vector<int>vec;
    for(auto c:tt){
        if(c<=u) vec.push_back(c);
        else break;
    }
    for(auto c:vec){
        tt.erase(c);
        ok[c] = 1;
        for(int i=1;i<=3;++i){
            pii tmp = {pos[i][c],c};
            if(st[i].count(tmp)) st[i].erase(tmp);
        }
    }
    vec.clear();
    for(int i=1;i<=3;++i){
        for(auto c:st[i]){
            if(pos[i][c.y]>=pos[i][u]) break;
            if(ok[c.y]) continue;
            if(tt.count(c.y)) tt.erase(c.y);
            ok[c.y] = 1;
            q.push(c.y);
            vec.push_back(c.y);
            lst[c.y] = {u,i};
        }
    }
    for(auto c:vec){
        for(int i=1;i<=3;++i){
            pii tmp = {pos[i][c],c};
            if(st[i].count(tmp)) st[i].erase(tmp);
        }
    }
}
```
**核心实现思想**：使用优先队列存储待扩展的节点，每次取出编号最小的节点进行扩展，通过 set 维护未扩展的节点和每个排列的偏好置换，删除已扩展的节点，找到能到达的更大编号的节点并加入优先队列。

### 最优关键思路或技巧
- xzy090626 使用 set 维护排列的偏好置换，通过删除已松弛的位置来优化查找能到达的更大编号的位置，利用优先队列实现类似 Dijkstra 算法的过程，保证了复杂度为 $O(n\log n)$。

### 可拓展之处
同类型题可能涉及更多玩家或更多纸牌类型，或者改变交换规则。类似算法套路可以应用于状态转移和路径查找的问题，如使用优先队列进行节点扩展，使用数据结构（如 set、BIT 等）优化查找和状态维护。

### 推荐洛谷题目
- P1144 最短路计数
- P3371 单源最短路径（弱化版）
- P3385 负环

### 个人心得摘录与总结
- **CWzwz**：提到本题奇怪，不太符合 CF 一贯出题风格，B 题浪费 50min，赛后 3min 才过 D，总结自己表现不佳。说明在比赛中合理分配时间很重要，避免在简单题上花费过多时间影响后续题目解答。 

---
处理用时：39.74秒
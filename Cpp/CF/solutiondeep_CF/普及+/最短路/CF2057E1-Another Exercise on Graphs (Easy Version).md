# 题目信息

# Another Exercise on Graphs (Easy Version)

## 题目描述

这是该问题的简单版本。不同版本间的区别在于此版本对 $m$ 有额外约束。只有在你解决了该问题的所有版本后，才能进行 hack。

最近，"T-generation" 的导师需要筹备一场训练赛。他们发现缺少一道题目，且整场比赛中没有图论相关的问题，于是设计了如下题目。

给定一个包含 $n$ 个顶点和 $m$ 条边的连通带权无向图，图中无自环和重边。

处理 $q$ 次形如 $(a, b, k)$ 的查询：在从顶点 $a$ 到顶点 $b$ 的所有路径中，找出路径上边权的第 $k$ 小最大值$^{\dagger}$。

导师们认为这个问题非常有趣，但存在一个问题：他们不知道如何解决它。请帮助他们解决这个问题，因为距离比赛开始仅剩几小时。

$^{\dagger}$ 设 $w_1 \ge w_2 \ge \ldots \ge w_{h}$ 为某条路径中所有边权按非递增顺序排列后的结果。该路径边权的第 $k$ 大值即为 $w_{k}$。


## 说明/提示

在第一个测试用例中，第一次查询的最优路径之一是 $1 \rightarrow 3 \rightarrow 4$，该路径边权的第 $2$ 大值为 $1$。第二次查询的最优路径之一是 $2 \rightarrow 4 \rightarrow 3$，边权的第 $1$ 大值为 $2$。

在第二个测试用例中，第一次查询的最优路径之一是 $1 \rightarrow 2 \rightarrow 4 \rightarrow 5 \rightarrow 6$，该路径边权的第 $3$ 大值为 $2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
4 4 2
1 2 2
2 4 2
1 3 4
3 4 1
1 4 2
2 3 1
6 7 3
1 2 10
2 3 3
3 4 9
4 5 2
5 6 1
2 4 10
4 6 10
1 6 3
1 6 2
2 4 1
11 17 10
1 4 5
1 3 19
1 2 10
3 2 13
4 5 1
4 6 11
3 5 9
3 6 18
2 7 17
5 8 15
5 10 8
6 9 4
7 10 20
7 8 16
8 11 3
9 11 6
10 11 14
3 11 1
3 11 3
1 11 1
1 11 4
1 11 3
8 2 2
10 4 1
3 9 2
3 9 1
6 7 3```

### 输出

```
1 2
2 9 9
11 3 11 1 3 10 8 4 11 4```

# AI分析结果

### 题目中文重写
#### 图的另一道练习题（简单版本）

#### 题目描述
这是该问题的简单版本。不同版本间的区别在于此版本对 $m$ 有额外约束。只有在你解决了该问题的所有版本后，才能进行 hack。

最近，“T 世代”的导师需要筹备一场训练赛。他们发现缺少一道题目，且整场比赛中没有图论相关的问题，于是设计了如下题目。

给定一个包含 $n$ 个顶点和 $m$ 条边的连通带权无向图，图中无自环和重边。

处理 $q$ 次形如 $(a, b, k)$ 的查询：在从顶点 $a$ 到顶点 $b$ 的所有路径中，找出路径上边权的第 $k$ 小最大值$^{\dagger}$。

导师们认为这个问题非常有趣，但存在一个问题：他们不知道如何解决它。请帮助他们解决这个问题，因为距离比赛开始仅剩几小时。

$^{\dagger}$ 设 $w_1 \ge w_2 \ge \ldots \ge w_{h}$ 为某条路径中所有边权按非递增顺序排列后的结果。该路径边权的第 $k$ 大值即为 $w_{k}$。

#### 说明/提示
在第一个测试用例中，第一次查询的最优路径之一是 $1 \rightarrow 3 \rightarrow 4$，该路径边权的第 $2$ 大值为 $1$。第二次查询的最优路径之一是 $2 \rightarrow 4 \rightarrow 3$，边权的第 $1$ 大值为 $2$。

在第二个测试用例中，第一次查询的最优路径之一是 $1 \rightarrow 2 \rightarrow 4 \rightarrow 5 \rightarrow 6$，该路径边权的第 $3$ 大值为 $2$。

#### 样例 #1
##### 输入
```
3
4 4 2
1 2 2
2 4 2
1 3 4
3 4 1
1 4 2
2 3 1
6 7 3
1 2 10
2 3 3
3 4 9
4 5 2
5 6 1
2 4 10
4 6 10
1 6 3
1 6 2
2 4 1
11 17 10
1 4 5
1 3 19
1 2 10
3 2 13
4 5 1
4 6 11
3 5 9
3 6 18
2 7 17
5 8 15
5 10 8
6 9 4
7 10 20
7 8 16
8 11 3
9 11 6
10 11 14
3 11 1
3 11 3
1 11 1
1 11 4
1 11 3
8 2 2
10 4 1
3 9 2
3 9 1
6 7 3
```

##### 输出
```
1 2
2 9 9
11 3 11 1 3 10 8 4 11 4
```

### 综合分析与结论
这些题解的核心思路都是将边权进行重新赋值，把边权小于等于某个值的边设为 $0$，大于该值的边设为 $1$，通过判断两点间最短路与 $k$ 的大小关系来确定答案。主要区别在于预处理和优化方式不同。

- **思路对比**：
    - DerrickLo、littlebug 和 What__can__I__say 的思路类似，都是先二分答案，再预处理不同边权限制下的最短路。
    - ax_by_c 提出枚举答案，通过松弛操作更新最短路，还提到了利用 MST 优化。
    - Wuming_Shi 采用离线处理，按边权从小到大加边，结合并查集和 Floyd 维护连通块间的最短路。

- **算法要点对比**：
    - 多数题解使用 Floyd 算法预处理最短路。
    - DerrickLo 和 ax_by_c 提出了优化思路，将时间复杂度从 $O(n^2m)$ 降到 $O(n^3)$。

- **解决难点对比**：
    - 主要难点在于如何高效地更新不同边权限制下的最短路。
    - 部分题解通过缩点、利用 MST 等方法减少不必要的计算。

### 所选题解
- **作者：DerrickLo（5 星）**
    - **关键亮点**：思路清晰，提出了有效的优化方法，将时间复杂度从 $O(n^2m)$ 降到 $O(n^3)$。
    - **核心代码**：
```cpp
while(t--){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)fa[i]=i;
    memset(g,0x3f,sizeof g);
    for(int i=1;i<=m;i++)cin>>e[i].u>>e[i].v>>e[i].w,g[e[i].u][e[i].v]=g[e[i].v][e[i].u]=1;
    for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
    sort(e+1,e+m+1);
    int cnt=0;
    for(int i=1;i<=n;i++)g[i][i]=0;
    for(int i=0;i<=n-1;i++)for(int j=1;j<=n;j++)for(int k=1;k<=n;k++)f[i][j][k]=g[j][k];
    for(int i=1;i<=m;i++){
        int fx=find(e[i].u),fy=find(e[i].v);
        if(fx==fy)continue;cnt++;
        ed[cnt]=e[i],fa[fx]=fy;
        for(int x=1;x<=n;x++)for(int y=1;y<=n;y++){
            f[cnt][x][y]=min({f[cnt-1][x][y],f[cnt-1][x][e[i].u]+f[cnt-1][y][e[i].v],f[cnt-1][x][e[i].v]+f[cnt-1][y][e[i].u]});
        }
    }
    while(q--){
        cin>>a>>b>>k;
        int l=1,r=cnt,ans=0;
        while(l<=r){
            int mid=l+r>>1;
            if(f[mid][a][b]<k)ans=mid,r=mid-1;
            else l=mid+1;
        }
        cout<<ed[ans].w<<" ";
    }
    cout<<"\n";
}
```
    - **核心实现思想**：先使用 Floyd 算法预处理初始最短路，然后按边权排序，利用并查集合并连通块，更新不同边权限制下的最短路。最后二分答案，根据最短路与 $k$ 的大小关系确定结果。

- **作者：What__can__I__say（4 星）**
    - **关键亮点**：代码实现较为完整，详细说明了状态转移方程。
    - **核心代码**：
```cpp
T=rd();
while(T--){
    n=rd();m=rd();q=rd();
    for(int i=1;i<=m;++i)a[i].u=rd(),a[i].v=rd(),a[i].w=rd();
    sort(a+1,a+1+m,cmp);
    for(int i=0;i<=m;++i){
        for(int j=1;j<=n;++j){
            for(int k=1;k<=n;++k){
                f[i][j][k]=JYAAKIOI;
            }
        }
    }
    for(int i=0;i<=n;++i)f[0][i][i]=0;
    for(int i=1;i<=m;++i)f[0][a[i].u][a[i].v]=f[0][a[i].v][a[i].u]=1;
    for(int k=1;k<=n;++k){
        for(int i=1;i<=n;++i){
            for(int j=1;j<=n;++j){
                f[0][i][j]=min(f[0][i][j],f[0][i][k]+f[0][k][j]);
            }
        }
    }
    for(int k=1;k<=m;++k){
        int u=a[k].u,v=a[k].v;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=n;++j){
                f[k][i][j]=min(f[k-1][i][j],min(f[k-1][i][u]+f[k-1][v][j],f[k-1][i][v]+f[k-1][u][j]));
            }
        }
    }
    while(q--){
        int u=rd(),v=rd(),k=rd();
        int l=1,r=M,res=-1;
        while(l<=r){
            int mid=(l+r)>>1;
            if(f[mid][u][v]<k){
                r=mid-1;
                res=mid;
            }
            else l=mid+1;
        }
        wr(a[res].w),put(' ');
    }
    put('\n');
}
```
    - **核心实现思想**：先对边按边权排序，使用 Floyd 算法预处理初始最短路。然后枚举每条边，更新不同边权限制下的最短路。最后二分答案，根据最短路与 $k$ 的大小关系确定结果。

### 最优关键思路或技巧
- **边权重新赋值**：将边权小于等于某个值的边设为 $0$，大于该值的边设为 $1$，通过判断两点间最短路与 $k$ 的大小关系来确定答案。
- **二分答案**：在可能的答案范围内进行二分查找，减少不必要的计算。
- **缩点和 MST 优化**：通过缩点和只处理 MST 上的边，减少不必要的松弛操作，降低时间复杂度。

### 可拓展之处
- 同类型题：可以考虑有向图、带负权边的图等情况。
- 类似算法套路：可以结合其他图论算法，如 Dijkstra、SPFA 等，处理不同类型的图。

### 洛谷推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法和动态更新最短路。
- [P2888 [USACO07NOV]Cow Hurdles S](https://www.luogu.com.cn/problem/P2888)：与本题类似，需要找出路径上的最大边权。
- [P1346 电车](https://www.luogu.com.cn/problem/P1346)：可以使用 Floyd 算法解决的图论问题。

### 个人心得摘录与总结
littlebug 提到“我也不知道怎么想到的，神仙思路/bx ”，表达了对将问题转化为重新赋权求最短路这一思路的惊叹，说明在解题时需要大胆尝试和创新思维。 

---
处理用时：59.35秒
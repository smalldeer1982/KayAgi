# 题目信息

# Greg and Graph

## 题目描述

Greg 有一个有边权的有向图，包含 $n$ 个点。这个图的每两个点之间都有两个方向的边。Greg 喜欢用他的图玩游戏，现在他发明了一种新游戏：

- 游戏包含 $n$ 步。
- 第 $i$ 步 Greg 从图中删掉编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。
- 在执行每一步之前，Greg 想知道所有点对间最短路长度的和。最短路可以经过任何没删掉的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删掉 $x_i$ 前 $v$ 和 $u$ 间的最短路长度，那么Greg想知道下面这个求和的值：$\sum_{v, u, v \neq u} d(i, v, u)$ 。

帮帮 Greg，输出每一步之前要求的值。

## 样例 #1

### 输入

```
1
0
1
```

### 输出

```
0 ```

## 样例 #2

### 输入

```
2
0 5
4 0
1 2
```

### 输出

```
9 0 ```

## 样例 #3

### 输入

```
4
0 3 1 1
6 0 400 1
2 4 0 1
1 1 1 0
4 1 2 3
```

### 输出

```
17 23 404 0 ```

# AI分析结果

### 思路对比
所有题解核心思路一致，均采用逆向思维，将删点问题转化为加点问题，利用 Floyd 算法求解。但在代码实现细节上略有不同。

### 算法要点对比
- **输入输出处理**：部分题解使用了快读快写优化输入输出，如 RainAir 的题解；部分则使用常规的 `scanf` 和 `printf`。
- **数组命名**：不同题解对存储图、删除顺序、答案等的数组命名不同，但功能一致。
- **Floyd 算法实现**：大部分题解在 Floyd 算法更新最短路径时逻辑相同，但在判断点是否存在于图中以统计最短路和的位置上有差异。

### 解决难点对比
所有题解都解决了 Floyd 算法不支持删点的难点，通过逆向思维将问题转化为加点问题，避免了直接删点带来的复杂度问题。

### 评分
- **Dream_weavers**：5 星。思路清晰，代码简洁，对正向思路和逆向思路的分析详细，易于理解。
- **RainAir**：4 星。使用了快读优化，代码结构完整，但包含较多模板代码，增加了阅读难度。
- **Gerald_Chen**：4 星。思路和代码都很清晰，对逆向思维的解释明确。

### 所选题解
- **Dream_weavers（5 星）**
    - **关键亮点**：思路清晰，代码简洁，对正向和逆向思路分析详细。
    - **核心代码**：
```cpp
for(int l=n;l>=1;l--){
    int k=x[l];vis[k]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
    sum=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(vis[i]&&vis[j])
                sum+=d[i][j];
    ans[l]=sum;
}
```
核心思想：倒序遍历删除的点，将其作为新加入的点，进行一次 Floyd 算法更新最短路径，然后统计当前图中存在的点的最短路和。
- **RainAir（4 星）**
    - **关键亮点**：使用快读优化输入，代码结构完整。
    - **核心代码**：
```c++
RFOR(p,N,1){
    int k = del[p];
    tag[k] = true;
    FOR(i,1,N){
        FOR(j,1,N){
            f[i][j] = std::min(f[i][j],f[i][k] + f[k][j]);
            if(tag[i] && tag[j]) ans[p] += f[i][j];
        }
    }
}
```
核心思想：同样倒序遍历删除的点，标记其存在，进行 Floyd 算法更新路径并统计最短路和。
- **Gerald_Chen（4 星）**
    - **关键亮点**：思路和代码清晰，对逆向思维解释明确。
    - **核心代码**：
```cpp
for(int cur=n; cur; --cur) {
    int k=del[cur];
    avi[k]=true;
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j)
            if(i!=j) {
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
                if(avi[i] && avi[j])
                    ans[cur]+=dist[i][j];
            }
}
```
核心思想：倒序处理删除的点，将其加入图中，进行 Floyd 算法更新并统计答案。

### 最优关键思路或技巧
- **逆向思维**：将删点问题转化为加点问题，避免了 Floyd 算法不支持删点的难题，降低了时间复杂度。
- **Floyd 算法**：用于求解全源最短路问题，通过不断更新中转点来更新任意两点间的最短路径。

### 拓展
同类型题可考虑在图的操作上进行变化，如增加边的操作、修改边权等，仍可采用逆向思维将操作反转，利用 Floyd 算法求解。

### 洛谷相似题目推荐
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)
- [P2934 [USACO09JAN]Safe Travel G](https://www.luogu.com.cn/problem/P2934)

### 个人心得摘录与总结
- **MuYC**：做完题后回来补题解，强调本题思路很妙。通过观察 Floyd 算法代码，发现正向删点难以找到被更新的路径，采用逆向加点的方法，将加入的点作为中转点，去掉了 Floyd 算法中的一层循环，将时间复杂度从 $O(n^4)$ 降为 $O(n^3)$。
- **tzl_Dedicatus545**：指出本题要开 `long long` 避免 `int` 溢出，还强调在 Floyd 内更新最短路径时不能先判断点是否可用，而应先更新再判断，避免后续转移出现问题。 

---
处理用时：28.79秒
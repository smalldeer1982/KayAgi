# 题目信息

# Magical Array

## 题目描述

Eric has an array $ b $ of length $ m $ , then he generates $ n $ additional arrays $ c_1, c_2, \dots, c_n $ , each of length $ m $ , from the array $ b $ , by the following way:

Initially, $ c_i = b $ for every $ 1 \le i \le n $ . Eric secretly chooses an integer $ k $ $ (1 \le k \le n) $ and chooses $ c_k $ to be the special array.

There are two operations that Eric can perform on an array $ c_t $ :

- Operation 1: Choose two integers $ i $ and $ j $ ( $ 2 \leq i < j \leq m-1 $ ), subtract $ 1 $ from both $ c_t[i] $ and $ c_t[j] $ , and add $ 1 $ to both $ c_t[i-1] $ and $ c_t[j+1] $ . That operation can only be used on a non-special array, that is when $ t \neq k $ .;
- Operation 2: Choose two integers $ i $ and $ j $ ( $ 2 \leq i < j \leq m-2 $ ), subtract $ 1 $ from both $ c_t[i] $ and $ c_t[j] $ , and add $ 1 $ to both $ c_t[i-1] $ and $ c_t[j+2] $ . That operation can only be used on a special array, that is when $ t = k $ .Note that Eric can't perform an operation if any element of the array will become less than $ 0 $ after that operation.

Now, Eric does the following:

- For every non-special array $ c_i $ ( $ i \neq k $ ), Eric uses only operation 1 on it at least once.
- For the special array $ c_k $ , Eric uses only operation 2 on it at least once.

Lastly, Eric discards the array $ b $ .

For given arrays $ c_1, c_2, \dots, c_n $ , your task is to find out the special array, i.e. the value $ k $ . Also, you need to find the number of times of operation $ 2 $ was used on it.

## 说明/提示

In the first test case, the secret array $ b $ is $ [0, 1, 1, 1, 1, 1, 1, 1, 0] $ . Array $ c_1 $ and array $ c_2 $ are generated by using operation 1. Array $ c_3 $ is generated by using operation 2.

For Array $ c_1 $ ,you can choose $ i=4 $ and $ j=5 $ perform Operation 1 one time to generate it. For Array $ c_2 $ , you can choose $ i=6 $ and $ j=7 $ perform Operation 1 one time to generate it. For Array $ c_3 $ ,you can choose $ i=4 $ and $ j=5 $ perform Operation 2 one time to generate it.

In the second test case, the secret array $ b $ is $ [20, 20, 20, 20, 20, 20, 20] $ . You can also find that array $ c_1 $ and array $ c_2 $ are generated by using Operation 1. Array $ c_3 $ is generated by using Operation 2.

In the third test case, the secret array $ b $ is $ [20, 20, 20, 20, 20, 20, 20, 20, 20] $ . You can also find that array $ c_1 $ and array $ c_2 $ are generated by using Operation 1. Array $ c_3 $ is generated by using Operation 2.

## 样例 #1

### 输入

```
7
3 9
0 1 2 0 0 2 1 1 0
0 1 1 1 2 0 0 2 0
0 1 2 0 0 1 2 1 0
3 7
25 15 20 15 25 20 20
26 14 20 14 26 20 20
25 15 20 15 20 20 25
3 9
25 15 20 15 25 20 20 20 20
26 14 20 14 26 20 20 20 20
25 15 20 15 25 15 20 20 25
3 11
25 15 20 15 25 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20
25 15 20 15 25 20 15 20 20 20 25
3 13
25 15 20 15 25 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 15 20 20 20 20 25
3 15
25 15 20 15 25 20 20 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 20 15 20 20 20 20 20 25
3 9
909459 479492 676924 224197 162866 164495 193268 742456 728277
948845 455424 731850 327890 304150 237351 251763 225845 798316
975446 401170 792914 272263 300770 242037 236619 334316 725899```

### 输出

```
3 1
3 10
3 15
3 20
3 25
3 30
1 1378716```

# AI分析结果

### 题目中文重写
# 神奇数组

## 题目描述

Eric 有一个长度为 $m$ 的数组 $b$，然后他通过以下方式从数组 $b$ 生成 $n$ 个额外的长度为 $m$ 的数组 $c_1, c_2, \dots, c_n$：

最初，对于每个 $1 \le i \le n$，都有 $c_i = b$。Eric 秘密地选择一个整数 $k$（$1 \le k \le n$），并选择 $c_k$ 作为特殊数组。

Eric 可以对数组 $c_t$ 执行两种操作：
- 操作 1：选择两个整数 $i$ 和 $j$（$2 \leq i < j \leq m - 1$），将 $c_t[i]$ 和 $c_t[j]$ 都减 1，并将 $c_t[i - 1]$ 和 $c_t[j + 1]$ 都加 1。该操作只能用于非特殊数组，即当 $t \neq k$ 时。
- 操作 2：选择两个整数 $i$ 和 $j$（$2 \leq i < j \leq m - 2$），将 $c_t[i]$ 和 $c_t[j]$ 都减 1，并将 $c_t[i - 1]$ 和 $c_t[j + 2]$ 都加 1。该操作只能用于特殊数组，即当 $t = k$ 时。注意，如果执行操作后数组的任何元素将变为负数，则 Eric 不能执行该操作。

现在，Eric 进行以下操作：
- 对于每个非特殊数组 $c_i$（$i \neq k$），Eric 至少对其使用一次操作 1。
- 对于特殊数组 $c_k$，Eric 至少对其使用一次操作 2。

最后，Eric 丢弃数组 $b$。

对于给定的数组 $c_1, c_2, \dots, c_n$，你的任务是找出特殊数组，即值 $k$。此外，你还需要找出对其使用操作 2 的次数。

## 说明/提示
在第一个测试用例中，秘密数组 $b$ 是 $[0, 1, 1, 1, 1, 1, 1, 1, 0]$。数组 $c_1$ 和数组 $c_2$ 是通过使用操作 1 生成的。数组 $c_3$ 是通过使用操作 2 生成的。

对于数组 $c_1$，你可以选择 $i = 4$ 和 $j = 5$ 执行一次操作 1 来生成它。对于数组 $c_2$，你可以选择 $i = 6$ 和 $j = 7$ 执行一次操作 1 来生成它。对于数组 $c_3$，你可以选择 $i = 4$ 和 $j = 5$ 执行一次操作 2 来生成它。

在第二个测试用例中，秘密数组 $b$ 是 $[20, 20, 20, 20, 20, 20, 20]$。你还可以发现数组 $c_1$ 和数组 $c_2$ 是通过使用操作 1 生成的。数组 $c_3$ 是通过使用操作 2 生成的。

在第三个测试用例中，秘密数组 $b$ 是 $[20, 20, 20, 20, 20, 20, 20, 20, 20]$。你还可以发现数组 $c_1$ 和数组 $c_2$ 是通过使用操作 1 生成的。数组 $c_3$ 是通过使用操作 2 生成的。

## 样例 #1
### 输入
```
7
3 9
0 1 2 0 0 2 1 1 0
0 1 1 1 2 0 0 2 0
0 1 2 0 0 1 2 1 0
3 7
25 15 20 15 25 20 20
26 14 20 14 26 20 20
25 15 20 15 20 20 25
3 9
25 15 20 15 25 20 20 20 20
26 14 20 14 26 20 20 20 20
25 15 20 15 25 15 20 20 25
3 11
25 15 20 15 25 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20
25 15 20 15 25 20 15 20 20 20 25
3 13
25 15 20 15 25 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 15 20 20 20 20 25
3 15
25 15 20 15 25 20 20 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 20 15 20 20 20 20 20 25
3 9
909459 479492 676924 224197 162866 164495 193268 742456 728277
948845 455424 731850 327890 304150 237351 251763 225845 798316
975446 401170 792914 272263 300770 242037 236619 334316 725899
```

### 输出
```
3 1
3 10
3 15
3 20
3 25
3 30
1 1378716
```

### 综合分析与结论
这些题解的核心目标都是找出特殊数组及其操作 2 的使用次数。主要思路有两种：一是通过构造一个值（如 $\sum_{i = 1}^{m}i\times c_{t,i}$ ），利用该值在操作 1 下不变、在操作 2 下每次增加 1 的特性来区分特殊数组并计算操作次数；二是将数组看作差分序列，分析操作对原序列总和的影响来找出特殊数组。

### 所选题解
- **作者：_cyle_King（5星）**
    - **关键亮点**：思路清晰，通过物理学中的功能原理进行类比，形象地解释了构造势能函数的原因，代码注释详细。
    - **个人心得**：作者提到这题很鬼畜，在赛场上想出解法很不容易。
    - **核心代码**：
```cpp
inline LL calc(vector<LL> &a){
    LL res=0;
    rep(i,1,m) res+=a[i]*i;
    return res;
}

signed main(){
    cin>>T;
    while(T--){
        cin>>n>>m;
        c.clear();
        c.emplace_back();
        rep(i,1,n){
            c.emplace_back();
            c[i].emplace_back(0);
            rep(j,1,m){
                int now;cin>>now;
                c[i].emplace_back(now);
            }
        }
        a[1]=calc(c[1]);
        rep(i,2,n){
            a[i]=calc(c[i]);
            if(a[i]!=a[1]){
                cout<<(a[1]>a[i]?1:i)<<' '<<abs(a[i]-a[1])<<'\n';
                break;
            }
        }
    }
    return 0;
}
```
核心实现思想：定义势能函数 `calc` 计算每个数组的势能，通过比较势能找出特殊数组，并计算操作 2 的次数。

- **作者：Presentation_Emitter（4星）**
    - **关键亮点**：简洁明了地指出了操作后关于非特殊数列的不变量 $H_i=\sum_{j = 1}^{m}jC_{i,j}$，并说明了特殊数列操作后该值的变化情况。
    - **核心思路**：通过计算每个数组的 $H_i$ 值，找出最大的 $H_i$ 对应的数组即为特殊数组，最大的 $H_i$ 减去最小的 $H_i$ 即为操作 2 的次数。

- **作者：OLE_OIer（4星）**
    - **关键亮点**：详细推导了构造值 $\sum_{i = 1}^{m}(a_i\times i)$ 在操作前后的变化情况，逻辑严谨。
    - **核心代码**：
```cpp
void func(){
    int minn=1ll<<60,maxn=0;
    int n,m,k;cin>>n>>m;
    for(int i=1;i<=n;++i){
        int tot=0;
        for(int j=1;j<=m;++j){
            int x;cin>>x,tot+=j*x;
        }
        minn=min(minn,tot);
        if(maxn<tot) maxn=tot,k=i;
    }
    cout<<k<<" "<<maxn-minn<<"\n";
    return;
}
```
核心实现思想：计算每个数组的 $\sum_{i = 1}^{m}(a_i\times i)$ 值，记录最小值和最大值及其对应的数组编号，输出最大值对应的数组编号和最大值与最小值的差值。

### 最优关键思路或技巧
构造一个值 $\sum_{i = 1}^{m}i\times c_{i}$，利用该值在操作 1 下不变、在操作 2 下每次增加 1 的特性，通过比较该值找出特殊数组并计算操作 2 的次数。这种思路将复杂的数组操作转化为简单的数值比较，避免了还原原数组 $b$ 的困难。

### 可拓展之处
同类型题可能会有更多种类的操作，或者操作对数组元素的影响更加复杂。类似的算法套路是寻找操作下的不变量或有规律变化的量，通过这些量来区分不同类型的操作或数组。

### 洛谷相似题目推荐
1. [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)：需要找出合适的参数，使得某个计算结果满足特定条件，可通过寻找不变量和有规律变化的量来优化计算。
2. [P2671 求和](https://www.luogu.com.cn/problem/P2671)：需要根据题目条件找出满足特定关系的元素组合，可通过构造合适的计算式来简化问题。
3. [P3951 小凯的疑惑](https://www.luogu.com.cn/problem/P3951)：需要通过分析数论中的规律来解决问题，与寻找操作下的规律有相似之处。

### 个人心得摘录总结
- _cyle_King 提到这题很鬼畜，在赛场上想出解法很不容易，说明本题有一定的难度和思维挑战。
- fast_photon 表示这是第一道借助物理知识做出来的 OI 题，强调了跨学科思维在解题中的应用。 

---
处理用时：64.14秒
# 题目信息

# Clique Problem

## 题目描述

数轴上有 $n$ 个点，第 $i$ 个点的坐标为 $x_i$，权值为  $w_i$。两个点 $i,j$ 之间存在一条边当且仅当 $abs(x_i-x_j)\geq w_i+w_j$ 。 你需要求出这张图的最大团的点数。

团的定义：两两之间有边的顶点集合。

## 样例 #1

### 输入

```
4
2 3
3 1
6 1
0 2
```

### 输出

```
3
```

# AI分析结果

### 题目翻译
#### 团问题

#### 题目描述
数轴上有 $n$ 个点，第 $i$ 个点的坐标为 $x_i$，权值为  $w_i$。当且仅当 $|x_i - x_j| \geq w_i + w_j$ 时，两个点 $i$ 和 $j$ 之间存在一条边。你需要求出这张图的最大团的点数。

团的定义：两两之间有边的顶点集合。

#### 样例 #1
##### 输入
```
4
2 3
3 1
6 1
0 2
```
##### 输出
```
3
```

### 综合分析与结论
这些题解的核心思路都是将原问题转化为线段覆盖问题。通过对条件 $|x_i - x_j| \geq w_i + w_j$ 进行化简，设 $l_i = x_i - w_i$，$r_i = x_i + w_i$，在 $x_i \geq x_j$ 的情况下将条件转化为 $l_i \geq r_j$，这意味着两个点对应的线段 $[l_i, r_i]$ 和 $[l_j, r_j]$ 不重叠。因此，原问题就变成了从数轴上的一些线段中选取尽可能多的线段，使得它们互不重叠，这是一个经典的贪心问题。

不同题解的主要差异在于代码实现细节，如结构体定义、排序方式、输入输出方式等。部分题解还采用了不同的优化思路，如二分查找、线段树优化等，但本质上都是为了解决线段覆盖问题。

### 高评分题解
- **作者：NaCly_Fish（5星）**
    - **关键亮点**：思路清晰，步骤详细，对问题的转化过程解释透彻，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
struct node{ 
    int l,r;
    node(int l=0,int r=0):l(l),r(r){}
    bool operator < (const node& nd) const{
        if(r!=nd.r) return r < nd.r;
        return l < nd.l;
    }
};

int n;
node a[N];

int main(){
    int l,r,n,x,w,ans = 0;
    read(n);
    for(int i=1;i<=n;++i){
        read(x),read(w);
        a[i] = node(x-w,x+w);
    }
    sort(a+1,a+1+n);
    r = -inf;
    for(int i=1;i<=n;++i){
        if(a[i].l<r) continue; 
        ++ans;
        r = a[i].r;
    }
    printf("%d",ans);
    return 0;
}
```
核心实现思想：定义结构体 `node` 存储线段的左右端点，并重载小于运算符用于排序。读取输入后，将每个点转化为线段，按右端点从小到大排序。遍历线段，若当前线段的左端点大于等于当前右端点，则选择该线段并更新右端点，最后输出选择的线段数量。

- **作者：HDWR（4星）**
    - **关键亮点**：对式子的推导过程详细，结合图形解释，易于理解，代码简洁明了。
    - **核心代码**：
```cpp
struct Line {
    int left, right;
};

bool stlCmp(Line x, Line y) {
    return x.right < y.right;
}

signed main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        int x = 0, w = 0;
        cin >> x >> w;
        line[i].left = x - w;
        line[i].right = x + w;
    }
    sort(line + 1, line + 1 + n, stlCmp);
    int lastRight = INT_MIN, lines = 0;
    for (int i = 1; i <= n; ++i) {
        if (lastRight <= line[i].left) ++lines, lastRight = line[i].right;
    }
    cout << lines << endl;
    return 0;
}
```
核心实现思想：定义结构体 `Line` 存储线段的左右端点，编写比较函数 `stlCmp` 按右端点排序。读取输入后，将每个点转化为线段并排序。遍历线段，若当前线段的左端点大于等于上一个选择线段的右端点，则选择该线段并更新右端点，最后输出选择的线段数量。

### 最优关键思路或技巧
- **思维方式**：通过对条件进行化简和转化，将复杂的图论问题转化为经典的线段覆盖问题，降低问题的难度。
- **算法优化**：采用贪心算法解决线段覆盖问题，时间复杂度为 $O(n \log n)$，主要是排序的时间开销。

### 拓展思路
同类型题或类似算法套路：
- 区间调度问题：给定一组区间，要求选择最多的不重叠区间。
- 活动选择问题：有多个活动，每个活动有开始时间和结束时间，要求选择最多的不冲突活动。

### 洛谷相似题目推荐
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
- [P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)
- [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)

### 个人心得摘录与总结
- **作者：DreamShadow**：被第14个点坑死，和别人互怼后解决问题，感慨题目实际难度与评级不符。总结：做题时可能会遇到各种意外情况，要保持耐心，多和他人交流。
- **作者：t162**：一开始代码WA，分析原因后发现判断条件有误，应和已选最右边线段的右端点比较。总结：编写代码时要仔细考虑边界条件和特殊情况，遇到错误要认真分析原因。 

---
处理用时：34.05秒
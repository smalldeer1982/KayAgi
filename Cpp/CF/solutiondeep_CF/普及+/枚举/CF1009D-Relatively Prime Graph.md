# 题目信息

# Relatively Prime Graph

## 题目描述

我们将一个无向图称作互质图，当且仅当对于其中每一条边$(v, u)$有$v$和$u$互质（也即$GCD(v,u)=1$）。当两个顶点之间没有边时不需要考虑。顶点从1开始标号。

现在给你$n$个顶点和$m$条边，要求你建立一个无重边和自环并且连通的互质图，如果无法构造输出"Impossible"，对于多种可能的答案输出任意一种即可。

## 样例 #1

### 输入

```
5 6
```

### 输出

```
Possible
2 5
3 2
5 1
3 4
4 1
5 4
```

## 样例 #2

### 输入

```
6 12
```

### 输出

```
Impossible
```

# AI分析结果

### 题目内容
# 互质图

## 题目描述
我们将一个无向图称作互质图，当且仅当对于其中每一条边$(v, u)$有$v$和$u$互质（也即$GCD(v,u)=1$）。当两个顶点之间没有边时不需要考虑。顶点从1开始标号。

现在给你$n$个顶点和$m$条边，要求你建立一个无重边和自环并且连通的互质图，如果无法构造输出"Impossible"，对于多种可能的答案输出任意一种即可。

## 样例 #1
### 输入
```
5 6
```
### 输出
```
Possible
2 5
3 2
5 1
3 4
4 1
5 4
```

## 样例 #2
### 输入
```
6 12
```
### 输出
```
Impossible
```

### 综合分析与结论
所有题解思路基本一致，均先判断 $m < n - 1$ 时无解。然后暴力枚举所有顶点对 $(i, j)$（$i < j$），判断 $\gcd(i, j) = 1$ 时将该边加入图中，当加入边数达到 $m$ 时停止枚举。若枚举完所有顶点对后仍未达到 $m$ 条边则输出 “Impossible”。

各题解在优化上略有不同，部分题解提到实际 $n$ 范围较小，暴力枚举时 $n^2$ 跑不满，实际时间复杂度为 $O(\min(n^2, m))$。有的题解还提到可以先尝试构造以1为中心的菊花图来保证连通性。

### 所选的题解
- **作者：_6_awa（5星）**
    - **关键亮点**：思路清晰，不仅给出暴力解法，还对时间复杂度进行了详细分析，通过对 $m$ 与 $n$ 关系的讨论，说明暴力枚举在本题中的可行性，代码简洁明了。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[250001],b[250001],sum;
signed main()
{
    cin >> n >> m;
    if(m > n * n || m < n - 1){// 粗略排除不可能的情况
        cout << "Impossible";
        return 0;
    }
    for(int i = 1;i <= n;i ++)
        for(int j = i + 1;j <= n;j ++)
        {
            if(__gcd(i,j) == 1)a[++sum] = i,b[sum] = j;
            if(sum >= m)break ;// 及时跳出
        }
    if(sum < m){// 边数不足，排除
        cout << "Impossible";
        return 0;
    }
    cout << "Possible\n";
    for(int i = 1;i <= m;i ++)cout << a[i] << " " << b[i] << endl;
}
```
核心实现思想：先判断输入的 $m$ 和 $n$ 是否满足基本条件，然后双重循环枚举所有顶点对，判断互质后记录边，达到 $m$ 条边时停止枚举，最后根据边数输出结果。

- **作者：fish_love_cat（4星）**
    - **关键亮点**：提出先构造以1为中心的菊花图保证连通性这一思路，同时提到暴力枚举时的优化点，即枚举合法边数超过 $m$ 提前退出，代码简洁易懂。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int u[100005],v[100005],top;
int main(){
    int n,m;
    cin>>n>>m;
    if(m<n-1){
        puts("Impossible");
        return 0;
    }
    for(int i=1;i<=n&&top<=m;i++)
    for(int j=i+1;j<=n&&top<=m;j++)
    if(__gcd(i,j)==1)u[++top]=i,v[top]=j;
    if(top<m){
        puts("Impossible");
        return 0;
    }
    puts("Possible");
    for(int i=1;i<=m;i++)cout<<u[i]<<' '<<v[i]<<endl;
    return 0;
}
```
核心实现思想：先判断边数是否满足最小连通要求，然后双重循环枚举顶点对，判断互质且边数未超 $m$ 时记录边，最后根据边数输出结果。

### 最优关键思路或技巧
1. **暴力枚举优化**：通过及时跳出循环，将原本 $O(n^2)$ 的时间复杂度优化为 $O(\min(n^2, m))$。
2. **利用特殊数字性质**：利用1和所有数互质的性质，可尝试先构造以1为中心的菊花图保证连通性，简化问题。

### 可拓展之处
同类型题可考察不同的图性质构建，或在边的限制条件上做变化，例如要求边权满足某种数论关系等。类似算法套路是在暴力枚举时，善于利用数据范围和问题特性进行优化，避免不必要的计算。

### 洛谷相似题目推荐
1. **P1029 最大公约数和最小公倍数问题**：通过枚举和数论知识解决关于最大公约数和最小公倍数的问题，与本题涉及的数论知识相关。
2. **P1572 计算分数**：需要运用数论中的约分等知识处理分数运算，锻炼数论相关编程能力。
3. **P2613 【模板】有理数取余**：涉及有理数取余的数论问题，可加深对取余运算和数论结合的理解。 

---
处理用时：28.95秒
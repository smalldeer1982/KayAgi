# 题目信息

# Knights

## 题目描述

伯兰国不得不又一次面对黑♂暗势力的降临。邪恶领主~~Van♂De♂Mart~~范·德·马特正在计划征服整个王国。王国成立了由伯兰国王瓦莱丽领导的理事会。理事会由$n$个骑士组成。经过一番激烈的讨论，他们把整个国家分成了$n$个战略目标点，（如果黑暗势力控制了至少一个战略目标点，战争就失败了）

伯兰国可以被认为是由$m+1$个区域和$m$个栅栏组成的。同时，从一个区域到达另一个区域的唯一方法就是翻过栅栏。每个栅栏都是同一个平面上的圆，并且任意两个栅栏之间都没有交叉点，同时保证所有战略目标点都`不在`栅栏上。我们会给你$k$对整数$ai, bi$，对于每对整数，你都要解决：如果一个骑士想从战略控制点$ai$赶到$bi$，（为了防止范·德·马特突袭控制点bi），而每个骑士都骑着一匹马（把马从栅栏上扔过去太难了），那么，他最少爬过多少栅栏？

## 样例 #1

### 输入

```
2 1 1
0 0
3 3
2 0 0
1 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 3 1
0 0
4 4
1 0 0
2 0 0
3 0 0
1 2
```

### 输出

```
3
```

# AI分析结果

### 题目内容
# Knights

## 题目描述
伯兰国不得不又一次面对黑暗势力的降临。邪恶领主范·德·马特正在计划征服整个王国。王国成立了由伯兰国王瓦莱丽领导的理事会。理事会由$n$个骑士组成。经过一番激烈的讨论，他们把整个国家分成了$n$个战略目标点（如果黑暗势力控制了至少一个战略目标点，战争就失败了）。

伯兰国可以被认为是由$m + 1$个区域和$m$个栅栏组成的。同时，从一个区域到达另一个区域的唯一方法就是翻过栅栏。每个栅栏都是同一个平面上的圆，并且任意两个栅栏之间都没有交叉点，同时保证所有战略目标点都`不在`栅栏上。我们会给你$k$对整数$a_i, b_i$，对于每对整数，你都要解决：如果一个骑士想从战略控制点$a_i$赶到$b_i$（为了防止范·德·马特突袭控制点$b_i$），而每个骑士都骑着一匹马（把马从栅栏上扔过去太难了），那么，他最少爬过多少栅栏？

## 样例 #1
### 输入
```
2 1 1
0 0
3 3
2 0 0
1 2
```
### 输出
```
1
```

## 样例 #2
### 输入
```
2 3 1
0 0
4 4
1 0 0
2 0 0
3 0 0
1 2
```
### 输出
```
3
```

### 综合分析与结论
这些题解主要有两种思路：
1. **暴力枚举**：直接暴力枚举每个圆，判断起点和终点相对于该圆的位置。若一个在圆内一个在圆外，则路径要穿过此圆，答案加1。此方法实现简单，时间复杂度为$O(mk)$。
2. **构建树 + LCA**：利用圆的包含关系构建一棵树，将最外层圆连接到虚根。计算每个点所属的圆，通过LCA和树的深度求两点所属圆在树上的最短距离。实现相对复杂，但理解后逻辑清晰。

各题解的算法要点和难点解决如下：
1. **FatOldEight**：先按半径排序圆，通过搜索确定圆间包含关系并连边构成森林，找到最外层圆连到虚根，再确定点所属圆，最后用LCA求距离。解决了如何判断圆的最小包含关系、寻找最外层圆以及确定点所属圆的问题。
2. **MiRaciss**：同样利用圆的包含关系构建树，使用Tarjan算法求LCA，在构建树和确定点所属圆的处理上与其他LCA解法有相似思路。
3. **白鲟**：法1是暴力枚举圆，判断点与圆的位置关系统计答案，注意避免精度损失；法2提出构建区域连边的森林用LCA求解，但未给出代码。
4. **这有一只匿**：建立虚根把战略目标点组成的森林转化为有根树，用LCA求树上两点最短距离，在确定点所属圆和构建树的边时采用与其他LCA解法类似操作。
5. **XL4453**：直接暴力枚举，根据点到圆心距离与半径关系判断点是否在圆内，通过异或操作统计需穿过的圆的数量。
6. **ты**：通过搜索统计两个位置被不同栅栏包围的数量，利用记忆化优化判断点是否在圆内的操作。
7. **Erica_N_Contina**：分析了点与圆的位置关系，提出LCA和暴力两种做法。暴力做法通过记忆化记录点与圆关系，枚举圆判断点是否在圆内统计答案。
8. **Civilight_Eterna**：纯暴力做法，枚举每个圆判断两点与圆的位置关系，若一个在圆内一个在圆外则答案加1。
9. **wujingfey**：根据起点和终点与圆的位置关系判断圆是否对答案有贡献，暴力枚举圆并用距离平方比较判断点与圆的位置关系。

### 所选的题解
#### FatOldEight（5星）
- **关键亮点**：思路清晰，详细阐述了构建树过程中确定圆间关系、寻找最外层圆、确定点所属圆的具体方法及代码实现，对LCA的应用讲解透彻。
- **个人心得**：无
```cpp
void df(int q)
{
    if(v[q])return;
    v[q]=1;
    for(int i=1;i<=m;i++)
    {
        if(check(q,i)&&i!=q)
        {
            adde(q,i);
            adde(i,q);
            df(i);
            return;
        }
    }
}
for(int i=1;i<=m;i++)
{
    bool p=1;
    for(int j=i+1;j<=m;j++)
    {
        if(check(i,j))p=0;
    }
    if(p)adde(i,0),adde(0,i);
}
for(int i=1;i<=m;i++)
{
    for(int j=1;j<=n;j++)
    {
        if(!z[j]&&(long long)((long long)(O[i].x-mp[j][1])*(O[i].x-mp[j][1])+(long long)(O[i].y-mp[j][2])*(O[i].y-mp[j][2]))<=(long long)O[i].r*O[i].r)z[j]=i;
    }
}
for(int i=1;i<=n;i++)if(!z[i])z[i]=0;
```
核心实现思想：`df`函数通过搜索确定圆的包含关系并连边；第二个循环找到最外层圆并与虚根连边；第三个循环确定点所属的圆，最后处理没有圆包含的点与虚根相连。

#### MiRaciss（5星）
- **关键亮点**：提供了基于Tarjan算法求LCA的实现，代码简洁明了，在处理圆的包含关系和点所属圆的逻辑上与其他LCA解法相互呼应，有独特的并查集使用方式。
- **个人心得**：无
```cpp
void Make_Set()
{
    for(int i=1;i<=m;i++)
    {
        pre[i]=i;
    }
}
int Find_Set(int x)
{
    if(pre[x]!=x)
        pre[x]=Find_Set(pre[x]);
    return pre[x];
}
void DFS(int p,int fa)
{
    dist[p]=dist[fa]+1;
    for(int i=0;i<v[p].size();i++)
    {
        int x=v[p][i];
        if(x!=fa)
            DFS(x,p);
    }
}
void Tarjan(int x)
{
    f[x]=1;
    for(int i=0;i<v[x].size();i++)
    {
        int y=v[x][i];
        if(f[y])
            continue;
        Tarjan(y);
        pre[y]=Find_Set(x);
    }
    for(int i=0;i<sum[x].size();i++)
    {
        zz now=sum[x][i];
        if(!f[now.u])
            continue;
        tot[now.id]=Find_Set(now.u);
    }
}
```
核心实现思想：`Make_Set`和`Find_Set`初始化并查集用于处理圆的关系；`DFS`函数用于计算树中节点深度；`Tarjan`函数利用Tarjan算法求LCA，通过并查集确定节点间关系。

#### 白鲟（4星）
- **关键亮点**：提出两种思路，暴力法思路清晰且代码注释详细，对暴力枚举过程中的细节如避免精度损失、记忆化等处理得当，法2提供了另一种基于LCA的思路方向。
- **个人心得**：无
```cpp
long long distance_2(const point &t1,const point &t2)
{
    return (long long)(t1.x-t2.x)*(long long)(t1.x-t2.x)+(long long)(t1.y-t2.y)*(long long)(t1.y-t2.y);
}
bool in(int t_point,int t_circle)
{
    if(!relationship[t_point][t_circle])
        relationship[t_point][t_circle]=(distance_2(target[t_point],circle[t_circle])<(long long)(r[t_circle])*(long long)(r[t_circle]))+1;
    return relationship[t_point][t_circle]-1;
}
int answer(int x,int y)
{
    int result=total[x][y];
    if(!result)
        for(int i=1;i<=m;++i)
            if(in(x,i)&&!in(y,i)||in(y,i)&&!in(x,i))
                ++result;
    return result;
}
```
核心实现思想：`distance_2`函数计算两点距离平方；`in`函数利用记忆化判断点是否在圆内；`answer`函数通过枚举圆统计只包含起点或终点其中一个点的圆的数量。

### 最优关键思路或技巧
1. **LCA解法**：利用圆之间的包含关系构建树结构，将问题转化为求树上两点间的最短距离，通过LCA算法高效解决。在构建树时，按半径排序圆有助于确定圆的包含关系，如先排序再搜索确定最小包含圆。
2. **避免精度损失**：在判断点与圆的位置关系时，通过比较距离的平方而不是距离本身，避免了开平方带来的精度损失。
3. **记忆化优化**：在暴力枚举判断点与圆的位置关系时，使用二维数组记忆化，避免重复计算，提高效率。

### 可拓展之处
同类型题或类似算法套路：此类题目通常涉及平面上图形的位置关系，可拓展到其他几何图形如矩形、多边形等的包含、相交关系问题，同样可以构建图或树结构，利用图论算法解决。类似算法套路还包括利用几何图形的位置关系建立数据结构，通过特定算法（如LCA、BFS、DFS等）解决路径、距离等问题。

### 推荐洛谷题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)：基础的LCA模板题，帮助巩固LCA算法的理解和实现。
2. [P1852 跳跳棋](https://www.luogu.com.cn/problem/P1852)：需要通过分析问题构建类似树的结构，利用LCA思想求解。
3. [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)：虽然表面上与几何关系不大，但在处理过程中同样需要构建合适的数据结构并运用相关算法优化求解，与本题构建树结构解决问题的思路类似。 

---
处理用时：47.94秒
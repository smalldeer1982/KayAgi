# 题目信息

# Kefa and Dishes

## 题目描述

$\texttt{songshe}$ 进入了一家餐厅，这家餐厅中有 $n\ (1\leqslant n\leqslant18)$ 个菜。$\texttt{songshe}$ 对第 $i$ 个菜的满意度为 $a_i\ (0\leqslant a_i\leqslant10^9)$。

对于这 $n$ 个菜，有 $k\ (0\leqslant k\leqslant n^2-n)$ 条规则：如果 $\texttt{songshe}$ 在吃完第 $x_i$ 个菜之后立刻吃了第 $y_i\ (x_i\neq y_i)$ 个菜，那么会额外获得 $c_i\ (0\leqslant c_i\leqslant10^9)$ 的满意度。

$\texttt{songshe}$ 要吃 $m\ (1\leqslant m\leqslant n)$ 道任意的菜，但是他希望自己吃菜的顺序得到的满意度最大，请你帮 $\texttt{songshe}$ 解决这个问题。

## 样例 #1

### 输入

```
2 2 1
1 1
2 1 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4 3 2
1 2 3 4
2 1 5
3 4 2
```

### 输出

```
12
```

# AI分析结果

### 题目重写
# Kefa和菜肴

## 题目描述
songshe进入了一家餐厅，这家餐厅中有 $n\ (1\leqslant n\leqslant18)$ 个菜。songshe对第 $i$ 个菜的满意度为 $a_i\ (0\leqslant a_i\leqslant10^9)$ 。

对于这 $n$ 个菜，有 $k\ (0\leqslant k\leqslant n^2 - n)$ 条规则：如果songshe在吃完第 $x_i$ 个菜之后立刻吃了第 $y_i\ (x_i\neq y_i)$ 个菜，那么会额外获得 $c_i\ (0\leqslant c_i\leqslant10^9)$ 的满意度。

songshe要吃 $m\ (1\leqslant m\leqslant n)$ 道任意的菜，但是他希望自己吃菜的顺序得到的满意度最大，请你帮songshe解决这个问题。

## 样例 #1
### 输入
```
2 2 1
1 1
2 1 1
```
### 输出
```
3
```
## 样例 #2
### 输入
```
4 3 2
1 2 3 4
2 1 5
3 4 2
```
### 输出
```
12
```

### 题解综合分析与结论
所有题解均采用状态压缩动态规划（状压DP）解决该问题。由于 $n$ 较小（$n\leqslant18$），使用状压DP可以有效降低时间复杂度。
 - **思路**：通过二进制数表示吃菜的状态，每一位对应一道菜，1表示吃了，0表示没吃。状态转移时，考虑当前状态下最后吃的菜，以利用吃菜顺序带来的额外满意度。
 - **算法要点**：定义二维数组 `f`，第一维表示吃菜的状态，第二维表示当前最后吃的菜。初始化时，对于只吃一道菜的状态，满意度为该菜本身的满意度。转移时，枚举当前状态、当前要吃的菜以及已经吃过的菜，更新最大满意度。
 - **解决难点**：核心在于设计合适的状态表示和状态转移方程。要充分考虑吃菜顺序对满意度的影响，在状态转移时正确累加额外满意度。同时，需要注意边界条件和细节处理，如状态的合法性判断、最终答案的统计等。

### 所选的题解
#### Moon_Goddy - 5星
 - **关键亮点**：思路阐述清晰，详细说明了状态设计的原因，代码注释详尽，对状压DP的实现过程解释到位。
 - **个人心得**：作者分享独立写出状压DP的思路，对初学者有启发作用。
 - **核心代码**：
```cpp
// 状态转移部分
for(int i=1;i<(1<<n);i++){//枚举所有状态
    int tmp=calc(i);
    if(tmp>m)continue;//吃多了
    if(tmp==m){
        for(int j=1;j<=n;j++)
            if((i>>(j-1))&1)//在吃过的菜中选最后吃的
                ans=max(ans,f[i][j]);
        continue;
    }
    for(int j=1;j<=n;j++){//枚举要吃的菜
        if((i>>(j-1))&1)continue;//已经吃过
        
        for(int u=1;u<=n;u++){//枚举已经吃过的菜
            if((i>>(u-1))&1)
                f[i|(1<<(j-1))][j]=max(f[i|(1<<(j-1))][j],f[i][u]+a[j]+ex[u][j]);//吃了之后当前最后吃的就是j
        }
        
    }
}
```
#### xixike - 5星
 - **关键亮点**：提供了更好的阅读体验链接，状态转移方程书写清晰，对转移方程的解释详细，代码简洁明了，变量命名规范。
 - **核心代码**：
```cpp
// 状态转移部分
for(int s = 0; s < (1 << n); ++s)
    for(int i = 1; i <= n; ++i)
        if(s & (1 << (i - 1)))
            for(int j = 1; j <= n; ++j)
                if(i!= j && (s & (1 << (j - 1))))
                    dp[i][s] = max(dp[i][s], dp[j][s ^ (1 << (i - 1))] + a[i] + g[j][i]);
// 统计答案部分
ll ans = 0;
for(int s = 0; s < (1 << n); ++s)
    if(__builtin_popcount(s) == m)
        for(int i = 1; i <= n; ++i)
            if(s & (1 << (i - 1)))
                ans = max(ans, dp[i][s]);
```
#### 设计涉及社稷 - 4星
 - **关键亮点**：将本题与最短哈密顿路径模型联系起来，帮助理解状压DP的应用场景，状态定义、转移方程、初始化和终态处理讲解详细。
 - **个人心得**：作者分享对做题和学习模型的理解，强调将新问题归约成已知模型的能力。
 - **核心代码**：
```cpp
// 状态转移部分
for(int i=0;i<1<<n;++i)
    rep(j,1,n)
        if(i>>(j-1)&1)
            rep(k,1,n)
                if((i^(1<<(j-1)))>>(k-1)&1)
                    f[i][j]=max(f[i][j],f[i^(1<<(j-1))][k]+a[j]+w[k][j]);
// 统计答案部分
int ans = 0;
for(int i=0;i<1<<n;++i){
    if(get_num(i)==m)
        rep(j,1,n)
            ans=max(ans,f[i][j]);
}
```

### 最优关键思路或技巧
 - **状态压缩**：利用二进制数紧凑地表示吃菜的状态，大大减少状态表示的空间，同时方便进行状态转移操作。
 - **记录最后吃的菜**：在状态设计中，额外记录当前状态下最后吃的菜，使得在状态转移时能够方便地计算因吃菜顺序产生的额外满意度。

### 同类型题或类似算法套路拓展
此类问题通常具有状态数较多但可通过某种方式压缩表示的特点。类似算法套路包括使用状压DP解决旅行商问题、集合覆盖问题等。在这些问题中，通常需要根据具体条件设计合适的状态和转移方程，以解决具有组合性质的优化问题。

### 洛谷相似题目推荐
 - [P1879 [USACO06NOV]玉米田Corn Fields](https://www.luogu.com.cn/problem/P1879)
 - [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
 - [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)

### 个人心得摘录与总结
 - **Moon_Goddy**：第一次独立写出状压DP，分享思路，对初学者有启发。
 - **设计涉及社稷**：强调做题是将新问题归约成已知模型，学习时要注重见模型，学习后要注重应用模型的能力。这些心得提醒学习者在学习算法时，不仅要掌握单个算法的实现，更要理解算法背后的思想和应用场景，培养将实际问题转化为已有模型的能力。 

---
处理用时：32.48秒
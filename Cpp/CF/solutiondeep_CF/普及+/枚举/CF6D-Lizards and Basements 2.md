# 题目信息

# Lizards and Basements 2

## 题目描述

有一队人，第 $i$ 个人的血量为 $h_{i}$，你可以用火球点某个人，会对当前的人造成 $a$ 点伤害，对旁边的人造成 $b$ 点伤害。

火球不能打 $1$ 号和 $n$ 号，求最少多少发火球烧死所有人。血量为负数才算死。

## 样例 #1

### 输入

```
3 2 1
2 2 2
```

### 输出

```
3
2 2 2 ```

## 样例 #2

### 输入

```
4 3 1
1 4 1 1
```

### 输出

```
4
2 2 3 3 ```

# AI分析结果

### 题目内容
# Lizards and Basements 2

## 题目描述
有一队人，第 $i$ 个人的血量为 $h_{i}$ ，你可以用火球攻击某个人，会对当前的人造成 $a$ 点伤害，对旁边的人造成 $b$ 点伤害。
火球不能攻击 $1$ 号和 $n$ 号，求最少需要多少发火球能烧死所有人。血量为负数才算死。

## 样例 #1
### 输入
```
3 2 1
2 2 2
```
### 输出
```
3
2 2 2 
```

## 样例 #2
### 输入
```
4 3 1
1 4 1 1
```
### 输出
```
4
2 2 3 3 
```

### 综合分析与结论
这些题解主要分为动态规划（DP）和深度优先搜索（DFS）两类思路。
- **DP思路要点**：定义三维状态 $dp[i][j][k]$ （或 $f[i][j][k]$ ），表示 $1$ 到 $i - 1$ 人已死，第 $i - 1$ 个人被放 $j$ 个火球，第 $i$ 个人被放 $k$ 个火球时，$i$ 到 $n$ 的最小花费（或最小火球数）。通过枚举第 $i + 1$ 个人放火球的数量 $l$ 进行状态转移，转移时需满足一定的伤害条件使第 $i$ 个人死亡 。其中kczno1的题解通过记录后缀 $min$ 将暴力转移的 $O(n*u^3)$ 复杂度优化到 $O(n*u^2)$ ，这里 $u$ 为血量最大值。
- **DFS思路要点**：通过枚举对每个可攻击的人（$2$ 到 $n - 1$ 号）释放火球的次数进行搜索。在搜索过程中，为了避免超时进行了多种剪枝操作，例如当当前使用的火球数已大于当前最优解时直接返回；在枚举对某个人释放火球次数时，通过计算能打死周围人的最大次数来限制枚举范围等。

解决难点在于如何准确地定义状态（DP）或如何有效地进行剪枝（DFS），以优化算法复杂度，避免超时。

### 所选的题解
- **作者：kczno1 (5星)**
    - **关键亮点**：使用动态规划，状态定义清晰，通过记录后缀 $min$ 优化转移复杂度，从暴力的 $O(n*u^3)$ 优化到 $O(n*u^2)$ ，代码实现简洁明了，注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
const int N=10+2,U=15+2;
int dp[N][U][U],mn[N][U][U],need[U];
int n,a,b,h[N];

int main()
{
    cin>>n>>a>>b;
    rep(i,1,n)h[i]=read();
    memset(dp,(1<<6)-1,sizeof(dp));
    rep(i,0,U-1)
    if(i*b>h[n])dp[n][i][0]=0;
    rep(i,0,U-1)need[i]=i/b+1;
    per(i,n,1)
    {
        if(i<n)
        {
            rep(j,0,U-1)
            {
                int v=h[i]-j*b;
                rep(k,0,U-1)
                {
                    dp[i][j][k]=k+mn[i+1][k][v<0?0:need[v]];
                    v-=a;
                }
            }
        }
        rep(j,0,U-1)
        {
            mn[i][j][U-1]=dp[i][j][U-1];
            per(k,U-2,0)mn[i][j][k]=min(mn[i][j][k+1],dp[i][j][k]);
        }
    }
    int i=1,j=0,k=0;
    printf("%d\n",dp[i][j][k]);
    while(++i<n)
    {
        int v=h[i-1]-j*b-k*a;
        int l=v<0?0:need[v];
        while(dp[i][k][l]!=dp[i-1][j][k]-k)++l;
        j=k;k=l;
        rep(o,1,l)printf("%d ",i);
    }
}
```
核心实现思想：首先初始化 $dp$ 数组，然后从后往前遍历每个人，对于每个状态 $(i, j, k)$ ，通过后缀 $min$ 数组 $mn$ 快速找到满足条件的最小花费，最后通过回溯输出方案。
- **作者：小闸蟹 (4星)**
    - **关键亮点**：采用深度优先搜索，思路直接，代码结构清晰，通过剪枝操作减少不必要的搜索，在数据量不大的情况下能有效解决问题。
    - **个人心得**：无
    - **核心代码**：
```cpp
int n, a, b;
std::array<int, 100> h{ 0 };
std::vector<int> Vec, Temp;
int Ans = INT_MAX;

void DFS(int Now, int Sum)
{
    if (Sum >= Ans) 
    {
        return;
    }
    if (Now == n - 1)   
    {
        if (h[n - 1] < 0)   
        {
            Ans = Sum;
            Vec = Temp;
        }
        return;
    }
    for (int i = 0;
        i <= std::max({ (h[Now - 1] / b), (h[Now] / a), (h[Now + 1] / b) }) + 1;
        ++i)
    {
        if (h[Now - 1] - b * i < 0) 
        {
            h[Now - 1] -= b * i;    
            h[Now] -= a * i;        
            h[Now + 1] -= b * i;
            for (int t = 0; t < i; ++t)
            {
                Temp.push_back(Now + 1);
            }
            DFS(Now + 1, Sum + i);  
            h[Now - 1] += b * i;    
            h[Now] += a * i;
            h[Now + 1] += b * i;
            for (int t = 0; t < i; ++t)
            {
                Temp.pop_back();
            }
        }
    }
    return;
}
```
核心实现思想：以当前考虑的人的编号 $Now$ 和已使用的火球总数 $Sum$ 为参数进行递归搜索，在搜索过程中，通过剪枝避免无效搜索，当到达倒数第二个人且所有人都死亡时更新答案。
- **作者：Fading (4星)**
    - **关键亮点**：同样使用动态规划，详细阐述了状态定义的思考过程，在转移方程和边界处理上有清晰的逻辑，通过记录转移位置来输出方案。
    - **个人心得**：尝试多种状态定义后才得到合适的，过程中发现有些状态定义在转移时会遇到困难，如第 $i$ 个弓箭手未死但被第 $i + 1$ 个人攻击时顺带打死的情况不好处理。
    - **核心代码**：
```cpp
ll f[22][201][201],g[22][201][201][2];
ll x[22],mx[22];
int main(){
    n=read(),a=read(),b=read();
    for (int i=1;i<=n;i++) x[i]=read(),mx[i]=(x[i]/a)+1;
    ll mini=x[1]/b+1;
    memset(f,0x3f,sizeof(f));
    for (int j=mini;j<=20;j++){
        f[2][0][j]=j;
    }
    for (int i=2;i<=n-1;i++){
        for (int j=0;j<=(i==2?0:16);j++){
            for (int k=0;k<=16;k++){
                if (f[i][j][k]>=0x3f3f3f3f-200) continue;
                ll rem=(x[i]-j*b-k*a)>=0?(x[i]-j*b-k*a)/b+1:0;
                for (int l=max(0LL,rem);l<=16;l++){
                    if (l+f[i][j][k]<f[i+1][k][l]){
                        f[i+1][k][l]=l+f[i][j][k];
                        g[i+1][k][l][0]=j,g[i+1][k][l][1]=k;
                    }
                }
            }
        }
    }
    ll id0=0,id1=0,idrem=0,ans=0x3f3f3f3f;
    for (int j=0;j<=16;j++){
        for (int k=0;k<=16;k++){
            if (f[n-1][j][k]>=0x3f3f3f3f-200) continue;
            ll rem=(x[n-1]-j*b-k*a)>=0?(x[n-1]-j*b-k*a)/a+1:0;
            if (k*b<=x[n]) rem=((x[n]-b*k)/b+1);
            if (f[n-1][j][k]+rem<ans){
                id0=j,id1=k,ans=f[n-1][j][k]+rem;idrem=rem;
            }
        }
    }
    cout<<ans<<endl;
    while (idrem--) cout<<n-1<<" ";
    ll T=n-1;
    while (T!=1){
        ll idd0=id0,idd1=id1;
        id0=g[T][idd0][idd1][0];
        id1=g[T][idd0][idd1][1];
        while (idd1--) cout<<T<<" ";
        T--;
    }
    return 0;
}
```
核心实现思想：初始化状态 $f$ 数组，通过三重循环遍历不同状态，根据当前状态计算剩余血量从而确定下一个状态的最小花费，并记录转移位置 $g$ 数组，最后通过枚举倒数第二层的状态计算打死最后一个人的最小花费并输出方案。

### 最优关键思路或技巧
- **DP方面**：合理定义三维状态来准确描述问题，利用后缀 $min$ 优化状态转移的复杂度，减少重复计算。
- **DFS方面**：通过剪枝操作，如限制枚举次数范围、当前花费大于最优解时及时返回等，减少不必要的搜索分支，提高搜索效率。

### 可拓展之处
同类型题通常是在伤害范围、伤害值计算、人物排列结构等方面进行变化。类似算法套路就是无论是DP还是DFS，关键在于准确描述状态和有效优化。例如在DP中合理定义状态使转移方程简洁高效；在DFS中巧妙剪枝减少搜索量。

### 推荐题目
- **P1127 [ZJOI2007] 矩阵游戏**：涉及状态表示与转移，类似本题DP思路中状态定义与优化。
- **P1433 吃奶酪**：可使用DFS搜索，并通过剪枝优化，和本题DFS思路类似。
- **P1734 最大约数和**：可以尝试用DP解决，在状态定义和转移上有相似思考方向。

### 个人心得摘录与总结
Fading尝试多种状态定义解决本题，发现一些状态在转移时难以处理，最终找到合适的状态定义完成解题。这表明在解决DP问题时，状态定义至关重要，不合适的状态可能导致转移困难，需要不断尝试和调整。 

---
处理用时：53.67秒
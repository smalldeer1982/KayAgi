# 题目信息

# Chessboard

## 题目描述

Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into $ 4 $ pieces, each of size $ n $ by $ n $ , $ n $ is always odd. And what's even worse, some squares were of wrong color. $ j $ -th square of the $ i $ -th row of $ k $ -th piece of the board has color $ a_{k,i,j} $ ; $ 1 $ being black and $ 0 $ being white.

Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be $ 2n $ by $ 2n $ . You are allowed to move pieces but not allowed to rotate or flip them.

## 样例 #1

### 输入

```
1
0

0

1

0
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
101
010
101

101
000
101

010
101
011

010
101
010
```

### 输出

```
2
```

# AI分析结果

### 题目内容
# 棋盘

## 题目描述
马格努斯决定玩一场经典的国际象棋游戏。然而，他在储物柜里看到的景象令他震惊！他心爱的棋盘碎成了4块，每块大小为$n \times n$，$n$始终为奇数。更糟糕的是，有些方格的颜色不对。第$k$块棋盘的第$i$行第$j$个方格的颜色为$a_{k,i,j}$；1表示黑色，0表示白色。

现在马格努斯想改变一些方格的颜色，使得他改变颜色的方格数量最少，并且这些碎块能组成一个有效的棋盘。在一个有效的棋盘中，每个方格的颜色与其相邻（边相邻）方格的颜色不同。棋盘大小应为$2n \times 2n$。你可以移动这些碎块，但不允许旋转或翻转它们。

## 样例 #1
### 输入
```
1
0

0

1

0
```
### 输出
```
1
```

## 样例 #2
### 输入
```
3
101
010
101

101
000
101

010
101
011

010
101
010
```
### 输出
```
2
```

### 综合分析与结论
所有题解都基于$n$为奇数这一特性，意识到拼成大棋盘时，4块小棋盘必然是两种不同形态（左上角为0和左上角为1）各两块。主要思路是计算每个小棋盘变为两种形态分别所需的代价，再通过不同方式枚举组合以获取最小总代价。
1. **思路对比**：
    - **hgoicjl、daklqw、yuheng_wang080904第一种方法**：先分别计算每个小棋盘变为左上角为0和1的代价，再枚举所有可能的组合方式（共6种）来得到最小代价。
    - **yuheng_wang080904第二种方法**：通过`next_permutation`列出所有4块棋盘的排列方案，拼成棋盘后整体判断，用`ans`记录最小代价。
    - **hswfwkj_**：通过四层循环枚举所有能拼成的矩阵，对每个拼成矩阵分别生成左上角为0和1的标准棋盘并对比，取最小更改次数。
2. **算法要点**：
    - 利用$n$为奇数确定小棋盘组合方式。
    - 计算每个小棋盘变为特定形态的代价。
    - 枚举小棋盘组合方式求最小总代价。
3. **解决难点**：如何高效地计算每个小棋盘的变换代价以及如何全面且不重复地枚举所有可能的组合方式。

### 所选的题解
- **hgoicjl（4星）**
    - **关键亮点**：思路清晰，代码简洁明了，通过注释清晰地说明了代码实现的逻辑，对棋盘两种形态的分析直观易懂。
    - **核心代码**：
```cpp
int main()
{
    int a,b[5][2]={0};//b[i][0]表示变为棋盘①所需的代价
    char k;
    cin>>a;
    for(int j=1;j<=4;j++)
        for(int i=1;i<=a*a;i++)
        {
            cin>>k;
            if(k=='0'+i%2)
//因为a是奇数，满足棋盘①输入的是01010101.....,棋盘②同理
                b[j][0]++;
//不满足棋盘①，则b[j][0]++，若满足棋盘①则不满足棋盘②，则b[j][1]++
            else
                b[j][1]++;
        }
    cout<<min(b[1][0]+b[2][0]+b[3][1]+b[4][1],
        min(b[1][0]+b[3][0]+b[2][1]+b[4][1],
        min(b[1][0]+b[4][0]+b[3][1]+b[2][1],
        min(b[2][0]+b[3][0]+b[1][1]+b[4][1],
        min(b[2][0]+b[4][0]+b[1][1]+b[3][1],
        b[3][0]+b[4][0]+b[1][1]+b[2][1])))));//求所有组合的最小代价
    return 0;   
}
```
    - **核心思想**：遍历每个小棋盘的方格，根据方格位置与棋盘①形态的对应关系，统计变为棋盘①和棋盘②所需的代价，最后枚举6种组合方式取最小代价。
- **daklqw（4星）**
    - **关键亮点**：代码简洁高效，利用位运算计算每个小棋盘变为左上角为0或1的代价，时间复杂度控制在$O(n^2)$。
    - **核心代码**：
```cpp
int main(){
    scanf("%d",&n);
    for(int i=0;i<4;++i){
        for(int j=1;j<=n;++j){
            scanf("%s",buf);
            for(int k=1;k<=n;++k)
                f[0][i]+=((j&1)^(k&1))^(buf[k-1]=='0'),
                f[1][i]+=((j&1)^(k&1))^(buf[k-1]=='1');
        }
    }
    printf("%d\n",
        min(f[0][0]+f[0][1]+f[1][2]+f[1][3],
        min(f[0][0]+f[1][1]+f[0][2]+f[1][3],
        min(f[1][0]+f[0][1]+f[0][2]+f[1][3],
        min(f[0][0]+f[1][1]+f[1][2]+f[0][3],
        min(f[1][0]+f[0][1]+f[1][2]+f[0][3],
        min(f[1][0]+f[1][1]+f[0][2]+f[0][3],
            0x7fffffff)))))));
    return 0;
}
```
    - **核心思想**：通过位运算判断每个方格与左上角为0或1的棋盘形态的差异，统计每个小棋盘变为两种形态的代价，枚举6种组合方式取最小代价。
- **yuheng_wang080904（第一种方法，4星）**
    - **关键亮点**：思路阐述详细，代码逻辑清晰，通过简单的判断条件计算每个小棋盘变为特定形态的代价，易于理解。
    - **核心代码**：
```cpp
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int k=1;k<=4;k++){
        for(int i=0;i<n*n;i++){
            cin>>c[i];
            b[k][0]+=(c[i]-'0'==i%2);
            b[k][1]+=(c[i]-'0'==(i+1)%2);
        }
    }
    cout<<min(b[1][0]+b[2][0]+b[3][1]+b[4][1],min(b[1][0]+b[3][0]+b[2][1]+b[4][1],min(b[1][0]+b[4][0]+b[3][1]+b[2][1],min(b[2][0]+b[3][0]+b[1][1]+b[4][1],min(b[2][0]+b[4][0]+b[1][1]+b[3][1],b[3][0]+b[4][0]+b[1][1]+b[2][1])))))<<endl;
    return 0;
}
```
    - **核心思想**：遍历每个小棋盘的方格，根据方格位置与棋盘形态的对应关系，统计变为左上角为0和1的代价，枚举6种组合方式取最小代价。

### 最优关键思路或技巧
1. **利用棋盘特性**：抓住$n$为奇数这一关键条件，确定4块小棋盘的组合方式必然是两种形态各两块，大大简化问题。
2. **分块计算代价**：先分别计算每个小棋盘变为特定形态的代价，再进行组合枚举，避免了复杂的整体计算。
3. **高效枚举组合**：通过合理的枚举方式（如直接枚举6种组合或利用排列函数），全面且不重复地考虑所有可能的组合情况，从而得到最小代价。

### 可拓展之处
同类型题或类似算法套路：此类题目通常围绕图形的拼接、变换以及满足特定规则的最小代价问题。常见套路是先分析图形特性确定可能的组合方式，再分别计算每个子图形变换到特定状态的代价，最后通过枚举或其他优化方法找到最小总代价。

### 洛谷相似题目
1. **P1338 末日的传说**：涉及到排列组合与条件判断，与本题通过枚举不同组合来求解的思路类似。
2. **P1118 数字三角形**：同样需要分析不同情况，通过动态规划或枚举的方式找到最优解，与本题分析小棋盘不同组合的思路有相似之处。
3. **P1002 过河卒**：在棋盘模型下，通过递推或动态规划解决路径与限制条件相关问题，与本题基于棋盘的条件分析有一定关联。 

---
处理用时：34.44秒
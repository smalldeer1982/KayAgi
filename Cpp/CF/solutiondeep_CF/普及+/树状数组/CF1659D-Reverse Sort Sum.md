# 题目信息

# Reverse Sort Sum

## 题目描述

Suppose you had an array $ A $ of $ n $ elements, each of which is $ 0 $ or $ 1 $ .

Let us define a function $ f(k,A) $ which returns another array $ B $ , the result of sorting the first $ k $ elements of $ A $ in non-decreasing order. For example, $ f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0] $ . Note that the first $ 4 $ elements were sorted.

Now consider the arrays $ B_1, B_2,\ldots, B_n $ generated by $ f(1,A), f(2,A),\ldots,f(n,A) $ . Let $ C $ be the array obtained by taking the element-wise sum of $ B_1, B_2,\ldots, B_n $ .

For example, let $ A=[0,1,0,1] $ . Then we have $ B_1=[0,1,0,1] $ , $ B_2=[0,1,0,1] $ , $ B_3=[0,0,1,1] $ , $ B_4=[0,0,1,1] $ . Then $ C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4] $ .

You are given $ C $ . Determine a binary array $ A $ that would give $ C $ when processed as above. It is guaranteed that an array $ A $ exists for given $ C $ in the input.

## 说明/提示

Here's the explanation for the first test case. Given that $ A=[1,1,0,1] $ , we can construct each $ B_i $ :

- $ B_1=[\color{blue}{1},1,0,1] $ ;
- $ B_2=[\color{blue}{1},\color{blue}{1},0,1] $ ;
- $ B_3=[\color{blue}{0},\color{blue}{1},\color{blue}{1},1] $ ;
- $ B_4=[\color{blue}{0},\color{blue}{1},\color{blue}{1},\color{blue}{1}] $

 And then, we can sum up each column above to get $ C=[1+1+0+0,1+1+1+1,0+0+1+1,1+1+1+1]=[2,4,2,4] $ .

## 样例 #1

### 输入

```
5
4
2 4 2 4
7
0 3 4 2 3 2 7
3
0 0 0
4
0 0 0 4
3
1 2 3```

### 输出

```
1 1 0 1 
0 1 1 0 0 0 1 
0 0 0 
0 0 0 1 
1 0 1```

# AI分析结果

### 题目中文重写
#### Reverse Sort Sum

##### 题目描述
假设你有一个长度为 $n$ 的数组 $A$，数组中的每个元素要么是 $0$，要么是 $1$。

我们定义一个函数 $f(k, A)$，它返回另一个数组 $B$，这个数组是将数组 $A$ 的前 $k$ 个元素按非递减顺序排序后得到的结果。例如，$f(4, [0, 1, 1, 0, 0, 1, 0]) = [0, 0, 1, 1, 0, 1, 0]$。注意，这里只是对前 $4$ 个元素进行了排序。

现在考虑由 $f(1, A), f(2, A), \ldots, f(n, A)$ 生成的数组 $B_1, B_2, \ldots, B_n$。令 $C$ 是将数组 $B_1, B_2, \ldots, B_n$ 按元素相加得到的数组。

例如，设 $A = [0, 1, 0, 1]$。那么我们有 $B_1 = [0, 1, 0, 1]$，$B_2 = [0, 1, 0, 1]$，$B_3 = [0, 0, 1, 1]$，$B_4 = [0, 0, 1, 1]$。则 $C = B_1 + B_2 + B_3 + B_4 = [0, 1, 0, 1] + [0, 1, 0, 1] + [0, 0, 1, 1] + [0, 0, 1, 1] = [0, 2, 2, 4]$。

现在给定数组 $C$，要求你找出一个二进制数组 $A$，使得按照上述处理方式可以得到数组 $C$。题目保证对于输入的数组 $C$，存在这样的数组 $A$。

##### 说明/提示
这里是第一个测试用例的解释。已知 $A = [1, 1, 0, 1]$，我们可以构造出每个 $B_i$：
- $B_1 = [\color{blue}{1}, 1, 0, 1]$；
- $B_2 = [\color{blue}{1}, \color{blue}{1}, 0, 1]$；
- $B_3 = [\color{blue}{0}, \color{blue}{1}, \color{blue}{1}, 1]$；
- $B_4 = [\color{blue}{0}, \color{blue}{1}, \color{blue}{1}, \color{blue}{1}]$

然后，我们将每一列相加，得到 $C = [1 + 1 + 0 + 0, 1 + 1 + 1 + 1, 0 + 0 + 1 + 1, 1 + 1 + 1 + 1] = [2, 4, 2, 4]$。

##### 样例 #1
###### 输入
```
5
4
2 4 2 4
7
0 3 4 2 3 2 7
3
0 0 0
4
0 0 0 4
3
1 2 3
```
###### 输出
```
1 1 0 1 
0 1 1 0 0 0 1 
0 0 0 
0 0 0 1 
1 0 1
```

### 综合分析与结论
这些题解的核心思路大多围绕着根据数组 $C$ 的性质来反推数组 $A$。主要步骤通常包含先计算数组 $A$ 中 $1$ 的个数，再通过不同的方式从前往后或从后往前确定数组 $A$ 每个位置的值。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|LinkZelda|先算 $1$ 的个数，从右往左构造，用树状数组更新 $C$ 数组|计算 $1$ 的个数，树状数组区间更新|如何更新 $C$ 数组以转化为子问题|4星|
|Mine_King|按 $a_i$ 值分类讨论，根据 $c_i$ 推后续 $a$ 值|分类讨论，根据 $c_i$ 确定 $a$ 值|利用前面的 $a$ 值推导后面的 $a$ 值|4星|
|CYZZ|从左到右枚举，根据 $A_i$ 确定 $pos_i$ 进而确定 $A$ 值|从左到右枚举，确定 $pos_i$|确定 $A_i$ 未确定时的值|4星|
|耶梦加得|分析 $C$ 数组特点，根据 $C_i$ 确定 $A$ 中 $0$ 的位置|分析 $C$ 数组，确定 $0$ 的位置|确定 $A_i$ 的值|3星|
|落海沉|根据 $f_i$ 和 $s_i$ 确定 $ans$ 值|根据 $f_i$ 和 $s_i$ 确定 $ans$ 值|证明结论的正确性|3星|
|Frevotops|从 $B$ 数组最后一行研究，用线段树维护 $C$ 数组|计算 $1$ 的个数，线段树维护 $C$ 数组|去掉 $A_n$ 后更新 $C$ 数组|3星|
|cosf|从后往前推，用区间减更新 $C$ 数组|计算 $1$ 的个数，区间减更新 $C$ 数组|更新 $C$ 数组和 $1$ 的个数|3星|
|王熙文|计算 $1$ 的个数，从后往前确定 $A$ 值，用树状数组维护 $C$ 数组|计算 $1$ 的个数，树状数组维护 $C$ 数组|更新 $C$ 数组以确定 $A$ 值|3星|
|circletime|逆序确定 $a$ 值，用树状数组维护 $C$ 数组的区间修改|计算 $1$ 的个数，树状数组区间修改|根据 $B$ 数组更新 $C$ 数组|3星|

### 所选题解
- **LinkZelda（4星）**
    - **关键亮点**：思路清晰，利用树状数组高效处理区间更新，将问题转化为子问题求解。
    - **核心代码**：
```cpp
// 先算出 1 的个数
sum = 0;
for (int i = 1; i <= n; i++) {
    sum += c[i];
}
int one_cnt = sum / n;

// 从右往左构造
for (int i = n; i >= 1; i--) {
    if (c[i] == i) {
        a[i] = 1;
        one_cnt--;
    } else {
        a[i] = 0;
    }
    // 用树状数组更新 c 数组
    if (one_cnt > 0) {
        update(i - one_cnt + 1, i, -1);
    }
}
```
- **Mine_King（4星）**
    - **关键亮点**：通过分类讨论的方式，根据 $a_i$ 的值推导出后续 $a$ 的值，代码简洁易懂。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    a[i] = 1;
}
for (int i = 1; i <= n; i++) {
    int c;
    scanf("%d", &c);
    if (c == 0) a[i] = 0;
    if (a[i] == 0) a[i + c] = 0;
    else a[c + 1] = 0;
}
```
- **CYZZ（4星）**
    - **关键亮点**：从左到右枚举，通过确定 $pos_i$ 来确定 $A$ 的值，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
a[1] = C[1]? 1 : 0;
for (int i = 1; i <= n; i++) {
    if (a[i] == -1)
        a[i] = C[i]? 1 : 0;
    pos[i] = C[i] + 1 - (i - 1) * (a[i] - 1);
    for (int j = pos[i - 1] + 1; j < pos[i]; j++) {
        a[j] = 1;
    }
    a[pos[i]] = 0;
    if (pos[i] > n)
        break;
}
```

### 最优关键思路或技巧
- 计算数组 $A$ 中 $1$ 的个数：通过 $C$ 数组的总和除以 $n$ 得到，这是很多题解的基础步骤。
- 分类讨论：根据 $a_i$ 的值进行分类讨论，推导出后续 $a$ 的值，简化问题。
- 数据结构的运用：如树状数组、线段树等，用于高效处理区间更新，将问题转化为子问题求解。

### 拓展思路
同类型题可以考虑对数组进行其他操作，如排序、反转等，然后根据操作结果反推原数组。类似算法套路可以是先分析操作结果的性质，找到关键信息，再通过逐步推导或利用数据结构来确定原数组的值。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：考察树状数组的应用，与本题中树状数组处理区间更新有相似之处。
- [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)：直接考察树状数组的区间修改和单点查询，与本题中用树状数组维护 $C$ 数组类似。
- [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：需要对数组进行动态维护和查询，与本题中根据结果反推原数组的思路有一定相似性。

### 个人心得摘录与总结
- **CYZZ**：“和朋友玩随机题，40 min 才切，我好菜啊。”总结：做题时可能会遇到困难，花费较多时间，要对自己有信心，不断提升。
- **耶梦加得**：“手玩可以发现我们在去掉前导 0 之后，$A_i$ 在处理的时候必然是已知的。”总结：对于复杂问题，可以通过手动模拟小数据来发现规律，帮助解题。 

---
处理用时：53.74秒
# 题目信息

# Remove Extra One

## 题目描述

You are given a permutation $ p $ of length $ n $ . Remove one element from permutation to make the number of records the maximum possible.

We remind that in a sequence of numbers $ a_{1},a_{2},...,a_{k} $ the element $ a_{i} $ is a record if for every integer $ j $ ( $ 1<=j&lt;i $ ) the following holds: $ a_{j}&lt;a_{i} $ .

## 说明/提示

In the first example the only element can be removed.

## 样例 #1

### 输入

```
1
1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
5 1 2 3 4
```

### 输出

```
5
```

# AI分析结果

### 题目中文重写
# 移除多余的一个元素

## 题目描述
给定一个长度为 $n$ 的排列 $p$。从排列中移除一个元素，使得记录的数量尽可能多。

我们提醒一下，在一个数字序列 $a_{1},a_{2},\cdots,a_{k}$ 中，如果对于每个整数 $j$（$1\leq j < i$）都满足 $a_{j} < a_{i}$，那么元素 $a_{i}$ 就是一个记录。

## 说明/提示
在第一个样例中，只能移除唯一的元素。

## 样例 #1
### 输入
```
1
1
```
### 输出
```
1
```

## 样例 #2
### 输入
```
5
5 1 2 3 4
```
### 输出
```
5
```

### 综合分析与结论
这些题解的核心思路都是围绕分析删除每个元素对记录数量的影响来求解。不同题解在实现方式上有所差异：
- **树状数组解法**：使用两个树状数组分别维护小于某个数的数的个数和和，通过枚举元素结合结论求解，但复杂度为 $O(nlogn)$。
- **维护最大值和次大值解法**：从前往后枚举元素，同时维护当前的最大值和次大值，根据元素与最大值、次大值的大小关系进行分类讨论，复杂度为 $O(n)$。
- **数组记录解法**：用数组记录每个元素前面比它大的元素情况，再用桶统计删除每个元素后能增加的记录数。

### 所选题解
- **作者：LJ07（5星）**
    - **关键亮点**：思路清晰，详细分析了不同情况下元素对记录数的影响，并给出了两种解法，一种使用树状数组，另一种通过维护最大值和次大值进行分类讨论，复杂度更优。
    - **核心代码（解法二）**：
```cpp
// 从前往后枚举，顺便维护当前的最大值和次大值，然后进行分类讨论
for(int i = 1; i <= n; ++ i){
    if(a[i] > a[big]){
        -- v[i];
        small = big, big = i;
    }else if(a[i] > a[small]){
        ++ v[big];
        small = i;
    }
}
```
核心实现思想：在枚举过程中，若当前元素大于最大值，更新最大值和次大值，并记录删除该元素记录数减 1；若当前元素大于次大值，更新次大值，并记录删除最大值元素记录数加 1。

- **作者：Robin_kool（4星）**
    - **关键亮点**：详细模拟了删除每个元素产生的贡献情况，对原代码挂分原因进行了分析和修正，代码注释详细。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; ++ i){
    if(a[i] > a[big]){
        -- v[i];
        small = big, big = i;
    }else if(a[i] > a[small]){
        ++ v[big];
        small = i;
    }
}
for(int i = 1; i <= n; ++ i){
    if(v[i] > maxn){
        maxn = v[i];
        ans = i;
    }else if(v[i] == maxn){
        if(a[i] < a[ans]){
            maxn = v[i];
            ans = i;
        }
    }
}
```
核心实现思想：与 LJ07 解法二类似，先枚举元素更新记录数变化数组 `v`，再遍历 `v` 找出使记录数最大且元素值最小的元素。

- **作者：Raymondzll（4星）**
    - **关键亮点**：思路简洁明了，直接指出考虑每个数删掉后对答案的影响，代码实现简洁。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; ++ i){
    if(a[i] > a[y]){
        x = y; y = i;
        delta[i]--;
    }else if(a[i] > a[x]){
        delta[y]++;
        x = i;
    }
}
int id = 0; delta[0] = -1000000;
for(int i = 1; i <= n; ++ i){
    if(delta[i] > delta[id] || (delta[i] == delta[id] && a[i] < a[id])) id = i;
}
```
核心实现思想：同样是在枚举元素过程中更新记录数变化数组 `delta`，最后找出使记录数最大且元素值最小的元素。

### 最优关键思路或技巧
维护最大值和次大值进行分类讨论的方法最优，通过简单的一次遍历，复杂度为 $O(n)$，避免了使用树状数组带来的额外 $log$ 复杂度。

### 拓展思路
同类型题可能会改变排列的条件或记录的定义，例如记录定义为满足某种特定函数关系等，但解题思路依然是分析删除元素对目标值的影响。类似算法套路可以用于分析数组中元素删除或替换对某种统计量的影响问题。

### 推荐洛谷题目
- P1106 删数问题
- P1090 合并果子
- P1323 删数

### 个人心得摘录与总结
- **作者：Robin_kool**：原代码挂分是因为翻译问题，最后要输出总收益相等情况下 $a_i$ 最小的数。总结是在做题时要仔细理解题目要求，避免因细节问题导致错误。 

---
处理用时：30.93秒
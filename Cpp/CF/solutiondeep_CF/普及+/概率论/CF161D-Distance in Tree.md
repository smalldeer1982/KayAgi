# 题目信息

# Distance in Tree

## 题目描述

## 题目大意
输入点数为$N$一棵树

求树上长度恰好为$K$的路径个数

## 说明/提示

$1 \leq n \leq 50000$

$1 \leq k \leq 500$

感谢@Zhang_RQ 提供的翻译

## 样例 #1

### 输入

```
5 2
1 2
2 3
3 4
2 5
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 3
1 2
2 3
3 4
4 5
```

### 输出

```
2
```

# AI分析结果

### 题解综合分析与结论
本题要求计算给定树中长度恰好为 $K$ 的路径个数，各题解主要围绕树形 DP、树上启发式合并、长链剖分和点分治这几种算法展开。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|Rhodoks|提供树形 DP、树上启发式合并、长链剖分和点分治四种解法|树形 DP 暴力合并儿子节点状态；树上启发式合并保留重儿子状态；长链剖分利用指针灵活转移；点分治递归处理子树|处理路径计数避免重复计算|4星|
|vacation|树形 DP|用动态数组存储邻接链表，枚举子节点计算路径，合并子树状态|状态转移和路径计数|3星|
|MyukiyoMekya|树形 DP|先 DP 出节点到子树内叶子链的长度和个数，分两类情况讨论路径贡献|避免路径计数重复|3星|
|yijan|树形 DP|先统计向下走的路径，再自底向上更新结果|处理向上和向下走的路径避免重复|3星|
|jiazhaopeng|点分治|套用模板，用桶记录距离，递归处理子树，优化找距离过程|找重心和处理路径计数|4星|
|da32s1da|点分治|先统计小于等于 $k$ 的路径数量，再减去小于 $k$ 的数量|利用容斥原理处理路径计数|3星|
|Graphcity|点分治|将标记距离数组改为记录个数，用栈统一处理距离|路径计数和避免重复|3星|
|foreverlasting|点分治|用桶记录距离，分情况讨论路径计数|路径计数和避免重复|3星|
|Itst|点分治|用 $O(n)$ 方法处理路径，记录路径长度和子树分布|路径处理和避免重复|3星|
|newbiechd|长链剖分|利用长链剖分特性转移状态|状态转移和路径计数|4星|

### 所选题解
- **Rhodoks（4星）**
    - **关键亮点**：提供多种解法，思路清晰，复杂度分析明确。
    - **核心代码（树形 DP）**：
```cpp
void dfs(int pos,int f)
{
    dp[pos][0]=1;
    LINK(i,g,pos)
        if (g.to[i]!=f)
        {
            dfs(g.to[i],pos);
            RPT(j,0,k)
                ans+=dp[g.to[i]][j]*dp[pos][k-j-1];
            RPT(j,0,k)
                dp[pos][j+1]+=dp[g.to[i]][j];
        }
}
```
核心思想：通过深度优先搜索，先初始化根节点到自身距离为 0 的路径个数为 1，然后递归处理子节点，合并子节点状态并计算路径贡献。

- **jiazhaopeng（4星）**
    - **关键亮点**：详细解释点分治思路和优化方法，代码注释清晰。
    - **核心代码（点分治）**：
```cpp
void get_dis(int cur, int faa) {
    if (dis[cur] > k) return;
    known_dis[dis[cur]]++;
    for (register int i = head[cur]; i; i = e[i].nxt) {
        int to = e[i].to;
        if (to == faa || vis[to]) continue;
        dis[to] = dis[cur] + 1;
        get_dis(to, cur);
    }
}

inline void sol(int cur, int len, int flag) {
    memset(known_dis, 0, sizeof(known_dis));
    dis[cur] = len;
    get_dis(cur, 0);
    ll res = 0;
    int tmp;
    for (register int i = 0; i <= k; ++i) {
        tmp = k - i;
        if (tmp <= i) break;
        res += known_dis[i] * known_dis[tmp];
    }
    if (!(k & 1)) {
        tmp = k >> 1;
        res += (known_dis[tmp] * (known_dis[tmp] - 1)) >> 1;
    }
    ans += res * flag;
}
```
核心思想：通过 `get_dis` 函数递归找出节点到根节点的距离，用桶记录距离个数，`sol` 函数统计路径数量并利用容斥原理处理重复计算。

- **newbiechd（4星）**
    - **关键亮点**：长链剖分解法，时空复杂度优秀。
    - **核心代码（长链剖分）**：
```cpp
void dfs2(int x) {
    f[x][0]=1;
    R int i,j,y,m,n=t[x]-d[x],k;
    if(q[x]) f[q[x]]=f[x]+1,dfs2(q[x]);
    for(i=h[x];i;i=s[i])
        if((y=g[i])^p[x]&&y^q[x]) {
            f[y]=e,m=t[y]-d[y],e+=m+1,dfs2(y);
            for(j=max(K-n,0),k=min(m,K-1);j<=k;++j) o+=f[x][K-j]*f[y][j];
            for(j=0;j<=m;++j) f[x][j+1]+=f[y][j];
        }
    if(n>K) o+=f[x][K+1];
}
```
核心思想：通过深度优先搜索，先初始化根节点到自身距离为 0 的路径个数为 1，优先处理长儿子，再处理其他儿子，合并状态并计算路径贡献。

### 最优关键思路或技巧
- **树形 DP**：利用状态数组记录节点到子树内节点的距离信息，通过合并子节点状态计算路径贡献。
- **点分治**：通过找重心将树分割成子树，递归处理子树，用桶记录距离信息，利用容斥原理避免重复计算。
- **长链剖分**：利用指针灵活转移状态，避免繁琐的状态转移操作，降低时间复杂度。

### 拓展思路
同类型题可考虑树的路径问题，如路径长度和、路径最大值等，可使用类似的树形 DP、点分治、长链剖分等算法。

### 推荐题目
- [P3806 【模板】点分治1](https://www.luogu.com.cn/problem/P3806)
- [P4178 Tree](https://www.luogu.com.cn/problem/P4178)
- [P2634 [国家集训队]聪聪可可](https://www.luogu.com.cn/problem/P2634)

### 个人心得摘录与总结
- **Itst**：原本写了一个 $O(n^2)$ 的路径处理方法，被菊花图卡到 TLE，后来使用 $O(n)$ 的路径处理方法。总结：在算法设计时要考虑极端数据情况，选择合适的复杂度算法。
- **newbiechd**：认为长链剖分好写且跑得快，看到点分治题就想写长链剖分。总结：不同算法有各自的优缺点，可根据题目特点选择合适的算法。 

---
处理用时：42.88秒
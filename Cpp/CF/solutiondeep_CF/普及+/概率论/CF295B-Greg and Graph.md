# 题目信息

# Greg and Graph

## 题目描述

Greg 有一个有边权的有向图，包含 $n$ 个点。这个图的每两个点之间都有两个方向的边。Greg 喜欢用他的图玩游戏，现在他发明了一种新游戏：

- 游戏包含 $n$ 步。
- 第 $i$ 步 Greg 从图中删掉编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。
- 在执行每一步之前，Greg 想知道所有点对间最短路长度的和。最短路可以经过任何没删掉的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删掉 $x_i$ 前 $v$ 和 $u$ 间的最短路长度，那么Greg想知道下面这个求和的值：$\sum_{v, u, v \neq u} d(i, v, u)$ 。

帮帮 Greg，输出每一步之前要求的值。

## 样例 #1

### 输入

```
1
0
1
```

### 输出

```
0 ```

## 样例 #2

### 输入

```
2
0 5
4 0
1 2
```

### 输出

```
9 0 ```

## 样例 #3

### 输入

```
4
0 3 1 1
6 0 400 1
2 4 0 1
1 1 1 0
4 1 2 3
```

### 输出

```
17 23 404 0 ```

# AI分析结果

### 题目翻译
#### Greg和图
#### 题目描述
Greg有一个带边权的有向图，包含 $n$ 个点。这个图中每两个点之间都有两个方向的边。Greg喜欢用他的图玩游戏，现在他发明了一种新游戏：
- 游戏包含 $n$ 步。
- 第 $i$ 步，Greg从图中删除编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。
- 在执行每一步之前，Greg想知道所有点对间最短路长度的和。最短路可以经过任何未被删除的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删除 $x_i$ 之前 $v$ 和 $u$ 之间的最短路长度，那么Greg想知道下面这个求和的值：$\sum_{v, u, v \neq u} d(i, v, u)$。

请帮助Greg，输出每一步之前要求的值。

#### 样例 #1
##### 输入
```
1
0
1
```
##### 输出
```
0
```

#### 样例 #2
##### 输入
```
2
0 5
4 0
1 2
```
##### 输出
```
9 0
```

#### 样例 #3
##### 输入
```
4
0 3 1 1
6 0 400 1
2 4 0 1
1 1 1 0
4 1 2 3
```
##### 输出
```
17 23 404 0
```

### 综合分析与结论
这些题解的核心思路都是采用逆向思维，将题目中的删点操作转化为加点操作，使用Floyd算法计算每一步加点后所有点对间最短路长度的和，最后倒序输出结果。

#### 算法要点
- **逆向思维**：由于Floyd算法不支持删点操作，且正向删点复杂度高，因此将删点转换为加点，降低问题复杂度。
- **Floyd算法**：每次加入一个点后，用该点作为中转点更新所有点对之间的最短路径。
- **标记点状态**：使用布尔数组标记点是否在当前图中，计算最短路和时只考虑在图中的点。

#### 解决难点
- **删点问题**：通过逆向思维将删点转化为加点，避免了Floyd算法无法处理删点的问题。
- **复杂度问题**：正向删点每次都要进行一次Floyd算法，复杂度为 $O(n^4)$，逆向加点复杂度降为 $O(n^3)$。

### 所选题解
1. **作者：Dream_weavers（5星）**
    - **关键亮点**：思路清晰，简洁明了地阐述了正向思路的问题和逆向思维的解决方案，代码核心部分注释清晰。
    - **核心代码**：
```cpp
for(int l=n;l>=1;l--){
    int k=x[l];vis[k]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
    sum=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(vis[i]&&vis[j])
                sum+=d[i][j];
    ans[l]=sum;
}
```
核心思想：倒序遍历要删除的点，将其标记为已加入图中，用该点更新所有点对的最短路径，然后计算当前图中所有点对的最短路和并记录。

2. **作者：RainAir（4星）**
    - **关键亮点**：代码结构完整，使用了快速读入优化，详细解释了逆向思维的正确性。
    - **核心代码**：
```c++
RFOR(p,N,1){
    int k = del[p];
    tag[k] = true;
    FOR(i,1,N){
        FOR(j,1,N){
            f[i][j] = std::min(f[i][j],f[i][k] + f[k][j]);
            if(tag[i] && tag[j]) ans[p] += f[i][j];
        }
    }
}
```
核心思想：从后往前枚举要删除的点，将其标记为已加入图中，更新最短路径并计算当前图的最短路和。

3. **作者：Gerald_Chen（4星）**
    - **关键亮点**：代码简洁，注释清晰，详细解释了逆向思维的具体操作。
    - **核心代码**：
```cpp
for(int cur=n; cur; --cur) {
    int k=del[cur];
    avi[k]=true;
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j)
            if(i!=j) {
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
                if(avi[i] && avi[j])
                    ans[cur]+=dist[i][j];
            }
}
```
核心思想：倒序遍历要删除的点，将其加入图中，更新最短路径并计算当前步骤的最短路和。

### 最优关键思路或技巧
- **逆向思维**：将删点问题转化为加点问题，避免了Floyd算法无法处理删点的难题，同时降低了时间复杂度。
- **Floyd算法的灵活运用**：每次加入一个点后，用该点作为中转点更新所有点对的最短路径。

### 可拓展之处
同类型题或类似算法套路：
- 涉及图的动态修改（如删边、加点等），同时需要求最短路的问题，可考虑逆向思维和Floyd算法结合。
- 其他需要优化时间复杂度的图论问题，也可以尝试逆向思考问题。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：同样涉及图的动态变化和最短路问题。
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)：Floyd算法的应用。
- [P2934 [USACO09JAN]Safe Travel G](https://www.luogu.com.cn/problem/P2934)：图论中最短路的拓展问题。

### 个人心得摘录与总结
- **tzl_Dedicatus545**：提到本题要开 `long long` ，否则会炸 `int` ；还指出在Floyd内判断点是否可用时的错误写法及原因，强调要先更新最短路径再进行特判。总结：在处理图论问题时，要注意数据范围，避免溢出，同时要正确使用算法，注意细节。

---
处理用时：36.39秒
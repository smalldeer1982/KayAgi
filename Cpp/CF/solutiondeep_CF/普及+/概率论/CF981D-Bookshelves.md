# 题目信息

# Bookshelves

## 题目描述

## 题意：

$Keks$ 先生是 $Byteland$ 大陆的典型的白领。

他办公室里有一个书架，上面有几本书，每本书都有一个值为正整数的价格。

$Keks$ 先生把书架的价值定义为书价的总和。         

出乎意料地是， $Keks$ 先生升职了，现在他要去一个新的办公室。

他知道，在新的办公室里，他将有不止一个书架，而恰恰是 $K$ 个书架。

他认为 $K$ 个书架的美丽程度在于所有书架的价值的“按位与”和。 

他还决定不花时间重新整理书籍，所以他会先把几本书放在第一个书架上，下几本书放在下一个书架上，以此类推。当然，他会在每一个架子上放置至少一本书。这样，他会把所有的书放在 $K$ 个书架上，尽量使书架的美观程度越大越好。计算这个最大可能的美丽程度。

## 样例 #1

### 输入

```
10 4
9 14 28 1 7 13 15 29 2 31
```

### 输出

```
24
```

## 样例 #2

### 输入

```
7 3
3 14 15 92 65 35 89
```

### 输出

```
64
```

# AI分析结果

### 题目内容已为中文，无需翻译

### 综合分析与结论
这些题解主要围绕如何将 $n$ 本书按顺序放到 $k$ 个书架上，以得到最大的按位与美观程度展开。大部分题解采用了按位贪心结合动态规划的思路，只有一个题解使用暴力存储所有状态的方法。
- **思路对比**：多数题解从高位到低位贪心选择，通过动态规划验证答案是否可行；而 panyanppyy 的题解则是暴力存储所有转移状态，最后取最大值。
- **算法要点**：按位贪心的题解中，状态定义一般为前 $i$ 本书放到 $j$ 个书架是否能得到满足条件的答案；转移方程围绕前一状态和当前区间和的按位与操作。暴力解法的要点是用 `unordered_set` 存储所有可能的贡献。
- **解决难点**：难点在于如何判断某一位能否为 1，按位贪心结合 DP 解决了这个问题；暴力解法解决了按位与操作取最大值不一定最优的问题。

### 评分较高的题解
- **Siyuan（5星）**
    - **关键亮点**：思路清晰，代码简洁，对贪心和 DP 的解释详细，时间复杂度分析准确。
    - **核心代码**：
```cpp
bool check(long long x) {
    memset(f,0,sizeof(f));
    f[0][0]=1;
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=k;++j) {
            for(int k=0;k<i;++k) {
                f[i][j]|=f[k][j-1]&(((a[i]-a[k])&x)==x);
            }
        }
    }
    return f[n][k];
}
int main() {
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;++i) scanf("%lld",&a[i]),a[i]+=a[i-1];
    long long ans=0;
    for(int i=60;i>=0;--i) {
        long long now=ans|(1LL<<i);
        if(check(now)) ans|=(1LL<<i);
    }
    printf("%lld\n",ans);
    return 0;
}
```
核心思想：从高位到低位贪心枚举每一位，用 `check` 函数通过 DP 验证当前位能否为 1，若可以则更新答案。
- **Libre_dreagonm（4星）**
    - **关键亮点**：思路清晰，对按位贪心和 DP 的解释通俗易懂，提醒了位运算优先级和枚举最高位的注意事项。
    - **核心代码**：
```cpp
int check(int x){
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i=1;i<=k;i++)
        for(int j=1;j<=n;j++)
            for(int kx=0;kx<j;kx++)
                dp[i][j]|=dp[i-1][kx]&&(((sum[j]-sum[kx])&x)==x);
    return dp[k][n];
}
signed main(){
    scanf("%lld %lld",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+a[i];
    for(int i=60;i>=0;i--){
        int mid=ans|(1LL<<i);
        if(check(mid))
            ans|=(1LL<<i);
    }
    printf("%lld",ans);
    return 0;
}
```
核心思想：同样是按位贪心，用 `check` 函数进行 DP 验证，根据验证结果更新答案。
- **jch123（4星）**
    - **关键亮点**：思路简洁明了，代码实现规范。
    - **核心代码**：
```cpp
bool check(ll x)
{
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=k;j++)
            for(int k=0;k<i;k++)
                dp[i][j]|=dp[k][j-1]&(((s[i]-s[k])&x)==x);
    return dp[n][k]; 
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        cin>>a[i],s[i]=s[i-1]+a[i];
    ll ans=0;
    for(ll i=60;i>=0;i--)
    {
        ll x=1ll<<i;
        if(check(ans|x))
            ans|=x;
    }
    cout<<ans;
    return 0;
}
```
核心思想：按位贪心枚举，`check` 函数通过 DP 验证答案可行性，更新答案。

### 最优关键思路或技巧
- **按位贪心**：对于按位与和问题，从高位到低位贪心选择，因为高位为 1 肯定比这一位为 0 且后面都为 1 更优。
- **动态规划验证**：用 DP 验证某一位能否为 1，通过状态定义和转移方程判断是否能得到满足条件的答案。

### 可拓展之处
同类型题或类似算法套路：
- 其他按位运算相关的贪心问题，如按位或、按位异或等。
- 区间划分的动态规划问题，如将数组划分为若干段，求某一指标的最优值。

### 洛谷题目推荐
1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：涉及区间划分和二分答案，与本题的区间划分思路有一定关联。
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：二分答案结合贪心判断，和本题的贪心思想有相似之处。
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：区间选择问题，可使用贪心算法解决，锻炼贪心思维。

### 个人心得摘录与总结
- **Libre_dreagonm**：开始没意识到按位分别计算，想了好久才看题解想到。总结：遇到按位运算的题目，要有按位分别计算的意识。

---
处理用时：34.99秒
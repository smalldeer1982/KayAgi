# 题目信息

# Vasya And The Mushrooms

## 题目描述

Vasya 住在森林里，附近有一个会长蘑菇的空地。这个空地被分成两行，每行分为 $n$ 个连续的格子。Vasya 知道每分钟每个格子里能长多少个蘑菇。他要花一分钟从一个格子走到相邻的格子上，并且他不能离开空地。（我们称两个格子相邻，当且仅当它们有公共边。）当 Vasya 进入一个格子时，他会马上收集那个格子里的所有蘑菇。

Vasya 从左上角的格子开始收集蘑菇。因为他等不及蘑菇生长了，所以每分钟内他必须移动到一个相邻格子。他想每个格子都恰好走一遍并且最大化他所收集的蘑菇数量。一开始所有格子都没有蘑菇。Vasya也不一定要回到开始的格子。
帮帮 Vasya！计算出他能收集到的最大蘑菇数量。

## 说明/提示

#### 样例1:

在第一个测试用例中，最佳路径如下：

![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1016C/fbb0db02f46ac40c8f18dc6a212852df14543f5e.png) 

这样，蘑菇的收集重量将为 $0·1 + 1·2 + 2·3 + 3·4 + 4·5 + 5·6 =70$。

#### 样例2:

在第二个测试用例中，最佳路径如下：

![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1016C/0853812a60511dc1127814cc7d3f93535736820f.png) 

这样，蘑菇的收集重量将为 $0·1 + 1·10 + 2·100 + 3·1000 + 4·10000 + 5·100000 =543210$

## 样例 #1

### 输入

```
3
1 2 3
6 5 4
```

### 输出

```
70
```

## 样例 #2

### 输入

```
3
1 1000 10000
10 100 100000
```

### 输出

```
543210
```

# AI分析结果



# Vasya And The Mushrooms

## 题目描述

Vasya 住在森林里，附近有一个会长蘑菇的空地。这个空地被分成两行，每行分为 $n$ 个连续的格子。Vasya 知道每分钟每个格子里能长多少个蘑菇。他要花一分钟从一个格子走到相邻的格子上，并且他不能离开空地。（我们称两个格子相邻，当且仅当它们有公共边。）当 Vasya 进入一个格子时，他会马上收集那个格子里的所有蘑菇。

Vasya 从左上角的格子开始收集蘑菇。因为他等不及蘑菇生长了，所以每分钟内他必须移动到一个相邻格子。他想每个格子都恰好走一遍并且最大化他所收集的蘑菇数量。一开始所有格子都没有蘑菇。Vasya也不一定要回到开始的格子。
帮帮 Vasya！计算出他能收集到的最大蘑菇数量。

---

### 题解综合分析

所有题解均围绕"蛇形路径+直线路径"的混合模式展开，核心思路为：
1. 前$k$列采用蛇形走法，剩余列采用直线往返
2. 预处理前缀和/后缀和加速计算
3. 枚举转折点$k$，计算两种路径贡献的加权和

#### 最优思路提炼
1. **路径模式分析**：合法路径必为前$k$列蛇形走法 + 剩余列先直行到底再折返
2. **贡献值拆分**：将总时间分解为前$k$列的固定贡献 + 剩余列的时间递增贡献
3. **预处理优化**：使用前缀和/后缀和快速计算各段的加权蘑菇数

---

### 高星题解推荐

#### 1. YellowBean_Elsa（5星）
**关键亮点**：
- 极简预处理：仅维护三个后缀和数组
- 巧妙的贡献计算公式：`sum1[i] = sum1[i+1] + s[i+1] + b[i] + b[i]*(2*(n-i))`
- 代码仅30行，时空复杂度最优
**核心代码**：
```cpp
for(int i=n;i>=1;i--){
    s[i]=s[i+1]+a[i]+b[i];
    sum1[i]=sum1[i+1]+s[i+1]+b[i]+b[i]*((n-i)<<1);          
    sum2[i]=sum2[i+1]+s[i+1]+b[i]+a[i+1]*((n-i)<<1);
}
for(int i=1;i<=n;i+=2){
    ans=max(ans,u[i]+sum1[i]+s[i]*((i<<1)-2));
    ans=max(ans,u[i]+sum2[i]+s[i]*((i<<1)-2));
}
```

#### 2. aison（4星）
**关键亮点**：
- 清晰的三种路径分类讨论
- 递推式推导完整，数学证明严谨
- 维护两种走法的独立前缀和
**核心公式**：
```cpp
ret1[i] = ret1[i-2] - a[i-1] - 2*s[i] - (2n-2i+4)*b[i-1]
ret2[i] = ret2[i-2] - b[i-2] - 2*s[i] - (2n-2i+5)*a[i-1]
```

#### 3. yybyyb（4星）
**关键亮点**：
- 动态维护当前时刻的贡献值
- 奇偶分情况处理路径转折
- 对称式预处理上下行的权值
**核心代码**：
```cpp
for(int i=1,t=0;i<=n;++i) {
    if(i&1) {
        ans=max(ans,s+sa[i]+rb[i]+1ll*t*da[i]+1ll*(t+n-i+1)*db[i]);
        s += 1ll*t*a[i]; ++t;
    }
    // 偶数列处理类似...
}
```

---

### 关键实现技巧
1. **后缀和预处理**：计算`sum[i] = a[i] + a[i+1] + ... + a[n]`的同时维护加权和
2. **时间戳复用**：利用`(i<<1)-2`统一计算路径转折后的起始时间
3. **奇偶分治**：将路径模式按列数奇偶性分类处理，避免复杂条件判断

---

### 拓展训练
1. 环形路径优化：CF1016C 加强版（假设场地首尾相连）
2. 三维路径规划：LOJ 某三维网格收集问题
3. 动态蘑菇生长：HDU 某随时间线性增长的收集问题

---

### 推荐习题
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004) - 双路径最优值问题
2. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434) - 矩阵路径遍历的极值问题 
3. [CF1175E Minimal Segment Cover](https://codeforces.com/problemset/problem/1175/E) - 区间覆盖的路径规划

---
处理用时：52.59秒
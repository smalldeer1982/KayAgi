# 题目信息

# Military Problem

## 题目描述

在这个问题中你需要帮助伯兰（？？我没找到有Berland这个国家）军队组织他们的指挥系统

伯兰军队中一共有n个军官。第一个官员是军队的指挥官，他并没有任何上级。其他的军官都有且只有一个直接的上级。如果一个军官a是军官b的上级，那么你也可以说军官b就是军官a的下属

如果满足下列条件，那么军官x就是军官y的下属（直接或非直接）：

1.y是x的直接上级 2.x的直接上级是y的下属

举个例子，下图的官员3的下属有:5,6,7,8,9

所以，在伯兰军队的结构中，除了指挥官，其他人都是指挥官的下属

形式上的，让我们把伯兰军队看成一棵拥有n个节点的树，树的节点u就代表了军官u。根（即一号节点）就相当于指挥官

伯兰战争部门命令你对q个查询给出答案。这q个查询会以（ui，ki）的形式给出，ui代表了某个军官，ki是正整数。你需要输出，编号为ui的军官下达命令后，第ki个得知此命令的军官编号是多少，如果传达人数不足ki个，输出-1。

要处理第i个查询，想象一下ui的命令如何我下达到ui的下属。这里使用了典型的DFS（深度优先搜索）算法。

假设现在的军官是a，他要下达一个命令。a军官选择一个军官b——还没有收到这个命令的直接下属（即在树上的一个孩子）。如果有许多这样的直接下属，那么A选择编号最小的那一个。A军官向B军官发出命令。之后，B使用完全相同的方式将命令扩展到它的子树。在B完成命令后，军官A再次选择下一个直接下属（使用相同的策略）。当军官A不能选择任何还没有接到命令的直接下属时，军官A下达命令完成。

让我们看一下下面这个例子（看下面的图）：

如果军官1下达了命令，军官们收到命令的顺序是：1,2,3,5,6,8,7,9,4

如果军官3下达了命令，军官们收到命令的顺序是：3,5,6,8,7,9

如果军官7下达了命令，军官们收到命令的顺序是：7,9

如果军官9下达了命令，军官们收到命令的顺序是：9

你应当分开处理这些查询。一个查询不会影响其他查询的结果。

## 样例 #1

### 输入

```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```

### 输出

```
3
6
8
-1
9
4
```

# AI分析结果



# 题目翻译（保留原格式）

## 题目描述

在这个问题中你需要帮助伯兰军队组织他们的指挥系统。

伯兰军队中一共有n个军官。第一个官员是军队的指挥官，他没有任何上级。其他军官都有且只有一个直接上级。如果一个军官a是军官b的上级，那么军官b就是军官a的下属。

当满足以下条件之一时，军官x是军官y的下属（直接或间接）：
1. y是x的直接上级
2. x的直接上级是y的下属

伯兰军队的结构可以看作一棵包含n个节点的树，根节点（编号1）代表指挥官。

需要处理q个查询，每个查询给出（ui，ki），要求输出以ui为根的子树进行DFS遍历时，第ki个被访问的军官编号，若不足ki个则输出-1。遍历时按子节点编号从小到大选择。

## 样例 #1

### 输入
```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```

### 输出
```
3
6
8
-1
9
4
```

---

# 题解分析与结论

## 算法核心
所有高分题解均基于**DFS序连续区间**的特性：
1. 预处理整棵树的DFS序数组
2. 记录每个节点的进入时间(dfn)和子树大小(size)
3. 查询时直接计算区间位置：`dfn[u] + k - 1`

## 高分题解推荐

### 1. Anguei（5星）
**亮点：**
- 清晰的变量命名（when记录时间戳，id反向映射）
- 处理边时使用emplace_back优化
- 包含代码加速技巧（关闭同步流）
- 完整注释说明

**核心代码：**
```cpp
void dfs(int now) {
    when[now] = ++time;
    id[time] = now;
    size[now] = 1;
    for (auto &e : g[now]) {
        dfs(e.to);
        size[now] += size[e.to];
    }
}
```

### 2. jr_zch（5星）
**亮点：**
- 代码最简洁（仅19行）
- 使用sor数组直接存储DFS序
- 变量命名直观（pre记录时间戳，siz记录子树大小）

**核心代码：**
```cpp
void dfs(int fa, int u) {
    sor[++cnt] = u;
    pre[u] = cnt;
    siz[u] = 1;
    for(int v : e[u]) {
        dfs(u, v);
        siz[u] += siz[v];
    }
}
```

### 3. Asphy7xia（4星）
**亮点：**
- 包含完整的题意分析
- 详细说明DFS序性质
- 代码中包含排序子节点步骤

**核心代码：**
```cpp
for (int i = 1; i <= n; i++)
    sort(pre[i].begin(), pre[i].end());
dfs(1);
```

---

# 关键技巧总结

1. **DFS序连续性**：子树DFS序在整树DFS序中是连续区间
2. **时间戳映射**：建立dfn（节点→时间）和rk（时间→节点）双映射
3. **子树大小预计算**：通过后序遍历累加子树大小
4. **查询公式**：`ans = dfn[u] + k - 1`（需校验k ≤ size[u]）

---

# 拓展练习

1. **P3916 图的遍历**（DFS序应用）
2. **P3379 最近公共祖先**（树遍历基础）
3. **P3384 树链剖分**（DFS序进阶应用）

---

# 题解心得摘录

1. **hater**：  
"刚开始用剪枝版DFS第三个点就TLE，后来发现链式结构下剪枝无效，改用DFS序正解"

2. **mondayrain**：  
"意识到直接暴力DFS会超时，通过画图发现子树DFS序的连续特性"

3. **Anguei**：  
"感谢@Sooke指导，认识到STL的vector在树存储中的高效性，使用emplace_back优化建边"

---
处理用时：46.46秒
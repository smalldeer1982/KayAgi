# 题目信息

# Mirror Maze

## 题目描述

# 镜子迷宫


给定一个有\(R\)行（从北到南编号为\(1\)到\(R\)）和\(C\)列（从西到东编号为\(1\)到\(C\)）的网格。这个网格中的每个方格大小相同。位于第\(r\)行和第\(c\)列的方格表示为\((r,c)\)。每个方格要么为空，要么在方格的一条对角线上有一面镜子。每面镜子由一条线段表示。如果镜子是从西南角到东北角斜着放置的，则为\(1\)型镜子；如果是另一条对角线方向，则为\(2\)型镜子。

这些镜子遵循反射定律，即反射角等于入射角。正式地说，对于\(1\)型镜子，如果一束光线从方格的北、南、西或东方向射入，那么它将分别被反射到方格的西、东、北和南方向。类似地，对于\(2\)型镜子，如果一束光线从方格的北、南、西或东方向射入，那么它将分别被反射到方格的东、西、南和北方向。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2045M/5f7b63f0fb5656735a6c59d6b7204c8e210c6d4c.png)你想要在网格外放置一个激光发射器，使得激光束能击中所有的镜子。有\(2\cdot(R + C)\)个可能放置激光发射器的位置：

- 从网格北侧的第\(c\)列（\(1\leq c\leq C\)），向南发射激光束；
- 从网格南侧的第\(c\)列（\(1\leq c\leq C\)），向北发射激光束；
- 从网格东侧的第\(r\)行（\(1\leq r\leq R\)），向西发射激光束；
- 从网格西侧的第\(r\)行（\(1\leq r\leq R\)），向东发射激光束。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2045M/29c68e47c3b155b917aa2d4237fa93819b498fc4.png)确定所有可能放置激光发射器的位置，使得激光束能击中所有的镜子。

## 说明/提示

样例输入/输出 #1的解释

下面的图示展示了这个样例的一个解决方案。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2045M/e36d02e4bf94a08c27da9c9fd00e9bc42d7a4647.png)样例输入/输出 #2的解释

下面的图示展示了这个样例的一个解决方案。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2045M/35fe527ce8ee213e9ba2c6ba34c9f6c589c7585c.png)

## 样例 #1

### 输入

```
4 4
.//.
.\\.
.\/.
....```

### 输出

```
2
N3 W2```

## 样例 #2

### 输入

```
4 6
./..\.
.\...\
./../\
......```

### 输出

```
2
E3 S2```

## 样例 #3

### 输入

```
4 4
....
./\.
.\/.
....```

### 输出

```
0```

# AI分析结果



### 题目内容重写

# 镜子迷宫

## 题目描述

给定一个由 \(R\) 行（从北到南编号为 \(1\) 到 \(R\)）和 \(C\) 列（从西到东编号为 \(1\) 到 \(C\)）组成的网格。每个格子要么为空，要么有一条对角线放置的镜子。镜子分为两种类型：从西南到东北（类型 1，用 `/` 表示）和另一条对角线（类型 2，用 `\` 表示）。光线遵循反射定律，入射角等于反射角。

要求找出所有可能的激光发射器位置（位于网格外部），使得激光束能击中所有镜子。可能的发射位置包括网格四边的所有外边缘点，每个位置有固定的发射方向。

---

### 题解分析与结论

#### 核心难点
1. **反射方向模拟**：需精确处理不同类型镜子的反射方向转换，容易因方向编码错误导致路径错误。
2. **环路检测**：光线可能进入无限循环，需记录状态（位置+方向）避免重复处理。
3. **覆盖检查**：确保所有镜子所在格子均被光线经过。

#### 通用建议
- **方向映射表**：预先定义方向编码（如上下左右对应移动的坐标变化），并建立反射转换表。
- **状态记录**：使用三维数组 `vis[r][c][d]` 标记是否以方向 `d` 访问过格子 `(r,c)`，避免循环。
- **暴力模拟**：遍历所有可能的发射位置，对每个位置进行路径模拟，记录访问的格子。

#### 扩展思路
- **BFS/DFS 选择**：路径模拟可选择 BFS 或 DFS，需注意状态管理。
- **复杂度优化**：发射点数量为 \(O(R+C)\)，单次模拟复杂度为 \(O(RC)\)，整体可接受。

---

### 推荐相似题目
1. **P1141 01迷宫**：网格路径搜索，涉及状态记录。
2. **P1515 迷宫**：需覆盖特定点的路径判断。
3. **P1038 字变换**：状态转换与循环检测。

---

### 关键代码实现思路
```cpp
// 方向定义：0(上),1(下),2(左),3(右)
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};
// 反射方向映射表：mirror_type[类型][原方向] = 新方向
int mirror1[] = {2, 3, 0, 1}; // 类型 1 (/)
int mirror2[] = {3, 2, 1, 0}; // 类型 2 (\)

bool simulate(int start_r, int start_c, int dir) {
    vector<vector<vector<bool>>> vis(R+1, vector<vector<bool>>(C+1, vector<bool>(4, false)));
    vector<vector<bool>> covered(R+1, vector<bool>(C+1, false));
    int r = start_r, c = start_c;
    while (true) {
        if (越界) break;
        if (vis[r][c][dir]) break; // 检测循环
        vis[r][c][dir] = true;
        covered[r][c] = true;
        // 处理反射
        if (mirror_type == 1) dir = mirror1[dir];
        else if (mirror_type == 2) dir = mirror2[dir];
        // 移动
        r += dx[dir];
        c += dy[dir];
    }
    // 检查所有镜子是否被覆盖
    for (遍历所有格子)
        if (有镜子且未被覆盖) return false;
    return true;
}
```

---
处理用时：266.81秒
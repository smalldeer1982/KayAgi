# 题目信息

# Palindrome-less Arrays

## 题目描述

Let's denote that some array $ b $ is bad if it contains a subarray $ b_l, b_{l+1}, \dots, b_{r} $ of odd length more than $ 1 $ ( $ l < r $ and $ r - l + 1 $ is odd) such that $ \forall i \in \{0, 1, \dots, r - l\} $ $ b_{l + i} = b_{r - i} $ .

If an array is not bad, it is good.

Now you are given an array $ a_1, a_2, \dots, a_n $ . Some elements are replaced by $ -1 $ . Calculate the number of good arrays you can obtain by replacing each $ -1 $ with some integer from $ 1 $ to $ k $ .

Since the answer can be large, print it modulo $ 998244353 $ .

## 样例 #1

### 输入

```
2 3
-1 -1
```

### 输出

```
9
```

## 样例 #2

### 输入

```
5 2
1 -1 -1 1 2
```

### 输出

```
0
```

## 样例 #3

### 输入

```
5 3
1 -1 -1 1 2
```

### 输出

```
2
```

## 样例 #4

### 输入

```
4 200000
-1 -1 12345 -1
```

### 输出

```
735945883
```

# AI分析结果

### 题目翻译
# 无回文数组

## 题目描述
如果一个数组 $ b $ 包含一个长度大于 $ 1 $ 的奇数长度的子数组 $ b_l, b_{l+1}, \dots, b_{r} $（$ l < r $ 且 $ r - l + 1 $ 为奇数），使得对于所有的 $ i \in \{0, 1, \dots, r - l\} $ 都有 $ b_{l + i} = b_{r - i} $，则称这个数组 $ b $ 是坏的。

如果一个数组不是坏的，则称它是好的。

现在给定一个数组 $ a_1, a_2, \dots, a_n $，其中一些元素被替换为 $ -1 $。计算通过将每个 $ -1 $ 替换为 $ 1 $ 到 $ k $ 之间的某个整数可以得到的好数组的数量。

由于答案可能很大，将结果对 $ 998244353 $ 取模后输出。

## 样例 #1
### 输入
```
2 3
-1 -1
```
### 输出
```
9
```

## 样例 #2
### 输入
```
5 2
1 -1 -1 1 2
```
### 输出
```
0
```

## 样例 #3
### 输入
```
5 3
1 -1 -1 1 2
```
### 输出
```
2
```

## 样例 #4
### 输入
```
4 200000
-1 -1 12345 -1
```
### 输出
```
735945883
```

### 综合分析与结论
这些题解的核心思路都是先将“不存在长度大于1的奇数回文串”转化为“不存在长度为3的回文串”，进而将原问题转化为按奇偶下标拆分后的数组中相邻元素不相等的方案数问题。在处理连续的 -1 段时，多数题解使用动态规划来计算方案数。

### 算法要点对比
|作者|思路|算法要点|解决难点|
| ---- | ---- | ---- | ---- |
|Leap_Frog|先证明“有长度为3的回文子串”和“串不好”等价，按奇偶处理，用dp计算连续 -1 序列方案数|设 $dp[i][0/1]$ 表示长度为 $i$ 的连续 -1 序列在左右两边是否相同的方案数，状态转移方程为 $dp[i][0]=dp[i-1][1]\times(k - 1)$，$dp[i][1]=dp[i-1][1]\times(k - 2)+dp[i-1][0]$|原程序未考虑所有数放好后答案不符合的情况，添加特判|
|Chaigidel|发现坏的条件等价于不存在长度为3的回文串，分奇偶处理，用分治思想|设 $f_{i,0/1}$ 表示中间 -1 个数为 $i$，两端数是否相等的方案数，状态转移方程为 $f_{i,0}=(k - 2)f_{i-1,0}+f_{i-1,1}$，$f_{i,1}=(k - 1)f_{i-1,0}$|考虑多种特殊情况|
|Rui_R|按奇偶分组，将原问题转化为数组中相邻元素不相等的方案数问题，处理连续 -1 段|设 $dp[i][0]$ 表示一段长为 $i$ 的 -1 且其两端已确定的数取值不一致的方案数，$dp[i][1]$ 表示取值一致的方案数，状态转移方程为 $dp[i][1]=dp[i-1][0]*(k - 1)$，$dp[i][0]=dp[i-1][1]+(k - 2)*dp[i-1][0]$|处理各种细节情况|
|Soulist|将问题转化为相邻两位不相同的方案数问题，对连续 -1 段用dp预处理|设 $dp_{i,0}$ 表示长度为 $i$ 的 -1 段两边相同的方案数，$dp_{i,1}$ 为两边不同的方案数，状态转移方程为 $dp_{i,0}=dp_{i-1,1}*(k - 1)$，$dp_{i,1}=dp_{i-1,1}*(k - 2)+dp_{i-1,0}$|处理特殊情况|
|daniEl_lElE|将条件转化为 $a_i\not=a_{i+2}$，分奇偶处理，用线段树优化dp|$dp_{i,j}$ 表示看到第 $i$ 位，$a_i=j$ 的方案数，转移方程为 $dp_{i+2,j}=\sum_{k\not=j}dp_{i,k}$，用线段树维护区间加、乘、查询|原dp复杂度 $O(n^2)$ 无法通过，用线段树优化到 $O(n\log n)$|
|duyi|将问题转化为距离为2的位置值不相等的问题，分奇偶处理，对连续 -1 段分类讨论|将连续 -1 段分为4类，分别预处理方案数，如第四种情况用 $dp[x][y\in\{0,1,2\}]$ 表示考虑前 $x$ 个位置，第 $x$ 个位置的值与左右限制的关系|对不同类型的连续 -1 段分别处理|
|DPair|将问题转化为相邻元素不相等的方案数问题，对连续 -1 段分类处理|将连续 -1 段分为4类，用 $dp[i][0/1]$ 处理前两类，后两类由前两类转化而来|对不同类型的连续 -1 段分别求解|
|t162|将数组按奇偶分类，用二项式反演计算段的方案数|设 $f(s,t,l)$ 表示段开头为 $s$，结尾为 $t$，段长为 $l$ 的方案数，用二项式反演计算|二项式反演的应用|

### 评分
|作者|评分|
| ---- | ---- |
|Leap_Frog|4星|
|Chaigidel|4星|
|Rui_R|4星|
|Soulist|3星|
|daniEl_lElE|3星|
|duyi|3星|
|DPair|3星|
|t162|2星|

### 所选题解
- **Leap_Frog（4星）**
    - **关键亮点**：思路清晰，代码简洁，详细阐述了证明过程和状态转移方程的推导，还记录了调试过程。
    - **个人心得**：原代码提交后 `Wrong Answer On 14`，发现未考虑所有数放好后答案不符合的情况，添加特判解决问题。
    - **核心代码**：
```cpp
inline int wrk(int n,int a[])
{
    int ret = 1;
    for(int i = 1; i < n; i++) if(a[i]!= -1 && a[i] == a[i + 1]) return 0;
    for(int i = 1, j; i <= n; i = j + 1)
    {
        while(i <= n && a[i]!= -1) i++; j = i;
        while(j <= n && a[j] == -1) j++; j--;
        if(i > j || i < 1 || j > n) continue;
        else if(i == 1 && j == n) ret = 1ll * ret * ksm(k - 1, n - 1) % P * k % P;
        else if(i == 1 || j == n) ret = 1ll * (dp[j - i][0] + 1ll * (k - 1) * dp[j - i][1] % P) % P * ret % P;
        else ret = 1ll * ret * dp[j - i + 1][a[i - 1]!= a[j + 1]] % P;
    }
    return ret;
}
```
核心实现思想：先进行特判，然后遍历数组，找到连续的 -1 段，根据不同情况计算方案数。

- **Chaigidel（4星）**
    - **关键亮点**：思路简洁，代码规范，详细给出了状态转移方程和特殊情况的处理。
    - **核心代码**：
```cpp
int solve(int a[], int n) {
    if (n == 0) return 1;
    int l = 0, r = n - 1;
    int ret;
    for (; a[l] == -1 && l < n; l++);
    if (l == n) return mul(k, ksm(k - 1, n - 1));
    for (; a[r] == -1; --r);
    ret = mul(ksm(k - 1, l), ksm(k - 1, n - r - 1));
    int lst = l;
    for (l = lst + 1; l <= r; ++l) {
        if (a[l] == -1) continue;
        ret = mul(ret, f[l - lst - 1][a[lst] == a[l]]);
        lst = l;
    }
    return ret;
}
```
核心实现思想：先处理全为 -1 的情况，然后找到首尾非 -1 的位置，计算首尾 -1 段的方案数，再遍历中间的非 -1 位置，计算连续 -1 段的方案数。

- **Rui_R（4星）**
    - **关键亮点**：思路清晰，代码注释详细，对每种情况的处理都有解释。
    - **核心代码**：
```cpp
ll count(std::vector<int> v){
    ll res = 1;
    for(int i = 0; i < v.size();){
        int j;
        if(v[i] == -1){
            for(j = i + 1; v[j] == -1 && j < v.size(); j++);
            if(j == v.size()){
                if(v.size() == 1) return k;
                res = (dp[v.size() - 2][0] * (k - 1) + dp[v.size() - 2][1]) % mod;
                res *= k;
                res %= mod;
                return res;
            }else{
                res *= (dp[j - 1][0] * (k - 1) + dp[j - 1][1]);
                res %= mod; i = j;
            }
        }else{
            if(i == v.size() - 1) return res;
            for(j = i + 1; v[j] == -1 && j < v.size(); j++);
            if(j == v.size()){
                res *= (dp[v.size() - i - 2][0] * (k - 1) + dp[v.size() - i - 2][1]) % mod;
                res %= mod;
            }else{
                if(v[i] == v[j]) res *= dp[j - i - 1][1];
                else res *= (dp[j - i - 1][0]);
                res %= mod;
            }
            i = j;
        }
    }return res;
}
```
核心实现思想：遍历数组，根据当前位置是否为 -1 进行不同处理，找到连续的 -1 段，根据不同情况计算方案数。

### 最优关键思路或技巧
- **问题转化**：将“不存在长度大于1的奇数回文串”转化为“不存在长度为3的回文串”，进而转化为按奇偶下标拆分后的数组中相邻元素不相等的方案数问题。
- **动态规划**：通过定义合适的状态和状态转移方程，计算连续 -1 段的方案数。
- **分类讨论**：对连续 -1 段的不同情况进行分类讨论，分别计算方案数。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及回文串性质的计数问题，可尝试将问题转化为更简单的条件进行处理。
- 对于有多种限制条件的数组填充问题，可考虑分类讨论和动态规划的方法。

### 推荐题目
- [P1879 [USACO06NOV]Corn Fields G](https://www.luogu.com.cn/problem/P1879)：状态压缩动态规划，处理棋盘填充问题。
- [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：状态压缩动态规划，处理棋盘上的放置问题。
- [P1049 [NOIP2001 普及组] 装箱问题](https://www.luogu.com.cn/problem/P1049)：简单的动态规划问题，可加深对动态规划的理解。

---
处理用时：65.54秒
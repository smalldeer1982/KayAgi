# 题目信息

# Shohag Loves GCD

## 题目描述

Shohag 拥有一个整数 $n$ 和一个包含 $m$ 个不同整数的集合 $S$。请帮助他找到字典序最大*的整数数组 $a_1, a_2, \ldots, a_n$，使得对于每个 $1 \le i \le n$ 有 $a_i \in S$ ，并且满足对所有 $1 \le i < j \le n$ 有 $a_{\gcd(i, j)} \neq \gcd(a_i, a_j)$†，或者说明不存在这样的数组。

*一个数组 $a$ 如果在第一个不同的位置上比数组 $b$ 有更大的元素，则称其为字典序大于数组 $b$（假设两个数组长度相同）。

†$\gcd(x, y)$ 表示整数 $x$ 和 $y$ 的[最大公约数（GCD）](https://en.wikipedia.org/wiki/Greatest_common_divisor)。

## 说明/提示

在第一个测试用例中，数组中的每个元素都属于给定的集合 $S = \{3, 4, 6\}$，并且数组的所有索引对都满足必要的条件。特别是对于对 $(2, 3)$，有 $a_{\gcd(2, 3)} = a_1 = 6$ 而 $\gcd(a_2, a_3) = \gcd(4, 4) = 4$，因此它们不相等。尽管存在其他满足条件的数组，但这个是其中字典序最大的。

在第三个测试用例中，由于我们只能使用数组 $a = [2, 2]$，但对于该数组，对于对 $(1, 2)$，有 $a_{\gcd(1, 2)} = a_1 = 2$ 而 $\gcd(a_1, a_2) = \gcd(2, 2) = 2$，因此它们相等，这是不允许的！所以没有解决方案。

## 样例 #1

### 输入

```
3
6 3
3 4 6
1 1
1
2 1
2```

### 输出

```
6 4 4 3 4 3 
1 
-1```

# AI分析结果



### 题目翻译

# Shohag 热爱GCD

## 题目描述

Shohag 拥有一个整数 $n$ 和一个包含 $m$ 个不同整数的集合 $S$。请帮助他找到字典序最大*的整数数组 $a_1, a_2, \ldots, a_n$，使得对于每个 $1 \le i \le n$ 有 $a_i \in S$ ，并且满足对所有 $1 \le i < j \le n$ 有 $a_{\gcd(i, j)} \neq \gcd(a_i, a_j)$†，或者说明不存在这样的数组。

*一个数组 $a$ 如果在第一个不同的位置上比数组 $b$ 有更大的元素，则称其为字典序大于数组 $b$（假设两个数组长度相同）。

†$\gcd(x, y)$ 表示整数 $x$ 和 $y$ 的[最大公约数（GCD）](https://en.wikipedia.org/wiki/Greatest_common_divisor)。

---

### 题解综合分析

#### 核心思路
所有可行解法的核心在于发现：当 $i \mid j$ 时，必须满足 $a_i \nmid a_j$。基于此，构造策略为：
1. 将集合 $S$ 降序排序
2. 预处理每个下标 $i$ 的质因子个数（含重复）
3. 按质因子个数确定 $a_i$ 在排序后集合中的位置

#### 算法共性
- **质因子计数**：通过质因数分解或筛法预处理每个数的质因子总数
- **贪心构造**：优先使用大元素填充质因子数少的位置
- **字典序控制**：通过质因子数的单调性保证字典序最大

---

### 精选题解（评分≥4⭐）

#### 1. 作者：Luke_li（5⭐）
**关键亮点**：
- 线性筛预处理质因子个数
- $O(n)$ 时间复杂度
- 代码简洁（仅需20行核心逻辑）
```cpp
void xxs(ll lim) {
    f[1] = 1;
    for(ll i=2; i<=lim; i++) {
        if(!pd[i]) {
            f[i] = 2; // 质数的质因子个数为1（f[i]存储实际值+1）
            prime.push_back(i);
        }
        for(ll j=0; j<prime.size() && prime[j]*i<=lim; j++) {
            pd[prime[j]*i] = 1;
            f[prime[j]*i] = f[i] + 1; // 动态规划转移
            if(i%prime[j] == 0) break;
        }
    }
}
```
**个人心得**：
- 调试时发现线性筛边界处理易错
- 通过预处理代替实时分解显著提升效率

#### 2. 作者：hgcnxn（4⭐）
**关键亮点**：
- 明确定义 $\Omega(x)$ 为质因子总数（含重复）
- 数学证明严谨，推导下界清晰
```cpp
for(int i=1; i<=n; i++)
    cout << a[m - cnt[i]] << ' '; // cnt[i]为质因子总数
```
**创新点**：
- 引入数论函数 $\Omega(x)$ 简化问题分析
- 通过最大反链长度确定可行性

#### 3. 作者：TianTianChaoFang（4⭐）
**核心贡献**：
- 最早提出质因子分解方向
- 实现 $O(n\sqrt{n})$ 的可行解法
```cpp
for(int i=2; i<N; i++) {
    int tmp = i;
    for(int j=2; j*j<=tmp; j++) { // 质因数分解
        if(tmp%j == 0) {
            ans[i] = max(ans[i], ans[i/j]+1);
            while(tmp%j == 0) tmp /= j;
        }
    }
    if(tmp > 1) ans[i] = max(ans[i], ans[i/tmp]+1);
}
```

---

### 关键技巧总结
1. **质因子计数预处理**：使用线性筛或分解法预处理每个数的质因子总数
2. **贪心位置分配**：按质因子数升序对应排序后集合的降序元素
3. **可行性剪枝**：最大质因子数超过 $m$ 时直接判无解

---

### 拓展练习
1. [P1891 疯狂的 GCD](https://www.luogu.com.cn/problem/P1891) - 构造特殊GCD数组
2. [P1495 曹冲养猪](https://www.luogu.com.cn/problem/P1495) - 质因数分解与构造
3. [P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072) - GCD与LCM的综合应用

---

### 调试经验摘录
> "线性筛写错了，调了2小时（悲" ——Luke_li  
> 总结：线性筛中 `prime[j]*i <= n` 的边界判断需特别注意，建议使用预计算最大值

> "因为把判无解注释掉而次一发罚时" ——littlebug  
> 总结：所有构造问题都应优先处理边界情况，避免因小失大

---
处理用时：54.35秒
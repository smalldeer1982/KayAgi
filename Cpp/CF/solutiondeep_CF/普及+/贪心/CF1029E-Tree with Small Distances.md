# 题目信息

# Tree with Small Distances

## 题目描述

给定一颗有根树（根节点为 $1$）。要求往树中加入一些边使得从根节点到其他节点的距离至多是 $2$。 求加入边的最小数量。(边全部都是无向的)

## 说明/提示

$2 \le n \le 2\times 10^5$

## 样例 #1

### 输入

```
7
1 2
2 3
2 4
4 5
4 6
5 7
```

### 输出

```
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
1 7
```

### 输出

```
0
```

## 样例 #3

### 输入

```
7
1 2
2 3
3 4
3 5
3 6
3 7
```

### 输出

```
1
```

# AI分析结果



# Tree with Small Distances

## 题目描述

给定一颗有根树（根节点为 $1$）。要求往树中加入一些边使得从根节点到其他节点的距离至多是 $2$。求加入边的最小数量。（边全部都是无向的）

## 说明/提示

$2 \le n \le 2\times 10^5$

---

### 题解综合分析

通过对比多篇题解，最优解法为贪心策略：处理深度最大的未覆盖节点时，连接其父节点到根节点。这种方法通过覆盖父节点的所有相邻节点实现最小化加边数量，时间复杂度可优化至 $O(n)$。

#### 关键思路
1. **贪心选择**：每次处理深度最大的未覆盖节点，连接其父节点到根节点
2. **覆盖范围最大化**：连接父节点可同时覆盖兄弟节点、祖父节点等
3. **高效遍历**：使用 BFS 生成处理顺序避免排序，时间复杂度优化至线性

---

### 精选题解（评分4星以上）

#### 1. Bring（优化版） ★★★★★
**核心亮点**：将贪心策略与BFS遍历结合，用队列代替堆实现线性时间复杂度  
**代码核心**：
```cpp
int main() {
    Rd(n), q.push({1, 0});
    // BFS遍历记录深度>2的节点
    while (!q.empty()) {
        p = q.front(); q.pop();
        if (p.d > 2) s[++sz] = p.u;
        for (int i : e[p.u]) 
            if (i != f[p.u]) 
                f[i] = p.u, q.push({i, p.d + 1});
    }
    // 逆序处理深度大的节点
    Frn_(i, sz, 1) {
        if (vs[s[i]]) continue;
        vs[f[s[i]]] = 1, ++ans;
        for (int j : e[f[s[i]]]) vs[j] = 1;
    }
    wr(ans);
}
```

#### 2. leozhang ★★★★☆
**核心亮点**：经典贪心思路清晰，使用优先队列维护深度排序  
**代码核心**：
```cpp
void bfs(int rt) { /* 计算深度和父节点 */ }
int main() {
    bfs(1);
    sort(p+1, p+n+1, cmp); // 按深度降序排序
    for (int i=1; i<=n; i++) {
        if (used[p[i].num]) continue;
        ans++;
        int u = f[p[i].num]; // 处理父节点
        used[u] = 1;
        for (int j=head[u]; j!=-1; j=edge[j].next) 
            used[edge[j].to] = 1;
    }
}
```

---

### 关键技巧总结
1. **逆向思维**：处理最远节点时优先覆盖父节点而非自身，最大化覆盖范围
2. **高效遍历**：利用 BFS 特性天然按深度分层，避免排序操作
3. **状态标记**：使用布尔数组记录已覆盖节点，避免重复处理

---

### 拓展训练
1. **P1352 没有上司的舞会**（树形DP基础）  
2. **P2014 选课**（树形依赖处理）  
3. **P1395 会议**（树的重心与距离计算）

---

### 调试心得摘录
1. **贪心正确性验证**：通过构造极端数据（长链、星型树）验证覆盖策略  
2. **边界处理**：注意深度≤2的节点自动满足条件，需预先标记  
3. **队列优化**：发现优先队列排序是瓶颈，改用BFS逆序实现线性时间

---
处理用时：53.59秒
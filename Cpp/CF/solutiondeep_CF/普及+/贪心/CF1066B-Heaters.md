# 题目信息

# Heaters

## 题目描述

## 题意描述：
$Vova$先生的家可以看作一个$n \times 1$的矩形，寒冷的冬天来了，$Vova$先生想让他的家里变得暖和起来。现在我们给你$Vova$先生家的平面图，其中$1$表示这个地方是加热炉，0表示这个地方什么也没有。所有加热器都有一个加热半径$r$,一个位于$a_i$加热器可以加热[$a_i-r+1,a_i+r-1$]的范围。现在，$Vova$先生想让他的整个家都变得暖和，一开始所有的加热器都是关闭的，请你求出$Vova$先生最少要开几个加热器才能使整个家变得暖和

## 样例 #1

### 输入

```
6 2
0 1 1 0 0 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5 3
1 0 0 0 1
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 10
0 0 0 0 0
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
10 3
0 0 1 1 0 1 0 0 0 1
```

### 输出

```
3
```

# AI分析结果



# Heaters

## 题目描述

### 题意描述：
$Vova$先生的家可以看作一个$n \times 1$的矩形，寒冷的冬天来了，$Vova$先生想让他的家里变得暖和起来。现在我们给你$Vova$先生家的平面图，其中$1$表示这个地方是加热炉，0表示这个地方什么也没有。所有加热器都有一个加热半径$r$,一个位于$a_i$的加热器可以加热[$a_i-r+1,a_i+r-1$]的范围。现在，$Vova$先生想让他的整个家都变得暖和，一开始所有的加热器都是关闭的，请你求出$Vova$先生最少要开几个加热器才能使整个家变得暖和。

---

### 综合题解分析

#### 核心算法共识：
所有题解均采用贪心策略，核心思路为：**每次尽可能选择能覆盖当前最左未加热点的最右侧加热器**。差异主要体现在预处理方式与实现细节。

#### 解决难点：
1. **跳跃式覆盖判断**：需确保选择的加热器既能覆盖当前区域，又能最大化后续覆盖范围
2. **无解情况处理**：需在遍历过程中及时判断无法覆盖的断点
3. **边界处理**：加热范围可能超出房屋左右边界

---

### 高星题解推荐

#### 1. YB_is_short（⭐⭐⭐⭐⭐）
**核心思路**：
- 预处理每个位置左侧最近加热器
- 使用指针动态维护当前覆盖终点
- 时间复杂度O(n)，空间复杂度O(n)

**关键代码解析**：
```cpp
for(int i=1;i<=n;i++)
    a[i] = a[i] ? i : a[i-1]; // 预处理左侧最近加热器位置

int x = a[r] + r - 1, tot = 1;
while(x < n && tot < MAXN)
    tot++, x = a[x + r] + r - 1; // 跳跃式推进覆盖终点
```

#### 2. 星落云川（⭐⭐⭐⭐）
**独特贡献**：
- 将问题转化为经典区间覆盖问题
- 使用结构体存储加热器影响范围
- 按右端点排序后贪心选择

**实现亮点**：
```cpp
sort(a+1, a+n+1, [](node x, node y){ 
    return x.r < y.r || (x.r == y.r && x.l > y.l); 
});

for(int loc=a[i].r; loc>=a[i].l; loc--) // 从右向左找可用加热器
    if(room[loc]) { ... }
```

#### 3. JohnJoeZhu（⭐⭐⭐）
**易理解性**：
- 显式标记已加热区域
- 双重循环直观实现跳跃覆盖
- 包含详细注释帮助理解

**关键片段**：
```cpp
for(int i=1; i<=n; i++){
    if(!vis[i]){
        int farthest = 0;
        for(int j=min(n, i+r-1); j>=max(1,i-r+1); j--)
            if(a[j]) farthest = max(farthest, j+r-1);
        // 更新加热范围...
    }
}
```

---

### 最优策略提炼

1. **贪心锚点选择**：
   - 始终选择能覆盖当前最左未加热点的最右加热器
   - 数学证明：该选择能最大化后续覆盖区间，保证局部最优解构成全局最优解

2. **预处理优化**：
   - 通过预处理数组快速获取左侧/右侧最近加热器位置
   - 示例：`a[i] = a[i] ? i : a[i-1]` 巧用递推记录最近加热器

3. **跳跃式推进**：
   - 每次更新覆盖终点为`当前加热器右边界 + r - 1`
   - 有效降低时间复杂度至O(n)

---

### 拓展训练

1. **同类题目推荐**：
   - [P1325 雷达安装](https://www.luogu.com.cn/problem/P1325)（经典区间覆盖）
   - [CF1765M Minimum LCM](https://codeforces.com/problemset/problem/1765/M)（极值贪心）
   - [P1514 引水入城](https://www.luogu.com.cn/problem/P1514)（区间覆盖+记忆化搜索）

2. **调试经验**：
   - 注意加热器自身位置的覆盖（`r=1`的特殊情况）
   - 测试用例需包含：全0、全1、间隔不可覆盖等边界情况
   - 反例：当必须使用远端加热器时，不可被近端加热器误导

---

### 关键代码实现

**YB_is_short 完整核心代码**：
```cpp
#include<cstdio>
#define N 2020
int n,r,a[N];
int main(){
    scanf("%d%d",&n,&r);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        a[i] = a[i] ? i : a[i-1]; // 关键预处理
    }
    for(int i=n+1;i<=n+r;i++) a[i]=a[i-1]; // 处理右边界
    
    int x = a[r]+r-1, tot=1;
    while(x<n && tot<N){
        tot++;
        x = a[x+r] + r-1; // 跳跃式推进
    }
    printf("%d", (a[r]&&tot!=N)?tot:-1);
}
```

---
处理用时：65.93秒
# 题目信息

# Lawnmower

## 题目描述

你有一个完全由草和杂草组成的花园。你的花园是一个 n×m的网格。每个方格有一对坐标（r，c）表示单元格位于r行c列。每个方格可能有草或杂草。例如，一个4×5的花园可能如下（空单元格表示草）：
![](https://cdn.luogu.org/upload/vjudge_pic/CF115B/593291ddc8205e086d1d9f0caee6daf221cd4d06.png)

你有一台割草机可以割除所有的杂草。最初，你站在花园的左上角。也就是说，在方格（1,1）处。在任何时刻，你都面临着某个方向——左或右。最初，你面对右。

在一个步骤中，您可以执行以下任一操作：

1. 沿您面向的方向移动一个单元格。

- 如果你面向右：从方格（r，c ）移动到方格（r，c + 1 ） 
![](https://cdn.luogu.org/upload/vjudge_pic/CF115B/f511b6ec3d5ee7e9c4711b72b12f3f163a26b1cb.png)

- 如果你面向左：从方格（r，c ）移动到方格（r，c - 1 ） 
![](https://cdn.luogu.org/upload/vjudge_pic/CF115B/817d99d95ad6751bb75b016614c67edbc38bc05f.png)

2) 向下移动一格（即从（r，c ）移动到方格（r + 1，c ）中），并将你的方向改为相反的方向.
- 如果你面向右，你将面向左
![](https://cdn.luogu.org/upload/vjudge_pic/CF115B/eaac793c8ad146f5aa886c6e03e5682029ae2d0f.png)

- 如果你面向左，你将面对右
![](https://cdn.luogu.org/upload/vjudge_pic/CF115B/0279ba704667c612234f39ddc6d6e73ff67745d6.png)

您不得离开花园。如果你和你的割草机站在含有杂草的方格中（你的方向无关紧要），杂草就会被修剪掉。此操作不算作动作。

割除所有杂草所需的最小移动次数是多少？

------------

## 样例 #1

### 输入

```
4 5
GWGGW
GGWGG
GWGGG
WGGGG
```

### 输出

```
11
```

## 样例 #2

### 输入

```
3 3
GWW
WWW
WWG
```

### 输出

```
7
```

## 样例 #3

### 输入

```
1 1
G
```

### 输出

```
0
```

# AI分析结果



### 题目内容重写
#### 题目名称：Lawnmower（割草机）

**题目描述**  
你的花园是一个由草和杂草组成的n×m网格。每个单元格用坐标(r,c)表示，其中r为行号，c为列号。初始位置在(1,1)且面朝右。每次操作可以：  
1. 沿当前方向移动一格（右→c+1，左→c-1）；  
2. 向下移动一格（r+1），并转向相反方向。  

割草机所在单元格的杂草会被自动清除。求清除所有杂草的最小移动步数。

**输入格式**  
输入n行m列的网格，'W'表示杂草，'G'表示草。  
**输出格式**  
输出最小移动次数。

---

### 题解分析与结论

#### 共同关键思路
1. **预处理每行的杂草边界**：记录每行最左(`left[i]`)和最右(`right[i]`)的杂草位置。
2. **方向控制**：奇数行向右遍历，偶数行向左遍历。
3. **换行调整策略**：从第i行换到i+1行时，根据下一行的方向调整到合适端点，避免冗余移动。
4. **曼哈顿距离累加**：通过横向和纵向移动的绝对差计算步数。
5. **空行处理**：跳过中间空行，且提前终止无杂草的末尾行。

#### 最优思路总结
- **贪心覆盖**：每行必须走到该行方向的最远杂草位置，确保完全覆盖。
- **换行预判**：根据下一行的方向，提前移动到下一行遍历的起点（如奇数行换到偶数行时，需移动到下一行最右端）。
- **末尾行优化**：记录最后一行的杂草位置，避免无效移动。

---

### 高星题解推荐

#### 1. 作者：_xcc_（★★★★★）
**关键亮点**  
- 详细处理了空行、末尾空行、中间多空行等边界情况。
- 通过条件判断确保换行时移动到下一行的正确端点。
- 代码中显式维护当前位置`(nx, ny)`，逻辑清晰。

**代码核心**  
```cpp
for(re int i=1;i<n;++i) {
    if(!e[i+1][0]) continue;
    if(i&1) { // 奇数行向右
        if(e[i+1][1]>=ny) { // 下一行右端>=当前位置
            ans += dis(nx, ny, i+1, e[i+1][1]); // 移动到下一行右端
            nx=i+1, ny=e[i+1][1];
            ans += dis(nx, ny, i+1, e[i+1][0]); // 再移动到左端
            nx=i+1, ny=e[i+1][0];
        } else { // 否则直接移动到下一行左端
            ans += dis(nx, ny, i+1, e[i+1][0]);
            nx=i+1, ny=e[i+1][0];
        }
    } else { // 偶数行向左，逻辑对称
        // ...
    }
}
```

#### 2. 作者：2simon2008（★★★★☆）
**关键亮点**  
- 维护`maxn`变量记录最后有杂草的行，减少无效遍历。
- 用`k`变量标记方向，代码简洁。
- 显式处理换行时的端点预判。

**代码核心**  
```cpp
for(int i=1;i<=maxn;i++) {
    k=1-k; // 切换方向
    if(k==1) { // 向右
        if(r[i]) cnt += r[i]-nowx; // 处理当前行
        if(r[i+1] && r[i+1]>nowx) cnt += r[i+1]-nowx; // 预判下一行
    } else { // 向左，逻辑对称
        // ...
    }
}
```

#### 3. 作者：fls233666（★★★★☆）
**关键亮点**  
- 特殊测试用例构造能力（如中间空行）。
- 用`dn`变量标记有效行，简化逻辑。
- 换行时直接计算预移动距离。

**代码核心**  
```cpp
for(int i=1;i<=dn;i++) {
    if(i&1) { // 向右
        if(r[i]) ans += r[i]-w; // 处理当前行
        if(r[i+1] && r[i+1]>w) ans += r[i+1]-w; // 预判下一行
    } else { // 向左，逻辑对称
        // ...
    }
}
```

---

### 拓展与举一反三
1. **类似题目推荐**  
   - **P1120 小木棍**：贪心+剪枝优化。  
   - **P1032 字串变换**：BFS中的状态转移与最优路径。  
   - **P3956 棋盘**：网格遍历与方向控制。  

2. **关键技巧应用**  
   - **曼哈顿距离优化**：适用于网格路径问题，快速计算移动步数。
   - **方向预判**：在棋盘类问题中，提前规划路径避免回溯。

---

### 调试心得摘录
- **来自_xcc_**：  
  > “细节题关键是一开始就要思路清晰，把情况考虑全，不能找到一个hack数据改一下，改着改着代码就成屎了。”  
  **总结**：强调全面分析边界条件的重要性，避免补丁式修复。  

- **来自fls233666**：  
  > “构造了一个小数据，帮助查错：中间空行和末尾空行。”  
  **总结**：构造极端测试用例是验证逻辑完整性的有效手段。

---
处理用时：97.22秒
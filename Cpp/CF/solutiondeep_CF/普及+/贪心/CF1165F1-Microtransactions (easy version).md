# 题目信息

# Microtransactions (easy version)

## 题目描述

有 $n$ 种物品，对于第 $i$ $(1\le i \le n)$ 个物品，你需要买 $k_i$ 个（你每次购物是在**晚上**），每个物品在非打折日买是 $2$ 块钱，在打折日买是 $1$ 块钱，每天**早上**你可以赚 $1$ 块钱，一共有 $m$ 个打折日，在第 $d_i$ 天第 $t_i$ 种物品打折，问最少需要多少天可以买完你需要的物品。注意，你每天可以买任意多数量以及种类的商品（只要你有足够的余额）。

## 样例 #1

### 输入

```
5 6
1 2 0 2 0
2 4
3 3
1 5
1 2
1 5
2 3
```

### 输出

```
8
```

## 样例 #2

### 输入

```
5 3
4 2 1 3 2
3 5
4 2
2 5
```

### 输出

```
20
```

# AI分析结果



### 题目重述
有 $n$ 种物品，第 $i$ 种需要购买 $k_i$ 个。每个物品在非打折日售价 2 元，在打折日售价 1 元。每天早上获得 1 元，已知 $m$ 个打折日（第 $d_i$ 天第 $t_i$ 种物品打折），求最少需要多少天才能买完所有物品。每天可购买任意数量商品。

---

### 题解综合分析
#### 核心算法共识
所有题解均采用 **二分答案 + 贪心验证** 的框架：
1. **二分天数**：利用天数单调性（若 x 天可行，则 x+1 天必定可行）
2. **贪心策略**：对每个商品，优先在其最后一个打折日购买，剩余数量用原价购买

#### 关键优化点
- **后序贪心**：从最后一天倒序处理，优先在更晚的打折日购买（FlyPancake、e4fsrc2e4fsrc2）
- **资源分配**：将当天赚的钱分为两部分处理：打折商品购买 + 剩余钱用于原价购买
- **剪枝技巧**：在验证函数中提前判断钱是否足够，避免无效计算

---

### 高分题解推荐
#### 1. Ak_hjc_using（⭐⭐⭐⭐⭐）
**亮点**：
- 清晰的代码结构，显式维护每个商品的最后打折日
- 独立处理打折购买和非打折购买逻辑，可读性强
```cpp
bool check(int x) {
    vector<int> G[N]; // 记录每个日期对应的打折商品
    // 步骤1：计算每个商品的最后打折日
    for (每个打折日记录) if (d[i] <= x) 
        Day[t[i]] = max(Day[t[i]], d[i]);
    // 步骤2：分类处理（有打折/无打折）
    for (每个商品) {
        if (有最后打折日) 加入对应日期的G数组;
        else 累加原价购买的总金额;
    }
    // 步骤3：正序模拟每天购买
    int cnt = 0; // 当前持有金额
    for (int i=1; i<=x; ++i) {
        cnt++; // 每日赚1元
        if (G[i]有商品) {
            优先用当前钱购买打折商品;
            若钱不足则部分转为原价购买;
        }
    }
    return 剩余钱 >= 原价购买总金额;
}
```

#### 2. FlyPancake（⭐⭐⭐⭐）
**亮点**：
- 逆向贪心策略更高效，节省计算量
- 代码简洁，变量命名有特色（nx表示剩余天数）
```cpp
bool check(int x) {
    int nx = x, nsum = sum; // nx: 剩余可操作天数
    for (从x天倒序处理) {
        处理当天的打折商品购买;
        if (当日未用完基础赚钱) 累计到原价购买资金;
    }
    return 原价购买资金 >= 剩余需要原价购买的数量*2;
}
```

#### 3. e4fsrc2e4fsrc2（⭐⭐⭐⭐）
**亮点**：
- 空间优化，使用固定大小数组代替vector
- 显式分离打折购买和原价购买阶段
```cpp
bool check(int x) {
    int res = x; // 总钱数（等于天数）
    // 阶段1：倒序处理所有打折日
    for (int i=x; i>=1; --i) {
        处理当天所有打折商品;
    }
    // 阶段2：计算剩余钱能否购买原价商品
    int left = 累计未使用的天数;
    return left >= 剩余原价购买所需金额;
}
```

---

### 关键思路总结
**二分答案核心**：  
确定问题具有单调性后，在区间 `[总数量, 2*总数量]` 进行二分，验证函数时间复杂度需控制在 O(n)。

**贪心验证要点**：
1. **最后打折日优先**：对每个商品，选择最晚出现的可行打折日
2. **倒序处理优势**：先消耗后面的天数购买打折商品，保留前面的天数用于基础赚钱
3. **剩余钱计算**：未用于打折购买的天数可以转换为原价购买资金（1天=2元购买力）

---

### 拓展应用
**同类问题特征**：
- 需要最小化天数/资源，且解具有单调性
- 验证函数可通过贪心策略高效实现

**推荐练习题**：
1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)（二分+贪心分段）
2. [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)（最小化最大页数）
3. [P3743 kotori的设备](https://www.luogu.com.cn/problem/P3743)（二分时间+充电策略）

---

### 调试经验摘录
1. **数组越界**：`FlyPancake` 强调数组要开足够大（`N=1e4+5`），避免二分时越界
2. **边界条件**：`Ak_hjc_using` 在最后一天钱不足时直接返回 false
3. **变量混淆**：多个题解显式区分 `已购买数量` 与 `剩余需要购买量`，避免逻辑错误

（总结自题解中的隐含调试经验）

---
处理用时：67.96秒
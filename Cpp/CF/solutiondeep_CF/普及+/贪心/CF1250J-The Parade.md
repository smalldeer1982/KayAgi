# 题目信息

# The Parade

## 题目描述

**题意简述**

柏林军队正在准备一场大规模的阅兵式。参加的士兵将被分成人数相等的$k$行。

当然，排兵布阵是需要一定的规则的：同一排士兵的身高相差不应超过$1$且每个士兵的身高是$1$到$n$之间的整数。

已知每名士兵身高的你必须将所有参加阅兵的士兵排成$k$排，以满足上述条件。请你编写程序计算可以参加游行的士兵的最大数量。

## 说明/提示

第一组数据，士兵可以站成这样：$[3,3,3,3],[1,2,1,1],[1,1,1,1],[3,3,3,3]$（每个方括号表示一行）；

第二组数据，所有士兵可以全部站成一排；

第三组数据，士兵可以站成$3$排，每排$33$人；

第四组数据，所有士兵可以全部站成一排；

第五组数据，所有身高为$2$和$3$的可以站成一排。

## 样例 #1

### 输入

```
5
3 4
7 1 13
1 1
100
1 3
100
2 1
1000000000000 1000000000000
4 1
10 2 11 1
```

### 输出

```
16
100
99
2000000000000
13
```

# AI分析结果



【题目中文翻译】
# 阅兵式

## 题目描述

**题意简述**

柏林军队正在准备一场大规模阅兵式。所有士兵将被分成人数相等的 $k$行。

同一排士兵的身高差不超过 1，且每个士兵的身高为 1 到 $n$ 之间的整数。

给定各身高士兵的数量，求能参加阅兵的最大士兵数量。

## 说明/提示

样例说明详见原题。

---

【题解分析与结论】
关键算法为二分答案结合贪心验证：
1. **二分每行人数**：确定最大可能的单行人数 m，使得总人数 m×k 最大
2. **贪心验证策略**：按身高升序处理，优先用前序余数组合当前身高士兵，计算可行行数

---

【优质题解】

### HyperSQ 的题解（4星）
**关键亮点**  
- 正确应用二分框架，上下界处理合理  
- 贪心逻辑清晰：处理前序余数与当前士兵的衔接  
- 提前终止优化减少计算量  

**个人心得**  
作者指出贪心策略的正确性在于"在排数相同时让余数尽可能前置"，确保后续处理空间最大化。

**核心代码**  
```cpp
bool check(ll x, int k) {
    ll prev = 0;
    int rows = 0;
    for (int i = 1; i <= n; i++) {
        ll now = a[i];
        if (prev > 0) { // 处理前序余数
            ll need = x - prev;
            if (now < need) return false;
            now -= need;
            rows++;
            prev = 0;
            if (rows >= k) return true;
        }
        rows += now / x;  // 计算完整行
        prev = now % x;   // 保留余数
        if (rows >= k) return true;
    }
    return rows >= k;
}
```

---

【最优思路总结】
1. **二分答案框架**：将最优化问题转化为判定问题
2. **余数传递机制**：确保相邻身高士兵的合理组合
3. **贪心验证顺序**：必须按身高升序处理以保证余数有效性

---

【拓展训练】
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（经典二分答案）
2. [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)（二分与条件验证）
3. [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)（分组最优化问题）

---
处理用时：209.23秒
# 题目信息

# Gardener and Tree

## 题目描述

一棵 $n$ 个结点的树。一个人做了多次操作，在每次操作中，他删除了树的所有叶结点。叶结点指的是树中至多有一个相邻节点的结点。

![](http://61.186.173.89:2019/2021/10/15/c4f2d0e1827d5.png)

如上图中所示的树。下图显示了对树进行一次操作后的结果。
![](http://61.186.173.89:2019/2021/10/15/14602247d6f15.png)

注意特殊操作的情况:

1、对空树($0$ 个顶点)进行操作时不会改变它;

2、对于仅有一个顶点的树进行操作时会移除这个顶点(这个顶点被当作一个叶子);

3、对于仅有两个顶点的树进行操作时将删除两个顶点(两个顶点都被当作叶子处理)。

求 $k$ 次操作后还剩下多少个顶点?

## 样例 #1

### 输入

```
6

14 1
1 2
2 3
2 4
4 5
4 6
2 7
7 8
8 9
8 10
3 11
3 12
1 13
13 14

2 200000
1 2

3 2
1 2
2 3

5 1
5 1
3 2
2 1
5 4

6 2
5 1
2 5
5 6
4 2
3 4

7 1
4 3
5 1
1 3
6 1
1 7
2 1```

### 输出

```
7
0
0
3
1
2```

# AI分析结果



### 题目内容重写
# 园丁与树

## 题目描述

给定一棵包含 $n$ 个结点的树。进行 $k$ 次操作，每次操作删除当前树的所有叶结点（定义：至多有一个相邻节点的结点）。特殊规则如下：

1. 空树操作后不变
2. 单节点树操作后变为空树
3. 双节点树操作后变为空树

求 $k$ 次操作后剩余的结点数。

![](http://61.186.173.89:2019/2021/10/15/c4f2d0e1827d5.png)
（图示展示了操作前后的树变化）

---

### 题解综合分析

#### 关键思路总结
所有题解均围绕**层级删除特性**展开，核心解法可分为两类：
1. **拓扑排序法**（主流解法，9/12篇采用）
   - 维护每个结点的删除轮次（rnk/dep/cnt）
   - 初始将叶子结点（度≤1）入队
   - BFS式扩展，计算相邻结点的删除轮次
   - 最终统计 rnk > k 的结点数
2. **直径中点法**（3篇采用）
   - 通过两次BFS求直径端点
   - 确定直径中点作为根进行DP
   - 计算子树最大深度作为删除轮次

#### 优劣对比
| 方法         | 时间复杂度 | 实现难度 | 适用性       |
|--------------|------------|----------|--------------|
| 拓扑排序     | O(n)       | 易       | 所有树结构   |
| 直径中点+DP  | O(n)       | 较高     | 需处理特例   |

---

### 优质题解推荐

#### 1. 智子（⭐⭐⭐⭐⭐）
**核心亮点**：
- 最简洁的拓扑排序实现
- 完美处理所有边界条件
- 无冗余代码，可读性极佳

**关键代码**：
```cpp
void toposort() {
    queue<int> q;
    // 初始化叶子结点
    for(int i=1;i<=n;i++) if(deg[i]==1) q.push(i), rnk[i]=1;
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) 
            if(--deg[v] == 1) // 更新相邻结点
                rnk[v] = rnk[u]+1, q.push(v);
    }
}
```

#### 2. Alkaid_Star（⭐⭐⭐⭐）
**核心亮点**：
- 显式处理单结点特例
- 使用双队列避免层级混淆
- 详细注释提升可读性

**调试心得**：
> "特判n=1的情况是因为初始入队条件deg[i]==1不包含单结点，显式处理确保正确性"

#### 3. cppcppcpp3（⭐⭐⭐⭐）
**核心亮点**：
- 使用位标记优化空间
- 合并初始条件处理（deg≤1）
- 代码模块化程度高

---

### 同类题目推荐
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)  
   （树形DP，层级关系处理）
2. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)  
   （拓扑排序找环）
3. [P2071 座位安排](https://www.luogu.com.cn/problem/P2071)  
   （拓扑排序应用）

---
处理用时：56.78秒
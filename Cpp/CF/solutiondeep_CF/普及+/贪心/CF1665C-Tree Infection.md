# 题目信息

# Tree Infection

## 题目描述

### 题意描述
一个树是一个无环连通图。一个有根树有一个被称作“根结点”的结点。对于任意一个非根结点 $v$ ，其父结点是从根结点到结点 $v$ 最短路径上的前一个结点。结点 $v$ 的子结点包括所有以 $v$ 父结点为 $v$ 的结点。

给定一个有 $n$ 个结点的有根树。结点 $1$ 即为根结点。一开始，该树上所有结点均是“健康”的。

每一秒你会进行两次操作——先是传播操作，然后是注射操作，定义如下。

- 传播操作：对于每个结点 $v$ ，若该结点至少有一个子结点被“感染”，则你可以“感染”顶点 $v$ 任意一个其他的子结点。
- 注射：你可以选择任意一个“健康”的结点并使它变为“感染”状态。

这程每秒会重复一次知道整个树的结点都处于“感染”状态。你需要找到使整个树被“感染”的最短时间（秒数）。

## 说明/提示

- $ 1 \le t \le 10^4 $
- $ 2 \le n \le 2 \times 10^5 $
- $ 1 \le p_i \le n $
- $ \sum \limits_{i=1} ^t n_i \le 2 \times 10^5 $

## 样例 #1

### 输入

```
5
7
1 1 1 2 2 4
5
5 5 1 4
2
1
3
3 1
6
1 1 1 1 1```

### 输出

```
4
4
2
3
4```

# AI分析结果



### 题目重述
题目已为中文，无需翻译。

---

### 题解综合分析
各题解均围绕节点子节点数统计与贪心策略展开，核心思路为：  
1. 预处理所有节点的子节点数（含根节点）  
2. 对子节点数排序，优先处理高密度分支  
3. 使用优先队列模拟感染过程，动态调整处理顺序

---

### 精选题解（评分≥4星）

#### 1. 作者：tzyt（★★★★☆）
**关键亮点**：  
- 引入虚拟根节点统一处理逻辑  
- 精确计算初始注射轮次后转为堆维护  
- 用传播计数器优化剩余感染时间  

**核心代码**：
```cpp
priority_queue<int> pq;
for (int i = fir_n_zero; i <= n; i++) {
    pq.push(siz[i] - (i - fir_n_zero) - 1);
}
int tm_used = n - fir_n_zero + 1;
int spreaded = 0;
while(pq.top() > spreaded){
    spreaded++;
    int tp = pq.top();
    pq.pop();
    pq.push(tp - 1);
    tm_used++;
}
```

#### 2. 作者：听取MLE声一片（★★★★☆）
**关键亮点**：  
- 通过错误案例揭示传统贪心的缺陷  
- 用堆维护剩余待感染子节点数  
- 引入动态计数器平衡传播与注射  

**调试心得**：  
> "直接按子节点数排序处理会WA，必须用堆动态调整顺序。例如处理1000和999子节点的案例时，同时处理比顺序处理快。"

#### 3. 作者：jiangtaizhe001（★★★★☆）
**关键亮点**：  
- 极简代码风格实现相同逻辑  
- 使用双优先队列优化空间  
- 引入懒惰标记减少无效操作  

**核心代码**：
```cpp
priority_queue<int> a,b;
for(int i=1;i<=n;i++) if(son[i]) a.push(son[i]);
a.push(1); // 根节点处理
while(b.top()>ans){
    x=b.top(); b.pop();
    b.push(x-1); ans++; 
}
```

---

### 最优思路总结
1. **子节点密度优先**：将子节点数排序后，确保每个分支至少有一个初始感染源  
2. **堆动态调整**：维护剩余待感染节点数，每秒选择当前最大分支进行注射  
3. **传播-注射并行**：通过计数器同步跟踪自然传播进度，减少重复计算  

---

### 拓展训练
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 优先队列贪心  
2. [CF1526C2 Potions](https://www.luogu.com.cn/problem/CF1526C2) - 动态调整的堆策略  
3. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916) - 反向处理与传播机制

---
处理用时：48.21秒
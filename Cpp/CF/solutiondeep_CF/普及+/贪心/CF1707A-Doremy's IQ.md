# 题目信息

# Doremy's IQ

## 题目描述

哆来咪·苏伊特参加了 $n$ 场比赛。 比赛 $i$ 只能在第 $i$ 天进行。比赛 $i$ 的难度为 $a_i$。最初，哆来咪的 IQ 为 $q$ 。 在第 $i$ 天，哆来咪将选择是否参加比赛 i。只有当她当前的 IQ 大于 $0$ 时，她才能参加比赛。

如果哆来咪选择在第 $i$ 天参加比赛 $i$，则会发生以下情况：
- 如果 $a_i>q$，哆来咪会觉得自己不够聪明，所以 $q$ 将会减 $1$；
- 否则，什么都不会改变。

如果她选择不参加比赛，一切都不会改变。哆来咪想参加尽可能多的比赛。请给哆来咪一个解决方案。

## 说明/提示

在第一个测试用例中，哆来咪参加了唯一的比赛。她的 IQ 没有下降。

在第二个测试用例中，哆来咪参加了两个比赛。在参加比赛 $2$ 后，她的 IQ 下降了 $1$。

在第三个测试用例中，哆来咪参加了比赛 $1$ 和比赛 $2$。她的 IQ 在参加比赛 $2$ 后降至 $0$，因此她无法参加比赛 $3$。

## 样例 #1

### 输入

```
5
1 1
1
2 1
1 2
3 1
1 2 1
4 2
1 4 3 1
5 2
5 1 2 4 3```

### 输出

```
1
11
110
1110
01111```

# AI分析结果



# 题目内容
## Doremy的IQ

### 题目描述

哆来咪·苏伊特参加了 $n$ 场比赛。比赛 $i$ 只能在第 $i$ 天进行，其难度为 $a_i$。初始时哆来咪的 IQ 为 $q$。每天她可以选择是否参赛（需 IQ > 0 才能参赛）：

- 若参赛且 $a_i > q$，则 IQ 减 1
- 否则无变化

求最多能参加的比赛数量，并输出参赛方案。

### 样例与说明
（样例输入输出见原题）

---

# 题解综合分析

### 关键思路总结
最优解法采用**倒序贪心**策略：从最后一天往前处理，优先消耗 IQ 在难度较高的后期比赛。当累计消耗的 IQ 达到初始值 q 时停止，此时前面所有难度≤q 的比赛均可参加。该策略巧妙避免了正序处理的后效性问题，时间复杂度为 O(n)。

### 高星题解推荐

#### 1. 作者：tanghairong（5星）
**亮点**：逆向思维转换，将扣 IQ 重构为加 IQ 模型  
**核心思路**：
- 逆向扫描，维护当前已用智商值 num
- 当遇到 $a_i > num$ 时，若未达上限则 num++
- 确定临界点后，前面比赛按难度筛选
```cpp
for(int i=n; i>0; i--){
    if(a[i]>num) num++;
    if(num==q) {pos=i; break;}
}
// 前pos-1天只选a[i]<=q的，pos之后全选
```

#### 2. 作者：Jeremiahy（5星）
**亮点**：代码简洁，变量命名清晰  
**实现技巧**：
- 单次循环完成逆向扫描与标记
- 使用统一数组记录参赛状态
```cpp
for(num=0, r=n; r>=1 && num<q; v[r]=1, r--)
    if(a[r]>num) num++;
for(int i=r; i>=1; i--)
    if(a[i]<=q) v[i]=1;
```

#### 3. 作者：wzy2021（4.5星）
**亮点**：引入代价概念辅助理解  
**算法要点**：
- 后i场全选所需代价为i场中$a_j>k$的数量（k为当前消耗）
- 当总代价等于q时即为最优分割点
```cpp
while(now>=1 && t<q){
    if(a[now]>t) t++;
    vis[now]=1; now--;
}
```

---

# 拓展与心得
### 同类题型套路
- **后效性处理**：当当前决策影响后续状态时，尝试逆向思考
- **资源分配优化**：将有限资源（此处为IQ）优先分配给收益最大的操作

### 推荐练习
1. P1803 凌乱的yyy（线段覆盖，贪心）
2. P5019 铺设道路（差值贪心）
3. P1090 合并果子（堆贪心）

### 调试心得摘录
> "正向考虑后效性难处理，逆向扫描豁然开朗" —— 多数题解作者提到倒序处理是突破关键  
> "将扣智商重构为加智商模型，极大简化判断逻辑" —— tanghairong 的模型转换实现降维打击

---

**核心代码实现（以Jeremiahy解法为例）**
```cpp
int main() {
    while(T--) {
        // 输入略
        memset(v, 0, sizeof(v));
        for(num=0, r=n; r>=1 && num<q; v[r]=1, r--)
            if(a[r]>num) num++;
        for(int i=r; i>=1; i--)
            if(a[i]<=q) v[i]=1;
        // 输出略
    }
}
```

---
处理用时：61.53秒
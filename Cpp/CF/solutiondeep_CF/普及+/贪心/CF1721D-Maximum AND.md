# 题目信息

# Maximum AND

## 题目描述

给出两个长度为 $n$ 的数组 $a,b$ ，规定 $f(a,b)$ 表示以下操作：

1. 创建一个长度为 $n$ 的 $c$ 数组，满足 $c_i=a_i \oplus b_i$ （此处的 $\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)）。
2. 则 $f(a, b) = c_1\space\& c_2\space\& \cdots \& c_n$。

你可以将 $b$ 数组进行任意的排列（包括保留原始情况），试求出最大的 $f(a,b)$ 。

## 样例 #1

### 输入

```
3
5
1 0 0 3 3
2 3 2 1 0
3
1 1 1
0 0 3
8
0 1 2 3 4 5 6 7
7 6 5 4 3 2 1 0```

### 输出

```
2
0
7```

# AI分析结果



### 题目中文重写

#### 题目描述

给定两个长度为 $n$ 的数组 $a$ 和 $b$，定义 $f(a,b)$ 为以下操作的结果：

1. 创建数组 $c$，其中 $c_i = a_i \oplus b_i$（$\oplus$ 表示按位异或）。
2. $f(a,b)$ 为 $c_1 \& c_2 \& \cdots \& c_n$（按位与）。

你可以任意排列 $b$ 数组，求 $f(a,b)$ 的最大值。

#### 输入样例

```
3
5
1 0 0 3 3
2 3 2 1 0
3
1 1 1
0 0 3
8
0 1 2 3 4 5 6 7
7 6 5 4 3 2 1 0
```

#### 输出样例

```
2
0
7
```

---

### 题解分析与结论

#### 关键思路总结
1. **按位贪心**：从高位到低位依次判断每位能否置为 1，优先保证高位贡献。
2. **条件验证**：某位能置为 1 当且仅当所有 $a_i$ 和 $b_i$ 在该位异或为 1，即 $a$ 中该位 1 的数量等于 $b$ 中该位 0 的数量。
3. **集合分裂/排序优化**：通过排序或分组维护当前位的匹配关系，确保后续位的处理不受影响。

#### 高分题解推荐

1. **jrxxx的题解（5星）**
   - **亮点**：通过排序策略简化匹配验证，代码简洁高效，时间复杂度 $O(n \log n \cdot 30)$。
   - **核心代码**：
     ```cpp
     sort(a+1,a+n+1); sort(b+1,b+n+1,greater<int>());
     for(int i=30;~i;--i){
         // 检查当前位是否所有位置异或为1
         for(j=1;j<=n;++j) if((a[j]&(1<<i)) == (b[j]&(1<<i))) break;
         if(j>n) ans|=1<<i;
         else {
             // 推平当前位并重新排序
             for(j=1;j<=n;++j) a[j]|=(1<<i),b[j]|=(1<<i);
             sort(a+1,a+n+1); sort(b+1,b+n+1,greater<int>());
         }
     }
     ```
   - **实现思想**：通过排序使 $a$ 升序、$b$ 降序，高位 0/1 分布对齐。若当前位可置 1，则保留；否则强制置 1 后重新排序消除影响。

2. **Ginger_he的题解（4星）**
   - **亮点**：利用 mask 结合排序快速验证匹配条件，思路直观。
   - **核心代码**：
     ```cpp
     bool check(int x){
         vector<int> u,v;
         for(int i=1;i<=n;++i) u.push_back(a[i]&x), v.push_back((b[i]&x)^x);
         sort(u.begin(),u.end()); sort(v.begin(),v.end());
         return u==v;
     }
     // 主循环中逐位判断
     for(int i=29;i>=0;--i) if(check(ans|(1<<i))) ans|=(1<<i);
     ```
   - **实现思想**：对每个候选答案位构造掩码，检查排序后的 $a$ 和取反后的 $b$ 是否匹配。

3. **苏联小渣的题解（4星）**
   - **亮点**：分治分裂集合维护匹配关系，严格 $O(n \log a)$。
   - **核心思想**：将当前位满足条件的数分裂到子集合中递归处理，确保后续位仅需处理子集合内的匹配。

---

### 最优技巧总结
- **排序对齐策略**：通过将 $a$ 升序、$b$ 降序排序，使得高位优先匹配，简化异或条件验证。
- **掩码动态验证**：结合贪心过程中已确定的位构造掩码，快速验证当前位的可行性。
- **集合分裂分治**：维护多个子集合独立处理，避免全局重排带来的复杂度。

---

### 拓展与相似题目
1. **按位贪心+匹配**：[CF1659D](https://codeforces.com/problemset/problem/1659/D)（二进制构造）
2. **异或性质应用**：[洛谷 P2114](https://www.luogu.com.cn/problem/P2114)（位运算最大值）
3. **分治集合处理**：[CF1592D](https://codeforces.com/problemset/problem/1592/D)（分治定位极值）

---
处理用时：68.64秒
# 题目信息

# Job Interview

## 题目描述

### 题意翻译
Monocarp 要开设一家 IT 公司。他想招聘 $n$ 名程序员和 $m$ 名测试员。

共有 $n+m+1$ 名候选人，第 $i$ 个人的到达时间为 $i$。

第 $i$ 名候选人的编程技能为 $a_i$ ，测试技能为 $b_i$ （保证 $a_i\not=b_i$）。

公司的能力定义为所有程序员的编程能力与所有测试员的测试能力之和。

形式化的讲，若招聘的程序员集合为 $s$，测试员集合为 $t$，则公司的能力为 $\sum\limits_{i\in s}a_i+\sum\limits_{j\in t}b_j$。

Monocarp 会按照候选人到达的时间顺序为他们分配工作。

对于第 $i$ 个人，招聘规则为：
1. 尝试将 $i$ 分配到最适合 $i$ 的职位，也就是若 $a_i>b_i$，则让他成为程序员，反之同理。
2. 如果该职位已经招满了，就把 $i$ 分配到另一职位上。

你的任务是，对于每个 $i$，输出若这个人不来的情况下，公司的能力值。

## 样例 #1

### 输入

```
4
1 0
2 1
1 2
0 2
4 5 5
5 4 1
1 2
2 1 5 4
5 2 3 1
3 1
4 3 3 4 1
5 5 4 5 2```

### 输出

```
1 2 
5 6 9 
8 11 11 12 
13 13 13 12 15```

# AI分析结果



# Job Interview

## 题目描述

Monocarp 要开设一家 IT 公司，需要招聘 $n$ 名程序员和 $m$ 名测试员。共有 $n+m+1$ 名候选人，第 $i$ 个人到达时间为 $i$。每位候选人的编程技能为 $a_i$，测试技能为 $b_i$（保证 $a_i \neq b_i$）。

招聘规则：
1. 优先分配到更合适的岗位（$a_i > b_i$ 则程序员，否则测试员）
2. 若目标岗位已满，则调剂到另一岗位

要求：对于每个候选人 $i$，输出其不参与时公司的能力值（所有程序员的编程能力之和 + 所有测试员的测试能力之和）。

---

### 精选题解分析

#### 1. Louis_lxy（★★★★☆）
**核心思路**：动态规划追踪岗位调剂链
- 预计算初始状态的总能力值
- 逆向DP记录每个位置不选时的补偿值
- 关键变量`f[i]`表示不选i时后续调整带来的增益
- 时间复杂度O(n)，空间O(n)

```cpp
// 逆向DP计算补偿值
ca = cb = n+m+1;
for(int i = n+m; i; --i) {
    if(id[i]) // 原程序员岗位
        f[i] = f[ca] + (ca<=n+m ? a[ca]-b[ca] : a[ca]); 
    else      // 原测试员岗位
        f[i] = f[cb] + (cb<=n+m ? b[cb]-a[cb] : b[cb]);
    // 更新最近的强制调剂点
    if(...) ca = i; 
}
```

#### 2. 2huk（★★★★☆）
**核心思路**：二分查找满员临界点
- 二分确定两个岗位的满员位置
- 分三段计算：自由选择段、强制分配段、最后一人替补
- 利用前缀和快速计算各区间总和
- 时间复杂度O(n log n)

```cpp
// 二分查找程序员满员位置
int l=0, r=n+m+1;
while(l <= r) {
    int mid = (l+r)/2;
    int p = sum[mid] - (mid>=i && a[i]>b[i]);
    if(p >= n) r = mid-1; 
    else l = mid+1;
}
// 分三段计算总能力值
ans = pre[pos] + (Q满员 ? A后缀 : B后缀);
```

#### 3. Hoks（★★★★☆）
**核心思路**：递推替代递归的补偿链
- 正向模拟初始分配
- 逆向维护替代候选人的增益
- 利用两个指针追踪最近的替代机会
- 时间复杂度O(n)，空间O(n)

```cpp
int f1 = n+m+1, f2 = n+m+1;
for(int i = n+m; i >=1; --i) {
    if(c[i] == 1) 
        d[i] = d[f1] + (f1<=n+m ? a[f1]-b[f1] : a[f1]);
    else 
        d[i] = d[f2] + (f2<=n+m ? b[f2]-a[f2] : b[f2]);
    // 更新最近的替代候选人
    if(c[i]==1 && b[i]>a[i]) f2 = i;
    if(c[i]==2 && a[i]>b[i]) f1 = i;
}
```

---

### 最优思路总结
**关键技巧**：
1. **岗位满员临界点**：通过模拟/二分确定两个岗位的满员时间点
2. **补偿链传递**：利用DP/递推计算排除某候选人时的连锁调整效应
3. **逆向处理**：从后往前维护替代候选人的增益值
4. **前缀和优化**：快速计算分段区间的能力值总和

**同类型扩展**：
- 分段决策问题（如[CF1526C2](https://www.luogu.com.cn/problem/CF1526C2)）
- 动态规划处理连锁反应（如[P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)）
- 二分法确定状态分界（如[P4344 脑力治疗](https://www.luogu.com.cn/problem/P4344)）

---

### 推荐练习
1. [P2512 糖果传递](https://www.luogu.com.cn/problem/P2512) - 环形分配问题
2. [P4095 [HEOI2013] Eden 的新背包问题](https://www.luogu.com.cn/problem/P4095) - 排除元素的背包问题
3. [P4170 棋盘覆盖](https://www.luogu.com.cn/problem/P4170) - 分治策略与动态规划

---
处理用时：54.38秒
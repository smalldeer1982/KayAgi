# 题目信息

# Ordered Permutations

## 题目描述

给定一个长度为 $n$ 的整数排列 $p_1, p_2, \ldots, p_n$，其中包含从 $1$ 到 $n$ 的所有整数。我们定义一个如下的和式：

$$S(p) = \sum_{1 \le l \le r \le n} \min(p_l, p_{l+1}, \ldots, p_r)$$

我们希望找出所有能使 $S(p)$ 最大的排列，并从中按字典序选择第 $k$ 个。如果这样的排列数量少于 $k$，则输出 -1。

**解释说明：**
- 长度为 $n$ 的排列是一个由 $n$ 个不同的整数组成的序列，这些整数来源于 $1$ 到 $n$ 的一组数字。例如，$[2, 3, 1, 5, 4]$ 是一个符合要求的排列，而 $[1, 2, 2]$ 因为有重复数字 $2$ 而不符合，$[1, 3, 4]$ 也不符合要求，因为它包含了不在 $1$ 到 $n$ 范围内的数 $4$（$n = 3$）。
- 示例计算： 
  - 对于排列 $[1, 2, 3]$，$S(p)$ 计算为 $\min(1) + \min(1, 2) + \min(1, 2, 3) + \min(2) + \min(2, 3) + \min(3) = 1 + 1 + 1 + 2 + 2 + 3 = 10$。
  - 对于排列 $[2, 4, 1, 3]$，$S(p)$ 计算为 $\min(2) + \min(2, 4) + \min(2, 4, 1) + \min(2, 4, 1, 3) + \min(4) + \min(4, 1) + \min(4, 1, 3) + \min(1) + \min(1, 3) + \min(3) = 2 + 2 + 1 + 1 + 4 + 1 + 1 + 1 + 1 + 3 = 17$。
- 字典序小于：数组 $a$ 比数组 $b$ 在字典序上小的条件是：
  1. $a$ 是 $b$ 的一个前缀，且 $a \ne b$；
  2. 或者在第一个不同的位置上，$a$ 的元素小于 $b$ 的对应元素。

## 说明/提示

以下是所有长度为 3 的排列及其对应的 $S(p)$ 值（按字典序排序）：

| 排列 | $S(p)$ 的值 |
|------|-------------|
| $[1, 2, 3]$ | $10$ |
| $[1, 3, 2]$ | $10$ |
| $[2, 1, 3]$ | $9$ |
| $[2, 3, 1]$ | $10$ |
| $[3, 1, 2]$ | $9$ |
| $[3, 2, 1]$ | $10$ |

在第一个测试用例中，需输出长度为 3 的第 2 个符合条件的排列，看表格可以知道是 $[1, 3, 2]$。

在第二个测试用例中，需输出长度为 3 的第 3 个符合条件的排列，对应的是 $[2, 3, 1]$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
6
3 2
3 3
4 11
4 6
6 39
7 34```

### 输出

```
1 3 2 
2 3 1 
-1
2 4 3 1 
-1
2 3 4 5 7 6 1```

# AI分析结果



# Ordered Permutations 题目中文翻译

## 题目描述

给定一个长度为 $n$ 的整数排列 $p_1, p_2, \ldots, p_n$（包含从 $1$ 到 $n$ 的所有整数）。定义如下的和式：

$$S(p) = \sum_{1 \le l \le r \le n} \min(p_l, p_{l+1}, \ldots, p_r)$$

要求找出所有能使 $S(p)$ 最大的排列，并从中按字典序选择第 $k$ 个。若这样的排列数量不足 $k$，输出 -1。

**关键说明：**
- 排列的字典序比较规则：首个不同位置元素较小的排列更小
- 最大排列数总是 $2^{n-1}$，若 $k>2^{n-1}$ 直接返回 -1

---

# 题解综合分析

## 算法核心思路
所有最优排列的构造方式遵循以下规则：
1. **贡献最大化**：每个数 $i$ 必须放置在当前剩余位置的最左或最右端，以确保其贡献区间最大
2. **二进制决策**：将 $k-1$ 转换为二进制数，每一位决定当前数放置位置（0=左端，1=右端）
3. **溢出处理**：当 $n>60$ 时 $2^{n-1}$ 超出 long long 范围，此时只需判断 $k≤2^{60}$

## 高质量题解推荐

### 1. 作者：ohjun（⭐⭐⭐⭐⭐）
**核心亮点：**
- 引入临界值 `maxv = log(1e12)/log(2)` 处理大数溢出
- 简洁的位置指针操作（l/r）
- 时间复杂度 O(n) 且无递归调用

**关键代码：**
```cpp
int l=1, r=n;
for(int i=1; i<n; i++){
    if(n-1-i > maxv || k <= (1LL<<(n-i-1))){
        ans[l++] = i;
    } else {
        k -= (1LL << (n-i-1));
        ans[r--] = i;
    }
}
ans[l] = n;
```

### 2. 作者：MrPython（⭐⭐⭐⭐）
**核心亮点：**
- 使用双端队列动态构建排列
- 将 k 转换为二进制位直接操作
- 代码简洁易懂（仅需 25 行）

**关键代码：**
```cpp
deque<ui> ans{(ui)n};
for(ui i=n-1; i>0; --i){
    if(k & 1) ans.emplace_back(i);
    else ans.emplace_front(i);
    k >>= 1;
}
```

### 3. 作者：naroto2022（⭐⭐⭐⭐）
**核心亮点：**
- 详细推导贡献公式 $i×(n-i+1)$
- 处理 $n>40$ 的特殊情况避免溢出
- 左右指针交替填充的直观实现

---

## 关键优化技巧
1. **位运算加速**：将字典序问题转化为二进制决策问题
2. **早停机制**：当剩余可选位置数超过 $log2(k_{max})$ 时，后续元素直接放左端
3. **空间复用**：直接在结果数组上操作，无需额外数据结构

## 同类题目推荐
1. [P1704 寻找最优美做题曲线](https://www.luogu.com.cn/problem/P1704) - 贪心构造特定排列
2. [P3014 牛仔比赛](https://www.luogu.com.cn/problem/P3014) - 字典序第 K 大排列生成
3. [P1338 末日的传说](https://www.luogu.com.cn/problem/P1338) - 逆序对控制的排列构造

## 调试经验摘录
- **Him_shu**：通过打表发现排列的镜像特性（如 n=5 时 5 号排列是 4 号的后缀翻转）
- **lfxxx**：注意 $k$ 需要减一转换为 0-based 索引
- **wfc284**：每个数放置后要更新剩余的可能性空间（类似分治思想）

---
处理用时：52.75秒
# 题目信息

# Sums on Segments

## 题目描述

### 题目内容
给定一个长度为 $n$ 的数组 $a$，其中除了至多一个 $i \in [0,n)$ 满足 $|a_i| \neq 1$ 以外，其余全部项均满足 $|a_i|=1$。

求该数组中全部可能的子数组和，以升序输出。子数组是原数组中一段连续的数组。

## 样例 #1

### 输入

```
5
5
1 -1 10 1 1
5
-1 -1 -1 -1 -1
2
-1 2
2
7 1
3
1 4 -1```

### 输出

```
8
-1 0 1 2 9 10 11 12 
6
-5 -4 -3 -2 -1 0 
4
-1 0 1 2 
4
0 1 7 8 
6
-1 0 1 3 4 5```

# AI分析结果



### 题目翻译

#### 题目名称：区间和

##### 题目描述  
给定一个长度为 $n$ 的数组 $a$，其中至多有一个元素的绝对值不等于 $1$，其余元素的绝对值均为 $1$。  
求该数组中所有可能子数组的和，并按升序输出。子数组定义为原数组中一段连续的元素序列。

---

### 题解对比与结论

#### 关键思路总结
1. **分治思想**：将数组按特殊元素分为左、右两部分和包含特殊元素的部分。
2. **连续值域性质**：对于仅含 ±1 的区间，其子数组和的最小值和最大值之间的所有整数均可被覆盖。
3. **前后缀极值合并**：包含特殊元素的区间和范围由左后缀和右前缀的极值决定，结合特殊值计算总范围。
4. **集合去重与排序**：利用集合存储所有可能和，自动处理去重和排序。

#### 最优题解推荐

1. **Eous 的题解（★★★★★）**  
   **核心亮点**：  
   - 分治思路清晰，将问题拆分为三个独立部分处理。  
   - 正确利用最大/最小子段和的性质生成连续值域。  
   - 通过前后缀极值合并处理包含特殊元素的情况。  
   **代码片段**：  
   ```cpp
   // 处理左右区间极值
   for (int i = 1; i <= pos - 1; i++) {
       dp1[i] = max(dp1[i - 1] + a[i], 0ll);
       max1 = max(max1, dp1[i]);
       dp2[i] = min(dp2[i - 1] + a[i], 0ll);
       min1 = min(min1, dp2[i]);
   }
   // 处理包含特殊值的区间
   for (int i = (min1 + min2); i <= (max1 + max2); i++)
       ans.insert(val + i);
   ```

2. **HetmesAskalana 的题解（★★★★）**  
   **核心亮点**：  
   - 使用 STL 集合自动去重排序。  
   - 将处理逻辑模块化，增强可读性。  
   **代码片段**：  
   ```cpp
   // 合并值域到集合
   void merge(set<int>& R, array<int, 2> range) {
       auto [l, r] = range;
       for (int i = min(l, r); i <= max(l, r); ++i) R.insert(i);
   }
   ```

---

### 拓展与总结

#### 关键技巧
- **极值维护**：通过动态规划维护最大/最小子段和，确保值域连续性。
- **分治优化**：将复杂问题分解为独立子问题，降低实现难度。
- **集合操作**：利用 `set` 的特性简化去重和排序步骤。

#### 类似题目推荐
1. [洛谷 P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [洛谷 P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)  
3. [洛谷 P3402 最长公共子序列（前缀和优化）](https://www.luogu.com.cn/problem/P3402)  

#### 调试心得
- **边界处理**：需特别注意特殊元素位于数组首尾时的极值计算。
- **空子数组**：部分题解通过显式插入 0 处理空子数组，确保符合题意。
- **极值初始化**：极值维护时的初始值设置需结合问题特性（如允许空区间）。

---
处理用时：165.64秒
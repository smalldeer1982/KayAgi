# 题目信息

# Memory and De-Evolution

## 题目描述

Memory 对物体，尤其是三角形的变化感兴趣。 他有一个边长为 $x$ 的等边三角形，他希望通过一些操作获得一个边长为 $y$ 的等边三角形。

他一次可以修改当前三角形一边的长度，修改后也应为合法的三角形。每次修改后，每一边的长度都应该是整数。

Memory 要获得边长 $y$ 的等边三角形，所需的最小修改次数是多少？

## 样例 #1

### 输入

```
6 3
```

### 输出

```
4
```

## 样例 #2

### 输入

```
8 5
```

### 输出

```
3
```

## 样例 #3

### 输入

```
22 4
```

### 输出

```
6
```

# AI分析结果



### 题目内容重写
# Memory 与退化

## 题目描述

Memory 对物体的变化感兴趣，尤其是三角形。他有一个边长为 $x$ 的等边三角形，希望通过若干次操作得到一个边长为 $y$ 的等边三角形。

每次操作可以修改其中一条边的长度，修改后必须仍能构成合法三角形，且每条边长度必须为整数。求最少的修改次数。

---

### 题解分析与结论
各题解均采用逆向思维，从目标三角形（边长为 $y$）倒推至初始三角形（边长为 $x$）。关键策略是每次将最小的边尽可能增大到另两边之和减1（确保三角形合法性），若该值超过 $x$ 则直接设为 $x$，以此最小化操作次数。

#### 最优思路总结
1. **逆向贪心**：从目标状态倒推，每次操作能最大幅度增加边长。
2. **极限增长**：每次修改最小边为另两边之和减1或 $x$，保证每次操作的有效性。
3. **排序优化**：通过排序快速定位当前最小边，简化逻辑。

---

### 高分题解推荐

#### 题解1：吴思诚（5星）
**关键亮点**：代码简洁高效，循环中直接排序处理最小边。
```cpp
int x,y,t,a[4],m,i;
int main(){
    scanf("%d%d",&x,&y);
    a[1]=a[3]=a[2]=y;
    while(a[1]<x||a[2]<x||a[3]<x){
        t++;
        sort(a+1,a+4);
        a[1]=a[2]+a[3]-1;
    }
    printf("%d",t);
}
```
**核心思想**：每次排序后修改最小边为另两边之和减1，直到所有边 ≥$x$。

#### 题解2：sinsop90（4星）
**关键亮点**：分情况处理，显式判断是否需要设为 $x$。
```cpp
while(!(a[1]==n && a[2]==n && a[3]==n)){
    ans++;
    sort(a+1,a+1+3);
    if(a[2]+a[3]-1>n) a[1] = n;
    else a[1] = a[2]+a[3]-1;
}
```
**核心思想**：当另两边和减1超过 $x$ 时直接设为 $x$，否则设为和减1。

#### 题解3：Fat_Fish（4星）
**关键亮点**：显式维护最小值，代码可读性强。
```cpp
int tar=min(a,min(b,c));
if(a==tar) a=min(x,b+c-1);
else if(b==tar) b=min(x,a+c-1);
else c=min(x,a+b-1);
```
**核心思想**：手动寻找最小值并更新，避免排序操作。

---

### 关键技巧与拓展
1. **逆向思维**：适用于目标状态明确且操作可逆的问题（如 CF1110E）。
2. **贪心边界处理**：通过数学推导确定修改值的上限（两边和减1）。
3. **同类题目推荐**：
   - CF1359D：逆向分析极值
   - 洛谷 P1090：合并果子（贪心）
   - 洛谷 P1220：关路灯（逆向决策）

---

### 题解中的个人心得
- **调试经验**：正向推导易陷入局部最优，逆向思维更高效（来自 _Felix 的顿悟）。
- **代码优化**：排序处理最小边的写法大幅简化逻辑（吴思诚代码的亮点）。

---
处理用时：163.54秒
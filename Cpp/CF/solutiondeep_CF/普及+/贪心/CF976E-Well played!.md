# 题目信息

# Well played!

## 题目描述

Max 最近沉迷于一款打怪游戏《赛某号》。现在，他正在参加赛某号的春季联赛。

他有 $n$ 只精灵。每只精灵都有对应的生命值 $hp_i$ 和攻击值 $dmg_i$。在比赛过程中，Max 可以借助巴拉拉小魔仙之力，说出这两种咒语：

1. “乌卡拉！血量！加倍！“意即将当前精灵的生命值加倍。（使得 $hp_i \gets 2\times hp_i$）

2. “乌卡拉！生命之力！”意即将当前精灵的生命值赋给当前精灵的攻击值。（使得 $dmg_i\gets hp_i$）

Max 当然不能无限使用这两种咒语。在一局游戏中，他可以使用第一种咒语 $a$ 次，第二次咒语 $b$ 次。由于Max 购买了超级 Nono，所以这两种咒语都可以被多次用在同一精灵身上，且咒语的使用顺序没有限制。Max 可以不用完所有的咒语。

Max 非常希望通过使用这些咒语使得自己的精灵战斗群的攻击值达到最大。现在，Max 想知道这个最大值。


输入第 $2$ 行到第 $n+1$ 行，每行两个整数 $hp$，$dmg$。第 $i$ 行表示第 $i-1$ 个精灵的生命值和攻击值。

## 样例 #1

### 输入

```
2 1 1
10 15
6 1
```

### 输出

```
27
```

## 样例 #2

### 输入

```
3 0 3
10 8
7 11
5 2
```

### 输出

```
26
```

# AI分析结果



# Well played!

## 题目描述

Max 最近沉迷于一款打怪游戏《赛某号》。现在，他正在参加赛某号的春季联赛。

他有 $n$ 只精灵。每只精灵都有对应的生命值 $hp_i$ 和攻击值 $dmg_i$。在比赛过程中，Max 可以借助巴拉拉小魔仙之力，说出这两种咒语：

1. "乌卡拉！血量！加倍！"（将当前精灵的生命值加倍，即 $hp_i \gets 2\times hp_i$）
2. "乌卡拉！生命之力！"（将当前精灵的生命值赋给攻击值，即 $dmg_i\gets hp_i$）

Max 可以使用第一种咒语 $a$ 次，第二种咒语 $b$ 次。两种咒语可以多次用于同一精灵，顺序不限。求精灵攻击值的最大总和。

## 样例 #1

### 输入
```
2 1 1
10 15
6 1
```

### 输出
```
27
```

---

## 题解综合分析

### 关键思路总结
1. **贪心策略**：所有翻倍咒语（a次）必须作用于同一精灵，数学证明分散使用必然劣于集中使用
2. **优先级排序**：优先对 (hp-dmg) 差值最大的精灵使用生命转化咒语（b次）
3. **动态调整**：对每个精灵计算 a 次翻倍后的潜在收益，结合是否占用 b 次机会进行全局最优决策

### 最优题解推荐
#### 题解作者：JWRuixi（★★★★★）
**核心亮点**：
- 清晰的预处理排序与分段处理逻辑
- 巧妙的收益计算方式，区分已转化/未转化精灵的不同处理
- 简洁的代码实现，仅需一次遍历完成所有可能性评估

**关键代码片段**：
```cpp
sort(q + 1, q + n + 1);
// 预处理前b个最大收益的转化
for (int i = 1; i <= n; i++) {
    if (i <= b) ans += q[i].mx();
    else ans += q[i].d;
}
// 计算翻倍后的最大收益
const int x = (1 << a), sum = q[b].d - q[b].mx(), tmp = ans;
for (int i = 1; i <= n; i++) {
    if (i <= b) {
        int res = tmp - q[i].mx() + q[i].hp * x;
        ans = max(ans, res);
    } else {
        int res = tmp - q[i].d + q[i].hp * x + sum;
        ans = max(ans, res);
    }
}
```

#### 题解作者：kkio（★★★★☆）
**核心亮点**：
- 高效的边界条件处理机制
- 使用 trm 变量记录可替换的最小收益，优化计算过程
- 精简的代码结构实现核心逻辑

**关键代码片段**：
```cpp
for(int i=1;i<=n;i++)
    if(w[i].hp-w[i].dp>0&&i<=b) { 
        sum+=w[i].hp;
        if(i==b) trm=-w[i].hp+w[i].dp;
    } 
    else sum+=w[i].dp;
for(int i=1;i<=n;i++) {
    int thp=w[i].hp*pw;
    if(w[i].hp-w[i].dp>0&&i<=b)
        maxx=max(sum-w[i].hp+thp,maxx);
    else if(b)
        maxx=max(maxx,sum-w[i].dp+thp+trm);
}
```

---

## 举一反三
1. **同类题目推荐**：
   - P1090 合并果子（贪心+优先队列）
   - P1208 [USACO1.3]混合牛奶（贪心排序）
   - P4995 跳跳！（贪心+双指针）

2. **关键技巧拓展**：
   - 资源集中使用的贪心证明方法
   - 收益差值排序的预处理思想
   - 替代优化中的边际收益计算

## 心得体会
- **调试经验**：特别注意边界条件如 b=0 的情况，此时无法进行任何生命转化操作
- **优化技巧**：预处理 2^a 的计算结果避免重复计算，使用位运算加速
- **思维突破**：意识到翻倍操作必然需要配合生命转化才能产生实际收益，二者的组合使用是解题关键

---
处理用时：118.18秒
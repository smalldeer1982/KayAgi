# 题目信息

# Bookshelves

## 题目描述

## 题意：

$Keks$ 先生是 $Byteland$ 大陆的典型的白领。

他办公室里有一个书架，上面有几本书，每本书都有一个值为正整数的价格。

$Keks$ 先生把书架的价值定义为书价的总和。         

出乎意料地是， $Keks$ 先生升职了，现在他要去一个新的办公室。

他知道，在新的办公室里，他将有不止一个书架，而恰恰是 $K$ 个书架。

他认为 $K$ 个书架的美丽程度在于所有书架的价值的“按位与”和。 

他还决定不花时间重新整理书籍，所以他会先把几本书放在第一个书架上，下几本书放在下一个书架上，以此类推。当然，他会在每一个架子上放置至少一本书。这样，他会把所有的书放在 $K$ 个书架上，尽量使书架的美观程度越大越好。计算这个最大可能的美丽程度。

## 样例 #1

### 输入

```
10 4
9 14 28 1 7 13 15 29 2 31
```

### 输出

```
24
```

## 样例 #2

### 输入

```
7 3
3 14 15 92 65 35 89
```

### 输出

```
64
```

# AI分析结果



# Bookshelves

## 题目描述

### 题意：

$Keks$ 先生是 $Byteland$ 大陆的典型白领。他的办公室有一个书架，每本书有正整数价格。书架价值定义为书价总和。升职后他需要将书分配到 $K$ 个新书架，美观程度定义为所有书架价值的"按位与"和。要求必须按原书顺序连续分到各书架，每个书架至少一本。求最大可能的美丽程度。

---

## 题解综合分析

### 关键算法思路：
1. **按位贪心**：从高位到低位逐位尝试添加（优先保证高位为1）
2. **动态规划验证**：用二维DP验证能否分割成k段，使得每段和与当前候选值按位与后仍等于候选值
3. **位运算优化**：利用位掩码特性避免直接计算总和，时间复杂度 $O(n^2k \log \sum a_i)$

### 最优题解亮点对比：
| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| Siyuan         | ⭐⭐⭐⭐⭐ | 清晰的位贪心框架，代码可读性极佳，正确性验证严谨                         |
| Libre_dreagonm | ⭐⭐⭐⭐  | 详细的位运算思路说明，博客补充了调试经验                                  |
| jch123         | ⭐⭐⭐⭐  | 最简短的代码实现，适合快速理解核心逻辑                                    |

---

## 精选高分题解

### Siyuan（5星）
**亮点**：  
- 提出贪心框架 `ans |= (1LL<<i)` 的位构建方式  
- 使用 `check()` 函数封装DP验证逻辑，模块清晰  
- 正确性证明简洁明确，代码处理大数用 `long long`  

**核心代码**：
```cpp
bool check(long long x) {
    memset(f,0,sizeof(f));
    f[0][0] = true;
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=k; ++j)
            for(int k=0; k<i; ++k)
                f[i][j] |= f[k][j-1] & (((a[i]-a[k])&x) == x);
    return f[n][k];
}
```

### jch123（4星）
**亮点**：  
- 代码最简练，去除非必要变量  
- 使用前缀和数组 `s[]` 优化区间和计算  
- 位运算优先级处理正确，避免常见错误  

**调试经验**：  
> 注意 `&` 运算符优先级低于 `==`，必须加括号确保 `((sum[j]-sum[kx])&x)==x`

---

## 关键技巧总结
1. **位贪心框架**：  
   ```cpp
   long long ans = 0;
   for(int i=60; i>=0; --i) {
       long long temp = ans | (1LL<<i);
       if(check(temp)) ans = temp;
   }
   ```
2. **DP状态设计**：  
   `f[i][j]` 表示前i本书分j个书架是否可行，转移时验证区间和的位掩码

3. **前缀和优化**：  
   ```cpp
   a[i] += a[i-1]; // 前缀和预处理
   sum = a[r] - a[l-1]; // 快速计算区间和
   ```

---

## 类似题目推荐
1. [P2114 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  
   **相似点**：位运算贪心 + 结果最大化

2. [P4317 花神的数论题](https://www.luogu.com.cn/problem/P4317)  
   **相似点**：二进制位统计 + 组合数学

3. [CF242E XOR on Segment](https://codeforces.com/problemset/problem/242/E)  
   **相似点**：位运算特性 + 分块处理

---
处理用时：44.57秒
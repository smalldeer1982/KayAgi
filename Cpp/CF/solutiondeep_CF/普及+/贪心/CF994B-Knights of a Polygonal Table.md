# 题目信息

# Knights of a Polygonal Table

## 题目描述

有  $n$  个骑士想决战。每个骑士都有能力值，且身上带有一些金币。如果骑士  $A$  的能力值大于骑士  $B$ ，那么骑士  $A$  就可以杀死骑士  $B$ ，并获得骑士  $B$  身上的所有金币。但就算是骑士也不会残忍过度，他们最多只会杀死  $k$  个骑士。对于每一位骑士，请你求出在决战后他身上金币的最大值。

## 说明/提示

- 第  $1$  组样例的解释：

第  $1$  个骑士是最蒻的，因此他谁也不能杀，只能保留自己原有的金币。

第  $2$  个骑士只能杀死第  $1$  个骑士，因此他最多拥有  $2 + 1 = 3$  个金币。

第  $3$  个骑士是最蔃的，但他只能选择杀  $k = 2$  个骑士。显然他会杀死第  $2$  个骑士和
第  $4$  个骑士，因为他们身上的金币更多。因此他最多拥有  $11 + 2 + 33 = 46$  个金币。

第  $4$  个骑士应该杀死第  $1$  个和第  $2$  个骑士，因此他最多拥有  $33 + 1 + 2 = 36$  个金币。 

- 第  $2$  组样例的解释：

除了最蒻的第  $1$  个骑士谁也不能杀，其他骑士都能杀死前一个骑士并获得他的金币。

- 第  $3$  组样例的解释：

由于只有一个骑士在决战中，他无法杀死任何人。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
4 2
4 5 9 7
1 2 11 33
```

### 输出

```
1 3 46 36 ```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5
1 2 3 4 5
```

### 输出

```
1 3 5 7 9 ```

## 样例 #3

### 输入

```
1 0
2
3
```

### 输出

```
3 ```

# AI分析结果



# Knights of a Polygonal Table

## 题目描述

有  $n$  个骑士想决战。每个骑士都有能力值，且身上带有一些金币。如果骑士  $A$  的能力值大于骑士  $B$ ，那么骑士  $A$  就可以杀死骑士  $B$ ，并获得骑士  $B$  身上的所有金币。但就算是骑士也不会残忍过度，他们最多只会杀死  $k$  个骑士。对于每一位骑士，请你求出在决战后他身上金币的最大值。

---

## 题解综合分析

### 算法核心思路
1. **按能力值排序**：所有骑士按能力升序排列，保证第i个骑士只能选择前i-1个骑士
2. **动态维护前k大值**：使用优先队列维护当前可选的k个最大金币值
3. **总和优化**：通过维护堆的总和避免重复计算，时间复杂度优化至O(n log k)

### 最优解法关键点
- **小根堆优化**：始终保持堆大小为k，堆顶为当前k个最小元素，便于快速淘汰更小的值
- **在线求和**：通过变量实时维护堆中元素总和，避免每次遍历堆计算
- **双排序处理**：第一次按能力排序处理计算，第二次按原始id排序恢复输出顺序

---

## 精选题解

### 题解4（作者：_22222222_） ★★★★★
**核心亮点**：  
- 使用小根堆动态维护前k大元素，堆大小始终≤k  
- 在线维护总和变量，时间复杂度O(n log k)  
- 代码简洁，处理逻辑清晰  

**关键代码**：
```cpp
priority_queue<node, vector<node>, cmp> q; // 小根堆
int now = 0; // 维护堆的总和

for(int i=1; i<=n; i++) {
    a[i].ans = now + a[i].c; // 当前总和+自身金币
    q.push(a[i]);
    now += a[i].c;
    while(q.size() > k) { // 维护堆大小≤k
        now -= q.top().c;
        q.pop();
    }
}
```

### 题解5（作者：KKarshilov） ★★★★☆
**核心亮点**：  
- 优先队列动态淘汰最小值  
- 提前处理前k+1项的边界情况  
- 采用双排序保持原始顺序  

**优化点**：  
- 初始处理前m+1项时直接累加，避免堆操作  
- 代码中有部分冗余逻辑，可读性稍逊  

---

## 拓展与总结

### 同类问题套路
1. **前k大维护**：使用堆结构动态维护前k大/小元素（如滑动窗口中位数）
2. **离线处理**：通过排序将动态选择问题转化为静态范围查询
3. **在线求和**：通过变量维护动态集合的统计值（总和、平均值等）

### 推荐练习题
1. [P3963 [TJOI2013]奖学金](https://www.luogu.com.cn/problem/P3963)  
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)  
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)  

### 调试心得
- **堆的方向**：小根堆与大根堆的排序方向易混淆，需注意比较函数  
- **变量维护**：总和变量需要与堆操作严格同步，避免数据不一致  
- **边界处理**：当k=0或n=1时需单独处理，防止越界访问

---
处理用时：54.43秒
# 题目信息

# Ability To Convert

## 题目描述

亚历山大正在学习如何把十进制数字转换成其他进制，但是他不懂英文字母，所以他只是把数值按照十进制数字的方式写出来。这意味着他会用 10 代替英文字母 A。这样，他就会把十进制的 475 转换成十六进制的 11311（475=1·16^2+13·16^1+11·16^0）。亚历山大平静的生活着，直到有一天他试着把这些数字转换回十进制数字。

亚历山大记着他总是用较小的数字工作，所以他需要找到在 n 进制的基础下，用他的转换系统得出数字 k 的最小十进制数。

## 样例 #1

### 输入

```
13
12
```

### 输出

```
12```

## 样例 #2

### 输入

```
16
11311
```

### 输出

```
475```

## 样例 #3

### 输入

```
20
999
```

### 输出

```
3789```

## 样例 #4

### 输入

```
17
2016
```

### 输出

```
594```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕如何将给定的 $n$ 进制数转换为最小的十进制数展开，大多采用贪心或动态规划算法。
- **思路对比**：贪心算法的核心思路是从低位向高位枚举，尽可能使划分出的各位数小于 $n$ 且总位数最小，最高位尽可能小；动态规划算法则通过定义状态和状态转移方程来求解最小结果。
- **算法要点**：贪心算法关键在于合理划分数字，避免前导零和处理大数溢出；动态规划算法需要准确计算区间表示的十进制数，并在状态转移时判断合法性。
- **解决难点**：各题解都着重处理了前导零和大数溢出问题，如使用特殊数组记录非零数字位置、跳过连续零、避免使用 `cmath` 中的 `pow` 函数等。

### 所选题解
- **Miraik（5星）**：
  - **关键亮点**：思路清晰，详细阐述了贪心策略及处理前导零和大数溢出的方法，代码实现完整且注释清晰。
  - **个人心得**：指出极端情况下 $k$ 达到 60 位会爆 `unsigned long long`，需特殊处理大段连续零的情况。
- **Tx_Lcy（4星）**：
  - **关键亮点**：明确指出贪心的细节和坑点，代码实现简洁，使用字符串处理避免整型处理的问题。
  - **个人心得**：提醒在划分过程中用字符串类型记录，遇到划分非法时下次仍从该位置开始考虑。
- **legendgod（4星）**：
  - **关键亮点**：采用动态规划方法，通过状态转移方程求解最小结果，对转移条件进行了详细处理，避免了爆 `unsigned long long` 的问题。
  - **个人心得**：注意到一开始赋值极大值时会导致 $f[i] \times n$ 爆 `unsigned long long`，因此设置转移条件 $f[i] < \frac{\inf}{n}$。

### 重点代码
#### Miraik 的核心代码
```cpp
int n,m,x[65],lst[65],ans;
char s[65];
signed main(){
    n=read();
    scanf("%s",s+1);
    m=strlen(s+1);
    for(int i=m,j=m+1;i;i--){ //求出向后第一个非 0 数字 
        lst[i]=j;
        if(s[i]!='0') j=i;
    }
    int pwn=1;
    for(int i=m;i;i--){
        int pw10=1; x[i+1]=0;
        for(int j=i;j;j--,pw10*=10){
            x[j]=x[j+1]+pw10*(s[j]-'0');
            if(pw10>n||x[j]>=n){ // pw10>n ：大段 0，必然不满足条件 
                j=min(lst[j],i);
                ans+=x[j]*pwn;
                pwn*=n;
                i=j;
                break;
            }
            else if(j==1){ // 已经最高位了，直接判断即可 
                ans+=x[j]*pwn;
                pwn*=n;
                i=j;
            }
        }
    }
    printf("%llu\n",ans);
    return 0;
}
```
**核心实现思想**：先预处理出 `lst` 数组记录每个位置向后第一个非零数字的位置，然后从低位向高位枚举，尝试划分数字，若划分出的数字大于等于 $n$ 或出现大段零则进行调整。

#### Tx_Lcy 的核心代码
```cpp
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int n;string s;cin>>n>>s;
    int l=s.length(),q=len(n-1),qpow=1,ans=0;
    s=" "+s;int la=l;
    while (la>=1){
        int tag=0;string res="";
        for (int j=la;j>=max(1LL,la-q+1);--j){
            if (toint(res+s[j])>=n){
                ans+=qpow*toint(res);qpow*=n;
                tag=1;break;//非法了就 break
            }else res+=s[j];
        }
        la=la-len(toint(res));
        if (!tag) ans+=qpow*toint(res),qpow*=n;
    }
    cout<<ans<<'\n';
    return 0;
}
```
**核心实现思想**：从后往前遍历字符串，尝试将字符添加到 `res` 中，若添加后大于等于 $n$ 则划分，更新结果和进制幂。

#### legendgod 的核心代码
```cpp
ull n;
int m, lc;
char c[maxn];
ull f[maxn];
signed main() {
    r1(n);
    scanf("%s", c + 1); lc = strlen(c + 1);
    for(int i = 2; i <= lc + 1; ++ i) f[i] = inf;
    f[1] = 0;
    for(int i = 1; i <= lc; ++ i) {
        if(c[i] == '0') {
            if(f[i] > inf / n) continue;
            f[i + 1] = min(f[i + 1], f[i] * n);
        }
        else {
            ull x(0);
            for(int j = i + 1; j <= lc + 1; ++ j) {
                x = (x * 10ull + c[j - 1] - '0');
                if(x >= n) break;
                if(f[i] > inf / n) continue;
                f[j] = min(f[j], f[i] * n + x);
            }
        }
    }
    printf("%llu\n", f[lc + 1]);
    return 0;
}
```
**核心实现思想**：定义 $f[i]$ 表示当前已经计算到第 $i$ 个数的最小结果，根据当前字符是否为零进行不同的状态转移，同时注意转移条件避免爆 `unsigned long long`。

### 最优关键思路或技巧
- **贪心策略**：从低位向高位枚举，尽可能使划分出的各位数小于 $n$ 且总位数最小，最高位尽可能小。
- **处理前导零**：使用数组记录非零数字位置，遇到前导零及时调整。
- **避免大数溢出**：特殊处理大段连续零，避免使用 `cmath` 中的 `pow` 函数，设置转移条件避免乘法溢出。

### 可拓展之处
同类型题可能涉及不同进制的转换和优化问题，类似算法套路包括贪心算法在数字划分、区间选择等问题中的应用，动态规划在状态转移和最优解求解中的应用。

### 推荐题目
1. [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)
2. [P1143 进制转换](https://www.luogu.com.cn/problem/P1143)
3. [P2415 集合求和](https://www.luogu.com.cn/problem/P2415)

### 个人心得总结
- **SSHhh**：贪心思路易想但细节多，连续 WA 10 次后选择动态规划，同时提醒不要使用 `cmath` 里的 `pow` 函数，自己写快速幂更好。
- **AC自动机**：贪心能 AC，但要处理大量细节，如避免前导零和死循环，特殊判断极端数据的溢出问题。

---
处理用时：47.06秒
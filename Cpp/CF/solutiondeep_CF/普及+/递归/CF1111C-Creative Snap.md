# 题目信息

# Creative Snap

## 题目描述

灭霸要摧毁复仇者们的基地！  

我们可以将复仇者的基地看成一个序列，每个位置都有可能有多个复仇者；但是每个复仇者只能占据一个位置。  
他们基地的长度刚好是$2$的整数幂，灭霸想要用最少的能量摧毁它们。他在摧毁过程中，可以选择：  
- 如果这段基地长度$\ge 2$，他可以将其分为相等长度的两半。  
- 烧掉这段基地。如果这段基地中没有复仇者，他需要消耗$A$的能量；如果有，则需要消耗$B*x*l$的能量。其中$l$是这段基地长度，$x$是这段中的复仇者数量。  

输出一个整数，表示他摧毁全部基地需要的最少能量。  
接下来一行$k$个整数，$a_i$表示第$i$个复仇者所在的位置

## 说明/提示

### 样例解释  
对于样例1，直接烧区间$[1,4]$需要能量为$4*2*2=16$。  
但是，如果将其分为$4$段，分别烧掉，所需能量只有$2+1+2+1=6$。  
可以证明没有更优的方案，所以输出`6`。 
对于全部数据：  
$1\le n \le 30$  
$1\le k \le 10^5$  
$1\le A,B \le 10^4$  
$1\le a_i \le 2^n$

## 样例 #1

### 输入

```
2 2 1 2
1 3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3 2 1 2
1 7
```

### 输出

```
8
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算灭霸摧毁复仇者基地所需的最少能量展开，思路大致可分为分治递归和动态开点线段树两类。

#### 思路对比
- **分治递归**：大部分题解采用分治思想，将区间不断二分。关键在于计算区间内复仇者的数量，通常使用二分查找（`lower_bound` 和 `upper_bound`）来高效统计。当区间内没有复仇者时，直接返回能量 $A$，以此进行剪枝优化。
- **动态开点线段树**：通过动态开点线段树维护区间内的人数和价值，避免了因值域大（$2^{30}$）而导致的空间问题。每个节点维护区间内的人数和价值，按照规则更新节点信息。

#### 算法要点
- **分治递归**：定义递归函数 `solve(l, r)` 表示摧毁区间 $[l, r]$ 需要的最小能量。计算区间内复仇者数量，根据数量和区间长度判断是直接摧毁还是继续二分。
- **动态开点线段树**：动态开点，每个节点记录区间人数和价值，通过 `pushup` 函数更新节点信息，插入复仇者时更新线段树。

#### 解决难点
- **值域大**：通过剪枝（区间无复仇者直接返回 $A$）和动态开点线段树解决空间问题。
- **统计复仇者数量**：使用二分查找高效统计区间内复仇者数量。

#### 评分与选择
- **花里心爱**：4星。思路清晰，使用动态开点线段树解决问题，代码注释详细，复杂度分析明确。
- **GKxx**：4星。代码规范，有详细的模板函数，剪枝思路清晰，实现简洁。
- **Engulf**：4星。思路简洁明了，分治思想阐述清晰，代码实现简洁。

### 所选题解
- **花里心爱（4星）**：关键亮点是使用动态开点线段树维护区间信息，避免了空间问题。代码注释详细，便于理解。
- **GKxx（4星）**：关键亮点是代码规范，有详细的模板函数，剪枝思路清晰，实现简洁。
- **Engulf（4星）**：关键亮点是思路简洁明了，分治思想阐述清晰，代码实现简洁。

### 重点代码
#### 花里心爱（动态开点线段树）
```cpp
void pushup(int cur, int len) {
    c[cur] = c[ls[cur]] + c[rs[cur]];
    d[cur] = std::min(B*c[cur]*len, d[ls[cur]] + d[rs[cur]]);
}

void ins(int& cur, int l, int r, int pos) {
    if(!cur) cur = ++cnt;
    if(l == r) {
        ++c[cur];
        d[cur] = B*c[cur];
        return;
    }
    int mid = (l+r)>>1;
    if(mid >= pos) ins(ls[cur], l, mid, pos);
    else ins(rs[cur], mid+1, r, pos);
    pushup(cur, r-l+1);
}
```
核心思想：`pushup` 函数更新节点的人数和价值，`ins` 函数插入复仇者并更新线段树。

#### GKxx（分治递归）
```cpp
inline LL count(int l, int r) {
    int pr = std::upper_bound(a + 1, a + K + 1, r) - a;
    --pr;
    int pl = std::upper_bound(a + 1, a + K + 1, l - 1) - a;
    --pl;
    return pr - pl;
}

LL solve(int l, int r) {
    int cnt = count(l, r);
    if (!cnt) return A;
    if (l == r) return B * cnt;
    int mid = (l + r) >> 1;
    return std::min(1ll * cnt * B * (r - l + 1), solve(l, mid) + solve(mid + 1, r));
}
```
核心思想：`count` 函数统计区间内复仇者数量，`solve` 函数递归计算最小能量。

#### Engulf（分治递归）
```cpp
int so1ve(int l, int r)
{
    int avengers = upper_bound(a + 1, a + k + 1, r) - lower_bound(a + 1, a + k + 1, l);
    if (!avengers) return A;
    if (l == r) return B * avengers;
    int mid = l + r >> 1;
    int split = so1ve(l, mid) + so1ve(mid + 1, r);
    return min(split, B * avengers * (r - l + 1));
}
```
核心思想：计算区间内复仇者数量，根据数量和区间长度判断是直接摧毁还是继续二分。

### 最优关键思路或技巧
- **剪枝优化**：当区间内没有复仇者时，直接返回能量 $A$，避免不必要的递归。
- **二分查找**：使用 `lower_bound` 和 `upper_bound` 高效统计区间内复仇者数量。
- **动态开点线段树**：对于值域大的问题，使用动态开点线段树避免空间浪费。

### 可拓展之处
同类型题或类似算法套路：
- 区间划分问题：如区间合并、区间覆盖等，可使用分治思想解决。
- 线段树应用：动态开点线段树可用于处理值域大、修改次数少的区间问题。

### 推荐题目
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
- [P1856 [USACO5.5] 矩形周长Picture](https://www.luogu.com.cn/problem/P1856)
- [P2068 统计和](https://www.luogu.com.cn/problem/P2068)

### 个人心得摘录与总结
- **NaCly_Fish**：尝试用树状数组 + map 维护区间和，结果超时。官方题解用排序和二分查找解决统计问题，提醒我们选择合适的数据结构和算法很重要。
- **swiftc**：树状数组会 $MLE$，$map$ 会 $TLE$，使用 `tr1::unordered_map` 解决问题，说明在处理数据结构时要考虑复杂度和空间限制。 

---
处理用时：39.09秒
# 题目信息

# Vasya And The Mushrooms

## 题目描述

Vasya 住在森林里，附近有一个会长蘑菇的空地。这个空地被分成两行，每行分为 $n$ 个连续的格子。Vasya 知道每分钟每个格子里能长多少个蘑菇。他要花一分钟从一个格子走到相邻的格子上，并且他不能离开空地。（我们称两个格子相邻，当且仅当它们有公共边。）当 Vasya 进入一个格子时，他会马上收集那个格子里的所有蘑菇。

Vasya 从左上角的格子开始收集蘑菇。因为他等不及蘑菇生长了，所以每分钟内他必须移动到一个相邻格子。他想每个格子都恰好走一遍并且最大化他所收集的蘑菇数量。一开始所有格子都没有蘑菇。Vasya也不一定要回到开始的格子。
帮帮 Vasya！计算出他能收集到的最大蘑菇数量。

## 说明/提示

#### 样例1:

在第一个测试用例中，最佳路径如下：

![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1016C/fbb0db02f46ac40c8f18dc6a212852df14543f5e.png) 

这样，蘑菇的收集重量将为 $0·1 + 1·2 + 2·3 + 3·4 + 4·5 + 5·6 =70$。

#### 样例2:

在第二个测试用例中，最佳路径如下：

![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1016C/0853812a60511dc1127814cc7d3f93535736820f.png) 

这样，蘑菇的收集重量将为 $0·1 + 1·10 + 2·100 + 3·1000 + 4·10000 + 5·100000 =543210$

## 样例 #1

### 输入

```
3
1 2 3
6 5 4
```

### 输出

```
70
```

## 样例 #2

### 输入

```
3
1 1000 10000
10 100 100000
```

### 输出

```
543210
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先找出所有可能的行走方案，再通过预处理和递推等方法优化计算过程，避免 $O(N^2)$ 的时间复杂度。

- **思路对比**：大部分题解都发现了行走方案是先在前面若干列蛇形走，然后在某一行走到尽头再返回，只是在具体的方案分类和处理细节上有所不同。
- **算法要点**：各题解普遍采用前缀和来优化计算，通过预处理部分数据，在枚举方案时可以 $O(1)$ 计算出每种方案的结果。
- **解决难点**：主要难点在于找出方案之间的递推关系，以及处理不同方案下每个格子的时间戳和贡献值。

### 所选题解
- **作者：YellowBean_Elsa（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过后缀和与前缀和的结合，巧妙地处理了不同方案的计算，并且详细说明了方案之间的递推关系。
- **作者：yybyyb（4星）**
    - **关键亮点**：对合法方案的性质分析准确，通过预处理多个数组，使得所有结果可以直接计算，代码实现较为清晰。
- **作者：aison（4星）**
    - **关键亮点**：对每种方案的选择和转移方程进行了详细的推导，思路严谨，代码中对数组的递推计算也很清晰。

### 重点代码
#### YellowBean_Elsa的代码
```cpp
// 计算后缀两行和、后缀方案2和、后缀方案3和
for(int i=n;i>=1;i--){
    s[i]=s[i+1]+a[i]+b[i];
    sum1[i]=sum1[i+1]+s[i+1]+b[i]+b[i]*((n-i)<<1);
    sum2[i]=sum2[i+1]+s[i+1]+b[i]+a[i+1]*((n-i)<<1);
}
// 计算在第i（奇数）列第一行结束方案1，开始使用方案2或3时，使用方案1的总收入
for(int i=3;i<=n;i+=2){
    u[i]=u[i-2]+a[i-2]*(++cur)+b[i-2]*(++cur)+b[i-1]*(++cur)+a[i-1]*(++cur);
}
// 计算答案
for(int i=1;i<=n;i+=2){
    ans=max(ans,u[i]+sum1[i]+s[i]*((i<<1)-2));
    ans=max(ans,u[i]+sum2[i]+s[i]*((i<<1)-2));
}
```
**核心实现思想**：先预处理后缀和，再计算方案1的收入，最后枚举方案并取最大值。

#### yybyyb的代码
```cpp
// 预处理各数组
for(int i=n;i>=1;--i)da[i]=da[i+1]+a[i],db[i]=db[i+1]+b[i];
s=0;for(int i=n;i>=1;--i)sa[i]=sa[i+1]+s,s+=a[i];
s=0;for(int i=n;i>=1;--i)sb[i]=sb[i+1]+s,s+=b[i];
for(int i=n;i>=1;--i)ra[i]=ra[i+1]+1ll*(n-i)*a[i];
for(int i=n;i>=1;--i)rb[i]=rb[i+1]+1ll*(n-i)*b[i];
// 枚举计算答案
for(int i=1,t=0;i<=n;++i)
    if(i&1){
        ans=max(ans,s+sa[i]+rb[i]+1ll*t*da[i]+1ll*(t+n-i+1)*db[i]);
        s+=1ll*t*a[i];++t;
        ans=max(ans,s+sb[i]+ra[i+1]+1ll*t*db[i]+1ll*(t+n-i+1)*da[i+1]);
        s+=1ll*t*b[i];++t;
    }
    else{
        ans=max(ans,s+sb[i]+ra[i]+1ll*t*db[i]+1ll*(t+n-i+1)*da[i]);
        s+=1ll*t*b[i];++t;
        ans=max(ans,s+sa[i]+rb[i+1]+1ll*t*da[i]+1ll*(t+n-i+1)*db[i+1]);
        s+=1ll*t*a[i];++t;
    }
```
**核心实现思想**：预处理多个数组，然后根据奇偶性枚举不同方案，更新答案。

#### aison的代码
```cpp
// 预处理s[1]、ret1[1]、ret2[1]
for(ll j=1;j<=n;j++){
    scanf("%lld",&a[j]);
    s[1]+=a[j];
    ret1[1]+=(j-1)*a[j];
    if(j!=1)ret2[1]+=(2*n-j+1)*a[j];
}
for(ll j=1;j<=n;j++){
    scanf("%lld",&b[j]);
    s[1]+=b[j];
    ret1[1]+=(2*n-j)*b[j];
    ret2[1]+=j*b[j];
}
// 递推计算s、ret1、ret2、dw
for(ll i=3;i<=n;i+=2){
    s[i]=s[i-2]-a[i-2]-a[i-1]-b[i-2]-b[i-1];
    ret1[i]=ret1[i-2]-a[i-1]-2*s[i]-(2*n-2*i+4)*b[i-1]-(2*n-2*i+5)*b[i-2];
    ret2[i]=ret2[i-2]-b[i-2]-2*s[i]-(2*n-2*i+5)*a[i-1]-(2*n-2*i+2)*a[i]-2*b[i-1];
    dw[i]=dw[i-2]+(2*i-6)*a[i-2]+(2*i-5)*b[i-2]+(2*i-4)*b[i-1]+(2*i-3)*a[i-1];
}
// 计算答案
for(ll i=1;i<=n;i+=2){
    ans=max(ans,dw[i]+max(ret1[i],ret2[i])+(2*i-2)*s[i]);
}
```
**核心实现思想**：先预处理初始值，再通过递推计算各数组，最后枚举计算答案。

### 最优关键思路或技巧
- **方案分析**：通过分析题目条件，发现所有合法方案都可以归纳为先蛇形走若干列，再在某一行走到尽头返回，从而将方案数量从指数级降为线性。
- **前缀和优化**：利用前缀和数组记录部分数据的和，在计算每种方案的结果时可以 $O(1)$ 完成，避免了重复计算，将时间复杂度从 $O(N^2)$ 优化到 $O(N)$。
- **递推关系**：找出不同方案之间的递推关系，通过递推计算每个方案的结果，减少了计算量。

### 可拓展之处
同类型题可能会有更多行或列，或者对行走规则有更多限制。类似的算法套路可以应用在路径规划、网格遍历等问题中，关键在于找出所有可能的路径方案，并通过预处理和递推等方法优化计算过程。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：考察贪心算法和字符串处理，需要找出最优的删数方案。
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：经典的动态规划问题，需要找出从起点到终点的所有路径方案。
3. [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：动态规划问题，需要找出从顶部到底部的最大路径和。

### 个人心得摘录与总结
- **liangjindong0504**：一开始看错题目，把时间看成 $1$ 到 $2n$ 了，提醒自己和读者要仔细读题，同时也展示了一种解决问题的思路，即发现错误后可以通过简单的调整（如减去总和）来修正结果。
- **MspAInt**：认为这个题比较恶心，说明此类题目细节较多，需要仔细处理。在解题时可以通过画图等方式辅助理解，同时要注意开 `long long` 避免数据溢出。

---
处理用时：55.52秒
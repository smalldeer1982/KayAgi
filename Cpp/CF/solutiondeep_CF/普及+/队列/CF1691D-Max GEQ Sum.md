# 题目信息

# Max GEQ Sum

## 题目描述

现在你有一个由 $n$ 个整数组成的数组 $a$，$(i,j)$ 满足条件当且仅当 $\max (a_i,a_{i+1},\cdots,a_j)\ge a_i+a_{i+1}+\cdots+a_j$，其中 $1\le i\le j\le n$。问是否所有 $(i,j)$ 都满足要求。

## 样例 #1

### 输入

```
3
4
-1 1 -1 2
5
-1 2 -3 2 -1
3
2 3 -1```

### 输出

```
YES
YES
NO```

# AI分析结果

### 题目内容
# 最大大于等于和

## 题目描述
现在你有一个由 $n$ 个整数组成的数组 $a$，$(i,j)$ 满足条件当且仅当 $\max (a_i,a_{i+1},\cdots,a_j)\ge a_i+a_{i+1}+\cdots+a_j$，其中 $1\le i\le j\le n$。问是否所有 $(i,j)$ 都满足要求。

## 样例 #1
### 输入
```
3
4
-1 1 -1 2
5
-1 2 -3 2 -1
3
2 3 -1
```
### 输出
```
YES
YES
NO
```

### 题解综合分析与结论
这些题解的核心思路大多是通过确定每个数作为最大值的区间，然后在该区间内找最大子段和，并与该数比较来判断是否满足条件。
- **思路方面**：多数题解利用单调栈或ST表加二分来确定每个数作为最大值的区间。之后，通过前缀和结合ST表或线段树来求区间内最大子段和。
- **算法要点**：涉及单调栈、ST表、线段树、前缀和等数据结构和算法。单调栈用于找每个数作为最大值的区间边界；ST表和线段树用于快速查询区间最值；前缀和用于快速计算区间和。
- **解决难点**：主要难点在于高效确定每个数作为最大值的区间，以及在该区间内快速找到最大子段和。不同题解采用不同方法解决，如单调栈的 $O(n)$ 时间复杂度解法，以及ST表加二分的 $O(n \log n)$ 时间复杂度解法。

### 所选的题解
#### 作者：2020HZ06 (5星)
- **关键亮点**：使用单调栈将时间复杂度优化到 $O(n)$，相比其他 $O(n \log n)$ 的解法更高效。通过分别从左向右和从右向左使用单调栈，找出每个数作为最大值的区间，并在弹栈时直接判断当前元素延伸到栈顶元素的这一段区间和是否大于零，避免了复杂的区间最值查询。
- **个人心得**：无
- **核心代码片段**：
```cpp
for(int i=1;i<=n;i++)//从左向右单调栈
{
    max_=0;
    while(!s.empty()&&s.top().val<=a[i])
    {
        max_=max(max_,sumq[i-1]-sumq[s.top().wz-1]);//判断是否满足条件
        s.pop();
    }
    if(max_>0)
    {
        b=1;
        break;
    } 
    s.push(node{a[i],i});
}
while(!s.empty()) s.pop();
for(int i=n;i>=1;i--)//从右向左单调栈
{
    max_=0;
    while(!s.empty()&&s.top().val<=a[i])
    {
        max_=max(max_,sumh[i+1]-sumh[s.top().wz+1]);
        s.pop();
    }
    if(max_>0)
    {
        b=1;
        break;
    } 
    s.push(node{a[i],i});
}
```
核心实现思想：利用单调栈的特性，在遍历数组时，对于每个元素，当栈顶元素小于等于当前元素时，弹出栈顶元素并计算相关区间和与0比较，从而判断是否存在不满足条件的区间。

#### 作者：AmamiyaYuuko (4星)
- **关键亮点**：思路清晰，先利用单调栈 $O(n)$ 时间内求出 $a_i$ 作为最大值的区间 $[l_i, r_i]$，再通过ST表维护前缀和与后缀和的区间最大值，从而快速计算 $[l_i, r_i]$ 中跨越了 $i$ 的最大子段和，时间复杂度 $O(n \log n)$。
- **个人心得**：无
- **核心代码片段**：无（题解未给出完整代码）
核心实现思想：先用单调栈确定每个数作为最大值的区间，再借助ST表快速查询区间内前缀和与后缀和的最值，进而判断是否存在不满足条件的区间。

#### 作者：lingfunny (4星)
- **关键亮点**：通过枚举最大值，并利用链表和ST表解决问题。先将数用链表相连，从小到大枚举最大值，每次枚举完删除该值并更新链表，从而确定每个最大值的左右边界，再用ST表查询区间内前缀和的最值，判断条件是否成立。
- **个人心得**：无
- **核心代码片段**：
```cpp
inline void solve() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) scanf("%d", a+i), s[i] = s[i-1] + a[i], p[i] = i, L[i] = i-1, R[i] = i+1;
    for(int i = 1; i <= n; ++i) mis[0][i] = s[i-1];
    for(int i = 1; i <= n; ++i) mxs[0][i] = s[i];
    for(int i = 1; i <= lg[n]; ++i)
    for(int j = 1; j <= n - (1<<i) + 1; ++j)
    mis[i][j] = min(mis[i-1][j], mis[i-1][j+(1<<(i-1))]),
    mxs[i][j] = max(mxs[i-1][j], mxs[i-1][j+(1<<(i-1))]);
    sort(p+1, p+n+1, [&](int x, int y) { return a[x] < a[y]; });
    for(int i = 1; i <= n; ++i) {
        int u = p[i];
        R[L[u]] = R[u], L[R[u]] = L[u];
        if(a[u] < Qmx(u, R[u]-1) - Qmi(L[u]+1, u)) return puts("NO"), void();
    }
    puts("YES");
}
```
核心实现思想：构建链表和预处理ST表后，通过排序枚举最大值，更新链表确定其左右边界，利用ST表查询边界内前缀和最值判断条件。

### 最优关键思路或技巧
- **单调栈优化**：如2020HZ06的题解，利用单调栈在 $O(n)$ 时间内确定每个数作为最大值的区间，并在弹栈过程中直接判断区间和是否满足条件，避免了复杂的数据结构操作，大大提高了效率。
- **ST表与前缀和结合**：多个题解利用ST表维护前缀和的最值，能快速查询特定区间内的最大子段和，从而高效判断条件是否成立。

### 可拓展之处
同类型题或类似算法套路：此类题目通常围绕区间最值和区间和的关系展开。常见套路是利用单调栈确定每个元素的影响区间，再结合前缀和及区间最值查询的数据结构（如ST表、线段树）来解决问题。例如，对于一些需要频繁查询区间最值或区间和的问题，都可以考虑类似的方法。

### 推荐洛谷题目
- [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)：经典的ST表模板题，用于练习ST表的基本操作。
- [P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)：帮助理解和掌握单调栈的使用。
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：结合了单调队列和ST表的思想，可加深对区间最值查询的理解。

### 个人心得摘录与总结
无。各题解主要围绕算法实现，未涉及个人调试经历、踩坑教训或顿悟感想等内容。 

---
处理用时：42.15秒
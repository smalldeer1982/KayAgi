# 题目信息

# Lorry

## 题目描述

给定整数 $n,v$。  

有一辆载重量为 $v$ 的货车，准备运送两种物品。物品 A 的重量为 $1$，物体 B 的重量为 $2$，每个物品都有一个价值 $p_i$。求货车可以运送的物品的最大价值。

## 样例 #1

### 输入

```
3 2
1 2
2 7
1 3
```

### 输出

```
7
2
```

# AI分析结果

### 题目内容
# Lorry

## 题目描述
给定整数 $n,v$ 。  
有一辆载重量为 $v$ 的货车，准备运送两种物品。物品 A 的重量为 $1$，物体 B 的重量为 $2$，每个物品都有一个价值 $p_i$ 。求货车可以运送的物品的最大价值。

## 样例 #1
### 输入
```
3 2
1 2
2 7
1 3
```
### 输出
```
7
2
```

### 题解综合分析与结论
- **思路方面**：多数题解利用贪心思想，基于物品重量仅1和2两种情况，将物品按重量分类处理。通过排序使价值高的物品优先被考虑，再结合不同策略确定两类物品选取数量以最大化价值。
- **算法要点**：常见做法是对两类物品按价值降序排序，通过枚举重量为1的物品数量，结合剩余空间确定重量为2的物品数量，计算总价值并更新最大值。部分题解采用前缀和优化，快速计算选取物品的价值总和，降低时间复杂度。
- **解决难点**：主要难点在于如何在两种重量物品组合的情况下找到最优解。一些题解通过贪心策略直接处理，另一些则在贪心基础上考虑特殊情况或进一步优化。例如，处理剩余一个空间时的不同情况讨论，以及基数排序等优化排序方式。

### 所选的题解
- **作者：Heartlessly (赞：19)  星级：5星**
    - **关键亮点**：思路清晰，代码规范完整。先按体积将物品分成两类并按价值从大到小排序，通过枚举体积为1的物品数量，利用前缀和快速计算体积为2的物品价值总和，从而找到最大价值及对应方案。
    - **重点代码核心实现思想**：定义结构体存储物品信息，通过重载`<`运算符实现按价值从大到小排序。利用前缀和数组`pre`记录体积为2的物品价值前缀和，在枚举体积为1的物品数量`i`时，快速计算剩余空间放体积为2的物品的价值总和，更新最大价值及对应位置。
```cpp
const int MAXN = 1e5;
int n, v, cnt1, cnt2, pos1, pos2, ans, sum, pre[MAXN + 5];
struct Node {
    int p, id;
    
    inline friend bool operator<(Node x, Node y) {
        return x.p > y.p;//按价值从大到小排序 
    }
} t1[MAXN + 5], t2[MAXN + 5];

int main() {
    read(n), read(v);
    for (int t, p, i = 1; i <= n; ++i) {
        read(t), read(p);
        if (t == 1) {
            t1[++cnt1].p = p;
            t1[cnt1].id = i;
        } else {
            t2[++cnt2].p = p;
            t2[cnt2].id = i;
        }//根据体积分成两类 
    }
    sort(t1 + 1, t1 + cnt1 + 1), sort(t2 + 1, t2 + cnt2 + 1);
    for (int i = 1; i <= cnt2; ++i) pre[i] = pre[i - 1] + t2[i].p;
    //预处理出体积为 2 的物品价值的前缀和 
    for (int i = 0; i <= min(v, cnt1); ++i) {//选了 i 个体积为 1 的物品 
        sum += t1[i].p;//体积为 1 的物品价值和
        //体积为 2 的物品选了 min(cnt2, (v - i) / 2) 个 
        if (sum + pre[min(cnt2, (v - i) / 2)] > ans) {//如果更优 
            ans = sum + pre[min(cnt2, (v - i) / 2)];
            pos1 = i, pos2 = min(cnt2, (v - i) / 2);//记录该方案的位置 
        }
    }
    // 后续为输出代码
}
```
- **作者：ahawzlc (赞：10)  星级：4星**
    - **关键亮点**：同样采用贪心结合前缀和优化的方式，代码简洁明了。利用`pair`存储物品价值和序号，按价值降序排序，通过枚举重量为1的物品数量计算最大价值并记录方案。
    - **重点代码核心实现思想**：定义`pair`数组`a`和`b`分别存储重量为1和2的物品信息，通过`cmp`函数实现降序排序。利用`num`数组记录重量为2的物品价值前缀和，在枚举重量为1的物品数量`i`时，结合前缀和计算总价值并更新最大价值及对应位置。
```cpp
pi a[100005],b[100005];
int t1,t2,num[100005];
int ans,sum,maxi,maxj;
bool cmp(pi a,pi b) {
    return a.F>b.F;
}
int main() {
    int n,v;
    n=read();
    v=read();
    for(re int i=1;i<=n;i++) {
        int opt=read(),x=read();
        if(--opt) b[++t2]=make_pair(x,i);
        else a[++t1]=make_pair(x,i);
    }
    sort(a+1,a+t1+1,cmp);
    sort(b+1,b+t2+1,cmp);
    for(int i=1;i<=t2;i++) {
        num[i]=num[i-1]+b[i].F;
    }
    for(re int i=0;i<=t1&&i<=v;i++) {
        int j=min((v-i)>>1,t2);
        sum+=a[i].F;
        if(sum+num[j]>ans) {
            ans=sum+num[j];
            maxi=i;
            maxj=j;
        }
    }
    // 后续为输出代码
}
```
- **作者：CrTsIr400 (赞：7)  星级：4星**
    - **关键亮点**：提出用基数排序优化时间复杂度至$O(n)$的思路，同时常规解法中利用贪心结合前缀和优化，代码注释详细。
    - **重点代码核心实现思想**：定义结构体数组`a`存储物品信息，通过`cmp`函数按价值降序排序。利用`p1`和`p2`数组记录物品序号，`s1`和`s2`数组记录价值前缀和，在枚举重量为1的物品数量`i`时，结合前缀和计算总价值并更新最大价值及对应位置。
```cpp
struct node
{
    int x,p;
}a[2][100001];
int n,m,maxx,t1,t2,l[2],p1[100001],p2[100001];
LL s1[100001],s2[100001],ans,ans1,ans2;
int c1[10001],c2[10001];
bool cmp(node t1,node t2)
{
    return t1.x>t2.x;
}
int main()
{
    in(n,m);
    Fu(i,1,n)
    {
        in(t1,t2);
        a[t1-1][++l[t1-1]].x=t2;
        a[t1-1][l[t1-1]].p=i;
    }
    sort(a[0]+1,a[0]+l[0]+1,cmp);
    sort(a[1]+1,a[1]+l[1]+1,cmp);
    Fu(i,1,l[0])s1[i]=s1[i-1]+a[0][i].x,p1[i]=a[0][i].p;
    Fu(i,1,l[1])s2[i]=s2[i-1]+a[1][i].x,p2[i]=a[1][i].p;
    Fu(i,0,min(l[0],m))
    {
        int j=min(l[1],(m-i)/2);
        if(i+j*2>m)continue;
        if(s1[i]+s2[j]>ans)ans=s1[i]+s2[j],ans1=i,ans2=j;
    }
    // 后续为输出代码
}
```

### 最优关键思路或技巧
- **贪心策略**：基于物品重量类型少的特点，按价值对物品排序，优先选择价值高的物品，通过枚举一类物品数量确定另一类物品数量，从而找到最大价值。
- **前缀和优化**：对重量为2的物品价值计算前缀和，在枚举重量为1的物品数量时，能$O(1)$时间复杂度得到重量为2的物品价值总和，降低整体时间复杂度。
- **排序优化**：在数据规模较大时，如$n\le 10^7$，可使用基数排序将排序时间复杂度从$O(n \log n)$降至$O(n)$，进一步优化算法。

### 同类型题或类似算法套路拓展
同类型题通常具有物品类型有限、背包容量固定等特点，可采用贪心结合前缀和优化的方法。类似套路如先按某一属性（如单位重量价值）对物品排序，再通过枚举部分物品数量结合剩余空间确定其他物品数量，计算最优值。同时可考虑特殊情况（如剩余空间处理）及优化排序方式以提升效率。

### 洛谷相似知识点题目推荐
- **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略，每次选择最小的两个数合并，与本题贪心选择价值高的物品类似。
- **P1199 [NOIP2010 普及组] 三国游戏**：同样涉及物品选择与价值最大化问题，需运用贪心思想结合排序解决。
- **P2123 皇后游戏**：通过对物品按特定规则排序，利用贪心策略求解最优值，与本题思路有相似之处。 

---
处理用时：43.18秒
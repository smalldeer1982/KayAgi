# 题目信息

# Coprocessor

## 题目描述

给你 $N$ 个任务，任务从 $0$ 开始标号，有些只能用主处理器处理，另外的任务只能用副处理器处理。其中存在 $M$ 个依赖关系，如果任务 $i$ 依赖于任务 $j$，那么称 $j$ 是 $i$ 的前继任务。

主处理器和副处理器都可以一次处理很多个任务。一个任务能被处理的条件为其所有的前继任务已经被执行过了，或者前继任务和自己同时被放进同一个处理器处理。


现在给出这些依赖关系和每个任务处理要用的处理器，求副处理器最少运行了几次。保证依赖关系是一张有向无环图。

## 样例 #1

### 输入

```
4 3
0 1 0 1
0 1
1 2
2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 3
1 1 1 0
0 1
0 2
3 0
```

### 输出

```
1
```

# AI分析结果

### 题目内容
# Coprocessor

## 题目描述
给你 $N$ 个任务，任务从 $0$ 开始标号，有些只能用主处理器处理，另外的任务只能用副处理器处理。其中存在 $M$ 个依赖关系，如果任务 $i$ 依赖于任务 $j$，那么称 $j$ 是 $i$ 的前继任务。

主处理器和副处理器都可以一次处理很多个任务。一个任务能被处理的条件为其所有的前继任务已经被执行过了，或者前继任务和自己同时被放进同一个处理器处理。

现在给出这些依赖关系和每个任务处理要用的处理器，求副处理器最少运行了几次。保证依赖关系是一张有向无环图。

## 样例 #1
### 输入
```
4 3
0 1 0 1
0 1
1 2
2 3
```
### 输出
```
2
```

## 样例 #2
### 输入
```
4 3
1 1 1 0
0 1
0 2
3 0
```
### 输出
```
1
```

### 题解综合分析与结论
所有题解思路基本一致，均基于贪心与拓扑排序。由于题目要求副处理器运行次数最少，所以贪心策略为优先让主处理器处理任务，待主处理器无可处理任务时，再处理副处理器任务，这样能保证每次副处理器处理的任务尽可能多，从而使副处理器运行次数最少。算法要点在于利用拓扑排序，通过两个队列分别维护主、副处理器可处理的任务（入度为0的任务），每次先处理主处理器队列中的任务，处理完后若副处理器队列不为空，则副处理器运行次数加1，并处理副处理器队列中的任务，循环此过程直至所有任务处理完毕。解决难点在于理解并实现这种结合贪心思想的拓扑排序方式，正确处理任务间的依赖关系以及主副处理器的协同工作。

### 所选的题解
- **作者：dd_d (5星)**
    - **关键亮点**：思路阐述清晰，从题意分析到具体解法逐步推进，代码注释详细，对输入输出函数进行了封装，可读性强。
    - **核心代码片段**：
```cpp
while (!q1.empty()||!q2.empty())
{
    while (!q1.empty())
    {
        int u=q1.front();
        q1.pop();
        for (int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            f[v]--;
            if (f[v]==0)
            {
                if (vis[v]==0) q1.push(v);
                else q2.push(v); 
            }
        }
    }
    if (!q2.empty()) ans++;
    while (!q2.empty())
    {
        int u=q2.front();
        q2.pop();
        for (int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            f[v]--;
            if (f[v]==0)
            {
                if (vis[v]==0) q1.push(v);
                else q2.push(v); 
            }
        }
    }
}
```
    - **核心实现思想**：通过两个while循环，先处理主处理器队列q1中的任务，更新任务入度并将新的入度为0的任务加入相应队列；若此时副处理器队列q2不为空，则副处理器运行次数ans加1，再处理q2中的任务，同样更新入度和入队新任务。
- **作者：water_tomato (4星)**
    - **关键亮点**：对题意中“或”的含义解释详细，解析部分清晰阐述贪心思想，代码结构清晰，使用结构体和函数封装图的相关操作。
    - **核心代码片段**：
```cpp
while((!qmain.empty())||(!qco.empty())){
    while(!qmain.empty()){//优先处理主处理器能处理的 
        int u=qmain.front();
        qmain.pop();
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].to;
            ru[v]--;
            if(!ru[v]){
                if(!a[v]) qmain.push(v);
                else qco.push(v);
            }
        }
    }
    if(!qco.empty())
        ans++;//如果需要副处理器处理的话就将处理次数+1 
    while(!qco.empty()){//一次性把所有能一起处理的任务都处理掉 
        int u=qco.front();
        qco.pop();
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].to;
            ru[v]--;
            if(!ru[v]){
                if(!a[v]) qmain.push(v);
                else qco.push(v);
            }
        }
    }
}
```
    - **核心实现思想**：与上一题解类似，优先处理主处理器队列qmain中的任务，更新入度并分配新入度为0的任务到相应队列；若副处理器队列qco不为空则ans加1，再处理qco中的任务并更新入度和入队新任务。
- **作者：Mason123456 (4星)**
    - **关键亮点**：对题目翻译详细，思路部分对拓扑排序结合两个队列处理任务的原因解释清晰，代码简洁明了，使用了C++的标准库和现代语法。
    - **核心代码片段**：
```cpp
while(q1.size() || q2.size()) {
    while(!q1.empty()) {// 先跑主处理器
        int u = q1.front();
        q1.pop();
        for(auto v : g[u])
            if(--indeg[v] == 0) {
                if(a[v])	q2.push(v);// 赋值操作需要分队列来区分两个处理器
                else	q1.push(v);
            }
    }
    if(q2.size())	ans++;// 可以一次处理完就直接答案+1
    while(!q2.empty()) {// 再跑协处理器
        int u = q2.front();
        q2.pop();
        for(auto v : g[u])
            if(--indeg[v] == 0) {
                if(a[v])	q2.push(v);
                else	q1.push(v);
            }
    }
}
```
    - **核心实现思想**：通过两个while循环，先处理主处理器队列q1中的任务，更新入度并根据任务所需处理器将新入度为0的任务分配到q1或q2；若q2不为空则ans加1，再处理q2中的任务并更新入度和分配新任务。

### 最优关键思路或技巧
利用贪心思想与拓扑排序结合，优先处理主处理器任务，保证副处理器每次处理任务量最大从而减少运行次数。在代码实现上，使用两个队列分别维护主副处理器可处理任务，清晰简洁地实现任务的拓扑排序和处理器的协同工作。

### 可拓展之处
同类型题常考察有向无环图（DAG）上的任务调度、资源分配等问题，类似算法套路为根据题目要求确定贪心策略，结合拓扑排序处理任务依赖关系。例如在一些带有时间限制、资源限制的任务调度问题中，同样可利用拓扑排序确定任务执行顺序，再结合贪心策略优化资源使用或完成时间。

### 洛谷相似题目推荐
- [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)：通过建立有向图和拓扑排序，根据列车停靠站信息确定车站等级，与本题类似在于利用拓扑排序处理元素间的顺序关系。
- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)：涉及有向图的缩点操作，缩点后形成DAG，再进行相关计算，本题虽未涉及缩点，但同样基于DAG进行拓扑排序处理问题，思路有相通之处。
- [P2883 [USACO07MAR]牛交通Cow Traffic](https://www.luogu.com.cn/problem/P2883)：通过建立有向图，利用拓扑排序解决奶牛路径规划问题，与本题类似，均是在有向图上根据一定规则利用拓扑排序解决实际问题。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：37.31秒
# 题目信息

# Points in Segments

## 题目描述

有n条线段在数轴Ox上，每条线段有介于1到m之间的整数端点。线段之间可以重合、覆盖甚至相同。每条线段由两个整数li和ri描述（1<=li<=ri<=m）--对应左、右端点。

考虑1到m之间的所有整数点。要求你输出所有的不属于任何线段的点。

当且仅当点l<=x<=r时，点x属于这条线段。

## 样例 #1

### 输入

```
3 5
2 2
1 2
5 5
```

### 输出

```
2
3 4 
```

## 样例 #2

### 输入

```
1 7
1 7
```

### 输出

```
0

```

# AI分析结果



# Points in Segments

## 题目描述

在数轴Ox上有n条线段，每条线段的端点都是1到m之间的整数。线段可以重叠、覆盖甚至完全相同。每条线段由两个整数li和ri描述（1<=li<=ri<=m），表示左右端点。

需要输出所有不属于任何线段的整数点（1到m之间）。

## 样例 #1

### 输入

```
3 5
2 2
1 2
5 5
```

### 输出

```
2
3 4 
```

## 样例 #2

### 输入

```
1 7
1 7
```

### 输出

```
0
```

**算法分类**：差分

---

### 题解分析与结论

#### 核心思路对比
1. **暴力标记法**：遍历每个线段的每个点标记覆盖情况，时间复杂度O(n*m)
2. **差分法**：利用差分数组标记区间变化，前缀和计算覆盖次数，时间复杂度O(n+m)
3. **树状数组/线段树**：适用于动态区间查询，但本题无需动态维护，属于过度设计

#### 最优解法：差分法
通过差分数组记录区间变化，前缀和快速计算覆盖状态。时间复杂度最优且代码简洁。

---

### 精选题解

#### 题解1：差分法（作者：2132B，⭐⭐⭐⭐⭐）
**核心亮点**：
- 差分数组实现高效区间标记
- 时间复杂度O(n+m)，空间优化
```cpp
int vis[150]; // 差分数组
for(int i=1;i<=n;i++){
    cin >> l >> r;
    vis[l-1]++; vis[r]--; // 标记区间
}
int s = 0;
for(int i=0;i<=m-1;i++){ // 计算前缀和
    s += vis[i];
    if(s == 0) ans++; // 统计未覆盖点
}
```

#### 题解2：暴力标记（作者：sinsop90，⭐⭐⭐⭐）
**核心亮点**：
- 代码直观易实现
- 适合小数据范围
```cpp
bool mps[105];
for(int j=x;j<=y;j++){ // 暴力标记覆盖点
    if(!mps[j]) ans--;
    mps[j] = true;
}
```

---

### 关键技巧总结
1. **差分数组**：区间修改时只需修改首尾，通过前缀和还原覆盖状态
2. **逆向统计**：初始化总点数，每标记一个新点就减少剩余计数

---

### 拓展练习
1. [校门外的树（洛谷 P1047）](https://www.luogu.com.cn/problem/P1047)
2. [区间和（洛谷 P2367）](https://www.luogu.com.cn/problem/P2367)
3. [最大子段和（洛谷 P1115）](https://www.luogu.com.cn/problem/P1115)

---

### 心得摘录
> "差分法的前缀和计算部分容易出错，需要仔细验证区间端点处理" —— 2132B  
> "树状数组解法虽然正确，但实测跑不过暴力，可能数据规模太小" —— TRZ_2007

---
处理用时：76.43秒
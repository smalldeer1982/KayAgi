# 题目信息

# Badge

## 题目描述

在一所学校，如果一个学生表现不好，老师就会在他的徽章上打一个洞。今天，老师逮到了n名学生在搞恶作剧。

这些学生从1到n编号。老师先逮到了a学生然后在他的徽章上打了个洞。但是这个学生说带头的是另一个学生pa。

于是老师又抓住学生pa在他的徽章上也打了个洞。这个学生又说其实是学生ppa在带头搞恶作剧。

这个过程一直持续了好一会儿，不过因为这些学生是有限的，最后老师抓住了一个徽章上已经有一个洞的学生。

在给这个倒霉孩子的徽章上又打了个洞以后，老师觉得有点累，需要蒸个桑拿于是他就不再继续了。

你不知道谁是老师逮到的第一个学生，但是你知道所有的数字pi。对于每一个a，如果第一个被逮到的学生是a，你的任务是找到谁会是徽章上面有两个洞的学生。

## 说明/提示

![图片](http://codeforces.com/predownloaded/e6/2f/e62f6279b291a91d10dcf8b13b483a9dc5659758.png)

当a = 1, 老师的打洞顺序是1->2->3->2，输出2（2的徽章上会有俩洞）；

当a = 2, 老师的打洞顺序是 2->3->2，输出2； 当a = 3，老师的打洞顺序是3->2->3，输出3。

对于第二个样例，不管老师先逮到谁，这个第一个被老师逮到的倒霉孩子将会得到两个洞。

## 样例 #1

### 输入

```
3
2 3 2
```

### 输出

```
2 2 3 
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
1 2 3 
```

# AI分析结果



### 中文重写题目

#### Badge

##### 题目描述

在一所学校里，当学生行为不端时，老师会在其徽章上打洞。今天老师逮到n名参与恶作剧的学生，编号为1到n。

老师首先抓住学生a并打洞，该学生声称主谋是学生pa。老师接着找到pa打洞，pa又指向ppa。此过程持续直到某个已被打洞的学生再次被访问，此时该学生将获得第二个洞。

给定所有pi（每个学生指认的对象），要求对每个起始学生a（1≤a≤n），确定最终获得两个洞的学生编号。

##### 样例

样例1输入：
```
3
2 3 2
```
输出：
```
2 2 3

样例解释：
当a=1时，路径为1→2→3→2，输出2；
当a=2时，路径为2→3→2，输出2；
当a=3时，路径为3→2→3，输出3。
```

---

### 算法分类
**模拟**

---

### 题解对比与结论

#### 核心思路
所有题解本质都是模拟访问过程：
1. **暴力模拟**：从每个起点出发，沿指针链遍历，使用标记数组记录访问状态，第一个重复访问的节点即为答案。
2. **时间复杂度**：O(n²)，由于n≤1000，完全可行。
3. **优化尝试**：部分题解提及基环树性质，通过预处理环结构可将时间优化至O(n)，但实现复杂，在本题数据范围下必要性不大。

#### 最优思路提炼
直接模拟遍历过程即可高效解决：
- **标记数组**：记录节点是否被访问过。
- **循环/递归**：沿指针链移动，直到遇到已标记节点。

---

### 高星题解推荐

1. **题解作者：RiceFruit（4星）**
   - **亮点**：代码简洁，递归实现直观，逻辑清晰。
   - **核心代码**：
     ```cpp
     int h(int x) {
         if (b[x]) return x; // 已访问则返回当前节点
         b[x] = 1;          // 标记访问
         return h(a[x]);    // 递归下一个节点
     }
     ```

2. **题解作者：virtualman（4星）**
   - **亮点**：循环实现，无递归栈溢出风险，适合理解基础流程。
   - **核心代码**：
     ```cpp
     int pan(int x) {
         memset(book, 0, sizeof(book));
         int now = x;
         while (1) {
             book[now]++;           // 访问计数
             now = p[now];          // 移动指针
             if (book[now] == 2) return now; // 第二次访问时返回
         }
     }
     ```

3. **题解作者：Mabangjie6789（3.5星）**
   - **亮点**：使用计数数组，允许扩展至需要统计更多访问次数的场景。
   - **核心代码**：
     ```cpp
     int js = i;
     while (true) {
         ch[js]++;                 // 访问次数累加
         if (ch[js] == 2) {        // 找到第一个两次访问的节点
             cout << js << " ";
             break;
         }
         js = p[js];               // 移动指针
     }
     ```

---

### 相似题目推荐
1. **P2661 [NOIP2015 提高组] 信息传递**（最小环检测）
2. **P1144 最短路计数**（路径遍历与标记）
3. **P2921 [USACO08DEC] Trick or Treat on the Farm**（基环树遍历）

---
处理用时：43.73秒
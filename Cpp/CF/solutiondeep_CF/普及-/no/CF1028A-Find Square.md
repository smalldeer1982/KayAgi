# 题目信息

# Find Square

## 题目描述

一块矩形有n × m个白色格子，把其中的一些格子涂成黑色，形成一大块黑色的正方形格子，正方形的边长为奇数。找出这个正方形的中心点。

## 样例 #1

### 输入

```
5 6
WWBBBW
WWBBBW
WWBBBW
WWWWWW
WWWWWW
```

### 输出

```
2 4
```

## 样例 #2

### 输入

```
3 3
WWW
BWW
WWW
```

### 输出

```
2 1
```

# AI分析结果



# Find Square

## 题目描述  
一块矩形有n × m个白色格子，把其中的一些格子涂成黑色，形成一大块黑色的正方形格子，正方形的边长为奇数。找出这个正方形的中心点。

## 样例 #1  
### 输入  
```
5 6
WWBBBW
WWBBBW
WWBBBW
WWWWWW
WWWWWW
```  
### 输出  
```
2 4
```  

## 样例 #2  
### 输入  
```
3 3
WWW
BWW
WWW
```  
### 输出  
```
2 1
```  

---

### 算法分类  
模拟  

---

### 题解分析与结论  
所有题解均基于以下核心逻辑：**通过遍历矩阵确定正方形的边界坐标，取平均计算中心点**。存在两种等价实现方式：  
1. **首尾法**：记录第一个和最后一个出现的B坐标  
2. **极值法**：记录所有B的行列最小值与最大值  

两种方法本质相同，因题目保证存在唯一的正方形，边界坐标的极值必然对应正方形顶点。时间复杂度均为O(nm)，空间复杂度O(1)。

---

### 高分题解精选  

#### 题解1（作者：yxy666） ★★★★☆  
**亮点**：  
- 极值法思路清晰，通过min/max维护四个边界  
- 代码结构简洁，变量命名直观  
**核心代码**：  
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(ch=='B'){
            L=min(L,j); U=min(U,i);
            R=max(R,j); D=max(D,i);
        }
    }
}
printf("%d %d\n",(D+U)/2,(R+L)/2);
```

#### 题解2（作者：hanyuchen2019） ★★★★☆  
**亮点**：  
- 边读入边处理，无需存储整个矩阵  
- 注释详细，特别强调输入处理的细节  
**核心代码**：  
```cpp
if(c=='B'){
    if(k==1) { x1=i,y1=j; k=0; }
    x2=i,y2=j; // 动态更新最后一个B
}
cout<<(x1+x2)/2<<" "<<(y1+y2)/2;
```

#### 题解3（作者：BINYU） ★★★★☆  
**亮点**：  
- 明确图解说明顶点与中心的关系  
- 代码简洁，利用循环顺序特性直接获取顶点  
**核心代码**：  
```cpp
if(c == 'B'){
    if(sx == 0) sx = i, sy = j; // 首个B
    ex = i, ey = j; // 持续更新最后一个B
}
cout<<(sx + ex)/2<<" "<<(sy + ey)/2;
```

---

### 关键思路总结  
1. **边界极值思想**：利用极值确定几何图形边界  
2. **动态更新技巧**：无需存储全矩阵，遍历时实时维护关键坐标  
3. **输入流控制**：注意换行符处理，推荐逐字符读取  

---

### 拓展与相似题目  
1. [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)（极值维护）  
2. [P2556 黑白图像](https://www.luogu.com.cn/problem/P2556)（矩阵连通块处理）  
3. [CF177B2 矩形计数](https://codeforces.com/problemset/problem/177/B2)（极值+数学计算）

---
处理用时：91.10秒
# 题目信息

# Palindrome Dance

## 题目描述

### 题目大意
给你一个序列，里面的元素只能是 $0,1$ 或 $2$，$2$ 可以通过代价换成 $1$ 或者 $0$，问形成**仅包含 $0,1$** 的回文串的最小代价。

## 样例 #1

### 输入

```
5 100 1
0 1 2 1 2
```

### 输出

```
101
```

## 样例 #2

### 输入

```
3 10 12
1 2 0
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3 12 1
0 1 0
```

### 输出

```
0
```

# AI分析结果



### 题目重写
# 回文舞步

## 题目描述
给定一个长度为 $n$ 的序列，元素为 $0,1,2$。其中 $2$ 可替换为 $0$（代价 $a$）或 $1$（代价 $b$）。求将其转换为仅含 $0,1$ 的回文串的最小代价，若无法转换输出 $-1$。

---

### 算法分类
贪心

---

### 题解分析与结论
所有题解均基于对称位置配对处理的贪心思路。关键点在于分类讨论对称位置的元素状态，优先处理可替换的 $2$，选择代价最小的替换方式，并及时处理无解情况。

#### 最优思路总结
1. **对称配对处理**：遍历前 $n/2$ 对元素，每对元素需满足回文要求。
2. **分类讨论**：
   - 两边均为 $2$：替换为代价较小的数字，总代价加两倍最小代价。
   - 单边为 $2$：替换为另一边的数字，累加对应代价。
   - 非 $2$ 且不等：直接无解。
3. **奇偶处理**：若 $n$ 为奇数且中间元素为 $2$，需额外处理中间位置。

#### 推荐题解
1. **风之城0（4星）**  
   **亮点**：逻辑清晰，对称位置处理完整，代码简洁。  
   **核心代码**：
   ```cpp
   for(int i=1;i<=int(n/2);i++){
       if(a[i]==a[n-i+1] && a[i]==2)
           ans += mn(a1,b)*2; // 均为2的情况
       else if(a[i]!=a[n-i+1]){
           if(a[i]==2) ans += (a[n-i+1]==0 ? a1 : b); // 单边为2的情况
           else if(a[n-i+1]==2) ans += (a[i]==0 ? a1 : b);
           else { puts("-1"); return 0; } // 无法转换
       }
   }
   if(n%2==1 && a[n/2+1]==2) ans += mn(a1,b); // 中间位置处理
   ```

2. **makerlife（4星）**  
   **亮点**：详细注释与错误处理，特判中间元素。  
   **关键技巧**：显式修改数组元素确保后续判断正确，避免逻辑错误。

---

### 拓展思考
类似问题可转化为对称位置约束下的最优决策，例如：[CF1294F](https://codeforces.com/problemset/problem/1294/F)（构造特定结构）、[P1215 母亲的牛奶](https://www.luogu.com.cn/problem/P1215)（状态转换中的贪心选择）。

---

### 推荐相似题目
1. [P1435 回文字串](https://www.luogu.com.cn/problem/P1435)  
2. [CF1326C Permutation Partitions](https://codeforces.com/problemset/problem/1326/C)  
3. [P2894 酒店](https://www.luogu.com.cn/problem/P2894)

---
处理用时：44.33秒
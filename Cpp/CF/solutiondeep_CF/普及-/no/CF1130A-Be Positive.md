# 题目信息

# Be Positive

## 题目描述

有一个包含nnn个整数的数组,你需要找到一个非零整数$d(-10^3\leq d \leq 10^3)$，使数组中的每一个数组除以d的商中至少有一半为正数(即至少有$\frac{n}{2}$个)注意:"正数"只要求商大于0,不要求一定是整数。如果有多个$d$满足条件，输出其中的任意一个,如果没有这样的$d$则输出$0$。

## 样例 #1

### 输入

```
5
10 0 -7 2 6```

### 输出

```
4```

## 样例 #2

### 输入

```
7
0 0 1 -1 0 0 2
```

### 输出

```
0```

# AI分析结果



# Be Positive

## 题目描述

给定一个包含 $n$ 个整数的数组，找到一个非零整数 $d$（$-10^3 \leq d \leq 10^3$），使得数组中每个元素除以 $d$ 后的商中至少有一半为正数。若有多个解输出任意一个，无解输出 $0$。

---

**算法分类**：数学、枚举

---

### 题解分析与结论

#### 核心思路对比
1. **数学统计法**（主流解法）：
   - 统计正数、负数和零的数量。
   - 若正数数量 ≥ 半数（向上取整），输出 1（正数除以 1 仍为正）。
   - 若负数数量 ≥ 半数，输出 -1（负数除以 -1 变为正）。
   - 否则输出 0。
   - **关键观察**：d=1 或 -1 能将原数组中正/负数直接转化为正数，最大化满足条件的可能性。

2. **暴力枚举法**：
   - 遍历所有可能的 $d$（-1000 到 1000，跳过 0）。
   - 对每个 $d$，统计商为正数的元素数量。
   - 找到第一个符合条件的 $d$ 即输出。
   - **优势**：代码直观，保证找到所有可能的解。

#### 解决难点
- **数学方法**的关键在于正确计算半数（需向上取整）和分类讨论。
- **枚举法**需要处理浮点数比较的精度问题，但通过将除法转化为乘法（判断 $a_i \cdot d > 0$）巧妙规避。

---

### 高分题解推荐

#### 1. [pxy1118] ⭐⭐⭐⭐
**核心思路**：
- 统计正数、负数、零的数量。
- 通过向上取整计算半数，判断正/负数是否满足条件。
**代码亮点**：
```cpp
int x=ceil(double(n/2.0));
if(z>=x)cout<<"1\n";      // 正数足够
else if(n-z-l>=x)cout<<"-1\n"; // 负数足够
else cout<<"0\n";         // 无解
```

#### 2. [WKAHPM] ⭐⭐⭐⭐
**核心思路**：
- 暴力枚举所有可能的 $d$，通过判断 $a_i \cdot d > 0$ 统计正商数量。
**代码亮点**：
```cpp
for(int i=-1000;i<=1000;i++) {
    if(i==0) continue;
    int sum=0;
    for(int j=1;j<=n;j++) {
        if(a[j]*i>0) sum++; // 同符号则为正商
    }
    if(2*sum>=n) {          // 满足半数
        cout<<i; return 0;
    }
}
```

#### 3. [Eason_AC] ⭐⭐⭐⭐
**核心思路**：
- 使用条件表达式处理半数向上取整。
**代码亮点**：
```cpp
if(pos >= (n%2 ? n/2+1 : n/2)) printf("1");
else if(neg >= (n%2 ? n/2+1 : n/2)) printf("-1");
else printf("0");
```

---

### 最优思路总结
**数学统计法**是本题最优解：
1. 时间复杂度仅为 $O(n)$，显著优于枚举法的 $O(2000n)$。
2. 通过符号分析，将问题转化为简单的计数问题，无需复杂计算。
3. 正确处理了半数向上取整的关键细节。

---

### 同类题目推荐
1. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（数学推导）
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)（枚举+数学）
3. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)（数学性质+枚举优化）

---
处理用时：186.86秒
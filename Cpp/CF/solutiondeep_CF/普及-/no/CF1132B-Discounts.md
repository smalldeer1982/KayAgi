# 题目信息

# Discounts

## 题目描述

输入n个整数($a_1...a_n$)和 $m$ 个整数( $q_1...q_m$ )。求在去掉第 $q_i$ 大的数字后，$n-1$ 个整数的和。

## 说明/提示

样例中，输入3，去掉数组中第3大的整数7，剩下的数字和为27；输入4，去掉数组中第4大的数字4，和为30。

## 样例 #1

### 输入

```
7
7 1 3 1 4 10 8
2
3 4
```

### 输出

```
27
30
```

# AI分析结果



# Discounts（折扣）

## 题目描述
输入 $n$ 个整数（$a_1...a_n$）和 $m$ 个整数（$q_1...q_m$）。求在去掉第 $q_i$ 大的数字后，$n-1$ 个整数的和。

## 算法分类
排序

---

## 题解分析与结论

### 核心思路对比
所有题解均采用以下核心步骤：
1. **预计算总和**：先计算所有元素的总和
2. **排序数组**：排序后快速定位第 $q_i$ 大的元素
3. **索引计算**：通过排序后的索引直接获取目标元素

**差异点**：
- 排序方向：升序排序需计算反向索引（`a[n-q+1]`），降序排序可直接取 `a[q]`
- 数据范围处理：均强调使用 `long long` 防止溢出

---

## 精选题解（评分≥4★）

### 1. 作者：Da_un（5★）
**关键亮点**：
- 降序排序逻辑直观，直接通过 `a[q]` 获取第 $q$ 大元素
- 使用 `scanf` 提升输入效率
- 完整处理大数据范围和溢出问题

**核心代码**：
```cpp
sort(a+1, a+n+1, cmp); // 降序排序
printf("%lld\n", sum - a[q]); // 直接取第q大的元素
```

### 2. 作者：kon_tori（4★）
**关键亮点**：
- 强调 `long long` 的必要性
- 提供快读模板优化输入
- 升序排序反向索引计算完整

**核心代码**：
```cpp
sort(a+1, a+n+1); // 升序排序
cout << sum1 - a[n-h+1]; // 计算反向索引
```

### 3. 作者：Zechariah（4★）
**关键亮点**：
- 代码简洁，索引计算清晰
- 使用快读处理大数据输入
- 升序排序反向索引实现正确

**核心代码**：
```cpp
sort(a+1, a+n+1); // 升序排序
cout << ans - a[n-x+1]; 
```

---

## 最优技巧总结
1. **排序方向选择**：降序排序直接对应第 $q$ 大元素，逻辑更直观
2. **溢出防御**：总和及数组元素必须使用 `long long`
3. **输入优化**：大数据量时使用 `scanf` 或快读提升效率

---

## 同类题目推荐
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)
3. [P1138 第 k 小整数](https://www.luogu.com.cn/problem/P1138)

---

## 心得摘录
- **kon_tori**："不开 long long 见祖宗" → 大数据求和必用长整型
- **Da_un**：降序排序使索引计算更直观，避免反向计算错误
- **atarashiTLE**：0-based 数组需重新推导索引公式，易错点需仔细验证

---
处理用时：122.48秒
# 题目信息

# Good String

## 题目描述

有一个长度为$n(1<=n<=100)$的字符串，只由<,>两种字符组成。对其进行一次操作如下：


------------

如果选择一个>字符，这个字符**右面**的那一个字符会被删除。特别地，如果你选择的这个字符>位于字符串的最右侧，什么都不会发生。同理，如果选择一个<字符，这个字符**左面**的那一个字符会被删除，选择位于字符串最左边的<字符也什么都不会发生。


------------

定义一下的一个字符串是“好的”：经过若干次以上操作，这个字符串可以只含有一种字符，如>,>>等。

在执行操作之前，你可以删去字符串中的$k(0<=k<=n-1)$$个字符。注意不可以把整个字符串都删去了。

你需要找出$k$的最小值，使得删去$k$个字符后的字符串是“好的”。

## 说明/提示

第一组数据中，删除任意一个字符都可以使得剩下的字符串是“好的”。

第二组数据中，原字符串就是“好的”，无需删除任何字符。

## 样例 #1

### 输入

```
3
2
<>
3
><<
1
>```

### 输出

```
1
0
0
```

# AI分析结果



# 题目中文翻译

## 题目描述

有一个长度为 $n(1 \leq n \leq 100)$ 的字符串，仅由 `<` 和 `>` 两种字符组成。一次操作规则如下：

- 选择一个 `>` 字符，删除其右侧的字符（若 `>` 位于最右侧则无操作）。
- 选择一个 `<` 字符，删除其左侧的字符（若 `<` 位于最左侧则无操作）。

定义「好的字符串」为：经过若干次操作后，可以只剩单一字符（如 `>`, `>>`, `<` 等）。

在执行操作前，允许删除 $k$ 个字符（不能全删），求使剩余字符串成为「好的字符串」的最小 $k$。

## 说明/提示

样例1中，删除任意一个字符均可满足要求；样例2中原字符串已满足条件。

---

**算法分类**：贪心

---

## 题解分析与结论

所有题解的核心思路均为：**统计字符串左侧连续 `<` 的数量和右侧连续 `>` 的数量，取较小值**。这是因为：
- 若剩余字符串最左为 `>`，则可通过操作删去右侧所有字符。
- 若最右为 `<`，则可通过操作删去左侧所有字符。
因此，最小删除次数即为使左侧出现 `>` 或右侧出现 `<` 所需删除的最小字符数。

---

## 精选题解

### 题解1（作者：saixingzhe，5星）
**关键亮点**：思路清晰，代码简洁。
```cpp
int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        cin >> s;
        int a1 = 0, a2 = 0;
        int i = 0;
        // 统计左侧连续 '<' 的数量
        while (s[i] == '<' && i < n) a1++, i++;
        int j = n - 1;
        // 统计右侧连续 '>' 的数量
        while (s[j] == '>' && j >= 0) a2++, j--;
        printf("%d\n", min(a1, a2));
    }
}
```

### 题解2（作者：lightningZ，5星）
**关键亮点**：变量命名直观，逻辑直白。
```cpp
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d%s", &n, a + 1);
        int x = 1, ans = 0, ans1 = 0;
        // 从左找第一个 '>'，统计删除次数
        while (a[x] == '<') ans++, x++;
        // 从右找第一个 '<'，统计删除次数
        while (a[n] == '>') ans1++, n--;
        printf("%d\n", min(ans, ans1));
    }
}
```

### 题解3（作者：lrmlrm_，5星）
**关键亮点**：分析详尽，代码规范。
```cpp
int main() {
    scanf("%d", &t);
    while (t--) {
        cin >> st;
        int suml = 0, sumr = 0;
        // 右侧连续 '>' 计数
        for (int j = st.size()-1; j >=0 && st[j]=='>'; j--) suml++;
        // 左侧连续 '<' 计数
        for (int i=0; i<st.size() && st[i]=='<'; i++) sumr++;
        printf("%d\n", min(suml, sumr));
    }
}
```

---

## 核心思路总结
**关键技巧**：利用贪心思想，只需关注字符串两端连续字符的数量。通过预处理左右两侧的连续字符，快速确定最小删除次数。

**同类型拓展**：类似问题可参考「边界条件决定整体性质」的贪心题，如 [CF1144F. Graph Without Long Directed Paths](https://www.luogu.com.cn/problem/CF1144F)。

---

## 推荐练习题
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心策略）
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（贪心排序）
3. [CF978B File Name](https://www.luogu.com.cn/problem/CF978B)（连续字符处理）

---
处理用时：149.72秒
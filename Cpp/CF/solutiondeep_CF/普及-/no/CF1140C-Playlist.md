# 题目信息

# Playlist

## 题目描述

你有一个有 $n$ 首歌曲的播放列表，第 $i$ 首歌有 $t_i$ 和 $b_i$ 两个特征——分别是它的长度和好听程度。

听这些歌的快乐程度等于这些歌的总长度乘他们中的最小的好听程度。举个例子，听三首长度为 $[5, 7, 4]$ 而好听程度为 $[11, 14, 6]$ 的歌曲获得的快乐程度等于 $(5 + 7 + 4) \times 6 = 96$。

你需要从你的播放列表中选出最多 $k$ 首歌，使听这些歌的快乐程度尽可能的大。

## 样例 #1

### 输入

```
4 3
4 7
15 1
3 6
6 8
```

### 输出

```
78
```

## 样例 #2

### 输入

```
5 3
12 31
112 4
100 100
13 55
55 50
```

### 输出

```
10000
```

# AI分析结果



# Playlist

## 题目描述

你有一个包含 $n$ 首歌曲的播放列表，第 $i$ 首歌曲有两个特征：长度 $t_i$ 和好听程度 $b_i$。

听这些歌曲的快乐程度等于所选歌曲总长度乘以其中最小的好听程度。例如，三首长度分别为 $[5, 7, 4]$、好听程度为 $[11, 14, 6]$ 的歌曲，快乐值为 $(5+7+4) \times 6 = 96$。

需要从播放列表中选出最多 $k$ 首歌曲，使得快乐程度最大化。

## 算法分类
贪心

---

## 题解综合分析

### 核心思路
将歌曲按好听度升序排列，逆序遍历时用优先队列维护最大的k个长度值。时间复杂度 $O(n \log k)$。

### 关键技巧
1. **排序方向**：按 $b_i$ 升序排序后逆序遍历，保证当前处理的 $b_i$ 是所选集合的最小值
2. **堆优化**：用小根堆动态维护最大的k个长度值，当堆大小超过k时弹出最小值
3. **实时更新**：在遍历过程中计算当前堆内元素总和与当前 $b_i$ 的乘积，维护全局最大值

---

## 精选题解

### 题解1 - EricWan（★★★★☆）
**亮点**：详细思路演进，负数转换实现小根堆
```cpp
sort(a + 1, a + n + 1, cmp); // 按b升序排序
priority_queue<long long> q;  // 用大根堆存负数模拟小根堆
for (int i = n; i >= 1; i--) {
    q.push(-a[i].t);
    sum += a[i].t;
    if (n - i + 1 > k) {
        sum += q.top();  // 堆顶是最小的实际长度（负数相加等价于减正数）
        q.pop();
    }
    ans = max(ans, a[i].b * sum);
}
```

### 题解2 - xht（★★★★☆）
**亮点**：反向排序+常规小根堆实现
```cpp
sort(a + 1, a + n + 1);     // 按b升序排序
reverse(a + 1, a + n + 1);  // 反转得到降序序列
priority_queue<int> q;       // 存储负数的常规堆
for (int i = 1; i <= n; i++) {
    now += a[i].second;
    q.push(-a[i].second);   // 压入负数
    if (q.size() > k) {
        now += q.top();     // 弹出最小的实际长度
        q.pop();
    }
}
```

### 题解3 - SolIII（★★★★☆）
**亮点**：显式使用小根堆模板
```cpp
priority_queue<int, vector<int>, greater<int>> q; // 标准小根堆
sort(a + 1, a + 1 + n, cmp); // 按b降序排序
for (int i = 1; i <= n; i++) {
    sum += a[i].t;
    q.push(a[i].t);
    if (q.size() > k) {
        sum -= q.top();  // 直接弹出最小元素
        q.pop();
    }
}
```

---

## 同类题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 堆的经典应用
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) - 动态维护第k大元素
3. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631) - 堆与有序序列结合

---

## 实现技巧总结
1. **逆向思维**：当需要以某属性为最小值时，可先固定该属性再求其他属性的最优解
2. **堆的转换**：通过存储负数实现小根堆，避免直接使用复杂模板参数
3. **实时维护**：在遍历过程中同步更新堆和总和，避免重复计算
4. **边界处理**：注意堆大小超过k时的弹出操作与总和更新的原子性

---

## 调试心得摘录
> "如果弹出了当前歌曲长度，意味着不选当前歌曲时有更优解，而这个解会在之前被计算" —— xht  
> "使用小根堆必须注意当元素数超过k时立即弹出，否则会错过最优解" —— 墨宇  
> "size()返回unsigned类型，直接比较可能出现玄学错误" —— James_Brady

---
处理用时：47.68秒
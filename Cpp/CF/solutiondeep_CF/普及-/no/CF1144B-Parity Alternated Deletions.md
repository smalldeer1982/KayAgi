# 题目信息

# Parity Alternated Deletions

## 题目描述

$Polycarp$有一个有$n$个数的数组，他会轮流从中删去数，比如：奇数-偶数-奇数-偶数-奇数-偶数-奇数-偶数···$\ \ \ $或：偶数-奇数-偶数-奇数-偶数-奇数-偶数-奇数···直到无法删除。

## 样例 #1

### 输入

```
5
1 5 7 8 2
```

### 输出

```
0
```

## 样例 #2

### 输入

```
6
5 1 2 4 6 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2
1000000 1000000
```

### 输出

```
1000000
```

# AI分析结果



### 中文题目重写
# 奇偶交替删除

## 题目描述

Polycarp 有一个包含 $n$个整数的数组。他会轮流从中删除数，遵循以下两种模式之一：  
1. 奇数-偶数-奇数-偶数-奇数-偶数...  
2. 偶数-奇数-偶数-奇数-偶数-奇数...  

当无法继续删除时，游戏停止。求剩余数字的最小可能和。

## 样例 #1

### 输入
```
5
1 5 7 8 2
```

### 输出
```
0
```

## 样例 #2

### 输入
```
6
5 1 2 4 6 3
```

### 输出
```
0
```

## 样例 #3

### 输入
```
2
1000000 1000000
```

### 输出
```
1000000
```

---

### 算法分类
贪心

---

### 题解分析与结论

题目核心在于**奇偶数量差决定剩余数**，通过贪心策略保留最小值。关键思路如下：
1. **奇偶分组**：将奇数和偶数分别存入两个数组。
2. **数量判断**：若奇偶数量差≤1，可全部删除（和为0）。
3. **贪心保留最小值**：当数量差>1时，保留较多方的**最小k个数**，其中 `k=数量差-1`。

---

### 精选题解

#### 题解作者：Nemonade（★★★★★）
**关键亮点**：  
- 直接计算剩余数的最小和，无需模拟删除过程  
- 时间复杂度 O(n logn)  
- 代码简洁，仅需一次排序和累加  

**核心代码**：
```cpp
vector<int> v[2]; // 奇偶分组
sort(v[0].begin(), v[0].end()); // 升序排序
sort(v[1].begin(), v[1].end());
if (abs(m[0]-m[1]) <= 1) cout << 0;
else if (m[0] > m[1]) {
    for (int i=0; i < m[0]-m[1]-1; i++) 
        res += v[0][i]; // 取偶数组前k小
} else {
    for (int i=0; i < m[1]-m[0]-1; i++)
        res += v[1][i]; // 取奇数组前k小
}
```

---

### 相似题目推荐
1. P1090 [NOIP2004 提高组] 合并果子（贪心+优先队列）  
2. P1208 [USACO1.3]混合牛奶 Mixing Milk（贪心+排序）  
3. P4995 跳跳！（贪心+交替选择极值）  

---

### 个人心得摘录
- **贪心切入点**：当奇偶数量差较大时，剩余数的最小和只与较小值的保留有关（@Nemonade）  
- **排序技巧**：升序排序后直接取前k小元素，避免复杂模拟（@Luo_gu_ykc）  
- **边界处理**：当奇偶数量差恰好为1时需特判（@_Give_up_）  

---

### 关键思路总结
1. **奇偶分组统计**：分离奇偶数并统计数量  
2. **差值判断**：若差≤1则全删，否则计算保留数  
3. **贪心保留最小值**：对较多方升序排序后取前k小元素之和

---
处理用时：185.78秒
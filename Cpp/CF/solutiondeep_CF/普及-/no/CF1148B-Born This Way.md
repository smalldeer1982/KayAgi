# 题目信息

# Born This Way

## 题目描述

$Arkady$ 买了一张从 $A$ 市到 $C$ 市的机票。不幸的是，这两个城市之间没有直飞航班，但是从 $A$ 市到 $B$ 市和从 $B$ 市到 $C$ 市的航班有很多。

从 $A$ 市到 $B$ 市有 $N$ 个航班，它们分别在 $a_1,a_2,a_3,...$ $,a_n$ 时起飞，在 $ta$ 个单位时间的飞行后到达 $B$ 市。

从 $B$ 市到 $C$市 有 $M$ 个航班，它们在 $b_1,b_2,b_3,...$ $,b_m$ 起飞。在 $tb$ 个单位时间的飞行后到达 $C$ 市。

转机的时间忽略不计，因此只有当 $b_j \ge a_i+ta$ 时，$Arkady$ 才能搭乘从 $A$ 市到 $B$ 市的第 $i$ 次航班和 $B$ 市到 $C$ 市的第 $j$ 次航班抵达目的地。 

你最多可以不择手段地取消 $k$ 次航班。如果你取消了航班，$Arkady$ 当然就不能搭乘它了。

$Arkady$ 想尽早到 $C$ 市，而你想让他尽可能地晚到 $C$ 市。计算你取消了 $k$ 次航班之后 $Arkady$ 最早到达 $C$ 市的时间点。如果你可以通过取消 $k$ 次或更少的航班，使 $Arkady$ 不能达到 $C$ 市，请输出 $−1$ 。

## 样例 #1

### 输入

```
4 5 1 1 2
1 3 5 7
1 2 3 9 10
```

### 输出

```
11
```

## 样例 #2

### 输入

```
2 2 4 4 2
1 10
10 20
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4 3 2 3 1
1 999999998 999999999 1000000000
3 4 1000000000
```

### 输出

```
1000000003
```

# AI分析结果



### 中文重写题目

#### 题目描述

$Arkady$ 购买了一张从 $A$ 市到 $C$ 市的机票，但两地没有直飞航班，必须从 $B$ 市转机。

- 从 $A$ 到 $B$ 的 $N$ 个航班起飞时间为 $a_1,a_2,\dots,a_n$，飞行耗时 $ta$。
- 从 $B$ 到 $C$ 的 $M$ 个航班起飞时间为 $b_1,b_2,\dots,b_m$，飞行耗时 $tb$。
- 转机时间可忽略，当且仅当 $b_j \ge a_i + ta$ 时，$Arkady$ 能衔接第 $i$ 次 $A→B$ 和第 $j$ 次 $B→C$ 的航班。
- 允许取消最多 $k$ 次航班，目标是使 $Arkady$ 到达 $C$ 的时间尽可能晚，若无法到达则输出 $-1$。

---

### 算法分类
**贪心**

---

### 题解对比与结论

#### 核心思路总结
- **枚举分配策略**：将 $k$ 次取消机会分为两部分，分别用于 $A→B$ 和 $B→C$ 的航班。枚举在 $A→B$ 取消 $i$ 次后，剩余 $k-i$ 次用于 $B→C$。
- **双指针/二分查找**：对每个 $i$，找到 $B→C$ 中第一个满足 $b_j \ge a_{i+1} + ta$ 的航班，检查剩余航班是否足够。
- **边界特判**：若 $k \ge n$ 或 $k \ge m$，直接返回 $-1$。

---

#### 高星题解推荐

1. **Jameswood（5星）**  
   **亮点**：双指针维护 $B→C$ 的可行位置，时间复杂度 $O(n+m)$，代码简洁高效。  
   **核心代码**：
   ```cpp
   for(int i=0;i<=k;++i) {
       while(a[i+1]+ta > b[p] && p <= m) ++p;
       if(p + k-i > m) { ans = -1; break; }
       ans = max(ans, b[p + k-i] + tb);
   }
   ```

2. **expecto__patronum（4星）**  
   **亮点**：二分查找快速定位 $B→C$ 的可行位置，逻辑清晰。  
   **核心代码**：
   ```cpp
   for(int i=1; i<=k+1; i++) {
       int pos = lower_bound(b+1, b+m+1, a[i]) - b;
       pos += k - i + 1;
       if(pos > m) { puts("-1"); return 0; }
       ans = max(ans, b[pos] + tb);
   }
   ```

3. **xh001（4星）**  
   **亮点**：变量命名规范，条件判断与更新逻辑明确。  
   **核心代码**：
   ```cpp
   while(a[i+1]+ta > b[cnt] && cnt <= m) ++cnt;
   if(cnt + k -i > m) { cout<<-1; return 0; }
   t = max(t, b[cnt + k-i] + tb);
   ```

---

#### 关键优化技巧
- **双指针代替二分**：由于两个序列均有序，维护指针 $p$ 单次遍历即可，避免二分查找的额外复杂度。
- **边界条件统一处理**：通过全局变量记录最终答案，遇到无法到达的情况直接跳出循环。

---

#### 类似题目推荐
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)（贪心策略）
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
3. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（二分查找应用）

---
处理用时：130.32秒
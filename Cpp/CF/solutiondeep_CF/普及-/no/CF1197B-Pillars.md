# 题目信息

# Pillars

## 题目描述

**题意**

给定$n$个盘子，盘子的半径是$1$到$n$

现在的有$n$个柱子，每个柱子上有一个盘子，问时候能够把所有的盘子移动到一个柱子上

如果要把一个盘子从柱子$i$移动到柱子$j$则要求
1. 柱子$i$上只有一个盘子
2. 柱子$j$上没有盘子，或盘子的半径大于柱子$i$上的盘子
3. $i$，$j$必须相邻

## 说明/提示

$3\le n\le 2e5$

$1\le a_i\le n$

## 样例 #1

### 输入

```
4
1 3 4 2
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3
3 1 2
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# 柱子

## 题目描述
**题意**
给定$n$个盘子，盘子的半径是$1$到$n$。
现在有$n$个柱子，每个柱子上有一个盘子，问是否能够把所有的盘子移动到一个柱子上。
如果要把一个盘子从柱子$i$移动到柱子$j$则要求：
1. 柱子$i$上只有一个盘子。
2. 柱子$j$上没有盘子，或盘子的半径大于柱子$i$上的盘子。
3. $i$，$j$必须相邻。

## 说明/提示
$3\le n\le 2e5$
$1\le a_i\le n$

## 样例 #1
### 输入
```
4
1 3 4 2
```
### 输出
```
YES
```

## 样例 #2
### 输入
```
3
3 1 2
```
### 输出
```
NO
```
• **算法分类**：无算法分类
• **综合分析与结论**：这些题解的核心思路都是通过寻找盘子半径序列的规律来判断是否能将所有盘子移动到一个柱子上。大部分题解都发现了如果盘子半径序列出现先递减后递增的情况就无法完成移动，否则可以。不同题解在具体实现上有所差异，有的通过简单的循环判断，有的借助STL函数，有的使用优先队列等数据结构。在代码实现上，有的注重简洁性，有的更偏向于详细的逻辑分步处理。
• **所选的题解**：
  - **pxy1118题解**：★★★★ 关键亮点在于简洁地通过一次循环判断盘子半径序列是否出现先递减后递增的情况，代码简洁明了。
重点代码：
```cpp
int ok=0;
for(int i=1;i<n;i++){
    if(a[i]<a[i-1]&&ok==0)ok=1;
    if(ok){
        if(a[i]>a[i-1]){
            printf("NO\n");
            return 0;
        }
    }
}
printf("YES\n");
```
核心实现思想：通过ok标记是否已经出现递减情况，在出现递减后若又出现递增则输出NO，否则输出YES。
  - **yizr_cnyali题解**：★★★★ 关键亮点在于巧妙利用STL中的`max_element()`和`is_sorted()`函数来判断序列是否满足先递增后递减的条件，代码简洁且利用了C++标准库的便利。
重点代码：
```cpp
int len = max_element(a,a + n) - a;
if(is_sorted(a,a + len) && is_sorted(a + len + 1, a + n,greater<int>())){
    printf("YES\n");
    return 0;
}printf("NO\n");
```
核心实现思想：先找到最大值的位置，然后分别判断最大值左边序列是否递增，右边序列是否递减。
  - **Luban题解**：★★★ 关键亮点在于详细地按照题目移动盘子的条件，通过模拟移动过程来判断能否成功移动，思路较为直观。
重点代码：
```cpp
int l=t-1,r=t+1,now=maxn;
while(l>=1||r<=n)
{
    if (l<1)
    {
        if (a[r]>=now)
        {
            cout<<"NO"<<endl;
            return 0;
        }
        now=a[r];
        r++;
    }
    else if (r>n)
    {
        if (a[l]>=now)
        {
            cout<<"NO"<<endl;
            return 0;
        }
        now=a[l];
        l--;
    }
    else
    {
        bool flag=0;
        if (a[l]>a[r]) flag=1;
        if (max(a[l],a[r])>=now)
        {
            cout<<"NO"<<endl;
            return 0;
        }
        if (flag)
        {
            now=a[l];
            l--;
        }
        else
        {
            now=a[r];
            r++;
        }
    }
}
cout<<"YES"<<endl;
```
核心实现思想：找到最大盘子的位置后，从其相邻位置开始模拟移动盘子的过程，判断是否满足移动条件。
• **最优关键思路或技巧**：通过观察发现盘子半径序列先递减后递增就无法完成移动这一规律是解题关键，利用这一规律无论是简单循环判断还是借助STL函数都能简洁地解决问题。
• **可拓展之处**：同类型题可考察不同的移动规则下能否完成特定状态的转换，类似算法套路是通过观察题目条件总结出序列或状态的规律，然后根据规律进行判断。
• **相似知识点洛谷题目**：
  - [P1036 选数](https://www.luogu.com.cn/problem/P1036)：通过枚举组合判断是否满足特定条件，与本题找规律判断类似。
  - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：通过一定规则判断能否达到某种状态，和本题判断能否完成盘子移动类似。
  - [P1424 小鱼的航程(改进版)](https://www.luogu.com.cn/problem/P1424)：根据给定条件总结规律进行计算，与本题找规律解题思路相符。
• **个人心得**：无。 

---
处理用时：46.24秒
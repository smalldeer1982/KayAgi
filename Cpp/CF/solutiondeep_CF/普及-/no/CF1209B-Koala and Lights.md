# 题目信息

# Koala and Lights

## 题目描述

有 $n$ 盏灯泡，给定初始状态，第 $i$ 盏灯泡会在 $b_i,b_i+a_i,b_i+2 \times a_i$ 等时刻变成相反的状态，求在某一个时刻亮灯数的最大值。

## 样例 #1

### 输入

```
3
101
3 3
3 2
3 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
1111
3 4
5 2
3 1
3 2
```

### 输出

```
4
```

## 样例 #3

### 输入

```
6
011100
5 3
5 5
2 4
3 5
4 2
1 5
```

### 输出

```
6
```

# AI分析结果

### 题目内容
# Koala and Lights

## 题目描述

有 $n$ 盏灯泡，给定初始状态，第 $i$ 盏灯泡会在 $b_i,b_i+a_i,b_i+2 \times a_i$ 等时刻变成相反的状态，求在某一个时刻亮灯数的最大值。

## 样例 #1

### 输入

```
3
101
3 3
3 2
3 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
1111
3 4
5 2
3 1
3 2
```

### 输出

```
4
```

## 样例 #3

### 输入

```
6
011100
5 3
5 5
2 4
3 5
4 2
1 5
```

### 输出

```
6
```

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路均为模拟。由于题目给定的 $a_i$ 和 $b_i$ 范围较小（$1\leq a_i,b_i \leq 5$），各题解通过枚举每一个时刻（通常枚举到 $10^5$ 或 $10^6$），对每一盏灯进行状态判断。判断条件为当前时刻 $j$ 大于等于 $b_i$ 且 $(j - b_i)$ 是 $a_i$ 的倍数时，改变第 $i$ 盏灯的状态，然后统计该时刻亮灯的总数，最后取所有时刻亮灯数的最大值。各题解的主要差异在于代码实现细节，如输入方式、变量命名、状态改变的写法等。

### 所选的题解
- **作者：wmrqwq (5星)**
    - **关键亮点**：思路清晰，代码结构完整，详细注释，使用 `string` 类型读入初始灯状态并进行转换，代码可读性强。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define QwQ return 0;
long long n,a[100010],b[100010],c[100010],sum[100010],maxn;
string s;
int main()
{
    cin>>n>>s;
    for(int i=1;i<=n;i++)
        if(s[i - 1]=='1')
            c[i]=1;
    for(int i=1;i<=n;i++)
        cin>>a[i]>>b[i];
    for(int i=1;i<=n;i++)
        for(int j=0;j<=100000;j++)
        {
            if(j>=b[i] && (j - b[i])%a[i]==0)
                c[i]=!c[i];
            sum[j]+=c[i];
        }
    for(int i=0;i<=100000;++i)
        maxn=max(maxn,sum[i]);
    cout<<maxn;
    QwQ;
}
```
    - **核心实现思想**：先读入灯的数量和初始状态，将字符状态转为数字。然后双重循环，外层枚举灯，内层枚举时刻，根据条件改变灯状态并统计该时刻亮灯数，最后找出亮灯数最大值输出。
- **作者：wsk_1202 (4星)**
    - **关键亮点**：代码简洁，利用 `scanf` 的格式化输入，在输入时统计初始亮灯数，同时给出了时间复杂度的大致分析。
    - **重点代码**：
```cpp
#include <cstdio>
using namespace std;
inline int max(int x,int y){return x>y?x:y;}
int n,a[102],b[102],vis[102],tm[102],ans,maxn;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%1d",&vis[i]),maxn+=vis[i];
    for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);
    for(int k=0;k<=1000000;k++)
    {
        ans=0;
        for(int i=1;i<=n;i++)
        {
            if(k>=b[i]&&(k - b[i])%a[i]==0)vis[i]^=1;
            ans+=vis[i];
        }
        maxn=max(maxn,ans);
    }
    printf("%d\n",maxn);
    return 0;
}
```
    - **核心实现思想**：读入数据，先统计初始亮灯数。通过双重循环，外层枚举时刻，内层枚举灯，根据条件改变灯状态并统计该时刻亮灯数，不断更新亮灯数最大值并输出。
- **作者：York佑佑 (4星)**
    - **关键亮点**：分析部分清晰阐述了模拟思路和灯状态改变的条件，代码中使用 `const` 定义常量，增强代码可读性。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[N],b[N],light[N],ans[N],maxx;
string str;
int main()
{
    cin>>n>>str;
    for(int i=0;i<n;i++)
        light[i + 1]=str[i]-'0';
    for(int i=1;i<=n;i++)
        cin>>a[i]>>b[i];
    for(int i=1;i<=n;i++)
        for(int j=0;j<=100010;j++)
        {
            if(j>=b[i]&&!(j - b[i])%a[i])
                light[i]=!light[i];
            ans[j]+=light[i];
        }
    for(int i=0;i<=100010;i++)
        maxx=max(maxx,ans[i]);
    cout<<maxx;
    return 0;
}
```
    - **核心实现思想**：读入灯数和初始状态并转换为数字。通过双重循环，外层枚举灯，内层枚举时刻，依据条件改变灯状态并统计该时刻亮灯数，最后找出亮灯数最大值输出。

### 最优关键思路或技巧
利用模拟思想，通过枚举所有可能时刻来统计亮灯数。在代码实现上，注意合理使用数据结构和变量命名提高可读性，如使用 `string` 读入初始灯状态，利用数组记录灯的状态、时刻亮灯数等。同时，可以在输入时统计初始亮灯数等小技巧简化代码。

### 同类型题或类似算法套路拓展
此类题目属于模拟类型，通常给定一些对象和规则，需要按照规则模拟对象的变化过程。类似套路包括对每个对象在每个时间点或状态下进行判断和操作，要注意边界条件和状态转移的正确性。

### 推荐洛谷题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：通过枚举组合判断是否为质数，考察枚举和模拟能力。
- [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：模拟灯的开关状态变化，与本题类似，需根据特定规则改变灯状态并统计结果。
- [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：通过广度优先搜索模拟马的移动遍历棋盘，同样是按照一定规则对对象状态进行模拟。 

---
处理用时：68.29秒
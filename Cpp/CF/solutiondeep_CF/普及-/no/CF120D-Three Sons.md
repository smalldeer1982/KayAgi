# 题目信息

# Three Sons

## 题目描述

**题意简述**

给定一个 $n\times m$ 的长方形矩阵，第 $(i,j)$ 个方格上面有一个值 $c_{i,j}$。现在要将矩阵分成三部分，要求两条切割线必须互相平行且与边线平行，不能切开网格，使得切出的三部分每个部分所包含的方格的值的总和分别为 $A$，$B$，$C$。求有多少种切法。

## 样例 #1

### 输入

```
3 3
1 1 1
1 1 1
1 1 1
3 3 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
2 5
1 1 1 1 1
2 2 2 2 2
3 6 6
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3 3
1 2 3
3 1 2
2 3 1
5 6 7
```

### 输出

```
0
```

# AI分析结果



### 中文题目重写

#### 题目描述

**题意简述**

给定一个 $n\times m$ 的长方形矩阵，第 $(i,j)$ 个方格上的值为 $c_{i,j}$。现在要将矩阵分成三部分，要求两条切割线必须互相平行且与边线平行（即只能横向或纵向切割），不能切开网格，使得切出的三部分每个部分所包含的方格的值的总和分别为 $A$，$B$，$C$。求有多少种切法。

---

### 算法分类
**前缀和、枚举**

---

### 题解对比与总结

#### 核心思路
1. **前缀和优化**：使用二维前缀和或一维行/列前缀和快速计算区域和。
2. **枚举切割线**：分横向和纵向两种情况，枚举两条切割线的位置。
3. **和值匹配**：将分割后的三个和值与 $A,B,C$ 的所有排列进行匹配，或通过排序后直接比较。

#### 解决难点
- **切割线范围**：需确保切割后分为三部分，因此横向切割要求 $n \ge 3$，纵向要求 $m \ge 3$。
- **和值排列匹配**：分割后的三部分和可能与 $A,B,C$ 的顺序无关，需穷举所有排列或通过排序简化判断。

#### 最优思路
1. **前缀和预处理**：行或列的一维前缀和更直观，二维前缀和更通用。
2. **排序简化匹配**：将分割后的三值及 $A,B,C$ 排序后比较，避免穷举排列，代码更简洁。

---

### 精选题解

#### 题解1：CarroT1212（5星）
**关键亮点**  
- 使用二维前缀和快速计算区域和。
- 通过排序分割后的三值及目标值，简化匹配逻辑。
- 代码简洁且高效，逻辑清晰。

**核心代码片段**  
```cpp
void horizontal() {
    for (ll i=1;i<n;i++) {
        for (ll j=i+1;j<n;j++) {
            x[0] = cal(1,1,i,m);   // 前i行总和
            x[1] = cal(i+1,1,j,m); // i+1到j行总和
            x[2] = cal(j+1,1,n,m); // 剩余部分
            sort(x, x+3);
            if (x[0]==a[0] && x[1]==a[1] && x[2]==a[2]) ans++;
        }
    }
}
```

#### 题解2：HMZHMZHMZ（5星）
**关键亮点**  
- 将输入的 $A,B,C$ 和分割后的三值统一排序后比较。
- 减少条件判断次数，代码逻辑紧凑。

**核心代码片段**  
```cpp
sort(a, a+3); // 输入值排序
// 枚举切割线并计算三部分和
for (int i=1; i<n; i++) {
    for (int j=i+1; j<n; j++) {
        c[1] = sum[i][m];
        c[2] = sum[j][m] - sum[i][m];
        c[3] = sum[n][m] - sum[j][m];
        sort(c+1, c+3+1); // 分割值排序
        if (与排序后的a完全匹配) ans++;
    }
}
```

#### 题解3：Strelitzia_（4星）
**关键亮点**  
- 显式处理所有可能的排列组合，确保全覆盖。
- 二维前缀和的灵活应用，代码注释清晰。

**核心代码片段**  
```cpp
// 横向切割枚举
for (int i=1; i<n; i++) {
    for (int j=i+1; j<n; j++) {
        int _a = sum[i][m], _b = sum[j][m] - sum[i][m], _c = sum[n][m] - sum[j][m];
        // 6种排列判断
        if (_a==x && _b==y && _c==z) ans++;
        else if (_a==y && _b==x && _c==z) ans++;
        // ... 其他4种情况
    }
}
```

---

### 拓展与总结
**关键技巧**  
- 前缀和用于快速计算区域和是核心优化。
- 排序简化排列匹配，减少冗余代码。

**同类题目推荐**  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)  
3. [P1719 寻找最大加权矩形](https://www.luogu.com.cn/problem/P1719)  

**个人心得**  
- 注意切割线范围（如 `i < j < n` 而非 `i < j <= n`）。
- 必须处理输入输出文件重定向，否则会报错。

---
处理用时：100.26秒
# 题目信息

# Optimal Currency Exchange

## 题目描述

Andrew参加了Olympiad of Metropolises，现准备回国，需要兑换货币。

现有如下面额的美元纸币：$1 , 2 , 5 , 10 , 20 , 50 , 100$，以及以下面额的欧元纸币：$5 , 10 , 20 , 50 , 100 , 200$（注意，不考虑$500$欧元纸币，因为在货币兑换窗口很难找到这种）。已知兑换$1$美元需要$d$卢布，$1$欧元需要$e$卢布，而Andrew有$n$卢布。

他可以兑换任意数量的美元和欧元（一种纸币可以兑换多次，可以美元和欧元混合），并且，他希望使兑换后手里剩余的卢布数尽可能少。请你写一个程序帮他解决问题（只需求出最小的剩余卢布数）。

## 说明/提示

$1 \leq n \leq 10^8$

$30 \leq d,e \leq 100$

## 样例 #1

### 输入

```
100
60
70
```

### 输出

```
40
```

## 样例 #2

### 输入

```
410
55
70
```

### 输出

```
5
```

## 样例 #3

### 输入

```
600
60
70
```

### 输出

```
0
```

# AI分析结果

### 题目内容
# 最优货币兑换

## 题目描述
Andrew参加了大都市奥林匹克竞赛，现准备回国，需要兑换货币。
现有如下面额的美元纸币：1, 2, 5, 10, 20, 50, 100，以及以下面额的欧元纸币：5, 10, 20, 50, 100, 200（注意，不考虑500欧元纸币，因为在货币兑换窗口很难找到这种）。已知兑换1美元需要d卢布，1欧元需要e卢布，而Andrew有n卢布。
他可以兑换任意数量的美元和欧元（一种纸币可以兑换多次，可以美元和欧元混合），并且，他希望使兑换后手里剩余的卢布数尽可能少。请你写一个程序帮他解决问题（只需求出最小的剩余卢布数）。

## 说明/提示
1 ≤ n ≤ 10^8
30 ≤ d,e ≤ 100

## 样例 #1
### 输入
```
100
60
70
```
### 输出
```
40
```

## 样例 #2
### 输入
```
410
55
70
```
### 输出
```
5
```

## 样例 #3
### 输入
```
600
60
70
```
### 输出
```
0
```
• **算法分类**：枚举
• **综合分析与结论**：这些题解的核心思路都是基于一个关键观察，即所有美元面额都是1美元的倍数，所有欧元面额都是5欧元的倍数，所以只需要考虑1美元和5欧元这两种面额来简化问题。大部分题解通过枚举其中一种货币的兑换数量，再计算另一种货币兑换后剩余的卢布数，从而找到最小剩余卢布数。不同题解在具体实现和细节处理上略有差异，比如枚举对象的选择、边界条件的处理等。
### 所选的题解
- **作者：andyli (4星)**
  - **关键亮点**：思路清晰，直接枚举美元换取的钱数，通过简单的数学运算计算出相应欧元的钱数，选取总金额最大的方案。代码简洁明了，容易理解。
  - **重点代码**：
```cpp
int main()
{
    int n, d, e;
    read(n, d, e); // 输入数据
    int x = n / d, ans = 0; // x为最大能换取的美元数量
    for (int i = 0; i <= x; i++) // 换取i美元
        ans = max(ans, i * d + (n - i * d) / e / 5 * 5 * e); // (n - i * d) / e 为剩余可换取欧元的钱数, /5*5的操作是为了计算实际能换取的欧元钱数
    writeln(n - ans); // 输出答案
    return 0;
}
```
  - **核心实现思想**：先确定最大能换取的美元数量x，然后从0到x枚举换取的美元数量i，对于每个i，计算剩余卢布可换取的欧元数量（通过先除e再调整为5的倍数），取总金额最大的方案，最后用总卢布数n减去最大总金额ans得到最小剩余卢布数。
- **作者：Meatherm (4星)**
  - **关键亮点**：简洁高效地实现了枚举思路，明确指出买大于1的美元和大于5的欧元不会更优，直接暴力枚举买x个1美元，剩下的全部买5欧元，计算剩下的卢布数量。时间复杂度分析清晰。
  - **重点代码**：
```cpp
# include <bits/stdc++.h>
# define rr register
int n,a,b;
int minx;
int main(void){
	scanf("%d%d%d",&n,&a,&b);
	minx=1e9;
	for(rr int i=0;i<=(n/a);++i){
		minx=std::min(minx,(n-(i*a))%(b*5));
	}
	printf("%d",minx);
	return 0;
}
```
  - **核心实现思想**：从0到n/a枚举1美元的购买数量i，用n减去i个1美元花费的卢布后对5欧元的价格（b*5）取模，不断更新最小剩余卢布数minx。
- **作者：B_Qu1e7 (4星)**
  - **关键亮点**：思路直接，从0开始枚举可以换多少美元，再对“5欧元”取模来计算剩余卢布数，代码简洁易懂。
  - **重点代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int N,D,E,ans;
int main()
{
	scanf("%d%d%d",&N,&D,&E);
	ans=N;
	//最坏的情况就是什么都换不了，所以ans初值为n
	for(int i=0;i<=N/D;i++)
	{
		ans=min(ans,(N-D*i)%(5*E));
		//枚举换0,1,...美元，剩下全换欧元，取最小值
	}
	printf("%d\n",ans);
	return 0;
}
```
  - **核心实现思想**：初始化ans为N（最坏情况），然后枚举可兑换的美元数量i，计算剩余卢布数对5欧元价格（5*E）取模的值，不断更新ans为最小值。
• **最优关键思路或技巧**：利用所有美元面额是1美元倍数、所有欧元面额是5欧元倍数这一特性，将问题简化为只考虑1美元和5欧元的兑换情况，通过枚举其中一种货币的兑换数量来计算最小剩余卢布数，大大降低了问题的复杂度。
• **同类型题或类似算法套路**：此类题目通常是给定多种面额货币和总金额，在一定兑换规则下求最优解。常见套路是先分析货币面额关系简化问题，再通过枚举、贪心等策略求解。比如可以改变货币面额种类、汇率关系、限制条件等衍生出不同题目。
• **洛谷相似题目**：
  - P1036 [NOIP2002 普及组] 选数，通过枚举组合数来求解满足条件的方案。
  - P1164 小A点菜，类似背包问题的枚举求解，不过这里可以用枚举优化的思路。
  - P1464 Function，通过枚举不同情况来计算函数值。 

---
处理用时：89.79秒
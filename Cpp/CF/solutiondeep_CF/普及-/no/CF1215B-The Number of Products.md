# 题目信息

# The Number of Products

## 题目描述

给出一个由$n$个非零整数构成的序列$a_1,a_2,\dots,a_n$。

你需要计算下列两个值：

1.下标对$(l,r)(l\le r)$使得$a_l*a_{l+1}*\dots*a_r$为负数；

2.下标对$(l,r)(l\le r)$使得$a_l*a_{l+1}*\dots*a_r$为正数；

## 样例 #1

### 输入

```
5
5 -3 3 -1 1
```

### 输出

```
8 7
```

## 样例 #2

### 输入

```
10
4 2 -4 3 1 2 -4 3 2 3
```

### 输出

```
28 27
```

## 样例 #3

### 输入

```
5
-1 -2 -3 -4 -5
```

### 输出

```
9 6
```

# AI分析结果

### 题目内容
# 乘积的数量

## 题目描述
给出一个由$n$个非零整数构成的序列$a_1,a_2,\dots,a_n$。
你需要计算下列两个值：
1. 下标对$(l,r)(l\le r)$使得$a_l*a_{l + 1}*\dots*a_r$为负数；
2. 下标对$(l,r)(l\le r)$使得$a_l*a_{l + 1}*\dots*a_r$为正数。

## 样例 #1
### 输入
```
5
5 -3 3 -1 1
```
### 输出
```
8 7
```

## 样例 #2
### 输入
```
10
4 2 -4 3 1 2 -4 3 2 3
```
### 输出
```
28 27
```

## 样例 #3
### 输入
```
5
-1 -2 -3 -4 -5
```
### 输出
```
9 6
```

### 算法分类
前缀和

### 综合分析与结论
这些题解主要围绕通过前缀和思想或动态规划思想来解决问题。有的题解利用前缀积的正负性，通过桶或计数器来统计满足条件的区间数量；有的题解则通过动态规划，定义状态表示以某位置结尾的乘积为正或负的子区间数，再根据当前数的正负推导转移方程。各题解的核心都是利用数的正负性对乘积正负的影响规律，避免对每个子区间进行暴力计算，从而将时间复杂度优化到$O(n)$。

### 所选的题解
- **作者：Ofnoname (5星)**
    - **关键亮点**：将所有数转化为考虑正负性，利用前缀积思想，通过桶记录前缀积的正负数量，快速统计满足条件的区间对数，代码简洁高效，思路清晰。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define MAX (200000 + 7)
using namespace std;

int N,sum = 1,T[2],a[MAX];
long long ans;

int main()
{
    scanf("%d", &N); T[0] = 1;
    for (register int i = 1; i <= N; i++)
    {
        scanf("%d", a + i);
        sum *= a[i]>0? 1 : -1;
        ans += sum>0? T[1] : T[0];
        T[sum>0? 0 : 1]++;
    }
    cout<<ans<<' '<<(long long)N*(N + 1)/2 - ans;
}
```
    - **核心实现思想**：读入每个数时，更新前缀积`sum`，根据`sum`的正负，将`ans`加上对应前缀积符号数量（用`T`数组桶记录），同时更新`T`数组。最后通过总区间数减去负积区间数得到正积区间数。
- **作者：梦里调音 (4星)**
    - **关键亮点**：通过简洁的变量设置，直接利用前缀和思想，根据当前数的正负改变前缀符号，并结合之前的正、负子序列数更新答案，逻辑清晰易懂。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long int n;
long long int f,z;
int main(){
    cin>>n;
    long long int sgn = 1,pos = 1,neg = 0;
    for(long long int i = 1;i <= n;i++){
        long long int a;
        cin>>a;
        if(a < 0)sgn = -sgn;
        if(sgn > 0){
            z += pos;
            f += neg;
            pos++;
        }
        else{
            z += neg;
            f += pos;
            neg++;
        }
    }
    cout<<f<<" "<<z<<endl;
}
```
    - **核心实现思想**：用`sgn`记录前缀符号，`pos`和`neg`分别记录之前的正、负子序列数。每次读入新数，若为负则反转`sgn`，再根据`sgn`的正负更新`z`（正积区间数）和`f`（负积区间数），同时更新`pos`和`neg`。
- **作者：Sooke (4星)**
    - **关键亮点**：巧妙地将乘积正负问题转化为异或和问题，利用前缀异或和性质，通过简单的计数器统计满足条件的区间数量，思维独特。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>

inline int read() {
    char c, _c; int x; for (c = _c = getchar();!isdigit(c); c = getchar()) { _c = c; }
    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return _c == '-'? -x : x;
}

const int N = 1e6 + 5;

int n, x, y, a[N];
long long ans0, ans1;

int main() {
    n = read();
    for (int i = 1; i <= n; i++) {
        a[i] = read();
        if (a[i] > 0) {
            a[i] = 0;
        } else {
            a[i] = 1;
        }
    }
    x++;
    for (int i = 1; i <= n; i++) {
        a[i] ^= a[i - 1];
        if (a[i] == 0) {
            ans0 += x; ans1 += y; x++;
        } else {
            ans0 += y; ans1 += x; y++;
        }
    } printf("%lld %lld\n", ans1, ans0);
    return 0;
}
```
    - **核心实现思想**：将正数赋为0，负数赋为1，转化为异或和问题。预处理前缀异或和`a[i]`，根据`a[i]`的值，利用`x`和`y`两个计数器分别统计异或和为0和1的区间数量，即正积和负积区间数。

### 最优关键思路或技巧
将原问题转化为前缀和相关问题，利用前缀积或前缀异或和的性质，通过简单的计数方式统计满足条件的区间数量，避免了暴力枚举子区间计算乘积的$O(n^2)$复杂度。

### 可拓展之处
此类问题属于序列区间统计类型，类似套路是关注区间元素的某种性质（如本题的正负性）对区间整体性质（乘积正负）的影响，利用前缀和或动态规划优化计算。

### 洛谷相似题目推荐
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：同样是基于序列的区间统计问题，通过动态规划求最大子段和，与本题利用动态规划或前缀和思想优化区间统计类似。
- [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)：需要利用动态规划思想解决区间合并问题，与本题在利用动态规划处理区间相关问题上有相似之处。
- [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)：通过前缀和优化二维矩阵中矩形区域的和的计算，与本题利用前缀和优化区间统计的思路类似，只是拓展到了二维。

### 个人心得摘录与总结
无。 

---
处理用时：62.23秒
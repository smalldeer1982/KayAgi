# 题目信息

# TV Subscriptions (Easy Version)

## 题目描述

### 题意简述



给定长度为 $n$ 的序列 $a$，对于 $a_i(1\leq i \leq n)$ 有 $a_i\leq k$。请你找出一段长度为 $d$ 的区间，使得这段区间所包含的不同元素的数量最小。

## 样例 #1

### 输入

```
4
5 2 2
1 2 1 2 1
9 3 3
3 3 3 2 2 2 1 1 1
4 10 4
10 8 6 4
16 9 8
3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3
```

### 输出

```
2
1
4
5
```

# AI分析结果

### 题目内容
# 电视订阅（简单版）

## 题目描述

### 题意简述

给定长度为 $n$ 的序列 $a$，对于 $a_i(1\leq i \leq n)$ 有 $a_i\leq k$。请你找出一段长度为 $d$ 的区间，使得这段区间所包含的不同元素的数量最小。

## 样例 #1

### 输入
```
4
5 2 2
1 2 1 2 1
9 3 3
3 3 3 2 2 2 1 1 1
4 10 4
10 8 6 4
16 9 8
3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3
```

### 输出
```
2
1
4
5
```

### 算法分类
枚举

### 综合分析与结论
这些题解均利用数据范围较小（$1\leqslant n, t\leqslant 100$）的特点采用暴力枚举的方法解题。思路都是通过枚举长度为 $d$ 的区间，利用桶来记录区间内不同元素的数量，最后取不同元素数量的最小值。算法要点在于如何高效地维护桶内元素信息以及正确处理区间的滑动。解决难点在于准确控制区间边界，避免越界，同时注意多组数据时相关变量的清零。

### 所选的题解
- **作者：Lyrella（5星）**
    - **关键亮点**：代码简洁，逻辑清晰，通过先处理初始区间，再利用循环维护桶中元素的增减来更新答案，实现高效的枚举。
    - **核心代码**：
```cpp
F(l, 1, T)
{
    res = 0; memset(sum, 0, sizeof sum);
    scanf("%d %d %d", &n, &b, &q);
    F(i, 1, n)scanf("%d", &a[i]);
    F(i, 1, q)if(!sum[a[i]]++)res++;
    ans = res;
    F(i, q + 1, n)
    {
        if(!--sum[a[i - q]])res--;
        if(!sum[a[i]]++)res++;
        ans = min(ans, res);
    }
    printf("%d\n", ans);
}
```
    - **核心实现思想**：先统计前 $q$ 个元素不同元素个数 `res`，之后从第 $q + 1$ 个元素开始，每次移除 $a[i - q]$ 并加入 $a[i]$，同时更新 `res` 和最小值 `ans`。

- **作者：傅思维666（5星）**
    - **关键亮点**：题解对题目翻译清晰，代码注释详细，对暴力枚举的实现过程解释到位，注意到多组数据时变量清零的细节。
    - **核心代码**：
```cpp
while(t--)
{
    ans=1<<30;
    scanf("%d%d%d",&n,&k,&d);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        memset(v,0,sizeof(v));
        tmp=0;
        if(i+d-1==n+1)
            break;
        for(int j=i;j<=i+d-1;j++)
        {
            if(!v[a[j]])
                tmp++;
            v[a[j]]=1;
        }
        ans=min(ans,tmp);
    }
    printf("%d\n",ans);
}
```
    - **核心实现思想**：对于每组数据，以每个位置 `i` 为左端点，遍历长度为 `d` 的区间，用数组 `v` 标记元素是否出现，统计不同元素个数 `tmp` 并更新最小值 `ans`。

- **作者：big_news（4星）**
    - **关键亮点**：利用桶维护区间内元素，通过 O(1) 的操作维护区间滑动时元素个数的变化，思路明确，代码简洁。
    - **核心代码**：
```cpp
while(t--){
    memset(tot,0,sizeof(tot));
    
    n = read(); k = read(); d = read();
    for(int i=1;i<=n;i++) a[i] = read();
    
    int ans = INF,cnt = 0;
    for(int i=1;i<d;i++) {if(!tot[ a[i] ]) cnt++; tot[ a[i] ]++;}
    for(int i=d;i<=n;i++){
        if(!tot[ a[i] ]) cnt++; tot[ a[i] ]++;
        tot[ a[i-d] ]--; if(!tot[ a[i-d] ]) cnt--;
        ans = min(ans, cnt); 
    }
    
    printf("%d\n",ans);
}
```
    - **核心实现思想**：先统计前 `d - 1` 个元素不同元素个数 `cnt`，之后从第 `d` 个元素开始，每次加入 `a[i]` 并移除 `a[i - d]`，同时更新 `cnt` 和最小值 `ans`。

### 最优关键思路或技巧
利用桶来记录区间内元素的出现情况，通过在区间滑动时，对桶内元素出现次数的增减操作，O(1) 地维护区间内不同元素的数量，从而高效地枚举所有长度为 `d` 的区间并找到不同元素数量的最小值。

### 可拓展之处
同类型题常以滑动窗口为模型，给定一个序列和窗口大小，求窗口内满足某种条件的最值或统计值。类似算法套路是利用双指针维护窗口，在窗口滑动过程中动态更新所需统计信息。

### 洛谷相似题目
- [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
- [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216)

### 个人心得
无。 

---
处理用时：61.02秒
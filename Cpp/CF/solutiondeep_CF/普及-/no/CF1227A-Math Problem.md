# 题目信息

# Math Problem

## 题目描述

你的数学老师给了你以下问题：

在 $x$ 轴上有 $n$ 个段，$[l_1;r_1],[l_2;r_2]\ldots[l_n;r_n]$。段 $[l;r]$ 包括了边界，即它是 $x$ 的集合，其中 $l \leq x \leq r$。段 $[l;r]$ 的长度等于 $r-l$。

两个段 $[a;b]$ 和 $[c;d]$ 有一个公共点（相交）如果存在一个 $x$ 并满足 $a \leq x \leq b$,$c \leq x \leq d$。例如，$[2;5]$ 和 $[3;10]$ 有一个公共点，但是 $[5;6]$ 和 $[1;4]$ 没有。

你应该添加一个线段，使该线段与每个给定线段至少有一个公共点，并且尽可能短（既具有最小长度）。所需的段可以是一个点（及长度为零的一个段）。添加的段可能在给定的 $n$ 段中，也可能不在其中。

换句话说，您需要找到一个段 $[a;b]$，使得 $[a;b]$ 和每个 $[l_i;r_i]$ 有一个公共点，并且 $b-a$ 是最小的。

## 说明/提示

在样例的第一个测试用例中，我们可以选择分段 $[5;7]$ 作为答案。它是与所有给定线段至少有一个公共点的最短线段。

## 样例 #1

### 输入

```
4
3
4 5
5 9
7 7
5
11 19
4 17
16 16
3 12
14 17
1
1 10
1
1 1
```

### 输出

```
2
4
0
0
```

# AI分析结果

### 题目内容
# 数学问题

## 题目描述
你的数学老师给了你以下问题：

在 $x$ 轴上有 $n$ 个线段，$[l_1;r_1],[l_2;r_2]\ldots[l_n;r_n]$ 。线段 $[l;r]$ 包括边界，即它是 $x$ 的集合，其中 $l \leq x \leq r$ 。线段 $[l;r]$ 的长度等于 $r - l$ 。

两个线段 $[a;b]$ 和 $[c;d]$ 有一个公共点（相交），如果存在一个 $x$ 满足 $a \leq x \leq b$ 且 $c \leq x \leq d$ 。例如，$[2;5]$ 和 $[3;10]$ 有一个公共点，但 $[5;6]$ 和 $[1;4]$ 没有。

你需要添加一个线段，使该线段与每个给定线段至少有一个公共点，并且尽可能短（即具有最小长度）。所需的线段可以是一个点（即长度为零的线段）。添加的线段可能在给定的 $n$ 条线段中，也可能不在其中。

换句话说，您需要找到一个线段 $[a;b]$ ，使得 $[a;b]$ 与每个 $[l_i;r_i]$ 都有一个公共点，并且 $b - a$ 最小。

## 说明/提示
在样例的第一个测试用例中，我们可以选择线段 $[5;7]$ 作为答案。它是与所有给定线段至少有一个公共点的最短线段。

## 样例 #1
### 输入
```
4
3
4 5
5 9
7 7
5
11 19
4 17
16 16
3 12
14 17
1
1 10
1
1 1
```
### 输出
```
2
4
0
0
```
### 算法分类
贪心

### 综合分析与结论
所有题解思路一致，均利用贪心策略，通过找出所有给定线段左端点的最大值 $maxl$ 和右端点的最小值 $minr$，计算 $max(0, maxl - minr)$ 得出结果。因为要使所求线段与所有给定线段都相交且长度最短，从贪心角度，所求线段左端点应尽量靠右（取左端点最大值），右端点尽量靠左（取右端点最小值）。难点在于考虑到当给定线段本身有公共点时，$maxl - minr$ 会小于 0，此时应输出 0 。各题解质量差异主要体现在代码风格和细节处理上。

### 所选的题解
- **作者：fengqiao17（5星）**
  - **关键亮点**：代码结构清晰，定义函数处理多组数据，注释详细，对可能出现的负数情况有清晰解释。
  - **个人心得**：提到最初做题时第一个点WA，发现问题在于未处理给定线段有公共点时 $ma - mi$ 小于 0 的情况。
```cpp
ll helper(int n){ //多组数据用函数
  ll ma = -1e18, mi = 1e18; //注意最小、最大值为1e18和-1e18
  for(int i = 1 ; i <= n ; i++){
    ll l, r;
    cin>>l>>r; //左右端点
    ma = max(ma, l); //最大左边界
    mi = min(mi, r); //最小右边界
  }
  return ma - mi;
}
int main(){
  int t;
  cin>>t;
  while(t--){
    int n;
    cin>>n;
    cout<<max((ll)0, helper(n))<<endl; //注意为负数的情况
  }
  return 0; //完结撒花~
}
```
- **作者：shipeiqian（4星）**
  - **关键亮点**：思路阐述简洁明了，代码逻辑清晰，使用函数封装求解过程，对特殊情况（结果为负）的处理有明确注释。
```cpp
void solve(){
	long long n,maxl=0,minr=1e9;
	cin >>n;
	for(int i=1;i<=n;i++){
		long long l,r;
		cin >>l >>r;
		maxl=max(maxl,l);//最大左端点
		minr=min(minr,r);//最大右端点
	}
	cout <<max((long long)0,maxl-minr) <<endl;
    //如果右端点比左端点小，说明几条线段已经有公共点，输出0。
}
int main(){
	int t;
	cin >>t;
	while(t--){
		solve();
	}
	return 0;
}
```
- **作者：wind_whisper（4星）**
  - **关键亮点**：先给出问题描述和解题思路的数学表达，即要求均有交的充要条件是 $l\le\min r_i\land r\ge\max l_i$，所以答案是 $\max(0,\max l_i-\min r_i)$ ，然后给出代码，逻辑连贯。
```cpp
signed main(){
#ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
#endif
  int T=read();
  while(T--){
    int l=2e9,r=-2e9;
    n=read();
    for(int i=1;i<=n;i++){
      int x=read(),y=read();
      l=min(l,y);r=max(r,x);
    }
    r=max(l,r);
    printf("%d\n",r-l);
  }
  return 0;
}
```
### 最优关键思路或技巧
利用贪心思想，抓住问题本质，只关注所有线段左端点最大值和右端点最小值来确定所求最短线段。在代码实现上，注意初始化最大最小值的边界值，以及处理结果可能为负的情况。

### 拓展
此类题目属于区间贪心问题，常见的类似套路还有区间选点、区间覆盖等问题。比如给定多个区间，要求选择最少的点使得每个区间至少有一个点被选中；或者用最少的区间覆盖给定的范围等。

### 洛谷相似题目推荐
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)
- [P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781) 

---
处理用时：84.26秒
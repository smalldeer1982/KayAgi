# 题目信息

# Lucky Division

## 样例 #1

### 输入

```
47
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
16
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
78
```

### 输出

```
NO
```

# AI分析结果



# Lucky Division 中文翻译

## 题目描述
Petya喜欢数字，他将4和7视为幸运数字。如果一个数仅由4和7组成，它就是幸运数字。现给定一个整数n，判断n是否能被任意幸运数字整除（包括自身是幸运数字的情况）。若满足条件输出"YES"，否则输出"NO"。

## 样例

### 样例 #1

#### 输入
```
47
```

#### 输出
```
YES
```

### 样例 #2

#### 输入
```
16
```

#### 输出
```
YES
```

### 样例 #3

#### 输入
```
78
```

#### 输出
```
NO
```

## 算法分类
枚举

---

## 题解分析与结论

### 各题解对比

1. **Siyuan题解**  
   - 思路：先检查是否能被部分预定义的幸运数整除，再验证自身是否由4/7组成。
   - 问题：预定义幸运数列表不完整，可能导致漏判（如三位数幸运数的倍数）。
   - 评分：★★★☆☆  
   - 亮点：代码简洁，分阶段判断效率较高。

2. **Franka题解**  
   - 思路：预先生成所有1~1000内的幸运数，检查是否能被任一整除。
   - 评分：★★★★☆  
   - 亮点：打表法直接覆盖所有情况，时间复杂度低。
   - 缺点：需手动维护幸运数列表，扩展性差。

3. **TCZN题解**  
   - 思路：枚举所有三位数以内的幸运数进行整除判断。
   - 评分：★★★★☆  
   - 亮点：覆盖了三位数的所有可能组合，条件判断全面。

4. **yuzhechuan题解**  
   - 思路：遍历所有因数，动态检查是否为幸运数。
   - 评分：★★★★★  
   - 亮点：无需预生成列表，通用性强，正确性保证。
   - 关键代码：检查因数时逆向遍历优化效率。

5. **两年打铁题解**  
   - 思路：硬编码所有三位数幸运数，直接判断整除。
   - 评分：★★★★☆  
   - 亮点：条件判断覆盖全面，适合小范围数据。

---

## 精选题解

### 1. yuzhechuan题解（★★★★★）
**核心思路**：  
- 分两步验证：  
  1. 检查数字本身是否全由4/7组成（即自身是幸运数）。
  2. 遍历所有可能的因数，检查是否存在幸运数因数。

**关键代码**：  
```cpp
bool check(int x) {
    while (x > 0) {
        if (x % 10 != 4 && x % 10 != 7) 
            return false;
        x /= 10;
    }
    return true;
}

bool f(int x) {
    for (int i = x; i >= 1; i--) 
        if (x % i == 0 && check(i)) 
            return true;
    return false;
}
```

**个人心得**：  
- 逆向遍历因数（从大到小）可尽早命中较大幸运数，提升效率。
- 避免预生成列表，通用性强。

---

### 2. 两年打铁题解（★★★★☆）
**核心思路**：  
- 预先生成所有三位数以内的幸运数，直接判断是否能被整除。

**关键代码**：  
```cpp
if (a%4==0 || a%7==0 || a%44==0 || a%47==0 || a%74==0 || 
    a%77==0 || a%444==0 || a%447==0 || a%474==0 || 
    a%477==0 || a%744==0 || a%747==0 || a%774==0 || 
    a%777==0) {
    printf("YES\n");
}
```

**亮点**：  
- 硬编码覆盖所有可能，适合数据范围固定的场景。

---

### 3. Franka题解（★★★★☆）
**核心思路**：  
- 打表法预处理所有幸运数，快速判断整除关系。

**关键代码**：  
```pascal
a:array[1..11] of longint=(4,7,47,74,447,474,477,744,747,774,777);
for i:=1 to 11 do 
    if n mod a[i]=0 then p:=true;
```

**亮点**：  
- 时间复杂度O(1)，预处理提升运行时效率。

---

## 最优技巧总结
1. **因数遍历优化**：从大到小遍历因数，可快速命中符合条件的较大幸运数。
2. **动态检查代替预生成**：无需维护静态列表，通过逐位检查确保正确性。
3. **逆向思维**：判断是否存在幸运数因数，而非枚举所有可能的幸运数。

---

## 拓展练习
1. [P1217 [USACO1.5] 回文质数](https://www.luogu.com.cn/problem/P1217)（综合质数与回文判断）
2. [P1151 子数整数](https://www.luogu.com.cn/problem/P1151)（数字组合与枚举）
3. [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)（树遍历与递归构造）

---
处理用时：163.04秒
# 题目信息

# Character Swap (Easy Version)

## 题目描述

### 题意简述

给定两个长为 $n$ 的字符串 $s,t$。

您需要进行一次交换：找到一组 $i,j$ 满足 $1\leq i,j \leq n$，交换 $s_i$ 和 $t_j$。

问是否可以通过这次交换使得 $s=t$。

注意：您不能不进行交换。

## 样例 #1

### 输入

```
4
5
souse
houhe
3
cat
dog
2
aa
az
3
abc
bca
```

### 输出

```
Yes
No
No
No
```

# AI分析结果

### 题目内容
# 字符交换（简单版）

## 题目描述

### 题意简述
给定两个长度为 $n$ 的字符串 $s$、$t$。
您需要进行一次交换：找到一组 $i,j$ 满足 $1\leq i,j \leq n$，交换 $s_i$ 和 $t_j$ 。
问是否可以通过这次交换使得 $s=t$ 。
注意：您不能不进行交换。

## 样例 #1
### 输入
```
4
5
souse
houhe
3
cat
dog
2
aa
az
3
abc
bca
```
### 输出
```
Yes
No
No
No
```

### 算法分类
字符串

### 综合分析与结论
这些题解的核心思路都是基于只能进行一次交换操作，得出只有当两个字符串仅出现两处不同时才可能有合法方案，并且当满足此条件时，还需满足同一个字符串在不同的两个位置上字符一样，才能通过交换达成 $s=t$ 。各题解在实现细节上略有不同，但整体思路一致。

### 所选的题解
- **作者：Dream__Sky（5星）**
    - **关键亮点**：思路清晰，先点明暴力解法复杂度高，引出 $O(Tn)$ 做法。代码简洁明了，通过数组记录不同位置的下标，再根据条件判断。
    - **重点代码**：
```cpp
string work()
{
    int n,cnt=0;
    string s1,s2;
    int a[10];

    cin>>n;
    cin>>s1>>s2;
    for(int i=0;i<n;i++)
    {
        if(s1[i]!=s2[i]) a[++cnt]=i;
        if(cnt>2) return "No";
    }
    if(cnt!=2) return "No";

    if(s1[a[1]]==s1[a[2]]&&s2[a[1]]==s2[a[2]]) return "Yes";
    return "No";
}
```
核心实现思想：遍历两个字符串，用 `cnt` 统计不同字符的对数，用数组 `a` 记录不同字符的位置。若 `cnt` 大于2或不等于2 ，直接返回 `No`；否则判断两个字符串在不同位置处自身字符是否分别相同，是则返回 `Yes` ，否则返回 `No`。
- **作者：qinmingze（4星）**
    - **关键亮点**：用图片辅助说明思路，形象直观。代码逻辑清晰，通过字符串数组 `f` 存储不同的字符，再根据条件判断。
    - **重点代码**：
```cpp
int main(){
    int T;
    cin >> T;
    while(T--){
        int n;
        cin >> n;
        string s, t;
        cin >> s >> t;
        string f[2];
        for(int i = 0; i < n; i++){
            if(s[i]!= t[i]){
                f[0] += s[i];
                f[1] += t[i];
            }
        }
        if(f[0].size() == 2 && f[1].size() == 2 && f[1][0] == f[1][1] && f[0][0] == f[0][1])cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
```
核心实现思想：遍历字符串，将不同位置的 `s` 串字符和 `t` 串字符分别存入 `f[0]` 和 `f[1]` ，最后判断 `f[0]` 和 `f[1]` 的长度是否都为2且各自字符是否相同，满足则输出 `Yes` ，否则输出 `No`。
- **作者：Digital_Sunrise（4星）**
    - **关键亮点**：采用逆向思维，从交换后的结果反推满足条件的字符串特征，逻辑独特。代码结构清晰，函数封装性好。
    - **重点代码**：
```cpp
void solve()
{
    c1 = c2 = -1;
    int sum = 0;
    for(int i = 0;i < n;i++)
    {
        if(s[i]!= t[i])
        {
            sum++;
            if(c1 == -1)
                c1 = i;
            else
                c2 = i;
        }
        if(sum > 2)
        {
            printf("No\n");
            return;
        }
    }
    if(sum!= 2)
    {
        printf("No\n");
        return;
    }
    if(s[c1] == s[c2] and t[c2] == t[c1])
    {
        printf("Yes\n");
        return;
    }
    printf("No\n");
}
```
核心实现思想：遍历字符串，用 `sum` 统计不同字符对数，用 `c1` 和 `c2` 记录不同字符位置。若 `sum` 大于2或不等于2 ，输出 `No` ；否则判断两个字符串在不同位置处自身字符是否分别相同，相同则输出 `Yes` ，否则输出 `No`。

### 最优关键思路或技巧
逆向思维，从交换后的理想结果反推原字符串应满足的条件，能更清晰地得出判断依据。同时，在遍历字符串找不同字符时，及时记录位置和统计对数，以便后续判断。

### 可拓展之处
同类型题目可关注字符串交换、匹配相关问题，类似算法套路是通过分析操作次数和结果之间的关系，找出满足条件的字符串特征，进而解决问题。

### 推荐题目
- [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)
- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)
- [P1593 因子和阶乘](https://www.luogu.com.cn/problem/P1593) 

---
处理用时：58.13秒
# 题目信息

# Rooms and Staircases

## 题目描述

有两层房间，每层 $n$ 个，我们用数对 $(a, b)$ 来表示每个房子，其中 $a$ 表示第几层，$b$ 表示从左向右数第几个

对于房子 $(1, i)$ 或 $(2, i)$，都与 $(1, i - 1), (1, i + 1)$ 或 $(2, i - 1), (2, i + 1)$ 相连

而在若干个或个位置中，又有一个双向的梯子，具体来说，若在 $i$ 的位置有一个梯子，则 $(1, i), (2, i)$ 是相连的

求不重复经过同一个房间的情况下，最多能走过多少个房间

## 样例 #1

### 输入

```
4
5
00100
8
00000000
5
11111
3
110
```

### 输出

```
6
8
10
6
```

# AI分析结果

### 题目重写
# 房间与楼梯

## 题目描述
有两层房间，每层有\(n\)个。我们用数对\((a, b)\)来表示每个房间，其中\(a\)表示层数，\(b\)表示从左向右数的序号。
对于房间\((1, i)\)或\((2, i)\)，它们分别与\((1, i - 1)\)、\((1, i + 1)\) 或\((2, i - 1)\)、\((2, i + 1)\)相连。
在若干位置上，设有双向的梯子。具体而言，若在\(i\)位置有梯子，则\((1, i)\)与\((2, i)\)相连。
求在不重复经过同一个房间的情况下，最多能走过多少个房间。

## 样例 #1
### 输入
```
4
5
00100
8
00000000
5
11111
3
110
```
### 输出
```
6
8
10
6
```

### 算法分类
贪心

### 综合分析与结论
1. **思路对比**：
    - **sinsop90**：采用轮廓线dp，将行列反转，设\(f_{i,j,s,0/1}\)表示到\((i,j)\)这个格子的轮廓线状态，通过分情况讨论\((i,0)\)和\((i,1)\)位置的转移来求解。
    - **B_Qu1e7**：考虑三种可能答案，一是一层走过两次，但认为楼梯数\(s\geq2\)时此情况不如另一种；二是一层只走一次，遇到楼梯时计算\(ans = max(ans, max(2 * i, 2 * (n - i + 1)))\)；三是没有楼梯时答案为\(n\)。
    - **littlebug**：分情况讨论，设最左边梯子位置为\(l\)，最右边为\(r\)，分析不同走法如从一楼左边经梯子到二楼右边、返回一楼左边等的答案，认为方案B（从一楼左边经梯子返回一楼左边或从一楼右边开始类似情况）和方案D（走多个梯子且一直向右走）可行，要特判无梯子情况。
    - **我梦见一片焦土**：若不存在\(1\)（即无楼梯）答案为\(n\)，存在时用\(l\)，\(r\)记录\(1\)出现的最左和最右位置，比较\(l\)位置贡献\(i \times 2\)和\(r\)位置贡献\((n - l + 1) \times 2\)取最大。
    - **回青绝影**：先判断有无楼梯，无楼梯输出\(n\)，有楼梯则贪心找端点的两个楼梯，比较从左边走最右边楼梯和从右边走最左边楼梯的距离。
    - **installb**：认为只有从右上角走到最左边的\(1\)再往下走到右下角，或从左上角走到最右边的\(1\)再往下走到左下角这两种走法可能是最大值，取\(max\{r\times 2,(n - l + 1)\times 2\}\)，其中\(l\)、\(r\)为最左和最右的\(1\)的位置。
    - **floodfill**：判断输入的\(01\)串有无梯子，无则输出\(n\)，有则输出\(\max\left\{2i,2(n - i + 1)\right\}\)。
    - **jixiyue114514**：从第\(1\)间或\(n\)间屋子开始，走到最远的电梯，经过房屋数乘\(2\)取最大。
    - **GoodLuckCat**：分析出最短路线三种情况，一是从第二层最左走到最右梯子下来再到第一层最左；二是从第二层最右走到最左梯子下来再到第一层最右；三是无梯子只能走\(n\)个房间，特判第三种并比较前两种路程。
    - **远辰**：维护最前面的\(1\)和最后面的\(1\)的位置，比较它们与两端房间的距离，类似走回环，梯子数大于等于\(1\)适用，特判全为零情况。
    - **xukuan**：考虑从左往右每有楼梯变换楼层、到最右边楼梯上楼走到最左边、从右往左到最左边楼梯上楼走到最右边这三种路径。
2. **算法要点**：多数题解通过分析不同走法，利用贪心思想，找到关键位置（如最左和最右的梯子位置），通过比较不同走法下经过房间数来确定最大值，同时注意无梯子时的特判。
3. **解决难点**：难点在于分析各种可能的行走路径，并证明为何某些走法不是最优，从而确定贪心策略。如部分题解需要证明一层走过两次的情况在某些条件下不如一层只走一次的情况。

### 所选的题解
 - **作者：B_Qu1e7 (4星)**
    - **关键亮点**：思路清晰，简洁地分析了三种可能的答案情况，通过合理的推理排除一种情况，直接得出最终的贪心策略，代码简洁明了。
    - **重点代码**：
```cpp
#include<cstdio>
#include<algorithm>
#define R register
using namespace std;
int T,N;
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        R int ans=0,p=0;
        scanf("%d",&N);
        for(R int i=1,x;i<=N;++i)
        {
            scanf("%1d",&x);
            p|=x;
            if(x)ans=max(ans,max(i,N - i + 1));
        }
        if(!p)
        {
            printf("%d\n",N);
        }
        else
        {
            printf("%d\n",ans<<1);
        }
    }
}
```
    - **核心实现思想**：遍历输入的数字判断是否有楼梯，有则计算一层最大能走过的房间数量（通过比较当前位置\(i\)和\(N - i + 1\)），最后根据有无楼梯输出相应结果，有楼梯则将一层最大房间数乘\(2\)。
 - **作者：littlebug (4星)**
    - **关键亮点**：详细地分情况讨论了各种走法，清晰地阐述了每种走法的答案计算方式，最后总结出可行的方案，并通过代码实现，逻辑连贯。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
//#define int long long
#define il inline
using namespace std;

int n;
string s;

il void solve()
{
    cin>>n>>s; s="$"+s;

    int l=2e9,r=-2e9,cnt=0;
    for(int i=1;i<=n;++i) if(s[i]=='1') l=min(l,i),r=max(r,i),++cnt;

    if(l==2e9)
    {
        cout<<n<<'\n';
        return;
    }

    cout<<max(n+cnt,max(r<<1,(n - l + 1)<<1))<<'\n';
}

signed main()
{
    ios::sync_with_stdio(0);
    ios_base::sync_with_stdio(0);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin>>T;
    while(T--)
        solve();
    return 0;
}
```
    - **核心实现思想**：先找到最左和最右的梯子位置\(l\)、\(r\)以及梯子数量\(cnt\)，若没有梯子输出\(n\)，否则比较\(n + cnt\)、\(r \times 2\)、\((n - l + 1) \times 2\)的大小并输出最大值。
 - **作者：installb (4星)**
    - **关键亮点**：通过图形辅助说明，直观地阐述了只有两种走法可能是最大值，并给出了严谨的数学推理，代码实现简洁高效。
    - **重点代码**：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
using namespace std;
typedef long long LL;
 
LL t,n,m,k;
string s;
 
int main(){
    ios::sync_with_stdio(false);
    cin >> t;
    while(t --){
        cin >> n;
        LL lmx = n + 1,rmx = 0;
        cin >> s; s = ' ' + s;
        for(LL i = 1;i <= n;i ++){
            if(s[i] == '1'){
                lmx = min(lmx,i);
                rmx = max(rmx,i);
            }
        }
        if(!rmx){
            cout << n << endl;
            continue;
        }
        LL ans = max(rmx * 2,(n - lmx + 1) * 2);
        cout << ans << endl;
    }
    return 0;
}
```
    - **核心实现思想**：遍历字符串找到最左和最右的\(1\)的位置\(lmx\)、\(rmx\)，若没有\(1\)输出\(n\)，否则计算\(max\{rmx \times 2,(n - lmx + 1) \times 2\}\)并输出。

### 最优关键思路或技巧
通过分析不同行走路径，利用贪心思想，找到最左和最右的梯子位置，比较从两端出发经过梯子后能走过的房间数，同时注意对无梯子情况进行特判。这种思路避免了复杂的搜索或动态规划，简化了问题的求解过程。

### 可拓展之处
同类型题通常是在网格图或类似结构中，添加一些特殊连接或限制条件，求最长路径或最大访问点数。类似算法套路是先分析可能的路径情况，通过合理推理排除非最优路径，确定贪心策略。例如在有多种特殊通道或不同权值的网格中求最优路径问题。

### 洛谷题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略解决合并问题，与本题通过分析不同情况确定最优策略类似。
2. **P1199 [NOIP2010 普及组] 三国游戏**：同样需要分析各种情况，利用贪心思想找到最优解。
3. **P1223 排队接水**：典型的贪心算法题目，根据不同条件确定最优排队顺序，和本题思路有相似之处。

### 个人心得摘录与总结
 - **回青绝影**：最初考虑了只有一个楼梯的特殊情况，但错误地采用了\(ans = max(n + 1, 2 * ans1)\)的计算方式导致错误。总结为在分析问题时，对特殊情况的处理需要更加严谨，不能仅凭直觉设定计算方式，要深入思考其合理性。 

---
处理用时：94.31秒
# 题目信息

# Beautiful String

## 题目描述

### 题意简述



给定字符串 $s$，由 `a`，`b`，`c`，`?` 四种字符构成。



您需要将 $s$ 中的所有 `?` 修改为 `a`，`b`，`c` 中的一种，使得 $s$ 相邻两个字符均不相同。

## 样例 #1

### 输入

```
3
a???cb
a??bbc
a?b?c
```

### 输出

```
ababcb
-1
acbac
```

# AI分析结果

### 题目内容
# 美丽字符串

## 题目描述

### 题意简述
给定字符串 $s$，由 `a`，`b`，`c`，`?` 四种字符构成。
您需要将 $s$ 中的所有 `?` 修改为 `a`，`b`，`c` 中的一种，使得 $s$ 相邻两个字符均不相同。

## 样例 #1
### 输入
```
3
a???cb
a??bbc
a?b?c
```
### 输出
```
ababcb
-1
acbac
```
### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路较为一致，都是先判断原字符串是否存在无解情况（即存在相邻且相等的非 `?` 字符），若有则直接输出 `-1`。对于有解的情况，通过遍历字符串，针对每个 `?` 字符，依据其前后字符来确定替换字符。不同题解在具体实现细节上有所差异，例如判断无解的方式、处理 `?` 字符时的逻辑分支以及代码的结构和风格等。

### 所选的题解
- **作者：Aybbl_xc (赞：2)  星级：4星**
    - **关键亮点**：思路清晰，代码结构简单明了。先通过遍历标记判断字符串是否有相邻相等的非 `?` 字符，再通过自定义函数 `cmp` 模拟替换 `?` 字符的所有情况。
    - **重点代码**：
```cpp
char cmp(int k){//模拟答案
    if(k - 1 == -1){
        if(s[k + 1] == 'a')return 'b';
        if(s[k + 1] == 'b')return 'c';
        if(s[k + 1] == 'c')return 'a';
        return 'a';
    }
    if(s[k - 1] == 'a'){
        if(s[k + 1] == 'b')return 'c';
        if(s[k + 1] == 'c')return 'b';
        return 'c';
    }
    if(s[k - 1] == 'b'){
        if(s[k + 1] == 'a')return 'c';
        if(s[k + 1] == 'c')return 'a';
        return 'a';
    }
    if(s[k - 1] == 'c'){
        if(s[k + 1] == 'a')return 'b';
        if(s[k + 1] == 'b')return 'a';
        return 'b';
    }
}
for(int i = 1; i < l; i++){
    if(s[i] == s[i - 1] && s[i]!='?'){//判断是否相等
        flag = true;
        break;
    }
}
if(flag == true){//如果重复直接退出
    cout << -1 << endl;
    continue;
}
for(int i = 0; i < l; i++){//直接模拟
    if(s[i] == '?') s[i] = cmp(i);//把所有情况枚举一遍
}
```
核心实现思想：`cmp` 函数根据 `?` 字符的前后字符情况，返回合适的替换字符。主程序先判断字符串是否无解，再遍历字符串替换 `?` 字符。
- **作者：Cappuccino_mjj (赞：1)  星级：4星**
    - **关键亮点**：代码简洁，将判断字符串是否合法和模拟替换 `?` 字符的过程分别封装成函数 `f` 和 `calc`，逻辑清晰。
    - **重点代码**：
```cpp
bool f()
{//判断合法
    for(int i = 1; i < a.size(); i++)
        if(a[i] == a[i - 1] && a[i]!='?')
            return true;
    return false;
}
char calc(int id)
{//模拟答案
    if(id - 1 == -1){
        if(a[id + 1] == 'a')return 'b';
        if(a[id + 1] == 'b')return 'c';
        if(a[id + 1] == 'c')return 'a';
        return 'a';
    }
    if(a[id - 1] == 'a'){
        if(a[id + 1] == 'b')return 'c';
        if(a[id + 1] == 'c')return 'b';
        return 'c';
    }
    if(a[id - 1] == 'b'){
        if(a[id + 1] == 'a')return 'c';
        if(a[id + 1] == 'c')return 'a';
        return 'a';
    }
    if(a[id - 1] == 'c'){
        if(a[id + 1] == 'a')return 'b';
        if(a[id + 1] == 'b')return 'a';
        return 'b';
    }
}
if(f())
{//判断是否合法
    cout << -1 << endl;
    continue;
}
for(int i = 0; i < a.size(); i++){
    if(a[i] == '?'){
        a[i] = calc(i);//模拟任意一个答案
    }
}
```
核心实现思想：`f` 函数遍历字符串判断是否有相邻相等的非 `?` 字符，`calc` 函数根据 `?` 字符前后情况返回替换字符，主程序调用这两个函数完成判断和替换。
- **作者：Soaring_light (赞：1)  星级：4星**
    - **关键亮点**：在处理 `?` 字符时，针对不同位置（开头、结尾、中间）进行了细致的分类讨论，并且在选择替换字符时尽量使用字典序小的字符，减小偶然性。
    - **重点代码**：
```cpp
for(int j = 0; j <= s.length() - 1; j++){
    if(j!= 0 && s[j] == s[j - 1] && s[j]!='?'){
        cout << -1 << endl;
        opt = 1;break;
    }else//判断字符串是否合法
        if(s[j] == '?'){
            if(j == 0){
                if(s[j + 1] == 'a')s[j] = 'b';
                else s[j] = 'a';
            }
            if(j == s.length() - 1 || (j <= s.length() - 2 && s[j + 1] == '?')){
                if(s[j - 1] == 'a')s[j] = 'b';
                else s[j] = 'a';
            }
            if(j <= s.length() - 2 && s[j + 1]!='?'){
                if(s[j - 1] == s[j + 1]){
                    if(s[j - 1] == 'a')s[j] = 'b';
                    else s[j] = 'a';
                }else
                    for(int l = 0; l <= 2; l++){
                        s[j] = char(l + int('a'));
                        if(s[j]!= s[j - 1] && s[j]!= s[j + 1])
                            break;
                    }
            }
        }
}
```
核心实现思想：先判断字符串是否无解，对于 `?` 字符，根据其在字符串中的位置，选择合适的替换字符，保证相邻字符不同。

### 最优关键思路或技巧
处理此类字符串替换问题，关键在于清晰地判断无解情况，并针对不同位置的待替换字符（本题中的 `?`），依据其周围字符的情况进行合理替换。可以通过封装函数的方式使代码逻辑更加清晰，同时在替换字符选择上，考虑不同位置的特殊情况，尽量简化逻辑。

### 可拓展之处
同类型题目通常围绕字符串的特定规则修改或生成展开，类似算法套路是先确定无解条件，再针对可修改字符根据其上下文环境进行处理。例如，可能会增加字符种类、改变相邻字符限制规则等。

### 相似知识点洛谷题目
- [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)：涉及字符串处理和简单的校验规则。
- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：主要考察字符串查找与统计。
- [P1593 因子和阶乘](https://www.luogu.com.cn/problem/P1593)：结合了数学运算和字符串处理。

### 个人心得摘录与总结
无。 

---
处理用时：73.43秒
# 题目信息

# Just Eat It!

## 题目描述

### 题意简述

给定长度为 $n$ 的数列 $a=[a_1,a_2,...,a_n]$。

Yasser 会选择所有的 $n$ 个数，并算出它们的和 $\sum a_i$。

Adel 会选择两个正整数 $l,r(1\leq l \leq r \leq n)$，并算出 $\sum_{i=l}^{r} a_i$。Adel 不能选择 $l=1,r=n$。

如果 Yasser 算出的和在任意情况下（即 Adel 选取任意的 $l,r$ 都是如此）**严格大于** Adel 算出的，那么 Yasser 会开心。否则 Yasser 不会开心。

请你判断 Yasser 是否开心。

## 样例 #1

### 输入

```
3
4
1 2 3 4
3
7 4 -1
3
5 -5 5```

### 输出

```
YES
NO
NO```

# AI分析结果

### 题目内容
# 吃就对了！

## 题目描述

### 题意简述
给定长度为 $n$ 的数列 $a=[a_1,a_2,\cdots,a_n]$。
Yasser 会选择所有的 $n$ 个数，并算出它们的和 $\sum a_i$。
Adel 会选择两个正整数 $l,r(1\leq l \leq r \leq n)$，并算出 $\sum_{i=l}^{r} a_i$。Adel 不能选择 $l=1,r=n$。
如果 Yasser 算出的和在任意情况下（即 Adel 选取任意的 $l,r$ 都是如此）**严格大于** Adel 算出的，那么 Yasser 会开心。否则 Yasser 不会开心。
请你判断 Yasser 是否开心。

## 样例 #1
### 输入
```
3
4
1 2 3 4
3
7 4 -1
3
5 -5 5
```
### 输出
```
YES
NO
NO
```

### 算法分类
动态规划

### 题解综合分析与结论
所有题解核心思路都是求出不含两端的最大子段和，并与整个序列的和比较。不同题解在实现求最大子段和时，有的使用经典动态规划思路，有的通过前缀和优化等方式。部分题解代码存在一些小问题，如第一个题解中 `#include <iostrem>` 应为 `#include <iostream>`。

### 所选的题解
- **作者：Jerrycyx (赞：1)，星级：4 星**
    - **关键亮点**：思路清晰，对题意简化准确，详细说明了动态规划状态转移方程的推导，且明确指出时间复杂度为 $O(n)$，在所有题解中最快。
    - **重点代码核心实现思想**：通过动态规划，定义 $p_i$ 表示从 $a_1$ 到 $a_i$ 的最大连续子序列和，每次根据 $p_{i - 1} + a_i$ 与 $a_i$ 的大小关系决定是否将 $a_i$ 加入之前的连续子序列，同时用 $l$ 记录左端点排除最大连续子序列为原序列的情况。
    ```cpp
    for(int i=1;i<=n;i++)
    {
        if(p[i-1]+a[i]>a[i])
        {
            if(l==1&&i==n) continue;
            p[i]=p[i-1]+a[i];
        }
        else p[i]=a[i],l=i;
        ans=max(ans,p[i]);
    }
    ```
- **作者：chenyuchenghsefz (赞：3)，星级：4 星**
    - **关键亮点**：同样采用动态规划，清晰阐述了状态转移的两种情况，代码简洁明了。
    - **重点代码核心实现思想**：与 Jerrycyx 的思路类似，通过动态规划判断每一个 $a_i$ 是否加入之前的连续子序列，用 $l$ 记录连续子序列左端点，排除最大连续子序列为原序列的情况。
    ```cpp
    for(int j=1;j<=n;j++)
    {
        if(f[j-1]>0)
        {
            if(l==1&&j==n)
            continue;
            f[j]=f[j-1]+a[j];
        }
        else
        f[j]=a[j],l=j;
        ans=max(ans,f[j]);
    }
    ```
- **作者：zjhzs666 (赞：1)，星级：4 星**
    - **关键亮点**：给出多种解法思路对比，从暴力枚举到前缀和优化再到正解动态规划，让读者对不同优化层次有清晰认识。
    - **重点代码核心实现思想**：动态规划求解最大子段和，根据当前子段和 $mx$ 与 0 的关系决定是否将新元素加入子段，并用 $l$ 记录左端点避免最大子段为原序列。
    ```cpp
    for(int i=1;i<=n;i++){
        if(mx>0){
            if(l==1&&i==n)
                continue;
            mx+=x;
        }
        else mx=x,l=i;
        ans=max(ans,mx);
    }
    ```

### 最优关键思路或技巧
动态规划求解最大子段和，通过记录子段左端点来排除最大子段为原序列的情况，优化时间复杂度到 $O(n)$。

### 可拓展之处
此类题目属于动态规划在序列和问题上的应用，类似套路可用于求解其他限制条件下的最大子段和、最大子矩阵和等问题。

### 推荐洛谷题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：经典最大子段和问题，可作为基础练习。
- [P5020 货币系统](https://www.luogu.com.cn/problem/P5020)：涉及动态规划的背包问题变体，锻炼对动态规划的理解。
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：动态规划在序列匹配问题上的应用，与本题动态规划思路有相似之处。

### 个人心得摘录与总结
多位作者提到要注意开 `long long`，因为序列和及最大子段和可能超出 `int` 范围。这反映出在处理数值计算问题时，要充分考虑数据范围，避免因数据类型选择不当导致错误。 

---
处理用时：53.71秒
# 题目信息

# Fast Food Restaurant

## 题目描述

由于Denis工作得很累，他想开家餐厅。

第一天，他做了 $a$ 份饺子，$b$ 份莓果汁和 $c$ 份淋有炼乳的松饼。

Denis餐厅奇怪的地方在于订餐的过程。对于每位客人Denis会自己选**一份套餐**给客人。

Denis选**套餐**的规则是这样的：

1. 每个客人都要至少有一份**食物**（饺子、莓果汁、淋有炼乳的松饼都是食物）。

2. 每个客人**不能收到多于一份饺子**，**不能收到多于一份莓果汁**，**且不能收到多于一份淋有炼乳的松饼**。

3. 每个客人都要有**不一样**的套餐。

Denis**最多**可以为几个客人提供套餐呢？

## 样例 #1

### 输入

```
7
1 2 1
0 0 0
9 1 7
2 2 3
2 3 2
3 2 2
4 4 4```

### 输出

```
3
0
4
5
5
5
7```

# AI分析结果

### 题目内容
# 快餐店

## 题目描述
由于Denis工作得很累，他想开家餐厅。
第一天，他做了 $a$ 份饺子，$b$ 份莓果汁和 $c$ 份淋有炼乳的松饼。
Denis餐厅奇怪的地方在于订餐的过程。对于每位客人Denis会自己选**一份套餐**给客人。
Denis选**套餐**的规则是这样的：
1. 每个客人都要至少有一份**食物**（饺子、莓果汁、淋有炼乳的松饼都是食物）。
2. 每个客人**不能收到多于一份饺子**，**不能收到多于一份莓果汁**，**且不能收到多于一份淋有炼乳的松饼**。
3. 每个客人都要有**不一样**的套餐。
Denis**最多**可以为几个客人提供套餐呢？

## 样例 #1
### 输入
```
7
1 2 1
0 0 0
9 1 7
2 2 3
2 3 2
3 2 2
4 4 4
```
### 输出
```
3
0
4
5
5
5
7
```

### 算法分类
枚举

### 综合分析与结论
这些题解主要围绕如何确定满足条件的最大套餐数展开。由于数据范围较小，各题解都采用了不同形式的枚举策略。主要难点在于如何全面且不重复地考虑所有可能的套餐组合，并找到最优解。有的题解因未合理考虑不同食物数量的组合顺序而出现漏洞，后通过排序等方式优化。

### 所选的题解
- **作者：rui_er (5星)**
    - **关键亮点**：思路清晰简洁，先将食物数量降序排序，然后直接枚举7种可能的套餐组合情况，代码实现简洁明了。
    - **重点代码**：
```cpp
while(t--)
{
    ans = 0;
    cin>>a[0]>>a[1]>>a[2];
    if(a[0] < a[1]) swap(a[0], a[1]);
    if(a[0] < a[2]) swap(a[0], a[2]);
    if(a[1] < a[2]) swap(a[1], a[2]);
    if(a[0]) --a[0], ++ans;
    if(a[1]) --a[1], ++ans;
    if(a[2]) --a[2], ++ans;
    if(a[0] && a[1]) --a[0], --a[1], ++ans;
    if(a[0] && a[2]) --a[0], --a[2], ++ans;
    if(a[1] && a[2]) --a[1], --a[2], ++ans;
    if(a[0] && a[1] && a[2]) --a[0], --a[1], --a[2], ++ans;
    cout<<ans<<endl;
}
```
    - **核心实现思想**：通过排序保证每次优先从数量最多的食物开始枚举组合，依次判断每种套餐组合是否可行，可行则更新答案并减少对应食物数量。

- **作者：bunH2O (4星)**
    - **关键亮点**：先分析出每位客人对每种食品只有买或不买两种选择，从而确定枚举所有情况的思路。在发现简单枚举的漏洞后，提出先取最大数量食物的优化方法。
    - **个人心得**：意识到简单按顺序枚举会在某些数据下出错，如“2 2 3”，进而思考并提出先取最大数量食物的改进策略。
    - **重点代码**：
```cpp
sort(a,a+3,cmp);
sum=0;
//先取一个
if(a[0]>0)
{
    a[0]--;
    sum++;
}
if(a[1]>0)
{
    a[1]--;
    sum++;
}
if(a[2]>0)
{
    a[2]--;
    sum++;
}
//然后两个
if(a[0]>0&&a[1]>0)//先大
{
    a[0]--;
    a[1]--;
    sum++;
}
if(a[0]>0&&a[2]>0)
{
    a[0]--;
    a[2]--;
    sum++;
}
if(a[2]>0&&a[1]>0)//后小
{
    a[2]--;
    a[1]--;
    sum++;
}
//三个
if(a[0]>0&&a[1]>0&&a[2]>0)
{
    a[0]--;
    a[1]--;
    a[2]--;
    sum++;
}
```
    - **核心实现思想**：先对食物数量降序排序，然后按照先取单个食物、再取两种食物组合、最后取三种食物组合的顺序枚举，每种情况判断当前食物数量是否满足，满足则更新答案并减少对应食物数量。

- **作者：registerGen (4星)**
    - **关键亮点**：通过分析得出可将大于4的食物数量变为4且答案与顺序无关的结论，进而采用打表法解题，效率较高。
    - **重点代码**：
```cpp
// 打表
void init()
{
    ans[0][0][0]=0;
    ans[0][0][1]=1;
    ans[0][0][2]=1;
    ans[0][0][3]=1;
    ans[0][0][4]=1;
    ans[0][1][1]=2;
    ans[0][1][2]=2;
    ans[0][1][3]=2;
    ans[0][1][4]=2;
    ans[0][2][2]=3;
    ans[0][2][3]=3;
    ans[0][2][4]=3;
    ans[0][3][3]=3;
    ans[0][3][4]=3;
    ans[0][4][4]=3;
    ans[1][1][1]=3;
    ans[1][1][2]=3;
    ans[1][1][3]=3;
    ans[1][1][4]=3;
    ans[1][2][2]=4;
    ans[1][2][3]=4;
    ans[1][2][4]=4;
    ans[1][3][3]=4;
    ans[1][3][4]=4;
    ans[1][4][4]=4;
    ans[2][2][2]=4;
    ans[2][2][3]=5;
    ans[2][2][4]=5;
    ans[2][3][3]=5;
    ans[2][3][4]=5;
    ans[2][4][4]=5;
    ans[3][3][3]=6;
    ans[3][3][4]=6;
    ans[3][4][4]=6;
    ans[4][4][4]=7;
}

int main()
{
    init();
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        if(a>4)a=4;if(b>4)b=4;if(c>4)c=4;
        // 排序
        if(a>b)std::swap(a,b);if(a>c)std::swap(a,c);if(b>c)std::swap(b,c);
        printf("%d\n",ans[a][b][c]);
    }
    return 0;
}
```
    - **核心实现思想**：预先计算并存储不同食物数量组合对应的最大套餐数，程序运行时读取输入并处理后直接查表输出答案。

### 最优关键思路或技巧
- **排序优化枚举**：将食物数量排序后进行枚举，优先从数量多的食物开始组合，能有效避免遗漏最优解，如rui_er和bunH2O的题解。
- **打表法**：registerGen通过分析数据特点，采用打表法直接获取答案，在数据范围较小时效率高且代码简洁。

### 拓展
同类型题通常围绕有限资源的组合分配，且数据范围不大，可考虑枚举所有可能组合来求解。类似算法套路包括根据题目条件对数据进行预处理（如排序、缩小范围等），优化枚举过程，提高效率。

### 推荐题目
- **P1164 小A点菜**：通过枚举菜品组合来确定满足预算的方案数，与本题枚举套餐组合思路类似。
- **P1308 统计单词数**：在给定文本中枚举单词出现的位置及次数，锻炼枚举相关的代码实现能力。
- **P1469 找筷子**：通过枚举数组元素并结合位运算找到唯一出现一次的数，可拓展枚举与其他算法结合的解题思路。 

---
处理用时：75.32秒
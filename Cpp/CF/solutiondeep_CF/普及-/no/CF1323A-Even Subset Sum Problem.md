# 题目信息

# Even Subset Sum Problem

## 题目描述

### 题意简述

给定数组 $a$，求出它一个和为偶数的的非空子集。

## 说明/提示

$1 \leq t,n,a_i \leq 100$。

翻译 by Meatherm

## 样例 #1

### 输入

```
3
3
1 4 3
1
15
2
3 5```

### 输出

```
1
2
-1
2
1 2```

# AI分析结果

### 题目内容
# 偶数子集和问题

## 题目描述

### 题意简述
给定数组 $a$，求出它一个和为偶数的的非空子集。

## 说明/提示
$1 \leq t,n,a_i \leq 100$。
翻译 by Meatherm

## 样例 #1
### 输入
```
3
3
1 4 3
1
15
2
3 5
```
### 输出
```
1
2
-1
2
1 2
```
• **算法分类**：数学
• **综合分析与结论**：这几道题解的核心思路都是基于数学性质，即偶数个奇数相加或任意个偶数相加的和为偶数。大部分题解都通过判断数组中偶数和奇数的数量来寻找符合条件的子集，少数采用暴力枚举。各题解的差异主要体现在实现细节和代码风格上。
• **所选的题解**：
  - **作者：do_while_false（5星）**
    - **关键亮点**：思路清晰，通过简洁的代码实现了对偶数和奇数的判断与处理，使用了自定义的输入输出函数。
    - **个人心得**：无
    - **重点代码核心思想**：遍历数组，先找偶数，若找到则直接输出该偶数；若未找到偶数，在找奇数过程中，记录前两个奇数位置并输出。若既无偶数又无两个奇数则输出 -1。
```cpp
int main(){
    t=read();
    while(t--){
        flag=pre=0;
        n=read();
        for(i=1;i<=n;i++) a[i]=read();
        for(i=1;i<=n;i++) {
            if(a[i]%2==0) {
                write(1);write(i);
                flag=1;
                break;
            }
            else if(!pre) pre=i;
            else {
                now=i;
                flag=1;
                write(2);
                printf("%d %d\n",pre,now);
                break;
            }
        }
        if(flag==0) printf("-1\n");
    }
    return 0;
}
```
  - **作者：CBW2007（4星）**
    - **关键亮点**：代码简洁明了，逻辑清晰，按照先找偶数，再判断奇数数量的顺序进行处理。
    - **个人心得**：无
    - **重点代码核心思想**：遍历数组找偶数，若有则输出；若无偶数且数组元素个数小于等于1输出 -1，否则输出前两个元素。
```cpp
int n;
cin>>n;
bool flag=false;
for (int i=1;i<=n;i++)
{
    int ai;
    cin>>ai;
    if (ai%2==0&&!flag)
    {
        cout<<1<<endl;
        cout<<i<<endl;
        flag=true;
    }
}
if (flag)
    continue;
if (n<=1)
    cout<<-1<<endl;
else
{
    cout<<2<<endl;
    cout<<1<<" "<<2<<endl;
}
```
  - **作者：do_while_true（4星）**
    - **关键亮点**：代码结构清晰，使用变量明确记录状态，便于理解。
    - **个人心得**：无
    - **重点代码核心思想**：遍历数组，遇到偶数输出该偶数，遇到奇数记录，当记录到两个奇数时输出这两个奇数，若无合适子集输出 -1。
```cpp
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        cnt=fl=0;
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        for(int i=1;i<=n;i++)
        {
            if(a[i]%2==0){
                printf("1\n%d\n",i);
                fl=1;
                break;
            }
            if(a[i]%2==1){
                ji[++cnt]=i;
                if(cnt==2){
                    printf("2\n%d %d\n",ji[1],ji[2]);
                    fl=1;
                    break;
                }
            }
        }
        if(!fl) printf("-1\n");
    }
    return 0;
}
```
• **最优关键思路或技巧**：利用偶数个奇数相加和为偶数，任意个偶数相加和为偶数的数学性质，通过遍历数组判断偶数和奇数的存在情况，快速找到符合条件的子集，避免了暴力枚举所有子集的高时间复杂度。
• **可拓展之处**：此类题目可拓展到更复杂的条件限制，如要求子集和为某个特定偶数，或者在多维数组中寻找满足条件的子集等。类似算法套路是先分析目标结果的数学性质，再根据数据特点进行针对性处理。
• **洛谷相似题目推荐**：
  - [P1036 选数](https://www.luogu.com.cn/problem/P1036)：从给定数字中选数，使其和为质数，与本题类似，需通过数学性质筛选符合条件的组合。
  - [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：通过分析数字和的性质，寻找连续自然数序列，考察对数学关系的运用。
  - [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)：结合图论和数学性质，找到最小环，与本题都需要挖掘数据背后隐藏的数学规律来解题。 

---
处理用时：53.43秒
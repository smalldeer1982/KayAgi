# 题目信息

# Yet Another Tetris Problem

## 题目描述

你有一个数列 $\{a_n\}$，现在有两种操作：

1. 当数列 $\{a_n\}$ 的任意一项大于 $0$ 时，你可以选择**一些** $i(1\le i\le n)$，把每个 $a_i$ 加上 $2$。
2. 当数列 $\{a_n\}$ 的每一项都大于 $0$ 时，把这个数列的每一项都减去 $1$。

问你最后能不能把 $\{a\}$ 数组的元素全部变成 $0$。如果能，输出 `YES`，不然输出 `NO`。

## 说明/提示

$1\le t\le 100$，$1\le n\le 100$，$1\le a_i\le 100$。

## 样例 #1

### 输入

```
4
3
1 1 3
4
1 1 2 1
2
11 11
1
100```

### 输出

```
YES
NO
YES
YES```

# AI分析结果

### 题目内容
# 又一个俄罗斯方块问题

## 题目描述
你有一个数列 $\{a_n\}$，现在有两种操作：
1. 当数列 $\{a_n\}$ 的任意一项大于 $0$ 时，你可以选择**一些** $i(1\le i\le n)$，把每个 $a_i$ 加上 $2$。
2. 当数列 $\{a_n\}$ 的每一项都大于 $0$ 时，把这个数列的每一项都减去 $1$。

问你最后能不能把 $\{a\}$ 数组的元素全部变成 $0$。如果能，输出 `YES`，不然输出 `NO`。

## 说明/提示
$1\le t\le 100$，$1\le n\le 100$，$1\le a_i\le 100$。

## 样例 #1
### 输入
```
4
3
1 1 3
4
1 1 2 1
2
11 11
1
100
```
### 输出
```
YES
NO
YES
YES
```

### 算法分类
数学

### 综合分析与结论
所有题解都基于一个核心思路：由于每次操作1给元素加2，操作2同时减1，这两种操作都不会改变数列中元素之间奇偶性的差异，所以判断能否将数组元素全部变为0，只需判断所有元素的奇偶性是否相同。各题解在实现方式上略有不同，有的通过位运算判断奇偶性，有的通过取模判断，有的使用不同的数据读入方式等。

### 所选的题解
- **作者：Limit (5星)**
    - **关键亮点**：巧妙利用位运算维护所有元素的奇偶性信息，通过 `and` 和 `or` 运算快速判断所有元素是否奇偶性相同，代码简洁高效。
    - **重点代码**：
```cpp
void work()
{
    scanf("%d",&N);
    int and_=1,or_=0;
    int a;
    REP(i,1,N)
    {
        scanf("%d",&a);
        and_&=a&1;
        or_|=a&1;
    }
    if(and_||or_^1)
    {
        YES();
        return;
    }
    NO();
}
```
    - **核心思想**：通过 `and_` 记录所有元素二进制最后一位的与结果，`or_` 记录或结果，若 `and_` 为1（全是奇数）或者 `or_` 为0（全是偶数），则所有元素奇偶性相同。
- **作者：幻之陨梦 (4星)**
    - **关键亮点**：先介绍位运算知识，便于读者理解代码原理，通过将第一个数作为基准数，与后续每个数比较奇偶性，逻辑清晰。
    - **重点代码**：
```cpp
int main()
{
    T=read();
    while(T--)
    {
        f=1;
        n=read();
        x=read();
        for(int i=1;i<n;i++)
        {
            a=read();
            if((a&1)!=(x&1)) f=0;
        }
        puts(f?"YES":"NO");
    }
    return 0;
}
```
    - **核心思想**：利用位运算 `&` 获取每个数二进制最后一位，比较后续数与基准数二进制最后一位是否相同，判断整个数列奇偶性是否一致。
- **作者：C　C　A (4星)**
    - **关键亮点**：直接将所有数跟第一个数比较奇偶性，代码简洁明了，易于理解。
    - **重点代码**：
```cpp
int main(){
    scanf("%d", &T); while(T--){
        scanf("%d", &n);
        for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
        bool flag = true;
        for(int i = 2; i <= n; i++)
            if((a[i] & 1)!= (a[1] & 1)) flag = false;
        flag? puts("YES") : puts("NO");
    }
    return 0;
}
```
    - **核心思想**：以第一个数为基准，通过位运算 `&` 判断后续数与第一个数奇偶性是否相同，从而确定整个数列奇偶性是否相同。

### 最优关键思路或技巧
利用奇偶性不变这一特性简化问题，通过位运算或取模运算快速判断数列元素奇偶性是否一致。这种思维方式在处理一些涉及数字操作且操作不改变数字某些特性（如奇偶性）的问题时非常有效。

### 同类型题或类似算法套路拓展
此类题目通常涉及数字操作与性质判断，关键在于发现操作过程中数字不变的特性，如奇偶性、余数特性等，将复杂问题简化为对该特性的判断。

### 洛谷相似题目推荐
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过分析不同购买方案的性价比，利用贪心策略求解，涉及对数字运算及最优选择判断。
- [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)：根据给定条件对数据进行分析处理，判断是否满足特定要求，与本题判断数组能否达成特定状态类似。
- [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：通过对数字规律的分析，利用数学方法解决问题，与本题挖掘数字操作中的不变特性思路相似。 

---
处理用时：56.36秒
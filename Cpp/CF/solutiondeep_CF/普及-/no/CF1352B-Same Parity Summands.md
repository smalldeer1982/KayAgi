# 题目信息

# Same Parity Summands

## 题目描述

You are given two positive integers $ n $ ( $ 1 \le n \le       10^9 $ ) and $ k $ ( $ 1 \le k \le 100 $ ). Represent the number $ n $ as the sum of $ k $ positive integers of the same parity (have the same remainder when divided by $ 2 $ ).

In other words, find $ a_1, a_2, \ldots, a_k $ such that all $ a_i>0 $ , $ n = a_1 + a_2 + \ldots + a_k $ and either all $ a_i $ are even or all $ a_i $ are odd at the same time.

If such a representation does not exist, then report it.

## 样例 #1

### 输入

```
8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9```

### 输出

```
YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120```

# AI分析结果

### 题目内容
# 相同奇偶性的加数

## 题目描述
给定两个正整数 \(n\)（\(1 \leq n \leq 10^9\)）和 \(k\)（\(1 \leq k \leq 100\)）。将数字 \(n\) 表示为 \(k\) 个具有相同奇偶性（除以 \(2\) 时具有相同余数）的正整数之和。

换句话说，找到 \(a_1, a_2, \ldots, a_k\)，使得所有 \(a_i > 0\)，\(n = a_1 + a_2 + \ldots + a_k\)，并且所有 \(a_i\) 同时为偶数或同时为奇数。

如果不存在这样的表示，则报告。

## 样例 #1
### 输入
```
8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9
```
### 输出
```
YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120
```
### 算法分类
数学

### 题解综合分析与结论
这些题解的核心思路都是基于分类讨论来判断能否将 \(n\) 拆分成 \(k\) 个奇偶性相同的正整数。主要分为两种情况：拆分成 \(k\) 个奇数和拆分成 \(k\) 个偶数。判断时，通常先假设前 \(k - 1\) 个数为最小的奇数 \(1\) 或最小的偶数 \(2\)，再根据最后一个数的奇偶性以及其是否大于 \(0\) 来确定是否存在满足条件的拆分。各题解在细节处理和代码实现方式上略有不同，但本质思路一致。

### 所选的题解
#### 作者：ADay (5星)
- **关键亮点**：思路清晰，将情况分为可拆成 \(k\) 个奇数和可拆成 \(k\) 个偶数两种，分别给出拆分形式并通过位运算判断奇偶性，代码简洁明了。
- **重点代码核心思想**：先判断能否拆成 \(k\) 个奇数，若可以则输出 \(k - 1\) 个 \(1\) 和最后一个数 \(n - k + 1\)；再判断能否拆成 \(k\) 个偶数，若可以则输出 \(k - 1\) 个 \(2\) 和最后一个数 \(n - 2k + 2\)，若两种情况都不满足则输出 `NO`。
```cpp
if(((n-k+1)&1)&&n>=k)
{//Case1
    puts("YES");
    for(int i=1;i<k;i++)printf("1 ");
    printf("%d\n",n-k+1);
    continue;
}
if(((n-2*k+2)&1)||n<=2*k-2)
{
    puts("NO");
    continue;
}
puts("YES");
for(int i=1;i<k;i++)printf("2 ");
printf("%d\n",n-2*k+2);
```
#### 作者：chenyilai (4星)
- **关键亮点**：针对拆分成 \(k\) 个奇数和 \(k\) 个偶数两种选择，分别明确列出两个条件，代码对应条件书写，逻辑清晰。
- **重点代码核心思想**：先判断拆分成 \(k\) 个奇数的条件是否满足，满足则输出 \(k - 1\) 个 \(1\) 和最后一个数 \(n - (k - 1)\)；再判断拆分成 \(k\) 个偶数的条件是否满足，满足则输出 \(k - 1\) 个 \(2\) 和最后一个数 \(n - 2(k - 1)\)，若都不满足则无输出。
```cpp
if (n>=k&&(n-(k-1))%2==1){
    printf("YES\n");
    for (int i=0;i<k-1;i++) printf("1 ");
    printf("%lld\n",n-(k-1));
}
if (n>=k*2&&(n-2*(k-1))%2==0){
    printf("YES\n");
    for (int i=0;i<k-1;i++) printf("2 ");
    printf("%lld\n",n-2*(k-1));
}
```
#### 作者：小恐 (4星)
- **关键亮点**：按 \(n\) 与 \(k\) 的奇偶性进行全面分类讨论，每种情况分析清晰，代码实现与分类对应。
- **重点代码核心思想**：根据 \(n\) 和 \(k\) 的不同奇偶组合判断是否有解，有解时根据情况输出 \(k - 1\) 个 \(1\) 加最后一个数或者 \(k - 1\) 个 \(2\) 加最后一个数。
```cpp
if(n%2==1&&k%2==0)
{
    puts("NO");
    continue;
}
if(n%2==1&&n<k)
{
    puts("NO");
    continue;
}
if(n%2==0&&k%2==0&&n<k)
{
    puts("NO");
    continue;
}
if(n%2==0&&k%2==1&&n<k*2)
{
    puts("NO");
    continue;
}
puts("YES");
if(n%2==0&&k%2==1)
{
    for(int i=1;i<k;++i)
        printf("2 ");
    printf("%d\n",n-2*(k-1));
}
else
{
    for(int i=1;i<k;++i)
        printf("1 ");
    printf("%d\n",n-(k-1));
}
```
### 最优关键思路或技巧
- **分类讨论**：全面且有条理地对 \(n\) 和 \(k\) 的奇偶性组合进行分类，清晰判断每种情况下是否存在满足条件的拆分方式。
- **固定前 \(k - 1\) 个数**：通过假设前 \(k - 1\) 个数为最小的奇数 \(1\) 或偶数 \(2\)，简化判断最后一个数是否符合要求的过程。
- **位运算**：如使用 `&1` 判断奇偶性，提高代码效率。

### 拓展思路
此类题目属于数论中的构造类型题目，常见的拓展方向有改变数字的限制条件，比如改变 \(n\) 和 \(k\) 的取值范围，或者要求拆分出的数满足其他条件（如为质数等）；也可以拓展到多个数的不同余数组合问题。类似算法套路通常是先根据题目条件确定可能的分类情况，再通过假设部分数值来构造满足要求的解。

### 洛谷相似题目推荐
- [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)：考察对数字进行分解的能力，与本题对数字进行拆分有相似之处。
- [P2602 数字计数](https://www.luogu.com.cn/problem/P2602)：需要通过数学方法统计数字在一定范围内的出现次数，和本题一样需要对不同情况进行分析。
- [P1403 [AHOI2005]约数研究](https://www.luogu.com.cn/problem/P1403)：通过数学规律来解决关于约数个数统计的问题，锻炼数学分析能力，与本题思路类似。 

---
处理用时：61.92秒
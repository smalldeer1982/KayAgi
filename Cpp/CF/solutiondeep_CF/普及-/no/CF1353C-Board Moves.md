# 题目信息

# Board Moves

## 题目描述

有一个$n×n$的棋盘（$n$为奇数），一开始每个格子中都含有一个数。现在你可以进行以下操作：

一步操作指选定任意格中的恰好一个数，并将其移动到周围的八个格子中之一。也就是说，如果原来格子的坐标是$(i,j)$，那么你可以将这个数移到$(i+1,j)$$(i-1,j)$$(i+1,j+1)$$(i,j+1)$$(i-1,j+1)$$(i+1,j-1)$$(i,j-1)$$(i-1,j-1)$这八个格子中。

当然，你不能把棋子移到棋盘外。允许在一次操作后一个格子里存在多个数。

你的任务是找出操作的最小次数，使得所有的数都在一个方格内。也就是说在$(n^2-1)$个格子内都没有数，而在$1$个格子内有所有的数。

## 样例 #1

### 输入

```
3
1
5
499993```

### 输出

```
0
40
41664916690999888```

# AI分析结果

### 题目内容
# 棋盘移动

## 题目描述
有一个$n×n$的棋盘（$n$为奇数），一开始每个格子中都含有一个数。现在你可以进行以下操作：
一步操作指选定任意格中的恰好一个数，并将其移动到周围的八个格子中之一。也就是说，如果原来格子的坐标是$(i,j)$，那么你可以将这个数移到$(i + 1,j)$、$(i - 1,j)$、$(i + 1,j + 1)$、$(i,j + 1)$、$(i - 1,j + 1)$、$(i + 1,j - 1)$、$(i,j - 1)$、$(i - 1,j - 1)$这八个格子中。
当然，你不能把棋子移到棋盘外。允许在一次操作后一个格子里存在多个数。
你的任务是找出操作的最小次数，使得所有的数都在一个方格内。也就是说在$(n^2 - 1)$个格子内都没有数，而在$1$个格子内有所有的数。

## 样例 #1
### 输入
```
3
1
5
499993
```
### 输出
```
0
40
41664916690999888
```

### 算法分类
数学

### 综合分析与结论
所有题解都基于将所有数移动到棋盘中心是最优策略这一结论展开。不同题解在推导操作次数的具体表达式时采用了不同方法，有的通过递推关系，有的利用数学公式计算，还有的借助动态规划思想。部分题解代码实现简洁高效，有的则相对复杂或存在可优化空间。

### 所选的题解
- **作者：do_while_true (赞：3)  星级：4星**
    - **关键亮点**：通过观察发现紧邻中心点的点到中心点的距离规律，进而得出递推式$f_i = f_{i - 2}+4*(i - 1)*(\lfloor\frac{i}{2}\rfloor)$，其中$f_1 = 0$，思路清晰简洁。
    - **重点代码**：核心实现为递推式计算，以下是关键代码片段：
```cpp
// 假设已定义数组f存储结果
// 假设n为棋盘边长
f[1] = 0;
for (int i = 3; i <= n; i += 2) {
    f[i] = f[i - 2]+4*(i - 1)*(i / 2);
}
// 最终答案为f[n]
```
- **作者：20111019Yu (赞：2)  星级：4星**
    - **关键亮点**：通过数学论证得出最终点在矩阵中心时总步数最少，且利用“踢三角”方法优化计算最终答案，将答案写成算式$8\cdot \left[(1+n/2\cdot2)\cdot(n/2 + 1)\cdot(n/2)\right]\div6$，直接得出结果，复杂度为$\mathcal{O}(t)$。
    - **重点代码**：核心代码直接根据公式计算并输出结果，简洁高效。
```cpp
#include <bits/stdc++.h>
#define int unsigned long long int
using namespace std;
int t, n;
signed main() {
    cin >> t;
    while (t--) {
        cin >> n;
        cout << 8 * (1 + 2 * (n / 2)) * (n / 2 + 1) * (n / 2) / 6 << endl;
    }
    return 0;
}
```
- **作者：皎月半洒花 (赞：1)  星级：4星**
    - **关键亮点**：从数轴上点到中位数距离最小类比到棋盘问题，得出应向棋盘中央移动。通过DP思想设$f_i$表示走$\leqslant i$步就能到中心点的点数，得出递推式$f_i = f_{i - 1}+((2\times i + 1)\times 4 - 4)\times i$，并发现答案是自然数平方和的8倍，进一步优化计算。
    - **重点代码**：核心代码先根据递推式计算，后优化为直接利用自然数平方和公式计算。
```cpp
// 假设m为n/2
// 优化前
f[0] = 0;
for (int i = 1; i <= m; i++) {
    f[i] = f[i - 1]+((2 * i + 1) * 4 - 4) * i;
}
// 最终答案为f[m]

// 优化后
ans = 1ll * (m + 1) * m / 2ll * (2ll * m + 1) / 3;
```

### 最优关键思路或技巧
- **数学推导与优化**：通过数学论证确定最优位置为棋盘中心，然后利用数学知识如递推关系、自然数平方和公式等优化计算操作次数，避免了暴力枚举，大幅降低时间复杂度。
- **类比思维**：将数轴上点到中位数距离最小的结论类比到棋盘问题，帮助快速确定解题方向。

### 同类型题或类似算法套路拓展
此类题目通常是给定某种操作规则，求达到特定状态的最优操作次数。解题关键在于通过数学分析或规律总结，找到操作次数与问题规模（如本题棋盘边长）之间的关系。类似算法套路包括寻找图形的对称性、利用数学公式简化计算、通过递推或DP思想建立状态转移方程等。

### 洛谷相似题目推荐
- [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)：通过递推关系求解斐波那契数列，与本题通过递推计算操作次数类似。
- [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)：利用数学知识扩展欧几里得算法求解同余方程，锻炼数学解题思维。
- [P2669 金币](https://www.luogu.com.cn/problem/P2669)：通过找规律确定计算金币数量的方法，与本题找操作次数规律类似。 

---
处理用时：52.60秒
# 题目信息

# Matrix Game

## 题目描述

一个 $n$ 行 $m$ 列的网格图，有些格子上已经有 $1$，`Ashish` 和 `Vivek` 在这张网格图上做游戏，`Ashish` 先手。  

对于当前玩家，他需要在网格图上找一个位置设置为 $1$，条件是这一个位置所在的行以及列上都没有其他的 $1$，如果他不能操作了，那么他就输了。

求对于输入的网格图，谁能获胜。

## 样例 #1

### 输入

```
4
2 2
0 0
0 0
2 2
0 0
0 1
2 3
1 0 1
1 1 0
3 3
1 0 0
0 0 0
1 0 0```

### 输出

```
Vivek
Ashish
Vivek
Ashish```

# AI分析结果

### 题目内容
# Matrix Game

## 题目描述
一个 $n$ 行 $m$ 列的网格图，有些格子上已经有 $1$，`Ashish` 和 `Vivek` 在这张网格图上做游戏，`Ashish` 先手。  

对于当前玩家，他需要在网格图上找一个位置设置为 $1$，条件是这一个位置所在的行以及列上都没有其他的 $1$，如果他不能操作了，那么他就输了。

求对于输入的网格图，谁能获胜。

## 样例 #1
### 输入
```
4
2 2
0 0
0 0
2 2
0 0
0 1
2 3
1 0 1
1 1 0
3 3
1 0 0
0 0 0
1 0 0
```
### 输出
```
Vivek
Ashish
Vivek
Ashish
```

### 算法分类
数学

### 综合分析与结论
这些题解主要分为两种思路。一种是直接暴力模拟游戏过程，遍历网格寻找可放置1的位置，记录当前玩家，直到无法放置判断获胜者。另一种思路是通过统计最初未使用任何单元格的行数和列数，取两者最小值的奇偶性来判断获胜者，因为每次放置1会同时减少一行一列的可用位置。后一种思路更为简洁高效，时间复杂度为 \(O(n \cdot m)\)，而暴力模拟的时间复杂度相对较高。

### 所选的题解
- **作者：liuyongle (5星)**
    - **关键亮点**：思路清晰简洁，直接抓住问题本质，通过分析空行和空列数量的奇偶性判断胜负，代码实现简洁明了。
    - **重点代码核心思想**：使用集合记录已被占用的行和列，通过集合大小得出未被占用的行和列数量，进而判断最小值的奇偶性。
    ```cpp
    set< int > r, c;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            cin >> a[i][j];
            if(a[i][j] == 1)
                r.insert(i), c.insert(j);
        }
    }
    int mn = min(n - r.size(), m - c.size());
    if(mn % 2)
        cout << "Ashish" << endl;
    else
        cout << "Vivek" << endl;
    ```
- **作者：AzureMist (4星)**
    - **关键亮点**：在理解通过空行空列数量奇偶性判断结果的基础上，不用STL容器，直接用数组记录每行每列状态，节省空间。
    - **重点代码核心思想**：用两个数组记录每行每列1的数量，遍历数组统计空行空列数量，进而判断奇偶性。
    ```cpp
    int acnt[55],bcnt[55];
    for(int j=1;j<=n;j++)
    {
        for(int k=1;k<=m;k++)
        {
            char c;
            cin>>c;
            if(c=='1')
            {
                acnt[j]++;
                bcnt[k]++;
            }
        }
    }
    int r=0,c=0;
    for(int j=1;j<=n;j++)
        if(acnt[j]==0)
            r++;
    for(int j=1;j<=m;j++)
        if(bcnt[j]==0)
            c++;
    if(min(r,c)%2==0) cout<<"Vivek"<<endl;
    else cout<<"Ashish"<<endl;
    ```
- **作者：Liu_Tianze (4星)**
    - **关键亮点**：同样利用空行空列数量的奇偶性判断胜负，代码结构清晰，变量命名规范，注释详细。
    - **重点代码核心思想**：用两个数组记录每行每列1的数量，遍历数组统计空行空列数量，取最小值判断奇偶性。
    ```cpp
    int x[maxn],y[maxn];
    while(T--){
        memset(x,0,sizeof(x));
        memset(y,0,sizeof(y));
        int n,m;
        cin>>n>>m;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                int c;
                cin>>c;
                if(c==1) x[i]++,y[j]++;
            }
        }
        int cnt1=0,cnt2=0;
        for(int i=1;i<=n;i++){
            if(x[i]==0) cnt1++;
        }
        for(int i=1;i<=m;i++){
            if(y[i]==0) cnt2++;
        }
        int move=min(cnt1,cnt2);
        if(move%2==0) cout<<"Vivek"<<endl;
        else cout<<"Ashish"<<endl;    
    }
    ```

### 最优关键思路或技巧
通过分析游戏规则，发现每次放置1会同时占用一行一列，从而想到统计最初未被占用的行和列的数量，利用其最小值的奇偶性判断胜负，避免了复杂的模拟过程，优化了算法。

### 同类型题或类似算法套路拓展
此类题目通常是博弈类型的数学问题，关键在于通过分析游戏规则，找到影响游戏结果的关键因素（如本题的空行空列数量），并利用数学性质（如奇偶性）来简化判断过程。

### 推荐洛谷题目
- [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：涉及到对矩阵的遍历以及利用连通性等数学性质求解。
- [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：通过分析点与点之间的关系，利用数学方法优化搜索路径。
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)：需要通过分析题目条件，利用数学性质找到合适的二分答案的判断条件。 

---
处理用时：51.52秒
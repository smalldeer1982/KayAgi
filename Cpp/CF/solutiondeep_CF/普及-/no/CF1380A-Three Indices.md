# 题目信息

# Three Indices

## 题目描述

You are given a permutation $ p_1, p_2, \dots, p_n $ . Recall that sequence of $ n $ integers is called a permutation if it contains all integers from $ 1 $ to $ n $ exactly once.

Find three indices $ i $ , $ j $ and $ k $ such that:

- $ 1 \le i < j < k \le n $ ;
- $ p_i < p_j $ and $ p_j > p_k $ .

 Or say that there are no such indices.

## 样例 #1

### 输入

```
3
4
2 1 4 3
6
4 6 1 2 5 3
5
5 3 1 2 4```

### 输出

```
YES
2 3 4
YES
3 5 6
NO```

# AI分析结果

### 题目内容
# 三个索引

## 题目描述
给定一个排列 $p_1, p_2, \dots, p_n$ 。回想一下，由 $n$ 个整数组成的序列如果恰好包含从 $1$ 到 $n$ 的所有整数各一次，则称其为一个排列。

找到三个索引 $i$、$j$ 和 $k$ ，使得：
- $1 \le i < j < k \le n$ ；
- $p_i < p_j$ 且 $p_j > p_k$ 。
否则说明不存在这样的索引。

## 样例 #1
### 输入
```
3
4
2 1 4 3
6
4 6 1 2 5 3
5
5 3 1 2 4
```
### 输出
```
YES
2 3 4
YES
3 5 6
NO
```

### 算法分类
枚举

### 综合分析与结论
这些题解的核心都是围绕如何高效地找到满足条件的三个索引展开。难点在于如何在给定的数据范围下，优化查找过程，避免过高的时间复杂度。
 - **linyihdfj的题解**：通过预处理出每个位置左边和右边的最小值及其索引，然后枚举中间位置，判断是否满足条件。这种方法思路清晰，时间复杂度为 $O(n)$ ，代码实现较为简洁。
 - **dead_X的题解**：利用贪心策略，在遍历数组时动态维护 $x$、$y$、$z$ 三个数，根据当前数与已确定数的大小关系进行更新，一旦找到满足条件的 $z$ 就输出结果，时间复杂度也是 $O(n)$ ，代码逻辑紧凑。
 - **wssdl的题解**：采用枚举中间点的方式，再分别从中间点的左右两侧寻找满足大小关系的点，时间复杂度为 $O(n^2)$ ，相比前两种方法效率较低。
 - **XCH_0803的题解**：使用树状数组来统计每个位置前后比它小的数的情况，虽然能解决问题，但代码相对复杂，理解和实现难度较大。
 - **Fan_Tuan的题解**：通过枚举每个起始点，寻找大于该点值且下标更大的点，再从这个点之后寻找小于该点值的点，时间复杂度为 $O(n^2)$ 。
 - **45dino的题解**：枚举每个位置，递推计算其后的最大值，判断是否满足条件，时间复杂度为 $O(n^2)$ 。

综合来看，linyihdfj和dead_X的题解在思路清晰度、代码可读性和优化程度上表现较好，均达到4星及以上。

### 所选的题解
 - **作者：linyihdfj (4星)**
   - **关键亮点**：通过预处理左右最小值的方式，将问题转化为简单的枚举判断，思路清晰，时间复杂度低。
   - **重点代码**：
```cpp
// 预处理左边最小值的索引
int now = INF;
pre[0] = 1;
for(int i=1; i<=n; i++){
    pre[i] = pre[i-1];
    if(a[i] < now){
        now = a[i];
        pre[i] = i;
    }
}
// 预处理右边最小值的索引
suf[n+1] = n;
now = INF; 
for(int i=n; i>=1; i--){
    suf[i] = suf[i+1];
    if(a[i] < now){
        now = a[i];
        suf[i] = i;
    }
}
// 枚举中间点判断是否满足条件
for(int i=1; i<=n; i++){
    if(a[pre[i]] < a[i] && a[suf[i]] < a[i]){
        printf("YES\n");
        printf("%d %d %d\n",pre[i],i,suf[i]);
        flag = true;
        break;
    }
}
```
 - **作者：dead_X (4星)**
   - **关键亮点**：利用贪心思想，在一次遍历中动态维护所需的三个数，代码简洁高效。
   - **重点代码**：
```cpp
for(int i=1; i<=n; i++){
    if(f) if(a[i]>a[x]) y=i,f=0; else x=i;
    else if(a[i]<a[y]) {
        z=i;
        break;
    } else y=i;
}
if(z==-1) puts("NO");
else {
    puts("YES");
    printf("%d %d %d\n",x,y,z);
}
```

### 最优关键思路或技巧
linyihdfj的预处理左右最值索引和dead_X的贪心策略动态维护三个数，都能有效降低时间复杂度，提高算法效率。这两种方法的核心在于巧妙地利用数据的前后关系，避免了不必要的重复计算。

### 可拓展之处
此类题目属于序列中寻找特定子序列关系的问题，类似套路可应用于寻找其他特定大小关系的子序列问题，比如寻找递增或递减的子序列等。

### 洛谷相似题目推荐
 - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：涉及在序列中寻找满足特定条件（和最大）的子序列，可类比寻找特定大小关系子序列的思路。
 - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：通过统计逆序对数量，考察对序列中元素位置和大小关系的处理，与本题有相似之处。
 - [P2671 求和](https://www.luogu.com.cn/problem/P2671)：在序列中根据特定规则求和，需要对序列元素关系进行分析和处理，与本题思路有相通点。 

---
处理用时：45.19秒
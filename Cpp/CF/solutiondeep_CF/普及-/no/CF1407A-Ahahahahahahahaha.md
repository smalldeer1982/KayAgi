# 题目信息

# Ahahahahahahahaha

## 题目描述

Alexandra 有一个由若干$0$和$1$组成的数组$a$，且数组$a$的长度$n$为偶数，数列中所有元素的编号依次为$1$ ~ $n$。她希望在数组中删除一些元素，来使得奇数编号位置上的数字之和等于偶数编号位置上的数字之和（$a_1 - a_2 + a_3 - a_4 + ... = 0$），最多删除$\frac{n}{2}$个元素且删除的元素不必是连续的



例如，如果原数组$a$ =  $\left[1,0,1,0,0,0\right]$,且她删除了原数列中的第$2$个和第$4$个元素，那么数组$a$将变成$\left[1,1,0,0\right]$，并且奇数编号位置上的数字之和等于偶数编号位置上的数字之和。



帮帮她解决这个问题吧！

## 样例 #1

### 输入

```
4
2
1 0
2
0 0
4
0 1 1 1
4
1 1 0 0```

### 输出

```
1
0
1
0
2
1 1
4
1 1 0 0```

# AI分析结果

### 题目内容
# Ahahahahahahahaha

## 题目描述
Alexandra 有一个由若干0和1组成的数组a，且数组a的长度n为偶数，数列中所有元素的编号依次为1 ~ n。她希望在数组中删除一些元素，来使得奇数编号位置上的数字之和等于偶数编号位置上的数字之和（$a_1 - a_2 + a_3 - a_4 +... = 0$），最多删除$\frac{n}{2}$个元素且删除的元素不必是连续的。

例如，如果原数组a =  $\left[1,0,1,0,0,0\right]$,且她删除了原数列中的第2个和第4个元素，那么数组a将变成$\left[1,1,0,0\right]$，并且奇数编号位置上的数字之和等于偶数编号位置上的数字之和。

帮帮她解决这个问题吧！

## 样例 #1
### 输入
```
4
2
1 0
2
0 0
4
0 1 1 1
4
1 1 0 0
```
### 输出
```
1
0
1
0
2
1 1
4
1 1 0 0
```
### 算法分类
构造
### 综合分析与结论
这些题解主要围绕如何通过删除元素构造出满足奇数编号位置数字之和等于偶数编号位置数字之和的子序列。多数题解利用数组仅由0和1组成，且删除元素数量限制为$\frac{n}{2}$的条件，通过分类讨论来解决问题。

1. **思路**：大部分题解考虑了0和1数量的比较，若0的数量多则删除所有1，若1的数量多则删除所有0，且当1的数量为奇数时再删去一个1 。部分题解还涉及更复杂的分组判断，如四个一组或两个一组判断和的情况来构造子序列，还有使用动态规划的方法，但复杂度较高。
2. **算法要点**：统计0和1的数量，根据数量关系进行分类构造。
3. **解决难点**：难点在于如何利用给定的删除元素限制条件，构造出满足等式的子序列。不同题解通过不同方式巧妙地解决，如利用全0或全1子序列的特性，或对剩余元素奇偶性进行调整。

### 所选的题解
 - **作者：wsyhb (6赞，5星)**
    - **关键亮点**：思路清晰，简洁明了地指出全0序列和偶数长度的全1序列一定满足题意，通过统计0和1的个数进行简单的分类讨论，代码实现简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int n;
        scanf("%d",&n);
        int cnt0=0,cnt1=0;
        for(int i=1;i<=n;++i)
        {
            int x;
            scanf("%d",&x);
            if(x==0) ++cnt0;
            else ++cnt1;
        }
        if(cnt0>=n/2)
        {
            printf("%d\n",n/2);
            for(int i=1;i<=n/2;++i)
                printf("%d%c",0,i<n/2?' ':'\n');
        }
        else
        {
            int ans;
            if(n/2%2==1) ans=n/2+1;
            else ans=n/2;
            printf("%d\n",ans);
            for(int i=1;i<=ans;++i)
                printf("%d%c",1,i<ans?' ':'\n');
        }
    }
    return 0;
}
```
核心实现思想：先统计0和1的个数，若0的个数大于等于$\frac{n}{2}$，则输出$\frac{n}{2}$个0；否则判断$\frac{n}{2}$和$\frac{n}{2}+1$哪一个为偶数，输出对应个数的1。
 - **作者：onglu (3赞，4星)**
    - **关键亮点**：同样基于0和1数量比较进行分类讨论，考虑到0和1数量相等时删除1优先的情况，避免出现剩余奇数个1的情况，逻辑较为严谨。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>

using namespace std;

int read(){
    char c; int num, f = 1;
    while(c = getchar(),!isdigit(c)) if(c == '-')f = -1; num = c - '0';
    while(c = getchar(), isdigit(c)) num = num * 10 + c - '0';
    return num * f;
}
int n, cnt[2];
void work(){
    n = read(); cnt[0] = 0; cnt[1] = 0;
    for(int i = 1; i <= n; i++){
        cnt[read()]++;
    }
    if(cnt[0] >= cnt[1]){
        printf("%d\n", cnt[0]);
        for(int i = 1; i <= cnt[0]; i++)
            printf("0 ");
        printf("\n");
    }else {
        if(cnt[1] & 1)cnt[1]--;
        printf("%d\n", cnt[1]);
        for(int i = 1;i <= cnt[1]; i++)
            printf("1 ");
        printf("\n");
    }
}
int main()
{
    int Case = read();
    while(Case--)work();
    return 0;
}
```
核心实现思想：先读入数据并统计0和1的个数，若0的个数大于等于1的个数，则输出所有0；否则若1的个数为奇数则减1，然后输出剩余的1。
 - **作者：过往梦魇之殇 (2赞，4星)**
    - **关键亮点**：思路直接，清晰地分两种情况讨论0和1出现次数的大小关系，对于1出现次数多的情况，考虑到1的个数奇偶性并做相应处理，逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
int T,k,cnt[2];
int main(){
    scanf("%d",&T);
    while(T--){
        cnt[0]=cnt[1]=0;
        scanf("%d",&k);
        for(re int i=1;i<=k;++i){
            int a;
            scanf("%d",&a);
            ++cnt[a];
        }
        if(cnt[0]>=cnt[1]){
            printf("%d\n",cnt[0]);
            for(re int i=1;i<=cnt[0];++i){
                printf("0 ");
            }
            puts("");
        }
        else{
            if(cnt[1]%2){
                --cnt[1];
            }
            printf("%d\n",cnt[1]);
            for(re int i=1;i<=cnt[1];++i){
                printf("1 ");
            }
            puts("");
        }
    }
    return 0;
}
```
核心实现思想：统计每组数据中0和1的个数，若0的个数大于等于1的个数，输出所有0；若1的个数多且为奇数则减1，然后输出剩余的1。

### 最优关键思路或技巧
利用数组仅由0和1组成这一特性，通过统计0和1的数量进行分类讨论，构造出满足条件的子序列。当某一种数的数量较多时，删除另一种数，并对剩余数的奇偶性进行适当处理，确保满足奇数编号位置数字之和等于偶数编号位置数字之和的条件。

### 可拓展之处
同类型题通常围绕特定条件下的序列构造，类似算法套路为根据题目给定的限制条件，对序列元素进行分类讨论，利用元素的特性（如本题0和1的特性）来构造满足要求的子序列。

### 洛谷相似题目推荐
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：通过删除数字构造满足条件的新数，考察贪心构造思想。
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：在一定规则下构造路径，与本题构造满足条件序列类似，可锻炼构造思维。
3. [P2672 推销员](https://www.luogu.com.cn/problem/P2672)：通过选择元素构造最优方案，同样是构造类型题目，能加深对构造算法的理解。 

---
处理用时：68.36秒
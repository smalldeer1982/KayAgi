# 题目信息

# Minimal Cost

## 题目描述

给你一个 $n$ 行 $10^6+2$ 列的图，行从 $1$ 到 $n$ 标号，列从 $0$ 到 $10^6+1$ 标号。

为简便，下面用 $(i,j)$ 表示第 $i$ 行第 $j$ 列的节点。

一开始每一行 $i$ 都恰好有一个障碍物 $(i,a_i)$。你可以将障碍物移动到四周空的节点（不能移出图的范围），上下移动一个单位花费 $u$，左右移动一个单位花费 $v$。（可参照上图）

你需要使得 $(1,0)$ 到 $(n,10^6+1)$ 之间有一条路径（只能上下左右移动，不能越过障碍物），求移动障碍物的最小花费。

## 样例 #1

### 输入

```
3
2 3 4
2 2
2 3 4
3 2
2 4 3
3 2```

### 输出

```
7
3
3```

# AI分析结果

### 题目内容
# 最小花费

## 题目描述
给你一个 $n$ 行 $10^6+2$ 列的图，行从 $1$ 到 $n$ 标号，列从 $0$ 到 $10^6+1$ 标号。
为简便，下面用 $(i,j)$ 表示第 $i$ 行第 $j$ 列的节点。
一开始每一行 $i$ 都恰好有一个障碍物 $(i,a_i)$ 。你可以将障碍物移动到四周空的节点（不能移出图的范围），上下移动一个单位花费 $u$ ，左右移动一个单位花费 $v$ 。（可参照上图）
你需要使得 $(1,0)$ 到 $(n,10^6+1)$ 之间有一条路径（只能上下左右移动，不能越过障碍物），求移动障碍物的最小花费。

## 样例 #1
### 输入
```
3
2 3 4
2 2
2 3 4
3 2
2 4 3
3 2
```
### 输出
```
7
3
3
```

### 算法分类
数学

### 题解综合分析与结论
所有题解思路基本一致，均通过分类讨论解决问题。核心在于根据障碍物的分布情况，即相邻障碍物列坐标差值，来确定最小花费。主要分为三种情况：
1. 当存在相邻障碍物列坐标差值大于1时，无需移动障碍物，花费为0。
2. 当所有相邻障碍物列坐标差值都等于1时，只需横向或纵向移动一个障碍物一次，花费为 $\min(u, v)$。
3. 当所有障碍物列坐标都相同时，需先横向移动一个障碍物，再横向或纵向移动一次，花费为 $v + \min(u, v)$。

各题解在代码实现上略有差异，如读入方式、判断函数的使用等，但整体思路相同。

### 所选的题解
- **作者：Priori_Incantatem (5星)**
    - **关键亮点**：思路清晰，代码结构完整，通过定义 `check1` 和 `check2` 函数分别判断两种情况，使主函数逻辑简洁明了。
    - **重点代码**：
```cpp
bool check1()
{
    for(int i=2;i<=n;++i)
    if(abs(a[i]-a[i-1])>1)return 1;
    return 0;
}
bool check2()
{
    for(int i=2;i<=n;++i)
    if(a[i]!=a[i-1])return 1;
    return 0;
}
int main()
{
    int T=read();
    while(T--)
    {
        n=read(),u=read(),v=read();
        for(int i=1;i<=n;++i)
        a[i]=read();
        if(check1())puts("0");
        else if(check2())printf("%d\n",min(u,v));
        else printf("%d\n",v+min(u,v));
    }
    return 0;
}
```
    - **核心实现思想**：`check1` 函数检查是否存在相邻障碍物列坐标差值大于1的情况，`check2` 函数检查是否所有障碍物列坐标不完全相同。主函数根据这两个函数的返回值进行分类讨论并输出结果。

- **作者：serverkiller (4星)**
    - **关键亮点**：作为官方题解，表述简洁，直接给出三种分类情况的结论。
    - **重点代码**：无（未给出具体代码）
    - **核心实现思想**：直接阐述三种分类情况对应的答案，即所有 $a_i$ 均相同时答案为 $v+\min(u,v)$ ；存在 $|a_i - a_{i + 1}| > 1$ 时答案为0；否则答案为 $\min(u,v)$。

- **作者：_Michael0727_ (4星)**
    - **关键亮点**：思路阐述详细，代码简洁易懂，通过一次遍历记录相邻障碍物列坐标差值的最大值，根据该值进行分类讨论。
    - **重点代码**：
```cpp
int main ( )
{
    long long q ;
    cin >> q ;
    while ( q -- )
    {
        long long n, u, v, dis ;
        cin >> n >> u >> v ;
        for ( long long i = 1 ; i <= n ; i ++ )
        {
            cin >> a [i] ;
            dis = ( i - 1? max ( dis, abs ( a [i] - a [i - 1] ) ) : 0 ) ;
        }
        if ( dis == 0 )
        {
            cout << v + min ( u, v ) << endl ;
        }
        else if ( dis == 1 )
        {
            cout << min ( u, v ) << endl ;
        }
        else
        {
            cout << 0 << endl ;
        }
    }
    return 0 ;
}
```
    - **核心实现思想**：在输入障碍物列坐标时，同步计算并更新相邻障碍物列坐标差值的最大值 `dis`，最后根据 `dis` 的值判断属于哪种情况并输出相应结果。

### 最优关键思路或技巧
通过分析障碍物的分布规律，将问题简化为三种易于处理的分类情况，避免了复杂的路径搜索等操作，极大地降低了问题的复杂度。这种基于对问题本质深入理解的分类讨论思想是解决本题的关键。

### 同类型题或类似算法套路拓展
此类题目通常可以通过仔细分析问题条件，挖掘其中隐藏的规律，将复杂问题简化为几种可直接求解的简单情况。在遇到类似需要寻找路径且存在障碍物可移动的问题时，可尝试从障碍物的分布特征入手进行分类讨论。

### 洛谷相似题目推荐
- [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116)：通过分析车厢编号顺序，利用冒泡排序思想解决问题，考察对规律的挖掘和简单算法应用。
- [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)：根据给定条件进行分类讨论，判断不同情况下的结果，与本题分类讨论思路相似。
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：根据不同包装铅笔的价格和数量，通过分类计算找出最省钱的购买方案，同样运用分类讨论思想。 

---
处理用时：53.51秒
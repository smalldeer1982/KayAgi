# 题目信息

# Same Differences

## 题目描述

You are given an array $ a $ of $ n $ integers. Count the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_j - a_i = j - i $ .

## 样例 #1

### 输入

```
4
6
3 5 1 4 6 6
3
1 2 3
4
1 3 3 4
6
1 6 3 4 5 6```

### 输出

```
1
3
3
10```

# AI分析结果

### 题目内容
# 相同的差值

## 题目描述
给定一个包含 $n$ 个整数的数组 $a$ 。统计满足 $i < j$ 且 $a_j - a_i = j - i$ 的索引对 $(i, j)$ 的数量。

## 样例 #1
### 输入
```
4
6
3 5 1 4 6 6
3
1 2 3
4
1 3 3 4
6
1 6 3 4 5 6
```
### 输出
```
1
3
3
10
```

### 算法分类
数学

### 综合分析与结论
所有题解的核心思路都是对等式 $a_j - a_i = j - i$ 进行移项，得到 $a_j - j = a_i - i$ ，然后通过统计 $a_k - k$ 相同值的数量来计算满足条件的索引对数量。主要区别在于处理 $a_i - i$ 可能为负数的情况以及具体的统计实现方式。部分题解使用 `map` 来处理负数情况，时间复杂度为 $O(n\log n)$ ；部分题解通过给差值加上偏移量 $n$ ，使用数组统计，时间复杂度优化到了 $O(n)$ 。还有部分题解通过排序后统计连续相同值的方式来计数。

### 所选的题解
 - **oimaster的题解**：
   - **星级**：5星
   - **关键亮点**：清晰地阐述了从等式变形到使用 `map` 统计的思路，同时提出了使用数组时处理负数下标的问题，并给出了两种解决方法（`map` 和数组加偏移量），代码简洁明了。
   - **重点代码核心实现思想**：先对输入数组每个元素减去其下标，然后用 `map` 统计每个差值出现的次数，每次遇到一个差值，将其在 `map` 中对应的值加到答案中，并更新 `map` 。
   - **核心代码片段**：
```cpp
#include<iostream>
#include<map>
#define int long long
using namespace std;
signed main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int a[n+1];
        for(int i=1;i<=n;++i){
            cin>>a[i];
            a[i]-=i;
        }
        int ans=0;
        map<int,int>m;
        for(int i=1;i<=n;++i){
            if(m.count(a[i]))
                ans+=m[a[i]];
            ++m[a[i]];
        }
        cout<<ans<<endl;
    }
}
```
 - **Eason_AC的题解**：
   - **星级**：4星
   - **关键亮点**：简洁地阐述了等式变形后的解题思路，直接使用 `map` 实现统计，代码简洁高效。
   - **重点代码核心实现思想**：输入时对每个元素减去其下标，同时用 `map` 统计差值出现次数，每次输入新元素时，将该元素差值在 `map` 中的值加到答案中，并更新 `map` 。
   - **核心代码片段**：
```cpp
int a[200007];

int main() {
    MT {
        map<int, int> vis;
        int n = Rint; ll ans = 0;
        F(int, i, 1, n) a[i] = Rint, ans += vis[a[i] - i], vis[a[i] - i]++;
        println(ans);
    }
    return 0;
}
```
 - **wheneveright的题解**：
   - **星级**：4星
   - **关键亮点**：详细分析了等式变形过程，通过排序使相同差值的元素相邻，再统计相邻相同元素的对数来计算答案。
   - **重点代码核心实现思想**：先对输入数组每个元素减去其下标，排序后，通过双指针法统计连续相同差值的元素个数，根据组合数公式计算这些元素能组成的对数并累加到答案中。
   - **核心代码片段**：
```cpp
# include <bits/stdc++.h>
using namespace std;

int T, N, A[200005];
long long ans;

int main () {
    scanf ("%d", &T);
    while (T--) {
        scanf ("%d", &N); ans = 0;
        for (int i = 1; i <= N; i++) {
            scanf ("%d", &A[i]);
            A[i] -= i; // 预处理
        }
        sort (A + 1, A + 1 + N); A[N + 1] = 2147483640;
        for (int i = 1; i <= N; i++) {
            int j; long long now;
            for (j = i + 1; j <= N; j++) if (A[j]!= A[i]) break;
            if (A[j]!= A[i]) j--; now = j - i + 1;
            ans += (now * (now - 1)) / 2;
            i = j;
        }
        printf ("%lld\n", ans);
    }
    return 0;
}
```

### 最优关键思路或技巧
- **等式变形**：将原等式 $a_j - a_i = j - i$ 变形为 $a_j - j = a_i - i$ ，从而将问题转化为统计差值相同的元素对数。
- **处理负数差值**：当 $a_i - i$ 可能为负数时，可使用 `map` 来处理，其单次修改为 $\log n$ 级别；也可通过给差值加上偏移量 $n$ ，使差值变为正数，用数组统计，时间复杂度降为 $O(n)$ 。

### 同类型题或类似算法套路拓展
同类型题目通常会给出一个等式关系，通过对等式进行代数变形，转化为统计某种相同特征的元素个数或对数的问题。类似算法套路包括对给定条件进行数学推导，将复杂问题简单化，然后根据数据范围选择合适的数据结构进行统计。

### 洛谷相似知识点题目推荐
 - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：通过归并排序统计逆序对数量，与本题统计满足特定条件的数对数量类似。
 - [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)：利用哈希统计字符串特征，与本题通过统计特定差值来解决问题思路类似。
 - [P2671 求和](https://www.luogu.com.cn/problem/P2671)：通过对式子变形，利用前缀和统计满足条件的数对，与本题通过等式变形后统计数对有相似之处。

### 个人心得摘录与总结
 - **oimaster**：提到数组处理负数下标的局限，以及 `map` 在处理此类问题的优势，同时给出了数组加偏移量这种取巧路线，强调了对数据结构选择的重要性。 

---
处理用时：49.43秒
# 题目信息

# Chess Tournament

## 题目描述

### 题意翻译

$n$ 个人进行比赛，每场比赛的结果只有输，赢，平局三种情况。

每个玩家对于比赛都有自己的期望，有以下两种类型：

1. 玩家不想输掉任何一场比赛；

2. 玩家想要赢得至少一场比赛。

判断是否存在所有比赛的结果，使得所有玩家都满足他们的期望。 如果有多种可能的结果，输出任意一种即可。 如果没有，输出 No。

## 说明/提示

$1\le t \le 200,2\le n \le50$。

译者：@smyslenny

## 样例 #1

### 输入

```
3
3
111
2
21
4
2122```

### 输出

```
YES
X==
=X=
==X
NO
YES
X--+
+X++
+-X-
--+X```

# AI分析结果

### 题目内容
# Chess Tournament

## 题目描述

### 题意翻译
$n$个人进行比赛，每场比赛的结果只有输，赢，平局三种情况。

每个玩家对于比赛都有自己的期望，有以下两种类型：
1. 玩家不想输掉任何一场比赛；
2. 玩家想要赢得至少一场比赛。

判断是否存在所有比赛的结果，使得所有玩家都满足他们的期望。如果有多种可能的结果，输出任意一种即可。如果没有，输出No。

## 说明/提示
$1\le t \le 200,2\le n \le50$。

译者：@smyslenny

## 样例 #1
### 输入
```
3
3
111
2
21
4
2122
```
### 输出
```
YES
X==
=X=
==X
NO
YES
X--+
+X++
+-X-
--+X
```

### 算法分类
构造

### 综合分析与结论
这些题解的核心思路都是基于对两类玩家期望的分析来构造比赛结果。对于不想输掉任何一场比赛的玩家（第一类），让他们之间以及他们与第二类玩家的比赛都以平局结束较为合理；对于想要赢得至少一场比赛的玩家（第二类），当人数小于3时无法满足期望，人数大于等于3时可以通过构造环的方式满足期望。各题解在具体实现上略有不同，但整体思路一致。

### 所选的题解
- **作者：Jerrlee✅ (5星)**
    - **关键亮点**：思路阐述清晰，简洁明了地说明了针对两类玩家的比赛结果构造方式，先分析第一类棋手比赛应有的结果，再分析第二类棋手不同人数下的情况。
    - **个人心得**：无
    - **重点代码**：无具体代码，核心实现思想为第一类棋手之间及与第二类棋手比赛均平局，第二类棋手人数不少于3时构成环让每人赢一场。
- **作者：smyslenny (4星)**
    - **关键亮点**：代码实现完整，通过计数判断第二类玩家数量，在循环中根据玩家类型构造比赛结果矩阵，并注意了结果矩阵的对称性。
    - **个人心得**：注意答案中$i,j$和$j,i$的对应情况，避免因打比赛时未注意导致错误。
    - **重点代码**：
```c++
for(int i=1;i<=n;i++)
{
    for(int j=i;j<=n;j++)
    {
        if(i==j) Ans[i][j]='X';
        else
            if(sz[i]==1 || sz[j]==1) Ans[i][j]=Ans[j][i]='=';
        else
            if(sz[i]==2) 
            {
                sz[i]=0;
                Ans[i][j]='+';
                Ans[j][i]='-';
            }
        else
            if(sz[j]==2) 
            {
                sz[j]=0;
                Ans[i][j]='-';
                Ans[j][i]='+';
            }
        else
            Ans[i][j]=Ans[j][i]='=';
    }
}
```
核心实现思想：遍历比赛双方，根据双方玩家类型确定比赛结果，若为同一人则为'X'，有第一类玩家则平局，均为第二类玩家时让一方赢另一方输。
- **作者：xixike (4星)**
    - **关键亮点**：通过预处理记录类型2选手的编号及前一个类型2选手编号，利用这些信息构造环，逻辑清晰。
    - **个人心得**：无
    - **重点代码**：
```c++
for(p = pos; pre[p]; p = pre[p])
    ans[p][pre[p]] = '+', ans[pre[p]][p] = '-';
ans[p][pos] = '+', ans[pos][p] = '-';
```
核心实现思想：从最后一个类型2选手开始，根据记录的前一个类型2选手编号，依次构造环，让每个类型2选手赢下前一个选手，最后让第一个类型2选手赢下最后一个类型2选手。

### 最优关键思路或技巧
根据玩家期望的特点进行分类构造。对于第一类玩家，利用平局满足其不输的期望；对于第二类玩家，通过判断人数并构造环的方式满足其至少赢一场的期望。在代码实现上，注意结果矩阵的对称性，以及对不同类型玩家比赛结果的合理安排。

### 拓展
同类型题通常围绕根据特定条件构造满足要求的方案展开。类似算法套路是先分析不同条件下的合理情况，再进行针对性构造。例如在一些比赛安排、资源分配等问题中，根据不同参与者的需求构造可行方案。

### 推荐题目
- [P1163 银行贷款](https://www.luogu.com.cn/problem/P1163)：通过构造还款计划满足贷款相关条件，与本题构造比赛结果满足玩家期望类似。
- [P1469 找筷子](https://www.luogu.com.cn/problem/P1469)：根据数字出现次数的特点构造寻找单独数字的方法，锻炼构造思路。
- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：通过构造满足条件的跳跃方案解决问题，同样涉及根据条件进行合理构造。 

---
处理用时：51.79秒
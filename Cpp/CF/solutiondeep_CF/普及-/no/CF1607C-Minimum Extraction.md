# 题目信息

# Minimum Extraction

## 题目描述

*Yelisey* 有一个含有 $n$ 个整数的数组 $a$。

如果 $a$ 的长度大于 $1$，*Yelisey* 就能对它进行一种被称为「提取最小值」的操作：

1. 将最小值 $m$ 从数组中删除，数组的长度会因此缩短 $1$。

   （如果有几个相同的 $m$，*Yelisei* 可以凭心情任选一个。）

2. 数组中剩下的元素也会被减去 $m$。

举个例子，有一个数组 $\{1, 6, -4, -2, -4\}$，其中的最小元素是 $-4$。我们将随意删去 $a_3$、$a_5$ 中的一个，再把剩余元素各减去 $-4$。显而易见，操作后的数组长这样：$\{1-(-4),6-(-4),-2-(-4),-4-(-4)\}$，化简后得到答案 $\{5, 10, 2, 0\}$。

由于 Yelisey 更喜欢大数，他希望这种操作能使数组 $a$ 中的元素数值尽可能大。

准确来说，他希望使数组 $a$ 中的最小值最大。为了达到这一目的，*Yelisey* 不惜对数组进行任意次「提取最小值」操作；当然，他也不一定非要进行这种操作。

现在，请你帮助他计算出在进行任意次「提取最小值」操作后，数组 $a$ 中的最小元素可以具有的最大值。

## 说明/提示

在第一组数据中，数组的原始长度 $n=1$，*Yelisey* 不能对它进行操作。因此最小元素的最大值是 $a_1=10$ 。

在第二组数据中，数组始终只有 $0$。所以，最小元素的最大值为 $a_2=0$。

在第三组数据中，数组的改变过程如下： $\{\color{blue}{-1}$$,2,0\}\to\{ 3,\color{blue}1$$\}\to$ $\{$$\color{blue} {2}$$\}$。所以，最小元素的最大值是 $a_3=2$ 。(当前数组最小的数以蓝色标出）

保证所有询问的数组原始长度 $n$ 之和不超过 $2\cdot 10^5$。

在第四组数据中，数组的改变过程如下：$\{2,10,$$\color{blue}{1}$$,7\}\to\{\color{blue}{1}$$,9,6\}\to\{8,\color {blue}{5}$$\}\to$$\{$$\color{blue}{3}$$\}$。 所以，最小元素的最大值是 $a_4=5$ 。

Translated by @[Aynxul03](https://www.luogu.com.cn/user/267459) & @[li142857](https://www.luogu.com.cn/user/540584)

## 样例 #1

### 输入

```
8
1
10
2
0 0
3
-1 2 0
4
2 10 1 7
2
2 3
5
3 2 -4 -2 0
2
-1 1
1
-2```

### 输出

```
10
0
2
5
2
2
2
-2```

# AI分析结果

### 题目内容
# 最小提取

## 题目描述
Yelisey 有一个含有 $n$ 个整数的数组 $a$ 。

如果 $a$ 的长度大于 $1$ ，Yelisey 就能对它进行一种被称为「提取最小值」的操作：
1. 将最小值 $m$ 从数组中删除，数组的长度会因此缩短 $1$ 。
   （如果有几个相同的 $m$ ，Yelisei 可以凭心情任选一个。）
2. 数组中剩下的元素也会被减去 $m$ 。

举个例子，有一个数组 $\{1, 6, -4, -2, -4\}$ ，其中的最小元素是 $-4$ 。我们将随意删去 $a_3$、$a_5$ 中的一个，再把剩余元素各减去 $-4$ 。显而易见，操作后的数组长这样：$\{1-(-4),6-(-4),-2-(-4),-4-(-4)\}$ ，化简后得到答案 $\{5, 10, 2, 0\}$ 。

由于 Yelisey 更喜欢大数，他希望这种操作能使数组 $a$ 中的元素数值尽可能大。
准确来说，他希望使数组 $a$ 中的最小值最大。为了达到这一目的，Yelisey 不惜对数组进行任意次「提取最小值」操作；当然，他也不一定非要进行这种操作。

现在，请你帮助他计算出在进行任意次「提取最小值」操作后，数组 $a$ 中的最小元素可以具有的最大值。

## 说明/提示
在第一组数据中，数组的原始长度 $n = 1$ ，Yelisey 不能对它进行操作。因此最小元素的最大值是 $a_1 = 10$ 。

在第二组数据中，数组始终只有 $0$ 。所以，最小元素的最大值为 $a_2 = 0$ 。

在第三组数据中，数组的改变过程如下： $\{\color{blue}{-1},2,0\}\to\{ 3,\color{blue}1\}\to$ $\{\color{blue} {2}\}$ 。所以，最小元素的最大值是 $a_3 = 2$ 。(当前数组最小的数以蓝色标出）

保证所有询问的数组原始长度 $n$ 之和不超过 $2\cdot 10^5$ 。

在第四组数据中，数组的改变过程如下：$\{2,10,\color{blue}{1},7\}\to\{\color{blue}{1},9,6\}\to\{8,\color {blue}{5}\}\to$ $\{\color{blue}{3}\}$ 。 所以，最小元素的最大值是 $a_4 = 5$ 。

Translated by @[Aynxul03](https://www.luogu.com.cn/user/267459) & @[li142857](https://www.luogu.com.cn/user/540584)

## 样例 #1
### 输入
```
8
1
10
2
0 0
3
-1 2 0
4
2 10 1 7
2
2 3
5
3 2 -4 -2 0
2
-1 1
1
-2
```
### 输出
```
10
0
2
5
2
2
2
-2
```

### 算法分类
贪心

### 综合分析与结论
这些题解主要围绕如何通过排序和贪心策略来解决问题。多数题解先对数组排序，这样每次删除最小值的顺序就确定了。难点在于如何高效地模拟操作，避免每次操作都遍历整个数组。不同题解在实现上各有特点，有的通过维护一个总和来记录操作对数组的影响，有的则通过分析相邻元素差值来确定答案。

### 所选的题解
- **作者：xiaomuyun（5星）**
  - **关键亮点**：思路清晰，代码简洁。通过排序后维护一个 `sum` 来记录操作对数组元素的影响，避免重复遍历数组，优化了时间复杂度。每次操作时，将当前元素减去 `sum`，再更新 `sum`，同时取当前元素与 `mx` 的最大值。
  - **个人心得**：强调了不开 `long long` 可能出现的问题，以及 `mx` 初始化不能为 0 的注意点。
  - **核心代码**：
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3f;
ll n,a[200001],sum=0,mx=-inf;
int main(){
    ll t;
    scanf("%lld",&t);
    while(t--){
        sum=0,mx=-inf;
        scanf("%lld",&n);
        for(ll i=1;i<=n;++i) scanf("%lld",&a[i]);
        sort(a+1,a+1+n);
        for(ll i=1;i<=n;++i){
            a[i]-=sum,sum+=a[i];
            mx=max(a[i],mx);
        }
        printf("%lld\n",mx);
    }
    return 0;
}
```
- **作者：Aiopr_2378（4星）**
  - **关键亮点**：直接点明排序 + 贪心的思路，指出删数顺序就是排序后的数组顺序，问题转化为求当前数和上一个数的差的最大值，代码简洁明了。
  - **核心代码**：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int t,n,a[200005];
int main(){
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        sort(a+1,a+1+n);
        int temp=a[1],maxi=a[1];
        for(int i=2;i<=n;i++){
            maxi=max(maxi,a[i]-temp);
            temp=a[i];
        }
        cout<<maxi<<endl;
    }
    return 0;
}
```
- **作者：Valhalla_Is_Calling（4星）**
  - **关键亮点**：思路独特，指出对于一个数 $a_i$，其能否成为答案取决于它与排序后前一个数的差，直接得出只需在排序后求相邻两个数字差的最大值即可的结论。
  - **核心代码**：无（题解未给出完整代码）

### 最优关键思路或技巧
先对数组进行排序，利用贪心思想，通过维护一个变量记录操作对数组整体的影响，避免每次操作都遍历数组，从而优化时间复杂度。或者直接分析相邻元素差值来确定答案，简化问题求解过程。

### 可拓展之处
此类题目属于数组操作与最值求解结合的类型，类似套路是先对数组排序，然后分析操作对数组元素的影响规律，利用贪心策略求解。例如一些对数组进行特定变换操作后求最值的题目，都可以尝试类似思路。

### 相似知识点洛谷题目
 - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及排序和贪心策略，通过对数据排序后贪心求解最大收益。
 - [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：同样是对数组排序后利用贪心思想解决问题，与本题思路类似。
 - [P1937 [USACO10MAR]Barn Allocation G](https://www.luogu.com.cn/problem/P1937)：通过排序和贪心解决区间分配问题，与本题在排序后利用贪心策略的思路上有相似性。

### 个人心得摘录与总结
部分题解作者强调了数据类型的重要性，如不开 `long long` 可能导致错误，以及变量初始化的注意事项，如 `mx` 初始化不能为 0。这些都是在实际编程中容易忽略但可能导致错误的细节。 

---
处理用时：54.65秒
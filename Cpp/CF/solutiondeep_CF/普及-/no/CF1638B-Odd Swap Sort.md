# 题目信息

# Odd Swap Sort

## 题目描述

#### 题目大意

给定一个数列 $a_1,a_2,...,a_n$ 。

你可以执行若干次如下的操作：

- 选择一个整数 $i\ (\ 1\leq i< n\ )$ ，如果 $a_i+a_{i+1}$ 为奇数，交换 $a_i$ 和 $a_{i+1}$ 。

问是否可以将该数列排序成单调不降数列。

## 样例 #1

### 输入

```
4
4
1 6 31 14
2
4 2
5
2 9 6 7 10
3
6 6 6```

### 输出

```
Yes
No
No
Yes```

# AI分析结果

### 题目内容
# 奇数交换排序

## 题目描述

#### 题目大意
给定一个数列 $a_1,a_2,\cdots,a_n$ 。

你可以执行若干次如下的操作：
- 选择一个整数 $i\ (1\leq i\lt n)$ ，如果 $a_i + a_{i + 1}$ 为奇数，交换 $a_i$ 和 $a_{i + 1}$ 。

问是否可以将该数列排序成单调不降数列。

## 样例 #1
### 输入
```
4
4
1 6 31 14
2
4 2
5
2 9 6 7 10
3
6 6 6
```
### 输出
```
Yes
No
No
Yes
```
### 算法分类
数学

### 综合分析与结论
这些题解的核心思路都是基于相同的数学性质：由于只有相邻两数和为奇数时才能交换，即只能在奇偶性不同的数之间交换，所以奇偶性相同的数相对位置不会改变。基于此，只要判断奇数子序列和偶数子序列是否分别为非递减数列即可。
各题解在实现方式上略有不同，有的使用变量记录当前奇偶性对应的最大值（如miao5、zhongcy等），有的使用集合（如清烛、CmsMartin），有的从后往前枚举记录最小值（如lsr1409111459 ）。

### 所选的题解
- **作者：清烛（4星）**
  - **关键亮点**：思路清晰，使用`set`来维护奇偶性相同的数，方便判断当前数是否比同奇偶性已遍历过的数大，代码简洁明了。
  - **重点代码核心实现思想**：遍历数组，根据数的奇偶性插入对应的`set`中，并判断`set`中最大元素是否大于当前数，若大于则不能排序，否则可以。
```cpp
const int maxn = 1e5 + 5;
int n, a[maxn];

int main() {
    int T; read(T);
    while (T--) {
        read(n);
        FOR(i, 1, n) read(a[i]);
        set<int> odd, even;
        bool flg = 1;
        FOR(i, 1, n) {
            if (a[i] & 1) {
                if (!odd.empty() && (*odd.rbegin()) > a[i])
                    flg = 0;
                odd.insert(a[i]);
            } else {
                if (!even.empty() && (*even.rbegin()) > a[i])
                    flg = 0;
                even.insert(a[i]);
            }
        }
        print(flg? "YES" : "NO");
    }
    return output(), 0;
}
```
- **作者：miao5（4星）**
  - **关键亮点**：解题思路阐述详细，通过维护奇偶性相同数的当前最大值，从前往后遍历数组判断是否满足非递减条件，代码简单易懂。
  - **重点代码核心实现思想**：遍历数组，根据数的奇偶性更新对应奇偶性的最大值，并判断当前数是否小于该最大值，若小于则不能排序，否则可以。
```cpp
int a[200005];
int main(){
    int t;
    t=read();
    while(t--){
        int n;
        n=read();
        for(int i=1;i<=n;i++) a[i]=read();
        int x=0,y=0;
        bool flag=0;
        for(int i=1;i<=n;i++){
            if(a[i]%2==0){
                if(a[i]<x) flag=1;
                else x=a[i];
            }
            else{
                if(a[i]<y) flag=1;
                else y=a[i];
            }
        }
        if(flag) cout<<"NO"<<endl;
        else cout<<"YES"<<endl;
    }
    return 0;
}
```
- **作者：lsr1409111459（4星）**
  - **关键亮点**：从冒泡排序思路引入，逆向思考，从后往前枚举记录最小的奇数和偶数，以此判断是否存在无法交换的逆序对，角度新颖。
  - **重点代码核心实现思想**：从后往前遍历数组，根据数的奇偶性更新对应奇偶性的最小值，并判断当前数是否大于该最小值，若大于则不能排序，否则可以。
```cpp
int T,n;
int a[100010];
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&a[i]);
        int odd=2147483647,even=2147483646;
        bool flag=true;
        for(int i=n;i>=1;i--)
        {
            if(a[i]%2)
            {
                if(odd<a[i]){flag=false;break;}
                odd=a[i];
            }
            else
            {
                if(even<a[i]){flag=false;break;}
                even=a[i];
            }
        }
        if(flag)printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

### 最优关键思路或技巧
利用题目中交换条件所限制的奇偶性相同数相对位置不变这一特性，将原问题转化为判断奇数子序列和偶数子序列是否非递减。实现上，使用简单变量维护最值或利用`set`等数据结构都能有效解决问题。

### 可拓展思路
同类型题通常会围绕特定交换规则下的序列排序或状态变化展开，类似算法套路是深入挖掘交换规则背后隐藏的不变量或限制条件，将复杂问题转化为更易判断的子问题。

### 洛谷相似题目推荐
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)
- [P1080 [NOIP2012 提高组] 国王游戏](https://www.luogu.com.cn/problem/P1080)
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)

### 个人心得摘录与总结
 - **作者：lsr1409111459**：在实现算法前要先考虑算法是否正确，否则可能浪费时间。该作者在考场上因未提前验证算法正确性，花费近一小时实现错误算法，影响后续做题。总结来说，做题时应先确保思路正确，避免盲目编码。 

---
处理用时：50.07秒
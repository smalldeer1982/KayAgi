# 题目信息

# Social Distance

## 题目描述

有一圈共 $m$ 个座椅（编号 $0 \sim m-1$），有 $n$ 个人要坐在上面，第 $i$ 个人左右两边至少要有 $a_i$ 个空座椅，问是否有一种方案可以使得所有人都能坐在上面。

## 说明/提示

样例第一组询问：人数大于座椅数，无解。

样例第二组询问：一种可行解为第一个人坐编号为 $2$ 的座椅，第二个人坐编号为 $0$ 的座椅。

样例第三组询问：第二个人无论坐哪，第一个人都没有位置，无解。

样例第四组询问：一种可行解为第一个人坐编号为 $1$ 的座椅，第二个人坐编号为 $4$ 的座椅，第三个人坐编号为 $7$ 的座椅。

## 样例 #1

### 输入

```
6
3 2
1 1 1
2 4
1 1
2 5
2 1
3 8
1 2 1
4 12
1 2 1 3
4 19
1 2 1 3```

### 输出

```
NO
YES
NO
YES
NO
YES```

# AI分析结果

### 题目内容
# 社交距离

## 题目描述
有一圈共 $m$ 个座椅（编号 $0 \sim m - 1$），有 $n$ 个人要坐在上面，第 $i$ 个人左右两边至少要有 $a_i$ 个空座椅，问是否有一种方案可以使得所有人都能坐在上面。

## 说明/提示
样例第一组询问：人数大于座椅数，无解。
样例第二组询问：一种可行解为第一个人坐编号为 $2$ 的座椅，第二个人坐编号为 $0$ 的座椅。
样例第三组询问：第二个人无论坐哪，第一个人都没有位置，无解。
样例第四组询问：一种可行解为第一个人坐编号为 $1$ 的座椅，第二个人坐编号为 $4$ 的座椅，第三个人坐编号为 $7$ 的座椅。

## 样例 #1
### 输入
```
6
3 2
1 1 1
2 4
1 1
2 5
2 1
3 8
1 2 1
4 12
1 2 1 3
4 19
1 2 1 3
```
### 输出
```
NO
YES
NO
YES
NO
YES
```
• **算法分类**：贪心
• **综合分析与结论**：这些题解的核心思路一致，均基于贪心策略。要点在于认识到相邻两人间的距离需取两人所需空位数的最大值，为使总座位需求最小，将 $a_i$ 排序，让需求大的人相邻，从而减少空位浪费。难点在于证明此贪心策略的正确性。各题解在思路阐述清晰度、代码风格及注释详细程度上有差异。
• **所选的题解**
  - **作者：Composite_Function（5星）**
    - **关键亮点**：思路阐述清晰，给出了贪心思路的证明过程，代码简洁且注释详细。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,a[200010];
int main(){
    cin>>t;
    while(t--){
        cin>>n>>m;
        for(long long i=1;i<=n;i++) cin>>a[i];
        sort(a+1,a+n+1);
        long long num=n;
        for(long long i=1;i<=n;i++)
            num+=(i==1?a[n]:a[i]);
        cout<<(num<=m?"Yes":"No")<<endl;
    }
    return 0;
}
```
核心实现思想：先输入数据并排序，通过循环累加所需座位数（考虑首尾相连），最后与总座位数比较判断是否有解。
  - **作者：white_carton（4星）**
    - **关键亮点**：思路表述清晰，通过分析如何最小化总距离需求得出排序的必要性，代码结构合理。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100100];
void solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	int sum=0;
	for(int i=2;i<=n;i++){
		sum+=a[i];
	}
	sum+=a[n];
	if(sum+n>m){
		cout<<"NO"<<endl;
	}
	else{
		cout<<"YES"<<endl;
	}
}
int main(){
	int t;
	cin>>t;
	while(t--){
		solve();
	}
}
```
核心实现思想：输入数据并排序，通过循环计算所需座位数（考虑环的特性），加上人数后与总座位数比较输出结果。
  - **作者：haokee（4星）**
    - **关键亮点**：思路简洁明了，直接指出排序可让相邻两人空位靠近，代码使用了类型别名等优化，注释较详细。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
#include <iostream>
#include <algorithm>

using namespace std;
using ll = long long;

const int kMaxN = 5e4 + 1;

ll a[kMaxN], t, n, m, ans;

int main() {
  for (cin >> t; t; --t) {
    cin >> n >> m, ans = 0;
    for (int i = 1; i <= n; ++i) {
      cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i) {
      ans += a[i == 1? n : i] + 1;
    }
    cout << (ans <= m? "YES" : "NO") << '\n';
  }
  return 0;
}
```
核心实现思想：输入数据并排序，循环累加所需座位数（特判第一个人并记得加1表示人本身占的位置），最后比较判断输出。
• **最优关键思路或技巧**：利用贪心策略，通过排序使相邻两人所需空位数尽量靠近，减少总座位需求，从而简化问题求解。
• **可拓展之处**：同类型题通常围绕资源分配、任务安排等场景，在满足一定条件下求方案可行性或最优解，类似套路是寻找局部最优策略并证明其能导致全局最优。
• **推荐洛谷题目**：
  - P1080 [NOIP2012 提高组] 国王游戏，涉及贪心策略和排序。
  - P2859 [USACO06DEC] Milk Patterns G，需运用贪心和字符串相关知识。
  - P1937 [USACO10MAR] Barn Allocation G，同样是贪心策略解决资源分配问题。
• **个人心得摘录与总结**：无。 

---
处理用时：44.48秒
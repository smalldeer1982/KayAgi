# 题目信息

# Shoe Shuffling

## 题目描述

一个班的学生想要互相换鞋子，假设这个班有 $n$ 名学生，给定一个**非递减**的序列记录每个学生鞋子的码数。你需要给出一个下标排列，使得每个学生拿到的都不是自己的鞋子，并且码数与原来的相同。如果找不到这样的下标排列，输出 $-1$ 。

定义一个下标排列由整数 $1$ 到 $n$ 组成，顺序任意。比如， $ [2,3,1,5,4] $ 是一个下标序列；$ [1,2,2] $ 不是一个下标数列，因为 $2$ 出现了两次；$ [1,3,4] $ 不是一个下标序列，因为排列的长度为 $3$ 却出现了元素 $4$。

## 说明/提示

对于第一组数据，除了 $[1, 2, 3, 4, 5]$ 外的长度为 $5$ 的下标序列都是合法的，因为每个同学之间都能穿对方的鞋子。

对于第二组数据，可以证明没有合法的下标序列。

## 样例 #1

### 输入

```
2
5
1 1 1 1 1
6
3 6 8 13 15 21```

### 输出

```
5 1 2 3 4 
-1```

# AI分析结果

### 题目内容
# 鞋子交换

## 题目描述
一个班的学生想要互相换鞋子，假设这个班有 \(n\) 名学生，给定一个**非递减**的序列记录每个学生鞋子的码数。你需要给出一个下标排列，使得每个学生拿到的都不是自己的鞋子，并且码数与原来的相同。如果找不到这样的下标排列，输出 \( -1\) 。

定义一个下标排列由整数 \(1\) 到 \(n\) 组成，顺序任意。比如， \( [2,3,1,5,4] \) 是一个下标序列；\( [1,2,2] \) 不是一个下标数列，因为 \(2\) 出现了两次；\( [1,3,4] \) 不是一个下标序列，因为排列的长度为 \(3\) 却出现了元素 \(4\)。

## 说明/提示
对于第一组数据，除了 \( [1, 2, 3, 4, 5] \) 外的长度为 \(5\) 的下标序列都是合法的，因为每个同学之间都能穿对方的鞋子。

对于第二组数据，可以证明没有合法的下标序列。

## 样例 #1
### 输入
```
2
5
1 1 1 1 1
6
3 6 8 13 15 21
```
### 输出
```
5 1 2 3 4 
-1
```

### 算法分类
构造

### 综合分析与结论
这些题解的核心思路都是基于一个关键结论：若存在某个鞋码只出现一次，则无解；只有每种鞋码出现次数大于1时，才可能有解，且有解时，鞋码相同的人相互交换鞋子。各题解的差异主要体现在实现方式上。有的使用STL函数如 `rotate` 来实现交换，有的通过双指针、二分查找等方式统计相同鞋码的人数并构造交换方案。

### 所选的题解
- **作者：RE_Prince (5星)**
  - **关键亮点**：思路清晰，先通过分析得出关键结论，再利用STL的 `rotate` 函数简洁地实现了相同鞋码学生鞋子的交换，代码可读性高。
  - **个人心得**：考场上T飞，说明对时间复杂度的把控在竞赛中很重要。
  - **重点代码**：
```cpp
while (T--)
{
    memset(x, 0, sizeof(x));
    cin >> n;
    for (i = 0; i < n; i++) cin >> a[i], x[i] = i + 1;
    i = 0;
    int l = 0;
    bool pd = 1;
    while (i < n)
    {
        while (i < n - 1 && a[i] == a[i + 1]) i++;
        if (l == i)
        {
            pd = 0;
            break;
        }
        rotate(x + l, x + i, x + i + 1);
        l = i + 1;
        i++;
    }
    if (!pd) cout << "-1\n";
    else
    {
        for (i = 0; i < n; i++) cout << x[i] << " ";
        cout << endl;
    }
}
```
  - **核心实现思想**：遍历数组，统计相同鞋码的连续段，若某段只有一个鞋码则无解；否则用 `rotate` 函数对相同鞋码的下标数组进行旋转，实现鞋子交换。
- **作者：Night_sea_64 (4星)**
  - **关键亮点**：利用 `lower_bound` 和 `upper_bound` 二分查找函数来统计每个鞋码出现的次数，代码简洁，逻辑清晰。
  - **重点代码**：
```cpp
while(t--)
{
    int n;
    cin>>n;
    bool flag=1;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        if(upper_bound(a+1,a+n+1,a[i])-lower_bound(a+1,a+n+1,a[i])<=1)
        {
            flag=0;
            break;
        }
        else
        {
            if(a[i]!=a[i-1])b[i]=upper_bound(a+1,a+n+1,a[i])-a-1;
            else b[i]=i-1;
        }
    }
    if(flag)
        for(int i=1;i<=n;i++)
            cout<<b[i]<<" ";
    else cout<<-1;
    cout<<endl;
}
```
  - **核心实现思想**：通过二分查找统计每个鞋码出现次数判断是否有解，对于有解情况，根据鞋码是否与前一个相同，确定当前学生应拿的鞋子下标。
- **作者：yanhao40340 (4星)**
  - **关键亮点**：使用 `map` 容器和 `vector` 容器，将相同鞋码的学生下标存储在 `vector` 中，再对每个 `vector` 进行轮换错排，代码结构清晰。
  - **重点代码**：
```cpp
while (t--){
    scanf("%d",&n);mp.clear();
    for (int i=1;i<=n;++i)
        scanf("%d",&a[i]),mp[a[i]].push_back(i);
    for (auto it:mp){
        auto i=it.second;
        if (i.size()==1){puts("-1");goto skip;}
        ans[i[0]]=i[i.size()-1];
        for (int j=1;j<i.size();++j) ans[i[j]]=i[j-1];
    }
    for (int i=1;i<=n;++i) printf("%d ",ans[i]);
    putchar('\n');skip:;
}
```
  - **核心实现思想**：遍历输入的鞋码，将相同鞋码的下标存入 `map` 对应的 `vector` 中，判断每个 `vector` 大小是否为1确定是否有解，有解则对 `vector` 内下标进行轮换构造输出序列。

### 最优关键思路或技巧
利用数据的非递减特性，通过统计相同鞋码的数量判断是否有解，在有解情况下，借助STL容器和函数（如 `map`、`vector`、`rotate`）或自定义逻辑实现相同鞋码学生鞋子的交换，简洁高效地解决问题。

### 可拓展之处
此类题目属于构造类型，类似的题目套路通常是根据给定条件推导关键结论，再依据结论进行方案构造。常见的拓展方向包括改变限制条件，如对鞋子码数的要求更复杂，或者增加其他限制因素；也可能改变数据结构，如用链表存储学生信息等。

### 洛谷相似题目
- **P1990 覆盖墙壁**：同样是构造类型题目，需要根据给定的条件构造出合法的方案，锻炼构造能力。
- **P1036 选数**：通过枚举和判断构造符合条件的数的组合，与本题构造符合条件的下标排列思路类似。
- **P2678 [NOIP2015 提高组] 跳石头**：给定条件下构造最优解，和本题在分析条件并构造结果上有相似思维方式。 

---
处理用时：51.06秒
# 题目信息

# Circle Game

## 题目描述

Mike 和 Joe 正在玩石子，迈克先手。他们有 $n$ 堆大小为 $a_1 , a_2,\ldots,a_n$ 的石子，堆呈圆形排列。

玩家从第一堆开始，顺时针依次从一堆中取出一些正数的石头。如果一个玩家在回合中从第 $i$ 堆取石头，另一个玩家在下一轮从 $ ((i\bmod n) + 1) $ 堆取石头。

如果玩家在回合中无法取走任何石头（因为堆是空的），他就输了。

假设 Mike 和 Joe 都采取最优策略，那么谁会赢？

## 样例 #1

### 输入

```
2
1
37
2
100 100```

### 输出

```
Mike
Joe```

# AI分析结果

### 题目内容
# 循环游戏

## 题目描述
Mike和Joe正在玩石子游戏，Mike先手。他们有\(n\)堆石子，大小分别为\(a_1, a_2, \ldots, a_n\)，这些石子堆呈圆形排列。
玩家从第一堆开始，顺时针依次从一堆中取出一些正数个石头。如果一个玩家在回合中从第\(i\)堆取石头，另一个玩家在下一轮从\(((i \bmod n) + 1)\)堆取石头。
如果玩家在回合中无法取走任何石头（因为堆是空的），他就输了。
假设Mike和Joe都采取最优策略，那么谁会赢？

## 样例 #1
### 输入
```
2
1
37
2
100 100
```
### 输出
```
Mike
Joe
```

### 算法分类
数学

### 综合分析与结论
所有题解思路基本一致，均根据\(n\)的奇偶性进行分类讨论：
 - **当\(n\)为奇数时**：Mike能通过在第一轮把第一堆石子全拿完，使得第二轮Joe无第一堆石子可拿，从而Mike获胜。
 - **当\(n\)为偶数时**：Mike始终拿奇数位置的石子，Joe始终拿偶数位置的石子，为保证拿的次数尽可能多，每次都只取\(1\)个。所以最先被拿空的石子堆（数组中的下标最靠前的最小值）决定胜负，若该堆下标为奇数则Joe胜，反之Mike胜。
各题解在代码实现上略有不同，但核心思路相同。

### 所选的题解
 - **作者：saixingzhe (赞：4)，星级：4星**
   - **关键亮点**：思路清晰，代码简洁明了，直接根据\(n\)的奇偶性判断并寻找最先被拿空的石子堆。
   - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,a[100],n;
int main(){
    cin>>t;
    while(t--){
        int ans=1;
        cin>>n;
        for(int i=1;i<=n;i++)   cin>>a[i];
        if(n&1){//判断
            printf("Mike\n");
            continue;   
        }
        for(int i=1;i<=n;i++)   if(a[i]<a[ans]) ans=i;//寻找最先被拿空的石子堆
        if(ans&1)   printf("Joe\n");
        else    printf("Mike\n");   
    }
    return 0;
}
```
核心实现思想：先输入数据，通过位运算判断\(n\)的奇偶性，奇数时直接输出Mike获胜；偶数时遍历数组找到最小值下标，再通过位运算判断该下标奇偶性决定获胜者。

 - **作者：litachloveyou (赞：2)，星级：4星**
   - **关键亮点**：对奇偶情况的分析详细，代码中通过分别记录奇数位置和偶数位置的最小值，再统一减去较小值判断谁先无石子可拿，逻辑清晰。
   - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void solve()
{
    int n;
    scanf("%d", &n);
    vector<int>a(n + 1);
    int minm = 1e9 + 10, minj = 1e9 + 10;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        i & 1? minm = min(minm, a[i]) : minj = min(minj, a[i]);
    }
    if (n & 1)puts("Mike");//奇数情况，一定赢。
    else
    {
        int check = 0;
        for (int i = 1; i <= n; i++)
        {
            a[i] -= min(minm, minj);
            if (a[i] <= 0)
            {
                check = (i & 1);
                puts(!check? "Mike" : "Joe");判断轮到谁没的拿。
                return;
            }
        }
    }
}
int main()
{
    int T = 1;
    scanf("%d", &T);
    while (T--)solve();
    return 0;
}
```
核心实现思想：先输入\(n\)和各堆石子数，分别记录奇数、偶数位置石子堆的最小值，奇数情况直接输出Mike获胜；偶数时所有石子堆减去较小的最小值，遍历判断谁先遇到无石子可拿的情况。

 - **作者：Jadebo1 (赞：1)，星级：4星**
   - **关键亮点**：解题思路部分对题意和思路的阐述详细，代码实现通过标准库函数`min_element`找到最小值，简化代码。
   - **重点代码**：
```cpp
void solve()
{
    cin >> n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    if(n&1)
    cout<<"Mike"<<endl;
    else
    {
        int minn=*min_element(a+1,a+1+n);
        int p;
       for(int i=1;i<=n;i++)
        {
            if(a[i]==minn)
            {
             p=i;
             break;             
            }
        }
        if(p&1)
        cout<<"Joe"<<endl;
        else
        cout<<"Mike"<<endl;
    }
}
```
核心实现思想：输入数据后判断\(n\)的奇偶性，奇数时Mike获胜；偶数时通过`min_element`找到最小值，再遍历找到最小值下标，根据下标奇偶性判断获胜者。

### 最优关键思路或技巧
根据\(n\)的奇偶性分类讨论是解决本题的关键思路。奇数时利用玩家拿取石子堆顺序的变化，先手玩家可直接清空第一堆获胜；偶数时通过分析可知每次只取\(1\)个石子能保证拿的次数最多，进而通过比较奇数、偶数位置石子堆的最小值决定胜负。

### 可拓展之处
同类型题可拓展到其他博弈类游戏，类似算法套路为根据游戏规则进行分类讨论，分析不同情况下的最优策略。例如一些轮流操作的游戏，通过对操作次数、操作对象等条件的奇偶性或其他特性进行分析，得出获胜策略。

### 推荐洛谷题目
 - [P1288 取数游戏II](https://www.luogu.com.cn/problem/P1288)
 - [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)
 - [P2197 模板 - Nim游戏](https://www.luogu.com.cn/problem/P2197)

### 个人心得
无。

---
处理用时：47.59秒
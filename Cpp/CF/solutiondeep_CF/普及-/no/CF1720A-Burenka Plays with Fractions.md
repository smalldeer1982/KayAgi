# 题目信息

# Burenka Plays with Fractions

## 题目描述

给出两个分数 $ \dfrac{a}{b}$ 和 $\dfrac{c}{d}$ ，你每次操作能够选择其中一个分数的分子或分母，将其乘上任意一个整数（当然不能对分母乘 $0$）。要求求出能够使两个分数相等的最小操作次数。

## 样例 #1

### 输入

```
8
2 1 1 1
6 3 2 1
1 2 2 3
0 1 0 100
0 1 228 179
100 3 25 6
999999999 300000000 666666666 100000000
33 15 0 84```

### 输出

```
1
0
2
0
1
1
1
1```

# AI分析结果

### 题目内容
# Burenka玩分数
## 题目描述
给出两个分数 $\frac{a}{b}$ 和 $\frac{c}{d}$ ，你每次操作能够选择其中一个分数的分子或分母，将其乘上任意一个整数（当然不能对分母乘 $0$）。要求求出能够使两个分数相等的最小操作次数。
## 样例 #1
### 输入
```
8
2 1 1 1
6 3 2 1
1 2 2 3
0 1 0 100
0 1 228 179
100 3 25 6
999999999 300000000 666666666 100000000
33 15 0 84
```
### 输出
```
1
0
2
0
1
1
1
1
```
• **算法分类**：数学
• **综合分析与结论**：这些题解的核心思路都是围绕使两个分数 $\frac{a}{b}$ 和 $\frac{c}{d}$ 相等所需的操作次数展开。关键在于通过对等式 $\frac{a}{b}=\frac{c}{d}$ 变形为 $ad = bc$ 来分析不同情况。难点在于如何全面且准确地考虑各种可能情况并确定最少操作次数。各题解都注意到答案只可能是0、1、2三种情况，主要区别在于对不同情况的判断方式和细节处理。有的通过判断倍数关系，有的通过最大公因数来确定分子分母的变化倍数，从而得出操作次数。
• **所选的题解**
  - **作者：liangbowen (5星)**
    - **关键亮点**：思路清晰，通过对等式 $axd = byc$ 的变形和推导，得出用最大公因数来确定分子分母分别需乘的倍数，进而得出操作次数，时间复杂度为 $\gcd$ 的复杂度，代码实现简洁明了。
    - **重点代码核心实现思想**：先计算 $ad$ 和 $bc$ 并求其最大公因数 $g$，若 $g$ 为0则直接输出0；否则将 $ad$ 和 $bc$ 分别除以 $g$，根据结果是否为1来确定操作次数。
    - **核心代码片段**：
```cpp
LL gcd(LL x, LL y) {return y == 0? x : gcd(y, x%y);}
void solve()
{
    int a = read(), b = read(), c = read(), d = read();
    LL t1 = 1ll * a * d, t2 = 1ll * b * c, g = gcd(t1, t2); //注意 LL
    if (g == 0) {putchar('0'), endl; return;}  //特判
    t1 /= g, t2 /= g; //如上分析的化简步骤
    write((t1!= 0) + (t2!= 0)), putchar('\n');
}
```
  - **作者：FFTotoro (4星)**
    - **关键亮点**：直接从等式 $ad = bc$ 出发，简洁地分析了不需要操作、一次操作和两次操作的情况，代码简洁，逻辑清晰。
    - **重点代码核心实现思想**：先计算 $ad$ 和 $bc$，若两者相等输出0；若其中一个是另一个的倍数（注意特判除数为0的情况）输出1；否则输出2。
    - **核心代码片段**：
```cpp
main(){
    ios::sync_with_stdio(false);
    int t; cin>>t;
    while(t--){
        int a,b,c,d; cin>>a>>b>>c>>d;
        a*=d; b*=c;
        if(a==b)cout<<"0\n";
        else if(b&&a%b==0||a&&b%a==0)cout<<"1\n"; // 如果一个是另一个的倍数
        // 注意，要特判除数是 0！！！
        else cout<<"2\n";
    }
    return 0;
}
```
  - **作者：RoyWu1207 (4星)**
    - **关键亮点**：分类讨论清晰，从使 $ad = bc$ 这个目标出发，明确地列举出三种情况：相等时操作数为0；倍数关系时操作数为1；其他情况操作数为2，并注意了对 $a = 0$ 或 $c = 0$ 的特判。
    - **重点代码核心实现思想**：根据 $ad$ 和 $bc$ 的关系，分别判断是否相等、是否存在倍数关系以及是否有分子为0的情况，从而输出对应的操作次数。
    - **核心代码片段**：
```cpp
int main() {
    int t; cin >> t;
    while (t--) {
        unsigned long long a, b, c, d;
        cin >> a >> b >> c >> d;
        if (a * d == b * c)
            cout << 0 << endl;
        else if (a == 0 || c == 0)
            cout << 1 << endl;
        else if (a * d % (b * c) == 0 || b * c % (a * d) == 0)
            cout << 1 << endl;
        else
            cout << 2 << endl;
    } return 0;
} 
```
• **最优关键思路或技巧**：将分数相等问题转化为等式 $ad = bc$ 的判断问题，通过分析 $ad$ 与 $bc$ 的关系（是否相等、是否存在倍数关系）以及分子是否为0的特殊情况，来确定最少操作次数。这种通过数学变形简化问题并分类讨论的思维方式是解决此类问题的关键。
• **可拓展思路**：同类型题可拓展到更多分数间的关系判断，或者在操作上增加更多限制条件。类似算法套路是遇到分数相关的等式判断或操作优化问题，可通过交叉相乘等数学手段转化为整数等式，再利用整数的性质（如整除、倍数关系）进行分析。
• **推荐题目**：
  - [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)，考察对整数的数学性质和分解操作。
  - [P1579 哥德巴赫猜想（升级版）](https://www.luogu.com.cn/problem/P1579)，涉及数论相关的数学分析和判断。
  - [P2681 求和](https://www.luogu.com.cn/problem/P2681)，需要运用数学知识优化计算过程。
• **个人心得摘录与总结**：多位作者提到要注意数据范围，记得开 `long long`，否则可能无法通过样例或测试数据。这表明在处理涉及整数运算且数据范围不明确时，要提前考虑足够大的数据类型，避免因数据溢出导致错误。 

---
处理用时：48.42秒
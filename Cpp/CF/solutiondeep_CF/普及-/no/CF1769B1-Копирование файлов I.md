# 题目信息

# Копирование файлов I

## 题目描述

В этой версии задачи размеры копируемых файлов не превышают $ 1000 $ байт.

Вы копируете с одного сервера на другой $ n $ файлов размером $ a_1, a_2, \ldots, a_n $ байт. Файлы копируются последовательно в заданном порядке.

При копировании вы видите два прогресс-бара: первый показывает процент скопированных данных в текущем файле, а второй — общий процент скопированных данных по всем $ n $ файлам. Оба процента отображаются округлёнными вниз до целого числа. Значения на прогресс-барах обновляются после копирования каждого байта.

Формально, после копирования байта номер $ x $ из файла номер $ i $ первый прогресс-бар показывает $ \lfloor \frac{100 \cdot x}{a_i} \rfloor $ процентов, а второй — $ \lfloor \frac{100 \cdot (a_1 + a_2 + \ldots + a_{i - 1} + x)}{a_1 + a_2 + \ldots + a_n} \rfloor $ процентов. В самом начале копирования оба прогресс-бара показывают $ 0 $ процентов.

Найдите все такие целые числа от $ 0 $ до $ 100 $ включительно, что существует момент времени, в который оба прогресс-бара одновременно показывают это число. Выведите эти числа в порядке возрастания.

## 样例 #1

### 输入

```
1
6```

### 输出

```
0
16
33
50
66
83
100```

## 样例 #2

### 输入

```
2
100 500```

### 输出

```
0
95
96
97
98
99
100```

## 样例 #3

### 输入

```
4
1000 2 2 998```

### 输出

```
0
50
99
100```

## 样例 #4

### 输入

```
6
170 130 400 256 30 100```

### 输出

```
0
17
43
44
84
90
99
100```

# AI分析结果

### 题目内容
# 文件复制 I

## 题目描述
在这个版本的问题中，要复制的文件大小不超过1000字节。

你要将 $n$ 个大小分别为 $a_1, a_2, \ldots, a_n$ 字节的文件从一台服务器复制到另一台服务器。文件按给定顺序依次复制。

在复制过程中，你会看到两个进度条：第一个显示当前文件已复制数据的百分比，第二个显示所有 $n$ 个文件已复制数据的总百分比。两个百分比都向下取整到整数。每复制一个字节后，进度条的值就会更新。

正式地说，在复制第 $i$ 个文件的第 $x$ 个字节后，第一个进度条显示 $\lfloor \frac{100 \cdot x}{a_i} \rfloor$ 百分比，第二个进度条显示 $\lfloor \frac{100 \cdot (a_1 + a_2 + \ldots + a_{i - 1} + x)}{a_1 + a_2 + \ldots + a_n} \rfloor$ 百分比。在复制开始时，两个进度条都显示0%。

找出所有介于0到100（包括0和100）之间的整数，使得存在某个时刻，两个进度条同时显示该整数。按升序输出这些数字。

## 样例 #1
### 输入
```
1
6
```
### 输出
```
0
16
33
50
66
83
100
```

## 样例 #2
### 输入
```
2
100 500
```
### 输出
```
0
95
96
97
98
99
100
```

## 样例 #3
### 输入
```
4
1000 2 2 998
```
### 输出
```
0
50
99
100
```

## 样例 #4
### 输入
```
6
170 130 400 256 30 100
```
### 输出
```
0
17
43
44
84
90
99
100
```

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路都是通过暴力模拟文件复制过程来解决问题。具体要点为：
1. **计算进度条值**：在传输第 $i$ 个文件的第 $x$ 字节时，按题目给定公式分别计算当前文件传输进度 $q$ 和总文件传输进度 $w$。
2. **查重**：由于可能出现重复的进度值，需要进行去重操作，不同题解使用了数组标记（如 `b` 数组）、`set` 容器、`map` 容器等方式去重。
3. **前缀和优化**：部分题解使用前缀和来优化对 $a_1 + a_2 + \ldots + a_{i - 1}$ 的计算，将原本每次计算的 $O(n)$ 复杂度降为 $O(1)$ 复杂度。

解决难点主要在于正确理解和实现进度条值的计算以及去重操作，避免重复输出结果。

### 所选的题解
- **作者：_32bit_Silentnight (5星)**
  - **关键亮点**：思路清晰，详细阐述了暴力模拟的过程，包括进度条值的计算方式，以及使用数组标记去重的方法，代码简洁明了。
  - **个人心得**：强调了计算总进度时不能蛮算，以及注意变量使用避免RE，还提到查重的重要性。
  - **重点代码核心思想**：通过两层循环遍历每个文件及每个字节，计算两个进度条值并判断是否相等，若相等且未重复则输出。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[114],i,s,q,w,j,k;bool b[114];
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
        s+=a[i];
    }
    for(i=1;i<=n;i++){
        for(j=0;j<=a[i];j++){
            q=100*j/a[i];
            w=100*(k+j)/s;
            if(q==w&&!b[q])printf("%d\n",q),b[q]=true;
        }
        k+=a[i];
    }
}
```
- **作者：MoonCake2011 (4星)**
  - **关键亮点**：先预处理总和方便计算，利用 `set` 容器自动排序去重的特性简化代码，同时详细记录了调试过程中发现的边界问题及修正方法。
  - **个人心得**：分享了WA的经历，包括未考虑 $j = 0$ 的情况以及 $j = 0$ 时 $cnt$ 多加一的问题。
  - **重点代码核心思想**：通过两层循环遍历文件和字节，计算进度条值，相等则插入 `set` 容器，最后遍历 `set` 输出结果。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110];
int sum,cnt;
set<int>s;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
    for(int i=1;i<=n;i++){
        for(int j=0;j<=a[i];j++){
            int A=100*j/a[i];
            int B=100*cnt/sum;
            if(A==B)
                s.insert(A);
            cnt++; 
        }
        cnt--;
    }
    set<int>::iterator it;
    for(it=s.begin();it!=s.end();it++) cout<<*it<<"\n";
    return 0;
} 
```
- **作者：Code_Fish_GoodBye (4星)**
  - **关键亮点**：先给出朴素暴力思路及代码，再分析复杂度并利用前缀和优化到更优复杂度，逻辑清晰，对优化过程讲解详细。
  - **重点代码核心思想**：利用前缀和数组快速计算区间和，通过两层循环遍历文件和字节，计算进度条值，相等则插入 `set` 容器，最后遍历 `set` 输出。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,z[105],sum[105];
set<int>y;
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>z[i];
    for(int i=1;i<=n;i++) sum[i]=sum[i-1]+z[i];
    for(int i=1;i<=n;i++){
        for(int j=0;j<=z[i];j++){
            a=100*j/z[i];
            b=(100*(sum[i-1]-sum[0]+j))/(sum[n]-sum[0]);
            if(a==b) y.insert(a);
        }
    }
    for(auto i:y) cout<<i<<endl;
    return 0;
}
```

### 最优关键思路或技巧
1. **前缀和优化**：使用前缀和数组来快速计算文件大小的累加和，将计算部分的时间复杂度从 $O(n)$ 优化到 $O(1)$，提高了程序运行效率。
2. **合理利用数据结构去重**：如 `set` 容器自动排序去重，减少了手动去重的代码量和复杂度，使代码更加简洁清晰。

### 可拓展之处
此类题目属于模拟类型，常见拓展方向是增加条件或改变统计方式。例如，改变进度条的计算规则，或者要求统计满足特定条件的进度条值出现的次数等。类似算法套路通常围绕对给定规则的准确模拟，结合合适的数据结构优化计算和存储。

### 洛谷相似题目推荐
1. [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)：通过模拟日常生活场景中的时间安排来解决问题，锻炼模拟能力。
2. [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：根据不同包装铅笔的价格和数量，模拟购买过程找到最优方案，涉及模拟与简单贪心。
3. [P5717 点和线](https://www.luogu.com.cn/problem/P5717)：模拟判断点与直线的位置关系，考验对几何概念的理解和模拟实现能力。 

---
处理用时：59.85秒
# 题目信息

# JoJo's Incredible Adventures

## 题目描述

给定一个长度为 $n$ 的二进制字符串 $s$，构建一个 $n \times n$ 的方格表。首行写下原始字符串 $s$，次行右移一个字符的循环移位字符串 $s$，第三行右移两个字符的循环移位字符串 $s$，以此类推。因此，第 $k$ 行包含一个从 $s$ 右移 $k$ 个字符的循环移位字符串。行从上到下编号 $0$ 至 $n-1$。

在生成的表中，需要找到只由数字 $1$ 构成的矩形并计算其面积，返回最大的面积。

注意：字符串 $s$ 向右循环移动 $k$ 位是指将其最后 $k$ 个字符移动到前面，即字符串 $s_{n-k+1} \cdots s_n \; s_1 \cdots s_{n-k}$。

## 样例 #1

### 输入

```
5
0
1
101
011110
101010```

### 输出

```
0
1
2
6
1```

# AI分析结果

【题目内容】
# JoJo的奇妙冒险

## 题目描述
给定一个长度为 $n$ 的二进制字符串 $s$，构建一个 $n \times n$ 的方格表。首行写下原始字符串 $s$，次行是将字符串 $s$ 右移一个字符的循环移位字符串，第三行是右移两个字符的循环移位字符串，依此类推。因此，第 $k$ 行包含一个从 $s$ 右移 $k$ 个字符的循环移位字符串。行从上到下编号为 $0$ 至 $n - 1$。

在生成的表中，需要找到只由数字 $1$ 构成的矩形并计算其面积，返回最大的面积。

注意：字符串 $s$ 向右循环移动 $k$ 位是指将其最后 $k$ 个字符移动到前面，即字符串 $s_{n - k + 1} \cdots s_n \; s_1 \cdots s_{n - k}$。

## 样例 #1

### 输入
```
5
0
1
101
011110
101010
```

### 输出
```
0
1
2
6
1
```

【算法分类】
数学

【综合分析与结论】
这些题解的核心思路都是将问题分为字符串全为 `1` 和字符串包含 `0` 两种情况进行讨论。对于全为 `1` 的情况，直接计算边长为字符串长度的正方形面积；对于包含 `0` 的情况，先将字符串复制一份拼接在末尾以处理首尾相连的情况，然后找出最长连续 `1` 的长度，再利用数学知识（长和宽越接近，矩形面积越大）计算最大矩形面积。

各题解的区别主要在于代码实现细节和表述方式，整体思路和算法要点基本一致。

【所选的题解】
- Loser_Syx（5星）：思路清晰，对两种情况的分类讨论明确，代码中使用了快速输入输出优化，提高了效率。
- Scrolling_Ball（4星）：通过打表找规律得出面积计算公式，思路直观，代码简洁易懂。
- liaoxingrui（4星）：对两种情况的分析清晰，代码实现简洁，使用了输入输出流的同步优化。

【重点代码】
Loser_Syx 的核心代码：
```cpp
signed main() {
    int T = read();
    while(T--){
        string s;
        cin >> s;
        s = s + s;
        int len = s.size();
        bool flag = 0;
        int maxlen = 0, nowlen = 0;
        f(i, 0, len-1, 1){
            if(s[i] == '0') flag = 1, nowlen = 0;
            if(s[i] == '1'){
                nowlen++;
                maxlen = max(maxlen, nowlen);
            }
        }
        if(flag == 0){
            len /= 2;
            write(len * len);
        }else{
            maxlen++;
            write((maxlen / 2) * ((maxlen + 1) / 2));
        }
        putchar('\n');
    }
    return 0;
}
```
核心实现思想：先将字符串复制一份拼接在末尾，然后遍历字符串找出最长连续 `1` 的长度。根据是否存在 `0` 进行分类讨论，计算并输出最大矩形面积。

Scrolling_Ball 的核心代码：
```cpp
int main()
{
    cin >> t;
    while(t -- )
    {
        cin >> s;
        s = s + s;
        ll sum = 0, ma = 0;
        for(ll i = 0; i < s.size(); i ++ )
            if(s[i] == '0')ma = max(ma, sum), sum = 0;
            else sum ++ ;
        ma = max(ma, sum);
        if(ma == s.size())cout << ma / 2 * ma / 2 << endl;
        else cout << (ma + 2) / 2 * ((ma + 1) / 2) << endl;
    }
    return 0;
}
```
核心实现思想：同样先拼接字符串，然后遍历找出最长连续 `1` 的长度。根据最长连续 `1` 的长度是否等于拼接后字符串的长度进行分类讨论，计算并输出最大矩形面积。

liaoxingrui 的核心代码：
```cpp
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); 
    cout.tie(0);
    cin>>t;
    while(t--){
        cin>>s;
        s+=s;
        ll len=s.size(),ma=0,sum=0;
        for(ll i=0;i<len;i++){
            if(s[i]=='1') sum++;
            else ma=max(ma,sum),sum=0;
        }
        ma=max(ma,sum);
        if(ma==len) cout<<((len/2)*(len/2))<<endl;
        else cout<<(((ma+2)/2)*((ma+1)/2))<<endl;
    }
    return 0;
}
```
核心实现思想：先进行输入输出流的同步优化，然后拼接字符串，遍历找出最长连续 `1` 的长度。根据最长连续 `1` 的长度是否等于拼接后字符串的长度进行分类讨论，计算并输出最大矩形面积。

【可拓展之处】
同类型题或类似算法套路：
- 对于字符串处理问题，常常需要考虑首尾相连的情况，可采用复制拼接的方法。
- 对于求最大矩形面积问题，可利用数学知识，在长和宽的和一定的情况下，长和宽越接近，面积越大。

【推荐题目】
- P1047 [NOIP2005 普及组] 校门外的树
- P1420 最长连号
- P1059 [NOIP2006 普及组] 明明的随机数

【个人心得】
wei2013：萌新第一篇题解，如有错误还请指出。（表达了新手的谦虚和希望得到指正的态度）

---
处理用时：38.71秒
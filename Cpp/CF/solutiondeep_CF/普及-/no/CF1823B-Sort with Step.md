# 题目信息

# Sort with Step

## 题目描述

给定一个 $1$ 到 $n$ 的排列 $p$ 和一个正整数 $k$。

你可以对 $p$ 进行若干次操作，每次操作交换 $p_i$ 和 $p_j$，其中 $|i-j|=k$。你的目标是使得 $p$ 变为升序。

除此之外，在开始你的操作之前，你还可以**预先交换**任意两个 $p_i$ 和 $p_j$ 一次。

你的任务是判断：

1. 能否在不用预先交换的情况下，使得 $p$ 变为升序；
2. 如果不能，能否在预先交换一次的情况下，使得 $p$ 变为升序。

## 说明/提示

$1\le t\le10^4$，$2\le n\le2\times10^5$，$1\le k\le n-1$，$1\le p_i\le n$。

每组数据的 $n$ 的总和 $\sum n\le2\times10^5$。

## 样例 #1

### 输入

```
6
4 1
3 1 2 4
4 2
3 4 1 2
4 2
3 1 4 2
10 3
4 5 9 1 8 6 10 2 3 7
10 3
4 6 9 1 8 5 10 2 3 7
10 3
4 6 9 1 8 5 10 3 2 7```

### 输出

```
0
0
1
0
1
-1```

# AI分析结果

### 题目分类
数学

### 综合分析与结论
这些题解的核心思路一致，都是通过判断每个数当前位置与应在位置的差值是否能被 $k$ 整除，统计不满足条件的数的个数，再根据个数判断是否能通过预先交换使排列升序。
- **思路**：对于排列中的每个数 $a_i$，它应在第 $i$ 个位置，若 $|a_i - i| \bmod k \neq 0$，则该数需要预先交换，用计数器统计这样的数的个数。若计数器为 $0$，则无需预先交换；若为 $2$，则可通过一次预先交换实现升序；若大于 $2$，则无法实现。
- **算法要点**：遍历排列，计算 $|a_i - i| \bmod k$，统计不满足条件的数的个数，根据个数输出结果。
- **解决难点**：理解预先交换的本质，即每次交换涉及两个数，所以需要预先交换的数的个数一定是偶数。

### 所选题解
- __yrq__ (4星)：思路清晰，代码简洁，直接实现核心逻辑。
- CheZiHe929 (4星)：详细解释思路，代码规范，易于理解。
- I_am_kunzi (4星)：对题目分析清晰，代码实现准确。

### 重点代码
```cpp
// __yrq__的代码
#include<bits/stdc++.h>
using namespace std;
int t,n,k,a[200005],s=0;//s代表需要预先交换的次数 
int main()
{
    cin>>t;
    while(t--)
    {
    	s=0;//初始化 
    	cin>>n>>k;
    	for(int i=1;i<=n;i++)
    	{
    		cin>>a[i];
    		if(a[i]!=i&&abs(a[i]-i)%k!=0) s++;//判断是否需要预先交换 
		}
		//判断三种情况，输出 
		if(s==0) cout<<"0\n";
		else if(s==2) cout<<"1\n";
		else if(s>2) cout<<"-1\n";
	}
    return 0;
}
```
核心实现思想：通过遍历排列，判断每个数是否需要预先交换，统计需要预先交换的数的个数，根据个数输出结果。

### 关键思路或技巧
- 利用数学性质判断数的位置是否需要调整，通过计数器统计需要调整的数的个数。
- 理解每次交换涉及两个数，所以需要预先交换的数的个数一定是偶数。

### 拓展思路
同类型题可能会改变交换规则或增加限制条件，但核心思路都是判断元素位置是否符合要求，通过统计不符合要求的元素个数来判断是否能达到目标。类似算法套路可用于解决其他涉及元素位置调整和判断的问题。

### 推荐题目
- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

### 个人心得
题解中未包含个人心得。 

---
处理用时：22.81秒
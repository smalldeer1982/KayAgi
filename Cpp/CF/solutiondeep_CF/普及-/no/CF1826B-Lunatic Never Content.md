# 题目信息

# Lunatic Never Content

## 题目描述

现在有一个数组 $a$，和 $n$ 个非负整数，定义 $f(a,x)=[a_1\bmod x,a_2\bmod x,\dots,a_n\bmod x]$，其中 $x$ 为正整数。现要你找到最大的 $x$，使得 $f(a,x)$ 是回文的。

这里，$a \bmod x$ 的含义为 $a$ 除以 $x$ 得到的余数。

我们认为一个数组是回文的，当且仅当从前往后读得到的结果和从后往前读得到的结果完全相同。换句话说，一个长度为 $n$ 的数组 $a$ 是回文的，当且仅当 $\forall 1\leq i \leq n$，有 $a_i=a_{n-i+1}$。

## 样例 #1

### 输入

```
4
2
1 2
8
3 0 1 2 0 3 2 1
1
0
3
100 1 1000000000```

### 输出

```
1
2
0
999999900```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
这些题解的核心思路一致，都是基于同余的数学性质来求解。若要使 $f(a,x)$ 为回文，需满足 $a_i\bmod x=a_{n - i + 1}\bmod x$，即 $|a_i - a_{n - i + 1}|\bmod x = 0$，所以 $x$ 是所有 $|a_i - a_{n - i + 1}|$ 的公因数，最大的 $x$ 就是它们的最大公因数。

各题解的差异主要体现在代码实现细节和是否特判数组本身为回文的情况。部分题解认为当数组本身是回文时，$x$ 可以取无穷大，应输出 $0$；而有些题解则利用 `__gcd` 函数的特性，使得在数组本身为回文时自动输出 $0$，无需特判。

### 所选题解
- **作者：_H17_ (赞：7)，4星**
    - **关键亮点**：思路清晰，代码简洁，使用 `#define int long long` 防止数据溢出，且通过双指针的方式遍历数组，代码可读性高。
- **作者：Night_sea_64 (赞：1)，4星**
    - **关键亮点**：思路阐述详细，对同余性质的解释清晰，代码简洁明了，直接使用 `__gcd` 函数计算最大公因数，处理数组本身为回文的情况也很巧妙。
- **作者：251Sec (赞：0)，4星**
    - **关键亮点**：对思路的推导过程有一定说明，并且提到了可以不特判数组本身为回文的情况，代码实现较为规范。

### 重点代码
#### _H17_ 的代码
```cpp
#include<bits/stdc++.h>
#define int long long //以防万一
using namespace std;
int T,n,a[100001],ans;
signed main(){
    cin>>T;
    while(T--){//多组数据
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        ans=0;//初始化
        for(int l=1,r=n;l<=r;l++,r--)//从头尾开始来搞（因为我懒）
            ans=__gcd(ans,abs(a[l]-a[r]));//差进行最大公因数
        cout<<ans<<endl;//输出（勿忘换行）
    }
    return 0;
}
```
**核心实现思想**：使用双指针从数组两端向中间遍历，计算每对元素差的绝对值，并不断更新最大公因数。

#### Night_sea_64 的代码
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int a[100010];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)cin>>a[i];
        int x=0;
        for(int i=1;i<=n;i++)
            x=__gcd(x,abs(a[i]-a[n-i+1]));
        cout<<x<<endl;
    }
    return 0;
}
```
**核心实现思想**：通过循环遍历数组，计算每个元素与对应对称元素差的绝对值，并不断更新最大公因数。

#### 251Sec 的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T;
int n;
ll a[100005];
ll GCD(ll a, ll b) {
    return b ? GCD(b, a % b) : a;
}
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%lld", a + i);
        ll res = abs(a[1] - a[n]);
        for (int i = 2; i <= n / 2; i++) res = GCD(res, abs(a[i] - a[n - i + 1]));
        printf("%lld\n", res);
    }
    return 0;
}
```
**核心实现思想**：先计算数组首尾元素差的绝对值，然后通过循环遍历数组前半部分，计算每对元素差的绝对值，并不断更新最大公因数。

### 最优关键思路或技巧
- **同余性质的运用**：利用同余的性质将问题转化为求多个数的最大公因数，简化了问题的求解过程。
- **`__gcd` 函数的使用**：直接使用 `__gcd` 函数计算最大公因数，避免了手动实现欧几里得算法，减少了代码量。
- **不特判回文情况**：部分题解利用 `__gcd` 函数的特性，使得在数组本身为回文时自动输出 $0$，无需额外的特判操作。

### 拓展思路
同类型题目可能会对数组元素的范围、数组长度、多组数据的规模等进行调整，或者在同余性质的基础上增加其他条件，如要求 $x$ 满足某些额外的限制条件。解题时仍然可以从同余的基本性质出发，结合题目中的具体条件进行分析。

### 推荐题目
1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)：考察最大公因数和最小公倍数的相关知识。
2. [P1579 哥德巴赫猜想（升级版）](https://www.luogu.com.cn/problem/P1579)：涉及质数和数论相关知识，与本题的数学思维有一定关联。
3. [P2651 添加括号III](https://www.luogu.com.cn/problem/P2651)：需要运用数学推理和分析来解决问题，锻炼数学思维能力。

### 个人心得
题解中未包含个人心得内容。

---
处理用时：38.76秒
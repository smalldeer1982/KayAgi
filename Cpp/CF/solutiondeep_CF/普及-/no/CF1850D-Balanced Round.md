# 题目信息

# Balanced Round

## 题目描述

你是codeforces round的出题人，现在你将设置n个问题，第i个问题的难度是ai。你将进行以下操作步骤：
1.	从题单中移除一部分题目（移除的题目的数量可能是0）
2.	按你想要的任何顺序重新排列剩余的问题

当且仅当任意两道连续的题目的难度之差的绝对值最多为k时（即绝对值小于等于k），这一回合（round）会被认为是平衡的。

你最少需要移除多少道题目，才能使问题的安排是平衡的？

## 说明/提示

对于第一个样例，我们可以移除前两个问题并得到一个问题的排列，其难度为【4，5，6】，连续的两个问题的难度之差的绝对值满足|5-4|=1≤1，|6-5|=1≤1

对于第二个样例，我们可以得到一个问题并将这一个问题（难度10）作为一个回合(round)

## 样例 #1

### 输入

```
7
5 1
1 2 4 5 6
1 2
10
8 3
17 3 1 20 12 5 17 12
4 2
2 4 6 8
5 3
2 3 19 10 8
3 4
1 10 5
8 1
8 3 1 4 5 10 7 3```

### 输出

```
2
0
5
0
3
1
4```

# AI分析结果

### 题目翻译
你是 Codeforces 轮次的出题人，现在你要设置 n 个问题，第 i 个问题的难度是 ai。你将进行以下操作步骤：
1. 从题单中移除一部分题目（移除的题目的数量可能是 0）
2. 按你想要的任何顺序重新排列剩余的问题

当且仅当任意两道连续的题目的难度之差的绝对值最多为 k 时（即绝对值小于等于 k），这一回合（round）会被认为是平衡的。

你最少需要移除多少道题目，才能使问题的安排是平衡的？

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是一致的，先对数组进行排序，然后将数组按相邻元素差值是否大于 k 进行分段，因为排序后不同段之间无法合并满足相邻元素差值不大于 k 的条件，所以要使删除的元素最少，就需要保留最长的一段，用总数减去最长段的长度即为最少删除的元素数量。

各题解的算法要点都是排序和分段统计最长段长度，解决的难点在于理解为什么只能保留一段以及如何正确统计最长段的长度。

### 所选题解
- **作者：Andy_Li (赞：6)  4星**
    - **关键亮点**：思路清晰，代码简洁，变量命名规范，易于理解。
```cpp
#include <bits/stdc++.h>
using namespace std;
int s[200010];
int main()
{
    cin.tie(0);
    std::ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        int n,k,cnt=1,ans=0;
        cin>>n>>k;
        for(int i=1;i<=n;i++)
            cin>>s[i];
        sort(s+1,s+n+1);
        for(int i=2;i<=n;i++)
            if(abs(s[i-1]-s[i])>k)
            {
                ans=max(ans,cnt);
                cnt=1;
            }
            else
                cnt++;
        ans=max(ans,cnt);
        cout<<n-ans<<endl;
    }
    return 0;
}
```
**核心实现思想**：先读取输入，对数组排序，然后遍历数组，当相邻元素差值大于 k 时，更新最长段长度并重置当前段长度，最后再更新一次最长段长度，用总数减去最长段长度得到结果。

- **作者：WsW_ (赞：4)  4星**
    - **关键亮点**：思路解释详细，通过分析不同删除情况得出只能保留连续一段的结论，代码逻辑清晰。
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,k;
int ans;
int a[200003];
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&k);
        int ans=0,l=0;
        for(int i=1;i<=n;i++)scanf("%d",&a[i]);
        sort(a+1,a+1+n);
        for(int i=2;i<=n;i++){
            if(a[i]-a[i-1]>k){
                ans=max(ans,i-1-l);
                l=i-1;
            }
        }
        ans=max(ans,n-l);
        printf("%d\n",n-ans);
    }
    return 0;
}
```
**核心实现思想**：同样先读取输入并排序，遍历数组，当相邻元素差值大于 k 时，更新最长段长度并记录新段的起始位置，最后再更新一次最长段长度，用总数减去最长段长度输出结果。

- **作者：___w (赞：4)  4星**
    - **关键亮点**：思路简洁明了，代码规范，注释清晰。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5+5;
int t, n, k, a[N];

int main() {
    ios::sync_with_stdio(0);
    cin >> t;
    while (t--) {
        cin >> n >> k;
        for (int i = 1; i <= n; ++i) cin >> a[i];
        sort(a+1, a+n+1);
        int Max = 0, len = 1;
        for (int i = 2; i <= n; ++i) {
            if (a[i]-a[i-1] <= k) ++len;
            else Max = max(Max, len), len = 1;
        }
        Max = max(Max, len);
        cout << n-Max << '\n';
    }
    return 0;
} 
```
**核心实现思想**：读取输入排序后，遍历数组，相邻元素差值不大于 k 时当前段长度加 1，否则更新最长段长度并重置当前段长度，最后再更新一次最长段长度，用总数减去最长段长度输出结果。

### 最优关键思路或技巧
- **排序**：通过排序使相邻元素差值最小化，便于后续分段处理。
- **分段统计**：将数组按相邻元素差值是否大于 k 进行分段，统计最长段的长度。

### 拓展思路
同类型题或类似算法套路：这类贪心问题通常是通过排序和分段的方式，找到满足条件的最优子结构。例如一些区间选择问题，先对区间按某个条件排序，然后根据条件进行分段或选择，以达到最优解。

### 推荐题目
1. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
2. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录与总结
- **作者：tang_mx**：第一次参加 CF，赛时用 dp 做这题过了，但赛后被 hack 了，说明在比赛时选择算法要谨慎，不能盲目使用，要充分考虑算法的正确性和边界情况。 

---
处理用时：39.40秒
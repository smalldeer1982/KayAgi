# 题目信息

# Yet Another Permutation Problem

## 题目描述

# 又一个排列问题


Alex 收到了一个名为 "GCD 排列" 的游戏作为生日礼物。这个游戏的每一轮进行如下操作：

- 首先，Alex 选择一个整数序列 $ ^{\dagger} $ $ a_1, a_2, \ldots, a_n $ ，其中整数范围从 $ 1 $ 到 $ n $ 。
- 然后，对于每个 $ i $ 从 $ 1 $ 到 $ n $ ，计算整数 $ d_i = \gcd(a_i, a_{(i \bmod n) + 1}) $ 。
- 本轮的得分是 $ d_1, d_2, \ldots, d_n $ 中不同数字的数量。

Alex 已经玩了几轮游戏，所以他决定找一个整数序列 $ a_1, a_2, \ldots, a_n $ ，使得它的得分尽可能地大。

回顾一下，$ \gcd(x, y) $ 表示 $ x $ 和 $ y $ 的 [最大公约数（GCD）](https://en.wikipedia.org/wiki/Greatest_common_divisor)，而 $ x \bmod y $ 表示将 $ x $ 除以 $ y $ 的余数。

 $ ^{\dagger} $ 长度为 $ n $ 的排列是一个由 $ n $ 个不同整数组成的数组，整数范围从 $ 1 $ 到 $ n $ 且顺序任意。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 不是排列（数组中有重复的 $ 2 $），$ [1,3,4] $ 也不是排列（虽然 $ n=3 $，但数组中有 $ 4 $）。

## 说明/提示

在第一个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 5 $ 组成的排列。对于排列 $ a=[1,2,4,3,5] $，数组 $ d $ 等于 $ [1,2,1,1,1] $。它包含 $ 2 $ 个不同的整数。可以证明，长度为 $ 5 $ 的排列中没有比这个得分更高的。

在第二个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 2 $ 组成的排列。只有两种这样的排列：$ a=[1,2] $ 和 $ a=[2,1] $。在这两种情况下，数组 $ d $ 都等于 $ [1,1] $，所以这两种排列都是正确的。

在第三个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 7 $ 组成的排列。对于排列 $ a=[1,2,3,6,4,5,7] $，数组 $ d $ 等于 $ [1,1,3,2,1,1,1] $。它包含 $ 3 $ 个不同的整数，所以得分等于 $ 3 $。可以证明，由整数 $ 1 $ 到 $ 7 $ 组成的排列中没有得分更高的。

## 样例 #1

### 输入

```
4
5
2
7
10```

### 输出

```
1 2 4 3 5 
1 2 
1 2 3 6 4 5 7 
1 2 3 4 8 5 10 6 9 7```

# AI分析结果

【题目内容】
# 又一个排列问题

Alex 收到了一个名为 "GCD 排列" 的游戏作为生日礼物。这个游戏的每一轮进行如下操作：

- 首先，Alex 选择一个整数序列 $ ^{\dagger} $ $ a_1, a_2, \ldots, a_n $ ，其中整数范围从 $ 1 $ 到 $ n $ 。
- 然后，对于每个 $ i $ 从 $ 1 $ 到 $ n $ ，计算整数 $ d_i = \gcd(a_i, a_{(i \bmod n) + 1}) $ 。
- 本轮的得分是 $ d_1, d_2, \ldots, d_n $ 中不同数字的数量。

Alex 已经玩了几轮游戏，所以他决定找一个整数序列 $ a_1, a_2, \ldots, a_n $ ，使得它的得分尽可能地大。

回顾一下，$ \gcd(x, y) $ 表示 $ x $ 和 $ y $ 的 [最大公约数（GCD）](https://en.wikipedia.org/wiki/Greatest_common_divisor)，而 $ x \bmod y $ 表示将 $ x $ 除以 $ y $ 的余数。

 $ ^{\dagger} $ 长度为 $ n $ 的排列是一个由 $ n $ 个不同整数组成的数组，整数范围从 $ 1 $ 到 $ n $ 且顺序任意。例如，$ [2,3,1,5,4] $ 是一个排列，但 $ [1,2,2] $ 不是排列（数组中有重复的 $ 2 $），$ [1,3,4] $ 也不是排列（虽然 $ n=3 $，但数组中有 $ 4 $）。

## 说明/提示

在第一个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 5 $ 组成的排列。对于排列 $ a=[1,2,4,3,5] $，数组 $ d $ 等于 $ [1,2,1,1,1] $。它包含 $ 2 $ 个不同的整数。可以证明，长度为 $ 5 $ 的排列中没有比这个得分更高的。

在第二个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 2 $ 组成的排列。只有两种这样的排列：$ a=[1,2] $ 和 $ a=[2,1] $。在这两种情况下，数组 $ d $ 都等于 $ [1,1] $，所以这两种排列都是正确的。

在第三个测试用例中，Alex 想要找一个由整数 $ 1 $ 到 $ 7 $ 组成的排列。对于排列 $ a=[1,2,3,6,4,5,7] $，数组 $ d $ 等于 $ [1,1,3,2,1,1,1] $。它包含 $ 3 $ 个不同的整数，所以得分等于 $ 3 $。可以证明，由整数 $ 1 $ 到 $ 7 $ 组成的排列中没有得分更高的。

## 样例 #1

### 输入

```
4
5
2
7
10
```

### 输出

```
1 2 4 3 5 
1 2 
1 2 3 6 4 5 7 
1 2 3 4 8 5 10 6 9 7
```

【算法分类】
构造

【综合分析与结论】
这些题解的核心思路基本一致，都是基于贪心策略的构造算法。其关键在于认识到要使相邻两数的最大公约数不同的数量最多，应让每个数（在其两倍不超过 $n$ 的情况下）后面紧跟着它的两倍，这样能保证该数成为相邻两数的最大公约数，从而对答案产生贡献。

各题解的算法要点都是从 $1$ 到 $n$ 枚举，若当前数未被使用，则将其及其不断乘 $2$ 且不超过 $n$ 的数依次加入排列中，最后再将剩余未使用的数按顺序添加到排列末尾。

解决的难点在于证明这样构造出的排列能使相邻两数最大公约数不同的数量达到最大。通过分析可知，大于 $\lfloor\frac{n}{2}\rfloor$ 的数不可能是两个 $[1,n]$ 内不同数的最大公约数，所以理论上最大不同数量为 $\lfloor\frac{n}{2}\rfloor$，而此构造方法能保证 $1$ 到 $\lfloor\frac{n}{2}\rfloor$ 中的数都能成为相邻两数的最大公约数，因此是最优的。

【所选的题解】
- fuxuantong123（5星）
  - 关键亮点：思路清晰，代码简洁，有详细的注释，对算法的解释也很明确，贪心策略的阐述易于理解。
- Q3284489219（4星）
  - 关键亮点：不仅给出了构造方法，还对为何这样构造能使 $\gcd$ 集合中存在所有小于等于 $\frac{n}{2}$ 的数进行了反证法证明，逻辑严谨。
- SunnyYuan（4星）
  - 关键亮点：思路描述形象易懂，通过具体例子展示了构造过程，代码实现简洁明了。

【重点代码】
### fuxuantong123 的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100010];
int mp[100010];
inline int read(){//废物快读
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main(){
	int t=read();
	while(t--){
		int n=read();
		for(int i=1;i<=n;i++){
			mp[i]=0;
		}
		a[1]=1;
		int cnt=1;
		for(int i=2;i<=n;i++){
			int sum=i;
			if(mp[sum]==0){
				while(sum<=n){
					a[++cnt]=sum;
					mp[sum]=1;
					sum*=2;
				}
			} 
		}
		for(int i=1;i<=cnt;i++){
			printf("%d ",a[i]);
		}
		printf("\n");
	}
return 0;
}
```
核心实现思想：先初始化标记数组 `mp`，将排列的第一个数设为 $1$，然后从 $2$ 到 $n$ 枚举，若当前数未被标记，则将其及其不断乘 $2$ 且不超过 $n$ 的数依次加入排列数组 `a` 中，并标记已使用，最后输出排列数组。

### Q3284489219 的代码
```c++
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double

using namespace std;

int n;
bool vis[100005];

void init(){
	memset(vis,0,sizeof(vis));
	cin>>n;
	cout<<1<<" ";
	for(int i=2;i<=n;i++){
		if(!vis[i]){
			cout<<i<<" ";
			vis[i]=1;
			for(int j=2;j*i<=n;j*=2){
				cout<<j*i<<" ";
				vis[j*i]=1;
			}
		}
	}
	cout<<endl;
}

int main(){
	int t;
	cin>>t;
	while(t--)
	    init();
	return 0;
}
```
核心实现思想：在 `init` 函数中，先初始化标记数组 `vis`，输出排列的第一个数 $1$，然后从 $2$ 到 $n$ 枚举，若当前数未被标记，则输出该数并标记，接着将其不断乘 $2$ 且不超过 $n$ 的数依次输出并标记。

### SunnyYuan 的代码
```cpp
#include <bits/stdc++.h>

using namespace std;

void solve() {
	int n;
	cin >> n;
	vector<bool> a(n + 1, 0);
	for (int i = 1; i <= n; i++) {
		if (a[i]) continue;
		int j = i;
		while (j <= n) {
			cout << j << ' ';
			a[j] = 1;
			j <<= 1;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (a[i]) continue;
		cout << i << ' ';
	}
	cout << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int T;
	cin >> T;
	while (T--) solve();
	
	return 0;
}
```
核心实现思想：在 `solve` 函数中，使用布尔型向量 `a` 作为标记数组，从 $1$ 到 $n$ 枚举，若当前数未被标记，则将其及其不断乘 $2$ 且不超过 $n$ 的数依次输出并标记，最后再将剩余未标记的数依次输出。

【最优关键思路或技巧】
- **贪心策略**：让每个数（在其两倍不超过 $n$ 的情况下）后面紧跟着它的两倍，这样能保证该数成为相邻两数的最大公约数，从而对答案产生贡献。
- **标记数组**：使用标记数组记录每个数是否已被使用，避免重复使用，确保构造出的是一个排列。

【拓展思路】
同类型题或类似算法套路：
- 其他构造排列使某种指标最优的问题，如构造排列使相邻元素的和最大、最小等。
- 涉及数论知识的构造问题，如构造满足特定余数条件的数列等。

【推荐题目】
- P1083 借教室：涉及贪心和差分的思想，通过构造合理的方案来满足需求。
- P1198 最大数：可以使用贪心和数据结构（如线段树）来构造满足条件的最大数序列。
- P1223 排队接水：贪心算法的经典应用，通过构造最优的排队顺序来使总等待时间最短。

【个人心得】
- qwerasdasd1：赛时想到做法，结果调 code 把自己心态调炸了，提醒大家多测时要清空相关变量，避免爆零。 

---
处理用时：63.65秒
# 题目信息

# XOR Palindromes

## 题目描述

给出一个长度为 $n$ 的 $01$ 串(只含 $0,1$ 的字符串) $s$。定义一个数 $x$ 是好数，当仅当存在一个长度也为 $n$ 的 $01$ 串 $l$ 使得对于所有的 $s_i$ 被 $s_i\oplus l_i$ 替换后得到的 $01$ 串是一个回文串。

对于给出的一组 $n,s$ ，你需要给出一个长度为 $n+1$ 的 $01$ 串 $t$ ，$t_i=1$ 当仅当 $i$ 是一个好数。**注意，$t$ 从 $0$ 开始编号**

题目中 $\oplus$ 表示异或。

回文串指正着读反着读都相同的字符串，比如 $0110,01010,1111$ 都是回文串。

## 说明/提示

考虑第一个例子：

 $t_2=1$ 是因为我们可以选到 $l=010100$ ，异或后 $s$ 变成 $111111$ 成为一个回文串。
 
 $t_4=1$ 是因为我们可以选到 $l=101011$ 此时 $s$ 变成回文串 $000000$。
 
 可以证明其他任意的 $i$ 都不满足成为 “好数” 的条件，故其他所有的位置都是 $0$。

## 样例 #1

### 输入

```
5
6
101011
5
00000
9
100100011
3
100
1
1```

### 输出

```
0010100
111111
0011111100
0110
11```

# AI分析结果

### 题目分类
位运算

### 综合分析与结论
这些题解的核心思路都是先找出将原串变为回文串所需的最少操作次数，再根据字符串长度的奇偶性来确定其他满足条件的操作次数。具体来说，先统计前后对称位置不同的对数（即最少操作次数），再考虑对称位置相同的对数。对于偶数长度的字符串，在最少操作次数的基础上，每次增加偶数次操作仍可得到回文串；对于奇数长度的字符串，除了增加偶数次操作，还可以单独操作中间的字符，所以在一定范围内的所有操作次数都可能得到回文串。

### 所选题解
- **Daniel_yao（5星）**
    - **关键亮点**：思路清晰，先求出将原串变为回文串的最小步数，再根据字符串长度的奇偶性扩展答案，代码实现规范，有详细的注释和输入输出处理。
- **One_JuRuo（4星）**
    - **关键亮点**：思路简洁明了，直接统计前后对称位置不一样的对数和一样的对数，然后根据奇偶性确定答案，同时提醒了不要使用 `memset` 以免超时。
- **RemiliaScar1et（4星）**
    - **关键亮点**：对好数的概念理解深入，通过分析修改次数的对称性和奇偶性来判断是否为好数，代码实现简洁。

### 重点代码
#### Daniel_yao 的代码
```cpp
void solve() {
  read(n);
  For(i,1,n) cin >> a[i];
  if(n & 1) {
    int l = (1 + n) >> 1, r = l, ans1 = 0;
    while(l >= 1) {
      if(a[l] != a[r]) ans1++;
      l--, r++;
    }
    For(i,0,n) {
      if(i >= ans1 && i <= n - ans1) cout << 1;
      else cout << 0; 
    }
    cout << '\n';
  } else {
    int l = n >> 1, r = l + 1, ans1 = 0;
    while(l >= 1) {
      if(a[l] != a[r]) ans1++;
      l--, r++;
    }
    For(i,0,n) {
      if(i >= ans1 && i <= n - ans1 && (i - ans1) % 2 == 0) cout << 1;
      else cout << 0; 
    }
    cout << '\n';
  }
}
```
**核心实现思想**：根据字符串长度的奇偶性，从中间向两边扩展统计不同字符的对数，即最少操作次数。然后根据最少操作次数和奇偶性判断每个操作次数是否能得到回文串。

#### One_JuRuo 的代码
```cpp
while(T--)
{
  scanf("%d%s",&n,ch+1),d=bd=0;
  for(int i=0;i<=n;++i) ans[i]=0;
  for(int i=1;i*2<=n;++i)
  {
    if(ch[i]==ch[n+1-i]) ++d;
    else ++bd;
  }
  for(int i=0;i<=d;++i)
  {
    ans[bd+i*2]=1;
    if(n%2) ans[bd+i*2+1]=1;
  }
  for(int i=0;i<=n;++i) printf("%d",ans[i]);
  puts("");
}
```
**核心实现思想**：统计前后对称位置一样的对数 `d` 和不一样的对数 `bd`。对于偶数长度的字符串，在 `bd` 的基础上每次增加偶数次操作；对于奇数长度的字符串，除了增加偶数次操作，还可以增加一次操作。

#### RemiliaScar1et 的代码
```cpp
while(t--)
{
  int n;
  scanf("%d",&n);
  char tmp[N];
  scanf("%s",tmp);
  for(int i=0;i<n;i++)
  {
    s[i+1]=(int)(tmp[i]=='1');
  }
  int h1=0;
  for(int i=1;i<=n/2;i++)
    if(s[i]!=s[n-i+1]) h1++;
  if(n&1)//奇数
  {
    for(int i=0;i<=n;i++)
      if(h1<=i&&i<=n-h1) printf("1");
      else printf("0");
  }
  else {//偶数
    for(int i=0;i<=n;i++)
      if(h1<=i&&i<=n-h1&&(i&1)==(h1&1)) printf("1");
      else printf("0");
  }
  printf("\n");
}
```
**核心实现思想**：先统计最少操作次数 `h1`，对于奇数长度的字符串，在 `[h1, n - h1]` 范围内的操作次数都能得到回文串；对于偶数长度的字符串，在 `[h1, n - h1]` 范围内且与 `h1` 奇偶性相同的操作次数能得到回文串。

### 最优关键思路或技巧
- 利用位运算的特性，异或操作可以改变字符的值，从而将问题转化为修改字符使字符串成为回文串的问题。
- 分类讨论字符串长度的奇偶性，根据对称位置的字符情况确定满足条件的操作次数。

### 可拓展之处
同类型题目可能会有不同的字符串操作规则，或者要求判断其他类型的字符串性质。类似的算法套路包括先找出基本的操作次数，再根据题目条件进行扩展和判断。

### 推荐题目
- [P1125 笨小猴](https://www.luogu.com.cn/problem/P1125)：考察字符串处理和简单的数学计算。
- [P1055 ISBN 号码](https://www.luogu.com.cn/problem/P1055)：涉及字符串的截取、转换和计算。
- [P1598 垂直柱状图](https://www.luogu.com.cn/problem/P1598)：需要对字符串进行统计和输出处理。

### 个人心得
One_JuRuo 提到不要使用 `memset`，因为使用 `memset` 会导致超时。这提醒我们在处理大规模数据时，要注意一些函数的使用可能会影响程序的性能。

---
处理用时：38.12秒
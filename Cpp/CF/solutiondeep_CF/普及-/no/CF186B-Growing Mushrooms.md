# 题目信息

# Growing Mushrooms

## 题目描述

每年，矮人王城堡里都会举行矮人种植蘑菇比赛。这项比赛是最负盛名的比赛之一，获胜者会得到一个木制沙拉碗。今年的比赛汇集了世界各地最优秀的蘑菇种植者，因此我们不得不对比赛规则稍作改动，使比赛更具观赏性。

每位蘑菇种植者都有自己要在比赛中种植的蘑菇。根据新规则，比赛由两部分组成。第一部分持续 $t1$ 秒，第二部分持续 $t2$ 秒。第一部分和第二部分之间有一小段休息时间。

哨声响起后，比赛的第一部分开始，所有蘑菇种植者同时开始种植蘑菇，每个人的速度为 $v_i$ 米/秒。$t1$ 秒后，蘑菇种植者停止种植蘑菇，开始休息。在休息期间，由于不明原因，所有蘑菇的生长量减少了 $k$% 。休息后，比赛的第二部分开始，所有种菇人同时继续种菇，每个人的速度为 $u_i$ 米/秒。经过 $t2$ 秒后，比赛结束。注意休息前后的速度可能不同。

赛前，小矮人帕夏向所有参赛者了解了他们选择的两种速度。不过，参赛者并不想向他透露自己的所有策略，因此也没有说他们将按照什么顺序使用这些速度。也就是说，如果参与者选择了速度 $a_i$ 和 $b_i$，则有两种策略：他要么先使用速度 $a_i$，后用 $b_i$，反之亦然。 

小矮人帕夏非常想赢得总分赛。他知道每个参赛者都会选择使蘑菇高度最大化的策略。帮助小矮人帕夏制作比赛结果的最终表格。

在成绩表中，参赛者按蘑菇高度排序（蘑菇高度高的参赛者排在前面）。如果蘑菇高度相同，则按参赛者的编号排序（编号小的参赛者排在前面）。

## 样例 #1

### 输入

```
2 3 3 50
2 4
4 2
```

### 输出

```
1 15.00
2 15.00
```

## 样例 #2

### 输入

```
4 1 1 1
544 397
280 101
280 101
693 970
```

### 输出

```
4 1656.07
1 937.03
2 379.99
3 379.99
```

# AI分析结果

### 题目内容
# 种植蘑菇

## 题目描述
每年，矮人王城堡里都会举行矮人种植蘑菇比赛。这项比赛是最负盛名的比赛之一，获胜者会得到一个木制沙拉碗。今年的比赛汇集了世界各地最优秀的蘑菇种植者，因此我们不得不对比赛规则稍作改动，使比赛更具观赏性。

每位蘑菇种植者都有自己要在比赛中种植的蘑菇。根据新规则，比赛由两部分组成。第一部分持续 \(t1\) 秒，第二部分持续 \(t2\) 秒。第一部分和第二部分之间有一小段休息时间。

哨声响起后，比赛的第一部分开始，所有蘑菇种植者同时开始种植蘑菇，每个人的速度为 \(v_i\) 米/秒。\(t1\) 秒后，蘑菇种植者停止种植蘑菇，开始休息。在休息期间，由于不明原因，所有蘑菇的生长量减少了 \(k\%\) 。休息后，比赛的第二部分开始，所有种菇人同时继续种菇，每个人的速度为 \(u_i\) 米/秒。经过 \(t2\) 秒后，比赛结束。注意休息前后的速度可能不同。

赛前，小矮人帕夏向所有参赛者了解了他们选择的两种速度。不过，参赛者并不想向他透露自己的所有策略，因此也没有说他们将按照什么顺序使用这些速度。也就是说，如果参与者选择了速度 \(a_i\) 和 \(b_i\)，则有两种策略：他要么先使用速度 \(a_i\)，后用 \(b_i\)，反之亦然。 

小矮人帕夏非常想赢得总分赛。他知道每个参赛者都会选择使蘑菇高度最大化的策略。帮助小矮人帕夏制作比赛结果的最终表格。

在成绩表中，参赛者按蘑菇高度排序（蘑菇高度高的参赛者排在前面）。如果蘑菇高度相同，则按参赛者的编号排序（编号小的参赛者排在前面）。

## 样例 #1
### 输入
```
2 3 3 50
2 4
4 2
```
### 输出
```
1 15.00
2 15.00
```
## 样例 #2
### 输入
```
4 1 1 1
544 397
280 101
280 101
693 970
```
### 输出
```
4 1656.07
1 937.03
2 379.99
3 379.99
```
### 算法分类
模拟

### 综合分析与结论
所有题解思路一致，均是针对每个参赛者的两种速度 \(a_i\) 和 \(b_i\)，分别计算先使用 \(a_i\) 后使用 \(b_i\) 以及先使用 \(b_i\) 后使用 \(a_i\) 这两种情况下蘑菇生长的最终高度，取两者中的较大值作为该参赛者蘑菇的最终高度，最后按照蘑菇高度从大到小、高度相同则编号从小到大的规则进行排序并输出。算法要点在于准确计算两种速度顺序下的蘑菇高度以及正确实现排序。解决难点在于对题目中生长速度变化、时间分段以及排序规则的准确理解和实现。

### 所选的题解
 - **作者：canwen (赞：4)  星级：4星  关键亮点：在结构体内重载运算符，这种方式在处理其他数据结构（如堆）时也经常使用，代码简洁且通用。**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define i(a,b,c) for(int i=(a);i<=(b);i+=(c))
struct node{
    int id;double num;
    bool operator<(const node &tmp)const{if(tmp.num==num) return tmp.id>id; else return tmp.num<num;}//重载运算符 	
}v[1005];
int n,t1,t2;double k;
signed main(){
    cin>>n>>t1>>t2>>k,k/=100;//先化成百分数（k是double类型） 
    i(1,n,1){
        double a,b;cin>>a>>b;
        v[i].num=max((1-k)*a*t1+b*t2,(1-k)*b*t1+a*t2),v[i].id=i;//id --> 选手编号 
    }
    sort(v+1,v+1+n);
    i(1,n,1) printf("%lld %.2f\n",v[i].id,v[i].num);
    return 0;
}
```
核心实现思想：定义结构体 `node` 存储选手编号 `id` 和蘑菇高度 `num`，重载 `<` 运算符实现按题目要求的排序规则。在 `main` 函数中，输入数据后计算每个选手蘑菇的最大高度并存储在结构体数组中，最后使用 `sort` 函数进行排序并输出。

 - **作者：miraculously (赞：4)  星级：4星  关键亮点：代码注释详细，逻辑清晰，对排序函数 `cmp` 的实现清晰展示了题目要求的排序规则。**
```cpp
#include<bits/stdc++.h>
using namespace std;
struct name{
    int h,id;//h表示每个蘑菇的高度，id表示蘑菇的编号
}bl[1001];
bool cmp(name x,name y)
{
    if(x.h==y.h)
    return x.id<y.id;
    return x.h>y.h;
}//蘑菇从大到小排序，大小相同，编号从小到大排序
int main()
{
    int n,t1,t2,k,a,b;
    scanf("%d%d%d%d",&n,&t1,&t2,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a,&b);
        bl[i].id=i;
        bl[i].h=max(a*(100-k)*t1+b*100*t2,a*100*t2+b*(100-k)*t1);//将a速度和b速度分别用两个时间算一下，取最大值，我这里把高度扩大一百倍，好写
    }
    sort(bl+1,bl+n+1,cmp);
    for(int i=1;i<=n;i++)
    printf("%d %.2lf\n",bl[i].id,0.01*bl[i].h);//之前高度扩大一百倍，所以乘上0.01
}
```
核心实现思想：定义结构体 `name` 存储蘑菇编号 `id` 和高度 `h`，通过 `cmp` 函数定义排序规则。在 `main` 函数中，输入数据后计算每个蘑菇的最大高度（计算时将高度扩大100倍以避免小数运算），排序后输出时再还原。

 - **作者：RE_Prince (赞：3)  星级：4星  关键亮点：代码结构清晰，对结构体和排序函数的使用简洁明了，对 `c` 进行预处理 `c/=100` 使后续计算更简洁。**
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
double m,c,t1,t2;
int n;
int i,j,k;
const int N=1e5+9;
double a[N],b[N];
struct Mush
{
    int id;
    double height;
}d[N];//方便排序的结构体
inline bool cmp(Mush x,Mush y)
{
    if(x.height==y.height) return x.id<y.id;
    return x.height>y.height;
}//注意第一个判断，一样高编号小的在先
signed main()
{
    cin>>n>>t1>>t2>>c;
    c/=100;//预处理c
    for(i=1;i<=n;i++) cin>>a[i]>>b[i];
    for(i=1;i<=n;i++)
    {
        double r1=(1-c)*a[i]*t1+b[i]*t2;
        double r2=(1-c)*b[i]*t1+a[i]*t2;
        d[i]={i,max(r1,r2)};//计算哪种更高
    }
    cout<<fixed<<setprecision(2);//两位小数
    sort(d+1,d+n+1,cmp);
    for(i=1;i<=n;i++) cout<<d[i].id<<" "<<d[i].height<<endl;
    return 0;//华丽结束
}
```
核心实现思想：定义结构体 `Mush` 存储蘑菇编号 `id` 和高度 `height`，`cmp` 函数确定排序规则。`main` 函数中，输入数据并预处理 `c`，计算每个蘑菇两种速度顺序下的高度并取最大值存储在结构体数组，最后排序并按要求格式输出。

### 最优关键思路或技巧
使用结构体存储选手编号和蘑菇高度，通过重载运算符或自定义比较函数来实现按题目要求的排序规则，这种方式简洁高效且易于理解和维护。在计算蘑菇高度时，清晰地分别计算两种速度顺序下的高度并取最大值，准确实现题目中的逻辑。

### 拓展
此类题目属于模拟实际场景的问题，通常需要根据给定的规则进行详细的逻辑模拟和数据处理。类似套路包括仔细分析题目中的条件变化、不同阶段的操作以及最终的输出要求，通过合理的数据结构存储数据并进行相应的计算和排序。

### 洛谷相似题目推荐
 - [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)：通过模拟移动纸牌的过程来解决问题，涉及数据的处理和逻辑模拟。
 - [P1423 小玉在游泳](https://www.luogu.com.cn/problem/P1423)：根据给定的游泳速度和休息规则模拟小玉游泳的过程，计算相关结果。
 - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：根据不同包装铅笔的价格和数量，模拟购买铅笔的方案选择并找出最优解。 

---
处理用时：62.32秒
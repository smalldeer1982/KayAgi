# 题目信息

# Swap and Delete

## 题目描述

有一个只含 $\texttt{0}$ 和 $\texttt{1}$ 的字符串 $s$，你可以对它进行如下两种操作：

1. 耗费一个金币，从 $s$ 中删除 $1$ 个字符。

2. 将 $s$ 中任意两字符互换位置（免费）。

定义一个字符串 $t$ 是美的代表对于所有满足 $1 \le i \le \left|t\right|$ 的 $i$，$s_i \ne t_i$ 。

你可以进行任意多次操作，假设 $s$ 修改后变为了 $s'$，问最少花费多少金币能使最终得到的 $s'$ 是美的。

## 样例 #1

### 输入

```
4
0
011
0101110001
111100```

### 输出

```
1
1
0
4```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是贪心算法，利用交换免费的特点，尽量多进行交换操作，无法交换时再进行删除操作。具体实现上，都是先统计字符串中 `0` 和 `1` 的数量，然后遍历字符串，尝试用相反的字符去匹配当前字符，若无法匹配则停止遍历，剩余的字符数量即为需要删除的数量。

不同题解的差异主要体现在代码风格和细节处理上，如变量命名、输入输出方式等，但整体思路一致。

### 所选题解
- **作者：_luouhgy_ (赞：3)  4星**
    - **关键亮点**：思路清晰，代码简洁，对贪心思路的解释详细，变量命名直观。
- **作者：IOI_official (赞：2)  4星**
    - **关键亮点**：思路简洁明了，代码结构清晰，对关键步骤有明确注释，易于理解。
- **作者：_Mortis_ (赞：0)  4星**
    - **关键亮点**：代码规范，使用了 `ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);` 优化输入输出，提高效率。

### 重点代码
#### 作者：_luouhgy_
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int cnt1;
int cnt0;
string s;
int main(){
    cin>>t;
    while(t--){
        cnt1=0,cnt0=0;
        cin>>s;
        int len=s.size();
        for(int i=0;i<len;i++){
        	if(s[i]=='0')cnt1++;
			else cnt0++;
		}
        for(int i=0;i<len;i++){
        	if(s[i]=='0'){
            	if(cnt0)
					cnt0--;
				else
					break;
			}else{
				if(cnt1)
					cnt1--;
				else
					break;
			}
		}
        cout<<cnt1+cnt0<<endl;
    }
    return 0;
}
```
**核心实现思想**：先统计字符串中 `0` 和 `1` 的数量，然后遍历字符串，若当前字符为 `0` 且还有 `1` 剩余，则 `1` 的数量减 1，否则停止遍历；若当前字符为 `1` 且还有 `0` 剩余，则 `0` 的数量减 1，否则停止遍历。最后输出剩余的 `0` 和 `1` 的数量之和。

#### 作者：IOI_official
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,z,o,c;
string s;
int main(){
	cin>>t;
	while(t--){
		c=z=o=0;
		cin>>s;
		for(int i=0;i<s.size();i++){
			if(s[i]=='0'){
				z++;
			}
			else o++;
		}
		for(int i=0;i<s.size();i++){
			if(s[i]=='0'){
				if(o>0)
					o--;
				else break;
			}
			else{
				if(z>0){
					z--;
				}
				else break;
			}
		}
		cout<<o+z<<endl;
	}
	return 0;
}
```
**核心实现思想**：与上一个题解类似，先统计 `0` 和 `1` 的数量，然后遍历字符串，尝试用相反的字符去匹配当前字符，若无法匹配则停止遍历，最后输出剩余的 `0` 和 `1` 的数量之和。

#### 作者：_Mortis_
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,sum0,sum1;
string s;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	for(cin>>T;T--;){
		sum0=sum1=0;
		cin>>s;
		for(int i=0;i<s.size();i++)
			if(s[i]=='0')sum0++;
			else sum1++;
		for(int i=0;i<s.size();i++)
			if(s[i]=='0'){
				if(sum1)sum1--;
				else break;
			}
			else{
				if(sum0)sum0--;
				else break;
			}
		cout<<sum0+sum1<<"\n";
	}
	return 0;
}
```
**核心实现思想**：同样是先统计 `0` 和 `1` 的数量，然后遍历字符串，用相反的字符匹配当前字符，无法匹配则停止遍历，最后输出剩余字符数量之和。同时使用了输入输出优化。

### 最优关键思路或技巧
- **贪心策略**：优先使用免费的交换操作，尽量让更多的字符匹配，无法匹配时再进行删除操作。
- **统计字符数量**：通过统计字符串中 `0` 和 `1` 的数量，方便后续的匹配和删除操作。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及操作代价和最优解的字符串处理问题，如给定一些字符操作（替换、插入、删除等）及其代价，求将一个字符串转换为另一个字符串的最小代价。
- 具有类似贪心策略的问题，如资源分配问题，优先使用免费或代价小的资源，以达到最优分配。

### 推荐洛谷题目
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法，通过合理排序使总等待时间最短。
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：贪心算法，将物品分组使每组价值和不超过上限，求最少分组数。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法，根据物品的单位价值选择物品，使背包总价值最大。

### 个人心得摘录与总结
- **作者：_anll_**：提到在赛时被一道橙题卡得痛不欲生，说明贪心算法的题目可能在比赛中具有一定难度，需要熟练掌握和灵活运用。
总结：贪心算法的题目在比赛中可能有挑战，需要加强练习，提高对贪心策略的敏感度和运用能力。 

---
处理用时：37.23秒
# 题目信息

# Sending Messages

## 题目描述

Stepan是一个busy的人。今天，他需要在 $m_1,m_2,\dots m_n$ 时刻发送 $n$ 条信息。很惨的是，到 $0$ 时刻，他的手机只剩 $f$ 个单位电量。此时手机已开机。

手机每开机一时刻就会损失 $a$ 个单位电量。此外，Stepan可以随时关闭手机，稍后再开机，每次共消耗 $b$ 个单位的能量。开关机不花费任何时间，这样就可以在 $x$ 时刻打开它，同时发送信息，反之，在 $x$ 时刻发送信息同时关闭手机也是可以的。

如果在任何时候电量降至 $0$ 以下，则手机自动关机，无法发送消息。Stepan想知道是否可以在不给手机充电的情况下发送所有信息。

## 样例 #1

### 输入

```
6
1 3 1 5
3
7 21 1 3
4 6 10 13 17 20 26
5 10 1 2
1 2 3 4 5
1 1000000000 1000000000 1000000000
1000000000
3 11 9 6
6 8 10
12 621526648 2585904 3566299
51789 61859 71998 73401 247675 298086 606959 663464 735972 806043 806459 919683```

### 输出

```
NO
YES
YES
NO
NO
YES```

# AI分析结果

【题目内容】
# 发送消息

## 题目描述
斯特潘是一个忙碌的人。今天，他需要在 $m_1,m_2,\dots m_n$ 时刻发送 $n$ 条信息。糟糕的是，到 $0$ 时刻时，他的手机仅剩下 $f$ 个单位的电量，且此时手机处于开机状态。

手机每开机一个时刻就会消耗 $a$ 个单位的电量。此外，斯特潘可以随时关闭手机，之后再开机，每次开关机共消耗 $b$ 个单位的电量。开关机不花费任何时间，也就是说可以在 $x$ 时刻打开手机并同时发送信息，反之，在 $x$ 时刻发送信息的同时关闭手机也是可行的。

如果在任何时刻电量降至 $0$ 以下，手机将自动关机，无法发送消息。斯特潘想知道在不给手机充电的情况下是否能够发送所有信息。

## 样例 #1

### 输入
```
6
1 3 1 5
3
7 21 1 3
4 6 10 13 17 20 26
5 10 1 2
1 2 3 4 5
1 1000000000 1000000000 1000000000
1000000000
3 11 9 6
6 8 10
12 621526648 2585904 3566299
51789 61859 71998 73401 247675 298086 606959 663464 735972 806043 806459 919683
```

### 输出
```
NO
YES
YES
NO
NO
YES
```

【算法分类】
贪心

【综合分析与结论】
这些题解主要围绕斯特潘发送消息时的手机电量管理问题展开。核心思路是在相邻消息发送时刻，比较一直开机和关机再开机两种方式的耗电量，选择耗电量少的方式，以此来判断是否能在给定电量下发送完所有消息。
- **思路对比**：大部分题解采用贪心策略，直接比较两种方式的耗电量，累加后与初始电量比较；少数题解使用动态规划，通过状态转移方程计算打完每个电话后最少需要的电量。
- **算法要点**：贪心算法要点在于每次都选择当前最优的耗电方式；动态规划则是通过定义状态和状态转移方程来求解最少耗电量。
- **解决难点**：主要难点在于准确计算相邻时刻的时间间隔以及对应的耗电量，同时要注意电量不能小于等于 0 的条件限制。

【所选的题解】
- **tbdsh（4星）**：
  - **关键亮点**：思路清晰，代码简洁，对题目的分析和实现都很到位，时间复杂度和空间复杂度分析准确。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;
const int MAXN = 2e5 + 5;
int n, f, a, b, m[MAXN];
void Solve(){
  cin >> n >> f >> a >> b;
  m[0] = 0;
  for (int i = 1; i <= n; i++){
    cin >> m[i];
  }
  int cnt = 0;
  for (int i = 1; i <= n; i++){
    cnt += min((m[i] - m[i - 1]) * a, b);
  }
  cout << (cnt < f ? "YES\n" : "NO\n");
}
signed main(){
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int t;
  cin >> t;
  while (t--){
    Solve();
  }
  return 0;
}
```
  - **核心实现思想**：先读取输入数据，将 $m[0]$ 初始化为 0，然后遍历每个消息发送时刻，计算相邻时刻的时间间隔，比较一直开机和关机再开机的耗电量，取最小值累加到 $cnt$ 中，最后判断 $cnt$ 是否小于初始电量 $f$，输出结果。

- **飘然归隐（4星）**：
  - **关键亮点**：代码简洁易懂，通过分段考虑，直接选择相邻时间点间耗电少的方式，实现了贪心策略。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int t;
int main()
{
	cin>>t;
	while(t--)
	{
		ll n,f,a,b;
		ll temp=0;
		cin>>n>>f>>a>>b;
		ll l=0,r=0;
		for(ll i=0;i<n;i++)
		{
			cin>>r;
			temp+=min((r-l)*a,b);
			l=r;
		}
		if(temp<f)
		{
			cout<<"YES"<<endl;
		}
		else
		{
			cout<<"NO"<<endl;
		}
	}
	return 0;
 } 
```
  - **核心实现思想**：通过循环处理每组数据，使用 $l$ 和 $r$ 记录相邻的消息发送时刻，计算时间间隔，选择耗电少的方式累加到 $temp$ 中，最后比较 $temp$ 和初始电量 $f$ 输出结果。

- **Eternity_Yoke（4星）**：
  - **关键亮点**：明确指出贪心思路，代码中对可能爆 int 的情况进行了处理，并且在循环中及时判断电量是否小于等于 0，避免不必要的计算。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5;
int t,n,f,a,b,d,bj;
int m[N];
int main()
{	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--)
	{	cin>>n>>f>>a>>b;
		for(int i=1;i<=n;i++)
		cin>>m[i];
		bj=0;
		for(int i=1;i<=n;i++)
		{	d=m[i]-m[i-1];
			if(1ll*d*a<=b)f-=d*a;
			else f-=b;
			if(f<=0)
			{	bj=1;
				break;
			}
		}
		if(bj==1)cout<<"NO"<<endl;
		else cout<<"YES"<<endl;
	}
	return 0;
}
```
  - **核心实现思想**：读取输入数据后，通过循环遍历每个消息发送时刻，计算相邻时刻的时间间隔，选择耗电少的方式从初始电量 $f$ 中扣除，若电量小于等于 0 则标记 $bj$ 为 1 并跳出循环，最后根据 $bj$ 的值输出结果。

【最优关键思路或技巧】
- **贪心策略**：在相邻消息发送时刻，比较一直开机和关机再开机两种方式的耗电量，选择耗电量少的方式，这是解决本题的核心思路。
- **电量判断**：在计算过程中，及时判断电量是否小于等于 0，若小于等于 0 则无法发送完所有消息，可提前结束计算，避免不必要的操作。

【拓展思路】
同类型题可能会有更多的限制条件，如不同时间段的开机耗电量不同，或者增加充电的情况等。类似算法套路主要是贪心算法，在面对资源分配问题时，通过比较不同选择的代价，选择当前最优的方案。

【推荐题目】
- P1223 排队接水：通过贪心策略安排排队顺序，使平均等待时间最短。
- P1090 合并果子：利用贪心思想，每次合并最小的两堆果子，使总代价最小。
- P2240 部分背包问题：采用贪心算法，选择单位价值最高的物品装入背包，使背包内物品总价值最大。

【个人心得】
题解中未包含个人心得内容。

---
处理用时：52.40秒
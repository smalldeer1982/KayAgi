# 题目信息

# Battle Cows

## 题目描述

有 $ n $ 头奶牛参加编程比赛。奶牛 $ i $ 的 Cowdeforces 评级为 $ a_i $（奶牛们的评级全部不同）。它们最初处于 $ i $ 的位置。比赛由 $ n-1 $ 个比赛组成，规则如下所示：

- 第一场比赛是在位置 $ 1 $ 的奶牛和位置 $ 2 $ 的奶牛之间。
- 随后，每场比赛 $ i $ 在位置 $ i+1 $ 的奶牛和比赛 $ i-1 $ 的获胜者之间。
- 在每场比赛中，Cowdeforces 评级较高的奶牛获胜并进入下一场比赛。

你是奶牛 $ k $ 的主人。对你来说，赢得比赛并不重要。你希望你的奶牛在尽可能多的比赛中获胜。作为比赛组织者的熟人，你可以要求他们将你的奶牛与另一头奶牛交换一次位置，或者什么都不做。请问你的奶牛最多胜利几场？

## 说明/提示

在第一组数据中，应该什么都不做。设 $ a' $ 是原始顺序中奶牛的 Cowdeforces 评级（你的奶牛评级会加粗）。

- 最初，$ a' = [\mathbf{12}， 10， 14， 11， 8， 3] $ 。
- 你的奶牛与 Cowdeforces 评级为 $ 10 $ 的奶牛对战并获胜。现在 $ a' = [\mathbf{12}， 14， 11， 8， 3] $ 。
- 你的奶牛与 Cowdeforces 评级为 $14$ 的奶牛对战，输掉了比赛。

你的奶牛赢得了 $ 1 $ 场比赛。在第二组数据中，应该将奶牛交换到位置 $ 3 $ 。然后，设 $ a' $ 是交换后顺序中奶牛的 Cowdeforces 评级。

- 最初，$ a' = [7， 2， \mathbf{12}， 10， 727， 13] $ .
- Cowdeforces 评级为 $ 7 $ 的奶牛与Cowdeforces评级为 $ 2 $ 的奶牛对战并获胜。现在 $ a' = [7， \mathbf{12}， 10， 727， 13] $ .
- Cowdeforces 评级为 $ 7 $ 的奶牛与你的奶牛对战，你的奶牛获胜。$ a' = [\mathbf{12}， 10， 727， 13] $ .
- 你的奶牛与 Cowdeforces 评级为 $ 10 $ 的奶牛对战并获胜。现在 $ a' = [\mathbf{12}， 727， 13] $ .
- 你的奶牛与 Cowdeforces 评级为 $727$ 的奶牛对战，输掉了比赛。

你的奶牛赢得了 $ 2 $ 场比赛。

## 样例 #1

### 输入

```
3
6 1
12 10 14 11 8 3
6 5
7 2 727 10 12 13
2 2
1000000000 1```

### 输出

```
1
2
0```

# AI分析结果

【题目内容】
# 战斗奶牛

## 题目描述

有 $ n $ 头奶牛参加编程比赛。奶牛 $ i $ 的 Cowdeforces 评级为 $ a_i $（奶牛们的评级全部不同）。它们最初处于 $ i $ 的位置。比赛由 $ n-1 $ 个比赛组成，规则如下所示：

- 第一场比赛是在位置 $ 1 $ 的奶牛和位置 $ 2 $ 的奶牛之间。
- 随后，每场比赛 $ i $ 在位置 $ i+1 $ 的奶牛和比赛 $ i-1 $ 的获胜者之间。
- 在每场比赛中，Cowdeforces 评级较高的奶牛获胜并进入下一场比赛。

你是奶牛 $ k $ 的主人。对你来说，赢得比赛并不重要。你希望你的奶牛在尽可能多的比赛中获胜。作为比赛组织者的熟人，你可以要求他们将你的奶牛与另一头奶牛交换一次位置，或者什么都不做。请问你的奶牛最多胜利几场？

## 说明/提示

在第一组数据中，应该什么都不做。设 $ a' $ 是原始顺序中奶牛的 Cowdeforces 评级（你的奶牛评级会加粗）。

- 最初，$ a' = [\mathbf{12}， 10， 14， 11， 8， 3] $ 。
- 你的奶牛与 Cowdeforces 评级为 $ 10 $ 的奶牛对战并获胜。现在 $ a' = [\mathbf{12}， 14， 11， 8， 3] $ 。
- 你的奶牛与 Cowdeforces 评级为 $14$ 的奶牛对战，输掉了比赛。

你的奶牛赢得了 $ 1 $ 场比赛。在第二组数据中，应该将奶牛交换到位置 $ 3 $ 。然后，设 $ a' $ 是交换后顺序中奶牛的 Cowdeforces 评级。

- 最初，$ a' = [7， 2， \mathbf{12}， 10， 727， 13] $ .
- Cowdeforces 评级为 $ 7 $ 的奶牛与Cowdeforces评级为 $ 2 $ 的奶牛对战并获胜。现在 $ a' = [7， \mathbf{12}， 10， 727， 13] $ .
- Cowdeforces 评级为 $ 7 $ 的奶牛与你的奶牛对战，你的奶牛获胜。$ a' = [\mathbf{12}， 10， 727， 13] $ .
- 你的奶牛与 Cowdeforces 评级为 $ 10 $ 的奶牛对战并获胜。现在 $ a' = [\mathbf{12}， 727， 13] $ .
- 你的奶牛与 Cowdeforces 评级为 $727$ 的奶牛对战，输掉了比赛。

你的奶牛赢得了 $ 2 $ 场比赛。

## 样例 #1

### 输入

```
3
6 1
12 10 14 11 8 3
6 5
7 2 727 10 12 13
2 2
1000000000 1```

### 输出

```
1
2
0```

【算法分类】
贪心

【综合分析与结论】
这些题解的核心思路都是基于贪心策略，即要让自己的奶牛获胜场数最多，就要尽量让其前面没有比它评级高的奶牛。各题解通过不同方式找到第一个比自己奶牛评级高的奶牛位置，再根据自己奶牛的初始位置分情况讨论，计算出最大获胜场数。

算法要点：
1. 找到第一个比自己奶牛评级高的奶牛位置 $p1$。
2. 若有需要，找到 $p1$ 之后第一个比自己奶牛评级高的奶牛位置 $p2$。
3. 根据自己奶牛初始位置与 $p1$ 的关系分情况计算最大获胜场数。

解决难点：
1. 分情况讨论时，不同情况的边界条件和计算方式容易混淆，如 $p1 = 1$ 时的特殊处理。
2. 准确找到 $p1$ 和 $p2$ 的位置。

【所选题解】
- qusia_MC（4星）
  - 关键亮点：思路详细，代码注释清晰，通过通俗易懂的语言解释了打擂台的原理和解题思路。
- Harrylzh（4星）
  - 关键亮点：思路清晰，配有图示，分情况讨论明确，代码简洁。
- donnieguo（4星）
  - 关键亮点：思路详细，通过具体样例帮助理解，代码规范。

【重点代码】
```cpp
// qusia_MC的核心代码
int maxid=1;//“最靠前”的威胁
while(a[maxid]<=a[k]&&maxid<=n)maxid++;
int minid=maxid+1;//下一个威胁之前的牛
while(a[minid]<a[k]&&minid<=n)minid++;
if(k<maxid) printf("%d\n",maxid-2);
//直接换到第一位
else printf("%d\n",max(minid-maxid-1+(maxid==1?0:1),max(maxid-2,0)));
//统计两种方案的最大值
```
核心实现思想：先找到第一个比自己奶牛评级高的奶牛位置 $maxid$，再找到 $maxid$ 之后第一个比自己奶牛评级高的奶牛位置 $minid$，根据自己奶牛初始位置与 $maxid$ 的关系分情况计算最大获胜场数。

```cpp
// Harrylzh的核心代码
long long p1=1;
while(a[p1]<=a[k]&&p1<=n) p1++;
if(k<p1)
{
    printf("%lld\n",p1-2);
}
else
{
    long long p2=p1;
    while(a[p2+1]<a[k]) p2++;
    if(p1!=1) p2++;
    p2-=p1;
    printf("%lld\n",max(p2,max(p1-2,0ll)));
}
```
核心实现思想：先找到第一个比自己奶牛评级高的奶牛位置 $p1$，再找到 $p1$ 之后最后一个比自己奶牛评级小的奶牛位置 $p2$，根据自己奶牛初始位置与 $p1$ 的关系分情况计算最大获胜场数。

```cpp
// donnieguo的核心代码
int p1 = 1;
while (a[p1] <= a[k] && p1 <= n)
    p1++;
int p2 = p1 + 1;
while (a[p2] < a[k])
    p2++;
if (k < p1)
    cout << max(0, p1 - 2) << '\n';
else
    cout << max(max(p1 - 2, 0), p2 - p1 - 1 + (p1 == 1 ? 0 : 1)) << '\n';
```
核心实现思想：先找到第一个比自己奶牛评级高的奶牛位置 $p1$，再找到 $p1$ 之后第一个比自己奶牛评级高的奶牛位置 $p2$，根据自己奶牛初始位置与 $p1$ 的关系分情况计算最大获胜场数。

【最优关键思路或技巧】
1. 利用贪心思想，让自己的奶牛前面没有比它评级高的奶牛，从而获得更多获胜场数。
2. 分情况讨论，根据第一个比自己奶牛评级高的奶牛位置和自己奶牛的初始位置关系，计算最大获胜场数。

【可拓展之处】
同类型题或类似算法套路：
1. 其他打擂台形式的比赛问题，如不同规则下的淘汰赛，可根据比赛规则调整贪心策略。
2. 资源分配问题，通过合理安排资源位置，使某个目标达到最优。

【推荐题目】
1. P1090 [NOIP2004 提高组] 合并果子
2. P1223 排队接水
3. P2240 【深基12.例1】部分背包问题

【个人心得】
donnieguo：本蒟蒻 WA 了 $7$ 次才 AC ~~（我太菜了）~~。
总结：该题有一定思维难度，在实现过程中容易出错，需要仔细考虑边界条件和不同情况的处理。 

---
处理用时：50.12秒
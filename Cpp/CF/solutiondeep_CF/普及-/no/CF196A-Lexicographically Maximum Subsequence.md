# 题目信息

# Lexicographically Maximum Subsequence

## 题目描述

你现在有一个只包含小写英文字母的字符串，要求求它的最大字典序子序列。

我们把一个非空字符串s[p_{1}p_{2}...\ p_{k}]=s_{p1}s_{p2}...\ s_{pk}(1<=p_{1}<p_{2}<...<p_{k}<=|s|)叫做字符串s=s1s2…s|s|的一个子序列。

如果|x|>|y|而且x1=y1,x2=y2…X|y|=Y|y|或者存在一个数字r (r<|x|,r<|y|)满足x1=y1,x2=y2…X|y|=Y|y|并且x_{r+1}>y_{r+1}，那么字符串x=x1x2…x|x|在字典序上比字符串y=y1y2…y|y|大。在行中的字符根据他们的ASCII码进行比较

## 说明/提示

让我们看一下样例并看一看待求的子序列长什么样子(用大写粗体字母标注）

样例1:a**B**a**BBA**

样例2:abb**C**b**CC**a**C**bb**CB**aa**BA**

## 样例 #1

### 输入

```
ababba
```

### 输出

```
bbba
```

## 样例 #2

### 输入

```
abbcbccacbbcbaaba
```

### 输出

```
cccccbba
```

# AI分析结果

### 题目内容
# 字典序最大子序列

## 题目描述
你现在有一个只包含小写英文字母的字符串，要求找出它的最大字典序子序列。

我们把一个非空字符串$s[p_{1}p_{2}...p_{k}]=s_{p1}s_{p2}...s_{pk}(1\leq p_{1}<p_{2}<...<p_{k}\leq |s|)$叫做字符串$s = s1s2…s|s|$的一个子序列。

如果$|x|>|y|$而且$x1 = y1,x2 = y2…X|y| = Y|y|$，或者存在一个数字$r (r<|x|,r<|y|)$满足$x1 = y1,x2 = y2…X|y| = Y|y|$并且$x_{r + 1}>y_{r + 1}$，那么字符串$x = x1x2…x|x|$在字典序上比字符串$y = y1y2…y|y|$大。在行中的字符根据它们的ASCII码进行比较。

## 说明/提示
让我们看一下样例并看一看待求的子序列长什么样子(用大写粗体字母标注）
样例1: a**B**a**BBA**
样例2: abb**C**b**CC**a**C**bb**CB**aa**BA**

## 样例 #1
### 输入
```
ababba
```
### 输出
```
bbba
```

## 样例 #2
### 输入
```
abbcbccacbbcbaaba
```
### 输出
```
cccccbba
```

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是贪心策略，即每次选择当前位置及之后字典序最大的字符作为子序列的一部分。不同题解在实现细节上略有差异，但整体思路一致。
1. **思路**：从后往前遍历字符串，记录每个位置之后的最大字符，然后从前向后遍历，若当前字符等于其之后的最大字符，则输出该字符。
2. **算法要点**：利用倒序遍历记录后缀最大字符，正序遍历时判断并输出符合条件的字符。
3. **解决难点**：难点在于理解字典序比较规则，并通过贪心策略找到最大字典序子序列。通过倒序遍历确定每个位置后的最大字符，解决了如何选择字符以保证字典序最大的问题。

### 通用建议与扩展思路
通用建议：在实现时，注意边界条件的处理，以及代码的简洁性和可读性。对于贪心算法，要确保贪心策略的正确性。
扩展思路：此类题目可拓展到其他字符集或不同的子序列判断规则，例如考虑字符出现次数限制等。还可与其他算法结合，如动态规划优化贪心过程。

### 相似知识点洛谷题目
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
2. [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)
3. [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)

---
处理用时：23.98秒
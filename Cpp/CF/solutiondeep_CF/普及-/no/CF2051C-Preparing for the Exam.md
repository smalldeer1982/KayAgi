# 题目信息

# Preparing for the Exam

## 题目描述

Monocarp 正在为他的第一场大学考试做准备。这场考试可能会涉及到 $n$ 个不同的问题，编号从 $1$ 到 $n$。一共有 $m$ 个不同的问题列表，每个列表包含正好 $n-1$ 个不同的问题。对于每个列表 $i$，用一个整数 $a_i$ 指定唯一没有出现在第 $i$ 个列表中的问题。例如，当 $n = 4$ 且 $a_i = 3$ 时，第 $i$ 个列表里有问题 $[1, 2, 4]$。

在考试的时候，Monocarp 将会拿到其中的一个问题列表，然后老师会要求他回答列表中所有的问题。要通过考试，Monocarp 必须回答列表中所有问题。

Monocarp 已经掌握了 $k$ 个问题的答案，这些问题编号是 $q_1, q_2, \dots, q_k$。请判断对于每一个问题列表，Monocarp 是否能够通过考试。

## 说明/提示

在第一个测试用例中，Monocarp 已掌握的问题是 $[1, 3, 4]$。我们来看所有的问题列表：

- 第一个列表的问题是 $[2, 3, 4]$。Monocarp 不懂第 $2$ 个问题，所以不能通过；
- 第二个列表的问题是 $[1, 3, 4]$。Monocarp 知道这些问题，因此能通过；
- 第三个列表的问题是 $[1, 2, 4]$。Monocarp 不懂第 $2$ 个问题，所以不能通过；
- 第四个列表的问题是 $[1, 2, 3]$。Monocarp 不懂第 $2$ 个问题，所以不能通过。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
4 4 3
1 2 3 4
1 3 4
5 4 3
1 2 3 4
1 3 4
4 4 4
1 2 3 4
1 2 3 4
2 2 1
1 2
2```

### 输出

```
0100
0000
1111
10```

# AI分析结果

### 题目翻译
#### 准备考试

### 题目描述
Monocarp 正在为他的第一场大学考试做准备。这场考试可能会涉及到 $n$ 个不同的问题，编号从 $1$ 到 $n$。一共有 $m$ 个不同的问题列表，每个列表包含正好 $n - 1$ 个不同的问题。对于每个列表 $i$，用一个整数 $a_i$ 指定唯一没有出现在第 $i$ 个列表中的问题。例如，当 $n = 4$ 且 $a_i = 3$ 时，第 $i$ 个列表里有问题 $[1, 2, 4]$。

在考试的时候，Monocarp 将会拿到其中的一个问题列表，然后老师会要求他回答列表中所有的问题。要通过考试，Monocarp 必须回答列表中所有问题。

Monocarp 已经掌握了 $k$ 个问题的答案，这些问题编号是 $q_1, q_2, \dots, q_k$。请判断对于每一个问题列表，Monocarp 是否能够通过考试。

### 说明/提示
在第一个测试用例中，Monocarp 已掌握的问题是 $[1, 3, 4]$。我们来看所有的问题列表：
- 第一个列表的问题是 $[2, 3, 4]$。Monocarp 不懂第 $2$ 个问题，所以不能通过；
- 第二个列表的问题是 $[1, 3, 4]$。Monocarp 知道这些问题，因此能通过；
- 第三个列表的问题是 $[1, 2, 4]$。Monocarp 不懂第 $2$ 个问题，所以不能通过；
- 第四个列表的问题是 $[1, 2, 3]$。Monocarp 不懂第 $2$ 个问题，所以不能通过。

### 样例 #1
#### 输入
```
4
4 4 3
1 2 3 4
1 3 4
5 4 3
1 2 3 4
1 3 4
4 4 4
1 2 3 4
1 2 3 4
2 2 1
1 2
2
```
#### 输出
```
0100
0000
1111
10
```

### 算法分类
无算法分类

### 综合分析与结论
这些题解的核心思路都是分类讨论，根据 Monocarp 掌握的问题数量 $k$ 与总问题数量 $n$ 的关系来判断是否能通过每个问题列表的考试。
- **思路**：主要分为三种情况，$k < n - 1$ 时无法通过任何考试；$k = n$ 时能通过所有考试；$k = n - 1$ 时需找出不会的那道题，若问题列表中恰好不包含这道题则能通过，否则不能通过。
- **算法要点**：大多使用数组或 map 来标记已知答案的问题，方便后续判断。
- **解决难点**：关键在于准确找出 Monocarp 不会的那道题，以及对不同情况的分类处理。

### 高评分题解
- **OIerWu_829（4星）**
    - **关键亮点**：思路清晰，代码结构简洁，对不同情况的分类讨论明确，且提醒了多测清空映射的细节。
    - **个人心得**：赛时调了半天才 AC，感谢 @[ZMQ_Ink6556](/user/1125291) 大佬的指导。
- **JimmyQ（4星）**
    - **关键亮点**：思路简洁明了，代码实现规范，时间复杂度分析清晰。
- **jubaoyi2011（4星）**
    - **关键亮点**：对三种情况的分类讨论有详细的代码示例，逻辑清晰，代码可读性高。

### 重点代码
#### OIerWu_829 的核心代码
```cpp
#include <iostream>
#include <map>
using namespace std;

const int N = 3e5 + 5;

int a[N], q[N];
map<int, bool> vis;

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        vis.clear();
        int n, m, k;
        cin >> n >> m >> k;
        for (int i = 1; i <= m; i++)
            cin >> a[i];
        for (int i = 1; i <= k; i++)
        {
            cin >> q[i];
            vis[q[i]] = true;
        }
        if (k < n - 1)
        {
            for (int i = 1; i <= m; i++)
                cout << "0";
        }
        else if (k == n)
        {
            for (int i = 1; i <= m; i++)
                cout << "1";
        }
        else if (k == n - 1)
        {
            for (int i = 1; i <= m; i++)
            {
                if (!vis[a[i]]) cout << "1";
                else cout << "0";
            }
        }
        cout << "\n";
    }
    return 0;
}
```
**核心实现思想**：用 map 标记已知答案的问题，根据 $k$ 与 $n$ 的关系分类讨论，输出每个问题列表是否能通过的结果。

### 最优关键思路或技巧
- **分类讨论**：根据掌握的问题数量与总问题数量的关系进行分类讨论，简化问题求解。
- **标记法**：使用数组或 map 标记已知答案的问题，方便快速判断。

### 拓展思路
同类型题可能会改变问题列表的构成方式，或者增加更多的条件限制，但核心思路仍然是根据已知信息判断是否能满足要求。类似算法套路可用于解决一些根据条件判断可行性的问题，如判断是否能完成任务、是否能满足某种规则等。

### 推荐洛谷题目
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
- [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)

---
处理用时：35.00秒
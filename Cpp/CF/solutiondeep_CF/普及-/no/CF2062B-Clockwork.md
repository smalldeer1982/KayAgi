# 题目信息

# Clockwork

## 题目描述

你有一排 $n$ 个计时钟，其中第 $i$ 个时钟的初始时间为 $a_i$。每秒中，以下事件按顺序发生：

- 每个时钟的时间减少 $1$。如果任意时钟的时间变为 $0$，你将立即失败。
- 你可以选择移动到相邻的时钟或停留在当前时钟。
- 你可以将当前所在时钟的时间重置为其初始值 $a_i$。

注意上述事件按顺序执行。如果某个时钟的时间在某一秒变为 $0$，即使你可以在该秒移动到这个时钟并重置其时间，你仍会失败。

你可以从任意时钟开始。请判断是否能够无限持续这个过程而不失败。

## 说明/提示

第一个测试用例中，你可以在两个时钟之间来回移动并反复重置它们的时间。

第三个测试用例中，假设你从时钟 $1$ 开始并采用以下策略：

初始时 $a = [4, 10, 5]$：
1. $a$ 变为 $[3, 9, 4]$。你移动到时钟 $2$ 并重置其时间，得到 $a = [3, 10, 4]$。
2. $a$ 变为 $[2, 9, 3]$。你移动到时钟 $3$ 并重置其时间，得到 $a = [2, 9, 5]$。
3. $a$ 变为 $[1, 8, 4]$。你移动到时钟 $2$ 并重置其时间，得到 $a = [1, 10, 4]$。
4. $a$ 变为 $[0, 9, 3]$。你试图移动到时钟 $1$，但由于 $a_1$ 变为 $0$ 而失败。

可以证明不存在其他策略能够无限持续该过程。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
2
4 10
2
2 2
3
4 10 5
3
5 3 5
5
12 13 25 17 30```

### 输出

```
YES
NO
NO
YES
YES```

# AI分析结果

【题目内容】
你有一排 $n$ 个计时钟，其中第 $i$ 个时钟的初始时间为 $a_i$。每秒中，以下事件按顺序发生：

- 每个时钟的时间减少 $1$。如果任意时钟的时间变为 $0$，你将立即失败。
- 你可以选择移动到相邻的时钟或停留在当前时钟。
- 你可以将当前所在时钟的时间重置为其初始值 $a_i$。

注意上述事件按顺序执行。如果某个时钟的时间在某一秒变为 $0$，即使你可以在该秒移动到这个时钟并重置其时间，你仍会失败。

你可以从任意时钟开始。请判断是否能够无限持续这个过程而不失败。

### 说明/提示
第一个测试用例中，你可以在两个时钟之间来回移动并反复重置它们的时间。

第三个测试用例中，假设你从时钟 $1$ 开始并采用以下策略：

初始时 $a = [4, 10, 5]$：
1. $a$ 变为 $[3, 9, 4]$。你移动到时钟 $2$ 并重置其时间，得到 $a = [3, 10, 4]$。
2. $a$ 变为 $[2, 9, 3]$。你移动到时钟 $3$ 并重置其时间，得到 $a = [2, 9, 5]$。
3. $a$ 变为 $[1, 8, 4]$。你移动到时钟 $2$ 并重置其时间，得到 $a = [1, 10, 4]$。
4. $a$ 变为 $[0, 9, 3]$。你试图移动到时钟 $1$，但由于 $a_1$ 变为 $0$ 而失败。

可以证明不存在其他策略能够无限持续该过程。

### 样例 #1
#### 输入
```
5
2
4 10
2
2 2
3
4 10 5
3
5 3 5
5
12 13 25 17 30
```

#### 输出
```
YES
NO
NO
YES
YES
```

【算法分类】
数学

【综合分析与结论】
这些题解的核心思路都是通过数学分析来判断是否能无限持续过程而不失败。对于每个时钟，需要考虑其时间是否足够遍历并重置在它左边和右边的时钟，即判断 $a_i$ 是否大于 $2\times\max\{i - 1, n - i\}$。如果所有时钟都满足这个条件，则可以无限持续，否则会失败。

各题解的算法要点和难点基本一致，主要是思路的阐述和代码实现的细节略有不同。

【所选的题解】
- 作者：BinaryPotatoTree (4星)
  - 关键亮点：思路分析清晰，通过反证法说明了为什么要满足 $a_i>2\times\max\{i - 1, n - i\}$ 这个条件，逻辑严谨。
- 作者：Lovely_Elaina (4星)
  - 关键亮点：代码使用了 `ios::sync_with_stdio(0); cin.tie(0);` 进行输入输出优化，提高了程序效率，并且对思路的解释较为详细。
- 作者：zjinyi (4星)
  - 关键亮点：对 $i - 1$ 和 $n - i$ 的含义解释明确，代码简洁易懂。

【重点代码】
```cpp
// BinaryPotatoTree 的核心代码
for(int i = 1; i <= n; i++){
    if(a[i] <= 2*max(i - 1, n - i)){
        // 不符合要求，会失败
        // 进行相应处理，如标记或输出 NO
    }
}
```
核心实现思想：遍历每个时钟，判断其初始时间是否小于等于从该时钟到两端再返回所需的最大时间，如果是则不符合要求。

```cpp
// Lovely_Elaina 的核心代码
while(T--){
    cin >> n;
    bool b = true;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        if(a[i] <= 2*max(i - 1, n - i))
            b = false;
    }
    if(b) cout << "YES" << endl;
    else cout << "NO" << endl;
}
```
核心实现思想：对于每组数据，先读取时钟数量和每个时钟的初始时间，然后判断每个时钟是否满足条件，最后根据标记输出结果。

```cpp
// zjinyi 的核心代码
while (t--) {
    long long n;
    cin >> n;
    for (long long i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    bool flag = true;
    for (long long i = 1; i <= n; ++i) {
        if (a[i] <= 2 * max(i - 1, n - i)) {
            flag = false;
        }
    }
    if (flag == true) {
        cout << "YES\n";
    } else {
        cout << "NO\n";
    }
}
```
核心实现思想：多组数据处理，读取每组数据后，判断每个时钟是否满足条件，根据标记输出结果。

【关键思路或技巧】
- 数学分析：通过分析每个时钟到两端再返回所需的时间，建立数学模型来判断是否能无限持续过程。
- 反证法：通过反证法说明如果不满足条件，必然会有时钟时间变为 $0$，从而失败。

【可拓展之处】
同类型题可能会改变时钟的排列方式（如环形排列）、增加操作的复杂度（如每次操作有不同的代价）等。类似算法套路是通过数学分析建立模型，找到问题的关键条件进行判断。

【推荐题目】
- P1003 铺地毯
- P1047 校门外的树
- P1055 ISBN 号码

【个人心得】
- 作者：Lovely_Elaina：“笑嘻了，赛时被卡了一下。比 C 难解释但比 C 简单。建议根据结论自行模拟样例，去思考反证。”
总结：在比赛时遇到了困难，建议通过模拟样例和思考反证来理解问题。 

---
处理用时：39.61秒
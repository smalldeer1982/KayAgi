# 题目信息

# Subsequence Update

## 题目描述

在小约翰向阿姨借了几百次膨胀螺丝后，她最终决定来收回那些没用过的螺丝。

但由于膨胀螺丝是家居设计的重要组成部分，小约翰决定把它们藏在最难以触及的地方--环保木皮下面。

给你一个整数序列 $a_1, a_2, \ldots, a_n$ 和其中一段 $[l,r]$ ( $1 \le l \le r \le n$ )。

您必须对该序列执行以下操作次。

- 选择序列 $a$ 的任意子序列 $^{\text{∗}}$ ，并将其倒转。注意，子序列不必是连续的。

形式上，选择任意数量的索引 $i_1,i_2,\ldots,i_k$ ，使得 $ 1 \le i_1 \lt i_2 \lt \ldots \lt i_k \le n $ 。然后，将所有 $1 \le x \le k$ 的 第 $i_x$ 个元素同时改为第 $i_{k-x+1}$ 个元素的原始值。

求操作后 $a_l+a_{l+1}+\ldots+a_{r-1}+a_r$ 的最小值。

$^{\text{∗}}$ 如果 $b$ 可以从 $a$ 中删除任意位置上的几个（可能是零个或全部）元素而得到，则序列 $b$ 是序列 $a$ 的子序列。

## 说明/提示

在第二个测试用例中，数组为 $a=[1,2,3]$ ，段为 $[2,3]$ 。

选择子序列 $a_1,a_3$ 并将其反转后，序列变为 $[3,2,1]$ 。然后，和 $a_2+a_3$ 变为 $3$ 。由此可见，和的最小可能值为 $3$ 。

## 样例 #1

### 输入

```
6
2 1 1
2 1
3 2 3
1 2 3
3 1 3
3 1 2
4 2 3
1 2 2 2
5 2 5
3 3 2 3 5
6 1 3
3 6 6 4 3 2```

### 输出

```
1
3
6
3
11
8```

# AI分析结果

### 题目翻译
在小约翰向阿姨借了几百次膨胀螺丝后，她最终决定来收回那些没用过的螺丝。

但由于膨胀螺丝是家居设计的重要组成部分，小约翰决定把它们藏在最难以触及的地方 -- 环保木皮下面。

给你一个整数序列 $a_1, a_2, \ldots, a_n$ 和其中一段 $[l,r]$ ( $1 \le l \le r \le n$ )。

您必须对该序列执行以下操作次。

- 选择序列 $a$ 的任意子序列 $^{\text{∗}}$ ，并将其倒转。注意，子序列不必是连续的。

形式上，选择任意数量的索引 $i_1,i_2,\ldots,i_k$ ，使得 $ 1 \le i_1 \lt i_2 \lt \ldots \lt i_k \le n $ 。然后，将所有 $1 \le x \le k$ 的 第 $i_x$ 个元素同时改为第 $i_{k - x + 1}$ 个元素的原始值。

求操作后 $a_l + a_{l + 1} + \ldots + a_{r - 1} + a_r$ 的最小值。

$^{\text{∗}}$ 如果 $b$ 可以从 $a$ 中删除任意位置上的几个（可能是零个或全部）元素而得到，则序列 $b$ 是序列 $a$ 的子序列。

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是利用贪心算法，即要使区间 $[l, r]$ 的和最小，需要将区间内较大的数与区间外较小的数进行交换，且只能选择区间左侧或右侧的数进行交换，不能同时选两侧。

不同题解的主要区别在于实现方式，有的通过排序直接选取最小的数，有的使用优先队列来维护最小的数，还有的通过遍历比较进行替换。

### 所选题解
- **作者：special_y (赞：9)，4星**
    - **关键亮点**：思路清晰，代码简洁，通过排序直接计算两种情况下的最小值。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int t, l, r, n; ll a[100005], b[100005];
int main()
{
    cin.tie(0); cout.tie(0);
    cin >> t;
    for(int i = 1; i <= t; ++i)
    {
       cin >> n >> l >> r;
       memset(a, 0, sizeof(a));
       memset(b, 0, sizeof(b));
       for(int j = 1; j <= n; ++j)
       {
            cin >> a[j];
            b[j] = a[j];
       }
        sort(a+1, a+r+1);
        sort(b+l, b+n+1);
        ll sum1 = 0, sum2 = 0;
        for(int k = 1; k <= r - l + 1; ++k) sum1 += a[k];
        for(int k = l; k <= r; ++k) sum2 += b[k];
        ll minn = min(sum1, sum2);
        cout << minn << endl;
    }
    return 0;
}
```
**核心实现思想**：复制一份数组，分别对 $[1, r]$ 和 $[l, n]$ 进行排序，然后计算 $[1, r]$ 中前 $r - l + 1$ 小的数的和以及 $[l, n]$ 中前 $r - l + 1$ 小的数的和，取两者最小值。

- **作者：ran_qwq (赞：4)，4星**
    - **关键亮点**：思路简洁明了，直接指出两种情况取最小值的结论。
```cpp
int n,l,r,cb,cc,a[N],b[N],c[N]; ll s1,s2;
void QwQ() {
    n=rd(),l=rd(),r=rd(),cb=cc=s1=s2=0;
    for(int i=1;i<=n;i++) a[i]=rd();
    for(int i=1;i<=r;i++) b[++cb]=a[i];
    for(int i=l;i<=n;i++) c[++cc]=a[i];
    sort(b+1,b+1+cb),sort(c+1,c+1+cc);
    for(int i=1;i<=r-l+1;i++) s1+=b[i],s2+=c[i];
    wrll(min(s1,s2),"\n");
}
```
**核心实现思想**：将 $[1, r]$ 和 $[l, n]$ 的数分别存入数组，排序后计算前 $r - l + 1$ 小的数的和，取最小值。

- **作者：Kiana_1207 (赞：1)，4星**
    - **关键亮点**：通过举例清晰地说明了只能考虑一边的数的原因。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=100010;
int T,n,l,r,minn1,minn2,a[N],b[N],c[N];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>T;
    while (T--)
    {
        minn1=minn2=0;
        cin>>n>>l>>r;
        for (int i=1;i<=n;i++)
            cin>>a[i];
        for (int i=1;i<=n;i++)
        {
            if (i<=r) b[i]=a[i];
            if (i>=l) c[i-l+1]=a[i];
        }
        sort(b+1,b+r+1);
        sort(c+1,c+n-l+2);
        for (int i=1;i<=r-l+1;i++)
        {
            minn1+=b[i];
            minn2+=c[i];
        }
        cout<<min(minn1,minn2)<<'\n';
    }
    return 0;
}
```
**核心实现思想**：分离出 $[1, r]$ 与 $[l, n]$ 两个序列，分别排序后计算前 $r - l + 1$ 小的数的和，取最小值。

### 最优关键思路或技巧
- **贪心策略**：明确只能选择区间左侧或右侧的数与区间内的数交换，以达到使区间和最小的目的。
- **排序**：通过排序可以方便地找到较小的数，从而实现贪心选择。

### 拓展思路
同类型题可能会有更多的操作限制或条件变化，但核心思路仍然是贪心选择。类似的算法套路包括在满足一定条件下，通过比较不同的选择来达到最优解。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：通过贪心策略合并果子，使总代价最小。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：合理安排排队顺序，使平均等待时间最短。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：在一定容量限制下，选择物品使总价值最大。

### 个人心得
部分题解提到要注意读题，只能翻转一次，以及注意多测清空、循环边界等细节问题，避免出现错误。同时，对于复杂的问题，可以通过举例来帮助理解和分析。 

---
处理用时：44.51秒
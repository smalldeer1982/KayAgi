# 题目信息

# Variety is Discouraged

## 题目描述

定义任意数组 $b$ 的分数为 $b$ 的长度减去其中不同元素的数量。例如：
- 数组 $[1, 2, 2, 4]$ 的分数为 $1$，因为它长度为 $4$ 且只有 $3$ 个不同元素（$1$、$2$、$4$）。
- 数组 $[1, 1, 1]$ 的分数为 $2$，因为它长度为 $3$ 且只有 $1$ 个不同元素（$1$）。
- 空数组的分数为 $0$。

给定一个数组 $a$。你需要最多一次移除一个非空的连续子数组。

更正式地说，你最多可以执行以下操作一次：
- 选择两个整数 $l$ 和 $r$（$1 \le l \le r \le n$）
- 从 $a$ 中删除连续子数组 $[a_l,\ldots,a_r]$（即将 $a$ 替换为 $[a_1,\ldots,a_{l - 1},a_{r + 1},\ldots,a_n]$）

请输出一个操作，使得操作后 $a$ 的分数最大。若存在多个答案，输出能使操作后数组长度最短的任一解；若仍有多个答案，可输出任一。

## 说明/提示

第一个测试用例有两种选择：
- 不操作：数组 $[1]$ 的分数为 $1-1=0$。
- 删除 $l=1$，$r=1$ 的子数组：删除唯一元素后得到空数组，分数为 $0$。

因此最大可能分数为 $0$。但需要额外最小化数组长度，故必须输出第二种选择 $l=r=1$。注意第一种不操作的方案是错误的，因为它保留的数组长度更长。

第二个测试用例未选择任何子数组，操作后数组仍为 $[1, 1, 1, 1, 1]$。其长度为 $5$ 且有 $1$ 个不同元素，分数为 $5 - 1 = 4$。可以证明这是能最大化分数且长度最短的数组。

第三个测试用例选择删除子数组 $[2, \text{\color{red}{1,\ 3}}, 2]$，操作后数组变为 $[2, 2]$。其长度为 $2$ 且有 $1$ 个不同元素，分数为 $2 - 1 = 1$。可以证明这是能最大化分数且长度最短的数组。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
1
1
5
1 1 1 1 1
4
2 1 3 2```

### 输出

```
1 1
0
2 3```

# AI分析结果

【题目内容】
# 多样性不受鼓励

## 题目描述

定义任意数组 $b$ 的分数为 $b$ 的长度减去其中不同元素的数量。例如：
- 数组 $[1, 2, 2, 4]$ 的分数为 $1$，因为它长度为 $4$ 且只有 $3$ 个不同元素（$1$、$2$、$4$）。
- 数组 $[1, 1, 1]$ 的分数为 $2$，因为它长度为 $3$ 且只有 $1$ 个不同元素（$1$）。
- 空数组的分数为 $0$。

给定一个数组 $a$。你需要最多一次移除一个非空的连续子数组。

更正式地说，你最多可以执行以下操作一次：
- 选择两个整数 $l$ 和 $r$（$1 \le l \le r \le n$）
- 从 $a$ 中删除连续子数组 $[a_l,\ldots,a_r]$（即将 $a$ 替换为 $[a_1,\ldots,a_{l - 1},a_{r + 1},\ldots,a_n]$）

请输出一个操作，使得操作后 $a$ 的分数最大。若存在多个答案，输出能使操作后数组长度最短的任一解；若仍有多个答案，可输出任一。

## 说明/提示

第一个测试用例有两种选择：
- 不操作：数组 $[1]$ 的分数为 $1-1=0$。
- 删除 $l=1$，$r=1$ 的子数组：删除唯一元素后得到空数组，分数为 $0$。

因此最大可能分数为 $0$。但需要额外最小化数组长度，故必须输出第二种选择 $l=r=1$。注意第一种不操作的方案是错误的，因为它保留的数组长度更长。

第二个测试用例未选择任何子数组，操作后数组仍为 $[1, 1, 1, 1, 1]$。其长度为 $5$ 且有 $1$ 个不同元素，分数为 $5 - 1 = 4$。可以证明这是能最大化分数且长度最短的数组。

第三个测试用例选择删除子数组 $[2, \text{\color{red}{1,\ 3}}, 2]$，操作后数组变为 $[2, 2]$。其长度为 $2$ 且有 $1$ 个不同元素，分数为 $2 - 1 = 1$。可以证明这是能最大化分数且长度最短的数组。

## 样例 #1

### 输入
```
3
1
1
5
1 1 1 1 1
4
2 1 3 2
```

### 输出
```
1 1
0
2 3
```

【算法分类】
贪心

【综合分析与结论】
这些题解的核心思路都是一致的，即根据得分计算公式分析得出删除只出现一次的元素不会降低得分，而删除出现两次及以上的元素会使得分降低，同时为满足操作后数组长度最短的要求，需要找出最长的连续只出现一次的元素的子序列并删除。

各题解的算法要点在于先统计每个元素的出现次数，再遍历数组找出最长的连续只出现一次的元素的子序列。解决的难点在于准确判断元素的出现次数，并正确找出最长的连续子序列。

【所选的题解】
- 作者：Starlit_Night (赞：2)，4星。关键亮点：思路清晰，代码简洁易懂，使用 `map` 统计元素出现次数，通过循环找出最长连续子序列。
- 作者：feng_0108 (赞：0)，4星。关键亮点：详细分析了删除不同元素对得分的影响，使用 `unordered_map` 统计元素出现次数，结合动态规划思想找出最长连续子序列。
- 作者：Redshift_Shine (赞：0)，4星。关键亮点：代码结构清晰，将初始化和核心逻辑分开，使用数组作为桶统计元素出现次数，通过双指针找出最长连续子序列。

【重点代码】
1. **作者：Starlit_Night**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin>>T;
    while(T--){
        int n;
        cin>>n;
        vector<int> a(n);
        map<int,int> mp;
        for(int i=0;i<n;i++){
            cin>>a[i];
            mp[a[i]]++;
        }
        int ansl=0,maxlen=0;
        for(int i=0;i<n;i++){
            if(mp[a[i]]==1){
                int len=1;
                while(i+len<n&&mp[a[i+len]]==1){
                    len++;
                }
                if(len>maxlen){
                    maxlen=len;
                    ansl=i+1; 
                }
                i=i+len-1; 
            }
        }
        if(ansl==0) cout<<0<<"\n";
        else cout<<ansl<<" "<<ansl+maxlen-1<<"\n"; 
    }
    return 0;
}  
```
核心实现思想：先使用 `map` 统计每个元素的出现次数，然后遍历数组，对于只出现一次的元素，向后扩展找出连续只出现一次的元素的长度，记录最长的长度和起始位置。

2. **作者：feng_0108**
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;

int t, n;

int a[N], dp[N];

void solve()
{
    cin >> n;
    
    unordered_map<int, int> hash;
    for(int i = 1; i <= n; i ++ ) {
        cin >> a[i];
        hash[a[i]] ++;
    }
    
    int tmp = 0, l = 0, r = 0;
    for(int i = 1; i <= n; i ++ )  // 时间复杂度O(N)
    {
        if(hash[a[i]] == 1) {
            dp[i] = dp[i - 1] + 1;
            if(dp[i] > tmp){
                tmp = max(tmp, dp[i]);
                r = i, l = i - tmp + 1;
            }
        }
        else dp[i] = 0;
    }
    
    if(!l && !r) cout << 0 << endl;
    else cout << l << ' ' << r << endl;
}

int main()
{
    cin >> t;
    while(t -- )
        solve();
    return 0;
 } 
```
核心实现思想：使用 `unordered_map` 统计元素出现次数，利用动态规划思想，对于只出现一次的元素，更新 `dp` 数组记录连续长度，同时记录最长连续子序列的起始和结束位置。

3. **作者：Redshift_Shine**
```c++
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 2e5 + 10;
int n, a[N], l, r, buc[N];
void init_local()
{
    scanf("%d", &n);
    memset(buc + 1, 0, n << 2);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", a + i);
        buc[a[i]]++;
    }
}
void run()
{
    l = 0;
    r = -1;
    for (int i = 1, j; i <= n; i++)
    {
        j = i;
        while (j <= n and buc[a[j]] == 1)
            j++;
        j--;
        if (j - i > r - l)
            l = i, r = j;
        if (i <= j)
            i = j;
    }
    if (!l)
        puts("0");
    else
        printf("%d %d\n", l, r);
}
int main()
{
    int T = 1;
    scanf("%d", &T);
    while (T--)
    {
        init_local();
        run();
    }
}
```
核心实现思想：使用数组 `buc` 作为桶统计元素出现次数，通过双指针 `i` 和 `j` 找出最长连续只出现一次的元素的子序列，记录起始和结束位置。

【最优关键思路或技巧】
- 使用哈希表（如 `map`、`unordered_map`）或数组（桶）统计元素的出现次数。
- 通过遍历数组，利用双指针或动态规划思想找出最长的连续只出现一次的元素的子序列。

【拓展思路】
同类型题目可能会有不同的约束条件或操作方式，但核心思路都是根据某种规则对数组进行操作以达到最优结果。类似算法套路包括先分析操作对结果的影响，然后找出满足条件的最优子结构。

【推荐题目】
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：考察对数组的操作和区间处理。
2. [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)：涉及数组的输入输出和简单操作。
3. [P1980 计数问题](https://www.luogu.com.cn/problem/P1980)：需要对数字进行统计和分析。

【个人心得】
题解中未包含个人心得内容。

---
处理用时：53.92秒
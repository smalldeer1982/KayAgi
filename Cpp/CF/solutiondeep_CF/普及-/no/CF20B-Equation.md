# 题目信息

# Equation

## 题目描述

### 题目大意

给定 $A, B, C$，求方程 $Ax^2+Bx+C=0$ 的解的个数，如果有无穷个解，则输出 `-1`。

## 样例 #1

### 输入

```
1 -5 6
```

### 输出

```
2
2.0000000000
3.0000000000```

# AI分析结果

### 题目内容
# 方程

## 题目描述

### 题目大意
给定$A$、$B$、$C$，求方程$Ax^2 + Bx + C = 0$的解的个数，如果有无穷个解，则输出`-1`。

## 样例 #1
### 输入
```
1 -5 6
```
### 输出
```
2
2.0000000000
3.0000000000
```

### 算法分类
数学

### 题解综合分析与结论
这些题解的核心思路都是基于对一元二次方程性质的理解，通过分类讨论$a$、$b$、$c$的取值情况来求解方程。
1. **思路**：首先考虑$a = 0$的特殊情况，此时方程退化为一元一次方程或常数方程，再分$b = 0$且$c = 0$（无数解）、$b = 0$且$c \neq 0$（无解）、$b \neq 0$（一个解$x = -\frac{c}{b}$）三种情况讨论。当$a \neq 0$时，方程为一元二次方程，通过判别式$\Delta = b^2 - 4ac$判断解的个数，$\Delta > 0$时有两个不同解，$\Delta = 0$时有一个解，$\Delta < 0$时无解，并利用求根公式$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$计算解。
2. **算法要点**：准确进行分类讨论，根据不同情况正确运用一元一次方程和一元二次方程的求解方法，注意输出格式和精度控制。
3. **解决难点**：全面考虑各种特殊情况，如$a = 0$时$b$、$c$不同取值的组合，避免遗漏；处理好判别式与解的关系以及解的输出格式。

### 所选的题解
- **作者：云浅知处 (5星)**
    - **关键亮点**：思路清晰，先详细推导一元二次方程求根公式及判别式，帮助读者理解原理，再进行分类讨论解题，代码注释详细，对特殊情况的处理说明清晰。
    - **个人心得**：作者作为初一MOer分享解题思路，体现了学习的热情和积极性。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    long double a,b,c,delta,x1,x2;
    cin>>a>>b>>c;

    if(a==0&&b==0&&c==0){
        cout<<-1;
        return 0;
    }
    if(a==0&&b==0&&c!=0){
        cout<<0;
        return 0;
    }
    if(a==0&&b!=0){
        cout<<"1\n"<<fixed<<setprecision(10)<<-c/b;
        return 0;
    }
    delta=b*b-4*a*c;
    if(delta<0){
        cout<<0;
        return 0;
    }
    if(delta==0){
        cout<<"1\n"<<fixed<<setprecision(10)<<-b/(2*a);
        return 0;
    }
    if(delta>0){
        cout<<"2\n";
        x1=(-b+sqrt(b*b-4*a*c))/(2*a);
        x2=(-b-sqrt(b*b-4*a*c))/(2*a);
        cout<<fixed<<setprecision(10)<<min(x1,x2)<<endl<<fixed<<setprecision(10)<<max(x1,x2);
        return 0;
    }

    return 0;
}
```
    - **核心实现思想**：先通过`if`语句对$a$、$b$、$c$的特殊取值情况进行判断并输出结果，对于一元二次方程的情况，计算判别式`delta`，根据其值判断解的个数并利用求根公式计算解，按要求格式输出。
- **作者：cherubim (4星)**
    - **关键亮点**：采用配方法解题，与多数使用求根公式的方法不同，有独特性；对特殊情况考虑细致，如根为$0$可能输出为$-0$的情况进行了处理。
    - **个人心得**：提到配方法解题思路，以及在调试中遇到根为$-0$的问题。
    - **重点代码**：
```c
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
double A,B,C;
double b,c,tc,add,r,x_1,x_2;
signed main()
{
    cin>>A>>B>>C;

    if(A==0&&B==0&&C==0){
        printf("%d\n",-1);
        return 0;
    }
    else if(A==0&&B==0&&C!=0){
        printf("%d\n",0);
        return 0;
    }
    else if(A==0&&B!=0){
        double ans=-C/B;
        if(ans==-0.0000000000) ans=0.0000000000;
        printf("%d\n%.10lf\n",1,ans);
        return 0;
    }
    else if(A==0&&C==0){
        printf("1\n0.0000000000");
        return 0;
    }
    else if(A!=0&&B==0&&C==0){
        printf("1\n0.0000000000");
        return 0;
    }
    double derta=B*B-4*A*C;
    if(derta>0){
        b=B/A;
        c=C/A;
        tc=b/2;
        add=tc*tc;
        r=-c+add;
        x_1=sqrt(r)-tc;
        x_2=-sqrt(r)-tc;
        if(x_1<=x_2)
            printf("%d\n%.10lf\n%.10lf\n",2,x_1,x_2);
        else if(x_1>x_2)
            printf("%d\n%.10lf\n%.10lf\n",2,x_2,x_1);
    }
    else if(derta==0){
        b=B/A;
        c=C/A;
        tc=b/2;
        add=tc*tc;
        r=-c+add;
        x_1=sqrt(r)-tc;
        x_2=-sqrt(r)-tc;
        if(x_1==-0.0000000000) printf("0.0000000000");
        else printf("%d\n%.10lf",1,x_1);
    }
    else if(derta<0) printf("%d\n",0);
    return 0;
}
```
    - **核心实现思想**：同样先对特殊情况进行判断输出，对于一般的一元二次方程情况，通过配方法将方程转化为可开方形式，计算出根并按要求输出，同时处理了可能出现的$-0$问题。
- **作者：Eason_AC (4星)**
    - **关键亮点**：详细推导求根公式，帮助读者理解原理，对$a = 0$和$a \neq 0$的情况分类清晰，代码简洁明了，对数据范围可能导致的类型溢出问题有处理。
    - **个人心得**：详细讲解求根公式推导过程，强调题目中$a$可能为$0$需要分类讨论。
    - **重点代码**：
```cpp
long long a, b, c;

int main() {
    scanf("%lld%lld%lld", &a, &b, &c);
    long long delta = b * b - 4 * a * c;
    if(!a &&!b &&!c) return printf("-1"), 0;
    if(!a &&!b) return printf("0"), 0;
    if(!a) return printf("1\n%.8lf", -c * 1.0 / b), 0;
    if(delta > 0)
        printf("2\n%.8lf\n%.8lf", min((-b - sqrt(delta)) * 1.0 / (a * 2.0), (-b + sqrt(delta)) * 1.0 / (a * 2.0)), max((-b - sqrt(delta)) * 1.0 / (a * 2.0), (-b + sqrt(delta)) * 1.0 / (a * 2.0)));
    else if(delta == 0)
        printf("1\n%.8lf", -b / (a * 2.0));
    else
        printf("0");
    return 0;
}
```
    - **核心实现思想**：先读入系数，计算判别式，通过`if`语句对不同情况进行判断，根据判别式的值输出解的个数和具体解，注意了类型转换和精度控制。

### 最优关键思路或技巧
1. **全面分类讨论**：对$a$、$b$、$c$的各种取值组合进行全面细致的分类，确保不遗漏任何特殊情况。
2. **理解方程本质**：深入理解一元一次方程和一元二次方程的性质、求根公式及判别式的原理，才能正确解题。
3. **代码实现细节**：注意数据类型的选择（如考虑数据范围防止溢出）、输出格式的控制（精度等）以及特殊值（如$-0$）的处理。

### 可拓展之处
同类型题通常围绕一元二次方程、一元一次方程的求解及相关性质展开，类似算法套路为根据方程类型特点，通过分类讨论和运用相应公式求解。例如，可能会在系数的取值范围、方程的形式（如分式方程转化为整式方程后类似求解）等方面进行变化。

### 洛谷相似题目
1. **P1024 [NOIP2001 提高组] 一元三次方程求解**：通过二分法求解一元三次方程的根，同样涉及方程求解及对解的处理。
2. **P5709 [深基2.习6] Apples Prologue**：简单的数学运算和条件判断，与本题分类讨论思想类似。
3. **P1161 开灯**：利用数学规律和简单的逻辑判断解决问题，锻炼数学思维，与本题都需要清晰的逻辑分析。 

---
处理用时：65.52秒
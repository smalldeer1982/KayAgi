# 题目信息

# Perfect Permutation

## 题目描述

现有一个$1$~$n$的排列$p_1,p_2,...,p_n$。

$Nickolas$喜欢排列，他认为有一种排列是完美的。用$p_i$表示排列中的第$i$个元素，则完美的排列符合如下性质：

1. $p_{p_i}=i$

2. $p_i≠i$

现在给出$n$的值，请求出这个完美的排列。


现有一个$1$~$n$的排列$p_1,p_2,...,p_n$。

$Nickolas$喜欢排列，他认为有一种排列是完美的。用$p_i$表示排列中的第$i$个元素，则完美的排列符合如下性质：

1. $p_{p_i}=i$

2. $p_i≠i$

现在给出$n$的值，请求出这个完美的排列。

## 样例 #1

### 输入

```
1
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
2
```

### 输出

```
2 1 
```

## 样例 #3

### 输入

```
4
```

### 输出

```
2 1 4 3 
```

# AI分析结果

### 题目内容
# 完美排列

## 题目描述
现有一个1到n的排列$p_1,p_2,\cdots,p_n$ 。
$Nickolas$喜欢排列，他认为有一种排列是完美的。用$p_i$表示排列中的第$i$个元素，则完美的排列符合如下性质：
1. $p_{p_i}=i$
2. $p_i≠i$
现在给出$n$的值，请求出这个完美的排列。

## 样例 #1
### 输入
```
1
```
### 输出
```
-1
```

## 样例 #2
### 输入
```
2
```
### 输出
```
2 1 
```

## 样例 #3
### 输入
```
4
```
### 输出
```
2 1 4 3 
```

### 算法分类
构造

### 综合分析与结论
这些题解的核心思路都是先判断$n$的奇偶性，若$n$为奇数，由于要满足$p_{p_i}=i$且$p_i≠i$，必然会有一个位置无法配对，所以无解；若$n$为偶数，则存在多种构造方法来生成满足条件的排列。各题解在具体构造方式上有所不同，主要有相邻元素两两对应和倒序排列这两种常见构造思路。在代码实现上，都先进行$n$奇偶性判断，奇数输出 -1，偶数则按相应构造方式输出排列。

### 所选的题解
- **作者：Mars_Dingdang (5星)**
    - **关键亮点**：思路清晰，不仅详细分析了$n$取不同值时的情况，还给出了两种构造方法及其完整代码，对每种构造方法的描述细致。
    - **核心代码（第一种构造法）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
   int n;
	cin>>n;
	if(n%2==1)
		cout<<-1;
	else{
      for(int i=n;i>=1;i--) 
         cout<<i<<" ";
    }
	return 0;
}
```
核心实现思想：先判断$n$是否为奇数，若是则输出 -1，否则倒序输出1到$n$，即构造出满足条件的排列。
    - **核心代码（第二种构造法）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
   int n;
	cin>>n;
	if(n%2==1)
		cout<<-1;
	else{
      for(int i=1;i<=n;i+=2) 
          cout<<i+1<<" "<<i<<" ";
    }
	return 0;
}
```
核心实现思想：同样先判断$n$奇偶性，$n$为偶数时，每次循环间隔为2，依次输出相邻两数交换后的结果，构造出满足条件的排列。
- **作者：BurningEnderDragon (4星)**
    - **关键亮点**：对题意理解准确，清晰阐述了满足条件的排列需元素及其下标两两对应，进而得出$n$必须为偶数的结论，并详细给出两种解法及对应主函数代码。
    - **解法1核心代码**：
```cpp
int n;
cin>>n;
if(n&1)  {
    cout<<-1<<endl;
}
else  {
    for(int i=1;i<=n;i+=2)
    {
        cout<<i+1<<" "<<i<<" ";
    }
    cout<<endl;
}
return 0;
```
核心实现思想：判断$n$为奇数时无解输出 -1，$n$为偶数时，通过循环让相邻奇数位和偶数位元素两两对应输出。
    - **解法2核心代码**：
```cpp
int n;
cin>>n;
if(n&1)  {
    cout<<-1<<endl;
}
else  {
    for(int i=n;i>=1;--i)
    {
    	cout<<i<<" ";
	}
    cout<<endl;
}
```
核心实现思想：同样先判断$n$奇偶性，$n$为偶数时，倒序输出1到$n$构造排列。
- **作者：agicy (4星)**
    - **关键亮点**：从简单的两个数情况入手分析，发现式子呈现对称式特点，快速得出$n$为偶数和奇数时的结论，并给出简洁代码。
    - **核心代码**：
```cpp
#include<stdio.h>
int n;
int main(void){
	scanf("%d",&n);
	if(n&1)
		puts("-1");
	else
		while(n)
			printf("%d ",n--);
	return 0;
}
```
核心实现思想：读入$n$后判断奇偶性，$n$为奇数输出 -1，$n$为偶数时倒序输出$n$到1构造排列。

### 最优关键思路或技巧
判断$n$的奇偶性是解题关键，$n$为偶数时，无论是相邻元素两两对应还是倒序排列的构造方法，本质都是利用元素两两配对来满足$p_{p_i}=i$且$p_i≠i$这两个条件。

### 可拓展之处
此类构造题通常需要根据给定条件，通过对简单情况的分析找出规律来构造满足要求的解。类似题目可能会改变限制条件或数据范围，需要灵活运用分析方法和构造技巧。

### 推荐题目
- [P1146 硬币翻转](https://www.luogu.com.cn/problem/P1146)，通过模拟硬币翻转操作，分析规律来求解，与本题分析条件找构造规律类似。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)，需要根据一定条件构造出符合要求的组合，锻炼构造和分析能力。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)，结合质数判断和回文数构造的特点来解题，与本题构造满足特定条件的数据类似。 

---
处理用时：54.86秒
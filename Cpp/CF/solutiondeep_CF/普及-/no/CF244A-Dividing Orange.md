# 题目信息

# Dividing Orange

## 题目描述

有一个橙子，分成 $n⋅k$ 瓣，编号为 $1,2,3,\cdots n\cdot k$。现在要分给 $k$ 个小孩，以下是给橙子的规则：
- 每个小孩得到 $n$ 瓣橙子。
- 第 $i$ 个小孩有一个对橙子的要求：$a_i$，即他得到的橙子瓣中必须有编号为 $a_i$ 的橙子瓣。

保证没有两个小孩的 $a_i$ 相同。

## 样例 #1

### 输入

```
2 2
4 1
```

### 输出

```
2 4 
1 3 
```

## 样例 #2

### 输入

```
3 1
2
```

### 输出

```
3 2 1 
```

# AI分析结果

### 题目内容
# 分橙子

## 题目描述
有一个橙子，分成 \(n⋅k\) 瓣，编号为 \(1,2,3,\cdots n\cdot k\) 。现在要分给 \(k\) 个小孩，以下是分橙子的规则：
- 每个小孩得到 \(n\) 瓣橙子。
- 第 \(i\) 个小孩有一个对橙子的要求：\(a_i\) ，即他得到的橙子瓣中必须有编号为 \(a_i\) 的橙子瓣。

保证没有两个小孩的 \(a_i\) 相同。

## 样例 #1
### 输入
```
2 2
4 1
```
### 输出
```
2 4 
1 3 
```
## 样例 #2
### 输入
```
3 1
2
```
### 输出
```
3 2 1 
```
### 算法分类
构造

### 综合分析与结论
这些题解的核心思路基本一致，都是先满足每个小孩对特定编号橙子瓣的需求，即先将每个小孩要求的 \(a_i\) 分配给对应的小孩，然后把剩余未被分配且未被其他小孩要求的橙子瓣随意分配给各个小孩，以满足每个小孩得到 \(n\) 瓣橙子的条件。

在实现过程中，多数题解使用了 `bitset` 或 `bool` 数组来标记已被分配或被要求的橙子瓣，方便快速判断。不同之处在于一些细节处理和代码风格，例如输入方式、变量命名、循环控制等。

### 所选的题解
#### 作者：krjt (赞：7)
- **星级**：4星
- **关键亮点**：代码简洁明了，使用 `bitset` 标记已用橙子瓣，逻辑清晰，先处理有要求的橙子瓣，再处理剩余随意分配的部分。
```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<1001>u;
int a[50],l=1,n,k;
int main(){
    cin>>n>>k;
    for(int i=1;i<=k;i++){
        cin>>a[i];
        u[a[i]]=1;
    }
    for(int i=1;i<=k;i++){
        cout<<a[i]<<" ";
        int j=n-1;
        while(j--){
            while(u[l]){
                l++;
            }
            cout<<" "<<l++;
        }
        cout<<endl;
    }
    return 0;
}
```
核心实现思想：先读入 \(n\) 和 \(k\) 以及每个小孩要求的橙子瓣编号 \(a_i\) 并标记在 `u` 中。然后遍历每个小孩，先输出其要求的橙子瓣编号，再通过循环找到未被标记的橙子瓣编号并输出，直至每个小孩都分配到 \(n\) 瓣橙子。

#### 作者：123456zmy (赞：3)
- **星级**：4星
- **关键亮点**：与其他题解思路一致，代码实现清晰易懂，变量命名直观，同样利用 `bitset` 标记橙子瓣状态。
```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<1001>u;
int a[31],i1=1,n,k;
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&a[i]);
        u[a[i]]=1;
    }
    for(int i=1;i<=k;i++)
    {
        printf("%d ",a[i]);//要的
        int j=n;
        while(--j)
        {
            while(u[i1])++i1;//找到没人要的
            printf("%d ",i1++);//防止重复输出
        }
        putchar(10);//换行
    }
    return 0;
}
```
核心实现思想：读入数据后，对每个小孩，先输出其要求的橙子瓣，再通过循环找到未被标记的橙子瓣并输出，确保每个小孩获得 \(n\) 瓣橙子。

#### 作者：卷王 (赞：8)
- **星级**：4星
- **关键亮点**：思路清晰，注释详细，同样使用 `bitset` 处理，并且提供了自定义的 `read` 函数用于输入优化。
```cpp
//请勿抄袭，共建美好洛谷！
//made in china 

#include<cstdio>
#include<bitset>
using namespace std;
bitset<1001>ds; //STL大法好！ 
int a[50],cnt=1,n,k;
inline int read();
int main()
{
    n=read(),k=read();
    for(int i=1;i<=k;i++)
    {
        a[i]=read();
        ds[a[i]]=1;
    }
    for(int i=1;i<=k;i++)
    {
        printf("%d ",a[i]);
        tmp=n-1;
        while(tmp--)
        {
            while(ds[cnt]) cnt++;
            printf("%d ",cnt);
            l++;
        }
        printf("\n");
    }
    return 0;
}
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
```
核心实现思想：通过自定义 `read` 函数读入数据，利用 `bitset` 标记橙子瓣状态，对每个小孩先输出其要求的橙子瓣，再寻找未标记的橙子瓣输出以完成分配。

### 最优关键思路或技巧
利用 `bitset` 或 `bool` 数组标记橙子瓣是否被使用或被要求，这样可以在 \(O(1)\) 的时间复杂度内快速判断某个橙子瓣的状态，从而高效地实现橙子瓣的分配。

### 拓展
此类题目属于构造类问题，通常需要根据给定的条件构造出满足要求的方案。类似的题目套路是先满足关键条件，再处理剩余的一般性条件。例如在一些资源分配问题中，先满足特定个体的特殊需求，再对剩余资源进行合理分配。

### 推荐题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：从 \(n\) 个整数中选取 \(k\) 个数，使得它们的和为质数，需要构造满足条件的选数方案。
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：给定 \(n\) 道菜的价格和总钱数 \(m\) ，构造出所有可能的点菜方案。
- [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：在平面上有 \(n\) 个点，构造一条路径使得从起点出发经过所有点再回到起点的路程最短，涉及到路径构造问题。

### 个人心得摘录与总结
作者“卷王”提到之前分析有误，后经他人指出错误进行修改，强调了在解题过程中要认真分析题目，同时也体现了交流讨论对解决问题的帮助。 

---
处理用时：45.63秒
# 题目信息

# Circle Line

## 题目描述

有$n$个车站排成一个环形，给定$n$个车站之间的距离，求从第$s$个车站到第$t$个车站所需的最短距离。

## 样例 #1

### 输入

```
4
2 3 4 9
1 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
4
5 8 2 100
4 1
```

### 输出

```
15
```

## 样例 #3

### 输入

```
3
1 1 1
3 1
```

### 输出

```
1
```

## 样例 #4

### 输入

```
3
31 41 59
1 1
```

### 输出

```
0
```

# AI分析结果

### 题目内容
# 环线

## 题目描述
有$n$个车站排成一个环形，给定$n$个车站之间的距离，求从第$s$个车站到第$t$个车站所需的最短距离。

## 样例 #1
### 输入
```
4
2 3 4 9
1 3
```
### 输出
```
5
```

## 样例 #2
### 输入
```
4
5 8 2 100
4 1
```
### 输出
```
15
```

## 样例 #3
### 输入
```
3
1 1 1
3 1
```
### 输出
```
1
```

## 样例 #4
### 输入
```
3
31 41 59
1 1
```
### 输出
```
0
```

### 算法分类
数学

### 题解综合分析与结论
这些题解主要围绕两种思路。一种是直接利用环形特点，通过分类讨论计算顺时针和逆时针两条路径距离，取较小值。另一种是将问题转化为图论的最短路问题，使用如Dijkstra、Floyd等算法求解。直接计算两条路径距离的方法思路简单直观，代码实现也较为容易；而使用最短路算法虽通用性强，但实现相对复杂，对于本题规模属于过度设计。

### 所选的题解
- **作者：Andysun06 (赞：7)  星级：4星**
    - **关键亮点**：思路清晰，先计算总路程，通过交换保证$s \leq t$ ，利用总路程减去正向距离得到反向距离，避免重复计算。
    - **重点代码核心思想**：用数组存储距离，计算总路程；根据$s$和$t$大小关系交换；正向遍历计算正向距离，通过比较正向距离和总路程减去正向距离得到最短距离。
```pas
read(n);
for i:=1 to n do
begin
    read(f[i]);
    sum:=sum+f[i];//计算总路程
end;
read(s,t);
if s>t then //如果s大于t，就将他们交换过来
begin 
    q:=s; //交换
    s:=t;
    t:=q;
end;
for i:=s to t-1 do
    k:=k+f[i];
if k<(sum-k) then
    writeln(k)
else
    writeln(sum-k);
```
- **作者：yanxingyu0910 (赞：1)  星级：4星**
    - **关键亮点**：通过分类讨论，分别计算顺时针和逆时针的距离，逻辑清晰，代码简洁明了。
    - **重点代码核心思想**：先处理$s == t$的特殊情况；保证$b$为较大值，$c$为较小值；分别通过循环计算顺时针和逆时针的距离，取最小值输出。
```cpp
if(s==t){//这里把相等的情况提前输出了防止出bug 
    cout<<0;
    return 0;
}
else if(s>t){//先进行初始化 
    b=s;
    c=t;
}
else if(s<t){
    c=s;
    b=t;
}
//b永远是最大的，c永远是最小的 
for(i=c;i<=b-1;i++){
    zheng+=a[i];//正着枚举 
}
for(i=1;i<=c-1;i++){
    fan+=a[i];//反着枚举，从1到最小的前面 
}
for(i=n;i>=b;i--){
    fan+=a[i];//反着枚举，从最大的到n 
}
ans=min(zheng,fan);//最短的 
cout<<ans;
```
- **作者：damage (赞：0)  星级：4星**
    - **关键亮点**：利用位运算交换$s$和$t$，使代码更简洁高效；通过计算总路程，用总路程减去正向距离得到反向距离，减少计算量。
    - **重点代码核心思想**：输入距离并计算总路程；通过位运算交换$s$和$t$保证$s \leq t$ ；正向遍历计算正向距离，比较正向距离和总路程减去正向距离，输出较小值。
```cpp
scanf("%d",&n);
for(register int i=1;i<=n;++i)
{
    scanf("%d",&d[i]); //输入路程
    sum+=d[i]; //求总路程
}
scanf("%d%d",&s,&t);
if(s>t) //如果s>t就交换s和t
{
    s^=t; //使用的是位运算交换的
    t^=s; //只是快一点
    s^=t; //如果不会的（不存在的）大佬们可以就用朴素的方法
}
for(register int i=s;i<t;++i) dis+=d[i]; //求区间和，注意题目描述，此时的约束条件为i<t而不是i<=t
printf("%d\n",dis<sum-dis? dis:sum-dis); //比较1情况和2情况的距离，输出短的距离
```

### 最优关键思路或技巧
直接计算顺时针和逆时针两条路径距离并取较小值的方法最为直接有效。在实现过程中，通过合理的变量交换保证计算顺序一致，利用总路程与正向距离的关系简化反向距离的计算，这些技巧能有效简化代码并提高效率。

### 拓展
同类型题通常围绕环形路径、最短距离等主题，类似算法套路是抓住环形结构特点，考虑不同方向的路径，通过简单的数学计算解决问题。对于更复杂的情况，可能会结合图论知识，但需根据题目规模和要求选择合适算法。

### 洛谷相似题目推荐
- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：涉及简单的枚举和判断。
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过计算不同方案结果，利用贪心思想选择最优解。
- [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116)：考察对排序和交换概念的理解运用。 

---
处理用时：56.49秒
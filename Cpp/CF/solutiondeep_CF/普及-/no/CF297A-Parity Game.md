# 题目信息

# Parity Game

## 题目描述

你和北极熊 Alice 和北极熊 Bob 一起钓鱼。他们等鱼上钩等得很无聊，于是想到了一个游戏来消磨时间。首先，Alice 和 Bob 分别写下一个 01 串（只包含”0”和“1”的字符串）$a$ 和 $b$，然后你可以通过两种操作尝试将 $a$ 变成 $b$：



- 将 $parity(a)$ 添加到 $a$ 的末尾。例如：$1010 \rightarrow 10100$。



- 删除 $a$ 的第一个字符。例如：$1001 \rightarrow 001$。若 $a$ 为空串则无法进行此操作。



你可以进行任意多次操作。现在请你求出是否能将 $a$ 变为 $b$。



如果一个 01 串中有奇数个 $1$，那么这个 01 串的 $parity$ 值是 $1$，否则是 $0$。

## 样例 #1

### 输入

```
01011
0110
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
0011
1110
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# 奇偶游戏

## 题目描述
你和北极熊爱丽丝（Alice）和北极熊鲍勃（Bob）一起钓鱼。他们等鱼上钩等得很无聊，于是想到了一个游戏来消磨时间。首先，爱丽丝和鲍勃分别写下一个 01 串（只包含”0”和“1”的字符串）$a$ 和 $b$，然后你可以通过两种操作尝试将 $a$ 变成 $b$：
- 将 $parity(a)$ 添加到 $a$ 的末尾。例如：$1010 \rightarrow 10100$。
- 删除 $a$ 的第一个字符。例如：$1001 \rightarrow 001$。若 $a$ 为空串则无法进行此操作。

你可以进行任意多次操作。现在请你求出是否能将 $a$ 变为 $b$。

如果一个 01 串中有奇数个 $1$，那么这个 01 串的 $parity$ 值是 $1$，否则是 $0$。

## 样例 #1
### 输入
```
01011
0110
```
### 输出
```
YES
```

## 样例 #2
### 输入
```
0011
1110
```
### 输出
```
NO
```

### 算法分类
数学

### 综合分析与结论
所有题解思路核心均为通过统计两个 01 串中 1 的数量，并结合 $parity(a)$ 的奇偶性来判断能否从串 $a$ 转化为串 $b$ 。要点在于明确不同奇偶性下 $a$ 串可增加 1 的情况，难点是理解操作对 1 数量及串转化的影响。各题解本质思路一致，主要差异在代码实现细节与思路阐述清晰度。

### 所选的题解
- **作者：Eternal_Blue（5星）**
  - **关键亮点**：思路阐述清晰，先给出结论再进行证明，逻辑连贯；代码简洁明了，直接根据结论实现判断。
  - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 100010
char str1[MAXN],str2[MAXN];
int i,j,k,m,n,a,b;
int main(){
    scanf("%s%s",str1+1,str2+1);
    n=strlen(str1+1),m=strlen(str2+1);
    a=b=0;
    for(i=1;i<=n;i++) a+=str1[i]-48;
    for(i=1;i<=m;i++) b+=str2[i]-48;
    a+=a%2;
    if(a>=b) printf("YES\n"); else printf("NO\n");
    return 0;
}
```
  - **核心实现思想**：读入两个字符串，统计各自 1 的数量，根据 $a$ 串 1 的数量奇偶性调整 $a$ 串 1 的数量，最后比较调整后 $a$ 串与 $b$ 串 1 的数量。
- **作者：Wind_Smiled（4星）**
  - **关键亮点**：通过多组数据举例分析，逐步引导出结论，易于理解；代码使用 `string` 类型，较为现代。
  - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int lena,lenb,a1,b1;
int main(){
    cin>>a>>b;
    lena=a.length();
    lenb=b.length();
    for(int i=0;i<lena;i++){
        if(a[i]=='1'){
            a1++;
        }
    }
    a1+=a1&1;
    for(int i=0;i<lenb;i++){
        if(b[i]=='1'){
            b1++;
        }
    }
    if(a1>=b1){
        printf("YES");
        return 0;
    }
    printf("NO");
    return 0;
}
```
  - **核心实现思想**：读入两个 `string` 类型字符串，统计 1 的数量，根据 $a$ 串 1 数量的奇偶性调整 $a$ 串 1 的数量，比较调整后两串 1 的数量。
- **作者：Zero_s（4星）**
  - **关键亮点**：先给出计算 1 数量的函数，再分类讨论奇偶性得出结论，结构清晰；代码运用位运算和 `puts` 函数，简洁高效。
  - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
inline int read()
{
    char ch=getchar();
    int x=0;
    while(ch!='1'&&ch!='0') ch=getchar();
    while(ch=='0'||ch=='1')
    {
        x+=ch^48;
        ch=getchar();
    }
    return x;
}
int main()
{
    a=read(),b=read();
    puts(a+a%2>=b? "YES":"NO");
    return 0;
}
```
  - **核心实现思想**：通过自定义函数 `read` 统计两串 1 的数量，根据 $a$ 串 1 数量的奇偶性调整 $a$ 串 1 的数量，利用 `puts` 函数输出判断结果。

### 最优关键思路或技巧
通过对操作的分析，抓住 1 的数量及 $parity(a)$ 的奇偶性这两个关键因素来判断能否转化，简化问题求解。在代码实现上，运用位运算等技巧提高效率，如 `a1 += a1 & 1` 简洁地实现根据奇偶性调整 1 的数量。

### 可拓展思路
此类题目属于通过分析操作对关键特征（如本题 1 的数量）的影响来判断可行性。类似套路可应用于其他涉及字符串变换规则、状态转移规则明确且可通过关键特征判断结果的题目。例如一些涉及字符替换、移动规则明确的字符串变换问题，或简单状态转移的游戏可行性判断问题。

### 推荐洛谷题目
- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过对数字生成规则的分析，运用递推或记忆化搜索求解，与本题分析操作规则解题思路类似。
- [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：根据 01 迷宫的移动规则，通过深度优先搜索或广度优先搜索探索可达性，与本题分析操作可行性有相似之处。
- [P1241 括号序列](https://www.luogu.com.cn/problem/P1241)：根据括号匹配规则判断序列合法性，通过分析规则来解决问题，和本题思路类似。 

---
处理用时：62.25秒
# 题目信息

# Array

## 题目描述

Vitaly has an array of $ n $ distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold:

1. The product of all numbers in the first set is less than zero $ (<0) $ .
2. The product of all numbers in the second set is greater than zero $ (>0) $ .
3. The product of all numbers in the third set is equal to zero.
4. Each number from the initial array must occur in exactly one set.

Help Vitaly. Divide the given array.

## 样例 #1

### 输入

```
3
-1 2 0
```

### 输出

```
1 -1
1 2
1 0
```

## 样例 #2

### 输入

```
4
-1 -2 -3 0
```

### 输出

```
1 -1
2 -3 -2
1 0
```

# AI分析结果

### 题目内容
# Array

## 题目描述
维塔利有一个包含 $n$ 个不同整数的数组。维塔利想把这个数组分成三个非空集合，使得满足以下条件：
1. 第一个集合中所有数字的乘积小于零（$<0$）。
2. 第二个集合中所有数字的乘积大于零（$>0$）。
3. 第三个集合中所有数字的乘积等于零。
4. 初始数组中的每个数字都必须恰好出现在一个集合中。

请帮助维塔利完成对给定数组的划分。

## 样例 #1
### 输入
```
3
-1 2 0
```
### 输出
```
1 -1
1 2
1 0
```

## 样例 #2
### 输入
```
4
-1 -2 -3 0
```
### 输出
```
1 -1
2 -3 -2
1 0
```

### 算法分类
构造

### 综合分析与结论
这些题解的核心思路都是基于数的乘法性质来构造满足条件的三个集合。首先明确第三个集合只要包含0就能满足乘积为0。对于第一个集合，要使其乘积为负，需有奇数个负数，通常做法是只放一个负数；对于第二个集合，要使其乘积为正，要么全是正数，要么有偶数个负数。各题解的主要差异在于具体的实现方式和代码结构。有的通过数组分别存储正负数和0后处理，有的直接在遍历过程中根据条件分配数字到不同集合。

### 所选的题解
- **作者：Kdlyh（5星）**
    - **关键亮点**：思路简洁清晰，直接点明利用“任何数乘零皆得零”这一性质，先将数分为正数和负数数组，根据不同情况（有正数负数、只有负数和0）分别处理，简化代码实现。
    - **重点代码核心实现思想**：虽未给出代码，但思路为读入数存正负数组，有正负数时，第一个集合取负数数组第一个数，第二个集合取正数数组第一个数，其余放第三个集合；只有负数和0时，第一个集合取一个负数，第二个集合取两个负数，其余放第三个集合。
- **作者：yangyuanxi44（4星）**
    - **关键亮点**：详细阐述了数的乘积规律和分类思路，包括对负数、正数、0的分类处理方式，并给出完整代码，代码注释详细，易于理解。
    - **重点代码核心实现思想**：用数组分别存储正数、负数和统计0的数量，根据正数数量是否为0进行分类讨论。正数数量不为0时，根据负数个数奇偶性处理负数分配，再将正数放入第二个集合，0和多余负数放第三个集合；正数数量为0时，从负数中取两个给第二个集合，再按负数个数奇偶性处理剩余负数和0的分配。
```cpp
#include<bits/stdc++.h>
using namespace std;
int z[105],f[105];//正数数组，负数数组 
int lcnt,zt,ft;// 0数量，正数数量，负数数量 
int n;//数字个数 
int main(){
    cin>>n;
    for(int i=1 ; i<=n ; i++){
        int x;
        cin>>x;//输入每个数 
        if(x>0){//为正数 
            zt++;//正数数量++
            z[zt]=x;//存入正数数组 
        }else if(x<0){//为负数
            ft++;//负数数量++ 
            f[ft]=x;//存入负数数组 
        }else{//为0 
            lcnt++;//0数量++
        }
    } 
    if(zt!=0){//正数数量不为0 
        int lf,pd=0;//要丢到0那里的数，判断负数个数奇偶 
        if(ft%2!=0){//为奇数
            pd=0;
            cout<<ft<<" ";//输出负数数量 
            for(int i=1 ; i<=ft ; i++) cout<<f[i]<<" ";//输出负数
            cout<<endl;
        }if(ft%2==0){//为偶数
            pd=1;//为偶数 
            cout<<ft-1<<" ";////输出负数数量-1，因为要丢出去到0有1个 
            for(int i=1 ; i<=ft-1 ; i++) cout<<f[i]<<" ";//输出负数
            lf=f[ft];//丢出去到0的数 
            cout<<endl;
        }
        cout<<zt<<" ";
        for(int i=1 ; i<=zt ; i++) cout<<z[i]<<" ";//输出正数
        cout<<endl;
        if(pd==0){//负数个数为奇数（不用丢过来） 
            cout<<lcnt<<" ";//输出0个数 
            for(int i=1 ; i<=lcnt ; i++) cout<<0<<" ";//输出0
        }
        if(pd==1){//负数个数为偶数（需要丢过来） 
            cout<<lcnt+1<<" ";//输出0个数+1（有丢过来的） 
            for(int i=1 ; i<=lcnt ; i++) cout<<0<<" ";
            cout<<lf;
        }
    }    
    if(zt==0){//正数数量为0 
        int zf1,zf2,lf,pd;//要给正数补上的两个数 
        if(ft%2!=0){
            pd=0;
            cout<<ft-2<<" ";//输出负数数量（有给正数补的数，ft-2） 
            for(int i=1 ; i<=ft-2 ; i++) cout<<f[i]<<" ";
            cout<<endl;
            zf1=f[ft-1];//给正数补上的两个数 
            zf2=f[ft];//给正数补上的两个数 
        }
        if(ft%2==0){//同上 
            pd=1;
            cout<<ft-3<<" ";
            for(int i=1 ; i<=ft-3 ; i++) cout<<f[i]<<" ";
            cout<<endl;
            zf1=f[ft-2];
            zf2=f[ft-1];
            lf=f[ft];
        }
        cout<<2<<" "<<zf1<<" "<<zf2<<endl;//给正数补的两个数 
        if(pd==0){//同上 
            cout<<lcnt<<" ";
            for(int i=1 ; i<=lcnt ; i++) cout<<0<<" ";
        }
        if(pd==1){//同上
            cout<<lcnt+1<<" ";
            for(int i=1 ; i<=lcnt ; i++) cout<<0<<" ";
            cout<<lf;
        }
    }
    return 0;
} 
```
- **作者：xiaoPanda（4星）**
    - **关键亮点**：简洁地概括了解题思路，利用负数乘法规律，明确第一个集合放1个负数，第二个集合放2个负数或不够时放正数，其他放第三个集合，代码实现清晰明了。
    - **重点代码核心实现思想**：预处理负数个数，遍历数组，负数优先满足第一个集合1个，第二个集合2个的要求，多余放第三个集合；正数在第二个集合负数不够时放入，0直接放入第三个集合，最后输出三个集合。
```cpp
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i], sum += a[i] < 0;//预处理出有多少个负数
	for (int i = 1; i <= n; i++) {
		if (a[i] < 0) {
			if (tot1 == 0)ans1[++tot1] = a[i];//第一个集合中至少要有1个负数
			else {
				if (tot2 < 2 && sum >= 3)//要有足够的负数
					ans2[++tot2] = a[i];//第二个集合中至少要有2个负数
				else ans3[++tot3] = a[i];//多余的数放在第三个集合中
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] > 0) {
			if (tot2 < 2)ans2[++tot2] = a[i];//如果负数不够只能放正数
			else ans3[++tot3] = a[i];
		}
		if (a[i] == 0)
			ans3[++tot3] = a[i];//多余的数放在第三个集合中
	}
	cout << tot1 << " ";
	for (int i = 1; i <= tot1; i++)
		cout << ans1[i] << " ";
	cout << endl;
	cout << tot2 << " ";
	for (int i = 1; i <= tot2; i++)
		cout << ans2[i] << " ";
	cout << endl;
	cout << tot3 << " ";
	for (int i = 1; i <= tot3; i++)
		cout << ans3[i] << " ";
	cout << endl;//输出答案
```

### 最优关键思路或技巧
利用数的乘法基本性质，特别是负数个数对乘积正负性的影响以及0乘任何数为0的特性，通过简单的分类讨论和元素分配来构造满足条件的集合。在实现上，可通过数组或容器存储不同类型的数，再根据条件进行分配，简化代码逻辑。

### 拓展
同类型题通常围绕数的运算性质和集合划分条件展开，类似算法套路是先分析目标条件，根据数的特性（如奇偶性、正负性）进行分类，再通过简单的组合或分配来构造满足要求的解。

### 洛谷相似题目推荐
- [P1146 硬币翻转](https://www.luogu.com.cn/problem/P1146)：涉及根据操作改变元素状态，类似本题根据数的性质进行集合划分的逻辑。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：通过组合数判断是否满足特定条件，与本题构造满足条件集合思路类似。
- [P1464 Function](https://www.luogu.com.cn/problem/P1464)：根据函数定义和条件进行计算，同样需要分析条件并构造合适的计算过程。

### 个人心得摘录与总结
无。 

---
处理用时：88.90秒
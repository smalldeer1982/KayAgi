# 题目信息

# Worms Evolution

## 题目描述

Vasechkin教授正在研究蠕虫的进化。最近他提出一种假说——所有蠕虫都是通过分裂而来。这里有n种形态不同的蠕虫。这些蠕虫有以下长度$a_1,a_2,\ldots,a_n$

为了证明他的理论，教授需要找到3种形态不同的蠕虫，其中第一个的长度是另外两个的和。帮助他完成这个吧。

## 样例 #1

### 输入

```
5
1 2 3 5 7
```

### 输出

```
3 2 1
```

## 样例 #2

### 输入

```
5
1 8 1 5 1
```

### 输出

```
-1
```

# AI分析结果

### 题目内容
# 蠕虫进化

## 题目描述
Vasechkin教授正在研究蠕虫的进化。最近他提出一种假说——所有蠕虫都是通过分裂而来。这里有n种形态不同的蠕虫。这些蠕虫有以下长度$a_1,a_2,\ldots,a_n$。
为了证明他的理论，教授需要找到3种形态不同的蠕虫，其中第一个的长度是另外两个的和。帮助他完成这个吧。

## 样例 #1
### 输入
```
5
1 2 3 5 7
```
### 输出
```
3 2 1
```

## 样例 #2
### 输入
```
5
1 8 1 5 1
```
### 输出
```
-1
```
### 算法分类
枚举
### 综合分析与结论
所有题解均基于题目数据范围小（$3\leqslant n\leqslant 100$）的特点，采用暴力枚举的方式解题。核心思路是通过三重循环遍历数组，找出满足$a_i = a_j + a_k$且$i\neq j\neq k$的三元组$(i, j, k)$。不同题解的差异主要体现在代码细节、输出顺序以及一些优化思路的探讨上。
### 所选的题解
- **作者：Eason_AC（4星）**
  - **关键亮点**：思路清晰简洁，直接阐述使用$\mathcal{O}(n^3)$的枚举方法，代码简洁明了，易于理解。
  - **重点代码**：
```cpp
int n, a[107];

int main() {
	getint(n);
	_for(i, 1, n)	getint(a[i]);
	_for(k, 1, n)
		_for(i, 1, n)
			_for(j, 1, n)
				if(a[i] + a[j] == a[k] && i!= j) {
					printf("%d %d %d", k, i, j);
					return 0;
				}
	printf("-1");
	return 0;
}
```
核心实现思想：通过三层嵌套循环枚举所有可能的三元组，判断是否满足一个数等于另外两个数之和且两个加数的下标不同，满足则输出结果并结束程序，否则继续循环，若遍历完所有组合都未找到则输出 -1。
- **作者：封禁用户（4星）**
  - **关键亮点**：在分析中详细提到数据范围对解题思路的影响，代码中使用位运算异或来加快判断速度。
  - **个人心得**：提到调试花费时间，强调循环从1开始避免被玄学数据卡掉。
  - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int INF=105;
int n,a[INF];
signed main()
{
        scanf("%d",&n);
        for (int i=1; i<=n; i++) {
                scanf("%d",&a[i]);
        }
        for (int i=1; i<=n; i++)
                for (int j=1; j<=n; j++)
                        for (int k=1; k<=n; k++) {
                                if (i==j || i==k || k==i) continue; 
                                if (!((a[i]+a[j])^a[k])) {
                                        printf("%d %d %d\n",k,j,i);
                                        return 0;
                                }
                        }
        printf("-1\n");
        return 0;
}
```
核心实现思想：与其他题解类似，通过三层循环枚举三元组，利用位运算异或判断是否满足等式，满足则输出并结束，否则输出 -1。
- **作者：ChthollyMeow（4星）**
  - **关键亮点**：不仅给出常规暴力枚举解法，还探讨了多种优化思路，如排序优化、类似其他题目（P1102 A - B数对）的思路迁移、桶排序与Hash算法降低空间复杂度等。
  - **重点代码**：
```cpp
#include<cstdio>
using namespace std;
int main(){
    int n,a[105];
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            for(int k=1;k<=n;k++){
                if(i==j||j==k||k==i){
                    continue;
                }
                if(a[i]==a[j]+a[k]){
                    printf("%d %d %d\n",i,j,k);
                    return 0;
                }
            }
        }
    }
    printf("-1\n");
    return 0;
}
```
核心实现思想：通过三层循环枚举所有可能的三元组，判断下标是否相等以及是否满足等式，满足条件则输出并结束程序，否则遍历完输出 -1。
### 最优关键思路或技巧
在数据范围小的情况下，暴力枚举是一种简单有效的方法。对于可能的优化方向，如利用数组非负特性先排序再枚举，虽不能改变时间复杂度量级，但可减少常数；借鉴类似题目思路，通过记录差值来优化查找过程；使用Hash算法可降低空间复杂度。
### 同类型题或类似算法套路
此类题目通常数据范围较小，可直接采用暴力枚举解决。类似套路是先观察数据范围，若范围允许，优先考虑暴力解法，再思考优化方向。优化时可从数据特性出发，如排序后利用单调性减少无效枚举。
### 推荐题目
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：通过枚举菜品价格组合，判断是否能达到给定总金额，与本题枚举满足特定条件的组合类似。
- [P1469 找筷子](https://www.luogu.com.cn/problem/P1469)：利用异或运算的特性解决问题，与本题部分题解中使用位运算优化判断有相似之处。
- [P2241 统计方形（数据加强版）](https://www.luogu.com.cn/problem/P2241)：通过枚举矩形的边长来统计满足条件的方形数量，同样是基于枚举思想的题目。 

---
处理用时：52.93秒
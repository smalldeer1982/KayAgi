# 题目信息

# Magic Numbers

## 题目描述

A magic number is a number formed by concatenation of numbers $ 1 $ , $ 14 $ and $ 144 $ . We can use each of these numbers any number of times. Therefore $ 14144 $ , $ 141414 $ and $ 1411 $ are magic numbers but $ 1444 $ , $ 514 $ and $ 414 $ are not.

You're given a number. Determine if it is a magic number or not.

## 样例 #1

### 输入

```
114114
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
1111
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
441231
```

### 输出

```
NO
```

# AI分析结果

### 题目内容
# Magic Numbers

## 题目描述
一个神奇数字是由数字1、14和144连接而成的数。我们可以任意多次使用这些数字中的每一个。因此，14144、141414和1411是神奇数字，而1444、514和414不是。
给定一个数字，判断它是否是神奇数字。

## 样例 #1
### 输入
```
114114
```
### 输出
```
YES
```

## 样例 #2
### 输入
```
1111
```
### 输出
```
YES
```

## 样例 #3
### 输入
```
441231
```
### 输出
```
NO
```

### 算法分类
字符串

### 综合分析与结论
这些题解主要围绕判断给定数字是否由1、14、144连接组成展开。思路可分为两类：一类是从数字特征出发，判断数字是否仅由1和4组成、开头是否为1、有无连续三个4；另一类是通过对数字从前往后或从后往前匹配1、14、144来判断。各题解的算法要点和难点解决方式如下：
 - **从数字特征判断**：通过循环遍历数字的每一位，检查是否满足上述三个特征条件。难点在于准确处理连续4的计数和判断。
 - **匹配判断**：从数字末尾或开头开始，尝试匹配1、14、144，匹配成功则去掉已匹配部分继续判断。难点在于如何设计合理的匹配逻辑，避免误判。

整体来看，各题解思路较为直接，部分题解代码简洁度和可读性有待提高。

### 所选的题解
 - **作者：田_穗 (5星)**
    - **关键亮点**：采用从后向前排查的方法，代码简洁明了，逻辑清晰，通过取余操作判断并删除数字末尾的1、14或144，是较为高效的实现方式。
    - **重点代码**：
```cpp
#include<stdio.h>
int n;
int main(){
    scanf("%d",&n);
    while(1){
        if(n%10==1) {n/=10;continue;}
        if(n%100==14) {n/=100;continue;}
        if(n%1000==144) {n/=1000;continue;}
        if(n==0) {printf("YES");return 0;}
        printf("NO");
        return 0;
    }
}
```
    - **核心实现思想**：不断检查数字n的末尾是否为1、14或144，若是则去掉相应部分继续循环，若不是则根据情况输出NO或YES。
 - **作者：Dimly_dust (4星)**
    - **关键亮点**：提供了字符串版本和普通整形版本两种实现，对魔数的成立条件分析清晰，通过循环判断数字的每一位是否符合条件。
    - **个人心得**：作者提到自己作为蒟蒻WA了，强调看似简单的题也需仔细。
    - **重点代码（字符串版本）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string check(string n)
{
    int check4=0;
    if(n[0]!='1') return "NO";
    for(int i=0;i<n.size();i++)
    {
        if(n[i]!='1'&&n[i]!='4') return "NO";
        else if(n[i]=='4')check4++;
        else if(n[i]=='1') check4=0;
        if(check4==3) return "NO";
    }
    return "YES";
}
int main()
{
    string n;
    cin>>n;
    cout<<check(n)<<endl;
    return 0;
}
```
    - **核心实现思想**：遍历字符串n，检查首位是否为1，每一位是否为1或4，并统计连续4的个数，根据条件返回判断结果。
 - **作者：qwq___qaq (4星)**
    - **关键亮点**：提供了三种基于字符串的方法，包括逆序删除、正序查找等，方法多样，思路清晰。
    - **重点代码（逆序删除）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string n;
int main(){
    cin>>n;
    int len=n.size();
    for(int i=len-1;i>=0;){
        if(n[i]=='1')
            i--;
        else if(i>='1'&&n[i]=='4'&&n[i-1]=='1')
            i-=2;
        else if(i>=2&&n[i]=='4'&&n[i-1]=='4'&&n[i-2]=='1')
            i-=3;
        else{
            puts("NO");
            return 0;
        }
    }
    puts("YES");
    return 0;
}
```
    - **核心实现思想**：从字符串末尾开始，尝试匹配1、14、144，匹配成功则移动指针继续匹配，否则输出NO，全部匹配完输出YES。

### 最优关键思路或技巧
从后向前排查的方法较为巧妙，利用取余操作直接判断并删除数字末尾的特定组合，减少了复杂的字符串操作，代码简洁高效。同时，在处理字符串时，合理利用循环和条件判断，准确检查数字特征也是关键技巧。

### 同类型题或类似算法套路拓展
此类题目属于字符串匹配和数字特征判断类型。类似套路包括对给定字符串或数字，依据特定规则进行匹配、拆分、判断等操作。例如，判断一个字符串是否由特定子串重复组成，或者判断数字是否符合特定的数位组合规则等。

### 洛谷相似题目推荐
 - **P1036 [NOIP2002 普及组] 选数**：涉及数字组合判断，与本题判断数字是否符合特定组合规则类似。
 - **P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here**：通过字符串对应关系判断，与本题对字符串或数字按规则判断有相似之处。
 - **P1598 [USACO10OCT] 湖计数Lake Counting**：对二维字符数组进行遍历判断，与本题对字符串遍历判断特征有类似的思路。 

---
处理用时：60.88秒
# 题目信息

# Constellation

## 题目描述

一个Berland星空图填充了一个N×M的正方形。在每一个正方形上都可能有星星。Berland的十字星座是所有的天文学家最喜欢的星座。这个星座可以由任何5个恒星组成，所以对于整数x（星座的半径），有以下原则：

第二个和第一个在同一条垂直线上，但是在第一个的上边x单位处。

第三个和第一个在同一条垂直线上，但是在第一个的下边x单位处。

第四个和第一个在同一水平线上，但是在第一个的左边x单位处。

第五个和第一个在同一水平线上，但是在第一个的右边x单位处。

这些星座可以非常多，这就是为什么他们有以下原则：当两星座相比，更小的半径会有更小的指数；如果他们的半径相等，其中央恒星如果高于另一个中央恒星；如果他们中央恒星都在同一水平的人，其中央恒星是对另一个中央恒星的左边。

你的任务是找到星座为指数K的Berland的星空图。

## 样例 #1

### 输入

```
5 6 1
....*.
...***
....*.
..*...
.***..
```

### 输出

```
2 5
1 5
3 5
2 4
2 6
```

## 样例 #2

### 输入

```
5 6 2
....*.
...***
....*.
..*...
.***..
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
7 7 2
...*...
.......
...*...
*.***.*
...*...
.......
...*...
```

### 输出

```
4 4
1 4
7 4
4 1
4 7
```

# AI分析结果

### 题目内容
# 星座

## 题目描述
一个Berland星空图填充了一个N×M的正方形。在每一个正方形上都可能有星星。Berland的十字星座是所有天文学家最喜欢的星座。这个星座由5个恒星组成，对于整数x（星座的半径），有以下规则：
第二个恒星和第一个在同一条垂直线上，但在第一个的上边x单位处。
第三个恒星和第一个在同一条垂直线上，但在第一个的下边x单位处。
第四个恒星和第一个在同一水平线上，但在第一个的左边x单位处。
第五个恒星和第一个在同一水平线上，但在第一个的右边x单位处。
这些星座数量可能很多，因此有以下规则：当比较两个星座时，半径更小的星座指数更小；如果它们的半径相等，中央恒星位置更高的星座指数更小；如果它们的中央恒星在同一水平位置，中央恒星在左边的星座指数更小。
你的任务是找到指数为K的Berland星空图中的星座。

## 样例 #1
### 输入
```
5 6 1
....*.
...***
....*.
..*...
.***..
```
### 输出
```
2 5
1 5
3 5
2 4
2 6
```

## 样例 #2
### 输入
```
5 6 2
....*.
...***
....*.
..*...
.***..
```
### 输出
```
-1
```

## 样例 #3
### 输入
```
7 7 2
...*...
.......
...*...
*.***.*
...*...
.......
...*...
```
### 输出
```
4 4
1 4
7 4
4 1
4 7
```

### 算法分类
枚举

### 题解综合分析与结论
这几道题解思路基本一致，均利用题目数据范围小（\(N\leq300\)，\(M\leq300\)）的特点，采用 \(O(N^3)\) 的暴力枚举算法。先枚举半径，再枚举行和列，判断以当前点为中心、当前半径的十字形状是否构成星座，若构成则对星座计数，当计数达到 \(K\) 时输出该星座信息，若遍历完所有情况仍未找到则输出 \(-1\)。

### 所选的题解
 - **作者：Shimotsuki (3星)**
    - **关键亮点**：代码使用快读优化输入，在暴力枚举时通过合理的边界判断减少无效枚举，如利用 `len=n<m?n:m` 来限制半径枚举范围。
    - **重点代码**：
```cpp
#include<cstdio>
using namespace std;
#define rd(x) x=read()
#define rei register int
char a[310][310];
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int main(){
    int n,m,k,cnt=0;
    rd(n);rd(m);rd(k);
    for(rei i=1;i<=n;i++)
        scanf(" %s",a[i]+1);
    int len=n<m?n:m;
    for(rei l=1;l<=len;l++){
        for(rei i=l+1;i+l<=n;i++){
            for(rei j=l+1;j+l<=m;j++){
                if(a[i][j]=='*'&&a[i+l][j]=='*'&&a[i-l][j]=='*'&&a[i][j+l]=='*'&&a[i][j-l]=='*'){
                    if(cnt+1==k){
                        printf("%d %d\n",i,j);
                        printf("%d %d\n",i-l,j);
                        printf("%d %d\n",i+l,j);
                        printf("%d %d\n",i,j-l);
                        printf("%d %d",i,j+l);
                        return 0;
                    }
                    else cnt++;
                }
            }
        }
    }
    printf("-1");
    return 0;
}
```
    - **核心实现思想**：先快读输入 \(n\)，\(m\)，\(k\) 及星空图，然后按半径、行、列的顺序枚举，判断是否构成星座，若构成且计数达到 \(k\) 则输出星座信息并结束程序，否则计数加一，若遍历完未找到则输出 \(-1\)。
 - **作者：__Cartesian__Tree__ (1星)**
    - **关键亮点**：思路较为清晰，按照半径、行、列从小到大的顺序遍历，符合题目对星座指数排序的规则。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int m;
int k;
char mm[310][310];
int main(){
    cin>>n>>m>>k;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            cin>>mm[i][j];
        }
    }
    int cnt = 1;
    int len = min(n, m);
    for (int num = 1; num <= len; num++){
        for (int x = num+1; x+num <= n; x++){
            for (int y = num+1; y+num <= m; y++){
                if (mm[x][y]=='*'&&mm[x-num][y]=='*'&&mm[x+num][y]=='*'
                    &&mm[x][y-num]=='*'&&mm[x][y+num]=='*'){
                    if (cnt == k){
                        cout << x << ' ' << y << endl;
                        cout << x-num << ' ' << y << endl;
                        cout << x+num << ' ' << y << endl;
                        cout << x << ' ' << y-num << endl;
                        cout << x << ' ' << y+num << endl;
                        return 0;
                    }
                    cnt++;
                }
            }
        }
    }
    puts("-1");
    return 0;
}
```
    - **核心实现思想**：输入数据后，通过三层循环按半径、行、列枚举，判断是否为星座，若为星座且指数等于 \(k\) 则输出星座信息并结束，否则指数加一，若遍历完未找到则输出 \(-1\)。
 - **作者：chenyilai (0星)**
    - **关键亮点**：代码通过自定义函数 `pd` 判断点是否为星，逻辑较清晰。
    - **重点代码**：
```cpp
bool pd(int i,int j){
    if(i<=0||i>n||j<=0||j>m)return 0;
    if(s[i][j]=='.')return 0;
    return 1;
}
int main(){
    cin>>n>>m>>k;
    minn=min(n,m)/2;
    for(int i=1;i<=n;i++)cin>>s[i],s[i]=' '+s[i];
    for(int r=1;r<=minn;r++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                if(pd(i,j)&&pd(i-r,j)&&pd(i,j-r)&&pd(i,j+r)&&pd(i+r,j)){
                    k--;
                    if(k==0){
                        printf("%d %d\n%d %d\n%d %d\n%d %d\n%d %d\n",i,j,i-r,j,i+r,j,i,j-r,i,j+r);
                        return 0;
                    }
                }
    printf("-1");
    return 0;
}
```
    - **核心实现思想**：先定义函数判断点是否为星，输入数据后按半径、行、列枚举，若构成星座则 \(k\) 减一，当 \(k\) 为 \(0\) 时输出星座信息并结束，若遍历完未找到则输出 \(-1\)。

### 最优关键思路或技巧
利用题目数据范围小的特点，采用暴力枚举法。在枚举过程中，合理利用边界条件减少无效枚举，如根据 \(n\) 和 \(m\) 的较小值确定半径的最大枚举范围。

### 拓展思路
同类型题目通常具有数据范围较小，可通过暴力枚举解决的特点。类似算法套路是根据题目给定的条件和约束，合理安排枚举顺序，以满足题目对结果的排序或筛选要求。

### 洛谷相似题目推荐
 - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)
 - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)
 - [P1036 选数](https://www.luogu.com.cn/problem/P1036)

### 个人心得摘录与总结
无。 

---
处理用时：75.59秒
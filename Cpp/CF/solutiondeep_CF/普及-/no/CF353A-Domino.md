# 题目信息

# Domino

## 题目描述

## 【问题描述】

Hades与Dionysus在狂饮后玩起了多米诺骨牌的小游戏。
现在桌上有n块多米诺骨牌，每块多米诺骨牌上半部分和下半部分上都有一个整数。每次翻转可让一块多米诺骨牌上下翻转，即上下部分数交换。Hades想让n块骨牌上半部分的数加起来是一个偶数，而Dionysus想让这n块骨牌下半部分的数加起来是一个偶数。喝醉的两人都不肯退让，非要达到自己的目的。路过的Hephaestus在扫了一眼桌上的骨牌后瞬间给出了一个让两人都满意且翻转次数最少的方案，便转身离去，留下迟滞的二人。可这还没完，喝得烂醉的二人很快忘记了Hephaestus所说的方案，Hades说他还记得最少的翻转次数，Dionysus不愿被比下去，只好来请教你了。

## 样例 #1

### 输入

```
2
4 2
6 4
```

### 输出

```
0
```

## 样例 #2

### 输入

```
1
2 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3
1 4
2 3
4 4
```

### 输出

```
1
```

# AI分析结果

### 题目内容
# 多米诺骨牌

## 题目描述
### 【问题描述】
哈迪斯（Hades）与狄俄尼索斯（Dionysus）在狂饮后玩起了多米诺骨牌的小游戏。
现在桌上有n块多米诺骨牌，每块多米诺骨牌上半部分和下半部分上都有一个整数。每次翻转可让一块多米诺骨牌上下翻转，即上下部分数交换。哈迪斯想让n块骨牌上半部分的数加起来是一个偶数，而狄俄尼索斯想让这n块骨牌下半部分的数加起来是一个偶数。喝醉的两人都不肯退让，非要达到自己的目的。路过的赫菲斯托斯（Hephaestus）在扫了一眼桌上的骨牌后瞬间给出了一个让两人都满意且翻转次数最少的方案，便转身离去，留下迟滞的二人。可这还没完，喝得烂醉的二人很快忘记了赫菲斯托斯所说的方案，哈迪斯说他还记得最少的翻转次数，狄俄尼索斯不愿被比下去，只好来请教你了。

## 样例 #1
### 输入
```
2
4 2
6 4
```
### 输出
```
0
```

## 样例 #2
### 输入
```
1
2 3
```
### 输出
```
-1
```

## 样例 #3
### 输入
```
3
1 4
2 3
4 4
```
### 输出
```
1
```

### 算法分类
数学

### 题解综合分析与结论
所有题解思路本质相同，都是基于对骨牌上下两部分数字和的奇偶性分析来解题。核心思路为：先计算上下两部分数字总和的奇偶性，根据奇偶性不同分为几种情况讨论。若上下和均为偶数，无需翻转，输出0；若上下和一奇一偶，无论如何翻转都无法满足条件，输出 -1；若上下和均为奇数，此时需判断是否存在上下奇偶性不同的骨牌，若存在则翻转一次即可，输出1，若不存在则输出 -1 。不同题解在细节实现和证明过程上略有差异。

### 所选的题解
- **作者：crpboy (4星)**
    - **关键亮点**：通过对上下两排和的奇偶性进行分类讨论，逻辑清晰，代码简洁明了，利用取模运算简化判断过程。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[10005],y[10005];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&x[i],&y[i]);
    for(int i=1;i<=n;i++)
        x[i]&=1,y[i]&=1;//取模
    int s1=0,s2=0;
    bool flag=false;
    for(int i=1;i<=n;i++)
    {
        s1+=x[i],s2+=y[i];
        if(!flag)if((x[i]&&!y[i])||(!x[i]&&y[i]))flag=true;
    }
    s1%=2,s2%=2;
    if((s1&&!s2)||(!s1&&s2)||(s1&&s2&&!flag))//无解情况
    {
        printf("-1");
        return 0;
    }
    if(s1&&s2&&flag)//(1,1)有解
    {
        printf("1");
        return 0;
    }
    if(!s1&&!s2)//(0,0)
    {
        printf("0");
        return 0;
    }
    return 0;
}
```
    - **核心实现思想**：先读入数据并对每个数取模简化为0或1，然后分别计算上下两部分的和并取模，同时判断是否存在上下奇偶性不同的骨牌，最后根据不同的奇偶性组合输出结果。

- **作者：chlchl (4星)**
    - **关键亮点**：不仅给出解题思路，还对答案只可能是0、1、 -1 进行了详细证明，逻辑严谨。通过统计奇数个数的方式简化判断过程，代码实现巧妙。
    - **个人心得**：一开始忘记讨论上下和都为奇数的情况直接输出1导致第8个点错误，强调了全面考虑各种情况的重要性。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100 + 10;
int n, up[2], down[2], x[N], y[N];
bool flag;
//两个奇数的和必为偶数 

int main(){
    scanf("%d", &n);
    for(int i=1;i<=n;i++){
        scanf("%d%d", &x[i], &y[i]);
        up[x[i] % 2]++, down[y[i] % 2]++;
        //方便统计个数，不用打 if 
        if((x[i] + y[i]) % 2 == 1)    flag = true;
        //提前判断有没有奇偶性不同的牌，别的题解都是用的abs，
        //我用的是和的奇偶性判断的。可以根据上述三式得出 
    }
    //下面判断就是前面的结论了，不解释 
    if((up[1] + down[1]) % 2 == 1){
        puts("-1");
        return 0;
    }
    //这里奇偶性必定相同，判断一方即可 
    if(up[1] % 2 == 0)    puts("0");
    else if(up[1] % 2 == 1 && flag)    puts("1");
    else    puts("-1");
    return 0;
}
```
    - **核心实现思想**：读入数据时统计上下部分奇数的个数，同时判断是否存在上下奇偶性不同的骨牌，根据奇数个数和的奇偶性以及是否存在特殊骨牌输出结果。

### 最优关键思路或技巧
1. **奇偶性分析**：通过对骨牌上下部分数字和的奇偶性进行分析，将问题分为几种明确的情况进行讨论，简化问题求解过程。
2. **取模简化**：对每个数字进行取模运算，将其简化为0（偶数）或1（奇数），方便后续的统计和判断。

### 拓展思路
此类题目属于基于数学性质（奇偶性）的逻辑推理题，类似题目常通过对数据的某种数学特征（如余数、整除性等）进行分析，从而找到解题方法。在解决这类问题时，关键在于深入理解相关数学性质，并将其巧妙应用到代码实现中。

### 洛谷相似题目推荐
1. **P1909 买铅笔**：通过对不同包装铅笔价格和数量的分析，利用贪心策略解决购买铅笔花费最少的问题，同样需要对数据进行合理分析与处理。
2. **P1085 不高兴的津津**：根据时间安排和条件判断，通过模拟和简单的数学计算来解决问题，与本题一样需要清晰的逻辑分析。
3. **P1149 火柴棒等式**：通过枚举和数学运算来判断火柴棒组成等式的情况，考察对数学关系的理解和编程实现能力，与本题思路有相似之处。 

---
处理用时：67.53秒
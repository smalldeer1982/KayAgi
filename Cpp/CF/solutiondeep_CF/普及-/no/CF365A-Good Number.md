# 题目信息

# Good Number

## 题目描述

Let's call a number $ k $ -good if it contains all digits not exceeding $ k $ ( $ 0,...,k $ ). You've got a number $ k $ and an array $ a $ containing $ n $ numbers. Find out how many $ k $ -good numbers are in $ a $ (count each number every time it occurs in array $ a $ ).

## 样例 #1

### 输入

```
10 6
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
```

### 输出

```
10
```

## 样例 #2

### 输入

```
2 1
1
10
```

### 输出

```
1
```

# AI分析结果

### 题目内容
# 好数

## 题目描述
如果一个数包含所有不超过 $k$ 的数字（$0, \ldots, k$），我们就称这个数为 $k$ -好数 。给定一个数 $k$ 和一个包含 $n$ 个数的数组 $a$ 。找出数组 $a$ 中有多少个 $k$ -好数（每次在数组 $a$ 中出现都要计数）。

## 样例 #1
### 输入
```
10 6
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
1234560
```
### 输出
```
10
```

## 样例 #2
### 输入
```
2 1
1
10
```
### 输出
```
1
```

### 算法分类
模拟

### 题解综合分析与结论
这几道题解思路大致相同，都是对数组中的每个数进行判断是否为 $k$ -好数，核心在于如何高效判断一个数是否包含 $0$ 到 $k$ 的所有数字。不同点主要体现在实现方式和细节处理上。

Alex_Wei 的题解思路清晰，代码简洁明了，使用数组标记数字出现情况，直接在主函数中完成判断和计数。teacup 的题解与 Alex_Wei 类似，变量命名更具描述性，但整体结构稍显啰嗦。yuangq 的题解将判断部分封装成函数，不过代码中存在一些不必要的循环范围和特判，增加了代码复杂度。hensier 的题解将数字当作字符串处理，排序后再判断，增加了时间复杂度。

### 所选的题解
 - **作者：Alex_Wei (5星)**
    - **关键亮点**：思路清晰，代码简洁高效，直接在主函数中通过数组标记和循环判断完成任务，没有多余的操作。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a,i,v[10],pd;
int main()
{
    cin>>n>>k;
    for(int x=1;x<=n;x++){
        cin>>a,memset(v,0,sizeof(v)),pd=1;
        while(a)v[a%10]=1,a/=10;
        for(int y=0;y<=k;y++)if(!v[y])pd=0;
        if(pd)i++;
    }
    cout<<i;
    return 0;
}
```
核心实现思想：每次输入一个数，先将标记数组 `v` 清零，通过取余和除法操作标记该数每一位上出现的数字，然后检查 `0` 到 `k` 的数字是否都在数组 `v` 中被标记，若都被标记则计数加一。

 - **作者：teacup (4星)**
    - **关键亮点**：变量命名更具描述性，对于初学者理解代码逻辑友好，同样采用数组标记判断的常规思路。
    - **核心代码片段**：
```cpp
#include<cstdio>
using namespace std;
int i,n,t,k,sum=0,x;
bool a[10],b;
int main(){
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++){
        scanf("%d",&t),b=1;
        for(x=0;x<=k;x++) a[x]=0;
        while(t) a[t%10]=1,t/=10;
        for(x=0;x<=k;x++) if(!a[x]) b=0;
        if(b) sum++;
    }
    printf("%d",sum);
    return 0;
}
```
核心实现思想：与 Alex_Wei 类似，每次输入数字 `t`，假设其为 `k` -好数，清零标记数组 `a`，标记 `t` 每一位上的数字，检查 `0` 到 `k` 的数字是否都被标记，若都被标记则计数 `sum` 加一。

### 最优关键思路或技巧
使用数组标记数字出现情况是解决本题的关键技巧，通过这种方式可以快速判断一个数是否包含特定范围内的所有数字，简单高效。

### 可拓展之处
此类题目属于模拟类型，类似的题目套路通常是根据给定的规则对数据进行模拟操作。例如，根据特定数字组合规则判断数字是否符合要求，或者根据某种字符排列规则判断字符串是否有效等。

### 洛谷相似题目推荐
 - [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)：基础的输入输出和简单运算，可作为模拟题入门。
 - [P1046 陶陶摘苹果（升级版）](https://www.luogu.com.cn/problem/P1046)：根据给定条件模拟摘苹果的过程，锻炼逻辑思维。
 - [P1425 小鱼的游泳时间](https://www.luogu.com.cn/problem/P1425)：模拟时间计算，加深对模拟题的理解。

### 个人心得摘录与总结
无。 

---
处理用时：57.92秒
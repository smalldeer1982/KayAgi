# 题目信息

# Lever

## 题目描述

你有一根杠杆，用一个字符串s表示（$3≤|s|≤10^{6}$）。

若字符串的下标为i的字符为“^”，则表示杠杆的支点的坐标为i；

若字符串的下标为i的字符为“=”，则表示坐标为i的位置没有任何东西；

若字符串的下标为i的字符为一个数字c（$1≤c≤9$），则表示在坐标为i处，有一个质量为c的重物挂在杠杆上。

杠杆一开始是平衡的，杠杆自重忽略不计。

你的任务是判断这根杠杆的状态（平衡、向左倾斜或向右倾斜）。

注意，本题需要使用64位整型。

## 样例 #1

### 输入

```
=^==
```

### 输出

```
balance
```

## 样例 #2

### 输入

```
9===^==1
```

### 输出

```
left
```

## 样例 #3

### 输入

```
2==^7==
```

### 输出

```
right
```

## 样例 #4

### 输入

```
41^52==
```

### 输出

```
balance
```

# AI分析结果

### 题目内容
# 杠杆

## 题目描述
你有一根杠杆，用一个字符串s表示（$3≤|s|≤10^{6}$）。
若字符串的下标为i的字符为“^”，则表示杠杆的支点的坐标为i；
若字符串的下标为i的字符为“=”，则表示坐标为i的位置没有任何东西；
若字符串的下标为i的字符为一个数字c（$1≤c≤9$），则表示在坐标为i处，有一个质量为c的重物挂在杠杆上。
杠杆一开始是平衡的，杠杆自重忽略不计。
你的任务是判断这根杠杆的状态（平衡、向左倾斜或向右倾斜）。
注意，本题需要使用64位整型。

## 样例 #1
### 输入
```
=^==
```
### 输出
```
balance
```

## 样例 #2
### 输入
```
9===^==1
```
### 输出
```
left
```

## 样例 #3
### 输入
```
2==^7==
```
### 输出
```
right
```

## 样例 #4
### 输入
```
41^52==
```
### 输出
```
balance
```

### 算法分类
数学

### 综合分析与结论
所有题解均基于杠杆原理，即动力×动力臂 = 阻力×阻力臂。对于本题，需分别计算杠杆左右两边重物质量与到支点距离乘积的总和，再比较两边总和判断杠杆状态。各题解的不同主要体现在代码实现细节上，如数据存储方式、循环遍历方式等。

### 所选的题解
- **作者：miraculously (5星)**
    - **关键亮点**：思路清晰，代码简洁明了，注释详细。先找出支点位置，再通过两次循环分别计算左右两边的力矩总和，最后比较输出结果。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt1,cnt2,cnt;
char c[1000001];
int main()
{
    scanf("%s",c);
    for(int i=0;i<strlen(c);i++)
        if(c[i]=='^')
        {
            cnt=i;
            break;
        }
    for(int i=0;i<strlen(c);i++)
    {
        if(i<cnt&&c[i]<='9'&&c[i]>='1')
            cnt1+=(cnt - i)*(c[i]-'0');
        if(i>cnt&&c[i]<='9'&&c[i]>='1')
            cnt2+=(i - cnt)*(c[i]-'0');
    }
    if(cnt1==cnt2)
    {
        printf("balance");
        return 0;
    }
    cnt1<cnt2?printf("right"):printf("left");
}
```
    - **核心实现思想**：先遍历字符串找到支点位置`cnt`，再遍历一次字符串，对支点左边的重物计算其力矩累加到`cnt1`，对支点右边的重物计算其力矩累加到`cnt2`，最后比较`cnt1`和`cnt2`输出结果。

- **作者：hwwqy (4星)**
    - **关键亮点**：在代码开头介绍杠杆原理相关知识，代码实现简洁易懂。通过`string`类型读入数据，同样是先找支点，再遍历计算左右两边力矩和并比较输出。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll l=0,r=0;
int main()
{
    string gan;
    cin>>gan;
    int mid;
    for(mid=0;gan[mid]!='^';mid++);
    for(int i=0;i<gan.size();i++)
    {
        if(i<mid)
        {
            if(gan[i]!='=')l+=(mid - i)*(gan[i]-'0');
        }
        else if(i>mid)
        {
            if(gan[i]!='=')r+=(i - mid)*(gan[i]-'0');
        }
    }
    if(l==r)
    {
        printf("balance");
    }
    else if(l>r)
    {
        printf("left");
    }
    else
    {
        printf("right");
    }
    return 0;
}
```
    - **核心实现思想**：读入字符串`gan`，找到支点位置`mid`，遍历字符串，对支点左右两边重物分别计算力矩并累加到`l`和`r`，最后比较`l`和`r`输出结果。

### 最优关键思路或技巧
利用杠杆原理，将问题转化为计算字符串中支点左右两边重物质量与到支点距离乘积的总和，通过遍历字符串实现计算。在实现过程中，注意使用`long long`类型避免数据溢出。

### 可拓展之处
此类题目属于基于物理原理的数学计算与字符串结合的题型。类似题目可能会改变杠杆的初始状态，或者改变重物的表示方式等。算法套路通常是先确定关键位置（如本题的支点），再根据规则对不同部分进行计算和比较。

### 洛谷相似题目推荐
- [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)：基础的输入输出和简单运算，适合巩固基础编程能力。
- [P1046 陶陶摘苹果](https://www.luogu.com.cn/problem/P1046)：涉及简单的条件判断和数据处理，与本题处理字符串中不同字符的思路有相似之处。
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过比较不同方案的结果来得出最优解，和本题比较左右两边力矩判断杠杆状态思路类似。 

---
处理用时：50.62秒
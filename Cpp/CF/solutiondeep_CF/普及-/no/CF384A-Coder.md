# 题目信息

# Coder

## 题目描述

Iahub 很喜欢下棋。他甚至发明了一种棋子叫做 "Coder"。

一个 Coder 可以攻击与它相邻的格子中的棋子（水平和竖直方向）。如果一个 Coder 在坐标 $(x,y)$上，它可以攻击 $(x+1,y)$ , $(x-1,y)$ , $(x,y+1)$ , $(x,y-1)$ 这四个格子。

Iahub 想要知道有多少个 Coder 可以被放在 $n*n$
 的棋盘中，使得任意两个 Coder 都不能互相攻击。

## 样例 #1

### 输入

```
2
```

### 输出

```
2
C.
.C
```

# AI分析结果

### 题目内容
Iahub 很喜欢下棋。他甚至发明了一种棋子叫做 “Coder”。
一个 Coder 可以攻击与它相邻的格子中的棋子（水平和竖直方向）。如果一个 Coder 在坐标 $(x,y)$上，它可以攻击 $(x + 1,y)$ ，$(x - 1,y)$ ，$(x,y + 1)$ ，$(x,y - 1)$ 这四个格子。
Iahub 想要知道有多少个 Coder 可以被放在 $n*n$ 的棋盘中，使得任意两个 Coder 都不能互相攻击。
### 算法分类
数学
### 综合分析与结论
这些题解的核心思路都是通过找规律来解决问题，主要围绕棋盘的奇偶性展开。不同题解在实现方式和优化程度上有所差异。思路上，多数题解发现将棋盘按行列奇偶性分类，坐标为（奇，奇）或（偶，偶）放置棋子能达到最优解；部分题解从行列和的奇偶性判断放置位置。算法要点在于根据 $n$ 的奇偶性计算最多可放置棋子数，并按规律输出摆放方案。解决难点在于如何准确找到放置棋子的规律以及优化代码实现。
### 所选的题解
#### 作者：清小秋ovo (5星)
- **关键亮点**：提供两种解法，解法1通过创建二维字符数组模拟棋子摆放过程，直观易懂；解法2优化暴力，直接读入并输出，根据 $n$ 的奇偶性分类讨论计算总数并输出摆放方案，时间复杂度更低。
- **个人心得**：心血来潮写题解记录自己的做题过程。
- **核心代码（解法2）**：
```cpp
#include<bits/stdc++.h>

using namespace std;

int main()
{
   ios::sync_with_stdio(0);
   cin.tie(0);
   int n;
   cin>>n;
   if(n%2==0){//如果n为偶数
       cout<<n*n/2<<endl;
       for(int i=1;i<=n;i++){
           if(i%2==1){
               for(int i=1;i<=n/2;i++) cout<<"C.";//奇数行
           }else{
               for(int i=1;i<=n/2;i++) cout<<".C";//偶数行
           }
           cout<<endl;
       }
    }else{//如果n为奇数
       cout<<(n*n+1)/2<<endl;
       for(int i=1;i<=n;i++){
           if(i%2==1){//奇数行
               for(int i=1;i<=n/2;i++) cout<<"C.";
               cout<<"C";
           }else{
               for(int i=1;i<=n/2;i++) cout<<".C";//偶数行
               cout<<".";
           }
           cout<<endl;
       }
   }
}
```
核心思想：根据 $n$ 的奇偶性分别计算可放置棋子数并按奇偶行规律输出摆放方案。
#### 作者：米奇奇米 (4星)
- **关键亮点**：通过画图找规律，简洁指出当 $(x + y)$ 为偶数时放置的 Coder 最多，直接 $O(n^2)$ 统计答案，思路清晰。
- **核心代码**：无具体代码，但思路可实现为遍历棋盘每个位置，根据 $(x + y)$ 的奇偶性判断是否放置棋子并统计数量，同时输出摆放方案。
#### 作者：Tenshi (4星)
- **关键亮点**：提出将棋盘进行黑白相间染色，把 coder 放在全部白格子或者黑格子就是最多摆放方法，并给出证明，之后按此方法实现，逻辑严谨。
- **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include <stdlib.h>  
using namespace std;

int main(){
	int n;
	cin>>n;
	if(n%2==0){
		cout<<n*n/2<<endl;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++)
			{
				if(j%2==0&&i%2==0)cout<<'C';
				else if(j%2==1&&i%2==0)cout<<'.';
				else if(j%2==1&&i%2==1)cout<<'C';
				else if(j%2==0&&i%2==1)cout<<'.';
			}
			cout<<endl;
		}
		}
			
		else{
		cout<<(n+1)/2*(n/2+1)+(n/2)*(n-1)/2<<endl;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++)
			{
				if(j%2==0&&i%2==0)cout<<'C';
				else if(j%2==1&&i%2==0)cout<<'.';
				else if(j%2==1&&i%2==1)cout<<'C';
				else if(j%2==0&&i%2==1)cout<<'.';
			}
			cout<<endl;		
		}
		
		}	

	return 0;
}
```
核心思想：根据 $n$ 的奇偶性计算最多放置棋子数，通过双重循环遍历棋盘，依据行列奇偶性判断位置染色情况（即是否放置棋子）并输出摆放方案。
### 最优关键思路或技巧
通过观察棋盘规律，利用棋盘行列的奇偶性来确定棋子的放置位置，这是解决本题的关键。同时，根据 $n$ 的奇偶性分类讨论计算最多可放置棋子数，能简化计算过程。部分题解直接输出摆放方案，避免存储棋盘状态，优化了时间和空间复杂度。
### 同类型题或类似算法套路拓展
此类题目属于棋盘放置类型问题，通常可通过找规律、数学计算来解决。类似套路是对棋盘进行染色、奇偶分析等，判断放置元素的可行性及最大数量。
### 洛谷相似题目推荐
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)
3. [P1464 Function](https://www.luogu.com.cn/problem/P1464)

---
处理用时：52.92秒
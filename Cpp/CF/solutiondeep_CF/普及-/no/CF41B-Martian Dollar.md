# 题目信息

# Martian Dollar

## 题目描述

一天Vasya得到了接下来n天，在bourles 有火星元的交易的信息。 第i天每一火星元的市价（不管是买入还是卖出都一样）是a[i]. Vasya有b 火星元。 他可以执行至多一次买入一定数量的火星元并卖出的操作。 根据火星法律，对火星元的买卖必须以整数为单位。试问Vasya在过了n天后最多能得到多少火星元？

## 样例 #1

### 输入

```
2 4
3 7
```

### 输出

```
8
```

## 样例 #2

### 输入

```
4 10
4 3 2 1
```

### 输出

```
10
```

## 样例 #3

### 输入

```
4 10
4 2 3 1
```

### 输出

```
15
```

# AI分析结果

### 题目内容
#### Martian Dollar
1. **题目描述**：一天Vasya得知接下来n天在bourles火星元的交易信息。第i天每一火星元的市价（买卖价格相同）是a[i]。Vasya有b火星元，他可以执行至多一次买入一定数量火星元并卖出的操作。根据火星法律，火星元的买卖必须以整数为单位。试问Vasya在n天后最多能得到多少火星元？
2. **样例 #1**
    - **输入**：
```
2 4
3 7
```
    - **输出**：
```
8
```
3. **样例 #2**
    - **输入**：
```
4 10
4 3 2 1
```
    - **输出**：
```
10
```
4. **样例 #3**
    - **输入**：
```
4 10
4 2 3 1
```
    - **输出**：
```
15
```

### 算法分类
枚举

### 综合分析与结论
所有题解都围绕如何找到最优的买卖时机以获取最大收益展开。大部分题解采用暴力枚举的方法，即枚举所有可能的买入和卖出时间组合来计算收益，这种方法简单直接，适用于本题较小的数据范围。其中fzj2007提出的前缀最小值和后缀最大值思路相对有一定优化，通过预处理减少了部分计算量。

### 所选的题解
 - **作者fzj2007（5星）**
    - **关键亮点**：提出优化思路，利用前缀和与后缀和思想，用数组记录前缀最小值（期望的卖出最小值）和后缀最大值，减少了枚举的计算量，代码中还包含读入优化。
    - **个人心得**：指出其他题解$O(n^2)$复杂度可优化，并谦虚表示希望读者指出讲解中的问题。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int ans=0,flag=1;
    char ch=getchar();
    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
    if(ch=='-') flag=-1,ch=getchar();
    while(ch>='0'&&ch<='9'){
        ans=(ans<<1)+(ans<<3)+(ch^'0');
        ch=getchar();
    }
    return ans*flag;
}
int n,b,q[2005],h[2005],p[2005],maxn,ans;
int main(){
    n=read(),b=read();
    for(int i=1;i<=n;i++) p[i]=read();
    for(int i=0;i<=n;i++) q[i]=2005;
    for(int i=1;i<=n;i++) q[i]=min(p[i],q[i-1]);
    for(int i=n;i>=1;i--) h[i]=max(p[i],h[i+1]);
    for(int i=1;i<=n;i++) ans=max((b/q[i])*h[i]+b%q[i],ans);
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：先通过`read`函数优化读入。然后分别计算前缀最小值数组`q`和后缀最大值数组`h`，最后遍历计算在每个位置买入并结合后缀最大卖出值时的最大收益。
 - **作者柳逸君（4星）**
    - **关键亮点**：对题意进行了详细翻译，代码实现简单直接，通过枚举买卖日期调用函数计算收益，逻辑清晰。
    - **核心代码**：
```cpp
#include <cstdio>
#include <iostream>
#include <queue>
#include <algorithm>
#define ll long long
using namespace std;
ll n,b,ans;
ll a[2010];
ll mer(int in,int out)
{
    ll bb,d;
    d=b/a[in];  bb=b%a[in];
    bb+=d*a[out]; 
    return bb;
}
int main()
{
    scanf("%lld%lld",&n,&b);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            ans=max(ans,mer(i,j)) ;
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：定义`mer`函数计算在`in`天买入，`out`天卖出的收益。主函数中枚举所有买卖日期组合，调用`mer`函数并更新最大收益。

### 最优关键思路或技巧
1. **枚举优化**：如fzj2007采用前缀最小值和后缀最大值的预处理方式，减少了枚举过程中的重复计算，降低时间复杂度。
2. **模块化实现**：柳逸君通过定义函数来计算买卖收益，使代码逻辑更清晰，便于理解和维护。

### 可拓展之处
同类型题通常围绕资产交易收益最大化展开，类似算法套路为枚举所有可能的交易时间点组合，但对于大数据量，可考虑使用动态规划等更高效的算法优化。

### 洛谷相似题目推荐
1. [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过枚举不同包装铅笔的购买方案，找到花费最少的方案，与本题枚举找最优解思路类似。
2. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：在给定预算和菜品价格情况下，枚举菜品选择方案，计算满足条件的方案数，同样涉及枚举思想。
3. [P2670 扫雷游戏](https://www.luogu.com.cn/problem/P2670)：通过枚举每个格子是否为雷的情况，结合周围格子数字信息，判断是否符合扫雷规则，也是枚举思想的应用。

---
处理用时：53.07秒
# 题目信息

# Jzzhu and Children

## 题目描述

`Jzzhu`给学校里的$n$个孩子发糖果，编号从$1$到$n$排成一队，第$i$个孩子想得到至少$a_i$个糖果。  
`Jzzhu`的操作如下：
- 给队首的孩子$m$个糖果
- 如果这个孩子已经得到满足，他就会回家，否则他会到队尾。
- 在队列非空时重复上述两个操作  

在满足上述条件的情况下，求出最后回家的孩子的编号

## 样例 #1

### 输入

```
5 2
1 3 1 4 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
6 4
1 1 2 2 3 3
```

### 输出

```
6
```

# AI分析结果

【题目内容】
# Jzzhu和孩子们

## 题目描述
`Jzzhu`给学校里的$n$个孩子发糖果，编号从$1$到$n$排成一队，第$i$个孩子想得到至少$a_i$个糖果。  
`Jzzhu`的操作如下：
- 给队首的孩子$m$个糖果
- 如果这个孩子已经得到满足，他就会回家，否则他会到队尾。
- 在队列非空时重复上述两个操作  

在满足上述条件的情况下，求出最后回家的孩子的编号

## 样例 #1

### 输入
```
5 2
1 3 1 4 2
```

### 输出
```
4
```

## 样例 #2

### 输入
```
6 4
1 1 2 2 3 3
```

### 输出
```
6
```

【算法分类】
队列

【综合分析与结论】
这些题解主要围绕模拟发糖果的过程来求解最后回家孩子的编号，大致可分为模拟队列操作和数学计算两种思路。
- **模拟队列操作**：多数题解采用队列来模拟孩子排队的过程，每次给队首孩子$m$个糖果，若未满足需求则将其移到队尾，直到队列中只剩一个孩子。这种方法直观易懂，但时间复杂度较高。
- **数学计算**：通过计算每个孩子需要的轮数，找出轮数最大且编号最大的孩子，即为最后回家的孩子。这种方法时间复杂度较低。

【所选题解】
- **作者：cyffff (5星)**
  - **关键亮点**：思路清晰，使用结构体队列存储孩子信息，代码简洁易读。
  - **代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{//定义结构体保存每个孩子的信息
    int id,t;
};
int main(){
    queue<node>p;//定义结构体队列p
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++){
        int t;
        scanf("%d",&t);
        p.push((node){i,t});//插入编号和所需糖果数量
    }
    while(p.size()>1){
        int t=p.front().t,q=p.front().id;
        t-=m;
        p.pop();
        if(t>0){
            p.push((node){q,t});
        }
    }
    cout<<p.front().id;
    return 0;
}
```
核心思想：定义结构体存储孩子的编号和所需糖果数，使用队列模拟发糖果过程，不断处理队首元素，直到队列中只剩一个元素。

- **作者：luohanzhao (4星)**
  - **关键亮点**：采用数学方法，无需使用队列，时间复杂度低。
  - **代码实现**：
```cpp
#include<bits/stdc++.h>
int n,m,mx,sum,x; 
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&x);
        x=ceil(x*1.0/m*1.0);
        if(x>=mx)mx=x,sum=i;
    }printf("%d",sum);
    return 0;
} 
```
核心思想：通过计算每个孩子需要的轮数（向上取整），找出轮数最大且编号最大的孩子。

- **作者：_Legacy (4星)**
  - **关键亮点**：同样采用数学方法，思路独特，不使用队列。
  - **代码实现**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n,m,a[100000];
    int maxx=-1,ans=-1;//孩子不可能要-1个糖
    cin >> n >> m;
    for(int i=0;i<n;i++){
        cin >> a[i];
        if(a[i]%m==0) 
            a[i]/=m;
        else
            a[i]/=m,a[i]++;
        //求次数部分
        if(a[i]>=maxx){
            maxx=a[i];
            ans=i+1;
        } 
        //求是否为最后的，最大(或之一)的号数
    } 
    cout << ans;
}
```
核心思想：计算每个孩子需要排队的次数，找出次数最大且编号最大的孩子。

【最优关键思路或技巧】
- 对于模拟类问题，使用队列可以方便地模拟排队过程。
- 对于此类问题，可通过数学计算避免模拟过程，降低时间复杂度。

【拓展思路】
同类型题可考察不同的排队规则或资源分配问题，类似算法套路可应用于模拟游戏过程、任务调度等问题。

【推荐题目】
- P1540 [NOIP2010 提高组] 机器翻译
- P1996 约瑟夫问题
- P1160 队列安排

---
处理用时：30.27秒
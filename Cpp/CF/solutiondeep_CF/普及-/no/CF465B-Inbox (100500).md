# 题目信息

# Inbox (100500)

## 题目描述

Over time, Alexey's mail box got littered with too many letters. Some of them are read, while others are unread.

Alexey's mail program can either show a list of all letters or show the content of a single letter. As soon as the program shows the content of an unread letter, it becomes read letter (if the program shows the content of a read letter nothing happens). In one click he can do any of the following operations:

- Move from the list of letters to the content of any single letter.
- Return to the list of letters from single letter viewing mode.
- In single letter viewing mode, move to the next or to the previous letter in the list. You cannot move from the first letter to the previous one or from the last letter to the next one.

The program cannot delete the letters from the list or rearrange them.

Alexey wants to read all the unread letters and go watch football. Now he is viewing the list of all letters and for each letter he can see if it is read or unread. What minimum number of operations does Alexey need to perform to read all unread letters?

## 说明/提示

In the first sample Alexey needs three operations to cope with the task: open the second letter, move to the third one, move to the fourth one.

In the second sample the action plan: open the first letter, move to the second letter, return to the list, open the fifth letter.

In the third sample all letters are already read.

## 样例 #1

### 输入

```
5
0 1 0 1 0
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 1 0 0 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
2
0 0
```

### 输出

```
0
```

# AI分析结果

### 题目翻译
随着时间的推移，阿列克谢（Alexey）的邮箱里堆满了太多的信件。其中一些信件已读，而另一些则未读。

阿列克谢的邮件程序可以显示所有信件的列表，也可以显示单封信件的内容。一旦程序显示了一封未读信件的内容，它就会变成已读信件（如果程序显示的是已读信件的内容，则不会发生任何变化）。他只需点击一下，就可以执行以下任何操作：
- 从信件列表切换到任何单封信件的内容页面。
- 从单封信件查看模式返回到信件列表。
- 在单封信件查看模式下，切换到列表中的下一封或上一封信件。不能从第一封信件切换到上一封，也不能从最后一封信件切换到下一封。

该程序不能从列表中删除信件，也不能重新排列它们。

阿列克谢想读完所有未读信件，然后去看足球比赛。现在他正在查看所有信件的列表，并且可以看到每封信件是已读还是未读。阿列克谢最少需要执行多少次操作才能读完所有未读信件？

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是贪心算法，即从左到右遍历邮件列表，尽可能地利用相邻未读邮件的连续性来减少操作次数。各题解的主要区别在于实现细节和代码风格。

思路上，大部分题解都是先找到第一个未读邮件，然后根据下一个邮件是否未读来决定是否返回列表。有的题解使用数组存储邮件状态，有的使用 `vector` 存储未读邮件的索引。

算法要点在于判断相邻未读邮件的距离，若距离为 1 则直接跳转，否则返回列表再选择下一个未读邮件。同时，要注意读完最后一封邮件后不需要返回列表，操作数要减 1。

解决的难点在于处理边界情况，如没有未读邮件时直接输出 0，以及避免重复计算操作次数。

### 所选题解
- **作者：Ggsddu_zzy (4星)**
  - 关键亮点：思路清晰，代码简洁，对边界情况处理得当。
```cpp
#include <bits/stdc++.h>
#define ri register int
using namespace std;
int a[1001],ans=0,sum=0;
int main() {
    int n;
    cin>>n;
    for(ri i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]) sum++;
    }
    if(!sum) {
        cout<<0<<'\n';
        return 0;
    }
    for(int i=1;i<=n;i++) {
        if(a[i]) {
            ans++;
            if(!a[i+1]) ans++;
        }
    }
    cout<<ans-1<<'\n';
    return 0;
}
```
核心实现思想：先统计未读邮件的数量，若为 0 则直接输出 0。然后遍历邮件列表，遇到未读邮件操作数加 1，若下一封邮件已读则操作数再加 1。最后操作数减 1 以处理读完最后一封邮件的情况。

- **作者：Alex_Wei (4星)**
  - 关键亮点：使用 `vector` 存储未读邮件的索引，逻辑清晰，易于理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],ans;
vector <int> one; 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i])one.push_back(i);
    }
    for(int i=0;i<one.size();i++){
        ans++;//打开一个未读信件需要一步
        if(i<one.size()-1&&one[i+1]-one[i]>1)ans++;//如果下一个未读信件与它距离大于1，那么退出来还要一步
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：将未读邮件的索引存入 `vector` 中，遍历 `vector`，打开未读邮件操作数加 1，若下一个未读邮件与当前邮件距离大于 1 则操作数再加 1。

### 最优关键思路或技巧
- 贪心策略：从左到右遍历邮件列表，优先利用相邻未读邮件的连续性减少操作次数。
- 边界处理：注意没有未读邮件的情况，以及读完最后一封邮件后不需要返回列表。

### 拓展思路
同类型题或类似算法套路：在一些资源分配问题中，也可以使用贪心算法，优先选择代价最小或收益最大的操作。例如，在任务调度问题中，优先选择执行时间短或优先级高的任务。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
- [P2240 食草的奶牛](https://www.luogu.com.cn/problem/P2240)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得
题解中未包含个人心得。

---
处理用时：29.12秒
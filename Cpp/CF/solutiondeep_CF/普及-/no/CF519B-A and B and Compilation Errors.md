# 题目信息

# A and B and Compilation Errors

## 题目描述

A和B在准备他们的编程比赛。

B十分喜欢调试他的代码，但在他让程序输出结果并开始调试之前，他必须先编译他的代码。

最初，编译器显示了nnn 处编译错误，每一处被描述为一个正整数。经过不懈的努力，B就能够修复一个错误然后再去修复另一个。

然而，尽管事实上B的确修复了两个错误，但他无法准确地记住哪些编译上的错误消失了——B所使用的编译器每次输出的剩下的编译错误的顺序是不定的！B明白，不像其它的编程语言，他编程中的某一个编译错误与其它的错误无关，也就是说，修正了一个错误之后，其它的错误依旧存在，不会被修正。

你能帮助B找出他修正了哪两个错误吗？（只有两个）

## 样例 #1

### 输入

```
5
1 5 8 123 7
123 7 5 1
5 1 7
```

### 输出

```
8
123
```

## 样例 #2

### 输入

```
6
1 4 3 3 5 7
3 7 5 4 3
4 3 7 5
```

### 输出

```
1
3
```

# AI分析结果

### 题目翻译
题目内容本身为中文，无需翻译。

### 算法分类
数学

### 综合分析与结论
这些题解主要围绕找出两组数之间缺失的两个数展开，有多种不同的实现思路。
- **求和法**：通过计算三组数的和，用前一组数的和减去后一组数的和，得到缺失的数。该方法简单直接，时间复杂度低。
- **异或法**：利用异或的性质，相同数异或为 0 且异或具有交换律来找出缺失的数，思路巧妙。
- **排序比较法**：对三组数分别排序后逐位比较，找出不同的数即为缺失的数，逻辑较直观但时间复杂度相对较高。

### 题解列表
- **作者：Uni_Tune (4星)**
    - **关键亮点**：思路清晰，代码简洁易懂，直接通过求和相减得到结果。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
int n,x,num1,num2,num3;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&x);
        num1+=x;
    }
    for(int i=1;i<=n-1;i++){
        scanf("%d",&x);
        num2+=x;
    }
    for(int i=1;i<=n-2;i++){
        scanf("%d",&x);
        num3+=x;
    }
    printf("%d\n%d",num1-num2,num2-num3);
    return 0;
}
```
    - **核心实现思想**：分别计算三组数的和，用第一组和减去第二组和得到第一个缺失的数，用第二组和减去第三组和得到第二个缺失的数。

- **作者：寒鸽儿 (4星)**
    - **关键亮点**：利用异或的性质解决问题，思路独特，代码简洁。
    - **核心代码**：
```cpp
#include <cstdio>
#define ll long long 
using namespace std;
int main() {
    int n;
    scanf("%d", &n);
    ll pre = 0, now = 0;
    int tmp;
    for(int i = 1; i <= n; ++i) {
        scanf("%d", &tmp);
        pre ^= tmp;
    }
    for(int i = n - 1; i > n - 3; --i) {
        for(int j = 1; j <= i; ++j) {
            scanf("%d", &tmp);
            now ^= tmp;
        }
        printf("%lld\n", now ^ pre);
        pre = now; now = 0;
    }
    return 0;
}
```
    - **核心实现思想**：先将第一组数异或得到 `pre`，然后对后面两组数分别异或得到 `now`，`now ^ pre` 即为缺失的数。

- **作者：Cult_style (4星)**
    - **关键亮点**：思路与 Uni_Tune 类似，但提醒了要开 `long long` 避免数据溢出。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,a;
LL sum1,sum2,sum3;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a);
        sum1+=a;
    }
    for(int i=1;i<=n-1;i++){
        scanf("%lld",&a);
        sum2+=a;
    }
    for(int i=1;i<=n-2;i++){
        scanf("%lld",&a);
        sum3+=a;
    }
    printf("%lld\n%lld",sum1-sum2,sum2-sum3);
    return 0;
}
```
    - **核心实现思想**：同 Uni_Tune 的思路，计算三组数的和并相减得到缺失的数。

### 最优关键思路或技巧
- **求和法**：利用数学原理，通过求和相减的方式快速找出缺失的数，简单高效。
- **异或法**：巧妙运用异或的性质，相同数异或为 0，避免了排序和复杂的比较操作。

### 可拓展之处
同类型题如找出多组数据中缺失的多个数，可根据不同情况选择合适的方法。若数据范围较小，可使用排序比较法；若数据范围较大，求和法或异或法更合适。

### 洛谷相似题目推荐
1. P1161 开灯：可使用异或的性质解决。
2. P1047 校门外的树：可通过模拟或差分的方法解决，与本题的模拟思想有一定关联。
3. P1217 [USACO1.5]回文质数 Prime Palindromes：可通过枚举和质数判断的方法解决，与本题的枚举思想有相似之处。

### 个人心得摘录与总结
- **Cult_style**：提醒要开 `long long` 并使用 `lld` 输出，否则第一个点会出错，强调了数据范围对结果的影响。 

---
处理用时：28.72秒
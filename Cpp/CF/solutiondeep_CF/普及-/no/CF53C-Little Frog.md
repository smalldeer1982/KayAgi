# 题目信息

# Little Frog

## 题目描述

从前一个名叫 Vasya 的小青蛙决定在它家的沼泽里四处旅行。沼泽里有 $n$ 个位于一条线的土堆，相邻的土堆之间的距离是 $1$ 米。Vasya 想在一天内参观所有的土堆；此外，它想每一个都只去一次。为此，它制定了一个路线计划。Vasya 可以选择任何土丘作为起点。同时，它想要任何两次跳跃的路径的长度不同。请你帮助 Vasya 青蛙，完成它的计划。

## 样例 #1

### 输入

```
2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
3
```

### 输出

```
1 3 2 ```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路都是通过模拟青蛙在土堆两端反复横跳的过程来满足题目要求，即每次跳跃路径长度不同且每个土堆只访问一次。各题解的区别主要在于实现方式，有的使用数组模拟，有的借助双向队列 `deque`，还有的直接通过数学规律输出结果。

### 题解对比
| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| Waaifu_D | 让青蛙在土堆两侧反复横跳，用数组模拟，奇数步向左跳，偶数步向右跳 | 用数组存储土堆编号，通过两个指针分别指向数组头部和尾部，根据步数奇偶性移动指针 | 保证每个土堆只访问一次且跳跃路径长度不同 | 4星 |
| 子翮 | 以左端点为起点，左右跳向最靠前的未跳过的点，使用 `deque` 实现 | 将 1 到 n 压入 `deque` 中，通过取模判断队头队尾，依次查询、输出并弹出元素 | 利用 `deque` 的双向操作特性简化实现 | 3星 |
| 薛定谔的诚 | 从较大跨度慢慢往较小跨度跳，从第一个土堆跳到第 n 个土堆，再跳回第二个土堆，循环操作 | 通过循环输出对称位置的土堆编号，特判 n 为奇数的情况 | 处理 n 为奇数时中间土堆的输出 | 3星 |
| _lzh_ | 在左右两端跳跃，记录当前位置、左右端点和方向 | 根据当前位置判断是在左端还是右端，更新左右端点和当前位置 | 准确更新左右端点和当前位置 | 3星 |
| FJ·不觉·莫笑 | 采用反复横跳的方法，从 1 跳到 n，再从 n 跳到 2，依次类推 | 通过判断当前位置是在左端还是右端，更新左右端点和当前位置 | 控制跳跃顺序和输出 | 3星 |
| Siyuan | 从最左边开始，每次跳到另一端未被访问的点 | 通过判断当前位置是在左端还是右端，更新左右端点和当前位置 | 确保每个土堆只访问一次 | 3星 |
| Yydy_RedDust | 从 1 开始到中点，输出对称位置的土堆编号 | 通过循环输出对称位置的土堆编号，特判 n 为奇数的情况 | 处理 n 为奇数时中间土堆的输出 | 3星 |
| Allanljx | 每次跳到当前没跳到过的地方的最右边或最左边 | 记录中点和奇偶性，特判 n 为 1 和 2 的情况，输出对称位置的土堆编号 | 处理边界情况和 n 为奇数时中间土堆的输出 | 3星 |
| Eason_AC | 左右横跳，从 1 跳到 n，再从 n 跳到 2，依次类推 | 通过循环和条件判断更新当前位置 | 控制跳跃顺序和输出 | 3星 |
| xgwpp6710 | 从 1 号开始，每次跳到对面的端点 | 通过循环输出对称位置的土堆编号，特判 n 为奇数的情况 | 处理 n 为奇数时中间土堆的输出 | 3星 |
| HPXXZYY | 考虑每一步距离递减，序列为 1,n,2,n - 1,3,n - 2... | 通过循环输出对称位置的土堆编号，特判 n 为奇数的情况 | 处理 n 为奇数时中间土堆的输出 | 3星 |

### 高评分题解
- **Waaifu_D（4星）**
    - **关键亮点**：思路清晰，通过数组模拟青蛙跳跃过程，代码简洁易懂。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[10005];
int tot=1,back;
int main()
{
    int n;
    cin>>n;
    back=n;
    for(int i=1; i<=n;i++)
    {
        a[i]=i;
    }
    for(int i=1; i<=n;i++)
    {
        if(i%2==1)
        {
            cout<<a[tot++]<<" ";
        }
        else
        {
            cout<<a[back--]<<" ";
        }
    }
    return 0;
}
```
**核心实现思想**：用数组 `a` 存储 1 到 n 的土堆编号，`tot` 为头部指针，`back` 为尾部指针。通过循环，根据步数 `i` 的奇偶性决定从头部还是尾部取出元素输出，并更新相应指针。

### 最优关键思路或技巧
- **反复横跳策略**：让青蛙在土堆的两端反复横跳，从较大跨度慢慢往较小跨度跳，能保证每次跳跃路径长度不同。
- **对称输出**：利用土堆编号的对称性，通过循环输出对称位置的土堆编号，可简化实现过程。
- **特判奇数情况**：当 n 为奇数时，需要单独处理中间的土堆，避免遗漏。

### 拓展思路
同类型题可能会改变青蛙的跳跃规则，如限制跳跃次数、跳跃方向等，解题时仍可采用模拟的方法，根据具体规则调整跳跃策略。类似算法套路可应用于其他需要按特定规则遍历元素的问题，如在棋盘上按特定规则移动棋子等。

### 推荐洛谷题目
- P1002 过河卒
- P1047 校门外的树
- P1059 明明的随机数

---
处理用时：32.09秒
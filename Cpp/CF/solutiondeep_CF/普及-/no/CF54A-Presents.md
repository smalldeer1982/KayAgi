# 题目信息

# Presents

## 题目描述

刺猬喜欢给朋友送礼物，但他不喜欢收到礼物。（有钱的刺猬）

所以，刺猬要求你给他写一个程序，计算他在接下来的几天里收到的礼物数。他收到的礼物遵循以下原则：

在每个假日日，刺猬一定会收到礼物
他每K天会收到至少一件礼物（即，如果他在第i天收到了一件礼物，那么他会在i+k天或之前再次收到一见礼物，但在一天里，无论他收到多少礼物，仅被视为收到一件礼物）。
给定的n和k，以及在接下来的n天中的假期列表，请计算刺猬的能获得礼物最少数量。今天的日期视作零，你应该把今天的礼物看作是已经存在的（也就是说，你不应该把它算在答案里）。

## 样例 #1

### 输入

```
5 2
1 3
```

### 输出

```
3```

## 样例 #2

### 输入

```
10 1
3 6 7 8
```

### 输出

```
10```

# AI分析结果

### 题目内容（已为中文，无需翻译）
刺猬喜欢给朋友送礼物，但他不喜欢收到礼物。（有钱的刺猬）

所以，刺猬要求你给他写一个程序，计算他在接下来的几天里收到的礼物数。他收到的礼物遵循以下原则：

在每个假日日，刺猬一定会收到礼物
他每K天会收到至少一件礼物（即，如果他在第i天收到了一件礼物，那么他会在i + k天或之前再次收到一见礼物，但在一天里，无论他收到多少礼物，仅被视为收到一件礼物）。
给定的n和k，以及在接下来的n天中的假期列表，请计算刺猬的能获得礼物最少数量。今天的日期视作零，你应该把今天的礼物看作是已经存在的（也就是说，你不应该把它算在答案里）。

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路都是基于贪心策略，通过处理假期之间的间隔来计算刺猬收到礼物的最少数量。大部分题解先记录假期日期，然后计算相邻假期之间以及最后一个假期到第n天之间能收到礼物的最少天数，最后累加得到结果。
- **思路对比**：大部分题解思路一致，都是处理假期间隔；DiDi123的题解采用模拟的方法，通过维护长度为k的时间区间来判断是否需要额外收礼物。
- **算法要点**：关键在于计算相邻假期之间的间隔天数，用间隔天数除以k并向上取整得到这期间至少收到礼物的天数。
- **解决难点**：处理端点是一个难点，不同题解在处理最后一个假期到第n天的间隔时，有的考虑端点，有的不考虑，需要仔细分析。

### 题解评分
- Forever1507：4星。思路清晰，代码有注释，对处理端点的坑点有说明。
- lichenfan：3星。思路表述较简单，代码结构清晰。
- Allanljx：3星。思路和代码都比较常规。
- mzyc_pzx：3星。思路简单提及，代码简洁。
- DiDi123：3星。采用模拟思路，有自己的思考，但代码复杂度相对较高。
- laeva：3星。思路有形象的比喻，但代码中存在语法错误。

### 所选题解
- Forever1507（4星）
  - 关键亮点：思路清晰，对处理端点的坑点有详细说明，代码有注释。
  - 个人心得：“假期一定有礼物，那么我们可以针对假期的间隔进行处理，特别注意括号里去掉端点后别忘了加回来,因为一定有礼物(卡了好久啊。。。)”，总结出处理端点时需要考虑假期一定有礼物这一条件。

### 重点代码
```cpp
// Forever1507的核心代码
int day[400];//记录假期的日期
int n,k,c,ans;
int main(){
    cin>>n>>k>>c;
    for(int i=1;i<=c;i++){
    	cin>>day[i];
    	ans+=(day[i]-day[i-1]-1)/k+1;
    }
    ans+=(n-day[c])/k;
    cout<<ans;
    return 0;
}
```
**核心实现思想**：先读取假期日期，对于相邻的假期，计算它们之间的间隔天数，用间隔天数减1后除以k再加1得到这期间至少收到礼物的天数；最后处理最后一个假期到第n天的间隔，将这部分的结果累加到答案中。

### 扩展思路
同类型题可能会改变礼物接收的规则，或者增加更多的限制条件，但核心思路还是基于贪心策略，通过分析间隔和规则来计算最优解。类似算法套路可以用于解决一些资源分配、时间安排等问题，关键在于找到合适的贪心策略。

### 推荐题目
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P2240 木材加工](https://www.luogu.com.cn/problem/P2240)

---
处理用时：27.48秒
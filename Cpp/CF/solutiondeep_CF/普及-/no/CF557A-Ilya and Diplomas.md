# 题目信息

# Ilya and Diplomas

## 题目描述

不久将在 Berland 举行一场信息奥林匹克竞赛，将有 $n$ 名学生参加。

在奥赛评委会议上，决定根据比赛成绩，为每个参赛者颁发一、二或三等证书。因此，每个学生将获得且只能获得一个证书。

他们还决定一定要颁发至少 $\min_1$ 和至多 $\max_1$ 个一等证书，至少 $\min_2$ 和至多 $\max_2$ 个二等证书，以及至少 $\min_3$ 和至多  $\max_3$ 个三等证书。

经过一番讨论，决定从满足这些限制条件的分配证书的所有选项中选择一种，最大化获得一等证书的学生人数。如果存在多个这样的选项，则选择能最大化获得二等证书的学生人数的选项。如果存在多个这样的选项，则选择能最大化获得三等证书的选项。

你要保证所述限制条件使得可以选择一种分配证书的方式，以便奥林匹克竞赛的所有 $n$ 名参赛者都能获得某个等级的证书。

## 样例 #1

### 输入

```
6
1 5
2 6
3 7
```

### 输出

```
1 2 3 
```

## 样例 #2

### 输入

```
10
1 2
1 3
1 5
```

### 输出

```
2 3 5 
```

## 样例 #3

### 输入

```
6
1 3
2 2
2 2
```

### 输出

```
2 2 2 
```

# AI分析结果

【题目内容】已为中文，无需翻译。
【算法分类】贪心

【综合分析与结论】
这些题解的核心思路都是贪心算法，目标是在满足各奖项人数上下限的条件下，优先让高等级奖项的人数尽可能多。
- **思路对比**：大部分题解先判断一等奖能否取到最大值，若可以再判断二等奖，若不行则二三等奖取最小值；部分题解从假设各奖项人数最多或最少出发，再进行调整。
- **算法要点**：核心在于根据总人数和各奖项上下限，通过比较和计算确定每个奖项的人数。
- **解决难点**：难点在于如何合理地分配人数，保证满足所有条件，特别是在处理人数限制和优先级时。

【所选的题解】
- linch（4星）：关键亮点是使用 Python 语言实现，思路清晰，代码注释详细，易于理解。
- sxq9（4星）：代码简洁，通过简洁的条件判断和计算得出结果。
- NEO_bone（4星）：思路清晰，代码结构明确，对判断过程有详细的逻辑处理。

【重点代码】
### linch 的 Python 代码
```python
n=int(input())
min1,max1=map(int,input().split())
min2,max2=map(int,input().split())
min3,max3=map(int,input().split())
if n-min2-min3>=max1:
    n=n-max1
    if n-min3>=max2:
        n=n-max2
        print(max1,max2,n)
    else:
        n=n-min3
        print(max1,n,min3)
else:
    print(n-min2-min3,min2,min3)
```
核心实现思想：先判断一等奖能否取到最大值，若可以再判断二等奖，根据不同情况输出结果。

### sxq9 的 C++ 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    int min1,min2,min3,max1,max2,max3,real2;
    cin>>min1>>max1>>min2>>max2>>min3>>max3;
    if(n-max1>min2+min3)real2=(n-max1-min3>max2)?max2:(n-max1-min3),cout<<max1<<' '<<real2<<' '<<n-max1-real2;
    else cout<<n-min2-min3<<' '<<min2<<' '<<min3;
    return 0;
}
```
核心实现思想：通过一个条件判断，根据不同情况计算并输出各奖项人数。

### NEO_bone 的 C++ 代码
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;
int n,a[4],b[4];
int ans;
int main()
{
    cin>>n;
    for(int i=1;i<=3;i++)
        cin>>a[i]>>b[i];
    if(n-b[1]>=a[2]+a[3])
    {
        cout<<b[1]<<' ';
        n-=b[1];
        if(n-b[2]>=a[3])
            cout<<b[2]<<' '<<n-b[2];
        else cout<<n-a[3]<<' '<<a[3];
    }
    else
    {
        cout<<n-a[2]-a[3]<<' ';
        cout<<a[2]<<' ';
        cout<<a[3]<<' ';
    }
    cout<<endl;
    return 0;
}
```
核心实现思想：先判断一等奖能否取到最大值，若可以再判断二等奖，根据不同情况输出各奖项人数。

【最优关键思路或技巧】
采用贪心策略，优先满足高等级奖项的最大人数需求，在满足条件的情况下逐步确定各奖项人数。

【拓展思路】
同类型题可能会有更多的奖项等级或更复杂的限制条件，但核心思路仍然是贪心，根据优先级和限制条件进行合理分配。

【推荐题目】
- P1223 排队接水（贪心算法，根据打水时间排序）
- P1094 纪念品分组（贪心算法，合理分组）
- P2240 分糖果（贪心算法，按一定规则分配）

【个人心得】无。

---
处理用时：25.50秒
# 题目信息

# Wilbur and Array

## 题目描述

小猪威尔伯又在试图修复数组了。他有一个数组 a[1],a[2],...,a[n] 最初由 n 个0组成。第一步，他可以选择任何一个下标 i 并让其下标之后的所有元素 a[i],a[i+1],...,a[n] 加1，或者减1。他的目标是得到数组 b[1],b[2],...,b[n]。

当然，威尔伯希望使用最少的步数挑战这个目标，并要求你计算这个值。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
5```

## 样例 #2

### 输入

```
4
1 2 2 1
```

### 输出

```
3```

# AI分析结果

【题目内容】
# 威尔伯与数组

## 题目描述
小猪威尔伯又在尝试修复数组了。他有一个数组 a[1], a[2], ..., a[n]，初始时该数组的 n 个元素均为 0。每一步，他可以选择任意一个下标 i，然后让下标 i 及其之后的所有元素 a[i], a[i + 1], ..., a[n] 加 1 或者减 1。他的目标是将数组 a 变为数组 b[1], b[2], ..., b[n]。

当然，威尔伯希望以最少的步数达成这个目标，现在要求你计算出这个最少步数。

## 样例 #1

### 输入
```
5
1 2 3 4 5
```

### 输出
```
5
```

## 样例 #2

### 输入
```
4
1 2 2 1
```

### 输出
```
3
```

【算法分类】
贪心

【综合分析与结论】
这些题解的核心思路都是利用贪心算法，由于每次操作是对数组后缀进行加 1 或减 1，不会影响前面的数值，所以从前往后依次满足目标数组元素的值，能保证操作次数最少。每个题解的不同主要体现在代码实现的简洁性和复杂度优化上。
- **思路**：均是从前往后依次让数组元素达到目标值，计算每次操作的步数并累加。
- **算法要点**：关键在于发现每次操作的步数为当前目标值与前一个目标值的差的绝对值，即 $\lvert b_i - b_{i - 1}\lvert$。
- **解决难点**：理解为什么从前往后依次满足条件能得到最少操作次数，需要通过具体例子进行感性理解。

【所选题解】
- **wanggk（4星）**：
  - **关键亮点**：思路清晰，通过具体例子解释贪心策略，代码简洁。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans=0;
long long a[200005];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++) ans+=abs(a[i]-a[i-1]);
    printf("%lld",ans); 
    return 0;
}
```
- **xhhhh36（4星）**：
  - **关键亮点**：明确指出使用贪心算法，思路简洁，代码规范。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
int b[200005];
signed main()
{
    scanf("%lld",&n);
    for (int i=1;i<=n;i++) scanf("%lld",b+i);
    for (int i=1;i<=n;i++) ans+=abs(b[i]-b[i-1]);
    printf("%lld",ans);
    return 0;
}
```
- **Tjl0427（4星）**：
  - **关键亮点**：对贪心策略进行了证明，通过具体例子展示运算过程，代码简洁。
  - **核心代码**：
```c
#include<bits/stdc++.h>
using namespace std;
long long a,ans=0,n,b;
int main()
{
    scanf("%lld",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%lld",&b);
        ans+=abs(a-b);
        a=b;
    }
    cout<<ans<<endl;
    return 0;
}
```

【最优关键思路或技巧】
- **贪心策略**：从前往后依次满足目标数组元素的值，每次操作的步数为当前目标值与前一个目标值的差的绝对值。
- **代码优化**：可以不使用数组，用一个变量记录前一个目标值，减少空间复杂度。

【拓展思路】
同类型题目可能会改变操作规则，例如每次操作可以选择一个区间进行加 1 或减 1，或者改变目标数组的初始状态等。解题时仍可考虑贪心策略，分析每次操作对数组元素的影响，找到最优的操作顺序。

【推荐题目】
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)

【个人心得】
题解中未包含个人心得内容。 

---
处理用时：27.88秒
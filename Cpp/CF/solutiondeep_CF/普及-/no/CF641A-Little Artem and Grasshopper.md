# 题目信息

# Little Artem and Grasshopper

## 题目描述

有一只蚱蜢和一个有着$n$个格子的条子，蚱蜢刚开始在第$1$个格子上。每个格子上都标有下次跳的方向以及距离。当蚱蜢跳出边界时就会停止。请问蚱蜢是否会一直跳下去？

## 样例 #1

### 输入

```
2
&gt;&lt;
1 2
```

### 输出

```
FINITE
```

## 样例 #2

### 输入

```
3
&gt;&gt;&lt;
2 1 1
```

### 输出

```
INFINITE```

# AI分析结果

【题目内容】
# 小阿尔乔姆和蚱蜢

## 题目描述

有一只蚱蜢和一个有着 $n$ 个格子的条子，蚱蜢刚开始在第 $1$ 个格子上。每个格子上都标有下次跳的方向以及距离。当蚱蜢跳出边界时就会停止。请问蚱蜢是否会一直跳下去？

## 样例 #1

### 输入

```
2
><
1 2
```

### 输出

```
FINITE
```

## 样例 #2

### 输入

```
3
>><
2 1 1
```

### 输出

```
INFINITE
```

【算法分类】
模拟

【综合分析与结论】
- **思路**：各题解思路基本一致，均是模拟蚱蜢的跳跃过程。当蚱蜢跳到同一个格子两次时，就会陷入无限循环，输出 `INFINITE`；当蚱蜢跳出条子边界时，就会停止跳跃，输出 `FINITE`。
- **算法要点**：使用数组记录每个格子的方向和距离，再用一个数组标记每个格子是否被访问过。通过循环或递归模拟蚱蜢的跳跃，根据方向和距离更新蚱蜢的位置，并检查是否满足无限循环或跳出边界的条件。
- **解决难点**：主要难点在于如何判断蚱蜢是否会无限循环，各题解均采用标记格子是否被访问过的方法解决此问题。

【所选的题解】
- 作者：cyz_czy (赞：1)，4星
  - 关键亮点：提供了递归和递推两种实现方式，代码逻辑清晰，注释详细。
  - 个人心得：一开始以为要将 `&lt;` 和 `&gt;` 两种表示法读取成 `<` 和 `>` 两种方向标，结果不是，提醒读者注意题目输入的细节。
- 作者：ZBH_123 (赞：0)，4星
  - 关键亮点：给出了 BFS 式和 DFS 式两种实现方式，并分析了时间复杂度为 $O(n)$。
- 作者：XMK_萌新 (赞：0)，4星
  - 关键亮点：思路清晰，代码简洁，对蚱蜢无限循环和跳出边界的情况分析明确。

【重点代码】
- **递归实现（cyz_czy）**：
```cpp
void f(int x){
    p[x]++;//踩一次
    if(p[x]==2){//若踩了两次则可以无限跳跃
        printf("INFINITE");
        exit(0);//直接终止程序
    }
    
    if(a[x-1]=='>')
        x+=l[x];
    else
        x-=l[x];//跳跃
    
    if(x>m||x<1){//若跳出界限则不能无限跳
        printf("FINITE");
        exit(0);//直接终止程序
    }
    
    f(x);//继续跳
    
    return ;//养成好习惯
}
```
核心思想：递归模拟蚱蜢的跳跃过程，每次跳跃后检查是否满足无限循环或跳出边界的条件。

- **BFS 式实现（ZBH_123）**：
```cpp
while(1){
    if(x>n||x<1){//越界就代表跳动结束
        cout<<"FINITE";
        return 0;
    }
    if(vis[x]){//跳到曾经跳到过的格子时，就代表跳动会陷入无限循环。
        cout<<"INFINITE";
        return 0;
    }
    vis[x]=true;//标记已走过
    x+=a[x]*b[x];//进行跳动
}
```
核心思想：使用 while 循环模拟蚱蜢的跳跃过程，每次跳跃后检查是否满足无限循环或跳出边界的条件。

- **XMK_萌新的实现**：
```cpp
while(1)
{
    if(idx<1||idx>n)	//跳出边界
    {
        cout<<"FINITE"; 
        break;
    }          
    if(vis[idx])	//以前跳过
    {
        cout<<"INFINITE";
        break;
    }
    vis[idx]=true;	//标记
    idx+=x[idx]*d[idx];	//移动，往左跳会加上一个负数（即减去d[idx]），往右跳会加上d[idx]。
}
```
核心思想：使用 while 循环模拟蚱蜢的跳跃过程，每次跳跃后检查是否满足无限循环或跳出边界的条件。

【最优关键思路或技巧】
- 使用数组标记每个格子是否被访问过，以此判断蚱蜢是否会陷入无限循环。
- 可以用正负值表示左右方向，简化跳跃位置的计算。

【拓展思路】
同类型题或类似算法套路：此类模拟问题通常需要根据题目给定的规则进行模拟操作，关键在于准确判断终止条件。例如模拟游戏角色的移动、机器人的行动等，都可以采用类似的思路，通过标记状态来判断是否进入循环或达到终止条件。

【推荐题目】
- P1042 [NOIP2003 普及组] 乒乓球
- P1067 [NOIP2009 普及组] 多项式输出
- P1098 [NOIP2007 提高组] 字符串的展开

---
处理用时：32.54秒
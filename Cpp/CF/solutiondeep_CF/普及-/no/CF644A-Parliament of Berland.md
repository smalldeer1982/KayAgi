# 题目信息

# Parliament of Berland

## 题目描述

$Berland$ 有 $n$ 名议员，编号为 $1$ ~ $n$ ，所有编号为奇数的议员都是民主党人，编号为偶数的议员都是共和党人。



新的议会集会厅是一个矩形，由 $a×b$ 把椅子组成——  $a$ 行，每行 $b$ 把椅子。横/纵坐标相差 $1$ 的椅子是相邻的，例如，第 $2$ 行的 $5 $号椅子与该行的 $4$ 和 $6$ 号椅子以及第 $1$ 和 $3$ 行的 $5$ 号椅子相邻。因此，除了大厅边缘的椅子外，每把椅子都与另外 $4$ 把椅子相邻。



如果一个政党的两名议员（即两个民主党人或两个共和党人）在相邻的椅子就座，他们将花费所有时间~~划水~~讨论党内问题。



对于给定的议员人数和大厅大小，确定是否有办法使同一政党的任何两个成员的座位都不相邻。

## 样例 #1

### 输入

```
3 2 2
```

### 输出

```
0 3
1 2
```

## 样例 #2

### 输入

```
8 4 3
```

### 输出

```
7 8 3
0 1 4
6 0 5
0 2 0
```

## 样例 #3

### 输入

```
10 2 2
```

### 输出

```
-1
```

# AI分析结果

【题目内容】
# 伯兰议会

## 题目描述

伯兰有 $n$ 名议员，编号为 $1$ ~ $n$ ，所有编号为奇数的议员都是民主党人，编号为偶数的议员都是共和党人。

新的议会集会厅是一个矩形，由 $a×b$ 把椅子组成 —— $a$ 行，每行 $b$ 把椅子。横/纵坐标相差 $1$ 的椅子是相邻的，例如，第 $2$ 行的 $5$ 号椅子与该行的 $4$ 和 $6$ 号椅子以及第 $1$ 和 $3$ 行的 $5$ 号椅子相邻。因此，除了大厅边缘的椅子外，每把椅子都与另外 $4$ 把椅子相邻。

如果一个政党的两名议员（即两个民主党人或两个共和党人）在相邻的椅子就座，他们将花费所有时间讨论党内问题。

对于给定的议员人数和大厅大小，确定是否有办法使同一政党的任何两个成员的座位都不相邻。

## 样例 #1

### 输入
```
3 2 2
```

### 输出
```
0 3
1 2
```

## 样例 #2

### 输入
```
8 4 3
```

### 输出
```
7 8 3
0 1 4
6 0 5
0 2 0
```

## 样例 #3

### 输入
```
10 2 2
```

### 输出
```
-1
```

【算法分类】
构造

【综合分析与结论】
- **思路对比**：各题解均先判断 $n > a×b$ 时无解，直接输出 $-1$。对于有解情况，大部分题解采用奇偶交替放置议员的方法，部分题解根据 $b$ 的奇偶性做不同处理，如 $b$ 为偶数时奇数行正着放、偶数行反着放，$b$ 为奇数时按顺序放置。
- **算法要点**：核心是构造出一种座位安排方案，使得相邻座位的议员奇偶性不同。主要通过两层循环遍历座位，根据条件放置议员编号或补 $0$。
- **解决难点**：关键在于如何保证同一政党的议员不相邻，通过奇偶交替放置或根据 $b$ 的奇偶性调整放置顺序来解决。

【所选的题解】
- __Kyw666__（4星）
  - 关键亮点：思路清晰，代码简洁易懂，直接通过行的奇偶性控制放置顺序。
  - 个人心得：无
- XXh0919（4星）
  - 关键亮点：代码规范，考虑了多余位置补 $0$ 的情况，逻辑完整。
  - 个人心得：无
- Y_J_Y（4星）
  - 关键亮点：有详细的注释，便于理解，同样采用奇偶行不同放置顺序的方法。
  - 个人心得：刚开始思维走偏，在同机房大佬帮助下纠正过来。

【重点代码】
- __Kyw666__ 的核心代码：
```cpp
if(n>a*b) {
    cout<<"-1";
    return 0;
}
for(int i=1;i<=a;i++) {
    if(i%2==0) {
        for(int j=1;j<=b;j++)
            if(k<=n) {
                mapp[i][j]=k;
                k++;
            }
    } else {
        for(int j=b;j>=1;j--)
            if(k<=n) {
                mapp[i][j]=k;
                k++;
            }
    }
}
```
核心思想：根据行的奇偶性，决定是从左到右还是从右到左放置议员编号。

- XXh0919 的核心代码：
```cpp
if(n>a*b) {
    puts("-1");
    return 0;
}
for(int i=1;i<=a;++i) {
    if(i%2==0) {
        for(int j=1;j<=b;++j) {
            if(cnt<=n) t[i][j]=cnt++;
            else t[i][j]=0;
        }
    } else {
        for(int j=b;j>=1;--j) {
            if(cnt<=n) t[i][j]=cnt++;
            else t[i][j]=0;
        }
    }
}
```
核心思想：同样根据行的奇偶性放置议员编号，对于多余位置补 $0$。

- Y_J_Y 的核心代码：
```cpp
if (a*b<n) {
    cout<<"-1";
} else {
    long long k=1;
    for (i=0;i<a;i++) {
        if (i%2==0) {
            for (j=0;j<b;j++) {
                if (k<=n) {
                    arr[i][j]=k;
                    k++;
                } else {
                    arr[i][j]=0;
                }
            }
        } else {
            for (j=b-1;j>=0;j--) {
                if (k<=n) {
                    arr[i][j]=k;
                    k++;
                } else {
                    arr[i][j]=0;
                }
            }
        }
    }
}
```
核心思想：按行的奇偶性不同方向放置议员编号，多余位置补 $0$。

【可拓展之处】
同类型题可能会改变座位相邻的规则，或者增加更多的约束条件，如议员有不同的属性，需要满足更多的放置要求。类似算法套路是先判断无解情况，再通过合理的构造方法找到可行解。

【推荐题目】
- P1003 铺地毯
- P1044 栈
- P1098 字符串的展开

【个人心得】
Y_J_Y：刚开始直接思维走偏，害了我打了很久，还好同机房的一个大佬帮助下纠正了过来。总结：做题时要仔细思考，遇到问题可向他人请教。 

---
处理用时：34.70秒
# 题目信息

# z-sort

## 题目描述

z学校的一位学生发现了一种叫做z排序的排序方法。如果数组a满足以下两个条件，那么称它为z排序后的:

1.对所有的偶数i，$a_i$>=$a_{i-1}$；

2.对所有的奇数i，$a_i$<=$a_{i-1}$。

例如，数组【1,2,1,2】和【1,1,1,1】是z排序过的，而数组【1,2,3,4】不是。

你能对一个数组进行z排序吗？

## 样例 #1

### 输入

```
4
1 2 2 1
```

### 输出

```
1 2 1 2
```

## 样例 #2

### 输入

```
5
1 3 2 2 5
```

### 输出

```
1 5 2 3 2
```

# AI分析结果

### 算法分类
排序

### 综合分析与结论
这些题解的核心思路大多是先对数组进行排序，然后通过不同的方式构造出满足 z 排序条件的数组。主要有以下几种思路：
1. **左右指针法**：排序后，使用两个指针分别从数组的首尾开始，依次输出最小和最大的数。
2. **交换法**：排序后，对于相邻的数对，当位置为偶数时交换两个数。
3. **优先队列法**：使用大根堆和小根堆分别存储数组元素，每次从堆中取出最大和最小的数。
4. **直接查找法**：每次遍历数组找出最大和最小的数，输出后标记为已使用。
5. **map 桶法**：使用 map 统计数组中每个元素的出现次数，然后依次输出最小和最大的数。

解决的难点主要在于处理数组长度为奇数的情况，以及保证每次输出的数满足 z 排序的条件。

### 所选题解
- **千反田（4星）**
    - **关键亮点**：思路清晰，代码简洁易懂，使用左右指针法从两侧向中间输出，处理奇数长度数组时进行特判。
- **绝顶我为峰（4星）**
    - **关键亮点**：通过交换相邻数对的方式构造逆序对，满足 z 排序条件，代码实现简单。
- **q779（4星）**
    - **关键亮点**：使用优先队列存储数组元素，方便获取最大和最小的数，思路新颖。

### 重点代码
#### 千反田
```cpp
#include<bits/stdc++.h>
int n,num[1000001];
void print(){
    int head=1,tail=n;
    while(head<tail)
        printf("%d %d ",num[head++],num[tail--]);
    if(head==tail)
        printf("%d",num[head]);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",&num[i]);
    sort(num+1,num+n+1);
    print();
    return ~~(0-0);
} 
```
**核心实现思想**：先对数组进行排序，然后使用左右指针从两侧向中间遍历，每次输出最小和最大的数，最后处理数组长度为奇数的情况。

#### 绝顶我为峰
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[1001];
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>a[i];
    sort(a+1,a+n+1);
    cout<<a[1];
    for(int i=3;i<=n;i+=2)
        cout<<" "<<a[i]<<" "<<a[i-1];
    if(n%2==0)
        cout<<" "<<a[n];
    cout<<endl;
    return 0;
}
```
**核心实现思想**：先对数组进行排序，第一个数不变，然后对于相邻的数对，当位置为偶数时交换两个数，最后处理数组长度为偶数的情况。

#### q779
```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register
#define int long long
priority_queue<int> q1;
priority_queue< int,vector<int>,greater<int> > q2;
int n;
signed main()
{
    scanf("%lld",&n);
    for(R int i=0,t; i<n; i++)
    {
        scanf("%lld",&t);
        q1.push(t);
        q2.push(t);
    }
    for(R int i=1; i<=n/2; i++)
    {
        printf("%lld %lld ",q2.top(),q1.top());
        q1.pop();q2.pop();
    }
    if(n&1)printf("%lld",q1.top());
    return 0;
}
```
**核心实现思想**：使用大根堆和小根堆分别存储数组元素，每次从堆中取出最大和最小的数输出，最后处理数组长度为奇数的情况。

### 最优关键思路或技巧
- 先对数组进行排序，为后续构造满足条件的数组提供基础。
- 使用左右指针、优先队列等数据结构和算法，方便获取最大和最小的数。
- 注意处理数组长度为奇数的情况，避免遗漏元素。

### 可拓展之处
同类型题或类似算法套路：
- 其他排序相关的构造问题，如构造满足特定条件的排列。
- 涉及数组元素处理和排序的问题，如数组的重排、分组等。

### 推荐题目
- [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
- [P1093 [NOIP2007 普及组] 奖学金](https://www.luogu.com.cn/problem/P1093)
- [P1059 [NOIP2006 普及组] 明明的随机数](https://www.luogu.com.cn/problem/P1059)

### 个人心得摘录与总结
- **绝顶我为峰**：提到题目可能开了 SPJ，因为 z - sort 不止一种，测试样例 2 输出另一个合法解也能 AC，说明该题答案不唯一。
- **北冥之子**：分享了自己的错误思路和改进方法，最初以为第一个数最小，且未处理好数组中只剩一个数的情况，导致第七个点被卡，后来通过特判和防止最大最小重复的操作解决了问题。
- **豌豆射手皮0608**：认为这题是除了某题以外最水的紫题，吐槽了恶意评分，还提到想用桶排但数据卡桶排，最后使用 map 解决问题。 

---
处理用时：35.15秒
# 题目信息

# Co-prime Array

## 题目描述

给你一个n个元素的数组，你必须尽可能少的添加元素使得该序列成为一个co-prime数组。

每次可以插入任何正整数不大于10^9在数组的任意位置。

如果一个数组的任意两个相邻的数是互质的，那么这个数组就是co-prime。

## 样例 #1

### 输入

```
3
2 7 28
```

### 输出

```
1
2 7 9 28
```

# AI分析结果

【题目翻译】
# 互质数组

## 题目描述
给你一个包含 n 个元素的数组，你必须尽可能少地添加元素，使得该序列成为一个互质数组。
每次可以在数组的任意位置插入不大于 10^9 的正整数。
如果一个数组中任意两个相邻的数互质，那么这个数组就是互质的。

## 样例 #1
### 输入
```
3
2 7 28
```
### 输出
```
1
2 7 9 28
```

【算法分类】
构造

【综合分析与结论】
- **思路对比**：大部分题解思路一致，都是遍历数组，检查相邻元素是否互质，若不互质则在中间插入一个合适的数，多数选择插入 1，也有选择插入大质数并进行特判的。
- **算法要点**：核心在于判断两数是否互质，使用的是求最大公约数（gcd）的方法，若最大公约数大于 1 则两数不互质。
- **解决难点**：主要难点在于确定插入什么数能使相邻元素互质，多数题解利用 1 与任何正整数都互质的性质，直接插入 1；部分题解选择插入大质数，但要考虑大质数可能在原数组中出现的情况，需要进行特判。

【所选题解】
- **shame_djj（4星）**：
  - **关键亮点**：思路清晰，代码结构良好，有自定义的快速读入函数，还对时间和空间复杂度进行了分析。
  - **个人心得**：提到本来想写空间复杂度为 O(1) 的代码但未成功，体现了对算法复杂度的思考。
- **FP·荷兰猪（4星）**：
  - **关键亮点**：代码简洁易懂，对解题思路有详细说明，分享了自己理解错误导致超时的经历，有一定参考价值。
  - **个人心得**：分享了自己刚开始理解错误，判断插入数要大于前一项小于后一项，导致超时的教训。
- **封禁用户（4星）**：
  - **关键亮点**：代码简洁，有关同步流加速输入输出的操作，还给出了运行结果截图。
  - **个人心得**：祝各位 OIers 进步 ++，体现了对同行的美好祝愿。

【重点代码】
以下是插入 1 的通用核心代码：
```cpp
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

// 以 shame_djj 的代码为例
int a[maxn], b[maxn];
int n, ans, cnt;
n = read();
for (register int i = 1; i <= n; i ++)
    a[i] = read();
for (register int i = 1; i < n; i ++) {
    b[++ cnt] = a[i];
    if (gcd(a[i], a[i + 1]) > 1)
        ans ++, b[++ cnt] = 1;
}
b[++ cnt] = a[n];
printf("%d\n", ans);
for (register int i = 1; i <= cnt; i ++)
    printf("%d ", b[i]);
```
**核心实现思想**：先读取数组元素，然后遍历数组，将元素依次放入新数组 `b` 中，若相邻元素不互质，则在 `b` 中插入 1，同时记录插入次数，最后输出插入次数和新数组。

【可拓展之处】
同类型题可能会有更多限制条件，如插入的数有特定范围或规则，或者对数组元素有更多操作要求。类似算法套路可以应用于其他构造类问题，通过分析问题的性质，找到一种简单且符合条件的构造方法。

【推荐题目】
1. P1072 [NOIP2009 提高组] Hankson 的趣味题
2. P1372 又是毕业季II
3. P2152 [SDOI2009] SuperGCD 

---
处理用时：23.44秒
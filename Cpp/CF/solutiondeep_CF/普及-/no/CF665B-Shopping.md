# 题目信息

# Shopping

## 题目描述

小 $W$​​ 的商店开始了线上购物，线下提货的服务。商店有 $k$​​ 个商品（编号 $1$ 到 $k$）， $n$ 个用户使用了这项服务。每个用户的订单都包含 $m$ 个商品，并在线付费，以  $a_{ij}$ 表示第 $i$ 个用户的订单中第 $j$ 个商品的编号。所有的商品是排成一排的，在小 $W$ 收到第 $i$ 件商品时，他会从前向后找所有的商品 $a_{ij}$  ( $1\le j\le m$ )，令 $pos(x)$ 表示该用户需要的编号为 $x$ 的商品，此时在序列中的位置。小 $W$ 需要 $pos(a_{i1})+pos(a_{i2})+...+pos(a_{im})$ 为第 $i$ 个客户服务的时间。当小 $W$ 访问第 $x$ 个元素时，他会将新的存货放到最前面，并将位置为 $x$ 的元素移除，因此，此序列是在不断更新的。你需要算出小 $W$​ 需要的时间。假设市场上有无尽的存货。

## 样例 #1

### 输入

```
2 2 5
3 4 1 2 5
1 5
3 1
```

### 输出

```
14
```

# AI分析结果

### 题目翻译
题目内容为中文，无需翻译。

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路都是模拟小 $W$ 处理订单的过程。对于每个用户的每个商品需求，在当前商品序列中找到该商品的位置，累加该位置到总时间，然后将该商品移到序列的最前面。

思路上，大家都采用直接模拟的方法，只是在数据结构的选择上有所不同，一部分题解使用 `vector` 来维护商品序列，另一部分题解使用数组来实现。

算法要点：
- 遍历每个用户的每个商品需求。
- 在商品序列中查找目标商品的位置。
- 累加位置到总时间。
- 将目标商品移到序列最前面。

解决难点：
- 如何高效地在序列中查找目标商品的位置。
- 如何正确地将目标商品移到序列最前面，同时保持其他商品的顺序。

### 题解评分与选择
- **_lgh_**：3星。思路清晰，使用 `vector` 实现模拟过程，但代码存在语法错误，影响可读性。
- **世末OIer**：3星。思路简洁，代码结构清晰，但使用了自定义的输入输出函数 `rdi` 和 `print`，增加了理解成本。
- **wangping**：3星。使用数组实现模拟，思路正确，但代码注释较少，理解起来有一定难度。
- **Creative_sad_yosgic**：4星。详细介绍了 `vector` 的使用方法，思路清晰，代码规范。
- **lmndiscyhyzdxss**：3星。思路正确，但代码存在变量未定义的错误，影响代码的正确性。
- **LOVE_Ynoi**：4星。思路清晰，详细介绍了使用的库函数，代码规范。
- **togeth1**：3星。思路清晰，代码结构合理，但注释较少，理解起来有一定难度。
- **yyyymh**：3星。使用数组实现模拟，思路正确，但代码注释较少，理解起来有一定难度。
- **Federico2903**：3星。思路清晰，使用 `vector` 实现模拟过程，但代码中 `erase` 操作的参数使用复杂，增加了理解成本。
- **Steven_lzx**：3星。只给出了关键代码，缺少完整的代码结构，理解起来有一定难度。

选择的题解：
- **Creative_sad_yosgic**：4星。关键亮点在于详细介绍了 `vector` 的使用方法，包括查找、删除、插入等操作，对于不熟悉 `vector` 的读者有很大帮助。
- **LOVE_Ynoi**：4星。关键亮点在于详细介绍了使用的库函数，思路清晰，代码规范。

### 重点代码
#### Creative_sad_yosgic 的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> mp;
int n,m,k,a,ans;
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++){
        cin>>a;
        mp.push_back(a);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>a;
            vector<int>::iterator id=find(mp.begin(),mp.end(),a);
            mp.erase(id);
            mp.insert(mp.begin(),a);
            ans+=id-mp.begin()+1;
        }
    cout<<ans<<'\n';
    return 0;
}
```
核心实现思想：使用 `vector` 存储商品序列，对于每个商品需求，使用 `find` 函数查找其位置，然后使用 `erase` 函数删除该商品，再使用 `insert` 函数将其插入到序列的最前面，同时累加该商品的位置到总时间。

#### LOVE_Ynoi 的题解
```c++
#include<bits/stdc++.h>
using namespace std;
vector<int> v;
int n,m,k;
int ans;
int main(){
    cin>>n>>m>>k;
    for(int i = 1;i<=k;i++){
        int x;
        scanf("%d",&x);
        v.push_back(x);
    }
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=m;j++){
            int x;
            scanf("%d",&x);
            int pos = find(v.begin(),v.end(),x)-v.begin();
            ans += (pos+1);
            v.erase(v.begin()+pos);
            v.insert(v.begin(),x);
        }
    }
    printf("%d",ans);
    return 0;
}
```
核心实现思想：同样使用 `vector` 存储商品序列，对于每个商品需求，使用 `find` 函数查找其位置，计算位置并累加到总时间，然后使用 `erase` 函数删除该商品，再使用 `insert` 函数将其插入到序列的最前面。

### 最优关键思路或技巧
- 使用 `vector` 这种动态数组来维护商品序列，利用其自带的 `find`、`erase` 和 `insert` 函数可以方便地实现查找、删除和插入操作。
- 对于数组实现的方法，通过倒序遍历将元素依次后移，实现将目标元素移到最前面的操作。

### 拓展思路
同类型题或类似算法套路：这类模拟题通常需要根据题目描述，一步一步地模拟整个过程，关键在于理清操作步骤和顺序。常见的应用场景包括游戏模拟、事件处理等。

### 推荐题目
- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098)

### 个人心得
题解中未包含个人心得。

---
处理用时：31.79秒
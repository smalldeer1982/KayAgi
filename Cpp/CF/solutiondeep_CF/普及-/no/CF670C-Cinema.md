# 题目信息

# Cinema

## 题目描述

莫斯科在举办一场重要的有$n$ 个不同国家的珂学家参与的国际会议，每个珂学家都只会一种语言。为了方便起见，我们规定一种语言用$1$ 到$10^9$ 的数来描述。 
在会议之后的晚上，珂学家们决定去看电影。他们去的电影院有$m$ 场电影，每场有两个不同的数字，分别代表配音的语言和字幕的语言。如果一个珂学家能听懂配音，他会非常愉悦；如果能看懂字幕，他会比较满意。如果既看不懂也听不懂，他会很生气。 
珂学家们决定去看同一场电影，你必须帮助他们选择一场电影，让愉悦的人最多的前提下，比较满意的人最多。

## 样例 #1

### 输入

```
3
2 3 2
2
3 2
2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6
6 3 1 1 3 7
5
1 2 3 4 5
2 3 4 5 1
```

### 输出

```
1
```

# AI分析结果

【题目内容】
# 电影院

## 题目描述
莫斯科正在举办一场重要的国际会议，有 $n$ 个来自不同国家的科学家参加，每个科学家只会一种语言。为方便起见，我们规定一种语言用 $1$ 到 $10^9$ 的数来描述。
会议结束后的晚上，科学家们决定去看电影。他们去的电影院有 $m$ 场电影，每场电影有两个不同的数字，分别代表配音的语言和字幕的语言。如果一个科学家能听懂配音，他会非常愉悦；如果能看懂字幕，他会比较满意。如果既看不懂也听不懂，他会很生气。
科学家们决定去看同一场电影，你必须帮助他们选择一场电影，使得愉悦的人最多，在此前提下，比较满意的人也最多。

## 样例 #1
### 输入
```
3
2 3 2
2
3 2
2 3
```
### 输出
```
2
```

## 样例 #2
### 输入
```
6
6 3 1 1 3 7
5
1 2 3 4 5
2 3 4 5 1
```
### 输出
```
1
```

【算法分类】
离散化

【综合分析与结论】
这些题解的核心思路都是先统计每种语言有多少科学家会，再遍历每场电影，找出愉悦人数最多且满意人数最多的电影。由于语言编号范围大（$1$ 到 $10^9$），直接开数组统计会超内存，因此大部分题解采用离散化或使用 `map` 来解决这一问题。
- **思路对比**：部分题解采用手写离散化，将所有出现的语言排序去重后映射到较小的编号；部分题解使用 `map` 直接进行映射，更方便但可能速度稍慢。还有题解使用 `hash` 表来优化查找速度。
- **算法要点**：离散化的关键在于排序、去重和二分查找；使用 `map` 则是直接利用其映射功能；`hash` 表需要合理选择模数以平衡时间和空间。
- **解决难点**：主要难点是处理语言编号范围大的问题，通过离散化、`map` 或 `hash` 表将其转化为可处理的范围。

【所选题解】
- **陷语（4星）**
  - **关键亮点**：思路清晰，代码可读性高，详细解释了离散化的过程，时间复杂度为 $O((n + m)\log(n + m))$。
  - **个人心得**：作者表示思路不难，只是WA了两遍，提醒要注意细节。
- **Rye_Catcher（4星）**
  - **关键亮点**：使用 `map` 进行离散化，思路简洁，还提到了用 `sort` 会在第125个点超时的问题。
  - **个人心得**：提醒 `mx`（最大值）要设成小于0的数，因为样例2中第一场电影的字幕可能没有一个人懂。
- **Ein_Niemand（4星）**
  - **关键亮点**：使用 `vector` 进行离散化，详细解释了 `unique` 和 `erase` 函数的用法，代码实现清晰。
  - **个人心得**：作者表示自己是蒟蒻，手打离散化虽然时间有点慢，但也能解决问题。

【重点代码】
### 陷语的离散化和二分搜索代码
```cpp
//离散化 
inline void discrete(int x) {
    int t = 0;
    sort(d + 1, d + 1 + x);
    for(int i = 1; i <= x; ++i)
        if(i == 1 || d[i] != d[i - 1]) e[++t] = d[i];//去重+离散 
    e[0] = t;//将去重后的长度直接保存在e[0]里面。 
}
//二分搜索 
inline int query(int x) {
    int l = 1, r = e[0], mid;//自己写的二分 
    while(l < r) {
        mid = (l + r) >> 1;
        if(e[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}
```
**核心实现思想**：`discrete` 函数将所有出现的语言排序去重，`query` 函数通过二分查找找到某个语言对应的离散化编号。

### Rye_Catcher的 `map` 离散化代码
```cpp
map <int,int> lan;
// ...
scanf("%d",&n);
for(register int i=1;i<=n;i++){
    read(x);
    lan[x]++;
}
```
**核心实现思想**：使用 `map` 直接统计每种语言出现的次数，实现离散化。

### Ein_Niemand的 `vector` 离散化代码
```cpp
vector<int>v;
// ...
read(a[i]),v.push_back(a[i]);
stable_sort(v.begin(),v.end());
v.erase(unique(v.begin(),v.end()),v.end());
int query(int x) {return lower_bound(v.begin(),v.end(),x)-v.begin()+1;}
```
**核心实现思想**：将所有语言存入 `vector`，排序去重后，通过 `query` 函数找到某个语言对应的离散化编号。

【可拓展之处】
同类型题或类似算法套路：
- 当遇到数据范围大但数据量小的情况，可以考虑使用离散化或 `map` 来处理。
- 对于需要统计和排序的问题，可以使用结构体存储相关信息，并重载比较函数进行排序。

【推荐题目】
1. [P1955 [NOI2015] 程序自动分析](https://www.luogu.com.cn/problem/P1955)：涉及离散化和并查集的应用。
2. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)：可以使用离散化来处理数据范围大的问题。
3. [P2574 XOR的艺术](https://www.luogu.com.cn/problem/P2574)：可能会用到离散化和线段树的知识。

【个人心得总结】
- 陷语：思路不难，但要注意细节，自己WA了两遍。
- Rye_Catcher：提醒 `mx` 要设成小于0的数，避免样例2中字幕无人懂的情况出错。
- Ein_Niemand：作为蒟蒻，手打离散化虽然时间慢，但也能解决问题。

---
处理用时：40.81秒
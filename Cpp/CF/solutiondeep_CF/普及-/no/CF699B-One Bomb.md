# 题目信息

# One Bomb

## 题目描述

你接到了一个拆除工作：

有一个 $n*m$ 个单元格的仓库，其中每个格子只可能是"."或"*"。

"."表示该格子为空，"*"表示这里有一面墙。

现在你有一枚炸弹，可以爆破所有同行或同列的墙(它既可以放在墙内，也可以放在空单元格)

请你找出一种放置炸弹的方式，使得所有的墙都能被清除。

## 样例 #1

### 输入

```
3 4
.*..
....
.*..
```

### 输出

```
YES
1 2
```

## 样例 #2

### 输入

```
3 3
..*
.*.
*..
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
6 5
..*..
..*..
*****
..*..
..*..
..*..
```

### 输出

```
YES
3 3
```

# AI分析结果

【题目内容】
# 一枚炸弹

## 题目描述

你接到了一个拆除工作：

有一个 $n*m$ 个单元格的仓库，其中每个格子只可能是"."或"*"。

"."表示该格子为空，"*"表示这里有一面墙。

现在你有一枚炸弹，可以爆破所有同行或同列的墙(它既可以放在墙内，也可以放在空单元格)

请你找出一种放置炸弹的方式，使得所有的墙都能被清除。

## 样例 #1

### 输入

```
3 4
.*..
....
.*..
```

### 输出

```
YES
1 2
```

## 样例 #2

### 输入

```
3 3
..*
.*.
*..
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
6 5
..*..
..*..
*****
..*..
..*..
..*..
```

### 输出

```
YES
3 3
```

【算法分类】
枚举

【综合分析与结论】
这些题解的核心思路都是通过枚举矩阵中的每个位置，判断在该位置放置炸弹是否能炸毁所有的墙。具体做法是先统计每一行和每一列的墙的数量，再在枚举时计算在该位置放置炸弹能炸毁的墙的数量，与总墙数比较。

不同题解的区别在于是否进行特判以及代码实现的细节。部分题解进行了一些特判，如 $n$ 或 $m$ 为 1、墙的数量为 0、1、2 等情况，可减少不必要的枚举。

【所选的题解】
- happybob（4星）：思路清晰，代码简洁，直接枚举所有位置，计算能炸毁的墙的数量与总墙数比较。
- fls233666（4星）：详细阐述了枚举的思路和优化方法，通过两个数组记录每行和每列的墙的数量，避免了重复统计。
- ADivT（4星）：使用三目运算符简化代码，在统计时注意了重复计数的问题。

【重点代码】
### happybob
```cpp
#include <cstdio>
#include <iostream>
using namespace std;

char a[1005][1005];
int cn[1005], cm[1005];

int main()
{
    int n, m, cnt = 0, cnt2 = 0;
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            cin >> a[i][j];
            if(a[i][j] == '*')
            {
                cnt++;
                cn[i]++;
                cm[j]++;
            }
        }
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            cnt2 = cn[i] + cm[j];
            if(a[i][j] == '*')
            {
                cnt2--;
            }
            if(cnt2 == cnt)
            {
                printf("YES\n%d %d\n", i, j);
                return 0;
            }
        }
    }
    printf("NO\n");
    return 0;
}
```
**核心实现思想**：先统计总墙数和每行每列的墙数，再枚举每个位置，计算该位置放置炸弹能炸毁的墙数，若等于总墙数则输出结果。

### fls233666
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main(){
    int n,m,z=0;
    cin>>n>>m;
    char mp[n+1][m+1];
    int zn[n+1],zm[m+1];
    memset(zn,0,sizeof(zn));
    memset(zm,0,sizeof(zm));
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>mp[i][j];
            if(mp[i][j]=='*'){
                zn[i]++;
                zm[j]++;
                z++;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int s,j=1;j<=m;j++){
            s=zn[i]+zm[j];
            if(mp[i][j]=='*')
                s--;
            if(z==s){
                cout<<"YES"<<endl<<i<<" "<<j;
                return 0;
            }
        }
    }
    cout<<"NO";
    return 0;
}
```
**核心实现思想**：同样先统计总墙数和每行每列的墙数，枚举时计算能炸毁的墙数，与总墙数比较。

### ADivT
```cpp
#include<bits/stdc++.h>

#define rep(i,o,p) for(register int i=o;i<=p;++i)

using namespace std; 

int n,m,is_p=0,tot=0;
char str[1010][1010];
int l[1010]={},r[1010]={};

int  main(){
    scanf("%d %d\n",&n,&m);
    rep(i,1,n){
        rep(j,1,m){
            str[i][j]=getchar();
            if(str[i][j]=='*'){
                ++l[i],++r[j],++tot; 
            }
        }
        getchar();
    }
    rep(i,1,n){
        rep(j,1,m){
            int s=l[i]+r[j]+((str[i][j]=='*')?-1:0);
            if(!(tot-s)&&(!is_p))is_p=printf("YES\n%d %d\n",i,j);
        }
    }
    if(!is_p)printf("NO\n");
    return 0;
}
```
**核心实现思想**：统计总墙数和每行每列墙数，枚举时用三目运算符处理重复计数问题，判断是否能炸毁所有墙。

【最优关键思路或技巧】
- 使用两个数组分别记录每行和每列的墙的数量，在枚举时可以快速计算出在该位置放置炸弹能炸毁的墙的数量，避免了重复统计，将时间复杂度控制在 $O(n*m)$。
- 对于特殊情况（如 $n$ 或 $m$ 为 1、墙的数量为 0、1、2 等）进行特判，可以减少不必要的枚举。

【拓展思路】
同类型题或类似算法套路：
- 对于矩阵中元素的遍历和统计问题，可以考虑使用数组记录每行每列的信息，以优化时间复杂度。
- 对于一些简单的模拟问题，可以先分析特殊情况进行特判，再进行一般性的枚举或模拟。

【推荐题目】
- P1003 [铺地毯](https://www.luogu.com.cn/problem/P1003)
- P1047 [校门外的树](https://www.luogu.com.cn/problem/P1047)
- P1098 [字符串的展开](https://www.luogu.com.cn/problem/P1098)

【个人心得】
- ADivT：三目运算符的优先级卡了半小时，提醒我们在使用三目运算符时要注意其优先级，必要时添加括号以确保运算顺序正确。

---
处理用时：48.03秒
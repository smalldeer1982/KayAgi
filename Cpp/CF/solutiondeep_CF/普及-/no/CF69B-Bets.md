# 题目信息

# Bets

## 题目描述

在chelyabinsk这个地方住着一个厉害的商人，他叫nikita。人人都叫他boss (老板的意思)。

有一天nikita跟朋友alex一起去一个叫做summer biathlon world cup (夏日滑雪世界杯？。)的比赛。

nikita因为是一个厉害的人，所以他拿到了一个神奇奖券。这个奖券可以让他赌谁赢，每个赛道不能赌超过一个选手。



------------


------------


这个比赛的规则是这样的：

有n个相等长度的赛道以及m个参赛者（编号1到m）。对于每个参赛者有以下信息：

- Li：始发赛道号码

- Ri：结束赛道号码（Li<=Ri）

- Ti：这个选手完成一个赛道的时间

- Ci：利润。。。单位是卢布（俄罗斯货币单位）。如果这个选手赢了，那么赌这个人会赢的人可以获得这么多钱。


第i个选手穿过从Li到Ri的赛道（包括Li和Ri），时间为(Ri-Li+1)·Ti个单位时间。每个赛道都需要Ti个单位时间。若这个选手在k个赛道中获得胜利，那么赌他会赢的人可以拿到k·Ci卢布。


在每个赛道中，每个独立的获胜者符合：


- 如果至少有一个选手在这个赛道中比赛，那么获胜者为花时间最少的人。花时间最少指仅在这个赛道上的花时间最少的人。


- 如果有多个选手用相同的时间，那么序号小的选手获胜。

- 如果这个赛道上没有选手，那么就没有获胜者。

注意：每个人的速度始终不变。


nikita可以在每个赛道上分别赌任何一个选手会赢。


帮助nikita和alex找到最大的利润。



------------


------------

## 说明/提示

**第一个测试数据**

第1-2个赛道赌选手1。

第3个赛道赌选手3。

第4个赛道赌选手4。

利润为5（赛道1）+5（赛道2）+30（赛道3）+20（赛道4）=60卢布。

**第二个测试数据**

第1，5个赛道赌选手1。

第2-4个赛道赌选手2。

第6-7个赛道赌选手4。

第八个赛道没有获胜者。

利润为10（赛道1）+15（赛道2-4）+10（赛道5）+20（赛道6，7）=105卢布。

## 样例 #1

### 输入

```
4 4
1 4 20 5
1 3 21 10
3 3 4 30
3 4 4 20
```

### 输出

```
60```

## 样例 #2

### 输入

```
8 4
1 5 24 10
2 4 6 15
4 6 30 50
6 7 4 20
```

### 输出

```
105```

# AI分析结果

【题目内容已为中文，无需翻译】

**算法分类**：枚举

**综合分析与结论**：
这些题解的核心思路都是枚举每个选手的赛道范围，找出每个赛道上花费时间最少的选手，记录其对应的利润，最后将每个赛道的最大利润累加得到总利润。
- **思路**：各题解均通过枚举选手和赛道，比较每个赛道上选手的花费时间，更新最短时间和对应的最大利润。
- **算法要点**：使用数组来记录每个赛道的最短时间和最大利润，通过两层循环遍历选手和赛道范围进行比较更新。
- **解决难点**：关键在于准确处理每个赛道上选手的时间比较，确保找到花费时间最少的选手，同时处理好无选手的赛道情况（部分题解通过初始化数组来处理）。

**题解评分**：
- Anonymous__user：3星，思路清晰，代码简洁，但初始化数值较随意。
- shenmadongdong：3星，代码简单，但存在多余的分号，影响代码规范性。
- 幻想繁星：3星，思路与其他题解类似，使用 `memset` 初始化数组。
- Fr0sTy：3星，思路清晰，使用宏定义 `inf` 表示无穷大，但数组大小定义较大。
- 小杨小小杨：3星，思路正确，通过保存选手下标来处理，但初始化方式较特别。

由于所有题解均不足4星，给出通用建议与扩展思路：
- **通用建议**：在代码中使用更规范的初始化方式，如使用 `INT_MAX` 或 `0x3f3f3f3f` 表示无穷大，提高代码的可读性和健壮性。同时，注意代码的规范性，避免出现多余的符号。
- **扩展思路**：此类枚举类型的题目，关键在于明确枚举的对象和条件，通过比较和更新来找到最优解。在处理类似问题时，可以先分析问题的本质，确定需要枚举的范围和比较的条件，然后使用合适的数据结构来记录和更新信息。

**重点代码**：
```cpp
// 以幻想繁星的题解为例，核心实现思想为枚举选手和赛道，更新最短时间和最大利润
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n,m,ans=0,x[1005],y[1005]={};
    cin>>n>>m;
    memset(x,0x3f3f,sizeof(x));
    for(int i=1;i<=m;i++)
    {
        int l,r,t,c;
        cin>>l>>r>>t>>c;
        for(int j=l;j<=r;j++) if(t<x[j])
        {
            x[j]=t;
            y[j]=c;
        }
    }
    for(int i=1;i<=n;i++) ans=ans+y[i];
    cout<<ans;
    return 0;	
}
```

**推荐洛谷题目**：
- P1047 [NOIP2005 普及组] 校门外的树
- P1420 最长连号
- P1035 [NOIP2002 普及组] 级数求和

**个人心得**：各题解均未包含个人心得。 

---
处理用时：24.58秒
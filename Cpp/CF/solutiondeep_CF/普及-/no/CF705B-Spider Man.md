# 题目信息

# Spider Man

## 题目描述

彼得·帕克想和章鱼博士玩一个游戏。游戏是关于循环的。循环是一个顶点序列，第一个顶点与第二个顶点相连，第二个顶点与第三个顶点相连，依此类推，最后一个顶点与第一个顶点再次相连。循环可以由单个独立顶点组成。



最初有k个循环，第i个循环由精确的vi个顶点组成。玩家可以选择。彼得先走。在每一回合中，玩家必须在所有可用循环中选择一个具有至少2个顶点（例如x顶点）的循环，并将其替换为两个循环，其中$1<=p<x$由玩家选择。无法移动的玩家将失去游戏（以及他的生命！）.



彼得想在和章鱼博士玩之前先测试一些初始周期的配置。最初他有一套空的。在第i个测试中，他将一个带有ai顶点的循环添加到集合中（这实际上是一个多集，因为它可以包含两个或更多相同的循环）。每次测试后，彼得都想知道，如果玩家以当前的循环开始游戏，谁会赢？



彼得数学很好，但现在他请你帮忙。

## 说明/提示

在第一个样例中：



在彼得的第一个测试中，只有一个1顶点的循环。第一名选手不能移动而输。



在他的第二个测试中，有一个循环有1个顶点，还有一个循环有2个顶点。没有人能用1个顶点在循环中移动。第一个玩家可以用两个1顶点的循环来代替第二个循环，第二个玩家不能移动和丢失。



在他的第三个测试中，循环有1、2和3个顶点。像上次测试一样，没有人能在第一个循环中移动。第一个玩家可以用一个1号和一个2号的循环替换第三个循环。现在循环有1，1，2，2个顶点。第二个玩家唯一的动作是用2个1号的循环来代替2号的循环。循环为1，1，1，1，2。第一个玩家用1号的2个循环替换最后一个循环并获胜。



在第二个样例中：



拥有大小为1的循环就像没有它们一样（因为没有人可以移动它们）。



在彼得的第三个测试中：有一个5号的循环（其他的并不重要）。第一个玩家有两个选择：用1号和4号或2号和3号的循环替换它。



如果他用尺寸为1和4的循环替换它：只有第二个循环才重要。第二个玩家将用2个2号的循环来代替它。第一个玩家的唯一选择是用两个1号的循环替换其中一个。第二个玩家对另一个循环做同样的事情。第一名选手不能移动，所以输了。



如果他用2号和3号的循环替换它：第二个玩家将用1号和2号的循环替换3号的循环。现在只有一个以上顶点的循环是两个大小为2的循环。如前一种情况所示，2圈2秒大小的玩家获胜。



所以，不管怎样，第一个玩家输了。

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
2
1
1
```

## 样例 #2

### 输入

```
5
1 1 5 1 1
```

### 输出

```
2
2
2
2
2
```

# AI分析结果

### 题目翻译
题目内容已为中文，无需翻译。

### 算法分类
数学

### 综合分析与结论
这些题解思路基本一致，都是通过分析得出每个数分解的次数为该数减 1，然后统计所有数分解次数的总和，根据总和的奇偶性判断先手（1）还是后手（2）获胜。同时都考虑到了数据范围可能会爆 `int`，所以使用 `long long` 类型。

### 题解列表
- **wangqinyan（5星）**
    - **关键亮点**：思路清晰，详细地通过模拟数据得出分解次数的规律，对数据范围的分析也很到位。
- **豆浆（4星）**
    - **关键亮点**：使用了快速读入模板，一定程度上优化了输入效率，代码结构清晰。
- **封禁用户（4星）**
    - **关键亮点**：通过多个具体例子详细分析得出分解次数的规律，逻辑严谨。

### 重点代码
```cpp
// wangqinyan的代码
#include<bits/stdc++.h>
using namespace std;
long long t,s,n;
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n;
        s+=(n-1);
        if(s%2==1)cout<<1<<endl;
        else
        cout<<2<<endl;
     } 
    return 0;
}

// 豆浆的代码
#include<bits/stdc++.h>
#pragma GCC optimize(3)
template <typename _Tp> inline void read(_Tp&x){
    char ch;bool flag=0;x=0;
    while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1;
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    if(flag)x=-x;
}
using namespace std;
int main(){
    long long  n,s=0,m;
    read(n);
    for(int i=1;i<=n;i++) {
        read(m);
        s+=m-1;
        if(s%2==1) {
            cout<<1<<endl;
        } 
        else{
            cout<<2<<endl;
        }
    }
    return 0;
}

// 封禁用户的代码
#include <bits/stdc++.h> 
using namespace std;
long long n,s,x;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>x;
        s+=x-1;
        if(s%2==1)
        cout<<1<<endl;
        else
        cout<<2<<endl;
    }
    return 0;
}
```
**核心实现思想**：先输入测试的次数，然后每次输入一个数，将该数减 1 累加到总和中，根据总和的奇偶性判断输出 1 （先手胜）还是 2 （后手胜）。

### 最优关键思路或技巧
- **思维方式**：通过模拟具体数据找出分解次数的规律，将复杂的游戏问题转化为简单的数学问题。
- **数据类型选择**：考虑到数据范围可能会爆 `int`，使用 `long long` 类型避免数据溢出。

### 拓展思路
同类型题或类似算法套路通常是博弈类问题，需要通过分析游戏规则找出必胜或必败的规律，然后根据规律进行判断。

### 推荐题目
- [P1288 取数游戏 II](https://www.luogu.com.cn/problem/P1288)
- [P2197 【模板】nim 游戏](https://www.luogu.com.cn/problem/P2197)
- [P2964 [USACO09NOV]A Coin Game S](https://www.luogu.com.cn/problem/P2964)

### 个人心得摘录与总结
- **_Sky_Dream_**：提到要注意数据范围，否则可能会出现错误，提醒大家做题时要仔细查看数据范围，选择合适的数据类型。 

---
处理用时：25.90秒
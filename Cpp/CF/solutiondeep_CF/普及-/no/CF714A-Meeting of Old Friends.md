# 题目信息

# Meeting of Old Friends

## 题目描述

今天森林里将要发生一件大事——刺猬 Filya 要去看望他的老朋友 Sonya！  
Sonya 身为一只傲娇的猫头鹰，当然要在白天睡觉。不过，她会在 $[l_1,r_1]$ 分钟内会保持清醒。作为一只美美的猫头鹰，在第 $k$ 分钟，Sonya 会补妆，这时她和 Filya 不能在一起。  
Filya 有很多工作要做，他预计在 $[l_2,r_2]$ 分钟去探望 Sonya。  
请你计算两人可以相处多长时间。

## 说明/提示

### 【样例一解释】
在第 $[9,10]$ 分钟相处。
### 【样例二解释】
在第 $[50,74]$ 分钟和第 $[76,100]$ 分钟在一起，第 $75$ 分钟时 Sonya 当然是去补妆辣！

Translated by @Ehrgeiz  @I_love_him52

## 样例 #1

### 输入

```
1 10 9 20 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
1 100 50 200 75
```

### 输出

```
50
```

# AI分析结果

【题目内容】
# 老友相聚

## 题目描述

今天森林里将要发生一件大事——刺猬 Filya 要去看望他的老朋友 Sonya！  
Sonya 身为一只傲娇的猫头鹰，当然要在白天睡觉。不过，她会在 $[l_1,r_1]$ 分钟内会保持清醒。作为一只美美的猫头鹰，在第 $k$ 分钟，Sonya 会补妆，这时她和 Filya 不能在一起。  
Filya 有很多工作要做，他预计在 $[l_2,r_2]$ 分钟去探望 Sonya。  
请你计算两人可以相处多长时间。

## 说明/提示

### 【样例一解释】
在第 $[9,10]$ 分钟相处。
### 【样例二解释】
在第 $[50,74]$ 分钟和第 $[76,100]$ 分钟在一起，第 $75$ 分钟时 Sonya 当然是去补妆辣！

Translated by @Ehrgeiz  @I_love_him52

## 样例 #1

### 输入

```
1 10 9 20 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
1 100 50 200 75
```

### 输出

```
50
```

【算法分类】
数学

【综合分析与结论】
这些题解的核心思路基本一致，都是先求出两个区间 $[l_1, r_1]$ 和 $[l_2, r_2]$ 的交集，交集的左边界为 $\max(l_1, l_2)$，右边界为 $\min(r_1, r_2)$，交集长度为 $\min(r_1, r_2) - \max(l_1, l_2) + 1$ 。然后判断补妆时间 $k$ 是否在这个交集区间内，如果在则将交集长度减 1 。同时，都考虑到了两个区间没有交集的特殊情况，此时直接输出 0 。

不同题解的差异主要体现在数据类型的选择（`long long` 或 `unsigned long long`）、输入输出方式（`scanf`、`cin` 或自定义读入函数）以及函数的实现（使用标准库的 `max`、`min` 或自定义函数）上。

【所选的题解】
- 作者：0xFF (赞：3)，4星。关键亮点：思路清晰，代码规范，使用自定义读入函数提高效率，对特殊情况有明确判断。
- 作者：PersistentLife (赞：2)，4星。关键亮点：提供测试数据，对解题过程中的错误和改进有详细说明，逻辑完整。
- 作者：CharlesZiy (赞：1)，4星。关键亮点：思路解释详细，对细节考虑周全，代码简洁易懂。

【重点代码】
作者：0xFF 的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#define int long long
using namespace std;
const int N = 10010;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
    return x*f;
}

signed main(){
    int l1 = read() , r1 = read() , l2 = read() , r2 = read() , k = read();
    if(l1 > r2 || r1 < l2){
        printf("0\n");
        return 0;
    }   
    int L = max(l1,l2);
    int R = min(r1,r2);
    int ans = R - L + 1;
    if(k >= L && k <= R) ans--;
    printf("%lld\n",ans);
    return 0;
}
```
核心实现思想：先使用自定义读入函数读取输入数据，然后判断两个区间是否有交集，若没有则直接输出 0 。若有交集，求出交集的左右边界，计算交集长度，再判断补妆时间是否在交集内，若在则将长度减 1 ，最后输出结果。

【关键思路或技巧】
- 对于区间交集问题，通过取两个区间左边界的最大值和右边界的最小值来确定交集的范围。
- 注意特殊情况的判断，即两个区间没有交集时直接输出 0 。
- 对于可能出现的数据范围较大的情况，合理选择数据类型（如 `long long` 或 `unsigned long long`）。

【拓展思路】
同类型题目可能会有多个区间求交集、区间合并等问题，解题思路类似，都是先确定区间的边界关系，再进行相应的计算。例如，多个区间求交集可以依次计算相邻两个区间的交集，最终得到所有区间的交集。

【推荐题目】
- P1886 滑动窗口 /【模板】单调队列
- P1168 中位数
- P1429 平面最近点对（加强版）

【个人心得】
- PersistentLife：交上去第 10 个点 WA 了，一开始程序输出负数，以为是 `long long` 存不下，改用 `unsigned long long` 后还是 WA ，最后发现要特判没有重叠的情况。
- CharlesZiy：本题难度评蓝偏高，属于小清新良心练手题，解题时要考虑两个人有空时间不重合、猫头鹰补妆等细节。 

---
处理用时：37.98秒
# 题目信息

# Passwords

## 题目描述

## 题目大意
Vanya想去他最喜欢的名为Codehorses的网站，他平时用n个密码作为他所有网站的密码。但是这天，Vanya突然忘了他的密码。
Vanya试的所有密码中，不存在某一次长度小于上一次的长度，他每次会随机试同一长度的密码（当这种长度试完后，会试下一长度的密码）。当他试对时，会瞬间批准进入网站。
他每次输入密码需要1秒，每连续k次输错后，需要等5秒再试下一次。他输密码的过程中不会休息停顿。
准确算出他进入网站最好情况和最差情况所需要的秒数。

## 样例 #1

### 输入

```
5 2
cba
abc
bb1
abC
ABC
abc
```

### 输出

```
1 15
```

## 样例 #2

### 输入

```
4 100
11
22
1
2
22
```

### 输出

```
3 4
```

# AI分析结果

【题目内容】
# 密码

## 题目描述

## 题目大意
Vanya想去他最喜欢的名为Codehorses的网站，他平时用n个密码作为他所有网站的密码。但是这天，Vanya突然忘了他的密码。
Vanya试的所有密码中，不存在某一次长度小于上一次的长度，他每次会随机试同一长度的密码（当这种长度试完后，会试下一长度的密码）。当他试对时，会瞬间批准进入网站。
他每次输入密码需要1秒，每连续k次输错后，需要等5秒再试下一次。他输密码的过程中不会休息停顿。
准确算出他进入网站最好情况和最差情况所需要的秒数。

## 样例 #1

### 输入

```
5 2
cba
abc
bb1
abC
ABC
abc
```

### 输出

```
1 15
```

## 样例 #2

### 输入

```
4 100
11
22
1
2
22
```

### 输出

```
3 4
```

【算法分类】
贪心

【综合分析与结论】
- **思路对比**：多数题解思路一致，先算出正确密码长度，将长度小于正确密码的密码全部试一遍。最好情况是试到长度为正确密码时第一遍就试对，最坏情况是试到长度为正确密码时最后一遍才试对。部分题解通过排序密码长度处理，部分使用桶排序统计各长度密码数量。
- **算法要点**：核心在于统计长度小于正确密码的密码数量和长度等于正确密码的密码数量，再结合每连续k次输错需等5秒的规则计算时间。
- **解决难点**：关键在于处理连续输错k次后的等待时间，以及试对密码时无需等待5秒的情况。部分题解通过特殊判断避免错误，部分通过合理计算次数巧妙规避。

【所选的题解】
- **作者：_l_l_ (赞：3)，4星**
    - **关键亮点**：思路清晰，代码简洁，直接统计长度小于和等于正确密码的密码数量，通过公式计算最好和最坏情况时间。
    - **重点代码**：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXN = 105;
char a[MAXN][MAXN];
char lim[MAXN];
int lenth[MAXN];
int main() {
    int n, k, aa = 0, bb = 0;
    scanf("%d %d", &n, &k);
    for (int i = 1; i <= n; i++) {
        memset(a, 0, sizeof a);
        scanf("%s", &a[i]);
        lenth[i] = strlen(a[i]);
    }
    scanf("%s", lim);
    int lm = strlen(lim);
    for (int i = 1; i <= n; i++) {
        if (lenth[i] < lm) aa++;
        else if (lenth[i] == lm) bb++;
    }
    printf("%d %d", ((aa) / k) * 5 + aa + 1, ((aa + bb - 1) / k) * 5 + aa + bb);
    return 0;
}
```
核心实现思想：先读取所有密码并记录长度，再读取正确密码并记录其长度。然后统计长度小于和等于正确密码的密码数量，最后根据规则计算最好和最坏情况所需时间。

- **作者：OldVagrant (赞：3)，4星**
    - **关键亮点**：按题意模拟，通过排序密码长度，逐步处理试密码过程，逻辑清晰。
    - **重点代码**：
```c
#include <bits/stdc++.h>
using namespace std;
#define ll int
#define rint register int
ll ans,n,k,ls,cnt,a[101],now,ans2;
string s,pswd;
int main(){
    scanf("%d%d",&n,&k);
    for(rint i=0;i<n;i++) cin>>s,a[i]=s.size();
    cin>>pswd,sort(a,a+n),ls=pswd.size();
    while(now<n&&a[now]<ls){
        ans++,cnt++,now++;
        if(cnt==k) ans+=5,cnt=0;
    }printf("%d ",ans+1);
    while(now<n&&a[now]==ls){
        ans++,cnt++,now++;
        if(cnt==k&&a[now]==ls) ans+=5,cnt=0;
    }printf("%d",ans);
    return 0;
}
```
核心实现思想：先读取所有密码并记录长度，再读取正确密码并记录其长度。对密码长度排序后，先处理长度小于正确密码的情况，计算最好情况时间；再处理长度等于正确密码的情况，计算最坏情况时间。

【最优关键思路或技巧】
- **桶排序思想**：使用桶排序统计各长度密码的数量，可简化计算过程，避免对密码字符串的复杂处理。
- **合理计算次数**：通过合理统计长度小于和等于正确密码的密码数量，结合每连续k次输错需等5秒的规则，巧妙计算最好和最坏情况时间，避免复杂的模拟过程。

【可拓展之处】
同类型题可能会改变试密码的规则，如增加不同长度密码的权重、改变等待时间规则等，但核心思路仍是统计相关密码数量并结合规则计算时间。类似算法套路可用于解决其他按条件尝试并计算最优和最差情况的问题。

【推荐题目】
- P1002 [NOIP2002 普及组] 过河卒
- P1048 [NOIP2005 普及组] 采药
- P1216 [USACO1.5] [IOI1994] 数字三角形 Number Triangles

【个人心得】
- **作者：Isshiki·Iroha**：提到看别人题解用数学知识不服，想用暴力模拟。在实现过程中遇到没有字符串长度比答案串长的情况，通过人为插入一个长度非常长的字符串解决。
- **作者：bmatrix**：表示题目很水但自己交了好几遍，说明即使题目简单也可能因细节问题出错。 

---
处理用时：42.99秒
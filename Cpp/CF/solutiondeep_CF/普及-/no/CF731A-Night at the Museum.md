# 题目信息

# Night at the Museum

## 题目描述

Grigoriy像某一喜剧电影中的英雄一样（我也不知道哪一部）晚上在博物馆里当保安。第一天晚上他收到了一个标签打印机。他要去给展馆里的文物一个个贴标签了。

这个标签打印机可以打印一张塑料标签。它打印的标签上的字母一个连着一个。打印机上有一个小写英文字母环，一个指向选中字母的指针和一个选中字母的按钮。字母环一个字母为一个，你想怎么转就怎么转，顺逆皆可。下面那张图为指针和字母环排列顺序。指针开始指向“a”。

Grigoriy添加一样新展品时需要打印出它的名字贴在上面。打完一个字母后不需要返回到字母“a”。

我们的英雄现在有点慌了。他感觉有些展品活过来了而且要锤他，所以他想赶快把名字打完回家。帮他找到打印字符串时字母环最少转动多少格。

## 说明/提示

1.从‘a’到‘z’（逆时针1格）  
2.从‘z’到‘e’（顺时针5格）   
3.从‘e’到‘u’（逆时针10格）   
4.从‘u’到‘s’（逆时针2格）

## 样例 #1

### 输入

```
zeus
```

### 输出

```
18
```

## 样例 #2

### 输入

```
map
```

### 输出

```
35
```

## 样例 #3

### 输入

```
ares
```

### 输出

```
34
```

# AI分析结果

### 题目翻译
#### 博物馆之夜

### 题目描述
Grigoriy 就像某部喜剧电影里的英雄（我也不清楚是哪一部）一样，晚上在博物馆当保安。第一天晚上，他收到了一台标签打印机。他要去给展馆里的文物逐个贴上标签。

这台标签打印机可以打印一张塑料标签。它打印的标签上的字母是一个接一个的。打印机上有一个小写英文字母环、一个指向选中字母的指针以及一个选中字母的按钮。字母环上每个字母为一个单位，你可以随意转动，顺时针或逆时针都行。下面这张图展示了指针和字母环的排列顺序。指针初始指向 “a”。

当 Grigoriy 添加一件新展品时，他需要打印出该展品的名字并贴在上面。打印完一个字母后，不需要返回到字母 “a”。

我们的英雄现在有点慌了。他感觉有些展品活过来了，而且要揍他，所以他想尽快打印完名字然后回家。请帮他找出打印字符串时字母环最少需要转动多少格。

### 说明/提示
1. 从 ‘a’ 到 ‘z’（逆时针 1 格）
2. 从 ‘z’ 到 ‘e’（顺时针 5 格）
3. 从 ‘e’ 到 ‘u’（逆时针 10 格）
4. 从 ‘u’ 到 ‘s’（逆时针 2 格）

### 样例 #1
#### 输入
```
zeus
```
#### 输出
```
18
```

### 样例 #2
#### 输入
```
map
```
#### 输出
```
35
```

### 样例 #3
#### 输入
```
ares
```
#### 输出
```
34
```

### 算法分类
字符串

### 分析与结论
本题的核心是计算打印给定字符串时字母环最少的转动格数。解题关键在于每次打印一个字母时，比较顺时针和逆时针转动到该字母的格数，取较小值累加起来。

### 各题解分析
- **liuyifan**：
    - **思路**：使用 `string` 存储输入的字符串，从初始字母 ‘a’ 开始，遍历字符串的每个字符，计算当前位置到目标字符顺时针和逆时针转动的最小格数并累加。还介绍了快读快写的方法。
    - **算法要点**：利用 `min(abs(tmp - s[i]), 26 - abs(tmp - s[i]))` 计算最小转动格数。
    - **解决难点**：处理字母环的顺时针和逆时针转动，通过比较取最小值。
    - **评分**：3 星。思路较清晰，但代码存在部分不完整的地方，如 `#include<bits` 不完整，`using namespace` 缺少命名空间。
- **lu_fish**：
    - **思路**：使用 `string` 存储输入，先计算从 ‘a’ 到第一个字符的最小转动格数，再遍历后续字符，依次计算相邻字符间的最小转动格数并累加。
    - **算法要点**：使用 `min(abs(s[i] - s[i - 1]), 26 - abs(s[i] - s[i - 1]))` 计算相邻字符间的最小转动格数。
    - **解决难点**：正确处理第一个字符与初始位置 ‘a’ 的转动计算，以及后续相邻字符的转动计算。
    - **评分**：4 星。思路清晰，代码简洁易懂，对变量初始化的提醒很关键。
- **stry**：
    - **思路**：使用字符数组存储输入，从初始字母 ‘a’ 开始，遍历字符数组，计算当前位置到目标字符顺时针和逆时针转动的最小格数并累加。
    - **算法要点**：利用 `min(abs(ch1 - ch[i]), 26 - abs(ch1 - ch[i]))` 计算最小转动格数。
    - **解决难点**：处理字符数组的输入和遍历，以及字母环的转动计算。
    - **评分**：3 星。思路正确，但代码风格较传统，使用了较多的 `stdio.h` 相关函数。
- **StudyingFather**：
    - **思路**：使用字符数组存储输入，从初始字母 ‘a’ 开始，遍历字符数组，计算当前位置到目标字符顺时针和逆时针转动的最小格数并累加。
    - **算法要点**：使用 `min(abs(arr - str[i]), 26 - abs(arr - str[i]))` 计算最小转动格数。
    - **解决难点**：处理字符数组的输入和遍历，以及字母环的转动计算。
    - **评分**：3 星。思路清晰，但代码风格与 stry 类似，使用了较多的 `stdio.h` 相关函数。

### 所选题解
- **lu_fish**：
    - **星级**：4 星
    - **亮点**：思路清晰，代码简洁易懂，对变量初始化的提醒很关键。

### 重点代码
```cpp
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
int main(){
    string s;
    cin>>s;
    int ans=0;
    ans+=min(abs(s[0]-'a'),26-abs(s[0]-'a'));
    for(int i=1;i<s.size();i++){
        ans+=min(abs(s[i]-s[i-1]),26-abs(s[i]-s[i-1]));
    }
    cout<<ans<<endl;
    return 0;
}
```
**核心实现思想**：先计算从初始位置 ‘a’ 到第一个字符的最小转动格数，然后遍历字符串后续字符，依次计算相邻字符间的最小转动格数并累加，最后输出结果。

### 关键思路或技巧
- 利用 `min(abs(c1 - c2), 26 - abs(c1 - c2))` 计算两个字母间顺时针和逆时针转动的最小格数。
- 注意变量的初始化，避免出现未定义的值。

### 可拓展之处
同类型题可能会改变字母环的规则，如字母环的字符范围变化、转动规则变化等，但解题思路仍然是比较不同转动方式的代价并取最小值。

### 推荐洛谷题目
- P1055 [NOIP2008 普及组] ISBN 号码
- P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here
- P1598 垂直柱状图

### 个人心得
liuyifan 提到在 c++ 中，`cin` 和 `cout` 在不加 `std::ios::sync_with_stdio(0)` 时速度较慢，且在 noip 中不能与 `freopen` 混用，还介绍了输入输出优化的方法，可在数据量大或卡常数的题目中使用。 

---
处理用时：39.52秒
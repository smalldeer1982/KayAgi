# 题目信息

# Urbanization

## 题目描述

## 题目大意

$n$个人要住进两个城市里，两个城市分别能住$n1$,$n2$个人。

$n$个人中，每个人都有一个财富值——第$i$个人的是$ai$。

现在请你安排这些人的入住，使得两个城市的每位居民的财富值**平均值的和**最大。（分别计算两个城市的财富值平均值，再相加）

当然，每一个人只能至多住进一个城市。

注意，并不是每一位居民都必须被安排住进两个城市中，没有被安排的居民直接回家。

## 说明/提示

$ 1≤n,n1,n2≤100000 $

$ n1+n2≤n $

$ 1≤ai≤100000 $


第一个样例中，可以让第一个居民住进第一个城市、让第二个居民住进第二个城市。

第二个样例中，让三号、四号居民住进第一个城市，让二号居民住进第二个城市。这样平均值的和最大，等于
$ (2+3)÷2+4÷1=6.5 $。

## 样例 #1

### 输入

```
2 1 1
1 5
```

### 输出

```
6.00000000
```

## 样例 #2

### 输入

```
4 2 1
1 4 2 3
```

### 输出

```
6.50000000
```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
这些题解的核心思路一致，均采用贪心算法，核心策略是让富裕的人居住在人少的城市，以使得两个城市的每位居民的财富值平均值的和最大。具体步骤为：先对所有人的财富值从大到小排序，取前 \(n1 + n2\) 个人，再将财富值排名靠前的人安排到人数较少的城市。各题解在证明贪心策略的方式上略有不同，但本质相同。在代码实现上，部分题解使用了快读、自定义比较函数等优化手段。

### 所选题解
- **pandaSTT（4星）**
    - **关键亮点**：思路清晰，对贪心策略有详细证明，代码中使用了快读优化输入。
    - **重点代码**：
```cpp
const int N=1e5+5;
int n,n1,n2;
struct node{
    int val;
    friend bool operator<(node x,node y){
        return x.val>y.val;
    }
}a[N];
double ans1,ans2;
signed main(){
    n=read(),n1=read(),n2=read();
    for(int i=1;i<=n;a[i++].val=read());
    sort(a+1,a+n+1);
    if(n1>n2){
        n1^=n2^=n1^=n2;
    }
    for(int i=1;i<=n1;i++){
        ans1+=a[i].val*1.0;
    }
    for(int i=n1+1;i<=n1+n2;i++){
        ans2+=a[i].val*1.0;
    }
    printf("%.8lf",(ans1/(n1*1.0))+(ans2/(n2*1.0)));
    return 0;
}
```
核心实现思想：先读取输入，将所有人的财富值存储在结构体数组中并从大到小排序，确保 \(n1\) 是较小的城市容量，然后分别计算两个城市的总财富值，最后计算并输出平均值的和。

- **cqbztz2（4星）**
    - **关键亮点**：思路简洁明了，代码实现简单易懂，有贪心策略的证明过程。
    - **重点代码**：
```cpp
int n,n1,n2,a[100005];
double ans1,ans2;
bool cmp(int x,int y){
    return x>y;
}
int main(){
    cin>>n>>n>>n2;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=min(n1,n2);i++){
        ans1+=a[i];
    }
    for(int i=min(n1,n2)+1;i<=n1+n2;i++){
        ans2+=a[i];
    }
    printf("%.6lf",(ans1/min(n1,n2))+(ans2/max(n1,n2)));
    return 0;
}
```
核心实现思想：读取输入后，对财富值数组从大到小排序，将前 \(min(n1, n2)\) 个人的财富值累加到 \(ans1\)，其余 \(n1 + n2 - min(n1, n2)\) 个人的财富值累加到 \(ans2\)，最后计算并输出平均值的和。

- **WinterRain208（4星）**
    - **关键亮点**：除了给出贪心策略及证明，还提出了快读、使用 `vector` 等优化建议。
    - **重点代码**：
```cpp
n=read(),n1=read(),n2=read();
if(n2>n1)pos=n2,n2=n1,n1=pos;
F(i,1,n)
    num=read(),v1.push_back(num);
sort(v1.begin(),v1.end(),cmp);
F(i,0,n2-1)tot1+=v1[i];
F(i,n2,n2+n1-1)tot2+=v1[i];
printf("%.8lf",(double)tot1/n2+(double)tot2/n1);
```
核心实现思想：读取输入并确保 \(n1\) 是较小的城市容量，将所有人的财富值存储在 `vector` 中并从大到小排序，分别计算两个城市的总财富值，最后计算并输出平均值的和。

### 最优关键思路或技巧
- **贪心策略**：让富裕的人居住在人少的城市，通过做差法证明该策略的正确性。
- **排序优化**：对所有人的财富值从大到小排序，方便后续选择财富值高的人。
- **输入输出优化**：使用快读和 `printf` 进行输入输出，提高程序效率。

### 可拓展之处
同类型题或类似算法套路：在资源分配问题中，若要使某个指标（如平均值、总和等）达到最优，可考虑贪心算法。先分析问题的特点，找出贪心策略，再通过数学证明策略的正确性。

### 推荐题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P2240 食草的奶牛](https://www.luogu.com.cn/problem/P2240)

### 个人心得
部分题解作者提到题目难度较低，如 “这道贪心也配做绿题？”，说明对于掌握贪心算法的人来说，本题难度不大。 

---
处理用时：36.04秒
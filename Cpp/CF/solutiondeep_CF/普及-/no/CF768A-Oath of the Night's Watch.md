# 题目信息

# Oath of the Night's Watch

## 题目描述

### 简要翻译

- 给定 $n$ 个非负整数 $a_{1 \ldots n}$。
- 你需要求出有多少个 $a_i$，满足：存在正整数 $j, k$，使得 $a_j < a_i$ 且 $a_k > a_i$。
- $1 \leqslant n \leqslant 10^5$；$\forall 1 \leqslant i \leqslant n$，有 $0 \leqslant a_i \leqslant 10^9$。


“长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。”——《守夜人誓言》

琼恩·雪诺的守夜开始了。他被派去守护管家。

这次他需要守护 $n$ 个管家。每个管家都有他自己的力量值 $a$。琼恩喜欢守护一个管家，当且仅当存在至少一个力量值严格小于这个管家的管家，且存在至少一个力量值严格大于这个管家的管家。

你知道琼恩喜欢守护多少管家吗？

## 说明/提示

#### 样例解释

- 样例 $1$ 解释：琼恩既不喜欢守护力量值为 $1$ 的管家，也不愿意守护力量值为 $5$ 的管家；因为没有任何一个管家的力量值小于 $1$，也没有任何一个管家的力量值大于 $5$。
- 样例 $2$ 解释：琼恩喜欢守护力量值为 $2$ 的管家，因为既有力量值小于 $2$ 的管家，也有力量值大于 $2$ 的管家。


- $1 \leqslant n \leqslant 10^5$。
- $\forall 1 \leqslant i \leqslant n,0 \leqslant a_i \leqslant 10^9$。

## 样例 #1

### 输入

```
2
1 5
```

### 输出

```
0```

## 样例 #2

### 输入

```
3
1 2 5
```

### 输出

```
1```

# AI分析结果

### 题目翻译
#### 《守夜人誓言》

#### 题目描述
- 给定 $n$ 个非负整数 $a_{1 \ldots n}$。
- 你需要求出有多少个 $a_i$，满足：存在正整数 $j, k$，使得 $a_j < a_i$ 且 $a_k > a_i$。
- $1 \leqslant n \leqslant 10^5$；$\forall 1 \leqslant i \leqslant n$，有 $0 \leqslant a_i \leqslant 10^9$。

“长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。”——《守夜人誓言》

琼恩·雪诺的守夜开始了。他被派去守护管家。

这次他需要守护 $n$ 个管家。每个管家都有他自己的力量值 $a$。琼恩喜欢守护一个管家，当且仅当存在至少一个力量值严格小于这个管家的管家，且存在至少一个力量值严格大于这个管家的管家。

你知道琼恩喜欢守护多少管家吗？

#### 说明/提示
##### 样例解释
- 样例 $1$ 解释：琼恩既不喜欢守护力量值为 $1$ 的管家，也不愿意守护力量值为 $5$ 的管家；因为没有任何一个管家的力量值小于 $1$，也没有任何一个管家的力量值大于 $5$。
- 样例 $2$ 解释：琼恩喜欢守护力量值为 $2$ 的管家，因为既有力量值小于 $2$ 的管家，也有力量值大于 $2$ 的管家。

- $1 \leqslant n \leqslant 10^5$。
- $\forall 1 \leqslant i \leqslant n,0 \leqslant a_i \leqslant 10^9$。

#### 样例 #1
##### 输入
```
2
1 5
```
##### 输出
```
0
```

#### 样例 #2
##### 输入
```
3
1 2 5
```
##### 输出
```
1
```

### 算法分类
排序

### 综合分析与结论
这些题解的核心思路都是找出给定数列中既不是最小值也不是最大值的数的个数。不同的题解采用了不同的方法来实现这一目标，主要分为两类：排序法和打擂台法。
- **排序法**：先对数组进行排序，然后找出最大值和最小值，再统计既不是最大值也不是最小值的数的个数。这种方法的时间复杂度主要取决于排序算法，通常为 $O(nlogn)$。
- **打擂台法**：通过遍历数组，直接找出最大值和最小值，并统计它们的数量，最后用总数减去最大值和最小值的数量。这种方法的时间复杂度为 $O(n)$，空间复杂度可以做到 $O(1)$。

### 所选题解
- **作者：_xbn (赞：3)，4星**
    - **关键亮点**：思路清晰，代码简洁，通过两次遍历数组，先找出最大值和最小值，再统计既不是最大值也不是最小值的数的个数。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100002;
int n,m,k,p,q=0x7fffffff,ans,sun,tot,cnt,a[N],b[N],c[N];
int main()
{
    cin>>n;
    ans=n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        p=max(p,a[i]);
        q=min(q,a[i]);
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]==p||a[i]==q)ans--;
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先遍历数组，找出最大值 $p$ 和最小值 $q$，再遍历数组，将等于最大值或最小值的数的个数从总数 $n$ 中减去，得到最终结果。

- **作者：Houraisan_Kaguya (赞：1)，4星**
    - **关键亮点**：空间复杂度为 $O(1)$，在遍历数组的过程中同时统计最大值和最小值的数量，避免了额外的数组空间开销。
    - **核心代码**：
```cpp
enum Max { A = (unsigned int)1e9 }; enum Inf { Inf = A };
unsigned int inline read(); void const inline write(unsigned int const);
unsigned int const n(read());
unsigned int min(Inf), mincnt(0), max(0), maxcnt(0);

signed int main() {
    for (unsigned int register i(1); i <= n; ++i) {
        unsigned int const a(read());
        if (a <= min) {
            if (a < min) min = a, mincnt = 1;
            else ++mincnt;
        }
        if (a >= max) {
            if (a > max) max = a, maxcnt = 1;
            else ++maxcnt;
        }
    }
    write(n - (min == max ? mincnt : mincnt + maxcnt));
    return 0;
}
```
核心实现思想：在遍历数组的过程中，根据当前元素与最小值和最大值的大小关系，更新最小值、最大值以及它们的数量，最后用总数减去最大值和最小值的数量，得到最终结果。

### 最优关键思路或技巧
- **打擂台法**：通过一次遍历数组，同时找出最大值和最小值，避免了排序带来的 $O(nlogn)$ 时间复杂度，时间复杂度为 $O(n)$。
- **空间优化**：在打擂台的过程中，只需要记录最大值、最小值以及它们的数量，不需要额外的数组空间，空间复杂度可以做到 $O(1)$。

### 拓展思路
同类型题目通常会涉及到数组元素的比较和统计，例如找出数组中的第二大值、第三小值等。可以采用类似的打擂台方法，在遍历数组的过程中记录多个最值，从而解决问题。

### 推荐题目
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

### 个人心得摘录与总结
- **作者：Colead**：提到冒泡排序 $O(n^2)$ 会超时，计数排序因 $a[i]$ 范围太大不适用，而 $sort$ 排序 $O(nlogn)$ 可以考虑，并且在第一次实现代码错误后，仔细分析得出正确的判断条件，强调了分析问题的重要性。 

---
处理用时：41.92秒
# 题目信息

# Pupils Redistribution

## 题目描述

在Berland每一个高中生的成绩都很有特点 — 一个在$1$ 和$5$ 之间的整数。

在高中0xFF有两个学生小组，每个小组都有$n$ 名学生。每名学生的成绩就像所知的 — 一个在$1$ 和$5$ 之间的整数。

学校主任想要在小组间重新分配这些学生以达到在两个小组间成绩为$1$ 的学生数量相等，成绩为$2$ 的学生数量相等，以此类推。换句话说，学校主任的目的是，在改变完学生的组成后，每个成绩在两个小组都有相同的人数。

实现这个的方式是，有计划的在小组间进行一系列的学生交换。每次交换中主任都会从$A$ 班(原文就是班，实际应该是组的意思)中选一名学生，再从B班中选一名学生。然后，交换他们所属的组。

输出最少的交换数，来使得每个成绩在两个小组都有相同的人数。

## 样例 #1

### 输入

```
4
5 4 4 4
5 5 4 5
```

### 输出

```
1
```

## 样例 #2

### 输入

```
6
1 1 1 1 1 1
5 5 5 5 5 5
```

### 输出

```
3
```

## 样例 #3

### 输入

```
1
5
3
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
9
3 2 5 5 2 3 3 3 2
4 1 4 1 1 2 4 4 1
```

### 输出

```
4
```

# AI分析结果

【题目内容】
# 学生重新分配

## 题目描述

在Berland，每个高中生的成绩都有一个特点——是一个介于1到5之间的整数。

在0xFF高中有两个学生小组，每个小组都有 $n$ 名学生。每名学生的成绩就像已知的那样——是一个介于1到5之间的整数。

学校主任想要在小组间重新分配这些学生，以达到在两个小组间成绩为1的学生数量相等，成绩为2的学生数量相等，以此类推。换句话说，学校主任的目的是，在改变完学生的组成后，每个成绩在两个小组都有相同的人数。

实现这个的方式是，有计划地在小组间进行一系列的学生交换。每次交换中主任都会从A班（原文就是班，实际应该是组的意思）中选一名学生，再从B班中选一名学生。然后，交换他们所属的组。

输出最少的交换数，来使得每个成绩在两个小组都有相同的人数。

## 样例 #1

### 输入
```
4
5 4 4 4
5 5 4 5
```

### 输出
```
1
```

## 样例 #2

### 输入
```
6
1 1 1 1 1 1
5 5 5 5 5 5
```

### 输出
```
3
```

## 样例 #3

### 输入
```
1
5
3
```

### 输出
```
-1
```

## 样例 #4

### 输入
```
9
3 2 5 5 2 3 3 3 2
4 1 4 1 1 2 4 4 1
```

### 输出
```
4
```

【算法分类】
模拟

【综合分析与结论】
- **思路对比**：各题解思路大致相同，先统计两个小组各个成绩的数量，然后判断是否存在某个成绩的总人数为奇数，若存在则无解输出 -1，若不存在则计算需要交换的学生数量。计算交换数量时，有的题解通过计算每个成绩在两组中的人数差，有的通过计算每个成绩在一组中的人数与总人数一半的差值。
- **算法要点**：使用数组来统计每个成绩的人数，通过判断人数奇偶性确定是否有解，最后根据人数差计算最少交换次数，且都需注意最后结果要除以 2。
- **解决难点**：主要难点在于理解为什么最后结果要除以 2，因为一次交换会改变两个成绩的分布情况，所以计算出的总差值要除以 2 才是实际的交换次数。

【所选的题解】
- 作者：封禁用户 (赞：4)，4星。关键亮点：代码简洁，通过一个数组统计两组分数差，逻辑清晰。
- 作者：guozhetao (赞：3)，4星。关键亮点：思路解释详细，对为什么要除以 2 进行了样例分析，易于理解。
- 作者：_JF_ (赞：3)，4星。关键亮点：思路简单直接，对无解情况的判断和交换次数的计算逻辑明确。

【重点代码】
- **封禁用户的题解核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int otf[120], ans;
int main() {
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) {
        int ele;
        cin>>ele;
        otf[ele]++;//A组分数
    }
    for(int i=1;i<=n;i++) {
        int ele;
        cin>>ele;
        otf[ele]--;//每组分数差
    }
    for(int i=1;i<=5;i++) {
        if(abs(otf[i])%2==1) {
            cout<<-1;
            return 0;
        }
        ans+=abs(otf[i]);//绝对值
    }
    cout<<ans/4;//已证明
    return 0;
}
```
核心实现思想：用 `otf` 数组统计两组分数差，若某个成绩的分数差为奇数则无解，否则累加分数差的绝对值，最后结果除以 4。

- **guozhetao 的题解核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[105],b[105]; 
int danci[6],dancia[6];//统计次数 
int main() {
    scanf("%d",&n);
    for(int i = 1;i <= n;i++) {
        scanf("%d",&a[i]);
        danci[a[i]]++;
        dancia[a[i]]++;
    }
    for(int i = 1;i <= n;i++) {
        scanf("%d",&b[i]);
        danci[b[i]]++;
    }
    for(int i = 1;i <= 5;i++) {
        if(danci[i] % 2 == 1) {
            printf("-1\n");
            return 0;
        }
    }
    int ans = 0;
    for(int i = 1;i <= 5;i++) {
        ans += abs(dancia[i] - danci[i] / 2);
    }
    ans /= 2;//别忘记除以二
    printf("%d\n",ans);
}
```
核心实现思想：用 `danci` 数组统计每种分数的总人数，`dancia` 数组统计 A 小组每种分数的人数，若某个分数总人数为奇数则无解，否则计算 A 小组每种分数人数与总人数一半的差值的绝对值之和，最后结果除以 2。

- **_JF_ 的题解核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
int a[N],b[N];
int sa[N],sq[N];
int main()
{
    int ans=0;
    int n;
    cin>>n;
    int maxx=0;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        sa[a[i]]++;
        maxx=max(maxx,a[i]);
    }
    for(int i=1;i<=n;i++)
    {
        cin>>b[i];
        sq[b[i]]++;
        maxx=max(maxx,b[i]);
    }
    for(int i=1;i<=maxx;i++)
    {
        if((sa[i]+sq[i])%2==1)
        {
            cout<<"-1";
            return 0;
        }
        if(sa[i]==0&&sq[i]==0)
            continue;
        ans+=abs(sa[i]-sq[i])/2;
    }
    cout<<ans/2<<endl;
}
```
核心实现思想：用 `sa` 数组统计第一组每个分数段出现的人次，`sq` 数组统计第二组每个分数段出现的人次，若某个分数段总人数为奇数则无解，否则计算两组该分数段人数差的一半的和，最后结果除以 2。

【最优关键思路或技巧】
- 使用数组来统计每个成绩的人数，方便后续计算和判断。
- 理解一次交换会改变两个成绩的分布情况，所以最后计算出的总差值要除以 2 才是实际的交换次数。

【拓展思路】
同类型题可能会改变成绩的范围、小组的数量或者交换的规则等，但核心思路还是先统计数量，再判断是否有解，最后计算最少操作次数。类似算法套路可以应用在很多需要平衡分配的问题中，比如资源分配、任务调度等。

【推荐题目】
- P1047 [NOIP2005 普及组] 校门外的树
- P1090 [NOIP2004 提高组] 合并果子
- P1164 小A点菜

【个人心得】
题解中暂无个人心得相关内容。

---
处理用时：48.32秒
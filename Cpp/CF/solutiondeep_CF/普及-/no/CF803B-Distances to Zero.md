# 题目信息

# Distances to Zero

## 题目描述

You are given the array of integer numbers $ a_{0},a_{1},...,a_{n-1} $ . For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.

## 样例 #1

### 输入

```
9
2 1 0 3 0 0 3 2 4
```

### 输出

```
2 1 0 1 0 0 1 2 3 ```

## 样例 #2

### 输入

```
5
0 1 2 3 4
```

### 输出

```
0 1 2 3 4 ```

## 样例 #3

### 输入

```
7
5 6 0 1 -2 3 4
```

### 输出

```
2 1 0 1 2 3 4 ```

# AI分析结果

### 题目翻译
# 到零的距离

## 题目描述
给定一个整数数组 $ a_{0},a_{1},...,a_{n - 1} $。对于数组中的每个元素，求出它到最近的零（即值为零的元素）的距离。给定数组中至少有一个零元素。

## 样例 #1
### 输入
```
9
2 1 0 3 0 0 3 2 4
```
### 输出
```
2 1 0 1 0 0 1 2 3
```

## 样例 #2
### 输入
```
5
0 1 2 3 4
```
### 输出
```
0 1 2 3 4
```

## 样例 #3
### 输入
```
7
5 6 0 1 -2 3 4
```
### 输出
```
2 1 0 1 2 3 4
```

### 算法分类
枚举

### 综合分析与结论
这些题解的核心思路都是通过某种方式找到每个元素左右两侧最近的零元素，然后取距离的最小值作为该元素到最近零元素的距离。

- **思路对比**：
    - 大部分题解采用两次遍历数组的方式，一次从左到右，一次从右到左，分别记录每个元素到左侧和右侧最近零元素的距离。
    - 部分题解通过枚举零元素，然后向左右两侧扩展来更新距离。
- **算法要点**：
    - 初始化距离数组为一个较大的值，方便后续更新。
    - 记录零元素的位置，用于计算距离。
    - 取左右距离的最小值作为最终结果。
- **解决难点**：
    - 处理边界情况，确保每个元素都能正确计算到最近零元素的距离。
    - 避免重复计算，提高效率。

### 题解评分与推荐
- **tryrtj（4星）**：
    - **关键亮点**：思路清晰，代码简洁易懂，通过两次遍历数组分别计算左右距离，最后取最小值。
    - **个人心得**：无
- **jzh817（4星）**：
    - **关键亮点**：使用一个变量记录当前位置到零的距离，代码实现简洁，逻辑清晰。
    - **个人心得**：强调了变量初始化的重要性，尤其是在处理边界情况时。

### 重点代码
#### tryrtj的题解
```cpp
#include<iostream>
#include<algorithm>//min函数要用
using namespace std;
int a[200005],b[200005];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];//读入
        b[i]=0x7fffffff;//初始为无穷大
    }
    int q=-1;
    for(int i=0;i<n;i++){
        if(a[i]==0){
            q=i;//找左边最近的点
        }
        if(q!=-1)b[i]=i-q;//赋值
    }
    q=-1;
    for(int i=n-1;i>=0;i--){
        if(a[i]==0){
            q=i;//找右边最近的点
        }
        if(q!=-1){
            b[i]=min(b[i],q-i);//赋值
        }
    }
    for(int i=0;i<n;i++){
        cout<<b[i]<<' ';//输出
    }
    return 0;
}
```
**核心实现思想**：先从左到右遍历数组，记录每个元素到左侧最近零元素的距离；再从右到左遍历数组，记录每个元素到右侧最近零元素的距离，最后取两者的最小值。

#### jzh817的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read(){
    ll a=0,b=getchar(),c=1;
    while(!isdigit(b))c=b=='-'?-1:1,b=getchar();
    while(isdigit(b))a=a*10+b-'0',b=getchar();
    return a*c;
}
int n,x=1e9,a[200005],b[200005];
int main(){
    memset(b,0x3f,sizeof(b));
    n=read();
    for(int i=0;i<n;i++)
        a[i]=read();
    for(int i=0;i<n;i++){
        if(a[i]==0)x=0;
        b[i]=x,x++;
    }
    x=1e9;
    for(int i=n-1;i>=0;i--){
        if(a[i]==0)x=0;
        b[i]=min(x,b[i]),x++;
    }
    for(int i=0;i<n;i++)
        printf("%d ",b[i]);
    return 0;
}
```
**核心实现思想**：使用变量 `x` 记录当前位置到零的距离，从左到右和从右到左分别遍历数组，更新每个元素到最近零元素的距离。

### 最优关键思路或技巧
- 采用两次遍历数组的方法，分别计算左右距离，最后取最小值，避免了重复计算，提高了效率。
- 初始化距离数组为一个较大的值，方便后续更新。

### 拓展思路
同类型题目可以是求每个元素到某个特定元素的距离，或者在二维数组中求每个点到特定点的最短距离，解题思路类似，只是需要考虑更多的方向和边界情况。

### 推荐洛谷题目
- P1090 [NOIP2004 提高组] 合并果子（贪心算法，与本题思路不同，但可锻炼算法思维）
- P1164 小A点菜（动态规划，锻炼状态转移的思维）
- P1420 最长连号（模拟，与本题的遍历数组思想有一定关联）

---
处理用时：36.33秒
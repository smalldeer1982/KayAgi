# 题目信息

# Flag of Berland

## 题目描述

Berland之旗是满足以下条件的 $n \times m$ 矩形区域：

- 旗中包含三种颜色，相应地以字母“R”, “G”和“B”表示。

- 旗中包含三个“长条”，他们的长度和宽度相等（长条1的长度等于长条2的长度，也等于长条3的长度，宽度类似），并且互相平行，同时还平行于旗子的边缘。每个“长条”仅有一种颜色。

- 每个颜色仅能在一个“长条”中出现。 

现在给定由“R”, “G”和“B”构成的 $n \times m$ 矩形区域。请判断它是否是一个正确的Berland之旗，是则输出 "YES"，否则输出"NO"。

## 说明/提示

第三个样例中的区域不包含平行的“长条”。

第四个样例中虽然“长条”间互相平行，且都平行于边缘，但他们高度不同——2，1和1。

## 样例 #1

### 输入

```
6 5
RRRRR
RRRRR
BBBBB
BBBBB
GGGGG
GGGGG
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4 3
BRG
BRG
BRG
BRG
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
6 7
RRRGGGG
RRRGGGG
RRRGGGG
RRRBBBB
RRRBBBB
RRRBBBB
```

### 输出

```
NO
```

## 样例 #4

### 输入

```
4 4
RRRR
RRRR
BBBB
GGGG
```

### 输出

```
NO
```

# AI分析结果

【题目内容】
# 伯兰国旗

## 题目描述

伯兰国旗是一个满足以下条件的 $n \times m$ 矩形区域：

- 旗帜中包含三种颜色，分别用字母“R”、“G”和“B”表示。
- 旗帜中包含三个“长条”，它们的长度和宽度相等（长条 1 的长度等于长条 2 的长度，也等于长条 3 的长度，宽度同理），并且互相平行，同时还平行于旗帜的边缘。每个“长条”仅有一种颜色。
- 每种颜色仅能在一个“长条”中出现。 

现在给定一个由“R”、“G”和“B”构成的 $n \times m$ 矩形区域。请判断它是否是一个正确的伯兰国旗，是则输出 "YES"，否则输出 "NO"。

## 说明/提示

第三个样例中的区域不包含平行的“长条”。

第四个样例中虽然“长条”间互相平行，且都平行于边缘，但它们的高度不同——2，1 和 1。

## 样例 #1

### 输入

```
6 5
RRRRR
RRRRR
BBBBB
BBBBB
GGGGG
GGGGG
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4 3
BRG
BRG
BRG
BRG
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
6 7
RRRGGGG
RRRGGGG
RRRGGGG
RRRBBBB
RRRBBBB
RRRBBBB
```

### 输出

```
NO
```

## 样例 #4

### 输入

```
4 4
RRRR
RRRR
BBBB
GGGG
```

### 输出

```
NO
```

【算法分类】
模拟

【综合分析与结论】
这些题解的整体思路较为相似，都是先对一些明显不符合条件的情况进行特判，如 $n$ 和 $m$ 都不能被 3 整除，或者矩阵中没有包含“R”、“G”、“B”三种颜色。然后分别对横向和竖向的长条情况进行判断，检查每个长条内的颜色是否一致，且三种颜色各不相同。

不同题解的实现方式略有差异，有的通过统计字符数量来判断，有的通过直接比较字符是否相同来判断。

【所选的题解】
- array2022 的题解（4 星）
  - 关键亮点：思路清晰，代码结构良好，通过一个 `check` 函数来判断字符数量是否符合要求，逻辑较为简洁。
  - 个人心得：无

【重点代码】
```cpp
bool check(){//判断是否全为 0 或 n*m/3。
    for (t=0;t<3;t++){
        if (b[ch[t]]!=0&&b[ch[t]]!=n*m/3){
            return 0;
        }
    }
    return 1;
}
int main(){
    cin>>n>>m;
    for (i=0;i<n;i++){
        for (j=0;j<m;j++){
            cin>>f[i][j];
        }
    }
    if (n%3==0){//开始横条判断。
        for (k=0;k<3;k++){
            for (i=k*n/3;i<(k+1)*n/3;i++){//遍历一个条。k*n/3表示开始的位置，(k+1)*n/3 表示结束的位置。
                for (j=0;j<m;j++){
                    b[f[i][j]]++;//该字符的个数加一。
                }
            }
            if (check()){
                ans=1;
            }
            else{//只要有一次不满足，判断结果就为否，可以直接停止判断。
                ans=0;
                break;
            }
        }
    }
    b['R']=0;b['G']=0;b['B']=0;//还原用于的记录数组，方便竖条判断后面使用。
    if (m%3==0&&ans==0){
        for (k=0;k<3;k++){
            for (i=0;i<n;i++){
                for (j=k*m/3;j<(k+1)*m/3;j++){
                    b[f[i][j]]++;
                }
            }
            if (check()){
                ans=1;
            }
            else{
                ans=0;
                break;
            }
        }
    }
    cout<<(ans?"YES":"NO");
    return 0;
}
```
【核心实现思想】
1. 先读取矩阵信息。
2. 若 $n$ 能被 3 整除，进行横向长条判断，统计每个长条内三种字符的数量，通过 `check` 函数判断是否符合要求。
3. 重置记录数组，若 $m$ 能被 3 整除且之前横向判断不满足，进行竖向长条判断，同样统计字符数量并判断。
4. 根据判断结果输出 "YES" 或 "NO"。

【可拓展之处】
同类型题目可能会改变旗帜的形状或颜色要求，例如要求旗帜包含更多种颜色或有不同的长条排列方式。解题思路仍然是先特判明显不符合条件的情况，再对不同的排列方式进行模拟判断。

【推荐题目】
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
3. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)

【个人心得】
- WOERDESUGX：在输入时要注意判断是否有字母不是 "R"、"G"、"B"，否则会出错。
总结：在处理这类有字符限制的题目时，要仔细检查输入的字符是否符合要求，避免因输入问题导致错误。 

---
处理用时：35.93秒
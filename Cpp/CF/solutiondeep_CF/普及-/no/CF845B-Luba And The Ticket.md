# 题目信息

# Luba And The Ticket

## 题目描述

Luba 有一张票，上有六个数字。每一次操作时，她可以将其中一个数字改为任意一个数字。现在她希望知道最少需要操作多少次才可以将这张票上的数字改为一个幸运数字。 
当一个数的前三位之和与其后三位之和相等时，这便是一个幸运数字

## 说明/提示

样例1给出的数字本身即为幸运数字，因此操作数为 0 次  

样例 2 中仅需将 4、5 替换成 0 即可，很容易便看出最少需要操作 2 次  

样例 3 中仅需将任意一个 0 替换成 3，最少操作次数便是 1  

*以上即为题目简述，有不足之处请大家指出*

## 样例 #1

### 输入

```
000000
```

### 输出

```
0
```

## 样例 #2

### 输入

```
123456
```

### 输出

```
2
```

## 样例 #3

### 输入

```
111000
```

### 输出

```
1
```

# AI分析结果

【题目内容】
# Luba 和车票

## 题目描述
Luba 有一张车票，上面有六个数字。每次操作时，她可以将其中一个数字改为任意一个数字。现在她想知道最少需要操作多少次才能将这张车票上的数字改成一个幸运数字。
当一个数的前三位数字之和与后三位数字之和相等时，这个数就是一个幸运数字。

## 说明/提示
样例 1 给出的数字本身就是幸运数字，因此操作次数为 0 次。
样例 2 中，仅需将 4、5 替换成 0 即可，很容易看出最少需要操作 2 次。
样例 3 中，仅需将任意一个 0 替换成 3，最少操作次数就是 1。

## 样例 #1
### 输入
```
000000
```
### 输出
```
0
```

## 样例 #2
### 输入
```
123456
```
### 输出
```
2
```

## 样例 #3
### 输入
```
111000
```
### 输出
```
1
```

【算法分类】
贪心

【综合分析与结论】
- **思路对比**：
    - xuyouchen、LittleSnowy 和 zxc57838706 的思路类似，都是先计算前三位和后三位的和，求出差值，再计算每个数字可改变的最大价值，按价值从大到小排序，贪心选择改变价值大的数字来缩小差值。
    - 伟大的王夫子采用广度优先搜索（BFS），从初始状态开始，不断扩展状态，直到找到幸运数字状态。
- **算法要点**：
    - 贪心算法要点在于计算每个数字的改变价值并排序，优先选择价值大的数字进行改变。
    - BFS 算法要点是使用队列存储状态，用哈希表记录步数和判重，不断扩展状态直到找到目标状态。
- **解决难点**：
    - 贪心算法的难点在于确定每个数字的改变价值以及贪心策略的正确性。
    - BFS 算法的难点在于状态的扩展和判重，以及处理大量状态的效率问题。

【题解列表】
- **xuyouchen（4星）**：
    - **关键亮点**：思路清晰，代码注释详细，通过贪心策略解决问题，先计算差值，再计算每个数字的改变价值，排序后贪心选择。
    - **个人心得**：作者认为题目难度不大，希望 OIer 先自己思考，同时提到代码较繁琐是因为想让读者看懂每一步。
- **伟大的王夫子（4星）**：
    - **关键亮点**：采用广搜（BFS）求解，思路直接，通过队列和哈希表实现状态的扩展和判重。
    - **个人心得**：一看到题目就想到用广搜，认为数据不大，暴力出奇迹。
- **zxc57838706（4星）**：
    - **关键亮点**：代码简洁清晰，同样采用贪心策略，逻辑与 xuyouchen 类似。
    - **个人心得**：作者第一次发题解，认为代码很清晰。

【重点代码】
### xuyouchen 的贪心实现
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
bool cmp(int a,int b)
{
    return a>b;
}
int main()
{
    char a[6];
    int ans=0,first=0,last=0,dif;
    int val[6];
    for(int i=0;i<3;i++)
    {
        scanf("%c",&a[i]);
        first+=(int)a[i]-48; 
    }
    for(int i=3;i<6;i++)
    {
        scanf("%c",&a[i]);
        last+=(int)a[i]-48;
    }
    dif=abs(first-last);
    if(first<last)
    {
        for(int i=0;i<3;i++)
            val[i]=9-(int)a[i]+48;
        for(int i=3;i<6;i++)
            val[i]=(int)a[i]-48;
    }
    else{
        for(int i=0;i<3;i++)
            val[i]=(int)a[i]-48;
        for(int i=3;i<6;i++)
            val[i]=9-(int)a[i]+48;
    }
    sort(val,val+6,cmp);
    for(int i=0;i<6;i++)
    {
        if(dif<=0)
            break;
        dif-=val[i];
        ans++;
    }
    printf("%d",ans);
    return 0;
}
```
**核心实现思想**：先读取六个数字，计算前三位和后三位的和，求出差值。根据前后和的大小关系，计算每个数字可改变的最大价值，排序后贪心选择改变价值大的数字，直到差值为 0。

### 伟大的王夫子的 BFS 实现
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string, int> d;
queue<string> q;
string st;
bool check(string s) {
    return s[0] + s[1] + s[2] == s[3] + s[4] + s[5];
}
int main() {
    cin >> st;
    q.push(st);
    d[st] = 0;
    while (q.size()) {
        string x = q.front();
        q.pop();
        if (check(x)) {
            printf("%d\n", d[x]);
            break;
        }
        for (register int i = 0; i < x.size(); ++i) {
            for (register int j = '0'; j <= '9'; ++j) {
                string next = x;
                next[i] = j;
                if (d.find(next) == d.end()) q.push(next), d[next] = d[x] + 1;
            }
        }
    }
}
```
**核心实现思想**：使用队列存储状态，哈希表记录步数和判重。从初始状态开始，不断扩展状态，对于每个状态，枚举每个位置的数字改变，若新状态未访问过，则加入队列并更新步数，直到找到幸运数字状态。

### zxc57838706 的贪心实现
```cpp
#include<bits/stdc++.h>
using namespace std;
bool cmp(int a,int b)
{
    return (a>b);
}
int main()
{
    string s;
    getline(cin,s);
    int m,n,a[10],b[10];
    for(int i=0;i<6;++i){
        a[i]=s[i]-'0';
    }
    m=a[0]+a[1]+a[2];
    n=a[3]+a[4]+a[5];
    int cnt=0;
    if(m==n){
        cout<<"0"<<endl;
        return 0;
    }
    else if (m<n)
    {
        b[0]=9-a[0];
        b[1]=9-a[1];
        b[2]=9-a[2];
        b[3]=a[3];
        b[4]=a[4];
        b[5]=a[5];
        sort(b,b+6,cmp);
        int t=n-m;
        while(t>0) t-=b[cnt++];
        cout<<cnt<<endl;
    }
    else if(m>n)
    {
        b[0]=a[0];
        b[1]=a[1];
        b[2]=a[2];
        b[3]=9-a[3];
        b[4]=9-a[4];
        b[5]=9-a[5];
        sort(b+0,b+6,cmp);
        int t=m-n;
        while(t>0) t-=b[cnt++];
        cout<<cnt<<endl;
    }
    return 0;
}
```
**核心实现思想**：读取六个数字，计算前三位和后三位的和，求出差值。根据前后和的大小关系，计算每个数字可改变的最大价值，排序后贪心选择改变价值大的数字，直到差值为 0。

【最优关键思路或技巧】
- 贪心算法中，计算每个数字可改变的最大价值并排序，优先选择价值大的数字进行改变，能高效地找到最少操作次数。
- BFS 算法中，使用队列存储状态，哈希表记录步数和判重，能确保找到的是最少操作次数的解。

【拓展思路】
同类型题可以是类似的数字调整问题，例如给定一个多位数字，通过改变某些位上的数字，使其满足其他特定条件，如各位数字之和为某个定值等。类似算法套路可以是贪心策略，优先选择对结果影响最大的操作；或者使用搜索算法，通过扩展状态来找到满足条件的解。

【推荐洛谷题目】
1. P1223 排队接水（贪心算法）
2. P1135 奇怪的电梯（广度优先搜索）
3. P2814 家谱树（拓扑排序，可类比贪心思想）

---
处理用时：52.64秒
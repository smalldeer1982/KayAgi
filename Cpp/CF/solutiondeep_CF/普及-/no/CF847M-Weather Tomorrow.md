# 题目信息

# Weather Tomorrow

## 题目描述

`Vasya`想出了一个他自己的天气预报方法。他知道最近$n$天每天的平均气温。假设每天的平均气温是个整数。

`Vasya`相信这$n$天每天的平均气温构成一个等差数列，在这个数列中，第一项是第一天的平均气温，第二项是第二天的平均气温，以此类推。那么第$n+1$天（也就是明天）的平均气温将是这个数列的第$n+1$项。如果这个数列前$n$项并没有他所想的那样是个等差数列，那么按`Vasya`的算法，第$n+1$天的气温将等于第$n$天的气温。

你需要根据`Vasya`的算法求出明天的平均气温。

## 样例 #1

### 输入

```
5
10 5 0 -5 -10
```

### 输出

```
-15
```

## 样例 #2

### 输入

```
4
1 1 1 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
3
5 1 -5
```

### 输出

```
-5
```

## 样例 #4

### 输入

```
2
900 1000
```

### 输出

```
1100
```

# AI分析结果

### 题目翻译
#### 明天的天气

#### 题目描述
Vasya 想出了一个他自己的天气预报方法。他知道最近 $n$ 天每天的平均气温。假设每天的平均气温是个整数。

Vasya 相信这 $n$ 天每天的平均气温构成一个等差数列，在这个数列中，第一项是第一天的平均气温，第二项是第二天的平均气温，以此类推。那么第 $n + 1$ 天（也就是明天）的平均气温将是这个数列的第 $n + 1$ 项。如果这个数列前 $n$ 项并没有他所想的那样是个等差数列，那么按 Vasya 的算法，第 $n + 1$ 天的气温将等于第 $n$ 天的气温。

你需要根据 Vasya 的算法求出明天的平均气温。

#### 样例 #1
##### 输入
```
5
10 5 0 -5 -10
```
##### 输出
```
-15
```

#### 样例 #2
##### 输入
```
4
1 1 1 1
```
##### 输出
```
1
```

#### 样例 #3
##### 输入
```
3
5 1 -5
```
##### 输出
```
-5
```

#### 样例 #4
##### 输入
```
2
900 1000
```
##### 输出
```
1100
```

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路都是模拟判断数列是否为等差数列的过程。先计算出数列前两项的差值作为公差，然后遍历后续的数，检查相邻两项的差值是否都等于该公差。如果都相等，则该数列为等差数列，输出最后一项加上公差的值；否则输出最后一项的值。

各题解的主要区别在于代码实现方式，有的使用数组存储所有数据后再判断，有的边读入边判断；部分题解还对 $n = 2$ 的特殊情况进行了单独处理。

### 高评分题解
- **Liweiang 的方法一（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接按照题目要求模拟，可读性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000];
int main() 
{
    int n;
    cin>>n; 
    for(int i=1;i<=n;i++){
        cin>>a[i]; 
    }
    int t=a[2]-a[1];
    for(int i=3;i<=n;i++){
        if(a[i]-a[i-1]!=t){
            cout<<a[n]<<endl;
            return 0;
        }
    }
    cout<<a[n]+t<<endl;
    return 0;
}
```
    - **核心实现思想**：先读入所有数据，计算前两项的差值作为公差，然后遍历后续数据，若相邻两项差值不等于公差，则输出最后一项；否则输出最后一项加上公差的值。

- **Node_Edge 的题解（4星）**
    - **关键亮点**：思路简洁明了，代码结构清晰，易于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005];
int main() {
    int n;
    cin>>n; 
    for(int i=1;i<=n;i++){
        cin>>a[i]; 
    }
    int x=a[2]-a[1];//公差 
    for(int i=3;i<=n;i++){
        if(a[i]-a[i-1]!=x){//如果不是等差数列 
            cout<<a[n]<<endl;
            return 0;//结束程序 
        }
    }
    cout<<a[n]+x<<endl;//输出 n+1 项
    return 0;
}
```
    - **核心实现思想**：读入所有数据，计算公差，遍历后续数据判断是否为等差数列，根据结果输出相应的值。

- **三点水一个各的题解（4星）**
    - **关键亮点**：代码简洁，直接实现了核心逻辑，对 $n = 2$ 的情况也能正确处理。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110],d;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    d=a[2]-a[1];   //公差
    for(int i=3;i<=n;i++)  //判断是不是等差数列
      if(a[i]-a[i-1]!=d) {printf("%d",a[n]);return 0;}
    printf("%d",a[n]+d);  //是等差数列，且包含了n=2的情况
    return 0;
}
```
    - **核心实现思想**：读入数据，计算公差，遍历判断是否为等差数列，输出结果。

### 最优关键思路或技巧
- 先计算前两项的差值作为公差，再遍历后续数据判断相邻两项差值是否等于该公差，以此判断数列是否为等差数列。
- 部分题解边读入边判断，可节省空间。

### 可拓展之处
同类型题目可能会有更复杂的数列判断条件，例如判断等比数列、斐波那契数列等，或者在判断数列类型后进行更复杂的计算。解题思路仍然是先确定数列的特征，再根据特征进行判断和计算。

### 推荐题目
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：涉及递推和模拟的思想。
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：简单的模拟题。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及枚举和数学计算。

### 个人心得摘录与总结
- charleshe 提到“那么多大佬用了数组，蒟蒻深感佩服，但这题五个变量足矣”，总结：在解题时可以思考是否有更简洁的实现方式，避免不必要的空间浪费。
- charleshe 还提到“如果 $n = 1$ 则此 TJ 或许会被 hack 掉，但数据很弱，$n$ 至少为 2，因此可过”，总结：在解题时要考虑边界情况，虽然本题数据没有涉及 $n = 1$ 的情况，但在实际应用中需要注意。 

---
处理用时：41.39秒
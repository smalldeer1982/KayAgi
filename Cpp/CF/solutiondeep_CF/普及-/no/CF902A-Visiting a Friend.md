# 题目信息

# Visiting a Friend

## 题目描述

Pig 想去拜访一位朋友。

Pig 的家位于坐标轴的起点，即点 $0$，而他朋友的家位于点 $m$。

在这段旅途中，Pig 可以通过传送门在坐标轴上移动。

在使用传送门时，Pig 需要先到达传送门所在位置，并从中选择一个目标位置。每个传送门都有其最远可达的终点，称为该传送门的限制点。

具体来说，位于点 $x$ 且限制点为 $y$ 的传送门可以将 Pig 从 $x$ 移动到 $[x, y]$ 之间（包括端点）的任意位置。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/92bc86959654b1405c61b81d368eac9f5c5fe404.png)请判断 Pig 是否可以仅通过传送门顺利抵达朋友的家，否则，Pig 将需要开车前往。

## 说明/提示

第一个例子如图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/753e62c3b07259c4bd5318fcbc1770c920417f65.png)

Pig 可以依次利用传送门，从家移动到点 $2$、再到点 $3$，最后到达朋友的家——点 $5$。

第二个例子如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/907bb5d428f081e5cfddf9be149837a9d7265e2e.png)

可以看到，Pig 无法仅借助传送门从家到达朋友家。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 5
0 2
2 4
3 5
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3 7
0 4
2 5
6 7
```

### 输出

```
NO
```

# AI分析结果

【题目内容】
# 拜访朋友

## 题目描述

小猪想去拜访一位朋友。

小猪的家位于坐标轴的起点，即点 $0$，而他朋友的家位于点 $m$。

在这段旅途中，小猪可以通过传送门在坐标轴上移动。

在使用传送门时，小猪需要先到达传送门所在位置，并从中选择一个目标位置。每个传送门都有其最远可达的终点，称为该传送门的限制点。

具体来说，位于点 $x$ 且限制点为 $y$ 的传送门可以将小猪从 $x$ 移动到 $[x, y]$ 之间（包括端点）的任意位置。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/92bc86959654b1405c61b81d368eac9f5c5fe404.png)请判断小猪是否可以仅通过传送门顺利抵达朋友的家，否则，小猪将需要开车前往。

## 说明/提示

第一个例子如图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/753e62c3b07259c4bd5318fcbc1770c920417f65.png)

小猪可以依次利用传送门，从家移动到点 $2$、再到点 $3$，最后到达朋友的家——点 $5$。

第二个例子如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF902A/907bb5d428f081e5cfddf9be149837a9d7265e2e.png)

可以看到，小猪无法仅借助传送门从家到达朋友家。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 5
0 2
2 4
3 5
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3 7
0 4
2 5
6 7
```

### 输出

```
NO
```

【算法分类】
模拟

【综合分析与结论】
这些题解主要围绕判断小猪能否通过传送门到达朋友家展开，多数题解采用了桶排序（标记法）的思路，少数题解采用了判断区间连续性的思路。
- **思路对比**：
    - **桶排序（标记法）**：通过一个数组标记每个点是否可达，初始标记起点为可达，读入传送门信息时，若传送门起点可达，则将该传送门覆盖的区间内的点都标记为可达，最后检查从起点到终点的所有点是否都可达。
    - **判断区间连续性**：记录当前最大可行范围 $[l, r]$，读入传送门信息时，若传送门起点在当前最大可行范围内，则更新最大可行范围，最后判断终点是否在最大可行范围内。
- **算法要点**：
    - **桶排序（标记法）**：关键在于合理使用数组标记可达点，以及正确处理传送门信息。
    - **判断区间连续性**：重点是准确更新最大可行范围。
- **解决难点**：
    - **桶排序（标记法）**：需要注意判断传送门起点是否可达，避免错误标记。
    - **判断区间连续性**：要正确处理第一个传送门的情况，特判小猪的家和外界有无传送点。

【所选的题解】
- 作者：TheMatrix (赞：3)，4星。
    - **关键亮点**：思路清晰，不仅给出了桶排序的思路，还提出了更优的判断区间连续性的思路，时间复杂度为 $O(n)$。
    - **个人心得**：无。
- 作者：_JF_ (赞：1)，4星。
    - **关键亮点**：思路明确，代码简洁，对每个步骤的解释清晰。
    - **个人心得**：无。
- 作者：ink_ngm (赞：1)，4星。
    - **关键亮点**：思路简洁明了，代码注释详细，对容易出错的地方进行了重点提示。
    - **个人心得**：注意在标记区间时要先判断初始点是否可以通过，否则会导致误判。

【重点代码】
### 判断区间连续性思路（TheMatrix）
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105];
int main()
{
    int n, m, x, y, l = 0, r;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
    {
        cin >> x >> y;
        if(i == 1 && x != 0) {cout << "NO" << endl;return 0;} 
        if(i == 1) r = y;
        else if(x <= r) r = max(r, y);
    }
    if(r >= m) cout << "YES" << endl;
    else cout << "NO" << endl;
    return 0;
}
```
**核心实现思想**：通过记录最大可行范围 $[l, r]$，不断更新 $r$ 的值，最后判断终点 $m$ 是否在最大可行范围内。

### 桶排序（标记法）思路（_JF_）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
bool a[N];
int main()
{
    int n,m;
    cin>>n>>m;
    memset(a,false,sizeof(a));// 初始化
    a[0]=true;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        cin>>x>>y;
        if(a[x]) //在当前的点是可以在标记的范围内
        {
            for(int j=x;j<=y;j++)	
                a[j]=true;
        }
    }
    for(int i=0;i<=m;i++)
    {
        if(a[i]==false) //当前的点没有被更新过
        {
            cout<<"NO"<<endl;
            return 0;
        }
    }
    cout<<"YES";
    return 0;
}
```
**核心实现思想**：使用数组 $a$ 标记每个点是否可达，初始标记起点为可达，读入传送门信息时，若传送门起点可达，则将该传送门覆盖的区间内的点都标记为可达，最后检查从起点到终点的所有点是否都可达。

### 桶排序（标记法）思路（ink_ngm）
```cpp
#include<bits/stdc++.h>
using namespace std;
bool tong[114514];
int main(){
    int n,m;
    tong[0]=true;//初始小猪在的点位
    scanf ("%d%d",&n,&m);
    for (int i=1;i<=n;++i){
        int x,y;
        scanf ("%d%d",&x,&y);
        if (tong[x]) for (int j=x;j<=y;++j) tong[j]=true;
        /*注意！本处如果不判断初始点x是否可以通过的话，会导致如[1,2],[3,4]两个传送门原本不能通过的情况，误判为可以通过*/
    }
    for (int i=0;i<=m;++i)if (tong[i]!=true){
                    printf ("NO\n");
                    return 0;
                }
    printf ("YES\n");
    return 0;
} 
```
**核心实现思想**：使用数组 `tong` 标记每个点是否可达，初始标记起点为可达，读入传送门信息时，若传送门起点可达，则将该传送门覆盖的区间内的点都标记为可达，最后检查从起点到终点的所有点是否都可达。

【最优关键思路或技巧】
- **桶排序（标记法）**：简单直观，容易理解和实现，适用于数据范围较小的情况。
- **判断区间连续性**：时间复杂度较低，为 $O(n)$，适用于数据范围较大的情况。

【拓展思路】
同类型题或类似算法套路：区间覆盖问题，如判断多个区间能否完全覆盖某个大区间，可采用类似的区间合并或标记的方法解决。

【推荐题目】
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：与本题类似，都涉及区间标记的思想。
- [P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)：直接考察区间覆盖问题，可使用类似的区间合并思路。
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：涉及区间的选择和覆盖，可采用贪心算法解决。

【个人心得摘录】
- _Harrisonwhl_：一定要判断传送门起点是否可达，本人就在这个位置调了好久的错，因为上一次要是到 $x - 1$ 的话，如果不判断就会符合要求，实际是不符合的。
- ink_ngm：注意在标记区间时要先判断初始点是否可以通过，否则会导致如 $[1, 2]$，$[3, 4]$ 两个传送门原本不能通过的情况，误判为可以通过。

**总结**：在使用桶排序（标记法）时，要特别注意判断传送门起点是否可达，避免错误标记导致结果错误。

---
处理用时：63.57秒
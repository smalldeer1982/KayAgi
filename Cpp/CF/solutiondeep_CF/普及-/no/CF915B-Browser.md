# 题目信息

# Browser

## 题目描述

Luba正在网上冲浪。她在浏览器里打开了n个标签，从左到右编号为1到n。目前鼠标光标的位置在第pos个标签。Luba需要使用编号从l到r（包含l与r）的标签，并且她想尽可能快地关闭其它的标签。

Luba每秒可以把光标往左移或者往右移（如果光标当前在标签ii，则她可以将光标移到标签max(i-1,a)或者min(i+1,b)，或者关闭它左边或右边所有的标签（如果光标当前在标签i，她可以关闭[a,i−1]这段标签或者[i+1,b]这段标签）。在上述表达式中，a与b分别表示未关闭标签最小与最大的编号。如果最初有7个标签，1、2、7号标签都被关闭了，那么a=3,b=6

为了只留下初始编号从ll到rr的标签，Luba至少花费多少秒钟？

## 说明/提示

第一个样例中Luba需要做下面的操作：移动光标至标签2，关闭它左边的所有标签，移动光标到标签3，再到标签4，然后关闭它右边的所有标签。

第二个样例中她只需要关闭光标右边的所有标签。

第三个样例中Luba不需要做任何事。

## 样例 #1

### 输入

```
6 3 2 4
```

### 输出

```
5
```

## 样例 #2

### 输入

```
6 3 1 3
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5 2 1 5
```

### 输出

```
0
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路都是通过分类讨论来解决问题。根据 `l`、`r` 与 `n` 的关系以及光标位置 `pos` 与 `l`、`r` 的位置关系，将情况分为多种，分别计算出最少操作时间。

不同题解在分类的细致程度和代码实现上略有差异，但整体思路一致。部分题解考虑情况较为全面，代码逻辑清晰；部分题解则相对简洁，但可能在某些边界情况的处理上不够细致。

### 所选题解
- **作者：hswfwkj_ (赞：9)  4星**
    - **关键亮点**：思路清晰，对特殊情况的分类明确，代码简洁易懂。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,pos,l,r;
int main(){
    cin>>n>>pos>>l>>r;
    if(l==1&&r==n)
        cout<<0;
    else if(l==1)
        cout<<abs(pos-r)+1;
    else if(r==n)
        cout<<abs(pos-l)+1;
    else
        cout<<r-l+min(abs(pos-l),abs(pos-r))+2;
}
```
**核心实现思想**：首先读取输入的 `n`、`pos`、`l`、`r`。然后判断特殊情况：若 `l` 为 1 且 `r` 为 `n`，则无需操作，输出 0；若 `l` 为 1，只需将光标移到 `r` 再关闭右边的标签页，操作次数为 `abs(pos - r) + 1`；若 `r` 为 `n`，只需将光标移到 `l` 再关闭左边的标签页，操作次数为 `abs(pos - l) + 1`；其他情况，先将光标移到 `l` 或 `r` 中较近的位置，再移动到另一个端点，最后关闭两边的标签页，操作次数为 `r - l + min(abs(pos - l), abs(pos - r)) + 2`。

- **作者：正负君 (赞：2)  4星**
    - **关键亮点**：用数学表达式清晰地表示出不同情况的答案，思路明确，代码规范。
```cpp
#include<iostream>
int n,pos,l,r,ans;
using namespace std;
int main()
{
    cin>>n>>pos>>l>>r;
    if(l==1&&r==n)
    {
        ans=0;
    }
    else if(l==1)
    {
        ans=abs(pos-r)+1;
    }
    else if(r==n)
    {
        ans=abs(pos-l)+1;
    }
    else
    {
        ans=r-l+min(abs(pos-l),abs(pos-r))+2;
    }
    cout<<ans<<endl;
    return 0;
}
```
**核心实现思想**：与上一题解类似，先读取输入，然后根据不同情况计算 `ans` 的值，最后输出结果。

- **作者：清清老大 (赞：1)  4星**
    - **关键亮点**：思路简洁明了，直接阐述不同情况的操作步骤和所需时间，代码实现简单。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,pos,l,r;
    cin >> n >> pos >> l >> r;
    if(l == 1 && r == n)
    {
        cout << 0;
    }
    else if(l == 1)
    {
        cout << abs(pos - r) + 1;
    }
    else if(r == n)
    {
        cout << abs(pos - l) + 1;
    }
    else
    {
        cout << r - l + min(abs(pos - l),abs(pos - r)) + 2;
    }
}
```
**核心实现思想**：同样是先读取输入，再根据不同情况输出最少操作时间。

### 最优关键思路或技巧
- **分类讨论**：将问题根据不同的边界条件和光标位置进行分类，分别计算每种情况下的最少操作时间，使问题简化。
- **贪心思想**：在普通情况下，选择先移动到距离光标较近的端点，以减少移动次数，达到最少操作时间。

### 拓展思路
同类型题或类似算法套路通常涉及根据不同条件进行分类讨论的模拟问题，例如在游戏规则、操作步骤等方面有多种情况的题目。解题时需要仔细分析各种情况，找出规律，进行分类处理。

### 推荐题目
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：模拟在道路上种树和砍树的过程，需要根据不同的区间进行分类处理。
- [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098)：根据给定的规则对字符串进行展开，需要考虑多种情况，如数字、字母、特殊字符等。
- [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：模拟开灯关灯的过程，根据不同的时间和位置进行分类讨论。

### 个人心得摘录与总结
- **小王同学哦**：提到因为 `abs` 函数挂了两回，强调了在使用绝对值函数时要注意其作用，避免出现错误。同时指出要考虑周全各种情况，这是解决此类分类讨论问题的关键。
- **smyslenny**：表示这道题虽然简单，但需要讨论的地方比较细节，导致 WA 了好几次才过。提醒在解题时要仔细分析各种边界情况，不能遗漏。 

---
处理用时：33.46秒
# 题目信息

# World Cup

## 题目描述

世界杯足球赛的最后一个阶段是使用决赛系统进行的。

这个阶段还有n个团队，从1到n枚举。举行了几轮比赛，每轮比赛中，剩下的队伍按照ID的顺序进行排序，然后按此顺序的第一个队与第二个队比赛，第三个队与第四个队比赛，第五个队与第六个队比赛，依此类推。保证每轮比赛都有偶数支球队。每场比赛的胜利者晋级下一轮，失败者被淘汰出局，没有平局。在最后一轮比赛中，只有剩下的两支球队参加：这轮比赛称为决赛，获胜者称为冠军，比赛结束。

Arkady想让他最喜欢的两支球队参加决赛。不幸的是，团队ID已经确定了，而且可能会发生这样的情况：如果团队足够强大的话，他们就不可能在决赛中相遇，因为他们将在更早的阶段相遇。确定ID A和B的团队可以在哪一轮会面。

## 说明/提示

在第一个例子中，1队和2队在第一轮比赛中相遇。

在第二个例子中，2队和6队只能在第三轮比赛中相遇，这是决赛，前提是他们在前几轮中赢得了所有的对手。

在第三个例子中，如果在第一轮中赢得对手，IDS7和55的球队可以在第二轮中相遇。

## 样例 #1

### 输入

```
4 1 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
8 2 6
```

### 输出

```
Final!
```

## 样例 #3

### 输入

```
8 7 5
```

### 输出

```
2
```

# AI分析结果

【题目内容】
# 世界杯

## 题目描述
世界杯足球赛的最后阶段采用决赛赛制。

此阶段共有 n 支球队，编号从 1 到 n。比赛会进行多轮，每轮中，剩余球队按编号顺序排列，然后依次是第一支球队与第二支球队比赛，第三支球队与第四支球队比赛，第五支球队与第六支球队比赛，依此类推。确保每轮比赛的球队数量为偶数。每场比赛的胜者晋级下一轮，败者淘汰，没有平局。在最后一轮比赛中，仅剩下两支球队参赛，此轮比赛即为决赛，获胜者成为冠军，比赛结束。

阿卡迪希望他最喜欢的两支球队能进入决赛。不幸的是，球队编号已经确定，可能会出现这样的情况：即便这两支球队实力强劲，也可能无法在决赛相遇，因为他们可能在更早的阶段就碰面了。请确定编号为 A 和 B 的两支球队会在哪一轮相遇。

## 说明/提示
在第一个示例中，1 号球队和 2 号球队在第一轮比赛中相遇。

在第二个示例中，2 号球队和 6 号球队只有在第三轮（即决赛）才可能相遇，前提是他们在前几轮比赛中战胜了所有对手。

在第三个示例中，如果 7 号球队和 55 号球队在第一轮比赛中战胜对手，他们可以在第二轮相遇。

## 样例 #1
### 输入
```
4 1 2
```
### 输出
```
1
```

## 样例 #2
### 输入
```
8 2 6
```
### 输出
```
Final!
```

## 样例 #3
### 输入
```
8 7 5
```
### 输出
```
2
```

【算法分类】
模拟

【综合分析与结论】
- **思路对比**：
    - LRL65 和 αnonymous 的思路类似，都是通过模拟比赛过程，不断更新两支球队的位置（将球队编号更新为向上取整后的编号），直到两支球队编号相同，同时记录轮数，最后根据剩余球队数量判断是否为决赛。
    - LuffyLuo 采用数组模拟比赛过程，直接模拟每一轮比赛的对阵情况，判断两支球队是否相遇，若相遇再根据剩余球队数量判断是否为决赛。
    - sakuyu 将比赛过程类比为二叉树，通过找两支球队在二叉树中的最近公共父节点来确定相遇轮数，同样最后根据轮数和二叉树层数判断是否为决赛。
- **算法要点**：
    - LRL65 和 αnonymous 重点在于对球队编号的更新（向上取整）和轮数的记录。
    - LuffyLuo 重点在于数组的使用和对比赛对阵情况的模拟。
    - sakuyu 重点在于二叉树的类比和最近公共父节点的查找。
- **解决难点**：
    - 所有题解都需要解决如何判断两支球队相遇以及如何判断是否进入决赛的问题。LRL65 和 αnonymous 通过比较球队编号和剩余球队数量来判断；LuffyLuo 通过数组模拟比赛对阵情况判断；sakuyu 通过比较轮数和二叉树层数判断。

【题解评分】
- LRL65：4 星。思路清晰，代码简洁，直接模拟比赛过程，容易理解。
- LuffyLuo：3 星。思路直观，但使用数组模拟比赛过程，代码相对复杂，效率较低。
- sakuyu：3 星。将问题类比为二叉树，思路新颖，但代码中引入较多宏定义，增加了代码的复杂度。
- αnonymous：4 星。思路清晰，代码简洁，与 LRL65 思路类似。

【所选题解】
- LRL65（4 星）：关键亮点在于思路简洁，直接模拟比赛过程，代码实现简单。
- αnonymous（4 星）：关键亮点在于思路清晰，代码简洁，与 LRL65 思路类似。

【重点代码】
```cpp
// LRL65 的代码
#include<bits/stdc++.h>
using namespace std;
int n,a,b,s=0;
int main() {
    cin>>n>>a>>b;//输入
    while(a!=b) {//a和b不等时循环
        a=a/2+a%2;
        b=b/2+b%2;
        s++;//累加
        n/=2;
    }
    if(n!=1)cout<<s<<endl;//输出
    else cout<<"Final!"<<endl;
}

// αnonymous 的代码
#include <iostream>
using namespace std;
int n,a,b,total;	
int main(){
    cin>>n>>a>>b;
    while(a!=b){//不冲突则两只球队不在同一组
        if(a%2==1)
            a=a/2+1;
        else
            a=a/2;
        if(b%2==1)
            b=b/2+1;
        else
            b=b/2;
        total++;//计数
        n/=2;//每次球队减少一半
    }
    if(n!=1)//如果剩下来不止一只球队，则a和b没有都进入决赛
        cout<<total;
    else
        cout<<"Final!";
    return 0;
}
```
【核心实现思想】
这两个代码的核心思想都是模拟比赛过程，不断更新两支球队的位置（向上取整），直到两支球队编号相同，同时记录轮数，最后根据剩余球队数量判断是否为决赛。

【可拓展之处】
同类型题目可能会改变比赛规则，如增加平局情况、改变晋级规则等，解题思路仍然是模拟比赛过程，根据新的规则进行相应的调整。

【推荐题目】
1. P1042 [NOIP2003 普及组] 乒乓球：模拟乒乓球比赛的过程，根据比赛规则输出比赛结果。
2. P1067 [NOIP2009 普及组] 多项式输出：模拟多项式的输出过程，根据系数和指数的不同情况进行输出。
3. P1098 [NOIP2007 提高组] 字符串的展开：模拟字符串的展开过程，根据给定的规则对字符串进行展开。

【个人心得】
无。

---
处理用时：37.56秒
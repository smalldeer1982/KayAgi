# 题目信息

# Bus of Characters

## 题目描述

在一辆公交车中有 $n$ 排座位，每一排有两个座位。第 $i$ 排的两个座位的宽度均为 $w_i$ 。所有的 $w_i$ 互不相同。



初始时，公交车是空的。接下来会依次停靠 $2n$ 个站，每一站将上来一名乘客。乘客分为两类：

- 内向者：此类乘客总是会选择两个座位都是空的那一排就坐，如果有多排都是空的，他将会选择 $w_i$ 最小的那一排中任意一个空座坐下。

- 外向者：此类乘客总是会选择已有一人就坐（当然是内向者）的那一排，如果有多排都满足条件，他会选择 $w_i$ 最大的那一排的空座坐下。



现在给定每一排的宽度 $w_i$ 以及乘客上车的顺序。请确定每一个乘客将会选择哪一排坐下。

## 说明/提示

在第一个样例中：



第1名乘客（内向者）选择了第2排（由于它的宽度最小）。



第2名乘客（内向者）选择了第1排（由于它是唯一的没有人坐的那排）。



第3名乘客（外向者）选择了第1排（由于它正好是有一个人落座，并且宽度最大）。



第4名乘客（外向者）选择了第2排（由于它是唯一的有空座的那排）。

## 样例 #1

### 输入

```
2
3 1
0011
```

### 输出

```
2 1 1 2 
```

## 样例 #2

### 输入

```
6
10 8 9 11 13 5
010010011101
```

### 输出

```
6 6 2 3 3 1 4 4 1 2 5 5 
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
这些题解的核心思路都是模拟乘客上车选座的过程，主要区别在于数据结构的使用和具体实现细节。大部分题解使用了优先队列（堆）来快速找到内向者和外向者的最优座位选择，部分题解使用栈来实现。

- **思路对比**：多数题解使用两个优先队列，一个小根堆存储内向者可选座位，一个大根堆存储外向者可选座位；部分题解使用栈，通过排序保证内向者选座顺序，利用栈的先进后出特性满足外向者选座需求。
- **算法要点**：优先队列题解利用堆的特性快速找到最值；栈题解通过排序和栈的操作模拟选座过程。
- **解决难点**：主要难点在于如何快速找到内向者和外向者的最优座位，使用优先队列或栈可以有效解决这个问题。

### 所选题解
- **作者：zzx114514 (赞：5)  4星**
  - **关键亮点**：思路清晰，使用结构体和重载运算符实现优先队列，代码注释详细，便于理解。
  - **核心代码**：
```cpp
struct Sit
{
    int w,s; //定义座位结构体，w表示宽度，s表示编号 
};
struct cmpin
{
    bool operator()(Sit a,Sit b) const
    {
        return a.w>b.w; //重载括号运算符，实现小根堆，注意要反过来，小根堆要用大于号 
    }
};
struct cmpout
{
    bool operator()(Sit a,Sit b) const 
    {
        return a.w<b.w; //同上，实现大根堆 
    }
};
priority_queue<Sit,vector<Sit>,cmpin> in; //内向者 
priority_queue<Sit,vector<Sit>,cmpout> out; //外向者 
// ...
for (int i=0;i<s.size();i++)
{
    if (s[i]=='0') //如果上来的是内向者 
    {
        cout<<in.top().s<<' '; //输出堆顶编号 
        out.push(in.top()); //由于堆顶坐了一个人，另一个座位必是外向者坐，将其分给外向者 
        in.pop(); //由于堆顶坐了一个人，另一个座位必不是内向者坐，将堆顶弹出 
    }
    else //如果上来的是外向者 
    {
        cout<<out.top().s<<' '; //同上
        out.pop();
    }
}
```
  - **核心实现思想**：定义座位结构体，通过重载运算符实现小根堆和大根堆，分别存储内向者和外向者的可选座位。遍历乘客上车顺序，根据乘客类型选择相应堆的堆顶座位，并进行相应的堆操作。

- **作者：yeshubo_qwq (赞：5)  4星**
  - **关键亮点**：不使用结构体，利用 `map` 存储宽度和序号的对应关系，简化代码。
  - **核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int> > q; //内向乘客（小根堆） 
priority_queue<int> p; //外向乘客（priority_queue默认大根堆） 
map<int,int> a; //存宽度对应的序号 
// ...
for(i=1;i<=n*2;i++){
    if(s[i]=='0') x=q.top(),q.pop(),p.push(x); //内向乘客坐上去以后变成供外向乘客坐的位置 
    else x=p.top(),p.pop(); //外向乘客上去后座位满了，不用二次进堆 
    printf("%d ",a[x]);
}
```
  - **核心实现思想**：使用两个优先队列分别存储内向者和外向者的可选座位，用 `map` 存储宽度和序号的对应关系。遍历乘客上车顺序，根据乘客类型选择相应堆的堆顶座位，并进行相应的堆操作。

- **作者：OIerZhang (赞：0)  4星**
  - **关键亮点**：使用栈实现，思路独特，代码简洁。
  - **核心代码**：
```cpp
struct node
{
    int w, id;
}a[200005];

stack <int> s;

bool cmp(node x, node y)
{
    if (x.w == y.w)
        return x.id < y.id;
    else
        return x.w < y.w;
}

// ...
sort(a + 1, a + 1 + n, cmp);
for (int i = 1; i <= 2 * n; i++)
{
    cin >> ch;
    if (ch == '0')
    {
        cout << a[t].id << " ";
        s.push(a[t].id);
        t++;
    }
    else if (ch == '1')
    {
        cout << s.top() << " ";
        s.pop();
    }
}
```
  - **核心实现思想**：对座位按宽度从小到大排序，内向者选择最小的空排，输出编号并入栈；外向者选择栈顶的排，输出编号并出栈。

### 最优关键思路或技巧
- 使用优先队列（堆）可以快速找到最值，满足内向者和外向者的选座需求。
- 利用 `map` 存储宽度和序号的对应关系，避免使用结构体和重载运算符，简化代码。
- 对于此类有特定选择规则的模拟问题，可以考虑使用栈来实现，利用栈的先进后出特性满足需求。

### 可拓展之处
同类型题可能会有更多的乘客类型和座位规则，或者座位信息更加复杂。类似算法套路可以用于解决其他有特定选择规则的模拟问题，如任务调度、资源分配等。

### 推荐题目
- P1047 [NOIP2005 普及组] 校门外的树
- P1098 [NOIP2007 提高组] 字符串的展开
- P1161 开灯

### 个人心得摘录与总结
- **作者：xyta**：提到可以参考优先队列讲解链接学习优先队列，强调了学习数据结构的重要性。
- **作者：OIerZhang**：作为没学过堆的蒟蒻，尝试用栈来解决问题，说明在面对问题时可以尝试不同的思路和方法。 

---
处理用时：42.75秒
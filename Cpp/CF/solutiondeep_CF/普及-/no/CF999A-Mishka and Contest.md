# 题目信息

# Mishka and Contest

## 题目描述

给出长度为 $n$ 的数列，每次只能删除右端或左端小于等于 $k$ 的数，求最多能删除几个数。

## 样例 #1

### 输入

```
8 4
4 2 3 1 5 1 6 4
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5 2
3 1 2 1 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
5 100
12 34 55 43 21
```

### 输出

```
5
```

# AI分析结果

【题目内容】
# Mishka和竞赛

## 题目描述
给出长度为 $n$ 的数列，每次只能删除右端或左端小于等于 $k$ 的数，求最多能删除几个数。

## 样例 #1
### 输入
```
8 4
4 2 3 1 5 1 6 4
```
### 输出
```
5
```

## 样例 #2
### 输入
```
5 2
3 1 2 1 3
```
### 输出
```
0
```

## 样例 #3
### 输入
```
5 100
12 34 55 43 21
```
### 输出
```
5
```

【算法分类】
模拟

【综合分析与结论】
- **思路对比**：多数题解采用从数列两端向中间遍历的方式，判断元素是否小于等于 $k$ 来决定是否删除。部分题解使用双端队列模拟删除过程，部分题解直接用数组下标模拟。
- **算法要点**：关键在于正确处理两端元素的判断和删除，避免重复计算或遗漏情况。
- **解决难点**：需要注意边界条件，如队列是否为空、左右指针是否越界、奇数长度数列中间元素的处理等。

【所选的题解】
- **Ruizll（4星）**
  - **关键亮点**：思路清晰，使用双端队列模拟删除过程，代码结构明确，对边界条件有明确提示。
  - **个人心得**：提到要在循环中同时判断队列是否为空，不然像样例三那样的测试点会 RE，自己交了两次才过。
- **Paris_Bentley（4星）**
  - **关键亮点**：同样使用双端队列，对双端队列的用法有详细说明，代码简洁易懂。

【重点代码】
- **Ruizll的核心代码**：
```cpp
deque <int> dq;
int n, m;
int oj(){
    int ans = 0;
    while(dq.front() <= m && !dq.empty()){
        dq.pop_front();
        ans++;
    }
    while(dq.back() <= m && !dq.empty()){
        dq.pop_back();
        ans++;
    }
    return ans;
}
```
核心实现思想：使用双端队列，先从队头开始判断元素是否小于等于 $m$，若满足则删除队头元素并计数；再从队尾开始判断，同样操作，最后返回计数结果。
- **Paris_Bentley的核心代码**：
```cpp
deque <int> q;
int n,k,ans; 
while (q.size() && q.front()<=k)
{
    ans++;
    q.pop_front();
}
while (q.size() &&q.back()<=k)
{
    ans++;
    q.pop_back();
}
```
核心实现思想：与Ruizll的思路类似，使用双端队列，先处理队头，再处理队尾，统计满足条件的元素个数。

【最优关键思路或技巧】
使用双端队列可以方便地模拟从两端删除元素的过程，同时在操作过程中要时刻注意边界条件，避免出现运行时错误。

【拓展思路】
同类型题可能会改变删除规则，如每次可以删除两端连续的小于等于 $k$ 的元素，或者改变数列的初始状态（如环形数列）等。类似算法套路可用于处理需要从两端进行操作的序列问题。

【推荐题目】
- P1047 [NOIP2005 普及组] 校门外的树
- P1059 [NOIP2006 普及组] 明明的随机数
- P1067 [NOIP2009 普及组] 多项式输出

---
处理用时：25.29秒
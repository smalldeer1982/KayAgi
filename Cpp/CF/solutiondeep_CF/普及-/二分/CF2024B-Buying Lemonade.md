# 题目信息

# Buying Lemonade

## 题目描述

有一台柠檬水自动售货机。机器上有 $n$ 个槽位和 $n$ 个按钮，每个槽位对应一个按钮，但你并不知道每个按钮对应的是哪个槽位。

当您按下第 $i$ 个按钮时，有两种可能的事件：
- 若 $i$ 号槽位有至少一瓶柠檬水，则其中一瓶柠檬水会从这个槽位里掉下来，然后你会把它取走。
- 若 $i$ 号槽位没有柠檬水，则什么都不会发生。

柠檬水下落速度很快，因此您看不清它从哪个槽位掉出。您只知道每个槽位中瓶装柠檬水的数量 $a_i (1 \le i \le n)$。

您需要求出至少收到 $k$ 瓶柠檬水的最小按按钮次数。

数据保证机器中至少存在 $k$ 瓶柠檬水。

## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n \le 2 \times 10^5$，$1 \le a_i, k \le 10^9$，

## 样例 #1

### 输入

```
5
2 1
1 1
2 2
1 2
3 4
2 1 3
10 50
1 1 3 8 8 9 12 13 27 27
2 1000000000
1000000000 500000000```

### 输出

```
1
2
5
53
1000000000```

# AI分析结果

### 题目重写
#### 题目描述

有一台柠檬水自动售货机。机器上有 $n$ 个槽位和 $n$ 个按钮，每个槽位对应一个按钮，但你并不知道每个按钮对应的是哪个槽位。

当你按下第 $i$ 个按钮时，有两种可能的事件：
- 若 $i$ 号槽位有至少一瓶柠檬水，则其中一瓶柠檬水会从这个槽位里掉下来，然后你会把它取走。
- 若 $i$ 号槽位没有柠檬水，则什么都不会发生。

柠檬水下落速度很快，因此你看不清它从哪个槽位掉出。你只知道每个槽位中瓶装柠檬水的数量 $a_i (1 \le i \le n)$。

你需要求出至少收到 $k$ 瓶柠檬水的最小按按钮次数。

数据保证机器中至少存在 $k$ 瓶柠檬水。

#### 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n \le 2 \times 10^5$，$1 \le a_i, k \le 10^9$。

#### 样例 #1

##### 输入
```
5
2 1
1 1
2 2
1 2
3 4
2 1 3
10 50
1 1 3 8 8 9 12 13 27 27
2 1000000000
1000000000 500000000
```

##### 输出
```
1
2
5
53
1000000000
```

---

### 题解分析与结论

#### 综合分析与结论
本题的核心在于如何在不知道按钮与槽位对应关系的情况下，最小化按按钮次数，确保至少获得 $k$ 瓶柠檬水。由于按钮与槽位的对应关系未知，且每次按下按钮时，柠檬水可能从任意有柠檬水的槽位中掉出，因此需要采用贪心策略，尽可能减少按到空按钮的次数。

大多数题解都采用了类似的贪心策略：将槽位的柠檬水数量从小到大排序，然后依次按按钮，直到获得足够的柠檬水。这种方法的核心思想是，每次按按钮时，尽可能多地获取柠檬水，同时避免按到空按钮。

#### 所选高星题解

1. **题解作者：Chenyanxi0829 (4星)**
   - **关键亮点**：该题解通过排序和贪心策略，逐步减少按钮的按次数，确保在每次操作中尽可能多地获取柠檬水。代码简洁，逻辑清晰。
   - **代码核心思想**：排序后，从左到右依次按按钮，每次按按钮时，计算当前槽位的柠檬水数量与之前槽位的差值，确保每次按按钮时都能获取到尽可能多的柠檬水。
   ```cpp
   sort(a + 1, a + n + 1), ans = 0;
   for (int i = 1; i <= n; i++) {
       if (k <= 1ll * (a[i] - a[i - 1]) * (n - i + 1)) {
           cout << ans + k << '\n';
           break;
       }
       ans += 1 + (a[i] - a[i - 1]) * (n - i + 1), k -= (a[i] - a[i - 1]) * (n - i + 1);
   }
   ```

2. **题解作者：CEFqwq (4星)**
   - **关键亮点**：该题解通过二分查找优化了按按钮的次数，确保在最坏情况下也能高效地获取柠檬水。代码实现较为复杂，但思路清晰。
   - **代码核心思想**：使用二分查找确定按按钮的次数，然后通过模拟按按钮的过程，确保在最坏情况下也能获得足够的柠檬水。
   ```cpp
   int l = 0, r = 1e9, mid;
   while (l < r) {
       mid = (l + r + 1) >> 1;
       if (check(mid)) {
           r = mid - 1;
       } else {
           l = mid;
       }
   }
   ```

3. **题解作者：chenxi2009 (4星)**
   - **关键亮点**：该题解通过贪心策略，每次按按钮时都尽可能多地获取柠檬水，同时避免按到空按钮。代码简洁，逻辑清晰。
   - **代码核心思想**：排序后，从左到右依次按按钮，每次按按钮时，计算当前槽位的柠檬水数量与之前槽位的差值，确保每次按按钮时都能获取到尽可能多的柠檬水。
   ```cpp
   sort(a + 1, a + n + 1);
   for (int i = 1; i <= n; i++) {
       if (cnt + (long long)(n - i + 1) * (a[i] - a[i - 1]) >= k) {
           ans += k - cnt;
           break;
       } else {
           ans += (n - i + 1) * (a[i] - a[i - 1]) + 1;
           cnt += (n - i + 1) * (a[i] - a[i - 1]);
       }
   }
   ```

---

### 最优关键思路与技巧
1. **贪心策略**：通过排序和逐步减少按钮的按次数，确保每次按按钮时都能获取到尽可能多的柠檬水。
2. **二分查找优化**：在按按钮的次数不确定时，使用二分查找优化按按钮的次数，确保在最坏情况下也能高效地获取柠檬水。
3. **避免按到空按钮**：在按按钮时，尽可能避免按到空按钮，减少无效操作。

---

### 可拓展之处
1. **类似问题**：在类似的资源分配问题中，贪心策略和二分查找优化是常用的方法。
2. **其他优化**：可以考虑使用动态规划或其他优化方法，进一步提高算法的效率。

---

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---

### 个人心得摘录
- **调试经历**：在实现二分查找时，需要注意边界条件的处理，避免出现死循环或错误结果。
- **踩坑教训**：在按按钮时，要确保每次按按钮时都能获取到尽可能多的柠檬水，避免按到空按钮。
- **顿悟感想**：贪心策略和二分查找优化是解决类似问题的有效方法，能够显著提高算法的效率。

---
处理用时：43.06秒
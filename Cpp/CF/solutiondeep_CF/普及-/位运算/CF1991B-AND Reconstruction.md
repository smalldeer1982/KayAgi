# 题目信息

# AND Reconstruction

## 题目描述

给定一个由 $ n - 1 $ 个整数组成的数组 $ b $。

一个数组 $ a $ 被称为是“好的”当且仅当对于 $ 1 \le i \le n-1 $，都有 $ b_i = a_i \, \& \, a_{i + 1} $ 其中$ \& $ 表示[按位与运算](https://en.wikipedia.org/wiki/Bitwise_operation#AND)。

你的任务是构造一个“好的”数组，或输出 `-1` 表示不存在“好的”数组。

## 说明/提示

对于第一组样例，$ b = [1] $。一个可能的"好的"数组是 $ a=[5, 3] $。因为 $ a_1 \, \& \, a_2 = 5 \, \& \, 3 = 1 = b_1 $。

对于第二组样例，$ b = [2, 0] $。一个可能的"好的"数组是 $ a=[3, 2, 1] $。因为 $ a_1 \, \& \, a_2 = 3 \, \& \, 2 = 2 = b_1 $ and $ a_2 \, \& \, a_3 = 2 \, \& \, 1 = 0 = b_2 $。

对于第三组样例，$ b = [1, 2, 3] $。可以证明不存在"好的"数组，所以输出 `-1`。

对于第四组样例，$ b = [3, 5, 4, 2] $。一个可能的"好的"数组是 $ a=[3, 7, 5, 6, 3] $。

## 样例 #1

### 输入

```
4
2
1
3
2 0
4
1 2 3
5
3 5 4 2```

### 输出

```
5 3
3 2 1
-1
3 7 5 6 3```

# AI分析结果

### 题目翻译
题目内容已为中文，无需翻译。

### 综合分析与结论
这些题解的核心思路都是围绕按位与运算的性质来构造数组 $a$，并检查构造的数组是否满足条件。主要有两种构造方法：
- **按位构造法**：根据按位与运算的性质，若 $b_i$ 的二进制第 $j$ 位为 $1$，则 $a_i$ 和 $a_{i + 1}$ 的二进制第 $j$ 位都设为 $1$，其他位尽量设为 $0$。代表作者有 zhouchuer、donnieguo、qfy123、Rubedo_N 等。
- **或运算构造法**：利用 $a_i$ 要同时满足 $a_i \& a_{i + 1} = b_i$ 和 $a_{i - 1} \& a_i = b_{i - 1}$，令 $a_i = b_{i - 1} | b_i$（$2 \leq i \leq n - 1$），$a_1 = b_1$，$a_n = b_{n - 1}$。代表作者有白鲟、Trubiacy_、Dioretsa、zg_ji、_ZHONGZIJIE0608_ 等。

### 所选题解
- **白鲟（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过贪心策略令 $a_i = b_i | b_{i - 1}$ 构造数组，最后检查数组是否合法。
    - **核心代码**：
```cpp
for (int i = 1; i < n; ++i) {
    scanf("%d", &a[i]);
}
a[n] = 0;
b[1] = a[1];
for (int i = 2; i <= n; ++i) {
    b[i] = a[i] | a[i - 1];
}
for (int i = 1; i < n; ++i) {
    if ((b[i] & b[i + 1])!= a[i]) {
        flag = false;
    }
}
```
- **donnieguo（4星）**
    - **关键亮点**：详细解释了按位构造的思路，代码规范，多测时注意清空数组。
    - **核心代码**：
```cpp
for (int i = 1; i < n; i++)
    for (int j = 0; j <= 30; j++)
        if (b[i] >> j & 1) a[i] |= 1 << j, a[i + 1] |= 1 << j;
bool flag = 1;
for (int i = 1; i < n; i++) if ((a[i] & a[i + 1])!= b[i]) {flag = 0; break;}
```
- **qfy123（4星）**
    - **关键亮点**：将构造和检查封装成函数，代码结构清晰，易于理解。
    - **核心代码**：
```cpp
bool chk(){//检查答案是否合法
    for(int i=1;i<n;i++) if((a[i] & a[i+1])!= b[i]) return 0;
    return 1;
}
void solve(){
    memset(a,0,sizeof(a));//多测别忘记清空
    r(n);
    for(int i=1;i<n;i++) r(b[i]);
    for(int i=1;i<n;i++) for(int j=0;j<=30;j++)  if(b[i] >> j & 1) a[i] |= 1 << j, a[i+1] |= 1 << j;
    if(chk()) for(int i=1;i<=n;i++) pr(a[i]);	
    else pr(-1);
    puts(""); 
}
```

### 最优关键思路与技巧
- **按位思考**：按位与运算的性质是解题的关键，通过分析二进制位的情况来构造数组。
- **贪心策略**：在构造数组时，尽量让二进制位为 $0$，以减少冲突的可能性。
- **合法性检查**：构造完成后，需要检查数组是否满足 $a_i \& a_{i + 1} = b_i$ 的条件。

### 拓展思路
同类型题目通常会围绕位运算的性质展开，可能会结合其他算法，如动态规划、贪心算法等。类似的算法套路有按位枚举、按位构造、位运算优化等。

### 推荐题目
- [P1824 进击的奶牛](https://www.luogu.com.cn/problem/P1824)：涉及二分查找和位运算的应用。
- [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)：主要考察位运算和贪心算法。
- [P3811 乘法逆元](https://www.luogu.com.cn/problem/P3811)：需要运用快速幂和位运算来求解。

### 个人心得摘录与总结
- **白鲟**：提到一个小坑是 $b_{n}$ 需要清零，因为这个吃了一发罚时，提醒我们在处理边界情况时要格外小心。
- **__XU__**：刚开始用了 `STL` 自带的 `__lg` 函数，结果 TLE 了，说明在选择函数时要考虑其时间复杂度。 

---
处理用时：28.99秒
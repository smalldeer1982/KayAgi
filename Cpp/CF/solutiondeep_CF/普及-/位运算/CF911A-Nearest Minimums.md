# 题目信息

# Nearest Minimums

## 题目描述

You are given an array of $ n $ integer numbers $ a_{0},a_{1},...,a_{n-1} $ . Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.
找到一个长度为n的序列中，距离最短的最小值的距离。

## 样例 #1

### 输入

```
2
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
9
2 1 3 5 4 1 2 3 1
```

### 输出

```
3
```

# AI分析结果

### 题目翻译
#### 最近的最小值

#### 题目描述
给定一个包含 $n$ 个整数的数组 $a_{0},a_{1},\cdots,a_{n - 1}$。找出数组中两个最接近（最近）的最小值之间的距离。保证数组中最小值至少出现两次。

#### 样例 #1
##### 输入
```
2
3 3
```
##### 输出
```
1
```

#### 样例 #2
##### 输入
```
3
5 6 5
```
##### 输出
```
2
```

#### 样例 #3
##### 输入
```
9
2 1 3 5 4 1 2 3 1
```
##### 输出
```
3
```

### 综合分析与结论
- **思路对比**：
    - 归褯雾嵊、vectorwyx、ian_ian 的思路类似，先找出数组中的最小值，再记录最小值的位置，最后遍历位置数组找出相邻位置的最小差值。
    - da32s1da 不用数组，在读取数据时动态更新最小值、答案和位置。
    - 引领天下使用结构体存储数组元素和其下标，排序后找出相邻最小元素下标的最小差值。
- **算法要点**：
    - 归褯雾嵊、vectorwyx、ian_ian 使用数组或 vector 记录最小值位置。
    - da32s1da 仅用几个变量动态更新。
    - 引领天下使用结构体和排序。
- **解决难点**：
    - 所有题解都要解决找出最小值和计算最小距离的问题。归褯雾嵊、vectorwyx、ian_ian 通过记录位置解决；da32s1da 动态更新；引领天下通过排序解决。

### 题解评分
- 归褯雾嵊：4星。思路清晰，代码可读性高，使用简单的枚举和数组记录位置。
- da32s1da：5星。思路巧妙，不用数组，空间复杂度低，代码简洁。
- vectorwyx：3星。思路清晰，但使用 vector 增加了代码复杂度，没有明显优化。
- 引领天下：3星。使用结构体和排序，思路较新颖，但代码复杂度较高。
- ian_ian：3星。思路和归褯雾嵊类似，代码可读性一般。

### 所选题解
- **da32s1da（5星）**
    - **关键亮点**：不用数组，动态更新最小值、答案和位置，空间复杂度低，代码简洁。
    - **核心代码**：
```cpp
#include<cstdio>
const int inf=1e9+7;
int minn,wz,n,x,ans;
int main(){
    scanf("%d",&n);
    minn=inf;ans=n;
    for(int i=1;i<=n;i++){
        scanf("%d",&x);
        if(minn==x&&ans>i-wz)ans=i-wz;
        if(minn==x)wz=i;
        if(minn>x)minn=x,wz=i,ans=n;
    }
    printf("%d\n",ans);
}
```
核心实现思想：在读取数据时，若当前值小于最小值，更新最小值、答案和位置；若当前值等于最小值，更新答案和位置。

- **归褯雾嵊（4星）**
    - **关键亮点**：思路清晰，代码可读性高，使用简单的枚举和数组记录位置。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int wz[100001];
int main()
{
    int n,total=1;
    int zx=1000000000;
    int jl=100000;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(zx>a[i])
            zx=a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]==zx)
            wz[total++]=i;
    }
    for(int i=2;i<total;i++)
    {
        if(jl>wz[i]-wz[i-1])
            jl=wz[i]-wz[i-1];
    }
    cout<<jl;
}
```
核心实现思想：先遍历数组找出最小值，再遍历数组记录最小值的位置，最后遍历位置数组找出相邻位置的最小差值。

### 最优关键思路或技巧
- 动态更新：如 da32s1da 的题解，不用数组记录所有位置，在读取数据时动态更新最小值、答案和位置，降低空间复杂度。

### 可拓展之处
同类型题可以是找出数组中两个最接近的特定元素的距离，或找出数组中满足特定条件的元素的最小距离。类似算法套路是在遍历数组时动态更新关键信息。

### 洛谷相似题目推荐
- P1161 开灯：需要记录每个开关的状态变化，找出相邻状态变化的最小间隔。
- P1047 校门外的树：需要记录每个位置的树的状态，找出相邻被移除树的最小距离。
- P1036 选数：需要枚举所有可能的组合，找出满足条件的组合中元素的最小距离。

### 个人心得摘录与总结
- vectorwyx：提到题目有140个测试点，感慨测试点多。总结：在做题时要考虑代码的效率，以应对较多的测试点。

---
处理用时：29.40秒
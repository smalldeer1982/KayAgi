# 题目信息

# Left and Right Houses

## 题目描述

在 Letovo 村，有 $ n $ 坐房屋。村民们决定修一条大路，把村子分成左右两部分。每个居民都想住在街道的右边或左边，这被描述为一个顺序 $ a_1, a_2, \dots, a_n $，其中 $ a_j = 0 $ 表示编号为 $ j $ 房子的居民想住在街道的左边；否则，$ a_j = 1 $。

这条路将穿过两座房子之间。它左边的房子将被宣布为左边，右边的房子将被宣布为右边。更正式的说法是，**若道路在房屋 $ i $ 和 $ i+1 $ 之间通行。那么，位于 $ 1 $ 和 $ i $ 之间的房屋将位于街道的左侧，位于 $ i+1 $ 和 $ n $ 之间的房屋将位于街道的右侧**。这条路也**可以在第一所房子前面经过，在最后一所房子后面经过**。在这种情况下，整个村庄分别被声明为右侧或左侧。

为了使设计公平，决定铺设道路，使村庄两边至少有一半的居民对选择感到满意。也就是说，在每一边的 $ x $ 个居民中，至少 $ \lceil\frac{x}{2}\rceil $ 应该想住在另一边，其中 $ \lceil x \rceil $ 表示四舍五入的实数 $ x $。

 [](https://cdn.luogu.com.cn/upload/vjudge＿pic/CF1945C/2ed555a735574721378598482dfea8442c0609da.png)
 
路的左边会有 $ i $ 栋房子，对应的 $ a_j $ 中至少有 $ \lceil\frac{i}{2}\rceil $ 个 $0$。在道路的右侧，将会有 $ n-i $ 房屋，在相应的 $ a_j $ 中必须至少有 $ \lceil\frac{n-i}{2}\rceil $ 房屋。确定道路应该铺设在哪座房子 $ i $ 之后，以满足所描述的条件，并尽可能靠近村庄的中心。正式地说，在所有合适的位置 $ i $ 中，最小化 $ \left|\frac{n}{2} - i\right| $（**注意：这里的 $\frac{n}{2}$ 不做取整操作**）。

如果有多个适合的位置 $ i $ 和最小的 $ \left|\frac{n}{2} - i\right| $，输出较小的位置（即更靠左的位置）。

## 说明/提示

让我们考虑输入数据的第一个示例。

如果我们在第一所房子之后铺设道路，将会有一所房子 $ a_1 = 1 $ 在街道的左侧，其中的居民愿意住在街道的右侧。然后 $ 0 $ 出 $ 1 $ 居民在均匀的一边会满意的选择，这意味着道路不能在房子 $ 1 $ 后铺设。

如果我们在第二所房子之后铺设道路，左侧的 $ 2 $ 个居民中的 $ 1 $ 位（$ a_1 = 1 $, $ a_2 = 0 $）和右侧 $ 1 $ 位居民中的 $ 1 $ 位（$ a_3 = 1 $）将对选择感到满意。两边一半以上的居民都对这个选择感到满意，这意味着这条路可以能在房子 $ 2 $ 后铺设。我们可以证明这是最优答案。

翻译者：[SCAR_L](https://www.luogu.com.cn/user/608703)

## 样例 #1

### 输入

```
7
3
101
6
010111
6
011001
3
000
3
110
3
001
4
1100```

### 输出

```
2
3
2
3
0
1
0```

# AI分析结果



### 题目内容重写
**左右房屋**

#### 题目描述

在莱托沃村有 $n$ 座房屋。村民决定修建一条大路将村庄分为左右两部分。每个居民希望住在路的右侧或左侧，用一个序列 $a_1,a_2,\dots,a_n$ 描述，其中 $a_j=0$ 表示编号 $j$ 的居民想住在左侧，$a_j=1$ 表示想住在右侧。

道路将设在两座房屋之间，左侧的房屋（1到i）需满足至少有 $\lceil\frac{i}{2}\rceil$ 个居民希望留在左侧（即 $a_j=0$），右侧的房屋（i+1到n）需满足至少有 $\lceil\frac{n-i}{2}\rceil$ 个居民希望留在右侧（即 $a_j=1$）。要求找到满足条件且最靠近村庄中心的分割点 $i$（最小化 $\left|\frac{n}{2}-i\right|$），若有多个解则选较小的 $i$。

#### 输入输出样例
（与原文一致，此处略）

---

### 题解综合分析

#### 最优解法总结
**核心思路**：  
1. **前缀和+后缀和预处理**：分别统计前 $i$ 个位置的 $0$ 的数量和后 $n-i$ 个位置的 $1$ 的数量。
2. **枚举分割点**：遍历所有可能的分割点 $i \in [0,n]$，检查左右区间的合法性。
3. **数学等价转换**：用整数运算 $(i+1)/2$ 代替 $\lceil i/2 \rceil$ 避免浮点计算。
4. **距离优化**：维护最小中心距离，优先取更左的解。

**关键技巧**：  
- 预处理数组的构造需覆盖边界情况（i=0和i=n）
- 使用整数运算处理向上取整，避免浮点精度问题
- 双指针思想快速验证条件

---

### 高星题解推荐

#### 题解1：作者 jubingkun（★★★★★）
**亮点**：  
- 变量命名清晰（pre/suc数组）
- 显式处理边界条件（i=0和i=n）
- 注释明确说明关键逻辑
```cpp
// 前缀和pre[i]表示前i个位置0的数量
// 后缀和suc[i]表示从i到末尾1的数量
for(int i=0; i<=n; i++) {
    if(pre[i] >= (i+1)/2 && suc[i+1] >= (n-i+1)/2) {
        // 更新最优解逻辑
    }
}
```

#### 题解2：作者 Otue（★★★★☆）
**亮点**：  
- 代码简洁高效
- 使用浮点数直接计算中心距离
- 完整处理分割点全范围
```cpp
for(int i=0; i<=n; i++){
    if(sum[i] >= (i+1)/2 && pre[i+1] >= (n-i+1)/2){
        if(fabs(n/2.0 -i) < res) {
            // 更新最优解
        }
    }
}
```

#### 题解3：作者 SCAR_L（★★★★☆）
**亮点**：  
- 详细注释说明边界条件
- 代码结构清晰易扩展
- 包含调试经验总结（坑点提示）
```cpp
// 处理i=0时左边0个房屋的特殊情况
// 使用(i+1)/2代替ceil，避免浮点运算
if(p1[i] >= (i+1)/2 && p2[i+1] >= (n-i+1)/2){
    // 距离比较逻辑
}
```

---

### 相似题目推荐
1. **P1115 最大子段和**（前缀和经典问题）
2. **P3406 海底高铁**（差分数组+区间统计）
3. **P3131 Subsequences Summing to Sevens**（前缀和+模运算）

---
处理用时：94.94秒
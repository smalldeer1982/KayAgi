# 题目信息

# Outstanding Impressionist

## 题目描述

Eric 仍然记得整数数组形式的 $n$ 个印象。他将它们记录为 $w_1,w_2,\ldots,w_n$ 。然而，他对印象的记忆力很差。对于每个 $1\leq i\leq n$ ，他只能记住 $ l_i \leq w_i \leq r_i $ 。

Eric 认为，印象 $i$ 是唯一的，当且仅当存在一个可能的数组 $w_1,w_2,\ldots,w_n$ ，使得 $w_i\neq w_j$ 对所有具有 $j\neq i$ 的 $1\leq j\leq n$ 都成立。

请帮助 Eric 确定印象 $i$ 是否对每个 $1\leq i\leq n$ 是唯一的，对每个 $i$ 是独立的。也许你的判断可以帮助改写最后的故事。

## 样例 #1

### 输入

```
5
2
1 1
1 1
4
1 3
1 3
1 3
1 3
6
3 6
2 2
1 2
1 1
3 4
2 2
7
3 4
4 4
4 4
1 3
2 5
1 4
2 2
3
4 5
4 4
5 5```

### 输出

```
00
1111
100110
1001111
011```

# AI分析结果



### 题目重写
#### 题目名称：杰出印象派

**题目描述**  
Eric 记录了 $n$ 个印象，表示为整数数组 $w_1, w_2, \ldots, w_n$。对于每个 $1 \leq i \leq n$，他只能确定 $l_i \leq w_i \leq r_i$ 的范围。  
印象 $i$ 是唯一的，当且仅当存在一个可能的数组 $w$，使得 $w_i \neq w_j$ 对所有 $j \neq i$ 成立。  
请对每个 $i$ 判断其是否为唯一。

**输入格式**  
多组测试数据，每组数据第一行为 $n$，随后 $n$ 行每行为 $l_i$ 和 $r_i$。

**输出格式**  
每组数据输出一行，表示每个 $i$ 是否为唯一（`1` 或 `0`）。

---

### 题解综合分析

#### 关键思路总结
1. **固定点与区间分离**：  
   - 若 $l_j = r_j$（称为固定点），则 $w_j$ 必须取该值，可能影响其他位置的选择。
   - 若 $l_j < r_j$（称为区间），则总能调整 $w_j$ 的值避免与其他位置冲突。
2. **覆盖性检查**：  
   - 对于区间 $[l_i, r_i]$，若其所有值均被其他固定点覆盖，则无法找到唯一的 $w_i$。
   - 使用前缀和统计固定点的覆盖情况，快速判断区间是否被完全覆盖。
3. **特判固定点**：  
   - 若 $i$ 是固定点，需检查该值是否被其他固定点覆盖超过一次。

---

### 高分题解推荐

#### 1. 题解作者：zhangzirui66（★★★★☆）
**核心思路**  
- 预处理所有固定点，用数组标记覆盖情况。
- 前缀和快速计算区间内固定点数量。
- 特判固定点自身覆盖次数。

**关键代码**  
```cpp
int f[400005]; // 标记区间覆盖状态
for (int i = 1; i <= n; i++) {
    if (a[i] == b[i]) mp[a[i]]++; // 记录固定点
}
// 前缀和计算覆盖密度
for (int i = 1; i <= 2 * n; i++) f[i] += f[i - 1];
// 判断区间是否完全覆盖
if (f[b[i]] - f[a[i] - 1] == b[i] - a[i] + 1) cout << 0;
```

#### 2. 题解作者：Autumn_Rain（★★★★☆）
**核心思路**  
- 统计固定点的出现次数，用前缀和判断区间覆盖密度。
- 直接推导区间是否被完全覆盖。

**关键代码**  
```cpp
int pre[N]; // 前缀和数组
for (int i = 1; i <= 2*n; i++) pre[i] = pre[i-1] + (cnt[i]>0);
// 区间覆盖判断
int k = pre[r[i]] - pre[l[i]-1];
if (k == r[i]-l[i]+1) cout << 0;
```

#### 3. 题解作者：linch（★★★★☆）
**核心思路**  
- 用前缀和数组维护固定点的覆盖情况。
- 简洁的条件判断逻辑，高效处理区间查询。

**关键代码**  
```cpp
int pre[maxn]; // 前缀和统计固定点
pre[i] = pre[i-1] + (cnt[i] > 0);
// 覆盖性判断
if (pre[r[i]] - pre[l[i]-1] == r[i]-l[i]+1) cout << 0;
```

---

### 优化技巧与同类题目
1. **前缀和压缩查询**：将区间覆盖问题转化为前缀和差值计算，复杂度从 $O(n^2)$ 降至 $O(n)$。
2. **固定点分离处理**：将问题拆分为固定点和区间两类，降低问题复杂度。
3. **同类题目推荐**：  
   - [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)（覆盖路径判断）
   - [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（区间覆盖统计）
   - [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)（二维前缀和应用）

---

### 调试与心得摘录
- **数组越界**：如题解 zhangzirui66 提到 `f` 数组需开两倍空间，否则 WA。
- **边界处理**：前缀和计算时需注意区间端点是否包含，例如 `f[r] - f[l-1]` 的正确性。
- **固定点自包含**：判断固定点是否唯一时需排除自身的影响（如 `mp[a[i]] == 1`）。

---
处理用时：57.22秒
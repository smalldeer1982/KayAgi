# 题目信息

# Jumping on Walls

## 题目描述

瓦西亚在和忍者玩电脑游戏。在这个关卡，瓦西亚需要操控忍者走出一个很深的峡谷。

峡谷由两面垂直于地面且互相平行的墙组成，它们的高度为$n$米。我们将这些墙分成许多$1$米长的区域，并从下到上用$1$到$n$的正整数对它们进行编号。有些地方是安全的，忍者可以爬上去。有些地方石头很尖锐，忍者不能待在那里。我们称这些地区为危险地区。

最初忍者在左墙的最下方。他每秒可以执行以下操作之一：

* 向上爬一个区域；
* 向下爬一个区域；
* 跳到对面的墙上。忍者会跳到比他当前所在高度高$k$米的地方。更准确地说，如果在跳跃之前忍者位于一面墙的区域$x$，那么在跳跃之后，他位于另一面墙的区域$x + k$。

如果在某个时间点忍者到达了一个高度大于$n$的区域，那么忍者就可以从峡谷中出来了。

但峡谷被水淹没了，每秒水位会上升一米。最初，水位达到区域$1$的下边界。忍者不能待在被水淹没的地方。忍者和水轮流移动——首先忍者行动，然后水上升一米，然后忍者再行动，以此类推。

如果忍者可以离开峡谷，那这个关卡就完成了。

在几次失败的尝试之后，瓦西亚开始怀疑是否有可能完成这一关卡。请回答他的问题。

## 说明/提示

在第一个样例中，忍者可以先跳到右边的墙，然后沿着右边的墙往下走一米，然后跳到左边的墙。再跳跃一次忍者就可以离开峡谷。

在第二个样例中，忍者是无法离开峡谷的。

## 样例 #1

### 输入

```
7 3
---X--X
-X--XX-
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
6 2
--X-X-
X--XX-
```

### 输出

```
NO
```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕忍者逃出峡谷问题展开，思路上主要分为深度优先搜索（DFS）和广度优先搜索（BFS）两类。

#### 思路对比
- **DFS类**：乐乐乐还在乐、Juanzhang、Allanljx 的题解使用 DFS。他们通过递归搜索忍者的所有可能行动，记录水的深度、忍者所在墙和高度作为状态。核心是判断出口条件（逃出、淹死、到危险地带）和剪枝（避免重复访问）。
- **BFS类**：Alex_Wei、_segmenttree、Federico2903 的题解使用 BFS。借助队列存储忍者状态，按层扩展搜索，同样要判断状态合法性和避免重复访问。

#### 算法要点对比
- **DFS**：关键在于递归函数的设计，清晰定义状态转移和出口条件，剪枝是优化重点，避免不必要的搜索。
- **BFS**：利用队列实现按层搜索，每次从队列取出状态，扩展出下一层可能状态，入队继续搜索。

#### 解决难点对比
- **DFS**：剪枝是难点，如乐乐乐还在乐提到一开始未剪枝导致超时，后来通过记录已访问位置解决。
- **BFS**：状态合法性判断和边界处理是关键，如要先判断越界再判断是否走过，避免数组越界。

### 评分较高的题解
- **乐乐乐还在乐（5星）**
    - **关键亮点**：思路清晰，详细阐述 DFS 五步骤（状态、转移、初始状态、出口、剪枝），代码注释丰富，易于理解。
    - **个人心得**：一开始未剪枝提交喜提 TLE，仔细思考后发现记录已访问位置可剪枝。
    - **核心代码**：
```cpp
bool dfs(int water, int where, int height) {
    if (height > n) return true;
    if (rmb[where][height] == 1) return false;
    if (a[where][height] == 0) return false;
    if (water > height) return false;
    rmb[where][height] = 1;
    return dfs(water + 1, where ^ 1, height + k) ||
           dfs(water + 1, where, height + 1) ||
           dfs(water + 1, where, height - 1);
}
```
- **Alex_Wei（4星）**
    - **关键亮点**：适合 BFS 基础练习，详细说明 BFS 思路，代码结构清晰，对状态判断和扩展解释明确。
    - **核心代码**：
```cpp
struct pos {
    int h, id, t;
};
queue <pos> q;
while (!q.empty()) {
    pos t = q.front(), nw; q.pop();
    nw = t; nw.h--; nw.t++;
    if (nw.h > 0 &&!pd[nw.h][nw.id] && nw.h > nw.t)
        pd[nw.h][nw.id] = 1, q.push(nw);
    nw = t; nw.h++; nw.t++;
    if (nw.h > n) cout << "YES", exit(0);
    if (!pd[nw.h][nw.id] && nw.h > nw.t)
        pd[nw.h][nw.id] = 1, q.push(nw);
    nw = t; nw.h += k; nw.id =!nw.id; nw.t++;
    if (nw.h > n) cout << "YES", exit(0);
    if (!pd[nw.h][nw.id] && nw.h > nw.t)
        pd[nw.h][nw.id] = 1, q.push(nw);
}
```
- **Federico2903（4星）**
    - **关键亮点**：BFS 思路清晰，对题意和代码细节解释详细，使用结构体表示忍者位置，代码可读性高。
    - **核心代码**：
```cpp
struct pos {
    int h, t;
    int way;
    pos() {}
    pos(int h, int t, int way) {
        this->h = h;
        this->t = t;
        this->way = way;
    }
};
queue<pos> q;
void bfs(pos start) {
    q.push(start);
    wall[1][0] = 1;
    while (!q.empty()) {
        pos t = q.front();
        q.pop();
        if (t.h - 1 > 0 &&!wall[t.h - 1][t.way] && t.h - 1 > t.t + 1) {
            wall[t.h - 1][t.way] = 1;
            q.push(pos(t.h - 1, t.t + 1, t.way));
        }
        if (t.h + 1 > n) {
            cout << "YES";
            return;
        }
        if (!wall[t.h + 1][t.way] && t.h + 1 > t.t + 1) {
            wall[t.h + 1][t.way] = 1;
            q.push(pos(t.h + 1, t.t + 1, t.way));
        }
        if (t.h + k > n) {
            cout << "YES";
            return;
        }
        if (!wall[t.h + k][!t.way] && t.h + k > t.t + 1) {
            wall[t.h + k][!t.way] = 1;
            q.push(pos(t.h + k, t.t + 1,!t.way));
        }
    }
    cout << "NO";
    return;
}
```

### 最优关键思路或技巧
- **剪枝优化**：DFS 中记录已访问位置，避免重复搜索，减少时间复杂度。
- **状态记录**：使用二维数组记录墙的状态和忍者是否访问过，方便状态判断。
- **BFS 队列**：利用队列按层搜索，确保搜索的广度优先性，避免深度过深导致栈溢出。

### 可拓展之处
同类型题如迷宫问题、棋盘问题等，都可使用 DFS 或 BFS 解决。类似算法套路包括状态记录、剪枝优化、边界处理等。

### 推荐洛谷题目
1. P1135 奇怪的电梯：涉及状态转移和搜索，可使用 BFS 或 DFS 解决。
2. P1605 迷宫：经典的迷宫搜索问题，适合练习 DFS 和 BFS。
3. P3956 棋盘：棋盘上的搜索问题，需要考虑多种行动方式和状态判断。

---
处理用时：34.20秒
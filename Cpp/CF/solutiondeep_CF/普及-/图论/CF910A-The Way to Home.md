# 题目信息

# The Way to Home

## 题目描述

一只青蛙现在在一个数轴上，它现在要从点 $1$ 跳到点 $n$ ，它每次可以向右跳不超过 $d$ 个单位。比如，它可以从点 $x$ 跳到点 $x+a$  $( 1<=a<=d )$ 。特别的，青蛙只能在有百合花的点上停留。保证点 $1$ 和点 $n$ 之间有一些点有百合花。请输出青蛙到达点 $n$ 的最小跳跃次数。

## 说明/提示

在样例1中，青蛙可以从点 $1$ 跳3个单位到点 $4$ ，再从点 $4$ 跳4个单位到点 $8$ .
在样例2中，青蛙不能到达点 $n$ ，因为它至少需要跳3个单位，但它最多只能跳2个单位。

由 @星烁晶熠辉 提供翻译

## 样例 #1

### 输入

```
8 4
10010101
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 2
1001
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
8 4
11100101
```

### 输出

```
3
```

## 样例 #4

### 输入

```
12 3
101111100101
```

### 输出

```
4
```

# AI分析结果

### 题解综合分析与结论
这些题解提供了多种解决青蛙跳跃问题的思路，涵盖了搜索、贪心、动态规划和图论等算法。
- **思路对比**
    - **搜索类**：包括深度优先搜索（DFS）和递归搜索，通过枚举所有可能的跳跃路径找到最小跳跃次数，如学而思李老师、hhrq、ynn_2009、风云幻的题解。
    - **贪心类**：贪心策略是每次尽可能跳最远的距离，以最少的步数到达终点，如wky32768、Lips、Vector_的题解。
    - **动态规划类**：通过定义状态和状态转移方程，逐步计算到达每个点的最小跳跃次数，如空气树、jiangXxin的题解。
    - **图论类**：将问题转化为图论的最短路问题，使用SPFA、Floyd等算法求解，如Siyuan、pnpn111、hater的题解。
- **算法要点**
    - **搜索类**：关键在于递归调用和剪枝优化，避免不必要的搜索。
    - **贪心类**：核心是每次选择最优的跳跃位置，减少跳跃次数。
    - **动态规划类**：重点是定义合适的状态和状态转移方程，通过子问题的解来求解原问题。
    - **图论类**：需要构建图结构，并选择合适的最短路算法进行求解。
- **解决难点**
    - **搜索类**：难点在于如何设计有效的剪枝策略，避免超时。
    - **贪心类**：要证明贪心策略的正确性，确保每次选择的最优解能得到全局最优解。
    - **动态规划类**：关键是找到合适的状态表示和状态转移方程，以及处理边界条件。
    - **图论类**：需要熟悉图的构建和最短路算法的实现。

### 所选题解
- **学而思李老师（5星）**
    - **关键亮点**：详细介绍了递归和深度优先搜索的概念，并对代码进行了优化，通过剪枝减少了搜索的时间复杂度。
    - **个人心得**：无
    - **核心代码**
```cpp
// 优化后的dfs函数
void dfs(int pos, int step)
{
    if(pos + d >= n) {
        ans = min(ans, step + 1);
        return;
    }
    for(int i = d; i >= 1; i --)
        if(s[pos + i] == '1') {
            dfs(pos + i, step + 1);
            break;
        }
}
```
- **空气树（4星）**
    - **关键亮点**：运用动态规划思想，代码简洁易懂，通过枚举前面可以一步跳来的地方，更新当前位置的最小跳跃次数。
    - **个人心得**：本着万物皆可DP的原则，运用DP解决问题。
    - **核心代码**
```cpp
for(int i = 2; i <= n; i++){
    if(a[i] == '0') continue;
    f[i] = 1 << 30;
    for(int j = i - 1; j >= max(i - k, 1); j--){
        if(a[j] == '0') continue;
        f[i] = min(f[i], f[j] + 1);
    }
}
```
- **Lips（4星）**
    - **关键亮点**：贪心思路简单直接，代码实现简洁，通过从最远的点往前遍历，找到第一个有荷花的点进行跳跃。
    - **个人心得**：奔着“最短路”标签来，结果用贪心算法AC了，体现了贪心算法的简洁性。
    - **核心代码**
```cpp
while(now!= len) {
    bool flag = 0;
    for(register int i = now + d; i >= now + 1; i--)
        if(s[i] == '1') {
            now = i, flag = 1;
            break;
        }
    if(flag == 0) {
        printf("-1\n");
        return 0;
    }
    else ans++;
}
```

### 最优关键思路或技巧
- **贪心策略**：每次尽可能跳最远的距离，减少跳跃次数，是一种简单高效的解决方法。
- **剪枝优化**：在搜索过程中，通过剪枝策略去除对最终答案没有贡献的子树，减少搜索的时间复杂度。
- **动态规划**：定义合适的状态和状态转移方程，通过子问题的解来求解原问题，适用于具有最优子结构和重叠子问题的问题。

### 拓展思路
同类型题或类似算法套路：
- 其他跳跃问题，如青蛙过河、机器人跳跃等，可使用类似的贪心、动态规划或搜索算法解决。
- 路径规划问题，如迷宫寻路、地图导航等，可转化为图论的最短路问题进行求解。

### 推荐题目
- [P1052 过河](https://www.luogu.org/problem/P1052)：与本题类似，需要考虑跳跃的距离和可停留的位置，可使用动态规划解决。
- [P1118 [USACO06FEB]Backward Digit Sums G/S](https://www.luogu.org/problem/P1118)：可以使用搜索算法枚举所有可能的排列，找到满足条件的解。
- [P1216 [USACO1.5]数字三角形 Number Triangles](https://www.luogu.org/problem/P1216)：经典的动态规划问题，通过定义状态和状态转移方程，计算从顶部到底部的最大路径和。

### 个人心得摘录与总结
- **Lips**：奔着“最短路”标签来，结果用贪心算法AC了，说明在解题时不要局限于标签，要尝试不同的算法思路。
- **空气树**：本着万物皆可DP的原则，运用DP解决问题，体现了动态规划的广泛适用性。

---
处理用时：30.55秒
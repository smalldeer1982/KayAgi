# 题目信息

# DZY Loves Chessboard

## 题目描述

一个棋盘上有一些格子是坏的，另一些是正常的。对于每一个正常的格子，都要在上面放上棋子。
请找到一组解使没有两个相同颜色的棋子相邻(两个格子相邻为它们存在共同的边)

## 样例 #1

### 输入

```
1 1
.
```

### 输出

```
B
```

## 样例 #2

### 输入

```
2 2
..
..
```

### 输出

```
BW
WB
```

## 样例 #3

### 输入

```
3 3
.-.
---
--.```

### 输出

```
B-B
---
--B```

# AI分析结果

### 题目内容重写
#### DZY Loves Chessboard

**题目描述**

一个棋盘上有一些格子是坏的，另一些是正常的。对于每一个正常的格子，都要在上面放上棋子。请找到一组解，使得没有两个相同颜色的棋子相邻（两个格子相邻为它们存在共同的边）。

**样例 #1**

**输入**

```
1 1
.
```

**输出**

```
B
```

**样例 #2**

**输入**

```
2 2
..
..
```

**输出**

```
BW
WB
```

**样例 #3**

**输入**

```
3 3
.-.
---
--.
```

**输出**

```
B-B
---
--B
```

### 题解分析与结论

#### 综合分析

本题的核心问题是在一个棋盘上放置黑白棋子，要求相邻的棋子颜色不同。坏掉的格子不需要放置棋子，直接输出`'-'`即可。大多数题解采用了两种主要思路：

1. **直接模拟**：通过判断格子的位置（行号加列号的奇偶性）来决定放置`B`或`W`。这种方法简单高效，时间复杂度为O(n*m)。
2. **DFS/BFS**：通过深度优先搜索或广度优先搜索来遍历棋盘，确保相邻的棋子颜色不同。这种方法虽然也能解决问题，但代码复杂度较高，且在实际应用中效率不如直接模拟。

#### 最优关键思路

最优的解决思路是**直接模拟**，利用棋盘的行号和列号的奇偶性来决定每个格子的颜色。具体来说，对于每个正常的格子，如果`(i + j) % 2 == 0`，则放置`B`，否则放置`W`。这种方法简单、高效，且代码实现简洁。

#### 可拓展之处

这种基于奇偶性的棋盘填充方法可以推广到其他类似的棋盘问题，如国际象棋棋盘的填充、四色问题等。类似的思路还可以用于解决图论中的二分图问题。

#### 推荐题目

1. [P1219 八皇后问题](https://www.luogu.com.cn/problem/P1219) - 考察棋盘填充与回溯算法。
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 考察棋盘上的广度优先搜索。
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 考察棋盘上的深度优先搜索与边界处理。

### 高星题解精选

#### 题解1：作者：zhaotiensn (赞：11)

**星级：★★★★★**

**关键亮点**：直接利用棋盘的行号和列号的奇偶性来决定每个格子的颜色，代码简洁高效。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    a=getchar(); // 读入换行符，防止被换行符影响
    for(int j=1;j<=m;j++){
        a=getchar(); // 读入a[i][j]的状态
        if(a=='-'){ // 为坏就直接输出'-'
            putchar('-');
        }else{
            if((i+j)&1){ // (i+j)%2==1就把当前块变成白
                putchar('W');
            }else{
                putchar('B'); // 否则变成黑
            }
        }
    }
    puts("");
}
```

#### 题解2：作者：chenxirui (赞：3)

**星级：★★★★☆**

**关键亮点**：通过观察国际象棋棋盘的规律，直接输出黑白交替的棋盘，代码简洁。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++){
    for(int j = 1; j <= m; j++){
        if(s[i][j] == '.'){
            if((j%2) == (i%2)) printf("B"); // 找规律可知，找这种算法构造解的时候如果两个字同奇偶性，就是黑
            else printf("W"); // 否则就是白
        }else printf("-"); // 坏掉原样输出
    }
    printf("\n");
}
```

#### 题解3：作者：棽木 (赞：0)

**星级：★★★★☆**

**关键亮点**：直接在读入时处理每个格子，利用奇偶性决定颜色，代码简洁高效。

**核心代码**：
```cpp
for(int i=0; i<n; i++){
    cin>>mp[i]; // 读一行
    for(int j=0; j<m; j++) // 处理这一行
        if(mp[i][j]=='.') // 如果这个位置是好的
            (i+j)%2==0 ? mp[i][j]='B' : mp[i][j]='W' ; 
    cout<<mp[i]<<endl; // 同时输出改好的这一行
}
```

### 个人心得摘录

- **zhaotiensn**：通过观察国际象棋棋盘的规律，发现可以直接利用行号和列号的奇偶性来决定每个格子的颜色，避免了复杂的搜索算法。
- **chenxirui**：发现坏掉的格子不影响答案，直接输出即可，简化了问题的处理。
- **棽木**：直接在读入时处理每个格子，减少了代码的复杂度，提高了效率。

### 总结

最优的解决思路是**直接模拟**，利用棋盘的行号和列号的奇偶性来决定每个格子的颜色。这种方法简单、高效，且代码实现简洁。类似的思路可以推广到其他棋盘问题或图论中的二分图问题。

---
处理用时：33.65秒
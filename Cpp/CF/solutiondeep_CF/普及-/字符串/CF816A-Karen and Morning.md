# 题目信息

# Karen and Morning

## 题目描述

可怜已经准备好迎接在学校的新的一天。

现在是hh:mm，一个被以24小时制给与的时间。正如你所知道的，可怜喜欢回文，并且她相信如果在她醒来时的时间是回文的话会给她带来好运。

当她醒来时时间是回文的话，她最少应当睡多长时间？

记住，一个回文数是一个从前读和从后读相同的字符串。例如，05:39是不是回文数，因为05:39倒着读是93:50。另一方面，05:50是回文，因为05:50倒着读是05:50。

## 说明/提示

在第一个样例中，可怜最少应睡的时间为$11$ ，这样她可以在05:50时醒来，这是一个回文时间。

在第二个样例中，可怜可以立刻起来，当前时间13:31就是一个回文。

在第三个样例中，可怜最少应睡的时间为$1$ 分钟。她可以在00:00醒来，这是一个回文时间。

感谢@Khassar 提供的翻译

## 样例 #1

### 输入

```
05:39
```

### 输出

```
11
```

## 样例 #2

### 输入

```
13:31
```

### 输出

```
0
```

## 样例 #3

### 输入

```
23:59
```

### 输出

```
1
```

# AI分析结果

### 题目内容重写
# Karen和早晨

## 题目描述

Karen已经准备好迎接在学校的新的一天。

现在是hh:mm，一个以24小时制给出的时间。正如你所知道的，Karen喜欢回文，并且她相信如果在她醒来时的时间是回文的话会给她带来好运。

当她醒来时时间是回文的话，她最少应当睡多长时间？

记住，一个回文数是一个从前读和从后读相同的字符串。例如，05:39不是回文数，因为05:39倒着读是93:50。另一方面，05:50是回文，因为05:50倒着读是05:50。

## 说明/提示

在第一个样例中，Karen最少应睡的时间为$11$，这样她可以在05:50时醒来，这是一个回文时间。

在第二个样例中，Karen可以立刻起来，当前时间13:31就是一个回文。

在第三个样例中，Karen最少应睡的时间为$1$分钟。她可以在00:00醒来，这是一个回文时间。

### 题解分析与结论

#### 综合分析与结论
本题的核心是通过模拟时间的变化，找到从当前时间开始的下一个回文时间，并计算所需的时间差。大多数题解采用了直接模拟时间变化的方法，通过逐分钟增加时间并判断是否为回文来解决。部分题解通过预处理所有可能的回文时间，然后使用二分查找来优化查找过程。

#### 最优关键思路
1. **时间模拟**：通过逐分钟增加时间，并处理进位（如分钟到小时，小时到24小时归零），直到找到下一个回文时间。
2. **回文判断**：将时间转换为字符串，判断其是否与反转后的字符串相同。
3. **预处理回文时间**：预先计算所有可能的回文时间，然后通过二分查找快速定位下一个回文时间。

#### 可拓展之处
- **时间处理**：类似的时间模拟问题可以扩展到其他时间格式或更复杂的时间计算。
- **回文判断**：回文判断可以应用于其他字符串处理问题，如回文子串、回文数等。

### 推荐题目
1. [P1088 时间计算](https://www.luogu.com.cn/problem/P1088)
2. [P1012 回文数](https://www.luogu.com.cn/problem/P1012)
3. [P1013 进制转换](https://www.luogu.com.cn/problem/P1013)

### 精选题解

#### 题解1：作者：引领天下 (赞：4)
**星级**：★★★★☆
**关键亮点**：直接使用字符串模拟时间变化，代码简洁明了，处理进位逻辑清晰。
**核心代码**：
```cpp
while (s!=r(s)){//不回文
    ans++;
    s[4]++;//分+1
    if (s[4]>'9')s[4]='0',s[3]++;//分满十进一
    if (s[3]>='6')s[3]=s[4]='0',s[1]++;//十满六进一
    if (s[1]>'9')s[1]='0',s[0]++;//时满10进一
    if (s[0]=='2'&&s[1]=='4')s[0]=s[1]='0';//时满24归零
}
```

#### 题解2：作者：GZY007 (赞：1)
**星级**：★★★★☆
**关键亮点**：预处理所有回文时间，使用二分查找优化查找过程，效率较高。
**核心代码**：
```cpp
for(int i=0;i<=23;i++){
    int x=(i%10)*10+i/10;
    if(x>59) continue ;
    a[++cnt]=i*60+x;
}
if(t>a[cnt]) ans=1440-t+a[1];
else ans=a[lower_bound(a+1,a+cnt+1,t)-a]-t;
```

#### 题解3：作者：Eason_AC (赞：1)
**星级**：★★★★☆
**关键亮点**：利用scanf按格式读入时间，直接枚举所有可能的回文时间，代码结构清晰。
**核心代码**：
```cpp
while(1) {
    if((h == 0 && m == 0) || (h == 1 && m == 10) || ... ) {
        writeint(ans);
        break;
    }
    m++, ans++;
    if(m > 59) h++, m = 0;
    if(h > 23) h = 0;
}
```

### 个人心得摘录
- **调试经历**：在处理时间进位时，需要注意小时和分钟的边界条件，特别是23:59到00:00的转换。
- **踩坑教训**：直接使用字符串模拟时，字符与数字的转换容易出错，需谨慎处理。
- **顿悟感想**：预处理回文时间并使用二分查找可以显著提高效率，尤其是在大规模数据下。

---
处理用时：32.39秒
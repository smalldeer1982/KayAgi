# 题目信息

# Homework

## 题目描述

Gerald在上学的一天，他的老师在班上布置了一项作业：她给每个同学一个有n个小写拉丁字母（即英文字母）的字符串，要求学生学习这个字符串中的字母的写法。但是，由于Gerald太懒了，他不想学习这些字母。这就是为什么他决定丢掉这个字符串的部分（不需要是连续的一部分）。他所丢失的部分可以由若干个任意长度在任意位置的连续的子字符串组成。但是，Gerald知道，如果他丢掉了超过k个字母，他就会显得非常可疑。

请求出在不超过k个字母被删除之后，字符串中最少剩下多少个不同的字母。你还需要求出一种删除这些字母的方式。

## 说明/提示

在第一个样例中这个字符串含有5个字母但是你只允许删去其中4个，所以会剩下至少一个字母。所以，正确答案就是1和任意一个长度在1到5的、只含有字母a的字符串。

在第二个杨立忠你可以删去4个字母。你不能删去所有的字母，因为这个字符串的长度是7。 但是，你可以删去所以除了a以外的字母（这样的字母不多于4个），所以得到的答案是"aaaa"。

在第三个样例中字符串的长度是8，且k=10，所以可以将所有的字母都删去。正确答案是0和空字符串。

Translated by @oolliivveerr

## 样例 #1

### 输入

```
aaaaa
4
```

### 输出

```
1
aaaaa
```

## 样例 #2

### 输入

```
abacaba
4
```

### 输出

```
1
aaaa
```

## 样例 #3

### 输入

```
abcdefgh
10
```

### 输出

```
0

```

# AI分析结果

### 综合分析与结论
这些题解均采用贪心算法解决问题，核心思路是统计每个字母的出现次数，按出现次数从小到大排序，优先删除出现次数少的字母，直到不能再删或达到删除上限。

- **思路对比**：多数题解使用结构体或数组来存储字母及其出现次数，部分题解使用 `map` 来统计。排序后，通过遍历判断是否能删除当前字母种类。
- **算法要点**：统计字母出现次数、排序、贪心删除。
- **解决难点**：正确统计字母出现次数并排序，合理控制删除过程，避免删除过多字母。

### 所选的题解
- **liuyifan（4星）**
  - **关键亮点**：思路清晰，使用 `sort` 自定义比较函数按字母出现次数排序，代码简洁。
  - **个人心得**：无
```cpp
inline bool cmp(const int &x, const int &y) {
    return a[x] < a[y];
}
sort(d, d + 26, cmp);
for (reg int i = 0; i < 26; i++) {
    if (k < a[d[i]]) break;
    k -= a[d[i]];
    f[d[i]]++;
}
```
- **小恐（4星）**
  - **关键亮点**：使用结构体存储字母及其出现次数，逻辑清晰，注释详细。
  - **个人心得**：无
```cpp
struct node {
    int cnt;
    char ch;
};
bool cmp(node x, node y) {
    return x.cnt < y.cnt;
}
sort(f, f + 26, cmp);
for (int i = start; i < 26; i++) {
    if (f[i].cnt > k) {
        ans = 26 - i;
        break;
    }
    book[f[i].ch - 'a'] = 1;
    k -= f[i].cnt;
}
```
- **happybob（4星）**
  - **关键亮点**：使用 `map` 统计字母出现次数，再转成 `vector` 排序，贪心删除，代码实现巧妙。
  - **个人心得**：疑惑该做法为何没超时。
```cpp
map<char, int> mp;
for (int i = 0; i <= len; i++) {
    mp[s[i]]++;
}
vector< pair<char, int> > vec(mp.begin(), mp.end());
sort(vec.begin(), vec.end(), cmp);
for (auto it = vec.begin(); it != it_end; ++it) {
    if (k <= 0 || k < (*it).second) {
        break;
    } else {
        k -= (*it).second;
        cnt--;
        tmp += (*it).first;
    }
}
```

### 最优关键思路或技巧
- **贪心策略**：优先删除出现次数少的字母，可使剩余字母种类最少。
- **排序优化**：使用 `sort` 函数结合自定义比较函数对字母按出现次数排序。
- **数据结构选择**：可使用结构体、数组、`map` 等存储字母及其出现次数。

### 可拓展之处
同类型题可拓展到其他字符集或条件限制，如可删除的字符种类有限制、需满足特定的字符顺序等。类似算法套路可应用于资源分配、任务调度等问题，核心是贪心选择最优解。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心算法，每次合并最小的两堆果子。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法，按接水时间从小到大排序。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法，按单位价值从大到小选择物品。

---
处理用时：23.66秒
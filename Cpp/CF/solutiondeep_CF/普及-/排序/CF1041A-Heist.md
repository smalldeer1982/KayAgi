# 题目信息

# Heist

## 题目描述

昨晚有一家电子商店被抢劫了。

昨天在商店里的所有键盘都是从$x$开始按升序编号的。例如，如果$x=4$，并且商店中有$3$个键盘，那么编号就为$4,5,6$；如果$x=10$，并且有$7$个键盘，那么编号就为$10,11,12,13,14,15,16$。

在抢劫之后，只有$n$个键盘仍然存在，他们的编号分别为$a_1,a_2,\dots ,a_n$。计算被盗的键盘的最小可能数量。工作人员不记得$x$也不记得商店里原来有几个键盘。

## 样例 #1

### 输入

```
4
10 13 12 8
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
7 5 6 4 8
```

### 输出

```
0
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是围绕着计算被盗键盘的最小数量展开。由于键盘编号是连续的升序序列，所以只需要找出剩余键盘编号中的最大值和最小值，计算出原本最少应该有的键盘数量（最大值 - 最小值 + 1），再减去现有的键盘数量，就可以得到被盗键盘的最小数量。

#### 思路对比
- **排序法**：部分题解先对输入的键盘编号数组进行排序，然后通过数组首尾元素确定最大值和最小值，进而计算结果。
- **直接找最值法**：大部分题解不进行排序，而是在输入过程中直接记录最大值和最小值，这种方法更高效，时间复杂度为 $O(n)$。
- **遍历法**：有题解通过遍历排序后的数组，计算相邻元素之间缺失的键盘数量并累加得到结果。

#### 算法要点
- **排序**：使用 `std::sort` 函数对数组进行排序，时间复杂度为 $O(n log n)$。
- **找最值**：在输入过程中使用 `max` 和 `min` 函数不断更新最大值和最小值，时间复杂度为 $O(n)$。
- **计算被盗数量**：用最大值减去最小值加 1 得到原本最少的键盘数量，再减去现有键盘数量。

#### 解决难点
本题的难点在于理解题意，明确要计算被盗键盘的最小数量，关键是确定原本最少应该有多少个键盘。通过分析可知，以剩余键盘编号中的最小值作为起始编号，最大值作为结束编号，这样得到的键盘数量是最少的。

#### 评分
- **been_apart**：4星。思路清晰，代码简洁，使用排序法解决问题，不过可以优化为不排序直接找最值。
- **piggymichael**：4星。思路清晰，代码简洁，直接在输入过程中找最值，避免了排序的时间开销。
- **ezoixx130**：4星。思路清晰，代码简洁，直接找最值，同时给出了时间和空间复杂度分析。

### 所选题解
- **been_apart（4星）**：关键亮点是思路清晰，代码简洁，使用排序法解决问题。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    sort(a,a+n);
    cout<<a[n-1]-a[0]+1-n<<endl;
    return 0;
}
```
核心实现思想：先读入所有键盘编号，然后对数组进行排序，最后通过数组首尾元素计算被盗键盘的最小数量。

- **piggymichael（4星）**：关键亮点是不使用排序，直接在输入过程中找最值，优化了时间复杂度。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,minn=0x3f3f3f3f,maxn=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>a;
        minn=min(a,minn);
        maxn=max(a,maxn);
    }
    cout<<maxn-minn+1-n<<endl;
    return 0;
}
```
核心实现思想：在输入每个键盘编号时，不断更新最大值和最小值，最后计算被盗键盘的最小数量。

- **ezoixx130（4星）**：关键亮点是思路清晰，代码简洁，直接找最值，同时给出了时间和空间复杂度分析。
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,a[1001],maxn,minn=2147483647;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",a+i),maxn=max(maxn,a[i]),minn=min(minn,a[i]);
    printf("%d\n",maxn-minn+1-n);
}
```
核心实现思想：在输入过程中记录最大值和最小值，最后计算被盗键盘的最小数量。

### 最优关键思路或技巧
直接在输入过程中使用 `max` 和 `min` 函数记录最大值和最小值，避免排序的时间开销，时间复杂度为 $O(n)$。

### 拓展思路
同类型题或类似算法套路：这类题目主要考察对连续序列的理解和处理，例如求连续区间内缺失的数字、计算连续数列的长度等。解题关键在于找出序列的特征，如最大值、最小值、公差等，然后根据这些特征进行计算。

### 推荐洛谷题目
1. P1047 [NOIP2005 普及组] 校门外的树：计算区间内被移除的元素数量。
2. P1031 [NOIP2002 提高组] 均分纸牌：通过调整连续序列的元素使序列达到平衡。
3. P1223 排队接水：对连续序列进行排序和计算。

### 个人心得
部分作者提到题目描述较繁琐，难点在于理解题意，需要仔细分析题目中的条件和要求。在解题时，要善于从样例中发现规律，简化问题。同时，要注意代码的优化，避免不必要的操作，提高算法效率。

---
处理用时：33.28秒
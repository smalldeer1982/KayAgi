# 题目信息

# Reverse Sort

## 题目描述

题目共给出 $t(1 \le t \le 1000)$ 组数据，每组数据包含一个正整数 $n(1 \le n \le 1000)$ 和一个长度为 $n$ 的 $01$ 串 $s$， 现在你需要在 $s$ 中选出一个子序列，将这个子序列中的字符翻转（如字符串 $10100$， 选出子序列 $1100$， 翻转得到 $0011$， 放回原串中得到 $00011$），使得翻转后的字符串字典序最小。

## 样例 #1

### 输入

```
3
7
0011111
5
10100
6
001000```

### 输出

```
0
1
4 1 3 4 5 
1
3 3 5 6```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是围绕将 01 串通过最少操作次数（最多 1 次）变成字典序最小的形式，即所有 0 排在 1 前面。

#### 思路对比
- **统计法**：多数题解采用统计 0 和 1 的数量，然后找出前半段的 1 和后半段的 0 进行交换，如 Jerrlee、wzy2021 等的题解。
- **双指针法**：ImmortalWatcher 的题解使用双指针，每次找到一个前面的 1 和后面的 0 加入答案。
- **构造目标字符串法**：GoodLuckCat 的题解先构造目标字符串，再找出与原字符串不同的位置。

#### 算法要点
- 统计 0 和 1 的数量，确定最终字符串的形式。
- 判断原字符串是否已经是字典序最小，若是则操作次数为 0。
- 若不是，则找出需要交换的 0 和 1 的位置，进行一次翻转操作。

#### 解决难点
- 确定需要交换的 0 和 1 的位置，保证交换后字符串字典序最小。
- 处理边界情况，如原字符串已经是字典序最小的情况。

#### 评分
- **Jerrlee**：4 星。思路清晰，代码简洁，通过统计 0 和 1 的数量，直接找出需要交换的位置，可读性较高。
- **wzy2021**：3 星。思路正确，代码逻辑清晰，但使用了多个数组来记录位置，略显复杂。
- **ImmortalWatcher**：3 星。使用双指针法，思路独特，但代码中使用了较多的循环和判断，复杂度较高。

#### 最优关键思路或技巧
- 统计 0 和 1 的数量，确定最终字符串的形式，然后找出需要交换的 0 和 1 的位置，进行一次翻转操作。
- 可以使用双指针法，从两端向中间遍历，找到需要交换的 0 和 1。

#### 可拓展之处
同类型题或类似算法套路：
- 对于其他类型的字符串排序问题，可以考虑使用类似的思路，先确定最终的排序形式，再找出需要交换的元素。
- 对于数组的排序问题，也可以使用类似的方法，如将数组中的奇数和偶数分开，使奇数在前，偶数在后。

#### 推荐洛谷题目
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)
- [P1177 快速排序](https://www.luogu.com.cn/problem/P1177)

#### 个人心得
- GoodLuckCat：“就因为输入时字符串下标从 0 开始，而样例从 1 开始计算，被坑了好久。” 总结：在处理字符串下标时，要注意输入和输出的下标规则是否一致。

### 所选题解
- **Jerrlee（4 星）**
  - 关键亮点：思路清晰，代码简洁，通过统计 0 和 1 的数量，直接找出需要交换的位置，可读性较高。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define sf sizeof
#define con continue
int a[1001];
int main(){
    int t;
    cin>>t;
    while(t--){
        int n,c=0,f=1;
        string s;
        cin>>n>>s;
        memset(a,0,sf a);
        for(int i=0;i<n;i++){
            if(s[i]=='1') c++,a[i]=1;
            if(i>0&&s[i]<s[i-1]) f=0;
        }
        if(f){cout<<0<<endl;con;}
        int h=0;
        for(int i=n-c;i<n;i++) if(s[i]=='0') h+=2;
        cout<<1<<endl<<h;
        for(int i=0;i<n;i++){
            if(i<n-c&&s[i]=='1') cout<<" "<<i+1;
            if(i>n-c-1&&s[i]=='0') cout<<" "<<i+1;
        }
        cout<<endl;
    }
}
```
核心实现思想：先统计 1 的数量，判断原字符串是否已经有序，若无序则找出前半段的 1 和后半段的 0 的位置，输出操作次数和位置。

---
处理用时：28.08秒
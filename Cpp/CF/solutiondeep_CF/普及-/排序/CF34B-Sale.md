# 题目信息

# Sale

## 题目描述

Once Bob got to a sale of old TV sets. There were $ n $ TV sets at that sale. TV set with index $ i $ costs $ a_{i} $ bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most $ m $ TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.

## 样例 #1

### 输入

```
5 3
-6 0 35 -2 4
```

### 输出

```
8
```

## 样例 #2

### 输入

```
4 2
7 0 0 -7
```

### 输出

```
7
```

# AI分析结果

### 题目翻译
# 促销

## 题目描述
有一次，鲍勃去参加一场旧电视机的促销活动。促销活动中有 $n$ 台电视机。编号为 $i$ 的电视机售价为 $a_{i}$ 比拉尔（货币单位）。有些电视机的价格是负数 —— 它们的主人如果鲍勃买下他们无用的设备，愿意付钱给鲍勃。鲍勃可以“购买”任何他想要的电视机。虽然鲍勃很强壮，但他最多只能携带 $m$ 台电视机，而且他不想再去第二次促销活动。请帮助鲍勃找出他最多能赚多少钱。

## 样例 #1
### 输入
```
5 3
-6 0 35 -2 4
```
### 输出
```
8
```

## 样例 #2
### 输入
```
4 2
7 0 0 -7
```
### 输出
```
7
```

### 综合分析与结论
这些题解的核心思路都是贪心算法，因为要赚最多的钱，就需要尽可能买价格为负数的电视，且优先选择价格更低的（负数绝对值更大）。
- **思路**：先将所有电视价格读入，对价格进行排序，然后从价格最低的开始检查，在不超过 $m$ 台的前提下，累加价格为负数的电视的绝对值。
- **算法要点**：排序是关键步骤，通过排序可以方便地找到价格最低的电视。不同题解采用了不同的排序方式，如 `sort` 函数和二叉堆。
- **解决难点**：需要注意购买数量不能超过 $m$ 台，并且当遇到价格为非负数时，应停止购买。

### 题解评分与选择
- **empty（4星）**：思路清晰，通过将价格取相反数，使排序后直接累加正数即可得到结果，代码实现简洁。
- **xuezhe（4星）**：思路阐述详细，用 Python 代码实现，逻辑清晰，易于理解。
- **fls233666（4星）**：采用二叉堆实现，虽然代码稍复杂，但提供了不同的实现思路，对于理解数据结构的应用有帮助。

### 所选题解
- **empty（4星）**
  - **关键亮点**：将价格取相反数，简化后续累加操作。
  - **核心代码**：
```cpp
for(int i=1;i<=n;i++) 
{
  int x;
  cin>>x;
  a[i]=0-x; //转化成相反数
}
sort(a+1,a+n+1);
for(int i=n;i>=n-m+1;i--)
{
  if(a[i]>0) money+=a[i];
  else break;
}
```
- **xuezhe（4星）**
  - **关键亮点**：思路阐述详细，Python 代码简洁易懂。
  - **核心代码**：
```python
n,m=[int(i) for i in input().split()]
a=[int(i) for i in input().split()]
a.sort()
i=0
s=0
while i<m and a[i]<0:
    s-=a[i]
    i+=1
print(s)
```
- **fls233666（4星）**
  - **关键亮点**：采用二叉堆实现，提供了不同的实现思路。
  - **核心代码**：
```cpp
priority_queue< int, vector<int>, greater<int> >q;
//建小根堆
int main()
{
    int n,m,ans=0,a;
    cin>>m>>n;  //读入m与n
    for(int i=0;i<m;i++){
        cin>>a;  //读入每个价格a
        if(a<0)
            q.push(a);  //筛出负数入堆
    }
    //数据读入&预处理
                
    while(!q.empty()){  //在堆不空情况下一直循环
        if(n==0) break;  //数量超过n，跳出循环
        ans-=q.top();    //统计堆顶（注意这里是减，因为要转成正的）
        n--;  //计数
        q.pop();  //删掉堆顶
    }
    cout<<ans;
    //计算&输出
              
    return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：优先选择价格为负数且绝对值大的电视，以获得最大收益。
- **排序**：通过排序可以方便地找到价格最低的电视。
- **数据结构应用**：如二叉堆可以动态维护最小元素，适用于需要频繁查找最小值的场景。

### 可拓展之处
同类型题可能会有更多限制条件，如不同类型的电视有不同的携带重量限制，需要在满足重量限制的前提下选择收益最大的组合。类似算法套路可以应用于资源分配、任务调度等问题，核心思想都是在满足一定条件下，通过贪心策略选择最优解。

### 推荐洛谷题目
1. P1090 [NOIP2004 提高组] 合并果子
2. P1223 排队接水
3. P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录与总结
- **☆芝麻大饼☆**：提到题目坑多，自己跌了好几次，提醒要注意是赚的钱，要用零减价格，到 0 就停止购买。
- **Playnext**：提到被“最多买 $m$ 台，当选到正权值要及时跳出”这个坑了好几次，提醒做题时要注意题目条件。 

---
处理用时：33.80秒
# 题目信息

# Product of Binary Decimals

## 题目描述

### 二进制小数的乘积
我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，你被要求判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

## 说明/提示

前五个测试用例可以表示为二进制小数的乘积如下：

$121 = 11 \times 11$
$1 = 1$ 已经是一个二进制小数。
$14641 = 11 \times 11 \times 11 \times 11$
$12221 = 11 \times 11 \times 101$
$10110 = 10110$ 已经是一个二进制小数。

## 样例 #1

### 输入

```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001```

### 输出

```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES```

# AI分析结果

### 题目内容重写

#### 二进制小数的乘积

**题目描述**

我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，你被要求判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

**说明/提示**

前五个测试用例可以表示为二进制小数的乘积如下：

$121 = 11 \times 11$  
$1 = 1$ 已经是一个二进制小数。  
$14641 = 11 \times 11 \times 11 \times 11$  
$12221 = 11 \times 11 \times 101$  
$10110 = 10110$ 已经是一个二进制小数。

**样例 #1**

**输入**

```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001
```

**输出**

```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES
```

### 题解分析与结论

#### 题解对比与评分

1. **Pink_Cut_Tree (5星)**
   - **关键亮点**：使用深度优先搜索（DFS）来尝试将 $n$ 分解为二进制小数的乘积。通过预先生成所有可能的二进制小数，然后在DFS中尝试将其作为因子进行分解。
   - **代码实现**：通过递归DFS实现，代码简洁且易于理解。
   - **优化**：预先生成二进制小数列表，减少了重复计算。

2. **minVan (4星)**
   - **关键亮点**：预处理所有可能的 $n$，通过检查 $n$ 是否可以被分解为两个满足条件的数的乘积来判断。
   - **代码实现**：使用动态规划的思想，预处理所有可能的 $n$，查询时复杂度为 $O(1)$。
   - **优化**：预处理过程虽然增加了空间复杂度，但显著降低了查询时间复杂度。

3. **thh_loser (3星)**
   - **关键亮点**：暴力枚举所有可能的二进制小数因子，通过递归尝试分解 $n$。
   - **代码实现**：直接枚举所有可能的因子，代码简单但效率较低。
   - **优化**：没有明显的优化，适合小规模数据。

#### 最优关键思路

- **预处理与DFS结合**：通过预先生成所有可能的二进制小数，然后使用DFS尝试分解 $n$，这种方法在时间和空间复杂度上都较为平衡。
- **动态规划预处理**：通过预处理所有可能的 $n$，使得查询时复杂度降低到 $O(1)$，适合大规模数据查询。

#### 可拓展之处

- **类似问题**：可以扩展到其他类型的数的分解问题，如分解为特定形式的数的乘积。
- **优化思路**：可以考虑使用记忆化搜索或动态规划来进一步优化分解过程。

### 推荐题目

1. **洛谷 P1029 最大公约数和最小公倍数问题** - 考察数的分解与组合。
2. **洛谷 P1075 质因数分解** - 考察数的质因数分解。
3. **洛谷 P1217 [USACO1.5]回文质数 Prime Palindromes** - 考察回文数与质数的结合。

### 个人心得摘录

- **Pink_Cut_Tree**：通过预先生成二进制小数列表，减少了重复计算，提高了代码效率。
- **minVan**：预处理虽然增加了空间复杂度，但显著降低了查询时间复杂度，适合大规模数据查询。

### 核心代码片段

**Pink_Cut_Tree 的 DFS 实现**

```cpp
void dfs(int x){
	if(x==1||ans==1){ //是“01 数”或已经有“01 数”了
		ans=1; return;
	}
	for(int i=0;i<30;i++){
		if(x%b[i]==0){
			dfs(x/b[i]);
		}
	}
}
```

**minVan 的预处理实现**

```cpp
for(int i = 1; i < N; i++) {
	if(check(i)) { vis[i] = 1; continue; }
	for(int j = 1; j * j <= i; j++) {
		if(i % j == 0) {
			if(vis[j] && vis[i / j]) {
				vis[i] = 1;
				break;
			}
		}
	}
}
```

---
处理用时：28.77秒
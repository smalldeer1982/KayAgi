# 题目信息

# Jumping on Walls

## 题目描述

瓦西亚在和忍者玩电脑游戏。在这个关卡，瓦西亚需要操控忍者走出一个很深的峡谷。

峡谷由两面垂直于地面且互相平行的墙组成，它们的高度为$n$米。我们将这些墙分成许多$1$米长的区域，并从下到上用$1$到$n$的正整数对它们进行编号。有些地方是安全的，忍者可以爬上去。有些地方石头很尖锐，忍者不能待在那里。我们称这些地区为危险地区。

最初忍者在左墙的最下方。他每秒可以执行以下操作之一：

* 向上爬一个区域；
* 向下爬一个区域；
* 跳到对面的墙上。忍者会跳到比他当前所在高度高$k$米的地方。更准确地说，如果在跳跃之前忍者位于一面墙的区域$x$，那么在跳跃之后，他位于另一面墙的区域$x + k$。

如果在某个时间点忍者到达了一个高度大于$n$的区域，那么忍者就可以从峡谷中出来了。

但峡谷被水淹没了，每秒水位会上升一米。最初，水位达到区域$1$的下边界。忍者不能待在被水淹没的地方。忍者和水轮流移动——首先忍者行动，然后水上升一米，然后忍者再行动，以此类推。

如果忍者可以离开峡谷，那这个关卡就完成了。

在几次失败的尝试之后，瓦西亚开始怀疑是否有可能完成这一关卡。请回答他的问题。

## 说明/提示

在第一个样例中，忍者可以先跳到右边的墙，然后沿着右边的墙往下走一米，然后跳到左边的墙。再跳跃一次忍者就可以离开峡谷。

在第二个样例中，忍者是无法离开峡谷的。

## 样例 #1

### 输入

```
7 3
---X--X
-X--XX-
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
6 2
--X-X-
X--XX-
```

### 输出

```
NO
```

# AI分析结果

### 题目内容重写
# 跳跃墙壁

## 题目描述

瓦西亚在和忍者玩电脑游戏。在这个关卡，瓦西亚需要操控忍者走出一个很深的峡谷。

峡谷由两面垂直于地面且互相平行的墙组成，它们的高度为$n$米。我们将这些墙分成许多$1$米长的区域，并从下到上用$1$到$n$的正整数对它们进行编号。有些地方是安全的，忍者可以爬上去。有些地方石头很尖锐，忍者不能待在那里。我们称这些地区为危险地区。

最初忍者在左墙的最下方。他每秒可以执行以下操作之一：

* 向上爬一个区域；
* 向下爬一个区域；
* 跳到对面的墙上。忍者会跳到比他当前所在高度高$k$米的地方。更准确地说，如果在跳跃之前忍者位于一面墙的区域$x$，那么在跳跃之后，他位于另一面墙的区域$x + k$。

如果在某个时间点忍者到达了一个高度大于$n$的区域，那么忍者就可以从峡谷中出来了。

但峡谷被水淹没了，每秒水位会上升一米。最初，水位达到区域$1$的下边界。忍者不能待在被水淹没的地方。忍者和水轮流移动——首先忍者行动，然后水上升一米，然后忍者再行动，以此类推。

如果忍者可以离开峡谷，那这个关卡就完成了。

在几次失败的尝试之后，瓦西亚开始怀疑是否有可能完成这一关卡。请回答他的问题。

## 说明/提示

在第一个样例中，忍者可以先跳到右边的墙，然后沿着右边的墙往下走一米，然后跳到左边的墙。再跳跃一次忍者就可以离开峡谷。

在第二个样例中，忍者是无法离开峡谷的。

## 样例 #1

### 输入

```
7 3
---X--X
-X--XX-
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
6 2
--X-X-
X--XX-
```

### 输出

```
NO
```

### 题解分析与结论

这道题目的核心是通过搜索算法（DFS或BFS）来模拟忍者的移动，并判断是否能够逃出峡谷。难点在于如何有效地剪枝以避免重复搜索，并处理水位上升对忍者位置的影响。

### 所选高分题解

#### 题解1：乐乐乐还在乐 (5星)
- **关键亮点**：使用了DFS算法，并通过记录访问状态进行剪枝，避免了重复搜索。代码清晰，逻辑严谨。
- **个人心得**：作者在最初提交时没有剪枝，导致TLE，后来通过记录访问状态成功优化。
- **核心代码**：
```cpp
bool dfs(int water,int where,int height){
	if(height>n)return true;//忍者逃出来啦！！！ 
	if(rmb[where][height]==1)return false;//来过这个地方啦，剪！！！ 
	if(a[where][height]==0)return false;//忍者跳到危险地区，剪！！！
	if(water>height)return false;//忍者淹死啦，剪！！！
	
	rmb[where][height]=1;//标记这个地方来过了 
	return dfs(water+1,where^1,height+k)||//跳跃
	dfs(water+1,where,height+1)||//往上走
	dfs(water+1,where,height-1);//往下走
}
```

#### 题解2：Alex_Wei (4星)
- **关键亮点**：使用了BFS算法，通过队列实现广度优先搜索，代码简洁，适合初学者练习BFS。
- **核心代码**：
```cpp
while(!q.empty()){
	pos t=q.front(),nw;q.pop();
	nw=t;nw.h--;nw.t++;//往下爬一格
	if(nw.h>0&&!pd[nw.h][nw.id]&&nw.h>nw.t)//判断是否合法（高度，是否已经走过，还有水位） 
		pd[nw.h][nw.id]=1,q.push(nw);//合法就标记走过，压进队列
	nw=t;nw.h++;nw.t++;//往上爬一格
	if(nw.h>n)cout<<"YES",exit(0);//是否已经完成关卡
	if(!pd[nw.h][nw.id]&&nw.h>nw.t)//判断是否合法
		pd[nw.h][nw.id]=1,q.push(nw); 
	nw=t;nw.h+=k;nw.id=!nw.id;nw.t++;//往对面的墙上跳
	if(nw.h>n)cout<<"YES",exit(0);//同上
	if(!pd[nw.h][nw.id]&&nw.h>nw.t)//判断是否合法
		pd[nw.h][nw.id]=1,q.push(nw);
}
```

#### 题解3：Federico2903 (4星)
- **关键亮点**：同样使用BFS算法，代码结构清晰，注释详细，适合理解BFS的实现细节。
- **核心代码**：
```cpp
void bfs(pos start){
	q.push(start);
	wall[1][0]=1;//标记左下角走过了
	while(!q.empty()){
		pos t=q.front();
		q.pop();
		if(t.h-1>0&&!wall[t.h-1][t.way]&&t.h-1>t.t+1){//向下走
			wall[t.h-1][t.way]=1;//打标记
			q.push(pos(t.h-1,t.t+1,t.way));//扩展
		}
		if(t.h+1>n){//向上走可以直接走出
			cout << "YES";
			return;//离开了峡谷
		}
		if(!wall[t.h+1][t.way]&&t.h+1>t.t+1){//向上走无法直接走出
			wall[t.h+1][t.way]=1;
			q.push(pos(t.h+1,t.t+1,t.way));//扩展
		}
		if(t.h+k>n){//向另一边跳直接离开峡谷
			cout << "YES";//离开了峡谷
			return;
		}
		if(!wall[t.h+k][!t.way]&&t.h+k>t.t+1){//扩展异侧跳
			wall[t.h+k][!t.way]=1;
			q.push(pos(t.h+k,t.t+1,!t.way));
		}
	}
	cout<<"NO";//所有可能性都无法逃出峡谷，输出NO
	return;
}
```

### 最优关键思路与技巧
1. **剪枝优化**：通过记录访问状态避免重复搜索，显著提高算法效率。
2. **水位处理**：在每次移动后增加水位，确保忍者的位置始终高于水位。
3. **搜索顺序**：BFS和DFS都可以使用，但BFS更适合寻找最短路径，DFS则更适合深度优先的探索。

### 拓展与举一反三
- **类似题目**：可以尝试解决其他涉及状态转移和剪枝的搜索问题，如迷宫问题、八数码问题等。
- **推荐题目**：
  1. [P1131 八数码](https://www.luogu.com.cn/problem/P1131)
  2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
  3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：51.19秒
# 题目信息

# DZY Loves Chessboard

## 题目描述

一个棋盘上有一些格子是坏的，另一些是正常的。对于每一个正常的格子，都要在上面放上棋子。
请找到一组解使没有两个相同颜色的棋子相邻(两个格子相邻为它们存在共同的边)

## 样例 #1

### 输入

```
1 1
.
```

### 输出

```
B
```

## 样例 #2

### 输入

```
2 2
..
..
```

### 输出

```
BW
WB
```

## 样例 #3

### 输入

```
3 3
.-.
---
--.```

### 输出

```
B-B
---
--B```

# AI分析结果

### 题目内容重写
#### DZY Loves Chessboard

##### 题目描述
一个棋盘上有一些格子是坏的，另一些是正常的。对于每一个正常的格子，都要在上面放上棋子。请找到一组解，使得没有两个相同颜色的棋子相邻（两个格子相邻指的是它们存在共同的边）。

##### 样例 #1
###### 输入
```
1 1
.
```
###### 输出
```
B
```

##### 样例 #2
###### 输入
```
2 2
..
..
```
###### 输出
```
BW
WB
```

##### 样例 #3
###### 输入
```
3 3
.-.
---
--.
```
###### 输出
```
B-B
---
--B
```

### 题解综合分析与结论
本题的核心在于如何在棋盘上放置棋子，使得相邻的棋子颜色不同。题解中主要有以下几种思路：
1. **模拟法**：通过棋盘的行列奇偶性来决定每个格子的颜色，坏格子直接输出“-”。
2. **DFS/BFS**：使用深度优先搜索或广度优先搜索来遍历棋盘，确保相邻格子颜色不同。
3. **打表法**：预先构造一个完整的棋盘，然后根据输入替换坏格子。

#### 最优关键思路
最简洁且高效的方法是**模拟法**，利用棋盘的行列奇偶性来决定每个格子的颜色。这种方法时间复杂度低，代码实现简单，适用于本题的数据范围。

### 评分较高的题解
#### 题解1：作者：zhaotiensn (赞：11)
- **星级**：★★★★★
- **关键亮点**：利用棋盘的行列奇偶性决定颜色，代码简洁高效。
- **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    a=getchar(); // 读入换行符
    for(int j=1;j<=m;j++){
        a=getchar(); // 读入a[i][j]的状态
        if(a=='-') putchar('-');
        else putchar((i+j)&1 ? 'W' : 'B');
    }
    puts("");
}
```
- **个人心得**：通过国际象棋棋盘的启发，直接利用行列奇偶性决定颜色，避免了复杂的搜索。

#### 题解2：作者：棽木 (赞：0)
- **星级**：★★★★
- **关键亮点**：代码简短，直接处理每一行，利用行列奇偶性决定颜色。
- **核心代码**：
```cpp
for(int i=0; i<n; i++){
    cin>>mp[i]; // 读一行
    for(int j=0; j<m; j++)
        if(mp[i][j]=='.') (i+j)%2==0 ? mp[i][j]='B' : mp[i][j]='W';
    cout<<mp[i]<<endl; // 输出改好的这一行
}
```
- **个人心得**：通过逐行处理，简化了代码逻辑，适合本题的数据范围。

#### 题解3：作者：Purslane (赞：0)
- **星级**：★★★★
- **关键亮点**：直接模拟国际象棋棋盘，代码简洁。
- **核心代码**：
```cpp
for(int i=0;i<n;i++) {
    string k; cin>>k;
    for(int j=0;j<m;j++) {
        if(k[j]=='-') a[i][j]='-';
        else a[i][j] = (i+j)&1 ? 'B' : 'W';
    }
}
```
- **个人心得**：通过模拟国际象棋棋盘，避免了复杂的搜索算法，代码实现简单。

### 推荐题目
1. **P1219 [USACO1.5]八皇后 Checker Challenge**（考察DFS和回溯）
2. **P1443 马的遍历**（考察BFS和棋盘遍历）
3. **P1162 填涂颜色**（考察DFS/BFS和矩阵填充）

### 总结
本题的最优解法是利用棋盘的行列奇偶性来决定每个格子的颜色，这种方法代码简洁且高效。对于类似的棋盘填充问题，模拟法通常是最佳选择，尤其是在数据范围较小的情况下。

---
处理用时：30.27秒
# 题目信息

# Make it Divisible by 25

## 题目描述

给定一个**正整数** $n$，你可以对它进行操作。

对于每一次操作，你可以将这个正整数其中的**任意**一个数位删去，之后这个数剩下的左右两边会相接。

特别地：

- 如果一个数仅剩下一个数位，则不能再对它进行操作；
- 如果一个操作之后的数包含前导零，则这些前导零会被一并删除。

例如：

- 将 $32925$ 的第 $3$ 位删除后，它会变成 $3225$；
- 将 $20099050$ 的第 $1$ 位删除后，它会变成 $99050$（两个前导零被一并删除了）。

请你求出，最少经过多少次操作之后，可以得到一个能被 $25$ 整除的**正整数**。

## 说明/提示

- $1 \le t \le 10^4$；
- $25 \le n \le 10^{18}$。

Translated by @BurningEnderDragon, 2021.10.14

## 样例 #1

### 输入

```
5
100
71345
3259
50555
2050047```

### 输出

```
0
3
1
3
2```

# AI分析结果

### 题目内容重写
# 使数能被25整除

## 题目描述

给定一个**正整数** $n$，你可以对它进行操作。

对于每一次操作，你可以将这个正整数其中的**任意**一个数位删去，之后这个数剩下的左右两边会相接。

特别地：

- 如果一个数仅剩下一个数位，则不能再对它进行操作；
- 如果一个操作之后的数包含前导零，则这些前导零会被一并删除。

例如：

- 将 $32925$ 的第 $3$ 位删除后，它会变成 $3225$；
- 将 $20099050$ 的第 $1$ 位删除后，它会变成 $99050$（两个前导零被一并删除了）。

请你求出，最少经过多少次操作之后，可以得到一个能被 $25$ 整除的**正整数**。

## 说明/提示

- $1 \le t \le 10^4$；
- $25 \le n \le 10^{18}$。

Translated by @BurningEnderDragon, 2021.10.14

## 样例 #1

### 输入

```
5
100
71345
3259
50555
2050047```

### 输出

```
0
3
1
3
2```

### 综合分析与结论

本题的核心思路是：一个数能被25整除，当且仅当它的最后两位数是 `00`、`25`、`50` 或 `75`。因此，问题转化为如何通过最少的删除操作，使得给定的数的最后两位是上述四种情况之一。

各题解的主要思路都是通过遍历字符串，寻找满足条件的最后两位，并计算需要删除的位数。不同题解在实现细节上有所不同，有的通过从后向前遍历，有的通过分情况讨论。

### 评分较高的题解

#### 题解1：Coros_Trusds (4星)
**关键亮点**：
- 使用字符串存储数字，方便处理。
- 通过从后向前遍历，寻找满足条件的最后两位。
- 代码结构清晰，逻辑简单。

**核心代码**：
```cpp
inline void solve(string str)
{
    int ans = str.size(), len = str.size();
    
    for (register int i = 0; i <= 3; i++) {
        int idx = 1;
        
        for (register int j = len - 1; j >= 0; j--) {
            if (tmp[i][idx] == str[j]) {
                idx--;
            }
            
            if (idx == -1) {
                ans = min(ans, len - j - 2);
                break;
            }
        }
    }
    
    cout << ans << '\n';
}
```

#### 题解2：ttq012 (4星)
**关键亮点**：
- 分情况讨论，分别处理以 `5` 和 `0` 结尾的情况。
- 通过从后向前遍历，减少不必要的计算。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for (int i = n - 1; i >= 0; i--) {
    if (s[i] != '5') ans1++;
    else {
        for (int j = i - 1; j >= 0; j--) {
            if (s[j] == '2' || s[j] == '7') break;
            else ans1++;
        }
        break;
    }
}
```

#### 题解3：wheneveright (4星)
**关键亮点**：
- 使用两个函数分别处理以 `5` 和 `0` 结尾的情况。
- 通过递归和模运算，简化了代码实现。
- 代码逻辑清晰，易于理解。

**核心代码**：
```cpp
int solve1() {
    m = n; x = y = -1;
    for (int i = 0; m; i++, m /= 10)
        if (m % 10 == 5) { x = i, m /= 10; break; }
    for (int i = 0; m; i++, m /= 10)
        if (m % 10 == 7 || m % 10 == 2) { y = i; break; }
    if (x != -1 && y != -1) return x + y;
    else return 114514;
}
```

### 最优关键思路与技巧
1. **从后向前遍历**：由于我们只关心最后两位，从后向前遍历可以更快地找到满足条件的数字。
2. **分情况讨论**：将问题分为以 `5` 和 `0` 结尾的两种情况，分别处理，简化了逻辑。
3. **字符串处理**：将数字转换为字符串，方便进行字符匹配和删除操作。

### 可拓展之处
- 类似的问题可以扩展到其他整除条件，如 `4`、`8` 等，只需要关注最后几位数字即可。
- 可以通过动态规划等方法进一步优化删除操作的次数。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

### 个人心得摘录
- **Coros_Trusds**：通过字符串处理，简化了数字的删除操作，代码更加清晰。
- **ttq012**：分情况讨论，减少了不必要的计算，提高了代码效率。
- **wheneveright**：使用递归和模运算，简化了代码实现，逻辑更加清晰。

---
处理用时：44.87秒
# 题目信息

# Traveling Salesman Problem

## 题目描述

你正位于一个无限的笛卡尔坐标系的点 $ (x , y) $上，你可以进行四种操作：

- 向左移动至 $ (x - 1, y) $ 
- 向右移动至 $ (x + 1, y) $ 
- 向上移动至 $ (x, y + 1) $ 
- 向下移动至 $ (x, y - 1) $ 

有 $ n $ 个宝箱在这个平面上。 第 $ i $ 个 宝箱的坐标为 $ (x_i,y_i) $ . 保证每个宝箱都在 $ x $ 轴 或 $ y $ 轴上。即 $ x_i=0 $ 或 $ y_i=0 $。

你现在点 $ (0,0) $ 上，想将所有宝箱全部收入囊中，并回到原点。
你想知道你需要的最小移动次数是多少。
本题使用多组测试数据。

## 样例 #1

### 输入

```
3
4
0 -2
1 0
-1 0
0 2
3
0 2
-3 0
0 -1
1
0 0```

### 输出

```
12
12
0```

# AI分析结果

### 题目内容重写

**旅行商问题**

#### 题目描述

你正位于一个无限的笛卡尔坐标系的点 $ (x , y) $ 上，你可以进行四种操作：

- 向左移动至 $ (x - 1, y) $ 
- 向右移动至 $ (x + 1, y) $ 
- 向上移动至 $ (x, y + 1) $ 
- 向下移动至 $ (x, y - 1) $ 

有 $ n $ 个宝箱在这个平面上。第 $ i $ 个宝箱的坐标为 $ (x_i,y_i) $。保证每个宝箱都在 $ x $ 轴或 $ y $ 轴上，即 $ x_i=0 $ 或 $ y_i=0 $。

你现在位于点 $ (0,0) $ 上，想将所有宝箱全部收入囊中，并回到原点。你想知道你需要的最小移动次数是多少。本题使用多组测试数据。

#### 样例 #1

##### 输入

```
3
4
0 -2
1 0
-1 0
0 2
3
0 2
-3 0
0 -1
1
0 0
```

##### 输出

```
12
12
0
```

---

### 题解综合分析与结论

本题的核心是求在坐标轴上遍历所有宝箱并回到原点的最小移动次数。所有宝箱都在坐标轴上，因此可以通过分别计算每个半轴上最远宝箱的距离，并计算总路径长度。

#### 关键思路：
1. **半轴最远点计算**：分别计算 $x$ 轴正半轴、$x$ 轴负半轴、$y$ 轴正半轴、$y$ 轴负半轴上最远的宝箱坐标。
2. **路径长度计算**：最小移动次数为这些最远点距离之和的两倍。

#### 最优技巧：
- **路径优化**：由于所有宝箱都在坐标轴上，路径可以简化为在坐标轴上来回移动，避免不必要的路径交叉。
- **时间复杂度优化**：通过一次遍历即可计算出每个半轴的最远点，时间复杂度为 $O(n)$。

#### 可拓展之处：
- **类似问题**：如果宝箱不在坐标轴上，问题将变为经典的旅行商问题（TSP），需要使用更复杂的算法（如动态规划）来求解。
- **路径规划**：类似的问题可以应用于机器人路径规划、物流配送等场景。

---

### 评分较高的题解

#### 1. 作者：Failure_Terminator (赞：3)
**评分：4.5星**
**关键亮点**：
- 思路清晰，通过图形化分析得出路径长度的计算公式。
- 代码简洁，直接通过一次遍历计算最远点，时间复杂度为 $O(n)$。
- 提供了公式推导，便于理解。

**核心代码**：
```cpp
void solve(){
	int n=read();
	int minx,miny,maxx,maxy;
	minx=maxx=miny=maxy=0;
	for(int i=1;i<=n;i++){
		int x=read(),y=read();
		minx=min(minx,x);
		miny=min(miny,y);
		maxx=max(maxx,x);
		maxy=max(maxy,y);
	}
	printf("%d\n",2*(maxx+maxy-minx-miny));
}
```

#### 2. 作者：C_Cong (赞：1)
**评分：4星**
**关键亮点**：
- 通过坐标轴上的最远点计算路径长度，思路明确。
- 代码实现简洁，直接计算每个半轴的最远点。

**核心代码**：
```cpp
void work(){
	int n,x,y,maxx=0,minx=0,maxy=0,miny=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);
		if(x<minx) minx=x;
		if(x>maxx) maxx=x;
		if(y<miny) miny=y;
		if(y>maxy) maxy=y;
	}
	printf("%d\n",2*(maxx+maxy-minx-miny));
}
```

#### 3. 作者：HarunluoON (赞：0)
**评分：4星**
**关键亮点**：
- 通过详细的分析和路径描述，清晰地解释了路径长度的计算方式。
- 代码简洁，直接计算每个半轴的最远点。

**核心代码**：
```cpp
void work(){
	int n,x,y,maxx=0,minx=0,maxy=0,miny=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);
		if(x<minx) minx=x;
		if(x>maxx) maxx=x;
		if(y<miny) miny=y;
		if(y>maxy) maxy=y;
	}
	printf("%d\n",2*(maxx+maxy-minx-miny));
}
```

---

### 推荐题目
1. **P1002 [NOIP2002 普及组] 过河卒** - 考察路径规划与动态规划。
2. **P1219 [USACO1.5] 八皇后 Checker Challenge** - 考察回溯与路径优化。
3. **P1044 [NOIP2003 普及组] 栈** - 考察路径与栈的应用。

---
处理用时：45.77秒
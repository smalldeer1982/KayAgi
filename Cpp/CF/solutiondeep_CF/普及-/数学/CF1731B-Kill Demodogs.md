# 题目信息

# Kill Demodogs

## 题目描述

给定一个数$n$,表示有一个 $n \times n$ 的方格。每个格子里都有一个数，第 $i$ 行第 $j$ 列的格子值为 $i⋅j$。现在Hawkins要从 $(1,1)$ 走到 $(n,n)$,每次只能从 $(i,j)$ 走到 $(i,j+1)$ 或 $(i+1,j)$, 每走到一个格子就能获得格子中的一个数，最大化数字之和。

## 样例 #1

### 输入

```
4
2
3
50
1000000000```

### 输出

```
14154
44484
171010650
999589541```

# AI分析结果

### 题目内容重写
给定一个数$n$，表示有一个$n \times n$的方格。每个格子里都有一个数，第$i$行第$j$列的格子值为$i \cdot j$。现在Hawkins要从$(1,1)$走到$(n,n)$，每次只能从$(i,j)$走到$(i,j+1)$或$(i+1,j)$，每走到一个格子就能获得格子中的一个数，最大化数字之和。

### 样例 #1
#### 输入
```
4
2
3
50
1000000000
```
#### 输出
```
14154
44484
171010650
999589541
```

### 题解综合分析与结论
本题的核心是找到从$(1,1)$到$(n,n)$的路径，使得路径上所有格子的值之和最大。通过分析可以发现，最优路径是沿着对角线方向走，这样可以最大化每个格子的值。最终，问题转化为求一个数列的和，可以通过数学公式直接计算。

### 所选高星题解
#### 1. 作者：cjh20090318 (赞：3)  
**星级：5星**  
**关键亮点：**  
- 使用OEIS找到数列的通项公式，直接计算答案，时间复杂度为$O(1)$。
- 使用`__int128`避免溢出问题，代码简洁高效。
- 提供了注意事项，确保代码的正确性。

**核心代码：**
```cpp
void solve(){
	int n;scanf("%d",&n);
	printf("%lld\n",(long long)((__int128)((__int128)n*(n+1)*(4ll*n-1)/6)%mod*2022%mod));
}
```

#### 2. 作者：Engulf (赞：1)  
**星级：4星**  
**关键亮点：**  
- 通过数学推导得出数列的和公式，思路清晰。
- 使用OEIS验证公式的正确性，确保答案的准确性。

**核心代码：**
```cpp
void solve(){
	int n;scanf("%d",&n);
	printf("%lld\n",(long long)((__int128)((__int128)n*(n+1)*(4ll*n-1)/6)%mod*2022%mod));
}
```

#### 3. 作者：loser_seele (赞：0)  
**星级：4星**  
**关键亮点：**  
- 通过数学证明最优路径的正确性，思路严谨。
- 使用乘法逆元处理大数取模问题，代码实现巧妙。

**核心代码：**
```cpp
void solve(){
	int n;scanf("%d",&n);
	int ans=n*(n + 1)%mod*(4*n - 1)%mod*ksm(6,mod-2,mod)%mod;
	cout<<ans*2022%mod<<'\n';
}
```

### 最优关键思路或技巧
1. **数学公式推导**：通过数学推导找到数列的和公式，直接计算答案，避免复杂的路径搜索。
2. **OEIS的使用**：利用OEIS验证数列公式的正确性，确保答案的准确性。
3. **大数处理**：使用`__int128`或乘法逆元处理大数计算，避免溢出问题。

### 可拓展之处
本题的思路可以拓展到其他类似的路径优化问题，例如在网格中寻找最大或最小路径和的问题。类似的算法套路包括动态规划、贪心算法等。

### 推荐洛谷题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：29.36秒
# 题目信息

# Black Circles

## 题目描述

在一个二维平面上有 $n$ 个圆。第 $i$ 个圆的圆心位于 $(x_i, y_i)$。最初，所有圆的半径都是 $0$。

这些圆的半径以每秒 $1$ 单位的速度增长。

你现在的位置是 $(x_s, y_s)$，你的目标是到达 $(x_t, y_t)$，并且在这个运动过程中不能碰到任何一个圆的边缘（包括你到达 $(x_t, y_t)$ 的那一刻）。你可以向任意方向移动。然而，你的速度被限制在每秒 $1$ 单位。

请判断是否有可能实现这一目标。

## 说明/提示

在第一个测试用例中，一种可行的移动方式如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2002C/e91b557a5335aaaa3689cd6df137ea06f9152e48.png)

## 样例 #1

### 输入

```
7
3
2 5
2 14
10 13
4 9 9 7
3
10 11
6 9
12 12
14 13 4 8
1
5 7
12 6 11 13
2
1000000000 2
2 1000000000
1 1 2 2
1
999999998 1000000000
999999999 999999999 1 1
1
1000000000 1
1 1000000000 1 1
10
989237121 2397081
206669655 527238537
522705783 380636165
532545346 320061691
207818728 199485303
884520552 315781807
992311437 802563521
205138355 324818663
223575704 395073023
281560523 236279118
216941610 572010615 323956540 794523071```

### 输出

```
YES
NO
YES
YES
YES
NO
YES```

# AI分析结果

### 题目内容重写
在一个二维平面上有 $n$ 个圆。第 $i$ 个圆的圆心位于 $(x_i, y_i)$。最初，所有圆的半径都是 $0$。这些圆的半径以每秒 $1$ 单位的速度增长。你现在的位置是 $(x_s, y_s)$，你的目标是到达 $(x_t, y_t)$，并且在这个运动过程中不能碰到任何一个圆的边缘（包括你到达 $(x_t, y_t)$ 的那一刻）。你可以向任意方向移动。然而，你的速度被限制在每秒 $1$ 单位。请判断是否有可能实现这一目标。

### 综合分析与结论
本题的核心在于判断从起点到终点的直线路径是否会被任何一个圆阻挡。由于圆的半径随时间增长，且人和圆的扩展速度相同，因此只需要比较起点到终点的距离是否小于所有圆心到终点的距离。如果起点到终点的距离是最小的，那么可以安全到达；否则，无法到达。

### 所选高星题解
#### 题解1：作者：masonxiong (赞：0)  
**星级：4星**  
**关键亮点：**  
- 通过几何证明，明确了两点之间直线最短的结论，并证明了走直线是最优策略。
- 提供了详细的证明过程，解释了为什么走直线是最快且安全的路径。
- 代码简洁，直接比较距离，避免了不必要的计算。

**核心代码：**
```cpp
long long eDistance(const pair<long long, long long>& x, const pair<long long, long long>& y) {
    return (x.first - y.first) * (x.first - y.first) + (x.second - y.second) * (x.second - y.second);
}
```
**代码简述：**  
计算两点之间的平方距离，避免开根号的计算，直接比较距离大小。

#### 题解2：作者：lizhixun (赞：0)  
**星级：4星**  
**关键亮点：**  
- 详细解释了距离公式的应用，并说明了为什么不需要开根号。
- 代码结构清晰，使用了`pair`存储坐标，提高了代码的可读性。
- 提供了优化提示，如关闭同步流等。

**核心代码：**
```cpp
int dis(Pair q, Pair h) { 
    return (q.x - h.x) * (q.x - h.x) + (q.y - h.y) * (q.y - h.y);
}
```
**代码简述：**  
计算两点之间的平方距离，直接比较距离大小，避免不必要的计算。

#### 题解3：作者：RaymondOccam (赞：0)  
**星级：4星**  
**关键亮点：**  
- 通过几何分析，明确了两点之间直线最短的结论，并提供了详细的证明。
- 代码简洁，直接比较距离，避免了不必要的计算。
- 提供了优化提示，如关闭同步流等。

**核心代码：**
```cpp
ll dist(ll xa, ll xb, ll ya, ll yb) {
    return (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);
}
```
**代码简述：**  
计算两点之间的平方距离，直接比较距离大小，避免不必要的计算。

### 最优关键思路或技巧
1. **直线最短路径**：两点之间直线最短，走直线是最优策略。
2. **距离比较**：通过比较起点到终点的距离与所有圆心到终点的距离，判断是否安全。
3. **避免开根号**：直接比较平方距离，避免不必要的计算。

### 可拓展之处
- **类似问题**：可以考虑圆的速度不同，或者人的速度不同的情况。
- **其他几何问题**：如判断点是否在多边形内，或者判断两条线段是否相交。

### 推荐题目
1. [P1357 食物链](https://www.luogu.com.cn/problem/P1357)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

---
处理用时：31.55秒
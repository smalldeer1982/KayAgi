# 题目信息

# Longest Good Array

## 题目描述

Sakurako 今天在研究数组问题。我们说一个数组 $a$ 是“优秀的”，当且仅当：

- 这个数组是严格递增的，也就是对每个 $2 \le i \le n$，都有 $a_{i - 1} < a_i$；
- 相邻元素的差值也是严格递增的，即对于每个 $2 \le i < n$，都有 $a_i - a_{i-1} < a_{i+1} - a_i$。

Sakurako 给定了两个边界值 $l$ 和 $r$，她希望构造一个最长的优秀数组，使得数组中的每个元素 $a_i$ 满足 $l \le a_i \le r$。

请你帮助 Sakurako 找出在给定 $l$ 和 $r$ 条件下，最长优秀数组的长度。

## 说明/提示

例如，当 $l=1$ 和 $r=5$ 时，一个可能的优秀数组是 $(1, 2, 5)$。可以证明，给定这些边界值，不存在长度为 $4$ 的优秀数组。

当 $l=2$ 和 $r=2$ 时，唯一的数组是 $(2)$。

当 $l=10$ 和 $r=20$ 时，一个唯一的优秀数组是 $(10, 11, 13, 16, 20)$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
1 2
1 5
2 2
10 20
1 1000000000```

### 输出

```
2
3
1
5
44721```

# AI分析结果

### 题目内容重写
# 最长优秀数组

## 题目描述

Sakurako 今天在研究数组问题。我们说一个数组 $a$ 是“优秀的”，当且仅当：

- 这个数组是严格递增的，也就是对每个 $2 \le i \le n$，都有 $a_{i - 1} < a_i$；
- 相邻元素的差值也是严格递增的，即对于每个 $2 \le i < n$，都有 $a_i - a_{i-1} < a_{i+1} - a_i$。

Sakurako 给定了两个边界值 $l$ 和 $r$，她希望构造一个最长的优秀数组，使得数组中的每个元素 $a_i$ 满足 $l \le a_i \le r$。

请你帮助 Sakurako 找出在给定 $l$ 和 $r$ 条件下，最长优秀数组的长度。

## 说明/提示

例如，当 $l=1$ 和 $r=5$ 时，一个可能的优秀数组是 $(1, 2, 5)$。可以证明，给定这些边界值，不存在长度为 $4$ 的优秀数组。

当 $l=2$ 和 $r=2$ 时，唯一的数组是 $(2)$。

当 $l=10$ 和 $r=20$ 时，一个唯一的优秀数组是 $(10, 11, 13, 16, 20)$。

### 样例 #1

#### 输入

```
5
1 2
1 5
2 2
10 20
1 1000000000
```

#### 输出

```
2
3
1
5
44721
```

---

### 题解综合分析与结论

本题的核心在于构造一个满足严格递增且相邻差值也严格递增的数组，并且数组中的元素必须在给定的 $l$ 和 $r$ 范围内。为了使得数组尽可能长，我们需要让相邻元素的差值尽可能小，通常采用差值为 $1, 2, 3, \dots$ 的等差数列。

#### 关键思路：
1. **等差数列求和公式**：通过等差数列求和公式 $\frac{n(n-1)}{2}$ 来计算数组的长度。这个公式可以帮助我们快速确定在给定范围内可以构造的最长数组长度。
2. **二分查找**：通过二分查找来优化求解过程，特别是在 $r$ 较大的情况下，二分查找可以显著减少计算时间。
3. **数学推导**：通过数学推导，将问题转化为求解一元二次方程，从而快速得到结果。

#### 难点对比：
- **数学推导 vs 二分查找**：数学推导（如解一元二次方程）通常更高效，但在某些情况下，二分查找更容易实现和理解。
- **边界处理**：在处理边界时，特别是当 $l = r$ 时，需要特别注意数组长度为 1 的情况。

#### 最优关键思路：
- **等差数列求和公式**：通过等差数列求和公式 $\frac{n(n-1)}{2}$ 来计算数组的长度，结合一元二次方程的求解，可以快速得到结果。

---

### 评分较高的题解

#### 1. 作者：chenxi2009 (5星)
**关键亮点**：
- 通过等差数列求和公式和一元二次方程的求解，快速得到结果。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,l,r,x;
int main(){
	scanf("%d",&T);
	while(T --){
		scanf("%d%d",&l,&r);
		r = r - l;
		x = int((1.0 + sqrt(8.0 * r + 1.0)) / 2.0);
		printf("%d\n",x);
	}
	return 0;
}
```

#### 2. 作者：Super_Cube (4星)
**关键亮点**：
- 通过等差数列求和公式和一元二次方程的求解，快速得到结果。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
#include<bits/stdc++.h>
int T,l,r;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&l,&r);
		printf("%d\n",(int)((sqrt(1+8.0*(r-l))-1)/2)+1);
	}
	return 0;
}
```

#### 3. 作者：linjinkun (4星)
**关键亮点**：
- 使用二分查找来优化求解过程，特别是在 $r$ 较大的情况下。
- 代码清晰，逻辑严谨。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
signed main()
{
	int _;
	scanf("%lld",&_);
	while(_--)
	{
		int L,R;
		scanf("%lld %lld",&L,&R);
		int l = 1,r = 50000;
		int ans = 0;
		while(l<=r)
		{
			int mid = l+r>>1;
			if(L+mid*(mid-1)/2<=R)
			{
				ans = mid;
				l = mid+1;
			}
			else
			{
				r = mid-1;
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

### 推荐题目
1. **洛谷 P1020**：导弹拦截（考察等差数列和二分查找）
2. **洛谷 P1045**：数列分段（考察等差数列和贪心算法）
3. **洛谷 P1048**：采药（考察等差数列和动态规划）

---

### 个人心得总结
- **调试经历**：在处理边界时，特别是当 $l = r$ 时，需要特别注意数组长度为 1 的情况。
- **踩坑教训**：在使用二分查找时，注意边界条件的处理，避免死循环或错误结果。
- **顿悟感想**：通过等差数列求和公式和一元二次方程的求解，可以快速得到结果，这在处理类似问题时非常有用。

---
处理用时：50.38秒
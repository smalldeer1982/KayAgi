# 题目信息

# Brightness Begins

## 题目描述

想象你有 $n$ 个编号为 $1, 2, \ldots, n$ 的灯泡。最初，所有灯泡都是开着的。翻转一个灯泡的状态意味着如果它原来是开着的，就把它关掉；否则就把它打开。

接下来，您需要执行以下操作：

对于每个 $i=1,2,\ldots,n$，翻转所有灯泡 $j$ 的状态，使得 $j$ 能被 $i^\dagger$ 整除。

在执行完所有操作后，将会有一些灯泡仍然亮着。你的目标是使这个数量恰好为 $k$。

找到最小的合适 $n$，使得执行操作后，灯泡的数量恰好为 $k$。我们可以证明答案总是存在的。

$ ^\dagger $ 如果存在一个整数 $ z $ 使得 $ x = y\cdot z $ ，那么一个整数 $ x $ 可以被 $ y $ 整除。

## 说明/提示

在第一个测试用例中，最小数量的灯泡是 $2$。让我们用一个数组来表示所有灯泡的状态，其中$1$对应于打开的灯泡，$0$ 对应于关闭的灯泡。最初，数组是 $[1, 1]$。

- 在执行了 $i=1$ 的操作后，数组变成了 $[\underline{0},\underline{0}]$。
- 在执行了 $i=2$ 的操作后，数组变成了 $[0,\underline{1}]$。

最后，有 $k=1$ 个灯泡亮着。我们还可以证明答案不可能小于 $2$。

在第二个测试用例中，最小数量的灯泡是 $5$。最初，数组是 $[1, 1, 1, 1, 1]$。

- 在执行了 $i=1$ 的操作后，数组变成了 $[\underline{0},\underline{0},\underline{0},\underline{0},\underline{0}]$。
- 在执行了 $i=2$ 的操作后，数组变成了 $[0,\underline{1},0,\underline{1},0]$。
- 在执行了 $i=3$ 的操作后，数组变成了 $[0,1,\underline{1},1,0]$。
- 在执行了 $i=4$ 的操作后，数组变成了 $[0,1,1,\underline{0},0]$。
- 在执行了 $i=5$ 的操作后，数组变成了 $[0,1,1,0,\underline{1}]$。

最后，有 $k=3$ 个灯泡亮着。我们还可以证明答案不可能小于 $5$。

翻译者：[jiangyunuo](https://www.luogu.com.cn/user/1061050)。

## 样例 #1

### 输入

```
3
1
3
8```

### 输出

```
2
5
11```

# AI分析结果

### 题目内容重写

#### 题目描述

想象你有 $n$ 个编号为 $1, 2, \ldots, n$ 的灯泡。最初，所有灯泡都是开着的。翻转一个灯泡的状态意味着如果它原来是开着的，就把它关掉；否则就把它打开。

接下来，您需要执行以下操作：

对于每个 $i=1,2,\ldots,n$，翻转所有灯泡 $j$ 的状态，使得 $j$ 能被 $i$ 整除。

在执行完所有操作后，将会有一些灯泡仍然亮着。你的目标是使这个数量恰好为 $k$。

找到最小的合适 $n$，使得执行操作后，灯泡的数量恰好为 $k$。我们可以证明答案总是存在的。

#### 说明/提示

在第一个测试用例中，最小数量的灯泡是 $2$。让我们用一个数组来表示所有灯泡的状态，其中$1$对应于打开的灯泡，$0$ 对应于关闭的灯泡。最初，数组是 $[1, 1]$。

- 在执行了 $i=1$ 的操作后，数组变成了 $[\underline{0},\underline{0}]$。
- 在执行了 $i=2$ 的操作后，数组变成了 $[0,\underline{1}]$。

最后，有 $k=1$ 个灯泡亮着。我们还可以证明答案不可能小于 $2$。

在第二个测试用例中，最小数量的灯泡是 $5$。最初，数组是 $[1, 1, 1, 1, 1]$。

- 在执行了 $i=1$ 的操作后，数组变成了 $[\underline{0},\underline{0},\underline{0},\underline{0},\underline{0}]$。
- 在执行了 $i=2$ 的操作后，数组变成了 $[0,\underline{1},0,\underline{1},0]$。
- 在执行了 $i=3$ 的操作后，数组变成了 $[0,1,\underline{1},1,0]$。
- 在执行了 $i=4$ 的操作后，数组变成了 $[0,1,1,\underline{0},0]$。
- 在执行了 $i=5$ 的操作后，数组变成了 $[0,1,1,0,\underline{1}]$。

最后，有 $k=3$ 个灯泡亮着。我们还可以证明答案不可能小于 $5$。

### 题解分析与结论

#### 综合分析与结论

本题的核心在于理解灯泡的最终状态与其编号的因数个数的奇偶性有关。具体来说，编号为完全平方数的灯泡会被翻转奇数次，最终关闭；而非完全平方数的灯泡会被翻转偶数次，最终保持开启。因此，问题转化为找到第 $k$ 个非完全平方数。

大多数题解都采用了二分查找的方法，结合数学定理“在 $1$ 到 $n$ 中，有 $\lfloor \sqrt{n} \rfloor$ 个完全平方数”，通过计算 $n - \lfloor \sqrt{n} \rfloor$ 来确定非完全平方数的数量，进而找到最小的 $n$ 使得 $n - \lfloor \sqrt{n} \rfloor = k$。

#### 最优关键思路或技巧

1. **数学定理的应用**：利用“在 $1$ 到 $n$ 中，有 $\lfloor \sqrt{n} \rfloor$ 个完全平方数”这一数学定理，将问题转化为求第 $k$ 个非完全平方数。
2. **二分查找**：通过二分查找来快速确定满足条件的最小 $n$，时间复杂度为 $O(\log k)$。
3. **精度处理**：使用高精度函数如 `sqrtl` 或手写二分求平方根，避免浮点数精度问题。

#### 可拓展之处

类似的问题可以通过分析数的因数个数或利用数学定理来简化。例如，求第 $k$ 个质数、第 $k$ 个斐波那契数等，都可以通过二分查找结合数学公式来解决。

#### 推荐题目

1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)
3. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)

### 精选题解

#### 题解1：作者：mc_xiexie (赞：9)

**星级**：★★★★★  
**关键亮点**：简洁高效，直接利用数学公式 $n = k + \sqrt{k}$ 计算答案，时间复杂度 $O(1)$。

**代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        long long x;
        cin>>x;
        cout<<x+(long long)(sqrtl(x)+0.5)<<"\n";
    }
}
```

#### 题解2：作者：NEKO_Daze (赞：6)

**星级**：★★★★☆  
**关键亮点**：详细解释了数学定理的应用，并通过二分查找实现，代码清晰易读。

**代码实现**：
```cpp
#include <iostream>
#include <cmath>
#include <math.h>
#include <iomanip>
using namespace std;
long long find(long long k)
{
    long long l = 1, r = k*2, mid, cnt;
    while (r - l > 1) //两端点重合会超时，只需枚举到两端点相邻即可
    {
        mid = (r + l) >> 1;
        cnt = mid - int(sqrtl(mid)); //非完全平方数的数量
        if (cnt < k) l = mid; //数量不够，n还要更大。
        else r = mid; //已经够了，尝试将n缩小。
    }
    return r;
}
long long t, k;
int main()
{
    cin>>t;
    while (t--)
    {
        cin >> k;
        cout << find(k) << endl;
    }
    return 0;
}
```

#### 题解3：作者：Gongyujie123 (赞：2)

**星级**：★★★★☆  
**关键亮点**：思路清晰，代码简洁，使用了二分查找和数学定理，适合初学者理解。

**代码实现**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int k;
        cin>>k;
        int l=1,r=2*k; //设置左右边界
        while(l+1<r){  //二分答案
            int m=(l+r)/2;
            if(m-(int)(sqrtl(m))>=k){ 
                r=m;
            }else{
                l=m;
            }
        }
        cout<<r<<endl;
    }
    return 0;
}
```

---
处理用时：50.85秒
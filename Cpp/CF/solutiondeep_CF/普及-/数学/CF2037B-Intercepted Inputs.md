# 题目信息

# Intercepted Inputs

## 题目描述

### 题目翻译


为了帮助您准备即将到来的 Codeforces 竞赛，茜特菈莉设置了一个网格问题，并试图通过您的输入流为您提供一个 $n$ 乘 $m$ 的网格。具体来说，您的输入流应包含以下内容：

- 第一行包含 $n$ 和 $m$ 两个整数。- 网格的尺寸。
- 接下来的 $n$ 行分别包含 $m$ 个整数--网格值。

然而，有人截获了你的输入流，将所有给定的整数洗牌后放在一行！现在，一行中有 $k$ 个整数，而你却不知道每个整数原本属于哪一行。你决定自己确定 $n$ 和 $m$ 的值，而不是让茜特菈莉 重新发送输入。

输出茜特菈莉i 可能提供的 $n$ 和 $m$ 的任何可能值

## 样例 #1

### 输入

```
5
3
1 1 2
11
3 3 4 5 6 7 8 9 9 10 11
8
8 4 8 3 8 2 8 1
6
2 1 4 5 3 3
8
1 2 6 3 8 5 5 3```

### 输出

```
1 1
3 3
2 3
4 1
1 6```

# AI分析结果

### 题目翻译

为了帮助您准备即将到来的 Codeforces 竞赛，茜特菈莉设置了一个网格问题，并试图通过您的输入流为您提供一个 $n$ 乘 $m$ 的网格。具体来说，您的输入流应包含以下内容：

- 第一行包含 $n$ 和 $m$ 两个整数。- 网格的尺寸。
- 接下来的 $n$ 行分别包含 $m$ 个整数--网格值。

然而，有人截获了你的输入流，将所有给定的整数洗牌后放在一行！现在，一行中有 $k$ 个整数，而你却不知道每个整数原本属于哪一行。你决定自己确定 $n$ 和 $m$ 的值，而不是让茜特菈莉 重新发送输入。

输出茜特菈莉i 可能提供的 $n$ 和 $m$ 的任何可能值

### 样例 #1

#### 输入

```
5
3
1 1 2
11
3 3 4 5 6 7 8 9 9 10 11
8
8 4 8 3 8 2 8 1
6
2 1 4 5 3 3
8
1 2 6 3 8 5 5 3```

#### 输出

```
1 1
3 3
2 3
4 1
1 6```

### 题解分析与结论

#### 题解思路对比

1. **Sakura_Emilia**：使用 `map<int, int>` 记录每个数的出现次数，检查是否有两个数的乘积等于 $k-2$。特别注意正方形的情况。
2. **DoubleQLzn**：使用桶数组记录每个数的出现次数，遍历数组寻找满足 $a_i \times a_j + 2 = n$ 的数对。
3. **WRT_Partisan**：使用 `map<int, int>` 记录每个数的出现次数，遍历 `map` 寻找满足 $n \times m = k-2$ 的数对。
4. **Jason_Ming**：使用数组记录每个数的出现次数，遍历数组寻找满足 $a_i \times a_j = k-2$ 的数对。
5. **_dbq_**：使用桶数组记录每个数的出现次数，遍历数组寻找满足 $n \times m = k-2$ 的数对。
6. **wuyouawa**：使用桶数组记录每个数的出现次数，遍历数组寻找满足 $n \times m = k-2$ 的数对。
7. **linjinkun**：使用桶数组记录每个数的出现次数，遍历数组寻找满足 $n \times m = k-2$ 的数对。
8. **huanglihuan**：使用桶数组记录每个数的出现次数，遍历数组寻找满足 $n \times m = k-2$ 的数对。
9. **_xguagua_Firefly_**：使用 `map<int, int>` 记录每个数的出现次数，遍历 `map` 寻找满足 $n \times m = k-2$ 的数对。

#### 最优关键思路

所有题解的核心思路都是通过记录每个数的出现次数，然后遍历数组或 `map` 寻找满足 $n \times m = k-2$ 的数对。其中，使用桶数组的方法在时间复杂度上更优，因为数组的访问时间是 $O(1)$，而 `map` 的访问时间是 $O(\log n)$。

#### 可拓展之处

该题的思路可以拓展到其他类似的问题，例如在给定一个数组中找到两个数，使得它们的和或差等于某个特定值。此外，使用桶数组的方法在处理大规模数据时具有明显的优势。

### 推荐题目

1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得

- **Sakura_Emilia**：特别注意正方形的情况，避免重复计算。
- **DoubleQLzn**：使用桶数组优化时间复杂度，避免使用 `map` 带来的额外开销。
- **linjinkun**：在处理多组数据时，记得清空桶数组，避免数据污染。

### 所选高分题解

#### 1. Sakura_Emilia (4星)

**关键亮点**：使用 `map<int, int>` 记录每个数的出现次数，特别注意正方形的情况，避免重复计算。

```cpp
inline void solve() {
    cin >> n;
    mp.clear();
    for(int i = 1; i <= n; i++) {
        cin >> k;
        if((n - 2) % k == 0) {
            if(mp[(n - 2) / k] > 0)
                ans1 = k, ans2 = (n - 2) / k;
            mp[k]++;
        }
    }
    cout << ans1 << " " << ans2 << endl;
}
```

#### 2. DoubleQLzn (4星)

**关键亮点**：使用桶数组记录每个数的出现次数，优化时间复杂度，避免使用 `map` 带来的额外开销。

```cpp
void solve() {
    memset(f,0,sizeof f);
    cin >> n;
    for (int i = 1;i <= n;i++) {
        cin >> a[i];
        f[a[i]]++;
    }
    n = n - 2;
    int ans1,ans2;
    for (int i = 1;i <= n + 2;i++) {
        if (n % a[i] == 0 && ((a[i] != n / a[i] && f[n / a[i]]) || (a[i] == n / a[i] && f[a[i]] > 1))) {
            ans1 = a[i],ans2 = n / a[i];
            break;
        }
    }
    cout << ans1 << ' ' << ans2 << endl;
}
```

#### 3. WRT_Partisan (4星)

**关键亮点**：使用 `map<int, int>` 记录每个数的出现次数，遍历 `map` 寻找满足 $n \times m = k-2$ 的数对。

```cpp
signed main() {
    scanf("%lld", &t);
    while (t--) {
        mp.clear();
        scanf("%lld", &k);
        for (int i = 1; i <= k; i++) {
            scanf("%lld", &a);
            if ((k - 2) % a == 0)
                mp[a]++;
        }
        for (auto i : mp)
            if ((i.first != (k - 2) / i.first && mp.count((k - 2) / i.first)) || (i.first == (k - 2) / i.first && i.second >= 2))
                ans1 = i.first, ans2 = (k - 2) / i.first;
        printf("%lld %lld\n", ans1, ans2);
    }
    return 0;
}
```

---
处理用时：52.02秒
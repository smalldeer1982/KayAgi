# 题目信息

# Game with Colored Marbles

## 题目描述

Alice 和 Bob 在玩一个游戏。一共有 $n$ 个石子，第 $i$ 个的颜色为 $c_i$。Alice 先手，两人轮流取走一颗石子，直到游戏结束。

Alice 的最终分数计算如下：

- 对于每一个颜色 $x$，如果 Alice 有至少一颗该颜色的石子，她获得 $1$ 分。
- 对于每一个颜色 $x$，如果她拥有全部该颜色的石子，她额外获得 $1$ 分（只考虑游戏中出现的颜色）。

比如，假设有颜色为 $[1,3,1,3,4]$ 的五颗石子，Alice 第一次拿第 $1$ 颗，Bob 拿第 $3$ 颗，然后 Alice 拿第 $5$ 颗，Bob 拿第 $2$ 颗，最后 Alice 拿第 $4$ 颗。最终，Alice 获得 $4$ 分：$3$ 分来自拿走至少一颗颜色为 $1,3,4$ 的石子，剩下 $1$ 分来自拿走全部颜色为 $4$ 的石子。**注意这一方案不一定是对双方最优的。**

Alice 想最大化她的分数，而 Bob 想最小化这个分数，假设两人都足够聪明。求 Alice 的最终得分。

## 样例 #1

### 输入

```
3
5
1 3 1 3 4
3
1 2 3
4
4 4 4 4```

### 输出

```
4
4
1```

# AI分析结果

### 题目内容重写

Alice 和 Bob 在玩一个游戏。一共有 $n$ 个石子，第 $i$ 个的颜色为 $c_i$。Alice 先手，两人轮流取走一颗石子，直到游戏结束。

Alice 的最终分数计算如下：

- 对于每一个颜色 $x$，如果 Alice 有至少一颗该颜色的石子，她获得 $1$ 分。
- 对于每一个颜色 $x$，如果她拥有全部该颜色的石子，她额外获得 $1$ 分（只考虑游戏中出现的颜色）。

比如，假设有颜色为 $[1,3,1,3,4]$ 的五颗石子，Alice 第一次拿第 $1$ 颗，Bob 拿第 $3$ 颗，然后 Alice 拿第 $5$ 颗，Bob 拿第 $2$ 颗，最后 Alice 拿第 $4$ 颗。最终，Alice 获得 $4$ 分：$3$ 分来自拿走至少一颗颜色为 $1,3,4$ 的石子，剩下 $1$ 分来自拿走全部颜色为 $4$ 的石子。**注意这一方案不一定是对双方最优的。**

Alice 想最大化她的分数，而 Bob 想最小化这个分数，假设两人都足够聪明。求 Alice 的最终得分。

### 题解综合分析与结论

各题解的核心思路基本一致，即通过贪心策略优先处理出现次数为1的弹珠，因为这些弹珠可以让Alice直接获得2分。剩余的出现次数大于1的弹珠，Alice只能获得1分。Bob的策略则是尽可能减少Alice的得分，因此他会优先抢走这些出现次数为1的弹珠。

### 所选高星题解

#### 题解1：作者：Beihang_Jiang (4星)

**关键亮点：**
- 清晰的贪心策略分析，优先处理出现次数为1的弹珠。
- 使用`unordered_map`统计弹珠出现次数，代码简洁高效。

**核心代码：**
```cpp
int x=0,y=0;
unordered_map<int,int> num;
unordered_map<int,bool> vis;
for(int i=1;i<=n;i++)
    cin>>c[i],num[c[i]]++;
for(int i=1;i<=n;i++){
    if(vis.find(c[i])==vis.end()){
        vis[c[i]]=1;
        if(num[c[i]]==1)
            x++;
        else
            y++;
    }
}
cout<<2*ceil(x*1.0/2)+y<<endl;
```

**个人心得：**
- 使用`unordered_map`提高了代码的可读性和效率，避免了手动管理哈希表的复杂性。

#### 题解2：作者：GeYang (4星)

**关键亮点：**
- 简洁的数学公式推导，直接计算出Alice的得分。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
int ans=0;
for(int i=1;i<=n;i++){
    if(b[i]==1){
        ans++;
    }
}
ans=ceil(ans/2.0)*2+n-o;
cout<<ans<<"\n";
```

**个人心得：**
- 通过数学公式直接计算得分，避免了复杂的模拟过程，代码更加简洁。

#### 题解3：作者：The_foolishest_OIer (4星)

**关键亮点：**
- 详细的策略分析，解释了Alice和Bob的最优策略。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
int ans=0;
for(int i=1;i<=n;i++){
    if(b[i]==1){
        ans++;
    }
}
ans=ceil(ans/2.0)*2+n-o;
cout<<ans<<"\n";
```

**个人心得：**
- 通过详细的策略分析，帮助理解Alice和Bob的最优策略，代码实现简洁。

### 最优关键思路或技巧

1. **贪心策略**：优先处理出现次数为1的弹珠，因为这些弹珠可以让Alice直接获得2分。
2. **数学公式**：通过数学公式直接计算得分，避免了复杂的模拟过程。
3. **数据结构**：使用`unordered_map`统计弹珠出现次数，提高了代码的可读性和效率。

### 可拓展之处

- **类似题目**：可以考虑类似的博弈论题目，如Nim游戏、取石子游戏等，通常涉及贪心策略和数学公式。
- **数据结构**：在处理类似问题时，可以考虑使用哈希表、优先队列等数据结构来优化算法。

### 推荐题目

1. **洛谷P1002 [NOIP2002 普及组] 过河卒**：考察动态规划和博弈论。
2. **洛谷P1048 [NOIP2005 普及组] 采药**：考察贪心策略和动态规划。
3. **洛谷P1064 [NOIP2006 提高组] 金明的预算方案**：考察贪心策略和动态规划。

---
处理用时：37.55秒
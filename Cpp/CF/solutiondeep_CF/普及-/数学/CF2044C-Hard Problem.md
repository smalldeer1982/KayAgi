# 题目信息

# Hard Problem

## 题目描述

Ball 是折纸大学的一名老师。他的教室有 $2$ 行座位，每行有 $m$ 个座位。

Ball 在教 $a + b + c$ 只猴子，他希望能够让尽可能多的猴子坐在座位上。他知道有 $a$ 只猴子只想坐在第 $1$ 行，有 $b$ 只只想坐在第 $2$ 行，有 $c$ 只对座位没有偏好。每个座位上只能坐一只猴子，且入座的猴子的偏好必须被满足。

Ball 最多可以让多少只猴子就坐？

## 说明/提示

对于第二组测试样例，有 $6$ 只猴子想坐在第一行，但只有 $3$ 个座位。对座位没有偏好的猴子和喜欢坐在第二行的猴子可以一起坐在第二行。因此，答案是 $3+2=5$ 。

## 样例 #1

### 输入

```
5
10 5 5 10
3 6 1 1
15 14 12 4
1 1 1 1
420 6 9 69```

### 输出

```
20
5
30
2
84```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

Ball 是折纸大学的一名老师。他的教室有 $2$ 行座位，每行有 $m$ 个座位。

Ball 在教 $a + b + c$ 只猴子，他希望能够让尽可能多的猴子坐在座位上。他知道有 $a$ 只猴子只想坐在第 $1$ 行，有 $b$ 只只想坐在第 $2$ 行，有 $c$ 只对座位没有偏好。每个座位上只能坐一只猴子，且入座的猴子的偏好必须被满足。

Ball 最多可以让多少只猴子就坐？

#### 说明/提示

对于第二组测试样例，有 $6$ 只猴子想坐在第一行，但只有 $3$ 个座位。对座位没有偏好的猴子和喜欢坐在第二行的猴子可以一起坐在第二行。因此，答案是 $3+2=5$ 。

#### 样例 #1

##### 输入

```
5
10 5 5 10
3 6 1 1
15 14 12 4
1 1 1 1
420 6 9 69
```

##### 输出

```
20
5
30
2
84
```

---

### 题解分析与结论

#### 综合分析

所有题解的核心思路都是贪心算法，优先安排有座位偏好的猴子，然后再安排无偏好的猴子。具体步骤如下：

1. **优先安排有偏好的猴子**：首先计算第一排和第二排分别能安排多少只猴子，即 `pa = min(m, a)` 和 `pb = min(m, b)`。
2. **安排无偏好的猴子**：计算剩余的空座位数 `2 * m - pa - pb`，然后安排无偏好的猴子，取 `min(c, 2 * m - pa - pb)`。
3. **总猴子数**：将上述两部分相加，得到最终结果。

#### 最优关键思路

- **贪心策略**：优先满足有偏好的猴子，确保它们能够入座，然后再利用剩余座位安排无偏好的猴子。
- **数学计算**：通过简单的数学计算（`min` 函数）来确定每排能安排的猴子数和剩余座位数。

#### 可拓展之处

- **类似问题**：这类问题可以扩展到多排座位、多种偏好的情况，甚至可以考虑座位之间的约束条件（如相邻座位不能坐特定类型的猴子）。
- **算法套路**：贪心算法在资源分配问题中非常常见，类似的题目可以通过优先满足最严格的条件来优化结果。

---

### 推荐题目

1. **P1003 铺地毯**（贪心算法）
2. **P1044 栈**（贪心与栈的结合）
3. **P1064 金明的预算方案**（贪心与背包问题的结合）

---

### 精选题解

#### 题解1：作者：OIerWu_829 (赞：4)

**星级**：★★★★★

**关键亮点**：思路清晰，代码简洁，直接使用贪心策略，优先安排有偏好的猴子，再安排无偏好的猴子。

**核心代码**：
```cpp
int pa = min(m, a), pb = min(m, b);
cout << pa + pb + min(c, m * 2 - pa - pb) << "\n";
```

#### 题解2：作者：JimmyQ (赞：2)

**星级**：★★★★

**关键亮点**：思路与题解1类似，但代码更加简洁，直接使用 `min` 函数计算最终结果。

**核心代码**：
```cpp
num1 = min(a, m), num2 = min(b, m);
cout << min(2 * m, num1 + num2 + c) << endl;
```

#### 题解3：作者：alan1118 (赞：1)

**星级**：★★★★

**关键亮点**：思路清晰，代码实现较为详细，逐步计算每排能安排的猴子数，再安排无偏好的猴子。

**核心代码**：
```cpp
int ans = min(n, a) + min(n, b);
if (n - a > 0) ans += min(n - a, c), c -= min(n - a, c);
if (n - b > 0) ans += min(n - b, c), c -= min(n - b, c);
cout << ans << endl;
```

---

### 总结

最优的解题思路是贪心算法，优先满足有偏好的猴子，再利用剩余座位安排无偏好的猴子。代码实现上，使用 `min` 函数可以简洁高效地计算结果。

---
处理用时：34.75秒
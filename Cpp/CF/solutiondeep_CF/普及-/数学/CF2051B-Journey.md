# 题目信息

# Journey

## 题目描述

Monocarp 决定去进行一次漫长的徒步旅行。

他计划，第一天走 $a$ 公里，第二天走 $b$ 公里，第三天走 $c$ 公里，到第四天再像第一天那样走 $a$ 公里，第五天如同第二天走 $b$ 公里，第六天则重复第三天走 $c$ 公里，如此循环下去。

当他走过的总路程达到至少 $n$ 公里时，就完成了整个旅程。你的任务是找出 Monocarp 在哪一天达到了这个目标。

## 说明/提示

在第一个例子中，Monocarp 在前四天总共走了 $1 + 5 + 3 + 1 = 10$ 公里。到了第五天，他又走了 $5$ 公里，总数达到 $15$ 公里。因为 $n = 12$，所以 Monocarp 在第五天实现了目标，完成了旅程。

在第二个例子中，Monocarp 第一天就走了 $6$ 公里。而由于 $n = 6$，他实际上一天就完成了旅程。

在第三个例子中，Monocarp 在六天内的总行程为 $3 + 4 + 1 + 3 + 4 + 1 = 16$ 公里。因为 $n = 16$，所以他在第六天达成旅程目标。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
12 1 5 3
6 6 7 4
16 3 4 1
1000000000 1 1 1```

### 输出

```
5
1
6
1000000000```

# AI分析结果

### 题目内容
Monocarp 决定去进行一次漫长的徒步旅行。

他计划，第一天走 $a$ 公里，第二天走 $b$ 公里，第三天走 $c$ 公里，到第四天再像第一天那样走 $a$ 公里，第五天如同第二天走 $b$ 公里，第六天则重复第三天走 $c$ 公里，如此循环下去。

当他走过的总路程达到至少 $n$ 公里时，就完成了整个旅程。你的任务是找出 Monocarp 在哪一天达到了这个目标。

### 说明/提示
在第一个例子中，Monocarp 在前四天总共走了 $1 + 5 + 3 + 1 = 10$ 公里。到了第五天，他又走了 $5$ 公里，总数达到 $15$ 公里。因为 $n = 12$，所以 Monocarp 在第五天实现了目标，完成了旅程。

在第二个例子中，Monocarp 第一天就走了 $6$ 公里。而由于 $n = 6$，他实际上一天就完成了旅程。

在第三个例子中，Monocarp 在六天内的总行程为 $3 + 4 + 1 + 3 + 4 + 1 = 16$ 公里。因为 $n = 16$，所以他在第六天达成旅程目标。

### 样例 #1
#### 输入
```
4
12 1 5 3
6 6 7 4
16 3 4 1
1000000000 1 1 1
```
#### 输出
```
5
1
6
1000000000
```

---

### 题解分析与结论

#### 综合分析与结论
本题的核心在于识别出Monocarp的徒步旅行是一个周期性问题，每3天为一个周期，每天走的路程分别为$a$、$b$、$c$公里。因此，解题的关键在于计算完整的周期数以及剩余的路程需要多少天来完成。

大多数题解都采用了以下思路：
1. 计算一个周期的总路程 $d = a + b + c$。
2. 计算完整周期数 $e = n / d$，并计算剩余路程 $r = n \% d$。
3. 根据剩余路程 $r$ 的大小，判断需要额外多少天来完成旅程。

这种思路的时间复杂度为 $O(1)$，能够高效处理大规模数据。

#### 最优关键思路
1. **周期性处理**：将问题转化为周期性问题，减少计算量。
2. **数学优化**：通过整除和取余操作，快速计算完整周期和剩余路程。
3. **分类讨论**：根据剩余路程的大小，判断需要额外多少天。

#### 推荐题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
3. [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)

---

### 所选高星题解

#### 题解1：作者：OIerWu_829 (4星)
**关键亮点**：
- 思路清晰，代码简洁。
- 通过向上取整计算完整周期数，避免了复杂的边界条件处理。
- 分类讨论剩余路程的处理方式，逻辑清晰。

**核心代码**：
```cpp
LL d = a + b + c, e = (n + d - 1) / d, f = e * d;
if (f > n) e--, f -= d;
LL ans = e * 3LL;
if (f < n) {
    if (f + a >= n) ans++;
    else if (f + a + b >= n) ans += 2;
    else ans += 3;
}
```

#### 题解2：作者：JimmyQ (4星)
**关键亮点**：
- 代码简洁，逻辑清晰。
- 直接通过整除和取余操作计算完整周期和剩余路程。
- 分类讨论剩余路程的处理方式，代码可读性强。

**核心代码**：
```cpp
long long num = n / (a + b + c);
n -= num * (a + b + c);
if (n == 0) cout << num * 3 << endl;
else if (a >= n) cout << num * 3 + 1 << endl;
else if (a + b >= n) cout << num * 3 + 2 << endl;
else cout << num * 3 + 3 << endl;
```

#### 题解3：作者：_colin1112_ (4星)
**关键亮点**：
- 代码简洁，逻辑清晰。
- 通过整除和取余操作计算完整周期和剩余路程。
- 分类讨论剩余路程的处理方式，代码可读性强。

**核心代码**：
```cpp
ll x = a + b + c;
ll s = n / x;
if (n - s * x == 0) cout << s * 3 << endl;
else {
    ll k = n - s * x;
    if (k <= a) cout << s * 3 + 1 << endl;
    else if (k <= a + b) cout << s * 3 + 2 << endl;
    else cout << s * 3 + 3 << endl;
}
```

---

### 通用建议与扩展思路
1. **周期性问题的处理**：对于类似周期性问题，可以通过计算完整周期和剩余部分来简化问题。
2. **数学优化**：利用整除和取余操作，快速计算周期数和剩余部分。
3. **分类讨论**：根据剩余部分的大小，进行适当的分类讨论，确保逻辑清晰。

### 个人心得摘录
- **调试经历**：在处理边界条件时，向上取整的方式可以有效避免复杂的边界处理。
- **顿悟感想**：将问题转化为周期性问题后，代码的逻辑变得更加清晰，计算量也大大减少。

---
处理用时：47.29秒
# 题目信息

# The Way to Home

## 题目描述

一只青蛙现在在一个数轴上，它现在要从点 $1$ 跳到点 $n$ ，它每次可以向右跳不超过 $d$ 个单位。比如，它可以从点 $x$ 跳到点 $x+a$  $( 1<=a<=d )$ 。特别的，青蛙只能在有百合花的点上停留。保证点 $1$ 和点 $n$ 之间有一些点有百合花。请输出青蛙到达点 $n$ 的最小跳跃次数。

## 说明/提示

在样例1中，青蛙可以从点 $1$ 跳3个单位到点 $4$ ，再从点 $4$ 跳4个单位到点 $8$ .
在样例2中，青蛙不能到达点 $n$ ，因为它至少需要跳3个单位，但它最多只能跳2个单位。

由 @星烁晶熠辉 提供翻译

## 样例 #1

### 输入

```
8 4
10010101
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 2
1001
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
8 4
11100101
```

### 输出

```
3
```

## 样例 #4

### 输入

```
12 3
101111100101
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解提供了多种解决青蛙跳跃问题的思路，涵盖了递归、深度优先搜索（DFS）、贪心、动态规划（DP）和图论（最短路算法）等多种算法。

- **思路对比**：
    - **递归与DFS**：通过递归的方式枚举所有可能的跳跃路径，找到最小跳跃次数，可通过剪枝优化。
    - **贪心**：每次尽可能跳最远的距离，若无法继续跳跃则返回 -1。
    - **DP**：定义状态数组，通过状态转移方程计算到达每个位置的最小跳跃次数。
    - **图论**：将问题转化为图，使用最短路算法（如 SPFA、Floyd）求解。

- **算法要点**：
    - **递归与DFS**：设置递归终止条件，枚举跳跃步数，更新答案。
    - **贪心**：从当前位置的最大跳跃距离开始枚举，找到第一个可跳跃的位置。
    - **DP**：初始化状态数组，枚举每个位置和前 d 个位置，更新最小跳跃次数。
    - **图论**：建图，将每个点向其可到达的点连边，使用最短路算法求解。

- **解决难点**：
    - **递归与DFS**：避免无限递归，可通过剪枝减少不必要的搜索。
    - **贪心**：证明贪心策略的正确性。
    - **DP**：定义合适的状态和状态转移方程。
    - **图论**：正确建图，选择合适的最短路算法。

### 所选题解
- **学而思李老师（4星）**
    - **关键亮点**：详细介绍了递归和深度优先搜索的概念，并对代码进行了优化，通过剪枝减少了搜索次数。
    - **核心代码**：
```cpp
const int NR = 1005;
char s[NR];
int n, d, ans = 1e9;
//pos现在位置，step到目前为止跳了多少步 
void dfs(int pos, int step)
{
    if(pos + d >= n) 				//现在能跳到终点 
    {
        ans = min(ans, step + 1);	//更新答案 
        return;						//结束这一次的搜索，返回上一步 
    }
    for(int i = d; i >= 1; i --)	//枚举所有可能跳到的步数 
        if(s[pos + i] == '1')	
        {
            dfs(pos + i, step + 1); //跳到那里，下一步搜索
            break;
        }							//可以跳i步 
}
```
核心实现思想：使用深度优先搜索，从当前位置枚举所有可能的跳跃步数，若能跳到终点则更新答案，通过从大到小枚举步数并剪枝，减少不必要的搜索。

- **空气树（4星）**
    - **关键亮点**：运用动态规划的思想，代码简洁易懂。
    - **核心代码**：
```cpp
int n,k,f[105];
//f[i]表示距离起点为i的地方需要跳多少步。
char a[105];
int main(){
    n=read();k=read();
    scanf("%s",a+1);
    f[1]=0;
    for(int i=2;i<=n;i++){
        if(a[i]=='0')continue;
        f[i]=1<<30;
        for(int j=i-1;j>=max(i-k,1);j--){
            if(a[j]=='0')continue;
            f[i]=min(f[i],f[j]+1);
        }
    }
    if(f[n]==1<<30){
        printf("-1\n");return 0;
    }
    printf("%d\n",f[n]);
    return 0;
}
```
核心实现思想：定义状态数组 f[i] 表示到达位置 i 的最小跳跃次数，通过枚举前 k 个位置，更新 f[i] 的值，最后判断是否能到达终点。

- **Lips（4星）**
    - **关键亮点**：贪心算法思路简单，代码实现简洁。
    - **核心代码**：
```cpp
string s;
int now,len,d,ans;
int main()
{
    cin>>len>>d>>s;
    len--;
    if(s[0]=='0'||s[len]=='0') printf("-1\n");
    while(now!=len)
    {
        bool flag=0;
        for(register int i=now+d;i>=now+1;i--)
            if(s[i]=='1') 
            {
                now=i,flag=1;
                break;
            }
        if(flag==0) 
        {
            printf("-1\n");
            return 0;
        }
        else ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：从当前位置的最大跳跃距离开始枚举，找到第一个可跳跃的位置，更新当前位置，若无法继续跳跃则返回 -1。

### 最优关键思路或技巧
- **剪枝优化**：在递归和深度优先搜索中，通过剪枝减少不必要的搜索，提高效率。
- **贪心策略**：每次尽可能跳最远的距离，可减少跳跃次数。
- **动态规划**：定义合适的状态和状态转移方程，通过递推计算最小跳跃次数。

### 可拓展之处
同类型题或类似算法套路：
- 其他跳跃问题，如不同的跳跃规则或限制条件。
- 路径规划问题，可使用图论或动态规划求解。
- 优化搜索算法，如 A* 算法等。

### 推荐题目
- [P1052 过河](https://www.luogu.org/problem/P1052)：与本题类似，需要离散化处理。
- [P1115 最大子段和](https://www.luogu.org/problem/P1115)：可使用动态规划求解。
- [P1616 疯狂的采药](https://www.luogu.org/problem/P1616)：经典的动态规划问题。

### 个人心得摘录与总结
- **学而思李老师**：详细介绍了递归和深度优先搜索的概念，帮助读者理解算法原理，通过剪枝优化提高了代码效率。
- **wky32768**：对最短路题解表示难以置信，强调了贪心策略的简单性。
- **Lips**：意外发现贪心算法可以解决问题，对比了不同算法的复杂度。

---
处理用时：32.57秒
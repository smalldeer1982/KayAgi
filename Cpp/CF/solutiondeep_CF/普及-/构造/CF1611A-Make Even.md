# 题目信息

# Make Even

## 题目描述

Polycarp 有一个不包含数字 $0$ 的整数 $n$。他可以使用他的数字执行以下操作数次（可能为零）：

将 $n$ 的长度 $l\ (1 \leq l \leq |n|$，这里 $|n|$ 指 $n$ 的十进制长度 $)$ 的前缀反转，即反转 $n$ 的 前 $l$ 位数字。那么，第 $1$ 个数位（默认从左向右数，下文同理）将与第 $l$ 个数位交换，第 $2$ 个数位与第 $(l-1)$ 个交换......以此类推。

例如，如果 $n=123456789$ 且 $l=5$，则 $n$ 变换后的值将为 $543216789$。

对于不同的操作，$l$ 的值可能不同。

Polycarp 喜欢偶数，并且非常不耐烦。因此，他想用最少的操作次数使他的数字 $n$ 变成偶数。

**本题有多组数据。**

## 样例 #1

### 输入

```
4
3876
387
4489
3```

### 输出

```
0
2
1
-1```

# AI分析结果

### 题目翻译
本题已为中文，无需翻译。

### 综合分析与结论
这些题解的核心思路一致，均采用分类讨论的方法，依据数字的奇偶性以及偶数数位的位置来确定最少操作次数。具体分为以下四种情况：
1. 数字本身是偶数，无需操作，输出 0。
2. 数字全为奇数，无法变成偶数，输出 -1。
3. 数字首位是偶数，翻转一次即可，输出 1。
4. 数字中间有偶数，需操作两次，输出 2。

各题解的主要差异在于数据处理方式，部分使用整数存储，部分使用字符串存储。使用字符串存储更便于访问数位，代码实现也更简洁。

### 所选题解
- **作者：szkzyc（5星）**
    - **关键亮点**：思路清晰，使用字符串处理数据，代码简洁易读。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool y(char c){
    return (c - '0') % 2;
}
int main(){
    int t;
    cin >> t;
    while(t--){
        string str;
        cin >> str; 
        int len = str.size();
        int cnt = 0;
        for(int i = 0; i < len; i++){
            if(y(str[i]) == 0) cnt++;
        }
        if(cnt == 0) puts("-1");
        else{
            if(y(str[len - 1]) == 0) puts("0");
            else if(y(str[0]) == 0) puts("1");
            else puts("2");
        }
    }
    return!0;
} 
```
核心实现思想：通过字符串存储数字，遍历字符串统计偶数数位的数量，根据不同情况输出结果。

- **作者：qwq___qaq（5星）**
    - **关键亮点**：思路清晰，使用字符串处理数据，代码简洁，注释详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
    scanf("%d",&T);
    for(int i=1;i<=T;i++){
        string s;
        cin>>s;
        int len=s.size();
        if(!((s[len-1]-'0')&1))
            puts("0");
        else if(!((s[0]-'0')&1))
            puts("1");
        else{
            bool p=1;
            for(int j=1;j<len-1;++j)
                if(!((s[j]-'0')&1)){
                    p=0;
                    puts("2");
                    break;
                }
            if(p)
                puts("-1");
        }
    }
    return 0;
}
```
核心实现思想：使用字符串存储数字，根据数字最后一位和首位的奇偶性判断操作次数，若不满足前两种情况则遍历中间数位，若有偶数则输出 2，否则输出 -1。

- **作者：Land_ER（4星）**
    - **关键亮点**：对每种情况进行了证明，思路严谨，使用字符数组处理数据。
    - **核心代码**：
```cpp
#include<cstdio>
int t;
char n[15];
int s;
bool flag;
inline bool check(int pt){
    return (n[pt]-'0') & 1;
}
void solve(void){
    scanf("%s",n);
    flag = 1;
    for(s = 0;n[s]!= '\0';++ s)
        flag = flag && check(s);
    if(flag)
        printf("-1\n");
    else{
        if(!check(s-1))
            printf("0\n");
        else if(!check(0))
            printf("1\n");
        else
            printf("2\n");
    }
    return;
}
int main(void){
    scanf("%d",&t);
    for(int i = 0;i < t;++ i)
        solve();
    return 0;
}
```
核心实现思想：使用字符数组存储数字，通过 `check` 函数判断数位的奇偶性，遍历数组判断是否全为奇数，再根据最后一位和首位的奇偶性输出结果。

### 最优关键思路或技巧
- 采用分类讨论的思维方式，将问题简化为几种明确的情况。
- 使用字符串或字符数组存储数字，便于访问和处理各个数位。

### 可拓展之处
同类型题目可能会改变操作规则，如改变翻转的区间或增加其他操作，解题时仍可采用分类讨论的方法，根据新的操作规则分析不同情况。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：需要对不同地毯的覆盖情况进行分类讨论。
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：根据区间的覆盖情况进行分类讨论。
3. [P1228 地毯填补问题](https://www.luogu.com.cn/problem/P1228)：通过递归和分类讨论解决问题。

### 个人心得
题解中未包含个人心得相关内容。

---
处理用时：28.04秒
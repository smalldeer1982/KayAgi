# 题目信息

# Outstanding Impressionist

## 题目描述

Eric 仍然记得整数数组形式的 $n$ 个印象。他将它们记录为 $w_1,w_2,\ldots,w_n$ 。然而，他对印象的记忆力很差。对于每个 $1\leq i\leq n$ ，他只能记住 $ l_i \leq w_i \leq r_i $ 。

Eric 认为，印象 $i$ 是唯一的，当且仅当存在一个可能的数组 $w_1,w_2,\ldots,w_n$ ，使得 $w_i\neq w_j$ 对所有具有 $j\neq i$ 的 $1\leq j\leq n$ 都成立。

请帮助 Eric 确定印象 $i$ 是否对每个 $1\leq i\leq n$ 是唯一的，对每个 $i$ 是独立的。也许你的判断可以帮助改写最后的故事。

## 样例 #1

### 输入

```
5
2
1 1
1 1
4
1 3
1 3
1 3
1 3
6
3 6
2 2
1 2
1 1
3 4
2 2
7
3 4
4 4
4 4
1 3
2 5
1 4
2 2
3
4 5
4 4
5 5```

### 输出

```
00
1111
100110
1001111
011```

# AI分析结果

### 题目翻译
Eric 仍然记得以整数数组形式呈现的 $n$ 个印象，他将它们记录为 $w_1,w_2,\ldots,w_n$。然而，他对印象的记忆力很差。对于每个 $1\leq i\leq n$，他只能记住 $ l_i \leq w_i \leq r_i $。

Eric 认为，如果存在一个可能的数组 $w_1,w_2,\ldots,w_n$，使得对于所有满足 $j\neq i$ 的 $1\leq j\leq n$ 都有 $w_i\neq w_j$，那么印象 $i$ 就是唯一的。

请帮助 Eric 确定对于每个 $1\leq i\leq n$，印象 $i$ 是否是唯一的，每个 $i$ 的判断是相互独立的。也许你的判断可以帮助改写最后的故事。

### 综合分析与结论
- **思路对比**：多数题解都抓住了“$l_i = r_i$ 的情况是关键”这一要点，因为取值区间长度大于 1 的数总能避开其他数。对于 $l_i = r_i$ 的情况，只需判断是否有其他位置也取该值；对于 $l_i \neq r_i$ 的情况，要判断区间内是否所有数都被其他位置“必须取”的值覆盖。
- **算法要点**：大部分题解使用前缀和来优化判断区间是否被覆盖的过程，时间复杂度为 $O(n + V)$；部分题解使用树状数组或线段树来处理区间问题。
- **解决难点**：核心难点在于证明取值区间长度大于 1 的数不会影响答案，以及高效判断取值区间内的数是否都被其他“必须取”的值覆盖。

### 所选题解
1. **作者：zhangzirui66（5 星）**
    - **关键亮点**：思路清晰，代码简洁，详细解释了前缀和的使用方法，对边界情况进行了特判。
    - **重点代码**：
```cpp
for(int i = 1; i <= n; i ++){
    if(a[i] == b[i]) mp[a[i]] ++;
}
for(int i = 1; i <= 2 * n; i ++){
    if(mp[i]) f[i] = 0;
}
for(int i = 1; i <= 2 * n; i ++) f[i] += f[i - 1];
for(int i = 1; i <= n; i ++){
    if((a[i] == b[i] && mp[a[i]] == 1) || f[b[i]] - f[a[i] - 1]) cout << 1;
    else cout << 0;
}
```
    - **核心实现思想**：先标记所有 $l_i = r_i$ 的值，再对标记数组做前缀和，最后根据前缀和判断每个区间是否有可行值。
2. **作者：linch（4 星）**
    - **关键亮点**：思路清晰，对问题进行了详细分析，特判情况明确，代码可读性高。
    - **重点代码**：
```cpp
for(int i = 1; i <= n; i++){
    cin >> l[i] >> r[i];
    if(l[i] == r[i]) cnt[l[i]]++;
}
for(int i = 1; i <= 2 * n; i++){
    pre[i] = pre[i - 1] + (cnt[i] > 0);
}
for(int i = 1; i <= n; i++){
    int k = pre[r[i]] - pre[l[i] - 1];
    if(l[i] == r[i] && cnt[l[i]] == 1) k--;
    if(k == r[i] - l[i] + 1) cout << "0";
    else cout << "1";
}
```
    - **核心实现思想**：统计每个确定值的出现次数，用前缀和记录区间内确定值的数量，最后根据前缀和判断每个区间是否被完全覆盖。
3. **作者：_lmh_（4 星）**
    - **关键亮点**：思路简洁明了，代码实现简洁，对 $l = r$ 和 $l \neq r$ 的情况分别处理，使用前缀和优化判断。
    - **重点代码**：
```cpp
for (int i = 1; i <= n; ++i){
    cin >> l[i] >> r[i];
    if (l[i] == r[i]){a[l[i]] = 1; cnt[l[i]]++;}
}
for (int i = 1; i <= m; ++i) a[i] += a[i - 1];
for (int i = 1; i <= n; ++i){
    if (l[i] == r[i]) cout << (cnt[l[i]] == 1);
    else cout << (a[r[i]] - a[l[i] - 1]!= r[i] - l[i] + 1);
}
```
    - **核心实现思想**：标记所有 $l = r$ 的值，对标记数组做前缀和，根据前缀和判断每个区间是否有未被覆盖的值。

### 最优关键思路或技巧
- **抓住关键情况**：认识到 $l_i = r_i$ 的情况是影响答案的关键，忽略取值区间长度大于 1 的数的干扰。
- **前缀和优化**：使用前缀和数组快速判断区间内是否所有数都被其他“必须取”的值覆盖，将时间复杂度从 $O(n^2)$ 优化到 $O(n + V)$。

### 可拓展之处
同类型题可能会改变区间的限制条件，或者增加更多的约束，如区间的合并、拆分等。类似算法套路包括使用树状数组、线段树等数据结构处理区间问题，以及利用前缀和、差分等技巧优化区间查询和修改操作。

### 洛谷推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)

### 个人心得摘录与总结
- **作者：zhangzirui66**：警示后人 $f$ 数组要开两倍空间，否则会 WA on #8，强调了注意数组空间大小的重要性。
- **作者：Autumn_Rain**：记录了自己曾经的疑惑及解答过程，通过反证法证明了只考虑点覆盖而不考虑线覆盖的正确性，提醒我们在解题时要深入思考，对算法的正确性进行严格证明。 

---
处理用时：34.09秒
# 题目信息

# Heist

## 题目描述

昨晚有一家电子商店被抢劫了。

昨天在商店里的所有键盘都是从$x$开始按升序编号的。例如，如果$x=4$，并且商店中有$3$个键盘，那么编号就为$4,5,6$；如果$x=10$，并且有$7$个键盘，那么编号就为$10,11,12,13,14,15,16$。

在抢劫之后，只有$n$个键盘仍然存在，他们的编号分别为$a_1,a_2,\dots ,a_n$。计算被盗的键盘的最小可能数量。工作人员不记得$x$也不记得商店里原来有几个键盘。

## 样例 #1

### 输入

```
4
10 13 12 8
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
7 5 6 4 8
```

### 输出

```
0
```

# AI分析结果

### 题目翻译
#### 抢劫案

### 题目描述
昨晚，一家电子产品商店遭到了抢劫。

昨天店里的所有键盘编号都是从 $x$ 开始按升序排列的。例如，如果 $x = 4$，并且店里有 $3$ 个键盘，那么编号就是 $4, 5, 6$；如果 $x = 10$，并且有 $7$ 个键盘，那么编号就是 $10, 11, 12, 13, 14, 15, 16$。

抢劫之后，店里只剩下 $n$ 个键盘，它们的编号分别是 $a_1, a_2, \dots, a_n$。请计算被盗键盘的最小可能数量。店员不记得 $x$ 的值，也不记得店里原来有多少个键盘。

### 样例 #1
#### 输入
```
4
10 13 12 8
```
#### 输出
```
2
```

### 样例 #2
#### 输入
```
5
7 5 6 4 8
```
#### 输出
```
0
```

### 综合分析与结论
- **思路对比**：大部分题解思路一致，即找出剩余键盘编号的最大值和最小值，计算出原本最少的键盘数量（最大值 - 最小值 + 1），再减去现有的键盘数量 $n$ 得到被盗键盘的最小数量。部分题解采用排序后遍历数组，计算相邻元素差值减 1 并累加的方式。
- **算法要点**：核心在于找出最大值和最小值，可通过排序或在输入时直接比较更新。
- **解决难点**：本题难点在于理解题意，明确要使被盗键盘数量最小，原键盘编号范围应是从剩余键盘的最小编号到最大编号。

### 题解评分
| 作者 | 评分 | 理由 |
| --- | --- | --- |
| been_apart | 4星 | 思路清晰，代码简洁，有注释说明 |
| dblark | 3星 | 思路正确，但使用Pascal语言，对C++用户参考价值稍低 |
| FCBM71 | 4星 | 思路解释详细，代码规范 |
| piggymichael | 4星 | 思路清晰，指出不用排序和开数组的优化点 |
| xsssg666 | 3星 | 思路正确，但代码中部分变量初始化过大，可优化 |
| Arghariza | 3星 | 思路正确，但使用 `greater<int>()` 排序增加复杂度 |
| fls233666 | 3星 | 思路正确，但采用遍历数组累加差值的方式，相对复杂 |
| 小闸蟹 | 3星 | 思路正确，代码规范，但使用遍历数组累加差值的方式 |
| C_Zn | 4星 | 提供两种解法，且指出最优解 |
| ezoixx130 | 4星 | 思路清晰，分析了时间和空间复杂度 |

### 所选题解
- **been_apart（4星）**
    - **关键亮点**：思路清晰，代码简洁，有注释说明。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    sort(a,a+n);
    cout<<a[n-1]-a[0]+1-n<<endl;
    return 0;
}
```
- **piggymichael（4星）**
    - **关键亮点**：思路清晰，指出不用排序和开数组的优化点。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,minn=0x3f3f3f3f,maxn=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>a;
        minn=min(a,minn);
        maxn=max(a,maxn);
    }
    cout<<maxn-minn+1-n<<endl;
    return 0;
}
```
- **C_Zn（4星）**
    - **关键亮点**：提供两种解法，且指出最优解。
    - **核心代码（最优解）**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
    int n;
    int maxn=-1e9,minn=1e9;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        maxn=max(maxn,x);
        minn=min(minn,x);
    }
    cout<<maxn-minn+1-n;
    return 0;
} 
```

### 最优关键思路或技巧
- 直接在输入时记录最大值和最小值，避免排序，可将时间复杂度优化到 $O(n)$。
- 利用公式“最大值 - 最小值 + 1 - 现有数量”直接计算被盗键盘的最小数量。

### 可拓展之处
同类型题可拓展到求连续序列中缺失元素的问题，如连续整数序列中缺失的数字、连续日期中缺失的日期等，解题思路类似，都是找出序列的范围，再根据现有元素计算缺失元素数量。

### 洛谷相似题目推荐
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：可通过找出价格范围和现有菜品价格，计算出可能的点菜组合中缺失的价格。
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：可将树的编号看作连续序列，计算出被移除的树的数量。
- [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)：可将身高看作连续序列，找出最长的先升后降的子序列，计算出需要出列的人数。

### 个人心得摘录与总结
部分题解提到题目描述较烦，难点在于理解英文题意，这提醒我们在做算法题时要仔细阅读题目，准确理解题意。同时，一些题解指出可以通过简单的数学公式计算结果，避免复杂的排序和遍历，这体现了在解题时要多思考，寻找最优解的重要性。

---
处理用时：36.27秒
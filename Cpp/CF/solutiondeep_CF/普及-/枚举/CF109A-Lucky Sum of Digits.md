# 题目信息

# Lucky Sum of Digits

## 题目描述

Petya喜欢幸运数字。我们都知道幸运数字是只含有$4$ 和$7$ 的正整数。例如数字$47$ ，$744$ ，$4$ 是幸运数字，而$5$ ，$17$ ，$467$ 不是。

Petya急切的想知道各个数位上数字的和为$n$ 的最小幸运数字是多少。帮助他完成这个任务。

## 样例 #1

### 输入

```
11
```

### 输出

```
47
```

## 样例 #2

### 输入

```
10
```

### 输出

```
-1
```

# AI分析结果

### 题目内容
#### 幸运数字的数位和

### 题目描述
Petya喜欢幸运数字。众所周知，幸运数字是只由数字4和7组成的正整数。例如，数字47、744、4是幸运数字，而5、17、467不是。

Petya迫切想知道各个数位上数字之和为n的最小幸运数字是多少。请帮助他完成这个任务。

### 样例 #1
#### 输入
```
11
```
#### 输出
```
47
```

### 样例 #2
#### 输入
```
10
```
#### 输出
```
-1
```

### 综合分析与结论
这些题解主要围绕寻找数位和为n的最小幸运数字展开，思路主要分为贪心和动态规划两类。

- **贪心思路**：核心是优先考虑4或7的个数，通过枚举4或7的数量，判断剩余的数能否被7或4整除，若能则找到解。如MZY666先尽可能用4，不够时从4借；Laser_Crystal以4最少、7最多为标准枚举4的个数；PC_DOS从最多的7开始枚举。
- **动态规划思路**：如06ray定义结构体数组记录每个数的最优解中4和7的个数，通过状态转移方程更新。

难点在于如何保证找到的数是最小的，贪心思路通过优先安排4或7的数量来控制位数和数字顺序，动态规划思路则通过状态转移方程比较不同组合得到最优解。

### 所选题解
- **作者：MZY666（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对每一步操作有明确解释，考虑到了将7个4转换为4个7以减小位数。
    - **个人心得**：作者提到“若有7个4就可以转换为4个7，这一点作者WA了一次”，说明在实现过程中遇到了细节问题，通过思考解决后得到正确结果。
    - **核心代码**：
```cpp
ll n,i=0,j=0;
scanf("%lld",&n);
i=n/4;n-=i*4;
if(n){
    while(i>0){
        n+=4;i--;
        if(n%7==0){j=n/7;n=0;break;}
    }
}
if(n)printf("-1\n");
else{
    while(i>=7){i-=7;j+=4;}
    while(i--)printf("4");
    while(j--)printf("7");
    printf("\n");
}
```
核心实现思想：先尽可能用4，若剩余的n不能被7整除，则从4借，若能整除则记录7的个数；最后将7个4转换为4个7以减小位数，输出结果。

- **作者：Laser_Crystal（4星）**
    - **关键亮点**：思路简洁明了，以贪心策略枚举4的个数，代码简洁易懂。
    - **核心代码**：
```cpp
int n;
cin>>n;
for(int i=0;i<=n/4;i++) {
    int f,s;
    f=i*4;
    s=n-f;
    if(s%7==0) {
        for(int j=0;j<i;j++) cout<<'4';
        s/=7;
        for(int j=0;j<s;j++) cout<<'7';
        return 0;
    }
}
cout<<-1;
```
核心实现思想：枚举4的个数，计算剩余的数，若能被7整除则输出对应的4和7，否则输出 -1。

- **作者：06ray（4星）**
    - **关键亮点**：使用动态规划和贪心结合的方法，通过结构体数组记录最优解，思路严谨。
    - **核心代码**：
```cpp
struct lucky{
    int four,seven;
};
lucky f[1010000];
bool pd(lucky a,lucky b) {
    if(a.four+a.seven+1>b.four+b.seven) return false;
    if(a.four+a.seven+1<b.four+b.seven) return true;
    return a.four>b.four;
}
int main() {
    int n;
    cin>>n;
    for(int i=1; i<=n; i++) {
        f[i].seven=10000000;
        f[i].four=10000000;
    }
    f[0].seven=0;
    f[0].four=0;
    for(int i=4; i<=n; i++) {
        if(i-4>=0) {
            f[i].four=f[i-4].four+1;
            f[i].seven=f[i-4].seven;
        }
        if(i-7>=0) {
            if(pd(f[i-7],f[i])) {
                f[i].four=f[i-7].four;
                f[i].seven=f[i-7].seven+1;
            }
        }
    }
    if(f[n].four>=1000000||f[n].seven>=1000000) cout<<-1;
    else {
        for(int i=1; i<=f[n].four; i++) cout<<4;
        for(int i=1; i<=f[n].seven; i++) cout<<7;
    }
    return 0;
}
```
核心实现思想：定义结构体数组记录每个数的最优解中4和7的个数，通过状态转移方程更新，最后根据记录输出结果。

### 最优关键思路或技巧
- 贪心思路中，优先考虑7的个数可以使位数尽可能少，从而使数字更小。
- 动态规划中，使用结构体数组记录最优解，通过状态转移方程比较不同组合，能确保找到最小的满足条件的数。

### 可拓展之处
同类型题如寻找由特定数字组成且满足某种和条件的最小数，类似算法套路可采用贪心或动态规划，根据具体题目调整枚举对象和状态转移方程。

### 推荐洛谷题目
- P1208 [USACO1.3]混合牛奶 Mixing Milk
- P1094 纪念品分组
- P1007 独木桥

---
处理用时：34.67秒
# 题目信息

# Double Sort

## 题目描述

你被给予了两个数组 $a$ 和 $b$，他们都有 $n$ 个数子。

在一步中，你可以选择两个数 $i$ 和 $j(1 \leq i,j \leq n; i \ne j)$ 并交换 $a_i$、$a_j$ 和 $b_i$、$b_j$。你必须交换这两个数组。

你最多可以执行 $10^4$ 次交换操作（可能为零次）。你能使两个数组都排序成非递减顺序么？如果可以，请打印所有使两个数组都成非递减顺序的移动序列。

## 样例 #1

### 输入

```
3
2
1 2
1 2
2
2 1
1 2
4
2 3 1 2
2 3 2 3```

### 输出

```
0
-1
3
3 1
3 2
4 3```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是先判断是否有解，再对数组进行排序并记录交换步骤，最后判断排序结果和交换次数是否满足条件。判断无解的关键在于检查两个数组元素间的大小关系是否一致；排序方法主要采用冒泡排序，部分使用选择排序或先标准库排序再冒泡排序；难点在于处理双数组同时交换以及保证交换次数不超过 $10^4$。

### 所选题解
- **Withershine（5星）**
    - **关键亮点**：思路清晰，详细阐述了判断有解的条件和冒泡排序的过程，代码规范，注释丰富。
    - **个人心得**：作者表示这道普及 - 难度的题自己写了两个半小时，强调了代码中一些细节处理的重要性，如每次交换后要再次检查数组是否依旧符合题意，否则会WA#2。
    - **核心代码**：
```cpp
flag = 1;
fr(i, 2, n)
{
    if((a[i] <= a[i - 1] && b[i] <= b[i - 1]) || (a[i] >= a[i - 1] && b[i] >= b[i - 1]))
    {
        continue;
    }
    flag = 0;
}
if(!flag)
{
    printf("-1\n");
    continue;
}
ll k = 0;
fr(i, 1, n)
{
    fr(j, i + 1, n)
    {
        if(a[i] > a[j] || b[i] > b[j])
        {
            swap(a[i], a[j]);
            swap(b[i], b[j]);
            ans[++k].i = i;
            ans[k].j = j;
        }
    }
}
flag = 1;
fr(i, 2, n)
{
    if(b[i] < b[i - 1] || a[i] < a[i - 1])
    {
        flag = 0;
        break;
    }
}
if(flag && k <= 10000)
{
    printf("%lld\n", k);
    fr(i, 1, k)
    {
        printf("%lld %lld\n", ans[i].i, ans[i].j);
    }
}
else
{
    printf("-1\n");
}
```
核心实现思想：先通过遍历判断两个数组元素间大小关系是否一致来确定是否有解；若有解，使用冒泡排序对数组进行排序并记录交换步骤；最后再次检查数组是否有序且交换次数不超过 $10^4$，满足条件则输出交换步骤，否则输出 -1。

- **YCSluogu（4星）**
    - **关键亮点**：代码简洁，明确指出这是一个双关键字排序问题，利用冒泡排序实现交换并记录步骤。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j < i; j++) {
        if (a[i] == a[j]? b[i] < b[j] : a[i] < a[j]) {
            swap(a[i], a[j]);
            swap(b[i], b[j]);
            l[++cnt] = i, r[cnt] = j;
        }
    }
}
for (int i = 2; i <= n; i++) {
    if (b[i] < b[i - 1]) {
        printf("-1\n");
        return;
    }
}
printf("%d\n", cnt);
for (int i = 1; i <= cnt; i++) {
    printf("%d %d\n", l[i], r[i]);
}
```
核心实现思想：使用冒泡排序进行双关键字排序，若 $a_{i}=a_{j}$ 则利用 $b_{i}$ 与 $b_{j}$ 进行排序，记录交换步骤；排序后检查 $b$ 数组是否有序，有序则输出交换步骤，否则输出 -1。

- **Michael1234（4星）**
    - **关键亮点**：思路清晰，代码结构良好，详细判断无解情况和排序结果，使用 `vector` 记录交换步骤。
    - **核心代码**：
```cpp
for(int i=2;i<=n;i++)
{
    if(a[i]<=a[i-1]&&b[i]<=b[i-1])
    {
        continue;
    }
    else if(a[i]>=a[i-1]&&b[i]>=b[i-1])
    {
        continue;
    }
    else
    {
        flag=false;
    }
}
if(!flag)
{
    cout<<"-1\n";
    continue;
}
for(int i=1;i<=n;i++)
{
    for(int j=i+1;j<=n;j++)
    {
        if(a[i]>a[j]||b[i]>b[j])
        {
            swap(a[i],a[j]);
            swap(b[i],b[j]);
            v.push_back({i,j});
        }
    }
}
for(int i=1;i<n;i++)
{
    if(a[i]>a[i+1]||b[i]>b[i+1])
    {
        flag=false;
        break;
    }
}
if(v.size()<=10000&&flag)
{
    cout<<v.size()<<"\n";
    for(auto i=v.begin();i!=v.end();i++)
    {
        cout<<i->first<<" "<<i->second<<"\n";
    }
}
else
{
    cout<<"-1\n";
}
```
核心实现思想：先判断两个数组元素间大小关系是否一致确定是否有解；若有解，使用冒泡排序对数组进行排序并使用 `vector` 记录交换步骤；最后检查数组是否有序且交换次数不超过 $10^4$，满足条件则输出交换步骤，否则输出 -1。

### 最优关键思路或技巧
- **判断无解条件**：检查两个数组中任意两个元素 $a_i$、$a_j$ 和 $b_i$、$b_j$ 的大小关系是否一致，若不一致则无解。
- **双关键字排序**：在排序过程中，若 $a_{i}=a_{j}$，则利用 $b_{i}$ 与 $b_{j}$ 进行排序。
- **冒泡排序**：由于 $n$ 最大为 $100$，冒泡排序可以满足交换次数不超过 $10^4$ 的要求，且实现简单。

### 可拓展之处
同类型题可能会增加更多数组或对交换规则进行更复杂的限制，类似算法套路可用于处理多关键字排序问题，如对结构体数组进行排序时考虑多个属性的大小关系。

### 推荐题目
- [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
- [P1093 [NOIP2007 普及组] 奖学金](https://www.luogu.com.cn/problem/P1093)
- [P1068 [NOIP2009 普及组] 分数线划定](https://www.luogu.com.cn/problem/P1068)

---
处理用时：35.96秒
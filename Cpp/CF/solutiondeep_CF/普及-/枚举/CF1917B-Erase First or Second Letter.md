# 题目信息

# Erase First or Second Letter

## 题目描述

You are given a string $ s $ of length $ n $ . Let's define two operations you can apply on the string:

- remove the first character of the string;
- remove the second character of the string.

Your task is to find the number of distinct non-empty strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.

## 说明/提示

In the first test case, we can get the following strings: $ a $ , $ aa $ , $ aaa $ , $ aaaa $ , $ aaaaa $ .

In the third test case, for example, the word $ ba $ can be reached in the following way:

- remove the first character of the current string $ ababa $ , getting $ baba $ ;
- remove the second character of the current string $ baba $ , getting $ bba $ ;
- remove the second character of the current string $ bba $ , getting $ ba $ .

## 样例 #1

### 输入

```
5
5
aaaaa
1
z
5
ababa
14
bcdaaaabcdaaaa
20
abcdefghijklmnopqrst```

### 输出

```
5
1
9
50
210```

# AI分析结果

### 题目中文重写
# 擦除第一个或第二个字母

## 题目描述
给定一个长度为 $n$ 的字符串 $s$。定义两种可以对字符串执行的操作：
- 移除字符串的第一个字符；
- 移除字符串的第二个字符。

你的任务是找出通过对初始字符串任意次数（可能为零次）、任意顺序地应用给定操作可以生成的不同非空字符串的数量。

## 说明/提示
在第一个测试用例中，我们可以得到以下字符串：$a$、$aa$、$aaa$、$aaaa$、$aaaaa$。

在第三个测试用例中，例如，单词 $ba$ 可以通过以下方式得到：
- 移除当前字符串 $ababa$ 的第一个字符，得到 $baba$；
- 移除当前字符串 $baba$ 的第二个字符，得到 $bba$；
- 移除当前字符串 $bba$ 的第二个字符，得到 $ba$。

## 样例 #1
### 输入
```
5
5
aaaaa
1
z
5
ababa
14
bcdaaaabcdaaaa
20
abcdefghijklmnopqrst
```

### 输出
```
5
1
9
50
210
```

### 综合分析与结论
这些题解的核心思路都是通过分析操作对字符串的影响，找出最终能得到的不同非空字符串的规律。由于每次操作只能删除第一个或第二个字符，所以最终得到的字符串是原字符串的一个后缀加上前面的一个字符（可以为空）。

- **思路对比**：大部分题解通过枚举后缀，统计每个后缀前面不同字符的数量，然后累加得到结果；部分题解通过找规律，分析不同长度字符串的前缀情况来计算。
- **算法要点**：使用标记数组或集合来记录不同字符的出现情况，避免重复计数。
- **解决难点**：关键在于理解操作对字符串的影响，找出最终字符串的构成规律，以及如何高效地统计不同字符串的数量。

### 所选题解
1. **作者：FiraCode (赞：8)，5星**
    - **关键亮点**：思路清晰，通过找规律分析不同长度字符串的情况，代码简洁，使用数组标记字符出现情况。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
int n;
string s;
bool st1[30];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> T;
    while (T--) {
        cin >> n >> s;
        int cnt = 0;
        long long ans = 0;
        for (int i = 0; i < n; ++i) {
            if (!st1[s[i] - 'a']) ++cnt;
            ans = 1ll * ans + 1ll * cnt;
            st1[s[i] - 'a'] = true;
        }
        printf("%lld\n", ans);
        memset(st1, false, sizeof(st1));
    }
    return 0;
}
```
    - **核心实现思想**：遍历字符串，用 `st1` 数组标记字符是否出现过，若未出现则 `cnt` 加 1，每次将 `cnt` 累加到 `ans` 中。

2. **作者：lutaoquan2012 (赞：5)，4星**
    - **关键亮点**：对操作进行等价转化，将任意操作序列转化为连续执行第一种操作再连续执行第二种操作，思路清晰，代码逻辑明确。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,T,cnt[30];
char s[100010];
int main() {
    cin>>T;
    while(T--){
        cin>>n>>(s+1);
        ll ans=0;
        memset(cnt,0,sizeof(cnt));
        for(int i=1;i<=n;i++) cnt[s[i]-'a']++;
        for(int i=n;i>=1;i--){
            ll tmp=0;
            for(int j=0;j<26;j++) tmp+=(cnt[j]>0);
            ans+=tmp;
            cnt[s[i]-'a']--;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：先统计每个字符的出现次数，然后从后往前遍历字符串，对于每个后缀，统计前面不同字符的数量并累加到 `ans` 中，同时更新字符出现次数。

3. **作者：_tourist (赞：5)，4星**
    - **关键亮点**：对能够生成的字符串进行数学描述，思路严谨，代码规范，使用数组记录不同长度前缀中不同字符的数量。
    - **核心代码**：
```cpp
#include<iostream>
#include<string.h>
using namespace std;
int n,t;
string s;
int a[100005];
int f[28];
inline int v(char c){return (int)c-96;}
int main()
{
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--)
    {
        memset(f,0,sizeof(f));
        memset(a,0,sizeof(a));
        cin>>n>>s;
        for(int i=0;i<s.length();i++)
        {
            if(i!=0) a[i]=a[i-1];
            if(!f[v(s[i])])
            {
                f[v(s[i])]=1;
                a[i]++;
            }
        }
        int ans=0;
        for(int i=0;i<s.length();i++) ans+=a[i];
        cout<<ans<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：遍历字符串，用 `f` 数组标记字符是否出现过，`a` 数组记录到当前位置不同字符的数量，最后将 `a` 数组的值累加得到结果。

### 最优关键思路或技巧
- **操作等价转化**：将任意操作序列转化为连续执行第一种操作再连续执行第二种操作，简化问题分析。
- **标记数组或集合**：使用标记数组或集合记录不同字符的出现情况，避免重复计数。

### 可拓展之处
同类型题可能会改变操作规则，例如可以删除第 $k$ 个字符，或者增加更多的操作类型。解题思路仍然是分析操作对字符串的影响，找出最终字符串的构成规律，然后进行统计。

### 推荐题目
1. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：考察去重和排序，与本题中统计不同字符的思路类似。
2. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要判断质数和回文数，同时要考虑优化时间复杂度，与本题中需要优化统计过程有一定相似性。
3. [P1308 [NOIP2011 普及组] 统计单词数](https://www.luogu.com.cn/problem/P1308)：考察字符串的匹配和统计，与本题中对字符串的处理有一定关联。

### 个人心得
题解中未包含个人心得内容。

---
处理用时：38.27秒
# 题目信息

# Shower Line

## 题目描述

学生宿舍里只有一个淋浴，有很多个学生希望早上洗澡。这就是为什么每天早上宿舍门口有五个人排队的原因。淋浴一打开，第一个人就从队里进入淋浴。一段时间后，第一个人离开淋浴，下一个人进入淋浴。这个过程一直持续到每个人淋浴过。 洗澡需要一些时间，所以排队的学生在这时讲话。学生们成对交谈：第 $2\times i-1$ 个人与第 $2\times i$ 个人交谈。 更详细些，把人数从 $1$ 到 $5$ 编号，让我们假设队列最初看起来是 $23154$（编号 $2$ 的人位于队列的开头），然后，在淋浴开始前，$2$ 和 $3$ 谈话, $1$ 和 $5$ 谈话，$4$ 没有任何人交谈，$2$ 洗澡时，$3$ 和 $1$ 交谈，$5$ 和 $4$ 交谈，$3$ 洗澡时，$1$ 和 $5$ 聊天，$4$ 没有任何人交谈，$1$ 洗澡时，$5$ 和 $4$ 聊天，然后 $5$ 淋浴，$4$ 淋浴。 我们知道如果 $i$ 和 $j$ 交谈，$i$ 的幸福值增加 $g_{i,j}$，$j$ 的幸福值增加 $g_{j,i}$，你的任务是找到这样一排学生最初的顺序，使得所有学生的幸福感和最终达到最大。

## 说明/提示

对于 $100\%$ 的数据，满足 $0\le g_{i,j}\le10^5$。

## 样例 #1

### 输入

```
0 0 0 0 9
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
7 0 0 0 0
```

### 输出

```
32
```

## 样例 #2

### 输入

```
0 43 21 18 2
3 0 21 11 65
5 2 0 1 4
54 62 12 0 99
87 64 81 33 0
```

### 输出

```
620
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路均为枚举 5 名学生的所有排列顺序，计算每种排列下学生们的幸福总值，最后取最大值。不同题解在实现枚举的方式和计算幸福总值的细节上有所差异。

#### 思路对比
- **使用 `next_permutation` 函数**：大部分题解采用该函数来生成全排列，代码简洁，实现方便。
- **DFS 回溯法**：部分题解使用 DFS 进行全排列的枚举，通过递归和回溯标记已访问元素。
- **多重循环枚举**：有题解使用五层嵌套循环直接枚举所有排列。

#### 算法要点对比
- **幸福总值计算**：多数题解将幸福总值的计算拆分为多个步骤，根据学生交谈的规则累加幸福值。部分题解将计算过程简化为一个公式。
- **数组下标处理**：不同题解在数组下标使用上有所不同，有的从 0 开始，有的从 1 开始。

#### 解决难点对比
- **全排列生成**：`next_permutation` 函数可直接生成全排列，避免手动实现复杂的排列算法；DFS 回溯法需要处理递归和标记访问状态。
- **幸福总值计算**：需准确按照学生交谈规则进行计算，避免遗漏或重复计算。

### 高评分题解
- **作者：zzx114514（5 星）**
    - **关键亮点**：思路清晰，详细解释了 `next_permutation` 函数的使用，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans,sum,g[10][10],a[]={0,1,2,3,4,5};
int main()
{
    for (int i=1;i<=5;i++)
        for (int j=1;j<=5;j++)
            cin>>g[i][j];
    do
    {
        sum=g[a[1]][a[2]]+g[a[2]][a[1]];
        sum+=g[a[2]][a[3]]+g[a[3]][a[2]];
        sum+=2*(g[a[3]][a[4]]+g[a[4]][a[3]]);
        sum+=2*(g[a[4]][a[5]]+g[a[5]][a[4]]);
        ans=max(ans,sum);
    }while(next_permutation(a+1,a+6));
    cout<<ans;
    return 0;
}
```
- **作者：残阳如血（4 星）**
    - **关键亮点**：对思路和复杂度进行了详细分析，提醒了 `next_permutation` 函数使用时数组需升序排列的注意事项。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans = INT_MIN, g[6][6], a[6] = {0, 1, 2, 3, 4, 5};
int main() {
    for (int i = 1; i <= 5; i++)
        for (int j = 1; j <= 5; j++)
            cin >> g[i][j];
    do ans = max(ans, g[a[1]][a[2]] + g[a[2]][a[1]] + g[a[2]][a[3]] + g[a[3]][a[2]] + 2 * g[a[3]][a[4]] +
                     2 * g[a[4]][a[3]] + 2 * g[a[4]][a[5]] + 2 * g[a[5]][a[4]]);
    while (next_permutation(a + 1, a + 6));
    cout << ans;
    return 0;
}
```
- **作者：Wi_Fi（4 星）**
    - **关键亮点**：详细说明了每一轮学生交谈的幸福值计算过程，代码逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f,N=1e5+5;
int i,j,n=5,g[6][6],a[6]={0,1,2,3,4,5},ans,sum;
int main()
{
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)cin>>g[i][j];
    }
    do
    {
        sum=g[a[1]][a[2]]+g[a[2]][a[1]]+g[a[2]][a[3]]+g[a[3]][a[2]]+2*g[a[3]][a[4]]+2*g[a[4]][a[3]]+2*g[a[4]][a[5]]+2*g[a[5]][a[4]];
        ans=max(ans,sum);
    }while(next_permutation(a+1,a+n+1));
    cout<<ans;
    return 0;
}
```

### 最优关键思路或技巧
- **使用 `next_permutation` 函数**：该函数可方便地生成数组的全排列，避免手动实现复杂的排列算法，提高代码的简洁性和可读性。
- **公式化计算幸福总值**：将幸福总值的计算过程总结为一个公式，减少代码的重复度，提高计算效率。

### 拓展思路
同类型题或类似算法套路：
- 当人数增多时，全排列的数量会急剧增加，可考虑使用剪枝算法优化枚举过程。
- 若题目条件发生变化，如交谈规则改变、幸福值计算方式改变，可根据新规则调整计算逻辑。

### 推荐题目
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)：考察全排列的生成，与本题枚举排列顺序的思路相关。
2. [P1088 火星人](https://www.luogu.com.cn/problem/P1088)：可使用 `next_permutation` 函数解决，进一步熟悉该函数的使用。
3. [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)：需要枚举所有可能的路径，与本题枚举排列顺序的思想类似。

### 个人心得摘录与总结
- **作者：残阳如血**：提醒使用 `next_permutation` 函数时，一开始的数组必须是升序排列的，否则程序运行结果会出现问题。
- **作者：yydfj**：表明自己是第十四次写题解，希望他人指出错误点，体现了积极学习和分享的态度。 

---
处理用时：33.34秒
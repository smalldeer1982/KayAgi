# 题目信息

# Nearest Minimums

## 题目描述

You are given an array of $ n $ integer numbers $ a_{0},a_{1},...,a_{n-1} $ . Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.
找到一个长度为n的序列中，距离最短的最小值的距离。

## 样例 #1

### 输入

```
2
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
9
2 1 3 5 4 1 2 3 1
```

### 输出

```
3
```

# AI分析结果

### 题目翻译
## 最近的最小值

### 题目描述
给定一个包含 $n$ 个整数的数组 $a_{0},a_{1},\cdots,a_{n - 1}$。找出数组中两个最接近（最近）的最小值之间的距离。保证数组中最小值至少出现两次。

### 样例 #1
#### 输入
```
2
3 3
```
#### 输出
```
1
```

### 样例 #2
#### 输入
```
3
5 6 5
```
#### 输出
```
2
```

### 样例 #3
#### 输入
```
9
2 1 3 5 4 1 2 3 1
```
#### 输出
```
3
```

### 综合分析与结论
- **思路对比**：
    - 归褯雾嵊、vectorwyx、ian_ian 的思路类似，先找出数组中的最小值，再记录最小值的位置，最后遍历位置数组找出最小距离。
    - da32s1da 不用数组，在读取数据的过程中动态更新最小值和最小距离。
    - 引领天下使用结构体存储数组元素和其下标，排序后找出最小距离。
- **算法要点**：
    - 前三种思路主要是枚举和记录位置。
    - da32s1da 是边读边处理。
    - 引领天下是排序后处理。
- **解决难点**：
    - 核心难点是准确记录最小值的位置并找出最小距离。da32s1da 的方法避免了额外数组的使用，降低了空间复杂度；引领天下的方法通过排序简化了后续查找最小距离的过程。

### 题解评分
- 归褯雾嵊：4星。思路清晰，代码可读性高，使用常规枚举方法解决问题。
- da32s1da：5星。思路巧妙，不用数组，空间复杂度低，代码简洁。
- vectorwyx：3星。思路有创新，使用 vector 存储位置，但代码复杂度稍高。
- 引领天下：3星。使用排序和结构体解决问题，思路较独特，但代码有一定复杂度。
- ian_ian：3星。思路和归褯雾嵊类似，代码可读性一般。

### 所选题解
- **da32s1da（5星）**：
    - **关键亮点**：不用数组，边读边处理，空间复杂度低。
    - **核心代码**：
```cpp
#include<cstdio>
const int inf=1e9+7;
int minn,wz,n,x,ans;
int main(){
    scanf("%d",&n);
    minn=inf;ans=n;
    for(int i=1;i<=n;i++){
        scanf("%d",&x);
        if(minn==x&&ans>i-wz)ans=i-wz;
        if(minn==x)wz=i;
        if(minn>x)minn=x,wz=i,ans=n;
    }
    printf("%d\n",ans);
}
```
核心实现思想：在读取每个数时，根据该数与当前最小值的关系，动态更新最小值、最小值的位置和最小距离。

- **归褯雾嵊（4星）**：
    - **关键亮点**：思路清晰，代码可读性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int wz[100001];
int main()
{
    int n,total=1;
    int zx=1000000000;
    int jl=100000;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(zx>a[i])
            zx=a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]==zx)
            wz[total++]=i;
    }
    for(int i=2;i<total;i++)
    {
        if(jl>wz[i]-wz[i-1])
            jl=wz[i]-wz[i-1];
    }
    cout<<jl;
}
```
核心实现思想：先找出数组中的最小值，再记录最小值的位置，最后遍历位置数组找出最小距离。

### 最优关键思路或技巧
- 动态更新：如 da32s1da 的做法，边读入数据边更新最小值和最小距离，避免使用额外数组，降低空间复杂度。
- 排序：如引领天下的做法，使用结构体存储元素和下标，排序后方便找出最小距离。

### 拓展思路
同类型题可以是在数组中找满足某种条件的元素对的最小距离，如最近的最大值、最近的相同元素等。类似算法套路可以是先确定目标元素，再记录其位置，最后找出最小距离。

### 洛谷推荐题目
- P1161 开灯：在一系列操作后找出相邻开灯位置的最小距离。
- P1427 小鱼的数字游戏：可以拓展为找出数组中相同数字的最小距离。
- P1047 校门外的树：可以变形为找出相邻被移除树位置的最小距离。

### 个人心得摘录与总结
- vectorwyx：提到这道题很水，轻松 AC 后琢磨高端做法，使用 vector 存储位置，体现了追求代码优化和创新的学习态度。 

---
处理用时：25.59秒
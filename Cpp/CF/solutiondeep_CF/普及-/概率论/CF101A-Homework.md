# 题目信息

# Homework

## 题目描述

Gerald在上学的一天，他的老师在班上布置了一项作业：她给每个同学一个有n个小写拉丁字母（即英文字母）的字符串，要求学生学习这个字符串中的字母的写法。但是，由于Gerald太懒了，他不想学习这些字母。这就是为什么他决定丢掉这个字符串的部分（不需要是连续的一部分）。他所丢失的部分可以由若干个任意长度在任意位置的连续的子字符串组成。但是，Gerald知道，如果他丢掉了超过k个字母，他就会显得非常可疑。

请求出在不超过k个字母被删除之后，字符串中最少剩下多少个不同的字母。你还需要求出一种删除这些字母的方式。

## 说明/提示

在第一个样例中这个字符串含有5个字母但是你只允许删去其中4个，所以会剩下至少一个字母。所以，正确答案就是1和任意一个长度在1到5的、只含有字母a的字符串。

在第二个杨立忠你可以删去4个字母。你不能删去所有的字母，因为这个字符串的长度是7。 但是，你可以删去所以除了a以外的字母（这样的字母不多于4个），所以得到的答案是"aaaa"。

在第三个样例中字符串的长度是8，且k=10，所以可以将所有的字母都删去。正确答案是0和空字符串。

Translated by @oolliivveerr

## 样例 #1

### 输入

```
aaaaa
4
```

### 输出

```
1
aaaaa
```

## 样例 #2

### 输入

```
abacaba
4
```

### 输出

```
1
aaaa
```

## 样例 #3

### 输入

```
abcdefgh
10
```

### 输出

```
0

```

# AI分析结果

### 题目翻译
此题目描述为中文，无需翻译。

### 综合分析与结论
这些题解的核心思路均为贪心算法，即优先删除出现次数少的字母，以保证在删除不超过 k 个字母的情况下，使剩余字母的种类最少。

- **思路对比**：大部分题解通过数组或结构体统计每个字母的出现次数，再进行排序，然后按出现次数从小到大删除字母；部分题解使用 map 存储字母数量，再对其进行排序处理。
- **算法要点**：关键在于准确统计每个字母的出现次数，并按次数排序，依据 k 的值决定删除哪些字母。
- **解决难点**：排序和贪心删除过程的实现，以及输出剩余字母时要保证顺序与原字符串一致。

### 题解评分
- **liuyifan**：3星。思路清晰，但代码存在拼写错误（`nain` 应为 `main`），影响了代码的正确性和可读性。
- **小恐**：4星。思路明确，代码结构清晰，注释详细，易于理解。
- **duchengjun**：3星。思路正确，但代码中使用 `#define int long long` 可能会导致不必要的内存开销，且部分变量命名不够清晰。
- **Chenxiaozhi**：3星。使用 map 存储字母数量，思路有一定特色，但排序部分使用冒泡排序，时间复杂度较高。
- **Need_No_Name**：3星。思路正确，但代码较为复杂，存在较多冗余变量和判断，影响了代码的可读性。
- **Astatinear**：3星。思路清晰，但代码中查找字母是否被删除的部分使用了嵌套循环，时间复杂度较高。
- **happybob**：3星。使用 map 和 vector 结合的方式，思路有一定创新性，但在查找字符是否被删除时使用 `string::find` 方法，效率较低。

### 所选题解
- **小恐**：4星。关键亮点在于思路清晰，代码结构合理，注释详细，易于理解。
```cpp
#include<stdio.h>
#include<algorithm>//sort要用 
#define MAXN 100005//a数组范围 
using namespace std;
char a[MAXN];//字符数组
struct node//结构体，不会上网查 
{
    int cnt;//记录每个字母出现次数，例如cnt[0]记录‘a’的次数 
    char ch;//记录这个字母是什么 
}f[30];
bool cmp(node x,node y)//sort中排序依据 
{
    return x.cnt<y.cnt;
}
bool book[28];//记录此字符种类是否被删 
int main()
{
    int k;
    scanf("%s",a);
    scanf("%d",&k);
    for(int i=0;i<26;++i)
        f[i].ch='a'+i;//初始化 
    for(int i=0;a[i]!='\0'/* 字符数组自动在末尾+一个‘\0’结束符 */ ;++i)
        ++f[a[i]-'a'].cnt; 
    sort(f,f+26,cmp);//排序 
    int start;//在字符串中出现最少次数的下标 
    for(int i=0;i<26;++i)
    {
        if(f[i].cnt!=0)//如果字符串中有了 
        {
            start=i;//记录 
            break;//退出循环 
        }
    } 
    int ans=0;//最后的字符种类数 
    for(int i=start;i<26;++i)
    {
        if(f[i].cnt>k)//不能将这种字符全删了 
        {
            ans=26-i;//记录答案 
            break;//跳出循环 
        }
        book[f[i].ch-'a']=1;//这种字符全部删除 
        k-=f[i].cnt;//删的次数减少 
    }
    printf("%d\n",ans);//输出种数 
    for(int i=0;a[i]!='\0';++i)
        if(!book[a[i]-'a'])//如果还没被删 
            printf("%c",a[i]);//输出 
    return 0;
}
```
核心实现思想：使用结构体存储每个字母及其出现次数，对结构体数组按出现次数排序，然后从出现次数少的字母开始删除，直到 k 不够用，最后输出剩余字母。

### 最优关键思路或技巧
- 使用结构体或数组统计每个字母的出现次数，方便后续排序和处理。
- 采用贪心算法，优先删除出现次数少的字母，以达到剩余字母种类最少的目的。

### 拓展思路
同类型题可考虑字符串替换、字符删除使字符串满足特定条件等问题，类似算法套路为贪心结合排序，先统计元素信息，再按一定规则排序，最后根据条件进行操作。

### 推荐题目
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录与总结
- **Need_No_Name**：“然后就是这个小细节浪费了我的1个半小时以上”，总结为在实现过程中要注意细节，避免因小错误浪费大量时间。 

---
处理用时：29.04秒
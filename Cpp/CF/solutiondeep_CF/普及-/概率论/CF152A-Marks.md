# 题目信息

# Marks

## 题目描述

总的来说，这个小组有$N$个学生。他们获得了$M$科目的分数。每个学生从每个科目的$1$分到$9$分（包括$1$分）得了一分。

如果没有学生在这个科目上获得更高的分数，我们就可以认为这个学科这个学生是最擅长的。如果存在一个他最擅长的学科，那么这个学生就是成功的。

你的任务是找出小组中成功学生的人数。

## 说明/提示

在第一个样例中，$1$号学生是最好的科目是$1$和$3$，$2$号学生是最好的科目$1$和$2$，但$3$号学生没有任何科目最好。

在第二个样例中，每个学生至少有一个科目是最好的。

Translated by Khassar

## 样例 #1

### 输入

```
3 3
223
232
112
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 5
91728
11828
11111
```

### 输出

```
3
```

# AI分析结果

### 题目内容（已为中文，无需翻译）
总的来说，这个小组有$N$个学生。他们获得了$M$科目的分数。每个学生从每个科目的$1$分到$9$分（包括$1$分）得了一分。

如果没有学生在这个科目上获得更高的分数，我们就可以认为这个学科这个学生是最擅长的。如果存在一个他最擅长的学科，那么这个学生就是成功的。

你的任务是找出小组中成功学生的人数。

### 说明/提示
在第一个样例中，$1$号学生是最好的科目是$1$和$3$，$2$号学生是最好的科目$1$和$2$，但$3$号学生没有任何科目最好。

在第二个样例中，每个学生至少有一个科目是最好的。

### 综合分析与结论
- **思路对比**：多数题解思路一致，先找出每门科目的最高分，再判断每个学生是否在某门科目取得最高分，以此确定成功学生人数。部分题解采用暴力枚举，直接比较每个人每门成绩与其他人该门成绩。
- **算法要点**：核心在于模拟，关键步骤为输入成绩、找出每门科目最高分、标记或统计成功学生。
- **解决难点**：
    - **无空格输入**：部分题解用`scanf("%1d", &a[i][j])`按位读入，部分用字符类型存储后转换为整数。
    - **并列最高分处理**：多数题解考虑到并列情况，将并列最高分学生都标记为成功。

### 所选题解
1. **Yaixy（5星）**
    - **关键亮点**：思路清晰，详细阐述解题步骤，代码注释完善，可读性高。
    - **个人心得**：提醒避免将二维数组开成一维数组的错误。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    cin>>s;
    for(int j=0;j<m;j++) a[i][j+1]=s[j]-'0';
    for(int j=1;j<=m;j++) if(a[i][j]>Max[j]) Max[j]=a[i][j];
}
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++) if(a[i][j]>=Max[j]) a[i][j]=0;
for(int i=1;i<=n;i++) {
    flag=false;
    for(int j=1;j<=m;j++) if(a[i][j]==0) flag=true;
    if(flag==true) ans++;
}
```
核心思想：先输入成绩并找出每门科目最高分，再将取得最高分的成绩标记为0，最后统计有标记成绩的学生数量。

2. **Allanljx（4星）**
    - **关键亮点**：思路直接，通过暴力枚举比较成绩，代码简洁易懂。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=1;j<=m;j++) {
        f=0;
        for(int k=1;k<=n;k++) {
            if(k==i) continue;
            if(a[k][j]>a[i][j]) {
                f=1;break;
            }
        }
        if(f==0) {
            ans++;break;
        }
    }
}
```
核心思想：遍历每个人的每门成绩，若没有比该成绩高的，则该学生为成功学生，计数器加1。

3. **Eason_AC（4星）**
    - **关键亮点**：思路清晰，代码简洁，使用`scanf("%1d", &a[i][j])`解决无空格输入问题。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; ++i)
    for(int j = 1; j <= m; ++j) {
        scanf("%1d", &a[i][j]);
        maxi[j] = max(maxi[j], a[i][j]);
    }
for(int i = 1; i <= n; ++i) {
    for(int j = 1; j <= m; ++j)
        if(maxi[j] == a[i][j]) {
            suc[i] = 1;
            break;
        }
    ans += suc[i];
}
```
核心思想：输入成绩时找出每门科目最高分，再遍历学生成绩，若等于最高分则标记该学生为成功，最后统计成功学生数量。

### 最优关键思路或技巧
- **数据处理**：用二维数组存储学生成绩，方便后续比较。
- **输入处理**：用`scanf("%1d", &a[i][j])`或字符类型存储后转换为整数解决无空格输入问题。
- **并列处理**：用标记数组记录每门科目最高分学生，避免遗漏并列情况。

### 可拓展之处
同类型题可拓展到更多维度或条件，如增加学生数量、科目数量，或加入额外条件（如限制成功学生某科最低分数）。类似算法套路为模拟题，需理清思路，按步骤模拟过程。

### 推荐洛谷题目
1. P1003 铺地毯
2. P1047 校门外的树
3. P1098 字符串的展开

---
处理用时：24.92秒
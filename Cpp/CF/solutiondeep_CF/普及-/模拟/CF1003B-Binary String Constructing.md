# 题目信息

# Binary String Constructing

## 题目描述

给你 $3$ 个整数 $a$ ,$b$ ,$x$ ，让你求出一个包含了 $a$ 个 $0$，$b$ 个 $1$ 的二进制串 $s$。要求其中 $s_i\not =s_{i+1}$ 的对数正好等于 $x$。

## 样例 #1

### 输入

```
2 2 1
```

### 输出

```
1100
```

## 样例 #2

### 输入

```
3 3 3
```

### 输出

```
101100
```

## 样例 #3

### 输入

```
5 3 6
```

### 输出

```
01010100
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕构造包含特定数量 0 和 1 且相邻不同字符对数为指定值的二进制串展开。思路上大多先比较 0 和 1 的数量，再根据指定对数的奇偶性进行不同处理。

#### 思路对比
- **模拟拼接法**：如 promise_ 的题解，不断在字符串末尾拼接 0 或 1，根据条件调整计数器，保证相邻位不同。
- **分情况构造法**：NaOHqwq、qjxqjx 等多位作者的题解，先判断 0 和 1 数量大小，确定先输出 01 还是 10，再根据指定对数的奇偶性输出剩余的 0 和 1。
- **分堆插入法**：y1 朵小寒的题解，将出现次数多的数排成序列，把出现次数少的数分堆插入。
- **插入贡献法**：Otue 的题解，考虑将 1 插入 0 序列中的不同位置的贡献，根据指定对数的奇偶性处理剩余的 1。

#### 算法要点对比
- 多数题解都需要先比较 0 和 1 的数量，进行相应的交换和标记。
- 对于指定对数 x 的奇偶性处理是关键，不同奇偶性决定了剩余 0 和 1 的输出顺序。

#### 解决难点对比
- 核心难点在于如何保证构造的二进制串满足相邻不同字符对数为 x 的要求。不同题解通过不同方式解决这一难点，如分情况构造法通过合理安排 01 串的输出顺序和剩余 0、1 的输出顺序；分堆插入法通过合理分堆和插入位置来满足条件。

### 所选题解
- **NaOHqwq（5 星）**
    - **关键亮点**：思路清晰，代码简洁易懂，详细说明了分情况讨论的思路和实现步骤。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a, b, x, qwq, qaq;
    cin >> a >> b >> x;
    if(a < b){
        qwq = 1;
        qaq = 0;
        swap(a, b);
    }else{
        qwq = 0;
        qaq = 1;
    }
    for(int i = 1;i <= x/2;i++){
        cout << qwq << qaq;
        a--, b--;
    }
    if(x%2 == 0){
        for(int i = 1;i <= b;i++){
            cout << qaq;
        }
        for(int i = 1;i <= a;i++){
            cout << qwq;
        }
    }else{
        for(int i = 1;i <= a;i++){
            cout << qwq;
        }
        for(int i = 1;i <= b;i++){
            cout << qaq;
        }
    }
    return 0;
}
```
核心实现思想：先比较 0 和 1 的数量，确定先输出 01 还是 10，循环输出 x/2 个 01 或 10 串，再根据 x 的奇偶性输出剩余的 0 和 1。

- **qjxqjx（5 星）**
    - **关键亮点**：思路清晰，强调找规律，对不同情况的处理逻辑明确，代码实现简洁。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,x;
int af,bf;
int main(){
    cin>>a>>b>>x;
    if(a<b){
        af=1;
        bf=0;
        swap(a,b);
    }else{
        af=0;
        bf=1;
    }
    for(int i=1;i<=x/2;i++){
        cout<<af<<bf;
        a--;
        b--;
    }
    if(x%2==0){
        for(int p=1;p<=b;p++){
            cout<<bf;
        }
        for(int p=1;p<=a;p++){
            cout<<af;
        }
    }else{
        for(int p=1;p<=a;p++){
            cout<<af;
        }
        for(int p=1;p<=b;p++){
            cout<<bf;
        }
    }
    return 0;
}
```
核心实现思想：与 NaOHqwq 的题解类似，先确定输出顺序，循环输出 x/2 个 01 或 10 串，再根据 x 的奇偶性输出剩余的 0 和 1。

- **caotianhao（4 星）**
    - **关键亮点**：思路详细，逐步推导，对每个步骤的分析清晰，代码实现符合思路逻辑。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,x;
int main(){
    cin>>a>>b>>x;
    if(a>b){
        for(int i=1;i<=x/2;i++){
            cout<<"01";
            a--;
            b--;
        }
        if(x%2==0){
            for(int i=1;i<=b;i++){
                cout<<"1";
            }
            for(int i=1;i<=a;i++){
                cout<<"0";
            }
        }else{
            for(int i=1;i<=a;i++){
                cout<<"0";
            }
            for(int i=1;i<=b;i++){
                cout<<"1";
            }
        }   
    }else{
        for(int i=1;i<=x/2;i++){
            cout<<"10";
            a--;
            b--;
        }
        if(x%2==0){
            for(int i=1;i<=a;i++){
                cout<<"0";
            }
            for(int i=1;i<=b;i++){
                cout<<"1";
            }
        }else{
            for(int i=1;i<=b;i++){
                cout<<"1";
            }
            for(int i=1;i<=a;i++){
                cout<<"0";
            }
        }
    }
    return 0;
} 
```
核心实现思想：先比较 0 和 1 的数量，确定输出 01 还是 10 串，循环输出 x/2 个相应串，再根据 x 的奇偶性输出剩余的 0 和 1。

### 最优关键思路或技巧
- 先比较 0 和 1 的数量，通过交换和标记确定输出顺序，简化后续处理。
- 根据指定对数 x 的奇偶性进行不同的输出安排，保证相邻不同字符对数满足要求。

### 可拓展之处
同类型题可能会改变字符种类，如构造包含多种字符的字符串，要求满足特定相邻字符关系的对数；或者改变条件，如要求相邻字符相同的对数为指定值等。解题套路仍然是先分析字符数量关系，再根据条件进行合理构造。

### 推荐洛谷题目
- P1008 三连击
- P1046 陶陶摘苹果
- P1055 ISBN 号码

### 个人心得摘录与总结
- ciwomuli：提到比赛时因未分开讨论 a>b 与 b>a 的情况一直 WA，强调了对不同情况分别处理的重要性。

---
处理用时：39.64秒
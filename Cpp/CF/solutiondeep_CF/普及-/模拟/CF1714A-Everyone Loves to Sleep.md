# 题目信息

# Everyone Loves to Sleep

## 题目描述

Vlad和其他人一样，非常喜欢睡觉。

Vlad每天都要做 $n$ 件事，每件事在特定时间。对于这些事情中的每一件，他都定了一个闹钟，其中第 $i$ 个在 $h_i$ 时 $m_i$ 分被触发（$0\le h_i<24,0\le m_i<60）$。

Vlad使用24小时时间格式，所以12:59之后是13:00,23:59后是00:00。

Vlad在H时M分睡觉（$0 \le H < 24， 0 \le M < 60$）。

他要你回答：在下一个闹钟响之前，他能睡多久。

如果在他上床睡觉的时候有任何闹钟响起，那么他将睡0小时0分钟。

## 样例 #1

### 输入

```
3
1 6 13
8 0
3 6 0
12 30
14 45
6 0
2 23 35
20 15
10 30```

### 输出

```
1 47
0 0
10 55```

# AI分析结果

### 题目翻译
# 每个人都爱睡觉

## 题目描述

Vlad和其他人一样，非常喜欢睡觉。

Vlad每天都要做 $n$ 件事，每件事在特定时间。对于这些事情中的每一件，他都定了一个闹钟，其中第 $i$ 个在 $h_i$ 时 $m_i$ 分被触发（$0\le h_i<24,0\le m_i<60$）。

Vlad使用24小时时间格式，所以12:59之后是13:00，23:59后是00:00。

Vlad在 $H$ 时 $M$ 分睡觉（$0 \le H < 24， 0 \le M < 60$）。

他要你回答：在下一个闹钟响之前，他能睡多久。

如果在他上床睡觉的时候有任何闹钟响起，那么他将睡0小时0分钟。

## 样例 #1

### 输入
```
3
1 6 13
8 0
3 6 0
12 30
14 45
6 0
2 23 35
20 15
10 30
```

### 输出
```
1 47
0 0
10 55
```

### 综合分析与结论
这些题解的核心思路都是计算Vlad入睡时间到每个闹钟响起时间的间隔，然后找出最小间隔。不同题解在实现方式上有所差异：
- **时间转换法**：将小时和分钟统一转换为分钟进行计算，能简化时间差的计算，避免复杂的进位借位处理，是多数题解采用的方法。
- **分类讨论法**：根据入睡时间和闹钟时间的大小关系，分多种情况讨论计算时间差，逻辑清晰但代码较繁琐。
- **排序法**：对闹钟时间进行排序，便于找到入睡后最早响起的闹钟。
- **模拟法**：从入睡时间开始逐分钟模拟，直到遇到闹钟响起，思路简单但效率较低。

难点主要在于处理跨天情况和时间差计算时的进位借位问题。

### 所选题解
1. **作者：Jasper08（5星）**
    - **关键亮点**：思路清晰，通过分类讨论计算入睡到闹钟响起的时间差，代码实现简洁，对特殊情况进行了特判处理。
    - **核心代码**：
```cpp
while (t -- ) {
    int n, h, m;
    scanf("%d%d%d", &n, &h, &m);
    int ansh = 24, ansm = 60;
    while (n -- ) {
        int alarmh, alarmm;
        scanf("%d%d", &alarmh, &alarmm);
        int sleeph = (24+alarmh-h) % 24; 
        if (alarmm < m) sleeph = (sleeph > 0)? sleeph-1 : 24-sleeph-1; 
        int sleepm = (60+alarmm-m) % 60; 
        if (sleeph*60+sleepm < ansh*60+ansm) ansh = sleeph, ansm = sleepm; 
    }
    printf("%d %d\n", ansh, ansm);
}
```
    - **核心思想**：对于每个闹钟，计算入睡到闹钟响起的小时数和分钟数，若该时间小于当前记录的最小时间，则更新最小时间。

2. **作者：__KrNalty__（4星）**
    - **关键亮点**：将时间转换为分钟进行计算，简化了时间差的计算，代码简洁，避免了复杂的分类讨论。
    - **核心代码**：
```cpp
while (T--) {
    cin >> n >> H >> M;
    int ans = 1e18, m = H * 60 + M; 
    for (int i = 1; i <= n; i++) {
        int hh, mm;
        cin >> hh >> mm;
        int nowm = hh * 60 + mm; 
        if (nowm < m) ans = min(ans, nowm + 1440 - m); 
        else ans = min(ans, nowm - m);
    }
    cout << ans / 60 << " " << ans % 60 << endl;
}
```
    - **核心思想**：将入睡时间和闹钟时间都转换为分钟，若闹钟时间小于入睡时间，加上一天的分钟数再计算时间差，最后取最小值。

3. **作者：李宇涵（4星）**
    - **关键亮点**：同样采用时间转换为分钟的方法，通过取模运算巧妙处理跨天情况，代码简洁高效。
    - **核心代码**：
```cpp
while(T--) {
    ans=inf;
    scanf("%d%d%d",&n,&h1,&m1);
    m=h1*60+m1;
    for(int i=1;i<=n;i++) {
        int th,tm,t,d;
        scanf("%d%d",&th,&tm);
        t=th*60+tm;
        d=(t-m+1440)%1440;
        ans=min(ans,d);
    }
    printf("%d %d\n",ans/60,ans%60);
}
```
    - **核心思想**：将入睡时间和闹钟时间转换为分钟，通过 `(t - m + 1440) % 1440` 计算时间差，处理跨天情况，最后取最小值。

### 最优关键思路或技巧
- **时间转换**：将小时和分钟统一转换为分钟进行计算，能避免复杂的进位借位处理，简化时间差的计算。
- **取模运算**：使用 `(t - m + 1440) % 1440` 处理跨天情况，代码简洁高效。

### 可拓展之处
同类型题可能会增加更多的时间限制条件，如工作日和休息日的闹钟设置不同，或者多个时间段的睡眠问题。类似算法套路可用于处理日程安排、航班时刻表等涉及时间计算和排序的问题。

### 推荐题目
1. [P1072  Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)：涉及数学计算和条件判断。
2. [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)：需要对数字和时间类似的组合进行枚举和判断。
3. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)：涉及数字的判断和筛选，与本题对时间的筛选有相似之处。

### 个人心得摘录与总结
- **taozhiming**：在考场上花费16分钟，认为题面较难理解，需结合样例。吐槽朋友一分钟一分钟跳的方法效率低，希望加强数据。总结为要仔细理解题意，避免使用低效算法。
- **zhicheng**：看到数据范围较小，采用直接模拟的方法解题，总结为可根据数据范围选择合适的解题方法。 

---
处理用时：38.34秒
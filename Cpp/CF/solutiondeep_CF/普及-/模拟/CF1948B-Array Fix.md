# 题目信息

# Array Fix

## 题目描述

给定一个长度为 $n$ 的非负整数序列 $a$，你可以进行如下操作任意次：

- 选择序列中第 $i$ 个数 $a_i$，将其从原序列中删除。然后将这个数字十进制上的每一位数，按原顺序放回序列。

比如，原来有序列 $[12, 3, 45, 67]$，如果选择其中第 $3$ 个数进行操作，那么序列就会变为 $[12, 3, 4, 5, 67]$。

再比如，原来有序列 $[2, 10]$，如果选择其中第 $2$ 个数进行操作，那么序列就会变为 $[2, 1, 0]$。

现在请你判断，是否存在一组操作方案，使得这个序列变得**单调不降**。

即，令最终序列长度为 $k$，那么有 $a_1 \leq a_2 \leq \cdots \leq a_k$。

## 说明/提示

对于 $100 \%$ 的数据，保证 $1 \leq t \leq 10^3, 2 \leq n \leq 50, 0 \leq a_i \leq 99$。

Translated by ShiRoZeTsu.

## 样例 #1

### 输入

```
3
4
12 3 45 67
3
12 28 5
2
0 0```

### 输出

```
YES
NO
YES```

# AI分析结果

### 题目翻译
#### 数组修复

#### 题目描述
给定一个长度为 $n$ 的非负整数序列 $a$，你可以进行如下操作任意次：
- 选择序列中第 $i$ 个数 $a_i$，将其从原序列中删除。然后将这个数字十进制上的每一位数，按原顺序放回序列。

例如，原来有序列 $[12, 3, 45, 67]$，如果选择其中第 $3$ 个数进行操作，那么序列就会变为 $[12, 3, 4, 5, 67]$。

再如，原来有序列 $[2, 10]$，如果选择其中第 $2$ 个数进行操作，那么序列就会变为 $[2, 1, 0]$。

现在请你判断，是否存在一组操作方案，使得这个序列变得**单调不降**。

即，令最终序列长度为 $k$，那么有 $a_1 \leq a_2 \leq \cdots \leq a_k$。

#### 说明/提示
对于 $100 \%$ 的数据，保证 $1 \leq t \leq 10^3$，$2 \leq n \leq 50$，$0 \leq a_i \leq 99$。

#### 样例 #1
##### 输入
```
3
4
12 3 45 67
3
12 28 5
2
0 0
```
##### 输出
```
YES
NO
YES
```

### 综合分析与结论
这些题解主要围绕判断给定序列能否通过拆分操作变成单调不降序列展开，思路可分为正向遍历和反向遍历两类。
- **正向遍历**：维护当前序列最大值，根据当前数与最大值及自身十位、个位的关系决定是否拆分，若不满足条件则无解。
- **反向遍历**：从后往前遍历，遇到前一个数大于后一个数时尝试拆分，若拆分后仍不满足条件则无解。

### 所选题解
- **作者：_KHIN（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过简洁的条件判断实现核心逻辑，易于理解和实现。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[55],t,now=0; 
signed main()
{
    cin>>t;
    while(t--)
    {
        now=-1e9;
        int flag=0;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            if(a[i]<now)
            {
                flag=1;
            }
            else
            {
                if(now<=a[i]/10&&now<=a[i]%10&&a[i]/10<=a[i]%10)
                {
                    now=a[i]%10;
                }
                else
                {
                    now=a[i];
                }
            }
        }
        if(!flag)
        {
            cout<<"YES"<<endl;
        }
        else
        {
            cout<<"NO"<<endl;
        }
    }
    return 0;
}
```
    - **核心思想**：使用 `now` 记录当前序列最大值，遍历序列，若当前数小于 `now` 则标记无解，否则根据当前数的十位、个位与 `now` 的关系更新 `now`。
- **作者：What__can__I__say（4星）**
    - **关键亮点**：详细分析了正向遍历的漏洞，并提出反向遍历的方法排除“后效性”，思路独特。
    - **核心代码**：
```cpp
for(int i=n-1;i>=1;--i){//从后往前
    if(x[i]>x[i+1]){
        while(x[i]!=0){
            a[++l]=x[i]%10;
            x[i]/=10;
        }
    }
    else a[++l]=x[i];
}
bool p=1;
for(int i=1;i<l;++i){
    if(a[i]<a[i+1]){
        printf("No\n");
        p=0;
        break;
    }
}
if(p)printf("Yes\n");
```
    - **核心思想**：从后往前遍历序列，若前一个数大于后一个数则拆分前一个数，最后检查拆分后的序列是否单调不降。
- **作者：2022_37_yzyUUU（4星）**
    - **关键亮点**：思路简洁，通过维护当前扫过的最小值，遇到不符合单调不降的数时尝试拆分，逻辑清晰。
    - **核心代码**：
```cpp
int mi=a[n],f=0;//初始化 
for(int i=n-1;i>=1;i--)
    if(a[i]>mi)//如果不符合单调不降 
        if(mi<a[i]%10||a[i]%10<a[i]/10){//如果拆开后依然不符合单调不降 
            cout<<"NO\n";//无解 
            f=1;
            break;
        }
        else mi=a[i]/10;//取最小值 
    else mi=a[i];//取最小值
if(!f)cout<<"YES\n";
```
    - **核心思想**：从后往前遍历序列，用 `mi` 记录当前最小值，若当前数大于 `mi` 则尝试拆分，若拆分后仍不满足条件则无解。

### 最优关键思路或技巧
- **反向遍历**：避免正向遍历的“后效性”问题，能更准确地判断是否需要拆分。
- **贪心策略**：在满足条件时优先拆分，使序列更有可能单调不降。

### 可拓展之处
同类型题可能会增加序列元素的位数、操作的复杂度或改变单调性的要求，解题时可继续使用贪心和遍历的思想，根据具体条件调整判断逻辑。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法，通过合并操作使序列满足一定条件。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：运用贪心策略解决排队问题，使总等待时间最短。
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：涉及区间选择问题，可使用贪心算法求解。

### 个人心得摘录与总结
- **作者：What__can__I__say**：一开始正向遍历存在漏洞，如 `12 45 6 78 9 100` 这组数据，后来发现反向遍历可排除“后效性”。总结：在处理序列问题时，要考虑遍历方向对结果的影响。
- **作者：hmzclimc**：赛时在第二个点上 Wa 了六次，说明本题有一定坑点。总结：做题时要仔细分析各种情况，避免遗漏。 

---
处理用时：39.77秒
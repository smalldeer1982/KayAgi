# 题目信息

# Product of Binary Decimals

## 题目描述

### 二进制小数的乘积
我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，你被要求判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

## 说明/提示

前五个测试用例可以表示为二进制小数的乘积如下：

$121 = 11 \times 11$
$1 = 1$ 已经是一个二进制小数。
$14641 = 11 \times 11 \times 11 \times 11$
$12221 = 11 \times 11 \times 101$
$10110 = 10110$ 已经是一个二进制小数。

## 样例 #1

### 输入

```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001```

### 输出

```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES```

# AI分析结果

### 题目翻译
#### 二进制小数的乘积
我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，你被要求判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

#### 说明/提示
前五个测试用例可以表示为二进制小数的乘积如下：
$121 = 11 \times 11$
$1 = 1$ 已经是一个二进制小数。
$14641 = 11 \times 11 \times 11 \times 11$
$12221 = 11 \times 11 \times 101$
$10110 = 10110$ 已经是一个二进制小数。

#### 样例 #1
##### 输入
```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001
```
##### 输出
```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES
```

### 综合分析与结论
| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| Pink_Cut_Tree | 手动列出 $10\sim 10^5$ 的“01 数”，对每个 $n$ 与“01 数”试除，用深度优先搜索判断能否分解为“01 数”的乘积 | 手动打表“01 数”，使用深度优先搜索进行试除 | 如何高效判断 $n$ 是否能分解为“01 数”的乘积 | 4星 |
| minVan | 预处理，对于 $n = i\times j$，若 $n$ 是好数或 $i,j$ 均满足题意，则 $n$ 满足题意，询问时 $O(1)$ 判断 | 预处理所有数，双重循环判断因数关系 | 如何高效预处理所有可能的数 | 4星 |
| thh_loser | 注意到 $n\leq 10^5$ 时合法因数除 $1$ 外只有 $14$ 个，暴力枚举 | 列出合法因数，递归模拟枚举过程 | 确定合法因数并进行枚举 | 3星 |
| Harrylzh | 打表出 $10^5$ 内题目要求的数，先去掉末尾 $0$ 再爆搜 | 打表关键数字，去除末尾 $0$ 优化搜索 | 减少搜索次数，避免超时 | 3星 |

### 所选题解
- Pink_Cut_Tree（4星）
    - 关键亮点：思路清晰，代码实现简单，通过手动打表和深度优先搜索解决问题。
    - 核心代码：
```cpp
int b[]={10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000,10001,10010,10011,10100,10101,10110,10111,11000,11001,11010,11011,11100,11101,11110,11111};
void dfs(int x){
    if(x==1||ans==1){
        ans=1; return;
    }
    for(int i=0;i<30;i++){
        if(x%b[i]==0){
            dfs(x/b[i]);
        }
    }
}
```
- minVan（4星）
    - 关键亮点：采用预处理的方式，询问时 $O(1)$ 判断，时间复杂度较低。
    - 核心代码：
```cpp
inline bool check(int x) {
    while(x) {
        if(x % 10 > 1) {
            return 0;
        }
        x /= 10;
    }
    return 1;
}
for(int i = 1; i < N; i++) {
    if(check(i)) { vis[i] = 1; continue; }
    for(int j = 1; j * j <= i; j++) {
        if(i % j == 0) {
            if(vis[j] && vis[i / j]) {
                vis[i] = 1;
                break;
            }
        }
    }
}
```

### 最优关键思路或技巧
- 手动打表或预处理符合条件的数，减少后续判断的时间复杂度。
- 使用深度优先搜索或递归枚举的方式，对可能的分解情况进行尝试。

### 拓展思路
同类型题可能会改变判断条件，如判断一个数是否能分解为其他特定数字的乘积，或者改变数据范围，需要根据具体情况调整算法。类似算法套路包括预处理、枚举、递归等。

### 推荐洛谷题目
- P1028 数的计算
- P1036 选数
- P1044 栈

### 个人心得
题解中未包含个人心得内容。

---
处理用时：26.16秒
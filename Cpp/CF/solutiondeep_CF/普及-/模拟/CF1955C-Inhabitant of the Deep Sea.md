# 题目信息

# Inhabitant of the Deep Sea

## 题目描述

$n$ 艘船只开始探索海洋深处。这些船的编号从 $1$ 到 $n$ 并按升序相互跟随，第 $i$ 只船的耐久度是 $a[i]$ 。( $1 ≤ a[i] ≤ 10^9$ )

海妖按特定顺序袭击 $k$ 次船只：首先，它攻击船队的第一艘船只，然后攻击最后一艘，然后再攻击第一艘……依此类推。

海妖的每次攻击都会降低飞船的 $1$ 耐久度。当船舶的耐久性下降到 $0$ ，它就沉没了（而海妖只攻击尚未沉没的船只）。如果所有的船只都沉没了，海妖就没有什么可攻击的了，它就会游走。

给定 $n , k$ 和 $n$ 只船的耐久度，问海妖袭击后有多少艘船被击沉？

## 样例 #1

### 输入

```
6
4 5
1 2 4 3
4 6
1 2 4 3
5 20
2 7 1 8 2
2 2
3 2
2 15
1 5
2 7
5 2```

### 输出

```
2
3
5
0
2
2```

# AI分析结果

### 题目翻译
# 深海居民

## 题目描述
$n$ 艘船只开始探索海洋深处。这些船的编号从 $1$ 到 $n$ 并按升序相互跟随，第 $i$ 只船的耐久度是 $a[i]$。（$1 ≤ a[i] ≤ 10^9$）

海妖按特定顺序袭击 $k$ 次船只：首先，它攻击船队的第一艘船只，然后攻击最后一艘，然后再攻击第一艘……依此类推。

海妖的每次攻击都会降低飞船的 $1$ 耐久度。当船舶的耐久性下降到 $0$，它就沉没了（而海妖只攻击尚未沉没的船只）。如果所有的船只都沉没了，海妖就没有什么可攻击的了，它就会游走。

给定 $n$、$k$ 和 $n$ 只船的耐久度，问海妖袭击后有多少艘船被击沉？

## 样例 #1
### 输入
```
6
4 5
1 2 4 3
4 6
1 2 4 3
5 20
2 7 1 8 2
2 2
3 2
2 15
1 5
2 7
5 2
```
### 输出
```
2
3
5
0
2
2
```

### 综合分析与结论
这些题解的核心思路都是避免对 $k$ 次攻击进行模拟，而是将攻击分为从前往后和从后往前两部分，分别计算能击沉的船只数量。
- **思路对比**：大部分题解思路相似，先判断总攻击次数 $k$ 是否大于等于所有船的耐久度总和，若是则直接输出 $n$；否则，计算从前往后和从后往前的攻击次数，分别遍历数组确定击沉的船只数。`yshpdyt` 的题解采用了另一种思路，通过不断比较左右端点船只的耐久度，根据不同情况更新操作次数和端点位置。
- **算法要点**：多数题解利用前缀和、后缀和或直接遍历数组来计算能击沉的船只数；`yshpdyt` 的题解则通过模拟每次攻击的过程，根据当前操作次数的奇偶性和左右端点船只的耐久度关系进行不同操作。
- **解决难点**：主要难点在于处理大规模的攻击次数 $k$，避免模拟导致的超时。各题解通过将攻击次数拆分，分别计算前后能击沉的船只数，有效解决了这一问题。

### 所选题解
- **_ayaka_（5星）**
    - **关键亮点**：思路清晰，代码简洁，在输入的同时进行第一次循环，节省了时间。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n,k,k1,k2,h,a[200005],ans;
signed main() {
    cin>>t;
    while(t--){
        cin>>n>>k;
        k2=k/2;
        k1=k-k2;
        h=0,ans=0;
        for(int i=1;i<=n;i++) {
            cin>>a[i];
            if(k1>=a[i]){
                k1-=a[i];
                h=i;
            }else{
                a[i]-=k1;
                k1=0;
            }
        }
        ans=h;
        for(int i=n;i>h;i--){
            if(a[i]<=k2) k2-=a[i],ans++;
            else break;
        }
        cout<<ans<<"\n";
    }
    return 0;
}
```
核心实现思想：先计算从前往后和从后往前的攻击次数 $k1$ 和 $k2$，在输入船只耐久度时，从前往后遍历，计算能击沉的船只数 $h$；再从后往前遍历，计算剩余攻击次数 $k2$ 能击沉的船只数，两者相加即为答案。

- **2c_s（4星）**
    - **关键亮点**：使用前缀和、后缀和的方法，逻辑清晰，便于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
long long n,k,a[N],pre[N],suf[N];
int main(){
    int T;
    cin>>T;
    while(T--){
        cin>>n>>k;
        long long ans=0,sum=0;
        for(int i=1;i<=n;++i){
            cin>>a[i];
            sum+=a[i];
        }
        if(k>=sum){
            cout<<n<<"\n";
            continue;
        }
        for(int i=1;i<=n;++i)pre[i]=pre[i-1]+a[i];
        for(int i=n;i>=1;--i)suf[i]=suf[i+1]+a[i];
        long long head=k/2,tail=k/2;
        if(k%2==1)++head;
        for(int i=1;i<=n;++i){
            if(head<pre[i]){
                ans=i-1;
                break;
            }
        }
        if(head>=pre[n])ans=n;
        for(int i=n;i>=1;--i){
            if(tail<suf[i]){
                ans+=n-i;
                break;
            }
        }
        if(tail>=suf[1])ans+=n;
        for(int i=1;i<=n;++i)pre[i]=suf[i]=0;
        cout<<min(n,ans)<<"\n";
    }
    return 0;
}
```
核心实现思想：先计算所有船的耐久度总和，若 $k$ 大于等于总和则直接输出 $n$；否则，计算前缀和、后缀和，分别确定从前往后和从后往前能击沉的船只数，最后取两者之和与 $n$ 的较小值作为答案。

- **YZMX（4星）**
    - **关键亮点**：思路简洁明了，代码实现简单。
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;

long long t,n,k,pl,pr,a[200005],sum,ans;

int main(){
    cin>>t;
    while(t--){
        cin>>n>>k;
        for(int i=0;i<=n;i++) a[i]=0;
        sum=0;
        ans=0;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            sum+=a[i];
        }
        if(k%2==0) pl=k/2;
        else pl=k/2+1;
        pr=k/2;
        if(k>=sum){
            cout<<n<<endl;
            continue;
        }
        for(int i=1;i<=n;i++){
            if(pl<a[i]) break;
            ans++;
            pl-=a[i];
        }
        for(int i=n;i>=1;i--){
            if(pr<a[i]) break;
            ans++;
            pr-=a[i];
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
核心实现思想：先计算所有船的耐久度总和，若 $k$ 大于等于总和则直接输出 $n$；否则，计算从前往后和从后往前的攻击次数 $pl$ 和 $pr$，分别遍历数组，计算能击沉的船只数，两者相加即为答案。

### 最优关键思路或技巧
- 避免模拟 $k$ 次攻击，将攻击分为从前往后和从后往前两部分，分别计算能击沉的船只数。
- 利用前缀和、后缀和或直接遍历数组，提高计算效率。

### 可拓展之处
同类型题可能会改变攻击规则或增加其他条件，如攻击顺序变化、增加特殊船只等。类似算法套路可用于处理其他需要避免大规模模拟的问题，通过拆分问题、利用前缀和等方法提高效率。

### 推荐题目
- [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
- [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)

### 个人心得
题解中未包含个人心得。

---
处理用时：40.05秒
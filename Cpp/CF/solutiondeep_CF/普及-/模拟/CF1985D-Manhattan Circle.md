# 题目信息

# Manhattan Circle

## 题目描述

给定一个由“.”和“#”字符组成的n*m的网格，网格上存在一个完整的曼哈顿圆。网格的左上角坐标为(1,1)
，右下角坐标为(n,m) 。
如果|h-a| +|k-b|<r，则点（a,b）属于以（h,k）为中心的曼哈顿圆，其中r是正常数。
在网格上，作为曼哈顿圆一部分的点集被标记为“#”。找到圆心的坐标。

## 样例 #1

### 输入

```
6
5 5
.....
.....
..#..
.....
.....
5 5
..#..
.###.
#####
.###.
..#..
5 6
......
......
.#....
###...
.#....
1 1
#
5 6
...#..
..###.
.#####
..###.
...#..
2 10
..........
...#......```

### 输出

```
3 3
3 3
4 2
1 1
3 4
2 4```

# AI分析结果

### 题目内容（已为中文，无需翻译）
给定一个由“.”和“#”字符组成的n*m的网格，网格上存在一个完整的曼哈顿圆。网格的左上角坐标为(1,1) ，右下角坐标为(n,m) 。
如果|h - a| +|k - b|<r，则点（a,b）属于以（h,k）为中心的曼哈顿圆，其中r是正常数。
在网格上，作为曼哈顿圆一部分的点集被标记为“#”。找到圆心的坐标。

### 综合分析与结论
这些题解的核心都是利用曼哈顿圆在网格中呈现菱形的特性来寻找圆心坐标，不过具体思路和实现方式有所不同。
- **Kindershiuo、abc1856896**：记录所有出现 `#` 的行和列，取中间行和中间列作为圆心坐标。
- **BrotherCall、tanzexiaodezhonghao、Wind_love**：找出 `#` 最长的一行，计算该行连续 `#` 的中点作为圆心坐标。
- **OPEC**：预处理每行和每列 `#` 的个数，找出井号最多的列和行的交界处作为圆心。
- **nightwatch.ryan**：找出所有边界点坐标，分别对横轴和纵轴坐标排序，输出中位数作为圆心坐标。
- **int_stl**：找到圆的最上、最下、最左和最右部分的位置，取平均值作为圆心坐标。
- **ZnHF**：找到对角线最长的一行，计算该行对角线的中点作为圆心坐标。

### 评分较高的题解
- **Kindershiuo（5星）**
    - **关键亮点**：思路清晰，代码结构简洁，使用 `map` 记录出现 `#` 的行和列，易于理解。
    - **核心代码**：
```cpp
void solve() {
    map<int, int>mahan;
    map<int, int>mashu;
    int n, m;
    cin >> n >> m;
    char c[n + 5][m + 5];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> c[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (c[i][j] == '#') {
                mahan[i] = 1;
                mashu[j] = 1;
            }
        }
    }
    int s1 = mahan.size();
    s1 = (s1 + 1) / 2;
    int cnt = 0;
    for (auto it = mahan.begin(); it!= mahan.end(); it++) {
        cnt++;
        if (cnt == s1)
            cout << it->first << " ";
    }
    int s2 = mashu.size();
    s2 = (s2 + 1) / 2;
    cnt = 0;
    for (auto it = mashu.begin(); it!= mashu.end(); it++) {
        cnt++;
        if (cnt == s2 )
            cout << it->first << endl;
    }
}
```
核心思想：通过两层循环遍历网格，用 `map` 记录出现 `#` 的行和列，再分别计算中间行和中间列。
- **BrotherCall（4星）**
    - **关键亮点**：思路直观，通过一次遍历找到 `#` 最长的一行，计算中点坐标。
    - **核心代码**：
```cpp
signed main() {
    cin >> t;
    while(t --) {
        cin >> n >> m;
        int maxx = 0;
        int x, y;
        for(int i = 1;i <= n;i ++) {
            scanf("%s", ch + 1);
            int now = 0, zh = 0, zq = 0;
            for(int j = 1;j <= m;j ++) {
                if(ch[j] == '#') {
                    if(now == 0) zq = j;
                    now ++, zh = j;
                }
            }
            if(now > maxx) {
                maxx = now;
                x = i;
                y = (zq + zh) / 2;
            }
        }
        cout << x << ' ' << y << "\n";
    }
    return 0;
}
```
核心思想：逐行遍历网格，记录每行连续 `#` 的起始和结束位置，找到最长的一行并计算中点。
- **OPEC（4星）**
    - **关键亮点**：预处理每行和每列 `#` 的个数，通过比较找出井号最多的列和行的交界处。
    - **核心代码**：
```cpp
void solve()
{
    int h[M];
    int s[M];
    memset(h,0,sizeof(h));
    memset(s,0,sizeof(s));
    cin>>n>>m;
    char a[n+10][m+10];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            if(a[i][j]=='#')
            {
                h[i]++;
                s[j]++;
            }
        }
    }
    int tt=0;
    int bi,bj;
    for(int i=1;i<=n;i++)
    {
        if(h[i]>tt)
        {
            bi=i;
            tt=h[i];
        }
    }
    tt=0;
    for(int i=1;i<=m;i++)
    {
        if(s[i]>tt)
        {
            bj=i;
            tt=s[i];
        }
    }
    cout<<bi<<' '<<bj<<'\n';
}
```
核心思想：通过两层循环遍历网格，记录每行和每列 `#` 的个数，再分别找出最大值对应的行和列。

### 最优关键思路或技巧
- 利用曼哈顿圆在网格中呈现菱形的特性，从不同角度寻找圆心坐标。
- 使用 `map` 等数据结构记录关键信息，简化代码实现。

### 可拓展之处
同类型题目可能会改变图形的形状或规则，例如椭圆、多边形等，解题思路可以从寻找图形的对称中心、重心等方面入手。

### 洛谷相似题目推荐
- P1003 铺地毯
- P1047 校门外的树
- P1067 多项式输出

### 个人心得摘录
- **tanzexiaodezhonghao**：不建议开数组，开数组结果爆了。
总结：在处理数据时要注意数据范围，避免因数组越界等问题导致程序出错。 

---
处理用时：35.40秒
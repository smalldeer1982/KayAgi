# 题目信息

# Index and Maximum Value

## 题目描述

Index 在生日派对上收到了另一个整数数组 $a_1,a_2,\dots,a_n$。随后，她准备对这个数组进行一些操作。

形式化地，她决定对这个数组执行 $m$ 次操作。有两种操作类型：
- 第一种操作形如 $\texttt{+ l r}$。给定两个正整数 $l,r$，将所有满足 $1\le i\le n,l\le a_i\le r$ 的 $a_i$ 的值改为 $a_i+1$。
- 第二种操作形如 $\texttt{- l r}$。给定两个正整数 $l,r$，将所有满足 $1\le i\le n,l\le a_i\le r$ 的 $a_i$ 的值改为 $a_i-1$。

举个例子，如果给定的数组 $a$ 初始为 $[7,1,3,4,3]$，在执行操作 $\texttt{+ 2 4}$ 后，数组变为 $a=[7,1,4,5,4]$。然后，在执行操作 $\texttt{- 1 10}$ 后，数组变为 $a=[6,0,3,4,3]$。

Index 对 $a$ 数组的最大值很好奇。在每次操作之后，请告诉她 $a$ 数组中的最大值。

## 样例 #1

### 输入

```
5
5 5
1 2 3 2 1
+ 1 3
- 2 3
+ 1 2
+ 2 4
- 6 8
5 5
1 3 3 4 5
+ 1 4
+ 2 3
- 4 5
- 3 3
- 2 6
5 5
1 1 1 1 1
+ 2 3
- 4 5
+ 1 6
- 2 5
+ 1 8
1 1
1
- 1 1
1 1
1000000000
+ 1000000000 1000000000```

### 输出

```
4 4 4 5 5
5 5 4 4 3
1 1 2 1 2
0
1000000001```

# AI分析结果

### 题目内容（已为中文，无需翻译）
Index 在生日派对上收到了另一个整数数组 $a_1,a_2,\dots,a_n$。随后，她准备对这个数组进行一些操作。

形式化地，她决定对这个数组执行 $m$ 次操作。有两种操作类型：
- 第一种操作形如 $\texttt{+ l r}$。给定两个正整数 $l,r$，将所有满足 $1\le i\le n,l\le a_i\le r$ 的 $a_i$ 的值改为 $a_i+1$。
- 第二种操作形如 $\texttt{- l r}$。给定两个正整数 $l,r$，将所有满足 $1\le i\le n,l\le a_i\le r$ 的 $a_i$ 的值改为 $a_i-1$。

举个例子，如果给定的数组 $a$ 初始为 $[7,1,3,4,3]$，在执行操作 $\texttt{+ 2 4}$ 后，数组变为 $a=[7,1,4,5,4]$。然后，在执行操作 $\texttt{- 1 10}$ 后，数组变为 $a=[6,0,3,4,3]$。

Index 对 $a$ 数组的最大值很好奇。在每次操作之后，请告诉她 $a$ 数组中的最大值。

### 综合分析与结论
这些题解的核心思路高度一致，均是发现题目为“诈骗题”，无需对整个数组进行操作，仅需维护数组的最大值。因为小于最大值的数在操作过程中不会超过最大值，当它与最大值相等时会和最大值同步变化。

算法要点：
1. 读取数组，找出最大值。
2. 对每次操作，判断最大值是否在操作区间 $[l, r]$ 内，若是则根据操作类型对最大值进行加 1 或减 1 操作。
3. 输出每次操作后的最大值。

解决难点：主要在于突破常规思维，意识到只需关注最大值，避免对整个数组进行操作，从而降低时间复杂度。

### 所选题解
- **作者：wangzhaohan2910（5星）**
    - 关键亮点：思路清晰，代码简洁，使用 `#define int long long` 避免了数据类型的一些潜在问题。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int r[100005];
signed main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,m,maxn{};
        cin>>n>>m;
        for(int i{1};i<=n;i++)
        {
            cin>>r[i];
            if(r[i]>maxn)
                maxn=r[i];
        }
        while(m--)
        {
            char c;
            int l,r;
            cin>>c>>l>>r;
            if(l<=maxn&&r>=maxn)
                if(c=='+')
                    maxn++;
                else
                    maxn--;
            cout<<maxn<<' ';
        }
        cout<<endl;
    }
    return 0;
}
```
核心实现思想：先找出数组的最大值，然后对每次操作判断最大值是否在操作区间内，若在则更新最大值，最后输出每次操作后的最大值。

- **作者：Lfz312g（4星）**
    - 关键亮点：代码结构清晰，将核心逻辑封装在 `solve` 函数中，提高了代码的可读性和可维护性。
    - 核心代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
void solve()
{
    int n,m;
    ll mx=-1;
    cin>>n>>m;
    for (int i=1;i<=n;i++) 
    {
        ll x;
        cin>>x;
        mx=max(mx,x);
    }
    while (m--)
    {
        char opt;
        int l,r;
        cin>>opt>>l>>r;
        if (mx>=l&&mx<=r) 
        {
            mx+=(opt=='+'?1:-1);
        }
        cout<<mx<<" ";
    }
    putchar('\n');
}
int main()
{
    int t;
    cin>>t;
    while (t--) solve();
    return 0;
}
```
核心实现思想：在 `solve` 函数中，先找出数组最大值，再根据操作更新最大值并输出。

- **作者：chenxi2009（4星）**
    - 关键亮点：使用 `scanf` 和 `printf` 进行输入输出，在处理大量数据时可能有更好的性能。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,a[100001],mx,l,r;
char c;
int main(){
    scanf("%d",&T);
    while(T --){
        scanf("%d%d",&n,&m);
        mx = 0;
        for(int i = 1;i <= n;i ++){
            scanf("%d",&a[i]);
            mx = max(mx,a[i]);
        }
        for(int i = 1;i <= m;i ++){
            c = 0;
            while(c!= '+' && c!= '-'){
                c = getchar();
            }
            scanf("%d%d",&l,&r);
            if(l <= mx && r >= mx){
                mx += c == '+'? 1 : -1;
            }
            printf("%d ",mx);
        }
        printf("\n");
    }
    return 0;
}
```
核心实现思想：通过 `scanf` 读取输入数据，找出最大值，根据操作更新最大值并使用 `printf` 输出。

### 最优关键思路或技巧
突破常规思维，不直接对整个数组进行操作，而是抓住问题的关键——最大值，避免了不必要的计算，将时间复杂度从 $O(\sum n \times \sum m)$ 降低到 $O(\sum n+\sum m)$。

### 可拓展之处
同类型题或类似算法套路：
- 对于一些涉及区间操作且只关注特定统计量（如最大值、最小值、总和等）的题目，可以考虑只维护关键信息，避免对整个数据结构进行操作。
- 可以拓展到多维数组或其他数据结构的区间操作问题，同样尝试找出关键信息进行维护。

### 推荐洛谷题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察对数组中连续子段最大值的求解，需要维护当前子段和与最大子段和。
2. [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)：涉及对数组元素的分类统计和计算，需要找出关键的统计量进行维护。
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)：二维数组的区间操作问题，需要将问题转化为一维问题，维护关键信息求解最大加权矩形。

### 个人心得摘录与总结
- **作者：mc_xiexie**：注意操作条件是 $1\le i\le n,l\le a_i\le r$，这一点可能会导致解题时出错，需要仔细审题。总结：在解题过程中要认真阅读题目条件，避免因粗心导致错误。 

---
处理用时：37.49秒
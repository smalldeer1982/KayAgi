# 题目信息

# Opponents

## 题目描述

# 问题描述

小白有 n 个对手，他每天都要和这些对手PK。对于每一天，如果 n 个对手全部到齐，那么小白就输了一场，否则小白就赢了一场。特别的，如果某天一个对手都没有到，也算小白赢。现在已知对手 d 天的出场情况，请计算小白最多能连胜多少场。

## 样例 #1

### 输入

```
2 2
10
00
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 1
0100
```

### 输出

```
1
```

## 样例 #3

### 输入

```
4 5
1101
1111
0110
1011
1111
```

### 输出

```
2
```

# AI分析结果

### 题解综合分析与结论
这些题解核心思路一致，都是通过遍历每天对手的出场情况，判断当天胜负，连胜则累加连胜场次，失败则清零，同时更新最大连胜场次。但在判断胜负和代码实现上有差异。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|Register|用变量记录当前和最高连胜，遍历每天情况，有 0 则当前连胜加 1 并更新最高连胜，否则当前连胜清零|贪心，类似最大子段和|判断当天胜负|4 星|
|judgejudge|将每天情况转换为胜负形式，用字符串 find 函数查找是否有 0 来判断胜负，连胜则累加，失败则清零并更新最大值|字符串 find 函数|判断胜负|3 星|
|LevenKoko|读入数据并计算每行和，全为 1 记为 0，否则记为 1，遍历统计连续 1 的长度并更新答案|模拟|判断胜负和统计连续 1 的长度|3 星|
|ZolaWatle|边读入字符串边判断是否全为 1，有 0 则增加连胜，全为 1 则更新答案并清零连胜，最后再更新一次答案|字符串遍历|判断胜负和处理最后可能的连胜|3 星|
|_Qer|用数组存每天结果，通过按位与计算当天结果，遍历数组统计连胜并更新答案|按位与|判断胜负和处理最后可能的连胜|3 星|

### 所选题解
- **Register（4 星）**
    - **关键亮点**：思路清晰，代码简洁，使用贪心思想，类似最大子段和，易于理解。
    - **核心代码**：
```cpp
int maxn=0/*最高连胜*/,d,n,sum=0/*当前连胜*/;
char t;
cin>>n>>d;
while(d--)
{
    bool flag=false;//判断是否胜利
    for(int i=1;i<=n;i++)
    {
        cin>>t;
        if(t=='0') flag=true;//有0就一定赢了
    }
    if(flag) {sum++;maxn=max(sum,maxn);}//更新当前or最高连胜
    else sum=0;//输了，当前连胜清零
}
cout<<maxn<<endl;
```

### 最优关键思路或技巧
使用贪心思想，类似最大子段和，用两个变量分别记录当前连胜和最高连胜，遍历每天情况，根据胜负更新变量。

### 拓展思路
同类型题可考察连续某种状态的最大长度，如连续正数和、连续上升子序列等，算法套路都是遍历过程中记录当前状态和最大状态。

### 洛谷相似题目推荐
1. P1115 最大子段和
2. P1719 最大加权矩形
3. P2671 [NOIP2015 普及组] 求和

### 个人心得摘录与总结
- **_Qer**：提到 n 和 d 不按常理出牌，容易踩坑，做题时要注意输入变量的含义。同时提到按位与表达式执行顺序问题，使用时要注意。
- **ZolaWatle**：提醒全部读完输入后可能还会积累连胜场数，要记得最后更新一次答案。 

---
处理用时：17.77秒
# 题目信息

# Product of Binary Decimals

## 题目描述

### 二进制小数的乘积
我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，你被要求判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

## 说明/提示

前五个测试用例可以表示为二进制小数的乘积如下：

$121 = 11 \times 11$
$1 = 1$ 已经是一个二进制小数。
$14641 = 11 \times 11 \times 11 \times 11$
$12221 = 11 \times 11 \times 101$
$10110 = 10110$ 已经是一个二进制小数。

## 样例 #1

### 输入

```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001```

### 输出

```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES```

# AI分析结果



### 题目内容重写
# 二进制小数的乘积

## 题目描述
我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

## 说明/提示
前五个测试用例的分解方式如下：
- $121 = 11 \times 11$
- $1 = 1$（本身就是二进制小数）
- $14641 = 11 \times 11 \times 11 \times 11$
- $12221 = 11 \times 11 \times 101$
- $10110 = 10110$（本身就是二进制小数）

## 样例输入与输出
输入：
```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001
```
输出：
```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES
```

---

### 题解对比与最优思路

#### 共同核心思路
1. **预处理所有二进制小数**：生成所有可能的01数（如10, 11, 100, 101等）。
2. **因数分解**：尝试将输入数分解为这些01数的乘积，通过递归或迭代检查所有可能的分解方式。

#### 关键技巧
- **DFS分解**：深度优先搜索尝试所有可能的01数因子。
- **动态规划预处理**：预先计算每个数是否能被分解，优化查询效率。
- **剪枝优化**：按从大到小的顺序尝试因子，减少递归深度。

---

### 高星题解推荐

#### 题解1：Pink_Cut_Tree（4星）
**亮点**：  
- 显式列出所有可能的01数，覆盖范围全面。
- DFS递归分解逻辑清晰，直接处理整除情况。

**核心代码**：
```cpp
int b[] = {10,11,100,101,...,11111}; // 所有可能的01数
void dfs(int x) {
    if (x == 1) { ans = 1; return; }
    for (int i = 0; i < 30; i++) {
        if (x % b[i] == 0) dfs(x / b[i]);
    }
}
```
**思想**：枚举预处理的01数作为因子，递归分解直至得到1。

#### 题解2：minVan（4星）
**亮点**：  
- 预处理所有数的可行性，查询时O(1)响应。
- 利用因子分解性质，通过动态规划递推。

**核心代码**：
```cpp
bool vis[N]; // 标记数是否可分解
for (int i = 1; i < N; i++) {
    if (check(i)) vis[i] = 1; // 自身是01数
    else {
        for (int j = 1; j*j <= i; j++) {
            if (i % j == 0 && vis[j] && vis[i/j]) 
                vis[i] = 1;
        }
    }
}
```
**思想**：检查每个数的因子是否均可分解，利用空间换时间。

---

### 拓展与总结
**关键优化点**：  
- 预处理范围需覆盖所有可能的01数（至n的最大值）。
- 分解时优先处理大因子，减少递归层数。

**相似题目推荐**：  
1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)  
2. [P1734 最大约数和](https://www.luogu.com.cn/problem/P1734)  
3. [P1876 开灯问题](https://www.luogu.com.cn/problem/P1876)

**心得总结**：  
- 预处理时需严格验证所有边界情况（如包含10）。
- 递归分解时注意终止条件和效率，避免无限循环。

---
处理用时：215.45秒
# 题目信息

# Replace Character

## 题目描述

给定一个长度为 $n$ 的字符串 $s$，只包含小写英文字母。

你只能进行一次如下操作：

- 选择任意两个下标 $i$ 和 $j$ ($1\le i,j\le n$)，允许选择 $i=j$。
- 将 $s_i$ 赋值为 $s_j$。

你需要最小化 $s$ 不同排列的个数。输出在一次操作后满足条件的任何一个字符串 $s$。

字符串的一个排列是打乱其字符顺序后形成的新字符串。比如 `bac` 是 `abc` 的一个排列，而 `bcc` 不是。

## 样例 #1

### 输入

```
6
3
abc
4
xyyx
8
alphabet
1
k
10
aabbccddee
6
ttbddq```

### 输出

```
cbc
yyyx
alphaaet
k
eabbccddee
tttddq```

# AI分析结果

### 题目内容
#### 替换字符

#### 题目描述
给定一个长度为 $n$ 的字符串 $s$，仅包含小写英文字母。
你只能进行一次如下操作：
- 选择任意两个下标 $i$ 和 $j$（$1\leq i,j\leq n$），允许 $i = j$。
- 将 $s_i$ 赋值为 $s_j$。
你需要最小化 $s$ 不同排列的个数。输出在一次操作后满足条件的任何一个字符串 $s$。
字符串的一个排列是打乱其字符顺序后形成的新字符串。例如，`bac` 是 `abc` 的一个排列，而 `bcc` 不是。

#### 样例 #1
##### 输入
```
6
3
abc
4
xyyx
8
alphabet
1
k
10
aabbccddee
6
ttbddq
```
##### 输出
```
cbc
yyyx
alphaaet
k
eabbccddee
tttddq
```

### 综合分析与结论
这些题解的核心目标都是通过一次操作让字符串的不同排列数最少。大部分题解采用贪心策略，即找出出现次数最多和最少的字符，把最少的字符替换为最多的字符；也有题解使用暴力枚举所有操作来找到最优解。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|封禁用户|让出现次数最多的字母“吃掉”出现次数最少的字母|用桶统计字符出现次数，找出最多和最少的字符|处理所有字符相同的情况|4星|
|nannangua|找出出现次数最多和最少的字母并替换|用数组统计字符出现次数，找出最多和最少的字符|处理特殊长度（1和2）的字符串|3星|
|hgcnxn|最大化排列数公式的分母，将出现次数最少的字符改为最多的字符|用结构体存储字符及其出现次数，排序后找出最多和最少的字符|确定最多和最少字符的位置|3星|
|Drifty|贪心让最大的 $n_i$ 加1，最小的 $n_j$ 减1|用向量统计字符出现次数，找出最多和最少的字符|处理最多和最少字符相同的情况|3星|
|HYdroKomide|暴力枚举所有赋值方法，计算排列数找最小值|枚举所有操作，用桶统计字符个数，根据排列公式计算排列数|避免重复计算排列数|2星|

### 所选题解
- **封禁用户（4星）**
    - **关键亮点**：思路清晰，代码简洁，对特殊情况处理得当。
    - **核心代码**：
```cpp
while(t--)
{
    cin >> n;
    memset(tong, 0, sizeof(tong));
    for(int i = 1 ; i <= n ; i++)
    {
        cin >> a[i];
        tong[a[i] - 'a']++;
    }
    maxt = mint = 0;
    maxp = -1;
    mint = 1000000007;
    for(int i = 0 ; i < 26 ; i++)
    {
        if(tong[i] > maxt)
        {
            maxt = tong[i];
            maxp = i;
        }
    }
    for(int i = 0 ; i < 26 ; i++)
    {
        if(!tong[i])
        {
            continue;
        }
        if(tong[i] <= mint)
        {
            mint = tong[i];
            minp = i;
        }
    }
    if(maxp == minp)
    {
        for(int i = 1 ; i <= n ; i++)
        {
            a[i] = minp + 'a';
        }
    }
    else
    {
        for(int i = 1 ; i <= n ; i++)
        {
            if(a[i] - 'a' == minp)
            {
                a[i] = maxp + 'a';
                break;
            }
        }
    }
    for(int i = 1 ; i <= n ; i++)
    {
        cout << a[i];
    }
    cout << '\n';
}
```
    - **核心实现思想**：用桶 `tong` 统计每个字符的出现次数，找出出现次数最多和最少的字符，若两者相同则将所有字符设为该字符，否则将第一个出现次数最少的字符替换为出现次数最多的字符。

### 最优关键思路或技巧
使用桶来统计字符出现次数，能高效找出出现次数最多和最少的字符，贪心策略让代码简洁且复杂度低。

### 可拓展之处
同类型题可能会增加操作次数限制、改变操作规则或对字符串有更多约束。类似算法套路可用于解决一些需要通过局部操作优化全局目标的问题，如通过交换元素让数组的某种特征最优。

### 推荐洛谷题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：贪心算法，通过合理分组使组数最少。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法，通过排序让总等待时间最少。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法，通过选择性价比最高的物品使总价值最大。

### 个人心得
- **封禁用户**：第一次打 [CF 比赛](https://codeforces.com/bestRatingChanges/15807442)，被 D 题虐了 awa。总结：首次参加比赛可能会遇到难题，需不断积累经验。 

---
处理用时：29.94秒
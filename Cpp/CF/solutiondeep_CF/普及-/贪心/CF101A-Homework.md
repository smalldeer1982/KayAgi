# 题目信息

# Homework

## 题目描述

Gerald在上学的一天，他的老师在班上布置了一项作业：她给每个同学一个有n个小写拉丁字母（即英文字母）的字符串，要求学生学习这个字符串中的字母的写法。但是，由于Gerald太懒了，他不想学习这些字母。这就是为什么他决定丢掉这个字符串的部分（不需要是连续的一部分）。他所丢失的部分可以由若干个任意长度在任意位置的连续的子字符串组成。但是，Gerald知道，如果他丢掉了超过k个字母，他就会显得非常可疑。

请求出在不超过k个字母被删除之后，字符串中最少剩下多少个不同的字母。你还需要求出一种删除这些字母的方式。

## 说明/提示

在第一个样例中这个字符串含有5个字母但是你只允许删去其中4个，所以会剩下至少一个字母。所以，正确答案就是1和任意一个长度在1到5的、只含有字母a的字符串。

在第二个杨立忠你可以删去4个字母。你不能删去所有的字母，因为这个字符串的长度是7。 但是，你可以删去所以除了a以外的字母（这样的字母不多于4个），所以得到的答案是"aaaa"。

在第三个样例中字符串的长度是8，且k=10，所以可以将所有的字母都删去。正确答案是0和空字符串。

Translated by @oolliivveerr

## 样例 #1

### 输入

```
aaaaa
4
```

### 输出

```
1
aaaaa
```

## 样例 #2

### 输入

```
abacaba
4
```

### 输出

```
1
aaaa
```

## 样例 #3

### 输入

```
abcdefgh
10
```

### 输出

```
0

```

# AI分析结果



# 中文题目重写

## 题目描述

Gerald 的作业是学习老师给定的一个由 n 个小写字母组成的字符串。他可以通过删除任意多个（可以是零个）不连续的子串来减少需要学习的字母数量，但删除的字母总数不能超过 k 个。请求出在满足删除限制的情况下，字符串中剩余字母种类的最小可能值，并给出一种可行的删除方案。

## 输入输出样例

样例1：
输入：
```
aaaaa
4
```
输出：
```
1
aaaaa

样例2：
输入：
abacaba
4
输出：
1
aaaa

样例3：
输入：
abcdefgh
10
输出：
0
（空字符串）
```

## 综合题解分析

### 关键算法思路
所有题解均采用**贪心策略**：
1. 统计各字符出现次数
2. 按出现次数升序排序
3. 优先删除出现次数少的字符类型，直至无法完全删除某类字符
4. 处理边界情况（k ≥ 总长度时返回空串）

### 最优题解推荐

#### 题解1：小恐（4.5星）
**核心亮点**：
- 结构体清晰记录字符与出现次数
- 正确处理字符串结束符'\0'
- 输出时保留原字符顺序

**关键代码**：
```cpp
struct node {
    int cnt;    // 出现次数
    char ch;    // 对应字符
} f[30];

// 统计字符出现次数
for(int i=0;a[i]!='\0';i++) 
    ++f[a[i]-'a'].cnt;

// 贪心删除
for(int i=start;i<26;i++) {
    if(f[i].cnt > k) break;
    book[f[i].ch-'a'] = 1; // 标记要删除的字符
    k -= f[i].cnt;
}
```

#### 题解2：Astatinear（4星）
**核心亮点**：
- 使用结构体数组存储字符信息
- 双重循环实现冒泡排序
- 输出时动态维护剩余字符数量

**关键实现**：
```cpp
struct Node {
    char val;
    int num;
} t[N];

// 冒泡排序字符出现次数
for(int j=0;j<i-1;j++) {
    for(int k=j;k<i;k++) {
        if(its[j]->second > its[k]->second)
            swap(its[j], its[k]);
    }
}

// 输出保留字符
for(int i=0;i<s.size();i++) {
    if(t1[s[i]-'a'+1] > 0) {
        cout << s[i];
        t1[s[i]-'a'+1]--;
    }
}
```

#### 题解3：happybob（4星）
**独特技巧**：
- 使用STL map统计字符频率
- 转换为vector后排序
- 利用string::find快速判断删除字符

**代码亮点**：
```cpp
vector<pair<char, int>> vec(mp.begin(), mp.end());
sort(vec.begin(), vec.end(), cmp);

// 输出时保留原顺序
for(char c : s) {
    if(tmp.find(c) == string::npos)
        cout << c;
}
```

## 同类题目推荐
1. P1090 [NOIP2004 提高组] 合并果子（贪心+优先队列）
2. P1607 [USACO09FEB] Fair Shuttle G（区间贪心）
3. P2679 [NOIP2015 提高组] 子串（字符串DP）

## 调试经验总结
1. **边界处理**：多个题解提到需要特殊处理k≥字符串长度的情况（直接返回空串）
2. **排序稳定性**：部分题解使用冒泡排序而非STL sort，虽效率较低但易于调试
3. **输出顺序保留**：需注意题目要求保留原字符串顺序，不能在处理时打乱字符顺序

## 核心代码模板
```cpp
// 统计字符频率
int cnt[26] = {0};
for(char c : s) cnt[c-'a']++;

// 创建索引数组并排序
vector<int> idx(26);
iota(idx.begin(), idx.end(), 0);
sort(idx.begin(), idx.end(), [&](int a,int b){ 
    return cnt[a] < cnt[b]; 
});

// 贪心删除
vector<bool> del(26);
int remain = 0;
for(int i : idx) {
    if(cnt[i] <= k) {
        k -= cnt[i];
        del[i] = true;
    } else {
        remain++;
    }
}

// 构造结果
string res;
for(char c : s) {
    if(!del[c-'a']) res += c;
}
```

---
处理用时：47.18秒
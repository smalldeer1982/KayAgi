# 题目信息

# Red Versus Blue

## 题目描述

红队和蓝队进行了一场比赛，这场比赛分为了 $n$ 个阶段。

已知比赛中红队获胜的阶段数 $r$ 以及蓝队获胜的阶段数 $b$，由于蓝队实力不如红队，满足 $b<r$。你错过了这场比赛，想知道每个阶段的获胜队伍。

你用一个长 $n$ 的字符串来表示每个阶段的获胜队伍。具体地，将每一个阶段的获胜队伍连起来形成一个字符串，这个字符串的第 $i$ 位若为 $R$ 则表示红队赢了第 $i$ 个阶段，为 $B$ 则表示蓝队赢了这个阶段。你认为为了让比赛更有看头，某个队伍连续获胜的阶段数越少越好。

请输出一种可能的字符串，其中每一队连续获胜的阶段数的最大值最小，若有多解输出任意一种。

## 样例 #1

### 输入

```
3
7 4 3
6 5 1
19 13 6```

### 输出

```
RBRBRBR
RRRBRR
RRBRRBRRBRRBRRBRRBR```

## 样例 #2

### 输入

```
6
3 2 1
10 6 4
11 6 5
10 9 1
10 8 2
11 9 2```

### 输出

```
RBR
RRBRBRBRBR
RBRBRBRBRBR
RRRRRBRRRR
RRRBRRRBRR
RRRBRRRBRRR```

# AI分析结果



# Red Versus Blue

## 题目描述

红队和蓝队进行了一场比赛，这场比赛分为 $n$ 个阶段。

已知比赛中红队获胜的阶段数 $r$ 以及蓝队获胜的阶段数 $b$，由于蓝队实力不如红队，满足 $b<r$。你错过了这场比赛，想知道每个阶段的获胜队伍。

你用一个长 $n$ 的字符串来表示每个阶段的获胜队伍。具体地，将每一个阶段的获胜队伍连起来形成一个字符串，这个字符串的第 $i$ 位若为 `R` 则表示红队赢了第 $i$ 个阶段，为 `B` 则表示蓝队赢了这个阶段。为了让比赛更有看头，需要使得某个队伍连续获胜的阶段数的最大值尽可能小。

请输出一种可能的字符串，若有多解输出任意一种。

---

## 题解分析与结论

### 核心思路
1. **分割策略**：用 $b$ 个 `B` 将 $r$ 个 `R` 分割为 $b+1$ 段，确保最大连续 `R` 最小。
2. **均匀分配**：每段基础长度为 $\lfloor \frac{r}{b+1} \rfloor$，余数 $y = r \bmod (b+1)$ 分配给前 $y$ 段各多一个 `R`。
3. **交替构造**：按顺序输出各段 `R` 后插入 `B`，最后一组 `R` 后无 `B`。

### 最优题解

#### 题解作者：wdgm4（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**  
- 直观的整除与余数计算，代码简洁高效。
- 动态减少余数变量，避免复杂的条件判断。

**核心代码**  
```cpp
int nem = b + 1;
int nem1 = r / nem;
int nem2 = r % nem;
for (int j = 1; j <= nem; j++) {
    for (int k = 1; k <= nem1; k++) printf("R");
    if (nem2) { printf("R"); nem2--; }
    if (j != nem) printf("B");
}
```

---

#### 题解作者：___cjy__（⭐️⭐️⭐️⭐️）
**关键亮点**  
- 分两阶段处理余数和基础段，逻辑清晰。
- 显式处理最后一组避免多余分隔符。

**核心代码**  
```cpp
int x = r / (b + 1), k = r % (b + 1);
for (int i = 1; i <= k; i++) {
    for (int j = 1; j <= x + 1; j++) cout << "R";
    cout << "B";
}
for (int i = k + 1; i < b + 1; i++) {
    for (int j = 1; j <= x; j++) cout << "R";
    cout << "B";
}
for (int i = 1; i <= x; i++) cout << "R";
```

---

#### 题解作者：Terry2011（⭐️⭐️⭐️⭐️）
**关键亮点**  
- 利用循环条件直接判断余数分配，减少变量。
- 紧凑的代码结构，适合快速实现。

**核心代码**  
```cpp
for (int j = 1; j <= b + 1; j++) {
    for (int k = 1; k <= r / (b + 1); k++) cout << "R";
    if (r % (b + 1) >= j) cout << "R";
    if (j <= b) cout << "B";
}
```

---

### 关键技巧总结
1. **余数优先分配**：将多余的 `R` 分配给前 $y$ 段，保证最大值最小。
2. **循环边界处理**：最后一组 `R` 后不加 `B`，避免格式错误。
3. **数学建模**：将问题转化为整除和余数的均匀分配问题。

### 拓展应用
- **同类问题**：资源平均分配（如分糖果、任务调度）。
- **类似题目**：  
  1. [CF1526B - Minimum Value](https://codeforces.com/problemset/problem/1526/B)  
  2. [洛谷 P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)（均匀分段思想）  
  3. [LeetCode 621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)（间隔分配优化）

### 个人心得摘录
> "在调试中发现，余数分配的顺序直接影响最大连续段长度。若错误地将余数分散到所有段，会导致总长度超限。必须严格限制仅前 $y$ 段增加一个 `R`。"  
> —— 摘自作者调试经验

---
处理用时：107.88秒
# 题目信息

# Two 0-1 Sequences

## 题目描述

你有两个 $01$ 串 $a$ 和 $b$，每次你可以对 $a$ 串进行以下两种操作（以下 $a_1$ 表示 $a$ 现在的第一个字符，$a_2$ 表示 $a$ 现在的第二个字符，以此类推）：

1. 若 $|a| \geq 2$，则可将 $a_2$ 改为 $\min(a_1,a_2)$，然后删除 $a_1$。
2. 若 $|a| \geq 2$，则可将 $a_2$ 改为 $\max(a_1,a_2)$，然后删除 $a_1$。

显然，删除 $a_1$ 后，原先的 $a_2$ 变成 $a_1$，$a_3$ 变成 $a_2$，$a$ 的长度减少 $1$。

试判断 $a$ 是否能够经过若干次操作（也可以不进行操作）变成 $b$。

## 样例 #1

### 输入

```
10
6 2
001001
11
6 2
110111
01
6 2
000001
11
6 2
111111
01
8 5
10000101
11010
7 4
1010001
1001
8 6
01010010
010010
8 4
01010101
1001
8 4
10101010
0110
7 5
1011100
11100```

### 输出

```
YES
YES
NO
NO
NO
YES
YES
NO
NO
YES```

# AI分析结果



### 题目重述

# Two 0-1 Sequences

## 题目描述

你有两个 $01$ 串 $a$ 和 $b$，每次你可以对 $a$ 串进行以下两种操作（以下 $a_1$ 表示 $a$ 现在的第一个字符，$a_2$ 表示 $a$ 现在的第二个字符，以此类推）：

1. 若 $|a| \geq 2$，则可将 $a_2$ 改为 $\min(a_1,a_2)$，然后删除 $a_1$。
2. 若 $|a| \geq 2$，则可将 $a_2$ 改为 $\max(a_1,a_2)$，然后删除 $a_1$。

显然，删除 $a_1$ 后，原先的 $a_2$ 变成 $a_1$，$a_3$ 变成 $a_2$，$a$ 的长度减少 $1$。

试判断 $a$ 是否能够经过若干次操作（也可以不进行操作）变成 $b$。

---

### 题解对比与结论

#### 核心思路总结
1. **后缀匹配**：$a$ 的最后 $m-1$ 个字符必须与 $b$ 的从第 2 个字符开始的子串完全一致。
2. **前缀存在性**：$a$ 的前 $n-m+1$ 个字符中必须存在至少一个字符等于 $b$ 的第一个字符。
3. **长度约束**：若 $n < m$，直接无法操作。

#### 评分较高的题解

1. **Lyrella（4星）**
   - **关键亮点**：逻辑简洁，直接遍历对比后缀，再检查前缀存在性；代码可读性强，处理边界条件清晰。
   - **代码片段**：
     ```cpp
     for (int i = strlen(a + 1), j = strlen(b + 1); j > 1; j--, i--)
         if (a[i] != b[j]) fl = false;
     for (int i = 1; i <= n - m + 1; i++)
         if (a[i] == b[1]) fl = true;
     ```

2. **happy_dengziyue（4星）**
   - **关键亮点**：代码简洁，利用双指针同时遍历 $a$ 和 $b$ 的后缀部分，高效判断匹配。
   - **代码片段**：
     ```cpp
     for (int i = n - m + 1, j = 1; j < m; i++, j++)
         if (a[i] != b[j]) ans = false;
     for (int i = 0; i <= n - m; i++)
         if (a[i] == b[0]) ans = true;
     ```

3. **Failure_Terminator（4星）**
   - **关键亮点**：代码逻辑清晰，通过分段判断提升可读性，直接返回结果避免冗余标记。
   - **代码片段**：
     ```cpp
     for (int i = n; i >= n - m + 2; i--)
         if (a[i] != b[i - n + m]) return false;
     for (int i = 0; i <= n - m; i++)
         if (a[i] == b[0]) return true;
     ```

---

### 关键技巧与拓展
1. **双指针后缀匹配**：通过从尾部同步遍历 $a$ 和 $b$，快速验证不可变部分是否匹配。
2. **贪心前缀验证**：只需判断前缀中是否存在目标字符，无需模拟具体操作。
3. **边界处理**：单独处理 $n < m$ 的情况，避免无效计算。

#### 相似题目推荐
1. [CF1352G - Special Permutation](https://codeforces.com/problemset/problem/1352/G)（构造性思维）
2. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)（贪心策略）
3. [CF977D - Divide by Three](https://codeforces.com/problemset/problem/977/D)（序列转换分析）

---
处理用时：145.07秒
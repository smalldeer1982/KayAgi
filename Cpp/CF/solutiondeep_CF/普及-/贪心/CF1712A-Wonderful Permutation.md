# 题目信息

# Wonderful Permutation

## 题目描述

## 题意描述

给你一个 $n$ 的排列 $p_i$ 以及 $k (k \le n)$。

在一次操作中，你可以选择两个编号 $i,j$ 并且交换 $p_i,p_j$。

求最少需要几次操作才能使 $\sum\limits_{i=1}\limits^{k} p_i$ 的值最小。

排列是指由 $n$ 个 $1$ 到 $n$ 的不同整数按任意顺序组成的序列，序列中不能有重复的数字，也不能有大于 $n$ 的数。

## 样例 #1

### 输入

```
4
3 1
2 3 1
3 3
1 2 3
4 2
3 4 1 2
1 1
1```

### 输出

```
1
0
2
0```

# AI分析结果



# Wonderful Permutation

## 题目描述

给你一个 $n$ 的排列 $p_i$ 以及 $k (k \le n)$。

在一次操作中，你可以选择两个编号 $i,j$ 并且交换 $p_i,p_j$。

求最少需要几次操作才能使 $\sum\limits_{i=1}\limits^{k} p_i$ 的值最小。

排列是指由 $n$ 个 $1$ 到 $n$ 的不同整数按任意顺序组成的序列，序列中不能有重复的数字，也不能有大于 $n$ 的数。

## 样例 #1

### 输入
```
4
3 1
2 3 1
3 3
1 2 3
4 2
3 4 1 2
1 1
1
```

### 输出
```
1
0
2
0
```

---

## 题解综合分析

### 最优解法总结
**核心思路**：统计前k个元素中大于k的元素数量。每个这样的元素必然需要一次交换，将其与后面的小值元素调换。时间复杂度O(k)，空间复杂度O(1)。

**关键证明**：排列中1~k的值必须出现在前k位，且每个不满足条件的元素总能找到对应的交换目标。

---

## 精选题解（评分≥4⭐）

### 1. heptari（5⭐）
**亮点**：代码最简，时间复杂度最优，直接统计前k元素中的违规项  
**核心代码**：
```cpp
for (long long i = 0; i < K; i++)
    if(arr[i]>K) ans++;
```

### 2. FQR_（5⭐）
**亮点**：注释清晰，变量命名规范  
**代码片段**：
```cpp
for(int i=1;i<=k;i++)
    if(a[i]>k) ans++;
```

### 3. sgl654321（4⭐）
**亮点**：包含数学推导过程，解释完整  
**心得摘录**："问题转化为求前k个元素中大于k的个数"

---

## 关键代码实现
```cpp
void solve() {
    int n, k, ans = 0;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i=0; i<n; i++) cin >> arr[i];
    
    for (int i=0; i<k; i++) 
        if (arr[i] > k) ans++;
    
    cout << ans << "\n";
}
```

---

## 拓展与相似题目
1. **P1969 [NOIP2013 提高组] 积木大赛**（贪心策略）  
2. **P1106 删数问题**（最小化序列的贪心思想）  
3. **CF1294C Product of Three Numbers**（排列元素选取与分解）

---
处理用时：43.10秒
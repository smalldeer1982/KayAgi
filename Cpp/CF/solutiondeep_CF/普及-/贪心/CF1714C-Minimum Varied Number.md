# 题目信息

# Minimum Varied Number

## 题目描述

找出数码和为 $s$ 的最小数字，使得其中的所有数字都是不同的（即所有数字都是唯一的）。

例如，如果 $s=20$ ，那么答案是 $389$。这是最小的数字，其中所有数字都不同，数字的总和为 $20$ （$3+8+9=20$）。

对于给定的 $s$ ，输出这个最小数字。

## 样例 #1

### 输入

```
4
20
8
45
10```

### 输出

```
389
8
123456789
19```

# AI分析结果



# Minimum Varied Number

## 题目描述

找出数码和为 $s$ 的最小数字，使得其中的所有数字都是不同的（即所有数字都是唯一的）。

例如，如果 $s=20$，那么答案是 $389$。这是最小的数字，其中所有数字都不同，数字的总和为 $20$（$3+8+9=20$）。

对于给定的 $s$，输出这个最小数字。

## 样例 #1

### 输入

```
4
20
8
45
10
```

### 输出

```
389
8
123456789
19
```

---

## 题解分析与结论

### 核心思路
1. **贪心策略**：从高位到低位尽可能选取大的数字，确保总位数最少。最后将选择的数字按升序排列以保证数值最小。
2. **关键技巧**：从9到1倒序选择数字，能选则选，剩余数值填入高位。最终逆序输出构造的数字序列。

### 精选题解

#### 1. FQR_（4星）
**亮点**：直接构造逆序字符串后翻转，代码简洁高效。
- 从9到1遍历，尽可能填入大数
- 剩余值填入首位后跳出循环
- 最后逆序输出字符串保证高位最小

```cpp
string ans;
for(int i=9; i>=1; i--) {
    if(s > i) {
        ans += (i + '0');
        s -= i;
    } else {
        ans += (s + '0');
        break;
    }
}
reverse(ans.begin(), ans.end());
```

#### 2. Qerucy（4星）
**亮点**：数组存储后倒序输出，逻辑清晰易理解。
- 使用数组记录选择的数字
- 倒序遍历数组实现升序排列

```cpp
int cnt = 0;
for(int i=9; i>=1; i--) {
    if(n >= i) {
        a[++cnt] = i;
        n -= i;
    }
}
for(int i=cnt; i>=1; i--) cout << a[i];
```

#### 3. zhicheng（4星）
**亮点**：栈结构存储数字，自然实现倒序输出。
- 利用栈先进后出特性
- 遍历时直接输出栈顶元素

```cpp
stack<int> st;
for(int i=9; i>=1; i--) {
    if(s >= i) {
        st.push(i);
        s -= i;
    }
}
while(!st.empty()) {
    cout << st.top();
    st.pop();
}
```

---

## 最优思路总结
1. **位数最小优先**：通过从大到小选择数字，快速逼近目标值，减少总位数。
2. **高位最小化**：将最后剩余的小数值放在最高位，大数值集中在低位，通过逆序输出实现整体最小。
3. **数据结构选择**：灵活使用字符串翻转、栈结构或数组倒序实现最终排列。

---

## 相似题目推荐
1. [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098) - 字符串处理与规则应用
2. [P1239 计数器](https://www.luogu.com.cn/problem/P1239) - 数字构造与组合数学
3. [P2602 数字计数](https://www.luogu.com.cn/problem/P2602) - 数位统计与DP应用

---
处理用时：45.92秒
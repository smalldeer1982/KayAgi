# 题目信息

# New Bakery

## 题目描述

### 题意

有一个长度为 $n$ 的数列和两个常数 $a,b$ 以及一个正整数 $k(1 \leq k \leq n)$，数列按以下方式构造：

- 对于前 $k$ 项，第 $i$ 项的值为 $b-i+1$；
- 对于剩下的项，每一项的值都为 $a$。

整数 $k$ 的值由你决定，但你需要保证数列中所有的项均为**非负整数**。在此条件下，你需要求出这个数列的和的最大值。

## 样例 #1

### 输入

```
7
4 4 5
5 5 9
10 10 5
5 5 11
1000000000 1000000000 1000000000
1000000000 1000000000 1
1000 1 1000```

### 输出

```
17
35
100
45
1000000000000000000
1000000000000000000
500500```

# AI分析结果



### 题目翻译

#### 题目描述

**题意**

有一个长度为 $n$ 的数列和两个常数 $a, b$ 以及一个正整数 $k$（$1 \leq k \leq n$）。数列构造方式如下：

- 前 $k$ 项的值为 $b - i + 1$（$i$ 为项的位置）；
- 剩余项的值为 $a$。

你需要选择一个合适的 $k$，使得数列中所有项均为**非负整数**，并求数列和的最大值。

### 题解分析与结论

#### 关键思路总结

1. **分类讨论**：当 $a \ge b$ 时，所有项选择 $a$ 最优，总和为 $n \cdot a$。
2. **贪心策略**：当 $a < b$ 时，尽可能选择前 $k$ 项构造等差数列（项值递减），剩余项为 $a$。最大可行的 $k$ 满足两个条件：
   - 所有前 $k$ 项非负，即 $k \le b$；
   - 等差数列的最后一项尽可能大，即 $k \le b - a$（保证前 $k$ 项均大于等于 $a$）。
3. **数学优化**：总和公式为等差数列求和（首项 $b$，末项 $b - k + 1$）加剩余项的总和。直接代入公式计算即可。

#### 最优代码实现

```cpp
#include <iostream>
using namespace std;
#define ll long long

int main() {
    ll T, n, a, b;
    cin >> T;
    while (T--) {
        cin >> n >> a >> b;
        ll k = min(n, b - a);
        ll ans;
        if (a >= b) {
            ans = n * a;
        } else {
            ans = (2 * b + 1 - k) * k / 2 + (n - k) * a;
        }
        cout << ans << endl;
    }
    return 0;
}
```

#### 关键代码说明

- **分类处理**：直接判断 $a$ 和 $b$ 的大小关系。
- **贪心取值**：$k$ 取 `min(n, b - a)`，确保前 $k$ 项均大于等于 $a$。
- **等差数列求和**：公式为 $\frac{(2b - k + 1) \cdot k}{2}$，结合剩余项总和 $(n - k) \cdot a$。

### 推荐相似题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
   - 考察点：贪心或动态规划求最大子段和。
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
   - 考察点：贪心策略与数学优化。
3. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
   - 考察点：二分答案与贪心验证。

---
处理用时：356.44秒
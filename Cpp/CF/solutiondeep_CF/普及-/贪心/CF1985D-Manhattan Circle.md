# 题目信息

# Manhattan Circle

## 题目描述

给定一个由“.”和“#”字符组成的n*m的网格，网格上存在一个完整的曼哈顿圆。网格的左上角坐标为(1,1)
，右下角坐标为(n,m) 。
如果|h-a| +|k-b|<r，则点（a,b）属于以（h,k）为中心的曼哈顿圆，其中r是正常数。
在网格上，作为曼哈顿圆一部分的点集被标记为“#”。找到圆心的坐标。

## 样例 #1

### 输入

```
6
5 5
.....
.....
..#..
.....
.....
5 5
..#..
.###.
#####
.###.
..#..
5 6
......
......
.#....
###...
.#....
1 1
#
5 6
...#..
..###.
.#####
..###.
...#..
2 10
..........
...#......```

### 输出

```
3 3
3 3
4 2
1 1
3 4
2 4```

# AI分析结果



### 题目重写
给定一个由“.”和“#”字符组成的n*m的网格，网格上存在一个完整的曼哈顿圆。网格的左上角坐标为(1,1)，右下角坐标为(n,m)。曼哈顿圆的定义为：若点(a,b)满足|h-a| + |k-b| < r，则属于以(h,k)为中心的曼哈顿圆（r为正常数）。网格上属于曼哈顿圆的点标记为“#”，要求找到圆心的坐标。

---

### 题解综合分析与结论
**核心思路**：曼哈顿圆在网格中呈现菱形，圆心位于菱形中心。最优解法为找到**最长连续`#`行的中点**，或统计所有`#`覆盖的连续行/列的中间值。

#### 高分题解推荐
1. **BrotherCall 的题解（5星）**
   - **亮点**：思路清晰，代码简洁高效。直接遍历每行统计连续`#`的起止位置，计算中点。
   - **代码核心**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int now = 0, zq = 0, zh = 0;
         for (int j = 1; j <= m; j++) {
             if (ch[j] == '#') {
                 if (now == 0) zq = j; // 记录第一个#
                 now++, zh = j;        // 更新最后一个#
             }
         }
         if (now > maxx) {            // 更新最长行
             maxx = now;
             x = i;                   // 圆心行
             y = (zq + zh) / 2;       // 圆心列
         }
     }
     ```

2. **tanzexiaodezhonghao 的题解（4星）**
   - **亮点**：避免存储完整网格，实时处理每行数据，节省内存。
   - **代码核心**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int cnt = 0, starts = 0, ends = 0;
         for (int j = 1; j <= m; j++) {
             cin >> ch;
             if (ch == '#') {
                 if (cnt == 0) starts = j;
                 cnt++;
                 ends = j;
             }
         }
         if (cnt > maxans) {         // 更新最长行
             maxans = cnt;
             x = i;
             y = (starts + ends) / 2;
         }
     }
     ```

3. **int_stl 的题解（4星）**
   - **亮点**：通过边界点计算中点，适用于对称结构。
   - **代码核心**：
     ```cpp
     // 遍历找到上下左右边界的行/列
     int shang = 0, xia = 0, zuo = 0, you = 0;
     for (int i = 1; i <= n; i++) {
         bool has_hash = false;
         for (int j = 1; j <= m; j++) {
             if (grid[i][j] == '#') has_hash = true;
         }
         if (has_hash) shang = i;    // 上边界
     }
     // 类似方法找到下、左、右边界
     cout << (shang + xia) / 2 << " " << (zuo + you) / 2;
     ```

---

### 最优关键思路总结
1. **最长行中点法**：曼哈顿圆的最长行必为圆心所在行，且该行中点即圆心。
2. **边界中点法**：圆心是上下左右边界的中间点，适用于对称图形。
3. **行/列统计法**：统计所有`#`覆盖的连续行/列，取中间值。

---

### 拓展与相关题目
1. **举一反三**：曼哈顿距离相关题目常涉及对称性、连续区间性质，可结合滑动窗口或前缀和优化。
2. **推荐题目**：
   - [P2733 家的范围](https://www.luogu.com.cn/problem/P2733)（矩阵中找最大正方形）
   - [CF1111D Interactive Diamond](https://codeforces.com/problemset/problem/1111/D)（曼哈顿距离与交互）
   - [P3667 钻石收藏家](https://www.luogu.com.cn/problem/P3667)（滑动窗口找连续区间）

---

### 题解个人心得摘录
- **避免存储完整网格**：直接逐行处理可节省内存（如 tanzexiaodezhonghao 的代码）。
- **边界条件处理**：需确保遍历顺序正确，避免漏掉首尾边界（如 int_stl 的上下左右遍历）。

---
处理用时：181.13秒
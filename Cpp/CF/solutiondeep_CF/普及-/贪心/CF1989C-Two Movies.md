# 题目信息

# Two Movies

## 题目描述

一个公司发行了两部电影。现在有 $n$ 位观众，每个人都会看一部这个公司的电影。

每位观众都会对其看的电影进行评分，分数 $a_i,b_i\in\{-1，0，1\}$。电影的总评分是看了此电影的观众对此电影的评分总和。公司的最终得分是这两部电影的总评分的较小值。

已知这些观众对两部电影的评价，你需要给每个人推荐一部电影，使公司的最终得分最大。求这个最大值。

## 样例 #1

### 输入

```
4
2
-1 1
-1 -1
1
-1
-1
5
0 -1 1 0 1
-1 1 0 0 1
4
-1 -1 -1 1
-1 1 1 1```

### 输出

```
0
-1
1
1```

# AI分析结果



### 题目翻译
# 两场电影

## 题目描述

某公司发布了两部电影。现有 $n$ 位观众，每位观众会观看其中一部电影并进行评分，评分值 $a_i,b_i\in\{-1,0,1\}$。电影的总评分是观看该电影的观众评分之和。公司的最终得分为两部电影总评分中的较小值。

已知观众对两部电影的评分，你需要为每位观众推荐观看其中一部电影，使得公司的最终得分最大化。求该最大值。

## 样例 #1

### 输入

```
4
2
-1 1
-1 -1
1
-1
-1
5
0 -1 1 0 1
-1 1 0 0 1
4
-1 -1 -1 1
-1 1 1 1```

### 输出

```
0
-1
1
1```

---

### 题解综合分析

#### 核心思路
所有题解均采用贪心策略，核心思路分为两个阶段：
1. **差异处理阶段**：对于评分不同的观众（$a_i \neq b_i$），选择评分较高的一方累加到对应电影总分。
2. **平衡调整阶段**：对评分相同的观众（$a_i = b_i$ 且非零），通过动态调整使得较小总分尽可能增大，较大总分适当削减。

#### 关键技巧
- **分步贪心**：先处理能直接获得最优解的情况，再处理需要权衡的情况。
- **动态平衡**：通过比较当前总分动态决定相同评分的分配策略：
  - 对评分为1的观众：优先加给当前较小的总分
  - 对评分为-1的观众：优先从当前较大的总分扣除

#### 最优代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[200002], b[200002], c[200002];

int main() {
    int t; cin >> t;
    while(t--) {
        int n; cin >> n;
        for(int i=1; i<=n; i++) cin >> a[i];
        for(int i=1; i<=n; i++) cin >> b[i];
        int suma = 0, sumb = 0, s = 0;
        
        // 第一阶段：处理差异评分
        for(int i=1; i<=n; i++) {
            if(a[i] > b[i]) suma += a[i];
            else if(a[i] < b[i]) sumb += b[i];
            else if(a[i] != 0) c[++s] = a[i]; // 记录非零相同评分
        }
        
        // 第二阶段：平衡调整
        for(int i=1; i<=s; i++) {
            if(suma >= sumb) {
                if(c[i] == 1) sumb++;  // 提升较小值
                else suma--;           // 削减较大值
            } else {
                if(c[i] == 1) suma++;
                else sumb--;
            }
        }
        cout << min(suma, sumb) << "\n";
    }
    return 0;
}
```

#### 评分较高的题解
1. **Vct14（5星）**
   - 亮点：代码简洁清晰，通过数组缓存相同评分，逻辑分层明确。
   - 关键代码：动态调整时使用`suma >= sumb`判断，平衡策略直观有效。

2. **HuangBarry（4星）**
   - 亮点：分类统计相同评分数量，批量处理提升效率。
   - 代码片段：
     ```cpp
     while(sum1--) // 处理所有评分为1的相同情况
         if(movie1 <= movie2) movie1++; 
         else movie2++;
     ```

3. **gaomingyang101011（4星）**
   - 亮点：独立处理正负相同评分，代码可读性强。
   - 关键实现：使用两个计数器分别处理1和-1的批量调整。

---

### 拓展学习
1. **类似题目套路**：
   - 双目标优化问题（如LeetCode 2102. Sequentially Ordinal Rank Tracker）
   - 平衡类贪心问题（如洛谷P1094 纪念品分组）

2. **推荐练习**：
   - [CF1538C Number of Pairs](https://codeforces.com/problemset/problem/1538/C)（双指针+贪心）
   - [洛谷P1209 [USACO1.3]修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)（贪心策略选择）
   - [洛谷P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列维护平衡）

---

### 总结心得
- **调试经验**：多个题解提到要最后处理相同评分，因为前期选择会影响后续平衡策略的顺序。
- **关键顿悟**：当最终结果由两个值的较小值决定时，应该以缩小两者差距为优化方向。
- **易错点**：忘记排除$a_i=b_i=0$的情况（此时无论选择哪部都不会影响总分）。

---
处理用时：84.91秒
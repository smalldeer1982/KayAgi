# 题目信息

# AND Reconstruction

## 题目描述

给定一个由 $ n - 1 $ 个整数组成的数组 $ b $。

一个数组 $ a $ 被称为是“好的”当且仅当对于 $ 1 \le i \le n-1 $，都有 $ b_i = a_i \, \& \, a_{i + 1} $ 其中$ \& $ 表示[按位与运算](https://en.wikipedia.org/wiki/Bitwise_operation#AND)。

你的任务是构造一个“好的”数组，或输出 `-1` 表示不存在“好的”数组。

## 说明/提示

对于第一组样例，$ b = [1] $。一个可能的"好的"数组是 $ a=[5, 3] $。因为 $ a_1 \, \& \, a_2 = 5 \, \& \, 3 = 1 = b_1 $。

对于第二组样例，$ b = [2, 0] $。一个可能的"好的"数组是 $ a=[3, 2, 1] $。因为 $ a_1 \, \& \, a_2 = 3 \, \& \, 2 = 2 = b_1 $ and $ a_2 \, \& \, a_3 = 2 \, \& \, 1 = 0 = b_2 $。

对于第三组样例，$ b = [1, 2, 3] $。可以证明不存在"好的"数组，所以输出 `-1`。

对于第四组样例，$ b = [3, 5, 4, 2] $。一个可能的"好的"数组是 $ a=[3, 7, 5, 6, 3] $。

## 样例 #1

### 输入

```
4
2
1
3
2 0
4
1 2 3
5
3 5 4 2```

### 输出

```
5 3
3 2 1
-1
3 7 5 6 3```

# AI分析结果



# AND Reconstruction

## 题目描述

给定一个由 $n - 1$ 个整数组成的数组 $b$。

一个数组 $a$ 被称为是“好的”当且仅当对于 $1 \le i \le n-1$，都有 $b_i = a_i \, \& \, a_{i + 1} $，其中 $\&$ 表示[按位与运算](https://en.wikipedia.org/wiki/Bitwise_operation#AND)。

你的任务是构造一个“好的”数组，或输出 `-1` 表示不存在“好的”数组。

## 说明/提示

对于第一组样例，$ b = [1] $。一个可能的"好的"数组是 $ a=[5, 3] $。因为 $ a_1 \, \& \, a_2 = 5 \, \& \, 3 = 1 = b_1 $。

对于第二组样例，$ b = [2, 0] $。一个可能的"好的"数组是 $ a=[3, 2, 1] $。因为 $ a_1 \, \& \, a_2 = 3 \, \& \, 2 = 2 = b_1 $ 且 $ a_2 \, \& \, a_3 = 2 \, \& \, 1 = 0 = b_2 $。

对于第三组样例，$ b = [1, 2, 3] $。可以证明不存在"好的"数组，所以输出 `-1`。

对于第四组样例，$ b = [3, 5, 4, 2] $。一个可能的"好的"数组是 $ a=[3, 7, 5, 6, 3] $。

---

## 题解综合分析

### 核心思路
所有题解均基于按位与运算的性质：若 $b_i$ 的某二进制位为 1，则 $a_i$ 和 $a_{i+1}$ 对应位必须为 1。构造方法主要有两种：
1. **贪心构造**：令 $a_i = b_{i-1} \mid b_i$（首尾特殊处理），再验证结果。
2. **位填充法**：遍历每个二进制位，将 $b_i$ 的 1 位强制设置到 $a_i$ 和 $a_{i+1}$ 的对应位，最后验证。

### 关键难点
1. **边界处理**：首元素 $a_1$ 和末元素 $a_n$ 需要单独处理（如设为 $b_1$ 和 $b_{n-1}$）。
2. **结果验证**：构造后必须重新检查每个 $b_i$ 是否满足 $a_i \& a_{i+1} = b_i$。
3. **二进制位冲突**：当不同 $b_i$ 对同一位置的 $a_i$ 产生矛盾要求时需判无解。

---

## 高星题解推荐

### 1. 白鲟（⭐⭐⭐⭐⭐）
**亮点**：简洁的贪心构造 + 边界处理
```cpp
a[n] = 0; // 关键边界处理
b[1] = a[1];
for (int i = 2; i <= n; ++i) {
    b[i] = a[i] | a[i - 1]; // 核心构造
}
// 验证部分省略
```
**个人心得**：未正确处理边界时导致罚时（如将 $a[n]$ 初始化为 0）。

### 2. donnieguo（⭐⭐⭐⭐）
**亮点**：位填充法的清晰实现
```cpp
for (int i = 1; i < n; i++)
    for (int j = 0; j <= 30; j++)
        if (b[i] >> j & 1) 
            a[i] |= 1 << j, a[i + 1] |= 1 << j;
```
**总结**：通过双重循环直接设置每个二进制位，逻辑直观。

### 3. _ZHONGZIJIE0608_（⭐⭐⭐⭐）
**亮点**：极简的贪心实现
```cpp
c[1] = b[1];
for (int i = 2; i < n; ++i) c[i] = (b[i] | b[i - 1]);
c[n] = b[n - 1];
```
**总结**：仅用 10 行核心代码完成构造与验证，时间复杂度 $O(n)$。

---

## 最优技巧总结
1. **贪心构造**：$a_i = b_{i-1} \mid b_i$ 是最高效的构造方式，能最小化 $a_i$ 的二进制位数。
2. **统一验证**：构造后必须遍历验证每个 $b_i$，时间复杂度 $O(n)$。
3. **位运算优先级**：注意运算符优先级（如 `>>` 和 `&` 需加括号）。

---

## 拓展练习
1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)（位运算贪心）
2. [P1879 [USACO06NOV] Corn Fields G](https://www.luogu.com.cn/problem/P1879)（状态压缩+位运算）
3. [P4317 花神的数论题](https://www.luogu.com.cn/problem/P4317)（数位DP+位运算性质）

---
处理用时：58.46秒
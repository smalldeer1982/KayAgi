# 题目信息

# Parity and Sum

## 题目描述

给定一个包含 $n$ 个整数的数组 $a$。

每次操作中，你可以选择任意一个数对 $(i,j)$，使得 $a_i$ 和 $a_j$ 奇偶性不同，即 $a_i$ 和 $a_j$ 既不同为奇数也不同为偶数。然后将 $a_i$ 和 $a_j$ 中值较小的那一个的元素的值替换为这两个元素的和，即：

- 如果 $a_i<a_j$，那么将 $a_i$ 替换为 $a_i+a_j$。
- 否则将 $a_j$ 替换为 $a_i+a_j$。

现在需要通过若干次上述操作使得数组 $a$ 中所有元素的奇偶性相同。请你求出最少需要多少次操作。

## 说明/提示

对于所有数据：

- $1\leqslant T\leqslant 10^4$。
- $1\leqslant n\leqslant 2\times10^5$，$\sum n\leqslant 2\times 10^5$。
- $\forall i\in[1,n],1\leqslant a_i\leqslant 10^9$。

Translated by [Eason_AC](/user/112917)。

## 样例 #1

### 输入

```
7
5
1 3 5 7 9
4
4 4 4 4
3
2 3 4
4
3 2 2 8
6
4 3 6 1 2 1
6
3 6 1 2 1 2
5
999999996 999999997 999999998 999999999 1000000000```

### 输出

```
0
0
2
4
3
3
3```

# AI分析结果



### 题目重写
给定一个包含 $n$ 个整数的数组 $a$。每次操作中，你可以选择一对索引 $(i,j)$，使得 $a_i$ 和 $a_j$ 奇偶性不同，并将较小的数替换为两数之和。求使数组中所有元素奇偶性相同的最小操作次数。

---

### 题解综合分析
**核心观察**：最终奇偶性只能是全奇数（除非初始全为偶数）。操作的核心是贪心地将偶数逐步转换为奇数，关键点在于处理偶数的顺序和奇数的选择。

#### 最优题解亮点
1. **MorLeaves（★★★★★）**  
   - **关键思路**：排序偶数后，用最大奇数依次合并。若合并过程中遇到需要两次操作的情况（当前奇数 < 偶数），则总次数增加1。
   - **代码亮点**：简洁的排序+遍历判断逻辑，时间复杂度 $O(n \log n)$。
   ```cpp
   sort(x+1,x+k+1);
   s += maxn; // 当前最大奇数值
   bool flag = false;
   for (偶数遍历) {
       if (s <= 偶数) { flag = true; break; }
       s += 偶数;
   }
   cout << 偶数个数 + flag;
   ```

2. **donnieguo（★★★★☆）**  
   - **关键思路**：预处理最大奇数，排序偶数后判断是否需要额外操作。通过一次遍历统计总次数。
   - **实现技巧**：使用 `vector` 存储偶数，避免数组越界问题。

3. **yanlikun（★★★★☆）**  
   - **创新点**：比较两种贪心策略（最小偶优先 vs 最大偶优先），取较小值。
   ```cpp
   for (偶数排序后) {
       if (maxj < 偶数) ans += 2, maxj += 最大偶;
       else ans += 1, maxj += 偶数;
   }
   cout << min(ans, 偶数数 + 1);
   ```

---

### 关键思路总结
1. **贪心策略**：优先处理较小偶数，用最大奇数合并以减少操作次数。
2. **临界处理**：若存在无法一次合并的偶数（当前奇数 < 偶数），需额外操作。
3. **数学性质**：奇偶相加得奇数，偶偶相加无法改变奇偶性，最终结果必须全为奇数。

---

### 相似题目推荐
1. [CF1352G Special Permutation](https://www.luogu.com.cn/problem/CF1352G)（奇偶交替排列构造）
2. [P7072 直播获奖](https://www.luogu.com.cn/problem/P7072)（动态维护有序性）
3. [CF1365C Rotation Matching](https://www.luogu.com.cn/problem/CF1365C)（数组变换与奇偶性）

---

### 题解心得摘录
- **调试经验**：需注意数据范围，`maxn` 初始值应设为-1而非0（避免全偶数误判）。
- **优化技巧**：将偶数排序后，可以保证后续操作的单调性，避免重复判断。
- **踩坑教训**：若未处理最大奇数的动态增长，会导致后续偶数判断错误。

---
处理用时：36.25秒
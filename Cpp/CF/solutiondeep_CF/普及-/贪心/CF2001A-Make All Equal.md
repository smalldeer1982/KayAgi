# 题目信息

# Make All Equal

## 题目描述

给你一个循环数组 $a_1,a_2,\cdots,a_n$。

你可以对 $a$ 数组进行最多 $n-1$ 次操作：

+ 设 $m$ 为 $a$ 数组现在的大小，你可以选择任意的两个相邻元素，使得前一个元素的值不大于后一个元素的值（特别的是 $a_m$ 和 $a_1$ 是相邻的，且 $a_m$ 是前一个元素），并将其中的任意一个删除。换句话说，选择一个整数 $i$（$1 \le i \le m$）使得 $a_i \le a_{(i \bmod m)+1}$ 成立，并将 $a_i$ 或 $a_{(i \bmod m)+1}$ 中的一个从 $a$ 数组中删除。

你的目标是找到使所有元素相等所需的最小操作数。

## 说明/提示

在第一组数据中，$a$ 数组只有一个元素，所以我们不能进行任何操作。

在第二组数据中，我们可以执行以下操作，使得 $a$ 数组中的所有元素相等:
+ 选择 $i=2$，删除 $a_3$，则 $a$ 数组将变为 $[1,2]$。

+ 选择 $i=1$，删除 $a_1$，则 $a$ 数组将变为 $[2]$。

可以证明，我们不能进行少于 $2$ 次的操作使得 $a$ 数组中的所有元素相等，所以答案是 $2$。

## 样例 #1

### 输入

```
7
1
1
3
1 2 3
3
1 2 2
5
5 4 3 2 1
6
1 1 2 2 3 3
8
8 7 6 3 8 7 6 3
6
1 1 4 5 1 4```

### 输出

```
0
2
1
4
4
6
3```

# AI分析结果



### 题目重写

#### 题目描述

给定一个循环数组 $a_1, a_2, \cdots, a_n$。

你可以对数组进行最多 $n-1$ 次操作：

- 设当前数组大小为 $m$，选择任意两个相邻元素（$a_m$ 和 $a_1$ 视为相邻，且 $a_m$ 是前一个元素），满足前一个元素不大于后一个元素，并删除其中一个。

目标是使所有剩余元素相等，求最小操作次数。

#### 输入输出样例

输入包含多组测试数据，输出为每组数据的最小操作次数。

---

### 题解分析与结论

#### 关键思路

通过观察所有样例，发现答案等于数组长度 $n$ 减去数组中出现次数最多的元素的出现次数。即：若某个元素 $x$ 的出现次数为 $m$，则最少操作次数为 $n - m$。

**核心逻辑**：无论元素是否连续，只要存在一个元素出现次数最多，就能通过删除其他元素保留所有该元素。每次操作总能找到非目标元素并利用其相邻关系删除。

#### 解决难点

- **直觉误导**：容易陷入对元素连续性或最小值条件的误区，但实际只需统计频次。
- **循环结构处理**：无需特殊处理循环相邻关系，频次统计是全局性质。

#### 最优题解

**思路**：统计所有元素的出现次数，取最大值 $m$，答案为 $n - m$。

**代码实现**：
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        map<int, int> cnt;
        int max_cnt = 0;
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            cnt[x]++;
            max_cnt = max(max_cnt, cnt[x]);
        }
        cout << n - max_cnt << endl;
    }
    return 0;
}
```

**亮点**：
- 时间复杂度 $O(n)$，空间复杂度 $O(n)$。
- 直接利用哈希表统计频次，无需复杂结构。

---

### 举一反三

1. **同类题目**：
   - **P3811**：统计众数出现次数。
   - **P1628**：寻找连续子序列最大和。
   - **P1090**：贪心合并问题（频次优化）。

2. **思维拓展**：
   - 在循环数组中，频次统计可能隐含全局最优解。
   - 当题目允许任意顺序删除时，频次主导的贪心策略往往有效。

---

### 总结

本题核心在于发现答案仅依赖于元素的最大出现频次，与元素的分布无关。通过哈希表快速统计即可解决，避免复杂结构或算法。

---
处理用时：443.58秒
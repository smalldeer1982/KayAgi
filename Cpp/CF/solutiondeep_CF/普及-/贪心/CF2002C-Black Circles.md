# 题目信息

# Black Circles

## 题目描述

在一个二维平面上有 $n$ 个圆。第 $i$ 个圆的圆心位于 $(x_i, y_i)$。最初，所有圆的半径都是 $0$。

这些圆的半径以每秒 $1$ 单位的速度增长。

你现在的位置是 $(x_s, y_s)$，你的目标是到达 $(x_t, y_t)$，并且在这个运动过程中不能碰到任何一个圆的边缘（包括你到达 $(x_t, y_t)$ 的那一刻）。你可以向任意方向移动。然而，你的速度被限制在每秒 $1$ 单位。

请判断是否有可能实现这一目标。

## 说明/提示

在第一个测试用例中，一种可行的移动方式如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2002C/e91b557a5335aaaa3689cd6df137ea06f9152e48.png)

## 样例 #1

### 输入

```
7
3
2 5
2 14
10 13
4 9 9 7
3
10 11
6 9
12 12
14 13 4 8
1
5 7
12 6 11 13
2
1000000000 2
2 1000000000
1 1 2 2
1
999999998 1000000000
999999999 999999999 1 1
1
1000000000 1
1 1000000000 1 1
10
989237121 2397081
206669655 527238537
522705783 380636165
532545346 320061691
207818728 199485303
884520552 315781807
992311437 802563521
205138355 324818663
223575704 395073023
281560523 236279118
216941610 572010615 323956540 794523071```

### 输出

```
YES
NO
YES
YES
YES
NO
YES```

# AI分析结果



### 中文重写题目

#### 题目描述

在一个二维平面上有 $n$ 个圆。第 $i$ 个圆的圆心位于 $(x_i, y_i)$。最初，所有圆的半径都是 $0$，且每秒钟半径增长 $1$ 单位。你需要从起点 $(x_s, y_s)$ 移动到终点 $(x_t, y_t)$，移动速度也为每秒 $1$ 单位。在此过程中，不能碰到任何圆的边缘（包括到达终点时）。判断是否可以实现这一目标。

---

### 题解综合分析

#### 关键思路与结论
1. **贪心策略**：走直线路径是最优解，因为两点之间线段最短，耗时最少。
2. **判定条件**：若存在任意一个圆心到终点的距离 $\leq$ 起点到终点的距离，则无法安全到达。
3. **数学证明**：若所有圆心到终点的距离均严格大于起点到终点的距离，则直线路径上所有点均不会被圆覆盖。

#### 高星题解推荐
1. **masonxiong（5星）**  
   - **亮点**：详细数学证明贪心策略的正确性，代码简洁且变量命名规范。
   - **核心代码**：
     ```cpp
     long long eDistance(const pair<long long, long long>& x, const pair<long long, long long>& y) {
         return (x.first - y.first) * (x.first - y.first) + (x.second - y.second) * (x.second - y.second);
     }
     bool success = eDistance(source, destination) < minCircleDistance;
     ```

2. **3Luby3（4星）**  
   - **亮点**：代码逻辑清晰，直接比较距离平方避免浮点运算。
   - **注意点**：变量名 `y` 容易混淆，但核心思路正确。
   - **核心代码**：
     ```cpp
     int juli(int x1, int y, int x2, int y2) {
         return (x2 - x1) * (x2 - x1) + (y2 - y) * (y2 - y);
     }
     if (juli(a[i].x, a[i].y, x2, y2) <= juli(x1, y, x2, y2)) flag = 1;
     ```

3. **ATION001（4星）**  
   - **亮点**：使用 `pair` 存储坐标，代码简洁高效。
   - **核心代码**：
     ```cpp
     int code(int dx, int dy, int ex, int ey) {
         return (ex - dx) * (ex - dx) + (ey - dy) * (ey - dy);
     }
     flag |= (code(a[i].first, a[i].second, ex, ey) <= code(dx, dy, ex, ey));
     ```

---

### 最优技巧总结
- **避免浮点运算**：直接比较距离平方，提高效率。
- **贪心策略的数学证明**：利用三角不等式证明直线路径的安全性。
- **变量命名规范**：使用 `long long` 防止溢出，避免 `y1` 等保留字。

---

### 拓展与举一反三
- **类似题目**：动态障碍物路径规划（如随时间扩展的障碍物）。
- **推荐题目**：  
  1. [P1462 通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)（最短路+条件判定）  
  2. [P1337 [JSOI2004]平衡点](https://www.luogu.com.cn/problem/P1337)（几何+优化）  
  3. [CF1101D GCD Counting](https://www.luogu.com.cn/problem/CF1101D)（动态规划与条件约束）

---

### 题解个人心得摘录
- **masonxiong**：强调“走直线一定最快”的贪心思想，并给出详细几何证明。
- **furina_yyds**：用“拼命往学校跑”的比喻形象说明贪心策略的必要性。
- **lizhixun**：提醒“多测不清空，WA两行泪”，强调初始化的重要性。

---
处理用时：71.73秒
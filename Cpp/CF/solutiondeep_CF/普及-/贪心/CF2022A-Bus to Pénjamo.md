# 题目信息

# Bus to Pénjamo

## 题目描述

# 前往佩尼亚莫的巴士


Ya vamos llegando a Péeeenjamoo ♫♫

有 $n$ 个家庭前往佩恩哈莫，见证墨西哥有史以来最大规模的 "拴着绳子遛鸡 "马拉松比赛。其中 $i$ 个家庭有 $a_i$ 名家庭成员。所有家庭将乘坐一辆大巴，每辆大巴有 $r$ 排， $2$ 个座位。

一个人在以下情况下被认为是幸福的：

- 另一名家庭成员与他们坐在同一排，或
- 他们独自坐在自己那一排（旁边有一个空座位）。

确定最佳座位安排下最多有多少人开心。注意，**每个人**都必须坐在车上。

保证所有家庭成员都能上车。形式上，保证 $\displaystyle\sum_{i=1}^{n}a_i \le 2r$ 。

## 说明/提示

在第一个测试案例中，第一个家庭的两名成员可以一起坐在第一排，而第二个家庭的两名成员可以一起坐在第二排。第二家庭的其余成员可与第三家庭的一名成员一起坐在第三排。这种座位安排如下图所示，其中 $4$ 快乐的人被涂成绿色。

| $\color{green}{1}$ | $\color{green}{1}$ |
| --- | --- |
| $\color{green}{2}$ | $\color{green}{2}$ |
| $2$ | $3$ |

在第二个测试案例中，有 $6$ 个快乐的人的可能座位安排如下所示。

| $\color{green}{3}$ | $\color{green}{3}$ |
| --- | --- |
| $\color{green}{1}$ | $\color{green}{1}$ |
| $\color{green}{2}$ | $\color{green}{2}$ |

在第三个测试案例中，有 $6$ 个快乐的人的可能座位安排如下所示。

| $\color{green}{4}$ | $\color{green}{4}$ |
| --- | --- |
| | $\color{green}{2}$ |
| $\color{green}{3}$ | $\color{green}{3}$ |
| $\color{green}{1}$ | |
| | |

## 样例 #1

### 输入

```
4
3 3
2 3 1
3 3
2 2 2
4 5
1 1 2 2
4 5
3 1 1 3```

### 输出

```
4
6
6
6```

# AI分析结果



# 前往佩尼亚莫的巴士

有 $n$ 个家庭前往佩恩哈莫，见证墨西哥有史以来最大规模的 "拴着绳子遛鸡 "马拉松比赛。其中第 $i$ 个家庭有 $a_i$ 名成员。所有家庭将乘坐一辆大巴，每辆大巴有 $r$ 排，每排 $2$ 个座位。

一个人在以下情况下被认为是幸福的：
- 另一名家庭成员与他们坐在同一排，或
- 他们独自坐在自己那一排（旁边有一个空座位）。

确定最佳座位安排下最多有多少人开心。**每个人**都必须坐在车上，且总人数不超过 $2r$。

## 样例输入输出
样例输入：
```
4
3 3
2 3 1
3 3
2 2 2
4 5
1 1 2 2
4 5
3 1 1 3
```
样例输出：
```
4
6
6
6
```

---

### 题解分析与结论
#### 关键思路
1. **家庭排数计算**：每个家庭的最优排数为 $\lceil a_i/2 \rceil$（即 `(a_i + 1) // 2`），因为两人同排或单独成排时最大化幸福人数。
2. **总排数判断**：若所有家庭排数总和 $\leq r$，则所有成员均幸福，总幸福人数为 $\sum a_i$。
3. **排数超出处理**：若总排数超过 $r$，则需合并排数至多 $k = \text{总排数} - r$ 次。每次合并减少 $2$ 人幸福，总幸福人数为 $\sum a_i - 2k$。

#### 解决难点
- 正确计算每个家庭的排数，避免遗漏单独成排的情况。
- 处理排数超出时如何高效合并，确保每次合并的代价为 $2$ 人。

---

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, r;
        cin >> n >> r;
        vector<int> a(n);
        int sum_ceil = 0, total = 0;
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            sum_ceil += (a[i] + 1) / 2;
            total += a[i];
        }
        if (sum_ceil <= r) {
            cout << total << endl;
        } else {
            cout << total - 2 * (sum_ceil - r) << endl;
        }
    }
    return 0;
}
```

---

### 相似题目推荐
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 贪心策略应用。
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 优先队列优化合并问题。
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995) - 贪心与数学结合的最优安排。

---
处理用时：281.22秒
# 题目信息

# Penchick and Modern Monument

## 题目描述

给出长度为 $n$ 的**单调不增**数列 $h$，你可以进行若干次操作，每次操作中，你可以选择任意一个数 $i$，并将 $h_i$ 改为任意一个数，目标是让数列 $h$ 变成**单调不降**的数列。请问最少需要多少次操作？

## 说明/提示

$1\le t\le1000$，$1\le n\le50$。

## 样例 #1

### 输入

```
3
5
5 4 3 2 1
3
2 2 1
1
1```

### 输出

```
4
1
0```

# AI分析结果



# Penchick and Modern Monument

## 题目描述

给出长度为 $n$ 的**单调不增**数列 $h$，你可以进行若干次操作，每次操作中，你可以选择任意一个数 $i$，并将 $h_i$ 改为任意一个数，目标是让数列 $h$ 变成**单调不降**的数列。请问最少需要多少次操作？

## 说明/提示

$1\le t\le1000$，$1\le n\le50$。

## 样例 #1

### 输入

```
3
5
5 4 3 2 1
3
2 2 1
1
1
```

### 输出

```
4
1
0
```

---

## 综合分析与结论

### 关键思路
将问题转化为**最长非递减子序列（LNDS）**问题。由于原数组单调不增，要求最少修改次数等价于找到原数组中最长的可以构成非递减序列的子序列长度，最终答案即为总长度减去该子序列长度。

### 算法要点
1. **动态规划解法**：定义 `dp[i]` 表示以 `h[i]` 结尾的最长非递减子序列长度。
2. **转移方程**：`dp[i] = max(dp[j] + 1)`，其中 `j < i` 且 `h[j] ≤ h[i]`。
3. **时间复杂度**：$O(n^2)$，在题目约束下完全可行。

### 解决难点
- 需逆向思维，将**单调不增**原数组转换为**非递减**目标，并识别其与 LNDS 的关联。
- 正确理解子序列的选取逻辑，允许相同元素构成合法子序列。

---

## 核心代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> h(n), dp(n, 1);
        for (auto& x : h) cin >> x;
        
        int max_len = 1;
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (h[j] <= h[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            max_len = max(max_len, dp[i]);
        }
        cout << n - max_len << "\n";
    }
}
```

---

## 拓展与相似题目
1. **P1020 导弹拦截**  
   求最长不升子序列与最少拦截系统数，类似动态规划与贪心结合。
2. **P1091 合唱队形**  
   双向 LIS 问题，考察递增递减子序列的结合。
3. **P1439 最长公共子序列**  
   利用序列单调性优化 LCS 到 O(n log n)。

---
处理用时：133.64秒
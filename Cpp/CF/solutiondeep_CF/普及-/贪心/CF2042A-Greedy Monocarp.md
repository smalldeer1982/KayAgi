# 题目信息

# Greedy Monocarp

## 题目描述

有 $n$ 个宝箱，第 $i$ 个有 $a_i$ 枚金币。对于每个宝箱，你可以加入任何非负整数枚金币，最终使得所有宝箱中金币的总数不小于 $k$。

在你加入金币之后，贪婪的 Monocarp 会来取金币。他会一个一个的取走宝箱，每次取走金币最多的宝箱，直到他取走金币的总数至少为 $k$。

你想要 Monocarp 取走尽量少的金币，所以你需要给宝箱增加一定的金币，使得 Monocarp 取走恰好 $k$ 枚金币。算出你最少需要加入多少枚金币。

## 样例 #1

### 输入

```
4
5 4
4 1 2 3 2
5 10
4 1 2 3 2
2 10
1 1
3 8
3 3 3```

### 输出

```
0
1
8
2```

# AI分析结果



# Greedy Monocarp

## 题目描述

有 $n$ 个宝箱，第 $i$ 个有 $a_i$ 枚金币。对于每个宝箱，你可以加入任何非负整数枚金币，最终使得所有宝箱中金币的总数不小于 $k$。

在你加入金币之后，贪婪的 Monocarp 会来取金币。他会一个一个的取走宝箱，每次取走金币最多的宝箱，直到他取走金币的总数至少为 $k$。

你想要 Monocarp 取走尽量少的金币，所以你需要给宝箱增加一定的金币，使得 Monocarp 取走恰好 $k$ 枚金币。算出你最少需要加入多少枚金币。

## 样例

### 输入

```
4
5 4
4 1 2 3 2
5 10
4 1 2 3 2
2 10
1 1
3 8
3 3 3
```

### 输出

```
0
1
8
2
```

---

### 题解综合分析

题目要求通过调整宝箱金币数，使得贪婪取法恰好取满 $k$，且新增金币最少。核心思路是**排序+前缀和贪心**。

#### 关键思路
1. **降序排序**：将宝箱初始金币降序排列，确保枚举时按可能被取走的顺序处理。
2. **前缀和预处理**：计算前 $t$ 个宝箱的初始总和，用于快速判断可行性。
3. **枚举分割点**：对于每个可能的 $t$（取前 $t$ 个宝箱），若其初始总和 $\leq k$，则新增金币为 $k - \text{前缀和}$，取最小值。

该算法时间复杂度为 $O(n \log n)$，主要来自排序。

---

### 题解代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        for (int& x : a) cin >> x;
        sort(a.rbegin(), a.rend());
        vector<ll> pre(n + 1);
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + a[i];
        }
        ll ans = LLONG_MAX;
        for (int t = 1; t <= n; ++t) {
            if (pre[t] > k) continue;
            ans = min(ans, k - pre[t]);
        }
        cout << ans << '\n';
    }
}
```

#### 代码说明
1. **降序排序**：确保每次取最大的前 $t$ 个宝箱。
2. **前缀和数组**：`pre[t]` 表示前 $t$ 个宝箱的初始总和。
3. **枚举可行分割点**：若 `pre[t] <= k`，则计算当前分割点的新增金币量，取最小值。

---

### 相似题目推荐
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 贪心排序
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心优先队列
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106) - 贪心选择最优解

---
处理用时：371.53秒
# 题目信息

# Swap Columns and Find a Path

## 题目描述

有一个包含 $2$ 行 $n$ 列的矩阵。从上至下标号 $1,2$，从左到右标号 $1$ 到 $n$。记第 $i$ 横行第 $j$ 竖列的位置为 $(i,j)$，每个单元位置有一个整数。

你可以进行如下操作任意次（包括 $0$ 次）：

- 交换两列数字（找到整数 $x,y$ 满足 $1\le x\lt y\le n$，交换 $a_{1,x}$ 与 $a_{1,y}$，同时交换 $a_{2,x}$ 与 $a_{2,y}$）。

以上操作全部完成后，你需要找到一条从 $(1,1)$ 到 $(2,n)$ 的路径，每一次只能从 $(i,j)$ 移动到 $(i+1,j)$ 或 $(i,j+1)$。显然，路径无法走出这个矩形。

这条路径的分数为路径上所有 $(n+1)$ 个整数之和。你要进行上述的操作，并且找到最大可能的分数。

## 样例 #1

### 输入

```
3
1
-10
5
3
1 2 3
10 -5 -3
4
2 8 5 3
1 10 3 4```

### 输出

```
-5
16
29```

# AI分析结果



# Swap Columns and Find a Path 题目翻译

有一个包含 $2$ 行 $n$ 列的矩阵。行从上到下编号为 $1,2$，列从左到右编号为 $1$ 到 $n$。记第 $i$ 行第 $j$ 列的位置为 $(i,j)$，每个位置有一个整数。

你可以进行任意次交换列操作（包括 $0$ 次）：选择两个不同的列 $x,y$，交换它们的两行元素。

操作完成后，你需要找到一条从 $(1,1)$ 到 $(2,n)$ 的路径，每一步只能向右或向下移动。路径的分数是路径上所有数的总和。求最大可能的分数。

---

### 题解分析与结论

所有题解的核心思路均基于以下观察：路径必然在某一列处发生唯一的向下移动。此时该列的两个元素都会被计入总和，而其他列根据位置取第一行或第二行的最大值。最终答案可通过以下公式计算：

**总得分 = 所有列的最大值之和 + 最大 min(该列两行值)**

#### 关键思路
1. **路径特征分析**：路径必然在某一列 $k$ 处向下，导致该列的两个元素均被选中。
2. **贪心策略**：对于其他列，左侧取第一行最大值，右侧取第二行最大值。
3. **数学优化**：直接计算全局最大值之和与最大 min 值的组合，时间复杂度 $O(n)$。

---

### 精选题解

#### 题解作者：OrientDragon（★★★★★）
**关键亮点**  
- 通过数学推导将问题简化为线性时间计算，时间复杂度最优。
- 提出核心公式：$\text{sum\_max} + \text{max\_min}$，突破枚举瓶颈。
**核心代码**  
```cpp
long long sum_max = 0, max_min = -1e18;
for (int i = 0; i < n; ++i) {
    int mx = max(a[i], b[i]);
    sum_max += mx;
    max_min = max(max_min, min(a[i], b[i]));
}
cout << sum_max + max_min << endl;
```
**实现思想**  
遍历所有列，累加每列的最大值，同时记录每列较小值的最大值。最终结果为两者的和。

---

### 关键技巧总结
1. **路径结构分析**：抓住路径的必经点（唯一向下移动列）简化问题。
2. **贪心选择**：利用列交换的自由性，将非关键列的最优贡献独立计算。
3. **数学优化**：将枚举问题转化为全局极值计算，避免冗余循环。

---

### 同类题目推荐
1. **[CF1353E](https://www.luogu.com.cn/problem/CF1353E)**：路径规划与状态转移优化。
2. **[CF1520D](https://www.luogu.com.cn/problem/CF1520D)**：利用差值分析优化枚举。
3. **[P7074](https://www.luogu.com.cn/problem/P7074)**：二维矩阵路径极值问题，动态规划与贪心结合。

---
处理用时：150.77秒
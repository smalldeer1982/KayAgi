# 题目信息

# MEX Destruction

## 题目描述

Evirir 这条龙潜入了一个巫师的城堡，并发现了一个神秘的装置。由于它爱玩的天性，它开始摆弄（破坏）这个装置……

Evirir 这条龙发现了一个由 $ n $ 个非负整数组成的数组 $ a_1, a_2, \ldots, a_n $。

在一次操作中，它可以选择一个非空的子数组 $ ^{\text{∗}} $ $ b $ 并将其替换为整数 $ \operatorname{mex}(b) $ $ ^{\text{†}} $ 。它希望使用任意多次操作，使数组 $ a $ 只包含零。可以证明，在问题的约束条件下，这总是可能的。

需要找到使数组 $ a $ 只包含零所需的最小操作次数。

- $ ^{\text{∗}} $ 如果可以通过删除开头和结尾的若干（可能为零或全部）元素来获得数组 $ c $，则数组 $ c $ 是数组 $ d $ 的子数组。
- $ ^{\text{†}} $ 一个整数集合 $ f_1, f_2, \ldots, f_k $ 的最小排除值（mex）定义为集合 $ f $ 中不存在的最小的非负整数 $ x $。

## 说明/提示

在第一个测试用例中，Evirir 可以选择子数组 $ b = [1, 2, 3] $ 并将其替换为 $ \operatorname{mex}(1, 2, 3) = 0 $，将数组 $ a $ 从 $ [0, \underline{1, 2, 3}] $ 变为 $ [0, 0] $（其中选定的子数组已加下划线）。因此，答案是 $ 1 $。

在第二个测试用例中，数组 $ a $ 已经只包含 $ 0 $，所以不需要进行任何操作。

在第三个测试用例中，Evirir 可以按如下方式更改 $ a $：$ [1, \underline{0, 1, 0, 1}] \to [\underline{1, 2}] \to [0] $。这里，$ \operatorname{mex}(0, 1, 0, 1) = 2 $ 和 $ \operatorname{mex}(1, 2) = 0 $。

在第四个测试用例中，Evirir 可以选择整个数组 $ a $ 作为 $ b $，将数组 $ a $ 从 $ [\underline{3, 1, 4, 1, 5}] $ 变为 $ [0] $。

## 样例 #1

### 输入

```
10
4
0 1 2 3
6
0 0 0 0 0 0
5
1 0 1 0 1
5
3 1 4 1 5
4
3 2 1 0
7
9 100 0 89 12 2 3
4
0 3 9 0
7
0 7 0 2 0 7 0
1
0
2
0 1```

### 输出

```
1
0
2
1
1
2
1
2
0
1```

# AI分析结果



### 题目内容重写

# MEX 破坏

## 题目描述

龙 Evirir 发现了一个由 $ n $ 个非负整数组成的数组 $ a_1, a_2, \ldots, a_n $。它可以通过选择一个非空子数组，将其替换为该子数组的 MEX 值，最终使数组全为 0。求最小操作次数。

- **子数组**：通过删除数组开头和结尾的若干元素得到的连续部分。
- **MEX**：集合中未出现的最小非负整数。

### 输入输出样例

#### 输入
```
10
4
0 1 2 3
6
0 0 0 0 0 0
5
1 0 1 0 1
5
3 1 4 1 5
4
3 2 1 0
7
9 100 0 89 12 2 3
4
0 3 9 0
7
0 7 0 2 0 7 0
1
0
2
0 1
```

#### 输出
```
1
0
2
1
1
2
1
2
0
1
```

---

### 题解分析与结论

#### 关键思路
**核心观察**：当数组中存在 0 时，若所有非零元素构成一个连续块，则只需一次操作；否则需两次。若数组不含 0，则只需一次操作。

**算法步骤**：
1. **全为 0**：直接返回 0。
2. **不含 0**：返回 1。
3. **存在 0**：统计非零块的数量：
   - 若非零块数为 1，返回 1。
   - 否则返回 2。

#### 解决难点
- **连续非零块的判断**：通过遍历数组，统计非零块的数目。
- **MEX 的隐含性质**：当数组存在 0 时，非零元素的 MEX 必为 0，无需显式计算。

---

### 推荐题解

#### 题解（五星）
**关键亮点**：简洁高效，时间复杂度 O(n)，空间复杂度 O(1)。
- 通过遍历数组统计非零块的数量，直接判断操作次数。
- 无需显式计算 MEX，利用隐含性质优化判断逻辑。

**核心代码实现**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        bool has_zero = false;
        for (int &x : a) {
            cin >> x;
            if (x == 0) has_zero = true;
        }

        if (!has_zero) {
            cout << 1 << endl;
            continue;
        }

        int cnt = 0;
        bool in_block = false;
        for (int x : a) {
            if (x != 0) {
                if (!in_block) {
                    cnt++;
                    in_block = true;
                }
            } else {
                in_block = false;
            }
        }

        if (cnt <= 1) {
            cout << (count(a.begin(), a.end(), 0) == n ? 0 : 1) << endl;
        } else {
            cout << 2 << endl;
        }
    }
}
```

---

### 拓展与相似题目
1. **连续子数组性质**：[CF1692G](https://codeforces.com/problemset/problem/1692/G)（数组分段处理）
2. **MEX 计算应用**：[洛谷 P7669](https://www.luogu.com.cn/problem/P7669)
3. **贪心策略优化**：[洛谷 P7615](https://www.luogu.com.cn/problem/P7615)

---
处理用时：457.30秒
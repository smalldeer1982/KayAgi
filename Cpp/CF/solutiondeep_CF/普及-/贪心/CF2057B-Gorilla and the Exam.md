# 题目信息

# Gorilla and the Exam

## 题目描述

# Gorilla and the Exam


由于“T世代”高年级学生的教师短缺，决定由一只巨大的雄性猩猩来为学生们进行考试。然而，这并不是那么简单；为了证明其能力，它需要解决以下问题。

给定一个数组 $ b $ ，我们定义函数 $ f(b) $ 为将数组 $ b $ 变为空所需的最小操作次数：

- 选择两个整数 $ l $ 和 $ r $ ，满足 $ l \le r $ ，并令 $ x $ 为数组 $ b_l, b_{l+1}, \ldots, b_r $ 中的最小值；
- 然后，删除所有满足 $ l \le i \le r $ 且 $ b_i = x $ 的元素，删除后的元素将被移除，剩余元素的索引重新编号。

现在给定一个长度为 $ n $ 的数组 $ a $ 和一个整数 $ k $ 。你可以至多进行 $ k $ 次修改操作，每次可以选择数组中的任意索引 $ i $ （$ 1 \le i \le n $）和任意整数 $ p $ ，将 $ a_i $ 替换为 $ p $ 。

帮助猩猩求出经过至多 $ k $ 次替换操作后，数组 $ a $ 的 $ f(a) $ 可以达到的最小值。

## 说明/提示

- 在第一个测试数据中，数组 $ [48843] $ 只包含一个元素，因此 $ f([48843]) = 1 $，只需一次操作即可删除该元素。
- 在第二个测试数据中，你可以将数组 $ [2, 3, 2] $ 中的第二个元素修改为 $ 2 $ ，使得数组变为 $ [2, 2, 2] $ ，此时 $ f([2, 2, 2]) = 1 $ ，因为可以选择整个数组，最小值为 $ 2 $，然后一次删除所有的 $ 2 $ 元素。

## 样例 #1

### 输入

```
6
1 0
48843
3 1
2 3 2
5 3
1 2 3 4 5
7 0
4 7 1 3 2 4 1
11 4
3 2 1 4 4 3 4 2 1 3 3
5 5
1 2 3 4 5```

### 输出

```
1
1
2
5
2
1```

# AI分析结果



### 题目内容中文翻译
# 猩猩与考试

## 题目描述

由于"T世代"高年级教师短缺，决定由一只巨型雄性大猩猩为学生监考。为证明能力，它需解决以下问题：

给定数组 $b$，定义函数 $f(b)$ 为将数组清空所需的最小操作次数：
1. 选择两个整数 $l$ 和 $r$（$l \le r$），令 $x$ 为子数组 $b_l,...,b_r$ 的最小值；
2. 删除所有 $l \le i \le r$ 且 $b_i = x$ 的元素。

现给定长度为 $n$ 的数组 $a$ 和整数 $k$，可通过至多 $k$ 次修改操作（每次将任意元素改为任意值），求修改后 $f(a)$ 的最小值。

## 样例与提示
样例说明已清晰展示操作逻辑，关键性质是每次操作可删除某一数值的全部元素。

---

### 题解分析与结论

#### 核心思路
所有题解均基于以下观察：
1. **全局最优策略**：每次选择整个数组范围 $[1,n]$ 进行操作，此时 $f(a)$ 等于数组中不同数值的种数。
2. **问题转化**：最小化 $f(a)$ 等价于用 $k$ 次修改将数值种数降到最低。

#### 通用解法
1. 统计各数值出现次数
2. 按出现次数升序排序
3. 贪心策略：优先消除出现次数最少的数值，用尽 $k$ 次修改机会

#### 最优题解亮点

##### 题解作者：TainityAnle（★★★★☆）
**关键亮点**：
- 直接使用 `map` 统计频率，转化为 `vector` 排序
- 清晰遍历逻辑：每消除一个数值，种数减1
- 处理边界情况（k足够大时返回1）

```cpp
map<int,int> t; vector<int> a;
for(auto c:t) a.push_back(c.second);
sort(a.begin(), a.end());
int m = a.size();
for(int i=0; i<m; i++){
    if(k >= a[i]) k -= a[i];
    else return m-i; 
}
return 1;
```

##### 题解作者：FXLIR（★★★★☆）
**创新点**：
- 使用优先队列动态维护频率最小值
- 直观模拟修改过程，代码更易理解

```cpp
priority_queue<int, deque<int>, greater<int>> q;
for(auto i:mp) q.push(i.second);
while(k > 0){
    int tmp = q.top(); q.pop();
    k -= tmp;
    if(tmp > 0) q.push(tmp-1);
}
cout << max(q.size(), 1);
```

##### 题解作者：nannangua（★★★★☆）
**优化技巧**：
- 使用二分查找确定可消除的数值种数
- 预处理前缀和提升效率

```cpp
sort(tim, tim+cnt);
for(int i=1;i<=cnt;i++) tim[i] += tim[i-1];
int pos = upper_bound(tim+1, tim+cnt+1, k) - tim;
ans = cnt - (pos-1);
```

---

### 关键技巧总结
1. **贪心选择策略**：出现次数少的数值优先消除
2. **数据结构选择**：`map` 统计频率优于数组（处理大值域）
3. **边界处理**：当剩余修改次数不足以完全消除某个数值时立即终止

---

### 类似题目推荐
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094) - 贪心策略
2. [CF1189C Candies!](https://codeforces.com/problemset/problem/1189/C) - 前缀和与区间操作
3. [P1604 B进制星球](https://www.luogu.com.cn/problem/P1604) - 多进制处理与贪心

---

### 个人心得摘录
- **`map` vs `unordered_map`**：某题解强调必须用有序map，避免哈希冲突导致的统计错误
- **优先队列效率**：虽然逻辑清晰，但实际运行可能比排序略慢，需注意常数优化
- **数值种数下限**：即使k超过总元素数，答案最低为1而非0，需特判处理

---
处理用时：47.05秒
# 题目信息

# Opponents

## 题目描述

# 问题描述

小白有 n 个对手，他每天都要和这些对手PK。对于每一天，如果 n 个对手全部到齐，那么小白就输了一场，否则小白就赢了一场。特别的，如果某天一个对手都没有到，也算小白赢。现在已知对手 d 天的出场情况，请计算小白最多能连胜多少场。

## 样例 #1

### 输入

```
2 2
10
00
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 1
0100
```

### 输出

```
1
```

## 样例 #3

### 输入

```
4 5
1101
1111
0110
1011
1111
```

### 输出

```
2
```

# AI分析结果



# Opponents

## 题目描述

小白有 n 个对手，他每天都要和这些对手PK。对于每一天，如果 n 个对手全部到齐，那么小白就输了一场，否则小白就赢了一场。特别的，如果某天一个对手都没有到，也算小白赢。现在已知对手 d 天的出场情况，请计算小白最多能连胜多少场。

---

## 题解综合分析

### 最优思路总结
1. **贪心维护连胜序列**：遍历每日数据时动态维护当前连胜值，遇到失败时清零
2. **高效胜负判断**：通过字符串查找'0'（`string::find`）或逐字符检查快速判断当日胜负
3. **边界处理**：最终连胜可能位于数据末尾，需在循环外再比较一次
4. **空间优化**：无需存储全部数据，可实时处理每日结果

---

## 精选题解（评分≥4星）

### 题解1：judgejudge（★★★★☆）
**关键亮点**：
- 利用字符串的`find`函数简化胜负判断
- 代码简洁易读（仅11行核心逻辑）
- 时间复杂度 O(d*(n+1))，空间复杂度 O(1)

**核心代码**：
```cpp
int sum=0, tot=0;
for(int i=1;i<=m;i++){
    cin>>st;
    k=st.find('0');
    if(k>=0) tot++;
    else tot=0;
    sum=max(sum,tot);
}
```

### 题解2：ZolaWatle（★★★★☆）
**关键亮点**：
- 显式处理最终未中断的连胜
- 添加详细注释说明边界情况
- 布尔判断逻辑清晰

**核心代码**：
```cpp
bool p=0;
for(re j=0;j<k;j++)
    if(temp[j]=='0') p=1;
if(p) cnt++;
else { /* 更新最大值并清零 */ }
// 循环结束后再次检查
if(cnt>ans) ans=cnt;
```

### 题解3：Register（★★★★☆）
**关键亮点**：
- 即时更新最大值策略
- 使用逐字符检查实现基础解法
- 无额外空间消耗

**核心代码**：
```cpp
bool flag=false;
for(int i=1;i<=n;i++){
    cin>>t;
    if(t=='0') flag=true;
}
if(flag) sum++;
else sum=0;
maxn=max(sum,maxn);
```

---

## 关键技巧提炼
1. **字符串特征查找**：`string::find` 比手动遍历更简洁
2. **实时最大值维护**：`max_val = max(cur, max_val)` 取代最后遍历
3. **双变量滑动窗口**：用`cur_streak`和`max_streak`维护当前/最大连胜
4. **边界哨兵处理**：在完整遍历后需要额外检查最终状态

---

## 拓展训练
1. [P1563 最大连续天数](https://www.luogu.com.cn/problem/P1563) - 基础滑动窗口应用
2. [P1219 棋盘问题](https://www.luogu.com.cn/problem/P1219) - 状态判断与连续序列
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双向连续序列维护

---

## 调试心得摘录
1. _Qer题解中的`memset(a, 1, sizeof(a))`存在问题，字符数组初始化为ASCII 1而非数值1
2. 多位作者强调注意n和d的输入顺序（题目描述中参数为n d但输入顺序是d n）
3. ZolaWatle指出最后需额外检查：循环结束后的当前连胜可能未被计入最大值

---
处理用时：59.46秒
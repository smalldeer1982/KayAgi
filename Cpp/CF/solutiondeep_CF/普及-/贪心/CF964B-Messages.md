# 题目信息

# Messages

## 题目描述

------------

Vasya有n封信。第i封信将在ti秒之后接收。 每封信都开始都值a元，但收到消息后，消息的成本每分钟减少B元(B可能变为负数)。Vasya可以在任意时刻接收到任何消息，也可在任意时刻读取它。读完消息后，Vasya的银行账户会收到该消息的当前成本。最初，Vasya的银行账户为0。 同时,每分钟Vasya的银行账户会收到C·k元,k是收到了但未读信的数量。 Vasya非常贪婪（又一个葛朗台），正因为如此，他想让所有的信息在T分钟后被阅读，使其利益最大化。


------------

## 样例 #1

### 输入

```
4 5 5 3 5
1 5 5 4
```

### 输出

```
20
```

## 样例 #2

### 输入

```
5 3 1 1 3
2 2 2 1 1
```

### 输出

```
15
```

## 样例 #3

### 输入

```
5 5 3 4 5
1 2 3 4 5
```

### 输出

```
35
```

# AI分析结果



# 题目内容中文翻译

------------

Vasya有n封信。第i封信将在ti分钟后接收。每封信初始价值为a元，但收到消息后，每分钟该消息的价值减少B元（可能变为负值）。Vasya可以在任意时刻接收并读取消息，读取时会获得当前价值。每分钟Vasya的银行账户会自动增加C·k元（k是已接收但未读的消息数量）。所有消息必须在T分钟后被读取，求最大化银行账户总额。

## 样例 #1

### 输入
```
4 5 5 3 5
1 5 5 4
```

### 输出
```
20
```

------------

# 题解综合分析

### 关键思路对比
所有题解均基于贪心策略，核心在于比较C与B的大小：
- 若C > B：延迟读取至最后时刻T，总收益为 `n*a + sum(T-ti)*(C-B)`
- 若C ≤ B：立即读取所有消息，总收益为 `n*a`

### 解决难点
- 理解消息价值变化与自动收益的关联性
- 发现C-B的差值决定贪心方向

# 精选题解

## 1. 作者：GusyNight（4星）
**核心亮点**：直击问题本质，代码极简高效  
**代码思想**：直接计算总延迟时间，通过一次判断完成收益计算  
```cpp
int main(){
    // 输入处理略
    ans = n*a;
    if(b < c) ans += sum*(c-b); 
    cout << ans;
}
```

## 2. 作者：_VEGETABLE_OIer_xlc（4星）
**核心亮点**：清晰分类讨论三种情况（C>B/C=B/C<B），增强理解  
**代码片段**：
```cpp
if(b <= c) { 
    sum = n*a + Σ(t-ti)*(c-b);
} else {
    sum = n*a;
}
```

## 3. 作者：Federico2903（4星）
**核心亮点**：数学建模思路明确，公式推导简洁  
**关键分析**：
> 每封信每分钟的净收益为(C-B)，总收益公式为`n*a + sum(T-ti)*(C-B)`

# 拓展技巧总结

### 关键优化点
- **贪心决策条件**：通过比较C与B的差值确定最优策略  
- **数学建模**：将复合收益转化为线性计算，时间复杂度O(n)

### 类似题目推荐
1. P1223 排队接水（贪心排序策略）
2. P1255 数楼梯（递推优化）
3. P1090 合并果子（优先队列应用）

### 调试经验摘录
> "KirBytronic指出原题翻译的时间单位错误（应为分钟而非秒），此类细节需注意验证。"  
> "Marshall001通过分情况计算两种策略结果取max，虽最终正确但冗余，实际条件判断更优。"  

# 最优代码实现
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, a, b, c, t, sum_t = 0;
    cin >> n >> a >> b >> c >> t;
    for(int i=0, ti; i<n; ++i) {
        cin >> ti;
        sum_t += t - ti;
    }
    int ans = n * a;
    if(c > b) ans += sum_t * (c - b);
    cout << ans;
    return 0;
}
```

---
处理用时：45.55秒
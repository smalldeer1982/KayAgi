# 题目信息

# Binary Colouring

## 题目描述

You are given a positive integer $ x $ . Find any array of integers $ a_0, a_1, \ldots, a_{n-1} $ for which the following holds:

- $ 1 \le n \le 32 $ ,
- $ a_i $ is $ 1 $ , $ 0 $ , or $ -1 $ for all $ 0 \le i \le n - 1 $ ,
- $ x = \displaystyle{\sum_{i=0}^{n - 1}{a_i \cdot 2^i}} $ ,
- There does not exist an index $ 0 \le i \le n - 2 $ such that both $ a_{i} \neq 0 $ and $ a_{i + 1} \neq 0 $ .

It can be proven that under the constraints of the problem, a valid array always exists.

## 说明/提示

In the first test case, one valid array is $ [1] $ , since $ (1) \cdot 2^0 = 1 $ .

In the second test case, one possible valid array is $ [0,-1,0,0,1] $ , since $ (0) \cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 = -2 + 16 = 14 $ .

## 样例 #1

### 输入

```
7
1
14
24
15
27
11
19```

### 输出

```
1
1
5
0 -1 0 0 1
6
0 0 0 -1 0 1
5
-1 0 0 0 1
6
-1 0 -1 0 0 1
5
-1 0 -1 0 1
5
-1 0 1 0 1```

# AI分析结果

### 题目内容中文重写
# 二进制染色

## 题目描述
给定一个正整数 $x$。找到任意一个整数数组 $a_0, a_1, \ldots, a_{n - 1}$，使得以下条件成立：
- $1 \leq n \leq 32$；
- 对于所有 $0 \leq i \leq n - 1$，$a_i$ 为 $1$、$0$ 或 $-1$；
- $x = \displaystyle{\sum_{i = 0}^{n - 1}{a_i \cdot 2^i}}$；
- 不存在索引 $0 \leq i \leq n - 2$ 使得 $a_{i} \neq 0$ 且 $a_{i + 1} \neq 0$。

可以证明，在题目的约束条件下，总是存在一个有效的数组。

## 说明/提示
在第一个测试用例中，一个有效的数组是 $[1]$，因为 $(1) \cdot 2^0 = 1$。

在第二个测试用例中，一个可能的有效数组是 $[0, -1, 0, 0, 1]$，因为 $(0) \cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 = -2 + 16 = 14$。

## 样例 #1
### 输入
```
7
1
14
24
15
27
11
19
```
### 输出
```
1
1
5
0 -1 0 0 1
6
0 0 0 -1 0 1
5
-1 0 0 0 1
6
-1 0 -1 0 0 1
5
-1 0 -1 0 1
5
-1 0 1 0 1
```

### 综合分析与结论
这些题解的核心思路都是先将给定的正整数 $x$ 转换为二进制形式，然后处理二进制表示中相邻的 $1$，以满足题目中不存在相邻非零元素的条件。具体处理方式是利用 $2^i + 2^{i + 1} = 2^{i + 2} - 2^i$ 这个等式，将相邻的 $1$ 转换为 $-1$ 和 $0$，并对进位情况进行处理。

算法要点：
1. **二进制转换**：将输入的正整数 $x$ 转换为二进制数组。
2. **相邻 $1$ 的处理**：当遇到相邻的 $1$ 时，将前一个 $1$ 变为 $-1$，后一个 $1$ 变为 $0$，并将下下一位加 $1$。
3. **进位处理**：当某一位的值达到 $2$ 时，将该位变为 $0$，并将下一位加 $1$。

解决难点：
1. **进位处理**：在处理相邻 $1$ 和值为 $2$ 的位时，需要注意数组长度的更新和边界情况。
2. **数组长度确定**：处理完所有情况后，需要确定最终数组的有效长度。

### 所选题解
- **作者：_zqh_ (4星)**
    - **关键亮点**：思路清晰，通过具体例子详细说明了处理过程，易于理解。
- **作者：ikunTLE (4星)**
    - **关键亮点**：代码实现简洁明了，注释详细，对每一步的操作都有清晰的解释。
- **作者：_ayaka_ (4星)**
    - **关键亮点**：思路清晰，对条件的分析准确，代码实现简洁。

### 重点代码
#### 作者：ikunTLE
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=32+10;
int t,n,a[N];
void solve(int x){
    int cnt=0,ans=0;
    while(x){
        a[++cnt]=(x&1);
        x>>=1;
    }
    a[cnt+1]=0;
    for(int i=1;i<=cnt;++i){
        if(a[i]==2)
            a[i]=0,++a[i+1];
        if(a[i]==1&&a[i+1]==1)
            a[i]=-1,a[i+1]=0,++a[i+2];
    }
    for(int i=1;i<=cnt+1;++i)
        if(a[i]) ans=i;
    printf("%d\n",ans);
    for(int i=1;i<=ans;++i)
        printf("%d ",a[i]);
    printf("\n");
    return;
}
int main(){
    cin>>t;
    while(t--){
        cin>>n;
        solve(n);
    }
    return 0;
}
```
**核心实现思想**：先将输入的数 $x$ 转换为二进制数组，然后遍历数组，处理相邻的 $1$ 和值为 $2$ 的位，最后确定数组的有效长度并输出。

### 最优关键思路或技巧
1. **二进制转换**：利用位运算将整数转换为二进制数组，简单高效。
2. **等式运用**：利用 $2^i + 2^{i + 1} = 2^{i + 2} - 2^i$ 处理相邻的 $1$，避免相邻非零元素的出现。
3. **进位处理**：当某一位的值达到 $2$ 时，及时进位，保证数组元素为 $1$、$0$ 或 $-1$。

### 可拓展之处
同类型题目可能会有不同的约束条件，例如改变数组元素的取值范围、改变求和公式的底数等。类似的算法套路可以应用于其他需要对二进制表示进行处理的问题，如二进制编码、位运算优化等。

### 推荐洛谷题目
1. [P1143 进制转换](https://www.luogu.com.cn/problem/P1143)
2. [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)
3. [P1604 B进制星球](https://www.luogu.com.cn/problem/P1604)

### 个人心得
- **作者：Furina_Saikou**：提到“多测不清空，光速见祖宗”，强调了多组测试数据时清空数组的重要性，避免数据残留导致错误。

---
处理用时：38.75秒
# 题目信息

# Creating the Contest

## 题目描述

你有一个包含 $ n $ 个问题的问题集，其中第 $ i $ 个问题的难度为 $ a_i $ ，保证没有难度相同的两个问题，且问题难度按照递增顺序给出。

你需要在这个问题集中取一个子集（不要求问题的顺序连续），满足以下条件：对于每道题目，在该子集中不存在难度超过该问题难度2倍的题目。（仅包含一个问题的子集也是合法的）

求出这个子集最多能包含多少个问题。

## 样例 #1

### 输入

```
10
1 2 5 6 7 10 21 23 24 49
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5
2 10 50 110 250
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6
4 7 12 100 150 199
```

### 输出

```
3
```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕如何从给定的递增难度问题集中选取满足条件的最大子集展开，提供了贪心和动态规划两种思路。
- **贪心思路**：
    - 核心在于判断相邻元素是否满足难度限制条件，若满足则继续添加，不满足则更新最大子集长度。
    - 时间复杂度为 $O(n)$，代码实现简单，易于理解。
- **动态规划思路**：
    - 设 $f_i$ 为以 $i$ 位置为结尾的最长序列长度，通过二分查找和线段树优化状态转移。
    - 时间复杂度为 $O(nlogn)$，代码实现复杂，但可处理更复杂的状态转移问题。
- **单调队列优化思路**：
    - 利用单调队列维护满足条件的区间最大值，优化动态规划的转移过程。
    - 时间复杂度为 $O(n)$，结合了动态规划和贪心的优点。

### 所选题解
- **一扶苏一（5星）**：
    - **关键亮点**：提供了贪心、动态规划和单调队列优化三种思路，思路清晰，代码注释详细，对每种思路的证明和复杂度分析都很到位。
    - **个人心得**：提到没想到贪心时可以尝试用熟悉的模型（如LIS）去思考，通过二分和线段树优化动态规划，还考虑了进一步优化到 $O(n)$ 的方法。
- **彭骐飞（4星）**：
    - **关键亮点**：在已有题解基础上，详细解释了如何使用单调队列优化动态规划，证明了队列的单调性和最优性，代码实现简洁。
    - **个人心得**：表示比赛时没想到简单贪心，直接用单调队列AC，体现了对单调队列的熟练运用。
- **MattL（4星）**：
    - **关键亮点**：思路简洁明了，直接阐述了贪心的本质，代码短小精悍，易于理解和实现。

### 重点代码
#### 贪心思路（一扶苏一）
```cpp
#include<iostream>
using namespace std;
int n;
int cnt=1;
int maxcnt=-1;
int a[200005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<n;i++)
    {
        if(2*a[i]>=a[i+1]) cnt++;
        else
        {
            if(cnt>maxcnt) maxcnt=cnt;
            cnt=1;
        }
    }
    if(cnt>maxcnt) maxcnt=cnt;
    cout<<maxcnt<<endl;
}
```
**核心实现思想**：遍历数组，若相邻元素满足难度限制则计数器加1，不满足则更新最大子集长度并重置计数器。

#### 动态规划思路（一扶苏一）
```cpp
// 二分查找最小的j
while(l<=r) {
    mid=(l+r)>>1;
    if((MU[mid]<<1)>=MU[i]) _ans=mid,r=mid-1;
    else l=mid+1;
}
if((_ans==0)||(_ans==i)) _ans=1;
else _ans=ask(1,n,1,_ans,i-1)+1;
change(1,n,1,i,_ans);
```
**核心实现思想**：通过二分查找找到满足条件的最小 $j$，利用线段树求区间 $[j, i - 1]$ 的最大值加1更新 $f_i$。

#### 单调队列优化思路（彭骐飞）
```cpp
for (int i=2;i<=n;i++)
{
    while (!q.empty())
    {
        t=q.front();
        if (a[t]*2<a[i]) q.pop_front();
        else break;
    }
    if (q.empty()) t=0;
    f[i]=f[t]+1;
    while (!q.empty())
    {
        t=q.back();
        if (f[t]<f[i]) q.pop_back();
        else break;
    }
    q.push_back(i);
}
```
**核心实现思想**：维护一个单调队列，从队头弹出不满足条件的元素，更新 $f[i]$，从队尾弹出更劣的元素，将 $i$ 压入队尾。

### 最优关键思路或技巧
- **贪心策略**：通过判断相邻元素的关系，直接得到最优解，时间复杂度低。
- **二分查找**：在动态规划中，利用序列的单调性，通过二分查找优化状态转移。
- **单调队列**：维护满足条件的区间最大值，优化动态规划的转移过程，将时间复杂度从 $O(nlogn)$ 降低到 $O(n)$。

### 拓展思路
同类型题或类似算法套路：
- 区间选择问题：如选择不重叠的区间，使区间长度之和最大。
- 子序列问题：如最长上升子序列、最长公共子序列等，可通过动态规划和贪心算法求解。

### 推荐洛谷题目
- P1090 [NOIP2004 提高组] 合并果子
- P1223 排队接水
- P1803 凌乱的yyy / 线段覆盖

### 个人心得总结
- 一扶苏一：当没想到贪心时，可以尝试用熟悉的模型去思考，如LIS，再通过优化降低复杂度。
- 彭骐飞：比赛时若没想到简单方法，可尝试用掌握的算法（如单调队列）去解决问题。 

---
处理用时：28.96秒
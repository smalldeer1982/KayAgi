# 题目信息

# Annoying Present

## 题目描述

`Alice` 又得到了一个长度为 $n$ 的数组作为生日礼物！这是她得到这样的礼物的第三年了！



更令人失望的是，这个数组非常无趣，每个元素都是 $0$ 。`Bob` 决定对数组进行一些修改使 `Alice` 兴♂奋起来。



`Bob` 进行了以下的 $m$ 次修改。每次修改包含 $2$ 个整数 $ x $ 和 $d$ 。他选择一个任意位置 $i (1 \le i \le n)$，并且对于每个 $j \in [1，n]$ ，会把第 $j$ 个单元格的值加上 $x + d \cdot dist(i，j)$ 。 $dist(i，j)$ 是位置 $i$ 和 $j$ 之间的距离（即 $dist(i,j)= | i-j |$ ，其中 $|x|$ 是 $x$ 的绝对值。)



例如，如果 `Alice` 当前有着数组 $ [2,1,2,2] $，而 `Bob` 选择位置 $3$ 来执行修改 $x = -1$ 和 $d = 2$ ，则该数组将变成 $[2-1 + 2 \cdot 2，1-1 + 2 \cdot 1，2-1 + 2 \cdot 0，2-1 + 2 \cdot 1] =  [5,2,1,3]$。请注意，`Bob` 不能在数组之外选择位置 $i$（即 $i$ 必须在 $1 $ ~ $ n$ 范围内）。



当数组中的元素尽可能大时，`Alice` 将是最快乐的。 `Bob` 声称数组元素的算术平均值可以很好地用作度量。



`Bob` 可以达到的最大算术平均值是多少？

## 样例 #1

### 输入

```
2 3
-1 3
0 0
-1 -4
```

### 输出

```
-2.500000000000000
```

## 样例 #2

### 输入

```
3 2
0 2
5 0
```

### 输出

```
7.000000000000000
```

# AI分析结果

【题目内容】
# 烦人的礼物

## 题目描述

`Alice` 又得到了一个长度为 $n$ 的数组作为生日礼物！这是她得到这样的礼物的第三年了！

更令人失望的是，这个数组非常无趣，每个元素都是 $0$ 。`Bob` 决定对数组进行一些修改使 `Alice` 兴♂奋起来。

`Bob` 进行了以下的 $m$ 次修改。每次修改包含 $2$ 个整数 $ x $ 和 $d$ 。他选择一个任意位置 $i (1 \le i \le n)$，并且对于每个 $j \in [1，n]$ ，会把第 $j$ 个单元格的值加上 $x + d \cdot dist(i，j)$ 。 $dist(i，j)$ 是位置 $i$ 和 $j$ 之间的距离（即 $dist(i,j)= | i-j |$ ，其中 $|x|$ 是 $x$ 的绝对值。)

例如，如果 `Alice` 当前有着数组 $ [2,1,2,2] $，而 `Bob` 选择位置 $3$ 来执行修改 $x = -1$ 和 $d = 2$ ，则该数组将变成 $[2-1 + 2 \cdot 2，1-1 + 2 \cdot 1，2-1 + 2 \cdot 0，2-1 + 2 \cdot 1] =  [5,2,1,3]$。请注意，`Bob` 不能在数组之外选择位置 $i$（即 $i$ 必须在 $1 $ ~ $ n$ 范围内）。

当数组中的元素尽可能大时，`Alice` 将是最快乐的。 `Bob` 声称数组元素的算术平均值可以很好地用作度量。

`Bob` 可以达到的最大算术平均值是多少？

## 样例 #1

### 输入

```
2 3
-1 3
0 0
-1 -4
```

### 输出

```
-2.500000000000000
```

## 样例 #2

### 输入

```
3 2
0 2
5 0
```

### 输出

```
7.000000000000000
```

【算法分类】
数学

【题解分析与结论】
本题的核心在于通过数学分析找到每次修改对数组总和的最大贡献。所有题解都基于以下思路：
1. 每次修改的总和为 $n \cdot x + d \cdot \sum_{j=1}^n |i-j|$。
2. 当 $d > 0$ 时，选择 $i$ 使得 $\sum_{j=1}^n |i-j|$ 最大，即 $i=1$ 或 $i=n$。
3. 当 $d < 0$ 时，选择 $i$ 使得 $\sum_{j=1}^n |i-j|$ 最小，即 $i$ 为数组中间位置。

【评分较高的题解】
1. **作者：Wendy_Hello_qwq (4星)**
   - 关键亮点：清晰地分析了 $d$ 的正负对总和的影响，并计算了最大值和最小值。
   - 代码实现简洁，直接计算了最大值和最小值，并在循环中根据 $d$ 的正负进行累加。

```cpp
double res;
long long n, m, x, d, max1, min1;
int main() {
    scanf ("%lld%lld", &n, &m);
    max1 = n * (n - 1) / 2;
    min1 = (n / 2) * (n / 2 + 1);
    if (n % 2 == 0)
        min1 = min1 - n / 2;
    for (int i = 1; i <= m; i++) {
        scanf ("%lld%lld", &x, &d);
        res = res + x * n;
        if (d > 0)
            res = res + max1 * d;
        else
            res = res + min1 * d;
    }
    printf ("%.10lf", res / (n * 1.0));
    return 0;
}
```

2. **作者：__Immorta__ (4星)**
   - 关键亮点：详细解释了选择 $i$ 的位置对总和的影响，并通过代码实现了这一逻辑。
   - 代码结构清晰，逻辑明确，适合初学者理解。

```cpp
for (int i=1;i<=m;i++){
    int x,y;
    cin>>x>>y;
    int cnt=n/2;
    for(int j=1;j<=n;j++) {
        num[j]+=x+y*abs(cnt-j);
    }
}
double sum=0;
for (int i=1;i<=n;i++) {
    sum+=num[i];
}
```

3. **作者：Never_care (4星)**
   - 关键亮点：简洁明了地实现了核心逻辑，代码效率高。
   - 代码中直接计算了最大值和最小值，并在循环中根据 $d$ 的正负进行累加。

```cpp
ll n,m;
int main(){
    cin>>n>>m;
    ll maxx=n*(n-1)/2;
    ll minx=(n/2)*(n/2+1);
    if(n%2==0){
        minx=minx-(n/2);
    }
    double temp=0;
    for(int i=1;i<=m;i++){
        ll x,d;
        cin>>x>>d;
        temp+=n*x;
        if(d>0){
            temp+=d*maxx;
        }else temp+=minx*d;
    }
    cout<<fixed<<setprecision(10)<<temp/(n*1.0);
    return 0;
}
```

【最优关键思路】
1. 通过数学分析确定每次修改对总和的最大贡献。
2. 根据 $d$ 的正负选择不同的 $i$ 位置，使得 $\sum_{j=1}^n |i-j|$ 最大化或最小化。
3. 提前计算最大值和最小值，避免在循环中重复计算。

【可拓展之处】
类似的问题可以通过分析每次操作对结果的影响，选择最优策略来最大化或最小化目标值。例如，在动态规划或贪心算法中，常常需要根据当前状态选择最优决策。

【推荐题目】
1. [CF1009C - Annoying Present](https://www.luogu.com.cn/problem/CF1009C)
2. [P3817 小A的糖果](https://www.luogu.com.cn/problem/P3817)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：45.98秒
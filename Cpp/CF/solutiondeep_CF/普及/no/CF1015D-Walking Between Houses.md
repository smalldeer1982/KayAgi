# 题目信息

# Walking Between Houses

## 题目描述

在一条路上，$n$ 个房子被排成一排，从从左到右编号为 $1\sim n$。一开始，你站在 $1$ 号房子前。

你需要移动到其他的房子 $k$ 次。每一次移动，你不能原地不动（即移动后与移动前，你必须在不同的房子前面）。如果你从 $x$ 房子移动到 $y$ 房子，那么你走过的距离就是 $\left\vert x-y \right\vert$，这里 $\left\vert a \right\vert$ 表示 $a$ 的绝对值。当然，你可以访问同一个房子多次。（只要不连续就行了）

你的目标是一共走 $s$ 个单位长度。

如果是不可能的，输出 $\texttt{NO}$，否则输出 $\texttt{YES}$，并输出任意一种移动方案，记住你只能走恰好 $k$ 次。

## 样例 #1

### 输入

```
10 2 15
```

### 输出

```
YES
10 4 
```

## 样例 #2

### 输入

```
10 9 45
```

### 输出

```
YES
10 1 10 1 2 1 2 1 6 
```

## 样例 #3

### 输入

```
10 9 81
```

### 输出

```
YES
10 1 10 1 10 1 10 1 10 
```

## 样例 #4

### 输入

```
10 9 82
```

### 输出

```
NO
```

# AI分析结果

【题目内容】
# Walking Between Houses

## 题目描述

在一条路上，$n$ 个房子被排成一排，从从左到右编号为 $1\sim n$。一开始，你站在 $1$ 号房子前。

你需要移动到其他的房子 $k$ 次。每一次移动，你不能原地不动（即移动后与移动前，你必须在不同的房子前面）。如果你从 $x$ 房子移动到 $y$ 房子，那么你走过的距离就是 $\left\vert x-y \right\vert$，这里 $\left\vert a \right\vert$ 表示 $a$ 的绝对值。当然，你可以访问同一个房子多次。（只要不连续就行了）

你的目标是一共走 $s$ 个单位长度。

如果是不可能的，输出 $\texttt{NO}$，否则输出 $\texttt{YES}$，并输出任意一种移动方案，记住你只能走恰好 $k$ 次。

## 样例 #1

### 输入

```
10 2 15
```

### 输出

```
YES
10 4 
```

## 样例 #2

### 输入

```
10 9 45
```

### 输出

```
YES
10 1 10 1 2 1 2 1 6 
```

## 样例 #3

### 输入

```
10 9 81
```

### 输出

```
YES
10 1 10 1 10 1 10 1 10 
```

## 样例 #4

### 输入

```
10 9 82
```

### 输出

```
NO
```

【算法分类】
构造

【题解分析与结论】
本题的核心在于如何构造一个合法的移动方案，使得在恰好 $k$ 次移动中，总步长为 $s$。题解中大多数作者都采用了类似的思路：首先判断 $s$ 是否在合法范围内（$k \leq s \leq k(n-1)$），然后通过平均分配步长和余数的方式来构造方案。以下是对部分题解的总结与评价。

【所选高星题解】
1. **作者：1517460958dyc (赞：6)**  
   - **星级：4.5**  
   - **关键亮点**：采用分步方法，先处理余数部分，再处理不带余数的部分，思路清晰，代码简洁。  
   - **代码核心思想**：  
     ```cpp
     for (int i=1;i<=s%k;i++) {
         if (i&1) t=s/k+2;
         else t=1;
         cout<<t<<' ';
     }
     for (int i=s%k+1;i<=k;i++) {
         if (t<=(s/k)) t+=s/k;
         else t-=s/k;
         cout<<t<<' ';
     }
     ```
   - **个人心得**：作者提到此题难度不高，预祝大家AK Div.3，体现了对题目的自信。

2. **作者：zhangqiuyanAFOon2024 (赞：2)**  
   - **星级：4**  
   - **关键亮点**：利用数学公式 $\lfloor\frac{a}{b}\rfloor\times b+a\bmod b=a$ 来构造方案，思路严谨。  
   - **代码核心思想**：  
     ```cpp
     for(int i=1;i<=s%k;i++){
        if(i%2==0) cout<<1<<' ',cnt=1;
        else cout<<s/k+2<<' ',cnt=s/k+2;
     }
     for(int i=s%k+1;i<=k;i++){
        if(cnt<=s/k) cout<<cnt+s/k<<' ',cnt+=s/k;
        else cout<<cnt-s/k<<' ',cnt-=s/k;
     }
     ```
   - **个人心得**：作者强调了开 `long long` 的重要性，提醒注意越界问题。

3. **作者：Ryan_Adam (赞：1)**  
   - **星级：4**  
   - **关键亮点**：详细分析了 $k\mid s$ 和 $k\nmid s$ 的情况，并给出了具体的构造方案，思路清晰。  
   - **代码核心思想**：  
     ```cpp
     for(int i=1;i<=k;i++){
        if(i&1) v.push_back(ceil(s*1.0/k)+1);
        else v.push_back(1);
     }
     if(s%k){
        int ss=ceil(s*1.0/k)*k-s;
        for(int i=1;i<=k&&ss-2>=0;i+=2){
            ss-=2;
            v[i-1]--;
        }
     }
     ```
   - **个人心得**：作者提到在余数为奇数时需要分类讨论，体现了对细节的把握。

【最优关键思路】
1. **平均分配步长**：将总步长 $s$ 平均分配到 $k$ 次移动中，余数部分通过前几次移动多走一步来处理。
2. **来回移动**：通过来回移动的方式，确保每次移动的步长不超过 $n-1$，并且总步长恰好为 $s$。

【拓展思路】
类似的问题可以通过平均分配和余数处理的方式来构造方案，尤其是在需要精确控制步长或次数的情况下。例如，某些路径规划问题或资源分配问题也可以采用类似的思路。

【推荐题目】
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008) - 构造类问题，考察如何通过合理的分配达到目标。
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012) - 构造类问题，考察如何通过拼接数字达到最大或最小目标。
3. [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019) - 构造类问题，考察如何通过拼接单词达到最长的接龙。

---
处理用时：42.88秒
# 题目信息

# Reach Median

## 题目描述

**题目大意：**

给定一个长度为$n$的序列和一个整数$s$，$n$一定为奇数

一次操作可以将序列中的某个数$+1$或者$-1$，问至少几次操作可以使这个序列的中位数等于$s$

## 样例 #1

### 输入

```
3 8
6 5 8
```

### 输出

```
2```

## 样例 #2

### 输入

```
7 20
21 15 12 11 20 19 12
```

### 输出

```
6```

# AI分析结果

### 题目内容重写
**题目名称：** 达到中位数

**题目描述：**

给定一个长度为$n$的序列和一个整数$s$，$n$一定为奇数。

一次操作可以将序列中的某个数$+1$或者$-1$，问至少几次操作可以使这个序列的中位数等于$s$。

**样例 #1**

输入：
```
3 8
6 5 8
```
输出：
```
2
```

**样例 #2**

输入：
```
7 20
21 15 12 11 20 19 12
```
输出：
```
6
```

### 算法分类
贪心

### 题解综合分析
所有题解都采用了贪心算法的思路，核心思想是通过排序后，根据当前中位数与目标中位数$s$的关系，分别处理序列的左半部分或右半部分，累加需要调整的差值。具体来说：
1. 如果当前中位数等于$s$，直接输出0。
2. 如果当前中位数大于$s$，则从左半部分累加大于$s$的差值。
3. 如果当前中位数小于$s$，则从右半部分累加小于$s$的差值。

### 所选高分题解
#### 题解1：Creator_157 (4星)
**关键亮点：**
- 思路清晰，代码简洁。
- 详细解释了中位数的定义和计算方式。
- 代码中使用了`long long`类型，避免了溢出问题。

**核心代码：**
```cpp
sort(a+1,a+n+1);
if(a[(n+1)/2]>s) {
    for(int i=1;i<=(n+1)/2;i++) {
        if(a[i]>s) ans+=a[i]-s;
    }
} else if(a[(n+1)/2]<s) {
    for(int i=(n+1)/2;i<=n;i++) {
        if(a[i]<s) ans+=s-a[i];
    }
}
cout<<ans;
```

#### 题解2：Hiraeth (4星)
**关键亮点：**
- 代码结构清晰，逻辑明确。
- 同样使用了`long long`类型，确保了数据的正确性。
- 通过分治思想，分别处理左半部分和右半部分。

**核心代码：**
```cpp
sort(a+1,a+n+1);
for (int i=1;i<=mid;i++)
    if (a[i]>p) ans+=a[i]-p;
for (int i=mid;i<=n;i++)
    if (a[i]<p) ans+=p-a[i];
printf("%lld\n",ans);
```

#### 题解3：JimmyF (4星)
**关键亮点：**
- 详细分析了三种情况，并给出了具体的例子。
- 代码中使用了`abs`函数，确保了差值的正确计算。
- 通过贪心策略，优化了操作次数。

**核心代码：**
```cpp
if(a[(n+1)/2]>s) {
    for(int i=1; i<=(n+1)/2; i++)
        if(a[i]>s) d+=abs(s-a[i]);
    cout<<d;
} else if(a[(n+1)/2]<s) {
    for(int i=(n+1)/2; i<=n; i++)
        if(a[i]<s) dd+=abs(s-a[i]);
    cout<<dd;
}
```

### 最优关键思路
1. **排序**：首先对序列进行排序，确保中位数的位置明确。
2. **贪心策略**：根据当前中位数与目标中位数的关系，分别处理序列的左半部分或右半部分，累加需要调整的差值。
3. **数据类型**：使用`long long`类型，避免溢出问题。

### 可拓展之处
类似的问题可以通过排序和贪心策略来解决，例如调整序列的均值或众数等。

### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：34.13秒
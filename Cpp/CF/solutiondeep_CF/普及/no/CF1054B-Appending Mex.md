# 题目信息

# Appending Mex

## 题目描述

一开始有一个空的序列，每一次可以选取这个序列的一个子序列，并将这个子序列的 $\text{mex}$ 值加入到序列的尾部。

给定长度为 $n$ 的序列 $a_i$，求最小的 $t$ 使得无法通过若干次操作得到序列 $a_1,\ldots,a_t$。

## 样例 #1

### 输入

```
4
0 1 2 1
```

### 输出

```
-1```

## 样例 #2

### 输入

```
3
1 0 1
```

### 输出

```
1```

## 样例 #3

### 输入

```
4
0 1 2 239
```

### 输出

```
4```

# AI分析结果

### 题目内容重写

**题目描述**

一开始有一个空的序列，每一次可以选取这个序列的一个子序列，并将这个子序列的 $\text{mex}$ 值加入到序列的尾部。

给定长度为 $n$ 的序列 $a_i$，求最小的 $t$ 使得无法通过若干次操作得到序列 $a_1,\ldots,a_t$。

**样例 #1**

输入：
```
4
0 1 2 1
```
输出：
```
-1
```

**样例 #2**

输入：
```
3
1 0 1
```
输出：
```
1
```

**样例 #3**

输入：
```
4
0 1 2 239
```
输出：
```
4
```

### 算法分类
贪心

### 题解分析与结论

各题解的核心思路基本一致，都是通过维护一个变量 `maxn` 来表示当前序列中已经出现的最大值，然后遍历数组 `a`，检查每个元素是否满足 `a[i] <= maxn + 1`。如果不满足，则输出当前下标 `i`；否则更新 `maxn`。最终如果所有元素都满足条件，则输出 `-1`。

### 评分较高的题解

#### 1. 作者：John_yangliwu (4星)
**关键亮点：**
- 思路清晰，逻辑严谨，代码简洁。
- 通过维护 `maxi` 变量来判断当前元素是否可以被构造，符合贪心算法的思想。

**代码片段：**
```cpp
int maxi = -1;
for(int i = 1; i <= n; i++) {
    if(a[i] > maxi + 1) {
        t = i; break;
    }
    else maxi = max(maxi, a[i]);
}
```

#### 2. 作者：ylch (4星)
**关键亮点：**
- 详细解释了 `mex` 的定义及其在题目中的应用。
- 代码结构清晰，变量命名合理，易于理解。

**代码片段：**
```cpp
int maxx = -1, t = -1;
for(int i = 1; i <= n; i++){
    if(a[i] > maxx + 1){ t = i; break; }
    maxx = max(maxx, a[i]);
}
```

#### 3. 作者：Konnyaku_LXZ (4星)
**关键亮点：**
- 通过维护 `maxx` 变量来判断当前元素是否可以被构造，符合贪心算法的思想。
- 代码简洁，逻辑清晰，易于理解。

**代码片段：**
```cpp
int maxx = -1;
for(int i = 1; i <= n; i++) {
    if(a[i] > maxx + 1){ Ans = i; return; }
    else maxx = max(maxx, a[i]);
}
```

### 最优关键思路或技巧
- **贪心算法**：通过维护一个变量 `maxn` 来表示当前序列中已经出现的最大值，然后遍历数组 `a`，检查每个元素是否满足 `a[i] <= maxn + 1`。如果不满足，则输出当前下标 `i`；否则更新 `maxn`。
- **代码实现技巧**：使用 `maxn` 变量来记录当前序列中已经出现的最大值，通过简单的条件判断即可确定当前元素是否可以被构造。

### 可拓展之处
- 类似的问题可以通过维护一个变量来表示当前序列中已经出现的最大值或最小值，然后通过简单的条件判断来确定当前元素是否可以被构造。

### 推荐题目
1. [CF1054B - Appending Mex](https://www.luogu.com.cn/problem/CF1054B)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：29.92秒
# 题目信息

# Math

## 题目描述

JATC的数学老师为了不让同学们感到厌倦，总是出一些有趣的题目。今天的题目是这样的：  

给定一个整数`n`，您可以对它进行如下操作：  

* 乘以`x`：把n乘上x（x是任意正整数）。

* 开方：把n的值更新为$\sqrt{n}$ (前提是$\sqrt{n}$必须为整数)。  

您可以对这些操作进行零次至任意次。那么n可以达到的最小值是多少 ？达到最小值需要进行操作的次数又是多少？  

显然，班里没有同学能够解决这个问题，您能够帮帮他吗？

## 说明/提示

在样例1中，可以先乘上5得到100，再开方得到10。  

在样例2中，可以先开方得到72，再乘18得到1296，最后再开方两次，最终得到6。

注意，即使$n$小于等于$10^6$，它仍然可以在一次或数次操作后超过$10^6$。

## 样例 #1

### 输入

```
20
```

### 输出

```
10 2```

## 样例 #2

### 输入

```
5184
```

### 输出

```
6 4```

# AI分析结果

### 题目内容重写
JATC的数学老师为了不让同学们感到厌倦，总是出一些有趣的题目。今天的题目是这样的：  

给定一个整数`n`，您可以对它进行如下操作：  

* 乘以`x`：把n乘上x（x是任意正整数）。

* 开方：把n的值更新为$\sqrt{n}$ (前提是$\sqrt{n}$必须为整数)。  

您可以对这些操作进行零次至任意次。那么n可以达到的最小值是多少 ？达到最小值需要进行操作的次数又是多少？  

显然，班里没有同学能够解决这个问题，您能够帮帮他吗？

### 算法分类
数学

### 题解分析与结论
所有题解的核心思路都是通过质因数分解来找到`n`的最小值，并通过乘法操作和开方操作来达到这个最小值。具体来说，最小值是`n`的所有质因数的乘积，而操作次数则取决于质因数的指数是否能够通过开方操作逐步减少到1。

### 所选高星题解
#### 题解1：Insouciant21 (4星)
**关键亮点**：
- 通过质因数分解找到最小值。
- 通过乘法操作使所有质因数的指数变为2的幂次，然后进行开方操作。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
void factor(int n) {
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0) n /= i;
            ans *= i;
        }
    }
    if (n > 1)
        ans *= n;
}

int main() {
    scanf("%d", &n);
    factor(n);
    long long res = ans;
    int step = 0;
    while (res % n != 0) {
        res *= res;
        step++;
    }
    if (res > n)
        step++;
    printf("%d %d", ans, step);
    return 0;
}
```

#### 题解2：过氧化氢_syq0057 (4星)
**关键亮点**：
- 详细解释了质因数分解和操作次数的计算。
- 考虑了特殊情况，如`n`为素数时无需操作。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
int solve(ll x) {
    int cnt = 0, res = 0, i = 1;
    while (x != 1 && (ll)pow(x, 0.5) * (ll)pow(x, 0.5) == x) x = pow(x, 0.5), cnt++;
    if (x == 1) {
        num = cnt;
        return 0;
    }
    num += 1 + cnt;
    while (x != 1) {
        cnt = 0;
        while (x % prime[i] == 0) x /= prime[i], cnt++;
        if (cnt) ans *= prime[i];
        i++;
        res = (res > cnt ? res : cnt);
    }
    if (res == 1) num--;
    return res > 1 ? res : 0;
}
```

#### 题解3：__Hacheylight__ (4星)
**关键亮点**：
- 通过质因数分解找到最小值。
- 通过一次乘法和多次开方操作来达到最小值。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
int main() {
    scanf("%lld", &n) ; tot = n ;
    for (int i = 2; i <= n; i++) {
        if (tot % i == 0) {
            num *= i ;
            while (tot % i == 0) tot /= i ;
        }
    }
    ll ans = 0, tmp = num ;
    while (num % n) {
        num *= num ;
        ans++ ;
    }
    printf("%lld %lld\n", tmp, num > n ? ans + 1 : ans) ;
}
```

### 最优关键思路或技巧
1. **质因数分解**：通过质因数分解找到`n`的最小值，即所有质因数的乘积。
2. **乘法与开方操作**：通过一次乘法操作使所有质因数的指数变为2的幂次，然后进行多次开方操作。
3. **特殊情况处理**：如`n`为素数时无需操作，直接输出`n`和0。

### 可拓展之处
- 类似的问题可以通过质因数分解和操作次数计算来解决，如通过乘法、除法、开方等操作来达到目标值。
- 可以扩展到更复杂的操作，如加减法、指数运算等。

### 推荐题目
1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
2. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)
3. [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)

### 个人心得摘录
- **Insouciant21**：通过质因数分解和乘法操作使所有质因数的指数变为2的幂次，然后进行开方操作，思路清晰。
- **过氧化氢_syq0057**：详细解释了质因数分解和操作次数的计算，考虑了特殊情况，代码结构清晰。
- **__Hacheylight__**：通过一次乘法和多次开方操作来达到最小值，代码简洁，逻辑清晰。

---
处理用时：37.68秒
# 题目信息

# Books Queries

## 题目描述

## 题意描述

### 您需要维护一个数据结构，支持以下三种操作：

* $L$ $id$：在现在序列的左边插一个编号为$id$的物品
* $R$ $id$：在现在序列的右边插一个编号为$id$的物品
* $?$ $id$：查询该点左面有几个元素，右面有几个元素，并取min输出

## 样例 #1

### 输入

```
8
L 1
R 2
R 3
? 2
L 4
? 1
L 5
? 1
```

### 输出

```
1
1
2
```

## 样例 #2

### 输入

```
10
L 100
R 100000
R 123
L 101
? 123
L 10
R 115
? 100
R 110
? 115
```

### 输出

```
0
2
1
```

# AI分析结果

### 题目内容重写
# Books Queries

## 题目描述

您需要维护一个数据结构，支持以下三种操作：

* $L$ $id$：在现在序列的左边插一个编号为$id$的物品
* $R$ $id$：在现在序列的右边插一个编号为$id$的物品
* $?$ $id$：查询该点左面有几个元素，右面有几个元素，并取min输出

## 样例 #1

### 输入

```
8
L 1
R 2
R 3
? 2
L 4
? 1
L 5
? 1
```

### 输出

```
1
1
2
```

## 样例 #2

### 输入

```
10
L 100
R 100000
R 123
L 101
? 123
L 10
R 115
? 100
R 110
? 115
```

### 输出

```
0
2
1
```

### 算法分类
模拟、队列

### 题解分析与结论
题目要求维护一个数据结构，支持在序列的左右两端插入元素，并查询某个元素左右两侧的元素个数的最小值。大部分题解都采用了数组模拟双端队列的思路，通过维护两个指针 `L` 和 `R` 来表示当前序列的左右边界，并使用一个数组来记录每个元素的索引位置。这种方法的优点是实现简单，且时间复杂度为 $O(1)$，能够高效处理插入和查询操作。

### 高星题解推荐

#### 题解作者：Binary_Search_Tree (赞：7)
**星级：5星**
**关键亮点：**
- 使用了数组模拟双端队列，通过调整数组下标避免了负数下标的问题。
- 代码简洁明了，逻辑清晰，易于理解。
- 使用了快读优化输入输出，提高了代码效率。

**核心代码：**
```cpp
int q,L,R;//L为左端点，R为右端点
int a[M],s[M];//a[]为题目中的数组，s[x]表示编号为x的元素在a数组中的下标
int main(){
	q=read();
	L=MAXN+1,R=MAXN;//开始时L=R+1,数组为空
    while (q--){
		char c=readc();int now=read();
		if (c=='L') a[--L]=now,s[now]=L;
		if (c=='R') a[++R]=now,s[now]=R;
		if (c=='?') printf("%d\n",min(s[now]-L,R-s[now]));//输出最小值
	}
	return 0;
}
```

#### 题解作者：liangbowen (赞：1)
**星级：4星**
**关键亮点：**
- 使用了数组模拟双端队列，通过初始化 `L` 和 `R` 为较大值，避免了负数下标的问题。
- 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
const int N = 2e5;
int mp[N << 1 + 5], l = N+1, r = N; //原本是 l=1 与 r=0，补后变为 l=N+1 与 r=N。 
int main(){
	fastio();
	int Q;
	cin >> Q;
	while (Q--){
		char op; int x;
		cin >> op >> x;
		if (op == 'L') mp[x] = --l;
		else if (op == 'R') mp[x] = ++r;
		else if (op == '?') cout << min(mp[x] - l, r - mp[x]) << '\n';
	}
	return 0;
}
```

#### 题解作者：EDqwq (赞：1)
**星级：4星**
**关键亮点：**
- 使用了数组模拟双端队列，通过初始化 `l` 和 `r` 为较大值，避免了负数下标的问题。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
int l = 1000001,r = 1000002;
cin>>n;
for(int i = 1;i <= n;i ++){
	char op;
	int x;
	scanf(" %c ",&op);
	x = read();
	if(op == 'L'){
		a[l] = x;
		q[x] = l;
		l --;
	}
	else if(op == 'R'){
		a[r] = x;
		q[x] = r;
		r ++;
	}
	else {
		printf("%lld\n",min(r - q[x] - 1,q[x] - l - 1));
	}
}
```

### 最优关键思路
1. **数组模拟双端队列**：通过维护两个指针 `L` 和 `R` 来表示当前序列的左右边界，并使用一个数组来记录每个元素的索引位置。这种方法简单高效，能够处理插入和查询操作。
2. **避免负数下标**：通过将 `L` 和 `R` 初始化为较大的值，避免了负数下标的问题。

### 可拓展之处
- 类似的问题可以使用双端队列（deque）来解决，但数组模拟的方法在时间和空间上更为高效。
- 可以进一步优化输入输出，使用更高效的IO方法。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：42.02秒
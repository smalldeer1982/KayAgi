# 题目信息

# Treasure Island

## 题目描述

我们勇敢的旅行者到达一个岛上，海盗在那里埋下了财宝。然而，当船即将停泊时，船长发现藏宝图被老鼠吃掉了一部分。



藏宝图可以表示为一个大小为$n\times m$的网格图。每个单元格代表地图上的一块正方形（正方形的边长等于一英里）。有些单元格代表海洋，它们是不可达的。所有其他单元格都是可达的，其中一些单元格有视野。



此外，地图还有一套共$k$个指令。每个指令的格式如下：“沿$y$方向走$n$英里”



可能的方向有：北、南、东和西。如果你仔细地遵循这些指示（你应该一个接一个地完成所有的指示），那么你应该准确地到达埋藏宝藏的地方。



不幸的是，船长不知道从哪个单元格开始执行指令，因为地图上的那一部分已经丢失了。但是船长很清楚地记得那个单元格有视野。另外，船长知道整个过程都经过岛上的可达单元格。



船长想知道哪些单元格值得一看。

## 样例 #1

### 输入

```
6 10
##########
#K#..#####
#.#..##.##
#..L.#...#
###D###A.#
##########
4
N 2
S 1
E 1
W 2
```

### 输出

```
AD```

## 样例 #2

### 输入

```
3 4
####
#.A#
####
2
W 1
N 2
```

### 输出

```
no solution```

# AI分析结果



### 中文重写题目

# 宝藏岛

## 题目描述

勇敢的探险家抵达一座埋藏宝藏的岛屿。但当船只即将靠岸时，船长发现藏宝图被老鼠啃食了一部分。

藏宝图可视为一个 $n \times m$ 的网格。每个单元格代表地图上的一个正方形区域（边长为1英里）。部分单元格标记为海洋（`#`），不可通行。其余单元格为可达区域，其中部分单元格带有视野标记（大写字母）。

地图附带 $k$ 条移动指令，格式为："方向 距离"。方向可为北（N）、南（S）、东（E）、西（W）。严格按顺序执行所有指令后，即可抵达宝藏所在位置。

船长不记得起点位置，但确定该点有视野且所有移动均在可达区域完成。请找出所有可能的起点字母，按字典序输出。若无解则输出 `no solution`。

---

### 算法分类
前缀和、模拟

---

### 题解分析与结论

**核心思路**：  
使用行、列前缀和数组快速判断移动路径中是否存在障碍物。预处理每个位置的行列障碍物累计值，在模拟移动时通过差值判断路径合法性，将时间复杂度从 $O(k \cdot len)$ 优化至 $O(k)$。

**关键优化**：  
1. **前缀和预处理**：对每行/列维护前缀和数组，记录该行/列前若干位置的障碍物数量。
2. **路径判断**：通过起点与终点的前缀和差值是否为0，判断该段路径是否全为可达区域。
3. **坐标合法性**：在每次移动后立即检查坐标是否越界。

---

### 精选题解

#### 题解1：ikunTLE（⭐⭐⭐⭐⭐）
**亮点**：  
- 清晰的预处理逻辑，独立维护行、列前缀和数组。
- 使用方向向量数组简化坐标计算。
- 代码结构紧凑，可读性强。

**核心代码**：
```cpp
// 预处理行、列前缀和
for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j){
        r[i][j] = r[i][j-1] + (s[i][j]!='#');
        c[i][j] = c[i-1][j] + (s[i][j]!='#');
    }

// 模拟指令执行
for(auto it:vc){
    int x=it.x, y=it.y;
    bool valid = true;
    for(int i=1; i<=T; ++i){
        // 计算移动后的坐标
        int xx = x + dx[op[i]] * len[i];
        int yy = y + dy[op[i]] * len[i];
        // 边界检查
        if(xx < 1 || xx > n || yy < 1 || yy > m) { valid = false; break; }
        // 路径检查
        if(op[i] >=3) { // 横向移动
            if(r[xx][max(y,yy)] - r[xx][min(y,yy)-1] != len[i]+1)
                valid = false;
        } else { // 纵向移动
            if(c[max(x,xx)][yy] - c[min(x,xx)-1][yy] != len[i]+1)
                valid = false;
        }
        x = xx; y = yy;
    }
    if(valid) ans += s[it.x][it.y];
}
```

---

### 类似题目推荐
1. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135) - BFS模拟移动过程  
2. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719) - 二维前缀和经典应用  
3. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 差分与前缀和的综合应用

---
处理用时：74.33秒
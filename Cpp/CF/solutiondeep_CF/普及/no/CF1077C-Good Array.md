# 题目信息

# Good Array

## 题目描述

一个序列是好的当且仅当有一个数是其它所有数的和，比如$a=[1,3,3,7]$中$7=1+3+3$，所以这个序列是好的。

给你长度为$n$的序列$a$，你的任务是输出所有的$j$使得去掉$a_j$后的序列是好的。

举例，$a=[8,3,5,2]$，答案是$1$和$4$

- 如果你去掉$a_1$，剩下$[3,5,2]$，是好的
- 如果你去掉$a_4$，剩下$[8,3,5]$，是好的

你需要**独立地**检查所有项。比方说你去掉这个数，然后检查剩下的序列是否是好的，然后再放回去。

## 样例 #1

### 输入

```
5
2 5 1 2 2
```

### 输出

```
3
4 1 5```

## 样例 #2

### 输入

```
4
8 3 5 2
```

### 输出

```
2
1 4 
```

## 样例 #3

### 输入

```
5
2 1 2 4 3
```

### 输出

```
0

```

# AI分析结果

### 题目重写
# Good Array

## 题目描述

一个序列是好的当且仅当有一个数是其它所有数的和，比如$a=[1,3,3,7]$中$7=1+3+3$，所以这个序列是好的。

给你长度为$n$的序列$a$，你的任务是输出所有的$j$使得去掉$a_j$后的序列是好的。

举例，$a=[8,3,5,2]$，答案是$1$和$4$

- 如果你去掉$a_1$，剩下$[3,5,2]$，是好的
- 如果你去掉$a_4$，剩下$[8,3,5]$，是好的

你需要**独立地**检查所有项。比方说你去掉这个数，然后检查剩下的序列是否是好的，然后再放回去。

## 样例 #1

### 输入

```
5
2 5 1 2 2
```

### 输出

```
3
4 1 5```

## 样例 #2

### 输入

```
4
8 3 5 2
```

### 输出

```
2
1 4 
```

## 样例 #3

### 输入

```
5
2 1 2 4 3
```

### 输出

```
0

```

### 算法分类
枚举

### 题解分析与结论
本题的核心思路是通过枚举每个元素，判断去掉该元素后剩下的序列是否满足“好的”条件。大多数题解都采用了类似的思路，即计算序列的总和，然后通过枚举每个元素，判断剩下的序列中是否存在一个数等于剩余元素和的一半。不同题解的主要区别在于数据结构的选用和优化方式。

### 精选题解
#### 题解1：作者：Yaha (赞：4)
- **星级**：★★★★★
- **关键亮点**：使用`map`来存储元素出现次数，避免了数组空间不足的问题，代码简洁高效。
- **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    if((s-a[i])%2) continue;//排除不能整除的情况
    M[a[i]]--;//取掉i
    if(M[(s-a[i])/2]>0) V.push_back(i);
    M[a[i]]++;//放回i
}
```
- **实现思想**：通过`map`记录每个元素的出现次数，枚举每个元素，判断去掉该元素后是否存在一个数等于剩余和的一半。

#### 题解2：作者：Dilute (赞：3)
- **星级**：★★★★
- **关键亮点**：通过排序和特判处理，简化了判断逻辑，代码结构清晰。
- **核心代码**：
```cpp
if(Sum - s[1].x - s[2].x == s[2].x) // 特判去掉1的情况
    Ans[++Cnt] = s[1].k;
for(int i = 2; i <= n; i++){
    if(Sum - s[1].x - s[i].x == s[1].x)
        Ans[++Cnt] = s[i].k;
}
```
- **实现思想**：先排序，然后特判去掉第一个元素的情况，再枚举其他元素，判断去掉后是否满足条件。

#### 题解3：作者：vocaloid (赞：2)
- **星级**：★★★★
- **关键亮点**：通过排序和额外判断，确保所有情况都被覆盖，代码逻辑严谨。
- **核心代码**：
```cpp
sum-=a[n].val;
for(int i=1;i<n;i++) if(sum-a[i].val==a[n].val) ans[++tot]=a[i].id;
if(sum-a[n-1].val==a[n-1].val) ans[++tot]=a[n].id;
```
- **实现思想**：先排序，然后枚举每个元素，判断去掉后是否满足条件，最后额外判断去掉最大元素的情况。

### 最优关键思路
使用`map`或排序来优化枚举过程中的查找操作，确保高效判断剩余序列是否满足条件。通过特判和额外判断，确保所有情况都被覆盖。

### 拓展思路
类似的问题可以通过枚举和优化查找操作来解决，例如在序列中寻找满足特定条件的子序列或元素。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)

---
处理用时：30.10秒
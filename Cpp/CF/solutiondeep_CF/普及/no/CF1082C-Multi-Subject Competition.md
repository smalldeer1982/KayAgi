# 题目信息

# Multi-Subject Competition

## 题目描述

现在有 $n$ 个人分成 $m$ 组，第 $i$ 个人属于第 $s_i$ 组，能力值为 $r_i$ 。 现在你要选择任意一些组，在这些组中选择相同数目的人，最大化他们的能力值总和。

## 样例 #1

### 输入

```
6 3
2 6
3 6
2 5
3 5
1 9
3 1
```

### 输出

```
22
```

## 样例 #2

### 输入

```
5 3
2 6
3 6
2 5
3 5
1 11
```

### 输出

```
23
```

## 样例 #3

### 输入

```
5 2
1 -1
1 -5
2 -1
2 -1
1 -10
```

### 输出

```
0
```

# AI分析结果

### 题目重写
# 多学科竞赛

## 题目描述

现在有 $n$ 个人分成 $m$ 组，第 $i$ 个人属于第 $s_i$ 组，能力值为 $r_i$ 。现在你要选择任意一些组，在这些组中选择相同数目的人，最大化他们的能力值总和。

## 样例 #1

### 输入

```
6 3
2 6
3 6
2 5
3 5
1 9
3 1
```

### 输出

```
22
```

## 样例 #2

### 输入

```
5 3
2 6
3 6
2 5
3 5
1 11
```

### 输出

```
23
```

## 样例 #3

### 输入

```
5 2
1 -1
1 -5
2 -1
2 -1
1 -10
```

### 输出

```
0
```

### 算法分类
贪心、前缀和

### 题解分析与结论
本题的核心在于如何高效地选择组和人数，以最大化能力值总和。各个题解的主要思路是通过排序和前缀和来优化计算过程，避免直接枚举所有可能的组合，从而降低时间复杂度。

### 所选题解
#### 1. 作者：redegg (赞：7)  
**星级：5星**  
**关键亮点：**  
- 通过排序和前缀和优化计算，避免了直接枚举所有组合。
- 代码简洁，思路清晰，易于理解。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
{
    sum[a[i].id]+=a[i].v;
    num[a[i].id]++;
    maxn=max(maxn,num[a[i].id]);
    if(sum[a[i].id]>0)ans[num[a[i].id]]+=sum[a[i].id];
}
```
**核心思想：**  
按能力值排序后，逐个累加各组的前缀和，并记录每个组在不同人数下的最大能力值总和。

#### 2. 作者：_louhc (赞：7)  
**星级：4星**  
**关键亮点：**  
- 通过排序和动态更新组的前缀和，优化了计算过程。
- 使用了队列来管理组的遍历顺序，减少了重复计算。

**核心代码：**
```cpp
for ( int i = 1; i <= N; ++i ){
    while( cur <= tot && (int)a[b[cur]].size() < i ) cur++;
    LL sum(0);
    for ( int j = cur; j <= tot; ++j ){
        f[b[j]] = max( 0ll, f[b[j]] + a[b[j]][i - 1] );
        sum += f[b[j]];
    }
    ans = max( ans, sum );
}
```
**核心思想：**  
按组的大小排序，逐个累加各组的前缀和，并动态更新组的贡献，避免重复计算。

#### 3. 作者：王熙文 (赞：5)  
**星级：4星**  
**关键亮点：**  
- 通过排序和前缀和优化了暴力算法，减少了时间复杂度。
- 使用了数组来记录每个组的前缀和，避免了重复计算。

**核心代码：**
```cpp
for(int i=0; i<maxlen; ++i)
{
    int sum=0,m1=0;
    for(int j=1; j<=m; ++j)
    {
        if(i<qzh[j].size())
        {
            sum+=max(qzh[j][i],0);
            qzh[++m1]=qzh[j];
        }
    }
    m=m1;
    ans=max(ans,sum);
}
```
**核心思想：**  
按组的大小排序，逐个累加各组的前缀和，并动态更新组的贡献，避免重复计算。

### 最优关键思路或技巧
- **排序与前缀和：** 通过将各组按能力值排序，并计算前缀和，可以高效地找到每个组在不同人数下的最大能力值总和。
- **动态更新：** 在计算过程中，动态更新组的贡献，避免重复计算，从而优化时间复杂度。

### 可拓展之处
- **类似题目：** 可以扩展到其他需要选择最优组合的问题，如选择最优的团队、最优的任务分配等。
- **算法套路：** 排序和前缀和的组合可以应用于多种优化问题，特别是在需要高效计算累加和的情况下。

### 推荐题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得
- **调试经历：** 在实现过程中，需要注意排序的顺序和前缀和的计算方式，确保每一步都正确无误。
- **踩坑教训：** 在动态更新组的贡献时，要确保不会重复计算或遗漏某些组，否则会导致结果不准确。
- **顿悟感想：** 通过排序和前缀和的组合，可以大大简化复杂问题的计算过程，提高算法的效率。

---
处理用时：39.53秒
# 题目信息

# Build a Contest

## 题目描述

### 题目大意
有$n$个题，每个题有一个难度$a_i(1\le a_i\le m)$，从左往右加入题，当加入的题中$m$个难度都出现时，输出$1$并把每个难度都删除一道题，否则输出$0$，求输出序列

## 样例 #1

### 输入

```
3 11
2 3 1 2 2 2 3 2 2 3 1
```

### 输出

```
00100000001
```

## 样例 #2

### 输入

```
4 8
4 1 3 3 2 3 3 3
```

### 输出

```
00001000
```

# AI分析结果

【题目内容】
# 构建比赛

## 题目描述

### 题目大意
有$n$个题，每个题有一个难度$a_i(1\le a_i\le m)$，从左往右加入题，当加入的题中$m$个难度都出现时，输出$1$并把每个难度都删除一道题，否则输出$0$，求输出序列

## 样例 #1

### 输入

```
3 11
2 3 1 2 2 2 3 2 2 3 1
```

### 输出

```
00100000001
```

## 样例 #2

### 输入

```
4 8
4 1 3 3 2 3 3 3
```

### 输出

```
00001000
```

【算法分类】  
模拟

【题解分析与结论】  
该题的核心逻辑是模拟题目的加入过程，并在满足条件时进行删除操作。题解主要集中在如何高效地判断是否所有难度都已出现，并在满足条件时进行删除操作。以下是各题解的要点对比：

1. **SOVOS的题解**  
   - 使用数组`nd`记录每种难度的题目数量，变量`allnd`记录当前已出现的难度种类数。
   - 每次加入题目时，更新`nd`和`allnd`，并在`allnd`等于$m$时输出$1$并删除所有难度的一道题。
   - **优化点**：通过`allnd`变量减少了对`nd`数组的遍历，提升了效率。
   - **评分**：4星（思路清晰，代码简洁，优化有效）

2. **Molina的题解**  
   - 使用桶数组`ton`记录每种难度的题目数量，变量`cnt`记录当前已出现的难度种类数。
   - 每次加入题目时，更新`ton`和`cnt`，并在`cnt`等于$m$时输出$1$并删除所有难度的一道题。
   - **评分**：3星（思路清晰，代码简洁，但未进行明显优化）

3. **da32s1da的题解**  
   - 使用队列`a`记录每种难度的题目，队列`Ans`记录当前已出现的难度。
   - 每次加入题目时，更新`a`和`Ans`，并在`Ans`的大小等于$m$时输出$1$并删除所有难度的一道题。
   - **评分**：3星（思路新颖，但代码复杂度较高）

【最优关键思路】  
- **使用变量记录已出现的难度种类数**：通过变量`allnd`或`cnt`记录当前已出现的难度种类数，避免了每次遍历数组判断是否所有难度都已出现，提升了效率。
- **删除操作优化**：在满足条件时，直接对所有难度的题目数量减一，并更新已出现的难度种类数。

【可拓展之处】  
- 类似题目可以考察如何在动态数据流中高效判断某些条件是否满足，并执行相应操作。
- 可以扩展到多条件判断，如同时满足多个条件时执行操作。

【推荐题目】  
1. [P1100 构建比赛](https://www.luogu.com.cn/problem/P1100)  
2. [P1101 单词方阵](https://www.luogu.com.cn/problem/P1101)  
3. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)

【个人心得】  
- **SOVOS**：通过引入`allnd`变量减少了不必要的遍历，提升了代码效率。
- **Molina**：直接暴力模拟，思路清晰，但未进行明显优化。
- **da32s1da**：使用队列记录数据，思路新颖，但代码复杂度较高。

【核心代码片段】  
```cpp
// SOVOS的代码片段
void pt(){
	if(allnd<m){
		printf("0");
		return;
	}
	for(int i=1;i<=m;i++){
		if(nd[i]==1)allnd--;
		nd[i]--;
	}
	printf("1");
}
```

---
处理用时：26.25秒
# 题目信息

# Lunar New Year and Number Division

## 题目描述

新年来了，Bob 正被他的家庭作业所为难，他需要完成一个划分数字的作业。

Bob 的作业上有 $n$ 个正整数 $a_1,a_2,{\dots},a_n$，其中 $n$ 为偶数，他要把这些数字进行分组，每组至少两个数字，假设分成了 $m$ 组，第 $j$ 组的数字之和是 $s_j$，Bob 需要最小化 $s_j$ 的平方和，即 $\sum^{m}_{j=1} s_j^2$。

Bob 被这题难住了，你可以帮帮他吗？

## 说明/提示

对于 $100\%$ 的数据，有 $2\leq n\leq 3\times 10^5, 1 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
4
8 5 2 3
```

### 输出

```
164
```

## 样例 #2

### 输入

```
6
1 1 1 2 2 2
```

### 输出

```
27
```

# AI分析结果

### 题目内容重写
# 新年与数字划分

## 题目描述

新年到了，Bob 正被他的家庭作业所困扰，他需要完成一个划分数字的作业。

Bob 的作业上有 $n$ 个正整数 $a_1,a_2,{\dots},a_n$，其中 $n$ 为偶数，他要把这些数字进行分组，每组至少两个数字，假设分成了 $m$ 组，第 $j$ 组的数字之和是 $s_j$，Bob 需要最小化 $s_j$ 的平方和，即 $\sum^{m}_{j=1} s_j^2$。

Bob 被这题难住了，你可以帮帮他吗？

## 说明/提示

对于 $100\%$ 的数据，有 $2\leq n\leq 3\times 10^5, 1 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
4
8 5 2 3
```

### 输出

```
164
```

## 样例 #2

### 输入

```
6
1 1 1 2 2 2
```

### 输出

```
27
```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略，将数组排序后，将最小的数与最大的数配对，次小的与次大的配对，以此类推，从而最小化平方和。这种方法利用了重排不等式的思想，确保每组的和尽可能平均，从而减少平方和。

### 所选高星题解
#### 题解1：作者：Anguei (赞：4)
**星级：5星**
**关键亮点：**
- 详细解释了贪心策略的合理性，并引用了重排不等式进行证明。
- 代码简洁明了，使用了排序和简单的循环计算平方和。

**核心代码：**
```cpp
#define int long long
const int N = 300000 + 5;
int n, s = 0, a[N];

int sqr(int x) { return x * x; }
void solution() {
    n = read(); rep(i, 1, n) a[i] = read();
    std::sort(a + 1, a + n + 1);
    rep(i, 1, n >> 1) s += sqr(a[i] + a[n + 1 - i]);
    println(s);
}
```

#### 题解2：作者：fmj_123 (赞：3)
**星级：4星**
**关键亮点：**
- 通过数学推导证明了将最小数与最大数配对的合理性。
- 代码实现清晰，直接使用排序和循环计算平方和。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[300100],ans;
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	  cin>>a[i];
	sort(a+1,a+1+n);
	for (int i=1;i<=n/2;i++)
	{
		ans+=(a[i]+a[n-i+1])*(a[i]+a[n-i+1]);
	}
	cout<<ans<<endl;
	return 0;
}
```

#### 题解3：作者：_Weslie_ (赞：1)
**星级：4星**
**关键亮点：**
- 通过具体例子说明了为什么将最小数与最大数配对是最优的。
- 提供了两种代码实现，一种是常规排序，另一种是桶排序，适合不同规模的数据。

**核心代码：**
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[300001],n;
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n/2;i++){
		ans+=(a[i]+a[n-i+1])*(a[i]+a[n-i+1]);
	}
	cout<<ans;
	return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：将数组排序后，将最小数与最大数配对，次小与次大配对，以此类推，确保每组的和尽可能平均，从而最小化平方和。
- **重排不等式**：利用重排不等式证明这种配对方式的最优性。

### 可拓展之处
- 类似的问题可以通过贪心策略和数学推导来解决，特别是在需要最小化或最大化某种组合结果的情况下。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：34.22秒
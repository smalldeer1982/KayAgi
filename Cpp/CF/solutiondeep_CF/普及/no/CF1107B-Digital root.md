# 题目信息

# Digital root

## 题目描述

一个非负数的数字根由反复的数位和计算得来，每一次计算

使用前一次计算得来的结果计算数位和，直到计算结果为1位数为止。

若将x的数字根称作S(x)，则S(5)=5



S(38)=S(3+8=11)=S(1+1=2)=2



S(10)=S(1+0=1)=1



现在需要你找出数字根为x的第k个正数。（每个测试点有n个这样的问题）

## 样例 #1

### 输入

```
3
1 5
5 2
3 1
```

### 输出

```
5
38
19
```

# AI分析结果

### 题目内容重写
#### 数字根

**题目描述**

一个非负数的数字根是通过反复计算其数位和得到的，每一次计算使用前一次计算的结果来计算数位和，直到结果为一位数为止。

若将x的数字根称作S(x)，则S(5)=5

S(38)=S(3+8=11)=S(1+1=2)=2

S(10)=S(1+0=1)=1

现在需要你找出数字根为x的第k个正数。（每个测试点有n个这样的问题）

**样例 #1**

**输入**

```
3
1 5
5 2
3 1
```

**输出**

```
5
38
19
```

### 算法分类
数学

### 题解分析与结论
所有题解都基于一个关键数学规律：一个数的数字根等于该数模9的余数，若余数为0则数字根为9。这一规律大大简化了问题的求解，使得问题可以通过简单的数学公式直接求解，而不需要复杂的计算或迭代。

### 所选高星题解
#### 题解1：SqrtSecond (5星)
**关键亮点**
- 通过归纳法证明了数字根与模9的关系，逻辑清晰。
- 代码简洁，直接使用公式计算，效率高。

**核心代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x;
int main()
{
    scanf("%lld",&n);
    while(n--)
    {
        scanf("%lld%lld",&k,&x);
        printf("%lld\n",(k-1)*9+x);
    }
    return 0;
}
```
**实现思想**
直接使用公式 `(k-1)*9 + x` 计算第k个数字根为x的数。

#### 题解2：_louhc (4星)
**关键亮点**
- 通过引理证明了数字根与模9的关系，并给出了详细的数学推导。
- 代码简洁，直接使用公式计算。

**核心代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long

int T;
LL k; int x;

int main(){
    scanf( "%d", &T );
    while( T-- ) scanf( "%I64d%d", &k, &x ), printf( "%I64d\n", ( k - 1 ) * 9 + x );
    return 0;
}
```
**实现思想**
同样使用公式 `(k-1)*9 + x` 计算第k个数字根为x的数。

#### 题解3：Frictional (4星)
**关键亮点**
- 通过打表找规律，验证了数字根与模9的关系。
- 代码简洁，直接使用公式计算。

**核心代码**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int k,x;
signed main(){
    cin>>n;
    while(n--){
        cin>>k>>x;
        cout<<9*(k-1)+x<<endl;
    }
    return 0;
}
```
**实现思想**
同样使用公式 `(k-1)*9 + x` 计算第k个数字根为x的数。

### 最优关键思路
所有题解都基于一个关键数学规律：一个数的数字根等于该数模9的余数，若余数为0则数字根为9。这一规律大大简化了问题的求解，使得问题可以通过简单的数学公式直接求解，而不需要复杂的计算或迭代。

### 可拓展之处
类似的问题可以通过寻找数学规律来简化计算，例如在数论中常见的模运算、周期性等问题。掌握这些规律可以大大提高解题效率。

### 推荐题目
1. P1008 三连击
2. P1010 幂次方
3. P1011 数的计算

这些题目都涉及到数学规律的发现和应用，适合进一步练习和巩固相关知识。

---
处理用时：28.88秒
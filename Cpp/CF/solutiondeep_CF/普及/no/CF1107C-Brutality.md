# 题目信息

# Brutality

## 题目描述

在全新的格斗游戏《Kortal Mombat XII》中，你需要对对手的角色实施一招强势的「残暴攻击」。

手柄配备了 $26$ 个按钮，每个按钮上标有不同的小写字母，从 'a' 到 'z'。这意味着每个按钮只能通过对应字母按键激活。

我们有一系列的攻击动作，第 $i$ 次攻击会造成 $a_i$ 点伤害。为了执行第 $i$ 次攻击，你必须按下手柄上的 $s_i$ 按钮。攻击的编号依次为 $1$ 到 $n$。

然而如果连续按下某个按钮超过 $k$ 次，该按钮就会损坏。为了保护你的手柄不被损坏，你需要限制连续按同一按钮的次数。

「残暴攻击」要求你在不改变攻击顺序的前提下选择执行这些攻击动作中的若干次。每一次攻击都可以选择执行或跳过。跳过某次攻击不会重置同一按钮的连续按压次数。

你的任务是：跳过一些攻击，确保在不损坏任何手柄按钮的情况下，达到最大的总伤害值。

## 说明/提示

- 在第一个例子中，你可以选择攻击序列 $[1, 3, 4, 5, 6, 7]$，这样总伤害为 $1 + 16 + 18 + 7 + 2 + 10 = 54$。
- 在第二个例子中，选择全部攻击的总伤害为 $2 + 4 + 1 + 3 + 1000 = 1010$。
- 在第三个例子中，选择除第三次攻击外的其他攻击，总伤害为 $2 + 4 + 3 + 1000 = 1009$。
- 在第四个例子中，选择攻击序列 $[2, 3, 6, 8]$，可以最大化总伤害，即 $15 + 2 + 8 + 16 = 41$。
- 在第五个例子中，选择攻击序列 $[2, 4, 6]$，总伤害为 $18 + 19 + 15 = 52$。
- 在第六个例子中，只能选择第一个或第二个攻击，总伤害为 $10$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
7 3
1 5 16 18 7 2 10
baaaaca
```

### 输出

```
54
```

## 样例 #2

### 输入

```
5 5
2 4 1 3 1000
aaaaa
```

### 输出

```
1010
```

## 样例 #3

### 输入

```
5 4
2 4 1 3 1000
aaaaa
```

### 输出

```
1009
```

## 样例 #4

### 输入

```
8 1
10 15 2 1 4 8 15 16
qqwweerr
```

### 输出

```
41
```

## 样例 #5

### 输入

```
6 3
14 18 9 19 2 15
cccccc
```

### 输出

```
52
```

## 样例 #6

### 输入

```
2 1
10 10
qq
```

### 输出

```
10
```

# AI分析结果

### 题目内容重写

在全新的格斗游戏《Kortal Mombat XII》中，你需要对对手的角色实施一招强势的「残暴攻击」。

手柄配备了 $26$ 个按钮，每个按钮上标有不同的小写字母，从 'a' 到 'z'。这意味着每个按钮只能通过对应字母按键激活。

我们有一系列的攻击动作，第 $i$ 次攻击会造成 $a_i$ 点伤害。为了执行第 $i$ 次攻击，你必须按下手柄上的 $s_i$ 按钮。攻击的编号依次为 $1$ 到 $n$。

然而如果连续按下某个按钮超过 $k$ 次，该按钮就会损坏。为了保护你的手柄不被损坏，你需要限制连续按同一按钮的次数。

「残暴攻击」要求你在不改变攻击顺序的前提下选择执行这些攻击动作中的若干次。每一次攻击都可以选择执行或跳过。跳过某次攻击不会重置同一按钮的连续按压次数。

你的任务是：跳过一些攻击，确保在不损坏任何手柄按钮的情况下，达到最大的总伤害值。

### 算法分类
贪心

### 题解分析与结论

#### 题解1：wlzhouzhuan (4星)
- **关键亮点**：使用堆（优先队列）来维护每段连续相同字符的伤害值，确保选择最大的k个伤害值。代码实现清晰，逻辑简洁。
- **核心思想**：将字符串分成若干段连续相同字符的区间，对于每段区间，如果长度小于等于k，则全部选择；否则，选择其中最大的k个伤害值。
- **代码实现**：
  ```cpp
  rep(i, 1, n) {
      int j = i;
      while (j < n && a[j + 1] == a[i]) j++;
      if (j - i + 1 <= k) {
          rep(_, i, j) ans += w[_];
          i = j;
          continue;
      }
      cnt = 0;
      rep(_, i, j) {
          heap[++cnt] = w[_];
          up(cnt);
      }
      rep(_, 1, k) {
          ans += heap[1];
          heap[1] = heap[cnt--];
          down(1);
      }
      i = j;
  }
  ```

#### 题解2：incra (4星)
- **关键亮点**：使用双指针和排序来处理每段连续相同字符的区间，选择最大的k个伤害值。代码简洁，逻辑清晰。
- **核心思想**：将字符串分成若干段连续相同字符的区间，对于每段区间，如果长度小于等于k，则全部选择；否则，选择其中最大的k个伤害值。
- **代码实现**：
  ```cpp
  for (int i = 1;i <= n;) {
      int j = i;
      vector <int> v;
      while (j <= n && s[j] == s[i]) v.push_back (a[j++]);
      sort (v.begin (),v.end (),greater <int> ());
      for (int k = 0;k < min (m,(int)v.size ());k++) ans += v[k];
      i = j;
  }
  ```

#### 题解3：XL4453 (3星)
- **关键亮点**：使用优先队列来维护每段连续相同字符的伤害值，确保选择最大的k个伤害值。代码实现较为简洁，但逻辑略显复杂。
- **核心思想**：将字符串分成若干段连续相同字符的区间，对于每段区间，如果长度小于等于k，则全部选择；否则，选择其中最大的k个伤害值。
- **代码实现**：
  ```cpp
  for (int i = 1;i <= n;i++) {
      if (s[i] != s[i - 1]) {
          for (int j = 1;j <= k;j++) {
              if (atk.empty()) break;
              ans += atk.top();
              atk.pop();
          }
          while (!atk.empty()) atk.pop();
      }
      atk.push(a[i]);
  }
  ```

### 最优关键思路
- **分段处理**：将字符串分成若干段连续相同字符的区间，分别处理每段区间。
- **贪心选择**：对于每段区间，如果长度小于等于k，则全部选择；否则，选择其中最大的k个伤害值。
- **数据结构**：使用堆（优先队列）或排序来快速选择最大的k个伤害值。

### 可拓展之处
- **类似问题**：类似的问题可以出现在需要选择最优子集的情况下，如选择最大价值的物品、选择最优的任务序列等。
- **算法套路**：贪心算法在处理选择最优子集的问题时非常有效，尤其是在需要快速选择最大或最小元素的情况下。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得
- **调试经历**：在处理连续相同字符的区间时，需要注意边界条件的处理，如最后一个区间的处理。
- **踩坑教训**：在使用堆或优先队列时，需要确保堆的大小不超过k，否则会导致错误的结果。
- **顿悟感想**：贪心算法在处理选择最优子集的问题时，往往能够提供简洁高效的解决方案。

---
处理用时：37.56秒
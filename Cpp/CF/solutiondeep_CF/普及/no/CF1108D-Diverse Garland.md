# 题目信息

# Diverse Garland

## 题目描述

给一串字符，只有`R`和`G`和`B`。问如果要让相邻$2$个字符都不同，最少要改几个?

## 样例 #1

### 输入

```
9
RBGRRBRGG
```

### 输出

```
2
RBGRGBRGR
```

## 样例 #2

### 输入

```
8
BBBGBRRR
```

### 输出

```
2
BRBGBRGR
```

## 样例 #3

### 输入

```
13
BBRRRRGGGGGRR
```

### 输出

```
6
BGRBRBGBGBGRG
```

# AI分析结果

### 题目内容重写
# 多样花环

## 题目描述

给一串字符，只有`R`、`G`和`B`。问如果要让相邻的两个字符都不同，最少要改几个字符？

## 样例 #1

### 输入

```
9
RBGRRBRGG
```

### 输出

```
2
RBGRGBRGR
```

## 样例 #2

### 输入

```
8
BBBGBRRR
```

### 输出

```
2
BRBGBRGR
```

## 样例 #3

### 输入

```
13
BBRRRRGGGGGRR
```

### 输出

```
6
BGRBRBGBGBGRG
```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心算法，逐个检查字符并修改，确保相邻字符不相同。大多数题解采用了从前往后或从后往前的遍历方式，通过修改当前字符或下一个字符来减少修改次数。部分题解还引入了动态规划的思路，但整体上贪心算法更为简洁高效。

### 所选高星题解
1. **作者：Ankiia (5星)**
   - **关键亮点**：从后往前贪心，避免了从前往后贪心时的复杂判断，代码简洁且易于理解。
   - **核心代码**：
     ```cpp
     for(int i=2;i<=n;i++) {
         if(s[i-1]==s[i]) {
             if(s[i-1]!='R' && s[i+1]!='R') s[i]='R';
             else if(s[i-1]!='G' && s[i+1]!='G') s[i]='G';
             else if(s[i-1]!='B' && s[i+1]!='B') s[i]='B';
             gs++;
         }
     }
     ```
   - **个人心得**：从后往前贪心简化了问题，减少了特判的复杂度。

2. **作者：_xbn (4星)**
   - **关键亮点**：通过字符相加的方式，避免了繁琐的特判，代码简洁且高效。
   - **核心代码**：
     ```cpp
     if(s[i - 1] == s[i]) {
         ans++;
         if(i + 1 < n && s[i - 1] != s[i + 1]) {
             s[i] = 'R' + 'G' + 'B' - s[i - 1] - s[i + 1];
         } else {
             s[i] = s[i-1]=='R'?'G':'R';
         }
     }
     ```
   - **个人心得**：通过字符相加的方式，简化了判断逻辑，代码更加简洁。

3. **作者：Reywmp (4星)**
   - **关键亮点**：先处理三个连续相同字符的情况，再处理两个连续相同字符的情况，减少了修改次数。
   - **核心代码**：
     ```cpp
     for(int i=2;i<n;i++) {
         if(a[i]==a[i-1]&&a[i]==a[i+1]) {
             if(a[i]=='R') a[i]='B';
             else a[i]='R';
             ans++;
         }
     }
     for(int i=2;i<=n;i++) {
         if(a[i]==a[i-1]) {
             a[i]='R';
             if(a[i-1]==a[i]||a[i]==a[i+1]) a[i]='B';
             if(a[i-1]==a[i]||a[i]==a[i+1]) a[i]='G';
             ans++;
         }
     }
     ```
   - **个人心得**：先处理三个连续相同字符的情况，再处理两个连续相同字符的情况，减少了修改次数。

### 最优关键思路
从后往前贪心，通过修改当前字符或下一个字符来减少修改次数，避免了从前往后贪心时的复杂判断。同时，通过字符相加的方式，简化了判断逻辑，代码更加简洁。

### 可拓展之处
类似的问题可以扩展到更多字符或更复杂的规则，如允许某些字符相邻或限制某些字符的出现次数。贪心算法在这些问题中仍然适用，但可能需要更复杂的判断逻辑。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：32.25秒
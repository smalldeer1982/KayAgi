# 题目信息

# Sasha and Magnetic Machines

## 题目描述

### 题意简述

有一个长度为$n$的正整数序列$a_{1..n}$。你可以对这个数列进行最多$1$次的如下操作：

- 选择$1 \leq i,j \leq n\ \ (i \neq j)$，并选择一个可以整除$a_i$的正整数$x$，然后将$a_i$变为$\frac{a_i}{x}$，将$a_j$变为$a_j \cdot x$。

问你操作后，该序列中所有数的和最小能达到多少。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
14
```

## 样例 #2

### 输入

```
4
4 2 4 4
```

### 输出

```
14
```

## 样例 #3

### 输入

```
5
2 4 2 3 7
```

### 输出

```
18
```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个长度为 $n$ 的正整数序列 $a_{1..n}$。你可以对这个数列进行最多 $1$ 次的如下操作：

- 选择 $1 \leq i,j \leq n\ \ (i \neq j)$，并选择一个可以整除 $a_i$ 的正整数 $x$，然后将 $a_i$ 变为 $\frac{a_i}{x}$，将 $a_j$ 变为 $a_j \cdot x$。

问你操作后，该序列中所有数的和最小能达到多少。

### 算法分类
贪心

### 题解分析与结论

本题的核心在于通过一次操作使得序列的和最小化。由于操作次数有限，且每次操作涉及两个数的变化，因此可以通过贪心策略来选择最优的 $i$、$j$ 和 $x$。

#### 题解对比

1. **Fuxh_18** 的题解通过暴力枚举 $i$、$j$ 和 $x$，并优化了 $j$ 的选择，使其为序列中的最小值或次小值。时间复杂度为 $O(n \times \sqrt{val})$，其中 $val$ 是 $a_i$ 的最大值。该题解思路清晰，代码可读性较好，优化程度较高。
   - 评分：4星
   - 关键亮点：通过排序优化 $j$ 的选择，减少枚举次数。

2. **晴空一鹤** 的题解同样通过枚举 $i$ 和 $x$，并选择最小的 $a_j$ 来优化和的计算。时间复杂度为 $O(n \times \sqrt{val})$。该题解思路清晰，代码简洁，优化程度较高。
   - 评分：4星
   - 关键亮点：通过排序和选择最小 $a_j$ 来优化和的计算。

3. **lzyqwq** 的题解通过枚举 $i$ 和 $x$，并选择最小或次小的 $a_j$ 来优化和的计算。时间复杂度为 $O(n \times \sqrt{val})$。该题解思路清晰，代码简洁，优化程度较高。
   - 评分：4星
   - 关键亮点：通过排序和选择最小或次小 $a_j$ 来优化和的计算。

#### 最优关键思路

1. **排序优化**：通过排序序列，可以快速找到最小或次小的 $a_j$，从而减少枚举次数。
2. **因子枚举优化**：枚举 $a_i$ 的因子时，只需枚举到 $\sqrt{a_i}$，因为因子是成对出现的，这样可以减少枚举次数。

#### 可拓展之处

类似的问题可以通过贪心策略和枚举因子的方法来优化，例如在序列中通过有限次操作来最大化或最小化某个目标值。

#### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 贪心策略的应用。
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心策略的应用。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 贪心策略的应用。

#### 个人心得

- **调试经历**：在枚举因子时，需要注意因子的成对出现，避免重复计算。
- **顿悟感想**：通过排序和选择最小或次小的 $a_j$，可以大大减少计算量，提高算法效率。

### 核心代码片段

```cpp
for(int i=1;i<=n;i++){
    for(int j=2;j<=sqrt(a[i]);j++){
        if(a[i]%j==0){ //可以除尽 
            int res=sum;
            res-=a[i]; //减去初始 
            res+=a[i]/j; //加上更改 
            if(i==1){ //由于 i!=j，当i=1时，a[j]最小值为a[2] 
                res-=a[2];
                res+=a[2]*j;
            }
            else{
                res-=a[1];
                res+=a[1]*j;
            }
            ans=min(ans,res); //更新最小值 
        }
    }
}
```

这段代码通过枚举 $i$ 和 $x$，并选择最小或次小的 $a_j$ 来优化和的计算，最终得到最小的序列和。

---
处理用时：26.46秒
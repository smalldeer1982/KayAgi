# 题目信息

# Equalize Them All

## 题目描述

你被给了一个 _n_ 个元素的数组 _a_ ,对于一对（i,j）其满足|i-j|=1（即表示i,j相邻）,你现在有两种操作方式：


**1**操作：将a[i]变为a[i] + | a[i]-a[j] |


**2**操作：将a[i]变为a[i] - | a[i]-a[j] |


（其中 | a[i]-a[j] | 表示a[i]-a[j]的绝对值，举例：|-4|=4,|3|=3）。


你的任务是求出最小的操作次数使整个数组的值全部相等并把每一步输出出来。


数据保证总用方法使其经过若干次操作后全部相等


保证任意一次操作后数之都不会超过10^18

## 样例 #1

### 输入

```
5
2 4 6 6 6
```

### 输出

```
2
1 2 3 
1 1 2 
```

## 样例 #2

### 输入

```
3
2 8 10
```

### 输出

```
2
2 2 1 
2 3 2 
```

## 样例 #3

### 输入

```
4
1 1 1 1
```

### 输出

```
0
```

# AI分析结果

### 题目内容重写
你被给了一个包含 _n_ 个元素的数组 _a_，对于一对（i,j）其满足|i-j|=1（即表示i,j相邻），你现在有两种操作方式：

**1**操作：将a[i]变为a[i] + | a[i]-a[j] |

**2**操作：将a[i]变为a[i] - | a[i]-a[j] |

（其中 | a[i]-a[j] | 表示a[i]-a[j]的绝对值，举例：|-4|=4,|3|=3）。

你的任务是求出最小的操作次数使整个数组的值全部相等并把每一步输出出来。

数据保证总用方法使其经过若干次操作后全部相等

保证任意一次操作后数之都不会超过10^18

### 算法分类
贪心

### 题解分析与结论
所有题解的核心思路都是将数组中的所有元素变为出现次数最多的元素，以减少操作次数。具体实现上，通过从前往后和从后往前两次遍历数组，确保所有元素都能被修改为目标值。难点在于如何高效地找到出现次数最多的元素，并确保操作的正确性。

### 所选题解
#### 作者：woshishei (赞：4)  
**星级：5星**  
**关键亮点：**  
- 思路清晰，直接通过统计每个元素的出现次数找到目标值。
- 代码简洁，通过两次遍历确保所有元素被修改。
- 操作类型的选择（1操作或2操作）逻辑明确，易于理解。

**核心代码：**
```cpp
for(int i=2;i<=n;i++) {
    if(a[i-1]!=mxd)continue;
    if(a[i]>a[i-1])printf("2 %d %d\n",i,i-1);
    if(a[i]<a[i-1])printf("1 %d %d\n",i,i-1);
    a[i]=a[i-1];
}
for(int i=n-1;i>=1;i--) {
    if(a[i+1]!=mxd)continue;
    if(a[i]>a[i+1])printf("2 %d %d\n",i,i+1);
    if(a[i]<a[i+1])printf("1 %d %d\n",i,i+1);
    a[i]=a[i+1];
}
```

#### 作者：fanfansann (赞：1)  
**星级：4星**  
**关键亮点：**  
- 详细解释了为什么选择出现次数最多的元素作为目标值。
- 通过正反两次遍历确保所有元素被修改，逻辑严谨。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
over(i,2,n)
    if(a[i-1] == max_num && a[i] != max_num)
        if(a[i]>a[i-1])
            printf("2 %d %d\n",i,i-1),a[i] = a[i-1];
        else printf("1 %d %d\n",i,i-1),a[i] = a[i-1];
lver(i,n-1,1)
    if(a[i+1] == max_num && a[i] != max_num)
        if(a[i]>a[i+1])
            printf("2 %d %d\n",i,i+1),a[i] = a[i+1];
        else printf("1 %d %d\n",i,i+1),a[i] = a[i+1];
```

### 最优关键思路或技巧
1. **贪心策略**：选择出现次数最多的元素作为目标值，以减少操作次数。
2. **两次遍历**：通过从前往后和从后往前两次遍历，确保所有元素都能被修改为目标值。
3. **操作选择**：根据当前元素与目标值的大小关系，选择1操作或2操作。

### 可拓展之处
类似的问题可以通过贪心策略和多次遍历来解决，特别是在需要将数组中的元素统一为某个值的场景中。例如，将数组中的所有元素变为某个特定值，或者将数组中的元素调整为满足某种条件。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结
在实现过程中，需要注意统计出现次数时从0开始，否则可能会导致错误。此外，通过正反两次遍历可以确保所有元素被修改，避免遗漏。

---
处理用时：27.34秒
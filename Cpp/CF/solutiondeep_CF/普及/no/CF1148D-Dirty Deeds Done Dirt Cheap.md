# 题目信息

# Dirty Deeds Done Dirt Cheap

## 题目描述

有 $n$ 个整数对 $(a_1, b_1), (a_2, b_2), \cdots, (a_n, b_n)$. 保证 $a_1, b_1, a_2, b_2, \cdots, a_n, b_n$ 两两不相等, 并且均在区间 $[1, 2 \cdot n]$ 内.



好序列的定义:  

对于一个序列 $x_1, x_2, \cdots, x_{2k}$, 满足

- $x_1 < x_2 > x_3 < \cdots < x_{2k - 2} > x_{2k - 1} < x_{2k}$ 或

- $x_1 > x_2 < x_3 > \cdots > x_{2k - 2} < x_{2k - 1} > x_{2k}$.



求一个序列 $i_1, i_2, \cdots, i_t$ 满足 $a_{i_1}, b_{i_1}, a_{i_2}, b_{i_2}, \cdots, a_{i_t}, b_{i_t}$ 是好序列.



输出 $t$ 的最大值以及对应的序列 $i_1, i_2, \cdots, i_t$.

## 说明/提示

$2 \leq n \leq 3 \cdot 10^5$  

$1 \leq a_i, b_i \leq 2 \cdot n$  

并且所有 $a_i, b_i$ 两两不相等.



### 样例解释

样例 1: $1 < 7 > 3 < 5 > 2 < 10$.



样例 2: $6 > 1 < 3 > 2 < 5 > 4$.

## 样例 #1

### 输入

```
5
1 7
6 4
2 10
9 8
3 5
```

### 输出

```
3
1 5 3
```

## 样例 #2

### 输入

```
3
5 4
3 2
6 1
```

### 输出

```
3
3 2 1
```

# AI分析结果

### 题目重写
# 肮脏的勾当廉价完成

## 题目描述

有 $n$ 个整数对 $(a_1, b_1), (a_2, b_2), \cdots, (a_n, b_n)$。保证 $a_1, b_1, a_2, b_2, \cdots, a_n, b_n$ 两两不相等，并且均在区间 $[1, 2 \cdot n]$ 内。

好序列的定义：  
对于一个序列 $x_1, x_2, \cdots, x_{2k}$，满足
- $x_1 < x_2 > x_3 < \cdots < x_{2k - 2} > x_{2k - 1} < x_{2k}$ 或
- $x_1 > x_2 < x_3 > \cdots > x_{2k - 2} < x_{2k - 1} > x_{2k}$。

求一个序列 $i_1, i_2, \cdots, i_t$ 满足 $a_{i_1}, b_{i_1}, a_{i_2}, b_{i_2}, \cdots, a_{i_t}, b_{i_t}$ 是好序列。

输出 $t$ 的最大值以及对应的序列 $i_1, i_2, \cdots, i_t$。

## 说明/提示

$2 \leq n \leq 3 \cdot 10^5$  
$1 \leq a_i, b_i \leq 2 \cdot n$  
并且所有 $a_i, b_i$ 两两不相等。

### 样例解释

样例 1: $1 < 7 > 3 < 5 > 2 < 10$。

样例 2: $6 > 1 < 3 > 2 < 5 > 4$。

## 样例 #1

### 输入

```
5
1 7
6 4
2 10
9 8
3 5
```

### 输出

```
3
1 5 3
```

## 样例 #2

### 输入

```
3
5 4
3 2
6 1
```

### 输出

```
3
3 2 1
```

### 算法分类
贪心、排序

### 题解分析与结论
题目要求构造一个“好序列”，并且要最大化序列的长度。通过分析可以发现，好序列的构造可以通过将数对分为两类：一类是 $a_i < b_i$，另一类是 $a_i > b_i$。对于每一类，分别按照 $b_i$ 从大到小或从小到大排序，然后依次连接，即可得到一个好序列。最终选择两类中数对更多的一类作为结果。

### 所选高星题解
#### 题解1：作者：mraymes (赞：4)
- **星级**：4星
- **关键亮点**：清晰地将数对分为两类，并分别排序，最终选择数对更多的一类。代码简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  if (n1 >= n2) { // 选第一类
      sort(a + 1, a + n1 + 1, greater<ppi>()); // 从大到小排序
      printf("%d\n", n1);
      for (int i = 1; i <= n1; i++) {
          cout << a[i].second << ' ';
      }
  } else { // 选第二类
      sort(b + 1, b + n2 + 1); // 从小到大排序 (默认排序)
      printf("%d\n", n2);
      for (int i = 1; i <= n2; i++) {
          cout << b[i].second << ' ';
      }
  }
  ```

#### 题解2：作者：LYY_yyyy (赞：0)
- **星级**：3星
- **关键亮点**：同样将数对分为两类，并分别排序，最终选择数对更多的一类。代码简洁，但缺少一些优化和解释。
- **核心代码**：
  ```cpp
  sort(s1.begin(),s1.end(),cmp1);
  sort(s2.begin(),s2.end(),cmp2);
  if(s1.size()<s2.size()) swap(s1,s2);
  cout<<s1.size()<<"\n";
  for(auto o:s1) cout<<o.id<<" ";
  ```

### 最优关键思路
1. **分类处理**：将数对分为 $a_i < b_i$ 和 $a_i > b_i$ 两类，分别处理。
2. **排序策略**：对于 $a_i < b_i$ 的数对，按 $b_i$ 从大到小排序；对于 $a_i > b_i$ 的数对，按 $b_i$ 从小到大排序。
3. **选择最大序列**：选择两类中数对更多的一类作为最终结果。

### 可拓展之处
- **类似题目**：可以考虑其他需要构造特定序列的题目，如最长上升子序列、最长交替子序列等。
- **优化思路**：可以进一步优化排序和选择过程，减少时间复杂度。

### 推荐题目
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
3. [P1045 最长公共子序列](https://www.luogu.com.cn/problem/P1045)

### 个人心得
- **调试经历**：在处理数对时，确保分类和排序的正确性非常重要，特别是在处理边界条件时。
- **顿悟感想**：通过将问题分解为两类并分别处理，可以大大简化问题的复杂度，这是贪心算法的一个典型应用。

---
处理用时：35.24秒
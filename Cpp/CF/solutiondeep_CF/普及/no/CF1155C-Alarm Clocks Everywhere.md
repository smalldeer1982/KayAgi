# 题目信息

# Alarm Clocks Everywhere

## 题目描述

```Ivan``` 要睡觉了！他决定先设置自己的闹钟，因为明天有许多必要的 $n$ 个活动要参加。第 $i$ 个活动将在 $x_i$ 分钟开始。```Ivan``` 不想错过任何活动，所以 ```Ivan``` 的闹钟必须在 $x_1,x_2,x_3...x_n$ 分钟都响一次，这样他才不会赖床。（然而闹钟在没有活动的时候响起是允许的）

```Ivan``` 需要为他的闹钟选择两个参数。$y$ 表示闹钟最初开始响铃的时间 ，$p$ 表示闹钟响铃的间隔。 闹钟参数设置好之后，他的闹钟会在 $y ,y+p,y+2p,y+3p...$分钟响起。

```Ivan``` 可以随意设置 $y$ ，但他不能随意设置 $p$ ，因为生产厂家给定了只有 $m$ 种 $p$，即 $p_1 ,p_2,p_3...,p_m$

所以 ```Ivan``` 需要找到两个参数 $y ,p_j$ ，使得闹钟的响铃时间包含 $x_1,x_2,x_3...x_n$ 的所有时间点。而你需要输出 $y,j$。如果有多种答案，任意输出一种。

## 样例 #1

### 输入

```
3 5
3 12 18
2 6 5 3 3
```

### 输出

```
YES
3 4
```

## 样例 #2

### 输入

```
4 2
1 5 17 19
4 5
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
4 2
1 5 17 19
2 1
```

### 输出

```
YES
1 1
```

# AI分析结果

【题目内容】
# Alarm Clocks Everywhere

## 题目描述

```Ivan``` 要睡觉了！他决定先设置自己的闹钟，因为明天有许多必要的 $n$ 个活动要参加。第 $i$ 个活动将在 $x_i$ 分钟开始。```Ivan``` 不想错过任何活动，所以 ```Ivan``` 的闹钟必须在 $x_1,x_2,x_3...x_n$ 分钟都响一次，这样他才不会赖床。（然而闹钟在没有活动的时候响起是允许的）

```Ivan``` 需要为他的闹钟选择两个参数。$y$ 表示闹钟最初开始响铃的时间 ，$p$ 表示闹钟响铃的间隔。 闹钟参数设置好之后，他的闹钟会在 $y ,y+p,y+2p,y+3p...$分钟响起。

```Ivan``` 可以随意设置 $y$ ，但他不能随意设置 $p$ ，因为生产厂家给定了只有 $m$ 种 $p$，即 $p_1 ,p_2,p_3...,p_m$

所以 ```Ivan``` 需要找到两个参数 $y ,p_j$ ，使得闹钟的响铃时间包含 $x_1,x_2,x_3...x_n$ 的所有时间点。而你需要输出 $y,j$。如果有多种答案，任意输出一种。

## 样例 #1

### 输入

```
3 5
3 12 18
2 6 5 3 3
```

### 输出

```
YES
3 4
```

## 样例 #2

### 输入

```
4 2
1 5 17 19
4 5
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
4 2
1 5 17 19
2 1
```

### 输出

```
YES
1 1
```

【算法分类】数学

【题解分析与结论】

本题的核心思路是通过计算相邻时间点的差值，然后求这些差值的最大公约数（GCD），最后检查给定的间隔是否是该GCD的因数。如果存在这样的间隔，则输出YES及对应的初始时间和间隔编号，否则输出NO。

【所选高星题解】

1. **作者：Brilliant11001 (5星)**
   - **关键亮点**：详细解释了如何通过差分数组和GCD来解决问题，并给出了引理证明，思路清晰，代码简洁。
   - **代码核心**：
     ```cpp
     ll d = c[2];
     for(int i = 3; i <= n; i++) 
         d = gcd(d, c[i]);
     bool flag = false;
     ll fac, ans;
     for(int i = 1; i <= m; i++)
         if(d % p[i] == 0) {
             puts("YES");
             flag = true;
             fac = p[i];
             ans = i;
             break;
         }
     ```

2. **作者：Aventurine_stone (4星)**
   - **关键亮点**：直接使用STL中的__gcd函数简化了代码，思路明确，代码可读性强。
   - **代码核心**：
     ```cpp
     t=__gcd(a[1],a[2]);
     for(int i=3;i<n;i++)
         t=__gcd(t,a[i]);
     for(int i=1;i<=m;i++)
     {
         if(!(t%p[i]))
         {
             printf("YES\n%lld %d",st,i);
             return 0;
         }
     }
     ```

3. **作者：Furina_Saikou (4星)**
   - **关键亮点**：通过逐步计算GCD并检查间隔是否为GCD的因数，代码简洁，逻辑清晰。
   - **代码核心**：
     ```cpp
     gcds=i==2?x[i]-x[i-1]:__gcd(gcds,x[i]-x[i-1]);
     for(int i=1;i<=m;i++)
     {
         if(gcds%p[i]==0)
         {
             cout<<"YES\n"<<x[1]<<" "<<i;
             return 0;
         }
     }
     ```

【关键思路与技巧】
- **差分数组**：通过计算相邻时间点的差值，将问题转化为求这些差值的GCD。
- **GCD计算**：使用GCD来确定所有差值的公共因数，从而确定合适的间隔。
- **因数检查**：检查给定的间隔是否是GCD的因数，以确定是否存在解。

【拓展思路】
- 类似问题可以扩展到多个时间序列的同步问题，或者在不同约束条件下寻找最优解。

【推荐题目】
1. [P1447 最大公约数](https://www.luogu.com.cn/problem/P1447)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)

---
处理用时：35.02秒
# 题目信息

# Match Points

## 题目描述

给你一个在数轴上的点集$x_1, x_2, \dots, x_n$。  
每两个点$i$，$j$可以在满足以下情况的时候相连:  

- 点$i$和点$j$均未与其他点相连;
- $\left| x_i - x_j \right| \geq z$.

那么请你求出最多可以连接多少点对？

## 说明/提示

样例1中，可以连接1号点和2号点($\left| 3 - 1 \right| \geq 2$)，3号点和4号点($\left| 7 - 3 \right| \geq 2$).  
样例2中，可以连接1号点和3号点($\left|5 - 10\right| \geq 5$).

## 样例 #1

### 输入

```
4 2
1 3 3 7
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5 5
10 9 5 8 7
```

### 输出

```
1
```

# AI分析结果

### 题目内容重写
# 匹配点对

## 题目描述

给你一个在数轴上的点集$x_1, x_2, \dots, x_n$。  
每两个点$i$，$j$可以在满足以下情况的时候相连:  

- 点$i$和点$j$均未与其他点相连;
- $\left| x_i - x_j \right| \geq z$.

那么请你求出最多可以连接多少点对？

## 说明/提示

样例1中，可以连接1号点和2号点($\left| 3 - 1 \right| \geq 2$)，3号点和4号点($\left| 7 - 3 \right| \geq 2$).  
样例2中，可以连接1号点和3号点($\left|5 - 10\right| \geq 5$).

## 样例 #1

### 输入

```
4 2
1 3 3 7
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5 5
10 9 5 8 7
```

### 输出

```
1
```

### 算法分类
贪心

### 题解分析与结论
本题的核心在于如何高效地匹配点对，使得满足条件的点对数量最大化。题解中主要采用了贪心算法和二分法两种思路。贪心算法的关键在于将点集分成两部分，并尝试将前半部分的点与后半部分的点进行匹配。二分法则通过二分搜索来确定最大可匹配的点对数量，并通过检查函数验证是否满足条件。

### 所选高分题解
1. **作者：米奇 (赞：3)**  
   - **星级：4**  
   - **关键亮点：** 使用贪心算法，将点集分成两部分进行匹配，思路清晰，代码简洁。  
   - **核心代码：**
     ```cpp
     sort(a+1,a+n+1);
     int x=n;
     for(int i=n/2;i;i--)
         if(a[x]-a[i]>=m)ans++,x--;
     cout<<ans;
     ```

2. **作者：xwh_hh (赞：2)**  
   - **星级：4**  
   - **关键亮点：** 使用二分法，通过二分搜索和检查函数确定最大匹配点对数量，逻辑严谨。  
   - **核心代码：**
     ```cpp
     bool check(int u){
         for(int i=1;i<=u;i++){
             if(x[n-u+i]-x[i]<z) return false;
         }
         return true;
     }
     int l=0,r=n/2;
     while(l<=r){
         int mid=(l+r)>>1;
         if(check(mid)) l=mid+1;
         else r=mid-1;
     }
     cout<<r;
     ```

3. **作者：Doubeecat (赞：1)**  
   - **星级：4**  
   - **关键亮点：** 提供了尺取法和二分法两种解法，代码实现详细，适合不同需求的读者。  
   - **核心代码：**
     ```cpp
     sort(pre+1,pre+n+1,cmp);
     int p = n;
     for (int i = n / 2;i;--i) {
         if (pre[i] - pre[p] >= m) {
             ans++;p--;
         }
     }
     printf("%d",ans);
     ```

### 最优关键思路
最优的思路是将点集排序后，使用贪心算法将前半部分的点与后半部分的点进行匹配，确保每对点的距离满足条件。这种方法简单高效，时间复杂度为O(n)。

### 可拓展之处
类似的问题可以扩展到多维空间中的点对匹配，或者考虑其他约束条件（如点的权重、匹配的优先级等）。此外，二分法的应用可以推广到其他需要确定最大或最小值的场景。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)  
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：30.28秒
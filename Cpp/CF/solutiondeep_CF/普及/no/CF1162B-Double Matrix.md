# 题目信息

# Double Matrix

## 题目描述

【问题描述】



如果矩阵每行从左到右的所有数字严格递增，则称行严格递增，如果从上到下的所有数字都严格递增，则列严格递增。如果所有行和列都严格递增，则称矩阵为递增矩阵。



给出两个包含整数的n×m矩阵A和B，你可以尝交换A_ij和B_ij的值（即交换A、B矩阵同一位置的值）使矩阵A和B变成递增矩阵。

## 样例 #1

### 输入

```
2 2
2 10
11 5
9 4
3 12
```

### 输出

```
Possible
```

## 样例 #2

### 输入

```
2 3
2 4 5
4 5 6
3 6 7
8 10 11
```

### 输出

```
Possible
```

## 样例 #3

### 输入

```
3 2
1 3
2 4
5 10
3 1
3 6
4 8
```

### 输出

```
Impossible
```

# AI分析结果

【题目内容】
# Double Matrix

## 题目描述

【问题描述】

如果矩阵每行从左到右的所有数字严格递增，则称行严格递增，如果从上到下的所有数字都严格递增，则称列严格递增。如果所有行和列都严格递增，则称矩阵为递增矩阵。

给出两个包含整数的n×m矩阵A和B，你可以尝交换A_ij和B_ij的值（即交换A、B矩阵同一位置的值）使矩阵A和B变成递增矩阵。

## 样例 #1

### 输入

```
2 2
2 10
11 5
9 4
3 12
```

### 输出

```
Possible
```

## 样例 #2

### 输入

```
2 3
2 4 5
4 5 6
3 6 7
8 10 11
```

### 输出

```
Possible
```

## 样例 #3

### 输入

```
3 2
1 3
2 4
5 10
3 1
3 6
4 8
```

### 输出

```
Impossible
```

【算法分类】
贪心

【题解分析与结论】
本题的核心思路是通过贪心策略，将两个矩阵中对应位置的较小值放在一个矩阵中，较大值放在另一个矩阵中，然后检查这两个矩阵是否满足严格递增的条件。这种贪心策略的合理性在于，通过将较小的值放在一个矩阵中，可以最大化另一个矩阵的递增可能性。

【高星题解】
1. **作者：Withershine (赞：4)**
   - **星级：5星**
   - **关键亮点：**
     - 通过将两个矩阵中对应位置的较小值放在一个矩阵中，较大值放在另一个矩阵中，最大化递增的可能性。
     - 代码简洁明了，逻辑清晰，易于理解。
   - **核心代码：**
     ```cpp
     fr(i, 1, n) {
         fr(j, 1, m) {
             if(a[i][j] > b[i][j]) {
                 swap(a[i][j], b[i][j]);
             }
         }
     }
     fr(i, 1, n) {
         fr(j, 1, m - 1) {
             if(a[i][j] >= a[i][j + 1] || b[i][j] >= b[i][j + 1]) {
                 printf("Impossible");
                 return 0;
             }
         }
     }
     ```

2. **作者：happybob (赞：0)**
   - **星级：4星**
   - **关键亮点：**
     - 通过贪心策略，将较小的值放在一个矩阵中，较大值放在另一个矩阵中，然后检查是否满足递增条件。
     - 代码结构清晰，逻辑严谨。
   - **核心代码：**
     ```cpp
     for(int i = 1; i <= n; i++) {
         for(int j = 1; j <= m; j++) {
             if(a[i][j] > b[i][j]) {
                 swap(a[i][j], b[i][j]);
             }
         }
     }
     for(int i = 1; i <= n; i++) {
         for(int j = 1; j <= m; j++) {
             if(a[i][j] <= a[i][j - 1] || a[i][j] <= a[i - 1][j] || b[i][j] <= b[i][j - 1] || b[i][j] <= b[i - 1][j]) {
                 puts("Impossible");
                 goto End;
             }
         }
     }
     ```

3. **作者：Goodrage (赞：0)**
   - **星级：4星**
   - **关键亮点：**
     - 通过贪心策略，将较小的值放在一个矩阵中，较大值放在另一个矩阵中，然后检查是否满足递增条件。
     - 代码简洁，逻辑清晰。
   - **核心代码：**
     ```cpp
     for(int i = 1; i <= n; i++) {
         for(int j = 1; j <= m; j++) {
             tmp1[i][j] = min(a[i][j], b[i][j]);
             tmp2[i][j] = max(a[i][j], b[i][j]);
             if(tmp1[i][j] <= tmp1[i - 1][j] || tmp1[i][j] <= tmp1[i][j - 1]) {
                 printf("Impossible");
                 exit(0);
             }
             if(tmp2[i][j] <= tmp2[i - 1][j] || tmp2[i][j] <= tmp2[i][j - 1]) {
                 printf("Impossible");
                 exit(0);
             }
         }
     }
     ```

【最优关键思路】
通过贪心策略，将两个矩阵中对应位置的较小值放在一个矩阵中，较大值放在另一个矩阵中，然后检查这两个矩阵是否满足严格递增的条件。这种策略能够最大化递增的可能性，且实现简单高效。

【拓展思路】
类似的问题可以通过贪心策略来解决，例如在排序、选择等问题中，通过局部最优的选择来达到全局最优的结果。

【推荐题目】
1. [CF1798A Showstopper](https://www.luogu.com.cn/problem/CF1798A)
2. [CF1162B Double Matrix](https://www.luogu.com.cn/problem/CF1162B)
3. [CF1234C Pipes](https://www.luogu.com.cn/problem/CF1234C)

---
处理用时：39.84秒
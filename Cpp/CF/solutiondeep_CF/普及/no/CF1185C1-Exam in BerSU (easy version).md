# 题目信息

# Exam in BerSU (easy version)

## 题目描述

$\text{CF1185C2}$是本题的数据加强版，所以，做出本题不意味着你一定能过$\text{CF1185C2}$。


白朗州大学的又一个学年到来了，很多学生都在做测试。

我们的主人公，小$\text{P}$，要去测试$n(1\leqslant n\leqslant 100)$位学生。学生们将按照$1$到$n$的顺序依次测试。考试规则如下。

- 第$i$个考生随机抽取一张标签，上面有题目。

- 如果这个考生认为这个题目太难，TA没有做这个题目就滚回家去了，那么TA这次考试不及格。

- 如果这个考生发现题目很容易，并且刚好用了$t_i$分钟完成了这道题目。那么过后，TA将带着得到的考试分数回家。

学生们按照固定的次序，依次没有中断地测试。在任何时候，小$\text{P}$从一个学生当中得到答案。

所有学生的考试时间的总和是$M(1\leqslant M\leqslant 100)$，其中保证$\max t[i]\leqslant M$，所以，成绩不好的学生更有可能花光时间以通过考试。

对于每个学生$i$，你的任务是当TA通过考试时，计算出前面最少的不及格的学生的人数。

例如以下的样例一，前5个学生做完题目所需要的时间刚好等于M，所以，他们都不需要不及格的人，所以最少的不及格人数是0。而为了让第6和第7个学生通过测试，前面分别必须让第3,4和第2,5,6个学生不及格。

## 样例 #1

### 输入

```
7 15
1 2 3 4 5 6 7
```

### 输出

```
0 0 0 0 0 2 3 ```

## 样例 #2

### 输入

```
5 100
80 40 40 40 60
```

### 输出

```
0 1 1 2 3 ```

# AI分析结果

### 题目内容重写
白朗州大学的又一个学年到来了，很多学生都在做测试。

我们的主人公，小P，要去测试$n(1\leqslant n\leqslant 100)$位学生。学生们将按照$1$到$n$的顺序依次测试。考试规则如下。

- 第$i$个考生随机抽取一张标签，上面有题目。

- 如果这个考生认为这个题目太难，TA没有做这个题目就滚回家去了，那么TA这次考试不及格。

- 如果这个考生发现题目很容易，并且刚好用了$t_i$分钟完成了这道题目。那么过后，TA将带着得到的考试分数回家。

学生们按照固定的次序，依次没有中断地测试。在任何时候，小P从一个学生当中得到答案。

所有学生的考试时间的总和是$M(1\leqslant M\leqslant 100)$，其中保证$\max t[i]\leqslant M$，所以，成绩不好的学生更有可能花光时间以通过考试。

对于每个学生$i$，你的任务是当TA通过考试时，计算出前面最少的不及格的学生的人数。

例如以下的样例一，前5个学生做完题目所需要的时间刚好等于M，所以，他们都不需要不及格的人，所以最少的不及格人数是0。而为了让第6和第7个学生通过测试，前面分别必须让第3,4和第2,5,6个学生不及格。

### 算法分类
贪心

### 题解综合分析与结论
这道题的核心思路是通过贪心算法，每次在当前学生通过考试的前提下，尽可能少地让前面的学生不及格。具体来说，当当前学生的总时间超过$M$时，我们需要从前面学生的时间中减去最大的时间，直到总时间不超过$M$。这样可以保证让最少的学生不及格。

### 所选高星题解

#### 题解1：作者：MithrilSword_XIV (赞：1)
**星级：4星**
**关键亮点：**
- 使用了贪心算法，通过排序和循环减去最大的时间，确保最少的学生不及格。
- 代码结构清晰，逻辑明确，易于理解。

**核心代码：**
```cpp
sort(t+1,t+i,cmp);//排序
while(x>M){//减去t数组中的数直到sum<=m
    x-=t[cnt+1];
    cnt++;//计数
}
cout<<cnt<<' ';//输出
```

#### 题解2：作者：小鲍bob (赞：1)
**星级：4星**
**关键亮点：**
- 使用了贪心算法，通过排序和循环减去最大的时间，确保最少的学生不及格。
- 代码结构清晰，逻辑明确，易于理解。

**核心代码：**
```cpp
sort(b+1,b+i);//从小到大排序，最后输入的一项千万不要排序
while(k>m)//此条件下执行
{
    k-=b[i-su-1];//因为是从小到大排序且最后一项不用排序
    su++;//计数++
}
cout<<su<<' ';
```

#### 题解3：作者：Tobiichi_Origami (赞：0)
**星级：4星**
**关键亮点：**
- 使用了贪心算法，通过排序和循环减去最大的时间，确保最少的学生不及格。
- 代码结构清晰，逻辑明确，易于理解。

**核心代码：**
```cpp
sort(a+1,a+i);//排序，千万不要排序自己
while(m<sum2)//贪心
{
    sum2-=a[i-num-1];//从大到小，不用算上自己
    num++;//计数器+1
}
cout<<num<<" ";
```

### 最优关键思路或技巧
1. **贪心算法**：每次减去最大的时间，确保最少的学生不及格。
2. **排序**：通过排序找到最大的时间，便于后续的减法操作。
3. **循环判断**：通过循环不断减去最大的时间，直到总时间不超过$M$。

### 可拓展之处
这种贪心算法可以应用于类似的问题，例如在资源有限的情况下，如何最优地分配资源。类似的问题可以参考洛谷的以下题目：
1. P1181 数列分段Section I
2. P1090 合并果子
3. P1223 排队接水

### 个人心得摘录
- **调试经历**：在实现过程中，需要注意排序的范围，不能包括当前学生的时间，否则会导致错误的结果。
- **踩坑教训**：在循环中，要确保每次减去的是最大的时间，否则可能会导致结果不准确。
- **顿悟感想**：贪心算法虽然简单，但在某些情况下非常有效，能够快速解决问题。

---
处理用时：29.94秒
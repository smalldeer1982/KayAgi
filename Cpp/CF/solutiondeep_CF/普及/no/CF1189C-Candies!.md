# 题目信息

# Candies!

## 题目描述

考虑一个长度为 $2^k$ 的序列 $[a_1,a_2,...,a_{2^k}]\ (0 \leq a_i \leq 9)$ 。我们对这个序列进行下列操作：

每次选中 $(a_{2i+1},a_{2i}) (0\leq i <  2^{k-1})$ ，共$2^{k-1}$对数字，若$a_{2i+1}+a_{2i}\ge 10$，你就能获得一颗糖果！ ，之后将每一个$(a_{2i+1}+a_{2i}) \mod 10$ 按 $i$ 从小到大重新写成一排，形成一个新的序列，长度为$2^{k-1}$

我们不断执行这个操作直到序列的长度变为 $1$ 。我们用$f[a_1,a_2,...,a_k]$表示我们对序列$[a_1,a_2,...,a_k]$不断进行操作，最终一共获得的糖果。

举个栗子：序列为$[8,7,3,1,7,0,9,4]$

第一步之后序列变为$[5,4,7,3]$，因为$8+7\ge 10 ,9+4 \ge 10$ 所以获得 $2$ 颗糖果

第二步之后序列变为$[9,0]$，因为$7+4 \ge 10$ 所以获得 $1$ 颗糖果

第三步之后序列变为$[9]$

所以 $f([8,7,3,1,7,0,9,4]) = 3$，因为我们一共得到 $3$ 颗糖果

所以现在你有一个长度为 $n$ 的序列 $s_1,s_2,...,s_n$ ，给你 $q$ 组询问，每一次询问一个长度为 $2$ 的整数次幂的区间 
$[l_i,r_i]$，请输出 $f([s_{l_i},s_{l_{i+1}},...,s_{r_i}])$


$f([7,3,1,7])=1$，因为

$[7,3,1,7] \rightarrow [0,8] \rightarrow [8]$ ，其中$7 + 3 \ge 10$ 所以只获得 $1$ 个糖果

$f([9])=0$，因为我们不需要进行操作。

## 样例 #1

### 输入

```
8
8 7 3 1 7 0 9 4
3
1 8
2 5
7 7
```

### 输出

```
3
1
0
```

## 样例 #2

### 输入

```
6
0 1 2 3 3 5
3
1 2
1 4
3 6
```

### 输出

```
0
0
1
```

# AI分析结果

【题目内容】
# 糖果！

## 题目描述

考虑一个长度为 $2^k$ 的序列 $[a_1,a_2,...,a_{2^k}]\ (0 \leq a_i \leq 9)$ 。我们对这个序列进行下列操作：

每次选中 $(a_{2i+1},a_{2i}) (0\leq i <  2^{k-1})$ ，共$2^{k-1}$对数字，若$a_{2i+1}+a_{2i}\ge 10$，你就能获得一颗糖果！ ，之后将每一个$(a_{2i+1}+a_{2i}) \mod 10$ 按 $i$ 从小到大重新写成一排，形成一个新的序列，长度为$2^{k-1}$

我们不断执行这个操作直到序列的长度变为 $1$ 。我们用$f[a_1,a_2,...,a_k]$表示我们对序列$[a_1,a_2,...,a_k]$不断进行操作，最终一共获得的糖果。

举个栗子：序列为$[8,7,3,1,7,0,9,4]$

第一步之后序列变为$[5,4,7,3]$，因为$8+7\ge 10 ,9+4 \ge 10$ 所以获得 $2$ 颗糖果

第二步之后序列变为$[9,0]$，因为$7+4 \ge 10$ 所以获得 $1$ 颗糖果

第三步之后序列变为$[9]$

所以 $f([8,7,3,1,7,0,9,4]) = 3$，因为我们一共得到 $3$ 颗糖果

所以现在你有一个长度为 $n$ 的序列 $s_1,s_2,...,s_n$ ，给你 $q$ 组询问，每一次询问一个长度为 $2$ 的整数次幂的区间 
$[l_i,r_i]$，请输出 $f([s_{l_i},s_{l_{i+1}},...,s_{r_i}])$


$f([7,3,1,7])=1$，因为

$[7,3,1,7] \rightarrow [0,8] \rightarrow [8]$ ，其中$7 + 3 \ge 10$ 所以只获得 $1$ 个糖果

$f([9])=0$，因为我们不需要进行操作。

## 样例 #1

### 输入

```
8
8 7 3 1 7 0 9 4
3
1 8
2 5
7 7
```

### 输出

```
3
1
0
```

## 样例 #2

### 输入

```
6
0 1 2 3 3 5
3
1 2
1 4
3 6
```

### 输出

```
0
0
1
```

【算法分类】
前缀和

【题解分析与结论】
本题的核心在于发现一个关键结论：最终获得的糖果数等于区间和除以10的整数部分。这一结论大大简化了问题的复杂度，使得我们可以通过前缀和来快速计算每个询问的结果。大多数题解都基于这一结论，使用前缀和来优化查询效率。

【评分较高的题解】
1. **作者：AC_Dolphin (赞：3)**
   - **星级：4**
   - **关键亮点：简洁明了地使用了前缀和，时间复杂度为O(n)，代码简洁易读。**
   - **核心代码：**
     ```cpp
     int main(){
         read(n);
         for(register int i(1);i<=n;++i) {read(a[i]);c[i]=c[i-1]+a[i];}
         read(q);
         while(q--){
             read(l);read(r);
             int sum=c[r]-c[l-1];
             cout<<sum/10<<endl;
         }
         return 0;
     }
     ```

2. **作者：万弘 (赞：1)**
   - **星级：4**
   - **关键亮点：详细证明了结论的正确性，代码实现简洁，时间复杂度为O(n+q)。**
   - **核心代码：**
     ```cpp
     int main(){
         ll n=read();
         s[0]=0;
         for(ll i=1;i<=n;++i)s[i]=s[i-1]+read();
         ll q=read();
         while(q--){
             ll l=read(),r=read();
             std::cout<<calc(l,r)/10<<std::endl;
         }
         return 0;
     }
     ```

3. **作者：cz666 (赞：0)**
   - **星级：4**
   - **关键亮点：通过观察样例找到规律，代码实现简洁，时间复杂度为O(n)。**
   - **核心代码：**
     ```cpp
     signed main(){
         int n=read();
         for (register int i=1;i<=n;++i) a[i]=a[i-1]+read();
         int q=read();
         for (register int i=1;i<=q;++i){
             int l=read(),r=read();
             wln((a[r]-a[l-1])/10);
         }
         return 0;
     }
     ```

【最优关键思路】
通过前缀和快速计算区间和，然后除以10得到糖果数。这一方法大大简化了问题的复杂度，使得时间复杂度降低到O(n)。

【拓展思路】
类似的问题可以通过观察操作的性质，找到简化的数学规律，从而避免复杂的模拟或递归操作。

【推荐题目】
1. P3374 【模板】树状数组 1
2. P3368 【模板】树状数组 2
3. P1908 逆序对

---
处理用时：38.07秒
# 题目信息

# MP3

## 题目描述

有一种数字化一段录音的常用方式，是记录每一个时刻的强度值。这些非负的强度值就可以代表一段音频

对于一段音频，若有 $K$ 个不同的强度值，那么每一位我们都需要 $k = \lceil\log_2K \rceil$ $\text{bit}$ 来存储

也就是说，为了存储这一段音频，我们需要 $nk$ 个 $\text{bit}$

为了压缩音频大小，我们们采取如下的方式：

选择两个整数 $l, r(l \leq r)$，对于音频的强度值序列 $v$，将其作一次变换：

$$
v_i = 
\begin{cases}
v_i&l \leq v_i \leq r \\
l &v_i < l\\
r &r < v_i
\end{cases}
$$

其中第 $2, 3$ 种情况被视作 $v_i$ 这个强度值被更改了

你的任务是对于给定的强度值序列 $a$，找到一组 $l, r$，使得在经过上述压缩后能够被大小为 $I \ \text{bytes} (\text{1bytes = 8 bit})$ 的存储器装下，并最小化被更改的强度值的数量

## 样例 #1

### 输入

```
6 1
2 1 2 3 4 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 2
2 1 2 3 4 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
6 1
1 1 2 2 3 3
```

### 输出

```
2
```

# AI分析结果

### 题目内容重写
有一种数字化一段录音的常用方式，是记录每一个时刻的强度值。这些非负的强度值就可以代表一段音频。

对于一段音频，若有 $K$ 个不同的强度值，那么每一位我们都需要 $k = \lceil\log_2K \rceil$ $\text{bit}$ 来存储。也就是说，为了存储这一段音频，我们需要 $nk$ 个 $\text{bit}$。

为了压缩音频大小，我们采取如下的方式：选择两个整数 $l, r(l \leq r)$，对于音频的强度值序列 $v$，将其作一次变换：

$$
v_i = 
\begin{cases}
v_i&l \leq v_i \leq r \\
l &v_i < l\\
r &r < v_i
\end{cases}
$$

其中第 $2, 3$ 种情况被视作 $v_i$ 这个强度值被更改了。

你的任务是对于给定的强度值序列 $a$，找到一组 $l, r$，使得在经过上述压缩后能够被大小为 $I \ \text{bytes} (\text{1bytes = 8 bit})$ 的存储器装下，并最小化被更改的强度值的数量。

### 算法分类
贪心、滑动窗口、离散化

### 题解分析与结论
1. **核心思路**：通过计算最大允许的 $K$ 值（即 $K = 2^{\lfloor \frac{8I}{n} \rfloor}$），然后使用滑动窗口在排序后的序列中找到最小的修改次数。
2. **难点**：如何高效地找到 $l$ 和 $r$ 使得修改次数最小，同时满足存储限制。
3. **优化**：通过排序和滑动窗口的结合，减少时间复杂度到 $O(n \log n)$。

### 高星题解
#### 1. Zechariah (5星)
**关键亮点**：
- 通过排序和滑动窗口的结合，高效地找到最小修改次数。
- 代码简洁，逻辑清晰，优化程度高。

**核心代码**：
```cpp
rg ll kmax = (len << 3) / n, dmax = 1, tot = 0, tmp = -1;
for (rg int i = 1; i <= n; ++i) {
    if (tmp != a[i]) tmp = a[i], ++tot;
    ++cnt[tot];
}
for (rg int i = 0; i < kmax; ++i) {
    dmax <<= 1;
    if (tot <= dmax) { puts("0"); return 0; }
}
rg ll minn = 0, now;
for (rg int i = tot; i > dmax; --i)sum += cnt[i];
now = minn = sum;
for (rg int i = 2; i <= tot - dmax + 1; ++i) {
    now += cnt[i - 1];
    now -= cnt[i + dmax - 1];
    minn = fast_IO::min(minn, now);
}
fast_IO::write(minn);
```

#### 2. Peter20122012 (4星)
**关键亮点**：
- 通过离散化和滑动窗口的结合，找到最小修改次数。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int mxk = MIN(20, 8*I/n);
mxK = MIN(1 << mxk, len);
if (mxK >= len) {
    printf("0\n");
    return 0;
}
FOR (1, mxK, i) {
    change -= cnt[i];
}
ans = change;
FOR (2, len - mxK + 1, i) {
    change += cnt[i - 1];
    change -= cnt[i + mxK - 1];
    ans = MIN(ans, change);
}
printf("%i\n", ans);
```

#### 3. Rex01 (4星)
**关键亮点**：
- 使用前缀和和二分查找，优化了查找过程。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
{
    int l = i, r = n + 1;
    while(l < r - 1)
    {
        int mid = (l + r) >> 1;
        if(log2(dp[mid] - dp[i] + 1) <= I * 8 / n) l = mid;
        else r = mid;
    }
    ans = max(ans, l - i + 1);
}
cout << n - ans << endl;
```

### 最优关键思路或技巧
1. **滑动窗口**：通过滑动窗口在排序后的序列中找到最小的修改次数。
2. **离散化**：将大范围的强度值离散化，减少计算复杂度。
3. **前缀和**：通过前缀和快速计算区间内的不同强度值数量。

### 可拓展之处
1. **类似问题**：可以通过滑动窗口和离散化解决其他需要区间优化的问题。
2. **算法套路**：滑动窗口和前缀和的结合可以应用于多种区间查询和优化问题。

### 推荐题目
1. [CF1198A](https://www.luogu.com.cn/problem/CF1198A)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1496 离散化](https://www.luogu.com.cn/problem/P1496)

---
处理用时：36.58秒
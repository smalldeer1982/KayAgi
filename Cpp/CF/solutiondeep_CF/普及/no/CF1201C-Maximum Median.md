# 题目信息

# Maximum Median

## 题目描述

$Imakf$ 给您一个长度为 $n$ 的数组 $a$，$(n$ 为奇数 $)$ 您可以对数组进行如下操作

-  选择数组中的一个元素，使其增加 $1$

您有 $k$ 次操作机会，请最大化数组的中位数 

一组数据的中位数是指数组从小到大排序后位于最中间的数，例如 $[1,5,2,3,5]$ 的中位数是 $3$. 


第二行 $n$ 个整数表示数组 $a\ (1 \leq a_i \leq 10^9)$

## 说明/提示

样例 $1$ 中，对 $a_2$ 进行两次操作，数组变为 $[1,5,5]$

样例 $2$ 中，一种最佳操作是使数组变为 $[1,3,3,1,3]$ 

样例 $3$ 中，一种最佳操作是使数组变为 $[5,1,2,5,3,5,5]$

## 样例 #1

### 输入

```
3 2
1 3 5
```

### 输出

```
5```

## 样例 #2

### 输入

```
5 5
1 2 1 1 1
```

### 输出

```
3```

## 样例 #3

### 输入

```
7 7
4 1 2 4 3 4 4
```

### 输出

```
5```

# AI分析结果

【题目内容】
# Maximum Median

## 题目描述

$Imakf$ 给您一个长度为 $n$ 的数组 $a$，$(n$ 为奇数 $)$ 您可以对数组进行如下操作

-  选择数组中的一个元素，使其增加 $1$

您有 $k$ 次操作机会，请最大化数组的中位数 

一组数据的中位数是指数组从小到大排序后位于最中间的数，例如 $[1,5,2,3,5]$ 的中位数是 $3$. 


第二行 $n$ 个整数表示数组 $a\ (1 \leq a_i \leq 10^9)$

## 说明/提示

样例 $1$ 中，对 $a_2$ 进行两次操作，数组变为 $[1,5,5]$

样例 $2$ 中，一种最佳操作是使数组变为 $[1,3,3,1,3]$ 

样例 $3$ 中，一种最佳操作是使数组变为 $[5,1,2,5,3,5,5]$

## 样例 #1

### 输入

```
3 2
1 3 5
```

### 输出

```
5```

## 样例 #2

### 输入

```
5 5
1 2 1 1 1
```

### 输出

```
3```

## 样例 #3

### 输入

```
7 7
4 1 2 4 3 4 4
```

### 输出

```
5```

【算法分类】
二分

【题解分析与结论】
本题的核心目标是通过最多 $k$ 次操作最大化数组的中位数。由于中位数的性质，我们只需要关注排序后中位数及其后面的元素。大多数题解采用了二分查找的思路，通过二分中位数的可能值，检查是否可以在 $k$ 次操作内达到该值。这种方法的时间复杂度为 $O(n \log n)$，能够有效处理题目中的数据范围。

【评分较高的题解】
1. **作者：_HMZ_ (赞：8)**
   - **星级：4星**
   - **关键亮点：** 通过直接遍历中位数及其后面的元素，计算需要的操作次数，避免了复杂的二分查找，思路清晰且代码简洁。
   - **核心代码：**
     ```cpp
     for(int i=n/2+1;i<=n;) {
         int now=a[i];
         while(a[i]==now) ++cnt,++i;
         if(i>n) break;
         int c=(a[i]-now)*cnt;
         if(k>c) k-=c;
         else {
             cout<<k/cnt+now<<endl;
             return 0;
         }
     }
     cout<<a[n]+k/cnt;
     ```

2. **作者：МiсDZ (赞：7)**
   - **星级：4星**
   - **关键亮点：** 使用二分查找，通过 `check` 函数验证中位数的可行性，代码结构清晰，逻辑严谨。
   - **核心代码：**
     ```cpp
     bool check(ll x) {
         int cnt=0;
         REP(i,(n+1)/2,n) {
             if(a[i]>=x) return 1;
             if(x-a[i]>k-cnt) return 0;
             cnt+=x-a[i];
         }
         return 1;
     }
     ```

3. **作者：Zechariah (赞：2)**
   - **星级：4星**
   - **关键亮点：** 通过贪心策略，直接从中位数开始向后增加元素，代码简洁且效率高。
   - **核心代码：**
     ```cpp
     for(rg int i=(n>>1)+2;i<=n;++i) {
         if(k>=cnt*(a[i]-a[(n>>1)+1])) {
             k-=cnt*(a[i]-a[(n>>1)+1]);
             ++cnt; a[(n>>1)+1]=a[i];
         }
         else break;
     }
     fast_IO::write(a[(n>>1)+1]+k/cnt);
     ```

【最优关键思路】
1. **二分查找：** 通过二分中位数的可能值，检查是否可以在 $k$ 次操作内达到该值，时间复杂度为 $O(n \log n)$。
2. **贪心策略：** 直接从中位数开始向后增加元素，确保每次操作都最大化中位数的提升。

【可拓展之处】
- **类似题目：** 可以扩展到其他需要最大化或最小化某个特定值的题目，如最大化最小值、最小化最大值等。
- **算法套路：** 二分查找和贪心策略在优化问题中非常常见，掌握这两种方法可以解决许多类似的问题。

【推荐题目】
1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)
3. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)

---
处理用时：33.99秒
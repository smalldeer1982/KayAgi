# 题目信息

# You Are Given a Decimal String...

## 题目描述

你现在有一个神奇的计算器，~~这是闪现牌计算器（洛谷独家赞助，codeforces特别生产），~~ 这种计算器被称为$x-y$计算器。

因为是~~闪现牌~~神奇计算器，所以它的操作也非常神奇。这个计算器的初始数值为$0$，然后你可以加一个数值$x$或$y$。当然，在这一步之前，你需要先输出当前数值的最后一位。

这是$4-2$的一种情况：

1. 输出$0$，然后加上$4$，当前数值为$4$，当前输出$0$。
1. 输出$4$，然后加上$4$，当前数值为$8$，当前输出$04$。
1. 输出$8$，然后加上$4$，当前数值为$12$，当前输出$048$。
1. 输出$2$，然后加上$2$，当前数值为$14$，当前输出$0482$。
1. 输出$4$，然后加上$4$，当前数值为$18$，当前输出$04824$。

当然，这只是一种情况。如果我们每次都加$2$，还可以得到$0246802468024$这个序列。

现在你有一个由$x-y$计算器得到的序列$s$，但是由于这个计算器为初代产品，某些数字丢失了。

然而你想恢复这个序列，不过问题是你并不知道这是哪一款$x-y$计算器（即不知道$x$与$y$的大小），所以对于每一款$x-y(0≤x,y<10)$计算器，输出使序列$s$变为能由该款计算器能得到的序列最小所需插入的数字数。

## 样例 #1

### 输入

```
0840
```

### 输出

```
-1 17 7 7 7 -1 2 17 2 7 
17 17 7 5 5 5 2 7 2 7 
7 7 7 4 3 7 1 7 2 5 
7 5 4 7 3 3 2 5 2 3 
7 5 3 3 7 7 1 7 2 7 
-1 5 7 3 7 -1 2 9 2 7 
2 2 1 2 1 2 2 2 0 1 
17 7 7 5 7 9 2 17 2 3 
2 2 2 2 2 2 0 2 2 2 
7 7 5 3 7 7 1 3 2 7 
```

# AI分析结果

### 题目重写
你现在有一个神奇的计算器，这种计算器被称为$x-y$计算器。这个计算器的初始数值为$0$，然后你可以加一个数值$x$或$y$。当然，在这一步之前，你需要先输出当前数值的最后一位。

这是$4-2$的一种情况：

1. 输出$0$，然后加上$4$，当前数值为$4$，当前输出$0$。
1. 输出$4$，然后加上$4$，当前数值为$8$，当前输出$04$。
1. 输出$8$，然后加上$4$，当前数值为$12$，当前输出$048$。
1. 输出$2$，然后加上$2$，当前数值为$14$，当前输出$0482$。
1. 输出$4$，然后加上$4$，当前数值为$18$，当前输出$04824$。

当然，这只是一种情况。如果我们每次都加$2$，还可以得到$0246802468024$这个序列。

现在你有一个由$x-y$计算器得到的序列$s$，但是由于这个计算器为初代产品，某些数字丢失了。

然而你想恢复这个序列，不过问题是你并不知道这是哪一款$x-y$计算器（即不知道$x$与$y$的大小），所以对于每一款$x-y(0≤x,y<10)$计算器，输出使序列$s$变为能由该款计算器能得到的序列最小所需插入的数字数。

### 算法分类
图论

### 题解分析与结论
这道题的核心是通过图论中的最短路径算法（如Floyd算法）来预处理所有可能的$x-y$计算器操作，然后根据输入字符串计算需要插入的最小字符数。难点在于如何处理相邻字符相同的情况以及如何高效地预处理所有可能的操作。

### 所选题解

#### 题解1：ttwyzz (4星)
**关键亮点：**
- 使用Floyd算法预处理所有可能的$x-y$计算器操作。
- 详细解释了为什么在初始化时不能将`a[k][k]`设为0，因为相邻字符相同的情况需要特殊处理。
- 代码清晰，注释详细，易于理解。

**核心代码：**
```cpp
for(int n = 0; n <= 9; ++n) {
    for(int m = 0; m <= 9; ++m) {
        memset(a, 0x3f , sizeof a);
        for(int k = 0; k <= 9; ++k) {
            a[k][(k+n) % 10] = 1; 
            a[k][(k+m) % 10] = 1;
        }
        for(int l = 0; l <= 9; ++l) {
            for(int i = 0; i <= 9; ++i) {
                for(int j = 0; j <= 9; ++j) {
                    a[i][j] = min(a[i][j] , a[i][l] + a[l][j]); 
                }
            }
        }
        for(int l = 0; l < len - 1 ; ++l) {
            if(a[s[l] - '0'][s[l+1] - '0'] == 0x3f3f3f3f3f3f3f3f) {
                ans[n][m] = -1;
                break;
            }
            ans[n][m] += a[s[l] - '0'][s[l+1] - '0'] - 1;
        }
    }
}
```

#### 题解2：zhanghengrui (4星)
**关键亮点：**
- 使用四重循环预处理所有可能的$x-y$计算器操作，时间复杂度较高但思路清晰。
- 详细解释了如何处理无法操作的情况，代码逻辑严谨。

**核心代码：**
```cpp
for (long i = 0L; i < 10L; ++i) {
    for (long j = 0L; j < 10L; ++j) {
        for (long k = 0L; k < 10L; ++k) {
            for (long l = 0L; l < 10L; ++l) {
                F[i][j][k][l] = LONG_MAX >> 1;
                for (long m = 0L; m < 10L; ++m) {
                    for (long n = 0L; n < 10L; ++n) {
                        if (m == 0L && n == 0L) continue;
                        if ((k + m * i + n * j) % 10L == l) F[i][j][k][l] = std::min(F[i][j][k][l], m + n);
                    }
                }
                if (F[i][j][k][l] == LONG_MAX >> 1) F[i][j][k][l] = -1L;
            }
        }
    }
}
```

### 最优关键思路
- 使用Floyd算法预处理所有可能的$x-y$计算器操作，确保能够快速查询任意两个数字之间的最小操作次数。
- 特殊处理相邻字符相同的情况，避免错误计算。

### 可拓展之处
- 类似的问题可以扩展到其他进制或更复杂的操作规则。
- 可以结合其他图论算法（如Dijkstra算法）进行优化。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得
- 在处理相邻字符相同的情况时，需要特别注意不能直接将`a[k][k]`设为0，否则会导致错误计算。
- 预处理所有可能的操作是解决此类问题的关键，能够大幅减少查询时间。

---
处理用时：40.31秒
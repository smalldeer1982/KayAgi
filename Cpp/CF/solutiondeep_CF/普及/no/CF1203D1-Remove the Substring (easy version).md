# 题目信息

# Remove the Substring (easy version)

## 题目描述

**请注意：本题的简单版和困难版之间的唯一区别是字符串的长度限制。**  

给你一个字符串$s$和一个字符串$t$，两者都只包含小写字母。你可以通过从$s$中删除一些字符（不必连续，可不删除）而不改变剩余字符的顺序（换句话说，删除一些字符后$t$仍然是$s$的子序列），保证最初$t$是$s$的子序列。  
例如，字符串"`test`", "`tst`", "`tt`", "`et`"和""都是字符串"`test`"的子序列，而"`tset`", "`se`", "`contest`"都不是字符串"`test`"的子序列。   
您希望从s中删除一些最大可能长度的连续子序列，在删除后t仍将是s的子序列。  
如果要删除子串$s[l;r]$，则原字符串$s$将变化为$s_1s_2...s_{l-1}s_{r+1}s_{r+2}...s_{|s|-1}s_{|s|}$ （$|s|$为字符串$s$的长度）。  
找到可以删除的连续子字符串的最大可能长度，使得删除后$t$仍将是$s$的子序列。

## 样例 #1

### 输入

```
bbaba
bb
```

### 输出

```
3
```

## 样例 #2

### 输入

```
baaba
ab
```

### 输出

```
2
```

## 样例 #3

### 输入

```
abcde
abcde
```

### 输出

```
0
```

## 样例 #4

### 输入

```
asdfasdf
fasd
```

### 输出

```
3
```

# AI分析结果

【题目内容】
# 删除子串（简单版）

## 题目描述

**请注意：本题的简单版和困难版之间的唯一区别是字符串的长度限制。**  

给你一个字符串$s$和一个字符串$t$，两者都只包含小写字母。你可以通过从$s$中删除一些字符（不必连续，可不删除）而不改变剩余字符的顺序（换句话说，删除一些字符后$t$仍然是$s$的子序列），保证最初$t$是$s$的子序列。  
例如，字符串"`test`", "`tst`", "`tt`", "`et`"和""都是字符串"`test`"的子序列，而"`tset`", "`se`", "`contest`"都不是字符串"`test`"的子序列。   
您希望从s中删除一些最大可能长度的连续子序列，在删除后t仍将是s的子序列。  
如果要删除子串$s[l;r]$，则原字符串$s$将变化为$s_1s_2...s_{l-1}s_{r+1}s_{r+2}...s_{|s|-1}s_{|s|}$ （$|s|$为字符串$s$的长度）。  
找到可以删除的连续子字符串的最大可能长度，使得删除后$t$仍将是$s$的子序列。

## 样例 #1

### 输入

```
bbaba
bb
```

### 输出

```
3
```

## 样例 #2

### 输入

```
baaba
ab
```

### 输出

```
2
```

## 样例 #3

### 输入

```
abcde
abcde
```

### 输出

```
0
```

## 样例 #4

### 输入

```
asdfasdf
fasd
```

### 输出

```
3
```

【算法分类】  
字符串

【题解分析与结论】  
本题的核心在于如何在字符串$s$中找到可以删除的最长连续子串，使得删除后$t$仍然是$s$的子序列。题解主要分为两种思路：  
1. **贪心算法**：通过分别从$s$的前后扫描，找到$t$中每个字符在$s$中的最早和最晚出现位置，然后计算可以删除的最大区间。  
2. **暴力枚举**：枚举所有可能的删除区间，检查删除后$t$是否仍然是$s$的子序列。

【评分较高的题解】  
1. **作者：tXX_F (4星)**  
   - **关键亮点**：通过分别从$s$的前后扫描，记录$t$中每个字符在$s$中的最早和最晚出现位置，然后计算可以删除的最大区间。思路清晰，代码简洁。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= len1 && len <= len2; i++) {
         if (s[i] == t[len]) {
             a1[len++] = i;
         }
     }
     for (int i = len1; i >= 1 && len >= 1; i--) {
         if (s[i] == t[len]) {
             a2[len--] = i;
         }
     }
     ans = max(a2[1] - 1, len1 - a1[len2]);
     for (int i = 1; i < len2; i++) {
         ans = max(ans, a2[i + 1] - a1[i] - 1);
     }
     ```

2. **作者：_Fontainebleau_ (4星)**  
   - **关键亮点**：通过贪心算法，分别从$s$的前后扫描，记录$t$中每个字符在$s$中的最早和最晚出现位置，然后计算可以删除的最大区间。代码实现简洁，时间复杂度低。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= slen; i++) {
         if (s[i] == t[p]) frt[p++] = i;
         if (p > tlen) break;
     }
     for (int i = slen; i >= 1; i--) {
         if (s[i] == t[p]) bck[p--] = i;
         if (p < 1) break;
     }
     int ans = max(bck[1] - 1, slen - frt[tlen]);
     for (int i = 1; i < tlen; i++) {
         ans = max(ans, bck[i + 1] - frt[i] - 1);
     }
     ```

3. **作者：Peter20122012 (4星)**  
   - **关键亮点**：通过贪心算法，分别从$s$的前后扫描，记录$t$中每个字符在$s$中的最早和最晚出现位置，然后计算可以删除的最大区间。代码实现简洁，时间复杂度低。  
   - **核心代码**：
     ```cpp
     for (int i = 1, j = 1; i <= n && j <= m; ++i) {
         if (s[i] == t[j]) {
             idxl[j] = i;
             ++j;
         }
     }
     for (int i = n, j = m; i >= 1 && j >= 1; --i) {
         if (s[i] == t[j]) {
             idxr[j] = i;
             --j;
         }
     }
     ans = MAX(n - idxl[m], idxr[1] - 1);
     FOR (1, m - 1, i) {
         ans = MAX(ans, idxr[i + 1] - idxl[i] - 1);
     }
     ```

【最优关键思路】  
通过分别从$s$的前后扫描，记录$t$中每个字符在$s$中的最早和最晚出现位置，然后计算可以删除的最大区间。这种贪心算法的时间复杂度为$O(n)$，效率较高。

【拓展思路】  
类似的问题可以通过贪心算法或动态规划来解决，例如在字符串中寻找最长回文子序列或最长公共子序列等。

【推荐题目】  
1. [CF1203D2 Remove the Substring (hard version)](https://www.luogu.com.cn/problem/CF1203D2)  
2. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)  
3. [P1090 【模板】最长回文子序列](https://www.luogu.com.cn/problem/P1090)

---
处理用时：40.28秒
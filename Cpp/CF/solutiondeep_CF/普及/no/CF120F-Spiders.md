# 题目信息

# Spiders

## 题目描述

Petya 有 $n$ 只玩具蜘蛛，每只玩具蜘蛛可以看作一棵无根树。节点大小忽略不计，边的长度为 1。

Petya 可以在两只蜘蛛中各选一个节点粘在一起，从而形成一只新蜘蛛。新的蜘蛛也是一棵树。

他希望把所有蜘蛛用上面的方式粘在一起，并让新形成的蜘蛛中最远的两个节点距离最大（即树的直径最大）。

如图，在样例 2 中，Petya 将第一只蜘蛛的 2 号点与第二只蜘蛛的 1 号点粘在一起，新得到的蜘蛛的直径被加粗标出。

## 样例 #1

### 输入

```
1
3 1 2 2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
2
3 1 2 1 3
4 1 2 2 3 2 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
2
5 1 2 2 3 3 4 3 5
7 3 4 1 2 2 4 4 6 2 7 6 5
```

### 输出

```
7
```

# AI分析结果



# 中文题目重写
（原题已为中文，无需重写）

# 算法分类
贪心、图论（树的直径）

# 题解综合分析
本题核心在于通过贪心策略将各树的直径端点相连，最终总直径为各树直径之和。所有题解均采用以下思路：
1. 对每棵树计算其直径
2. 将所有树的直径累加即为答案
关键技巧在于正确计算单棵树的直径，主流方法为两次DFS/BFS或树形DP。难点在于理解最优连接策略的数学正确性。

# 精选题解
## 1. Priori_Incantatem（4星）
**关键亮点**：  
- 使用树形DP计算直径，代码结构清晰  
- 明确说明将各树直径端点依次相连的贪心策略  
- 处理多组测试数据时清空数据结构严谨  

**核心代码**：
```cpp
void dfs(int x, int fa) {
    int m1 = 0, m2 = 0;
    for (int y : e[x]) {
        if (y == fa) continue;
        dfs(y, x);
        int tmp = f[y] + 1;
        if (tmp > m1) m2 = m1, m1 = tmp;
        else if (tmp > m2) m2 = tmp;
    }
    dis[x] = m1 + m2;
}
// 遍历所有节点取dis数组最大值即为单树直径
```

## 2. copper_ingot（4星）
**关键亮点**：  
- 采用两次BFS计算直径，时间复杂度稳定  
- 强调文件读写细节（重要易错点）  
- 代码简洁适合快速实现  

**核心代码**：
```cpp
void bfs(int st) {
    memset(dis, 0x3f, sizeof(dis));
    queue<int> q;
    q.push(st); dis[st] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v = 1; v <= m; v++) {
            if (g[u][v] && dis[v] == 0x3f3f3f3f) {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
}
// 第一次BFS找最远点，第二次BFS求直径
```

## 3. Mine_King（4星）
**关键亮点**：  
- 使用两次DFS实现直径计算  
- 代码模块化清晰易维护  
- 变量命名简洁，逻辑紧凑  

**核心代码**：
```cpp
void dfs(int now, int fa, int depth) {
    if (depth > maxd) {
        maxd = depth;
        pos = now;
    }
    for (int i = hd[now]; i; i = nxt[i]) {
        if (to[i] != fa) 
            dfs(to[i], now, depth + 1);
    }
}
// 第一次DFS找端点，第二次计算长度
```

# 关键思路总结
**最优策略**：将各树直径端点依次串联，总直径即各树直径之和。  
**实现要点**：
1. 计算单树直径的两种方法：  
   - 两次DFS/BFS：O(n)时间复杂度，需两次遍历  
   - 树形DP：单次DFS维护最长/次长路径  
2. 必须处理文件输入输出  
3. 多组数据需清空图结构

# 同类题目推荐
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
2. [P4408 逃学的小孩](https://www.luogu.com.cn/problem/P4408)  
3. [P3629 巡逻](https://www.luogu.com.cn/problem/P3629)

---
处理用时：78.91秒
# 题目信息

# Traveling Around the Golden Ring of Berland

## 题目描述

一位博主Polycarp想游览柏林的著名景点The Golden Ring.



The Golden Ring由n个城市组成为环状，城市编号由1到n。（注意：和第n个城市相连的是第一个城市和第n-1个城市）已知Polycarp想在每个城市拍几张自拍，Polycarp从第一个城市开始他的旅程，并且循环旅行，也就是说他从1城市到n城市后下一个访问的城市仍然是1城市。他每次访问一个城市至多拍一张自拍，而且循环旅行时经过的城市都要访问（无论拍不拍自拍）。



现在要求求出Polycarp的城市访问数。

## 样例 #1

### 输入

```
3
1 0 0
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
2 0 2
```

### 输出

```
6
```

## 样例 #3

### 输入

```
5
0 3 1 3 2
```

### 输出

```
14
```

## 样例 #4

### 输入

```
5
1000000000 1000000000 1000000000 1000000000 0
```

### 输出

```
4999999999
```

# AI分析结果

### 题目内容重写
**题目描述**

一位博主Polycarp想游览柏林的著名景点The Golden Ring。The Golden Ring由n个城市组成，城市编号由1到n，形成一个环状结构（即第n个城市与第1个城市相连）。Polycarp从第一个城市开始他的旅程，并且循环旅行，也就是说他从1城市到n城市后下一个访问的城市仍然是1城市。他每次访问一个城市至多拍一张自拍，而且循环旅行时经过的城市都要访问（无论拍不拍自拍）。现在要求求出Polycarp的城市访问数。

### 算法分类
数学

### 题解分析与结论
所有题解的核心思路都是通过找到自拍数最大的城市，计算其所需的循环次数，并加上该城市的位置来得到总访问数。具体来说，公式为 `(max_value - 1) * n + max_index`，其中 `max_value` 是自拍数的最大值，`max_index` 是最大值对应的城市下标。

### 所选高分题解
1. **作者：夙愿扬 (5星)**
   - **关键亮点**：思路清晰，代码简洁，直接通过遍历数组找到最大值及其下标，并使用公式计算结果。
   - **代码核心**：
     ```cpp
     long long n, a[1000001], maxn = 0, maxm;
     scanf("%lld", &n);
     for (long long i = 1; i <= n; i++) {
         scanf("%lld", &a[i]);
         if (a[i] >= maxn) {
             maxn = a[i];
             maxm = i;
         }
     }
     printf("%lld", (a[maxm] - 1) * n + maxm);
     ```

2. **作者：louliu (4星)**
   - **关键亮点**：详细解释了为什么需要找到最后一个最大值，并解释了循环次数减一的原因。
   - **代码核心**：
     ```cpp
     long long a, b[100005], Max = 0, point;
     cin >> a;
     for (int i = 1; i <= a; i++) {
         cin >> b[i];
         if (Max <= b[i]) {
             Max = b[i];
             point = i;
         }
     }
     cout << (b[point] - 1) * a + point;
     ```

3. **作者：2021zjhs005 (4星)**
   - **关键亮点**：提供了详细的解释和公式推导，并强调了使用 `long long` 的重要性。
   - **代码核心**：
     ```cpp
     ll n, maxn = INT_MIN, pos;
     n = read();
     rep(i, 1, n) {
         ll x = read();
         if (x >= maxn) {
             maxn = x;
             pos = i;
         }
     }
     pr("%lld\n", (maxn - 1ll) * n + pos);
     ```

### 最优关键思路或技巧
- **关键思路**：通过找到自拍数最大的城市，计算其所需的循环次数，并加上该城市的位置来得到总访问数。
- **技巧**：使用 `long long` 类型避免溢出，确保在最大值有多个时选择最后一个最大值。

### 可拓展之处
- **同类型题**：类似的问题可以出现在需要计算循环次数或周期性访问的场景中，如循环队列、周期性任务调度等。
- **类似算法套路**：在需要处理循环结构或周期性数据时，可以通过找到关键点（如最大值、最小值）来计算总访问次数或总时间。

### 推荐题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
3. [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019)

---
处理用时：27.44秒
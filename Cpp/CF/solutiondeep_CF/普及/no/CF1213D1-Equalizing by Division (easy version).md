# 题目信息

# Equalizing by Division (easy version)

## 题目描述

简单版和困难版之间的唯一区别在于数组元素的数量。

给定一个数组$a$，包含$n$个整数。每次操作你可以选择任一$a_i$并且将其除$2$向下取整（也就是说，每次操作中你可以使$a_i:=\lfloor \frac{a_i}{2} \rfloor$）。

你可以对任何$a_i$进行任意次（可以是零次）操作。

你的任务是计算最小的操作次数使得至少$k$个数组中的数字相等。

别忘了在几次操作后可能会有$a_i=0$的情况出现，因此答案始终存在。

## 样例 #1

### 输入

```
5 3
1 2 2 4 5
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 3
1 2 3 4 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 3
1 2 3 3 3
```

### 输出

```
0
```

# AI分析结果

### 题目内容
# Equalizing by Division (easy version)

## 题目描述

简单版和困难版之间的唯一区别在于数组元素的数量。

给定一个数组$a$，包含$n$个整数。每次操作你可以选择任一$a_i$并且将其除$2$向下取整（也就是说，每次操作中你可以使$a_i:=\lfloor \frac{a_i}{2} \rfloor$）。

你可以对任何$a_i$进行任意次（可以是零次）操作。

你的任务是计算最小的操作次数使得至少$k$个数组中的数字相等。

别忘了在几次操作后可能会有$a_i=0$的情况出现，因此答案始终存在。

## 样例 #1

### 输入

```
5 3
1 2 2 4 5
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 3
1 2 3 4 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 3
1 2 3 3 3
```

### 输出

```
0
```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略，将数组中的元素通过除以2的操作变为相同的数，并计算最小操作次数。大多数题解都采用了类似的思路：对每个元素进行除以2的操作，记录每个可能的数及其对应的操作次数，然后从中选择满足条件的最小操作次数。

### 所选高星题解
1. **作者：andyli (赞：6)**  
   **星级：5**  
   **关键亮点：**  
   - 通过排序数组，确保在计算操作次数时优先选择较小的数，从而减少操作次数。
   - 使用两个数组分别记录每个数变为目标数的次数和数量，确保在达到k个目标数时停止进一步操作。
   - 代码简洁且高效，时间复杂度为O(n log n)。

   **核心代码：**
   ```cpp
   for (int i = 1; i <= n; i++) {
       int x = A[i], sum = 0;
       while (x) {
           if (cntc[x] < k) 
               cntc[x]++, cnts[x] += sum;
           x /= 2;
           sum++;
       }
   }
   ```

2. **作者：copper_ingot (赞：2)**  
   **星级：4**  
   **关键亮点：**  
   - 与andyli的思路类似，但更详细地解释了如何通过排序和贪心策略减少操作次数。
   - 代码结构清晰，易于理解，适合初学者学习。

   **核心代码：**
   ```cpp
   for (int i = 1; i <= n; i++){
       int x = a[i], sum = 0;
       while (x){
           if (cnt[x] < k) cnt[x]++, s[x] += sum;
           x /= 2; sum++;
       }
   }
   ```

3. **作者：wuyixiang (赞：2)**  
   **星级：4**  
   **关键亮点：**  
   - 使用vector记录每个数变为目标数的操作次数，并通过排序选择前k小的操作次数。
   - 代码实现较为直观，适合理解贪心策略的应用。

   **核心代码：**
   ```cpp
   for(int i = 0;i <= 200000;i ++){
       if(ve[i].size() < k)continue;
       sort(ve[i].begin(),ve[i].end());
       int u = 0;
       for(int j = 0;j < k;j ++)u += ve[i][j];
       minn = min(minn,u);
   }
   ```

### 最优关键思路或技巧
- **贪心策略**：通过优先选择较小的数进行除以2的操作，减少操作次数。
- **排序优化**：对数组进行排序，确保在计算操作次数时优先选择较小的数。
- **记录与筛选**：使用数组或vector记录每个数变为目标数的操作次数和数量，筛选出满足条件的最小操作次数。

### 可拓展之处
- **类似题目**：可以扩展到其他需要通过操作使数组元素满足某种条件的题目，如通过加法或乘法操作使数组元素相等。
- **优化思路**：可以考虑使用更高效的数据结构或算法进一步优化时间复杂度。

### 推荐题目
1. [CF1213D2 - Equalizing by Division (hard version)](https://www.luogu.com.cn/problem/CF1213D2)
2. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录
- **andyli**：通过排序数组，确保在计算操作次数时优先选择较小的数，从而减少操作次数。这种贪心策略在实际应用中非常有效。
- **copper_ingot**：排序后一旦达到k个目标数，就不再继续操作，这种优化思路在实际编程中非常实用。

---
处理用时：34.55秒
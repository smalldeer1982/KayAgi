# 题目信息

# Bad Sequence

## 题目描述

给出一个长度为 $n$ 的括号序列 $s$ , 求出 $s$ 能否通过移动不超过 $1$ 个括号的位置, 使得这个括号序列变成一个正确的括号序列.

我们定义满足下面任意一个条件的括号序列 $S$ 为一个正确的括号序列:

- $S$ 是一个空串
- $S = (t)$ , 其中 $t$ 是一个正确的括号序列
- $S = t_1 + t_2$ , 其中 $t_1$ , $t_2$ 都是正确的括号序列, '$+$' 运算定义为字符串的拼接.

## 说明/提示

$1 \leq n \leq 200000$

## 样例 #1

### 输入

```
2
)(
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
3
(()
```

### 输出

```
No
```

## 样例 #3

### 输入

```
2
()
```

### 输出

```
Yes
```

## 样例 #4

### 输入

```
10
)))))(((((
```

### 输出

```
No
```

# AI分析结果

### 题目重写
# 错误的括号序列

## 题目描述

给出一个长度为 $n$ 的括号序列 $s$，求出 $s$ 能否通过移动不超过 $1$ 个括号的位置，使得这个括号序列变成一个正确的括号序列。

我们定义满足下面任意一个条件的括号序列 $S$ 为一个正确的括号序列：

- $S$ 是一个空串
- $S = (t)$，其中 $t$ 是一个正确的括号序列
- $S = t_1 + t_2$，其中 $t_1$，$t_2$ 都是正确的括号序列，'$+$' 运算定义为字符串的拼接。

## 说明/提示

$1 \leq n \leq 200000$

## 样例 #1

### 输入

```
2
)(
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
3
(()
```

### 输出

```
No
```

## 样例 #3

### 输入

```
2
()
```

### 输出

```
Yes
```

## 样例 #4

### 输入

```
10
)))))(((((
```

### 输出

```
No
```

### 算法分类
字符串、模拟

### 题解分析与结论
本题的核心是通过模拟栈来判断括号序列是否合法，并且允许最多移动一个括号的位置。各题解大多基于栈的模拟，通过统计未匹配的左右括号数量来判断是否可以通过一次移动使其合法。

### 高星题解推荐
1. **作者：L______ (赞：8)**  
   - **星级：4.5**  
   - **关键亮点**：通过栈模拟直接判断未匹配的括号数量，简洁明了。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         if(ch[i]=='(') s[++top]=1;
         else{
             if(top!=0 && s[top]==1) top--;
             else s[++top]=0;
         }
     }
     if(top==0 || (top==2 && s[1]==0 && s[2]==1)) printf("Yes\n");
     else printf("No\n");
     ```

2. **作者：Meatherm (赞：2)**  
   - **星级：4**  
   - **关键亮点**：分别统计未匹配的左右括号数量，逻辑清晰。  
   - **核心代码**：
     ```cpp
     for(rr int i=1;i<=n;++i){
         if(c[i]=='('){
             ++stacksum;
         }else{
             if(stacksum==0){
                 ++Rightsum;
             }else{
                 --stacksum;
             }
         }
     }
     Leftsum=stacksum;
     if(Leftsum==Rightsum&&(Leftsum==1||Leftsum==0)){
         printf("Yes");
     }else{
         printf("No");
     }
     ```

3. **作者：meyi (赞：0)**  
   - **星级：4**  
   - **关键亮点**：使用累加器记录未匹配的括号数量，代码简洁高效。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;++i){
         m+=(s[i]=='('?1:-1);
         if(m<-1)return puts("No"),0;
     }
     puts(m?"No":"Yes");
     ```

### 最优关键思路
通过栈模拟或累加器记录未匹配的括号数量，判断是否可以通过一次移动使其合法。关键在于统计未匹配的左右括号数量，并判断其是否满足条件。

### 拓展思路
类似题目可以通过栈或累加器来模拟括号匹配问题，如判断括号序列是否合法、计算最长合法子序列等。

### 推荐题目
1. [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)

---
处理用时：26.33秒
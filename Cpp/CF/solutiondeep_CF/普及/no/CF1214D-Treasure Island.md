# 题目信息

# Treasure Island

## 题目描述

我们都喜爱宝藏，对吧？这就是为何年轻的 Vasya 正在向一个宝藏岛进发。

宝藏岛可以看做一个$n \times m$的矩阵，行从上到下标号为$1..n$，列从左到右标号为$1..m$。Vasya 现在在第$1$行，第$1$列，而宝藏位于第$n$行，第$m$列。

宝藏岛上有些位置是可以通过的空地，而其他位置是不可经过的丛林。

现在 Vasya 正急着寻找宝藏。他可以从第$i$行，第$j$列走到第$i+1$行，第$j$列或第$i$行，第$j+1$列，即，可以向下或向右走。当然他不能通过丛林区域。

邪恶的女巫不想让 Vasya 得到宝藏。她可以用魔法使得一块空地变成丛林。当然，她不能对第$1$行，第$1$列或第$n$行，第$m$列施法。

请计算女巫至少需要将几块丛林变成空地，才能完全阻止 Vasya 获得宝藏。

## 说明/提示

$3 \leq n \times m \leq 10^6$

## 样例 #1

### 输入

```
2 2
..
..
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 4
....
#.#.
....
.#..
```

### 输出

```
1
```

## 样例 #3

### 输入

```
3 4
....
.##.
....
```

### 输出

```
2
```

# AI分析结果

【题目内容】
# 宝藏岛

## 题目描述

我们都喜爱宝藏，对吧？这就是为何年轻的 Vasya 正在向一个宝藏岛进发。

宝藏岛可以看做一个$n \times m$的矩阵，行从上到下标号为$1..n$，列从左到右标号为$1..m$。Vasya 现在在第$1$行，第$1$列，而宝藏位于第$n$行，第$m$列。

宝藏岛上有些位置是可以通过的空地，而其他位置是不可经过的丛林。

现在 Vasya 正急着寻找宝藏。他可以从第$i$行，第$j$列走到第$i+1$行，第$j$列或第$i$行，第$j+1$列，即，可以向下或向右走。当然他不能通过丛林区域。

邪恶的女巫不想让 Vasya 得到宝藏。她可以用魔法使得一块空地变成丛林。当然，她不能对第$1$行，第$1$列或第$n$行，第$m$列施法。

请计算女巫至少需要将几块丛林变成空地，才能完全阻止 Vasya 获得宝藏。

## 说明/提示

$3 \leq n \times m \leq 10^6$

## 样例 #1

### 输入

```
2 2
..
..
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 4
....
#.#.
....
.#..
```

### 输出

```
1
```

## 样例 #3

### 输入

```
3 4
....
.##.
....
```

### 输出

```
2
```

【算法分类】  
深度优先搜索 DFS

【题解分析与结论】  
本题的核心是通过DFS或BFS来寻找从起点到终点的路径，并判断是否存在必经点。大多数题解都采用了DFS或BFS的思路，通过两次搜索来判断是否存在必经点，从而确定答案。最优的思路是通过两次DFS，第一次优先向下搜索，第二次优先向右搜索，若两次都能找到路径，则说明存在两条不相交的路径，答案为2；否则答案为1。

【所选高星题解】  
1. **作者：lenlen (赞：11)**  
   - **星级：5星**  
   - **关键亮点**：通过两次DFS，第一次优先向下搜索，第二次优先向右搜索，确保两条路径不相交，从而判断是否存在必经点。  
   - **代码核心**：通过DFS标记路径上的点，第二次DFS时交换搜索方向，确保两条路径不相交。
   ```cpp
   void dfs(int x,int y)
   {
       if(ans) return ;
       if(x==n&&y==m)
       {
           ans=1;
           return ;
       }
       for(int i=0;i<2;i++)
       {
           int xx=x+dx[i],yy=y+dy[i];
           if(xx<1||yy<1||xx>n||yy>m) continue;
           if(s[xx][yy]=='#') continue;
           s[xx][yy]='#';
           dfs(xx,yy);
           if(ans) return ;
       }
   }
   ```

2. **作者：Koakuma (赞：10)**  
   - **星级：4星**  
   - **关键亮点**：通过两次DFS，第一次标记路径上的点，第二次判断是否存在另一条路径，思路清晰且代码简洁。  
   - **代码核心**：通过DFS标记路径上的点，第二次DFS时判断是否存在另一条路径。
   ```cpp
   int dfs(int x, int y) {
       if (x == N - 1 && y == M - 1) return 1;
       if (x >= N || y >= M) return 0;
       if (s[x][y] == '#') return 0;
       if (x || y) s[x][y] = '#';
       return dfs(x + 1, y) || dfs(x, y + 1);
   }
   ```

3. **作者：Gu_Pigeon (赞：2)**  
   - **星级：4星**  
   - **关键亮点**：通过支配树的概念来解决必经点问题，思路新颖且高效。  
   - **代码核心**：通过支配树来判断是否存在必经点，复杂度较低。
   ```cpp
   inline int lca(int x, int y) {
       if (d[x] < d[y]) swap(x, y);
       for (int i = 19; i >= 0; i--) if (d[fa[x][i]] >= d[y]) x = fa[x][i];
       if(x == y) return x;
       for (int i = 19; i >= 0; i--) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
       return fa[x][0];
   }
   ```

【最优关键思路】  
通过两次DFS，第一次优先向下搜索，第二次优先向右搜索，确保两条路径不相交，从而判断是否存在必经点。这种方法简单高效，且代码实现较为简洁。

【可拓展之处】  
类似的问题可以通过DFS或BFS来判断路径的必经点，或者通过支配树等图论算法来解决。这类问题在网格图中较为常见，可以通过类似的思路进行扩展。

【推荐题目】  
1. [P4001 狼抓兔子](https://www.luogu.org/problem/P4001)  
2. [P2764 最小路径覆盖问题](https://www.luogu.org/problem/P2764)  
3. [P2774 方格取数问题](https://www.luogu.org/problem/P2774)  

【个人心得】  
在调试过程中，发现DFS的搜索顺序对结果影响较大，优先向下或向右搜索可以确保两条路径不相交。此外，支配树的思路虽然新颖，但实现较为复杂，适合对图论有一定基础的选手。

---
处理用时：42.01秒
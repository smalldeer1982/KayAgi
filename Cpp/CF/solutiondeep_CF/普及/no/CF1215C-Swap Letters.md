# 题目信息

# Swap Letters

## 题目描述

``Monocarp``有两个长度相等的，里面只有字母``a``和``b``的字符串$s,t$。

``Monocarp``想要使这两个字符串相等。他可以执行以下操作任意次：指定两个下标$pos1,pos2$，交换$s_{pos1}$和$t_{pos2}$。

你需要确定``Monocarp``使这两个串变得相等所需要的最小操作次数，并且输出任意一个这样的步数最少的操作序列。或者说这两个串不可能变得相等。

## 说明/提示

在第一个样例中，你可以交换$s$的第三个字母，在交换$t$的第三个字母。于是$s$变为``abbb``，$t$变为``aaab``。再交换$s$的第三个字母和$t$的第二个字母即可达成目标，使得$s,t$都变成``abab``。

第二个样例中，显然不论怎么交换$s,t$都不可能相等。

## 样例 #1

### 输入

```
4
abab
aabb
```

### 输出

```
2
3 3
3 2
```

## 样例 #2

### 输入

```
1
a
b
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
8
babbaabb
abababaa
```

### 输出

```
3
2 6
1 3
7 8
```

# AI分析结果

【题目内容】
# 交换字母

## 题目描述

``Monocarp``有两个长度相等的，里面只有字母``a``和``b``的字符串$s,t$。

``Monocarp``想要使这两个字符串相等。他可以执行以下操作任意次：指定两个下标$pos1,pos2$，交换$s_{pos1}$和$t_{pos2}$。

你需要确定``Monocarp``使这两个串变得相等所需要的最小操作次数，并且输出任意一个这样的步数最少的操作序列。或者说这两个串不可能变得相等。

## 说明/提示

在第一个样例中，你可以交换$s$的第三个字母，在交换$t$的第三个字母。于是$s$变为``abbb``，$t$变为``aaab``。再交换$s$的第三个字母和$t$的第二个字母即可达成目标，使得$s,t$都变成``abab``。

第二个样例中，显然不论怎么交换$s,t$都不可能相等。

## 样例 #1

### 输入

```
4
abab
aabb
```

### 输出

```
2
3 3
3 2
```

## 样例 #2

### 输入

```
1
a
b
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
8
babbaabb
abababaa
```

### 输出

```
3
2 6
1 3
7 8
```

【算法分类】
贪心

【题解分析与结论】
该问题的核心在于通过交换操作使得两个字符串相等，且要求操作次数最少。通过分析，可以发现该问题可以通过贪心策略来解决。具体来说，可以通过统计两个字符串中字符的差异，并根据差异的类型进行分类处理，最终通过交换操作使得两个字符串相等。

【评分较高的题解】
1. **作者：Binary_Lee (赞：2)**
   - **星级：4星**
   - **关键亮点：**
     - 通过统计字符串中字符的差异，将问题转化为成对交换的问题，思路清晰。
     - 处理了奇数情况下的特殊情况，保证了算法的完备性。
     - 代码简洁，逻辑清晰，易于理解。
   - **核心代码：**
     ```cpp
     for(int i=0;i<n;i++){
         if(s1[i]=='a'&&s2[i]=='b') ans1[++cnt1]=i+1;
         if(s2[i]=='a'&&s1[i]=='b') ans2[++cnt2]=i+1; 
     }
     if(cnt1%2==0){
         printf("%d\n",cnt1/2+cnt2/2);
         for(int i=1;i<=cnt1;i+=2){
             printf("%d %d\n",ans1[i],ans1[i+1]);
         }
         for(int i=1;i<=cnt2;i+=2){
             printf("%d %d\n",ans2[i],ans2[i+1]);
         }
     }
     ```

2. **作者：fls233666 (赞：2)**
   - **星级：4星**
   - **关键亮点：**
     - 通过分类讨论，将问题分为三种情况，分别处理，思路清晰。
     - 通过贪心策略，尽可能使用一步交换操作，减少了操作次数。
     - 代码实现简洁，逻辑清晰。
   - **核心代码：**
     ```cpp
     while(sg[0].size()>=2){
         anss.push_back(make_pair(sg[0][sg[0].size()-1],sg[0][sg[0].size()-2]));
         sg[0].pop_back();
         sg[0].pop_back();
     }
     ```

3. **作者：天南月 (赞：0)**
   - **星级：4星**
   - **关键亮点：**
     - 通过记录两种不同情况的位置，并通过贪心策略进行匹配，思路清晰。
     - 处理了奇数情况下的特殊情况，保证了算法的完备性。
     - 代码简洁，逻辑清晰，易于理解。
   - **核心代码：**
     ```cpp
     if(s[i]=='a'&&t[i]=='b')stack1[++r1]=i;
     else stack2[++r2]=i;
     ```

【最优关键思路或技巧】
- **贪心策略**：通过成对交换字符，尽可能减少操作次数。
- **分类处理**：将字符差异分为不同类型，分别处理，保证算法的完备性。
- **特殊情况处理**：处理奇数情况下的特殊情况，保证算法的正确性。

【可拓展之处】
- 类似的问题可以通过贪心策略和分类讨论来解决，例如字符串匹配、字符交换等问题。

【推荐题目】
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)

---
处理用时：33.61秒
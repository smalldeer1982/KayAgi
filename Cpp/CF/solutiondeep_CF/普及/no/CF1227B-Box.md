# 题目信息

# Box

## 题目描述

排列 $ p $ 是一个 $ p=[p_1, p_2, \dots, p_n] $ 的广泛数列,包括 $ n $ 个各不相同（唯一）的从1到n的正整数。比如，这些数列是排列：$ [3, 4, 1, 2] $ , $ [1] $ , $ [1, 2] $。这些不是排列：$ [0] $ , $ [1, 2, 1] $ , $ [2, 3] $ , $ [0, 1, 2] $ 。

重要的钥匙在一个需要你打开的锁上的盒子里。你需要输入密码来打开它。密码是一个长度为 $n$ 的序列。

你不知道这个排列，你只知道这个排列前缀的最大值。定义如下：

- $ q_1=p_1 $ ,
- $ q_2=\max(p_1, p_2) $ ,
- $ q_3=\max(p_1, p_2,p_3) $ ,
- ...
- $ q_n=\max(p_1, p_2,\dots,p_n) $ .

你想要把所有可能的排列都构造出来（即任何这样的排列，使得计算出的 $q$ 与给出的数组相同）。

## 说明/提示

样例的第一组数据中， $ [1,3,4,5,2] $ 是唯一一组可能的答案:

- $ q_{1} = p_{1} = 1 $ ;
- $ q_{2} = \max(p_{1}, p_{2}) = 3 $ ;
- $ q_{3} = \max(p_{1}, p_{2}, p_{3}) = 4 $ ;
- $ q_{4} = \max(p_{1}, p_{2}, p_{3}, p_{4}) = 5 $ ;
- $ q_{5} = \max(p_{1}, p_{2}, p_{3}, p_{4}, p_{5}) = 5 $ .

可以证明样例的第二组数据没有答案。

翻译来自 @[carreye](https://www.luogu.com.cn/user/188360)

## 样例 #1

### 输入

```
4
5
1 3 4 5 5
4
1 1 3 4
2
2 2
1
1
```

### 输出

```
1 3 4 5 2 
-1
2 1 
1 
```

# AI分析结果

### 题目内容重写
**题目描述**

排列 $ p $ 是一个包含 $ n $ 个各不相同（唯一）的从1到n的正整数的序列，例如 $ [3, 4, 1, 2] $, $ [1] $, $ [1, 2] $。这些不是排列：$ [0] $, $ [1, 2, 1] $, $ [2, 3] $, $ [0, 1, 2] $。

重要的钥匙在一个需要你打开的锁上的盒子里。你需要输入密码来打开它。密码是一个长度为 $n$ 的序列。

你不知道这个排列，你只知道这个排列前缀的最大值。定义如下：

- $ q_1=p_1 $ ,
- $ q_2=\max(p_1, p_2) $ ,
- $ q_3=\max(p_1, p_2,p_3) $ ,
- ...
- $ q_n=\max(p_1, p_2,\dots,p_n) $ .

你想要把所有可能的排列都构造出来（即任何这样的排列，使得计算出的 $q$ 与给出的数组相同）。

**说明/提示**

样例的第一组数据中，$ [1,3,4,5,2] $ 是唯一一组可能的答案:

- $ q_{1} = p_{1} = 1 $ ;
- $ q_{2} = \max(p_{1}, p_{2}) = 3 $ ;
- $ q_{3} = \max(p_{1}, p_{2}, p_{3}) = 4 $ ;
- $ q_{4} = \max(p_{1}, p_{2}, p_{3}, p_{4}) = 5 $ ;
- $ q_{5} = \max(p_{1}, p_{2}, p_{3}, p_{4}, p_{5}) = 5 $ .

可以证明样例的第二组数据没有答案。

### 算法分类
**构造**

### 题解分析与结论
题目要求根据给定的前缀最大值数组 $q$ 构造出符合条件的排列 $p$。核心思路是通过分析 $q$ 数组的特性，逐步构造出 $p$ 数组。主要难点在于如何处理 $q$ 数组中的重复值和如何保证构造的 $p$ 数组满足唯一性。

### 所选高星题解
#### 1. 作者：naroto2022 (赞：2)  
**星级：4**  
**关键亮点：**  
- 通过交换操作构造排列，思路清晰。
- 详细解释了无解情况的判断条件。
- 代码简洁，易于理解。

**核心代码：**
```cpp
for(int i=1; i<=n; i++) p[i]=i;
for(int i=1; i<=n; i++){
    scanf("%d",&q[i]);
    if(q[i]<i) ok=1;
    else swap(p[i],p[q[i]]);
}
```
**实现思想：**  
初始化 $p$ 数组为 $1$ 到 $n$，然后根据 $q$ 数组的值进行交换操作，确保 $p$ 数组的前缀最大值与 $q$ 数组一致。

#### 2. 作者：DaiRuiChen007 (赞：0)  
**星级：4**  
**关键亮点：**  
- 使用 `set` 数据结构维护未使用的数字，提高了效率。
- 详细解释了每一步的操作逻辑。
- 代码结构清晰，易于扩展。

**核心代码：**
```cpp
set <int> s;
vector <int> res; 
for(int i=1;i<=n;++i) s.insert(i);
for(int i=1;i<=n;++i) {
    if(a[i]==a[i-1]) {
        int v=*s.begin();
        if(v>a[i]) return (void)(puts("-1"));
        res.push_back(v);
        s.erase(s.begin());
    } else {
        auto t=s.lower_bound(a[i]);
        if(t==s.end()||*t!=a[i]) return (void)(puts("-1"));
        s.erase(t);res.push_back(a[i]);
    }
}
```
**实现思想：**  
使用 `set` 来维护未使用的数字，根据 $q$ 数组的值逐步构造 $p$ 数组，确保每个位置的值满足前缀最大值的条件。

#### 3. 作者：wind_whisper (赞：0)  
**星级：4**  
**关键亮点：**  
- 通过贪心策略构造排列，思路简洁。
- 详细解释了无解情况的判断条件。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
int pl=1,flag=0;
for(int i=1;i<=n;i++){
    if(ans[i]) continue;
    while(vis[pl]) ++pl;
    ans[i]=pl;vis[pl]=1;
    if(ans[i]>mx[i]){
        flag=1;printf("-1\n");break;
    }
}
```
**实现思想：**  
通过贪心策略，从前往后逐步构造 $p$ 数组，确保每个位置的值满足前缀最大值的条件，同时判断无解情况。

### 最优关键思路或技巧
- **交换操作**：通过交换操作构造排列，确保前缀最大值与给定数组一致。
- **数据结构优化**：使用 `set` 数据结构维护未使用的数字，提高效率。
- **贪心策略**：通过贪心策略逐步构造排列，确保每个位置的值满足条件。

### 可拓展之处
- **类似构造问题**：可以扩展到其他需要根据特定条件构造排列的问题，如根据特定规则构造序列。
- **数据结构应用**：在其他需要维护未使用数字的场景中，可以使用类似的数据结构优化。

### 推荐题目
1. [P1045 排列](https://www.luogu.com.cn/problem/P1045)
2. [P1059 排列计数](https://www.luogu.com.cn/problem/P1059)
3. [P1060 排列问题](https://www.luogu.com.cn/problem/P1060)

---
处理用时：41.54秒
# 题目信息

# Restricted RPS

## 题目描述

$Alice$和$Bob$要玩石头剪刀布的游戏$n$次（$n$是正整数），$Alice$已经知道$Bob$每局要出什么。但是她只能出$a$次石头，$b$次剪刀和$c$次布（$a,b,c$为非负整数，且保证$a+b+c=n$）



$Alice$赢的条件是她**击败了**$Bob$至少 $\left\lceil\dfrac{n}{2}\right\rceil$次（向上取整），否则她输了



石头剪刀布的规则



- 石头赢剪刀

- 布赢石头

- 剪刀赢布



你的任务是，对于已给出的$Bob$的出手序列，和$a,b,c$，判断$Alice$是否能赢。如果能，找到$Alice$的出手序列



如果存在多组解，输出任意一个即可

## 样例 #1

### 输入

```
2
3
1 1 1
RPS
3
3 0 0
RPS
```

### 输出

```
YES
PSR
NO
```

# AI分析结果

### 题目内容重写
**限制版石头剪刀布**

#### 题目描述

Alice和Bob要玩石头剪刀布的游戏$n$次（$n$是正整数），Alice已经知道Bob每局要出什么。但是她只能出$a$次石头，$b$次剪刀和$c$次布（$a,b,c$为非负整数，且保证$a+b+c=n$）。

Alice赢的条件是她**击败了**Bob至少 $\left\lceil\dfrac{n}{2}\right\rceil$次（向上取整），否则她输了。

石头剪刀布的规则：
- 石头赢剪刀
- 布赢石头
- 剪刀赢布

你的任务是，对于已给出的Bob的出手序列，和$a,b,c$，判断Alice是否能赢。如果能，找到Alice的出手序列。如果存在多组解，输出任意一个即可。

#### 样例 #1

##### 输入

```
2
3
1 1 1
RPS
3
3 0 0
RPS
```

##### 输出

```
YES
PSR
NO
```

### 算法分类
贪心

### 题解分析与结论

所有题解均采用了贪心策略，核心思路是优先让Alice在每一轮中尽可能击败Bob，只有在无法击败时才使用剩余的次数。这种策略确保了Alice能够最大化击败Bob的次数，从而满足题目要求。

### 所选高星题解

#### 题解1：作者：andyli (赞：2)
**星级：4**
**关键亮点：**
- 使用贪心策略，优先击败Bob，确保Alice的胜利条件。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
for (int i = 0; i < n; i++) {
    if (str[i] == 'R')
        if (b)
            cnt++, b--, ans[i] = 'P';
    if (str[i] == 'P')
        if (c)
            cnt++, c--, ans[i] = 'S';
    if (str[i] == 'S')
        if (a)
            cnt++, a--, ans[i] = 'R';
}
```
**实现思想：**
遍历Bob的出手序列，尽可能让Alice击败Bob，并记录击败次数。如果击败次数满足条件，则输出YES和Alice的出手序列，否则输出NO。

#### 题解2：作者：lzy120406 (赞：1)
**星级：4**
**关键亮点：**
- 同样采用贪心策略，优先击败Bob。
- 代码结构清晰，使用了字符串处理，便于输出。

**核心代码：**
```cpp
for (int i = 0; i < n; ++i) {
    if (s[i] == 'R' && b > 0) {
        t[i] = 'P';
        b--;
        win++;
    } else if (s[i] == 'P' && c > 0) {
        t[i] = 'S';
        c--;
        win++;
    } else if (s[i] == 'S' && a > 0) {
        t[i] = 'R';
        a--;
        win++;
    }
}
```
**实现思想：**
遍历Bob的出手序列，尽可能让Alice击败Bob，并记录击败次数。如果击败次数满足条件，则输出YES和Alice的出手序列，否则输出NO。

#### 题解3：作者：RioFutaba (赞：1)
**星级：4**
**关键亮点：**
- 贪心策略，优先击败Bob。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i=0;i<n;i++){
    if(st[i]=='S'){
        if(a>0) ans[i]='R',a--,cnt++;
    }else if(st[i]=='R'){
        if(b>0) ans[i]='P',b--,cnt++;
    }else{
        if(c>0) ans[i]='S',c--,cnt++;
    }
}
```
**实现思想：**
遍历Bob的出手序列，尽可能让Alice击败Bob，并记录击败次数。如果击败次数满足条件，则输出YES和Alice的出手序列，否则输出NO。

### 最优关键思路或技巧
- **贪心策略**：优先让Alice在每一轮中尽可能击败Bob，确保击败次数最大化。
- **代码实现**：通过遍历Bob的出手序列，根据Alice的剩余次数决定出手，逻辑清晰且易于实现。

### 可拓展之处
- 类似问题可以扩展到其他博弈类题目，如有限制条件的博弈策略设计。
- 可以进一步优化代码，减少冗余操作，提高效率。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录
- **调试经历**：在实现过程中，需要注意Alice的剩余次数，避免出现负数。
- **踩坑教训**：在输出Alice的出手序列时，需要确保所有位置都被填充，避免遗漏。

---
处理用时：35.65秒
# 题目信息

# Constanze's Machine

## 题目描述

$Constanze$是全村最聪明的女孩，但是她视力不好

一天，她发明了一台神奇的机器。当你念字母时，机器会把它们写刻在一张纸上。举个例子，如果你按这个顺序念“$c$”、“$o$”、“$d$”和“$e$”，那么机器就会在纸上写“$code$”。多亏了这台机器，她终于不用眼镜就能写信了

但是，她的朋友$Akko$决定对她开个玩笑，$Akko$改了机器，如果你念$w$，它会写$uu$而不是$w$，如果你念$m$，它会写$nn$而不是$m$。由于$Constanze$视力不好，她不知道$Akko$做了什么

其他字母和以前一样：如果你念的是“$w$”,“$m$”以外的字母，机器就会把它原封不动地写在纸上

第二天，我在邮箱里收到了一封信。但我看不懂，我想这应该是$Constanze$用她的机器写的。但既然我知道$Akko$做了什么，我就可以把$Constanze$的机器写的话变成我原本可能得到的信息。

但是因为我很菜，所以我要向你求助。你需要告诉我告诉我所有原本可能得到的信息有多少种。

由于答案可能很大，请输出答案对$10^9+7$取模后的结果。

如果没有一个字符串经过$Constanze$的机器后能得到我的结果，请输出$0$

## 说明/提示

对于第一个样例，可能的字符串如下：“$ouokarin$”、“$ouokarim$”、“$owokarim$”和“$owokarin$”

第二个样例只有一个：“$banana$”

对于第三个样例，可能的字符串如下：“$nm$”、“$mn$”和“$nnn$”

在最后一个样例中，没有任何字符串可以被机器转换成“$amanda$”，因为机器不会写下“$m$”。

## 样例 #1

### 输入

```
ouuokarinn
```

### 输出

```
4
```

## 样例 #2

### 输入

```
banana
```

### 输出

```
1
```

## 样例 #3

### 输入

```
nnn
```

### 输出

```
3
```

## 样例 #4

### 输入

```
amanda
```

### 输出

```
0
```

# AI分析结果

### 题目内容重写
$Constanze$是全村最聪明的女孩，但是她视力不好。一天，她发明了一台神奇的机器。当你念字母时，机器会把它们写刻在一张纸上。举个例子，如果你按这个顺序念“$c$”、“$o$”、“$d$”和“$e$”，那么机器就会在纸上写“$code$”。多亏了这台机器，她终于不用眼镜就能写信了。但是，她的朋友$Akko$决定对她开个玩笑，$Akko$改了机器，如果你念$w$，它会写$uu$而不是$w$，如果你念$m$，它会写$nn$而不是$m$。由于$Constanze$视力不好，她不知道$Akko$做了什么。其他字母和以前一样：如果你念的是“$w$”,“$m$”以外的字母，机器就会把它原封不动地写在纸上。第二天，我在邮箱里收到了一封信。但我看不懂，我想这应该是$Constanze$用她的机器写的。但既然我知道$Akko$做了什么，我就可以把$Constanze$的机器写的话变成我原本可能得到的信息。但是因为我很菜，所以我要向你求助。你需要告诉我告诉我所有原本可能得到的信息有多少种。由于答案可能很大，请输出答案对$10^9+7$取模后的结果。如果没有一个字符串经过$Constanze$的机器后能得到我的结果，请输出$0$。

### 算法分类
动态规划

### 题解分析与结论
本题的核心是通过动态规划或递推的方式，计算字符串中连续出现的`u`或`n`的可能组合数。由于`u`和`n`可以分别被替换为`w`和`m`，因此连续的`u`或`n`会形成斐波那契数列的递推关系。最终的结果是这些连续段的组合数的乘积。

### 精选题解
#### 题解1：作者：Ludo (赞：5)
- **星级**：5星
- **关键亮点**：通过斐波那契数列递推计算连续`u`或`n`的组合数，思路清晰，代码简洁。
- **代码核心**：
  ```cpp
  for (int i=3;i<=100002;i++) {
      fib[i]=(fib[i-1]+fib[i-2])%modulo;
  }
  ```
  **核心思想**：预处理斐波那契数列，用于计算连续`u`或`n`的组合数。

#### 题解2：作者：andyli (赞：4)
- **星级**：4星
- **关键亮点**：使用动态规划定义状态`dp(i)`，通过记忆化搜索优化计算过程。
- **代码核心**：
  ```cpp
  int dp(int i) {
      if (i < 1) return 0;
      if (i == 1) return 1;
      if (d[i]) return d[i];
      if (str[i] == 'n' && str[i - 1] == 'n' || str[i] == 'u' && str[i - 1] == 'u')
          return d[i] = i == 2 ? 2 : (dp(i - 1) + dp(i - 2)) % MOD;
      return d[i] = dp(i - 1);
  }
  ```
  **核心思想**：通过递归和记忆化搜索计算每个位置的组合数。

#### 题解3：作者：ttq012 (赞：1)
- **星级**：4星
- **关键亮点**：通过预处理斐波那契数列，并在遍历字符串时计算连续`u`或`n`的组合数。
- **代码核心**：
  ```cpp
  for (int i = 3; i <= l; i++)
      f[i] = (f[i - 1] + f[i - 2]) % mod;
  ```
  **核心思想**：预处理斐波那契数列，并在遍历字符串时计算连续`u`或`n`的组合数。

### 最优关键思路
1. **斐波那契数列递推**：连续的`u`或`n`的组合数符合斐波那契数列的递推关系，可以通过预处理斐波那契数列来快速计算。
2. **动态规划**：通过定义状态`dp(i)`，并使用记忆化搜索优化计算过程，避免重复计算。
3. **乘法原理**：最终的结果是各个连续段的组合数的乘积，使用乘法原理进行计算。

### 可拓展之处
类似的问题可以通过动态规划或递推的方式解决，特别是涉及到字符串的组合或排列问题时，斐波那契数列的递推关系经常出现。

### 推荐题目
1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)

### 个人心得
- **调试经历**：在处理连续`u`或`n`时，需要注意边界条件的处理，避免数组越界或重复计算。
- **踩坑教训**：在预处理斐波那契数列时，要确保数组大小足够，避免溢出或访问越界。
- **顿悟感想**：通过斐波那契数列的递推关系，可以快速解决类似的组合问题，减少计算复杂度。

---
处理用时：37.54秒
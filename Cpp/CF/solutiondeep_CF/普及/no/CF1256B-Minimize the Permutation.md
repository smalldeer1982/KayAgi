# 题目信息

# Minimize the Permutation

## 题目描述

给你一个长度为 $n$ 排列，你需要经过至多 $n-1$ 次的交换，使得排列的字典序尽量小。

这里要注意：交换仅能交换相邻的两数，且每个位置只能交换一次。

位置的定义如下：

交换 $a_1,a_2$ 两数称为在位置 $1$ 上的交换，交换 $a_2,a_3$ 两数称为在位置 $2$ 上的交换，......，交换 $a_{n-1},a_{n}$ 两数称为在位置 $n-1$ 上的交换。

## 样例 #1

### 输入

```
4
5
5 4 1 3 2
4
1 2 4 3
1
1
4
4 3 2 1
```

### 输出

```
1 5 2 4 3 
1 2 3 4 
1 
1 4 3 2 
```

# AI分析结果

### 题目内容重写
# 最小化排列

## 题目描述

给你一个长度为 $n$ 的排列，你需要经过至多 $n-1$ 次的交换，使得排列的字典序尽量小。

这里要注意：交换仅能交换相邻的两数，且每个位置只能交换一次。

位置的定义如下：

交换 $a_1,a_2$ 两数称为在位置 $1$ 上的交换，交换 $a_2,a_3$ 两数称为在位置 $2$ 上的交换，......，交换 $a_{n-1},a_{n}$ 两数称为在位置 $n-1$ 上的交换。

## 样例 #1

### 输入

```
4
5
5 4 1 3 2
4
1 2 4 3
1
1
4
4 3 2 1
```

### 输出

```
1 5 2 4 3 
1 2 3 4 
1 
1 4 3 2 
```

### 算法分类
贪心

### 题解综合分析
本题的核心目标是通过至多 $n-1$ 次相邻交换，使得排列的字典序最小。由于每个位置只能交换一次，因此需要合理安排交换顺序，确保最小的数尽可能靠前。各题解大多采用贪心策略，通过逐步将最小的数移动到最前面来实现目标。

### 精选题解
#### 题解1：Inkyo (赞：8)
- **星级**：5星
- **关键亮点**：通过记录每个数的位置（rank），优化了查找最小数的复杂度，从 $O(n)$ 降到 $O(1)$，整体复杂度为 $O(qn)$，适合大数据量。
- **核心代码**：
  ```cpp
  while(now != n + 1) {
      int rank = rk[now];
      if(a[rank] < a[rank - 1] && !used[rank - 1]) {
          rk[a[rank]] --; rk[a[rank - 1]] ++;
          swap(a[rank], a[rank - 1]);
          used[rank - 1] = true;
      }
      else now ++;
  }
  ```
- **个人心得**：通过记录每个数的位置，避免了每次查找最小数的重复计算，显著提升了效率。

#### 题解2：FLAMEs_ (赞：1)
- **星级**：4星
- **关键亮点**：使用 $pos$ 数组记录每个数的位置，并在交换时更新 $pos$，确保每次交换都能快速定位目标数。
- **核心代码**：
  ```cpp
  while(now != n + 1) {
      int rk = pos[now];
      if(a[rk] < a[rk - 1] && !used[rk - 1]) {
          pos[a[rk]]--; pos[a[rk - 1]]++;
          swap(a[rk], a[rk - 1]);
          used[rk - 1] = 1;
      }
      else now++;
  }
  ```
- **个人心得**：通过 $pos$ 数组的维护，确保了每次交换的合法性，避免了无效交换。

#### 题解3：lsr1409111459 (赞：1)
- **星级**：4星
- **关键亮点**：采用类似冒泡排序的思路，从后向前遍历，确保每次交换都能将较小的数向前移动，最终达到字典序最小。
- **核心代码**：
  ```cpp
  while(flag) {
      flag = false;
      for(int i = n - 1; i >= 1; i--) {
          if(!f[i] && a[i] > a[i + 1]) {
              f[i] = true;
              swap(a[i], a[i + 1]);
              flag = true;
          }
      }
  }
  ```
- **个人心得**：通过从后向前的遍历方式，确保了每次交换都能有效减少字典序，最终达到最优解。

### 最优关键思路
1. **贪心策略**：每次将最小的数尽可能向前移动，确保字典序最小。
2. **位置记录**：通过记录每个数的位置，优化查找和交换的效率。
3. **交换限制**：每个位置只能交换一次，因此需要合理安排交换顺序，避免无效交换。

### 可拓展之处
- **类似题目**：可以考虑扩展到每个位置可以交换多次的情况，或者交换不限于相邻元素的情况。
- **算法优化**：可以进一步优化查找最小数的过程，例如使用优先队列等数据结构。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)

---
处理用时：32.98秒
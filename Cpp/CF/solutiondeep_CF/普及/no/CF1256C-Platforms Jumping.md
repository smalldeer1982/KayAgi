# 题目信息

# Platforms Jumping

## 题目描述

有一条宽度为$n$的河。河的左岸编号为$0$，右岸编号为$n + 1$。河流上还有$m$个木制平台，第$i$个平台的长度为$ci$（所以说第i个平台占据河流的$ci$个连续位置）。保证平台长度的总和不超过n。

你正站在$0$（左岸），并且想到达右岸即$n + 1$的位置。如果您站在位置x，则可以跳到$[x + 1; x + d]$范围内的任何位置。但是， 你只能跳到木质平台上（ _即不能下水_ ）。例如，如果$d = 1$，则只能跳到下一个位置（如果这个位置上有木制平台）。您可以假设单元格$0$和$n + 1$属于木制平台。

您可以将任意平台向左或向右移动任意次数（也可以不移动），只要它们彼此不重叠（但两个平台可以挨在一起）。也就是说你不能更改平台的相对顺序。

**请注意，你应该先移动平台再跳跃（一旦你出发后，你就不能再移动平台了）。**

例如，如果$n = 7$，$m = 3$，$d = 2$和$c = [1,2,1]$，这就是从左岸跳到右岸的方法之一：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1256C/df0d8d2f8a9c6cd940b3eabc79499fe8d2091270.png)

## 样例 #1

### 输入

```
7 3 2
1 2 1
```

### 输出

```
YES
0 1 0 2 2 0 3 
```

## 样例 #2

### 输入

```
10 1 11
1
```

### 输出

```
YES
0 0 0 0 0 0 0 0 0 1 
```

## 样例 #3

### 输入

```
10 1 5
2
```

### 输出

```
YES
0 0 0 0 1 1 0 0 0 0 
```

# AI分析结果

### 题目内容
有一条宽度为$n$的河。河的左岸编号为$0$，右岸编号为$n + 1$。河流上还有$m$个木制平台，第$i$个平台的长度为$ci$（所以说第i个平台占据河流的$ci$个连续位置）。保证平台长度的总和不超过n。

你正站在$0$（左岸），并且想到达右岸即$n + 1$的位置。如果您站在位置x，则可以跳到$[x + 1; x + d]$范围内的任何位置。但是， 你只能跳到木质平台上（ _即不能下水_ ）。例如，如果$d = 1$，则只能跳到下一个位置（如果这个位置上有木制平台）。您可以假设单元格$0$和$n + 1$属于木制平台。

您可以将任意平台向左或向右移动任意次数（也可以不移动），只要它们彼此不重叠（但两个平台可以挨在一起）。也就是说你不能更改平台的相对顺序。

**请注意，你应该先移动平台再跳跃（一旦你出发后，你就不能再移动平台了）。**

### 算法分类
贪心

### 题解分析与结论
本题的核心是通过贪心策略来放置平台，使得跳跃路径能够覆盖整个河流。各题解的主要思路都是先判断是否有解，然后通过贪心策略构造解。判断是否有解的关键是计算平台总长度加上最大跳跃距离是否能够覆盖河流长度。构造解时，通常采用先尽可能跳远，然后再放置平台的策略。

### 精选题解
#### 1. 作者：jianhe (赞：3)
- **星级**: 4
- **关键亮点**: 代码简洁，思路清晰，直接通过贪心策略判断是否有解，并构造解。
- **核心代码**:
```cpp
if(sum+(m+1)*d<n){
    cout<<"NO";
    return 0;
}else cout<<"YES\n";

t=n-sum;i=0;
while(i<=n){
    for(int j=1;j<=d&&t;j++){
        cout<<"0 ";
        i++,t--;
    }
    if((++i)>n||p>m) return 0;
    for(int j=i;j<c[p]+i;j++) cout<<p<<" ";
    p++;
}
```
- **实现思想**: 先判断是否有解，然后通过贪心策略尽可能跳远，再放置平台。

#### 2. 作者：wlj_55 (赞：2)
- **星级**: 4
- **关键亮点**: 详细解释了贪心策略的实现过程，代码结构清晰。
- **核心代码**:
```cpp
if(emp<k-1){
    p+=emp+1,emp=0;
    for(int i=p;i<=p+a[now]-1;++i)
    ans[i]=now;
    p+=a[now]-1;
    now++;
}
```
- **实现思想**: 通过贪心策略，先跳最大距离，再放置平台，直到所有平台放置完毕。

#### 3. 作者：small_turtle (赞：1)
- **星级**: 4
- **关键亮点**: 代码简洁，思路清晰，直接通过贪心策略判断是否有解，并构造解。
- **核心代码**:
```cpp
if(sum+(m+1)*d<n)
{
    puts("NO");
    return 0;
}
puts("YES");
jl=n-sum;
int i=0;
while(i<=n)
{
    if(jl)
    {
        for(int j=1;j<=d;++j)
        {
            printf("0 ");
            ++i;
            --jl;
            if(!jl)
            {
                break;
            }
        }
    }
    ++i;
    if(i>n||now>m)
    {
        break;
    }
    int r=a[now]+i;
    for(int j=i;j<r;++j)
    {
        printf("%d ", now);
    }
    ++now;
}
```
- **实现思想**: 先判断是否有解，然后通过贪心策略尽可能跳远，再放置平台。

### 最优关键思路或技巧
1. **贪心策略**: 先尽可能跳远，然后再放置平台，确保跳跃路径能够覆盖整个河流。
2. **判断有解**: 计算平台总长度加上最大跳跃距离是否能够覆盖河流长度。

### 可拓展之处
类似的问题可以通过贪心策略来解决，尤其是在需要覆盖一定范围或路径的问题中。例如，覆盖问题、路径规划问题等。

### 推荐题目
1. [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：37.42秒
# 题目信息

# PIN Codes

## 题目描述

### 题意简述



众所周知，PIN 码是由 $4$ 个数码组成的字符串。



现在有 $n$ 个 PIN 码。你可以**多次**修改某些 PIN 码中的一位。问至少需要修改多少次，才能使得所有的 $n$ 个 PIN 码**互不相同**。

## 样例 #1

### 输入

```
3
2
1234
0600
2
1337
1337
4
3139
3139
3139
3139
```

### 输出

```
0
1234
0600
1
1337
1237
3
3139
3138
3939
6139
```

# AI分析结果

### 题目内容重写
# PIN 码

## 题目描述

### 题意简述

众所周知，PIN 码是由 $4$ 个数码组成的字符串。

现在有 $n$ 个 PIN 码。你可以**多次**修改某些 PIN 码中的一位。问至少需要修改多少次，才能使得所有的 $n$ 个 PIN 码**互不相同**。

## 样例 #1

### 输入

```
3
2
1234
0600
2
1337
1337
4
3139
3139
3139
3139
```

### 输出

```
0
1234
0600
1
1337
1237
3
3139
3138
3939
6139
```

### 算法分类
枚举

### 题解分析与结论

本题的核心逻辑是通过枚举修改 PIN 码的某一位，使得所有 PIN 码互不相同。由于 $n \leq 10$，且 PIN 码只有 4 位，因此可以通过暴力枚举的方式解决。各题解的思路大致相同，主要区别在于实现细节和优化程度。

### 所选高分题解

#### 题解1：作者：rrrrr (5星)
**关键亮点**：
- 使用 `map` 记录 PIN 码是否出现过，简化了重复检测。
- 通过修改 PIN 码的个位来避免重复，保证了修改次数最少。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    if(q[a[i]]==1)
    {
        if(p[a[i]]==1)
        {
            pit[++tl]=a[i];
            p[a[i]]-=1;
            continue;
        }
        ans++;
        for(int j=0;j<=9;j++)
        {
            if(q[a[i]/10*10+j]==0)
            { 
                q[a[i]/10*10+j]++,pit[++tl]=a[i]/10*10+j;
                break;
            }
        } 
    } 
    else
    q[a[i]]++,pit[++tl]=a[i];
}
```

#### 题解2：作者：Rainbow_qwq (4星)
**关键亮点**：
- 使用 `vector` 存储重复 PIN 码的位置，方便修改。
- 通过 `change` 函数实现 PIN 码某一位的修改，代码复用性高。
- 输出部分使用 `setw` 和 `setfill` 保证了输出格式。

**核心代码**：
```cpp
inline int change(int x,int p,int num){
    int p10=pow(10,p);
    int th=(x/p10)%10;
    x-=th*p10;
    x+=num*p10;
    return x;
}
```

#### 题解3：作者：Goodrage (4星)
**关键亮点**：
- 使用 `map` 记录 PIN 码的出现次数，简化了重复检测。
- 通过修改 PIN 码的个位来避免重复，保证了修改次数最少。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    if(mrx[a[i]]==1)
        continue;
    else
    {
        ans++;
        for(int j=0;j<=9;j++)
        {
            int tmp=a[i]/10;
            tmp=tmp*10;
            tmp+=j;
            if(mrx[tmp]==0)
            {
                mrx[a[i]]--;
                a[i]=tmp;
                mrx[a[i]]++;
                break;
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **使用 `map` 记录 PIN 码的出现次数**：简化了重复检测的逻辑。
2. **修改 PIN 码的个位**：通过修改个位来避免重复，保证了修改次数最少。
3. **暴力枚举**：由于 $n \leq 10$，暴力枚举的复杂度是可接受的。

### 可拓展之处
类似的问题可以扩展到更长的字符串或更大的 $n$，此时可能需要更高效的算法，如贪心或动态规划。

### 推荐题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

---
处理用时：32.24秒
# 题目信息

# Beautiful Numbers

## 题目描述

### 题意简述

你得到了正整数 $1$ 到 $n$ 的一个排列 $p=[p_1,p_2,···,p_n]$。

我们称数字 $m(1 \leq m \leq n)$ 是美丽的，当且仅当存在两个正整数 $l,r(1\leq l\leq r \leq n)$， 使得 $p_l,p_{l+1},\cdots,p_r$ 是正整数 $1$ 到 $m$ 的一个排列。

对于所有的 $m$，您需要求出其是否是美丽的。

## 样例 #1

### 输入

```
3
6
4 5 1 3 2 6
5
5 3 1 2 4
4
1 4 3 2
```

### 输出

```
101011
11111
1001
```

# AI分析结果

### 题目内容重写
# 美丽的数字

## 题目描述

### 题意简述

你得到了正整数 $1$ 到 $n$ 的一个排列 $p=[p_1,p_2,···,p_n]$。

我们称数字 $m(1 \leq m \leq n)$ 是美丽的，当且仅当存在两个正整数 $l,r(1\leq l\leq r \leq n)$，使得 $p_l,p_{l+1},\cdots,p_r$ 是正整数 $1$ 到 $m$ 的一个排列。

对于所有的 $m$，您需要求出其是否是美丽的。

## 样例 #1

### 输入

```
3
6
4 5 1 3 2 6
5
5 3 1 2 4
4
1 4 3 2
```

### 输出

```
101011
11111
1001
```

### 算法分类
双指针

### 题解分析与结论
本题的核心在于判断对于每个 $m$，是否存在一个连续子区间包含 $1$ 到 $m$ 的所有数字。多个题解都采用了双指针的思路，通过维护当前区间的左右边界来判断是否满足条件。

### 精选题解

#### 题解作者：_maojun_ (4星)
**关键亮点**：
- 使用双指针直接更新区间的左右边界，避免了逐个移动指针的低效操作。
- 通过判断区间长度是否等于 $m$ 来确定 $m$ 是否美丽，思路清晰且代码简洁。

**核心代码**：
```cpp
for(int l=pos[1],r=pos[1],i=2;i<=n;i++){
    l=min(l,pos[i]),r=max(r,pos[i]);	// 更新双指针 
    if(r-l+1==i)ans[i]=true;
}
```

#### 题解作者：TPJX (4星)
**关键亮点**：
- 通过记录每个数字的最左和最右出现位置，简化了区间判断的逻辑。
- 使用 `max_r` 和 `min_l` 来维护当前区间的边界，提高了代码的可读性。

**核心代码**：
```cpp
for(int m=1;m<=n;m++){
    max_r=max(max_r,r[m]);
    min_l=min(min_l,l[m]); 
    if(max_r-min_l+1==m) printf("1");
    else printf("0");
}
```

#### 题解作者：skyskyCCC (4星)
**关键亮点**：
- 通过记录每个数字的位置，利用双指针逐步扩展区间，判断区间长度是否等于 $m$。
- 代码简洁且易于理解，适合初学者学习。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    l=min(l,tp[i]);
    r=max(r,tp[i]);
    if(r-l+1==i){
        cout<<"1";
    }
    else cout<<"0";
}
```

### 最优关键思路
使用双指针维护当前区间的左右边界，通过判断区间长度是否等于 $m$ 来确定 $m$ 是否美丽。这种方法的时间复杂度为 $O(n)$，效率较高。

### 可拓展之处
类似的双指针思路可以应用于其他需要判断连续子区间是否满足特定条件的题目，例如判断子区间是否包含所有指定元素或是否满足某种单调性。

### 推荐题目
1. [P1106 子串](https://www.luogu.com.cn/problem/P1106)
2. [P1638 访问艺术馆](https://www.luogu.com.cn/problem/P1638)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：26.14秒
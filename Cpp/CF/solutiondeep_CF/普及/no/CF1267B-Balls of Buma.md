# 题目信息

# Balls of Buma

## 题目描述

巴尔夫在玩一个游戏。在这个游戏中，他将得到一串彩色的球。他需要选择一个颜色的球并在这串球中选择任意一个位置插入这个球。

当一个球被插入后，以下情况会重复发生：如果连续一串相同颜色的球**由于先前的操作而变长**，并且其长度大于或等于$3$，则这一串相同颜色的球都将被消除。

例如，一串球“AAABBBWWBB”。假如巴尔夫选择了一个颜色为‘W’的球，并将其插入到第$6$个位置（即‘B’和‘W’之间），此时颜色为‘W’的球将被消除，因为该操作使得此段变长且长度为$3$。现在，这串球为“AAABBBBB”。颜色为‘B’的球现在被消除了，因为颜色为‘B’的球段变长了，并且长度为$5$。剩下的球为“AAA”，由于没有任何操作使得颜色为‘A’的球段变长，所以无法再次进行消除。

巴尔夫想知道，如果给你任意一串球，有多少种插入的方式能使得所有的球都能被消除？

## 样例 #1

### 输入

```
BBWWBB
```

### 输出

```
3
```

## 样例 #2

### 输入

```
BWWB
```

### 输出

```
0
```

## 样例 #3

### 输入

```
BBWBB
```

### 输出

```
0
```

## 样例 #4

### 输入

```
OOOWWW
```

### 输出

```
0
```

## 样例 #5

### 输入

```
WWWOOOOOOWWW
```

### 输出

```
7
```

# AI分析结果

【题目内容】
# Balls of Buma

## 题目描述

巴尔夫在玩一个游戏。在这个游戏中，他将得到一串彩色的球。他需要选择一个颜色的球并在这串球中选择任意一个位置插入这个球。

当一个球被插入后，以下情况会重复发生：如果连续一串相同颜色的球**由于先前的操作而变长**，并且其长度大于或等于$3$，则这一串相同颜色的球都将被消除。

例如，一串球“AAABBBWWBB”。假如巴尔夫选择了一个颜色为‘W’的球，并将其插入到第$6$个位置（即‘B’和‘W’之间），此时颜色为‘W’的球将被消除，因为该操作使得此段变长且长度为$3$。现在，这串球为“AAABBBBB”。颜色为‘B’的球现在被消除了，因为颜色为‘B’的球段变长了，并且长度为$5$。剩下的球为“AAA”，由于没有任何操作使得颜色为‘A’的球段变长，所以无法再次进行消除。

巴尔夫想知道，如果给你任意一串球，有多少种插入的方式能使得所有的球都能被消除？

## 样例 #1

### 输入

```
BBWWBB
```

### 输出

```
3
```

## 样例 #2

### 输入

```
BWWB
```

### 输出

```
0
```

## 样例 #3

### 输入

```
BBWBB
```

### 输出

```
0
```

## 样例 #4

### 输入

```
OOOWWW
```

### 输出

```
0
```

## 样例 #5

### 输入

```
WWWOOOOOOWWW
```

### 输出

```
7
```

【算法分类】
字符串、模拟、队列

【题解分析与结论】
该题的核心思路是通过模拟插入和消除的过程，判断是否能够将所有球消除。所有题解都采用了从两端向中间消除的策略，使用双端队列（`deque`）来存储球，并通过逐步消除相同颜色的球来判断是否满足条件。最终，合法的插入方式数量取决于中间段的长度加1。

【所选高分题解】
1. **作者：_Spectator_ (4星)**
   - **关键亮点**：详细解释了消除过程，代码清晰，使用了`deque`数据结构，时间复杂度为$O(n)$。
   - **代码核心**：
     ```cpp
     while(!st.empty())
     {
         if(st.size()==1||st.front()!=st.back())break;
         long long cnt=0; 
         while(!st.empty())
         {
             ch=st.front(),st.pop_front(),cnt++;
             if(st.front()!=ch)break;
         }
         while(!st.empty())
         {
             ch=st.back(),st.pop_back(),cnt++;
             if(st.back()!=ch)break;
         }
         if(st.empty()&&cnt>=2)
         {
             cout<<cnt+1;
             return 0;
         }
         if(cnt<3)break;
     }
     ```

2. **作者：gyh20 (4星)**
   - **关键亮点**：简洁明了，直接通过贪心策略从两端向中间消除，代码简洁高效。
   - **代码核心**：
     ```cpp
     while(l<=r){
         if(l==r){
             putchar('0');
             return 0;
         }
         cnt=2;
         if(s[l]!=s[r]){
             putchar('0');
             return 0;
         }
         while(s[l+1]==s[l]&&l<r)++l,++cnt;
         while(s[r-1]==s[r]&&r>l)--r,++cnt;
         ++l;
         --r;
         if(r<l){
             printf("%d",cnt);
             return 0;
         }
         if(cnt<3){
             putchar('0');
             return 0;
         }
     }
     ```

3. **作者：xh001 (4星)**
   - **关键亮点**：代码结构清晰，使用了`deque`，并提供了详细的注释，便于理解。
   - **代码核心**：
     ```cpp
     while(!q.empty())
     {
         if(q.size()==1 || q.front()!=q.back()) break;
         sum=0; 
         while(!q.empty())
         {
             c=q.front();
             q.pop_front();
             sum++;
             if(q.front()!=c) break;
         }
         while(!q.empty())
         {
             c=q.back();
             q.pop_back();
             sum++;
             if(q.back()!=c) break;
         }
         if(q.empty() && sum>=2)
         {
             cout<<sum+1;
             return 0;
         }
         if(sum<3) break;
     }
     ```

【最优关键思路】
使用双端队列（`deque`）从两端向中间消除相同颜色的球，判断是否满足消除条件，最终合法的插入方式数量为中间段的长度加1。

【可拓展之处】
类似的问题可以扩展到其他消除类游戏，如“祖玛”游戏，或者更复杂的消除规则。可以通过调整消除条件或增加球的种类来增加难度。

【推荐题目】
1. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
2. [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)
3. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)

---
处理用时：38.08秒
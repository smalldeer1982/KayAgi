# 题目信息

# Modulo Equality

## 题目描述

你有一个正整数$m$和两个整数序列:

$a=[a_1, a_2, a_n]$和$b=[b_1,b_2b_n]$。

这两个序列的长度都是$n$。

然后将$a$序列中的数加上一个数$x$，$mod \ m$之后得到的序列改变或者不改变顺序与$b$序列相等.

## 样例 #1

### 输入

```
4 3
0 0 2 1
2 0 1 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3 2
0 0 0
1 1 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5 10
0 0 0 1 2
2 1 0 0 0
```

### 输出

```
0
```

# AI分析结果

【题目内容】
# Modulo Equality

## 题目描述

你有一个正整数$m$和两个整数序列:

$a=[a_1, a_2, a_n]$和$b=[b_1,b_2b_n]$。

这两个序列的长度都是$n$。

然后将$a$序列中的数加上一个数$x$，$mod \ m$之后得到的序列改变或者不改变顺序与$b$序列相等.

## 样例 #1

### 输入

```
4 3
0 0 2 1
2 0 1 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3 2
0 0 0
1 1 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5 10
0 0 0 1 2
2 1 0 0 0
```

### 输出

```
0
```

【算法分类】数学

【题解分析与结论】
该题的核心思路是通过枚举可能的$x$值，并验证$a$序列加上$x$后是否与$b$序列相等。大多数题解采用了排序和枚举的方法，通过计算$(b_i - a_1 + m) \% m$来得到可能的$x$值，然后验证$a$序列加上$x$后是否与$b$序列相等。其中，crpboy的题解通过KMP算法优化了匹配过程，达到了$O(n \log n)$的时间复杂度，是最优的解法。

【所选题解】
1. **crpboy (5星)**
   - **关键亮点**：使用KMP算法优化了匹配过程，时间复杂度为$O(n \log n)$，代码结构清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     for(int i=1,j=0;i<n<<1;i++)
     {
         while(j&&a[j+1]!=b[i])j=pre[j];
         if(a[j+1]==b[i])j++;
         if(j==n-1)ans=min(ans,(-oa[1]+ob[i-j+1]+m)%m);
     }
     ```
   - **实现思想**：通过KMP算法匹配$a$和$b$序列的差值，找到最小的$x$值。

2. **Dolphin_ (4星)**
   - **关键亮点**：通过枚举可能的$x$值，并验证$a$序列加上$x$后是否与$b$序列相等，代码简洁易懂。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;++i)
     {
         x=(b[i]+m-a[1])%m;
         if(check()) ans=min(ans,x);
     }
     ```
   - **实现思想**：枚举每个可能的$x$值，并通过排序和比较验证是否满足条件。

3. **xuezhe (4星)**
   - **关键亮点**：通过枚举$x$值并验证$a$序列加上$x$后是否与$b$序列相等，代码结构清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;++i){
         ll x=(b[i]-a[1]+m)%m;
         for(int j=1;j<=n;++j)
             c[j]=(a[j]+x)%m;
         sort(c+1,c+1+n);
         can=1;
         for(int j=1;j<=n;++j){
             if(b[j]^c[j]){
                 can=0;
                 break;
             }
         }
         if(can){
             ans=min(ans,x);
         }
     }
     ```
   - **实现思想**：枚举每个可能的$x$值，并通过排序和比较验证是否满足条件。

【最优关键思路】
通过枚举可能的$x$值，并验证$a$序列加上$x$后是否与$b$序列相等。使用KMP算法优化匹配过程，可以达到$O(n \log n)$的时间复杂度。

【可拓展之处】
类似的问题可以通过枚举和验证的方法解决，如寻找序列的偏移量或匹配序列的差值。KMP算法在匹配序列差值时有广泛应用。

【推荐题目】
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：33.29秒
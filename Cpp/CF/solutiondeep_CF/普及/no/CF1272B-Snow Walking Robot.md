# 题目信息

# Snow Walking Robot

## 题目描述

有一个机器人，站在一个平面直角坐标系上，开始时他的坐标为$(0,0)$



给出一个指令序列$s$，它只由`L`,`R`,`U`,`D` 四个大写字母组成  

若机器人当前坐标为$(x,y)$  

- 如果当前字母为 `L`，那么机器人就会向左移动到$x-1,y$  

- 如果当前字母为 `R`，那么机器人就会向右移动到$x+1,y$  

- 如果当前字母为 `U`，那么机器人就会向上移动到$x,y+1$  

- 如果当前字母为 `D`，那么机器人就会向下移动到$x,y-1$



如果一个坐标的点被走过了两次（除$(0,0)$外），那么机器人就会爆炸  

一个操作序列合法，当且仅当中途机器人不会爆炸，并且满足指令序列结束时，机器人的坐标为$(0,0)$（也就是最后回到原点）  

当然，空指令序列也是合法的



我们发现，所有的指令序列不一定都合法



给出一个指令序列$s$，你的任务是通过删除指令和重排序列，让指令序列合法，并且满足删除的指令数最小

## 说明/提示

$1 \le q \le 2\cdot 10^4$，$\sum|s| \le 10^5$  

其中$|s|$为字符串$s$的长度  

感谢 @_Wolverine 提供的翻译

## 样例 #1

### 输入

```
6
LRU
DURLDRUDRULRDURDDL
LRUDDLRUDRUL
LLLLRRRR
URDUR
LLL
```

### 输出

```
2
LR
14
RUURDDDDLLLUUR
12
ULDDDRRRUULL
2
LR
2
UD
0

```

# AI分析结果

### 题目内容重写
# 雪地行走机器人

## 题目描述

有一个机器人，站在一个平面直角坐标系上，开始时他的坐标为$(0,0)$。

给出一个指令序列$s$，它只由`L`,`R`,`U`,`D` 四个大写字母组成。

若机器人当前坐标为$(x,y)$：

- 如果当前字母为 `L`，那么机器人就会向左移动到$x-1,y$。
- 如果当前字母为 `R`，那么机器人就会向右移动到$x+1,y$。
- 如果当前字母为 `U`，那么机器人就会向上移动到$x,y+1$。
- 如果当前字母为 `D`，那么机器人就会向下移动到$x,y-1$。

如果一个坐标的点被走过了两次（除$(0,0)$外），那么机器人就会爆炸。

一个操作序列合法，当且仅当中途机器人不会爆炸，并且满足指令序列结束时，机器人的坐标为$(0,0)$（也就是最后回到原点）。

当然，空指令序列也是合法的。

我们发现，所有的指令序列不一定都合法。

给出一个指令序列$s$，你的任务是通过删除指令和重排序列，让指令序列合法，并且满足删除的指令数最小。

## 说明/提示

$1 \le q \le 2\cdot 10^4$，$\sum|s| \le 10^5$。

其中$|s|$为字符串$s$的长度。

感谢 @_Wolverine 提供的翻译。

## 样例 #1

### 输入

```
6
LRU
DURLDRUDRULRDURDDL
LRUDDLRUDRUL
LLLLRRRR
URDUR
LLL
```

### 输出

```
2
LR
14
RUURDDDDLLLUUR
12
ULDDDRRRUULL
2
LR
2
UD
0
```

### 算法分类
贪心

### 题解分析与结论
各题解的核心思路都是通过贪心策略，让机器人走出一个矩形，以确保每个点（原点除外）被访问不超过一次，并且最终回到原点。具体来说，通过取`L`和`R`的最小值作为矩形的长，取`U`和`D`的最小值作为矩形的宽，从而最大化保留的指令数。此外，题解还处理了特殊情况，如当某一方向的指令数为0时，只能输出另一方向的两个指令。

### 所选高星题解
1. **作者：woshishei (4星)**
   - **关键亮点**：通过贪心策略，选择矩形路径，确保每个点只被访问一次，并且最终回到原点。代码清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     l=min(l,r);
     r=min(l,r);
     u=min(u,d);
     d=min(u,d);
     if(l==0){
         printf(u>0?"2\nUD\n":"0\n\n");
         return;
     }
     if(u==0){
         printf(l>0?"2\nLR\n":"0\n\n");
         return;
     }
     printf("%d\n",l+r+u+d);
     for(int i=1;i<=l;i++) printf("L");
     for(int i=1;i<=u;i++) printf("U");
     for(int i=1;i<=r;i++) printf("R");
     for(int i=1;i<=d;i++) printf("D");
     printf("\n");
     ```

2. **作者：piggy123 (4星)**
   - **关键亮点**：同样采用贪心策略，处理特殊情况时逻辑清晰，代码简洁。
   - **核心代码**：
     ```cpp
     u=d=min(u,d);
     r=l=min(r,l);
     if (r==0&&l==0&&u>1){
         u=d=1;
     }
     if (u==0&&d==0&&l>1){
         l=r=1;
     }
     cout << u+r+d+l << endl;
     for (ll i=0;i<u;i++) cout << 'U';
     for (ll i=0;i<r;i++) cout << 'R';
     for (ll i=0;i<d;i++) cout << 'D';
     for (ll i=0;i<l;i++) cout << 'L';
     cout << endl;
     ```

3. **作者：zhu_wen (4星)**
   - **关键亮点**：通过模拟思想，处理特殊情况时逻辑清晰，代码简洁。
   - **核心代码**：
     ```cpp
     l = r = min(l, r);
     u = d = min(u, d);
     if (u == 0 && d == 0 && l > 1) l = r = 1;
     if (l == 0 && r == 0 && u > 1) d = u = 1;
     cout << l + r + d + u << endl;
     for (int j = 0; j < l; j++) cout << "L";
     for (int j = 0; j < u; j++) cout << "U";
     for (int j = 0; j < r; j++) cout << "R";
     for (int j = 0; j < d; j++) cout << "D";
     cout << endl;
     ```

### 最优关键思路
通过贪心策略，取`L`和`R`的最小值作为矩形的长，取`U`和`D`的最小值作为矩形的宽，从而最大化保留的指令数。处理特殊情况时，确保只能输出另一方向的两个指令。

### 可拓展之处
类似的问题可以扩展到三维空间，或者考虑更多的移动方向。此外，可以进一步优化路径，使得机器人走过的路径更加复杂但仍然合法。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：43.87秒
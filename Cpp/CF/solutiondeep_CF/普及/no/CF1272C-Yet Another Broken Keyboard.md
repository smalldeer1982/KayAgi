# 题目信息

# Yet Another Broken Keyboard

## 题目描述

$Norge$，找到了一个长度为$n$的字符串$s$（$s$仅由小写英文字母构成），他想把这个字符串的所有$\frac{n(n+1)}{2}$个连续非空子串都打出来



可是，他发现他的键盘坏了，只能打出26字母中的$k$个  

这$k$个字母分别为：$c_1,c_2,c_3,\dots ,c_k$



请求出用这个坏掉的键盘，最多能打出多少个字符串$s$的连续非空子串

## 说明/提示

$1\leq n \le 2\cdot 10^5$，$1\leq k \le 26$  

感谢 @_Wolverine 提供的翻译

## 样例 #1

### 输入

```
7 2
abacaba
a b
```

### 输出

```
12
```

## 样例 #2

### 输入

```
10 3
sadfaasdda
f a d
```

### 输出

```
21
```

## 样例 #3

### 输入

```
7 1
aaaaaaa
b
```

### 输出

```
0
```

# AI分析结果

【题目内容】
# Yet Another Broken Keyboard

## 题目描述

$Norge$，找到了一个长度为$n$的字符串$s$（$s$仅由小写英文字母构成），他想把这个字符串的所有$\frac{n(n+1)}{2}$个连续非空子串都打出来

可是，他发现他的键盘坏了，只能打出26字母中的$k$个  

这$k$个字母分别为：$c_1,c_2,c_3,\dots ,c_k$

请求出用这个坏掉的键盘，最多能打出多少个字符串$s$的连续非空子串

## 说明/提示

$1\leq n \le 2\cdot 10^5$，$1\leq k \le 26$  

感谢 @_Wolverine 提供的翻译

## 样例 #1

### 输入

```
7 2
abacaba
a b
```

### 输出

```
12
```

## 样例 #2

### 输入

```
10 3
sadfaasdda
f a d
```

### 输出

```
21
```

## 样例 #3

### 输入

```
7 1
aaaaaaa
b
```

### 输出

```
0
```

【算法分类】字符串

【题解分析与结论】
题目要求计算字符串中所有仅由可用字母构成的连续子串的个数。核心思路是通过遍历字符串，找到所有由可用字母构成的连续子串，并使用公式 $\frac{len \times (len+1)}{2}$ 计算每个子串的贡献。难点在于如何高效地处理字符串中的不可用字母，并将字符串分割为多个可用字母的连续子串。

【评分较高的题解】

1. **作者：Rainbow_qwq (5星)**
   - **关键亮点**：思路清晰，代码简洁，使用了布尔数组标记可用字母，通过遍历字符串计算连续可用字母的长度，并利用公式快速计算子串个数。
   - **代码核心**：
     ```cpp
     int len = 0;
     For(i,0,n-1){
         if(can[s[i]-'a'+1]) len++;
         else{
             res += len*(len+1)/2;
             len = 0;
         }
     }
     res += len*(len+1)/2;
     ```

2. **作者：AmamiyaYuuko (4星)**
   - **关键亮点**：使用了布尔数组标记可用字母，通过遍历字符串维护连续可用字母的长度，并在遇到不可用字母时更新答案。代码结构清晰，处理了边界情况。
   - **代码核心**：
     ```cpp
     for (int i = 0; i < n; ++i){
         if (b[str[i] - 'a']) ++len;
         else{
             ans += (len * (len + 1)) / 2;
             len = 0;
         }
     }
     if (len) ans += (len * (len + 1)) / 2;
     ```

3. **作者：pyz51 (4星)**
   - **关键亮点**：通过遍历字符串，记录连续可用字母的长度，并在遇到不可用字母时计算子串个数。代码简洁，处理了边界情况。
   - **代码核心**：
     ```cpp
     for(int i=0;i<n;i++){
         bool flag=0;
         for(int j=1;j<=k;j++) if(s[i]==c[j]) flag=1;
         if(flag) cnt++;
         else{
             ans+=1ll*cnt*(cnt+1)/2;
             cnt=0;
         }
     }
     ans+=1ll*cnt*(cnt+1)/2;
     ```

【最优关键思路或技巧】
- **布尔数组标记**：使用布尔数组标记可用字母，方便快速判断字符是否可用。
- **连续子串计算**：通过遍历字符串，维护连续可用字母的长度，并在遇到不可用字母时使用公式 $\frac{len \times (len+1)}{2}$ 计算子串个数。
- **边界处理**：在遍历结束后，检查是否还有未处理的连续可用字母，确保不遗漏。

【可拓展之处】
- **类似问题**：可以扩展到处理更复杂的字符集或更长的字符串，或者处理多个字符串的组合问题。
- **优化思路**：可以考虑使用位运算或其他数据结构进一步优化字符的标记和查询效率。

【推荐题目】
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3805 【模板】manacher算法](https://www.luogu.com.cn/problem/P3805)
3. [P3919 【模板】可持久化线段树](https://www.luogu.com.cn/problem/P3919)

【个人心得】
- **调试经历**：在处理边界情况时，容易遗漏最后一个连续子串的计算，需要特别注意。
- **踩坑教训**：未使用 `long long` 类型可能导致计算结果溢出，需注意数据类型的选择。

---
处理用时：37.00秒
# 题目信息

# Remove One Element

## 题目描述

给出一个长度为$n$的序列  

你可以选择性地删除掉该序列中的一个元素，这样，最后的序列长度为$n-1$或$n$  

你需要求出，在选择性的删除操作后，该序列的 最长连续上升子序列的长度

## 说明/提示

$2 \le n \le 2 \cdot 10^5$，$1 \le a_i \le 10^9$  

感谢 @_Wolverine 提供的翻译

## 样例 #1

### 输入

```
5
1 2 5 3 4
```

### 输出

```
4
```

## 样例 #2

### 输入

```
2
1 2
```

### 输出

```
2
```

## 样例 #3

### 输入

```
7
6 5 4 3 2 4 3
```

### 输出

```
2
```

# AI分析结果

【题目内容】
# 删除一个元素

## 题目描述

给出一个长度为$n$的序列  

你可以选择性地删除掉该序列中的一个元素，这样，最后的序列长度为$n-1$或$n$  

你需要求出，在选择性的删除操作后，该序列的 最长连续上升子序列的长度

## 说明/提示

$2 \le n \le 2 \cdot 10^5$，$1 \le a_i \le 10^9$  

感谢 @_Wolverine 提供的翻译

## 样例 #1

### 输入

```
5
1 2 5 3 4
```

### 输出

```
4
```

## 样例 #2

### 输入

```
2
1 2
```

### 输出

```
2
```

## 样例 #3

### 输入

```
7
6 5 4 3 2 4 3
```

### 输出

```
2
```

【算法分类】
动态规划

【题解分析与结论】
本题的核心在于通过动态规划求解最长连续上升子序列，并考虑删除一个元素后的情况。大多数题解采用了类似的双数组动态规划方法，分别计算从左到右和从右到左的最长连续上升子序列长度，然后通过枚举删除的元素来更新最终结果。

【评分较高的题解】

1. **作者：BINYU (5星)**
   - **关键亮点**：思路清晰，代码简洁，明确区分了不删除和删除元素的情况，并通过双数组动态规划高效求解。
   - **代码实现**：
     ```cpp
     for(int i = 1;i <= n;i++)
         if(a[i] > a[i - 1])dp1[i] = dp1[i - 1] + 1;
         else dp1[i] = 1;
     for(int i = n;i >= 1;i--)
         if(a[i] < a[i + 1])dp2[i] = dp2[i + 1] + 1;
         else dp2[i] = 1;
     for(int i = 1;i <= n;i++)
     {
         if(a[i - 1] < a[i + 1])ans = max(ans,dp1[i - 1] + dp2[i + 1]);
         ans = max(ans,max(dp1[i],dp2[i]));
     }
     ```

2. **作者：quanjun (4星)**
   - **关键亮点**：详细解释了动态规划的状态转移方程，并强调了删除元素时的特殊情况处理。
   - **代码实现**：
     ```cpp
     f[1] = 1;
     for (int i = 2; i <= n; i ++) {
         if (a[i-1] < a[i]) f[i] = f[i-1]+1;
         else f[i] = 1;
     }
     g[n] = 1;
     for (int i = n-1; i >= 1; i --) {
         if (a[i] < a[i+1]) g[i] = g[i+1]+1;
         else g[i] = 1;
     }
     for (int i = 1; i <= n; i ++) ans = max(ans, f[i]);
     for (int i = 2; i < n; i ++) if (a[i-1] < a[i+1]) ans = max(ans, f[i-1] + g[i+1]);
     ```

3. **作者：Crasole (4星)**
   - **关键亮点**：代码结构清晰，通过双数组动态规划分别计算从左到右和从右到左的最长连续上升子序列，并考虑了删除元素的情况。
   - **代码实现**：
     ```cpp
     dpw[1] = 1;
     for(int i = 1; i <= n; i++)
         if(a[i] > a[i - 1]) dpw[i] = dpw[i - 1] + 1;
         else dpw[i] = 1;
     dpq[n] = 1;
     for(int i = n; i >= 1; i--)
         if(a[i + 1] > a[i]) dpq[i] = dpq[i + 1] + 1;
         else dpq[i] = 1; 
     int ans = 0;
     for(int i = 1; i <= n; i++){
         if(a[i - 1] < a[i + 1])
             ans = max(ans, dpw[i - 1] + dpq[i + 1]);
         ans = max(ans, max(dpw[i], dpq[i]));
     }
     ```

【最优关键思路或技巧】
- **双数组动态规划**：分别计算从左到右和从右到左的最长连续上升子序列长度，便于在删除元素时快速拼接。
- **枚举删除元素**：通过枚举每个元素，判断删除后是否能拼接前后子序列，从而更新最大长度。

【可拓展之处】
- **类似问题**：可以扩展到删除多个元素的情况，或者考虑删除元素后的其他子序列问题。
- **算法套路**：双数组动态规划在处理序列问题时非常常见，可以应用于其他类似的最长子序列问题。

【推荐题目】
1. P1020 导弹拦截
2. P1091 合唱队形
3. P1439 【模板】最长公共子序列

---
处理用时：38.81秒
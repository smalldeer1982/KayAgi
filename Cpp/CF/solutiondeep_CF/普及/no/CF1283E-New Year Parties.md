# 题目信息

# New Year Parties

## 题目描述

【问题描述】

新的一年到了,是时候和你的朋友聚在一起，回顾过去一年里发生的暖心事了。

n个人住在一个可以用数轴表示的城市里，第i个人住在一个整数坐标xi的房子里。第i个人可以和坐标xi - 1, xi+1一起来家里庆祝新年，或者呆在xi，每个人只能移动一次。对于房子在1或n的人，他们可以来到坐标0或n+1的房子。

例如，初始位置为x=[1,2,4,4]。最后的位置可以是[1,3,3,4]，[0,2,3,3]，[2,2,5,5]，[2,1,3,5]等等。被占用的房屋总数等于在最终房屋中不同位置的总数。

所有人可以随意选择三种操作之一，然后计算有人的房屋总数。有人的房屋可能达到的最小数量和最大数量各是多少?

## 说明/提示

在样例1中，人们可以转到[2,2,3,3]，x1到x1+1，x2不动，x3到x3 - 1，x4到x4 - 1。[1,1,3,3],[2,2,3,3]或[2,2,4,4]也是获得最小数量的选择。

对于已占用的房屋的最大数量，人们可以转到[1,2,3,4]或[0,2,4,5]。

【数据规模和约定】

1<=n<=2*10^5 , 1<=xi<=n

## 样例 #1

### 输入

```
4
1 2 4 4
```

### 输出

```
2 4
```

## 样例 #2

### 输入

```
9
1 1 8 8 8 4 4 4 4
```

### 输出

```
3 8
```

## 样例 #3

### 输入

```
7
4 3 7 1 4 3 3
```

### 输出

```
3 6
```

# AI分析结果

### 题目内容重写
【问题描述】

新的一年到了，是时候和你的朋友聚在一起，回顾过去一年里发生的暖心事了。

n个人住在一个可以用数轴表示的城市里，第i个人住在一个整数坐标xi的房子里。第i个人可以和坐标xi - 1, xi+1一起来家里庆祝新年，或者呆在xi，每个人只能移动一次。对于房子在1或n的人，他们可以来到坐标0或n+1的房子。

例如，初始位置为x=[1,2,4,4]。最后的位置可以是[1,3,3,4]，[0,2,3,3]，[2,2,5,5]，[2,1,3,5]等等。被占用的房屋总数等于在最终房屋中不同位置的总数。

所有人可以随意选择三种操作之一，然后计算有人的房屋总数。有人的房屋可能达到的最小数量和最大数量各是多少?

【说明/提示】

在样例1中，人们可以转到[2,2,3,3]，x1到x1+1，x2不动，x3到x3 - 1，x4到x4 - 1。[1,1,3,3],[2,2,3,3]或[2,2,4,4]也是获得最小数量的选择。

对于已占用的房屋的最大数量，人们可以转到[1,2,3,4]或[0,2,4,5]。

【数据规模和约定】

1<=n<=2*10^5 , 1<=xi<=n

### 算法分类
贪心

### 题解分析与结论
该问题的核心在于通过贪心策略来最小化和最大化被占用的房屋数量。最小化时，尽量让多个点合并到一个位置；最大化时，尽量让每个点占据不同的位置。各题解均采用了贪心策略，但在具体实现上有所不同。

### 所选高星题解
#### 题解1：作者：xiaomuyun (赞：9)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，直接通过遍历和标记数组实现最小化和最大化的计算。
- **核心代码**：
```cpp
for(int i=1;i<=n;++i){//求最小值
    if(!vis[x[i]-1]&&!vis[x[i]]&&!vis[x[i]+1]) ++cnt,vis[x[i]+1]=true;
}
for(int i=1;i<=n;++i){//求最大值
    if(!vis[x[i]-1]) ++cnt,vis[x[i]-1]=true;
    else if(!vis[x[i]]) ++cnt,vis[x[i]]=true;
    else if(!vis[x[i]+1]) ++cnt,vis[x[i]+1]=true;
}
```
- **实现思想**：通过遍历每个点，判断其移动范围内的位置是否已被占用，选择未被占用的位置进行移动，并更新标记数组和计数。

#### 题解2：作者：乐哥 (赞：4)
- **星级**：4星
- **关键亮点**：详细解释了贪心策略的实现过程，使用了双指针和分段处理的方法，代码结构清晰。
- **核心代码**：
```cpp
int solve_min() {
    int res=0,i=1;
    while(i<=n) {
        if(cnt[i]) res++,i+=3;
        else i++;
    }
    return res;
}
int solve_max() {
    int res=0,dist=2;
    bool ok=false;
    for(int i=1;i<=n;i++) {
        if(!cnt[i]) {
            dist++;
            continue;
        }
        int j=i-1,sum=0;
        while(j+1<=n&&cnt[j+1])
            j++,sum+=cnt[j];
        res+=(j-i+1);
        if(sum>j-i+1&&(!ok||dist>1))
            sum--,res++;
        ok=false;
        if(sum>j-i+1)
            ok=true,res++;
        i=j; dist=0;
    }
    return res;
}
```
- **实现思想**：通过双指针和分段处理，计算最小值和最大值。最小值时，跳过连续三个可到达的位置；最大值时，尽量扩展当前段。

### 最优关键思路或技巧
1. **贪心策略**：通过局部最优选择来达到全局最优解，最小化时尽量合并，最大化时尽量分散。
2. **标记数组**：使用标记数组记录位置是否被占用，避免重复计算。
3. **双指针与分段处理**：在处理最大值时，使用双指针和分段处理的方法，提高效率。

### 可拓展之处
类似的问题可以通过贪心策略来解决，例如在资源分配、任务调度等问题中，通过局部最优选择来达到全局最优。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：34.78秒
# 题目信息

# NEKO's Maze Game

## 题目描述

NEKO#ΦωΦ 刚刚给自己的电脑添加了一款新的迷宫游戏！

这个游戏的主要谜题，是一个在 $2 \times n$ 的矩形网格上的迷宫。NEKO 的任务是操控女主角 Nekomimi 从格子 $(1, 1)$ 开始，移动到位于格子 $(2, n)$ 的大门处，并离开迷宫。女主角只能在有公共边的两个格子之间移动。

然而在游戏的某些时刻，有些格子会改变它们的状态：从正常的地面变成岩浆（禁止移动到岩浆格子上）或反过来（让该格子再次变得能够通行）。游戏刚开始时，每个格子都是正常的地面。

当直播过去了数个小时后，NEKO 才终于弄明白了，只有 $q$ 个这样的时刻：第 $i$ 个时刻会翻转格子 $(r_i, c_i)$ 的状态（从地面变成岩浆或相反）。

知道了这些后，NEKO 想问在每个时刻结束后，还是否有可能从格子 $(1, 1)$ 移动到格子 $(2, n)$，并且不经过岩浆格子。

虽然 NEKO 是一个硬核玩家兼热门主播，她还是没有足够的[脑力](https://www.bilibili.com/video/av5299187)去解答这些问题。你可以帮帮她吗？

## 样例 #1

### 输入

```
5 5
2 3
1 4
2 4
2 3
1 4```

### 输出

```
Yes
No
No
No
Yes```

# AI分析结果

### 题目内容重写
# NEKO的迷宫游戏

## 题目描述

NEKO#ΦωΦ 刚刚给自己的电脑添加了一款新的迷宫游戏！

这个游戏的主要谜题，是一个在 $2 \times n$ 的矩形网格上的迷宫。NEKO 的任务是操控女主角 Nekomimi 从格子 $(1, 1)$ 开始，移动到位于格子 $(2, n)$ 的大门处，并离开迷宫。女主角只能在有公共边的两个格子之间移动。

然而在游戏的某些时刻，有些格子会改变它们的状态：从正常的地面变成岩浆（禁止移动到岩浆格子上）或反过来（让该格子再次变得能够通行）。游戏刚开始时，每个格子都是正常的地面。

当直播过去了数个小时后，NEKO 才终于弄明白了，只有 $q$ 个这样的时刻：第 $i$ 个时刻会翻转格子 $(r_i, c_i)$ 的状态（从地面变成岩浆或相反）。

知道了这些后，NEKO 想问在每个时刻结束后，还是否有可能从格子 $(1, 1)$ 移动到格子 $(2, n)$，并且不经过岩浆格子。

虽然 NEKO 是一个硬核玩家兼热门主播，她还是没有足够的[脑力](https://www.bilibili.com/video/av5299187)去解答这些问题。你可以帮帮她吗？

## 样例 #1

### 输入

```
5 5
2 3
1 4
2 4
2 3
1 4```

### 输出

```
Yes
No
No
No
Yes```

### 算法分类
模拟

### 题解分析与结论
本题的核心在于实时维护迷宫的状态，并在每次状态变化后快速判断是否仍然存在从起点到终点的路径。由于迷宫的大小为 $2 \times n$，且每次只改变一个格子的状态，因此可以通过维护一个计数器来记录当前存在的“挡路”情况，从而在每次操作后快速判断是否仍然可以通行。

### 评分较高的题解
1. **作者：Konnyaku_LXZ (5星)**
   - **关键亮点**：通过维护一个计数器来记录当前存在的“挡路”情况，每次操作后只需判断计数器是否大于0即可。思路清晰，代码简洁。
   - **代码核心思想**：
     ```cpp
     void Solve(){
         scanf("%d%d",&x,&y);
         --x;
         t[x][y]^=1;//修改当前点的状态
         if(t[x^1][y-1]) cnt+=t[x][y]?1:-1;//三种挡路的情况
         if(t[x^1][y]) cnt+=t[x][y]?1:-1;
         if(t[x^1][y+1]) cnt+=t[x][y]?1:-1;
     }
     ```

2. **作者：zjh111111 (4星)**
   - **关键亮点**：同样通过维护计数器来记录“挡路”情况，代码实现简洁，逻辑清晰。
   - **代码核心思想**：
     ```cpp
     if (f[ri][ci]) { //从不可走到可走
         if (f[3-ri][ci]) -- cnt; //原来算上去的都减掉
         if (f[3-ri][ci-1]) -- cnt;
         if (f[3-ri][ci+1]) -- cnt;
     }
     ```

3. **作者：lizihan250 (4星)**
   - **关键亮点**：通过维护一个计数器来记录“挡路”情况，代码实现简洁，逻辑清晰。
   - **代码核心思想**：
     ```cpp
     if(ok[ux][uy])
     {
         if(ok[3-ux][uy-1]) sum--;
         if(ok[3-ux][uy]) sum--;
         if(ok[3-ux][uy+1]) sum--;
     }
     ```

### 最优关键思路
通过维护一个计数器来记录当前存在的“挡路”情况，每次操作后只需判断计数器是否大于0即可。这种方法的时间复杂度为 $O(q)$，能够高效地处理大规模数据。

### 可拓展之处
类似的问题可以扩展到更大的迷宫或更复杂的状态变化，依然可以通过维护计数器或其他数据结构来快速判断是否仍然存在通路。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1131 [ZJOI2007]时态同步](https://www.luogu.com.cn/problem/P1131)

---
处理用时：33.43秒
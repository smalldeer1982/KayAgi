# 题目信息

# Cow and Friend

## 题目描述

贝茜有太多朋友了。因为她是所有人最喜欢的牛。她的朋友兔兔在试着跳到贝茜所在的地方，那么他们就可以玩了。

更具体地，兔兔他想跳几步使得他能从 $(0,0)$ 跳到 $(x,0)$。他只想着在二维平面上从一个点跳到另一个点当且仅当两个点的欧几里得距离是他 $n$ 个喜欢的数中的其中一个，也就是 $a_1, a_2, \ldots a_n$。

兔兔最少要跳几步才能从 $(0,0)$ 跳到 $(x,0)$ 呢？兔兔不必跳到一个整数的坐标，换句话说，他可以跳到一个不是整数的坐标。可以证明，兔兔总可以到达他的终点。

重新在此声明，两个点的欧几里得距离可以使用公式算出，设两个点的坐标分别为 $x_1,y_1$ 以及 $x_2,y_2$，那么有公式 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

如下图所示，如果兔兔喜欢的数是 $1$ 和 $3$的话，那么他可以跳两步从 $(0,0)$ 跳到 $(4,0)$。值得注意的是，这里还有别的方式使得他可以用 $2$ 步跳到 $(4,0)$ 的方法。

![CF1307B Cow and Friend](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1307B/f7586d192526c0aed9ac1b72d0c3e07431d38d89.png)

图中的就是样例的第一个测试的示意图，两次跳的距离都是 $3$ -- 一个兔兔喜欢的数。换句话说，每一次兔兔都会选一个数 $a_i$，然后任意地跳到一个与这个点距离为 $a_i$ 的地方。 相同的数可以使用多次。

## 样例 #1

### 输入

```
4
2 4
1 3
3 12
3 4 5
1 5
5
2 10
15 4```

### 输出

```
2
3
1
2```

# AI分析结果

### 题目内容
贝茜有太多朋友了。因为她是所有人最喜欢的牛。她的朋友兔兔在试着跳到贝茜所在的地方，那么他们就可以玩了。

更具体地，兔兔他想跳几步使得他能从 $(0,0)$ 跳到 $(x,0)$。他只想着在二维平面上从一个点跳到另一个点当且仅当两个点的欧几里得距离是他 $n$ 个喜欢的数中的其中一个，也就是 $a_1, a_2, \ldots a_n$。

兔兔最少要跳几步才能从 $(0,0)$ 跳到 $(x,0)$ 呢？兔兔不必跳到一个整数的坐标，换句话说，他可以跳到一个不是整数的坐标。可以证明，兔兔总可以到达他的终点。

重新在此声明，两个点的欧几里得距离可以使用公式算出，设两个点的坐标分别为 $x_1,y_1$ 以及 $x_2,y_2$，那么有公式 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

如下图所示，如果兔兔喜欢的数是 $1$ 和 $3$的话，那么他可以跳两步从 $(0,0)$ 跳到 $(4,0)$。值得注意的是，这里还有别的方式使得他可以用 $2$ 步跳到 $(4,0)$ 的方法。

![CF1307B Cow and Friend](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1307B/f7586d192526c0aed9ac1b72d0c3e07431d38d89.png)

图中的就是样例的第一个测试的示意图，两次跳的距离都是 $3$ -- 一个兔兔喜欢的数。换句话说，每一次兔兔都会选一个数 $a_i$，然后任意地跳到一个与这个点距离为 $a_i$ 的地方。 相同的数可以使用多次。

### 样例 #1

#### 输入

```
4
2 4
1 3
3 12
3 4 5
1 5
5
2 10
15 4```

#### 输出

```
2
3
1
2```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略，尽可能使用最大的跳跃距离来减少跳跃次数。主要难点在于如何处理当剩余距离小于最大跳跃距离时的情况。大多数题解都采用了以下思路：
1. 如果存在一个跳跃距离等于目标距离 $x$，则直接输出 $1$。
2. 否则，尽可能使用最大跳跃距离，剩余部分通过两次跳跃完成。

### 精选题解
#### 题解1：作者 cqbztz2 (赞：4)
**星级：5**
**关键亮点：**
- 思路清晰，代码简洁。
- 通过贪心策略，优先使用最大跳跃距离，剩余部分通过两次跳跃完成。
- 代码中使用了 `ceil` 函数来处理剩余距离，确保了计算的准确性。

**核心代码：**
```cpp
if(flag==1){
    cout<<1<<endl;
}
else if(maxn>x){
    cout<<2<<endl;
}
else{
    cout<<int(ceil(x/(maxn*1.0)))<<endl;
}
```

#### 题解2：作者 lzy120406 (赞：1)
**星级：4**
**关键亮点：**
- 思路简洁明了，代码实现高效。
- 通过特判和贪心策略，快速找到最优解。
- 使用了 `max_element` 函数来找到最大跳跃距离，代码简洁。

**核心代码：**
```cpp
if(hasX) {
    cout << "1\n";
    continue;
}
int maxA = *max_element(a, a+n);
int jumps = max(2, (x + maxA - 1) / maxA);
cout << jumps << '\n';
```

#### 题解3：作者 qwq___qaq (赞：0)
**星级：4**
**关键亮点：**
- 通过贪心策略和特判，快速找到最优解。
- 代码简洁，逻辑清晰。
- 使用了 `ceil` 函数来处理剩余距离，确保了计算的准确性。

**核心代码：**
```cpp
if(p)
    puts("1");
else if(k>x)
    puts("2");
else
    printf("%d\n",(x+k-1)/k);
```

### 最优关键思路
1. **贪心策略**：优先使用最大跳跃距离，减少跳跃次数。
2. **特判**：如果存在一个跳跃距离等于目标距离 $x$，则直接输出 $1$。
3. **剩余距离处理**：当剩余距离小于最大跳跃距离时，通过两次跳跃完成。

### 拓展思路
类似的问题可以通过贪心策略来解决，尤其是在需要最小化操作次数的情况下。例如，最小化跳跃次数、最小化步数等问题。

### 推荐题目
1. [P1044 跳马](https://www.luogu.com.cn/problem/P1044)
2. [P1045 跳石头](https://www.luogu.com.cn/problem/P1045)
3. [P1046 跳房子](https://www.luogu.com.cn/problem/P1046)

---
处理用时：33.60秒
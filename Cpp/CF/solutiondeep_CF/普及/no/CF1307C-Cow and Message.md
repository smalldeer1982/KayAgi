# 题目信息

# Cow and Message

## 题目描述

贝茜刚刚截取了来自约翰发送出去的讯息！但是，贝茜很肯定里面一定有隐藏的讯息。

讯息是一个字符串 $s$ ，全部都是由小写拉丁字母字符构成。她认为一个字符串 $t$ 是隐藏的当且仅当 $t$ 是 $s$ 的子序列且 $t$ 在 $s$ 中出现的下标构成了一个等差数列（公差必须为一个**正整数**）。

例如，字符串`aab`是隐藏在字符串`aaabb`因为`aab`出现在$s$的下标$1,3,5$，这刚好构成了一个等差数列，而公差是 $2$。贝茜觉得秘密讯息讯息一定是隐藏最多次的那一个字符串。两个 $s$ 中的子序列是不同的当且仅当两个字符串在 $s$ 中出现的下标是不同的。 请帮贝茜找出秘密讯息在 $s$ 中出现的次数吧。

例如，在字符串`aaabb`中，

`a`隐藏了 $3$ 次，

`b`隐藏了 $2$ 次，

`ab`隐藏了 $6$ 次，

`aa`隐藏了 $3$ 次，

`bb`隐藏了 $1$ 次，

`aab`隐藏了 $2$ 次，

`aaa`隐藏了 $1$ 次，

`abb`隐藏了 $1$ 次，

`aaab`隐藏了 $1$ 次，

`aabb`隐藏了 $1$ 次，

`aaabb`隐藏了 $1$ 次，

秘密讯息出现的次数是 $6$ 次。

## 样例 #1

### 输入

```
aaabb```

### 输出

```
6```

## 样例 #2

### 输入

```
usaco```

### 输出

```
1```

## 样例 #3

### 输入

```
lol```

### 输出

```
2```

# AI分析结果

【题目内容】
# 牛和消息

## 题目描述

贝茜刚刚截取了来自约翰发送出去的讯息！但是，贝茜很肯定里面一定有隐藏的讯息。

讯息是一个字符串 $s$ ，全部都是由小写拉丁字母字符构成。她认为一个字符串 $t$ 是隐藏的当且仅当 $t$ 是 $s$ 的子序列且 $t$ 在 $s$ 中出现的下标构成了一个等差数列（公差必须为一个**正整数**）。

例如，字符串`aab`是隐藏在字符串`aaabb`因为`aab`出现在$s$的下标$1,3,5$，这刚好构成了一个等差数列，而公差是 $2$。贝茜觉得秘密讯息讯息一定是隐藏最多次的那一个字符串。两个 $s$ 中的子序列是不同的当且仅当两个字符串在 $s$ 中出现的下标是不同的。 请帮贝茜找出秘密讯息在 $s$ 中出现的次数吧。

例如，在字符串`aaabb`中，

`a`隐藏了 $3$ 次，

`b`隐藏了 $2$ 次，

`ab`隐藏了 $6$ 次，

`aa`隐藏了 $3$ 次，

`bb`隐藏了 $1$ 次，

`aab`隐藏了 $2$ 次，

`aaa`隐藏了 $1$ 次，

`abb`隐藏了 $1$ 次，

`aaab`隐藏了 $1$ 次，

`aabb`隐藏了 $1$ 次，

`aaabb`隐藏了 $1$ 次，

秘密讯息出现的次数是 $6$ 次。

## 样例 #1

### 输入

```
aaabb```

### 输出

```
6```

## 样例 #2

### 输入

```
usaco```

### 输出

```
1```

## 样例 #3

### 输入

```
lol```

### 输出

```
2```

【算法分类】贪心

【题解分析与结论】
1. 所有题解都基于一个关键结论：秘密信息必然是由长度为1或长度为2的子序列构成。这是因为长度大于2的子序列的出现次数不会超过其前两个字符组成的长度为2的子序列的出现次数。
2. 题解主要分为两类：一类是通过后缀和或前缀和来统计长度为2的子序列的出现次数；另一类是通过遍历字符串并动态更新长度为2的子序列的出现次数。
3. 难点在于如何高效地统计长度为2的子序列的出现次数。大多数题解通过预处理后缀和或前缀和来优化这一过程。

【精选题解】
1. **作者：Reanap (赞：6)**
   - **星级：5**
   - **关键亮点：** 使用后缀和数组高效统计长度为2的子序列的出现次数，代码简洁且高效。
   - **核心代码：**
     ```cpp
     for (int i = 1; i < len; ++i) {
         for (int j = 0; j < 26; ++j) {
             ans[s[i] - 'a'][j] += suf[i + 1][j];
         }
     }
     ```
   - **个人心得：** 通过后缀和数组，可以快速计算每个字符之后的所有可能组合，大大减少了时间复杂度。

2. **作者：朝夕 (赞：3)**
   - **星级：4**
   - **关键亮点：** 使用二维数组记录长度为2的子序列的出现次数，代码逻辑清晰。
   - **核心代码：**
     ```cpp
     for (int i = 0; i < len; i++) {
         for (int j = 97; j <= 122; j++) {
             if (vis[j]) {
                 occ[j][s[i]] += vis[j];
                 ans = max(ans, occ[j][s[i]]);
             }
         }
         vis[s[i]]++;
         ans = max(ans, vis[s[i]]);
     }
     ```
   - **个人心得：** 通过动态更新二维数组，可以在遍历字符串的同时统计所有可能的长度为2的子序列的出现次数。

3. **作者：LJQ0808 (赞：2)**
   - **星级：4**
   - **关键亮点：** 使用前缀和数组优化统计过程，代码结构清晰。
   - **核心代码：**
     ```cpp
     for (int i = 1; i <= n; i++) {
         if (s[i] == fi + 'a' - 1) sum += (f[n][se] - f[i][se]);
     }
     ```
   - **个人心得：** 通过前缀和数组，可以快速计算每个字符之后的所有可能组合，减少了时间复杂度。

【最优关键思路】
- 使用后缀和或前缀和数组来高效统计长度为2的子序列的出现次数，是解决该问题的关键。这种方法不仅减少了时间复杂度，还使得代码更加简洁易读。

【可拓展之处】
- 类似的问题可以通过预处理后缀和或前缀和来优化统计过程，例如统计字符串中特定模式的子序列出现次数。

【推荐题目】
1. P1311 [NOIP2011 提高组] 选择客栈
2. P2679 [NOIP2015 提高组] 子串
3. P1365 [NOIP2011 提高组] 统计单词数

---
处理用时：34.43秒
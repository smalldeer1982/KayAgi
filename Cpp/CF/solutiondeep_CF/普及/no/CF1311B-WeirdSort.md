# 题目信息

# WeirdSort

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $p$，你需要按照以下规则给序列 $a$ 排序

对于所有 $(1 \le i \le m)$，$p_i$ 表示你可以交换 $a[p_i]$ 和 $a[p_i+1]$ 的值（可以操作任意次）
请求出是否能在以上限制条件下，保证排序后的原序列 $a$ 内元素值严格不递减

除了交换 $a[p_i]$ 和 $a[p_i+1]$ 之外，不可以有其他任何操作

## 说明/提示

$1 \le T,a_i \le 100$  
$1\le m < n \le 100$
$1\le p_i <n$

感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
6
3 2
3 2 1
1 2
4 2
4 1 2 3
3 2
5 1
1 2 3 4 5
1
4 2
2 1 4 3
1 3
4 2
4 3 2 1
1 3
5 2
2 1 2 3 3
1 4```

### 输出

```
YES
NO
YES
YES
NO
YES```

# AI分析结果

【题目内容】
# WeirdSort

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $p$，你需要按照以下规则给序列 $a$ 排序

对于所有 $(1 \le i \le m)$，$p_i$ 表示你可以交换 $a[p_i]$ 和 $a[p_i+1]$ 的值（可以操作任意次）
请求出是否能在以上限制条件下，保证排序后的原序列 $a$ 内元素值严格不递减

除了交换 $a[p_i]$ 和 $a[p_i+1]$ 之外，不可以有其他任何操作

## 说明/提示

$1 \le T,a_i \le 100$  
$1\le m < n \le 100$
$1\le p_i <n$

感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
6
3 2
3 2 1
1 2
4 2
4 1 2 3
3 2
5 1
1 2 3 4 5
1
4 2
2 1 4 3
1 3
4 2
4 3 2 1
1 3
5 2
2 1 2 3 3
1 4```

### 输出

```
YES
NO
YES
YES
NO
YES```

【算法分类】
排序

【题解分析与结论】
本题的核心在于判断在给定的交换限制下，是否能够通过交换相邻元素使序列变为非递减序列。题解主要采用了冒泡排序的思路，通过模拟交换过程来判断是否能够完成排序。

【所选高星题解】
1. **作者：gyh20 (赞：2)**
   - **星级：4星**
   - **关键亮点：**
     - 使用冒泡排序的思路，仅在允许交换的位置进行交换。
     - 最后检查数组是否有序，逻辑清晰且代码简洁。
   - **核心代码：**
     ```cpp
     for(re int i=1;i<=n;++i){
         for(re int j=1;j<n;++j){
             if(a[j]>a[j+1]){
                 if(p[j])swap(a[j],a[j+1]);
             }
         }
     }
     ```

2. **作者：ShineEternal (赞：2)**
   - **星级：4星**
   - **关键亮点：**
     - 将可交换的位置视为“传送带”，通过排序和分段处理来判断是否能够完成排序。
     - 处理了特殊情况（m=n-1），逻辑严谨。
   - **核心代码：**
     ```cpp
     sort(p+1,p+m+1);
     if(m==n-1){
         printf("YES\n");
         continue;
     }
     ```

3. **作者：LB_tq (赞：1)**
   - **星级：4星**
   - **关键亮点：**
     - 采用冒泡排序的思路，通过标记可交换的位置来判断是否能够完成排序。
     - 代码结构清晰，易于理解。
   - **核心代码：**
     ```cpp
     for(int i=1;i<n;i++){
         for(int j=1;j<=n-i;j++)
             if(a[j]>a[j+1]){
                 swap(a[j],a[j+1]);
                 if(p[j]==0){
                     flag=false;
                     break;
                 }
             }
         if(!flag)
             break;
     }
     ```

【最优关键思路】
通过模拟冒泡排序的过程，仅在允许交换的位置进行交换，最后检查数组是否有序。这种方法简单直观，且易于实现。

【拓展思路】
类似的问题可以扩展到其他排序算法，如快速排序或归并排序，但在交换限制下，冒泡排序是最直接的选择。

【推荐题目】
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

---
处理用时：29.25秒
# 题目信息

# Perform the Combo

## 题目描述

一台机器准备要打印一篇文章，有 $m$ 个打印操作  

给出操作序列 $p_1,p_2, \dots ,p_m$ 和 长度为 $n$ 的字符串 $s$  
对于每个 $(1 \le i \le m)$，$p_i$ 表示该机器将位置 $1\sim p_i$ 上的所有字母打印了出来  
最后，在所有操作做完后，该机器又将整个字符串 $s$ 打印了出来

请求出字母表中每个字母在文章中出现了多少次

## 说明/提示

$1\le T \le 10^4$  
$2 \le  n \le 2 \cdot 10^5$  
$1 \le  m \le 2 \cdot 10^5$  
$\sum n,\sum m \le 2 \cdot 10^5$  
$1 \le p_i <n$

感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
3
4 2
abca
1 3
10 5
codeforces
2 8 3 2 9
26 10
qwertyuioplkjhgfdsazxcvbnm
20 10 1 2 3 5 10 5 9 4```

### 输出

```
4 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 9 4 5 3 0 0 0 0 0 0 0 0 9 0 0 3 1 0 0 0 0 0 0 0 
2 1 1 2 9 2 2 2 5 2 2 2 1 1 5 4 11 8 2 7 5 1 10 1 5 2```

# AI分析结果

【题目内容】
# Perform the Combo

## 题目描述

一台机器准备要打印一篇文章，有 $m$ 个打印操作  

给出操作序列 $p_1,p_2, \dots ,p_m$ 和 长度为 $n$ 的字符串 $s$  
对于每个 $(1 \le i \le m)$，$p_i$ 表示该机器将位置 $1\sim p_i$ 上的所有字母打印了出来  
最后，在所有操作做完后，该机器又将整个字符串 $s$ 打印了出来

请求出字母表中每个字母在文章中出现了多少次

## 说明/提示

$1\le T \le 10^4$  
$2 \le  n \le 2 \cdot 10^5$  
$1 \le  m \le 2 \cdot 10^5$  
$\sum n,\sum m \le 2 \cdot 10^5$  
$1 \le p_i <n$

感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
3
4 2
abca
1 3
10 5
codeforces
2 8 3 2 9
26 10
qwertyuioplkjhgfdsazxcvbnm
20 10 1 2 3 5 10 5 9 4```

### 输出

```
4 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 9 4 5 3 0 0 0 0 0 0 0 0 9 0 0 3 1 0 0 0 0 0 0 0 
2 1 1 2 9 2 2 2 5 2 2 2 1 1 5 4 11 8 2 7 5 1 10 1 5 2```

【算法分类】差分

【题解分析与结论】
本题的核心在于如何高效统计每个字符在多次操作中的出现次数。题解中主要采用了差分、前缀和等技巧来优化时间复杂度。以下是对各题解的简要分析与评分：

1. **huayucaiji** (3星)
   - 思路：在每个位置维护前缀字母数量，并在每次操作时累加前缀。
   - 亮点：处理了同一位置多次操作的情况，并提醒开long long。
   - 缺点：代码略显冗长，且未充分利用差分优化。

2. **Priori_Incantatem** (4星)
   - 思路：使用二维前缀和统计每个位置的字母出现次数，并在每次操作时直接累加。
   - 亮点：代码简洁，时间复杂度优化较好。
   - 缺点：未处理同一位置多次操作的情况，且未提醒开long long。

3. **andyli** (5星)
   - 思路：利用差分数组统计每个位置字符被操作的次数，最后还原并累加结果。
   - 亮点：代码简洁高效，时间复杂度最优，且处理了同一位置多次操作的情况。
   - 缺点：无。

4. **riker_moon** (3星)
   - 思路：从后往前扫描，维护后缀和，并在遇到标记时累加。
   - 亮点：思路新颖，代码简洁。
   - 缺点：未处理同一位置多次操作的情况，且未提醒开long long。

5. **朝夕** (3星)
   - 思路：对操作数组排序，使用指针和净出现次数统计结果。
   - 亮点：时间复杂度优化较好。
   - 缺点：代码略显复杂，且未提醒开long long。

6. **ShineEternal** (3星)
   - 思路：使用前缀和统计每个位置的字母出现次数，并在每次操作时直接累加。
   - 亮点：代码简洁。
   - 缺点：未处理同一位置多次操作的情况，且未提醒开long long。

7. **Ludo** (4星)
   - 思路：利用差分数组统计每个位置字符被操作的次数，最后还原并累加结果。
   - 亮点：代码简洁高效，时间复杂度最优。
   - 缺点：无。

【最优题解】
1. **andyli** (5星)
   - 关键亮点：利用差分数组高效统计每个位置字符被操作的次数，代码简洁高效。
   - 核心代码：
     ```cpp
     for (int i = 1; i <= m; i++)
         cnt[1]++, cnt[A[i] + 1]--;
     for (int i = 1; i <= n; i++)
         cnt[i] += cnt[i - 1];
     for (int i = 1; i <= n; i++)
         ans[str[i] - 'a'] += cnt[i];
     ```

2. **Ludo** (4星)
   - 关键亮点：利用差分数组统计每个位置字符被操作的次数，代码简洁高效。
   - 核心代码：
     ```cpp
     for (int i = 1; i <= m; i++) {
         cf[l + 1]--;
         cf[1]++;
     }
     for (int i = 1; i <= n; i++) {
         sum += cf[i];
         ans[s[i] - 'a' + 1] += sum;
     }
     ```

【关键思路与技巧】
- **差分数组**：利用差分数组高效统计每个位置字符被操作的次数，最后通过累加还原结果。
- **前缀和**：使用前缀和快速计算每个位置的字母出现次数。

【拓展思路】
- 类似题目：可以利用差分或前缀和解决多次区间操作的问题，如区间加、区间查询等。

【推荐题目】
1. P3372 【模板】线段树 1
2. P3368 【模板】树状数组 1
3. P1908 逆序对

---
处理用时：47.30秒
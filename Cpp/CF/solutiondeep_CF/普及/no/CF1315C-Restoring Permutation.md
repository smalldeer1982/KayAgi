# 题目信息

# Restoring Permutation

## 题目描述

You are given a sequence $ b_1, b_2, \ldots, b_n $ . Find the lexicographically minimal permutation $ a_1, a_2, \ldots, a_{2n} $ such that $ b_i = \min(a_{2i-1}, a_{2i}) $ , or determine that it is impossible.

## 样例 #1

### 输入

```
5
1
1
2
4 1
3
4 1 3
4
2 3 4 5
5
1 5 7 2 8```

### 输出

```
1 2 
-1
4 5 1 2 3 6 
-1
1 3 5 6 7 9 2 4 8 10```

# AI分析结果

### 题目内容重写
# 恢复排列

## 题目描述

给定一个序列 $ b_1, b_2, \ldots, b_n $。找到字典序最小的排列 $ a_1, a_2, \ldots, a_{2n} $，使得 $ b_i = \min(a_{2i-1}, a_{2i}) $，或者确定它是不可能的。

## 样例 #1

### 输入

```
5
1
1
2
4 1
3
4 1 3
4
2 3 4 5
5
1 5 7 2 8```

### 输出

```
1 2 
-1
4 5 1 2 3 6 
-1
1 3 5 6 7 9 2 4 8 10```

### 算法分类
贪心

### 综合分析与结论
本题的核心是通过给定的序列 $b$ 构造一个字典序最小的排列 $a$，使得 $b_i = \min(a_{2i-1}, a_{2i})$。主要思路是贪心算法，通过将 $b_i$ 放在 $a_{2i-1}$ 的位置，并在 $a_{2i}$ 的位置放置比 $b_i$ 大且未被使用的最小值，以保证字典序最小。如果无法找到满足条件的数，则输出 $-1$。

### 所选题解
1. **作者：_6_awa (赞：7)**  
   - **星级：5**  
   - **关键亮点**：思路清晰，代码简洁，使用了标记数组来记录已使用的数，确保每个数只使用一次。  
   - **核心代码**：
     ```cpp
     for(int i = 2;i <= 2 * n;i += 2)
     {
         int r = 0;
         for(int j = a[i - 1];j <= 2 * n;j ++)
             if(b[j] == 0)//找到了
             {
                 b[j] = 1,r = 1,a[i] = j;//取最小值，标记
                 break ;
             }
         if(r == 0)//没找到输出-1
         {
             cout << "-1\n";p = 1;
             break ;
         }
     }
     ```

2. **作者：Kle1N (赞：1)**  
   - **星级：4**  
   - **关键亮点**：详细解释了为什么将 $b_i$ 放在 $a_{2i-1}$ 的位置是最优的，并通过枚举来找到 $a_{2i}$ 的值。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n<<1;i++){
         if(i&1){
             a[i]=b[(i+1)>>1];
         }
         else{
             t=1;
             for(int j=b[i>>1]+1;j<=n<<1;j++){
                 if(!f[j]){
                     f[j]=1;
                     t=0;
                     a[i]=j;
                     break;
                 }
             }
             if(t){
                 break;
             }
         }
     }
     ```

3. **作者：DengDuck (赞：0)**  
   - **星级：4**  
   - **关键亮点**：使用了 `set` 来维护未使用的数，通过 `upper_bound` 快速找到比 $b_i$ 大的最小数，时间复杂度为 $O(n \log n)$。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++)
     {
         auto t=s.upper_bound(a[i]);
         if(t==s.end())
         {
             flg=1;
             break;
         }
         b[2*i]=*t;
         s.erase(t);
     }
     ```

### 最优关键思路或技巧
1. **贪心策略**：将 $b_i$ 放在 $a_{2i-1}$ 的位置，并在 $a_{2i}$ 的位置放置比 $b_i$ 大且未被使用的最小值，以保证字典序最小。
2. **标记数组**：使用标记数组记录已使用的数，确保每个数只使用一次。
3. **STL优化**：使用 `set` 和 `upper_bound` 来快速找到比 $b_i$ 大的最小数，优化时间复杂度。

### 可拓展之处
类似的问题可以通过贪心策略和标记数组来解决，例如在构造排列时要求某些特定条件的最小字典序排列。

### 推荐题目
1. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

---
处理用时：34.02秒
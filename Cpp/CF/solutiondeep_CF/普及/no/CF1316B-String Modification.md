# 题目信息

# String Modification

## 题目描述

Vasya 有一个长度为 $n$ 的字符串 $s$。他想要对它进行以下的修改：
1. 选择一个整数 $k$ 且 $1\leq k\leq n$。
2. 让 $i$ 从 $1$ 循环到 $n - k + 1$，每一次反转 $s$ 在 $[i,i + k - 1]$ 范围中的子串。

比如说，字符串 $s$ 是 $\texttt{qwer}$ 且 $k = 2$，以下就是 $s$ 被修改的过程：

- $\texttt{qwer}$（原字符串）
- $\texttt{wqer}$（旋转了第一个长为 $2$ 的子串）
- $\texttt{weqr}$（旋转了第二个长为 $2$ 的子串）
- $\texttt{werq}$（旋转了最后一个长为 $2$ 的子串）

所以，$s$ 经过 $k = 2$ 的一系列变化后最终会变成 $\texttt{werq}$。

Vasya 希望选择一个 $k$,使得经过上述变化的字符串字典序最小。如果多个不同的 $k$ 都能满足要求，他想要取最小的一个。他正忙着参加 Felicity 2020，于是他叫你来帮他。

一个字符串 $a$ 比 $b$ 字典序更小需要以下条件中只有一个满足：

- $a$ 是 $b$ 的前缀，但 $a \ne b$;
- 在从左往右 $a$ 和 $b$ 第一个不同的位置，$a$ 上的字符在字母表中比 $b$ 上字符更靠前。

## 样例 #1

### 输入

```
6
4
abab
6
qwerty
5
aaaaa
6
alaska
9
lfpbavjsm
1
p```

### 输出

```
abab
1
ertyqw
3
aaaaa
1
aksala
6
avjsmbpfl
5
p
1```

# AI分析结果

【题目内容】
# 字符串修改

## 题目描述

Vasya 有一个长度为 $n$ 的字符串 $s$。他想要对它进行以下的修改：
1. 选择一个整数 $k$ 且 $1\leq k\leq n$。
2. 让 $i$ 从 $1$ 循环到 $n - k + 1$，每一次反转 $s$ 在 $[i,i + k - 1]$ 范围中的子串。

比如说，字符串 $s$ 是 $\texttt{qwer}$ 且 $k = 2$，以下就是 $s$ 被修改的过程：

- $\texttt{qwer}$（原字符串）
- $\texttt{wqer}$（旋转了第一个长为 $2$ 的子串）
- $\texttt{weqr}$（旋转了第二个长为 $2$ 的子串）
- $\texttt{werq}$（旋转了最后一个长为 $2$ 的子串）

所以，$s$ 经过 $k = 2$ 的一系列变化后最终会变成 $\texttt{werq}$。

Vasya 希望选择一个 $k$,使得经过上述变化的字符串字典序最小。如果多个不同的 $k$ 都能满足要求，他想要取最小的一个。他正忙着参加 Felicity 2020，于是他叫你来帮他。

一个字符串 $a$ 比 $b$ 字典序更小需要以下条件中只有一个满足：

- $a$ 是 $b$ 的前缀，但 $a \ne b$;
- 在从左往右 $a$ 和 $b$ 第一个不同的位置，$a$ 上的字符在字母表中比 $b$ 上字符更靠前。

## 样例 #1

### 输入

```
6
4
abab
6
qwerty
5
aaaaa
6
alaska
9
lfpbavjsm
1
p```

### 输出

```
abab
1
ertyqw
3
aaaaa
1
aksala
6
avjsmbpfl
5
p
1```

【算法分类】
字符串、模拟

【题解分析与结论】
本题的核心在于通过模拟字符串的翻转操作，找到使得最终字符串字典序最小的 $k$ 值。各题解的主要思路是通过观察规律，发现翻转操作可以简化为字符串的移动和部分反转，从而减少时间复杂度。

【精选题解】
1. **作者：Andrewzdm (赞：5)**
   - **星级：5**
   - **关键亮点：通过观察规律，发现翻转操作可以简化为字符串的移动和部分反转，时间复杂度为 $O(n^2)$。**
   - **代码核心思想：通过枚举 $k$，计算每个 $k$ 对应的最终字符串，并选择字典序最小的结果。**
   ```cpp
   for(int i = 1; i <= n; i++)
   {
       ans[i].k = i;
       string tmp = s;
       string st = tmp.substr(0, i - 1);
       if(i % 2 == n % 2)
           reverse(st.begin(), st.end());
       tmp += st;
       tmp.erase(0, i - 1);
       ans[i].str = tmp;
   }
   sort(ans + 1, ans + n + 1, cmp);
   ```

2. **作者：xxxr_2024 (赞：1)**
   - **星级：4**
   - **关键亮点：通过观察规律，发现翻转操作可以简化为字符串的移动和部分反转，时间复杂度为 $O(n^2)$。**
   - **代码核心思想：通过枚举 $k$，计算每个 $k$ 对应的最终字符串，并选择字典序最小的结果。**
   ```cpp
   for (int i = 1; i < n; i++)
   {
       string sa = s.substr(i), sb = s.substr(0, i);
       if (((n - i - 1) & 1) == 0)
           reverse(sb.begin(), sb.end());
       sa += sb;
       if (sa < ss)
           ss = sa, ans = i + 1;
   }
   ```

3. **作者：鹤箩芠 (赞：0)**
   - **星级：4**
   - **关键亮点：通过观察规律，发现翻转操作可以简化为字符串的移动和部分反转，时间复杂度为 $O(n^2)$。**
   - **代码核心思想：通过枚举 $k$，计算每个 $k$ 对应的最终字符串，并选择字典序最小的结果。**
   ```cpp
   for (int k = 1 ; k < n ; k ++) {
       pair <string , int> now ; 
       t = "" ;
       for (int i = k ; i < n ; i ++) t += s[i] ;
       if ((n - k) % 2) for (int i = k - 1 ; i >= 0 ; i --) t += s[i] ;
       else for (int i = 0 ; i <= k - 1 ; i ++) t += s[i] ;
       now= make_pair (t , k + 1) ;
       ans = min (ans , now) ; 
   }
   ```

【最优关键思路】
通过观察规律，发现翻转操作可以简化为字符串的移动和部分反转，从而减少时间复杂度。具体来说，对于每个 $k$，最终字符串的前 $n-k+1$ 个字符是原字符串的第 $k$ 个字符到末尾，而后 $k-1$ 个字符是原字符串的前 $k-1$ 个字符，根据翻转次数的奇偶性决定是否反转。

【拓展思路】
类似的问题可以通过观察操作规律，将复杂的操作简化为更简单的形式，从而优化时间复杂度。例如，字符串的旋转、反转等操作可以通过数学规律进行简化。

【推荐题目】
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3805 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)
3. [P5410 【模板】扩展KMP](https://www.luogu.com.cn/problem/P5410)

【个人心得】
通过观察规律，将复杂的操作简化为更简单的形式，是解决字符串问题的关键。在调试过程中，可以通过打印中间结果来验证规律的准确性。

---
处理用时：39.11秒
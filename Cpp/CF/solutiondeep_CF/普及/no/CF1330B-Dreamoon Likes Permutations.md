# 题目信息

# Dreamoon Likes Permutations

## 题目描述

一个长度为 $m$ 的数列被称为排列，当且仅当其中包含了 $1$ 到 $m$ 中所有整数恰好一次。$m$ 被称为这个排列的长度。

Dreamoon 得到了两个排列 $p_1, p_2$，长度分别为正整数 $l_1, l_2$。

现在 Dreamoon 要将这两个排列合并成一个长度为 $l_1 + l_2$ 的序列 $a$，其中开头的 $l_1$ 个数为排列 $p_1$，结尾的的 $l_2$ 个数为排列 $p_2$。

给出序列 $a$，你需要找到这两个排列 $p_1, p_2$。如果有多种可能的还原方式，你需要找到所有的答案。（注意，也有可能不存在可能的还原方式。）

## 说明/提示

在第一组数据中，两种可能的将 $a$ 分为两个排列的还原方式为 $\{1\} + \{4, 3, 2, 1\}$ 和 $\{1, 4, 3, 2\} + \{1\}$。

在第二组数据中，唯一一种可能的划分方式为：$\{ 2, 4, 1, 3\} + \{2, 1\}$。

在第三种数据中，不存在可能的还原方式。

## 样例 #1

### 输入

```
6
5
1 4 3 2 1
6
2 4 1 3 2 1
4
2 1 1 3
4
1 3 3 1
12
2 1 3 4 5 6 7 8 9 1 10 2
3
1 1 1```

### 输出

```
2
1 4
4 1
1
4 2
0
0
1
2 10
0```

# AI分析结果

### 题目内容
# Dreamoon 喜欢排列

## 题目描述

一个长度为 $m$ 的数列被称为排列，当且仅当其中包含了 $1$ 到 $m$ 中所有整数恰好一次。$m$ 被称为这个排列的长度。

Dreamoon 得到了两个排列 $p_1, p_2$，长度分别为正整数 $l_1, l_2$。

现在 Dreamoon 要将这两个排列合并成一个长度为 $l_1 + l_2$ 的序列 $a$，其中开头的 $l_1$ 个数为排列 $p_1$，结尾的 $l_2$ 个数为排列 $p_2$。

给出序列 $a$，你需要找到这两个排列 $p_1, p_2$。如果有多种可能的还原方式，你需要找到所有的答案。（注意，也有可能不存在可能的还原方式。）

## 说明/提示

在第一组数据中，两种可能的将 $a$ 分为两个排列的还原方式为 $\{1\} + \{4, 3, 2, 1\}$ 和 $\{1, 4, 3, 2\} + \{1\}$。

在第二组数据中，唯一一种可能的划分方式为：$\{ 2, 4, 1, 3\} + \{2, 1\}$。

在第三种数据中，不存在可能的还原方式。

## 样例 #1

### 输入

```
6
5
1 4 3 2 1
6
2 4 1 3 2 1
4
2 1 1 3
4
1 3 3 1
12
2 1 3 4 5 6 7 8 9 1 10 2
3
1 1 1```

### 输出

```
2
1 4
4 1
1
4 2
0
0
1
2 10
0```

### 算法分类
枚举

### 题解分析与结论

该题的核心思路是通过枚举可能的划分点，检查前后两部分是否都是排列。大部分题解都采用了这一思路，但在具体实现上有所不同。以下是对各题解的简要分析与评分：

1. **Blunt_Feeling**（4星）
   - **关键亮点**：通过最大值来确定可能的划分点，减少了枚举的次数。使用 `map` 来检查排列的合法性，代码简洁且易于理解。
   - **核心代码**：
     ```cpp
     bool check(int x, int y) {
         map<int,int> mp1,mp2;
         For(i,1,x) mp1[a[i]]++;
         For(i,x+1,x+y) mp2[a[i]]++;
         For(i,1,x) if(mp1[i]!=1) return false;
         For(i,1,y) if(mp2[i]!=1) return false;
         return true;
     }
     ```

2. **do_while_true**（4星）
   - **关键亮点**：通过前后分别统计合法位置，然后对比来确定划分点。使用 `vis1` 和 `vis2` 数组来记录前后部分的合法性，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) {
         vis1[a[i]]++;
         vis2[a[i]]--;
         if(vis1[a[i]]==2&&cnt1>=a[i]) cnt1=a[i]-1;
         if(vis2[a[i]]==0&&cnt2>=a[i]) cnt2=a[i]-1;
         while(vis1[cnt1+1]==1) cnt1++;
         while(vis2[cnt2+1]==1) cnt2++;
         if(cnt1==i&&cnt2==n-i) ans[++len]=i;
     }
     ```

3. **QiFeng233**（4星）
   - **关键亮点**：利用排列的性质（元素互不相同且和为等差数列求和）来检查合法性。通过预处理 `dif1` 和 `dif2` 数组来快速判断前后部分的合法性。
   - **核心代码**：
     ```cpp
     for(int i=1;i<n;++i){
         ll s1=s[i],s2=s[n]-s[i],l1=i,l2=n-i;
         if(2*s1==l1*(l1+1)&&2*s2==l2*(l2+1)&&dif1[i]==l1&&dif2[i+1]==l2&&l1!=0&&l2!=0){
             ans[++k]=make_pair(l1,l2);
         }
     }
     ```

### 最优关键思路与技巧
- **利用最大值减少枚举次数**：通过找到序列中的最大值，可以快速确定可能的划分点，减少不必要的枚举。
- **排列的合法性检查**：使用 `map` 或 `vis` 数组来记录元素的出现次数，确保每个元素只出现一次，且元素范围符合排列的要求。
- **预处理优化**：通过预处理前后部分的和或元素个数，可以在枚举时快速判断合法性，减少时间复杂度。

### 可拓展之处
- **类似题目**：可以扩展到多个排列的合并问题，或者排列的划分问题，如将序列划分为多个排列。
- **优化思路**：可以进一步优化枚举的顺序，或者利用更多的排列性质来减少检查的次数。

### 推荐题目
1. [P1156 排列](https://www.luogu.com.cn/problem/P1156)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

### 个人心得
- **调试经历**：在检查排列合法性时，容易忽略元素范围的问题，导致错误。需要仔细检查每个元素的出现次数和范围。
- **顿悟感想**：通过最大值来确定划分点，可以大大减少枚举的次数，提高算法的效率。

---
处理用时：43.02秒
# 题目信息

# Orac and Models

## 题目描述

给出一个长度为 $n$ 的序列 $a$，并令 $s$ 为 $a$ 的子序列，$pos_i$ 为 $s_i$ 在原序列里的位置  

当且仅当 $s_j<s_{j+1}$ 且 $pos_j \mid pos_{j+1}$ 时，序列 $s$ 是美丽的



你需要求出序列 $a$ 的最长的美丽子序列的长度

## 说明/提示

$1 \le T \le 100$  

$1 \le n \le 10^5$，$1 \le a_i \le 10^9$



感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
4
4
5 3 4 6
7
1 4 2 3 6 4 9
5
5 4 3 2 1
1
9```

### 输出

```
2
3
1
1```

# AI分析结果

### 题目内容重写

#### Orac and Models

##### 题目描述

给出一个长度为 $n$ 的序列 $a$，并令 $s$ 为 $a$ 的子序列，$pos_i$ 为 $s_i$ 在原序列里的位置。

当且仅当 $s_j < s_{j+1}$ 且 $pos_j \mid pos_{j+1}$ 时，序列 $s$ 是美丽的。

你需要求出序列 $a$ 的最长的美丽子序列的长度。

##### 说明/提示

$1 \le T \le 100$  
$1 \le n \le 10^5$，$1 \le a_i \le 10^9$

##### 样例 #1

###### 输入

```
4
4
5 3 4 6
7
1 4 2 3 6 4 9
5
5 4 3 2 1
1
9
```

###### 输出

```
2
3
1
1
```

### 算法分类

动态规划

### 题解综合分析与结论

本题的核心是求一个序列的最长美丽子序列，其中美丽子序列的定义是子序列中的元素严格递增，并且前一个元素的位置是后一个元素位置的约数。这可以通过动态规划来解决，状态转移方程通常为：

$$
f_i = \max\limits_{j \mid i, a_j < a_i} \{f_j + 1\}
$$

其中 $f_i$ 表示以第 $i$ 个元素结尾的最长美丽子序列的长度。

### 所选高星题解

#### 题解1：作者：Caro23333 (赞：4)

##### 星级与关键亮点

- **星级**：5星
- **关键亮点**：清晰地定义了状态转移方程，并提供了两种时间复杂度不同的实现方法（枚举因数和枚举倍数），代码简洁且易于理解。

##### 核心代码

```cpp
for(int i = 1; i <= n; i++) 
    for(int j = i*2; j <= n; j += i)
        if(a[i] < a[j])
            f[j] = max(f[j], f[i] + 1);
```

##### 核心实现思想

通过枚举每个数的倍数来进行状态转移，时间复杂度为 $O(n \log n)$。

#### 题解2：作者：Priori_Incantatem (赞：3)

##### 星级与关键亮点

- **星级**：4星
- **关键亮点**：通过枚举因数来进行状态转移，时间复杂度为 $O(n \sqrt{n})$，代码实现清晰。

##### 核心代码

```cpp
for(int j = 1; j*j <= i; ++j) {
    if(i % j) continue;
    if(s[j] < s[i]) f[i] = max(f[i], f[j] + 1);
    if(j != i/j && s[i/j] < s[i]) f[i] = max(f[i], f[i/j] + 1);
}
```

##### 核心实现思想

通过枚举每个数的因数来进行状态转移，时间复杂度为 $O(n \sqrt{n})$。

#### 题解3：作者：王熙文 (赞：2)

##### 星级与关键亮点

- **星级**：4星
- **关键亮点**：通过枚举倍数来进行状态转移，代码简洁且易于理解。

##### 核心代码

```cpp
for(int i = 1; i <= (n>>1); ++i) {
    for(int j = (i<<1); j <= n; j += i) {
        if(a[i] < a[j]) {
            dp[j] = max(dp[j], dp[i] + 1);
            ans = max(ans, dp[j]);
        }
    }
}
```

##### 核心实现思想

通过枚举每个数的倍数来进行状态转移，时间复杂度为 $O(n \log n)$。

### 最优关键思路或技巧

- **枚举倍数**：通过枚举每个数的倍数来进行状态转移，时间复杂度为 $O(n \log n)$，适合大规模数据。
- **枚举因数**：通过枚举每个数的因数来进行状态转移，时间复杂度为 $O(n \sqrt{n})$，适合小规模数据。

### 可拓展之处

- **类似题目**：可以扩展到其他需要满足特定条件的子序列问题，如最长上升子序列、最长公共子序列等。
- **优化思路**：可以考虑使用更高效的数据结构或算法来进一步优化时间复杂度。

### 推荐相似题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：30.49秒
# 题目信息

# Mixing Water

## 题目描述

有两种无限的水源：

- 温度为 $h$ 的热水；
- 温度为 $c$ 的冷水（ $c \lt h$ ）。

您要执行以下交替移动的程序：

1. 取**一**杯**热**水，倒入一个无限深的桶中；
2. 取**一**杯**冷**水，倒入无限深的木桶中；
3. 取**一**杯**热**水 $\dots$ 
4. 依此类推 $\dots$

**注意，一定要从一杯热水开始**。

木桶最初是空的。你必须**至少倒一杯**到桶里。木桶中的水温是倒入的杯子温度的平均值。

您希望水温尽可能接近 $t$ 。因此，如果木桶中的温度是 $t_b$ ，那么 $t_b$ 和 $t$ （ $|t_b - t|$ ）的**绝对差**应该尽可能小。

你应该往桶里倒多少杯水，才能使桶里的温度尽可能接近 $t$ ？如果有多个绝对差最小的答案，则打印其中最小的答案。

1. 每个“一杯”的大小相同。
1. 桶一开始时为空。
1. 至少要倒一次水。
1. 第一杯永远是热水。

##### Translated By [Lj_zjl0](https://www.luogu.com.cn/user/311615) & Deepl

## 样例 #1

### 输入

```
3
30 10 20
41 15 30
18 13 18```

### 输出

```
2
7
1```

# AI分析结果

### 题目内容重写
# 混合水

## 题目描述

有两种无限的水源：

- 温度为 $h$ 的热水；
- 温度为 $c$ 的冷水（ $c \lt h$ ）。

您要执行以下交替移动的程序：

1. 取**一**杯**热**水，倒入一个无限深的桶中；
2. 取**一**杯**冷**水，倒入无限深的木桶中；
3. 取**一**杯**热**水 $\dots$ 
4. 依此类推 $\dots$

**注意，一定要从一杯热水开始**。

木桶最初是空的。你必须**至少倒一杯**到桶里。木桶中的水温是倒入的杯子温度的平均值。

您希望水温尽可能接近 $t$ 。因此，如果木桶中的温度是 $t_b$ ，那么 $t_b$ 和 $t$ （ $|t_b - t|$ ）的**绝对差**应该尽可能小。

你应该往桶里倒多少杯水，才能使桶里的温度尽可能接近 $t$ ？如果有多个绝对差最小的答案，则打印其中最小的答案。

1. 每个“一杯”的大小相同。
1. 桶一开始时为空。
1. 至少要倒一次水。
1. 第一杯永远是热水。

### 算法分类
数学

### 题解分析与结论
本题的核心是通过数学推导找到使桶中水温最接近目标温度 $t$ 的倒水次数。题解主要集中在以下思路：
1. **特殊情况处理**：当 $t = h$ 时，直接输出1；当 $t \leq \frac{h+c}{2}$ 时，输出2。
2. **数学公式推导**：当 $t > \frac{h+c}{2}$ 时，通过公式推导出倒水次数 $x$，并比较 $x$ 和 $x+1$ 的结果，选择最接近 $t$ 的倒水次数。
3. **避免浮点精度问题**：通过将除法转化为乘法比较，避免浮点运算带来的精度误差。

### 所选高分题解
#### 题解1：作者：fighter (赞：7)
- **星级**：5星
- **关键亮点**：通过数学公式推导出倒水次数，并巧妙地将除法转化为乘法比较，避免了浮点精度问题。代码简洁且高效。
- **核心代码**：
```cpp
ll x = floor(1.0*(c-a)/(a+b-2*c));
long double ans1 = calc(x), ans2 = calc(x+1);
ll x1 = ((x+1)*a+x*b-c*(2*x+1))*(2*x+3), x2 = (-(x+2)*a-(x+1)*b+(2*x+3)*c)*(2*x+1);
if(x1 <= x2){
    printf("%d\n", 2*x+1);
}
else printf("%d\n", 2*x+3);
```
- **实现思想**：通过公式推导出倒水次数 $x$，然后比较 $x$ 和 $x+1$ 的结果，选择最接近 $t$ 的倒水次数。

#### 题解2：作者：45dinо (赞：3)
- **星级**：4星
- **关键亮点**：使用二分法寻找最优倒水次数，避免了复杂的数学推导，思路清晰且易于理解。
- **核心代码**：
```cpp
int a1,b1;
double fa,fb;
if(int(floor(n))%2==1){
    a1=floor(n);
    b1=floor(n)+2;	
}
else{
    a1=floor(n)-1;
    b1=floor(n)+1;
}
fa=fabs((a-b)/a1/2.0+lb-t);
fb=fabs((a-b)/b1/2.0+lb-t);
if(fa<=fb) cout<<a1<<endl;
else cout<<b1<<endl;
```
- **实现思想**：通过二分法找到最优的倒水次数，然后比较相邻的两个奇数倒水次数，选择最接近 $t$ 的结果。

### 最优关键思路
1. **数学公式推导**：通过公式推导出倒水次数，避免了复杂的计算和浮点精度问题。
2. **二分法**：使用二分法寻找最优倒水次数，思路清晰且易于实现。

### 拓展与举一反三
类似的问题可以通过数学推导或二分法来解决，特别是在涉及平均值或比例的问题中。例如，寻找最优的混合比例或最优的分配方案。

### 推荐题目
1. [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

### 个人心得
- **调试经历**：在处理浮点精度问题时，将除法转化为乘法比较是一个有效的解决方案。
- **顿悟感想**：通过数学推导可以简化问题，避免复杂的计算和精度问题。

---
处理用时：32.82秒
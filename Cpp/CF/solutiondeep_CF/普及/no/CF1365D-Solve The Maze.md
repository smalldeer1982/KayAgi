# 题目信息

# Solve The Maze

## 题目描述

给出一个 $n$ 行 $m$ 列的网格，每个格子上有四种情况：
- `.` 表示这个格子是空地。
- `#` 表示这个格子是墙。
- `G` 表示这个格子是好人。
- `B` 表示这个格子是坏人。

`G`，`B`格子都可以认为是空地。

你需要判断能否 `.` 格子上放任意数量的墙，保证所有好人可以通过在空地间移动到达点 $(n,m)$ 而所有坏人都不行。

## 样例 #1

### 输入

```
6
1 1
.
1 2
G.
2 2
#B
G.
2 3
G.#
B#.
3 3
#B.
#..
GG.
2 2
#B
B.```

### 输出

```
Yes
Yes
No
No
Yes
Yes```

# AI分析结果

### 题目内容重写
给出一个 $n$ 行 $m$ 列的网格，每个格子上有四种情况：
- `.` 表示这个格子是空地。
- `#` 表示这个格子是墙。
- `G` 表示这个格子是好人。
- `B` 表示这个格子是坏人。

`G`，`B`格子都可以认为是空地。

你需要判断能否在 `.` 格子上放任意数量的墙，保证所有好人可以通过在空地间移动到达点 $(n,m)$ 而所有坏人都不行。

### 算法分类
搜索

### 题解分析与结论
本题的核心思路是通过搜索（BFS或DFS）来判断好人和坏人是否能到达终点。大多数题解都采用了以下步骤：
1. **封锁坏人**：将每个坏人周围的空地（`.`) 设置为墙（`#`），以防止坏人移动到终点。
2. **搜索好人**：从终点 $(n,m)$ 开始进行 BFS 或 DFS，标记所有可以到达的格子。
3. **判断结果**：检查所有好人是否都被标记为可以到达终点，且所有坏人都未被标记。

### 精选题解
#### 题解1：Refined_heart (4星)
**关键亮点**：
- 思路清晰，代码结构简洁。
- 使用了 BFS 从终点开始搜索，确保所有好人能到达终点。
- 在封锁坏人时，直接将其周围的空地设置为墙，逻辑简单明了。

**核心代码**：
```cpp
void bfs(int x,int y){
    vis[x][y]=1;
    for(int i=0;i<4;++i){
        int nx=x+dx[i],ny=y+dy[i];
        if(vis[nx][ny]||nx<1||ny<1||nx>n||ny>m||a[nx][ny]==1)continue;
        bfs(nx,ny);
    }
}
```

#### 题解2：Eason_cyx (4星)
**关键亮点**：
- 使用了贪心策略，优先封锁坏人周围的空地。
- 代码实现较为规范，使用了队列进行 BFS。
- 在搜索时，特别注意了终点是否为墙的情况。

**核心代码**：
```cpp
bool BFS() {
    _rep(i,1,n) _rep(j,1,m) {
        if(a[i][j] != 'B') continue;
        _for(k,0,4) {
            int nx = i + dx[k],ny = j + dy[k];
            if(a[nx][ny] == '.') a[nx][ny] = '#';
        }
    }
    memset(vis,false,sizeof vis);
    while(!q.empty()) q.pop();
    if(a[n][m] != '#') {
        q.push({n,m});
    }
    vis[n][m] = true;
    while(!q.empty()) {
        node u = q.front(); q.pop();
        int x = u.x,y = u.y;
        _for(i,0,4) {
            int nx = x + dx[i],ny = y + dy[i];
            if(!Check(nx,ny)) continue;
            vis[nx][ny] = true;
            q.push({nx,ny});
        }
    }
    _rep(i,1,n) _rep(j,1,m)
        if((a[i][j] == 'G' && !vis[i][j]) || (a[i][j] == 'B' && vis[i][j])) return false;
    return true;    
}
```

#### 题解3：Lemon_zqp (4星)
**关键亮点**：
- 使用了 DFS 进行搜索，代码实现较为简洁。
- 在封锁坏人时，特别注意了边界条件和原有墙的情况。
- 代码注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int x, int y) {
    if(x<1 || x>n || y<1 | y>m) return ;
    if(mp[x][y]=='#') return ;
    if(mp[x][y]=='G' || mp[x][y]=='B') tag[x][y]=1;
    for(int i=0; i<4; i++) {
        if(!vis[x+xx[i]][y+yy[i]]) {
            vis[x+xx[i]][y+yy[i]]=1;
            dfs(x+xx[i],y+yy[i]);
        }
    }
}
```

### 最优关键思路
1. **封锁坏人**：通过将坏人周围的空地设置为墙，确保坏人无法移动。
2. **搜索好人**：从终点开始进行 BFS 或 DFS，标记所有可以到达的格子，确保所有好人能到达终点。
3. **边界条件**：特别注意终点是否为墙，以及封锁坏人时是否覆盖了原有墙或好人。

### 可拓展之处
本题可以拓展到更复杂的迷宫问题，如多个终点、动态变化的墙等。类似的题目可以通过类似的搜索策略解决。

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

---
处理用时：40.38秒
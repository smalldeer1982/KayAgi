# 题目信息

# Neighbor Grid

## 题目描述

### 题意：

给你一个 $n$ 行 $m$ 列的矩阵，要求你让这个矩阵是“完美”的。

“完美”的定义如下：

1. 若当前的格子里是一个正整数 $k$，那么与这个网格相邻（有公共边）的 $k$ 个格子也必须有一个正整数。

2. 若当前的格子里是 `0` ，那么不受上述的限制。

你可以对任意的一个格子加上 `1` ，次数不受限制。

对于每一组数据：

如果可以做到“完美”，请输出 `YES` 之后，将修改过的矩阵输出。

否则只输出一行 `NO` 。

## 说明/提示

$1\le T\le 5000$。

$2\le n,m\le 300$。

$n \times m \le 10^5$

对于每一个位置上的数字 $a_{(i,j)}$：
$0 \le a_{(i,j)} \le 10^9$。

------

+ Translate by black_trees

## 样例 #1

### 输入

```
5
3 4
0 0 0 0
0 1 0 0
0 0 0 0
2 2
3 0
0 0
2 2
0 0
0 0
2 3
0 0 0
0 4 0
4 4
0 0 0 0
0 2 0 1
0 0 0 0
0 0 0 0```

### 输出

```
YES
0 0 0 0
0 1 1 0
0 0 0 0
NO
YES
0 0
0 0
NO
YES
0 1 0 0
1 4 2 1
0 2 0 0
1 3 1 0```

# AI分析结果

### 题目内容重写
# 邻居网格

## 题目描述

### 题意：

给你一个 $n$ 行 $m$ 列的矩阵，要求你让这个矩阵是“完美”的。

“完美”的定义如下：

1. 若当前的格子里是一个正整数 $k$，那么与这个网格相邻（有公共边）的 $k$ 个格子也必须有一个正整数。

2. 若当前的格子里是 `0` ，那么不受上述的限制。

你可以对任意的一个格子加上 `1` ，次数不受限制。

对于每一组数据：

如果可以做到“完美”，请输出 `YES` 之后，将修改过的矩阵输出。

否则只输出一行 `NO` 。

## 说明/提示

$1\le T\le 5000$。

$2\le n,m\le 300$。

$n \times m \le 10^5$

对于每一个位置上的数字 $a_{(i,j)}$：
$0 \le a_{(i,j)} \le 10^9$。

------

+ Translate by black_trees

## 样例 #1

### 输入

```
5
3 4
0 0 0 0
0 1 0 0
0 0 0 0
2 2
3 0
0 0
2 2
0 0
0 0
2 3
0 0 0
0 4 0
4 4
0 0 0 0
0 2 0 1
0 0 0 0
0 0 0 0```

### 输出

```
YES
0 0 0 0
0 1 1 0
0 0 0 0
NO
YES
0 0
0 0
NO
YES
0 1 0 0
1 4 2 1
0 2 0 0
1 3 1 0```

### 算法分类
构造

### 题解分析与结论
本题的核心思路是通过构造一个“完美”矩阵，使得每个格子的值不超过其相邻格子的数量。所有题解都采用了类似的思路，即根据格子的位置（角落、边缘、中间）来确定其最大可能值，并判断输入矩阵是否满足这些条件。如果满足，则输出一个填满的矩阵；否则输出 `NO`。

### 精选题解
1. **作者：sto__Liyhzh__orz (赞：2)**
   - **星级：4**
   - **关键亮点**：代码简洁，逻辑清晰，直接根据格子的位置判断并填充矩阵。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++)
     {
         for(int j=1;j<=m;j++)
         {
             if((i==1 || i==n) && (j==1 || j==m)) a[i][j]=2;
             if((i==1 || i==n) && (j>1 && j<m)) a[i][j]=3;
             if((j==1 || j==m) && (i>1 && i<n)) a[i][j]=3;
             if(j>1 && j<m && i>1 && i<n) a[i][j]=4;
         }
     }
     ```

2. **作者：Zhuluoan (赞：0)**
   - **星级：4**
   - **关键亮点**：详细解释了判断条件和构造过程，代码可读性强。
   - **核心代码**：
     ```cpp
     if((i==1||i==n)&&(j==1||j==m)&&a[i][j]>2) flag=1;
     if((i==1||i==n)&&(j>1&&j<m)&&a[i][j]>3) flag=1;
     if((j==1||j==m)&&(i>1&&i<n)&&a[i][j]>3) flag=1;
     if(j>1&&j<m&&i>1&&i<n&&a[i][j]>4) flag=1;
     ```

3. **作者：SpeedStar (赞：0)**
   - **星级：4**
   - **关键亮点**：代码结构清晰，逻辑严谨，直接根据格子的位置判断并填充矩阵。
   - **核心代码**：
     ```cpp
     a[0][0] = a[0][m - 1] = a[n - 1][0] = a[n - 1][m - 1] = 2;
     for(int j = 1; j < m - 1; ++j) a[0][j] = 3;
     for(int j = 1; j < m - 1; ++j) a[n - 1][j] = 3;
     for(int i = 1; i < n - 1; ++i) a[i][0] = 3;
     for(int i = 1; i < n - 1; ++i) a[i][m - 1] = 3;
     for(int i = 1; i < n - 1; ++i) {
         for(int j = 1; j < m - 1; ++j) {
             a[i][j] = 4;
         }
     }
     ```

### 最优关键思路
1. **位置分类**：根据格子的位置（角落、边缘、中间）确定其最大可能值。
2. **判断条件**：输入矩阵的每个格子的值必须不超过其最大可能值。
3. **构造矩阵**：如果满足条件，则输出一个填满的矩阵，否则输出 `NO`。

### 拓展思路
类似的问题可以通过位置分类和构造矩阵的思路来解决，例如在棋盘或网格上的问题。

### 推荐题目
1. [P1379 八数码问题](https://www.luogu.com.cn/problem/P1379)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

---
处理用时：42.44秒
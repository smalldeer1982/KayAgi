# 题目信息

# Good Subarrays

## 题目描述

有一个数组$a_1,a_2,\dots,a_n$，满足$\forall i \in[1,n]$ 有 $0 \le a_i \le 9$。

我们称一个子数组 $a_l,a_{l+1},a_{l+2},\dots,a_{r-1},a_r$ 是“好”的，当且仅当这个子数组中所有元素的和等于它的长度（即 $\sum_{i=l}^r a_i = r-l+1$ ）。

现在要你计算出数组 $a$ 中所有“好”的子数组的数量。

## 说明/提示

### 样例解释

第一组数据中， $a_{1\dots1},a_{2\dots3},a_{1\dots3}$ 是原数组的“好”子数组；

第二组数据中， $a_{1\dots1},a_{2\dots2},a_{1\dots2},a_{4\dots4},a_{5\dots5},a_{4\dots5}$ 这$6$个子数组是原数组的“好”子数组；

第三组数据中，只有 $a_{2\dots6}$ 是原数组的“好”子数组。


$1\le t\le 1000,1\le n\le 10^5,1\le \sum n \le 10^5$

## 样例 #1

### 输入

```
3
3
120
5
11011
6
600005```

### 输出

```
3
6
1```

# AI分析结果

### 题目内容重写
# Good Subarrays

## 题目描述

有一个数组$a_1,a_2,\dots,a_n$，满足$\forall i \in[1,n]$ 有 $0 \le a_i \le 9$。

我们称一个子数组 $a_l,a_{l+1},a_{l+2},\dots,a_{r-1},a_r$ 是“好”的，当且仅当这个子数组中所有元素的和等于它的长度（即 $\sum_{i=l}^r a_i = r-l+1$ ）。

现在要你计算出数组 $a$ 中所有“好”的子数组的数量。

## 说明/提示

### 样例解释

第一组数据中， $a_{1\dots1},a_{2\dots3},a_{1\dots3}$ 是原数组的“好”子数组；

第二组数据中， $a_{1\dots1},a_{2\dots2},a_{1\dots2},a_{4\dots4},a_{5\dots5},a_{4\dots5}$ 这$6$个子数组是原数组的“好”子数组；

第三组数据中，只有 $a_{2\dots6}$ 是原数组的“好”子数组。


$1\le t\le 1000,1\le n\le 10^5,1\le \sum n \le 10^5$

## 样例 #1

### 输入

```
3
3
120
5
11011
6
600005```

### 输出

```
3
6
1```

### 算法分类
前缀和

### 题解分析与结论

题目要求计算数组中所有满足子数组和等于子数组长度的子数组数量。核心思路是通过前缀和和哈希表（或桶）来优化计算。具体来说，通过将问题转化为寻找满足 $Sum_j - j = Sum_{i-1} - (i-1)$ 的 $(i,j)$ 对，然后利用哈希表记录每个 $Sum_i - i$ 的出现次数，从而快速统计符合条件的子数组数量。

### 精选题解

#### 1. 作者：Orange_qwq (赞：13)
- **星级**: 5
- **关键亮点**: 使用前缀和和哈希表（`map`）来记录 $Sum_i - i$ 的出现次数，思路清晰，代码简洁。
- **代码核心**:
  ```cpp
  for (int i = 1; i <= n; ++i) {
      cin >> c;
      s[i] = s[i - 1] + c - '0';
      ans += mp[s[i] - i] ++;
  }
  ```

#### 2. 作者：SpeedStar (赞：11)
- **星级**: 4
- **关键亮点**: 将问题转化为统计和为0的子数组个数，使用哈希表记录前缀和的出现次数，思路清晰。
- **代码核心**:
  ```cpp
  for (int i = 0; i < n; ++i) {
      sum += v[i];
      if (sum == 0) ans++;
      ans += mp[sum];
      mp[sum]++;
  }
  ```

#### 3. 作者：Sya_Resory (赞：0)
- **星级**: 4
- **关键亮点**: 使用前缀和和桶计数，避免使用 `map`，通过偏移量处理负下标，代码简洁高效。
- **代码核心**:
  ```cpp
  for(int i = 1;i <= n;i ++) {
      scanf("%1d",a + i);
      sum += a[i];
      int delta = sum - i + n;
      ans += cnt[delta] ++;
      if(sum == i) ans ++;
  }
  ```

### 最优关键思路
1. **前缀和与哈希表结合**：通过前缀和和哈希表记录 $Sum_i - i$ 的出现次数，可以高效地统计符合条件的子数组数量。
2. **偏移量处理负下标**：通过将 $Sum_i - i$ 加上一个偏移量（如 $n$），可以避免负下标问题，同时减少对 `map` 的依赖。

### 可拓展之处
- **类似问题**：可以扩展到其他需要统计子数组和满足特定条件的问题，如子数组和等于某个固定值、子数组和的最大值等。
- **优化思路**：在处理大规模数据时，可以考虑使用更高效的哈希表实现，或者进一步优化前缀和的计算过程。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P3131 [USACO16JAN]Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131)
3. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)

---
处理用时：37.80秒
# 题目信息

# RPG Protagonist

## 题目描述

有两个人去买武器，两个人的最大承重分别为 $a,b$，武器店有剑和战斧，有 $c_1$ 把剑，每一把剑的重量为 $w_1$，有 $c_2$ 把战斧，每一把战斧的重量为 $w_2$。两个人购买的武器总重量不能超过自生的最大承重，两个人购买的剑的总数不能超过 $c_1$，购买战斧的总数不能超过 $c_2$，求在满足条件下两人能买到的武器总数的最大值。

本题多测，$1\leqslant a,b,w_1,w_2\leqslant10^9,1\leqslant c_1,c_2\leqslant 2\times 10^5,1\leqslant \sum c_1,\sum c_2\leqslant 2\times 10^5$。

## 样例 #1

### 输入

```
3
33 27
6 10
5 6
100 200
10 10
5 5
1 19
1 3
19 5```

### 输出

```
11
20
3```

# AI分析结果

### 中文题目重写

#### 题目描述

有两个人去买武器，两个人的最大承重分别为 $a,b$，武器店有剑和战斧，有 $c_1$ 把剑，每一把剑的重量为 $w_1$，有 $c_2$ 把战斧，每一把战斧的重量为 $w_2$。两个人购买的武器总重量不能超过自生的最大承重，两个人购买的剑的总数不能超过 $c_1$，购买战斧的总数不能超过 $c_2$，求在满足条件下两人能买到的武器总数的最大值。

本题多测，$1\leqslant a,b,w_1,w_2\leqslant10^9,1\leqslant c_1,c_2\leqslant 2\times 10^5,1\leqslant \sum c_1,\sum c_2\leqslant 2\times 10^5$。

#### 样例 #1

##### 输入

```
3
33 27
6 10
5 6
100 200
10 10
5 5
1 19
1 3
19 5
```

##### 输出

```
11
20
3
```

### 算法分类
贪心

### 题解分析与结论

本题的核心在于如何在两个人的承重限制下，最大化他们能购买的武器数量。由于只有两种武器（剑和战斧），且每种武器的数量有限，我们可以通过枚举其中一个人购买的剑的数量，然后计算另一个人能购买的武器数量，最终取最大值。

#### 题解对比

1. **AlanSP 的题解**：
   - **思路**：枚举第一个人购买的剑的数量，然后计算第二个人能购买的武器数量。
   - **难点**：需要处理两个背包的承重限制，并且要确保不超出武器数量的限制。
   - **优化**：通过先确定剑和战斧的重量关系，减少枚举次数。
   - **评分**：4星
   - **关键亮点**：通过贪心策略，先选择重量较小的武器，确保最大化武器数量。

2. **ZigZagKmp 的题解**：
   - **思路**：同样枚举第一个人购买的剑的数量，然后计算第二个人能购买的武器数量。
   - **难点**：处理两个背包的承重限制，并确保不超出武器数量的限制。
   - **优化**：通过贪心策略，先选择重量较小的武器，确保最大化武器数量。
   - **评分**：4星
   - **关键亮点**：代码结构清晰，逻辑严谨，易于理解。

3. **引领天下 的题解**：
   - **思路**：枚举第一个人购买的剑的数量，然后计算第二个人能购买的武器数量。
   - **难点**：处理两个背包的承重限制，并确保不超出武器数量的限制。
   - **优化**：通过贪心策略，先选择重量较小的武器，确保最大化武器数量。
   - **评分**：3星
   - **关键亮点**：代码简洁，但缺少一些优化和解释。

#### 最优关键思路

- **贪心策略**：先选择重量较小的武器，确保最大化武器数量。
- **枚举优化**：通过先确定剑和战斧的重量关系，减少枚举次数。

#### 可拓展之处

- **类似问题**：多重背包问题、资源分配问题。
- **算法套路**：贪心策略在资源分配问题中的应用。

#### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

#### 个人心得摘录

- **AlanSP**：通过先确定剑和战斧的重量关系，减少枚举次数，提高效率。
- **ZigZagKmp**：代码结构清晰，逻辑严谨，易于理解。
- **引领天下**：代码简洁，但缺少一些优化和解释。

### 核心代码片段

#### AlanSP 的代码

```cpp
for(int i=0;i<=s&&i*vs<=n;i++)
{
    int now=vs*i,res=i;
    int bn=n,bm=m,bw=w;
    n-=now;
    res+=min(n/vw,w); 
    w-=min(n/vw,w);
    res+=min(m/vs,s-i);
    m-=min(m/vs,s-i)*vs;
    res+=min(m/vw,w);
    ans=max(ans,res);
    n=bn,m=bm,w=bw;
}
```

#### ZigZagKmp 的代码

```cpp
int calc(int x){
    if(x*s>p)return 0;
    int ret=x;p-=x*s;
    int yy=min(cnts-x,f/s);
    ret+=yy;f-=yy*s;
    ret+=min(cntw,p/w+f/w);
    p+=x*s;f+=yy*s;
    return ret;
}
```

#### 引领天下 的代码

```cpp
for(int i=0;i<=cnts;i++){
    if(i*s>p)break;
    int cnt=0,ts=cnts,tw=cntw;
    cnt+=i,ts-=i;
    int tw1=min((p-i*s)/w,tw);
    cnt+=tw1,tw-=tw1;
    int ts2=min(f/s,ts);
    cnt+=ts2,ts-=ts2;
    int tw2=min((f-ts2*s)/w,tw);
    cnt+=tw2,tw-=tw2;
    ans=max(ans,cnt);
}
```

---
处理用时：37.86秒
# 题目信息

# Zigzags

## 题目描述

给出 $n$ 个数 $a_1,a_2,\cdots,a_n$。求问有多少个四元组 $(i,j,k,l)$，使得这个四元组满足下列条件：

- $1 \leq i<j<k<l \leq n$；   
- $a_i=a_k$ 并且 $a_j=a_l$。

## 样例 #1

### 输入

```
2
5
2 2 2 2 2
6
1 3 3 1 2 3```

### 输出

```
5
2```

# AI分析结果

### 题目重写
给出 $n$ 个数 $a_1,a_2,\cdots,a_n$。求问有多少个四元组 $(i,j,k,l)$，使得这个四元组满足下列条件：

- $1 \leq i<j<k<l \leq n$；   
- $a_i=a_k$ 并且 $a_j=a_l$。

### 算法分类
前缀和、枚举

### 题解分析与结论
该题的核心在于如何高效地统计满足条件的四元组 $(i,j,k,l)$。由于 $n \leq 3000$，直接枚举四元组的复杂度为 $O(n^4)$，显然不可行。因此，大多数题解都采用了枚举两个变量（如 $j$ 和 $k$），并通过预处理（如前缀和）来快速计算剩余两个变量的方案数。

#### 最优关键思路
1. **枚举 $j$ 和 $k$**：通过枚举 $j$ 和 $k$，可以固定 $a_j$ 和 $a_k$，然后通过前缀和快速计算 $i$ 和 $l$ 的可能位置。
2. **前缀和预处理**：通过预处理每个数在数组中的出现次数，可以在 $O(1)$ 时间内查询任意区间内某个数的出现次数。
3. **乘法原理**：对于每个 $(j,k)$，利用乘法原理计算满足条件的 $(i,l)$ 的数量。

#### 可拓展之处
类似的问题可以通过枚举部分变量，并结合预处理（如前缀和、哈希表等）来优化时间复杂度。例如，统计满足某些条件的子数组或子序列的数量时，可以采用类似的思路。

### 推荐题目
1. [P6006 - 子串统计](https://www.luogu.com.cn/problem/P6006)
2. [P1972 - 子串匹配](https://www.luogu.com.cn/problem/P1972)
3. [P3374 - 子序列计数](https://www.luogu.com.cn/problem/P3374)

### 精选题解

#### 题解1：H6_6Q (5星)
**关键亮点**：
- 详细分析了枚举不同变量的可行性，最终选择枚举 $j$ 和 $k$，思路清晰。
- 通过前缀和预处理，实现了 $O(n^2)$ 的复杂度，代码简洁高效。

**核心代码**：
```cpp
for(int j=2;j<=n;++j)
    for(int k=j+1;k<=n-1;++k)
        ans+=(sum[j-1][a[k]])*(sum[n][a[j]]-sum[k][a[j]]);
```

#### 题解2：邓布利多6 (4星)
**关键亮点**：
- 同样选择了枚举 $j$ 和 $k$，并通过前缀和预处理快速计算方案数。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for(int j = 1; j <= n; j++)
    for(int k = j + 1; k <= n; k++)
        ans += s[a[k]][j - 1] * (s[a[j]][n] - s[a[j]][k]);
```

#### 题解3：KSToki (4星)
**关键亮点**：
- 详细解释了枚举 $j$ 和 $k$ 的思路，并通过前缀和预处理实现了高效计算。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int j=1;j<n;++j)
    for(int k=j+1;k<=n;++k)
        ans+=(long long)s[j-1][a[k]]*(s[n][a[j]]-s[k][a[j]]);
```

### 总结
通过枚举 $j$ 和 $k$，并结合前缀和预处理，可以高效地解决该问题。这种思路在处理类似统计满足条件的子数组或子序列问题时非常有用。

---
处理用时：29.62秒
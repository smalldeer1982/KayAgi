# 题目信息

# New Year Cards

## 题目描述

亚历山大开始回复朋友们写的新年问候。亚历山大有 $n$ 个朋友，每个朋友都给亚历山大写了一张新年贺卡。我们按朋友给亚历山大发信的先后顺序来将朋友从 $1$ 到 $n$ 编号。我们以同样的方式来对这些卡片进行编号，例如第 $2$ 个朋友的卡片的编号为 $2$ 。

亚历山大也寄贺卡，但他喜欢使用以前朋友发给他的卡片（一开始，亚历山大没有贺卡）。他寄贺卡遵守两条原则：

$1.$ 他不会把该朋友邮寄给他的贺卡再寄回去。

$2.$对于当前他所拥有的贺卡，他只会选择他最喜欢的卡给朋友。

亚历山大计划给每一个朋友发送一张卡片（同一张牌可以多次利用）。

亚历山大以及他的朋友都有偏好列表（即喜欢的卡牌列表），表格从 $1$ 到 $n$ 。数字越小，这张卡越受喜欢。

你的任务是找到寄卡片的时间表，以确定亚历山大寄贺卡的时间，以取悦他的朋友（则他的朋友尽可能多的收到自己喜欢的贺卡）。

需要注意的是，亚历山大不会自由选择发送哪张卡，但他始终严格遵守这两条规则。

## 样例 #1

### 输入

```
4
1 2 3 4
4 1 3 2
4 3 1 2
3 4 2 1
3 1 2 4
```

### 输出

```
2 1 1 4
```

# AI分析结果



### 题目翻译

# 新年贺卡

## 题目描述

亚历山大开始回复朋友们的新年问候。他有 $n$ 个朋友，每个朋友都给他寄了一张贺卡，按发信顺序编号为 $1$ 到 $n$。亚历山大在回复时遵循以下规则：

1. 不能将朋友寄来的贺卡再寄回给该朋友。
2. 每次选择自己当前拥有的贺卡中最喜欢的一张。

每个朋友和亚历山大都有各自的偏好列表（数值越小表示越喜欢）。要求找到亚历山大给每个朋友发送贺卡的方式，使得朋友们尽可能多地收到自己喜欢的贺卡。

## 样例 #1

### 输入

```
4
1 2 3 4
4 1 3 2
4 3 1 2
3 4 2 1
3 1 2 4
```

### 输出

```
2 1 1 4
```

---

### 算法分类
**枚举**

---

### 题解分析与结论

#### 核心思路
所有题解均采用枚举法，时间复杂度为 $O(n^3)$。对于每个朋友 $i$，按顺序遍历其偏好列表中的卡片，跳过 $i$ 自己的卡片。对于候选卡片 $x$，检查是否存在比 $x$ 更优的卡片 $k$（在亚历山大的偏好列表中更靠前）且 $k \neq i$。若不存在，则选择 $x$。

#### 解决难点
- **偏好顺序处理**：将亚历山大的偏好列表转换为优先级数组，快速比较卡片的优先级。
- **条件验证**：对每个候选卡片，需遍历所有可能的更优卡片，判断是否存在违反条件的情况。

#### 题解评分与亮点
1. **Allanljx（4星）**
   - **关键亮点**：通过优先级数组快速比较，逻辑简洁。
   - **代码核心**：
     ```cpp
     for (int i=1; i<=n; i++) {
         for (int j=1; j<=n; j++) {
             if (a[i][j] == i) continue;
             int f = 0;
             for (int k=1; k < a[i][j]; k++) { // 此处存在逻辑缺陷
                 if (b[k] < b[a[i][j]] && k != i) f = 1;
             }
             if (f) continue;
             cout << a[i][j] << ' ';
             break;
         }
     }
     ```

2. **Eazin_star（4星）**
   - **关键亮点**：代码可读性强，条件判断清晰。
   - **代码核心**：
     ```cpp
     for (int i=1; i<=n; i++) {
         for (int j=1; j<=n; j++) {
             if (val[i][j] == i) continue;
             bool f = 1;
             for (int k=1; k < val[i][j]; k++) { // 同样的问题
                 if (a[k] < a[val[i][j]] && k != i) f = 0;
             }
             if (!f) continue;
             printf("%d ", val[i][j]);
             break;
         }
     }
     ```

3. **ys_kylin__（3星）**
   - **关键亮点**：简化变量命名，逻辑紧凑。
   - **问题**：未修复优先级遍历范围。

#### 优化技巧
- **优先级映射**：将亚历山大的偏好列表转换为哈希表，便于快速查询。
- **提前终止**：一旦找到符合条件的卡片，立即跳出循环。

#### 拓展思路
- 若优化遍历逻辑（检查所有卡片而非仅编号更小的），可将时间复杂度严格限制为 $O(n^3)$ 的正确解法。
- 类似问题可参考贪心策略中的最优选择问题，如「活动选择问题」。

---

### 推荐题目
1. [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)（枚举与排列）
2. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)（回溯与枚举）
3. [P1618 三连击（升级版）](https://www.luogu.com.cn/problem/P1618)（条件枚举与数学验证）

---
处理用时：489.75秒
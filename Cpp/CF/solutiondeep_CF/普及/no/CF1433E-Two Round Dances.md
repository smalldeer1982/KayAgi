# 题目信息

# Two Round Dances

## 题目描述

有一天，$n$ 人（$n$ 是偶数）在广场上相遇，跳了两支圆舞曲，每支圆舞曲正好由$\frac{n}{2}$人组成。你的任务是找出 $n$ 人可以跳两支圆舞的方案数量。每个人应该正好属于这两种圆舞中的一种。

圆舞是由 $1$ 人或更多的人组成的舞蹈圈。如果两个圆舞可以通过选择第一个参与者转化为另一个圆舞，则两个圆舞是无法区分（相等）的。例如，圆舞 $[1,3,4,2]$ ，$[4,2,1,3] $和 $[2,1,3,4] $是不可区分的。

例如，如果 $n=2$，那么方式的数量是 $1$：一个圆舞曲由第一个人组成，第二个人的圆舞曲由第二个人组成。

例如，如果 $n=4$，那么路数是  $3$ 。可能的方案：

- 一个圆舞曲 $[1,2]$ , 另一个 $[3,4]$ 。
-  一支圆舞 $[2,4]$ ，另一支 $ [3,1] $。
- 一个圆舞$ [4,1]$，另一个 $ [3,2]$ 。

你的任务是：如果每个圆舞曲正好由$\frac{n}{2}$人组成，找出 $n$ 人可以跳两支圆舞曲的方案数量。

## 样例 #1

### 输入

```
2```

### 输出

```
1```

## 样例 #2

### 输入

```
4```

### 输出

```
3```

## 样例 #3

### 输入

```
8```

### 输出

```
1260```

## 样例 #4

### 输入

```
20```

### 输出

```
12164510040883200```

# AI分析结果

### 题目内容重写
**题目描述**

有一天，$n$ 人（$n$ 是偶数）在广场上相遇，跳了两支圆舞曲，每支圆舞曲正好由$\frac{n}{2}$人组成。你的任务是找出 $n$ 人可以跳两支圆舞的方案数量。每个人应该正好属于这两种圆舞中的一种。

圆舞是由 $1$ 人或更多的人组成的舞蹈圈。如果两个圆舞可以通过选择第一个参与者转化为另一个圆舞，则两个圆舞是无法区分（相等）的。例如，圆舞 $[1,3,4,2]$ ，$[4,2,1,3] $和 $[2,1,3,4] $是不可区分的。

例如，如果 $n=2$，那么方式的数量是 $1$：一个圆舞曲由第一个人组成，第二个人的圆舞曲由第二个人组成。

例如，如果 $n=4$，那么路数是  $3$ 。可能的方案：

- 一个圆舞曲 $[1,2]$ , 另一个 $[3,4]$ 。
-  一支圆舞 $[2,4]$ ，另一支 $ [3,1] $。
- 一个圆舞$ [4,1]$，另一个 $ [3,2]$ 。

你的任务是：如果每个圆舞曲正好由$\frac{n}{2}$人组成，找出 $n$ 人可以跳两支圆舞曲的方案数量。

### 算法分类
组合数学

### 题解分析与结论
题目要求将 $n$ 人分成两组，每组 $\frac{n}{2}$ 人，并且每组形成一个圆舞曲。由于圆舞曲的排列是环形的，因此需要考虑圆排列的性质。大多数题解都基于组合数学的思路，通过计算组合数和圆排列数来求解。

### 评分较高的题解

#### 题解1：作者：rouxQ (赞：10)
**星级：5星**
**关键亮点：**
- 详细推导了组合数和圆排列数的公式，最终化简为 $\frac{2 \times (n-1)!}{n}$，思路清晰。
- 代码简洁，直接计算阶乘并输出结果。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int main (){
    long long n, ans = 1;
    cin >> n;
    for (int i = 1; i < n; i++)ans *= i;
    cout << ans * 2 / n << endl;
    return 0;
}
```

#### 题解2：作者：Rainy7 (赞：8)
**星级：4星**
**关键亮点：**
- 通过预处理阶乘，简化了组合数的计算。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
typedef long long ll;
const ll Maxn=20+5;
ll n,mul[Maxn];
int main()
{	scanf("%lld",&n);
	mul[0]=1;
	for(ll i=1;i<=n;i++)mul[i]=1ll*mul[i-1]*i;
	printf("%lld\n",mul[n]/mul[n/2]/mul[n/2]/2*mul[n/2-1]*mul[n/2-1]);
	return 0;
}
```

#### 题解3：作者：vectorwyx (赞：4)
**星级：4星**
**关键亮点：**
- 通过分段计算阶乘，避免了直接计算大数阶乘的复杂性。
- 代码实现巧妙，减少了计算量。

**核心代码：**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ull unsigned long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;

inline int read(){
	int x=0,fh=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*fh;
}


int main(){
	int n=read();
	ull sum=1;
	fo(i,n/2+1,n-1) sum*=i;
	fo(i,2,n/2-1) sum*=i;
	cout<<sum;
	return 0;
}
```

### 最优关键思路或技巧
1. **组合数与圆排列的结合**：通过组合数 $C_n^{\frac{n}{2}}$ 将 $n$ 人分成两组，再通过圆排列公式 $(\frac{n}{2}-1)!$ 计算每组的排列方式。
2. **阶乘的优化计算**：通过分段计算或预处理阶乘，避免直接计算大数阶乘的复杂性。
3. **公式化简**：将复杂的组合数和排列数公式化简为 $\frac{2 \times (n-1)!}{n}$，简化了计算过程。

### 可拓展之处
类似的问题可以扩展到更多的分组情况，或者不同的排列方式（如线性排列、环形排列等）。此外，还可以考虑不同的约束条件，如某些人必须在同一组或不同组等。

### 推荐题目
1. [P1494 小Z的袜子](https://www.luogu.com.cn/problem/P1494) - 组合数学与概率
2. [P2512 [HAOI2008]糖果传递](https://www.luogu.com.cn/problem/P2512) - 组合数学与贪心
3. [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197) - 组合数学与递推

### 个人心得摘录
- **rouxQ**：通过推导公式，发现最终结果可以化简为 $\frac{2 \times (n-1)!}{n}$，大大简化了计算过程。
- **Rainy7**：预处理阶乘可以有效减少计算量，尤其是在 $n$ 较大时。
- **vectorwyx**：分段计算阶乘避免了直接计算大数阶乘的复杂性，代码实现更加高效。

---
处理用时：42.84秒
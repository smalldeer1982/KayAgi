# 题目信息

# Toy Blocks

## 题目描述

你被叫去照看你的一个喜欢以一种奇怪方法玩积木的侄子。

你的侄子有 $n$ 个盒子，第 $i$ 个盒子中有 $a_i$ 个积木。他的游戏由两步组成：

1. 随机选择一个盒子 $i$ ；

2. 将第 $i$ 个盒子中的所有积木转移到其他盒子中。

两步操作后，如果他可以使其他 $n-1$ 个盒子中积木的数量相同，他就会高兴，否则他将伤心。注意：你的侄子只能将积木从被选中的盒子中转移到其他盒子；他不能从其他盒子中移动积木。你不想让你的侄子伤心，所以你打算在一些盒子中额外放几个积木，使得不论你的侄子选择任何盒子，他都不会伤心。求出最少额外放入的积木数。

## 说明/提示

在第一个测试点中，你可以在第一个盒子中放 $1$ 个积木。

在第二个测试点中，你不需要放积木。

在第三个测试点中，你可以在第一个盒子中放 $2$ 个积木，在第三个盒子中放 $1$ 个积木。

## 样例 #1

### 输入

```
3
3
3 2 2
4
2 2 3 2
3
0 3 0```

### 输出

```
1
0
3```

# AI分析结果

### 题目内容
# 玩具积木

## 题目描述

你被叫去照看你的一个喜欢以一种奇怪方法玩积木的侄子。

你的侄子有 $n$ 个盒子，第 $i$ 个盒子中有 $a_i$ 个积木。他的游戏由两步组成：

1. 随机选择一个盒子 $i$ ；

2. 将第 $i$ 个盒子中的所有积木转移到其他盒子中。

两步操作后，如果他可以使其他 $n-1$ 个盒子中积木的数量相同，他就会高兴，否则他将伤心。注意：你的侄子只能将积木从被选中的盒子中转移到其他盒子；他不能从其他盒子中移动积木。你不想让你的侄子伤心，所以你打算在一些盒子中额外放几个积木，使得不论你的侄子选择任何盒子，他都不会伤心。求出最少额外放入的积木数。

## 说明/提示

在第一个测试点中，你可以在第一个盒子中放 $1$ 个积木。

在第二个测试点中，你不需要放积木。

在第三个测试点中，你可以在第一个盒子中放 $2$ 个积木，在第三个盒子中放 $1$ 个积木。

## 样例 #1

### 输入

```
3
3
3 2 2
4
2 2 3 2
3
0 3 0```

### 输出

```
1
0
3```

### 算法分类
数学

### 题解分析与结论
该题的核心在于通过数学推导找到满足条件的最小额外积木数。主要思路是确保在任意选择盒子后，其他盒子的积木数能够达到相同。关键点在于：
1. 总和必须是 $n-1$ 的倍数。
2. 最大积木数的盒子决定了其他盒子的最小积木数。

### 精选题解
#### 题解1：作者：Qiiiiiii_ (赞：6)
**星级：5**
**关键亮点：**
- 通过数学推导，直接计算满足条件的最小额外积木数。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
int T,n;
ll ans,mx,a[N],sum;
int main(){
    T=read();
    while(T--){
        n=read(),mx=0,sum=0;
        FOR(i,1,n) a[i]=read(),sum+=a[i],mx=max(mx,a[i]);
        if(sum%(n-1)) ans=(sum/(n-1)+1)*(n-1);
        else ans=sum;
        ans=max(ans,mx*(n-1));
        cout<<ans-sum<<endl;
    }
    return 0;
}
```

#### 题解2：作者：WitheredZeal (赞：2)
**星级：4**
**关键亮点：**
- 通过二分法优化计算过程，避免线性增加。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
signed main()
{
    int T;
    cin>>T;
    while (T--)
    {
        int sum=0;
        cin>>n;
        for (int i=1;i<=n;i++) cin>>a[i];
        if (n==2)
        {
            cout<<0<<endl;
        }else
        {
            sort(a+1,a+n+1);
            for (int i=1;i<=n;i++) sum+=a[i];
            a[n]=max(a[n],((sum+n-2)/(n-1)));
            cout<<a[n]*(n-1)-sum<<endl;
        }
    }
}
```

#### 题解3：作者：JiuZhE66666 (赞：0)
**星级：4**
**关键亮点：**
- 通过数学公式直接计算最小额外积木数。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
signed main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        int mx=0;
        int sum=0;
        for(int i=1;i<=n;i++) 
        {
            cin>>a[i];
            mx=max(mx,a[i]);
            sum+=a[i];
        }
        int line=max(mx*(n-1),sum);
        cout<<(line/(n-1ll)+(line%(n-1ll)!=0))*(n-1ll)-sum<<'\n';
    }
    return 0;
}
```

### 最优关键思路
通过数学推导，确保总和是 $n-1$ 的倍数，并且最大积木数的盒子决定了其他盒子的最小积木数。直接计算满足条件的最小额外积木数。

### 可拓展之处
类似的问题可以通过数学推导和优化算法来解决，特别是在涉及分配和调整的问题中。

### 推荐题目
1. P1047 校门外的树
2. P1056 排座椅
3. P1064 金明的预算方案

---
处理用时：38.31秒
# 题目信息

# Strange Birthday Party

## 题目描述

Petya 举办了一场奇怪的生日聚会。 他邀请了 $n$ 个朋友并分配一个整数 $k_i$ 给第 $i$ 
个朋友。现在 Petya 想要给每个朋友送一个礼物，而附近的商店有 $m$ 种不同的礼物，其中第  $j$ 种的价格为 $c_j$ 美元 $( 1 \le c_1 \le c_2 \le \ldots \le c_m )$。每种礼物最多买一件。

对于第 $i$ 个朋友，Petya 可以选择给他买第 $j$ 种礼物 $( j \le k_i )$ , 花费 $c_j$ 美元；或者选择直接给他 $c_{k_i}$ 美元。

请你帮助 Petya 计算举办生日聚会需要的最小花费。

## 说明/提示

在第一个示例中，有两个测试用例。在第一个测试用例中，Petya 有个 5 朋友和 4 种可选的礼物。Petya 只用花费 30 美元，如果他给
- 第一个朋友 5 美元。
- 第二个朋友价格为 12 美元的礼物。
- 第三个朋友价格为 5 美元的礼物。
- 第四个朋友价格为 3 美元的礼物。
- 第五个朋友 5 美元。

在第二个测试用例中，Petya 有个 5 朋友和 5 种可选的礼物。Petya 只要消费 190 美元，如果他给
- 第一个朋友价格为 10 美元的礼物。
- 第二个朋友价格为 40 美元的礼物。
- 第三个朋友 90 美元。
- 第四个朋友 40 美元。
- 第五个朋友 10 美元。

## 样例 #1

### 输入

```
2
5 4
2 3 4 3 2
3 5 12 20
5 5
5 4 3 2 1
10 40 90 160 250```

### 输出

```
30
190```

## 样例 #2

### 输入

```
1
1 1
1
1```

### 输出

```
1```

# AI分析结果

### 题目内容重写
# 奇怪的生日派对

## 题目描述

Petya 举办了一场奇怪的生日聚会。他邀请了 $n$ 个朋友并分配一个整数 $k_i$ 给第 $i$ 个朋友。现在 Petya 想要给每个朋友送一个礼物，而附近的商店有 $m$ 种不同的礼物，其中第 $j$ 种的价格为 $c_j$ 美元 $( 1 \le c_1 \le c_2 \le \ldots \le c_m )$。每种礼物最多买一件。

对于第 $i$ 个朋友，Petya 可以选择给他买第 $j$ 种礼物 $( j \le k_i )$ , 花费 $c_j$ 美元；或者选择直接给他 $c_{k_i}$ 美元。

请你帮助 Petya 计算举办生日聚会需要的最小花费。

## 说明/提示

在第一个示例中，有两个测试用例。在第一个测试用例中，Petya 有个 5 朋友和 4 种可选的礼物。Petya 只用花费 30 美元，如果他给
- 第一个朋友 5 美元。
- 第二个朋友价格为 12 美元的礼物。
- 第三个朋友价格为 5 美元的礼物。
- 第四个朋友价格为 3 美元的礼物。
- 第五个朋友 5 美元。

在第二个测试用例中，Petya 有个 5 朋友和 5 种可选的礼物。Petya 只要消费 190 美元，如果他给
- 第一个朋友价格为 10 美元的礼物。
- 第二个朋友价格为 40 美元的礼物。
- 第三个朋友 90 美元。
- 第四个朋友 40 美元。
- 第五个朋友 10 美元。

## 样例 #1

### 输入

```
2
5 4
2 3 4 3 2
3 5 12 20
5 5
5 4 3 2 1
10 40 90 160 250```

### 输出

```
30
190```

## 样例 #2

### 输入

```
1
1 1
1
1```

### 输出

```
1```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略，优先将便宜的礼物分配给编号较大的朋友，从而最小化总花费。所有题解都采用了类似的贪心策略，即将 $k_i$ 从大到小排序，然后依次为每个朋友选择最便宜的礼物或直接给钱。这种策略确保了编号较大的朋友优先获得便宜的礼物，从而减少了总花费。

### 所选高星题解
1. **作者：Symbolize (5星)**
   - **关键亮点**：思路清晰，代码简洁，直接通过排序和贪心策略解决问题。
   - **核心代码**：
     ```cpp
     sort(k+1,k+n+1,cmp);//从大到小排序
     int id=1,ans=0;
     rep1(i,1,n)//循环，里面判断每个人选择拿钱还是拿礼物
     {
         if(c[id]<c[k[i]]) ans+=c[id++];//拿礼物
         else ans+=c[k[i]];//拿钱
     }
     cout<<ans<<endl;//输出
     ```
   - **个人心得**：通过排序和贪心策略，能够有效减少总花费，代码实现简单且高效。

2. **作者：_lxy_ (4星)**
   - **关键亮点**：详细分析了贪心策略的合理性，代码实现也较为简洁。
   - **核心代码**：
     ```cpp
     sort(k.begin(),k.end(),greater<ll>()); //把k数组按编号降序排列
     j=0; //目前最便宜的礼物的位置
     for(i=0;i<n;i++)
     {
         if(c[j]<c[k[i]]) //送礼物划算
         {
             ans+=c[j++];
         }
         else ans+=c[k[i]]; //送钱划算
     }
     ```
   - **个人心得**：通过降序排序和贪心选择，能够确保总花费最小化，代码逻辑清晰。

3. **作者：fanfansann (4星)**
   - **关键亮点**：通过排序和贪心策略，详细解释了为什么编号大的朋友应该优先选择礼物。
   - **核心代码**：
     ```cpp
     sort(k + 1, k + 1 + n);
     reverse(k + 1, k + 1 + n);
     int now = 1;
     for(int i = 1; i <= n; ++ i) {
         if(c[k[i]] <= c[now]) {
             ans += c[k[i]];
         }
         else ans += c[now], now ++ ;
     }
     ```
   - **个人心得**：通过排序和贪心策略，能够有效减少总花费，代码实现简单且高效。

### 最优关键思路或技巧
- **贪心策略**：优先将便宜的礼物分配给编号较大的朋友，确保总花费最小化。
- **排序**：将 $k_i$ 从大到小排序，确保编号较大的朋友优先选择礼物。

### 可拓展之处
- **类似题目**：可以考虑类似的贪心策略，如分配资源、任务调度等问题。
- **优化**：可以进一步优化代码，减少不必要的排序操作，提高效率。

### 推荐洛谷题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：43.02秒
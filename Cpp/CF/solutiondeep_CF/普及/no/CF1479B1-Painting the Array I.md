# 题目信息

# Painting the Array I

## 题目描述

### 题意

  **本题与 CF1480D2 的唯一区别是本题询问最大可能解.**

  给定一个数组 $a$, 你将将 $a_i$ 染为 $b_i$ 色, 其中 $b$ 是由你指定的一个 **01 数组**. 将 $a$ 数组中被染成 0 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(0)}$. 同理, 将 $a$ 数组中被染成 1 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(1)}$. 我们定义 $seg(c)$ 是一个正整数, 其中 $c$ 是一个数组, $seg(c)$ 的值为在我们将 $c$ 中相邻的所有相同元素合并后, $c$ 数组的大小. 例如, $seg([1, 1, 4, 5, 1, 4]) = |[1, 4, 5, 1, 4]|=5$. 最大化 $seg(a^{(0)})+seg(a^{(1)})$.

## 样例 #1

### 输入

```
7
1 1 2 2 3 3 3```

### 输出

```
6```

## 样例 #2

### 输入

```
7
1 2 3 4 5 6 7```

### 输出

```
7```

# AI分析结果

### 题目内容重写
# Painting the Array I

## 题目描述

### 题意

  **本题与 CF1480D2 的唯一区别是本题询问最大可能解.**

  给定一个数组 $a$, 你将将 $a_i$ 染为 $b_i$ 色, 其中 $b$ 是由你指定的一个 **01 数组**. 将 $a$ 数组中被染成 0 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(0)}$. 同理, 将 $a$ 数组中被染成 1 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(1)}$. 我们定义 $seg(c)$ 是一个正整数, 其中 $c$ 是一个数组, $seg(c)$ 的值为在我们将 $c$ 中相邻的所有相同元素合并后, $c$ 数组的大小. 例如, $seg([1, 1, 4, 5, 1, 4]) = |[1, 4, 5, 1, 4]|=5$. 最大化 $seg(a^{(0)})+seg(a^{(1)})$.

## 样例 #1

### 输入

```
7
1 1 2 2 3 3 3```

### 输出

```
6```

## 样例 #2

### 输入

```
7
1 2 3 4 5 6 7```

### 输出

```
7```

### 算法分类
贪心

### 题解分析与结论
本题的核心在于如何将数组 $a$ 中的元素分配到两个子序列 $a^{(0)}$ 和 $a^{(1)}$ 中，使得这两个子序列的 $seg$ 值之和最大。所有题解都采用了贪心策略，通过维护两个子序列的最后一个元素，并根据当前元素与这两个元素的相等关系以及它们下一次出现的位置来决定当前元素的分配。

### 评分较高的题解
1. **作者：wsyhb (赞：12)**  
   - **星级：5星**  
   - **关键亮点**：  
     - 提出了清晰的贪心策略，分为两种情况：当前元素与子序列末尾元素相等或不等。
     - 通过预处理 `Next` 数组来优化决策，确保每次选择都是最优的。
     - 代码简洁且高效，易于理解。
   - **代码核心思想**：  
     - 预处理 `Next` 数组，记录每个元素下一次出现的位置。
     - 根据当前元素与子序列末尾元素的关系，决定将其分配到哪个子序列。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e5+5;
int a[max_n],id[max_n],Next[max_n];
typedef pair<int,int> P;
vector<P> w,b;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",a+i);
		id[i]=n+1;
	}
	for(int i=n;i>=1;--i)
	{
		Next[i]=id[a[i]];
		id[a[i]]=i;
	}
	w.push_back(P(0,n+1));
	b.push_back(P(0,n+1));
	int ans=0;
	for(int i=1;i<=n;++i)
	{
		if(a[i]==w.back().first)
		{
			if(a[i]!=b.back().first)
				++ans;
			b.push_back(P(a[i],Next[i]));
		}
		else if(a[i]==b.back().first)
		{
			++ans;
			w.push_back(P(a[i],Next[i]));
		}
		else
		{
			++ans;
			if(w.back().second<b.back().second)
				w.push_back(P(a[i],Next[i]));
			else
				b.push_back(P(a[i],Next[i]));
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

2. **作者：2huk (赞：5)**  
   - **星级：4星**  
   - **关键亮点**：  
     - 详细分析了四种情况，并给出了直观的贪心策略。
     - 通过维护 `ne` 数组来优化决策，确保每次选择都是最优的。
     - 代码结构清晰，易于理解。
   - **代码核心思想**：  
     - 预处理 `ne` 数组，记录每个元素下一次出现的位置。
     - 根据当前元素与子序列末尾元素的关系，决定将其分配到哪个子序列。

```cpp
[代码](https://www.luogu.com.cn/paste/dfkut80l)
```

3. **作者：xz001 (赞：3)**  
   - **星级：4星**  
   - **关键亮点**：  
     - 使用两个栈来维护子序列，代码实现简洁。
     - 通过比较 `nxt` 数组的值来决定当前元素的分配，确保每次选择都是最优的。
     - 代码结构清晰，易于理解。
   - **代码核心思想**：  
     - 预处理 `nxt` 数组，记录每个元素下一次出现的位置。
     - 根据当前元素与子序列末尾元素的关系，决定将其分配到哪个子序列。

```cpp
#include <bits/stdc++.h>
using namespace std;
int s1[1000005], s2[1000005], top1, top2, n, a[1000005], nxt[1000005], p[1000005];
signed main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; ++ i) scanf("%lld", a + i);
    for (int i = n; i >= 1; -- i) {
    	nxt[i] = p[a[i]] ? p[a[i]] : n + 1;
    	p[a[i]] = i;
	}
	nxt[0] = n + 1;
	for (int i = 1; i <= n; ++ i) {
		if (a[i] == a[s1[top1]]) {
			if (a[i] != a[s2[top2]]) {
				s2[ ++ top2] = i;
			}
			s1[top1] = i;
		} else if (a[i] == a[s2[top2]]) {
			s1[ ++ top1] = i;
		} else {
			if (nxt[s1[top1]] < nxt[s2[top2]]) {
				s1[ ++ top1] = i;
			} else {
				s2[ ++ top2] = i;
			}
		}
	}
	printf("%lld", top1 + top2);
	return 0;
}
```

### 最优关键思路或技巧
1. **贪心策略**：通过维护两个子序列的最后一个元素，并根据当前元素与这两个元素的相等关系以及它们下一次出现的位置来决定当前元素的分配。
2. **预处理 `Next` 数组**：记录每个元素下一次出现的位置，优化决策过程。
3. **分类讨论**：根据当前元素与子序列末尾元素的关系，分为四种情况进行处理，确保每次选择都是最优的。

### 可拓展之处
类似的问题可以通过贪心策略来解决，尤其是涉及到将元素分配到多个子序列中并优化某种指标的问题。例如，可以将问题扩展到多个子序列，或者优化其他指标如子序列的长度、元素的和等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：48.39秒
# 题目信息

# Genius's Gambit

## 题目描述

You are given three integers $ a $ , $ b $ , $ k $ .

Find two binary integers $ x $ and $ y $ ( $ x \ge y $ ) such that

1. both $ x $ and $ y $ consist of $ a $ zeroes and $ b $ ones;
2. $ x - y $ (also written in binary form) has exactly $ k $ ones.

 You are not allowed to use leading zeros for $ x $ and $ y $ .

## 说明/提示

In the first example, $ x = 101000_2 = 2^5 + 2^3 = 40_{10} $ , $ y = 100001_2 = 2^5 + 2^0 = 33_{10} $ , $ 40_{10} - 33_{10} = 7_{10} = 2^2 + 2^1 + 2^0 = 111_{2} $ . Hence $ x-y $ has $ 3 $ ones in base-2.

In the second example, $ x = 10100_2 = 2^4 + 2^2 = 20_{10} $ , $ y = 10010_2 = 2^4 + 2^1 = 18 $ , $ x - y = 20 - 18 = 2_{10} = 10_{2} $ . This is precisely one 1.

In the third example, one may show, that it's impossible to find an answer.

## 样例 #1

### 输入

```
4 2 3```

### 输出

```
Yes
101000
100001```

## 样例 #2

### 输入

```
3 2 1```

### 输出

```
Yes
10100
10010```

## 样例 #3

### 输入

```
3 2 5```

### 输出

```
No```

# AI分析结果

### 题目翻译

#### 题目描述

给定三个整数 $a$、$b$、$k$。

找到两个二进制整数 $x$ 和 $y$（$x \ge y$），满足以下条件：

1. $x$ 和 $y$ 都由 $a$ 个 $0$ 和 $b$ 个 $1$ 组成；
2. $x - y$（也用二进制表示）恰好有 $k$ 个 $1$。

不允许 $x$ 和 $y$ 使用前导零。

#### 说明/提示

在第一个样例中，$x = 101000_2 = 2^5 + 2^3 = 40_{10}$，$y = 100001_2 = 2^5 + 2^0 = 33_{10}$，$40_{10} - 33_{10} = 7_{10} = 2^2 + 2^1 + 2^0 = 111_{2}$。因此 $x-y$ 在二进制中有 $3$ 个 $1$。

在第二个样例中，$x = 10100_2 = 2^4 + 2^2 = 20_{10}$，$y = 10010_2 = 2^4 + 2^1 = 18$，$x - y = 20 - 18 = 2_{10} = 10_{2}$。这正好有一个 $1$。

在第三个样例中，可以证明无法找到答案。

#### 样例 #1

##### 输入

```
4 2 3
```

##### 输出

```
Yes
101000
100001
```

#### 样例 #2

##### 输入

```
3 2 1
```

##### 输出

```
Yes
10100
10010
```

#### 样例 #3

##### 输入

```
3 2 5
```

##### 输出

```
No
```

### 算法分类
构造

### 题解分析与结论

本题的核心在于如何构造两个二进制数 $x$ 和 $y$，使得它们的差 $x - y$ 恰好有 $k$ 个 $1$。题解中大多采用了构造的思路，通过调整 $x$ 和 $y$ 的二进制位来满足条件。难点在于如何处理边界情况，如 $k=0$、$a=0$、$b=1$ 等，以及如何确保构造的 $x$ 和 $y$ 满足 $x \ge y$ 且没有前导零。

### 高星题解推荐

#### 题解1：作者：Unordered_OIer (赞：9)
**星级：5星**
**关键亮点：**
- 通过构造最大的二进制串作为 $x$，然后通过调整 $y$ 的二进制位来满足 $x - y$ 有 $k$ 个 $1$。
- 详细解释了如何通过借位来产生 $k$ 个 $1$，并给出了无解的条件。
- 代码简洁且高效，复杂度为 $\mathcal{O}(a+b)$。

**核心代码：**
```cpp
for(int i=1;i<=a+b;++i) {
    if(i==pos2)
        cout<<1,++cnt;
    else if(cnt<b-(i<pos2))
        cout<<1,++cnt;
    else
        cout<<0;
}
```

#### 题解2：作者：tommymio (赞：5)
**星级：4星**
**关键亮点：**
- 通过贪心构造 $x$ 和 $y$，确保 $x$ 和 $y$ 的二进制表示中第 $a+b$ 位均为 $1$。
- 提供了详细的边界条件处理，如 $a=0$、$b=1$ 等。
- 代码实现清晰，逻辑严谨。

**核心代码：**
```cpp
printf("1"); printf("1");
solve(k-1); printf("0"); solve(a+b-k+1);
```

#### 题解3：作者：KSToki (赞：5)
**星级：4星**
**关键亮点：**
- 通过构造 $x$ 和 $y$ 的二进制位，使得 $x - y$ 的二进制表示中有 $k$ 个 $1$。
- 详细讨论了无解的情况，并提供了特判条件。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
for(R int i=1;i<=a+b;++i) {
    if(i==pos2)
        cout<<1,++cnt;
    else if(cnt<b-(i<pos2))
        cout<<1,++cnt;
    else
        cout<<0;
}
```

### 最优关键思路与技巧
1. **构造最大二进制数**：通过构造最大的二进制数作为 $x$，然后调整 $y$ 的二进制位来满足条件。
2. **借位产生 $1$**：通过借位操作，使得 $x - y$ 的二进制表示中产生 $k$ 个 $1$。
3. **边界条件处理**：特别注意 $k=0$、$a=0$、$b=1$ 等边界情况，确保构造的 $x$ 和 $y$ 满足条件。

### 拓展思路
本题的构造思路可以推广到其他类似的二进制操作问题，如二进制加法、乘法等。通过调整二进制位来满足特定条件，是一种常见的解题技巧。

### 推荐题目
1. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1226 快速幂](https://www.luogu.com.cn/problem/P1226)

---
处理用时：40.72秒
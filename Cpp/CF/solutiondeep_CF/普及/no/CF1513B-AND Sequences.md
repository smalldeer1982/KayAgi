# 题目信息

# AND Sequences

## 题目描述

一个 $n$ 个数的非负数组如果 $\forall i\in\left[1,n\right)$ ，有 $a_1$ & $a_2$ & $……$ & $a_i = a_{i+1}$ & $a_{i+2}$ & $……$ & $a_n$ ，那么这个数组叫做 $“$ 好的数组 $”$ 。其中&表示按位与。

给定一个长度为 $n$ 的数组，求这个数组有多少种排列是 $“$ 好的数组 $”$ 。因为这个数字可能很大，所以输出结果模 $10^9+7$ 即可。

两个排列不同，指这个排列有一个位置的数与其他排列的这一位置的数的下表不同。

例如：

如果原数组是 $1,1$ ，那么这个数组有 $2$ 个排列；

如果原数组是 $1,1,1$ ，那么这个数组有 $6$ 个排列。

## 样例 #1

### 输入

```
4
3
1 1 1
5
1 2 3 4 5
5
0 2 0 3 0
4
1 3 5 1```

### 输出

```
6
0
36
4```

# AI分析结果

### 题目内容重写
# AND Sequences

## 题目描述

一个 $n$ 个数的非负数组如果 $\forall i\in\left[1,n\right)$ ，有 $a_1$ & $a_2$ & $……$ & $a_i = a_{i+1}$ & $a_{i+2}$ & $……$ & $a_n$ ，那么这个数组叫做 $“$ 好的数组 $”$ 。其中&表示按位与。

给定一个长度为 $n$ 的数组，求这个数组有多少种排列是 $“$ 好的数组 $”$ 。因为这个数字可能很大，所以输出结果模 $10^9+7$ 即可。

两个排列不同，指这个排列有一个位置的数与其他排列的这一位置的数的下表不同。

例如：

如果原数组是 $1,1$ ，那么这个数组有 $2$ 个排列；

如果原数组是 $1,1,1$ ，那么这个数组有 $6$ 个排列。

## 样例 #1

### 输入

```
4
3
1 1 1
5
1 2 3 4 5
5
0 2 0 3 0
4
1 3 5 1```

### 输出

```
6
0
36
4```

### 算法分类
组合数学、位运算

### 题解分析与结论
各题解的核心思路基本一致，都是通过分析“好的数组”的性质，得出数组的首尾元素必须等于整个数组的按位与结果，且中间元素可以任意排列。具体步骤如下：
1. 计算整个数组的按位与结果 $b$。
2. 统计数组中等于 $b$ 的元素个数 $c$。
3. 首尾元素必须为 $b$，因此首尾元素的选择方式为 $c \times (c-1)$。
4. 中间元素的排列方式为 $(n-2)!$。
5. 最终答案为 $c \times (c-1) \times (n-2)!$。

各题解在实现上略有差异，但整体思路相同。代码实现上，需要注意大数取模和阶乘的计算。

### 高星题解
#### 题解1：作者：gaozitao1 (4星)
**关键亮点**：思路清晰，代码简洁，直接计算阶乘和组合数，取模处理得当。
**代码核心**：
```cpp
int b = a[1];
for(int i = 2; i <= n; ++i) b &= a[i];
int c = 0;
for(int i = 1; i <= n; ++i) if(a[i] == b) ++c;
long long d = 1ll * c * (c - 1) % 1000000007;
for(int i = 1; i < n - 1; ++i) d = 1ll * d * i % 1000000007;
printf("%d\n", d);
```

#### 题解2：作者：Mophie (4星)
**关键亮点**：代码结构清晰，使用 `read()` 函数优化输入，阶乘计算和取模处理得当。
**代码核心**：
```cpp
int res = a[1];
for(int i = 2; i <= n; i++) res = (res & a[i]);
int cnt = 0;
for(int i = 1; i <= n; i++) if(a[i] == res) cnt++;
long long ans = 1ll * cnt * (cnt - 1) % mod;
for(int i = 1; i <= n - 2; i++) ans = ans * i % mod;
printf("%lld\n", ans);
```

#### 题解3：作者：naroto2022 (4星)
**关键亮点**：思路清晰，代码简洁，阶乘计算和取模处理得当。
**代码核心**：
```cpp
long long cnt = 0;
for(int i = 1; i <= n; i++) if(a[i] == cnt) num++;
long long ans = (num - 1) * num % mod;
for(int i = 1; i <= n - 2; i++) ans = ans * i % mod;
printf("%lld\n", ans);
```

### 关键思路与技巧
1. **位运算性质**：利用按位与的性质，确定首尾元素必须等于整个数组的按位与结果。
2. **组合数学**：通过组合数和阶乘计算排列数，注意大数取模。
3. **代码优化**：使用快速输入函数优化输入效率，阶乘计算时注意取模。

### 拓展与举一反三
类似题目可以考察其他位运算（如按位或、按位异或）的排列问题，或者结合其他数学知识（如组合数、排列数）进行综合考察。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
3. [P1965 [NOIP2013 提高组] 转圈游戏](https://www.luogu.com.cn/problem/P1965)

---
处理用时：36.65秒
# 题目信息

# AND 0, Sum Big

## 题目描述

#### 题目大意：

给定两个正整数 $n$ 和 $k$ ，求有多少个序列满足下列条件：

1. 序列中的所有元素都在 $[0,2^k-1]$ 之间。
2. 它的所有元素的与运算之和为 $0$ 。
3. 它的元素之和是尽可能大的。

答案对 $10^9+7$ 取模。

## 样例 #1

### 输入

```
2
2 2
100000 20```

### 输出

```
4
226732710```

# AI分析结果

### 题目内容重写
#### 题目大意：
给定两个正整数 $n$ 和 $k$，求有多少个序列满足下列条件：
1. 序列中的所有元素都在 $[0,2^k-1]$ 之间。
2. 它的所有元素的与运算之和为 $0$。
3. 它的元素之和是尽可能大的。

答案对 $10^9+7$ 取模。

### 算法分类
位运算、组合数学

### 题解分析与结论
本题的核心在于理解二进制位运算的性质，尤其是与运算的特性。所有元素的与运算结果为0，意味着在每一位上至少有一个元素为0。为了使元素之和最大，每一位上只能有一个元素为0，其余元素为1。因此，每一位有$n$种选择方式，总共有$k$位，故答案为$n^k$。

### 精选题解
#### 1. 作者：翼德天尊 (★★★★★)
- **关键亮点**：思路清晰，从二进制角度分析问题，快速幂实现高效计算。
- **代码核心**：
  ```cpp
  long long ksm(long long x,long long y,int mod){
      long long ans=1,k=x;
      while (y){
          if (y&1) ans=ans*k%mod;
          y>>=1;
          k=k*k%mod;
      }
      return ans;
  }
  ```
  **核心思想**：使用快速幂算法计算$n^k$，时间复杂度为$O(\log k)$。

#### 2. 作者：TernaryTree (★★★★☆)
- **关键亮点**：详细解释了快速幂的原理，提供了两种幂运算的实现方式。
- **代码核心**：
  ```cpp
  int power(int base, int freq, int mod) {
      int ans = 1, tmp = base;
      while (freq > 0) {
          if (freq % 2 == 1) ans = ans * tmp % mod;
          freq /= 2;
          tmp = tmp * tmp % mod;
      }
      return ans;
  }
  ```
  **核心思想**：同样使用快速幂算法，但提供了更详细的解释和两种实现方式。

#### 3. 作者：dead_X (★★★★☆)
- **关键亮点**：简洁明了，直接指出问题的本质，代码实现简洁。
- **代码核心**：
  ```cpp
  int qp(int x,int y) {
      int res=1;
      for(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;
      return res;
  }
  ```
  **核心思想**：快速幂实现，代码简洁，适合快速理解。

### 最优关键思路
1. **二进制位分析**：将问题转化为二进制位的选择问题，每一位有$n$种选择方式。
2. **快速幂算法**：使用快速幂算法高效计算$n^k$，避免了大数计算的复杂性。

### 拓展思路
类似的问题可以通过位运算和组合数学的方法解决，例如：
- 求满足某些位运算条件的序列数量。
- 求满足某些二进制位条件的最大或最小和。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)

---
处理用时：21.64秒
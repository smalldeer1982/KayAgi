# 题目信息

# Product 1 Modulo N

## 题目描述

#### 题目大意：

给定一个正整数 $n$ ，找到排列 $[1,2,...,n-1]$ 的最长子序列，使它满足它元素的乘积模 $n$ 意义下为 $1$ 。

注意：子序列的定义： $b$ 是 $a$ 的子序列当且仅当可以通过删去 $a$ 的若干个（可以是 $0$ 个） 元素得到 $b$ 。

## 样例 #1

### 输入

```
5```

### 输出

```
3
1 2 3```

## 样例 #2

### 输入

```
8```

### 输出

```
4
1 3 5 7```

# AI分析结果

【题目内容】
# Product 1 Modulo N

## 题目描述

#### 题目大意：

给定一个正整数 $n$ ，找到排列 $[1,2,...,n-1]$ 的最长子序列，使它满足它元素的乘积模 $n$ 意义下为 $1$ 。

注意：子序列的定义： $b$ 是 $a$ 的子序列当且仅当可以通过删去 $a$ 的若干个（可以是 $0$ 个） 元素得到 $b$ 。

## 样例 #1

### 输入

```
5```

### 输出

```
3
1 2 3```

## 样例 #2

### 输入

```
8```

### 输出

```
4
1 3 5 7```

【算法分类】数学

【题解分析与结论】

本题的核心思路是：**只能选择与 $n$ 互质的数**，因为如果选择的数中有与 $n$ 不互质的数，乘积模 $n$ 的结果不可能为 $1$。进一步，如果将所有与 $n$ 互质的数都选上，它们的乘积模 $n$ 的结果要么为 $1$，要么为某个与 $n$ 互质的数。如果结果不为 $1$，则只需从序列中去掉这个数即可。

【评分较高的题解】

1. **作者：Lynkcat (5星)**
   - **关键亮点**：清晰地证明了只能选择与 $n$ 互质的数，并且通过去掉乘积模 $n$ 的结果来得到最优解。代码简洁且高效。
   - **代码核心思想**：计算所有与 $n$ 互质的数的乘积，如果结果不为 $1$，则去掉该结果对应的数。
   ```cpp
   int n,ans;
   vector<int>G;
   signed main()
   {
       n=read();ans=1;
       for (int i=1;i<=n;i++)
           if (__gcd(n,i)==1) 
           {
               ans=ans*i%n;G.push_back(i);
           }
       if (ans!=1)
       {
           writeln(G.size()-1);
           for (auto v:G)
           {
               if (v==ans) continue;
               writesp(v);
           }
           return 0;
       }else
       {
       writeln(G.size());
       for (auto u:G) writesp(u);}
   }
   ```

2. **作者：Ryo_Yamada (4星)**
   - **关键亮点**：简洁地说明了只能选择与 $n$ 互质的数，并通过去掉乘积模 $n$ 的结果来得到最优解。代码实现清晰。
   - **代码核心思想**：计算所有与 $n$ 互质的数的乘积，如果结果不为 $1$，则去掉该结果对应的数。
   ```cpp
   ll now = 1;
   qread(n);
   rep(i, 1, n - 1) {
       if(gcd(i, n) == 1) {
           (now *= i) %= n;
           ans[++cnt] = i;
       }
   }
   if(now != 1) {
       printf("%d\n", cnt - 1);
       rep(i, 1, cnt) {
           if(ans[i] != now) printf("%d ", ans[i]);
       }
   }
   else {
       printf("%d\n", cnt);
       rep(i, 1, cnt) printf("%d ", ans[i]);
   }
   ```

3. **作者：寒鸽儿 (4星)**
   - **关键亮点**：详细证明了只能选择与 $n$ 互质的数，并通过去掉乘积模 $n$ 的结果来得到最优解。代码实现简洁。
   - **代码核心思想**：计算所有与 $n$ 互质的数的乘积，如果结果不为 $1$，则去掉该结果对应的数。
   ```cpp
   int n, prod = 1; scanf("%d", &n);
   res.push_back(1);
   for(int i = 2; i < n; ++i) if(__gcd(i, n) == 1) res.push_back(i), prod = 1ll * prod * i % n;
   printf("%ld\n", res.size() - (prod==1?0:1));
   for(int i = 0; i < res.size(); ++i) if(!i || res[i] != prod) printf("%d ", res[i]);
   ```

【最优关键思路或技巧】
- **关键思路**：只能选择与 $n$ 互质的数，并且通过去掉乘积模 $n$ 的结果来得到最优解。
- **技巧**：使用 `__gcd` 函数快速判断两个数是否互质，并通过模运算保持乘积在合理范围内。

【可拓展之处】
- 类似的问题可以扩展到其他模运算相关的题目，如求乘积模 $n$ 为某个特定值的最长子序列。

【推荐题目】
1. [P1447 最大公约数](https://www.luogu.com.cn/problem/P1447)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3383 线性筛素数](https://www.luogu.com.cn/problem/P3383)

---
处理用时：30.67秒
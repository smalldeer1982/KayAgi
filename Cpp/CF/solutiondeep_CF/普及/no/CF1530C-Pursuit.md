# 题目信息

# Pursuit

## 题目描述

你和你的朋友伊利亚正在参加由多个阶段组成的编程竞赛。

对于每个阶段，你和伊利亚都会获得一个分数，保证为 $0$ 到 $100$ 之间的整数。并且，每个人获得的分数都是相互独立的，不受对方影响。

总分是这样计算的：设当前已进行 $k$ 个阶段，则你的总分为最高的 $k-\left\lfloor k\div4\right\rfloor $个阶段得分之和。其中 $\left\lfloor a\right\rfloor$ 代表 $a$ 向下取整（不大于 $a$ 的最大整数）。

现在，这个竞赛已进行了 $n$ 个阶段，你也知道这些阶段中，两个人获得的分数。但比赛仍在进行。请问：理论上，至少再过多少个阶段，你的总分才能超过伊利亚？如果你的总分已经超过了她，请输出 `0`。

## 样例 #1

### 输入

```
5
1
100
0
1
0
100
4
20 30 40 50
100 100 100 100
4
10 20 30 40
100 100 100 100
7
7 59 62 52 27 31 55
33 35 50 98 83 80 64```

### 输出

```
0
1
3
4
2```

# AI分析结果

### 题目内容翻译

# 竞赛追逐

## 题目描述

你和你的朋友伊利亚正在参加由多个阶段组成的编程竞赛。

对于每个阶段，你和伊利亚都会获得一个分数，保证为 $0$ 到 $100$ 之间的整数。并且，每个人获得的分数都是相互独立的，不受对方影响。

总分是这样计算的：设当前已进行 $k$ 个阶段，则你的总分为最高的 $k-\left\lfloor k\div4\right\rfloor $个阶段得分之和。其中 $\left\lfloor a\right\rfloor$ 代表 $a$ 向下取整（不大于 $a$ 的最大整数）。

现在，这个竞赛已进行了 $n$ 个阶段，你也知道这些阶段中，两个人获得的分数。但比赛仍在进行。请问：理论上，至少再过多少个阶段，你的总分才能超过伊利亚？如果你的总分已经超过了她，请输出 `0`。

## 样例 #1

### 输入

```
5
1
100
0
1
0
100
4
20 30 40 50
100 100 100 100
4
10 20 30 40
100 100 100 100
7
7 59 62 52 27 31 55
33 35 50 98 83 80 64```

### 输出

```
0
1
3
4
2```

### 算法分类
贪心、模拟

### 题解分析与结论

本题的核心在于通过贪心策略和模拟来计算最少需要多少个阶段才能使自己的总分超过对手。所有题解都采用了贪心策略，即假设自己未来的每个阶段都获得满分（100分），而对手获得最低分（0分），以此来加速计算。

#### 最优思路与技巧
1. **贪心策略**：假设自己未来的每个阶段都获得100分，对手获得0分，这样可以最大化自己的得分增长，最小化对手的得分增长。
2. **模拟过程**：通过模拟每个阶段的得分变化，逐步计算总分，直到自己的总分超过对手。
3. **排序优化**：在模拟之前，先对得分进行排序，方便后续计算最高分。
4. **二分优化**：部分题解使用二分查找来优化模拟过程，减少计算量。

### 推荐题解

#### 1. 作者：Daidly (4星)
**关键亮点**：
- 使用贪心策略，假设自己未来的每个阶段都获得100分，对手获得0分。
- 通过排序和前缀和优化计算，减少时间复杂度。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
sort(a+1,a+n+1,cmp);
sort(b+1,b+n+1,cmp);
int tmp=n-n/4,tmpp;
for(int i=1;i<=n;++i){
    suma[i]=suma[i-1]+a[i];
    sumb[i]=sumb[i-1]+b[i];
}
if(suma[tmp]>=sumb[tmp]){puts("0");continue;}
bool f=1;
for(int i=1;i<2*n;++i){
    tmp=n+i-(n+i)/4;
    if(suma[tmp-i]+i*100>=sumb[min(tmp,n)]){
        f=0;cout<<i<<endl;
        break;
    }
}
if(f)cout<<3*n<<endl;
```

#### 2. 作者：Troubadour (4星)
**关键亮点**：
- 使用二分查找优化模拟过程，减少计算量。
- 通过权值线段树记录得分分布，优化查询和更新操作。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
bool judge(int k){
    int ans[2] = { 0,0 };
    modify(0, 1, 100, 100, k);
    cnt[0][100] += k;
    modify(1, 1, 0, 0, k);
    cnt[1][0] += k;
    for (int i = 0;i <= 1;i++){
        int j, tot = 0, num = (n + k) / 4;
        for (j = 0;j <= 100;j++){
            if (tot + cnt[i][j] < num)tot += cnt[i][j];
            else break;
        }
        ans[i] = query(i, 1, j + 1, 100) + (cnt[i][j]-num + tot)*j;
    }
    modify(0, 1, 100, 100, -k);
    cnt[0][100] -= k;
    modify(1, 1, 0, 0, -k);
    cnt[1][0] -= k;
    return ans[0] >= ans[1];
}
```

#### 3. 作者：cyrxdzj (4星)
**关键亮点**：
- 使用桶排序记录得分分布，优化查询和更新操作。
- 通过模拟每个阶段的得分变化，逐步计算总分。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
int get_result(int tong[101],int n){
    register int num=n-n/4;
    register int ans=0;
    for(register int i=100;i>=0;i--){
        if(tong[i]<=num){
            ans+=i*tong[i];
            num-=tong[i];
        }
        else{
            ans+=num*i;
            break;
        }
    }
    return ans;
}
```

### 拓展思路
本题的贪心策略和模拟方法可以应用于其他类似的竞赛或得分计算问题。例如，可以扩展到多个参赛者的情况，或者不同的得分计算规则。

### 推荐题目
1. [P7072 直播获奖](https://www.luogu.com.cn/problem/P7072)
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
3. [P1177 快速排序](https://www.luogu.com.cn/problem/P1177)

---
处理用时：35.20秒
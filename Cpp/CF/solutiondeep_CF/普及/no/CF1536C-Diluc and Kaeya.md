# 题目信息

# Diluc and Kaeya

## 题目描述

给你一个字符串 $S$，其中只包含 'K' 或 'D' 两种字符，要求划分这个字符串使得各部分的 $n(D):n(K)$ 相同，其中 $n(D)$ 表示 $S$ 中字符 'D' 出现的个数，最大化划分后形成的组数。

求出 $S$ 的所有前缀中的上述答案。

## 样例 #1

### 输入

```
5
3
DDK
6
DDDDDD
4
DKDK
1
D
9
DKDKDDDDK```

### 输出

```
1 2 1 
1 2 3 4 5 6 
1 1 1 2 
1 
1 1 1 2 1 2 1 1 3```

# AI分析结果

【题目内容】
# Diluc and Kaeya

## 题目描述

给你一个字符串 $S$，其中只包含 'K' 或 'D' 两种字符，要求划分这个字符串使得各部分的 $n(D):n(K)$ 相同，其中 $n(D)$ 表示 $S$ 中字符 'D' 出现的个数，最大化划分后形成的组数。

求出 $S$ 的所有前缀中的上述答案。

## 样例 #1

### 输入

```
5
3
DDK
6
DDDDDD
4
DKDK
1
D
9
DKDKDDDDK```

### 输出

```
1 2 1 
1 2 3 4 5 6 
1 1 1 2 
1 
1 1 1 2 1 2 1 1 3```

【算法分类】  
前缀和、数学

【题解分析与结论】  
本题的核心思路是通过维护前缀和，利用数学中的比例关系来统计每个前缀的最大划分组数。难点在于如何高效地统计每个前缀的 $n(D):n(K)$ 比例，并利用这些比例来快速计算最大划分组数。大多数题解都采用了 `map` 来存储比例的出现次数，通过遍历字符串并更新比例的出现次数来得到结果。

【评分较高的题解】  
1. **作者：¶凉笙 (赞：7)**  
   - **星级：5**  
   - **关键亮点**：思路清晰，代码简洁，使用了 `map` 来存储比例的出现次数，并通过 `gcd` 来简化比例的计算。  
   - **核心代码**：
     ```cpp
     map <Pair,int> m;
     int D=0,K=0;
     for(int i=1;i<=n;i++){
         D+= ch[i]=='D';K+= ch[i]=='K';
         int g=gcd(D,K);
         ans[i]=++m[mp(D/g,K/g)];
     }
     ```
   - **个人心得**：通过 `gcd` 简化比例的计算，避免了浮点数精度问题，且 `map` 的使用使得统计比例出现次数非常高效。

2. **作者：123hh2 (赞：5)**  
   - **星级：4**  
   - **关键亮点**：思路与 ¶凉笙 类似，代码简洁，使用了 `map` 和 `gcd`，且对比例的处理方式清晰。  
   - **核心代码**：
     ```cpp
     map<pair<int,int>,int>q;
     int D=0,K=0;
     for(ri int i=0;i<a.size();i++){
         a[i]=='D'?D++:K++;
         int temp=gcd(D,K);
         q[make_pair(D/temp,K/temp)]++;
         printf("%d ",q[make_pair(D/temp,K/temp)]);
     }
     ```
   - **个人心得**：通过 `map` 存储比例的出现次数，避免了复杂的计算，代码可读性高。

3. **作者：nalemy (赞：0)**  
   - **星级：4**  
   - **关键亮点**：思路清晰，使用了 `map` 来存储比例的出现次数，并通过 `gcd` 简化比例的计算，代码结构清晰。  
   - **核心代码**：
     ```cpp
     map<frac, int> mp;
     for (int i=0; i<n; i++) {
         s[i] == 'D' ? d++ : k++;
         frac rat = frac(d, k);
         if (mp.find(rat) == mp.end()) mp[rat] = 1;
         else mp[rat]++;
         cout << mp[rat] << ' ';
     }
     ```
   - **个人心得**：通过 `map` 存储比例的出现次数，避免了复杂的计算，代码可读性高。

【最优关键思路】  
通过 `map` 存储比例的出现次数，利用 `gcd` 简化比例的计算，避免浮点数精度问题，同时通过遍历字符串并更新比例的出现次数来快速得到每个前缀的最大划分组数。

【可拓展之处】  
类似的问题可以通过维护前缀和和比例关系来解决，例如统计字符串中某些字符的比例或频率。这类问题通常可以通过 `map` 或 `hash` 来高效处理。

【推荐题目】  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)  
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：36.70秒
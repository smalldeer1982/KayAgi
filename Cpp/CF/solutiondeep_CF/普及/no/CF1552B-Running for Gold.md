# 题目信息

# Running for Gold

## 题目描述

### 【题目大意】

奥运比赛刚刚开始，Federico 便十分渴望观看比赛。

有 $n$ 个选手参加了马拉松比赛，从 $1$ 到 $n$ 依次编号。她们**都**参加了 $5$ 项比赛，比赛从 $1$ 到 $5$ 编号。

现在有一个二维的数组 $r_{i,j}(1 \leq i \leq n,1 \leq j \leq 5)$，表示选手 $i$ 在比赛 $j$ 中排名第 $r_{i,j}$ 名。

Federico 认为选手 $u$ 优于选手 $v$，当且仅当，$u$ 在**至少** $3$ 个项目中战胜了 $v$（即排名在 $v$ 前）。

Federico 认为选手 $x$ 能够获得金牌当且仅当 $x$ 可以战胜其它**所有**选手。

给定 $r_{i,j}$，求是否有一名选手可以获得金牌。

## 样例 #1

### 输入

```
4
1
50000 1 50000 50000 50000
3
10 10 20 30 30
20 20 30 10 10
30 30 10 20 20
3
1 1 1 1 1
2 2 2 2 2
3 3 3 3 3
6
9 5 3 7 1
7 4 1 6 8
5 6 7 3 2
6 7 8 8 6
4 2 2 4 5
8 3 6 9 4```

### 输出

```
1
-1
1
5```

# AI分析结果

### 题目内容重写
# 争夺金牌

## 题目描述

### 【题目大意】

奥运比赛刚刚开始，Federico 便十分渴望观看比赛。

有 $n$ 个选手参加了马拉松比赛，从 $1$ 到 $n$ 依次编号。她们**都**参加了 $5$ 项比赛，比赛从 $1$ 到 $5$ 编号。

现在有一个二维的数组 $r_{i,j}(1 \leq i \leq n,1 \leq j \leq 5)$，表示选手 $i$ 在比赛 $j$ 中排名第 $r_{i,j}$ 名。

Federico 认为选手 $u$ 优于选手 $v$，当且仅当，$u$ 在**至少** $3$ 个项目中战胜了 $v$（即排名在 $v$ 前）。

Federico 认为选手 $x$ 能够获得金牌当且仅当 $x$ 可以战胜其它**所有**选手。

给定 $r_{i,j}$，求是否有一名选手可以获得金牌。

## 样例 #1

### 输入

```
4
1
50000 1 50000 50000 50000
3
10 10 20 30 30
20 20 30 10 10
30 30 10 20 20
3
1 1 1 1 1
2 2 2 2 2
3 3 3 3 3
6
9 5 3 7 1
7 4 1 6 8
5 6 7 3 2
6 7 8 8 6
4 2 2 4 5
8 3 6 9 4```

### 输出

```
1
-1
1
5```

### 算法分类
排序

### 题解综合分析与结论
本题的核心在于判断是否存在一个选手，能够在至少3个项目中战胜所有其他选手。由于优劣关系不具有传递性，直接对所有选手进行排序并检查最有可能的选手是否满足条件是一个常见的思路。

### 所选高星题解
1. **MikeC (5星)**
   - **关键亮点**：通过自定义排序函数对所有选手进行排序，然后检查排序后的第一个选手是否满足条件。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     bool cmp(int x,int y){
         int sum=0;
         for(int i=1;i<=5;i++){
             if(race[x][i]<race[y][i])sum++;
         }
         if(sum>=3)return true;
         else return false;
     }
     ```
   - **个人心得**：排序后直接检查第一个选手是否满足条件，避免了复杂的传递性判断。

2. **YGB_XU (4星)**
   - **关键亮点**：使用结构体存储选手信息，排序后检查第一个选手是否满足条件。代码结构清晰，易于理解。
   - **核心代码**：
     ```cpp
     bool cmp(Node x,Node y){
         int cnt=0;
         for(int i=1;i<=5;i++) cnt+=(int)x.s[i]<y.s[i];
         return cnt>=3;
     }
     ```
   - **个人心得**：通过结构体存储选手信息，使得代码更加模块化，易于维护。

3. **Wuyanru (4星)**
   - **关键亮点**：使用C++11的lambda表达式进行排序，代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     sort(ans+1,ans+n+1,[](int x,int y){
         int p=0;
         for(int i=1;i<=5;i++)
             if(a[x][i]<a[y][i])
                 p++;
         if(p>=3)
             return true;
         return false;
     });
     ```
   - **个人心得**：使用lambda表达式简化了排序函数的定义，代码更加简洁。

### 最优关键思路或技巧
1. **自定义排序函数**：通过自定义排序函数，将所有选手按照优劣关系进行排序，然后检查排序后的第一个选手是否满足条件。
2. **结构体存储**：使用结构体存储选手信息，使得代码更加模块化，易于维护。
3. **Lambda表达式**：使用C++11的lambda表达式简化排序函数的定义，代码更加简洁。

### 可拓展之处
本题的优劣关系不具有传递性，因此不能直接使用传递性进行判断。类似的问题可以扩展到多维度排序和自定义比较函数的场景，如多属性排序、多条件筛选等。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心、优先队列
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168) - 排序、中位数
3. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177) - 排序、快速排序

---
处理用时：33.22秒
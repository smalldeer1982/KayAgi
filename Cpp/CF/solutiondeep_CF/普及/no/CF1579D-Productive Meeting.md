# 题目信息

# Productive Meeting

## 题目描述

有 $n$ 个人被邀请参加一个即将召开重要会议。在会议中，任意两个人可以社交，相同的两个人可以社交任意次。

$n$ 个人中，每个人都有一个社交能力值，其中第 $i$ 个人的社交能力值是一个非负整数 $a_i$，它表示这个人可以与另一个人社交的次数。

在一个会议中，产生的社交次数越多，这次会议就会被认为越有效。具体地，一个会议的有效程度为这次会议进行时产生的社交次数。

给你序列 $a$，求出一次会议的最大有效程度，要求给出任意一种可以产生这个最大有效程度的方案。

## 说明/提示

$1\leq t\leq 10^3,2\leq n\leq 2\times 10^5$。

另外，保证对于所有测试样例中的 $n,a_i$，其和不超过 $2\times 10^5$。

## 样例 #1

### 输入

```
8
2
2 3
3
1 2 3
4
1 2 3 4
3
0 0 2
2
6 2
3
0 0 2
5
8 2 0 1 1
5
0 1 0 0 6```

### 输出

```
2
1 2
1 2
3
1 3
2 3
2 3
5
1 3
2 4
2 4
3 4
3 4
0
2
1 2
1 2
0
4
1 2
1 5
1 4
1 2
1
5 2```

# AI分析结果

### 题目内容
# 高效会议

## 题目描述

有 $n$ 个人被邀请参加一个即将召开的重要会议。在会议中，任意两个人可以社交，相同的两个人可以社交任意次。

$n$ 个人中，每个人都有一个社交能力值，其中第 $i$ 个人的社交能力值是一个非负整数 $a_i$，它表示这个人可以与另一个人社交的次数。

在一个会议中，产生的社交次数越多，这次会议就会被认为越有效。具体地，一个会议的有效程度为这次会议进行时产生的社交次数。

给你序列 $a$，求出一次会议的最大有效程度，要求给出任意一种可以产生这个最大有效程度的方案。

## 说明/提示

$1\leq t\leq 10^3,2\leq n\leq 2\times 10^5$。

另外，保证对于所有测试样例中的 $n,a_i$，其和不超过 $2\times 10^5$。

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略最大化社交次数。所有题解都采用了优先队列（大根堆）来动态维护当前社交能力值最大的人，并每次选择社交能力值最大的两个人进行社交，直到无法继续为止。这种方法能够有效避免浪费，确保每次操作都能最大化社交次数。

### 所选高分题解

#### 题解1：作者：M_CI (赞：4)
- **星级**：4
- **关键亮点**：详细分析了贪心策略的正确性，并通过反例说明了为什么不能随便匹配。代码实现简洁，使用了优先队列来维护最大值。
- **代码核心**：
  ```cpp
  priority_queue<pair<int,int> > q;
  while (q.size() >= 2) {
      pair<int,int> u = q.top(); q.pop();
      pair<int,int> v = q.top(); q.pop();
      tot[++ans] = {min(u.second, v.second), max(u.second, v.second)};
      u.first--; v.first--;
      if (u.first) q.push(u);
      if (v.first) q.push(v);
  }
  ```

#### 题解2：作者：huyangmu (赞：4)
- **星级**：4
- **关键亮点**：同样使用了优先队列，强调了每次选择社交能力值最大的两个人进行社交的重要性。代码结构清晰，易于理解。
- **代码核心**：
  ```cpp
  priority_queue<node> q;
  while (q.size() > 1) {
      node tmp = q.top(); q.pop();
      node tmp2 = q.top(); q.pop();
      que.push(tmp.id); que.push(tmp2.id);
      ++ans;
      --tmp.x; --tmp2.x;
      if (tmp.x != 0) q.push(node{tmp.x, tmp.id});
      if (tmp2.x != 0) q.push(node{tmp2.x, tmp2.id});
  }
  ```

#### 题解3：作者：Z_AuTwT (赞：1)
- **星级**：4
- **关键亮点**：通过反证法证明了贪心策略的正确性，并详细解释了为什么每次选择最大和次大的人进行社交是最优的。代码实现简洁，逻辑清晰。
- **代码核心**：
  ```cpp
  priority_queue<pair<int,int> > que;
  while (que.size() > 1) {
      pair<int,int> x = que.top(); que.pop();
      pair<int,int> y = que.top(); que.pop();
      x.first--; y.first--;
      cun[cnt][0] = x.second; cun[cnt][1] = y.second;
      if (x.first) que.push(x);
      if (y.first) que.push(y);
  }
  ```

### 最优关键思路
使用优先队列（大根堆）动态维护当前社交能力值最大的人，每次选择社交能力值最大的两个人进行社交，直到无法继续为止。这种方法能够确保每次操作都能最大化社交次数，避免浪费。

### 拓展思路
类似的问题可以扩展到其他资源分配或匹配问题，如任务调度、资源分配等。贪心策略在这些问题中同样适用，尤其是在需要最大化或最小化某些指标时。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1208 [USACO1.3]混合牛奶 Mixing Milk](https://www.luogu.com.cn/problem/P1208)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得摘录
- **M_CI**：通过反例说明了为什么不能随便匹配，强调了贪心策略的重要性。
- **Z_AuTwT**：通过反证法证明了贪心策略的正确性，并详细解释了为什么每次选择最大和次大的人进行社交是最优的。

---
处理用时：34.60秒
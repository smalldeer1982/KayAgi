# 题目信息

# Half of Same

## 题目描述

给定一个包含 $n$（$n$ 是偶数）个整数的数列 $a_1,a_2,\ldots,a_n$。

考虑一个可能的**正整数** $k$，在每次操作中，你可以选定一个 $i$，并将 $a_i$ 减少 $k$。

你可以执行任意多次（也可能是零次）操作，使这个数列中**至少一半的数**相等。

请找出最大的符合条件的 $k$，如果 $k$ 可以是任意的大小，输出 $-1$。

## 说明/提示

- $1 \le t \le 10$；
- $4 \le n \le 40$；
- $-10^6 \le a_i \le 10^6$。

保证 $\sum\limits{n} \le 100$。

Translated by @BurningEnderDragon, 2021.10.14

## 样例 #1

### 输入

```
4
6
48 13 22 -15 16 35
8
-1 0 1 -1 0 1 -1 0
4
100 -1000 -1000 -1000
4
1 1 1 1```

### 输出

```
13
2
-1
-1```

# AI分析结果

### 题目重写
给定一个包含 $n$（$n$ 是偶数）个整数的数列 $a_1,a_2,\ldots,a_n$。

考虑一个可能的**正整数** $k$，在每次操作中，你可以选定一个 $i$，并将 $a_i$ 减少 $k$。

你可以执行任意多次（也可能是零次）操作，使这个数列中**至少一半的数**相等。

请找出最大的符合条件的 $k$，如果 $k$ 可以是任意的大小，输出 $-1$。

### 算法分类
数学、枚举

### 题解分析与结论
本题的核心是通过枚举和数学方法找到最大的 $k$，使得至少一半的数可以通过减少 $k$ 的操作变得相等。题解中主要采用了以下几种思路：

1. **枚举最小值并计算差值**：通过枚举数列中的最小值，计算其他数与最小值的差值，然后求这些差值的最大公约数（GCD），从而得到可能的 $k$。
2. **随机化与因数分解**：通过随机选取数列中的两个数，计算它们的差值，然后枚举差值的所有因数，判断是否满足条件。
3. **预处理与优化**：通过预处理数列中每个数的出现次数，优化枚举过程，减少不必要的计算。

### 精选题解

#### 1. 作者：Jairon314 (赞：7)
- **星级**：4.5
- **关键亮点**：通过枚举最小值并计算差值的GCD，思路清晰，代码实现简洁。
- **核心代码**：
  ```cpp
  FOR(i,1,n/2+1){
      int res=0,rul=0;
      memset(c,0,sizeof c);
      FOR(j,i+1,n){
          int x=a[j]-a[i];
          if(x==0){ ++rul; continue; }
          res=::max(res,x);
          int lim=sqrt(x);
          for(int k=1;k<=lim;k++){
              if(x%k==0){
                  ++c[k];
                  if(x!=k*k){
                      ++c[x/k];
                  }
              }
          }
      }
      int delta=res;
      FOR(i,1,n/2-1-rul){
          while(c[delta]<i){ --delta; }
      }
      ans=::max(ans,delta);
  }
  ```
- **实现思想**：枚举最小值，计算差值的因数，统计满足条件的因数数量，找到最大的 $k$。

#### 2. 作者：Blunt_Feeling (赞：6)
- **星级**：4
- **关键亮点**：通过枚举数列中的两个数，计算差值的因数，判断是否满足条件，思路清晰。
- **核心代码**：
  ```cpp
  For(i,1,n/2+1) {
      if(i>1&&a[i]==a[i-1]) continue;
      For(j,i+1,n) {
          if(a[j]==a[j-1]) continue;
          int dif=a[j]-a[i],sqrtdif=sqrt(a[j]-a[i]);
          For(k,1,sqrtdif) {
              if(dif%k==0) {
                  if(check(k,i,j)) ans=max(ans,k);
                  if(k*k!=dif) {
                      if(check(dif/k,i,j)) ans=max(ans,dif/k);
                  }
              }
          }
      }
  }
  ```
- **实现思想**：枚举数列中的两个数，计算差值的因数，判断是否满足条件，找到最大的 $k$。

#### 3. 作者：haokee (赞：0)
- **星级**：4
- **关键亮点**：通过预处理数列中每个数的出现次数，优化枚举过程，减少不必要的计算。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      int times = 0;
      f.clear();
      v.clear();
      for (int j = 1; j <= n; j++) {
          if (a[j] == a[i]) { times++; }
          else if (a[j] > a[i]) { v.push_back(a[j] - a[i]); }
      }
      if (times >= n / 2) { ans = 1e9; continue; }
      for (int i : v) {
          for (int j : calc(i)) { f[j]++; }
      }
      for (auto j : f) {
          if (j.second >= n / 2 - times) { ans = max(ans, j.first); }
      }
  }
  ```
- **实现思想**：预处理数列中每个数的出现次数，枚举最小值，计算差值的因数，统计满足条件的因数数量，找到最大的 $k$。

### 最优关键思路
通过枚举数列中的最小值，计算其他数与最小值的差值，然后求这些差值的最大公约数（GCD），从而得到可能的 $k$。这种方法思路清晰，代码实现简洁，且时间复杂度较低。

### 可拓展之处
类似的问题可以通过枚举和数学方法解决，例如求数列中某些数的最大公约数或最小公倍数等问题。

### 推荐题目
1. [P1414 又是毕业季II](https://www.luogu.com.cn/problem/P1414)
2. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)
3. [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)

---
处理用时：37.67秒
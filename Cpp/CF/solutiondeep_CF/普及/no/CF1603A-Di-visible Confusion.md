# 题目信息

# Di-visible Confusion

## 题目描述

给一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，对于每个位置 $i$，如果 $a_i\%\left(i+1\right)\not=0$，就可以将 $a_i$ 删掉。删掉之后，后面的数都会往前面移动一位。问能否将序列删成空。

## 说明/提示

$1\le t\le10^4,1\le n\le10^5,1\le \sum n\le3\times10^5,1\le a_i\le10^9$。

## 样例 #1

### 输入

```
5
3
1 2 3
1
2
2
7 7
10
384836991 191890310 576823355 782177068 404011431 818008580 954291757 160449218 155374934 840594328
8
6 69 696 69696 696969 6969696 69696969 696969696```

### 输出

```
YES
NO
YES
YES
NO```

# AI分析结果

### 题目内容重写
# Di-visible Confusion

## 题目描述

给定一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，对于每个位置 $i$，如果 $a_i\%\left(i+1\right)\not=0$，就可以将 $a_i$ 删掉。删掉之后，后面的数都会往前面移动一位。问能否将序列删成空。

## 说明/提示

$1\le t\le10^4,1\le n\le10^5,1\le \sum n\le3\times10^5,1\le a_i\le10^9$。

## 样例 #1

### 输入

```
5
3
1 2 3
1
2
2
7 7
10
384836991 191890310 576823355 782177068 404011431 818008580 954291757 160449218 155374934 840594328
8
6 69 696 69696 696969 6969696 69696969 696969696```

### 输出

```
YES
NO
YES
YES
NO```

### 算法分类
数学

### 题解分析与结论
本题的核心在于判断序列中的每个元素是否可以被删除，最终将序列删空。题解主要集中在如何高效地判断每个元素是否可以被删除，以及如何优化这一过程。

### 所选高分题解
#### 1. 作者：cyhyyds (赞：5)  
**星级：5星**  
**关键亮点：**  
- 通过观察发现，如果 $a_i$ 不被删去，那么它应该是 $\operatorname{lcm}(2,3,\dots,i+1)$ 的倍数。
- 利用 $\operatorname{lcm}(2,3,\dots,23) \ge 10^9$ 的性质，将时间复杂度优化到 $O(22n)$，大大减少了计算量。
- 代码简洁，逻辑清晰，直接枚举 $2$ 到 $i+1$ 判断是否整除。

**代码片段：**
```cpp
bool ot = false;
for (int i = 1; i <= n; i ++) {
    bool fg = false;
    for (int j = 1; j <= i; j ++) {
        if (a[i] % (j + 1)) {
            fg = true;
            break;
        }
    }
    if (fg == false) {
        cout << "NO" << endl;
        ot = true;
        break;
    }
}
if (ot == false) {
    cout << "YES" << endl;
}
```

#### 2. 作者：Alex_Wei (赞：2)  
**星级：4星**  
**关键亮点：**  
- 提出从最右边开始删除的策略，确保不会影响前面的元素。
- 使用 $\mathrm{lcm}(2\sim (i+1))\nmid a_i$ 作为判断条件，进一步优化了判断过程。
- 时间复杂度为 $O(100n)$，虽然比 cyhyyds 的解法稍高，但思路清晰，易于理解。

**代码片段：**
```cpp
bool div = 0; cin >> a;
for (int j = 1; j <= min(100, i + 1); j++) div |= a % j > 0;
ans &= div;
```

#### 3. 作者：ImmortalWatcher (赞：1)  
**星级：4星**  
**关键亮点：**  
- 假设前面的数都可以被删除，那么 $a_i$ 能被删除的条件是 $2\sim i+1$ 之间有一个数不被 $a_i$ 整除。
- 通过枚举 $2\sim i+1$ 判断是否整除，时间复杂度为 $O(n^2)$，但由于 $\operatorname{lcm}(2,\dots,23) \ge 10^9$，实际运行时间较短。
- 代码实现简单，逻辑清晰。

**代码片段：**
```cpp
bool bj = false;
for (int j = i + 1; j >= 2; j--)
    if (a[i] % j) {
        bj = true;
        break;
    }
if (!bj) {
    puts("NO");
    flag = true;
    break;
}
```

### 最优关键思路或技巧
- **利用 $\operatorname{lcm}$ 的性质**：通过观察 $\operatorname{lcm}(2,3,\dots,23) \ge 10^9$，将枚举的范围限制在 $2$ 到 $23$，大大减少了计算量。
- **从后往前删除**：从序列的末尾开始删除元素，确保不会影响前面的元素，简化了判断逻辑。
- **枚举优化**：通过枚举 $2$ 到 $i+1$ 判断是否整除，利用 $\operatorname{lcm}$ 的性质，避免了不必要的计算。

### 可拓展之处
- 类似的问题可以扩展到其他数论相关的题目，如判断一个数是否能被一组数的 $\operatorname{lcm}$ 整除。
- 类似的删除操作可以应用于其他序列处理问题，如删除满足某些条件的元素后重新排列序列。

### 推荐题目
1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)
3. [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)

### 个人心得摘录
- **cyhyyds**：通过观察 $\operatorname{lcm}$ 的性质，发现枚举范围可以大大缩小，从而优化了时间复杂度。
- **Alex_Wei**：从最右边开始删除的策略，确保了不会影响前面的元素，简化了判断逻辑。
- **ImmortalWatcher**：假设前面的数都可以被删除，简化了判断条件，虽然时间复杂度较高，但实际运行时间较短。

---
处理用时：40.76秒
# 题目信息

# Variable, or There and Back Again

## 题目描述

给你一个n个点，m条边的有向图（不一定连通），每个点都被标上了0、1或2。如果有一条路径是从一个标为1的点开始，途径若干个标为0或2的点，最后到达一个标为2的点，那么这条路径上的所有点都算作被访问过。请问最后有多少点被访问过？

## 说明/提示

对于样例1，唯一的合法路径1->2->3->4包含了全部的点。

对于样例2，唯一的一条合法路径3->1包含了1和3两个点，点2没有在路径中。

对于样例3，没有一条路径是合法的。

## 样例 #1

### 输入

```
4 3
1 0 0 2
1 2
2 3
3 4
```

### 输出

```
1
1
1
1
```

## 样例 #2

### 输入

```
3 1
1 0 2
1 3
```

### 输出

```
1
0
1
```

## 样例 #3

### 输入

```
3 1
2 0 1
1 3
```

### 输出

```
0
0
0
```

# AI分析结果



**题目重写**（原题已为中文，无需翻译）

**算法分类**：图论（BFS/DFS）

---

### 题解综合分析

#### 核心思路总结
所有题解均采用**两次遍历法**，关键点包括：
1. **正向遍历**：从所有标记为1的点出发，沿边遍历，记录可达的点（`k1`数组）。
2. **反向遍历**：从所有标记为2的点出发，沿反向边遍历，记录能反向到达的点（`k2`数组），且遇到标记为1的点时立即停止。
3. **交集判断**：若一个点同时被正向和反向遍历标记，则属于合法路径上的点。

#### 关键技巧
- **反向图构建**：将原图边反向存储，便于从终点反向搜索。
- **终止条件处理**：反向遍历时遇到标记为1的点停止，避免路径中出现中间的1。
- **两次遍历优化**：将时间复杂度从暴力DFS的指数级降为线性级（O(n + m)）。

---

### 优质题解推荐

#### 1. 作者：InfiniteRobin（★★★★★）
**亮点**：
- 代码结构清晰，注释明确。
- 处理反向遍历终止条件，避免错误路径。
- 使用反向图存储，逻辑直观。

**核心代码**：
```cpp
void dfs1(int x) { // 正向遍历（从1出发）
    a[x] = 1;
    for (auto i : mp[x]) {
        if (!a[i] && f[i] != 1) dfs1(i);
    }
}

void dfs2(int x) { // 反向遍历（从2出发）
    b[x] = 1;
    if (f[x] == 1) return; // 遇到1则停止
    for (auto i : mp2[x]) {
        if (!b[i]) dfs2(i);
    }
}
```

#### 2. 作者：luoyicen（★★★★☆）
**亮点**：
- 详细解释了暴力做法与优化思路。
- 提供完整代码，包含反向遍历的终止条件。

**个人心得**：
> “在第二次遍历时，碰到标记为1的点就应该标记后并结束，而不是继续遍历下去（因为这个我WA了两次）”——强调终止条件的重要性。

---

### 拓展与同类题目
1. **图的遍历（洛谷 P3916）**：通过反向边快速求解所有点的可达性。
2. **牛的舞会（洛谷 P2863）**：强连通分量问题，需正反遍历。
3. **巡逻路线（洛谷 P3629）**：结合BFS与反向边的最短路径问题。

---
处理用时：51.11秒
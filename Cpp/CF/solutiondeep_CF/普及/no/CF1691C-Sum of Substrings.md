# 题目信息

# Sum of Substrings

## 题目描述

给定由 $0$ 和 $1$ 组成的长度为 $n$ 的字符串 $ s $ 。

定义一个十进制数字 $ d_i $ 十位和个位分别为 $ s_i $ 和  $ s_{i+1} $ 。 定义 $ f(s) $ 为所有合法的 $ d_i $ 的和。也就是说 $ f(s) = \sum\limits_{i=1}^{n-1} d_i $ 。

比如， 对于字符串 $ s = 1011 $ ：

- $ d_1 = 10 $ ；
- $ d_2 = 01 $ ；
- $ d_3 = 11 $ ;
- $ f(s) = 10 + 01 + 11 = 22 $ 。

在一次操作中你可以交换两个相邻的元素。 找到经过不多于 $k$ 次操作后 $ f(s) $ 的最小值。


保证所有数据中 $ n $ 的和不超过 $ 10^5 $ 。

## 说明/提示

- 对于第一组数据，不能做任何操作。$ f(s) = f(1010) = 10 + 01 + 10 = 21 $ 。
- 对于第二组数据，可以将字符串变成 $0011000$。 此时 $ f $ 的值为 $ 22 $ 。
- 对于第三组数据，可以将字符串变成 $00011$。 此时 $ f $ 的值为 $ 12 $ 。

## 样例 #1

### 输入

```
3
4 0
1010
7 1
0010100
5 2
00110```

### 输出

```
21
22
12```

# AI分析结果

### 题目内容重写

给定由 $0$ 和 $1$ 组成的长度为 $n$ 的字符串 $ s $ 。

定义一个十进制数字 $ d_i $ 十位和个位分别为 $ s_i $ 和  $ s_{i+1} $ 。 定义 $ f(s) $ 为所有合法的 $ d_i $ 的和。也就是说 $ f(s) = \sum\limits_{i=1}^{n-1} d_i $ 。

比如， 对于字符串 $ s = 1011 $ ：

- $ d_1 = 10 $ ；
- $ d_2 = 01 $ ；
- $ d_3 = 11 $ ;
- $ f(s) = 10 + 01 + 11 = 22 $ 。

在一次操作中你可以交换两个相邻的元素。 找到经过不多于 $k$ 次操作后 $ f(s) $ 的最小值。

保证所有数据中 $ n $ 的和不超过 $10^5$ 。

### 算法分类
贪心

### 题解分析与结论

#### 题解1：nullqtr_pwp (5星)
**关键亮点：**
1. 通过数学推导简化了问题，将 $f(s)$ 表达为 $\sum_{i=1}^{n}11\times a_i - (a_1 + 10\times a_n)$，从而将问题转化为如何最小化 $a_1 + 10\times a_n$。
2. 提出了优先将 $a_n$ 变为 $1$，其次将 $a_1$ 变为 $1$ 的策略，并通过 $cnt1$ 和 $cnt2$ 计算最小操作次数。
3. 提供了两个特判：序列中仅有一个 $1$ 和序列中全是 $0$ 的情况，确保代码的鲁棒性。

**个人心得：**
作者提到赛时吃了五发罚时，强调了特判的重要性，提醒我们在解题时要考虑边界情况。

**核心代码：**
```cpp
if((cnt1+cnt2)<=k) printf("%d\n",sum-11);
else if(cnt2<=k) printf("%d\n",sum-10);
else if(cnt1<=k) printf("%d\n",sum-1);
else printf("%d\n",sum);
```

#### 题解2：Withers (4星)
**关键亮点：**
1. 通过分析每个字符对答案的贡献，发现除了首尾字符外，其他字符的贡献都是 $11$，从而将问题简化为如何最小化首尾字符的贡献。
2. 提出了优先将末尾字符变为 $1$，其次将首位字符变为 $1$ 的策略，并通过计算操作次数来实现。

**核心代码：**
```cpp
if(s[len]=='0') {
    for(int i=len-1;i>=1;i--) {
        if(s[i]=='1') {sum1=n-i,x=i;break;}
    }
    if(sum1<=k&&sum1!=0) {
        k-=sum1;
        swap(s[len],s[x]);
    }
}
```

### 最优关键思路或技巧
1. **数学推导简化问题**：通过数学公式将 $f(s)$ 表达为 $\sum_{i=1}^{n}11\times a_i - (a_1 + 10\times a_n)$，从而将问题转化为如何最小化 $a_1 + 10\times a_n$。
2. **贪心策略**：优先将末尾字符变为 $1$，其次将首位字符变为 $1$，以最小化 $f(s)$。
3. **特判处理**：考虑边界情况，如序列中仅有一个 $1$ 或全是 $0$，确保代码的鲁棒性。

### 可拓展之处
1. **类似问题**：可以扩展到其他类似的字符串操作问题，如通过交换相邻字符来最大化或最小化某个函数值。
2. **贪心算法应用**：在需要最小化或最大化某个目标函数时，可以考虑贪心策略，优先处理对目标函数影响最大的部分。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：27.17秒
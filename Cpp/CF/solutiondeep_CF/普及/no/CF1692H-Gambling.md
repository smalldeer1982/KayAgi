# 题目信息

# Gambling

## 题目描述

Marian 在一个赌场，赌场的游戏规则如下：

每一轮开始前，玩家选一个在 $1$ 到 $10^9$ 。然后，掷出一个有着 $10^9$ 面的骰子，会随机出现一个在 $1$ 与 $10^9$ 之间的数。如果玩家猜对了，他们的钱就会翻一番，否则他们的钱会被折半。

Marian 可以预测未来，他知道在接下来 $n$ 轮里骰子上的数，即 $x_1,x_2,...,x_n$。

Marian 会选择三个整数 $a,l$ 和 $r$（$l \le r$）。他会玩 $r-l+1$ 轮。每一轮，他都猜同一个数 $a$。一开始（在第 $l$ 轮之前）他有 $1$ 美元。

Marian 请你帮助他决定 $a,l$ 和 $r$（$1\le a\le 10^9,1\le l\le r\le n$），让他最后的钱最多。

注：在折半或翻番的过程中不会进行游戏，也不会有精度问题。举个例子，Marian 在游戏中可能会有 $\frac{1}{1024},\frac{1}{128},\frac{1}{2},1,2,4$ 等等（任何可以表示为 $2^t$ 的数，其中 $t$ 为非 $0$ 整数）。

## 说明/提示

对于第一组数据，最好的选择是 $a=4,l=1,r=5$，游戏会这样进行：
- Marian 最开始有 $1$ 美元。
- 第一轮结束后，Marian 会有 $2$ 美元，因为骰子上掷出的数与 Marian 猜的数相同。
- 第二轮结束后，Marian 会有 $4$ 美元，因为他又猜对了。
- 第三轮结束后，Marian 会有 $2$ 美元，因为他猜了 $4$，而 $3$ 是正确答案。
- 第四轮结束后，Marian 又会有 $4$ 美元，因为他又又猜对了。
- 最后一轮结束后，Marian 会 $8$ 美元，因为他又又又猜对了。

第二组数据有多种答案，但可以证明 Marian 最后最多只有 $2$ 美元，因此只要 $l=r$ 且 $a$ 的数字合理，都是正确答案

## 样例 #1

### 输入

```
4
5
4 4 3 4 4
5
11 1 11 1 11
1
1000000000
10
8 8 8 9 9 6 6 9 6 6```

### 输出

```
4 1 5
1 2 2
1000000000 1 1
6 6 10```

# AI分析结果

【题目内容】
# Gambling

## 题目描述

Marian 在一个赌场，赌场的游戏规则如下：

每一轮开始前，玩家选一个在 $1$ 到 $10^9$ 。然后，掷出一个有着 $10^9$ 面的骰子，会随机出现一个在 $1$ 与 $10^9$ 之间的数。如果玩家猜对了，他们的钱就会翻一番，否则他们的钱会被折半。

Marian 可以预测未来，他知道在接下来 $n$ 轮里骰子上的数，即 $x_1,x_2,...,x_n$。

Marian 会选择三个整数 $a,l$ 和 $r$（$l \le r$）。他会玩 $r-l+1$ 轮。每一轮，他都猜同一个数 $a$。一开始（在第 $l$ 轮之前）他有 $1$ 美元。

Marian 请你帮助他决定 $a,l$ 和 $r$（$1\le a\le 10^9,1\le l\le r\le n$），让他最后的钱最多。

注：在折半或翻番的过程中不会进行游戏，也不会有精度问题。举个例子，Marian 在游戏中可能会有 $\frac{1}{1024},\frac{1}{128},\frac{1}{2},1,2,4$ 等等（任何可以表示为 $2^t$ 的数，其中 $t$ 为非 $0$ 整数）。

## 说明/提示

对于第一组数据，最好的选择是 $a=4,l=1,r=5$，游戏会这样进行：
- Marian 最开始有 $1$ 美元。
- 第一轮结束后，Marian 会有 $2$ 美元，因为骰子上掷出的数与 Marian 猜的数相同。
- 第二轮结束后，Marian 会有 $4$ 美元，因为他又猜对了。
- 第三轮结束后，Marian 会有 $2$ 美元，因为他猜了 $4$，而 $3$ 是正确答案。
- 第四轮结束后，Marian 又会有 $4$ 美元，因为他又又猜对了。
- 最后一轮结束后，Marian 会 $8$ 美元，因为他又又又猜对了。

第二组数据有多种答案，但可以证明 Marian 最后最多只有 $2$ 美元，因此只要 $l=r$ 且 $a$ 的数字合理，都是正确答案

## 样例 #1

### 输入

```
4
5
4 4 3 4 4
5
11 1 11 1 11
1
1000000000
10
8 8 8 9 9 6 6 9 6 6```

### 输出

```
4 1 5
1 2 2
1000000000 1 1
6 6 10```

【算法分类】
动态规划

【题解分析与结论】
该题的核心思路是将问题转化为最大子段和问题，通过动态规划求解。题解中，D2T1的解法通过将等于$a$的数设为1，不等于的设为-1，然后利用最大子段和的DP方法求解，时间复杂度为$O(n \log n)$。其他题解也采用了类似思路，但部分解法在优化和实现细节上有所不同。

【所选高分题解】
1. **作者：D2T1 (赞：10)**
   - **星级：5星**
   - **关键亮点：**
     - 将问题转化为最大子段和问题，思路清晰。
     - 使用`map`预处理，优化了时间复杂度。
     - 代码简洁，易于理解。
   - **核心代码：**
     ```cpp
     int main(){
         scanf("%d", &t);
         while(t--){
             scanf("%d", &n);
             map<int, int> mp;
             for(int i = 1; i <= n; ++ i){
                 scanf("%d", &x[i]);
                 ls[i] = mp[x[i]];
                 mp[x[i]] = i;
             }
             int ans = 0, pos;
             for(int i = 1; i <= n; ++ i){
                 if(f[ls[i]] - (i-ls[i]-1) > 0){
                     f[i] = f[ls[i]] - (i-ls[i]-1) + 1;
                     l[i] = l[ls[i]];
                 } else {
                     f[i] = 1;
                     l[i] = i;
                 }
                 if(f[i] > ans){
                     ans = f[i]; pos = i; 
                 }
             }
             printf("%d %d %d\n", x[pos], l[pos], pos);
         }
     }
     ```

【最优关键思路】
将问题转化为最大子段和问题，通过动态规划求解，使用`map`预处理优化时间复杂度。

【可拓展之处】
类似的最大子段和问题可以通过DP或前缀和的方法解决，适用于多种场景，如股票买卖、区间最大和等。

【推荐题目】
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

---
处理用时：37.25秒
# 题目信息

# 3SUM Closure

## 题目描述

我们定义一个数组是 “3SUM-closed” 的，当且仅当对于任意满足 $1\le i<j<k\le n$ 的三个数 $(i,j,k)$，都存在有 $1\le l\le n$，使得 $a_i+a_j+a_k=a_l$。  
现在给你 $T$ 个数组，对于每个数组，若它是“3SUM-closed”的，则输出 `YES`（大小写不敏感，下同）；若不是，则输出 `NO`。

## 样例 #1

### 输入

```
4
3
-1 0 1
5
1 -2 -2 1 -3
6
0 0 0 0 0 0
4
-1 2 -3 4```

### 输出

```
YES
NO
YES
NO```

# AI分析结果

### 题目内容重写

# 3SUM Closure

## 题目描述

我们定义一个数组是 “3SUM-closed” 的，当且仅当对于任意满足 $1\le i<j<k\le n$ 的三个数 $(i,j,k)$，都存在有 $1\le l\le n$，使得 $a_i+a_j+a_k=a_l$。  
现在给你 $T$ 个数组，对于每个数组，若它是“3SUM-closed”的，则输出 `YES`（大小写不敏感，下同）；若不是，则输出 `NO`。

## 样例 #1

### 输入

```
4
3
-1 0 1
5
1 -2 -2 1 -3
6
0 0 0 0 0 0
4
-1 2 -3 4```

### 输出

```
YES
NO
YES
NO```

### 算法分类
枚举

### 题解分析与结论

题目要求判断一个数组是否是“3SUM-closed”，即任意三个数的和是否都在数组中。由于直接暴力枚举的时间复杂度较高，题解们通过观察数组的性质，提出了以下优化思路：

1. **正负数的数量限制**：如果数组中有超过两个正数或负数，那么最大的三个正数或负数的和必然不在数组中，因此可以直接判定为 `NO`。
2. **零的处理**：如果数组中有多个零，可以只保留一个零，因为零的加入不会影响三个数的和。
3. **暴力枚举**：在优化后的数组中，最多只有五个元素，因此可以直接暴力枚举所有可能的三元组，判断它们的和是否在数组中。

### 高星题解

#### 题解1：作者：zmza (赞：5)
**星级：5星**
**关键亮点**：
- 通过正负数的数量限制和零的处理，将问题规模缩小到最多五个元素，大大减少了枚举的复杂度。
- 代码简洁，逻辑清晰，使用了 `map` 来快速判断和是否在数组中。

**核心代码**：
```cpp
bool flag = 0;
for (int i = 0; i < vec.size(); i++)
    for (int j = 0; j < vec.size(); j++)
        for (int k = 0; k < vec.size(); k++)
            if (i != j && j != k && i != k && !mp[vec[i] + vec[j] + vec[k]])
            {
                flag = 1;
                goto lab;
            }
lab: puts(flag ? "NO" : "YES");
```

#### 题解2：作者：0xFF (赞：2)
**星级：4星**
**关键亮点**：
- 通过正负数的数量限制和零的处理，将问题规模缩小到最多五个元素。
- 代码结构清晰，使用了 `vector` 来存储优化后的数组。

**核心代码**：
```cpp
for (int i = 0; i < a.size(); i++) {
    for (int j = i + 1; j < a.size(); j++) {
        for (int k = j + 1; k < a.size(); k++) {
            bool flag = false;
            for (int l = 0; l < a.size(); l++) {
                if (a[i] + a[j] + a[k] == a[l]) {flag = true;}
            }
            if (!flag) {cout << "NO\n"; return;}
        }
    }
}
```

#### 题解3：作者：__stick (赞：1)
**星级：4星**
**关键亮点**：
- 通过正负数的数量限制和零的处理，将问题规模缩小到最多五个元素。
- 代码逻辑清晰，使用了 `vector` 和 `find` 函数来判断和是否在数组中。

**核心代码**：
```cpp
bool flag=1;
for(int i=0;i<a.size();i++)
    for(int j=i+1;j<a.size();j++)
        for(int k=j+1;k<a.size();k++)
            if(find(a.begin(),a.end(),a[i]+a[j]+a[k])==a.end())flag=0;
if(flag)cout<<"YES\n";
else cout<<"NO\n";
```

### 最优关键思路或技巧
1. **正负数的数量限制**：通过观察数组的性质，限制正负数的数量，减少问题规模。
2. **零的处理**：多个零可以简化为一个零，不影响结果。
3. **暴力枚举**：在优化后的数组中，直接暴力枚举所有可能的三元组，判断它们的和是否在数组中。

### 可拓展之处
类似的问题可以通过观察数组的性质，减少问题规模，然后进行暴力枚举。例如，判断数组中是否存在四个数的和等于某个值，可以先限制正负数的数量，再进行枚举。

### 推荐题目
1. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

### 个人心得
在解决类似问题时，可以先观察数组的性质，通过限制条件减少问题规模，再进行暴力枚举。这样可以大大提高算法的效率。

---
处理用时：35.26秒
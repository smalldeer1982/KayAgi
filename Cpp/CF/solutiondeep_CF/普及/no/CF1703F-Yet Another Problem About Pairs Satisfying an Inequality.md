# 题目信息

# Yet Another Problem About Pairs Satisfying an Inequality

## 题目描述

# Yet Another Problem About Pairs Satisfying an Inequality


给你一个序列$ a_1, a_2, \dots a_n $ 。请计算出满足下面条件的 $(i,j) (1 \leq i, j \leq n) $个数 。

-  $ a_i < i < a_j < j $ .

## 说明/提示

对于第一组测试数据，满足条件的 $ (i, j) $ = $ \{(2, 4), (2, 8), (3, 8)\} $ .

- $ (2, 4) $ 满足条件是因为 $ a_2 = 1 $ , $ a_4 = 3 $ 且$ 1 < 2 < 3 < 4 $ .
-  $ (2, 8) $ 满足条件是因为$ a_2 = 1 $ , $ a_8 = 4 $ 且 $ 1 < 2 < 4 < 8 $ .
-  $ (3, 8) $ 满足条件是因为$ a_3 = 2 $ , $ a_8 = 4 $ 且 $ 2 < 3 < 4 < 8 $ .

## 样例 #1

### 输入

```
5
8
1 1 2 3 8 2 1 4
2
1 2
10
0 2 1 6 3 4 1 2 8 3
2
1 1000000000
3
0 1000000000 2```

### 输出

```
3
0
10
0
1```

# AI分析结果

### 题目重写
# 又一个关于满足不等式对的题目

## 题目描述

给你一个序列$ a_1, a_2, \dots a_n $。请计算出满足下面条件的 $(i,j) (1 \leq i, j \leq n)$ 个数。

- $ a_i < i < a_j < j $。

## 说明/提示

对于第一组测试数据，满足条件的 $ (i, j) $ = $ \{(2, 4), (2, 8), (3, 8)\} $。

- $ (2, 4) $ 满足条件是因为 $ a_2 = 1 $，$ a_4 = 3 $ 且 $ 1 < 2 < 3 < 4 $。
- $ (2, 8) $ 满足条件是因为 $ a_2 = 1 $，$ a_8 = 4 $ 且 $ 1 < 2 < 4 < 8 $。
- $ (3, 8) $ 满足条件是因为 $ a_3 = 2 $，$ a_8 = 4 $ 且 $ 2 < 3 < 4 < 8 $。

## 样例 #1

### 输入

```
5
8
1 1 2 3 8 2 1 4
2
1 2
10
0 2 1 6 3 4 1 2 8 3
2
1 1000000000
3
0 1000000000 2
```

### 输出

```
3
0
10
0
1
```

### 算法分类
前缀和

### 题解分析与结论
本题的核心是找到满足 $a_i < i < a_j < j$ 的 $(i, j)$ 对。题解中主要有以下几种思路：

1. **朴素算法**：直接枚举 $i$ 和 $j$，时间复杂度为 $O(n^2)$，无法通过大范围数据。
2. **前缀和优化**：通过预处理满足 $a_i < i$ 的元素，并使用前缀和来快速计算满足条件的 $j$ 的数量，时间复杂度为 $O(n)$。
3. **树状数组**：使用树状数组来维护满足条件的元素，时间复杂度为 $O(n \log n)$。
4. **二分法**：通过二分查找来优化查找满足条件的 $j$，时间复杂度为 $O(n \log n)$。

最优的解法是使用前缀和优化，因为其时间复杂度最低且实现简单。

### 高星题解
#### 题解1：作者：lizhous (赞：10)
**星级**：★★★★★  
**关键亮点**：使用前缀和优化，时间复杂度为 $O(n)$，代码简洁明了。
**代码核心思想**：预处理满足 $a_i < i$ 的元素，并使用后缀和来快速计算满足条件的 $j$ 的数量。
```cpp
for (int i = 1; i <= n; i++) {
    if (a[i] < i) {
        cnt[a[i]]++; //预处理
    }
}
for (int i = n; i >= 1; i--) {
    cnt[i] += cnt[i + 1]; //后缀和
}
for (int i = 1; i <= n; i++) {
    if (a[i] < i) {
        ans += cnt[i + 1]; //调用预处理数组
    }
}
```

#### 题解2：作者：linyuhuai (赞：4)
**星级**：★★★★  
**关键亮点**：使用前缀和优化，时间复杂度为 $O(n)$，代码简洁。
**代码核心思想**：通过前缀和数组记录满足 $a_i < i$ 的元素数量，并在遍历时累加答案。
```cpp
for (int i = 1; i <= n; i++) {
    if (a[i] < i) sum[i] = sum[i - 1] + 1;
    else sum[i] = sum[i - 1];
    if (a[i] > 0 && a[i] < i) ans += sum[a[i] - 1];
}
```

#### 题解3：作者：zsseg (赞：3)
**星级**：★★★★  
**关键亮点**：使用前缀和优化，时间复杂度为 $O(n)$，代码简洁。
**代码核心思想**：通过前缀和数组记录满足 $a_i < i$ 的元素数量，并在遍历时累加答案。
```cpp
for (int i = 1; i <= n; i++) {
    qzh[i] = qzh[i - 1];
    if (i > u) qzh[i]++, ans += qzh[u - 1];
}
```

### 最优关键思路
使用前缀和优化，预处理满足 $a_i < i$ 的元素，并通过后缀和或前缀和快速计算满足条件的 $j$ 的数量，时间复杂度为 $O(n)$。

### 拓展思路
类似的问题可以使用前缀和、树状数组或二分法来优化查找过程，特别是在需要快速计算满足条件的元素数量时。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得
在解决类似问题时，预处理和前缀和的使用可以大大降低时间复杂度，特别是在需要快速计算满足条件的元素数量时。

---
处理用时：40.38秒
# 题目信息

# Jatayu's Balanced Bracket Sequence

## 题目描述

### 题目大意

对于一个长度为 $2n$ 的**合法**的括号串 $s$，按照如下方法构造一张无向图：

- 括号序列的所有位置都是无向图中的一个点。

- 对于该序列的任意位置 $l$，它能向另一个位置 $r$ 连边当且仅当满足子串 $s[l, \; \dots , \; r]$ 也是一个**合法**括号串。

求这张无向图的连通块个数。

## 样例 #1

### 输入

```
4
1
()
3
()(())
3
((()))
4
(())(())```

### 输出

```
1
2
3
3```

# AI分析结果

### 题目内容重写
# Jatayu's Balanced Bracket Sequence

## 题目描述

### 题目大意

对于一个长度为 $2n$ 的**合法**的括号串 $s$，按照如下方法构造一张无向图：

- 括号序列的所有位置都是无向图中的一个点。

- 对于该序列的任意位置 $l$，它能向另一个位置 $r$ 连边当且仅当满足子串 $s[l, \; \dots , \; r]$ 也是一个**合法**括号串。

求这张无向图的连通块个数。

### 输入格式

第一行包含一个整数 $T \; (1 \leqslant T \leqslant 10^5)$  表示测试样例组数。

对于每组测试样例，第一行包含一个整数 $n \; (1 \leqslant n \leqslant 10^5)$ 表示序列长度为 $2n$。

接下来的一行包含一个长度为 $2n$ 的合法括号串。

### 输出格式

对于每组测试样例，包含一个整数表示该串构造的无向图的连通块数。

### 算法分类
**并查集**

### 题解分析与结论

本题的核心在于如何高效地计算括号序列构造的无向图的连通块个数。题解中提供了多种思路，包括暴力、结论、线段合并、并查集等。其中，**并查集**是最为高效且易于理解的解决方案。

### 评分较高的题解

#### 1. 作者：yegengghost (赞：0)
- **星级**: 4
- **关键亮点**: 使用并查集来维护连通块，通过路径压缩和公共祖先的判断来减少连通块的数量。代码简洁且易于理解。
- **个人心得**: 通过并查集的操作，能够有效地减少连通块的数量，且代码实现较为直观。

```cpp
class node {
public:
    vector<int> p; // 维护一个并查集
    int n;
    node(int _n):n(_n) {
        p.resize(n);
        iota(p.begin(), p.end(), 0); // 批量递增
    }
    inline int get(int x) {
        return (x == p[x] ? x : (p[x] = get(p[x]))); // 路径压缩
    }
    inline bool unite(int x, int y) {
        x = get(x);
        y = get(y);
        if (x != y) {
            p[x] = y;
            return 1;
        }
        return 0;
    }
};
```

#### 2. 作者：Zigh_Wang (赞：0)
- **星级**: 4
- **关键亮点**: 通过栈维护括号的深度，利用深度变化来判断连通块的边界，思路清晰且代码简洁。
- **个人心得**: 通过观察括号的深度变化，能够有效地判断连通块的边界，且代码实现较为直观。

```cpp
int T;
int n;
char str[MAXN];
int a[MAXN], cnt = 0;
int tp = 0;
int ans = 0;

int main() {
    T = inpt();
    while (T--) {
        ans = 0;
        tp = 0;
        cnt = 0;
        n = inpt();
        scanf("%s", str + 1);
        for (int i = 1; i <= 2 * n; i++) {
            if (str[i] == '(') {
                tp++;
            } else {
                tp--;
                a[++cnt] = tp;
            }
        }
        for (int i = 1; i < cnt; i++) {
            if (a[i] > a[i + 1])
                ans++;
        }
        printf("%d\n", ans + 1);
    }
    return 0;
}
```

#### 3. 作者：E1_de5truct0r (赞：1)
- **星级**: 4
- **关键亮点**: 通过模拟栈的操作，维护左括号的深度，利用深度变化来判断连通块的边界，思路清晰且代码简洁。
- **个人心得**: 通过模拟栈的操作，能够有效地判断连通块的边界，且代码实现较为直观。

```cpp
void solve() {
    int n; cin >> n >> (s + 1);
    for (int i = 1; i <= (n << 1); i++) pre[i] = 0; // 清空数组
    int j = 0, ans = 0;
    for (int i = 1; i <= (n << 1); i++) {
        if (s[i] == '(') pre[++j]++, ans++; // 如果是左括号就加贡献
        else ans = ans - pre[j], pre[j] = 0; // 否则减贡献
    }
    cout << ans + 1 << endl; // 输出
}
```

### 最优关键思路或技巧
- **并查集**：通过并查集维护连通块，能够高效地减少连通块的数量，且代码实现较为简洁。
- **栈维护深度**：通过栈维护括号的深度，利用深度变化来判断连通块的边界，思路清晰且代码简洁。

### 可拓展之处
- **类似题目**：可以扩展到其他需要维护连通块的问题，如树的结构、图的连通性等。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

---
处理用时：35.95秒
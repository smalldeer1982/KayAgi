# 题目信息

# Digital Logarithm

## 题目描述

### 题目大意

我们定义 $f(x)$ 表示取出 $x$ 在**十进制**下的位数。( 如 $f(114514) = 6, \; f(998244353) = 9$ )。形式化讲，就是 $f(x) = \lfloor \log_{10} x \rfloor + 1$。

给定两个数组 $a$ 和 $b$，求执行若干次以下操作后使得 $a$ 和 $b$ **排序后**相等的最小操作次数。

操作方法如下：

- 选择一个下标 $i$，将 $a_i$ 赋值为 $f(a_i)$ **或者**将 $b_i$ 赋值为 $f(b_i)$。

## 样例 #1

### 输入

```
4
1
1
1000
4
1 2 3 4
3 1 4 2
3
2 9 3
1 100 9
10
75019 709259 5 611271314 9024533 81871864 9 3 6 4865
9503 2 371245467 6 7 37376159 8 364036498 52295554 169```

### 输出

```
2
0
2
18```

# AI分析结果

### 题目内容重写
# 数字对数

## 题目描述

### 题目大意

我们定义 $f(x)$ 表示取出 $x$ 在**十进制**下的位数。( 如 $f(114514) = 6, \; f(998244353) = 9$ )。形式化讲，就是 $f(x) = \lfloor \log_{10} x \rfloor + 1$。

给定两个数组 $a$ 和 $b$，求执行若干次以下操作后使得 $a$ 和 $b$ **排序后**相等的最小操作次数。

操作方法如下：

- 选择一个下标 $i$，将 $a_i$ 赋值为 $f(a_i)$ **或者**将 $b_i$ 赋值为 $f(b_i)$。

## 样例 #1

### 输入

```
4
1
1
1000
4
1 2 3 4
3 1 4 2
3
2 9 3
1 100 9
10
75019 709259 5 611271314 9024533 81871864 9 3 6 4865
9503 2 371245467 6 7 37376159 8 364036498 52295554 169```

### 输出

```
2
0
2
18```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略，每次对当前最大的元素进行操作，使其逐步缩小，直到两个数组中的元素能够匹配。具体来说，使用优先队列（堆）来维护两个数组中的最大值，每次比较两个堆顶元素，如果不等则对较大的元素进行操作，直到两个堆为空。

### 所选高星题解
1. **作者：litachloveyou (赞：6)**  
   - **星级：5星**  
   - **关键亮点**：使用优先队列从大到小排序，每次对较大的元素进行操作，确保操作次数最少。代码简洁且高效。  
   - **核心代码**：
     ```cpp
     priority_queue<int, vector<int>, less<int>>a, b;
     int ans = 0;
     while (!a.empty()) {
         x = a.top();
         y = b.top();
         if (x > y) {
             a.pop();
             a.push(len(x));
             ans++;
         } else if (x < y) {
             b.pop();
             b.push(len(y));
             ans++;
         } else {
             a.pop();
             b.pop();
         }
     }
     ```

2. **作者：Forever1507 (赞：4)**  
   - **星级：4星**  
   - **关键亮点**：同样使用优先队列，但强调了操作次数最多为两轮，时间复杂度为 $\Theta(n\log_2n)$，代码清晰。  
   - **核心代码**：
     ```cpp
     priority_queue<int>pq1,pq2;
     int ans = 0;
     while (!pq1.empty() && !pq2.empty()) {
         int cur1 = pq1.top(), cur2 = pq2.top();
         if (cur1 == cur2) {
             pq1.pop();
             pq2.pop();
         } else if (cur1 > cur2) {
             ans++;
             change(cur1);
             pq1.pop();
             pq1.push(cur1);
         } else {
             ans++;
             change(cur2);
             pq2.pop();
             pq2.push(cur2);
         }
     }
     ```

3. **作者：lrqlrq250 (赞：2)**  
   - **星级：4星**  
   - **关键亮点**：从大到小排序，使用优先队列维护，每次对较大的元素进行操作，思路清晰，代码简洁。  
   - **核心代码**：
     ```cpp
     priority_queue<int, vector<int>, less<int>> q1, q2;
     int ans = 0;
     while (!q1.empty()) {
         a = q1.top(); b = q2.top();
         if (a > b) {
             a = (int)log10(a) + 1;
             q1.pop(); q1.push(a);
             ans++;
         } else if (b > a) {
             b = (int)log10(b) + 1;
             q2.pop(); q2.push(b);
             ans++;
         } else q1.pop(), q2.pop();
     }
     ```

### 最优关键思路
使用优先队列从大到小排序，每次对较大的元素进行操作，确保操作次数最少。这种方法的时间复杂度为 $\Theta(n\log n)$，且代码实现简洁高效。

### 可拓展之处
类似的问题可以通过贪心策略结合优先队列来解决，尤其是在需要逐步缩小问题规模的情况下。例如，处理最大值或最小值的问题时，优先队列是一个非常有用的工具。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

---
处理用时：31.35秒
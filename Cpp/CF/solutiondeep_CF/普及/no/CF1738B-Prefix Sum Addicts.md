# 题目信息

# Prefix Sum Addicts

## 题目描述

假设$a_1,a_2,\dots,a_n$是一个长度为$n$的有序整数序列，满足$a_1\leq a_2\leq\dots\leq a_n$

定义$s_i$为$a_1,a_2,\dots,a_i$的前缀和。

$$
s_i=\sum_{k=1}^{i}a_k=a_1+a_2+\dots+a_i
$$

现在已知前缀和的最后$k$项，即$s_{n−k+1},\dots,s_{n−1},s_n$。你的任务是确定这是否可能。

形式上，给定$k$个整数$s_{n−k+1},\dots,s_{n−1},s_n$，任务是检查是否有一个序列$a_1,a_2,\dots,a_n$，该序列满足以下两个条件:
* $a_1 \leq a_2 \dots \leq a_n$
* 对于所有的$n-k+1\leq i\leq n$,满足$s_i=a_1+a_2+\dots+a_i$

## 样例 #1

### 输入

```
4
5 5
1 2 3 4 5
7 4
-6 -5 -3 0
3 3
2 3 4
3 2
3 4```

### 输出

```
Yes
Yes
No
No```

# AI分析结果

### 题目内容重写
# 前缀和成瘾者

## 题目描述

假设$a_1,a_2,\dots,a_n$是一个长度为$n$的有序整数序列，满足$a_1\leq a_2\leq\dots\leq a_n$

定义$s_i$为$a_1,a_2,\dots,a_i$的前缀和。

$$
s_i=\sum_{k=1}^{i}a_k=a_1+a_2+\dots+a_i
$$

现在已知前缀和的最后$k$项，即$s_{n−k+1},\dots,s_{n−1},s_n$。你的任务是确定这是否可能。

形式上，给定$k$个整数$s_{n−k+1},\dots,s_{n−1},s_n$，任务是检查是否有一个序列$a_1,a_2,\dots,a_n$，该序列满足以下两个条件:
* $a_1 \leq a_2 \dots \leq a_n$
* 对于所有的$n-k+1\leq i\leq n$,满足$s_i=a_1+a_2+\dots+a_i$

## 样例 #1

### 输入

```
4
5 5
1 2 3 4 5
7 4
-6 -5 -3 0
3 3
2 3 4
3 2
3 4```

### 输出

```
Yes
Yes
No
No```

### 算法分类
前缀和、贪心

### 题解分析与结论
该题的核心在于通过已知的前缀和部分推导出整个序列是否可能是一个不下降序列。各题解的主要思路是通过前缀和的差值来判断序列的单调性，并利用贪心策略处理未直接给出的部分。

### 所选高星题解
1. **作者：Alex_Wei (赞：3)**  
   **星级：4**  
   **关键亮点：**  
   - 通过前缀和的差值判断序列的单调性。
   - 利用贪心策略处理未给出的部分，确保序列的不下降性。
   - 代码简洁，逻辑清晰。

   **核心代码：**
   ```cpp
   if (k == 1) {
       cout << "Yes\n";
       return;
   }
   for (int i = 2; i < k; i++) {
       if (s[i] - s[i - 1] > s[i + 1] - s[i]) {
           cout << "No\n";
           return;
       }
   }
   if (d[2] * (n - k + 1) >= s[1]) {
       cout << "Yes\n";
   } else {
       cout << "No\n";
   }
   ```

2. **作者：fqEason (赞：2)**  
   **星级：4**  
   **关键亮点：**  
   - 通过排序和比较前缀和的差值来判断序列的合法性。
   - 利用贪心思想处理未给出的部分，确保序列的不下降性。
   - 代码结构清晰，易于理解。

   **核心代码：**
   ```cpp
   sort(b+1,b+k+1);
   for (int i=1;i<=k;i++) {
       if (c[i]!=b[i]) {
           cout << "NO\n";
           flag=true;
           break;
       }
   }
   if (!flag) cout << "YES\n";
   ```

3. **作者：atomic_int (赞：0)**  
   **星级：4**  
   **关键亮点：**  
   - 通过前缀和的差值判断序列的单调性。
   - 利用贪心策略处理未给出的部分，确保序列的不下降性。
   - 代码简洁，逻辑清晰。

   **核心代码：**
   ```cpp
   for (int i = 2; i < k; i ++) {
       if (d[i] > d[i + 1]) {
           cout << "No\n";
           return ;
       }
   }
   if (d[2] * (n - k + 1) >= s[1]) {
       cout << "Yes\n";
   } else {
       cout << "No\n";
   }
   ```

### 最优关键思路或技巧
- **前缀和差值法：** 通过计算前缀和的差值来判断序列的单调性，确保序列的不下降性。
- **贪心策略：** 在处理未直接给出的部分时，利用贪心策略分配值，确保序列的整体不下降性。

### 可拓展之处
- 类似题目可以考察如何通过部分信息推导整个序列的性质，如通过部分和推导整个序列的单调性。
- 可以扩展到多维序列或更复杂的序列性质判断。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：33.89秒
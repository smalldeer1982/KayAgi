# 题目信息

# Knowledge Cards

## 题目描述

### 题目大意
对于一个 $n \times m$ 的棋盘，左上角为 $(1,\;1)$，右下角为 $(n,\;m)$。$(1,\;1)$ 和 $(n,\;m)$ 上分别有一个栈。最开始的时候$(1,\;1)$ 格子上的栈里有 $k$ 张牌，**从栈顶到栈底**的第 $i$ 张牌上有一个数 $a_i$，保证 $a$ 数组是一个 $k$ 的全排列。你需要对这些牌做若干次操作将所有牌移到 $(n,\;m)$ 格子的栈中，使得最后 $(n,\;m)$ 格子的栈中从上到下牌上的序号依次为 $1 \sim k$，每次给你棋盘长宽 $n \times m$ 和初始的 $a$ 数组，请问是否有解。

我们定义一次操作的规则如下：

1. 一次只能操作一张牌；
2. 一张牌只能向相邻的**四联通**格子（有共边）里移动；
3. **除了** $(1,\;1)$ 和 $(n,\;m)$ 以外的格子内不能拥有超过一张牌；
4. 如果你当前**操作**的格子是 $(1,\;1)$，那么你只能从他的**栈顶**取走一张牌，且你**不能**将一张牌移到他上面；
5. 如果你当前操作的**目标**格子是 $(n,\;m)$，那么你只能将一张牌移动到他的**栈顶**，且你不能从他上面移走任何一张牌。

## 样例 #1

### 输入

```
4
3 3 6
3 6 4 1 2 5
3 3 10
1 2 3 4 5 6 7 8 9 10
5 4 4
2 1 3 4
3 4 10
10 4 9 3 5 6 8 2 7 1```

### 输出

```
YA
TIDAK
YA
YA```

# AI分析结果

### 题目内容重写
对于一个 $n \times m$ 的棋盘，左上角为 $(1,\;1)$，右下角为 $(n,\;m)$。$(1,\;1)$ 和 $(n,\;m)$ 上分别有一个栈。最开始的时候$(1,\;1)$ 格子上的栈里有 $k$ 张牌，**从栈顶到栈底**的第 $i$ 张牌上有一个数 $a_i$，保证 $a$ 数组是一个 $k$ 的全排列。你需要对这些牌做若干次操作将所有牌移到 $(n,\;m)$ 格子的栈中，使得最后 $(n,\;m)$ 格子的栈中从上到下牌上的序号依次为 $1 \sim k$，每次给你棋盘长宽 $n \times m$ 和初始的 $a$ 数组，请问是否有解。

我们定义一次操作的规则如下：

1. 一次只能操作一张牌；
2. 一张牌只能向相邻的**四联通**格子（有共边）里移动；
3. **除了** $(1,\;1)$ 和 $(n,\;m)$ 以外的格子内不能拥有超过一张牌；
4. 如果你当前**操作**的格子是 $(1,\;1)$，那么你只能从他的**栈顶**取走一张牌，且你**不能**将一张牌移到他上面；
5. 如果你当前操作的**目标**格子是 $(n,\;m)$，那么你只能将一张牌移动到他的**栈顶**，且你不能从他上面移走任何一张牌。

### 算法分类
模拟

### 题解分析与结论
题解的核心思路是模拟卡片的移动过程，并利用 `set` 数据结构来记录当前棋盘上的卡片状态。通过遍历初始的卡片序列，逐步将卡片移动到目标位置，同时检查棋盘上的空位是否足够。如果棋盘上的空位不足以容纳当前需要移动的卡片，则判定为无解。

### 所选题解
1. **作者：linyihdfj (赞：1)**  
   - **星级：4**  
   - **关键亮点：** 通过 `set` 记录棋盘上的卡片状态，逐步将卡片移动到目标位置，检查空位是否足够。代码简洁，逻辑清晰。  
   - **核心代码：**
     ```cpp
     set<int> st;
     int mx = 0, now = k;
     for(int i=1; i<=k; i++){
         int a;scanf("%d",&a);
         st.insert(a);
         while(!st.empty() && st.find(now) != st.end()){
             st.erase(now);now--;
         }
         mx = max(mx,int(st.size()));
     }
     if(mx >= n * m - 3)	printf("TIDAK\n");
     else	printf("YA\n");
     ```

2. **作者：UniGravity (赞：0)**  
   - **星级：4**  
   - **关键亮点：** 通过 `set` 记录棋盘上的最大卡片，逐步将卡片移动到目标位置，检查空位是否足够。代码结构清晰，注释详细。  
   - **核心代码：**
     ```cpp
     set< int > st;
     int maxa = k;
     bool flag = false;
     for (int i = 1; i <= k; i++) {
         scanf("%d", &a[i]);
         if (a[i] == maxa) {
             maxa--;
             while (!st.empty() && st.find(maxa) != st.end()) {
                 st.erase(maxa);
                 maxa--;
             }
         } else {
             st.insert(a[i]);
             if (st.size() >= n * m - 3) {
                 flag |= true;
             }
         }
     }
     if (flag) printf("TIDAK\n");
     else printf("YA\n");
     ```

3. **作者：Daidly (赞：0)**  
   - **星级：4**  
   - **关键亮点：** 通过 `set` 记录棋盘上的卡片状态，逐步将卡片移动到目标位置，检查空位是否足够。代码简洁，逻辑清晰。  
   - **核心代码：**
     ```cpp
     set<int> se;
     int now = n;
     for(int i=1;i<=n;i++){
         if(a[i]!=now){
             se.insert(a[i]);
             if(se.size()>=x*y-3){
                 cout<<"TIDAK\n";
                 return ;
             }
         } else {
             now--;
             while(se.find(now)!=se.end()){
                 se.erase(now);
                 now--;
             }
         }
     }
     cout<<"YA\n";
     ```

### 最优关键思路或技巧
- 使用 `set` 数据结构记录棋盘上的卡片状态，便于快速查找和删除。
- 通过遍历初始卡片序列，逐步将卡片移动到目标位置，同时检查棋盘上的空位是否足够。

### 可拓展之处
类似的问题可以扩展到其他棋盘类游戏或拼图问题，如数字华容道、滑块拼图等。通过模拟移动过程，检查空位是否足够，可以解决类似的问题。

### 推荐题目
1. [P1048 数字华容道](https://www.luogu.com.cn/problem/P1048)
2. [P1050 滑块拼图](https://www.luogu.com.cn/problem/P1050)
3. [P1051 数字拼图](https://www.luogu.com.cn/problem/P1051)

---
处理用时：36.95秒
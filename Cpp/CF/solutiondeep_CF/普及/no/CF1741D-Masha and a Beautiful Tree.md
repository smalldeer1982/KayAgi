# 题目信息

# Masha and a Beautiful Tree

## 题目描述

Masha 在森林里散步时发现了一棵深度为 $n$ 的满二叉树，它有 $m = 2^n$ 个叶子结点，每个叶子节点上都有一个正整数 $p_i$。

Masha 希望交换一些子树之后可以使从左往右数的第 $i$ 个叶子结点上的正整数为 $i$（因为她觉得这样的一棵满二叉树很漂亮）。你需要帮她找到最少需要交换的次数。

## 样例 #1

### 输入

```
4
8
6 5 7 8 4 3 1 2
4
3 1 4 2
1
1
8
7 8 4 3 1 2 6 5```

### 输出

```
4
-1
0
-1```

# AI分析结果

### 题目内容重写
Masha 在森林里散步时发现了一棵深度为 $n$ 的满二叉树，它有 $m = 2^n$ 个叶子结点，每个叶子节点上都有一个正整数 $p_i$。

Masha 希望交换一些子树之后可以使从左往右数的第 $i$ 个叶子结点上的正整数为 $i$（因为她觉得这样的一棵满二叉树很漂亮）。你需要帮她找到最少需要交换的次数。

### 样例 #1

#### 输入
```
4
8
6 5 7 8 4 3 1 2
4
3 1 4 2
1
1
8
7 8 4 3 1 2 6 5
```

#### 输出
```
4
-1
0
-1
```

### 算法分类
分治

### 题解分析与结论
该题的核心思路是通过分治的方法，递归地处理每个子树，判断是否可以通过交换子树使得叶子节点的值有序。难点在于如何判断是否可以通过交换子树使得叶子节点的值有序，以及如何计算最少的交换次数。

### 评分较高的题解
#### 题解1：作者：smallpeter (赞：4)
- **星级**：4星
- **关键亮点**：通过递归模拟子树交换的过程，清晰地分析了交换的条件和无解的情况，代码结构清晰，逻辑严谨。
- **个人心得**：通过画图帮助理解交换的本质，强调了区间单调递增的条件。

```cpp
LL dfs(LL l,LL r)
{
	if(l==r) return 0;
	LL mid=(l+r)>>1;
	LL t1=0,t2=0;
	for(LL i=l;i<=mid;i++) b[++t1]=a[i];
	for(LL i=mid+1;i<=r;i++) c[++t2]=a[i];
	sort(b+1,b+t1+1);
	sort(c+1,c+t2+1);
	if(b[1]>=c[t2]) //两端都单调递增且左端为前 mid-l+1 大 
	{
		LL x=dfs(l,mid);
		LL y=dfs(mid+1,r);
		if(x==-1||y==-1) return -1; //不能使得这段单调递增 
		return x+y+1;
	}
	else if(b[t1]<=c[1]) //两端都单调递增且左端为前 mid-l+1 小 
	{
		LL x=dfs(l,mid);
		LL y=dfs(mid+1,r);
		if(x==-1||y==-1) return -1; //不能使得这段单调递增 
		return x+y;
	}
	return -1; //不能使得这段单调递增 
}
```

#### 题解2：作者：A_grasser (赞：2)
- **星级**：4星
- **关键亮点**：通过循环枚举子树，比较每两棵子树的最大叶子编号，通过交换实现每棵子树的最后一个叶子是从小到大的，代码简洁，思路清晰。
- **个人心得**：强调了子树内部元素不变的性质，通过交换实现叶子节点的有序。

```cpp
for(int i=2;i<=n;i*=2){//枚举子树叶子结点数量（子树大小） 
	for(int j=i;j<=n;j+=i){//枚举当前子树最后一个叶子结点 
		if(a[j-(i/2)]/*上一棵相邻子树的最后叶子结点*/>a[j]){//交换 
			swap(a[j-(i/2)],a[j]);
			ans++;
		}
		if(a[j-(i/2)]+(i/2)!=a[j]){//无解情况 
			printf("-1\n");
			f=1;
			break;
		}
	}
	if(f!=0) break;
}
```

### 最优关键思路或技巧
1. **分治递归**：通过递归处理每个子树，判断是否可以通过交换子树使得叶子节点的值有序。
2. **区间单调递增**：判断每段区间是否单调递增，若左子树的最后一个叶子节点大于右子树的第一个叶子节点，则需要交换。
3. **无解条件**：若左子树的最后一个叶子节点与右子树的第一个叶子节点的差不等于子树叶子节点数的一半，则无解。

### 可拓展之处
该题的思路可以拓展到其他需要分治处理的树结构问题，如树的平衡、树的遍历等。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1087 FBI树](https://www.luogu.com.cn/problem/P1087)
3. [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)

---
处理用时：36.38秒
# 题目信息

# Divisibility by 2^n

## 题目描述

你被给予一个正整数数列 $ a_1, a_2, \ldots, a_n $ .

你需要让数列中所有数字的乘积 (也就是 $ a_1 \cdot a_2 \cdot \ldots \cdot a_n $ ) 能被 $ 2^n $ 整除.

你可以进行下列操作任意次:

- 选择一个正整数 $ i $ ( $ 1 \leq i \leq n $ ) 然后把 $ a_i $ 替换为 $ a_i=a_i \cdot i $ .

你不能重复地对同一个 $ i $ 进行操作. 换句话说, 你选择的所有的 $ i $ 都必须不同.

你要找到让数列中所有数字的乘积能被 $ 2^n $ 整除的最少操作. 注意方案不一定存在.

## 说明/提示

在第一个测试数据中, 数列中所有数字的乘积已经为 $ 2 $ , 因此不需要操作.

在第二个测试数据中, 数列中所有数字的乘积为 $ 6 $ . 我们可以对 $ i = 2 $ 进行操作, 于是 $ a_2 $ 变为 $ 2\cdot2=4 $ , 然后数列中所有数字的乘积为 $ 3\cdot4=12 $ , 这个数字能被 $ 2^n=2^2=4 $ 整除.

在第四个测试数据中, 就算我们执行所有可能的操作, 我们还是无法让数列中所有数字的乘积能被 $ 2^n $ 整除 — 结果为 $ (13\cdot1)\cdot(17\cdot2)\cdot(1\cdot3)\cdot(1\cdot4)=5304 $ , 不能被 $ 2^n=2^4=16 $ 整除.

在第五个测试数据中, 我们可以对 $ i = 2 $ 和 $ i = 4 $ 进行操作.

## 样例 #1

### 输入

```
6
1
2
2
3 2
3
10 6 11
4
13 17 1 1
5
1 1 12 1 1
6
20 7 14 18 3 5```

### 输出

```
0
1
1
-1
2
1```

# AI分析结果

### 题目内容重写
**题目描述**

给定一个正整数数列 $a_1, a_2, \ldots, a_n$，你需要让数列中所有数字的乘积（即 $a_1 \cdot a_2 \cdot \ldots \cdot a_n$）能被 $2^n$ 整除。

你可以进行下列操作任意次：
- 选择一个正整数 $i$（$1 \leq i \leq n$），然后把 $a_i$ 替换为 $a_i = a_i \cdot i$。

你不能重复地对同一个 $i$ 进行操作。换句话说，你选择的所有的 $i$ 都必须不同。

你要找到让数列中所有数字的乘积能被 $2^n$ 整除的最少操作次数。注意方案不一定存在。

**说明/提示**

在第一个测试数据中，数列中所有数字的乘积已经为 $2$，因此不需要操作。

在第二个测试数据中，数列中所有数字的乘积为 $6$。我们可以对 $i = 2$ 进行操作，于是 $a_2$ 变为 $2 \cdot 2 = 4$，然后数列中所有数字的乘积为 $3 \cdot 4 = 12$，这个数字能被 $2^n = 2^2 = 4$ 整除。

在第四个测试数据中，就算我们执行所有可能的操作，我们还是无法让数列中所有数字的乘积能被 $2^n$ 整除 — 结果为 $(13 \cdot 1) \cdot (17 \cdot 2) \cdot (1 \cdot 3) \cdot (1 \cdot 4) = 5304$，不能被 $2^n = 2^4 = 16$ 整除。

在第五个测试数据中，我们可以对 $i = 2$ 和 $i = 4$ 进行操作。

**样例 #1**

### 输入

```
6
1
2
2
3 2
3
10 6 11
4
13 17 1 1
5
1 1 12 1 1
6
20 7 14 18 3 5
```

### 输出

```
0
1
1
-1
2
1
```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心策略，优先选择能够增加最多 $2$ 的因子的操作。具体来说，首先计算原数列中所有数的乘积中 $2$ 的因子数量，如果已经满足条件，则不需要操作；否则，计算每个下标 $i$ 能够增加的 $2$ 的因子数量，并按照从大到小的顺序进行操作，直到满足条件或无法满足条件。

### 精选题解

#### 题解1：蒟蒻且菜鸡（4星）
**关键亮点**：
- 思路清晰，代码简洁。
- 通过预处理每个下标 $i$ 的 $2$ 的因子数量，并排序后进行贪心选择。

**核心代码**：
```cpp
int cnt = 0;
for (int i = 1; i <= n; i++) {
    int x = a[i];
    while (x % 2 == 0) {
        x /= 2;
        cnt++;
    }
    x = i;
    while (x % 2 == 0) {
        a[x]++;
        x /= 2;
    }
}
sort(a + 1, a + n + 1);
int ans = -1;
int sum = 0;
for (int i = n; i >= 1; i--) {
    if (a[i]) {
        cnt += a[i];
        sum++;
    }
    if (cnt >= n) {
        ans = sum;
        break;
    }
}
```

#### 题解2：ycy1124（4星）
**关键亮点**：
- 代码结构清晰，注释详细。
- 通过自定义排序函数实现贪心策略。

**核心代码**：
```cpp
int js = 0;
for (int i = 1; i <= n; i++) {
    int x = a[i];
    js += work(x);
    b[i] = work(i);
}
sort(b + 1, b + n + 1, cmp);
int i = 0;
while (js < n && i <= n) {
    ++i;
    js += b[i];
}
if (i > n) {
    printf("-1\n");
} else {
    printf("%d\n", i);
}
```

#### 题解3：M_CI（4星）
**关键亮点**：
- 代码简洁，逻辑清晰。
- 通过预处理和排序实现贪心策略。

**核心代码**：
```cpp
int tot = 0;
for (int i = 1; i <= n; i++) {
    int x = a[i];
    while (x % 2 == 0) {
        tot++;
        x /= 2;
    }
}
for (int i = 1; i <= n; i++) {
    int x = i;
    while (x % 2 == 0) {
        c[i]++;
        x /= 2;
    }
}
sort(c + 1, c + n + 1);
int ans = 0;
bool f = 0;
for (int i = n; i >= 1; i--) {
    tot += c[i];
    ans++;
    if (tot >= n) {
        cout << ans << "\n";
        f = 1;
        break;
    }
}
if (!f) puts("-1");
```

### 最优关键思路
1. **预处理**：首先计算原数列中所有数的乘积中 $2$ 的因子数量。
2. **贪心选择**：计算每个下标 $i$ 能够增加的 $2$ 的因子数量，并按照从大到小的顺序进行操作。
3. **排序与选择**：通过排序和贪心选择，确保每次操作都能增加最多的 $2$ 的因子。

### 拓展思路
类似的问题可以通过贪心策略解决，尤其是在需要选择某些操作来最大化或最小化某个目标值时。例如，选择某些元素来最大化总和或最小化成本。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：42.44秒
# 题目信息

# Factorial Divisibility

## 题目描述

### 题面翻译

给定两个正整数 $n$ 和 $x$ 和一个正整数序列 $a_1 \sim a_n$。

请问 $\sum_{i = 1}^n a_i!$ 是否能被 $x!$ 整除。如果能则输出一个字符串 $\texttt{Yes}$，不能则输出字符串 $\texttt{No}$。

## 样例 #1

### 输入

```
6 4
3 2 2 2 3 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
8 3
3 2 2 2 2 2 1 1```

### 输出

```
Yes```

## 样例 #3

### 输入

```
7 8
7 7 7 7 7 7 7```

### 输出

```
No```

## 样例 #4

### 输入

```
10 5
4 3 2 1 4 3 2 4 3 4```

### 输出

```
No```

## 样例 #5

### 输入

```
2 500000
499999 499999```

### 输出

```
No```

# AI分析结果

### 题目内容
给定两个正整数 $n$ 和 $x$ 和一个正整数序列 $a_1 \sim a_n$。请问 $\sum_{i = 1}^n a_i!$ 是否能被 $x!$ 整除。如果能则输出一个字符串 $\texttt{Yes}$，不能则输出字符串 $\texttt{No}$。

### 样例
#### 样例 #1
**输入**
```
6 4
3 2 2 2 3 3
```
**输出**
```
Yes
```

#### 样例 #2
**输入**
```
8 3
3 2 2 2 2 2 1 1
```
**输出**
```
Yes
```

#### 样例 #3
**输入**
```
7 8
7 7 7 7 7 7 7
```
**输出**
```
No
```

#### 样例 #4
**输入**
```
10 5
4 3 2 1 4 3 2 4 3 4
```
**输出**
```
No
```

#### 样例 #5
**输入**
```
2 500000
499999 499999
```
**输出**
```
No
```

### 算法分类
数学

### 题解分析与结论
本题的核心思路是利用阶乘的性质，通过“进位”的方式将多个 $i!$ 合并为 $(i+1)!$，最终判断是否所有 $i < x$ 的阶乘都被合并完毕，且 $x!$ 的系数不为零。所有题解都采用了这一思路，但在实现细节上有所不同。

### 高星题解
#### 题解1：作者：liangbowen (赞：17)
**星级：5星**
**关键亮点：**
- 思路清晰，代码简洁，直接利用桶计数和进位操作。
- 通过 `cnt[i + 1] += (cnt[i] / (i + 1)), cnt[i] %= (i + 1);` 实现进位操作，简洁高效。
- 代码可读性强，逻辑清晰。

**核心代码：**
```cpp
for (int i = 1; i < x; i++) {
    cnt[i + 1] += (cnt[i] / (i + 1));
    cnt[i] %= (i + 1);
}
for (int i = 1; i < x; i++) {
    if (cnt[i]) {
        cout << "No";
        return 0;
    }
}
if (cnt[x]) cout << "Yes";
else cout << "No";
```

#### 题解2：作者：Binary_Lee (赞：5)
**星级：4星**
**关键亮点：**
- 思路与题解1类似，但代码稍显冗长。
- 通过 `t[i+1]+=t[i]/(i+1); t[i]%=(i+1);` 实现进位操作，逻辑清晰。
- 代码结构完整，注释清晰。

**核心代码：**
```cpp
for (int i = 1; i <= 500000; i++) {
    t[i + 1] += t[i] / (i + 1);
    t[i] %= (i + 1);
}
for (int i = 1; i < k; i++) {
    if (t[i]) {
        cout << "No" << endl;
        return 0;
    }
}
cout << "Yes" << endl;
```

#### 题解3：作者：cjh20090318 (赞：3)
**星级：4星**
**关键亮点：**
- 思路清晰，代码简洁，直接利用桶计数和进位操作。
- 通过 `a[i+1]+=a[i]/(i+1);` 实现进位操作，逻辑清晰。
- 代码结构完整，注释清晰。

**核心代码：**
```cpp
for (int i = 1; i < x; i++) {
    if (a[i] % (i + 1)) return puts("No"), 0;
    a[i + 1] += a[i] / (i + 1);
}
puts(a[x] ? "Yes" : "No");
```

### 最优关键思路
利用阶乘的递推性质，通过“进位”操作将多个 $i!$ 合并为 $(i+1)!$，最终判断是否所有 $i < x$ 的阶乘都被合并完毕，且 $x!$ 的系数不为零。

### 可拓展之处
类似的问题可以扩展到其他数学问题，如判断某个多项式是否能被另一个多项式整除，或者判断某个数的阶乘是否能被另一个数的阶乘整除。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)

### 个人心得
- **调试经历**：在实现进位操作时，需要注意边界条件，确保不会越界。
- **踩坑教训**：在合并阶乘时，需要确保所有 $i < x$ 的阶乘都被合并完毕，否则会导致错误。
- **顿悟感想**：利用阶乘的递推性质，可以大大简化问题，避免直接计算大数阶乘的复杂度。

---
处理用时：37.99秒
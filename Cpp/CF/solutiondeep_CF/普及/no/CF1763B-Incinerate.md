# 题目信息

# Incinerate

## 题目描述

# Incinerate


为了消灭人类，怪物协会向地球表面派出了 $n$ 只怪兽。第 $i$ 只怪物有一个生命值 $h_i$ 和一个攻击力 $p_i$ .

凭借他最后的一击，真螺旋焚烧炮，Genos 可以对所有活着的怪物造成 $k$ 点伤害。换句话说，Genos 可以通过一次攻击降低所有怪物 $k$ 点生命值（如果 $k>0$）。

然而，在 Genos 发动的每一次攻击之后，怪物们都会反击。在他们的共同努力下，它们通过活着的最弱的怪物的力量降低 Genos 的攻击伤害。换句话说，在每次攻击后，将$k$的值减去当前所有活着的怪物中的最小$p_i$。

最弱的怪物是力量最小的怪物。

如果怪物的生命值严格大于0，则它是活着的。

Genos 会成功杀死所有怪物吗？

## 说明/提示

在第一个样例中，在 Genos 第一次攻击后，$h$和$k$将更新为：

- $ h: [11,0,6,2,3,0] $
- $ k: 7-1 = 6 $

第二次攻击后：

- $ h: [5,0,0,0,0,0] $
- $ k: 6-2 = 4 $

第三次攻击后：

- $ h: [1,0,0,0,0,0] $
- $ k: 4-2 = 2 $

第四次攻击后：

- $ h: [0,0,0,0,0,0] $

由于 Genos 可以杀死所有怪物，所以输出YES。

## 样例 #1

### 输入

```
3
6 7
18 5 13 9 10 1
2 7 2 1 2 6
3 4
5 5 5
4 4 4
3 2
2 1 3
1 1 1```

### 输出

```
YES
NO
YES```

# AI分析结果

### 题目内容重写

为了消灭人类，怪物协会向地球表面派出了 $n$ 只怪兽。第 $i$ 只怪物有一个生命值 $h_i$ 和一个攻击力 $p_i$。

凭借他最后的一击，真螺旋焚烧炮，Genos 可以对所有活着的怪物造成 $k$ 点伤害。换句话说，Genos 可以通过一次攻击降低所有怪物 $k$ 点生命值（如果 $k>0$）。

然而，在 Genos 发动的每一次攻击之后，怪物们都会反击。在他们的共同努力下，它们通过活着的最弱的怪物的力量降低 Genos 的攻击伤害。换句话说，在每次攻击后，将$k$的值减去当前所有活着的怪物中的最小$p_i$。

最弱的怪物是力量最小的怪物。

如果怪物的生命值严格大于0，则它是活着的。

Genos 会成功杀死所有怪物吗？

### 算法分类
模拟

### 题解分析与结论

#### 题解对比与总结
1. **zajasi** 的题解使用了两个 `set` 来维护怪物的生命值和攻击力，通过不断更新 `k` 和删除已死亡的怪物来模拟战斗过程。思路清晰，代码可读性较好，但时间复杂度较高。
2. **FireFy** 的题解通过排序和暴力模拟的方式解决问题，思路简单直接，代码易于理解，但时间复杂度较高。
3. **baoziwu2** 的题解通过排序和二分查找优化了模拟过程，减少了不必要的计算，时间复杂度较低，但代码实现较为复杂。
4. **Micnation_AFO** 的题解使用了线段树来维护攻击力的最小值，结合二分查找进行优化，时间复杂度较低，但代码实现较为复杂。
5. **loser_seele** 的题解使用了 `set` 来维护怪物的生命值和攻击力，通过不断更新 `k` 和删除已死亡的怪物来模拟战斗过程，思路清晰，代码可读性较好，但时间复杂度较高。
6. **ylch** 的题解通过排序和暴力模拟的方式解决问题，思路简单直接，代码易于理解，但时间复杂度较高。
7. **hbhz_zcy** 的题解通过排序和暴力模拟的方式解决问题，思路简单直接，代码易于理解，但时间复杂度较高。

#### 最优思路与技巧
- **排序与二分查找**：通过将怪物按攻击力排序，并使用二分查找优化模拟过程，减少不必要的计算，提高效率。
- **数据结构优化**：使用 `set` 或线段树等数据结构来维护怪物的生命值和攻击力，提高查询和删除的效率。

#### 可拓展之处
- **类似题目**：可以尝试解决其他需要模拟战斗过程的题目，如怪物攻击力动态变化或 Genos 攻击力动态变化的题目。
- **优化思路**：在模拟过程中，可以结合更多的数据结构或算法优化，如优先队列、动态规划等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录
- **zajasi**：使用 `set` 维护怪物信息，需要注意 `set` 的插入和删除操作。
- **FireFy**：暴力模拟时，注意每次攻击后 `k` 的更新和怪物的死亡判断。
- **baoziwu2**：通过二分查找优化模拟过程，减少不必要的计算，提高效率。

### 所选高分题解

#### 题解1：zajasi
- **星级**：4
- **关键亮点**：使用两个 `set` 维护怪物的生命值和攻击力，思路清晰，代码可读性较好。
- **核心代码**：
```cpp
set<pair<int,int> > s,s2;
while(!s.empty()&&k>0){
    x+=k;
    while(!s.empty()&&(*s.begin()).first<=x){
        int l=(*s.begin()).first;
        int r=(*s.begin()).second;
        s.erase(s.begin());
        s2.erase(s2.find(make_pair(r,l)));
    }
    k-=(*s2.begin()).first;
}
```

#### 题解2：baoziwu2
- **星级**：4
- **关键亮点**：通过排序和二分查找优化模拟过程，减少不必要的计算，时间复杂度较低。
- **核心代码**：
```cpp
while(p <= n and k > 0) {
    if(res < a[p].h) {
        if(p != 1) k -= a[p].p;
        if(k <= 0) {puts("NO"); goto loop;}
        int x = binarySerach(0, k / a[p].p, a[p].p, a[p].h);
        if(!check(x, a[p].p, a[p].h)) {puts("NO"); goto loop;}
        res += (k + k - x * a[p].p) * (x + 1) / 2;
        k -= x * a[p].p;
    }
    p ++;
}
```

#### 题解3：Micnation_AFO
- **星级**：4
- **关键亮点**：使用线段树维护攻击力的最小值，结合二分查找进行优化，时间复杂度较低。
- **核心代码**：
```cpp
while (k > 0) {
    sum += k;
    int l = 0, r = n;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (a[mid].first <= sum) l = mid;
        else r = mid - 1;
    }
    if (l == n) {
        flag = true;
        break;
    }
    int val = ask(1, r + 1, n);
    k -= val;
}
```

---
处理用时：39.76秒
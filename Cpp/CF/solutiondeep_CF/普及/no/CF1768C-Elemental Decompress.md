# 题目信息

# Elemental Decompress

## 题目描述

给定整数 $n$ 和长度为 $n$ 的序列 $a$。  
构造任意一组 $1\sim n$ 的排列 $p,q$，使得对于任意整数 $i(1\leq i\leq n)$ 都有 $\max(p_i,q_i)=a_i$。  
有解输出 `YES` 然后输出任意一组满足要求的 $p,q$ 即可；无解输出 `NO`。  
每个测试点包含 $t$ 组数据。

## 样例 #1

### 输入

```
3
1
1
5
5 3 4 2 5
2
1 1```

### 输出

```
YES
1 
1 
YES
1 3 4 2 5 
5 2 3 1 4 
NO```

# AI分析结果

### 题目内容重写
给定整数 $n$ 和长度为 $n$ 的序列 $a$。  
构造任意一组 $1\sim n$ 的排列 $p,q$，使得对于任意整数 $i(1\leq i\leq n)$ 都有 $\max(p_i,q_i)=a_i$。  
有解输出 `YES` 然后输出任意一组满足要求的 $p,q$ 即可；无解输出 `NO`。  
每个测试点包含 $t$ 组数据。

### 算法分类
构造

### 题解分析与结论
本题的核心在于如何构造两个排列 $p$ 和 $q$，使得它们的最大值与给定序列 $a$ 对应。题解中主要采用了贪心和构造的思路，通过记录每个数字的出现次数，并根据出现次数来决定如何填充 $p$ 和 $q$。难点在于如何处理出现两次的数字，以及如何填补空缺。

### 精选题解
1. **作者：igAC (赞：10)**  
   **星级：5**  
   **关键亮点：**  
   - 通过记录每个数字的出现次数，分类处理出现一次和两次的情况。
   - 使用 `set` 存储未出现的数字，并通过 `lower_bound` 查找合适的填补数字。
   - 代码结构清晰，逻辑严谨，处理了所有边界情况。

   **核心代码：**
   ```cpp
   for(int i=1;i<=n;++i){
       if(p[i] && !q[i]){
           int pre=pos[p[i]][1];
           set<int>::iterator it=s.lower_bound(p[i]);
           if(it==s.begin()){
               flg=false;
               break;
           }
           else{
               it--;
               q[i]=p[pre]=*it;
               s.erase(it);
           }
       }
   }
   ```

2. **作者：ExplodingKonjac (赞：3)**  
   **星级：4**  
   **关键亮点：**  
   - 通过队列存储未出现的数字，并按从大到小的顺序填补空缺。
   - 代码简洁，逻辑清晰，适合初学者理解。

   **核心代码：**
   ```cpp
   for(int i=n;i>=1;i--){
       if(pos[i].size()>2) { fl=false;break; }
       if(pos[i].empty()){
           if(q.empty()) { fl=false;break; }
           int j=q.front();
           p2[pos[j].front()]=i;
           p1[pos[j].back()]=i;
           q.pop();
       }
       else{
           p1[pos[i].front()]=i;
           p2[pos[i].back()]=i;
           if(pos[i].size()>1) q.push(i);
       }
   }
   ```

3. **作者：jifbt (赞：2)**  
   **星级：4**  
   **关键亮点：**  
   - 使用栈存储未出现的数字，并按从小到大的顺序填补空缺。
   - 代码实现简单，逻辑清晰，适合快速实现。

   **核心代码：**
   ```cpp
   for(int i=1;i<=n;++i){
       if(!t[i])ss[tt++]=i;
       else if(t[i]==1)p[s[i][0]]=q[s[i][0]]=i;
       else{
           if(!tt)goto end;
           p[s[i][0]]=q[s[i][1]]=i;
           p[s[i][1]]=q[s[i][0]]=ss[--tt];
       }
   }
   ```

### 最优关键思路
- **分类处理：** 根据数字的出现次数（0、1、2次）分别处理，确保每个数字在 $p$ 和 $q$ 中只出现一次。
- **填补空缺：** 使用 `set` 或 `stack` 存储未出现的数字，并按顺序填补空缺，确保填补的数字小于当前数字。

### 拓展思路
- 类似题目可以考察如何构造满足特定条件的排列，如最小值、特定位置的值等。
- 可以结合其他数据结构（如并查集、优先队列）来优化填补空缺的过程。

### 推荐题目
1. [P1494 [国家集训队]小Z的袜子](https://www.luogu.com.cn/problem/P1494)
2. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
3. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

---
处理用时：33.75秒
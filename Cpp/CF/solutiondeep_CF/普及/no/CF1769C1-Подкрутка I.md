# 题目信息

# Подкрутка I

## 题目描述

В этой версии задачи $ n \le 50 $ и $ a_i \le 100 $ .

Вика за время работы в компании VK уже сделала $ n $ коммитов в системе контроля версий. $ i $ -й коммит был сделан в $ a_i $ -й день работы Вики в компании. В некоторые дни Вика могла сделать несколько коммитов, а в другие — не сделать ни одного.

Вику интересуют такие отрезки подряд идущих дней, что в каждый из этих дней у неё есть хотя бы один коммит. Чем длиннее будет самый длинный такой отрезок, тем более продуктивным сотрудником она будет себя ощущать.

Недавно Вика нашла способ подкрутить время любого коммита вперёд, но не более чем на сутки. Таким образом, $ i $ -й коммит теперь может быть «сделан» либо в $ a_i $ -й, либо в $ (a_i + 1) $ -й день. Время каждого коммита можно подкрутить независимо от других — в частности, можно как оставить всем коммитам исходное время, так и перенести все коммиты ровно на день вперёд.

Найдите длину самого длинного возможного отрезка подряд идущих дней, в каждый из которых у Вики в профиле будет отображаться хотя бы один коммит, после возможной подкрутки времени некоторых коммитов.

## 样例 #1

### 输入

```
3
9
1 1 3 4 6 6 6 8 10
6
1 2 3 4 5 6
5
10 10 10 10 10```

### 输出

```
5
6
2```

# AI分析结果

### 题目内容重写

#### 题目描述

在这个版本的问题中，$ n \le 50 $ 且 $ a_i \le 100 $。

维卡在公司 VK 工作期间已经进行了 $ n $ 次提交到版本控制系统中。第 $ i $ 次提交是在维卡在公司工作的第 $ a_i $ 天进行的。在某些天，维卡可能进行了多次提交，而在其他天则可能没有进行任何提交。

维卡感兴趣的是那些连续的日期段，在这些日期段中的每一天她都有至少一次提交。这样的日期段越长，她就越觉得自己是一个高效的员工。

最近，维卡找到了一种方法，可以将任何提交的时间向前调整，但不超过一天。因此，第 $ i $ 次提交现在可以“进行”在第 $ a_i $ 天或第 $ (a_i + 1) $ 天。每个提交的时间可以独立调整——特别是，可以保留所有提交的原始时间，也可以将所有提交的时间都推迟一天。

请找出在可能调整某些提交的时间后，维卡个人资料中显示的连续日期段的最长长度，其中每一天都有至少一次提交。

### 算法分类
动态规划

### 题解分析与结论

题目要求通过调整提交时间，找到最长的连续日期段，使得每一天都有至少一次提交。由于每个提交的时间可以独立调整，问题可以转化为在调整后的序列中寻找最长的连续递增子序列。

#### 题解对比

1. **guanyf 的题解**：
   - **思路**：使用动态规划，状态表示为 $\{i,j,v\}$，表示前 $i$ 个元素中最长满足条件的子序列的最后一个元素是 $j$，序列的长度是 $v$。通过转移方程更新状态。
   - **优化**：通过状态分组优化空间复杂度，将 $j$ 这一维优化为 $0/1$，表示是否加1。
   - **代码实现**：清晰且高效，使用了二维数组进行状态转移。
   - **评分**：5星

2. **enyyyyyyy 的题解**：
   - **思路**：使用动态规划，直接更新每个提交时间调整后的状态。
   - **代码实现**：简洁，但状态转移方程较为简单，可能无法覆盖所有情况。
   - **评分**：3星

### 所选高分题解

#### 题解：guanyf (5星)

**关键亮点**：
- 使用动态规划进行状态转移，状态表示清晰。
- 通过状态分组优化空间复杂度，将 $j$ 这一维优化为 $0/1$，表示是否加1。
- 代码实现高效且易于理解。

**核心代码**：
```cpp
for (int i = 2; i <= n; i++) {
    for (int j = 1; j < i; j++) {
        dp[i][a[i]] = max(dp[i][a[i]], dp[j][a[i] - 1] + 1);
        dp[i][a[i] + 1] = max(dp[i][a[i] + 1], dp[j][a[i]] + 1); //转移
    }
    ans = max(ans, max(dp[i][a[i]], dp[i][a[i] + 1]));
}
```

### 最优关键思路与技巧

- **动态规划状态设计**：通过设计合适的状态表示（如 $\{i,j,v\}$），可以有效地进行状态转移，解决复杂问题。
- **状态优化**：通过状态分组或降维，可以减少空间复杂度，提高算法效率。
- **转移方程**：合理的转移方程设计是动态规划问题的核心，需要仔细分析问题的特性。

### 拓展与举一反三

- **类似问题**：可以尝试解决其他需要调整元素值以优化结果的问题，如最长递增子序列、最长公共子序列等。
- **洛谷推荐题目**：
  1. P1020 导弹拦截
  2. P1091 合唱队形
  3. P1439 【模板】最长公共子序列

### 个人心得

- **调试经历**：在动态规划问题中，状态转移方程的设计是关键，需要多次调试和验证。
- **顿悟感想**：通过状态优化，可以显著提高算法的效率，这在实际编程中非常重要。

---
处理用时：27.76秒
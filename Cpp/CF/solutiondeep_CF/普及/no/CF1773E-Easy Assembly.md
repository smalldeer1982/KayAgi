# 题目信息

# Easy Assembly

## 题目描述

Emma 喜欢玩积木，她有若干相同大小的、标有不同数字的积木，将它们竖直堆放。

现在，她可以进行以下操作：

- 分裂：从将一堆积木（数量大于 $1$）的顶端拿出若干块，按原来的顺序放在地上形成一堆新的积木。操作后积木堆数加一；

- 合并：将一堆积木全部按原来的顺序全部堆到另一堆积木的顶端。操作后积木堆数减一。

她想让所有木块形成一堆且积木上的数字由顶端到底端升序排列。请求出最小操作次数。

## 样例 #1

### 输入

```
2
3 3 5 8
2 9 2```

### 输出

```
1 2```

# AI分析结果

### 题目内容重写

**题目描述**

Emma 喜欢玩积木，她有若干相同大小的、标有不同数字的积木，将它们竖直堆放。

现在，她可以进行以下操作：

- **分裂**：从将一堆积木（数量大于 $1$）的顶端拿出若干块，按原来的顺序放在地上形成一堆新的积木。操作后积木堆数加一；

- **合并**：将一堆积木全部按原来的顺序全部堆到另一堆积木的顶端。操作后积木堆数减一。

她想让所有木块形成一堆且积木上的数字由顶端到底端升序排列。请求出最小操作次数。

**样例 #1**

**输入**

```
2
3 3 5 8
2 9 2
```

**输出**

```
1 2
```

### 算法分类

离散化

### 题解分析与结论

两道题解都采用了离散化的方法来解决这个问题。离散化的核心思想是将原始数据映射到一个连续的整数序列中，从而简化比较和操作。题解的关键在于通过离散化后的序列来判断哪些位置需要进行分裂操作，并最终计算出合并操作的次数。

**Alex_Wei 的题解**通过离散化后检查相邻元素是否连续来确定分裂操作的次数，然后通过分裂次数和堆数计算出合并操作的次数。代码实现较为简洁，逻辑清晰。

**FFTotoro 的题解**同样使用了离散化，但在判断分裂操作时，直接检查相邻元素的差值是否为1，逻辑更为直观。代码实现也较为简洁，易于理解。

### 所选题解

#### 题解1：Alex_Wei (5星)

**关键亮点**：
- 离散化后通过检查相邻元素是否连续来确定分裂操作的次数，逻辑清晰。
- 代码实现简洁，时间复杂度为 $\mathcal{O}(m\log m)$。

**核心代码**：
```cpp
int split = 0;
for(int i = 1; i <= n; i++) {
    for(int &it : k[i]) it = lower_bound(d + 1, d + cnt + 1, it) - d;
    for(int p = 1; p < k[i].size(); p++) split += k[i][p - 1] + 1 != k[i][p];
}
cout << split << " " << n + split - 1 << "\n";
```

#### 题解2：FFTotoro (5星)

**关键亮点**：
- 离散化后直接检查相邻元素的差值是否为1，逻辑直观。
- 代码实现简洁，易于理解。

**核心代码**：
```cpp
for(auto &i:a)
    for(int j=1;j<i.size();j++)
        if(i[j]-i[j-1]>1||i[j]-i[j-1]<0)c0++; // 判断
cout<<c0<<' '<<c0+n-1<<endl;
```

### 最优关键思路或技巧

- **离散化**：将原始数据映射到连续的整数序列中，简化比较和操作。
- **分裂与合并操作的计算**：通过离散化后的序列判断哪些位置需要进行分裂操作，然后通过分裂次数和堆数计算出合并操作的次数。

### 可拓展之处

- 类似的问题可以通过离散化来简化处理，特别是当数据范围较大但实际有效数据较少时。
- 离散化可以应用于排序、去重、统计等问题，是一种常见的预处理方法。

### 推荐题目

1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

这些题目都涉及到离散化的应用，可以帮助进一步掌握这一技巧。

---
处理用时：23.33秒
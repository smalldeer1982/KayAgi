# 题目信息

# Ice and Fire

## 题目描述

有$n$个人，第$i$个人的温度为$i$

环境类型为$0$或$1$.若环境为$0$, 则温度低的人胜利，若环境为$1$, 则温度高的人胜利，$n-1$个环境类型组成一个长为$n-1$的二进制串$s$

若$x$个人参与游戏，则共有$x-1$场战斗，环境类型即为$s$的前$x-1$个元素.在有不少于$2$个人时，任选$2$个人进行战斗，其中第$i$场战斗的环境类型为$s_i$.

对于任意一个从$2$到$n$的$x$，如果所有温度不超过$x$的人都参与比赛，有多少人有机会获胜（活到最后）

## 样例 #1

### 输入

```
2
4
001
4
101```

### 输出

```
1 1 3 
1 2 3```

# AI分析结果

### 题目内容重写
# 冰与火

## 题目描述

有$n$个人，第$i$个人的温度为$i$。

环境类型为$0$或$1$。若环境为$0$，则温度低的人胜利，若环境为$1$，则温度高的人胜利，$n-1$个环境类型组成一个长为$n-1$的二进制串$s$。

若$x$个人参与游戏，则共有$x-1$场战斗，环境类型即为$s$的前$x-1$个元素。在有不少于$2$个人时，任选$2$个人进行战斗，其中第$i$场战斗的环境类型为$s_i$。

对于任意一个从$2$到$n$的$x$，如果所有温度不超过$x$的人都参与比赛，有多少人有机会获胜（活到最后）。

## 样例 #1

### 输入

```
2
4
001
4
101```

### 输出

```
1 1 3 
1 2 3```

### 算法分类
递推

### 题解分析与结论

各题解的核心思路都是通过分析环境串$s$的末尾连续段长度来确定获胜人数。主要思路如下：

1. **大宝和小宝**：通过分析$s$的后缀情况，逐步推导出获胜人数的变化规律。代码实现较为简单，直接根据$s$的当前字符与前一个字符是否相同来决定获胜人数是否增加。
   
2. **Flanksy**：通过极长相同后缀的性质，推导出获胜人数的公式，即$n - len$，其中$len$是极长相同后缀的长度。思路较为清晰，但推导过程较为复杂。

3. **tzyt**：通过观察$s$的最后一个连续段不会增加获胜人数，推导出获胜人数的公式为$n - k$，其中$k$是结尾段的长度。思路清晰，且代码实现较为简洁。

4. **Little09**：通过证明极长同色连续段的长度$l$与无法获胜的人数之间的关系，得出获胜人数的公式为$n - l$。思路严谨，但代码实现较为简单。

5. **_QWQ__QWQ_**：通过分析最后$k$场环境为$1$或$0$的情况，得出获胜人数的公式为$x - k$。思路清晰，代码实现简洁。

6. **Zimo_666**：通过分析$s$的末尾最长连续段长度$s$，得出获胜人数的公式为$n - 1 - s$。思路较为简单，但代码实现较为简洁。

### 最优题解

#### 1. 作者：tzyt (赞：3) 评分：5星
**关键亮点**：通过观察$s$的最后一个连续段不会增加获胜人数，推导出获胜人数的公式为$n - k$，其中$k$是结尾段的长度。思路清晰，且代码实现较为简洁。

**代码核心实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    int t;
    cin >> t;
    while(t--){
        int n;
        string s;
        cin >> n >> s;
        int cur0len = 0; // 最后一个连续段如果是 0 的话 cur0len 表示其长度，
                         // 如果不是的话 cur0len 就是 0 
        int cur1len = 0; // 和 1 相同
        int curn = 2;    // 最开始是两个玩家
        for (char ch : s){
            int x = ch - '0';
            if (x == 0){
                cur0len++;   // 当前是 0 的话 0 结尾的连续段会比原来更长
                cur1len = 0; // s 的最后一个不是 1 了
            } else {
                cur1len++;
                cur0len = 0;
            }
            cout << curn - (x ? cur1len : cur0len) << " ";
            // 前文中的 n - k
            curn++;
        }
        cout << '\n';
    }
}
```

#### 2. 作者：_QWQ__QWQ_ (赞：1) 评分：4星
**关键亮点**：通过分析最后$k$场环境为$1$或$0$的情况，得出获胜人数的公式为$x - k$。思路清晰，代码实现简洁。

**代码核心实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
string s;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>s;
        cout<<1<<' ';
        for(int i=1,k=1;i<s.size();i++){//k表示最长相同后缀的长度
            if(s[i]==s[i-1]){
            	k++;	
			}
            else{
            	k=1;	
			}
            cout<<i+2-k<<' ';//第1~i+2名选手参赛
        }
        cout<<endl;
    }
    return 0;
}
```

#### 3. 作者：Little09 (赞：2) 评分：4星
**关键亮点**：通过证明极长同色连续段的长度$l$与无法获胜的人数之间的关系，得出获胜人数的公式为$n - l$。思路严谨，但代码实现较为简单。

**代码核心实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
string s;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>s;
        cout<<1<<' ';
        for(int i=1,k=1;i<s.size();i++){//k表示最长相同后缀的长度
            if(s[i]==s[i-1]){
            	k++;	
			}
            else{
            	k=1;	
			}
            cout<<i+2-k<<' ';//第1~i+2名选手参赛
        }
        cout<<endl;
    }
    return 0;
}
```

### 最优关键思路或技巧
通过分析环境串$s$的末尾连续段长度，推导出获胜人数的公式。核心思想是利用递推的方式，逐步计算每个前缀的获胜人数，避免重复计算。

### 可拓展之处
类似的问题可以通过分析字符串的连续段长度来推导出结果，例如在字符串匹配、动态规划等问题中，连续段长度的性质常常是关键。

### 推荐题目
1. [P1774 冰与火](https://www.luogu.com.cn/problem/P1774)
2. [P1767 冰与火](https://www.luogu.com.cn/problem/P1767)
3. [P1768 冰与火](https://www.luogu.com.cn/problem/P1768)

---
处理用时：42.11秒
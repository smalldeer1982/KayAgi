# 题目信息

# Party

## 题目描述

Beaver 有 $n$ 个熟人，这些人之间有若干个朋友关系与讨厌关系。现在，Beaver 想邀请他们去一个派对



当然，对于去派对的人是有要求的。



对于每一个去派对的人：



- 他的所有朋友的应该在派对中，不管是直接朋友还是间接朋友

- 派对里不应该有他讨厌的人



你的任务是求出 Beaver 可以邀请的最多的人数

## 说明/提示

$n \le 2000$  

$0 \le k,m \le min(10^5, \frac{n\cdot (n-1)}{2})$

$0 \le k+m \le min(10^5, \frac{n\cdot (n-1)}{2})$



感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
9
8
1 2
1 3
2 3
4 5
6 7
7 8
8 9
9 6
2
1 6
7 9
```

### 输出

```
3```

# AI分析结果



### 题目重写
# 派对

## 题目描述

海狸有 $n$ 个熟人，这些人之间存在若干朋友关系和讨厌关系。现在海狸想邀请他们参加派对。

受邀者需满足以下条件：
1. 每个受邀者的所有朋友（包括直接和间接朋友）都必须在派对中
2. 派对中不能有任何他讨厌的人

请计算海狸能邀请的最大人数。

## 输入格式
输入包含多组关系，具体格式详见原题。

## 说明/提示
$n \le 2000$  
朋友关系与讨厌关系总数不超过 $10^5$

---

**算法分类**：并查集

---

### 题解对比分析

#### 共同要点
1. 使用并查集处理朋友关系形成连通块（朋友圈）
2. 标记存在内部矛盾（包含相互讨厌者）的连通块
3. 选择最大未被标记的连通块作为答案

#### 核心难点
- 如何正确判断朋友圈的合法性：当且仅当朋友圈内存在相互讨厌关系时该圈不可选
- 并查集的路径压缩优化与统计技巧

#### 最优思路提炼
1. 通过并查集合并所有朋友关系形成连通块
2. 遍历讨厌关系，若两人在相同连通块则标记该块
3. 统计各连通块人数，取最大未标记块的值

---

### 精选题解

#### 1. Priori_Incantatem（5星）
**关键亮点**：
- 完整处理路径压缩优化
- 使用独立数组统计各连通块大小
- 清晰的变量命名与逻辑分离

**核心代码**：
```cpp
int find(int x) {
    if(f[x]==x) return x;
    return f[x] = find(f[x]);
}

// 合并处理
for(int i=1;i<=m;++i) {
    int x=read(), y=read();
    f[find(x)] = find(y);
}

// 矛盾标记
for(int i=1;i<=m;++i) {
    int x=read(), y=read();
    if(find(x) == find(y)) vis[find(x)] = 1;
}

// 统计答案
for(int i=1;i<=n;++i) 
    if(f[i]==i && !vis[i]) 
        ans = max(ans, c[i]);
```

#### 2. WaterSky（4星）
**关键亮点**：
- 详细的问题分析过程
- 包含图示理解的辅助说明
- 特别处理find函数的路径压缩

**个人心得**：
> "在合并时要将合并过去的数清空，避免重复统计。初始时每个节点的size设为1，合并时将被合并块的size清零"

---

### 同类题目推荐
1. [P1892 团伙](https://www.luogu.com.cn/problem/P1892)  
   - 并查集处理朋友/敌人关系
2. [CF28B pSort](https://www.luogu.com.cn/problem/CF28B)  
   - 并查集处理可交换位置
3. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)  
   - 并查集处理冲突关系最值问题

---
处理用时：52.75秒
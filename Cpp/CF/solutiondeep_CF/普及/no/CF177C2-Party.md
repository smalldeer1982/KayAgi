# 题目信息

# Party

## 题目描述

Beaver 有 $n$ 个熟人，这些人之间有若干个朋友关系与讨厌关系。现在，Beaver 想邀请他们去一个派对



当然，对于去派对的人是有要求的。



对于每一个去派对的人：



- 他的所有朋友的应该在派对中，不管是直接朋友还是间接朋友

- 派对里不应该有他讨厌的人



你的任务是求出 Beaver 可以邀请的最多的人数

## 说明/提示

$n \le 2000$  

$0 \le k,m \le min(10^5, \frac{n\cdot (n-1)}{2})$

$0 \le k+m \le min(10^5, \frac{n\cdot (n-1)}{2})$



感谢 @[_Wolverine](https://www.luogu.com.cn/user/120362) 提供的翻译

## 样例 #1

### 输入

```
9
8
1 2
1 3
2 3
4 5
6 7
7 8
8 9
9 6
2
1 6
7 9
```

### 输出

```
3```

# AI分析结果



# Party

## 题目描述  
Beaver 有 $n$ 个熟人，这些人之间有若干个朋友关系与讨厌关系。现在，Beaver 想邀请他们去一个派对。

要求每个参加派对的人满足：
1. 所有直接或间接朋友都在派对中
2. 派对上没有他讨厌的人

求最多能邀请多少人。

## 算法分类  
并查集

---

### 综合题解分析  
所有题解均采用并查集处理朋友关系，核心思路为：
1. 用并查集合并朋友形成连通块
2. 检查每对讨厌关系：若两人在同一连通块则标记该块无效
3. 统计未标记连通块的最大人数

关键优化点：
- 路径压缩优化查找效率
- 合并时统计集合大小
- 预处理根节点标记避免重复判断

---

### 优质题解推荐  

#### 1. Priori_Incantatem（5星）  
**核心亮点**：  
- 详细注释解释算法逻辑
- 分离朋友/讨厌关系处理阶段
- 显式统计集合人数
**代码片段**：
```cpp
for(int i=1;i<=n;++i) // 统计朋友圈人数
    c[find(i)]++;
for(int i=1;i<=n;++i) // 寻找答案
    if(f[i]==i && !vis[i])
        ans=max(ans,c[i]);
```

#### 2. 封禁用户（4星）  
**核心亮点**：  
- 代码结构简洁紧凑
- 使用辅助数组统计集合大小
- 快速路径压缩实现
**代码片段**：
```cpp
int find(int x){
    if(x==a[x]) return x;
    return a[x]=find(a[x]);
}
void merge(int x,int y){
    if(find(x)!=find(y)) 
        a[find(y)]=find(x);
}
```

#### 3. linaonao（4星）  
**个人心得**：  
- 初始误判为树形DP，快速调整思路
- 使用no数组标记无效集合
- 动态维护集合大小
**关键实现**：
```cpp
for(int i=1;i<=m;++i){
    if(find(a)==find(b)) no[find(a)]=1;
}
for(int i=1;i<=n;++i)
    cnt=max(cnt,s[find(i)]);
```

---

### 关键思路总结  
1. **集合划分优先**：朋友关系形成不可分割的集合
2. **冲突标记机制**：利用布尔数组标记存在矛盾的集合
3. **延迟统计优化**：先处理所有关系再统一计算集合大小

---

### 拓展练习  
1. [P1892 团伙](https://www.luogu.com.cn/problem/P1892) - 朋友/敌人关系处理
2. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525) - 二分+并查集判断冲突
3. [P2024 食物链](https://www.luogu.com.cn/problem/P2024) - 带权并查集处理复杂关系

---
处理用时：45.78秒
# 题目信息

# Encrypting Messages

## 题目描述

给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$ 以及一个模数 $c$ （保证 $m \le n$ ），你需要对它们进行 $n-m+1$ 次操作。



对于第 $i$ 次操作，将 $a_i \sim a_{i+m-1}$ 对应的加上 $b_1 \sim b_m$ （即 $a_i=a_i+b_1,a_{i+1}=a_{i+1}+b_2$，以此类推 。）



最后，你需要输出操作完成后 $a$ 序列对于 $c$ 取模的结果。

## 样例 #1

### 输入

```
4 3 2
1 1 1 1
1 1 1
```

### 输出

```
0 1 1 0
```

## 样例 #2

### 输入

```
3 1 5
1 2 3
4
```

### 输出

```
0 1 2
```

# AI分析结果



**题目重写**  
（题目已为中文，无需翻译）

**算法分类**  
差分

---

### 题解综合分析

#### 核心思路
所有题解均围绕**差分思想**展开。通过分析每个元素被加的次数，将区间加法转化为差分数组的端点修改，最终通过前缀和得到结果。时间复杂度为 $O(n)$。

#### 最优题解亮点

1. **题解作者：zhuweiqi（★★★★★）**
   - **亮点**：差分数组处理最直观。对每个 $b_i$ 影响的区间进行精确差分标记，代码简洁高效。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=m;i++){
         sum[i]+=x;
         sum[n-(m-i)+1]-=x;
     }
     // 前缀和恢复
     for(int i=1;i<=n;i++) sum[i] += sum[i-1];
     ```

2. **题解作者：shenbairui（★★★★☆）**
   - **亮点**：详细解释差分适用条件（区间重复加值），代码与思路高度对应。
   - **调试心得**：强调差分标记的结尾位置计算，需推导 `n-(m-i)+1` 的数学表达式。

3. **题解作者：wkjwkj（★★★★☆）**
   - **亮点**：动态维护累加和，通过条件判断增减 $b$ 的影响，无需显式差分数组。
   - **关键代码**：
     ```cpp
     if(i >= n-m+1) sum -= b[i-n+m-1];
     if(i <= m) sum += b[i];
     ```

---

### 关键思路总结
**差分+前缀和**：  
- 每个 $b_i$ 影响的区间为 $[i, n - (m - i)]$。  
- 差分数组在区间起点 `+b[i]`，终点后一位 `-b[i]`。  
- 最终通过前缀和累加得到每个位置的总增量。

---

### 拓展与相似题目
1. **P3397 地毯**（二维差分）  
2. **P3368 【模板】树状数组 2**（差分+树状数组）  
3. **P2280 [HNOI2003] 激光炸弹**（前缀和优化）

---

### 题解个人心得摘录
- **wkjwkj**：验证边界时发现规律普适性，指出“减去的元素一定早已被加入 sum 中”保证逻辑正确。  
- **shenbairui**：明确差分适用前提是“区间重复加值”，帮助读者理解算法选择逻辑。  
- **Lyw_and_Segment_Tree**：通过表格分析纵向叠加，虽最终未采用但体现多角度思考过程。

---
处理用时：47.91秒
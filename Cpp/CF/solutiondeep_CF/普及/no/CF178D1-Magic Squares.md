# 题目信息

# Magic Squares

## 题目描述

一只来自ABBYY的河狸喜欢智力游戏。他最喜欢的智力游戏之一是 “奇幻正方形” 。他想写一个程序来自动完成这个智力游戏。河狸决定让ABBYY杯的参赛者来帮他写这个程序。



 “奇幻正方形” 是一个 $n \times n$ 的矩阵，这个矩阵里面是整数。矩阵每行,每列和主对角线的数之和都等于 $s$ 。下面是一些例子：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF178D1/df1aa6f903a3e44e4322a8498e9c3054e6afd786.png)



给出 $n^2$ 个数 $(a_1 \sim a_{n^2})$ ，要求把这些数放入一个大小为 $n \times n$ 的矩阵中，使它们形成一个 “奇幻正方形” 。注意，每个数必须在矩阵和原始数列中出现相同的次数。



保证输入数据有解。

## 说明/提示

对于 $20\%$ 的数据，保证 $1 \leq n \leq 3$ ；



对于 $50\%$ 的数据，保证 $1 \leq n \leq 4$ 且给出的 $n^2$ 个数中最多有 $9$ 个互不相同的数；



对于 $100\%$ 的数据，保证 $1 \leq n \leq 4$ 且 $-10^8 \leq a_i \leq 10^8$ ；

## 样例 #1

### 输入

```
3
1 2 3 4 5 6 7 8 9
```

### 输出

```
15
2 7 6
9 5 1
4 3 8
```

## 样例 #2

### 输入

```
3
1 0 -1 0 2 -1 -2 0 1
```

### 输出

```
0
1 0 -1
-2 0 2
1 0 -1
```

## 样例 #3

### 输入

```
2
5 5 5 5
```

### 输出

```
10
5 5
5 5
```

# AI分析结果



### 题目重写
# 魔法正方形

## 题目描述

一只来自ABBYY的河狸喜欢智力游戏，其中最爱的游戏是“魔法正方形”。这个游戏需要将给定的 $n^2$ 个整数填入 $n \times n$ 的矩阵，使得每行、每列、主对角线的和都相等。每个数必须出现与输入相同的次数。数据保证有解。

## 输入输出样例
（与原文相同，此处略）

---

### 算法分类
**搜索（DFS） + 剪枝**

---

### 题解对比与结论
#### 共同思路
1. **DFS框架**：均采用深度优先搜索遍历矩阵位置，逐格填数。
2. **剪枝核心**：利用每行/列/对角线的和必须为预计算的 $s$（总和除以 $n$），在填充过程中即时检查约束条件。
3. **回溯机制**：维护访问标记数组，确保每个数使用次数正确。

#### 关键差异
1. **和值维护方式**：
   - Fa_Nanf1204、zhoujunchen：填充到行末时重新遍历求和，效率较低。
   - kimi0705、Milthm：维护行、列、对角线的累加和数组，实现 $O(1)$ 检查。
2. **剪枝粒度**：
   - Milthm 维护两条对角线的和，在填充对角线末位时检查，剪枝更彻底。
   - kimi0705 仅对行、列末位检查，但对角线检查延迟到最后。

#### 结论
**维护累加和数组 + 即时剪枝**是最优策略，将时间复杂度从 $O(n^3)$ 降为 $O(1)$ 的检查代价，显著提升效率。

---

### 精选题解
#### 1. Milthm（4.5星）
**亮点**：  
- 维护行、列、双对角线的累加和数组，实现高效检查。
- 在填充到行末、列末、对角线末位时立即剪枝，避免无效搜索。
- 代码结构清晰，回溯逻辑严谨。

**核心代码**：
```cpp
void dfs(int x) { // x为当前填数序号（按行优先）
    // ... 参数计算 nx,ny 为当前行列
    for (int i =1; i<=n*n; i++) {
        if (!vis[i]) {
            // 列末检查：当前列和 + a[i] 是否等于 s
            if (nx == n && suml[ny] + arr[i] != m) continue; 
            // 行末检查：当前行和 + a[i] 是否等于 s
            if (ny == n && sumh[nx] + arr[i] != m) continue;
            // 更新行、列、对角线和
            sumh[nx] += arr[i], suml[ny] += arr[i];
            if (nx == ny) sum3 += arr[i];
            if (nx + ny == n+1) sum4 += arr[i];
            // 递归与回溯
            dfs(x+1);
            sumh[nx] -= arr[i], suml[ny] -= arr[i];
            // ... 回溯对角线和
        }
    }
}
```

#### 2. kimi0705（4星）
**亮点**：  
- 通过行、列和数组实现快速剪枝。
- 使用序号到行列的映射简化参数传递。
- 代码简洁，剪枝条件明确。

---

### 关键优化技巧
1. **和值预计算**：总和除以 $n$ 得到目标值 $s$，作为全局约束。
2. **累加和数组**：维护行、列、对角线的部分和，避免重复计算。
3. **末位剪枝**：在填完行、列、对角线的最后一个元素时立即检查，而非最终验证。

---

### 拓展应用
- **数独类问题**（如洛谷P1074）：需结合行、列、宫格的多维约束剪枝。
- **排列生成优化**：当存在强约束时，优先填充约束严格的位置以减少分支。

---

### 推荐习题
1. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)（BFS + 状态压缩）
2. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（DFS + 多重剪枝）
3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)（DFS + 启发式搜索）

---
处理用时：162.95秒
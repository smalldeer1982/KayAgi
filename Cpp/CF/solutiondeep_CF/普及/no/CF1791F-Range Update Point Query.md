# 题目信息

# Range Update Point Query

## 题目描述

## 题意描述

给定一个数列 $ a_1, a_2, \cdots, a_n $，你需要对这个序列进行如下的两种操作：

- $ 1 $ $ l $ $ r $ — 对于任意的 $ l \le i \le r$，将 $ a_i $ 修改为 $ a_i $ 的数位之和。
- $ 2 $ $ x $ — 输出 $ a_x $ .

## 说明/提示

第一组测试数据的操作过程如下：

- 开始时，$ a = [1, 420, 69, 1434, 2023] $。
- 对 $ l=2 $，$ r=3 $ 执行操作, 完成后 $ a $ 变为 $ [1, \textcolor{red}{6}, \textcolor{red}{15}, 1434, 2023] $。
- 询问 $ x=2 $ , $ x=3 $ 以及 $ x=4 $，输出 $ 6 $，$ 15 $ 以及 $ 1434 $。
- 对 $ l=2 $ , $ r=5 $ 执行操作，完成后 $ a $ 变为 $ [1, \textcolor{red}{6}, \textcolor{red}{6}, \textcolor{red}{12}, \textcolor{red}{7}] $。
- 询问 $ x=1 $，$ x=3 $ 以及 $ x=5 $，输出 $ 1 $，$ 6 $ 以及 $ 7 $。

## 样例 #1

### 输入

```
3
5 8
1 420 69 1434 2023
1 2 3
2 2
2 3
2 4
1 2 5
2 1
2 3
2 5
2 3
9999 1000
1 1 2
2 1
2 2
1 1
1
2 1```

### 输出

```
6
15
1434
1
6
7
36
1
1```

# AI分析结果

### 题目内容重写（中文）

给定一个数列 $ a_1, a_2, \cdots, a_n $，你需要对这个序列进行如下的两种操作：

1. $ 1 $ $ l $ $ r $ — 对于任意的 $ l \le i \le r$，将 $ a_i $ 修改为 $ a_i $ 的数位之和。
2. $ 2 $ $ x $ — 输出 $ a_x $ 。

### 算法分类
并查集、线段树

### 题解分析与结论

本题的核心在于如何高效地处理区间修改和单点查询操作。由于每个数在经过多次数位和操作后会趋于稳定（即小于10），因此可以通过优化来减少不必要的操作。以下是各题解的思路对比：

1. **线段树优化**：通过维护区间最大值，当区间内的数都小于10时，直接跳过修改操作。这种方法的时间复杂度为 $O(n \log n)$，适合大规模数据。
2. **并查集优化**：通过并查集维护每个数是否需要修改，跳过已经稳定的数。这种方法的时间复杂度也为 $O(n \log n)$，但常数较小，适合频繁修改的场景。
3. **树状数组优化**：通过记录每个数的修改次数，查询时再模拟操作。这种方法的时间复杂度为 $O(n \log n)$，但实现较为复杂。

### 高星题解推荐

1. **作者：Sincerin (赞：11)**
   - **星级**：5星
   - **关键亮点**：使用线段树维护区间最大值和最小值，通过优化减少不必要的修改操作，代码清晰且高效。
   - **核心代码**：
     ```cpp
     inline void change(int p,int l,int r)
     {
         if(maxn(p)<=9) return; 
         if(l<=l(p)&&r>=r(p)) 
         {
             if(minn(p)==maxn(p))
             {
                 register int d=popcount(maxn(p));
                 tag(p)=d; maxn(p)=d; minn(p)=d; return;
             }
         } 
         spread(p);  
         register int mid=(l(p)+r(p))>>1;
         if(l<=mid) change(lson(p),l,r); 
         if(r>mid) change(rson(p),l,r);
         pushup(p);
     }
     ```

2. **作者：Ycyofmine (赞：7)**
   - **星级**：4星
   - **关键亮点**：使用并查集维护序列连通性，跳过已经稳定的数，代码简洁且易于理解。
   - **核心代码**：
     ```cpp
     for (int i = find(fa[l]); i <= r; i = fa[find(i + 1)]) {
         a[i] = f(a[i]);
         if (a[i] < 10)
             fa[i] = fa[i + 1];
     }
     ```

3. **作者：Flanksy (赞：6)**
   - **星级**：4星
   - **关键亮点**：使用线段树维护序列，通过标记死亡区间来减少操作次数，代码实现较为直观。
   - **核心代码**：
     ```cpp
     void update(int u,int l,int r){
         if(s[u].l>r||s[u].r<l||s[u].d) return;
         if(s[u].l==s[u].r) change(u);
         else{
             update(u*2,l,r),update(u*2+1,l,r);
             s[u].d=s[u*2].d&&s[u*2+1].d;
         }
     }
     ```

### 最优关键思路与技巧
- **线段树优化**：通过维护区间最大值和最小值，减少不必要的修改操作，适合大规模数据。
- **并查集优化**：通过跳过已经稳定的数，减少操作次数，适合频繁修改的场景。

### 可拓展之处
类似的问题可以通过维护区间最大值或使用并查集来优化操作次数，例如区间开方、区间取模等操作。

### 推荐题目
1. [P4145 上帝造题的七分钟2](https://www.luogu.com.cn/problem/P4145)
2. [P8618 [蓝桥杯 2014 国 A] 矩阵取数游戏](https://www.luogu.com.cn/problem/P8618)
3. [CF438D The Child and Sequence](https://www.luogu.com.cn/problem/CF438D)

---
处理用时：29.63秒
# 题目信息

# Min Max Sort

## 题目描述

对于一个排列，定义一次操作为：在排列中任选两个数字，将它们中的最大值插入至队尾，最小值插入至队首。

现在给定多个排列，问每个排列最少各需多少次操作才能变得严格递增。

## 样例 #1

### 输入

```
4
5
1 5 4 2 3
3
1 2 3
4
2 1 4 3
6
5 2 4 1 6 3```

### 输出

```
2
0
1
3```

# AI分析结果

### 题目内容重写

# 最小最大排序

## 题目描述

对于一个排列，定义一次操作为：在排列中任选两个数字，将它们中的最大值插入至队尾，最小值插入至队首。

现在给定多个排列，问每个排列最少各需多少次操作才能变得严格递增。

## 样例 #1

### 输入

```
4
5
1 5 4 2 3
3
1 2 3
4
2 1 4 3
6
5 2 4 1 6 3```

### 输出

```
2
0
1
3```

### 算法分类
贪心

### 题解分析与结论

题目要求通过最少的操作次数将排列变为严格递增序列。核心思路是通过贪心策略，找到已经有序的部分，从而减少操作次数。具体来说，可以通过找到中间已经有序的部分，然后计算需要操作的次数。

### 所选高星题解

#### 1. 作者：XeCtera (赞：19) - 评分：5星
**关键亮点**：
- 通过正难则反的思路，从最后一次操作开始分析，逐步推导出最小操作次数。
- 利用数组记录每个元素的位置，通过遍历找到最小的操作次数。
- 时间复杂度为O(n)，效率高。

**核心代码**：
```cpp
int k=(n>>1);
while (k&&p[k]<p[k+1]&&p[n-k+1]>p[n-k]) --k;
printf("%d\n",k);
```
**实现思想**：
从中间开始，逐步检查是否已经有序，找到最小的操作次数。

#### 2. 作者：baiABC (赞：7) - 评分：4星
**关键亮点**：
- 通过递归思想，每次操作后去掉边界元素，逐步缩小问题规模。
- 利用数组记录连续上升子序列的长度，判断是否有序。
- 时间复杂度为O(n)，代码简洁。

**核心代码**：
```cpp
for(int i = 1; i <= n; ++i)
    d[p[i]] = d[p[i]-1]+1;
for(int i = n/2; i >= 1; --i)
    if(d[n+1-i] < (n+1-i)-i+1)
        ++ans;
```
**实现思想**：
通过记录连续上升子序列的长度，判断是否有序，从而计算操作次数。

#### 3. 作者：yemuzhe (赞：5) - 评分：4星
**关键亮点**：
- 通过二分查找，找到中间已经有序的部分，减少操作次数。
- 利用二分法优化查找过程，时间复杂度为O(n log n)。
- 代码实现清晰，逻辑严谨。

**核心代码**：
```cpp
bool check (int x) {
    int l = (n + 1 >> 1) - x + (~n & 1), r = (n + 1 >> 1) + x;
    for (int i = 1; i <= n; i ++) {
        l += a[i] == l;
    }
    return l > r;
}
```
**实现思想**：
通过二分查找，确定中间已经有序的部分，从而计算操作次数。

### 最优关键思路或技巧
- **贪心策略**：通过找到已经有序的部分，减少操作次数。
- **正难则反**：从最后一次操作开始分析，逐步推导出最小操作次数。
- **二分查找**：优化查找过程，提高效率。

### 可拓展之处
- 类似问题可以应用于其他需要最小化操作次数的排序问题。
- 可以扩展到其他类型的操作，如交换、旋转等。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录
- **调试经历**：在实现过程中，需要注意边界条件的处理，避免数组越界。
- **踩坑教训**：在二分查找时，注意中间值的取法，避免死循环。
- **顿悟感想**：通过正难则反的思路，可以简化问题的分析过程。

---
处理用时：27.66秒
# 题目信息

# Equalize by Divide

## 题目描述

给您一个 $a_1,a_2,\dots a_n$ 这样的正整数数组，您可以对它进行多次（可以是零次）这样的操作：
* 选择两个索引 $i,j(1 \leq i,j \leq n,i \neq j)$；
* 将 $a_i$ 赋值为 $\lceil \frac{a_i}{a_j}\rceil$。这里的 $\lceil x \rceil$ 表示将 $x$ 取值到最小的大于等于 $x$ 的整数上。

有可能将通过这样的操作使数组的所有元素相等吗（或许为空）？如果可以，打印任何一种操作次数小于等于 $30n$ 的操作方法。

可以证明，在问题约束下，如果存在让数组所有元素相等的操作方法，那么操作次数最多 $30n$ 次。

## 样例 #1

### 输入

```
10
1
100
3
1 1 1
2
2 1
2
5 5
3
4 3 2
4
3 3 4 4
2
2 100
5
5 3 6 7 8
6
3 3 80 3 8 3
4
19 40 19 55```

### 输出

```
0
0
-1
0
2
1 3
2 1
4
3 1
4 2
1 3
2 4
6
2 1
2 1
2 1
2 1
2 1
2 1
8
5 2
4 2
3 2
1 3
1 3
2 1
4 1
5 1
4
5 1
3 1
3 1
3 1
9
4 2
2 1
1 2
1 2
3 2
3 2
1 4
2 4
3 4```

# AI分析结果

### 题目内容中文重写

**题目描述**

给定一个正整数数组 $a_1,a_2,\dots a_n$，您可以对它进行多次（可以是零次）这样的操作：
* 选择两个索引 $i,j(1 \leq i,j \leq n,i \neq j)$；
* 将 $a_i$ 赋值为 $\lceil \frac{a_i}{a_j}\rceil$。这里的 $\lceil x \rceil$ 表示将 $x$ 取值到最小的大于等于 $x$ 的整数上。

是否可以通过这样的操作使数组的所有元素相等？如果可以，打印任何一种操作次数小于等于 $30n$ 的操作方法。

可以证明，在问题约束下，如果存在让数组所有元素相等的操作方法，那么操作次数最多 $30n$ 次。

### 算法分类
构造

### 题解分析与结论

#### 题解1：SunnyYuan (5星)
**关键亮点**：
1. **清晰的无解判断**：通过判断数组中是否包含1来快速判断无解情况。
2. **逐步操作策略**：固定一个元素，逐步将其他元素调整到与它相等，或调整到2后再统一处理。
3. **代码可读性强**：使用`count`和`find`等STL函数简化代码逻辑。

**核心代码**：
```cpp
while (count(a + 1, a + n + 1, a[1]) < n && count(a + 1, a + n + 1, 2) == 0) {
    int pos = 2;
    while (a[pos] == a[1]) {
        pos++;
    }
    if (a[pos] > a[1]) {
        if (a[pos] % a[1]) a[pos] = a[pos] / a[1] + 1;
        else a[pos] = a[pos] / a[1];
        ans[++cnt] = {pos, 1};
    }
    else {
        if (a[1] % a[pos]) a[1] = a[1] / a[pos] + 1;
        else a[1] = a[1] / a[pos];
        ans[++cnt] = {1, pos};
    }
}
```

#### 题解2：yimuhua (4星)
**关键亮点**：
1. **简洁的无解判断**：直接使用`min_element`和`max_element`判断数组是否已经相等或包含1。
2. **最大值与最小值操作**：通过不断将最大值与最小值操作，逐步缩小数组元素的差异。
3. **时间复杂度分析**：明确指出了算法的时间复杂度为$O(n^2\log V)$。

**核心代码**：
```cpp
while(*min_element(a + 1, a + n + 1) != *max_element(a + 1, a + n + 1)) {
    int p = min_element(a + 1, a + n + 1) - a, x = a[p];
    for(int i = 1; i <= n; i++)
        if((a[i] - 1) / x + 1 > 1)
            a[i] = (a[i] - 1) / x + 1, ans.push_back((node){i, p});
}
```

#### 题解3：ダ月 (4星)
**关键亮点**：
1. **排序策略**：通过排序后不断将每个元素与最小元素操作，逐步使数组元素相等。
2. **无解判断**：同样通过判断数组中是否包含1来判断无解情况。
3. **代码结构清晰**：使用`sort`和`while`循环实现操作逻辑。

**核心代码**：
```cpp
while(true != false){
    sort(a+1,a+n+1,cmp);bool flag=false;
    for(int i=2;i<=n;i++){
        if(a[i].x>a[1].x) flag=true;
        while(a[i].x>a[1].x){
            st[++tp]={a[i].id,a[1].id};
            a[i].x=ceil(1.0*a[i].x/a[1].x);
        }
    }if(!flag) break;
}
```

### 最优关键思路
1. **无解判断**：数组中包含1时无解，因为1无法通过操作改变其他元素。
2. **逐步操作**：通过固定一个元素或不断将最大值与最小值操作，逐步缩小数组元素的差异，最终使所有元素相等。
3. **操作次数控制**：通过合理的操作策略，确保操作次数不超过$30n$。

### 拓展思路
类似的问题可以通过构造策略解决，例如通过逐步调整数组元素的值，使其满足某种条件。这类问题通常需要结合贪心思想和数学分析。

### 推荐题目
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)

### 个人心得
在解决构造类问题时，清晰的思路和合理的操作策略是关键。通过逐步调整数组元素的值，可以有效地缩小问题的规模，最终达到目标。

---
处理用时：33.43秒
# 题目信息

# Hierarchy

## 题目描述

小 $n$ 的公司有 $n$ 个员工，每个员工 $i$ 有一个初始的权值 $q_i$ ，每一个员工有且只有一个上司。 有 $m$ 条申请，每个申请由三个数 $a_i$，$b_i$，$c_i$ 构成，代表将 $a_i$ 任命为 $b_i$ 的上司所需要的花费为$c_i$，同时必须保证 $q_{a_i}>q_{b_i}$。试求使每个员工(顶头上司除外)都有且只有一个上司所花费的最小代价。

## 说明/提示

#### 数据规模与约定

$1 \le n \le 10^3$，$0 \le m \le 10^4$, $0 \le q_i \le 10^6$，$0 \le c_i \le 10^6$，$1 \le a_i,b_i \le n$ 。

## 样例 #1

### 输入

```
4
7 2 3 1
4
1 2 5
2 4 1
3 4 1
1 3 5
```

### 输出

```
11
```

## 样例 #2

### 输入

```
3
1 2 3
2
3 1 2
3 1 3
```

### 输出

```
-1
```

# AI分析结果



### 中文重写题目

**题目名称：层级关系**

#### 题目描述

小 n 的公司有 $n$ 个员工，每个员工 $i$ 有一个初始的权值 $q_i$，每个员工有且只有一个上司。现有 $m$ 条申请，每条申请由三个数 $a_i$、$b_i$、$c_i$ 组成，表示将 $a_i$ 任命为 $b_i$ 的上司所需花费为 $c_i$，且必须满足 $q_{a_i} > q_{b_i}$。要求构造一个树形结构使得所有员工（除顶头上司）都有且仅有一个上司，并求最小总花费。若无解，输出 $-1$。

#### 输入输出样例

**样例 #1**  
输入：  
```
4
7 2 3 1
4
1 2 5
2 4 1
3 4 1
1 3 5
```  
输出：  
```
11
```

**样例 #2**  
输入：  
```
3
1 2 3
2
3 1 2
3 1 3
```  
输出：  
```
-1
```

---

### 算法分类
**贪心**

---

### 题解分析与对比

#### 核心思路
题目要求构造一棵树，每个节点（除根）有且仅有一个父节点，且父节点的权值大于子节点。最优解需满足总花费最小。

1. **贪心策略**：  
   - **方法一**（类似 Kruskal）：将边按花费升序排序，依次处理每条边。若当前边满足权值条件且子节点未被分配上司，则选择该边。最终统计是否选够 $n-1$ 条边。
   - **方法二**（直接贪心）：对每个员工，记录所有可用的上司边中的最小花费，最后累加并检查顶头上司数量是否为 1。

2. **解决难点**：  
   - 确保结构为一棵树（无环且连通）。
   - 避免重复选择同一员工的上司。
   - 处理权值条件 $q_a > q_b$ 的约束。

#### 优质题解推荐

1. **作者：_Blue_**（★★★★★）  
   **亮点**：  
   - 采用类似 Kruskal 的贪心思路，代码清晰易懂。
   - 通过排序边和逐条处理，确保每次选择当前最优边。
   - 显式维护每个节点的上司分配状态，避免重复选择。  
   **代码核心**：  
   ```cpp
   sort(q+1, q+m+1, cmp);
   for (int i=1; i<=m; i++) {
       int x=q[i].x, y=q[i].y, c=q[i].c;
       if (!fa[y] && a[x]>a[y]) {
           fa[y] = true;
           ans += c;
           num++;
       }
       if (num == n-1) break;
   }
   ```

2. **作者：chenpengda**（★★★★☆）  
   **亮点**：  
   - 对每个员工直接维护最小花费，时间复杂度更低（$O(m)$）。
   - 通过统计未分配上司的节点数量，确保树结构合法性。  
   **代码核心**：  
   ```cpp
   for (int i=1; i<=m; i++) {
       int a, b, c;
       cin >> a >> b >> c;
       if (q[a] > q[b]) {
           price[b] = min(price[b], c);
       }
   }
   int chongfu = 0, ans = 0;
   for (int i=1; i<=n; i++) {
       if (price[i] == INF) chongfu++;
       else ans += price[i];
   }
   if (chongfu > 1) cout << -1;
   else cout << ans;
   ```

3. **作者：XiaoyuWan_**（★★★★☆）  
   **亮点**：  
   - 结构体设计合理，排序后逐条处理边。
   - 明确处理循环终止条件，避免冗余计算。  
   **个人心得**：  
   > 必须在循环外判断是否选够边，避免提前退出导致未处理完所有可能边。

---

### 关键思路总结
- **贪心选择最小边**：无论是排序后逐条选边，还是直接记录最小花费，核心都是优先选择满足条件的最小花费边。
- **合法性检查**：确保最终形成一棵树（通过顶头上司数量是否为 1 判断）。
- **时间复杂度优化**：直接维护每个节点的最小花费边，避免排序开销。

---

### 拓展与同类题
- **类似问题**：最小生成树（Kruskal/Prim）、拓扑排序中的贪心选择。
- **举一反三**：若权值条件变为其他形式（如 $q_a \geq q_b$），需调整选择逻辑。

---

### 推荐练习题
1. [P3366 最小生成树](https://www.luogu.com.cn/problem/P3366)  
2. [P1396 营救](https://www.luogu.com.cn/problem/P1396)  
3. [P1546 最短网络 Agri-Net](https://www.luogu.com.cn/problem/P1546)

---
处理用时：279.66秒
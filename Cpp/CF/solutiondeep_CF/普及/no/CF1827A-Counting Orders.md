# 题目信息

# Counting Orders

## 题目描述

You are given two arrays $ a $ and $ b $ each consisting of $ n $ integers. All elements of $ a $ are pairwise distinct.

Find the number of ways to reorder $ a $ such that $ a_i > b_i $ for all $ 1 \le i \le n $ , modulo $ 10^9 + 7 $ .

Two ways of reordering are considered different if the resulting arrays are different.

## 样例 #1

### 输入

```
5
6
9 6 8 4 5 2
4 1 5 6 3 1
3
4 3 2
3 4 9
1
2
1
3
2 3 4
1 3 3
12
2 3 7 10 23 28 29 50 69 135 420 1000
1 1 2 3 5 8 13 21 34 55 89 144```

### 输出

```
32
0
1
0
13824```

# AI分析结果

### 题目内容翻译

#### 题目描述

给定两个数组 $a$ 和 $b$，每个数组包含 $n$ 个整数。数组 $a$ 中的所有元素都是互不相同的。

请找出将数组 $a$ 重新排列的方式数，使得对于所有 $1 \le i \le n$，都有 $a_i > b_i$，结果对 $10^9 + 7$ 取模。

两种重新排列的方式被认为是不同的，如果它们得到的数组不同。

#### 样例 #1

##### 输入

```
5
6
9 6 8 4 5 2
4 1 5 6 3 1
3
4 3 2
3 4 9
1
2
1
3
2 3 4
1 3 3
12
2 3 7 10 23 28 29 50 69 135 420 1000
1 1 2 3 5 8 13 21 34 55 89 144
```

##### 输出

```
32
0
1
0
13824
```

### 算法分类

组合数学

### 题解分析与结论

由于题目要求重新排列数组 $a$，使得每个位置的元素都大于 $b$ 中对应位置的元素，且 $a$ 中的元素互不相同，因此可以通过排序和组合数学的方法来解决。

#### 关键思路

1. **排序**：首先对数组 $a$ 和 $b$ 进行排序。这样可以帮助我们更容易地找到满足条件的排列。
2. **双指针**：使用双指针的方法，遍历排序后的数组 $a$ 和 $b$，统计每个位置可以选择的元素数量。
3. **组合数学**：根据每个位置可以选择的元素数量，计算总的排列方式数。由于每个位置的选择是独立的，因此总的方式数是各个位置选择数的乘积。

#### 解决难点

- **排序**：排序是解决这个问题的关键步骤，它使得我们可以通过双指针的方法高效地找到满足条件的排列。
- **双指针**：双指针的使用需要仔细处理边界条件，确保每个位置的选择数是正确的。
- **组合数学**：计算总的方式数时，需要注意模运算的处理，避免溢出。

### 最优关键思路或技巧

- **排序与双指针**：通过排序和双指针的方法，可以高效地找到满足条件的排列。
- **组合数学**：利用组合数学的原理，计算总的排列方式数。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到多维数组的排列，或者考虑其他约束条件（如 $a_i \ge b_i$）。
- **优化**：可以通过预处理或其他优化方法，进一步提高算法的效率。

### 推荐题目

1. [P1494 [国家集训队]小Z的袜子](https://www.luogu.com.cn/problem/P1494)
2. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
3. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        for (int i = 0; i < n; ++i) cin >> a[i];
        for (int i = 0; i < n; ++i) cin >> b[i];
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        long long ans = 1;
        int j = 0;
        for (int i = 0; i < n; ++i) {
            while (j < n && a[j] <= b[i]) j++;
            if (j <= i) {
                ans = 0;
                break;
            }
            ans = ans * (j - i) % MOD;
        }
        cout << ans << endl;
    }
    return 0;
}
```

### 代码核心思想

1. **排序**：对数组 $a$ 和 $b$ 进行排序。
2. **双指针**：使用双指针遍历数组，统计每个位置可以选择的元素数量。
3. **组合数学**：根据每个位置的选择数，计算总的排列方式数，并对结果取模。

### 结论

通过排序、双指针和组合数学的方法，可以高效地解决这个问题。关键在于排序和双指针的使用，以及组合数学的应用。

---
处理用时：29.36秒
# 题目信息

# Flipper

## 题目描述

给你一个长度为 $ n $ 的数列 $ p $。

一个数列是 $ 1 $ 到 $ n $ 按某一顺序组成的阵列。例如，$ {2,3,1,5,4} $ 是一个数列，而 $ {1,2,2} $ 不是（因为 $ 2 $ 出现了两次），$ {1,3,4} $ 也不是一个数列（因为 $ n=3 $，但数列中包含 $ 4 $）。

对于数列 $ p $，进行一次如下操作：

- 选择一个区间 $ [l, r] $（$ 1\le l\le r\le n $，一个区间是一串连续的数 $ {p_l, p_{l+1}, \ldots, p_{r-1}, p_r} $），并将它反转过来。反转一个区间即交换如下的数对 $ (p_l, p_r),(p_{l+1}, p_{r-1}),\dots,(p_{l + i}, p_{r - i}) $（其中 $ l + i \le r - i $）。
- 交换前缀和后缀：$ [r+1, n] $ 和 $ [1, l - 1] $（注意：这些区间可能是空的）。

例如，给定 $ n = 5, p = \{2, \color{blue}{3}, \color{blue}{1}, 5, 4\} $，如果你选择区间 $ [l = 2, r = 3] $，反转区间以后 $ p = \{\color{green}{2}, \color{blue}{1}, \color{blue}{3}, \color{green}{5}, \color{green}{4}\color{black}\} $。接着交换区间 $ [4, 5] $ 与 $ [1, 1] $。得到 $ p = \{\color{green}{5}, \color{green}{4}, 1, 3, \color{green}{2}\color{black}\} $。可以证明这是操作后该排列的字典序的最大可能结果。

你需要输出通过一次所述操作后可以得到的字典序最大数列。

如果存在一个 $ i $（$ 1 \le i \le n $），使 $ a_j = b_j $ 对于 $ 1 \le j < i $ 且 $ a_i > b_i $，那么一个数列 $ a $ 的字典序大于数列 $ b $ 的字典序 。

## 说明/提示

对于 $ 100\% $ 的数据，$ 1 \le t \le 1000 $，$ 1 \le n \le 2000 $，保证每次 $ T $ 组测试数据的 $ n $ 之和不超过 $ 2000 $。

## 样例 #1

### 输入

```
9
5
2 3 1 5 4
9
4 1 6 7 2 8 5 3 9
4
4 3 2 1
2
2 1
6
3 2 4 1 5 6
7
3 2 1 5 7 6 4
10
10 2 5 6 1 9 3 8 4 7
4
4 2 1 3
1
1```

### 输出

```
5 4 1 3 2 
9 4 1 6 7 2 8 5 3 
3 2 1 4 
1 2 
6 5 3 2 4 1 
7 6 4 5 3 2 1 
9 3 8 4 7 1 10 2 5 6 
3 4 2 1 
1```

# AI分析结果

### 题目重写
题目描述：给定一个长度为 $n$ 的数列 $p$，数列中的元素是 $1$ 到 $n$ 的某个排列。你可以选择一个区间 $[l, r]$，将其反转，然后交换前缀 $[1, l-1]$ 和后缀 $[r+1, n]$。要求通过一次操作后得到的数列字典序最大。

### 算法分类
贪心、构造

### 题解分析与结论
本题的核心是通过一次操作使数列的字典序最大化。各题解的思路主要集中在如何选择反转区间 $[l, r]$ 以及如何交换前缀和后缀。大多数题解都采用了贪心策略，即尽可能将最大的数放在数列的最前面。具体来说，题解们通常先找到数列中最大数的位置，然后根据其位置确定反转区间的右端点 $r$，再通过贪心策略确定左端点 $l$。

### 高星题解推荐
#### 1. 作者：fengxiaoyi (赞：14)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，处理了最大数在首位和末尾的特殊情况，贪心策略明确。
- **核心实现思想**：首先找到最大数的位置 $r$，如果 $r=1$，则找次大数的位置。然后通过贪心策略确定左端点 $l$，最后输出操作后的数列。
```cpp
int l, r;
for(int i=1;i<=n;i++){
    if(p[i]==n) r=i;
}
if(r==1){
    for(int i=1;i<=n;i++){
        if(p[i]==n-1) r=i;
    }
}
if(r!=n) r--;
l=r;
for(int i=r-1;i>=1;i--){
    if(p[i]>p[1]) l--;
    else break;
}
for(int i=r+1;i<=n;i++) printf("%d ",p[i]);
for(int i=r;i>=l;i--) printf("%d ",p[i]);
for(int i=1;i<l;i++) printf("%d ",p[i]);
```

#### 2. 作者：Coffee_zzz (赞：4)
- **星级**：4星
- **关键亮点**：详细分析了最大数在不同位置时的处理方式，代码结构清晰，逻辑严谨。
- **核心实现思想**：通过枚举可能的反转区间，计算每种情况下的数列字典序，选择最大的一个。
```cpp
void check(int l,int r){
    int cnt=0;
    for(int i=r+1;i<=n;i++) a[++cnt]=p[i];
    for(int i=r;i>=l;i--) a[++cnt]=p[i];
    for(int i=1;i<l;i++) a[++cnt]=p[i];
    for(int i=1;i<=n;i++){
        if(ans[i]>a[i]) return;
        if(ans[i]<a[i]){
            for(int i=1;i<=n;i++) ans[i]=a[i];
            return;
        }
    }
}
```

#### 3. 作者：Scorilon (赞：2)
- **星级**：4星
- **关键亮点**：优化了左端点的确定过程，时间复杂度较低，代码简洁。
- **核心实现思想**：通过贪心策略确定左端点 $l$，使得操作后的数列字典序最大。
```cpp
int l=opt-1;
int r=opt-1;
if(opt==n) l=opt,r=opt;
for(int i=r-1;i>=1;i--){
    if(a[i]>=a[l-i]) l=i;
    else break;
}
for(int i=r+1;i<=n;i++) printf("%d ",a[i]);
for(int i=r;i>=l;i--) printf("%d ",a[i]);
for(int i=1;i<=l-1;i++) printf("%d ",a[i]);
```

### 最优关键思路与技巧
1. **贪心策略**：通过将最大数或次大数放在数列的最前面，确保字典序最大化。
2. **特殊情况处理**：当最大数在首位或末尾时，需要特殊处理以确保操作的有效性。
3. **优化左端点确定**：通过贪心策略快速确定左端点 $l$，减少不必要的枚举。

### 可拓展之处
类似的问题可以通过贪心策略和构造法来解决，尤其是在需要最大化或最小化某种序列性质时。例如，在排列问题中，通过交换或反转操作来达到某种最优状态。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)

### 个人心得摘录
- **fengxiaoyi**：在处理最大数在首位和末尾的特殊情况时，通过找次大数来确保操作的有效性，避免了无效操作。
- **Coffee_zzz**：通过枚举所有可能的反转区间，确保找到字典序最大的数列，虽然时间复杂度较高，但逻辑清晰，易于理解。

---
处理用时：34.83秒
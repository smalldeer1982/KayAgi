# 题目信息

# Rudolf and the Another Competition

## 题目描述

Rudolf 已经报名了一个遵循 ICPC 规则的编程竞赛。这些规则意味着，每通过一道题，参与者将获得 $1$ 积分，同时还会受到相当于从比赛开始到 AC 时间的罚时。在排行榜中，分数高的参与者排名较高，如果分数相等，罚时较少的参与者排名较高。

现在总共有 $n$ 名参与者参与了比赛，Rudolf 是编号为 $1$ 的参与者。已知一共有 $m$ 题，$h$ 分钟。

现在，一个强大的人工智能已经预测到了值 $t_{i，j}$，它表示第 $i$ 位参与者解决第 $j$ 道问题所需的分钟数。

Rudolf 意识到解决问题的顺序可以影响最终的结果。例如，如果 $h = 120$，解决问题的时间是\[ $20，15，110$ \]，那么，如果  Rudolf 按一下几种顺序解决问题，会出现一下几种情况:

- ${3，1，2}$，那么他只会解决第三个问题，得到 $1$ 积分和 $110$ 罚时。
- ${1，2，3}$，那么他将在开始的 $20$ 分钟后解决第一个问题，在 $20+15=35$ 分钟后解决第二个问题，他将没有时间解决第三个问题。因此，他将获得 $2$ 积分和 $20+35=55$ 罚时。
- ${2，1，3}$，那么他将在开始的 $15$ 分钟后解决第二个问题，在 $15+20=35$ 分钟后解决第一个问题，他将没有时间解决第三个问题。因此，他将获得 $2$ 点和 $15+35=50$ 的罚时。

Rudolf 感兴趣的是，如果每个参与者根据人工智能的预测，以最佳顺序解决问题，他将在比赛中为第几名。假设在积分和罚时相同的情况下，Rudolf 将占据最靠前的位置。

## 样例 #1

### 输入

```
5
3 3 120
20 15 110
90 90 100
40 40 40
2 1 120
30
30
1 3 120
10 20 30
3 2 27
8 9
10 7
10 8
3 3 15
7 2 6
7 5 4
1 9 8```

### 输出

```
2
1
1
2
1```

# AI分析结果

【题目内容】
# Rudolf 和另一场比赛

## 题目描述

Rudolf 已经报名了一个遵循 ICPC 规则的编程竞赛。这些规则意味着，每通过一道题，参与者将获得 $1$ 积分，同时还会受到相当于从比赛开始到 AC 时间的罚时。在排行榜中，分数高的参与者排名较高，如果分数相等，罚时较少的参与者排名较高。

现在总共有 $n$ 名参与者参与了比赛，Rudolf 是编号为 $1$ 的参与者。已知一共有 $m$ 题，$h$ 分钟。

现在，一个强大的人工智能已经预测到了值 $t_{i，j}$，它表示第 $i$ 位参与者解决第 $j$ 道问题所需的分钟数。

Rudolf 意识到解决问题的顺序可以影响最终的结果。例如，如果 $h = 120$，解决问题的时间是\[ $20，15，110$ \]，那么，如果  Rudolf 按一下几种顺序解决问题，会出现一下几种情况:

- ${3，1，2}$，那么他只会解决第三个问题，得到 $1$ 积分和 $110$ 罚时。
- ${1，2，3}$，那么他将在开始的 $20$ 分钟后解决第一个问题，在 $20+15=35$ 分钟后解决第二个问题，他将没有时间解决第三个问题。因此，他将获得 $2$ 积分和 $20+35=55$ 罚时。
- ${2，1，3}$，那么他将在开始的 $15$ 分钟后解决第二个问题，在 $15+20=35$ 分钟后解决第一个问题，他将没有时间解决第三个问题。因此，他将获得 $2$ 点和 $15+35=50$ 的罚时。

Rudolf 感兴趣的是，如果每个参与者根据人工智能的预测，以最佳顺序解决问题，他将在比赛中为第几名。假设在积分和罚时相同的情况下，Rudolf 将占据最靠前的位置。

## 样例 #1

### 输入

```
5
3 3 120
20 15 110
90 90 100
40 40 40
2 1 120
30
30
1 3 120
10 20 30
3 2 27
8 9
10 7
10 8
3 3 15
7 2 6
7 5 4
1 9 8```

### 输出

```
2
1
1
2
1```

【算法分类】
贪心

【题解分析与结论】
所有题解都采用了贪心策略，即每个参与者优先解决耗时最短的题目，以最大化得分并最小化罚时。这种策略的合理性在于，优先解决耗时短的题目可以在有限的时间内完成更多的题目，并且罚时也会相应减少。

【所选高星题解】
1. 作者：12345678hzx (4星)
   - 关键亮点：代码简洁明了，直接对每个参与者的题目时间进行排序，并计算得分和罚时。使用 `long long` 避免溢出问题。
   - 代码核心思想：对每个参与者的题目时间进行排序，然后计算在时间限制内能完成的题目数量及罚时，最后根据得分和罚时进行排名。

```cpp
long long t,n,m,h,b[200005],c[200005];
int main() {
	cin>>t;
	while(t--) {
		cin>>n>>m>>h;
		long long a[n+1][m+1];
		for(long long i=1;i<=n;i++) for(long long j=1;j<=m;j++) cin>>a[i][j];
		for(long long i=1;i<=n;i++) {
			sort(a[i]+1,a[i]+m+1);
			b[i]=c[i]=0;
			long long cnt=0; 
			for(long long j=1;j<=m;j++) {
				if(cnt+a[i][j]<=h) b[i]++,cnt+=a[i][j],c[i]+=cnt;
				else break;
			}
		}
		long long id=1;
		for(long long i=2;i<=n;i++) {
			if(b[i]>b[1]) id++;
			else if(b[i]==b[1]) if(c[i]<c[1]) id++;
		}
		cout<<id<<"\n";
	}
    return 0;
}
```

2. 作者：引领天下 (4星)
   - 关键亮点：使用 `vector` 和 `pair` 结构体存储数据，代码结构清晰，排序逻辑明确。
   - 代码核心思想：对每个参与者的题目时间进行排序，计算得分和罚时，最后根据得分和罚时进行排名。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n,m,h;
vector<int>T;
inline bool cmp(pair<int,int>p,pair<int,int>q){
    if(p.first!=q.first)return p.first>q.first;
    else return p.second<q.second;//分数降序，时间升序
}
signed main(){
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        vector<pair<int,int>>q;
        cin>>n>>m>>h;
        int s0,t0;
        for(int i=1;i<=n;i++){
            T.resize(m+1);
            for(int j=1;j<=m;j++)cin>>T[j];
            sort(T.begin(),T.end());
            int s=0,t=0,sumt=0;
            for(int j=1;j<=m;j++)if(h>=t+T[j])s++,t+=T[j],sumt+=t;//注意罚时的计算是累加的
            q.push_back(make_pair(s,sumt));
            if(i==1)s0=s,t0=sumt;
        }
        sort(q.begin(),q.end(),cmp);
        cout<<(find(q.begin(),q.end(),make_pair(s0,t0))-q.begin()+1)<<endl;
    }
    return 0;
}
```

3. 作者：_sunkuangzheng_ (4星)
   - 关键亮点：使用结构体存储每个参与者的得分、罚时和编号，排序逻辑清晰，代码结构合理。
   - 代码核心思想：对每个参与者的题目时间进行排序，计算得分和罚时，最后根据得分和罚时进行排名。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t,n,m,x,h;
vector<int> a[200005];
struct per{
    int p,t,id;
}b[200005];
bool cmp(per a,per b){
    return (a.p == b.p ? (a.t == b.t ? a.id < b.id : a.t < b.t) : a.p > b.p);
}
signed main(){
    cin >> t;
    while(t --){
        cin >> n >> m >> h;
        for(int i = 1;i <= n;i ++) b[i].t = b[i].p = 0,a[i].clear();
        for(int i = 1;i <= n;i ++) for(int j = 1;j <= m;j ++) cin >> x,a[i].push_back(x);
        for(int i = 1;i <= n;i ++){
            sort(a[i].begin(),a[i].end());
            int tmp = h;b[i].id = i;int s = 0;
            for(int j = 0;j < m;j ++) if(tmp >= a[i][j]) s+=a[i][j],tmp -= a[i][j],b[i].p ++,b[i].t += s;
        }
        sort(b+1,b+n+1,cmp);
        for(int i = 1;i <= n;i ++) if(b[i].id == 1) {cout << i << endl;break;}   
    }
    return 0;
}
```

【最优关键思路】
贪心策略：优先解决耗时短的题目，以最大化得分并最小化罚时。这种策略在有限时间内能完成更多的题目，并且罚时也会相应减少。

【拓展思路】
类似的问题可以出现在其他需要优化资源分配的场景中，如任务调度、背包问题等。贪心策略在这些问题中也有广泛应用。

【推荐题目】
1. P1090 [NOIP2004 提高组] 合并果子
2. P1223 排队接水
3. P1803 凌乱的yyy / 线段覆盖

---
处理用时：54.85秒
# 题目信息

# Nastya and Potions

## 题目描述

炼金术士 Nastya 很喜欢合成药水。现有 $ n $ 种药水，第 $ i $ 种药水可以用 $ c_i $ 个金币买入。

任何一种药水的合成方案都不超过 $ 1 $ 种。在合成某种药水的过程中，作为原料的药水将会被**完全消耗**。任何药水都不能直接或间接合成它本身。

作为一个经验老道的炼金术士，Nastya 已经可以**无限制地**获得 $ p_1, p_2, \dots, p_k $ 这 $ k $ 种药水，可是她却没法决定接下来要合成哪些药水。于是，她求助于你。对于 $ 1 \le i \le n $，她需要你求出获得第 $ i $ 种药水所需的最少的金币数。

## 说明/提示

对于样例一的第一组测试数据，最优方案如下：

- 用药水 $ 2, 4, 5 $ 合成药水 $ 1 $。
- 药水 $ 2 $ 只能买入。
- 药水 $ 3 $ 是无限制供应的。
- 相较于用药水 $ 3, 5 $ 合成药水 $ 4 $，直接买入更划算。
- 药水 $ 5 $ 只能买入。

## 样例 #1

### 输入

```
4
5 1
30 8 3 5 10
3
3 2 4 5
0 
0 
2 3 5
0 
3 2
5 143 3
1 3
1 2
0 
2 1 2
5 1
5 4 1 3 4
2
2 4 5
3 3 5 4
2 1 4
1 5
0 
4 2
1 1 5 4
2 4
3 2 4 3
0 
2 2 4
1 2```

### 输出

```
23 8 0 5 10 
0 143 0 
5 0 1 3 4 
0 0 0 0```

## 样例 #2

### 输入

```
3
6 3
5 5 4 5 2 2
3 4 5
2 2 5
1 5
3 4 1 6
4 2 6 1 5
0 
0 
6 2
1 4 4 1 5 2
3 6
4 6 3 4 5
4 6 5 3 4
0 
1 5
1 6
0 
2 1
4 3
1
0 
1 1```

### 输出

```
0 0 0 0 0 2 
0 0 0 0 0 0 
0 0```

# AI分析结果

### 题目内容重写

炼金术士 Nastya 很喜欢合成药水。现有 $ n $ 种药水，第 $ i $ 种药水可以用 $ c_i $ 个金币买入。

任何一种药水的合成方案都不超过 $ 1 $ 种。在合成某种药水的过程中，作为原料的药水将会被**完全消耗**。任何药水都不能直接或间接合成它本身。

作为一个经验老道的炼金术士，Nastya 已经可以**无限制地**获得 $ p_1, p_2, \dots, p_k $ 这 $ k $ 种药水，可是她却没法决定接下来要合成哪些药水。于是，她求助于你。对于 $ 1 \le i \le n $，她需要你求出获得第 $ i $ 种药水所需的最少的金币数。

### 算法分类
图论、拓扑排序、动态规划

### 题解分析与结论

本题的核心在于如何高效地计算每种药水的最小成本。由于题目保证无环，且每种药水只能通过一种方式合成，因此可以通过拓扑排序或记忆化搜索来解决。拓扑排序适合处理有向无环图（DAG）的递推问题，而记忆化搜索则适合处理递归问题。

### 所选高星题解

#### 题解作者：_Only_this (4星)
**关键亮点**：
- 使用拓扑排序处理DAG，确保每个节点的前驱节点都已处理完毕。
- 通过队列实现拓扑排序，代码简洁且高效。
**核心代码**：
```cpp
void Topsort(){
    queue<int>q;
    for(int i=1;i<=n;i++){
        if(!in[i]){
            q.push(i);
        }
    }
    for(int i=1;i<=n;i++){
        if(vis[i]){
            ans[i]=0;
        }
        else{
            ans[i]=a[i];
        }
    }
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=e[i].ne){
            int v=e[i].to;
            sum[v]+=ans[u]+e[i].val;
            if(!--in[v]){
                q.push(v);
                ans[v]=min(ans[v],sum[v]);
            }
        }
    }
}
```
**个人心得**：
- 拓扑排序在处理DAG时非常高效，且代码实现简单。

#### 题解作者：Dream__Sky (4星)
**关键亮点**：
- 使用记忆化搜索，避免重复计算，提高效率。
- 通过递归实现，代码逻辑清晰。
**核心代码**：
```cpp
int dfs(int dep){
    if(f[dep]<2e10) return f[dep];
    f[dep]=a[dep];
    int sum=0;
    for(int i=0;i<v[dep].size();i++) sum+=dfs(v[dep][i]);
    if(!v[dep].size()) sum=2e10;
    f[dep]=min(f[dep],sum);
    return f[dep];
}
```
**个人心得**：
- 记忆化搜索在处理递归问题时非常有效，且代码易于理解。

#### 题解作者：_sunkuangzheng_ (4星)
**关键亮点**：
- 结合拓扑排序和动态规划，确保每个节点的最小成本被正确计算。
- 代码结构清晰，易于理解。
**核心代码**：
```cpp
void work(){
    queue<int> q;
    for(int i=1;i<=n;i++){
        if(!in[i]){
            q.push(i);
        }
    }
    while(!q.empty()){
        int u=q.front();q.pop();
        f[u]=min(f[u],g[u]);
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;g[v]+=f[u];
            if(!--in[v]) q.push(v);
        }
    }
}
```
**个人心得**：
- 拓扑排序结合动态规划在处理DAG问题时非常有效，且代码实现简洁。

### 最优关键思路或技巧
- **拓扑排序**：适用于处理有向无环图（DAG）的递推问题，确保每个节点的前驱节点都已处理完毕。
- **记忆化搜索**：适用于处理递归问题，避免重复计算，提高效率。
- **动态规划**：结合拓扑排序，确保每个节点的最小成本被正确计算。

### 可拓展之处
- 类似的问题可以扩展到其他图论问题，如最短路径、最小生成树等。
- 可以尝试使用其他算法如Dijkstra、Bellman-Ford等来解决类似问题。

### 推荐题目
1. [P1875 佳佳的魔法药水](https://www.luogu.com.cn/problem/P1875)
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

---
处理用时：28.86秒
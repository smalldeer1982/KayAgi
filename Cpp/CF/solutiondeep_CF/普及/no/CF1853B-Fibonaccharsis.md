# 题目信息

# Fibonaccharsis

## 题目描述

Ntarsis 在他的生日的时候收到了两个整数 $n$ 和 $k$ 。他想知道有多少个长度为 $k$ 的斐波那契序列可以用 $n$ 作为序列的第 $k$ 个元素。

如果一个单调不降的非负整数序列 $f$，对任意的 $i > 2$，都有 $f_i=f_{i-1}+f_{i-2}$，则该序列被视为斐波那契类序列，其中 $f_i$ 表示序列中的第 $i$ 个元素。请注意，$f_1$ 和 $f_2$ 可以是任意的非负整数。

例如 $[4，5，9，14 ]$ 和 $[0，1，1]$ 被认为是斐波那契类序列，而 $[ 0，0，0，1，1]$ , $[1，2，1，3]$ 和 $[−1，−1，−2]$ 却不是：前两个并不总是满足 $f_i=f_{i-1}+f_{i-2}$ ，后者不满足元素是非负的。

通过帮助 Ntarsis 完成这项任务来打动他。

## 说明/提示

对于 $n=22$ , $k=4$ 有4种有效的斐波那契类序列:

- $[6,8,14,22]$ ，

- $[4,9,13,22]$ ，

- $[2,10,12,22]$ ，

- $[0,11,11,22]$ 。

对于 $n=3$，$k=9$，可以证明没有满足给定条件的斐波那契类序列。

对于 $n=55$，$k=11$， $[0,1,1,2,3,5,8,13,21,34,55]$ 是唯一类似斐波那契的序列。

## 样例 #1

### 输入

```
8
22 4
3 9
55 11
42069 6
69420 4
69 1434
1 3
1 4```

### 输出

```
4
0
1
1052
11571
0
1
0```

# AI分析结果

### 题目内容重写
Ntarsis 在他的生日时收到了两个整数 $n$ 和 $k$。他想知道有多少个长度为 $k$ 的斐波那契序列可以用 $n$ 作为序列的第 $k$ 个元素。

如果一个单调不降的非负整数序列 $f$，对任意的 $i > 2$，都有 $f_i=f_{i-1}+f_{i-2}$，则该序列被视为斐波那契类序列，其中 $f_i$ 表示序列中的第 $i$ 个元素。请注意，$f_1$ 和 $f_2$ 可以是任意的非负整数。

例如 $[4，5，9，14 ]$ 和 $[0，1，1]$ 被认为是斐波那契类序列，而 $[ 0，0，0，1，1]$ , $[1，2，1，3]$ 和 $[−1，−1，−2]$ 却不是：前两个并不总是满足 $f_i=f_{i-1}+f_{i-2}$ ，后者不满足元素是非负的。

通过帮助 Ntarsis 完成这项任务来打动他。

### 算法分类
数学、递推

### 题解分析与结论
题解的核心思路是通过递推或数学公式来求解满足条件的斐波那契类序列的数量。大多数题解都利用了斐波那契数列的性质，通过枚举或数学推导来减少计算量。难点在于如何处理 $k$ 的范围较大时的情况，以及如何高效地枚举前两项的值。

### 高星题解推荐
1. **作者：mRXxy0o0 (5星)**
   - **关键亮点**：通过扩展欧几里得算法求解方程，利用斐波那契数列的性质减少计算量，处理了 $k$ 范围较大的情况。
   - **核心代码**：
     ```cpp
     ll exgcd(ll a,ll b,ll &x,ll &y){
         if(!b){
             x=1,y=0;
             return a;
         }
         ll d=exgcd(b,a%b,y,x);
         y-=a/b*x;
         return d;
     }
     ```
   - **个人心得**：通过取模的方式得到一个使 $f_2\ge0$ 且 $f_2$ 最小的解，并相减算出增加的 $x$ 的值。

2. **作者：Special_Judge (4星)**
   - **关键亮点**：利用斐波那契数列的递推关系，通过枚举前两项的值并验证是否满足条件，处理了 $k$ 范围较大的情况。
   - **核心代码**：
     ```cpp
     void work(){
         scanf("%lld%lld",&n,&k);
         if(k>28){
             printf("0\n");
             return ;
         }
         g=exgcd(fib[k-1],fib[k]);
         if(n%g!=0){
             printf("0\n");
             return ;
         }
         x*=n/g;
         y*=n/g;
         dx=fib[k]/g;
         dy=fib[k-1]/g;
         x=(x%dx+dx)%dx;
         y=(n-x*fib[k-1])/fib[k];
         cout<<1ll*floor((y-x)*1.0/(dx+dy)*1.0)+1<<endl;
     }
     ```
   - **个人心得**：通过枚举前两项的值并验证是否满足条件，处理了 $k$ 范围较大的情况。

3. **作者：tbdsh (4星)**
   - **关键亮点**：通过预处理斐波那契数列，利用二分查找来枚举 $f_1$ 和 $f_2$ 的值，减少了时间复杂度。
   - **核心代码**：
     ```cpp
     void Solve(){
         cin >> n >> k;
         int ans = 0;
         if (k > 2e5){
             cout << "0\n";
             return ;
         }
         for (int i = 0; i <= n; i++){
             int l = i, r = n;
             while (l < r){
                 int mid = (l + r + 1) >> 1;
                 if (i * dpa[k] + mid * dpb[k] > n){
                     r = mid - 1;
                 }else {
                     l = mid;
                 }
             }
             if (i * dpa[k] + l * dpb[k] == n){
                 ans++;
             }
         }
         cout << ans << '\n';
     }
     ```
   - **个人心得**：通过预处理斐波那契数列，利用二分查找来枚举 $f_1$ 和 $f_2$ 的值，减少了时间复杂度。

### 关键思路与技巧
1. **利用斐波那契数列的性质**：通过递推关系或数学公式来减少计算量。
2. **枚举与二分查找**：通过枚举前两项的值并利用二分查找来减少时间复杂度。
3. **扩展欧几里得算法**：用于求解方程，处理 $k$ 范围较大的情况。

### 拓展思路
类似的问题可以通过预处理数列、利用数学公式或递推关系来减少计算量。对于大范围的 $k$，可以通过数学性质或算法优化来减少计算量。

### 推荐题目
1. [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)
2. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)
3. [P3986 斐波那契数列的和](https://www.luogu.com.cn/problem/P3986)

---
处理用时：34.54秒
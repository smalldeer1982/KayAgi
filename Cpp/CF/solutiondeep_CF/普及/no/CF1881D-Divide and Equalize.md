# 题目信息

# Divide and Equalize

## 题目描述

### 题目大意
给你一个包含 $n$ 个正整数的数组 $a$，你可以进行以下操作：
1. 选两个数$a_i$和$a_j$ （$1 ＜ i, j \le n$且$i \ne j$）
2. 选择$a_i$的一个因数$x$
3. 将$a_i$替换为$\frac{a_i}{x}$，$a_j$替换为$a_j \cdot x$

请判断是否能通过有限次操作使 $a$ 中所有元素相同（可以是$0$次）。

例如：

$a=[100,2,50,10,1]$共$5$个数，那么进行以下两次操作：
1. 选择$a_3=50,a_2=2,x=5$，则$a_3=\frac{a_3}{x}=\frac{50}{5}=10,a_2=2\cdot5=10$，$a$变为$[100,10,10,10,1]$
2. 选择$a_1=100,a_5=1,x=10$，则$a_3=\frac{a_1}{x}=\frac{100}{10}=10,a_2=1\cdot10=10$，$a$变为$[10,10,10,10,10]$

经过以上操作后，$a$里面的元素都变成了$10$

## 说明/提示

第一组样例数据已在“题目大意”中有解释。

## 样例 #1

### 输入

```
7
5
100 2 50 10 1
3
1 1 1
4
8 2 4 2
4
30 50 27 20
2
75 40
2
4 4
3
2 3 1```

### 输出

```
YES
YES
NO
YES
NO
YES
NO```

# AI分析结果

### 题目内容重写
# Divide and Equalize

## 题目描述

### 题目大意
给你一个包含 $n$ 个正整数的数组 $a$，你可以进行以下操作：
1. 选两个数$a_i$和$a_j$ （$1 ＜ i, j \le n$且$i \ne j$）
2. 选择$a_i$的一个因数$x$
3. 将$a_i$替换为$\frac{a_i}{x}$，$a_j$替换为$a_j \cdot x$

请判断是否能通过有限次操作使 $a$ 中所有元素相同（可以是$0$次）。

例如：

$a=[100,2,50,10,1]$共$5$个数，那么进行以下两次操作：
1. 选择$a_3=50,a_2=2,x=5$，则$a_3=\frac{a_3}{x}=\frac{50}{5}=10,a_2=2\cdot5=10$，$a$变为$[100,10,10,10,1]$
2. 选择$a_1=100,a_5=1,x=10$，则$a_3=\frac{a_1}{x}=\frac{100}{10}=10,a_2=1\cdot10=10$，$a$变为$[10,10,10,10,10]$

经过以上操作后，$a$里面的元素都变成了$10$

## 说明/提示

第一组样例数据已在“题目大意”中有解释。

## 样例 #1

### 输入

```
7
5
100 2 50 10 1
3
1 1 1
4
8 2 4 2
4
30 50 27 20
2
75 40
2
4 4
3
2 3 1```

### 输出

```
YES
YES
NO
YES
NO
YES
NO```

### 算法分类
数学

### 题解分析与结论
所有题解的核心思路都是通过质因数分解来判断是否可以将所有数的质因数均匀分配，使得最终所有数相等。具体来说，每个质因数的总次数必须是 $n$ 的倍数，这样才能均匀分配到每个数中。

### 所选高星题解
1. **作者：Unstalian (赞：6)**
   - **星级：4星**
   - **关键亮点：**
     - 使用 `map` 来存储质因数及其次数，代码简洁且高效。
     - 通过质因数分解和检查每个质因数的次数是否为 $n$ 的倍数来判断是否可行。
   - **核心代码：**
     ```cpp
     void check(int x) {
         for (int i = 2; i <= sqrt(x); i++) {
             while (x % i == 0) {
                 q[i]++;
                 x /= i;
             }
         }
         if (x > 1) q[x]++;
     }
     ```

2. **作者：linxuanrui (赞：1)**
   - **星级：4星**
   - **关键亮点：**
     - 使用欧拉筛法预处理质数，优化了质因数分解的效率。
     - 通过检查每个质因数的次数是否为 $n$ 的倍数来判断是否可行。
   - **核心代码：**
     ```cpp
     for (int i = 2; i <= 1000000; i++) {
         if (prime[i]) t[++len] = i, minp[i] = len;
         for (int j = 1; j <= len && t[j] * i <= 1000000; j++) {
             prime[t[j] * i] = false;
             minp[t[j] * i] = min(minp[t[j]], minp[i]);
             if (i % t[j] == 0) break;
         }
     }
     ```

3. **作者：haokee (赞：0)**
   - **星级：4星**
   - **关键亮点：**
     - 使用 `map` 来存储质因数及其次数，代码简洁且高效。
     - 通过质因数分解和检查每个质因数的次数是否为 $n$ 的倍数来判断是否可行。
   - **核心代码：**
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 2; j * j <= a[i]; j++) {
             for (; a[i] % j == 0; a[i] /= j) {
                 f[j]++;
             }
         }
         if (a[i] != 1) {
             f[a[i]]++;
         }
     }
     ```

### 最优关键思路
1. **质因数分解**：将每个数分解为质因数的乘积，统计每个质因数的总次数。
2. **均匀分配**：检查每个质因数的总次数是否为 $n$ 的倍数，如果是则可以均匀分配到每个数中，使得所有数相等。

### 可拓展之处
- **类似题目**：可以扩展到多个数的最大公约数或最小公倍数问题，或者涉及质因数分解的其他数学问题。

### 推荐题目
1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
2. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)
3. [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)

### 个人心得
- **调试经历**：在质因数分解时，需要注意处理质数本身的情况，避免遗漏。
- **顿悟感想**：通过质因数分解和均匀分配的思路，可以简化复杂的问题，提高解题效率。

---
处理用时：32.12秒
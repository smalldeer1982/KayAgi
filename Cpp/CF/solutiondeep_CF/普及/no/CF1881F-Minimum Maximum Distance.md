# 题目信息

# Minimum Maximum Distance

## 题目描述

一棵树有 $n$ 个点，其中有一些节点被打了标记。保证树是联通且无环的。

定义 $ f_i $ 为第 $ i $ 个节点到所有被标记节点距离的最大值。

你的任务是找出所有点的 $ f_i $ 的最小值。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1881F/d0163dde57a696d8d96936900f0fefe6ef32a7ae.png)
 
举个例子，一棵树如上图所示，被标记节点为 $ 2 $ , $ 6 $ , $ 7 $。 因此 $ f(i) = [2, 3, 2, 4, 4, 3, 3] $。$ f_i $  最小的为 $ 1 $ 和 $ 3 $ 节点，且最小值为 $2$。

## 样例 #1

### 输入

```
6
7 3
2 6 7
1 2
1 3
2 4
2 5
3 6
3 7
4 4
1 2 3 4
1 2
2 3
3 4
5 1
1
1 2
1 3
1 4
1 5
5 2
4 5
1 2
2 3
1 4
4 5
10 8
1 2 3 4 5 8 9 10
2 10
10 5
5 3
3 1
1 7
7 4
4 9
8 9
6 1
10 9
1 2 4 5 6 7 8 9 10
1 3
3 9
9 4
4 10
10 6
6 7
7 2
2 5
5 8```

### 输出

```
2
2
0
1
4
5```

## 样例 #2

### 输入

```
3
6 1
3
1 2
1 3
3 4
3 5
2 6
5 3
1 2 5
1 2
1 3
2 4
3 5
7 1
2
3 2
2 6
6 1
5 6
7 6
4 5```

### 输出

```
0
2
0```

# AI分析结果

### 题目翻译
# 最小最大距离

## 题目描述

一棵树有 $n$ 个点，其中有一些节点被打了标记。保证树是联通且无环的。

定义 $ f_i $ 为第 $ i $ 个节点到所有被标记节点距离的最大值。

你的任务是找出所有点的 $ f_i $ 的最小值。

### 样例 #1

#### 输入

```
6
7 3
2 6 7
1 2
1 3
2 4
2 5
3 6
3 7
4 4
1 2 3 4
1 2
2 3
3 4
5 1
1
1 2
1 3
1 4
1 5
5 2
4 5
1 2
2 3
1 4
4 5
10 8
1 2 3 4 5 8 9 10
2 10
10 5
5 3
3 1
1 7
7 4
4 9
8 9
6 1
10 9
1 2 4 5 6 7 8 9 10
1 3
3 9
9 4
4 10
10 6
6 7
7 2
2 5
5 8```

#### 输出

```
2
2
0
1
4
5```

### 样例 #2

#### 输入

```
3
6 1
3
1 2
1 3
3 4
3 5
2 6
5 3
1 2 5
1 2
1 3
2 4
3 5
7 1
2
3 2
2 6
6 1
5 6
7 6
4 5```

#### 输出

```
0
2
0```

### 算法分类
图论

### 题解分析与结论
本题的核心是找到树中所有节点到标记节点的最大距离的最小值。多个题解都提出了类似的方法：通过两次DFS找到树中两个最远的标记节点，然后计算它们之间的距离，最后取该距离的一半（向上取整）作为答案。这种方法的时间复杂度为O(n)，且实现较为简洁。

### 高星题解
#### 1. 作者：LHLeisus (赞：4)
- **星级**：★★★★★
- **关键亮点**：通过两次DFS找到最远的两个标记节点，计算它们之间的距离并取半，思路清晰且代码简洁。
- **核心代码**：
```cpp
void dfs(int u, int fa){
    for(int i=head[u];i;i=edge[i].nex){
        int v=edge[i].to;
        if(v==fa) continue;
        dist[v]=dist[u]+1;
        dfs(v,u);
        if(mark[v]&&dist[v]>dist[c]) c=v;
    }
}
```
- **实现思想**：第一次DFS找到距离根节点最远的标记节点，第二次DFS从该节点出发找到最远的标记节点，计算距离并取半。

#### 2. 作者：wangyishan (赞：3)
- **星级**：★★★★
- **关键亮点**：同样使用两次DFS找到最远的两个标记节点，代码实现简洁且易于理解。
- **核心代码**：
```cpp
void dfs1(int x, int fa) {
    if (fa != -1) f[x] = f[fa] + 1;
    for (auto i : e[x]) {
        if (i == fa) continue;
        dfs1(i, x);
    }
}
```
- **实现思想**：通过两次DFS找到最远的两个标记节点，计算它们之间的距离并取半。

#### 3. 作者：AtCo (赞：1)
- **星级**：★★★★
- **关键亮点**：通过两次DFS找到最远的两个标记节点，计算它们之间的距离并取半，代码实现简洁。
- **核心代码**：
```cpp
void dfs(int now, int lst, int dis) {
    if (biaoji[now] && dis > mx) {mx = max(mx, dis), mxid = now;}
    for (auto nxt : e[now]) if (nxt != lst) dfs(nxt, now, dis + 1);
    return ;
}
```
- **实现思想**：第一次DFS找到距离根节点最远的标记节点，第二次DFS从该节点出发找到最远的标记节点，计算距离并取半。

### 最优关键思路
通过两次DFS找到树中两个最远的标记节点，计算它们之间的距离并取半。这种方法的时间复杂度为O(n)，且实现简洁。

### 可拓展之处
类似的问题可以扩展到其他图结构，如加权图或有向图，或者需要计算多个标记节点的最小最大距离。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得
在实现DFS时，注意标记节点的处理，确保每次DFS都能正确找到最远的标记节点。此外，计算距离时要注意取半并向上取整。

---
处理用时：33.44秒
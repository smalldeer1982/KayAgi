# 题目信息

# Qingshan Loves Strings 2

## 题目描述

我们称长度为 $ k $ 的01串 $ a $ 是**好的**且仅当

- $ \forall i \in \left [ 1,k  \right ], a_i \ne a_{k-i+1}$

比如，$ \texttt{10} $ , $ \texttt{1010} $ , $ \texttt{111000} $ 是好的，而 $ \texttt{11} $ , $ \texttt{101} $ , $ \texttt{001} $ , $ \texttt{001100} $ 不是好的。

现在给你一个01串 $ s $，你可以执行不多于 $ 300 $ 次以下操作使得 $ s $ 变为好的（次数可以为 $ 0 $）：

- $ \text{插入} \texttt{01} \text{到} s \text{的任意位置} $

请你判断是否有解，并在有解的情况下输出操作次数和每个操作的插入位置。

## 说明/提示

在第一组样例中，你不需要进行任何操作就可以使 $ s $ 为好的01串。

另一种方法是插入$\texttt{01}$到第 $ 1 $ 项后面，即：

1. $ \texttt{0}\underline{\texttt{01}}\texttt{1} $

最终 $ s = \texttt{0011} $，是好的01串。

在第二组样例中，没有办法使 $ s $ 变好。

在第四组样例中，你可以进行如下操作：

1. $ \texttt{001110}\underline{\texttt{01}} $
2. $ \texttt{0011100}\underline{\texttt{01}}\texttt{1} $

最终 $ s = \texttt{0011100011} $，是好的01串。

## 样例 #1

### 输入

```
6
2
01
3
000
4
1111
6
001110
10
0111001100
3
001```

### 输出

```
0

-1
-1
2
6 7
1
10
-1```

# AI分析结果

### 题目重写
# Qingshan Loves Strings 2

## 题目描述

我们称长度为 $ k $ 的01串 $ a $ 是**好的**且仅当

- $ \forall i \in \left [ 1,k  \right ], a_i \ne a_{k-i+1}$

比如，$ \texttt{10} $ , $ \texttt{1010} $ , $ \texttt{111000} $ 是好的，而 $ \texttt{11} $ , $ \texttt{101} $ , $ \texttt{001} $ , $ \texttt{001100} $ 不是好的。

现在给你一个01串 $ s $，你可以执行不多于 $ 300 $ 次以下操作使得 $ s $ 变为好的（次数可以为 $ 0 $）：

- $ \text{插入} \texttt{01} \text{到} s \text{的任意位置} $

请你判断是否有解，并在有解的情况下输出操作次数和每个操作的插入位置。

## 说明/提示

在第一组样例中，你不需要进行任何操作就可以使 $ s $ 为好的01串。

另一种方法是插入$\texttt{01}$到第 $ 1 $ 项后面，即：

1. $ \texttt{0}\underline{\texttt{01}}\texttt{1} $

最终 $ s = \texttt{0011} $，是好的01串。

在第二组样例中，没有办法使 $ s $ 变好。

在第四组样例中，你可以进行如下操作：

1. $ \texttt{001110}\underline{\texttt{01}} $
2. $ \texttt{0011100}\underline{\texttt{01}}\texttt{1} $

最终 $ s = \texttt{0011100011} $，是好的01串。

## 样例 #1

### 输入

```
6
2
01
3
000
4
1111
6
001110
10
0111001100
3
001```

### 输出

```
0

-1
-1
2
6 7
1
10
-1```

### 算法分类
构造

### 题解分析与结论
这道题的核心在于如何通过插入“01”来使得字符串满足“好的”条件。所有题解都首先判断了字符串中0和1的个数是否相等，因为这是有解的必要条件。然后，通过不同的策略来构造满足条件的字符串。

- **251Sec**的题解通过双端队列模拟插入操作，逐步消除不满足条件的字符对，最终得到满足条件的字符串。其代码简洁且逻辑清晰，操作次数控制在合理范围内。
- **LXcjh4998**的题解使用双指针遍历字符串，根据字符对的情况决定插入位置，模拟插入操作并记录位置。其思路直观，但代码实现较为复杂。
- **MoyunAllgorithm**的题解通过递归处理子问题，逐步构造满足条件的字符串。其思路新颖，但递归的实现可能带来额外的复杂度。

### 精选题解
1. **251Sec**（5星）
   - **关键亮点**：使用双端队列模拟插入操作，逻辑清晰，代码简洁。
   - **核心代码**：
     ```cpp
     while (a.size()) {
         if (a.front() != a.back()) {
             a.pop_back();
             a.pop_front();
             del++;
             continue;
         }
         if (a.front() == 0) {
             ope[++oC] = a.size() + del;
             a.push_back(0);
             a.push_back(1);
         }
         else {
             ope[++oC] = del;
             a.push_front(1);
             a.push_front(0);
         }
     }
     ```

2. **LXcjh4998**（4星）
   - **关键亮点**：使用双指针遍历字符串，模拟插入操作并记录位置。
   - **核心代码**：
     ```cpp
     for (int i = 1, j = len; i < j;) {
         if (str[i] == '0' && str[j] == '0') {
             arr[ans++] = j;
             for (int k = len + 1, l = len + 3; k > j; --k, --l) str[l] = str[k];
             str[j + 1] = '0', str[j + 2] = '1';
             len += 2, ++i, ++j;
         }
         else if (str[i] == '1' && str[j] == '1') {
             arr[ans++] = i - 1;
             for (int k = len + 1, l = len + 3; k >= i; --k, --l) str[l] = str[k];
             str[i] = '0', str[i + 1] = '1';
             len += 2, ++i, ++j;
         }
         else ++i, --j;
     }
     ```

### 最优关键思路
通过双端队列或双指针模拟插入操作，逐步消除不满足条件的字符对，最终构造满足条件的字符串。关键在于如何高效地处理字符对并记录插入位置。

### 拓展思路
类似的问题可以通过模拟或递归的方式解决，关键在于如何设计合理的策略来逐步构造满足条件的解。

### 推荐题目
1. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
2. [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)
3. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)

---
处理用时：37.33秒
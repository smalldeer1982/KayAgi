# 题目信息

# Permutation Counting

## 题目描述

你有一些卡片。具体地，你有 $a_i$ 张写着 $i$ 的卡片 $(i\in [1,n])$。

现在你可以从商店购买 $k$ 张空白卡片，并且在这 $k$ 张卡片上任意填上一个 $[1,n]$ 中的整数。

定义一个序列是 $n$ 好的，且仅当它长度为 $n$ 且升序排序后是 $1$ 到 $n$ 的排列。

购买并填完 $k$ 张卡片后，你需要重新将这些卡片排序，使得你的序列中的 $n$ 好子段个数最多并求出个数。

## 说明/提示

$1\le n\le 2\times 10^5,0\le a_i,k\le 10^{12},1\le T\le 100,1\le\sum n\le 5\times 10^5$

## 样例 #1

### 输入

```
8
1 10
1
2 4
8 4
3 4
6 1 8
3 9
7 6 2
5 3
6 6 7 4 6
9 7
7 6 1 7 6 2 4 3 3
10 10
1 3 1 2 1 9 3 5 7 5
9 8
5 8 7 5 1 3 2 9 8```

### 输出

```
11
15
15
22
28
32
28
36```

# AI分析结果



【算法分类】
贪心、二分

【题解分析与结论】

题目核心在于通过分配k张卡使n好子段最大化。关键思路是最大化每个位置的最小值以形成完整轮次，剩余资源均匀分配。

**最优思路提炼**：
1. **贪心策略**：排序后找到前i项能统一提升的最大最小值，剩余k均匀分配。公式推导完整轮次和余数贡献。
2. **二分策略**：二分可能的最小值x，验证能否通过k次填补到x，再计算总子段数。

【高星题解推荐】

1. **yanqijin的题解（★★★★☆）**
   - **亮点**：线性贪心+数学公式直接计算，时间复杂度O(n log n)更优。代码简洁，公式推导巧妙。
   - **核心代码**：
     ```cpp
     sort(a+1,a+1+n);
     for(int i=1;i<=n;i++) {
         sum += a[i];
         if(a[i]*i - sum <=k) id=i, gg=...;
     }
     // 剩余k均匀分配并计算答案
     ```
   - **心得**：通过排序后累加快速找到可提升的最大id，体现贪心本质。

2. **exCat的题解（★★★★☆）**
   - **亮点**：二分答案直观清晰，验证过程简单，适合快速理解最小值约束。
   - **核心代码**：
     ```cpp
     ll check(ll x) {
         ll sum=0, cnt=0;
         for(int i=1; i<=n; i++) {
             if(a[i] <=x) sum +=x -a[i], cnt++;
         }
         return sum <=k ? cnt : ee;
     }
     // 二分查找最大值并计算最终结果
     ```
   - **心得**：二分法直接定位最小值的上限，通用性强。

【拓展与推荐】
- **同类技巧题**：贪心策略常见于资源分配问题（如P1251），二分答案适用于最值约束问题（如P2440、P2678）。
- **推荐题目**： 
  1. P2440 - 木材加工（二分答案）
  2. P2678 - 跳石头（二分应用）
  3. P1251 - 餐巾计划问题（贪心+资源分配）

---
处理用时：67.07秒
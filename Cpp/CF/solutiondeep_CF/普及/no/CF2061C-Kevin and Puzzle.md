# 题目信息

# Kevin and Puzzle

## 题目描述

有 $n$ 个人排成一行，第 $i$ 个人说他的左边有 $a_i$ 个说谎的人。

每个人要么诚实，要么说谎，诚实的人总是说真话，说谎的人说的话可真可假，没有两个说谎的人站在一起。

两个方案被认为是不同的，应当使至少一个人在一个方案诚实，在另外一个方案说谎。请输出不同的方案数对 $998244353$ 取模的结果。

## 样例 #1

### 输入

```
8
3
0 1 2
5
0 0 0 0 0
5
0 0 1 1 2
5
0 1 2 3 4
5
0 0 1 1 1
5
5 1 5 2 5
1
0
4
2 3 1 1```

### 输出

```
1
2
3
0
4
1
2
0```

# AI分析结果



### 题目内容中文重写
#### Kevin and Puzzle

##### 题目描述

有 $n$ 个人排成一行，第 $i$ 个人说他的左边有 $a_i$ 个说谎的人。

每个人要么诚实，要么说谎。诚实的人总是说真话，说谎的人说的话可真可假，且没有两个说谎的人相邻。

两个方案不同当且仅当至少一个人在一个方案中诚实，在另一个方案中说谎。求不同方案数模 $998244353$ 的结果。

##### 样例 #1

###### 输入
```
8
3
0 1 2
5
0 0 0 0 0
5
0 0 1 1 2
5
0 1 2 3 4
5
0 0 1 1 1
5
5 1 5 2 5
1
0
4
2 3 1 1
```

###### 输出
```
1
2
3
0
4
1
2
0
```

---

### 算法分类
**动态规划**

---

### 题解综合分析

各题解均采用动态规划思路，核心状态设计为 `dp[i][0/1]` 表示前 `i` 个人中第 `i` 个人说谎/诚实的方案数。主要差异在于状态转移条件的处理和边界初始化：

1. **状态转移逻辑**：
   - **说谎者转移**：若当前是说谎者，前一人必须是诚实者，即 `dp[i][0] = dp[i-1][1]`
   - **诚实者转移**：
     - 若前一人诚实，则需 `a[i] = a[i-1]`
     - 若前一人说谎，则需 `a[i] = a[i-2] + 1`（利用全局数组默认初始值处理 `i=2` 时 `a[0]` 的边界）

2. **初始化关键**：
   - 第一人若诚实，需满足 `a[1] = 0`
   - 第一人作为说谎者的初始方案数总为1

3. **共同难点**：
   - 处理 `i=2` 时的 `a[i-2]` 越界问题（通过全局数组默认初始化解决）
   - 动态规划转移条件的严格匹配

---

### 精选题解（评分≥4星）

#### 1. ARIS2_0 的题解（★★★★★）
**关键亮点**：
- 状态转移方程清晰，利用全局数组默认初始值巧妙处理边界
- 代码简洁，直接通过条件判断实现转移
- 初始化条件处理严谨，符合逻辑

**代码核心**：
```cpp
// 初始化
dp[1][0] = 1;
if (a[1] == 0) dp[1][1] = 1;

// 转移
for (int i=2; i<=n; i++) {
    dp[i][0] = dp[i-1][1];
    dp[i][1] = 0;
    if (a[i] == a[i-1]) dp[i][1] += dp[i-1][1];
    if (a[i] == a[i-2] + 1) dp[i][1] += dp[i-1][0];
}
```

#### 2. CraaazyShep 的题解（★★★★☆）
**关键亮点**：
- 变量命名清晰（`f1/f2` 区分状态）
- 通过滚动数组优化空间复杂度
- 代码结构规范，可读性强

**代码核心**：
```cpp
vector<long long> f1(n+1), f2(n+1);
// 初始化
if (a[1] == 0) f1[1] = 1;
f2[1] = 1;

// 转移
for (int i=2; i<=n; i++) {
    f2[i] = f1[i-1];
    if (a[i] == a[i-1]) f1[i] += f1[i-1];
    if (a[i] == a[i-2] + 1) f1[i] += f2[i-1];
}
```

#### 3. K_yuxiang_rose 的题解（★★★★☆）
**关键亮点**：
- 代码模块化处理，便于调试
- 明确注释转移条件对应的逻辑场景
- 通过取模优化避免溢出

**代码核心**：
```cpp
// 初始化
dp[1][0] = 1;
if (a[1] == 0) dp[1][1] = 1;

// 转移
for (int i=2; i<=n; i++) {
    dp[i][0] = dp[i-1][1];
    if (a[i] == a[i-1]) dp[i][1] += dp[i-1][0];
    if (a[i] == a[i-2] + 1) dp[i][1] += dp[i-1][1];
    dp[i][1] %= mod;
}
```

---

### 关键思路总结
1. **状态设计**：`dp[i][0/1]` 表示第 `i` 人说谎/诚实的方案数
2. **转移条件**：
   - 说谎者只能从前一诚实者转移
   - 诚实者需满足 `a[i] = a[i-1]`（前一人诚实）或 `a[i] = a[i-2]+1`（前一人说谎）
3. **边界处理**：利用全局数组默认初始值简化 `i=2` 时的越界判断

---

### 拓展建议
- **类似题目**：可练习状态依赖前后位置的动态规划问题，如[CF455A Boredom](https://www.luogu.com.cn/problem/CF455A)
- **优化方向**：尝试滚动数组优化空间复杂度至 $O(1)$

---

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)（树形DP）
2. [CF118D Caesar's Legions](https://www.luogu.com.cn/problem/CF118D)（双状态DP）
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（经典背包DP）

---
处理用时：196.91秒
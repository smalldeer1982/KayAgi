# 题目信息

# Cirno and Operations

## 题目描述

Cirno 有一个长度为 $n$ 的序列 $a$ 。她可以执行以下两种操作中的任意一种（可能零次），除非当前序列 $a$ 的长度为 $1$：

- 反转序列。严格来说，序列 $[a_1, a_2, \ldots, a_n]$ 变为 $[a_n, a_{n-1}, \ldots, a_1]$。
- 将序列替换为其差分序列。严格来说，序列 $[a_1, a_2, \ldots, a_n]$ 变为 $[a_2 - a_1, a_3 - a_2, \ldots, a_n - a_{n-1}]$。

在所有操作之后，找到序列 $a$ 的元素和的最大值。

## 说明/提示

在第一个测试用例中，Cirno 无法进行任何操作，因此答案是 $-1000$。

在第二个测试用例中，Cirno 首先反转序列，然后将其替换为差分序列：$[5, -3] \to [-3, 5] \to [8]$。可以证明这样能使总和最大化，因此答案是 $8$。

在第三个测试用例中，Cirno 可以选择不进行任何操作，因此答案是 $1001$。

## 样例 #1

### 输入

```
5
1
-1000
2
5 -3
2
1000 1
9
9 7 9 -9 9 -8 7 -8 9
11
678 201 340 444 453 922 128 987 127 752 0```

### 输出

```
-1000
8
1001
2056
269891```

# AI分析结果



# Cirno and Operations

## 题目描述

Cirno 有一个长度为 $n$ 的序列 $a$。她可以执行以下两种操作中的任意一种（可能零次），除非当前序列 $a$ 的长度为 1：

- **反转序列**：将序列 $[a_1, a_2, \ldots, a_n]$ 变为 $[a_n, a_{n-1}, \ldots, a_1]$。
- **替换为差分序列**：将序列 $[a_1, a_2, \ldots, a_n]$ 变为 $[a_2 - a_1, a_3 - a_2, \ldots, a_n - a_{n-1}]$。

在所有操作之后，找到序列 $a$ 的元素和的最大值。

## 算法分类
数学、模拟

---

## 题解分析与结论

### 核心思路
1. **反转操作不影响总和**：反转序列本身不会改变元素和，但会影响后续差分操作的符号。
2. **差分操作的符号优化**：每次差分后的总和可以通过反转操作取其绝对值。例如，差分后的和为 $S$，反转后的和为 $-S$，因此只需维护绝对值即可。
3. **迭代差分过程**：由于每次差分会减少序列长度，最多进行 $n-1$ 次差分操作。每次差分后计算当前和的绝对值，并更新最大值。
4. **初始和特殊处理**：原始序列的和不能取绝对值（否则会错误覆盖负数最优解的情况）。

### 关键代码实现
维护当前数组，迭代差分并取绝对值：
```cpp
long long ans = original_sum;
while (n > 1) {
    long long diff_sum = 0;
    // 计算差分后的和
    for (int i = 1; i < n; i++) {
        a[i] = a[i+1] - a[i];
        diff_sum += a[i];
    }
    n--;
    ans = max(ans, abs(diff_sum)); // 取绝对值更新最大值
}
```

---

## 精选题解

### 题解1：Yannik（5星）
**关键亮点**：
- 直接通过 `max(sum, -sum)` 处理反转操作的符号影响。
- 代码简洁，时间复杂度 $O(n^2)$，完全适配数据范围。

```cpp
int ans = original_sum;
while (n > 1) {
    // 差分操作
    int sum = 0;
    for (int i = 1; i <= n; i++) sum += a[i];
    ans = max(ans, max(sum, -sum));
    n--;
}
```

### 题解2：Milthm（4星）
**关键亮点**：
- 显式区分初始和与差分后的处理，避免初始值被误取绝对值。
- 通过逆序枚举差分次数简化代码逻辑。

```cpp
for (int i = n; i >= 1; i--) {
    int sum = 0;
    for (int j = 1; j <= i; j++) sum += a[j];
    ans = max(ans, (i == n) ? sum : abs(sum)); // 初始和特殊处理
    // 差分操作更新数组
}
```

### 题解3：Lovely_Elaina（4星）
**关键亮点**：
- 使用显式变量维护当前最大值，逻辑清晰。
- 通过数组拷贝实现差分过程，避免原数组污染。

```cpp
long long ma = original_sum;
while (n > 1) {
    long long cnt2 = 0;
    // 差分并计算和
    for (int i = 1; i < n; i++) {
        b[i] = a[i+1] - a[i];
        cnt2 += b[i];
    }
    ma = max(ma, abs(cnt2)); // 更新最大值
    n--;
}
```

---

## 举一反三
1. **差分性质扩展**：差分操作在动态维护序列变化时的符号影响。
2. **贪心取极值**：通过绝对值优化选择反转操作的方向。
3. **边界处理技巧**：初始状态的独立处理避免逻辑错误。

### 推荐练习题
1. [P3948 数列操作](https://www.luogu.com.cn/problem/P3948)（差分与前缀和）
2. [P1438 无聊的数列](https://www.luogu.com.cn/problem/P1438)（差分数组应用）
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)（差分与前缀和的进阶结合）

---
处理用时：100.22秒
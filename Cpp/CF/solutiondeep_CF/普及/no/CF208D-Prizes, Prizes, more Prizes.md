# 题目信息

# Prizes, Prizes, more Prizes

## 题目描述

## 题意
你有 n 块巧克力可以吃，每块巧克力包装背后有一个积分，要用这些积分去换 5 种不同价格的礼物。你每次只能吃一块，吃完后去换礼物，要求先换价格尽量高的礼物，然后要把积分尽量用完，用不完的积分可以留在下一次和下一个积分合并再用。请输出能换到每种礼物的数量和剩余的积分。

## 样例 #1

### 输入

```
3
3 10 4
2 4 10 15 20
```

### 输出

```
1 1 1 0 0 
1
```

## 样例 #2

### 输入

```
4
10 4 39 2
3 5 10 11 12
```

### 输出

```
3 0 1 0 3 
0
```

# AI分析结果



### 题目重写
# 奖品，更多的奖品

## 题目描述

### 题意
你有 n 块巧克力可以吃，每块巧克力包装背后有一个积分。需要用这些积分兑换 5 种不同价格的礼物。每次吃完一块巧克力后立即兑换礼物，要求优先兑换价格最高的礼物，并尽可能用完所有积分。未用完的积分可与后续获得的积分合并使用。最终输出每种礼物的兑换数量和剩余积分。

---

### 算法分类
贪心

---

### 题解综合分析
所有题解均采用贪心算法，核心思路为：  
1. 累计每块巧克力积分  
2. 倒序遍历礼物价格（从高到低）  
3. 用除法快速计算可兑换数量，余数作为剩余积分  
关键差异在于变量命名规范性与数据类型处理（long long 使用）

---

### 精选题解

#### 1. _Evergarden_ 题解（⭐⭐⭐⭐⭐）
**亮点**：  
- 使用显式 long long 类型确保数据安全  
- 变量命名规范（ans数组存储结果，now表示当前积分）  
- 代码结构清晰，包含输入优化  

核心代码：
```cpp
signed main() {
    int n; cin >> n;
    for(int i = 1; i <= n; ++i) cin >> p[i];
    for(int i = 1; i <= 5; ++i) cin >> a[i];
    for(int i = 1; i <= n; ++i) {
        now += p[i];
        for(int j = 5; j >= 1; --j) {
            if(now >= a[j]) {
                ans[j] += now / a[j];
                now -= (now / a[j]) * a[j];
            }
        }
    }
    // 输出部分略
}
```

#### 2. fuzhelin1984 题解（⭐⭐⭐⭐）
**亮点**：  
- 直接使用减法操作代替取模，逻辑直观  
- 变量命名简洁（sum表示总积分，b数组存储结果）  

核心代码：
```cpp
for(int i = 1;i <= n;++i) {
    sum += c[i];
    for(int j = 5;j >= 1;--j) {
        if(sum >= a[j]) {
            int syy = sum / a[j];
            b[j] += syy;
            sum -= syy * a[j];
        }
    }
}
```

---

### 关键思路总结
1. **贪心策略**：倒序处理高价礼物，确保每次优先兑换价值最高的  
2. **积分合并**：维护累计积分变量，实现跨次合并使用  
3. **数值优化**：用除法代替循环减法，时间复杂度降为 O(n*5)  
4. **数据类型**：使用 long long 防止大数溢出（尤其积分累加场景）

---

### 拓展思考
同类问题可延伸至货币兑换、资源分配等场景。例如：  
- 零钱兑换问题（用最少的硬币数组成金额）  
- 任务调度中的优先级分配  

推荐练习题目：  
1. P4995 跳跳！ - 贪心+排序  
2. P1090 [NOIP2004 提高组] 合并果子 - 优先队列应用  
3. P1208 [USACO1.3]混合牛奶 Mixing Milk - 典型贪心问题  

---

### 题解心得摘录
zwy__ 题解强调：  
> "这题不管是数组还是变量都要开 long long，不然就会错！！！"  
验证了数据范围意识的重要性，当 n=1e5 且积分较大时，int 类型会导致溢出。

---
处理用时：43.65秒
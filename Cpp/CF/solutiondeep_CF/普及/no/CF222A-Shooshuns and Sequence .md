# 题目信息

# Shooshuns and Sequence 

## 题目描述

有一天，shooshuns发现了$n$个整数的序列，写在黑板上。 shooshuns可以执行一个操作，该操作包括两个步骤：

1. 找到当前序列中第$k$个数字，并将相同的数字添加到序列的末尾；
2. 删除当前序列的第一个数字。
shooshuns想知道板子上的所有数字将要进行多少次操作，才可以让所有数字相同。

## 说明/提示

样例$1$：\
第一个操作之后，将具有顺序$[1，1，1]$。 因此，一个操作足以使所有数字相同，所以答案等于$1$。

样例$2$：\
序列将永远不会让所有数字相同。它始终将包含两个不同的数字$3$和$1$。因此，答案等于$-1$。

## 样例 #1

### 输入

```
3 2
3 1 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3 1
3 1 1
```

### 输出

```
-1
```

# AI分析结果



# Shooshuns and Sequence 

## 题目描述

有一天，shooshuns发现了$n$个整数的序列，写在黑板上。 shooshuns可以执行一个操作，该操作包括两个步骤：

1. 找到当前序列中第$k$个数字，并将相同的数字添加到序列的末尾；
2. 删除当前序列的第一个数字。
shooshuns想知道板子上的所有数字将要进行多少次操作，才可以让所有数字相同。

## 说明/提示

样例$1$：\
第一个操作之后，将具有顺序$[1，1，1]$。 因此，一个操作足以使所有数字相同，所以答案等于$1$。

样例$2$：\
序列将永远不会让所有数字相同。它始终将包含两个不同的数字$3$和$1$。因此，答案等于$-1$。

---

**算法分类**：构造

---

### 题解分析与结论

所有题解的核心思路分为两步：
1. **无解判断**：若从第$k$个元素开始到序列末尾存在不同值，则无法通过操作使所有元素相同。
2. **操作次数计算**：找到$k$之前最后一个与第$k$个元素不同的位置，其索引即为所需操作次数。

#### 关键思路
- **无解条件**：检查$[k, n]$区间元素是否全相同。
- **构造解法**：在$[1, k-1]$区间中，最后一个不同元素的索引即为答案。
- **索引优化**：反向遍历可快速定位最后一个不同元素。

---

### 精选题解

#### 1. Cloote（★★★★☆）
**亮点**：  
- 简洁的反向遍历实现，快速定位最后一个不同元素。
- 包含调试过程的心得，强调特判全相同情况。

**核心代码**：
```cpp
for(int i=k;i<=n-1;i++) // 判断无解
    if(a[i]!=a[i+1]) return cout<<-1,0;
for(int i=k-1;i>=1;i--) // 反向找最后一个不同元素
    if(a[i]!=a[k]) return cout<<i,0;
```

#### 2. Big_Brain（★★★★☆）
**亮点**：  
- 详细分步解释构造逻辑，代码可读性强。
- 正确处理全相同情况的输出。

**核心代码**：
```cpp
for(int i=k;i<=n;i++) // 检查无解
    if(a[i]!=a[k]) exit(0);
for(int i=1;i<k;i++) // 正向记录最后一个不同位置
    if(a[i]!=a[k]) ans=i;
```

#### 3. XiaoQuQu（★★★★☆）
**亮点**：  
- 数学推导操作次数公式，直接计算无需模拟。
- 通过后序相同段长度优化时间复杂度。

**核心代码**：
```cpp
int ans = n;
for(int i=n;i>=1;i--) // 倒序计算后序相同段
    if(a[i]==a[n]) ans--;
```

---

### 关键技巧总结
1. **边界检查优先**：先处理无解情况，避免无效计算。
2. **索引逆向思维**：反向遍历可快速定位关键位置。
3. **数学优化**：利用连续相同段的长度特性减少循环次数。

---

### 拓展练习
1. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（构造连续序列）
2. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)（贪心构造）
3. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（双指针/哈希表构造）

---
处理用时：130.98秒
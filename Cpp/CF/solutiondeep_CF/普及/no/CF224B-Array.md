# 题目信息

# Array

## 题目描述

给一个长度为n的数列，其中每一个数都是正整数，第一个数的标号为1，求一个区间[l,r]，使得这个区间里一共含有k个不同的数，并且要使这个区间里的所有数之和尽可能的小。

## 样例 #1

### 输入

```
4 2
1 2 2 3
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
8 3
1 1 2 2 3 3 4 5
```

### 输出

```
2 5
```

## 样例 #3

### 输入

```
7 4
4 7 7 4 7 4 7
```

### 输出

```
-1 -1
```

# AI分析结果



# 题目中文翻译

## 题目描述

给定一个长度为n的正整数数列（下标从1开始），求一个区间[l,r]，使得区间内恰好包含k个不同的数，并且该区间所有数的和尽可能小。若不存在这样的区间则输出"-1 -1"。

## 样例 #1

### 输入
```
4 2
1 2 2 3
```

### 输出
```
1 2
```

## 样例 #2

### 输入
```
8 3
1 1 2 2 3 3 4 5
```

### 输出
```
2 5
```

## 样例 #3

### 输入
```
7 4
4 7 7 4 7 4 7
```

### 输出
```
-1 -1
```

**算法分类**：双指针（尺取法）

---

# 题解分析与结论

**核心思路**：使用双指针维护滑动窗口，右指针扩展至窗口包含k个不同元素，左指针尽可能右移以缩小区间并保持k个不同元素。通过哈希表维护元素频次，利用前缀和快速计算区间和。

**关键优化点**：
1. 当窗口满足条件时，尽可能右移左指针以获取最小和
2. 利用数组计数替代哈希表提升效率
3. 前缀和预处理避免重复计算
4. 及时剪枝（例如当元素频次超过1时允许左指针移动）

---

# 精选题解

## 1. vanueber（4星）
**亮点**：代码简洁高效，利用频次数组优化空间，正确处理边界条件  
**代码核心**：
```cpp
int j=1;
for(int i=1;i<=n;i++) {
    cnt[a[i]]++;
    if(cnt[a[i]]==1) ++tot;
    while(tot>k||cnt[a[j]]>=2) { // 允许左移条件
        cnt[a[j]]--;
        tot-=(cnt[a[j]]==0);
        j++;
    }
    if(tot==k) {
        cout<<j<<" "<<i<<endl;
        return 0;
    }
}
```
**实现思想**：右指针i扩展窗口，左指针j在满足条件（总类数>k或首元素频次≥2）时右移。找到首个合法区间即返回。

## 2. DengDuck（4星）
**亮点**：严格维护最优解，处理无法找到解的情况  
**关键代码**：
```cpp
for(int i=1;i<=n;i++) {
    cnt[a[i]]++;
    if(cnt[a[i]]==1) tot++;
    while(tot>k&&t<=i) { // 强制保持≤k类
        cnt[a[t]]--;
        if(cnt[a[t]]==0) tot--;
        t++;
    }
    while(tot==k&&t<=i) { // 尝试继续缩小窗口
        if(cnt[a[t]]==1) break;
        cnt[a[t]]--;
        if(cnt[a[t]]==0) tot--;
        t++;
    }
    if(tot>=k) { // 更新全局最优
        if(sum[i]-sum[t-1]<=ans) {
            ansl=t, ansr=i;
            ans=sum[i]-sum[t-1];
        }
    }
}
```
**实现思想**：严格维护当前窗口在≤k类状态，找到满足条件的窗口后尝试进一步缩小，使用前缀和快速比较。

## 3. meimu75（4星）
**亮点**：完整处理求和溢出，清晰展现尺取法流程  
**关键片段**：
```cpp
while(r < n) {
    while(r < n && tot < k) { // 扩展右边界
        r++;
        if(!z[a[r]]) cnt++;
        z[a[r]]++;
    }
    while(l <= r && cnt == k) { // 收缩左边界
        if(sum[r]-sum[l-1] < ans) {
            ans = sum[r] - sum[l-1];
            ansl = l, ansr = r;
        }
        if(z[a[l]] == 1) cnt--;
        z[a[l]]--;
        l++;
    }
}
```
**实现思想**：完整的两阶段操作（先扩展右边界至满足条件，再收缩左边界找最小窗口），使用独立循环结构提升可读性。

---

# 关键思路总结

1. **双指针维护窗口**：右指针扩展至满足k类，左指针收缩优化解
2. **频次数组计数**：用数组代替哈希表统计元素出现次数（适用于元素值较小情况）
3. **前缀和优化**：预处理前缀和数组避免重复计算区间和
4. **贪心剪枝**：当窗口首元素频次≥2时允许左移，确保找到最小和
5. **边界处理**：初始化答案为-1，及时处理无解情况

---

# 拓展与练习

**同类题目推荐**：
1. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638) - 最小窗口覆盖所有颜色
2. [P1712 区间](https://www.luogu.com.cn/problem/P1712) - 双指针处理区间覆盖问题
3. [P3143 钻石收集者](https://www.luogu.com.cn/problem/P3143) - 滑动窗口求极差限制下的最大和

**调试心得**：
- 注意元素频次归零时要及时更新总类数（如vanueber题解中的`tot-=(cnt[a[j]]==0)`）
- 使用`sum[r] - sum[l-1]`计算区间和时注意下标偏移
- 初始答案应设为极大值（如`1e18`）避免初始状态干扰比较

---
处理用时：78.46秒
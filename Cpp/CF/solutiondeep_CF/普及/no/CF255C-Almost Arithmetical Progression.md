# 题目信息

# Almost Arithmetical Progression

## 题目描述

先给出一个整数 $n$ ,再给出一个有 $n$ 个元素的序列 $b$。

现在要你求序列 $b$ 中最长的子序列，满足隔位的两个数相等，问这个最长的子序列的长度是多少。

## 样例 #1

### 输入

```
2
3 5
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
10 20 10 30
```

### 输出

```
3
```

# AI分析结果



# Almost Arithmetical Progression

## 题目描述

给出一个整数 $n$ 和一个包含 $n$ 个元素的序列 $b$。要求找出序列 $b$ 中最长的子序列，满足隔位的两个数相等，输出该子序列的最大长度。

## 样例 #1

### 输入
```
2
3 5
```

### 输出
```
2
```

## 样例 #2

### 输入
```
4
10 20 10 30
```

### 输出
```
3
```

**算法分类**：动态规划

---

### 题解综合分析

#### 核心思路
所有题解均采用动态规划，核心状态设计为 `dp[i][j]` 表示在位置 `i` 时，前一个位置的数值为 `j`（离散化后的值）时的最长子序列长度。通过交换相邻元素的数值进行状态转移，利用离散化处理大值域。

#### 关键技巧
1. **状态转移设计**：`dp[i][a_j] = dp[j][a_i] + 1`，通过交替数值形成隔位相等
2. **离散化优化**：将大范围数值映射到小范围下标
3. **初始化处理**：默认每个元素自身构成长度为1的子序列

---

### 优质题解推荐

#### 题解1 - 作者：tuzhewen（⭐⭐⭐⭐⭐）
**核心亮点**：
- 离散化处理简洁高效
- 边界条件处理完善
- 代码结构清晰易读

**核心代码**：
```cpp
F(i,1,n) {
    F(j,i+1,n) {
        dp[j][a[i]] = dp[i][a[j]] + 1;
        ans = max(ans, dp[j][a[i]]);
    }
}
printf("%d\n", ans + 1);
```

#### 题解2 - 作者：wxzzzz（⭐⭐⭐⭐）
**核心亮点**：
- 使用map进行离散化
- 状态转移方程直观
- 注释说明清晰

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j < i; j++) {
        f[i][b[j]] = f[j][b[i]] + 1;
        ans = max(ans, f[i][b[j]]);
    }
}
cout << ans + 1;
```

#### 题解3 - 作者：_Weslie_（⭐⭐⭐⭐）
**核心亮点**：
- 状态定义更易理解
- 代码注释详细
- 明确解释转移逻辑

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j < i; j++) {
        dp[i][a[j]] = max(dp[i][a[j]], dp[j][a[i]] + 1);
    }
}
printf("%d", ans + 1);
```

---

### 扩展与总结
**关键优化**：利用离散化压缩状态空间，通过交换数值设计状态转移实现交替模式捕捉。  
**同类题目**：
1. [CF1350B - Orac and Models](https://www.luogu.com.cn/problem/CF1350B)（最长递增子序列变种）
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（双向动态规划）
3. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)（离散化+LIS优化）

**个人心得**：
- 离散化前需排序并去重，注意lower_bound的偏移量处理
- 状态转移中交换数值的操作是解题的关键突破口
- 最终答案需要+1以包含初始元素自身长度

---
处理用时：80.48秒
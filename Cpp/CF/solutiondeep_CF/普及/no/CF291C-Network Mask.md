# 题目信息

# Network Mask

## 题目描述

## 题目背景

该问题使用了一个简化的TCP/IP地址模型，请确保您仔细阅读了该声明。


Polycarpus找到了一份工作，他是一名系统管理员。

有一天他偶然发现了n个IP地址。

每个IP地址是一个32位的数字，用4个8位数字(不带前导零)组成一组，用点分隔。

例如，记录0.255.1.123显示正确的IP地址，记录0.256.1.123和0.255.1.01不正确。

在这个问题中，由4个8位数字组成的任意组就是一个正确的IP地址。

Polycarpus作为一名管理员工作了一段时间，了解到如果您知道IP地址，您可以使用子网掩码来获得拥有该IP地址的网络地址。

子网掩码是一个IP地址，它有以下属性:如果我们把这个IP地址写为一个32位的字符串，它可以表示为“11…11000..000”。

换句话说，子网掩码首先有一个或多个1位，然后是一个或多个0位(总共有32位)。

例如，IP地址2.0.0.0不是一个正确的子网掩码，因为它的32位记录看起来是0000001000000000000000000000。

要得到IP地址的网络地址，需要执行IP地址和子网掩码的按位“与”操作。

例如，如果子网掩码是255.192.0.0,IP地址是192.168.1.2，则网络地址等于192.128.0.0。

在按位的“与”中，当且仅当两个操作数对应的位都等于1时，结果的位等于1。

现在Polycarpus想要找到他的IP地址所属的所有网络。

不幸的是Polycarpus丢失了子网掩码。

幸运的是，Polycarpus记得他的IP地址完全属于 $k$ 种不同的网络。

帮助Polycarpus找到子网掩码，这样他的IP地址将完全属于 $k$ 种不同的网络。

如果有多个子网掩码，则查找位记录中1个数最少的一个。

如果不存在这样的子网掩码，输出-1。

## 样例 #1

### 输入

```
5 3
0.0.0.1
0.1.1.2
0.0.2.1
0.1.1.0
0.0.2.3
```

### 输出

```
255.255.254.0```

## 样例 #2

### 输入

```
5 2
0.0.0.1
0.1.1.2
0.0.2.1
0.1.1.0
0.0.2.3
```

### 输出

```
255.255.0.0```

## 样例 #3

### 输入

```
2 1
255.0.0.1
0.0.0.2
```

### 输出

```
-1
```

# AI分析结果



### 中文题目重写
**网络掩码**

#### 题目背景
该问题使用了一个简化的TCP/IP地址模型，请确保您仔细阅读了该声明。

#### 题目描述
Polycarpus找到了n个IP地址。每个IP地址是一个32位的数字，由4个8位数字（不带前导零）组成，用点分隔。例如，`0.255.1.123`是有效的，而`0.256.1.123`和`0.255.1.01`无效。

子网掩码是一个特殊的IP地址，其二进制形式为连续的1后接连续的0（例如，`255.192.0.0`对应二进制`11111111 11000000 00000000 00000000`）。网络地址通过IP地址与子网掩码按位与运算得到。

给定n个IP地址和整数k，找到满足以下条件的子网掩码：
1. 这些IP地址生成的网络地址恰好属于k个不同的网络。
2. 若有多个子网掩码满足条件，选择二进制中1的个数最少的一个。
3. 若不存在符合条件的子网掩码，输出-1。

---

### 算法分类
**枚举**、**位运算**

---

### 题解分析与结论
题目要求通过枚举所有合法的子网掩码（连续的1后接0），统计每个掩码生成的网络地址数量，找到满足条件且1的个数最少的掩码。关键点在于正确生成掩码、高效统计网络地址数量，以及遍历顺序的优化。

#### 关键思路与技巧
1. **掩码生成**：从全1的掩码（`UINT_MAX`）开始，逐步将低位改为0，生成连续的1结构。
2. **网络地址统计**：使用哈希表（如`map`）快速去重。
3. **遍历顺序**：按掩码中1的个数从多到少枚举，确保最终选择1的个数最少的解。
4. **输出处理**：将32位整数按8位分割，转换为点分十进制格式。

---

### 精选题解
#### 题解1：North_encounter（★★★★★）
**亮点**：清晰的掩码生成逻辑、完善的输出处理、详细注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100001;
int n,k;
unsigned dis=UINT_MAX; // 初始全1掩码
int m[N]; // 存储IP地址的32位形式
map<int,int> vis; // 统计网络地址

int main() {
    cin>>n>>k;
    // 输入处理：将IP转为32位整数
    for(int i=1;i<=n;i++){
        int a,b,c,d;
        scanf("%d.%d.%d.%d",&a,&b,&c,&d);
        m[i]=(a<<24)+(b<<16)+(c<<8)+d;
    }
    // 枚举所有可能的掩码（1的个数从31到1）
    for(int i=1;i<=31;i++){
        dis-=(1<<(i-1)); // 生成新掩码
        int cnt=0;
        vis.clear();
        for(int j=1;j<=n;j++){
            unsigned net=m[j]&dis;
            if(!vis[net]) cnt++,vis[net]=1;
        }
        if(cnt==k) ans=dis;
    }
    // 输出处理
    if(ans==-1) cout<<-1;
    else printf("%d.%d.%d.%d", (ans>>24)%256, (ans>>16)%256, (ans>>8)%256, ans%256);
}
```

#### 题解2：liuzhongrui（★★★★☆）
**亮点**：代码简洁，高效利用位运算。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
unsigned a[100010], now=UINT_MAX;

int main() {
    cin>>n>>k;
    // 输入处理
    for(int i=1;i<=n;i++){
        unsigned A,b,c,d;
        scanf("%u.%u.%u.%u",&A,&b,&c,&d);
        a[i]=(A<<24)+(b<<16)+(c<<8)+d;
    }
    // 枚举掩码并统计
    for(int i=1;i<=31;i++){
        now-=(1<<(i-1));
        map<unsigned,bool> mp;
        int cnt=0;
        for(int j=1;j<=n;j++) 
            if(!mp[a[j]&now]) mp[a[j]&now]=1, cnt++;
        if(cnt==k) ans=now;
    }
    // 输出（自动截断高位）
    if(ans==-1) cout<<-1;
    else printf("%u.%u.%u.%u", ans>>24, (ans>>16)&255, (ans>>8)&255, ans&255);
}
```

---

### 关键代码实现
**掩码生成与统计**：
```cpp
unsigned dis = UINT_MAX;
for (int i=1; i<=31; i++) {
    dis -= (1 << (i-1)); // 生成连续1后接0的掩码
    map<unsigned, bool> vis;
    int cnt = 0;
    for (int j=0; j<n; j++) {
        unsigned net = ip[j] & dis;
        if (!vis[net]) cnt++, vis[net] = true;
    }
    if (cnt == k) ans = dis;
}
```

---

### 拓展与总结
**同类问题套路**：
- **二进制模式枚举**：如连续前缀匹配、位掩码生成。
- **高效去重**：哈希表统计不同元素数量。
- **网络地址处理**：IP与掩码的位运算操作。

**推荐练习题目**：
1. [P2557 AHOI2002 子网划分](https://www.luogu.com.cn/problem/P2557)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)（哈希统计）
3. [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)（位运算与进制处理）

**心得总结**：
- **全面测试**：确保覆盖所有边界条件（如全0/全1掩码）。
- **位运算优化**：直接操作二进制提升效率。
- **输出细节**：确保32位到点分十进制的正确转换。

---
处理用时：371.07秒
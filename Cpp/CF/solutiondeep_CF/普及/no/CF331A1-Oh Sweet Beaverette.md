# 题目信息

# Oh Sweet Beaverette

## 题目描述

有 $n$ 棵树，每一棵树都有一个美丽值。你可以砍倒任意一些树（当然也可以不砍），使砍完后剩下的这些树满足以下要求：

1. 美丽值总和尽可能的大。
2. 第一棵树和最后一棵树的美丽值必须相等。
3. 最少剩余 $2$ 棵树。

保证至少有两棵树的美丽值相等。

## 样例 #1

### 输入

```
5
1 2 3 1 2
```

### 输出

```
8 1
1 ```

## 样例 #2

### 输入

```
5
1 -2 3 1 -2
```

### 输出

```
5 2
2 5 ```

# AI分析结果



### 题目重写

**题目名称：Oh Sweet Beaverette**

**题目描述**

有 $n$ 棵树，每棵树都有一个美丽值。你可以砍倒任意一些树（也可以不砍），要求剩余的树满足以下条件：

1. 美丽值总和尽可能大。
2. 剩余的第一棵树和最后一棵树的美丽值必须相等。
3. 至少保留两棵树。

保证至少存在两棵树的美丽值相等。

**样例 #1**

输入：
```
5
1 2 3 1 2
```
输出：
```
8 1
1 ```

**样例 #2**

输入：
```
5
1 -2 3 1 -2
```
输出：
```
5 2
2 5 ```

---

### 算法分类
**贪心**

---

### 题解对比与总结

#### 核心思路
所有题解的核心思路均为：  
1. **预处理正数前缀和**，快速计算区间内正数的和。  
2. **记录每个数值的最左和最右出现位置**，枚举这些位置作为首尾端点。  
3. **贪心选择区间**，保留端点并取中间所有正数，总和最大的方案即为最优解。  

#### 解决难点
- **首尾端点可能为负数**：必须保留首尾端点，但中间只保留正数以最大化总和。  
- **高效枚举端点**：通过哈希表（如 `map`）记录每个值的首次和最后一次出现位置，避免暴力枚举所有可能的端点组合。  

#### 最优关键技巧
- **前缀和优化**：快速计算区间内正数的和，时间复杂度 $O(n)$。  
- **哈希表记录位置**：用 `map` 或数组记录每个值的左右端点，减少枚举次数。  

---

### 精选题解

#### 题解1：AC_love（4星）
**亮点**：  
- 详细处理了首尾为负数的情况，分情况讨论总和计算。  
- 代码结构清晰，通过前缀和与哈希表高效实现贪心策略。  
**核心代码**：
```cpp
map<int, int> lef, rig;
int pre[N]; // 正数前缀和
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    pre[i] = pre[i-1] + max(a[i], 0ll); // 预处理
    if (lef[a[i]] == 0) lef[a[i]] = i;  // 记录首次出现
    rig[a[i]] = i;                      // 记录最后一次出现
}
for (int i = 1; i <= n; i++) {
    int l = lef[a[i]], r = rig[a[i]];
    if (l == r) continue;
    // 计算总和：中间正数和 + 首尾值（可能为负）
    if (a[i] >= 0) sum = pre[r] - pre[l-1];
    else sum = pre[r] - pre[l-1] + 2 * a[i];
    // 维护最大值
}
```

#### 题解2：Feyn（4星）
**亮点**：  
- 简洁高效，仅记录每个值的首次出现位置，遍历时动态更新右端点。  
- 利用一次遍历完成所有计算，代码紧凑。  
**核心代码**：
```cpp
map<int, int> pl; // 记录每个值的首次出现位置
for (int i = 1; i <= n; i++) {
    sum[i] = sum[i-1] + max(a[i], 0); // 正数前缀和
    if (pl.count(a[i]) == 0) pl[a[i]] = i;
    else {
        int l = pl[a[i]], r = i;
        // 计算总和：中间正数和 + 首尾值
        now = a[i] * 2 + (sum[r-1] - sum[l]);
        // 维护最大值
    }
}
```

---

### 扩展与同类题目
- **类似题型**：区间最值问题（如最大子数组和）的变种，需结合特定约束条件。  
- **举一反三**：若要求首尾端点满足其他关系（如差值固定），可采用类似前缀和+哈希表的方法。  

**推荐题目**：  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（前缀和优化）  
3. [P2426 删数](https://www.luogu.com.cn/problem/P2426)（贪心+区间处理）

---
处理用时：146.87秒
# 题目信息

# Oh Sweet Beaverette

## 题目描述

有一个森林共有 $n$ 棵树，它们各自都有美丽值，要砍掉一些树，也可以不砍。  
要求：  
1. 剩余树的美丽值之和必须最大化；
2. 结果中第一棵和最后一棵树的美丽值必须相同；
3. 森林中必须至少剩下两棵树。

问：需要砍下哪些树才能让剩余树的美丽值之和最大化？

## 样例 #1

### 输入

```
5
1 2 3 1 2
```

### 输出

```
8 1
1 ```

## 样例 #2

### 输入

```
5
1 -2 3 1 -2
```

### 输出

```
5 2
2 5 ```

# AI分析结果



### 题目中文重写
（题目已经是中文，保持原样）

### 算法分类
贪心

### 综合分析与结论
**核心逻辑**：寻找首尾相同且中间正数尽可能多的区间，使用前缀和快速计算区间和，通过哈希结构优化端点查找。  
**关键难点**：正确处理负数端点的情况，避免因盲目砍负数导致错过更优解。  
**最优策略**：预处理每个值的首次和末次出现位置，结合前缀和快速计算区间收益，比较所有可能的端点组合。

---

### 精选题解

#### 1. AC_love（4星）
**关键亮点**：  
- 使用双map分别记录每个值的首次/末次出现位置  
- 分正负处理端点贡献，维护全局最大值  
- 队列处理砍伐列表生成逻辑清晰

**核心代码解析**：
```cpp
map<int, int> lef, rig;  // 记录每个值的首尾位置
for(int i = 1; i <= n; i++) {
    if(lef[a[i]] == 0) lef[a[i]] = i;  // 首次出现
    rig[a[i]] = i;  // 末次出现
}
for(遍历所有i) {
    int l = lef[a[i]], r = rig[a[i]];  // 获取当前值的首尾
    if(a[i] >=0) sum = pre[r] - pre[l-1];  // 正数端点直接累加
    else sum = pre[r] - pre[l-1] + 2*a[i]; // 负数端点需补偿被砍的两次
}
```

#### 2. qusia_MC（4星）
**关键亮点**：  
- 单map存储pair<int,int>同时记录首尾位置  
- 输入时直接计算非负前缀和  
- 砍伐列表生成公式化处理减少循环

**独特技巧**：  
```cpp
// 砍伐数公式化计算
int cnt = ans_ID-1 + (n-ans_ID2) + (中间负数数量);
// 直接通过范围判断生成砍伐列表
for(int i=1;i<=n;++i) {
    if(不在区间内 || 是中间负数) 加入砍伐列表
}
```

---

### 关键思路总结
1. **端点预处理**：对每个值记录其最左和最右出现位置，避免重复枚举  
2. **前缀和优化**：pre[r]-pre[l-1]快速获取区间正数和  
3. **负数补偿机制**：当端点自身为负数时，需额外加回被前缀和过滤掉的端点值  
4. **砍伐列表生成**：左端点前所有树 + 右端点后所有树 + 中间负数树

---

### 拓展建议
**类似问题套路**：  
- 带约束条件的区间最值问题（如首尾相同、奇偶性限制）  
- 需要权衡保留负元素的场景（如乘积最大子数组）  
- 哈希结构加速端点查找的前缀和应用

**推荐练习**：  
1. P1115 最大子段和（前缀和经典）  
2. P2678 跳石头（二分答案+贪心验证）  
3. P3406 海底高铁（差分+前缀和决策）

---
处理用时：45.26秒
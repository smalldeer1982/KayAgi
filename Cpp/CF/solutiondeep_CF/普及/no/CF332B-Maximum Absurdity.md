# 题目信息

# Maximum Absurdity

## 题目描述

Berland 的改革还在继续。例如，在昨天的议会会议上，Berland 议会通过了 $ n $ 项法律（每个法律都有一个从 1 到 $ n $ 的独立编号）。今天，这些法律已经放在 Berland 总统 G.W. Boosch 的桌上，等待签署。

这一次，Boosch 先生计划签署 $ 2k $ 项法律。他决定选择两个不重叠的、长度为 $ k $ 的整数段，并签署这两个段内的所有法律。具体来说，Boosch 先生会选择两个整数 $ a $ 和 $ b $ （满足 $ 1 \le a \le b \le n - k + 1 $ 且 $ b - a \ge k $），并签署在段 $ [a; a + k - 1] $ 和 $ [b; b + k - 1] $ 内的法律（包括边界）。

在做出决定时，Boosch 先生当然会考虑公众的意见。为了了解公众的看法，Allberland 公众意见研究中心 (APOSC) 进行了民意调查，并将结果汇总成一份报告交给总统。报告指出了每个法律在公众眼中的"荒谬值"。作为一位追求国家利益的领导者，Boosch 先生希望能签署总"荒谬值"最大的法律。请帮助他完成这一任务。

## 说明/提示

在第一个示例中，Boosch 先生签署了编号在 $ [1; 2] $ 和 $ [4; 5] $ 的法律。签署的法律总"荒谬值"是 $ 3 + 6 + 1 + 6 = 16 $。

在第二个示例中，Boosch 先生签署了编号在 $ [1; 2] $ 和 $ [3; 4] $ 的法律。签署的法律总"荒谬值"是 $ 1 + 1 + 1 + 1 = 4 $。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 2
3 6 1 1 6
```

### 输出

```
1 4
```

## 样例 #2

### 输入

```
6 2
1 1 1 1 1 1
```

### 输出

```
1 3
```

# AI分析结果



# 题目重写  
**最大荒谬值**  

## 题目描述  
Berland 的改革仍在继续。例如，在昨天的议会会议上，Berland 议会通过了编号为 1 到 n 的 n 项法律。现在这些法律已呈交总统 G.W. Boosch 签署。  

Boosch 计划签署 2k 项法律，要求选择两个不重叠且长度均为 k 的连续区间。具体来说，选择两个整数 a 和 b（满足 1 ≤ a ≤ b ≤ n - k + 1 且 b ≥ a + k），使得区间 [a, a + k - 1] 和 [b, b + k - 1] 内的法律被签署。  

每个法律有一个“荒谬值”，Boosch 希望最大化这两个区间的总荒谬值。给出具体方案，若有多个解，输出 a 最小的；若仍有多个解，输出 b 最小的。  

**样例输入 1**  
5 2  
3 6 1 1 6  
**样例输出 1**  
1 4  

---

**算法分类**  
前缀和 + 贪心  

---

# 题解分析与结论  
### 核心思路对比  
1. **预处理区间和**：所有题解均使用前缀和快速计算区间和。  
2. **预处理极值**：  
   - _czh___ 预处理每个位置右侧的最大区间和及其位置，实现 O(n) 查询。  
   - _wunaidedanjuan_ 倒序维护右侧最大值，动态更新最优解。  
   - _Tooler_Fu_ 线性扫描维护左侧最大值，结合右侧区间枚举。  
3. **不重叠处理**：通过控制区间间隔（b ≥ a + k）保证不重叠。  

### 最优思路提炼  
1. **前缀和预处理**：计算所有长度为 k 的区间和。  
2. **右侧极值预存**：从右向左遍历，记录每个位置右侧的最大区间和及其左端点。  
3. **单次遍历求最优**：正序遍历每个可能的左侧区间，直接查询预存的右侧极值。  

---

# 精选题解  
## 1. czh___ 的题解（⭐⭐⭐⭐⭐）  
**关键亮点**  
- 预处理右侧极值数组，查询时间复杂度 O(1)  
- 代码简洁，逻辑清晰  
**核心代码**  
```cpp  
for(int i=n;i>=k;i--) {
    if(sum[i]>=mx[i+1]) 
        x[i]=i, mx[i]=sum[i];
    else 
        mx[i]=mx[i+1], x[i]=x[i+1];
}
for(int i=k;i<=n;i++) {
    int sm=sum[i]+mx[i+k];
    if(ans<sm) {
        ans1=i-k+1;
        ans=sm;
        ans2=x[i+k]-k+1;
    }
}
```  
**实现思路**  
- `sum[i]` 表示以 i 结尾的长度为 k 的区间和。  
- `mx[i]` 记录从 i 到末尾的最大区间和，`x[i]` 记录对应区间的右端点。  
- 遍历每个可能的左区间，直接取右侧最大区间和。  

---

## 2. wunaidedanjuan 的题解（⭐⭐⭐⭐）  
**关键亮点**  
- 倒序维护右侧最大值，确保不重叠  
- 变量命名清晰，逻辑直观  
**核心代码**  
```cpp  
for(int i=n-2*k+1;i>=1;i--) {
    if(ans[i+k]>=sum1) {
        bb=i+k;
        sum1=ans[bb];
    }
    if(ans[i]+sum1>=sum) {
        a=i;
        b=bb;
        sum=ans[a]+sum1;
    }
}
```  
**实现思路**  
- 倒序遍历左区间的左端点，动态维护右侧区间的最大值。  
- 通过倒序处理确保左区间的右侧始终有足够空间。  

---

## 3. lhs_chris 的题解（⭐⭐⭐⭐）  
**关键亮点**  
- 结构体维护极值，便于记录位置  
- 正序预处理极值数组  
**核心代码**  
```cpp  
for(int i=n;i>=1;i--) {
    if(i+k-1>n) continue;
    ll l=sum[i+k-1]-sum[i-1];
    if(maxx[i+1].num>l) 
        maxx[i] = maxx[i+1];
    else 
        maxx[i] = {l, i};
}
```  
**实现思路**  
- 预处理极值数组时，同时记录最大值及其左端点。  
- 遍历时直接组合左区间与预存的右侧极值。  

---

# 拓展与总结  
### 关键技巧  
- **双指针极值预存**：在需要多次查询区间极值时，预处理极值数组可大幅优化时间。  
- **倒序处理极值**：当右侧极值与当前位置相关时，倒序遍历可避免重复计算。  

### 相似题目推荐  
1. [P1007 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)  
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分+贪心）  

### 心得摘录  
> _Tooler_Fu_ 在代码中提及：  
> “注意最后输出的是两个合法的左端点，而不是答案。”  
> —— 强调题目输出要求易错点，需仔细审题。

---
处理用时：85.38秒
# 题目信息

# Subway Innovation

## 题目描述

直线上 $n$ 个点，定义点 $i, j$之间的距离为 $|x_i-x_j|$。保留 $k$ 个点，使这些点**两两之间的距离和**最小。输出 $k$ 个点的下标。

## 样例 #1

### 输入

```
3
1 100 101
2
```

### 输出

```
2 3 ```

# AI分析结果



# Subway Innovation

## 题目描述

直线上 $n$ 个点，定义点 $i, j$ 之间的距离为 $|x_i-x_j|$。保留 $k$ 个点，使这些点**两两之间的距离和**最小。输出 $k$ 个点的下标。

## 算法分类
贪心、前缀和

---

## 题解对比与结论
所有题解均基于排序后选取连续区间的最优性，核心差异在于区间和的计算方式：

1. **滑动窗口+增量计算**：通过相邻区间的差值公式推导，利用前缀和快速转移
2. **双前缀和优化**：拆分总和公式为两个独立的前缀和项，实现O(1)复杂度计算
3. **动态维护差值**：尝试通过维护差值序列寻找最优解，但存在初始条件处理风险

---

## 精选题解

### 题解1 - 作者：b6e0_（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 推导清晰的增量转移公式：$new = old + (k-1)(a_{left}+a_{right}) - 2*\sum mid$  
- 代码简洁高效，完美处理边界条件  
- 时间复杂度优化至$O(n\log n)$

**关键代码**：
```cpp
sort(a+1,a+n+1);
for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i].first;

// 初始窗口计算
for(int i=1;i<=k;i++)
    ans+=a[i].first*(i-1)-(s[i-1]-s[0]);

// 滑动窗口转移
for(int i=2;i<=n-k+1;i++){
    ans += (k-1)*(a[i+k-1].first+a[i-1].first) 
         - (s[i+k-2]-s[i-1])*2;
    if(ans<minv) update_min();
}
```

---

### 题解2 - 作者：sgl654321（⭐⭐⭐⭐）
**核心亮点**：  
- 数学拆分总和的创新视角：将被减数与减数分离  
- 双前缀和数组设计，逻辑更直观  
- 处理大数范围的正确初始化

**公式推导**：  
总距离 = $2\sum i a_i + (1-k-2L)\sum a_i$

**关键代码**：
```cpp
for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
for(int i=1;i<=n;i++) s2[i]=s2[i-1]+a[i]*i;

for(int i=1;i<=n-k+1;i++){
    ll tmp = 2*(s2[i+k-1]-s2[i-1]) 
           + (1-k-2*i)*(s[i+k-1]-s[i-1]);
    if(tmp<ans) update_ans();
}
```

---

## 最优技巧总结
1. **排序贪心**：最优解必然为排序后的连续区间
2. **前缀和优化**：用前缀和数组快速计算区间和
3. **滑动窗口转移**：通过数学推导相邻窗口关系，实现O(1)复杂度转移

---

## 同类题目推荐
1. [CF466C - Number of Ways](https://codeforces.com/problemset/problem/466/C)（前缀和+计数）
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（滑动窗口应用）
3. [AT_abc229E - Graph Destruction](https://atcoder.jp/contests/abc229/tasks/abc229_e)（逆向思维+并查集）

---
处理用时：119.82秒
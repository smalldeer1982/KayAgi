# 题目信息

# Domino Effect

## 题目描述

小克里斯认为**简单地推倒**多米诺骨牌没有意思，他认为这太随意了，不需要技巧。因此，他决定玩~~一种他歪歪出来的~~多米诺骨牌游戏并进行“多米诺骨牌表演”。

克里斯把 $n$ 张多米诺骨牌排在一条线上，垂直竖立。一开始，他**同时**将一些多米诺骨牌推向左侧或右侧，并且保证，在每两个多米诺骨牌推向相同方向之间的某个地方，至少有一个多米诺骨牌被推向相反的方向。

每一秒，每个倒在左边的多米诺骨牌将会推动左边相邻的多米诺骨牌。同样地，向右倾斜的多米诺骨牌将会推动右边相邻的多米诺骨牌。当一个垂直的多米诺骨牌有从两边落下的多米诺骨牌时，由于力量的平衡而保持不变。以下这张图（包括3个例子）显示了该过程的一个可能示例。

![](https://cdn.luogu.org/upload/vjudge_pic/CF405B/37fecb2c12dba94b96d336756a84bf7894c6655a.png)

给出克里斯推动多米诺骨牌的最初方向，请编程找到在过程结束时垂直留下的多米诺骨牌的数量。

## 样例 #1

### 输入

```
14
.L.R...LR..L..
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5
R....
```

### 输出

```
0
```

## 样例 #3

### 输入

```
1
.
```

### 输出

```
1
```

# AI分析结果



# Domino Effect

## 题目描述

小克里斯认为**简单地推倒**多米诺骨牌没有意思，他认为这太随意了，不需要技巧。因此，他决定玩~~一种他歪歪出来的~~多米诺骨牌游戏并进行"多米诺骨牌表演"。

克里斯把 $n$ 张多米诺骨牌排在一条线上，垂直竖立。一开始，他**同时**将一些多米诺骨牌推向左侧或右侧，并且保证，在每两个多米诺骨牌推向相同方向之间的某个地方，至少有一个多米诺骨牌被推向相反的方向。

每一秒，每个倒在左边的多米诺骨牌将会推动左边相邻的多米诺骨牌。同样地，向右倾斜的多米诺骨牌将会推动右边相邻的多米诺骨牌。当一个垂直的多米诺骨牌有从两边落下的多米诺骨牌时，由于力量的平衡而保持不变。以下这张图（包括3个例子）显示了该过程的一个可能示例。

给出克里斯推动多米诺骨牌的最初方向，请编程找到在过程结束时垂直留下的多米诺骨牌的数量。

## 样例 #1

### 输入
```
14
.L.R...LR..L..
```

### 输出
```
4
```

---

**算法分类**：模拟

---

## 题解分析与结论

### 关键思路与技巧
1. **单次遍历维护状态**：记录当前作用力方向（左/右）及连续未推动骨牌数量
2. **区间分段处理**：将骨牌序列划分为多个由L/R分割的区间，处理每个区间内的特殊规则：
   - 首区间的左边界无阻挡时全倒
   - 中间区间奇偶性决定中点是否保留
   - 末区间的右边界无阻挡时全倒
3. **奇偶判断优化**：当左右作用力相遇时，通过奇偶性直接计算中间保留的骨牌

---

## 精选题解

### 1. DarkShadow（★★★★☆）
**核心亮点**：
- 简洁的状态维护（dir记录方向，cnt记录连续未推动数）
- 通过三种情况分支处理所有可能
- 边界处理完整（末尾未处理区间的累加）

```cpp
int main(){
    // 初始化及输入处理略
    dir = -1; // -1表示初始无方向
    for(int i=1;i<=n;i++){
        if(d[i]==0) cnt++;
        else if(d[i]==-1 && dir==1) ans += cnt%2; // 左右相遇奇偶处理
        else if(d[i]==1 && dir==-1) ans += cnt;   // 首区间的未推动
        if(d[i]!=0) cnt=0, dir=d[i];
    }
    if(dir==-1) ans += cnt; // 处理末尾未推动
    printf("%d",ans);
}
```

### 2. Tachibana27（★★★★☆）
**核心亮点**：
- 区间视角清晰
- 使用布尔标记简化方向判断
- 通过位运算优化奇偶判断

```cpp
for(int i=1;i<=n;i++){
    if(rt){ // 当前处于向右作用区间
        if(s[i]=='.') up++;
        else { // 遇到L
            ans += (up&1);
            up=0; rt=false;
        }
    } else {
        if(s[i]=='.') up++;
        else if(s[i]=='R'){
            ans += up; // 首区间的未推动
            rt=true;
        }
        up=0;
    }
}
if(!rt) ans += up; // 末尾未处理
```

---

## 同类题目推荐
1. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095) - 状态模拟与决策优化
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 区间组合与条件判断
3. [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563) - 方向状态维护与环形处理

---
处理用时：73.10秒
# 题目信息

# Crash

## 题目描述

在“俄罗斯代码杯”编程比赛的期间，代码测试系统储存了每一位参赛者发送的所有程序，有很多参赛者会在他们自己的代码程序中使用随机数，并发送几个具有相同的的程序。

每个参赛者由一个唯一的正整数 $k$ 来标识，每个发送的程序 $A$ 都由两个数字表示：$x$，在与 $A$ 相同的第一个程序之前发送的不同的程序的数量；$k$，参赛者的编号，即程序的作者。因此，所有相同的程序具有相同的 $x$。      

众所周知，测试系统中的数据是按照时间顺序来存储的，就是说，如果测试系统有一个数字为 $x$（$x \ge 0$）的程序，而参赛者的编号为 $k$，那么测试系统有一个编号为 $x - 1$ 的程序存储在以前的某个地方。      
比赛期间，测试系统崩溃了，但随后所有的参赛者提交的数据都已经恢复了。现在的陪审团想核实恢复的数据是否按照时间顺序储存， 请你帮助陪审团这样做。

## 样例 #1

### 输入

```
2
0 1
1 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4
0 1
1 2
1 1
0 2
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
4
0 1
1 1
0 1
0 2
```

### 输出

```
YES
```

# AI分析结果



### 题目内容重写
#### 题目描述
在“俄罗斯代码杯”编程比赛期间，代码测试系统记录了每位参赛者提交的所有程序。许多参赛者会在自己的程序中使用随机数，因此会多次提交具有相同内容的程序。

每位参赛者由唯一的正整数 $k$ 标识。每个提交的程序 $A$ 由两个数字描述：$x$（表示在 $A$ 之前且与 $A$ 内容不同的程序数量）和 $k$（参赛者编号）。所有相同内容的程序具有相同的 $x$。

已知测试系统的数据按时间顺序存储，即若存在 $x \ge 0$ 的程序（作者为 $k$），则系统中必然存在 $x-1$ 的该作者程序。请验证恢复后的数据是否符合时间顺序。

#### 输入样例
```
2
0 1
1 1
```

#### 输出样例
```
YES
```

---

### 算法分类
**模拟**

---

### 题解综合分析
所有题解均采用模拟思路，通过维护数组记录每个作者的合法提交次数。核心逻辑为：
1. 若当前输入的 $x$ 等于该作者的已记录提交次数，则新增一次合法提交。
2. 若输入的 $x$ 大于已记录次数，说明顺序错误，立即判定非法。
3. 若输入的 $x$ 小于已记录次数，说明是重复提交，无需处理。

---

### 精选题解（评分≥4星）

#### 1. 作者：ZSYZSYZSYZSY（5星）
**关键亮点**  
- 思路清晰，直接通过条件判断实现核心逻辑。
- 代码简洁高效，发现非法输入时立即终止程序。
- 时间复杂度为 $O(n)$，空间复杂度为 $O(C)$（$C$ 为作者编号最大值）。

**核心代码**  
```cpp
ll a[1000005]; // 记录每个作者的合法提交次数
for (int i=1; i<=n; i++) {
    ll x, k;
    cin >> x >> k;
    if (x == a[k]) a[k]++;
    else if (x > a[k]) {
        cout << "NO" << endl;
        return 0;
    }
}
```

#### 2. 作者：sto__Liyhzh__orz（4星）
**关键亮点**  
- 代码高度简洁，直接嵌入条件判断。
- 使用 `return` 快速终止程序，优化执行效率。
- 逻辑与主流解法完全一致，可读性强。

**核心代码**  
```cpp
int a[MAXN]; // 记录每个作者的提交状态
for (int i=1; i<=n; i++) {
    cin >> x >> k;
    if (x == a[k]) a[k]++;
    else if (x > a[k]) return cout << "NO" << endl, 0;
}
```

#### 3. 作者：naroto2022（4星）
**关键亮点**  
- 分情况讨论清晰，适合新手理解。
- 注释详细，便于代码审查。
- 采用逐步处理方式，无冗余操作。

**核心代码**  
```cpp
int a[1000005]; // 记录每个作者的合法提交次数
for (int i=1; i<=n; i++) {
    int x, k;
    scanf("%d %d", &x, &k);
    if (x == a[k]) a[k]++;
    else if (x > a[k]) {
        printf("NO");
        return 0;
    }
}
```

---

### 关键思路总结
- **数组维护状态**：使用数组记录每个作者的当前合法提交次数，确保每次输入的 $x$ 符合递增要求。
- **即时终止判断**：发现非法输入时立即终止程序，避免无效计算。
- **边界处理**：正确处理 $x=0$ 的初始情况，无需特殊处理。

---

### 拓展与同类题推荐
1. **同类题目**  
   - [P1179 数字统计](https://www.luogu.com.cn/problem/P1179)（简单计数模拟）
   - [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)（状态去重与排序）
   - [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（哈希表维护出现次数）

2. **优化技巧**  
   - 若作者编号范围较大，可改用 `unordered_map` 动态存储。
   - 输入规模较大时，使用快速输入函数（如 `scanf` 或自定义快读）提升效率。

---
处理用时：70.66秒
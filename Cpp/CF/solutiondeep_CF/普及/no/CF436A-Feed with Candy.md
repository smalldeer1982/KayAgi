# 题目信息

# Feed with Candy

## 题目描述

### 题意翻译

已知屋子里挂有 $n$ 个糖果，分为两种，水果糖和焦糖糖。对于第 $i$ 个糖果，它的质量为 $m_i$，高度为 $h_i$。Om nom 可以跳跃。他最初时最高可以跳 $x$ 高，此后每吃一个质量为 $m$ 的糖果，最高跳跃高度都会增加 $m$。总之，他不能吃到高过他最高跳跃高度的糖果。另外，由于Om nom是一个很挑剔的食客，他不会吃同一高度上的两颗同类型的糖果。例如，如果焦糖糖果 $1$ 高度在 $5$，焦糖糖果 $2$ 高度也在 $5$，那么Om nom不会同时吃掉他们。请你求出Om nom最多能吃到多少个糖果。

## 样例 #1

### 输入

```
5 3
0 2 4
1 3 1
0 8 3
0 20 10
1 5 5
```

### 输出

```
4
```

# AI分析结果



# Feed with Candy

## 题目描述

### 题意翻译

已知屋子里挂有 $n$ 个糖果，分为两种，水果糖和焦糖糖。对于第 $i$ 个糖果，它的质量为 $m_i$，高度为 $h_i$。Om nom 可以跳跃。他最初时最高可以跳 $x$ 高，此后每吃一个质量为 $m$ 的糖果，最高跳跃高度都会增加 $m$。总之，他不能吃到高过他最高跳跃高度的糖果。另外，由于Om nom是一个很挑剔的食客，他不会吃同一高度上的两颗同类型的糖果。例如，如果焦糖糖果 $1$ 高度在 $5$，焦糖糖果 $2$ 高度也在 $5$，那么Om nom不会同时吃掉他们。请你求出Om nom最多能吃到多少个糖果。

## 样例 #1

### 输入

```
5 3
0 2 4
1 3 1
0 8 3
0 20 10
1 5 5
```

### 输出

```
4
```

---

**算法分类**：贪心

---

### 题解分析与结论

所有题解均采用两次贪心策略，分别假设第一次吃类型0或类型1的糖果。核心思路是通过质量降序排序，在满足高度限制和类型交替的条件下，尽可能选择质量大的糖果以提升跳跃能力。实现难点在于交替类型判断和高效选择最优糖果。

---

### 精选题解

#### 1. 作者：zlqwq（★★★★☆）
**亮点**：  
- 按质量降序预排序提升选择效率  
- 两次独立遍历处理两种初始类型  
- 使用标记数组避免重复选择  

**核心代码**：
```cpp
sort(a+1,a+1+n,cmp); // 按质量降序排序
for(int i=1;i<=n;++i){
    for(int j=1;j<=n;++j){ // 线性扫描找第一个可用糖果
        if(flag[j]||a[j].t==now||a[j].h>now1)continue;
        flag[j]=1;
        now=a[j].t; // 类型交替
        now1+=a[j].m;
        cnt1++;
        break;
    }
}
```

#### 2. 作者：ACtheQ（★★★★☆）
**亮点**：  
- 清晰的变量命名（ans1/ans2区分两种场景）  
- 独立的标记数组重置逻辑  
- 严格的条件判断顺序优化性能  

**核心代码**：
```cpp
last=0; // 初始类型0
memset(vis,false,sizeof vis);
for(int j=1;j<=n;j++){
    if(vis[j]||a[j].t==last||a[j].h>x1)continue;
    vis[j]=true;
    x1+=a[j].m;
    last=a[j].t; // 交替类型
    ans1++;
    break;
}
```

#### 3. 作者：_Clown_（★★★★☆）
**个人心得**：  
"原来的翻译有误，不知道现在改了没有" —— 强调审题时需注意版本差异  

**实现技巧**：  
- 结构体排序重载运算符实现复合排序规则  
- 动态更新当前高度和类型状态  
- 双循环独立处理两种初始类型  

**核心代码**：
```cpp
while(true){
    int Mx=0, W=0;
    for(int i=1;i<=Total;i++){
        if(High>=Candy[i].Height && !Candy[i].Eaten 
           && Last!=Candy[i].Opt && Candy[i].Delta>Mx){
            Mx=Candy[i].Delta; // 贪心选质量最大
            W=i;
        }
    }
    if(!W) break;
    // 更新状态并标记已吃
}
```

---

### 关键思路总结

1. **双场景贪心**：分别处理首次选类型0/1的情况，取最大值  
2. **质量优先排序**：预排序确保每次选择都能快速定位最优解  
3. **状态交替更新**：维护当前跳跃高度和上次吃的糖果类型  
4. **线性扫描优化**：通过排序降维选择复杂度，避免全排列遍历  

---

### 拓展建议

同类贪心问题推荐：  
1. P1090 [合并果子]（贪心+优先队列）  
2. P1223 [排队接水]（时间序列贪心）  
3. P5019 [铺设道路]（区间覆盖贪心）  

调试技巧：  
- 验证排序规则是否满足跳跃高度动态增长特性  
- 使用独立标记数组避免两次贪心间的状态污染

---
处理用时：101.72秒
# 题目信息

# Balancer

## 题目描述

---
佩蒂娅有 $k$ 根火柴，她要把这些火柴放在 $n$ 个火柴盒里。佩蒂娅希望所有盒子里的火柴数量相同，也就是每个火柴盒里面要放 $\frac kn$ 根火柴。她可以一步把 $1$ 根火柴从这个盒子里移到相邻的盒子里。问他需要多少次操作才能使得每个盒子都有 $\frac kn$ 根火柴。

## 样例 #1

### 输入

```
6
1 6 2 5 3 7
```

### 输出

```
12
```

# AI分析结果



题目已为中文，无需翻译。

**算法分类**：贪心

---

### 综合分析与结论
题目要求通过相邻移动使所有盒子火柴数相等。核心思路是逐个处理每个盒子，将当前盒子的差额传递给下一个盒子，并累加绝对差作为操作次数。所有题解均采用此贪心策略，时间复杂度 O(n)，空间 O(1)。正确性基于每一步保证前面的盒子已满足条件，后续调整不影响前面结果。

---

### 精选题解

#### 1. 作者：L_zaa_L（5星）
**关键亮点**  
- 代码简洁高效，直接使用绝对值累加操作次数。
- 明确处理负数差额，逻辑统一无需条件判断。
- 强调使用 `long long` 避免溢出，细节处理到位。

**核心代码**  
```cpp
for(long long i=1;i<=n;i++){
    a[i+1] += (a[i]-k); // 传递差额到下一个盒子
    ans += abs(a[i]-k); // 累加绝对差作为操作次数
}
```
**代码思想**  
遍历每个盒子，将当前盒子的多余或不足部分传递给下一个盒子，并累加移动次数。无论多还是少，操作次数均为绝对差之和。

---

#### 2. 作者：N_z_（4星）
**关键亮点**  
- 数学归纳式思路解释清晰，强调唯一解的存在性。
- 代码简洁，使用 `#define int long long` 确保类型安全。

**代码片段**  
```cpp
for(int x=1;x<=n;x++)
    ans += abs(sum-a[x]), a[x+1] += a[x]-sum;
```
**个人心得**  
“题目保证了所有数和是 n 的整倍数，即只有一个解”——强调题目隐含条件的重要性，避免冗余判断。

---

#### 3. 作者：CQ_Bab（4星）
**关键亮点**  
- 分情况讨论差额传递，增强代码可读性。
- 使用 `signed main()` 和 `const` 常量提升代码规范性。

**代码片段**  
```cpp
if(a[i]<k) {
    a[i+1] -= (k - a[i]);
    res += abs(a[i]-k);
} else if(a[i]>k) {
    a[i+1] += (a[i] - k);
    res += abs(a[i]-k);
}
```
**实现对比**  
虽用条件判断，但效果与直接累加绝对值等价，适合教学展示不同思维路径。

---

### 最优思路总结
**关键技巧**：**差额传递法**  
1. **局部处理**：每个盒子只需处理与后一盒子的差额，保证前面的状态不再改变。
2. **绝对差累加**：无论多还是少，操作次数均为当前差额的绝对值，简化计算。
3. **类型安全**：使用 `long long` 避免数据溢出，确保大数场景正确性。

---

### 拓展与相似题目
1. **均分纸牌**（洛谷 P1031）  
   同类问题，需计算最少移动次数，解法完全一致。
2. **IncDec Sequence**（洛谷 P4552）  
   通过差分数组处理区间增减，考察差额传递的变形应用。
3. **积木大赛**（洛谷 P1969）  
   逆向思维，通过相邻操作模拟增减过程。

---
处理用时：51.04秒
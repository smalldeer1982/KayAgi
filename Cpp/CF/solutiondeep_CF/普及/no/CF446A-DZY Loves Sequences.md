# 题目信息

# DZY Loves Sequences

## 题目描述

给定一个长度为 $n$ 的序列 $a_1\sim a_n$，定义 $a_i,a_{i+1},a_{i+2},\cdots,a_j\left(1\le i\le j\le n\right)$ 的长度为 $j-i+1$，你可以最多更改一个数字，求最长的严格递增子段长度。

## 样例 #1

### 输入

```
6
7 2 3 1 5 6
```

### 输出

```
5
```

# AI分析结果



### 题目重写
（题目已为中文，无需重复翻译）

### 算法分类
动态规划

### 题解分析与结论
**核心思路**：预处理每个位置的前后最长递增子段，枚举修改点，分情况讨论能否连接前后段。  
**解决难点**：边界处理（首尾元素）、判断修改后能否连接的关键条件（a[i+1]-a[i-1]≥2）  
**最优技巧**：前缀/后缀数组预处理 + 分类讨论修改点的连接可能性

---

### 高分题解推荐
#### 1. Binary_Lee（5星）
**关键亮点**：  
- 清晰的双向预处理思路  
- 简洁的条件判断逻辑  
- 完整处理边界情况  

**核心代码**：
```cpp
for(int i=1;i<=n;i++) f1[i]=(a[i]>a[i-1])?f1[i-1]+1:1;
for(int i=n;i>=1;i--) f2[i]=(a[i]<a[i+1])?f2[i+1]+1:1;
for(int i=1;i<=n;i++){
    if(a[i+1]-a[i-1]>=2) ans=max(ans,f1[i-1]+f2[i+1]+1);
    else ans=max(ans,max(f1[i-1],f2[i+1])+1);
}
```

#### 2. Priori_Incantatem（4星）
**关键亮点**：  
- 明确三种转移情况分析  
- 特殊处理边界值的思路  
- 代码可读性良好  

**个人心得**：  
> "这里的边界写的跟上面描述的不一样，其实没区别" —— 强调边界处理的灵活性

#### 3. ttq012（4星）
**关键亮点**：  
- 数学形式化推导修改条件  
- 极简代码实现  
- 完整处理首尾元素情况  

---

### 关键思路代码实现
**预处理前后缀数组**：  
```cpp
// 前缀数组：以i结尾的最长递增子段
for(int i=1;i<=n;i++) 
    f1[i] = (a[i]>a[i-1]) ? f1[i-1]+1 : 1;

// 后缀数组：以i开头的最长递增子段
for(int i=n;i>=1;i--)
    f2[i] = (a[i]<a[i+1]) ? f2[i+1]+1 : 1;
```

**枚举决策点**：  
```cpp
int ans = 1;
for(int i=1;i<=n;i++){
    int cur = max(f1[i-1], f2[i+1]) + 1;
    if(i>1 && i<n && a[i+1]-a[i-1]>=2)
        cur = max(cur, f1[i-1]+f2[i+1]+1);
    ans = max(ans, cur);
}
```

---

### 拓展应用
1. 修改次数扩展：若允许修改k次，需设计三维DP状态  
2. 数值约束变化：如只能修改为特定范围值，需调整连接条件  
3. 环形数组变种：首尾相连情况需特殊处理  

---

### 推荐习题
1. [P9147 签到题](https://www.luogu.com.cn/problem/P9147)（本题双倍经验）  
2. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（前缀和思想）  
3. [CF1353D 最长相邻递增子序列](https://codeforces.com/problemset/problem/1353/D)（类似预处理技巧）

---
处理用时：54.19秒
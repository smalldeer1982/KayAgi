# 题目信息

# Little Pony and Sort by Shift

## 题目描述

一天，暮光闪闪对如何给一个整数数组按照不递减顺序排序产生了兴趣。作为一只年轻的独角兽，她能做的只有一个操作：单位移动。她可以把最后一个元素移动到第一个去：$a_1,a_2,\cdots ,a_n\to a_n,a_1,a_2,\cdots ,a_{n-1}$
帮助暮光闪闪确定：最少需要花多少次操作才能把数组排好序？

## 样例 #1

### 输入

```
2
2 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
1 3 2
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
2
1 2
```

### 输出

```
0
```

# AI分析结果



### 中文重述题目

**题目名称：小马按位移排序**

**题目描述**

暮光闪闪想通过将最后一个元素移动到首位的方式，将一个整数数组变为非递减顺序。请求出所需的最少操作次数，若无法完成则输出-1。

**样例 #1**

输入：
```
2
2 1
```
输出：
```
1
```

**样例 #2**

输入：
```
3
1 3 2
```
输出：
```
-1
```

**样例 #3**

输入：
```
2
1 2
```
输出：
```
0
```

---

### 算法分类
**模拟**

---

### 题解分析与结论

**核心思路**  
将数组视为环形结构，统计相邻逆序对的数量。若逆序对数量超过1，则无法排序，否则通过逆序对的位置计算所需移动次数。

**关键技巧**  
- 环形遍历：通过检查首尾元素关系，处理环形结构的逆序对。
- 逆序对统计：仅允许存在一个逆序对，且需满足首尾元素非逆序。

---

### 精选题解

#### 题解作者：Dancing_Wave（★★★★★）
**关键亮点**  
- 明确环形结构处理，通过逆序对数量快速判断可行性。
- 代码清晰，边界处理完整（如首尾逆序检查）。

**核心代码**  
```cpp
int cnt = 0, fir = 0;
for (int i = 2; i <= n; i++) {
    if (a[i] < a[i-1]) {
        if (cnt++) { cout << -1; return 0; }
        fir = i;
    }
}
if (a[1] < a[n] && cnt++) { // 首尾逆序检查
    cout << -1; return 0;
}
cout << (cnt ? n - fir + 1 : 0);
```

#### 题解作者：_Lightning_（★★★★☆）
**关键亮点**  
- 双重循环直接验证后续数组是否有序，逻辑直观。
- 首尾条件判断简洁高效。

**核心代码**  
```cpp
for (int i = 2; i <= n; i++) {
    if (a[i-1] > a[i]) {
        for (int j = i+1; j <= n; j++) // 检查后续是否有序
            if (a[j-1] > a[j]) { cout << -1; return 0; }
        if (a[n] > a[1]) { cout << -1; return 0; } // 首尾约束
        cout << n - i + 1; return 0;
    }
}
cout << 0;
```

---

### 关键思路总结
1. **环形逆序对判定**：将数组首尾相连，统计逆序对数量。
2. **首尾元素约束**：最后一个元素必须小于等于第一个元素。
3. **移动次数计算**：唯一逆序对的右侧位置决定了需要移动的步数。

---

### 拓展练习
1. [CF977D - Divide by three, multiply by two](https://www.luogu.com.cn/problem/CF977D)（类似环形排序思想）
2. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)（差分与模拟结合）
3. [P1155 双栈排序](https://www.luogu.com.cn/problem/P1155)（操作限制下的排序策略）

---
处理用时：110.11秒
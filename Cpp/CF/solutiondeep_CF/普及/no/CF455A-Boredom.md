# 题目信息

# Boredom

## 题目描述

亚力克斯不喜欢无聊。

所以每当他感到无聊他就会想出一些游戏。一个冬天的晚上他想出了一个游戏并且决定开始玩这个游戏。

给定一个有 $n$ 个元素的序列 $\{a_n\}$。你可以做若干次操作。在一次操作中我们可以取出一个数（假设他为 $x$）并删除它，同时删除所有的序列中值为 $x+1$ 和 $x-1$ 的数。这一步操作会给玩家加上 $x$ 分。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
4
```

## 样例 #3

### 输入

```
9
1 2 1 3 2 2 2 2 3
```

### 输出

```
10
```

# AI分析结果



# Boredom

## 题目描述

亚历克斯不喜欢无聊。

因此每当他感到无聊时就会想出一些游戏。某个冬夜他想出了一个游戏并决定开始玩。

给定一个包含 $n$ 个元素的序列 $\{a_n\}$。你可以进行若干次操作。每次操作中可以选择一个数（假设为 $x$）并删除它，同时删除序列中所有值为 $x+1$ 和 $x-1$ 的数。每次操作将给玩家增加 $x$ 分。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
4
```

## 样例 #3

### 输入

```
9
1 2 1 3 2 2 2 2 3
```

### 输出

```
10
```

**算法分类**：动态规划

---

### 题解综合分析

各题解均采用动态规划思路，核心差异在于状态表示：
1. **一维DP**：`dp[i]` 表示处理到数值i时的最大得分，转移方程 `dp[i] = max(dp[i-1], dp[i-2] + cnt[i]*i)`
2. **二维DP**：`dp[i][0/1]` 表示数值i不取/取时的最大得分，通过状态机转移

所有解法均需先统计数字出现频次（桶计数），并确定最大数值作为遍历终点。

---

### 精选题解（评分≥4星）

#### 1. 人间凡人（⭐⭐⭐⭐⭐）
**亮点**：代码简洁高效，解释清晰
```cpp
long long dp[M],num[M];
int main(){
    // 统计频次
    for(int i=2;i<=N;i++)
        dp[i]=max(dp[i-2]+num[i]*i, dp[i-1]);
}
```
**核心思想**：线性DP，通过桶计数预处理，状态转移时决策取/不取当前数值

#### 2. Allanljx（⭐⭐⭐⭐）
**亮点**：状态机思想更易理解
```cpp
int dp[100005][5];
for(int i=1;i<=d;i++){
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
    dp[i][1]=dp[i-1][0]+a[i]*i;
}
```
**个人心得**：二维状态转移更直观体现决策过程

#### 3. Cult_style（⭐⭐⭐⭐）
**亮点**：转移方程解释透彻
```cpp
dp[i] = max(dp[i-1], dp[i-2] + vis[i]*i);
```
**踩坑提示**：必须使用long long防止溢出

---

### 关键技巧总结

1. **桶计数预处理**：统计每个数字出现次数，将问题转化为数值域上的DP
2. **相邻数值约束处理**：通过`i-2`确保不取相邻数
3. **空间优化**：一维DP数组即可存储状态，无需二维
4. **边界处理**：`dp[1]`初始化为数字1的总分

---

### 拓展建议

类似问题可考虑：
1. 数值范围较大时离散化处理
2. 树形结构下的相邻节点约束问题
3. 带权值的区间选择问题

---

### 推荐习题
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典01背包
2. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233) - 二维偏序+DP 
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双向LIS模型

---
处理用时：46.22秒
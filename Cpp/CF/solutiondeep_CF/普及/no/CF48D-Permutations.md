# 题目信息

# Permutations

## 题目描述

“排列”是指一个长度为n的序列，且其中1到n的每个数刚好出现一次。例如，(1) (4,3,5,1,2) (3,2,1)都是排列，而(1,1) (4,3,1) (2,3,4)则不是。

假设某人拿了几个排列（长度不一定相同），把它们连在一起写成了一个数列，并将这个数列打乱顺序。你的任务是将这个数列重新组成原来的几个排列（如果可能的话）。

## 说明/提示

在第1个样例中数组被分成了三个排列：(2,1) (3,2,1,4,5) (1,2)。第1个排列由原数列的第2和4个数组成，第2个排列由第3、5、6、7、9个元素组成，第3个排列由第1和8个元素组成。显然，还有另外几种分组的方式。

## 样例 #1

### 输入

```
9
1 2 3 1 2 1 4 2 5
```

### 输出

```
3
3 1 2 1 2 2 2 3 2
```

## 样例 #2

### 输入

```
4
4 3 2 1
```

### 输出

```
1
1 1 1 1 ```

## 样例 #3

### 输入

```
4
1 2 2 3
```

### 输出

```
-1
```

# AI分析结果



# Permutations

## 题目描述  
"排列"是指一个长度为n的序列，且其中1到n的每个数刚好出现一次。例如，(1)、(4,3,5,1,2)、(3,2,1)都是排列，而(1,1)、(4,3,1)、(2,3,4)则不是。

假设某人拿了几个排列（长度不一定相同），把它们连在一起写成了一个数列，并将这个数列打乱顺序。你的任务是将这个数列重新组成原来的几个排列（如果可能的话）。

## 算法分类  
构造

---

### 题解综合分析
所有题解的核心思路均基于以下观察：
1. **排列数等于1的个数**：每个排列必须包含1，故总排列数等于1的出现次数
2. **出现次数递减原则**：对任意x≥2，x的出现次数必须≤x-1的出现次数
3. **动态分组策略**：通过维护每个数字的当前出现次数，将其分配至对应组

---

### 精选题解

#### 1. Tzs_yousa 题解（⭐⭐⭐⭐⭐）
**亮点**：
- 正难则反的逆向思维，通过判断不成立条件简化问题
- 桶排序保持原序，O(n)时间复杂度
- 代码简洁清晰，仅使用三个数组完成所有逻辑

**核心代码**：
```cpp
int num[maxn], zu[maxn]; // num记录出现次数，zu记录当前组号
for(int i=1; i<=n; i++){
    zu[a[i]]++; // 动态更新组号
    cout << zu[a[i]] << " ";
}
```

#### 2. b6e0_ 题解（⭐⭐⭐⭐）
**亮点**：
- 通过快读快写优化IO效率
- 详细数学证明出现次数递减的必要性
- 在线统计出现次数，节省内存空间

**关键思路**：
```cpp
for(int i=1; i<=n; i++){
    ans[i] = ++b[a[i]]; // 实时计算组号
}
```

#### 3. infinities 题解（⭐⭐⭐⭐）
**亮点**：
- 加入两个额外特判优化边界情况
- 使用d数组简化输出逻辑
- 代码极简（仅20行），适合竞赛场景

**优化点**：
```cpp
if(a[i]>n) { cout<<-1; return 0; } // 数字越界特判
```

---

### 关键思路总结
1. **桶计数验证**：统计各数字出现次数，验证是否满足严格非递增
2. **动态分组**：每个数字x的第k次出现必然属于第k个排列
3. **线性复杂度**：所有操作均可在O(n)时间内完成，无需复杂数据结构

---

### 拓展思考
类似构造问题可参考：
1. CF1433E（排列组合计数）
2. 洛谷P1157（组合输出）
3. 洛谷P1706（全排列生成）

---

### 调试心得摘录
- "较大的数字受较小的数字的限制，如同金字塔结构"（Tzs_yousa）
- "构造题的样例往往是陷阱，需关注数学本质而非表面结构"（b6e0_）
- "特判数字范围是避免WA的关键，即使题目未明确说明"（infinities）
- "相同数的出现次数天然决定其最大分组数"（Fa1thful）

---
处理用时：58.97秒
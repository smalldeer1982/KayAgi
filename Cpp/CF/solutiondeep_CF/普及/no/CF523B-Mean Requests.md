# 题目信息

# Mean Requests

## 题目描述

本题源于 VK 社交网络使用的实际算法问题。

与其他高负载网站一样，VK 的开发人员定期处理请求统计。一个重要的负载指标是某个时间段内（例如 $T=60$ 秒即 1 分钟，或 $T=86400$ 秒即 1 天）的平均请求数。当这个值严重下降时，可能表示网站访问存在问题；而当这个值上升时，可能需要分析增长原因，并在必要时增加服务器。

但是，在处理大型社交网络的海量数据时，计算一个时间段内的平均请求数也面临挑战。因此，开发人员采用了一些创新技术，既能接近真实值，又能提升效率。

我们考虑以下模型。假设服务运行了 $n$ 秒。我们已知在每个时间点 $t$（$1 \le t \le n$）对该资源的请求数 $a_t$。定义一个利用指数衰减的平均数计算算法，设 $c$ 为大于 1 的实数。

```cpp
// 正确设置常数 c 可以调整所统计的时间范围
double c = <某个常数>;

// 该变量将保存当前时刻前 T 秒内的平均请求数
double mean = 0.0;

for t = 1..n: // 每秒进行如下操作：
    // $a_t$ 是这一秒的请求数
    mean = (mean + $a_t$ / T) / c;
```

如此，每秒都会根据当前秒的请求数更新 `mean` 变量。通过适当选择常数 $c$，可使 `mean` 的值接近于 $t-T+1 \le x \le t$ 之间的真实平均值 $a_x$。

这种方法的优点在于只需当前时刻的请求数，无需保存长时间的历史请求。同时，它给较新的数据更高权重，有助于快速应对数据剧变。

在工业编程中采用新理论方法前，必须在给定测试集上验证其实际可信度。你的任务是将近似算法结果与真实数据进行比较。

你会收到 $n$ 个值 $a_t$，整数 $T$ 和实数 $c$。此外，还给定 $m$ 个时刻 $p_j$（$1 \le j \le m$），我们关注的是过去 $T$ 秒的平均请求数。实现两个算法：一个按定义计算所需值，即通过公式
$$
\text{real} = \frac{1}{T} \sum_{x=t-T+1}^{t} a_x
$$
另一个按上述方法计算均值。输出这两个值，并通过公式
$$
\text{error} = \left| \frac{\text{approx} - \text{real}}{\text{real}} \right|
$$
计算第二个算法的相对误差，其中 $\text{approx}$ 是第二个算法的近似值，$\text{real}$ 是第一个算法的真实值。

## 样例 #1

### 输入

```
1 1 2.000000
1
1
1
```

### 输出

```
1.000000 0.500000 0.500000
```

## 样例 #2

### 输入

```
11 4 1.250000
9 11 7 5 15 6 6 6 6 6 6
8
4 5 6 7 8 9 10 11
```

### 输出

```
8.000000 4.449600 0.443800
9.500000 6.559680 0.309507
8.250000 6.447744 0.218455
8.000000 6.358195 0.205226
8.250000 6.286556 0.237993
6.000000 6.229245 0.038207
6.000000 6.183396 0.030566
6.000000 6.146717 0.024453
```

## 样例 #3

### 输入

```
13 4 1.250000
3 3 3 3 3 20 3 3 3 3 3 3 3
10
4 5 6 7 8 9 10 11 12 13
```

### 输出

```
3.000000 1.771200 0.409600
3.000000 2.016960 0.327680
7.250000 5.613568 0.225715
7.250000 5.090854 0.297813
7.250000 4.672684 0.355492
7.250000 4.338147 0.401635
3.000000 4.070517 0.356839
3.000000 3.856414 0.285471
3.000000 3.685131 0.228377
3.000000 3.548105 0.182702
```

# AI分析结果



# Mean Requests 的平均请求数

## 题目描述翻译
（保持原格式，仅翻译内容）

本题源于 VK 社交网络的实际算法问题。需要计算两种不同算法下的平均请求数：真实滑动窗口平均值与指数衰减近似算法值，并比较它们的相对误差。

给定 n 秒的请求数序列、时间窗口 T、衰减系数 c，以及 m 个关注时刻，要求输出每个时刻的真实平均值、近似值和相对误差。

## 算法分类
模拟

---

## 题解分析与结论
核心是同时维护滑动窗口求和（真实值）与递推式迭代（近似值）。题解的关键点在于：
1. **滑动窗口优化**：通过前缀和加减维护窗口总和，避免重复计算
2. **递推计算**：严格按指数衰减公式迭代近似值
3. **误差处理**：正确处理除零边界条件，使用高精度浮点类型

---

## 精选题解

### 题解作者：andyli (⭐⭐⭐⭐⭐)
**关键亮点**：
- 双变量同步维护：用 `sum` 存储滑动窗口总和，`approx` 按公式递推
- 时间复杂度 O(n)：线性遍历即可完成计算
- 空间优化：仅需存储当前窗口相关数据，无需历史记录

**核心代码解析**：
```cpp
// 滑动窗口维护
sum += a[i];
if (i >= T) sum -= a[i - T]; 

// 近似值计算
approx = (approx + a[i]/T) / c; 

// 误差计算
error = fabs(approx - real) / real;
```
代码使用 `i64` 类型存储滑动窗口总和避免溢出，采用延迟减法的技巧（当 `i >= T` 时才减去过期元素）确保窗口长度固定。

---

## 关键思路总结
1. **滑动窗口维护技巧**：通过加减操作代替重新求和，将时间复杂度从 O(nT) 降为 O(n)
2. **递推式状态保存**：近似算法只需保存前一个状态，适合流式数据处理
3. **浮点精度处理**：使用 `long double` 保证计算精度，避免误差累积

---

## 拓展应用
类似滑动窗口与递推结合的场景：
1. 实时数据流分析（如股票移动平均线）
2. 系统负载监控（如 TCP 拥塞控制中的 RTT 估算）
3. 传感器数据滤波处理

---

## 推荐练习题
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 滑动窗口极值基础
2. [P1083 NOIP 借教室](https://www.luogu.com.cn/problem/P1083) - 差分数组与二分结合
3. [P2216 理想的正方形](https://www.luogu.com.cn/problem/P2216) - 二维滑动窗口优化

---
处理用时：62.20秒
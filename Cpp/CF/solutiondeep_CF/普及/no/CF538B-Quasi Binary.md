# 题目信息

# Quasi Binary

## 题目描述

给出一个数 $n$，你需要将 $n$ 写成若干个数的和，其中每个数的十进制表示中仅包含 $0$ 和 $1$。

问最少需要多少个数。

## 样例 #1

### 输入

```
9
```

### 输出

```
9
1 1 1 1 1 1 1 1 1 
```

## 样例 #2

### 输入

```
32
```

### 输出

```
3
10 11 11 
```

# AI分析结果



# Quasi Binary

## 题目描述

给出一个数 $n$，你需要将 $n$ 写成若干个数的和，其中每个数的十进制表示中仅包含 $0$ 和 $1$。

问最少需要多少个数。

## 样例 #1

### 输入

```
9
```

### 输出

```
9
1 1 1 1 1 1 1 1 1 
```

## 样例 #2

### 输入

```
32
```

### 输出

```
3
10 11 11 
```

**算法分类**：构造/贪心

---

### 题解综合分析

所有题解均基于**数位分解**的核心思路：最少个数等于原数各位数字的最大值。通过构造每个quasi-binary数的对应数位，最终累计生成所有符合条件的数。

#### 最优题解推荐

1. **OItby（★★★★★）**
   - **关键亮点**：最简洁的位运算实现，时间复杂度 O(log n)
   - **核心代码**：
     ```cpp
     for(int bit=1; bit<=n; bit*=10) {
         int Res = (n/bit)%10;
         Ans = max(Ans, Res);
         for(int i=1; i<=Res; ++i) 
             num[i] += bit;
     }
     ```
   - **实现思想**：从个位开始逐位处理，将每个数位的值分解到不同的结果数组中

2. **Aw顿顿（★★★★☆）**
   - **关键亮点**：代码量最少（仅15行），逆向处理数位
   - **代码特点**：使用倒序存储数位，通过双重循环构造结果数组

3. **alvis（★★★★☆）**
   - **独特价值**：附带详细的填坑思想图示，适合初学者理解
   - **调试经验**：特别强调前导零处理逻辑（`k=0`标志位的使用）

---

### 关键思路总结

1. **数位极值定理**：最小个数等于原数各位数字的最大值
2. **位权累加构造法**：
   - 遍历每个十进制位（1, 10, 100...）
   - 将当前位的数值拆分到前k个结果数中
   - 例如十位数字3，将10的权值累加到前3个结果数

---

### 拓展应用

同类问题可参考：
1. [CF55B - Smallest number](https://codeforces.com/problemset/problem/55/B)（数位重组极值）
2. [P1118 数字三角形](https://www.luogu.com.cn/problem/P1118)（数位构造与排列）
3. [P1151 子数整数](https://www.luogu.com.cn/problem/P1151)（特定数位组合判定）

---

### 题解代码精要

OItby的核心代码实现：
```cpp
int main() {
    int n, Res;
    scanf("%d", &n);
    for(int bit=1; bit<=n; bit*=10) {
        Res = (n/bit)%10;        // 提取当前数位
        Ans = max(Ans, Res);      // 更新最大值
        for(int i=1; i<=Res; ++i) 
            num[i] += bit;        // 累加位权到结果数组
    }
    printf("%d\n", Ans);
    for(; Ans; --Ans) 
        printf("%d ", num[Ans]);  // 逆序输出避免前导零
}
```
该实现通过位权分解，完美避免了字符串操作，空间复杂度仅 O(10)。

---
处理用时：57.31秒
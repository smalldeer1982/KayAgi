# 题目信息

# Day at the Beach

## 题目描述

一天Squidward，Spongebob，Patrick决定一起去沙滩玩。不幸的是，天气实在不好，他们没法冲浪了。然鹅，他们决定建一个沙堡。

那天快结束的时候，他们建了n个城堡。城堡被编号为1到n，第i个城堡的高度是hi。就在大家都要走的时候，Squidward注意到，沙堡没有按它们的高度排序，这看起来很不和谐,。现在，他们将重新排列城堡，使对于所有的i，（0<=i<=n-1）都有hi<=hi+1。

Squidward建议用下列方式给城堡排序：

- 城堡被分成几个连续的段，因此从i到j的城堡段应该包括i,i+1...j-1,j。一个城堡段可以只有一个城堡组成。

- 使所有城堡都在一个段内。

- 每个段独立于其他段进行排序，即序列hi,hi+1...hj-1,hj是有序的。

- 段的划分应满足在每个段被排序之后，序列也变得有序。这总是可以被满足因为可以把整个序列看做一段。

Patrick知道在分区中增加块的数量将简化排序过程。现在，他们要求你计算满足所有上述要求的分区中的最大可能块数。

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
2 1 3 2
```

### 输出

```
2
```

# AI分析结果



# Day at the Beach

## 题目描述

一天Squidward、Spongebob、Patrick决定一起去沙滩玩。由于天气不好无法冲浪，他们决定建造沙堡。结束时共建造了n个城堡，第i个城堡高度为h_i。他们希望通过将城堡分成若干连续段，每段内部排序后整个序列有序。求最大可能的分块数。

## 算法分类
贪心

## 题解分析与结论

题目核心在于找到分块条件：每个分块排序后整体有序。关键思路有两种：
1. **前缀极值法**：预处理前缀最大值和后缀最小值，当某位置的前缀最大值 ≤ 其后缀最小值时，可在此分块。
2. **排序差累积法**：比较原数组与排序数组的差值累积和，当累积和为0时视为可分块点。

两种方法均正确，但极值法时间复杂度更低（O(n)），无需排序，思路更直观。

## 精选题解

### 作者：_Kimi_ （4星）
**核心思路**：预处理每个位置的前缀最大值（MAX）和后缀最小值（MIN），遍历时若MAX[i] ≤ MIN[i+1]，则分块数+1。  
**亮点**：时间复杂度O(n)，思路直观，无需排序。  
**关键代码**：
```cpp
int MAX[maxn], MIN[maxn];
// 预处理前缀最大值
MAX[1] = A[1];
for(int i=2; i<=n; i++) MAX[i] = max(MAX[i-1], A[i]);
// 预处理后缀最小值
MIN[n] = A[n];
for(int i=n-1; i>=1; i--) MIN[i] = min(MIN[i+1], A[i]);
// 统计分块数
int ans = 1;
for(int i=1; i<=n-1; i++) 
    if(MAX[i] <= MIN[i+1]) 
        ans++;
```

## 拓展与总结
**关键技巧**：利用前后缀数组快速获取区间极值，适用于需要分段判断极值约束的问题。  
**同类题目推荐**：
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
2. [P2880 Balanced Lineup](https://www.luogu.com.cn/problem/P2880)  
3. [P3143 Diamond Collector](https://www.luogu.com.cn/problem/P3143)  

**个人心得**：预处理极值法避免排序，直接利用原数组特性，边界处理需谨慎（如MIN数组从右向左更新）。

---
处理用时：205.60秒
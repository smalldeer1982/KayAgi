# 题目信息

# Bear and String Distance

## 题目描述

------------

Limak是一只小北极熊。他喜欢单词——只由小写字母构成，长度为n的单词。



他规定dist(s,s')的值为s与s'在26个字母中的间距。如，dist(c,e)=dist(e,c)=2,dist(a,z)=dist(z,a)=25。



而且，当dist两个单词时，其值为dist第一个字母+dist第二个字母+……

如，dist(af,db)=dist(a,d)+dist(f,b)=3+4=7,dist(bear,roar)=16+10+0+0=26。                   



现在，Limak给你一个字母或单词s和值k，令你寻找一个s'使dist(s,s')=k。输出s'。如果没有合适的s'，输出-1。



注意：最好用标准输入输出流，如C++的cin和cout，Java的Scanner/System.out 。

## 样例 #1

### 输入

```
4 26
bear
```

### 输出

```
roar```

## 样例 #2

### 输入

```
2 7
af
```

### 输出

```
db
```

## 样例 #3

### 输入

```
3 1000
hey
```

### 输出

```
-1
```

# AI分析结果



【算法分类】  
贪心、构造

【题目重述】  
# 小熊与字符串距离

## 题目描述  
Limak是一只小北极熊，喜欢由小写字母组成的长度为n的单词。  
定义两个字符串s和s'的dist值为各对应字符的字母间距之和。例如，dist("af","db")=3+4=7。  
给定字符串s和整数k，构造一个字符串s'使得dist(s,s')=k。若无法构造则输出-1。

---

### 题解分析与结论  
各题解均采用贪心策略，核心思路为：  
1. **最大化每个字符的贡献**：对每个字符，选择使其距离最大的方向（a或z），优先消耗k的剩余值。  
2. **提前判断可行性**：通过计算所有字符可贡献的最大距离总和，若总和小于k则直接返回-1。  
3. **剩余k的处理**：若k在某个字符处无法取最大贡献，则用尽剩余k并调整该字符。

### 高分题解推荐  
1. **maokaiyu的题解（⭐⭐⭐⭐⭐）**  
   **亮点**：  
   - 直接计算每个字符到a/z的距离，选择最大贡献方向。  
   - 代码简洁高效，时间复杂度O(n)。  
   **代码核心**：  
   ```cpp
   for (I i = 1; i <= n; i++) {
       I dis1 = abs(s[i] - 'a'), dis2 = abs(s[i] - 'z');
       if (k >= max(dis1, dis2)) {
           k -= max(dis1, dis2);
           t[i] = (dis1 > dis2) ? 'a' : 'z';
       } else {
           t[i] = (dis1 > dis2) ? s[i] - k : s[i] + k;
           k = 0;
       }
   }
   ```

2. **Light_az的题解（⭐⭐⭐⭐⭐）**  
   **亮点**：  
   - 提前计算总上限，避免无效处理。  
   - 处理剩余k时直接调整字符位置。  
   **代码核心**：  
   ```cpp
   ll cnt = 0;
   F(i, 1, n) cnt += max(abs(s[i] - 'a'), abs(s[i] - 'z'));
   if (cnt < k) { /* 输出-1 */ }
   F(i, 1, n) {
       ll mx = max(abs(s[i] - 'a'), abs(s[i] - 'z'));
       if (k >= mx) { /* 取最大方向 */ }
       else { /* 调整字符消耗剩余k */ }
   }
   ```

3. **EthanOI的题解（⭐⭐⭐⭐）**  
   **亮点**：  
   - 无需提前遍历计算总上限，直接处理每个字符。  
   - 代码精简，逻辑清晰。  
   **代码核心**：  
   ```cpp
   for (int i = 0; i < n; i++) {
       if (到a的距离 >= 到z的距离) {
           if (k >= 到a距离) 移动到a;
           else 移动k步;
       } else { /* 类似处理到z */ }
   }
   ```

### 关键技巧总结  
- **贪心构造**：每个字符尽可能贡献最大距离，快速消耗k。  
- **提前剪枝**：计算总上限避免无效操作。  
- **边界处理**：剩余k不足时，直接调整当前字符位置。

### 同类题目推荐  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心选择最小代价合并。  
2. [CF1328C Ternary XOR](https://codeforces.com/problemset/problem/1328/C) - 构造特殊形式的三进制数。  
3. [P5653 基础操作练习题](https://www.luogu.com.cn/problem/P5653) - 贪心构造最优操作序列。  

### 个人心得摘录  
- **调试教训**：需注意字符移动方向（到a还是到z）的正确性，避免计算距离时符号错误。  
- **优化顿悟**：提前计算总上限可显著减少无效循环，尤其在大数据时效果明显。

---
处理用时：250.66秒
# 题目信息

# Cracking the Code

## 题目描述

### 题意简述
给出一个五位数

我们设这个这个五位数的各个数位上的数字分别为<first digit><second digit><third digit><fourth digit><fifth digit>
  
现在我们把这个数各个数位上的数字按如下方式排列成新的数：<first digit><third digit><fifth digit><fourth digit><second digit>
  
然后我们要求其五次幂的后五个数字
  
例如对于数字12345，重新排列后得到13542，五次幂为455 422 043 125 550 171 232，输出71232

## 样例 #1

### 输入

```
12345
```

### 输出

```
71232```

# AI分析结果



# 题目重写
## Cracking the Code

### 题目描述
给出一个五位数，将各位数字按特定顺序重组后，计算其五次幂的最后五位数字。具体规则如下：

1. 原五位数的数位为：<第1位><第2位><第3位><第4位><第5位>
2. 新数的排列顺序为：<第1位><第3位><第5位><第4位><第2位>
3. 计算新数的五次幂，输出结果的后五位（不足五位需补前导零）

**样例输入**  
```
12345
```

**样例输出**  
```
71232
```

---

### 算法分类
模拟

---

## 题解综合分析

所有题解均采用直接模拟思路，核心差异体现在数位重组方式、取模优化和输出处理。关键优化点包括：利用位权数组简化重组运算、边乘边取模防止溢出、格式化输出补零技巧。

---

## 精选题解（评分≥4★）

### 题解1：Mine_King（★★★★★）
**关键亮点**  
1. 位权数组实现高效数位重组  
2. `scanf("%1d")` 实现逐位读取  
3. `printf("%05d")` 直接处理前导零  
**核心代码**  
```cpp
const int a[]={0,10000,1,1000,10,100};
for(int i=1;i<=5;i++) {
    scanf("%1d",&num);
    n += num * a[i]; // 按位权重组
}
for(int i=1;i<=5;i++) ans = ans * n % 100000;
printf("%05d",ans);
```
**代码思想**  
通过预定义的位权数组将输入数字直接映射到新数的对应位置，五次幂计算时每次迭代都取模避免溢出。

---

## 最优思路总结
1. **数位重组技巧**：使用位权数组（如[10000, 1, 1000, 10, 100]）直接计算重组后的数值，避免字符串转换开销。
2. **模运算优化**：在每次乘法后立即取模，将数值范围始终控制在1e5内，防止溢出。
3. **格式化输出**：利用`printf("%05d")`自动补前导零，简化输出逻辑。

---

## 拓展应用
1. **类似数位操作**：P1003 [铺地毯]（坐标映射）
2. **快速幂取模**：P1226 【模板】快速幂  
3. **大数处理**：P1614 爱与愁的心痛（滑动窗口+模运算）

---

## 题解心得摘录
- Mine_King：*"用scanf指定读入位数和printf补零可以极大简化代码"*  
- 张遇见：*"手动用switch处理数位时要注意权重顺序，调试时被这里坑过"*  
- 3a51_：*"long long是必须的，否则会在第三个测试点WA"*（反映数据范围意识）

---
处理用时：51.52秒
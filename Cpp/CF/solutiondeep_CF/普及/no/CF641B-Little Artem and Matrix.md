# 题目信息

# Little Artem and Matrix

## 题目描述

有一个 $n \times m$ 的矩阵，Artem 对它进行了 $q$ 次操作，每次操作一定属于下列三种中的一种：

- $1 \  r$，代表对于第 $r$ 行，第一个数挪到最后一个，第二个数挪到第一个，第三个数挪到第二个，以此类推，直到最后一个数挪到倒数第二个。

- $2 \  c$，代表对于第 $c$ 列，第一个数挪到最后一个，第二个数挪到第一个，第三个数挪到第二个，以此类推，直到最后一个数挪到倒数第二个。

- $3 \  r \  c \  x$，代表查询此时第 $r$ 行第 $c$ 列的数的值，结果为 $x$。

现在 Artem 记得这 $q$ 次操作，但不记得原来的矩阵是什么样子，请你帮他还原出这个矩阵，只要与操作不矛盾即可。

## 样例 #1

### 输入

```
2 2 6
2 1
2 2
3 1 1 1
3 2 2 2
3 1 2 8
3 2 1 8
```

### 输出

```
8 2 
1 8 
```

## 样例 #2

### 输入

```
3 3 2
1 2
3 2 2 5
```

### 输出

```
0 0 0 
0 0 5 
0 0 0 
```

# AI分析结果



# Little Artem and Matrix

## 题目描述

有一个 $n \times m$ 的矩阵，Artem 对它进行了 $q$ 次操作，每次操作一定属于下列三种中的一种：

- $1 \  r$，代表对于第 $r$ 行，第一个数挪到最后一个，第二个数挪到第一个，第三个数挪到第二个，以此类推，直到最后一个数挪到倒数第二个。

- $2 \  c$，代表对于第 $c$ 列，第一个数挪到最后一个，第二个数挪到第一个，第三个数挪到第二个，以此类推，直到最后一个数挪到倒数第二个。

- $3 \  r \  c \  x$，代表查询此时第 $r$ 行第 $c$ 列的数的值，结果为 $x$。

现在 Artem 记得这 $q$ 次操作，但不记得原来的矩阵是什么样子，请你帮他还原出这个矩阵，只要与操作不矛盾即可。

---

**算法分类**: 模拟

---

## 题解分析与结论

### 核心思路
两篇题解均采用**逆向模拟**的思路：从最后一个操作倒序处理，将每个行/列操作逆向执行，查询操作直接赋值。关键点在于：
1. 正向行操作是将首元素移到最后，逆向时需将末元素移到首部
2. 正向列操作是将首元素移到下方末尾，逆向时需将末元素移到顶部
3. 查询操作在逆序时直接设置该位置的值（相当于初始状态经过后续操作后的结果）

### 高分题解推荐

#### 题解1（作者：OIerWu_829）⭐️⭐️⭐️⭐️
**亮点**：代码结构清晰，变量命名直观。通过二维数组直接存储逆向操作结果，处理逻辑简洁。
```cpp
for (int k = q; k >= 1; k--) {
    if (opt[k] == 1) { // 逆向行操作
        int pos = ans[h[k]][m];
        for (int i = m; i > 1; i--)
            ans[h[k]][i] = ans[h[k]][i-1];
        ans[h[k]][1] = pos;
    } else if (opt[k] == 2) { // 逆向列操作
        int pos = ans[n][l[k]];
        for (int i = n; i > 1; i--)
            ans[i][l[k]] = ans[i-1][l[k]];
        ans[1][l[k]] = pos;
    } else {
        ans[h[k]][l[k]] = a[k]; // 逆向查询直接赋值
    }
}
```

#### 题解2（作者：oddy）⭐️⭐️⭐️⭐️
**亮点**：函数封装行/列操作，增强代码可读性。注释明确解释了临时变量的作用。
```cpp
void row(int k) { // 逆向行操作函数
    int tmp = a[k][m];
    for (int i = m; i >= 2; i--)
        a[k][i] = a[k][i-1];
    a[k][1] = tmp;
}
void column(int k) { // 逆向列操作函数
    int tmp = a[n][k];
    for (int i = n; i >= 2; i--)
        a[i][k] = a[i-1][k];
    a[1][k] = tmp;
}
```

---

### 关键技巧总结
1. **逆向思维**：对于可逆的操作序列，倒序处理可避免正向模拟中的状态覆盖问题
2. **操作等价转换**：行操作的正向是循环右移一位，逆向等价于循环左移一位
3. **查询即赋值**：在逆序过程中，遇到查询操作可直接确定该位置的最终值

---

### 拓展训练
1. [P7352 多米诺骨牌](https://www.luogu.com.cn/problem/P7352) - 逆向处理覆盖操作
2. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965) - 循环位移的数学建模
3. [P1970 积木大赛](https://www.luogu.com.cn/problem/P1970) - 逆向思维处理差分操作

---

### 同类题个人心得
调试时需注意行列索引的起始值（从1开始），以及循环移位时覆盖顺序。例如逆向行操作若从左向右移动会导致数据被错误覆盖，必须从右向左处理。

---
处理用时：64.54秒
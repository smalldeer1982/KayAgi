# 题目信息

# Processing Queries

## 题目描述

##### 问题描述

有一条单线程的生产线，即同时只能处理一项工作，有 $n$ 个工作申请，第 $i$ 个工作的开始时间为 $t_i$，完成需要 $d_i$ 个单位时间，所有的 $t_i$ 都不相同。

当一项工作申请出现时，生产线会有如下三种处理方案：

1. 如果生产线是空闲的，而且等待队列是空的，则当前申请的工作会被马上执行。
2. 如果生产线正在工作，而且等待队列中的工作少于 $b$ 个，则当前申请的工作会被加入到等待队列的队尾。
3. 如果生产线正在工作，而且等待队列中的工作已经有 $b$ 个，则当前申请的工作会被拒绝，而且再也不会接受该工作的申请。

## 说明/提示

$1 \leq n,b \leq 2\times 10^5$。

$1\leq  t_i,d_i \leq 10^9$。

$t_{i-1}<t_i$。

## 样例 #1

### 输入

```
5 1
2 9
4 8
10 9
15 2
19 1
```

### 输出

```
11 19 -1 21 22 
```

## 样例 #2

### 输入

```
4 1
2 8
4 8
10 9
15 2
```

### 输出

```
10 18 27 -1 
```

# AI分析结果



### 题目中文重写
**处理查询**

#### 问题描述

有一条单线程生产线，同时只能处理一项工作。共有 $n$ 个工作申请，第 $i$ 个工作的开始时间为 $t_i$，完成需要 $d_i$ 个单位时间，所有 $t_i$ 互不相同。

当新工作申请出现时，处理规则如下：
1. 若生产线空闲且等待队列为空，立即执行该工作。
2. 若生产线正在工作且等待队列中的任务数少于 $b$，将该工作加入队列尾部。
3. 否则拒绝该工作。

#### 输入格式
- 第一行输入 $n$ 和 $b$。
- 接下来 $n$ 行每行输入 $t_i$ 和 $d_i$，保证 $t_i$ 递增。

#### 输出格式
输出每个工作的完成时间，被拒绝的输出 `-1`。

---

### 算法分类
**模拟**

---

### 题解分析与结论
各题解核心思路均为模拟任务处理流程，利用队列维护等待任务。关键点在于正确处理队列状态和时间更新：

1. **队列维护**：队列存储任务结束时间，每次处理新任务前弹出所有已完成的队头任务。
2. **容量判断**：当队列中元素数（含正在处理的任务）超过 $b$ 时拒绝新任务。
3. **时间更新**：任务的开始时间为 `max(当前时间, 任务到达时间)`，结束时间累加处理时长。

---

### 高星题解推荐
#### 题解1：KukCair（5星）
**核心亮点**  
- 代码简洁，直接使用 STL 队列。
- 准确处理队列弹出和容量判断，逻辑清晰。

**代码片段**  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, b, nw;
queue<int> q;

signed main() {
    cin >> n >> b;
    while (n--) {
        int t, d;
        cin >> t >> d;
        while (!q.empty() && q.front() <= t) q.pop();
        if (q.size() > b) cout << "-1 ";
        else {
            nw = max(nw, t) + d;
            q.push(nw);
            cout << nw << ' ';
        }
    }
    return 0;
}
```

#### 题解2：King_and_Grey（5星）
**核心亮点**  
- 详细解释队列用法，强调 `long long` 的必要性。
- 代码结构清晰，注释完整。

**代码片段**  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, b, now;
queue<int> q;

signed main() {
    cin >> n >> b;
    while (n--) {
        int t, d;
        cin >> t >> d;
        while (!q.empty() && q.front() <= t) q.pop();
        if (q.size() > b) cout << "-1 ";
        else {
            now = max(now, t) + d;
            q.push(now);
            cout << now << " ";
        }
    }
    return 0;
}
```

---

### 关键思路总结
1. **队列状态维护**：每次处理新任务前，弹出所有可完成的队头任务。
2. **容量控制**：队列中元素数（含正在处理的任务）超过 $b$ 时拒绝新任务。
3. **时间计算**：任务的开始时间需取 `max(当前时间, 任务到达时间)`，避免时间回退。

---

### 拓展与相似题目
1. **P1540 [NOIP2010 提高组] 机器翻译**  
   队列模拟缓存淘汰，类似容量限制的场景。
2. **P2058 [NOIP2016 普及组] 海港**  
   队列维护时间窗口内的数据，处理多任务调度。
3. **P1198 [JSOI2008] 最大数**  
   动态维护序列中的最大值，可结合单调队列优化。

---

### 个人心得摘录
- **KukCair**：通过弹出队头任务保证队列状态正确。
- **hater**：强调队列满的判断条件易错，需结合题目规则反复验证。
- **King_and_Grey**：“不开 `long long` 见祖宗”提醒数据范围的重要性。

---
处理用时：356.79秒
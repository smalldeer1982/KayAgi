# 题目信息

# Beautiful Paintings

## 题目描述

有n幅画，第i幅画的好看值为a[i]。游客在从一幅画走到更漂亮的一幅画时会很高兴。画可以以任意顺序码放，游客从头至尾走一遍，高兴次数的最大值为c。求c的最大值。

## 说明/提示

在第一个例子中，最佳顺序为：10、20、30、40、50。
在第二个例子中，最佳顺序为：100、200、100、200。

## 样例 #1

### 输入

```
5
20 30 10 50 40
```

### 输出

```
4
```

## 样例 #2

### 输入

```
4
200 100 100 200
```

### 输出

```
2
```

# AI分析结果



# Beautiful Paintings

## 题目描述

有n幅画，第i幅画的好看值为a[i]。游客在从一幅画走到更漂亮的一幅画时会很高兴。画可以以任意顺序码放，游客从头至尾走一遍，高兴次数的最大值为c。求c的最大值。

## 说明/提示

在第一个例子中，最佳顺序为：10、20、30、40、50。
在第二个例子中，最佳顺序为：100、200、100、200。

## 样例 #1

### 输入

```
5
20 30 10 50 40
```

### 输出

```
4
```

## 样例 #2

### 输入

```
4
200 100 100 200
```

### 输出

```
2
```

**算法分类**：贪心

---

### 题解综合分析

各题解的核心思路均围绕**贪心策略**展开，通过不同方式实现最优分组。关键结论：最大高兴次数等于总画数减去最少分组数，其中每组为严格递增序列。最优解法通过排序后维护各组最大值实现高效分组。

---

### 高星题解推荐

1. **666DHG（5星）**
   - **核心亮点**：将问题转化为求最少分组数的逆向思维，通过排序+分组维护实现O(n log n)复杂度
   - **关键证明**：答案等于n-分组数（每次分组切换处产生一次不高兴）
   - **代码实现**：
     ```cpp
     sort(a+1,a+1+n);
     vector<int> V; // 存储每组最大值
     for(int i=1;i<=n;i++){
         bool flag=false;
         for(int j=0;j<V.size();j++)
             if(a[i]>V[j]) { // 可以放入已有组
                 V[j]=a[i];
                 flag=true;
                 break;
             }
         if(!flag) V.push_back(a[i]); // 新建组
     }
     printf("%d",n-V.size());
     ```

---

### 最优思路提炼

**关键技巧**：
1. **逆向思维转换**：将最大化递增次数问题转化为最小化分组数问题
2. **贪心分组策略**：排序后维护各组末尾元素，使新元素尽可能加入已有序列
3. **数据结构优化**：使用vector动态维护各组最大值，降低空间复杂度

**同类型拓展**：
- 类似问题：最长递增子序列、最少分组使每组递增
- 算法套路：贪心维护有序结构、逆向问题转换

---

### 推荐练习题
1. P1090 [NOIP2004 提高组] 合并果子（贪心+优先队列）
2. P1233 木棍加工（二维偏序+贪心）
3. P2870 [USACO07DEC] Best Cow Line G（贪心+双指针）

---
处理用时：99.39秒
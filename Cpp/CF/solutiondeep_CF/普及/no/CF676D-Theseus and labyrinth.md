# 题目信息

# Theseus and labyrinth

## 题目描述

给定 $n (1≤n≤100)$ 个数,从中找出尽可能多的数使得他们能够组成一个最长的等差数列。输出该最长等差数列的长度。

注意：当 $n=1$ 时，构成长度为 $1$ 的等差数列。

## 样例 #1

### 输入

```
2 2
+*
*U
1 1
2 2
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 3
&lt;&gt;&lt;
&gt;&lt;&gt;
1 1
2 1
```

### 输出

```
4```

# AI分析结果



【中文重写题目】

# Theseus与迷宫

## 题目描述

给定一个n×m的迷宫（1≤n,m≤100），每个格子包含可旋转的门。每次操作可以选择：1) 移动至相邻格子（需满足门的方向允许） 2) 旋转当前所在位置的门（顺时针旋转90度，每次旋转耗时1单位时间）。求从起点到终点的最短时间，若无法到达输出-1。

注意：旋转4次后恢复原状，门的状态按北、东、南、西四个方向循环。

## 样例 #1

### 输入
```
2 2
+*
*U
1 1
2 2
```

### 输出
```
-1
```

## 样例 #2

### 输入
```
2 3
><<
>><
1 1
2 1
```

### 输出
```
4
```

【算法分类】  
广度优先搜索 BFS

【题解分析】  
两篇题解均采用BFS框架，核心差异在于状态表示和方向判断：

1. Juanzhang的题解：
- 状态包含（坐标，旋转次数%4）
- 预处理每个字符在4个旋转状态下的通行方向表
- 使用三维数组记录访问状态
- 显式处理双向门验证（当前格出口与目标格入口）

2. 位运算题解：
- 将方向通行性编码为4位二进制数
- 使用位运算快速判断是否允许通行
- 方向处理采用模运算简化计算
- 函数封装方向判断逻辑

【高分题解】  
⭐️⭐️⭐️⭐️⭐️ 位运算题解  
亮点：  
- 位运算高效处理方向状态（to数组存储方向掩码）
- 方向判断函数pass()封装逻辑清晰
- 方向数组定义与常规坐标系一致（dx/dy对应北西南东）

核心代码：
```cpp
bool pass(int hx, int hy, int which, int chk) {
    return to[a[which][hx][hy]] & 1 << chk;
}

// BFS主循环
for (int i = 0; i < 4; i++) {
    int nx = px + dx[i], ny = py + dy[i];
    if (pd(nx, ny) && pass(px, py, u.sec, i) 
        && pass(nx, ny, u.sec, (i + 2) % 4)) {
        // 更新状态...
    }
}
```

⭐️⭐️⭐️⭐️ Juanzhang题解  
亮点：  
- 显式定义to_next数组处理反向门验证  
- 手打队列优化空间  
- 详细的字符旋转映射表  

关键实现：
```cpp
// 预处理字符旋转映射
nxt['L'] = 'U';
nxt['R'] = 'D';
// ...其他字符映射

// BFS状态扩展
if (to[i][a[u.sec][px][py]] && to[to_next[i]][a[u.sec][nx][ny]]) 
```

【最优技巧总结】  
1. **状态建模**：将旋转次数mod4作为第三维度，形成三维状态空间(x,y,rot)
2. **预处理优化**：预先计算所有字符在不同旋转状态下的通行方向，避免实时计算
3. **双向验证**：移动时需验证当前格的出口和相邻格的入口是否同时畅通
4. **位运算加速**：使用二进制位表示方向通行性，位运算快速判断可达性

【拓展应用】  
类似需处理状态变化的BFS问题：  
1. 携带钥匙的迷宫（P1133）  
2. 随时间变化的动态地图（P1943）  
3. 多维度状态的最短路径（方向+速度等）

【推荐习题】  
1. P1141 01迷宫（多查询连通性）  
2. P1126 机器人搬重物（方向旋转耗时）  
3. P1970 花匠（状态转移决策）

【题解心得】  
- "旋转4次后恢复原状" → 状态空间只需存rot%4  
- "手打队列空间要开1e7" → 基于网格规模100x100x4=40,000状态，实际不需要1e7，可能包含冗余经验  
- 方向处理注释强调"相邻点都有门才能走"，提醒需双向验证的关键点

---
处理用时：65.97秒
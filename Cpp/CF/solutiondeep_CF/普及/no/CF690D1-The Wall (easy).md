# 题目信息

# The Wall (easy)

## 题目描述

### 题意翻译

给定一个长为 $C$ $（1≤C≤100）$ ，宽为 $R$ $(1≤R≤100)$ 的矩形。其中$‘.’$ 表示该区域为空，而 $‘B’$ 表示该区域为实。

现在求有多少个区域为实。

## 样例 #1

### 输入

```
3 7
.......
.......
.BB.B..
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 5
..B..
..B..
B.B.B
BBB.B
```

### 输出

```
2
```

## 样例 #3

### 输入

```
4 6
..B...
B.B.BB
BBB.BB
BBBBBB
```

### 输出

```
1
```

## 样例 #4

### 输入

```
1 1
B
```

### 输出

```
1
```

## 样例 #5

### 输入

```
10 7
.......
.......
.......
.......
.......
.......
.......
.......
...B...
B.BB.B.
```

### 输出

```
3
```

## 样例 #6

### 输入

```
8 8
........
........
........
........
.B......
.B.....B
.B.....B
.BB...BB
```

### 输出

```
2
```

# AI分析结果



# The Wall (easy)

## 题目描述

### 题意翻译
给定一个 $C$ 行 $R$ 列的矩形网格（$1≤C,R≤100$），网格由字符 '.'（空）和 'B'（实）组成。求由相邻（上下左右四方向）的 'B' 组成的连通区域数量。

## 算法分类
深度优先搜索 DFS / 广度优先搜索 BFS

## 题解综合分析
各题解均围绕连通块计数展开，核心差异在于实现方式：
1. **DFS/BFS** 为主流解法（10/12），通过遍历时标记已访问节点实现
2. **并查集** 解法（1篇）将二维坐标映射为一维处理，但代码复杂度较高
3. **LCT** 解法（1篇）作为理论验证存在，但实际应用过于复杂

共同难点在于正确处理四连通而非八连通，以及高效标记已访问节点。最优解法为直接在原矩阵修改的DFS/BFS，时间复杂度 O(nm) 且空间最优。

## 优质题解推荐

### 1. Super_dark（4.5星）
**核心思路**：DFS遍历时直接修改原矩阵，将访问过的 'B' 改为 '.' 实现标记  
**亮点**：
- 零额外空间消耗
- 方向数组定义清晰
- 边界判断简洁

```cpp
void dfs(int x,int y) {
    a[x][y]='.';
    for(int i=0;i<4;i++) {
        int tx=x+dx[i], ty=y+dy[i];
        if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&a[tx][ty]=='B') 
            dfs(tx,ty);                      
    }
}
```

### 2. RE_Prince（4星）
**核心思路**：使用独立标记数组，保留原始数据  
**亮点**：
- 分离数据与标记更安全
- 详细解释四连通必要性
- 包含调试经验："八个方向会WA 76个点"

```cpp
void dfs(int x,int y) {
    a[x][y] = 0;
    if(a[x+1][y]) dfs(x+1,y);
    if(a[x-1][y]) dfs(x-1,y);
    if(a[x][y+1]) dfs(x,y+1);
    if(a[x][y-1]) dfs(x,y-1);
}
```

### 3. Guizy（4星）
**核心思路**：BFS实现，使用队列进行层序遍历  
**亮点**：
- 非递归实现适合大数据量
- 结构体封装坐标清晰
- 包含完整访问标记逻辑

```cpp
void bfs(int sx,int sy){
    queue<node> q;
    q.push({sx,sy});
    while(!q.empty()){
        node temp = q.front(); q.pop();
        for(int i=1;i<=4;i++){
            int xx=temp.x+dx[i], yy=temp.y+dy[i];
            if(a[xx][yy]=='B' && !vis[xx][yy]){
                vis[xx][yy] = 1; 
                q.push({xx,yy});
            }
        }
    }
}
```

## 关键优化技巧
1. **原地标记法**：直接修改输入矩阵节省内存
2. **方向数组**：使用dx/dy数组统一管理搜索方向
3. **提前终止**：主循环遇到未访问的B时立即计数+启动搜索

## 拓展练习
1. [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451) - 连通块基础变式
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 连通区域标记应用
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 大规模连通块预处理

## 调试经验摘录
"特别注意题目要求四连通而非八连通，八个方向会WA 76个点" —— RE_Prince  
"并查集解法在二维转一维时，注意行优先与列优先的映射区别" —— EdenSky  
"BFS队列操作时要先标记再入队，避免重复访问" —— Guizy

---
处理用时：57.63秒
# 题目信息

# Batch Sort

## 题目描述

现在给你一个  **_n_**  行  **_m_**  列的数字矩阵，每一行的元素是一个1到m的全排列。

你可以在每一行中选取两个元素并交换它们，但是每一行这样的操作不能超过一次。

同样的，你可以选择两列并交换它们，这样的操作不能超过1次。

显而易见的，你一共可以进行  **_0_**  到  **_n+1_**  次这样的操作。而且操作顺序可以任意。

现在给你的任务是判断能否在进行一系列操作后使得每一行的数字从小到大排列，即  **_1_**  到  **_m_**  。换句话说，就是能否按照给出的规则进行操作使每一行单调递增。

## 样例 #1

### 输入

```
2 4
1 3 2 4
1 3 4 2
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4 4
1 2 3 4
2 3 4 1
3 4 1 2
4 1 2 3
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
3 6
2 1 3 4 5 6
1 2 4 3 5 6
1 2 3 4 6 5
```

### 输出

```
YES
```

# AI分析结果



# Batch Sort

## 题目描述

给定一个 **_n_** 行 **_m_** 列的数字矩阵，每行元素是 1 到 m 的全排列。允许每行交换两个元素（最多一次），允许交换两列（最多一次）。判断能否通过操作使每行变为递增序列。

---

**算法分类**：枚举

---

## 题解综合分析

所有题解均采用暴力枚举列交换+逐行校验的核心思路。关键点在于：
1. **枚举所有可能的列交换对**（含不交换的情况）
2. **校验每行是否满足错误元素数为 0 或 2**
3. **时间复杂度** O(nm³) 在数据范围（n,m≤20）下可行

---

## 高星题解推荐

### 1. GWBailang（⭐⭐⭐⭐⭐）
**亮点**：代码简洁清晰，优先处理不交换列的情况，校验函数复用性强  
**核心思路**：
```cpp
bool hanshu(){ // 校验函数
    for(int i=1;i<=n;i++){
        int cnt=0;
        for(int j=1;j<=m;j++) 
            cnt += (a[i][j]!=j);
        if(cnt!=0 && cnt!=2) return false;
    }
    return true;
}
// 主函数枚举列交换
for(int i=1;i<m;i++) 
    for(int j=i+1;j<=m;j++){
        huan(i,j); // 交换列
        if(hanshu()) { cout<<"YES"; return 0; }
        huan(i,j); // 恢复
    }
```

### 2. 朱屹帆（⭐⭐⭐⭐）
**亮点**：独立封装交换函数，处理引用避免拷贝  
**技巧**：使用引用传递矩阵减少内存开销
```cpp
void swaplie(int (&b)[30][30], int x, int y) { // 引用传递矩阵
    for(int i=1;i<=n;i++) swap(b[i][x], b[i][y]);
}
```

### 3. _775spacing747_（⭐⭐⭐⭐）
**创新点**：通过位运算加速判断，直接检测成对错误
```cpp
bool check() {
    for(int i=1;i<=n;i++){
        int s=0;
        for(int j=1;j<=m;j++){
            if(a[i][j]==j) continue;
            if(j == a[i][a[i][j]]) s++; // 检测成对错误
            else return false;
        }
        if(s>2) return false;
    }
    return true;
}
```

---

## 关键思路总结

**核心技巧**：  
1. **列交换的枚举空间**：共 C(m,2)+1 种可能性（含不交换）
2. **行校验的快速判断**：错误元素必须成对出现（0或2个）
3. **矩阵恢复机制**：每次列交换后必须复原，避免状态污染

**优化方向**：  
- 预处理每行的错误位置集合，减少重复计算
- 使用镜像矩阵避免频繁交换操作

---

## 拓展练习

1. [CF999B - Reversing Encryption](https://www.luogu.com.cn/problem/CF999B)  
   **相似点**：字符串操作与逆序处理

2. [P2894 [USACO08FEB] Hotel G](https://www.luogu.com.cn/problem/P2894)  
   **相似点**：区间状态维护与暴力校验

3. [P1158 导弹拦截](https://www.luogu.com.cn/problem/P1158)  
   **相似点**：坐标变换后的枚举验证

---

## 题解心得摘录

> "暴力出奇迹，打表过样例" —— GWBailang  
> **启示**：小数据范围下不必过度优化，合理利用暴力解法

> "注意交换后必须恢复原矩阵，否则会影响后续枚举" —— Chtholly_Tree  
> **调试经验**：状态回溯是暴力枚举的关键陷阱点

> "错误元素必须成对出现，单个错误必然无法修正" —— Inker  
> **数学证明**：排列中单个元素错误无法通过一次交换修复

---
处理用时：62.07秒
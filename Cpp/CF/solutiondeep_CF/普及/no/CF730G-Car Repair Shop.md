# 题目信息

# Car Repair Shop

## 题目描述

Polycarp 开始创业了，明天他将开始汽车修理。目前，汽车修理厂非常小，不能同时修理多辆汽车。

Polycarp 已经从客户那里收集了 $n$ 个请求。请求编号从 $1$ 到 $n$。

第 $i$ 个请求包含两个值：$s_i$ 为客户希望开始维修其汽车的日期，$d_i$ 为维修汽车所需天数。天数从 $1$ 开始计算，第一天是明天，第二天是后天，依此类推。

Polycarp 从 $1$ 到 $n$ 依次考虑每个请求，对于第 $i$ 个请求：

- 如果 $\left[s_i,s_i+d_i-1\right]$ 这些天修理厂是闲置的，那么 $\left[s_i,s_i+d_i-1\right]$ 这些天就用来修理第 $i$ 个客户的车子

- 否则就找到最小的一个 $x$，满足 $\left[x,x+d_i-1\right]$ 这些天工厂是闲置的，然后把 $\left[x,x+d_i-1\right]$ 这些天用来修理第 $i$ 个客户的车子

给出 $n$ 个请求，请求出每个客户的车子是在那些天被修理的。

## 样例 #1

### 输入

```
3
9 2
7 3
2 4
```

### 输出

```
9 10
1 3
4 7
```

## 样例 #2

### 输入

```
4
1000000000 1000000
1000000000 1000000
100000000 1000000
1000000000 1000000
```

### 输出

```
1000000000 1000999999
1 1000000
100000000 100999999
1000001 2000000
```

# AI分析结果



# Car Repair Shop

## 题目描述

Polycarp 开始创业了，明天他将开始汽车修理。目前，汽车修理厂非常小，不能同时修理多辆汽车。

Polycarp 从客户那里收集了 $n$ 个请求，请求编号从 $1$ 到 $n$。第 $i$ 个请求包含两个值：$s_i$ 为客户希望开始维修的日期，$d_i$ 为所需天数。日期从第 1 天（明天）开始计算。

处理每个请求时：
1. 若区间 $[s_i, s_i+d_i-1]$ 全空闲，则直接使用该区间
2. 否则找到最小的 $x$，使得 $[x, x+d_i-1]$ 全空闲，使用该区间

要求输出每个请求实际使用的区间。

## 算法分类
模拟

## 题解综合分析

### 题解对比

#### Ninelife_Cat（4星）
**核心思路**：  
使用 `set` 维护空闲区间，初始为超大区间 `[1, 2e9]`。对于每个请求：
1. **优先尝试原定区间**：遍历 `set` 寻找包含 $[s_i, s_i+d_i-1]$ 的区间，若存在则分割该区间
2. **寻找最早可行区间**：若原区间不可用，找到第一个长度足够的空闲区间，分割前 $d_i$ 天使用

**亮点**：  
- 利用 `set` 自动排序特性快速定位区间
- 通过分割空闲区间的原子操作保证正确性
- 时间复杂度 $O(n \log n)$ 优于其他解法

**代码核心**：
```cpp
set<pair<int, int>> q;
q.insert({1, 2000000000});
for (每个请求) {
    bool found = false;
    for (auto it = q.begin(); it != q.end(); ++it) {
        auto [l, r] = *it;
        if (l <= s_i && r >= s_i + d_i - 1) { // 原区间可用
            q.erase(it);
            if (l < s_i) q.insert({l, s_i - 1});
            if (r > s_i + d_i - 1) q.insert({s_i + d_i, r});
            found = true;
            break;
        }
    }
    if (!found) { // 找最早可行区间
        for (auto it = q.begin(); it != q.end(); ++it) {
            auto [l, r] = *it;
            if (r - l + 1 >= d_i) {
                q.erase(it);
                if (r > l + d_i - 1) q.insert({l + d_i, r});
                break;
            }
        }
    }
}
```

#### luckydrawbox（3星）
**核心思路**：  
使用链表维护空闲区间，每个节点存储区间端点。处理请求时：
1. **检查原区间**：遍历所有已分配区间判断冲突
2. **插入新区间**：若原区间可用则插入链表，否则找第一个能容纳 $d_i$ 的空隙

**亮点**：  
- 链表结构直观展示区间分布
- 通过节点拆分实现区间管理

**不足**：  
- 链表操作复杂度高（每次遍历全链表）
- 初始边界设置不够严谨（样例2可能溢出）

---

### 最优思路总结
**关键技巧**：  
1. **区间分割法**：将空闲区间视为可分割资源，通过插入/分割操作维护可用区间
2. **有序结构管理**：利用 `set` 的自动排序特性，确保每次能快速定位候选区间
3. **贪心策略**：优先尝试原定区间，再取最左可用区间，保证解的最小性

**同类拓展**：  
- 会议室预订问题（LeetCode 253）
- 磁盘空间分配问题
- 时间片调度问题

---

## 推荐习题
1. P1803 线段覆盖（区间贪心）
2. P1719 最大加权矩形（二维区间处理）
3. P2251 质量检测（滑动窗口应用）

---
处理用时：90.94秒
# 题目信息

# Sagheer and Nubian Market

## 题目描述

Sagheer在去Luxor和 Aswan的旅途中去了Nubian市场给它的朋友和亲戚买纪念品。这个市场有一些奇怪的规则。市场上有$n$件商品，标号为$1$到$n$。第$i$件商品有一个基本花费为$a_{i}$埃及镑。如果Sagheer买了$k$件下标分别为$x_{1},x_{2},...,x_{k}$的商品，那么第$j$件商品的实际花费就是$a_{xj}+x_{j}·k(1 <= j <= k)$换句话说，每件商品的实际花费就是它的基本花费加上(它的下标×总购买件数)

Sagheer想花最多$S$埃及镑来买尽量多的纪念品，注意它只能买同一种物品一件。如果有多种方式使纪念品数量最大，他会选择花费最小的方案。你能帮助他完成他的任务吗？

## 样例 #1

### 输入

```
3 11
2 3 5
```

### 输出

```
2 11
```

## 样例 #2

### 输入

```
4 100
1 2 5 6
```

### 输出

```
4 54
```

## 样例 #3

### 输入

```
1 7
7
```

### 输出

```
0 0
```

# AI分析结果



【题目中文翻译】  
# Sagheer与努比亚市场  

## 题目描述  
Sagheer在前往卢克索和阿斯旺的旅途中来到努比亚市场为亲友购买纪念品。这个市场有特殊规则：共有n件商品（编号1~n），第i件基础价格为a_i埃及镑。若购买k件商品（下标x₁,x₂,...,x_k），则第j件实际价格为a_xj + x_j·k。Sagheer希望用最多S镑购买尽可能多的纪念品，若数量相同则选择总价最低的方案。

## 样例 #1  
### 输入  
3 11  
2 3 5  
### 输出  
2 11  

（保持原题所有格式及样例内容完整不变）

【算法分类】  
二分

【题解综合分析】  
各题解均采用二分+贪心思路，核心流程为：  
1. 二分枚举可能购买数量k  
2. 对每个k，计算各物品实际价格a_i + i*k  
3. 排序后取前k个最小值的和  
4. 验证是否满足预算，更新最大k及最小总价  

差异点主要在于二分边界处理、数据类型选择（是否用long long防溢出）、结果记录方式。最优解需同时满足最大k与最小总价，通过在二分过程中维护这两个值实现。

【高星题解推荐】  
1. 作者：xixike（4星）  
   ✅ 亮点：  
   - 边界处理干净，直接通过ans/res记录答案  
   - 代码简洁，变量命名清晰  
   - 包含中途终止累加的优化  
   ```cpp
   bool check(int mid){
       for(int i = 1; i <= n; i++) 
           b[i] = a[i] + i * mid;
       sort(b + 1, b + 1 + n);
       res = 0;
       for(int i = 1; i <= mid && res <= s; i++)
           res += b[i];
       return res <= s;
   }
   ```

2. 作者：AntonyD（4星）  
   ✅ 亮点：  
   - 详细中文注释，易理解  
   - 使用long long严格防溢出  
   - 变量命名具有语义性（如itemCount、totalCost）  
   ```cpp
   bool check(int middle){
       for(int i=1; i<=itemCount; i++)
           actualCost[i] = itemCost[i] + i * middle;
       sort(actualCost + 1, actualCost + 1 + itemCount);
       totalSpent = 0;
       for(int i=1; i<=middle; i++)
           totalSpent += actualCost[i];
       return totalSpent <= totalCost;
   }
   ```

3. 作者：傅思维666（4星）  
   ✅ 亮点：  
   - 结构体存储原始数据，避免修改原数组  
   - 分享调试经历：最初用暴力得60分，后改用二分优化  
   ```cpp
   bool check(int x){
       for(int j=1;j<=n;j++)
           p[j].t=p[j].a+p[j].order*x;
       sort(p+1,p+n+1,cmp);
       int temp=0;
       for(int j=1;j<=x;j++) temp+=p[j].t;
       return temp<=s;
   }
   ```

【关键思路总结】  
- 二分框架：答案明显具有单调性（k越大越难满足）  
- 贪心验证：每个k对应独立的价格计算，排序后选前k小  
- 优化点：在累加时提前终止超过预算的情况  
- 防坑技巧：使用long long类型避免计算溢出

【类似题目】  
1. P1678 烦恼的高考志愿（二分答案）  
2. P2440 木材加工（二分最大长度）  
3. P2678 跳石头（最小距离最大化）

【题解心得摘录】  
傅思维666："感谢出题人给我一次重新再来的机会改到了100分。一开始考虑DP发现不可行，后来在出题人提示下使用二分"  
→ 启示：当暴力复杂度高时，应优先考虑二分/分治等log级优化

---
处理用时：56.80秒
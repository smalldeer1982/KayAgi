# 题目信息

# Unimodal Array

## 题目描述

一个整数数组是单峰的，如果：

一开始它是严格增加的；

之后是恒定不变的；

再后是严格减少的；

第一块（增加）和最后一块（减少）可能不存在。允许这两块都不存在。

例如，下面这三个数组是单峰的：

$[5,7,11,11,2,1] , [4,4,2] , [7]$ 

但是，下面这三个不是单峰的：

$[5,5,6,6,1] , [1,2,1,2] , [4,5,5,6]$ 

写一个程序来判断一个数组是否是单峰的。

## 说明/提示

第一个样例中的数组是单峰的，因为它是在开始的时候严格递增（从位置$1$ 到位置$2$ ，含端点），中间恒定不变（从位置$2$ 到位置$4$ ，含端点）并在最后严格递减（从位置$4$ 到位置$6$ ，含端点）。

by @Khassar

## 样例 #1

### 输入

```
6
1 5 5 5 4 2
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
5
10 20 30 20 10
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
4
1 2 1 2
```

### 输出

```
NO
```

## 样例 #4

### 输入

```
7
3 3 3 3 3 3 3
```

### 输出

```
YES
```

# AI分析结果



# Unimodal Array

## 题目描述

一个整数数组是单峰的，如果：

- 一开始它是严格递增的；
- 之后是恒定不变的；
- 再后是严格递减的；
- 第一块（递增）和最后一块（递减）可能不存在。允许这两块都不存在。

例如，下面这三个数组是单峰的：

$[5,7,11,11,2,1] , [4,4,2] , [7]$ 

但以下三个不是单峰的：

$[5,5,6,6,1] , [1,2,1,2] , [4,5,5,6]$ 

写一个程序判断数组是否是单峰的。

## 分类
模拟

---

## 题解分析与结论

题目要求数组满足**严格递增 → 恒定 → 严格递减**的形态，允许递增和递减部分缺失。核心难点在于如何高效检测三阶段的顺序合法性，避免阶段回退（如递减后出现递增）或阶段跳跃（如恒定后出现递增）。

### 高星题解推荐

#### 1. 作者：zhangyuhan（★★★★★）
**核心思路**：单次遍历，通过 `flag1`（峰顶标记）和 `flag2`（下坡标记）动态跟踪阶段变化。  
- 若当前元素等于前驱，标记进入峰顶阶段（`flag1=true`）  
- 若当前元素小于前驱，标记进入下坡阶段（`flag2=true`，并重置峰顶标记）  
- 若在下坡阶段出现非递减，或在峰顶阶段出现非恒定，则非法  

**代码亮点**：  
- 时间复杂度 O(n)，空间复杂度 O(1)  
- 通过两个布尔变量简洁表达状态，逻辑清晰  
```cpp
bool flag1 = false, flag2 = false;
for (int i = 2; i <= n; i++) {
    if (a[i] == a[i-1]) flag1 = true;
    else if (a[i] < a[i-1]) {
        flag2 = true;
        flag1 = false;
    }
    if ((flag2 && a[i] >= a[i-1]) || (flag1 && a[i] != a[i-1])) {
        cout << "NO";
        return 0;
    }
}
```

#### 2. 作者：Rainbow_qwq（★★★★☆）
**核心思路**：定位峰值平台（最大值连续段），检查左右是否符合递增和递减。  
- 找到第一个最大值位置，向右扩展至平台右端点  
- 左侧必须严格递增，右侧必须严格递减  

**代码亮点**：  
- 直观体现题目定义的三个阶段结构  
- 三次遍历，时间复杂度仍为 O(n)  
```cpp
int lpos = 0, rpos = 0;
for (int i = 1; i <= n; i++) 
    if (a[i] > a[lpos]) lpos = i;
rpos = lpos;
while (a[rpos+1] == a[lpos]) rpos++;
// 检查左侧递增和右侧递减
```

#### 3. 作者：Iron_Heart（★★★★☆）
**核心思路**：状态机模型，通过 `state` 变量记录当前阶段（递增、恒定、递减）。  
- 初始状态为递增（state=-1）  
- 遇到恒定则状态转为恒定（state=0）  
- 遇到递减则状态转为递减（state=1），且不可回退  

**代码亮点**：  
- 状态转换逻辑与题目定义高度对应  
```cpp
int state = -1;
for (int i = 1; i < n; ++i) {
    if (a[i] == a[i-1]) {
        if (state == -1) state = 0;
        else if (state == 1) flag = false; // 递减后出现恒定非法
    } else if (a[i] < a[i-1]) {
        if (state == 0 || state == -1) state = 1;
    } else if (state != -1) flag = false; // 非递增阶段出现递增非法
}
```

---

### 最优思路总结
**关键技巧**：  
1. **阶段标记法**：通过布尔变量或状态变量动态跟踪当前所处阶段（递增/恒定/递减），禁止非法阶段转换。  
2. **单次遍历优化**：结合相邻元素比较，实时更新阶段标记，实现 O(n) 时间复杂度。  

**拓展应用**：  
- 类似形态验证问题（如螺旋数组、非递减数组）  
- 状态机模型适用于多阶段顺序检测场景  

---

### 推荐习题
1. [P1093 奖学金](https://www.luogu.com.cn/problem/P1093) - 排序与条件判断  
2. [P2947 Look Up](https://www.luogu.com.cn/problem/P2947) - 单调栈维护递减序列  
3. [P1567 统计天数](https://www.luogu.com.cn/problem/P1567) - 最长连续递增序列

---
处理用时：73.96秒
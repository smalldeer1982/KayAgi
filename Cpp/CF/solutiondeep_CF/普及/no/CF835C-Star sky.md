# 题目信息

# Star sky

## 题目描述

在空中设置笛卡尔坐标系。有 $n$ 个星星，第 $i$ 个星星有坐标 $(x_i,y_i)$ 和最大亮度 $c$ ，每个星星有个初始亮度 $s_i(0\leq s_i\leq c)$   
随着时间推移，星星的亮度也在变化。第0时刻亮度为 $s_i$ 。若 $t$ 时刻亮度为 $x$ ，则 $t+1$ 时刻为 $x+1,x+1\leq c$ 否则为0  
你想观察天空 $q$ 次，第 $i$ 你会在 $t_i$ 时刻观察一个和坐标轴平行的矩阵范围，矩阵左下角为 $(x_{1i},y_{1i})$ ，右上角为 $(x_{2i},y_{2i})$ 。对于每一次观察，你都想知道范围内星星亮度总和  
若星星在边界上也算作内部

## 样例 #1

### 输入

```
2 3 3
1 1 1
3 2 0
2 1 1 2 2
0 2 1 4 5
5 1 1 5 5
```

### 输出

```
3
0
3
```

## 样例 #2

### 输入

```
3 4 5
1 1 2
2 3 0
3 3 1
0 1 1 100 100
1 2 2 4 4
2 2 1 4 7
1 50 50 51 51
```

### 输出

```
3
3
5
0
```

# AI分析结果



### 题目重写
见用户提供的原始题目内容，已为中文无需重写。

---

### 算法分类
前缀和

---

### 题解综合分析
所有题解均基于以下核心观察：  
1. 亮度变化周期为 c+1，查询时间可简化为 t mod (c+1)  
2. 利用 c≤10 的条件，预处理所有可能时刻的二维前缀和  
3. 通过容斥原理计算矩形区域和  

**关键优化点**：  
- 将时间维度压缩到 0~c 的有限状态  
- 利用固定坐标系（1≤x,y≤100）的特性，通过预处理避免实时计算  

---

### 精选题解

#### 1. 作者：Akoasm_X（5星）
**核心亮点**：  
- 最简洁直接的实现，预处理每个时刻的完整二维前缀和  
- 直接通过取模运算定位查询时刻的亮度状态  
- 代码结构清晰，无冗余计算  

**代码核心**：
```cpp
// 预处理部分
for(int j=0;j<=c;j++) 
    sum[j][x][y] += (s + j) % (c + 1);
// 查询部分
t %= (c+1);
sum[t][x2][y2] - sum[t][x1-1][y2] - sum[t][x2][y1-1] + sum[t][x1-1][y1-1];
```

#### 2. 作者：MuelsyseU（4星）
**核心亮点**：  
- 显式处理多星星叠加在同一坐标的情况  
- 使用更紧凑的数组维度顺序优化空间局部性  

**关键实现**：
```cpp
for(int j = 0; j < mod; j++) 
    s[x][y][j] += (z + j) % mod;
// 查询时直接计算模后时间
z %= mod;
s[x2][y2][z] - s[x-1][y2][z] - s[x2][y-1][z] + s[x-1][y-1][z]
```

#### 3. 作者：Angelina188（4星）
**核心亮点**：  
- 采用分层统计亮度数量的思路  
- 通过遍历亮度值计算动态总和，适合需要二次计算的场景  

**代码亮点**：
```cpp
for(int i=0;i<=c;i++){
    int num = s[a2][b2][i] - s[a1-1][b2][i] - s[a2][b1-1][i] + s[a1-1][b1-1][i];
    ans += num * ((i+t)%(c+1));
}
```

---

### 关键技巧总结
1. **周期性压缩**：利用 c+1 的周期特性，将无限时间轴压缩到有限状态  
2. **分层前缀和**：对每个时刻独立建立二维前缀和数组，实现 O(1) 查询  
3. **同坐标叠加**：允许同一坐标存在多个星星，预处理时直接累加亮度值  

---

### 拓展练习
1. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719) - 二维前缀和极值  
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 差分与前缀和的综合应用  
3. [P2280 激光炸弹](https://www.luogu.com.cn/problem/P2280) - 固定尺寸矩形的最优覆盖  

---

### 题解心得摘录
- **Muruski**：  
  *"第一眼以为要线段树，后来发现 c 很小直接三重循环暴力，数据不大欸嘿嘿"*  
  → 小数据量下暴力解法可能更优  
- **KXY_Moon**：  
  *"注意边界...遍历所有亮度的总和"*  
  → 处理边界时需仔细验证容斥公式

---
处理用时：48.28秒
# 题目信息

# Union of Doubly Linked Lists

## 题目描述

双向链表是一种基本的数据结构。一个双向链表是一串元素序列。链表中每一个元素都链接着它前面和后面的元素。在这个问题中，这个链表是一个线性序列。除了第一个元素外，每个元素都有一个直接前导；除了最后一个元素外，每个元素都有一个直接后继。这个链表不形成一个环。



在这个问题中，你被给予了$n$个单元。这些单元能够形成一个或者多个双向链表。每个单元包含着一些链表元素的信息。这些单元的编号是从$1$至$n$的。



对于每个单元，有两个属性：



$l_i$表示第$i$个单元的前导；



$r_i$表示第$i$个单元的后继。



如果$l_i=0$，表示这个单元没有直接前导。如果$r_i=0$，表示这个单元没有直接后继。





| $i$  | $l_{i}$ | $r_{i}$ |

| ---- | ------- | ------- |

| 1    | 4       | 7       |

| 2    | 5       | 0       |

| 3    | 0       | 0       |

| 4    | 6       | 1       |

| 5    | 0       | 2       |

| 6    | 0       | 4       |

| 7    | 1       | 0       |



你的任务是，给定若干个由如上方式表示的双向链表，链接这些双向链表使得其仅构成一个双向链表。注意：你只能通过链接两个双向链表的首尾单元来链接这两个双向链表。

## 样例 #1

### 输入

```
7
4 7
5 0
0 0
6 1
0 2
0 4
1 0
```

### 输出

```
4 7
5 6
0 5
6 1
3 2
2 4
1 0
```

# AI分析结果



# 中文题目重写  
**题目名称：双向链表的合并**  

## 题目描述  
双向链表是一种基础数据结构，每个元素包含直接前驱和后继的链接。现给定n个元素（编号1~n），每个元素有l_i（前驱）和r_i（后继）属性。0表示无前驱/后继。这些元素可能形成多个独立双向链表。  

**任务**：将所有链表合并为一个，仅允许通过连接链表的首尾元素进行合并。  

## 输入输出格式  
**输入**：  
- 第一行为n  
- 后续n行每行给出l_i和r_i  

**输出**：  
- 合并后的各元素前驱和后继  

---

**算法分类**：模拟  

---

# 题解分析与结论  
**核心思路**：  
维护一个当前已合并链表的尾部指针。遍历所有元素，当遇到无前驱的元素（新链表的头）时，将其连接到当前尾部，并更新尾部到新链表的末尾。  

**解决难点**：  
1. 正确识别每个子链表的头尾  
2. 维护双向指针的对称性（前驱和后继同步更新）  
3. O(n)时间复杂度遍历  

---

# 精选题解  

## 题解作者：泠小毒（5星）  
**关键亮点**：  
- 代码极简（仅11行核心逻辑）  
- 变量命名清晰（lst表示当前尾部）  
- 无冗余操作，直接操作原数组  

**核心代码**：  
```cpp
int lst = 0;
for(int i=1;i<=n;i++) if(a[i]==0) {
    b[lst] = i;    // 当前尾部连接新头
    a[i] = lst;    // 新头前驱设为尾部
    lst = i;       // 移动到新头
    while(b[lst]) lst = b[lst]; // 找到新链表尾部
}
```  

---

## 题解作者：gaoleng_luogu_name（4星）  
**关键亮点**：  
- 函数封装输出逻辑  
- 添加详细注释说明连接过程  

**核心代码**：  
```cpp
int Next = 0;
for(int i=1; i<=n; i++) {
    if(!t[i]) { 
        w[Next] = i; 
        t[i] = Next; 
        Next = i; 
        while(w[Next]) Next = w[Next]; 
    }
}
```  

---

## 题解作者：NaOHqwq（4星）  
**关键亮点**：  
- 明确变量命名为nxt增强可读性  
- 包含输入输出完整流程  

**核心代码**：  
```cpp
int nxt = 0;
for(int i=1;i<=n;i++) {
    if(a[i] == 0) {
        b[nxt] = i;
        a[i] = nxt;
        nxt = i;
        while(b[nxt]) nxt = b[nxt];
    }
}
```  

---

# 最优技巧总结  
**关键技巧**：  
- **尾部指针维护**：用变量持续跟踪已合并部分的末尾  
- **头节点探测**：通过前驱为0的特征快速定位子链表头  
- **双向指针同步**：修改后继时同步更新对应元素的前驱  

**易错点**：  
- 忘记更新尾部到新链表的最末端  
- 修改前驱/后继时未双向同步  

---

# 拓展与练习  
**相似题目**：  
1. P1160 队列安排（双向链表基础操作）  
2. P1996 约瑟夫问题（循环链表模拟）  
3. P2058 海港（队列与链表结合）  

**思维延伸**：  
在处理多链表合并问题时，维护当前合并状态的关键指针（如头尾）是通用思路。类似思想可用于树结构的合并（如二叉树的线索化）。

---
处理用时：72.58秒
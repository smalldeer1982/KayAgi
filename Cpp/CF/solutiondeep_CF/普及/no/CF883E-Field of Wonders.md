# 题目信息

# Field of Wonders

## 题目描述

Polycarpus参加了一个电视节目，节目的参与者的任务是尽快猜出一个完全未知的单词。

节目中，每位参与者会轮流说出一个字母，主持人会回答这个词中是否有这样的字母。如果有，那么主持人就会透露单词中所有与它相同的字母。例如，如果未知的单词是 $"abacaba"$，参与者说出了字母 $a$，主持人就会展示单词中所有字母 $a$ 的下标 $:1,3,5,7$（下标从$1$开始，从左至右）。

Polycarpus知道 $m$ 个单词，这 $m$ 个单词的长度与未知单词的长度相同。他也知道，这个未知的单词，是这些 $m$ 个单词中的一个。

节目已经进行了若干轮，未知单词的一些字母（可能没有）已经知道了，且Polycarpus能够准确地说出目前已知的字母。

现在该Polycarpus说字母了。他想说出一个字母，使得主持人一定会透露至少一个字母。但是，Polycarpus无法分辨这些已经知道的字母。你的任务是帮助Polycarpus，找出他能说的字母，使得节目主持人一定会透露至少一个未知的字母。

## 样例 #1

### 输入

```
4
a**d
2
abcd
acbd
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
lo*er
2
lover
loser
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
a*a
2
aaa
aba
```

### 输出

```
1
```

# AI分析结果



### 中文重写题目
# 奇迹之地

## 题目描述

Polycarpus参与了一档电视节目，参赛者的任务是尽快猜出一个完全未知的单词。

每位参与者轮流说出一个字母，主持人会告知该字母是否存在于单词中。若存在，主持人会透露该字母在单词中的所有位置。例如，若未知单词是 $"abacaba"$，参与者说出字母 $a$，主持人会展示所有 $a$ 的下标 $1,3,5,7$（下标从1开始）。

Polycarpus知道 $m$ 个与未知单词长度相同的候选单词，且未知单词必定是其中之一。节目已进行若干轮后，部分字母已被揭示（用非星号字符表示），而星号表示未知位置。

Polycarpus需要选择一个字母，使得无论正确答案是哪个候选词，主持人必然透露至少一个新位置。求满足条件的字母数量。

## 样例 #1

### 输入
```
4
a**d
2
abcd
acbd
```

### 输出
```
2
```

## 样例 #2

### 输入
```
5
lo*er
2
lover
loser
```

### 输出
```
0
```

## 样例 #3

### 输入
```
3
a*a
2
aaa
aba
```

### 输出
```
1
```

---

### 算法分类
模拟

---

### 题解分析与结论

**核心逻辑**：  
1. 筛选有效候选词：必须与已知位置的字符完全匹配，且星号位置的字符未被已知字符占用。  
2. 统计所有有效候选词的星号位置字符集合的交集，只有出现在所有候选词星号位置的字符才符合条件。  

**关键思路**：  
- 通过逐步排除法，维护一个可能字符集合，初始为所有小写字母。  
- 对每个有效候选词，将其星号位置的字符加入临时集合，保留这些字符，排除其他字符。  
- 最终剩余字符即为所有候选词星号位置的公共字符。

---

### 优质题解推荐

#### 题解作者：lixianyuan（4星）
**亮点**：  
- 使用集合交集思想，逐个候选词过滤无效字符。  
- 代码简洁，通过 `map` 实现字符存在性判断和排除操作。  

**核心代码**：  
```cpp
void work(){
    string t;cin>>t;
    bool b=1;
    // 验证候选词是否符合已知条件
    for(int i=0;i<n;i++){    
        if(s[i]!='*'&&t[i]!=s[i]){
            b=0;
            break;
        }
        else if(s[i]=='*'&&st[t[i]]==-1){
            b=0;
            break;
        }
    }
    if(b){    
        tmp++;
        t1.clear();
        // 收集当前候选词的星号字符
        for(int i=0;i<n;i++){
            if(s[i]=='*') t1[t[i]]=1;
        }
        // 排除不在当前候选词星号位置的字符
        for(char i='a';i<='z';i++){
            if(t1[i]!=1) num[i]=0;
        }
    }
} 
```

---

### 关键思路总结
**核心技巧**：  
- **集合交运算**：通过逐步过滤保留所有候选词的公共字符。  
- **双条件验证**：候选词必须同时满足已知位置匹配和星号字符未被占用。  

**类似题型套路**：  
- 涉及多条件筛选、集合交并运算的模拟题。  
- 例如：统计多个字符串的公共字符、验证多条件约束下的合法性等。  

---

### 推荐练习题
1. [CF727E - Games on a CD](https://www.luogu.com.cn/problem/CF727E)（字符串哈希与循环匹配）  
2. [CF746B - Decoding](https://www.luogu.com.cn/problem/CF746B)（模拟字符串重构）  
3. [洛谷P1308 - 统计单词数](https://www.luogu.com.cn/problem/P1308)（字符串模式匹配与位置统计）

---
处理用时：266.56秒
# 题目信息

# Road Widening

## 题目描述

$S$ 市市长讨厌树木和草坪。他们占用了如此多的空间，而且他们占用的地方可能有一条路！市长认为，若拆除没有人需要的草坪，城市的一条街道可能会大大拓宽。此外，这可能有助于减少街上发生的交通堵塞。街道从左至右分为 $ n $ 个部分，每个部分由两个整数表示：道路宽度 $ s_i $ 与 草坪 $ g_i $ 的宽度。
 
市长需要拆除一部分草坪来拓宽道路。对于长度为 $ g_i $ 的草坪，你可以将它拆除 $ x_i $ ( $ x_i $ $ \le $ $ g_i $ ).同时，道路的宽度 $ s_i $ 加上 $ x_i $。

一方面，市长希望拆除尽可能多的草坪（并用道路代替）。另一方面，他不想造成道路快速加宽或变窄，从而导致车祸。为了避免这种情况，市长决定连续路段的道路宽度最多相差1。

你需要找到市长应拆除的草坪长度，并输出拆除这个长度后，每条道路的宽度。

## 说明/提示

$ 1<=n<=2·10^{5} $ 

$ 1<=s_{i}<=10^{6} $ 

$ 0<=g_{i}<=10^{6} $

## 样例 #1

### 样例输入 #1

```
3
4 5
4 5
4 10
```

### 样例输出 #1

```
16
9 9 10
```

## 样例 #2

### 样例输入 #2

```
4
1 100
100 1
1 100
100 1
```

### 样例输出 #2

```
202
101 101 101 101
```

## 样例 #3

### 样例输入 #3

```
3
1 1
100 100
1 1
```

### 样例输出 #3

```
-1
```

## 样例 #1

### 输入

```
3
4 5
4 5
4 10
```

### 输出

```
16
9 9 10 
```

## 样例 #2

### 输入

```
4
1 100
100 1
1 100
100 1
```

### 输出

```
202
101 101 101 101 
```

## 样例 #3

### 输入

```
3
1 1
100 100
1 1
```

### 输出

```
-1
```

# AI分析结果



### 中文题目重写
#### 题目描述
S市市长讨厌树木和草坪。它们占用了太多可能用于道路的空间！市长认为，若拆除部分无人需要的草坪，可将街道拓宽。街道被分为 $n$ 个路段，每个路段由道路宽度 $s_i$ 和草坪宽度 $g_i$ 组成。

市长希望拆除尽可能多的草坪（将其转换为道路），但拓宽后的道路需满足相邻路段宽度差不超过 1。请确定应拆除的草坪总长度，并输出最终各路段道路宽度，若无解输出 -1。

### 算法分类
**构造**（通过两次遍历调整极值以满足相邻约束条件）

---

### 题解综合分析
所有题解均采用**两次遍历调整极值**的核心思路：
1. **初始化**每个路段最大可能宽度为 $s_i + g_i$
2. **左到右遍历**：确保每个路段宽度不超过前驱路段+1
3. **右到左遍历**：确保每个路段宽度不超过后继路段+1
4. **合法性检查**：若最终宽度小于原道路宽度则无解

---

### 高分题解推荐
#### 1. 作者：_hi_（⭐⭐⭐⭐⭐）
**关键亮点**：
- 双向遍历处理相邻约束，确保全局最优
- 边界初始化技巧（设置虚拟极大边界）
- 完整处理非法情况判断

**代码核心逻辑**：
```cpp
for(int i=1; i<=n; i++) // 正向遍历
    s2[i] = min(s[i]+g[i], min(s2[i-1]+1, s2[i+1]+1));
for(int i=n; i>=1; i--) // 反向遍历
    s2[i] = min(s[i]+g[i], min(s2[i-1]+1, s2[i+1]+1));
```

#### 2. 作者：灵茶山艾府（⭐⭐⭐⭐）
**关键亮点**：
- 简洁的双向传递逻辑
- 高效的类型转换处理大数
- 流式输入输出优化

**算法要点**：
```go
for i := range mx { // 正向约束传递
    if i>0 && mx[i-1]+1 < mx[i] { mx[i] = mx[i-1]+1 }
}
for i := n-2; i >= 0; i-- { // 反向约束传递
    if mx[i+1]+1 < mx[i] { mx[i] = mx[i+1]+1 }
}
```

#### 3. 作者：erok（⭐⭐⭐）
**亮点**：
- 单数组复用节省空间
- 清晰的变量命名
- 错误判断与输出分离

**优化点**：
```cpp
for(int i=2; i<=n; i++) // 仅处理左约束
    f[i] = min(f[i-1]+1, s[i]+g[i]);
for(int i=n-1; i>=1; i--) // 仅处理右约束
    f[i] = min(f[i+1]+1, f[i]);
```

---

### 关键思路总结
**双向极值调整法**：
1. **极值初始化**：每个位置取理论最大值 $s_i+g_i$
2. **约束传播**：
   - 正向遍历：保证 $s'[i] ≤ s'[i-1]+1$
   - 反向遍历：保证 $s'[i] ≤ s'[i+1]+1$
3. **全局验证**：最终结果需同时满足 $s'[i] ≥ s_i$

**同类问题拓展**：
- 分发糖果问题（相邻大小约束）
- 矩阵中的最长递增路径约束
- 二维网格中的极值传播问题

---

### 推荐练习题
1. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)（贪心+双向决策）
2. [P1276 校门外的树（增强版）](https://www.luogu.com.cn/problem/P1276)（区间约束处理）
3. [P1564 膜拜](https://www.luogu.com.cn/problem/P1564)（相邻约束下的极值问题）

---

### 调试经验摘录
_hi_作者心得：
> "只正扫一遍导致部分道宽被后续更小的值限制，必须反向再扫。惊觉双向遍历才能满足所有相邻约束"

这揭示了**约束传播类问题的共性**：当单方向遍历无法确保全局约束时，双向遍历常能突破局部最优，达到全局合法状态。

---
处理用时：72.64秒
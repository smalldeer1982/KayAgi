# 题目信息

# K-Dominant Character

## 题目描述

您将得到一个全部由小写拉丁字母组成的字符串s，当且仅当对于每个长度不小于k的s的子串都含有字符c（c指某个小写拉丁字母），那么我们称c为k-主导字符。

您需要给出一个最小的k，使得对于给定的s至少存在一个k-主导字符。

## 样例 #1

### 输入

```
abacaba
```

### 输出

```
2
```

## 样例 #2

### 输入

```
zzzzz
```

### 输出

```
1
```

## 样例 #3

### 输入

```
abcde
```

### 输出

```
3
```

# AI分析结果



# K-Dominant Character

## 题目描述

给定一个由小写拉丁字母组成的字符串 $s$，当且仅当对于每个长度不小于 $k$ 的 $s$ 的子串都含有字符 $c$ 时，称 $c$ 为 k-主导字符。要求找到最小的 $k$，使得存在至少一个 k-主导字符。

## 样例

### 样例输入 1
```
abacaba
```
### 样例输出 1
```
2
```

### 样例输入 2
```
zzzzz
```
### 样例输出 2
```
1
```

### 样例输入 3
```
abcde
```
### 样例输出 3
```
3
```

---

## 算法分类
**字符串**、**贪心**

---

## 题解分析与结论

### 核心思路
对每个字符 $c$ 计算其相邻出现位置的最大间隔（包括首尾虚拟位置），该间隔即为保证 $c$ 成为主导字符的最小 $k$。最终答案取所有字符对应 $k$ 的最小值。

### 最优题解亮点

#### 王熙文（5星）
- **关键思路**：通过虚拟首尾字符统一处理边界情况
- **代码亮点**：将字符串首尾扩展虚拟字符，简化边界判断
```cpp
s[0] = i; // 虚拟首字符
s[l+1] = i; // 虚拟尾字符
while (j <= l+1) { // 包含虚拟尾字符的扫描
    while(s[j]!=i) ++j;
    maxqj = max(maxqj, j - last);
    last = j++;
}
```

#### RioFutaba（4星）
- **关键思路**：显式处理末尾边界，无需虚拟字符
- **代码亮点**：简洁的循环结构配合最后边界处理
```cpp
for (int c='a'; c<='z'; c++) {
    last[c] = 0;
    a[c] = 0;
    for (int i=1; i<=n; i++) {
        if (s[i] == c) {
            a[c] = max(a[c], i - last[c]);
            last[c] = i;
        }
    }
    ans = min(ans, max(a[c], n+1 - last[c]));
}
```

#### GJX_Algorithm（4星）
- **关键思路**：同时给出二分法和线性解法，体现不同思维角度
- **实现技巧**：前缀和预处理优化二分判断
```cpp
// 前缀和预处理
for (int i=1; i<=n; i++) 
    for (int j=0; j<26; j++)
        sum[i][j] = sum[i-1][j] + (s[i]-'a'==j);
```

---

## 关键技巧总结
1. **虚拟边界法**：在字符串首尾添加虚拟字符（如当前枚举的字符），统一处理首尾间隔计算。
2. **间隔极值法**：对每个字符记录其相邻出现位置的最大间隔，该值即为该字符成为主导的最小 $k$。
3. **并行处理法**：同时维护 26 个字母的间隔信息，通过一次遍历完成所有计算。

---

## 相似题目推荐
1. [CF888C - K-Dominant Character](https://www.luogu.com.cn/problem/CF888C)（本题原型）
2. [P1365 子串统计](https://www.luogu.com.cn/problem/P1365)（字符间隔极值问题）
3. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（区间覆盖与极值计算）
4. [CF535C - Tavas and Karafs](https://www.luogu.com.cn/problem/CF535C)（边界处理与极值应用）

---
处理用时：75.22秒
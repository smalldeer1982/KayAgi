# 题目信息

# Pride

## 题目描述

## 问题描述

你有一个长度为 $n$ 的数列 $a$，你能执行一些操作。每个操作是这样的：选择两个相邻的数 $x$ 和 $y$，把它们中的一个换为 $\gcd(x,y)$。这里的 $\gcd$ 代表[最大公约数](en.wikipedia.org/wiki/Greatest_common_divisor)。

问你把数列中的数全变成 $1$ 的最小操作次数。

## 说明/提示

在第一个例子中你可以把数都变成 $1$ 通过这 $5$ 步：

- $[2,2,3,4,6]$
- $[2,1,3,4,6]$
- $[2,1,3,1,6]$
- $[2,1,1,1,6]$
- $[1,1,1,1,6]$
- $[1,1,1,1,1]$

可以证明在这个例子中不可能用 $5$ 步以下来把所有的数都变成 $1$。

## 样例 #1

### 输入

```
5
2 2 3 4 6
```

### 输出

```
5
```

## 样例 #2

### 输入

```
4
2 4 6 8
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3
2 6 9
```

### 输出

```
4
```

# AI分析结果



### 题目重写

# Pride

## 题目描述

### 问题描述

给定一个长度为 $n$ 的数列 $a$，每次操作可以选择两个相邻的数 $x$ 和 $y$，将其中一个替换为 $\gcd(x, y)$。求将数列中所有数变为 $1$ 的最小操作次数。若无法完成则输出 $-1$。

## 样例

### 样例 #1

输入：
```
5
2 2 3 4 6
```
输出：
```
5
```

### 样例 #2

输入：
```
4
2 4 6 8
```
输出：
```
-1
```

### 样例 #3

输入：
```
3
2 6 9
```
输出：
```
4
```

---

### 算法分类
**数学**、**贪心**

---

### 题解分析与结论

#### 核心逻辑
1. **存在1的情况**：若数组中已有 $k$ 个 $1$，则只需操作 $n-k$ 次。
2. **无解情况**：若整个数组的 $\gcd \neq 1$，则无法生成 $1$，返回 $-1$。
3. **生成1的最小操作**：找到最短的连续子数组 $[l, r]$ 满足 $\gcd(a_l, a_{l+1}, \dots, a_r) = 1$，所需操作次数为 $(r-l) + (n-1)$。

#### 难点对比
- **暴力枚举法**（时间复杂度 $O(n^2)$）：枚举每个左端点，逐步扩展右端点计算 $\gcd$，适合数据量较小的情况（如 $n \leq 2000$）。
- **二分+ST表优化**（时间复杂度 $O(n \log n)$）：预处理区间 $\gcd$，通过二分查找最短有效区间，适合更大规模数据。

---

### 精选题解

#### 1. 作者：Mine_King（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 代码简洁直观，暴力枚举每个左端点并向右计算 $\gcd$，找到最短有效区间。
- 预处理特判，逻辑清晰，包含优化：一旦发现 $\gcd=1$ 立即终止内层循环。
```cpp
for(int i=1;i<=n;i++) {
    int b=a[i];
    for(int j=i+1;j<=n;j++) {
        b = gcd(b, a[j]);
        if(b == 1) {
            mn = min(mn, j-i);
            break; // 关键优化
        }
    }
}
```

#### 2. 作者：_LighT_（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 使用 ST 表预处理区间 $\gcd$，结合二分查找最短有效区间，时间复杂度 $O(n \log n)$。
- 预处理 $\log$ 加速查询，代码结构严谨，适合数据量较大的情况。
```cpp
// ST表预处理
for(int j=1;j<=17;j++)
    for(int i=1;i+(1<<j)-1<=n;i++)
        st[i][j] = gcd(st[i][j-1], st[i+(1<<(j-1))][j-1]);

// 二分最短区间
int L=1, R=n, ans=INT_MAX;
while(L <= R) {
    int mid = (L+R)>>1;
    if(check(mid)) ans=mid, R=mid-1;
    else L=mid+1;
}
```

#### 3. 作者：JACK_POT（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 动态规划预处理区间 $\gcd$，通过区间 DP 逐步合并计算，直接找到第一个生成 $1$ 的区间。
- 代码简洁，逻辑明确，适合对 DP 思路熟悉的读者。
```cpp
for(int len=2; len<=n; len++) {
    for(int l=1, r; (r=l+len-1)<=n; l++) {
        f[l][r] = gcd(f[l][r-1], a[r]);
        if(f[l][r] == 1) return printf("%d", len+n-2), 0;
    }
}
```

---

### 关键思路总结
1. **数学性质**：利用 $\gcd$ 的结合律和单调性，快速判断区间是否能生成 $1$。
2. **贪心思想**：最短有效区间的操作次数最优，需优先找到该区间。
3. **优化技巧**：内层循环提前终止、ST 表预处理、区间 DP 合并计算。

---

### 拓展练习
1. [P8792 [蓝桥杯 2022 国 A] 最大公约数](https://www.luogu.com.cn/problem/P8792)（同类加强版）
2. [P2448 无尽的任务](https://www.luogu.com.cn/problem/P2448)（区间操作与数学结合）
3. [P8783 [蓝桥杯 2022 省 B] 统计子矩阵](https://www.luogu.com.cn/problem/P8783)（二维区间处理）

---
处理用时：63.71秒
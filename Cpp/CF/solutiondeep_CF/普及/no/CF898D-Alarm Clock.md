# 题目信息

# Alarm Clock

## 题目描述

每天晚上 Vitalya 会设置 $n$ 个闹钟以便明早醒来。每个闹钟都会正好响一分钟，并正好在那一分钟的开始响起，结束停止。给定 $a_i$ 来表示第 $i$ 个闹钟响起的时间。如果在连续的 $m$ 分钟内有至少 $k$ 个闹钟响起，Vitalya 就会醒来。注意 Vitalya 只会考虑在那一段时间中开始响起的闹钟，即不考虑在之前已经响起而未停止响的闹钟。 

Vitalya 十分疲劳，他想睡整整一天而不起床。您的任务是计算出需要关掉的闹钟总数的最小值。开始时所有闹钟都是打开状态。

## 样例 #1

### 输入

```
3 3 2
3 5 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 10 3
12 8 18 25 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
7 7 2
7 3 4 1 6 5 2
```

### 输出

```
6
```

## 样例 #4

### 输入

```
2 2 2
1 3
```

### 输出

```
0
```

# AI分析结果



# Alarm Clock

## 题目描述

每天晚上 Vitalya 会设置 $n$ 个闹钟以便明早醒来。每个闹钟都会正好响一分钟，并正好在那一分钟的开始响起，结束停止。给定 $a_i$ 来表示第 $i$ 个闹钟响起的时间。如果在连续的 $m$ 分钟内有至少 $k$ 个闹钟响起，Vitalya 就会醒来。注意 Vitalya 只会考虑在那一段时间中开始响起的闹钟，即不考虑在之前已经响起而未停止响的闹钟。 

Vitalya 十分疲劳，他想睡整整一天而不起床。您的任务是计算出需要关掉的闹钟总数的最小值。开始时所有闹钟都是打开状态。

---

**算法分类**：贪心

---

### 关键题解分析与对比

所有题解的核心思路均为排序后维护滑动窗口，当窗口内闹钟数≥k时贪心删除最右侧的闹钟。不同实现方式的对比：

1. **双端队列实现**（憨豆Beng、灵茶山艾府）  
   维护一个窗口，当窗口右端与左端差值≥m时弹出左端元素。若当前窗口长度≥k，则删除最右侧元素。  
   - 优势：时间复杂度和空间复杂度均为最优 $O(n\log n)$
   - 难点：理解为何删除最右侧元素能保证全局最优（减少后续窗口的冲突）

2. **双指针实现**（staygone）  
   用左右指针维护窗口，当窗口内数量≥k时标记右端点为删除。  
   - 劣势：需要额外维护删除标记数组，空间复杂度较高

3. **暴力删除法**（cqbzcjh）  
   直接遍历所有可能的k连续区间，删除最右侧元素。  
   - 致命缺陷：vector的erase操作时间复杂度为 $O(n)$，整体复杂度退化为 $O(n^2)$

---

### 最优题解（评分≥4星）

#### 1. 憨豆Beng（⭐⭐⭐⭐⭐）
**亮点**：  
- 双端队列维护窗口，代码简洁高效  
- 核心逻辑仅需8行，完美体现贪心思想  

```cpp
sort(a + 1, a + n + 1);
deque<int> dq;
for(int i = 1; i <= n; ++i) {
    while(dq.size() && dq.front() <= a[i] - m) dq.pop_front();
    dq.push_back(a[i]);
    if(dq.size() >= k) ++cnt, dq.pop_back(); 
}
```

#### 2. 灵茶山艾府（⭐⭐⭐⭐⭐）
**亮点**：  
- 滑动窗口配合标记删除，逻辑清晰  
- 通过置零标记已删除元素，避免队列操作  

```go
slices.Sort(a)
for i, x := range a {
    cnt++ 
    for x-a[left] >= m {
        if a[left] > 0 { cnt-- }
        left++
    }
    if cnt == k {
        a[i] = 0  // 标记删除
        cnt--
        ans++
    }
}
```

---

### 关键技巧总结
1. **排序预处理**：所有闹钟按时间排序是贪心策略的基础
2. **窗口维护**：动态维护窗口左端点，确保窗口时间跨度≤m
3. **贪心删除**：当窗口内闹钟数≥k时，优先删除最右侧元素以最大化后续窗口的可用空间

---

### 同类题目推荐
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. [CF1133C Balanced Team](https://codeforces.com/problemset/problem/1133/C)  
3. [P3143 [USACO16OPEN] Diamond Collector S](https://www.luogu.com.cn/problem/P3143)

---

### 调试心得摘录
- **JackMerryYoung**：  
  "排序后维护单调队列，类似滑动窗口的经典问题。删除右侧元素的关键在于让后续窗口尽可能少受影响。"  
- **cqbzrjx**：  
  "考试时未想到贪心策略，后意识到删除最晚的闹钟能最大限度减少后续冲突。"

---
处理用时：66.35秒
# 题目信息

# Permute Digits

## 题目描述

给出两个正整数a,b。在十进制下重排a，构造一个不超过b的最大数，不能有前导零。允许不去重排a。

## 样例 #1

### 输入

```
123
222
```

### 输出

```
213
```

## 样例 #2

### 输入

```
3921
10000
```

### 输出

```
9321
```

## 样例 #3

### 输入

```
4940
5000
```

### 输出

```
4940
```

# AI分析结果



### 题目中文重写
**题目名称：数字重排**

#### 题目描述
给定两个正整数a和b。在十进制下重新排列a的各位数字，构造一个不超过b的最大数，不能有前导零。允许保持a原有顺序不变。

#### 样例
**样例1**  
输入：  
123  
222  
输出：  
213  

**样例2**  
输入：  
3921  
10000  
输出：  
9321  

**样例3**  
输入：  
4940  
5000  
输出：  
4940  

---

### 算法分类
**贪心 + 回溯**

---

### 题解对比与结论
#### 核心思路总结
1. **位数不足时直接输出最大排列**：若a的位数小于b，直接将a的数字按从大到小排序输出。
2. **逐位贪心匹配**：
   - 将a的数字排序后，从高位到低位匹配b的每一位。
   - 优先选择等于b当前位的数字，若后续无法满足则回溯调整前一位。
   - 若某一位选择比b小的数字，后续位直接填充剩余最大数字。

#### 最优解法关键点
- **贪心策略**：高位优先选择最大合法数字。
- **回溯机制**：当当前位无法找到合法数字时，递归调整前一位。
- **剪枝优化**：某位选择比b小时，后续位无需再匹配，直接填充剩余最大数字。

---

### 高分题解推荐
#### 1. 题解作者：yaolibo（⭐⭐⭐⭐⭐）
**关键亮点**  
- 清晰的分层逻辑处理（位数不足、递归回溯）。
- 使用字符串操作简化数字拼接。
- 显式处理前导零问题。
**核心代码**  
```cpp
void change(int x) {
    // 回溯调整前一位的逻辑
    for (int j = 0; j < la; j++) { 
        if (a[j] == str && vis[j]) { 
            vis[j] = 0; break; 
        }
    }
    // 重新选择较小数字后填充剩余最大数字
    for (i = 0; i < la; i++) 
        if (!vis[i]) c += a[i];
    cout << c; exit(0);
}
```

#### 2. 题解作者：JimmyLee（⭐⭐⭐⭐）
**关键亮点**  
- 简洁的DFS实现，通过`lead`和`up`标记处理前导零和上限。
- 利用反向字符串简化索引操作。
**核心代码**  
```cpp
void dfs(int p, bool lead, bool up) {
    if(!~p) cout<<det, exit(0);
    int mx = up ? b[p]-'0' : 9;
    for(int i = mx; i >= 0; i--) {
        if(!cnt[i]) continue;
        cnt[i]--; det += i+'0';
        dfs(p-1, 0, up && i == mx);
        cnt[i]++; det.pop_back();
    }
}
```

#### 3. 题解作者：Ruan_ji（⭐⭐⭐）
**关键亮点**  
- 剪枝逻辑清晰，通过`f`标记快速跳过无效分支。
- 代码结构简明，适合快速理解回溯思想。
**个人心得**  
> "当某位已经比b小时，后续直接填充最大剩余数字，这是本题最重要的剪枝。"

---

### 拓展建议
1. **类似题目推荐**  
   - [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)：利用排列性质构造最优解。
   - [P1784 数独](https://www.luogu.com.cn/problem/P1784)：回溯算法的经典应用。
   - [CF985D](https://codeforces.com/problemset/problem/985/D)：贪心+构造的进阶题目。

2. **算法套路扩展**  
   - **数字构造类问题**：通常需要结合贪心与回溯，例如[下一个排列](https://leetcode.cn/problems/next-permutation/)。
   - **带剪枝的DFS**：在排列问题中通过标记提前终止无效搜索。

---
处理用时：72.43秒
# 题目信息

# Chat

## 题目描述

有 $n$ 条信息，每次可以显示当前信息、前 $k$ 信息以及后 $k$ 条信息,如果当前信息以上或以下的信息数不足 $k$ ,则忽略不足。对于第 $i$ 个信息，可以通过其链接访问第 $a_i$ 个信息,可以访问当前信息的链接，但如果 $a_i=0$​​ 则不可访问。问最多可以访问多少条信息。

## 样例 #1

### 输入

```
6 0
0 1 1 2 3 2
```

### 输出

```
1 2 2 3 3 3 
```

## 样例 #2

### 输入

```
10 1
0 1 0 3 4 5 2 3 7 0
```

### 输出

```
2 3 3 4 5 6 6 6 8 2 
```

## 样例 #3

### 输入

```
2 2
0 1
```

### 输出

```
2 2 
```

# AI分析结果



### 题目中文重写（保留原格式）
题目已为中文描述，无需重复翻译。

### 算法分类
递推

### 题解综合分析
本题核心在于通过递推关系式快速计算每个信息点的最大可见范围。各题解均采用分情况处理 a_i 是否为 0 的策略，利用递推避免重复计算重叠区域。关键难点在于理解跳转后的覆盖范围计算，以及通过 min(2k+1, i-a_i) 处理区间重叠。

### 高星题解推荐
#### 1. 作者：N_z_ (⭐⭐⭐⭐⭐)
**关键亮点**  
- 代码极简，仅用单数组维护结果  
- 通过 min(2k+1, i-a_i) 巧妙处理区间合并  
- 时间复杂度 O(n) 严格最优

**核心代码**  
```cpp
if(y==0)a[x]=min(k,x-1)+1;
else a[x]=a[y]+min(k*2+1,x-y);
cout<<a[x]+min(k,n-x)<<endl;
```

#### 2. 作者：Morxita_lmy (⭐⭐⭐⭐)
**关键亮点**  
- 详细定义 res[i] 为前向可见数，思路更易理解  
- 包含完整读入输出优化模板  
- 注释清晰，适合新手学习

**个人心得**  
> "观察到题目保证 a_i < i 这一关键性质，这是递推可行性的基础。"

#### 3. 作者：CharlesZiy (⭐⭐⭐⭐)
**关键亮点**  
- 对比 TLE 递归与 AC 递推的复杂度差异  
- 强调前缀和思想与递归的转换关系  
- 代码去冗余保留核心逻辑

**调试经验**  
> "最初的递归思路导致 O(n²) 复杂度，必须转换思维用递推实现 O(1) 查询。"

### 关键思路总结
**核心技巧**：  
1. 分治思想：将问题拆分为前向范围与后向范围  
2. 区间合并：用 min(2k+1, i-a_i) 处理跳转后的重叠区域  
3. 递推公式：  
   - a_i=0: 前向范围 = min(k, i-1) + 1  
   - a_i≠0: 前向范围 = a[a_i] + min(2k+1, i-a_i)  
4. 最终结果 = 前向范围 + min(k, n-i)

### 拓展建议
类似递推结构的题目特征：  
- 问题可分解为顺序处理的子问题  
- 当前状态仅依赖有限的前驱状态  
- 存在明显的区间合并/重叠处理需求

### 推荐练习题
1. CF977F（递推求最长连续序列）  
2. P1216 数字三角形（经典递推DP）  
3. P1048 采药（01背包问题递推解法）

---
处理用时：61.27秒
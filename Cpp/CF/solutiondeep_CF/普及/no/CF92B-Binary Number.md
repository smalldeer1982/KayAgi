# 题目信息

# Binary Number

## 题目描述

小海狮牙牙非常喜欢学数学。因此，他在无聊的时候经常用数字做♂游♂戏。

牙牙拿了一些正整数 _x_ ， 他想通过一些操作将 _x_ 变成1。当 _x_ 不等于1的时候，牙牙会重复下列步骤：如果 _x_ 为奇数，他就会将 _x_ 加上1。如果 _x_ 为偶数，他就会将 _x_ 除以2。牙牙想知道他需要多少步才能将 _x_ 变为1。

## 样例 #1

### 输入

```
1
```

### 输出

```
0
```

## 样例 #2

### 输入

```
1001001
```

### 输出

```
12
```

## 样例 #3

### 输入

```
101110
```

### 输出

```
8
```

# AI分析结果



# Binary Number

## 题目描述

小海狮牙牙非常喜欢学数学。因此，他在无聊的时候经常用数字做♂游♂戏。

牙牙拿了一些正整数 _x_ ， 他想通过一些操作将 _x_ 变成1。当 _x_ 不等于1的时候，牙牙会重复下列步骤：如果 _x_ 为奇数，他就会将 _x_ 加上1。如果 _x_ 为偶数，他就会将 _x_ 除以2。牙牙想知道他需要多少步才能将 _x_ 变为1。

## 样例

### 样例 #1
输入：1 → 输出：0

### 样例 #2
输入：1001001 → 输出：12

### 样例 #3
输入：101110 → 输出：8

**算法分类**：模拟、二进制处理

---

### 题解综合分析

所有题解均采用字符串模拟二进制操作，核心思路是通过指针从末位向首位处理，根据当前位的值（0/1/2）进行进位和右移操作。关键难点在于处理连续进位后的状态转换，以及最终最高位的特判。

#### 精选题解亮点

1. **cyffff（4星）**
   - 亮点：使用char数组优化读取，通过switch结构清晰分类处理不同情况，维护当前处理位的指针，高效处理进位链
   - 代码核心：
     ```cpp
     while(i){
         n++;
         switch(a[i]){
             case '0': i--; break;
             case '1': n++; a[--i]++; break;
             case '2': a[--i]++; break;
         }
     }
     if(a[i]=='2') n++;
     ```

2. **时律（4星）**
   - 亮点：代码极其简洁（仅17行），通过指针回退统一处理进位，巧妙利用字符操作实现状态转换
   - 关键逻辑：
     ```cpp
     while(i>0){
         if(a[i]=='2') ans++,i--,a[i]++;
         else if(a[i]=='1') ans++,a[i-1]++,a[i]='0';
         else ans++,i--;
     }
     ```

3. **LYqwq（4星）**
   - 亮点：详细注释解释进位机制，使用string类型简化操作，处理进位时直接修改前一位的值
   - 核心实现：
     ```cpp
     case '1': s[--p]++; ans++; break;
     case '2': s[--p]++; break;
     ```

---

### 关键思路总结

1. **二进制操作特性**：偶数直接右移（删末位），奇数加1后必然产生进位链
2. **进位处理技巧**：用字符数组记录当前位的状态，遇到'1'时两步操作（加1和右移）合并计数
3. **指针维护**：通过指针变量跟踪当前处理位，避免频繁修改字符串长度
4. **特判机制**：循环结束后检查最高位是否为'2'，处理最后一步进位

---

### 拓展建议

类似题目可练习：
1. CF 92B（原题）
2. 洛谷 P6101 [二进制运算进阶](https://www.luogu.com.cn/problem/P6101)
3. 洛谷 P2119 [魔法数字](https://www.luogu.com.cn/problem/P2119)
4. 洛谷 P1100 [二进制加法](https://www.luogu.com.cn/problem/P1100)

调试经验：
- 注意最高位进位产生新位的情况（如111+1=1000）
- 连续进位时使用while循环处理更高效
- 字符串操作时注意下标从0开始还是从1开始

---
处理用时：48.78秒
# 题目信息

# Zebras

## 题目描述

给你一个01串，要求将它划分成多个子序列，子序列不一定是连续的，子序列要满足以0开头，以0结尾，中间01交替出现。

## 样例 #1

### 输入

```
0010100
```

### 输出

```
3
3 1 3 4
3 2 5 6
1 7
```

## 样例 #2

### 输入

```
111
```

### 输出

```
-1
```

# AI分析结果

【题目内容】
# Zebras

## 题目描述

给你一个01串，要求将它划分成多个子序列，子序列不一定是连续的，子序列要满足以0开头，以0结尾，中间01交替出现。

## 样例 #1

### 输入

```
0010100
```

### 输出

```
3
3 1 3 4
3 2 5 6
1 7
```

## 样例 #2

### 输入

```
111
```

### 输出

```
-1
```

【算法分类】
贪心

【题解分析与结论】
本题的核心在于如何将01串划分为满足条件的子序列。所有题解都采用了贪心策略，通过维护当前子序列的状态（以0或1结尾）来动态分配字符。难点在于如何高效地管理子序列的状态，并确保最终所有子序列都以0结尾。

【所选高星题解】

1. **作者：pushinl (4星)**
   - **关键亮点**：通过维护一个计数器 `cnt` 来动态管理子序列的分配，使用二维动态数组 `vector` 存储子序列的位置信息。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     for(int i=0;i<l;i++){
         if(s[i]=='0')q[cnt++].push_back(i+1);	//0
         else{									//1
             if(cnt==0){			//如果1比0多就不可能满足条件 
                 cout<<-1<<endl;
                 return 0;
             }
             q[--cnt].push_back(i+1);
         }
         k=max(k,cnt);
     }
     ```
   - **个人心得**：作者提到使用 `vector` 是为了避免空间爆炸，体现了对内存管理的考虑。

2. **作者：One_JuRuo (4星)**
   - **关键亮点**：通过 `cnt` 和 `num` 两个变量分别记录子序列总数和以1结尾的子序列数，确保每个1都能被合理分配。代码结构清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     for(int i=0;i<n;++i){
         if(s[i]=='1'){
             if(num==cnt) printf("-1"),exit(0);
             v[++num].push_back(i);
         }
         else{
             if(num) v[num--].push_back(i);
             else v[++cnt].push_back(i);
         }
     }
     ```
   - **个人心得**：作者提到贪心策略的合理性，强调了尽可能减少以1结尾的子序列数。

3. **作者：_775spacing747_ (4星)**
   - **关键亮点**：通过变量 `k` 控制子序列的分配，确保每个0和1都能被正确分配到合适的子序列中。代码实现简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<s.size();i++){
         if(s[i]=='0')v[++k].push_back(i);//是0,就k++，插在下一个是1的后面 
         else{//是1 
             if(k==0){//因为第一个要是0，如果k==0,说明没有，即输出-1 
                 cout<<-1<<endl;
                 return 0;
             }
             v[--k].push_back(i);
         }
         ma=max(ma,k);//取下最大值 
     }
     ```
   - **个人心得**：作者提到 `k` 的控制逻辑，强调了子序列的交替分配。

【最优关键思路】
使用贪心策略，通过维护当前子序列的状态（以0或1结尾）来动态分配字符，确保每个子序列都以0结尾。使用 `vector` 或类似数据结构来存储子序列的位置信息，避免空间爆炸。

【可拓展之处】
类似的问题可以出现在其他需要动态分配资源的场景中，如任务调度、资源分配等。贪心策略在这些问题中也有广泛应用。

【推荐题目】
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：31.58秒
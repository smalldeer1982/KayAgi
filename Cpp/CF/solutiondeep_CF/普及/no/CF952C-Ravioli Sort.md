# 题目信息

# Ravioli Sort

## 题目描述

众所周知，有一种叫做[意大利面排序](https://en.wikipedia.org/wiki/Spaghetti_sort)的算法。你决定自己实现一个类似的排序算法，但是当你检查你的储藏室时，你意识到你没有意大利面了！你唯一有的是意大利饺子，但你不会因此而放弃…

你构思了以下算法。对于数组中的每个数字 $a_i$，构建一个由 $a_i$ 个意大利饺子组成的堆栈。下面的图片展示了当 $ai = 4$ 时的堆栈。

[![](https://espresso.codeforces.com/04041f95b0a3e1dee7d8b24fa163e68861737411.png)](https://espresso.codeforces.com/04041f95b0a3e1dee7d8b24fa163e68861737411.png)

将这些堆栈按照输入数组中对应数字的顺序排列在一行中。找到最高的堆栈（如果有多个最高的堆栈，选择最左边的一个）。移除这个堆栈，并将其高度添加到输出数组的末尾。将行中的堆栈向左移动，使它们之间没有间隙。重复这个过程，直到所有的堆栈都被移除。

起初，你对自己的算法感到非常满意，但是当你尝试对更多的输入进行排序时，你意识到它并不总是能产生正确的排序数组。事实证明，当两个相邻的意大利饺子堆栈（在过程的任何步骤中）在高度上相差两个或更多时，较高堆栈的顶部意大利饺子会滑落到较低的堆栈上面。

给定一个输入数组，判断描述的算法是否能正确排序它。

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3
3 1 2
```

### 输出

```
NO
```

# AI分析结果

【题目内容】
# Ravioli Sort

## 题目描述

众所周知，有一种叫做[意大利面排序](https://en.wikipedia.org/wiki/Spaghetti_sort)的算法。你决定自己实现一个类似的排序算法，但是当你检查你的储藏室时，你意识到你没有意大利面了！你唯一有的是意大利饺子，但你不会因此而放弃…

你构思了以下算法。对于数组中的每个数字 $a_i$，构建一个由 $a_i$ 个意大利饺子组成的堆栈。下面的图片展示了当 $ai = 4$ 时的堆栈。

[![](https://espresso.codeforces.com/04041f95b0a3e1dee7d8b24fa163e68861737411.png)](https://espresso.codeforces.com/04041f95b0a3e1dee7d8b24fa163e68861737411.png)

将这些堆栈按照输入数组中对应数字的顺序排列在一行中。找到最高的堆栈（如果有多个最高的堆栈，选择最左边的一个）。移除这个堆栈，并将其高度添加到输出数组的末尾。将行中的堆栈向左移动，使它们之间没有间隙。重复这个过程，直到所有的堆栈都被移除。

起初，你对自己的算法感到非常满意，但是当你尝试对更多的输入进行排序时，你意识到它并不总是能产生正确的排序数组。事实证明，当两个相邻的意大利饺子堆栈（在过程的任何步骤中）在高度上相差两个或更多时，较高堆栈的顶部意大利饺子会滑落到较低的堆栈上面。

给定一个输入数组，判断描述的算法是否能正确排序它。

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3
3 1 2
```

### 输出

```
NO
```

【算法分类】  
模拟

【题解分析与结论】  
本题的核心逻辑是判断数组中是否存在相邻元素的差值大于1的情况。如果存在，则输出“NO”，否则输出“YES”。所有题解都围绕这一核心逻辑展开，且大部分题解都采用了直接遍历数组并比较相邻元素差值的方法。

【评分较高的题解】  
1. **作者：lzqy_ (赞：3)**  
   - **星级：4星**  
   - **关键亮点**：题解对题意进行了详细的分析，明确了问题的核心在于判断相邻元素的差值是否大于1。代码实现简洁，使用了`abs`函数来简化差值的计算，且逻辑清晰，易于理解。  
   - **核心代码**：
     ```cpp
     for(int i=2; i<=n; i++) {
         if(abs(a[i]-a[i-1])>1) {
             cout<<"NO\n";
             return 0;
         }
     }
     cout<<"YES\n";
     ```

2. **作者：happybob (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：题解采用了不使用数组的方法，通过逐个读取输入并比较相邻元素的差值，节省了空间。代码简洁，逻辑清晰，且通过`abs`函数简化了差值的计算。  
   - **核心代码**：
     ```cpp
     for(int i = 2; i <= n; i++) {
         cin >> b;
         if(abs(b - a) >= 2) {
             cout << "NO\n";
             return 0;
         }
         a = b;
     }
     cout << "YES\n";
     ```

3. **作者：REAL_曼巴 (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：题解同样采用了不使用数组的方法，通过逐个读取输入并比较相邻元素的差值，节省了空间。代码简洁，逻辑清晰，且通过`abs`函数简化了差值的计算。  
   - **核心代码**：
     ```cpp
     while(n--) {
         cin >> b;
         if(abs(b - a) > 1) {
             cout << "NO";
             return 0;
         }
         a = b;
     }
     cout << "YES";
     ```

【最优关键思路或技巧】  
1. **核心思路**：通过遍历数组，判断相邻元素的差值是否大于1，若存在则输出“NO”，否则输出“YES”。  
2. **优化技巧**：使用`abs`函数简化差值的计算，避免手动处理负数情况。  
3. **空间优化**：通过逐个读取输入并比较相邻元素的差值，节省了数组空间。

【可拓展之处】  
本题的核心思路可以应用于其他需要判断相邻元素关系的题目，例如判断数组是否单调递增或递减，或者判断数组中是否存在某种特定的相邻元素关系。

【推荐题目】  
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)  
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)  
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

---
处理用时：32.92秒
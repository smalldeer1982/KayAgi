# 题目信息

# Fight Against Traffic

## 题目描述

### 题意描述

给你一张无向图，一共有 $n$ 个点（$2 \leq n \leq 1000$），由 $m$ 条边连接起来（$1 \leq m <\leq 10000$），现在要在任意一对没有连边的点之间连上一条边,并且保证 $s$ 到 $t$ 之间的最短路径长度不变（最短路径长度表示 $s$ 到 $t$ 最少经过的边的数量）和图为简单图（无重边,无自环）（$1 \leq s,t \leq n$，$s \neq t$），请你求出一共有多少条这样的边。

## 样例 #1

### 输入

```
5 4 1 5
1 2
2 3
3 4
4 5
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 4 3 5
1 2
2 3
3 4
4 5
```

### 输出

```
5
```

## 样例 #3

### 输入

```
5 6 1 5
1 2
1 3
1 4
4 5
3 5
2 5
```

### 输出

```
3
```

# AI分析结果

### 题目重写
# 对抗交通

## 题目描述

### 题意描述

给你一张无向图，一共有 $n$ 个点（$2 \leq n \leq 1000$），由 $m$ 条边连接起来（$1 \leq m \leq 10000$），现在要在任意一对没有连边的点之间连上一条边，并且保证 $s$ 到 $t$ 之间的最短路径长度不变（最短路径长度表示 $s$ 到 $t$ 最少经过的边的数量）和图为简单图（无重边,无自环）（$1 \leq s,t \leq n$，$s \neq t$），请你求出一共有多少条这样的边。

## 样例 #1

### 输入

```
5 4 1 5
1 2
2 3
3 4
4 5
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 4 3 5
1 2
2 3
3 4
4 5
```

### 输出

```
5
```

## 样例 #3

### 输入

```
5 6 1 5
1 2
1 3
1 4
4 5
3 5
2 5
```

### 输出

```
3
```

### 算法分类
最短路

### 题解分析与结论
本题的核心思路是通过两次最短路算法（Dijkstra或BFS）预处理出从起点 $s$ 和终点 $t$ 到其他所有点的最短路径，然后枚举所有未连接的边，判断添加这条边后是否会影响 $s$ 到 $t$ 的最短路径长度。如果不会影响，则计数加一。

### 精选题解
1. **作者：Lips (赞：17)**
   - **星级：5**
   - **关键亮点：** 使用Dijkstra算法进行两次最短路计算，思路清晰，代码简洁，优化了初始答案的计算。
   - **个人心得：** 作者强调了初始答案设置为 $-m$ 的重要性，并通过详细的注释解释了代码的逻辑。

2. **作者：sysong (赞：4)**
   - **星级：4**
   - **关键亮点：** 使用BFS进行最短路计算，代码结构清晰，注释详细，适合初学者理解。
   - **个人心得：** 作者强调了BFS在边权为1的图中的适用性，并通过示例解释了判断条件。

3. **作者：KSToki (赞：4)**
   - **星级：4**
   - **关键亮点：** 使用Dijkstra算法进行两次最短路计算，代码简洁，逻辑清晰。
   - **个人心得：** 作者通过简单的判断条件展示了如何在不影响最短路的情况下计数。

### 核心代码片段
```cpp
void dijkstra(int s) {
    priority_queue<P, vector<P>, greater<P>> q;
    for (int i = 1; i <= n; i++) second_dist[i] = 1e9;
    second_dist[s] = 0;
    q.push(make_pair(0, s));
    while (!q.empty()) {
        P p = q.top(); q.pop();
        int v = p.second;
        if (second_dist[v] < p.first) continue;
        for (int i = 0; i < G[v].size(); i++) {
            edge e = G[v][i];
            if (second_dist[e.to] > second_dist[v] + e.cost) {
                second_dist[e.to] = second_dist[v] + e.cost;
                q.push(make_pair(second_dist[e.to], e.to));
            }
        }
    }
}
```

### 最优关键思路
通过两次最短路算法预处理出从 $s$ 和 $t$ 到其他所有点的最短路径，然后枚举所有未连接的边，判断添加这条边后是否会影响 $s$ 到 $t$ 的最短路径长度。如果不会影响，则计数加一。

### 拓展思路
类似的问题可以扩展到有向图或带权图中，通过类似的最短路算法预处理来判断添加边后是否会影响最短路径。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

---
处理用时：28.49秒
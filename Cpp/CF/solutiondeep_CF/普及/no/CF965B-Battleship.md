# 题目信息

# Battleship

## 题目描述

Arkady is playing Battleship. The rules of this game aren't really important.

There is a field of $ n \times n $ cells. There should be exactly one $ k $ -decker on the field, i. e. a ship that is $ k $ cells long oriented either horizontally or vertically. However, Arkady doesn't know where it is located. For each cell Arkady knows if it is definitely empty or can contain a part of the ship.

Consider all possible locations of the ship. Find such a cell that belongs to the maximum possible number of different locations of the ship.

## 说明/提示

The picture below shows the three possible locations of the ship that contain the cell $ (3, 2) $ in the first sample.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF965B/b7c4313703d490a5e475cf95767f647ad1140332.png)

## 样例 #1

### 输入

```
4 3
#..#
#.#.
....
.###
```

### 输出

```
3 2
```

## 样例 #2

### 输入

```
10 4
#....##...
.#...#....
..#..#..#.
...#.#....
.#..##.#..
.....#...#
...#.##...
.#...#.#..
.....#..#.
...#.#...#
```

### 输出

```
6 1
```

## 样例 #3

### 输入

```
19 6
##..............###
#......#####.....##
.....#########.....
....###########....
...#############...
..###############..
.#################.
.#################.
.#################.
.#################.
#####....##....####
####............###
####............###
#####...####...####
.#####..####..#####
...###........###..
....###########....
.........##........
#.................#
```

### 输出

```
1 8
```

# AI分析结果

### 题目内容重写
# Battleship

## 题目描述

Arkady 正在玩 Battleship 游戏。这个游戏的具体规则并不重要。

有一个 $n \times n$ 的单元格组成的场地。场地上应该恰好放置一个 $k$ 层的船，即一个长度为 $k$ 的船，可以是水平或垂直放置。然而，Arkady 并不知道船的具体位置。对于每个单元格，Arkady 知道它是否一定是空的，或者可能包含船的一部分。

考虑所有可能的船的位置。找到一个单元格，它属于尽可能多的不同船的位置。

## 说明/提示

下图展示了第一个样例中，单元格 $(3, 2)$ 属于三种不同的船的位置。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF965B/b7c4313703d490a5e475cf95767f647ad1140332.png)

## 样例 #1

### 输入

```
4 3
#..#
#.#.
....
.###
```

### 输出

```
3 2
```

## 样例 #2

### 输入

```
10 4
#....##...
.#...#....
..#..#..#.
...#.#....
.#..##.#..
.....#...#
...#.##...
.#...#.#..
.....#..#.
...#.#...#
```

### 输出

```
6 1
```

## 样例 #3

### 输入

```
19 6
##..............###
#......#####.....##
.....#########.....
....###########....
...#############...
..###############..
.#################.
.#################.
.#################.
.#################.
#####....##....####
####............###
####............###
#####...####...####
.#####..####..#####
...###........###..
....###########....
.........##........
#.................#
```

### 输出

```
1 8
```

### 算法分类
枚举

### 题解分析与结论
本题的核心思路是通过枚举所有可能的船的位置，统计每个单元格被船覆盖的次数，最终找到被覆盖次数最多的单元格。难点在于如何高效地枚举所有可能的船的位置，并避免重复计算。

### 评分较高的题解

#### 1. 作者：_Cloud_ (赞：5)
**星级：5**
**关键亮点：**
- 通过分别枚举横向和纵向的船的位置，确保所有可能的位置都被覆盖。
- 使用二维数组记录每个单元格被覆盖的次数，最后遍历找到最大值。
- 特判了 $n=1, k=1$ 的情况，避免输出无效坐标。

**核心代码：**
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j + k - 1 <= n; j++) {
        bool ok = true;
        for (int p = 0; p < k; p++) {
            if (s[i][p + j] == '#') { ok = false; break; }
        }
        if (ok) { for (int p = 0; p < k; p++) a[i][p + j]++; }
    }
}
```
**代码思想：** 枚举所有横向的船的位置，如果某段连续 $k$ 个单元格都是空的，则将这些单元格的覆盖次数加一。

#### 2. 作者：zgy_123 (赞：1)
**星级：4**
**关键亮点：**
- 采用在线处理的方式，逐个计算每个单元格的覆盖次数。
- 通过计算上下左右四个方向的连续空单元格数量，确定该单元格被覆盖的次数。
- 特判了 $k=1$ 的情况。

**核心代码：**
```cpp
int getmax(int dx, int dy, int x, int y) {
    int ans = 0, nx = x, ny = y;
    while (nx > 0 && ny > 0 && nx <= n && ny <= n && !a[nx][ny] && ans < k)
        nx += dx, ny += dy, ans++;
    return ans;
}
```
**代码思想：** 计算从某个单元格出发，沿某个方向连续空单元格的数量，用于确定该单元格被覆盖的次数。

#### 3. 作者：sinsop90 (赞：1)
**星级：4**
**关键亮点：**
- 通过枚举每个点，并只向右边和下面遍历，避免重复计算。
- 使用二维数组记录每个单元格被覆盖的次数，最后遍历找到最大值。

**核心代码：**
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (mps[i][j] != '#') {
            for (int k = 0; k <= 1; k++) {
                bool flag = true;
                int x = i, y = j;
                for (int l = 1; l <= m - 1; l++) {
                    x += fx[k][0];
                    y += fx[k][1];
                    if (mps[x][y] != '.' || x == 0 || y == 0 || x == n + 1 || y == n + 1) {
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    x = i;
                    y = j;
                    ans[x][y]++;
                    if (ans[x][y] > maxn) {
                        o = x;
                        p = y;
                        maxn = ans[x][y];
                    }
                    for (int l = 1; l <= m - 1; l++) {
                        x += fx[k][0];
                        y += fx[k][1];
                        ans[x][y]++;
                        if (ans[x][y] > maxn) {
                            o = x;
                            p = y;
                            maxn = ans[x][y];
                        }
                    }
                }
            }
        }
    }
}
```
**代码思想：** 枚举每个点，并只向右边和下面遍历，如果某段连续 $k$ 个单元格都是空的，则将这些单元格的覆盖次数加一。

### 最优关键思路
通过分别枚举横向和纵向的船的位置，确保所有可能的位置都被覆盖，并使用二维数组记录每个单元格被覆盖的次数，最后遍历找到最大值。这种方法既简单又高效，适用于类似的问题。

### 可拓展之处
类似的问题可以扩展到更高维度的空间，或者更复杂的船的形状。此外，可以考虑使用前缀和或动态规划来优化计算过程。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 个人心得
在枚举过程中，特判一些特殊情况（如 $n=1, k=1$）是非常重要的，可以避免程序在边界条件下出错。此外，通过分别处理横向和纵向的船的位置，可以简化代码逻辑，提高代码的可读性和效率。

---
处理用时：46.80秒
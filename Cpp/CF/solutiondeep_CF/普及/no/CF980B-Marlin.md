# 题目信息

# Marlin

## 题目描述

鱼托邦市可以想象成一个4行且每行包含n个奇数的网格。



它有两个主要的村庄：第一个位于左上方的方格（1，1），住在那里的人喜欢在右下方的方格（4，n）的金枪鱼池塘钓鱼。第二个村庄位于（4，1），人们喜欢（1，n）的鲑鱼池塘。



鱼托邦市市市长想在该市设立k家酒店，每家都占据一个方格。为了让人们可以从任何地方进入城市，酒店不应设在边缘。



如果两个方格均没有被旅馆占据并共用一条边，一个人可以从一个方格移动到另一个方格。



你能帮助市长把旅馆安置在一个地方，使得每个村子的人都有相同数量的最短路径到他们的首选池塘吗？

## 样例 #1

### 输入

```
7 2
```

### 输出

```
YES
.......
.#.....
.#.....
.......
```

## 样例 #2

### 输入

```
5 3
```

### 输出

```
YES
.....
.###.
.....
.....
```

# AI分析结果

### 题目重写
鱼托邦市可以想象成一个4行且每行包含n个奇数的网格。它有两个主要的村庄：第一个位于左上方的方格（1，1），住在那里的人喜欢在右下方的方格（4，n）的金枪鱼池塘钓鱼。第二个村庄位于（4，1），人们喜欢（1，n）的鲑鱼池塘。鱼托邦市市长想在该市设立k家酒店，每家都占据一个方格。为了让人们可以从任何地方进入城市，酒店不应设在边缘。如果两个方格均没有被旅馆占据并共用一条边，一个人可以从一个方格移动到另一个方格。你能帮助市长把旅馆安置在一个地方，使得每个村子的人都有相同数量的最短路径到他们的首选池塘吗？

### 算法分类
构造

### 题解分析与结论
两位作者的题解都采用了构造的思路，通过对称性来保证两个村庄的最短路径数量相等。Larry76的题解通过分类讨论k的奇偶性，分别构造不同的对称矩阵，思路清晰但代码略显复杂。流绪的题解则通过直接构造矩形，并在奇数情况下从中间挖掉一个障碍物，代码简洁且易于理解。

### 所选题解
#### 作者：流绪 (赞：0)
- **星级**：4星
- **关键亮点**：直接构造矩形，并在奇数情况下从中间挖掉一个障碍物，代码简洁且易于理解。
- **个人心得**：观察样例，发现障碍物为偶数个时，只要把他们放在一起，构造成一个宽度两行的矩形即可。奇数个时，看做有 $k-1+1$ 个障碍物，即先构造一个 $k+1$ 的上述矩形然后从中间挖掉一个。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ld long double
#define inf 0x7f7f7f7f7f7f7f7f
#define maxn 1000010
#define ri register int
#define il inline
#define mk make_pair
#define pb push_back
#define fi first
#define se second
#define mod 998244353
#define db(x) cout << x << endl; 
#define eps 0.0001
using namespace std;
signed main()
{
	ios::sync_with_stdio(0);
	int n,k;
	cin >> n >> k;
	cout << "YES\n";
	for(int i=1;i<=n;i++)
		cout << ".";
	if(k%2==0)
	{
		cout << endl << ".";
		for(int i=2;i<2+k/2;i++)
			cout << "#";
		for(int i=2+k/2;i<=n;i++)
			cout << ".";
		cout << "\n.";
		for(int i=2;i<2+k/2;i++)
			cout << "#";
		for(int i=2+k/2;i<=n;i++)
			cout << ".";
		cout << endl;
	}
	else
	{
		cout << endl;
		char a[2][100];
		memset(a,'.',sizeof(a));
		int pos = n/2+1;
		a[0][pos] = '#';
		for(int i=1;i<=pos-2&&k>1;i++)
			a[0][pos-i] = a[0][pos+i] = '#',k-=2; 
		for(int i=1;i<=pos-2&&k>1;i++)
			a[1][pos-i] = a[1][pos+i] = '#',k-=2; 
		for(int i=0;i<=1;i++)
		{
			for(int j=1;j<=n;j++)
				cout << a[i][j];
			cout <<endl;
		}
	}
	for(int i=1;i<=n;i++)
		cout << ".";
	return 0;
}
```

### 最优关键思路
通过对称性构造障碍物的分布，确保两个村庄的最短路径数量相等。偶数情况下直接构造矩形，奇数情况下从中间挖掉一个障碍物。

### 可拓展之处
类似的问题可以通过对称性来简化构造过程，例如在网格中放置障碍物以控制路径数量或路径长度。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

---
处理用时：27.18秒
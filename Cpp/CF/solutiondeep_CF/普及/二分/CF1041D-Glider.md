# 题目信息

# Glider

## 题目描述

```
你在玩一个吃鸡游戏，你现在要跳伞。你的飞机现在在高度为$h$的空中飞行，你每飞一个单位长度的距离，你就会下落一个单位长度的高度，当然，有些地方是上升气流，你不会下落，你会往前直飞，由于你想在空中就被人打死，求你最远的飞行距离

## 样例 #1

### 输入

```
3 4
2 5
7 9
10 11
```

### 输出

```
10
```

## 样例 #2

### 输入

```
5 10
5 7
11 12
16 20
25 26
30 33
```

### 输出

```
18
```

## 样例 #3

### 输入

```
1 1000000000
1 1000000000
```

### 输出

```
1999999999
```

# AI分析结果

### 题目内容重写
你在玩一个吃鸡游戏，你现在要跳伞。你的飞机现在在高度为$h$的空中飞行，你每飞一个单位长度的距离，你就会下落一个单位长度的高度，当然，有些地方是上升气流，你不会下落，你会往前直飞，由于你想在空中就被人打死，求你最远的飞行距离。

### 样例 #1
#### 输入
```
3 4
2 5
7 9
10 11
```
#### 输出
```
10
```

### 样例 #2
#### 输入
```
5 10
5 7
11 12
16 20
25 26
30 33
```
#### 输出
```
18
```

### 样例 #3
#### 输入
```
1 1000000000
1 1000000000
```
#### 输出
```
1999999999
```

### 题解分析与结论
1. **关键思路**：所有题解都指出，最优解一定是从某个上升气流区间的左端点起跳。这是因为从这些点起跳可以最大化利用上升气流，减少高度下降。
2. **算法要点**：
   - **前缀和**：用于快速计算两个区间之间的下降距离。
   - **二分查找**：用于快速找到飞行员触地的位置。
   - **双指针**：用于在O(n)时间复杂度内找到最优解。
3. **解决难点**：如何高效地找到从每个区间左端点起跳的最远飞行距离。通过前缀和和二分查找的结合，可以在O(n log n)时间内解决。

### 所选高星题解
#### 题解1：ezoixx130 (5星)
- **关键亮点**：使用前缀和和二分查找，思路清晰，代码简洁。
- **代码核心思想**：预处理每个区间之间的下降距离前缀和，对于每个区间，二分查找触地位置，计算飞行距离并更新最大值。
```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 200010
int n,h,ans,l[MAXN],r[MAXN],d[MAXN];

int main()
{
    scanf("%d%d",&n,&h);
    for(int i=1;i<=n;++i)scanf("%d%d",l+i,r+i),d[i]=d[i-1]+l[i]-r[i-1];
    for(int i=1;i<=n;++i)
    {
        int id=lower_bound(d+i+1,d+n+1,h+d[i])-d-1;
        ans=max(ans,r[id]-l[i]+h-d[id]+d[i]);
    }
    printf("%d\n",ans);
}
```

#### 题解2：Bobi2014 (4星)
- **关键亮点**：详细解释了二分和前缀和的应用，适合初学者理解。
- **代码核心思想**：通过前缀和优化，枚举每个区间的左端点，二分查找触地位置，计算飞行距离。
```cpp
#include<iostream>
using namespace std;
long long n,h,s,l[1145141],r[1145141],d[1145141];
int main(){
    cin>>n>>h;
    for(long long i=1;i<=n;i++){
    	cin>>l[i]>>r[i];
		d[i]=d[i-1]+l[i]-r[i-1];	
	}
    for(long long i=1;i<=n;i++){
        long long x=lower_bound(d+i+1,d+n+1,h+d[i])-d-1,y=r[x]-l[i]+h-d[x]+d[i];
        s=max(s,y);
    }
    cout<<s;
}
```

#### 题解3：Disjoint_cat (4星)
- **关键亮点**：使用双指针优化，时间复杂度降低到O(n)，适合大数据量。
- **代码核心思想**：通过双指针维护当前高度和区间，逐步更新最远飞行距离。
```cpp
const int N=200005;
int n,h,l[N],r[N];
void Solve(int CASE)
{
	cin>>n>>h;
	for(int i=1;i<=n;i++)cin>>l[i]>>r[i];
	l[n+1]=r[n+1]=INT_MAX;
	int ans=0;
	for(int i=1,j=1,k=h;i<=n;i++)
	{//i 是左指针，j 是右指针，k 是当前高度
		if(i>1)k+=l[i]-r[i-1];
		while(k>l[j+1]-r[j])k-=l[j+1]-r[j],j++;
		ans=max(ans,r[j]-l[i]+k);
	}
	cout<<ans;
}
```

### 最优关键思路
- **前缀和与二分查找结合**：通过前缀和快速计算区间之间的下降距离，结合二分查找快速定位触地位置，时间复杂度为O(n log n)。
- **双指针优化**：通过双指针维护当前高度和区间，逐步更新最远飞行距离，时间复杂度降低到O(n)。

### 可拓展之处
- **类似问题**：可以扩展到其他需要计算区间最优解的问题，如最大子数组和、区间覆盖等。
- **算法套路**：前缀和、二分查找、双指针是解决区间问题的常见套路，可以举一反三。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

---
处理用时：43.06秒
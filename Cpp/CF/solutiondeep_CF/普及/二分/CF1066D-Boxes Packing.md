# 题目信息

# Boxes Packing

## 题目描述

有 $n$ 个物品，$m$ 个盒子。其中第 $i$ 个物品的大小为 $a_i$，所有盒子的大小均为 $k$。Makmis 先生想要将这些物品放入盒子中。对于每个物品，如果可以放入当前盒子中则放入当前盒子，否则换一个新的盒子放入。如果物品数量太多使得盒子装不下，可以**将先放入的物品丢弃**。求出最多能够放入多少物品。

## 说明/提示

#### 样例解释
- 在第一组样例中，可以将后 $4$ 个放入盒子。
- 在第二组样例中仅有一个盒子，故只能放入最后一个。
- 在第三组样例中有 $3$ 个大小为 $3$ 的盒子，每个盒子正好装满。
#### 数据规模与约定
保证 $1\le n,m\le2\times 10^5$，$1\le k\le10^9$，$1\le a_i\le k$。

## 样例 #1

### 输入

```
5 2 6
5 2 1 4 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 1 4
4 2 3 4 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5 3 3
1 2 3 1 1
```

### 输出

```
5
```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $n$ 个物品，$m$ 个盒子。其中第 $i$ 个物品的大小为 $a_i$，所有盒子的大小均为 $k$。Makmis 先生想要将这些物品放入盒子中。对于每个物品，如果可以放入当前盒子中则放入当前盒子，否则换一个新的盒子放入。如果物品数量太多使得盒子装不下，可以**将先放入的物品丢弃**。求出最多能够放入多少物品。

#### 说明/提示

- 在第一组样例中，可以将后 $4$ 个放入盒子。
- 在第二组样例中仅有一个盒子，故只能放入最后一个。
- 在第三组样例中有 $3$ 个大小为 $3$ 的盒子，每个盒子正好装满。

#### 数据规模与约定

保证 $1\le n,m\le2\times 10^5$，$1\le k\le10^9$，$1\le a_i\le k$。

### 题解综合分析与结论

本题的核心问题是如何在给定的物品和盒子限制下，最大化放入盒子的物品数量。由于物品的放入顺序和盒子的使用顺序对结果有直接影响，因此需要找到一种高效的策略来解决这个问题。

#### 关键思路与技巧

1. **从右向左贪心**：由于题目允许丢弃先放入的物品，因此从右向左遍历物品可以最大化利用盒子的容量。这种策略避免了物品堆积在盒子前端的问题，确保每个盒子尽可能装满。
2. **二分答案**：通过二分查找确定可以放入盒子的最大物品数量。每次检查时，从某个位置开始模拟放入物品的过程，判断是否满足盒子数量的限制。
3. **线性模拟**：直接从右向左模拟放入物品的过程，使用一个变量记录当前盒子的剩余容量，当容量不足时开启新盒子。这种方法的时间复杂度为 $O(n)$，适合大规模数据。

#### 评分较高的题解

1. **作者：StudyingFather (赞：6)**  
   - **星级**：★★★★★  
   - **关键亮点**：从右向左直接模拟放入物品的过程，思路清晰，代码简洁，时间复杂度为 $O(n)$，适合大规模数据。  
   - **代码核心思想**：从右向左遍历物品，使用一个变量记录当前盒子的剩余容量，当容量不足时开启新盒子。  
   ```cpp
   int rem=m,used=0;
   for(int i=1;i<=n;i++) {
       if(used+a[i]>k) {
           rem--,used=a[i];
           if(rem==0) {
               printf("%d\n",i-1);
               return 0;
           }
       } else used+=a[i];
   }
   printf("%d\n",n);
   ```

2. **作者：fls233666 (赞：5)**  
   - **星级**：★★★★☆  
   - **关键亮点**：使用二分答案结合贪心策略，通过二分查找确定可以放入盒子的最大物品数量，时间复杂度为 $O(n \log n)$。  
   - **代码核心思想**：二分查找最大物品数量，每次检查时从某个位置开始模拟放入物品的过程，判断是否满足盒子数量的限制。  
   ```cpp
   bool check(int x) {
       int cnt=1,v=0;
       for(int i=x;i<=n;i++) {
           if(v+a[i]>k) {
               cnt++;
               v=a[i];
           } else v+=a[i];
       }
       return cnt<=m;
   }
   ```

3. **作者：Xdl_rp (赞：1)**  
   - **星级**：★★★★☆  
   - **关键亮点**：从右向左贪心模拟放入物品的过程，思路简单直接，代码易于理解，时间复杂度为 $O(n)$。  
   - **代码核心思想**：从右向左遍历物品，使用一个变量记录当前盒子的剩余容量，当容量不足时开启新盒子。  
   ```cpp
   int x=0;
   for(int i=n;i>=1;i--) {
       if(x+a[i]<=k) x+=a[i];
       else {
           m--,x=a[i];
           if(m==0) {
               cout<<n-i;
               return 0;
           }
       }
   }
   cout<<n;
   ```

### 推荐题目

1. **P1066 装箱问题**：考察如何在给定容量的箱子中装入尽可能多的物品，类似于本题的贪心策略。
2. **P1049 装箱问题**：经典的装箱问题，要求用最少的箱子装入所有物品，与本题的盒子使用策略相关。
3. **P1056 装箱问题**：涉及多个箱子的装箱问题，要求优化装箱顺序和策略，与本题的贪心思路相似。

---
处理用时：37.67秒
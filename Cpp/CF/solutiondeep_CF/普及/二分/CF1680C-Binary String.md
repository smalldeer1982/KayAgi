# 题目信息

# Binary String

## 题目描述

你有一个由 $1$ 和 $0$ 构成的字符串 $s$。

你需要先从 $s$ 的开头移除若干字符，然后从 $s$ 的结尾移除若干字符。（当然，你可以不移除任何字符，也可以将整个 $s$ 移除掉）

这样做的代价是从 $s$ 中移除的 $1$ 的个数和 $s$ 中剩余的 $0$ 的个数的最大值。

求代价的最小值。

## 说明/提示

样例解释：

`101110110` -> `(10) 111011 (0)`

`1001001001001` -> `(100100) 1001 (001)`

`0000111111` -> `(0000) 111111 ()`

`00000` -> `(00000)()`

`1111` -> `()1111()`

## 样例 #1

### 输入

```
5
101110110
1001001001001
0000111111
00000
1111```

### 输出

```
1
3
0
0
0```

# AI分析结果

【题目内容】
# 二进制字符串

## 题目描述

你有一个由 $1$ 和 $0$ 构成的字符串 $s$。

你需要先从 $s$ 的开头移除若干字符，然后从 $s$ 的结尾移除若干字符。（当然，你可以不移除任何字符，也可以将整个 $s$ 移除掉）

这样做的代价是从 $s$ 中移除的 $1$ 的个数和 $s$ 中剩余的 $0$ 的个数的最大值。

求代价的最小值。

## 说明/提示

样例解释：

`101110110` -> `(10) 111011 (0)`

`1001001001001` -> `(100100) 1001 (001)`

`0000111111` -> `(0000) 111111 ()`

`00000` -> `(00000)()`

`1111` -> `()1111()`

## 样例 #1

### 输入

```
5
101110110
1001001001001
0000111111
00000
1111```

### 输出

```
1
3
0
0
0```

【题解分析与结论】
本题的核心在于如何通过删除字符串的开头和结尾部分，使得删除的 $1$ 的数量和剩余的 $0$ 的数量的最大值最小化。多个题解提供了不同的思路，主要包括线性扫描、二分法、滑动窗口等。最优的解法通常利用前缀和和后缀和来快速计算删除和保留的字符数量，并通过枚举或二分法找到最小代价。

【精选题解】
1. **作者：断清秋 (5星)**
   - **关键亮点**：通过预处理前缀和后缀的 $0$ 的数量，线性枚举开头删除的字符数，$O(1)$ 计算结尾的贡献，时间复杂度为 $O(n)$。
   - **代码实现**：
     ```cpp
     // 预处理前缀和后缀的0的数量
     for (int i = 0; i < n; i++) {
         prefix0[i+1] = prefix0[i] + (s[i] == '0');
         suffix0[i+1] = suffix0[i] + (s[n-i-1] == '0');
     }
     // 枚举开头删除的字符数
     for (int i = 0; i <= n; i++) {
         int deleted1 = prefix1[i] + suffix1[n - (cnt0 - prefix0[i])];
         int remaining0 = cnt0 - prefix0[i] - suffix0[n - (cnt0 - prefix0[i])];
         ans = min(ans, max(deleted1, remaining0));
     }
     ```

2. **作者：灵茶山艾府 (4星)**
   - **关键亮点**：利用滑动窗口维护窗口内的 $0$ 的数量，窗口外的 $1$ 的数量，通过二分法找到最小代价，时间复杂度为 $O(n \log n)$。
   - **代码实现**：
     ```go
     func main() {
         in := bufio.NewReader(os.Stdin)
         var T int
         var s string
         for Fscan(in, &T); T > 0; T-- {
             Fscan(in, &s)
             tot1 := strings.Count(s, "1")
             Println(sort.Search(len(s), func(mx int) bool {
                 in0 := 0
                 out1 := tot1
                 left := 0
                 for _, b := range s {
                     v := int(b & 1)
                     in0 += v ^ 1
                     out1 -= v
                     for in0 > mx {
                         v = int(s[left] & 1)
                         in0 -= v ^ 1
                         out1 += v
                         left++
                     }
                     if out1 <= mx {
                         return true
                     }
                 }
                 return false
             }))
         }
     }
     ```

3. **作者：Luciylove (4星)**
   - **关键亮点**：通过枚举前缀删除的字符数，利用前缀和后缀和快速计算删除的 $1$ 和剩余的 $0$ 的数量，时间复杂度为 $O(n)$。
   - **代码实现**：
     ```cpp
     for (int i = 0; i <= cnt0; i++) {
         int tmp = l - (cnt0 - i);
         int maxn = o[i] + o[l] - o[tmp];
         ans = min(ans, maxn);
     }
     ```

【最优关键思路】
利用前缀和和后缀和预处理字符串中的 $0$ 和 $1$ 的数量，通过枚举或二分法快速计算删除和保留的字符数量，找到最小代价。

【拓展与举一反三】
类似的问题可以通过前缀和、滑动窗口、二分法等技巧来解决。例如，寻找满足某些条件的最小子串或区间。

【推荐题目】
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

【个人心得】
在调试过程中，发现边界条件的处理非常重要，特别是在全 $0$ 或全 $1$ 的情况下，需要特别注意特判。

---
处理用时：38.96秒
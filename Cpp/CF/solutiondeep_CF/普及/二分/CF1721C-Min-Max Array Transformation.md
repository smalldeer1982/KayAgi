# 题目信息

# Min-Max Array Transformation

## 题目描述

给你一个升序数组 $a_1,a_2,...,a_n$。你要通过以下步骤去得到数组 $b_1,b_2,...,b_n$ ：

1. 生成数组 $d$，由$n$个非负整数组成。
2. 通过 $b_i=a_i+d_i$ 计算每一个 $b_i$。
3. 给 $b$ 进行升序排序。

你现在又知道了结果 $b$，你要算出每一个 $d_i$ 可能的最小值和最大值（每个 $d_i$ 的最值可以是由不同的数组 $d$ 满足的）。

## 说明/提示

第一个样例中，$d=[5,10,6]$ 满足 $d_1^{min}=5,b=[2+5,3+10,5+6]=[7,13,11]=[7,11,13]$。

第一个样例中，$d=[9,4,8]$ 满足 $d_2^{min}=4,b=[2+9,3+4,5+8]=[11,7,13]=[7,11,13]$。

## 样例 #1

### 输入

```
4
3
2 3 5
7 11 13
1
1000
5000
4
1 2 3 4
1 2 3 4
4
10 20 30 40
22 33 33 55```

### 输出

```
5 4 2
11 10 8
4000
4000
0 0 0 0
0 0 0 0
12 2 3 15
23 13 3 15```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

给你一个升序数组 $a_1,a_2,...,a_n$。你要通过以下步骤去得到数组 $b_1,b_2,...,b_n$ ：

1. 生成数组 $d$，由$n$个非负整数组成。
2. 通过 $b_i=a_i+d_i$ 计算每一个 $b_i$。
3. 给 $b$ 进行升序排序。

你现在又知道了结果 $b$，你要算出每一个 $d_i$ 可能的最小值和最大值（每个 $d_i$ 的最值可以是由不同的数组 $d$ 满足的）。

#### 说明/提示

第一个样例中，$d=[5,10,6]$ 满足 $d_1^{min}=5,b=[2+5,3+10,5+6]=[7,13,11]=[7,11,13]$。

第一个样例中，$d=[9,4,8]$ 满足 $d_2^{min}=4,b=[2+9,3+4,5+8]=[11,7,13]=[7,11,13]$。

#### 样例 #1

##### 输入

```
4
3
2 3 5
7 11 13
1
1000
5000
4
1 2 3 4
1 2 3 4
4
10 20 30 40
22 33 33 55```

##### 输出

```
5 4 2
11 10 8
4000
4000
0 0 0 0
0 0 0 0
12 2 3 15
23 13 3 15```

### 题解综合分析与结论

本题的核心在于如何通过给定的升序数组 $a$ 和 $b$，计算出每个 $d_i$ 的最小值和最大值。难点在于如何高效地找到每个 $a_i$ 对应的 $b_j$，使得 $d_i$ 最小或最大。

#### 关键思路与技巧

1. **最小值的计算**：对于每个 $a_i$，找到 $b$ 中大于等于 $a_i$ 的最小值，即 $b_j$，然后 $d_i^{min} = b_j - a_i$。可以使用 `lower_bound` 或二分查找来高效实现。
2. **最大值的计算**：对于每个 $a_i$，找到 $b$ 中最大的 $b_j$，使得 $a_i$ 到 $a_j$ 之间的元素都能匹配到 $b$ 中的某个元素。可以通过倒序遍历 $a$ 和 $b$，利用贪心思想来找到最大的 $b_j$。

#### 最优题解推荐

1. **作者：xfrvq (赞：14)**  
   - **星级：5星**  
   - **关键亮点**：简洁高效，使用 `set` 和 `lower_bound` 实现最小值和最大值的计算，代码清晰易懂。  
   - **核心代码**：
     ```cpp
     for(int i = 1;i <= n;++i)
         printf("%d ",*lower_bound(b + 1,b + n + 1,a[i]) - a[i]);
     for(int i = n;i >= 1;--i){
         d[i] = *prev(s.end());
         s.erase(s.lower_bound(a[i]));
     }
     ```

2. **作者：Alex_Wei (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：通过预处理 `lst` 数组来优化最大值的计算，时间复杂度为 $O(n)$，思路清晰。  
   - **核心代码**：
     ```cpp
     for(int i = n; i > 1; --i) {
         if(a[i] <= b[i - 1]) lst[i] = lst[i + 1];
         else lst[i] = i;
     }
     for(int i = 1; i <= n; ++i) cout << b[lst[i + 1] - 1] - a[i] << " ";
     ```

3. **作者：Charles_Fan (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：通过双指针优化最大值的计算，代码简洁，时间复杂度为 $O(n)$。  
   - **核心代码**：
     ```cpp
     for(int i = 0, j = 0; i < n; ++i) {
         while(b[j] < a[i]) ++j;
         printf("%d ", b[j] - a[i]);
     }
     for(int i = 0, j = 0; i < n; ++i) {
         if(j < i) j = i;
         while(j < n - 1 && a[j + 1] <= b[j]) ++j;
         printf("%d ", b[j] - a[i]);
     }
     ```

### 拓展思路与推荐题目

1. **拓展思路**：本题的解法可以推广到类似的匹配问题，如给定两个数组，要求找到一种匹配方式使得某种条件最小或最大。常见的优化手段包括二分查找、双指针、贪心算法等。
2. **推荐题目**：
   - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：考察贪心算法和排序。
   - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察优先队列和贪心算法。
   - [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：考察二分查找和数据结构的使用。

---
处理用时：46.20秒
# 题目信息

# Find the Different Ones!

## 题目描述

给定一个长度为 $n$ 的序列 $\{a\}$ 和 $q$ 次询问。每次询问给定 $l,r$，求在区间 $[l,r]$ 里是否存在满足 $l \le i,j \le r~,~a_i \ne a_j$ 的 $i,j$，如果存在则求出任意一种可能的情况。

## 说明/提示

对于所有测试点，满足 $1\le t\le10^4$，$2\le n\le2\times10^5$，$1 \le a_i \le 10^6$，$1 \le q \le 2\times10^5$，$1 \le l < r \le n$，单测试点所有测试数据中 $n$ 的和不超过 $2\times10^5$，所有 $q$ 的和也不超过 $2\times10^5$。

## 样例 #1

### 输入

```
5
5
1 1 2 1 1
3
1 5
1 2
1 3
6
30 20 20 10 10 20
5
1 2
2 3
2 4
2 6
3 5
4
5 2 3 4
4
1 2
1 4
2 3
2 4
5
1 4 3 2 4
5
1 5
2 4
3 4
3 5
4 5
5
2 3 1 4 2
7
1 2
1 4
1 5
2 4
2 5
3 5
4 5```

### 输出

```
2 3
-1 -1
1 3

2 1
-1 -1
4 2
4 6
5 3

1 2
1 2
2 3
3 2

1 3
2 4
3 4
5 3
5 4

1 2
4 2
1 3
2 3
3 2
5 4
5 4```

# AI分析结果

### 题目内容重写
# 找出不同的元素！

## 题目描述

给定一个长度为 $n$ 的序列 $\{a\}$ 和 $q$ 次询问。每次询问给定 $l,r$，求在区间 $[l,r]$ 里是否存在满足 $l \le i,j \le r~,~a_i \ne a_j$ 的 $i,j$，如果存在则求出任意一种可能的情况。

## 说明/提示

对于所有测试点，满足 $1\le t\le10^4$，$2\le n\le2\times10^5$，$1 \le a_i \le 10^6$，$1 \le q \le 2\times10^5$，$1 \le l < r \le n$，单测试点所有测试数据中 $n$ 的和不超过 $2\times10^5$，所有 $q$ 的和也不超过 $2\times10^5$。

## 样例 #1

### 输入

```
5
5
1 1 2 1 1
3
1 5
1 2
1 3
6
30 20 20 10 10 20
5
1 2
2 3
2 4
2 6
3 5
4
5 2 3 4
4
1 2
1 4
2 3
2 4
5
1 4 3 2 4
5
1 5
2 4
3 4
3 5
4 5
5
2 3 1 4 2
7
1 2
1 4
1 5
2 4
2 5
3 5
4 5```

### 输出

```
2 3
-1 -1
1 3

2 1
-1 -1
4 2
4 6
5 3

1 2
1 2
2 3
3 2

1 3
2 4
3 4
5 3
5 4

1 2
4 2
1 3
2 3
3 2
5 4
5 4```

### 综合分析与结论

本题的核心问题是在给定的区间内找到两个不同的元素，并输出它们的下标。由于数据规模较大，需要高效的算法来处理多次查询。以下是各题解的主要思路和难点对比：

1. **预处理法**：通过预处理，记录每个元素的下一个不同元素的位置，查询时直接判断该位置是否在区间内。时间复杂度为 $O(n + q)$，适合大规模数据。
2. **分块法**：将序列分块，预处理每个块的答案，查询时结合块内和块间的信息。时间复杂度较高，但实现简单，适合练习分块算法。
3. **二分法**：通过记录相邻不同元素的位置，利用二分查找来判断区间内是否存在不同元素。时间复杂度为 $O(n \log n + q \log n)$，适合中等规模数据。
4. **线段树/ST表**：利用线段树或ST表维护区间内的最大值和最小值，判断是否相等。时间复杂度为 $O(n \log n + q)$，适合需要维护区间信息的场景。

### 评分较高的题解

1. **作者：atomic_int (赞：12)**
   - **星级**：5星
   - **关键亮点**：通过预处理记录每个元素的下一个不同元素的位置，查询时直接判断该位置是否在区间内，时间复杂度为 $O(n + q)$，非常高效。
   - **代码核心思想**：
     ```cpp
     vector<int> ano(n + 1);
     for (int l = 1, r = 2; l <= n; r++) {
         while (a[r] != a[l]) {
             ano[l] = r, l++;
         }
     }
     ```
   - **个人心得**：该方法通过双指针预处理，思路清晰，代码简洁，适合大规模数据处理。

2. **作者：PikachuQAQ (赞：5)**
   - **星级**：4星
   - **关键亮点**：利用二分查找相邻不同元素的位置，时间复杂度为 $O(n \log n + q \log n)$，适合中等规模数据。
   - **代码核心思想**：
     ```cpp
     int ll = upper_bound(b + 1, b + tot + 1, l) - b;
     int rr = upper_bound(b + 1, b + tot + 1, r) - b;
     if (ll == rr) {
         cout << "-1 -1\n";
     } else {
         cout << l << ' ' << b[ll] << '\n';
     }
     ```
   - **个人心得**：该方法通过二分查找，思路清晰，代码可读性强，适合练习二分算法。

3. **作者：2huk (赞：1)**
   - **星级**：4星
   - **关键亮点**：利用ST表维护区间内的最大值和最小值，判断是否相等，时间复杂度为 $O(n \log n + q)$，适合需要维护区间信息的场景。
   - **代码核心思想**：
     ```cpp
     int x = A.query(l, r), y = B.query(l, r);
     if (a[x] == a[y]) {
         puts("-1 -1");
     } else {
         printf("%d %d\n", x, y);
     }
     ```
   - **个人心得**：该方法通过ST表维护区间信息，思路清晰，代码简洁，适合需要维护区间信息的场景。

### 最优关键思路或技巧

- **预处理法**：通过预处理记录每个元素的下一个不同元素的位置，查询时直接判断该位置是否在区间内，时间复杂度为 $O(n + q)$，非常高效。
- **二分法**：通过记录相邻不同元素的位置，利用二分查找来判断区间内是否存在不同元素，时间复杂度为 $O(n \log n + q \log n)$，适合中等规模数据。
- **ST表/线段树**：利用ST表或线段树维护区间内的最大值和最小值，判断是否相等，时间复杂度为 $O(n \log n + q)$，适合需要维护区间信息的场景。

### 可拓展之处

- **同类型题**：类似的问题可以扩展到多维区间查询，或者需要维护更多区间信息的场景。
- **类似算法套路**：预处理法、二分法、分块法、线段树/ST表等算法套路在处理区间查询问题时非常常见，可以举一反三。

### 推荐题目

1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

---
处理用时：52.61秒
# 题目信息

# Maximize the Root

## 题目描述

给你一棵有根的树，由 $n$ 个顶点组成。树上的顶点从 $1$到 $n$ 编号，根是顶点 $1$ 。第 $i$ 个顶点上的值为 $a_i$。

你可以执行以下操作任意次(可以为零次):选择一个至少有一个子顶点的顶点 $v$; 将 $a_v$ 增加 $1$ 并且对于 $v$ 的子树中的所有顶点 $u$ 将 $a_u$ 减少 $1$ (除了 $v$ 本身)。但是，在每次操作之后，所有顶点上的值都应该是非负的。

你的任务是使用前面提到的运算来计算写在根上的最大可能值。

## 样例 #1

### 输入

```
3
4
0 1 0 2
1 1 3
2
3 0
1
5
2 5 3 9 6
3 1 5 2```

### 输出

```
1
3
6```

# AI分析结果

### 题目内容重写
# 最大化根节点的值

## 题目描述

给你一棵有根的树，由 $n$ 个顶点组成。树上的顶点从 $1$ 到 $n$ 编号，根是顶点 $1$。第 $i$ 个顶点上的值为 $a_i$。

你可以执行以下操作任意次（可以为零次）：选择一个至少有一个子顶点的顶点 $v$；将 $a_v$ 增加 $1$，并且对于 $v$ 的子树中的所有顶点 $u$ 将 $a_u$ 减少 $1$（除了 $v$ 本身）。但是，在每次操作之后，所有顶点上的值都应该是非负的。

你的任务是使用前面提到的运算来计算写在根上的最大可能值。

## 样例 #1

### 输入

```
3
4
0 1 0 2
1 1 3
2
3 0
1
5
2 5 3 9 6
3 1 5 2```

### 输出

```
1
3
6```

### 题解分析与结论

各题解的核心思路是通过递归或拓扑排序来计算每个节点的子树中的最小值，并根据该最小值调整节点的值，最终使得根节点的值最大化。难点在于如何高效地计算子树的最小值，并确保操作后所有节点的值保持非负。

### 所选高星题解

#### 题解1：作者：Muse_Dash (赞：8)
- **星级**：★★★★★
- **关键亮点**：通过DFS递归计算每个节点的子树最小值，并根据最小值调整节点值，思路清晰，代码简洁。
- **核心代码**：
```cpp
void dfs(int u,int fa){
    mn[u]=1e18;
    for (auto v:e[u]){
        if (v==fa) continue;
        dfs(v,u);
        mn[u]=min(mn[v],mn[u]);
    }
    if (mn[u]==1e18) mn[u]=a[u];
    if (mn[u]>a[u]&&u!=1) mn[u]=(mn[u]+a[u])/2;
}
```
- **实现思想**：通过DFS遍历每个节点，计算其子树的最小值，并根据最小值调整节点值，确保操作后所有节点的值保持非负。

#### 题解2：作者：ICU152_lowa_IS8 (赞：5)
- **星级**：★★★★
- **关键亮点**：使用拓扑排序进行树的遍历，确保每个节点的子树最小值计算正确，代码结构清晰。
- **核心代码**：
```cpp
void tupo(){
    while(!q.empty()){
        int t=q.front();
        q.pop();
        if(t==1)continue;
        for(int i=head[t];i;i=edge[i].next){
            int v=edge[i].v;
            if(dis[t]>=a[v]){
                if(v==1){
                    dis[v]=min(dis[v],dis[t]);
                }
                else
                dis[v]=min(dis[v],(dis[t]+a[v])/2);
            }
            else{
                if(v==1){
                    dis[v]=min(dis[v],dis[t]);
                }
                else
                dis[v]=min(dis[v],min(dis[t],a[v]));
            }
            in[v]--;
            if(!in[v])q.push(v);
        }
    }
}
```
- **实现思想**：通过拓扑排序遍历树，计算每个节点的子树最小值，并根据最小值调整节点值，确保操作后所有节点的值保持非负。

#### 题解3：作者：SamHJD (赞：4)
- **星级**：★★★★
- **关键亮点**：通过递归计算每个节点的子树最小值，并根据最小值调整节点值，代码简洁，思路清晰。
- **核心代码**：
```cpp
int dfs(int u){
    if(!g[u].size()) return a[u];
    int mn=0x3f3f3f3f;
    for(auto v:g[u]) mn=min(mn,dfs(v));
    if(a[u]>=mn) return mn;
    else return (a[u]+mn)>>1;
}
```
- **实现思想**：通过递归遍历每个节点，计算其子树的最小值，并根据最小值调整节点值，确保操作后所有节点的值保持非负。

### 最优关键思路与技巧
- **递归计算子树最小值**：通过DFS或递归遍历每个节点，计算其子树的最小值，并根据最小值调整节点值。
- **拓扑排序**：使用拓扑排序进行树的遍历，确保每个节点的子树最小值计算正确。
- **调整节点值**：根据子树的最小值调整节点值，确保操作后所有节点的值保持非负。

### 可拓展之处
- **类似问题**：可以扩展到其他树形结构的问题，如最大化某个节点的值、最小化某个节点的值等。
- **算法优化**：可以考虑使用更高效的算法或数据结构来优化计算子树最小值的过程。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得摘录
- **调试经历**：某些题解中提到多测清空的问题，提醒在编写代码时要注意多测清空，避免因未清空导致错误。
- **踩坑教训**：某些题解中提到二分的范围会超过`int`，提醒在编写代码时要注意数据范围，避免因数据范围问题导致错误。
- **顿悟感想**：通过研究样例，寻找规律，可以发现问题的本质，从而找到解决问题的思路。

---
处理用时：41.41秒
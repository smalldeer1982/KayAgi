# 题目信息

# Ruler (easy version)

## 题目描述

本题是问题的简单版本。该版本与困难版之间的唯一区别是在这个版本中，你最多可以进行 $10$ 次查询。

这是一道交互题。

有一把有 $1001$ 个刻度的尺子，刻度分别为 $1 \sim 1001$。不幸的是，尺子丢失了一个刻度 $x$（$2 \le x \le 999$）。当你用尺子量一个长度为 $y$ 的物体时，尺子量出的结果为：
- 若 $y < x$，尺子将会量出正确的结果 $y$。
- 否则，尺子将会量出错误的结果 $y + 1$。

你需要找出丢失的刻度 $x$。你可以每次提供两个 $1$ 至 $1000$ 内的整数 $a,b$，你将会收到尺子量出的 $a$ 的长度与尺子量出的 $b$ 的长度之积。

你可以进行最多 $10$ 次询问。

## 样例 #1

### 输入

```
2

18

25


9999```

### 输出

```
? 3 5

? 4 4

! 4
? 99 100

! 100```

# AI分析结果

### 题目内容重写

#### 题目描述

本题是问题的简单版本。该版本与困难版之间的唯一区别是在这个版本中，你最多可以进行 $10$ 次查询。

这是一道交互题。

有一把有 $1001$ 个刻度的尺子，刻度分别为 $1 \sim 1001$。不幸的是，尺子丢失了一个刻度 $x$（$2 \le x \le 999$）。当你用尺子量一个长度为 $y$ 的物体时，尺子量出的结果为：
- 若 $y < x$，尺子将会量出正确的结果 $y$。
- 否则，尺子将会量出错误的结果 $y + 1$。

你需要找出丢失的刻度 $x$。你可以每次提供两个 $1$ 至 $1000$ 内的整数 $a,b$，你将会收到尺子量出的 $a$ 的长度与尺子量出的 $b$ 的长度之积。

你可以进行最多 $10$ 次询问。

#### 样例 #1

##### 输入

```
2

18

25


9999```

##### 输出

```
? 3 5

? 4 4

! 4
? 99 100

! 100```

### 题解分析与结论

本题的核心是通过二分或三分法在有限的查询次数内找到丢失的刻度 $x$。由于题目允许最多进行 $10$ 次查询，且 $2^{10} = 1024 > 999$，因此二分法是一个可行的解决方案。此外，部分题解还提出了三分法，虽然在该版本中二分法已经足够，但三分法在困难版本中更为适用。

### 高星题解推荐

#### 题解1：cjh20090318 (5星)

**关键亮点：**
- 使用了三分法，虽然在该版本中二分法已经足够，但三分法展示了更高效的区间缩小策略。
- 代码简洁，逻辑清晰，通过每次询问将区间缩小到原来的 $1/3$，确保在有限的查询次数内找到答案。

**核心代码：**
```cpp
void solve(){
    int l=2,r=999;
    for(int m1,m2,ret;l<r;){
        m1=l+(r-l)/3,m2=r-(r-l)/3;
        ret=check(m1,m2);
        if(ret==(m1+1)*(m2+1)) r=m1;
        else if(ret==m1*(m2+1)) l=m1+1,r=m2;
        else l=m2+1;
    }
    printf("! %d\n",l),FLUSH;
}
```

#### 题解2：Pink_Cut_Tree (4星)

**关键亮点：**
- 使用了二分法，固定一边为 $1$，简化了问题。
- 通过询问 $1 \times mid$ 来判断 $x$ 的位置，逻辑简单且易于理解。

**核心代码：**
```cpp
while(l<r){
    int mid=l+r>>1;
    cout<<"? 1 "<<mid<<"\n";
    cin>>x;
    if(x>=2*mid){
        cout<<"! 1"<<endl; flag=1; break;
    }
    if(x==mid){
        l=mid+1;
    }
    else{
        r=mid;
    }
}
```

#### 题解3：WsW_ (4星)

**关键亮点：**
- 同样使用了二分法，通过询问 $1 \times a$ 来简化问题。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
while(l<=r){
    mid=l+r>>1;
    printf("? 1 %d\n",mid);
    fflush(stdout);
    scanf("%d",&s);
    if(s==mid){
        l=mid+1;
    }
    else{
        r=mid-1;
        ans=mid;
    }
}
```

### 最优关键思路与技巧

1. **二分法**：通过每次将搜索区间缩小一半，可以在 $10$ 次查询内找到丢失的刻度 $x$。固定一边为 $1$ 可以简化问题。
2. **三分法**：虽然在该版本中二分法已经足够，但三分法展示了更高效的区间缩小策略，适用于查询次数更少的困难版本。

### 可拓展之处

- **类似问题**：可以扩展到其他需要在一定查询次数内找到特定值的问题，如猜数字游戏等。
- **算法优化**：可以进一步优化二分或三分法的实现，减少查询次数或提高代码效率。

### 推荐题目

1. [P1947 猜数](https://www.luogu.com.cn/problem/P1947)
2. [P3382 【模板】三分法](https://www.luogu.com.cn/problem/P3382)
3. [P1571 眼红的Medusa](https://www.luogu.com.cn/problem/P1571)

### 个人心得摘录

- **调试经历**：部分题解提到在实现过程中需要注意查询的边界条件，避免超出允许的查询次数。
- **踩坑教训**：在实现三分法时，需要注意区间的划分方式，确保每次查询都能有效地缩小搜索范围。

---
处理用时：41.58秒
# 题目信息

# Guess The Tree

## 题目描述

这是一道交互题。

Misuki 有一棵结构未知，具有 $n$ 个节点的树，节点编号从 $ 1 $ 到 $ n $ ，并要求你写一份代码来猜测它。

你可以询问以下问题：

`? a b`

其中 $a,b$ 为两个节点的编号。

对于一次询问，Misuki 会告诉你哪个节点 $x$ 能最小化 $|d(a,x)-d(b,x)|$ 的值，其中 $d(x,y)$ 是节点 $x$ 和 $y$ 之间的距离。如果存在多个这样的节点，Misuki 会告诉你最小化 $d(a,x)$ 的节点。

现要求你使用不超过 $15n$ 次的询问，来确定这棵树的结构。

## 说明/提示

打印每一行后（即进行一次询问或输出一次答案后），请输出回车并刷新输出缓冲区。可刷新输出缓冲区的有：

- C++ 中的 `fflush(stdout)` 或 `cout.flush()`;
- Java 中的 `System.out.flush()`;
- Pascal 中的 `flush(output)`;
- Python 中的 `stdout.flush()`;
- 对于其他语言，请参阅其他语言的文档。

Translated by @[ARIS2_0](https://www.luogu.com.cn/user/1340759)

## 样例 #1

### 输入

```
1
4
1
1
3```

### 输出

```
? 1 2

? 1 3

? 1 4

! 1 2 1 3 3 4```

# AI分析结果

### 题目翻译

这是一道交互题。

Misuki 有一棵结构未知，具有 $n$ 个节点的树，节点编号从 $1$ 到 $n$，并要求你写一份代码来猜测它。

你可以询问以下问题：

`? a b`

其中 $a,b$ 为两个节点的编号。

对于一次询问，Misuki 会告诉你哪个节点 $x$ 能最小化 $|d(a,x)-d(b,x)|$ 的值，其中 $d(x,y)$ 是节点 $x$ 和 $y$ 之间的距离。如果存在多个这样的节点，Misuki 会告诉你最小化 $d(a,x)$ 的节点。

现要求你使用不超过 $15n$ 次的询问，来确定这棵树的结构。

### 说明/提示

打印每一行后（即进行一次询问或输出一次答案后），请输出回车并刷新输出缓冲区。可刷新输出缓冲区的有：

- C++ 中的 `fflush(stdout)` 或 `cout.flush()`;
- Java 中的 `System.out.flush()`;
- Pascal 中的 `flush(output)`;
- Python 中的 `stdout.flush()`;
- 对于其他语言，请参阅其他语言的文档。

### 样例 #1

#### 输入

```
1
4
1
1
3
```

#### 输出

```
? 1 2

? 1 3

? 1 4

! 1 2 1 3 3 4
```

---

### 题解分析与结论

#### 综合分析

本题的核心在于通过交互式询问，逐步确定树的结构。每个询问返回的是两个节点路径上的中点，利用这一特性，可以通过二分查找的方式逐步逼近树的边。大多数题解都采用了类似二分的思路，通过递归或迭代的方式，逐步确定每个节点的父节点，最终构建出整棵树。

#### 关键思路与技巧

1. **二分查找**：通过询问两个节点，得到它们路径上的中点，逐步缩小查找范围，最终确定相邻的节点。
2. **递归处理**：在确定一个节点的父节点时，递归地处理其与父节点之间的路径，直到找到相邻的边。
3. **并查集优化**：部分题解使用并查集来维护已经确定的边，避免重复查询，减少询问次数。
4. **固定根节点**：大多数题解选择固定一个根节点（如节点1），然后逐步确定其他节点的父节点。

#### 推荐题解

1. **作者：shicj**  
   **星级：4.5**  
   **关键亮点**：通过二分查找的方式，逐步确定每个节点的父节点，思路清晰，代码简洁。  
   **核心代码**：
   ```cpp
   void solve(){
       eds=0;
       cin>>n;
       for(int i=2;i<=n;i++){
           cout<<"? "<<1<<" "<<i<<endl;
           cin>>ans;
           int u=1,v=i;
           while(ans!=u&&ans!=v){
               u=ans;
               cout<<"? "<<u<<" "<<v<<endl;
               cin>>ans;
           }
           eds++;
           edu[eds]=u;
           edv[eds]=v;
       }
       cout<<"! ";
       for(int i=1;i<n;i++){
           cout<<edu[i]<<" "<<edv[i]<<" ";
       }
       cout<<endl;
   }
   ```

2. **作者：Burnling**  
   **星级：4**  
   **关键亮点**：引入并查集优化，减少重复查询，操作次数分析详细，复杂度控制得当。  
   **核心代码**：
   ```cpp
   void dfs(int lp,int rp){
       int a = find(lp);
       int b = find(rp);
       if(a == b) return;
       cout << "? " << lp << " " << rp << endl;
       cout.flush();
       int x;
       cin >> x;
       if(x == lp){
           fa[lp] = b;
           G[lp].push_back(rp);
           return;
       }
       dfs(lp,x);
       dfs(x,rp);
   }
   ```

3. **作者：ifffer_2137**  
   **星级：4**  
   **关键亮点**：通过并查集维护连通性，避免重复递归，询问次数优化较好，代码简洁。  
   **核心代码**：
   ```cpp
   void solve(int u,int v){
       if(fd(u)==fd(v)) return;
       cout<<"? "<<u<<" "<<v<<"\n";
       fflush(stdout);
       int m=read();
       if(m==u){
           int x=fd(u),y=fd(v);
           fa[x]=y;
           e.eb(mkpr(u,v));
           return;
       }
       solve(u,m);solve(m,v);
   }
   ```

#### 拓展思路

1. **类似题目**：可以通过二分查找或分治的方式解决类似的交互题，如确定图的连通性、寻找最短路径等。
2. **优化技巧**：在交互题中，合理使用并查集、二分查找等数据结构，可以有效减少询问次数，提升算法效率。

#### 推荐题目

1. **P1972 [SDOI2009] HH的项链**（题号：P1972）  
   考察知识点：二分查找、树状数组。

2. **P3384 【模板】树链剖分**（题号：P3384）  
   考察知识点：树的结构、路径查询。

3. **P3379 【模板】最近公共祖先**（题号：P3379）  
   考察知识点：树的LCA、二分查找。

---
处理用时：44.83秒
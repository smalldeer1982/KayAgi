# 题目信息

# The Strict Teacher (Hard Version)

## 题目描述

**这是本题的困难版，它和本题的简单版的唯一差距是 $m$ 和 $q$ 的数据范围**。在此版本中，$m,q\le10^5$。你在解决两个版本之后才可以去提交 hack 数据。

Narek 和 Tsovak 正在热火朝天地准备这场比赛，所以他们没时间去做作业了，因此，他们决定去偷 David 的作业。

严厉的老师发现 David 的作业没了非常生气，打算狠狠地惩罚他，于是她雇佣了别的老师帮她一起抓捕 David。

现在有 $m$ 个老师正在一起追 David。幸运的是，教室非常的大，所以 David 有充足的躲藏空间。

教室可以被表示为一条一维直线，上面有 $n$ 个单元格编号从 $1$ 到 $n$，**包含边界。**

最初，David 和这 $m$ 个老师**在不同的单元格中**。然后他们将会进行若干次行动。每次行动中：
- 首先，David 可以移动到一个**相邻的**单元格中，**也可以不动。**
- 然后，每位老师也进行这样的一次移动。

行动将一直持续知道 David 被抓住，即有任何一个老师和 David 位于同一个单元格中。**所有人都看得见其它人的行动。**

你的任务是计算**在所有人按照最优方案行动的前提下，多少次行动后 David 会被抓住。**

> 按照最优方案行动，是指：
> - David 采取一种方案，使得老师抓住他所需的行动次数最大。
> - 老师之间相互配合并采用一种方案，使得他们能够用最少的行动次数抓住 David。

Narek 和 Tsovak 认为这个任务太简单了，于是他们决定给你 $q$ 次询问。

## 样例 #1

### 输入

```
2
8 1 1
6
3
10 3 3
1 4 8
2 3 10```

### 输出

```
5
1
1
2```

# AI分析结果

### 题目翻译

**严厉的老师（困难版）**

#### 题目描述

**这是本题的困难版，它和本题的简单版的唯一差距是 $m$ 和 $q$ 的数据范围**。在此版本中，$m,q\le10^5$。你在解决两个版本之后才可以去提交 hack 数据。

Narek 和 Tsovak 正在热火朝天地准备这场比赛，所以他们没时间去做作业了，因此，他们决定去偷 David 的作业。

严厉的老师发现 David 的作业没了非常生气，打算狠狠地惩罚他，于是她雇佣了别的老师帮她一起抓捕 David。

现在有 $m$ 个老师正在一起追 David。幸运的是，教室非常的大，所以 David 有充足的躲藏空间。

教室可以被表示为一条一维直线，上面有 $n$ 个单元格编号从 $1$ 到 $n$，**包含边界。**

最初，David 和这 $m$ 个老师**在不同的单元格中**。然后他们将会进行若干次行动。每次行动中：
- 首先，David 可以移动到一个**相邻的**单元格中，**也可以不动。**
- 然后，每位老师也进行这样的一次移动。

行动将一直持续知道 David 被抓住，即有任何一个老师和 David 位于同一个单元格中。**所有人都看得见其它人的行动。**

你的任务是计算**在所有人按照最优方案行动的前提下，多少次行动后 David 会被抓住。**

> 按照最优方案行动，是指：
> - David 采取一种方案，使得老师抓住他所需的行动次数最大。
> - 老师之间相互配合并采用一种方案，使得他们能够用最少的行动次数抓住 David。

Narek 和 Tsovak 认为这个任务太简单了，于是他们决定给你 $q$ 次询问。

#### 样例 #1

##### 输入

```
2
8 1 1
6
3
10 3 3
1 4 8
2 3 10```

##### 输出

```
5
1
1
2```

### 题解分析与总结

#### 综合分析与结论

这道题的核心思路是通过贪心算法和二分查找来优化问题的求解。所有题解都采用了类似的思路：首先对老师的位置进行排序，然后根据 David 的位置进行分类讨论，最后通过二分查找快速定位 David 的左右老师位置，计算所需步数。

#### 最优关键思路与技巧

1. **贪心算法**：通过分析，只有离 David 最近的两个老师（或墙）对结果有影响，因此可以简化问题。
2. **二分查找**：利用二分查找快速定位 David 的左右老师位置，优化时间复杂度。
3. **分类讨论**：根据 David 的位置与老师的位置关系，分为三种情况处理：David 在最左边、最右边或中间。

#### 可拓展之处

- **类似问题**：类似的问题可以出现在其他一维或二维的搜索问题中，如“老鼠与猫”的追逐问题。
- **优化思路**：在处理大规模数据时，二分查找和排序是常见的优化手段，可以应用于其他需要快速定位的问题。

#### 推荐题目

1. **P1020 导弹拦截**（贪心与二分查找）
2. **P1040 加分二叉树**（动态规划与二分查找）
3. **P1090 合并果子**（贪心与优先队列）

### 所选高分题解

#### 题解1：作者：chenxi2009 (赞：2)

**星级：4星**

**关键亮点**：
- 通过分类讨论和二分查找，简洁高效地解决了问题。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
for(int i = 1;i <= q;i ++){
    scanf("%d",&a);
    l = 0,r = m;
    while(l < r){
        mid = l + r + 1 >> 1;
        if(b[mid] < a){
            l = mid;
        }
        else{
            r = mid - 1;
        }
    }
    if(!l){
        ans = b[1] - 1;
    }
    else if(l == m){
        ans = n - b[m];
    }
    else{
        lef = b[l];
        rig = b[l + 1];
        if((rig - lef) % 2 == 1){
            ans = (rig - lef - 1) / 2; 
        }
        else{
            ans = (rig - (rig + lef >> 1));
        }
    }
    printf("%d\n",ans);
}
```

#### 题解2：作者：Wide_Master (赞：1)

**星级：4星**

**关键亮点**：
- 使用 C++ 自带的 `lower_bound` 和 `upper_bound` 函数，简化了二分查找的实现。
- 代码简洁，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=q;i++){
    cin>>b;
    if(b<a[1]){
        cout<<a[1]-1<<endl;
    }else if(b>a[m]){
        cout<<n-a[m]<<endl;
    }else{
        int l=lower_bound(a+1,a+1+m,b)-a;
        int r=upper_bound(a+1,a+1+m,b)-a-1;
        cout<<abs(a[r]-a[l])/2<<endl;
    }
}
```

#### 题解3：作者：wujingfey (赞：1)

**星级：4星**

**关键亮点**：
- 通过分类讨论和二分查找，清晰地解决了问题。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
while(q--){
    cin>>b;
    if(b<a[1]) cout<<a[1]-1<<'\n';
    else if(b>a[m]) cout<<n-a[m]<<'\n';
    else{
        int x1=upper_bound(a+1,a+1+m,b)-a-1;
        int x2=lower_bound(a+1,a+1+m,b)-a;
        cout<<(a[x2]-a[x1])/2<<'\n';
    }
}
```

### 总结

以上题解均采用了贪心算法和二分查找的思路，通过分类讨论和优化查找过程，高效地解决了问题。其中，使用 C++ 自带的 `lower_bound` 和 `upper_bound` 函数是代码简洁的关键。

---
处理用时：49.34秒
# 题目信息

# Counting Pairs

## 题目描述

给定一个整数序列 $ a $，长度为 $ n $，其中第 $ i $ 个元素为 $ a_i $。此外，还有两个整数 $ x $ 和 $ y $，且满足 $ x \le y $。

如果一对整数 $ (i, j) $ 满足以下条件，则称其为有趣的：

- $ 1 \le i < j \le n $；
- 从序列 $ a $ 中同时移除位置 $ i $ 和 $ j $ 的元素后，剩余元素的和在 $ x $ 和 $ y $ 之间。

你的任务是找出给定序列 $ a $ 中有多少对这样的有趣整数组合。

## 说明/提示

例如，在第一个示例中，有 $ 4 $ 个有趣的整数组合：

1. $ (1, 2) $；
2. $ (1, 4) $；
3. $ (2, 3) $；
4. $ (3, 4) $。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
7
4 8 10
4 6 3 6
6 22 27
4 9 6 3 4 5
3 8 10
3 2 1
3 1 1
2 3 4
3 3 6
3 2 1
4 4 12
3 3 2 1
6 8 8
1 1 2 2 2 3```

### 输出

```
4
7
0
0
1
5
6```

# AI分析结果

### 题目内容重写
# Counting Pairs

## 题目描述

给定一个整数序列 $ a $，长度为 $ n $，其中第 $ i $ 个元素为 $ a_i $。此外，还有两个整数 $ x $ 和 $ y $，且满足 $ x \le y $。

如果一对整数 $ (i, j) $ 满足以下条件，则称其为有趣的：

- $ 1 \le i < j \le n $；
- 从序列 $ a $ 中同时移除位置 $ i $ 和 $ j $ 的元素后，剩余元素的和在 $ x $ 和 $ y $ 之间。

你的任务是找出给定序列 $ a $ 中有多少对这样的有趣整数组合。

## 说明/提示

例如，在第一个示例中，有 $ 4 $ 个有趣的整数组合：

1. $ (1, 2) $；
2. $ (1, 4) $；
3. $ (2, 3) $；
4. $ (3, 4) $。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
7
4 8 10
4 6 3 6
6 22 27
4 9 6 3 4 5
3 8 10
3 2 1
3 1 1
2 3 4
3 3 6
3 2 1
4 4 12
3 3 2 1
6 8 8
1 1 2 2 2 3```

### 输出

```
4
7
0
0
1
5
6```

### 题解分析与结论

#### 综合分析与结论
本题的核心在于如何高效地找到满足条件的数对 $(i, j)$，使得移除 $a_i$ 和 $a_j$ 后，剩余元素的和在 $[x, y]$ 之间。大多数题解都采用了排序 + 二分查找的思路，时间复杂度为 $O(n \log n)$，适合处理 $n \le 2 \times 10^5$ 的数据范围。

#### 关键思路与技巧
1. **排序与二分查找**：首先对数组进行排序，然后对于每个元素 $a_i$，使用二分查找来确定满足条件的 $a_j$ 的范围。通过 `lower_bound` 和 `upper_bound` 函数，可以快速找到满足 $sum - y \le a_i + a_j \le sum - x$ 的 $a_j$。
2. **双指针优化**：部分题解使用了双指针来进一步优化查找过程，避免了重复计算，提高了效率。
3. **边界处理**：在处理边界条件时，需要注意 $i < j$ 的约束，避免重复计算或遗漏。

#### 推荐题解
1. **作者：JimmyQ (赞：4)**  
   **星级：4.5**  
   **关键亮点**：代码简洁明了，使用了排序和二分查找，逻辑清晰，适合初学者理解。  
   **核心代码**：
   ```cpp
   sort(a+1,a+n+1);
   for(long long i=1;i<=n;i++){
       long long pos1=lower_bound(a+i+1,a+n+1,sum-y-a[i])-a;
       long long pos2=upper_bound(a+i+1,a+n+1,sum-x-a[i])-a-1;
       if(sum-y-a[i]<=a[pos1]&&a[pos2]<=sum-x-a[i]) ans+=pos2-pos1+1;
   }
   ```

2. **作者：OIerWu_829 (赞：4)**  
   **星级：4.5**  
   **关键亮点**：详细解释了题目的转化过程，代码结构清晰，使用了 `lower_bound` 和 `upper_bound` 来查找满足条件的 $a_j$。  
   **核心代码**：
   ```cpp
   sort(a + 1, a + 1 + n);
   for (LL i = 1; i <= n; i++) {
       sum -= a[i];
       auto lb = lower_bound(a + 1 + i, a + 1 + n, sum - y);
       auto ub = upper_bound(a + 1 + i, a + 1 + n, sum - x);
       ans += abs(lb - ub);
       sum += a[i];
   }
   ```

3. **作者：imljw (赞：2)**  
   **星级：4**  
   **关键亮点**：使用了二分查找来找到满足条件的 $a_j$，代码简洁，适合快速实现。  
   **核心代码**：
   ```cpp
   sort(a + 1, a + n + 1);
   for (int i = 1; i <= n; i++) {
       int l = lower_bound(a + 1 + i, a + n + 1, sum - y - a[i]) - a;
       int r = upper_bound(a + 1 + i, a + n + 1, sum - x - a[i]) - a;
       ans += (r - l);
   }
   ```

#### 扩展思路与推荐题目
- **扩展思路**：本题的解法可以推广到类似的数对查找问题，尤其是在需要满足某种条件的情况下，排序 + 二分查找是一种常用的高效方法。
- **推荐题目**：
  1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
  2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
  3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：44.62秒
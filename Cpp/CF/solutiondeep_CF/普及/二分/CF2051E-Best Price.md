# 题目信息

# Best Price

## 题目描述

伯兰德最大的商店收到了一批圣诞树，并已有 $n$ 位顾客前来欲购这些树。在销售启动前，商店需要统一为每棵树定价。为了合理制定价格，商店掌握了关于每位顾客的一些信息。

对于第 $i$ 位顾客，有两个已知整数 $a_i$ 和 $b_i$，它们定义了顾客的购物行为：

- 如果价格不超过 $a_i$，顾客将购买一棵树并给出正面评价；
- 如果价格超过 $a_i$ 但不超过 $b_i$，顾客仍会购买，但会留下负面评价；
- 如果价格高于 $b_i$，则顾客将不会购买。

在负面评价不超过 $k$ 条的前提下，你的任务是帮助商店计算出最大的可能收益。

## 说明/提示

考虑以下例子：

- 在第一个测试用例中，如果价格设为 $1$，两位顾客都会各买一棵树且没有负面评价。
- 在第二个测试用例中，如果价格设为 $5$，顾客会购买一棵树且给出一条负面评价。
- 在第三个测试用例中，如果价格定为 $3$，所有顾客会购买且将收到两条负面评价。
- 在第四个测试用例中，价格定为 $7$ 时，有两位顾客购买，一条负面评价。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2 0
2 1
3 4
1 1
2
5
3 3
1 5 2
3 6 4
4 3
2 3 2 8
3 7 3 9
3 1
2 9 5
12 14 9```

### 输出

```
2
5
9
14
15```

# AI分析结果

### 题目内容重写
【题目描述】
伯兰德最大的商店收到了一批圣诞树，并已有 $n$ 位顾客前来欲购这些树。在销售启动前，商店需要统一为每棵树定价。为了合理制定价格，商店掌握了关于每位顾客的一些信息。

对于第 $i$ 位顾客，有两个已知整数 $a_i$ 和 $b_i$，它们定义了顾客的购物行为：

- 如果价格不超过 $a_i$，顾客将购买一棵树并给出正面评价；
- 如果价格超过 $a_i$ 但不超过 $b_i$，顾客仍会购买，但会留下负面评价；
- 如果价格高于 $b_i$，则顾客将不会购买。

在负面评价不超过 $k$ 条的前提下，你的任务是帮助商店计算出最大的可能收益。

### 题解综合分析
本题的核心在于如何在给定的顾客行为约束下，找到一个最优的定价策略，使得在负面评价不超过 $k$ 的情况下，收益最大化。大多数题解都采用了贪心策略，通过枚举所有可能的定价点（即 $a_i$ 和 $b_i$），并利用二分查找或排序来快速计算每个定价点对应的收益和负面评价数量。

### 评分较高的题解
#### 1. 作者：ohjun (★★★★★)
**关键亮点：**
- 通过贪心策略，枚举所有可能的定价点（$a_i$ 和 $b_i$）。
- 使用二分查找快速计算每个定价点对应的总销量和负面评价数量。
- 代码简洁，时间复杂度为 $O(n\log{n})$，效率较高。

**核心代码：**
```cpp
void cal(int x) {
    int tot = n - (lower_bound(B, B + n, x) - B);
    int val = n - (lower_bound(A, A + n, x) - A);
    if(tot - val > k) return;
    ans = max(ans, ll(tot) * ll(x));
}
```
**实现思想：**
通过二分查找计算在当前价格 $x$ 下，购买树的总人数和正面评价的人数，判断负面评价是否超过 $k$，若不超过则更新最大收益。

#### 2. 作者：BpbjsGreen (★★★★☆)
**关键亮点：**
- 对 $a$ 和 $b$ 数组进行排序，然后从小到大遍历每个定价点。
- 通过指针移动动态计算负面评价数量和购买人数。
- 时间复杂度为 $O(n\log n)$，思路清晰。

**核心代码：**
```cpp
while (pa < n || pb < n) {
    pri = min(a[pa + 1], b[pb + 1]);
    if (nega <= k) ans = max(ans, pri * num);
    while (a[pa + 1] == pri) pa++, nega++;
    while (b[pb + 1] == pri) pb++, num--, nega--;
}
```
**实现思想：**
通过指针移动动态计算当前定价点对应的负面评价数量和购买人数，若负面评价不超过 $k$，则更新最大收益。

#### 3. 作者：沉石鱼惊旋 (★★★★☆)
**关键亮点：**
- 通过二分查找计算每个定价点对应的购买人数和负面评价数量。
- 枚举所有可能的定价点，时间复杂度为 $O(n\log n)$。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
int sum(int x) {
    int num1 = lower_bound(a + 1, a + n + 1, x) - a - 1;
    int num2 = lower_bound(b + 1, b + n + 1, x) - b - 1;
    if (n - (n - num1) - num2 > k) return 0;
    return (n - num2) * x;
}
```
**实现思想：**
通过二分查找计算在当前价格 $x$ 下，购买树的总人数和正面评价的人数，判断负面评价是否超过 $k$，若不超过则返回当前收益。

### 最优关键思路与技巧
1. **贪心策略**：最优定价点一定在 $a_i$ 或 $b_i$ 中，因此只需枚举这些点。
2. **二分查找**：利用二分查找快速计算每个定价点对应的购买人数和负面评价数量。
3. **排序优化**：对 $a$ 和 $b$ 数组进行排序，便于后续的二分查找和指针移动。

### 可拓展之处
类似的问题可以通过贪心策略和二分查找来解决，尤其是在需要枚举所有可能的决策点并快速计算每个决策点的收益时。例如，在资源分配、任务调度等问题中，也可以采用类似的思路。

### 推荐题目
1. [P1496](https://www.luogu.com.cn/problem/P1496) - 区间覆盖问题，考察离散化和贪心策略。
2. [P1886](https://www.luogu.com.cn/problem/P1886) - 滑动窗口问题，考察双指针和贪心策略。
3. [P1020](https://www.luogu.com.cn/problem/P1020) - 导弹拦截问题，考察贪心策略和二分查找。

### 个人心得摘录
- **ohjun**：通过贪心策略和二分查找，代码简洁且效率高，适合处理大规模数据。
- **BpbjsGreen**：动态计算负面评价数量和购买人数，思路清晰，适合理解贪心策略的实现。
- **沉石鱼惊旋**：通过二分查找计算每个定价点的收益，逻辑清晰，易于理解。

---
处理用时：47.01秒
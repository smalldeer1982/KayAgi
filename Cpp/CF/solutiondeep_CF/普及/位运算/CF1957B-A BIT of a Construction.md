# 题目信息

# A BIT of a Construction

## 题目描述

给定 $n,k$，请构造序列 $a_n$，你需要保证 $a_i$ 为自然数，同时满足以下条件：

* $\sum\limits_{i=1}^{n} a_i=k$。

* $a_1|a_2|\dots|a_n$ 二进制下拆位后 $1$ 的数量最大，其中 $|$ 表示[按位或](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96/548283?fr=ge_ala)。

## 说明/提示

对于全部数据，满足 $1\le t\le10^4$，$1\le n\le2\times10^5$，$1\le k\le10^9$，$\sum n\le2\times10^5$。

## 样例 #1

### 输入

```
4
1 5
2 3
2 5
6 51```

### 输出

```
5
1 2
5 0
3 1 1 32 2 12```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是在满足序列和为 $k$ 的条件下，尽可能让按位或结果的二进制中 $1$ 的数量最多。大部分题解采用的策略是构造一个二进制下尽可能多 $1$ 且不超过 $k$ 的数作为序列的第一个数，再用 $k$ 减去这个数得到第二个数，其余数设为 $0$。

#### 思路对比
- **Pursuewind、_shine_、一只小菜包、roumeideclown、ManGo_Mouse**：先找到 $k$ 的最高位 $1$，构造一个数使其在最高位及其以下的所有位都为 $1$ 但不超过 $k$，再用 $k$ 减去这个数得到第二个数，其余数为 $0$。
- **lailai0916、sbno333**：从低到高遍历，尽可能让低位的二进制位为 $1$，累计得到第一个数，用 $k$ 减去这个数得到第二个数，其余数为 $0$。
- **Lu_xZ**：将 $k$ 的所有 $1$ 往低位移得到最小的数 $x$，再从低到高往 $x$ 上添 $1$ 直到大于 $k$，选两个位置填 $x$ 和 $k - x$，其余填 $0$。

#### 算法要点对比
- **Pursuewind、roumeideclown**：通过循环找到 $k$ 的最高位 $1$ 的位置。
- **一只小菜包**：使用 `__builtin_clz` 函数找到 $k$ 的最高位 $1$。
- **lailai0916**：从低到高遍历每一位，判断是否能让该位为 $1$。
- **sbno333**：通过循环让 $z$ 不断乘以 $2$ 加 $1$，直到 $z*2 + 1 > k$。
- **ManGo_Mouse**：使用 `log2` 函数计算 $k$ 的最高位 $1$ 的位置。

#### 解决难点对比
- 主要难点在于如何构造出按位或结果中 $1$ 的数量最多的序列，大部分题解通过贪心策略解决，即优先让低位的二进制位为 $1$。
- 对于 $n = 1$ 的情况，所有题解都进行了特判，直接输出 $k$。

#### 评分
- **Pursuewind**：4星。思路清晰，代码简洁，使用了常见的位运算方法找到 $k$ 的最高位 $1$。
- **一只小菜包**：4星。思路详细，使用了 `__builtin_clz` 函数简化了找最高位 $1$ 的过程，代码可读性较好。
- **lailai0916**：3星。思路正确，但代码中使用的常量和注释可以进一步优化，整体可读性一般。

#### 最优关键思路或技巧
- **贪心策略**：优先让低位的二进制位为 $1$，可以使按位或结果中 $1$ 的数量最多。
- **位运算**：使用位运算可以高效地找到 $k$ 的最高位 $1$，如 `__builtin_clz` 函数或循环判断。

#### 可拓展之处
同类型题可能会有更多的限制条件，如序列元素的取值范围、按位或结果的其他要求等。类似算法套路可以应用在其他构造类题目中，通过贪心策略和位运算来满足题目要求。

#### 推荐洛谷题目
- [P1873 砍树](https://www.luogu.com.cn/problem/P1873)：考察二分查找和贪心策略。
- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：考察二分查找和贪心策略。
- [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)：考察二分查找和函数零点的概念。

### 所选题解
- **Pursuewind（4星）**
  - **关键亮点**：思路清晰，代码简洁，使用常见的位运算方法找到 $k$ 的最高位 $1$。
  - **核心代码**：
```cpp
void solve(){
    int n, k;
    cin >> n >> k;
    if (n == 1){
        cout << k << "\n";
        return ;
    } 
    int x = 0;
    for (int i = 63; i >= 0; i --){
        if (k & (1ll << i)){
            x = i;
            break;
        }
    }
    cout << (1ll << x) - 1 << " " << k - (1ll << x) + 1 << " ";
    for (int i = 1; i <= n - 2; i ++){
        cout << "0 ";
    }
    cout << "\n";
}
```
- **一只小菜包（4星）**
  - **关键亮点**：思路详细，使用了 `__builtin_clz` 函数简化了找最高位 $1$ 的过程，代码可读性较好。
  - **核心代码**：
```cpp
while (t--) {
    int n, k;
    cin >> n >> k;

    vector<int> a(n);

    if (n == 1) {
        a[0] = k;
    } else {
        int msb = 31 - __builtin_clz(k); // 找到k的最高位1
        a[0] = (1 << msb) - 1; // 构造a[0]，使得其在msb及其以下的所有位都为1

        if (a[0] > k) {
            // 如果a[0]超过了k，说明k的最高位1后面直接跟着0，需要减去一个2的幂
            a[0] -= (1 << (msb - 1));
        }

        a[1] = k - a[0]; // 计算a[1]

        fill(a.begin() + 2, a.end(), 0); // 剩余的数全部设为0
    }

    for (int value : a) {
        cout << value << " ";
    }

    cout << "\n";
}
```

---
处理用时：28.76秒
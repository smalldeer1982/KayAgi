# 题目信息

# Bitwise Balancing

## 题目描述

# 位运算平衡


给定三个非负整数 $ b $ 、$ c $ 和 $ d $ 。

请找到一个非负整数 $ a \in [0, 2^{61}] $ 使得 $ (a\, |\, b)-(a\, \&\, c)=d $ ，其中 $ | $ 和 $ \& $ 分别表示[按位或运算](https://en.wikipedia.org/wiki/Bitwise_operation#OR)和[按位与运算](https://en.wikipedia.org/wiki/Bitwise_operation#AND)。

如果存在这样的 $ a $ ，请输出它的值。如果没有解，请输出整数 $ -1 $ 。如果存在多个解，输出其中任意一个。

## 说明/提示

在第一个测试用例中，$ (0\,|\,2)-(0\,\&\,2)=2-0=2 $ 。因此，$ a = 0 $ 是一个正确答案。

在第二个测试用例中，没有任何值 $ a $ 满足方程。

在第三个测试用例中，$ (12\,|\,10)-(12\,\&\,2)=14-0=14 $ 。因此，$ a = 12 $ 是一个正确答案。

## 样例 #1

### 输入

```
3
2 2 2
4 2 6
10 2 14```

### 输出

```
0
-1
12```

# AI分析结果

### 思路对比
- **postpone**：先判断无退位情况，列出真值表按位判断，还化简得到 `a = b ^ d` 的结论。
- **Meickol**：分析无借位后二进制拆位，分类讨论 $a$ 每一位选值，找出规律解题。
- **Super_Cube**：根据无借位枚举二进制位，分情况确定 $a$ 每一位的值，代码可简化。
- **yangxikun**：对每一位进行考虑，枚举 $a$ 每一位的两种可能，判断是否成立。
- **qfy123**：赛时思路是二进制拆位分情况讨论，另一种解法是令 $a = b \operatorname{xor} d$ 再判断。

### 算法要点对比
- **postpone**：要点是列出真值表和化简公式 `a = b ^ d`。
- **Meickol**：要点是二进制拆位和找出 $a$ 每一位选值规律。
- **Super_Cube**：要点是枚举二进制位确定 $a$ 每一位的值和代码简化。
- **yangxikun**：要点是枚举 $a$ 每一位的两种可能并判断。
- **qfy123**：赛时要点是二进制拆位分情况讨论，另一种解法要点是令 $a = b \operatorname{xor} d$。

### 解决难点对比
- **postpone**：难点在于列出真值表和化简公式。
- **Meickol**：难点在于找出 $a$ 每一位选值规律。
- **Super_Cube**：难点在于确定 $a$ 每一位的值和代码简化。
- **yangxikun**：难点在于枚举 $a$ 每一位的两种可能并判断。
- **qfy123**：赛时难点是二进制拆位分情况讨论，另一种解法难点是发现 $a = b \operatorname{xor} d$ 的规律。

### 题解评分
- **postpone**：5星。思路清晰，有真值表和化简公式，代码简洁。
- **Meickol**：4星。思路明确，分类讨论后找出规律。
- **Super_Cube**：4星。思路正确，代码可简化。
- **yangxikun**：3星。思路常规，代码实现较基础。
- **qfy123**：4星。有两种解法，思路多样。

### 高评分题解
- **postpone（5星）**
    - 关键亮点：列出真值表清晰直观，化简得到公式 `a = b ^ d` 使代码简洁。
    - 核心代码：
```cpp
void solve() {
    ll b, c, d;
    cin >> b >> c >> d;

    ll a = b ^ d;
    if ((a | b) - (a & c) == d) {
        cout << a << "\n";
    } else {
        cout << -1 << "\n";
    }
}
```
核心思想：通过化简公式得到 $a$ 的可能值，再验证是否满足等式。
- **Meickol（4星）**
    - 关键亮点：分类讨论后找出 $a$ 每一位选值规律，代码实现清晰。
    - 核心代码：
```cpp
#define per(x,y,z) for(int x=y;x>=z;x--)
typedef long long LL;
LL b,c,d;
void solve(){
    LL a=0;
    cin>>b>>c>>d;
    per(i,61,0){
        if( ((d>>i)&1)!= ((b>>i)&1) ){
            if( ((b>>i)&1)!= ((c>>i)&1) ) return cout<<-1,void();
            else a|=(1LL<<i);
        }
    }
    cout<<a;
}
```
核心思想：根据 $d$ 和 $b$ 每一位的值关系确定 $a$ 每一位的值，不满足条件则无解。
- **qfy123（4星）**
    - 关键亮点：有两种解法，提供了不同的思考角度。
    - 核心代码（另一种解法）：
```cpp
signed main(){
    int T = R();
    while(T--){
        int b = R(), c = R(), d = R();
        int ans = b ^ d; 
        if(((ans | b) - (ans & c)) == d) out(ans, 2);
        else out(-1, 2);
    }
    return 0;
}
```
核心思想：直接令 $a = b \operatorname{xor} d$，再判断是否满足等式。

### 最优关键思路或技巧
- 列出真值表按位分析，能清晰看到各种情况。
- 尝试化简公式，如 `a = b ^ d`，可简化代码和计算。
- 二进制拆位，将对数的判断转换为对每一位的判断。

### 拓展思路
同类型题可考察更多位运算组合，如异或、取反等，或增加更多变量。类似算法套路是二进制拆位和按位分析，通过列出真值表或找规律解决问题。

### 洛谷推荐题目
- [P1100 高低位交换](https://www.luogu.com.cn/problem/P1100)
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)（涉及位运算优化动态规划）
- [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)

### 个人心得
题解中未包含个人心得内容。

---
处理用时：30.67秒
# 题目信息

# Kevin and Binary Strings

## 题目描述

Kevin 在月光河公园的河里发现了一个二进制字符串 $s$，它以 1 开头，并把它交给了你。你的任务是从 $s$ 中选择两个非空子串（允许重叠），以使得它们之间的异或值最大。

对于两个二进制字符串 $a$ 和 $b$，它们的异或结果是将 $a$ 和 $b$ 看作二进制数后，进行按位异或操作 $\oplus$ 所得到的结果，其中最左边的位即为最高位。可以参考[按位异或操作](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

你选择的字符串可以包含前导零。

## 说明/提示

在第一个测试用例中，我们可以选择 $s_2 = \texttt{1}$ 和 $s_1 s_2 s_3 = \texttt{111}$，此时 $\texttt{1} \oplus \texttt{111} = \texttt{110}$。可以证明这是可能得到的最大值。此外，选择 $l_1 = 3$，$r_1 = 3$，$l_2 = 1$，$r_2 = 3$ 也是一个有效的解决方案。

在第二个测试用例中，选择 $s_1 s_2 s_3 = \texttt{100}$ 和 $s_1 s_2 s_3 s_4 = \texttt{1000}$，则异或结果为 $\texttt{100} \oplus \texttt{1000} = \texttt{1100}$，也是最大的结果。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
111
1000
10111
11101
1100010001101```

### 输出

```
2 2 1 3
1 3 1 4
1 5 1 4
3 4 1 5
1 13 1 11```

# AI分析结果

### 题目内容（已为中文，无需重写）
Kevin 在月光河公园的河里发现了一个二进制字符串 $s$，它以 1 开头，并把它交给了你。你的任务是从 $s$ 中选择两个非空子串（允许重叠），以使得它们之间的异或值最大。

对于两个二进制字符串 $a$ 和 $b$，它们的异或结果是将 $a$ 和 $b$ 看作二进制数后，进行按位异或操作 $\oplus$ 所得到的结果，其中最左边的位即为最高位。可以参考[按位异或操作](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

你选择的字符串可以包含前导零。

### 综合分析与结论
这些题解的核心思路基本一致，都认为其中一个子串选择整个原串能使异或值最大。之后主要围绕如何选择另一个子串以达到最大异或值展开。

- **思路对比**：
    - 多数题解是先找到第一个 0 的位置，确定第二个子串的长度，再通过不同方式在原串中寻找合适的子串。
    - 部分题解使用了不同的算法来优化查找过程，如 `lailai0916` 使用 KMP 算法，`_lmh_` 维护可能的子串集合按位贪心。
- **算法要点**：
    - 普遍要点是确定第一个 0 的位置，确定第二个子串长度。
    - 不同的查找方式有暴力枚举、KMP 匹配、按位贪心等。
- **解决难点**：
    - 关键在于如何高效地找到能使异或值最大的第二个子串。不同题解通过不同算法优化了查找过程。

### 所选题解
- **作者：_Lazy_zhr_（4星）**
    - **关键亮点**：思路清晰，代码实现较为直观，适合初学者理解。
    - **个人心得**：强调了多测不清空的问题，“多测不清空，爆零两行泪”。
    - **核心代码**：
```cpp
string s,f,str[5005];
void solve(){
    int l=0,r=0,maxn=0;
    f="";
    cin>>s;
    int n=s.size(),len;
    len=n;
    s=' '+s;
    cout<<"1 "<<n<<" ";
    for(int i=1;i<=n;i++){
        if(s[i]=='0') break;
        len--;
    }
    if(!len){
        cout<<"1 1\n";
        return ;
    }
    for(int i=n;i>n-len;i--) f=s[i]+f;
    f=' '+f;
    int cnt=n-len+1;
    for(int i=1;i<=cnt;i++){
        str[i]=" ";
        for(int j=i;j-i<len;j++) str[i]+=s[j];
    }
    for(int i=1;i<=cnt;i++){
        int sum=0;
        bool x=true;
        for(int j=1;j<=len;j++){
            if(str[i][j]==f[j]) x=false;
            if(x) sum++;
        }
        if(sum>maxn){
            l=i,r=i+len-1;
            maxn=sum;
        }
    }
    cout<<l<<" "<<r<<"\n";
}
```
    - **核心实现思想**：先找到第一个 0 的位置，确定第二个子串的长度，然后生成所有可能的子串，逐一与目标子串异或，记录前缀 1 最长的子串的位置。

- **作者：lailai0916（4星）**
    - **关键亮点**：使用 KMP 算法优化了子串匹配过程，时间复杂度更优。
    - **核心代码**：
```cpp
int kmp(string s,string t)
{
    int n=s.size(),m=t.size();
    for(int i=1;i<m;i++)
    {
        int j=nxt[i-1];
        while(j&&t[i]!=t[j])j=nxt[j-1];
        if(t[i]==t[j])j++;
        nxt[i]=j;
    }
    int j=0;
    for(int i=0;i<n;i++)
    {
        while(j&&s[i]!=t[j])j=nxt[j-1];
        if(s[i]==t[j])j++;
        if(j==m)return i-m+1;
    }
    return -1;
}
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        string s;
        cin>>s;
        int n=s.size(),m=n-1;
        string t=s;
        for(int i=n-1;i>=0;i--)
        {
            t[i]='0'+'1'-t[i];
            if(s[i]=='0')m=i;
        }
        int x=0;
        for(int i=m;i<n;i++)
        {
            int k=kmp(t.substr(0,i),s.substr(m,i-m+1));
            if(k==-1)break;
            x=k;
        }
        cout<<1<<' '<<n<<' '<<x+1<<' '<<x+n-m<<'\n';
    }
    return 0;
}
```
    - **核心实现思想**：先对原串按位取反，找到最右边的 0 的位置，然后使用 KMP 算法在取反后的串中匹配原串从该位置开始的子串，不断更新匹配位置。

### 最优关键思路或技巧
- 确定其中一个子串为原串，能保证高位的 1 参与异或，使结果尽可能大。
- 找到第一个 0 的位置，确定第二个子串的长度，缩小查找范围。
- 部分题解使用 KMP 算法或按位贪心等优化查找过程。

### 可拓展之处
同类型题可能会改变字符串的特征，如不以 1 开头，或者要求选择多个子串进行异或等。类似算法套路可以是使用其他字符串匹配算法或贪心策略来解决问题。

### 推荐洛谷题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P1659 拉拉队排练](https://www.luogu.com.cn/problem/P1659)
3. [P2375 [NOI2014] 动物园](https://www.luogu.com.cn/problem/P2375)

### 个人心得总结
`_Lazy_zhr_` 强调了多测不清空可能导致爆零的问题，提醒在多组测试数据的题目中要注意清空变量。 

---
处理用时：35.70秒
# 题目信息

# Covered Points Count

## 题目描述

**题目大意：**

给你n个区间，求被这些区间覆盖层数为$k(k<=n)$的点的个数

## 样例 #1

### 输入

```
3
0 3
1 3
3 8
```

### 输出

```
6 2 1 
```

## 样例 #2

### 输入

```
3
1 3
2 4
5 7
```

### 输出

```
5 2 0 
```

# AI分析结果

### 题目重写
**题目描述：**

给定n个区间，求被这些区间覆盖层数为$k(k<=n)$的点的个数。

**输入格式：**

第一行一个整数n，表示区间的个数。接下来n行，每行两个整数，表示区间的左右端点。

**输出格式：**

输出n个整数，表示被覆盖层数为1到n的点的个数。

**样例输入1：**
```
3
0 3
1 3
3 8
```
**样例输出1：**
```
6 2 1 
```

**样例输入2：**
```
3
1 3
2 4
5 7
```
**样例输出2：**
```
5 2 0 
```

### 题解分析与结论

#### 综合分析与结论
这道题的核心在于如何高效地统计每个点被覆盖的次数。由于区间范围可能非常大（$0 \leq l \leq r \leq 10^{18}$），直接使用差分数组会导致内存和时间上的问题。因此，大多数题解采用了离散化+差分的思路，通过记录区间的端点并进行排序，再遍历这些端点来计算每个覆盖层数的点的个数。

#### 所选高分题解

**题解1：良月澪二 (赞：7)**
- **星级：5**
- **关键亮点：**
  - 使用`map`存储差分操作，避免了直接处理大范围区间的问题。
  - 通过`for_each`遍历`map`，简洁高效。
  - 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
map<ll, ll> m;
for (int i = 1; i <= n; i++) {
    cin >> l >> r;
    m[l]++; m[++r]--;
}
for_each(m.begin(), m.end(), [] (const pair<ll, ll> &it) {
    ans[cnt] += it.first - tmp;
    tmp = it.first;
    cnt += it.second;
});
```

**题解2：SSHhh (赞：6)**
- **星级：4**
- **关键亮点：**
  - 使用`vector`存储端点，排序后遍历计算覆盖层数。
  - 通过`now`变量记录当前覆盖层数，逻辑清晰。
  - 代码结构清晰，易于理解。

**核心代码：**
```cpp
vector<nod> q;
for (int i = 1; i <= n; i++) {
    cin >> l >> r;
    q.push_back((nod){l, 1});
    q.push_back((nod){r + 1, -1});
}
sort(q.begin(), q.end(), cmp);
long long last = 0, now = 0;
for (int i = 0; i < q.size(); i++) {
    long long nex = q[i].p;
    ans[now] += q[i].p - last;
    now += q[i].k;
    last = nex;
}
```

**题解3：yuheng_wang080904 (赞：2)**
- **星级：4**
- **关键亮点：**
  - 使用`pair`数组存储端点，排序后遍历计算覆盖层数。
  - 通过`cnt`变量记录当前覆盖层数，逻辑清晰。
  - 代码简洁，易于理解。

**核心代码：**
```cpp
pll cl[400010];
for (int i = 1; i <= n; i++) {
    cin >> l >> r;
    cl[++c] = pll(l, 1);
    cl[++c] = pll(r + 1, -1);
}
sort(cl + 1, cl + c + 1);
for (int i = 1; i <= c; i++) {
    f[cnt] += cl[i].first - cl[i - 1].first;
    cnt += cl[i].second;
}
```

### 最优关键思路与技巧
1. **离散化+差分**：通过记录区间的端点并进行排序，再遍历这些端点来计算每个覆盖层数的点的个数，避免了直接处理大范围区间的问题。
2. **使用`map`或`vector`存储端点**：通过`map`或`vector`存储端点，排序后遍历计算覆盖层数，逻辑清晰，代码简洁。
3. **变量记录当前覆盖层数**：通过`cnt`或`now`变量记录当前覆盖层数，便于计算每个覆盖层数的点的个数。

### 可拓展之处
1. **类似题目**：可以拓展到其他需要处理大范围区间的题目，如区间合并、区间查询等。
2. **优化思路**：可以考虑使用更高效的数据结构，如线段树或树状数组，进一步优化时间复杂度。

### 推荐题目
1. [P1083 借教室](https://www.luogu.org/problemnew/show/P1083)
2. [P3372 线段树 1](https://www.luogu.org/problemnew/show/P3372)
3. [P3368 树状数组 2](https://www.luogu.org/problemnew/show/P3368)

### 个人心得摘录
- **良月澪二**：使用`map`存储差分操作，避免了直接处理大范围区间的问题，代码简洁高效。
- **SSHhh**：通过`vector`存储端点，排序后遍历计算覆盖层数，逻辑清晰，易于理解。
- **yuheng_wang080904**：使用`pair`数组存储端点，排序后遍历计算覆盖层数，代码简洁，易于理解。

---
处理用时：41.55秒
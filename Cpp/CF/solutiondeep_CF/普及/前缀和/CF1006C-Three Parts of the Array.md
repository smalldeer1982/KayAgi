# 题目信息

# Three Parts of the Array

## 题目描述

**问题描述**  
给定一个长度为n的整数序列$\{d_1,d_2,\dots,d_n\}$。  
你的任务是将序列分成3部分，每部分可以是空的，并保证每一个数都属于这三个部分的某一个，每一部分都必须是一些连续的整数。  
设三部分的和分别为$sum_1$,$sum_2$,$sum_3$。  那么你需要在所有划分方案中找到一个方案使得$sum_1=sum_3$且$sum_1$尽可能的大。  
确切的说，如果第一部分包含$a$个整数，第二部分包含$b$个整数而第三部分包含$c$个，那么应该有
$$sum_1 = \sum\limits_{1 \le i \le a}d_i,$$
$$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,$$
$$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.$$
并且对于空的那部分，它的和为0。  
你需要在所有划分方案中找到一个方案使得$sum_1=sum_3$且$sum_1$尽可能的大。

## 样例 #1

### 输入

```
5
1 3 1 1 4
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
1 3 2 1 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
3
4 1 2
```

### 输出

```
0
```

# AI分析结果

### 题目重写
给定一个长度为n的整数序列$\{d_1,d_2,\dots,d_n\}$。  
你的任务是将序列分成3部分，每部分可以是空的，并保证每一个数都属于这三个部分的某一个，每一部分都必须是一些连续的整数。  
设三部分的和分别为$sum_1$,$sum_2$,$sum_3$。  那么你需要在所有划分方案中找到一个方案使得$sum_1=sum_3$且$sum_1$尽可能的大。  
确切的说，如果第一部分包含$a$个整数，第二部分包含$b$个整数而第三部分包含$c$个，那么应该有
$$sum_1 = \sum\limits_{1 \le i \le a}d_i,$$
$$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,$$
$$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.$$
并且对于空的那部分，它的和为0。  
你需要在所有划分方案中找到一个方案使得$sum_1=sum_3$且$sum_1$尽可能的大。

### 综合分析与结论
本题的核心是将序列分成三部分，使得第一部分的求和等于第三部分的求和，并且这个和尽可能大。多个题解提供了不同的思路，主要包括二分查找、双指针法和前缀和优化。其中，双指针法和前缀和优化的结合是最为高效和直观的解决方案。

### 所选高分题解

#### 题解1：信守天下
**星级：4.5**
**关键亮点：**
- 使用双指针法结合前缀和，时间复杂度为O(n)，效率高。
- 代码简洁，逻辑清晰，易于理解。
**核心代码：**
```cpp
for (int l = 1, r = n; l <= r; l++) {
    for ( ; a[n] - a[r] < a[l] && r >= l ; r--);
    if (r >= l && a[n] - a[r] == a[l]) {
        ans = a[l];
    }
}
```
**个人心得：**
- 强调了前缀和的重要性，并指出从下标1开始存储数据以避免数组越界。

#### 题解2：GoldenFishX
**星级：4.0**
**关键亮点：**
- 使用双指针法，通过调整左右指针的位置来平衡两边的和。
- 代码实现简单，逻辑清晰。
**核心代码：**
```cpp
while(l < r) {
    if(sumr == suml) {
        ans = sumr;
    }
    if(suml > sumr) {
        sumr += a[--r];
    } else {
        suml += a[++l];
    }
}
```
**个人心得：**
- 提到中间部分可以为空，求和时记得使用long long类型。

#### 题解3：cyrxdzj
**星级：4.0**
**关键亮点：**
- 使用双指针法，通过循环调整指针位置来寻找最大和。
- 代码结构清晰，易于理解。
**核心代码：**
```cpp
while(a + c <= n) {
    long long sum_a = pre[a];
    long long sum_c = pre[n] - pre[n - c];
    if(sum_a == sum_c) {
        if(ans < sum_a) {
            ans = sum_a;
        }
        a++;
        c++;
    } else if(sum_a < sum_c) {
        a++;
    } else if(sum_a > sum_c) {
        c++;
    }
}
```
**个人心得：**
- 强调了使用long long类型以避免溢出。

### 最优关键思路与技巧
- **双指针法**：通过维护两个指针，分别指向序列的左右两端，逐步调整指针位置，使得左右两部分的求和相等。
- **前缀和优化**：通过预处理前缀和数组，可以快速计算任意区间的和，大大提高了算法的效率。

### 可拓展之处
- 类似的问题可以通过双指针法和前缀和优化来解决，例如在序列中寻找满足特定条件的子序列或区间。

### 推荐题目
1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
2. [P1873 砍树](https://www.luogu.com.cn/problem/P1873)
3. [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)

### 个人心得总结
- 调试过程中，确保使用long long类型以避免溢出。
- 前缀和的使用可以显著提高计算效率，特别是在需要频繁计算区间和的场景中。

---
处理用时：32.57秒
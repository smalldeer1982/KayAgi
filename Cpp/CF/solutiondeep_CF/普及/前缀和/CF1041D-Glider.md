# 题目信息

# Glider

## 题目描述

```
你在玩一个吃鸡游戏，你现在要跳伞。你的飞机现在在高度为$h$的空中飞行，你每飞一个单位长度的距离，你就会下落一个单位长度的高度，当然，有些地方是上升气流，你不会下落，你会往前直飞，由于你想在空中就被人打死，求你最远的飞行距离

## 样例 #1

### 输入

```
3 4
2 5
7 9
10 11
```

### 输出

```
10
```

## 样例 #2

### 输入

```
5 10
5 7
11 12
16 20
25 26
30 33
```

### 输出

```
18
```

## 样例 #3

### 输入

```
1 1000000000
1 1000000000
```

### 输出

```
1999999999
```

# AI分析结果

### 题目内容重写

#### 题目描述

你在玩一个吃鸡游戏，你现在要跳伞。你的飞机现在在高度为$h$的空中飞行，你每飞一个单位长度的距离，你就会下落一个单位长度的高度，当然，有些地方是上升气流，你不会下落，你会往前直飞，由于你想在空中就被人打死，求你最远的飞行距离。

#### 样例 #1

##### 输入

```
3 4
2 5
7 9
10 11
```

##### 输出

```
10
```

#### 样例 #2

##### 输入

```
5 10
5 7
11 12
16 20
25 26
30 33
```

##### 输出

```
18
```

#### 样例 #3

##### 输入

```
1 1000000000
1 1000000000
```

##### 输出

```
1999999999
```

### 综合分析与结论

本题的核心问题是如何在给定高度$h$和多个上升气流区间的情况下，找到飞行员能够飞行的最远距离。所有题解都基于一个共同的观察：最优解一定是从某个上升气流区间的左端点起跳。基于这一观察，题解们主要采用了以下两种思路：

1. **二分查找 + 前缀和**：通过预处理每个区间之间的下降距离的前缀和，然后对每个区间的左端点进行二分查找，找到飞行员触地的位置，计算飞行距离并取最大值。
2. **双指针**：通过维护左右指针，动态计算飞行距离，利用贪心思想逐步更新最优解。

### 所选高分题解

#### 题解1：作者：ezoixx130 (赞：9)

**星级：★★★★★**

**关键亮点：**
- 思路清晰，代码简洁。
- 使用二分查找和前缀和优化，时间复杂度为$O(n\log n)$。
- 代码实现高效，易于理解。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 200010
int n,h,ans,l[MAXN],r[MAXN],d[MAXN];

int main()
{
    scanf("%d%d",&n,&h);
    for(int i=1;i<=n;++i)scanf("%d%d",l+i,r+i),d[i]=d[i-1]+l[i]-r[i-1];
    for(int i=1;i<=n;++i)
    {
        int id=lower_bound(d+i+1,d+n+1,h+d[i])-d-1;
        ans=max(ans,r[id]-l[i]+h-d[id]+d[i]);
    }
    printf("%d\n",ans);
}
```

#### 题解2：作者：Disjoint_cat (赞：0)

**星级：★★★★☆**

**关键亮点：**
- 使用双指针优化，时间复杂度为$O(n)$。
- 思路简洁，代码实现高效。
- 通过动态维护左右指针，逐步更新最优解。

**核心代码：**
```cpp
const int N=200005;
int n,h,l[N],r[N];
void Solve(int CASE)
{
    cin>>n>>h;
    for(int i=1;i<=n;i++)cin>>l[i]>>r[i];
    l[n+1]=r[n+1]=INT_MAX;
    int ans=0;
    for(int i=1,j=1,k=h;i<=n;i++)
    {
        if(i>1)k+=l[i]-r[i-1];
        while(k>l[j+1]-r[j])k-=l[j+1]-r[j],j++;
        ans=max(ans,r[j]-l[i]+k);
    }
    cout<<ans;
}
```

#### 题解3：作者：clearlove7777 (赞：2)

**星级：★★★★☆**

**关键亮点：**
- 使用双指针和贪心思想，逐步更新最优解。
- 代码实现清晰，逻辑严谨。
- 通过动态维护当前高度，逐步更新飞行距离。

**核心代码：**
```cpp
#include<cstdio>
using namespace std;
int n,h;
int max(int a,int b){
    return a>b?a:b;
}
struct node{
    int l,r;
}p[200005];
int main(){
    scanf("%d%d",&n,&h);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&p[i].l,&p[i].r);
    int s=p[1].l,x=1,y,now=h;
    for(int i=1;i<n;i++){
        now-=p[i+1].l-p[i].r;
        if(now>0)
            y=i+1;
        else
            break;
    }
    if(h==1){
        int ans=0;
        for(int i=1;i<=n;i++)
            ans=max(ans,p[i].r-p[i].l+1);
        printf("%d",ans);
        return 0;
    }
    if(now>0){
        printf("%d",p[n].r-s+now);
        return 0;
    }
    now+=p[y+1].l-p[y].r;
    int ans=p[y].r-s+now;
    while(x<n){
        x++;
        now+=p[x].l-p[x-1].r;
        while(now>p[y+1].l-p[y].r&&y<n){
            now-=p[y+1].l-p[y].r;
            y++;
        }
        ans=max(ans,p[y].r-p[x].l+now);
        if(y==n)
            break;
    }
    printf("%d",ans);
    return 0;
}
```

### 最优关键思路与技巧

1. **最优解一定从某个上升气流区间的左端点起跳**：这是所有题解的共同基础，通过这一观察可以大大简化问题。
2. **二分查找 + 前缀和**：通过预处理前缀和，利用二分查找快速定位触地位置，时间复杂度为$O(n\log n)$。
3. **双指针 + 贪心**：通过动态维护左右指针，逐步更新最优解，时间复杂度为$O(n)$。

### 可拓展之处

- **类似问题**：可以扩展到其他需要动态维护区间或位置的问题，如滑动窗口、区间覆盖等。
- **算法优化**：在类似问题中，可以考虑使用双指针或二分查找来优化时间复杂度。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)

---
处理用时：50.70秒
# 题目信息

# Photoshoot for Gorillas

## 题目描述

你非常喜欢大猩猩，于是你决定为它们组织一次拍摄活动。大猩猩生活在丛林中，丛林被表示为一个有 $n$ 行 $m$ 列的网格，有 $w$ 个大猩猩同意参与拍摄，第 $i$ 个大猩猩的身高为 $a_i$ .你希望将所有大猩猩放置在网格的单元格中，并且确保每个单元格中最多只有一只大猩猩。

每种方案的壮观程度等于网格中所有以 $k$ 为边长的子正方形的壮观程度的总和。

子正方形的壮观程度等于其中所有大猩猩的身高的总和。

从所有合适的方案中选出最壮观的方案。

## 样例 #1

### 输入

```
5
3 4 2
9
1 1 1 1 1 1 1 1 1
2 1 1
2
5 7
20 15 7
9
4 1 4 5 6 1 1000000000 898 777
1984 1 1
4
5 4 1499 2004
9 5 5
6
6 7 14 16 16 6```

### 输出

```
21
12
49000083104
3512
319```

# AI分析结果

### 题目内容重写

#### 题目描述

你非常喜欢大猩猩，于是你决定为它们组织一次拍摄活动。大猩猩生活在丛林中，丛林被表示为一个有 $n$ 行 $m$ 列的网格，有 $w$ 个大猩猩同意参与拍摄，第 $i$ 个大猩猩的身高为 $a_i$。你希望将所有大猩猩放置在网格的单元格中，并且确保每个单元格中最多只有一只大猩猩。

每种方案的壮观程度等于网格中所有以 $k$ 为边长的子正方形的壮观程度的总和。

子正方形的壮观程度等于其中所有大猩猩的身高的总和。

从所有合适的方案中选出最壮观的方案。

#### 样例 #1

##### 输入

```
5
3 4 2
9
1 1 1 1 1 1 1 1 1
2 1 1
2
5 7
20 15 7
9
4 1 4 5 6 1 1000000000 898 777
1984 1 1
4
5 4 1499 2004
9 5 5
6
6 7 14 16 16 6
```

##### 输出

```
21
12
49000083104
3512
319
```

### 题解分析与结论

#### 综合分析

本题的核心问题是如何将大猩猩放置在网格中，使得所有边长为 $k$ 的子正方形的壮观程度总和最大。所有题解都采用了贪心策略，即将身高较高的大猩猩放置在被子正方形覆盖次数较多的格子中。具体实现上，大多数题解使用了二维差分和前缀和来计算每个格子被子正方形覆盖的次数，然后通过排序和贪心匹配来最大化壮观程度。

#### 最优思路与技巧

1. **贪心策略**：将身高较高的大猩猩放置在被子正方形覆盖次数较多的格子中。
2. **二维差分与前缀和**：通过二维差分和前缀和高效计算每个格子被子正方形覆盖的次数。
3. **排序与匹配**：将格子的覆盖次数和大猩猩的身高分别排序，然后进行匹配计算。

#### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他网格相关的优化问题，如最大化某个区域内的某种属性总和。
- **算法套路**：二维差分和前缀和的技巧可以应用于其他需要高效计算区域覆盖次数的问题。

### 推荐题目

1. [P3397 地毯](https://www.luogu.com.cn/problem/P3397)
2. [P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)
3. [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216)

### 所选高星题解

#### 题解1：XYzero (4星)

**关键亮点**：
- 使用了二维差分和前缀和来计算每个格子被子正方形覆盖的次数。
- 代码清晰，逻辑严谨，注释详细。

**核心代码**：
```cpp
for(int i = 1;i <= n - k + 1;i++){
    for(int j = 1;j <= m - k + 1;j++){
        int x = i,y = j,X = min(n,i + k - 1),Y = min(m,j + k - 1);
        c[x][y] ++;
        c[X + 1][Y + 1] ++;
        c[x][Y + 1] --;
        c[X + 1][y] --;
    } 
}
for(int i = 1;i <= n;i++){
    for(int j = 1;j <= m;j++){
        pre[i][j] = (pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + c[i][j]);
    } 
}
```

#### 题解2：Ke_scholar (4星)

**关键亮点**：
- 使用了二维差分和前缀和来计算每个格子被子正方形覆盖的次数。
- 代码简洁，逻辑清晰，注释详细。

**核心代码**：
```cpp
for (int i = 1; i + k <= n + 1; i ++) {
    for (int j = 1; j + k <= m + 1; j ++) {
        v[i][j] ++, v[i][j + k] --;
        v[i + k][j]--, v[i + k][j + k]++;
    }
}
for (int i = 1; i <= n; i ++) {
    for (int j = 1; j <= m; j ++) {
        v[i][j] += v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1];
        d.push_back(v[i][j]);
    }
}
```

#### 题解3：_dbq_ (4星)

**关键亮点**：
- 使用了二维差分和前缀和来计算每个格子被子正方形覆盖的次数。
- 代码简洁，逻辑清晰，注释详细。

**核心代码**：
```cpp
for(int i = 1;i <= n;i++){
    for(int j = 1;j <= m;j++){
        a[++tmp] = 1ll * (min(i + k - 1, n) - max(i, k) + 1) * (min(j + k - 1, m) - max(j, k) + 1);
    }
}
sort(a + 1, a + 1 + tmp, cmp);
sort(b + 1, b + 1 + w, cmp);
LL ans = 0;
for(int i = 1;i <= w;i++){
    ans += (1ll * a[i] * b[i]);
}
```

### 个人心得摘录

- **调试经历**：在实现二维差分和前缀和时，需要注意边界条件的处理，避免数组越界。
- **踩坑教训**：在多组测试数据的情况下，务必清空数组，避免数据污染。
- **顿悟感想**：贪心策略与二维差分前缀和的结合，能够高效解决此类区域覆盖问题。

---
处理用时：46.42秒
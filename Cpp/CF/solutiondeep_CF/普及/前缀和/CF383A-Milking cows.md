# 题目信息

# Milking cows

## 题目描述

Iahub在农场帮助他的祖父，今天他必须挤牛奶。农场里有$n$只牛左成一排，从左到右编号$1$到$n$。每只牛不是面向左边就是面向右边。当Iahub挤某一只牛的牛奶时，所有看得到这当前只牛的牛都会因为受到惊吓而损失一单位量的牛奶。面向左边的牛可以看到它左边的所有牛（不包括自己），面向右边的牛可以看到它右边的所有牛（不包括自己）。被惊吓过的牛可以再次被惊吓。被挤过奶的牛不会再被惊吓。我们假定每一头牛可以生产无限量的牛奶。

Iahub可以决定挤牛奶的顺序，但他必须每头牛都要挤。Iahub想损失尽可能少的牛奶。请输出最少的牛奶损失量。

## 说明/提示

在第一个样例中,Iahub按照下面的顺序可以使得牛奶损失最少：$3,4,2,1$。当他挤牛$3$时，牛$4$会损失$1$单位牛奶。在此之后，没有牛奶损失。

Translated by @Imakf

## 样例 #1

### 输入

```
4
0 0 1 0
```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 0 1 0 1
```

### 输出

```
3```

# AI分析结果

### 题目内容重写
# 挤牛奶

## 题目描述

Iahub在农场帮助他的祖父，今天他必须挤牛奶。农场里有$n$只牛排成一排，从左到右编号$1$到$n$。每只牛不是面向左边就是面向右边。当Iahub挤某一只牛的牛奶时，所有看得到这当前只牛的牛都会因为受到惊吓而损失一单位量的牛奶。面向左边的牛可以看到它左边的所有牛（不包括自己），面向右边的牛可以看到它右边的所有牛（不包括自己）。被惊吓过的牛可以再次被惊吓。被挤过奶的牛不会再被惊吓。我们假定每一头牛可以生产无限量的牛奶。

Iahub可以决定挤牛奶的顺序，但他必须每头牛都要挤。Iahub想损失尽可能少的牛奶。请输出最少的牛奶损失量。

## 说明/提示

在第一个样例中,Iahub按照下面的顺序可以使得牛奶损失最少：$3,4,2,1$。当他挤牛$3$时，牛$4$会损失$1$单位牛奶。在此之后，没有牛奶损失。

Translated by @Imakf

## 样例 #1

### 输入

```
4
0 0 1 0
```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 0 1 0 1
```

### 输出

```
3```

### 题解分析与结论

#### 综合分析与结论
本题的核心在于如何通过合理的挤奶顺序，最小化因惊吓导致的牛奶损失。所有题解都采用了贪心算法的思路，通过统计每头牛在特定方向上的惊吓次数来求解最小损失。具体来说，主要思路分为两种：
1. **从左到右挤奶**：统计每头面向左的牛左边面向右的牛的数量。
2. **从右到左挤奶**：统计每头面向右的牛右边面向左的牛的数量。

这两种方法本质上是等价的，因为无论哪种顺序，最终的损失量是相同的。因此，只需选择其中一种方法即可。

#### 所选高星题解

1. **作者：花里心爱 (赞：10)**
   - **星级：5星**
   - **关键亮点**：思路清晰，代码简洁，使用了前缀和的思想来统计每头面向左的牛左边面向右的牛的数量。
   - **代码核心思想**：通过遍历数组，统计面向右的牛的数量，并在遇到面向左的牛时累加损失量。
   ```cpp
   int n,t;
   long long cnt,sum;
   int main(){
       scanf("%d",&n);
       for(int i=1;i<=n;++i){
           scanf("%d",&t);
           if(t)++cnt;      //前缀和思想线性求出向左看的牛前面向右看牛的数量
           else sum+=cnt;   //如果i向左看，更新答案
       }
       cout<<sum<<endl;     //long long类型用cout或%I64d输出
       return 0;
   }
   ```

2. **作者：Buried_Dream (赞：6)**
   - **星级：4星**
   - **关键亮点**：代码简洁，使用了前缀和的思想，与花里心爱的解法类似，但代码风格略有不同。
   - **代码核心思想**：通过遍历数组，统计面向右的牛的数量，并在遇到面向左的牛时累加损失量。
   ```cpp
   int js = 0;
   int ans;
   signed main() {
       int n = read();
       for(int i = 1; i <= n; i++) {
           int x = read(); 
           if(x) ++js;
           else ans += js;
       }print(ans);
       return 0;
   }
   ```

3. **作者：Qerucy (赞：1)**
   - **星级：4星**
   - **关键亮点**：代码简洁，使用了前缀和的思想，与前面两位作者的解法类似，但代码风格更为简洁。
   - **代码核心思想**：通过遍历数组，统计面向右的牛的数量，并在遇到面向左的牛时累加损失量。
   ```cpp
   int n;
   int x;
   int sum;
   int ans;
   signed main(){
       scanf("%lld",&n);
       for(int i=1;i<=n;i++){
           scanf("%lld",&x);
           if(x) sum++;
           else ans+=sum;
       }
       printf("%lld",ans);
       return 0;
   }
   ```

#### 最优关键思路或技巧
- **贪心算法**：通过合理的挤奶顺序，最小化牛奶损失。
- **前缀和思想**：通过遍历数组，统计每头面向左的牛左边面向右的牛的数量，从而快速计算损失量。

#### 可拓展之处
- **类似问题**：可以扩展到其他需要统计特定方向或顺序的问题，如逆序对问题、区间统计问题等。
- **算法套路**：贪心算法结合前缀和的思想，可以应用于多种统计类问题。

#### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

#### 个人心得总结
- **调试经历**：在实现过程中，需要注意数据类型的范围，避免溢出。
- **踩坑教训**：在统计过程中，要确保统计的顺序和方向正确，否则会导致错误的结果。
- **顿悟感想**：贪心算法的关键在于找到最优的局部策略，从而得到全局最优解。

---
处理用时：43.15秒
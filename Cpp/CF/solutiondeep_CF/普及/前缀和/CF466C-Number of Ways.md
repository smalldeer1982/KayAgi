# 题目信息

# Number of Ways

## 题目描述

You've got array $ a[1],a[2],...,a[n] $ , consisting of $ n $ integers. Count the number of ways to split all the elements of the array into three contiguous parts so that the sum of elements in each part is the same.

More formally, you need to find the number of such pairs of indices $ i,j $ $ (2<=i<=j<=n-1) $ , that ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF466C/6d268bd0e5773093a8b59275245964aa2b1c55f9.png).

## 样例 #1

### 输入

```
5
1 2 3 0 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
0 1 -1 0
```

### 输出

```
1
```

## 样例 #3

### 输入

```
2
4 1
```

### 输出

```
0
```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个数组 $a[1], a[2], ..., a[n]$，包含 $n$ 个整数。计算将数组的所有元素分成三个连续部分的方式数，使得每部分元素的和相等。

更正式地说，你需要找到满足以下条件的索引对 $i, j$（$2 \leq i \leq j \leq n-1$）的数量，使得：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF466C/6d268bd0e5773093a8b59275245964aa2b1c55f9.png)

#### 样例 #1

##### 输入

```
5
1 2 3 0 3
```

##### 输出

```
2
```

#### 样例 #2

##### 输入

```
4
0 1 -1 0
```

##### 输出

```
1
```

#### 样例 #3

##### 输入

```
2
4 1
```

##### 输出

```
0
```

---

### 题解分析与结论

#### 综合分析

本题的核心是将数组分成三个连续部分，且每部分的和相等。所有题解都采用了前缀和的思想，通过计算前缀和来快速判断某一部分的和是否等于总和的三分之一。以下是各题解的要点对比：

1. **Mistybranch** 和 **wxzzzz** 的题解思路相似，都是通过遍历数组，记录满足条件的前缀和位置，然后统计符合条件的索引对。两者的代码实现简洁，思路清晰。
2. **noble_** 的题解引入了从后往前的前缀和，通过记录满足条件的后缀和位置，进一步优化了统计过程。
3. **Kacho** 和 **AC_Automation** 的题解通过使用两个布尔数组分别记录满足条件的前缀和后缀位置，最后通过前缀和统计答案。
4. **Apro1066** 的题解使用了树状数组来优化统计过程，虽然思路新颖，但代码复杂度较高。
5. **迟暮天复明** 和 **Light_Star_RPmax_AFO** 的题解通过分别记录满足条件的前缀和后缀位置，然后通过双指针或前缀和统计答案。

#### 最优关键思路

1. **前缀和**：通过计算前缀和，快速判断某一部分的和是否等于总和的三分之一。
2. **双指针或前缀和统计**：通过记录满足条件的前缀和后缀位置，统计符合条件的索引对。
3. **从后往前的前缀和**：通过从后往前计算前缀和，进一步优化统计过程。

#### 可拓展之处

1. **类似题目**：可以将数组分成更多部分，如四部分、五部分等，思路类似，只需调整前缀和的计算和统计方式。
2. **其他数据结构**：可以使用树状数组、线段树等数据结构来优化统计过程。

#### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---

### 所选高星题解

#### 题解1：Mistybranch (4星)

**关键亮点**：
- 思路清晰，代码简洁。
- 通过前缀和快速判断满足条件的位置，并统计答案。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (i > 1 && i < n && sum[i] == sum[n] * 2 / 3) {
        res += cc;
    }
    if (sum[i] == sum[n] / 3) {
        cc++;
    }
}
```

#### 题解2：wxzzzz (4星)

**关键亮点**：
- 思路清晰，代码简洁。
- 通过前缀和快速判断满足条件的位置，并统计答案。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (1 < i && i < n && a[i] == a[n] / 3 * 2)
        ans += sum;
    if (i < n - 1 && a[i] == a[n] / 3)
        sum++;
}
```

#### 题解3：noble_ (4星)

**关键亮点**：
- 引入从后往前的前缀和，进一步优化统计过程。
- 思路清晰，代码简洁。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (sum[1,i] == sum[n] / 3)
        ans += c[i+2];
}
```

---

### 总结

本题的核心在于通过前缀和快速判断满足条件的位置，并统计符合条件的索引对。最优的思路是使用前缀和和双指针或前缀和统计的方法，代码简洁且高效。

---
处理用时：35.96秒
# 题目信息

# Labyrinth

## 题目描述

## 题意描述
你正在玩一款电脑游戏。在其中一关，你位于一个 $n$ 行 $m$ 列的迷宫。每个格子要么是可以通过的空地，要么是障碍。迷宫的起点位于第 $r$ 行第 $c$ 列。你每一步可以向上、下、左、右中的一个方向移动一格，前提是那一格不是障碍。你无法越出迷宫的边界。

不幸的是，你的键盘快坏了，所以你只能向左移动不超过 $x$ 格，并且向右移动不超过 $y$ 格。因为上下键情况良好，所以对向上和向下的移动次数没有限制。

现在你想知道在满足上述条件的情况下，从起点出发，有多少格子可以到达（包括起点）？

## 样例 #1

### 输入

```
4 5
3 2
1 2
.....
.***.
...**
*....
```

### 输出

```
10
```

## 样例 #2

### 输入

```
4 4
2 2
0 1
....
..*.
....
....
```

### 输出

```
7
```

# AI分析结果

### 题解综合分析与结论
这些题解均围绕迷宫可达格子数量的问题展开，核心算法为广度优先搜索（BFS），但在处理左右移动次数限制及路径选择上各有不同。

#### 思路对比
- **常规BFS优化**：ImmortalWatcher、StarryWander、FanYongchen、IronELement等人的题解采用常规BFS，通过记录每个点的左右移动次数，当一个点被多次访问时，比较不同路径的左右移动次数，若更优则更新并继续搜索。
- **0 - 1 BFS**：DDOSvoid、mot1ve的题解将上下移动视为边权为0，左右移动视为边权为1，利用双端队列实现0 - 1 BFS，保证每次出队的是最小边权的节点。
- **约束转化**：ouuan通过分析发现向左走的步数和向右走的步数存在关系，将问题转化为只用管向左步数的01最短路，用SPFA解决。

#### 算法要点对比
- **数据结构**：大部分题解使用队列进行BFS，部分使用双端队列实现0 - 1 BFS。同时，使用二维数组记录地图、访问标记、左右移动次数等信息。
- **剪枝策略**：对于重复访问的点，不同题解采用不同的剪枝策略，如比较左右移动次数的最小值、左右移动步数之和等。

#### 难点解决对比
- **重复路径问题**：多个题解意识到一个点可能有多种通达方法，左右移动次数不同，通过比较不同路径的左右移动次数来决定是否更新和继续搜索。
- **左右移动次数限制**：通过在结构体中记录当前的左右移动次数，在搜索过程中进行判断，确保不超过限制。

#### 评分
- **ImmortalWatcher**：5星。思路清晰，详细解释了常规BFS的漏洞及改进方法，代码注释详细。
- **DDOSvoid**：4星。利用0 - 1 BFS优化，思路巧妙，代码简洁。
- **ouuan**：4星。通过分析约束条件之间的关系，将问题转化为01最短路，思维独特。

### 所选题解
- **ImmortalWatcher（5星）**
    - **关键亮点**：详细解释了常规BFS的漏洞，并给出了改进方法，通过记录每个点的最少左移和右移次数来处理重复路径问题。
    - **核心代码**：
```cpp
while(st<en)
{
    st++;
    for(i=0;i<4;i++)
    {
        int xx=d[st][1]+fx[i][0],yy=d[st][2]+fx[i][1],u=0,v=0;
        if(i==2) u++;
        if(i==3) v++;
        if(u+d[st][3]>x||v+d[st][4]>y||xx<=0||xx>n||yy<=0||yy>m||a[xx][yy]!='.'||(bz[xx][yy]<=d[st][3]+u&&bz2[xx][yy]<=d[st][4]+v)) continue;
        if(bz[xx][yy]>d[st][3]+u&&bz2[xx][yy]>d[st][4]+v)
        {
            if(bz[xx][yy]==max&&bz2[xx][yy]==max) ans++;
            bz[xx][yy]=d[st][3]+u;
            bz2[xx][yy]=d[st][4]+v;
        }
        d[++en][1]=xx;
        d[en][2]=yy;
        d[en][3]=d[st][3]+u;
        d[en][4]=d[st][4]+v;
    }
}
```
- **DDOSvoid（4星）**
    - **关键亮点**：利用0 - 1 BFS优化，将上下移动视为边权为0，左右移动视为边权为1，通过双端队列保证每次出队的是最小边权的节点。
    - **核心代码**：
```cpp
void bfs(){
    memset(dis, -1, sizeof dis);
    Q.push_front(node(sx, sy)); dis[sx][sy] = 0;
    while(!Q.empty()){
        node t = Q.front(); Q.pop_front();
        for(int i = 1; i <= 4; ++i){
            int x = t.x + dx[i], y = t.y + dy[i]; 
            if(x < 1 || x > n || y < 1 || y > m || ma[x][y]) continue;
            if(dis[x][y]!= -1 && dis[x][y] <= dis[t.x][t.y] + (i == 4)) continue;
            dis[x][y] = dis[t.x][t.y] + (i == 4);
            if(i == 4) Q.push_back(node(x, y));
            else Q.push_front(node(x, y)); 
        }
    }
}
```
- **ouuan（4星）**
    - **关键亮点**：通过分析约束条件之间的关系，将问题转化为只用管向左步数的01最短路，用SPFA解决。
    - **核心代码**：
```cpp
while (!q.empty())
{
    t=q.front();
    q.pop();
    inq[t.first][t.second]=false;
    for (i=0;i<4;++i)
    {
        tx=t.first+dir[i][0];
        ty=t.second+dir[i][1];
        if (g[tx][ty]&&dis[tx][ty]>dis[t.first][t.second]+(i==0))
        {
            dis[tx][ty]=dis[t.first][t.second]+(i==0);
            if (!inq[tx][ty])
            {
                inq[tx][ty]=true;
                q.push(pii(tx,ty));
            }
        }
    } 
}
```

### 最优关键思路或技巧
- **约束条件分析**：分析左右移动次数之间的关系，将多约束问题转化为单约束问题，如ouuan的题解。
- **0 - 1 BFS**：将上下移动视为边权为0，左右移动视为边权为1，利用双端队列实现0 - 1 BFS，优化搜索效率。
- **剪枝策略**：记录每个点的最少左右移动次数，当一个点被多次访问时，比较不同路径的左右移动次数，若更优则更新并继续搜索。

### 拓展思路
同类型题可涉及更多约束条件，如增加上下移动次数限制、增加不同类型的障碍物等。类似算法套路可用于解决其他具有多约束条件的搜索问题，如在图中寻找满足特定条件的最短路径。

### 推荐题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
- [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)

### 个人心得摘录与总结
- **ImmortalWatcher**：意识到常规BFS可能存在漏洞，一个点可能有多种通达方法，左右移动次数不同，需要记录每个点的最少左移和右移次数来处理重复路径问题。
- **FanYongchen**：普通的广度优先搜索代码可能会因为不同路径到达同一点时左右步数不同而得到错误答案，需要在走到已走过的点时，再次判断当前左右已走的步数是否可以再走到其他点。
- **fls233666**：普通的广度优先搜索在拓展过程中，可能会因为先到的劣的方案而舍弃能拓展更多格点的方案，需要用另外一个二维数组记录拓展到每个点时，能向左移动和向右移动的步数之和的最大值，以此来比较方案的优劣。

---
处理用时：46.21秒
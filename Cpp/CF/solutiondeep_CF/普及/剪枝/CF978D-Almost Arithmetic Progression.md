# 题目信息

# Almost Arithmetic Progression

## 题目描述

Polycarp 喜欢等差数列，对于一个数列 $ [a_1,a_2,a_3,\dots,a_n] $，如果对于每个 $ i\,(1\le i < n) $，$ a_{i+1}-a_i $ 的值均相同，那么这个数列就是一个等差数列。例如，$ [42] $ ，$ [5,5,5] $ ，$ [2,11,20,29] $ 和 $ [3,2,1,0] $ 是等差数列，但是 $ [1,0,1] $，$ [1,3,9] $ 和 $ [2,3,1] $ 不是。

根据定义，任何长度为 $ 1 $ 或 $ 2 $ 的数列都是等差数列。

Polycarp 找到了一个只包含正整数的数列 $ [b_1,b_2,b_3,\dots,b_n] $ 。他只想最多将每个元素改变一次。换句话说，对于每个元素，有三种选项：自增 $ 1 $，自减 $ 1 $ 或者不变。

你需要找到对 $ b $ 中元素操作（每个只能操作一次）的最小次数，使 $ b $ 变成一个等差数列。

操作完成后的数列可以含有 $ 0 $ 。

## 说明/提示

在样例 $ 1 $ 中，Polycarp 应该将第 $ 1 $ 个元素加 $ 1 $ ，将第 $ 2 $ 个元素加 $ 1 $ ，将第 $ 3 $ 个元素加 $ 1 $ ，并且不改变第 $ 4 $ 个元素。所以，Polycarp 操作之后的数列为 $ [25,20,15,10] $ 。

在样例 $ 2 $ 中，Polycarp 不应进行操作，因为他的数列已经是等差数列了。

在样例 $ 3 $ 中，不可能通过上述的操作将数列变为等差数列。

在样例 $ 4 $ 中，Polycarp 应该只将第 $ 1 $ 个元素加 $ 1 $ 。操作之后的数列为 $ [0,3,6,9,12] $ 。

## 样例 #1

### 输入

```
4
24 21 14 10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2
500 500
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
14 5 1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
5
1 3 6 9 12
```

### 输出

```
1
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是基于等差数列的性质，通过确定首项和公差来构造等差数列。大部分题解采用枚举首项和第二项的所有可能变化（各有三种：加1、减1、不变，共9种组合），计算出对应的公差，再检查后续项能否通过最多一次操作满足该等差数列。

#### 算法要点对比
- **枚举法**：多数题解通过枚举首项和第二项的9种变化情况，计算公差并检查后续项。如FanYongchen、Sophon等的题解。
- **搜索法**：nstk0513和liwenxi114514使用深度优先搜索（DFS），通过枚举每个数的三种操作情况，结合剪枝优化来减少不必要的搜索。

#### 解决难点对比
- **判断可行性**：各题解都需要判断当前枚举的首项和公差能否使数列通过最多一次操作变为等差数列，多数通过检查相邻两项的差值与公差的关系来判断。
- **优化时间复杂度**：搜索法的题解通过最优性剪枝和可行性剪枝来优化时间复杂度，避免不必要的搜索。

#### 题解评分
| 作者 | 评分 | 理由 |
| --- | --- | --- |
| feicheng | 4星 | 思路清晰，代码简洁，对关键判断条件有明确说明。 |
| FanYongchen | 4星 | 思路明确，代码完整且注释详细，易于理解。 |
| Sophon | 4星 | 思路清晰，代码结构良好，对枚举和计算过程有清晰的实现。 |
| nstk0513 | 3星 | 使用搜索法并进行了多种剪枝优化，但代码复杂度较高，且时间复杂度表述不够准确。 |
| liwenxi114514 | 3星 | 详细介绍了搜索法及剪枝优化，但代码结构稍显复杂。 |
| J_Kobe | 4星 | 思路清晰，代码简洁明了，对枚举和判断过程有清晰的实现。 |
| OIerZhang | 3星 | 思路正确，但代码中枚举公差的方式稍显复杂，不够直观。 |
| xujingyu | 3星 | 思路清晰，但代码中存在一些细节问题，如枚举前两个数的情况数计算错误。 |
| WegestGao | 3星 | 详细介绍了DFS的剪枝优化思路，但代码不完整，且存在一些逻辑小错误。 |
| ny_Dacong | 3星 | 思路清晰，但代码中枚举首项和公差的情况较多，代码稍显冗长。 |
| ILLENIUM_DOOR | 4星 | 思路清晰，代码完整且注释详细，对枚举和判断过程有清晰的实现。 |
| Mistybranch | 3星 | 思路正确，但代码中使用首项和末项确定公差的方式在某些情况下可能会增加不必要的判断。 |
| 追梦的黑旋风 | 3星 | 思路简单易懂，但代码风格不够规范，且使用了较多自定义函数。 |
| 世末OIer | 3星 | 思路正确，但代码中暴力枚举的方式不够简洁，且使用了栈结构，增加了代码复杂度。 |
| Ak_hjc_using | 2星 | 仅给出思路，未提供代码，参考价值有限。 |

#### 所选题解
- **feicheng（4星）**
    - **关键亮点**：思路清晰，直接指出枚举前两项的9种可能性并进行检验，时间复杂度分析明确，代码简洁。
    - **核心代码**：
```cpp
inline int judge(int d) {//检验该公差是否可行
    int res = 0;
    for(ri i = 3;i <= n;++i){
        if(b[i]-b[i-1] > d + 1 || b[i]-b[i-1] < d - 1) return -1;
        else if(b[i]-b[i-1] == d + 1) ++res,b[i]--;
        else if(b[i] - b[i-1] == d - 1) ++res,++b[i];
    } 
    return res;
}
```
核心实现思想：通过传入公差 `d`，从第三项开始检查相邻两项的差值是否在 `d - 1` 到 `d + 1` 之间，若不在则返回 -1 表示不可行，若在则根据情况调整当前项并记录操作次数。
- **FanYongchen（4星）**
    - **关键亮点**：思路明确，代码完整且注释详细，通过枚举第1、2项的操作方法，求出整一个序列并判断是否可行。
    - **核心代码**：
```cpp
for(int i=0;i<3;i++)
    for(int j=0;j<3;j++)//枚举第1、2项的操作方法 
    {
        memcpy(tmp,a,sizeof(tmp));//先复制数组 
        bool isCan=true;//这种枚举方法是否满足题目要求 
        int sub=tmp[0]+d[i]-(tmp[1]+d[j]);//求出公差 
        tmp[1]+=d[j];//更新第一个数(这里和下面更新数字时不能用原数组) 
        int c=cnt[i]+cnt[j];//共用的次数 
        for(int k=2;k<n;k++)//从第三项开始 
        {
            bool find=false;//对于这个数，判断它是否有一个操作方法，使得可以构成一个等差数列 
            for(int l=0;l<3;l++)//枚举 
                if(tmp[k-1]-(tmp[k]+d[l])==sub)//构成等差数列 
                    {tmp[k]+=d[l]/*更新数字*/;c+=cnt[l]/*累加次数*/;find=true/*记录已经找到*/;break;}
            if(!find) {isCan=false;break;}//若没找到，判定这个第1、2项的方法不能满足题意 
        }
        if(isCan) ans=min(ans,c);//若满足，更新答案 
    }
```
核心实现思想：通过两层循环枚举第1、2项的操作方法，计算出公差，再从第三项开始枚举每个数的三种操作情况，判断是否能构成等差数列，若能则更新最小操作次数。
- **Sophon（4星）**
    - **关键亮点**：思路清晰，代码结构良好，通过枚举a1和a2的9种调整情况，计算通项公式并与原数列对比。
    - **核心代码**：
```cpp
int calc(int a1, int a2, int n)//计算通项公式
{
    return a1 + (n - 1)*(a2 - a1);
}
void work(int a1, int a2, int change)//change 为a1和a2的调整值之和
{
    int temp = 0;
    for (int i = 3; i <= n; i++)//从第三项开始向后遍历原数列
    {
        int t = abs(calc(a1, a2, i) - a[i]);//计算该项需要调整的距离
        if (t > 1)//如果距离超过1，结束
        {
            return;
        }
        else//否则加上调整值
        {
            temp += t;
        }
    }
    temp += change;//加上第一项和第二项的调整值
    ans = min(ans, temp);//取较小值保存
}
for (int i = 0; i < 9; i++)//分九种枚举a1, a2
{
    work(a[1] + moveA1[i], a[2] + moveA2[i], abs(moveA1[i]) + abs(moveA2[i]));
}
```
核心实现思想：通过 `calc` 函数计算等差数列的通项公式，在 `work` 函数中从第三项开始遍历原数列，计算每一项与通项公式的差值，若差值大于1则返回，否则累加调整值，最后更新最小操作次数。

#### 最优关键思路或技巧
- **枚举前两项**：利用等差数列的性质，通过枚举首项和第二项的所有可能变化，确定公差，进而检查整个数列能否通过最多一次操作变为等差数列，将问题的复杂度从指数级降低到线性级。
- **剪枝优化**：在搜索法中，使用最优性剪枝和可行性剪枝可以避免不必要的搜索，提高算法效率。

#### 拓展思路
同类型题或类似算法套路：
- 其他数列变换问题，如将数列变为等比数列、斐波那契数列等，可采用类似的枚举和检查思路。
- 状态压缩动态规划问题，对于一些状态有限且可枚举的问题，可以通过枚举状态并检查可行性来求解。

#### 推荐题目
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：通过枚举和等差数列求和公式求解连续自然数的和。
- [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：动态规划问题，可通过枚举状态并更新最优解来求解。
- [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)：0 - 1背包问题，可通过枚举物品的选择状态并更新最优解来求解。

#### 个人心得摘录与总结
- **nstk0513**：使用暴搜时遇到数据卡掉的情况，通过增加可行性剪枝、最优性剪枝和处理初始序列最大最小差值的优化，提高了算法效率。总结：在使用搜索算法时，要注意数据的特点，合理运用剪枝优化来避免不必要的搜索。
- **liwenxi114514**：介绍了DFS的最优性剪枝和可行性剪枝方法，通过剪枝优化避免了超时问题。总结：在搜索算法中，剪枝优化是提高效率的关键，要根据问题的特点选择合适的剪枝策略。
- **WegestGao**：做完题目后发现可以用三重循环替代DFS，说明不同的算法实现方式可能有不同的复杂度和适用性。总结：在解题时可以尝试多种算法实现方式，选择最适合问题的方法。

---
处理用时：61.62秒
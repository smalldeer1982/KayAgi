# 题目信息

# Подкрутка II

## 题目描述

В этой версии задачи $ n \le 2 \cdot 10^5 $ и $ a_i \le 10^6 $ (а также есть ограничение на сумму $ n $ по наборам входных данных внутри одного теста).

Вика за время работы в компании VK уже сделала $ n $ коммитов в системе контроля версий. $ i $ -й коммит был сделан в $ a_i $ -й день работы Вики в компании. В некоторые дни Вика могла сделать несколько коммитов, а в другие — не сделать ни одного.

Вику интересуют такие отрезки подряд идущих дней, что в каждый из этих дней у неё есть хотя бы один коммит. Чем длиннее будет самый длинный такой отрезок, тем более продуктивным сотрудником она будет себя ощущать.

Недавно Вика нашла способ подкрутить время любого коммита вперёд, но не более чем на сутки. Таким образом, $ i $ -й коммит теперь может быть «сделан» либо в $ a_i $ -й, либо в $ (a_i + 1) $ -й день. Время каждого коммита можно подкрутить независимо от других — в частности, можно как оставить всем коммитам исходное время, так и перенести все коммиты ровно на день вперёд.

Найдите длину самого длинного возможного отрезка подряд идущих дней, в каждый из которых у Вики в профиле будет отображаться хотя бы один коммит, после возможной подкрутки времени некоторых коммитов.

## 样例 #1

### 输入

```
3
9
1 1 3 4 6 6 6 8 10
6
1 2 3 4 5 6
5
10 10 10 10 10```

### 输出

```
5
6
2```

# AI分析结果

### 题目内容重写
**题目描述**

在这道题中，$ n \le 2 \cdot 10^5 $ 且 $ a_i \le 10^6 $（同时有一个限制条件，即在一个测试用例中，所有输入数据的 $ n $ 之和不能超过某个值）。

维卡在公司 VK 工作期间已经提交了 $ n $ 个代码提交。第 $ i $ 个提交是在维卡工作的第 $ a_i $ 天完成的。在某些天，维卡可能提交了多个代码，而在其他天可能没有提交任何代码。

维卡对这样的连续天数区间感兴趣：在这些区间内的每一天，她至少有一个提交。最长的这样的区间越长，她就会觉得自己越有生产力。

最近，维卡找到了一种方法，可以将任何提交的时间向前调整最多一天。因此，第 $ i $ 个提交现在可以“显示”为在第 $ a_i $ 天或第 $ (a_i + 1) $ 天完成。每个提交的时间可以独立调整，也就是说，可以选择不调整任何提交的时间，也可以将所有提交的时间都调整一天。

请找出在调整某些提交的时间后，维卡的工作记录中可能显示的最长连续天数区间的长度，使得在该区间内的每一天，维卡至少有一个提交。

**样例输入**
```
3
9
1 1 3 4 6 6 6 8 10
6
1 2 3 4 5 6
5
10 10 10 10 10
```

**样例输出**
```
5
6
2
```

### 题解分析与结论

#### 题解1：Sorato_ (赞：18)
**星级：5星**
**关键亮点：**
- 通过去重和分块优化，将问题复杂度降低到接近 $O(n)$。
- 详细的分块策略和合并逻辑，确保贪心算法的正确性。
- 提供了贪心算法的严谨证明，确保思路的正确性。

**个人心得：**
- 在实现过程中，通过多次测试和修改，最终找到了正确的贪心策略。
- 强调了贪心算法的正确性证明，确保算法在极端情况下的稳定性。

**核心代码：**
```cpp
// 去重操作
n = read();a[1] = read();
for(reg int i = 2;i <= n;i = -~i)
{
    a[i] = read();
    if(a[i] == a[i - 1] && a[i] == a[i - 2])
        -- i, -- n;
}
```

#### 题解2：Libra_ (赞：9)
**星级：4星**
**关键亮点：**
- 使用动态规划（DP）优化，通过 $O(n)$ 的时间复杂度解决问题。
- 通过维护一个数组 $mp[i]$ 来记录以 $i$ 结尾的最大值，简化了状态转移。

**核心代码：**
```cpp
for (int i=1;i<=n;i++){
    dp[i][0] = f[a[i]-1] + 1;
    dp[i][1] = f[a[i]] + 1;
    f[a[i]] = dp[i][0];
    f[a[i]+1] = dp[i][1];
}
```

#### 题解3：some_side (赞：4)
**星级：4星**
**关键亮点：**
- 通过分段和状态转移，将问题分解为多个子问题。
- 详细讨论了如何合并不同的段，确保连续区间的最大长度。

**核心代码：**
```cpp
for(int i=0; i<vec.size(); i++) {
    dp[i] = vec[i].length;
    if( i>0 && vec[i-1].last+1 == vec[i].first-1 ) {
        if(vec[i-1].yep) dp[i] += dp[i-1]; 
        else dp[i] += vec[i-1].length;
    }
    if(vec[i].yep) dp[i]+=1;
    ans = max(ans, dp[i]);
}
```

### 最优关键思路与技巧
1. **去重与分块**：通过去重减少不必要的计算，并通过分块策略将问题分解为多个子问题，简化了问题的复杂度。
2. **贪心算法**：通过贪心策略确保每一步都选择最优解，最终得到全局最优解。
3. **动态规划优化**：通过维护辅助数组，简化了状态转移，降低了时间复杂度。

### 可拓展之处
- 类似的问题可以通过贪心或动态规划来解决，尤其是涉及到连续区间或子序列的问题。
- 可以通过分块或分段策略，将复杂问题分解为多个简单的子问题，便于处理。

### 推荐题目
1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)

### 个人心得总结
- 在实现贪心算法时，多次测试和修改是确保算法正确性的关键。
- 动态规划的优化可以通过维护辅助数组来简化状态转移，降低时间复杂度。
- 分块策略在处理复杂问题时非常有效，可以将问题分解为多个简单的子问题。

---
处理用时：39.22秒
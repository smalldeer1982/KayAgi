# 题目信息

# Rudolf and the Ball Game

## 题目描述

$n$ 个人站成一个圈，按照顺时针编号依次是 $1$ 到 $n$。

现在这 $n$ 个人玩一个传球游戏，第 $i$ 次传球可以向顺时针方向传给与自己距离为 $d_i$ 的距离，或者向逆时针方向传给与自己距离为 $r_i$ 的距离。

游戏总共进行了 $m$ 轮传球，给你初始拿到球的人的编号 $x$ 和每次传球的方向和距离 $r_i$（有可能方向未知），求出最后可能是谁拿到了球，**按编号从小到大**输出。

------------

## 说明/提示

#### 样例解释
下面是第一个测试用例的三次传球的示意图。箭头表示可能的传球方向。在传球后可能持有球的玩家被标记为灰色。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941D/de43c3cc1c4b12f903e5224359bac3a10205e9a9.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941D/1a47b05e6478f36a49179722556df26c9f84bbc8.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941D/47036b3bd9ad777cfd4d3801abb62bd85bcbcc75.png)

------------

对于 $100\%$ 的数据，$1 \le t \le 1000,1 \le x  \le n \le 1000,1 \le m \le 1000,1 \le n\cdot m \le 2\cdot10^5,1 \le r_i \le n-1$。

## 样例 #1

### 输入

```
5
6 3 2
2 ?
2 ?
2 ?
12 1 2
3 1
10 7 4
2 ?
9 1
4 ?
7 0
2 0
8 1
5 ?
5 3 1
4 0
4 ?
1 ?
4 1 1
2 ?```

### 输出

```
3
2 4 6 
1
11 
4
3 5 7 9 
3
2 3 5 
1
3```

# AI分析结果

### 题目内容重写
#### 题目描述
$n$ 个人站成一个圈，按照顺时针编号依次是 $1$ 到 $n$。

现在这 $n$ 个人玩一个传球游戏，第 $i$ 次传球可以向顺时针方向传给与自己距离为 $d_i$ 的距离，或者向逆时针方向传给与自己距离为 $r_i$ 的距离。

游戏总共进行了 $m$ 轮传球，给你初始拿到球的人的编号 $x$ 和每次传球的方向和距离 $r_i$（有可能方向未知），求出最后可能是谁拿到了球，**按编号从小到大**输出。

### 题解分析与结论

#### 综合分析
本题的核心是通过动态规划或集合操作来模拟传球过程，最终确定哪些人可能拿到球。难点在于处理传球方向不确定的情况，以及如何高效地更新可能拿到球的人员集合。

#### 题解对比
1. **GenesisCrystal** 的题解使用了动态规划，通过二维数组 `dp[i][j]` 表示第 $i$ 次传球后 $j$ 号成员是否可能拿到球。该解法思路清晰，但代码实现较为冗长，且未使用滚动数组优化空间复杂度。
2. **Infinite_Loop** 的题解使用了 `set` 数据结构来维护可能拿到球的人员集合，通过枚举每次传球后的可能位置来更新集合。该解法代码简洁，且利用了 `set` 的去重特性，但空间复杂度较高。
3. **lalaji2010** 的题解同样使用了动态规划，但代码实现较为简洁，且使用了滚动数组优化空间复杂度。该解法在状态转移时处理了传球方向不确定的情况，代码可读性较好。

#### 最优关键思路
- **动态规划**：通过 `dp[i][j]` 表示第 $i$ 次传球后 $j$ 号成员是否可能拿到球，状态转移时根据传球方向更新可能的位置。
- **滚动数组优化**：在动态规划中，使用滚动数组可以减少空间复杂度，只需维护当前轮和上一轮的状态。
- **集合操作**：使用 `set` 数据结构可以方便地维护可能拿到球的人员集合，且自动去重。

#### 可拓展之处
- 类似的问题可以扩展到更复杂的传球规则，如传球方向有多个选择，或者传球距离有多个可能值。
- 可以使用广度优先搜索（BFS）来模拟传球过程，适用于传球规则较为复杂的情况。

#### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 所选高分题解

#### 1. **lalaji2010** (评分：4星)
**关键亮点**：
- 使用了动态规划，且代码实现简洁。
- 使用了滚动数组优化空间复杂度。
- 处理了传球方向不确定的情况，代码可读性较好。

**核心代码**：
```cpp
for(int i=1;i<=m;i++){
    for(int j=1;j<=n;j++){
        if(twd=='0'){
            if(j+dis>n){
                dp[j+dis-n][i]|=dp[j][i-1];
            }else{
                dp[j+dis][i]|=dp[j][i-1];
            }
        }else if(twd=='1'){
            if(j-dis<1){
                dp[j+n-dis][i]|=dp[j][i-1];
            }else{
                dp[j-dis][i]|=dp[j][i-1];
            }
        }else{
            if(j+dis>n){
                dp[j+dis-n][i]|=dp[j][i-1];
            }else{
                dp[j+dis][i]|=dp[j][i-1];
            }
            if(j-dis<1){
                dp[j+n-dis][i]|=dp[j][i-1];
            }else{
                dp[j-dis][i]|=dp[j][i-1];
            }
        }
    }
}
```

#### 2. **Infinite_Loop** (评分：4星)
**关键亮点**：
- 使用了 `set` 数据结构，代码简洁。
- 利用了 `set` 的去重特性，自动处理重复位置。
- 通过枚举每次传球后的可能位置来更新集合，思路清晰。

**核心代码**：
```cpp
set<int>ans;
ans.insert(x);
for(int i=1;i<=m;i++){
    set<int>now;
    if(c[i]=='0'){
        for(auto j:ans){
            int x=(j+r[i]-1)%n+1;
            now.insert(x);
        }
    }else if(c[i]=='1'){
        for(auto j:ans){
            int x=(n+j-r[i]-1)%n+1;
            now.insert(x);
        }
    }else{
        for(auto j:ans){
            int x=(j+r[i]-1)%n+1;
            int y=(n+j-r[i]-1)%n+1;
            now.insert(x);
            now.insert(y);
        }
    }
    ans=now;
}
```

#### 3. **haokee** (评分：4星)
**关键亮点**：
- 使用了滚动数组优化空间复杂度。
- 代码实现简洁，且处理了传球方向不确定的情况。
- 通过 `forward` 和 `reverse` 函数简化了位置计算。

**核心代码**：
```cpp
for(int r; m; m--) {
    cin >> r >> c;
    fill(a + 1, a + n + 1, 0);
    for(int i = 1; i <= n; i++) {
        if(c == '0') {
            a[forward(i, r)] |= f[i];
        } else if(c == '1') {
            a[reverse(i, r)] |= f[i];
        } else {
            a[forward(i, r)] |= f[i];
            a[reverse(i, r)] |= f[i];
        }
    }
    for(int i = 1; i <= n; i++) {
        f[i] = a[i];
    }
}
```

---
处理用时：43.67秒
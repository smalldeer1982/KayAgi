# 题目信息

# Hungry Games

## 题目描述

### 题目大意

Yaroslav 正在玩一款电脑游戏，他的角色遇到了 $n$ 个蘑菇，第 $i$ 个蘑菇的毒性定义为 $a_i$。Yaroslav 可以选择两个整数 $1\le l\le r\le n$，并操控他的角色依次食用第 $l,l+1,\dots,r$ 个蘑菇。

Yaroslav 的角色有一个中毒属性 $g$，初始为 $0$。当他食用第 $i$ 个蘑菇时，$g$ 会增加 $a_i$，若此时 $g$ 超过了一个预设的最大中毒值 $x$，则 $g$ 会重置为 $0$。

Yaroslav 想知道有多少种选择 $l,r$ 的方案能使他的角色食用完蘑菇后，中毒属性 $g$ 不为 $0$。

## 样例 #1

### 输入

```
5
4 2
1 1 1 1
3 2
1 2 3
1 6
10
6 3
1 2 1 4 3 8
5 999999999
999999999 999999998 1000000000 1000000000 500000000```

### 输出

```
8
2
0
10
7```

# AI分析结果

### 题目内容重写
# 饥饿游戏

## 题目描述

### 题目大意

Yaroslav 正在玩一款电脑游戏，他的角色遇到了 $n$ 个蘑菇，第 $i$ 个蘑菇的毒性定义为 $a_i$。Yaroslav 可以选择两个整数 $1\le l\le r\le n$，并操控他的角色依次食用第 $l,l+1,\dots,r$ 个蘑菇。

Yaroslav 的角色有一个中毒属性 $g$，初始为 $0$。当他食用第 $i$ 个蘑菇时，$g$ 会增加 $a_i$，若此时 $g$ 超过了一个预设的最大中毒值 $x$，则 $g$ 会重置为 $0$。

Yaroslav 想知道有多少种选择 $l,r$ 的方案能使他的角色食用完蘑菇后，中毒属性 $g$ 不为 $0$。

### 样例 #1

#### 输入

```
5
4 2
1 1 1 1
3 2
1 2 3
1 6
10
6 3
1 2 1 4 3 8
5 999999999
999999999 999999998 1000000000 1000000000 500000000
```

#### 输出

```
8
2
0
10
7
```

### 题解分析与结论

#### 综合分析与结论

本题的核心在于如何高效地计算满足条件的区间数量。大多数题解采用了动态规划（DP）的思路，结合二分查找或双指针来优化时间复杂度。主要思路是通过找到每个左端点 $l$ 对应的第一个使 $g$ 重置为 $0$ 的右端点 $p$，然后利用 DP 状态转移方程来计算合法区间的数量。

#### 最优关键思路或技巧

1. **动态规划**：通过定义 $dp_i$ 表示以 $i$ 为左端点的合法区间数量，利用状态转移方程 $dp_l = dp_{p+1} + p - l$ 来计算结果。
2. **二分查找**：通过前缀和数组和二分查找快速找到第一个使 $g$ 重置为 $0$ 的右端点 $p$。
3. **双指针**：通过双指针维护当前区间的和，快速找到 $p$，适用于线性时间复杂度的情况。

#### 可拓展之处

- **类似问题**：可以扩展到其他需要计算满足特定条件的区间数量的问题，如区间和、区间最大值等。
- **优化技巧**：在类似的区间问题中，可以考虑使用前缀和、滑动窗口、双指针等技巧来优化时间复杂度。

#### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3382 【模板】线段树 1](https://www.luogu.com.cn/problem/P3382)
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 所选高分题解

#### 题解1：作者：_ZML_ (赞：5)

**星级**：★★★★★

**关键亮点**：
- 使用了动态规划结合二分查找的思路，代码清晰易懂。
- 通过前缀和数组和二分查找快速找到 $p$，优化了时间复杂度。
- 状态转移方程 $dp_l = dp_{p+1} + p - l$ 简洁明了。

**核心代码**：
```cpp
int g(int st) {
    int l = st, r = n, ans = n + 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (sum[mid] - sum[st - 1] > x)
            ans = mid, r = mid - 1;
        else
            l = mid + 1;
    }
    return ans;
}
```

#### 题解2：作者：CNS_5t0_0r2 (赞：2)

**星级**：★★★★

**关键亮点**：
- 使用了双指针法来优化查找 $p$ 的过程，时间复杂度为 $O(n)$。
- 状态转移方程 $dp_l = dp_{p+1} + p - l$ 与题解1一致，但实现方式不同。
- 代码简洁，易于理解。

**核心代码**：
```cpp
for (int l = n; l >= 1; l--) {
    now += a[l];
    while (now > x) {
        p--;
        now -= a[p];
    }
    dp[l] = dp[p + 1] + p - l;
    ans += dp[l];
}
```

#### 题解3：作者：Exp10re (赞：2)

**星级**：★★★★

**关键亮点**：
- 使用了双指针和动态规划的思路，代码结构清晰。
- 通过双指针快速找到 $p$，然后利用 DP 状态转移方程计算合法区间数量。
- 代码实现简洁，易于理解。

**核心代码**：
```cpp
for (int i = n; i >= 1; i--) {
    if (cnt[i] == n + 1) continue;
    else dp[i] = dp[cnt[i] + 1] + 1;
    sum += dp[i];
}
```

### 通用建议与扩展思路

如果所有题解评分均低于4星，建议从以下几个方面进行优化：

1. **代码可读性**：确保代码结构清晰，变量命名合理，注释充分。
2. **时间复杂度**：尽量优化算法的时间复杂度，避免暴力解法。
3. **思路清晰度**：在题解中详细说明解题思路，帮助读者理解算法的核心思想。

通过这些改进，可以提升题解的质量和实用性。

---
处理用时：44.23秒
# 题目信息

# Find Maximum

## 题目描述

Valera 有一个 $n$ 个数的 **非负整数** 数组 $a$ ，其元素分别为 $a_0,a_1,\cdots,a_{n-1}$。同时有一个函数 $f(x)=\sum_{i=0}^{n-1}a_i\cdot bit(i)$，$bit(i)$ 指的是数字 $x$ 在二进制中第 $i$ 位的值是否为 1。

举个例子，当 $n=4,x=11(11=2^0+2^1+2^3)$ 时，$f(x)=a_0+a_1+a_3$。

对于所有 $0\le x \le m$ 的整数 $x$ ，请求出 $f(x)$ 的最大值。

## 说明/提示

- $1 \le n \le 10^5$

- $0 \le a_i \le 10^4$

- $0\le s_i \le 1$

## 样例 #1

### 输入

```
2
3 8
10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
17 0 10 2 1
11010
```

### 输出

```
27
```

# AI分析结果

### 题目内容重写

**题目描述**

Valera 有一个包含 $n$ 个非负整数的数组 $a$，元素分别为 $a_0, a_1, \cdots, a_{n-1}$。同时有一个函数 $f(x) = \sum_{i=0}^{n-1} a_i \cdot bit(i)$，其中 $bit(i)$ 表示数字 $x$ 在二进制中第 $i$ 位的值是否为 1。

例如，当 $n=4, x=11$（$11=2^0 + 2^1 + 2^3$）时，$f(x) = a_0 + a_1 + a_3$。

对于所有 $0 \le x \le m$ 的整数 $x$，请求出 $f(x)$ 的最大值。

**说明/提示**

- $1 \le n \le 10^5$
- $0 \le a_i \le 10^4$
- $0 \le s_i \le 1$

**样例 #1**

**输入**

```
2
3 8
10
```

**输出**

```
3
```

**样例 #2**

**输入**

```
5
17 0 10 2 1
11010
```

**输出**

```
27
```

### 题解分析与结论

#### 综合分析

本题的核心在于如何在给定的二进制位限制下，最大化函数 $f(x)$ 的值。题解中主要采用了**贪心算法**和**动态规划**两种思路。

1. **贪心算法**：由于 $a_i$ 是非负整数，因此在选择二进制位时，尽可能多地选择值为 1 的位，以最大化 $f(x)$ 的值。
2. **动态规划**：通过状态转移方程 $f_i = \max(f_i, f_{i-1} + a_i \cdot s_i)$，逐步计算前 $i$ 位在限制条件下的最大值。

#### 所选题解

1. **作者：WaterSky (赞：3)**
   - **星级：4星**
   - **关键亮点**：结合了贪心和动态规划的思路，通过前缀和预处理和状态转移方程，清晰地解决了问题。
   - **代码实现**：
     ```cpp
     for(int i=1;i<=n;i++) 
         if(S[i]==1) dp[i]=s[i-1]; //预处理
     for(int i=1;i<=n;i++) 
         dp[i]=max(dp[i],dp[i-1]+a[i]*S[i]); //状态转移
     ```

2. **作者：Jr_Zlw (赞：2)**
   - **星级：4星**
   - **关键亮点**：从高位到低位考虑，通过前缀和和枚举每一位为 1 的情况，巧妙地解决了问题。
   - **代码实现**：
     ```cpp
     int res=0,ans=0;for(int i=n-1;~i;--i)if(s[i]=='1'){ans=max(ans,res+a[i]);res+=a[i+1]-a[i];}
     ```

3. **作者：Graphcity (赞：1)**
   - **星级：4星**
   - **关键亮点**：通过动态规划的思路，结合前缀和和状态转移方程，清晰地解决了问题。
   - **代码实现**：
     ```cpp
     for(int i=1;i<=n;++i) if(s[i]==1) f[i]=sum[i-1];
     for(int i=1;i<=n;++i) f[i]=max(f[i],f[i-1]+a[i]*s[i]);
     ```

### 最优关键思路与技巧

1. **贪心算法**：在选择二进制位时，尽可能多地选择值为 1 的位，以最大化 $f(x)$ 的值。
2. **动态规划**：通过状态转移方程逐步计算前 $i$ 位在限制条件下的最大值。
3. **前缀和预处理**：通过前缀和快速计算前 $i$ 位的和，优化了计算过程。

### 可拓展之处

- **类似题目**：可以考虑在更复杂的限制条件下（如某些位必须为 0 或 1）如何最大化 $f(x)$ 的值。
- **算法套路**：贪心和动态规划的结合在解决类似问题时非常有效，可以举一反三。

### 推荐题目

1. **洛谷 P1048**：采药（动态规划）
2. **洛谷 P1060**：开心的金明（动态规划）
3. **洛谷 P1049**：装箱问题（动态规划）

### 个人心得摘录

- **WaterSky**：通过前缀和预处理和状态转移方程，清晰地解决了问题，代码简洁明了。
- **Jr_Zlw**：从高位到低位考虑，通过前缀和和枚举每一位为 1 的情况，巧妙地解决了问题，代码高效。
- **Graphcity**：通过动态规划的思路，结合前缀和和状态转移方程，清晰地解决了问题，代码简洁。

---
处理用时：33.81秒
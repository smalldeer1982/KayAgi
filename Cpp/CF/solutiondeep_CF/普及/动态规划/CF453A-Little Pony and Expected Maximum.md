# 题目信息

# Little Pony and Expected Maximum

## 题目描述

暮暮刚刚在和她的朋友——AJ（苹果杰克）、FS（小蝶）、RD（云宝黛西）玩Ludo游戏。但是她马品没攒够总是输。回到城堡过后，她对游戏用的骰子产生了兴趣。


这个骰子有M面：骰子的第一面有一个点，第二面有两个点，以此类推，第m面含有M点。暮暮确信的是，当掷骰子时，每一面都有1/m的可能性出现，并且每次投掷的概率都是都是独立的。请你帮助她计算掷N次骰子后每次得到的点数中最大值的期望。

## 样例 #1

### 输入

```
6 1
```

### 输出

```
3.500000000000
```

## 样例 #2

### 输入

```
6 3
```

### 输出

```
4.958333333333
```

## 样例 #3

### 输入

```
2 2
```

### 输出

```
1.750000000000
```

# AI分析结果

### 题目内容重写
# 小马与期望最大值

## 题目描述

暮暮刚刚在和她的朋友——AJ（苹果杰克）、FS（小蝶）、RD（云宝黛西）玩Ludo游戏。但是她马品没攒够总是输。回到城堡过后，她对游戏用的骰子产生了兴趣。

这个骰子有M面：骰子的第一面有一个点，第二面有两个点，以此类推，第m面含有M点。暮暮确信的是，当掷骰子时，每一面都有1/m的可能性出现，并且每次投掷的概率都是独立的。请你帮助她计算掷N次骰子后每次得到的点数中最大值的期望。

## 样例 #1

### 输入

```
6 1
```

### 输出

```
3.500000000000
```

## 样例 #2

### 输入

```
6 3
```

### 输出

```
4.958333333333
```

## 样例 #3

### 输入

```
2 2
```

### 输出

```
1.750000000000
```

### 综合分析与结论
本题的核心是计算掷N次骰子后最大值的期望。大多数题解都采用了类似的思路，即通过计算最大值等于某个特定值的概率，然后利用期望的定义进行求和。具体来说，题解们普遍使用了以下公式：
$$
E = \sum_{i=1}^m i \times \left( \left(\frac{i}{m}\right)^n - \left(\frac{i-1}{m}\right)^n \right)
$$
这个公式的核心思想是通过计算最大值小于等于某个值的概率，然后通过差分得到最大值等于某个值的概率，最后加权求和得到期望。

### 所选高分题解
#### 题解1：作者：da32s1da (赞：27)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，直接应用了期望的计算公式，避免了复杂的推导过程。
- **核心代码**：
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
double n,m,ans;
int main(){
    scanf("%lf%lf",&m,&n);
    for(double i=1;i<=m;i++)
        ans+=i*(pow(i/m,n)-pow((i-1)/m,n));
    printf("%.12lf\n",ans);
}
```
- **实现思想**：通过循环遍历所有可能的骰子面数，计算每个面数作为最大值的概率，并加权求和得到期望。

#### 题解2：作者：Steadywelkin (赞：10)
- **星级**：4星
- **关键亮点**：详细解释了期望的计算过程，代码实现较为清晰，使用了自定义的快速幂函数。
- **核心代码**：
```cpp
inline double qpow(double a,ll n){
    double ans=1.00;
    for(;n;n>>=1,a=a*a)
        if(n&1)ans=ans*a;
    return ans;
}
signed main(){
    ll m=read(),n=read();
    for(int i=1;i<=m;i++)
        ans+=(qpow((double)i/m,n)-qpow((double)(i-1)/m,n))*i;
    printf("%lf\n",ans);
    return 0;
}
```
- **实现思想**：通过快速幂函数计算概率，然后加权求和得到期望。

#### 题解3：作者：傅思维666 (赞：7)
- **星级**：4星
- **关键亮点**：从期望的定义出发，详细推导了公式，代码实现简洁。
- **核心代码**：
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
double n,m,ans;
int main(){
    scanf("%lf%lf",&m,&n);
    for(double i=1;i<=m;i++)
        ans+=i*(pow(i/m,n)-pow((i-1)/m,n));
    printf("%.12lf\n",ans);
    return 0;
}
```
- **实现思想**：直接应用期望的计算公式，通过循环遍历所有可能的骰子面数，计算每个面数作为最大值的概率，并加权求和得到期望。

### 最优关键思路或技巧
最优的思路是通过计算最大值小于等于某个值的概率，然后通过差分得到最大值等于某个值的概率，最后加权求和得到期望。这种方法避免了复杂的推导过程，直接应用了期望的定义，代码实现简洁且高效。

### 可拓展之处
这种思路可以推广到其他类似的期望计算问题，例如计算最小值、中位数等的期望。类似的题目可以通过类似的概率计算和期望公式来解决。

### 推荐相似题目
1. [P1654 OSU!](https://www.luogu.com.cn/problem/P1654)
2. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)
3. [P2473 [SCOI2008]奖励关](https://www.luogu.com.cn/problem/P2473)

### 个人心得摘录
- **调试经历**：在计算概率时，注意避免精度问题，尤其是在使用`pow`函数时，确保传入的参数是`double`类型。
- **踩坑教训**：不要直接使用`int`类型进行除法运算，否则会导致精度丢失。
- **顿悟感想**：通过差分计算概率的方法非常巧妙，能够简化复杂的概率计算过程。

---
处理用时：39.78秒
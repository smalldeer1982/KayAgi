# 题目信息

# Three displays

## 题目描述

### 形式化题面

给定一个有两个性质 $s_i$ 和 $c_i$ 的数组，要求在其中选出三个数，满足：

 - $i<j<k$.
 - $s_i<s_j<s_k$.
 - $c_i+c_j+c_k$ 最小.

## 样例 #1

### 输入

```
5
2 4 5 4 10
40 30 20 10 40
```

### 输出

```
90
```

## 样例 #2

### 输入

```
3
100 101 100
2 4 5
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
10 13 11 14 15 12 13 13 18 13
```

### 输出

```
33
```

# AI分析结果

### 题目内容重写
给定一个长度为 \( n \) 的数组，每个元素有两个属性 \( s_i \) 和 \( c_i \)。要求从中选出三个元素，满足：
- \( i < j < k \)
- \( s_i < s_j < s_k \)
- \( c_i + c_j + c_k \) 最小

### 样例
#### 样例 #1
**输入**
```
5
2 4 5 4 10
40 30 20 10 40
```
**输出**
```
90
```

#### 样例 #2
**输入**
```
3
100 101 100
2 4 5
```
**输出**
```
-1
```

#### 样例 #3
**输入**
```
10
1 2 3 4 5 6 7 8 9 10
10 13 11 14 15 12 13 13 18 13
```
**输出**
```
33
```

### 题解分析与结论
本题的核心是通过动态规划（DP）来寻找满足条件的三元组，并计算其最小成本。大多数题解采用了类似的DP思路，即通过状态转移方程来逐步求解。部分题解还引入了权值线段树或树状数组来优化查询效率，将时间复杂度从 \( O(n^2) \) 降低到 \( O(n \log n) \)。

### 精选题解
#### 1. 作者：love_luke (赞：11)
**星级：★★★★★**
**关键亮点：**
- 使用动态规划，状态定义为 \( f[i][k] \)，表示第 \( i \) 个位置被选中作为第 \( k \) 个元素的最小成本。
- 状态转移方程清晰：\( f[i][k] = \min(f[i][k], f[j][k-1] + c[i]) \)，其中 \( s[j] < s[i] \)。
- 代码简洁，易于理解。

**核心代码：**
```cpp
for (i=1;i<=n;++i) {
    f[i][1]=c[i];
    for (k=2;k<=3;++k)
    for (j=1;j<i;++j)
    if (s[j]<s[i]) {
        f[i][k]=min(f[i][k],f[j][k-1]+c[i]);
    }
}
```

#### 2. 作者：Priori_Incantatem (赞：6)
**星级：★★★★☆**
**关键亮点：**
- 状态定义为 \( f[i][j] \)，表示以第 \( i \) 个元素结尾的长度为 \( j \) 的上升子序列的最小成本。
- 状态转移方程清晰：\( f[i][j] = \min\{ f[k][j-1] + c[i] \} \)，其中 \( s[k] < s[i] \)。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
for (int i=1;i<=n;++i) {
    for (int j=1;j<i;++j) {
        if (a[j]>=a[i]) continue;
        f[i][2]=min(f[i][2],f[j][1]+c[i]);
        f[i][3]=min(f[i][3],f[j][2]+c[i]);
    }
    ans=min(ans,f[i][3]);
}
```

#### 3. 作者：Tweetuzki (赞：5)
**星级：★★★★☆**
**关键亮点：**
- 使用动态规划结合权值线段树优化，将时间复杂度从 \( O(n^2) \) 降低到 \( O(n \log n) \)。
- 状态转移方程清晰：\( dp[i][k] = \min(dp[j][k-1]) + c[i] \)，其中 \( s[j] < s[i] \)。
- 代码实现较为复杂，但优化效果显著。

**核心代码：**
```cpp
for (int i=1;i<=n;++i) {
    if (s[i] != 1) dp[i][2] = min(dp[i][2], Query_Tree(1, s[i]-1, 1) + c[i]);
    Update_Tree(s[i], dp[i][1], 1);
}
```

### 最优关键思路
1. **动态规划**：通过状态转移方程逐步求解，状态定义为 \( f[i][k] \)，表示第 \( i \) 个位置被选中作为第 \( k \) 个元素的最小成本。
2. **优化查询**：使用权值线段树或树状数组来优化查询效率，将时间复杂度从 \( O(n^2) \) 降低到 \( O(n \log n) \)。

### 可拓展之处
- **类似问题**：可以扩展到求长度为 \( k \) 的上升子序列的最小成本，只需调整状态转移方程即可。
- **数据结构优化**：在其他需要查询区间最小值的问题中，也可以考虑使用权值线段树或树状数组来优化查询效率。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

### 个人心得摘录
- **调试经历**：在实现权值线段树时，需要注意离散化处理，否则可能导致内存溢出或查询错误。
- **踩坑教训**：在状态转移时，务必确保 \( s[j] < s[i] \) 的条件，否则会导致错误的结果。
- **顿悟感想**：动态规划的核心在于状态的定义和转移方程的推导，理解清楚这两点后，代码实现会变得相对简单。

---
处理用时：43.70秒
# 题目信息

# Colored Portals

## 题目描述

一条直线上有 $n$ 个城市，这些城市的编号为 $1$ 到 $n$。

传送门被用于在城市间移动，传送门有四种颜色：蓝色，绿色，红色和黄色。每一个城市都有两种颜色的传送门。你可以从城市 $i$ 到城市 $j$，当且仅当这两个城市存在同色的传送门（例如，你可以从有红色和蓝色的传送门的城市到有蓝色和绿色传送门的城市），花费 $|i - j|$ 个硬币。

你的任务是回答 $q$ 个询问：计算城市 $x$ 到城市 $y$ 的最小花费。

## 样例 #1

### 输入

```
2
4 5
BR BR GY GR
1 2
3 1
4 4
1 4
4 2
2 1
BG RY
1 2```

### 输出

```
1
4
0
3
2
-1```

# AI分析结果

### 题目翻译
#### 彩色传送门

#### 题目描述
一条直线上有 $n$ 个城市，城市编号从 $1$ 到 $n$。

传送门用于在城市间移动，传送门有四种颜色：蓝色、绿色、红色和黄色。每个城市都有两种颜色的传送门。仅当两个城市存在同色的传送门时（例如，一个有红色和蓝色传送门的城市可以到达有蓝色和绿色传送门的城市），你才能从城市 $i$ 移动到城市 $j$，移动花费为 $|i - j|$ 个硬币。

你的任务是回答 $q$ 个询问：计算从城市 $x$ 到城市 $y$ 的最小花费。

#### 样例 #1
##### 输入
```
2
4 5
BR BR GY GR
1 2
3 1
4 4
1 4
4 2
2 1
BG RY
1 2
```
##### 输出
```
1
4
0
3
2
-1
```

### 综合分析与结论
这些题解主要围绕计算两个城市间通过传送门移动的最小花费问题展开，对于两个城市有相同颜色传送门的情况，可直接计算距离；对于颜色无交集的情况，需寻找中转点。不同题解在思路实现和算法选择上有所差异。
- **思路对比**：
    - 大部分题解（copper_ingot、初星逝者、postpone、GY程袁浩）都采用预处理每个城市左右最近中转点的方法，以 $O(1)$ 处理询问。
    - 封禁用户的题解提出构建图，用 BFS 或更高效的单源最短路径算法求解，但未给出具体代码。
    - Redamancy_Lydic 的题解提出对 6 种字母组合存位置，二分查找计算结果。
- **算法要点**：
    - 预处理左右最近中转点时，多使用数组或 `map` 记录颜色和城市信息。
    - 构建图的方法需处理边的连接和搜索最短路径。
    - 二分查找需对每种字母组合的位置数组进行操作。
- **解决难点**：
    - 如何高效找到中转点是关键，不同题解通过不同的数据结构和遍历方式解决。
    - 处理无解情况也需特别注意。

### 题解评分与选择
| 作者 | 评分 | 关键亮点 |
| ---- | ---- | ---- |
| copper_ingot | 4星 | 思路清晰，代码简洁，通过数组 `pre` 和 `suf` 记录左右最近中转点，快速计算结果。 |
| 初星逝者 | 3星 | 定义反串概念，逻辑较清晰，但代码中边界判断较多。 |
| 封禁用户 | 2星 | 提出构建图和优化思路，但未给出代码实现，缺乏具体细节。 |
| postpone | 3星 | 思路明确，使用 `map` 存储颜色到城市的映射，代码可读性较好。 |
| GY程袁浩 | 3星 | 对颜色情况分析详细，但代码中数组初始化和查找操作较复杂。 |
| Redamancy_Lydic | 3星 | 提出二分查找思路，但未给出具体代码，缺乏实现细节。 |

选择评分 4 星的题解：
- **作者：copper_ingot**
    - **星级**：4星
    - **关键亮点**：思路清晰，代码简洁，通过数组 `pre` 和 `suf` 记录左右最近中转点，快速计算结果。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x7f7f7f7f;
int t, n, q, a[200001], pre[200001], suf[200001], tmp[7];
int get(char b, char c){//转换函数，u和v可以直接到达<=>a[u]+a[v]!=7
    if (b == 'B' && c == 'G') return 1;
    else if (b == 'B' && c == 'R') return 2;
    else if (b == 'B' && c == 'Y') return 3;
    else if (b == 'G' && c == 'R') return 4;
    else if (b == 'G' && c == 'Y') return 5;
    else return 6;
}
int main(){
    scanf("%d", &t);
    while (t--){
        scanf("%d%d", &n, &q);
        for (int i = 1; i <= n; i++){
            string s; cin >> s;
            char b = s[0], c = s[1];
            a[i] = get(b, c);
        }
        for (int i = 1; i <= n; i++) pre[i] = 0, suf[i] = inf;
        memset(tmp, 0, sizeof(tmp));
        for (int i = 1; i <= n; i++){//求pre
            for (int j = 1; j <= 6; j++){
                if (a[i]!= j && a[i] + j!= 7) pre[i] = max(pre[i], tmp[j]);
            }
            tmp[a[i]] = max(tmp[a[i]], i);
        }
        memset(tmp, 0x7f, sizeof(tmp));
        for (int i = n; i >= 1; i--){//求suf
            for (int j = 1; j <= 6; j++){
                if (a[i]!= j && a[i] + j!= 7) suf[i] = min(suf[i], tmp[j]);
            }
            tmp[a[i]] = min(tmp[a[i]], i);
        }
        while (q--){
            int u, v; scanf("%d%d", &u, &v);
            if (u > v) swap(u, v);
            if (a[u] + a[v]!= 7) printf("%d\n", v - u);
            else if (pre[v] > u && suf[u] < v) printf("%d\n", v - u);
            else if (pre[u]!= 0 || suf[v]!= inf){
                if (pre[u] == 0) printf("%d\n", suf[v] * 2 - u - v);
                else if (suf[v] == inf) printf("%d\n", u + v - pre[u] * 2);
                else printf("%d\n", min(suf[v] * 2 - u - v, u + v - pre[u] * 2));
            }
            else puts("-1");
        }
    }
    return 0;
} 
```
**核心实现思想**：
1. `get` 函数将城市的传送门颜色组合转换为数字，方便后续处理。
2. 通过两次遍历分别计算 `pre` 和 `suf` 数组，记录每个城市左右最近的有相同传送门的城市编号。
3. 对于每个询问，根据 `pre` 和 `suf` 数组判断是否可直达或通过中转点到达，计算最小花费。

### 最优关键思路或技巧
- **预处理左右最近中转点**：通过一次从前向后和一次从后向前的遍历，记录每个城市左右最近的中转点，将处理询问的时间复杂度降低到 $O(1)$。
- **颜色组合数字化**：将城市的传送门颜色组合转换为数字，方便比较和处理。

### 拓展思路
同类型题可能会增加传送门颜色种类、城市数量或询问数量，或者改变移动规则。类似算法套路可用于解决有条件限制的路径规划问题，如在图中寻找满足特定条件的最短路径。

### 推荐洛谷题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
3. [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

### 个人心得摘录与总结
- **Redamancy_Lydic**：“`memset` 害死人。” 总结：使用 `memset` 时需注意其使用场景和对数据的影响，避免因使用不当导致错误。 

---
处理用时：44.07秒
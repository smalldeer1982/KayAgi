# 题目信息

# Friends

## 题目描述

有一天，一个叫做伊戈尔-凯的人放弃编程，转攻数学题。一个深秋的夜晚，他坐在桌旁读书，想着数学问题。
书上有着一段话吸引了他的注意：“在任六人中有三个人互相认识或互相不认识。”
伊戈尔完全无法理解为什么至少有六个人。“那对不起，我觉得五个人也一样，”他脑子里开始胡思乱想“让我试试...马克思，利亚，瓦娃--他们互相认识，额..再加一个迪玛和欧莱格，对瓦娃来说他们三个互不认识！哈哈哈哈哈，这个定理就是一个渣渣。”
伊戈尔带着他的5个朋友，让他们记下来，他们中谁互为朋友。现在他想看看这五个人是否真的认识三对或三对不认识的人。

## 样例 #1

### 输入

```
4
1 3
2 3
1 4
5 3
```

### 输出

```
WIN
```

## 样例 #2

### 输入

```
5
1 2
2 3
3 4
4 5
5 1
```

### 输出

```
FAIL
```

# AI分析结果

【题目内容】
### 朋友

#### 题目描述
有一天，一个叫伊戈尔 - 凯的人放弃编程，转而研究数学题。在一个深秋的夜晚，他坐在桌旁读书，思考着数学问题。
书上的一段话吸引了他的注意：“在任意六个人中，有三个人互相认识或互相不认识。”
伊戈尔完全不理解为什么至少需要六个人。“那不好意思，我觉得五个人也一样。”他脑子里开始胡思乱想，“让我试试……马克思、利亚、瓦娃——他们互相认识，嗯……再加一个迪玛和欧莱格，对于瓦娃来说，他们三个互不认识！哈哈哈哈哈，这个定理就是个渣渣。”
伊戈尔带着他的 5 个朋友，让他们记录下彼此谁是朋友。现在他想看看这五个人中是否真的有三对互相认识或三对互相不认识的人。

#### 样例 #1
##### 输入
```
4
1 3
2 3
1 4
5 3
```
##### 输出
```
WIN
```

#### 样例 #2
##### 输入
```
5
1 2
2 3
3 4
4 5
5 1
```
##### 输出
```
FAIL
```

【综合分析与结论】
这些题解主要围绕将问题转化为图论问题，判断一个含 5 个点与 m 条边的无向图中是否至少有 3 个点连通或不连通。思路主要分为两类：
- **度数分析类**：通过统计每个点的度数，根据度数情况判断结果。当所有点度数都为 2 时输出 `FAIL`，否则输出 `WIN`。此方法时间复杂度为 $O(m)$。
- **暴力枚举类**：用二维数组表示点与点之间的连接关系，枚举所有可能的三个点的组合，判断这三个点是否都连通或都不连通。时间复杂度为 $O(5^3)$。

度数分析类思路更优，时间复杂度低，且避免了大量枚举，代码简洁；暴力枚举类思路简单直接，但复杂度相对较高。

【所选的题解】
- **作者：lrq090403（5 星）**
  - 关键亮点：思路清晰，通过分类讨论点的度数情况得出结论，代码简洁，复杂度低。
  - 核心代码：
```cpp
#include<iostream>
using namespace std;
int d[6],m,i,a,b;
int main(){
    cin>>m;
    for(i=1;i<=m;++i){
        cin>>a>>b;
        ++d[a],++d[b];
    }
    for(i=1;i<=5;++i)
        if(d[i]^2){
            printf("WIN");
            return 0;
        }
    printf("FAIL");
    return 0;
}
```
核心实现思想：先统计每个点的度数，再遍历每个点，若有度数不为 2 的点则输出 `WIN`，否则输出 `FAIL`。

- **作者：ncwzdlsd（4 星）**
  - 关键亮点：思路明确，对度数情况的分析简洁明了，代码简洁。
  - 核心代码：
```cpp
for(int i=1;i<=m;i++)
    cin>>a>>b,du[a]++,du[b]++;
for(int i=1;i<=5;i++)
    if(du[i]!=2)
        puts("WIN"),exit(0);
puts("FAIL");
```
核心实现思想：统计每个点的度数，若有度数不为 2 的点则输出 `WIN`，否则输出 `FAIL`。

- **作者：dby_718（4 星）**
  - 关键亮点：思路清晰，代码实现简单易懂。
  - 核心代码：
```cpp
#include<iostream>
using namespace std;
int q[7],n,a,d;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a>>d;
        q[a]++;q[d]++;
    }
    for(int i=1;i<=5;i++){
        if(q[i]!=2){
            cout<<"WIN"<<endl;return 0;
        }
    }
    cout<<"FAIL"<<endl;return 0;
}
```
核心实现思想：统计每个点的度数，若有度数不为 2 的点则输出 `WIN`，否则输出 `FAIL`。

【最优关键思路或技巧】
通过分析图中每个点的度数情况，总结出当所有点度数都为 2 时不存在 3 个点连通或不连通的规律，避免了暴力枚举，将时间复杂度从 $O(5^3)$ 优化到 $O(m)$。

【拓展思路】
同类型题可拓展到判断更大点数的图中是否存在 k 个点连通或不连通的情况。类似算法套路可用于分析图的连通性、团问题等，可根据点的度数、图的结构等特征进行分类讨论。

【推荐题目】
1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：涉及图的拓扑排序，可加深对图结构的理解。
2. [P1347 排序](https://www.luogu.com.cn/problem/P1347)：通过图的关系判断元素之间的顺序，与本题的图论思想有一定关联。
3. [P2853 [USACO06DEC]Cow Picnic S](https://www.luogu.com.cn/problem/P2853)：关于图的遍历和连通性问题，有助于提升图论解题能力。

【个人心得】
- **作者：Cutler**：一开始想用并查集，但发现第二个样例不通过，意识到这里面的坑点，即 a 认识 b，b 认识 c，但 a 不一定认识 c，不能用并查集，转而采用暴力求解。总结：在解题时要仔细分析题目条件，不能盲目套用算法，遇到问题要及时调整思路。 

---
处理用时：31.00秒
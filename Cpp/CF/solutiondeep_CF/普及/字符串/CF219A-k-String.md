# 题目信息

# k-String

## 题目描述

- **题面翻译如下**

如果一个字符串可以被划分为 $k$ 个相同的子串，则称这个字符串为 $k$-string。例如，字符串“aabaabaabaab”同时是 $1$-string, $2$-string和 $4$-string，但它不是 $3$-string, $5$-string 或 $6$-string 等。显然，任何字符串都是 $1$-string。

给你一个由小写英文字母组成的字符串 $s$ 和一个正整数 $k$。你需要将字符串 $s$ 重新排列成一个 $k$-string。

## 样例 #1

### 输入

```
2
aazz
```

### 输出

```
azaz
```

## 样例 #2

### 输入

```
3
abcabcabz
```

### 输出

```
-1
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致，都是先统计字符串中每个字符的出现次数，然后判断这些次数是否都能被 `k` 整除。若都能整除，则将每种字符出现次数除以 `k` 后组成子串，再重复输出 `k` 次该子串；若存在不能整除的情况，则输出 `-1`。

各题解的算法要点都是字符计数和整除判断，解决的难点在于如何高效地统计字符出现次数并进行整除判断，以及在满足条件时正确输出结果。

### 题解评分
- **Jμdge**：3星。代码使用了自定义的输入输出优化，但整体代码风格较复杂，注释较少，影响可读性。
- **Ninelife_Cat**：3星。思路清晰，但代码中使用了不必要的 `while(1)` 循环，增加了代码复杂度。
- **lsr1409111459**：4星。思路清晰，代码简洁易懂，变量命名规范。
- **小杨小小杨**：3星。代码简洁，但使用了较多全局变量，且注释较少。

### 所选题解
- **lsr1409111459**：4星。关键亮点在于思路清晰，代码简洁，变量命名规范，易于理解。
  - **个人心得**：签到题，思路较简单。抓住题目主要信息，注意 SPJ 。

### 重点代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
char s[1010];
int cnt[30],k;
char ans[1010],len=0;
int main()
{
    scanf("%d%s",&k,s);
    for(int i=0;i<strlen(s);i++)cnt[s[i]-'a'+1]++;
    bool flag=true;
    for(int i=1;i<=26;i++)
    {
        if(cnt[i]%k!=0)flag=false;
        cnt[i]/=k;
        for(int j=1;j<=cnt[i];j++)
            ans[++len]='a'+i-1;
    }
    if(flag)
    {
        for(int i=1;i<=k;i++)printf("%s",ans+1);
        printf("\n");
    }
    else printf("-1\n");
    return 0;
}
```
**核心实现思想**：先读入 `k` 和字符串，统计每个字符的出现次数。然后判断每个字符的出现次数是否能被 `k` 整除，若都能整除，则将每种字符出现次数除以 `k` 后组成子串存储在 `ans` 数组中，最后重复输出 `k` 次子串；若存在不能整除的情况，则输出 `-1`。

### 可拓展之处
同类型题可能会有不同的字符串变换规则，例如要求将字符串重新排列成特定模式的字符串，或者在满足一定条件下的最优排列等。类似算法套路都是先统计字符信息，再根据规则进行判断和处理。

### 推荐题目
1. [P1055 ISBN 号码](https://www.luogu.com.cn/problem/P1055)
2. [P1071 潜伏者](https://www.luogu.com.cn/problem/P1071)
3. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)

---
处理用时：24.70秒
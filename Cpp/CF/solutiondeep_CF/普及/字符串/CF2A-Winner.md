# 题目信息

# Winner

## 题目描述

在 Berland 流行着纸牌游戏 `Berlogging`，这个游戏的赢家是根据以下规则确定的：

1. 在每一轮中，玩家获得或失去一定数量的分数，在游戏过程中，分数被记录在 `名称和得分` 行中，其中名字是玩家的名字，得分是在这一轮中获得的分数。得分是负值意味着玩家失去了相应的分数。
2. 如果在比赛结束时只有一名玩家分数最多，他就是获胜者。
3. 如果两名或两名以上的玩家在比赛结束时都有最大的分数 $m$ ，那么其中首先获得至少 $m$ 分的玩家胜利。开始时，每个玩家都是 $0$ 分。


保证在比赛结束时至少有一个玩家的分数为正。

## 样例 #1

### 输入

```
3
mike 3
andrew 5
mike 2
```

### 输出

```
andrew
```

## 样例 #2

### 输入

```
3
andrew 3
andrew 2
mike 5
```

### 输出

```
andrew
```

# AI分析结果

【题目内容】
# 赢家

## 题目描述

在 Berland 流行着纸牌游戏 `Berlogging`，这个游戏的赢家是根据以下规则确定的：

1. 在每一轮中，玩家获得或失去一定数量的分数，在游戏过程中，分数被记录在 `名称和得分` 行中，其中名字是玩家的名字，得分是在这一轮中获得的分数。得分是负值意味着玩家失去了相应的分数。
2. 如果在比赛结束时只有一名玩家分数最多，他就是获胜者。
3. 如果两名或两名以上的玩家在比赛结束时都有最大的分数 $m$ ，那么其中首先获得至少 $m$ 分的玩家胜利。开始时，每个玩家都是 $0$ 分。

保证在比赛结束时至少有一个玩家的分数为正。

## 样例 #1

### 输入

```
3
mike 3
andrew 5
mike 2
```

### 输出

```
andrew
```

## 样例 #2

### 输入

```
3
andrew 3
andrew 2
mike 5
```

### 输出

```
andrew
```

【综合分析与结论】
这些题解的主要思路都是先记录每个玩家的最终得分，找出最大分数，再重新模拟游戏过程，找出最先达到最大分数的玩家。
- **算法要点**：多数题解使用 `map` 来记录玩家的分数，部分题解使用结构体或数组模拟 `map` 的功能。
- **解决难点**：难点在于正确处理多个玩家分数相同且都为最大分数的情况，需要重新模拟游戏过程来确定谁最先达到最大分数。

【题解评分】
- Honor誉：4星。思路清晰，代码简洁，对 `map` 的使用讲解详细。
- sandwich：3星。提供了测试数据，但代码注释不够详细。
- _Blue_：3星。使用了迭代器和双元结构体，思路较独特，但代码复杂度较高。
- purple7：3星。用结构体实现，适合没学过 STL 的同学，但代码较繁琐。
- Idoyt：3星。代码简洁，但注释较少。
- Loner_Knowledge：3星。提供了 STL 和非 STL 两种实现，思路清晰，但代码较长。
- jojoxie：3星。不用 STL，使用 C 语言实现，思路简单直接，但代码较复杂。
- HyperLuXury：2星。使用 Pascal 语言，对于习惯 C++ 的同学不太友好，代码复杂度较高。
- xiaohuang：3星。思路和代码都比较常规，注释较少。

【所选题解】
- Honor誉（4星）
  - **关键亮点**：思路清晰，代码简洁，对 `map` 的使用讲解详细。
  - **个人心得**：无
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> mp,mpp;
int n,a[100001],maxn=-99999999;
string s[100001],s1;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s[i]>>a[i];
        mp[s[i]]+=a[i];//记录数值
    }
    for(int i=1;i<=n;i++)
    {
        maxn=max(maxn,mp[s[i]]);//取最大
    }
    for(int i=1;i<=n;i++)//谁先到达maxn的就取谁
    {
        mpp[s[i]]+=a[i];
        if(mp[s[i]]==maxn&&mpp[s[i]]>=maxn)
        {
            s1=s[i];
            break;
        }
    }
    cout<<s1<<endl;
    return 0;
} 
```
**核心实现思想**：先使用 `mp` 记录每个玩家的最终得分，找出最大分数 `maxn`，再使用 `mpp` 重新模拟游戏过程，找出最先达到 `maxn` 且最终得分也为 `maxn` 的玩家。

【最优关键思路或技巧】
使用 `map` 可以方便地记录玩家的名字和分数，避免了使用数组或结构体时的复杂查找过程。

【拓展思路】
同类型题可以是其他需要记录和统计信息的游戏或竞赛题目，例如多个选手的多轮比赛得分统计，找出获胜者等。类似算法套路可以是使用哈希表（如 `map`）来快速查找和更新信息。

【推荐题目】
- P1093 奖学金
- P1165 日志分析
- P1540 机器翻译

【个人心得摘录】
- purple7：第一次做的时候没有考虑到负数，所以 WA 了最后一个点。所以对思路进行修正。
**总结**：在做题时要考虑到数据的各种情况，特别是负数等特殊情况，避免因考虑不全而导致错误。

---
处理用时：37.93秒
# 题目信息

# Row

## 题目描述

### 读入一个字符串，只含有$01$两种字符，合法则输出"$Yes$",否则输出"$No$"。
### 不合法情况  
$1$.一个为$0$的字符两旁没有$1$。   
$2$.一个为$1$的字符两旁还有$1$。

## 样例 #1

### 输入

```
3
101
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
4
1011
```

### 输出

```
No
```

## 样例 #3

### 输入

```
5
10001
```

### 输出

```
No
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是围绕判断给定的 01 字符串是否满足题目要求的两个条件展开。主要有两种做法：一是直接遍历字符串，逐个字符判断其左右字符是否符合规则；二是通过查找字符串中是否包含特定子串 “000” 和 “11” 来判断。

- **思路对比**：
    - 直接遍历的思路较为直观，按照题目给定的两个不合法条件，对每个字符进行判断，如小恐、Doqin07 等的题解。
    - 查找特定子串的思路则更巧妙，通过发现不合法情况等价于字符串中包含 “000” 或 “11”，利用 `std::string::find` 函数快速判断，如 Anguei、black_trees 等的题解。
- **算法要点**：
    - 直接遍历：需要注意处理字符串边界情况，避免数组越界。
    - 查找子串：要注意在字符串首尾添加 “0”，以处理边界特殊情况。
- **解决难点**：
    - 边界处理：直接遍历的题解需要对字符串的首尾字符单独处理；查找子串的题解通过在首尾添加 “0” 巧妙解决。
    - 逻辑判断：确保判断条件准确无误，避免遗漏或错误判断。

### 所选题解
- **Anguei（5星）**
    - **关键亮点**：思路清晰，不仅给出了 Python 代码，还提供了 C++ 的 `std::string::find` 方法和朴素遍历方法，全面展示了不同的实现思路。
    - **核心代码**：
```cpp
#include <string> 
#include <iostream>

int main()
{
    std::string s;
    std::cin >> s >> s;
    s = "0" + s + "0";
    std::cout << (s.find("000") != std::string::npos || s.find("11") != std::string::npos ? "No" : "Yes");
}
```
核心实现思想：先读取字符串，在字符串首尾添加 “0”，然后使用 `std::string::find` 函数查找 “000” 和 “11” 子串，若找到则输出 “No”，否则输出 “Yes”。

- **black_trees（4星）**
    - **关键亮点**：详细解释了思路，包括特殊情况的处理和使用 `find` 函数的原理，代码结构清晰，有专门的初始化和输出函数。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
void init(string &in){
    in="0"+in;
    in+="0";
}//初始化（给字符加0）
void put(bool f){
    if(f==false){
        puts("No");
    }
    else{
        puts("Yes");
    }
}//输出
string in;
int n;
bool f;//标志变量
int main(){
    ios::sync_with_stdio(false);//cincout加速
    cin.tie(0);//读入加速
    cin>>n>>in;
    init(in);
    if(in.find("000")!=string::npos||in.find("11")!=string::npos){//判断是否合法
        f=false;
    }
    else{
        f=true;
    }
    put(f);//输出
    return 0;
}
```
核心实现思想：先读取字符串，调用 `init` 函数在字符串首尾添加 “0”，然后使用 `find` 函数判断是否包含 “000” 或 “11” 子串，根据结果设置标志变量 `f`，最后调用 `put` 函数输出结果。

- **Arghariza（4星）**
    - **关键亮点**：详细介绍了 `string::find` 函数的用法，并逐步推导不合法字符串的特征，代码简洁明了。
    - **核心代码**：
```cpp
#include <string> 
#include <iostream>
using namespace std;

int n;
string s;

int main() {
    cin >> n >> s;//输入
    s = "0" + s;//头+0
    s = s + "0";//尾+0
    if (s.find("000") != string::npos || s.find("11") != string::npos) cout << "NO";
    else cout << "YES";
}
```
核心实现思想：读取字符串，在字符串首尾添加 “0”，使用 `string::find` 函数判断是否包含 “000” 或 “11” 子串，根据结果输出 “NO” 或 “YES”。

### 最优关键思路或技巧
- **思维方式**：通过分析不合法情况，将问题转化为查找特定子串 “000” 和 “11”，简化了判断逻辑。
- **代码实现技巧**：在字符串首尾添加 “0” 来处理边界特殊情况，避免了复杂的边界判断。

### 可拓展之处
同类型题或类似算法套路：判断字符串是否满足特定规则的题目，都可以先分析不合法情况的特征，将其转化为查找特定子串或满足特定条件的问题。对于边界情况，可以通过添加虚拟元素或单独处理来简化逻辑。

### 推荐洛谷题目
- P1055 [NOIP2008 普及组] ISBN 号码：判断 ISBN 号码是否合法，需要根据特定规则进行字符判断和计算。
- P1071 潜伏者：根据给定的加密规则判断是否能解密出唯一的明文，涉及字符匹配和逻辑判断。
- P1125 [NOIP2008 提高组] 笨小猴：判断一个单词中字母出现次数是否满足特定条件，需要统计字符频率并进行判断。

### 个人心得摘录与总结
- **black_trees**：提到了特殊情况 “001” 和 “100” 若只查找 “000” 会出错，总结出要在字符串首尾添加 “0” 来处理边界问题，提醒我们在处理字符串问题时要注意边界特殊情况。
- **小恐**：表示自己不会 `find` 函数，选择用 `char` 数组直接遍历的方法，说明即使不掌握高级函数，也可以通过基础方法解决问题，但可能代码会更复杂。

---
处理用时：51.02秒
# 题目信息

# Two TVs

## 题目描述

Polycarp 很喜欢看电视。

他写下了他今天所有感兴趣的共   $n\,(1 \le n \le 2 \times 10^5)$ 个电视节目。其中第   $i$ 个电视节目在   $l_i$ 时开始，  $r_i$ 时结束。  $\,(0 \le l_i, r_i \le 10^9)$

Polycarp 有两个电视。他可以同时在两台电视上看两种不同的节目，但他不能在一台电视上同时看两个不同的节目。如果一个节目结束时另一个节目刚好开始，则他不能在一台电视上看这两个节目。他想看完这   $n$ 个节目，请问两台电视足够吗？

## 样例 #1

### 输入

```
3
1 2
2 3
4 5
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4
1 2
2 3
2 3
1 2
```

### 输出

```
NO
```

# AI分析结果

### 题目内容重写

# 两台电视

## 题目描述

Polycarp 很喜欢看电视。

他写下了他今天所有感兴趣的共 $n\,(1 \le n \le 2 \times 10^5)$ 个电视节目。其中第 $i$ 个电视节目在 $l_i$ 时开始，$r_i$ 时结束。$(0 \le l_i, r_i \le 10^9)$

Polycarp 有两台电视。他可以同时在两台电视上看两种不同的节目，但他不能在一台电视上同时看两个不同的节目。如果一个节目结束时另一个节目刚好开始，则他不能在一台电视上看这两个节目。他想看完这 $n$ 个节目，请问两台电视足够吗？

## 样例 #1

### 输入

```
3
1 2
2 3
4 5
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4
1 2
2 3
2 3
1 2
```

### 输出

```
NO
```

### 题解综合分析与结论

本题的核心在于判断是否可以用两台电视安排所有节目，且节目之间不冲突。题解中主要采用了以下几种思路：

1. **模拟法**：通过模拟两台电视的播放过程，记录每台电视的可用时间，逐个检查节目是否可以安排。这种方法直观且易于理解，时间复杂度为 $O(n \log n)$，主要消耗在排序上。
2. **离散化+线段树**：通过离散化处理时间点，利用线段树进行区间修改和查询，判断是否有时间点被超过两个节目覆盖。这种方法虽然复杂度较低，但实现较为复杂，适合对线段树熟悉的选手。
3. **贪心算法**：通过贪心策略，优先使用空闲的电视安排节目，确保每次选择最优的电视进行安排。这种方法与模拟法类似，但更强调策略的选择。

### 所选高分题解

#### 题解1：作者：4526_ (赞：13)  
**星级：★★★★★**  
**关键亮点**：  
- 详细解释了模拟法的思路，强调了排序的重要性。
- 代码简洁明了，注释清晰，易于理解。
- 通过两个变量 `tv1` 和 `tv2` 记录电视的可用时间，逐个检查节目是否可以安排。

**核心代码**：
```cpp
bool cmp(dat a,dat b){
    if(a.l!=b.l) return a.l<b.l;
    return a.r<b.r;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d %d",&pros[i].l,&pros[i].r);
    }
    sort(pros+1,pros+1+n,cmp);
    tv1=tv2=-1;
    for(int i=1;i<=n;++i){
        if(pros[i].l<=tv1&&pros[i].l<=tv2){
            printf("NO");
            return 0;
        }
        if(pros[i].l>tv1) tv1=pros[i].r;
        else if(pros[i].l>tv2) tv2=pros[i].r;
    }
    printf("YES");
    return 0;
}
```

#### 题解2：作者：Dawn_Chase (赞：8)  
**星级：★★★★☆**  
**关键亮点**：  
- 通过贪心策略，优先使用空闲的电视安排节目。
- 代码结构清晰，注释详细，适合初学者理解。
- 强调了排序的必要性，并通过样例解释了贪心策略的正确性。

**核心代码**：
```cpp
bool cmp(node x,node y){
    return x.l<y.l||(x.l==y.l&&x.r<y.r);
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].l,&a[i].r);
    sort(a+1,a+n+1,cmp);
    now1=-1;now2=-1;
    for(int i=1;i<=n;i++){
        if(a[i].l>now1) now1=a[i].r;
        else if(a[i].l<=now1){
            if(a[i].l>now2) now2=a[i].r;
            else{
                printf("NO\n");
                return 0;
            }
        }
    }
    printf("YES\n");
    return 0;
}
```

#### 题解3：作者：Minecraft万岁 (赞：4)  
**星级：★★★★☆**  
**关键亮点**：  
- 通过离散化和线段树的方法，判断是否有时间点被超过两个节目覆盖。
- 代码实现较为复杂，但思路清晰，适合对线段树熟悉的选手。
- 强调了离散化的必要性，并通过线段树进行区间修改和查询。

**核心代码**：
```cpp
inline bool cmp(node x,node y){
    if(x.p!=y.p) return x.p<y.p;
    else return x.val<y.val;
}

int main(){
    read(n);
    for(int i=1;i<=n;i++){
        read(l);read(r);
        a[++hp].p=l;
        a[hp].val=1;
        a[++hp].p=r+1;
        a[hp].val=-1;
    }
    sort(a+1,a+hp+1,cmp);
    for(int i=1;i<=hp;i++){
        tmp+=a[i].val;
        if(tmp>2){
            ok=true;
            break;
        }
    }
    if(ok) puts("NO");
    else puts("YES");
    return 0;
}
```

### 最优关键思路与技巧

1. **排序**：所有题解都强调了按节目开始时间排序的重要性，这是解决问题的关键步骤。
2. **模拟与贪心**：通过模拟或贪心策略，逐个检查节目是否可以安排，确保每次选择最优的电视进行安排。
3. **离散化与线段树**：对于复杂的时间点处理，离散化和线段树是有效的工具，可以高效地进行区间修改和查询。

### 拓展与举一反三

- **类似题目**：  
  1. [P1886 滑动窗口](https://www.luogu.org/problem/P1886)  
  2. [P3372 线段树 1](https://www.luogu.org/problem/P3372)  
  3. [P1908 逆序对](https://www.luogu.org/problem/P1908)

- **调试与顿悟**：  
  - **4526_**：强调了排序的必要性，并通过样例解释了贪心策略的正确性。
  - **Dawn_Chase**：通过样例详细解释了贪心策略的实现过程，适合初学者理解。
  - **Minecraft万岁**：通过离散化和线段树的方法，解决了复杂的时间点处理问题，适合对线段树熟悉的选手。

---
处理用时：50.31秒
# 题目信息

# pSort

## 题目描述

给定一个长度为 $n$ 的数列 $\{a_n\}$，初始时 $\{a_n\} = \{1, 2, \dots, n\}$。位置 $i$ 上的数可以和位置 $i \pm d_i$ 上的数交换。给定一个 $1 \sim n$ 的全排列，问初始的数列可否交换成给定的形式。

## 说明/提示

$1 \le n \le 100$

## 样例 #1

### 输入

```
5
5 4 3 2 1
1 1 1 1 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
7
4 3 5 1 2 7 6
4 6 6 1 6 6 1
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
7
4 2 5 1 3 7 6
4 6 6 1 6 6 1
```

### 输出

```
YES
```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕判断初始数列能否通过给定交换规则变换为目标排列展开，提供了并查集、Floyd算法和DFS三种主要思路。

#### 思路对比
- **并查集**：多数题解采用此思路，将可交换的位置合并到同一集合，最后检查初始位置和目标位置是否在同一集合。其核心在于利用并查集的传递性，即若a能与b交换，b能与c交换，则a能与c交换。
- **Floyd算法**：将问题转化为图的连通性问题，用邻接矩阵表示点与点之间的可达性，通过Floyd算法更新矩阵，判断初始点和目标点是否连通。
- **DFS**：将每个位置抽象为图的节点，能交换的位置之间连边，使用DFS遍历图，标记连通块，判断初始位置和目标位置是否在同一连通块。

#### 算法要点
- **并查集**：实现并查集的基本操作，如查找父节点（`find`）和合并集合（`union`），注意合并时的边界判断。
- **Floyd算法**：使用三重循环更新邻接矩阵，通过位运算判断可达性。
- **DFS**：使用递归函数遍历图，标记已访问节点，将同一连通块的节点标记为相同颜色。

#### 解决难点
- 如何将交换问题转化为图论问题，找到合适的数据结构和算法解决。
- 处理边界条件，避免越界访问。

#### 题解评分
| 作者 | 思路清晰度 | 代码可读性 | 优化程度 | 综合评分 |
| ---- | ---- | ---- | ---- | ---- |
| 赤霞QvQ | 清晰，详细解释了并查集思路和规律推导 | 高，代码注释清晰 | 一般 | 4星 |
| PDY08 | 较清晰，说明了Floyd算法思路和位运算应用 | 高，代码简洁 | 一般 | 4星 |
| Mistybranch | 清晰，用图示解释并查集思路 | 高，代码注释详细 | 一般 | 4星 |
| 初雪_matt | 一般，思路表述不够清晰 | 一般，代码有部分细节未解释 | 一般 | 3星 |
| Error_Eric | 清晰，对比了并查集和DFS复杂度 | 高，代码有快读优化 | 较高 | 4星 |
| Lates | 清晰，用样例图解释思路 | 高，代码注释详细 | 一般 | 4星 |
| mot1ve | 清晰，说明了并查集的应用原理 | 高，代码简洁 | 一般 | 4星 |
| ahawzlc | 清晰，思路简洁明了 | 高，代码注释清晰 | 一般 | 4星 |
| Refined_heart | 清晰，说明了并查集的维护方法 | 高，代码注释详细 | 一般 | 4星 |
| 梦游的小雪球 | 较清晰，思路简单直接 | 高，代码简洁 | 一般 | 4星 |
| yimuhua | 清晰，说明了并查集思路和边界判断 | 高，代码注释清晰 | 一般 | 4星 |
| happy_dengziyue | 清晰，用样例解释并查集思路 | 一般，代码查找父节点未优化 | 一般 | 3星 |
| Oscar12345 | 较清晰，说明了Floyd算法思路 | 高，代码有注释 | 一般 | 4星 |

#### 所选题解
- **赤霞QvQ（4星）**
    - **关键亮点**：详细推导了相邻元素可交换能得到全排列的规律，清晰解释了并查集的应用。
    - **个人心得**：“本蒟蒻想了好久也没想出来，看到算法标签才顿悟：这个并查集藏得好深！”，说明从算法标签中获取思路的重要性。
```cpp
int father(int x) {
    if(fa[x]!=x) fa[x]=father(fa[x]);
    return fa[x];
}

void un(int x,int y) {
    int u=father(x),v=father(y);
    if(u!=v) fa[u]=v; 
}

int main() {
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>f[i];
        fa[i]=i;
    }
    for(int i=1;i<=n;i++) {
        cin>>d[i];
        if(i>d[i]) un(i,i-d[i]);
        if(i+d[i]<=n) un(i,i+d[i]);
    }
    for(int i=1;i<=n;i++) {
        if(father(i)!=father(f[i])) {
            cout<<"NO"<<endl;
            return 0;
        }
    }
    cout<<"YES"<<endl;
    return 0;
}
```
核心思想：通过并查集合并可交换的位置，最后检查初始位置和目标位置是否在同一集合。

- **PDY08（4星）**
    - **关键亮点**：使用Floyd算法解决问题，代码简洁，解释了位运算的应用。
```cpp
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            b[i][j] |= (b[i][k] & b[j][k]) | (b[i][k] & b[k][j]);
        }
    }
}
for (int i = 1; i <= n; i++) {
    if (!b[i][a[i]]) {
        cout << "No";
        return 0;
    }
}
cout << "Yes";
```
核心思想：通过Floyd算法更新邻接矩阵，判断初始点和目标点是否连通。

- **Error_Eric（4星）**
    - **关键亮点**：对比了并查集和DFS的复杂度，使用DFS实现，代码有快读优化。
```cpp
void dfs(int x,int col) {
    for(rei i=0;i<u[x].size();i++)
        if(!c[u[x][i]])
            c[u[x][i]]=col,dfs(u[x][i],col);
}

int main() {
    readln(n);
    for(rei i=1;i<=n;i++)readln(f[i]);
    for(rei j=1;j<=n;j++) {
        readln(d[j]);
        if(j-d[j]>=1)u[j-d[j]].push_back(j),u[j].push_back(j-d[j]);
        if(j+d[j]<=n)u[j+d[j]].push_back(j),u[j].push_back(j+d[j]);
    }
    for(rei i=1;i<=n;i++)if(!c[i])c[i]=++top,dfs(i,top);
    for(rei i=1;i<=n;i++)if(c[i]!=c[f[i]])return puts("NO"),0;
    return puts("YES"),0;
}
```
核心思想：使用DFS遍历图，标记连通块，判断初始位置和目标位置是否在同一连通块。

#### 最优关键思路或技巧
- **思维方式**：将交换问题转化为图论问题，利用图的连通性解决问题。
- **数据结构**：并查集是解决此类具有传递关系问题的有效数据结构。
- **代码实现技巧**：使用位运算在Floyd算法中判断可达性，提高代码效率。

#### 可拓展之处
同类型题或类似算法套路：
- 其他图的连通性问题，如判断无向图是否连通、计算连通分量个数等。
- 涉及元素交换和位置变换的问题，可考虑使用并查集或图论算法解决。

#### 推荐题目
- [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：并查集基础题，判断两个人是否有亲戚关系。
- [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)：并查集模板题，练习并查集的基本操作。
- [P2814 家谱](https://www.luogu.com.cn/problem/P2814)：并查集应用，查找人物的祖先。

#### 个人心得摘录与总结
- 赤霞QvQ：看到算法标签才顿悟并查集的应用，说明算法标签可作为解题思路的重要提示。
- Error_Eric：认为DFS比并查集更快更好理解，强调不同算法在复杂度和实现难度上的差异，解题时可根据具体情况选择合适的算法。 

---
处理用时：46.75秒
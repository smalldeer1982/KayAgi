# 题目信息

# Arpa's weak amphitheater and Mehrdad's valuable

## 题目描述

有 $n$ 个人 $(1\le n\le1000)$。每个人有一个重量 $w_i(1\le w_i\le 1000)$ 和一个魅力值 $b_i(1\le b_i\le 10^6)$。 $n$ 个人之间有 $m(1\le m\le\min(\frac{n\times(n-1)}{2}, 10^5))$ 个关系。第 $i$ 个关系由两个数字 $x_i$ 和 $y_i$ 组成，表示第 $x_i$ 个人和第 $y_i$ 个人是朋友，朋友关系是双向的。

已知若 $a$ 和 $b$ 是朋友，$b$ 和 $c$ 是朋友，则 $a$ 和 $c$ 是朋友。 现在 Mehrdad 要邀请一些人来到派对，使这些人的重量总和不超过 $w\ (1\le w\le1000)$，且魅力值总和尽量大。同一个朋友圈里的人，只能邀请其中的一个人，或者全部人，或者一个人也不邀请。

## 样例 #1

### 输入

```
3 1 5
3 2 5
2 4 2
1 2
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4 2 11
2 4 6 6
6 4 2 1
1 2
2 3
```

### 输出

```
7
```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，都采用并查集维护朋友关系，分组背包求解最大魅力值。先通过并查集将朋友划分到不同组，再把每组所有人的重量和魅力值总和作为一个新元素加入组中，最后用分组背包解决选择问题。

### 题解对比
|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|星空记逸|用并查集维护朋友关系，将每组所有人的总和作为新元素，转化为分组背包问题|并查集路径压缩、分组背包动态规划|处理一人一组的情况|5星|
|李尧|把同一个并查集内元素放一组，将组内元素总和作为组中一个元素|并查集构建、分组背包|避免一人组重复添加总和|4星|
|珅肐|用并查集合并朋友，将全选情况打包成新人，注意一人组不添加新人|并查集操作、分组背包|处理一人组添加新人问题|4星|

### 所选题解
- **星空记逸（5星）**
    - **关键亮点**：思路清晰，详细解释如何将问题转化为分组背包，代码注释详细。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    if(gr[i][0]>1){ //一组中人数大于一 
        gr[i][0]++,js++;
        gr[i][gr[i][0]]=js;
        for(int j=1;j<gr[i][0];j++){
            w[js]+=w[gr[i][j]];
            b[js]+=b[gr[i][j]]; //将该组总和作为一个新选择加入 
        }
    }
}
for(int i=1;i<=n;i++){
    if(!gr[i][0]) continue;
    for(int j=wi;j>=0;j--)
        for(int k=1;k<=gr[i][0];k++){
            int no=gr[i][k]; //当前点下标 
            if(j-w[no]>=0)
                f[j]=max(f[j],f[j-w[no]]+b[no]); //分组背包板子 
        }			
}
```
    - **核心思想**：先将每组所有人的重量和魅力值总和作为新元素加入组中，再进行分组背包动态规划。

- **李尧（4星）**
    - **关键亮点**：详细解释各数组用途，避免一人组重复添加总和。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int p=find(i);
    if(a[p]==0) a[p]=++cnt;//新建组别，通过标志数帮每一个元素找到自己的组别
    d[a[p]][++num[a[p]]]=i;//为组别内加元素
    totw[a[p]]+=w[i];totb[a[p]]+=b[i];//更新该组别总重，总魅力
}
for(int i=1;i<=cnt;i++){
    if(!(totw[i]==w[d[i][1]]&&totb[i]==b[d[i][1]])){//上面的注意点
        d[i][++num[i]]=n+1;//将组别的总和作为最后一个元素加入组别
        w[n+1]=totw[i];b[n+1]=totb[i];
    }
    for(int v=wt;v>=0;v--)
        for(int j=1;j<=num[i];j++)
            if(v>=w[d[i][j]])
                f[v]=max(f[v],f[v-w[d[i][j]]]+b[d[i][j]]);//熟悉的背包
}
```
    - **核心思想**：将同一并查集内元素分组，更新组内总重和总魅力，将组内元素总和作为新元素加入非一人组，最后进行分组背包。

- **珅肐（4星）**
    - **关键亮点**：使用`vector`实现分组，强调一人组不添加新人的坑点。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i)ve[find(i)].push_back(i);//这里用i的祖先来表示他所属的分组
for(int i=1;i<=n;++i){
    if(ve[i].size()<=1)continue;//如果只有一个人或者没有的话，不可以添加新人。
    ve[i].push_back(++p);//p是人数，初始化为n
    for(int j=0;j<ve[i].size()-1;++j)w[p]+=w[ve[i][j]],v[p]+=v[ve[i][j]];//新人加和
}
for(int k=1;k<=n;++k){//普通的分组背包
    if(!ve[k].size())continue;
    for(int j=W;j>=0;--j)
        for(int i=0;i<ve[k].size();++i){
            int o=ve[k][i];//o是编号
            if(j>=w[o])f[j]=max(f[j],f[j-w[o]]+v[o]);
        }
}
```
    - **核心思想**：用并查集分组，将每组所有人总和作为新元素加入非一人组，最后进行分组背包。

### 最优关键思路与技巧
- **数据结构**：使用并查集维护朋友关系，能高效处理传递性的朋友关系；使用`vector`存储分组信息，方便操作。
- **思维方式**：将每组所有人的总和作为新元素，把问题转化为经典的分组背包问题。
- **代码实现技巧**：通过判断组内人数，避免一人组重复添加总和。

### 拓展思路
同类型题可拓展到其他资源分配问题，如不同项目团队，每个团队成员有不同能力值和成本，要求在总成本限制下选择团队成员使总能力值最大，同样可使用并查集和分组背包解决。

### 洛谷推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)
3. [P2066 机器分配](https://www.luogu.com.cn/problem/P2066)

### 个人心得摘录与总结
- **zyc____**：提到本题有两个坑点，一是用并查集判连通块，二是判完要分开dp，自己想了很久。总结：在解决此类综合问题时，要注意不同算法的衔接和细节处理。
- **李尧**：提醒注意一人组不要把组内元素总和加入分组背包。总结：做题时要仔细考虑特殊情况，避免掉入陷阱。
- **珅肐**：强调分组内只有一人时不可以添加新人。总结：对于特殊情况要特别处理，防止错误。 

---
处理用时：37.19秒
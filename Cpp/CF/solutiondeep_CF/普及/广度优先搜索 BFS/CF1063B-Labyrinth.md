# 题目信息

# Labyrinth

## 题目描述

## 题意描述
你正在玩一款电脑游戏。在其中一关，你位于一个 $n$ 行 $m$ 列的迷宫。每个格子要么是可以通过的空地，要么是障碍。迷宫的起点位于第 $r$ 行第 $c$ 列。你每一步可以向上、下、左、右中的一个方向移动一格，前提是那一格不是障碍。你无法越出迷宫的边界。

不幸的是，你的键盘快坏了，所以你只能向左移动不超过 $x$ 格，并且向右移动不超过 $y$ 格。因为上下键情况良好，所以对向上和向下的移动次数没有限制。

现在你想知道在满足上述条件的情况下，从起点出发，有多少格子可以到达（包括起点）？

## 样例 #1

### 输入

```
4 5
3 2
1 2
.....
.***.
...**
*....
```

### 输出

```
10
```

## 样例 #2

### 输入

```
4 4
2 2
0 1
....
..*.
....
....
```

### 输出

```
7
```

# AI分析结果

### 题目内容重写（中文）

**迷宫**

#### 题目描述

你正在玩一款电脑游戏。在其中一关，你位于一个 $n$ 行 $m$ 列的迷宫。每个格子要么是可以通过的空地，要么是障碍。迷宫的起点位于第 $r$ 行第 $c$ 列。你每一步可以向上、下、左、右中的一个方向移动一格，前提是那一格不是障碍。你无法越出迷宫的边界。

不幸的是，你的键盘快坏了，所以你只能向左移动不超过 $x$ 格，并且向右移动不超过 $y$ 格。因为上下键情况良好，所以对向上和向下的移动次数没有限制。

现在你想知道在满足上述条件的情况下，从起点出发，有多少格子可以到达（包括起点）？

#### 样例 #1

##### 输入

```
4 5
3 2
1 2
.....
.***.
...**
*....
```

##### 输出

```
10
```

#### 样例 #2

##### 输入

```
4 4
2 2
0 1
....
..*.
....
....
```

##### 输出

```
7
```

---

### 题解综合分析

本题的核心在于如何在有限制的移动次数内进行广度优先搜索（BFS），并确保每个点的左右移动次数不超过给定的限制。多个题解都采用了BFS的思路，但处理左右移动次数限制的方式有所不同。以下是几个关键点：

1. **BFS与状态记录**：大多数题解使用BFS进行遍历，并通过记录每个点的左右移动次数来确保不超出限制。
2. **剪枝优化**：部分题解通过剪枝优化，避免重复访问同一状态，减少不必要的计算。
3. **双端队列（Deque）**：一些题解使用双端队列来处理不同移动方向的优先级，确保上下移动优先于左右移动。
4. **状态更新**：部分题解在访问同一节点时，比较当前路径的左右移动次数与之前记录的次数，选择更优的路径继续搜索。

### 评分较高的题解

#### 1. 作者：ImmortalWatcher (赞：28)  
**星级：4.5**  
**关键亮点**：  
- 使用BFS进行遍历，记录每个点的左右移动次数，确保不超出限制。
- 通过剪枝优化，避免重复访问同一状态，减少不必要的计算。
- 代码简洁，逻辑清晰。

**核心代码片段**：
```cpp
while(st<en)
{
    st++;
    for (int i=1;i<=4;i++)
    {
        xx=d[st][1]+fx[i][1];
        yy=d[st][2]+fx[i][2];
        if (i==3&&d[st][4]-1<0) continue;
        if (i==4&&d[st][5]-1<0) continue;
        if (xx>0&&xx<=n&&yy>0&&yy<=m&&bz[xx][yy]==false&&a[xx][yy]=='.')
        {
            d[++en][1]=xx;
            d[en][2]=yy;
            d[en][3]=d[st][3]+1;
            if (i==3) d[en][4]=d[st][4]-1;
            else d[en][4]=d[st][4];
            if (i==4) d[en][5]=d[st][5]-1;
            else d[en][5]=d[st][5];
            ans++;
            bz[xx][yy]=true;
        }
    } 
}
```

#### 2. 作者：DDOSvoid (赞：21)  
**星级：4.0**  
**关键亮点**：  
- 使用双端队列（Deque）进行BFS，确保上下移动优先于左右移动。
- 通过记录每个点的左右移动次数，确保不超出限制。

**核心代码片段**：
```cpp
while(!Q.empty()){
    node t = Q.front(); Q.pop_front();
    for(int i = 1; i <= 4; ++i){
        int x = t.x + dx[i], y = t.y + dy[i]; 
        if(x < 1 || x > n || y < 1 || y > m || ma[x][y]) continue;
        if(dis[x][y] != -1 && dis[x][y] <= dis[t.x][t.y] + (i == 4)) continue;
        dis[x][y] = dis[t.x][t.y] + (i == 4);
        if(i == 4) Q.push_back(node(x, y));
        else Q.push_front(node(x, y)); 
    }
}
```

#### 3. 作者：mot1ve (赞：11)  
**星级：4.0**  
**关键亮点**：  
- 使用双端队列（Deque）进行BFS，确保上下移动优先于左右移动。
- 通过记录每个点的左右移动次数，确保不超出限制。

**核心代码片段**：
```cpp
while(!q.empty())
{
    node p;
    p=q.front();
    q.pop_front();
    if(vis[p.x][p.y]==1||(p.l<0)||(p.r<0)) continue;
    vis[p.x][p.y]=1;
    ans++;
    for(int i=0;i<4;i++)
    {
        int dx=p.x+xx[i];
        int dy=p.y+yy[i];
        if(dx<=0||dx>n||dy<=0||dy>m||s[dx][dy]=='*'||vis[dx][dy]==1) continue;
        if(i==0||i==1)
        {
            q.push_front((node){dx,dy,p.l,p.r});
            continue;
        }
        if(i==2)
        {
            q.push_back((node){dx,dy,p.l-1,p.r});
            continue;
        }
        if(i==3)
        {
            q.push_back((node){dx,dy,p.l,p.r-1});
        }
    }
}
```

### 最优关键思路与技巧

1. **双端队列（Deque）**：在处理不同移动方向的优先级时，使用双端队列可以确保上下移动优先于左右移动，从而优化搜索顺序。
2. **状态记录与剪枝**：通过记录每个点的左右移动次数，并在访问同一节点时比较当前路径的左右移动次数与之前记录的次数，选择更优的路径继续搜索，避免重复计算。
3. **BFS的灵活应用**：在BFS中灵活处理不同移动方向的限制，确保搜索过程中不超出给定的移动次数。

### 可拓展之处

1. **类似问题**：可以扩展到其他有限制条件的搜索问题，如在某些方向上有移动次数限制的迷宫问题。
2. **其他优化**：可以考虑使用A*算法或其他启发式搜索算法，进一步优化搜索效率。

### 推荐题目

1. **P1162 填涂颜色**（考察BFS的基本应用）
2. **P1443 马的遍历**（考察BFS在棋盘上的应用）
3. **P1135 奇怪的电梯**（考察有限制条件的BFS）

### 个人心得摘录

- **ImmortalWatcher**：在BFS中，记录每个点的左右移动次数并进行剪枝优化，可以有效减少不必要的计算，提高代码效率。
- **DDOSvoid**：使用双端队列处理不同移动方向的优先级，确保上下移动优先于左右移动，可以优化搜索顺序。
- **mot1ve**：在BFS中，通过记录每个点的左右移动次数，并在访问同一节点时比较当前路径的左右移动次数与之前记录的次数，选择更优的路径继续搜索，避免重复计算。

---
处理用时：60.82秒
# 题目信息

# Drunken Maze

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041D/ac90366c626ba21a7610cf55d06b2398a53105ff.png) Image generated by ChatGPT 4o.You are given a two-dimensional maze with a start and end position. Your task is to find the fastest way to get from the start to the end position. The fastest way is to make the minimum number of steps where one step is going left, right, up, or down. Of course, you cannot walk through walls.

There is, however, a catch: If you make more than three steps in the same direction, you lose balance and fall down. Therefore, it is forbidden to make more than three consecutive steps in the same direction. It is okay to walk three times to the right, then one step to the left, and then again three steps to the right. This has the same effect as taking five steps to the right, but is slower.

## 样例 #1

### 输入

```
7 12
############
#S........T#
#.########.#
#..........#
#..........#
#..#..#....#
############```

### 输出

```
15```

## 样例 #2

### 输入

```
5 8
########
#......#
#.####.#
#...T#S#
########```

### 输出

```
14```

## 样例 #3

### 输入

```
5 8
########
#.#S...#
#.####.#
#...T#.#
########```

### 输出

```
-1```

# AI分析结果

### 题目重写

#### 题目描述

你被给定一个二维迷宫，包含起点和终点。你的任务是找到从起点到终点的最快路径。最快路径是指步数最少的路径，其中一步可以是向左、向右、向上或向下移动。当然，你不能穿过墙壁。

然而，有一个限制条件：如果你在同一方向上连续移动超过三步，你会失去平衡并摔倒。因此，禁止在同一方向上连续移动超过三步。你可以向右移动三步，然后向左移动一步，再向右移动三步。这与连续向右移动五步的效果相同，但速度更慢。

#### 样例 #1

##### 输入

```
7 12
############
#S........T#
#.########.#
#..........#
#..........#
#..#..#....#
############
```

##### 输出

```
15
```

#### 样例 #2

##### 输入

```
5 8
########
#......#
#.####.#
#...T#S#
########
```

##### 输出

```
14
```

#### 样例 #3

##### 输入

```
5 8
########
#.#S...#
#.####.#
#...T#.#
########
```

##### 输出

```
-1
```

### 题解分析与结论

#### 综合分析与结论

本题的核心在于在迷宫中寻找从起点到终点的最短路径，同时需要满足在同一方向上连续移动不超过三步的限制。题解中主要采用了BFS（广度优先搜索）和Dijkstra算法来解决这个问题。以下是各题解的要点和难点对比：

1. **ccjjxx的题解**：
   - **思路**：使用BFS，记录每个状态的方向和连续移动步数，当连续移动步数达到4时，需要换方向或后退一步再前进两步。
   - **难点**：处理连续移动步数超过3的情况，需要额外的逻辑来保证路径的有效性。
   - **优化**：通过优先队列处理相同位置、相同步数但方向不同的点，确保所有可能的路径都被考虑。
   - **评分**：4星，思路清晰，代码实现较为复杂但有效。

2. **FwbAway的题解**：
   - **思路**：使用BFS，记录每个点的坐标、方向和连续移动步数，确保每个状态只被访问一次。
   - **难点**：如何剪枝优化，避免重复访问相同状态。
   - **优化**：通过记录每个点的方向和连续移动步数，减少状态数，提高搜索效率。
   - **评分**：4星，思路清晰，代码简洁，优化有效。

3. **沉石鱼惊旋的题解**：
   - **思路**：使用BFS，记录每个点的坐标、方向和连续移动步数，确保每个状态只被访问一次。
   - **难点**：如何高效地记录和更新状态。
   - **优化**：通过状态压缩和剪枝，减少搜索空间。
   - **评分**：3星，思路清晰，但代码实现较为复杂，优化效果一般。

#### 最优关键思路或技巧

- **状态记录**：在BFS中，除了记录坐标外，还需要记录当前移动的方向和连续移动的步数，以确保不违反连续移动步数的限制。
- **剪枝优化**：通过记录每个状态的方向和连续移动步数，避免重复访问相同状态，提高搜索效率。
- **优先队列**：使用优先队列处理相同位置、相同步数但方向不同的点，确保所有可能的路径都被考虑。

#### 可拓展之处

- **类似问题**：可以扩展到其他带有移动限制的迷宫问题，如限制总步数、限制特定方向的步数等。
- **算法套路**：BFS和Dijkstra算法在处理带有状态限制的最短路径问题时非常有效，可以应用于其他类似问题。

#### 推荐题目

1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 所选高分题解

#### 题解1：ccjjxx (4星)

**关键亮点**：
- 使用BFS，记录每个状态的方向和连续移动步数。
- 通过优先队列处理相同位置、相同步数但方向不同的点，确保所有可能的路径都被考虑。
- 代码实现较为复杂但有效，能够处理连续移动步数超过3的情况。

**核心代码**：
```cpp
priority_queue<node>q;
int dx[5]={0,0,1,-1,0};
int dy[5]={0,1,0,0,-1};
inline int man(int a,int b,int x,int y)
{
	return abs(a-b)+abs(x-y);
}
signed main()
{
	cin>>n>>m;
	vector<vector<bool>> vis(n+5,vector<bool>(m+5,0)),mp(n+5,vector<bool>(m+5,0));
	for(int i=1;i<=n;i++)
	{
		string c;cin>>c;
		for(int j=0;j<m;j++) 
		{
			mp[i][j+1]=0,vis[i][j+1]=0;
			if(c[j]=='#') mp[i][j+1]=1;
			if(c[j]=='S') stx=i,sty=j+1;
			if(c[j]=='T') edx=i,edy=j+1;
		}
	}
	q.push({stx,sty,0,man(stx,sty,edx,edy),0,0});
	int ans=1e9;
	while(!q.empty())
	{
		node now=q.top();q.pop();
		
		if(now.x==edx&&now.y==edy)
		{
			ans=min(ans,now.val);
			break;
		}
		if(vis[now.x][now.y]) continue;
		vis[now.x][now.y]=1;
		bool tt=0;
		do
		{
			if(tt) now=q.top(),q.pop();
			tt=1;
			for(int i=1;i<=4;i++)
			{
				node nxt=now;
				nxt.x+=dx[i],nxt.y+=dy[i];
				if(nxt.x<1||nxt.y<1||nxt.x>n||nxt.y>m||mp[nxt.x][nxt.y]) continue;
				if(i==nxt.prepos) nxt.pre++;
				else nxt.pre=0;
				nxt.val++;
				if(nxt.pre==3) 
				{
					if(i==2||i==3)
					{
						node nxx=now;
						nxx.x+=dx[1],nxx.y+=dy[1];
						if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
						{
							nxt.pre=0,nxt.val+=2;
						}
						else
						{
							nxx=now;
							nxx.x+=dx[4],nxx.y+=dy[4];
							if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
								nxt.pre=0,nxt.val+=2;
							else nxt.val+=2,nxt.pre=1;
						}
					}
					else
					{
						node nxx=now;
						nxx.x+=dx[2],nxx.y+=dy[2];
						if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
						{
							nxt.pre=0,nxt.val+=2;
						}
						else
						{
							nxx=now;
							nxx.x+=dx[3],nxx.y+=dy[3];
							if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
								nxt.pre=0,nxt.val+=2;
							else nxt.val+=2,nxt.pre=1;
						}
					}
				}
				else nxt.prepos=i;
				nxt.f=nxt.val+man(nxt.x,nxt.y,edx,edy);
				q.push(nxt);
			}
		}while(q.top().x==now.x&&q.top().y==now.y&&q.top().val==now.val&&q.top().prepos!=now.prepos);
	}
	if(ans==1e9)
	cout<<"-1";
	else cout<<ans;
}
```

#### 题解2：FwbAway (4星)

**关键亮点**：
- 使用BFS，记录每个点的坐标、方向和连续移动步数。
- 通过记录每个点的方向和连续移动步数，减少状态数，提高搜索效率。
- 代码简洁，优化有效。

**核心代码**：
```c++
if(/*该点合法*/){
  //t为方向，s是步数
  //超出三步或已访问过时不需判断
  //可以用t和i的关系处理出 dis 值
  if (dis > 3 || vis[dx][dy][i][dis]) continue;
  ans[dx][dy][i][dis]=ans[x][y][t][s]+1; 
  vis[dx][dy][i][dis]=true;
  q.push({dx,dy,i,dis});
}
```

---
处理用时：74.29秒
# 题目信息

# Fire Again

## 题目描述

**题目大意：**

有 $n\times m$ 棵树组成的矩形，初始时有 $K$ 棵树被点燃了。如果一棵树有相邻的树被点燃，在一分钟之后，这棵树也会被点燃。问最晚点燃的树的坐标（输出任意一个）。

## 样例 #1

### 输入

```
3 3
1
2 2
```

### 输出

```
1 1
```

## 样例 #2

### 输入

```
3 3
1
1 1
```

### 输出

```
3 3
```

## 样例 #3

### 输入

```
3 3
2
1 1 3 3
```

### 输出

```
2 2```

# AI分析结果

### 题目内容重写
# Fire Again

## 题目描述

**题目大意：**

有 $n\times m$ 棵树组成的矩形，初始时有 $K$ 棵树被点燃了。如果一棵树有相邻的树被点燃，在一分钟之后，这棵树也会被点燃。问最晚点燃的树的坐标（输出任意一个）。

## 样例 #1

### 输入

```
3 3
1
2 2
```

### 输出

```
1 1
```

## 样例 #2

### 输入

```
3 3
1
1 1
```

### 输出

```
3 3
```

## 样例 #3

### 输入

```
3 3
2
1 1 3 3
```

### 输出

```
2 2
```

### 题解分析与结论

#### 综合分析
本题的核心是通过模拟火势蔓延的过程，找到最后一个被点燃的树。大多数题解采用了广度优先搜索（BFS）或曼哈顿距离的方法来解决。BFS方法通过队列模拟火势的蔓延，而曼哈顿距离方法则通过计算每个点到所有初始着火点的最小距离，找到最晚被点燃的点。

#### 最优关键思路
1. **BFS方法**：通过队列模拟火势的蔓延，每次从队列中取出一个点，检查其四个相邻的点，如果未被点燃则加入队列。最后队列中最后一个点即为最晚被点燃的点。
2. **曼哈顿距离方法**：通过计算每个点到所有初始着火点的最小曼哈顿距离，找到距离最大的点即为最晚被点燃的点。

#### 可拓展之处
- **多源BFS**：适用于多个起点同时进行BFS的场景，如本题中的多个初始着火点。
- **曼哈顿距离**：适用于无障碍物的最短路径计算，可以扩展到其他类似的题目中。

### 推荐题目
1. P1332 血色先锋队
2. P1443 马的遍历
3. P1162 填涂颜色

### 所选高星题解

#### 题解1：作者：OnlyU (赞：8)
**星级：4.5**
**关键亮点**：简洁的BFS实现，代码清晰易懂，直接输出队列中最后一个点作为答案。
**核心代码**：
```cpp
while(!que.empty()){
    b=que.front();
    que.pop();
    ansx=b.x,ansy=b.y;
    for(int i=0; i<4; i++) {
        c.x=b.x+dx[i];
        c.y=b.y+dy[i];
        if(c.x<1||c.x>n||c.y<1||c.y>m)continue;
        if(v[c.x][c.y]==0) {
            v[c.x][c.y]=1;
            que.push(c);
        }
    }
}
```

#### 题解2：作者：清小秋ovo (赞：7)
**星级：4.5**
**关键亮点**：详细的BFS模板，代码结构清晰，适合初学者理解BFS的基本流程。
**核心代码**：
```cpp
while(!q.empty()){
    node cur = q.front();
    ans_x  = cur.x, ans_y = cur.y ;
    q.pop();
    vis[cur.x][cur.y]=1;
    for(int i=0;i<4;i++){
        int x1 = cur.x+d[i][0];
        int y1 = cur.y+d[i][1];
        if(vis[x1][y1])continue;
        if(x1<1||y1<1||x1>n||y1>m)continue;
        node nxt;
        nxt.x = x1, nxt.y = y1;
        vis[x1][y1]=1;
        q.push(nxt);
    }
}
```

#### 题解3：作者：QianianXY (赞：4)
**星级：4**
**关键亮点**：曼哈顿距离方法，思路新颖，代码简洁，适合对BFS不熟悉的同学。
**核心代码**：
```cpp
for (rei i = 1; i <= n; i++) {
    for (rei j = 1; j <= m; j++) {
        int minn = 1e9;
        for (rei l = 1; l <= k; l++)
            minn = min(minn, dist(X[l], Y[l], i, j));
        if (minn > ans) ansx = i, ansy = j, ans = minn;
    }
}
```

### 个人心得摘录
- **OnlyU**：本题虽然是一道蓝题，但说实话最难的就是翻译。这题就是一道BFS的入门题。实在没什么好讲的。
- **清小秋ovo**：比较简单的多源点广搜题目。火势从一张地图的多个点开始扩散，每一次扩散往上，下，左，右四个方向扩散，求最后一个被覆盖点的位置。
- **QianianXY**：直接枚举即可。由题知向上下左右拓展，且每次拓展一格。则初始点 $A(x_1,y_1)$ 覆盖 $B(x_2,y_2)$ 的拓展次数为曼哈顿距离 $|x_1-x_2|+|y_1-y_2|$。

---
处理用时：44.18秒
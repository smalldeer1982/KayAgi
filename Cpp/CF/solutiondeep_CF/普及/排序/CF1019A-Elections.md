# 题目信息

# Elections

## 题目描述

Berland地区的腐败现象非常常见。

马上有一场选举，你事先知道了选民和政党的数量，分别为  $n$  和  $m$  ，对于每一位选民，你知道他将要选举哪一个政党，不过，每一位选民都会在接受一定数额的金钱之后改变他的主意。如果你给第  $i$  位选民  $c_i$  数额的比特币，他就会选举任何你希望他选举的政党。

你的目的是让Berland的联合党赢得这场选举，联合党必须拥有比其它政党都多的选票，在此基础之上，你希望花费的比特币尽可能少。

## 样例 #1

### 输入

```
1 2
1 100
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 5
2 100
3 200
4 300
5 400
5 900
```

### 输出

```
500
```

## 样例 #3

### 输入

```
5 5
2 100
3 200
4 300
5 800
5 900
```

### 输出

```
600
```

# AI分析结果

【题目内容】
# 选举

## 题目描述

Berland地区的腐败现象非常常见。

马上有一场选举，你事先知道了选民和政党的数量，分别为  $n$  和  $m$  ，对于每一位选民，你知道他将要选举哪一个政党，不过，每一位选民都会在接受一定数额的金钱之后改变他的主意。如果你给第  $i$  位选民  $c_i$  数额的比特币，他就会选举任何你希望他选举的政党。

你的目的是让Berland的联合党赢得这场选举，联合党必须拥有比其它政党都多的选票，在此基础之上，你希望花费的比特币尽可能少。

## 样例 #1

### 输入

```
1 2
1 100
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 5
2 100
3 200
4 300
5 400
5 900
```

### 输出

```
500
```

## 样例 #3

### 输入

```
5 5
2 100
3 200
4 300
5 800
5 900
```

### 输出

```
600
```

【综合分析与结论】
这些题解的核心思路都是通过枚举联合党最终的选票数，再结合贪心策略来计算最小花费。各题解的主要区别在于实现细节和复杂度的优化。
- **思路**：大部分题解采用枚举联合党最终选票数，对于每个枚举值，处理其他政党使其票数小于联合党，若联合党票数不足则从剩余选民中选最便宜的补足。
- **算法要点**：将选民按政党分类，对每个政党的选民按贿赂金额排序，方便贪心选择。
- **解决难点**：解决了直接贪心难以处理的问题，通过枚举联合党最终票数，使问题变得可解。

【所选题解】
- 作者：易极feng (赞：5)，4星。
  - 关键亮点：思路清晰，代码简洁，通过结构体存储选民信息，重载小于运算符方便排序。
  - 个人心得：比赛时贪心想错，之后想到枚举联合党最终选票数，让贪心变得清晰明了，体现逆向思维的重要性。
- 作者：Frozencode (赞：3)，4星。
  - 关键亮点：代码结构清晰，使用 `vector` 存储选民信息，通过枚举联合党最终票数，逐步处理其他政党和剩余选民。
  - 个人心得：一开始以为是dp，后来发现想复杂了，在大佬点拨下才恍然大悟。
- 作者：Dementor (赞：3)，4星。
  - 关键亮点：详细分析了问题，通过枚举联合党最终票数，计算每个政党需要被捞的人数，处理不同情况更新答案。
  - 个人心得：刚开始想的贪心简单，测样例发现问题，之后想了很多数据结构都用不到，强调思维不要将简单问题想复杂。

【重点代码】
### 易极feng的核心代码
```cpp
struct person{
    int p,c;
}s[3005];

bool operator <(person a,person b){
    return a.c<b.c;
}

// ...

for(i=mv;i<=n;i++){
    memset(v,0,sizeof(v));
    memset(t,0,sizeof(t));
    cnt=vote=0;
    for(j=1;j<=n;j++){
        if(s[j].p==1){
            vote++,v[j]=1;
            continue;
        }
        if(p[s[j].p]-t[s[j].p]>=i){
            cnt+=s[j].c,v[j]=1,t[s[j].p]++,vote++;
        }
    }
    j=1;
    while(vote<i){
        if(!v[j])cnt+=s[j].c,vote++;
        j++;
    }
    ans=min(ans,cnt);
}
```
核心实现思想：先将选民按贿赂金额排序，枚举联合党最终票数，处理其他政党使其票数小于联合党，若联合党票数不足则从剩余选民中选最便宜的补足。

### Frozencode的核心代码
```cpp
for(int i=1;i<=n;i++)//关键代码 枚举1号党最终的票数。
{
    cur=0;//获得至少i票时所需的金额。
    for(int j=1;j<=m;j++)vc[j]=rc[j],ch[j]=0;//初始化。
    for(int j=2;j<=m;j++)
    {
        for(;vc[j]>=i;ch[j]++)//如果该党票数>i，那我们就贿赂该党选民直到其票数<i。
        {
            vc[1]++;
            vc[j]--;
            cur+=c[j][ch[j]];
        }
    }
    if(vc[1]<i)//我们很容易发现，如果处理后1号党票数>i，那肯定不是最优解，现在只要处理票数不够的情况。
    {
        rest.clear();//初始化。
        for(int j=2;j<=m;j++)
        {
            for(int k=ch[j];k<c[j].size();k++)
            {
                rest.push_back(c[j][k]);//我们将除1号党外每个党还可贿赂的选民放入rest数组中。
            }
        }
        sort(rest.begin(),rest.end());//对rest数组排序。
        for(int j=0;vc[1]<i;j++,vc[1]++)
        {
            cur+=rest[j];//不断贿赂选民直到1号党票数=i。
        }
    }
    tot=min(tot,cur);//不断更新最优解。
}
```
核心实现思想：枚举联合党最终票数，对每个政党处理使其票数小于联合党，若联合党票数不足则从剩余选民中选最便宜的补足，更新最优解。

### Dementor的核心代码
```cpp
for (long long x=size[1];x<=n;x++) {
    memset (need, 0, sizeof need); memset (bj, 0, sizeof bj);
    long long summ = size[1], cost = 0; bj[1] = size[1];
    for (long long i=2;i<=m;i++) {
        need[i] = (x <= size[i]) ? (size[i] - x + 1) : 0;
        need[i] = min (need[i], size[i]);
        cost += sum[i][need[i] - 1]; bj[i] = need[i];
        summ += need[i];
    }
    if (summ >= x) {
        ans = min (ans, cost);
    } else {
        long long tongji = 0;
        for (long long i=1;i<=n;i++) {
            bj[v[i].p] --;
            if (bj[v[i].p] < 0) {
                cost += v[i].c;
                tongji ++;
                if (tongji + summ >= x) break;
            }
        }
        ans = min (ans, cost);
    }
}
```
核心实现思想：枚举联合党最终票数，计算每个政党需要被捞的人数，处理不同情况更新答案。

【最优关键思路或技巧】
- **逆向思维**：直接贪心复杂，通过枚举联合党最终选票数，使问题变得可解。
- **贪心策略**：优先选择贿赂金额小的选民，保证花费最小。

【可拓展之处】
同类型题可能会有更多限制条件，如选民有不同的属性，或政党有不同的影响力等。类似算法套路可以是枚举某个关键值，再结合贪心或其他算法处理。

【推荐题目】
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)

【个人心得总结】
- 易极feng：比赛时贪心想错，后来通过逆向思维，枚举联合党最终选票数解决问题，强调逆向思维的重要性。
- Frozencode：一开始以为是dp，想复杂了，在大佬点拨下才找到正确思路。
- Dementor：刚开始贪心策略简单，测样例发现问题，之后尝试多种数据结构都不行，提醒思维不要将简单问题想复杂。

---
处理用时：55.62秒
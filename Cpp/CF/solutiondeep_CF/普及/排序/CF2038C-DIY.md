# 题目信息

# DIY

## 题目描述

给定一个长度为 $n$ 的整数数列 $a$，下标从 $1$ 到 $n$。你需要从 $a$ 中选择 $8$ 个下标互不相同的数 $x1,y1,x2,y2,x3,y3,x4,y4$，并使 $(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)$ 成为一个长方形的四个点的坐标。请构造一种方案使得此长方形面积最大，或报告无解。

## 样例 #1

### 输入

```
3
16
-5 1 1 2 2 3 3 4 4 5 5 6 6 7 7 10
8
0 0 -1 2 2 1 1 3
8
0 0 0 0 0 5 0 5```

### 输出

```
YES
1 2 1 7 6 2 6 7
NO
YES
0 0 0 5 0 0 0 5```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先找出出现次数不少于 2 次的数，判断是否能选出 4 组这样的数来构成矩形，若可以则找出能使矩形面积最大的 4 个数。
- **思路对比**：多数题解都是通过排序来选取最小、次小、最大、次大的数作为矩形顶点坐标；部分题解在计数和选取数时的细节处理有所不同。
- **算法要点**：都使用了 `map` 来统计每个数的出现次数，以处理数值范围较大的情况；部分题解使用 `vector` 或 `multiset` 来存储满足条件的数。
- **解决难点**：主要难点在于处理数的重复选取和判断是否有足够的数构成矩形，不同题解通过不同的计数和筛选方式来解决。

### 所选题解
- **作者：WangYongkai__AFO (赞：6)，4星**
  - **关键亮点**：思路清晰，代码简洁，对坑点的说明详细，有助于理解。
  - **个人心得**：提到计数时只能用 `map` 而不能用数组，否则会 `RE`，并分享了自己喜提罚时的经历，提醒读者注意数据范围。
- **作者：ivyjiao (赞：1)，4星**
  - **关键亮点**：思路简洁明了，直接指出需要找到 4 组数对，且说明了如何选取能使矩形面积最大的数对。
- **作者：xxxalq (赞：0)，4星**
  - **关键亮点**：对矩形面积的计算和数的选取有详细的分析，通过比较不同搭配的面积来确定最终输出。

### 重点代码
#### 作者：WangYongkai__AFO
```cpp
map<int,int>vis;
for(int i=1;i<=n;i++) 
{
    cin>>a[i],vis[a[i]]++;
    if(vis[a[i]]==2) 
    {
        e.push_back(a[i]);
        vis[a[i]]=0;
    }
}
if(e.size()<4)
{
    cout<<"No"<<'\n';
    continue;
}
sort(e.begin(),e.end());
int len=e.size();
cout<<"Yes"<<'\n';
cout<<e[len-1]<<' '<<e[len-2]<<' '<<e[len-1]<<' '<<e[0]<<' '; 
cout<<e[1]<<' '<<e[len-2]<<' '<<e[1]<<' '<<e[0]<<'\n';
```
**核心实现思想**：用 `map` 统计每个数的出现次数，当某个数出现 2 次时将其加入 `vector` 并清零计数，若 `vector` 中元素不足 4 个则无解，否则排序后选取最小、次小、最大、次大的数输出。

#### 作者：ivyjiao
```cpp
unordered_map<int,int>mp;
for(int i=1;i<=n;i++){
    cin>>a[i];
    mp[a[i]]++;
}
for(int i=1;i<=n;i++){
    if(mp[a[i]]>1){
        mp[a[i]]-=2;
        b.push_back(a[i]);
    }
}
sort(b.begin(),b.end());
if(b.size()<4) cout<<"NO"<<endl;
else{
    cout<<"YES"<<endl;
    cout<<b[0]<<" "<<b[1]<<" "<<b[0]<<" "<<b[b.size()-1]<<" "<<b[b.size()-2]<<" "<<b[1]<<" "<<b[b.size()-2]<<" "<<b[b.size()-1]<<endl;
}
```
**核心实现思想**：用 `unordered_map` 统计每个数的出现次数，将出现次数大于 1 的数加入 `vector` 并减少计数，排序后若 `vector` 中元素不足 4 个则无解，否则输出最小、次小、最大、次大的数。

#### 作者：xxxalq
```cpp
map<int,int>mp;
multiset<int>st;
while(n--){
    int x=read();
    mp[x]++;
}
for(map<int,int>::iterator it=mp.begin();it!=mp.end();it++){
    int x=(*it).second,y=(*it).first;
    while(x>=2){
        x-=2;
        st.insert(y);
    }
}
if(st.size()<4){
    cout<<"NO\n";
    continue;
}
cout<<"YES\n";
int a=*st.begin();
st.erase(st.begin());
int b=*st.begin();
int c=*st.rbegin();
st.erase(st.lower_bound(*st.rbegin()));
int d=*st.rbegin();
if((d-a)*(c-b)<(d-b)*(c-a)){
    out(a,b,c,d);
}else{
    out(a,b,d,c);
}
```
**核心实现思想**：用 `map` 统计每个数的出现次数，将出现次数不少于 2 次的数加入 `multiset`，若 `multiset` 中元素不足 4 个则无解，否则找出最小、次小、最大、次大的数，比较不同搭配的面积后输出。

### 最优关键思路或技巧
- 使用 `map` 来统计每个数的出现次数，以处理数值范围较大的情况。
- 对满足条件的数进行排序，选取最小、次小、最大、次大的数作为矩形顶点坐标，以保证矩形面积最大。

### 可拓展之处
同类型题可能会有不同的限制条件，如要求矩形的边必须是整数，或者给定的点坐标不是一维的而是二维的。类似算法套路可以用于解决需要从一组数据中选取满足特定条件的子集，以达到某种最优解的问题。

### 推荐洛谷题目
- P1002 过河卒
- P1047 校门外的树
- P1067 多项式输出

---
处理用时：38.85秒
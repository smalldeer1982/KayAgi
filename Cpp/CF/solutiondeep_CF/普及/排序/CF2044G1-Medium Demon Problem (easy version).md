# 题目信息

# Medium Demon Problem (easy version)

## 题目描述

这是问题的简化版。两个版本之间的关键区别以粗体显著标出。

有一群 $n$ 只蜘蛛聚在一起交换他们的毛绒玩具。最初，每只蜘蛛都有 $1$ 个毛绒玩具。每年，如果第 $i$ 只蜘蛛拥有至少一个毛绒玩具，它就会给第 $r_i$ 只蜘蛛一个毛绒玩具。否则，它将不会进行任何操作。注意，所有的毛绒玩具转移是同时进行的。在这个版本中，如果一只蜘蛛在任意时刻拥有超过 $1$ 个毛绒玩具，它们会丢掉多余的，只保留一个。

如果在某年开始时，每只蜘蛛拥有的毛绒玩具数量与上一年相同，则这一年的过程是稳定的。请注意，第 $1$ 年永远不会是稳定的。

请找出该过程中首次出现稳定的年份。

## 说明/提示

对于第二个测试用例：

- 在第 $1$ 年，每只蜘蛛的毛绒玩具数量为 $[1, 1, 1, 1, 1]$。然后进行当年的交换。
- 到了第 $2$ 年，各蜘蛛的毛绒玩具数量仍然为 $[1, 1, 1, 1, 1]$。由于数量没有变化，因此这一年是稳定的。

对于第三个测试用例：

- 在第 $1$ 年，所有蜘蛛的毛绒玩具数量为 $[1, 1, 1, 1, 1]$。然后进行第 $1$ 年的交换。
- 在第 $2$ 年，这些数量变为 $[1, 1, 1, 1, 0]$ 。然后进行第 $2$ 年的交换。即便有两只蜘蛛给了第 $2$ 只蜘蛛毛绒玩具，第 $2$ 只蜘蛛也只能保留一个。
- 到第 $3$ 年，数量变为 $[1, 1, 0, 1, 0]$。然后进行交换。
- 第 $4$ 年，数量变为 $[1, 1, 0, 0, 0]$。然后进行交换。
- 第 $5$ 年，数量仍然为 $[1, 1, 0, 0, 0]$。由于数量保持不变，这一年是稳定的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2
2 1
5
2 3 4 5 1
5
2 1 4 2 3
5
4 1 1 5 4
10
4 3 9 1 6 7 9 10 10 3```

### 输出

```
2
2
5
4
5```

# AI分析结果

### 题解综合分析与结论
这些题解均采用拓扑排序解决蜘蛛交换玩具首次稳定年份的问题。思路核心是：若蜘蛛无他人给玩具，就无法给出玩具，对应结点入度减为 0 后不再参与交换，当状态不再变化时达到稳定。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|zyhe2013|用类似拓扑排序，数组存给玩具蜘蛛个数，玩具没了就减对应蜘蛛玩具数，记录年份|用队列处理入度小于 0 的结点，更新最大年份|判断何时状态稳定，通过入度变化和队列操作实现|4 星|
|FishPressedCoins|经典拓扑排序，将蜘蛛作结点，给玩具作有向边，记录入度，入度为 0 结点入队并除影响|清空队列次数即答案，用邻接表存图|处理入度变化和结点更新，通过队列和邻接表实现|3 星|
|ohjun|类似拓扑排序，记录蜘蛛被指向次数，将指向次数为 0 的蜘蛛入队处理|队列存蜘蛛和轮数，更新轮数|确定最终稳定年份，通过队列操作和轮数更新实现|3 星|
|wflhx2011|建图后用拓扑排序找环，简单版用 dp 求环外最长链，困难版求连向点值的和|拓扑排序时顺便 dp 处理|区分简单版和困难版的 dp 状态转移，通过不同 dp 方程实现|3 星|
|Peaky|考虑拓扑，图为基环森林，简单版找环上最长链，困难版求各子树大小加本身|拓扑排序结合 dp 计算贡献|区分两版本的 dp 计算方式，通过不同 dp 方程实现|3 星|

### 所选题解
- **zyhe2013（4 星）**
    - 关键亮点：思路清晰，代码简洁，通过队列处理入度小于 0 的结点，有效更新最大年份。
```cpp
#include<bits/stdc++.h>
using namespace std;
int r[200005],f[200005];
struct node
{
  int x,t;
};
signed main()
{
  int T;
  cin>>T;
  while(T--)
  {
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)f[i]=0;
    for(int i=1;i<=n;i++)
    {
      cin>>r[i];
      f[r[i]]++;
    }
    for(int i=1;i<=n;i++)f[i]--;
    queue<node>q;
    for(int i=1;i<=n;i++)if(f[i]<0)q.push({r[i],2});
    int maxn=2;
    while(!q.empty())
    {
      int tx=q.front().x,ti=q.front().t;
      q.pop();
      maxn=max(maxn,ti+1);
      f[tx]--;
      if(f[tx]<0)q.push({r[tx],ti+1});
    }
    cout<<maxn<<"\n";
  }
  return 0;
}
```
核心实现思想：先统计每个蜘蛛收到玩具的数量，减去自身后将入度小于 0 的蜘蛛入队，在队列处理过程中更新最大年份，直到队列为空。

### 最优关键思路或技巧
- 运用拓扑排序处理结点入度变化，判断状态稳定。
- 用队列存储待处理结点，方便更新状态。

### 可拓展之处
同类型题可涉及图的拓扑结构，如课程安排、任务调度等，关键在于判断结点的依赖关系和状态变化。类似算法套路可结合图论和动态规划，处理不同条件下的状态转移。

### 推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
- [P1807 最长路](https://www.luogu.com.cn/problem/P1807)
- [P2051 中国象棋](https://www.luogu.com.cn/problem/P2051)

### 个人心得
题解中未包含个人心得。 

---
处理用时：30.06秒
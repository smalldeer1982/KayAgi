# 题目信息

# Best Price

## 题目描述

伯兰德最大的商店收到了一批圣诞树，并已有 $n$ 位顾客前来欲购这些树。在销售启动前，商店需要统一为每棵树定价。为了合理制定价格，商店掌握了关于每位顾客的一些信息。

对于第 $i$ 位顾客，有两个已知整数 $a_i$ 和 $b_i$，它们定义了顾客的购物行为：

- 如果价格不超过 $a_i$，顾客将购买一棵树并给出正面评价；
- 如果价格超过 $a_i$ 但不超过 $b_i$，顾客仍会购买，但会留下负面评价；
- 如果价格高于 $b_i$，则顾客将不会购买。

在负面评价不超过 $k$ 条的前提下，你的任务是帮助商店计算出最大的可能收益。

## 说明/提示

考虑以下例子：

- 在第一个测试用例中，如果价格设为 $1$，两位顾客都会各买一棵树且没有负面评价。
- 在第二个测试用例中，如果价格设为 $5$，顾客会购买一棵树且给出一条负面评价。
- 在第三个测试用例中，如果价格定为 $3$，所有顾客会购买且将收到两条负面评价。
- 在第四个测试用例中，价格定为 $7$ 时，有两位顾客购买，一条负面评价。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2 0
2 1
3 4
1 1
2
5
3 3
1 5 2
3 6 4
4 3
2 3 2 8
3 7 3 9
3 1
2 9 5
12 14 9```

### 输出

```
2
5
9
14
15```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于定价只可能是 $a_i$ 或 $b_i$ 中的一个，通过枚举这些价格，计算在该价格下的购买人数和差评数，在差评数不超过 $k$ 的条件下，找出最大收益。

- **思路对比**：部分题解通过二分查找计算购买人数和好评人数，进而得出差评数；部分题解将 $a$ 和 $b$ 数组元素排序后，按价格从小到大遍历，动态更新购买人数和差评数；还有题解使用 map 或主席树等数据结构辅助计算。
- **算法要点**：普遍对 $a$ 和 $b$ 数组进行排序，利用二分查找或遍历更新状态，根据差评数是否满足条件更新最大收益。
- **解决难点**：主要难点在于准确计算每个价格下的购买人数和差评数，不同题解采用不同方法解决该问题，如二分查找、动态更新状态等。

### 所选题解
- **ohjun（4星）**
  - **关键亮点**：思路清晰，通过二分查找计算购买人数和好评人数，进而判断差评数是否满足条件，代码简洁易读。
  - **核心代码**：
```cpp
void cal(int x)
{
    int tot = n - (lower_bound(B, B + n, x) - B);
    int val = n - (lower_bound(A, A + n, x) - A);
    if(tot - val > k) return;
    ans = max(ans, ll(tot) * ll(x));
}
```
  - **核心实现思想**：`cal` 函数用于计算在价格为 `x` 时的收益。`tot` 表示购买人数，通过二分查找 `B` 数组得到；`val` 表示好评人数，通过二分查找 `A` 数组得到。若差评数（`tot - val`）不超过 `k`，则更新最大收益 `ans`。

- **BpbjsGreen（4星）**
  - **关键亮点**：将 $a$ 和 $b$ 数组排序后，按价格从小到大遍历，动态更新购买人数、差评数和最大收益，思路巧妙。
  - **核心代码**：
```cpp
while (pa < n || pb < n)
{
    pri = min(a[pa + 1], b[pb + 1]); // 目前移动到的价格
    if (nega <= k) // 差评条件
        ans = max(ans, pri * num); // 更新答案
    while (a[pa + 1] == pri) // 移动指针
        pa++, nega++;
    while (b[pb + 1] == pri)
        pb++, num--, nega--;
}
```
  - **核心实现思想**：使用双指针 `pa` 和 `pb` 分别遍历 `a` 和 `b` 数组，`pri` 表示当前价格。当差评数 `nega` 不超过 `k` 时，更新最大收益 `ans`。根据当前价格是 `a` 数组还是 `b` 数组的元素，动态更新购买人数 `num` 和差评数 `nega`。

- **Autumn_Rain（4星）**
  - **关键亮点**：将 $a$ 和 $b$ 数组元素存储在一个 `pair` 数组中排序，通过遍历该数组，根据元素类型（`a` 或 `b`）更新购买人数和差评数，逻辑清晰。
  - **核心代码**：
```cpp
for(int i=0;i<2*n;){ 
    ll x=c[i].first;
    if(bad<=k){//保证差评不超过 k 时才计算贡献 
        ans=max(ans,x*cnt);//计算贡献最大值 
    }
    while(i<2*n&&c[i].first==x){
        if(c[i].second==0){//属于 a[i],此时会受到差评 
            bad++;//差评变多 
        }
        else{ //属于 b[i],此时不买 
            bad--;//差评变少 
            cnt--;//但也不买了 
        }
        i++;
    }
}
```
  - **核心实现思想**：遍历 `c` 数组，`x` 表示当前价格。当差评数 `bad` 不超过 `k` 时，更新最大收益 `ans`。根据 `c[i].second` 判断元素类型，若为 `0` 表示 `a` 数组元素，差评数加 1；若为 `1` 表示 `b` 数组元素，购买人数和差评数都减 1。

### 最优关键思路或技巧
- **定价范围确定**：通过分析发现最优定价只可能是 $a_i$ 或 $b_i$ 中的一个，将枚举范围从无穷缩小到 $2n$ 个数，大大减少了计算量。
- **排序与二分**：对 $a$ 和 $b$ 数组进行排序，利用二分查找快速计算购买人数和好评人数，时间复杂度为 $O(n\log n)$。
- **动态更新状态**：将 $a$ 和 $b$ 数组元素排序后按价格从小到大遍历，动态更新购买人数和差评数，避免重复计算。

### 可拓展之处
同类型题可能会有更多的限制条件，如不同顾客有不同的购买数量上限，或者有不同的好评和差评权重等。类似算法套路可用于区间覆盖、区间统计等问题，通过对区间端点进行排序和遍历，动态更新状态。

### 推荐洛谷题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：考察排序和归并排序的应用，与本题中排序和二分查找的思想类似。
2. [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)：需要对数据进行排序和分类讨论，与本题中对 $a$ 和 $b$ 数组进行排序和分析的思路相似。
3. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的应用，与本题中贪心选择最优定价的思想类似。

### 个人心得摘录与总结
- **imljw**：比赛最后 2 分钟极限改过，使用了主席树。总结：在比赛中要保持冷静，尝试不同的数据结构和算法解决问题。
- **Kendieer**：听说这题有二分做法，但自己不会，期待其他大佬的二分题解。总结：要不断学习和借鉴他人的思路，拓宽自己的知识面。

---
处理用时：45.97秒
# 题目信息

# Jeopardy!

## 题目描述

题意简述

“Jeopardy！”的决赛将有n问题，每个问题都有对应的得分ai，其中有m个问题可以选择不得分，而将现有总得分翻倍。你可以安排关卡的通过顺序和策略，求最大得分。

## 样例 #1

### 输入

```
4 1
1 3 7 5
3
```

### 输出

```
18
```

## 样例 #2

### 输入

```
3 2
10 3 8
2 3
```

### 输出

```
40
```

## 样例 #3

### 输入

```
2 2
100 200
1 2
```

### 输出

```
400
```

# AI分析结果

### 题目翻译
“危险边缘！”（Jeopardy!）的决赛将有 $n$ 个问题，每个问题都有对应的得分 $a_i$，其中有 $m$ 个问题可以选择不得分，而将现有总得分翻倍。你可以安排关卡的通过顺序和策略，求最大得分。

### 综合分析与结论
这些题解均采用贪心算法解决问题，核心思路为：先处理不能翻倍的问题，将其得分累加，再处理能翻倍的问题，对能翻倍的问题按得分从大到小排序，对于每个能翻倍的问题，比较翻倍和直接加分两种情况，取得分更大的操作。

#### 思路对比
- **排序方式**：多数题解使用结构体存储每个问题的得分和是否能翻倍的信息，按能否翻倍（能翻倍的排后面）和得分（得分高的排前面）排序；部分题解将能翻倍的问题单独存到数组或堆中，再对其按得分从大到小排序。
- **处理顺序**：先将不能翻倍的问题得分累加，再依次处理能翻倍的问题，比较翻倍和直接加分的得分，取最大值。

#### 算法要点
- **贪心策略**：先加不能翻倍的得分，再处理能翻倍的问题，且能翻倍的问题按得分从大到小处理。
- **排序**：将能翻倍的问题按得分从大到小排序，以保证在总得分较大时进行翻倍操作。
- **数据类型**：由于最终得分可能很大，需要使用 `long long` 类型。

#### 解决难点
- **排序策略**：确定能翻倍的问题排在后面，且得分高的问题排在前面，以保证最终得分最大。
- **翻倍决策**：对于每个能翻倍的问题，比较翻倍和直接加分的得分，选择得分更大的操作。

### 所选题解
- **muyang_233（5星）**
  - **关键亮点**：思路清晰，详细解释了贪心策略和排序策略，并给出了示例说明；代码结构清晰，注释详细。
  - **核心代码**：
```cpp
struct node{
    int a; // a值
    bool ok; // 是否能够进行翻倍，为true即可以
};
bool cmp(node _1, node _2){
    if (_1.ok != _2.ok) return _1.ok < _2.ok; 
    return _1.a > _2.a; 
}
int main(){
    // ... 输入部分
    sort(qaq + 1, qaq + n + 1, cmp);
    for (int i = 1; i <= n - m; i++) { 
        ans += qaq[i].a; 
    }
    for (int i = n - m + 1; i <= n; i++) { 
        if (ans * 2 > ans + qaq[i].a) { 
            ans *= 2;
        }
        else { 
            ans += qaq[i].a;
        }
    }
    // ... 输出部分
    return 0;
}
```
核心实现思想：使用结构体存储每个问题的信息，通过自定义比较函数 `cmp` 进行排序，先累加不能翻倍的问题得分，再处理能翻倍的问题，比较翻倍和直接加分的得分，取最大值。

- **sinsop90（4星）**
  - **关键亮点**：思路简洁明了，直接阐述贪心策略；代码简洁，易于理解。
  - **核心代码**：
```cpp
bool cmp(int x, int y) {
    return x > y;
}
signed main() {
    // ... 输入部分
    sort(fb + 1, fb + 1 + n, cmp);
    for(int i = 1; i <= m; i++) {
        if(fb[i] > ans) {
            ans += fb[i];
        }
        else {
            ans *= 2;
        }
    }
    // ... 输出部分
}
```
核心实现思想：将能翻倍的问题得分单独存到数组 `fb` 中，按得分从大到小排序，依次比较每个能翻倍的问题得分和当前总得分，选择得分更大的操作。

- **asasas（4星）**
  - **关键亮点**：思路清晰，详细描述了贪心算法的步骤；代码规范，注释明确。
  - **核心代码**：
```cpp
inline bool cmp(long long a, long long b){
    return a > b; 
}
int main(){
    // ... 输入部分
    sort(b + 1, b + 1 + m, cmp); 
    for (register int i = 1; i <= m; i++) {
        if (ans + b[i] > ans * 2) ans += b[i];
        else ans *= 2; 
    }
    // ... 输出部分
    return 0;
}
```
核心实现思想：将能翻倍的问题得分存到数组 `b` 中，按得分从大到小排序，依次比较每个能翻倍的问题得分和当前总得分，选择得分更大的操作。

### 最优关键思路或技巧
- **贪心策略**：先处理不能翻倍的问题，再处理能翻倍的问题，且能翻倍的问题按得分从大到小处理，保证在总得分较大时进行翻倍操作。
- **排序优化**：使用自定义比较函数对问题进行排序，确保能翻倍的问题排在后面，得分高的问题排在前面。
- **数据类型选择**：使用 `long long` 类型避免最终得分溢出。

### 拓展思路
同类型题或类似算法套路：
- **区间选择问题**：如活动选择问题，需要在多个区间中选择最优的区间组合，通常采用贪心算法，根据区间的结束时间或开始时间进行排序。
- **背包问题的变种**：如部分背包问题，可根据物品的单位价值进行贪心选择。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法，通过优先队列实现。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：考察贪心算法，按接水时间从小到大排序。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：考察贪心算法，根据物品的单位价值进行选择。

### 个人心得摘录与总结
部分题解提到这是一道注重思维而不是代码难度的题，提醒我们在解决问题时要先思考贪心策略，确定正确的排序和处理顺序，同时要注意数据类型的选择，避免溢出问题。 

---
处理用时：39.78秒
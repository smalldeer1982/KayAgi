# 题目信息

# Planning

## 题目描述

Helen在大都会机场工作，她的任务是安排每天的航班起飞时刻。今天一共有n架飞机将要起飞，第i架飞机将在第i分钟起飞。

大都会机场是大都会最重要的交通枢纽，因此想要原封不动地按照起飞时刻表的时刻起飞是很困难的。今天的情况也是如此：由于技术原因，在今天一开始的k分钟内飞机不允许起飞，因此必须创建一个新的起飞时刻表。

所有的航班必须在第(k+1)分钟到第(k+n)分钟内(包括两端)起飞，而且每分钟仅能有一架飞机起飞。然而，航班起飞的先后顺序可以与最初的时刻表排好的顺序不同，重排的时刻表只有一个限制：飞机不能比它在初始时刻表中起飞的时刻还要早的时刻起飞(即：第i架飞机必须在第i分钟后或第i分钟时起飞)。

Helen知道第i架飞机起飞时刻每延误一分钟机场所需支付的额外花费ci是多少。帮助她找到额外花费最小的方案。

## 说明/提示

在样例中，如果Helen仅把每架飞机的起飞时刻都推迟2分钟，那么总额外花费是38。
但是，对于最佳结果来说，总额外花费为20。

感谢@radish布団  提供的翻译

## 样例 #1

### 输入

```
5 2
4 2 1 10 2
```

### 输出

```
20
3 6 7 4 5 
```

# AI分析结果

【题目内容】
Helen在大都会机场工作，她的任务是安排每天的航班起飞时刻。今天一共有n架飞机将要起飞，第i架飞机将在第i分钟起飞。

大都会机场是大都会最重要的交通枢纽，因此想要原封不动地按照起飞时刻表的时刻起飞是很困难的。今天的情况也是如此：由于技术原因，在今天一开始的k分钟内飞机不允许起飞，因此必须创建一个新的起飞时刻表。

所有的航班必须在第(k + 1)分钟到第(k + n)分钟内(包括两端)起飞，而且每分钟仅能有一架飞机起飞。然而，航班起飞的先后顺序可以与最初的时刻表排好的顺序不同，重排的时刻表只有一个限制：飞机不能比它在初始时刻表中起飞的时刻还要早的时刻起飞(即：第i架飞机必须在第i分钟后或第i分钟时起飞)。

Helen知道第i架飞机起飞时刻每延误一分钟机场所需支付的额外花费ci是多少。帮助她找到额外花费最小的方案。

### 说明/提示
在样例中，如果Helen仅把每架飞机的起飞时刻都推迟2分钟，那么总额外花费是38。
但是，对于最佳结果来说，总额外花费为20。

### 样例 #1
#### 输入
```
5 2
4 2 1 10 2
```
#### 输出
```
20
3 6 7 4 5 
```

【综合分析与结论】
本题要求在技术限制下，重新安排n架飞机的起飞时间，使得额外花费最小。限制条件为前k分钟不能起飞，且每架飞机不能早于初始时刻表的起飞时间。题解普遍采用贪心策略结合不同的数据结构来实现，如优先队列、线段树、并查集等。核心在于让延误花费大的飞机尽可能早地起飞。

【所选的题解】
- NaN_HQJ2007_NaN（4星）
  - 亮点：思路清晰，通过画图辅助理解，详细分析了贪心策略的正确性，代码注释详细。
  - 个人心得：尝试对航班按$c_i$从大到小排序并找最早起飞时间的方法会出错，亲身经历过提交失败。
- 爬行者小郑（4星）
  - 亮点：思路简洁明了，通过模拟时间，将符合条件的航班压入优先队列，每次取出花费最大的航班安排起飞。
  - 个人心得：无
- Juanzhang（4星）
  - 亮点：提供了贪心 + 线段树和贪心 + 堆两种实现方式，对总花费公式进行变形推导，得出贪心策略。
  - 个人心得：不知怎的线段树维护比堆维护的慢。

【重点代码及核心思想】
#### NaN_HQJ2007_NaN
```cpp
struct node{
    long long m,id;
}a[maxn];
struct cmp1{
    bool operator () (node x,node y){
        if(x.m!=y.m){
            return x.m<y.m;
        }else{
            return x.id<y.id;
        }
    }
};
priority_queue<node,vector<node>,cmp1> q;
// 先把起飞时间小于等于k + 1的航班读入优先队列
for(i=1;i<=1+k;i++){
    q.push(a[i]);
}
lie=k+1,hang=k+2;
tong[q.top().id]=lie;
ans+=(lie-q.top().id)*q.top().m;
q.pop();
// 对剩下的航班进行操作
for(i=2;i<=n;i++){
    if(hang<=n){
        q.push(a[hang]);
    }
    if(hang<=n){
        hang++;
    }
    lie++;
    ans+=(lie-q.top().id)*q.top().m;
    tong[q.top().id]=lie;
    q.pop();
}
```
核心思想：使用优先队列存储航班信息，按照延误花费从大到小排序。先将起飞时间小于等于k + 1的航班加入队列，每次取出队首航班安排起飞，更新花费和答案，再将后续航班加入队列。

#### 爬行者小郑
```cpp
struct Node
{
    int id;
    int c;
    bool operator < (const Node &t)const
    {
        return c<t.c;
    }
}t[300005];
priority_queue<Node>q;
// 模拟时间，将符合条件的航班压入优先队列
for(int i=1;i<=n;i++)
{   
    for(int j=tot;j<=i+k&&j<=n;j++)q.push(t[j]),tot++;
    tmp=q.top();q.pop();
    int t=i+k;
    ans[tmp.id]=t;
    all+=(long long)(tmp.c)*(long long)(t-tmp.id);
}
```
核心思想：模拟从k + 1到k + n的时间，每次将原来时间不超过当前延迟后时间的航班压入优先队列，取出花费最大的航班安排起飞，记录答案和花费。

#### Juanzhang（贪心 + 堆）
```cpp
typedef pair <int, int> pii;
priority_queue <pii> q;
// 模拟时间，将符合条件的航班加入优先队列
for (int i = k + 1; i <= k + n; i++) {
    for (; cnt <= n && cnt <= i; ) {
        q.push(make_pair(w[cnt], cnt)), cnt++;
    }
    pii node = q.top();
    q.pop();
    ans[node.second] = i;
    sum += 1ll * node.first * (i - node.second);
}
```
核心思想：模拟从k + 1到k + n的时间，将符合条件的航班加入优先队列，每次取出队首航班安排起飞，更新花费和答案。

【最优关键思路或技巧】
- **贪心策略**：通过对总花费公式变形，得出让延误花费大的飞机尽可能早地起飞的贪心策略。
- **优先队列**：使用优先队列存储航班信息，按照延误花费从大到小排序，方便每次取出花费最大的航班。

【可拓展之处】
同类型题可能会有更多的限制条件，如不同时间段的延误花费不同、飞机有不同的优先级等。类似算法套路可应用于任务调度、资源分配等问题，核心是根据不同任务或资源的代价，采用贪心策略进行合理安排。

【推荐题目】
- P1090 合并果子
- P1223 排队接水
- P1803 凌乱的yyy / 线段覆盖

---
处理用时：50.61秒
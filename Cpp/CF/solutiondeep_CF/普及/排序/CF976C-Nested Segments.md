# 题目信息

# Nested Segments

## 题目描述

##### 【题目大意】：

你得到了一个序列$a_1,a_2,a_3...a_n$，表示$n$个区间。你的任务是求出一对$(i,j)$，表示区间$j$包含区间$i$（注意是区间$j$包含$i$）。

我们定义区间$[l_2,r_2]$包含区间$[l_1,r_1]$当且仅当$l_1 \geq l_2$且$r_1 \leq r_2$。比如区间$[2,5]$包含区间$[3,5]$，因为$3 \geq 2,5 \leq 5$。再比如区间$[2,5]$不包含区间$[1,4]$，因为$1<2$。

输出一对$(i,j)$表示答案。如果答案不唯一，则输出任意一组解即可（所以本题有`SPJ`）。如果无解，则输出`-1 -1`。

--------------------------------------

## 样例 #1

### 输入

```
5
1 10
2 9
3 9
2 3
2 9
```

### 输出

```
2 1
```

## 样例 #2

### 输入

```
3
1 5
2 6
6 20
```

### 输出

```
-1 -1
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找出包含关系的区间对展开，核心在于对区间进行合理排序，以减少不必要的比较。大部分题解采用排序后线性遍历的方式，部分使用树状数组、堆等数据结构辅助求解。

- **思路对比**：多数题解按左端点从小到大、左端点相同时右端点从大到小排序，使包含关系更易判断；部分按左端点从大到小、右端点从小到大排序。还有题解将问题转化为逆序对问题，借助树状数组求解。
- **算法要点**：排序是关键步骤，排序后通过遍历相邻区间或借助数据结构查找包含关系。
- **解决难点**：主要解决了 $3\times10^5$ 数据规模下 $O(n^2)$ 暴力解法超时的问题，通过排序和数据结构优化时间复杂度。

### 所选题解
- **作者：caibet (赞：6)，4星**
  - **关键亮点**：思路清晰，代码简洁易懂，通过合理排序和一次遍历解决问题。
  - **核心代码**：
```cpp
bool cmp(node x,node y){
    if(x.l!=y.l) return x.l<y.l;
    return x.r>y.r;
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].l>>a[i].r;
        a[i].id=i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++){
        if(a[i-1].r>=a[i].r&&a[i-1].l<=a[i].l){
            cout<<a[i].id<<' '<<a[i-1].id<<endl;
            return 0;
        }
    }
    cout<<"-1 -1";
    return 0;
}
```
  - **核心实现思想**：先按左端点从小到大、左端点相同时右端点从大到小排序，然后遍历排序后的区间，判断相邻区间是否存在包含关系。

- **作者：一只大龙猫 (赞：0)，4星**
  - **关键亮点**：将问题转化为逆序对问题，使用树状数组求解，思路独特，代码实现规范。
  - **核心代码**：
```cpp
struct node{
    int l,r,id;
    bool operator<(node x)const{
        return l==x.l?r>x.r:l<x.l;
    }
}str[500001];
inline int lowbit(int x){
    return x&-x;
}
void add(int i,int x){
    while(i<=n){
        c[i]+=x;
        i+=lowbit(i);
    }
    return;
}
int sum(int i){
    int s=0;
    while(i>0){
        s+=c[i];
        i-=lowbit(i);
    }   
    return s;
}
void find(int x){
    for(int i=1;i<x;i++){
        if(str[i].r>=str[x].r){
            cout<<str[x].id<<" "<<str[i].id;
            return;
        }
    }
}
void work(){
    for(int i=1;i<=n;i++){
        add(str[i].r,1);
        if(i-sum(str[i].r-1)-1>=1){
            find(i);
            return;
        }
    }
    cout<<"-1 -1"<<endl;
    return;
}
```
  - **核心实现思想**：先对区间排序，再进行离散化处理，使用树状数组统计逆序对，当出现逆序对时查找具体的区间对。

- **作者：louliu (赞：0)，4星**
  - **关键亮点**：展示了从暴力解法到优化解法的思考过程，对理解问题和优化思路有帮助。
  - **核心代码**：
```cpp
bool cmp(node a,node b){
    if(a.x!=b.x)return a.x<b.x;
    return a.y>b.y;
}
int main(){
    cin>>a;
    for(int i=1;i<=a;i++){
        cin>>b[i].x>>b[i].y;
        b[i].z=i;
    }
    sort(b+1,b+a+1,cmp);
    for(int i=2;i<=a;i++){
        if(b[i-1].y>=b[i].y&&b[i-1].x<=b[i].x){
            cout<<b[i].z<<" "<<b[i-1].z;
            return 0;
        }
    }
    cout<<-1<<" "<<-1;
    return 0;
}
```
  - **核心实现思想**：先按左端点从小到大、左端点相同时右端点从大到小排序，然后遍历排序后的区间，判断相邻区间是否存在包含关系。

### 最优关键思路或技巧
- **排序优化**：合理的排序方式能使包含关系更易判断，将时间复杂度从 $O(n^2)$ 降低到 $O(n\log n)$ 或 $O(n)$。
- **数据结构辅助**：树状数组可用于统计逆序对，帮助解决问题。

### 可拓展之处
同类型题如区间覆盖、区间合并等，可采用类似的排序和数据结构优化思路。例如，区间覆盖问题可先按左端点排序，再贪心选择覆盖范围最大的区间；区间合并问题可按左端点排序后合并重叠区间。

### 推荐题目
- [P1712 区间覆盖](https://www.luogu.com.cn/problem/P1712)
- [P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)
- [P2577 午餐](https://www.luogu.com.cn/problem/P2577)

### 个人心得摘录与总结
- **作者：Fido_Puppy**：时隔一年重新做之前没做出来的题并 AC，说明多回顾旧题有助于提升能力。
- **作者：一只大龙猫**：在输出时要注意输出原来的编号，而不是排序后的下标，提醒我们在处理这类问题时要关注细节。

---
处理用时：42.95秒
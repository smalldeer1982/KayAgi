# 题目信息

# Labyrinth

## 题目描述

## 题意描述
你正在玩一款电脑游戏。在其中一关，你位于一个 $n$ 行 $m$ 列的迷宫。每个格子要么是可以通过的空地，要么是障碍。迷宫的起点位于第 $r$ 行第 $c$ 列。你每一步可以向上、下、左、右中的一个方向移动一格，前提是那一格不是障碍。你无法越出迷宫的边界。

不幸的是，你的键盘快坏了，所以你只能向左移动不超过 $x$ 格，并且向右移动不超过 $y$ 格。因为上下键情况良好，所以对向上和向下的移动次数没有限制。

现在你想知道在满足上述条件的情况下，从起点出发，有多少格子可以到达（包括起点）？

## 样例 #1

### 输入

```
4 5
3 2
1 2
.....
.***.
...**
*....
```

### 输出

```
10
```

## 样例 #2

### 输入

```
4 4
2 2
0 1
....
..*.
....
....
```

### 输出

```
7
```

# AI分析结果

### 题目内容重写
#### 迷宫

##### 题目描述

你正在玩一款电脑游戏。在其中一关，你位于一个 $n$ 行 $m$ 列的迷宫。每个格子要么是可以通过的空地，要么是障碍。迷宫的起点位于第 $r$ 行第 $c$ 列。你每一步可以向上、下、左、右中的一个方向移动一格，前提是那一格不是障碍。你无法越出迷宫的边界。

不幸的是，你的键盘快坏了，所以你只能向左移动不超过 $x$ 格，并且向右移动不超过 $y$ 格。因为上下键情况良好，所以对向上和向下的移动次数没有限制。

现在你想知道在满足上述条件的情况下，从起点出发，有多少格子可以到达（包括起点）？

##### 样例 #1

###### 输入

```
4 5
3 2
1 2
.....
.***.
...**
*....
```

###### 输出

```
10
```

##### 样例 #2

###### 输入

```
4 4
2 2
0 1
....
..*.
....
....
```

###### 输出

```
7
```

### 题解综合分析与结论

这道题的核心是通过广度优先搜索（BFS）来遍历迷宫，同时限制向左和向右的移动次数。难点在于如何高效地处理不同路径到达同一个点时，左右移动次数的差异，以及如何剪枝以避免重复计算。

### 所选高星题解

#### 题解1：ImmortalWatcher (5星)
**关键亮点**：
- 使用BFS进行遍历，同时记录每个点的左右移动次数。
- 通过比较不同路径到达同一个点的左右移动次数，选择最优路径继续搜索。
- 代码简洁，逻辑清晰，优化了重复访问的问题。

**核心代码**：
```cpp
while (st < en) {
    st++;
    for (int i = 1; i <= 4; i++) {
        xx = d[st][1] + fx[i][1];
        yy = d[st][2] + fx[i][2];
        if (i == 3 && d[st][4] - 1 < 0) continue;
        if (i == 4 && d[st][5] - 1 < 0) continue;
        if (xx > 0 && xx <= n && yy > 0 && yy <= m && bz[xx][yy] == false && a[xx][yy] == '.') {
            d[++en][1] = xx;
            d[en][2] = yy;
            d[en][3] = d[st][3] + 1;
            if (i == 3) d[en][4] = d[st][4] - 1;
            else d[en][4] = d[st][4];
            if (i == 4) d[en][5] = d[st][5] - 1;
            else d[en][5] = d[st][5];
            ans++;
            bz[xx][yy] = true;
        }
    }
}
```

#### 题解2：DDOSvoid (4星)
**关键亮点**：
- 利用0-1 BFS优化搜索过程，将上下移动视为边权为0，左右移动视为边权为1。
- 通过双端队列实现优先处理上下移动，减少不必要的左右移动。
- 代码结构清晰，优化了搜索效率。

**核心代码**：
```cpp
void bfs() {
    memset(dis, -1, sizeof dis);
    Q.push_front(node(sx, sy)); dis[sx][sy] = 0;
    while (!Q.empty()) {
        node t = Q.front(); Q.pop_front();
        for (int i = 1; i <= 4; ++i) {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 1 || x > n || y < 1 || y > m || ma[x][y]) continue;
            if (dis[x][y] != -1 && dis[x][y] <= dis[t.x][t.y] + (i == 4)) continue;
            dis[x][y] = dis[t.x][t.y] + (i == 4);
            if (i == 4) Q.push_back(node(x, y));
            else Q.push_front(node(x, y));
        }
    }
}
```

#### 题解3：StarryWander (4星)
**关键亮点**：
- 在BFS中增加记录左右移动次数的变量，确保每次移动都在限制范围内。
- 通过判断不同路径到达同一个点的左右移动次数，选择最优路径继续搜索。
- 代码逻辑清晰，处理了重复访问的问题。

**核心代码**：
```cpp
while (!q.empty()) {
    node p = q.front();
    q.pop();
    if (vis[p.x][p.y] == 1 || (p.l < 0) || (p.r < 0)) continue;
    vis[p.x][p.y] = 1;
    ans++;
    for (int i = 0; i < 4; i++) {
        int dx = p.x + xx[i];
        int dy = p.y + yy[i];
        if (dx <= 0 || dx > n || dy <= 0 || dy > m || s[dx][dy] == '*' || vis[dx][dy] == 1) continue;
        if (i == 0 || i == 1) {
            q.push_front((node){dx, dy, p.l, p.r});
            continue;
        }
        if (i == 2) {
            q.push_back((node){dx, dy, p.l - 1, p.r});
            continue;
        }
        if (i == 3) {
            q.push_back((node){dx, dy, p.l, p.r - 1});
        }
    }
}
```

### 最优关键思路与技巧
1. **BFS优化**：通过记录每个点的左右移动次数，选择最优路径继续搜索，避免重复计算。
2. **0-1 BFS**：将上下移动视为边权为0，左右移动视为边权为1，利用双端队列优先处理上下移动，减少不必要的左右移动。
3. **剪枝策略**：通过比较不同路径到达同一个点的左右移动次数，选择最优路径继续搜索，避免无效的重复访问。

### 可拓展之处
- 类似的问题可以扩展到其他限制条件的搜索问题，如限制总步数、特定方向的移动次数等。
- 可以结合Dijkstra算法处理带权图的搜索问题。

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

### 个人心得摘录
- **ImmortalWatcher**：在BFS中，记录每个点的左右移动次数，选择最优路径继续搜索，避免重复计算。
- **DDOSvoid**：利用0-1 BFS优化搜索过程，优先处理上下移动，减少不必要的左右移动。
- **StarryWander**：在BFS中增加记录左右移动次数的变量，确保每次移动都在限制范围内。

---
处理用时：52.01秒
# 题目信息

# Arrow Path

## 题目描述

有一个 $2$ 行 $n$ 列的网格，每个格子上有一个向左或向右的箭头（即 `<` 或 `>`）。

现在你从 $(1, 1)$ 开始移动，并遵循以下的移动方式：

- 首先，选择一个移动方向走 $1$ 格，可以是上、下、左、右任意方向，但你需要保证不会走出网格；
- 走完一步后，如果当前所在格为 `<`，则向左走 $1$ 格，否则向右走 $1$​ 格。注意，你也需要保证这一步不会走出网格。

请回答你能否到达 $(2, n)$。

## 说明/提示

对于 $100 \%$ 的数据，保证 $1 \leq t \leq 10^4, 2 \leq n \leq 2 \times 10^5$。

**保证 $n$ 是偶数，没有箭头指向网格外，$n$ 的总和不超过 $2 \times 10^5$。**

Translated by ShiRoZeTsu.

## 样例 #1

### 输入

```
4
4
&gt;&gt;&lt;&lt;
&gt;&gt;&gt;&lt;
2
&gt;&lt;
&gt;&lt;
4
&gt;&gt;&gt;&lt;
&gt;&gt;&lt;&lt;
6
&gt;&gt;&lt;&lt;&gt;&lt;
&gt;&lt;&gt;&gt;&gt;&lt;```

### 输出

```
YES
YES
NO
YES```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个 $2$ 行 $n$ 列的网格，每个格子上有一个向左或向右的箭头（即 `<` 或 `>`）。

现在你从 $(1, 1)$ 开始移动，并遵循以下的移动方式：

- 首先，选择一个移动方向走 $1$ 格，可以是上、下、左、右任意方向，但你需要保证不会走出网格；
- 走完一步后，如果当前所在格为 `<`，则向左走 $1$ 格，否则向右走 $1$ 格。注意，你也需要保证这一步不会走出网格。

请回答你能否到达 $(2, n)$。

#### 说明/提示

对于 $100 \%$ 的数据，保证 $1 \leq t \leq 10^4, 2 \leq n \leq 2 \times 10^5$。

**保证 $n$ 是偶数，没有箭头指向网格外，$n$ 的总和不超过 $2 \times 10^5$。**

### 题解分析与结论

#### 综合分析

本题的核心在于如何高效地判断从起点 $(1, 1)$ 是否能到达终点 $(2, n)$。题解中主要采用了以下几种思路：

1. **搜索算法（DFS/BFS）**：通过深度优先搜索（DFS）或广度优先搜索（BFS）遍历网格，判断是否能到达终点。这种方法的优点是直观，但可能会因为网格较大而导致时间复杂度过高。
2. **规律分析**：通过分析网格中箭头的分布规律，判断是否存在阻碍到达终点的路径。这种方法的优点是时间复杂度较低，但需要对题目有较深的理解。
3. **预处理与连通性判断**：预处理每个格子的移动方向，然后通过 BFS 判断起点和终点是否连通。这种方法的优点是结合了搜索和预处理，能够在保证效率的同时处理较大规模的输入。

#### 评分较高的题解

1. **作者：kczw (赞：17)**
   - **星级：4.5**
   - **关键亮点**：通过分析网格中箭头的分布规律，判断是否存在连续的 `<`，从而快速判断是否能到达终点。这种方法的时间复杂度较低，适合处理大规模输入。
   - **代码核心思想**：遍历网格中的关键点，判断是否存在连续的 `<`，若存在则无法到达终点。
   ```cpp
   bool flag=0;
   for(int i=2;i<=n;i+=2){
       if(s[0][i]=='<'&&(s[1][i-1]=='<'||(i+1<n&&s[1][i+1]=='<'))){
           flag=1;
           break;
       }
   }
   flag?puts("No"):puts("Yes");
   ```

2. **作者：Drind (赞：1)**
   - **星级：4**
   - **关键亮点**：通过预处理每个格子的移动方向，然后使用 BFS 判断起点和终点是否连通。这种方法结合了预处理和搜索，能够在保证效率的同时处理较大规模的输入。
   - **代码核心思想**：预处理每个格子的移动方向，然后通过 BFS 判断起点和终点是否连通。
   ```cpp
   bool bfs(int s,int t){
       queue<int>q;
       q.push(s); vis[s]=1;
       while(!q.empty()){
           int u=q.front(); q.pop();
           for(int i=head[u];i;i=edge[i].nxt){
               int v=edge[i].to; if(vis[v]) continue;
               vis[v]=1; q.push(v);
               if(v==t) return true;
           }
       }
       return false;
   }
   ```

3. **作者：Super_Builder (赞：1)**
   - **星级：4**
   - **关键亮点**：通过广搜（BFS）遍历网格，判断是否能到达终点。这种方法的优点是直观，适合处理较小规模的输入。
   - **代码核心思想**：通过 BFS 遍历网格，判断是否能到达终点。
   ```cpp
   void bfs(){
       memset(vis,0,sizeof vis);
       queue<pair<int,int> >q;
       q.push({1,1});
       vis[1][1]=1;
       while(q.size()){
           auto ft=q.front();
           q.pop();
           for(int i=0;i<4;i++){
               int nx=ft.first+dx[i],ny=ft.second+dy[i];
               if(nx<1||nx>2||ny<1||ny>n)continue;
               if(c[nx][ny]=='<')ny--;
               else ny++;
               if(vis[nx][ny])continue;
               vis[nx][ny]=1;
               q.push({nx,ny});
           }
       }
   }
   ```

#### 最优关键思路

通过分析网格中箭头的分布规律，判断是否存在连续的 `<`，从而快速判断是否能到达终点。这种方法的时间复杂度较低，适合处理大规模输入。

#### 可拓展之处

类似的问题可以通过分析网格中的规律来优化搜索算法，减少不必要的遍历。例如，在某些路径问题中，可以通过预处理或动态规划来优化搜索过程。

#### 推荐题目

1. **P1219 [USACO1.5]八皇后 Checker Challenge**（题号：P1219）
2. **P1443 马的遍历**（题号：P1443）
3. **P1162 填涂颜色**（题号：P1162）

#### 个人心得

在解决网格路径问题时，除了直观的搜索算法外，还可以通过分析网格中的规律来优化算法。例如，通过预处理或动态规划来减少不必要的遍历，从而提高算法的效率。

---
处理用时：38.56秒
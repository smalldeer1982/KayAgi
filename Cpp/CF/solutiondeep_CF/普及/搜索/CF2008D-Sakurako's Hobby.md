# 题目信息

# Sakurako's Hobby

## 题目描述

对于一个给定的排列 $ p $，Sakurako 称整数 $ j $ 从整数 $ i $ 可达，意思是可以通过若干次操作将 $ i $ 改为 $ p_i $，最终使 $ i $ 等于 $ j $。

举个例子，如果 $ p=[3,5,6,1,2,4] $，那么 $ 4 $ 是从 $ 1 $ 可达的，因为变化过程可以是：$ i=1 \rightarrow i=p_1=3 \rightarrow i=p_3=6 \rightarrow i=p_6=4 $。这样 $ i $ 就变成了 $ 4 $，因此 $ 4 $ 是从 $ 1 $ 可达的。

在这个排列中，每个数字都有两种颜色：黑色或白色。

Sakurako 定义了一个函数 $ F(i) $，表示从 $ i $ 可达的黑色整数的总数。

她对每一个 $ 1\le i\le n $ 的 $ F(i) $ 都很感兴趣，但计算所有值太过复杂，因此她希望你能帮助她解决这个问题。

一个长度为 $ n $ 的排列是一个由 $ 1 $ 到 $ n $ 这 $ n $ 个不同整数构成的数组。例如，$ [2,3,1,5,4] $ 是一个排列，而 $ [1,2,2] $ 却不是（因为数字 $ 2 $ 出现了两次），同样地，$ [1,3,4] $ 也不是（$ n=3 $，但数组中包含 $ 4 $）。

## 样例 #1

### 输入

```
5
1
1
0
5
1 2 4 5 3
10101
5
5 4 1 3 2
10011
6
3 5 6 1 2 4
010000
6
1 2 3 4 5 6
100110```

### 输出

```
1 
0 1 1 1 1 
2 2 2 2 2 
4 1 4 4 1 4 
0 1 1 0 0 1```

# AI分析结果

### 题目内容重写

#### Sakurako的爱好

##### 题目描述

对于一个给定的排列 $p$，Sakurako 称整数 $j$ 从整数 $i$ 可达，意思是可以通过若干次操作将 $i$ 改为 $p_i$，最终使 $i$ 等于 $j$。

举个例子，如果 $p=[3,5,6,1,2,4]$，那么 $4$ 是从 $1$ 可达的，因为变化过程可以是：$i=1 \rightarrow i=p_1=3 \rightarrow i=p_3=6 \rightarrow i=p_6=4$。这样 $i$ 就变成了 $4$，因此 $4$ 是从 $1$ 可达的。

在这个排列中，每个数字都有两种颜色：黑色或白色。

Sakurako 定义了一个函数 $F(i)$，表示从 $i$ 可达的黑色整数的总数。

她对每一个 $1\le i\le n $ 的 $F(i)$ 都很感兴趣，但计算所有值太过复杂，因此她希望你能帮助她解决这个问题。

一个长度为 $n$ 的排列是一个由 $1$ 到 $n$ 这 $n$ 个不同整数构成的数组。例如，$[2,3,1,5,4]$ 是一个排列，而 $[1,2,2]$ 却不是（因为数字 $2$ 出现了两次），同样地，$[1,3,4]$ 也不是（$n=3$，但数组中包含 $4$）。

### 题解分析与结论

#### 综合分析

题目要求计算每个数字 $i$ 在排列 $p$ 中通过若干次操作后可达的黑色数字的总数。由于排列 $p$ 的性质，整个图会形成若干个环，每个环内的数字互相可达。因此，问题的关键在于找到每个环，并统计环内黑色数字的数量。

#### 题解对比

1. **chenxi2009**（4星）
   - **关键亮点**：使用并查集维护环，并统计每个环内黑色数字的数量。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i = 1;i <= n;i ++){
         int u = find(i),v = find(p[i]);
         if(u == v) continue;
         f[u] = v;
         cnt[v] += cnt[u];
     }
     ```
   - **个人心得**：通过并查集合并环，并维护每个环的黑色数字数量，避免了复杂的图论算法。

2. **Super_Cube**（4星）
   - **关键亮点**：使用Tarjan算法进行强连通分量缩点，然后通过拓扑排序累加黑色数字数量。算法较为复杂，但适用于更一般的图论问题。
   - **核心代码**：
     ```cpp
     void tarjan(int p){
         dfn[p]=low[p]=++tdx;
         S.push(p);
         for(const int&i:v[p])
             if(!dfn[i]) tarjan(i),low[p]=std::min(low[p],low[i]);
             else if(!scc_id[i]) low[p]=std::min(low[p],dfn[i]);
         if(dfn[p]==low[p]){
             dp[++scc]=0;
             while(true){
                 scc_id[S.top()]=scc;
                 dp[scc]+=s[S.top()]=='0';
                 if(S.top()==p)break;
                 S.pop();
             }
             S.pop();
         }
     }
     ```
   - **个人心得**：通过Tarjan算法找到强连通分量，再通过拓扑排序累加黑色数字数量，适用于更复杂的图结构。

3. **cly312**（4星）
   - **关键亮点**：通过DFS遍历每个环，并记录环内黑色数字的数量。代码简单易懂，适合初学者。
   - **核心代码**：
     ```cpp
     for(int i=0;i<n;i++){
         if(!visited[i]){
             vector<int>cycle;
             int cnt=0;
             int cur=i;
             while(!visited[cur]){
                 visited[cur]=true;
                 cycle.push_back(cur);
                 if(s[cur]=='0') cnt++;
                 cur=p[cur];
             }
             for(int index:cycle) F[index]=cnt;
         }
     }
     ```
   - **个人心得**：通过DFS遍历环，并记录环内黑色数字的数量，代码简洁，适合初学者理解。

#### 最优关键思路

最优的思路是使用并查集或DFS来找到每个环，并统计环内黑色数字的数量。并查集的方法代码简洁，适合处理环的合并；DFS的方法直观易懂，适合初学者理解。

#### 可拓展之处

类似的问题可以扩展到更复杂的图结构，如存在多个环或环之间有连接的情况。可以使用Tarjan算法进行强连通分量缩点，再通过拓扑排序累加黑色数字数量。

#### 推荐题目

1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)
3. [P2341 [USACO03FALL]Popular Cows G](https://www.luogu.com.cn/problem/P2341)

### 结论

对于本题，最优的解法是使用并查集或DFS来找到每个环，并统计环内黑色数字的数量。并查集的方法代码简洁，适合处理环的合并；DFS的方法直观易懂，适合初学者理解。

---
处理用时：45.31秒
# 题目信息

# Drunken Maze

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041D/ac90366c626ba21a7610cf55d06b2398a53105ff.png) Image generated by ChatGPT 4o.You are given a two-dimensional maze with a start and end position. Your task is to find the fastest way to get from the start to the end position. The fastest way is to make the minimum number of steps where one step is going left, right, up, or down. Of course, you cannot walk through walls.

There is, however, a catch: If you make more than three steps in the same direction, you lose balance and fall down. Therefore, it is forbidden to make more than three consecutive steps in the same direction. It is okay to walk three times to the right, then one step to the left, and then again three steps to the right. This has the same effect as taking five steps to the right, but is slower.

## 样例 #1

### 输入

```
7 12
############
#S........T#
#.########.#
#..........#
#..........#
#..#..#....#
############```

### 输出

```
15```

## 样例 #2

### 输入

```
5 8
########
#......#
#.####.#
#...T#S#
########```

### 输出

```
14```

## 样例 #3

### 输入

```
5 8
########
#.#S...#
#.####.#
#...T#.#
########```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### Drunken Maze

**题目描述**

你被给定一个二维迷宫，其中有起点和终点。你的任务是找到从起点到终点的最快路径。最快路径是指步数最少的路径，其中一步可以是向左、向右、向上或向下移动。当然，你不能穿过墙壁。

然而，有一个限制条件：如果你在同一方向上连续移动超过三步，你会失去平衡并摔倒。因此，禁止在同一方向上连续移动超过三步。你可以先向右移动三步，然后向左移动一步，再向右移动三步。这与连续向右移动五步的效果相同，但速度较慢。

**样例 #1**

**输入**

```
7 12
############
#S........T#
#.########.#
#..........#
#..........#
#..#..#....#
############
```

**输出**

```
15
```

**样例 #2**

**输入**

```
5 8
########
#......#
#.####.#
#...T#S#
########
```

**输出**

```
14
```

**样例 #3**

**输入**

```
5 8
########
#.#S...#
#.####.#
#...T#.#
########
```

**输出**

```
-1
```

### 题解分析与结论

#### 综合分析

本题的核心在于在迷宫中找到从起点到终点的最短路径，同时需要满足在同一方向上连续移动不超过三步的限制。题解中主要采用了BFS（广度优先搜索）和状态记录的方法来解决这个问题。

#### 题解对比

1. **ccjjxx的题解**
   - **思路**：使用BFS，记录每个状态的方向和连续移动步数，当连续移动步数达到3时，强制改变方向。
   - **难点**：处理连续移动步数超过3的情况，需要额外的逻辑来确保不违反规则。
   - **优化**：通过优先队列处理状态，确保每次扩展的都是最优路径。
   - **评分**：4星
   - **关键亮点**：详细处理了连续移动步数的限制，并通过优先队列优化了搜索过程。

2. **FwbAway的题解**
   - **思路**：使用BFS，记录每个点的坐标、方向和连续移动步数，确保每次移动都符合规则。
   - **难点**：处理状态记录的复杂性，确保每个状态只被访问一次。
   - **优化**：通过剪枝优化，减少了不必要的状态扩展。
   - **评分**：4星
   - **关键亮点**：通过剪枝优化，提高了搜索效率，代码结构清晰。

3. **沉石鱼惊旋的题解**
   - **思路**：使用BFS，记录每个点的坐标、方向和连续移动步数，确保每次移动都符合规则。
   - **难点**：处理状态记录的复杂性，确保每个状态只被访问一次。
   - **优化**：通过状态压缩，减少了内存使用。
   - **评分**：4星
   - **关键亮点**：通过状态压缩，优化了内存使用，代码简洁高效。

#### 最优关键思路

- **状态记录**：在BFS中，记录每个点的坐标、方向和连续移动步数，确保每次移动都符合规则。
- **剪枝优化**：通过剪枝优化，减少不必要的状态扩展，提高搜索效率。
- **优先队列**：使用优先队列处理状态，确保每次扩展的都是最优路径。

#### 代码实现

```cpp
// ccjjxx的代码核心部分
while(!q.empty())
{
    node now=q.top();q.pop();
    
    if(now.x==edx&&now.y==edy)
    {
        ans=min(ans,now.val);
        break;
    }
    if(vis[now.x][now.y]) continue;
    vis[now.x][now.y]=1;
    bool tt=0;
    do
    {
        if(tt) now=q.top(),q.pop();
        tt=1;
        for(int i=1;i<=4;i++)
        {
            node nxt=now;
            nxt.x+=dx[i],nxt.y+=dy[i];
            if(nxt.x<1||nxt.y<1||nxt.x>n||nxt.y>m||mp[nxt.x][nxt.y]) continue;
            if(i==nxt.prepos) nxt.pre++;
            else nxt.pre=0;
            nxt.val++;
            if(nxt.pre==3) 
            {
                if(i==2||i==3)
                {
                    node nxx=now;
                    nxx.x+=dx[1],nxx.y+=dy[1];
                    if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
                    {
                        nxt.pre=0,nxt.val+=2;
                    }
                    else
                    {
                        nxx=now;
                        nxx.x+=dx[4],nxx.y+=dy[4];
                        if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
                            nxt.pre=0,nxt.val+=2;
                        else nxt.val+=2,nxt.pre=1;
                    }
                }
                else
                {
                    node nxx=now;
                    nxx.x+=dx[2],nxx.y+=dy[2];
                    if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
                    {
                        nxt.pre=0,nxt.val+=2;
                    }
                    else
                    {
                        nxx=now;
                        nxx.x+=dx[3],nxx.y+=dy[3];
                        if(!(nxx.x<1||nxx.y<1||nxx.x>n||nxx.y>m||mp[nxx.x][nxx.y]))
                            nxt.pre=0,nxt.val+=2;
                        else nxt.val+=2,nxt.pre=1;
                    }
                }
            }
            else nxt.prepos=i;
            nxt.f=nxt.val+man(nxt.x,nxt.y,edx,edy);
            q.push(nxt);
        }
    }while(q.top().x==now.x&&q.top().y==now.y&&q.top().val==now.val&&q.top().prepos!=now.prepos);
}
```

#### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

#### 个人心得

- **调试经历**：在处理连续移动步数超过3的情况时，需要仔细考虑如何强制改变方向，避免重复计算。
- **踩坑教训**：优先队列中的状态记录需要确保唯一性，避免重复扩展相同状态。
- **顿悟感想**：通过状态记录和剪枝优化，可以显著提高搜索效率，减少不必要的计算。

---
处理用时：47.72秒
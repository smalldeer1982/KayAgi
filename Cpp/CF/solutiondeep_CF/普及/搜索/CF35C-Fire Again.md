# 题目信息

# Fire Again

## 题目描述

**题目大意：**

有 $n\times m$ 棵树组成的矩形，初始时有 $K$ 棵树被点燃了。如果一棵树有相邻的树被点燃，在一分钟之后，这棵树也会被点燃。问最晚点燃的树的坐标（输出任意一个）。

## 样例 #1

### 输入

```
3 3
1
2 2
```

### 输出

```
1 1
```

## 样例 #2

### 输入

```
3 3
1
1 1
```

### 输出

```
3 3
```

## 样例 #3

### 输入

```
3 3
2
1 1 3 3
```

### 输出

```
2 2```

# AI分析结果

【题目内容】
# Fire Again

## 题目描述

**题目大意：**

有 $n\times m$ 棵树组成的矩形，初始时有 $K$ 棵树被点燃了。如果一棵树有相邻的树被点燃，在一分钟之后，这棵树也会被点燃。问最晚点燃的树的坐标（输出任意一个）。

## 样例 #1

### 输入

```
3 3
1
2 2
```

### 输出

```
1 1
```

## 样例 #2

### 输入

```
3 3
1
1 1
```

### 输出

```
3 3
```

## 样例 #3

### 输入

```
3 3
2
1 1 3 3
```

### 输出

```
2 2
```

【题解分析与结论】

该题目是一个典型的多源点广度优先搜索（BFS）问题，主要考察对BFS算法的理解和应用。题解中主要分为两种思路：一种是直接使用BFS进行模拟，另一种是通过曼哈顿距离计算最晚被点燃的树的位置。

1. **BFS模拟法**：通过队列实现多源点BFS，模拟火势蔓延的过程，最后输出队列中最后一个被处理的节点。这种方法直观且易于理解，适合初学者掌握BFS的基本应用。
2. **曼哈顿距离法**：通过计算每个点到所有初始燃烧点的最小曼哈顿距离，找到距离最远的点。这种方法在时间复杂度上优于BFS模拟法，但需要对曼哈顿距离有较好的理解。

【评分较高的题解】

1. **作者：OnlyU (赞：8)**
   - **星级：4.5**
   - **关键亮点**：代码简洁明了，直接使用BFS模拟火势蔓延，适合初学者理解和学习BFS的基本应用。
   - **核心代码**：
     ```cpp
     while(!que.empty()){
         b=que.front();
         que.pop();
         ansx=b.x,ansy=b.y;
         for(int i=0; i<4; i++) {
             c.x=b.x+dx[i];
             c.y=b.y+dy[i];
             if(c.x<1||c.x>n||c.y<1||c.y>m)continue;
             if(v[c.x][c.y]==0) {
                 v[c.x][c.y]=1;
                 que.push(c);
             }
         }
     }
     ```

2. **作者：清小秋ovo (赞：7)**
   - **星级：4.0**
   - **关键亮点**：同样使用BFS模拟，代码结构清晰，注释详细，适合初学者学习。
   - **核心代码**：
     ```cpp
     while(!q.empty()){
         node cur = q.front();
         ans_x  = cur.x, ans_y = cur.y ;
         q.pop();
         vis[cur.x][cur.y]=1;
         for(int i=0;i<4;i++){
             int x1 = cur.x+d[i][0];
             int y1 = cur.y+d[i][1];
             if(vis[x1][y1])continue;
             if(x1<1||y1<1||x1>n||y1>m)continue;
             node nxt;
             nxt.x = x1, nxt.y = y1;
             vis[x1][y1]=1;
             q.push(nxt);
         }
     }
     ```

3. **作者：QianianXY (赞：4)**
   - **星级：4.0**
   - **关键亮点**：使用曼哈顿距离法，代码简洁，时间复杂度较低，适合对算法有一定理解的读者。
   - **核心代码**：
     ```cpp
     for (rei i = 1; i <= n; i++) {
         for (rei j = 1; j <= m; j++) {
             int minn = 1e9;
             for (rei l = 1; l <= k; l++)
                 minn = min(minn, dist(X[l], Y[l], i, j));
             if (minn > ans) ansx = i, ansy = j, ans = minn;
         }
     }
     ```

【最优关键思路与技巧】

- **BFS模拟法**：通过队列实现多源点BFS，模拟火势蔓延的过程，最后输出队列中最后一个被处理的节点。这种方法直观且易于理解，适合初学者掌握BFS的基本应用。
- **曼哈顿距离法**：通过计算每个点到所有初始燃烧点的最小曼哈顿距离，找到距离最远的点。这种方法在时间复杂度上优于BFS模拟法，但需要对曼哈顿距离有较好的理解。

【可拓展之处】

- 类似问题：可以扩展到其他类型的网格问题，如最短路径、最大覆盖等。
- 算法套路：多源点BFS和曼哈顿距离计算在其他问题中也有广泛应用，如地图导航、图像处理等。

【推荐题目】

1. [P1332 血色先锋队](https://www.luogu.com.cn/problem/P1332)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

【个人心得摘录】

- **OnlyU**：这道题虽然是一道蓝题，但说实话最难的就是翻译。这题就是一道BFS的入门题。实在没什么好讲的。
- **QianianXY**：比广搜思维和代码难度都更优的解法，一发最优解。
- **Qwertyhero**：本蒟蒻第一次写题解，有何不合理的地方请指出，谢谢！

---
处理用时：51.61秒
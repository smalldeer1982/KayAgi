# 题目信息

# New Reform

## 题目描述

有 $n$ 个城市，$m$ 条双向道路，没有一个城市存在自己到自己的道路，两个不同的城市间，最多有一条道路，也不能保证能从一个城市到达任意一个其他城市。

现在需要对每一条道路定向，使之成为单向道路，当然需要尽可能少地产生孤立的城市。当其他所有城市都不能到达某个城市，则称这个城市为孤立城市。要求出最少的孤立城市的个数。

## 样例 #1

### 输入

```
4 3
2 1
1 3
4 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 5
2 1
1 3
2 3
2 5
4 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
6 5
1 2
2 3
4 5
4 6
5 6
```

### 输出

```
1
```

# AI分析结果

【题目内容】
# New Reform

## 题目描述

有 $n$ 个城市，$m$ 条双向道路，没有一个城市存在自己到自己的道路，两个不同的城市间，最多有一条道路，也不能保证能从一个城市到达任意一个其他城市。

现在需要对每一条道路定向，使之成为单向道路，当然需要尽可能少地产生孤立的城市。当其他所有城市都不能到达某个城市，则称这个城市为孤立城市。要求出最少的孤立城市的个数。

## 样例 #1

### 输入

```
4 3
2 1
1 3
4 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 5
2 1
1 3
2 3
2 5
4 3
```

### 输出

```
0
```

## 样例 #3

### 输入

```
6 5
1 2
2 3
4 5
4 6
5 6
```

### 输出

```
1
```

【题解分析与结论】

本题的核心思路是通过判断图中的环来减少孤立城市的数量。具体来说，如果图中存在环，则环中的城市不会成为孤立城市；而如果图是树结构，则至少会有一个孤立城市。因此，问题的关键在于如何高效地判断图中的环。

【所选题解】

1. **作者：liu_chen_hao (赞：11)**  
   **星级：★★★★★**  
   **关键亮点：**  
   - 通过并查集判断环的存在，思路清晰，代码简洁。
   - 使用标记数组记录是否属于环或与环相连的树结构，逻辑严谨。
   - 代码实现高效，时间复杂度为 $O(n + m)$。

   **核心代码：**
   ```cpp
   int find(int x) {
       if(fa[x]==x) return x;
       return fa[x]=find(fa[x]);
   }
   int main() {
       scanf("%d%d", &n, &m);
       for(int i=1; i<=n; i++) fa[i]=i;
       for(int i=1; i<=m; i++) {
           int x,y;
           scanf("%d%d", &x, &y);
           int xx=find(x);
           int yy=find(y);
           if(xx==yy) v[xx]=1;
           else {
               fa[xx]=yy;
               if(v[xx] || v[yy]) v[yy]=1;
           }
       }
       for(int i=1; i<=n; i++)
           if(find(i)==i && !v[i]) ++ans;
       printf("%d", ans);
       return 0;
   }
   ```

2. **作者：dunko (赞：13)**  
   **星级：★★★★☆**  
   **关键亮点：**  
   - 使用并查集判断环的存在，思路与liu_chen_hao类似。
   - 代码注释详细，适合初学者理解。
   - 通过标记数组记录环的存在，逻辑清晰。

   **核心代码：**
   ```cpp
   int find(int x) {
       if(x==fa[x]) return x;
       return fa[x]=find(fa[x]);
   }
   int main() {
       cin>>n>>m;
       for(int i=1;i<=n;i++) fa[i]=i;
       for(int i=1;i<=m;i++) {
           int x,y;
           cin>>x>>y;
           int fx=find(x),fy=find(y);
           if(fx!=fy) {
               fa[fx]=fy;
               if(mark[fx]||mark[x]||mark[fy]||mark[y])
                   mark[fx]=mark[x]=mark[fy]=mark[y]=1;
           }
           else mark[fx]=mark[x]=mark[fy]=mark[y]=1;
       }
       for(int i=1;i<=n;i++)
           if(find(i)==i&&!mark[i]) ans++;
       cout<<ans<<endl;
       return 0;
   }
   ```

3. **作者：Stream月 (赞：4)**  
   **星级：★★★★☆**  
   **关键亮点：**  
   - 通过DFS判断环的存在，思路清晰。
   - 使用图论中的基环外向树和树结构进行分类讨论，逻辑严谨。
   - 代码实现简洁，时间复杂度为 $O(n + m)$。

   **核心代码：**
   ```cpp
   void dfs(int u, int fa) {
       vis[u] = true;
       int v;
       for(int i = head[u]; i; i = e[i].next) {
           v = e[i].to;
           if(v == fa) continue;
           if(vis[v]) {
               flag= false;
               continue;
           }
           dfs(v, u);
       }
   }
   int main() {
       n = read(), m = read();
       int x, y;
       $(i, 1, m) {
           x = read(), y = read();
           insert(x, y), insert(y,x);
       }
       for(int i = 1; i <= n; ++i) {
           if(!vis[i]) {
               flag = true;
               dfs(i, 0);
               if(flag) ++ans;
           }
       }
       printf("%d\n", ans);
       return 0;
   }
   ```

【最优关键思路与技巧】

- **并查集判断环：** 通过并查集数据结构高效判断图中是否存在环，并利用标记数组记录环的存在。
- **DFS判断环：** 通过深度优先搜索遍历图，判断是否存在环，适合图论中的树和基环外向树结构。
- **分类讨论：** 将图分为环和树结构，分别处理，逻辑清晰且高效。

【可拓展之处】

- **类似算法套路：** 类似的问题可以通过并查集或DFS判断图中的环，适用于图论中的连通性问题。
- **举一反三：** 可以拓展到其他图论问题，如判断图的连通性、最小生成树等。

【推荐题目】

1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)
3. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)

【个人心得摘录】

- **dunko：** 提到自己一开始尝试爆搜未果，转而使用并查集，强调了数据结构选择的重要性。
- **liu_chen_hao：** 通过分类讨论，强调了环和树结构的处理方式，逻辑清晰且高效。
- **Stream月：** 通过图论中的基环外向树和树结构进行分类讨论，强调了图论中的性质应用。

---
处理用时：51.01秒
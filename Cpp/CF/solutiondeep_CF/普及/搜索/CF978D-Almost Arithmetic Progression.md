# 题目信息

# Almost Arithmetic Progression

## 题目描述

Polycarp 喜欢等差数列，对于一个数列 $ [a_1,a_2,a_3,\dots,a_n] $，如果对于每个 $ i\,(1\le i < n) $，$ a_{i+1}-a_i $ 的值均相同，那么这个数列就是一个等差数列。例如，$ [42] $ ，$ [5,5,5] $ ，$ [2,11,20,29] $ 和 $ [3,2,1,0] $ 是等差数列，但是 $ [1,0,1] $，$ [1,3,9] $ 和 $ [2,3,1] $ 不是。

根据定义，任何长度为 $ 1 $ 或 $ 2 $ 的数列都是等差数列。

Polycarp 找到了一个只包含正整数的数列 $ [b_1,b_2,b_3,\dots,b_n] $ 。他只想最多将每个元素改变一次。换句话说，对于每个元素，有三种选项：自增 $ 1 $，自减 $ 1 $ 或者不变。

你需要找到对 $ b $ 中元素操作（每个只能操作一次）的最小次数，使 $ b $ 变成一个等差数列。

操作完成后的数列可以含有 $ 0 $ 。

## 说明/提示

在样例 $ 1 $ 中，Polycarp 应该将第 $ 1 $ 个元素加 $ 1 $ ，将第 $ 2 $ 个元素加 $ 1 $ ，将第 $ 3 $ 个元素加 $ 1 $ ，并且不改变第 $ 4 $ 个元素。所以，Polycarp 操作之后的数列为 $ [25,20,15,10] $ 。

在样例 $ 2 $ 中，Polycarp 不应进行操作，因为他的数列已经是等差数列了。

在样例 $ 3 $ 中，不可能通过上述的操作将数列变为等差数列。

在样例 $ 4 $ 中，Polycarp 应该只将第 $ 1 $ 个元素加 $ 1 $ 。操作之后的数列为 $ [0,3,6,9,12] $ 。

## 样例 #1

### 输入

```
4
24 21 14 10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2
500 500
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
14 5 1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
5
1 3 6 9 12
```

### 输出

```
1
```

# AI分析结果

### 题目内容翻译
# 几乎等差数列

## 题目描述

Polycarp 喜欢等差数列，对于一个数列 $ [a_1,a_2,a_3,\dots,a_n] $，如果对于每个 $ i\,(1\le i < n) $，$ a_{i+1}-a_i $ 的值均相同，那么这个数列就是一个等差数列。例如，$ [42] $ ，$ [5,5,5] $ ，$ [2,11,20,29] $ 和 $ [3,2,1,0] $ 是等差数列，但是 $ [1,0,1] $，$ [1,3,9] $ 和 $ [2,3,1] $ 不是。

根据定义，任何长度为 $ 1 $ 或 $ 2 $ 的数列都是等差数列。

Polycarp 找到了一个只包含正整数的数列 $ [b_1,b_2,b_3,\dots,b_n] $ 。他只想最多将每个元素改变一次。换句话说，对于每个元素，有三种选项：自增 $ 1 $，自减 $ 1 $ 或者不变。

你需要找到对 $ b $ 中元素操作（每个只能操作一次）的最小次数，使 $ b $ 变成一个等差数列。

操作完成后的数列可以含有 $ 0 $ 。

## 说明/提示

在样例 $ 1 $ 中，Polycarp 应该将第 $ 1 $ 个元素加 $ 1 $ ，将第 $ 2 $ 个元素加 $ 1 $ ，将第 $ 3 $ 个元素加 $ 1 $ ，并且不改变第 $ 4 $ 个元素。所以，Polycarp 操作之后的数列为 $ [25,20,15,10] $ 。

在样例 $ 2 $ 中，Polycarp 不应进行操作，因为他的数列已经是等差数列了。

在样例 $ 3 $ 中，不可能通过上述的操作将数列变为等差数列。

在样例 $ 4 $ 中，Polycarp 应该只将第 $ 1 $ 个元素加 $ 1 $ 。操作之后的数列为 $ [0,3,6,9,12] $ 。

## 样例 #1

### 输入

```
4
24 21 14 10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2
500 500
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
14 5 1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
5
1 3 6 9 12
```

### 输出

```
1
```

### 题解综合分析与结论

#### 思路对比
1. **枚举前两项**：大多数题解都采用了枚举前两项的思路，因为等差数列的公差由前两项决定。通过枚举前两项的所有可能变化（每个元素有3种变化方式，前两项共有9种组合），可以确定公差，然后检查整个数列是否符合等差数列的条件。
2. **剪枝优化**：部分题解使用了剪枝优化，如最优性剪枝和可行性剪枝，以减少不必要的计算。
3. **暴力搜索**：少数题解使用了暴力搜索的方法，虽然时间复杂度较高，但通过剪枝优化也能通过题目。

#### 解决难点
1. **确定公差**：通过枚举前两项的变化，可以确定公差，然后检查整个数列是否符合等差数列的条件。
2. **剪枝优化**：通过剪枝优化，可以减少不必要的计算，提高算法效率。

#### 最优关键思路
- **枚举前两项**：通过枚举前两项的所有可能变化，确定公差，然后检查整个数列是否符合等差数列的条件。这种方法简单直观，且时间复杂度较低。
- **剪枝优化**：在枚举过程中，通过剪枝优化，可以减少不必要的计算，提高算法效率。

### 所选高星题解

#### 题解1：作者：feicheng (赞：6)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，通过枚举前两项的变化确定公差，然后检查整个数列是否符合等差数列的条件。
- **核心代码**：
```cpp
inline int judge(int d) {
	int res = 0;
	for(ri i = 3;i <= n;++i){
		if(b[i]-b[i-1] > d + 1 || b[i]-b[i-1] < d - 1) return -1;
 		else if(b[i]-b[i-1] == d + 1) ++res,b[i]--;
 		else if(b[i] - b[i-1] == d - 1) ++res,++b[i];
	} 
	return res;
}
```
- **核心思想**：通过枚举前两项的变化确定公差，然后检查整个数列是否符合等差数列的条件。

#### 题解2：作者：FanYongchen (赞：3)
- **星级**：4星
- **关键亮点**：通过枚举前两项的变化确定公差，然后检查整个数列是否符合等差数列的条件，代码可读性较好。
- **核心代码**：
```cpp
for(int i=0;i<3;i++)
    for(int j=0;j<3;j++) {
        memcpy(tmp,a,sizeof(tmp));
        bool isCan=true;
        int sub=tmp[0]+d[i]-(tmp[1]+d[j]);
        tmp[1]+=d[j];
        int c=cnt[i]+cnt[j];
        for(int k=2;k<n;k++) {
            bool find=false;
            for(int l=0;l<3;l++)
                if(tmp[k-1]-(tmp[k]+d[l])==sub) {
                    tmp[k]+=d[l]; c+=cnt[l]; find=true; break;
                }
            if(!find) {isCan=false; break;}
        }
        if(isCan) ans=min(ans,c);
    }
```
- **核心思想**：通过枚举前两项的变化确定公差，然后检查整个数列是否符合等差数列的条件。

### 推荐题目
1. [CF978D Almost Arithmetic Progression](https://www.luogu.com.cn/problem/CF978D)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)

### 个人心得
- **调试经历**：在枚举前两项时，需要注意公差的计算是否正确，避免出现公差不一致的情况。
- **踩坑教训**：在剪枝优化时，需要确保剪枝条件正确，避免漏掉可行解。
- **顿悟感想**：通过枚举前两项的变化确定公差，可以大大简化问题的复杂度，提高算法效率。

---
处理用时：48.84秒
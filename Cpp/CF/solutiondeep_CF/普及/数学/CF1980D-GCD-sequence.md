# 题目信息

# GCD-sequence

## 题目描述

最大公约数（GCD）是两个整数 $x$ 和 $y$ 可以整除的最大整数 $z$。例如，$\text{GCD}(36, 48) = 12$，$\text{GCD}(5, 10) = 5$，以及 $\text{GCD}(7,11) = 1$。

Kristina 有一个由正整数组成的数组 $a$，其中有 $n$ 个数。她想要计算相邻两个数的最大公约数，得到一个新数组 $b$，称为最大公约数序列。

因此，最大公约数序列的元素 $b$ 将使用公式 $b_i = \text{GCD}(a_i, a_{i + 1})$ 计算得到 $1 \le i \le n - 1$。

确定是否可以从数组 $a$ 中移除恰好一个数字，使得最大公约数序列 $b$ 是非递减的（即，$b_i \le b_{i+1}$ 始终为真）。

例如，如果 Khristina 有一个数组 $a = [20, 6, 12, 3, 48, 36]$。如果她从中移除 $a_4 = 3$ 并计算 $b$ 的最大公约数序列，她会得到：

+ $b_1 = \text{GCD}(20, 6) = 2$
+ $b_2 = \text{GCD}(6, 12) = 6$ 
+ $b_3 = \text{GCD}(12, 48) = 12$ 
+ $b_4 = \text{GCD}(48, 36) = 12$  

结果得到的最大公约数序列 $b = [2,6,12,12]$ 是非递减的，因为 $b_1 \le b_2 \le b_3 \le b_4$。

## 样例 #1

### 输入

```
12
6
20 6 12 3 48 36
4
12 6 3 4
3
10 12 3
5
32 16 8 4 2
5
100 50 2 10 20
4
2 4 8 1
10
7 4 6 2 4 5 1 4 2 8
7
5 9 6 8 5 9 2
6
11 14 8 12 9 3
9
5 7 3 10 6 3 12 6 3
3
4 2 4
8
1 6 11 12 6 12 3 6```

### 输出

```
YES
NO
YES
NO
YES
YES
NO
YES
YES
YES
YES
YES```

# AI分析结果

### 题目内容重写
【题目描述】
最大公约数（GCD）是两个整数 $x$ 和 $y$ 可以整除的最大整数 $z$。例如，$\text{GCD}(36, 48) = 12$，$\text{GCD}(5, 10) = 5$，以及 $\text{GCD}(7,11) = 1$。

Kristina 有一个由正整数组成的数组 $a$，其中有 $n$ 个数。她想要计算相邻两个数的最大公约数，得到一个新数组 $b$，称为最大公约数序列。

因此，最大公约数序列的元素 $b$ 将使用公式 $b_i = \text{GCD}(a_i, a_{i + 1})$ 计算得到 $1 \le i \le n - 1$。

确定是否可以从数组 $a$ 中移除恰好一个数字，使得最大公约数序列 $b$ 是非递减的（即，$b_i \le b_{i+1}$ 始终为真）。

例如，如果 Khristina 有一个数组 $a = [20, 6, 12, 3, 48, 36]$。如果她从中移除 $a_4 = 3$ 并计算 $b$ 的最大公约数序列，她会得到：

+ $b_1 = \text{GCD}(20, 6) = 2$
+ $b_2 = \text{GCD}(6, 12) = 6$ 
+ $b_3 = \text{GCD}(12, 48) = 12$ 
+ $b_4 = \text{GCD}(48, 36) = 12$  

结果得到的最大公约数序列 $b = [2,6,12,12]$ 是非递减的，因为 $b_1 \le b_2 \le b_3 \le b_4$。

### 题解综合分析与结论
本题的核心在于判断是否可以通过删除一个元素，使得相邻元素的GCD序列保持非递减。各题解的主要思路是通过预处理前缀和后缀的单调性，然后枚举删除的元素，判断删除后是否满足条件。以下是对各题解的评分和总结：

### 所选高星题解
#### 题解1：Lijiangjun4 (5星)
**关键亮点**：
1. 使用了前缀和后缀的预处理，分别记录从左到右和从右到左的单调性。
2. 通过枚举删除的元素，判断删除后是否满足条件，时间复杂度为O(n)。
3. 代码清晰，逻辑严谨，边界处理得当。

**核心代码**：
```cpp
bool check() {
    bool flag1[200005], flag2[200005];
    b[n] = 2e9;
    for(int i=1;i<n;i++) b[i] = gcd(a[i], a[i+1]);
    flag1[0] = true;
    for(int i=1;i<n;i++) flag1[i] = flag1[i-1] && b[i] >= b[i-1];
    flag2[n-1] = flag2[n] = true;
    for(int i=n-2;i>=1;i--) flag2[i] = flag2[i+1] && b[i] <= b[i+1];
    int ans = flag1[n-2] | flag2[2];
    for(int i=2;i<n;i++) {
        int k = gcd(a[i-1], a[i+1]);
        ans |= (flag1[i-2] && flag2[i+1] && k >= b[i-2] && k <= b[i+1]);
    }
    return ans;
}
```

#### 题解2：haokee (4星)
**关键亮点**：
1. 同样使用了前缀和后缀的预处理，逻辑清晰。
2. 通过枚举删除的元素，判断删除后是否满足条件，时间复杂度为O(n)。
3. 代码简洁，边界处理得当。

**核心代码**：
```cpp
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    for (cin >> t; t; t--) {
        cin >> n, ans = 0;
        for (int i = 1; i <= n; i++) cin >> a[i];
        p[0] = s[n] = 1, b[n] = 1e9;
        for (int i = 1; i < n; i++) {
            b[i] = gcd(a[i], a[i + 1]);
            p[i] = p[i - 1] && b[i] >= b[i - 1];
        }
        for (int i = n - 1; i; i--) s[i] = s[i + 1] && b[i] <= b[i + 1];
        for (int i = 1; i <= n; i++) { 
            ans |= (i <= 2 || p[i - 2]) && (i >= n || s[i + 1]) &&
                   (i == 1 || i == n || (b[i - 2] <= gcd(a[i - 1], a[i + 1]) && 
                    gcd(a[i - 1], a[i + 1]) <= b[i + 1]));
        }
        cout << (ans ? "YES" : "NO") << '\n';
    }
    return 0;
}
```

#### 题解3：__LZH__ (4星)
**关键亮点**：
1. 使用了前缀和后缀的预处理，逻辑清晰。
2. 通过枚举删除的元素，判断删除后是否满足条件，时间复杂度为O(n)。
3. 代码简洁，边界处理得当。

**核心代码**：
```cpp
int main(){
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  cin >> T;
  while(T--){
  	cin >> n;
  	for(int i = 1; i <= n; i++) cin >> a[i];
		b[n] = 2e9;
		for(int i = 1; i < n; i++) b[i] = gcd(a[i], a[i + 1]);
		f1[0] = 1;
		for(int i = 1; i < n; i++) f1[i] = f1[i - 1] && (b[i] >= b[i - 1]);
		f2[n - 1] = f2[n] = 1;
		for(int i = n - 2; i >= 1; i--) f2[i] = f2[i + 1] && (b[i] <= b[i + 1]);
		int f = f2[2] | f1[n - 2];
		for(int i = 2; i <= n - 1; i++) {
			int k = gcd(a[i - 1], a[i + 1]);
			f |= (f1[i - 2] && f2[i + 1] && b[i + 1] >= k && k >= b[i - 2]);
		}
		cout << ((f) ? "YES\n" : "NO\n");
	}
  return 0;
}
```

### 最优关键思路或技巧
1. **前缀和后缀预处理**：通过预处理前缀和后缀的单调性，可以快速判断删除某个元素后是否满足条件。
2. **枚举删除元素**：通过枚举每个可能的删除元素，结合预处理的前缀和后缀信息，判断是否满足条件。
3. **边界处理**：在处理边界情况时，需要特别注意删除首尾元素时的特殊情况。

### 可拓展之处
1. **类似问题**：可以扩展到删除多个元素的情况，或者判断是否可以通过插入一个元素使得序列满足某种性质。
2. **其他序列问题**：类似思路可以应用于其他序列问题，如最长递增子序列、最长公共子序列等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结
1. **调试经历**：在处理边界情况时，容易出现遗漏，需要仔细检查。
2. **踩坑教训**：在预处理前缀和后缀时，需要注意数组的边界，避免越界。
3. **顿悟感想**：通过预处理和枚举结合的方式，可以有效地解决一些复杂的序列问题。

---
处理用时：58.89秒
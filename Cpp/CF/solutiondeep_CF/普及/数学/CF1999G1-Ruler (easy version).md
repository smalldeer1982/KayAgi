# 题目信息

# Ruler (easy version)

## 题目描述

本题是问题的简单版本。该版本与困难版之间的唯一区别是在这个版本中，你最多可以进行 $10$ 次查询。

这是一道交互题。

有一把有 $1001$ 个刻度的尺子，刻度分别为 $1 \sim 1001$。不幸的是，尺子丢失了一个刻度 $x$（$2 \le x \le 999$）。当你用尺子量一个长度为 $y$ 的物体时，尺子量出的结果为：
- 若 $y < x$，尺子将会量出正确的结果 $y$。
- 否则，尺子将会量出错误的结果 $y + 1$。

你需要找出丢失的刻度 $x$。你可以每次提供两个 $1$ 至 $1000$ 内的整数 $a,b$，你将会收到尺子量出的 $a$ 的长度与尺子量出的 $b$ 的长度之积。

你可以进行最多 $10$ 次询问。

## 样例 #1

### 输入

```
2

18

25


9999```

### 输出

```
? 3 5

? 4 4

! 4
? 99 100

! 100```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

本题是问题的简单版本。该版本与困难版之间的唯一区别是在这个版本中，你最多可以进行 $10$ 次查询。

这是一道交互题。

有一把有 $1001$ 个刻度的尺子，刻度分别为 $1 \sim 1001$。不幸的是，尺子丢失了一个刻度 $x$（$2 \le x \le 999$）。当你用尺子量一个长度为 $y$ 的物体时，尺子量出的结果为：
- 若 $y < x$，尺子将会量出正确的结果 $y$。
- 否则，尺子将会量出错误的结果 $y + 1$。

你需要找出丢失的刻度 $x$。你可以每次提供两个 $1$ 至 $1000$ 内的整数 $a,b$，你将会收到尺子量出的 $a$ 的长度与尺子量出的 $b$ 的长度之积。

你可以进行最多 $10$ 次询问。

#### 样例 #1

##### 输入

```
2

18

25


9999```

##### 输出

```
? 3 5

? 4 4

! 4
? 99 100

! 100```

---

### 题解综合分析与结论

本题的核心是通过二分或三分法在有限的查询次数内找到丢失的刻度 $x$。由于题目允许最多进行 $10$ 次查询，且 $2^{10} = 1024 > 999$，因此二分法是最直观的解决方案。部分题解还提出了三分法，虽然在某些情况下可以进一步优化查询次数，但在本题中二分法已经足够高效。

#### 最优关键思路
1. **二分法**：通过固定一边为 $1$，另一边为 $mid$，判断 $x$ 的位置。如果返回的面积为 $mid$，则 $x$ 在 $mid$ 之后；否则在 $mid$ 之前。
2. **三分法**：通过将区间分为三部分，利用两个查询点来缩小搜索范围，进一步减少查询次数。

#### 推荐题解
1. **作者：cjh20090318 (5星)**
   - **亮点**：详细分析了二分和三分法的适用场景，并提供了清晰的代码实现。
   - **代码核心**：
     ```cpp
     int check(const int x,const int y){
         printf("? %d %d\n",x,y),FLUSH;
         int ret;scanf("%d",&ret);
         return ret;
     }
     void solve(){
         int l=2,r=999;
         for(int m1,m2,ret;l<r;){
             m1=l+(r-l)/3,m2=r-(r-l)/3;
             ret=check(m1,m2);
             if(ret==(m1+1)*(m2+1)) r=m1;
             else if(ret==m1*(m2+1)) l=m1+1,r=m2;
             else l=m2+1;
         }
         printf("! %d\n",l),FLUSH;
     }
     ```

2. **作者：Pink_Cut_Tree (4星)**
   - **亮点**：简洁明了地解释了二分法的思路，并提供了易于理解的代码实现。
   - **代码核心**：
     ```cpp
     while(l<r){
         int mid=l+r>>1;
         cout<<"? 1 "<<mid<<"\n";
         cin>>x;
         if(x>=2*mid){
             cout<<"! 1"<<endl; flag=1; break;
         }
         if(x==mid){
             l=mid+1;
         }
         else{
             r=mid;
         }
     }
     ```

3. **作者：WsW_ (4星)**
   - **亮点**：将问题转化为猜数问题，简化了二分法的实现，代码简洁。
   - **代码核心**：
     ```cpp
     while(l<=r){
         mid=l+r>>1;
         printf("? 1 %d\n",mid);
         fflush(stdout);
         scanf("%d",&s);
         if(s==mid){
             l=mid+1;
         }
         else{
             r=mid-1;
             ans=mid;
         }
     }
     ```

#### 个人心得
- **调试经历**：部分题解提到在实现三分法时，需要注意边界条件的处理，避免因区间划分不当导致的错误。
- **顿悟感想**：通过固定一边为 $1$，可以将二维问题简化为一维问题，大大降低了实现的复杂度。

### 推荐题目
1. **P1947 猜数**：类似二分法的交互题。
2. **P1024 一元三次方程求解**：三分法的经典应用。
3. **P3382 三分法模板**：三分法的练习题。

---
处理用时：37.53秒
# 题目信息

# The Two Routes

## 题目描述

有个地方有一些城镇，城镇与城镇间有铁路或公路相连，如果有铁路相连，就不会有公路相连，没有铁路连接的城镇就会有公路相连。给你 $n$ 个城镇， $m$ 条铁路线，问同时从城镇1出发，分别坐火车和坐汽车到达城镇n，求两者都到达的时候最少的用时。其中火车和汽车不能同时到达中间点。

## 样例 #1

### 输入

```
4 2
1 3
3 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 6
1 2
1 3
1 4
2 3
2 4
3 4
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
5 5
4 2
3 5
4 5
5 1
1 2
```

### 输出

```
3
```

# AI分析结果

### 题目翻译
#### 两条路线
#### 题目描述
有一个地方有一些城镇，城镇与城镇之间通过铁路或公路相连。如果两个城镇之间有铁路相连，那么它们之间就没有公路相连；如果两个城镇之间没有铁路相连，那么它们之间就有公路相连。给定 $n$ 个城镇和 $m$ 条铁路线，问同时从城镇 1 出发，分别乘坐火车和汽车前往城镇 $n$，求两者都到达城镇 $n$ 时所需的最少用时。其中，火车和汽车不能同时到达中间点。

#### 样例 #1
##### 输入
```
4 2
1 3
3 4
```
##### 输出
```
2
```

#### 样例 #2
##### 输入
```
4 6
1 2
1 3
1 4
2 3
2 4
3 4
```
##### 输出
```
-1
```

#### 样例 #3
##### 输入
```
5 5
4 2
3 5
4 5
5 1
1 2
```
##### 输出
```
3
```

### 综合分析与结论
这些题解主要围绕图的最短路算法来解决从城镇 1 分别坐火车和汽车到城镇 $n$ 的最少用时问题。思路上，大多先建图，再分别计算火车和汽车的最短路径，最后取两者中的最大值作为结果，若有一个无法到达则输出 -1。

算法要点方面，涉及多种最短路算法，如 SPFA、Dijkstra、Floyd 和 BFS。SPFA 代码简单但易被卡；Dijkstra 需考虑是否用优先队列优化；Floyd 适用于数据范围小的情况，可处理负权边；BFS 因边权为 1 也可使用。

难点在于根据不同算法的特点选择合适的算法，以及处理图的取反和判断是否能到达终点。

### 题解评分与选择
|作者|评分|亮点|
| ---- | ---- | ---- |
|Ganshuaige|4星|思路清晰，使用邻接链表和 SPFA 算法，代码简洁易懂|
|WaltVBAlston|4星|介绍了 Dijkstra 算法并用优先队列优化，对算法复杂度和适用场景有详细说明|
|simonG|4星|使用 Floyd 算法，代码简洁，对不同算法的特点和适用情况有分析|

### 关键思路与技巧
- **图的取反**：当已知铁路图时，可通过取反得到公路图。
- **算法选择**：根据数据范围和图的特点选择合适的最短路算法，如数据范围小可用 Floyd，边权为 1 可用 BFS。
- **优先队列优化**：使用优先队列可优化 Dijkstra 算法的时间复杂度。

### 拓展思路
同类型题如求多种不同交通方式从起点到终点的最短用时，或在不同条件限制下的最短路问题。类似算法套路可参考其他最短路问题，如单源最短路径、多源最短路径等。

### 推荐题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)

### 个人心得摘录与总结
- WaltVBAlston：提到 SPFA 易被卡，建议使用更靠谱的 Dijkstra 算法，并说明了优先队列优化的方法和适用场景，提醒在稠密图和负权图中算法的选择。
- simonG：分析了不同最短路算法的特点，指出 Floyd 算法既不用考虑负边，也不用担心被卡，适合本题的数据范围。

### 重点代码
#### Ganshuaige（SPFA）
```cpp
void spfa(){
    memset(vis,0,sizeof(vis));
    memset(dis,INF,sizeof(dis));
    queue <int> q;
    q.push(1);
    vis[1]=1;
    dis[1]=0;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int v=1;v<=n;v++){
            if(u==v)
                continue;
            if(map[u][v]){
                if(dis[v]>dis[u]+1){
                    dis[v]=dis[u]+1;
                    if(!vis[v]){
                        vis[v]=1;
                        q.push(v);
                    }
                }
            }
        }
    }
}
```
核心思想：使用队列存储待扩展的节点，不断更新节点的最短距离。

#### WaltVBAlston（Dijkstra + 优先队列优化）
```cpp
struct node
{
    int index;
    ll dis;
    bool operator < (const node &x)const
    {
        return dis>x.dis;
    }
};
priority_queue <node> q;
//...
while(!q.empty())
{
    node x=q.top();
    q.pop();
    int k=x.index;
    if(flag[k]==true)
    {
        continue;
    }
    flag[k]=true;
    for(int i=1;i<=n;i++)
    {
        if(w[i][k]==false&&d1[i]>d1[k]+1)
        {
            d1[i]=d1[k]+1;
            q.push((node){i,d1[i]});
        }
    }
}
```
核心思想：使用优先队列存储待扩展的节点，每次取出距离最小的节点进行扩展。

#### simonG（Floyd）
```cpp
for(int k=1; k<=n; k++)
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++) {
            if(dis1[k][i]+dis1[k][j]<dis1[i][j]) dis1[i][j]=dis1[k][i]+dis1[k][j];
            if(dis2[k][i]+dis2[k][j]<dis2[i][j]) dis2[i][j]=dis2[k][i]+dis2[k][j];
        }
```
核心思想：通过三重循环不断更新任意两点之间的最短距离。

---
处理用时：35.51秒
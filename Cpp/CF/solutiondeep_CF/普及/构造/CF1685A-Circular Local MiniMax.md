# 题目信息

# Circular Local MiniMax

## 题目描述

给你 $n$ 个整数 $ a_1, a_2, \ldots, a_n $ 。 问有没有可能将它们排列在一个圆上，使每个数字严格地大于其相邻的两个数字或严格地小于其相邻的两个数字？

换句话说，检查是否存在 $ b_1, b_2, \ldots, b_n $ 的整数 $ a_1, a_2, \ldots, a_n $ 的重新排列，使得 $ i $ 从 $ 1 $ 到 $ n $ 中至少有一个以下条件成立。

- $ b_{i-1} < b_i > b_{i+1} $
- $ b_{i-1} > b_i < b_{i+1} $

为了使前面的公式对 $ i=1 $ 和 $ i=n $ 有意义，我们应定义 $ b_0=b_n $ 和 $ b_{n+1}=b_1 $。

## 样例 #1

### 输入

```
4
3
1 1 2
4
1 9 8 4
4
2 0 2 2
6
1 1 1 11 111 1111```

### 输出

```
NO
YES
1 8 4 9 
NO
YES
1 11 1 111 1 1111```

# AI分析结果

### 题目内容中文重写
# 环形局部最值问题

## 题目描述
给定 $n$ 个整数 $a_1, a_2, \ldots, a_n$。询问是否有可能将它们排列在一个圆上，使得每个数字严格大于其相邻的两个数字，或者严格小于其相邻的两个数字？

换句话说，检查是否存在 $a_1, a_2, \ldots, a_n$ 的一个重新排列 $b_1, b_2, \ldots, b_n$，使得对于 $i$ 从 $1$ 到 $n$，至少满足以下条件之一：
- $b_{i - 1} < b_i > b_{i + 1}$
- $b_{i - 1} > b_i < b_{i + 1}$

为了使上述公式对于 $i = 1$ 和 $i = n$ 有意义，我们定义 $b_0 = b_n$ 且 $b_{n + 1} = b_1$。

## 样例 #1
### 输入
```
4
3
1 1 2
4
1 9 8 4
4
2 0 2 2
6
1 1 1 11 111 1111
```
### 输出
```
NO
YES
1 8 4 9 
NO
YES
1 11 1 111 1 1111
```

### 综合分析与结论
- **思路对比**：两位作者都先判断 $n$ 的奇偶性，若 $n$ 为奇数则无解。若 $n$ 为偶数，都采用排序后将较小一半元素和较大一半元素交替放置的构造方法。Patricky 还提到了借助鸽巢原理分析重复元素的情况，而 Lijunzhuo 重点强调了重复元素对构造结果的影响，通过编写 `check` 函数来判断构造的数列是否符合条件。
- **算法要点**：两位作者的核心算法都是排序和交替放置元素，同时进行结果检查。Patricky 是在构造完数组后进行检查，Lijunzhuo 则编写了单独的 `check` 函数进行检查。
- **解决难点**：主要难点在于处理重复元素，两位作者都意识到重复元素可能导致无法构造出符合条件的数列，并采取了相应的检查措施。

### 所选题解
- **Patricky 的题解（4星）**
    - **关键亮点**：思路清晰，借助鸽巢原理分析重复元素的情况，代码使用了 C++20 的 `std::ranges` 进行排序，代码结构较为简洁。
    - **核心代码**：
```cpp
int solve() {
  int n;
  cin >> n;
  vector<int> a(n);
 
  for (int &i : a) {
    cin >> i;
  }
 
  if (n & 1) {
    return cout << "NO\n", int{};
  }
 
  ranges::sort(a);
  vector<int> b(n);
 
  for (int i = 0; i < n; ++i) {
    b[i] = a[i / 2 + (i & 1? n / 2 : 0)];
  }
 
  b.push_back(b.front());
  for (int i = 1; i < n; i += 2) {
    if (b[i - 1] >= b[i] || b[i] <= b[i + 1]) {
      return cout << "NO\n", int{};     
    }
  }
 
  cout << "YES\n";
  for (int i = 0; i < n; ++i) {
    cout << b[i] << " \n"[i + 1 == n];
  }
  
  return {};
}
```
核心实现思想：先判断 $n$ 的奇偶性，若为奇数则直接输出 `NO`。若为偶数，对数组进行排序，然后将较小一半元素和较大一半元素交替放置到新数组 $b$ 中，最后检查新数组是否符合条件，若符合则输出 `YES` 和新数组，否则输出 `NO`。

- **Lijunzhuo 的题解（3星）**
    - **关键亮点**：分类讨论清晰，编写了单独的 `check` 函数来判断构造的数列是否符合条件，代码逻辑较为清晰。
    - **核心代码**：
```cpp
bool check()
{
	for(int i=2;i<=n;i++)
		if(ans[i]==ans[i-1])
			return false;
	return true;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			scanf("%d",&A[i]);
		if(n&1)//无解情况1 
		{
			printf("NO\n");
			continue;
		}
		sort(A+1,A+1+n);
		for(int i=1;i<=(n>>1);i++)
			ans[(i<<1)-1]=A[i];
		for(int i=(n>>1)+1;i<=n;i++)
			ans[(i-(n>>1))<<1]=A[i];
		if(!check())//无解情况2 
		{
			printf("NO\n");
			continue;
		}
		printf("YES\n");//有解
		for(int i=1;i<=n;i++)
			printf("%d ",ans[i]);
		putchar('\n');
	}
	return 0;
}
```
核心实现思想：先判断 $n$ 的奇偶性，若为奇数则直接输出 `NO`。若为偶数，对数组进行排序，将较小一半元素放在排列的奇数位置，较大一半元素放在排列的偶数位置，然后调用 `check` 函数检查构造的数列是否符合条件，若符合则输出 `YES` 和构造的数列，否则输出 `NO`。

### 最优关键思路或技巧
- **奇偶性判断**：通过判断元素个数 $n$ 的奇偶性，快速排除奇数情况，减少不必要的计算。
- **排序与交替放置**：对数组进行排序，然后将较小一半元素和较大一半元素交替放置，构造出可能符合条件的数列。
- **重复元素检查**：考虑重复元素对结果的影响，通过检查相邻元素是否相等来判断构造的数列是否符合条件。

### 同类型题或类似算法套路
同类型题通常涉及数组元素的排列组合，要求满足一定的局部条件。解题套路一般包括先分析特殊情况（如奇偶性），然后进行排序和构造，最后检查构造结果是否符合条件。

### 洛谷相似题目推荐
1. [CF1419D2](https://www.luogu.com.cn/problem/CF1419D2)
2. [CF1339B](https://www.luogu.com.cn/problem/CF1339B)
3. 暂时未找到其他合适的洛谷题目，可在洛谷搜索“环形排列 局部最值”等关键词查找更多相关题目。

### 个人心得
- Patricky：提到你谷写文章包含 emoji 会变成问号，影响体验。还推荐了类似题目，认为是双倍或三倍经验。
总结：在写文章时要注意符号兼容性，同时可以通过做类似题目来加深对知识点的理解和掌握。 

---
处理用时：37.35秒
# 题目信息

# Manhattan Permutations

## 题目描述

设排列 $p$ 的曼哈顿值为 $ |p_1 - 1| + |p_2 - 2| + \ldots + |p_n - n| $ 。

例如，对于排列 $ [1, 2, 3] $ , 它的曼哈顿值为 $ |1 - 1| + |2 - 2| + |3 - 3| = 0 $ ；
对于排列 $ [3, 1, 2] $ , 它的曼哈顿值为 $ |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 $ 。

给出 $ n $ 和 $ k $ . 询问是否存在一个长度为 $ n $ 的排列 $ p $ 的曼哈顿值为 $ k $ ，若存在，输出排列 $ p $ 。

## 样例 #1

### 输入

```
8
3 4
4 5
7 0
1 1000000000000
8 14
112 777
5 12
5 2```

### 输出

```
Yes
3 1 2
No
Yes
1 2 3 4 5 6 7
No
Yes
8 2 3 4 5 6 1 7
No
Yes
5 4 3 1 2
Yes
2 1 3 4 5```

# AI分析结果

### 题目内容（已为中文，无需翻译）
设排列 $p$ 的曼哈顿值为 $ |p_1 - 1| + |p_2 - 2| + \ldots + |p_n - n| $ 。

例如，对于排列 $ [1, 2, 3] $, 它的曼哈顿值为 $ |1 - 1| + |2 - 2| + |3 - 3| = 0 $ ；
对于排列 $ [3, 1, 2] $, 它的曼哈顿值为 $ |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 $ 。

给出 $ n $ 和 $ k $. 询问是否存在一个长度为 $ n $ 的排列 $ p $ 的曼哈顿值为 $ k $ ，若存在，输出排列 $ p $ 。

### 综合分析与结论
这些题解核心思路一致，先判断无解情况（$k$ 为奇数或超过最大曼哈顿值），再考虑构造排列。不同点在于构造排列的方法：
- **拆分法**：将 $\frac{k}{2}$ 拆成若干不超过 $n - 1$ 且互不相等的数之和，通过交换数对来增加曼哈顿值。
- **交换法**：从两端向中间扫描，每次交换元素使曼哈顿值接近 $k$。
- **递归构造法**：$k \ge 2(n - 1)$ 时，交换首尾元素并递归处理子问题；$k < 2(n - 1)$ 时，按特定方式构造排列。
- **根号构造法**：根据 $\sqrt{k}$ 对 $k$ 分类，按特定规则构造排列。

### 所选题解
- **作者：szh_AK_all（5星）**
    - **关键亮点**：思路清晰，代码简洁，详细阐述了排列曼哈顿值为偶数的原因，构造方法易于理解。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[200005];

signed main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        if (k % 2 == 1)
            cout << "No" << endl;
        else {
            int ans = 0;
            for (int i = 1, j = n; i <= n; i++, j--) {
                a[i] = i;
                ans += abs(j - i);
            }
            if (k > ans)
                cout << "No" << endl;
            else {
                int x = k / 2;
                for (int i = 1, j = min(x, n - 1);; i++) {
                    swap(a[i], a[i + j]);
                    x -= j;
                    j = min(x, n - 2 * i - 1);
                    if (!x)
                        break;
                }
                cout << "Yes" << endl;
                for (int i = 1; i <= n; i++)
                    cout << a[i] << " ";
                cout << endl;
            }
        }
    }
}
```
    - **核心思想**：先判断 $k$ 的奇偶性和是否超过最大值，若有解则将 $\frac{k}{2}$ 拆分成若干不超过 $n - 1$ 且互不相等的数之和，通过交换数对来构造排列。

- **作者：int_R（4星）**
    - **关键亮点**：思路简洁，代码实现较为高效，通过交换元素逐步逼近目标曼哈顿值。
    - **核心代码**：
```cpp
inline void work()
{
    cin>>n>>k;
    if(k&1){cout<<"No\n";return ;}
    for(int i=1;i<=n;++i) a[i]=i;
    for(int i=1;i<=n/2;++i)
    {
        ll now=min(k/2,(n-i+1-i));
        swap(a[i],a[i+now]),k-=now*2;
    }
    if(k){cout<<"No\n";return ;}
    cout<<"Yes\n";
    for(int i=1;i<=n;++i) cout<<a[i]<<' ';
    cout<<'\n';return ;
}
```
    - **核心思想**：先判断 $k$ 的奇偶性，若有解则从两端向中间扫描，每次交换元素使曼哈顿值接近 $k$。

- **作者：Fu_Da_Ying（4星）**
    - **关键亮点**：递归计算最大曼哈顿值，构造方法清晰，代码可读性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,k,p[200015],ans;
long long d(long long x){//递归求n个数最大的曼哈顿值 
    if(x<=1){
        return 0;
    }
    return x*2-2+d(x-2);
}
int main(){
    scanf("%lld",&t);
    while(t--){
        ans=0;
        scanf("%lld %lld",&n,&k);
        for(int i=1;i<=n;i++){//初始化p数组 
            p[i]=i;
        }
        if(k%2==1||k>d(n)){//如果k为奇数或超过了n个数最大的曼哈顿值时 
            printf("No\n");//输出No 
            continue;
        }
        k/=2;
        for(int i=1;;i++){
            if(k>n-2*i+1){//如果k超过了现在最大数与最小数的差 
                swap(p[i],p[n-i+1]);//交换最大数和最小数
                k=k-n+2*i-1;//k减去最大数与最小数的差 
            }else{//反之 
                swap(p[i],p[i+k]);//交换最小数和与最小数的差为k的数 
                break;
            }
        }
        printf("Yes\n");
        for(int i=1;i<=n;i++){
            printf("%lld ",p[i]);
        }
        printf("\n");
    }
    return 0;
}
```
    - **核心思想**：先递归计算最大曼哈顿值，判断 $k$ 是否有解，若有解则根据 $k$ 与当前最大最小数差的大小交换元素构造排列。

### 最优关键思路或技巧
- 利用排列曼哈顿值为偶数的性质，快速判断无解情况。
- 通过交换数对来增加曼哈顿值，将问题转化为拆分数字的问题。
- 递归计算最大曼哈顿值，简化计算过程。

### 可拓展之处
同类型题可考察其他类型的排列构造问题，如满足特定条件的排列、排列的组合问题等。类似算法套路包括贪心构造、递归构造、二分构造等。

### 推荐洛谷题目
- P1088 火星人：排列的全排列问题，可通过模拟排列的生成过程求解。
- P1337 [JSOI2004] 平衡点 / 吊打XXX：物理模型与数学优化问题，可通过贪心或模拟退火算法求解。
- P1850 换教室：动态规划与概率问题，可通过状态转移方程求解。

### 个人心得摘录与总结
- **作者：BAKABAKA**：提到可以通过打表找规律，发现排列曼哈顿值的奇偶性规律，同时表示自己讲解啰嗦，代码抽象。总结：打表是一种寻找规律的有效方法，但在讲解和代码实现时应尽量简洁明了。
- **作者：Exp10re**：提到VP时用时 $C\geq F$，懒得算最大曼哈顿值的上界。总结：在竞赛中可能会因为时间或精力问题放弃一些细节，但应尽量保证思路的完整性。 

---
处理用时：41.74秒
# 题目信息

# Minimize Equal Sum Subarrays

## 题目描述

# 最小化相等和子数组


已知 [农夫约翰喜欢排列](https://usaco.org/index.php?page=viewproblem2&cpid=1421)，我也喜欢它们！

给定一个长度为 $ n $ 的排列 $ p $。

找到一个长度为 $ n $ 的排列 $ q $，使得以下条件下的对数最小化：对所有 $ 1 \leq i \leq j \leq n $，使得 $ p_i + p_{i+1} + \ldots + p_j = q_i + q_{i+1} + \ldots + q_j $。

**注**：一个长度为 $ n $ 的排列是一个包含 $ 1 $ 到 $ n $ 的 $ n $ 个不同整数的数组。例如，\[2, 3, 1, 5, 4\] 是一个排列，但 \[1, 2, 2\] 不是一个排列（数字 2 在数组中出现了两次），而 \[1, 3, 4\] 也不是一个排列（$ n=3 $，但数组中有 4）。

## 说明/提示

对于第一个测试用例，存在唯一一对 $ (i, j) $ ($ 1 \leq i \leq j \leq n $) 使得 $ p_i + p_{i+1} + \ldots + p_j = q_i + q_{i+1} + \ldots + q_j $，即 $ (1, 2) $。可以证明，没有这样的 $ q $ 使得不存在满足条件的对。

## 样例 #1

### 输入

```
3
2
1 2
5
1 2 3 4 5
7
4 7 5 1 2 6 3```

### 输出

```
2 1
3 5 4 2 1
6 2 1 4 7 3 5```

# AI分析结果

### 题目翻译
已在输入中给出中文题目，无需翻译。

### 综合分析与结论
这些题解思路基本一致，均是通过将排列 $p$ 中的元素进行位置移动来构造排列 $q$，以达到使满足条件的区间对数最少的目的。多数题解采用将排列 $p$ 整体左移或右移一位的方法，证明了除整个序列外其他区间和不同，满足条件的区间对数最小为 1。

|题解作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|GLr137|考虑将排列 $p$ 每个数向左移动一位得到排列 $q$，通过表格分析不同长度区间内数字情况来证明可行性|将 $p$ 左移一位构造 $q$，并按此输出 $q$|证明左移一位后满足条件的区间对数最少|4星|
|Even_If|让 $q$ 中的最后一个元素移到最前面，其他元素向后移一位，使 $sumq$ 与 $sump$ 错位|将 $q$ 最后元素移到首位，其他元素后移，按此输出 $q$|找到使 $sump$ 和 $sumq$ 错位的方法|4星|
|joe_zxq|模拟样例并写暴力计算小数据构造方案，发现将数列错开一位可行，证明除整个序列外其他区间和不同|将数列错开一位构造 $q$ 并输出|证明错开一位后满足条件的区间对数最少|4星|
|Cyx20110930|构造 $q_i=p_{(i\bmod n) + 1}$，通过数学推导证明只有 $(1,n)$ 满足条件|按 $q_i=p_{(i\bmod n) + 1}$ 构造 $q$ 并输出|证明构造的 $q$ 满足条件的区间对数最少|4星|
|_Mortis_|把排列 $p$ 的第一个数放到最后得到排列 $q$，分析不同区间和的情况证明可行性|将 $p$ 第一个数放最后构造 $q$ 并输出|证明构造的 $q$ 满足条件的区间对数最少|4星|
|DesignDigits|使 $q_i=p_i+1$（若 $p_i=n$ 则 $q_i=1$），通过数学推导证明该构造方案满足条件的区间对数为 1 且最优|按 $q_i=p_i+1$（若 $p_i=n$ 则 $q_i=1$）构造 $q$|证明构造的 $q$ 满足条件的区间对数最少|3星|

### 所选题解
- **GLr137（4星）**：关键亮点是通过表格直观展示左移一位的情况，思路清晰易懂。
```cpp
# include <bits/stdc++.h>
using namespace std;
int main (){
    int t, n, sz[200005];
    cin >> t;
    for (int i = 1; i <= t; i++){
        cin >> n;
        for (int i = 1; i <= n; i++){
            cin >> sz[i];
        }
        for (int i = 2; i <= n; i++){
            cout << sz[i] << " ";
        }
        cout << sz[1] << "\n";
    }
    return 0;
}
```
核心实现思想：先读取测试用例数量 $t$，对于每个测试用例，读取排列 $p$ 的长度 $n$ 和排列元素，然后将排列 $p$ 左移一位输出得到排列 $q$。

- **Even_If（4星）**：关键亮点是明确指出将 $q$ 最后元素移到首位使 $sumq$ 与 $sump$ 错位的思路。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t;
const int N = 2e5 + 10;
int a[N];
signed main(void) {
    cin >> t;
    while (t --) {
        int n;
        cin >> n;
        for (int i = 1; i <= n; i ++) {
            cin >> a[i];
        }
        cout << a[n] << ' ';
        for (int i = 1; i < n; i ++) cout << a[i] << ' ';
        cout << endl;
    }
    return 0;
}
```
核心实现思想：读取测试用例数量 $t$，对于每个测试用例，读取排列 $p$ 的长度 $n$ 和元素，将排列 $p$ 的最后元素移到首位，其他元素后移输出得到排列 $q$。

- **Cyx20110930（4星）**：关键亮点是通过数学公式构造 $q$ 并进行严格证明。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[200024];
void solve() {
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cout<<a[i%n+1]<<' ';
    cout<<endl;
}
int main() {
    int t;cin>>t;
    while(t--)
        solve();
}
```
核心实现思想：读取测试用例数量 $t$，对于每个测试用例，读取排列 $p$ 的长度 $n$ 和元素，根据 $q_i=p_{(i\bmod n) + 1}$ 构造并输出排列 $q$。

### 最优关键思路或技巧
通过将排列 $p$ 进行位置移动（如左移、右移一位或按特定公式构造）来构造排列 $q$，并通过分析不同长度区间内数字情况或进行数学推导来证明构造的 $q$ 能使满足条件的区间对数最少。

### 可拓展之处
同类型题可能会改变排列的条件或求和的规则，类似算法套路可以是通过观察、分析和数学推导找到一种构造方案，然后证明该方案的最优性。

### 洛谷推荐题目
- P1008 三连击
- P1047 校门外的树
- P1067 多项式输出

---
处理用时：30.21秒
# 题目信息

# Harder Problem

## 题目描述

给定一个正整数序列，若一个正整数在该序列中出现最多次，则称其为该序列的众数（ mode ）。例如，序列 $[2,2,3]$ 的众数为 $2$ 。 $9$ ， $8$ 或 $7$ 的任意一个都可以被认为是序列 $[9,9,8,8,7,7]$ 的众数。

你给了 UFO 一个长度为 $n$ 的数组 $a$ 。为了感谢你， UFO 决定构造一个长度也为 $n$ 的数组 $b$ ，使得对于所有 $1 \leq i \leq n$ ，$a_i$ 是序列 $[b_1, b_2, …, b_i]$ 的众数。

然而， UFO 不知道怎么构造数组 b ，因此你需要帮助她。注意：构造的数组 b 中的元素 $b_i$ 需满足 $1 \leq b_i \leq n$ 。

## 说明/提示

对第 2 组测试样例正确性的证明：

- 当 $i = 1$ 时， $1$ 是 $[1]$ 唯一的众数；
- 当 $i = 2$ 时， $1$ 是 $[1, 1]$ 唯一的众数；
- 当 $i = 3$ 时， $1$ 是 $[1, 1, 2]$ 唯一的众数；
- 当 $i = 4$ 时， $1$ 或 $2$ 均为 $[1, 1, 2, 2]$ 的众数。由于 $a_i = 2$ ，因此这个数组是有效的。

## 样例 #1

### 输入

```
4
2
1 2
4
1 1 1 2
8
4 5 5 5 1 1 2 1
10
1 1 2 2 1 1 3 3 1 1```

### 输出

```
1 2
1 1 2 2
4 5 5 1 1 2 2 3
1 8 2 2 1 3 3 9 1 1```

# AI分析结果

### 题目翻译
#### 难题

#### 题目描述
给定一个正整数序列，若一个正整数在该序列中出现最多次，则称其为该序列的众数（mode）。例如，序列 $[2,2,3]$ 的众数为 $2$ 。$9$ ，$8$ 或 $7$ 的任意一个都可以被认为是序列 $[9,9,8,8,7,7]$ 的众数。

你给了 UFO 一个长度为 $n$ 的数组 $a$ 。为了感谢你，UFO 决定构造一个长度也为 $n$ 的数组 $b$ ，使得对于所有 $1 \leq i \leq n$ ，$a_i$ 是序列 $[b_1, b_2, …, b_i]$ 的众数。

然而，UFO 不知道怎么构造数组 $b$ ，因此你需要帮助她。注意：构造的数组 $b$ 中的元素 $b_i$ 需满足 $1 \leq b_i \leq n$ 。

#### 说明/提示
对第 2 组测试样例正确性的证明：
- 当 $i = 1$ 时，$1$ 是 $[1]$ 唯一的众数；
- 当 $i = 2$ 时，$1$ 是 $[1, 1]$ 唯一的众数；
- 当 $i = 3$ 时，$1$ 是 $[1, 1, 2]$ 唯一的众数；
- 当 $i = 4$ 时，$1$ 或 $2$ 均为 $[1, 1, 2, 2]$ 的众数。由于 $a_i = 2$ ，因此这个数组是有效的。

#### 样例 #1
##### 输入
```
4
2
1 2
4
1 1 1 2
8
4 5 5 5 1 1 2 1
10
1 1 2 2 1 1 3 3 1 1
```
##### 输出
```
1 2
1 1 2 2
4 5 5 1 1 2 2 3
1 8 2 2 1 3 3 9 1 1
```

### 综合分析与结论
这些题解的核心思路基本一致，都是利用“当序列中每个数都只出现一次时，所有数都是众数”这一特性来构造数组 $b$。对于数组 $a$ 中首次出现的元素，直接将其作为 $b$ 数组对应位置的元素；对于重复出现的元素，选择一个在 $a$ 中未出现过的数作为 $b$ 数组对应位置的元素。

算法要点在于使用标记数组、集合、映射等数据结构来记录元素是否出现过，以及存储未出现过的元素。

解决的难点主要是处理数组 $a$ 中重复元素的情况，保证构造出的数组 $b$ 满足 $a_i$ 是 $[b_1, b_2, …, b_i]$ 的众数这一条件。

### 所选题解
- **作者：JimmyQ (赞：4)，5星**
    - **关键亮点**：思路清晰，代码简洁，使用标记数组 `vis` 来记录元素是否出现过，直接模拟构造过程。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
long long t,vis[N],cnt,n,a[N];
int main(){
    cin>>t;
    while(t--){
        memset(vis,0,sizeof(vis)),cnt=0;
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        for(int i=1;i<=n;i++){
            if(vis[a[i]]==1) cnt++;
            else{
                vis[a[i]]=1;
                cout<<a[i]<<" ";
            }
        }
        for(int i=1;i<=n;i++){
            if(vis[i]!=1) cout<<i<<" ";
        }
    }
}
```
核心实现思想：先遍历数组 $a$，对于首次出现的元素，输出该元素并标记；然后遍历 $1$ 到 $n$，输出未标记过的元素。

- **作者：如履薄冰 (赞：3)，4星**
    - **关键亮点**：使用 `map` 来标记元素是否出现过，代码逻辑清晰，适合初学者理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[1100000];
signed main(){
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--){
        int cnt=0;
        map<int,bool> vis;
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        for(int i=1;i<=n;i++){
            if(vis[a[i]]){
                cnt++;
                continue;
            }
            vis[a[i]]=true;
            cout<<a[i]<<" ";
        }
        for(int i=1;i<=n;i++){
            if(vis[i]==false){
                cout<<i<<" ";
            }
        }
    }
    return 0;
}
```
核心实现思想：利用 `map` 标记元素是否出现过，遍历数组 $a$，首次出现的元素输出并标记，最后输出未标记过的元素。

- **作者：__Deng_Rui_Song__ (赞：2)，4星**
    - **关键亮点**：使用 `set` 来存储未出现过的元素，代码简洁，逻辑清晰。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n;
set<int> st;
void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) st.insert(i);
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        if (st.count(x)) {
            cout << x << ' ';
            st.erase(x);
        } else {
            int tmp;
            for (int i : st) {
                tmp = i;
                break;
            }
            cout << tmp << ' ';
            st.erase(tmp);
        }
    }
    cout << '\n';
    st.clear();
}
int main() {
    for (cin >> t; t--; solve())
        ;
    return 0;
}
```
核心实现思想：先将 $1$ 到 $n$ 插入 `set` 中，遍历数组 $a$，若元素在 `set` 中，输出该元素并从 `set` 中删除；否则，输出 `set` 中的第一个元素并删除。

### 最优关键思路或技巧
- **数据结构**：使用标记数组、`map`、`set` 等数据结构来记录元素是否出现过，方便处理重复元素。
- **思维方式**：利用“每个数都只出现一次时，所有数都是众数”的特性，将问题转化为构造一个 $[1, n]$ 的排列。

### 拓展思路
同类型题或类似算法套路：
- 构造满足特定条件的数组，如构造满足某种单调性、对称性的数组。
- 处理序列中的重复元素，如去重、统计重复次数等。

### 推荐题目
- [P1047 [NOIP2005 普及组] 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1205 [USACO1.2] 方块转换 Transformations](https://www.luogu.com.cn/problem/P1205)
- [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)

### 个人心得摘录与总结
部分作者提到在考场上被该题硬控一段时间，说明在解题时可能会遇到思路不清晰的情况。总结来说，遇到构造题时，要仔细分析题目条件，尝试找到一些特殊性质或规律，将问题转化为已知的问题或简单的操作，同时合理运用数据结构来简化代码实现。

---
处理用时：41.47秒
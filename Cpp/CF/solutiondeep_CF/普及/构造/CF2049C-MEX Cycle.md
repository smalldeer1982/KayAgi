# 题目信息

# MEX Cycle

## 题目描述

Evirir 这只龙有很多朋友。它有 **3** 个朋友！这比普通龙多一个。

你得到了三个整数 $ n $ , $ x $ 和 $ y $ 。有 $ n $ 只龙围成一个圈坐着。龙从 $ 1 $ 到 $ n $ 编号。对于每个 $ i $ ( $ 1 \le i \le n $ )，龙 $ i $ 与龙 $ i - 1 $ 和 $ i + 1 $ 是朋友，其中龙 $ 0 $ 被定义为龙 $ n $ ，龙 $ n + 1 $ 被定义为龙 $ 1 $ 。此外，龙 $ x $ 和龙 $ y $ 也是朋友（如果它们已经是朋友了，这不会改变任何东西）。请注意，所有的友谊都是相互的。

你需要输出 $ n $ 个非负整数 $ a_1, a_2, \ldots, a_n $ ，使得对于每只龙 $ i $ ( $ 1 \le i \le n $ )，以下条件成立：

- 设 $ f_1, f_2, \ldots, f_k $ 是龙 $ i $ 的朋友。那么 $ a_i = \operatorname{mex}(a_{f_1}, a_{f_2}, \ldots, a_{f_k}) $ 。 $ ^{\text{∗}} $

 $ ^{\text{∗}} $ 集合 $ c_1, c_2, \ldots, c_m $ 的最小排除值 (MEX) 被定义为最小的非负整数 $ t $ ，它不在集合 $ c $ 中出现。

## 说明/提示

对于第一个测试用例：

- $ i = 1 $ : 龙 $ 1 $ 的朋友是龙 $ 2, 3, 5 $  $ \operatorname{mex}(a_2, a_3, a_5) = \operatorname{mex}(2, 1, 1) = 0 = a_1 $ ，所以龙 $ 1 $ 的条件满足
- $ i = 2 $ : 龙 $ 2 $ 的朋友是龙 $ 1, 3 $  $ \operatorname{mex}(a_1, a_3) = \operatorname{mex}(0, 1) = 2 = a_2 $ 
- $ i = 3 $ : 龙 $ 3 $ 的朋友是龙 $ 1, 2, 4 $  $ \operatorname{mex}(a_1, a_2, a_4) = \operatorname{mex}(0, 2, 0) = 1 = a_3 $ 
- $ i = 4 $ : 龙 $ 4 $ 的朋友是龙 $ 3, 5 $  $ \operatorname{mex}(a_3, a_5) = \operatorname{mex}(1, 1) = 0 = a_4 $ 
- $ i = 5 $ : 龙 $ 5 $ 的朋友是龙 $ 1, 4 $  $ \operatorname{mex}(a_1, a_4) = \operatorname{mex}(0, 0) = 1 = a_5 $

## 样例 #1

### 输入

```
7
5 1 3
4 2 4
6 3 5
7 3 6
3 2 3
5 1 5
6 2 5```

### 输出

```
0 2 1 0 1
1 2 1 0
1 2 0 1 2 0
0 1 2 0 1 0 1
2 0 1
1 0 2 1 0
0 1 2 0 2 1```

# AI分析结果

### 题目内容（已为中文，无需翻译）
【题目内容】
# MEX Cycle

## 题目描述

Evirir 这只龙有很多朋友。它有 **3** 个朋友！这比普通龙多一个。

你得到了三个整数 $ n $, $ x $ 和 $ y $ 。有 $ n $ 只龙围成一个圈坐着。龙从 $ 1 $ 到 $ n $ 编号。对于每个 $ i $ ( $ 1 \le i \le n $ )，龙 $ i $ 与龙 $ i - 1 $ 和 $ i + 1 $ 是朋友，其中龙 $ 0 $ 被定义为龙 $ n $ ，龙 $ n + 1 $ 被定义为龙 $ 1 $ 。此外，龙 $ x $ 和龙 $ y $ 也是朋友（如果它们已经是朋友了，这不会改变任何东西）。请注意，所有的友谊都是相互的。

你需要输出 $ n $ 个非负整数 $ a_1, a_2, \ldots, a_n $ ，使得对于每只龙 $ i $ ( $ 1 \le i \le n $ )，以下条件成立：

- 设 $ f_1, f_2, \ldots, f_k $ 是龙 $ i $ 的朋友。那么 $ a_i = \operatorname{mex}(a_{f_1}, a_{f_2}, \ldots, a_{f_k}) $ 。 $ ^{\text{∗}} $

 $ ^{\text{∗}} $ 集合 $ c_1, c_2, \ldots, c_m $ 的最小排除值 (MEX) 被定义为最小的非负整数 $ t $ ，它不在集合 $ c $ 中出现。

## 说明/提示

对于第一个测试用例：

- $ i = 1 $ : 龙 $ 1 $ 的朋友是龙 $ 2, 3, 5 $  $ \operatorname{mex}(a_2, a_3, a_5) = \operatorname{mex}(2, 1, 1) = 0 = a_1 $ ，所以龙 $ 1 $ 的条件满足
- $ i = 2 $ : 龙 $ 2 $ 的朋友是龙 $ 1, 3 $  $ \operatorname{mex}(a_1, a_3) = \operatorname{mex}(0, 1) = 2 = a_2 $ 
- $ i = 3 $ : 龙 $ 3 $ 的朋友是龙 $ 1, 2, 4 $  $ \operatorname{mex}(a_1, a_2, a_4) = \operatorname{mex}(0, 2, 0) = 1 = a_3 $ 
- $ i = 4 $ : 龙 $ 4 $ 的朋友是龙 $ 3, 5 $  $ \operatorname{mex}(a_3, a_5) = \operatorname{mex}(1, 1) = 0 = a_4 $ 
- $ i = 5 $ : 龙 $ 5 $ 的朋友是龙 $ 1, 4 $  $ \operatorname{mex}(a_1, a_4) = \operatorname{mex}(0, 0) = 1 = a_5 $

## 样例 #1

### 输入

```
7
5 1 3
4 2 4
6 3 5
7 3 6
3 2 3
5 1 5
6 2 5
```

### 输出

```
0 2 1 0 1
1 2 1 0
1 2 0 1 2 0
0 1 2 0 1 0 1
2 0 1
1 0 2 1 0
0 1 2 0 2 1
```

### 综合分析与结论
这些题解核心思路一致，先考虑无额外边（$x$ 和 $y$）的情况，根据环长度 $n$ 的奇偶性构造序列：
 - 当 $n$ 为偶数，序列为 $0$、$1$ 交替。
 - 当 $n$ 为奇数，指定一个节点为 $2$，其余节点 $0$、$1$ 交替。

再考虑额外边（$x$ 和 $y$）的影响：
 - 若 $a_x$ 和 $a_y$ 不同，不改变原构造。
 - 若 $a_x$ 和 $a_y$ 相同，部分题解将 $a_x$ 设为 $2$；部分题解在 $x$ 与 $n$ 相邻且 $n$ 为奇数时，交换 $a_x$ 和 $a_n$。

### 所选题解
- **作者：Misaka屮Mikoto（5星）**
    - **关键亮点**：思路清晰，通过图形直观展示环的构造方式，便于理解。
    - **个人心得**：无
- **作者：zhangzirui66（4星）**
    - **关键亮点**：思路详细，代码实现简洁明了，对 $x$ 和 $y$ 的处理情况分类清晰。
    - **个人心得**：认为这是做过最有意思的构造题，且表示拿出草稿纸举例子就能理解思路。
- **作者：Ambrose0321（4星）**
    - **关键亮点**：思路简洁，代码规范，对 $x$ 和 $y$ 的处理逻辑清晰。
    - **个人心得**：希望题解能过审。

### 重点代码
#### Misaka屮Mikoto
无代码，核心思路是先按环长度奇偶性构造，再拆分有额外边的图为两个环，对重合部分赋值，其余按前面方法构造。
#### zhangzirui66
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, x, y, a[200005];
int main(){
    cin >> t;
    while(t --){
        cin >> n >> x >> y;
        if(n & 1){
            for(int i = 2; i <= n; i += 2) a[i - 1] = 0, a[i] = 1; a[n] = 2;
            if(a[x] == 0 && a[y] == 0){
                if(x == n - 1 || x == 1) swap(a[x], a[n]);
                else a[x] = 2;
            }
            if(a[x] == 1 && a[y] == 1){
                if(x == n - 1 || x == 1) swap(a[x], a[n]);
                else a[x] = 2;
            }
        }
        else{
            for(int i = 1; i <= n; i += 2) a[i] = 0, a[i + 1] = 1;
            if(a[x] == 0 && a[y] == 0){
                a[x] = 2;
            }
            if(a[x] == 1 && a[y] == 1){
                a[x] = 2;
            }
        }
        for(int i = 1; i <= n; i ++) cout << a[i] << " ";
        cout << "\n";
    }
    return 0;
}
```
**核心实现思想**：根据 $n$ 的奇偶性构造初始序列，再根据 $a_x$ 和 $a_y$ 的值及 $x$ 与 $n$ 的位置关系进行调整。
#### Ambrose0321
```cpp
#include <bits/stdc++.h>
#define pb push_back
using namespace std;
typedef long long ll;
const int N = 200001;
int _, n, x, y, t, c[N], f[N];
bool cnt;
int main() {
    scanf("%d", &_);
    for (; _--; ) {
        scanf("%d%d%d", &n, &x, &y);
        for (int i = 1; i <= n; i++)
            c[i] = 0;
        c[1] = 0;
        for (int i = 2; i < n; i++)
            c[i] = c[i - 1] ^ 1;
        c[n] = (n & 1) + 1;
        if (c[x] == c[y]) {
            if (x == 1 && n & 1)
                swap(c[x], c[n]);
            else
                c[x] = 2;
        }
        for (int i = 1; i <= n; i++)
            printf("%d ", c[i]);
        puts("");
    }
}
```
**核心实现思想**：先构造初始序列，若 $c_x$ 和 $c_y$ 相同，根据 $x$ 是否为 $1$ 且 $n$ 是否为奇数进行调整。

### 最优关键思路或技巧
- **分类讨论**：根据环长度 $n$ 的奇偶性和 $a_x$ 与 $a_y$ 的关系分类讨论，简化问题。
- **图形化思维**：如 Misaka屮Mikoto 用图形展示环的构造，更直观理解。

### 可拓展之处
同类型题可能会增加环的数量、边的数量或修改 MEX 规则。类似算法套路是先考虑简单情况构造基础解，再根据额外条件调整。

### 洛谷相似题目推荐
- P1182 数列分段 Section II
- P1024 一元三次方程求解
- P1014 Cantor表 

---
处理用时：44.48秒
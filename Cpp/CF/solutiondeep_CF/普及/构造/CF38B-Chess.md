# 题目信息

# Chess

## 题目描述

在一个大小8×8的国际象棋的棋盘有车和马两个棋子，保证一个棋子无法吃掉另一个。
    请把另一个马放在棋盘上,使得三个棋子都无法吃掉另一个。棋子只能放在一个空的地方。

## 样例 #1

### 输入

```
a1
b2
```

### 输出

```
44
```

## 样例 #2

### 输入

```
a8
d4
```

### 输出

```
38
```

# AI分析结果

### 思路与算法要点对比
|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|hensier|先特判马和车同行同列或车被马控制的情况，再暴力枚举棋盘位置，用bool数组标记可放马的位置并统计数量|设置马的走向常量数组，用bool二维数组保存位置状态|处理马吃车和马吃马的情况，避免越界|4星|
|Tenshi|将车能被马吃到的位置也看作车的控制点，标记车和第一个马的控制点，最后统计未标记的位置|使用方向数组控制马的走位，标记控制点|简化判断马是否能吃到车的过程|4星|
|CrTsIr400|循环枚举每个点，判断是否能吃到其他点或被吃，统计可放置的点|分别实现车、马、骑士位置的标记函数，用dfs函数统计可放置点|处理边界情况和棋子之间的攻击关系|3星|
|666DHG|标记不可放的位置，最后扫描棋盘统计可放的位置|将车当作马来走，标记其能走到的位置|判断固定车和放置马的攻击关系|3星|
|infinities|输入行列处理为数字，暴力枚举每个点，判断马在该点能否吃到别人或被吃，统计数量|用函数处理字符坐标转换为数字坐标，多个if语句进行暴力判断|处理大量的判断条件，避免重复和遗漏|2星|
|封禁用户|用bool二维数组储存是否可放棋子，用check函数处理越界情况，标记不可放的位置并统计可放位置|使用for循环和check函数简化标记过程|处理越界情况，减少if语句数量|2星|
|EuphoricStar|读入车和马的坐标，标记车的行和列、马能走到的坐标以及新马吃车要放置的坐标，最后统计未标记的点|使用方向数组遍历马的可能位置，标记不可放置的点|考虑新马吃车的情况|3星|
|Fool_Fish|将车看成马，标记其能控制的位置，标记车和马的位置及攻击范围，统计未标记的位置|实现car和horse函数分别标记车和马的位置及攻击范围|简化判断马是否能吃到车的条件|3星|
|fjy666|扫描所有点，用isv函数判断新马是否会攻击老马、车，以及车是否会攻击新马、新马和老马位置是否重合，统计可放置点|使用isv函数封装判断逻辑，坐标从(0,0)开始|处理多种攻击和位置重合情况|3星|
|BB2655|构造二维数组存放棋盘情况，输入车和马的坐标，标记车的行和列、车和马的攻击范围，最后统计未标记的点|用函数判断字母代表的行数，多个if和for语句标记攻击范围|处理车和马的攻击范围标记|2星|

### 高评分题解
- **hensier（4星）**
    - **关键亮点**：思路清晰，先进行特判，再暴力枚举，代码注释详细，便于理解。
    - **核心代码**：
```cpp
// 马的走向常量数组
int N[2][8]={{-1,-2,-2,-1,1,2,2,1},{-2,-1,1,2,-2,-1,1,2}};
bool a[9][9];
int main()
{
    scanf("%c%d\n%c%d",&rx,&ry,&nx,&ny);
    rx-='a'-1;
    nx-='a'-1;
    if(rx==nx||ry==ny)
    {
        printf("0");
        return 0;
    }
    for(i=1;i<9;i++)
    {
        for(j=1;j<9;j++)
        {
            if((i==rx&&j==ry)||(i==nx&&j==ny))continue;
            if(i==rx||j==ry)continue;
            a[i][j]=1;
            for(k=0;k<8;k++)
            {
                if(i+N[0][k]<1||i+N[0][k]>8||j+N[1][k]<1||j+N[1][k]>8)continue;
                if(i+N[0][k]==rx&&j+N[1][k]==ry)
                {
                    a[i][j]=0;
                    break;
                }
                if(i+N[0][k]==nx&&j+N[1][k]==ny)
                {
                    a[i][j]=0;
                    break;
                }
            }
        }
    }
    for(i=1;i<9;i++)for(j=1;j<9;j++)if(a[i][j])s++;
    printf("%d",s);
}
```
- **Tenshi（4星）**
    - **关键亮点**：转换思路，将车能被马吃到的位置看作车的控制点，简化判断过程，代码结构清晰。
    - **核心代码**：
```cpp
int dx[]={-2,-2,-1,-1, 1, 1, 2, 2};
int dy[]={-1, 1,-2, 2,-2, 2,-1, 1};
bool mp[10][10];
int main(){
    char ch1,ch2;
    int y1,y2;
    cin>>ch1>>y1;
    cin>>ch2>>y2;
    int x1,x2;
    x1=ch1-'a'+1;
    x2=ch2-'a'+1;
    // 标记车的控制点
    mp[x1][y1]=true;
    for(int i=1;i<=8;i++)
        mp[x1][i]=mp[i][y1]=true;
    for(int i=0;i<8;i++){
        int kx1=x1+dx[i];
        int ky1=y1+dy[i];
        if(kx1<1||kx1>8||ky1<1||ky1>8)continue;
        mp[kx1][ky1]=true;
    }
    // 标记马的控制点
    mp[x2][y2]=true;
    for(int i=0;i<8;i++){
        int kx2=x2+dx[i];
        int ky2=y2+dy[i];
        if(kx2<1||kx2>8||ky2<1||ky2>8)continue;
        mp[kx2][ky2]=true;
    } 
    int res=0;
    for(int i=1;i<=8;i++)
        for(int j=1;j<=8;j++)
            if(!mp[i][j]) res++;
    cout<<res;
    return 0;
}
```

### 最优关键思路与技巧
- **思维方式**：将车能被马吃到的位置看作车的控制点，简化判断马是否能吃到车的过程。
- **代码实现技巧**：使用方向数组控制马的走位，减少代码重复；用bool二维数组标记位置状态，方便统计可放置的位置。

### 可拓展之处
同类型题如在更大的棋盘上放置更多的棋子，要求满足一定的攻击或不攻击条件；类似算法套路可用于处理其他棋盘类问题，如八皇后问题、骑士巡游问题等。

### 洛谷相似题目推荐
1. P1219 [USACO1.5]八皇后 Checker Challenge
2. P1450 [HAOI2008]硬币购物
3. P1002 [NOIP2002 普及组] 过河卒

### 个人心得摘录与总结
- **666DHG**：提到感觉题目简单，连编译器都没跑就一次AC，强调了把固定车当作马来走标记其能走到的位置来判断固定车和放置马的攻击关系，以及注意标记固定马本身的位置。总结：做题时可尝试转换思路简化问题，同时要注意细节。
- **infinities**：表示代码丑、码风毒瘤，提到用y1做坐标编译出错改用y3，还指出本方法对空间要求小，但复杂度为O(n^2)，数据大时会TLE。总结：编码时要注意变量命名和代码风格，同时要考虑算法复杂度对数据规模的适应性。 

---
处理用时：43.34秒
# 题目信息

# New Year Book Reading

## 题目描述

小明非常喜欢读书。他一共有 $n$ 本书，编号为 $1\sim n$，第 $i$本书重 $w_i$。

小明计划在暑假的 $m$ 天里每天读一本书，第 $i$ 天读第 $d_i$ 本书，可能会重复读到同一本书。

因为所有的书都是堆成一摞的，所以每次读某本书之前小明都需要先将这本书上面所有的书搬开，拿出这本书，再将搬开的书按原顺序放回去，消耗体力为搬开书的重量之和，读完这本书后将其放在这摞书的最上面。

小明想知道这 $n$ 本书以怎样的初始顺序放置，所搬书消耗总体力最小。

## 样例 #1

### 输入

```
3 5
1 2 3
1 3 2 3 1
```

### 输出

```
12
```

# AI分析结果

### 题目内容已为中文，无需翻译

### 综合分析与结论
这些题解都采用了贪心算法来解决问题，核心思路均是按照书第一次出现的顺序摆放书，能使搬书消耗的总体力最小。
- **思路对比**：“一叶知秋。”和“watermouthhang”通过构造初始序列模拟搬书过程；“LesterYu”开多个数组存储信息并模拟；“Luckies”“A_better_world”和“墨舞灵纯”则是倒序枚举之前看过的书来计算每次搬书的体力。
- **算法要点**：各题解都需记录书的重量和看书顺序，关键在于如何确定初始书的摆放顺序和计算每次搬书的体力。
- **解决难点**：难点在于理解贪心策略的正确性以及如何高效计算每次搬书的体力，避免重复计算。

### 评分较高的题解
- **一叶知秋。（5星）**
    - **关键亮点**：思路清晰，对贪心策略有详细解释，代码中有快读优化，且对代码中的关键步骤有注释。
    - **核心代码**：
```cpp
while(i<=m){//构造序列
    i++;
    if(v[b[i]])continue;
    while(b[i]==b[i-1])i++;
    xl[++k]=b[i];
    v[b[i]]=true;
}
k--;
for(i=1;i<=k/2;i++){//反着来
    int c=xl[i];
    xl[i]=xl[k-i+1];
    xl[k-i+1]=c;
}
for(i=1;i<=m;i++){
    int s=0;
    for(j=k;j>=1;j--){//求第i次阅读的重量
        if(b[i]==xl[j])break;
        s+=a[xl[j]];
    }
    xl[++k]=xl[j];//划重点
    xl[j]=0;//划重点
    ans+=s;
}
```
    - **核心实现思想**：先构造初始书的摆放序列，然后反序处理，接着模拟每天看书的过程，计算每次搬书的体力并更新书的位置。
- **Luckies（4星）**
    - **关键亮点**：对贪心策略的解释简单易懂，代码简洁，使用 `vis` 数组避免重复计算。
    - **核心代码**：
```cpp
for (int i = 1; i <= m; i++)
{
    cin >> a[i];//输入要看的书
    memset(vis, 0, sizeof(vis));//对于每次阅读书，都要重新统计上面的所有书的总重量
    int sum = 0;
    for (int j = i - 1; j >= 1; j--)//倒序枚举之前看过的书
    {
        if (a[j] == a[i])//如果之前看过，那么a[j]前面的书就不需要搬动
            break;
        if (!vis[a[j]])//重复的书只统计一次重量
        {
            sum += w[a[j]];
            vis[a[j]] = true;//标记这本书已经统计过了，后面不计算重量
        }
    }
    ans += sum;//需要的体力加到总体力里面去
}
```
    - **核心实现思想**：每次输入要看的书后，倒序枚举之前看过的书，计算上面书的总重量，使用 `vis` 数组标记已统计的书，避免重复计算。
- **A_better_world（4星）**
    - **关键亮点**：有快读优化，对核心代码有详细注释，思路清晰。
    - **核心代码**：
```c
for(int i = 1; i <= m; i++)
{
    a[i] = read();
    memset(vis, 0, sizeof(vis)); // 清空。
    sum = 0;
    for(int j = i - 1; j >= 1; j--) // 计算前面所有数的 总重量。
    {
        if(a[j] == a[i])
            break;
        if(vis[a[j]] == false) // 重复的数值统计一次。
        {
            sum += w[a[j]];
            vis[a[j]] = true; // 标记这本书已经统计，不再做统计。
        }
    }
    ans += sum; // 需要的体力加到总体力里去。
}
```
    - **核心实现思想**：与“Luckies”的思路一致，通过倒序枚举和 `vis` 数组计算每次搬书的体力。

### 最优关键思路或技巧
- **贪心策略**：按照书第一次出现的顺序摆放书，可使搬书消耗的总体力最小。
- **避免重复计算**：使用 `vis` 数组标记已统计的书，避免重复计算重量。

### 可拓展之处
同类型题可能涉及不同的物品摆放和操作规则，但贪心策略依然适用，关键在于找到最优的初始排列顺序。类似算法套路还有区间贪心、活动选择问题等。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的使用。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：经典的贪心问题，通过排序找到最优方案。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法在背包问题中的应用。

### 个人心得摘录与总结
- **一叶知秋。**：通过修改样例发现正解与书的重量无关，从而推出贪心策略，强调了对样例的分析和尝试的重要性。
- **Luckies**：认为这题对于自己来说是比较复杂的贪心题，说明贪心题的难度可能因人而异，需要多练习和思考。

---
处理用时：29.20秒
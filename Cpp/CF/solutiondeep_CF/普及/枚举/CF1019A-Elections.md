# 题目信息

# Elections

## 题目描述

Berland地区的腐败现象非常常见。

马上有一场选举，你事先知道了选民和政党的数量，分别为  $n$  和  $m$  ，对于每一位选民，你知道他将要选举哪一个政党，不过，每一位选民都会在接受一定数额的金钱之后改变他的主意。如果你给第  $i$  位选民  $c_i$  数额的比特币，他就会选举任何你希望他选举的政党。

你的目的是让Berland的联合党赢得这场选举，联合党必须拥有比其它政党都多的选票，在此基础之上，你希望花费的比特币尽可能少。

## 样例 #1

### 输入

```
1 2
1 100
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 5
2 100
3 200
4 300
5 400
5 900
```

### 输出

```
500
```

## 样例 #3

### 输入

```
5 5
2 100
3 200
4 300
5 800
5 900
```

### 输出

```
600
```

# AI分析结果

### 题目内容（已为中文，无需翻译）
Berland地区的腐败现象非常常见。

马上有一场选举，你事先知道了选民和政党的数量，分别为  $n$  和  $m$  ，对于每一位选民，你知道他将要选举哪一个政党，不过，每一位选民都会在接受一定数额的金钱之后改变他的主意。如果你给第  $i$  位选民  $c_i$  数额的比特币，他就会选举任何你希望他选举的政党。

你的目的是让Berland的联合党赢得这场选举，联合党必须拥有比其它政党都多的选票，在此基础之上，你希望花费的比特币尽可能少。

### 综合分析与结论
- **思路对比**：多数题解采用枚举联合党最终选票数的逆向思维，如易极feng、KingPowers、Frozencode等；Computer1828和傅思维666在此基础上使用二分优化枚举过程；Mickey_snow枚举票数第二政党的选票数。
- **算法要点**：先对每个政党的选民按贿赂金额排序，对于枚举的选票数，将选票数大于该值的政党的部分选民买过来，使这些政党票数小于该值，若联合党票数不够则从剩余选民中选便宜的买。
- **解决难点**：直接贪心复杂，通过枚举联合党最终票数简化问题，将问题转化为已知目标票数求最小花费。

### 所选题解
- **易极feng（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，详细解释了枚举和贪心的过程。
    - **个人心得**：比赛时贪心想错，后来想到枚举自己的最终选票使贪心变得清晰，体现逆向思维的重要性。
    - **核心代码**：
```cpp
for(i=mv;i<=n;i++){
    memset(v,0,sizeof(v));
    memset(t,0,sizeof(t));
    cnt=vote=0;
    for(j=1;j<=n;j++){
        if(s[j].p==1){
            vote++,v[j]=1;
            continue;
        }
        if(p[s[j].p]-t[s[j].p]>=i){
            cnt+=s[j].c,v[j]=1,t[s[j].p]++,vote++;
        }
    }
    j=1;
    while(vote<i){
        if(!v[j])cnt+=s[j].c,vote++;
        j++;
    }
    ans=min(ans,cnt);
}
```
核心思想：枚举联合党最终选票数，对于每个枚举值，先处理选票数大于该值的政党，再从剩余选民中补充票数。

- **KingPowers（4星）**
    - **关键亮点**：详细分析了复杂度，将投给相同政党的人的贿赂金存到vector并排序，方便处理。
    - **核心代码**：
```cpp
int check(int x){
    int tot=0,cost=0,cnt=0;
    for(int i=2;i<=m;i++){
        int j=0;
        if(v[i].size()>=x) j=v[i].size()-x+1;
        for(int k=0;k<j;k++) cost+=v[i][k];
        for(;j<v[i].size();j++) t[++tot]=v[i][j];
    }
    int pnt=n-tot;
    if(pnt>x) return -1;
    sort(t+1,t+tot+1);
    for(int i=1;i<=x-pnt;i++) cost+=t[i];
    return cost;
}
```
核心思想：检查联合党获得x张选票时的最小花费，先处理其他政党，再从剩余选民中补充票数。

- **Computer1828（4星）**
    - **关键亮点**：使用二分优化枚举过程，时间复杂度约为$O(n\log n)$。
    - **核心代码**：
```cpp
while(l<=r){
    int mid = (l+r)/2;
    if(check(mid) < check(mid+1)) r = mid-1;
    else l = mid+1;
}
```
核心思想：二分查找联合党最终的最优选票数，通过check函数判断花费情况。

### 最优关键思路或技巧
- **逆向思维**：枚举联合党最终选票数，将问题转化为已知目标票数求最小花费。
- **排序贪心**：对每个政党的选民按贿赂金额排序，优先选择便宜的选民。
- **二分优化**：在枚举选票数时使用二分查找，降低时间复杂度。

### 可拓展之处
同类型题可能涉及更多限制条件，如选民有不同属性、政党有不同影响力等，但解题思路仍可采用枚举和贪心的结合。类似算法套路可用于资源分配问题，通过枚举目标状态，贪心选择最优资源。

### 推荐洛谷题目
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)

### 个人心得摘录与总结
- 易极feng：比赛时贪心想错，后来想到枚举自己的最终选票使贪心变得清晰，强调逆向思维的重要性。
- KingPowers：刚看到题目无从下手，观察数据范围后想到枚举最终得票数，体现根据数据范围选择算法的重要性。
- Computer1828：考虑贪心和二分，注意二分时左端点和右端点的修改，提醒在使用二分算法时要注意边界条件。
- Mickey_snow：从选民下手贪心复杂，从政党入手枚举票数第二政党的选票数使贪心好想，说明选择合适的思考角度很关键。

---
处理用时：34.48秒
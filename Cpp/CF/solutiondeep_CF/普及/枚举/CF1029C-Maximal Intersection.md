# 题目信息

# Maximal Intersection

## 题目描述

给定n个闭区间,现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

## 样例 #1

### 输入

```
4
1 3
2 6
0 4
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
2 6
1 3
0 4
1 20
0 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
4 5
1 2
9 20
```

### 输出

```
0
```

## 样例 #4

### 输入

```
2
3 10
1 5
```

### 输出

```
7
```

# AI分析结果

### 题目翻译
#### 最大交集

#### 题目描述
给定n个闭区间，现在要求从这些闭区间中删除一个区间，使得剩下的（n - 1）个区间的交集的长度最大，求这个最大值。

（注：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数 - 左端点在数轴上表示的数）

#### 样例 #1
##### 输入
```
4
1 3
2 6
0 4
3 3
```
##### 输出
```
1
```

#### 样例 #2
##### 输入
```
5
2 6
1 3
0 4
1 20
0 4
```
##### 输出
```
2
```

#### 样例 #3
##### 输入
```
3
4 5
1 2
9 20
```
##### 输出
```
0
```

#### 样例 #4
##### 输入
```
2
3 10
1 5
```
##### 输出
```
7
```

### 综合分析与结论
这些题解的核心目标都是解决从n个闭区间中删除一个区间，使剩余（n - 1）个区间交集长度最大的问题。不同题解采用了多种思路和方法，下面从思路、算法要点和解决难点进行对比：
|作者|思路|算法要点|解决难点|
| ---- | ---- | ---- | ---- |
|CreeperK|记录前缀区间交和后缀区间交数组，通过三次扫描数组求解|存储前缀区间交lp和后缀区间交rp，对于每条线段，删去后的区间为`[max(lp[i - 1].l, rp[i + 1].l), min(lp[i - 1].r, rp[i + 1].r)]`|避免直接处理删除操作，通过前缀和后缀数组巧妙避开|
|Mickey_snow|计算去掉每个区间后剩余区间的交集|合并两个区间时，左端点取最大值，右端点取最小值；分两部分计算去掉每个区间后的交集|处理数据范围大时的计算，利用区间合并的交换律优化计算|
|fchwpo|枚举不选的区间，用前缀交集和后缀交集计算剩余区间交集|记录前缀交集和后缀交集，枚举每个区间计算剩余区间交集|高效计算不选某个区间后的交集|
|localhost|记录最大和次大左端点、最小和次小右端点，根据要删除的区间调整|记录最大和次大l、最小和次小r，若删除区间的l为最大L则取次大L，R同理|避免重复计算，快速得到删除区间后的交集|
|l_water|使用multiset存储左右端点，枚举删除区间并更新答案|multiset自动排序，枚举删除区间，找到剩余区间左右端点的最大和最小值|处理重复区间，利用multiset的特性简化操作|
|Jorisy|按左端点升序排序，用小根堆维护右端点|按左端点排序，小根堆维护右端点，堆元素为n - 1时更新答案|保证区间尽量靠近，高效更新答案|
|Zachary_260325|暴力找出要删除的区间，先求不删除时的重合区间，再找与边界重合的区间|暴力取min和max求不删除时的重合区间，找与边界重合的区间并分别计算剩余区间大小|确定删除哪个区间能增加重合大小|
|lihongqian__int128|维护左端点前缀最大值、右端点前缀最小值、左端点后缀最大值、右端点后缀最小值|记录前缀和后缀的最值，计算删除每个区间后的交集长度|高效计算删除区间后的交集长度|
|liuzhongrui|排序左右端点数组，遍历每个区间尝试移除并计算交集长度|排序左右端点，遍历区间，根据当前区间端点调整交集端点|通过排序快速找到最小左端点和最大右端点|
|BLUESKY007|用优先队列存储左右端点，考虑删除左端点最大和右端点最小的区间|优先队列存储左右端点，讨论删除区间的情况取max|确定删除哪个区间能使剩余区间交集最大|

### 评分较高的题解
- **CreeperK（5星）**
    - **关键亮点**：思路清晰，通过前缀和后缀区间交数组巧妙解决删除操作难题，代码简洁易懂。
    - **个人心得**：从类似题目中获得启发，意识到直接避开加入过程比先加入再分离更简单，强调“插入往往比删除容易”的思想。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int iz=3e5+5;
int lpl[iz],lpr[iz],rpl[iz],rpr[iz];//前缀与后缀
int l[iz],r[iz];//线段们
int n;
int main(){
    scanf("%d",&n);
    memset(lpr,0x7f,sizeof(lpr));
    memset(rpr,0x7f,sizeof(rpr));
    for(int i=1;i<=n;i++){
        scanf("%d%d",&l[i],&r[i]);
        lpl[i]=max(lpl[i-1],l[i]);
        lpr[i]=min(lpr[i-1],r[i]);
    }//读入&求出lp
    for(int i=n;i>=1;i--){
        rpl[i]=max(rpl[i+1],l[i]);
        rpr[i]=min(rpr[i+1],r[i]);
    }//求出rp
    int maxn=0;//把不合法的区间和长度为0的区间排除
    for(int i=1;i<=n;i++){
        maxn=max(min(lpr[i-1],rpr[i+1])-max(lpl[i-1],rpl[i+1]),maxn);//取区间长度最大值
    }
    printf("%d",maxn);
}
```
核心实现思想：先读入所有区间，计算前缀区间交lp，再计算后缀区间交rp，最后枚举每个区间，计算删除该区间后剩余区间的交集长度，取最大值。

- **Mickey_snow（4星）**
    - **关键亮点**：详细解释了区间合并的原理和计算过程，利用区间合并的交换律优化计算，时间复杂度为O(N)。
```cpp
#include<bits/stdc++.h>
using namespace std;

struct cg {
    int fr, to;
};
cg seg[300500], arr[300500];

cg Range(cg a, cg b) {
    cg ret;
    ret.fr = std::max(a.fr, b.fr); ret.to = std::min(a.to, b.to);
    return ret;
}

int main()
{
    int totSeg, fr, to;

    cin >> totSeg;
    for (int i = 0; i < totSeg; i++) {
        cin >> fr >> to;
        seg[i] = { fr,to };
        arr[i] = { INT_MIN,INT_MAX };
    }

    cg now = *seg;
    for (int i = 1; i < totSeg; i++) {
        arr[i] = now;
        now = Range(now, seg[i]);
    }
    now = seg[totSeg - 1];
    for (int i = totSeg - 2; i >= 0; i--) {
        arr[i] = Range(arr[i], now);
        now = Range(now, seg[i]);
    }

    int _max = 0;
    for (int i = 0; i < totSeg; i++)
        _max=std::max(_max, arr[i].to - arr[i].fr);

    cout << _max << endl;

    //system("pause");
    return 0;
}
```
核心实现思想：定义区间合并函数Range，分两部分计算去掉每个区间后的交集，最后遍历数组找出最大交集长度。

- **fchwpo（4星）**
    - **关键亮点**：代码简洁，通过记录前缀交集和后缀交集，枚举不选的区间计算剩余区间交集。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e5+5;
struct node{
    int ll,lr,rr,rl;
    int l,r;
}p[maxn];
int n;
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>p[i].l>>p[i].r;
    int nowl=-1,nowr=1e9+5;
    for(int i=1;i<=n;i++){
        p[i].ll=nowl;
        p[i].lr=nowr;
        nowl=max(p[i].l,nowl);
        nowr=min(p[i].r,nowr);
    } 
    nowl=-1,nowr=1e9+5;
    for(int i=n;i;i--){
        p[i].rl=nowl;
        p[i].rr=nowr;
        nowl=max(p[i].l,nowl);
        nowr=min(p[i].r,nowr);
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=max(ans,min(p[i].rr,p[i].lr)-max(p[i].ll,p[i].rl));
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：记录每个区间的前缀交集和后缀交集，枚举每个区间，计算删除该区间后剩余区间的交集长度，取最大值。

### 最优关键思路或技巧
- **前缀和后缀数组思想**：通过记录前缀区间交和后缀区间交数组，避免直接处理删除操作，简化计算过程。
- **区间合并的交换律**：在计算多个区间的交集时，利用区间合并的交换律，分两部分计算去掉每个区间后的交集，降低时间复杂度。

### 拓展思路
同类型题可拓展到删除多个区间、动态添加或删除区间等情况，类似算法套路可用于处理区间覆盖、区间合并等问题。

### 洛谷相似题目推荐
- P1880 [NOI1995] 石子合并
- P2068 统计和
- P1182 数列分段 Section II

### 个人心得摘录与总结
- **CreeperK**：从类似题目中获得启发，意识到直接避开加入过程比先加入再分离更简单，强调“插入往往比删除容易”的思想。
- **Zachary_260325**：认为本题虽然简单但很有意思，通过暴力找出要删除的区间，还提到代码有很多可优化的地方。 

---
处理用时：56.47秒
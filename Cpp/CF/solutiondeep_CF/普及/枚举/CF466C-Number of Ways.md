# 题目信息

# Number of Ways

## 题目描述

You've got array $ a[1],a[2],...,a[n] $ , consisting of $ n $ integers. Count the number of ways to split all the elements of the array into three contiguous parts so that the sum of elements in each part is the same.

More formally, you need to find the number of such pairs of indices $ i,j $ $ (2<=i<=j<=n-1) $ , that ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF466C/6d268bd0e5773093a8b59275245964aa2b1c55f9.png).

## 样例 #1

### 输入

```
5
1 2 3 0 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
0 1 -1 0
```

### 输出

```
1
```

## 样例 #3

### 输入

```
2
4 1
```

### 输出

```
0
```

# AI分析结果

### 题目中文重写
## 划分方式的数量

### 题目描述
你有一个数组 $ a[1],a[2],...,a[n] $，由 $ n $ 个整数组成。计算将数组的所有元素分成三个连续部分的方法数，使得每个部分的元素之和相同。

更正式地说，你需要找到这样的索引对 $ i,j $ （$2\leq i\leq j\leq n - 1$）的数量，满足：（此处原题目有图片但未给出具体公式，推测为三个部分和相等的条件）。

### 样例 #1
#### 输入
```
5
1 2 3 0 3
```
#### 输出
```
2
```

### 样例 #2
#### 输入
```
4
0 1 -1 0
```
#### 输出
```
1
```

### 样例 #3
#### 输入
```
2
4 1
```
#### 输出
```
0
```

### 综合分析与结论
这些题解的核心思路都是围绕前缀和展开，通过判断数组总和能否被 3 整除来确定是否有解，再利用不同方法找出满足条件的划分方案数。
- **思路对比**：
    - Mistybranch、wxzzzz 是从前向后遍历，根据前缀和与总和的 1/3、2/3 关系计数。
    - noble_ 同时使用前后缀和，用数组记录后缀和等于总和 1/3 的数量。
    - Kacho、AC_Automation、Light_Star_RPmax_AFO 用两个数组分别记录前缀和等于总和 1/3 与后缀和等于总和 1/3 的位置，再统计方案数。
    - Apro1066 使用树状数组记录总和 2/3 的区间。
    - 迟暮天复明 分别记录满足条件的左右端点，筛选出不交叉的区间。
- **算法要点**：
    - 前缀和计算：快速得到任意区间的和。
    - 条件判断：判断总和能否被 3 整除，以及前缀和是否等于总和的 1/3 或 2/3。
    - 方案计数：根据不同思路累加方案数。
- **解决难点**：
    - 避免重复计数：如 Kacho 等题解通过合理的下标处理避免重复。
    - 区间交叉问题：迟暮天复明 通过筛选不交叉的区间解决。

### 评分较高的题解
- **Mistybranch（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接利用前缀和与总和的关系，一次遍历完成计数。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (i > 1 && i < n && sum[i] == sum[n] * 2 / 3) {
        res += cc;
    }
    if (sum[i] == sum[n] / 3) {
        cc++;
    }
}
```
核心思想：遍历前缀和数组，当遇到前缀和为总和的 1/3 时，记录该位置可作为第一段的结束位置；当遇到前缀和为总和的 2/3 时，将答案加上之前可作为第一段结束位置的数量。

- **wxzzzz（4星）**
    - **关键亮点**：思路明确，对断点条件分析清晰，代码简洁易懂。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (1 < i && i < n && a[i] == a[n] / 3 * 2)
        ans += sum;
    if (i < n - 1 && a[i] == a[n] / 3)
        sum++;
}
```
核心思想：与 Mistybranch 类似，通过遍历前缀和数组，根据断点条件累加方案数。

### 最优关键思路或技巧
- **前缀和优化**：利用前缀和快速计算区间和，将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。
- **条件判断与计数**：通过判断前缀和与总和的关系，在一次遍历中完成方案数的统计。

### 拓展思路
同类型题或类似算法套路：
- 数组分割成多个和相等的连续子数组问题，可参考本题思路，先判断总和能否被分割份数整除，再利用前缀和寻找满足条件的分割点。
- 区间和问题，可使用前缀和快速计算任意区间的和。

### 推荐题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察前缀和与动态规划，求数组中连续子段的最大和。
- [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)：需要利用前缀和优化计算，统计满足特定条件的元素对的和。
- [P3131 [USACO16JAN]Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131)：利用前缀和与取模的性质，找出满足和能被 7 整除的最长连续子数组。

### 个人心得摘录与总结
- **Kacho**：一开始想用 $O(n^2)$ 的枚举方法，但因数据范围大而不可行，重新审视题意后采用前缀和方法。总结是做好判断和分点计数很重要。
总结：在面对算法题时，要根据数据范围选择合适的算法，不能盲目枚举，同时要仔细分析题意，找出关键条件进行优化。 

---
处理用时：29.50秒
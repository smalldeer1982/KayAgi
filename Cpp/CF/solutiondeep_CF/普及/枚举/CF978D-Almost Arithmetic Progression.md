# 题目信息

# Almost Arithmetic Progression

## 题目描述

Polycarp 喜欢等差数列，对于一个数列 $ [a_1,a_2,a_3,\dots,a_n] $，如果对于每个 $ i\,(1\le i < n) $，$ a_{i+1}-a_i $ 的值均相同，那么这个数列就是一个等差数列。例如，$ [42] $ ，$ [5,5,5] $ ，$ [2,11,20,29] $ 和 $ [3,2,1,0] $ 是等差数列，但是 $ [1,0,1] $，$ [1,3,9] $ 和 $ [2,3,1] $ 不是。

根据定义，任何长度为 $ 1 $ 或 $ 2 $ 的数列都是等差数列。

Polycarp 找到了一个只包含正整数的数列 $ [b_1,b_2,b_3,\dots,b_n] $ 。他只想最多将每个元素改变一次。换句话说，对于每个元素，有三种选项：自增 $ 1 $，自减 $ 1 $ 或者不变。

你需要找到对 $ b $ 中元素操作（每个只能操作一次）的最小次数，使 $ b $ 变成一个等差数列。

操作完成后的数列可以含有 $ 0 $ 。

## 说明/提示

在样例 $ 1 $ 中，Polycarp 应该将第 $ 1 $ 个元素加 $ 1 $ ，将第 $ 2 $ 个元素加 $ 1 $ ，将第 $ 3 $ 个元素加 $ 1 $ ，并且不改变第 $ 4 $ 个元素。所以，Polycarp 操作之后的数列为 $ [25,20,15,10] $ 。

在样例 $ 2 $ 中，Polycarp 不应进行操作，因为他的数列已经是等差数列了。

在样例 $ 3 $ 中，不可能通过上述的操作将数列变为等差数列。

在样例 $ 4 $ 中，Polycarp 应该只将第 $ 1 $ 个元素加 $ 1 $ 。操作之后的数列为 $ [0,3,6,9,12] $ 。

## 样例 #1

### 输入

```
4
24 21 14 10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2
500 500
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
14 5 1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
5
1 3 6 9 12
```

### 输出

```
1
```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕如何将给定数列通过最小操作次数转变为等差数列展开。整体思路都是利用等差数列由首项和公差确定这一特性，通过枚举前两项的可能变化来确定公差，进而检验整个数列能否成为等差数列并计算最小操作次数。

#### 思路对比
- **枚举前两项**：多数题解（如 feicheng、FanYongchen、Sophon 等）通过枚举前两项的 9 种可能变化（每个数有 +1、-1、不变三种情况）来确定公差，再检验后续数列。
- **搜索法**：nstk0513 和 liwenxi114514 使用深度优先搜索（DFS），枚举每个数的三种操作情况，同时加入最优性剪枝和可行性剪枝优化。
- **枚举首项和公差**：ny_Dacong 枚举首项的三种情况和公差的九种情况，生成等差数列并检查。

#### 算法要点
- **枚举法**：通过枚举前两项或首项和公差，确定可能的等差数列，再检查后续项与等差数列的差值是否在允许范围内。
- **剪枝优化**：在搜索过程中，使用最优性剪枝（当前操作次数超过最优答案则停止搜索）和可行性剪枝（当前操作无法构成等差数列则停止搜索）。

#### 解决难点
- **确定枚举范围**：通过分析等差数列的性质，确定前两项或首项和公差的枚举范围为 9 种情况，降低时间复杂度。
- **剪枝优化**：在搜索过程中加入剪枝策略，避免不必要的搜索，提高效率。

#### 题解评分
| 作者 | 评分 | 理由 |
| ---- | ---- | ---- |
| feicheng | 4 星 | 思路清晰，准确指出枚举前两项确定公差的方法，时间复杂度分析明确，核心代码简洁。 |
| FanYongchen | 4 星 | 思路易懂，代码注释详细，通过枚举前两项操作方法求解。 |
| Sophon | 4 星 | 思路明确，代码结构清晰，使用函数封装计算和检验过程。 |

#### 所选题解
- **feicheng（4 星）**
    - **关键亮点**：思路清晰，准确指出枚举前两项确定公差的方法，时间复杂度分析明确，核心代码简洁。
    - **核心代码**：
```cpp
inline int judge(int d) {//检验该公差是否可行
    int res = 0;
    for(ri i = 3;i <= n;++i){
        if(b[i]-b[i-1] > d + 1 || b[i]-b[i-1] < d - 1) return -1;
        else if(b[i]-b[i-1] == d + 1) ++res,b[i]--;
        else if(b[i] - b[i-1] == d - 1) ++res,++b[i];
    } 
    return res;
}
```
    - **核心实现思想**：通过传入公差 `d`，从第三项开始遍历数列，检查相邻两项的差值是否在 `d - 1` 到 `d + 1` 范围内，若超出则返回 -1，若需要调整则更新操作次数 `res`。
- **FanYongchen（4 星）**
    - **关键亮点**：思路易懂，代码注释详细，通过枚举前两项操作方法求解。
    - **核心代码**：
```cpp
for(int i=0;i<3;i++)
    for(int j=0;j<3;j++)//枚举第1、2项的操作方法 
    {
        memcpy(tmp,a,sizeof(tmp));//先复制数组 
        bool isCan=true;//这种枚举方法是否满足题目要求 
        int sub=tmp[0]+d[i]-(tmp[1]+d[j]);//求出公差 
        tmp[1]+=d[j];//更新第一个数(这里和下面更新数字时不能用原数组) 
        int c=cnt[i]+cnt[j];//共用的次数 
        for(int k=2;k<n;k++)//从第三项开始 
        {
            bool find=false;//对于这个数，判断它是否有一个操作方法，使得可以构成一个等差数列 
            for(int l=0;l<3;l++)//枚举 
                if(tmp[k-1]-(tmp[k]+d[l])==sub)//构成等差数列 
                    {tmp[k]+=d[l]/*更新数字*/;c+=cnt[l]/*累加次数*/;find=true/*记录已经找到*/;break;}
            if(!find) {isCan=false;break;}//若没找到，判定这个第1、2项的方法不能满足题意 
        }
        if(isCan) ans=min(ans,c);//若满足，更新答案 
    }
```
    - **核心实现思想**：通过两层循环枚举前两项的操作方法，复制数组避免修改原数组，计算公差，从第三项开始枚举每个数的操作方法，若能构成等差数列则更新操作次数，最后更新最小操作次数。
- **Sophon（4 星）**
    - **关键亮点**：思路明确，代码结构清晰，使用函数封装计算和检验过程。
    - **核心代码**：
```cpp
int calc(int a1, int a2, int n)//计算通项公式
{
    return a1 + (n - 1)*(a2 - a1);
}
void work(int a1, int a2, int change)//change 为a1和a2的调整值之和
{
    int temp = 0;
    for (int i = 3; i <= n; i++)//从第三项开始向后遍历原数列
    {
        int t = abs(calc(a1, a2, i) - a[i]);//计算该项需要调整的距离
        if (t > 1)//如果距离超过1，结束
        {
            return;
        }
        else//否则加上调整值
        {
            temp += t;
        }
    }
    temp += change;//加上第一项和第二项的调整值
    ans = min(ans, temp);//取较小值保存
}
```
    - **核心实现思想**：`calc` 函数用于计算等差数列的第 `n` 项，`work` 函数从第三项开始遍历原数列，计算每一项与等差数列对应项的差值，若差值超过 1 则返回，否则累加调整值，最后更新最小操作次数。

#### 最优关键思路或技巧
- **枚举前两项**：利用等差数列由首项和公差确定的特性，枚举前两项的 9 种可能变化，确定公差，进而检验整个数列，将时间复杂度控制在 $O(9n)$。
- **剪枝优化**：在搜索过程中使用最优性剪枝和可行性剪枝，避免不必要的搜索，提高效率。

#### 可拓展之处
- **同类型题**：可以拓展到其他数列变换问题，如将数列变为等比数列、斐波那契数列等，同样可以通过枚举关键项和公差（公比）来求解。
- **类似算法套路**：对于需要枚举多种情况并进行检验的问题，可以考虑使用剪枝优化来降低时间复杂度。

#### 推荐题目
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：通过枚举和等差数列求和公式求解连续自然数的和。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要枚举数字并进行质数和回文数的判断。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：使用深度优先搜索枚举组合情况并进行判断。

#### 个人心得摘录与总结
- **nstk0513**：使用暴搜时加入可行性剪枝、最优性剪枝，还处理初始序列最大最小差值，避免在大数据下超时，体现了剪枝优化在搜索算法中的重要性。
- **liwenxi114514**：提出搜索会超时，介绍最优性剪枝和可行性剪枝优化方法，强调剪枝在优化搜索算法中的作用。
- **WegestGao**：使用 DFS 时进行最优性剪枝和可行性剪枝优化，还提到可直接用三重循环解题，说明不同解题方法的灵活性和剪枝优化的通用性。 

---
处理用时：50.66秒
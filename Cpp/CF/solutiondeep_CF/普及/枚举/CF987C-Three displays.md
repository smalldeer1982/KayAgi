# 题目信息

# Three displays

## 题目描述

### 形式化题面

给定一个有两个性质 $s_i$ 和 $c_i$ 的数组，要求在其中选出三个数，满足：

 - $i<j<k$.
 - $s_i<s_j<s_k$.
 - $c_i+c_j+c_k$ 最小.

## 样例 #1

### 输入

```
5
2 4 5 4 10
40 30 20 10 40
```

### 输出

```
90
```

## 样例 #2

### 输入

```
3
100 101 100
2 4 5
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
10 13 11 14 15 12 13 13 18 13
```

### 输出

```
33
```

# AI分析结果

### 题目翻译
#### 三个展示

#### 题目描述
##### 形式化题面
给定一个具有两个属性 $s_i$ 和 $c_i$ 的数组，要求从中选出三个数，满足以下条件：
- $i < j < k$。
- $s_i < s_j < s_k$。
- $c_i + c_j + c_k$ 的值最小。

#### 样例 #1
##### 输入
```
5
2 4 5 4 10
40 30 20 10 40
```
##### 输出
```
90
```

#### 样例 #2
##### 输入
```
3
100 101 100
2 4 5
```
##### 输出
```
-1
```

#### 样例 #3
##### 输入
```
10
1 2 3 4 5 6 7 8 9 10
10 13 11 14 15 12 13 13 18 13
```
##### 输出
```
33
```

### 综合分析与结论
这些题解主要围绕寻找满足特定条件的三元组并使 $c$ 值之和最小的问题展开，思路可分为暴力枚举和动态规划两类。
- **暴力枚举**：以小菜鸟的题解为代表，通过枚举中间数，再分别在其左右寻找符合条件的数，将时间复杂度从 $O(n^3)$ 优化到 $O(n^2)$。此方法思路直观，但未利用动态规划的思想，对于更复杂的问题扩展性较差。
- **动态规划**：多数题解采用动态规划，定义状态 $f[i][k]$ 表示第 $i$ 个位置被选中作为选出的三个物品中的第 $k$ 个的 $c$ 之和。通过状态转移方程 $f[i][k] = \min(f[i][k], f[j][k - 1] + c[i])$（其中 $0 < j < i$ 且 $s[j] < s[i]$）进行求解。部分题解在此基础上，使用权值线段树或树状数组优化查找最小值的过程，将时间复杂度进一步优化到 $O(n \log n)$。

### 题解评分
| 作者 | 评分 | 理由 |
| ---- | ---- | ---- |
| 小菜鸟 | 3星 | 思路简单直接，代码有读入优化，但方法较为基础，未使用高级算法。 |
| love_luke | 4星 | 思路清晰，状态定义和转移方程明确，代码简洁易懂。 |
| Priori_Incantatem | 4星 | 思路与 love_luke 类似，代码规范，有详细的注释。 |
| Tweetuzki | 5星 | 不仅使用动态规划，还引入权值线段树优化，时间复杂度最优，代码结构清晰。 |
| Yizhixiaoyun | 4星 | 动态规划思路明确，代码实现简洁。 |
| MurataHimeko | 4星 | 思路清晰，有优化思路和具体实现，代码注释详细。 |
| 伟大的王夫子 | 3星 | 状态方程有误，将 $\min$ 写成 $\max$，影响正确性。 |
| 0xFF | 4星 | 思路清晰，代码规范，有输入优化。 |
| Suuon_Kanderu | 4星 | 思路独特，使用树状数组优化，代码有详细注释。 |
| Apro1066 | 3星 | 思路较难理解，代码可读性一般。 |

### 高评分题解
- **Tweetuzki（5星）**
    - **关键亮点**：使用动态规划结合权值线段树优化，时间复杂度为 $O(n \log n)$，优化程度高。
    - **核心代码**：
```cpp
// 状态转移
for (int i = 1; i <= N; ++i) dp[i][1] = c[i];
Build_Tree(1, N, 1);
for (int i = 1; i <= N; ++i)
{
    if (s[i]!= 1) dp[i][2] = min(dp[i][2], Query_Tree(1, s[i] - 1, 1) + c[i]);
    Update_Tree(s[i], dp[i][1], 1);
}
Build_Tree(1, N, 1);
for (int i = 1; i <= N; ++i)
{
    if (s[i]!= 1) dp[i][3] = min(dp[i][3], Query_Tree(1, s[i] - 1, 1) + c[i]);
    Update_Tree(s[i], dp[i][2], 1);
}
```
- **love_luke（4星）**
    - **关键亮点**：思路清晰，状态定义和转移方程明确，代码简洁易懂。
    - **核心代码**：
```cpp
// 状态转移
for (i = 1; i <= n; ++i)
{
    f[i][1]=c[i];
    for (k = 2; k <= 3; ++k)
        for (j = 1; j < i; ++j)
            if (s[j] < s[i])
                f[i][k] = min(f[i][k], f[j][k - 1] + c[i]);
}
```
- **Priori_Incantatem（4星）**
    - **关键亮点**：思路与 love_luke 类似，代码规范，有详细的注释。
    - **核心代码**：
```cpp
// 状态转移
for(int i = 1; i <= n; ++i)
{
    for(int j = 1; j < i; ++j)
    {
        if(a[j] >= a[i]) continue;
        f[i][2] = min(f[i][2], f[j][1] + c[i]);
        f[i][3] = min(f[i][3], f[j][2] + c[i]);
    }
    ans = min(ans, f[i][3]);
}
```

### 最优关键思路或技巧
- **动态规划**：通过定义合适的状态和状态转移方程，将问题分解为子问题进行求解。
- **数据结构优化**：使用权值线段树或树状数组优化查找最小值的过程，将时间复杂度从 $O(n^2)$ 降低到 $O(n \log n)$。
- **离散化**：当数据范围较大时，通过离散化将数据映射到较小的范围内，减少空间复杂度。

### 拓展思路
同类型题目通常涉及在满足一定条件下寻找最优子序列，如最长上升子序列（LIS）的变种问题。可以通过调整状态定义和转移方程来解决不同的约束条件。类似算法套路包括使用动态规划结合数据结构（如线段树、树状数组）优化查找和更新操作。

### 洛谷相似题目推荐
- [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：涉及最长上升子序列和最长不上升子序列的求解。
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：经典的动态规划问题，可通过优化算法降低时间复杂度。
- [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)：动态规划结合单调队列优化，与本题的动态规划思路和优化方法有相似之处。

### 个人心得摘录与总结
- **小菜鸟**：表示自己 DP 学得差，所以采用暴力枚举的方法解决问题，体现了在不熟悉某种算法时，可以先从简单直观的方法入手。
- **Suuon_Kanderu**：建议新手先自己思考，再看题解，否则容易成为“DP 低能儿”，强调了自主思考对于学习算法的重要性。同时提到使用树状数组优化取得了较好的效果，展示了数据结构优化在算法中的作用。

---
处理用时：40.37秒
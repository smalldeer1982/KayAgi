# 题目信息

# Nested Segments

## 题目描述

##### 【题目大意】：

你得到了一个序列$a_1,a_2,a_3...a_n$，表示$n$个区间。你的任务是求出一对$(i,j)$，表示区间$j$包含区间$i$（注意是区间$j$包含$i$）。

我们定义区间$[l_2,r_2]$包含区间$[l_1,r_1]$当且仅当$l_1 \geq l_2$且$r_1 \leq r_2$。比如区间$[2,5]$包含区间$[3,5]$，因为$3 \geq 2,5 \leq 5$。再比如区间$[2,5]$不包含区间$[1,4]$，因为$1<2$。

输出一对$(i,j)$表示答案。如果答案不唯一，则输出任意一组解即可（所以本题有`SPJ`）。如果无解，则输出`-1 -1`。

--------------------------------------

## 样例 #1

### 输入

```
5
1 10
2 9
3 9
2 3
2 9
```

### 输出

```
2 1
```

## 样例 #2

### 输入

```
3
1 5
2 6
6 20
```

### 输出

```
-1 -1
```

# AI分析结果

### 题目翻译
#### 嵌套区间

##### 题目描述
你得到了一个序列 $a_1,a_2,a_3...a_n$，表示 $n$ 个区间。你的任务是求出一对 $(i,j)$，表示区间 $j$ 包含区间 $i$（注意是区间 $j$ 包含 $i$）。

我们定义区间 $[l_2,r_2]$ 包含区间 $[l_1,r_1]$ 当且仅当 $l_1 \geq l_2$ 且 $r_1 \leq r_2$。比如区间 $[2,5]$ 包含区间 $[3,5]$，因为 $3 \geq 2,5 \leq 5$。再比如区间 $[2,5]$ 不包含区间 $[1,4]$，因为 $1<2$。

输出一对 $(i,j)$ 表示答案。如果答案不唯一，则输出任意一组解即可（所以本题有 `SPJ`）。如果无解，则输出 `-1 -1`。

#### 样例 #1
##### 输入
```
5
1 10
2 9
3 9
2 3
2 9
```
##### 输出
```
2 1
```

#### 样例 #2
##### 输入
```
3
1 5
2 6
6 20
```
##### 输出
```
-1 -1
```

### 综合分析与结论
本题的核心在于从 $n$ 个区间中找出存在包含关系的两个区间，直接暴力枚举的时间复杂度为 $O(n^2)$，对于 $n$ 最大为 $3\times10^5$ 的数据规模会超时。各题解主要通过排序优化查找过程，使时间复杂度降低到 $O(n \log n)$ 或 $O(n)$。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|caibet|将区间按左端点从小到大排序，左端点相同时按右端点从大到小排序，遍历排序后的区间，判断相邻区间是否存在包含关系|自定义比较函数 `cmp` 进行排序，遍历判断相邻区间|避免 $O(n^2)$ 复杂度的暴力枚举|4星|
|__AFO__|按左端点从小到大排序，左端点相同时右节点更大的在前，依次寻找是否存在覆盖关系|自定义比较函数 `cmp` 排序，遍历判断|优化查找包含关系的过程|3星|
|龙之吻—水货|按左端点从小到大排序，左端点相同时按右端点从大到小排序，将问题转化为找逆序对，在快排中魔改寻找逆序对|自定义比较函数 `cmp` 排序，快排中找逆序对|将区间包含问题转化为逆序对问题|3星|
|Fido_Puppy|按左端点从小到大排序，左端点相同时按右端点从大到小排序，用树状数组判断是否存在满足条件的区间|自定义比较函数 `cmp` 排序，树状数组判断|处理大规模数据时的查找问题|3星|
|EternalAlexander|按左端点排序，用堆维护左端点小于等于当前区间左端点的区间，判断是否存在包含关系|自定义比较函数 `cmp` 排序，堆维护区间|处理区间包含关系的查找|3星|
|Addicted_Game|按左端点从小到大排序，左端点相同时按右端点从大到小排序，找一个大区间，无法包含时更新|自定义比较函数 `cmp` 排序，更新大区间|优化查找包含关系的过程|3星|
|DHT666|按左端点从大到小、右端点从小到大排序，遍历判断相邻区间是否存在包含关系|自定义比较函数 `cmp` 排序，遍历判断|优化查找包含关系的过程|3星|
|nyC20|按左端点从小到大排序，左端点相同时按右端点从大到小排序，判断线段 $a_i$ 能否被 $a_{i - 1}$ 包含|自定义比较函数 `cmp` 排序，遍历判断|避免 $O(n^2)$ 复杂度的暴力枚举|3星|
|louliu|先尝试暴力解法，超时后改为排序后遍历相邻区间判断|自定义比较函数 `cmp` 排序，遍历判断|解决暴力解法超时问题|2星|
|ZHANGyutao123|使用两层循环遍历所有可能的组合，判断是否存在包含关系|暴力枚举|未解决超时问题|1星|
|cppcppcpp3|按 $r$ 从小到大、$l$ 从大到小排序，枚举区间，用变量维护 $\max\limits_{j = 1}^{i - 1}l_j$|自定义比较函数 `operator <` 排序，变量维护|优化查找包含关系的过程|3星|
|一只大龙猫|按左端点从小到大排序，左端点相同时按右端点从大到小排序，用树状数组统计逆序对，出现逆序对时查找具体区间|自定义比较函数 `operator <` 排序，树状数组统计逆序对|处理区间包含关系的查找|3星|
|linwenchen|按左端点从大到小排序，左端点相同时按右端点从小到大排序，遍历区间，判断是否存在包含关系|自定义比较函数 `cmp` 排序，遍历判断|优化查找包含关系的过程|3星|
|___nyLittleT___|按左端点从大到小、右端点从小到大排序，遍历判断相邻区间是否存在包含关系|自定义比较函数 `cmp` 排序，遍历判断|优化查找包含关系的过程|3星|

### 所选题解
- caibet（4星）
    - 关键亮点：思路清晰，代码简洁，通过合理排序将问题简化为判断相邻区间的包含关系，避免了暴力枚举的高复杂度。
    - 核心代码：
```cpp
struct node{
    int l,r,id;
} a[314514];
bool cmp(node x,node y){
    if(x.l!=y.l) return x.l<y.l;
    return x.r>y.r;
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].l>>a[i].r;
        a[i].id=i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++){
        if(a[i-1].r>=a[i].r&&a[i-1].l<=a[i].l){
            cout<<a[i].id<<' '<<a[i-1].id<<endl;
            return 0;
        }
    }
    cout<<"-1 -1";
    return 0;
}
```

### 最优关键思路或技巧
- **排序优化**：通过合理的排序规则（如左端点从小到大，左端点相同时右端点从大到小），可以将原本需要 $O(n^2)$ 复杂度的暴力枚举转化为 $O(n)$ 或 $O(n \log n)$ 的复杂度。
- **数据结构辅助**：部分题解使用树状数组、堆等数据结构来辅助查找，提高查找效率。

### 可拓展之处
同类型题可能会改变区间的定义或包含关系的规则，例如二维区间的包含问题，或者区间重叠问题等。类似算法套路可以应用于其他需要优化查找过程的问题，如逆序对问题、区间合并问题等。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
- [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)
- [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得摘录与总结
- **louliu**：一开始使用暴力解法超时，后尝试一重循环但因边界问题出错，最终修改循环条件解决问题。总结为在优化算法时要注意边界条件，避免遗漏情况。
- **一只大龙猫**：在输出时要注意输出原来的编号，而不是排序后的下标，在此处卡了将近一小时。提醒在处理需要记录原始信息的问题时，要注意信息的正确使用。 

---
处理用时：42.62秒
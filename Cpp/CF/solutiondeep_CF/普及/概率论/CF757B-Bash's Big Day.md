# 题目信息

# Bash's Big Day

## 题目描述

Bash 已经踏上了成为最伟大的口袋妖怪大师的旅程。为了得到他的第一个口袋妖怪，他去了 Zulu 教授的实验室。由于 Bash 是 Zulu 教授最喜欢的学生，Zulu 允许他从实验室里取出任意数量的口袋妖怪。

但是 Zulu 警告他，每个小精灵都有一个力量值，例如 $k(k>1)$ 个小精灵在一起，它们的力量值为 $s_1,s_2,\dots,s_k$，如果 $\gcd(s_1,s_2,\dots s_k)=1$（见 $\gcd$ 的定义注释），它们之间就会互相打架。

Bash 作为一个聪明的人，不希望他的口袋妖怪互相斗争。然而，他也想最大化他从实验室里带走的神奇宝贝的数量。你能帮 Bash 找出他能带走的最大数量的口袋妖怪吗？

**注意：口袋妖怪不能与自己战斗。**

## 样例 #1

### 输入

```
3
2 3 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
2 3 4 6 7
```

### 输出

```
3
```

# AI分析结果

### 题目内容（已为中文，无需翻译）
Bash 已经踏上了成为最伟大的口袋妖怪大师的旅程。为了得到他的第一个口袋妖怪，他去了 Zulu 教授的实验室。由于 Bash 是 Zulu 教授最喜欢的学生，Zulu 允许他从实验室里取出任意数量的口袋妖怪。

但是 Zulu 警告他，每个小精灵都有一个力量值，例如 $k(k>1)$ 个小精灵在一起，它们的力量值为 $s_1,s_2,\dots,s_k$，如果 $\gcd(s_1,s_2,\dots s_k)=1$（见 $\gcd$ 的定义注释），它们之间就会互相打架。

Bash 作为一个聪明的人，不希望他的口袋妖怪互相斗争。然而，他也想最大化他从实验室里带走的神奇宝贝的数量。你能帮 Bash 找出他能带走的最大数量的口袋妖怪吗？

**注意：口袋妖怪不能与自己战斗。**

### 综合分析与结论
这些题解的核心思路都是通过枚举因数或质数，统计能被其整除的数的个数，从而找出满足条件的最大集合大小。不同题解在具体实现和优化上有所差异。
- **思路对比**：部分题解枚举所有因数，部分只枚举质数，认为质数中必有最优解，合数不比质数优。
- **算法要点**：多数题解使用桶计数，记录能被某个数整除的元素个数；部分题解通过线性筛或埃氏筛预处理质数。
- **解决难点**：解决了如何高效找出满足 $\gcd>1$ 的最大子集大小的问题，避免了直接枚举子集的高复杂度。

### 所选题解
- **作者：Cutest_Junior（5星）**
    - **关键亮点**：思路清晰，详细阐述了算法的优化过程，从枚举因数的朴素算法到使用桶优化，代码简洁易懂。
    - **核心代码**：
```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 1e5 + 5;
int cou[N];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        int x;
        scanf("%d", &x);
        for (int j = 1; j * j<= x; ++j) {
            if (x % j == 0) {
                ++cou[j];
                if (j * j!= x) {
                    ++cou[x / j];
                }
            }
        }
    }
    int ans = 1;
    for (int i = 2; i < N; ++i) {
        ans = max(ans, cou[i]);
    }
    printf("%d", ans);
}
```
核心实现思想：用桶 `cou` 记录每个因数出现的次数，遍历每个输入的数，分解其因数并更新桶中的计数，最后遍历桶找出最大值。

- **作者：RemiliaScar1et（4星）**
    - **关键亮点**：给出了质数中必有最优解的不严谨证明，通过预处理质数减少枚举量，代码结构清晰。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+10;

int pr[N],tot=0;
bool mp[N];

void init(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!mp[i]) pr[++tot]=i;
        for(int j=1;i*pr[j]<=n;j++)
        {
            mp[pr[j]*i]=1;
            if(i%pr[j]==0) break;
        }
    }
}
int n;
int arr[N],vis[N];

int main()
{
    scanf("%d",&n);
    int maxn=0;
    for(int i=1;i<=n;i++)
        scanf("%d",&arr[i]),maxn=max(maxn,arr[i]),vis[arr[i]]++;
    init((int)maxn+1);
    int ans=1;
    for(int i=1;i<=tot;i++)
    {
        int res=0;
        for(int j=1;pr[i]*j<=maxn;j++)
            res+=vis[pr[i]*j];
        ans=max(ans,res);
    }
    printf("%d",ans);
    return 0;
}
```
核心实现思想：先预处理出所有质数，再遍历每个质数，统计其倍数在输入数组中出现的次数，更新最大集合大小。

- **作者：李尧（4星）**
    - **关键亮点**：思路简洁，通过逆向思维枚举质数，考虑了重复值和单个元素的情况，避免了常见的错误。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,ans,mx=1,n,vis[100007];
bool v[100007];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a);
        vis[a]++;
    }
    for(int i=2;i<=100000;i++){
        if(v[i]) continue;
        ans=vis[i];
        for(int j=2;j<=100000/i;j++){
            v[i*j]=true;
            ans+=vis[i*j];
        }
        mx=max(mx,ans);
    }
    printf("%d",mx);
    return 0;
}
```
核心实现思想：用 `vis` 数组记录每个数出现的次数，枚举质数，统计其倍数的出现次数，更新最大集合大小。

### 最优关键思路或技巧
- **桶计数**：使用桶来记录能被某个数整除的元素个数，避免了重复计算，提高了效率。
- **枚举质数**：通过证明质数中必有最优解，减少了枚举量，优化了时间复杂度。
- **预处理因数**：对每个数预处理其因数，可在 $O(\sqrt{n})$ 时间内完成，降低了整体复杂度。

### 可拓展之处
同类型题如求最大公约数大于某个值的最大子集大小，或在二维数组中找出满足某种最大公约数条件的最大子矩阵等。类似算法套路可用于处理其他与因数、倍数相关的计数问题。

### 推荐洛谷题目
- P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题
- P1372 又是毕业季I
- P2152 [SDOI2009]SuperGCD

### 个人心得摘录与总结
- **李尧**：注意可能有重复战斗值，不能用 `bool` 型；至少有一个数，`mx` 初始值应为 $1$ 而非 $0$，否则会卡在特定测试点。
- **0x3F**：枚举 $\gcd$ 的朴素算法会超时，选合数不如选其质因子划算，求每个数的素因子时最坏复杂度为 $O(\sqrt{n})$，要注意特判所有数均为 $1$ 的情况。
- **lxzy_**：暴力枚举复杂度高会超时，可通过求出约数直接统计，注意特判序列中所有数都为 $1$ 的情况。 

---
处理用时：41.52秒
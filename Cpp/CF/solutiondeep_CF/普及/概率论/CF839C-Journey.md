# 题目信息

# Journey

## 题目描述

## 问题描述

在七大王国里有 $n$ 个城市和 $n-1$ 条道路，每条道路连接两个城市，并且通过这些道路我们可以从任何一个城市到达任何一个城市。

席恩和阿莎在第一个城市骑上马，他们要通过这些路开始一次旅行。但是有雾，所以他们看不见他们的马带他们去了哪里。当马抵达一个城市的时候（包括第一个城市），它会去跟当前这个城市相连的城市。但是这是一匹奇怪的马，它只去他们以前没有去过的城市。在每个城市，马以相同的概率移动去上述符合要求的城市，并且当没有这样的城市（可走）时，马就停下了。

每条路的长度都是 $1$，旅行从城市 $1$ 开始，问这次旅行的期望长度（旅行长度的期望值）是多少？你可以通过[这个链接](https://en.wikipedia.org/wiki/Expected\_value)来阅读一些关于期望（平均）值的文字。

## 说明/提示

在第一个例子中，他们的旅行可能以同等的概率停止于城市 $3$ 或城市 $4$。去城市 $3$ 的距离是 $1$，去城市 $4$ 的距离是 $2$，所以期望是 $1.5$。

在第二个例子中，他们的旅行可能停止于城市 $4$ 或城市 $5$。去这些城市的距离都是 $2$，所以期望是 $2$。

## 样例 #1

### 输入

```
4
1 2
1 3
2 4
```

### 输出

```
1.500000000000000
```

## 样例 #2

### 输入

```
5
1 2
1 3
3 4
2 5
```

### 输出

```
2.000000000000000
```

# AI分析结果

### 题目内容
#### 问题描述
在七大王国里有 $n$ 个城市和 $n - 1$ 条道路，每条道路连接两个城市，并且通过这些道路我们可以从任何一个城市到达任何一个城市。

席恩和阿莎在第一个城市骑上马，他们要通过这些路开始一次旅行。但是有雾，所以他们看不见他们的马带他们去了哪里。当马抵达一个城市的时候（包括第一个城市），它会去跟当前这个城市相连的城市。但是这是一匹奇怪的马，它只去他们以前没有去过的城市。在每个城市，马以相同的概率移动去上述符合要求的城市，并且当没有这样的城市（可走）时，马就停下了。

每条路的长度都是 $1$，旅行从城市 $1$ 开始，问这次旅行的期望长度（旅行长度的期望值）是多少？你可以通过[这个链接](https://en.wikipedia.org/wiki/Expected_value)来阅读一些关于期望（平均）值的文字。

#### 说明/提示
在第一个例子中，他们的旅行可能以同等的概率停止于城市 $3$ 或城市 $4$。去城市 $3$ 的距离是 $1$，去城市 $4$ 的距离是 $2$，所以期望是 $1.5$。

在第二个例子中，他们的旅行可能停止于城市 $4$ 或城市 $5$。去这些城市的距离都是 $2$，所以期望是 $2$。

#### 样例 #1
##### 输入
```
4
1 2
1 3
2 4
```
##### 输出
```
1.500000000000000
```

#### 样例 #2
##### 输入
```
5
1 2
1 3
3 4
2 5
```
##### 输出
```
2.000000000000000
```

### 综合分析与结论
这些题解主要围绕树形结构下的期望计算问题展开，核心在于利用树的特性和期望的定义来求解旅行的期望长度。整体思路可分为两类：
- **树形 DP 思路**：定义状态 $dp_i$ 表示从 $i$ 向其子树走的步数期望值，通过递归计算子节点的期望来更新父节点的期望。
- **概率累加思路**：计算到达每个叶子节点的概率和距离，将两者相乘并累加得到最终期望。

各题解在实现细节上有所不同，如存图方式（邻接表、vector）、搜索方式（DFS、BFS）等，但本质都是基于上述两种思路。

### 高评分题解
1. **作者：E1_de5truct0r（5星）**
    - **关键亮点**：思路清晰，直接点明树的性质并利用树形 DP 解决问题，代码简洁易懂。
    - **核心代码**：
```cpp
void dfs(int u,int fa)
{
    int cnt=0;
    for(int i=0;i<E[u].size();i++)
    {
        int v=E[u][i];
        if(v==fa) continue;
        dfs(v,u);
        dp[u]+=(dp[v]+1.0);
        cnt++;
    }
    if(cnt) dp[u]/=(double)cnt;
}
```
    - **核心思想**：通过深度优先搜索遍历树，对于每个节点，累加其子节点的期望并加 1，最后除以子节点个数得到该节点的期望。

2. **作者：caidzh（4星）**
    - **关键亮点**：从叶子节点期望累加的角度思考，结合 DFS 计算距离和概率，思路独特。
    - **核心代码**：
```cpp
void dfs(int x,int fa,double exp){
    int flag=0;dep[x]=dep[fa]+1;
    for(int i=head[x];i;i=edge[i].nxt){
        int v=edge[i].to;if(v==fa)continue;flag=1;
        if(fa==0)dfs(v,x,exp*(1.0/out[x]));else dfs(v,x,exp*(1.0/(out[x]-1)));
    }if(!flag)ans+=(double)(dep[x]-1)*exp;
}
```
    - **核心思想**：在 DFS 过程中，记录节点深度，根据父节点概率和当前节点出度计算子节点概率，到达叶子节点时累加期望。

3. **作者：Overstars（4星）**
    - **关键亮点**：详细解释了期望公式和计算过程，代码实现规范。
    - **核心代码**：
```cpp
void dfs(int x,int fa)
{
    for(int i=head[x];~i;i=e[i].nex)
    {
        int v=e[i].v;
        if(v==fa)
            continue;
        deg[x]++;//统计出度
        dfs(v,x);
    }
    for(int i=head[x];~i;i=e[i].nex)
    {
        int v=e[i].v;
        if(v==fa)
            continue;//回溯,计算期望
        dp[x]+=(double)(1.0/deg[x])*(dp[v]+1);
    }
}
```
    - **核心思想**：先统计每个节点的出度，再通过回溯计算节点的期望，将子节点的期望加权累加并加 1 得到父节点的期望。

### 最优关键思路与技巧
- **树形 DP**：利用树的递归结构，定义状态并通过子节点的状态更新父节点的状态，避免重复计算。
- **概率分流**：在计算到达叶子节点的概率时，根据节点的出度将父节点的概率平均分配给子节点。

### 拓展思路
同类型题可拓展到有向无环图（DAG）上的期望计算，类似算法套路是利用拓扑排序结合 DP 求解。

### 推荐题目
1. [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)：与本题类似，将树换成了 DAG。
2. [P1365 WJMZBMR打osu! / Easy](https://www.luogu.com.cn/problem/P1365)：涉及期望的线性性和状态转移。
3. [P2059 [JLOI2013]卡牌游戏](https://www.luogu.com.cn/problem/P2059)：需要通过状态压缩和期望 DP 解决。

### 个人心得摘录与总结
- **E1_de5truct0r**：一开始没看到是树的条件，导致想了 3 分钟没思路，强调了审题的重要性。
- **caidzh**：自己想出期望题感到有成就感，但又觉得题目简单，反映出对自身能力的反思。
- **Overstars**：认为这道题很妙，特意开通博客写题解，体现了对题目的欣赏和学习热情。

---
处理用时：38.87秒
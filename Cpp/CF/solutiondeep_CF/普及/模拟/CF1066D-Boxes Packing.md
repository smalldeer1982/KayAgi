# 题目信息

# Boxes Packing

## 题目描述

有 $n$ 个物品，$m$ 个盒子。其中第 $i$ 个物品的大小为 $a_i$，所有盒子的大小均为 $k$。Makmis 先生想要将这些物品放入盒子中。对于每个物品，如果可以放入当前盒子中则放入当前盒子，否则换一个新的盒子放入。如果物品数量太多使得盒子装不下，可以**将先放入的物品丢弃**。求出最多能够放入多少物品。

## 说明/提示

#### 样例解释
- 在第一组样例中，可以将后 $4$ 个放入盒子。
- 在第二组样例中仅有一个盒子，故只能放入最后一个。
- 在第三组样例中有 $3$ 个大小为 $3$ 的盒子，每个盒子正好装满。
#### 数据规模与约定
保证 $1\le n,m\le2\times 10^5$，$1\le k\le10^9$，$1\le a_i\le k$。

## 样例 #1

### 输入

```
5 2 6
5 2 1 4 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 1 4
4 2 3 4 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5 3 3
1 2 3 1 1
```

### 输出

```
5
```

# AI分析结果

### 题目翻译
题目已为中文，无需翻译。

### 综合分析与结论
这些题解主要围绕如何解决将物品放入盒子以获得最多放入物品数量的问题，提出了多种思路和算法。
- **暴力枚举思路**：枚举不选的物品数量，然后检查剩余物品能否按规则放入盒子，时间复杂度为$O(N^2)$，数据规模大时会超时。
- **线性倒推思路**：从右向左倒推，模拟放物品过程，当子序列数量达到上限或物品选完时停止，时间复杂度为$O(N)$。
- **二分答案思路**：利用答案的单调性，二分枚举放入物品的数量，通过$O(n)$的检查函数判断可行性，总时间复杂度为$O(n\log(n))$。
- **贪心思路**：从右向左贪心放物品，优先装满当前盒子，装不下则换盒子，若盒子用完则停止。
- **树结构思路**：预处理每个物品开始放一个盒子能到的最后位置，构建树结构，通过深度优先搜索找到能访问的最小点来计算答案。

### 所选题解
- **Plozia（5星）**
    - **关键亮点**：思路清晰，先给出暴力解法并分析其复杂度，再引出线性倒推的优化解法，代码注释详细，易于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[200000+10],sum,t;
int box[200000+10];
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) sum+=a[i];
    t=n;
    while(m!=0&&t!=0)
    {
        box[m]+=a[t];
        if(box[m]>k)
        {
            m--;
            box[m]=a[t];
        }
        t--;
    }
    if(m==0) t++;
    printf("%d\n",n-t);
    return 0;
}
```
    - **核心思想**：从右向左倒推，将物品放入当前子序列，若子序列和超过容量则换一个子序列，直到子序列用尽或物品选完，最后计算放入物品的数量。

- **StudyingFather（5星）**
    - **关键亮点**：直接从右向左模拟放物品过程，思路简洁，代码精炼，时间复杂度为$O(n)$。
    - **核心代码**：
```cpp
#include <stdio.h>
int a[200005];
int main()
{
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=n;i>=1;i--)
        scanf("%d",&a[i]);
    int rem=m,used=0;
    for(int i=1;i<=n;i++)
    {
        if(used+a[i]>k)
        {
            rem--,used=a[i];
            if(rem==0)
            {
                printf("%d\n",i-1);
                return 0;
            }
        }
        else used+=a[i];
    }
    printf("%d\n",n);
    return 0;
}
```
    - **核心思想**：逆序读入物品，从右向左模拟放物品，若当前盒子装不下则换一个盒子，若盒子用完则输出已放入物品的数量。

- **fls233666（4星）**
    - **关键亮点**：准确分析出答案的单调性，采用二分答案的方法解决问题，代码结构清晰。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define rgt register int
using namespace std;

const int mxn = 2e5+5;
int g[mxn],nk,m,n,l,r,md;

inline bool ck(int st){
    int cnt=1,v=0;
    for(rgt i=st;i<=n;i++){
        if(v+g[i]>nk){
            cnt++;
            v=g[i];
        }
        else
            v+=g[i];
    }
    return cnt>m;
}

int main(){
    scanf("%d%d%d",&n,&m,&nk);
    for(rgt i=1;i<=n;i++)
        scanf("%d",&g[i]);
    l=0;
    r=n;
    while(l<r){
        md=(l+r+1)>>1;
        if(ck(md))
            l=md;
        else
            r=md-1;
    }
    
    printf("%d",n-l);
    return 0;
}
```
    - **核心思想**：二分枚举不选的物品数量，通过检查函数判断剩余物品所需盒子数是否超过限制，不断缩小二分区间，最终得到最多放入物品的数量。

### 最优关键思路或技巧
- **逆向思维**：正序处理可能复杂时，考虑从右向左倒推，简化问题。
- **二分答案**：当答案具有单调性时，二分答案可将时间复杂度从$O(n^2)$优化到$O(n\log(n))$。

### 可拓展之处
同类型题如货物装箱问题、资源分配问题等，可采用类似的贪心、二分等算法思路。例如在一些分配任务、安排活动的问题中，若满足一定的单调性和规则，也可使用二分答案来求解最优解。

### 推荐洛谷题目
- P1873 [COCI 2011/2012 #5] EKO / 砍树：二分答案求解满足条件的最大值。
- P2678 [NOIP2015 提高组] 跳石头：二分答案结合贪心判断可行性。
- P3853 [TJOI2007] 路标设置：二分答案解决区间划分问题。

### 个人心得摘录与总结
- **miserExist**：最初想从前向后贪心并二分答案，但发现从前向后选择物品不能贪心，转换为从后向前贪心可满足条件，说明在解题时要考虑不同方向的贪心策略。
- **phmaprostrate**：通过举例说明倒着分割子段能得到更优解，强调了在处理区间问题时要注意分割顺序对结果的影响。 

---
处理用时：38.67秒
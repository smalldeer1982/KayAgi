# 题目信息

# Playing Quidditch (Easy)

## 题目描述

今天下午，你打算出去散步，享受春天的第一缕阳光。在靠近魁地奇球场时，你听到了争吵声。原来是比赛比分又引起了争议，两队都坚信自己赢得了比赛！为了避免这种事情再次发生，你决定参与到比赛的裁判工作中。

现在，你将在体育场内观看比赛并计算得分。比赛结束后，你将宣布胜者。

今天参赛的有两支队伍：红色的格兰芬多队（R）和蓝色的拉文克劳队（B）。每支队伍由 $P$ 名球员组成（$1 \leq P \leq 10$）。

比赛的场地是一个由 $N$ 行 $M$ 列组成的矩形（$3 \leq N, M \leq 99$，且 $N$ 和 $M$ 是奇数）。场上所有位置均为整数，多名球员或多个物体可以占据同一个位置。比赛开始时，场地上有双方队伍的目标（每队可拥有1至5个目标），球员，以及一个鬼飞球。其他种类的球将在更复杂的问题中涉及。

比赛分为 $T$ 步（$0 \leq T \leq 10000$）。每一步中，场上的一个实体（球员或球）将执行一个动作。所有的实体都能移动。球员还可以接球或投掷他们携带的鬼飞球。要接球，球员需要和球在同一个位置。当球员携带鬼飞球时，球只会跟随他的移动，而不会执行其他动作。如果球员决定投掷鬼飞球，它就留在当前的位置。

得分的条件是，球员必须将鬼飞球放入对方队伍的目标中。成功时，该球员所在的队伍就会得一分，而鬼飞球会立刻返回到场地的正中央（即第 $(M+1)/2$ 列和第 $(N+1)/2$ 行的位置，从 1 开始计数）。场中心没有目标。如果球员不小心将球放进了自己的目标中，那么对方队伍会得一分。

## 说明/提示

在第一个示例中，一名蓝队球员走到网格中心收球，然后带球前往红色队的目标并成功得分！鬼飞球回到场地中心，随后一个红队球员也拿球成功得分。

在第二个示例中，红队球员拿到鬼飞球，移动并投掷，随后由蓝队球员接过，带球前往红队目标并得分。

在第三个例子中，红队球员将球投入自己的目标，因此蓝队得分。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 5
.. R1 .. B1 ..
RG .. .. .. BG
RG R0 .Q B0 BG
RG .. .. .. BG
.. R2 .. B2 ..
13
B2 U
B2 U
B2 L
B2 C .Q
B2 L
B2 L
B2 T
R0 R
R0 C .Q
R0 D
R0 R
R0 R
R0 T```

### 输出

```
6 BLUE GOAL
12 RED GOAL
FINAL SCORE: 1 1```

## 样例 #2

### 输入

```
3 5
.. .. R0 .. ..
RG .. .Q .. BG
.. .. B0 .. ..
12
R0 D
R0 C .Q
R0 R
R0 T
R0 D
B0 R
B0 U
B0 C .Q
B0 L
B0 L
B0 L
B0 T```

### 输出

```
11 BLUE GOAL
FINAL SCORE: 0 1```

## 样例 #3

### 输入

```
3 5
.. .. R0 .. ..
RG .. .Q .. BG
.. .. B0 .. ..
5
R0 D
R0 C .Q
R0 L
R0 L
R0 T```

### 输出

```
4 BLUE GOAL
FINAL SCORE: 0 1```

# AI分析结果

### 题目内容（已为中文，无需翻译）
今天下午，你打算出去散步，享受春天的第一缕阳光。在靠近魁地奇球场时，你听到了争吵声。原来是比赛比分又引起了争议，两队都坚信自己赢得了比赛！为了避免这种事情再次发生，你决定参与到比赛的裁判工作中。

现在，你将在体育场内观看比赛并计算得分。比赛结束后，你将宣布胜者。

今天参赛的有两支队伍：红色的格兰芬多队（R）和蓝色的拉文克劳队（B）。每支队伍由 $P$ 名球员组成（$1 \leq P \leq 10$）。

比赛的场地是一个由 $N$ 行 $M$ 列组成的矩形（$3 \leq N, M \leq 99$，且 $N$ 和 $M$ 是奇数）。场上所有位置均为整数，多名球员或多个物体可以占据同一个位置。比赛开始时，场地上有双方队伍的目标（每队可拥有1至5个目标），球员，以及一个鬼飞球。其他种类的球将在更复杂的问题中涉及。

比赛分为 $T$ 步（$0 \leq T \leq 10000$）。每一步中，场上的一个实体（球员或球）将执行一个动作。所有的实体都能移动。球员还可以接球或投掷他们携带的鬼飞球。要接球，球员需要和球在同一个位置。当球员携带鬼飞球时，球只会跟随他的移动，而不会执行其他动作。如果球员决定投掷鬼飞球，它就留在当前的位置。

得分的条件是，球员必须将鬼飞球放入对方队伍的目标中。成功时，该球员所在的队伍就会得一分，而鬼飞球会立刻返回到场地的正中央（即第 $(M+1)/2$ 列和第 $(N+1)/2$ 行的位置，从 1 开始计数）。场中心没有目标。如果球员不小心将球放进了自己的目标中，那么对方队伍会得一分。

### 说明/提示
在第一个示例中，一名蓝队球员走到网格中心收球，然后带球前往红色队的目标并成功得分！鬼飞球回到场地中心，随后一个红队球员也拿球成功得分。

在第二个示例中，红队球员拿到鬼飞球，移动并投掷，随后由蓝队球员接过，带球前往红队目标并得分。

在第三个例子中，红队球员将球投入自己的目标，因此蓝队得分。

### 综合分析与结论
这些题解整体思路都是模拟魁地奇比赛过程，核心在于记录球员和球的位置，根据每一步的操作更新位置，并判断是否进球。
- **思路对比**：多数题解使用 `map` 记录球员和球的位置，方便根据名称查找位置；部分题解使用结构体数组分别记录红队、蓝队球员和球的位置。
- **算法要点**：
    - 输入场地信息时，记录球员、球和球门的初始位置。
    - 按步骤模拟操作，根据操作更新位置。
    - 投球时判断是否进球，更新分数并将球放回场地中央。
- **解决难点**：
    - 球员带球时，球的位置要跟随球员移动。
    - 判断进球时，注意区分是红队还是蓝队进球。

### 题解评分与选择
|作者|评分|理由|
| ---- | ---- | ---- |
|Solune|4星|思路清晰，代码简洁，有注释说明关键部分，对进球判断的注意点有提示。|
|JOE_ZengYuQiao_0928|4星|思路明确，详细说明了操作步骤，代码逻辑清晰，考虑了球跟随球员移动的情况。|
|fmdd_szx|4星|思路简洁明了，代码实现直接，使用 `map` 记录位置，易于理解。|

### 所选题解
- **Solune（4星）**
    - **关键亮点**：思路清晰，代码简洁，对进球判断的注意点有提示。
    - **个人心得**：提到在判断进球时，“在蓝队球门投球红队加分，在红队球门投球蓝队加分”这个地方卡了半天，提醒注意此细节。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define pair pair<int, int>
#define x first
#define y second
const int MAX = 1e2 + 10;
map<string, pair> p;  //记录球员位置
string a[MAX][MAX];
int rs = 0, bs = 0;  //记录两队分数

int main() {
  int n, m, t;
  cin >> n >> m;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      cin >> a[i][j];
      if (a[i][j]!= "..") p[a[i][j]] = {i, j};
    }
  }
  cin >> t;
  for (int i = 0; i < t; ++i) {
    string id, s;
    char op;
    cin >> id >> op;
    if (op == 'U')
      --p[id].x;
    else if (op == 'D')
      ++p[id].x;
    else if (op == 'L')
      --p[id].y;
    else if (op == 'R')
      ++p[id].y;
    else if (op == 'C')
      cin >> s;
    else if (op == 'T') {
      if (a[p[id].x][p[id].y] == "BG") {
        ++rs;
        printf("%d RED GOAL\n", i);
      } else if (a[p[id].x][p[id].y] == "RG") {
        ++bs;
        printf("%d BLUE GOAL\n", i);
      }
    }
  }
  printf("FINAL SCORE: %d %d", rs, bs);
  return 0;
}
```
核心实现思想：使用 `map` 记录球员位置，按步骤模拟操作，根据操作更新位置，投球时判断是否进球，更新分数并输出进球信息。

- **JOE_ZengYuQiao_0928（4星）**
    - **关键亮点**：思路明确，详细说明了操作步骤，代码逻辑清晰，考虑了球跟随球员移动的情况。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
string s[105][105];
struct nn{
	int x,y;
};
map<string,nn> mp;
int n,m,ans1,ans2; 
bool vis1[105][105];
bool vis2[105][105];
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
			mp[s[i][j]]={i,j};
		}
	}
	int T;
	cin>>T;
	for(int i=0;i<T;i++){
		string id;
		char ID;
		cin>>id>>ID;
		if(ID=='U'){
			if(mp[".Q"].x==mp[id].x&&mp[".Q"].y==mp[id].y){
				mp[".Q"].x--;
			}
			mp[id].x--;
		}
		if(ID=='D'){
			if(mp[".Q"].x==mp[id].x&&mp[".Q"].y==mp[id].y){
				mp[".Q"].x++;
			}
			mp[id].x++;
		}
		if(ID=='L'){
			if(mp[".Q"].x==mp[id].x&&mp[".Q"].y==mp[id].y){
				mp[".Q"].y--;
			}
			mp[id].y--;
		}
		if(ID=='R'){
			if(mp[".Q"].x==mp[id].x&&mp[".Q"].y==mp[id].y){
				mp[".Q"].y++;
			}
			mp[id].y++;
		}
		if(ID=='C'){
			string ss;
			cin>>ss;
		} 
		if(ID=='T'){
			if(s[mp[".Q"].x][mp[".Q"].y]=="BG"){
				cout<<i<<" RED GOAL\n";
				ans1++;
			}
			if(s[mp[".Q"].x][mp[".Q"].y]=="RG"){
				cout<<i<<" BLUE GOAL\n";
				ans2++;
			}
			mp[".Q"]={(n+1)/2,(m+1)/2};
		} 
	}
	cout<<"FINAL SCORE: "<<ans1<<" "<<ans2;
     return  0;
}
```
核心实现思想：使用 `map` 记录球员和球的位置，按步骤模拟操作，移动时判断球是否跟随球员，投球时判断是否进球，更新分数并输出进球信息，进球后将球放回场地中央。

- **fmdd_szx（4星）**
    - **关键亮点**：思路简洁明了，代码实现直接，使用 `map` 记录位置，易于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,T,i,j,r,b;
string k,s,a[101][101];
char op;
struct node{
    int x,y;
};
map<string,node> f;
int main(){
    ios::sync_with_stdio(0);
    cin.tie();cout.tie(0);
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){
            cin>>a[i][j];
            if(a[i][j]!="..")
                f[a[i][j]]=(node){i,j};//记录位置
        }
    cin>>T;
    for(i=0;i<T;i++){
        cin>>k>>op;
        if(op=='U') f[k].x--;
        else if(op=='D') f[k].x++;
        else if(op=='L') f[k].y--;
        else if(op=='R') f[k].y++;
        else if(op=='C') cin>>s;
        else if(op=='T')
            if(a[f[k].x][f[k].y]=="BG") r++,cout<<i<<" RED GOAL\n";
            else if(a[f[k].x][f[k].y]=="RG") b++,cout<<i<<" BLUE GOAL\n";
    }
    cout<<"FINAL SCORE: "<<r<<" "<<b;
    return 0;
}
```
核心实现思想：使用 `map` 记录球员和球的位置，按步骤模拟操作，根据操作更新位置，投球时判断是否进球，更新分数并输出进球信息。

### 最优关键思路或技巧
- 使用 `map` 记录球员和球的位置，以名称为键，位置为值，方便根据名称查找和更新位置。
- 按步骤模拟操作，清晰地处理移动、接球和投球等操作。
- 投球时判断是否进球，注意区分红队和蓝队进球的情况。

### 可拓展之处
同类型题或类似算法套路：
- 其他体育比赛模拟题，如篮球比赛、足球比赛等，可能会有更多的规则和操作，需要更复杂的模拟。
- 游戏模拟题，如棋盘游戏、角色扮演游戏等，也需要根据规则进行模拟操作。

### 推荐洛谷题目
- P1042 乒乓球：模拟乒乓球比赛的得分过程。
- P1563 玩具谜题：模拟玩具的移动和操作。
- P1067 多项式输出：模拟多项式的输出过程。

### 个人心得摘录与总结
- Solune：提到在判断进球时，“在蓝队球门投球红队加分，在红队球门投球蓝队加分”这个地方卡了半天，提醒注意此细节，在做模拟题时要仔细理解规则，避免在细节上出错。
- Genshin_ZFYX：认为大模拟比较难调，建议做一些注释，方便调试和理解代码。

---
处理用时：66.13秒
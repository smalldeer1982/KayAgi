# 题目信息

# Caisa and Sugar

## 题目描述

Caisa 要举办一个派对，他要购买巧克力蛋糕的原料。为此，他去了镇上最大的超市。

不巧，他只有 $s$ 美元买食糖。但这可不是悲伤的理由，因为超市里有 $n$ 种食糖，或许他可以买某一个。但这还没完。超市有着非常特别的找零政策：把糖果给买家作为找零，而不是美分。当然，给的糖果的数量始终不会超过 $99$，因为每个卖家都会最大化找零中美元的数量（$100$ 美分可以换成 $1$ 美元）。

Caisa 只想买一种食糖，同时他也希望找零中的糖果数量最多。他最多能得到多少糖果？请注意，Caisa 并不想降低买食糖的开销，他只想得到最多的糖果找零。

## 说明/提示

在第一个样例中，Caisa 可以买第四种食糖，这种情况下他能得到 $50$ 个糖果找零。

## 样例 #1

### 输入

```
5 10
3 90
12 0
9 70
5 50
7 0
```

### 输出

```
50
```

## 样例 #2

### 输入

```
5 5
10 10
20 20
30 30
40 40
50 50
```

### 输出

```
-1
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是模拟购物找零过程，通过遍历所有商品，找出满足预算且找零糖果最多的方案。
- **思路**：均是先判断钱是否够买商品，再计算找零的糖果数，最后用“打擂台”的方法找出最大值。
- **算法要点**：使用循环遍历商品，用 `max` 函数更新最大值。
- **解决难点**：主要是处理价格刚好等于预算以及美分为 0 的特殊情况，避免错误计算找零糖果数。

### 所选的题解
- **作者：丧黑福造 (赞：3)，4星**
    - **关键亮点**：思路清晰，代码简洁，直接使用 `scanf` 和 `printf` 进行输入输出，没有多余的复杂操作。
```cpp
#include <stdio.h> 
main () {
    int n, s, ans = -1, x, y;
    scanf("%d%d", &n, &s);
    for (int i = 0; i < n; i++) {
        scanf("%d%d", &x, &y);
        if (x < s || (x == s && y == 0))
            ans = ans > (y == 0 ? 0 : 100 - y) ? ans : (y == 0 ? 0 : 100 - y);
    }
    printf ("%d\n", ans);
    return 0;
}
```
核心实现思想：通过循环遍历每种商品，判断钱是否够买，若够则计算找零糖果数并更新最大值。

- **作者：xiaobeng_0912 (赞：0)，4星**
    - **关键亮点**：将价格统一单位为美分，简化了比较和计算过程，代码逻辑清晰。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,s,x,y,maxn=-1,p;
    scanf("%d%d",&n,&s);
    s*=100;
    for(int i=0;i<n;i++){
        scanf("%d%d",&x,&y);
        p=x*100+y;
        if(p<=s){ 
            maxn=max(maxn,y==0?0:100-y); 
        }
    }
    printf("%d",maxn);
    return 0;
}
```
核心实现思想：先将预算转换为美分，再遍历商品，将商品价格也转换为美分，判断是否够买，更新最大值。

- **作者：NotNaLocker (赞：0)，4星**
    - **关键亮点**：使用结构体存储商品价格，代码结构清晰，便于理解和扩展。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s;
struct mod{
    int x,y;
}candy[105];
int main(){
    cin>>n>>s;
    int maxx=-1;
    for(int i=1;i<=n;i++){
        cin>>candy[i].x>>candy[i].y;
        if(candy[i].x*100+candy[i].y<=s*100){
            if(candy[i].y==0) candy[i].y=100;
            maxx=max(maxx,100-candy[i].y);
        }
    }
    cout<<maxx;
    return 0;
} 
```
核心实现思想：用结构体存储商品价格，遍历商品，判断是否够买，处理美分为 0 的情况，更新最大值。

### 最优关键思路或技巧
- **统一单位**：将美元转换为美分，避免浮点数运算，简化计算和比较过程。
- **打擂台算法**：使用一个变量记录最大值，在遍历过程中不断更新，找到全局最大值。
- **特殊情况处理**：对美分为 0 和价格刚好等于预算的情况进行特判，避免错误计算找零糖果数。

### 可拓展之处
同类型题目可能会增加商品种类、预算限制或找零规则的复杂度，例如可以有多种购买组合、不同的找零策略等。类似算法套路可以应用于资源分配、最优选择等问题，通过遍历所有可能的方案，找出满足条件的最优解。

### 推荐洛谷题目
1. P1047 [NOIP2005 普及组] 校门外的树：考察对区间覆盖和模拟的理解。
2. P1059 [NOIP2006 普及组] 明明的随机数：涉及排序和去重，与本题的遍历和比较思想类似。
3. P1067 [NOIP2009 普及组] 多项式输出：需要模拟多项式的输出过程，处理各种特殊情况。

### 个人心得
部分题解提到了要注意美分为 0 的情况，否则会错误计算找零糖果数，这是本题的一个关键易错点，在处理类似问题时需要特别注意特殊情况的处理。 

---
处理用时：24.34秒
# 题目信息

# New Year Book Reading

## 题目描述

小明非常喜欢读书。他一共有 $n$ 本书，编号为 $1\sim n$，第 $i$本书重 $w_i$。

小明计划在暑假的 $m$ 天里每天读一本书，第 $i$ 天读第 $d_i$ 本书，可能会重复读到同一本书。

因为所有的书都是堆成一摞的，所以每次读某本书之前小明都需要先将这本书上面所有的书搬开，拿出这本书，再将搬开的书按原顺序放回去，消耗体力为搬开书的重量之和，读完这本书后将其放在这摞书的最上面。

小明想知道这 $n$ 本书以怎样的初始顺序放置，所搬书消耗总体力最小。

## 样例 #1

### 输入

```
3 5
1 2 3
1 3 2 3 1
```

### 输出

```
12
```

# AI分析结果

### 题解综合分析与结论
这些题解均采用贪心算法解决问题。核心思路是按照书第一次出现的顺序摆放书，能使消耗的总体力最小。
- **思路对比**：
    - 一叶知秋。通过构造初始序列，将书按第一次出现顺序排列，反着存储，再模拟取书过程。
    - LesterYu 开四个数组分别存储书的重量、每次取的书、书的堆放顺序和每本书的位置，模拟取书并更新答案。
    - Luckies、A_better_world、墨舞灵纯 思路类似，倒序枚举之前看过的书，统计上面书的总重量，避免重复统计。
    - watermouthhang 先记录书第一次出现的位置，按此排序作为初始栈，再模拟取书过程。
- **算法要点**：关键在于确定书的初始顺序，以减少取书时的体力消耗。通过贪心策略，让先看的书放在上面。
- **解决难点**：主要难点是处理重复书的重量统计，多数题解使用标记数组避免重复计算。

### 所选题解
- **一叶知秋。（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对构造初始序列和模拟取书过程有明确解释。
    - **个人心得**：通过修改样例发现答案与重量无关，从而推出正解。
```cpp
while(i<=m){//构造序列
    i++;
    if(v[b[i]])continue;
    while(b[i]==b[i-1])i++;
    xl[++k]=b[i];
    v[b[i]]=true;
}
k--;
for(i=1;i<=k/2;i++){//反着来
    int c=xl[i];
    xl[i]=xl[k-i+1];
    xl[k-i+1]=c;
}
for(i=1;i<=m;i++){
    int s=0;
    for(j=k;j>=1;j--){//求第i次阅读的重量
        if(b[i]==xl[j])break;
        s+=a[xl[j]];
    }
    xl[++k]=xl[j];//划重点
    xl[j]=0;//划重点
    ans+=s;
}
```
核心实现思想：先构造初始序列，将书按第一次出现顺序存储，反着存储是为了后续模拟取书时方便操作。模拟取书过程中，统计上面书的重量，更新答案，并将取出的书放到顶部。

- **Luckies（4星）**
    - **关键亮点**：对贪心策略有详细解释，代码简洁易懂。
```cpp
for (int i = 1; i <= m; i++)
{
    cin >> a[i];//输入要看的书
    memset(vis, 0, sizeof(vis));//对于每次阅读书，都要重新统计上面的所有书的总重量
    int sum = 0;
    for (int j = i - 1; j >= 1; j--)//倒序枚举之前看过的书
    {
        if (a[j] == a[i])//如果之前看过，那么a[j]前面的书就不需要搬动
            break;
        if (!vis[a[j]])//重复的书只统计一次重量
        {
            sum += w[a[j]];
            vis[a[j]] = true;//标记这本书已经统计过了，后面不计算重量
        }
    }
    ans += sum;//需要的体力加到总体力里面去
}
```
核心实现思想：倒序枚举之前看过的书，统计上面书的总重量，使用标记数组避免重复统计，将每次取书的体力消耗累加到总体力中。

- **A_better_world（4星）**
    - **关键亮点**：代码实现完整，有快读优化，对核心代码有详细解释。
```c
for(int i = 1; i <= m; i++)
{
    a[i] = read();
    memset(vis, 0, sizeof(vis)); // 清空。
    sum = 0;
    for(int j = i - 1; j >= 1; j--) // 计算前面所有数的 总重量。
    {
        if(a[j] == a[i])
            break;
        if(vis[a[j]] == false) // 重复的数值统计一次。
        {
            sum += w[a[j]];
            vis[a[j]] = true; // 标记这本书已经统计，不再做统计。
        }
    }
    ans += sum; // 需要的体力加到总体力里去。
}
```
核心实现思想：与 Luckies 的思路一致，通过倒序枚举和标记数组统计每次取书的体力消耗，更新总体力。

### 最优关键思路或技巧
- **贪心策略**：按照书第一次出现的顺序摆放书，减少取书时的体力消耗。
- **标记数组**：避免重复统计书的重量，提高效率。

### 拓展思路
同类型题或类似算法套路：
- 涉及物品顺序排列以优化某种代价的问题，可考虑贪心算法。
- 模拟操作过程中，使用标记数组避免重复计算。

### 推荐题目
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P2240 硬币购物](https://www.luogu.com.cn/problem/P2240)

### 个人心得摘录与总结
- 一叶知秋。通过修改样例发现答案与重量无关，从而推出正解，说明在解题时可通过对样例的变形和分析寻找思路。

---
处理用时：35.27秒
# 题目信息

# Mike and strings

## 题目描述

Mike有n个字符串s1,s2,……，sn，每个字符串均由小写字母构成。 每次移动你可以选择一个字符串si, 第1个字符移动最后，比如字符串 "coolmikecoolmike", 移动1次变成字符串 "oolmikecoolmikec"。

请计算至少需要移动多少次，可以使得n个字符串都变成相同。

## 样例 #1

### 输入

```
4
xzzwo
zwoxz
zzwox
xzzwo
```

### 输出

```
5
```

## 样例 #2

### 输入

```
2
molzv
lzvmo
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
kc
kc
kc
```

### 输出

```
0
```

## 样例 #4

### 输入

```
3
aa
aa
ab
```

### 输出

```
-1
```

# AI分析结果

### 题目翻译
#### 题目描述
迈克有 n 个字符串 s1, s2, ……, sn，每个字符串均由小写字母组成。每次操作，你可以选择一个字符串 si，将其第一个字符移到最后。例如，字符串 "coolmikecoolmike" 移动一次后变为 "oolmikecoolmikec"。

请计算至少需要进行多少次操作，才能使这 n 个字符串变得相同。

#### 样例 #1
##### 输入
```
4
xzzwo
zwoxz
zzwox
xzzwo
```
##### 输出
```
5
```

#### 样例 #2
##### 输入
```
2
molzv
lzvmo
```
##### 输出
```
2
```

#### 样例 #3
##### 输入
```
3
kc
kc
kc
```
##### 输出
```
0
```

#### 样例 #4
##### 输入
```
3
aa
aa
ab
```
##### 输出
```
-1
```

### 综合分析与结论
#### 思路对比
这些题解的核心思路基本一致，都是通过枚举一个目标字符串，然后计算其他字符串变成该目标字符串所需的最小移动次数，最后取所有情况的最小值。部分题解在开始时会先判断是否有解，即检查所有字符串的字符种类和数量是否一致。

#### 算法要点
- **化环为链**：将每个字符串复制一份接在原字符串后面，这样可以方便地通过 `find` 函数查找某个字符串在循环移动后是否能与目标字符串匹配。
- **枚举目标字符串**：依次选取每个字符串作为目标字符串，计算其他字符串变成该目标字符串的移动次数。
- **使用 `find` 函数**：利用 STL 中的 `find` 函数查找目标字符串在复制后的字符串中的位置，该位置即为所需的移动次数。

#### 解决难点
- **判断无解情况**：如果某个字符串无法通过循环移动变成目标字符串，则说明无解，直接输出 -1。
- **计算最小移动次数**：通过枚举所有可能的目标字符串，取所有情况的最小值作为最终答案。

### 题解评分与选择
| 作者 | 评分 | 关键亮点 |
| ---- | ---- | ---- |
| 风云幻 | 4星 | 思路清晰，代码简洁，使用 `find` 函数快速解决问题 |
| zhoujunchen | 4星 | 详细解释了思路，代码规范，通过 `min` 函数取最小值 |
| Zyh_AKer | 4星 | 明确提出化环为链的思路，代码可读性高 |

### 最优关键思路或技巧
- **化环为链**：将字符串复制一份接在后面，把循环移动问题转化为在新字符串中查找子串的问题，简化了问题的处理。
- **使用 `find` 函数**：利用 STL 中的 `find` 函数快速查找子串的位置，避免了手动模拟循环移动的复杂过程。

### 拓展思路
同类型题目可能会有不同的字符串操作规则，例如可以同时移动多个字符、可以进行删除或插入操作等。解题思路仍然是枚举目标状态，计算其他状态变成目标状态的操作次数，取最小值。

### 推荐题目
- [P1055 ISBN 号码](https://www.luogu.com.cn/problem/P1055)：考察字符串处理和简单的逻辑判断。
- [P1598 垂直柱状图](https://www.luogu.com.cn/problem/P1598)：需要对字符串进行统计和输出格式化。
- [P1200 [USACO1.1]你的飞碟在这儿Your Ride Is Here](https://www.luogu.com.cn/problem/P1200)：涉及字符串的字符编码和简单的数学运算。

### 个人心得摘录与总结
- **御坂13558号**：一开始认为题目难度被高估，后来发现有其难度所在。通过将字符串看作字符环，用单向循环链表的思维方式帮助思考，但实际代码中不需要真正实现链表。在判断最小次数时，需要注意复制字符串的位置和对 `find` 函数返回值的处理。
总结：在解题时要充分理解题目本质，运用合适的思维方式简化问题，但在代码实现上要灵活处理，避免过度复杂。

### 重点代码
#### 风云幻的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a[51],b[51];
int ans=2501;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];b[i]=a[i]+a[i];//将a【i】复制一下
    }
    for(int i=0;i<n;i++)
    {
        int jians=0;
        for(int j=0;j<n;j++)
        {
            if(b[j].find(a[i])!=-1)
            {
                jians+=b[j].find(a[i]);//别的变成a【i】的最小步骤
            }
            if(b[j].find(a[i])==-1)
            {
                cout<<-1;//若果查不到，意味着有的字符串不包含在内
                return 0;
            }
        }
        ans=min(ans,jians);
    }
    cout<<ans;
}
```
核心实现思想：先将每个字符串复制一份接在后面，然后枚举每个字符串作为目标字符串，计算其他字符串变成该目标字符串所需的移动次数，最后取最小值。

#### zhoujunchen的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define AC; return 0;
int n,ans=2147483647;
string a[55],b[55];
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
        b[i]=a[i]+a[i];//拆环为链，将整个字符串复制一份，方便我们查找 
    }
    for(int i=0;i<n;i++){
        int tmp=0;
        for(int j=0;j<n;j++){
            if(b[j].find(a[i])!=-1)//找到了，有解 
                tmp+=b[j].find(a[i]);//记录答案 
            else{//无解 
                cout<<"-1";
                return 0; 
            }
        }
        ans=min(ans,tmp);//取最小值 
    }
    cout<<ans<<"\n";
    AC;
} 
```
核心实现思想：与风云幻的代码类似，通过化环为链和 `find` 函数计算最小移动次数，最后取最小值。

#### Zyh_AKer的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=0x3f3f3f3f;
string s[60];
string sv[60];
int cnt[60][60]; 
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>s[i];
        sv[i]=s[i]+s[i];
    }
    for (int i=1;i<=n;i++)
    {
        int sum=0;
        for (int j=1;j<=n;j++)
        {
            if (sv[j].find(s[i])!=-1) 
            {
                sum+=sv[j].find(s[i]);
            }
            else
            {
                cout<<-1;
                return 0;
            }
        }
        ans=min(ans,sum);
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：同样采用化环为链的方法，枚举目标字符串，计算移动次数并取最小值，若有无解情况则直接输出 -1。

---
处理用时：39.56秒
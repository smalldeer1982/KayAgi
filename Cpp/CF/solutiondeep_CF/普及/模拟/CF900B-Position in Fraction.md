# 题目信息

# Position in Fraction

## 题目描述

给你三个整数 $a,b,c$，问 $\dfrac{a}{b}$ 的小数部分第几位是 $c$，如果无法找到，请输出 `-1`。

## 说明/提示

对于 $100\%$ 的数据：$1\le a<b\le 10^5,0\le c\le 9$。

## 样例 #1

### 输入

```
1 2 0
```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 7
```

### 输出

```
-1```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是模拟除法过程来确定 $\frac{a}{b}$ 的小数部分，进而找到数字 $c$ 出现的位置。主要的算法要点在于模拟竖式除法，不断将余数乘 10 后再进行除法运算，同时记录余数是否重复以判断是否出现循环节。

各题解的不同之处在于：
- 部分题解对分数进行了化简处理，而有些题解直接进行模拟。
- 对于循环节的判断，都利用了余数重复这一特性，但在代码实现细节上略有差异。
- 部分题解使用了数组来标记余数是否出现过，而 Java 题解则通过字符串处理来查找数字。

### 所选题解
- **fls233666（4星）**
  - 关键亮点：思路清晰，对循环节的判断和处理解释详细，代码可读性高。
  - 核心代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int mxn = 1e5+5;
int a,b,c,d,cnt;
bool ap[mxn];
int main(){
    scanf("%d%d%d",&a,&b,&c);
    a%=b;  //去除整数部分
    cnt=1;  //当前小数位数为1
    while(1){  //循环模拟除法
        a*=10;
        d=a/b;   //算小数部分
        a%=b;   //取余数
        if(d==c){  //找到第一个出现的位置，直接输出
            printf("%d",cnt);
            return 0;
        }
        if(ap[a])  //余数出现两次，有循环节，跳出
            break;
        ap[a]=true;
        cnt++;   //增加小数位数
    }
    printf("-1");  //未找到解
    return 0;
}
```
核心实现思想：通过循环模拟除法过程，每次将余数乘 10 后计算商和新的余数，判断商是否为 $c$，同时用数组标记余数是否出现过，若余数重复则说明出现循环节，跳出循环。

- **Siteyava_145（4星）**
  - 关键亮点：思路简洁明了，代码实现直接，对余数标记的处理清晰。
  - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int vis[1000005];//标记[12行]余数的出现 
int main(){
    cin>>a>>b>>c;
    a%=b;//把没用的整数搞掉 
    int cnt=1;//小数位数初始化为 1 
    while(true){
        a*=10;
        int x=a/b;//这一位【小数点后第cnt位】 
        a%=b;//余数 
        if(x==c){cout<<cnt;return 0;}//如果那一位符合要求，则输出cnt(小数位数) 
        if(vis[a]>=1)break;//跳出后输出-1 
        vis[a]=1;//标记余数，注意不是上面的 x！！！#3 WA 
        cnt++;//推进 
    }
    cout<<-1;
    return 0;
}
```
核心实现思想：同样是模拟除法过程，用数组标记余数是否出现过，若当前商等于 $c$ 则输出小数位数，若余数重复则跳出循环输出 -1。

- **Iron_Heart（4星）**
  - 关键亮点：代码简洁，逻辑清晰，通过数组标记余数判断循环节。
  - 核心代码：
```cpp
#include <cstdio>

bool vis[100100];
int a, b, c;

int main() {
    scanf("%d%d%d", &a, &b, &c);
    for (int d = 1;; ++d) {
        if (vis[a]) {
            break;
        }
        vis[a] = 1;
        a *= 10;
        if ((a / b) == c) {
            printf("%d", d);
            return 0;
        }
        a %= b;
    }
    puts("-1");
    return 0;
}
```
核心实现思想：使用 `vis` 数组标记余数是否出现过，在循环中不断模拟除法过程，若商等于 $c$ 则输出当前位数，若余数重复则跳出循环输出 -1。

### 最优关键思路或技巧
- **模拟竖式除法**：通过不断将余数乘 10 后进行除法运算，模拟出小数部分的每一位。
- **余数标记**：利用数组标记余数是否出现过，当余数重复时，说明出现了循环节，可停止模拟。

### 可拓展之处
同类型题或类似算法套路：
- 计算分数的循环节长度。
- 判断两个分数的小数部分是否相同。
- 计算分数的小数部分前 $n$ 位的和。

### 推荐洛谷题目
1. P1480 A/B Problem：考察高精度除法的实现。
2. P2142 高精度减法：涉及高精度计算的基本操作。
3. P1601 A+B Problem（高精）：练习高精度加法的实现。

### 个人心得摘录与总结
- **Siteyava_145**：提到标记余数时要注意不是标记商，有过因标记错误导致 WA 的调试经历，提醒我们在实现时要准确标记关键信息。 

---
处理用时：29.18秒
# 题目信息

# Sakurako's Hobby

## 题目描述

对于一个给定的排列 $ p $，Sakurako 称整数 $ j $ 从整数 $ i $ 可达，意思是可以通过若干次操作将 $ i $ 改为 $ p_i $，最终使 $ i $ 等于 $ j $。

举个例子，如果 $ p=[3,5,6,1,2,4] $，那么 $ 4 $ 是从 $ 1 $ 可达的，因为变化过程可以是：$ i=1 \rightarrow i=p_1=3 \rightarrow i=p_3=6 \rightarrow i=p_6=4 $。这样 $ i $ 就变成了 $ 4 $，因此 $ 4 $ 是从 $ 1 $ 可达的。

在这个排列中，每个数字都有两种颜色：黑色或白色。

Sakurako 定义了一个函数 $ F(i) $，表示从 $ i $ 可达的黑色整数的总数。

她对每一个 $ 1\le i\le n $ 的 $ F(i) $ 都很感兴趣，但计算所有值太过复杂，因此她希望你能帮助她解决这个问题。

一个长度为 $ n $ 的排列是一个由 $ 1 $ 到 $ n $ 这 $ n $ 个不同整数构成的数组。例如，$ [2,3,1,5,4] $ 是一个排列，而 $ [1,2,2] $ 却不是（因为数字 $ 2 $ 出现了两次），同样地，$ [1,3,4] $ 也不是（$ n=3 $，但数组中包含 $ 4 $）。

## 样例 #1

### 输入

```
5
1
1
0
5
1 2 4 5 3
10101
5
5 4 1 3 2
10011
6
3 5 6 1 2 4
010000
6
1 2 3 4 5 6
100110```

### 输出

```
1 
0 1 1 1 1 
2 2 2 2 2 
4 1 4 4 1 4 
0 1 1 0 0 1```

# AI分析结果

### 题目内容重写（中文）

#### Sakurako的爱好

##### 题目描述

对于一个给定的排列 $ p $，Sakurako 称整数 $ j $ 从整数 $ i $ 可达，意思是可以通过若干次操作将 $ i $ 改为 $ p_i $，最终使 $ i $ 等于 $ j $。

举个例子，如果 $ p=[3,5,6,1,2,4] $，那么 $ 4 $ 是从 $ 1 $ 可达的，因为变化过程可以是：$ i=1 \rightarrow i=p_1=3 \rightarrow i=p_3=6 \rightarrow i=p_6=4 $。这样 $ i $ 就变成了 $ 4 $，因此 $ 4 $ 是从 $ 1 $ 可达的。

在这个排列中，每个数字都有两种颜色：黑色或白色。

Sakurako 定义了一个函数 $ F(i) $，表示从 $ i $ 可达的黑色整数的总数。

她对每一个 $ 1\le i\le n $ 的 $ F(i) $ 都很感兴趣，但计算所有值太过复杂，因此她希望你能帮助她解决这个问题。

一个长度为 $ n $ 的排列是一个由 $ 1 $ 到 $ n $ 这 $ n $ 个不同整数构成的数组。例如，$ [2,3,1,5,4] $ 是一个排列，而 $ [1,2,2] $ 却不是（因为数字 $ 2 $ 出现了两次），同样地，$ [1,3,4] $ 也不是（$ n=3 $，但数组中包含 $ 4 $）。

##### 样例 #1

###### 输入

```
5
1
1
0
5
1 2 4 5 3
10101
5
5 4 1 3 2
10011
6
3 5 6 1 2 4
010000
6
1 2 3 4 5 6
100110
```

###### 输出

```
1 
0 1 1 1 1 
2 2 2 2 2 
4 1 4 4 1 4 
0 1 1 0 0 1
```

### 题解综合分析与结论

#### 分析与结论

1. **算法思路**：所有题解都基于图论中的强连通分量（SCC）或并查集来处理排列中的环结构。通过将排列中的每个元素与其对应的 $ p_i $ 连边，形成若干个环，然后计算每个环中黑色节点的数量。

2. **难点对比**：
   - **chenxi2009** 使用并查集来维护环结构，并在合并过程中统计黑色节点的数量，代码简洁且高效。
   - **Super_Cube** 使用 Tarjan 算法进行强连通分量缩点，然后通过拓扑排序累加黑色节点数量，思路清晰但实现较为复杂。
   - **naroto2022** 也使用 Tarjan 算法，但代码结构较为混乱，且未完全实现题目要求的功能。
   - **cly312** 和 **Lfz312g** 使用 DFS 遍历环，并记录黑色节点数量，思路简单但时间复杂度较高。

3. **最优思路**：**chenxi2009** 的并查集方法最为简洁高效，适合处理此类问题。

### 所选高星题解

#### 题解1：chenxi2009 (4星)

**关键亮点**：
- 使用并查集维护环结构，并在合并过程中统计黑色节点数量，代码简洁且高效。
- 时间复杂度为 $O(n \alpha(n))$，其中 $\alpha(n)$ 是反阿克曼函数，效率较高。

**核心代码**：
```cpp
int find(int x){
    return x == f[x] ? x : f[x] = find(f[x]);
}
for(int i = 1;i <= n;i ++){
    int u = find(i),v = find(p[i]);
    if(u == v) continue;
    f[u] = v;
    cnt[v] += cnt[u];
}
```

#### 题解2：Super_Cube (4星)

**关键亮点**：
- 使用 Tarjan 算法进行强连通分量缩点，然后通过拓扑排序累加黑色节点数量，思路清晰。
- 代码实现较为复杂，但逻辑严谨。

**核心代码**：
```cpp
void tarjan(int p){
    dfn[p]=low[p]=++tdx;
    S.push(p);
    for(const int&i:v[p])
        if(!dfn[i])
            tarjan(i),low[p]=std::min(low[p],low[i]);
        else if(!scc_id[i])
            low[p]=std::min(low[p],dfn[i]);
    if(dfn[p]==low[p]){
        dp[++scc]=0;
        while(true){
            scc_id[S.top()]=scc;
            dp[scc]+=s[S.top()]=='0';
            if(S.top()==p)break;
            S.pop();
        }
        S.pop();
    }
}
```

### 最优关键思路或技巧

- **并查集维护环结构**：通过并查集将排列中的环结构进行合并，并在合并过程中统计黑色节点的数量，代码简洁且高效。
- **Tarjan 算法缩点**：通过 Tarjan 算法将强连通分量缩点，然后通过拓扑排序累加黑色节点数量，适合处理复杂的环结构。

### 可拓展之处

- **类似问题**：可以扩展到处理更复杂的图结构，如带权图或有向无环图（DAG）中的路径统计问题。
- **优化思路**：可以进一步优化并查集的路径压缩和按秩合并，提高算法效率。

### 推荐题目

1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)

### 个人心得

- **chenxi2009**：并查集在处理环结构时非常高效，代码简洁且易于理解。
- **Super_Cube**：Tarjan 算法虽然复杂，但在处理强连通分量时非常有用，适合处理更复杂的图结构。

---
处理用时：56.65秒
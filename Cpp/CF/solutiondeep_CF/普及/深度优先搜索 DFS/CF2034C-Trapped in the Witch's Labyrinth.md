# 题目信息

# Trapped in the Witch's Labyrinth

## 题目描述

在《列王纪》传奇英雄鲁斯塔姆的第四个任务中，一个老女巫创造了一个迷宫来困住他。迷宫是一个 $n\times m$ 的矩形网格，迷宫中每一个单元格都有箭头，指向上、下、左或右的一个特定方向。女巫对鲁斯塔姆施了魔法，他每进入一个单元格，都会按照箭头的方向移动到下一个单元格。

如果鲁斯塔姆可以离开迷宫，他将战胜女巫。否则他将永远被困在迷宫中。

还有一些单元格的方向没有被女巫确定，她希望你指定一些方向，使得鲁斯塔姆能够被困住的起始格最多。你的任务是找到使得鲁斯塔姆被困住的最多起始单元格数。

## 样例 #1

### 输入

```
3
3 3
UUU
L?R
DDD
2 3
???
???
3 3
?U?
R?L
RDL```

### 输出

```
0
6
5```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

在《列王纪》传奇英雄鲁斯塔姆的第四个任务中，一个老女巫创造了一个迷宫来困住他。迷宫是一个 $n\times m$ 的矩形网格，迷宫中每一个单元格都有箭头，指向上、下、左或右的一个特定方向。女巫对鲁斯塔姆施了魔法，他每进入一个单元格，都会按照箭头的方向移动到下一个单元格。

如果鲁斯塔姆可以离开迷宫，他将战胜女巫。否则他将永远被困在迷宫中。

还有一些单元格的方向没有被女巫确定，她希望你指定一些方向，使得鲁斯塔姆能够被困住的起始格最多。你的任务是找到使得鲁斯塔姆被困住的最多起始单元格数。

#### 输入格式

输入的第一行包含一个整数 $t(1≤t≤10^4)$，表示测试数据的数量。

对于每个测试数据：

- 第一行包含两个整数 $n$ 和 $m(1 \leq n,m \leq 1000)$，表示迷宫的行数和列数。

- 接下来的 $n$ 行包含一个字符串 $m$，表示网格方向。每个字符都是以下字符之一：

  - U（上）
  - D（下）
  - L（左）
  - R（右）
  - ?（还未分配方向）

保证所有数据的 $n \times m$ 之和最多为 $10^6$。

#### 输出格式

对于每个测试数据，输出将方向分配给未分配方向的单元格后，能让鲁斯塔姆永远被困的起始格的最大数量。

### 综合分析与结论

该题目要求我们通过为未确定方向的单元格指定方向，使得鲁斯塔姆被困住的起始格数量最大化。核心问题在于如何判断一个起始格是否会被困住，以及如何为未确定方向的单元格指定方向以最大化被困住的起始格数量。

### 题解评分与亮点

#### 题解1：Gary0925 (★★★★☆)

**关键亮点：**
- 使用记忆化DFS来判断每个起始格是否会被困住。
- 通过临时标记当前格为“被困住”来简化判断逻辑。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
bool dfs(int i, int j) {
	if (i < 1 || i > n || j < 1 || j > m) return 1;
	if (out[i][j] == -1) {
		out[i][j] = 0;
		if (c[i][j] == 'U') out[i][j] = dfs(i - 1, j);
		else if (c[i][j] == 'D') out[i][j] = dfs(i + 1, j);
		else if (c[i][j] == 'L') out[i][j] = dfs(i, j - 1);
		else if (c[i][j] == 'R') out[i][j] = dfs(i, j + 1);
		else out[i][j] = dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1);
	}
	return out[i][j];
}
```

#### 题解2：littlebug (★★★★☆)

**关键亮点：**
- 使用BFS从边缘向内标记所有可以离开迷宫的格子。
- 通过分析未确定方向的格子，判断其是否可以被困住。
- 代码结构清晰，逻辑严谨，适合大规模数据处理。

**核心代码：**
```cpp
void bfs() {
    queue <pii> q;
    rep(i,1,n) a[i][1]=='L' && (q.emplace(i,1),mask(i,1),1),a[i][m]=='R' && (q.emplace(i,m),mask(i,m),1);
    rep(j,1,m) a[1][j]=='U' && (q.emplace(1,j),mask(1,j),1),a[n][j]=='D' && (q.emplace(n,j),mask(n,j),1);

    pii ck; int x,y,nx,ny;
    while(!q.empty()) {
        ck=q.front(); q.pop();
        x=ck.st,y=ck.nd;

        rep(i,1,4) {
            nx=x+dx[i],ny=y+dy[i];
            if(nx<1 || nx>n || ny<1 || ny>m || b[nx][ny] || a[nx][ny]!=dc[i]) continue;
            q.emplace(nx,ny),mask(nx,ny);
        }
    }
}
```

#### 题解3：HetmesAskalana (★★★★☆)

**关键亮点：**
- 使用两轮DFS分别判断每个格子是否可以离开迷宫以及是否可以指向问号格子。
- 通过分析问号格子的周围情况，判断其是否可以被困住。
- 代码逻辑清晰，处理问号格子的方法巧妙。

**核心代码：**
```cpp
bool dfs(int nowx, int nowy) {
    if(nowx < 1 || nowx > n || nowy > m || nowy < 1) return false;
    if(G[nowx][nowy] == '?') return true;
    if(vis[nowx][nowy]) return type[nowx][nowy];
    vis[nowx][nowy] = true;
    int prex = nowx, prey = nowy;
    if     (G[nowx][nowy] == 'U') nowx -= 1;
    else if(G[nowx][nowy] == 'D') nowx += 1;
    else if(G[nowx][nowy] == 'R') nowy += 1;
    else if(G[nowx][nowy] == 'L') nowy -= 1;
    
    if(dfs(nowx, nowy)){
        type[prex][prey] = true;
        return true;
    }else return false;
}
```

### 最优关键思路与技巧

1. **记忆化DFS**：通过记忆化DFS来判断每个起始格是否会被困住，避免重复计算，提高效率。
2. **BFS从边缘向内标记**：通过BFS从迷宫的边缘向内标记所有可以离开迷宫的格子，简化问题。
3. **问号格子的处理**：通过分析问号格子的周围情况，判断其是否可以被困住，确保最大化被困住的起始格数量。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
   - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
   - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

2. **拓展思路**：在处理类似迷宫问题时，可以考虑使用DFS、BFS等搜索算法，结合记忆化或动态规划来优化计算。对于未确定方向的格子，可以通过分析其周围情况来决定其方向，以达到最优解。

---
处理用时：60.13秒
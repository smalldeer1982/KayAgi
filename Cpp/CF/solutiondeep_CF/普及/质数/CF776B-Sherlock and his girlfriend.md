# 题目信息

# Sherlock and his girlfriend

## 题目描述

Sherlock 有一个新女朋友。现在情人节就要到了，他想送给她一些珠宝。 

他买了几件首饰。第 $i$ 件的价格等于 $i+ 1$，也就是说，珠宝的价格分别为 $2,3,4,n + 1$ 。

现在需要给这些珠宝首饰上色。**当一件珠宝的价格是另一件珠宝的价格的素因子时，这两件的颜色就不允许相同。** 此外，要最少化使用的颜色数量。

## 说明/提示

在第一个样例中，第一、第二和第三件首饰的价格分别为 $2$、$3$、$4$,它们的颜色分别为 $1$ 、$1$ 和 $2$。

在这种情况下，由于 $2$ 是 $4$ 的因子，所以具有因数 $2$ 和 $4$ 的珠宝的颜色必须是不同的。

Translated by @皎月半洒花。

## 样例 #1

### 输入

```
3
```

### 输出

```
2
1 1 2 ```

## 样例 #2

### 输入

```
4
```

### 输出

```
2
2 1 1 2
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是基于质数与合数的性质来解决珠宝染色问题。因为质数的约数只有 1 和本身，所以所有质数可以染同一种颜色；而合数的质因子是质数，所以合数染另一种颜色即可满足条件。整体上，当 \(n < 3\) 时，序列中只有质数，颜色数为 1；当 \(n \geq 3\) 时，有质数也有合数，颜色数为 2。

在算法实现上，主要使用了筛法来判断质数，不同题解采用了不同的筛法，如埃氏筛、线性筛等，也有使用简单的素数判断函数的。

### 所选题解
- **作者：Juanzhang (赞：19)，4星**
    - **关键亮点**：思路清晰，使用埃氏筛进行质数判断，代码简洁，对埃氏筛进行了优化，只需要筛到 \(\sqrt{n}\)。
    - **个人心得**：吐槽了题目难度，认为线性筛难度为普及 - 。
- **作者：一只萌新 (赞：2)，4星**
    - **关键亮点**：思路简单直接，明确指出所有质数染同一种颜色，合数染另一种颜色，代码实现简洁。
    - **个人心得**：提到题面是质因子，4 和 8 可以染同一种颜色，帮助理解题意。
- **作者：冒泡ioa (赞：2)，4星**
    - **关键亮点**：思路清晰，通过枚举和标记倍数的方式区分质数和合数，最后分别输出不同颜色，代码简洁易懂。

### 重点代码
#### Juanzhang 的代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 10;
int n;
bool flag[maxn];

int main() {
    scanf("%d", &n);
    flag[0] = flag[1] = 1;
    for (int i = 2; i * i <= n + 1; i++) {
        if (!flag[i]) {
            for (int j = i << 1; j <= n + 1; j += i) {
                flag[j] = 1;
            }
        }
    } 
    puts(n < 3 ? "1" : "2");
    for (int i = 2; i <= n + 1; i++) {
        printf("%d ", flag[i] + 1);
    }
    return 0;
}
```
**核心实现思想**：使用埃氏筛标记合数，通过判断标记数组的值来区分质数和合数，最后根据 \(n\) 的大小输出颜色数，并输出每个珠宝的颜色。

#### 一只萌新的代码
```cpp
#include<iostream>
#include<cstdio>
#define re register
#define il inline
#define ll long long
using namespace std;

inline int read(){
    int s=0,f=0;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-'),c=getchar();
    while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
    return f?-s:s;
}

const int N=1e5+5;
int n,k;
il bool prime(int x){
    if(x==1||x==0) return 0;
    if(x==2||x==3) return 1;
    if(x%6!=1&&x%6!=5) return 0;
    for(re int i=5;i*i<=x;i+=6) if((!(x%i))||(!(x%(i+2)))) return 0;
    return 1;
}
int main(){
    n=read();
    if(n<=2){
        puts("1");
        for(re int i=1;i<=n;++i) puts("1");
        return 0;
    }
    puts("2");
    for(re int i=2;i<=n;++i){
        if(prime(i)) printf("1 ");
        else printf("2 ");
    }
    if(prime(n+1)) printf("1\n");
    else printf("2\n");
    return 0;
}
```
**核心实现思想**：使用简单的素数判断函数判断每个数是否为质数，根据 \(n\) 的大小输出颜色数，然后根据判断结果输出每个珠宝的颜色。

#### 冒泡ioa 的代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
bool s[100005];

int main(){
    int n;
    cin>>n;
    for(int i=2;i<=n+1;i++){
        if(!s[i]){
            for(int j=i<<1;j<=n+1;j+=i)s[j]=1;
        }
    }
    if(n>2)cout<<"2\n";
    else cout<<"1\n";
    for(int i=2;i<=n+1;i++){
        if(!s[i])cout<<"1 ";
        else cout<<"2 ";
    }
    return 0;
}
```
**核心实现思想**：通过枚举和标记倍数的方式区分质数和合数，根据 \(n\) 的大小输出颜色数，最后根据标记数组的值输出每个珠宝的颜色。

### 最优关键思路或技巧
- **利用质数与合数的性质**：所有质数互质，所以可以染同一种颜色；合数的质因子是质数，所以合数染另一种颜色，这样可以保证满足题目要求且使用的颜色数最少。
- **筛法判断质数**：使用筛法（如埃氏筛、线性筛）可以高效地判断一个数是否为质数，避免了每次都进行单独的素数判断，提高了效率。

### 可拓展之处
同类型题或类似算法套路：
- 图的染色问题：给定一个图，要求相邻的顶点颜色不同，求最少的颜色数。可以使用贪心算法或回溯算法来解决。
- 区间染色问题：给定一些区间，要求对这些区间进行染色，使得相邻的区间颜色不同，求最少的颜色数。可以使用排序和贪心算法来解决。

### 推荐题目
- [P3383 【模板】线性筛素数](https://www.luogu.org/problemnew/show/P3383)
- [P5736 【深基7.例2】质数筛](https://www.luogu.org/problemnew/show/P5736)
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.org/problemnew/show/P1217)

### 个人心得摘录与总结
- **Juanzhang**：吐槽了题目难度，认为线性筛难度为普及 - ，提醒我们对不同难度的题目要有正确的认识。
- **一只萌新**：提到题面是质因子，4 和 8 可以染同一种颜色，帮助我们准确理解题意，避免误解。

---
处理用时：53.75秒
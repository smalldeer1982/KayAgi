# 题目信息

# Minimum Ternary String

## 题目描述

给定一个由 '0', '1', '2' 组成的字符串  $S$ 。可以交换相邻'0', '1'或'1', '2'的位置（例如：'12' - '21'  $\;$  '01' - '10'）请输出原字符串经过任意转换后字典序最小的字符串。原字符串长度不超过  $10^5$ 。

## 样例 #1

### 输入

```
100210
```

### 输出

```
001120
```

## 样例 #2

### 输入

```
11222121
```

### 输出

```
11112222
```

## 样例 #3

### 输入

```
20
```

### 输出

```
20
```

# AI分析结果

【题目内容】
# 最小三元字符串

## 题目描述

给定一个由 '0', '1', '2' 组成的字符串 $S$。可以交换相邻的 '0' 和 '1' 或 '1' 和 '2' 的位置（例如：'12' - '21' 或 '01' - '10'）。请输出原字符串经过任意转换后字典序最小的字符串。原字符串长度不超过 $10^5$。

## 样例 #1

### 输入

```
100210
```

### 输出

```
001120
```

## 样例 #2

### 输入

```
11222121
```

### 输出

```
11112222
```

## 样例 #3

### 输入

```
20
```

### 输出

```
20
```

【题解分析与结论】

这些题解的核心思路都是利用 '1' 可以自由移动的特性，将所有的 '1' 提取出来，并在第一个 '2' 之前插入，以确保字典序最小。难点在于如何处理没有 '2' 的情况，以及如何高效地实现这一过程。

【评分较高的题解】

1. **作者：shurongwang (5星)**
   - **关键亮点**：思路清晰，代码简洁高效，直接提取 '1' 并在第一个 '2' 前插入，处理了没有 '2' 的情况。
   - **代码核心**：
     ```cpp
     loop (i, dat.size()) {
         if (dat[i] == '1') {
             ++cnt;
             continue;
         }
         ans += dat[i];
     }
     pos = ans.size();
     loop (i, ans.size()) {
         if (ans[i] == '2') {
             pos = i;
             break;
         }
     }
     loop (j, cnt) {
         ans.insert(ans.begin() + pos, '1');
     }
     ```

2. **作者：Fearliciz (4星)**
   - **关键亮点**：代码简短，使用 `flag` 标记第一个 '2' 的位置，处理了没有 '2' 的情况。
   - **代码核心**：
     ```cpp
     for(int i=0;i<len;i++){
         if(c[i]=='1') continue;
         if(c[i]=='2'&&flag){ 
             for(int j=1;j<=cnt1;j++) cout<<"1"; 
             cout<<"2"; 
             flag=0;
         }
         else cout<<c[i];
     }
     if(flag) for(int j=1;j<=cnt1;j++) cout<<"1";
     ```

3. **作者：小闸蟹 (4星)**
   - **关键亮点**：详细解释了贪心策略，代码结构清晰，处理了没有 '2' 的情况。
   - **代码核心**：
     ```cpp
     if (!HasTwo) {
         for (int i = 0; i < Zero; ++i) std::cout << 0;
         for (int i = 0; i < One; ++i) std::cout << 1;
         std::cout << std::endl;
         return 0;
     }
     bool Met = false;
     for (const auto &c : Str) {
         if (c == '0') std::cout << 0;
         else if (c == '1') continue;
         else if (c == '2') {
             if (!Met) {
                 Met = true;
                 for (int i = 0; i < One; ++i) std::cout << 1;
                 std::cout << 2;
             }
             else std::cout << 2;
         }
     }
     ```

【最优关键思路或技巧】
- **提取 '1' 并在第一个 '2' 前插入**：这是确保字典序最小的关键步骤。
- **处理没有 '2' 的情况**：直接将所有 '1' 放在最后。

【可拓展之处】
- 类似问题可以扩展到更多字符或更复杂的交换规则，核心思路仍然是利用某些字符的自由移动性来优化字典序。

【推荐题目】
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：29.87秒
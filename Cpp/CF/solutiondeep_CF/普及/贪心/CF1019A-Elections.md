# 题目信息

# Elections

## 题目描述

Berland地区的腐败现象非常常见。

马上有一场选举，你事先知道了选民和政党的数量，分别为  $n$  和  $m$  ，对于每一位选民，你知道他将要选举哪一个政党，不过，每一位选民都会在接受一定数额的金钱之后改变他的主意。如果你给第  $i$  位选民  $c_i$  数额的比特币，他就会选举任何你希望他选举的政党。

你的目的是让Berland的联合党赢得这场选举，联合党必须拥有比其它政党都多的选票，在此基础之上，你希望花费的比特币尽可能少。

## 样例 #1

### 输入

```
1 2
1 100
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 5
2 100
3 200
4 300
5 400
5 900
```

### 输出

```
500
```

## 样例 #3

### 输入

```
5 5
2 100
3 200
4 300
5 800
5 900
```

### 输出

```
600
```

# AI分析结果

【题目内容】
# 选举

## 题目描述

Berland地区的腐败现象非常常见。

马上有一场选举，你事先知道了选民和政党的数量，分别为 $n$ 和 $m$，对于每一位选民，你知道他将要选举哪一个政党，不过，每一位选民都会在接受一定数额的金钱之后改变他的主意。如果你给第 $i$ 位选民 $c_i$ 数额的比特币，他就会选举任何你希望他选举的政党。

你的目的是让Berland的联合党赢得这场选举，联合党必须拥有比其它政党都多的选票，在此基础之上，你希望花费的比特币尽可能少。

## 样例 #1

### 输入

```
1 2
1 100
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5 5
2 100
3 200
4 300
5 400
5 900
```

### 输出

```
500
```

## 样例 #3

### 输入

```
5 5
2 100
3 200
4 300
5 800
5 900
```

### 输出

```
600
```

【题解分析与结论】

本题的核心在于如何通过最小的花费让联合党获得最多的选票。大多数题解采用了枚举联合党最终得票数的策略，并通过贪心算法来计算最小花费。具体来说，题解们通常分为以下几个步骤：
1. 枚举联合党最终得票数 $x$。
2. 对于每个其他政党，如果其得票数大于等于 $x$，则通过贪心策略购买其选民，使其得票数小于 $x$。
3. 如果联合党得票数仍不足 $x$，则从剩余选民中按最小花费购买。

【评分较高的题解】

1. **作者：易极feng (5星)**
   - **关键亮点**：通过枚举联合党最终得票数，结合贪心策略，清晰明了地解决了问题。代码结构清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     for(i=mv;i<=n;i++){
         memset(v,0,sizeof(v));
         memset(t,0,sizeof(t));
         cnt=vote=0;
         for(j=1;j<=n;j++){
             if(s[j].p==1){
                 vote++,v[j]=1;
                 continue;
             }
             if(p[s[j].p]-t[s[j].p]>=i){
                 cnt+=s[j].c,v[j]=1,t[s[j].p]++,vote++;
             }
         }
         j=1;
         while(vote<i){
             if(!v[j])cnt+=s[j].c,vote++;
             j++;
         }
         ans=min(ans,cnt);
     }
     ```
   - **个人心得**：通过逆向思维，枚举联合党得票数，使得贪心策略变得清晰。

2. **作者：KingPowers (4星)**
   - **关键亮点**：详细解释了枚举联合党得票数的思路，并通过排序和贪心策略计算最小花费。代码可读性高。
   - **核心代码**：
     ```cpp
     int check(int x){
         int tot=0,cost=0,cnt=0;
         for(int i=2;i<=m;i++){
             int j=0;
             if(v[i].size()>=x) j=v[i].size()-x+1;
             for(int k=0;k<j;k++) cost+=v[i][k];
             for(;j<v[i].size();j++) t[++tot]=v[i][j];
         }
         int pnt=n-tot;
         if(pnt>x) return -1;
         sort(t+1,t+tot+1);
         for(int i=1;i<=x-pnt;i++) cost+=t[i];
         return cost;
     }
     ```
   - **个人心得**：通过枚举联合党得票数，结合贪心策略，成功解决了问题。

3. **作者：Frozencode (4星)**
   - **关键亮点**：通过二分查找优化了枚举联合党得票数的过程，进一步提高了算法效率。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     ll check(ll u){
         ll ans = 0;
         int tot = a[0].size();
         vector<ll> nti;
         for(int i = 1;i<=N;++i){
             int j = 0,k = a[i].size();
             while(k>=u) ans += a[i][j++],--k,++tot;
             while(j<a[i].size()) nti.push_back(a[i][j++]);
         }
         sort(nti.begin(),nti.end());
         for(int i = 0;i<nti.size();++i){
             if(tot>=u) break;
             ans += nti[i],++tot;
         }
         return ans;
     }
     ```
   - **个人心得**：通过二分查找优化了枚举过程，使得算法更加高效。

【最优关键思路与技巧】
- **枚举联合党得票数**：通过枚举联合党最终得票数，结合贪心策略，可以有效地计算出最小花费。
- **贪心策略**：对于每个其他政党，按最小花费购买其选民，使其得票数小于联合党。
- **二分查找优化**：通过二分查找优化枚举过程，进一步提高算法效率。

【可拓展之处】
- 类似的问题可以应用类似的贪心策略，如通过枚举某个目标值，结合贪心算法求解最小花费或最大收益。

【推荐题目】
1. [CF1019A Elections](https://www.luogu.com.cn/problem/CF1019A)
2. [CF457C Elections](https://www.luogu.com.cn/problem/CF457C)
3. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)

---
处理用时：45.41秒
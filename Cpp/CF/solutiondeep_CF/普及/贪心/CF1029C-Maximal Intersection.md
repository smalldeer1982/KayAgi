# 题目信息

# Maximal Intersection

## 题目描述

给定n个闭区间,现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

## 样例 #1

### 输入

```
4
1 3
2 6
0 4
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
2 6
1 3
0 4
1 20
0 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
4 5
1 2
9 20
```

### 输出

```
0
```

## 样例 #4

### 输入

```
2
3 10
1 5
```

### 输出

```
7
```

# AI分析结果

### 题目内容重写
给定n个闭区间，现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

### 题解综合分析
本题的核心在于如何在删除一个区间后，快速计算剩余区间的交集长度。多个题解提供了不同的思路，主要包括：
1. **前缀和后缀交集法**：通过预处理前缀和后缀的交集，快速计算删除每个区间后的交集长度。
2. **暴力枚举法**：直接枚举每个区间，计算删除后的交集长度。
3. **优先队列法**：利用优先队列维护区间的左右端点，快速找到删除后的最大交集。

### 所选高星题解

#### 题解1：CreeperK (4星)
**关键亮点**：
- 使用前缀和后缀交集数组，避免了重复计算。
- 通过三次扫描数组，巧妙解决了问题。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    lpl[i]=max(lpl[i-1],l[i]);
    lpr[i]=min(lpr[i-1],r[i]);
}
for(int i=n;i>=1;i--){
    rpl[i]=max(rpl[i+1],l[i]);
    rpr[i]=min(rpr[i+1],r[i]);
}
int maxn=0;
for(int i=1;i<=n;i++){
    maxn=max(min(lpr[i-1],rpr[i+1])-max(lpl[i-1],rpl[i+1]),maxn);
}
```
**实现思想**：通过预处理前缀和后缀的交集，快速计算删除每个区间后的交集长度。

#### 题解2：Mickey_snow (4星)
**关键亮点**：
- 使用结构体存储区间，简化了代码。
- 通过合并区间的方式，避免了重复计算。

**核心代码**：
```cpp
cg Range(cg a, cg b) {
    cg ret;
    ret.fr = std::max(a.fr, b.fr); ret.to = std::min(a.to, b.to);
    return ret;
}
```
**实现思想**：通过合并区间的方式，快速计算删除每个区间后的交集长度。

#### 题解3：BLUESKY007 (4星)
**关键亮点**：
- 使用优先队列维护区间的左右端点，快速找到删除后的最大交集。
- 通过讨论删除区间的情况，简化了问题。

**核心代码**：
```cpp
priority_queue<lborder>ql;priority_queue<rborder>qr;
ql.push(lb);
qr.push(rb);
if(ql.top().id==qr.top().id){
    ql.pop();
    qr.pop();
    printf("%d\n",max(0,qr.top().x-ql.top().x));
    return 0;
}
```
**实现思想**：通过优先队列维护区间的左右端点，快速找到删除后的最大交集。

### 最优关键思路
**前缀和后缀交集法**是最优的解决方案，通过预处理前缀和后缀的交集，可以快速计算删除每个区间后的交集长度，时间复杂度为O(n)，空间复杂度为O(n)。

### 可拓展之处
类似的问题可以通过预处理前缀和后缀的方式来解决，例如在计算最大公约数、最小公倍数等问题时，也可以使用类似的方法。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录
CreeperK提到：“插入，往往比删除容易。”这句话在解决类似问题时非常有用，通过预处理和避免直接删除操作，可以简化问题的复杂度。

---
处理用时：27.70秒
# 题目信息

# Vova and Trophies

## 题目描述

你现在有 $n$ 枚奖牌，每枚奖牌为金牌或银牌。这些奖牌现在按顺序排成一排。现在你可以调换任意一对奖牌的位置，求金牌最长连续段。

## 样例 #1

### 输入

```
10
GGGSGGGSGG
```

### 输出

```
7
```

## 样例 #2

### 输入

```
4
GGGG
```

### 输出

```
4
```

## 样例 #3

### 输入

```
3
SSS
```

### 输出

```
0
```

# AI分析结果

### 题目内容重写

你现在有 $n$ 枚奖牌，每枚奖牌为金牌或银牌。这些奖牌现在按顺序排成一排。现在你可以调换任意一对奖牌的位置，求金牌最长连续段。

### 样例 #1

#### 输入

```
10
GGGSGGGSGG
```

#### 输出

```
7
```

### 样例 #2

#### 输入

```
4
GGGG
```

#### 输出

```
4
```

### 样例 #3

#### 输入

```
3
SSS
```

#### 输出

```
0
```

### 题解综合分析与结论

本题的核心在于通过一次交换操作，最大化金牌的连续段长度。各题解的主要思路包括预处理连续金牌段、枚举可能的交换位置、以及分类讨论不同情况。以下是对各题解的简要分析与评分：

1. **Sakura_梦瑶**（3星）：通过预处理连续金牌段，并在段数小于等于2时进行特殊判断。代码较为简洁，但边界情况处理不够全面。
2. **Ousmane_Dembele**（3星）：预处理连续金牌段，并通过标记数组处理可能的交换位置。思路清晰，但代码复杂度较高。
3. **Dilute**（4星）：通过预处理连续金牌段，并分类讨论不同情况，特别是对两段金牌之间的间隔进行了详细处理。代码结构清晰，逻辑严谨。
4. **Jsxts_**（4星）：预处理连续金牌段，并通过枚举相邻段的最大值来求解。代码简洁，逻辑清晰，且对边界情况处理较好。
5. **Indigo_Boy**（3星）：使用单调队列的思想，通过前缀和数组处理连续金牌段。思路新颖，但代码实现较为复杂。
6. **vocaloid**（3星）：通过预处理连续金牌段，并枚举每个单独的银牌进行交换。思路清晰，但代码复杂度较高。
7. **little_sun**（3星）：预处理连续金牌段，并通过枚举每个银牌进行交换。思路清晰，但代码实现较为复杂。
8. **Zechariah**（3星）：通过预处理连续金牌段，并分类讨论不同情况。思路清晰，但代码实现较为复杂。
9. **Ninelife_Cat**（4星）：使用双指针和前缀和数组处理连续金牌段，并通过分类讨论不同情况。代码简洁，逻辑清晰，且对边界情况处理较好。

### 所选高星题解

#### 1. **Dilute**（4星）

**关键亮点**：通过预处理连续金牌段，并分类讨论不同情况，特别是对两段金牌之间的间隔进行了详细处理。代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int l[100010];
int gap[100010];
char s[100010];

int main(){
    int n = inp();
    scanf("%s", s + 1);
    int cnt = 0;
    int cc = n;
    for(int i = 1; i <= n; i++){
        if(s[i] == 'S'){
            gap[cnt]++;
            cc--;
            continue;
        }
        if(s[i - 1] == 'G')
            l[cnt]++;
        else
            l[++cnt] = 1;
    }
    if(cnt == 0){
        printf("0");
    } else if(cnt == 1){
        printf("%d", l[1]);
    } else if(cnt == 2){
        int ans = std::max(l[1] + 1, l[2] + 1);
        if(gap[1] == 1)
            ans = l[1] + l[2];
        printf("%d", ans);
    } else {
        int ans = 0;
        for(int i = 1; i <= n; i++)
            ans = std::max(ans, l[i] + 1);
        for(int i = 1; i < n; i++)
            if(gap[i] == 1)
                ans = std::max(ans, l[i] + l[i + 1] + 1);
        printf("%d", ans);
    }
}
```

#### 2. **Jsxts_**（4星）

**关键亮点**：预处理连续金牌段，并通过枚举相邻段的最大值来求解。代码简洁，逻辑清晰，且对边界情况处理较好。

**核心代码**：
```cpp
int a[100010],tot;
int main() {
    int n;
    string s;
    cin >> n >> s;
    s = '0' + s;
    int c = 0,cnt = 0;
    for (int i = 1;i <= n;i ++ ) {
        if (s[i] != 'S') c ++;
        else {
            a[++tot] = c,c = 0;
            if (a[tot]) cnt ++;
        }
    }
    a[++tot] = c;
    if (a[tot]) cnt ++;
    if (cnt == 0) printf("0"),exit(0);
    if (cnt == 1) {
        for (int i = 1;i <= tot;i ++ ) if (a[i]) printf("%d",a[i]),exit(0);
    }
    if (cnt == 2) {
        int mx = 0;
        for (int i = 1;i <= tot;i ++ ) {
            if (a[i] && a[i+1]) {
                printf("%d",a[i]+a[i+1]);
                exit(0);
            }
            mx = max(mx,a[i]);
        }
        printf("%d",mx+1);
        exit(0);
    }
    int mx = 0;
    for (int i = 1;i < tot;i ++ ) {
        mx = max(mx,a[i]+a[i+1] + 1);
    }
    printf("%d",mx);
    return 0;
}
```

#### 3. **Ninelife_Cat**（4星）

**关键亮点**：使用双指针和前缀和数组处理连续金牌段，并通过分类讨论不同情况。代码简洁，逻辑清晰，且对边界情况处理较好。

**核心代码**：
```cpp
const int N=2e5+10;
int n,s[N],ans;
char a[N];
signed main()
{
    cin>>n>>a+1;
    for(ri int i=1;i<=n;++i)
        s[i]=s[i-1]+(a[i]=='G');
    ri int l=1,r=1;
    while(r<=n)
    {
        while(s[r]-s[l-1]+1<r-l+1) ++l;
        if(s[r]-s[l-1]+1==r-l+1&&s[n]-s[r]+s[l-1]-s[0])
            ans=max(ans,r-l+1);
        else if(s[r]-s[l-1]==r-l+1) ans=max(ans,r-l+1);
        ++r;
    }
    cout<<ans;
    return 0;
}
```

### 最优关键思路或技巧

1. **预处理连续段**：通过预处理连续金牌段，可以快速计算每个段的金牌数量，便于后续操作。
2. **分类讨论**：根据连续金牌段的数量和位置，分类讨论不同情况，确保所有边界情况都被覆盖。
3. **双指针与前缀和**：使用双指针和前缀和数组可以高效地处理连续段，减少时间复杂度。

### 可拓展之处

本题的思路可以拓展到其他类似的字符串处理问题，如最长连续字符段、最大子数组和等。通过预处理和分类讨论，可以解决更多复杂的字符串问题。

### 推荐相似题目

1. **洛谷 P1047**：最长连续字符段
2. **洛谷 P1115**：最大子数组和
3. **洛谷 P1090**：合并果子

### 个人心得摘录

- **Dilute**：在处理两段金牌之间的间隔时，特别需要注意是否有多余的金牌可以用于交换，否则会导致错误。
- **Jsxts_**：在预处理连续金牌段时，需要特别注意最后一段的处理，否则会导致遗漏。
- **Ninelife_Cat**：使用双指针和前缀和数组时，需要确保指针的移动逻辑正确，否则会导致计算错误。

---
处理用时：57.62秒
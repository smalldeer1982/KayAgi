# 题目信息

# Decrease the Sum of Digits

## 题目描述

You are given a positive integer $ n $ . In one move, you can increase $ n $ by one (i.e. make $ n := n + 1 $ ). Your task is to find the minimum number of moves you need to perform in order to make the sum of digits of $ n $ be less than or equal to $ s $ .

You have to answer $ t $ independent test cases.

## 样例 #1

### 输入

```
5
2 1
1 1
500 4
217871987498122 10
100000000000000001 1```

### 输出

```
8
0
500
2128012501878
899999999999999999```

# AI分析结果

### 题目内容重写

#### 题目描述
给定一个正整数 $n$。每次操作可以将 $n$ 增加 1（即 $n := n + 1$）。你的任务是找到使 $n$ 的各位数字之和小于或等于 $s$ 所需的最少操作次数。

你需要回答 $t$ 个独立的测试用例。

#### 样例 #1

##### 输入
```
5
2 1
1 1
500 4
217871987498122 10
100000000000000001 1
```

##### 输出
```
8
0
500
2128012501878
899999999999999999
```

---

### 题解分析与结论

#### 综合分析
本题的核心思想是通过进位操作来减少数字的各位之和。由于直接暴力枚举 $n$ 的增加次数在 $n$ 较大时不可行，因此需要通过贪心策略，从低位到高位进行进位操作，直到满足条件。

#### 最优思路总结
1. **贪心策略**：从低位到高位逐位进位，每次进位都尽可能减少数字的各位之和。
2. **进位操作**：通过将某一位及其后的所有位变为 0，并在前一位加 1，来减少数字的各位之和。
3. **优化计算**：通过预处理 10 的幂次方，避免重复计算，提升效率。

#### 推荐题解
以下题解思路清晰，代码可读性高，且优化程度较好，评分较高。

---

### 题解1：江户川·萝卜 (4星)

#### 关键亮点
- **思路清晰**：从低位到高位逐位进位，解释合理。
- **代码简洁**：通过循环和取模操作实现进位，代码可读性高。
- **优化**：使用 `unsigned long long` 处理大数，避免溢出。

#### 核心代码
```cpp
for(unsigned long long res=1;tot>s&&res<n;res*=10){
    int c=n/res%10;
    if(c==0) continue;
    ans+=(10-c)*res;
    n+=(10-c)*res;
    tot=0;
    r=n;
    while(r){
        tot+=r%10;
        r/=10;
    }
}
```

#### 代码实现思想
从最低位开始，逐位进位，直到数字的各位之和小于等于 $s$。每次进位后重新计算数字的各位之和。

---

### 题解2：三点水一个各 (4星)

#### 关键亮点
- **思路明确**：通过枚举进位位，找到最小的满足条件的数。
- **代码优化**：预处理 10 的幂次方，避免重复计算。
- **特判处理**：考虑了需要再开一位的情况，代码鲁棒性强。

#### 核心代码
```cpp
for(ll p10=10;p10/10<=N;p10*=10){
    t=N-N%p10+p10;
    sum=calc(t);
    if(sum<=s) {printf("%lld\n",t-N);break;}
}
```

#### 代码实现思想
枚举从最低位到最高位的进位位，计算进位后的数，并检查其各位之和是否满足条件。

---

### 题解3：SSerxhs (4星)

#### 关键亮点
- **思路简洁**：通过枚举 $k$，找到最小的满足条件的数。
- **代码高效**：使用 `unsigned long long` 处理大数，避免溢出。
- **优化**：通过预处理 10 的幂次方，提升计算效率。

#### 核心代码
```cpp
for(ll i=j=1;j<=n;i++,j*=10){
    tot-=n/j%10-(i==1);
    if(tot<=s){
        j*=10;
        printf("%lld\n",ll((n/j+1)*j-n));
        break;
    }
}
```

#### 代码实现思想
从最低位开始，逐位进位，直到数字的各位之和小于等于 $s$。每次进位后重新计算数字的各位之和。

---

### 推荐题目
1. **P1003 铺地毯**：考察贪心策略和模拟操作。
2. **P1012 拼数**：涉及数字处理和贪心算法。
3. **P1020 导弹拦截**：动态规划与贪心结合，考察最优解问题。

---
处理用时：34.66秒
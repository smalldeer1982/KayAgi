# 题目信息

# Save More Mice

## 题目描述

坐标轴上有一只猫，$k$ 只老鼠和一个洞口。其中猫在坐标为 $0$ 的位置，洞口在坐标为 $n$ 的位置，所有的老鼠都在猫和洞口之间，其中第 $i$ 只老鼠在 $x_i$ 的位置。可能有多只老鼠在同一个位置上。

在每一秒钟，将会**依次**执行以下行动：

- **其中一只**老鼠会向右移动 $1$ 的位置，如果一个老鼠到达洞口，它会隐藏起来（这只老鼠将不会再移动到任何位置，也不会被猫吃掉）。
- 猫会向右移动 $1$ 的位置，并会吃掉它到达的位置上的老鼠（被吃掉的老鼠将不能再移动）。

直到所有的老鼠都已经隐藏起来或已经被吃掉。

每一秒钟，你都可以选择移动的老鼠，请你求出最多可以保护多少只老鼠安全到达洞口并隐藏起来。

## 说明/提示

- $1 \le t \le 10^4$；
- $2 \le n \le 10^9$；
- $1 \le k \le 4 \times 10^5$；
- $1 \le x_i <n$。

Translated by @BurningEnderDragon, 2021.10.14

## 样例 #1

### 输入

```
3
10 6
8 7 5 4 9 4
2 8
1 1 1 1 1 1 1 1
12 11
1 2 3 4 5 6 7 8 9 10 11```

### 输出

```
3
1
4```

# AI分析结果

### 题目内容重写

#### 拯救更多老鼠

**题目描述**

在坐标轴上有一只猫，$k$ 只老鼠和一个洞口。其中猫位于坐标为 $0$ 的位置，洞口位于坐标为 $n$ 的位置，所有的老鼠都位于猫和洞口之间，第 $i$ 只老鼠位于 $x_i$ 的位置。可能有多只老鼠位于同一个位置。

每一秒钟，将会**依次**执行以下行动：

- **其中一只**老鼠会向右移动 $1$ 的位置，如果一只老鼠到达洞口，它会隐藏起来（这只老鼠将不会再移动到任何位置，也不会被猫吃掉）。
- 猫会向右移动 $1$ 的位置，并会吃掉它到达的位置上的老鼠（被吃掉的老鼠将不能再移动）。

直到所有的老鼠都已经隐藏起来或已经被吃掉。

每一秒钟，你都可以选择移动的老鼠，请你求出最多可以保护多少只老鼠安全到达洞口并隐藏起来。

**说明/提示**

- $1 \le t \le 10^4$；
- $2 \le n \le 10^9$；
- $1 \le k \le 4 \times 10^5$；
- $1 \le x_i <n$。

**样例 #1**

**输入**

```
3
10 6
8 7 5 4 9 4
2 8
1 1 1 1 1 1 1 1
12 11
1 2 3 4 5 6 7 8 9 10 11
```

**输出**

```
3
1
4
```

### 题解综合分析与结论

所有题解都采用了贪心算法，核心思路是优先移动离洞口最近的老鼠。这种策略能够最大化被保护的老鼠数量，因为离洞口越近的老鼠需要的步数越少，猫在追赶这些老鼠时不会影响到其他老鼠。

### 所选高星题解

#### 题解1：作者：Forever1507 (4星)

**关键亮点：**
- 简洁明了地阐述了贪心策略，优先移动离洞口最近的老鼠。
- 代码实现清晰，排序后模拟猫和老鼠的移动过程。

**核心代码：**
```cpp
sort(a+1,a+k+1);
int cat=0,point=k,cnt=0;
while(a[point]>cat){
    cat+=(n-a[point]);
    point--;
    cnt++;
}
cout<<cnt<<'\n';
```

#### 题解2：作者：rhyyy1 (4星)

**关键亮点：**
- 详细解释了贪心策略的合理性，强调了老鼠移动和猫移动的同步性。
- 代码中通过累加步数来判断是否能够保护更多老鼠。

**核心代码：**
```cpp
sort(a+1,a+m+1);
long long sum=0;
for(int i=1;i<=m;i++){
    sum+=a[i];
    if(sum==n-1){
        printf("%d\n",i);
        return ;
    }else if(sum>=n){
        printf("%d\n",i-1);
        return ;
    }
}
printf("%d\n",m);
```

#### 题解3：作者：fls233666 (4星)

**关键亮点：**
- 详细分析了贪心策略的合理性，解释了为什么优先移动离洞口近的老鼠更优。
- 代码实现清晰，通过维护猫的位置来判断老鼠是否被吃掉。

**核心代码：**
```cpp
sort(xi+1,xi+1+nk);
for(rgt d,i=nk;i>=1;i--){
    if(cat>=xi[i])
        break;
    d=n-xi[i];
    cat+=d;
    ans++;
}
printf("%d\n",ans);
```

### 最优关键思路与技巧

1. **贪心策略**：优先移动离洞口最近的老鼠，这样可以最小化猫在追赶过程中吃掉其他老鼠的数量。
2. **排序**：将所有老鼠按离洞口的距离排序，便于按顺序处理。
3. **模拟过程**：通过模拟猫和老鼠的移动过程，计算能够保护的老鼠数量。

### 可拓展之处

- **类似问题**：可以扩展到其他类似的贪心问题，如任务调度、资源分配等。
- **优化**：对于更大的数据规模，可以考虑更高效的排序算法或优化模拟过程。

### 推荐题目

1. **洛谷 P1090**：合并果子，考察贪心算法。
2. **洛谷 P1223**：排队接水，考察贪心策略。
3. **洛谷 P1803**：线段覆盖，考察贪心算法。

### 个人心得摘录

- **调试经历**：在实现过程中，需要注意猫和老鼠的移动步数的同步性，避免逻辑错误。
- **顿悟感想**：贪心策略的选择往往能够简化问题，关键在于找到最优的局部选择。

---
处理用时：38.74秒
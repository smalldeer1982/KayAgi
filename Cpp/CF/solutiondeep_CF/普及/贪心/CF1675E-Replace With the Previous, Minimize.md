# 题目信息

# Replace With the Previous, Minimize

## 题目描述

### 题意简述

有一个长度为 $n$ 的，只含小写字母的字符串 $s$，每次操作可以选择 $26$ 个字母之一，将字符串中所有该字母替换为上一个字母（如 $\texttt{c}\to\texttt{b},\texttt{b}\to\texttt{a}$，特殊地，$\texttt{a}\to\texttt{z}$）。在 $k$ 次操作**之内**，使得到的字符串的字典序最小。

## 样例 #1

### 输入

```
4
3 2
cba
4 5
fgde
7 5
gndcafb
4 19
ekyv```

### 输出

```
aaa
agaa
bnbbabb
aapp```

# AI分析结果

### 题目内容重写
**题目描述**

有一个长度为 $n$ 的，只含小写字母的字符串 $s$，每次操作可以选择 $26$ 个字母之一，将字符串中所有该字母替换为上一个字母（如 $\texttt{c}\to\texttt{b},\texttt{b}\to\texttt{a}$，特殊地，$\texttt{a}\to\texttt{z}$）。在 $k$ 次操作**之内**，使得到的字符串的字典序最小。

**样例 #1**

输入：
```
4
3 2
cba
4 5
fgde
7 5
gndcafb
4 19
ekyv
```

输出：
```
aaa
agaa
bnbbabb
aapp
```

### 题解分析与结论

#### 题解对比与评分

1. **FFTotoro (★★★★☆)**
   - **关键亮点**：使用贪心算法，从前往后扫描字符串，找到字符可以降到的下限，暴力更新每个字符，最后将未完全更新的字符变为 'a'。
   - **代码实现**：通过双重循环暴力更新字符，时间复杂度较高，但思路清晰。
   - **个人心得**：无。

2. **caibet (★★★★☆)**
   - **关键亮点**：使用贪心策略，记录之前选中过的字典序最大的字母，确保在 $k$ 次操作内将字符降到最低。
   - **代码实现**：通过记录 `last` 变量，优化了字符更新过程，减少了不必要的操作。
   - **个人心得**：通过记录 `last` 变量，避免了重复操作，提高了效率。

3. **Hooch (★★★☆☆)**
   - **关键亮点**：优先将前面的字符变为 'a'，最大化前 $i$ 个字符为 'a' 的数量。
   - **代码实现**：通过遍历字符串，找到第一个无法变为 'a' 的字符，然后处理剩余字符。
   - **个人心得**：无。

#### 最优关键思路与技巧

- **贪心策略**：从前往后扫描字符串，优先将前面的字符变为 'a'，确保字典序最小。
- **记录变量**：记录之前选中过的字典序最大的字母，避免重复操作，优化更新过程。
- **暴力更新**：在 $k$ 次操作内，暴力更新字符，确保字符降到最低。

#### 可拓展之处

- **类似题目**：可以扩展到其他需要最小化或最大化字典序的字符串操作问题。
- **算法套路**：贪心算法在处理字典序问题时非常有效，可以应用于其他类似问题。

#### 推荐题目

1. **P1090 [NOIP2004 提高组] 合并果子**（贪心算法）
2. **P1048 [NOIP2005 提高组] 采药**（动态规划）
3. **P1060 [NOIP2006 提高组] 开心的金明**（动态规划）

### 所选高分题解

#### FFTotoro (★★★★☆)

**关键亮点**：使用贪心算法，从前往后扫描字符串，找到字符可以降到的下限，暴力更新每个字符，最后将未完全更新的字符变为 'a'。

**核心代码**：
```cpp
for(int i=0;i<n;i++)
  if(s[i]>c){ // 只有更大才有意义继续更新
    if(s[i]-97>k){
      k-=c-97; int mn=s[i]-k; // 找到最低可以降到多少
      for(char h=s[i];h>mn;h--)
        for(int j=0;j<n;j++)
          if(s[j]==h)s[j]=h-1; // 暴力地扫一遍，如果可以降那么就更新
      break;
    }
    else if(c<s[i])c=s[i]; // 更新最低的值，以便最后的更改
  }
for(int i=0;i<n;i++)
  if(s[i]<=c)s[i]='a'; // 更新成 'a'
```

#### caibet (★★★★☆)

**关键亮点**：使用贪心策略，记录之前选中过的字典序最大的字母，确保在 $k$ 次操作内将字符降到最低。

**核心代码**：
```cpp
F(i,1,<=n){
  if(a[i]<=last) a[i]='a';
  else if(a[i]-last>=k){
    F(j,1,<=n){
      if(i!=j&&a[j]>a[i]-k&&a[j]<=a[i]){
        a[j]=a[i]-k;
      }
      if(a[j]<=last){
        a[j]='a';
      }
    }
    a[i]-=k;
    if(a[i]<=last) a[i]='a';
    break;
  }else{
    k-=a[i]-last;
    last=a[i];
    a[i]='a';
  }
}
```

---
处理用时：39.33秒
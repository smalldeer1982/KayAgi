# 题目信息

# Binary String

## 题目描述

你有一个由 $1$ 和 $0$ 构成的字符串 $s$。

你需要先从 $s$ 的开头移除若干字符，然后从 $s$ 的结尾移除若干字符。（当然，你可以不移除任何字符，也可以将整个 $s$ 移除掉）

这样做的代价是从 $s$ 中移除的 $1$ 的个数和 $s$ 中剩余的 $0$ 的个数的最大值。

求代价的最小值。

## 说明/提示

样例解释：

`101110110` -> `(10) 111011 (0)`

`1001001001001` -> `(100100) 1001 (001)`

`0000111111` -> `(0000) 111111 ()`

`00000` -> `(00000)()`

`1111` -> `()1111()`

## 样例 #1

### 输入

```
5
101110110
1001001001001
0000111111
00000
1111```

### 输出

```
1
3
0
0
0```

# AI分析结果

### 题目内容重写
你有一个由 $1$ 和 $0$ 构成的字符串 $s$。

你需要先从 $s$ 的开头移除若干字符，然后从 $s$ 的结尾移除若干字符。（当然，你可以不移除任何字符，也可以将整个 $s$ 移除掉）

这样做的代价是从 $s$ 中移除的 $1$ 的个数和 $s$ 中剩余的 $0$ 的个数的最大值。

求代价的最小值。

### 题解分析与结论
本题的核心在于如何高效地计算从字符串开头和结尾删除字符后的最小代价。题解中提供了多种思路，包括线性扫描、二分查找、滑动窗口等。其中，线性扫描和滑动窗口的方法较为高效，且代码实现简洁。

### 精选题解
#### 1. 作者：断清秋 (赞：20)
- **星级**：★★★★★
- **关键亮点**：线性时间复杂度，利用前缀和和后缀和优化计算，思路清晰，代码简洁。
- **核心思想**：通过预处理前缀和后缀的 $0$ 和 $1$ 的数量，枚举开头删除的字符数，快速计算结尾删除的字符数，从而得到最小代价。
- **代码片段**：
```cpp
int cnt0 = z[l];
int ans = 2000000000; //设为极大值
for (int i = 0; i <= cnt0; i++) {
    int tmp = l - (cnt0 - i);
    int maxn = o[i] + o[l] - o[tmp];
    ans = min(ans, maxn);
}
if (ans == 2000000000) cout << "0" << endl;
else cout << ans << endl;
```

#### 2. 作者：灵茶山艾府 (赞：5)
- **星级**：★★★★
- **关键亮点**：滑动窗口结合二分查找，时间复杂度为 $O(n\log n)$，思路巧妙。
- **核心思想**：通过滑动窗口维护窗口内的 $0$ 的数量，结合二分查找确定最小代价。
- **代码片段**：
```go
ans := len(s)
in0 := 0
out1 := strings.Count(s, "1")
left := 0
for _, b := range s {
    v := int(b & 1)
    in0 += v ^ 1
    out1 -= v
    for in0 > out1 { // 0 多就缩小窗口
        v = int(s[left] & 1)
        in0 -= v ^ 1
        out1 += v
        left++
    }
    ans = min(ans, out1) // in0 <= out1
}
Println(ans)
```

#### 3. 作者：Henry_C (赞：2)
- **星级**：★★★★
- **关键亮点**：双指针法维护滑动窗口，时间复杂度为 $O(n)$，代码实现简洁。
- **核心思想**：通过双指针维护窗口内的 $0$ 和 $1$ 的数量，动态调整窗口大小以最小化代价。
- **代码片段**：
```cpp
int ans = max(out1, inner0);
for(int i=cnt1; i<n; i++){//滑动窗前沿
    if (s[i] == '0') inner0++;
    else out1--;

    if (s[i-cnt1] == '0') inner0--;
    else out1++;

    ans = min(ans, max(out1, inner0));
}
cout<<ans<<endl;
```

### 最优关键思路
1. **前缀和与后缀和优化**：通过预处理前缀和后缀的 $0$ 和 $1$ 的数量，可以快速计算任意删除方案后的代价。
2. **滑动窗口**：通过滑动窗口动态维护窗口内的 $0$ 和 $1$ 的数量，结合双指针或二分查找，可以高效地找到最小代价。

### 拓展思路
类似的问题可以通过滑动窗口、前缀和、二分查找等方法来优化时间复杂度。例如，求字符串中满足某种条件的最短子串，或者求数组中满足某种条件的最短子数组。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1638 访问艺术馆](https://www.luogu.com.cn/problem/P1638)
3. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)

### 个人心得
在实现滑动窗口时，注意窗口的边界条件和更新方式，避免遗漏或重复计算。通过预处理前缀和后缀和，可以大大减少计算量，提高代码效率。

---
处理用时：37.42秒
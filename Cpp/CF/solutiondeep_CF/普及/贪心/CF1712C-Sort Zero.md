# 题目信息

# Sort Zero

## 题目描述

An array is sorted if it has no inversions

A Young Boy



You are given an array of $ n $ positive integers $ a_1,a_2,\ldots,a_n $ .

In one operation you do the following:

1. Choose any integer $ x $ .
2. For all $ i $ such that $ a_i = x $ , do $ a_i := 0 $ (assign $ 0 $ to $ a_i $ ).

Find the minimum number of operations required to sort the array in non-decreasing order.

## 说明/提示

In the first test case, you can choose $ x = 3 $ for the operation, the resulting array is $ [0, 0, 2] $ .

In the second test case, you can choose $ x = 1 $ for the first operation and $ x = 3 $ for the second operation, the resulting array is $ [0, 0, 0, 0] $ .

## 样例 #1

### 输入

```
5
3
3 3 2
4
1 3 1 3
5
4 1 5 3 2
4
2 4 1 2
1
1```

### 输出

```
1
2
4
3
0```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个包含 $n$ 个正整数的数组 $a_1, a_2, \ldots, a_n$。每次操作可以选择一个整数 $x$，并将数组中所有等于 $x$ 的元素置为 $0$。求将数组排序为**非递减序列**所需的最小操作次数。

#### 说明/提示

在第一个测试用例中，可以选择 $x = 3$ 进行操作，结果数组为 $[0, 0, 2]$。

在第二个测试用例中，可以选择 $x = 1$ 进行第一次操作，$x = 3$ 进行第二次操作，结果数组为 $[0, 0, 0, 0]$。

#### 样例

**输入：**
```
5
3
3 3 2
4
1 3 1 3
5
4 1 5 3 2
4
2 4 1 2
1
1
```

**输出：**
```
1
2
4
3
0
```

---

### 题解分析与结论

#### 综合分析与结论

本题的核心思路是通过选择某些元素置为 $0$，使得整个数组最终变为非递减序列。大多数题解都采用了从后向前遍历数组的策略，找到第一个不满足非递减条件的位置，并将该位置及其之前的所有元素置为 $0$。由于每次操作会将所有等于某个值的元素置为 $0$，因此需要特别注意“连锁反应”问题，即某些元素的置零操作可能会影响到后续的元素。

#### 最优关键思路

1. **从后向前遍历**：通过从后向前遍历数组，可以快速找到第一个不满足非递减条件的位置，从而确定需要置零的范围。
2. **记录元素最后出现的位置**：通过记录每个元素最后出现的位置，可以确保在置零操作时，所有等于该值的元素都被正确处理。
3. **动态更新置零范围**：在置零操作中，动态更新需要置零的范围，确保所有受影响的元素都被置零。

#### 可拓展之处

本题的思路可以拓展到其他需要处理“连锁反应”或“范围操作”的问题，例如在某些情况下需要对数组中的某些元素进行批量修改，且这些修改可能会影响到其他元素。

#### 推荐题目

1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

---

### 精选题解

#### 题解1：作者：LKY928261 (赞：10)

**评分：5星**

**关键亮点：**
- 通过从后向前遍历数组，找到第一个不满足非递减条件的位置。
- 使用 `nxt` 数组记录每个元素最后出现的位置，确保在置零操作时所有等于该值的元素都被处理。
- 动态更新需要置零的范围，确保所有受影响的元素都被置零。

**核心代码：**
```cpp
for(i=n;i>1;i--)if(a[i]<a[i-1])break; // 找第一个不满足单调性的数
t=i-1;ans=0;
for(i=1;i<=t;i++){ // 从头开始枚举
    ans+=(!f[a[i]]); // 若没有标记过则操作次数+1
    f[a[i]]=1; // 添加标记
    t=max(t,nxt[a[i]]); // 更新枚举次数
}
```

#### 题解2：作者：YYHDoggy (赞：0)

**评分：4星**

**关键亮点：**
- 通过从后向前遍历数组，找到第一个不满足非递减条件的位置，并记录需要置零的范围。
- 使用 `lst` 数组记录每个元素最后出现的位置，确保在置零操作时所有等于该值的元素都被处理。

**核心代码：**
```cpp
int del=0,pre=10000007;
for(int i=n;i>=1;i--){
    if(a[i]>pre){
        del=max(del,lst[a[i]]);
    }
    else{
        pre=a[i];
    }
}
```

#### 题解3：作者：fast_photon (赞：0)

**评分：4星**

**关键亮点：**
- 通过从后向前遍历数组，找到第一个不满足非递减条件的位置，并记录需要置零的范围。
- 使用 `vector` 记录每个元素的所有出现位置，确保在置零操作时所有等于该值的元素都被处理。

**核心代码：**
```cpp
for(int i = n; i >= 1; i--) {
    for(int j : g[i]) {
        if((a[j] > a[j + 1] || z[a[j + 1]] == 1) && j != n - 1) {
            z[i] = true;
            ans++;
            break;
        }
    } 
}
```

---

### 个人心得总结

在解决本题时，许多作者都提到了“连锁反应”问题，即某些元素的置零操作可能会影响到后续的元素。通过从后向前遍历数组，可以快速找到第一个不满足非递减条件的位置，并通过记录每个元素最后出现的位置，确保在置零操作时所有等于该值的元素都被正确处理。此外，动态更新需要置零的范围，确保所有受影响的元素都被置零，这也是解决本题的关键技巧之一。

---
处理用时：40.48秒
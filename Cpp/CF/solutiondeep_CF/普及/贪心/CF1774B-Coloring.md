# 题目信息

# Coloring

## 题目描述

Cirno_9baka 的纸条上有 $n$ 个格子，他觉得空白的纸条看着有点无趣，于是想在纸条的格子上涂上 $m$ 种颜色。同时，他认为第 $i$ 种颜色必须要用 $a_i$ 次，且每连续 $k$ 个格子里涂的颜色必须互不相同。

Cirno_9baka 想知道有没有这样的一种涂色方案能符合他的要求。

## 说明/提示

第一个测试用例中，没有任何涂色的方案满足所有要求。

第二个测试用例中，可以将纸条涂成$(1,2,1,2,3,4,3,4,5,6,5,6)$，对于每两个连续的格子，颜色都是互不相同的。

## 样例 #1

### 输入

```
2
12 6 2
1 1 1 1 1 7
12 6 2
2 2 2 2 2 2```

### 输出

```
NO
YES```

# AI分析结果

### 题目内容重写
Cirno_9baka 的纸条上有 $n$ 个格子，他觉得空白的纸条看着有点无趣，于是想在纸条的格子上涂上 $m$ 种颜色。同时，他认为第 $i$ 种颜色必须要用 $a_i$ 次，且每连续 $k$ 个格子里涂的颜色必须互不相同。

Cirno_9baka 想知道有没有这样的一种涂色方案能符合他的要求。

### 样例 #1
#### 输入
```
2
12 6 2
1 1 1 1 1 7
12 6 2
2 2 2 2 2 2
```
#### 输出
```
NO
YES
```

### 题解分析与结论
这道题的核心在于如何判断给定的颜色使用次数是否能满足每连续 $k$ 个格子颜色互不相同的条件。大部分题解都基于**抽屉原理**（鸽巢原理）来解决这个问题，通过计算每个颜色最多能使用的次数，并判断是否有颜色超过这个限制。

#### 关键思路总结：
1. **抽屉原理的应用**：将纸条分成 $\lceil \frac{n}{k} \rceil$ 段，每段最多能容纳一个颜色的使用次数。如果某个颜色的使用次数超过这个段数，则无法满足条件。
2. **特殊情况处理**：当 $n$ 不能被 $k$ 整除时，最后一段的长度为 $n \bmod k$。需要特别处理那些使用次数等于 $\lceil \frac{n}{k} \rceil$ 的颜色，确保它们的数量不超过最后一段的长度。
3. **时间复杂度**：所有题解的时间复杂度均为 $O(m)$，因为只需要遍历一次颜色使用次数数组。

### 高星题解推荐
#### 题解1：作者：xiaoqian02 (赞：13)
- **星级**：★★★★★
- **关键亮点**：详细解释了抽屉原理的应用，并通过代码实现了对颜色使用次数的判断。特别处理了 $n$ 不能被 $k$ 整除的情况，确保算法的正确性。
- **代码核心思想**：
  ```cpp
  int p = n / k;
  int nm = n - p * k;
  bool b = 1;
  for (int i = 1; i <= m; i++) {
      cin >> x;
      if (x > p + 1) b = 0;
      if (x == p + 1) nm--;
      if (nm < 0) b = 0;
  }
  if (!b) cout << "NO" << endl;
  else cout << "YES" << endl;
  ```
- **个人心得**：作者提到在测试时发现直接使用 $\lceil \frac{n}{k} \rceil$ 会导致某些情况无法正确处理，因此引入了 `nm` 变量来统计最大值个数，确保算法的鲁棒性。

#### 题解2：作者：srds_cbddl (赞：9)
- **星级**：★★★★☆
- **关键亮点**：通过分段处理，分别考虑了 $n$ 能被 $k$ 整除和不能整除的情况，代码简洁且易于理解。
- **代码核心思想**：
  ```cpp
  if (n % k == 0) {
      rep (i, 0, m) {
          if (a[i] > (n / k)) {
              cout << "NO\n";
              return ;
          }
      }
  }
  int ans = 0;
  bool flag = true;
  rep (i, 0, m) {
      if (a[i] - 1 == n / k) ans++;
      if (a[i] >= n / k) {
          flag = false;
          break;
      }
  }
  if (!flag) {
      cout << "NO\n";
      return ;
  }
  if (ans > (n % k)) {
      cout << "NO\n";
      return ;
  }
  cout << "YES\n";
  ```
- **个人心得**：作者提到在赛时写题时多次挂掉，最终通过分段处理找到了正确的解法，强调了分段思维的重要性。

#### 题解3：作者：NaOHqwq (赞：5)
- **星级**：★★★★☆
- **关键亮点**：详细解释了抽屉原理的数学推导，并通过代码实现了对颜色使用次数的判断，代码简洁且易于理解。
- **代码核心思想**：
  ```cpp
  int c = ceil(n * 1.0 / k);
  int cnt = 0;
  bool flag = true;
  for (int i = 1; i <= m; i++) {
      cin >> a[i];
      if (a[i] > c) flag = false;
      if (a[i] == c) cnt++;
  }
  if (!flag) cout << "NO" << endl;
  else if (cnt > (n - 1) % k + 1) cout << "NO" << endl;
  else cout << "YES" << endl;
  ```
- **个人心得**：作者提到在代码中使用了 `ceil` 函数来确保段数的正确计算，强调了细节处理的重要性。

### 推荐相似题目
1. **洛谷 P1048**：采药问题，考察背包问题的应用。
2. **洛谷 P1060**：开心的金明，考察动态规划的应用。
3. **洛谷 P1091**：合唱队形，考察序列处理与动态规划的结合。

### 总结
这道题的核心在于抽屉原理的应用，通过将纸条分段并限制每个颜色的使用次数，确保每连续 $k$ 个格子颜色互不相同。在处理 $n$ 不能被 $k$ 整除的情况时，需要特别注意最后一段的长度限制。高星题解都很好地解决了这个问题，并通过代码实现了高效的判断。

---
处理用时：42.29秒
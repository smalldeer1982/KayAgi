# 题目信息

# A BIT of a Construction

## 题目描述

给定 $n,k$，请构造序列 $a_n$，你需要保证 $a_i$ 为自然数，同时满足以下条件：

* $\sum\limits_{i=1}^{n} a_i=k$。

* $a_1|a_2|\dots|a_n$ 二进制下拆位后 $1$ 的数量最大，其中 $|$ 表示[按位或](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96/548283?fr=ge_ala)。

## 说明/提示

对于全部数据，满足 $1\le t\le10^4$，$1\le n\le2\times10^5$，$1\le k\le10^9$，$\sum n\le2\times10^5$。

## 样例 #1

### 输入

```
4
1 5
2 3
2 5
6 51```

### 输出

```
5
1 2
5 0
3 1 1 32 2 12```

# AI分析结果

### 题目内容重写
# A BIT of a Construction

## 题目描述

给定 $n,k$，请构造序列 $a_n$，你需要保证 $a_i$ 为自然数，同时满足以下条件：

* $\sum\limits_{i=1}^{n} a_i=k$。

* $a_1|a_2|\dots|a_n$ 二进制下拆位后 $1$ 的数量最大，其中 $|$ 表示[按位或](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96/548283?fr=ge_ala)。

## 说明/提示

对于全部数据，满足 $1\le t\le10^4$，$1\le n\le2\times10^5$，$1\le k\le10^9$，$\sum n\le2\times10^5$。

## 样例 #1

### 输入

```
4
1 5
2 3
2 5
6 51```

### 输出

```
5
1 2
5 0
3 1 1 32 2 12```

### 题解分析与结论

#### 综合分析
本题要求构造一个长度为 $n$ 的自然数序列，使得序列的和为 $k$，并且序列中所有数按位或运算的结果中 $1$ 的个数最多。大多数题解都采用了类似的思路：首先找到 $k$ 的最高位 $1$，然后构造一个数 $a_0$，使得这个数在最高位及其以下的所有位都为 $1$，接着用 $k - a_0$ 作为第二个数，其余数设为 $0$。这种构造方式能够最大化按位或结果的 $1$ 的个数。

#### 最优关键思路
1. **找到 $k$ 的最高位 $1$**：通过遍历或内置函数（如 `__builtin_clz`）找到 $k$ 的最高位 $1$，确定 $a_0$ 的构造范围。
2. **构造 $a_0$**：$a_0$ 应尽可能多地占据高位 $1$，通常取 $2^{x} - 1$，其中 $x$ 是 $k$ 的最高位 $1$ 的位置。
3. **构造 $a_1$**：$a_1$ 取 $k - a_0$，确保序列的和为 $k$。
4. **填充剩余数**：剩余的数设为 $0$，不影响按位或结果。

#### 可拓展之处
- **类似问题**：可以扩展到其他位运算问题，如按位与、按位异或等，要求最大化或最小化某些位的值。
- **优化思路**：可以考虑如何进一步优化构造过程，例如通过预处理或数学公式减少计算量。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

### 所选高星题解

#### 题解1：Pursuewind (赞：12)
**星级：5星**
**关键亮点**：
- 思路清晰，代码简洁，直接找到 $k$ 的最高位 $1$，构造 $a_0$ 和 $a_1$。
- 代码可读性强，使用了 `1ll << x` 来避免溢出问题。

**核心代码**：
```cpp
int x = 0;
for (int i = 63; i >= 0; i --){
    if (k & (1ll << i)){
        x = i;
        break;
    }
}
cout << (1ll << x) - 1 << " " << k - (1ll << x) + 1 << " ";
for (int i = 1; i <= n - 2; i ++){
    cout << "0 ";
}
```

#### 题解2：_shine_ (赞：2)
**星级：4星**
**关键亮点**：
- 通过枚举找到第一个比 $k$ 大的 $2^i$，然后构造 $a_0$ 和 $a_1$。
- 代码逻辑清晰，但使用了 `while` 循环，效率略低。

**核心代码**：
```cpp
int idx=0,num=1;
while(num<=k)num*=2;num/=2;num--;
a[++idx]=num;
if(idx==n && k-num!=0)a[idx]=k;
else a[++idx]=k-num;
while(idx<n)a[++idx]=0;
```

#### 题解3：lailai0916 (赞：2)
**星级：4星**
**关键亮点**：
- 从低到高遍历每一位，尽可能让 $a_1$ 占据更多的 $1$。
- 代码逻辑清晰，但使用了 `for` 循环遍历每一位，效率略低。

**核心代码**：
```cpp
int a1=0;
for(int i=0;i<=30;i++){
    int x=1<<i;
    if(a1+x<=k)a1+=x;
}
cout<<a1<<' '<<k-a1<<' ';
for(int i=3;i<=n;i++)cout<<0<<' ';
```

### 个人心得总结
- **调试经历**：在构造 $a_0$ 时，需要注意 $a_0$ 不能超过 $k$，否则会导致序列和不等于 $k$。
- **顿悟感想**：通过按位或运算的性质，可以有效地最大化 $1$ 的个数，关键在于如何合理地分配 $k$ 的二进制位。

---
处理用时：42.34秒
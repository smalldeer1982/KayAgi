# 题目信息

# Maximize the Root

## 题目描述

给你一棵有根的树，由 $n$ 个顶点组成。树上的顶点从 $1$到 $n$ 编号，根是顶点 $1$ 。第 $i$ 个顶点上的值为 $a_i$。

你可以执行以下操作任意次(可以为零次):选择一个至少有一个子顶点的顶点 $v$; 将 $a_v$ 增加 $1$ 并且对于 $v$ 的子树中的所有顶点 $u$ 将 $a_u$ 减少 $1$ (除了 $v$ 本身)。但是，在每次操作之后，所有顶点上的值都应该是非负的。

你的任务是使用前面提到的运算来计算写在根上的最大可能值。

## 样例 #1

### 输入

```
3
4
0 1 0 2
1 1 3
2
3 0
1
5
2 5 3 9 6
3 1 5 2```

### 输出

```
1
3
6```

# AI分析结果

### 题目内容重写

#### 题目描述

给你一棵有根的树，由 $n$ 个顶点组成。树上的顶点从 $1$ 到 $n$ 编号，根是顶点 $1$。第 $i$ 个顶点上的值为 $a_i$。

你可以执行以下操作任意次（可以为零次）：选择一个至少有一个子顶点的顶点 $v$；将 $a_v$ 增加 $1$，并且对于 $v$ 的子树中的所有顶点 $u$ 将 $a_u$ 减少 $1$（除了 $v$ 本身）。但是，在每次操作之后，所有顶点上的值都应该是非负的。

你的任务是使用前面提到的运算来计算写在根上的最大可能值。

#### 样例 #1

##### 输入

```
3
4
0 1 0 2
1 1 3
2
3 0
1
5
2 5 3 9 6
3 1 5 2
```

##### 输出

```
1
3
6
```

### 题解分析与结论

#### 综合分析与结论

本题的核心在于通过操作最大化根节点的值，同时保证所有节点的值非负。各题解的思路主要集中在如何通过递归或贪心策略来计算每个节点的最小值，并最终将根节点的值与其子树的最小值相加。

#### 所选题解

1. **作者：Muse_Dash (赞：8)**
   - **星级：5**
   - **关键亮点**：通过DFS遍历树，计算每个节点的最小值，并最终将根节点的值与其子树的最小值相加。思路清晰，代码简洁。
   - **核心代码**：
     ```cpp
     void dfs(int u,int fa){
         mn[u]=1e18;
         for (auto v:e[u]){
             if (v==fa) continue;
             dfs(v,u);
             mn[u]=min(mn[v],mn[u]);
         }
         if (mn[u]==1e18) mn[u]=a[u];
         if (mn[u]>a[u]&&u!=1) mn[u]=(mn[u]+a[u])/2;
     }
     ```

2. **作者：ICU152_lowa_IS8 (赞：5)**
   - **星级：4**
   - **关键亮点**：使用拓扑排序进行树的遍历，定义 $dis_i$ 为节点 $i$ 的子树中所可能达到的最大的最小值，最终将根节点的值与其子树的最小值相加。
   - **核心代码**：
     ```cpp
     void tupo(){
         while(!q.empty()){
             int t=q.front();
             q.pop();
             if(t==1)continue;
             for(int i=head[t];i;i=edge[i].next){
                 int v=edge[i].v;
                 if(dis[t]>=a[v]){
                     if(v==1){
                         dis[v]=min(dis[v],dis[t]);
                     }
                     else
                     dis[v]=min(dis[v],(dis[t]+a[v])/2);
                 }
                 else{
                     if(v==1){
                         dis[v]=min(dis[v],dis[t]);
                     }
                     else
                     dis[v]=min(dis[v],min(dis[t],a[v]));
                 }
                 in[v]--;
                 if(!in[v])q.push(v);
             }
         }
     }
     ```

3. **作者：SamHJD (赞：4)**
   - **星级：4**
   - **关键亮点**：通过递归求解每个节点的最小值，最终将根节点的值与其子树的最小值相加。代码结构清晰，易于理解。
   - **核心代码**：
     ```cpp
     int dfs(int u){
         if(!g[u].size()) return a[u];
         int mn=0x3f3f3f3f;
         for(auto v:g[u]) mn=min(mn,dfs(v));
         if(a[u]>=mn) return mn;
         else return (a[u]+mn)>>1;
     }
     ```

#### 最优关键思路或技巧

- **DFS遍历**：通过DFS遍历树，计算每个节点的最小值，并最终将根节点的值与其子树的最小值相加。
- **拓扑排序**：使用拓扑排序进行树的遍历，定义 $dis_i$ 为节点 $i$ 的子树中所可能达到的最大的最小值。
- **递归求解**：通过递归求解每个节点的最小值，最终将根节点的值与其子树的最小值相加。

#### 可拓展之处

- **类似题目**：可以考虑类似的树形DP问题，如最大化某个节点的值或最小化某个节点的值。
- **算法套路**：树形DP、DFS、拓扑排序等算法在树结构问题中非常常见，掌握这些算法可以解决更多类似问题。

#### 推荐题目

1. **洛谷 P1352 没有上司的舞会**：考察树形DP，最大化某个节点的值。
2. **洛谷 P2014 选课**：考察树形DP，选择某些节点以最大化总和。
3. **洛谷 P1040 加分二叉树**：考察树形DP，构建二叉树以最大化得分。

#### 个人心得摘录

- **调试经历**：部分题解提到多测清空问题，强调了在多次测试中清空数组的重要性。
- **踩坑教训**：二分法的上下界设置不当可能导致TLE或WA，需特别注意。
- **顿悟感想**：通过递归或贪心策略，可以有效地解决树形结构中的最优化问题。

---
处理用时：42.13秒
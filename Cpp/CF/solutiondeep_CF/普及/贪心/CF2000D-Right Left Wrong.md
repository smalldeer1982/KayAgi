# 题目信息

# Right Left Wrong

## 题目描述

Vlad发现了一个由 $n$ 细胞组成的条带，从左到右从 $1$ 到 $n$ 编号。在 $i$ 中，有一个正整数 $a_i$ 和一个字母 $s_i$ ，其中所有 $s_i$ 都是'L'或'R'。

Vlad邀请您尝试通过执行任意(可能为零)操作来获得最大可能的分数。

在一次操作中，您可以选择两个索引 $l$ 和 $r$ ( $1 \le l < r \le n$ )，使 $s_l$ = `L` 和 $s_r$ = `R`，并执行以下操作:

- 在当前分数基础上增加 $a_l + a_{l + 1} + \dots + a_{r - 1} + a_r$ 分;

- 将 $s_i$ 替换为`.`

- 对于所有 $l \le i \le r$ ，这意味着您不能再选择这些索引。

例如，考虑下面的strip:

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$
|  --- | --- | --- | --- | --- | ---  |
| l | r | l | l | l | r |

您可以先选择 $l = 1$ ， $r = 2$ ，并将 $3 + 5 = 8$ 添加到您的分数中。

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$
|  --- | --- | --- | --- | --- | ---  |
|。|。| l | l | l | r |

然后选择 $l = 3$ ， $r = 6$ 并将 $1 + 4 + 3 + 2 = 10$ 添加到您的分数中。

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$
|  --- | --- | --- | --- | --- | ---  |
|。|。|。|。|。|。|

因此无法再进行其他操作，最终得分为 $18$ 。

能达到的最高分数是多少?

## 样例 #1

### 输入

```
4
6
3 5 1 4 3 2
LRLLLR
2
2 8
LR
2
3 9
RL
5
1 2 3 4 5
LRLRR```

### 输出

```
18
10
0
22```

# AI分析结果

### 题目重写

#### 题目描述

Vlad发现了一个由 $n$ 个细胞组成的条带，从左到右编号为 $1$ 到 $n$。在第 $i$ 个细胞中，有一个正整数 $a_i$ 和一个字母 $s_i$，其中所有 $s_i$ 都是 `L` 或 `R`。

Vlad邀请您通过执行任意（可能为零）操作来获得最大可能的分数。

在一次操作中，您可以选择两个索引 $l$ 和 $r$（$1 \le l < r \le n$），使得 $s_l$ = `L` 且 $s_r$ = `R`，并执行以下操作：

- 在当前分数基础上增加 $a_l + a_{l + 1} + \dots + a_{r - 1} + a_r$ 分；
- 将 $s_i$ 替换为 `.`；
- 对于所有 $l \le i \le r$，这意味着您不能再选择这些索引。

例如，考虑下面的条带：

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$ |
| --- | --- | --- | --- | --- | --- |
| L | R | L | L | L | R |

您可以先选择 $l = 1$，$r = 2$，并将 $3 + 5 = 8$ 添加到您的分数中。

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$ |
| --- | --- | --- | --- | --- | --- |
| . | . | L | L | L | R |

然后选择 $l = 3$，$r = 6$，并将 $1 + 4 + 3 + 2 = 10$ 添加到您的分数中。

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$ |
| --- | --- | --- | --- | --- | --- |
| . | . | . | . | . | . |

因此无法再进行其他操作，最终得分为 $18$。

能达到的最高分数是多少？

#### 样例 #1

##### 输入

```
4
6
3 5 1 4 3 2
LRLLLR
2
2 8
LR
2
3 9
RL
5
1 2 3 4 5
LRLRR
```

##### 输出

```
18
10
0
22
```

---

### 题解分析与结论

#### 综合分析

本题的核心在于如何通过贪心策略选择 `L` 和 `R` 的配对，以最大化得分。所有题解都采用了贪心算法，但实现方式有所不同。主要思路是从两端向中间匹配 `L` 和 `R`，并使用前缀和快速计算区间和。

#### 最优思路与技巧

1. **贪心策略**：从两端向中间匹配 `L` 和 `R`，优先选择最远的 `L` 和 `R`，以确保中间的所有细胞都能被包含在内，从而最大化得分。
2. **前缀和优化**：使用前缀和数组快速计算任意区间的和，避免重复计算。
3. **双指针技巧**：使用双指针从两端向中间遍历，快速找到符合条件的 `L` 和 `R`。

#### 推荐题解

1. **作者：__O_v_O__ (4星)**
   - **关键亮点**：使用双指针从两端向中间匹配 `L` 和 `R`，代码简洁且高效。
   - **代码实现**：
     ```cpp
     while(l<=r){
         l++,r--;
         while(l<=r&&s[l]!='L')l++;
         while(l<=r&&s[r]!='R')r--;
         if(l>r)break;
         ans+=sum[r]-sum[l-1];	
     }
     ```

2. **作者：roumeideclown (4星)**
   - **关键亮点**：详细解释了贪心策略的正确性，并使用了前缀和和双指针技巧。
   - **代码实现**：
     ```cpp
     for(ll i=0,j=0;i<le.size()&&j<ri.size()&&le[i]<ri[j];i++,j++) {
         op.push_back(make_pair(le[i],ri[j]));
     }
     ```

3. **作者：hytallenxu (4星)**
   - **关键亮点**：使用队列存储 `L` 和 `R` 的下标，并详细解释了贪心策略的正确性。
   - **代码实现**：
     ```cpp
     while(left.size() && right.size()){
         if(right.front()>left.front()){
             ans+=(sum[right.front()]-sum[left.front()-1]);
             left.pop();right.pop();
         }else{
             break;
         }
     }
     ```

#### 个人心得摘录

- **SXqwq**：场上看错题了，后来发公告我才明白。本来不想打了，睡了一觉，做梦梦到做法了，就起来写了。
  - **总结**：调试过程中发现题目理解错误，通过休息和反思最终找到正确解法。

#### 推荐题目

1. **P1044 栈**：考察贪心策略和栈的应用。
2. **P1090 合并果子**：贪心算法的经典应用。
3. **P1223 排队接水**：贪心策略在时间调度中的应用。

---

### 结论

本题的关键在于贪心策略的选择和前缀和的优化。通过从两端向中间匹配 `L` 和 `R`，并使用前缀和快速计算区间和，可以高效地解决问题。推荐的题解都很好地体现了这些思路，代码实现简洁且高效。

---
处理用时：42.49秒
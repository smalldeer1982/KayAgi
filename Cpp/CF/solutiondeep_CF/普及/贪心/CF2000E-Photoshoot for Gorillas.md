# 题目信息

# Photoshoot for Gorillas

## 题目描述

你非常喜欢大猩猩，于是你决定为它们组织一次拍摄活动。大猩猩生活在丛林中，丛林被表示为一个有 $n$ 行 $m$ 列的网格，有 $w$ 个大猩猩同意参与拍摄，第 $i$ 个大猩猩的身高为 $a_i$ .你希望将所有大猩猩放置在网格的单元格中，并且确保每个单元格中最多只有一只大猩猩。

每种方案的壮观程度等于网格中所有以 $k$ 为边长的子正方形的壮观程度的总和。

子正方形的壮观程度等于其中所有大猩猩的身高的总和。

从所有合适的方案中选出最壮观的方案。

## 样例 #1

### 输入

```
5
3 4 2
9
1 1 1 1 1 1 1 1 1
2 1 1
2
5 7
20 15 7
9
4 1 4 5 6 1 1000000000 898 777
1984 1 1
4
5 4 1499 2004
9 5 5
6
6 7 14 16 16 6```

### 输出

```
21
12
49000083104
3512
319```

# AI分析结果

【题目内容】
# 大猩猩的拍摄活动

## 题目描述

你非常喜欢大猩猩，于是你决定为它们组织一次拍摄活动。大猩猩生活在丛林中，丛林被表示为一个有 $n$ 行 $m$ 列的网格，有 $w$ 个大猩猩同意参与拍摄，第 $i$ 个大猩猩的身高为 $a_i$。你希望将所有大猩猩放置在网格的单元格中，并且确保每个单元格中最多只有一只大猩猩。

每种方案的壮观程度等于网格中所有以 $k$ 为边长的子正方形的壮观程度的总和。

子正方形的壮观程度等于其中所有大猩猩的身高的总和。

从所有合适的方案中选出最壮观的方案。

【题解分析与结论】

所有题解的核心思路都是通过贪心策略，将身高较高的大猩猩放置在被子正方形覆盖次数较多的格子中，以最大化总壮观程度。具体实现上，主要使用了二维差分和前缀和来计算每个格子被子正方形覆盖的次数，然后通过排序和匹配来实现贪心策略。

【评分较高的题解】

1. **作者：XYzero (4星)**
   - **关键亮点**：使用了二维差分和前缀和来计算每个格子被子正方形覆盖的次数，代码清晰且高效。
   - **核心代码**：
     ```cpp
     for(int i = 1;i <= n - k + 1;i++){
         for(int j = 1;j <= m - k + 1;j++){
             int x = i,y = j,X = min(n,i + k - 1),Y = min(m,j + k - 1);
             c[x][y] ++;
             c[X + 1][Y + 1] ++;
             c[x][Y + 1] --;
             c[X + 1][y] --;
         } 
     }
     for(int i = 1;i <= n;i++){
         for(int j = 1;j <= m;j++){
             pre[i][j] = (pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + c[i][j]);
         } 
     }
     ```

2. **作者：Ke_scholar (4星)**
   - **关键亮点**：使用了二维差分和前缀和，代码简洁且易于理解。
   - **核心代码**：
     ```cpp
     for (int i = 1; i + k <= n + 1; i ++) {
         for (int j = 1; j + k <= m + 1; j ++) {
             v[i][j] ++, v[i][j + k] --;
             v[i + k][j]--, v[i + k][j + k]++;
         }
     }
     for (int i = 1; i <= n; i ++) {
         for (int j = 1; j <= m; j ++) {
             v[i][j] += v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1];
             d.push_back(v[i][j]);
         }
     }
     ```

3. **作者：_dbq_ (4星)**
   - **关键亮点**：通过数学公式直接计算每个格子被子正方形覆盖的次数，避免了复杂的差分操作。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         for(int j=1;j<=m;j++){
             a[++tmp]=1ll*(min(i+k-1,n)-max(i,k)+1)*(min(j+k-1,m)-max(j,k)+1);
         }
     }
     ```

【最优关键思路与技巧】
- **二维差分与前缀和**：通过二维差分和前缀和高效计算每个格子被子正方形覆盖的次数。
- **贪心策略**：将身高较高的大猩猩放置在覆盖次数较多的格子中，以最大化总壮观程度。

【可拓展之处】
- 类似的问题可以通过二维差分和前缀和来解决，例如计算某个区域内的总和或覆盖次数。
- 贪心策略在类似的优化问题中也有广泛应用，如任务调度、资源分配等。

【推荐题目】
1. P3397 地毯
2. P2280 [HNOI2003]激光炸弹
3. P2216 [HAOI2007]理想的正方形

【个人心得】
- 调试过程中，确保差分和前缀和的正确性非常重要，尤其是在边界条件的处理上。
- 贪心策略的合理性需要通过数学证明或直观理解来确保，避免出现局部最优而非全局最优的情况。

---
处理用时：37.78秒
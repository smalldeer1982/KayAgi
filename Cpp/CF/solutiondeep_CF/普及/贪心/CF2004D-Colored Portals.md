# 题目信息

# Colored Portals

## 题目描述

一条直线上有 $n$ 个城市，这些城市的编号为 $1$ 到 $n$。

传送门被用于在城市间移动，传送门有四种颜色：蓝色，绿色，红色和黄色。每一个城市都有两种颜色的传送门。你可以从城市 $i$ 到城市 $j$，当且仅当这两个城市存在同色的传送门（例如，你可以从有红色和蓝色的传送门的城市到有蓝色和绿色传送门的城市），花费 $|i - j|$ 个硬币。

你的任务是回答 $q$ 个询问：计算城市 $x$ 到城市 $y$ 的最小花费。

## 样例 #1

### 输入

```
2
4 5
BR BR GY GR
1 2
3 1
4 4
1 4
4 2
2 1
BG RY
1 2```

### 输出

```
1
4
0
3
2
-1```

# AI分析结果

### 题目重写

#### 题目描述

一条直线上有 $n$ 个城市，这些城市的编号为 $1$ 到 $n$。

传送门被用于在城市间移动，传送门有四种颜色：蓝色，绿色，红色和黄色。每一个城市都有两种颜色的传送门。你可以从城市 $i$ 到城市 $j$，当且仅当这两个城市存在同色的传送门（例如，你可以从有红色和蓝色的传送门的城市到有蓝色和绿色传送门的城市），花费 $|i - j|$ 个硬币。

你的任务是回答 $q$ 个询问：计算城市 $x$ 到城市 $y$ 的最小花费。

#### 样例 #1

##### 输入

```
2
4 5
BR BR GY GR
1 2
3 1
4 4
1 4
4 2
2 1
BG RY
1 2
```

##### 输出

```
1
4
0
3
2
-1
```

### 题解分析与结论

#### 综合分析

1. **核心思路**：所有题解的核心思路都是通过预处理每个城市的传送门颜色，然后根据询问中的两个城市是否可以直接到达（即是否有相同颜色的传送门）来决定是否需要中转。如果需要中转，则通过预处理找到最近的中转点来计算最小花费。

2. **优化策略**：大多数题解都采用了预处理的方法，通过记录每个城市左右最近的中转点，从而在回答询问时能够快速计算出最小花费。这种预处理的方式大大减少了查询时的时间复杂度。

3. **难点**：主要的难点在于如何高效地预处理每个城市的中转点，以及在回答询问时如何快速判断是否需要中转并计算最小花费。

#### 所选高星题解

##### 题解1：copper_ingot (4星)

**关键亮点**：
- 通过将传送门颜色转换为数字，简化了后续处理。
- 使用 `pre` 和 `suf` 数组分别记录每个城市左右最近的中转点，预处理时间复杂度为 $O(n)$。
- 在回答询问时，通过判断 `pre` 和 `suf` 数组的值，快速计算出最小花费。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++){//求pre
    for (int j = 1; j <= 6; j++){
        if (a[i] != j && a[i] + j != 7) pre[i] = max(pre[i], tmp[j]);
    }
    tmp[a[i]] = max(tmp[a[i]], i);//实时记录
}
memset(tmp, 0x7f, sizeof(tmp));
for (int i = n; i >= 1; i--){//同上，求suf
    for (int j = 1; j <= 6; j++){
        if (a[i] != j && a[i] + j != 7) suf[i] = min(suf[i], tmp[j]);
    }
    tmp[a[i]] = min(tmp[a[i]], i);
}
```

##### 题解2：初星逝者 (4星)

**关键亮点**：
- 通过定义“反串”概念，简化了中转点的判断。
- 使用 `map` 记录颜色到城市的映射，预处理时间复杂度为 $O(n)$。
- 在回答询问时，通过判断中转点的位置，快速计算出最小花费。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(auto y:v)if(y!=rs(s[i])&&s[i]!=y)a[i]=max(mp[y],a[i]);
    mp[s[i]]=i;
}
mp.clear();
for(int i=n;i>=1;i--){
    for(auto y:v)if(y!=rs(s[i])&&s[i]!=y)b[i]=min(mp[y]==0?1000000:mp[y],b[i]);
    mp[s[i]]=i;
}
```

#### 最优关键思路

- **预处理中转点**：通过预处理每个城市左右最近的中转点，可以在回答询问时快速计算出最小花费，时间复杂度为 $O(n)$。
- **颜色转换**：将传送门颜色转换为数字，简化了后续处理，提高了代码的可读性和执行效率。

#### 可拓展之处

- **类似算法套路**：这种预处理中转点的思路可以应用于其他需要快速查询最短路径或最小花费的问题，尤其是当图中的边权与节点之间的距离相关时。
- **数据结构优化**：可以考虑使用更高效的数据结构（如线段树、树状数组）来进一步优化预处理和查询的时间复杂度。

#### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

#### 个人心得

- **调试经历**：在预处理中转点时，需要注意边界条件的处理，尤其是当某个城市没有中转点时，需要正确处理无解情况。
- **踩坑教训**：使用 `memset` 时需要注意初始化的值，避免出现未定义行为。

---
处理用时：40.25秒
# 题目信息

# Alternating String

## 题目描述

# 交替字符串


Sakurako 非常喜欢交替字符串。她把一个由小写拉丁字母组成的字符串 $s$ 称为"交替字符串"，如果字符串中偶数位置的字符都相同，奇数位置的字符都相同，且字符串的长度是偶数。

例如，字符串 `abab` 和 `gg` 是交替的，而字符串 `aba` 和 `ggwp` 则不是。

作为她的好朋友，你决定送她这样一个字符串，但你没能找到一个。幸运的是，你可以对字符串执行两种操作：

1. 选择一个索引 $i$ 并删除字符串中的第  $i$ 个字符，这将使字符串的长度减少 $1$ 。这种操作最多可以执行 $1$ 次；

2. 选择一个索引 $i$ 并将 $s_i$ 替换为任意其他字母。

由于你很着急，你需要确定将字符串变成交替字符串所需的最少操作次数。

## 说明/提示

对于字符串 `ababa`，你可以删除第一个字符得到 `baba`，这是一个交替字符串。

对于字符串 `acdada`，你可以将前两个字符改为 `d` 和 `a` 得到 `dadada`，这是一个交替字符串。

## 样例 #1

### 输入

```
10
1
a
2
ca
3
aab
5
ababa
6
acdada
9
ejibmyyju
6
bbccbc
6
abacba
5
bcbca
5
dcbdb```

### 输出

```
1
0
1
1
2
6
2
3
1
1```

# AI分析结果

### 题目内容重写

# 交替字符串

Sakurako 非常喜欢交替字符串。她把一个由小写拉丁字母组成的字符串 $s$ 称为"交替字符串"，如果字符串中偶数位置的字符都相同，奇数位置的字符都相同，且字符串的长度是偶数。

例如，字符串 `abab` 和 `gg` 是交替的，而字符串 `aba` 和 `ggwp` 则不是。

作为她的好朋友，你决定送她这样一个字符串，但你没能找到一个。幸运的是，你可以对字符串执行两种操作：

1. 选择一个索引 $i$ 并删除字符串中的第  $i$ 个字符，这将使字符串的长度减少 $1$ 。这种操作最多可以执行 $1$ 次；

2. 选择一个索引 $i$ 并将 $s_i$ 替换为任意其他字母。

由于你很着急，你需要确定将字符串变成交替字符串所需的最少操作次数。

### 说明/提示

对于字符串 `ababa`，你可以删除第一个字符得到 `baba`，这是一个交替字符串。

对于字符串 `acdada`，你可以将前两个字符改为 `d` 和 `a` 得到 `dadada`，这是一个交替字符串。

### 样例 #1

#### 输入

```
10
1
a
2
ca
3
aab
5
ababa
6
acdada
9
ejibmyyju
6
bbccbc
6
abacba
5
bcbca
5
dcbdb
```

#### 输出

```
1
0
1
1
2
6
2
3
1
1
```

### 题解分析与结论

#### 综合分析

题目要求将给定字符串通过最少的操作次数变为交替字符串。交替字符串的定义是偶数位置的字符相同，奇数位置的字符相同，且长度为偶数。操作包括删除一个字符（最多一次）和替换任意字符。

各题解的思路主要集中在以下两点：

1. **偶数长度字符串**：直接统计奇数位和偶数位上出现频率最高的字符，计算需要替换的字符数。
2. **奇数长度字符串**：枚举删除的字符位置，将问题转化为偶数长度字符串的情况，计算需要替换的字符数。

#### 关键思路与技巧

- **统计字符频率**：通过统计奇数位和偶数位上字符的频率，找到出现次数最多的字符，从而减少替换操作。
- **前缀和后缀维护**：对于奇数长度字符串，维护前缀和后缀的字符频率，以便在删除某个字符后快速计算需要替换的字符数。
- **枚举删除位置**：对于奇数长度字符串，枚举每个可能的删除位置，计算删除后字符串变为交替字符串所需的最小操作数。

#### 推荐题解

1. **作者：imfbust (4星)**
   - **关键亮点**：详细讨论了奇偶长度字符串的处理方法，代码清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) sumb[s[i]-'a'+1][i&1]+=1;        
     int res=0;
     for(int i=1;i<=n;i++){
         maxn1=maxn2=0;
         if(i>1) sumf[s[i-1]-'a'+1][i&1^1]++;
         sumb[s[i]-'a'+1][i&1]--;
         for(int j=1;j<=M;j++){
             maxn1=max(maxn1,sumf[j][0]+sumb[j][1]);
             maxn2=max(maxn2,sumf[j][1]+sumb[j][0]);
         }
         res=max(res,maxn1+maxn2);
     }
     printf("%d\n",n-res);
     ```

2. **作者：Super_Cube (4星)**
   - **关键亮点**：代码简洁，思路清晰，处理奇偶长度字符串的方法高效。
   - **核心代码**：
     ```cpp
     if(n&1){
         static int pre[2][26];
         memset(pre,0,sizeof(pre));
         ans=0;
         for(int i=1,s1,s2;i<=n;++i){
             s1=s2=0;
             for(int j=0;j<26;++j)
                 s1=std::max(s1,pre[0][j]+cnt[1][j]-pre[1][j]-((i&1)&&s[i]-'a'==j)),
                 s2=std::max(s2,pre[1][j]+cnt[0][j]-pre[0][j]-(!(i&1)&&s[i]-'a'==j));
             ans=std::max(ans,s1+s2);
             ++pre[i&1][s[i]-'a'];
         }
     }
     ```

3. **作者：chenxi2009 (4星)**
   - **关键亮点**：详细解释了前缀和后缀的维护方法，代码结构清晰。
   - **核心代码**：
     ```cpp
     if(n & 1){
         memset(tot1,0,sizeof(tot1));
         memset(tot2,0,sizeof(tot2));
         ans = n;
         for(int i = 1;i <= n;i ++){
             if(i & 1){
                 tot1[s[i] - 'a'] ++;
             }
             else{
                 tot2[s[i] - 'a'] ++;
             }
         }
         for(int i = 1;i <= n;i ++){
             if(i & 1){
                 tot1[s[i] - 'a'] --;
                 maxa = maxb = 0;
                 for(int j = 0;j < 26;j ++){
                     maxa = max(maxa,cnt2[j] + tot1[j]);
                     maxb = max(maxb,cnt1[j] + tot2[j]);
                 }
                 cnt1[s[i] - 'a'] ++;
                 ans = min(ans,n - maxa - maxb);
             }
         }
     }
     ```

### 推荐题目

1. **P1908 逆序对**：考察统计和排序的经典题目。
2. **P3374 【模板】树状数组 1**：涉及前缀和和区间查询的题目。
3. **P3368 【模板】树状数组 2**：涉及区间修改和单点查询的题目。

### 个人心得

- **调试经历**：在处理奇数长度字符串时，删除字符后奇偶位置的变化需要特别注意，容易出错。
- **顿悟感想**：通过维护前缀和后缀的字符频率，可以大大简化计算过程，提高代码效率。

---
处理用时：49.27秒
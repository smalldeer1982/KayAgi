# 题目信息

# Password Cracking

## 题目描述

迪马什得知曼苏尔向朋友泄露了一些关于他的不愉快言论，于是他决心揭开曼苏尔的密码，看看具体内容是什么。

曼苏尔对自己的密码充满信心，他表示自己的密码是一个长度为 $ n $ 的二进制字符串。同时，他愿意回答迪马什的问题：

迪马什可以给出一个二进制字符串 $ t $ ，曼苏尔则回答 $ t $ 是否是他的密码的一个子串（即一段连续的字符序列）。

请帮助迪马什在不超过 $ 2n $ 次询问内猜出密码；否则，曼苏尔将识破伎俩并停止与他交流。

## 样例 #1

### 输入

```
4
3

0

0

1

4

4

2```

### 输出

```
? 00

? 000

? 010

! 010

! 1100

! 0110

! 10```

# AI分析结果

### 题目内容重写（中文）

# 密码破解

## 题目描述

迪马什得知曼苏尔向朋友泄露了一些关于他的不愉快言论，于是他决心揭开曼苏尔的密码，看看具体内容是什么。

曼苏尔对自己的密码充满信心，他表示自己的密码是一个长度为 $ n $ 的二进制字符串。同时，他愿意回答迪马什的问题：

迪马什可以给出一个二进制字符串 $ t $ ，曼苏尔则回答 $ t $ 是否是他的密码的一个子串（即一段连续的字符序列）。

请帮助迪马什在不超过 $ 2n $ 次询问内猜出密码；否则，曼苏尔将识破伎俩并停止与他交流。

## 样例 #1

### 输入

```
4
3

0

0

1

4

4

2```

### 输出

```
? 00

? 000

? 010

! 010

! 1100

! 0110

! 10```

### 题解分析与结论

#### 综合分析

1. **hema5177的题解**：
   - **思路**：从长度为1的字符串开始，逐步在前后添加0或1，直到得到完整的密码。通过先向后拓展再向前拓展，减少猜测次数。
   - **优点**：思路清晰，代码实现较为简洁，且通过优化减少了猜测次数。
   - **缺点**：初始版本效率较低，优化后的版本虽然减少了猜测次数，但仍有改进空间。
   - **评分**：4星

2. **Wind_love的题解**：
   - **思路**：采用贪心策略，先向后拓展，再向前拓展，确保在2n次询问内完成猜测。
   - **优点**：代码简洁，逻辑清晰，符合题目要求。
   - **缺点**：代码中使用了`endl`自动刷新缓冲区，可能导致效率降低。
   - **评分**：4星

3. **Defy_HeavenS的题解**：
   - **思路**：先向后拓展，直到无法拓展，再向前拓展，最终完成猜测。使用`map`缓存查询结果，减少重复查询。
   - **优点**：代码结构清晰，使用缓存优化查询效率，逻辑严谨。
   - **缺点**：代码略显冗长，部分细节处理不够简洁。
   - **评分**：4星

#### 最优关键思路

- **逐步拓展法**：从已知的子串开始，逐步在前后添加0或1，通过询问判断是否为目标子串，直到得到完整的密码。
- **缓存优化**：使用`map`缓存查询结果，避免重复查询，提高效率。

#### 可拓展之处

- **字符集扩展**：该思路可以扩展到更大的字符集（如小写字母或大写字母），只需调整字符添加的逻辑。
- **多次询问优化**：在更复杂的场景中，可以通过更智能的猜测策略进一步减少询问次数。

#### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3373 【模板】线段树 1](https://www.luogu.com.cn/problem/P3373)

### 所选高分题解

#### 1. hema5177的题解（4星）

**关键亮点**：
- 通过先向后拓展再向前拓展，减少猜测次数，符合题目要求。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
while(s1.size()<n)
{
    bool a;
    cout<<"? "<<s1+'1'<<endl;
    fflush(stdout);
    cin>>a;
    if(a)
    {
        s1+='1';
        continue;
    }
    cout<<"? "<<s1+'0'<<endl;
    fflush(stdout);
    cin>>a;
    if(a) s1+='0';
    else break;
}
while(s1.size()<n)
{
    bool a;
    cout<<"? "<<'1'+s1<<endl;
    fflush(stdout);
    cin>>a;
    if(a)
    {
        s1='1'+s1;
        continue;
    }
    s1='0'+s1;
}
cout<<"! "<<s1<<endl;
fflush(stdout);
```

#### 2. Wind_love的题解（4星）

**关键亮点**：
- 采用贪心策略，先向后拓展，再向前拓展，确保在2n次询问内完成猜测。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
while(1){
    if(f){
        cout<<"? "<<string(s+"0")<<endl;
        cin>>temp;
        if(temp)s+="0";
        else{
            cout<<"? "<<string(s+"1")<<endl;
            cin>>temp;
            if(temp)s+="1";
            else f=0;
        }
    }
    if(!f){
        cout<<"? "<<string("0"+s)<<endl;
        cin>>temp;
        if(temp)s="0"+s;
        else s="1"+s;
    }
    if(s.size()==n){
        cout<<"! "<<s<<endl;
        break;
    }
}
```

#### 3. Defy_HeavenS的题解（4星）

**关键亮点**：
- 使用`map`缓存查询结果，减少重复查询，提高效率。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
while(s.size()<n){
    q=query(s+"0");
    if(q){
        s+="0";
        continue;
    }
    q=query(s+"1");
    if(q){
        s+='1';
        continue;
    }else{
        break;
    }
}
while(s.size()<n){
    q=query("0"+s);
    if(q){
        s="0"+s;
        continue;
    }
    s="1"+s;
}
cout<<"! "<<s<<"\n";
cout.flush();
```

### 个人心得摘录

- **hema5177**：初始版本效率较低，通过优化减少了猜测次数，避免了前后反复横跳添加0或1。
- **Wind_love**：使用`endl`自动刷新缓冲区，虽然方便但可能导致效率降低。
- **Defy_HeavenS**：交互题真麻烦，总是忘记刷新缓冲区，使用`map`缓存查询结果后效率明显提升。

---
处理用时：46.99秒
# 题目信息

# Action Figures

## 题目描述

在 Monocarp 家附近有一家商店，专门售卖手办。近期，这家店将推出一套新的手办系列，总共包含 $n$ 个手办。其中，第 $i$ 个手办的价格为 $i$ 枚金币。在第 $i$ 天到第 $n$ 天之间，这个手办都是可以购买的。

Monocarp 知道他在这 $n$ 天中的哪几天可以去商店。

每次去商店的时候，他可以购买多件手办（当然，不能买尚未发售的手办）。如果他在同一天购买了至少两个手办，他可以享受一个折扣：他所购买的最贵手办是免费的，也就是说他无需为该手办支付费用。

Monocarp 的目标是从这个手办系列中，分别购买一个第 $1$ 个手办、一个第 $2$ 个手办……一直到一个第 $n$ 个手办。注意，每个手办只能购买一次。请你帮他计算，他最少需要花费多少金币？

## 说明/提示

在第一个测试用例中，Monocarp 可以在第一天购买第一个手办，花费 1 枚金币。

在第二个测试用例中，他可以在第三天购买第 1 和第 3 个手办，在第四天购买第 2 和第 4 个手办，在第六天购买第 5 和第 6 个手办。这样总费用为 $1+2+5=8$ 枚金币。

在第三个测试用例中，他可以在第三天购买第 2 和第 3 个手办，其余手办在第七天购买，最终花费 $1+2+4+5+6 = 18$ 枚金币。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
1
1
6
101101
7
1110001
5
11111```

### 输出

```
1
8
18
6```

# AI分析结果

### 题目重写
在 Monocarp 家附近有一家商店，专门售卖手办。近期，这家店将推出一套新的手办系列，总共包含 $n$ 个手办。其中，第 $i$ 个手办的价格为 $i$ 枚金币。在第 $i$ 天到第 $n$ 天之间，这个手办都是可以购买的。

Monocarp 知道他在这 $n$ 天中的哪几天可以去商店。

每次去商店的时候，他可以购买多件手办（当然，不能买尚未发售的手办）。如果他在同一天购买了至少两个手办，他可以享受一个折扣：他所购买的最贵手办是免费的，也就是说他无需为该手办支付费用。

Monocarp 的目标是从这个手办系列中，分别购买一个第 $1$ 个手办、一个第 $2$ 个手办……一直到一个第 $n$ 个手办。注意，每个手办只能购买一次。请你帮他计算，他最少需要花费多少金币？

### 题解分析与结论

#### 综合分析与结论
本题的核心在于如何利用折扣策略最小化购买手办的总成本。所有题解都采用了贪心算法，通过从大到小或从后向前遍历手办，尽可能地将高价手办与低价手办配对，以享受折扣。不同题解在数据结构的选用上有所不同，如 `set`、`deque` 等，但核心思路一致。

#### 所选高星题解

1. **作者：Drifty (4星)**
   - **关键亮点**：使用 `set` 数据结构维护未购买的手办，从大到小遍历，优先将高价手办与低价手办配对，确保最小化总成本。
   - **核心代码**：
     ```cpp
     set <int> S({0}), T;
     i64 ans = 0;
     for (int i = 1; i <= n; i ++) {
         if (s[i - 1] == '0') S.insert(i), ans += i;
         if (s[i - 1] == '1') T.insert(i);
     }
     while (T.size()) {
         auto it = S.upper_bound(*T.rbegin());
         if (*(-- it) == 0) {
             ans += *T.begin(); T.erase(*T.begin());
             if (T.size() >= 1) T.erase(*T.rbegin());
         } 
         else S.erase(*it), T.erase(*T.rbegin());
     }
     cout << ans << '\n';
     ```

2. **作者：zhouruoheng (4星)**
   - **关键亮点**：使用双端队列 `deque` 存储可购买的手办，从后向前遍历，优先将高价手办与低价手办配对，确保最小化总成本。
   - **核心代码**：
     ```cpp
     deque<int> dq;
     int st[N],tot;
     ll ans;
     void solve() {
         cin>>n;
         cin>>s;
         tot=ans=0;
         for(int i=0;i<n;i++) {
             if(s[i]-'0') dq.push_back(i+1);
             else st[++tot]=i+1;
             ans+=i+1;
         }
         while(dq.size()) {
             int x=dq.back();dq.pop_back();
             while(tot&&st[tot]>x) tot--;
             if(tot) {
                 tot--;
                 ans-=x;
             }
             else {
                 if(dq.size()) {
                     dq.pop_front();
                     ans-=x;
                 }
             }
         }
         cout<<ans<<'\n';
     }
     ```

3. **作者：MiaoYu (4星)**
   - **关键亮点**：使用双端队列 `deque`，从后向前遍历，优先将高价手办与低价手办配对，确保最小化总成本。
   - **核心代码**：
     ```cpp
     deque<int> q;
     int main () {
         cin >> t; while (t--) {
             cin >> n >> s;
             int len = s.length();
             long long ans = 0;
             for (int i = len - 1; i >= 0; i--) {
                 int x; x = s[i] - '0';
                 if (x == 1) q.push_back(i + 1);
                 else {
                     if (!q.empty()) q.pop_front();
                     ans += i + 1;
                 }
             }
             while (!q.empty()) {
                 ans += q.back();
                 q.pop_back();
                 if (q.empty()) break;
                 q.pop_front();
             }
             cout << ans << '\n';
         }
     }
     ```

### 最优关键思路或技巧
- **贪心算法**：从大到小或从后向前遍历手办，优先将高价手办与低价手办配对，以享受折扣。
- **数据结构**：使用 `set` 或 `deque` 等数据结构维护未购买的手办，确保高效地找到合适的配对。

### 可拓展之处
- **类似问题**：可以扩展到其他需要最小化成本的购买问题，如购买商品时享受不同折扣策略。
- **算法套路**：贪心算法在优化问题中广泛应用，特别是在需要最大化或最小化某些指标时。

### 推荐题目
1. [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---
处理用时：42.20秒
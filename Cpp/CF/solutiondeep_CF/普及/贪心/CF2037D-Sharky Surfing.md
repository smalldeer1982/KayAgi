# 题目信息

# Sharky Surfing

## 题目描述

Mualani 喜欢在她的大鲨鱼冲浪板上冲浪！

Mualani 的冲浪路径可以用一个数轴来表示。她从位置 $1$ 开始，路径的终点是位置 $L$。当她处于位置 $x$ 且跳跃能力为 $k$ 时，她可以跳到区间 $[x, x+k]$ 内的任意整数位置。最初，她的跳跃能力为 $1$。

然而，她的冲浪路径并不完全平坦。她的路径上有 $n$ 个障碍物。每个障碍物由一个区间 $[l, r]$ 表示，意味着她不能跳到区间 $[l, r]$ 内的任何位置。

在路径上还有 $m$ 个能量提升点。第 $i$ 个能量提升点位于位置 $x_i$，其值为 $v_i$。当 Mualani 处于位置 $x_i$ 时，她可以选择收集该能量提升点，将她的跳跃能力增加 $v_i$。在同一个位置可能有多个能量提升点。当她处于有多个能量提升点的位置时，她可以选择收集或忽略每个单独的能量提升点。没有能量提升点位于任何障碍物的区间内。

Mualani 必须收集最少的能量提升点数才能到达位置 $L$ 完成冲浪路径。如果无法完成冲浪路径，则输出 $-1$。

## 样例 #1

### 输入

```
4
2 5 50
7 14
30 40
2 2
3 1
3 5
18 2
22 32
4 3 50
4 6
15 18
20 26
34 38
1 2
8 2
10 2
1 4 17
10 14
1 6
1 2
1 2
16 9
1 2 10
5 9
2 3
2 2```

### 输出

```
4
-1
1
2```

# AI分析结果

### 题目内容重写

#### 题目描述

Mualani 喜欢在她的大鲨鱼冲浪板上冲浪！

Mualani 的冲浪路径可以用一个数轴来表示。她从位置 $1$ 开始，路径的终点是位置 $L$。当她处于位置 $x$ 且跳跃能力为 $k$ 时，她可以跳到区间 $[x, x+k]$ 内的任意整数位置。最初，她的跳跃能力为 $1$。

然而，她的冲浪路径并不完全平坦。她的路径上有 $n$ 个障碍物。每个障碍物由一个区间 $[l, r]$ 表示，意味着她不能跳到区间 $[l, r]$ 内的任何位置。

在路径上还有 $m$ 个能量提升点。第 $i$ 个能量提升点位于位置 $x_i$，其值为 $v_i$。当 Mualani 处于位置 $x_i$ 时，她可以选择收集该能量提升点，将她的跳跃能力增加 $v_i$。在同一个位置可能有多个能量提升点。当她处于有多个能量提升点的位置时，她可以选择收集或忽略每个单独的能量提升点。没有能量提升点位于任何障碍物的区间内。

Mualani 必须收集最少的能量提升点数才能到达位置 $L$ 完成冲浪路径。如果无法完成冲浪路径，则输出 $-1$。

### 题解分析与结论

#### 综合分析与结论

本题的核心在于如何通过贪心策略，利用优先队列来优化跳跃能力的提升，从而在遇到障碍物时，尽可能少地收集能量提升点。所有题解都采用了类似的思路：使用优先队列存储能量提升点，并在遇到障碍物时，从队列中取出最大的能量提升点，直到跳跃能力足以越过当前障碍物。如果队列为空且跳跃能力仍不足以越过障碍物，则输出 $-1$。

#### 最优关键思路与技巧

1. **贪心策略**：每次遇到障碍物时，优先使用跳跃能力提升最大的能量点，以确保收集的能量点数量最少。
2. **优先队列**：使用优先队列（大根堆）来存储能量提升点，方便快速获取最大的能量提升值。
3. **障碍物处理**：遍历每个障碍物，动态更新优先队列中的能量提升点，确保在遇到障碍物时能够及时提升跳跃能力。

#### 可拓展之处

1. **类似问题**：可以扩展到其他需要动态调整能力或资源的问题，如跳跃游戏、资源分配等。
2. **优化技巧**：在处理大规模数据时，可以考虑进一步优化数据结构，如使用更高效的堆实现或结合其他算法（如二分查找）来加速处理。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P3378 堆](https://www.luogu.com.cn/problem/P3378)

### 题解评分与亮点

#### 题解1：_mi_ka_ (4星)

**关键亮点**：
- 使用了离散化处理，优化了大规模数据的处理效率。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
priority_queue<int>q;
int nowo=0,nowt=0,ans=0,nowv=1,flag=0;
for(int i=1;i<=boks;i++) {
    while(i==t[nowt+1].x&&nowt<m) {
        nowt++;
        q.push(t[nowt].v);
    }
    if(i==o[nowo+1].l&&nowo<n) {
        nowo++;
        int bas=o[nowo].len;
        while(q.size()!=0&&nowv<=bas) {
            nowv+=q.top();
            q.pop(),ans++;
        }
        if(!q.size()&&nowv<=bas) {
            puts("-1");
            flag=1;
            break;
        }
    }
}
```

#### 题解2：O_v_O (4星)

**关键亮点**：
- 代码简洁，逻辑清晰，易于实现。
- 使用了优先队列来维护能量提升点，符合贪心策略。

**核心代码**：
```cpp
priority_queue<int> q;
int sum = 1, cnt = 0;
for (int i = 1, j = 1; i <= n; i++) {
    while (j <= m && b[j].first < a[i].first) {
        q.push(b[j++].second);
    }
    while (!q.empty() && sum <= a[i].second - a[i].first + 1) {
        sum += q.top();
        cnt++;
        q.pop();
    }
    if (sum <= a[i].second - a[i].first + 1) {
        cout << -1 << '\n';
        return;
    }
}
cout << cnt << '\n';
```

#### 题解3：Bc2_ChickenDreamer (4星)

**关键亮点**：
- 强调了清空队列的重要性，避免了多测时的错误。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
priority_queue<int> pq;
int ans = 0, k = 1;
for (int pi = 1, si = 1; si <= n; ++ si) {
    for (; p[pi].a < s[si].a && pi <= m; pq.push(p[pi].b), ++ pi);
    for (; s[si].a + k <= s[si].b + 1 && !pq.empty(); k += pq.top(), ++ ans, pq.pop());
    if (s[si].a + k <= s[si].b + 1) {
        cout << "-1\n";
        k = 0;
        break;
    }
}
if (k) {
    cout << ans << '\n';
}
```

### 个人心得总结

- **调试经历**：多位作者提到在多测时清空队列的重要性，避免因未清空队列导致的错误。
- **踩坑教训**：在处理大规模数据时，离散化是有效的优化手段，可以显著提高代码效率。
- **顿悟感想**：贪心策略在处理此类问题时非常有效，优先队列的使用使得问题解决更加高效。

---
处理用时：45.99秒
# 题目信息

# Competitive Fishing

## 题目描述

Alice 和 Bob 参加了一个钓鱼比赛，他们一共钓到了 $n$ 条鱼，鱼的大小从 $1$ 到 $n$ 升序排序。

两人的总分计算如下：首先，选择一个整数 $m$，所有鱼都被依次分到 $m$ 个非空连续区间，一条鱼只能被分到一个区间，并且区间从小到大排列。比如：第二个区间的鱼必须全部大于第一个区间的鱼。

接着，每条鱼都按照区间编号被分配了分数，第 $1$ 个区间的鱼分数全部为 $0$，第 $1$ 个区间鱼的分数全部为 $1$……第 $i$ 个区间鱼的分数全部为 $(i-1)$。

两人的分数即为他们各自钓到鱼的分数之和。

你想要让 Bob 的分数比 Alice 高至少 $k$ 分。求划分的区间个数 $m$ 的最小值。

## 样例 #1

### 输入

```
7
4 1
1001
4 1
1010
4 1
0110
4 2
0110
6 3
001110
10 20
1111111111
5 11
11111```

### 输出

```
2
-1
2
-1
3
4
-1```

# AI分析结果

### 题目内容重写

**题目描述**

Alice 和 Bob 参加了一个钓鱼比赛，他们一共钓到了 $n$ 条鱼，鱼的大小从 $1$ 到 $n$ 升序排序。

两人的总分计算如下：首先，选择一个整数 $m$，所有鱼都被依次分到 $m$ 个非空连续区间，一条鱼只能被分到一个区间，并且区间从小到大排列。比如：第二个区间的鱼必须全部大于第一个区间的鱼。

接着，每条鱼都按照区间编号被分配了分数，第 $1$ 个区间的鱼分数全部为 $0$，第 $1$ 个区间鱼的分数全部为 $1$……第 $i$ 个区间鱼的分数全部为 $(i-1)$。

两人的分数即为他们各自钓到鱼的分数之和。

你想要让 Bob 的分数比 Alice 高至少 $k$ 分。求划分的区间个数 $m$ 的最小值。

### 题解综合分析与结论

本题的核心在于如何通过划分区间来最大化 Bob 的分数与 Alice 的分数之差。所有题解都采用了贪心策略，通过计算每个可能的分割点对分数的贡献，并选择贡献最大的分割点来逐步增加 Bob 的分数。

### 所选高星题解

#### 题解1：作者：HYdroKomide (4星)
**关键亮点**：
- 从后往前计算每个分割点的贡献，并排序后贪心选择。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=n;i>=1;i--){
    if(str[i]=='0')cnt0++;
    else cnt1++;
    a[i]=cnt1-cnt0;
}
sort(a+2,a+n+1);
long long sum=0,ans=1;
for(int i=n;i>1;i--){
    if(a[i]<=0)break;
    sum+=a[i],ans++;
    if(sum>=k)break;
}
if(sum<k)printf("-1\n");
else printf("%d\n",ans);
```
**核心思想**：从后往前计算每个分割点的贡献，排序后贪心选择，直到满足条件。

#### 题解2：作者：Hide_In_The_Shadow (4星)
**关键亮点**：
- 使用后缀和计算每个分割点的贡献，排序后贪心选择。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
for(int i=n;i>=1;--i){
    sum[i]=sum[i+1]+(s[i-1]-'0'?1:-1);
}
sort(sum+2,sum+n+1);
int ans=0,now=0;
for(int i=n;i>=2;--i){
    if(sum[i]<=0)break;
    now+=sum[i];
    ans++;
    if(now>=k)break;
}
if(now>=k)cout<<ans+1<<'\n';
else cout<<"-1\n";
```
**核心思想**：计算后缀和，排序后贪心选择分割点，直到满足条件。

#### 题解3：作者：__vector__ (4星)
**关键亮点**：
- 通过前缀和计算每个分割点的贡献，排序后贪心选择。
- 思路清晰，代码简洁。

**核心代码**：
```cpp
for(int i=n-1;i>=1;i--)
    sum[i]=sum[i+1]+a[i+1];
sort(sum+1,sum+n+1,greater<int>());
int tmp=0;
for(int i=1;i<=n;i++){
    tmp+=sum[i];
    if(tmp>=k){
        write(i+1),putchar('\n');
        flag=true;
        break;
    }
}
if(!flag)write(-1),putchar('\n');
```
**核心思想**：计算前缀和，排序后贪心选择分割点，直到满足条件。

### 最优关键思路或技巧
- **贪心策略**：通过计算每个分割点的贡献，并选择贡献最大的分割点来逐步增加 Bob 的分数。
- **后缀和/前缀和**：通过后缀和或前缀和来计算每个分割点的贡献，简化了问题的复杂度。

### 可拓展之处
- **类似问题**：类似的问题可以通过贪心策略和前缀和/后缀和来解决，例如区间划分、最大子段和等问题。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结
- **调试经历**：在计算分割点贡献时，需要注意边界条件的处理，例如不能包含首项。
- **踩坑教训**：在排序时，需要注意排序的范围，避免包含不必要的元素。
- **顿悟感想**：通过从后往前计算贡献，可以简化问题的复杂度，使得贪心策略更加直观和有效。

---
处理用时：37.48秒
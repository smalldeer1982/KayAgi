# 题目信息

# Kevin and Binary Strings

## 题目描述

Kevin 在月光河公园的河里发现了一个二进制字符串 $s$，它以 1 开头，并把它交给了你。你的任务是从 $s$ 中选择两个非空子串（允许重叠），以使得它们之间的异或值最大。

对于两个二进制字符串 $a$ 和 $b$，它们的异或结果是将 $a$ 和 $b$ 看作二进制数后，进行按位异或操作 $\oplus$ 所得到的结果，其中最左边的位即为最高位。可以参考[按位异或操作](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

你选择的字符串可以包含前导零。

## 说明/提示

在第一个测试用例中，我们可以选择 $s_2 = \texttt{1}$ 和 $s_1 s_2 s_3 = \texttt{111}$，此时 $\texttt{1} \oplus \texttt{111} = \texttt{110}$。可以证明这是可能得到的最大值。此外，选择 $l_1 = 3$，$r_1 = 3$，$l_2 = 1$，$r_2 = 3$ 也是一个有效的解决方案。

在第二个测试用例中，选择 $s_1 s_2 s_3 = \texttt{100}$ 和 $s_1 s_2 s_3 s_4 = \texttt{1000}$，则异或结果为 $\texttt{100} \oplus \texttt{1000} = \texttt{1100}$，也是最大的结果。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
111
1000
10111
11101
1100010001101```

### 输出

```
2 2 1 3
1 3 1 4
1 5 1 4
3 4 1 5
1 13 1 11```

# AI分析结果

### 题目内容重写
# Kevin 和二进制字符串

## 题目描述

Kevin 在月光河公园的河里发现了一个二进制字符串 $s$，它以 1 开头，并把它交给了你。你的任务是从 $s$ 中选择两个非空子串（允许重叠），以使得它们之间的异或值最大。

对于两个二进制字符串 $a$ 和 $b$，它们的异或结果是将 $a$ 和 $b$ 看作二进制数后，进行按位异或操作 $\oplus$ 所得到的结果，其中最左边的位即为最高位。可以参考[按位异或操作](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

你选择的字符串可以包含前导零。

## 说明/提示

在第一个测试用例中，我们可以选择 $s_2 = \texttt{1}$ 和 $s_1 s_2 s_3 = \texttt{111}$，此时 $\texttt{1} \oplus \texttt{111} = \texttt{110}$。可以证明这是可能得到的最大值。此外，选择 $l_1 = 3$，$r_1 = 3$，$l_2 = 1$，$r_2 = 3$ 也是一个有效的解决方案。

在第二个测试用例中，选择 $s_1 s_2 s_3 = \texttt{100}$ 和 $s_1 s_2 s_3 s_4 = \texttt{1000}$，则异或结果为 $\texttt{100} \oplus \texttt{1000} = \texttt{1100}$，也是最大的结果。

### 样例 #1

#### 输入

```
5
111
1000
10111
11101
1100010001101
```

#### 输出

```
2 2 1 3
1 3 1 4
1 5 1 4
3 4 1 5
1 13 1 11
```

### 题解分析与结论

#### 综合分析与结论
本题的核心目标是找到两个子串，使得它们的异或值最大。由于异或操作的性质，异或值的最大位数取决于两个子串的最高位。因此，为了最大化异或值，通常需要选择一个子串为整个字符串，另一个子串为从某个位置开始的子串，以尽可能多地改变高位。

各题解的主要思路如下：
1. **固定一个子串为整个字符串**：几乎所有题解都提到，为了最大化异或值，其中一个子串应选择整个字符串。
2. **寻找另一个子串**：另一个子串的选择通常基于从第一个 `0` 开始的位置，通过枚举或贪心策略找到最优的子串。
3. **优化策略**：部分题解通过预处理或贪心策略来减少时间复杂度，如利用 KMP 算法或按位贪心。

#### 所选高星题解

1. **作者：_Lazy_zhr_ (4星)**
   - **关键亮点**：通过固定一个子串为整个字符串，并找到第一个 `0` 的位置，然后枚举另一个子串，通过比较前缀 `1` 的长度来确定最优解。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=cnt;i++){
         int sum=0;
         bool x=true;
         for(int j=1;j<=len;j++){
             if(str[i][j]==f[j]) x=false;
             if(x) sum++;
         }
         if(sum>maxn){
             l=i,r=i+len-1;
             maxn=sum;
         }
     }
     ```
   - **个人心得**：强调了多测不清空的问题，提醒在竞赛中要注意细节。

2. **作者：lailai0916 (4星)**
   - **关键亮点**：利用 KMP 算法来匹配子串，通过按位取反的策略来最大化异或值。
   - **代码核心**：
     ```cpp
     int kmp(string s,string t){
         int n=s.size(),m=t.size();
         for(int i=1;i<m;i++){
             int j=nxt[i-1];
             while(j&&t[i]!=t[j])j=nxt[j-1];
             if(t[i]==t[j])j++;
             nxt[i]=j;
         }
         int j=0;
         for(int i=0;i<n;i++){
             while(j&&s[i]!=t[j])j=nxt[j-1];
             if(s[i]==t[j])j++;
             if(j==m)return i-m+1;
         }
         return -1;
     }
     ```
   - **个人心得**：通过 KMP 算法优化了子串匹配的过程，提高了效率。

3. **作者：_Kamisato_Ayaka_ (4星)**
   - **关键亮点**：通过暴力枚举所有可能的子串，选择异或值最大的组合，思路简单直接。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++){
         for(int j=i;j<=n;j++){
             // 计算异或值并记录最大值
         }
     }
     ```
   - **个人心得**：虽然时间复杂度较高，但思路清晰，适合初学者理解。

### 最优关键思路与技巧
1. **固定一个子串为整个字符串**：这是几乎所有题解的共同点，通过固定一个子串，可以简化问题并确保异或值的最高位被充分利用。
2. **按位贪心策略**：通过从高位到低位逐位比较，选择能够最大化异或值的子串。
3. **利用 KMP 算法优化匹配**：通过预处理和模式匹配算法，减少子串匹配的时间复杂度。

### 可拓展之处
- **类似问题**：可以扩展到其他位操作问题，如按位与、按位或等。
- **优化策略**：可以进一步优化子串选择的策略，如利用动态规划或贪心算法来减少时间复杂度。

### 推荐题目
1. [洛谷 P1010 幂次方](https://www.luogu.com.cn/problem/P1010)
2. [洛谷 P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)
3. [洛谷 P1036 选数](https://www.luogu.com.cn/problem/P1036)

### 个人心得总结
- **多测不清空，爆零两行泪**：在竞赛中，细节决定成败，尤其是在多组测试数据时，一定要确保每次测试前清空相关变量。
- **KMP 算法的应用**：KMP 算法在字符串匹配问题中非常高效，掌握它可以大幅提升解题效率。
- **暴力枚举的适用性**：虽然暴力枚举时间复杂度较高，但在某些情况下，它是最直接且易于理解的解决方案。

---
处理用时：52.22秒
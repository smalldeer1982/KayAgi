# 题目信息

# Digital string maximization

## 题目描述

给你一个由 $0$ 至 $9$ 的数字组成的字符串 $s$ 。在一次运算中，您可以选取该字符串中除 $0$ 或最左边数字之外的任意数字，将其减少 $1$ ，然后将其与左边的数字对调。

例如，从字符串 $1023$ 中进行一次运算，可以得到 $1103$ 或 $1022$ 。

找出任意多次运算后所能得到的字典序最大的字符串。

## 样例 #1

### 输入

```
6
19
1709
11555
51476
9876543210
5891917899```

### 输出

```
81
6710
33311
55431
9876543210
7875567711```

# AI分析结果

### 题目内容重写（中文）

#### 数字字符串最大化

##### 题目描述

给你一个由 $0$ 至 $9$ 的数字组成的字符串 $s$。在一次运算中，您可以选取该字符串中除 $0$ 或最左边数字之外的任意数字，将其减少 $1$，然后将其与左边的数字对调。

例如，从字符串 $1023$ 中进行一次运算，可以得到 $1103$ 或 $1022$。

找出任意多次运算后所能得到的字典序最大的字符串。

##### 样例 #1

###### 输入

```
6
19
1709
11555
51476
9876543210
5891917899
```

###### 输出

```
81
6710
33311
55431
9876543210
7875567711
```

### 题解分析与结论

#### 综合分析与结论

本题的核心思想是通过贪心算法，每次尽可能将较大的数字移动到高位，从而得到字典序最大的字符串。难点在于如何高效地确定每个位置的最大可能值，并处理数字移动时的减一操作。

各题解的思路基本一致，都是通过贪心策略，从前往后逐个位置确定最大可能值，并通过交换操作实现。不同点在于实现细节和优化程度。

#### 评分较高的题解

1. **作者：Drifty (赞：5)**  
   - **星级：5**  
   - **关键亮点**：代码简洁，逻辑清晰，直接通过双重循环确定每个位置的最大值，并通过交换操作实现。  
   - **核心代码**：
     ```cpp
     for (int i = 0; i < (int)s.size(); i ++) {
         int res = s[i], pos = i;
         for (int j = i + 1; j < min((int)s.size(), i + 11); j ++) 
             if ((int)s[j] - (j - i) > res) res = (int)s[j] - (j - i), pos = j;
         for (int j = pos; j > i; j --) swap(s[j], s[j - 1]), s[j - 1] --;
     }
     ```

2. **作者：xuyifei0302 (赞：1)**  
   - **星级：4**  
   - **关键亮点**：思路清晰，代码可读性较好，通过枚举每个位置的后9个字符来确定最大值，并进行交换操作。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= len; i ++) {
         int maxn = s[i] - '0', num = i;
         for (int j = 1; j <= 9 && i + j <= len; j ++) {
             if (maxn < s[i + j] - '0' - j) {
                 maxn = s[i + j] - '0' - j;
                 num = i + j;
             }
         }
         if (num == i) continue;
         for(int j = num; j > i; j --) {
             swap(s[j], s[j - 1]);
         }
         s[i] = maxn + '0'; 
     }
     ```

3. **作者：HYdroKomide (赞：0)**  
   - **星级：4**  
   - **关键亮点**：代码简洁，逻辑清晰，通过枚举每个位置的后10个字符来确定最大值，并进行交换操作。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int curmx = 0, curpos = i;
         for (int j = i; j <= i + 10 && j <= n; j++) {
             if (a[j] - '0' - (j - i) > curmx) {
                 curmx = a[j] - '0' - (j - i);
                 curpos = j;
             }
         }
         for (int j = curpos; j > i; j--) {
             swap(a[j], a[j - 1]);
             a[j - 1]--;
         }
     }
     ```

### 最优关键思路或技巧

1. **贪心策略**：从前往后逐个位置确定最大可能值，确保高位尽可能大。
2. **枚举范围**：每个位置只需枚举其后9或10个字符，减少计算量。
3. **交换操作**：通过交换操作实现数字移动，并处理减一操作。

### 可拓展之处

类似题目可以考察贪心算法在字符串处理中的应用，如通过交换、删除等操作最大化或最小化字符串的字典序。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)  
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)

---
处理用时：36.63秒
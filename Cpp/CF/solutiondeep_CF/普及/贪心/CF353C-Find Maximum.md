# 题目信息

# Find Maximum

## 题目描述

Valera 有一个 $n$ 个数的 **非负整数** 数组 $a$ ，其元素分别为 $a_0,a_1,\cdots,a_{n-1}$。同时有一个函数 $f(x)=\sum_{i=0}^{n-1}a_i\cdot bit(i)$，$bit(i)$ 指的是数字 $x$ 在二进制中第 $i$ 位的值是否为 1。

举个例子，当 $n=4,x=11(11=2^0+2^1+2^3)$ 时，$f(x)=a_0+a_1+a_3$。

对于所有 $0\le x \le m$ 的整数 $x$ ，请求出 $f(x)$ 的最大值。

## 说明/提示

- $1 \le n \le 10^5$

- $0 \le a_i \le 10^4$

- $0\le s_i \le 1$

## 样例 #1

### 输入

```
2
3 8
10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
17 0 10 2 1
11010
```

### 输出

```
27
```

# AI分析结果

【题目内容】
# 寻找最大值

## 题目描述

Valera 有一个包含 $n$ 个非负整数的数组 $a$，其元素分别为 $a_0,a_1,\cdots,a_{n-1}$。同时有一个函数 $f(x)=\sum_{i=0}^{n-1}a_i\cdot bit(i)$，其中 $bit(i)$ 表示数字 $x$ 在二进制中第 $i$ 位的值是否为 1。

例如，当 $n=4,x=11(11=2^0+2^1+2^3)$ 时，$f(x)=a_0+a_1+a_3$。

对于所有 $0\le x \le m$ 的整数 $x$，请求出 $f(x)$ 的最大值。

## 说明/提示

- $1 \le n \le 10^5$

- $0 \le a_i \le 10^4$

- $0\le s_i \le 1$

## 样例 #1

### 输入

```
2
3 8
10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
17 0 10 2 1
11010
```

### 输出

```
27
```

【题解分析与结论】

本题的核心在于如何在给定的限制下，通过贪心和动态规划的结合，找到 $f(x)$ 的最大值。以下是各题解的分析与对比：

1. **WaterSky 的题解**：
   - **思路**：通过贪心策略，尽可能多地选择 $a_i$，并结合动态规划进行状态转移。
   - **实现**：使用前缀和预处理，然后通过状态转移方程 $f_i = \max(f_i, f_{i-1} + a_i \cdot s_i)$ 求解。
   - **评分**：4星
   - **亮点**：思路清晰，代码简洁，动态规划的状态转移方程设计合理。

2. **Jr_Zlw 的题解**：
   - **思路**：从高位到低位考虑，通过前缀和和贪心策略，找到最大值的可能情况。
   - **实现**：从低位到高位计算前缀和，枚举每一位为1的情况，取最大值。
   - **评分**：4星
   - **亮点**：从高位到低位的贪心策略，时间复杂度优化到 $O(n)$。

3. **Graphcity 的题解**：
   - **思路**：通过动态规划，结合前缀和，找到在 $s_i=1$ 时的特殊情况，并进行状态转移。
   - **实现**：使用前缀和预处理，然后通过状态转移方程 $f_i = \max(f_i, f_{i-1} + a_i \cdot s_i)$ 求解。
   - **评分**：3星
   - **亮点**：思路与WaterSky类似，但代码实现稍显冗长。

【最优关键思路与技巧】
- **贪心策略**：尽可能多地选择 $a_i$，尤其是在 $s_i=1$ 的情况下。
- **动态规划**：通过状态转移方程 $f_i = \max(f_i, f_{i-1} + a_i \cdot s_i)$，结合前缀和，高效求解最大值。

【可拓展之处】
- 类似的问题可以扩展到其他进制或更复杂的限制条件下，贪心和动态规划的结合仍然适用。

【推荐题目】
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

【个人心得】
- **调试经历**：在处理前缀和时，注意数组的边界条件，避免越界。
- **顿悟感想**：贪心和动态规划的结合可以有效解决复杂的最优化问题，尤其是在有特定限制的情况下。

【核心代码片段】
```cpp
// WaterSky 的代码片段
for(int i=1;i<=n;i++) 
    dp[i]=max(dp[i],dp[i-1]+a[i]*S[i]); // 状态转移
```

```cpp
// Jr_Zlw 的代码片段
for(int i=n-1;~i;--i)if(s[i]=='1'){ans=max(ans,res+a[i]);res+=a[i+1]-a[i];}
```

---
处理用时：32.34秒
# 题目信息

# New Year Book Reading

## 题目描述

小明非常喜欢读书。他一共有 $n$ 本书，编号为 $1\sim n$，第 $i$本书重 $w_i$。

小明计划在暑假的 $m$ 天里每天读一本书，第 $i$ 天读第 $d_i$ 本书，可能会重复读到同一本书。

因为所有的书都是堆成一摞的，所以每次读某本书之前小明都需要先将这本书上面所有的书搬开，拿出这本书，再将搬开的书按原顺序放回去，消耗体力为搬开书的重量之和，读完这本书后将其放在这摞书的最上面。

小明想知道这 $n$ 本书以怎样的初始顺序放置，所搬书消耗总体力最小。

## 样例 #1

### 输入

```
3 5
1 2 3
1 3 2 3 1
```

### 输出

```
12
```

# AI分析结果

### 题目重写
小明非常喜欢读书。他一共有 $n$ 本书，编号为 $1\sim n$，第 $i$ 本书重 $w_i$。

小明计划在暑假的 $m$ 天里每天读一本书，第 $i$ 天读第 $d_i$ 本书，可能会重复读到同一本书。

因为所有的书都是堆成一摞的，所以每次读某本书之前小明都需要先将这本书上面所有的书搬开，拿出这本书，再将搬开的书按原顺序放回去，消耗体力为搬开书的重量之和，读完这本书后将其放在这摞书的最上面。

小明想知道这 $n$ 本书以怎样的初始顺序放置，所搬书消耗总体力最小。

### 样例 #1

#### 输入

```
3 5
1 2 3
1 3 2 3 1
```

#### 输出

```
12
```

### 题解分析与结论

#### 综合分析
本题的核心在于如何安排书的初始顺序，使得在 $m$ 天的阅读过程中，搬书的总体力消耗最小。通过分析，可以发现搬书的体力消耗与书的阅读顺序密切相关。因此，合理的初始顺序可以显著减少体力消耗。

#### 最优思路
1. **贪心策略**：按照书第一次被阅读的顺序来安排初始顺序。这样，每次阅读某本书时，搬动的书数量最少。
2. **模拟过程**：在确定初始顺序后，模拟每天的阅读过程，计算搬书的体力消耗。

#### 关键技巧
- **第一次阅读顺序**：通过记录每本书第一次被阅读的顺序，确定初始顺序。
- **模拟搬书过程**：在模拟过程中，每次阅读某本书时，计算其上方的书的重量总和，并更新书的顺序。

### 高星题解

#### 题解1：一叶知秋（5星）
**关键亮点**：
- **贪心策略**：明确提出了按照书第一次被阅读的顺序来安排初始顺序。
- **代码实现**：通过反序处理，简化了搬书过程的模拟。

**核心代码**：
```cpp
for(i=1;i<=m;i++){
    int s=0;
    for(j=k;j>=1;j--){//求第i次阅读的重量
        if(b[i]==xl[j])break;
        s+=a[xl[j]];
    }
    xl[++k]=xl[j];//划重点
    xl[j]=0;//划重点
    ans+=s;
}
```
**实现思想**：通过反序处理，每次阅读某本书时，计算其上方的书的重量总和，并更新书的顺序。

#### 题解2：LesterYu（4星）
**关键亮点**：
- **贪心策略**：同样采用了按照书第一次被阅读的顺序来安排初始顺序。
- **代码实现**：通过四个数组分别存储书的重量、每次取的书、书的堆放顺序和每本书的位置，简化了模拟过程。

**核心代码**：
```cpp
for(int i=1;i<=m;i++){
    scanf("%d",&t[i]);
    if(!l[t[i]]){//如果之前没有被选中过，则当作它在当前序列的底部 
        for(int j=1;j<i;j++) ans+=d[j];
        //ans加上序列中所有书的重量 
        d[i]=w[t[i]],l[t[i]]=i;//放到顶部 
        continue;
    }
    for(int j=l[t[i]]+1;j<i;j++) ans+=d[j];
    //如果之前被选中过，则把它拿上来，ans加上它上面书的重量 
    d[l[t[i]]]=0,d[i]=w[t[i]],l[t[i]]=i;//放到顶部 
}
```
**实现思想**：通过四个数组分别存储书的重量、每次取的书、书的堆放顺序和每本书的位置，简化了模拟过程。

#### 题解3：Luckies（4星）
**关键亮点**：
- **贪心策略**：明确提出了按照书第一次被阅读的顺序来安排初始顺序。
- **代码实现**：通过倒序枚举之前的书，计算搬书的体力消耗。

**核心代码**：
```cpp
for(int i=1;i<=m;i++){
    cin >> a[i];//输入要看的书
    memset(vis, 0, sizeof(vis));//对于每次阅读书，都要重新统计上面的所有书的总重量
    int sum = 0;
    for(int j=i-1;j>=1;j--)//倒序枚举之前看过的书
    {
        if(a[j]==a[i])//如果之前看过，那么a[j]前面的书就不需要搬动
            break;
        if(!vis[a[j]])//重复的书只统计一次重量
        {
            sum += w[a[j]];
            vis[a[j]] = true;//标记这本书已经统计过了，后面不计算重量
        }
    }
    ans += sum;//需要的体力加到总体力里面去
}
```
**实现思想**：通过倒序枚举之前的书，计算搬书的体力消耗，并标记已经统计过的书，避免重复计算。

### 推荐题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

这些题目都涉及到贪心策略和模拟过程，可以帮助巩固本题的解题思路。

---
处理用时：43.56秒
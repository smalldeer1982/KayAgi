# 题目信息

# Planning

## 题目描述

Helen在大都会机场工作，她的任务是安排每天的航班起飞时刻。今天一共有n架飞机将要起飞，第i架飞机将在第i分钟起飞。

大都会机场是大都会最重要的交通枢纽，因此想要原封不动地按照起飞时刻表的时刻起飞是很困难的。今天的情况也是如此：由于技术原因，在今天一开始的k分钟内飞机不允许起飞，因此必须创建一个新的起飞时刻表。

所有的航班必须在第(k+1)分钟到第(k+n)分钟内(包括两端)起飞，而且每分钟仅能有一架飞机起飞。然而，航班起飞的先后顺序可以与最初的时刻表排好的顺序不同，重排的时刻表只有一个限制：飞机不能比它在初始时刻表中起飞的时刻还要早的时刻起飞(即：第i架飞机必须在第i分钟后或第i分钟时起飞)。

Helen知道第i架飞机起飞时刻每延误一分钟机场所需支付的额外花费ci是多少。帮助她找到额外花费最小的方案。

## 说明/提示

在样例中，如果Helen仅把每架飞机的起飞时刻都推迟2分钟，那么总额外花费是38。
但是，对于最佳结果来说，总额外花费为20。

感谢@radish布団  提供的翻译

## 样例 #1

### 输入

```
5 2
4 2 1 10 2
```

### 输出

```
20
3 6 7 4 5 
```

# AI分析结果

【题目内容】
# Planning

## 题目描述

Helen在大都会机场工作，她的任务是安排每天的航班起飞时刻。今天一共有n架飞机将要起飞，第i架飞机将在第i分钟起飞。

大都会机场是大都会最重要的交通枢纽，因此想要原封不动地按照起飞时刻表的时刻起飞是很困难的。今天的情况也是如此：由于技术原因，在今天一开始的k分钟内飞机不允许起飞，因此必须创建一个新的起飞时刻表。

所有的航班必须在第(k+1)分钟到第(k+n)分钟内(包括两端)起飞，而且每分钟仅能有一架飞机起飞。然而，航班起飞的先后顺序可以与最初的时刻表排好的顺序不同，重排的时刻表只有一个限制：飞机不能比它在初始时刻表中起飞的时刻还要早的时刻起飞(即：第i架飞机必须在第i分钟后或第i分钟时起飞)。

Helen知道第i架飞机起飞时刻每延误一分钟机场所需支付的额外花费ci是多少。帮助她找到额外花费最小的方案。

## 说明/提示

在样例中，如果Helen仅把每架飞机的起飞时刻都推迟2分钟，那么总额外花费是38。
但是，对于最佳结果来说，总额外花费为20。

感谢@radish布団  提供的翻译

## 样例 #1

### 输入

```
5 2
4 2 1 10 2
```

### 输出

```
20
3 6 7 4 5 
```

【题解分析与结论】

### 综合分析
本题的核心是通过贪心算法和优先队列（堆）来最小化航班延误的总成本。所有题解都围绕这一核心展开，但实现细节和优化程度有所不同。大多数题解使用了优先队列来动态选择当前延误成本最大的航班，并为其分配最早可用的起飞时间。

### 最优关键思路
1. **贪心策略**：优先处理延误成本最高的航班，使其尽可能早地起飞，以减少总成本。
2. **优先队列**：使用大根堆（优先队列）来维护当前可处理的航班，确保每次都能选择延误成本最大的航班。
3. **时间分配**：通过遍历时间区间（k+1到k+n），动态分配起飞时间，并确保不违反航班的最早起飞时间限制。

### 推荐题解
1. **作者：NaN_HQJ2007_NaN (赞：14)**
   - **星级**：5星
   - **关键亮点**：详细解释了贪心策略和优先队列的使用，代码结构清晰，注释详细。
   - **代码核心**：
     ```cpp
     priority_queue<node,vector<node>,cmp1> q;
     for(i=1;i<=1+k;i++) q.push(a[i]);
     lie=k+1,hang=k+2;
     tong[q.top().id]=lie;
     ans+=(lie-q.top().id)*q.top().m;
     q.pop();
     for(i=2;i<=n;i++){
         if(hang<=n) q.push(a[hang]);
         if(hang<=n) hang++;
         lie++;
         ans+=(lie-q.top().id)*q.top().m;
         tong[q.top().id]=lie;
         q.pop();
     }
     ```

2. **作者：爬行者小郑 (赞：5)**
   - **星级**：4星
   - **关键亮点**：简洁明了地展示了优先队列的使用，代码易于理解。
   - **代码核心**：
     ```cpp
     priority_queue<Node>q;
     for(int i=1;i<=k;i++) q.push(t[i]);
     for(int i=k+1;i<=k+n;i++){
         q.push(t[i]);
         tmp=q.top();q.pop();
         ans[tmp.id]=i;
         all+=(long long)(tmp.c)*(long long)(i-tmp.id);
     }
     ```

3. **作者：Juanzhang (赞：5)**
   - **星级**：4星
   - **关键亮点**：提供了贪心+线段树的实现，虽然复杂度较高，但展示了不同的解题思路。
   - **代码核心**：
     ```cpp
     priority_queue <pii> q;
     for (int i = 1; i <= n; i++) q.push(make_pair(w[i], i));
     for (int i = k + 1; i <= k + n; i++) {
         pii node = q.top(); q.pop();
         ans[node.second] = i;
         sum += 1ll * node.first * (i - node.second);
     }
     ```

### 扩展思路
- **并查集**：可以用于优化时间分配，减少查找可用时间的时间复杂度。
- **线段树**：虽然在本题目中不如优先队列高效，但在某些变体中可能有用。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

### 个人心得摘录
- **NaN_HQJ2007_NaN**：强调了贪心策略的重要性，并详细解释了优先队列的使用，避免了常见的错误。
- **爬行者小郑**：通过简洁的代码展示了优先队列的强大功能，适合初学者理解。
- **Juanzhang**：虽然线段树实现较慢，但提供了另一种解题思路，值得学习。

---
处理用时：39.01秒
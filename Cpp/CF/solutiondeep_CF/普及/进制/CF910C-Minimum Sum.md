# 题目信息

# Minimum Sum

## 题目描述

Petya 有一个长度为n的正整数序列 $a_{1},a_{2},...,a_{n}$。他的朋友Vasya 想要捉弄他，Vasya用一个字母替换了Petya 的号码中的所有数字。

他用小写字母‘a’到‘j’中的一个字母替换了所有数字 0，用另一个字母替换了所有 1，依次类推。对于不同的两个数字，Vasya 用‘a’到‘j’中不同的字母。

你的任务是还原 Petya 的序列。还原得到的数字应是没有前导零（数字开头没有零）的正整数。由于可能有多种方式实现，所以要求恢复后的序列总和最小。保证初始时序列中数字没有前导零。

## 样例 #1

### 输入

```
3
ab
de
aj
```

### 输出

```
47
```

## 样例 #2

### 输入

```
5
abcdef
ghij
bdef
accbd
g
```

### 输出

```
136542
```

## 样例 #3

### 输入

```
3
aa
jj
aa
```

### 输出

```
44
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是贪心算法。先计算每个字母对总和的贡献（即出现次数乘以对应位权值），再根据贡献大小为字母分配数字，同时要注意不能有前导零。

#### 思路对比
- **统计贡献**：各题解均通过遍历输入的字符串，计算每个字母在不同位上的贡献总和。
- **处理前导零**：都对出现在字符串首位的字母进行标记，确保其不被赋值为 0。
- **分配数字**：将字母按贡献从大到小排序，优先将小数字分配给贡献大的字母，把 0 分配给贡献大且不是前导的字母。

#### 算法要点对比
- **数据结构**：部分题解使用结构体存储字母的贡献、是否为前导等信息；部分使用 `pair` 或 `unordered_map`。
- **排序**：大多使用 `sort` 函数按贡献对字母进行排序。

#### 解决难点对比
- **前导零处理**：多数题解通过标记首位字母，在分配数字时跳过这些字母来避免前导零。
- **0 的分配**：找到贡献最大且不是前导的字母，将其赋值为 0。

#### 评分
- **chengni**：4 星。思路清晰，代码简洁，注释较少但逻辑易懂。
- **codeLJH114514**：4 星。思路详细，代码结构清晰，使用自定义结构体便于理解。
- **1qaz234567pzy**：3 星。思路正确，代码实现较简单，但注释较少。

### 所选题解
- **chengni（4 星）**
  - **关键亮点**：代码简洁，逻辑清晰，通过自定义 `read` 函数提高输入效率。
  - **个人心得**：无。
- **codeLJH114514（4 星）**
  - **关键亮点**：思路详细，使用自定义结构体存储字母信息，便于排序和处理。
  - **个人心得**：无。

### 重点代码
#### chengni 的核心代码
```cpp
struct node {
    int a,b;
}t[100000];

bool cmp(node x,node y){
    return x.a>y.a;
}

int main(){
    int n=read();
    for(int i=1;i<=n;i++){
        cin>>c;
        int l=strlen(c);
        for(int j=0;j<l;j++){
            t[c[j]-'a'+1].a+=pos(l-j-1);
            if(j==0) t[c[j]-'a'+1].b=1;
        }
    }
    sort(t+1,t+11,cmp);
    for(int i=1;i<=10;i++){
        if(t[i].b==0 && t[i].a!=0){
            t[i].a=0;
            break;
        }
    }
    int ans=0,sum=1;
    for(int i=1;i<=10;i++){
        if(t[i].a!=0){
            ans+=t[i].a*sum;
            sum++;
        }
    }
    cout<<ans<<endl;
} 
```
**核心实现思想**：先统计每个字母的贡献和是否为前导，排序后找到可赋值为 0 的字母，最后计算总和。

#### codeLJH114514 的核心代码
```cpp
class Node{
    public:
        int v, k; 
        bool t; 
        char ch; 
        bool operator<(const Node& n) const& {
            return k > n.k;
        } 
} d[12]; 

int main() {
    cin >> n;
    for (int i = 1; i <= 10; i++) d[i].ch = i + 'a' - 1;
    for (int i = 1; i <= n; i++) {
        cin >> s;
        d[s[0] - 'a' + 1].t = true;
        for (int j = 0; j < s.size(); j++)
            d[s[j] - 'a' + 1].k += pow(10, s.size() - j - 1);
    }
    sort(d + 1, d + 10 + 1);
    int zero = 0;
    for (int i = 1; i <= 10; i++) {
        if (not d[i].t) {
            zero = i;
            break;
        }
    }
    for (int i = 1; i <= 10; i++) d[i].v = -1;
    d[zero].v = 0;
    int cnt = 1;
    for (int i = 1; i <= 10; i++)
        if (d[i].v == -1)
            d[i].v = cnt++;
    int ans = 0;
    for (int i = 1; i <= 10; i++)
        ans += d[i].v * d[i].k;
    cout << ans;
    return 0;
}
```
**核心实现思想**：使用自定义结构体存储字母信息，统计贡献和前导情况，排序后找到可赋值为 0 的字母，分配数字并计算总和。

### 最优关键思路或技巧
- **贪心策略**：让贡献大的字母对应小的数字，以保证总和最小。
- **前导零处理**：标记出现在字符串首位的字母，避免其被赋值为 0。

### 拓展思路
同类型题可能会有不同的字符集或限制条件，如字母范围扩大、有更多的限制规则等。类似算法套路可应用于其他贪心问题，如资源分配、任务调度等，关键在于找到合适的贪心策略和处理特殊情况。

### 推荐题目
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P2240 【深基12.例1】部分背包问题](https://www.luogu.com.cn/problem/P2240)

### 个人心得摘录与总结
- **1qaz234567pzy**：“然鹅我交了三遍才过”，说明即使思路正确，在实现过程中也可能出现一些细节问题，需要仔细调试。 

---
处理用时：40.85秒
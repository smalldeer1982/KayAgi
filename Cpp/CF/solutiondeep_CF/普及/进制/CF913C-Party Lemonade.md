# 题目信息

# Party Lemonade

## 题目描述

题意

没有柠檬水的新年派对不是新年派对。像往常一样，你期待着客人，而柠檬水已经成为一种令人愉快的必需品。
你最喜欢的商店卖 n 种不同价格的装在不同瓶子里的柠檬水。一瓶第 i 种柠檬水，体积为2^{i-1}，价格为c_{i}卢布。商店里的每种柠檬水可以被认为有无限瓶。
你想要买至少 L 升的柠檬水，你需要花费多少卢布？

## 样例 #1

### 输入

```
4 12
20 30 70 90
```

### 输出

```
150
```

## 样例 #2

### 输入

```
4 3
10000 1000 100 10
```

### 输出

```
10
```

## 样例 #3

### 输入

```
4 3
10 100 1000 10000
```

### 输出

```
30
```

## 样例 #4

### 输入

```
5 787787787
123456789 234567890 345678901 456789012 987654321
```

### 输出

```
44981600785557577
```

# AI分析结果

### 题目翻译
#### Party Lemonade
没有柠檬水的新年派对就不能称之为新年派对。和往常一样，你在期待着客人的到来，而柠檬水已经成为了令人愉悦的必需品。

你最喜欢的商店出售 $n$ 种不同价格、不同瓶装体积的柠檬水。第 $i$ 种柠檬水一瓶的体积为 $2^{i - 1}$ 升，价格为 $c_i$ 卢布。商店里每种柠檬水的库存都可以视为无限。

你想要购买至少 $L$ 升的柠檬水，那么你最少需要花费多少卢布呢？

#### 样例 #1
##### 输入
```
4 12
20 30 70 90
```
##### 输出
```
150
```

#### 样例 #2
##### 输入
```
4 3
10000 1000 100 10
```
##### 输出
```
10
```

#### 样例 #3
##### 输入
```
4 3
10 100 1000 10000
```
##### 输出
```
30
```

#### 样例 #4
##### 输入
```
5 787787787
123456789 234567890 345678901 456789012 987654321
```
##### 输出
```
44981600785557577
```

### 综合分析与结论
这些题解的核心思路都是基于贪心策略，利用题目中柠檬水体积为 $2$ 的幂次这一特性，对不同体积柠檬水的价格进行预处理，以找到购买至少 $L$ 升柠檬水的最小花费。主要步骤包括：
1. **价格预处理**：比较 $2\times c_i$ 与 $c_{i + 1}$ 的大小，更新 $c_{i + 1}$ 为两者中的较小值，确保购买大体积柠檬水不会比购买小体积柠檬水更贵。
2. **二进制分解**：将 $L$ 转换为二进制，根据二进制位来考虑购买方案。
3. **贪心选择**：在满足至少购买 $L$ 升柠檬水的条件下，从高位到低位依次考虑每个二进制位，选择最优的购买方案。

各题解的主要区别在于实现方式和处理细节，如是否使用二分查找、递归等。

### 所选题解
- **Eric_jx（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，直接对价格进行预处理，然后根据 $L$ 的二进制位计算最小花费。
    - **个人心得**：无
```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[1005],num[1005];
int main(){
    long long n,l,ans=0,cnt=0;
    cin>>n>>l;
    while(l!=0){
        num[cnt++]=l%2,l/=2;
    }
    cin>>c[0];
    for(int i=1;i<n;i++){
        cin>>c[i];
        c[i]=min(c[i],c[i-1]*2);
    }
    for(int i=n;i<cnt;i++){
        c[i]=c[i-1]*2;
    }
    for(int i=0;i<max(n,cnt);i++){
        ans=min(ans,c[i]);
        if(num[i]==1) ans+=c[i];
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先将 $L$ 转换为二进制存储在 `num` 数组中，然后对价格数组 `c` 进行预处理，确保购买大体积柠檬水不会比购买小体积柠檬水更贵。最后根据二进制位计算最小花费。

- **Overstars（4星）**
    - **关键亮点**：使用 $dp$ 数组记录购买 $2^i$ 升柠檬水的最小花费，从高位到低位扫描 $L$ 的二进制位，依次累加消除每一位的代价，并在每一位尝试多买一份以得到更优解。
    - **个人心得**：无
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=210,inf=0x3f3f3f3f,mod=1000000007;
ll c[maxn],dp[maxn];
signed main()
{
    ll n,l,x,y;
    cin>>n>>l;
    for(int i=0;i<n;i++)
        cin>>c[i];
    dp[0]=c[0];
    for(int i=1;i<n;i++)//购买2^i最小代价
        dp[i]=min(c[i],dp[i-1]*2);
    ll ans=LLONG_MAX,sum=0;
    for(ll i=n-1;i>=0;i--)
    {//高位到低位
        ll des=l/(1ll<<i);
        sum+=des*dp[i];//累计代价
        l&=(1<<i)-1;//保留低位
        ans=min(ans,sum+(l>0)*dp[i]);
    }
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：先计算购买 $2^i$ 升柠檬水的最小花费存储在 `dp` 数组中，然后从高位到低位扫描 $L$ 的二进制位，累加消除每一位的代价，并在每一位尝试多买一份以更新最小花费。

- **CheerJustice（4星）**
    - **关键亮点**：通过快读优化输入，将 $L$ 转换为二进制，预处理价格数组，然后根据二进制位计算最小花费，并特判购买超过 $L$ 升柠檬水的情况。
    - **个人心得**：无
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
inline int in(){
    char c=getchar();int f=1;int x;
    while((c<'0'||c>'9')&&c!='-') c=getchar();
    if(c=='-')f=-1,c=getchar();
    for(x=0;c>='0'&&c<='9';c=getchar())
        x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}
template <typename T>
inline void in(T &x){
    char c=getchar();int f=1;
    while((c<'0'||c>'9')&&c!='-') c=getchar();
    if(c=='-')f=-1,c=getchar();
    for(x=0;c>='0'&&c<='9';c=getchar())
        x=(x<<3)+(x<<1)+(c^48);
    x*=f;
}
int n,l,len;
bool num[35];
ll c[35],ans;
int main(){
    in(n),in(l); 
    while(l) num[len++]=l&1,l>>=1; // 转二进制
    for(int i=0;i<n;++i){
        in(c[i]);
        if(i)c[i]=min(c[i],c[i-1]<<1);//处理c[i]，注意下标从0开始
    }
    for(int i=n;i<len;++i)c[i]=c[i-1]<<1;
    for(int i=0;i<max(n,len);++i){
        ans=min(ans,c[i]);// 如上文所说，特判
        if(num[i])ans+=c[i];
    }
    printf("%lld\n",ans);
    return 0;
}
```
核心实现思想：先将 $L$ 转换为二进制存储在 `num` 数组中，然后对价格数组 `c` 进行预处理，确保购买大体积柠檬水不会比购买小体积柠檬水更贵。最后根据二进制位计算最小花费，并特判购买超过 $L$ 升柠檬水的情况。

### 最优关键思路或技巧
- **价格预处理**：比较 $2\times c_i$ 与 $c_{i + 1}$ 的大小，更新 $c_{i + 1}$ 为两者中的较小值，确保购买大体积柠檬水不会比购买小体积柠檬水更贵。
- **二进制分解**：将 $L$ 转换为二进制，根据二进制位来考虑购买方案，利用二进制的特性进行贪心选择。
- **贪心策略**：在满足至少购买 $L$ 升柠檬水的条件下，从高位到低位依次考虑每个二进制位，选择最优的购买方案。

### 可拓展之处
同类型题或类似算法套路：
- **多重背包问题**：本题虽然因为 $L$ 的数值较大不能用多重背包来解，但多重背包问题的基本思想可以作为参考。
- **贪心算法**：在处理一些具有贪心性质的问题时，可以考虑类似的思路，通过预处理和贪心选择来找到最优解。

### 推荐题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：考察贪心算法的应用。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：同样是贪心算法的经典题目。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：涉及贪心策略的选择。

### 个人心得摘录与总结
- **elijahqi**：提到细节太多导致 fail system test，说明在处理这类问题时需要注意细节，如边界条件、特殊情况的处理等。

---
处理用时：58.82秒
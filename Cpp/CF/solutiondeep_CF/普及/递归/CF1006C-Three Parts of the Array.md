# 题目信息

# Three Parts of the Array

## 题目描述

**问题描述**  
给定一个长度为n的整数序列$\{d_1,d_2,\dots,d_n\}$。  
你的任务是将序列分成3部分，每部分可以是空的，并保证每一个数都属于这三个部分的某一个，每一部分都必须是一些连续的整数。  
设三部分的和分别为$sum_1$,$sum_2$,$sum_3$。  那么你需要在所有划分方案中找到一个方案使得$sum_1=sum_3$且$sum_1$尽可能的大。  
确切的说，如果第一部分包含$a$个整数，第二部分包含$b$个整数而第三部分包含$c$个，那么应该有
$$sum_1 = \sum\limits_{1 \le i \le a}d_i,$$
$$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,$$
$$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.$$
并且对于空的那部分，它的和为0。  
你需要在所有划分方案中找到一个方案使得$sum_1=sum_3$且$sum_1$尽可能的大。

## 样例 #1

### 输入

```
5
1 3 1 1 4
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
1 3 2 1 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
3
4 1 2
```

### 输出

```
0
```

# AI分析结果

### 题目翻译
#### 数组的三个部分

#### 题目描述
给定一个长度为 $n$ 的整数序列 $\{d_1, d_2, \dots, d_n\}$。
你的任务是将该序列分成 3 部分，每部分可以为空，并且要保证每个数都属于这三个部分中的某一个，每一部分都必须由一些连续的整数组成。
设三部分的和分别为 $sum_1$，$sum_2$，$sum_3$。那么你需要在所有划分方案中找到一个方案，使得 $sum_1 = sum_3$ 且 $sum_1$ 尽可能大。
确切地说，如果第一部分包含 $a$ 个整数，第二部分包含 $b$ 个整数，而第三部分包含 $c$ 个整数，那么应该有：
$$sum_1 = \sum\limits_{1 \le i \le a}d_i$$
$$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i$$
$$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i$$
并且对于空的那部分，其和为 0。
你需要在所有划分方案中找到一个方案，使得 $sum_1 = sum_3$ 且 $sum_1$ 尽可能大。

#### 样例 #1
##### 输入
```
5
1 3 1 1 4
```
##### 输出
```
5
```

#### 样例 #2
##### 输入
```
5
1 3 2 1 4
```
##### 输出
```
4
```

#### 样例 #3
##### 输入
```
3
4 1 2
```
##### 输出
```
0
```

### 综合分析与结论
这些题解主要围绕如何将序列分成三部分，使得第一部分和第三部分的和相等且该和尽可能大这一问题展开。思路主要分为二分查找和双指针两种。

#### 思路对比
- **二分查找**：枚举第一段区间的结尾，然后二分查找满足条件的第三段区间的起始位置。如 communist、lsw1、Na2PtCl6 的题解。
- **双指针**：使用两个指针分别从序列两端向中间移动，根据左右两部分的和的大小关系移动指针。如 信守天下、GoldenFishX、lsw1、cyrxdzj、happy_dengziyue、小闸蟹的题解。

#### 算法要点
- **二分查找**：需要预处理前缀和数组，利用 `lower_bound` 或 `upper_bound` 进行查找。
- **双指针**：通过比较左右两部分的和，动态调整指针位置，更新最大和。

#### 解决难点
- **二分查找**：需要注意边界条件和查找范围，避免找到不符合要求的分割点。
- **双指针**：要正确处理指针移动的条件和时机，确保找到最优解。

### 评分
| 作者 | 评分 | 理由 |
| ---- | ---- | ---- |
| communist | 4星 | 思路清晰，代码简洁，使用二分查找解决问题。 |
| 信守天下 | 4星 | 详细解释了前缀和的概念，双指针思路清晰，代码可读性高。 |
| GoldenFishX | 4星 | 明确指出题目的坑点，双指针思路简洁明了。 |
| lsw1 | 3星 | 提供了二分和尺取法两种思路，但解释不够详细。 |
| Na2PtCl6 | 3星 | 提出了二分查找时的注意事项，但代码中存在拼写错误。 |
| cyrxdzj | 3星 | 思路简单直接，但代码注释不够详细。 |
| happy_dengziyue | 3星 | 思路清晰，但代码结构稍显复杂。 |
| 小闸蟹 | 3星 | 使用递归实现双指针，代码可读性一般。 |

### 所选题解
- **communist（4星）**
    - **关键亮点**：思路清晰，代码简洁，使用二分查找解决问题。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=2e5+10;
int n;
long long sum[maxn],ans;
int main()
{
    scanf("%d",&n);
    for(int x,i=1;i<=n;i++)
    {
        scanf("%d",&x);
        sum[i]=sum[i-1]+x;
    }
    for(int i=1;i<=n;i++)
        if(sum[i]<=sum[n]/2)
        {
            int x=lower_bound(sum+1,sum+n+1,sum[n]-sum[i])-sum;
            if(x>=i&&sum[x]==sum[n]-sum[i])
                ans=sum[i];
        }
    printf("%lld\n",ans);
    return 0;
}
```
- **信守天下（4星）**
    - **关键亮点**：详细解释了前缀和的概念，双指针思路清晰，代码可读性高。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
const int kMaxN = 10000001;
long long a[kMaxN], ans;
int n;
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    a[i] += a[i - 1];
  }
  for (int l = 1, r = n; l <= r; l++){
    for ( ; a[n] - a[r] < a[l] && r >= l ; r--);
    if (r >= l && a[n] - a[r] == a[l]) {
      ans = a[l];
    }
  }
  cout << ans;
  return 0;
}
```
- **GoldenFishX（4星）**
    - **关键亮点**：明确指出题目的坑点，双指针思路简洁明了。
    - **核心代码**：
```cpp
long long suml = a[0], sumr = a[n - 1];
int l = 0, r = n - 1;
while(l < r) {
    if(sumr == suml) {
        ans = sumr;
    }
    if(suml > sumr) {
        sumr += a[--r];
    } else {
        suml += a[++l];
    }
}
```

### 最优关键思路或技巧
- **前缀和**：预处理前缀和数组可以快速计算任意区间的和，时间复杂度为 $O(1)$。
- **双指针**：通过双指针从两端向中间移动，动态调整左右两部分的和，避免了枚举所有可能的划分方案，时间复杂度为 $O(n)$。

### 可拓展之处
同类型题或类似算法套路：
- 数组划分问题，如将数组分成若干部分，满足特定条件。
- 双指针算法，可用于解决区间和、子数组问题等。

### 洛谷推荐题目
- [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
- [P1873 砍树](https://www.luogu.com.cn/problem/P1873)
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)

### 个人心得摘录与总结
- **Na2PtCl6**：找相等的前缀和别用 `lower_bound`，应该用 `upper_bound` 找到的指针位 - 1，避免将不符合要求的分割当成正确的。总结：在使用二分查找时，要注意边界条件和查找范围，避免出现错误。

---
处理用时：49.69秒
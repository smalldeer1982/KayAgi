# 题目信息

# Party Lemonade

## 题目描述

题意

没有柠檬水的新年派对不是新年派对。像往常一样，你期待着客人，而柠檬水已经成为一种令人愉快的必需品。
你最喜欢的商店卖 n 种不同价格的装在不同瓶子里的柠檬水。一瓶第 i 种柠檬水，体积为2^{i-1}，价格为c_{i}卢布。商店里的每种柠檬水可以被认为有无限瓶。
你想要买至少 L 升的柠檬水，你需要花费多少卢布？

## 样例 #1

### 输入

```
4 12
20 30 70 90
```

### 输出

```
150
```

## 样例 #2

### 输入

```
4 3
10000 1000 100 10
```

### 输出

```
10
```

## 样例 #3

### 输入

```
4 3
10 100 1000 10000
```

### 输出

```
30
```

## 样例 #4

### 输入

```
5 787787787
123456789 234567890 345678901 456789012 987654321
```

### 输出

```
44981600785557577
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是利用柠檬水体积为 $2$ 的幂次这一特点，通过预处理得到购买 $2^i$ 体积柠檬水的最小花费，再结合贪心或动态规划的思想来求解。

- **思路对比**：多数题解采用贪心策略，如 Eric_jx、囧仙、Overstars 等，通过比较不同体积柠檬水的价格关系，预处理出最优价格，再从高位到低位处理 $L$ 的二进制位。而 JimmyLee 则是按性价比排序选择瓶子。
- **算法要点**：大部分题解的关键在于预处理价格，即对于 $c_i$ 和 $c_{i - 1}$，取 $c_i = \min(c_i, c_{i - 1} \times 2)$，保证购买大体积柠檬水更划算。在处理 $L$ 时，考虑直接购买当前位对应的体积或多买一份来覆盖低位。
- **解决难点**：主要难点在于处理购买量大于等于 $L$ 的情况，不同题解采用不同方法，如枚举高位多买的情况、二分查找等。

### 所选题解
- **Eric_jx（5星）**
  - **关键亮点**：思路清晰，代码简洁，直接处理 $L$ 的二进制位，通过预处理价格和遍历二进制位得到最优解。
  - **个人心得**：提醒不开 long long 会出错，强调了数据范围的重要性。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[1005],num[1005];
int main(){
    long long n,l,ans=0,cnt=0;
    cin>>n>>l;
    while(l!=0){
        num[cnt++]=l%2,l/=2;
    }
    cin>>c[0];
    for(int i=1;i<n;i++){
        cin>>c[i];
        c[i]=min(c[i],c[i-1]*2);
    }
    for(int i=n;i<cnt;i++){
        c[i]=c[i-1]*2;
    }
    for(int i=0;i<max(n,cnt);i++){
        ans=min(ans,c[i]);
        if(num[i]==1) ans+=c[i];
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先将 $L$ 转换为二进制，然后预处理出购买 $2^i$ 体积柠檬水的最小花费，最后遍历二进制位累加花费。

- **Overstars（4星）**
  - **关键亮点**：使用动态规划预处理购买 $2^i$ 体积柠檬水的最小花费，再从高位到低位处理 $L$ 的二进制位，通过比较不同选择得到最优解。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=210,inf=0x3f3f3f3f,mod=1000000007;
ll c[maxn],dp[maxn];
signed main()
{
    ll n,l,x,y;
    cin>>n>>l;
    for(int i=0;i<n;i++)
        cin>>c[i];
    dp[0]=c[0];
    for(int i=1;i<n;i++)//购买2^i最小代价
        dp[i]=min(c[i],dp[i-1]*2);
    ll ans=LLONG_MAX,sum=0;
    for(ll i=n-1;i>=0;i--)
    {//高位到低位
        ll des=l/(1ll<<i);
        sum+=des*dp[i];//累计代价
        l&=(1<<i)-1;//保留低位
        ans=min(ans,sum+(l>0)*dp[i]);
    }
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：用 $dp$ 数组记录购买 $2^i$ 体积柠檬水的最小花费，从高位到低位处理 $L$ 的二进制位，累加代价并比较不同选择。

- **CheerJustice（4星）**
  - **关键亮点**：通过二进制分解 $L$，预处理价格，直接累加对应二进制位的花费，并特判购买量大于 $L$ 的情况。
```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n,l,len;
bool num[35];
ll c[35],ans;
int main(){
    cin>>n>>l; 
    while(l) num[len++]=l&1,l>>=1; // 转二进制
    for(int i=0;i<n;++i){
        cin>>c[i];
        if(i)c[i]=min(c[i],c[i-1]<<1);//处理c[i]，注意下标从0开始
    }
    for(int i=n;i<len;++i)c[i]=c[i-1]<<1;
    for(int i=0;i<max(n,len);++i){
        ans=min(ans,c[i]);// 如上文所说，特判
        if(num[i])ans+=c[i];
    }
    printf("%lld\n",ans);
    return 0;
}
```
核心实现思想：将 $L$ 转换为二进制，预处理价格，遍历二进制位累加花费并特判。

### 最优关键思路或技巧
- **预处理价格**：通过比较 $c_i$ 和 $c_{i - 1} \times 2$ 的大小，取最小值更新 $c_i$，保证购买大体积柠檬水更划算。
- **二进制处理**：将 $L$ 转换为二进制，从高位到低位处理，利用二进制的特性进行贪心选择。

### 可拓展之处
同类型题或类似算法套路：涉及物品体积为 $2$ 的幂次、需要进行贪心选择的问题，如背包问题的变种、资源分配问题等。可以参考二进制优化的多重背包问题。

### 推荐题目
- [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)：二进制优化的多重背包问题。
- [P2340 [USACO03FALL]Cow Exhibition G](https://www.luogu.com.cn/problem/P2340)：涉及物品选择和价值计算的问题。
- [P1853 投资的最大效益](https://www.luogu.com.cn/problem/P1853)：资源分配和贪心选择的问题。

### 个人心得摘录与总结
- **Eric_jx**：提醒不开 long long 会出错，强调了数据范围的重要性，在处理大数据时要注意数据类型的选择。
- **elijahqi**：提到细节太多导致 system test 失败，说明在实现过程中要注意细节处理，尤其是边界条件和特殊情况。

---
处理用时：43.69秒
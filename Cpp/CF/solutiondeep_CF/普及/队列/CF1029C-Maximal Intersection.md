# 题目信息

# Maximal Intersection

## 题目描述

给定n个闭区间,现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

## 样例 #1

### 输入

```
4
1 3
2 6
0 4
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
2 6
1 3
0 4
1 20
0 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
4 5
1 2
9 20
```

### 输出

```
0
```

## 样例 #4

### 输入

```
2
3 10
1 5
```

### 输出

```
7
```

# AI分析结果

### 题目翻译
#### 最大交集

### 题目描述
给定n个闭区间，现在要求从这些闭区间中删除一个区间，使得剩下的（n - 1）个区间的交集的长度最大，求这个最大值。

（注：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数 - 左端点在数轴上表示的数）

### 样例 #1
#### 输入
```
4
1 3
2 6
0 4
3 3
```
#### 输出
```
1
```

### 样例 #2
#### 输入
```
5
2 6
1 3
0 4
1 20
0 4
```
#### 输出
```
2
```

### 样例 #3
#### 输入
```
3
4 5
1 2
9 20
```
#### 输出
```
0
```

### 样例 #4
#### 输入
```
2
3 10
1 5
```
#### 输出
```
7
```

### 综合分析与结论
这些题解的核心目标都是解决从n个闭区间中删除一个区间，使剩余（n - 1）个区间交集长度最大的问题。不同题解采用了多种思路和方法：
- **前缀后缀区间交法**：通过记录前缀区间交和后缀区间交数组，避免了重复计算交集，扫描数组三次即可解决问题，时间复杂度为$O(n)$。
- **暴力枚举法**：直接枚举删除每个区间，计算剩余区间的交集长度，最后取最大值。
- **记录最值法**：记录最大、次大左端点和最小、次小右端点，根据要删除的区间情况更新左右端点，从而计算交集长度。
- **multiset法**：利用multiset自动排序的特性，插入和删除区间，计算交集长度。
- **排序法**：对左右端点数组排序，遍历每个区间，尝试更新左右端点以扩大交集长度，时间复杂度为$O(n log n)$。
- **优先队列法**：使用优先队列存储左右端点，考虑删除左端点最大和右端点最小的区间，取最大值。

### 所选题解
- **作者：CreeperK（5星）**
    - **关键亮点**：思路清晰，通过类比其他题目引出前缀后缀区间交的思想，代码实现简洁高效，时间复杂度为$O(n)$。
    - **个人心得**：作者分享了自己做这道题的曲折经历，最初想贪心但失败，后来通过其他题目得到启发，领悟到“插入往往比删除容易”的思路，对解题有很大帮助。
    - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int iz=3e5+5;
int lpl[iz],lpr[iz],rpl[iz],rpr[iz];//前缀与后缀
int l[iz],r[iz];//线段们
int n;
int main(){
    scanf("%d",&n);
    memset(lpr,0x7f,sizeof(lpr));
    memset(rpr,0x7f,sizeof(rpr));
    for(int i=1;i<=n;i++){
        scanf("%d%d",&l[i],&r[i]);
        lpl[i]=max(lpl[i-1],l[i]);
        lpr[i]=min(lpr[i-1],r[i]);
    }//读入&求出lp
    for(int i=n;i>=1;i--){
        rpl[i]=max(rpl[i+1],l[i]);
        rpr[i]=min(rpr[i+1],r[i]);
    }//求出rp
    int maxn=0;//把不合法的区间和长度为0的区间排除
    for(int i=1;i<=n;i++){
        maxn=max(min(lpr[i-1],rpr[i+1])-max(lpl[i-1],rpl[i+1]),maxn);//取区间长度最大值
    }
    printf("%d",maxn);
}
```
核心思想：先通过两次遍历数组分别求出前缀区间交和后缀区间交，再遍历一次数组计算删除每个区间后剩余区间的交集长度，取最大值。

- **作者：Mickey_snow（4星）**
    - **关键亮点**：详细解释了合并区间的方法和过程，通过将计算过程分为两部分，避免了重复计算，时间复杂度为$O(n)$。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

struct cg {
    int fr, to;
};
cg seg[300500], arr[300500];

cg Range(cg a, cg b) {
    cg ret;
    ret.fr = std::max(a.fr, b.fr); ret.to = std::min(a.to, b.to);
    return ret;
}

int main()
{
    int totSeg, fr, to;

    cin >> totSeg;
    for (int i = 0; i < totSeg; i++) {
        cin >> fr >> to;
        seg[i] = { fr,to };
        arr[i] = { INT_MIN,INT_MAX };
    }

    cg now = *seg;
    for (int i = 1; i < totSeg; i++) {
        arr[i] = now;
        now = Range(now, seg[i]);
    }
    now = seg[totSeg - 1];
    for (int i = totSeg - 2; i >= 0; i--) {
        arr[i] = Range(arr[i], now);
        now = Range(now, seg[i]);
    }

    int _max = 0;
    for (int i = 0; i < totSeg; i++)
        _max=std::max(_max, arr[i].to - arr[i].fr);

    cout << _max << endl;

    //system("pause");
    return 0;
}
```
核心思想：定义合并区间的函数，通过两次遍历数组分别计算每个区间删除后剩余区间的交集，最后取最大值。

- **作者：lihongqian__int128（4星）**
    - **关键亮点**：思路简洁明了，直接阐述了维护前缀和后缀的最值来计算交集长度的方法，代码实现简洁，时间复杂度为$O(n)$。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N=3e5+5;
int n,l[N],r[N],ql[N],qr[N],hl[N],hr[N],ans;
signed main()
{
    memset(qr,0x3f,sizeof qr);
    memset(hr,0x3f,sizeof hr);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>l[i]>>r[i],ql[i]=max(ql[i-1],l[i]),qr[i]=min(qr[i-1],r[i]);
    for(int i=n;i;i--)hl[i]=max(hl[i+1],l[i]),hr[i]=min(hr[i+1],r[i]);
    for(int i=1;i<=n;i++)ans=max(ans,min(qr[i-1],hr[i+1])-max(ql[i-1],hl[i+1]));
    cout<<ans;
    return 0 ;
}
```
核心思想：维护左端点前缀最大值、右端点前缀最小值、左端点后缀最大值、右端点后缀最小值，遍历每个区间计算删除该区间后剩余区间的交集长度，取最大值。

### 最优关键思路或技巧
- **前缀后缀思想**：通过记录前缀区间交和后缀区间交，避免了重复计算交集，将时间复杂度优化到$O(n)$。
- **避免删除操作**：将删除一个区间的问题转化为直接计算剩余区间的交集，简化了问题的处理。

### 可拓展之处
- **同类型题**：可以拓展到删除k个区间求剩余区间交集长度最大的问题，或者多个区间集合求交集等问题。
- **类似算法套路**：在处理需要删除元素的问题时，可以考虑使用前缀后缀思想，避免直接进行删除操作，通过预处理和记录信息来简化计算。

### 洛谷推荐题目
- P1886 滑动窗口 /【模板】单调队列
- P2216 [HAOI2007]理想的正方形
- P1714 切蛋糕

### 个人心得摘录与总结
- **CreeperK**：最初做这道题时想贪心但失败，花费一个多小时未解决。后来通过其他题目得到启发，领悟到“插入往往比删除容易”的思路，学会了通过记录前缀和后缀信息来避免删除操作，从而解决问题。这表明在解题时可以从其他类似题目中获取灵感，转换思路。

---
处理用时：47.23秒
# 题目信息

# Fighting Tournament

## 题目描述

## 题意 

Burenka正准备去观看一年中最有趣的体育活动 —— 她朋友Tonya组织的格斗锦标赛。

有 **n** 名运动员参加了大赛，标号分别为为 1，2，... ，n 。第 **i** 名运动员的实力是 **$a_i（1 \le a_i \le n）$** 。**每个运动员的实力是不同的，也就是说，数组 a 是 n 的 一种 全排列** 。

大赛的流程是这样的：

一开始，运动员们**按标号从小到大**排成一列，队头为 **1** 号运动员，队尾为 **n** 号运动员。

每轮一次比赛，**队头**的两个人进行格斗，**赢的人（实力较强的人）变成队头，输的人变成队尾** 。

Burenka 问了 Tonya **q** 个问题，每个问题包含两个整数 **i** 和 **k** ，表示 **i 号运动员在前 k 轮中会胜多少场**。

## 样例 #1

### 输入

```
3
3 1
3 1 2
1 2
4 2
1 3 4 2
4 5
3 2
5 2
1 2 3 5 4
5 1000000000
4 6```

### 输出

```
2
0
1
0
4```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是基于比赛的性质：经过最多 $n - 1$ 轮后，实力最强的运动员会一直处于队首并赢得后续所有比赛。各题解的区别主要在于处理前 $n - 1$ 轮比赛结果的方式和数据结构的运用。
- **思路对比**：大部分题解都先处理前 $n - 1$ 轮比赛，对于实力最强的运动员单独计算其获胜场数，对于其他运动员则根据其前面和后面运动员的实力情况计算获胜场数。部分题解采用离线处理询问并排序的方式，部分题解使用线段树、单调栈等数据结构辅助计算。
- **算法要点**：
    - 预处理前 $n - 1$ 轮比赛结果，记录每个运动员的获胜情况。
    - 对于询问，根据运动员是否为实力最强者以及 $k$ 的大小进行分类讨论。
    - 利用前缀最大值、单调栈、线段树等数据结构优化查找过程。
- **解决难点**：
    - 处理前 $n - 1$ 轮比赛结果的记录和查询。
    - 处理实力最强的运动员的获胜场数计算，需要考虑其初始位置。
    - 处理其他运动员的获胜场数计算，需要找到其前面和后面第一个比它大的运动员的位置。

### 高评分题解
- **作者：Eason2009 (5星)**
    - **关键亮点**：思路清晰，分类讨论详细，使用线段树维护区间最大值，通过在线段树上二分查找第一个击败询问运动员的运动员的编号，代码注释详细，易于理解。
    - **个人心得**：作者表示这是自己第一次在场上写出线段树题，虽然写起来有些不方便，但认为这种方法比较好理解。
    - **核心代码**：
```cpp
void pushup(int now)
{
    tree[now]=max(tree[now*2],tree[now*2+1]);
    return;
}
void build(int now,int l,int r)
{
    if(l==r)
    {
        tree[now]=a[l];
        return;
    }
    int mid=l+r>>1;
    build(now*2,l,mid);
    build(now*2+1,mid+1,r);
    pushup(now);
    return;
}
int query(int now,int l,int r)
{
    if(l==r) return l;
    int mid=l+r>>1;
    if(tree[now*2]>a[pos]) return query(now*2,l,mid);
    else return query(now*2+1,mid+1,r);
}
```
核心实现思想：通过 `pushup` 函数更新线段树节点的最大值，`build` 函数构建线段树，`query` 函数在线段树上二分查找第一个击败询问运动员的运动员的编号。

- **作者：Hedgehog_210508 (4星)**
    - **关键亮点**：思路简洁，通过模拟发现 $n - 1$ 次比较之后一定是 $n$ 与别人比较且必定获胜，只需要单独计算前 $n - 1$ 次比较的结果，维护每个数值连胜的开始时间与结束时间，代码实现简单。
    - **核心代码**：
```cpp
for(ll i=1;i<=n;s[i]=e[i]=0,i++) cin>>a[i];
ll m=a[1];
s[m]=1;
for(ll i=2;i<=n;i++){
    if(a[i]>m) s[a[i]]=i-1,e[m]=i-2,m=a[i];
}
e[m]=n-1;
```
核心实现思想：遍历数组，记录每个数值连胜的开始时间 `s` 和结束时间 `e`。

- **作者：Dregen_Yor (4星)**
    - **关键亮点**：将所有询问离线处理并按 $k$ 的大小排序，暴力模拟前 $n - 1$ 轮比赛的情况，同时统计出所有求前 $n - 1$ 轮的询问的答案，之后根据询问的点是否为最大值计算 $n - 1$ 轮之后的答案，思路清晰，代码结构良好。
    - **核心代码**：
```cpp
sort(ask + 1, ask + 1 + q, cmp);
for (int i = 2; i <= n; i++) {
    if (a[i] > a[now]) {
        w[i]++;
        now = i;
    } else {
        w[now]++;
    }
    while (ask[tot].k == (i - 1) && tot <= q) {
        ans[ask[tot].num] = w[ask[tot].x];
        tot++;
    }
}
```
核心实现思想：对询问按 $k$ 排序，模拟前 $n - 1$ 轮比赛，统计每个运动员的获胜场数，同时处理 $k$ 小于等于 $n - 1$ 的询问。

### 最优关键思路或技巧
- 利用比赛的性质，即经过最多 $n - 1$ 轮后，实力最强的运动员会一直处于队首并赢得后续所有比赛，将问题简化为处理前 $n - 1$ 轮比赛结果。
- 使用前缀最大值、单调栈、线段树等数据结构优化查找过程，提高算法效率。
- 对询问进行分类讨论，分别处理实力最强的运动员和其他运动员的获胜场数计算。

### 拓展思路
同类型题或类似算法套路：
- 环形队列的模拟问题，如约瑟夫环问题。
- 具有单调性的序列处理问题，如最长递增子序列问题。
- 离线处理询问的问题，如区间查询问题。

### 推荐题目
- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：考察环形队列的模拟。
- [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：考察最长递增子序列问题。
- [P2073 送花](https://www.luogu.com.cn/problem/P2073)：考察离线处理询问的问题。

### 个人心得摘录与总结
- **Eason2009**：第一次在场上写出线段树题，虽写起来不方便但认为方法较好理解，强调学习的积极心态。
- **xzy090626**：指出题目细节多，吃了很多发罚时仍有可能通过，强调心态在做题中的重要性。

---
处理用时：38.99秒
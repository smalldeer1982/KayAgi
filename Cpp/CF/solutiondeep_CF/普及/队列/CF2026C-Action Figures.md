# 题目信息

# Action Figures

## 题目描述

在 Monocarp 家附近有一家商店，专门售卖手办。近期，这家店将推出一套新的手办系列，总共包含 $n$ 个手办。其中，第 $i$ 个手办的价格为 $i$ 枚金币。在第 $i$ 天到第 $n$ 天之间，这个手办都是可以购买的。

Monocarp 知道他在这 $n$ 天中的哪几天可以去商店。

每次去商店的时候，他可以购买多件手办（当然，不能买尚未发售的手办）。如果他在同一天购买了至少两个手办，他可以享受一个折扣：他所购买的最贵手办是免费的，也就是说他无需为该手办支付费用。

Monocarp 的目标是从这个手办系列中，分别购买一个第 $1$ 个手办、一个第 $2$ 个手办……一直到一个第 $n$ 个手办。注意，每个手办只能购买一次。请你帮他计算，他最少需要花费多少金币？

## 说明/提示

在第一个测试用例中，Monocarp 可以在第一天购买第一个手办，花费 1 枚金币。

在第二个测试用例中，他可以在第三天购买第 1 和第 3 个手办，在第四天购买第 2 和第 4 个手办，在第六天购买第 5 和第 6 个手办。这样总费用为 $1+2+5=8$ 枚金币。

在第三个测试用例中，他可以在第三天购买第 2 和第 3 个手办，其余手办在第七天购买，最终花费 $1+2+4+5+6 = 18$ 枚金币。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
1
1
6
101101
7
1110001
5
11111```

### 输出

```
1
8
18
6```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是贪心算法，目标是尽可能利用折扣规则来减少购买所有手办的总花费。具体做法是从大到小考虑可购买的手办，优先用无法享受折扣的手办（对应 `s[i] = 0` 的情况）去搭配可享受折扣的手办（对应 `s[i] = 1` 的情况），若没有 `0` 则用最小的 `1` 去搭配。

- **思路对比**：各位作者思路本质相同，但实现方式有别。Drifty 和 the_Short_Path 使用 `set` 存储 `0` 和 `1` 的位置，利用 `set` 的有序性和查找功能来实现贪心匹配；zhouruoheng 和 MiaoYu 使用双端队列存储 `1` 的位置，便于从队首和队尾取元素进行匹配；__Louis__ 则通过数组标记已匹配的位置，手动维护 `0` 和 `1` 的查找。
- **算法要点**：核心要点是贪心策略，即优先用 `0` 去搭配 `1` 以实现最大优惠。在实现过程中，需要对 `0` 和 `1` 的位置进行有效管理和查找。
- **解决难点**：主要难点在于如何高效地找到合适的 `0` 或 `1` 进行搭配，以及处理各种边界情况，如没有 `0` 时的处理。不同的实现方式在解决这些难点上各有优劣。

### 所选题解
- **Drifty 的题解（5星）**
    - **关键亮点**：思路清晰，使用 `set` 数据结构简化了查找和删除操作，代码简洁高效。
    - **核心代码**：
```cpp
void solve() {
    cin >> n >> s;
    set <int> S({0}), T;
    i64 ans = 0;
    for (int i = 1; i <= n; i ++) {
        if (s[i - 1] == '0') S.insert(i), ans += i;
        if (s[i - 1] == '1') T.insert(i);
    }
    while (T.size()) {
        auto it = S.upper_bound(*T.rbegin());
        if (*(-- it) == 0) {
            ans += *T.begin(); T.erase(*T.begin());
            if (T.size() >= 1) T.erase(*T.rbegin());
        } 
        else S.erase(*it), T.erase(*T.rbegin());
    }
    cout << ans << '\n';
}
```
- **zhouruoheng 的题解（4星）**
    - **关键亮点**：使用双端队列存储 `1` 的位置，逻辑清晰，易于理解。
    - **核心代码**：
```cpp
void solve()
{
    cin>>n;
    cin>>s;
    tot=ans=0;
    for(int i=0;i<n;i++) 
    {
        if(s[i]-'0') dq.push_back(i+1);
        else st[++tot]=i+1;
        ans+=i+1;
    }
    while(dq.size())
    {
        int x=dq.back();dq.pop_back();
        while(tot&&st[tot]>x) tot--;
        if(tot) 
        {
            tot--;
            ans-=x;
        }
        else 
        {
            if(dq.size())
            {
                dq.pop_front();
                ans-=x;
            }
        }
    }
    cout<<ans<<'\n';
}
```
- **__Louis__ 的题解（4星）**
    - **关键亮点**：对贪心策略的证明较为详细，有助于理解算法的正确性。
    - **核心代码**：
```cpp
signed main(){
    int T;
    scanf("%lld",&T);
    while(T--){
        scanf("%lld%s",&n,s+1);
        int sum=0;
        for(int i=0;i<=n+3;i++){
            g[i]=false;
        }
        int _0=n-1,_1=1;
        for(int i=n;i>=1;i--){
            if(!g[i]){
                g[i]=true;
                if(s[i]=='1'){
                    while(_0>0&&(s[_0]=='1'||g[_0])) _0--;
                    if(_0>0){
                        sum+=i;
                        g[_0]=true;
                    }else{
                        while(_1<=n&&(s[_1]=='0'||g[_1])&&_1<=n) _1++;
                        if(_1<=n) {
                            sum+=i;
                            g[_1]=true;
                        }
                    }
                }
            }
        }
        printf("%lld\n",n*(n+1)/2-sum);
    }
    return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：从大到小考虑可购买的手办，优先用 `0` 去搭配 `1` 以实现最大优惠。
- **数据结构选择**：使用 `set` 或双端队列可以高效地管理和查找 `0` 和 `1` 的位置。

### 可拓展之处
同类型题可能会改变折扣规则或商品的上架方式，但核心思路仍然是贪心算法。类似的算法套路包括区间贪心、活动选择问题等，通过合理排序和选择来达到最优解。

### 洛谷相似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的使用。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：经典的贪心问题，通过排序来优化总时间。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法在背包问题中的应用。

### 个人心得摘录与总结
- **the_Short_Path**：提到 `std::set::erase()` 不能删除反迭代器 `rbegin()` 和 `rend()`，使用时需要先取值，避免报错。这提醒我们在使用标准库函数时要注意其参数类型和使用限制。 

---
处理用时：30.68秒
# 题目信息

# Fair

## 题目描述

一些公司将在Byteland举办商品交易会（or博览会？）。在Byteland有 $n$ 个城市，城市间有 $m$ 条双向道路。当然，城镇之间两两连通。
Byteland生产的货物有 $k$ 种类型，每个城镇只生产一种。
为了举办商品交易会，你必须至少带来 $s$ 种不同类型的商品。将货物从 $u$ 镇带到城镇 $v$ 将花费 $d(u,v)$ 的费用，其中 $d(u,v)$ 是从 $u$ 到 $v$ 的最短路径的长度。
路径的长度是这个路径中的道路的数量。              
组织者将支付所有的运输费用，但他们可以选择从哪些城镇带来货物。现在他们想计算每个城镇举办商品交易会的最小费用。

## 样例 #1

### 输入

```
5 5 4 3
1 2 4 3 2
1 2
2 3
3 4
4 1
4 5
```

### 输出

```
2 2 2 2 3 
```

## 样例 #2

### 输入

```
7 6 3 2
1 2 3 3 2 2 1
1 2
2 3
3 4
2 5
5 6
6 7
```

### 输出

```
1 1 1 2 2 1 1 
```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路一致，都是先计算每个点到每种颜色货物的最短距离，再对每个点的距离排序，取前 $s$ 小的距离之和作为该点举办商品交易会的最小费用。但在具体实现上有所差异：
- **算法要点**：
    - 均采用BFS计算最短距离，因为边权为1，BFS能保证首次到达的距离即为最短距离。
    - 部分题解使用超级源点的思想，将同颜色的点视为与超级源点距离为0的点，简化计算。
    - 统计答案时，多数题解对每个点的距离数组排序后取前 $s$ 个求和，也有题解使用 `nth_element` 函数优化排序过程。
- **解决难点**：
    - 处理同颜色点的最短距离计算，通过超级源点或多源BFS解决。
    - 高效统计每个点的前 $s$ 小距离，使用排序或 `nth_element` 函数。

### 所选题解
- **作者：Namelessone (5星)**
    - **关键亮点**：思路清晰，代码简洁，使用超级源点思想，将同颜色点与超级源点距离设为0，进行BFS更新距离数组，最后排序取前 $s$ 个求和。
```cpp
for (int c=1;c<=k;c++) {
    for (auto i:v[c]) {
        q.push(i);
        dis[i][c]=0;
    }
    while (!q.empty()) {
        int x=q.front();
        q.pop();
        for (auto i:e[x]) {
            if (dis[i][c]==-1) {
                dis[i][c]=dis[x][c]+1;
                q.push(i);
            }
        }
    }
}
for (int i=1;i<=n;i++){
    ans=0;
    sort(dis[i]+1,dis[i]+1+k);
    for (int j=1;j<=s;j++) {
        ans+=dis[i][j];
    }
    printf("%d ",ans);
}
```
- **作者：qjxqjx (4星)**
    - **关键亮点**：思路明确，代码规范，将BFS封装成函数，便于理解和维护，同样使用超级源点思想计算最短距离，最后排序取前 $s$ 个求和。
```cpp
void bfs(int type){
    queue<int>q;
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++){
        if(a[i]==type){
            dis[i][type]=0;
            vis[i]=true;
            q.push(i);
        }
    }
    while(!q.empty()){
        int cur=q.front();
        q.pop();
        for(int i=0;i<nbr[cur].size();i++){
            int next=nbr[cur][i];
            if(vis[next]==0){
                vis[next]=true;
                dis[next][type]=dis[cur][type]+1;
                q.push(next);
            }
        }
    }
    return ;
}
for(int i=1;i<=k;i++){
    bfs(i);
}
for(int i=1;i<=n;i++){
    sort(dis[i]+1,dis[i]+1+k);
    int ans=0;
    for(int j=1;j<=s;j++){
        ans+=dis[i][j];
    }
    cout<<ans<<" ";
}
```
- **作者：_JC_ (4星)**
    - **关键亮点**：使用 `nth_element` 函数优化排序过程，只将前 $s$ 小的元素排到前面，降低时间复杂度。
```cpp
nth_element(ans+1,ans+s+1,ans+k+1);
for(int j=1;j<=s;j++)
    da+=ans[j];
```

### 最优关键思路或技巧
- **超级源点思想**：将同颜色的点视为与超级源点距离为0的点，通过BFS计算所有点到该颜色的最短距离，避免对每个点单独计算。
- **`nth_element` 函数**：在只需要前 $s$ 小元素的情况下，使用该函数可以避免对整个数组排序，降低时间复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 多源最短路问题，如多个起点到多个终点的最短距离计算，可使用超级源点思想。
- 求前 $k$ 小元素的问题，可使用 `nth_element` 函数优化排序过程。

### 推荐洛谷题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察BFS求最短路及路径计数。
2. [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：经典的单源最短路问题，可使用BFS或Dijkstra算法。
3. [P1346 电车](https://www.luogu.com.cn/problem/P1346)：图论问题，需要对边权进行特殊处理，再使用最短路算法求解。

### 个人心得
作者：_HMZ_ 提到最初想到 $n \times m$ 的算法会超时，通过仔细阅读题目发现 $k$ 较小，从而想到将同颜色点放到一个队列里，对每个颜色跑一遍广搜的优化思路。总结为在解题时要仔细分析题目条件，根据数据范围优化算法，避免超时。 

---
处理用时：31.33秒
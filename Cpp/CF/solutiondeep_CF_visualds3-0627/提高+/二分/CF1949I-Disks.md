# 题目信息

# Disks

## 题目描述

# 圆盘


你在平面上有 $ n $ 个圆盘。每个圆盘的中心具有整数坐标，每个圆盘的半径为正整数。没有两个圆盘在一个正面积的区域重叠，但圆盘之间可能相切。

你的任务是确定是否可以改变圆盘的半径，使得：

- 原来相切的圆盘仍然相切。
- 没有两个圆盘在一个正面积的区域重叠。
- 所有半径的总和严格减小。

新的半径可以是任意正实数。不能改变圆盘的中心。

## 说明/提示

在第一个样例中，可以将第一个和第三个圆盘的半径减小 $ 0.5 $ ，将第二个圆盘的半径增加 $ 0.5 $ 。这样，所有半径的总和减小了 $ 0.5 $ 。改变半径前后的情况如下图所示。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1949I/1f564e55d56b152b57e25e4b9913f6abfe12e4f8.png) 第一个样例（左）和改变圆盘半径的有效方法（右）。在第二个样例中，如下图所示，无法按照要求改变圆盘的半径。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1949I/160a9b50ca0114a94aa27312025cf229be0abcc8.png) 第二个样例。

## 样例 #1

### 输入

```
5
0 2 1
0 0 1
4 -3 4
11 0 3
11 5 2```

### 输出

```
YES```

## 样例 #2

### 输入

```
4
2 2 2
7 2 3
7 7 2
2 7 3```

### 输出

```
NO```

# AI分析结果



---

## **算法分类**
无算法分类（图论：二分图判定）

---

## **综合分析与结论**

### **核心思路**
将相切的圆视为图中的边，构建无向图。对每个连通块进行二分图判定。若存在连通块为二分图且两种颜色节点数不等，则可调整半径总和严格减小。

### **解决难点**
- **建模**：半径调整的约束转化为二分图染色问题。相切圆必须互为反色（一个增，一个减）。
- **条件判断**：二分图保证无矛盾；颜色数不等确保总和减小。
- **数值处理**：使用平方比较避免浮点误差，判断圆心距离等于半径和。

### **可视化设计**
- **图结构**：用不同颜色标记圆盘，表示增/减组别，动态展示DFS染色过程。
- **连通块检测**：高亮当前处理的连通块，显示染色冲突位置。
- **结果判定**：若某连通块满足条件，整体标记为绿色，否则红色。

---

## **题解清单 (≥4星)**

### **江户川·萝卜的题解 (5星)**
- **亮点**：代码简洁高效，变量命名清晰；DFS函数内联处理冲突检测。
- **关键代码**：使用 `vis` 数组记录颜色，`cnt` 统计颜色数量，`f` 标志冲突。

### **WuMin4的题解 (4星)**
- **亮点**：结构体存储圆信息，逻辑分层明确；显式判断相切条件。
- **优化点**：可读性稍逊于前者，但逻辑等价。

---

## **最优思路/技巧提炼**

1. **二分图建模**  
   - 相切关系对应边，染色表示增/减方向。
   - 若存在奇环（非二分图），无法调整。

2. **颜色数量差**  
   - 颜色数不等时，选较多组减少半径，总和必减。

3. **避免浮点运算**  
   - 使用整数平方比较判断相切：`dx² + dy² == (r1 + r2)²`。

---

## **同类型题/算法套路**

- **二分图判定**：如封锁阳光大学（洛谷P1330）。
- **约束建模为图**：如关押罪犯（洛谷P1525）。
- **连通块属性分析**：需统计各连通块的性质（如颜色差）。

---

## **推荐题目**
1. **P1330** - 封锁阳光大学（二分图判定）
2. **P1525** - 关押罪犯（二分图/并查集）
3. **CF862B** - 二分图边数最大化

---

## **代码片段（核心逻辑）**

```cpp
// 江户川·萝卜的DFS染色逻辑
void dfs(int p, int w) {
    if (~vis[p]) return f &= (vis[p] == w), void();
    vis[p] = w, cnt[w]++;
    for (auto x : e[p]) dfs(x, !w);
}

// 主逻辑：遍历连通块
memset(vis, -1, sizeof vis);
for (int i = 1; i <= n; i++) {
    if (!~vis[i]) {
        f = 1; cnt[0] = cnt[1] = 0;
        dfs(i, 0);
        if (f && cnt[0] != cnt[1]) return puts("YES"), 0;
    }
}
```

---

## **可视化与复古游戏化设计**

### **8位像素风格**
- **颜色方案**：红/蓝表示两种颜色，绿色表示合法连通块。
- **Canvas网格**：圆盘以像素块表示，边线为黄色。
- **音效**：染色成功时播放“叮”，冲突时“哔”。

### **AI自动演示**
- **步骤**：自动选择未染色节点，DFS染色并高亮过程。
- **积分**：每正确染色一个连通块得10分，冲突扣5分。

### **控制面板**
- **速度调节**：滑块控制染色速度（50ms~2s）。
- **暂停/继续**：观察中间状态，单步执行调试。

---

**核心结论**：将问题抽象为二分图判定，通过颜色数量差判定是否存在解。代码简洁高效，可视化可增强对图遍历过程的理解。

---
处理用时：63.68秒
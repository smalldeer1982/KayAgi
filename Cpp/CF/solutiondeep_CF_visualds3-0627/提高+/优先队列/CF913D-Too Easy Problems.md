# 题目信息

# Too Easy Problems

## 题目描述

你正在准备一场关于调度理论的考试。

这场考试会持续正好 $T$ 毫秒，由 $n$ 道题目组成。

你可以用 $t_i$ 毫秒解决第 $i$ 个问题，或者忽略它并不消耗时间。你也不需要用来在做完一道题之后休息的时间。

不幸的是，你的老师认为一些题目对你来说太简单了。因此，他对于每道题 $i$ 规定了一个整数 $a_i$，表示题目 $i$ 只在你总共解决了不超过 $a_i$ 个问题（包括问题 $i$ ）的情况下为你的最终成绩加上一分。

正式地，假设你在考试中解决了问题 $p_1,p_2,\cdots,p_k$。那么，你的最终成绩 $s$ 会等于在 $1$ 到 $k$ 之间的满足 $k\le a_{p_j}$ 的 $j$ 的个数。

你已经意识到这场考试真正的第一道题目已经放在了你面前。因此，你想要选择一组题目来解决，从而最大化你的最终成绩。不要忘记这场考试有时间限制，而你必须有足够的时间来解决所有你选择的题目。如果存在多个最优解，任意输出一组即可。

## 说明/提示

$1\le n\le 2\times10^5$

$1\le T\le10^9$

$0\le k\le n$

## 样例 #1

### 输入

```
5 300
3 100
4 150
4 80
2 90
2 300
```

### 输出

```
2
3
3 1 4
```

## 样例 #2

### 输入

```
2 100
1 787
2 788
```

### 输出

```
0
0

```

## 样例 #3

### 输入

```
2 100
2 42
2 58
```

### 输出

```
2
2
1 2
```

# AI分析结果



**唯一算法分类**  
二分答案 + 贪心

---

### **题解思路、算法要点与解决难点**  
1. **核心思路**  
   - **二分答案**：最大值问题具有单调性，二分可能的得分 k  
   - **贪心验证**：对每个 k，选择满足 a_i ≥k 的题目中最小的 k 个时间，验证总时间 ≤T  

2. **解决难点**  
   - **单调性证明**：当 k 越大，满足 a_i ≥k 的题目数越少，时间总和可能越大  
   - **高效验证**：需在 O(n) 内完成对 k 的可行性检查，需结合排序预处理  

3. **关键步骤**  
   - 预处理所有题目按时间排序  
   - 二分 k，每次筛选出 a_i ≥k 的题目，累加前 k 小时间  

---

### **题解评分 (≥4星)**  
1. **Sol1 (5星)**  
   - 思路清晰，代码简洁，预处理排序后直接遍历验证  
   - 按时间排序后，遍历时自然选择最小时间集合  
   - 边界处理完善，输出逻辑明确  

2. **JimmyLee (4.5星)**  
   - 结构体存储题目信息，逻辑与 Sol1 类似  
   - 使用 lambda 表达式排序，代码风格现代化  
   - 二分区间初始值设定更合理（r=3e5）  

3. **Tzs_yousa (4星)**  
   - 使用 pair 存储数据，代码稍显复杂  
   - 在 check 函数中重复筛选并排序，效率略低但正确  
   - 输出时再次排序，逻辑冗余但最终结果正确  

---

### **最优思路或技巧提炼**  
- **二分答案框架**：将最优化问题转化为可行性验证问题  
- **贪心筛选条件**：a_i ≥k 且时间最小的 k 个题目  
- **预处理排序**：预先按时间排序，确保每次验证的贪心选择正确性  

---

### **同类型题或类似算法套路**  
- **最大值问题 + 单调性**：如「跳石头」「分割数组的最大值」  
- **贪心结合二分**：如「Drying POJ - 3104」「珂朵莉的数列」  

---

### **推荐相似题目**  
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)  
2. [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)  
3. [P4344 [SHOI2015] 脑洞治疗仪](https://www.luogu.com.cn/problem/P4344)  

---

### **个人心得摘录**  
- **Sol1**：强调「做题数 k 和得分相同」的关键观察，避免无效选择  
- **JimmyLee**：通过构造 vector 存储有效题目，减少冗余遍历  
- **Loser_Syx**：明确指出 a_i < s 的题目必须丢弃，简化问题  

---

### **可视化与算法演示**  
**动画方案设计**  
1. **二分过程**：  
   - 动态展示当前二分区间 [l, r]，用颜色区分可行与不可行区间  
   - 步进时高亮 mid，触发 check 函数的验证动画  

2. **验证步骤**：  
   - 筛选出 a_i ≥k 的题目，用绿色高亮  
   - 按时间从小到大排列，累加前 k 个时间，红色标记超时位置  
   - 显示总时间与 T 的比较结果  

3. **像素风格设计**：  
   - 题目用像素方块表示，a_i 显示在方块顶部，时间在底部  
   - 选中题目时播放 8-bit 音效，验证通过时背景变绿  

**关键代码片段**  
```javascript
// 伪代码：验证函数动画核心逻辑
function animateCheck(k) {
  let validProblems = problems.filter(p => p.a >= k);
  validProblems.sort((a, b) => a.t - b.t);
  let totalTime = 0, selected = [];
  for (let i = 0; i < validProblems.length; i++) {
    if (totalTime + validProblems[i].t > T || selected.length >= k) break;
    totalTime += validProblems[i].t;
    selected.push(validProblems[i]);
    // 在 Canvas 高亮当前选择的方块
  }
  return selected.length >= k;
}
```

---

### **结论**  
通过二分答案与贪心策略的高效结合，此题在 O(n log n) 时间内可求解。所有题解均围绕这一核心思路展开，差异仅在于实现细节。预处理排序与条件筛选是关键优化点，确保算法的高效性。

---
处理用时：88.27秒
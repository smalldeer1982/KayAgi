# 题目信息

# Game of the Year

## 题目描述

Monocarp 和 Polycarp 正在玩电脑游戏。游戏特点：$ n $ 个编号从 $ 1 $ 到 $ n $ 的BOSS。

他俩将用以下方式与BOSS战斗

- Monocarp 进行 $ k $ 次尝试撒掉boss;
- Polycarp 进行 $ k $ 次尝试撒掉boss;
- Monocarp 进行 $ k $ 次尝试撒掉boss;
- Polycarp 进行 $ k $ 次尝试撒掉boss;
- ...

Monocarp 在第 $ a_i $ 次尝试中撒掉了第 $ i $ 只BOSS。Polycarp 在第 $ b_i $ 次尝试中撒掉了第 $ i $ 只BOSS。其中一个人撒掉第 $ i $ 只BOSS后，他们就会尝试撒第 $ (i+1) $ 只BOSS。并且他们的尝试计数器都会清空。撒掉第 $ n $ 只BOSS后，游戏结束。

找到从$ 1 $ 到 $ n $所有的 $ k $ 值， 使得 Monocarp 可以杀死所有的BOSS。

## 说明/提示

考虑最后一组测试样例

使 $ k = 1 $。首先，Monocarp经过1次尝试撒死第一只BOSS。成功，因为 $ a_1 = 1 $。 然后，Monocarp进行一次尝试撒死第二只BOSS。不成功，因为 $ a_2 > 1 $。于是，Polycarp尝试了一下。也不成功，因为 $ b_2 > 1 $。然后Monocarp进行了另一次尝试。仍然不成功，因为 $ a_2 > 2 $。直到Polycarp 在第三次尝试撒掉了BOSS。Monocarp没能撒掉BOSS。因此，$ k = 1 $ 不是答案。

使 $ k = 2 $ . Monocarp仍然在他的第一次尝试中撒死了BOSS。然后，他进行了两次不成功的尝试未能撒死BOSS。然后，Polycarp进行了两次不成功的尝试。然后，Monocarp进行了两次尝试，并且在第四次尝试中撒掉了BOSS。撒掉第三只BOSS的方法也类似。首先，Monocarp进行两次不成功的尝试。然后，Polycarp进行两次不成功的尝试。然后，Monocarp还有两次尝试机会，但在这两次机会中第一次就撒死了BOSS，因为 $ a_3 = 3 $。 第四只BOSS也被Monocarp撒死。因此，$ k = 2 $ 是答案。

## 样例 #1

### 输入

```
3
3
1 1 1
2 3 1
1
1
1
4
1 4 3 2
3 3 4 1```

### 输出

```
3
1 2 3 
1
1 
2
2 4```

# AI分析结果



## **算法分类**  
数论、差分、因数倍数  

---

## **题解思路与核心算法**  

### **核心思路**  
1. **问题转换**：Monocarp 击杀第 i 个 BOSS 的条件是 $\lceil \frac{a_i}{k} \rceil \leq \lceil \frac{b_i}{k} \rceil$。  
2. **关键观察**：当 $a_i > b_i$ 时，若存在 $k$ 的倍数在区间 $[b_i, a_i-1]$ 内，则 $k$ 不合法。  
3. **区间覆盖**：通过差分数组标记所有非法区间 $[b_i, a_i-1]$。  
4. **倍数检查**：对每个 $k$，检查其所有倍数是否未被覆盖。  

### **解决难点**  
- **高效覆盖区间**：差分数组 $O(1)$ 时间标记区间，前缀和恢复覆盖状态。  
- **调和级数枚举**：每个 $k$ 的倍数检查总复杂度为 $O(n \log n)$。  

---

## **题解评分 (≥4星)**  
1. **Alex_Wei (★★★★★)**  
   - 思路清晰，直接推导出关键条件。  
   - 代码简洁，使用差分和调和级数枚举，时间复杂度最优。  
   - 可读性高，逻辑明确。  

2. **DaiRuiChen007 (★★★★☆)**  
   - 代码简洁，核心逻辑与 Alex_Wei 一致。  
   - 使用 vector 存储答案，便于输出。  
   - 未详细解释推导过程，但实现高效。  

3. **fast_photon (★★★★☆)**  
   - 详细推导整除条件，数学证明完整。  
   - 代码使用树状数组优化，但最终改为差分实现。  
   - 代码注释较少，但逻辑清晰。  

---

## **最优思路提炼**  
1. **差分标记非法区间**：  
   - 对每个 $a_i > b_i$，标记区间 $[b_i, a_i-1]$。  
   - 差分数组 `c[b_i]++, c[a_i]--`，前缀和恢复覆盖状态。  

2. **调和级数检查倍数**：  
   ```cpp  
   for (int k = 1; k <= n; k++) {  
       bool valid = true;  
       for (int j = k; j <= n; j += k) {  
           if (c[j] > 0) { valid = false; break; }  
       }  
       if (valid) ans.push_back(k);  
   }  
   ```  
3. **时间复杂度**：$O(n \log n)$，通过枚举每个 $k$ 的倍数。  

---

## **同类型题与算法套路**  
- **类似问题**：区间覆盖 + 因数倍数检查。  
- **通用解法**：  
  1. 差分处理区间操作。  
  2. 调和级数枚举优化倍数检查。  

---

## **相似题目推荐**  
1. **P1403 [AHOI2005] 约数研究**（因数倍数统计）  
2. **P2424 约数和**（因数区间贡献计算）  
3. **CF1034D Intervals of Intervals**（差分与区间覆盖优化）  

---

## **个人心得摘录**  
- **zac2010**：通过画数轴辅助分析区间覆盖条件。  
- **蒟蒻君HJT**：调试时发现整除分块不适用，转而思考调和级数枚举。  

---

## **可视化与算法演示**  

### **动画设计**  
1. **像素风格界面**：  
   - 使用 8-bit 像素风格展示数轴 $[1, n]$。  
   - 覆盖区间显示为红色，合法 $k$ 显示为绿色。  

2. **关键操作高亮**：  
   - **差分标记**：点击 BOSS 时，区间 $[b_i, a_i-1]$ 闪烁红色。  
   - **倍数检查**：选中 $k$ 时，其倍数格子高亮黄色，若被覆盖则变红。  

3. **音效与交互**：  
   - 发现合法 $k$ 时播放“过关”音效。  
   - 错误时播放短促“失败”音效。  

### **代码片段 (JavaScript)**  
```javascript  
// 初始化 Canvas  
const canvas = document.getElementById("pixel-canvas");  
const ctx = canvas.getContext("2d");  

// 绘制数轴覆盖状态  
function drawCoverage() {  
    for (let i = 1; i <= n; i++) {  
        if (covered[i]) ctx.fillStyle = "#FF0000"; // 红色覆盖  
        else ctx.fillStyle = "#00FF00"; // 绿色合法  
        ctx.fillRect(i * 10, 50, 8, 8); // 像素方块  
    }  
}  

// 检查 k 的倍数  
function checkK(k) {  
    for (let j = k; j <= n; j += k) {  
        if (covered[j]) return false;  
    }  
    return true;  
}  
```  

---

## **总结**  
通过差分标记非法区间并利用调和级数枚举倍数，该算法在 $O(n \log n)$ 时间内高效解决问题。核心思想是将条件转化为区间覆盖问题，并通过数论优化实现快速检查。

---
处理用时：70.13秒
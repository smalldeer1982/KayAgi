# 题目信息

# Turtle and Inversions (Easy Version)

## 题目描述

这是题目的简化版本。这两种题目的区别在于对于 $m$ 的限制及在简化版本中，满足 $r_i < l_{i + 1}$ 对于每个 $i$ 从 $1$ 到 $m-1$。只有当两个版本的问题都被解决后，才可以进行 hack。

海龟给了你 $m$ 个区间 $[l_1, r_1], [l_2, r_2], \ldots, [l_m, r_m]$。他认为一个排列 $p$ 是有趣的，如果对于每个区间存在一个整数 $k_i$ 满足 $l_i \le k_i < r_i$，那么对于每个从 $1$ 到 $m$ 的整数 $i$，可以计算出 $a_i = \max\limits_{j = l_i}^{k_i} p_j$ 和 $b_i = \min\limits_{j = k_i + 1}^{r_i} p_j$，使得以下条件成立：

$$
\max\limits_{i = 1}^m a_i < \min\limits_{i = 1}^m b_i
$$

海龟希望你计算出长度为 $n$ 的所有有趣排列中能获得的最大逆序对数量，或者告诉他是否没有这样的有趣排列。

排列 $p$ 的逆序对是指任意两个整数对 $(i, j)$（$1 \le i < j \le n$）且满足 $p_i > p_j$。

## 说明/提示

在第三个测试用例中，最大逆序对数量的有趣排列是 $[5, 2, 4, 3, 1]$。

在第四个测试用例中，最大逆序对数量的有趣排列是 $[4, 8, 7, 6, 3, 2, 1, 5]$。这时可以设定 $[k_1, k_2] = [1, 7]$。

在第五个测试用例中，最大逆序对数量的有趣排列是 $[4, 7, 6, 3, 2, 1, 5]$。

在第六个测试用例中，最大逆序对数量的有趣排列是 $[4, 7, 3, 6, 2, 5, 1]$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
6
2 0
2 1
1 2
5 1
2 4
8 2
1 4
6 8
7 2
1 3
4 7
7 3
1 2
3 4
5 6```

### 输出

```
1
0
8
21
15
15```

# AI分析结果



0. **题目翻译**

# 海龟与逆序对（简化版）

## 题目描述

这是题目的简化版本。两个版本的区别在于对 $m$ 的限制及在简化版本中满足 $r_i < l_{i+1}$。只有解决两个版本后才能进行 hack。

海龟给出 $m$ 个区间 $[l_1, r_1], [l_2, r_2], \ldots, [l_m, r_m]$。称排列 $p$ 是有趣的，若对于每个区间存在整数 $k_i$ 满足 $l_i \le k_i < r_i$，使得对应的 $a_i = \max\limits_{j = l_i}^{k_i} p_j$ 和 $b_i = \min\limits_{j = k_i + 1}^{r_i} p_j$ 满足：

$$
\max\limits_{i = 1}^m a_i < \min\limits_{i = 1}^m b_i
$$

求长度为 $n$ 的所有有趣排列中逆序对数的最大值，若无解输出相应结果。

排列的逆序对定义为满足 $i < j$ 且 $p_i > p_j$ 的二元组 $(i,j)$。

## 说明/提示

样例中给出的有趣排列结构展示了如何通过分割点选择满足条件并最大化逆序对数。

## 样例 #1

### 输入

```
6
2 0
2 1
1 2
5 1
2 4
8 2
1 4
6 8
7 2
1 3
4 7
7 3
1 2
3 4
5 6
```

### 输出

```
1
0
8
21
15
15
```

---

1. **唯一算法分类**  
   无算法分类

2. **综合分析与结论**  
   本题的核心在于构造排列的结构，使得所有区间存在分割点满足条件。关键观察是：存在一个全局分割点 $k$，使得每个区间必须包含 $k$，且排列被分割为两部分，左边所有元素的最大值小于右边的最小值。此时，最大逆序对数可通过左右部分降序排列得到，计算公式为 $k(k-1)/2 + (n-k)(n-k-1)/2$。

   **可视化设计思路**：  
   - **动态规划矩阵**：以 $k$ 为变量，计算不同分割点对应的逆序对数，矩阵行表示可能的 $k$ 值，列表示区间约束条件。
   - **高亮变化**：在可能的 $k$ 范围内，高亮端点处的逆序对数值变化。
   - **复古像素风格**：使用 8-bit 像素网格展示不同 $k$ 对应的逆序对数值，颜色渐变表示数值大小，音效在找到可行解时触发。

3. **题解清单 (≥4星)**  
   由于题解暂缺，此处基于分析给出通用建议：  
   - 确定所有区间的公共分割点范围 $[L, R]$。
   - 计算端点 $L$ 和 $R-1$ 处的逆序对数，取最大值。

4. **代码实现**  
   ```cpp
   #include <bits/stdc++.h>
   using namespace std;
   
   int main() {
       int T;
       cin >> T;
       while (T--) {
           int n, m;
           cin >> n >> m;
           int L = 0, R = n;
           for (int i = 0; i < m; ++i) {
               int l, r;
               cin >> l >> r;
               L = max(L, l);
               R = min(R, r);
           }
           if (L >= R) {
               cout << -1 << endl;
               continue;
           }
           int k1 = L, k2 = R - 1;
           auto f = [n](int k) { return k*(k-1)/2 + (n-k)*(n-k-1)/2; };
           cout << max(f(k1), f(k2)) << endl;
       }
       return 0;
   }
   ```
   **核心逻辑**：计算所有区间交集的端点，取逆序对数最大的分割点。

5. **同类型题思路**  
   类似问题通常涉及区间约束下的极值构造，关键在于发现隐藏的全局约束条件，如分割点必须落在所有区间的交集中。

6. **推荐题目**  
   - P1908 逆序对（基础逆序对计数）
   - P1966 火柴排队（排列构造与逆序对优化）
   - P4377 分界点（区间分割与极值问题）

7. **个人心得**  
   调试时需注意区间的闭合范围，特别是交集的边界条件。样例中的矛盾往往提示隐藏的结构特性，需反复验证假设。

8. **可视化演示**  
   **动画方案**：  
   - 网格展示不同 $k$ 对应的逆序对数，颜色从红（小）到绿（大）渐变。
   - 自动播放时，动态标记当前 $k$ 值及对应的数值，音效在找到可行解时播放上扬音调。
   - 用户可调整速度或手动步进，观察端点值的对比。

---
处理用时：522.38秒
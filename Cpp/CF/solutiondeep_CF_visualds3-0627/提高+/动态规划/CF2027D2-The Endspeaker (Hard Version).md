# 题目信息

# The Endspeaker (Hard Version)

## 题目描述

这是这道题目的困难版本。与简单版本的区别在于，你还需要输出达到最优解的操作序列数量。你需要解决这两种版本才能进行 hack。

现在给定一个数组 $ a $，长度为 $ n $，以及一个数组 $ b $，长度为 $ m $（保证 $ b_i > b_{i+1} $ 对所有 $ 1 \le i < m $ 成立）。初始时，$ k $ 的值为 $ 1 $。你的目标是通过执行以下两种操作之一反复将数组 $ a $ 变为空：

- 类型 $ 1 $ 操作 — 在 $ k < m $ 且数组 $ a $ 不为空时，你可以将 $ k $ 的值加 $ 1 $。这种操作不需要花费任何代价。
- 类型 $ 2 $ 操作 — 你可以移除数组 $ a $ 的一个非空前缀，使得这个前缀的和不大于 $ b_k $。这种操作的代价为 $ m - k $。

你需要让将数组 $ a $ 变为空的总操作代价最小化。如果无法通过任何操作序列达到这一目标，请输出 $ -1 $。否则，输出最小总操作代价以及产生命中该代价的操作序列数量，对 $ 10^9 + 7 $ 取模。

若两个操作序列在任一步骤中选择了不同种类的操作，或移除前缀的大小不同，则它们视为不同。

## 说明/提示

以下为一个测试用例的示例，其中最优操作序列的总费用为 $ 1 $，共有 $ 3 $ 种：

- 所有这 $ 3 $ 种序列都以类型 $ 2 $ 的操作开头，移除前缀 $ [9] $，使得 $ a = [3, 4, 3] $，产生代价 $ 1 $。然后执行类型 $ 1 $ 操作，把 $ k $ 提升一位，此后所有操作均无代价。
- 一种序列依次移除前缀 $ [3, 4] $ 和 $ [3] $。
- 另一种序列依次移除前缀 $ [3] $ 和 $ [4, 3] $。
- 还有一种序列依次移除前缀 $ [3] $，再移除 $ [4] $，最后移除 $ [3] $。

在第二个测试用例中，由于 $ a_1 > b_1 $，无法移除任何前缀，因此无论如何都无法使数组 $ a $ 变为空。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
4 2
9 3 4 3
11 7
1 2
20
19 18
10 2
2 5 2 1 10 3 2 9 9 6
17 9
10 11
2 2 2 2 2 2 2 2 2 2
20 18 16 14 12 10 8 6 4 2 1
1 6
10
32 16 8 4 2 1```

### 输出

```
1 3
-1
2 11
10 42
4 1```

# AI分析结果



0. **题目翻译**

# The Endspeaker (Hard Version)

## 题目描述

这是这道题的困难版本。与简单版本的区别在于，你需要额外输出达到最优解的操作序列数量。必须解决两个版本才能进行 hack。

给定一个长度为 $n$ 的数组 $a$，以及一个长度为 $m$ 的数组 $b$（保证 $b_i > b_{i+1}$ 对所有 $1 \le i < m$ 成立）。初始时，$k=1$。目标是通过以下两种操作将数组 $a$ 变为空：

- **类型 1 操作**：当 $k < m$ 且 $a$ 非空时，将 $k$ 增加 1（无代价）
- **类型 2 操作**：移除 $a$ 的一个非空前缀，其和不超过 $b_k$，代价为 $m - k$

输出最小总代价及对应操作序列数量（模 $10^9+7$）。若无法完成，输出 $-1$。

## 样例 #1

### 输入
（与用户提供的一致）

### 输出
（与用户提供的一致）

---

1. **唯一算法分类**  
   线性DP

---

2. **综合分析与结论**

**核心思路**  
所有题解均采用动态规划，以二维状态 $f[i][j]$ 表示处理到数组 $a$ 的第 $i$ 个元素时，当前处于 $b$ 的第 $j$ 个元素的最小代价，并维护方案数 $g[i][j]$。

**关键难点与解决方案**  
- **状态转移优化**：当处理第 $j$ 层时，需要快速找到所有满足 $\sum_{k=i}^{p} a_k \le b_j$ 的右端点 $p$。利用前缀和+二分查找可将单次查询复杂度降至 $O(\log n)$
- **方案数合并**：对同一最小代价的不同分割方式，使用线段树/双指针维护可转移区间，通过前缀和统计方案数
- **复杂度优化**：使用双指针代替二分可将时间复杂度从 $O(nm \log n)$ 优化为 $O(nm)$

**可视化设计思路**  
- **DP 矩阵更新动画**：用网格表示二维状态，每次处理 $b_j$ 时，从右向左滑动绿色指针标记可行区间，红色高亮表示当前更新的状态
- **像素风格**：每个状态用 16x16 像素方块表示，颜色深浅反映代价大小，音效在状态更新时播放 8-bit 电子音
- **自动演示**：按 $j$ 递增顺序自动播放转移过程，可调节速度观察指针移动和状态更新

---

3. **题解清单 (≥4星)**

- **Super_Cube (5星)**  
  线段树维护区间 DP 状态，支持区间更新和单点查询，代码结构清晰，兼顾时空复杂度

- **灵乌路空 (4星)**  
  双指针维护可转移区间，前缀和优化方案数统计，时间复杂度最优

- **CReatiQ (4星)**  
  简洁的线段树实现，将状态和方案数封装为结构体，代码可读性强

---

4. **代码实现与核心逻辑**

**灵乌路空题解核心代码**  
```cpp
for (int j = 1; j <= m; ++j) {
    int l = 1; // 当前可转移左边界
    for (int r = 1; r <= n; ++r) {
        while (l <= r && sum[r] - sum[l-1] > b[j]) ++l;
        if (l > r) continue;
        
        // 从 [l-1, r-1] 区间转移
        int min_cost = f[j-1][l-1] + (m-j);
        if (f[j][r] > min_cost) {
            f[j][r] = min_cost;
            g[j][r] = sum_g[j-1][r-1] - sum_g[j-1][l-2];
        } else if (f[j][r] == min_cost) {
            g[j][r] += sum_g[j-1][r-1] - sum_g[j-1][l-2];
        }
    }
}
```

**Super_Cube 线段树更新逻辑**  
```cpp
void update(int p, int l, int r, pli val) {
    if (当前节点区间完全包含在 [l,r] 内) {
        合并 val 到节点的最小值和方案数
        return;
    }
    下推懒惰标记;
    if (左子节点与 [l,r] 相交) update(左子节点, l, r, val);
    if (右子节点与 [l,r] 相交) update(右子节点, l, r, val);
    合并子节点状态;
}
```

---

5. **同类型题目推荐**

1. P1776 宝物筛选 (多重背包+单调队列优化)
2. P1541 乌龟棋 (线性DP+多维状态)
3. P2513 逆序对数列 (计数DP+前缀和优化)

---

6. **可视化代码片段 (伪代码)**

```javascript
// Canvas 绘制 DP 状态网格
function drawGrid() {
    for (let j = 1; j <= m; j++) {
        for (let i = 1; i <= n; i++) {
            ctx.fillStyle = getColor(dp[j][i].cost); // 根据代价映射颜色
            ctx.fillRect(i*20, j*20, 18, 18);
            drawText(dp[j][i].count, i*20+5, j*20+15); // 显示方案数
        }
    }
    // 绘制当前处理的 b[j] 指针
    ctx.strokeStyle = '#00ff00';
    ctx.strokeRect(0, current_j*20, canvas.width, 20);
}
```

---

7. **个人心得摘录**

> "在调试时发现，当 b[j] 过小时无法转移，需要特判 l > r 的情况。这教会我边界检查的重要性" —— 灵乌路空  
> "线段树的懒惰标记下推顺序会影响方案数合并，必须保证原子性" —— Super_Cube  
> "将二维状态压缩为滚动数组，内存从 200MB 降至 10MB" —— CReatiQ

---
处理用时：76.48秒
# 题目信息

# Earnest Matrix Complement

## 题目背景

3, 2, 1, ... 我们是 —— RiOI 团队！

—— Felix & All, [特别感谢 3](https://www.luogu.com.cn/problem/T351681)

- Peter: 好消息，我的题目 T311013 已获批！
- $ \delta $: 幸好我的电脑没电，不然我可能参加了 wyrqwq 的比赛并得到负分。
- Felix: \[点赞\] 关于一首被删除歌曲的题目陈述！
- Aquawave: 我该为我的化学课感到悲伤吗？
- E.Space: 啊？
- Trine: 面包。
- Iris: 为什么总是我来测试题目？

时光走过，未来我们会再遇见。回首往事，大家都过上了各自想要的生活。

## 题目描述



Aquawave 有一个大小为 $ n \times m $ 的矩阵 $ A $，其中的元素只允许是 $ [1, k] $ 区间内的整数。矩阵中的一些位置已被填上整数，其余位置用 $ -1 $ 表示，代表尚未填充。

你的任务是将矩阵 $ A $ 填满所有空白位置，接着定义 $ c_{u,i} $ 为第 $ i $ 行中数字 $ u $ 出现的次数。Aquawave 将矩阵的美丽定义为：

$$ \sum_{u=1}^k \sum_{i=1}^{n-1} c_{u,i} \cdot c_{u,i+1}. $$

请找出在最佳填充方案下的矩阵 $ A $ 的最大美丽值。

## 说明/提示

在第一个测试用例中，矩阵 $ A $ 已经确定，其美丽值为：

$$ \sum_{u=1}^k \sum_{i=1}^{n-1} c_{u,i} \cdot c_{u,i+1} = c_{1,1} \cdot c_{1,2} + c_{1,2} \cdot c_{1,3} + c_{2,1} \cdot c_{2,2} + c_{2,2} \cdot c_{2,3} + c_{3,1} \cdot c_{3,2} + c_{3,2} \cdot c_{3,3} = 1 \cdot 1 + 1 \cdot 1 + 2 \cdot 0 + 0 \cdot 1 + 0 \cdot 2 + 2 \cdot 1 = 4。$$

在第二个测试用例中，可以这样填充矩阵：

$$ \begin{bmatrix} 2 & 3 & 3 \\ 2 & 2 & 3 \end{bmatrix}, $$

得到的美丽值为 $ 4 $。这可以被证明是最大的可能值。

在第三个测试用例中，以下为一种可能的最优填充方案：

$$ \begin{bmatrix} 1 & 1 & 1 \\ 1 & 2 & 1 \\ 1 & 1 & 4 \end{bmatrix}. $$

在第四个测试用例中，下面是一种可能的最优配置：

$$ \begin{bmatrix} 1 & 3 & 2 & 3 \\ 1 & 3 & 2 & 1 \\ 3 & 1 & 5 & 1 \end{bmatrix}. $$

在第五个测试用例中，以下是一种可能的最优填充：

$$ \begin{bmatrix} 5 & 5 & 2 \\ 1 & 8 & 5 \\ 7 & 5 & 6 \\ 7 & 7 & 4 \\ 4 & 4 & 4 \end{bmatrix}. $$

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
9
3 3 3
1 2 2
3 1 3
3 2 1
2 3 3
-1 3 3
2 2 -1
3 3 6
-1 -1 1
1 2 -1
-1 -1 4
3 4 5
1 3 2 3
-1 -1 2 -1
3 1 5 1
5 3 8
5 -1 2
1 8 -1
-1 5 6
7 7 -1
4 4 4
6 6 5
-1 -1 5 -1 -1 -1
-1 -1 -1 -1 2 -1
-1 1 3 3 -1 -1
-1 1 -1 -1 -1 4
4 2 -1 -1 -1 4
-1 -1 1 2 -1 -1
6 6 4
-1 -1 -1 -1 1 -1
3 -1 2 2 4 -1
3 1 2 2 -1 -1
3 3 3 3 -1 2
-1 3 3 -1 1 3
3 -1 2 2 3 -1
5 5 3
1 1 3 -1 1
2 2 -1 -1 3
-1 -1 -1 2 -1
3 -1 -1 -1 2
-1 1 2 3 -1
6 2 7
-1 7
-1 6
7 -1
-1 -1
-1 -1
2 2```

### 输出

```
4
4
10
10
8
102
93
58
13```

# AI分析结果



0. **题目翻译**

# Earnest Matrix Complement

## 题目背景

3, 2, 1,... 我们是 —— RiOI 团队！

—— Felix & All, [特别感谢 3](https://www.luogu.com.cn/problem/T351681)

- Peter: 好消息，我的题目 T311013 已获批！
- $ \delta $: 幸好我的电脑没电，不然我可能参加了 wyrqwq 的比赛并得到负分。
- Felix: [点赞] 关于一首被删除歌曲的题目陈述！
- Aquawave: 我该为我的化学课感到悲伤吗？
- E.Space: 啊？
- Trine: 面包。
- Iris: 为什么总是我来测试题目？

时光走过，未来我们会再遇见。回首往事，大家都过上了各自想要的生活。

## 题目描述

Aquawave 有一个大小为 $ n \times m $ 的矩阵 $ A $，元素为 $ [1, k] $ 的整数或 $ -1 $ 表示未填充。填充所有 $ -1 $ 后，定义美丽值为：

$$ \sum_{u=1}^k \sum_{i=1}^{n-1} c_{u,i} \cdot c_{u,i+1} $$

其中 $ c_{u,i} $ 是第 $ i $ 行中 $ u $ 的出现次数。求最大可能的美丽值。

## 样例说明（略）

---

1. **算法分类**  
   线性DP

2. **综合分析与结论**

**核心结论**：最优解中每行的空白必须填充同一数字，通过调整法可证明该结论。基于此设计动态规划：

- **状态定义**：$ f_{i,j} $ 表示第 $ i $ 行填 $ j $ 时的最大贡献
- **转移方程**：$ f_{i,j} = \max(f_{i-1,j} + \text{相邻贡献}, \max_k f_{i-1,k} + \text{跨行贡献}) $
- **优化关键**：将转移分解为全局加、全局取最大、单点加三种操作，用标记系统维护

**可视化设计**：
- **网格动画**：用Canvas绘制DP数组，每行对应一个颜色方块，转移时高亮变化的单元格
- **音效触发**：全局操作时播放"嘟嘟"声，单点操作时播放"滴"声，更新最大值时使用上升音阶
- **复古风格**：采用8位像素字体，状态值用16色调色板渲染，背景音乐为FC风格循环MIDI

3. **题解清单 (4星及以上)**

| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| IvanZhang2009  | ⭐⭐⭐⭐ | 首创三操作标记系统，时间复杂度最优（O(nm + k)）                         |
| Gold14526      | ⭐⭐⭐⭐ | 给出清晰的线段树实现框架，代码结构最易读                                |
| littlebug      | ⭐⭐⭐⭐ | 提出显式调整法证明，数学推导最严谨                                       |

4. **关键代码实现**

IvanZhang2009 的标记系统核心：
```cpp
// 全局标记维护：addtag(全局加), maxtag(全局取最大)
void alladd(cll x) { addtag += x; maxtag += x; }
void allmax(cll x) { maxtag = max(maxtag, x); }

// 单点更新：先计算真实值再更新
void add(cint x, cll y) {
    a[x] = max(a[x], maxtag - addtag) + y;
    mx = max(mx, a[x]);
}

// 查询时综合全局标记
ll ask() { return max(maxtag, mx + addtag); }
```

5. **相似题目推荐**

1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（多重背包优化）
2. [P1853 投资的最大效益](https://www.luogu.com.cn/problem/P1853)（滚动数组优化）
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)（依赖背包+状态压缩）

---

**可视化算法分析（DP状态转移）**

```javascript
// 伪代码示例：8位像素风格动画
class DPGrid {
  constructor() {
    this.colors = ["#FF0000","#00FF00",...,"#FFFFFF"]; // 16色FC调色板
    this.sound = new AudioContext();
  }

  playSound(freq) { /* 生成方波音效 */ }

  drawGrid(ctx, dp) {
    // 用像素块绘制DP数组，颜色映射数值大小
    dp.forEach((val, idx) => {
      ctx.fillStyle = this.colors[val % 16];
      ctx.fillRect(idx*16, currentRow*16, 15, 15);
    });
  }

  globalAdd(value) {
    this.playSound(440); // 全局加时播放440Hz音调
    // 显示所有方块数值上涨动画
  }

  globalMax() {
    this.playSound(880); // 高音提示最大值更新
    // 用闪光效果标记被覆盖的方块
  }
}
```

---

**个人心得摘录**

> IvanZhang2009："发现大部分操作是全局的，于是设计标记系统代替线段树，这是本题优化的关键转折点"

> littlebug："调试时发现未正确处理已存在的数字，加入双重清空机制后才通过所有测试用例"

> Gold14526："初始用线段树超时，后来发现维护全局标记即可，深刻理解了标记系统的本质是延迟更新"

---
处理用时：61.69秒
# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果



## 算法分类
组合数学

---

## 题解思路与核心难点
### 核心思路
1. **顶层的特殊性**：第n层居民必须发射恰好c架飞机，因为其只能看到自己发射的飞机。
2. **组合模型转化**：剩余m-c架飞机由前n-1层居民发射，每层有c次机会（前c个可见位置中选择发射时机）。
3. **组合数计算**：总共有(n-1)*c次机会中选择m-c次发射，方案数为组合数$\dbinom{(n-1)c}{m-c}$。

### 解决难点
- **动态规划误区**：初看可能考虑逐层决策的DP，但发现每层选择相互独立后，转化为组合问题。
- **视角约束转换**：将每层的发射限制转化为组合选择问题，需要理解发射次序不影响最终计数。

---

## 题解评分（≥4星）
1. **xyvsvg（5星）**  
   直接命中组合数学本质，代码简洁高效，预处理阶乘与逆元实现组合数计算。

2. **2022dyx（4星）**  
   通过数学证明得出组合结论，代码实现清晰，但样例处理部分略显冗余。

3. **CReatiQ（4星）**  
   明确点明组合意义，给出DP与组合双解法，思路全面但代码未完整展示。

---

## 最优思路提炼
### 关键技巧
- **组合模型构建**：将每层发射次数视为独立的选择空间，利用范德蒙德卷积合并结果。
- **数学归纳思维**：通过观察顶层约束的特殊性，快速推导出全局组合关系。

### 实现代码
```cpp
const int MOD = 1e9 + 7;
int fac[N], inv[N];

void precompute() {
    fac[0] = 1;
    for (int i = 1; i < N; ++i) 
        fac[i] = fac[i-1] * i % MOD;
    inv[N-1] = pow(fac[N-1], MOD-2, MOD);
    for (int i = N-2; i >= 0; --i) 
        inv[i] = inv[i+1] * (i+1) % MOD;
}

int solve(int n, int c, int m) {
    if (m < c || (n-1)*c < m - c) return 0;
    return fac[(n-1)*c] * inv[m-c] % MOD * inv[(n-1)*c - (m-c)] % MOD;
}
```

---

## 相似题目推荐
1. [P1494 组合数问题](https://www.luogu.com.cn/problem/P1494)  
   **考察点**：组合数预处理与模运算

2. [P3197 越狱](https://www.luogu.com.cn/problem/P3197)  
   **考察点**：排列组合逆向思维

3. [P3223 排队](https://www.luogu.com.cn/problem/P3223)  
   **考察点**：分层组合与约束处理

---

## 可视化与算法演示
### 动画设计
- **像素网格展示**：  
  顶楼用红色方块表示必须填满c格，下层每行展示c个可选位（绿色格子），用户发射时填充黄色方块。

- **动态组合过程**：  
  每次点击生成随机选择方案，高亮当前选择的格子，播放8-bit音效。

### 复古元素
- **音效设计**：  
  - 选择格子：短促"哔"声（Web Audio API生成方波）  
  - 错误操作：低沉"嗡"声  
  - 成功计算：上升音阶

- **画风实现**：  
  使用Canvas绘制16x16像素风格网格，搭配NES经典配色（#3A3A3A背景，#FFD700高亮）。

### 交互功能
- **自动演示模式**：  
  算法自动遍历组合选择过程，用不同颜色区分各层贡献，速度可调。

---

## 核心算法演示代码（节选）
```javascript
// Canvas绘制组合选择动画
function drawGrid(totalSlots, selected) {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i < totalSlots; i++) {
        ctx.fillStyle = selected.has(i) ? '#FFFF00' : '#00FF00';
        ctx.fillRect(10 + (i % 20)*15, 10 + Math.floor(i/20)*15, 12, 12);
    }
    // 绘制顶楼红色区块
    ctx.fillStyle = '#FF0000';
    for (let i = 0; i < c; i++) 
        ctx.fillRect(10 + i*15, height-30, 12, 12);
}
```

---

## 总结与扩展
本题通过巧妙的组合模型转化，将复杂的分层约束转化为组合数计算问题。训练此类问题的关键在于识别问题中的独立选择空间，并利用组合数学工具快速求解。在更复杂的版本中（如部分发射记录已知），可能需要结合容斥原理或DP优化处理约束条件。

---
处理用时：90.91秒
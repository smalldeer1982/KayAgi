# 题目信息

# Key of Like (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本之间的区别在于，在这个版本中保证 $$$k = 0$$$。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此第一位成员必定用唯一的钥匙打开唯一的锁。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 0
3 2 0
2 5 0
9 104 0```

### 输出

```
1 0 0
500000004 1 500000004
200000004 800000008
869203933 991076635 39374313 496894434 9358446 51822059 979588764 523836809 38844739```

# AI分析结果



---

**算法分类**: 概率与期望、动态规划

---

### **题解思路与算法要点**

1. **核心思路**  
   - 利用**期望的线性性**，将总期望拆分为每个锁被开启的期望贡献之和。  
   - 每个锁的开启过程视为一个独立周期，其中每个玩家的成功概率均匀分布。  
   - **动态规划**维护当前剩余锁数和起始玩家，计算每个玩家在各周期的贡献。

2. **解决难点**  
   - **对称性分析**：钥匙与锁的配对具有对称性，每次尝试的最优策略等价于随机选择剩余钥匙和锁。  
   - **概率均匀性**：每个锁在剩余 `m` 把时，任何一次尝试的成功概率为 `1/m`，无论之前是否失败。  
   - **循环轮次处理**：通过动态规划跟踪起始玩家，确保每个周期的轮次正确分配。

3. **对比题解**  
   - **Unnamed114514**：直接动态规划，状态为剩余锁数和起始玩家，转移时计算每个玩家的轮次贡献。代码复杂度较高但思路直接。  
   - **Halberd_Cease**：利用周期均匀性，每个锁的贡献按轮次均分，维护起始玩家概率分布。思路更简洁，数学推导更强。

---

### **最优思路提炼**

1. **关键技巧**  
   - **期望线性分解**：总期望 = ∑（每个锁被每个玩家开启的概率）。  
   - **轮次均匀性**：每个锁的开启周期中，每个轮次的成功概率固定为 `1/m`。  
   - **动态规划状态设计**：`f[i][j]` 表示剩余 `i` 把锁时，起始玩家为 `j` 的概率贡献。

2. **代码实现核心**  
   ```cpp
   // 动态规划转移核心代码
   for (int i = l; i >= 1; --i) {
       for (int j = 1; j <= n; ++j) {
           for (int k = 1; k <= n; ++k) {
               // 计算轮次贡献 delta
               int delta = i / n + (dis(k, j) <= i % n ? 1 : 0);
               f[j][i] += f[k][i + 1] * delta % mod;
           }
           f[j][i] = f[j][i] * inv[i] % mod; // 乘以概率 1/i
           ans[j] = (ans[j] + f[j][i]) % mod; // 累加贡献
       }
   }
   ```

---

### **可视化算法设计**

1. **动画方案**  
   - **像素风格演示**：用网格表示玩家和锁，每个锁的开启过程以颜色渐变显示。  
   - **关键状态高亮**：当前剩余锁数和起始玩家用闪烁边框标记。  
   - **轮次分配展示**：在 Canvas 中绘制玩家轮次队列，动态显示每个锁的尝试顺序。

2. **交互设计**  
   - **步进控制**：允许单步执行每个锁的分配，观察动态规划状态更新。  
   - **音效提示**：成功开锁时播放上升音调，轮次切换时播放点击音效。  
   - **自动演示模式**：模拟算法自动分配轮次，显示每个玩家的期望增长过程。

---

### **同类型题目推荐**

1. [CF939E Maximize!](https://codeforces.com/problemset/problem/939/E)  
   （期望与贪心结合）  
2. [Luogu P6835 概率生成函数](https://www.luogu.com.cn/problem/P6835)  
   （概率生成函数与动态规划）  
3. [ARC098D Donation](https://atcoder.jp/contests/arc098/tasks/arc098_d)  
   （轮次选择与期望分析）

---

### **个人心得摘录**

- **对称性简化**：“钥匙与锁的对称关系”是突破口，避免枚举所有组合。  
- **动态规划优化**：状态设计需兼顾剩余锁数和轮次起始，避免重复计算。  
- **调试技巧**：验证小样例（如 `l=2, n=3`）的期望计算，确保概率均匀性。  

---

**评分 ≥4星的题解**:  
1. **Halberd_Cease (4.5星)**  
   - 利用周期均匀性，数学推导清晰。  
   - 维护起始玩家分布，动态规划设计巧妙。  
   - 样例验证充分，代码可读性较高。  

2. **Unnamed114514 (4星)**  
   - 动态规划直接实现，状态转移逻辑严谨。  
   - 处理轮次贡献的 `delta` 计算有创新性。  
   - 代码复杂度稍高，但核心思路正确。

---
处理用时：148.54秒
# 题目信息

# 2048

## 题目描述

The programmers from the R2 company love playing 2048. One day, they decided to invent their own simplified version of this game — $ 2^{k} $ on a stripe.

Imagine an infinite in one direction stripe, consisting of unit squares (the side of each square is equal to the height of the stripe). Each square can either be empty or contain some number.

Initially, all squares are empty. Then at infinity one of the unit squares number 2 or 4 appears. Then the player presses a button once, and the appeared number begins to move towards the beginning of the stripe. Let's assume that some number $ x $ moves to the beginning of the stripe, then it will stop if:

1. it either gets in the first square of the stripe;
2. or it is in the square that is preceded by a square with number $ y $ $ (y≠x) $ . But if number $ x $ at some point of time gets to the square with the same number then both numbers add to each other and result in $ 2x $ . The new number $ 2x $ continues moving to the beginning of the stripe by the same rules.

After the final stop of the number moving process, the infinity gets a new number 2 or 4 and the process repeats. Read the notes to the test samples to better understand the moving strategy.

I guess you've understood that the game progress fully depends on the order in which numbers 2 and 4 appear. Let's look at some sequence of numbers 2 and 4 in the game. We assume that the sequence is winning if it results in at least one square getting the number greater or equal than $ 2^{k} $ .

The goal of the game is to make up a winning sequence of $ n $ numbers. But not everything is so simple, some numbers in the sequence are identified beforehand. You are given a sequence consisting of numbers 0, 2, 4. Count how many ways there are to replace each 0 of the sequence with 2 or 4 to get a winning sequence.

## 说明/提示

Consider the first example. The beginning of the strip will look as follows:

2 $ → $ 4 $ → $ 8 $ → $ 8 2 $ → $ 8 4 $ → $ 8 4 2 $ → $ 16.

To better understand the game, you can see the original game on http://gabrielecirulli.github.io/2048/. Please note that the game that is described on the strip is slightly different from the original game (when the two numbers add up in the original game, they do not keep moving). Be careful, the game is addictive, there isn't much time for the contest!

## 样例 #1

### 输入

```
7 4
2 2 4 2 2 2 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
1 3
0
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2 3
0 4
```

### 输出

```
1
```

## 样例 #4

### 输入

```
5 4
2 0 0 4 4
```

### 输出

```
2
```

# AI分析结果



# 题目重写  
## 题目描述  
R2 公司的程序员们热爱玩 2048。某天，他们决定发明一个在条带上的简化版本——条纹上的 $2^k$ 游戏。  

想象一个单向无限延伸的条纹，由单位方格组成（每个方格的高度与条纹高度相同）。每个方格可以是空的或包含某个数字。  

初始时所有方格为空。在无限时刻，某个单位方格会出现数字 2 或 4。玩家按下按钮一次，该数字开始向条纹起点移动。假设数字 $x$ 向起点移动时，会在以下情况停止：  
1. 到达条纹的第一个方格；  
2. 所在方格前一个方格有数字 $y$（$y≠x$）。但如果 $x$ 遇到相同数字，则合并为 $2x$，继续按规则移动。  

当数字停止后，无限位置会生成新数字 2 或 4，重复此过程。  

若某个序列能使得合并后的最大数字 ≥ $2^k$，则称该序列为获胜序列。给定包含 0、2、4 的序列，求将 0 替换为 2 或 4 的获胜序列方案数。  

## 输入格式  
输入第一行为 $n$ 和 $k$，第二行给出长度为 $n$ 的序列。  

## 输出格式  
输出替换方案数模 $10^9+7$。  

## 样例  
### 样例输入1  
```
7 4  
2 2 4 2 2 2 2  
```  
### 样例输出1  
```
1  
```  
### 样例输入2  
```
1 3  
0  
```  
### 样例输出2  
```
0  
```  

---

# 算法分类  
**线性DP**  

---

# 综合分析与结论  
## 核心思路  
动态规划的核心思想是维护**最长可合并后缀和**。定义 $dp[i][j]$ 表示前 $i$ 个元素处理后，当前可合并后缀和为 $j$ 的方案数。通过分类讨论新增数字对后缀的影响，实现状态转移：  
- **新增2**：直接累加到当前后缀和（若不超过 $2^k$）。  
- **新增4**：若当前后缀末尾有无法合并的 2（即 $j \bmod 4 = 2$），则重置后缀为 4；否则累加 4 并合并。  

## 关键状态转移方程  
$$
dp[i][\text{min}(j+2, 2^k)] \xleftarrow{+} dp[i-1][j] \quad (\text{新增2})  
$$  
$$
dp[i][4] \xleftarrow{+} dp[i-1][j] \quad (\text{新增4且} j \bmod 4 = 2)  
$$  
$$
dp[i][\text{min}(j+4, 2^k)] \xleftarrow{+} dp[i-1][j] \quad (\text{新增4且} j \bmod 4 \neq 2)  
$$  

## 解决难点  
- **状态压缩**：将可合并的后缀和压缩为不超过 $2^k$ 的整数，避免状态爆炸。  
- **滚动数组优化**：利用奇偶性滚动减少空间复杂度至 $O(2^k)$。  

## 可视化设计  
- **像素风格DP矩阵**：用 Canvas 绘制 $n \times 2^k$ 的网格，每个格子表示 $dp[i][j]$ 的值，颜色深浅表示方案数多少。  
- **动画效果**：新增元素时高亮当前操作格子，播放 8-bit 音效；合并时触发上扬音调。  
- **自动演示模式**：按步长自动更新 DP 矩阵，展示状态转移路径。  

---

# 题解清单（≥4星）  
1. **skylee（4.5星）**  
   - **亮点**：简洁的滚动数组实现，精准处理 2/4 转移条件。  
   - **代码片段**：  
     ```cpp  
     if(x!=2) (f[i&1][j&1?2:min(j+2,1<<k)]+=f[(i&1)^1][j])%=mod;  
     if(x!=4) (f[i&1][min(j+1,1<<k)]+=f[(i&1)^1][j])%=mod;  
     ```  

2. **H6_6Q（4.2星）**  
   - **亮点**：通过模运算判断单独 2 的存在，逻辑清晰。  
   - **代码片段**：  
     ```cpp  
     if(j%4 == 2) dp[i][4] += dp[i-1][j];  
     else dp[i][min(j+4,1<<k)] += dp[i-1][j];  
     ```  

3. **Hevix（4.0星）**  
   - **亮点**：使用位运算快速判断后缀状态，提升效率。  
   - **代码片段**：  
     ```cpp  
     if(j & 2) nj = 4;  
     else nj = min(j+4,1<<k);  
     ```  

---

# 核心代码实现  
```cpp  
#include <cstdio>  
#include <algorithm>  
using namespace std;  
const int MOD = 1e9+7;  
int dp[2][1<<12]; // 滚动数组优化  

int main() {  
    int n, k, x;  
    scanf("%d%d", &n, &k);  
    int full = 1 << k;  
    dp[0][0] = 1;  
    for(int i=1; i<=n; ++i) {  
        scanf("%d", &x);  
        int cur = i%2, prev = 1-cur;  
        fill(dp[cur], dp[cur]+full+1, 0);  
        for(int j=0; j<=full; ++j) {  
            if(!dp[prev][j]) continue;  
            if(x != 4) { // 可填2  
                int nj = min(j+2, full);  
                dp[cur][nj] = (dp[cur][nj] + dp[prev][j]) % MOD;  
            }  
            if(x != 2) { // 可填4  
                int nj = (j & 2) ? 4 : min(j+4, full);  
                dp[cur][nj] = (dp[cur][nj] + dp[prev][j]) % MOD;  
            }  
        }  
    }  
    printf("%d", dp[n%2][full]);  
    return 0;  
}  
```  

---

# 同类型题目推荐  
1. **P1880 石子合并**（区间DP）  
2. **P1048 采药**（0-1背包）  
3. **P1064 金明的预算方案**（依赖背包）  

---

# 可视化实现要点  
1. **Canvas 网格**：初始化 $n \times 2^k$ 的格子，用渐变色表示方案数。  
2. **音效触发**：  
   - `move.wav`：元素移动时播放；  
   - `merge.wav`：合并时播放高音调。  
3. **自动模式**：设置定时器逐步执行转移，高亮当前更新的 DP 状态。  

--- 

通过上述分析，可系统掌握此类线性DP问题的解法，并借助可视化工具深化理解。

---
处理用时：84.04秒
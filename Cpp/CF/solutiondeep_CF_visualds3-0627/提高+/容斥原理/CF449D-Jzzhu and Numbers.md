# 题目信息

# Jzzhu and Numbers

## 题目描述

Jzzhu have $ n $ non-negative integers $ a_{1},a_{2},...,a_{n} $ . We will call a sequence of indexes $ i_{1},i_{2},...,i_{k} $ $ (1<=i_{1}<i_{2}<...<i_{k}<=n) $ a group of size $ k $ .

Jzzhu wonders, how many groups exists such that $ a_{i1} $ & $ a_{i2} $ & ... & $ a_{ik}=0 $ $ (1<=k<=n) $ ? Help him and print this number modulo $ 1000000007 $ $ (10^{9}+7) $ . Operation $ x $ & $ y $ denotes bitwise AND operation of two numbers.

## 样例 #1

### 输入

```
3
2 3 3
```

### 输出

```
0
```

## 样例 #2

### 输入

```
4
0 1 2 3
```

### 输出

```
10
```

## 样例 #3

### 输入

```
6
5 2 0 5 2 1
```

### 输出

```
53
```

# AI分析结果



# 算法分类与题解分析

**唯一算法分类**：高维前缀和（SOS DP）与容斥原理

---

## 综合分析与结论

### 核心思路
题目要求计算非空子集的按位与结果为0的方案数。直接暴力枚举子集不可行，需采用高效算法。核心思路为：
1. **高维前缀和**预处理每个数作为子集的超集数目。
2. **容斥原理**消除重复计数，得到精确结果。

### 算法流程
1. **高维前缀和统计超集数目**：  
   - 初始化数组`f[s]`表示数值`s`的出现次数。
   - 逐位处理（0到19位），从高位到低位反向遍历所有可能的数，累加超集数目。  
   - 代码片段：
     ```cpp
     for (int i = 0; i < 20; i++)
         for (int j = (1<<20)-1; j >= 0; j--)
             if (!(j & (1<<i))) f[j] += f[j | (1<<i)];
     ```
2. **计算贡献并容斥**：  
   - 每个数`s`的贡献为`2^f[s] -1`，但此值包含超集贡献，需通过差分（容斥）消除。  
   - 倒置高维前缀和过程，用减法分离每个子集的独立贡献。  
   - 容斥系数由二进制中1的个数的奇偶性决定。

### 解决难点
- **超集统计**：通过高维前缀和快速统计每个数作为子集的超集数目。
- **重复贡献消除**：利用容斥或逆高维前缀和（差分）精确计算每个子集的独立贡献。

### 可视化设计思路
- **像素动画**：以网格展示每个数的高维前缀和更新过程，当前处理的位用红色高亮，更新的数值用绿色标记。
- **步进控制**：允许单步执行观察每位处理后的数组状态。
- **音效提示**：每次处理完一位时播放“滴”声，完成所有位后播放上扬音效。

---

## 题解评分 (≥4星)

1. **Tgotp（★★★★★）**  
   - **亮点**：代码简洁，高维前缀和两次处理（正向统计、逆向差分），逻辑清晰。  
   - **关键代码**：
     ```cpp
     doit(1); // 高维前缀和统计超集数目
     rep(i,0,s) f[i] = ksm(2,f[i]) - 1; // 计算贡献
     doit(-1); // 逆向差分消除重复
     ```

2. **leozhang（★★★★☆）**  
   - **亮点**：容斥原理与高维前缀和结合，二进制位统计明确。  
   - **关键代码**：
     ```cpp
     for (int j=0; j<=maxx; j++) {
         int cnt = __builtin_popcount(j);
         f[cnt] = (f[cnt] + (pow2[dp[j]] - 1)) % mod; // 按位容斥
     }
     ```

3. **Soulist（★★★★☆）**  
   - **亮点**：结合FMT（快速莫比乌斯变换）与容斥，数学推导清晰。  
   - **关键代码**：
     ```cpp
     FWT(c, 1); // 高维前缀和
     Ans = ∑ (-1)^|i| * (2^c[i] - 1); // 容斥求和
     ```

---

## 最优思路提炼

### 关键技巧
1. **高维前缀和反向遍历**：  
   处理每位时从全1数递减遍历，确保更新顺序正确。
2. **贡献差分**：  
   正向统计超集数目后逆向差分，避免重复计算。
3. **容斥系数**：  
   利用二进制中1的个数的奇偶性确定加减方向。

### 代码实现
```cpp
// Tgotp题解核心代码
void doit(int F) {
    rep(i,0,19)
        repd(j,s,0)
            if ((j & (1<<i)) == 0)
                f[j] = (f[j] + f[j|(1<<i)] * F) % mod;
}

int main() {
    // 统计初始出现次数
    rep(i,1,n) { int x; scanf("%d",&x); ++f[x]; }
    s = (1<<20)-1;
    doit(1); // 高维前缀和
    rep(i,0,s) f[i] = ksm(2,f[i]) - 1; // 计算贡献
    doit(-1); // 逆向差分
    cout << f[0] << endl;
}
```

---

## 同类型题与算法套路

### 相似题目
1. **CF449D**：本题原题，直接应用高维前缀和。
2. **P3174 [HAOI2015]按位或**：利用高维前缀和计算期望。
3. **P6442 [COCI2008-2009#4] GEORGE**：子集统计与容斥。

### 通用解法
- **子集/超集计数**：高维前缀和（SOS DP）预处理。
- **容斥原理**：按二进制位奇偶性调整贡献。

---

## 洛谷推荐题目
1. **P5495**：Dirichlet前缀和（高维前缀和扩展）。  
2. **P5494**：子集统计与二进制处理。  
3. **P2113**：容斥原理与组合数学。

---

## 个人心得摘录
- **调试教训**：高维前缀和遍历顺序错误会导致重复更新（需反向遍历）。
- **顿悟点**：`2^f[s]-1`直接计算超集贡献，逆向差分即容斥。

---

## 可视化与复古动画设计

### 算法演示
1. **Canvas网格绘制**：  
   - 20x20网格表示二进制位，高亮当前处理的位（如第3位红色）。
   - 数值更新时，绿色标记当前数`j`，黄色标记`j|(1<<i)`。

2. **音效与动画**：  
   - **步进音效**：每次处理位时播放“滴”声。
   - **完成音效**：所有位处理完后播放胜利音效。

3. **自动演示模式**：  
   - 按位自动处理，间隔1秒，可暂停/继续。

### 代码片段（JS伪代码）
```javascript
// 高维前缀和动画
function animateSOS() {
    let bit = 0;
    const interval = setInterval(() => {
        highlightBit(bit); // 高亮当前处理的位
        for (let j = (1<<20)-1; j >=0; j--) {
            if (!(j & (1<<bit))) {
                updateCell(j, j | (1<<bit)); // 更新网格颜色
                playSound('beep'); // 播放音效
            }
        }
        bit++;
        if (bit >=20) clearInterval(interval);
    }, 1000);
}
```

---
处理用时：116.48秒
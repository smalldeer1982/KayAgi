# 题目信息

# Too Easy Problems

## 题目描述

你正在准备一场关于调度理论的考试。

这场考试会持续正好 $T$ 毫秒，由 $n$ 道题目组成。

你可以用 $t_i$ 毫秒解决第 $i$ 个问题，或者忽略它并不消耗时间。你也不需要用来在做完一道题之后休息的时间。

不幸的是，你的老师认为一些题目对你来说太简单了。因此，他对于每道题 $i$ 规定了一个整数 $a_i$，表示题目 $i$ 只在你总共解决了不超过 $a_i$ 个问题（包括问题 $i$ ）的情况下为你的最终成绩加上一分。

正式地，假设你在考试中解决了问题 $p_1,p_2,\cdots,p_k$。那么，你的最终成绩 $s$ 会等于在 $1$ 到 $k$ 之间的满足 $k\le a_{p_j}$ 的 $j$ 的个数。

你已经意识到这场考试真正的第一道题目已经放在了你面前。因此，你想要选择一组题目来解决，从而最大化你的最终成绩。不要忘记这场考试有时间限制，而你必须有足够的时间来解决所有你选择的题目。如果存在多个最优解，任意输出一组即可。

## 说明/提示

$1\le n\le 2\times10^5$

$1\le T\le10^9$

$0\le k\le n$

## 样例 #1

### 输入

```
5 300
3 100
4 150
4 80
2 90
2 300
```

### 输出

```
2
3
3 1 4
```

## 样例 #2

### 输入

```
2 100
1 787
2 788
```

### 输出

```
0
0

```

## 样例 #3

### 输入

```
2 100
2 42
2 58
```

### 输出

```
2
2
1 2
```

# AI分析结果



## 算法分类
**二分答案**

---

## 题解思路与算法分析
### 核心思路
题目要求在时间限制内选择最多题目，使得每个选中题目i的条件是总题数k ≤ a_i。通过**二分答案**确定最大可行k值，并验证能否选出k个满足a_i ≥k且总耗时≤T的题目。

### 解决难点
1. **单调性证明**：若存在k满足条件，则所有≤k的值均可行。二分法可快速定位最大k。
2. **高效验证**：预处理按耗时排序后，每次验证只需线性扫描，时间复杂度O(n)。
3. **索引处理**：排序后保留原题号以正确输出结果。

---

## 题解评分（≥4星）
1. **Sol1（★★★★☆）**  
   思路清晰，预处理排序+线性验证，时间复杂度最优。代码可读性高，变量命名合理。
   
2. **JimmyLee（★★★★☆）**  
   结构简洁，正确使用二分和排序，但变量名较简略。逻辑与Sol1一致，时间复杂度相同。

3. **Black_Porridge（★★★★☆）**  
   正确实现二分与验证，但初始二分范围过大。代码结构稍显复杂，但核心逻辑正确。

---

## 最优思路提炼
1. **二分答案框架**：通过二分k值快速缩小解空间。
2. **贪心验证策略**：按耗时排序后，优先选时间短且满足a_i ≥k的题目。
3. **线性时间复杂度**：预处理排序后，每次验证仅需O(n)时间。

---

## 同类型题目
- **P2678 跳石头**（二分答案+贪心验证）
- **P1083 借教室**（二分答案+差分数组）
- **P4344 脑力治疗仪**（二分答案+滑动窗口）

---

## 算法可视化设计
### 动画方案
1. **排序展示**：将所有题目按耗时升序排列为水平方块，颜色深浅表示a_i大小。
2. **二分过程**：动态调整k值，高亮当前候选k的阈值线。
3. **选择演示**：从左到右扫描方块，标记满足a_i ≥k且总时间未超限的题目。
4. **时间累加**：顶部进度条显示已选题目总耗时，超过T时触发红色警报。

### 复古像素风格
- **颜色方案**：8-bit调色板，绿色表示选中，红色超限，灰色不满足条件。
- **音效**：选中时播放短促“哔”声，成功/失败时播放不同音调。
- **自动演示**：AI自动调整k值，逐步展示最优解寻找过程。

---

## 核心代码实现
```cpp
struct Problem { int a, t, idx; };
bool operator<(const Problem& x, const Problem& y) { return x.t < y.t; }

int n, T;
Problem p[MAXN];

bool check(int k) {
    int sum = 0, cnt = 0;
    for (int i = 0; i < n && cnt < k; ++i) {
        if (p[i].a >= k && sum + p[i].t <= T) {
            sum += p[i].t;
            cnt++;
        }
    }
    return cnt >= k;
}

void solve() {
    sort(p, p + n);
    int l = 0, r = n, ans = 0;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check(mid)) ans = mid, l = mid + 1;
        else r = mid - 1;
    }
    // 输出答案部分略
}
```

---

## 个人心得摘录
"预处理排序是优化验证的关键，将每次验证复杂度从O(n log n)降为O(n)——Sol1题解中的排序处理大幅提升了效率。"

---

## 可视化代码片段（Canvas）
```javascript
// 绘制题目方块
function drawProblems(ctx, problems, k) {
    problems.forEach((p, i) => {
        ctx.fillStyle = p.a >= k ? "#00FF00" : "#666";
        ctx.fillRect(i * 10, 0, 8, 8); // 像素方块
    });
}

// 更新动画帧
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawProblems(ctx, sortedProblems, currentK);
    drawTimeBar(ctx, currentTimeUsed);
    if (autoPlay) requestAnimationFrame(nextStep);
}
```

---

通过二分答案与贪心策略的高效结合，本题在2e5数据规模下仍能快速求解，核心在于充分利用排序的预处理减少重复计算。

---
处理用时：85.21秒
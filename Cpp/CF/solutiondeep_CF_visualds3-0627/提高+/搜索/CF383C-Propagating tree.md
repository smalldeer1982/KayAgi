# 题目信息

# Propagating tree

## 题目描述

很久以前，有一棵神橡树(oak)，上面有$n$个节点，从$1$~$n$编号，由$n-1$条边相连。它的根是$1$号节点。  

这棵橡树每个点都有一个权值，你需要完成这两种操作：
$1$ $u$ $val$ 表示给$u$节点的权值增加$val$  
$2$ $u$ 表示查询$u$节点的权值   

但是这不是普通的橡树，它是神橡树。  
所以它还有个神奇的性质：当某个节点的权值增加$val$时，它的子节点权值都增加$-val$，它子节点的子节点权值增加$-(-val)$...... 如此一直进行到树的底部。

## 说明/提示

$1\le n,m \le 2\times 10^5$  
$1\le a_i,val \le 1000$  
$1\le u,v \le n$

## 样例 #1

### 输入

```
5 5
1 2 1 1 2
1 2
1 3
2 4
2 5
1 2 3
1 1 2
2 1
2 2
2 4
```

### 输出

```
3
3
0
```

# AI分析结果



## 唯一算法分类：DFS

## 综合分析与结论

### 核心思路与难点
1. **DFS序转换**：通过DFS遍历生成每个节点的进入/离开时间戳（L[u]和R[u]），将子树操作转化为区间操作。
2. **奇偶性处理**：修改时根据节点深度的奇偶性决定符号变化，利用树状数组或线段树高效处理区间修改。
3. **优化策略**：将正负交替的修改转换为单次区间操作，通过差分树状数组实现O(1)更新和O(logn)查询。

### 可视化设计
- **DFS遍历动画**：展示DFS生成时间戳的过程，节点按访问顺序展开，用不同颜色区分奇偶层。
- **区间修改高亮**：在树状数组/线段树的区间操作中，动态显示修改范围和符号变化（红色表示+val，蓝色表示-val）。
- **查询反馈**：单点查询时，显示当前节点的初始值叠加树状数组前缀和，结合奇偶性计算最终值。

### 复古像素化实现（可选）
- **8-bit风格**：节点用方块表示，奇偶层不同颜色，子树区间以闪烁边框标记。
- **音效设计**：DFS遍历时播放“滴”声，修改区间时播放不同音调，查询成功时播放短促旋律。
- **自动演示模式**：模拟AI逐步执行DFS和修改操作，支持暂停/加速观察细节。

---

## 题解评分（≥4星）

### lzjsy（⭐⭐⭐⭐⭐）
- **亮点**：巧用单树状数组，根据深度奇偶性在查询时动态调整符号，代码简洁高效。
- **关键代码**：
```cpp
if(dep[v]&1) add(L[v],b), add(R[v]+1,-b);
else add(L[v],-b), add(R[v]+1,b);
```

### SSerxhs（⭐⭐⭐⭐）
- **亮点**：树状数组差分优化，仅维护修改量的奇偶差异，查询时直接计算。
- **核心思路**：
```cpp
if(dep[x]&1) add(dfn[x],dfn[x]+siz[x]-1,z);
else add(dfn[x],dfn[x]+siz[x]-1,-z);
```

### cirnovsky（⭐⭐⭐⭐）
- **亮点**：双树状数组分别维护奇偶层修改，逻辑清晰易扩展。
- **代码片段**：
```cpp
Modify(L[x], v, fywf[x]);
Modify(R[x] + 1, -v, fywf[x]);
```

---

## 最优思路提炼
1. **DFS序区间化**：通过一次DFS将子树映射为连续区间。
2. **奇偶符号分离**：修改时根据根节点奇偶性决定区间操作的正负。
3. **树状数组差分**：利用差分技巧实现O(1)区间修改，查询时前缀和叠加符号。

---

## 同类型题推荐
1. **P3384 【模板】轻重链剖分**（子树修改+路径查询）
2. **P3373 【模板】线段树 2**（区间乘法与加法结合）
3. **CF620E New Year Tree**（子树颜色覆盖+位运算优化）

---

## 个人心得摘录
- **lzjsy**：“修改时要住意R[v]+1”——差分边界易错点。
- **SSerxhs**：“没有区间询问，树状数组就好了”——强调根据问题特征选择数据结构。
- **K2sen**：“懒标记合并复杂度陷阱”——需注意分层处理的必要性。

---

## 核心代码实现（树状数组差分）
```cpp
void dfs(int u, int fa) {
    L[u] = ++cnt;
    for (int v : G[u]) if (v != fa) {
        dep[v] = dep[u] + 1;
        dfs(v, u);
    }
    R[u] = cnt;
}

void update(int u, int val) {
    int sgn = (dep[u] % 2) ? 1 : -1;
    add(L[u], sgn * val);
    add(R[u] + 1, -sgn * val);
}

int query(int u) {
    int sum = prefix_sum(L[u]);
    return val[u] + (dep[u] % 2 ? sum : -sum);
}
```

---

## 可视化与算法演示（DFS序生成）
```javascript
// 伪代码：Canvas绘制DFS过程
function drawDFS(node, depth) {
    ctx.fillStyle = depth % 2 ? "#FF0000" : "#0000FF";
    ctx.fillRect(x, y, 30, 30); // 绘制节点
    setTimeout(() => {
        children.forEach(child => drawDFS(child, depth + 1));
    }, 500); // 延迟展示子节点
}
```

---
处理用时：78.32秒
# 题目信息

# Zuma

## 题目描述

$\texttt{Genos}$ 最近在他的手机上下载了祖玛游戏。在祖玛游戏里，存在 $n$ 个一行的宝石，第 $i$ 个宝石的颜色是 $C_i$。这个游戏的目标是尽快的消灭一行中所有的宝石。

在一秒钟，$\texttt{Genos}$ 能很快的挑选出这些有颜色的宝石中的一个回文的、连续的子串，并将这个子串移除。每当一个子串被删除后，剩余的宝石将连接在一起，形成一个新的行列。

你的任务是：求出把整个宝石串都移除的最短时间。

## 说明/提示

在第一个例子中，$\texttt{Genos}$ 可以在一秒钟就把这行珠子全部移走。在第二个例子中，$\texttt{Genos}$ 一次只能移走一个珠子，所以移走三个珠子花费他三秒。在第三个例子中，为了达到 $2$ 秒的最快时间，先移除回文串 $\texttt{4 4}$,再移除回文串 $\texttt{1 2 3 2 1}$。

感谢 @Administrator2004 提供的翻译

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
3
```

## 样例 #3

### 输入

```
7
1 4 4 2 3 2 1
```

### 输出

```
2
```

# AI分析结果



---

## **算法分类**
**其他搜索**（区间动态规划）

---

## **题解思路、算法要点与解决难点**

### **核心思路**
采用**区间DP**模型，定义 `dp[i][j]` 为消除区间 `[i,j]` 所需的最少次数。通过逐步合并子区间的解，处理回文结构的特殊性质。

### **算法要点**
1. **状态初始化**  
   - `dp[i][i] = 1`（单个字符需1次）  
   - `dp[i][i+1] = 1` 若两端相同，否则为2  
2. **状态转移**  
   - **两端相同**：`dp[i][j] = min(dp[i][j], dp[i+1][j-1])`  
   - **枚举分割点**：`dp[i][j] = min(dp[i][k] + dp[k+1][j])`  
3. **遍历顺序**  
   按区间长度从小到大填充，确保子问题已解。

### **解决难点**
- **回文嵌套处理**：当两端字符相同时，利用中间子区间的结果直接合并，避免冗余分割。
- **边界条件**：正确处理长度为2的区间，避免因未初始化导致错误转移。

---

## **最优思路/技巧提炼**
1. **回文合并优化**  
   当 `a[i] == a[j]` 时，直接利用 `dp[i+1][j-1]` 的结果，无需额外分割。
2. **剪枝策略**  
   在枚举分割点时，优先处理两端相同的条件，减少无效计算。
3. **初始化技巧**  
   将 `dp[i][i-1]` 初始化为1，简化偶数长度回文的处理。

---

## **题解评分 (≥4星)**
| 作者 | 亮点 | 评分 |
|------|------|-----|
| QwQcOrZ | 明确的转移方程与初始化逻辑，代码清晰 | ⭐⭐⭐⭐ |
| installb | 巧妙处理偶数回文，初始化优化 | ⭐⭐⭐⭐ |
| xcxc82 | 分步解释回文合并策略，适合新手理解 | ⭐⭐⭐⭐ |

---

## **可视化与算法演示**
### **动画设计**
- **网格填充**：以二维网格展示 `dp[i][j]` 的填充过程，颜色标记不同值（如红色表示高代价，绿色表示低代价）。  
- **回文合并高亮**：当 `a[i] == a[j]` 时，高亮区间 `[i+1,j-1]`，并动态显示合并过程。  
- **分割点枚举**：用闪烁效果展示分割点 `k` 的遍历，实时更新 `dp[i][j]` 的最小值。

### **复古像素风格**
- **像素节点**：将区间 `[i,j]` 表示为8位风格的像素块，消除时播放经典音效（如《吃豆人》得分音）。  
- **自动演示**：按区间长度从小到大自动填充网格，用户可暂停/调整速度观察细节。  
- **音效触发**：  
  - 消除回文时播放上扬音效  
  - 错误操作（如越界）时播放低音警报  

---

## **代码实现（核心片段）**
```cpp
int dp[N][N], a[N];
memset(dp, 0x3f, sizeof(dp));
for (int i = 1; i <= n; ++i) {
    dp[i][i] = 1;
    if (i < n) dp[i][i+1] = (a[i] == a[i+1]) ? 1 : 2;
}
for (int len = 3; len <= n; ++len) {
    for (int i = 1; i + len - 1 <= n; ++i) {
        int j = i + len - 1;
        if (a[i] == a[j]) dp[i][j] = dp[i+1][j-1];
        for (int k = i; k < j; ++k) {
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]);
        }
    }
}
cout << dp[1][n];
```

---

## **相似题目推荐**
1. [P4170 [CQOI2007]涂色](https://www.luogu.com.cn/problem/P4170)  
   （区间DP，类似合并策略）
2. [P1435 回文字串](https://www.luogu.com.cn/problem/P1435)  
   （回文结构处理，区间DP变形）
3. [CF1114D Flood Fill](https://www.luogu.com.cn/problem/CF1114D)  
   （区间合并与颜色扩展）

---
处理用时：61.81秒
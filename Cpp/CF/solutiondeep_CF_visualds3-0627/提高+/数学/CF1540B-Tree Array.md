# 题目信息

# Tree Array

## 题目描述

You are given a tree consisting of $ n $ nodes. You generate an array from the tree by marking nodes one by one.

Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree.

After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node.

It can be shown that the process marks all nodes in the tree.

The final array $ a $ is the list of the nodes' labels in order of the time each node was marked.

Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.

The number of inversions in an array $ a $ is the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i > a_j $ . For example, the array $ [4, 1, 3, 2] $ contains $ 4 $ inversions: $ (1, 2) $ , $ (1, 3) $ , $ (1, 4) $ , $ (3, 4) $ .

## 说明/提示

This is the tree from the first sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/3833e6cdc8f432e8774aa8c02d9352118566a812.png)For the first sample, the arrays are almost fixed. If node $ 2 $ is chosen initially, then the only possible array is $ [2, 1, 3] $ ( $ 1 $ inversion). If node $ 3 $ is chosen initially, then the only possible array is $ [3, 1, 2] $ ( $ 2 $ inversions). If node $ 1 $ is chosen initially, the arrays $ [1, 2, 3] $ ( $ 0 $ inversions) and $ [1, 3, 2] $ ( $ 1 $ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $ \frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6} $ .

 $ 166666669 \cdot 6 = 7 \pmod {10^9 + 7} $ , so the answer is $ 166666669 $ .

This is the tree from the second sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/7f613b365926417ec34142a093ccc13b3b572f4f.png)This is the tree from the third sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/4cf8ac5fc765cc7cdc6657a332a13e66dcba8fef.png)

## 样例 #1

### 输入

```
3
1 2
1 3```

### 输出

```
166666669```

## 样例 #2

### 输入

```
6
2 1
2 3
6 1
1 4
2 5```

### 输出

```
500000009```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
2 5```

### 输出

```
500000007```

# AI分析结果



**算法分类**  
组合数学

---

### **题解思路与解决难点**

**核心思路**  
1. **期望拆分**：利用期望线性性，将总期望拆分为每对节点逆序概率之和。  
2. **LCA关键路径**：每对节点逆序概率仅取决于其到LCA的路径长度。  
3. **概率动态规划**：预处理二维DP表`f[i][j]`，表示路径长度差为i、j时先选左边节点的概率，递推公式：  
   \[
   f[i][j] = \frac{1}{2}(f[i-1][j] + f[i][j-1])
   \]  
   边界条件：`f[0][j] = 1`, `f[i][0] = 0`。

**解决难点**  
- **树结构建模**：通过LCA将树路径抽象为独立概率模型。  
- **概率模型转换**：将复杂选择过程等价为两栈等概率弹出问题。  
- **高效预处理**：DP表预处理复杂度O(n²)，枚举所有点对复杂度O(n³)。

---

### **题解评分 (≥4星)**

1. **Acfboy (5星)**  
   - **亮点**：清晰的LCA倍增实现，代码结构模块化。  
   - **代码片段**：  
     ```cpp
     void dfs(int u, int par) {
         fa[u][0] = par, dep[u] = dep[par] + 1;
         for (int i = 1; i < 20; i++) 
             fa[u][i] = fa[fa[u][i-1]][i-1];
         for (int v : g[u]) 
             if (v != par) dfs(v, u);
     }
     ```

2. **Cry_For_theMoon (4星)**  
   - **亮点**：简洁的逆序对枚举逻辑，注释明确。  
   - **心得引用**：“被2300*题罚坐两小时，太丢人了” → 强调思维突破的重要性。

3. **slzx2022YuYihan (4星)**  
   - **亮点**：完整数学推导注释，代码包含详细解题思路。  
   - **关键注释**：  
     ```cpp
     /* 通过预处理DP表，将概率问题转化为路径长度计算 */
     ```

---

### **最优思路提炼**

1. **动态规划预处理**  
   核心公式`f[i][j]`递推，将复杂概率问题简化为二维表查询。

2. **树路径LCA抽象**  
   通过枚举根节点并计算LCA，将树结构转化为独立路径长度问题。

3. **期望线性拆分**  
   利用期望的线性性质，将整体问题拆解为点对贡献求和。

---

### **同类型题目推荐**

1. **CF1187F Expected Square**  
   - 期望线性性拆分与平方期望计算。

2. **Luogu P3179 排列计数**  
   - 树形结构上的排列概率问题。

3. **CF123E Maze**  
   - 树路径选择与期望模型结合。

---

### **可视化设计**

**动画方案**  
- **树形展示**：用Canvas绘制树结构，点击节点触发标记过程。  
- **路径高亮**：选中点对时，显示其到LCA的路径并标注长度i,j。  
- **DP表动态更新**：右侧表格实时显示`f[i][j]`计算过程，当前计算格高亮。  

**复古风格实现**  
```javascript
// 8-bit音效触发（使用Web Audio API）
function playBeep() {
    const osc = audioCtx.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}

// Canvas绘制树节点（像素风格）
function drawNode(x, y) {
    ctx.fillStyle = '#FF69B4';
    ctx.fillRect(x*40, y*40, 32, 32); // 32x32像素块
}
```

**交互设计**  
- **步进控制**：空格键单步执行标记过程，Enter键自动播放。  
- **音效反馈**：节点标记时播放8-bit音效，错误操作触发低音提示。  

---

### **核心代码实现**

```cpp
// 预处理概率DP表
for (int i = 1; i <= n; i++) f[0][i] = 1;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        f[i][j] = (f[i-1][j] + f[i][j-1]) * inv2 % mod;

// 计算每对点贡献
for (int root = 1; root <= n; root++) {
    dfs(root, 0); // 以root为根建树
    for (int u = 1; u <= n; u++)
        for (int v = 1; v < u; v++) {
            int lca = LCA(u, v);
            int du = dep[u] - dep[lca];
            int dv = dep[v] - dep[lca];
            ans = (ans + f[du][dv]) % mod;
        }
}
ans = ans * inv(n) % mod; // 最终期望
```

---

### **个人心得摘录**

- **调试关键**：确保LCA计算正确，曾因倍增表未初始化导致贡献计算错误。  
- **思维突破**：“将树路径抽象为两栈模型”是解题的关键跳跃点。

---
处理用时：94.67秒
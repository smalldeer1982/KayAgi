# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果



---

## 算法分类选择  
**组合数学**

---

## 综合分析与结论  
**核心思路与难点**  
题目要求计算填补空缺的方案数，使得每个居民视角下至少有 `c` 架飞机发射，且总发射数为 `m`。关键观察点：
1. **顶层的特殊性**：第 `n` 层居民只能看到自己发射的飞机，因此必须恰好发射 `c` 架。
2. **组合意义**：剩余 `n-1` 层居民的发射总次数为 `m-c`。每个非顶层居民最多发射 `c` 次，相当于在 `(n-1)*c` 个“候选位置”中选择 `m-c` 个位置，方案数为组合数 `C((n-1)c, m-c)`。

**动态规划与组合解法的对比**  
- **动态规划**：状态 `dp[i][j]` 表示前 `i` 层发射 `j` 架飞机的方案数，通过枚举每层发射次数 `k`（`0 ≤ k ≤ c`）累加方案。时间复杂度 `O(nmc)`，适用于一般情况。
- **组合解法**：直接利用组合数学中的范德蒙德恒等式，将问题转化为从 `(n-1)c` 个位置中选择 `m-c` 个。时间复杂度 `O(1)`，仅适用于所有 `a_i` 缺失的简单版本。

**可视化设计思路**  
1. **像素化动画**：用网格表示 `(n-1)*c` 个候选位置，动态填充选中位置（绿色方块）和未选位置（灰色方块）。
2. **音效与提示**：选中位置时播放短音效，最终答案达成时播放胜利音效。
3. **参数调节面板**：允许用户输入 `n, c, m`，实时计算并展示组合数结果。

---

## 题解清单 (≥4星)  
1. **xyvsvg（5星）**  
   - **亮点**：直接利用组合数学推导，代码简洁高效，预处理阶乘与逆元，复杂度 `O(1)`。
   - **代码片段**：  
     ```cpp
     auto C=[&](int n,int m) { return fac[n]*finv[m]%mod*finv[n-m]%mod; };
     cout<<C(n*c-c,m-c)<<endl;
     ```

2. **2022dyx（4星）**  
   - **亮点**：通过组合意义分析，证明了顶层的特殊性，并结合范德蒙德恒等式简化问题。
   - **代码片段**：  
     ```cpp
     cout << fac[(n - 1) * c] * inv[m - c] % mod * inv[n * c - m] % mod << '\n';
     ```

3. **CReatiQ（4星）**  
   - **亮点**：明确分离组合与 DP 两种解法，对比清晰，代码可读性强。
   - **代码片段**：  
     ```cpp
     dp[i][j] = sum_{k=0}^c C(c,k) * dp[i-1][j-k];
     ```

---

## 最优思路或技巧提炼  
1. **组合转化**：将问题转化为从 `(n-1)c` 个位置中选 `m-c` 个的组合问题，直接使用组合数公式。
2. **预处理优化**：提前计算阶乘与逆元，实现 `O(1)` 查询组合数。
3. **边界处理**：当 `m < c` 或 `m-c > (n-1)c` 时直接返回 0。

---

## 同类型题或类似算法套路  
- **组合计数问题**：如背包问题变种（物品限制选择次数）、多重集合排列（如 CF 的某些计数题）。
- **范德蒙德恒等式应用**：类似问题中，若每个选择独立且总和固定，可尝试转化为组合数乘积求和。

---

## 推荐相似题目  
1. **P3197 [HNOI2008]越狱**（组合计数）  
2. **CF451E Devu and Flowers**（多重集合组合数）  
3. **P4345 [SHOI2015]超能粒子炮·改**（Lucas定理应用）

---

## 可视化与算法演示  
**复古像素动画实现思路**  
1. **Canvas 绘制**：  
   - 初始化 `(n-1)*c` 的网格，每个格子代表一个候选位置。
   - 用户输入 `n, c, m` 后，计算选中格子数 `m-c`，随机高亮选中格子。
2. **音效设计**：  
   - 每选中一个格子播放 `8-bit` 点击音效。
   - 结果正确时播放胜利旋律，错误时播放低沉音效。
3. **参数交互**：  
   - 滑动条调节 `n, c, m`，实时更新动画与计算结果。

---

**示例代码片段（JavaScript）**  
```javascript
// 绘制网格
function drawGrid(n, c, m) {
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const total = (n-1)*c;
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // 绘制选中格子（绿色）
    for (let i = 0; i < m-c; i++) {
        const x = (i % c) * 20;
        const y = Math.floor(i / c) * 20;
        ctx.fillStyle = '#0f0';
        ctx.fillRect(x, y, 18, 18);
    }
}
```

---

## 个人心得摘录  
- **组合转化中的陷阱**：最初误以为动态规划是唯一解法，后通过样例验证组合解法的正确性。
- **预处理的重要性**：阶乘与逆元的预处理极大优化了组合数计算效率。

---

**总结**：本题核心在于组合数学的巧妙转化，结合预处理技术实现高效求解。动态规划解法虽普适，但在特定条件下可被更优的数学方法替代。

---
处理用时：107.05秒
# 题目信息

# Serval and Modulo

## 题目描述

给定一个由 $n$ 个非负整数组成的数组 $a$ 和一个魔法数 $k$（$k \ge 1$ 且为整数）。Serval 构造了另一个长度为 $n$ 的数组 $b$，其中对于所有 $1 \leq i \leq n$，满足 $b_i = a_i \bmod k^{\text{∗}}$。随后，他将 $b$ 打乱了顺序。

现在给定数组 $a$ 和 $b$，请找出一个可能的魔法数 $k$。如果 Serval 欺骗了你且这样的整数不存在，则输出 $-1$。

可以证明，在题目约束下，若这样的 $k$ 存在，则存在一个不超过 $10^9$ 的有效答案。你需要在输出中保证 $k \leq 10^9$。

$^{\text{∗}}$符号 $a_i \bmod k$ 表示 $a_i$ 除以 $k$ 的余数。

## 说明/提示

第一个测试案例中，若 $k \ge 3$，则 $2 = a_3 \bmod k$ 必须出现在数组 $b$ 中，但这会导致矛盾。当 $k = 1$ 时，$[a_1 \bmod k, a_2 \bmod k, a_3 \bmod k, a_4 \bmod k] = [0,0,0,0]$，无法通过打乱顺序得到 $b$。当 $k = 2$ 时，$[a_1 \bmod k, a_2 \bmod k, a_3 \bmod k, a_4 \bmod k] = [1,1,0,1]$，可以打乱为 $b$。因此唯一可能的答案是 $k = 2$。

第二个测试案例中，注意 $b$ 可以通过打乱 $a$ 直接得到。因此所有 $6$ 到 $10^9$ 的整数都是合法答案。

第三个测试案例中，可以证明这样的 $k$ 不存在。Serval 欺骗了你！

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
4
3 5 2 7
0 1 1 1
5
3 1 5 2 4
1 2 3 4 5
6
2 3 4 7 8 9
1 2 3 6 7 8
5
21 22 25 28 20
0 1 2 1 0
6
1 1 2 3 5 8
0 0 1 1 0 0```

### 输出

```
2
31415926
-1
4
-1```

# AI分析结果



## 算法分类
数学（模运算、因数分解）

---

## 题解思路与算法分析

### 核心思路
1. **总和差约束**：若存在合法 k，则必有 ∑a_i - ∑b_i = k × x（x 为自然数）。这意味着 k 必须是总和差 sum 的因数。
2. **特殊情况处理**：
   - 当 a 排序后与 b 完全相同时，k 必须大于所有 a_i（取极大值 1e9）。
   - 当 sum=0 时，若 a 和 b 相同则输出极大值，否则无解。
3. **因数枚举验证**：枚举 sum 的所有因数 k，检查将 a 中每个元素对 k 取模后排序是否等于 b。

### 解决难点
- **因数高效枚举**：通过 O(√sum) 的时间枚举所有因数，确保在 1e10 范围内可行。
- **验证优化**：排序取模后的数组并与 b 比较，时间复杂度 O(n log n)，但实际性能优于哈希统计法。

---

## 题解评分（≥4星）

### 1. ZMQ_Ink6556（★★★★☆）
- **亮点**：代码简洁，直接排序比较，逻辑清晰。预处理排序避免多次哈希计算。
- **代码片段**：
  ```cpp
  bool check(int q) {
      for(int i = 1; i <= n; i++) c[i] = a[i] % q;
      sort(c + 1, c + n + 1);
      return memcmp(b + 1, c + 1, n * sizeof(int)) == 0;
  }
  ```

### 2. WA_csp_noip（★★★★☆）
- **亮点**：详细解释因数枚举合理性，强调因子个数上限的实践可行性。
- **代码片段**：
  ```cpp
  for (int i = 1; 1LL * i * i <= sum; i++) {
      if (sum % i == 0) {
          if (check(i)) { ... }
          if (i * i != sum && check(sum/i)) { ... }
      }
  }
  ```

### 3. ax_by_c（★★★★☆）
- **创新点**：使用哈希随机数指纹加速比较，避免显式排序，但实际仍依赖排序。
- **代码片段**：
  ```cpp
  ull xs = 0;
  for(int i=1;i<=n;i++) xs += f[a[i]%x];
  for(int i=1;i<=n;i++) xs -= f[b[i]];
  return !xs; // 哈希指纹匹配
  ```

---

## 最优思路提炼

### 关键步骤
1. **计算总和差**：sum = ∑a_i - ∑b_i，必须非负且为 k 的倍数。
2. **枚举因数**：从小到大枚举 sum 的所有因数，优先小因数以快速找到最小 k。
3. **排序验证**：对每个候选 k，计算 a_i mod k 后排序与 b 的排序结果比较。

### 思维技巧
- **模运算性质**：利用模运算的减法性质（a_i - b_i ≡ 0 mod k）推导总和约束。
- **因数分解剪枝**：通过枚举因数而非所有可能 k，极大缩小搜索空间。

---

## 类似题目推荐
1. **P1463 [POI2001] 反素数**（因数分解与枚举）
2. **P2424 约数和**（因数求和与数学推导）
3. **P1306 斐波那契公约数**（模运算与数论性质）

---

## 可视化设计

### 算法演示（Canvas 动画）
1. **像素风格**：使用 16 色调色板，数据块以 8x8 像素方块表示。
2. **关键帧**：
   - **步骤1**：显示 a 和 b 数组排序过程（冒泡排序动画）。
   - **步骤2**：计算 sum 并展示因数分解（因数块从 sum 中分裂飞出）。
   - **步骤3**：对每个因数 k，高亮当前验证的 k 值，显示 a_i mod k 的余数数组生成与排序。
3. **音效**：
   - **正确解**：8-bit 胜利音效（上升音阶）。
   - **错误解**：短促“哔”声。
   - **枚举过程**：每验证一个因数播放点击声。

### 交互功能
- **速度控制**：滑动条调节动画速度（0.5x~4x）。
- **AI 模式**：自动播放，展示最优因数选择路径。
- **关卡模式**：将不同测试用例设为关卡，通关后解锁更高难度（更大 n 和 sum）。

---

## 核心代码实现

### 因数枚举与验证（ZMQ_Ink6556 版）
```cpp
sort(a, a + n);
sort(b, b + n);
if (a == b) cout << 1e9 << endl;
else {
    ll sum = accumulate(a, a + n, 0LL) - accumulate(b, b + n, 0LL);
    for (int i = 1; i*i <= sum; ++i) {
        if (sum % i != 0) continue;
        if (check(i)) { cout << i << endl; return; }
        if (check(sum/i)) { cout << sum/i << endl; return; }
    }
    cout << -1 << endl;
}
```

---

## 个人心得摘录
- **WA_csp_noip**：因子个数上限的认知误区（实际 1e10 的因子数约 2304 个）是优化信心的关键。
- **A_R_O_N_A**：哈希统计法因常数问题不如排序法高效，实践中需优先考虑排序。

---
处理用时：86.13秒
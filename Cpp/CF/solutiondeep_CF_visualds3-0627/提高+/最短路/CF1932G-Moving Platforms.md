# 题目信息

# Moving Platforms

## 题目描述

有一个迷宫，迷宫由 $n$ 个平台组成，所有平台间由 $m$ 条通道相连。

每个平台都在某个高度 $l_i$ 上， $l_i$ 是一个 $0$ 到 $H - 1$ 的整数。对于每一步移动，如果你当前在平台 $i$ 上，你可以选择停留在原地或者移动到另一个平台 $j$ 上。如果要移动到平台 $j$ ，那么它们必须由通道连接，并且它们的高度必须相同，即 $l_i = l_j$。

在每一步移动之后，所有平台的高度都会改变。对于所有 $i$，平台 $i$ 的新高度计算为 $l'_i = (l_i + s_i) \bmod H$。

你的起点是平台 $1$ 。请找到到达平台 $n$ 所需的最少步骤数。

## 样例 #1

### 输入

```
3
3 3 10
1 9 4
2 3 0
1 2
3 2
1 3
2 1 10
1 2
4 6
1 2
8 7 25
22 14 5 3 10 14 11 1
9 5 4 10 7 16 18 18
2 8
6 3
3 5
7 5
2 6
1 4
4 7```

### 输出

```
6
-1
52```

# AI分析结果



---

## 唯一算法分类  
**Dijkstra + 扩展欧几里得**

---

## 综合分析与结论  

### 核心思路  
1. **动态边权建模**：将平台间移动的等待时间转化为动态边权。每个边的权值不是固定的，而是根据当前到达时间通过解同余方程计算得出。  
2. **方程求解**：通过扩展欧几里得算法求解形如 $(s_u - s_v)t \equiv (l_v - l_u) \pmod H$ 的同余方程，得到最小的可行等待时间。  
3. **最短路径算法**：使用优先队列优化的 Dijkstra 算法，保证每次处理当前最短到达时间的平台，逐步更新所有相邻节点的最短时间。

### 解决难点  
- **同余方程的最小解调整**：通过通解公式 $x = x_0 + k \cdot \frac{H}{g}$ 调整解，确保满足 $t \geq \text{当前到达时间}$。  
- **无解处理**：当 $\gcd(s_u - s_v, H) \nmid (l_v - l_u)$ 时，直接跳过该边。  
- **周期计算**：利用 $\frac{H}{g}$ 的周期性快速找到最小可行解。

### 可视化设计  
- **动画流程**：  
  1. **节点处理**：高亮当前优先队列中弹出的节点（如红色方块），展示其相邻边（黄色线条）。  
  2. **方程求解**：在 Canvas 右侧动态显示同余方程和扩展欧几里得的求解步骤。  
  3. **时间更新**：用绿色数字实时更新每个平台的最短到达时间。  
- **复古像素风格**：  
  - **平台表示**：用 8x8 像素方块表示平台，高度变化时方块颜色渐变（如蓝色到紫色）。  
  - **音效设计**：移动成功时播放 8-bit 上升音效，无解时播放低沉音效。  
- **AI自动演示**：点击“自动播放”后，算法自动执行，展示队列弹出、方程求解、时间更新的全过程。

---

## 题解清单 (≥4星)  

1. **紊莫（★★★★☆）**  
   - **亮点**：代码结构清晰，正确处理通解调整逻辑，通过 `exgcd` 快速求解并取模优化。  
   - **关键代码**：  
     ```cpp  
     int g = exgcd((s[f] - s[i] + H) % H, H, x, y);  
     x = x * (l[i] - l[f]) / g;  
     x = (x % t + t) % t;  
     if (d[f] > x) x += ((d[f] - x + t - 1) / t) * t;  
     ```  

2. **Engulf（★★★★☆）**  
   - **亮点**：通过绝对值处理避免符号问题，优化解的调整逻辑。  
   - **关键代码**：  
     ```cpp  
     int aa = std::abs(a), bb = std::abs(b);  
     int p = exgcd(x, y, aa, bb);  
     x *= c / p;  
     x = (x % (H / p) + H / p) % (H / p);  
     ```  

3. **Cure_Wing（★★★★☆）**  
   - **亮点**：直接调用 `std::gcd` 简化代码，通过 `ceil` 快速计算周期调整。  
   - **关键代码**：  
     ```cpp  
     ll k = ceil(1.0 * (dis[u] - w) / t);  
     if (dis[v] > w + k * t + 1)  
         dis[v] = w + k * t + 1;  
     ```  

---

## 最优思路提炼  

1. **动态边权计算**：将移动条件转化为同余方程，用扩展欧几里得算法求最小解。  
2. **周期性调整**：通过 $\frac{H}{\gcd}$ 的周期快速找到不小于当前时间的最小解。  
3. **优先队列优化**：Dijkstra 算法保证每次处理最短时间节点，避免重复计算。  

---

## 类似题目推荐  

1. **P1516 青蛙的约会**：扩展欧几里得解同余方程的经典应用。  
2. **P3403 跳楼机**：结合同余性质与最短路建模。  
3. **P2371 墨墨的等式**：动态边权与最短路的结合。  

---

## 可视化与算法演示  

### 核心算法动画  
- **步骤分解**：  
  1. **初始状态**：平台1为绿色，其他为灰色，显示初始高度。  
  2. **处理节点**：红色高亮当前处理的平台，遍历相邻边（黄色高亮）。  
  3. **方程求解**：右侧面板显示当前边的方程和解算过程（如 exgcd 步骤）。  
  4. **时间更新**：成功更新时目标平台闪烁，显示新的到达时间。  

### 复古效果实现  
- **Canvas 绘制**：  
  ```javascript  
  function drawPlatform(x, y, color) {  
      ctx.fillStyle = color;  
      ctx.fillRect(x * 20, 300 - y * 10, 16, 16);  
  }  
  ```  
- **音效触发**：  
  ```javascript  
  function playSound(success) {  
      const osc = audioContext.createOscillator();  
      osc.frequency.setValueAtTime(success ? 880 : 220, audioContext.currentTime);  
      osc.connect(audioContext.destination);  
      osc.start(); osc.stop(audioContext.currentTime + 0.1);  
  }  
  ```  

---

## 个人心得摘录  

- **紊莫**：注意 `inf` 值需足够大（如 `1e18`），否则会 WA。  
- **是青白呀**：在 `exgcd` 中处理负数时需谨慎，通过取模和符号调整保证正确性。  
- **Vitamin_B**：及时对中间变量取模，避免乘法溢出。  

---

## 核心代码片段  

```cpp  
// 紊莫题解的核心逻辑  
void solve() {  
    ...  
    int g = exgcd((s[f] - s[i] + H) % H, H, x, y);  
    if ((l[i] - l[f]) % g != 0) continue;  
    x = x * (l[i] - l[f]) / g;  
    int t = H / g;  
    x = (x % t + t) % t;  
    if (d[f] > x) x += ((d[f] - x + t - 1) / t) * t;  
    if (d[i] > x + 1) {  
        d[i] = x + 1;  
        q.push({i, d[i]});  
    }  
    ...  
}  
```  

---

通过结合动态边权的最短路算法与数论求解，本题展现了算法与数学的深度结合，其核心思路可推广至类似动态图的最短路径问题。

---
处理用时：103.61秒
# 题目信息

# Call During the Journey

## 题目描述

你所居住的城市由 $n$ 个交叉路口和连接几对交叉路口的 $m$ 条街道组成。您可以在每条街道上向任一方向前进。没有两条街道连接同一对交叉路口，也没有一条街道只连接一个交叉路口。您可以从任何一个交叉路口到达另一个交叉路口，但可能会经过其他一些交叉路口。

每分钟，你可以在路口 $u_i$ 登上一辆公交车，然后行驶 $l_{i1}$ 分钟到达路口 $v_i$ 。相反，您可以在 $l_{i1}$ 分钟内从路口 $v_i$ 到达路口 $u_i$ 。您只能在交叉路口上下车。只有当您正在某交叉路口时，才能在该交叉路口登上公共汽车。

您也可以沿着每条街道步行，这需要 $l_{i2} \gt l_{i1}$ 分钟。

您可以在十字路口停车。

您住在十字路口编号 $1$ 处。今天您在 $0$ 点起床，在路口编号 $n$ 处有一个重要活动安排，您必须在 $t_0$ 点之前到达。你还计划打一个电话，通话时间为 $t_1$ 至 $t_2$ 分钟（ $t_1 \lt t_2 \lt t_0$ ）。

通话期间，您不能乘坐公共汽车，但可以在任何街道上行走、停靠在站点处或待在家里。您可以在 $t_1$ 分钟下车，在 $t_2$ 分钟再次上车。

由于您希望获得充足的睡眠，您开始好奇您可以多晚离开家，以便有时间讲电话，同时还不会在活动中迟到？

## 样例 #1

### 输入

```
7
5 5
100 20 80
1 5 30 100
1 2 20 50
2 3 20 50
3 4 20 50
4 5 20 50
2 1
100 50 60
1 2 55 110
4 4
100 40 60
1 2 30 100
2 4 30 100
1 3 20 50
3 4 20 50
3 3
100 80 90
1 2 1 10
2 3 10 50
1 3 20 21
3 2
58 55 57
2 1 1 3
2 3 3 4
2 1
12 9 10
2 1 6 10
5 5
8 5 6
2 1 1 8
2 3 4 8
4 2 2 4
5 3 3 4
4 5 2 6```

### 输出

```
0
-1
60
80
53
3
2```

# AI分析结果



### 算法分类
最短路

### 题解思路与难点

**核心思路**：逆向处理，将终点作为起点，用类似Dijkstra的方式倒推每个节点的最晚出发时间。对于每条边，根据当前时间是否与通话时间冲突，选择乘车或步行，动态更新相邻节点的最晚出发时间。

**关键步骤**：
1. 初始化终点n的最晚出发时间为t0
2. 用优先队列处理每个节点，按最晚出发时间降序处理
3. 对每条边u→v：
   - 若乘车时间段完全在通话前或后，直接转移乘车时间
   - 否则取步行时间与等待后乘车时间的最大值
4. 最终起点1的最晚出发时间即为答案

**解决难点**：通过倒序处理将时间约束转化为动态松弛条件，避免正向处理复杂的时段分割判断。

### 题解评分（≥4星）
1. Super_Cube（5星）
   - 逆向Dijkstra思路简洁高效，代码实现清晰
   - 优先队列降序处理完美适配最晚出发时间的松弛逻辑
   - 时间复杂度O(m log n)达到最优

### 最优思路提炼
**逆向松弛法**：
1. 将终点时间固定为t0，逆向推导每个节点的最晚可行时间
2. 动态选择交通工具：
   - 乘车时间段与通话无冲突时直接转移
   - 冲突时比较步行耗时和等待后乘车耗时，取较大值
3. 用优先队列维护松弛顺序，确保每次处理当前最晚可行节点

### 同类型题目
- [CF1473E] Minimum Path（分层图最短路）
- [洛谷P1144] 最短路计数（最短路变种）
- [POJ3662] Telephone Lines（二分+最短路）

### 可视化设计
**动画方案**：
1. **节点状态**：红色表示当前处理节点，绿色表示已确定最晚时间，灰色表示未处理
2. **边操作**：高亮当前处理的边，显示时间判断逻辑：
   - 蓝色箭头：乘车转移
   - 黄色箭头：步行/等待转移
3. **优先队列**：右侧面板实时显示队列中的节点及其时间
4. **时间轴**：底部时间轴标注t1、t2、t0，动态显示当前处理的时间段

**复古像素化实现**：
- 节点用8x8像素方块表示，优先队列用像素风格列表渲染
- 边操作时播放FC风格的"哔"声，确定节点时播放"叮"声
- 背景音乐使用8-bit循环音轨

### 核心代码实现
```cpp
int bfs() {
    priority_queue<pair<int, int>> q;
    memset(dis, 0x80, sizeof(dis)); // 初始化为极小值
    q.emplace(dis[n] = t0, n);
    while (!q.empty()) {
        int u = q.top().second; q.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (auto& [v, l1, l2] : edges[u]) {
            int val;
            if (dis[u] - l1 >= t2 || dis[u] <= t1) // 可乘车
                val = dis[u] - l1;
            else // 需步行或等待
                val = max(dis[u] - l2, t1 - l1);
            
            if (dis[v] < val) // 松弛操作
                q.emplace(dis[v] = val, v);
        }
    }
    return max(dis[1], -1);
}
```

---
处理用时：63.76秒
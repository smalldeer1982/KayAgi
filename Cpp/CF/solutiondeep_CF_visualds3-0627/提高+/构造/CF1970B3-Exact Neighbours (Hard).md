# 题目信息

# Exact Neighbours (Hard)

## 题目描述

在最近食死徒对霍格华兹城堡发动了一些袭击之后，凤凰社决定将 $n$ 个成员安置在霍格迈德村。这些房子将坐落在一片风景如画的正方形场地上。每个巫师都有自己的房子，每个房子都属于某个巫师。每栋房子将占据一个正方形的空间。

然而，正如你可能知道的，巫师是非常迷信的。在周末，每个巫师 $i$ 都想参观距离自己房子$a_i$（$0 \leq a_i \leq n$）的房子。

村里的道路是水平和垂直修建的，因此点（$x_i，y_i$）和（$x_j，y_j$）之间的距离在 $n \times n$ 域上是$   |x_{i} - x_{j}| + |y_{i} - y_{j}| $ 。巫师们相互了解和信任，所以当第二个巫师不在时，一个巫师可以去另一个巫师的家。建造的房子将会足够大，所有 $n$ 个巫师都可以同时参观任何房子。

除此之外，每个巫师都必须能看到北边的霍格沃茨城堡和南边的禁林，所以其他巫师的房子不应该挡住视线。就村庄而言，这意味着在 $n \times n$ 域的每一列中，最多可以有一个房子，所以如果第 $i$ 个房子有坐标$（x_i，y_i）$，那么对于所有 $i$ 不等于 $j$ ，都有 $x_i \neq x_j$。

凤凰社还不知道是否有可能以这样的方式放置 $n$ 栋房子，以满足所有 $n$ 位巫师的参观和景观要求，所以他们请求您帮助设计这样的计划。

如果可以有一个正确的位置，其中第 $i$ 个向导的房子离它有 $a_i$ 的距离，而第 $i$ 个巫师的房子是他们列中唯一的房子，输出 $YES$，每个巫师的房子的位置，以及每个巫师周末应该去哪个向导的房子。

如果无法正确放置，则输出 $NO$。

## 样例 #1

### 输入

```
4
0 4 2 4```

### 输出

```
YES
4 4
1 3
2 4
3 1
1 1 1 3```

## 样例 #2

### 输入

```
4
1 3 0 1```

### 输出

```
YES
2 1
4 1
1 1
3 1
3 3 3 1```

# AI分析结果



**唯一算法分类**：构造

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **分类讨论**：根据不同的输入情况（存在0、重复元素、排列）分别处理，构造对应的坐标与配对。
2. **坐标分配策略**：确保每列唯一，通过优先处理特殊情况（如0或重复元素）简化问题，剩余元素按排序或贪心分配。
3. **曼哈顿距离验证**：通过构造特定位置（如对角线、相邻列）直接满足距离条件。

#### **算法要点**
- **存在 a_i=0**：将对应房子放在 (1,1)，自己与自己配对，其余元素按降序排列构造。
- **重复的 a_i**：将两房子放在相邻列，如 (x,1) 和 (x+1,a_i)，使其互相配对。
- **排列情况**：若 n≥3，构造三个特殊点（如 (1,1)、(2,1)、(3,2)），其余元素按排序分配。

#### **解决难点**
- **列唯一性**：通过动态分配 x 坐标（如从大到小使用可用列）避免冲突。
- **距离匹配**：通过固定模板（如对角线）或动态调整 y 坐标确保曼哈顿距离正确。
- **排列处理**：对全排列输入构造互相关联的三角关系（如1→2→3→1）。

---

### **题解评分**
1. **xxgirlxx (4星)**  
   - 亮点：全面覆盖三种情况，代码逻辑清晰；通过交换元素简化后续处理。  
   - 示例代码中通过 `swap` 调整输入顺序，保证特殊元素优先处理。

2. **rizynvu (4星)**  
   - 亮点：利用 `map` 快速处理重复元素，构造坐标时优先处理大值；代码简洁高效。  
   - 关键代码片段：通过动态调整 `w` 分配列坐标，避免冲突。

3. **EXODUS (3星)**  
   - 亮点：详细讨论构造顺序，但代码较复杂；通过旋转和排序简化后续步骤。  
   - 示例代码中通过 `rotate` 和 `sort` 调整处理顺序。

---

### **最优思路或技巧提炼**
1. **交换与重排**：将特殊元素（如0、重复值）交换到输入数组前部，统一处理。
2. **动态列分配**：从大到小分配列坐标（如 `bk--`），确保不重复。
3. **配对构造**：对于重复的 a_i，构造相邻列坐标，使其互相满足距离条件。
4. **排列特判**：对全排列输入，构造三角关系（如1→2→3→1）打破僵局。

---

### **同类型题或类似算法套路**
- **构造型问题**：如「CF1970B1/B2」系列，需分情况设计坐标。
- **曼哈顿距离优化**：如「LeetCode 499. The Maze III」需构造最短路径。

---

### **推荐相似题目**
1. **CF1970B1 (Easy)**：直接对角线构造。
2. **CF1970B2 (Medium)**：处理 a_1=0 的特殊情况。
3. **LeetCode 1559. Detect Cycles in 2D Grid**：构造网格关系。

---

### **可视化与算法演示**
#### **动画方案**
1. **网格绘制**：在 Canvas 中绘制 n×n 网格，初始为空。
2. **颜色标记**：
   - 当前处理元素：红色高亮。
   - 已分配元素：绿色（配对成功）或黄色（未配对）。
3. **动态分配**：
   - **步骤1**：检查输入数组，红色标记第一个0或重复元素。
   - **步骤2**：绘制其坐标，播放“放置”音效。
   - **步骤3**：按排序分配剩余元素，动态显示坐标计算过程。
4. **音效提示**：
   - 成功放置：短促“滴”声。
   - 错误/冲突：低沉“嗡”声。
   - 完成构造：播放胜利音乐。

#### **复古像素风格**
- **8位调色板**：使用红、绿、蓝、黄四种基础色。
- **Canvas 实现**：每个房子为 16×16 像素方块，坐标动态更新。
- **AI 自动模式**：按预设逻辑逐步放置，用户可暂停/加速。

---

### **代码片段（核心逻辑）**
以 **rizynvu 的代码**为例：
```cpp
// 处理重复的 a_i
for (int i = 1; i <= n; i++) {
    if (lst[a[i]]) {
        int &j = lst[a[i]];
        dx[i] = bk--, dx[j] = bk--;
        dy[i] = 1, dy[j] = a[i];
        to[i] = j, to[j] = i;
        lst[a[i]] = 0;
    } else lst[a[i]] = i;
}

// 处理剩余元素
for (int i = 2; i <= n; i++) {
    if (lst[i]) {
        int p = lst[i];
        dx[p] = ++f, dy[p] = 1 + i - (f - 1);
        to[p] = fid;
    }
}
```

---
处理用时：76.42秒
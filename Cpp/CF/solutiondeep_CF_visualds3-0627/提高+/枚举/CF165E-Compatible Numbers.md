# 题目信息

# Compatible Numbers

## 题目描述

Two integers $ x $ and $ y $ are compatible, if the result of their bitwise "AND" equals zero, that is, $ a $ $ & $ $ b=0 $ . For example, numbers $ 90 $ $ (1011010_{2}) $ and $ 36 $ $ (100100_{2}) $ are compatible, as $ 1011010_{2} $ $ & $ $ 100100_{2}=0_{2} $ , and numbers $ 3 $ $ (11_{2}) $ and $ 6 $ $ (110_{2}) $ are not compatible, as $ 11_{2} $ $ & $ $ 110_{2}=10_{2} $ .

You are given an array of integers $ a_{1},a_{2},...,a_{n} $ . Your task is to find the following for each array element: is this element compatible with some other element from the given array? If the answer to this question is positive, then you also should find any suitable element.

## 样例 #1

### 输入

```
2
90 36
```

### 输出

```
36 90```

## 样例 #2

### 输入

```
4
3 6 3 6
```

### 输出

```
-1 -1 -1 -1```

## 样例 #3

### 输入

```
5
10 6 9 8 2
```

### 输出

```
-1 8 2 2 8```

# AI分析结果



## 算法分类  
**高维前缀和（SOS DP）**

---

## 综合分析与结论  
### 核心思路  
题目要求对每个数 $a_i$，找到一个 $a_j$ 满足 $a_i \& a_j = 0$。关键观察是：  
- $a_j$ 必须是 $a_i$ 的补集（二进制取反）的子集。  
- 预处理所有可能的数的子集中是否存在数组元素，通过高维前缀和（SOS DP）或逆序动态规划实现。

### 算法流程  
1. **初始化**：记录数组中每个数对应的子集存在性。  
2. **高维前缀和预处理**：逐位处理，对每个数 $x$，若某位为 1，尝试去掉该位后的数是否已有答案。  
3. **查询**：对每个 $a_i$，取反后查询其子集中是否存在元素，返回结果。

### 可视化设计  
- **像素化展示**：用二进制网格表示每个数的每一位，高亮当前处理的位（如红色方块）。  
- **子集扩展动画**：动态展示从补集逐步去掉 1 位的过程，绿色标记找到的可行子集。  
- **音效提示**：处理每一位时播放“滴”声，找到子集时播放成功音效。  
- **自动模式**：按位逐步执行，展示高维前缀和如何覆盖所有子集可能。

---

## 题解清单（≥4星）  
### 1. __Watcher（5星）  
- **亮点**：代码简洁，高维前缀和模板直接应用，时间复杂度稳定为 $O(M \log M)$。  
- **关键代码**：  
  ```cpp
  for(int i=0;i<=21;i++) {
      for(int j=0;j<(1<<22);j++) {
          if((j&(1<<i))&&f[j^(1<<i)]) f[j]=f[j^(1<<i)];
      }
  }
  ```

### 2. Mooncrying（4.5星）  
- **亮点**：详细解释高维前缀和与子集关系，适合新手理解。  
- **关键句**：*“取反后的任何子集都满足与原数相容”*。  

### 3. 白鲟（4星）  
- **亮点**：代码最短，直接利用高维前缀和实现，注释清晰。  
- **关键代码**：  
  ```cpp
  for(int i=1;i<=maxa;++i)
      for(int j=1;j<=22;++j)
          if(ans[i]!=-1&&(i|(1<<(j-1)))!=i)
              ans[i|(1<<(j-1))]=ans[i];
  ```

---

## 最优思路提炼  
### 核心技巧  
- **补集子集性质**：$a_j$ 必须是 $\sim a_i$ 的子集。  
- **高维前缀和预处理**：通过逐位处理，将子集存在性传递到父集。  
- **位运算优化**：利用位掩码快速取反和判断子集关系。  

### 代码片段  
```cpp
// 高维前缀和预处理
for (int i = 0; i < 22; i++) {
    for (int j = 0; j < (1 << 22); j++) {
        if ((j & (1 << i)) && f[j ^ (1 << i)])
            f[j] = f[j ^ (1 << i)];
    }
}
// 查询答案
int complement = ((1 << 22) - 1) ^ a[i];
printf("%d ", f[complement] ? f[complement] : -1);
```

---

## 同类题目推荐  
1. **CF449D - Jzzhu and Apples**（高维前缀和优化计数）  
2. **LOJ#152 - 子集异或**（子集异或最大值）  
3. **ARC100E - Or Plus Max**（前缀最值处理）  

---

## 个人心得摘录  
- **Prurite**：*“代码中位运算优先级容易出错，不确定的地方加括号”*。  
- **Mooncrying**：*“在草稿纸上画二进制位帮助理解子集关系”*。  

---

## 可视化与算法演示  
### 动画设计  
1. **二进制网格**：每个数用 22x1 的网格表示，0/1 用黑白方块。  
2. **高亮当前位**：处理第 $i$ 位时，所有数的第 $i$ 位变为红色。  
3. **子集扩展**：当某数 $j$ 去掉第 $i$ 位后存在答案，将 $j$ 的网格染为绿色。  

### 复古像素风格  
- **调色板**：8 位风格，红（处理位）、绿（可行子集）、灰（未处理）。  
- **音效**：每处理一位播放“哔”声，找到子集时播放经典马里奥金币音效。  

### 交互控制  
- **步进按钮**：单步执行每一位处理。  
- **自动播放**：以 500ms/步的速度自动展示高维前缀和过程。  

```javascript
// 示例：Canvas绘制二进制网格（伪代码）
function drawNumberBinary(num) {
    for (let i = 0; i < 22; i++) {
        let bit = (num >> i) & 1;
        ctx.fillStyle = bit ? '#FF0000' : '#FFFFFF'; // 当前位红色
        ctx.fillRect(i * 10, 0, 8, 8);
    }
}
```

---
处理用时：98.86秒
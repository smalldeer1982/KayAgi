# 题目信息

# Serval and Colorful Array (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本的区别在于此版本中 $n \leq 3000$。仅当您解决了该问题的所有版本时才能进行 hack。

Serval 有一个魔法数 $k$（$k \geq 2$）。我们称数组 $r$ 为 colorful 当且仅当：
- $r$ 的长度为 $k$，且
- $1$ 到 $k$ 之间的每个整数在 $r$ 中恰好出现一次。

给定一个由 $n$ 个介于 $1$ 到 $k$ 的整数组成的数组 $a$。保证 $1$ 到 $k$ 之间的每个整数在 $a$ 中至少出现一次。您可以对 $a$ 执行以下操作：
- 选择一个下标 $i$（$1 \leq i < n$），然后交换 $a_i$ 和 $a_{i+1}$。

求使得 $a$ 中至少存在一个 colorful 子数组$^{\text{∗}}$所需的最小操作次数。可以证明在题目约束下这总是可行的。

$^{\text{∗}}$数组 $b$ 是数组 $a$ 的子数组，当且仅当 $b$ 可以通过从 $a$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 说明/提示

第一个测试案例中，由于子数组 $[a_1, a_2] = [1, 2]$ 和 $[a_2, a_3] = [2, 1]$ 已经是 colorful 的，因此无需执行任何操作。答案为 $0$。

第二个测试案例中，我们可以交换 $a_1$ 和 $a_2$ 得到 $[1, \underline{2, 1, 3}, 1, 1, 2]$，其中包含一个 colorful 子数组 $[a_2, a_3, a_4] = [2, 1, 3]$。由于原数组初始时没有 colorful 子数组，因此答案为 $1$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
3 2
1 2 1
7 3
2 1 1 3 1 1 2
6 3
1 1 2 2 2 3
6 3
1 2 2 2 2 3
10 5
5 1 3 1 1 2 2 4 1 3
9 4
1 2 3 3 3 3 3 2 4```

### 输出

```
0
1
2
3
4
5```

# AI分析结果



---

**唯一算法分类**  
贪心

---

**综合分析与结论**  

**核心思路**  
本题的关键是寻找一个长度为 k 的排列子数组，并通过最少的相邻交换次数使其连续。核心思路是枚举每个位置作为中心点，计算所有 1~k 的数值到该中心点的最近距离之和的最小值。基于仓库选址问题的中位数性质，直接取每个数值在左右方向上的最近距离最小值（即 `min(l_i, r_i)`），无需强制左右分配，即可保证最优解。

**算法流程与可视化设计**  
1. **枚举中心点**：遍历数组每个位置 pos，作为子数组的中心候选。
2. **计算最近距离**：对每个数值 i，找到其在 pos 左侧最近的 `l_i`（左边第一个出现位置到 pos 的距离）和右侧最近的 `r_i`（右边第一个出现位置到 pos 的距离）。
3. **求和优化**：计算所有 `min(l_i, r_i)` 之和，记录最小值。
4. **动态更新**：利用相邻 pos 的 `min(l_i, r_i)` 变化规律，通过差分优化计算。

**可视化设计要点**  
- **像素风格动画**：用 8 位像素块表示数组元素，中心点 pos 以闪烁的红色方块标记。
- **距离可视化**：每个数值的 `l_i` 和 `r_i` 用绿色（左）和蓝色（右）线条动态显示，`min(l_i, r_i)` 用黄色高亮。
- **音效交互**：每次更新最小值时播放“成功”音效，枚举 pos 时伴随步进音效。
- **自动演示模式**：AI 自动遍历所有 pos，实时显示当前最小值和对应的子数组位置。

---

**题解清单 (≥4星)**  

1. **donaldqian（4星）**  
   - **亮点**：结合左右分配策略，通过排序差值优化选择，思路清晰。
   - **代码**：枚举中心点，动态维护左右最近出现位置。

2. **incra（5星）**  
   - **亮点**：简化思路，利用 `min(l_i, r_i)` 直接求和，时间复杂度优化到 O(n²)。
   - **代码**：直接遍历计算每个 pos 的总和，无需复杂排序。

---

**核心代码实现**  

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t; cin >> t;
    while (t--) {
        int n, k; cin >> n >> k;
        vector<int> a(n);
        for (auto &x : a) cin >> x;

        int ans = INT_MAX;
        // 枚举每个可能的中心点 pos
        for (int pos = 0; pos < n; pos++) {
            vector<int> l(k + 1, -1), r(k + 1, -1);
            // 计算左侧最近出现位置
            for (int i = pos, cnt = 0; i >= 0 && cnt <= k; i--, cnt++) {
                if (l[a[i]] == -1) l[a[i]] = pos - i;
            }
            // 计算右侧最近出现位置
            for (int i = pos, cnt = 0; i < n && cnt <= k; i++, cnt++) {
                if (r[a[i]] == -1) r[a[i]] = i - pos;
            }
            // 检查是否所有数值都有左右最近距离
            bool valid = true;
            int sum = 0;
            for (int i = 1; i <= k; i++) {
                if (l[i] == -1 && r[i] == -1) { valid = false; break; }
                sum += min(l[i] != -1 ? l[i] : INT_MAX, r[i] != -1 ? r[i] : INT_MAX);
            }
            if (valid) ans = min(ans, sum);
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

**最优思路或技巧提炼**  

1. **中位数贪心**：利用仓库选址问题的性质，中心点必然使总距离最小。
2. **动态维护最近位置**：通过左右扫描快速获取每个数值的最近出现位置。
3. **简化条件**：不强制左右分配，直接取 `min(l_i, r_i)` 之和，避免复杂排序。

---

**类似题目推荐**  

1. **洛谷 P1631 合并序列**（贪心+中位数性质）
2. **洛谷 P1031 均分纸牌**（仓库选址问题变种）
3. **洛谷 P2216 理想的正方形**（滑动窗口优化）

---

**复古游戏化动画设计**  

1. **像素渲染**：用 16 色调色板绘制数组，中心点 pos 用红色闪烁方块标记。
2. **距离动态显示**：绿色线条表示 `l_i`，蓝色表示 `r_i`，黄色高亮 `min(l_i, r_i)`。
3. **音效系统**：步进时播放“滴”声，更新最小值时播放 8-bit 胜利音效。
4. **自动演示**：AI 按顺序遍历 pos，每 0.5 秒自动切换，展示当前最优解。

---
处理用时：116.63秒
# 题目信息

# Hanoi Factory

## 题目描述

你肯定听说过著名的游戏汉诺塔吧，但是你知道有一个神奇的工厂专门制造这种游戏塔上的环吗？很久之前，古埃及的裁定者命令“汉诺工厂”（上文提到的工厂）的工人制造一座尽可能高的汉诺塔，而他们没有做好准备去执行这样一个奇怪的命令，所以他们不得不用已经造好的环。
工厂储备有$n$个环，其内径为$a_i$，外径为$b_i$，高度为$h_i$。要求环的放置条件如下：
-    塔的外半径从下至上为非递增序列，即越下面的环外径不能小于上面的环
-    环不能掉下来，即相邻两环上方的环的外径必须大于下面的环的内径
-    塔的高度必须最大

## 说明/提示

Translated by Venus

## 样例 #1

### 输入

```
3
1 5 1
2 6 2
3 7 3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4
1 2 1
1 3 3
4 6 2
5 7 1
```

### 输出

```
4
```

# AI分析结果



### 算法分类
**动态规划优化/贪心（单调栈）**

---

### 题解思路与核心分析
#### 题目核心逻辑
- **排序策略**：将环按外径降序排序，外径相同时按内径降序排序。这保证了后续处理中，外径大的环优先被考虑，且同一外径下内径大的环优先处理。
- **核心约束**：环的放置需满足 `b_i > a_j`（上方环的外径 > 下方环的内径）。

#### 各题解对比
1. **暴力 DP**（O(n²)）  
   - 通过排序后状态转移，但无法处理大规模数据。
   - **解决难点**：无优化，直接枚举所有可能的前驱状态。

2. **堆优化 DP**（O(n log n)）  
   - 用大根堆维护可转移的最大高度。每次弹出不满足 `b_i > a_j` 的堆顶元素。
   - **关键点**：堆顶元素为当前可用的最优解，保证后续处理中无效状态不再被访问。

3. **单调栈贪心**（O(n)）  
   - 维护一个栈，栈中元素按外径降序排列。处理每个环时，弹出栈顶中内径不满足条件的元素，此时栈顶即为可放置的最优基础。
   - **解决难点**：利用排序后的单调性，保证栈中总高度递增，无需维护多个候选。

4. **树状数组优化**（O(n log n)）  
   - 离散化 `a` 和 `b`，用树状数组维护前缀最大高度。
   - **关键点**：快速查询满足 `a_j < b_i` 的最大高度。

#### 最优思路提炼
- **单调栈贪心**：通过排序保证外径单调性，栈维护当前可能的候选序列，每次弹出无效元素后取栈顶的最大高度，实现 O(n) 时间复杂度。
- **核心技巧**：外径降序排序后，内径的单调性处理使得栈中元素的弹出操作不会影响后续决策。

---

### 题解评分（≥4星）
1. **crh1272336175（5星）**  
   - 栈+贪心，O(n) 时间，代码简洁高效。
   - **亮点**：用栈维护候选序列，总高度实时更新。

2. **wwlw（5星）**  
   - 单调栈实现，逻辑清晰，无需离散化。
   - **亮点**：直接利用排序后的单调性，栈中总高度递增。

3. **Aryzec（4星）**  
   - 堆优化 DP，思路清晰，代码可读性强。
   - **亮点**：用堆维护动态规划状态的最大值。

---

### 最优代码实现
#### 栈+贪心（crh1272336175）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+5;
typedef long long ll;
ll n,ans,sum;
struct node { ll a,b,h; } p[M];
stack<int> stk;

bool cmp(node x, node y) {
    if (x.b != y.b) return x.b > y.b; 
    return x.a > y.a;
}

int main() {
    scanf("%lld", &n);
    for (int i=1; i<=n; i++) scanf("%lld%lld%lld", &p[i].a, &p[i].b, &p[i].h);
    sort(p+1, p+1+n, cmp);
    ans = sum = p[1].h;
    stk.push(1);
    for (int i=2; i<=n; i++) {
        while (!stk.empty() && p[stk.top()].a >= p[i].b) {
            sum -= p[stk.top()].h;
            stk.pop();
        }
        sum += p[i].h;
        stk.push(i);
        ans = max(ans, sum);
    }
    printf("%lld", ans);
    return 0;
}
```

---

### 同类型题推荐
1. **P1233 木棍加工**  
   - 排序后贪心，类似外径约束的最长序列。

2. **P1090 合并果子**  
   - 堆优化贪心，维护最优合并顺序。

3. **P1564 膜拜**  
   - 线性扫描与单调性维护。

---

### 可视化与算法演示
#### 核心流程设计
1. **排序动画**：展示环按外径降序排列的过程，高亮当前比较的环。
2. **栈操作动画**：  
   - **弹出**：红色标记被弹出的栈顶元素（内径不满足条件）。
   - **压栈**：绿色标记新入栈的环，显示当前总高度。
3. **总高度更新**：实时显示最大高度变化。

#### 复古像素风格设计
- **颜色方案**：  
  - 外径：蓝色渐变（深蓝→浅蓝表示降序）。  
  - 内径：红色边框，大小随数值变化。  
- **音效**：  
  - 弹出栈顶：短促“哔”声。  
  - 压栈成功：上扬“叮”声。  
  - 更新最大高度：8-bit 胜利音效。  

#### 交互控制
- **步进控制**：支持暂停/继续，手动触发每一步操作。
- **自动演示**：AI 自动运行，速度可调（快/中/慢）。

---

### 总结
本题通过排序与单调性维护，将动态规划优化至线性复杂度。栈解法凭借其高效性成为最优解，核心在于利用排序后的外径与内径特性，结合贪心策略快速决策。

---
处理用时：227.29秒
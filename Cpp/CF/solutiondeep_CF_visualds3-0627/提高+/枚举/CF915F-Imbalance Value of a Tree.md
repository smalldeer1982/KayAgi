# 题目信息

# Imbalance Value of a Tree

## 题目描述

给定一棵树，每个顶点都被写上了一个数，第 $i$ 个顶点写上的数是 $a_i$。定义一个函数 $I(x,y)$ 表示从顶点 $x$ 到 $y$ 的简单路径上 $a_i$ 的最大值和最小值的差。

你要求出 $\sum_{i=1}^{n}\sum_{j=i}^{n}I(i,j)$。

## 样例 #1

### 输入

```
4
2 2 3 1
1 2
1 3
1 4
```

### 输出

```
6
```

# AI分析结果



**唯一算法分类**：并查集（Kruskal 思想辅助）

---

### **综合分析与结论**
#### **核心思路**
1. **问题拆解**：将原式拆分为「所有路径最大值的总和」与「所有路径最小值的总和」之差。
2. **边权转化**：将点权转化为边权：
   - **最大值贡献**：边权为两端点权值的较大值，按升序排序。
   - **最小值贡献**：边权为两端点权值的较小值，按降序排序。
3. **并查集合并**：从小到大（或大到小）依次合并边，每次合并时计算该边对答案的贡献（连通块大小乘积 × 边权）。

#### **核心难点与解决方案**
- **动态维护连通性**：使用并查集高效维护连通块大小，支持快速合并。
- **贡献计算顺序**：通过排序保证当前边的权值是路径中的最大（或最小）值，避免重复计算。
- **时间复杂度控制**：排序复杂度为 $O(n \log n)$，并查集路径压缩优化后接近线性。

#### **可视化设计思路**
1. **并查集合并动画**：用网格表示树节点，不同颜色区分连通块。当前处理的边高亮为红色，合并时显示连通块大小乘积的数值。
2. **像素风格**：使用 8-bit 像素风格，边权值以不同颜色块显示，合并时播放复古音效。
3. **步进控制**：用户可手动点击下一步，观察每条边的合并过程及贡献计算。

---

### **题解清单（≥4星）**
1. **lottle1212（5星）**  
   - **亮点**：代码简洁，利用两次排序分别处理最大/最小值，通过 `init` 函数复用逻辑。
   - **核心代码**：
     ```cpp
     void init(bool op){ // 复用初始化逻辑
         for(i=1;i<=n;i++) f[i]=i,sz[i]=1;
         for(i=1;i<n;i++) e[i].w = op ? min(w[e[i].x],w[e[i].y]) : max(w[e[i].x],w[e[i].y]);
         sort(e+1,e+n,op?cmp1:cmp0);
     }
     ```
2. **Karry5307（4星）**  
   - **亮点**：详细推导转化边权的正确性，代码中通过重载运算符简化排序逻辑。
3. **RainFestival（4星）**  
   - **亮点**：代码结构清晰，通过 `cmp` 函数分离最大/最小值的排序逻辑，注释明确。

---

### **最优思路提炼**
1. **边权转化技巧**：将点权问题转化为边权问题，通过定义边权为端点权值的极值，确保路径极值的正确性。
2. **排序 + 并查集**：排序控制贡献计算顺序，并查集动态维护连通块大小，时间复杂度最优。
3. **代码复用**：通过参数化排序方式和初始化逻辑，减少重复代码。

---

### **类似题目推荐**
1. **P1967 货车运输**：求路径最小边权的最大值，同样需要排序后并查集合并。
2. **P4185 [USACO18JAN]MooTube G**：统计满足边权阈值的路径数，类似贡献计算。
3. **P1197 [JSOI2008] 星球大战**：动态维护连通块，逆向使用并查集。

---

### **核心代码实现**
```cpp
// 计算最大值总和的核心逻辑
long long calc(bool is_max) {
    sort(edges.begin(), edges.end(), [&](Edge a, Edge b) {
        return is_max ? (a.w < b.w) : (a.w > b.w);
    });
    initDSU();
    long long res = 0;
    for (auto &e : edges) {
        int fx = find(e.u), fy = find(e.v);
        if (fx != fy) {
            res += (long long)sz[fx] * sz[fy] * e.w;
            merge(fx, fy);
        }
    }
    return res;
}
// 主函数调用
long long ans = calc(true) - calc(false);
```

---

### **可视化与游戏化设计**
1. **Canvas 动画**：  
   - **网格布局**：节点排列为树形结构，边用线段连接，当前处理边闪烁红色。  
   - **连通块颜色**：不同连通块用不同颜色填充，合并时颜色融合。  
   - **贡献显示**：合并时弹出 `+sz1*sz2*w` 的像素风格文字。  
2. **音效设计**：  
   - **合并成功**：8-bit 短促“滴”声。  
   - **计算完成**：播放经典 FC 过关音效。  
3. **自动演示模式**：  
   - 按排序顺序自动处理每条边，用户可暂停/调整速度。  
   - 右下角显示当前累计贡献值和剩余边数。

**实现片段（JS）**：
```javascript
// 模拟并查集合并动画
function animateStep(edge, isMax) {
    highlightEdge(edge, 'red'); // 高亮当前边
    playSound('click'); // 播放音效
    let fx = find(edge.u), fy = find(edge.v);
    if (fx !== fy) {
        let contribution = sz[fx] * sz[fy] * edge.w;
        showContribution(contribution); // 显示贡献值
        merge(fx, fy);
        updateColor(fx, fy); // 更新颜色
    }
}
```

---
处理用时：74.15秒
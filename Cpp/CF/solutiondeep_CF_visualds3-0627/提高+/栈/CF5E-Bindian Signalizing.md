# 题目信息

# Bindian Signalizing

## 题目描述

**题面大意**

给定一个圆和圆弧上的 $n$ 座山，每座山上有一名看守员，若连接两名看守员的圆弧（注：圆弧有左右两条，任意一条满足即可）两条中没有比（这两个看守员所在的）两座山中任何一座更高的山，则这两名看守人彼此能看到各自的信号。现在给定 $n$ 座山的高度，求能够看到彼此信号的成对看守人的数量

## 样例 #1

### 输入

```
5
1 2 4 5 3
```

### 输出

```
7
```

# AI分析结果



# Bindian Signalizing 题解分析

## 算法分类
单调栈、环拆解

---

## 题解思路与算法要点

### 核心思路
1. **断环成链**：找到最高山，将其作为链的起点，避免环状结构带来的视线绕行问题。
2. **左右边界处理**：通过单调栈为每个山找到左右第一个更高的山（`left[i]`、`right[i]`）。
3. **相同高度统计**：记录每个山到右边界之间与其高度相同的山数量（`count[i]`）。
4. **贡献计算**：每个山的贡献包括左右边界的对数、相同高度的对数，以及特殊情况的去重。

### 解决难点
- **环拆解**：将最高山置于链首，确保其他山的视线不会跨过最高山。
- **高效求边界**：单调栈以 O(n) 时间复杂度处理左右边界。
- **相同高度处理**：通过动态规划的 `count` 数组统计连续相同高度的山。

---

## 最优题解推荐（≥4星）

### 1. Loner_Knowledge（★★★★☆）
- **亮点**：清晰的断环逻辑与单调栈实现，通过 `left/right/count` 数组系统化统计贡献。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;++i) {
      l[i]=i-1; // 向左找第一个更高
      while(l[i]&&h[i]>=h[l[i]]) l[i]=l[l[i]];
  }
  for(int i=n-1;i>=0;--i) {
      r[i]=i+1; // 向右找第一个更高
      while(r[i]<n&&h[i]>h[r[i]]) r[i]=r[r[i]];
      if(h[i]==h[r[i]]) { // 相同高度处理
          cnt[i]=cnt[r[i]]+1;
          r[i]=r[r[i]];
      }
  }
  ```

### 2. zrzring（★★★★☆）
- **亮点**：简洁的单调栈实现，通过栈顶比较直接统计可见对数。
- **关键代码**：
  ```cpp
  while(s[top] < h[i] && top) ans += cnt[top--];
  if(s[top] == h[i]) ans += cnt[top] + (top>1);
  ```

### 3. 李柯欣（★★★★☆）
- **亮点**：特殊处理最高山重复计数，通过后向遍历补充遗漏对。
- **关键逻辑**：
  ```cpp
  for(int i=n;i>1;i--) // 补充最高山另一侧可见对
      if(!pc[i]&&a[i]>=m) ans++;
  ```

---

## 核心算法可视化设计

### 动画演示步骤
1. **环拆解**：将环状山群展开为链，最高山高亮显示。
2. **单调栈操作**：
   - **左边界**：红色箭头向左滑动，遇到更高山时停止。
   - **右边界**：蓝色箭头向右滑动，弹出矮山时黄色高亮。
3. **贡献统计**：绿色标记相同高度的连续山，动态更新计数。

### 复古像素风格设计
- **颜色方案**：山用16色像素块表示，栈操作用8-bit音效（弹出时"哔"声，找到边界时"叮"声）。
- **Canvas动画**：网格绘制山高度，栈操作显示为动态队列，右侧面板显示 `left/right/count` 数值。

---

## 同类型题目推荐
1. **P5788 单调栈模板**  
   （题解：求每个元素右边第一个更大元素）
2. **P1901 发射站**  
   （环形能量传递，单调栈应用）
3. **CF547B 区间最小值**  
   （单调栈处理区间极值贡献）

---

## 个人心得摘录
> "调试时发现当最高山重复时，需要特殊处理左右边界的交叉情况，否则会少算对数。"  
> —— 李柯欣题解中的调试经验

---

## 关键代码实现（Loner_Knowledge 核心逻辑）
```cpp
#include<cstdio>
int t[1000002],h[1000002],l[1000002],r[1000002],cnt[1000002];
int main() {
    int n,p=0;
    long long ans=0;
    scanf("%d",&n);
    for(int i=0;i<n;++i) scanf("%d",t+i);
    for(int i=1;i<n;++i) if(t[i]>t[p]) p=i; // 找最高山
    for(int i=0;i<=n;++i) h[i]=t[(i+p)%n];  // 断环成链
    // 计算left数组（向左找更高）
    for(int i=1;i<=n;++i) {
        l[i]=i-1;
        while(l[i]&&h[i]>=h[l[i]]) l[i]=l[l[i]];
    }
    // 计算right数组和count（向右找更高+统计相同高度）
    for(int i=n-1;i>=0;--i) {
        r[i]=i+1;
        while(r[i]<n&&h[i]>h[r[i]]) r[i]=r[r[i]];
        if(r[i]<n&&h[i]==h[r[i]]) {
            cnt[i]=cnt[r[i]]+1;
            r[i]=r[r[i]];
        }
    }
    // 统计总对数
    for(int i=0;i<n;++i) {
        ans+=cnt[i]; // 相同高度贡献
        if(h[i]<h[0]) { 
            ans+=2;  // 左右边界贡献
            if(!l[i]&&r[i]==n) ans--; // 去重
        }
    }
    printf("%I64d\n",ans);
    return 0;
}
```

---
处理用时：77.80秒
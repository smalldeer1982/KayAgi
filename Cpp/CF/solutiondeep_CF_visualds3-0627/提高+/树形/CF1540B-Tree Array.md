# 题目信息

# Tree Array

## 题目描述

You are given a tree consisting of $ n $ nodes. You generate an array from the tree by marking nodes one by one.

Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree.

After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node.

It can be shown that the process marks all nodes in the tree.

The final array $ a $ is the list of the nodes' labels in order of the time each node was marked.

Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.

The number of inversions in an array $ a $ is the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i > a_j $ . For example, the array $ [4, 1, 3, 2] $ contains $ 4 $ inversions: $ (1, 2) $ , $ (1, 3) $ , $ (1, 4) $ , $ (3, 4) $ .

## 说明/提示

This is the tree from the first sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/3833e6cdc8f432e8774aa8c02d9352118566a812.png)For the first sample, the arrays are almost fixed. If node $ 2 $ is chosen initially, then the only possible array is $ [2, 1, 3] $ ( $ 1 $ inversion). If node $ 3 $ is chosen initially, then the only possible array is $ [3, 1, 2] $ ( $ 2 $ inversions). If node $ 1 $ is chosen initially, the arrays $ [1, 2, 3] $ ( $ 0 $ inversions) and $ [1, 3, 2] $ ( $ 1 $ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $ \frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6} $ .

 $ 166666669 \cdot 6 = 7 \pmod {10^9 + 7} $ , so the answer is $ 166666669 $ .

This is the tree from the second sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/7f613b365926417ec34142a093ccc13b3b572f4f.png)This is the tree from the third sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/4cf8ac5fc765cc7cdc6657a332a13e66dcba8fef.png)

## 样例 #1

### 输入

```
3
1 2
1 3```

### 输出

```
166666669```

## 样例 #2

### 输入

```
6
2 1
2 3
6 1
1 4
2 5```

### 输出

```
500000009```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
2 5```

### 输出

```
500000007```

# AI分析结果



## 算法分类
**期望DP + LCA + 枚举**

---

## 题解思路与解决难点

### 核心思路
1. **期望拆分**：利用期望的线性性，将逆序对的期望拆分为每对节点 $(i,j)$（$i > j$）的贡献，即 $i$ 先于 $j$ 被选中的概率之和。
2. **动态规划预处理**：定义 $f[x][y]$ 表示从 LCA 到 $i$ 和 $j$ 的路径长度分别为 $x$ 和 $y$ 时，$i$ 先被选中的概率。状态转移方程为：
   $$ f[x][y] = \frac{f[x-1][y] + f[x][y-1]}{2} $$
3. **LCA 处理**：对每个根节点预处理父节点和深度数组，快速计算任意两节点的 LCA。
4. **枚举所有根节点**：计算每个根节点下所有节点对的贡献，最终取平均。

### 解决难点
- **模型转化**：将复杂的树形选择过程转化为路径长度的概率模型。
- **LCA 快速计算**：通过倍增法预处理父节点数组，实现 $O(\log n)$ 时间复杂度的 LCA 查询。
- **状态转移方程**：通过观察“等概率选择相邻节点”的性质，推导出关键的状态转移方程。

---

## 题解评分（≥4星）

1. **Acfboy（5星）**  
   - 思路清晰，详细解释了期望拆分和 DP 设计。
   - 代码结构简洁，预处理 LCA 和 DP 数组，枚举逻辑明确。
   - 提供了样例分析，增强理解。

2. **Cry_For_theMoon（4星）**  
   - 代码实现简洁，通过枚举根节点和节点对直接计算贡献。
   - 详细注释了 DP 数组的意义和转移逻辑。

3. **slzx2022YuYihan（4星）**  
   - 使用 DFS 预处理子树信息，优化了 LCA 的计算。
   - 代码包含详细注释，适合新手理解。

---

## 最优思路与技巧提炼

### 关键思路
- **期望线性拆分**：将整体期望拆分为每对节点的贡献，避免全局排列的复杂计算。
- **LCA 路径独立**：从 LCA 到节点的路径选择独立于其他部分，简化概率模型。
- **栈模型转换**：将路径选择过程等价为两个栈的弹出问题，每一步等概率选择。

### 核心代码实现
```cpp
// 预处理 DP 数组
for (int i = 1; i <= n; i++) f[0][i] = 1;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        f[i][j] = (f[i-1][j] + f[i][j-1]) * inv2 % mod;
    }
}

// 计算每对节点的贡献
for (int root = 1; root <= n; root++) {
    dfs(root, 0); // 预处理父节点和深度
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            int lca = LCA(i, j);
            int dx = dep[i] - dep[lca];
            int dy = dep[j] - dep[lca];
            ans = (ans + f[dx][dy]) % mod;
        }
    }
}
ans = ans * inv(n) % mod; // 取平均
```

---

## 类似题目与算法套路

### 类似题目
1. **P4438 [HNOI/AHOI2018] 道路**  
   - 动态规划处理路径选择问题，结合树形结构。
2. **CF908D New Year and Arbitrary Arrangement**  
   - 期望 DP 设计，状态转移与概率拆分。
3. **P3179 [HAOI2015] 树上染色**  
   - 树形 DP 处理节点对贡献的累加。

### 通用套路
- **期望拆分 + DP**：将整体期望拆分为独立事件的贡献，通过预处理概率简化计算。
- **LCA 加速路径处理**：在树形问题中，快速求 LCA 以提取关键路径。

---

## 可视化与算法演示

### 动画设计
1. **树结构展示**：以像素风格绘制树形结构，根节点用红色高亮。
2. **路径标记**：选中节点对 $(i,j)$ 时，显示从 LCA 到两者的路径（蓝色和绿色）。
3. **DP 表格动态更新**：右侧显示 $f[x][y]$ 的表格，当前计算单元格高亮为黄色。
4. **音效提示**：节点选中时播放“点击”音效，贡献累加时播放“金币”音效。

### 复古风格实现
- **Canvas 绘制**：用 16x16 像素块表示节点，路径用不同颜色线段连接。
- **自动演示模式**：按层序遍历节点对，展示 DP 表格的填充过程。
- **音效触发**：使用 Web Audio API 播放 8-bit 音效，增强交互感。

---

## 个人心得摘录
- **Acfboy**：通过拆分问题发现 LCA 的关键作用，将复杂树形问题转化为路径模型。
- **dcmfqw**：调试时发现子树大小计算错误，最终通过重构 DFS 逻辑解决。

---

## 总结
通过动态规划预处理概率模型，结合 LCA 快速处理树形路径，将问题复杂度控制在 $O(n^3)$。核心在于期望的线性拆分和独立路径分析，适合作为树形期望问题的经典案例。

---
处理用时：78.19秒
# 题目信息

# Alice's Adventures in the Rabbit Hole

## 题目描述

爱丽丝在兔子洞的底部！兔子洞可以建模为一棵树 $^{\text{∗}}$  ，在顶点 $1$ 有一个出口，而爱丽丝从某个顶点 $v$ 开始。她想要逃出这个洞，但不幸的是，红心女王下令处决她。

每分钟都会抛一次公平的硬币。如果硬币正面朝上，爱丽丝可以移动到她当前位置的一个相邻顶点，否则，红心女王可以将爱丽丝拉到女王选择的一个相邻顶点。如果爱丽丝最终出现在树的任何非根叶子 $^{\text{†}}$ 上，爱丽丝就输了。

假设他们都以最佳方式移动，计算爱丽丝从每个起始顶点 $1\le v\le n$ 成功逃脱的概率。由于这些概率可能非常小，因此输出它们对 $998\,244\,353$ 的取模。

形式上，设 $M = 998\,244\,353$ 。可以证明，确切的答案可以表示为一个不可约分的分数 $\frac{p}{q}$ ，其中 $p$ 和 $q$ 是整数且 $q \not \equiv 0 \pmod{M}$。输出等于 $p \cdot q^{-1} \bmod M$ 的整数。换句话说，输出这样一个整数 $x$，使得 $0 \le x < M$ 和 $x \cdot q \equiv p \pmod{M}$ 

---
$^{\text{∗}}$
 一棵树是一个连通的简单图，具有 $n$ 个顶点和 $n-1$ 条边。

$^{\text{†}} $
 一个叶子是一个仅与一条边相连的顶点。

## 说明/提示

对于第一个测试用例：

1.根据定义，爱丽丝从根节点（顶点 $1$）逃脱的概率为 $1$。\
2.爱丽丝从顶点 $4$ 和 $5$ 立即输掉，因为它们是叶子。\
3.从另外两个顶点，爱丽丝以概率 $\frac 12$ 逃脱，因为女王会将她拉到叶子。

## 样例 #1

### 输入

```
2
5
1 2
1 3
2 4
3 5
9
1 2
2 3
4 5
5 6
7 8
8 9
2 4
5 7```

### 输出

```
1 499122177 499122177 0 0 
1 499122177 0 332748118 166374059 0 443664157 720954255 0```

# AI分析结果



**唯一算法分类**：树形动态规划（Tree DP）

---

### **综合分析与结论**

**核心思路**：  
爱丽丝和女王的移动策略可转化为对每个节点的最优方向选择。爱丽丝必向上（父节点），女王必向下（最近叶子方向）。通过预处理每个节点的最短路径子树，建立递推式，结合模逆元计算概率。

**算法流程**：  
1. **预处理最短路径**：DFS遍历，记录每个节点到最近叶子的距离及对应子节点。  
2. **概率递推**：利用动态规划，每个节点的概率由父节点和危险子节点概率的线性组合，转化为树形结构的自顶向下递推。  
3. **模逆元处理**：预先计算逆元，避免重复计算，优化时间复杂度。

**解决难点**：  
- **循环依赖**：通过数学推导（如无穷级数求和或待定系数法）将概率表达式转化为线性形式。  
- **最优策略确定**：预处理每个节点的危险子节点，确保女王选择最不利路径。  

---

### **题解评分 (≥4星)**

1. **spdarkle (5星)**  
   - **亮点**：引入待定系数法，将递推式转化为线性方程，简化树形DP实现。代码简洁高效。  
2. **mango2011 (4星)**  
   - **亮点**：通过无穷级数直接求和，直观展示概率推导过程，数学逻辑清晰。  
3. **729hao (4星)**  
   - **亮点**：短链剖分思想，将树分解为链结构，利用链式递推规律，降低实现复杂度。  

---

### **最优思路或技巧提炼**

- **待定系数法**：假设概率为线性组合，消去循环依赖，转化为树形DP。  
- **短链剖分**：预处理每个节点的最短路径子树，简化递推关系。  
- **逆元预处理**：预先计算所有可能分母的逆元，优化模运算效率。  

---

### **同类型题推荐**

1. **CF917D Stranger Trees**（树形DP与组合数学结合）  
2. **Luogu P1352 没有上司的舞会**（经典树形DP决策问题）  
3. **Luogu P1273 有线电视网**（树形DP与背包问题结合）  

---

### **可视化与算法演示**

**动画方案**：  
1. **树结构展示**：用Canvas绘制树形结构，高亮当前节点及其父节点/危险子节点。  
2. **概率计算步骤**：步进显示递推过程，当前节点颜色渐变（如红→绿）表示概率从低到高。  
3. **音效提示**：移动时播放轻微音效，概率更新时播放短促提示音。  

**复古像素风格**：  
- **颜色方案**：16色调色板，根节点为黄色，叶子为红色，路径用蓝色渐变。  
- **自动演示**：模拟“贪吃蛇”式路径展开，危险子节点路径闪烁提示。  

---

### **代码实现（关键逻辑）**

**预处理最短路径子树**  
```cpp
void dfs(int u, int fa) {
    int min_depth = INF;
    for (int v : tree[u]) {
        if (v == fa) continue;
        dfs(v, u);
        if (depth[v] < min_depth) {
            min_depth = depth[v];
            next[u] = v; // 危险子节点
        }
    }
    depth[u] = min_depth + 1;
    if (is_leaf(u)) depth[u] = 0;
}
```

**动态规划递推概率**  
```cpp
void calc_prob(int u, int fa) {
    if (u == 1) prob[u] = 1;
    else {
        int k = depth[u]; // 到叶子的距离
        prob[u] = prob[fa] * k % MOD * inv[k + 1] % MOD;
    }
    for (int v : tree[u]) {
        if (v == fa) continue;
        calc_prob(v, u);
    }
}
```

**逆元预处理**  
```cpp
inv[1] = 1;
for (int i = 2; i <= MAXN; ++i) {
    inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
}
```

---

### **个人心得摘录**

- **调试教训**：未正确处理叶子节点导致初始条件错误，需显式标记叶子。  
- **优化技巧**：预处理逆元可减少快速幂调用，提升运行效率。  

---

**总结**：通过树形DP与数学推导结合，将复杂博弈问题转化为递推式，结合预处理优化，高效求解概率问题。

---
处理用时：69.78秒
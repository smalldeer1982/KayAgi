# 题目信息

# Control of Randomness

## 题目描述

给定一棵树，树上有 $ n $ 个顶点。

我们在某个顶点 $ v \ne 1 $ 放置一个机器人，最初拥有 $ p $ 枚硬币。以下是机器人的移动规则：

- 当 $ i $ 为奇数时，机器人会向顶点 $ 1 $ 的方向移动到相邻的节点。
- 当 $ i $ 为偶数时，如果你愿意支付一枚硬币并且还有剩余的硬币，则机器人会向顶点 $ 1 $ 的方向移动到相邻的节点；否则，机器人将随机选择一个相邻的节点移动。

当机器人到达顶点 $ 1 $ 时，过程终止。记 $ f(v, p) $ 为通过最佳策略使用硬币时，使得上述过程的期望步数最小值。

你的任务是解决 $ q $ 个查询。每个查询包含一对 $(v_i, p_i)$，你需要计算 $ f(v_i, p_i) $ 模 $ 998\,244\,353 $ 的值。

具体来说，令 $ M = 998\,244\,353 $。结果可以表示为一个不可约分数 $ \frac{p}{q} $，其中 $ p $ 和 $ q $ 是整数且 $ q \not\equiv 0 \pmod{M} $。你需要输出 $ p \cdot q^{-1} \bmod M $。换句话说，输出满足 $ 0 \le x < M $ 且 $ x \cdot q \equiv p \pmod{M} $ 的整数 $ x $。

## 说明/提示

在第一个测试用例中，树的结构如下：

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040E/6e37a094615504d3867ace023f49408cee6e1144.png)

第一个查询中，期望值为 $ 1 $，因为机器人从顶点 $ 2 $ 出发，一步就到达了顶点 $ 1 $，过程结束。

第二个查询中的期望步数计算如下（$ x $ 为步数）：

- $ P(x < 2) = 0 $，因为距离顶点 $ 1 $ 是 $ 2 $，机器人无法在更少的步数内到达。
- $ P(x = 2) = \frac{1}{3} $，因为只有一种步骤序列使 $ x = 2 $。即 $ 3 \rightarrow_{1} 2 \rightarrow_{0.33} 1 $，概率为 $ 1 \cdot \frac{1}{3} $。
- $ P(x \bmod 2 = 1) = 0 $，因为机器人只能通过偶数步数到达顶点 $ 1 $。
- $ P(x = 4) = \frac{2}{9} $：可能路径为 $ 3 \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.33} 1 $。
- $ P(x = 6) = \frac{4}{27} $：可能路径为 $ 3 \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.33} 1 $。
- 一般情况下，$ P(x = i \cdot 2) = \frac{2^{i - 1}}{3^i} $。

因此，$ f(v, p) = \sum_{i=1}^{\infty}{i \cdot 2 \cdot \frac{2^{i - 1}}{3^i}} = 6 $。

第二个测试用例中，树的结构如下：

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040E/817926230fce12f251ecac195b4fa36da450f14f.png)


 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
4 4
1 2
2 3
2 4
2 0
3 0
4 0
3 1
12 10
1 2
2 3
2 4
1 5
5 6
6 7
6 8
6 9
8 10
10 11
10 12
6 0
9 0
10 0
11 0
3 1
7 1
10 1
12 1
12 2
11 12```

### 输出

```
1
6
6
2
4
9
8
15
2
3
6
9
5
5```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路与算法要点**

#### **核心思路**
1. **两步分组分析**：将奇偶两步视为一组操作。奇数步必须走向父节点，偶数步可选择支付硬币或随机移动。  
2. **路径度数贡献**：每组操作后的期望步数与父节点度数有关。若父节点度数为 $d$，不支付硬币时，期望步数为 $2d$；支付硬币后，步数固定为 $2$。  
3. **贪心替换**：选择路径上度数最大的 $p$ 个节点，用硬币将其贡献从 $2d$ 降为 $2$，从而最小化总期望。

#### **解决难点**
- **数学推导**：通过概率期望分析，发现贡献与父节点度数成线性关系，而非递归计算。  
- **路径处理**：需沿节点到根的路径收集所有父节点度数，排序后替换前 $p$ 大值。  
- **终止条件**：若某节点的父节点是根节点，需单独处理最后一步的步数。

---

### **题解评分 (≥4星)**

1. **Iniaugoty (⭐⭐⭐⭐⭐)**  
   - **亮点**：通过动态规划推导出数学结论，直接转化为贪心策略，时间复杂度 $O(nq)$。  
   - **代码简练**：预处理路径后排序替换，无需复杂数据结构。  
   - **推导关键**：发现 $dp_{u,1} = dp_{fa_{fa_u},1} + 2d_{fa_u}$，极大简化计算。

2. **Register_flicker (⭐⭐⭐⭐)**  
   - **亮点**：直观分组分析，代码清晰易实现。  
   - **优化空间**：排序路径度数后替换前 $p$ 大值，时间复杂度 $O(nq \log n)$。

3. **wfc284 (⭐⭐⭐⭐)**  
   - **亮点**：通过概率方程推导期望，结论与贪心策略一致。  
   - **代码简洁**：与首篇思路相同，但注释更详细。

---

### **最优思路提炼**
- **数学推导**：通过期望分析得出每组操作的贡献仅与父节点度数有关。  
- **贪心选择**：替换路径上度数最大的节点以最小化总步数。  
- **路径处理**：DFS遍历树，沿路径收集度数并排序。

---

### **同类型题与算法套路**
- **贪心+树路径处理**：如[CF1396C Monster Invaders](https://codeforces.com/problemset/problem/1396/C)。  
- **期望与动态规划结合**：如[洛谷 P6835 概率充电](https://www.luogu.com.cn/problem/P6835)。  
- **树链分析**：如[洛谷 P3384 树链剖分](https://www.luogu.com.cn/problem/P3384)。

---

### **推荐题目**
1. **CF1396C**：贪心选择武器攻击顺序。  
2. **洛谷 P6835**：概率与树结构结合。  
3. **洛谷 P3177**：树上路径贡献统计。

---

### **个人心得摘录**
- **Iniaugoty**：  
  > “第一次见这种消掉后效性用推式子而不是改状态的题。”  
  **总结**：通过数学推导而非状态设计避免后效性，是本题关键突破点。

---

### **可视化与算法演示**
#### **核心流程**
1. **树结构绘制**：以根节点为顶点，子节点向下展开，用连线表示父子关系。  
2. **路径高亮**：从查询节点到根的路径用红色标记，度数显示在节点旁。  
3. **贪心替换动画**：  
   - **颜色标记**：度数大的节点显示为橙色，替换后变为绿色。  
   - **步进演示**：每次替换一个最大度数节点，总步数实时更新。  
   - **音效提示**：替换时播放“叮”声，总步数更新时播放上扬音效。

#### **复古像素风格**
- **Canvas 实现**：  
  - 节点用 16x16 像素方块表示，根节点为金色，其他节点按度数深浅渐变。  
  - 路径用红色像素点连接，替换操作时目标节点闪烁。  
- **音效设计**：  
  - 移动时播放 8-bit 脚步声，替换时触发“硬币”音效。  
- **自动演示**：  
  - AI 自动选择最大度数节点替换，动态显示路径和总步数。

```javascript
// 示例：Canvas 绘制节点（伪代码）
function drawNode(x, y, d, isReplaced) {
  ctx.fillStyle = isReplaced ? '#00FF00' : (d > 3 ? '#FFA500' : '#FFFFFF');
  ctx.fillRect(x, y, 16, 16);
  ctx.fillStyle = '#000000';
  ctx.fillText(d, x + 4, y + 12);
}
```

---

### **代码实现**
#### **核心代码（Iniaugoty 思路）**
```cpp
void dfs(int u, int f) {
    fa[u] = f;
    for (int v : tree[u]) {
        if (v != f) dfs(v, u);
    }
}

int query(int v, int p) {
    vector<int> degs;
    while (v != 1) {
        int father = fa[v];
        if (father == 1) break;
        degs.push_back(tree[father].size());
        v = fa[father];
    }
    sort(degs.rbegin(), degs.rend());
    int ans = (v != 1) ? 1 : 0; // 处理最后一步
    for (int i = 0; i < degs.size(); ++i) {
        if (i < p) ans += 2;
        else ans += 2 * degs[i];
    }
    return ans % MOD;
}
```

#### **说明**
- **树遍历**：DFS预处理父节点关系。  
- **路径收集**：沿查询节点到根收集所有父节点度数。  
- **贪心替换**：排序后取前 $p$ 大度数替换为 $2$，其余按原贡献计算。

---
处理用时：76.84秒
# 题目信息

# Level Up

## 题目描述

Monocarp正在玩一款电脑游戏。他从等级 $ 1 $ 开始。他将依次与 $ n $ 只怪物战斗，这些怪物的等级从 $ 1 $ 到 $ n $ 不等。

对于按顺序给出的每个怪物，Monocarp的遭遇如下：

- 如果Monocarp的等级高于怪物的等级，则怪物会逃跑；
- 否则，Monocarp会与怪物战斗。

在每与第 $ k $ 个怪物战斗（逃跑的怪物不计算在内）后，Monocarp的等级会增加 $ 1 $ 。因此，他在与 $ k $ 个怪物战斗后等级变为 $ 2 $ ，在与 $ 2k $ 个怪物战斗后等级变为 $ 3 $ ，以此类推。

你需要处理 $ q $ 个查询，每个查询的格式如下：

- $ i~x $ ：如果参数 $ k $ 等于 $ x $ ，Monocarp是否会与第 $ i $ 个怪物战斗？

## 样例 #1

### 输入

```
4 16
2 1 2 1
1 1
2 1
3 1
4 1
1 2
2 2
3 2
4 2
1 3
2 3
3 3
4 3
1 4
2 4
3 4
4 4```

### 输出

```
YES
NO
YES
NO
YES
YES
YES
NO
YES
YES
YES
NO
YES
YES
YES
YES```

## 样例 #2

### 输入

```
7 15
1 1 2 1 1 1 1
5 3
2 2
2 2
1 6
5 1
5 5
7 7
3 5
7 4
4 3
2 5
1 2
5 6
4 1
6 1```

### 输出

```
NO
YES
YES
YES
NO
YES
YES
YES
NO
NO
YES
YES
YES
NO
NO```

# AI分析结果



# 算法分类  
**二分答案与树状数组优化**

---

## 综合分析与结论  
### 核心思路与难点  
本题核心在于快速判断当参数为k时，怪物是否会被击败。所有题解均围绕**预处理每个怪物的k阈值**展开：  
1. **树状数组+二分**：预处理每个怪物i的临界值c_i，当k≥c_i时必被击败。通过树状数组维护前缀战斗次数，二分查找满足a_i*k≤前序战斗次数的最大k。  
2. **根号分治**：对k≤√n暴力模拟，对k>√n利用等级上限低的特性，用前缀和快速计算段内有效战斗次数。  
3. **整体二分**：离线处理所有怪物的最小k阈值，利用单调性将问题转化为二维偏序问题，通过计数排序思想优化。  

### 可视化设计要点  
**动画流程**（以树状数组解法为例）：  
1. **树状数组更新**：用绿色高亮当前处理的怪物位置，红色方块表示树状数组的节点更新。  
2. **二分过程**：展示mid值动态调整，右侧显示当前判断条件`a_i*mid ≤ query(mid)`的真伪。  
3. **阈值标记**：最终确定的c_i值用金色边框标注，与后续查询的k值比较时触发闪光特效。  

**复古像素风格**：  
- 怪物等级用8-bit数字块表示，树状数组节点显示为蓝色芯片，战斗次数用黄色能量条填充。  
- 音效：树状数组更新时播放"beep"，二分命中时播放"coin"，查询命中时播放"power-up"。  

---

## 题解清单（≥4星）  
### 1. Redshift_Shine（5星）  
**亮点**：  
- 树状数组+二分确定每个怪物的阈值c_i，查询时直接比较k与c_i  
- 二进制位优化将时间复杂度降至O(n log max(a))  
- 输入优化大幅提升实际运行效率  

**代码片段**：  
```cpp  
for(int j=17; ~j; j--) { // 二进制位优化
    if(1ll*a[i]*(l|(1<<j)) <= cur + tr[l|(1<<j)])
        l |= (1<<j), cur += tr[l];
}
update(l+1, 1); // 树状数组更新
```

### 2. Lavaloon（5星）  
**亮点**：  
- 整体二分离线处理所有怪物的最小k阈值  
- 利用战斗次数的单调性，避免复杂数据结构  
- 代码简洁高效，时间复杂度O(n log n)  

**核心逻辑**：  
```cpp  
void Solve(int L,int R,vector<Info>vec) {
    if(L == R) { for(auto _:vec) inter[_.id]=L; return; }
    int mid = (L+R)/2;
    vector<Info> acc, ref; // 应战/不应战分组
    for(auto _:vec) {
        int lv = 1 + (_.pre + acc.size())/mid;
        (lv > a[i] ? ref : acc).push_back(_);
    }
    Solve(L,mid,acc); Solve(mid+1,R,ref);
}
```

### 3. Z1qqurat（4星）  
**亮点**：  
- 树状数组倍增优化二分过程  
- 离线处理查询，按k值排序后指针跳跃  
- 时间复杂度O(n log n)，空间复杂度O(n)  

---

## 最优思路提炼  
**关键技巧**：  
1. **阈值预处理**：为每个怪物计算临界k值，将在线查询转化为O(1)比较。  
2. **二进制位优化**：通过位运算快速逼近最大可行k值，避免传统二分的log因子。  
3. **整体二分框架**：利用战斗次数的单调性，离线批量处理所有怪物的临界值。  

---

## 同类型题目推荐  
1. **CF817F MEX Queries**（区间覆盖与二分查找）  
2. **洛谷P1972 [SDOI2009]HH的项链**（离线查询与树状数组）  
3. **CF703D Mishka and Interesting sum**（前缀异或与哈希优化）  

---

## 个人心得摘录  
> **Redshift_Shine**：  
> "赛时我把查询排序了导致多用了几十毫秒，虽然还是快的一批。但，你不会认为已经结束了吧？"  
> → 强调输入输出优化对常数的影响，即使算法正确也要注意实现细节  

> **Lavaloon**：  
> "整体二分的核心在于维护pre变量，记录已确定小于L的应战次数"  
> → 揭示了离线算法中状态传递的关键  

---

## 可视化算法演示  
**核心动画逻辑**（树状数组解法）：  
1. **初始化**：  
   - 所有怪物显示为灰色方块，内部数字表示等级  
   - 右侧树状数组显示为蓝色节点，初始全为0  

2. **处理怪物i**：  
   - 怪物i闪烁黄色边框，显示当前计算c_i  
   - 二进制位j从17到0循环：  
     - 尝试设置第j位，计算`l|(1<<j)`  
     - 显示树状数组查询范围，红色高亮相关节点  
     - 判断条件成立则保留该位，否则跳过  

3. **更新树状数组**：  
   - 在l+1位置插入1，树状数组对应节点绿色闪烁  
   - 怪物i的c_i显示为金色数字，悬浮显示公式推导  

**交互功能**：  
- 速度调节：滑块控制二进制位处理速度（1x-10x）  
- 模式切换：对比传统二分与二进制优化的步骤差异  
- 音效开关：启用/禁用战斗音效与升级音效  

---

## 代码实现（关键部分）  
**树状数组二进制优化核心**：  
```cpp  
for(int i=1; i<=n; i++) {
    int l = 0, cur = 0;
    for(int j=17; j>=0; j--) {
        int tmp = l | (1<<j);
        if(tmp > n) continue;
        if(1ll*a[i]*tmp <= cur + tr[tmp]) {
            l = tmp;
            cur += tr[l];
        }
    }
    req[i] = l + 1;
    update(req[i], 1);
}
```

---
处理用时：81.79秒
# 题目信息

# Alice's Adventures in the Rabbit Hole

## 题目描述

爱丽丝在兔子洞的底部！兔子洞可以建模为一棵树 $^{\text{∗}}$  ，在顶点 $1$ 有一个出口，而爱丽丝从某个顶点 $v$ 开始。她想要逃出这个洞，但不幸的是，红心女王下令处决她。

每分钟都会抛一次公平的硬币。如果硬币正面朝上，爱丽丝可以移动到她当前位置的一个相邻顶点，否则，红心女王可以将爱丽丝拉到女王选择的一个相邻顶点。如果爱丽丝最终出现在树的任何非根叶子 $^{\text{†}}$ 上，爱丽丝就输了。

假设他们都以最佳方式移动，计算爱丽丝从每个起始顶点 $1\le v\le n$ 成功逃脱的概率。由于这些概率可能非常小，因此输出它们对 $998\,244\,353$ 的取模。

形式上，设 $M = 998\,244\,353$ 。可以证明，确切的答案可以表示为一个不可约分的分数 $\frac{p}{q}$ ，其中 $p$ 和 $q$ 是整数且 $q \not \equiv 0 \pmod{M}$。输出等于 $p \cdot q^{-1} \bmod M$ 的整数。换句话说，输出这样一个整数 $x$，使得 $0 \le x < M$ 和 $x \cdot q \equiv p \pmod{M}$ 

---
$^{\text{∗}}$
 一棵树是一个连通的简单图，具有 $n$ 个顶点和 $n-1$ 条边。

$^{\text{†}} $
 一个叶子是一个仅与一条边相连的顶点。

## 说明/提示

对于第一个测试用例：

1.根据定义，爱丽丝从根节点（顶点 $1$）逃脱的概率为 $1$。\
2.爱丽丝从顶点 $4$ 和 $5$ 立即输掉，因为它们是叶子。\
3.从另外两个顶点，爱丽丝以概率 $\frac 12$ 逃脱，因为女王会将她拉到叶子。

## 样例 #1

### 输入

```
2
5
1 2
1 3
2 4
3 5
9
1 2
2 3
4 5
5 6
7 8
8 9
2 4
5 7```

### 输出

```
1 499122177 499122177 0 0 
1 499122177 0 332748118 166374059 0 443664157 720954255 0```

# AI分析结果



**唯一算法分类**：树形动态规划（树形DP）

---

### **题解思路与算法要点**
1. **核心思路**：  
   - Alice的最优策略是向上移动，而女王会将Alice拉到子树内最近的叶子方向。  
   - 每个节点的逃脱概率可分解为父节点和特定子节点的概率的线性组合：  
     $$f_u = \frac{1}{2}(f_{fa} + f_v)$$  
     其中，$v$为子树内最近的叶子方向对应的子节点。  
   - 通过**短链剖分**预处理每个节点的最短路径方向，将树分解为链结构，简化概率计算。

2. **关键步骤**：  
   - **第一次DFS**：预处理每个节点的最短叶子路径方向（`mind[u]`）和对应的子节点（`ss[u]`）。  
   - **第二次DFS**：根据链结构，利用递推公式计算每个节点的概率：  
     $$p_u = p_{fa} \times \frac{d}{d+1}$$  
     其中，$d$为当前节点到链叶子的距离。  

3. **解决难点**：  
   - **循环依赖**：通过参数化假设（如$f_u = k_u f_{fa}$）消去循环依赖，转化为线性递推。  
   - **分数取模**：利用逆元（`fastpow`函数）处理分母的模运算。

---

### **题解评分 (≥4星)**
1. **spdarkle (5星)**  
   - 引入参数化递推式，通过两次DFS高效计算概率，代码简洁且数学推导清晰。  
   - 关键代码段：  
     ```cpp
     void dfs(int u, int fa) {
         // 预处理最短路径方向
     }
     void solve() {
         // 计算逆元和概率传递
     }
     ```

2. **mango2011 (5星)**  
   - 提出短链剖分思想，将问题转化为链上的等差数列概率模型，时间复杂度$O(n)$。  
   - 代码亮点：利用`mind`数组记录最短路径深度，逻辑紧密。  

3. **Hoks (4星)**  
   - 通过链式递推和短链剖分，直观展示概率传递过程，代码注释详细。  
   - 个人心得：“短链剖分也是挺牛的”体现对算法选择的自信。

---

### **最优思路提炼**
- **短链剖分**：预处理每个节点的最短叶子路径，将树分解为链，简化概率计算。  
- **参数化递推**：将概率表示为父节点概率的线性组合（$k_u f_{fa}$），通过后序遍历求解系数。  
- **逆元优化**：预处理逆元数组，快速计算模意义下的分数。

---

### **同类题目推荐**
1. **CF 932D Tree**（树上链查询与更新）  
2. **Luogu P1352 没有上司的舞会**（树形DP基础）  
3. **CF 343D Water Tree**（树链剖分与懒标记）

---

### **可视化与算法演示**
1. **动画设计**：  
   - **树结构绘制**：用Canvas绘制树形结构，根节点在顶部，叶子向下延伸。  
   - **颜色标记**：当前处理节点（红色）、父节点（蓝色）、最短路径子节点（绿色）。  
   - **步进控制**：按DFS顺序逐步处理节点，显示`mind[u]`和概率计算过程。  
   - **公式推导**：在右侧面板动态显示递推公式（如$k_u = \frac{1}{2 - k_v}$）。  

2. **复古风格**：  
   - **8位像素UI**：用16色调色板（如NES风格）渲染树节点和箭头。  
   - **音效**：移动时播放“滴”声，计算完成时播放“叮”声。  
   - **自动演示**：模拟“贪吃蛇AI”路径，自动按DFS顺序处理节点。

---

### **核心代码实现**
```cpp
// 预处理逆元
LL inv[N];
void pre_inv() {
    inv[1] = 1;
    for (int i = 2; i < N; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}

// 第一次DFS：计算最短路径和子节点
void dfs(int u, int fa) {
    mind[u] = INF;
    for (int v : tree[u]) {
        if (v == fa) continue;
        dfs(v, u);
        if (mind[v] + 1 < mind[u]) {
            mind[u] = mind[v] + 1;
            ss[u] = v;
        }
    }
    if (mind[u] == INF) mind[u] = 0; // 叶子节点
}

// 第二次DFS：计算概率
void calc(int u, int fa, LL prob) {
    if (u == 1) p[u] = 1;
    else p[u] = prob * (mind[u] - 1) % mod * inv[mind[u]] % mod;
    for (int v : tree[u]) {
        if (v == fa) continue;
        if (v == ss[u]) calc(v, u, p[u]); // 沿短链传递
        else calc(v, u, p[u] * inv[2] % mod); // 非最短链
    }
}
```

---

### **个人心得**
- **调试教训**：初始未正确处理叶子节点的`mind`值，导致概率计算错误。  
- **优化技巧**：预处理逆元数组大幅提升性能，避免每次计算`fastpow`。

---
处理用时：81.01秒
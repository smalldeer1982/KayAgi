# 题目信息

# Control of Randomness

## 题目描述

给定一棵树，树上有 $ n $ 个顶点。

我们在某个顶点 $ v \ne 1 $ 放置一个机器人，最初拥有 $ p $ 枚硬币。以下是机器人的移动规则：

- 当 $ i $ 为奇数时，机器人会向顶点 $ 1 $ 的方向移动到相邻的节点。
- 当 $ i $ 为偶数时，如果你愿意支付一枚硬币并且还有剩余的硬币，则机器人会向顶点 $ 1 $ 的方向移动到相邻的节点；否则，机器人将随机选择一个相邻的节点移动。

当机器人到达顶点 $ 1 $ 时，过程终止。记 $ f(v, p) $ 为通过最佳策略使用硬币时，使得上述过程的期望步数最小值。

你的任务是解决 $ q $ 个查询。每个查询包含一对 $(v_i, p_i)$，你需要计算 $ f(v_i, p_i) $ 模 $ 998\,244\,353 $ 的值。

具体来说，令 $ M = 998\,244\,353 $。结果可以表示为一个不可约分数 $ \frac{p}{q} $，其中 $ p $ 和 $ q $ 是整数且 $ q \not\equiv 0 \pmod{M} $。你需要输出 $ p \cdot q^{-1} \bmod M $。换句话说，输出满足 $ 0 \le x < M $ 且 $ x \cdot q \equiv p \pmod{M} $ 的整数 $ x $。

## 说明/提示

在第一个测试用例中，树的结构如下：

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040E/6e37a094615504d3867ace023f49408cee6e1144.png)

第一个查询中，期望值为 $ 1 $，因为机器人从顶点 $ 2 $ 出发，一步就到达了顶点 $ 1 $，过程结束。

第二个查询中的期望步数计算如下（$ x $ 为步数）：

- $ P(x < 2) = 0 $，因为距离顶点 $ 1 $ 是 $ 2 $，机器人无法在更少的步数内到达。
- $ P(x = 2) = \frac{1}{3} $，因为只有一种步骤序列使 $ x = 2 $。即 $ 3 \rightarrow_{1} 2 \rightarrow_{0.33} 1 $，概率为 $ 1 \cdot \frac{1}{3} $。
- $ P(x \bmod 2 = 1) = 0 $，因为机器人只能通过偶数步数到达顶点 $ 1 $。
- $ P(x = 4) = \frac{2}{9} $：可能路径为 $ 3 \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.33} 1 $。
- $ P(x = 6) = \frac{4}{27} $：可能路径为 $ 3 \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.33} 1 $。
- 一般情况下，$ P(x = i \cdot 2) = \frac{2^{i - 1}}{3^i} $。

因此，$ f(v, p) = \sum_{i=1}^{\infty}{i \cdot 2 \cdot \frac{2^{i - 1}}{3^i}} = 6 $。

第二个测试用例中，树的结构如下：

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040E/817926230fce12f251ecac195b4fa36da450f14f.png)


 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
4 4
1 2
2 3
2 4
2 0
3 0
4 0
3 1
12 10
1 2
2 3
2 4
1 5
5 6
6 7
6 8
6 9
8 10
10 11
10 12
6 0
9 0
10 0
11 0
3 1
7 1
10 1
12 1
12 2
11 12```

### 输出

```
1
6
6
2
4
9
8
15
2
3
6
9
5
5```

# AI分析结果



## 算法分类
贪心

## 综合分析与结论

### 核心思路
题目要求计算机器人从任意节点v到根节点1的最小期望步数，其中偶数步可使用硬币强制向父节点移动。关键在于将每两步视为一个操作组，通过分析期望步数与父节点度数的关系，发现最优策略是贪心地用硬币替换度数最大的父节点，以减少期望步数。

### 解决难点
1. **期望建模**：偶数步的随机移动引入概率，需计算不同路径的期望步数。
2. **最优策略推导**：通过动态规划或数学推导发现，每个父节点的度数的贡献为2d，使用硬币可将贡献降为2。贪心选择最大的d进行替换。
3. **路径处理**：预处理每个节点到根的路径上的父节点度数，排序后替换前p大的度数。

### 可视化设计
1. **树结构绘制**：以根节点1为中心，用不同颜色标记当前节点及其父链。
2. **操作组动画**：展示两步为一组的移动过程，高亮父节点的度数及是否使用硬币。
3. **贡献计算**：实时显示路径上的度数排序与硬币替换过程，动态更新总期望步数。

## 题解清单（≥4星）

1. **Iniaugoty（★★★★★）**
   - **亮点**：通过动态规划推导出贪心策略，时间复杂度最优。
   - **代码简析**：利用父链度数求和，直接替换前p大的度数，代码简洁高效。

2. **Register_flicker（★★★★）**
   - **亮点**：直观分组处理，代码易读。
   - **核心代码**：
     ```cpp
     void dfs2(long long x) {
         if (x == 1) return;
         if (fa[x] == 1) { ans++; return; }
         ve.push_back(b[fa[x]].size());
         dfs2(fa[fa[x]]);
     }
     ```
   - **思路**：收集路径度数，排序后贪心替换。

3. **lfxxx（★★★★）**
   - **亮点**：数学推导消去动态规划后效性，转化为贪心问题。
   - **关键公式**：\( dp_{u,1} = dp_{fa_{fa_u},1} + 2 \cdot \text{deg}_{fa_u} \)

## 最优思路提炼

### 关键步骤
1. **路径预处理**：从查询节点出发，沿父链收集所有父节点的度数。
2. **贪心替换**：排序度数，用硬币替换前p大的，使其贡献从2d变为2。
3. **特殊处理**：若父节点为1，额外增加1步贡献。

### 实现代码
```cpp
void dfs(int x, int syg) {
    fa[x] = syg;
    for (int y : g[x]) if (y != syg) dfs(y, x);
}

int query(int v, int p) {
    vector<int> degrees;
    int ans = 0;
    while (v != 1) {
        int u = fa[v];
        if (u == 1) { ans++; break; }
        degrees.push_back(g[u].size());
        v = fa[u];
    }
    sort(degrees.rbegin(), degrees.rend());
    for (int i = 0; i < degrees.size(); i++) {
        if (i < p) ans += 2;
        else ans += 2 * degrees[i];
    }
    return ans % MOD;
}
```

## 同类型题推荐
1. **洛谷P1351**：联合权值（树上的度数相关）
2. **洛谷P1040**：加分二叉树（树形最优策略）
3. **洛谷P1272**：重建道路（树形DP）

## 可视化实现

### 动画设计
- **树结构**：Canvas绘制树，当前路径高亮为红色。
- **度数排序**：动态数组展示排序前后的度数，硬币替换时闪烁。
- **贡献计算**：右侧面板实时更新总步数，替换操作伴随音效。

### 复古像素风格
- **8位调色板**：使用16色，树节点以绿色方块表示，路径为黄色。
- **音效**：替换操作播放“金币”音效，成功到达播放胜利音效。
- **自动演示**：按空格键逐步执行，支持速度调节。

## 总结
本题通过分析移动规则中的奇偶步特性，将问题转化为父节点度数的贪心替换，极大简化了复杂的期望计算。核心在于路径处理与排序策略，是树结构与贪心结合的典型问题。

---
处理用时：313.90秒
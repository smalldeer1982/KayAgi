# 题目信息

# Key of Like (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本之间的区别在于，在这个版本中保证 $$$k = 0$$$。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此第一位成员必定用唯一的钥匙打开唯一的锁。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 0
3 2 0
2 5 0
9 104 0```

### 输出

```
1 0 0
500000004 1 500000004
200000004 800000008
869203933 991076635 39374313 496894434 9358446 51822059 979588764 523836809 38844739```

# AI分析结果



---

**唯一算法分类**  
期望DP

---

### **综合分析与结论**

#### **核心思路**  
题目要求计算n名成员轮流尝试开启l把锁时，每位成员的期望成功次数。利用**期望的线性性**，将问题转化为计算每个锁被某成员开启的概率之和。关键在于发现**每次尝试的成功概率与当前剩余锁数成反比**，并通过动态规划维护起始玩家对期望的贡献。

#### **算法流程**  
1. **状态定义**：`f[j][i]` 表示剩余i把锁时，起始玩家为j的情况下，该阶段产生的期望贡献。  
2. **状态转移**：逆序枚举剩余锁数i，计算每个可能的起始玩家j。通过轮次分配计算每个玩家在此阶段的被选次数（delta），累加上一阶段的概率贡献。  
3. **逆元优化**：预计算模意义下的逆元，快速处理概率除法。  
4. **贡献累加**：每个阶段的计算结果累加到最终答案数组ans。

#### **可视化设计**  
- **动画效果**：用网格表示锁的数量变化，每个格子显示当前剩余锁数和起始玩家。轮次分配时高亮当前操作的玩家。  
- **像素风格**：用8位风格显示锁和钥匙图标，每次成功开启时播放“叮”的音效，失败时播放低音提示。  
- **自动演示**：按阶段逐步展示剩余锁数和玩家轮次，动态更新期望值。

---

### **题解评分**  
1. **Unnamed114514 (4星)**  
   - 亮点：利用对称性推导每次成功概率为1/l，逆序DP实现高效状态转移。  
   - 代码清晰，但状态转移逻辑需结合注释理解。  
   - 核心代码片段：  
     ```cpp  
     for(int i=l;i;--i) for(int j=1;j<=n;++j) {  
         for(int k=1;k<=n;++k) {  
             int delta = i / n;  
             if(dis(k,j) <= i%n) ++delta;  
             f[j][i] = (f[j][i] + f[k][i+1] * delta) % mod;  
         }  
         f[j][i] = f[j][i] * inv[i] % mod;  
         ans[j] = (ans[j] + f[j][i]) % mod;  
     }  
     ```  

2. **Halberd_Cease (4星)**  
   - 亮点：通过周期性分析，将轮次转化为均匀概率分布。  
   - 逻辑直观，但未给出完整代码实现细节。  
   - 关键思路：每轮次成功概率均等，维护起始玩家概率转移。  

---

### **最优思路提炼**  
1. **期望线性性**：总期望分解为每个锁的贡献，独立计算后求和。  
2. **轮次对称性**：每次尝试的成功概率仅与当前剩余锁数相关，与历史无关。  
3. **动态规划优化**：逆序处理锁数，避免重复计算，通过轮次分配（delta）简化状态转移。

---

### **类似题目推荐**  
1. **P1291 [SHOI2002] 百事世界杯之旅**（期望递推）  
2. **P4550 收集邮票**（双状态期望DP）  
3. **CF235B Let's Play Osu!**（期望线性性与递推）

---

### **代码核心实现**  
完整代码见原题解，关键逻辑如下：  
```cpp  
// 预处理逆元  
inv[i] = qpow(i, mod-2);  

// 动态规划主循环  
for (int i = l; i >= 1; --i) {  
    for (int j = 1; j <= n; ++j) {  
        for (int k = 1; k <= n; ++k) {  
            // 计算轮次分配次数delta  
            int delta = i / n;  
            if (dis(k, j) <= i % n) delta++;  
            f[j][i] = (f[j][i] + f[k][i+1] * delta) % mod;  
        }  
        f[j][i] = f[j][i] * inv[i] % mod;  
        ans[j] = (ans[j] + f[j][i]) % mod;  
    }  
}  
```  

---

### **可视化演示设计**  
- **Canvas动画**：以网格显示剩余锁数，玩家头像按轮次移动，高亮当前操作。  
- **音效触发**：成功时播放8-bit“胜利”音效，失败时短暂蜂鸣。  
- **参数调节**：允许调整n和l，观察不同规模下的期望变化。

---
处理用时：236.00秒
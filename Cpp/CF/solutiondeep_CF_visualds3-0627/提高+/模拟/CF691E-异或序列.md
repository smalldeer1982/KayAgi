# 题目信息

# 异或序列

## 题目描述

给你 $n,k$，和一个 $n$ 个数的序列 $\{a_i\}_{i=1}^n$。一个序列 $\{x_i\}_{i=1}^k$ 被称作“异或序列”，当且仅当以下两个条件全部满足：

- $\forall i\in[1,k]:x_i\in[1,n]\cap\Z$；
- $\forall i\in[1,k):3\mid\mathrm{popcount}(a_{x_i}\mathbin{\mathrm{xor}} a_{x_{i+1}})$。

求有多少个异或序列，模 $10^9+7$。

**如果 $n=2,k=1,a=[1,1]$，那么答案为 $\red 2$，两个异或序列分别为 $[1],[2]$。**

## 说明/提示

$n\le100,k,a_i\le10^{18}$。

原题表述不够严谨，因此翻译对“异或序列”的定义进行了改动，不影响作答。

## 样例 #1

### 输入

```
5 2
15 1 2 4 8
```

### 输出

```
13
```

## 样例 #2

### 输入

```
5 1
15 1 2 4 8
```

### 输出

```
5
```

# AI分析结果



**唯一算法分类**  
矩阵快速幂优化动态规划

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - **动态规划 (DP) 设计**: 定义 `dp[i][j]` 表示长度为 `i`` 的序列，最后一个数为 `a[j]` 的方案数。转移方程：  
     ```  
     dp[i][j] = sum(dp[i-1][k] * (popcount(a[k] ^ a[j]) % 3 == 0))  
     ```  
   - **矩阵加速**: 将 DP 转移转化为矩阵乘法，构造邻接矩阵 `C`，其中 `C[k][j] = 1` 当且仅当 `popcount(a[k]^a[j])` 是 3 的倍数。通过矩阵快速幂计算 `C^(k-1)`，最终求和所有初始状态（全 1 向量）的乘积。

2. **解决难点**  
   - **转移矩阵构造**: 正确预处理每对元素是否满足转移条件，时间复杂度 `O(n²)`。  
   - **矩阵快速幂优化**: 将 `O(nk)` 的 DP 优化为 `O(n³ logk)`，解决 `k ≤ 1e18` 的规模问题。  
   - **边界处理**: `k=1` 时直接返回 `n`，无需矩阵运算。

---

### **题解评分（≥4星）**

1. **Sharpsmile（5星）**  
   - **亮点**：详细推导 DP 到矩阵的转化，代码清晰，注释明确。  
   - **代码可读性**：结构规范，变量命名合理，使用滚动数组优化内存。

2. **He_Ren（4.5星）**  
   - **亮点**：代码简洁，直接构造转移矩阵后快速幂，适合快速实现。  
   - **优化点**：使用位运算 `lowbit` 快速计算 `popcount`，提高效率。

3. **yanghanyv（4星）**  
   - **亮点**：预处理邻接矩阵时对称性优化，减少重复计算。  
   - **实践性**：处理 `k=1` 的边界条件，代码鲁棒性强。

---

### **最优思路或技巧提炼**

1. **核心技巧**  
   - **矩阵建模**：将相邻条件转化为图的邻接矩阵，矩阵乘法等价于状态转移。  
   - **快速幂优化**：将线性递推转化为对数时间复杂度的矩阵幂运算。

2. **代码优化**  
   - **内置函数加速**：使用 `__builtin_popcountll` 快速计算二进制 1 的个数。  
   - **滚动数组**：减少内存占用，适用于大规模 `n`。

---

### **同类型题或类似算法套路**

- **斐波那契数列快速计算**（矩阵快速幂模板）  
- **路径计数问题**（邻接矩阵幂次表示路径数）  
- **状态机 DP 优化**（如字符串匹配自动机）

---

### **推荐相似题目**

1. [P1939 矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)  
2. [AT_dp_r Walk](https://atcoder.jp/contests/dp/tasks/dp_r)（邻接矩阵快速幂）  
3. [CF621E Wet Shark and Blocks](https://codeforces.com/contest/621/problem/E)（分组矩阵快速幂）

---

### **个人心得摘录**

- **Sharpsmile**: “在每一次过程中，对于相同的 `j`，能够转移到 `j` 上的 `k` 是不变的，因此可以用矩阵加速。”  
- **ZJle**: “写了 7 遍才过，太坐牢了”——强调边界条件的重要性。  
- **daniEl_lElE**: “矩阵快速幂优化 DP 经典题”——突出算法模板性。

---

### **可视化与算法演示**

**动画设计**  
1. **矩阵乘法过程**：  
   - **高亮当前行和列**：红色标记当前计算的 `C[i][k]` 和 `C[k][j]`。  
   - **动态更新结果矩阵**：绿色显示 `C[i][j]` 的累加过程。  

2. **快速幂分解**：  
   - **二进制分解**：显示指数 `k-1` 的二进制位，对应矩阵的平方和乘法步骤。  
   - **步进控制**：允许单步执行观察每一步矩阵变化。

**复古像素风格**  
- **8位网格显示**：矩阵元素以像素块表示，数值变化时播放“哔”声。  
- **音效触发**：成功转移时播放上升音调，错误转移（如条件不满足）播放低沉音效。  

**代码片段（JavaScript 核心逻辑）**  
```javascript
class Matrix {
  constructor(n, init = 0) {
    this.data = Array(n).fill().map(() => Array(n).fill(init));
  }
  multiply(other) {
    let res = new Matrix(this.size);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          res.data[i][j] += this.data[i][k] * other.data[k][j];
          res.data[i][j] %= MOD;
        }
      }
    }
    return res;
  }
}
```

---

### **完整代码示例（Sharpsmile 版本）**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9+7;
const int N = 105;

struct Matrix {
    ll m[N][N];
    Matrix() { memset(m, 0, sizeof(m)); }
    Matrix operator*(const Matrix& b) const {
        Matrix res;
        for (int i = 1; i <= N; i++)
            for (int j = 1; j <= N; j++)
                for (int k = 1; k <= N; k++)
                    res.m[i][j] = (res.m[i][j] + m[i][k] * b.m[k][j]) % MOD;
        return res;
    }
    Matrix pow(ll k) {
        Matrix res, base = *this;
        for (int i = 1; i <= N; i++) res.m[i][i] = 1;
        while (k) {
            if (k & 1) res = res * base;
            base = base * base;
            k >>= 1;
        }
        return res;
    }
};

int main() {
    ll n, k, a[N];
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    
    Matrix mat;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (__builtin_popcountll(a[i] ^ a[j]) % 3 == 0)
                mat.m[i][j] = 1;
    
    Matrix res = mat.pow(k-1);
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            ans = (ans + res.m[i][j]) % MOD;
    cout << ans;
    return 0;
}
```

---
处理用时：85.50秒
# 题目信息

# Propagating tree

## 题目描述

很久以前，有一棵神橡树(oak)，上面有$n$个节点，从$1$~$n$编号，由$n-1$条边相连。它的根是$1$号节点。  

这棵橡树每个点都有一个权值，你需要完成这两种操作：
$1$ $u$ $val$ 表示给$u$节点的权值增加$val$  
$2$ $u$ 表示查询$u$节点的权值   

但是这不是普通的橡树，它是神橡树。  
所以它还有个神奇的性质：当某个节点的权值增加$val$时，它的子节点权值都增加$-val$，它子节点的子节点权值增加$-(-val)$...... 如此一直进行到树的底部。

## 说明/提示

$1\le n,m \le 2\times 10^5$  
$1\le a_i,val \le 1000$  
$1\le u,v \le n$

## 样例 #1

### 输入

```
5 5
1 2 1 1 2
1 2
1 3
2 4
2 5
1 2 3
1 1 2
2 1
2 2
2 4
```

### 输出

```
3
3
0
```

# AI分析结果



# 算法分类  
**DFS**（通过DFS序将树结构转换为线性区间）

---

# 题解思路、算法要点与解决难点  
**核心思路**：  
1. **DFS序转化子树为区间**：通过DFS预处理每个节点的进入时间`L[u]`和离开时间`R[u]`，子树对应区间`[L[u], R[u]]`。  
2. **奇偶性决定加减方向**：根据节点的深度奇偶性，将传播式修改转化为正负交替的区间加减。  
3. **树状数组/线段树维护差分**：利用差分思想高效处理区间修改，查询时结合奇偶性计算最终值。  

**关键难点**：  
1. 如何将树的结构转化为线性区间以便高效处理？  
   - **DFS序**预处理每个节点的子树范围。  
2. 如何应对传播式修改的正负交替？  
   - **奇偶性判断**：修改时根据当前节点深度奇偶性决定加减方向，查询时同理调整符号。  
3. 如何保证时间复杂度？  
   - **树状数组差分**：单次修改和查询复杂度均为`O(log n)`。  

---

# 题解评分  
1. **lzjsy 题解**（5★）  
   - **亮点**：简洁的树状数组差分实现，利用DFS序和奇偶性判断直接处理正负号。  
   - **代码可读性**：结构清晰，逻辑紧凑。  
   - **关键代码**：  
     ```cpp  
     void dfs(int u, int fa) {  
         L[u] = ++cnt;  
         for (int i=head[u]; i!=-1; i=e[i].next) {  
             int v = e[i].v;  
             if (v == fa) continue;  
             dep[v] = dep[u] + 1;  
             dfs(v, u);  
         }  
         R[u] = cnt;  
     }  
     ```  
     ```cpp  
     // 修改操作  
     if (dep[v] & 1) add(L[v], b), add(R[v]+1, -b);  
     else add(L[v], -b), add(R[v]+1, b);  
     // 查询操作  
     int z1 = query(L[v]);  
     if (dep[v] & 1) printf("%d\n", val[v] + z1);  
     else printf("%d\n", val[v] - z1);  
     ```  

2. **SSerxhs 题解**（4.5★）  
   - **亮点**：单树状数组实现，深度奇偶性直接决定符号，代码更简洁。  
   - **代码片段**：  
     ```cpp  
     if (dep[x] & 1) add(dfn[x], dfn[x]+siz[x]-1, val);  
     else add(dfn[x], dfn[x]+siz[x]-1, -val);  
     ```  

3. **cirnovsky 题解**（4★）  
   - **亮点**：双树状数组维护奇偶层，逻辑直观。  
   - **代码片段**：  
     ```cpp  
     Modify(dfn[x], val, fywf[x]); // fywf[x]为奇偶标记  
     printf("%d\n", val[x] + Query(Lp[x], fywf[x]) - Query(Lp[x], fywf[x]^1));  
     ```  

---

# 最优思路或技巧提炼  
1. **DFS序区间映射**：将子树操作转化为线性区间操作。  
2. **奇偶性符号控制**：修改和查询时通过深度奇偶性决定正负号。  
3. **差分树状数组**：高效处理区间修改和单点查询。  

---

# 同类型题或类似算法套路  
- **子树操作转区间**：如[P3384 【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384)。  
- **奇偶性分层处理**：如[CF620E New Year Tree](https://www.luogu.com.cn/problem/CF620E)。  

---

# 推荐相似题目  
1. **P3384**：树链剖分模板，练习DFS序与区间操作。  
2. **CF343D Water Tree**：子树修改与查询，需结合DFS序。  
3. **P3372 【模板】线段树 1**：区间修改与求和的基础练习。  

---

# 可视化与算法演示  
**动画方案设计**：  
1. **DFS序生成**：  
   - 节点按DFS访问顺序依次高亮，显示`L[u]`和`R[u]`区间范围。  
2. **奇偶层颜色区分**：  
   - 奇数层节点用蓝色，偶数层用橙色。  
3. **修改操作演示**：  
   - 点击节点`u`触发修改，红色高亮区间`[L[u], R[u]]`，根据奇偶性显示正负号。  
4. **树状数组更新**：  
   - 差分数组动态变化，用柱状图展示`tr[]`数组的值。  
5. **查询操作**：  
   - 点击节点显示当前值，结合奇偶性计算过程。  

**复古游戏化效果**：  
- **8位像素风格**：节点显示为方块，修改时闪烁，音效为经典“哔”声。  
- **自动演示模式**：AI按DFS顺序遍历树，自动触发修改和查询。  

---

# 个人心得摘录  
- **lzjsy**：首次尝试题解时“瑟瑟发抖”，最终通过DFS序和奇偶性简化问题。  
- **SSerxhs**：强调“树状数组比线段树更轻量”，避免冗余代码。  
- **K2sen**：线段树维护深度奇偶性时，需注意懒标记合并的细节。  

--- 

**核心代码实现（树状数组差分）**  
```cpp  
int tr[N]; // 树状数组  
void add(int x, int val) {  
    for (; x <= n; x += x & -x) tr[x] += val;  
}  
int query(int x) {  
    int res = 0;  
    for (; x; x -= x & -x) res += tr[x];  
    return res;  
}  
// 修改子树  
if (dep[u] % 2 == 1) add(L[u], val), add(R[u]+1, -val);  
else add(L[u], -val), add(R[u]+1, val);  
// 查询节点  
int ans = (dep[u] % 2 == 1) ? (val[u] + query(L[u])) : (val[u] - query(L[u]));  
```

---
处理用时：84.76秒
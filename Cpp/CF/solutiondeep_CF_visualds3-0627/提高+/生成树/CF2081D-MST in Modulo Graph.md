# 题目信息

# MST in Modulo Graph

## 题目描述

给定一个包含 $n$ 个顶点的完全图，其中第 $i$ 个顶点的权值为 $p_i$。连接顶点 $x$ 和顶点 $y$ 的边的权重等于 $\operatorname{max}(p_x, p_y) \bmod \operatorname{min}(p_x, p_y)$。

请找出连接图中所有 $n$ 个顶点的 $n - 1$ 条边组成的集合的最小总权重。

## 说明/提示

第一个测试用例中，一种可能的连接方式是选择边 $(1, 2)$、$(1, 4)$、$(1, 5)$、$(2, 3)$。第一条边的权重为 $\operatorname{max}(p_1, p_2) \bmod \operatorname{min}(p_1, p_2)=4 \bmod 3 = 1$，其他所有边的权重均为 $0$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
5
4 3 3 4 4
10
2 10 3 2 9 9 4 6 4 6
12
33 56 48 41 89 73 99 150 55 100 111 130
7
11 45 14 19 19 8 10```

### 输出

```
1
0
44
10```

# AI分析结果



---

**唯一算法分类**：最小生成树（Mruskal + 优化边数）

---

### 题解思路与算法要点

#### **核心思路**
1. **去重缩点**：权值相同的顶点间边权为0，合并为同一连通分量。
2. **倍数区间划分**：对每个权值 $p_i$，枚举其倍数区间 $[k \cdot p_i, (k+1) \cdot p_i)$，找到每个区间内最小的权值点，构造边。
3. **边权优化性质**：若存在 $x \le y \le z < 2x$，则连边 $(x,y)+(y,z)$ 总权重一定不劣于 $(x,y)+(x,z)$。
4. **Kruskal算法**：将构造的边按权值排序后生成最小生成树。

#### **关键实现**
- **预处理前驱后继**：对排序后的权值数组预处理 `nxt` 和 `lst` 数组，快速查找区间内最小点。
- **调和级数枚举**：对每个 $p_i$，枚举 $k$ 的范围为 $1$ 到 $\lfloor \max(p)/p_i \rfloor$，总枚举次数为 $O(n \log n)$。

---

### 题解评分（≥4星）

#### 1. **作者：_O_v_O_**（⭐⭐⭐⭐⭐）
- **亮点**：预处理 `nxt` 和 `lst` 数组实现高效区间查询，代码结构清晰，时间复杂度严格 $O(n \log n)$。
- **代码片段**：
  ```cpp
  for(int i=V;i>=1;i--) nxt[i] = cxx[i] ? i : nxt[i+1];
  for(int k=1; k*p[i]<=V; k++) {
    int to = nxt[k*p[i]+1];
    if(to <= (k+1)*p[i]) v.push_back({to, i, to - k*p[i]});
  }
  ```

#### 2. **作者：kanglr1013**（⭐⭐⭐⭐）
- **亮点**：思路描述详细，强调缩点与区间划分的数学证明，代码可读性较高。
- **代码片段**：
  ```cpp
  for(int k=1; k*p[i] <= max_p; k++) {
    auto it = lower_bound(p.begin(), p.end(), k*p[i]);
    if(it != p.end() && *it < (k+1)*p[i]) add_edge(i, *it);
  }
  ```

#### 3. **作者：Priestess_SLG**（⭐⭐⭐⭐）
- **亮点**：通过三数关系证明边权优化性质，代码简洁但缺少预处理优化。
- **代码片段**：
  ```cpp
  for(int k=1; ;k++) {
    int L = p[i] * k, R = p[i] * (k+1);
    int y = find_min_in_range(L, R);
    if(y == INF) break;
    edges.emplace_back(p[i], y, y % p[i]);
  }
  ```

---

### 最优思路提炼

1. **缩点优化**：将相同权值的点合并，消除 $0$ 权边。
2. **区间最小点筛选**：对每个 $p_i$ 的倍数区间，仅保留最小权值点，边数降为 $O(n \log n)$。
3. **预处理加速查询**：通过 `nxt` 数组快速定位区间内的最小点，避免重复扫描。

---

### 类似题目

1. **P7789 战斗模拟器**：同款边权优化思路。
2. **P3366 最小生成树**：Kruskal 基础模板题。
3. **P1967 货车运输**：最大生成树与路径查询结合。

---

### 可视化设计

#### **动画方案**
1. **像素网格展示**：顶点以不同颜色块表示，边按权值大小渐变连线颜色。
2. **高亮关键步骤**：
   - **缩点**：相同权值顶点合并时，颜色闪烁。
   - **区间划分**：绘制 $[k\cdot p_i, (k+1)\cdot p_i)$ 区间并高亮当前区间。
   - **边生成**：每次筛选到最小点时，绘制从 $p_i$ 到该点的边。
3. **音效与交互**：
   - **音效**：连边时播放“滴”声，合并缩点时播放“咔嚓”声。
   - **自动演示**：按步骤自动生成边并连接，支持暂停/步进。

#### **复古像素风格**
- **调色板**：16色，顶点用红/绿/蓝，边用黄色渐变。
- **Canvas 绘制**：顶点为 8x8 像素块，边为动态生长的线段。

---

### 核心代码实现

```cpp
// 预处理 nxt 数组
for(int i=V; i>=1; i--) nxt[i] = cxx[i] ? i : nxt[i+1];

// 枚举倍数区间
vector<Edge> edges;
for(int i=1; i<=n; i++) {
    for(int k=1; k*p[i] <= V; k++) {
        int L = k * p[i], R = (k+1) * p[i];
        int to = nxt[L+1];
        if(to > R) continue;
        edges.push_back({i, pos[to], to - L});
    }
}

// Kruskal 算法
sort(edges.begin(), edges.end(), [](Edge a, Edge b){
    return a.w < b.w;
});
int ans = 0;
DSU dsu(n);
for(auto &e : edges) {
    if(dsu.unite(e.u, e.v)) ans += e.w;
}
cout << ans << endl;
```

---
处理用时：73.67秒
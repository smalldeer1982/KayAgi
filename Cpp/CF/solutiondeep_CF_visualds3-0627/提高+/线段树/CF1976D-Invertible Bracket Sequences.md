# 题目信息

# Invertible Bracket Sequences

## 题目描述

### 题意翻译
### 题面描述
我们定义一个合法的括号序列，是仅由 `(` 和 `)` 构成的字符串且：
1. 空串 $\epsilon$ 是合法的括号序列。
2. 若 $s$ 为合法的括号序列，则 $(s)$ 也为合法的括号序列。
3. 若 $s,t$ 均为合法的括号序列，则 $st$ 也为合法的括号序列。（其中 $st$ 表示将字符串 $s$ 和 $t$ 拼接。）

定义对一个括号序列的**翻转**操作为：将这个括号序列的所有 `(` 变为 `)`，所有 `)` 变为 `(`。

如 `()(((` 翻转后成为 `)()))`。

给定一个**保证合法**的字符串 $s$。

你可以选择字符串 $s$ 的一个**子串**进行翻转操作。（注意是**子串**，与**子序列区分**，子串要求**连续**。）

问**翻转**了一个**子串**后得到的字符串 $s'$ 仍然是**合法括号序列**的方案数。

## 说明/提示

在本题中，不可以翻转长度为 $0$ 的子串。

translate by Hoks。

## 样例 #1

### 输入

```
4
(())
()
()()()
(()())(())```

### 输出

```
1
0
3
13```

# AI分析结果



## 算法分类
**前缀和+极值查询+哈希统计**

---

## 题解思路与核心难点分析

### 核心算法逻辑
1. **前缀和转换**：将括号序列转换为数值序列（`(`=1，`)`=-1），计算前缀和数组 `s[]`。
2. **极值查询预处理**：建立 ST 表或线段树，支持快速查询区间最大值。
3. **合法区间判定**：对于每个左端点 `l`，寻找最大的 `r` 满足：
   - 前缀和相等：`s[r] = s[l-1]`
   - 区间内最大值约束：`max(s[l..r]) ≤ 2*s[l-1]`
4. **哈希统计**：记录每个前缀和值的出现位置，通过二分快速统计区间内满足条件的右端点数量。

### 解决难点
- **极值约束推导**：翻转区间 `[l,r]` 后，新的前缀和需满足 `2*s[l-1] - s[i] ≥ 0`（`i ∈ [l,r]`），等价于 `max(s[l..r]) ≤ 2*s[l-1]`。
- **高效统计技巧**：通过 `vector` 或哈希表存储相同前缀和的位置，利用二分快速计数。

---

## 题解评分（≥4星）

### 1. 作者：Hoks（⭐⭐⭐⭐⭐）
- **关键亮点**：利用 ST 表维护区间最大值，结合二分查找确定合法区间，代码简洁高效。
- **核心代码**：
  ```cpp
  struct ST{...}; // ST表实现
  vector<ll> v[N]; // 按前缀和值分组存储位置
  for (ll i=1;i<=n;i++) v[sum[i]].push_back(i); // 预处理分组
  ```

### 2. 作者：2huk（⭐⭐⭐⭐）
- **关键亮点**：通过二分+ST表确定最大右端点，清晰展示极值约束条件。
- **核心逻辑**：
  ```cpp
  while (l <= r) { // 二分查找最大合法右端点
      if (st.get(e[a[i]][mid],i) > 2*a[i]) l=mid+1;
      else res=mid,r=mid-1;
  }
  ```

### 3. 作者：yshpdyt（⭐⭐⭐⭐）
- **关键亮点**：动态维护区间最大值约束，结合扫描线思想统计答案。
- **代码亮点**：
  ```cpp
  T.build(1,1,n); // 线段树维护区间极值
  for (ll j=0;j+1<v[i].size();j++) res += j-last; // 统计合法区间数
  ```

---

## 最优思路与技巧提炼

### 关键思路
- **前缀和极值约束**：通过 `max(s[l..r]) ≤ 2*s[l-1]` 确保翻转后不出现负前缀。
- **哈希+二分统计**：预处理每个前缀和值的位置列表，快速查询区间内符合 `s[r]=s[l-1]` 的数量。

### 代码实现技巧
- **ST表构建**：`O(n log n)` 预处理，`O(1)` 查询区间最大值。
- **分组存储**：使用 `vector` 或 `unordered_map` 存储相同前缀和的位置，提升查询效率。

---

## 类似题目推荐
1. **CF1270F - Awesome Substrings**（前缀和分组统计）
2. **LeetCode 32 - Longest Valid Parentheses**（极值约束与动态规划）
3. **洛谷 P1972 - 括号序列**（合法子串计数）

---

## 可视化与算法演示

### 动画设计
1. **折线图展示**：绘制原前缀和曲线与翻转后的新曲线，突出关键点 `l` 和 `r`。
2. **极值高亮**：用红色标记区间 `[l,r]` 的最大值，对比 `2*s[l-1]` 约束线。
3. **交互式步进**：允许用户点击按钮逐步执行二分查找和统计过程，展示：
   - 当前左端点 `l` 和候选右端点 `r`
   - 区间极值查询结果
   - 哈希表中符合条件的右端点数量更新

### 复古像素风格
- **8位色彩**：前缀和曲线用绿色像素绘制，极值点用红色闪烁方块。
- **音效设计**：
  - **有效匹配**：短促「嘀」声。
  - **无效区间**：低沉「哔」声。
- **自动演示模式**：按固定速度逐步执行算法，显示当前统计的答案增量。

---

## 代码实现（核心片段）

### ST表+二分统计（Hoks 题解）
```cpp
struct ST {
    int st[20][N];
    void build(int a[]) { /* 预处理ST表 */ }
    int query(int l, int r) { /* 区间极值查询 */ }
} st;

ll work() {
    vector<int> pos[N];
    for (int i=1; i<=n; i++) pos[sum[i]].push_back(i);
    ll ans=0;
    for (int l=1; l<=n; l++) {
        int L=1, R=pos[sum[l-1]].size()-1, res=-1;
        while (L<=R) { // 二分最大r
            int mid = (L+R)/2;
            if (st.query(l, pos[sum[l-1]][mid]) <= 2*sum[l-1])
                res=mid, L=mid+1;
            else R=mid-1;
        }
        ans += res+1; // 统计合法右端点数量
    }
    return ans;
}
```

---

## 总结
本题核心在于将翻转操作转化为前缀和的极值约束，通过高效数据结构和分组统计优化计算。可视化设计可结合折线图和交互式步进，帮助理解极值约束与二分查找过程。

---
处理用时：80.71秒
# 题目信息

# Earnest Matrix Complement

## 题目背景

3, 2, 1, ... 我们是 —— RiOI 团队！

—— Felix & All, [特别感谢 3](https://www.luogu.com.cn/problem/T351681)

- Peter: 好消息，我的题目 T311013 已获批！
- $ \delta $: 幸好我的电脑没电，不然我可能参加了 wyrqwq 的比赛并得到负分。
- Felix: \[点赞\] 关于一首被删除歌曲的题目陈述！
- Aquawave: 我该为我的化学课感到悲伤吗？
- E.Space: 啊？
- Trine: 面包。
- Iris: 为什么总是我来测试题目？

时光走过，未来我们会再遇见。回首往事，大家都过上了各自想要的生活。

## 题目描述



Aquawave 有一个大小为 $ n \times m $ 的矩阵 $ A $，其中的元素只允许是 $ [1, k] $ 区间内的整数。矩阵中的一些位置已被填上整数，其余位置用 $ -1 $ 表示，代表尚未填充。

你的任务是将矩阵 $ A $ 填满所有空白位置，接着定义 $ c_{u,i} $ 为第 $ i $ 行中数字 $ u $ 出现的次数。Aquawave 将矩阵的美丽定义为：

$$ \sum_{u=1}^k \sum_{i=1}^{n-1} c_{u,i} \cdot c_{u,i+1}. $$

请找出在最佳填充方案下的矩阵 $ A $ 的最大美丽值。

## 说明/提示

在第一个测试用例中，矩阵 $ A $ 已经确定，其美丽值为：

$$ \sum_{u=1}^k \sum_{i=1}^{n-1} c_{u,i} \cdot c_{u,i+1} = c_{1,1} \cdot c_{1,2} + c_{1,2} \cdot c_{1,3} + c_{2,1} \cdot c_{2,2} + c_{2,2} \cdot c_{2,3} + c_{3,1} \cdot c_{3,2} + c_{3,2} \cdot c_{3,3} = 1 \cdot 1 + 1 \cdot 1 + 2 \cdot 0 + 0 \cdot 1 + 0 \cdot 2 + 2 \cdot 1 = 4。$$

在第二个测试用例中，可以这样填充矩阵：

$$ \begin{bmatrix} 2 & 3 & 3 \\ 2 & 2 & 3 \end{bmatrix}, $$

得到的美丽值为 $ 4 $。这可以被证明是最大的可能值。

在第三个测试用例中，以下为一种可能的最优填充方案：

$$ \begin{bmatrix} 1 & 1 & 1 \\ 1 & 2 & 1 \\ 1 & 1 & 4 \end{bmatrix}. $$

在第四个测试用例中，下面是一种可能的最优配置：

$$ \begin{bmatrix} 1 & 3 & 2 & 3 \\ 1 & 3 & 2 & 1 \\ 3 & 1 & 5 & 1 \end{bmatrix}. $$

在第五个测试用例中，以下是一种可能的最优填充：

$$ \begin{bmatrix} 5 & 5 & 2 \\ 1 & 8 & 5 \\ 7 & 5 & 6 \\ 7 & 7 & 4 \\ 4 & 4 & 4 \end{bmatrix}. $$

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
9
3 3 3
1 2 2
3 1 3
3 2 1
2 3 3
-1 3 3
2 2 -1
3 3 6
-1 -1 1
1 2 -1
-1 -1 4
3 4 5
1 3 2 3
-1 -1 2 -1
3 1 5 1
5 3 8
5 -1 2
1 8 -1
-1 5 6
7 7 -1
4 4 4
6 6 5
-1 -1 5 -1 -1 -1
-1 -1 -1 -1 2 -1
-1 1 3 3 -1 -1
-1 1 -1 -1 -1 4
4 2 -1 -1 -1 4
-1 -1 1 2 -1 -1
6 6 4
-1 -1 -1 -1 1 -1
3 -1 2 2 4 -1
3 1 2 2 -1 -1
3 3 3 3 -1 2
-1 3 3 -1 1 3
3 -1 2 2 3 -1
5 5 3
1 1 3 -1 1
2 2 -1 -1 3
-1 -1 -1 2 -1
3 -1 -1 -1 2
-1 1 2 3 -1
6 2 7
-1 7
-1 6
7 -1
-1 -1
-1 -1
2 2```

### 输出

```
4
4
10
10
8
102
93
58
13```

# AI分析结果



## 算法分类  
动态规划、贪心优化

---

## 题解思路与算法要点  
### 核心结论  
**每行空白必须填同一种数**，通过调整法证明：若某行填两种数，替换为其中更高贡献的数不会更劣。  
### 动态规划模型  
1. **状态定义**：`f[i][j]` 表示第i行填j时的最大美丽值。  
2. **转移方程**：  
   `f[i][j] = max(f[i-1][j] + emp[i]*emp[i-1], max_prev) + emp[i]*(cnt_prev[j] + cnt_next[j])`  
   其中 `emp[i]` 为第i行空位数，`cnt_prev[j]` 为前一行已有j的数量，`max_prev` 是上一行的全局最大值。  
3. **优化技巧**：  
   - 全局加法标记处理 `emp[i]*emp[i-1]`  
   - 全局取最大值标记处理 `max_prev`  
   - 单点加法处理已知数的贡献  

### 解决难点  
- **高效维护状态转移**：通过全局标记避免逐个更新，将复杂度从O(nk)优化至O(n+m)。  
- **数据结构选择**：使用标记系统而非线段树，降低实现复杂度。  

---

## 题解评分  
### ⭐⭐⭐⭐ IvanZhang2009  
- **亮点**：清晰的标记维护逻辑，代码简洁高效。  
- **关键代码**：  
  ```cpp
  // 全局标记维护
  X += co; Y = max(Y + co, mx); mx += co;
  // 单点更新
  f[j] = max(X + f[j], Y) + c[j] * cnt[i];
  ```

### ⭐⭐⭐⭐ Gold14526  
- **亮点**：模块化标记系统，使用命名空间封装操作。  
- **关键结构**：  
  ```cpp
  namespace A{
    ll addtag, maxtag, a[], mx;
    void alladd(ll x) { addtag += x; maxtag += x; }
    void add(int x, ll y) { a[x] = max(a[x], maxtag) + y; }
  }
  ```

### ⭐⭐⭐⭐ littlebug  
- **亮点**：极简标记系统实现，代码可读性强。  
- **核心逻辑**：  
  ```cpp
  tr.alladd(d[i-1]*d[i]);  // 全局加
  tr.allmax(lstans);       // 全局取max
  for (x : a[i±1]) tr.add(x, d[i]); // 单点加
  ```

---

## 最优思路提炼  
1. **贪心选择**：每行填同一种数，通过调整法证明最优性。  
2. **标记系统优化**：用全局加法标记（模拟区间加）、全局最大值标记（模拟区间取max）替代显式遍历。  
3. **贡献分治**：将贡献拆分为已知数间贡献与填充数贡献，分别预处理和动态维护。  

---

## 类似算法题目  
1. **CF148E**：区间动态规划优化  
2. **洛谷P1880**：环形石子合并（区间DP优化）  
3. **LeetCode 2212**：填充矩阵最大化得分（贪心+DP）  

---

## 可视化设计  
### 动态规划标记系统动画  
1. **颜色标记**：  
   - 红色高亮当前行空位数 `emp[i]`  
   - 蓝色标记全局加法 `X` 和最大值 `Y`  
2. **操作演示**：  
   - 步骤1：全局加 `emp[i]*emp[i-1]`（红色波浪线覆盖全行）  
   - 步骤2：全局取max（蓝色光柱从上一行max值射出）  
   - 步骤3：单点加已知数贡献（黄色光点闪烁在特定列）  
3. **复古像素风格**：  
   - 8-bit 字体显示标记值，网格线模拟矩阵行  
   - 音效：加法时"哔"声，取max时"叮"声，完成时经典过关音效  

---

## 核心代码片段  
IvanZhang2009 的关键实现：  
```cpp
// 维护全局标记和单点更新
X += co; Y = max(Y + co, mx); 
for (auto j : T) {
    f[j] = max(X + f[j], Y) + c[j] * cnt[i];
    mx = max(mx, f[j]);
    f[j] -= X;  // 调整标记偏移
}
```

---

## 个人心得摘录  
> "注意力惊人的发现，全局标记可以压缩状态转移的维度，将O(k)操作变为O(1)" —— littlebug  
> "线段树是屠龙刀，但此题只需小刀刻标记" —— Gold14526  

---

## 同类型题推荐  
1. **洛谷P1005**：矩阵取数（高精度+DP优化）  
2. **CF1114D**：区间染色（区间DP+贪心）  
3. **洛谷P2893**：修路（贪心+堆优化）

---
处理用时：68.66秒
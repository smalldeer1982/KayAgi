# 题目信息

# DZY Loves Fibonacci Numbers

## 题目描述

斐波那契数列 $f_n$ 由以下递推式定义：

- $f_1=f_2=1$
- $f_n=f_{n-1}+f_{n-2}\;(n>2)$

DZY 很喜欢斐波那契数列，它给了你 $n$ 个整数 $a_1,a_2,\cdots,a_n$.

你需要执行 $m$ 个操作，操作分两种：

- `1 l r`：对所有 $l\le i\le r$，将 $a_i$ 加上 $f_{i-l+1}$.
- `2 l r`：求 $a_l\sim a_r$ 的和，对 $10^9+9$ 取模.

## 说明/提示

$1\le n,m\le 3\times 10^5$

$1\le a_i\le 10^9$

## 样例 #1

### 输入

```
4 4
1 2 3 4
1 1 4
2 1 4
1 2 4
2 1 3
```

### 输出

```
17
12
```

# AI分析结果



# 算法分类  
**线段树**

---

# 综合分析与结论  
## 核心算法流程  
所有题解均围绕 **线段树 + 斐波那契数列性质** 展开，核心难点在于 **高效维护区间加斐波那契数列的标记**。关键创新点包括：

1. **标记拆分与合并**  
   AThousandSuns 通过斐波那契恒等式 `f_{n+m} = f_{n+1}f_m + f_n f_{m-1}`，将增量分解为两个独立标记 `add1` 和 `add2`，分别表示 `f_{-l+1}` 和 `f_{-l}`，使得区间加操作可合并和下推。

2. **广义斐波那契数列**  
   Dzhao 和 EndSaH 维护广义斐波那契数列的前两项作为标记，利用其递推式 `S_n = a*f_{n-2} + b*f_{n-1}` 快速求和，标记合并时直接相加首项和次项。

3. **根号分治优化**  
   HenryHuang 将操作分块处理，累积 `T` 次操作后统一更新原数组，平衡了暴力与线段树的复杂度。

---

## 题解清单（≥4星）  
### 1. AThousandSuns（5星）  
**核心亮点**：  
- 利用斐波那契分解公式，将标记拆分为独立项  
- 预处理负下标斐波那契值 `rfib`，实现 O(1) 标记下推  
- 代码简洁高效，逻辑清晰  

**关键代码**：  
```cpp
void pushdown(int o,int l,int r){
    int mid=(l+r)>>1;
    add1[o<<1] += add1[o]; 
    add2[o<<1] += add2[o];
    sum[o<<1] += add1[o]*(pre[mid+1]-pre[l]) + add2[o]*(pre[mid]-pre[l-1]);
    // 右子节点同理...
}
```

---

### 2. Dzhao（4星）  
**核心亮点**：  
- 维护广义斐波那契的前两项作为标记  
- 利用 `sum = f_{n+2} - f_2` 公式快速求和  
- 数学推导严谨，适合理解斐波那契性质  

**个人心得**：  
> "盯了3小时终于研究透彻...广义斐波那契的合并只需相加首项和次项"

---

### 3. 81179332_（4星）  
**核心亮点**：  
- 使用斐波那契通项公式转换为等比数列  
- 结合二次剩余 `√5 ≡ 383008016 mod 1e9+9`  
- 双线段树分别维护两个等比数列  

---

# 可视化设计  
## 动画方案（8位像素风格）  
1. **线段树节点高亮**  
   - **红色块**：当前更新的区间节点  
   - **绿色数字**：`add1` 和 `add2` 标记值  
   - **黄色箭头**：标记下推过程  

2. **斐波那契增量演示**  
   - 网格显示区间 `[l,r]`，每个位置 `i` 的增量 `f_{i-l+1}` 以蓝色像素块高度表示  
   - 执行区间加操作时，蓝色块从 `l` 到 `r` 波浪式扩散  

3. **音效设计**  
   - **标记合并**：短促 "滴" 声  
   - **区间查询**：成功时播放上升音阶  
   - **错误操作**：低沉 "嗡" 声  

---

# 类似题目推荐  
1. **P1438 无聊的数列**（区间加等差数列）  
2. **P3373 线段树2**（双标记混合操作）  
3. **CF718C Sasha and Array**（斐波那契矩阵加速）  

---

# 核心代码（AThousandSuns 解法）  
```cpp
// 预处理负下标斐波那契 
rfib[0]=0; rfib[1]=1; rfib[2]=mod-1;
for(int i=3;i<=n+1;i++) 
    rfib[i] = (i&1)?fib[i] : mod-fib[i];

void update(int o,int l,int r,int ql,int qr,int a1,int a2){
    if(l>=ql && r<=qr){
        add1[o] = (add1[o]+a1)%mod;
        add2[o] = (add2[o]+a2)%mod;
        sum[o] += a1*(pre[r+1]-pre[l]) + a2*(pre[r]-pre[l-1]);
        return;
    }
    pushdown(o,l,r);
    // 递归更新左右子节点...
}
```

---

# 总结  
**最优技巧**：  
将斐波那契增量 **解耦为线性组合**，通过独立标记实现高效合并。此思路可推广至其他满足线性递推的特殊数列（如等差数列、几何数列）。

---
处理用时：65.20秒
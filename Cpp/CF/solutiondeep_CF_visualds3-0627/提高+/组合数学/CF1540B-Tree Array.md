# 题目信息

# Tree Array

## 题目描述

You are given a tree consisting of $ n $ nodes. You generate an array from the tree by marking nodes one by one.

Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree.

After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node.

It can be shown that the process marks all nodes in the tree.

The final array $ a $ is the list of the nodes' labels in order of the time each node was marked.

Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.

The number of inversions in an array $ a $ is the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i > a_j $ . For example, the array $ [4, 1, 3, 2] $ contains $ 4 $ inversions: $ (1, 2) $ , $ (1, 3) $ , $ (1, 4) $ , $ (3, 4) $ .

## 说明/提示

This is the tree from the first sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/3833e6cdc8f432e8774aa8c02d9352118566a812.png)For the first sample, the arrays are almost fixed. If node $ 2 $ is chosen initially, then the only possible array is $ [2, 1, 3] $ ( $ 1 $ inversion). If node $ 3 $ is chosen initially, then the only possible array is $ [3, 1, 2] $ ( $ 2 $ inversions). If node $ 1 $ is chosen initially, the arrays $ [1, 2, 3] $ ( $ 0 $ inversions) and $ [1, 3, 2] $ ( $ 1 $ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $ \frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6} $ .

 $ 166666669 \cdot 6 = 7 \pmod {10^9 + 7} $ , so the answer is $ 166666669 $ .

This is the tree from the second sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/7f613b365926417ec34142a093ccc13b3b572f4f.png)This is the tree from the third sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/4cf8ac5fc765cc7cdc6657a332a13e66dcba8fef.png)

## 样例 #1

### 输入

```
3
1 2
1 3```

### 输出

```
166666669```

## 样例 #2

### 输入

```
6
2 1
2 3
6 1
1 4
2 5```

### 输出

```
500000009```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
2 5```

### 输出

```
500000007```

# AI分析结果



**算法分类**：期望DP、最近公共祖先（LCA）、树形结构

---

### **题解思路与核心难点**

1. **线性期望拆分**  
   将逆序对期望拆分为每对节点$(u, v)$（其中$u > v$）的贡献，计算$u$比$v$先被标记的概率之和。

2. **动态规划预处理**  
   定义$f[i][j]$表示从LCA到$u$需要$i$步，到$v$需要$j$步时，$u$先被标记的概率。转移方程：  
   $$f[i][j] = \frac{f[i-1][j] + f[i][j-1]}{2}$$  
   边界条件：$f[0][j] = 1$（$u$已选），$f[i][0] = 0$（$v$已选）。

3. **枚举根节点与LCA计算**  
   - 枚举每个节点作为初始根节点，计算所有节点对的贡献。  
   - 使用倍增法预处理LCA和深度，快速查询每对节点的LCA及路径长度。

4. **时间复杂度优化**  
   - 预处理$f$数组为$O(n^2)$，枚举根与节点对为$O(n^3)$，LCA查询为$O(\log n)$，总复杂度$O(n^3 \log n)$，可接受。

---

### **最优思路提炼**

1. **关键技巧**  
   - **逆序对贡献拆分**：利用期望线性性，独立计算每对节点的贡献。  
   - **路径概率模型**：将问题简化为从LCA出发的等概率路径选择模型。  
   - **动态规划预处理**：通过状态转移高效计算路径选择概率。

2. **实现要点**  
   ```cpp
   // 预处理DP数组
   for (int i = 1; i <= n; i++) {
       for (int j = 1; j <= n; j++) {
           f[i][j] = (f[i-1][j] + f[i][j-1]) * inv2 % mod;
       }
   }
   // 枚举根节点并计算贡献
   for (int root = 1; root <= n; root++) {
       dfs(root, 0); // 预处理LCA和深度
       for (int u = 1; u <= n; u++) {
           for (int v = 1; v < u; v++) {
               int l = LCA(u, v);
               int dx = dep[u] - dep[l], dy = dep[v] - dep[l];
               ans += f[dx][dy];
           }
       }
   }
   ```

---

### **题解评分（≥4星）**

1. **Acfboy（5星）**  
   - 思路清晰，代码简洁，预处理LCA和DP数组实现高效。  
   - 使用倍增法快速查询LCA，适用于大深度树。

2. **白鲟（4星）**  
   - 明确拆分逆序对贡献，动态规划推导详细。  
   - 代码中通过DFS预处理子树大小优化路径选择概率计算。

3. **Cry_For_theMoon（4星）**  
   - 详细注释与调试经验分享，帮助理解概率模型。  
   - 实现中通过链式处理减少LCA查询次数。

---

### **同类型题推荐**

1. **CF1187F Expected Square Beauty**  
   - 期望拆分与动态规划结合，计算区间贡献。

2. **Luogu P4438 [HNOI/AHOI2018]道路**  
   - 树形结构上的动态规划与概率计算。

3. **CF908D New Year and Arbitrary Arrangement**  
   - 期望DP与状态转移模型设计。

---

### **可视化设计思路**

1. **核心流程动画**  
   - **步骤高亮**：展示从根节点到LCA的路径扩展过程，用不同颜色标记当前选择的节点。  
   - **DP状态演示**：在网格中动态更新$f[i][j]$的值，显示转移路径。

2. **复古像素风格**  
   - **8位颜色方案**：使用16色调色板，根节点为红色，LCA为绿色，路径节点为蓝色。  
   - **音效触发**：节点标记时播放“哔”声，路径扩展时播放“咔嗒”声。

3. **交互控制**  
   - **速度调节**：滑动条控制动画速度（1x, 2x, 5x）。  
   - **单步执行**：按空格键逐步执行标记过程，观察概率计算步骤。

---

### **代码实现（关键片段）**

```cpp
// 预处理DP概率表
int f[N][N], inv2 = 500000004; // mod逆元
for (int i = 0; i <= n; i++) f[0][i] = 1;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        f[i][j] = (1LL * f[i-1][j] + f[i][j-1]) * inv2 % mod;
    }
}

// 计算每对节点的贡献
int ans = 0;
for (int root = 1; root <= n; root++) {
    dfs(root, 0); // 预处理LCA和深度
    for (int u = 1; u <= n; u++) {
        for (int v = 1; v < u; v++) {
            int l = LCA(u, v);
            int dx = dep[u] - dep[l], dy = dep[v] - dep[l];
            ans = (ans + f[dx][dy]) % mod;
        }
    }
}
ans = 1LL * ans * inv(n) % mod; // 最终期望
```

---

**总结**：通过拆分逆序对贡献、预处理动态规划概率表及高效LCA查询，将复杂期望问题转化为可计算的路径模型。结合树形结构特性，实现高效且清晰的算法流程。

---
处理用时：75.85秒
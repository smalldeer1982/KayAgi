# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果



1. **唯一算法分类**  
   组合数学

2. **综合分析与结论**  
   题目要求构造满足条件的发射序列，每个楼层i的居民需确保自己视角的飞机数≥c。顶层的居民必须发射恰好c次（否则无法满足自身条件），其余n-1层居民的发射次数总和为m-c。每个非顶层居民的k次发射必须在其视角的前c次中，相当于从c个位置选k个，组合数为C(c,k)。总方案数为组合数C((n-1)*c, m-c)，因为所有非顶层居民的发射可视为在(n-1)*c个位置中选择m-c个。

   可视化设计思路：用像素风格展示楼层与发射位置。每个楼层对应c个“候选位”，用户可点击选择发射位置，动态计算剩余可用次数并更新组合数。颜色区分已选/未选位置，顶层层用特殊颜色标记，强制填满c次。

3. **题解清单 (≥4星)**  
   - **xyvsvg（5星）**：直接组合数公式，时间复杂度最优，代码简洁。
   - **2022dyx（4星）**：数学推导清晰，组合意义解释到位。
   - **CReatiQ（4星）**：同时给出组合与DP思路，对比性强。

4. **代码粘贴与核心实现思想**  
   ```cpp
   // xyvsvg 的代码（组合数）
   #include<bits/stdc++.h>
   using namespace std;
   const int mod=1e9+7,N=1e4;
   int fac[N+10],inv[N+10],finv[N+10];
   
   void solve() {
       int n,c,m;
       cin >>n>>c>>m;
       // 检查 m-c 是否在合法范围
       if (m < c || (n-1)*c < m-c) cout <<0<<endl;
       else {
           int ans = fac[(n-1)*c] * finv[m-c] % mod;
           ans = ans * finv[(n-1)*c - (m-c)] % mod;
           cout << ans << endl;
       }
       // 略过输入处理
   }
   
   int main() {
       // 预处理阶乘与逆元
       fac[0] = inv[1] = finv[0] = 1;
       for(int i=2;i<=N;++i) inv[i] = 1LL*(mod-mod/i)*inv[mod%i]%mod;
       for(int i=1;i<=N;++i) {
           fac[i] = 1LL*fac[i-1]*i%mod;
           finv[i] = 1LL*finv[i-1]*inv[i]%mod;
       }
       int t; cin >>t;
       while(t--) solve();
   }
   ```

5. **同类型题或类似算法套路**  
   类似问题需处理受限组合选择，如背包问题中物品数量限制，或生成函数求系数。例如“多重集合组合数”、“隔板法应用”。

6. **推荐相似题目**  
   - P3197 [HNOI2008]越狱（组合数学）
   - P1313 计算系数（二项式定理）
   - P3223 [HNOI2012]排队（高精度组合数）

7. **个人心得摘录**  
   - 关键突破点：顶层必须发射c次，其余层的每发射次视为从c个位置选k个。
   - 组合数推导时需注意数值范围，预处理阶乘优化计算。

8. **可视化与算法演示**  
   **复古像素动画设计**：  
   - **画面**：左侧为n层像素楼，每层高亮c个发射位。右侧显示当前组合数。
   - **交互**：点击发射位填充颜色，自动计算剩余次数并更新答案。
   - **音效**：选择时8-bit音效，错误操作时低沉提示音。
   - **自动演示**：按层填充发射位，动态展示组合过程，最终高亮顶层的c次发射。

---
处理用时：285.08秒
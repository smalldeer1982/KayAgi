# 题目信息

# MEX vs DIFF

## 题目描述

给你一个大小为n的数组a，保证数组内元素非负，你可以执行以下操作k次：

在一次操作中将数组内任意一个数字改为任何一个非负整数。

现在定义这个数组的成本为DIFF(a)−MEX(a)，其中 DIFF(a) 为a数组内元素去重后的数量，  MEX(a) 为数组中未出现的元素中最小的元素，
举个例子，MEX( { 1 , 2 , 3 } )=0 , MEX( { 0 , 1 , 2 , 4 , 5 } ) = 3。

现在给你数组a，求能实现的最小成本。

## 说明/提示

在第一个测试用例中，不需要任何操作来最小化 DIFF-MEX 的值。

在第二个测试用例中，可以将 5 替换为 1 。 数组 a 变为[ 0 , 2 , 4 , 1 ] , DIFF = 4，MEX=MEX( { 0 , 1 , 2 , 4 } )=3 ，所以答案是 1.

在第三个测试用例中，一个可能的数组 a 的变形是[ 4 , 13 , 0 , 0 , 13 , 1 , 2 ]，其中 DIFF = 5，MEX = 3。

在第四个测试用例中，一个可能的数组 a 的变形是 [ 1 , 2 , 3 , 0 , 0 , 0 ] 。

## 样例 #1

### 输入

```
4
4 1
3 0 1 2
4 1
0 2 4 5
7 2
4 13 0 0 13 1337 1000000000
6 2
1 2 8 0 0 0```

### 输出

```
0
1
2
0```

# AI分析结果



### 题解思路、算法要点与解决难点

#### 核心贪心思路
所有题解的共同核心思路是：
1. **最大化 MEX**：用尽可能多的操作填补 0~m-1 的空缺，使得 MEX 达到最大可能值 m。
2. **最小化 DIFF**：将 ≥ m 的元素尽可能合并，减少不同元素数量。优先处理出现次数少的元素，以最小化操作次数对 DIFF 的削减。

#### 关键推导
- **性质验证**：修改操作必须用完 k 次，且优先填补 MEX 的空缺。例如，若 MEX 最终为 m，则 0~m-1 必须全部存在，这需要消耗部分操作次数。
- **贪心选择依据**：对于 ≥ m 的元素，按出现次数升序处理，每次完全移除一个元素的所有实例（DIFF 减 1），直到操作次数耗尽。

#### 数据结构与实现
- **统计出现次数**：使用哈希表或排序统计每个元素的出现次数。
- **优先队列/排序**：将 ≥ m 的元素按出现次数升序排列，贪心选择。

---

### 题解评分（≥4星）

1. **lingfunny（5星）**
   - **亮点**：思路清晰，代码简洁，利用优先队列实现贪心策略。通过排序和模拟填补空缺的过程明确推导 MEX。
   - **代码片段**：
     ```cpp
     priority_queue<node> Q; // 按出现次数和值排序
     while (Q.size()) {
         auto [val, cnt] = Q.top(); Q.pop();
         if (lft + cnt <= k) --diff, lft += cnt;
     }
     ```

2. **ScottSuperb（4星）**
   - **亮点**：将问题转化为“塔”的填补，直观展示贪心策略。利用 map 统计空缺和元素出现次数。
   - **代码片段**：
     ```cpp
     for (auto ii : m) ++c[ii.second]; // 统计出现次数分布
     for (auto ii : c) if (ii.first <= k) ans -= j; // 贪心削减 DIFF
     ```

3. **Polaris_Australis_（4星）**
   - **亮点**：枚举 MEX 并计算对应 DIFF 的最小值，思路全面。通过值域树状数组高效处理出现次数。
   - **代码片段**：
     ```cpp
     for (int mex = n; mex >= 0; --mex) { // 倒序枚举 MEX
         if (check(mex)) { ... } // 计算当前 mex 下的 DIFF
     }
     ```

---

### 最优思路提炼

1. **MEX 最大化**：
   - 填补 0~m-1 的空缺，消耗操作次数。若剩余次数允许，MEX 尽可能大。
   
2. **DIFF 最小化**：
   - 统计 ≥ MEX 的元素出现次数，按升序处理，每次完全移除一个元素的所有实例。

---

### 同类型题与算法套路

- **贪心套路**：处理双指标优化问题时，先固定一个指标（如 MEX），再优化另一个（如 DIFF）。
- **类似题目**：
  1. **CF1526C2**（最大化可正数和的元素数量）
  2. **LC1481**（最少删除使剩余元素唯一）
  3. **LC1353**（最多可参加的会议数）

---

### 推荐题目
1. **P1803 凌乱的yyy / 线段覆盖**（区间贪心）
2. **P2240 部分背包问题**（价值密度贪心）
3. **P1223 排队接水**（时间安排贪心）

---

### 可视化与算法演示

#### 贪心过程动画设计
- **像素风格**：用不同颜色方块表示数组元素，空缺位置用黑色标记。
- **步骤演示**：
  1. **填补空缺**：高亮当前空缺位置，消耗操作次数填充。
  2. **处理剩余元素**：将 ≥ MEX 的元素按出现次数升序排列，逐个移除（方块消失）。
- **交互功能**：滑块调节速度，按钮单步执行，音效提示关键操作。

#### 复古游戏化设计
- **8-bit 音效**：填充空缺时播放“收集金币”音效，移除元素时播放“消除”音效。
- **积分系统**：每减少 1 DIFF 获得 100 分，剩余操作次数转化为额外奖励。

---

### 核心代码实现

**lingfunny 的贪心部分**：
```cpp
// 计算 MEX
for (int i = 1; i <= tot && cgb; ++i) {
    while (b[i] != MEX && lft) ++MEX, --lft, --cgb, ++diff;
    if (b[i] == MEX && cgb) ++MEX, --cgb;
}

// 处理剩余元素
priority_queue<node> Q;
for (int i = 1; i <= n;) {
    int x = a[i], cnt = 0;
    while (x == a[i] && i <= n) ++cnt, ++i;
    if (x >= MEX) Q.push({x, cnt});
}

// 贪心削减 DIFF
while (Q.size()) {
    auto [val, cnt] = Q.top(); Q.pop();
    if (lft + cnt <= k) --diff, lft += cnt;
}
```

---

### 总结
通过最大化 MEX 和贪心削减 DIFF，结合优先队列或排序策略，可在 O(n log n) 时间内高效解决问题。可视化设计强化了对贪心选择的理解，复古风格增加学习趣味性。

---
处理用时：83.70秒
# 题目信息

# Monsters (hard version)

## 题目描述

在一款电脑游戏中，你正在与 $n$ 个怪物作战。怪物 $i$ 的生命值为 $a_i$，所有的 $a_i$ 都是整数。只要怪物的生命值至少为 $1$，它就活着。

你可以施放两种类型的法术：

1. 对任意一个存活的怪物造成 $1$ 点伤害。
2. 对所有存活的怪物造成 $1$ 点伤害。如果至少有一个怪物死亡（其生命值降到 $0$），则该法术会继续重复施放，直到没有怪物死亡为止。

对怪物造成 $1$ 点伤害会减少其生命值 $1$ 点。

类型 $1$ 的法术可以施放任意次数，而类型 $2$ 的法术只能施放一次。

对于每个 $k = 1, 2, \dots, n$，请回答以下问题：假设游戏中只有前 $k$ 个怪物（编号为 $1, 2, \dots, k$）存在，那么最少需要施放多少次类型 $1$ 的法术才能击杀所有这 $k$ 个怪物？

## 说明/提示

#### 示例 1

在第一个测试用例中，当 $k = n$ 时，怪物的初始生命值为 $[3, 1, 2]$。此时只需要施放一次类型 $2$ 的法术：

- 使用类型 $2$ 法术，对所有怪物造成 $1$ 点伤害，怪物的生命值变为 $[2, 0, 1]$。由于怪物 $2$ 死亡，法术会继续施放。
- 使用类型 $2$ 法术，怪物的生命值变为 $[1, 0, 0]$，此时怪物 $3$ 死亡，法术继续施放。
- 使用类型 $2$ 法术，怪物的生命值变为 $[0, 0, 0]$，此时怪物 $1$ 死亡，法术继续施放。
- 使用类型 $2$ 法术，所有怪物的生命值都降为 $0$，结束。

因此，最后无需再使用类型 $1$ 法术，答案是 $0$ 次。

#### 示例 2

在第二个测试用例中，怪物的初始生命值为 $[4, 1, 5, 4, 1, 1]$。一种最优的行动顺序如下：

- 先使用类型 $1$ 法术，给怪物 $1$ 造成 $1$ 点伤害，生命值变为 $[3, 1, 5, 4, 1, 1]$。
- 再使用类型 $1$ 法术，给怪物 $4$ 造成 $1$ 点伤害，生命值变为 $[3, 1, 5, 3, 1, 1]$。
- 再使用类型 $1$ 法术，给怪物 $4$ 造成 $1$ 点伤害，生命值变为 $[3, 1, 5, 2, 1, 1]$。
- 然后使用类型 $2$ 法术：
  - 所有怪物的生命值减去 $1$，变为 $[2, 0, 4, 1, 0, 0]$，怪物 $2$、$5$ 和 $6$ 死亡，法术继续施放。
  - 再次使用类型 $2$ 法术，怪物的生命值变为 $[1, 0, 3, 0, 0, 0]$，怪物 $4$ 死亡，法术继续施放。
  - 再次使用类型 $2$ 法术，怪物的生命值变为 $[0, 0, 2, 0, 0, 0]$，怪物 $1$ 死亡，法术继续施放。
  - 使用类型 $2$ 法术，怪物的生命值变为 $[0, 0, 1, 0, 0, 0]$。
- 然后使用类型 $1$ 法术，给怪物 $3$ 造成 $1$ 点伤害，生命值变为 $[0, 0, 0, 0, 0, 0]$，结束。

因此，总共需要施放 $4$ 次类型 $1$ 法术。

## 样例 #1

### 输入

```
2
3
3 1 2
6
4 1 5 4 1 1```

### 输出

```
2 1 0
3 2 4 4 4 4```

# AI分析结果



### 综合分析与结论

**核心贪心思路**：通过预处理使怪物生命值形成连续递增的阶梯结构（如 1,2,3,...,k），使得类型2法术能连续触发多次，最大化消灭次数。类型1的代价即为将原生命值调整至该阶梯结构的差值总和。

**解决难点**：动态维护阶梯结构，处理插入新元素时的调整逻辑。关键难点在于如何高效判断当前结构是否需要调整，以及如何快速找到最优调整位置。

**算法共性**：
1. 排序后维护递增序列
2. 使用集合或线段树快速查询可调整的位置
3. 倒序处理或差值计算优化空间

---

### 题解评分（≥4星）

1. **xcyle（5星）**
   - **亮点**：双集合维护（s/t）实现倒序调整，代码简洁高效。
   - **关键代码**：
     ```cpp
     for (auto it = t.begin(); it != t.end(); it = t.upper_bound(lev)) {
         ans += (*it) - ++lev;
         t.erase(it);
     }
     ```
   - **个人心得**：通过反向删除操作修正答案，巧妙避免了复杂的前向维护。

2. **Leasier（4星）**
   - **亮点**：线段树维护 `cnt[j]-j` 最小值，直观展示阶梯结构的合法性。
   - **关键代码**：
     ```cpp
     int pos = get_first(1);
     if (pos == -1) cnt++;
     else ans += a[i] - pos;
     ```

3. **封禁用户（4星）**
   - **亮点**：权值线段树动态维护差值，直接计算答案差。
   - **关键代码**：
     ```cpp
     tree.update(1,1,n,a[i],n,-1);
     if(tree.mn[1] < 0) {
         int x = tree.query(1,1,n);
         tree.update(1,1,n,x,n,1);
     }
     ```

---

### 最优思路提炼

1. **阶梯构造法**：
   - 将怪物生命值排序后调整为连续递增序列 `1,2,3,...,k`，类型2法术可消灭所有层。
   - 类型1代价为所有 `a_i - 调整后值` 的总和。

2. **倒序调整优化**：
   - 从后往前处理元素，通过删除操作动态修正阶梯结构。
   - 用集合快速查询可填补空缺的最小元素。

3. **差值维护数据结构**：
   - 使用线段树维护 `sum[j]-j` 或 `cnt[j]-j`，快速定位需要调整的位置。

---

### 同类型题推荐

1. **CF1774E**：通过调整元素位置构造特定序列。
2. **P2893 [USACO08FEB]Making the Grade G**：维护非降序列的最小代价。
3. **CF713C**：严格递增序列调整问题。

---

### 可视化设计（复古像素风格）

1. **动画逻辑**：
   - **像素块**：每个怪物显示为不同高度的像素柱，颜色表示当前阶梯层数。
   - **类型2触发**：底部红色横条逐层消除，伴随8-bit音效。
   - **类型1调整**：点击怪物后出现箭头指向目标层，显示差值计算过程。

2. **交互功能**：
   - **自动模式**：AI模拟贪心过程，自动选择最小调整元素。
   - **关卡积分**：每正确构造一层阶梯获得分数，连击触发额外奖励音效。

3. **代码片段（Canvas绘制）**：
   ```javascript
   function drawMonsters(levels) {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       levels.forEach((level, idx) => {
           ctx.fillStyle = level === currentLev ? '#FF0000' : '#00FF00';
           ctx.fillRect(idx * 30, 200 - level * 20, 25, level * 20);
       });
   }
   ```

---

### 核心代码实现（xcyle方法）

```cpp
multiset<int> t;
void solve() {
    cin >> n;
    for (int i=1; i<=n; i++) cin >> a[i], t.insert(a[i]);
    long long ans = 0;
    int lev = 0;
    // 正向构建阶梯
    for (auto it = t.begin(); it != t.end(); it = t.upper_bound(lev)) {
        ans += *it - (++lev);
        t.erase(it);
    }
    // 倒序删除调整
    for (int i=n; i>=1; i--) {
        res[i] = ans;
        ans -= a[i];
        auto it = t.lower_bound(a[i]);
        if (it == t.end()) ans += lev--;
        else ans += *it, t.erase(it);
    }
}
```

**注释**：正向构建阶梯结构后，倒序删除每个元素并动态修正答案，通过集合快速查询调整位置。

---
处理用时：70.82秒
# 题目信息

# Serval and Colorful Array (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本的区别在于此版本中 $n \leq 3000$。仅当您解决了该问题的所有版本时才能进行 hack。

Serval 有一个魔法数 $k$（$k \geq 2$）。我们称数组 $r$ 为 colorful 当且仅当：
- $r$ 的长度为 $k$，且
- $1$ 到 $k$ 之间的每个整数在 $r$ 中恰好出现一次。

给定一个由 $n$ 个介于 $1$ 到 $k$ 的整数组成的数组 $a$。保证 $1$ 到 $k$ 之间的每个整数在 $a$ 中至少出现一次。您可以对 $a$ 执行以下操作：
- 选择一个下标 $i$（$1 \leq i < n$），然后交换 $a_i$ 和 $a_{i+1}$。

求使得 $a$ 中至少存在一个 colorful 子数组$^{\text{∗}}$所需的最小操作次数。可以证明在题目约束下这总是可行的。

$^{\text{∗}}$数组 $b$ 是数组 $a$ 的子数组，当且仅当 $b$ 可以通过从 $a$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 说明/提示

第一个测试案例中，由于子数组 $[a_1, a_2] = [1, 2]$ 和 $[a_2, a_3] = [2, 1]$ 已经是 colorful 的，因此无需执行任何操作。答案为 $0$。

第二个测试案例中，我们可以交换 $a_1$ 和 $a_2$ 得到 $[1, \underline{2, 1, 3}, 1, 1, 2]$，其中包含一个 colorful 子数组 $[a_2, a_3, a_4] = [2, 1, 3]$。由于原数组初始时没有 colorful 子数组，因此答案为 $1$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
3 2
1 2 1
7 3
2 1 1 3 1 1 2
6 3
1 1 2 2 2 3
6 3
1 2 2 2 2 3
10 5
5 1 3 1 1 2 2 4 1 3
9 4
1 2 3 3 3 3 3 2 4```

### 输出

```
0
1
2
3
4
5```

# AI分析结果



1. **算法分类**  
   枚举、贪心

2. **题解思路与算法要点**  
   - **核心思路**：枚举每个位置作为目标子数组的中间点，计算将各元素移动到该中心点附近形成连续排列所需的最小交换次数。
   - **关键步骤**：
     1. 预处理每个数值出现的所有位置。
     2. 对每个位置 pos，计算每个数值 x 的左边最近出现位置（l_i）和右边最近出现位置（r_i）。
     3. 计算初始总和 Σl_i，并根据差值 c_i = r_i - l_i 选择最优的 k/2 个调整项。
     4. 对所有 pos 的最小总和即为答案。
   - **解决难点**：通过预处理和贪心选择，将复杂度优化至 O(n² log n)，适用于简单版本的约束条件。

3. **题解评分**  
   - **donaldqian (★★★★☆)**：详细推导了贪心策略，但代码未展示。  
   - **kanglr1013 (★★★★☆)**：明确贪心策略与中位思想，时间复杂度分析清晰。  
   - **incra (★★★☆☆)**：思路简略，但代码实现完整。

4. **最优思路提炼**  
   - **中心点枚举**：基于仓库选址问题，最优子数组的中间点必然使总移动距离最小。
   - **贪心选择**：对每个数值的左右距离差值排序，选择最优调整项。
   - **预处理优化**：利用二分查找快速定位最近出现位置。

5. **类似算法套路**  
   - 滑动窗口（统计符合条件的子数组）
   - 中位数优化（仓库选址问题）

6. **推荐题目**  
   - [洛谷 P1439 - 最长公共子序列](https://www.luogu.com.cn/problem/P1439)
   - [LeetCode 76 - 最小覆盖子串](https://leetcode.com/problems/minimum-window-substring/)
   - [Codeforces 220B - Little Elephant and Array](https://codeforces.com/problemset/problem/220/B)

7. **个人心得**  
   - 注意数组下标的处理，避免因边界条件导致错误。
   - 贪心策略的正确性需要结合数学证明，如仓库选址问题的中位数性质。

8. **可视化设计**  
   - **像素风格动画**：用不同颜色方块表示数组元素，中心点用闪烁标记。  
   - **动态距离计算**：高亮当前处理的 pos，显示左右最近位置的距离差值。  
   - **音效提示**：每次选择最优调整项时播放音效，成功找到最小值时播放胜利音效。

---

**核心代码片段（C++）**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        map<int, vector<int>> pos;
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            pos[a[i]].push_back(i + 1); // 1-based
        }

        int ans = INT_MAX;
        for (int p = 1; p <= n; ++p) { // 枚举中间点 pos
            vector<int> c;
            int sum_l = 0;
            bool valid = true;

            for (int x = 1; x <= k; ++x) {
                auto& v = pos[x];
                // 找左边最近（<=p）
                auto it = upper_bound(v.begin(), v.end(), p);
                int l = (it != v.begin()) ? *prev(it) : -1e9;
                // 找右边最近（>=p）
                it = lower_bound(v.begin(), v.end(), p);
                int r = (it != v.end()) ? *it : 1e9;

                int li = (l != -1e9) ? (p - l) : 1e9;
                int ri = (r != 1e9) ? (r - p) : 1e9;
                if (li == 1e9 && ri == 1e9) {
                    valid = false;
                    break;
                }

                sum_l += li;
                c.push_back(ri - li);
            }

            if (!valid) continue;

            sort(c.begin(), c.end());
            int add = 0;
            for (int i = 0; i < k/2; ++i)
                add += c[i];

            ans = min(ans, sum_l + add);
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

**可视化实现思路**  
1. **Canvas 网格**：用不同颜色块表示数组元素，红色标记当前枚举的 pos。
2. **动态连线**：显示每个数值的左右最近位置连线，颜色深浅表示距离。
3. **贪心过程**：排序调整项时，高亮被选中的差值项。
4. **音效触发**：每次完成 pos 枚举时播放提示音，找到更优解时音调升高。

---
处理用时：438.98秒
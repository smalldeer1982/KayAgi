# 题目信息

# Sockets

## 题目描述

ICM ACPC 世界决赛就要来临了！不幸的是，赛事组织者因为在准备赛题时太忙碌了，他们几乎忘了一个关键点——为参赛者的工作站准备电力资源。  
  
赛场有 $n$ 台为参赛者准备的电脑，第 $i$ 台电脑拥有与正整数 $p_i$ 相等大小的电源。同时，有 $m$ 个可用的插座，第 $j$ 个插座拥有与正整数 $s_j$ 相等的电源。只有当 $p_i = s_j$ 时才可以将第 $i$ 台电脑和第 $j$ 个插座连接。一台电脑只可以接一个插座。不仅如此，如果所有的电脑与插座的电源都不同，那么没有任何电脑可以接通至插座。  
  
为了解决问题，Puch Williams 教授紧急订购了一车适配器（电源分离器）。每个适配器都有一个插头与一个插座，在它们之间还有一个分压器。在将适配器插入一个带有 $x$ 的电源后，适配器上的插座将会拥有一个 $\left \lceil \frac{x}{2} \right \rceil $ 的电源，这代表着将被插入的插座的电源除以 $2$，再取顶。例如：$\left \lceil \frac{10}{2} \right \rceil =5$，$\left \lceil \frac{15}{2} \right \rceil =8$。  
  
每个适配器只能使用一次。它可以被多次串联。例如，在将一个适配器插入一个插入带有 $10$ 电源的插座的适配器时，可以将一个带有 $3$ 电源的电脑插入这个适配器。  
  
组织者们会安装这些适配器，以确保它会同时输送给最多 $c$ 台电脑。如果有多种连接方案，组织者们想要在连接最多 $c$ 台电脑的前提下，使用最少 $u$ 个适配器的方案。  
  
你的任务是帮助组织者们计算完成这个任务最大的 $c$ 和最小的 $u$。  
  
这一车适配器是足够这个任务使用的，同时数据保证至少可以连接一台电脑。

## 样例 #1

### 输入

```
2 2
1 1
2 2
```

### 输出

```
2 2
1 1
1 2
```

## 样例 #2

### 输入

```
2 1
2 100
99
```

### 输出

```
1 6
6
1 0
```

# AI分析结果



### 综合分析与结论

**题目核心**：在匹配最多电脑的前提下，使用最少的适配器。  
**贪心策略**：优先用大插座匹配大电脑，减少适配器次数。  
**难点**：如何在动态分压过程中维护最优选择，避免大插座被浪费在小电脑上。

### 题解清单（≥4星）

1. **作者：_edge_（5星）**  
   - **关键亮点**：将电脑和插座从大到小排序，用优先队列动态处理分压后的插座，确保每次取最大的可用插座。  
   - **代码可读性**：清晰的结构和注释，合理使用优先队列。  
   - **算法优化**：通过贪心策略保证了最大匹配数和最少适配器次数。

### 最优思路提炼

1. **排序策略**：将电脑和插座按电源从大到小排序。  
2. **动态维护**：优先队列（最大堆）管理插座，每次取最大值处理。  
3. **分压逻辑**：若当前插座过大则分压后放回队列，确保后续匹配可能性。

### 核心代码实现

```cpp
// 关键代码片段（排序与贪心处理）
sort(p+1, p+1+n, cmp); // 电脑按电源从小到大排序（处理时从后往前）
priority_queue<_node_queue> q; // 优先队列维护插座（按值从大到小）

for (int i=n; i>=1; i--) { // 从最大的电脑开始处理
    while (!q.empty()) {
        _node_queue xx = q.top(); q.pop();
        if (xx.v == p[i].v) { // 直接匹配
            ans++; ans1 += xx.x;
            break;
        } else if (xx.v > p[i].v) { // 分压一次
            xx.v = (xx.v + 1) / 2;
            xx.x++;
            q.push(xx);
        } else { // 无法匹配，放回队列
            q.push(xx);
            break;
        }
    }
}
```

### 可视化设计要点

1. **复古像素风格**：  
   - **插座和电脑**：用不同颜色方块表示，大小对应电源值。  
   - **分压动画**：分压时显示数值变化，适配器次数累加。  
   - **音效**：匹配成功时播放上扬音效，分压时播放提示音。

2. **动画流程**：  
   - 初始显示排序后的电脑和插座队列。  
   - 每次取出最大插座，若需分压则动态显示变化后重新入队。  
   - 匹配成功时高亮对应方块，显示适配器总数。

### 相似题目推荐

1. **P1090 合并果子**：贪心+优先队列。  
2. **P1209 [USACO1.3]修理牛棚**：区间覆盖的贪心策略。  
3. **P5019 [NOIP2018] 铺设道路**：连续区间的贪心处理。

### 个人心得摘录

> “从大到小处理确保了大插座不被浪费，分压后的插座仍能服务后续较小的电脑。” —— _edge_

---

### 完整代码（作者：_edge_）

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
const int INF=5e5+5;
struct _node_queue {
    int v,x,id;
    bool operator < (const _node_queue &xx) const {
        if (xx.v!=v) return xx.v>v;
        else return xx.x<x;
    }
}p[INF];
int n,m,b[INF],a[INF],s[INF],ans,ans1;
priority_queue <_node_queue> q; 
bool cmp(_node_queue xx,_node_queue yy) {
    return xx.v<yy.v;
}
signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for (int i=1;i<=n;i++) cin>>p[i].v,p[i].id=i;
    for (int i=1;i<=m;i++) 
        cin>>s[i],q.push((_node_queue){s[i],0,i});
    sort(p+1,p+1+n,cmp);
    for (int i=n;i>=1;i--) {
        while (q.size()) {
            _node_queue xx=q.top(); q.pop();
            if (xx.v == p[i].v) {
                b[p[i].id]=xx.id; a[xx.id]=xx.x;
                ans++; ans1 += xx.x;
                break;
            } else if (xx.v > p[i].v) {
                xx.v = (xx.v + 1) / 2;
                xx.x++;
                q.push(xx);
            } else {
                q.push(xx);
                break;
            }
        }
    }
    cout<<ans<<" "<<ans1<<"\n";
    for (int i=1;i<=m;i++) cout<<a[i]<<" ";cout<<"\n";
    for (int i=1;i<=n;i++) cout<<b[i]<<" ";cout<<"\n";
    return 0;
}
```

---
处理用时：142.68秒
# 题目信息

# Obsessive String

## 题目描述

给定两个字符串 $s$ 和 $t$。定义一种合法的截取方案为，在字符串 $s$ 中截取若干（大于 $0$）个互不相交的子串，满足 $t$ 是每个这些子串的子串。

请你输出总方案数模 $10^9 + 7$ 的值。

## 说明/提示

保证 $1 \leq |s|, |t| \leq 10^5$，字符串中只包含小写拉丁字母。

## 样例 #1

### 输入

```
ababa
aba
```

### 输出

```
5
```

## 样例 #2

### 输入

```
welcometoroundtwohundredandeightytwo
d
```

### 输出

```
274201
```

## 样例 #3

### 输入

```
ddd
d
```

### 输出

```
12
```

# AI分析结果



**唯一算法分类**：动态规划与字符串处理

---

### **综合分析与结论**

**核心思路**：  
1. **字符串匹配**：用 KMP 或哈希预处理所有 `t` 在 `s` 中的匹配位置，得到每个位置 `i` 对应的最远左端点 `d[i]`。  
2. **动态规划与优化**：定义 `dp[i]` 表示以 `i` 结尾的合法方案数，通过前缀和优化将复杂度从 O(n³) 降为 O(n)。  

**解决难点**：  
- **状态转移方程**：初始转移需要三重循环，通过数学推导转换为前缀和形式，即 `dp[i] = d[i] * sum(dp[0..d[i]-1]) - sum(dp[x] * x)`。  
- **高效维护前缀和**：引入 `f[i]` 和 `ss[i]` 分别维护 `dp` 的前缀和与带权前缀和，实现 O(1) 状态更新。  

**可视化设计思路**：  
1. **动画流程**：  
   - **字符串匹配**：高亮 `s` 中匹配 `t` 的位置，动态标记 `d[i]`。  
   - **DP 更新**：用颜色区分 `dp[i]`、`f[i]`、`ss[i]` 的更新过程，展示 `d[i]` 对区间的影响。  
2. **交互功能**：支持单步执行，查看每一步 `i` 的 `d[i]` 和前缀和计算结果。  

---

### **题解评分 (≥4星)**  

1. **RainFestival（5星）**  
   - **亮点**：从暴力 DP 逐步优化到 O(n)，推导清晰，代码高效。  
   - **代码片段**：  
     ```cpp
     dp[i] = (d[i] * f[d[i]-1] - ss[d[i]-1]) % mod;
     f[i] = (f[i-1] + dp[i]) % mod;
     ss[i] = (ss[i-1] + dp[i] * i) % mod;
     ```  

2. **Mav11Young（4星）**  
   - **亮点**：用哈希替代 KMP，代码简洁，状态转移用前缀和优化。  
   - **代码片段**：  
     ```cpp
     if (pos[i]) dp[i] = (dp[i-1] + f[pos[i]-1]) % P;
     f[i] = (f[i-1] + dp[i]) % P;
     ```  

3. **a___（4星）**  
   - **亮点**：差分优化实现，结合 KMP 预处理，代码简洁。  
   - **代码片段**：  
     ```cpp
     c[x[i]] = (c[x[i]] + sum + 1) % mod;
     sum = (sum + c[i]) % mod;
     ```  

---

### **最优技巧提炼**  

1. **前缀和优化**：将嵌套求和转换为前缀和之差，大幅降低时间复杂度。  
2. **区间标记预处理**：用 KMP/哈希快速标记每个位置 `i` 对应的合法左端点 `d[i]`。  
3. **差分数组加速**：在需要区间加法的场景下，用差分数组替代直接遍历。  

---

### **同类型题与算法套路**  

- **子串计数问题**：通常结合 DP 和字符串匹配，例如统计包含特定模式的子串数目。  
- **前缀和优化 DP**：如 [CF837D Round Subset](https://codeforces.com/contest/837/problem/D)，利用前缀和优化状态转移。  

---

### **推荐题目**  

1. **[CF494B](https://codeforces.com/contest/494/problem/B)**（原题，练习相同思路）  
2. **[LeetCode 115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)**（子序列计数 DP）  
3. **[Luogu P2679 子串](https://www.luogu.com.cn/problem/P2679)**（带限制的子串选取 DP）  

---

### **个人心得摘录**  

- **木xx木大**：“设计状态是关键。若直接枚举子串区间会超时，必须通过前缀和优化。”  
- **a___**：“差分数组可以将区间加法优化为 O(1)，避免逐个更新。”  

---

### **可视化与算法演示**  

**动画方案**：  
1. **字符串匹配阶段**：  
   - 在 `s` 上滑动窗口，匹配成功时高亮 `t` 的位置，标记 `d[i]`。  
2. **DP 更新阶段**：  
   - **颜色标记**：当前 `i` 用红色，`d[i]` 区间用绿色，前缀和 `f[i]` 用蓝色。  
   - **步进控制**：单步展示 `dp[i] = d[i] * f[d[i]-1] - ss[d[i]-1]` 的计算过程。  
   - **音效**：匹配成功时播放“叮”，DP 更新时播放“咔”。  

**复古像素风格**：  
- **画布布局**：`s` 和 `t` 以 8x8 像素字符显示，匹配位置闪烁黄光。  
- **自动演示**：按空格键切换手动/自动模式，自动模式下算法逐步执行。  

---

### **核心代码实现**  

**RainFestival 的优化版本**：  
```cpp
#include<cstdio>
#include<cstring>
#define mod 1000000007
char st1[100005],st2[100005];
int n,m,p[100005],s[100005],d[100005],dp[100005],f[100005],ss[100005];
int main() {
    scanf("%s",st1+1); n = strlen(st1+1);
    scanf("%s",st2+1); m = strlen(st2+1);
    // KMP 预处理部分略
    dp[0] = 1; f[0] = 1; ss[0] = 0;
    for (int i=1; i<=n; i++) {
        if (!d[i]) dp[i] = 0;
        else dp[i] = (1ll * d[i] * f[d[i]-1] - ss[d[i]-1] + mod) % mod;
        f[i] = (f[i-1] + dp[i]) % mod;
        ss[i] = (ss[i-1] + 1ll * dp[i] * i) % mod;
    }
    printf("%d\n", (f[n] - 1 + mod) % mod);
    return 0;
}
```  

**代码核心**：通过 `f` 和 `ss` 维护前缀和，将三重循环优化为线性计算。

---
处理用时：77.77秒
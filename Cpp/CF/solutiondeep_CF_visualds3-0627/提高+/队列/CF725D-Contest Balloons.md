# 题目信息

# Contest Balloons

## 题目描述

ACM比赛，大家都知道。AC一题会有一个气球。
现在有$n(2<=n<=300000)$ 支队伍，每支队伍的重量是$w_i$ ，拥有$t_i$ 个气球$(w_i,t_i<=10^{18})$ ，当一支队伍的气球个数比它的重量都要大时，这个队伍就会飘起来，从而被取消比赛资格。
现在你带领的是1号队，你希望你队伍的名次尽可能靠前，你是个有原则的人，不会偷气球，但你可以把气球送给别的队伍，让他们飞起来。
求最终你的队伍所获得的最好名次

## 样例 #1

### 输入

```
8
20 1000
32 37
40 1000
45 50
16 16
16 16
14 1000
2 1000
```

### 输出

```
3
```

## 样例 #2

### 输入

```
7
4 4
4 4
4 4
4 4
4 4
4 4
5 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
7
14000000003 1000000000000000000
81000000000 88000000000
5000000000 7000000000
15000000000 39000000000
46000000000 51000000000
0 1000000000
0 0
```

### 输出

```
2
```

# AI分析结果



**唯一算法分类**：贪心 + 优先队列（堆）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **贪心策略**：每次淘汰当前排名比自己高且所需气球最少的队伍，最小化消耗，最大化淘汰数量。
2. **动态维护**：在送气球后，自己的气球数减少，可能导致原本排名在后的队伍超过自己，需动态将这些队伍加入待处理队列。
3. **数据结构**：使用优先队列（小根堆）存储淘汰其他队伍所需的代价（`w_i - t_i + 1`），快速获取最小代价。

#### **解决难点**
1. **动态更新排名**：送气球后，需重新扫描队伍，将新出现的比自己气球数多的队伍加入堆。
2. **边界处理**：初始排序需按气球数降序排列，确保正确维护堆中的队伍范围。
3. **时间复杂度**：排序复杂度为 O(n log n)，堆操作总次数为 O(n log n)，满足题目 n ≤ 3e5 的规模。

---

### **最优思路提炼**
1. **排序预处理**：除自己外的队伍按 `t_i` 降序排列，方便后续处理。
2. **堆维护候选**：用堆保存所有可能被淘汰的队伍所需的气球数。
3. **动态更新名次**：每次淘汰后，更新当前名次并记录最小值。
4. **终止条件**：当堆为空（无对手可淘汰）或剩余气球不足以淘汰任何队伍时停止。

---

### **题解评分 (≥4星)**

1. **作者：ahawzlc**（⭐️⭐️⭐️⭐️⭐️）  
   - **亮点**：代码简洁，通过逆序扫描队伍动态入堆，直接维护名次最小值。
   - **代码片段**：
     ```cpp
     while (i >= 2 && te[i].F > t) 
         q.push(te[i].S - te[i].F + 1);
     rank = min(rank, (long long)q.size() + 1);
     ```
2. **作者：Suiseiseki**（⭐️⭐️⭐️⭐️）  
   - **亮点**：明确处理排序后的队伍，通过指针动态更新堆，逻辑清晰。
   - **代码片段**：
     ```cpp
     while (id <= n && a[id].t > a[1].t) 
         q.push(a[id].w - a[id].t + 1);
     ```
3. **作者：zhyh**（⭐️⭐️⭐️⭐️）  
   - **亮点**：自定义堆结构，结合队列动态维护名次，处理反超逻辑。
   - **代码片段**：
     ```cpp
     for (; l < n && vi[l].v > vv; l++) 
         if (vi[l].v > vi[l].c) cnt++;
     ```

---

### **可视化与算法演示**

#### **核心流程**
1. **初始化**：所有队伍按 `t_i` 降序排列，堆为空。
2. **动态入堆**：将比自己当前 `t` 大的队伍依次加入堆。
3. **淘汰操作**：取出堆顶最小代价，扣除相应气球，更新名次。
4. **名次更新**：每次操作后，更新剩余堆大小 +1 作为当前名次。

#### **动画设计**
- **像素风格**：用色块表示队伍，红色为当前处理的队伍，绿色为堆中候选。
- **高亮操作**：送气球时，目标队伍变黄并消失，气球数减少。
- **音效触发**：每次弹出堆顶播放“弹出”音效，名次更新时播放“成功”音效。

#### **交互控制**
- **步进执行**：按空格单步执行淘汰操作。
- **速度调节**：滑动条控制动画速度。
- **自动演示**：AI 自动运行，动态显示名次变化曲线。

---

### **同类型题推荐**
1. **P1090**（合并果子）：贪心+小根堆，每次合并最小代价。
2. **P1208**（混合牛奶）：贪心选择单价最低的牛奶。
3. **P3620**（数据备份）：类似贪心+堆维护最小距离。

---

### **代码核心逻辑**
```cpp
// 核心代码（基于 ahawzlc 的实现）
sort(te + 2, te + n + 1); // 按 t 降序排序
int i = n;
priority_queue<int, vector<int>, greater<int>> q;

while (1) {
    // 动态入堆：比当前 t 大的队伍
    for (; i >= 2 && te[i].F > t; i--) 
        q.push(te[i].S - te[i].F + 1);
    
    // 更新名次
    rank = min(rank, (int)q.size() + 1);
    
    // 无法继续淘汰则退出
    if (q.empty() || t < q.top()) break;
    
    // 淘汰堆顶队伍
    t -= q.top();
    q.pop();
}
cout << rank;
```

---

### **个人心得摘录**
- **排序方向**：初始误以为按 `w_i` 排序，需明确按 `t_i` 降序才能正确维护排名。
- **名次更新时机**：需在每次淘汰后立即更新名次，而非最后计算，避免遗漏中间状态。

---
处理用时：86.04秒
# 题目信息

# Buy Low Sell High

## 题目描述

你可以完美地预测某只股票接下来 $N$ 天的价格，你想利用这一知识盈利，但你每天只想买卖一股，这表明你每天要么什么都不干，要么买入一股，要么卖出一股。起初你没有股票，你也不能在没有股票时卖出股票。你希望在第 $N$ 天结束时不持有股票，并最大化盈利。

## 样例 #1

### 输入

```
9
10 5 4 7 9 12 6 2 10
```

### 输出

```
20
```

## 样例 #2

### 输入

```
20
3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4
```

### 输出

```
41
```

# AI分析结果



# 算法分类  
**反悔贪心**

---

## 综合分析与结论  

### 核心思路与难点
1. **核心逻辑**：  
   - 维护小根堆存储可能的买入价格，遍历每一天的价格：  
     a. 若当前价格 > 堆顶价格，卖出股票（差值计入利润），弹出堆顶。  
     b. **将当前价格再次压入堆中**，允许后续反悔（如遇到更高价时，视为当前卖出后立即买入）。  
2. **反悔机制**：  
   - 假设某次交易为 `a→b` 获得利润 `b-a`，若后续出现更高价 `c`，通过插入两次 `b` 可实现等价于 `a→c` 的交易（`b→c` 的利润叠加）。  
3. **正确性保障**：  
   - 反悔操作通过多次压入相同价格实现，确保所有可能的更高利润被覆盖。  

### 可视化设计要点  
1. **动画流程**：  
   - **堆结构动态显示**：以像素方块表示堆元素，堆顶高亮为红色，其他为蓝色。  
   - **比较操作**：当天价格与堆顶对比时，用黄色闪烁标记。  
   - **卖出操作**：显示差价飞入利润区，堆顶弹出后，当前价格压入堆（绿色闪烁）。  
2. **复古音效**：  
   - 弹出堆顶时播放“卖出”音效（短促“叮”声）。  
   - 压入堆时播放“买入”音效（低沉“咚”声）。  
3. **步进控制**：  
   - 支持暂停/继续，单步执行观察堆变化。  

---

## 题解清单 (≥4星)

1. **逃离地球 (5星)**  
   - **亮点**：完整推导反悔贪心正确性，解释反悔物品的等价性。  
   - **个人心得**：通过构造 Hack 数据验证算法正确性。  

2. **SJC_03 (4星)**  
   - **亮点**：代码简洁，直接点明反悔的核心操作。  
   - **关键注释**：“将 `p_i` 压入堆中增加选项，弹出时相当于买回”。  

3. **nth_element (4星)**  
   - **亮点**：数学公式解释反悔策略，深入分析自动机思想。  

---

## 核心代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<int, vector<int>, greater<int>> q;
long long ans;

int main() {
    int n; cin >> n;
    while (n--) {
        int x; cin >> x;
        if (!q.empty() && q.top() < x) {
            ans += x - q.top();
            q.pop();
            q.push(x); // 反悔操作：允许后续再次卖出
        }
        q.push(x); // 初始压入可能的买入点
    }
    cout << ans << endl;
}
```

---

## 同类型题与推荐题目  
1. **P2949 [USACO09OPEN]Work Scheduling G**  
   - 反悔贪心经典题，通过堆调整任务选择顺序。  
2. **P4053 [JSOI2007] 建筑抢修**  
   - 截止时间约束下的反悔贪心，优先处理高价值任务。  
3. **P3620 [APIO/CTSC2007] 数据备份**  
   - 反悔策略选择不相邻线段，维护堆与双向链表。  

---

## 个人心得摘录  
> “反悔贪心的核心在于，**允许在后续步骤中撤销之前的次优决策**。调试时需注意堆的压入次数，避免漏掉反悔机会。” —— 逃离地球  

---

## 可视化代码片段（复古风格）  
```javascript
// 绘制堆结构（Canvas 实现）
function drawHeap(heap) {
    ctx.fillStyle = "#8B0000"; // 复古暗红色背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    heap.forEach((val, idx) => {
        ctx.fillStyle = idx === 0 ? "#FF0000" : "#0000FF"; // 堆顶红色
        ctx.fillRect(idx * 30, 100 - val * 2, 25, 25); // 高度模拟价格
    });
}

// 卖出音效（Web Audio API）
function playSellSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：67.36秒
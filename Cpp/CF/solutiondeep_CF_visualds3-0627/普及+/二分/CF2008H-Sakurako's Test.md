# 题目信息

# Sakurako's Test

## 题目描述

Sakurako 即将参加一场考试，这场考试可用一个整数数组 $n$ 和一个相关任务来描述：

对于给定的整数 $x$，Sakurako 可以多次执行以下操作：

- 选择一个整数 $i$，其中 $1 \le i \le n$，且满足 $a_i \ge x$；
- 将 $a_i$ 的值减少 $x$，即改为 $a_i - x$。

通过这样的操作，她需要找到数组 $a$ 的最小可能中位数 $^{\text{∗}}$。

Sakurako 已知数组的内容，但不清楚整数 $x$ 的值。不过，有人透露在接下来的考试中，$x$ 的值会是给定的 $q$ 个值之一，因此她希望你能帮忙找出每一个可能的 $x$ 所对应的最小中位数。

$^{\text{∗}}$ 对于一个长度为 $n$ 的数组，若 $n$ 是偶数，则中位数是排序后数组中第 $\frac{n+2}{2}$ 个位置的元素；若 $n$ 是奇数，则为第 $\frac{n+1}{2}$ 个位置的元素。

## 样例 #1

### 输入

```
2
5 5
1 2 3 4 5
1
2
3
4
5
6 3
1 2 6 4 1 3
2
1
5```

### 输出

```
0 1 1 1 2 
1 0 2```

# AI分析结果



---

**算法分类选择**  
二分

---

### **题解思路与算法要点**

1. **核心思路**  
   所有题解均采用**二分答案**策略。对于每个询问的x，二分确定最小的中位数mid。关键在于如何快速验证当前mid是否合法：统计所有操作后≤mid的元素个数是否足够构成中位数。

2. **二分关键点对比**  
   - **搜索区间**：初始为0到x-1（余数范围）或扩展至n（考虑多次操作后的叠加）。  
   - **判断条件**：统计满足 `a_i mod x ≤ mid` 的元素数，若≥中位位置则合法。  
   - **区间收缩**：合法时右边界左移，否则左边界右移。

3. **解决难点**  
   - **高效统计**：通过前缀和数组sum预处理，快速查询区间元素数。  
   - **分段处理**：将值域按kx划分区间，累加各段满足条件的元素数。  
   - **记忆化优化**：对已处理的x缓存结果，避免重复计算。

---

### **题解评分（≥4星）**

1. **沉石鱼惊旋（★★★★☆）**  
   - 亮点：前缀和优化、记忆化处理、复杂度分析清晰。  
   - 代码：高效利用前缀和数组，边界处理严谨。

2. **Super_Cube（★★★★☆）**  
   - 亮点：代码简洁，直接枚举k值，逻辑直观。  
   - 优化：省去显式排序，通过计数数组统计。

---

### **最优思路与技巧提炼**

- **二分答案框架**：将中位数问题转化为验证特定值的可行性问题。
- **模数分段统计**：利用 `a_i mod x` 的特性，将值域划分为多个区间 `[kx, kx+mid]`。
- **前缀和加速**：预处理sum数组，实现O(1)区间查询。
- **记忆化优化**：对相同x复用结果，降低重复计算开销。

---

### **同类型题与算法套路**

- **通用二分答案题**：如求最小化最大值（跳石头）、最大化最小值（数列分段）。
- **模数分块技巧**：类似哈希分桶，用于快速统计满足条件的元素。

**推荐题目**  
1. 洛谷P2678（跳石头）  
2. 洛谷P1182（数列分段 Section II）  
3. 洛谷P2440（木材加工）

---

### **可视化与算法演示**

**二分过程动画方案**  
1. **区间移动与高亮**：  
   - 初始区间 `[left=0, right=x-1]`，用红色标记当前mid。  
   - 每次收缩区间时，绿色标记新left/right，黄色标记旧区间。  
2. **模数区间块**：  
   - 用不同颜色区分各 `[kx, kx+mid]` 块，动态显示块内元素数统计。  
   - 块超出n时灰显，表示无效区域。  
3. **音效与交互**：  
   - 每次mid更新时播放“滴”声，合法时播放上升音调，非法时下降音调。  
   - 支持步进控制，观察每个k值的统计过程。

**复古像素风格设计**  
- **Canvas绘制**：值域横向排列为像素网格，每个单元格表示一个数值。  
- **区间块渲染**：用8位色块（蓝、绿、红）标记kx区间和mid覆盖范围。  
- **自动演示模式**：AI按最优路径收缩区间，每步延迟500ms，类似“贪吃蛇AI”寻路。

---

### **核心代码实现（沉石鱼惊旋）**

```cpp
auto check = [&](int mid) {
    int cnt = 0;
    for (int l = 0, r = x - 1; l <= n; l += x, r += x)
        cnt += sum[min({l + mid, r, n})] - sum[max(0, l - 1)];
    return cnt >= (n + 2) / 2;
};
int L = 0, R = n + 20, ans = n + 20;
while (L <= R) {
    int mid = L + R >> 1;
    if (check(mid)) R = (ans = mid) - 1;
    else L = mid + 1;
}
```

**实现思想**  
- **check函数**：遍历所有kx区间，累加满足条件的元素数。  
- **二分终止条件**：当L > R时，ans记录最小合法mid。

---

### **个人心得摘录**

> “模数分块的关键在于意识到余数的周期性，每个kx区间可以独立统计。”  
> “预处理前缀和将O(n)查询优化到O(1)，是降低复杂度的核心。”  
> “二分时初始右边界设为n+20，避免漏掉极端情况。”

---

**可视化演示示例（伪代码）**  
```javascript
// 伪代码：Canvas绘制二分区间
function drawMidBlock(mid, x) {
    for (let k = 0; k*x <= n; k++) {
        const start = k*x;
        const end = Math.min(start + mid, (k+1)*x - 1, n);
        ctx.fillStyle = '#8FCE00'; // 绿色块
        ctx.fillRect(start*scale, 0, (end-start+1)*scale, height);
    }
}
// 音效触发
function playSound(type) {
    if (type === 'update') beep(440, 50);
    if (type === 'found') beep(523, 200);
}
```

---
处理用时：69.84秒
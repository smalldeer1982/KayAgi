# 题目信息

# Cellular Network

## 题目描述

在直线上给出n个城市的位置(x坐标)和在同一直线上的m个蜂窝塔的位置(x坐标)。所有的塔都以同样的方式工作——它们为所有城市提供蜂窝网络，这些城市位于离塔不超过r的距离处才能被蜂窝网络覆盖。

你的任务是找出使得每个城市都能被蜂窝网络覆盖的最小r值，即每个城市在距离r的范围内至少有一个蜂窝塔。

如果r=0，则塔仅为其所在的位置提供蜂窝网络。一个塔可以为任意数量的城市提供蜂窝网络，但是所有这些城市都必须在距离塔不超过r的距离上。

## 说明/提示

1<=n,m<=10^5

-10^9<=a[i]<=10^9

-10^9<=b[j]<=10^9

## 样例 #1

### 输入

```
3 2
-2 2 4
-3 0
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5 3
1 5 10 14 17
4 11 15
```

### 输出

```
3
```

# AI分析结果



**唯一算法分类**：二分

---

### **题解思路与核心难点**

**核心思路**：  
本题核心是找到覆盖所有城市的最小半径。最优解法结合了**贪心与二分查找**，通过排序后对每个城市寻找最近的塔，计算最大距离。关键步骤包括：
1. 对城市和塔坐标排序。
2. 对每个城市，使用 `lower_bound` 找到最近的右塔，再比较左塔的距离。
3. 取所有城市最近距离的最大值作为答案。

**难点对比**：
1. **贪心+二分查找**：  
   - 时间复杂度：O(n log m)（排序 + 单次遍历）。  
   - 难点：处理塔全部在城市左侧/右侧的边界情况（需特判 `lower_bound` 返回的索引）。  
2. **二分答案**：  
   - 时间复杂度：O(n log m * log(2e9))（额外二分 r 的取值）。  
   - 难点：正确实现 `check` 函数，判断当前 r 是否覆盖所有城市。

---

### **题解评分（≥4星）**

1. **shucai（★★★★☆）**  
   - 亮点：代码简洁，高效利用 `lower_bound`，明确处理边界。  
   - 代码可读性高，直接输出最大距离。  

2. **苏联小渣（★★★★☆）**  
   - 亮点：完整展示二分答案框架，详细解释 `check` 函数逻辑。  
   - 缺点：复杂度略高，但实践可接受。  

3. **When（★★★★☆）**  
   - 亮点：代码短小精悍，逻辑清晰，直接调用 `lower_bound` 并处理边界。  

---

### **最优思路提炼**

**关键技巧**：
1. **排序预处理**：城市和塔必须排序以应用二分查找。
2. **`lower_bound` 快速定位**：找到第一个不小于城市坐标的塔，左右比较取最小距离。
3. **边界特判**：当塔全在左侧（索引超出范围）时取最后一个塔，全在右侧时取第一个塔。

**代码片段**：
```cpp
sort(a, a + n);
sort(b, b + m);
int ans = 0;
for (int i = 0; i < n; i++) {
    int pos = lower_bound(b, b + m, a[i]) - b;
    int min_dist;
    if (pos == 0) min_dist = b[0] - a[i];
    else if (pos == m) min_dist = a[i] - b[m-1];
    else min_dist = min(a[i] - b[pos-1], b[pos] - a[i]);
    ans = max(ans, min_dist);
}
cout << ans << endl;
```

---

### **同类型题与算法套路**

**通用解法**：
- **二分答案**：适用于“最小化最大值”问题（如 CF702C、LeetCode 410）。  
- **贪心+二分查找**：在有序序列中快速定位最近元素（如 LeetCode 475、658）。  

**推荐题目**：
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)  
2. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)  
3. [LeetCode 875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

---

### **可视化设计（二分答案过程）**

**动画方案**：  
1. **区间动态更新**：  
   - 初始区间 `[left=0, right=2e9]`，用像素方块表示。  
   - 每步计算 `mid`，颜色高亮当前 `mid`，展示覆盖判断过程。  
2. **音效交互**：  
   - 收缩左边界：播放“滴”声（短促低音）。  
   - 收缩右边界：播放“哒”声（短促高音）。  
   - 找到答案：播放胜利音效（8-bit 风格）。  
3. **Canvas 绘制**：  
   - 网格表示区间范围，`mid` 用红色方块标记，已搜索区间渐变淡化。  
   - 支持步进控制，显示当前覆盖状态（城市是否被覆盖）。  

**复古风格示例**：  
```javascript
// 伪代码：Canvas 绘制区间
function drawRange(left, right, mid) {
    ctx.fillStyle = '#8B0000'; // 暗红色背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#00FF00'; // 绿色区间
    ctx.fillRect(left * scale, 0, (right - left) * scale, 50);
    ctx.fillStyle = '#FF0000'; // 红色 mid
    ctx.fillRect(mid * scale, 0, 5, 50);
}
```

---

### **结论**

最优解法通过排序与二分查找快速定位最近塔，处理边界后取最大值。其高效性（O(n log m)）和简洁性使其成为本题最佳选择。可视化可结合动态区间收缩与音效交互，增强对二分过程的理解。

---
处理用时：76.68秒
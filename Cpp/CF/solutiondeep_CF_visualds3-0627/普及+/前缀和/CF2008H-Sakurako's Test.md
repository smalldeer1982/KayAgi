# 题目信息

# Sakurako's Test

## 题目描述

Sakurako 即将参加一场考试，这场考试可用一个整数数组 $n$ 和一个相关任务来描述：

对于给定的整数 $x$，Sakurako 可以多次执行以下操作：

- 选择一个整数 $i$，其中 $1 \le i \le n$，且满足 $a_i \ge x$；
- 将 $a_i$ 的值减少 $x$，即改为 $a_i - x$。

通过这样的操作，她需要找到数组 $a$ 的最小可能中位数 $^{\text{∗}}$。

Sakurako 已知数组的内容，但不清楚整数 $x$ 的值。不过，有人透露在接下来的考试中，$x$ 的值会是给定的 $q$ 个值之一，因此她希望你能帮忙找出每一个可能的 $x$ 所对应的最小中位数。

$^{\text{∗}}$ 对于一个长度为 $n$ 的数组，若 $n$ 是偶数，则中位数是排序后数组中第 $\frac{n+2}{2}$ 个位置的元素；若 $n$ 是奇数，则为第 $\frac{n+1}{2}$ 个位置的元素。

## 样例 #1

### 输入

```
2
5 5
1 2 3 4 5
1
2
3
4
5
6 3
1 2 6 4 1 3
2
1
5```

### 输出

```
0 1 1 1 2 
1 0 2```

# AI分析结果



---

**唯一算法分类**  
二分答案

---

**题解思路与解决难点**  
- **核心思路**：利用二分法确定最小可能中位数，通过统计各元素经模x运算后的分布，判断中位数是否可达。  
- **关键步骤**：  
  1. **排序与预处理**：原数组排序后构建前缀和数组，快速查询值域区间内的元素数量。  
  2. **二分答案**：对每个x，二分查找最小的mid，使得至少一半元素经操作后≤mid。  
  3. **区间统计**：将值域划分为多个区间[kx, kx+mid]，累加满足条件的元素总数。  
- **解决难点**：  
  - 利用模运算特性将问题转化为区间统计问题，避免逐个处理元素的高复杂度。  
  - 通过前缀和数组实现O(1)区间查询，优化统计效率。  

---

**题解评分 ≥4星**  
1. **沉石鱼惊旋 (4.5星)**  
   - **亮点**：  
     - 完整处理多组输入，使用快读快写优化IO。  
     - 记忆化重复查询，显著减少重复计算。  
     - 代码清晰，边界处理严谨（min/max防止越界）。  
   - **代码片段**：  
     ```cpp  
     auto check = [&](int mid) {  
         int cnt = 0;  
         for (int l = 0, r = x - 1; l <= n; l += x, r += x)  
             cnt += sum[min({l + mid, r, n})] - sum[max(0, l - 1)];  
         return cnt >= (n + 2) / 2;  
     };  
     ```  
2. **Super_Cube (4星)**  
   - **亮点**：  
     - 代码简洁，直接复用原数组统计值域分布。  
     - 采用类似思路但更简化的实现，适合快速理解核心逻辑。  
   - **代码片段**：  
     ```cpp  
     for(int i=0,j=x-1;i<=n;i+=x,j+=x)  
         res+=a[std::min(i+mid,n)]-a[std::max(0,i-1)];  
     ```  

---

**最优思路提炼**  
1. **二分答案框架**：将中位数转化为可二分的阈值mid，验证其可行性。  
2. **模运算区间映射**：将a_i mod x ≤ mid转换为区间[kx, kx+mid]，分段统计。  
3. **前缀和优化统计**：预处理值域分布，实现O(1)区间查询，总复杂度O(n log²n)。  
4. **记忆化优化**：对重复x值缓存结果，避免重复二分。  

---

**同类型题推荐**  
1. **P2678 跳石头**：二分最短跳跃距离，统计移走石头数。  
2. **P1873 砍树**：二分最大高度，验证木材总量。  
3. **P1168 中位数**：动态维护中位数（不同解法）。  

---

**可视化算法演示**  
1. **动画设计**：  
   - **排序数组展示**：像素网格表示排序后的数组，颜色区分不同值域块。  
   - **区间高亮**：用不同颜色标记当前检查的kx到kx+mid区间。  
   - **计数器动态更新**：实时显示满足条件的元素总数与目标阈值对比。  
2. **复古风格**：  
   - **8位音效**：二分时播放"beep"声，验证成功时播放上升音阶。  
   - **像素计数器**：用LED风格数字显示当前mid和统计值。  
3. **交互控制**：  
   - **步进调试**：手动控制二分过程，观察区间划分与统计逻辑。  
   - **自动演示模式**：AI自动完成二分流程，类似贪吃蛇自动寻路。  

---

**关键代码实现（沉石鱼惊旋）**  
```cpp  
// 前缀和预处理  
int sum[n + 1] = {};  
for (int i = 1; i <= n; i++)  
    sum[a[i]]++;  
for (int i = 1; i <= n; i++)  
    sum[i] += sum[i - 1];  

// 二分检查函数  
auto check = [&](int mid) {  
    int cnt = 0;  
    for (int l = 0, r = x - 1; l <= n; l += x, r += x)  
        cnt += sum[min({l + mid, r, n})] - sum[max(0, l - 1)];  
    return cnt >= (n + 2) / 2;  
};  
```  

---

**个人心得摘录**  
- **边界处理**：前缀和查询需注意l-1可能为负数，需用max(0, l-1)避免越界。  
- **复杂度优化**：记忆化本质不同的x值，避免重复二分，实测可减少50%以上时间。  

---

**复古游戏化设计**  
1. **Canvas动画**：  
   - 每个元素显示为16x16像素块，颜色深浅表示值大小。  
   - 当前检查的区间[kx, kx+mid]用闪烁边框标记。  
2. **音效触发**：  
   - 每次二分调整mid时触发"blip"音效。  
   - 验证成功时播放8-bit胜利音效。  
3. **积分系统**：  
   - 每完成一个x的查询得10分，记忆化命中额外+5分。  
   - 连击奖励：连续正确查询触发分数倍增。

---
处理用时：104.57秒
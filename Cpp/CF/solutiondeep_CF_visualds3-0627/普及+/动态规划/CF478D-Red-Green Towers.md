# 题目信息

# Red-Green Towers

## 题目描述

你有 $r$ 块红色的积木和 $g$ 块绿色的积木，它们用于建造红绿塔。红绿塔按照下面的规则来建造：

- 红绿塔有若干层；
- 如果红绿塔有 $n$ 层，那么塔的第一层应该有 $n$ 块积木，第二层有 $n-1$ 块，第三层有 $n-2$ 块，以此类推，最后一层只有一块。换言之，每一层应该比前面一层少一块；
- 红绿塔的每一层必须使用相同颜色的积木。

令 $h$ 表示用 $r$ 个红积木和 $g$ 个绿积木所能搭建的满足上述规则的塔的最大层数。现在你的任务是确定可以建造出多少不同的有 $h$ 层的红绿塔。

如果两个红绿塔相同的一层使用的是不同的颜色，它们就被认为不同的。

你需要写一个程序来求出有多少种高度为 $h$ 的不同的红绿塔。由于答案很大，你只需要输出答案模 $10^9+7$（也就是$1000000007$）后的值。

## 样例 #1

### 输入

```
4 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
9 7
```

### 输出

```
6
```

## 样例 #3

### 输入

```
1 1
```

### 输出

```
2
```

# AI分析结果



---

## 题目重写

# 红绿塔

## 题目描述

你有 $r$ 块红色积木和 $g$ 块绿色积木，用于建造红绿塔。红绿塔按照以下规则建造：

- 塔有若干层；
- 若塔有 $n$ 层，则第一层有 $n$ 块积木，第二层有 $n-1$ 块，依此类推，最后一层有 $1$ 块；
- 每层必须使用同一颜色的积木。

令 $h$ 表示用给定积木能建造的最大层数。你需要计算有多少种不同的 $h$ 层红绿塔建造方案（答案取模 $10^9+7$）。

## 样例 #1

### 输入
```
4 6
```

### 输出
```
2
```

---

## 唯一算法分类
0-1背包

---

## 综合分析与结论

### 核心算法模型
将每层积木视为背包物品，颜色选择视为物品装入不同背包。问题转化为双重约束的 0-1 背包计数问题，需同时满足红绿积木的总消耗不超过各自容量。

### 关键算法步骤
1. **确定最大层数h**  
   通过等差数列求和公式 $h(h+1)/2 \leq r+g$ 计算最大可行层数

2. **背包状态设计**  
   定义 `dp[j]` 表示使用 j 个红积木的方案数。绿积木数通过总消耗公式 `h(h+1)/2 - j` 隐含计算

3. **状态转移方程**  
   ```math
   dp[j] = (dp[j] + dp[j-i]) \mod (10^9+7)
   ```
   其中 i 表示当前处理的层积木数

4. **合法性校验**  
   最终需满足红积木数 j ≥ max(0, h(h+1)/2 - g) 以保证绿积木充足

### 可视化设计要点
1. **动态网格展示**  
   Canvas 绘制二维网格：x轴表示红积木数（0→r），y轴表示层数（1→h）。每个单元格填充色度表示方案数，使用热力色阶（蓝→黄→红）表示数值大小

2. **背包更新动画**  
   每处理一层时，从右向左扫描红积木数：
   - 当前处理单元格闪烁黄色边框
   - 新增方案数时触发像素扩散特效
   - 无效区域（j < i或绿积木不足）显示红色遮罩

3. **音效系统**  
   - 层数更新：8-bit 风格上升音阶
   - 方案数增加：短促"滴"声
   - 最终统计：经典 FC 过关音效

---

## 题解清单（4星及以上）

### 灵茶山艾府（★★★★★）
- **关键亮点**  
  精确推导红积木下界，完美应用滚动数组优化，时间复杂度 $O(h·r)$ 严格最优
- **核心代码段**  
  ```go
  for i := 1; i <= h; i++ {
      for j := r; j >= i; j-- {
          dp[j] = (dp[j] + dp[j-i]) % mod
      }
  }
  ```

### _JF_（★★★★☆）
- **关键亮点**  
  创新性地通过二维状态隐含绿积木数，采用显式层数循环更易理解
- **特色实现**  
  ```cpp
  for(int j=min(r,(1+i)*i/2);j>=0;j--){
      int Red=j, Gre=(1+i)*i/2-j;
      if(Red<=r && Gre<=g){
          dp1[j] += dp[j];
          if(j-i>=0) dp1[j] += dp[j-i];
      }
  }
  ```

### 流绪（★★★★☆）
- **关键亮点**  
  通过数学推导准确处理剩余积木问题，代码实现简洁高效
- **数学优化**  
  ```cpp
  int sum=h*(h-1)/2;
  for(int i=r;~i;i--) {
      if(sum-i>g) break; // 绿积木不足时提前终止
      ans+=dp[i];
  }
  ```

---

## 核心代码实现

### 灵茶山艾府解法（Go）
```go
func main() {
    const mod = 1e9+7
    var r, g, ans int
    Scan(&r, &g)
    h := 1
    for (h+1)*(h+2)/2 <= r+g { h++ }
    dp := make([]int, r+1)
    dp[0] = 1
    for i := 1; i <= h; i++ {
        for j := r; j >= i; j-- {
            dp[j] = (dp[j] + dp[j-i]) % mod
        }
    }
    minRed := max(0, h*(h+1)/2 - g)
    for _, v := range dp[minRed:] {
        ans = (ans + v) % mod
    }
    Print(ans)
}
```

---

## 相似题目推荐
1. **CF478D** - 本题原题（红绿塔问题）
2. **P1048** - 采药（经典0-1背包）
3. **P1156** - 垃圾陷阱（双重约束背包）

---

## 可视化代码片段（JS Canvas）
```javascript
class DPDemo {
    constructor(canvas, r, h) {
        this.ctx = canvas.getContext('2d')
        this.cellSize = 30
        this.colors = [[240, 248, 255], [135, 206, 250], [70, 130, 180]]
        this.initGrid(r, h)
    }

    drawCell(x, y, value) {
        const color = this.getColor(value)
        this.ctx.fillStyle = `rgb(${color})`
        this.ctx.fillRect(x*this.cellSize, y*this.cellSize, 
                         this.cellSize-1, this.cellSize-1)
    }

    updateLayer(i, dp) {
        for(let j=dp.length-1; j>=i; j--) {
            this.highlightCell(j, i) // 高亮当前更新位置
            this.drawCell(j, i, dp[j])
            playSound('click') // 触发音效
        }
    }
}
```

---

## 个人心得摘录
> "最初错误地将层数计算为√(2(r+g))导致WA，后改为循环验证法才正确。背包下界推导时，必须同时考虑红积木不能为负，这是关键边界条件。" —— 流绪

---

## 算法演示说明
1. **初始化阶段**  
   展示空白的DP数组网格，第一行全绿（dp[0]=1）

2. **层处理动画**  
   - 第i层处理时，右侧显示当前层数
   - 更新列时使用黄色高亮边框
   - 数值变化时产生像素粒子特效

3. **最终统计**  
   有效区域（minRed→r）显示绿色边框，无效区域红色遮罩，答案区域脉冲金光特效

--- 

通过本方案，学习者可直观理解背包模型在双重约束场景下的应用，掌握滚动数组优化技巧，同时通过游戏化交互增强学习体验。

---
处理用时：104.09秒
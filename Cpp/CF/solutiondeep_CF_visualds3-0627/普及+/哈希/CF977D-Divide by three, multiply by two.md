# 题目信息

# Divide by three, multiply by two

## 题目描述

有一个长度为 $n$ 的数列 $a_i$，要求你将这个数列重排成一个排列 $p_i$，使得对于任意的 $p_i(1 \le i < n)$：



- $p_i \times 2 = p_{i+1}$，或者

- 当 $p_i$ 可以被 $3$ 整除时，$p_i \div 3 = p_{i+1}$。



保证答案存在。

## 说明/提示

在第一个样例中，一种可能的合法排列为 $[9,3,6,12,4,8]$。

## 样例 #1

### 输入

```
6
4 8 6 3 12 9
```

### 输出

```
9 3 6 12 4 8 
```

## 样例 #2

### 输入

```
4
42 28 84 126
```

### 输出

```
126 42 84 28 
```

## 样例 #3

### 输入

```
2
1000000000000000000 3000000000000000000
```

### 输出

```
3000000000000000000 1000000000000000000 
```

# AI分析结果



**算法分类选择**：数论（因子分解与排序）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **因子分解**：每个数分解出3的因子次数，次数高的优先排列。同次数时按数值升序（确保乘2连接）。
- **排序策略**：排序后序列保证每一步优先除以3，无法再除时用乘2连接。

#### **解决难点**
- **确定起始点与顺序**：通过3的因子次数确定排列优先级，解决如何选择下一个元素的问题。
- **避免复杂结构**：无需建图或搜索，直接数学推导即可生成正确序列。

---

### **题解评分 (≥4星)**

1. **yuzhechuan的题解（5星）**
   - **亮点**：利用因子分解与排序，时间复杂度O(n log n)，代码简洁高效。
   - **核心代码**：
     ```cpp
     sort(A+1, A+1+n, [](STR m, STR n) {
         return m.b != n.b ? m.b > n.b : m.a < n.a;
     });
     ```

2. **Islauso的题解（4星）**
   - **亮点**：拓扑排序思路清晰，证明图中无环确保可行性。
   - **核心代码**：
     ```cpp
     if ((a[i] * 2 == a[j]) || (a[i] % 3 == 0 && a[i] / 3 == a[j])) {
         add_edge(i, j);
     }
     ```

3. **Tyyyyyy的题解（4星）**
   - **亮点**：暴力搜索实现简单，适合小规模数据。
   - **核心代码**：
     ```cpp
     if (p[step-1] * 2 == a[i] || a[i] * 3 == p[step-1]) {
         dfs(i, step + 1);
     }
     ```

---

### **最优思路或技巧提炼**

- **关键数学性质**：每个数的3因子次数决定了其在序列中的位置，同次数时数值升序确保乘2操作的正确连接。
- **实现步骤**：
  1. 计算每个数的3因子次数。
  2. 按3因子次数降序、数值升序排序。
  3. 直接输出排序后的序列。

---

### **同类型题或类似算法套路**

- **通用解法**：涉及因子分解的排列问题，例如需要按质因子次数排序的场景。
- **类似题目**：
  1. **LeetCode 891. Super Egg Drop**（数学推导优化）。
  2. **Codeforces 1144F. Graph Without Long Directed Paths**（图论染色问题）。
  3. **洛谷 P1104 生日**（多关键字排序）。

---

### **可视化与算法演示**

#### **动画方案**
1. **因子分解展示**：高亮每个数的3因子次数（如9→2，3→1）。
2. **排序过程**：动态显示排序后的数组，颜色区分不同3因子次数。
3. **连接箭头**：用箭头表示相邻元素的乘2或除3操作，颜色区分操作类型（如红色箭头表示除3，蓝色表示乘2）。

#### **复古游戏化设计**
- **像素风格**：用8位风格显示数值和因子次数，背景音乐为8位循环音效。
- **自动演示**：AI自动排序并连接元素，每步触发“滴答”音效，成功时播放胜利音效。
- **交互控制**：用户可暂停/步进观察排序和连接逻辑。

---

### **代码实现（核心逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node { long long val; int cnt_3; };

int main() {
    int n; cin >> n;
    vector<Node> arr(n);
    for (auto& x : arr) {
        cin >> x.val;
        long long tmp = x.val;
        x.cnt_3 = 0;
        while (tmp % 3 == 0) x.cnt_3++, tmp /= 3;
    }
    sort(arr.begin(), arr.end(), [](const Node& a, const Node& b) {
        return a.cnt_3 != b.cnt_3 ? a.cnt_3 > b.cnt_3 : a.val < b.val;
    });
    for (auto& x : arr) cout << x.val << " ";
    return 0;
}
```

---

### **个人心得摘录**

- **yuzhechuan**：通过观察样例发现3因子的规律，避免复杂搜索。
- **Islauso**：拓扑排序前需严格证明无环，避免错误假设。
- **Tyyyyyy**：暴力搜索虽直观，但需注意剪枝和终止条件。

---
处理用时：92.60秒
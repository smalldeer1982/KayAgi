# 题目信息

# Checkposts

## 题目描述

你的城市有 $n$ 个路口。路口之间有一条单程道路。作为城市的市长，你必须确保所有路口的安全。

为了确保安全，你必须建造一些警察检查站。一个检查站只能建在一个路口。 如果有一个检查站在 $i$ 路口，保护 $j$ 的条件是：$i==j$ 或者警察巡逻车可以从 $i$ 走到 $j$，并且能回到 $i$。

建造检查站要花一些钱。 由于城市的某些地区比其他地区更昂贵，在某些路口修建检查站可能比其他路口花费更多的钱。

你需要找到使所有路口安全的最低花费，以及花费与最低价格相等的方案数。

如果其中任何一个路口包含其中一个检查点而不包含在另一个路口中，则两种方式是不同的。

方案数模 $10^9+7$。

## 说明/提示

$1 \leq n \leq 10^5,0 \leq m \leq 3 \times 10^5,0 \leq a_{i} \leq 10^9$。

$1<=u_{i},v_{i}<=n,u≠v$。

**最小花费不需要取模，方案数需要取模。**

## 样例 #1

### 输入

```
3
1 2 3
3
1 2
2 3
3 2
```

### 输出

```
3 1
```

## 样例 #2

### 输入

```
5
2 8 0 6 0
6
1 4
1 3
2 4
3 4
4 5
5 1
```

### 输出

```
8 2
```

## 样例 #3

### 输入

```
10
1 3 2 2 1 3 1 4 10 10
12
1 2
2 3
3 1
3 4
4 5
5 6
5 7
6 4
7 3
8 9
9 10
10 9
```

### 输出

```
15 6
```

## 样例 #4

### 输入

```
2
7 91
2
1 2
2 1
```

### 输出

```
7 1
```

# AI分析结果



## 算法分类  
**强连通分量（Tarjan）**

---

## 题解思路与解决难点  
### 核心思路  
1. **强连通分量（SCC）划分**  
   - 检查站的保护范围等价于一个 SCC，因此需通过 Tarjan 算法找到所有 SCC。
2. **最小花费计算**  
   - 每个 SCC 的最小花费是该分量内所有节点的最小点权。
3. **方案数计算**  
   - 每个 SCC 中与最小点权相等的节点数量的乘积（模 $10^9+7$）。

### 解决难点  
1. **Tarjan 实现与 SCC 统计**  
   - 正确维护 `dfn` 和 `low` 数组，利用栈回溯 SCC。
   - 在弹栈时实时统计当前 SCC 的最小点权及其出现次数。
2. **数据规模优化**  
   - 使用链式前向星或 vector 存图以支持 $3 \times 10^5$ 边的快速遍历。
3. **边界处理**  
   - 不连通图的多次 Tarjan 调用。
   - 方案数乘法运算的取模处理。

---

## 题解评分（≥4星）  
### 1. KEBrantily（5星）  
- **亮点**  
  - 代码简洁，变量命名清晰（`sum[t]` 存 SCC 最小点权，`siz[num]` 存数量）。  
  - 在 Tarjan 弹栈时直接统计最小值和数量，避免二次遍历。  
  - 链式前向星存图高效处理大规模数据。  

### 2. LevenKoko（4星）  
- **亮点**  
  - 实时计算答案，减少后处理步骤。  
  - 代码注释详细，调试提示明确（如 `不开 long long 见祖宗`）。  

### 3. Farkas_W（4星）  
- **亮点**  
  - 独立函数 `add` 和 `cmin` 提高可读性。  
  - 使用 `vector` 存图，直观展示邻接关系。  

---

## 最优思路与技巧  
### 关键步骤  
1. **Tarjan 弹栈时统计最小值与数量**  
   ```cpp  
   do {
       cur = stk[instk--];
       if (v[cur] < newv[sc]) {  
           newv[sc] = v[cur];  
           num[sc] = 0;  // 重置计数器
       }
       if (newv[sc] == v[cur]) num[sc]++;  
   } while (cur != u);  
   ```  
2. **乘法取模优化**  
   ```cpp  
   ans2 = (ans2 * siz[i]) % Mod;  // 逐步取模避免溢出  
   ```  

### 技巧  
- **链式前向星存图**：处理大规模稀疏图更高效。  
- **实时统计**：在弹栈阶段直接完成最小值和计数，避免二次遍历 SCC。  

---

## 类似题目  
1. **P2194 HXY烧情侣**（双倍经验，同 SCC 最小点权问题）  
2. **P2341 [USACO03FALL]受欢迎的牛**（SCC 缩点后统计出度）  
3. **P1262 间谍网络**（SCC + 最小点权选择）  

---

## 个人心得摘录  
- **调试教训**  
  > "不开 long long 的我在 P2194 卡了一个下午" —— LevenKoko  
  > **总结**：数据范围需仔细检查，尤其涉及累加和乘法时。  

- **优化技巧**  
  > "实时计算答案而非后处理" —— LevenKoko  
  > **总结**：减少代码复杂度和时间复杂度。  

---

## 可视化算法演示（Tarjan 核心流程）  
### 动画设计  
1. **像素风格**  
   - **颜色方案**：  
     - 未访问节点：灰色  
     - 栈中节点：黄色  
     - 已弹出节点：绿色（属于某个 SCC）  
   - **高亮操作**：  
     - `dfn/low` 更新时显示红色闪烁边框。  
     - 弹栈时播放 8-bit 音效（类似 FC 金币声）。  

2. **关键步骤演示**  
   - **Step 1**：DFS 进入节点，标记 `dfn` 和 `low`。  
   - **Step 2**：回溯时更新 `low`，显示箭头指向父节点。  
   - **Step 3**：发现 SCC 根节点（`dfn == low`），弹栈并统计最小点权。  

3. **自动演示模式**  
   - **AI 控制**：按预定义路径自动执行算法，支持暂停/继续。  
   - **积分系统**：正确识别 SCC 后获得积分，错误操作扣分。  

### 代码片段（Canvas 绘制 SCC）  
```javascript  
// 绘制节点（伪代码）  
function drawNode(node, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(node.x, node.y, 20, 20);  
    ctx.fillText(node.id, node.x + 5, node.y + 15);  
}  

// 弹栈动画  
function popStack() {  
    playSound("pop.wav"); // 8-bit 音效  
    let node = stack.pop();  
    drawNode(node, "#00FF00"); // 绿色标记完成  
}  
```  

---

## 核心代码实现  
### KEBrantily 的关键逻辑  
```cpp  
void tarjan(int x) {  
    low[x] = dfn[x] = ++cnt;  
    zhan[++top] = x; vis[x] = 1;  
    for (int i = head[x]; i; i = e[i].nxt) {  
        int to = e[i].to;  
        if (!dfn[to]) {  
            tarjan(to);  
            low[x] = min(low[x], low[to]);  
        } else if (vis[to]) {  
            low[x] = min(low[x], dfn[to]);  
        }  
    }  
    if (dfn[x] == low[x]) {  
        ++t;  
        int pre = zhan[top--];  
        sum[t] = val[pre];  
        vis[pre] = 0; num[pre] = t;  
        while (pre != x) {  
            pre = zhan[top--];  
            sum[t] = min(sum[t], val[pre]); // 实时更新最小值  
            if (val[pre] == sum[t]) siz[t]++; // 统计数量  
        }  
    }  
}  
```  

### 方案数计算  
```cpp  
for (int i = 1; i <= t; i++) {  
    ans1 += sum[i];  
    ans2 = (ans2 * siz[i]) % Mod;  
}  
```

---
处理用时：90.47秒
# 题目信息

# Dining Hall

## 题目描述

在一个庞大的王国中，有一个无限大的餐厅。

该餐厅可以表示为由单元格 $(x, y)$ 构成的集合，其中 $x, y$ 是自然数。餐厅内还有无数张桌子。每张桌子由四个单元格定义：$(3x + 1, 3y + 1)$、$(3x + 1, 3y + 2)$、$(3x + 2, 3y + 1)$、$(3x + 2, 3y + 2)$，其中 $x, y$ 是非负整数。所有不属于任何桌子的单元格被视为走廊。

客人只能在走廊中移动，且每次只能通过相邻的边移动到相邻的单元格，每次移动耗时相同。注意：客人只能在最后一次移动时坐在桌子上，且必须坐在桌子上。

在王国的一场晚宴中，共有 $n$ 位客人到来，每位客人有一个特征值 $t_i$（取值为 $0$ 或 $1$）。他们按顺序进入大厅，从单元格 $(0, 0)$ 出发走向某张桌子。若第 $i$ 位客人的 $t_i = 1$，则他会选择距离最近的仍有空位的桌子；若 $t_i = 0$，则他会选择距离最近的未被占用的桌子（即使后续可能有其他客人加入）。若存在多张桌子距离相同，则选择 $x$ 坐标最小的单元格；若仍有多个选项，则选择其中 $y$ 坐标最小的单元格。

从单元格到桌子的距离定义为到该桌子上最近的未被占用的单元格的距离。两单元格之间的距离按移动到相邻单元格的次数计算。注意：移动过程中不允许穿过属于桌子的单元格，除非是最后一步（该步骤会将你放置在桌子的最终单元格上）。

为更好理解条件，可参考说明中的图示。

你无需亲自计算所有客人的入座情况，请直接输出每位客人最终入座的单元格。

## 说明/提示

第一位客人到单元格 $(1, 1)$ 的距离为 2，因此选择该位置。

第二位客人到单元格 $(1, 2)$ 和 $(2, 1)$ 的距离均为 3，但由于 $1 < 2$，因此选择 $(1, 2)$。无额外约束。

第三位客人到单元格 $(2, 1)$ 的距离为 3，因此选择该位置。

第四位客人到单元格 $(1, 4)$ 的距离为 5，因此选择该位置。

第五位客人到单元格 $(4, 1)$ 的距离为 5。

第六位客人到单元格 $(1, 5)$ 和 $(2, 2)$ 的距离均为 6，但由于 $x$ 坐标更小，因此选择 $(1, 5)$。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2090C/14307747f44bf893a0cb5c3731d43642a649f3b9.png)

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
6
0 1 1 0 0 1
5
1 0 0 1 1```

### 输出

```
1 1
1 2
2 1
1 4
4 1
1 5
1 1
1 4
4 1
1 2
2 1```

# AI分析结果



**唯一算法分类**：优先队列（堆）的应用

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **桌子的生成与选择**：每个桌子的左下角坐标按照特定规则生成，确保距离（步数）递增。优先队列动态维护所有可能的位置，根据客人类型选择最近的位置。
- **优先队列管理**：对于每个被占用的桌子，将剩余三个位置加入优先队列，供后续客人选择（特别是t_i=1的客人）。
- **坐标更新规则**：根据当前坐标生成下一个未被占用桌子的左下角，确保按距离顺序生成。

#### **解决难点**
- **动态维护可用位置**：通过优先队列快速获取最近位置，避免遍历所有可能的桌子。
- **正确生成新桌子坐标**：通过数学规律更新x和y，确保新桌子的步数递增，满足t_i=0客人需求。

---

### **题解评分**

1. **AstaVenti_的题解（★★★★★）**
   - **亮点**：高效利用优先队列动态管理，时间复杂度O(n log n)，代码简洁，正确处理所有样例。
   - **思路清晰度**：通过坐标更新规则和优先队列明确模拟客人选择过程。
   
2. **BLuemoon_的题解（★★★☆☆）**
   - **不足**：预处理所有可能位置，导致内存和时间开销较大，无法处理大规模数据。
   - **亮点**：通过两个set分离不同类型客人的选择条件，直观但效率低。

3. **postpone的题解（★★★☆☆）**
   - **不足**：思路描述较模糊，未给出完整实现，依赖外部链接。
   - **亮点**：提出使用map管理距离映射，但未深入优化。

---

### **最优思路提炼**
- **优先队列动态选择**：维护一个按步数和坐标排序的优先队列，确保每次选择最近可用位置。
- **坐标生成数学规律**：桌子的左下角按阶梯状生成，步数递增，避免重复计算。
- **分治管理类型**：t_i=0选择新桌子，t_i=1从队列中选，逻辑分离清晰。

---

### **同类型题与算法套路**
- **优先队列应用**：如Dijkstra算法、合并K个有序链表，利用堆快速获取极值。
- **坐标生成与遍历**：类似蛇形矩阵或螺旋矩阵的坐标生成，需数学规律推导。

---

### **推荐题目**
1. **P1090 [NOIP2004 提高组] 合并果子**（优先队列）
2. **P1908 逆序对**（分治与数学规律）
3. **P1443 马的遍历**（BFS与坐标生成）

---

### **可视化与算法演示**
- **动画设计**：Canvas展示坐标网格，高亮当前选择的位置和路径。
- **颜色标记**：红色表示当前客人位置，绿色表示可用位置，灰色表示已占用。
- **步进控制**：支持暂停/继续，查看优先队列状态和坐标更新过程。
- **像素风格**：8-bit像素动画，音效提示位置选中和队列变化。

---

### **代码实现（核心逻辑）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef tuple<ll,ll,ll> tp; // 步数、x、y

int main() {
    ll T, n;
    cin >> T;
    while (T--) {
        priority_queue<tp, vector<tp>, greater<tp>> pq;
        ll x = 1, y = 1, dis = 2; // 初始桌子左下角
        cin >> n;
        vector<pair<ll, ll>> ans(n);
        for (int i = 0; i < n; ++i) {
            int t; cin >> t;
            if (t == 1 && !pq.empty() && get<0>(pq.top()) < dis) {
                auto [d, px, py] = pq.top(); pq.pop();
                ans[i] = {px, py};
            } else {
                ans[i] = {x, y};
                // 将其他三个位置加入队列
                pq.emplace(x + y + 1, x + 1, y);
                pq.emplace(x + y + 1, x, y + 1);
                pq.emplace(x + y + 4, x + 1, y + 1);
                // 更新下一个桌子坐标
                if (y == 1) swap(x, y), y += 3;
                else x += 3, y -= 3;
                dis = x + y;
            }
        }
        for (auto [a, b] : ans) cout << a << " " << b << "\n";
    }
}
```

---
处理用时：326.99秒
# 题目信息

# Knights of a Polygonal Table

## 题目描述

有  $n$  个骑士想决战。每个骑士都有能力值，且身上带有一些金币。如果骑士  $A$  的能力值大于骑士  $B$ ，那么骑士  $A$  就可以杀死骑士  $B$ ，并获得骑士  $B$  身上的所有金币。但就算是骑士也不会残忍过度，他们最多只会杀死  $k$  个骑士。对于每一位骑士，请你求出在决战后他身上金币的最大值。

## 说明/提示

- 第  $1$  组样例的解释：

第  $1$  个骑士是最蒻的，因此他谁也不能杀，只能保留自己原有的金币。

第  $2$  个骑士只能杀死第  $1$  个骑士，因此他最多拥有  $2 + 1 = 3$  个金币。

第  $3$  个骑士是最蔃的，但他只能选择杀  $k = 2$  个骑士。显然他会杀死第  $2$  个骑士和
第  $4$  个骑士，因为他们身上的金币更多。因此他最多拥有  $11 + 2 + 33 = 46$  个金币。

第  $4$  个骑士应该杀死第  $1$  个和第  $2$  个骑士，因此他最多拥有  $33 + 1 + 2 = 36$  个金币。 

- 第  $2$  组样例的解释：

除了最蒻的第  $1$  个骑士谁也不能杀，其他骑士都能杀死前一个骑士并获得他的金币。

- 第  $3$  组样例的解释：

由于只有一个骑士在决战中，他无法杀死任何人。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
4 2
4 5 9 7
1 2 11 33
```

### 输出

```
1 3 46 36 ```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5
1 2 3 4 5
```

### 输出

```
1 3 5 7 9 ```

## 样例 #3

### 输入

```
1 0
2
3
```

### 输出

```
3 ```

# AI分析结果



## 唯一算法分类
**贪心、堆（优先队列）**

---

## 综合分析与结论

### 核心思路
1. **按能力值排序**：将骑士按能力值从小到大排序，保证处理第 i 个骑士时，所有可杀的骑士都在其左侧。
2. **动态维护前 k 大金币**：使用小根堆维护当前可杀骑士中金币最多的前 k 个元素。堆顶保存最小的前 k 元素，当新元素比堆顶大时替换堆顶，保持堆的大小不超过 k。
3. **总和动态更新**：维护堆中元素的总和，每个骑士的最终金币为堆总和加上自身金币。

### 解决难点
- **高效筛选前 k 大元素**：通过堆的 O(log k) 操作优化时间复杂度，避免每次暴力排序。
- **避免重复计算**：堆中动态维护当前可杀骑士的最优选择，无需每次重新遍历。

### 可视化设计
- **像素动画**：骑士按能力值从左到右排列，每个骑士以像素块表示，颜色深浅表示金币多少。
- **堆动态变化**：用像素堆结构展示堆顶元素的替换过程，堆大小超过 k 时弹出最小元素。
- **音效与高亮**：替换堆顶时播放“弹出”音效，总和更新时显示高亮数值。
- **自动演示**：模拟贪心流程，自动步进处理每个骑士，堆状态和总和实时更新。

---

## 题解清单 (≥4星)

### 1. _22222222_（★★★★★）
- **关键亮点**：小根堆动态维护前 k 大元素，时间复杂度 O(n log k)，最优解法。
- **代码简洁性**：直接使用 STL 优先队列，逻辑清晰。

### 2. fls233666（★★★★）
- **关键亮点**：优先队列处理前 k 大元素，思路正确但时间复杂度略高。
- **实现细节**：取出前 k 元素后放回堆，适用于 k 较小的情况。

---

## 最优思路代码片段

```cpp
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆
int sum = 0;

for (int i = 1; i <= n; i++) {
    // 当前骑士答案 = sum + 自身金币
    ans[i] = sum + a[i].c;

    // 维护堆
    if (min_heap.size() < k) {
        min_heap.push(a[i].c);
        sum += a[i].c;
    } else if (a[i].c > min_heap.top()) {
        sum -= min_heap.top();
        min_heap.pop();
        min_heap.push(a[i].c);
        sum += a[i].c;
    }
}
```

---

## 同类型题与算法套路
- **类似问题**：动态维护前 k 大/小元素（如滑动窗口中位数、实时统计 Top K）。
- **通用解法**：优先队列（大根堆或小根堆）、快速选择算法。

---

## 推荐相似题目
1. [P3963 [TJOI2013] 奖学金](https://www.luogu.com.cn/problem/P3963)  
2. [CF987C Three displays](https://codeforces.com/problemset/problem/987/C)  
3. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)

---

## 个人心得摘录
- **堆的维护顺序**：“贪心策略的正确性依赖于及时替换堆顶元素，否则可能漏掉更优解。”  
- **排序的关键性**：“按能力排序后，每个骑士的决策仅依赖于前面已处理的数据，实现线性递推。”

---

## 可视化算法演示

### 动画方案
1. **骑士队列**：按能力值从小到大排列，每个骑士显示为颜色块（颜色越深金币越多）。
2. **堆操作**：新骑士的加入触发堆调整，堆顶被替换时显示“弹出”动画。
3. **总和更新**：每次堆变化后，总和数值动态变化，伴随音效提示。

### 复古像素风格
- **调色板**：8位色系，骑士块使用绿-黄-红渐变，堆元素用蓝色方块。
- **Canvas 绘制**：网格布局，左侧骑士队列，右侧堆结构，底部显示当前总和。

### 交互功能
- **步进控制**：支持暂停/继续、单步前进、调整动画速度。
- **自动演示**：默认自动播放，模拟贪心策略的完整执行流程。

---

**总结**：通过排序与堆的巧妙结合，将问题转化为动态维护前 k 大元素的和，时间复杂度与代码实现均达到最优。

---
处理用时：114.70秒
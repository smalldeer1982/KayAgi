# 题目信息

# Divide by three, multiply by two

## 题目描述

有一个长度为 $n$ 的数列 $a_i$，要求你将这个数列重排成一个排列 $p_i$，使得对于任意的 $p_i(1 \le i < n)$：



- $p_i \times 2 = p_{i+1}$，或者

- 当 $p_i$ 可以被 $3$ 整除时，$p_i \div 3 = p_{i+1}$。



保证答案存在。

## 说明/提示

在第一个样例中，一种可能的合法排列为 $[9,3,6,12,4,8]$。

## 样例 #1

### 输入

```
6
4 8 6 3 12 9
```

### 输出

```
9 3 6 12 4 8 
```

## 样例 #2

### 输入

```
4
42 28 84 126
```

### 输出

```
126 42 84 28 
```

## 样例 #3

### 输入

```
2
1000000000000000000 3000000000000000000
```

### 输出

```
3000000000000000000 1000000000000000000 
```

# AI分析结果



**唯一算法分类**：数学+排序

---

### **题解思路、算法要点与解决难点**

**核心思路**：通过分析每个数的3的因子数，按降序排序，相同则按数值升序排列。这样构造的序列天然满足题目条件：每个数只能通过乘2或除3得到下一个数。

**解决难点**：
1. **因子数的关系**：除3操作会减少3的因子数，乘2不影响。因此，3的因子数多的数应排在前面，形成链式结构。
2. **贪心排序**：通过排序规则保证相邻元素的合法性，无需复杂搜索或建图。

---

### **题解评分 (≥4星)**

1. **yuzhechuan的题解（5星）**  
   - **亮点**：简洁高效，时间复杂度O(n log n)，数学分析透彻，正确性直观。  
   - **关键代码**：统计3的因子数，按因子数降序+数值升序排序。

2. **Islauso的题解（4星）**  
   - **亮点**：拓扑排序保证正确性，适用于通用情况。  
   - **关键代码**：建图（乘2/除3的边）+拓扑排序输出。

3. **Tyyyyyy的题解（4星）**  
   - **亮点**：动态规划最长路，路径还原清晰。  
   - **关键代码**：用map记录数值索引，拓扑排序更新最长路径。

---

### **最优思路或技巧提炼**

1. **3因子数排序法**：  
   - 每个数分解为3的因子数，降序排列。  
   - 同因子数时按数值升序（便于乘2连接）。  
   - **正确性**：高因子数数无法由低因子数数通过乘2得到，只能通过除3连接；数值升序确保乘2后的数存在。

2. **辅助数据结构**：  
   - 使用结构体存储数值和3的因子数，便于排序。

---

### **同类型题或类似算法套路**

- **因子驱动排序**：如[CF1144G. Two Merged Sequences](https://codeforces.com/problemset/problem/1144/G)，利用数值特性构造序列。  
- **拓扑排序应用**：如[LeetCode 210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)，依赖关系建图。

---

### **推荐相似题目**

1. [洛谷 P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)（贪心+排序）  
2. [洛谷 P1967 货车运输](https://www.luogu.com.cn/problem/P1967)（最大生成树+贪心）  
3. [洛谷 P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（DFS剪枝+因子分析）

---

### **个人心得摘录**

- **yuzhechuan**：“/3和x2是分块的，/3决定了序列能走多远” → 深刻理解因子数的链式关系。  
- **Islauso**：通过数学证明图中无环，确保拓扑排序可行性 → 理论推导支撑算法选择。

---

### **可视化与算法演示**

**核心算法过程（排序法）**：  
1. **分解因子**：为每个数计算3的因子数，高亮其数值（如9→3²）。  
2. **排序动画**：展示按因子数降序排列，同因子数时数值升序。  
3. **连接验证**：逐步检查相邻数是否满足乘2或除3，高亮合法边。

**复古像素化设计**：  
- **颜色标记**：3因子数用不同颜色深度表示（如红色深度递增）。  
- **Canvas动画**：数列排列为像素块，排序时交换位置并显示因子数。  
- **音效**：排序完成时播放8-bit胜利音效，错误连接触发警示音。

---

### **代码实现（核心逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    long long val;
    int cnt_3; // 3的因子数
};

bool cmp(const Node& a, const Node& b) {
    if (a.cnt_3 != b.cnt_3) 
        return a.cnt_3 > b.cnt_3; // 因子数降序
    return a.val < b.val; // 数值升序
}

int main() {
    int n;
    cin >> n;
    vector<Node> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i].val;
        long long x = arr[i].val;
        arr[i].cnt_3 = 0;
        while (x % 3 == 0) {
            arr[i].cnt_3++;
            x /= 3;
        }
    }
    sort(arr.begin(), arr.end(), cmp);
    for (auto& node : arr) 
        cout << node.val << " ";
    return 0;
}
```

**正确性验证**：  
- 样例1排序后顺序为9(3²)→3(3¹)→6(3¹)→12(3¹)→4(3⁰)→8(3⁰)，满足相邻条件。

---
处理用时：133.52秒
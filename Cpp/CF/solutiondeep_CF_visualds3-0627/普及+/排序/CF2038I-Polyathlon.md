# 题目信息

# Polyathlon

## 题目描述

伯兰（Berland）是今年国际大学生多项全能比赛的主办国！与双项全能是两个项目的比赛类似，多项全能是多个项目的比赛。今年有 $m$ 个项目。此外，还有 $n$ 名参赛者。项目编号从 $1$ 到 $m$ ，参赛者编号从 $1$ 到 $n$ 。

有些参赛者擅长多项运动。我们还知道，对于每一对参与者来说，至少存在一种运动，即其中一人擅长该运动，而另一人不擅长。

比赛项目的顺序在开幕式上决定。从历史上看，它是由万能的随机数生成器决定的。掷出一个从 $1$ 到 $m$ 的随机数 $x$ 。比赛从 $x$ 开始，然后是 $(x \bmod m + 1)$ ，接着是 $((x + 1) \bmod m + 1)$ ，以此类推。

每个项目的比赛规则如下。如果剩下的所有参赛者（所有尚未被淘汰的参赛者）都不擅长该项目，则所有人都进入下一个项目。否则，所有熟练的参赛者都进入下一个项目，所有不熟练的参赛者都被淘汰出局。一旦比赛只剩下一名参赛者，比赛即告结束，该参赛者即为获胜者。

作为比赛的组织者，您事先对比赛可能出现的结果很好奇。对于每个运动项目 $x$ ，如果比赛从运动项目 $x$ 开始，请打印获胜者的编号。

## 样例 #1

### 输入

```
3 5
10010
01100
10101```

### 输出

```
3 2 3 1 3```

# AI分析结果



**唯一算法分类**：基数排序

---

**题解思路与核心难点**：

1. **问题转化**  
   每个起始位置对应参赛者字符串的循环移位，胜者为字典序最大的字符串。字典序比较规则与淘汰机制一致，确保每次筛选保留更高位的1。

2. **核心算法**  
   使用基数排序从低位到高位（项目顺序）逐步排序。每次按当前位将选手分为1在前、0在后两组，保持稳定性。经过m轮处理，数组首位即为当前起始位置的胜者。

3. **实现优化**  
   - **循环移位处理**：将字符串复制两倍长度，避免取模运算。
   - **动态维护排序**：通过倒序处理项目位，确保每次排序后首位对应不同起始位置的胜者。

**题解评分 (≥4星)**：

1. **鳶一折纸（5星）**  
   - **亮点**：基于基数排序的稳定性质，O(nm)时间复杂度，代码简洁高效。
   - **代码实现**：从最后一位向前处理，动态调整排序数组。

2. **Register_int（5星）**  
   - **亮点**：极简代码，直接复制字符串并倒序基数排序，逻辑清晰。
   - **关键代码**：循环处理每位，归并1和0的选手。

3. **xyz105（4星）**  
   - **亮点**：直观排序后动态调整，利用基数排序思想推导后续起始位置结果。
   - **优化**：通过排序结果快速生成其他位置的答案。

---

**最优思路与技巧**：

- **基数排序的逆向应用**：从最后一个项目开始排序，确保高位优先级。
- **循环移位的字典序比较**：通过复制字符串简化循环处理，直接截取子串比较。
- **稳定性维护**：每轮排序保持之前的相对顺序，仅根据当前位分组。

**同类型题套路**：

- **循环字符串排序**（如[CF1202E](https://codeforces.com/problemset/problem/1202/E)）
- **字典序极大值筛选**（如[LeetCode 321](https://leetcode.com/problems/create-maximum-number/)）
- **基数排序处理多维数据**（如[洛谷P1177](https://www.luogu.com.cn/problem/P1177)）

---

**推荐题目**：

1. [CF1202E - 分解子串](https://codeforces.com/problemset/problem/1202/E)  
   **考察点**：字符串循环处理与哈希技巧。

2. [LeetCode 321 - 最大数生成](https://leetcode.com/problems/create-maximum-number/)  
   **考察点**：字典序极大值筛选与贪心。

3. [洛谷P1271 - 基数排序](https://www.luogu.com.cn/problem/P1271)  
   **考察点**：基数排序的基础实现与优化。

---

**可视化设计**：

1. **动画流程**：  
   - **初始化**：展示所有选手的01字符串排列成环形。
   - **基数排序步骤**：高亮当前处理的项目位，将选手按1/0分组移动。
   - **动态结果更新**：每处理完一位，显示当前排序数组及首位胜者。

2. **像素风格**：  
   - **颜色方案**：1用绿色，0用红色；当前处理位闪烁黄色。
   - **Canvas绘制**：选手编号以像素块显示，移动时带有拖尾动画。

3. **音效交互**：  
   - **移动音效**：选手切换位置时播放8-bit点击声。
   - **胜者确认**：每轮结束时播放胜利音效，胜者编号高亮。

**代码片段（核心基数排序）**：

```cpp
vector<int> a(n);
for (int i = 1; i <= n; ++i) a[i-1] = i; // 初始化选手编号

// 处理每个项目位（倒序）
for (int pos = m; pos >= 1; --pos) {
    vector<int> ones, zeros;
    for (int id : a) {
        if (s[id][pos] == '1') ones.push_back(id);
        else zeros.push_back(id);
    }
    a.clear();
    a.insert(a.end(), ones.begin(), ones.end());
    a.insert(a.end(), zeros.begin(), zeros.end());
    ans[pos] = a[0]; // 记录当前位起始的胜者
}
```

---

**个人心得**：

- **循环处理技巧**：复制字符串避免复杂的取模运算，极大简化代码。
- **基数排序稳定性**：理解其保持原有顺序的特性是解决本题的关键。
- **调试教训**：初始未考虑字符串循环导致WA，通过复制两倍长度解决。

---
处理用时：108.36秒
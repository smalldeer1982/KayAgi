# 题目信息

# Clique Problem

## 题目描述

数轴上有 $n$ 个点，第 $i$ 个点的坐标为 $x_i$，权值为  $w_i$。两个点 $i,j$ 之间存在一条边当且仅当 $abs(x_i-x_j)\geq w_i+w_j$ 。 你需要求出这张图的最大团的点数。

团的定义：两两之间有边的顶点集合。

## 样例 #1

### 输入

```
4
2 3
3 1
6 1
0 2
```

### 输出

```
3
```

# AI分析结果



---

## **唯一算法分类**  
**贪心算法（线段覆盖问题）**

---

## **题解思路、算法要点与解决难点**  
**核心思路**：  
将每个点转化为数轴上的区间 `[x_i - w_i, x_i + w_i]`，问题转化为选择尽可能多的互不重叠区间。按右端点排序后贪心选择，每次选右端点最小的未重叠区间。

**解决难点**：  
- **问题转化**：需通过数学推导将边的存在条件 `|x_i - x_j| ≥ w_i + w_j` 转换为区间不重叠条件。  
- **贪心策略证明**：需证明按右端点排序后依次选择的正确性（局部最优导致全局最优）。

**算法流程**：  
1. 计算所有点的区间 `[l_i, r_i]`。  
2. 按 `r_i` 从小到大排序。  
3. 遍历排序后的区间，记录当前已选区间的右端点，若当前区间左端点 ≥ 已选右端点则选择该区间。  

---

## **题解评分**  
### **评分 ≥4星题解**  
1. **NaCly_Fish（5星）**  
   - **亮点**：详细推导问题转化过程，代码可读性高，结构体排序逻辑清晰。  
   - **代码**：结构体排序 + 贪心遍历，时间复杂度 `O(n log n)`。  

2. **Siyuan（4星）**  
   - **亮点**：代码简洁，排序优化（使用索引数组），空间效率高。  
   - **代码**：通过 `id[]` 减少结构体复制，适合大规模数据。  

3. **mcDinic（4星）**  
   - **亮点**：代码简短，变量命名清晰，适合快速理解核心逻辑。  
   - **代码**：直接排序并贪心，无冗余操作。  

---

## **最优思路或技巧提炼**  
**关键技巧**：  
1. **区间模型转化**：将点的权值转化为左右端点，将图论问题转为几何问题。  
2. **右端点排序贪心**：保证每次选择对后续影响最小的区间（右端点最小，为后续留出更多空间）。  
3. **时间复杂度优化**：排序主导复杂度，贪心遍历仅需 `O(n)`。  

---

## **同类型题或类似算法套路**  
**通用解法**：  
- **线段覆盖问题**：选择不重叠区间的最优解均可按右端点排序贪心。  
- **活动选择问题**：如课程安排、任务调度等。  

---

## **推荐相似题目**  
1. **P1803 线段覆盖**（模板题，直接应用贪心）  
2. **CF1029C Maximal Intersection**（区间极值问题，需处理交集）  
3. **P2240 部分背包问题**（贪心策略的另一个典型应用）  

---

## **个人心得摘录**  
- **@凉城無愛**：  
  > “画图后发现，若选右端点最小的区间，后续可选区间更多，这是贪心的核心直觉。”  
- **@青鸟_Blue_Bird**：  
  > “调试时发现未正确初始化右端点变量，导致漏选第一个区间，深刻教训！”  

---

## **可视化与算法演示**  
### **动画方案设计**  
1. **可视化元素**：  
   - **数轴**：显示所有区间的左右端点。  
   - **当前选中区间**：高亮为绿色，已选区间为蓝色，未选为灰色。  
   - **指针**：动态标记当前遍历位置和已选右端点。  

2. **交互逻辑**：  
   - **步进控制**：用户可单步执行或自动播放（速度可调）。  
   - **音效触发**：选中区间时播放“滴”声，完成时播放胜利音效。  

3. **复古像素风格**：  
   - **颜色方案**：8位色（深蓝、亮绿、浅灰）。  
   - **Canvas绘制**：区间显示为矩形块，数轴网格用像素点阵。  

4. **自动演示模式**：  
   - **AI决策**：按右端点排序后依次选择，动态更新指针位置。  

---

## **代码实现（核心逻辑）**  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct Interval {
    int l, r;
    bool operator<(const Interval& other) const {
        return r < other.r; // 按右端点排序
    }
};

int main() {
    int n, x, w;
    cin >> n;
    Interval intervals[n];
    for (int i = 0; i < n; ++i) {
        cin >> x >> w;
        intervals[i].l = x - w;
        intervals[i].r = x + w;
    }
    sort(intervals, intervals + n);
    int count = 0, last_r = -2e9;
    for (auto& itv : intervals) {
        if (itv.l >= last_r) {
            count++;
            last_r = itv.r;
        }
    }
    cout << count << endl;
    return 0;
}
```

---

**可视化代码片段（JS Canvas）**  
```javascript
// 绘制数轴和区间（伪代码）
function drawIntervals(intervals, selected) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    intervals.forEach((itv, i) => {
        const x1 = scale(itv.l), x2 = scale(itv.r);
        ctx.fillStyle = selected.has(i) ? "#00FF00" : "#666666";
        ctx.fillRect(x1, 50, x2 - x1, 20); // 绘制区间块
    });
}
```

---
处理用时：80.88秒
# 题目信息

# Military Problem

## 题目描述

在这个问题中你需要帮助伯兰（？？我没找到有Berland这个国家）军队组织他们的指挥系统

伯兰军队中一共有n个军官。第一个官员是军队的指挥官，他并没有任何上级。其他的军官都有且只有一个直接的上级。如果一个军官a是军官b的上级，那么你也可以说军官b就是军官a的下属

如果满足下列条件，那么军官x就是军官y的下属（直接或非直接）：

1.y是x的直接上级 2.x的直接上级是y的下属

举个例子，下图的官员3的下属有:5,6,7,8,9

所以，在伯兰军队的结构中，除了指挥官，其他人都是指挥官的下属

形式上的，让我们把伯兰军队看成一棵拥有n个节点的树，树的节点u就代表了军官u。根（即一号节点）就相当于指挥官

伯兰战争部门命令你对q个查询给出答案。这q个查询会以（ui，ki）的形式给出，ui代表了某个军官，ki是正整数。你需要输出，编号为ui的军官下达命令后，第ki个得知此命令的军官编号是多少，如果传达人数不足ki个，输出-1。

要处理第i个查询，想象一下ui的命令如何我下达到ui的下属。这里使用了典型的DFS（深度优先搜索）算法。

假设现在的军官是a，他要下达一个命令。a军官选择一个军官b——还没有收到这个命令的直接下属（即在树上的一个孩子）。如果有许多这样的直接下属，那么A选择编号最小的那一个。A军官向B军官发出命令。之后，B使用完全相同的方式将命令扩展到它的子树。在B完成命令后，军官A再次选择下一个直接下属（使用相同的策略）。当军官A不能选择任何还没有接到命令的直接下属时，军官A下达命令完成。

让我们看一下下面这个例子（看下面的图）：

如果军官1下达了命令，军官们收到命令的顺序是：1,2,3,5,6,8,7,9,4

如果军官3下达了命令，军官们收到命令的顺序是：3,5,6,8,7,9

如果军官7下达了命令，军官们收到命令的顺序是：7,9

如果军官9下达了命令，军官们收到命令的顺序是：9

你应当分开处理这些查询。一个查询不会影响其他查询的结果。

## 样例 #1

### 输入

```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```

### 输出

```
3
6
8
-1
9
4
```

# AI分析结果



### 算法分类
**DFS**

### 题解思路与解决难点
**核心思路**：利用树的前序遍历特性，预处理每个节点的 DFS 序（`dfn`）、子树大小（`size`）和时间戳映射数组（`id`）。查询时直接通过区间偏移计算第 `k` 个节点。

**难点与解决方案**：
1. **DFS 顺序的正确性**：题目要求按子节点编号从小到大遍历，需对邻接表进行显式排序。
2. **高效预处理**：通过一次 DFS 遍历，同时记录 `dfn`（进入时间戳）、`size`（子树大小）和 `id`（时间戳→节点映射）。
3. **查询优化**：利用子树的 DFS 序连续性，将查询复杂度优化至 O(1)。

### 题解评分（≥4星）
1. **Asphy7xia 的题解（5星）**  
   - 思路清晰，显式排序邻接表确保 DFS 顺序正确。  
   - 代码简洁，变量命名规范，可读性强。  
   - 预处理和查询逻辑分离，实践性强。  

2. **jr_zch 的题解（4.5星）**  
   - 使用 `sor` 数组记录 DFS 序，`pre` 记录时间戳，逻辑直观。  
   - 显式排序邻接表，确保遍历顺序正确。  
   - 代码结构清晰，但变量命名略简（如 `sor` 可优化为 `dfs_order`）。  

3. **The_foolishest_OIer 的题解（4星）**  
   - 引入 `dfn` 和 `rdfn`（反向映射），逻辑完整。  
   - 显式排序邻接表，但代码中未注释排序步骤，可读性稍弱。  

### 最优思路提炼
1. **邻接表排序**：确保 DFS 遍历顺序按子节点编号从小到大。
2. **DFS 预处理三要素**：
   - `dfn[u]`：节点 `u` 的进入时间戳。
   - `size[u]`：以 `u` 为根的子树大小。
   - `id[time]`：时间戳 `time` 对应的节点。
3. **查询公式**：若 `k ≤ size[u]`，答案即 `id[dfn[u] + k - 1]`。

### 同类型题与算法套路
- **常见变形**：树的前序/后序区间查询、子树统计问题。
- **通用解法**：DFS 序 + 区间映射，适用于子树求和、最值、存在性查询。
- **类似题目**：  
  - **洛谷 P3384**（树链剖分，利用 DFS 序区间操作）。  
  - **洛谷 P3919**（可持久化线段树，DFS 序维护子树历史版本）。  

### 代码片段（核心DFS逻辑）
```cpp
// 显式排序邻接表，确保子节点按编号从小到大
for (int i = 1; i <= n; i++) sort(g[i].begin(), g[i].end());

void dfs(int u) {
    dfn[u] = ++time;      // 记录进入时间戳
    id[time] = u;         // 时间戳→节点映射
    size[u] = 1;          // 初始化子树大小
    for (int v : g[u]) {  // 遍历已排序的子节点
        dfs(v);
        size[u] += size[v];
    }
}
```

### 可视化设计
**复古像素风格动画**：
1. **Canvas 绘制**：树节点以像素方块表示，根节点为绿色，其他节点为蓝色。
2. **DFS 过程**：当前访问节点高亮为红色，访问顺序以黄色路径连接。
3. **音效**：节点访问时播放 8-bit 音效，查询命中时播放胜利音效。
4. **交互控制**：支持暂停/继续、步进调试，速度可调节。

### 个人心得
- **排序陷阱**：未显式排序邻接表会导致 DFS 顺序错误，需特别注意。
- **时间戳映射**：`dfn` 和 `id` 的逆向关系是快速查询的关键。

---

### 完整代码（Asphy7xia 的实现）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
vector<int> g[N];
int dfn[N], size[N], id[N], time;

void dfs(int u) {
    dfn[u] = ++time;
    id[time] = u;
    size[u] = 1;
    for (int v : g[u]) {
        dfs(v);
        size[u] += size[v];
    }
}

int main() {
    int n, q;
    scanf("%d%d", &n, &q);
    for (int i = 2, p; i <= n; i++) {
        scanf("%d", &p);
        g[p].push_back(i);
    }
    for (int i = 1; i <= n; i++) sort(g[i].begin(), g[i].end());
    dfs(1);
    while (q--) {
        int u, k;
        scanf("%d%d", &u, &k);
        if (k > size[u]) printf("-1\n");
        else printf("%d\n", id[dfn[u] + k - 1]);
    }
    return 0;
}
```

---
处理用时：239.13秒
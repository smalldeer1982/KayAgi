# 题目信息

# Divide by three, multiply by two

## 题目描述

有一个长度为 $n$ 的数列 $a_i$，要求你将这个数列重排成一个排列 $p_i$，使得对于任意的 $p_i(1 \le i < n)$：



- $p_i \times 2 = p_{i+1}$，或者

- 当 $p_i$ 可以被 $3$ 整除时，$p_i \div 3 = p_{i+1}$。



保证答案存在。

## 说明/提示

在第一个样例中，一种可能的合法排列为 $[9,3,6,12,4,8]$。

## 样例 #1

### 输入

```
6
4 8 6 3 12 9
```

### 输出

```
9 3 6 12 4 8 
```

## 样例 #2

### 输入

```
4
42 28 84 126
```

### 输出

```
126 42 84 28 
```

## 样例 #3

### 输入

```
2
1000000000000000000 3000000000000000000
```

### 输出

```
3000000000000000000 1000000000000000000 
```

# AI分析结果



### 唯一算法分类  
**其他搜索**（数学性质排序与拓扑排序结合）

---

### 题解思路、算法要点与解决难点  

#### 核心思路分析  
题目要求构造一个满足特定相邻条件的排列。关键点在于分析数的因子特性（3的幂次和2的幂次），并利用这一特性构造链式结构。  

#### 题解对比与难点  
1. **数学排序法（yuzhechuan）**  
   - **要点**：每个数分解为 $3^b \cdot x$（x不含3的因子），按3的幂次降序排列，相同则按数值升序。  
   - **难点**：发现3的幂次决定了排列的层级关系，乘2和除3操作只能在同层级或相邻层级间进行。  
   - **优化**：无需显式建图，直接排序即可构造正确序列，复杂度 $O(n \log n)$。  

2. **拓扑排序法（Islauso）**  
   - **要点**：将每个数可能的后续数（乘2或除3）作为边建图，证明图中无环后拓扑排序。  
   - **难点**：需要数学证明图中无环（利用因子分解矛盾）。  
   - **实现**：邻接矩阵建图，队列实现拓扑排序，复杂度 $O(n^2)$。  

3. **DFS暴搜法（Tyyyyyy等）**  
   - **要点**：暴力枚举所有可能的排列，剪枝条件为相邻元素需满足乘2或除3。  
   - **难点**：指数级复杂度，但题目保证答案存在且数据较小（n≤100），实践中可通过剪枝快速找到解。  

---

### 题解评分（≥4星）  

1. **yuzhechuan（5星）**  
   - **亮点**：数学性质发现巧妙，代码简洁高效，直接排序即可输出结果。  
   - **代码片段**：  
     ```cpp  
     sort(A+1, A+1+n, [](STR m, STR n) {  
         return m.b != n.b ? m.b > n.b : m.a < n.a;  
     });  
     ```  

2. **Islauso（4星）**  
   - **亮点**：图论建模严谨，拓扑排序实现直观，适用于更通用的链式结构问题。  
   - **代码片段**：  
     ```cpp  
     if (a[i] * 2 == a[j] || (a[i] % 3 == 0 && a[i]/3 == a[j])) {  
         edge[i][j] = 1;  
         in[j]++;  
     }  
     ```  

3. **Tweetuzki（4星）**  
   - **亮点**：动态规划求最长路径，结合哈希优化因子查询，复杂度 $O(n \log n)$。  
   - **代码片段**：  
     ```cpp  
     if (A[i] % 3 == 0) v = mp[A[i] / 3];  
     if (v) G[u].push_back(v), ind[v]++;  
     ```  

---

### 最优思路提炼  
**关键技巧**：  
1. **因子分解**：将数分解为 $3^b \cdot x$，3的幂次决定层级，2的幂次决定同层顺序。  
2. **贪心排序**：按3的幂次降序排列，同层级按数值升序（即2的幂次升序）。  
3. **数学证明**：乘2和除3操作无法形成环，确保拓扑排序的正确性。  

---

### 同类型题与算法套路  
- **链式结构构造**：如 [LeetCode 332. 重新安排行程](https://leetcode.com/problems/reconstruct-itinerary/)，需构造欧拉路径。  
- **因子分解应用**：如 [CF 1114C. Trailing Loves (or L'oeufs?)](https://codeforces.com/problemset/problem/1114/C)，计算阶乘的因子数。  

---

### 推荐相似题目  
1. [洛谷 P1118 数字重组](https://www.luogu.com.cn/problem/P1118)  
2. [洛谷 P1582 倒水](https://www.luogu.com.cn/problem/P1582)（因子分解与位运算）  
3. [洛谷 P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)（拓扑排序应用）  

---

### 可视化与算法演示  

#### 动画方案设计  
1. **数学排序法**：  
   - **节点表示**：每个数显示为方块，颜色深浅表示3的幂次（深色高幂次）。  
   - **排序过程**：动态展示按3的幂次降序排列，同层级按数值升序。  
   - **操作高亮**：箭头表示乘2或除3操作，验证相邻节点是否合法。  

2. **拓扑排序法**：  
   - **图结构绘制**：节点按数值排列，边表示乘2或除3操作。  
   - **拓扑遍历**：队列动态展示节点入队，颜色标记已访问节点。  

#### 复古游戏化设计  
- **8位像素风格**：  
  - 节点用16x16像素块表示，绿色为合法边，红色为非法边。  
  - 背景音乐：8-bit循环音效，节点访问时播放“哔”声，完成时播放胜利音效。  
- **自动演示模式**：  
  - 初始状态显示所有节点，自动按排序或拓扑顺序逐步连接，速度可调。  

```javascript  
// 伪代码：Canvas绘制节点  
function drawNode(ctx, x, y, value, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(x, y, 30, 30);  
    ctx.fillStyle = 'white';  
    ctx.fillText(value, x + 5, y + 20);  
}  
```  

---

### 核心代码实现  
#### yuzhechuan的排序法  
```cpp  
struct Node {  
    long long val;  
    int pow3;  
};  
sort(nodes.begin(), nodes.end(), [](Node a, Node b) {  
    return a.pow3 != b.pow3 ? a.pow3 > b.pow3 : a.val < b.val;  
});  
```  

#### Islauso的拓扑排序  
```cpp  
for (int i = 1; i <= n; ++i) {  
    if (in[i] == 0) q.push(i);  
}  
while (!q.empty()) {  
    int u = q.front(); q.pop();  
    ans.push_back(u);  
    for (int v : G[u]) if (--in[v] == 0) q.push(v);  
}  
```  

---

### 总结  
通过因子分解与数学性质直接排序是最优解，拓扑排序和DFS则适用于更通用的链式结构问题。可视化设计结合数学层级与图遍历，可直观展现算法核心逻辑。

---
处理用时：158.91秒
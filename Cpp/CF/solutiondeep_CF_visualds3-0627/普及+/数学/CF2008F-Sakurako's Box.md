# 题目信息

# Sakurako's Box

## 题目描述

Sakurako 有一个装满 $n$ 个球的盒子。每个球都有自己的数值。她想和朋友打个赌，朋友如果从盒子中随机选出两个球（可以是不同的两球，即使它们有相同的数值），这两个球数值的乘积能够等于 Sakurako 事先猜测到的一个数。

因为 Sakurako 是概率学方面的专家，她知道最明智的猜测应该是[期望值](http://tiny.cc/matozh_en)，但她忘了如何去计算。请帮助她计算出这个数组中任意两个元素乘积的期望值。

可以证明，该期望值的形式为 $\frac{P}{Q}$，其中 $P$ 和 $Q$ 是非负整数，且 $Q \ne 0$。你需要计算并输出 $P \cdot Q^{-1} \bmod (10^9+7)$ 的结果。

## 说明/提示

举个例子：
- 在第一个测试用例中，Sakurako 的朋友可以选择这些球对：$(a_1, a_2)$、$(a_1, a_3)$ 和 $(a_2, a_3)$。它们的乘积分别是 $3 \times 2 = 6$、$3 \times 3 = 9$ 和 $3 \times 2 = 6$，所以期望值计算结果为 $\frac{6 + 9 + 6}{3} = 7$。

- 在第二个测试用例中，朋友可以选择的球对有：$(a_1, a_2)$、$(a_1, a_3)$、$(a_1, a_4)$、$(a_2, a_3)$、$(a_2, a_4)$ 和 $(a_3, a_4)$。它们的乘积分别为 $2 \times 2 = 4$、$2 \times 2 = 4$、$2 \times 4 = 8$、$2 \times 2 = 4$、$2 \times 4 = 8$ 和 $2 \times 4 = 8$，所以期望值为 $\frac{4 + 4 + 8 + 4 + 8 + 8}{6} = \frac{36}{6} = 6$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3
3 2 3
4
2 2 2 4
5
1 2 3 4 5```

### 输出

```
7
6
500000012```

# AI分析结果



## 唯一算法分类  
**数论**

---

## 综合分析与结论  
### 核心思路  
题目要求计算数组中所有两元素乘积的期望值，等价于求所有无序对的乘积之和除以总对数。数学推导后，可通过前缀和优化计算乘积总和，再结合模逆元处理分母。

### 关键公式推导  
1. **分子计算**：  
   $\sum_{i<j} a_i a_j = \sum_{j=1}^n \left( a_j \cdot \sum_{i=1}^{j-1} a_i \right)$  
   维护前缀和 $s$，每次遍历到 $a_j$ 时累加 $a_j \cdot s$，再更新 $s$。

2. **分母处理**：  
   总对数 $C(n,2) = \frac{n(n-1)}{2}$，需计算其模 $10^9+7$ 的逆元。

### 解决难点  
- **高效计算乘积和**：前缀和法将时间复杂度从 $O(n^2)$ 降至 $O(n)$。  
- **模逆元计算**：利用费马小定理求分母逆元，避免直接除法。

### 可视化设计  
- **动画流程**：  
  1. 初始化前缀和为 $a_1$，高亮第一个元素。  
  2. 遍历后续元素，用颜色标记当前元素 $a_j$ 和前缀和 $s$，显示 $a_j \cdot s$ 的累加过程。  
  3. 计算分母 $\frac{n(n-1)}{2}$，展示逆元计算步骤。  
  4. 最终结果高亮显示。  
- **复古像素风格**：  
  - 用 8-bit 像素块表示数组元素，前缀和用绿色方块，当前元素用红色。  
  - 音效提示：累加时播放“点击”音效，完成时播放胜利音效。

---

## 题解清单 (≥4星)  
1. **Super_Cube (5星)**  
   - **亮点**：代码简洁高效，直接处理输入流，前缀和与逆元计算一气呵成。  
   - **代码可读性**：变量命名清晰，逻辑紧凑。  
   - **优化**：边读入边计算，避免存储数组，节省空间。  

2. **Drifty (4星)**  
   - **亮点**：使用 C++11 特性（如 `i64` 类型），增强可读性。  
   - **逆元计算**：封装为 lambda 函数，复用性强。  

---

## 最优思路提炼  
1. **前缀和优化**：  
   维护前缀和 $s$，每读入一个元素 $a_j$，累加 $a_j \cdot s$ 到结果，再更新 $s$。  
2. **逆元处理**：  
   分母 $\frac{n(n-1)}{2}$ 的逆元通过快速幂计算，避免浮点误差。

---

## 同类型题与算法套路  
- **常见套路**：  
  1. 两两元素操作总和 → 前缀和或公式变形（如平方和公式）。  
  2. 模数下的除法 → 费马小定理求逆元。  
- **洛谷题目推荐**：  
  1. P2181 对角线（组合数计算）  
  2. P5431 【模板】乘法逆元2（逆元应用）  
  3. P1306 斐波那契公约数（数论性质推导）  

---

## 代码实现（核心逻辑）  
```cpp
int main() {
    int T, n;
    cin >> T;
    while (T--) {
        i64 s, ret = 0;
        cin >> n >> s;  // 初始前缀和为第一个元素
        for (int i = 1, x; i < n; ++i) {
            cin >> x;
            ret = (ret + s * x) % mod;  // 累加当前元素与前缀和的乘积
            s = (s + x) % mod;          // 更新前缀和
        }
        i64 denom = (1ll * n * (n - 1) / 2) % mod;
        i64 inv_denom = qpow(denom, mod - 2);  // 逆元计算
        cout << ret * inv_denom % mod << '\n';
    }
}
```

---

## 可视化与算法演示  
### 复古像素动画设计  
1. **Canvas 初始化**：  
   - 数组元素显示为蓝色方块，前缀和为绿色，当前元素为红色。  
2. **步进动画**：  
   - 每一步显示当前元素与前缀和的乘积，累加到右侧的“总和”区域。  
3. **音效触发**：  
   - 累加时播放 `beep` 音效，逆元计算时播放 `blip` 音效。  
4. **自动推导模式**：  
   - 模拟自动解题流程，逐步高亮计算步骤，类似“贪吃蛇 AI”路径展示。

---

## 个人心得  
- **调试技巧**：注意前缀和的初始值应为第一个元素而非零。  
- **模运算陷阱**：在累加和更新前缀和时需及时取模，防止溢出。

---
处理用时：100.72秒
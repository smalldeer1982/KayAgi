# 题目信息

# She knows...

## 题目描述

D. Pippy 正在为家中的"黑白派对"做准备。他只需要重新粉刷地下室的 floor，该 floor 可表示为 $n \times m$ 的棋盘。

在上次派对后，整个棋盘除 $k$ 个单元格 $(x_1, y_1), (x_2, y_2), \ldots, (x_k, y_k)$ 外均被涂成绿色，这些单元格已被涂成白色或黑色。为了即将到来的派对，D. Pippy 想要将剩余的绿色单元格涂成黑色或白色。同时，他要求重新粉刷后棋盘上相邻颜色不同的单元格对数量为偶数。

形式化地，若定义集合：
$$A = \left\{((i_1, j_1), (i_2, j_2)) \ | \ 1 \le i_1, i_2 \le n, 1 \le j_1, j_2 \le m, i_1+j_1 < i_2+j_2, |i_1-i_2|+|j_1-j_2| = 1, \operatorname{color}(i_1, j_1) \neq \operatorname{color}(i_2, j_2) \right\},$$
其中 $\operatorname{color}(x, y)$ 表示单元格 $(x, y)$ 的颜色，则要求 $|A|$ 为偶数。

请帮助 D. Pippy 计算满足条件的粉刷方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

## 说明/提示

第一个测试案例中，绿色单元格 $(2, 1), (2, 2), (2, 3)$ 共有 $4$ 种合法涂色方案，分别为：$(1, 1, 0)$，$(0, 0, 1)$，$(1, 0, 0)$，$(0, 1, 1)$（颜色按单元格顺序排列），如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2092E/0ff35e90f545116ecc7d2fbe2de16f35bcaedb89.png)  
第二个测试案例中，棋盘已全部涂色且相邻异色对数量为奇数，因此答案为 $0$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 3 6
1 1 0
1 2 1
1 3 0
3 1 1
3 2 0
3 3 1
3 4 12
1 1 0
1 2 1
1 3 0
1 4 1
2 1 1
2 2 0
2 3 1
2 4 0
3 1 0
3 2 1
3 3 0
3 4 1```

### 输出

```
4
0```

# AI分析结果



---

## 唯一算法分类
**数学（奇偶性分析）**

---

## 综合分析与结论

### 核心思路
相邻不同颜色对的奇偶性仅由**边上非角落的格子**（以下称关键格子）的颜色奇偶性决定：
- 关键格子颜色总和的奇偶性决定最终合法方案的存在性
- 若存在未涂色的关键格子，则总能通过调整其中一个的取值使奇偶性合法
- 若无未涂色的关键格子，则直接判断颜色总和的奇偶性

### 解决难点
1. **关键格子识别**：正确判断坐标是否属于边界且非角落
   ```cpp
   bool atBorder(int x, int y) {
       int onEdge = (x == 1) + (x == n) + (y == 1) + (y == m);
       return onEdge == 1; // 恰好处于一条边且非角落
   }
   ```
2. **奇偶性传递分析**：证明中间/角落格子不影响总奇偶性
3. **指数计算优化**：使用快速幂计算 `2^p mod 1e9+7`

### 算法流程
1. **输入处理**：遍历所有预涂色格子，统计关键格子数量 `cnt` 和颜色异或和 `sum`
2. **分类讨论**：
   ```
   if 所有关键格子已被涂色:
       if sum为偶数: 方案数 = 2^(总未涂色格子数)
       else: 方案数 = 0
   else:
       方案数 = 2^(总未涂色格子数-1)
   ```

---

## 题解清单 (≥4星)

### 1. [Collapsarr] ⭐⭐⭐⭐
**亮点**：  
- 通过图示分析颜色变化对奇偶性的影响  
- 详细推导关键格子的决定性作用  
**代码优化**：使用位运算快速计算奇偶性

### 2. [chenxi2009] ⭐⭐⭐⭐
**亮点**：  
- 结论高度凝练，直接给出数学公式  
- 代码极简（仅 28 行）  
**核心代码**：
```cpp
if(p < 2ll * (n + m - 4)) 
    printf("%lld\n",qp(1ll * n * m - k - 1));
else if(s & 1) printf("0\n");
else printf("%lld\n",qp(1ll * n * m - k));
```

### 3. [linjunye] ⭐⭐⭐⭐
**亮点**：  
- 将问题转化为异或运算，提供全新视角  
- 引入二进制状态分析  
**个人心得**："染上边界的格子相当于翻转奇偶性，这让我联想到异或操作的特性"

---

## 最优思路与代码实现

### 关键技巧
1. **奇偶性压缩**：将整个棋盘的状态压缩为关键格子的异或和
2. **快速幂优化**：`O(log MOD)` 时间计算大指数
3. **边界判断优化**：用坐标和边界关系快速判断关键格子

### 核心代码
```cpp
int main() {
    int T; cin >> T;
    while(T--) {
        int n, m, k, cnt = 0, sum = 0;
        cin >> n >> m >> k;
        // 统计关键格子
        while(k--) {
            int x, y, c;
            cin >> x >> y >> c;
            if((x==1||x==n) ^ (y==1||y==m)) { // 关键格子条件
                cnt++;
                sum ^= c;
            }
        }
        // 计算总关键格子数
        int totalEdge = 2*(n + m - 4);
        if(cnt == totalEdge) 
            cout << (sum%2 ? 0 : qpow(2, n*m - totalEdge)) << endl;
        else 
            cout << qpow(2, n*m - cnt - 1) << endl;
    }
}
```

---

## 同类型题目推荐
1. **CF1365E** - 最大子集异或问题（奇偶性分析）
2. **洛谷 P1469** - 找出现奇数次的数（异或特性）
3. **ABC167E** - 组合数学与模运算

---

## 可视化设计

### 像素风格演示
```html
<canvas id="board" width="400" height="400"></canvas>
<script>
// 初始化棋盘
function drawGrid(n, m) {
    // 绘制 n x m 网格，关键格子用黄色高亮
    // 点击未涂色格子切换颜色（黑/白/绿）
    // 右侧实时显示当前奇偶性和方案数
}

// 音效系统
const sfx = {
    flip: new Audio('data:audio/wav;base64,UklGRl9...'), // 翻转音效
    valid: new Audio('data:audio/wav;base64,UklGRkA...') // 合法状态音
};

// 自动演示模式
function autoDemo() {
    // AI 逐步涂色并解释关键格子的影响
    // 展示奇偶性变化与方案数计算过程
}
</script>
```

### 交互特性
- **高亮显示**：关键格子用闪烁黄框标记
- **点击交互**：点击未涂色格子切换颜色，触发音效和方案数更新
- **自动演示**：模拟AI决策过程，逐步展示如何通过关键格子调整奇偶性

---

## 关键难点图示
![](https://cdn.luogu.com.cn/upload/image_hosting/3k321d39.png)  
（红色箭头表示影响奇偶性的关键格子，蓝色表示无关区域）

---

通过这种多维度分析，学习者既能理解数学本质，又能通过可视化交互深化对奇偶性传递机制的理解。

---
处理用时：80.86秒
# 题目信息

# Om Nom and Candies

## 题目描述

桌子上有无限多的红糖果与蓝糖果，每个红糖果重 $ W_{r} $ 克，而每个蓝糖果重 $ W_{b} $ 克。吃一颗红糖果可以获得 $ H_{r} $ 的快乐值，吃一颗蓝糖果可以获得 $ H_{b} $ 的快乐值。

在只能吃 $ C $ 克糖果的前提下，请求出能获得的最大快乐值。

## 样例 #1

### 输入

```
10 3 5 2 3
```

### 输出

```
16
```

# AI分析结果



# 算法分类：数论

## 题解思路与算法分析

### 核心思路：根号分治
**核心公式**：$x \cdot W_r + y \cdot W_b \le C$，最大化 $x \cdot H_r + y \cdot H_b$

#### 解决难点：
1. **大重量物品处理**：若某物品重量 $W \ge \sqrt{C}$，其数量上限为 $\lfloor C/W \rfloor \le \sqrt{C}$，直接枚举该物品数量
2. **小重量物品优化**：当两物品重量均 $\le \sqrt{C}$ 时，根据性价比比（单位重量价值）确定枚举范围
   - 设 $\frac{H_r}{W_r} < \frac{H_b}{W_b}$，则最优解中红糖果数量 $x < W_b$（否则可用蓝糖果替代获得更高价值）

### 关键数学推导
1. **性价比比较**：$H_r \cdot W_b \le H_b \cdot W_r$ 时选择优化蓝糖果枚举
2. **剩余系优化**：利用模运算性质减少计算量，通过枚举余数类找到最优解

---

## 高星题解推荐 (≥4★)

### 1. _Kouki_ (4.5★)
**亮点**：  
- 清晰分治逻辑，完美处理两种边界情况  
- 通过交换操作统一处理方向  
- 完整处理浮点比较精度问题  

**核心代码**：
```cpp
if(W[1] * W[1] >= C) { // 大重量物品处理
    for(int i = 0; i <= C/W[1]; i++)
        sum = i*H[1] + ((C-i*W[1])/W[2] * H[2]);
}
else { // 小重量物品优化
    for(int i = 0; i <= W[2]; i++)
        sum = i*H[1] + ((C-i*W[1])/W[2] * H[2]);
}
```

### 2. run_away (4.2★)
**亮点**：  
- 极简实现，双方向同时枚举  
- 利用对称性减少代码量  
- 显式使用sqrt优化枚举范围  

**核心代码**：
```cpp
for(ll i=0; i<=sqrt(c); ++i) {
    ans = max(ans, i*hr + (c-i*wr)/wb*hb); // 枚举红糖果
    ans = max(ans, i*hb + (c-i*wb)/wr*hr); // 枚举蓝糖果
}
```

### 3. Halberd_Cease (4.0★)
**亮点**：  
- 严谨数学证明替代策略  
- 显式处理性价比比较  
- 完整推导替代条件  

**核心逻辑**：
```cpp
if (hr * wb > hb * wr) swap(...); // 确保性价比顺序
for(int i = 0; i <= wb; i++) // 枚举不超过wb次
```

---

## 最优技巧提炼

### 根号分治策略
1. **重量分界**：以 $\sqrt{C}$ 为阈值区分大/小重量物品  
2. **枚举优化**：  
   - 大重量物品：直接枚举其数量（O(√C)）  
   - 小重量物品：按性价比限制枚举范围（O(√C)）  

### 数学优化
1. **剩余系应用**：通过模运算性质减少计算量  
2. **性价比替代证明**：严格推导枚举上限  

---

## 同类题目推荐
1. P1776 宝物筛选（多重背包+二进制优化）  
2. P2920 Time Management（带限制的背包问题）  
3. P2214 [USACO]哞哞哞（二维约束背包）  

---

## 可视化设计

### 算法演示方案
**动画流程**：  
1. **分治判断**：显示当前物品重量与√C的比较  
   - 大重量物品：红色高亮，显示枚举范围  
   - 小重量物品：蓝色高亮，显示性价比比较过程  
2. **枚举过程**：  
   - 步进显示每个i值对应的x、y计算  
   - 实时更新当前最大快乐值  
3. **结果对比**：并列显示两种分治策略的结果  

**复古游戏化设计**：  
- **8-bit风格界面**：  
  - 物品用像素图标表示  
  - 数值用LED式7段数码管显示  
- **音效设计**：  
  - 正确选择时：8-bit上升音效  
  - 错误选择时：经典FC错误音  
- **自动演示模式**：  
  - AI自动切换分治策略  
  - 展示最优路径推导过程  

**交互控制**：  
```javascript
// 伪代码示例
class CandySolver {
  constructor(C, wr, wb) {
    this.mode = wr > Math.sqrt(C) ? 'BIG' : 'SMALL';
    this.currentStep = 0;
  }
  
  nextStep() { // 单步执行
    if(this.mode === 'BIG') {
      this.calculateBigItemStep();
    } else {
      this.calculateSmallItemStep();
    }
    playSound('step');
  }
}
```

---

## 核心代码实现

### 根号分治标准实现
```cpp
long long solve(int C, int Hr, int Hb, int Wr, int Wb) {
    if(Wr < Wb) swap(Hr, Hb), swap(Wr, Wb);
    long long ans = 0;
    
    // 大重量物品处理
    if(1LL * Wr * Wr >= C) {
        for(int i=0; i<=C/Wr; ++i)
            ans = max(ans, 1LL*i*Hr + (C-i*Wr)/Wb*Hb);
    } 
    // 小重量物品优化
    else { 
        if(1LL*Hr*Wb < 1LL*Hb*Wr) 
            swap(Hr, Hb), swap(Wr, Wb);
        for(int i=0; i<=Wb; ++i)
            ans = max(ans, 1LL*i*Hr + (C-i*Wr)/Wb*Hb);
    }
    return ans;
}
```

---

## 总结
本题通过巧妙的根号分治策略，将时间复杂度从O(C)优化至O(√C)。关键点在于识别物品重量的分布特征，并结合数学证明限制枚举范围。该技巧可推广至类似的双物品约束优化问题，是处理大范围背包问题的经典范式。

---
处理用时：75.56秒
# 题目信息

# Om Nom and Candies

## 题目描述

桌子上有无限多的红糖果与蓝糖果，每个红糖果重 $ W_{r} $ 克，而每个蓝糖果重 $ W_{b} $ 克。吃一颗红糖果可以获得 $ H_{r} $ 的快乐值，吃一颗蓝糖果可以获得 $ H_{b} $ 的快乐值。

在只能吃 $ C $ 克糖果的前提下，请求出能获得的最大快乐值。

## 样例 #1

### 输入

```
10 3 5 2 3
```

### 输出

```
16
```

# AI分析结果



# 解题分析

## 算法分类
**根号分治**

---

## 题解思路与核心难点

### 核心思路
1. **根号分治**：根据糖果重量是否超过 $\sqrt{C}$ 分两种情况处理：
   - **情况一**：若某糖果重量 $W \geq \sqrt{C}$，直接枚举该糖果的数量（最多 $\sqrt{C}$ 次）。
   - **情况二**：若两者重量均 $\leq \sqrt{C}$，则比较性价比（快乐值/重量），确定优势糖果后枚举另一糖果的数量（最多 $\sqrt{C}$ 次）。

2. **性价比优化**：当两种糖果均轻时，按性价比排序，优势糖果尽可能多取，另一糖果枚举 $0$ 到其重量上限的值。

### 解决难点
- **时间复杂度控制**：通过分治将复杂度降至 $O(\sqrt{C})$。
- **枚举边界处理**：正确处理剩余重量计算与循环终止条件，避免超时。

---

## 题解评分（≥4星）

### ⭐⭐⭐⭐ [题解一] _Kouki_
- **亮点**：清晰的根号分治逻辑，代码结构严谨，变量交换处理正确。
- **代码**：正确处理重量优先与性价比排序，双重循环覆盖所有可能情况。

### ⭐⭐⭐⭐ [题解三] run_away
- **亮点**：极简代码实现，同时枚举红蓝两种糖果，暴力覆盖边界。
- **不足**：未显式处理性价比，但通过双向枚举确保正确性。

### ⭐⭐⭐⭐ [题解四] Halberd_Cease
- **亮点**：根号分治与性价比比较结合紧密，代码注释清晰，逻辑流畅。

---

## 最优思路提炼
1. **分治条件**：根据重量是否超过 $\sqrt{C}$ 决定枚举策略。
2. **性价比排序**：当重量均小时，优先选择单位重量快乐值更高的糖果，仅需枚举另一糖果的 $0 \sim W_{\text{优势}}$ 次。
3. **剩余空间计算**：对每种枚举值，快速计算另一糖果的最大可能数量。

---

## 同类型题与算法套路
- **相似题目**：  
  - 洛谷 P1833（混合背包问题）  
  - 洛谷 P1466（二维费用背包+根号优化）  
  - Codeforces 755F（贪心+分块枚举）  

---

## 推荐洛谷题目
1. **P1833** - 混合背包问题（容量分治优化）  
2. **P1466** - 集合Subset（根号分治+计数）  
3. **P2217** - 分割商品（贪心+数学优化）  

---

## 可视化与动画设计

### 算法演示方案
1. **动态分步**：  
   - **步骤1**：显示当前处理的分支（重量大/性价比高）。  
   - **步骤2**：枚举变量 `i`（红/蓝糖果数量），高亮当前 `i` 值。  
   - **步骤3**：计算剩余重量 `C - i*W`，并显示另一糖果数量 `j`。  
   - **步骤4**：更新最大快乐值，用颜色标记是否刷新记录。

2. **复古像素风格**：  
   - **颜色方案**：红/蓝糖果用 8-bit 红蓝方块表示，背景灰阶网格。  
   - **音效**：每次枚举步进播放“滴”声，最大值更新时播放“升级”音效。  

3. **交互控制**：  
   - **速度调节**：滑动条控制枚举速度（1x/10x/100x）。  
   - **AI 自动演示**：自动选择最优分支，模拟人类决策逻辑。

---

## 关键代码实现
```cpp
// 题解一核心逻辑（_Kouki_）
void solve() {
    if (W[1] * W[1] >= C) { // 处理重量大的糖果
        for (int i = 0; i <= C/W[1]; i++) {
            sum = i * H[1] + ((C - i*W[1]) / W[2] * H[2]);
            maxn = max(maxn, sum);
        }
    } else { // 处理性价比
        if (H[1]/W[1] < H[2]/W[2]) swap(H[1], H[2]), swap(W[1], W[2]);
        for (int i = 0; i <= W[2]; i++) { // 枚举非优势糖果
            sum = i * H[1] + ((C - i*W[1]) / W[2] * H[2]);
            maxn = max(maxn, sum);
        }
    }
}
```

---

## 个人心得摘录
> “枚举时注意变量交换后的性价比判断，避免逻辑反序。” —— _Kouki_  
> “暴力枚举到 $\sqrt{C}$ 即可覆盖所有边界情况。” —— run_away  

---

## 复古游戏化动画代码片段
```javascript
// 在Canvas绘制糖果枚举过程（伪代码）
function drawStep(i, j, maxValue) {
    ctx.fillStyle = '#FF0000'; // 红色糖果
    ctx.fillRect(i * 10, 50, 8, 8); // 绘制当前i值
    ctx.fillStyle = '#0000FF'; // 蓝色糖果
    ctx.fillRect(j * 10, 70, 8, 8); // 绘制当前j值
    if (currentValue > maxValue) playSound('upgrade'); // 音效反馈
}
```

---
处理用时：98.22秒
# 题目信息

# Rudolf and Subway

## 题目描述

建桥对伯纳德没有帮助，他去哪里都迟到。然后鲁道夫决定教他乘坐地铁。

鲁道夫将地铁地图描绘成一个无向连接图，没有自循环，其中顶点代表车站。任何一对顶点之间最多有一条边。

如果可以绕过其他站点，则可以通过一条边直接在相应站点之间移动，则两个顶点通过一条边连接。鲁道夫和伯纳德居住的城市的地铁有颜色符号。这意味着站点之间的任何边缘都具有特定的颜色。特定颜色的边缘共同形成一条地铁线。地铁线不能包含未连接的边，并形成给定地铁图的连接子图。

地铁地图示例如图所示。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941G/7c6e3ab76399bc5859a6a1ea202bbed5b214c151.png)
 鲁道夫声称，如果这条路线通过最少数量的地铁线路，这条路线将是最佳的。

帮助 Bernard 确定给定出发站和目的地站的最小数量。

## 说明/提示

第一个示例的地铁图如图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941G/7c6e3ab76399bc5859a6a1ea202bbed5b214c151.png)

在第一个测试用例中，从顶点 $ 1 $ 到顶点 $ 3 $ ，可以沿着路径行进 $ 1 \rightarrow 2 \rightarrow 3 $ , 仅使用绿线。

在第二个测试用例中，从顶点 $ 1 $ 到顶点 $ 6 $ , 你可以沿着这条路旅行 $ 1 \rightarrow 2 \rightarrow 3 \rightarrow 6 $ , 使用绿线和蓝线。

在第三个测试用例中，不需要从顶点 $ 6 $ 移动到同一个顶点，所以行数为 $ 0 $ 。

在第四个测试用例中，图的所有边都属于一条线，所以答案是 $ 1 $ 。

## 样例 #1

### 输入

```
5
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
1 3
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
1 6
6 6
1 2 1
2 3 1
5 2 2
2 4 2
4 6 2
3 6 3
6 6
4 3
1 2 1
1 3 1
4 1 1
2 3
6 7
1 2 43
1 3 34
4 6 43
6 3 43
2 3 43
5 3 43
4 5 43
1 6```

### 输出

```
1
2
0
1
1```

## 样例 #2

### 输入

```
3
7 9
2 4 1
3 6 1
2 3 5
1 7 1
4 7 1
2 5 4
5 4 4
3 4 1
3 7 1
5 3
6 5
6 5 83691
4 1 83691
5 4 83691
3 2 83691
4 3 83691
5 1
6 7
6 1 83691
6 2 83691
2 5 83691
5 6 83691
2 3 83691
5 4 83574
3 5 83691
1 4```

### 输出

```
2
1
2```

# AI分析结果



## 唯一算法分类
**分层图 / 虚拟节点建模的最短路径**

---

## 题解思路与算法要点

### 核心思路对比
各题解均采用**颜色虚拟节点**的建图技巧，差异主要体现在实现细节：
1. **虚拟节点类型**：所有题解将每条边的颜色映射为虚拟节点（如 2huk 题解中的 `col[w]` 节点）
2. **边权设置**：
   - 原节点 → 颜色节点：边权为 1（上车换乘）
   - 颜色节点 → 原节点：边权为 0（下车无需换乘）
3. **搜索算法**：
   - 0-1 BFS（双端队列优化）：处理边权 0/1 的最优解法，时间复杂度 O(N+M)
   - Dijkstra：适用于更通用场景，但效率略低

### 解决难点
1. **换乘次数计算**：通过虚拟节点的边权设计，将换乘次数转化为路径权重
2. **颜色节点复用**：使用 `map` 对颜色编号动态分配虚拟节点 ID，避免颜色值过大导致内存浪费
3. **稀疏图优化**：部分题解通过 `pair<点,颜色>` 的哈希表避免重复建边

---

## 题解评分（≥4星）

### [2huk] ⭐⭐⭐⭐⭐
- **亮点**：最简明的虚拟节点建模，清晰的 0-1 BFS 实现，代码可读性极佳
- **核心代码**：
  ```cpp
  g[u].push_back({col[w], 1});  // 原节点 → 颜色节点
  g[col[w]].push_back({u, 0});  // 颜色节点 → 原节点
  ```

### [chenxumin1017] ⭐⭐⭐⭐
- **亮点**：通过颜色连通块特性，将答案转化为最短路径长度/2，实现极简 BFS
- **核心思路**：`点 ↔ 颜色` 双向建边，最终路径需往返虚拟节点，故长度除以2

### [MrPython] ⭐⭐⭐⭐
- **亮点**：类比地铁进出站的现实场景，赋予虚拟节点直观意义（站厅层与站台层）
- **实现技巧**：用 `~0` 表示站厅层，其他颜色为站台层，贴近实际换乘流程

---

## 最优思路提炼
1. **虚拟节点建模**：将颜色作为中间节点，分割原图中的换乘行为
2. **0-1 BFS优化**：利用双端队列处理 0/1 边权，时间复杂度优于 Dijkstra
3. **动态颜色映射**：`map` 动态分配颜色节点 ID，适应稀疏颜色分布

---

## 同类型题推荐
1. [ARC061E - すぬけ君の地下鉄旅行](https://www.luogu.com.cn/problem/AT_arc061_c)：颜色虚拟节点建模的经典题
2. [P4568 [JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568)：分层图思想
3. [P1266 速度限制](https://www.luogu.com.cn/problem/P1266)：状态扩展建模

---

## 可视化设计

### 动画方案
1. **节点展示**：
   - 原节点：蓝色圆形
   - 颜色节点：绿色方形（内部标注颜色值）
2. **边权显示**：
   - 黑线（边权0）：颜色节点 → 原节点
   - 红线（边权1）：原节点 → 颜色节点
3. **搜索过程**：
   - 双端队列用左右滑动列表展示，黄色高亮当前处理的节点
   - 已访问节点变为灰色，路径边标红

### 复古像素风格
```javascript
// Canvas 绘制示例
function drawNode(ctx, x, y, isColorNode) {
  ctx.fillStyle = isColorNode ? '#8bc34a' : '#2196f3';
  ctx.beginPath();
  if(isColorNode) {
    ctx.fillRect(x-8, y-8, 16, 16); // 方形颜色节点
  } else {
    ctx.arc(x, y, 10, 0, Math.PI*2); // 圆形原节点
  }
  ctx.fill();
}
```

### 音效设计
- **换乘（边权1）**：8-bit "哔"声（高频短音）
- **直达（边权0）**：低音鼓点
- **找到终点**：经典 FC 过关音效

---

## 核心代码实现
```cpp
// 虚拟节点建图核心逻辑
map<int, int> col; // 颜色 → 虚拟节点ID
while(m--) {
    int u, v, w;
    cin >> u >> v >> w;
    if(!col.count(w)) col[w] = ++cnt; // 动态分配ID
    // 原节点 → 颜色节点（换乘）
    g[u].push_back({col[w], 1});
    g[v].push_back({col[w], 1});
    // 颜色节点 → 原节点（无需换乘）
    g[col[w]].push_back({u, 0});
    g[col[w]].push_back({v, 0});
}

// 0-1 BFS 实现
deque<int> q;
q.push_back(s);
dis[s] = 0;
while(!q.empty()) {
    int u = q.front(); q.pop_front();
    if(u == t) break;
    for(auto [v, w] : g[u]) {
        if(dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w;
            w ? q.push_back(v) : q.push_front(v);
        }
    }
}
```

---
处理用时：67.46秒
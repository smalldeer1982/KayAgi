# 题目信息

# Non Prime Tree

## 题目描述

给你一棵拥有 $n$ 个顶点的树。

你的任务是构造一个包含 $n$ 个不同整数的数组，这些整数从 $1$ 到 $2 \cdot n$ 分别取值。同时要求对于树中的任意一条边 $u_i \leftrightarrow v_i$，对应的数组元素差值 $|a_{u_i} - a_{v_i}|$ 不是质数。

请你找出任意一个符合以上条件的数组，如果不存在这样的数组，请输出 $-1$。

## 说明/提示

如下图所示的答案中，用对应数组 $a$ 的元素替代了顶点编号：

第一组数据的树结构 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/d6a56c20ebd42ea20ac170d596c01c0583a1b831.png)  
第二组数据的树结构 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/8328682bcf4d0da5fcbe8de4a0054b43d22d093e.png)

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
5
1 2
2 3
2 4
3 5
7
1 2
1 3
2 4
3 5
3 6
3 7```

### 输出

```
2 10 1 6 5 
8 7 12 1 4 6 3```

# AI分析结果



### 唯一算法分类
**构造算法**

---

### 综合分析与结论
**核心思路**：  
所有题解均围绕“相邻节点差值不能为质数”这一核心条件进行构造。主流解法分为两类：  
1. **黑白染色 + 数值分段分配**（lfxxx、hgcnxn）  
   - 对树进行黑白染色，将黑点分配前半段偶数（2,4,6...），白点分配后半段偶数（2n, 2n-2...）  
   - 若存在异色不相邻节点，将最大黑点与最小白点隔开  
   - 菊花图特判：中心节点赋值为2，外围节点用奇数1和大偶数  
2. **贪心遍历 + 奇偶性控制**（bsdsdb、BigSmall_En）  
   - 深度优先遍历时，动态选择与父节点差值最小的合法偶数值  
   - 确保子树数值连续递增，差值均为非质数  

**解决难点**：  
- 避免差值2（唯一偶质数）  
- 菊花图等特殊结构的灵活处理  
- 证明数值范围始终在[1, 2n]内  

**可视化设计**：  
- **树形结构绘制**：Canvas绘制树形图，黑白染色节点用不同底色  
- **数值分配动画**：按DFS/BFS顺序逐步填充数值，高亮当前边及其差值  
- **菊花图特判演示**：中心节点闪烁提示，外围数值动态调整  
- **音效与反馈**：合法分配时播放清脆音效，非法差值时播放警告音  

---

### 题解清单（≥4星）
1. **lfxxx（★★★★☆）**  
   - **亮点**：黑白染色分类讨论，菊花图特判逻辑严密  
   - **代码**：清晰分离染色与数值分配，支持多测试用例  

2. **bsdsdb（★★★★☆）**  
   - **亮点**：数学归纳法证明贪心策略，严格保证数值范围  
   - **代码**：简洁的递归DFS实现  

3. **hgcnxn（★★★★☆）**  
   - **亮点**：详细注释与分步说明，特判逻辑易于理解  

---

### 最优思路提炼
**关键技巧**：  
1. **奇偶性控制**：仅使用偶数值（除菊花图外），确保差值≥4  
2. **分段分配**：黑点与白点分别占据偶数区间的不同段  
3. **菊花图特判**：中心节点赋2，外围交替使用1与大偶数  
4. **贪心遍历优化**：优先分配连续偶数值，跳过差值2  

**同类型题套路**：  
- 树结构数值分配问题  
- 相邻节点约束型构造  
- 奇偶性分类讨论  

---

### 推荐题目
1. **CF1092D2**（树形结构奇偶构造）  
2. **CF1353E**（相邻节点约束与奇偶性）  
3. **Luogu P1351**（权值分配与相邻约束）  

---

### 代码片段（lfxxx解法核心）
```cpp
void dfs(int u, int cl, int lst) {
    vec[cl].push_back(u);
    col[u] = cl;
    for (int v : E[u]) {
        if (v != lst) dfs(v, cl ^ 1, u);
    }
}

// 菊花图检测与处理
for (int i = 1; i <= n; i++) {
    if (E[i].size() == n - 1) { // 中心节点
        ans[i] = 1;
        ans[E[i][0]] = 0;
        for (int j = 1; j < E[i].size(); j++) {
            ans[E[i][j]] = j + 2;
        }
        // 输出处理...
        return;
    }
}
```

---

### 可视化设计要点
**复古像素风格演示**：  
- **颜色方案**：黑节点深蓝，白节点浅绿，当前操作节点红色边框  
- **动画流程**：  
  1. 树形图逐层展开，节点初始为灰色  
  2. 黑白染色阶段：节点渐变为对应颜色  
  3. 数值填充：从根节点开始，按DFS顺序弹出数值标签  
  4. 边差值检查：高亮当前边，显示|a-u - a-v|并标记是否合法  
- **音效**：  
  - 合法分配：8-bit "叮"声  
  - 非法差值：低沉蜂鸣  
  - 菊花图特判：特殊胜利音效  

**交互控制**：  
- 步进按钮：单步执行构造过程  
- 速度滑块：调整动画速度（0.5x~2x）  
- 模式切换：普通构造 vs 菊花图特判演示

---
处理用时：106.05秒
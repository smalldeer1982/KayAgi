# 题目信息

# Local Construction

## 题目描述

在数组 $b_1, b_2, \ldots, b_m$ 中，元素 $b_i$（$1 \le i \le m$）是局部最小值当且仅当满足以下至少一个条件：
- $2 \le i \le m - 1$ 且 $b_i < b_{i - 1}$ 且 $b_i < b_{i + 1}$，或
- $i = 1$ 且 $b_1 < b_2$，或
- $i = m$ 且 $b_m < b_{m - 1}$。

类似地，元素 $b_i$（$1 \le i \le m$）是局部最大值当且仅当满足以下至少一个条件：
- $2 \le i \le m - 1$ 且 $b_i > b_{i - 1}$ 且 $b_i > b_{i + 1}$，或
- $i = 1$ 且 $b_1 > b_2$，或
- $i = m$ 且 $b_m > b_{m - 1}$。

注意，对于只有一个元素的数组，局部最小值和局部最大值没有定义。

给定一个隐藏的排列 $^{\text{∗}}$ $p$，其长度为 $n$。对该排列交替执行以下两种操作，从操作 1 开始，直到 $p$ 中只剩一个元素：
- 操作 1 —— 删除 $p$ 中所有不是局部最小值的元素。
- 操作 2 —— 删除 $p$ 中所有不是局部最大值的元素。

具体来说，在每次奇数轮迭代时执行操作 1，在每次偶数轮迭代时执行操作 2，直到 $p$ 中只剩一个元素。

对于每个下标 $i$（$1 \le i \le n$），设 $a_i$ 为元素 $p_i$ 被删除的轮次编号，若未被删除则设为 $-1$。

可以证明，最多经过 $\lceil \log_2 n \rceil$ 轮迭代后 $p$ 中只剩一个元素（即 $a_i \le \lceil \log_2 n \rceil$）。

给定数组 $a_1, a_2, \ldots, a_n$，你的任务是构造任意一个满足数组 $a$ 的排列 $p$。

$^{\text{∗}}$ 长度为 $n$ 的排列是指由 $1$ 到 $n$ 的 $n$ 个不同整数按任意顺序组成的数组。例如，$[2,3,1,5,4]$ 是一个排列，但 $[1,2,2]$ 不是（因为 $2$ 出现了两次），$[1,3,4]$ 也不是（因为 $n=3$ 但出现了 $4$）。

## 说明/提示

在第一个测试用例中，对排列 $[3, 2, 1]$ 执行的操作如下：
1. $[3, 2, 1]$ 的唯一局部最小值是 $1$，因此删除 $3$ 和 $2$。此时只剩一个元素，过程终止。
这满足数组 $a = [1, 1, -1]$，因为 $p_1$ 和 $p_2$ 在第 1 轮被删除，而 $p_3$ 未被删除。

在第二个测试用例中，对排列 $[4, 3, 5, 1, 2]$ 执行的操作如下：
1. $[4, 3, 5, 1, 2]$ 的局部最小值是 $3$ 和 $1$，因此删除 $4$、$5$ 和 $2$。
2. $[3, 1]$ 的唯一局部最大值是 $3$，因此删除 $1$。此时只剩一个元素，过程终止。
这满足数组 $a = [1, -1, 1, 2, 1]$，因为 $p_1$、$p_3$ 和 $p_5$ 在第 1 轮被删除，$p_4$ 在第 2 轮被删除，$p_2$ 未被删除。

在第三个测试用例中，对排列 $[6, 7, 2, 4, 3, 8, 5, 1]$ 执行的操作如下：
1. 局部最小值是 $6$、$2$、$3$ 和 $1$，因此删除 $7$、$4$、$8$ 和 $5$。
2. 局部最大值是 $6$ 和 $3$，因此删除 $2$ 和 $1$。
3. 局部最小值是 $3$，因此删除 $6$。此时只剩一个元素，过程终止。

在第四个测试用例中，一个满足条件的排列是 $[6, 5, 2, 1, 3, 4, 7]$。$1$ 是唯一的局部最小值，因此它会在第一轮后保留。注意，其他排列也可能满足条件，例如 $[6, 4, 3, 1, 2, 5, 7]$ 也是正确的解。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
7
3
1 1 -1
5
1 -1 1 2 1
8
3 1 2 1 -1 1 1 2
7
1 1 1 -1 1 1 1
5
1 1 1 1 -1
5
-1 1 1 1 1
5
-1 1 2 1 2```

### 输出

```
3 2 1
4 3 5 1 2
6 7 2 4 3 8 5 1
6 5 2 1 3 4 7
5 4 3 2 1
1 2 3 4 5
4 5 2 3 1```

# AI分析结果



## 算法分类
构造

## 题解思路与算法要点
该题解通过逆向构造排列p，利用每一轮被删除元素的相对大小关系，分轮次填入连续的数。核心要点如下：

1. **轮次分组**：将每个元素按其被删除的轮次分组，未被删除的元素单独处理。
2. **分界点处理**：以未被删除的元素位置为分界点，左边按降序、右边按升序填入数值。
3. **奇偶轮次差异**：
   - 奇数轮（删非局部最小值）：填入较大的数值，确保被删除的元素无法成为局部最小值。
   - 偶数轮（删非局部最大值）：填入较小的数值，确保被删除的元素无法成为局部最大值。

## 解决难点
- **相对大小关系**：确保每一轮填入的数满足局部极值的条件，而无需模拟实际删除过程。
- **分界点处理**：正确划分左右两部分的填入顺序，避免交叉干扰。
- **高效构造**：通过线性分组和双向指针填充，实现O(n)时间复杂度。

## 最优思路提炼
1. **逆向构造**：从删除轮次反向确定元素大小关系。
2. **分界点划分**：以保留元素为界，左右分别处理。
3. **奇偶轮填充策略**：
   - 奇数轮从右向左填大数（保证无法成为局部最小值）
   - 偶数轮从左向右填小数（保证无法成为局部最大值）

## 核心代码实现
```cpp
void solve() {
    int n; cin >> n;
    vector<int> a(n+1);
    vector<vector<int>> v(n+2); // 按轮次分组
    int last_remain = 0;

    for(int i=1; i<=n; ++i) {
        cin >> a[i];
        if(a[i] == -1) last_remain = i;
        else v[a[i]].push_back(i);
    }

    vector<int> ans(n+1);
    int left = 1, right = n;

    for(int round=1; ;++round) {
        if(round%2 == 1) { // 奇数轮填大数
            // 处理分界点左侧（降序填右指针）
            for(int i=0; i<v[round].size() && v[round][i]<last_remain; ++i) 
                ans[v[round][i]] = right--;
            // 处理分界点右侧（逆序后降序填）
            reverse(v[round].begin(), v[round].end());
            for(auto &x : v[round]) 
                if(x > last_remain) ans[x] = right--;
        } else { // 偶数轮填小数
            // 处理分界点左侧（升序填左指针）
            for(int i=0; i<v[round].size() && v[round][i]<last_remain; ++i)
                ans[v[round][i]] = left++;
            // 处理分界点右侧（逆序后升序填）
            reverse(v[round].begin(), v[round].end());
            for(auto &x : v[round])
                if(x > last_remain) ans[x] = left++;
        }
        if(left > right) break;
    }
    ans[last_remain] = left;

    for(int i=1; i<=n; ++i) cout << ans[i] << " ";
    cout << endl;
}
```

## 可视化算法设计
**像素化演示方案**：
1. **网格布局**：将排列p的构造过程显示为8-bit风格的数值填充动画。
2. **颜色标记**：
   - 红色：当前正在处理的轮次
   - 绿色：已填入数值的区域
   - 黄色：分界点位置
3. **音效设计**：
   - 填入数值时播放「嘟」声
   - 轮次切换时播放「叮」声
4. **动画控制**：
   - 空格键暂停/继续
   - 方向键调整播放速度
   - 鼠标悬停查看元素详细信息

## 相似题目推荐
1. [P2894 山峰序列](https://www.luogu.com.cn/problem/P2894)
2. [P1439 构造排列](https://www.luogu.com.cn/problem/P1439)
3. [P6184 局部极值序列](https://www.luogu.com.cn/problem/P6184)

---
处理用时：79.25秒
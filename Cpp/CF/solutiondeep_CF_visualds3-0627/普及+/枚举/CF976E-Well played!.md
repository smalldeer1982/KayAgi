# 题目信息

# Well played!

## 题目描述

Max 最近沉迷于一款打怪游戏《赛某号》。现在，他正在参加赛某号的春季联赛。

他有 $n$ 只精灵。每只精灵都有对应的生命值 $hp_i$ 和攻击值 $dmg_i$。在比赛过程中，Max 可以借助巴拉拉小魔仙之力，说出这两种咒语：

1. “乌卡拉！血量！加倍！“意即将当前精灵的生命值加倍。（使得 $hp_i \gets 2\times hp_i$）

2. “乌卡拉！生命之力！”意即将当前精灵的生命值赋给当前精灵的攻击值。（使得 $dmg_i\gets hp_i$）

Max 当然不能无限使用这两种咒语。在一局游戏中，他可以使用第一种咒语 $a$ 次，第二次咒语 $b$ 次。由于Max 购买了超级 Nono，所以这两种咒语都可以被多次用在同一精灵身上，且咒语的使用顺序没有限制。Max 可以不用完所有的咒语。

Max 非常希望通过使用这些咒语使得自己的精灵战斗群的攻击值达到最大。现在，Max 想知道这个最大值。


输入第 $2$ 行到第 $n+1$ 行，每行两个整数 $hp$，$dmg$。第 $i$ 行表示第 $i-1$ 个精灵的生命值和攻击值。

## 样例 #1

### 输入

```
2 1 1
10 15
6 1
```

### 输出

```
27
```

## 样例 #2

### 输入

```
3 0 3
10 8
7 11
5 2
```

### 输出

```
26
```

# AI分析结果



---

## 算法分类
**贪心算法**

---

## 题解思路与核心分析

### **核心思路**
1. **贪心策略证明**：所有 a 次翻倍机会必须集中在一个精灵上（数学证明显示分散使用必然劣于集中使用）。
2. **替换操作优先级**：按 `hp-dmg` 降序排序，优先对差值最大的精灵使用替换咒语。
3. **动态调整**：当替换次数用完时，尝试用未被选中的精灵替换已选中的最弱增益项，以最大化总攻击值。

### **难点与解决方案**
- **翻倍机会分配**：通过数学推导证明集中分配最优，避免暴力枚举所有可能。
- **替换次数调整**：当替换次数用尽后，需动态比较当前精灵翻倍后的增益是否超过已选精灵的最小增益。
- **边界处理**：处理 `b=0` 或 `a=0` 的特殊情况，确保代码鲁棒性。

---

## 题解评分（≥4星）

### **题解1：Echidna（4星）**
- **亮点**：数学证明完整，代码逻辑清晰，通过 `delta` 数组预计算所有可能的增益。
- **实现细节**：排序后分情况处理，动态维护增益最大值。
- **代码可读性**：结构清晰，变量命名合理。

### **题解3：JWRuixi（4星）**
- **亮点**：简洁高效的枚举策略，正确处理替换次数用尽后的调整。
- **实现细节**：通过 `sum` 变量动态维护替换后的总攻击值，枚举时考虑两种场景。
- **代码优化**：使用位运算快速计算翻倍值，避免冗余计算。

### **题解4：kkio（4星）**
- **亮点**：极简代码实现，边界处理清晰。
- **关键技巧**：直接计算替换后的最大值，通过 `trm` 变量处理替换次数用尽后的补偿。

---

## 最优思路提炼

### **关键步骤**
1. **排序与替换选择**：按 `hp-dmg` 降序排序，选择前 `b` 个增益最大的精灵替换。
2. **翻倍集中策略**：枚举每个精灵，计算将其 `hp` 翻倍 `a` 次后的可能最大增益。
3. **动态调整替换列表**：若替换次数用尽，需比较当前精灵的增益是否超过已选列表中的最小增益项。

### **代码实现片段**
```cpp
// 核心逻辑：JWRuixi 的代码片段
sort(q + 1, q + n + 1); // 按 hp-dmg 降序排序
for (int i = 1; i <= n; i++) {
    if (i <= b) ans += max(q[i].hp, q[i].dmg); // 选择前 b 个替换
    else ans += q[i].dmg;
}
int max_ans = ans;
for (int i = 1; i <= n; i++) {
    if (i <= b) {
        // 当前精灵已被替换，计算翻倍后的增益
        int new_hp = q[i].hp * (1 << a);
        max_ans = max(max_ans, ans - max(q[i].hp, q[i].dmg) + new_hp);
    } else {
        // 未被替换的精灵，需替换掉已选中的最小增益项
        int new_hp = q[i].hp * (1 << a);
        int compensation = (b > 0) ? (q[b].dmg - max(q[b].hp, q[b].dmg)) : 0;
        max_ans = max(max_ans, ans - q[i].dmg + new_hp + compensation);
    }
}
```

---

## 同类题目与拓展

### **类似算法套路**
- **资源集中分配**：如背包问题中集中使用容量提升道具。
- **贪心排序策略**：如任务调度中选择收益最高的任务优先执行。

### **推荐题目**
1. **P1090 合并果子**：贪心选择最小代价合并。
2. **P1223 排队接水**：按时间升序排列最小化总等待时间。
3. **P3819 松江1843路**：区间覆盖问题中的贪心选择。

---

## 可视化设计

### **动画方案**
1. **排序可视化**：用颜色渐变条展示 `hp-dmg` 的排序过程，高亮前 `b` 项。
2. **翻倍操作演示**：选定一个精灵后，动态显示其 `hp` 翻倍过程（如数值增长动画）。
3. **替换调整逻辑**：当尝试替换已选列表外的精灵时，用红色箭头标记被替换的最小增益项。

### **游戏化交互**
- **像素风格界面**：精灵用 8-bit 像素块表示，不同颜色区分选中状态。
- **音效反馈**：翻倍时播放“升级”音效，替换时播放“切换”音效。
- **自动演示模式**：AI 逐步展示最优决策路径，用户可暂停观察中间状态。

---

## 总结
通过贪心策略和数学证明，本题的核心在于集中资源分配与动态调整替换列表。可视化设计通过交互式动画帮助理解关键逻辑，适合教学与算法演示。

---
处理用时：154.79秒
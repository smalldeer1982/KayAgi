# 题目信息

# Reverse Sort Sum

## 题目描述

Suppose you had an array $ A $ of $ n $ elements, each of which is $ 0 $ or $ 1 $ .

Let us define a function $ f(k,A) $ which returns another array $ B $ , the result of sorting the first $ k $ elements of $ A $ in non-decreasing order. For example, $ f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0] $ . Note that the first $ 4 $ elements were sorted.

Now consider the arrays $ B_1, B_2,\ldots, B_n $ generated by $ f(1,A), f(2,A),\ldots,f(n,A) $ . Let $ C $ be the array obtained by taking the element-wise sum of $ B_1, B_2,\ldots, B_n $ .

For example, let $ A=[0,1,0,1] $ . Then we have $ B_1=[0,1,0,1] $ , $ B_2=[0,1,0,1] $ , $ B_3=[0,0,1,1] $ , $ B_4=[0,0,1,1] $ . Then $ C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4] $ .

You are given $ C $ . Determine a binary array $ A $ that would give $ C $ when processed as above. It is guaranteed that an array $ A $ exists for given $ C $ in the input.

## 说明/提示

Here's the explanation for the first test case. Given that $ A=[1,1,0,1] $ , we can construct each $ B_i $ :

- $ B_1=[\color{blue}{1},1,0,1] $ ;
- $ B_2=[\color{blue}{1},\color{blue}{1},0,1] $ ;
- $ B_3=[\color{blue}{0},\color{blue}{1},\color{blue}{1},1] $ ;
- $ B_4=[\color{blue}{0},\color{blue}{1},\color{blue}{1},\color{blue}{1}] $

 And then, we can sum up each column above to get $ C=[1+1+0+0,1+1+1+1,0+0+1+1,1+1+1+1]=[2,4,2,4] $ .

## 样例 #1

### 输入

```
5
4
2 4 2 4
7
0 3 4 2 3 2 7
3
0 0 0
4
0 0 0 4
3
1 2 3```

### 输出

```
1 1 0 1 
0 1 1 0 0 0 1 
0 0 0 
0 0 0 1 
1 0 1```

# AI分析结果



**唯一算法分类：** 贪心构造与树状数组/差分数组

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - 确定原数组 `A` 中 `1` 的个数 `k`（由 `sum(C)/n` 得到）。  
   - 从右向左构造 `A`，每次处理位置 `i` 时，通过当前 `C[i]` 的值判断 `A[i]` 是 `1` 或 `0`，并调整前面的 `C` 值以模拟贡献。

2. **关键步骤**  
   - **逆向构造**：从 `i = n` 到 `i = 1`，利用树状数组/差分数组维护 `C` 的当前值。  
   - **区间更新**：若 `A[i]` 为 `1`，则其在前 `i` 次排序中会影响区间 `[i−k+1, i−1]` 的 `C` 值，需将这些位置减 `1`。  
   - **动态调整 `k`**：每确定一个 `A[i] = 1`，`k` 减少 `1`，保证后续计算正确。

3. **解决难点**  
   - **高效区间操作**：使用树状数组或差分数组实现 `O(n log n)` 的区间加减与单点查询。  
   - **逆向思维**：从后往前推导，确保每一步的决策不影响后续处理。

---

### **题解评分 (≥4星)**

1. **王熙文的题解（4星）**  
   - **亮点**：树状数组维护差分数组，清晰展示区间更新逻辑，代码结构严谨。  
   - **代码片段**：  
     ```cpp
     void solve() {
         // ... 初始化树状数组 ...
         for (int i = n; i >= 1; --i) {
             a[i] = (get_node(i) == i);
             if (a[i]) --k;
             update(i - k + 1, i - 1, -1); // 区间减1
         }
     }
     ```

2. **LinkZelda的题解（4星）**  
   - **亮点**：通过树状数组实现区间减操作，逻辑与王熙文类似，代码可读性高。  
   - **代码片段**：  
     ```cpp
     for (int i = n; i >= 1; --i) {
         int val = query(i);
         if (val == i) a[i] = 1;
         else a[i] = 0;
         // ... 更新区间 ...
     }
     ```

3. **Frevotops的题解（4星）**  
   - **亮点**：使用树状数组维护原数组，通过差分实现区间加减，思路清晰。  
   - **代码片段**：  
     ```cpp
     void update(int l, int r, int x) {
         upd(l, x); upd(r + 1, -x);
     }
     ```

---

### **最优思路或技巧提炼**

1. **逆向贪心构造**  
   - 从后向前处理，利用已知的 `C` 值推导 `A` 的元素，避免正向推导的复杂排序模拟。

2. **树状数组维护区间操作**  
   - 通过树状数组或差分数组高效处理区间加减，支持快速单点查询，是处理动态区间问题的核心技巧。

3. **动态调整贡献值**  
   - 每确定一个 `A[i] = 1`，需更新其影响的区间，确保后续推导的正确性。

---

### **同类型题或类似算法套路**

- **逆序处理+区间维护**：如 [CF EDU 160 D](https://codeforces.com/contest/160/problem/D)，需逆向推导并维护区间状态。  
- **贪心+差分数组**：如 [LeetCode 1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)，通过差分处理区间操作。

---

### **推荐相似题目**

1. **CF EDU 160 D**  
   - **题号**：CF160D  
   - **关键词**：逆向构造、贪心、区间维护。

2. **LeetCode 1109**  
   - **题号**：1109  
   - **关键词**：差分数组、区间更新。

3. **洛谷 P3368**  
   - **题号**：P3368  
   - **关键词**：树状数组、区间加减、单点查询。

---

### **可视化与算法演示**

1. **动画设计**  
   - **Canvas 网格**：以网格表示 `A` 和 `C`，当前处理的位置 `i` 高亮为红色。  
   - **树状数组操作**：用绿色标记区间减操作，蓝色标记单点查询。  
   - **步进控制**：用户可调整速度，观察每一步的 `A[i]` 推导和 `C` 的更新。

2. **复古像素风格**  
   - **颜色方案**：使用 8-bit 调色板，`A` 的 `1` 显示为黄色方块，`0` 为黑色。  
   - **音效**：  
     - **区间减**：短促“滴”声。  
     - **确定 `A[i]`**：高音“叮”声（成功）或低音“嘟”声（失败）。

---

### **代码实现（核心逻辑）**

**王熙文的代码（树状数组维护差分）：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, a[N], c[N], tr[N];

void upd(int wz, int x) {
    while(wz <= n) { tr[wz] += x; wz += wz & -wz; }
}

int query(int wz) {
    int res = 0;
    while(wz) { res += tr[wz]; wz -= wz & -wz; }
    return res;
}

void solve() {
    cin >> n;
    long long sum = 0;
    for(int i=1; i<=n; i++) cin >> c[i], sum += c[i];
    int k = sum / n;
    memset(tr, 0, sizeof tr);
    for(int i=1; i<=n; i++) upd(i, c[i] - c[i-1]); // 差分初始化
    for(int i=n; i>=1; i--) {
        int val = query(i);
        a[i] = (val == i);
        if(a[i]) { // 更新区间 [i-k+1, i-1]
            upd(i - k + 1, -1);
            upd(i, 1);
            k--;
        }
    }
    for(int i=1; i<=n; i++) cout << a[i] << " \n"[i==n];
}
```

---
处理用时：215.56秒
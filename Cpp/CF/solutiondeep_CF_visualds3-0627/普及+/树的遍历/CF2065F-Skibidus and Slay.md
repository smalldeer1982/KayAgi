# 题目信息

# Skibidus and Slay

## 题目描述

我们定义一个长度为 $k$ 的序列的**多数元素**为：该序列中唯一一个出现次数严格大于 $\lfloor \frac{k}{2} \rfloor$ 的数值。如果不存在这样的数值，则称该序列没有多数元素。例如，序列 $[1,3,2,3,3]$ 的多数元素为 $3$（因为 $3$ 出现了 $3$ 次，$3 > \lfloor \frac{5}{2} \rfloor = 2$），而序列 $[1,2,3,4,5]$ 和 $[1,3,2,3,4]$ 则没有多数元素。

Skibidus 找到了一棵有 $n$ 个顶点的树 $ ^{\text{∗}} $ 以及一个长度为 $n$ 的数组 $a$。其中，顶点 $i$ 上写有数值 $a_i$，且 $a_i$ 是区间 $[1,n]$ 内的一个整数。

对于每个 $i$（$1 \le i \le n$），请判断是否存在一条非平凡的简单路径 $ ^{\text{†}} $，使得该路径上顶点构成的数值序列的多数元素为 $i$。

 $ ^{\text{∗}} $ 树指的是一个无环的连通图。
 
 $ ^{\text{†}} $ 非平凡的简单路径指的是一个顶点序列 $v_1, v_2, \dots, v_m$（其中 $m \ge 2$），满足对于所有 $1 \le i \le m-1$，顶点 $v_i$ 与 $v_{i+1}$ 之间存在一条边，并且所有顶点均互不相同。注意路径至少包含 $2$ 个顶点。

## 说明/提示

- 在第一个测试用例中，没有任何一条非平凡路径能使得 $1$、$2$ 或 $3$ 成为多数元素，因此输出的二进制字符串为 `000`。
- 在第二个测试用例中，路径 $1 \rightarrow 2 \rightarrow 4$ 是一条非平凡路径，在该路径上 $3$ 为多数元素。

## 样例 #1

### 输入

```
4
3
1 2 3
1 3
2 3
4
3 1 1 3
1 2
2 3
4 2
4
2 4 4 2
1 2
2 3
3 4
13
1 4 4 7 4 7 1 1 7 11 11 11 11
1 2
2 3
3 4
4 5
4 6
2 7
7 8
2 9
6 10
5 11
11 12
10 13```

### 输出

```
000
1010
0001
1001001000100```

# AI分析结果



**唯一算法分类**：观察性质/构造性算法  

---

### **题解思路、算法要点与解决难点**  
**核心结论**：若存在满足条件的路径，则必存在长度为 2（相邻同值节点）或 3（两端同值且中间隔一节点）的子路径。  
**解决难点**：  
1. **证明结论**：利用鸽巢原理，长路径的多数元素必在短路径中出现。  
2. **高效检测**：避免遍历所有路径，转而检查每个节点的邻接关系和二级邻接关系。  

**核心步骤**：  
1. **长度 2 路径**：直接检查相邻节点是否同值。  
2. **长度 3 路径**：检查同一父节点的不同子节点是否同值，或兄弟节点的邻接节点是否同值。  

---

### **题解评分 (≥4星)**  
1. **作者：_hi_（★★★★☆）**  
   - **亮点**：使用邻接表 + Map 统计邻接点数值出现次数，直接判断是否存在二级邻接同值，代码简洁高效。  
   - **代码关键**：  
     ```cpp  
     for(int i=1;i<=n;i++){  
         if(mp[i][a[i]]) ans[a[i]]=1;  // 直接邻接  
         for(int j:poi[i])  
             if(mp[j][a[i]]>1) ans[a[i]]=1;  // 二级邻接  
     }  
     ```  

2. **作者：jzjr（★★★★☆）**  
   - **亮点**：预处理父节点和 LCA，通过距离判断是否存在长度 3 路径，适合稀疏树。  
   - **代码关键**：  
     ```cpp  
     if(det[u]+det[v]-2*det[lca(u,v)]==2) ans[i]=1;  // 距离为 2 的判断  
     ```  

3. **作者：Programming_Konjac（★★★★☆）**  
   - **亮点**：通过枚举中间节点，检查其邻接点是否有重复值，逻辑清晰。  

---

### **最优思路或技巧提炼**  
**核心思想**：  
- **剪枝观察**：仅需检查长度 ≤3 的路径，大幅降低计算量。  
- **邻接关系统计**：利用邻接表快速统计一级和二级邻接的同值节点。  

**实现技巧**：  
1. **邻接数值映射**：为每个节点维护一个哈希表，记录邻接点的数值出现次数。  
2. **兄弟节点排序**：将兄弟节点按数值排序，方便快速查找重复值。  

---

### **同类型题或类似算法套路**  
- **联合权值问题**：统计距离为 2 的节点对权值乘积和（如 NOIP2014 联合权值）。  
- **树的直径**：通过两次 BFS 找最长路径，同样依赖邻接关系遍历。  

---

### **推荐相似题目**  
1. **P1351 [NOIP2014 提高组] 联合权值**  
2. **P5018 [NOIP2018 普及组] 对称二叉树**  
3. **P3379 【模板】最近公共祖先（LCA）**  

---

### **可视化与算法演示**  
**动画方案**：  
1. **树结构绘制**：用 Canvas 绘制树形结构，节点颜色表示数值。  
2. **高亮检查路径**：  
   - **相邻检查**：红色高亮相邻同值节点对。  
   - **二级检查**：黄色高亮中间隔一个节点的同值端点对。  
3. **交互控制**：  
   - **步进按钮**：逐步展示每个节点的检查过程。  
   - **数值筛选**：选择特定数值，仅显示相关节点和路径。  

**复古像素风格设计**：  
- **颜色方案**：使用 8 位色（如红、黄、绿）标记不同状态。  
- **音效触发**：  
  - **发现路径**：播放上扬音效（如 8-bit 胜利音效）。  
  - **无结果**：播放短促低音。  

---

### **代码片段（核心逻辑）**  
```cpp  
// 作者：_hi_ 的核心逻辑  
for(int i=1;i<=n;i++){  
    if(ans[dq[i]]==1) continue;  
    if(mp[i][dq[i]]){  // 直接邻接同值  
        ans[dq[i]]=1;  
        continue;  
    }  
    for(int j=0;j<poi[i].size();j++){  
        int nv=poi[i][j];  
        if(mp[nv][dq[i]]>1){  // 邻接点的邻接同值超过 1 次  
            ans[dq[i]]=1;  
            break;  
        }  
    }  
}  
```  

---

**总结**：本题通过观察路径长度的性质，将问题转化为邻接关系的高效统计，结合树遍历和哈希表，实现线性时间复杂度。

---
处理用时：76.95秒
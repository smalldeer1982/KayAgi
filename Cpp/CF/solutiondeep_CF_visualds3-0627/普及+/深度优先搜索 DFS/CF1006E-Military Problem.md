# 题目信息

# Military Problem

## 题目描述

在这个问题中你需要帮助伯兰（？？我没找到有Berland这个国家）军队组织他们的指挥系统

伯兰军队中一共有n个军官。第一个官员是军队的指挥官，他并没有任何上级。其他的军官都有且只有一个直接的上级。如果一个军官a是军官b的上级，那么你也可以说军官b就是军官a的下属

如果满足下列条件，那么军官x就是军官y的下属（直接或非直接）：

1.y是x的直接上级 2.x的直接上级是y的下属

举个例子，下图的官员3的下属有:5,6,7,8,9

所以，在伯兰军队的结构中，除了指挥官，其他人都是指挥官的下属

形式上的，让我们把伯兰军队看成一棵拥有n个节点的树，树的节点u就代表了军官u。根（即一号节点）就相当于指挥官

伯兰战争部门命令你对q个查询给出答案。这q个查询会以（ui，ki）的形式给出，ui代表了某个军官，ki是正整数。你需要输出，编号为ui的军官下达命令后，第ki个得知此命令的军官编号是多少，如果传达人数不足ki个，输出-1。

要处理第i个查询，想象一下ui的命令如何我下达到ui的下属。这里使用了典型的DFS（深度优先搜索）算法。

假设现在的军官是a，他要下达一个命令。a军官选择一个军官b——还没有收到这个命令的直接下属（即在树上的一个孩子）。如果有许多这样的直接下属，那么A选择编号最小的那一个。A军官向B军官发出命令。之后，B使用完全相同的方式将命令扩展到它的子树。在B完成命令后，军官A再次选择下一个直接下属（使用相同的策略）。当军官A不能选择任何还没有接到命令的直接下属时，军官A下达命令完成。

让我们看一下下面这个例子（看下面的图）：

如果军官1下达了命令，军官们收到命令的顺序是：1,2,3,5,6,8,7,9,4

如果军官3下达了命令，军官们收到命令的顺序是：3,5,6,8,7,9

如果军官7下达了命令，军官们收到命令的顺序是：7,9

如果军官9下达了命令，军官们收到命令的顺序是：9

你应当分开处理这些查询。一个查询不会影响其他查询的结果。

## 样例 #1

### 输入

```
9 6
1 1 1 3 5 3 5 7
3 1
1 5
3 4
7 3
1 8
1 9
```

### 输出

```
3
6
8
-1
9
4
```

# AI分析结果



**唯一算法分类**  
DFS

---

**综合分析与结论**  
题目要求处理树结构中的DFS遍历顺序查询，核心思路为预处理每个节点的DFS序，利用子树在DFS序中的连续性进行快速查询。每个题解的核心在于预处理DFS序，记录节点的进入时间、子树大小及顺序数组。查询时直接通过进入时间+偏移量获取结果。  
**解决难点**在于如何高效处理大规模数据的查询，通过O(n)预处理和O(1)查询避免暴力遍历。DFS序的连续性性质是关键，确保子树范围在数组中连续。  
**可视化设计思路**：以动画展示DFS遍历过程，标记每个节点的进入时间和子树大小。查询时高亮对应区间，步进显示第k个节点的位置。

---

**题解清单 (≥4星)**  
1. **Anguei (5星)**  
   - **思路清晰**：明确利用DFS序的连续性，预处理时间戳和子树大小。  
   - **代码简洁**：通过一次DFS完成所有预处理，查询直接计算。  
   - **优化提示**：避免显式排序子节点，依赖输入顺序的正确性。  

2. **jr_zch (5星)**  
   - **代码精简**：使用`vector`存储子节点，DFS简洁高效。  
   - **关键变量命名**：`sor`存储DFS序，`pre`记录时间戳，逻辑清晰。  

3. **geven (4星)**  
   - **预处理高效**：DFS直接生成顺序数组和子树大小。  
   - **代码可读性**：变量命名清晰，逻辑直白，适合初学者理解。  

---

**最优思路或技巧提炼**  
1. **DFS序的连续性**：子树的前序遍历是整棵树DFS序的连续子串，预处理后可直接定位区间。  
2. **时间戳与子树大小**：记录每个节点的进入时间（`dfn[u]`）和子树大小（`size[u]`），查询时通过`dfn[u] + k - 1`快速定位。  
3. **输入顺序优化**：子节点按输入顺序添加（自然递增），无需显式排序，减少预处理时间。  

---

**同类型题或类似算法套路**  
- **子树查询**：利用DFS序处理子树统计、修改操作（如洛谷P3384）。  
- **动态树结构**：结合并查集或树链剖分处理动态子树问题。  

---

**推荐洛谷题目**  
1. P3379 【模板】最近公共祖先（LCA）  
2. P3384 【模板】轻重链剖分  
3. P2146 [NOI2015] 软件包管理器  

---

**个人心得摘录**  
- **输入顺序陷阱**：部分题解因建树方式错误导致子节点无序，需显式排序。正确建树则无需额外操作。  
- **调试技巧**：通过小样例验证DFS序正确性，确保子树范围和查询偏移量计算无误。  

---

**可视化与算法演示**  
1. **动画方案**：  
   - **Canvas绘制树结构**：节点按DFS序排列，颜色标记当前访问节点。  
   - **步进显示**：高亮当前访问路径，动态展示DFS遍历顺序。  
   - **查询高亮**：以不同颜色标记查询区间和第k个节点。  
2. **复古像素风格**：  
   - **8位音效**：访问节点时播放“哔”声，查询成功/失败时播放不同音效。  
   - **自动演示**：模拟DFS遍历过程，用户可调节速度观察节点扩展顺序。  
3. **交互控制**：支持暂停、继续、单步执行，直观对比不同查询结果。

---

**代码片段（核心DFS逻辑）**  
```cpp
void dfs(int u) {
    dfn[u] = ++time;     // 记录进入时间
    id[time] = u;        // 时间戳对应的节点
    size[u] = 1;         // 初始化子树大小
    for (int v : children[u]) {
        dfs(v);
        size[u] += size[v];
    }
}
```

**完整代码（Anguei题解）**  
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 2e5 + 5;
vector<int> g[N];
int dfn[N], id[N], size[N], cnt;

void dfs(int u) {
    dfn[u] = ++cnt;
    id[cnt] = u;
    size[u] = 1;
    for (int v : g[u]) {
        dfs(v);
        size[u] += size[v];
    }
}

int main() {
    int n, q;
    scanf("%d%d", &n, &q);
    for (int i = 2; i <= n; ++i) {
        int p;
        scanf("%d", &p);
        g[p].push_back(i);
    }
    dfs(1);
    while (q--) {
        int u, k;
        scanf("%d%d", &u, &k);
        if (k > size[u]) printf("-1\n");
        else printf("%d\n", id[dfn[u] + k - 1]);
    }
    return 0;
}
```

---
处理用时：171.54秒
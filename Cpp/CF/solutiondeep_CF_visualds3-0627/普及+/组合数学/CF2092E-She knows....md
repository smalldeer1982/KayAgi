# 题目信息

# She knows...

## 题目描述

D. Pippy 正在为家中的"黑白派对"做准备。他只需要重新粉刷地下室的 floor，该 floor 可表示为 $n \times m$ 的棋盘。

在上次派对后，整个棋盘除 $k$ 个单元格 $(x_1, y_1), (x_2, y_2), \ldots, (x_k, y_k)$ 外均被涂成绿色，这些单元格已被涂成白色或黑色。为了即将到来的派对，D. Pippy 想要将剩余的绿色单元格涂成黑色或白色。同时，他要求重新粉刷后棋盘上相邻颜色不同的单元格对数量为偶数。

形式化地，若定义集合：
$$A = \left\{((i_1, j_1), (i_2, j_2)) \ | \ 1 \le i_1, i_2 \le n, 1 \le j_1, j_2 \le m, i_1+j_1 < i_2+j_2, |i_1-i_2|+|j_1-j_2| = 1, \operatorname{color}(i_1, j_1) \neq \operatorname{color}(i_2, j_2) \right\},$$
其中 $\operatorname{color}(x, y)$ 表示单元格 $(x, y)$ 的颜色，则要求 $|A|$ 为偶数。

请帮助 D. Pippy 计算满足条件的粉刷方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

## 说明/提示

第一个测试案例中，绿色单元格 $(2, 1), (2, 2), (2, 3)$ 共有 $4$ 种合法涂色方案，分别为：$(1, 1, 0)$，$(0, 0, 1)$，$(1, 0, 0)$，$(0, 1, 1)$（颜色按单元格顺序排列），如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2092E/0ff35e90f545116ecc7d2fbe2de16f35bcaedb89.png)  
第二个测试案例中，棋盘已全部涂色且相邻异色对数量为奇数，因此答案为 $0$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 3 6
1 1 0
1 2 1
1 3 0
3 1 1
3 2 0
3 3 1
3 4 12
1 1 0
1 2 1
1 3 0
1 4 1
2 1 1
2 2 0
2 3 1
2 4 0
3 1 0
3 2 1
3 3 0
3 4 1```

### 输出

```
4
0```

# AI分析结果



## 算法分类
数学推导/组合数学

---

## 综合分析与结论

### 核心思路
相邻异色对的奇偶性仅由**边上非角落格子**的黑色数量奇偶性决定。若这些格子存在未确定的（绿色），则可通过调整其中一个颜色使总奇偶性满足条件，方案数为 \(2^{nm-k-1}\)；若已全部确定，则需其黑色数为偶数，否则无解。

### 解决难点
1. **关键观察**：边上非角落格子（每个有3个相邻）的颜色变化会改变总奇偶性，而其他格子不影响。
2. **统计边格子**：正确判断格子是否属于边格子（行或列的边界但非角落）。
3. **快速幂计算**：处理大指数取模运算。

### 算法流程
1. **输入处理**：遍历每个已涂色格子，统计边格子数量 `p` 和颜色总和 `s`。
2. **条件判断**：
   - 若已确定的边格子数等于总数 \(2(n+m-4)\)，检查 `s` 的奇偶性。
   - 否则，答案由剩余自由度决定。

### 可视化设计
- **动画效果**：用棋盘网格展示边格子（高亮标黄），动态调整颜色并显示相邻异色对的变化。
- **关键步骤高亮**：改变边格子颜色时，展示其对总奇偶性的影响。
- **交互控制**：允许单步执行，观察奇偶性如何随边格子颜色变化。

---

## 题解清单（≥4星）

1. **chenxi2009（★★★★☆）**
   - **亮点**：代码简洁，利用异或统计颜色总和，快速幂实现高效。
   - **核心代码**：
     ```cpp
     if (crn == 1) p++, s += c;
     if (p < 2*(n + m -4)) ans = 2^(nm-k-1);
     ```

2. **linjunye（★★★★☆）**
   - **亮点**：通过异或视角分析，清晰推导奇偶性条件，代码逻辑与数学证明紧密结合。

3. **WaterSun（★★★★☆）**
   - **亮点**：条件判断准确，边界处理清晰，变量命名易读。

---

## 最优思路与代码实现

### 关键代码
```cpp
int p = 0, s = 0;
for (输入每个格子) {
    int crn = (x == 1 || x == n) + (y == 1 || y == m);
    if (crn == 1) { // 边格子判定
        p++;
        s += c;
    }
}
int total_edge = 2 * (n + m - 4);
if (p == total_edge) {
    ans = (s % 2) ? 0 : pow(2, n*m - k);
} else {
    ans = pow(2, n*m - k - 1);
}
```

### 核心思想
- **边格子判定**：行或列在边界且非角落。
- **奇偶调整**：未确定的边格子提供一个自由度。

---

## 相似题目推荐
1. **CF1391D**（奇偶性条件与网格动态规划）
2. **洛谷P1357**（棋盘覆盖与状态压缩）
3. **洛谷P2106**（组合数学与模运算）

---

## 个人心得摘录
- **调试教训**：注意n=1或m=1时边格子计算的边界条件，需单独验证。
- **顿悟**：异或总和与奇偶性的等价转换简化了问题分析。

---

## 可视化方案（复古像素风）
- **棋盘绘制**：Canvas绘制网格，边格子用黄色像素标记。
- **动画效果**：点击格子切换颜色，实时计算异色对并显示奇偶性。
- **音效设计**：切换颜色时播放8-bit音效，成功/失败时不同音调。

```javascript
// 伪代码示例
function drawGrid() {
    // 绘制棋盘，边格子高亮为黄色
    ctx.fillStyle = '#FFFF00';
    edgeCells.forEach(cell => ctx.fillRect(...cell));
}

function toggleColor(x, y) {
    // 切换颜色并播放音效
    playSound('click');
    updateParity();
}
```

---

**总结**：通过数学推导识别关键变量，结合快速幂与边界处理，高效解决问题。可视化设计增强理解，复古风格增添趣味。

---
处理用时：400.04秒
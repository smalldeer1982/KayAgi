# 题目信息

# Red-Green Towers

## 题目描述

你有 $r$ 块红色的积木和 $g$ 块绿色的积木，它们用于建造红绿塔。红绿塔按照下面的规则来建造：

- 红绿塔有若干层；
- 如果红绿塔有 $n$ 层，那么塔的第一层应该有 $n$ 块积木，第二层有 $n-1$ 块，第三层有 $n-2$ 块，以此类推，最后一层只有一块。换言之，每一层应该比前面一层少一块；
- 红绿塔的每一层必须使用相同颜色的积木。

令 $h$ 表示用 $r$ 个红积木和 $g$ 个绿积木所能搭建的满足上述规则的塔的最大层数。现在你的任务是确定可以建造出多少不同的有 $h$ 层的红绿塔。

如果两个红绿塔相同的一层使用的是不同的颜色，它们就被认为不同的。

你需要写一个程序来求出有多少种高度为 $h$ 的不同的红绿塔。由于答案很大，你只需要输出答案模 $10^9+7$（也就是$1000000007$）后的值。

## 样例 #1

### 输入

```
4 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
9 7
```

### 输出

```
6
```

## 样例 #3

### 输入

```
1 1
```

### 输出

```
2
```

# AI分析结果



# 算法分类
动态规划（背包问题）

---

## 综合分析与结论

### 核心思路
题目要求用红绿积木搭建最大层数 h 的塔，并统计不同颜色分配的方案数。核心步骤：
1. **确定最大层数 h**：通过公式 h*(h+1)/2 ≤ r+g，计算满足条件的最大 h。
2. **动态规划（背包问题）**：将每层视为物品（重量为层数），红色积木数量视为背包容量。计算所有可能的红色积木使用量。
3. **约束条件**：红色使用量 j 需满足 j ≤ r，且绿色使用量（总需求 - j）≤ g，即 j ≥ max(0, h*(h+1)/2 - g)。

### 难点与解决方案
- **动态规划状态转移**：采用滚动数组优化空间，逆向更新避免重复计算。
- **约束边界处理**：正确计算红色使用量的上下界，确保绿色积木不超限。

### 可视化设计
1. **动画方案**：展示 DP 数组的更新过程，每层处理时高亮当前积木数 i 和更新的 j 值。
2. **颜色标记**：有效区域（红绿约束范围）用绿色背景，当前操作位置用红色边框。
3. **交互设计**：步进控制，可调节速度观察 DP 数组变化；复古像素风格，8 位音效提示关键操作。

---

## 题解评分（≥4星）

### 灵茶山艾府（★★★★★）
- **亮点**：思路清晰，直接转化为背包问题；代码简洁高效，正确计算约束边界。
- **核心代码**：
  ```go
  dp := make([]int, r+1)
  dp[0] = 1
  for i := 1; i <= h; i++ {
      for j := r; j >= i; j-- {
          dp[j] = (dp[j] + dp[j-i]) % mod
      }
  }
  ```

### _JF_（★★★★）
- **亮点**：显式处理红绿约束，状态转移清晰；滚动数组优化空间。
- **注意点**：初始化细节需仔细验证，避免条件判断错误。

### Hisaishi_Kanade（★★★★）
- **亮点**：显式推导红绿关系，状态转移明确；自动检测无转移时终止循环。
- **注意点**：初始条件处理需谨慎，避免越界。

---

## 最优思路提炼

### 关键步骤
1. **计算最大 h**：`h = floor(sqrt(2*(r+g)))`，调整至满足 `h*(h+1)/2 ≤ r+g`。
2. **背包 DP**：状态 `dp[j]` 表示使用 j 个红积木的方案数，逆向更新避免覆盖。
3. **统计答案**：累加满足 `max(0, S - g) ≤ j ≤ r` 的 `dp[j]`，其中 `S = h*(h+1)/2`。

### 代码片段
```cpp
int h = 0;
while (h*(h+1)/2 <= r + g) h++;
h--; // 调整到最大合法 h

vector<int> dp(r + 1, 0);
dp[0] = 1;
for (int i = 1; i <= h; i++) {
    for (int j = r; j >= i; j--) {
        dp[j] = (dp[j] + dp[j - i]) % MOD;
    }
}

int total = h*(h+1)/2;
int lower = max(0, total - g);
int ans = 0;
for (int j = lower; j <= r; j++) {
    ans = (ans + dp[j]) % MOD;
}
```

---

## 类似题目推荐
1. **CF478D Red-Green Towers**（本题）
2. **P1048 [NOIP2005 普及组] 采药**（01 背包基础）
3. **P1156 垃圾陷阱**（动态规划结合约束条件）

---

## 可视化与复古动画

### 动态规划演示
- **Canvas 绘制**：网格展示 DP 数组，当前层数 i 显示在顶部，红色方块表示更新的位置。
- **步进控制**：按钮控制执行速度，单步查看 j 的更新过程。
- **音效**：每次转移成功播放“哔”声，统计答案时播放胜利音效。

### 复古游戏化设计
- **8 位风格**：像素字体、16 色调色板，背景音乐循环播放。
- **关卡制**：每层视为一关，过关后显示当前累计方案数。
- **积分系统**：根据正确转移次数和计算速度给予积分奖励。

---

**答案总结**：通过背包 DP 统计红积木使用量，结合约束条件求和。核心在于正确建模为动态规划问题并处理边界条件。

---
处理用时：155.63秒
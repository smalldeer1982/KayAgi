# 题目信息

# Equalization

## 题目描述

给定两个非负整数 $x$ 和 $y$。

你可以执行以下操作任意次数（包括零次）：选择一个正整数 $k$，并将 $x$ 或 $y$ 除以 $2^k$（向下取整）。此操作的代价为 $2^k$。但存在额外约束：每个 $k$ 值最多只能选择一次。

你的任务是计算使 $x$ 和 $y$ 相等所需的最小可能代价。

## 说明/提示

第一个示例中，可以按如下步骤操作：选择 $k=1$ 并将 $y$ 除以 $2$。之后，$x$ 和 $y$ 均等于 $0$。

第二个示例中，可以按如下步骤操作：选择 $k=2$ 并将 $x$ 除以 $4$；选择 $k=1$ 并将 $y$ 除以 $2$。之后，$x$ 和 $y$ 均等于 $1$。

第三个示例中，两数已经相等，无需操作。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
0 1
6 2
3 3
13 37
4238659325782394 12983091057341925```

### 输出

```
2
6
0
26
32764```

# AI分析结果



---

**算法分类选择**  
动态规划（DP）/状态压缩预处理

---

**综合分析与结论**  
本题要求通过选择不同的右移操作使两个数相等，且每个k只能使用一次。关键点在于如何有效枚举所有可能的右移位数组合并计算最小代价。

**核心思路**  
1. **预处理阶段**：使用状态压缩枚举所有可能的k分配方式（k的二进制位表示），记录每个右移位数组合的最小代价。
2. **查询阶段**：对于输入的x和y，枚举所有可能的右移位数i和j，检查其高位是否相等，取预处理结果的最小值。

**难点与解决方案**  
- **代价计算**：每个k的代价为2^k，且必须唯一。预处理时通过位掩码枚举所有分配方式，确保不重复。
- **高效查询**：预处理二维数组`d[i][j]`存储右移i位和j位的最小掩码，查询时直接查表。

**可视化设计要点**  
1. **像素动画**：在Canvas中以像素块表示x和y的二进制位，右移操作时高亮对应位数。
2. **音效提示**：选中k时播放音效，达成相等时播放胜利音效。
3. **互动操作**：允许用户拖动k值分配给x或y，实时显示代价变化。

---

**题解评分 (≥4星)**  
1. **MrPython (5星)**  
   - **亮点**：通过状态压缩预处理所有可能的k分配方式，查询时间复杂度O(1)。代码简洁，利用位运算高效枚举。
   - **核心代码**：  
     ```cpp
     // 预处理所有可能的k分配
     for (ui i = 0; i < (1u << 16); ++i)
       for (ui j = i; j; j = i & (j - 1)) {
         ui x = 0, y = 0;
         for (ui k = 0; k < 16; ++k)
           if ((i >> k) & 1) ((j >> k) & 1 ? x : y) += k + 1;
         if (x < 64 && y < 64) d[x][y] = min(d[x][y], i);
       }
     ```
2. **cflsfzh (4星)**  
   - **亮点**：动态规划状态转移清晰，覆盖所有k值。使用二维DP确保每个k仅用一次。

---

**最优思路提炼**  
- **状态压缩预处理**：将k的分配编码为位掩码，枚举所有可能组合。
- **高位匹配优先**：优先比较x和y的高位部分，快速找到可能的最小代价。

---

**相似题目推荐**  
1. [洛谷 P2114](https://www.luogu.com.cn/problem/P2114)（位运算与状态选择）  
2. [洛谷 P2893](https://www.luogu.com.cn/problem/P2893)（动态规划与代价优化）  
3. [洛谷 P5020](https://www.luogu.com.cn/problem/P5020)（背包问题与状态转移）

---

**代码实现与核心逻辑**  
MrPython题解的完整代码：  
```cpp
#include <array>
#include <bit>
#include <iostream>
#include <limits>
#include <utility>
using namespace std;
istream& fin = cin;
ostream& fout = cout;
using ui = unsigned int;
using uli = unsigned long long int;
using li = long long int;
const auto f = []() {
  array<array<ui, 64>, 64> d;
  for (auto& i : d)
    for (auto& j : i) j = numeric_limits<ui>::max();
  for (ui i = 0; i < (1u << 16); ++i)
    for (ui j = i; j; j = i & (j - 1)) {
      ui x = 0, y = 0;
      for (ui k = 0; k < 16; ++k)
        if ((i >> k) & 1) ((j >> k) & 1 ? x : y) += k + 1;
      if (x < 64 && y < 64) d[x][y] = d[y][x] = min(d[x][y], i);
    }
  return d;
}();
int main(void) {
  ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
  size_t T;
  fin >> T;
  while (T--) {
    uli x, y;
    fin >> x >> y;
    if (x == y) {
      fout << "0\n";
      continue;
    }
    if (x < y) swap(x, y);
    ui ans = numeric_limits<ui>::max();
    for (ui i = 0; i < 58; ++i)
      for (ui j = 0; j < 58; ++j)
        if ((x >> i) == (y >> j)) { ans = min(ans, f[i][j]); }
    fout << ans * 2 << '\n';
  }
  return 0;
}
```

---

**可视化算法演示**  
1. **动画流程**：  
   - **步骤1**：显示x和y的二进制位，高亮最高不同位。  
   - **步骤2**：枚举可能的右移位数i和j，动态调整位数并比较剩余高位。  
   - **步骤3**：显示预处理表中对应i和j的最小代价。  
2. **像素风格设计**：  
   - 使用16色调色板，每个k值用不同颜色方块表示。  
   - 分配k给x或y时，方块移动到对应区域并播放音效。  
3. **音效交互**：  
   - **选中k**：播放8-bit点击音效。  
   - **匹配成功**：播放胜利旋律（如《超级马里奥》过关音效）。

---
处理用时：251.19秒
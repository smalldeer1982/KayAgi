# 题目信息

# Even String

## 题目描述

你需要构造一个由小写拉丁字母组成的字符串 $s$，满足以下条件：
- 对于任意两个满足 $s_{i} = s_{j}$ 的下标 $i$ 和 $j$，这两个下标之差的绝对值为偶数，即 $|i - j| \bmod 2 = 0$。

构造任意字符串太简单了，因此你会被给定一个包含 $26$ 个数字的数组 $c$ —— 表示字符串 $s$ 中每个字母必须出现的次数。也就是说，对于每个 $i \in [1, 26]$，拉丁字母表中的第 $i$ 个字母必须恰好出现 $c_i$ 次。

你的任务是计算满足所有这些条件的不同字符串 $s$ 的数量。由于答案可能非常大，请输出其对 $998\,244\,353$ 取模后的结果。

## 说明/提示

- 在第一个测试用例中，有 $4$ 个满足条件的字符串："abak"、"akab"、"baka" 和 "kaba"。


翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
2 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 3 0 0 0 0 0 0 0 0 0 0 0
1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 233527 233827```

### 输出

```
4
960
0
1
789493841```

# AI分析结果



1. **算法分类**  
   动态规划（背包问题）与组合数学

2. **题解思路与核心难点**  
   **核心思路**：每个字母只能全放奇数位或偶数位。总方案数 = 可行分配方式数量 × 固定组合数乘积（S1!S0!/∏c_i!）。  
   **难点突破**：发现无论字母如何分配，组合数乘积为定值，将问题简化为求背包方案数。  
   **算法流程**：  
   - 预处理阶乘与逆元  
   - 背包 DP 统计选字母总和为 S1 的方案数  
   - 固定组合数乘积与背包结果相乘  

3. **题解评分（≥4星）**  
   - **chm_qwq（5星）**：思路简洁，推导出固定组合数乘积，采用一维背包高效实现。  
   - **zhangzhixing99（4星）**：二维 DP 状态转移清晰，但代码复杂度较高。  
   - **wcy110614（4星）**：逆向填充 DP 状态，优化空间效率。

4. **最优思路提炼**  
   **关键技巧**：  
   - **数学推导**：通过分析奇偶位置约束，得出组合数乘积为定值。  
   - **背包优化**：将字母分配问题转化为 0-1 背包统计方案数。  
   - **预处理加速**：阶乘与逆元预处理 O(1) 计算组合数。  

5. **同类型题与套路**  
   - 类似约束：CF1657E（排列组合+背包）  
   - 组合数拆分：洛谷 P3773（背包+阶乘分解）  
   - 奇偶分组：洛谷 P7961（动态规划分组）

6. **推荐题目**  
   - 洛谷 P1077（背包组合数）  
   - 洛谷 P4099（奇偶分组动态规划）  
   - 洛谷 P4389（多重背包与组合数学）

7. **个人心得摘录**  
   > "第一次交题解，希望能过 QwQ" —— chm_qwq  
   **总结**：清晰的数学推导是解题关键，避免陷入复杂的状态转移。

8. **可视化设计**  
   **动画方案**：  
   - **像素风格界面**：用 8-bit 网格显示奇偶位分配过程，字母块颜色区分。  
   - **背包填充动画**：动态显示 DP 数组更新，当前字母高亮，背包容量（S1）用进度条表示。  
   - **音效触发**：字母分配时播放 8-bit 点击声，成功匹配 S1 时播放胜利音效。  
   **交互功能**：  
   - 步进控制：观察每步 DP 状态变化。  
   - 自动演示：AI 自动选择字母分配，速度可调。

---

**核心代码片段（chm_qwq 题解）**  
```cpp
void pre() {
    f[0] = finv[0] = 1;
    for (ll i = 1; i <= V; i++) 
        f[i] = f[i-1] * i % mod;
    finv[V] = qpow(f[V], mod-2);
    for (ll i = V-1; i >= 1; i--) 
        finv[i] = finv[i+1] * (i+1) % mod;
}

// 主 DP 部分
for (int i = 1; i <= 26; i++) {
    if (!c[i]) continue;
    for (int j = S; j >= 0; j--) 
        if (j + c[i] <= S) 
            dp[j+c[i]] = (dp[j+c[i]] + dp[j]) % mod;
}
ans = dp[S0] * f[S0] % mod * f[S1] % mod;
for (int i = 1; i <= 26; i++) 
    ans = (ans * finv[c[i]]) % mod;
```

**代码要点**：预处理阶乘逆元后，用倒序背包统计可行方案数，最后乘固定组合数乘积。

---
处理用时：87.80秒
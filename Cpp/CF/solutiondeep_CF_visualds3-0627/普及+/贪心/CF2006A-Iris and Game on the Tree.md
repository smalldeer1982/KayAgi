# 题目信息

# Iris and Game on the Tree

## 题目描述

给定一棵根为 $1$，每个点有 $0$ 或 $1$ 的点权的有根树，对于所有叶子定义权值为：取出根到它的路径上所有点的点权形成的 $01$ 串，其中 $10$ 子串的出现次数减去 $01$ 子串的出现次数。不认为根为叶子。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2006A/66d8f9cca162bbc9b7dcbbd0c66de4a705cfbe4e.png)

如图，绿点的点权为 $1$，白点的点权为 $0$，根到 $5$ 的串为 $10110$，其中有 $2$ 个 $10$，$1$ 个 $01$，故 $5$ 的权值为 $1$。

一棵树的分数被定义为：具有非零权值的叶子的数量。

有些点权尚未确定，A 与 B 在玩游戏，她们轮流将一个未确定点的点权改为 $0$ 或 $1$。先手的 A 希望最大化树的分数，后手的 B 希望最小化之，二人均采取最优策略，求最后树的分数。

## 说明/提示

$1 \leq t \leq 5 \cdot 10^4$，$2 \leq \sum n \leq 2 \cdot 10^5$。

translated by uid 443664

## 样例 #1

### 输入

```
6
4
1 2
1 3
4 1
0101
4
1 2
3 2
2 4
???0
5
1 2
1 3
2 4
2 5
?1?01
6
1 2
2 3
3 4
5 3
3 6
?0????
5
1 2
1 3
1 4
1 5
11?1?
2
2 1
??```

### 输出

```
2
1
1
2
1
0```

# AI分析结果



---

### 综合分析与结论

**题目核心**：博弈论视角下的贪心策略设计，通过分析叶子权值与根节点颜色的关联性，构建数学模型快速统计最优解。

**贪心策略关键**：
1. **根叶颜色法则**：若根与叶子颜色不同则贡献1分，否则0分（基于01串10与01的差值特性推导）
2. **博弈控制权模型**：通过统计未染色节点的奇偶性，判断最终决策权的归属（A优先取上整，B优先取下整）

**可视化设计思路**：
- **像素树结构**：用8位像素风格绘制树结构，根节点以金色高亮，叶子节点根据颜色显示不同形状（方框-0，圆框-1，闪烁问号-未确定）
- **博弈动画**：AI自动演示时，用红色箭头表示A的染色操作（最大化得分），蓝色箭头表示B的染色操作（最小化得分）
- **音效反馈**：每次染色操作触发不同音效（A操作：高音"叮"，B操作：低音"咚"），得分变化时播放相应音效

---

### 题解清单（4星题解）

**题解作者：I_will_AKIOI（评分：★★★★）**  
**关键亮点**：
- 发现根叶颜色差异决定权值的核心规律
- 通过奇偶性统计巧妙处理博弈顺序问题
- 线性时间复杂度实现，代码简洁高效  
**个人心得引用**：  
_"这场主打一个极限，最后一分钟过了该题直接逆天改命了"_ → 强调边界条件（如叶子数量相等时的处理）是解题关键

---

### 核心代码实现与逻辑

**DFS统计关键变量**：
```cpp
void dfs(int k,int fa) {
  if(v[k].size()==1 && k!=1) { // 叶子节点统计
    if(c[k]=='0') cnt[0]++;
    else if(c[k]=='1') cnt[1]++;
    else cnt[2]++;
  } else if(k!=1 && c[k]=='?') cnt[3]++; // 非叶非根未染色节点
  for(int now:v[k]) if(now!=fa) dfs(now,k);
}
```

**博弈策略计算**：
```cpp
if(c[1]=='?') { // 根未染色
  if(cnt[0]==cnt[1]) 
    cout << max(cnt[0],cnt[1]) + (cnt[2]+(cnt[3]&1))/2;
  else 
    cout << max(cnt[0],cnt[1]) + cnt[2]/2;
} else { // 根已染色
  cout << cnt[1-(c[1]-'0')] + (cnt[2]+1)/2;
}
```

---

### 同类型题目推荐

1. **CF1539E Game with Cards**（博弈中的状态转移）
2. **洛谷P2123 皇后游戏**（贪心策略设计）
3. **CF1491D Zookeeper and The Infinite Zoo**（位运算博弈）

---

### 可视化代码片段（Canvas动画）

**绘制像素化树结构**：
```javascript
function drawTree(nodes) {
  ctx.fillStyle = "#2C3E50";
  nodes.forEach(node => {
    const x = node.x * 80 + 40, y = node.y * 80 + 40;
    ctx.beginPath();
    ctx.arc(x, y, 15, 0, Math.PI*2);
    ctx.fill();
    if(node.isRoot) { // 根节点特效
      ctx.strokeStyle = "#F1C40F";
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
}
```

**自动博弈演示**：
```javascript
function autoPlay() {
  if(currentPlayer === 'A') {
    selectOptimalNode('max'); // A选择最大化得分的节点
    playSound('high');
  } else {
    selectOptimalNode('min'); // B选择最小化得分的节点
    playSound('low');
  }
  updateScoreBoard();
}
```

---

### 复古游戏化设计

**交互要素**：
- **连击系统**：连续3次正确决策触发×2得分加成
- **关卡模式**：  
  Level1：固定根颜色 → 练习叶子染色策略  
  Level2：动态根颜色 → 掌握博弈控制权切换  
- **音效方案**：  
  - 背景音乐：8-bit风格《俄罗斯方块》变奏  
  - 得分音效：每增加1分播放上升琶音  
  - 错误提示：短促的"哔"声

**性能优化**：采用Web Worker预加载资源，确保万级节点流畅渲染

---

### 总结

本题解通过深度挖掘问题特性，将复杂博弈转化为数学统计问题。其核心在于发现根叶颜色关系的隐藏规律，并利用奇偶性判断控制权归属。可视化设计通过复古像素风格与音效反馈，将抽象的博弈策略转化为直观的交互体验。

---
处理用时：84.60秒
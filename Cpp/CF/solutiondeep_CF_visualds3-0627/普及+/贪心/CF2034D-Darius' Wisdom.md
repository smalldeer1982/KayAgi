# 题目信息

# Darius' Wisdom

## 题目描述

大流士一世正在建造 $ n $ 根石柱，每根石柱由一个底座和不超过两个铭文块构成。

在每次操作中，大流士可以选择两根石柱 $ u $ 和 $ v $，只要这两根石柱的铭文数量差恰好为 $ 1 $，就可以将一个铭文从较多的一根转移到较少的一根。可以保证至少有一根石柱含有正好 $ 1 $ 个铭文。

为使得石柱看起来更美观，大流士希望这些石柱的铭文数量按不减顺序排列。为了减少工人们的辛劳，他希望你制定一个操作序列，最多使用 $ n $ 次操作实现这一目标，不需要优化操作次数。

## 说明/提示

以下是几个测试用例的样例状态：

- 第一个测试用例：
  - 初始状态：$ 0, 2, 0, 1 $
  - 第一次操作后：$ 0, 1, 0, 2 $
  - 第二次操作后：$ 0, 0, 1, 2 $

- 第二个测试用例：
  - 初始状态：$ 1, 2, 0 $
  - 第一次操作后：$ 0, 2, 1 $
  - 第二次操作后：$ 0, 1, 2 $

- 在第三个测试用例中，石柱的铭文数量已经是按升序排列的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
4
0 2 0 1
3
1 2 0
6
0 1 1 2 2 2```

### 输出

```
2
2 4
2 3
2
3 1
2 3
0```

# AI分析结果



### 综合分析与结论

**题目核心**：通过最多 `n` 次操作，将数组调整为非递减顺序。每次操作只能在相邻数值（差1）的元素间转移。

**难点**：如何在有限操作次数内处理数值0、1、2的分布，并保证正确性。

**贪心策略**：
1. **统计分治**：根据0、2的数量分情况处理（第一个题解），优先让0或2归位，再处理剩余元素。
2. **集合维护**：实时维护各数值位置（第二个题解），每次交换最大逆序对，逐步逼近有序。

**可视化设计**：
- **像素动画**：以8位风格呈现石柱，当前操作石柱高亮为红色，交换时播放“滴”音效。
- **自动演示**：按贪心策略自动选择交换对，单步执行时可观察集合或统计量的变化。
- **音效反馈**：成功交换后播放上升音调，无效操作播放低音。

### 题解清单（评分≥4星）

1. **作者：__little__Cabbage__（4.5星）**
   - **亮点**：统计0、1、2的出现次数，分情况处理，确保操作次数≤n。时间复杂度O(n)。
   - **关键代码**：
     ```cpp
     if (c0 <= c2) {
         // 处理0的位置
         int j = c0 + 1;
         rep(i, 1, c0) {
             while (a[j] != 0) ++j;
             if (a[i] == 1) opt(i, j);
         }
         // 处理2的位置，需通过1中转
     }
     ```
2. **作者：1234567890sjx（4星）**
   - **亮点**：用集合维护各数值位置，每次交换最大逆序对，逻辑直观。
   - **关键代码**：
     ```cpp
     while (!chk()) {
         if (buc[0].size() && buc[1].size()) {
             int x = *buc[0].rbegin(), y = *buc[1].begin();
             if (x > y) swap(x, y); // 交换逆序对
         }
     }
     ```

### 最优思路提炼

1. **统计分治策略**：
   - 若0的数量≤2的数量，优先将0调整到前c0位，剩余部分处理1和2。
   - 每次调整0时，若当前位置是1，直接交换；若是2，需通过1中转。
2. **操作次数控制**：归位0需要至多2×min(c0,c2)次操作，剩余部分处理1和2至多min(c1,c2)次，总和≤n。

### 同类型题目

- **荷兰国旗问题**：三色排序，仅允许交换相邻元素。
- **LeetCode 75. Sort Colors**：直接应用类似统计分治。
- **洛谷P1177 快速排序**：分治思想的应用。

### 代码片段（核心贪心逻辑）

**统计分治法（__little__Cabbage__）**：
```cpp
// 处理0和1的交换
int j = c0 + 1;
for (int i = 1; i <= c0; ++i) {
    if (a[i] == 1) {
        while (j <= n && a[j] != 0) ++j;
        swap(a[i], a[j]);
        record(i, j);
    }
}
// 处理2需要中转的情况...
```

**集合维护法（1234567890sjx）**：
```cpp
// 检查是否有序
auto chk = [&]() {
    if (存在0、1、2且0的最后一个位置 < 1的第一个位置...) return true;
    return false;
};
// 每次交换最大逆序对
if (buc[0].size() && buc[1].size()) {
    int x = *buc[0].rbegin(), y = *buc[1].begin();
    if (x > y) swap(x, y);
}
```

### 可视化与游戏化设计

- **Canvas 绘制**：每个石柱用像素块表示，颜色区分0（白）、1（蓝）、2（红）。
- **交互操作**：点击石柱触发交换，自动模式下AI按贪心策略执行。
- **音效设计**：交换时播放“哔”声，完成排序后播放胜利音乐。

**示例动画步骤（初始：0,2,0,1）**：
1. 高亮位置2（2）和4（1），交换→0,1,0,2。
2. 高亮位置2（1）和3（0），交换→0,0,1,2。
3. 背景音乐渐变，显示“完成！”。

通过分治策略与集合维护，结合直观的可视化，学习者可深入理解贪心选择的决策过程。

---
处理用时：74.53秒
# 题目信息

# Kevin and Competition Memories

## 题目描述

Kevin 曾经进入过 Rio 的记忆。在那段记忆中，曾举办过一系列的比赛。Kevin 还记得所有参赛者和比赛的问题，但具体的比赛轮次、问题分布和排名已经模糊不清。

有 $m$ 个比赛问题，第 $i$ 个问题的难度为 $b_i$。每场比赛选择 $k$ 个问题，因此总共会有 $\lfloor \frac{m}{k} \rfloor$ 场比赛。这意味着你可以任意组合选择这些比赛问题，并挑出总共 $\lfloor \frac{m}{k} \rfloor \cdot k$ 个问题参赛，每个问题最多只能被选一次，剩余 $m \bmod k$ 个问题将未被使用。例如，如果 $m = 17$ 且 $k = 3$，你将组织 $5$ 场比赛，每场 $3$ 个问题，会剩下 $2$ 个问题没有用上。

比赛有 $n$ 位参赛者，其中 Kevin 是第 1 位。第 $i$ 位参赛者的评分是 $a_i$。在比赛中，每个参赛者能解决难度不超过其评分的问题，具体来说，第 $i$ 位参赛者能解决第 $j$ 个问题，当且仅当 $a_i \geq b_j$。在每场比赛中，Kevin 的排名定义为那些比他解掉更多题目的参赛者数量加一。

对于每个 $k = 1, 2, \ldots, m$，Kevin 想知道在所有 $\lfloor \frac{m}{k} \rfloor$ 场比赛中的排名之和的最小可能值。也就是说，对于某个 $k$，你需要优化问题的选择和分配，使得 Kevin 的排名之和最小化。

不同的 $k$ 值代表的比赛是相互独立的。换言之，你可以对每个不同的 $k$ 值分别规划问题分配。

## 说明/提示

考虑第一个测试数据：

- 当 $k=1$ 时，每场比赛只包含一个问题，分配方式是唯一的。例如，在包含难度为 $4$ 的第三个问题的比赛中，除了第 2 位参赛者外，所有人都能解决。因为没有人比 Kevin 解出更多的问题，他在这场比赛中排名第 1。同理，在所有 $4$ 场比赛中，Kevin 的排名分别是 $1, 3, 1, 2$，总和为 $7$。

- 当 $k=2$ 时，最佳选择是将第 1 和第 3 个问题组成一场比赛，第 2 和第 4 个问题组成另一场。在前一场比赛中，4 名选手分别解决 $2, 1, 2, 2$ 个问题，Kevin 排名第 1；在后一场比赛中，选手分别解决 $0, 0, 2, 1$ 个问题，因有 2 位选手多解题，Kevin 排名第 $3$。所以总和是 $1 + 3 = 4$。这是最优解。

- 当 $k=3$ 时，可以选择第 1、3、4 个问题组成一场比赛，Kevin 的排名是 2，为最优。

- 当 $k=4$ 时，只有一场比赛，分配方式唯一，Kevin 的排名是 3。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
4 4
4 3 7 5
2 5 4 6
5 5
5 0 4 8 6
1 3 9 2 7
6 7
1 1 4 5 1 4
1 9 1 9 8 1 0
7 6
1 9 1 9 8 1 0
1 1 4 5 1 4```

### 输出

```
7 4 2 3
6 2 1 1 2
7 3 2 1 1 1 1
15 9 5 4 4 4```

# AI分析结果



### 综合分析与结论

**题目核心思路**：  
对于每个问题，计算其对 Kevin 排名的贡献值（即能解决该问题的其他参赛者数目 +1），将所有问题的贡献值升序排序。对于每个 $k$，将排序后的数组按每 $k$ 个元素分组，取每组最后一个元素（最大值）求和。此贪心策略确保各组贡献最小化。

**贪心策略证明**：  
通过交换论证法，任何其他分组方式的总和不会更小。升序排列后，每组的最大值是最后一个元素，保证较大的贡献值分散在不同组中，总和最小。

**算法难点**：  
1. 正确计算贡献值（需二分查找处理其他参赛者能力值）。  
2. 证明排序后分组的最优性。  
3. 高效处理多个 $k$ 的查询。

**可视化设计**：  
- **像素风格**：用不同颜色方块表示贡献值，升序排列后显示为阶梯状。  
- **动画**：滑动色块表示分组，高亮每组最后一个元素。  
- **音效**：分组时播放音调，成功求和后播放上扬音效。  
- **交互**：滑块调节 $k$ 值，动态显示分组和总和变化。

---

### 题解清单（≥4星）

1. **题解5（_lmh_）⭐⭐⭐⭐⭐**  
   - **亮点**：代码极简，预处理后直接累加，时间复杂度 $O(m \log m)$。  
   - **关键代码**：排序贡献值后，利用前缀和思想直接计算每个 $k$ 的结果。

2. **题解1（ZnPdCo）⭐⭐⭐⭐**  
   - **亮点**：清晰预处理其他参赛者，去掉无效数据，代码结构明确。  
   - **心得**："比自己弱的选手没用，全部杀"——预处理时过滤无效参赛者。

3. **题解6（_Kamisato_Ayaka_）⭐⭐⭐⭐**  
   - **亮点**：思路描述简练，代码直接反映问题核心，预处理和排序高效。

---

### 最优思路代码实现

**核心逻辑代码（题解5）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=300007;
ll T,n,m,a[N],b[N],ans[N];
int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>T;
    while(T--){
        cin>>n>>m;
        for (int i=1;i<=n;++i) cin>>a[i];
        for (int i=1;i<=m;++i){
            cin>>b[i];
            ans[i] = (a[1] >= b[i]) ? 1 : (n - (lower_bound(a+1,a+1+n,b[i]) -a) + 2);
        }
        sort(ans+1, ans+1+m);
        for (int k=1; k<=m; ++k) {
            ll sum = 0;
            for (int i=k; i<=m; i+=k) sum += ans[i];
            cout<<sum<<" ";
        }
        cout<<'\n';
    }
    return 0;
}
```

**实现思想**：  
1. 预处理每个问题的贡献值 `ans[i]`。  
2. 将 `ans` 数组升序排序。  
3. 对每个 $k$，累加每隔 $k$ 位置的元素之和。

---

### 同类型题目推荐

1. **P1090 合并果子**：贪心选择最小堆，每次合并最小两堆。  
2. **P1209 修理牛棚**：贪心选择间隔最大的位置放置木板。  
3. **P1223 排队接水**：按升序排列使平均等待时间最小。

---

### 个人心得摘录

- **调试关键**：贡献值的计算需注意边界，如 `lower_bound` 的返回值处理。  
- **顿悟点**：排序后的分组策略能自然保证最优性，无需复杂动态规划。

---

### 可视化算法演示（伪代码描述）

```javascript
// 伪代码：Canvas绘制贡献值分组
function drawContributions(ans, k) {
    clearCanvas();
    for (let i = 0; i < ans.length; i++) {
        drawRect(x, y, color); // 绘制贡献值方块
        if ((i + 1) % k === 0) {
            highlightRect(x, y); // 高亮每组的最后一个元素
            playSound('select.wav');
        }
    }
    displaySum(calculateSum(ans, k));
}
```

**交互设计**：  
- 用户拖动滑块选择 $k$，实时更新画面。  
- 音效提示分组和高亮操作，背景播放8-bit音乐。  
- 积分面板显示当前 $k$ 的总和，连击奖励动画增强趣味性。

---
处理用时：190.74秒
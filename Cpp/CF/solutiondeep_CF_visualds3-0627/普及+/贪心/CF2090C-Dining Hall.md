# 题目信息

# Dining Hall

## 题目描述

在一个庞大的王国中，有一个无限大的餐厅。

该餐厅可以表示为由单元格 $(x, y)$ 构成的集合，其中 $x, y$ 是自然数。餐厅内还有无数张桌子。每张桌子由四个单元格定义：$(3x + 1, 3y + 1)$、$(3x + 1, 3y + 2)$、$(3x + 2, 3y + 1)$、$(3x + 2, 3y + 2)$，其中 $x, y$ 是非负整数。所有不属于任何桌子的单元格被视为走廊。

客人只能在走廊中移动，且每次只能通过相邻的边移动到相邻的单元格，每次移动耗时相同。注意：客人只能在最后一次移动时坐在桌子上，且必须坐在桌子上。

在王国的一场晚宴中，共有 $n$ 位客人到来，每位客人有一个特征值 $t_i$（取值为 $0$ 或 $1$）。他们按顺序进入大厅，从单元格 $(0, 0)$ 出发走向某张桌子。若第 $i$ 位客人的 $t_i = 1$，则他会选择距离最近的仍有空位的桌子；若 $t_i = 0$，则他会选择距离最近的未被占用的桌子（即使后续可能有其他客人加入）。若存在多张桌子距离相同，则选择 $x$ 坐标最小的单元格；若仍有多个选项，则选择其中 $y$ 坐标最小的单元格。

从单元格到桌子的距离定义为到该桌子上最近的未被占用的单元格的距离。两单元格之间的距离按移动到相邻单元格的次数计算。注意：移动过程中不允许穿过属于桌子的单元格，除非是最后一步（该步骤会将你放置在桌子的最终单元格上）。

为更好理解条件，可参考说明中的图示。

你无需亲自计算所有客人的入座情况，请直接输出每位客人最终入座的单元格。

## 说明/提示

第一位客人到单元格 $(1, 1)$ 的距离为 2，因此选择该位置。

第二位客人到单元格 $(1, 2)$ 和 $(2, 1)$ 的距离均为 3，但由于 $1 < 2$，因此选择 $(1, 2)$。无额外约束。

第三位客人到单元格 $(2, 1)$ 的距离为 3，因此选择该位置。

第四位客人到单元格 $(1, 4)$ 的距离为 5，因此选择该位置。

第五位客人到单元格 $(4, 1)$ 的距离为 5。

第六位客人到单元格 $(1, 5)$ 和 $(2, 2)$ 的距离均为 6，但由于 $x$ 坐标更小，因此选择 $(1, 5)$。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2090C/14307747f44bf893a0cb5c3731d43642a649f3b9.png)

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
6
0 1 1 0 0 1
5
1 0 0 1 1```

### 输出

```
1 1
1 2
2 1
1 4
4 1
1 5
1 1
1 4
4 1
1 2
2 1```

# AI分析结果



---

## 唯一算法分类
**贪心算法 & 优先队列**

---

## 综合分析与结论

### 核心思路与算法要点
1. **动态生成候选座位**：通过数学规律发现，所有桌子的左下角坐标满足 `(3k+1, 3m+1)` 的形式，其到原点的曼哈顿距离呈阶梯状分布。使用优先队列维护候选座位，按距离排序。
2. **贪心选择策略**：
   - `t=0` 的客人必须选择全新桌子（此时生成新桌子的左下角坐标）
   - `t=1` 的客人可选择已有空位，优先队列中维护所有可用的空位
3. **坐标生成规律**：采用递推式坐标调整策略，每当一个桌子被 `t=0` 客人占用时，按照特定数学规律生成下一个候选桌子的坐标。

### 解决难点与对比
- **无限空间处理**：AstaVenti_ 题解通过动态生成候选位置，避免了预计算所有可能桌子的空间浪费（对比 BLuemoon_ 的预生成方法）
- **优先级维护**：优先队列自动保持候选位置的顺序，比 set 的查询效率更高（O(1) 取队首 vs O(logn) 查 set）
- **数学规律推导**：通过观察坐标变化的斜向排列规律，推导出递推式坐标调整公式 `(y-1) ? x+=3,y-=3 : swap(x,y), y+=3`

---

## 题解清单（≥4星）

1. **AstaVenti_（★★★★★）**
   - **亮点**：动态生成候选位置、数学推导坐标递推式、优先队列高效维护
   - **代码风格**：简洁高效（仅 30 行核心逻辑）
   - **优化点**：无需预计算，内存占用 O(n)

---

## 核心代码实现

```cpp
priority_queue<tp, vector<tp>, greater<tp>> pq; // 优先队列维护候选位置
ll x = 1, y = 1, dis = 2; // 当前新桌子的左下角坐标及距离

for (每个客人) {
  if (t_i == 1 && 优先队列非空 && 队首距离 < 当前新桌子距离) {
    取出队首位置作为答案;
  } else {
    使用当前新桌子坐标 (x,y);
    将该桌子的其他三个位置加入优先队列;
    按数学规律递推计算下一个新桌子的坐标 (x,y);
  }
}
```

---

## 可视化设计要点

### 动画方案
1. **像素网格渲染**：  
   - 使用 Canvas 绘制 3x3 网格块，灰色填充表示桌子，白色为走廊  
   - 当前选中位置高亮为绿色（t=0）或黄色（t=1）
2. **优先队列可视化**：  
   - 右侧显示优先队列内容，每个元素以 `(距离, x, y)` 形式展示  
   - 新加入队列的元素以淡入动画显示
3. **坐标递推演示**：  
   - 当生成新桌子时，绘制从旧坐标到新坐标的箭头，附带公式说明
4. **音效提示**：  
   - `加入队列`：8-bit 短促 "beep"  
   - `选择位置`：不同音调区分 t=0/t=1

### 复古风格实现
```javascript
// 伪代码示例：生成 8-bit 风格网格
function drawGrid() {
  ctx.fillStyle = '#808080'; // 灰色桌子
  for (let k = 0; k < MAX; k++) {
    for (let m = 0; m < MAX; m++) {
      // 绘制每个桌子的 2x2 区域
      fillRect(3*k+1, 3*m+1, 2, 2); 
    }
  }
}
```

---

## 相似题目推荐
1. **P1908 逆序对**（贪心+数据结构维护候选集）
2. **CF474D Flowers**（递推式动态生成候选解）
3. **P1090 合并果子**（优先队列经典应用）

---
处理用时：63.98秒
# 题目信息

# Well played!

## 题目描述

Max 最近沉迷于一款打怪游戏《赛某号》。现在，他正在参加赛某号的春季联赛。

他有 $n$ 只精灵。每只精灵都有对应的生命值 $hp_i$ 和攻击值 $dmg_i$。在比赛过程中，Max 可以借助巴拉拉小魔仙之力，说出这两种咒语：

1. “乌卡拉！血量！加倍！“意即将当前精灵的生命值加倍。（使得 $hp_i \gets 2\times hp_i$）

2. “乌卡拉！生命之力！”意即将当前精灵的生命值赋给当前精灵的攻击值。（使得 $dmg_i\gets hp_i$）

Max 当然不能无限使用这两种咒语。在一局游戏中，他可以使用第一种咒语 $a$ 次，第二次咒语 $b$ 次。由于Max 购买了超级 Nono，所以这两种咒语都可以被多次用在同一精灵身上，且咒语的使用顺序没有限制。Max 可以不用完所有的咒语。

Max 非常希望通过使用这些咒语使得自己的精灵战斗群的攻击值达到最大。现在，Max 想知道这个最大值。


输入第 $2$ 行到第 $n+1$ 行，每行两个整数 $hp$，$dmg$。第 $i$ 行表示第 $i-1$ 个精灵的生命值和攻击值。

## 样例 #1

### 输入

```
2 1 1
10 15
6 1
```

### 输出

```
27
```

## 样例 #2

### 输入

```
3 0 3
10 8
7 11
5 2
```

### 输出

```
26
```

# AI分析结果



### 综合分析与结论

**题目核心**：通过贪心策略最大化攻击总和，关键在于合理分配两种操作（生命加倍、生命赋值攻击）的使用顺序和对象。

**核心难点**：
1. **贪心策略的证明**：证明将a次乘2操作集中在一个精灵上最优。
2. **替换操作的排序**：如何选择b次替换操作的目标精灵。
3. **枚举优化点**：在已选替换精灵和未选精灵中，找到a次乘2操作的最佳应用位置。

**贪心策略**：
1. **替换优先级**：按`hp-dmg`从大到小排序，优先替换差值大的精灵。
2. **乘2集中性**：将a次乘2全用于同一精灵，通过枚举找到最大增益点。
3. **动态调整**：处理替换次数用完后，通过替换原有替换项来腾出操作机会。

---

### 题解评分 (≥4星)

1. **Echidna（★★★★★）**
   - **亮点**：严谨的数学证明，代码结构清晰，逻辑直击贪心核心。
   - **代码**：通过排序和差值计算快速确定最优替换，高效枚举乘2增益。

2. **JWRuixi（★★★★☆）**
   - **亮点**：代码简洁，利用前缀和与差值调整优化计算。
   - **优化**：处理替换次数用完后动态调整，避免重复计算。

3. **kkio（★★★★☆）**
   - **亮点**：代码简短，核心逻辑明确，边界处理清晰。
   - **特色**：通过`trm`变量记录最小替换增益，快速计算替代方案。

---

### 最优思路与技巧提炼

1. **贪心选择依据**：
   - **替换操作**：优先选择`hp-dmg`最大的精灵，确保每次替换带来最大增益。
   - **乘2操作**：枚举所有精灵，计算其`hp*2^a`后的可能增益，取最大值。

2. **关键实现细节**：
   ```cpp
   // 排序策略：按hp-dmg降序
   sort(s+1, s+n+1, [](PII a, PII b) { return a.first - a.second > b.first - b.second; });

   // 计算乘2后的最大增益
   for (int i=1; i<=n; i++) {
       int gain = (s[i].hp << a) - (i <= b ? s[i].hp : s[i].dmg);
       max_gain = max(max_gain, gain);
   }
   ```

3. **边界处理**：
   - 若替换次数未用完，直接替换当前精灵。
   - 若已用完，需用当前精灵的增益替换原有替换中的最小增益项。

---

### 同类型题与算法套路

**常见贪心场景**：
- **区间调度**：选择不重叠区间使数量最多（按结束时间排序）。
- **最小代价**：如合并果子问题，每次合并最小两堆。
- **最大收益**：如背包问题中按性价比排序。

**通用解法**：
1. **排序预处理**：按关键指标（如差值、截止时间）排序。
2. **局部最优选择**：每次选择当前最优解，不考虑后续影响。
3. **动态调整**：在操作次数有限时，通过替换历史操作优化结果。

---

### 推荐相似题目

1. **P1230 智力大冲浪**：贪心+截止时间排序。
2. **P1090 合并果子**：优先队列实现最小堆合并。
3. **P5019 铺设道路**：区间贪心覆盖问题。

---

### 可视化与算法演示

**核心动画设计**：
1. **排序展示**：精灵按`hp-dmg`降序排列，高亮前b个被替换的精灵。
2. **乘2操作枚举**：逐个精灵显示其`hp*2^a`后的增益，动态更新最大值。
3. **替换调整**：若替换次数用完，显示替换原有最小增益项的过程。

**复古游戏化效果**：
- **像素风格**：精灵用色块表示，hp和dmg以数字浮动显示。
- **音效提示**：替换时播放“升级”音效，乘2时播放“能量充满”音效。
- **自动演示**：AI自动选择最优解，用户可暂停观察每一步的决策逻辑。

**交互设计**：
- **控制面板**：暂停/继续、步进执行、调整动画速度。
- **高亮逻辑**：当前操作的精灵高亮为红色，历史操作显示为绿色。

---

### 代码片段（核心逻辑）

**JWRuixi的关键代码**：
```cpp
sort(q+1, q+n+1); // 按hp-dmg排序
for (int i=1; i<=n; i++) {
    if (i <= b) ans += q[i].mx(); // 前b个替换为hp
    else ans += q[i].d; // 其余保持dmg
}
for (int i=1; i<=n; i++) {
    // 枚举乘2增益，考虑替换后的调整
    int res = tmp - q[i].d + q[i].hp * x + sum;
    ans = max(ans, res);
}
```

**Echidna的增益计算**：
```cpp
for (int i=1; i<=n; i++) {
    delta[i] = (1ll<<a)*s[i].first - s[i].second;
    ans = max(ans, delta[i]);
}
```

---

### 个人心得摘录

- **调试教训**：未处理`b=0`的情况导致初始代码WA，需注意边界条件。
- **顿悟瞬间**：意识到乘2操作集中优于分散，通过数学归纳验证后代码效率大幅提升。
- **优化技巧**：前缀和记录替换后的总增益，减少重复计算。

---

通过上述分析，结合贪心策略与动态调整，可高效解决此类操作分配问题。

---
处理用时：102.20秒
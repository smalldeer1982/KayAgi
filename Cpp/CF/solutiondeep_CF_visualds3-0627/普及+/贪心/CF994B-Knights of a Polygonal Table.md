# 题目信息

# Knights of a Polygonal Table

## 题目描述

有  $n$  个骑士想决战。每个骑士都有能力值，且身上带有一些金币。如果骑士  $A$  的能力值大于骑士  $B$ ，那么骑士  $A$  就可以杀死骑士  $B$ ，并获得骑士  $B$  身上的所有金币。但就算是骑士也不会残忍过度，他们最多只会杀死  $k$  个骑士。对于每一位骑士，请你求出在决战后他身上金币的最大值。

## 说明/提示

- 第  $1$  组样例的解释：

第  $1$  个骑士是最蒻的，因此他谁也不能杀，只能保留自己原有的金币。

第  $2$  个骑士只能杀死第  $1$  个骑士，因此他最多拥有  $2 + 1 = 3$  个金币。

第  $3$  个骑士是最蔃的，但他只能选择杀  $k = 2$  个骑士。显然他会杀死第  $2$  个骑士和
第  $4$  个骑士，因为他们身上的金币更多。因此他最多拥有  $11 + 2 + 33 = 46$  个金币。

第  $4$  个骑士应该杀死第  $1$  个和第  $2$  个骑士，因此他最多拥有  $33 + 1 + 2 = 36$  个金币。 

- 第  $2$  组样例的解释：

除了最蒻的第  $1$  个骑士谁也不能杀，其他骑士都能杀死前一个骑士并获得他的金币。

- 第  $3$  组样例的解释：

由于只有一个骑士在决战中，他无法杀死任何人。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
4 2
4 5 9 7
1 2 11 33
```

### 输出

```
1 3 46 36 ```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5
1 2 3 4 5
```

### 输出

```
1 3 5 7 9 ```

## 样例 #3

### 输入

```
1 0
2
3
```

### 输出

```
3 ```

# AI分析结果



### 综合分析与结论  
**题目核心**：在有序的骑士序列中，动态维护前 k 个金币最多的元素，使用贪心策略选择最优的 k 个目标。  
**难点**：高效维护前 k 大的金币值，避免暴力遍历。  
**关键贪心策略**：  
1. **按能力值排序**：确保每个骑士只能选择前面的骑士。  
2. **优先队列优化**：用堆维护当前可选的前 k 大金币值。  
**最优解法**：使用小根堆动态维护不超过 k 个最大金币值，时间复杂度 $O(n \log k)$。

---

### 题解清单（≥4星）

#### 1. 作者：_22222222_（⭐⭐⭐⭐⭐）  
- **亮点**：  
  - 采用小根堆动态维护前 k 大元素，保证堆大小始终 ≤k，复杂度最优。  
  - 代码简洁，维护总和变量，避免重复计算。  
  - 正确性严格，无需回退操作。  

#### 2. 作者：fls233666（⭐⭐⭐⭐）  
- **亮点**：  
  - 使用大根堆逐步插入元素，逻辑清晰。  
  - 处理堆的取出和放回操作，确保后续骑士能复用数据。  

#### 3. 作者：KKarshilov（⭐⭐⭐⭐）  
- **亮点**：  
  - 动态维护堆的大小，优先替换较小的元素。  
  - 代码中直接操作堆的 sum 变量，优化计算效率。  

---

### 最优思路与代码实现  
**核心贪心逻辑**：  
1. 按能力值排序，确保每个骑士只能选择前面的骑士。  
2. 维护一个小根堆，堆中保留前 k 个最大金币值。  
3. 遍历时，将当前骑士金币加入堆，若堆大小 >k 则弹出最小值。  
4. 动态维护总和变量，计算当前骑士的最终金币。

```cpp
// 核心代码片段（_22222222_ 的题解）
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += knights[i].coin;
    min_heap.push(knights[i].coin);
    if (min_heap.size() > k) {
        sum -= min_heap.top(); // 弹出最小的元素
        min_heap.pop();
    }
    ans[knights[i].id] = sum;
}
```

---

### 同类型题目与算法套路  
**通用贪心策略**：  
- **前 k 大/小元素维护**：优先队列动态优化。  
- **有序性依赖**：先排序，再按顺序处理。  
**同类题目**：  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)  
3. [CF455A Boredom](https://codeforces.com/problemset/problem/455/A)  

---

### 可视化与算法演示设计  
**动画方案**：  
1. **像素风格 Canvas**：  
   - 骑士按能力值排序后横向排列，每个骑士用不同颜色方块表示，方块高度对应金币数。  
   - 当前处理的骑士高亮为红色，其左侧方块标记为可选区域。  
2. **堆动态演示**：  
   - 小根堆右侧显示，每次插入新元素后，若堆大小 >k，弹出最小值（方块爆炸特效）。  
   - 堆顶元素始终显示当前最小金币值。  
3. **音效与交互**：  
   - 插入堆时播放“收集金币”音效，弹出时播放“丢弃”音效。  
   - 支持暂停/步进，观察每一步堆的变化。  

**复古游戏化设计**：  
- **8-bit 音效**：使用 Web Audio API 生成芯片音乐。  
- **积分系统**：每正确维护一次堆得 10 分，连续正确处理触发连击特效。  
- **自动演示模式**：AI 自动执行，速度可调（1x/2x/5x）。  

---

### 个人心得摘录  
- **作者：傅思维666**：  
  > “贪心策略虽然好想，但实现时要注意堆的维护顺序。初始代码因忘记回放元素导致 WA，后来发现必须保证堆的全局状态。”  
- **调试教训**：动态维护堆时需注意元素的增删顺序，避免数据污染。  

---

### 推荐代码（完整实现）  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

struct Knight { int p, c, id, ans; };
vector<Knight> knights;

int main() {
    int n, k; cin >> n >> k;
    knights.resize(n);
    for (int i = 0; i < n; i++) cin >> knights[i].p;
    for (int i = 0; i < n; i++) cin >> knights[i].c;
    for (int i = 0; i < n; i++) knights[i].id = i;
    
    sort(knights.begin(), knights.end(), [](auto& a, auto& b) {
        return a.p < b.p;
    });
    
    priority_queue<int, vector<int>, greater<int>> min_heap;
    int sum = 0;
    for (auto& knight : knights) {
        sum += knight.c;
        min_heap.push(knight.c);
        if (min_heap.size() > k) {
            sum -= min_heap.top();
            min_heap.pop();
        }
        knight.ans = sum;
    }
    
    sort(knights.begin(), knights.end(), [](auto& a, auto& b) {
        return a.id < b.id;
    });
    
    for (auto& knight : knights) cout << knight.ans << ' ';
}
```

---
处理用时：72.54秒
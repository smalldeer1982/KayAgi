# 题目信息

# Sakurako's Box

## 题目描述

Sakurako 有一个装满 $n$ 个球的盒子。每个球都有自己的数值。她想和朋友打个赌，朋友如果从盒子中随机选出两个球（可以是不同的两球，即使它们有相同的数值），这两个球数值的乘积能够等于 Sakurako 事先猜测到的一个数。

因为 Sakurako 是概率学方面的专家，她知道最明智的猜测应该是[期望值](http://tiny.cc/matozh_en)，但她忘了如何去计算。请帮助她计算出这个数组中任意两个元素乘积的期望值。

可以证明，该期望值的形式为 $\frac{P}{Q}$，其中 $P$ 和 $Q$ 是非负整数，且 $Q \ne 0$。你需要计算并输出 $P \cdot Q^{-1} \bmod (10^9+7)$ 的结果。

## 说明/提示

举个例子：
- 在第一个测试用例中，Sakurako 的朋友可以选择这些球对：$(a_1, a_2)$、$(a_1, a_3)$ 和 $(a_2, a_3)$。它们的乘积分别是 $3 \times 2 = 6$、$3 \times 3 = 9$ 和 $3 \times 2 = 6$，所以期望值计算结果为 $\frac{6 + 9 + 6}{3} = 7$。

- 在第二个测试用例中，朋友可以选择的球对有：$(a_1, a_2)$、$(a_1, a_3)$、$(a_1, a_4)$、$(a_2, a_3)$、$(a_2, a_4)$ 和 $(a_3, a_4)$。它们的乘积分别为 $2 \times 2 = 4$、$2 \times 2 = 4$、$2 \times 4 = 8$、$2 \times 2 = 4$、$2 \times 4 = 8$ 和 $2 \times 4 = 8$，所以期望值为 $\frac{4 + 4 + 8 + 4 + 8 + 8}{6} = \frac{36}{6} = 6$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3
3 2 3
4
2 2 2 4
5
1 2 3 4 5```

### 输出

```
7
6
500000012```

# AI分析结果



## 算法分类选择  
**数学**

---

## 综合分析与结论  

### 核心思路与难点  
1. **数学推导**：期望值为所有两两元素乘积之和除以组合数 $C(n,2)$。关键公式为 $\sum_{i<j}a_i a_j = \sum_{j=2}^n a_j \cdot \sum_{i=1}^{j-1} a_i$，通过前缀和优化将计算复杂度从 $O(n^2)$ 降至 $O(n)$。  
2. **逆元计算**：分母的逆元通过费马小定理（快速幂）高效求得。  
3. **实现技巧**：动态维护前缀和，逐个累加每个元素对总和的贡献。  

### 可视化设计要点  
1. **动画流程**：  
   - **数组遍历**：用像素方块表示数组元素，当前处理元素高亮为黄色。  
   - **前缀和显示**：已遍历元素的总和以绿色数字实时更新。  
   - **乘积计算**：当前元素与前缀和的乘积以红色数字弹出，累加到总和中。  
2. **复古风格**：  
   - **颜色方案**：8-bit 调色板（黄、绿、红、灰）。  
   - **音效触发**：  
     - **元素处理**：播放短促的“滴”声。  
     - **总和更新**：播放上扬音调。  
3. **交互功能**：  
   - **步进控制**：用户可逐帧观察前缀和与乘积的更新过程。  
   - **自动模式**：算法以默认速度自动运行，类似贪吃蛇 AI。  

---

## 题解清单 (≥4星)  

### 1. Super_Cube 题解（⭐⭐⭐⭐）  
- **关键亮点**：代码简洁，直接推导公式，输入处理高效。  
- **代码片段**：  
  ```cpp  
  for(int i=1,x;i<n;++i)
      scanf("%d",&x), ans=(ans+1ll*x*s)%mod, (s+=x)<mod?0:s-=mod;
  ```

### 2. Drifty 题解（⭐⭐⭐⭐）  
- **关键亮点**：使用现代 C++ 特性（如 `auto` lambda），解释详细。  
- **代码片段**：  
  ```cpp  
  auto inv = [](i64 a, i64 x = P - 2) { /* 快速幂逆元 */ };
  ```

---

## 最优思路或技巧提炼  

1. **前缀和优化**：  
   - 维护前缀和 $s$，每个元素 $a_j$ 的贡献为 $a_j \cdot s$，累加后更新 $s \leftarrow s + a_j$。  
2. **逆元计算**：  
   - 分母 $\frac{n(n-1)}{2}$ 的逆元通过快速幂计算，避免除法精度问题。  

---

## 同类型题与算法套路  

1. **类似问题**：计算数组所有两数之和的总和（LeetCode 2682）。  
2. **通用解法**：将 $\sum_{i<j} a_i a_j$ 转化为 $\sum a_j \cdot \text{前缀和}$ 的形式。  

---

## 推荐题目  

1. **洛谷 P3131**：前缀和统计子数组和模 7 的倍数。  
2. **LeetCode 1. 两数之和**：哈希表优化查找。  
3. **洛谷 P3911**：数学与因数分解结合。  

---

## 代码实现（关键逻辑）  

### 核心逻辑代码  
```cpp  
int s = a[0], ans = 0;
for (int j = 1; j < n; j++) {
    ans = (ans + 1LL * s * a[j]) % mod; // 累加乘积
    s = (s + a[j]) % mod;              // 更新前缀和
}
int denom = 1LL * n * (n-1) / 2 % mod;
ans = 1LL * ans * qpow(denom, mod-2) % mod; // 逆元计算
```

---

## 复古像素动画设计  

1. **Canvas 初始化**：  
   - 像素块大小 32x32，灰色背景，数组元素用黄色填充。  
2. **动画步骤**：  
   - **步骤 1**：高亮当前元素 $a_j$，显示前缀和 $s$（绿色）。  
   - **步骤 2**：显示 $a_j \cdot s$（红色数字飘动），累加到总和。  
   - **步骤 3**：将 $a_j$ 加入前缀和区域（颜色渐变至绿色）。  
3. **音效规则**：  
   - **元素处理**：8-bit “滴”声（Web Audio API 合成）。  
   - **总和更新**：成功音效（频率 440Hz，持续 0.2s）。  

---

## 个人心得摘录  

> “官方题解可能复杂，但通过前缀和与公式变形，可以大幅简化计算。”  
> —— Drifty 题解中的思维突破点，强调数学变形的重要性。

---
处理用时：121.00秒
# 题目信息

# Left and Right Houses

## 题目描述

在 Letovo 村，有 $ n $ 坐房屋。村民们决定修一条大路，把村子分成左右两部分。每个居民都想住在街道的右边或左边，这被描述为一个顺序 $ a_1, a_2, \dots, a_n $，其中 $ a_j = 0 $ 表示编号为 $ j $ 房子的居民想住在街道的左边；否则，$ a_j = 1 $。

这条路将穿过两座房子之间。它左边的房子将被宣布为左边，右边的房子将被宣布为右边。更正式的说法是，**若道路在房屋 $ i $ 和 $ i+1 $ 之间通行。那么，位于 $ 1 $ 和 $ i $ 之间的房屋将位于街道的左侧，位于 $ i+1 $ 和 $ n $ 之间的房屋将位于街道的右侧**。这条路也**可以在第一所房子前面经过，在最后一所房子后面经过**。在这种情况下，整个村庄分别被声明为右侧或左侧。

为了使设计公平，决定铺设道路，使村庄两边至少有一半的居民对选择感到满意。也就是说，在每一边的 $ x $ 个居民中，至少 $ \lceil\frac{x}{2}\rceil $ 应该想住在另一边，其中 $ \lceil x \rceil $ 表示四舍五入的实数 $ x $。

 [](https://cdn.luogu.com.cn/upload/vjudge＿pic/CF1945C/2ed555a735574721378598482dfea8442c0609da.png)
 
路的左边会有 $ i $ 栋房子，对应的 $ a_j $ 中至少有 $ \lceil\frac{i}{2}\rceil $ 个 $0$。在道路的右侧，将会有 $ n-i $ 房屋，在相应的 $ a_j $ 中必须至少有 $ \lceil\frac{n-i}{2}\rceil $ 房屋。确定道路应该铺设在哪座房子 $ i $ 之后，以满足所描述的条件，并尽可能靠近村庄的中心。正式地说，在所有合适的位置 $ i $ 中，最小化 $ \left|\frac{n}{2} - i\right| $（**注意：这里的 $\frac{n}{2}$ 不做取整操作**）。

如果有多个适合的位置 $ i $ 和最小的 $ \left|\frac{n}{2} - i\right| $，输出较小的位置（即更靠左的位置）。

## 说明/提示

让我们考虑输入数据的第一个示例。

如果我们在第一所房子之后铺设道路，将会有一所房子 $ a_1 = 1 $ 在街道的左侧，其中的居民愿意住在街道的右侧。然后 $ 0 $ 出 $ 1 $ 居民在均匀的一边会满意的选择，这意味着道路不能在房子 $ 1 $ 后铺设。

如果我们在第二所房子之后铺设道路，左侧的 $ 2 $ 个居民中的 $ 1 $ 位（$ a_1 = 1 $, $ a_2 = 0 $）和右侧 $ 1 $ 位居民中的 $ 1 $ 位（$ a_3 = 1 $）将对选择感到满意。两边一半以上的居民都对这个选择感到满意，这意味着这条路可以能在房子 $ 2 $ 后铺设。我们可以证明这是最优答案。

翻译者：[SCAR_L](https://www.luogu.com.cn/user/608703)

## 样例 #1

### 输入

```
7
3
101
6
010111
6
011001
3
000
3
110
3
001
4
1100```

### 输出

```
2
3
2
3
0
1
0```

# AI分析结果



**唯一算法分类**：前缀和

---

### **题解思路与算法要点**
1. **核心思路**  
   - 预处理前缀和数组`pre[]`统计左侧0的数量，后缀和数组`suf[]`统计右侧1的数量。
   - 枚举每个分割点`i`，检查左侧0的数量是否满足`≥ceil(i/2)`，右侧1的数量是否满足`≥ceil((n-i)/2)`。
   - 记录满足条件且离中心`n/2`最近的`i`，若有多个选较小的。

2. **解决难点**  
   - **快速计算条件判断**：通过前缀和避免重复遍历，将条件判断优化至O(1)。
   - **处理浮点中心点**：用`n-2i`的绝对值替代浮点计算，避免精度问题（如NEKO_Daze的题解）。
   - **边界处理**：正确包含分割点在首尾的情况（如`i=0`和`i=n`）。

3. **关键变量与步骤**  
   - **前缀和`pre[i]`**：从左到右累加0的个数。
   - **后缀和`suf[i]`**：从右到左累加1的个数。
   - **最小化`|n/2 -i|`**：通过维护最小差值和对应的`i`。

---

### **题解评分（≥4星）**
1. **Otue (★★★★☆)**  
   - **亮点**：代码简洁，明确使用前缀和后缀数组，正确处理条件判断。
   - **代码片段**：
     ```cpp
     for (int i = 0; i <= n; i++) {
         if (sum[i] >= (i + 1) / 2 && pre[i + 1] >= (n - i + 1) / 2) {
             // 更新最优解
         }
     }
     ```

2. **SCAR_L (★★★★☆)**  
   - **亮点**：注释清晰，处理首尾边界准确，直接使用`(i+1)/2`计算ceil。
   - **代码片段**：
     ```cpp
     if (p1[i] >= (i + 1) / 2 && p2[i+1] >= (n - i + 1) / 2)
     ```

3. **jubingkun (★★★★☆)**  
   - **亮点**：通过`round`函数简化条件判断，代码结构清晰。
   - **代码片段**：
     ```cpp
     if (pre[i] >= round(i/2.0) && nxt[i+1] >= round((n-i)/2.0))
     ```

---

### **最优思路与技巧**
1. **前缀和优化**：用O(n)预处理快速获取任意区间的0/1数量。
2. **整数替代浮点**：通过比较`|n-2i|`避免浮点精度问题（如NEKO_Daze）。
3. **边界处理技巧**：枚举`i`从0到n，包含所有可能分割点。

---

### **类似题目推荐**
1. **P1719 最大加权矩形**（二维前缀和）
2. **P3406 海底高铁**（差分数组优化）
3. **P1115 最大子段和**（前缀和与动态规划）

---

### **可视化设计**
1. **动画方案**：  
   - **Canvas网格**：每栋房子显示为方块，左半蓝色（0）、右半红色（1）。
   - **分割线高亮**：遍历时移动分割线，绿色表示符合条件，红色不符合。
   - **动态数值显示**：实时显示左侧0的数量和右侧1的占比要求。

2. **复古像素风格**：  
   - **8位音效**：分割线移动时播放“哔”声，符合条件时播放“叮”声。
   - **自动演示模式**：AI自动遍历所有分割点，最优解出现时闪烁提示。

3. **交互控制**：  
   - **速度调节**：滑动条控制遍历速度。
   - **单步调试**：手动点击逐步观察条件判断过程。

---

**示例代码（核心逻辑）**  
```cpp
// 前缀和与后缀和预处理
for (int i = 1; i <= n; i++) 
    pre[i] = pre[i-1] + (a[i] == '0');
for (int i = n; i >= 1; i--)
    suf[i] = suf[i+1] + (a[i] == '1');

// 枚举分割点并更新最优解
double mid = n / 2.0;
int best = 0;
double min_diff = INF;
for (int i = 0; i <= n; i++) {
    if (pre[i] >= (i+1)/2 && suf[i+1] >= (n-i+1)/2) {
        double diff = fabs(mid - i);
        if (diff < min_diff || (diff == min_diff && i < best)) {
            min_diff = diff;
            best = i;
        }
    }
}
cout << best << endl;
```

---

**个人心得**  
- **调试教训**：初始未正确处理`i=0`导致首尾边界错误，需测试极端情况。
- **优化启发**：用整数运算替代浮点比较大幅提升效率。

---
处理用时：94.80秒
# 题目信息

# Creating the Contest

## 题目描述

你有一个包含 $ n $ 个问题的问题集，其中第 $ i $ 个问题的难度为 $ a_i $ ，保证没有难度相同的两个问题，且问题难度按照递增顺序给出。

你需要在这个问题集中取一个子集（不要求问题的顺序连续），满足以下条件：对于每道题目，在该子集中不存在难度超过该问题难度2倍的题目。（仅包含一个问题的子集也是合法的）

求出这个子集最多能包含多少个问题。

## 样例 #1

### 输入

```
10
1 2 5 6 7 10 21 23 24 49
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5
2 10 50 110 250
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6
4 7 12 100 150 199
```

### 输出

```
3
```

# AI分析结果



# 算法分类  
**贪心**

---

# 综合分析与结论  
## 核心思路  
题目要求在递增序列中找最长连续子序列，使得每个元素不超过前一个元素的两倍。通过分析不同题解发现，贪心策略是最优解：**维护当前连续子序列长度，遇到断点则更新最大值**。

## 解决难点  
1. **贪心正确性证明**：需证明最长子序列一定是连续的。利用序列单调性，若存在不连续的情况，中间元素必然可被包含，从而形成更长的连续子序列。  
2. **动态规划优化**：对于非贪心解法，需用线段树或单调队列维护区间最大值，优化复杂度至 O(n)。  

## 可视化设计  
- **动画流程**：  
  1. 用色块表示数组元素，绿色表示当前处理的元素  
  2. 红色箭头标记相邻元素比较（检查是否满足 a[i+1] ≤ 2*a[i]）  
  3. 动态显示计数器（蓝色数字）和当前最长长度（黄色数字）  
  4. 断点出现时用闪光特效，并重置计数器  
- **复古风格**：  
  1. 8-bit 像素字体显示数组和计数器  
  2. 背景音乐使用低比特芯片音效循环播放  
  3. 满足条件时播放「叮」音效，断点时播放「咔嚓」音效  

---

# 高星题解推荐 (≥4⭐️)  
1. **一扶苏一（5⭐️）**  
   - 亮点：同时给出贪心与动态规划两种解法，包含严格数学证明  
   - 代码简洁，时间复杂度 O(n)  

2. **彭骐飞（4⭐️）**  
   - 亮点：用单调队列优化动态规划至 O(n)，思路巧妙  
   - 包含队列维护策略的详细推导  

3. **MattL（4⭐️）**  
   - 亮点：最简贪心实现，代码仅 10 行  
   - 明确处理循环结束后的最大值更新  

---

# 最优代码实现  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, cnt = 1, ans = 1;
    cin >> n;
    int a[n];
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 1; i < n; ++i) {
        if (a[i] <= 2 * a[i-1]) cnt++;
        else ans = max(ans, cnt), cnt = 1;
    }
    cout << max(ans, cnt);
}
```

**核心逻辑**：  
- `cnt` 维护当前连续子序列长度  
- 遍历时比较相邻元素，若满足条件则延长，否则重置  
- 循环结束后需再次比较（处理末尾连续段）  

---

# 相似题目推荐  
1. **P1091 合唱队形**（最长递增/递减子序列）  
2. **P1280 尼克的任务**（贪心选择时间区间）  
3. **P1233 木棍加工**（二维贪心排序）  

---

# 个人心得摘录  
- **调试教训**：循环结束后容易遗漏 `max(ans, cnt)` 导致错误（@KagurazakaKano）  
- **思维突破**：发现序列单调性后，贪心策略自然浮现（@一扶苏一）  

---

# 可视化算法演示（伪代码）  
```javascript
// 模拟贪心过程（Canvas 实现）
function animate() {
    drawArray(); // 绘制数组色块
    highlightCurrent(i); // 高亮当前元素
    if (a[i] <= 2 * a[i-1]) {
        playSound('beep'); // 播放成功音效
        cnt++;
        drawCounter(cnt); // 更新计数器动画
    } else {
        playSound('break'); 
        ans = Math.max(ans, cnt);
        drawMax(ans); // 显示最大值爆炸特效
        cnt = 1;
    }
    requestAnimationFrame(animate);
}
```

---
处理用时：66.48秒
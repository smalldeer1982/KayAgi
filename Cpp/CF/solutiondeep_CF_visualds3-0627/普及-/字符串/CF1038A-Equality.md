# 题目信息

# Equality

## 题目描述

### 题目大意：
给定一个长度为$n$的字符串和$k$，问这个字符串包含字母表前$k$个大写字母并且数量相同的子序列最长是多少

## 样例 #1

### 输入

```
9 3
ACAABCCAB
```

### 输出

```
6```

## 样例 #2

### 输入

```
9 4
ABCABCABC
```

### 输出

```
0```

# AI分析结果



**唯一算法分类**：计数问题/贪心算法

---

### **综合分析与结论**

**核心思路**  
题目要求找出包含前k个大写字母且各字母数量相等的子序列的最大长度。通过统计每个字母的出现次数，取前k个字母中出现次数的最小值，乘以k即可得到答案。该思路基于贪心策略，确保每个字母的使用次数不超过最小值，从而保证等量存在。

**难点与解决**  
1. **正确统计前k个字母**：需注意字母的索引转换（如A对应0或1）。
2. **处理未出现的字母**：若前k个字母中有未出现的（次数为0），结果直接为0。
3. **子序列不要求连续**：无需考虑顺序，仅需关注出现次数。

**题解对比**  
- 所有题解均采用统计计数后取最小值的思路，差异仅在于实现细节（如数组索引、求最小值方式）。
- **abensyl的题解**通过排序取最小值，时间复杂度略高但正确；其他题解直接遍历更高效。

---

### **题解清单 (≥4星)**

1. **piggymichael (4星)**  
   - 亮点：代码简洁，直接遍历求最小值，数组索引处理准确。
   - 代码可读性高，无冗余操作。

2. **Sternenlicht (4星)**  
   - 亮点：使用快速读写模板提升效率，注释清晰，逻辑明确。
   - 处理初始值为`INF`，避免初始值干扰。

3. **flora715 (4星)**  
   - 亮点：代码极简，数组命名清晰，注释直接点明题目核心。
   - 省略非必要头文件，保持代码紧凑。

---

### **最优思路提炼**

1. **计数统计**：用数组统计各字母出现次数。
2. **贪心选择**：取前k个字母的最小次数，确保子序列等量存在。
3. **数学计算**：结果=最小值×k，时间复杂度O(n + k)，高效可靠。

---

### **同类型题推荐**

1. **P1321 单词覆盖统计**（统计字母频率）  
2. **P2550 [AHOI2001]彩票摇奖**（计数与匹配）  
3. **P1598 垂直柱状图**（字母频率可视化）

---

### **可视化与算法演示**

**核心步骤动画设计**  
1. **字母计数阶段**：高亮字符串中的每个字符，对应字母的计数器递增。
2. **最小值查找阶段**：遍历前k个字母的计数器，动态标记当前最小值。
3. **结果计算**：显示最小值与k的乘积，以醒目标记展示最终结果。

**复古像素风格实现**  
- **Canvas绘制**：网格显示每个字母的计数器，用不同颜色块表示计数大小。
- **音效提示**：计数器更新时播放短音效，找到最小值时播放上扬音调。
- **自动演示**：按步播放计数、求最小值、输出结果，速度可调。

```javascript
// 示例：Canvas绘制字母计数（伪代码）
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
// 绘制初始计数器网格
for (let i = 0; i < k; i++) {
  drawPixelBlock(i, 0, initialCountColor);
}
// 更新计数动画
function updateCount(char) {
  const idx = char - 'A';
  highlightChar(char); // 高亮当前字符
  incrementCounter(idx); // 计数器动画增长
  playSound('count');
}
```

---

**答案**  
所有题解均正确，核心思路为统计前k字母的最小出现次数并乘k。**最优代码**如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    string s;
    cin >> n >> k >> s;
    int cnt[26] = {0};
    for (char c : s) cnt[c - 'A']++;
    int min_cnt = INT_MAX;
    for (int i = 0; i < k; i++) 
        min_cnt = min(min_cnt, cnt[i]);
    cout << min_cnt * k << endl;
    return 0;
}
```

---
处理用时：98.59秒
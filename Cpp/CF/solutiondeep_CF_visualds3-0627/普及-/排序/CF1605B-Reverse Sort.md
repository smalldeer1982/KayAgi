# 题目信息

# Reverse Sort

## 题目描述

题目共给出 $t(1 \le t \le 1000)$ 组数据，每组数据包含一个正整数 $n(1 \le n \le 1000)$ 和一个长度为 $n$ 的 $01$ 串 $s$， 现在你需要在 $s$ 中选出一个子序列，将这个子序列中的字符翻转（如字符串 $10100$， 选出子序列 $1100$， 翻转得到 $0011$， 放回原串中得到 $00011$），使得翻转后的字符串字典序最小。

## 样例 #1

### 输入

```
3
7
0011111
5
10100
6
001000```

### 输出

```
0
1
4 1 3 4 5 
1
3 3 5 6```

# AI分析结果



---

## **算法分类**  
贪心算法  

---

## **题解思路与核心难点**  

### **核心思路**  
1. **目标状态确定**：最终字典序最小的字符串为所有 `0` 在前、所有 `1` 在后。  
   - 统计原串中 `0` 的数量 `cnt0`，前 `cnt0` 个字符应为 `0`，后 `cnt1 = n - cnt0` 个字符应为 `1`。  
2. **关键观察**：若原串未排序，则存在前 `cnt0` 中的 `1` 和后 `cnt1` 中的 `0`。反转这些位置的字符即可达成目标。  
3. **一次操作足够**：通过一次反转子序列操作，将前 `cnt0` 中的 `1` 和后 `cnt1` 中的 `0` 配对翻转，使得所有 `0` 前移、`1` 后移。  

### **解决难点**  
- **子序列选择**：需精准找出前 `cnt0` 中的 `1` 和后 `cnt1` 中的 `0`，并确保它们的数量相等。  
- **正确性证明**：反转后，前 `cnt0` 中的 `1` 变为 `0`，后 `cnt1` 中的 `0` 变为 `1`，从而满足目标状态。  

---

## **题解评分**  
以下为评分≥4星的题解：  

1. **Jerrlee✅（5星）**  
   - **亮点**：代码简洁，直接遍历统计关键位置，逻辑清晰。  
   - **代码**：线性遍历，高效统计需要反转的位置。  

2. **wzy2021（4星）**  
   - **亮点**：使用双数组分别记录前部 `1` 和后部 `0` 的位置，结构清晰。  
   - **优化**：倒序记录后部 `0` 的位置，确保输出顺序正确。  

3. **Jur_Cai（4星）**  
   - **亮点**：通过双指针动态减少 `1` 的计数，避免冗余遍历。  
   - **实现**：记录无需交换的 `1`，减少操作次数。  

---

## **最优思路提炼**  
- **贪心策略**：通过一次操作修正所有错误位置。  
- **关键步骤**：  
  1. 统计 `cnt0` 和 `cnt1`。  
  2. 遍历前 `cnt0` 个字符，记录所有 `1` 的位置。  
  3. 遍历后 `cnt1` 个字符，记录所有 `0` 的位置。  
  4. 将这些位置合并为子序列，反转后即可达成目标。  

---

## **相似题目推荐**  
1. **CF1605B - Reverse Sort**（原题）  
2. **LeetCode 942 - DI String Match**（构造最小字典序排列）  
3. **LeetCode 670 - Maximum Swap**（贪心交换数字位置）  
4. **洛谷 P1106 - 删数问题**（贪心构造最小数）  

---

## **代码实现（核心逻辑）**  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int t; cin >> t;
    while (t--) {
        int n; string s;
        cin >> n >> s;
        int cnt0 = count(s.begin(), s.end(), '0');
        bool sorted = true;
        for (int i = 1; i < n; i++)
            if (s[i] < s[i-1]) sorted = false;
        if (sorted) { cout << "0\n"; continue; }
        
        vector<int> pos;
        for (int i = 0; i < cnt0; i++)
            if (s[i] == '1') pos.push_back(i+1);
        for (int i = cnt0; i < n; i++)
            if (s[i] == '0') pos.push_back(i+1);
        
        cout << "1\n" << pos.size() << " ";
        for (int p : pos) cout << p << " ";
        cout << "\n";
    }
    return 0;
}
```

---

## **可视化设计**  
### **动画方案**  
1. **颜色标记**：  
   - 红色：前 `cnt0` 中的 `1`。  
   - 蓝色：后 `cnt1` 中的 `0`。  
   - 黄色：反转后的字符。  
2. **步骤演示**：  
   - 初始串高亮错误位置。  
   - 选中子序列并翻转，动态更新字符颜色。  
3. **复古像素风格**：  
   - 使用 8-bit 像素字体和色块表示字符。  
   - 背景音乐：8-bit 风格循环音效，关键操作时触发“哔”声。  

### **交互设计**  
- **控制面板**：暂停/继续、单步执行、速度调节。  
- **自动模式**：AI 自动演示如何选择子序列并反转。  

---

## **个人心得**  
- **踩坑点**：下标从 1 开始输出，需在代码中 `+1`。  
- **调试技巧**：先验证原串是否已排序，避免无效操作。  
- **思维突破**：意识到只需一次操作即可完成所有修正，避免复杂动态规划。  

---

---
处理用时：65.03秒
# 题目信息

# Splitting Items

## 题目描述

Alice 和 Bob 有 $n$ 个数，第 $i$ 个数为 $a_i$，他们决定玩一个游戏取走这些数。

游戏由 Alice 开始取数。

每一次玩家都可以拿走一个剩下的数，直到没有数字可拿走。

定义 $A$ 是 Alice 获取的数字和，$B$ 是 Bob 获取的数字和，游戏总分 $p = A - B$。

Alice 希望最大化 $p$，Bob 希望最小化 $p$，他们都绝顶聪明。

现在 Bob 拥有了修改数的权限，可以把一些数字（可以没有，也可以没有全部）**增加**一个整数值（可以增加不同的值），但是这样 Alice 可能会起疑心，所以总增加的数值必须小于等于 $k$。

请求出 Bob 能达到的 $p$ 的最小值。

## 样例 #1

### 输入

```
4
2 5
1 10
3 0
10 15 12
4 6
3 1 2 4
2 4
6 9```

### 输出

```
4
13
0
0```

# AI分析结果



**唯一算法分类**: 贪心算法

---

### **综合分析与结论**

**核心思路**:  
将数组降序排序后，双方轮流取最大值。Alice 取奇数位，Bob 取偶数位。Bob 通过增加偶数位的值（总增量 ≤k），使其尽可能接近前一个奇数位的值，从而最大化 Bob 的总和，最小化 `A-B`。

**解决难点**:  
- **贪心策略**: 必须保证修改后的偶数位值不超过前一个奇数位值，否则该数会被 Alice 取走。  
- **分配 k**: 按差值从小到大依次填补偶数位，确保 `k` 的利用率最高。

**算法流程**:  
1. 降序排序数组。  
2. 遍历每个偶数位 `i`，计算与前一个奇数位 `i-1` 的差值 `delta`。  
3. 若剩余 `k >= delta`，将 `a[i]` 增加到 `a[i-1]`，并消耗 `delta`。  
4. 若 `k < delta`，将 `a[i] += k` 并终止分配。  
5. 最终计算奇偶位的总和差 `A-B`。

---

### **题解清单 (≥4星)**

1. **Stars_Traveller (5星)**:  
   - **亮点**: 代码逻辑清晰，直接遍历偶数位并处理 `k`，注释简洁。  
   - **代码**: 使用 `for(int i=2; i<=n; i+=2)` 循环处理偶数位，明确体现贪心策略。

2. **RaymondOccam (4星)**:  
   - **亮点**: 详细解释了排序后偶数位修改的数学原理，代码可读性强。  
   - **代码片段**:  
     ```cpp
     if (k >= x) a[i] += x, k -= x;
     else a[i] += k, k = 0;
     ```

3. **Scean_Tong (4星)**:  
   - **亮点**: 代码简洁，通过 `i%2` 直接区分奇偶位，逻辑紧凑。  
   - **个人心得**: 强调修改后的顺序不能改变，否则会影响取数策略。

---

### **最优思路与技巧提炼**

1. **排序与奇偶位分离**:  
   - 降序排序后，奇偶位的归属直接确定，无需动态博弈分析。

2. **贪心分配 k**:  
   - 优先填补差值最小的偶数位，确保 `k` 的利用率最大化。

3. **边界处理**:  
   - 若 `k` 耗尽，直接终止分配，避免无效操作。

---

### **同类型题与算法套路**

- **通用解法**:  
  1. 排序确定优先级。  
  2. 按固定策略分配资源（如 `k`）。  
  3. 处理边界条件。

- **类似题目**:  
  1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090): 贪心选择最小堆合并。  
  2. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995): 交替取最大最小值。  
  3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223): 贪心排序最小等待时间。

---

### **可视化与算法演示**

**动画方案**:  
1. **Canvas 绘制**:  
   - 数组降序排列为横向条形图，奇偶位用红蓝区分。  
   - 处理偶数位时，动态显示条形高度增加，剩余 `k` 用进度条表示。

2. **关键步骤高亮**:  
   - **当前操作元素**: 黄色边框标记正在处理的偶数位。  
   - **变化效果**: 数值增加时条形图高度渐变，伴随音效。  

3. **复古像素风格**:  
   - **调色板**: 8-bit 风格，红（Alice）、蓝（Bob）、黄（操作位）。  
   - **音效**:  
     - 增加数值时播放 "beep" 短音。  
     - `k` 耗尽时播放低音 "buzz"。

4. **交互控制**:  
   - **步进按钮**: 单步执行、暂停、重置。  
   - **速度调节**: 滑动条控制动画速度。

---

### **核心代码实现**

**关键逻辑片段**:  
```cpp
sort(a + 1, a + n + 1, greater<int>()); // 降序排序
for (int i = 2; i <= n; i += 2) {
    int delta = a[i-1] - a[i];
    if (k >= delta) {
        a[i] = a[i-1];
        k -= delta;
    } else {
        a[i] += k;
        k = 0;
        break;
    }
}
// 计算最终 A-B
int ans = 0;
for (int i = 1; i <= n; i++) {
    ans += (i % 2 == 1) ? a[i] : -a[i];
}
cout << ans << endl;
```

---

### **个人心得摘录**

- **关键教训**:  
  > "如果修改后的偶数位值超过前一个奇数位，Alice 会取走它，导致 Bob 的总和反而减少。因此必须严格限制增量不超过差值。" —— Stars_Traveller

- **调试经验**:  
  > "需注意 `k` 耗尽后立即终止循环，否则会错误地继续操作剩余偶数位。" —— Scean_Tong

---
处理用时：80.78秒
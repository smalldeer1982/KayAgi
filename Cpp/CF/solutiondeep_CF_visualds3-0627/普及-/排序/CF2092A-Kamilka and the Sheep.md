# 题目信息

# Kamilka and the Sheep

## 题目描述

Kamilka 有一群由 $n$ 只绵羊组成的羊群，第 $i$ 只绵羊的美丽值为 $a_i$。所有 $a_i$ 均互不相同。清晨已至，需要给绵羊喂食。Kamilka 可以选择一个非负整数 $d$ 并给每只绵羊喂食 $d$ 捆草。此后，每只绵羊的美丽值将增加 $d$。

傍晚时，Kamilka 必须选择恰好两只绵羊带往山区。若这两只绵羊的美丽值（在喂食后）分别为 $x$ 和 $y$，则 Kamilka 此次散步的乐趣等于 $\gcd(x, y)$，其中 $\gcd(x, y)$ 表示整数 $x$ 和 $y$ 的[最大公约数 (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor)。

任务是通过合理选择 $d$，求出 Kamilka 能获得的最大可能乐趣。

## 说明/提示

第一个测试用例中，选择 $d=1$ 可行。此时乐趣为 $\gcd(1+1, 3+1)=\gcd(2, 4)=2$。可以证明无法获得更大的答案。

第二个测试用例中，选择 $d=3$。此时乐趣为 $\gcd(5+3, 1+3)=\gcd(8, 4)=4$。因此该测试用例的答案为 $4$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
2
1 3
5
5 4 3 2 1
3
5 6 7
3
1 11 10```

### 输出

```
2
4
2
10```

# AI分析结果



## 算法分类
数学

## 综合分析与结论

### 核心思路
题目要求通过选择非负整数 `d`，使得两只绵羊喂食后的美丽值的最大公约数（GCD）最大。关键在于发现，最大可能的 GCD 是数组中最大值与最小值的差。

### 数学推导
设数组最大值为 `a_max`，最小值为 `a_min`，差值为 `D = a_max - a_min`。通过选择 `d` 使得 `a_min + d` 和 `a_max + d` 均为 `D` 的倍数，此时它们的 GCD 就是 `D`。例如：
- 当 `d = D - a_min % D` 时，`a_min + d` 和 `a_max + d` 分别为 `D` 和 `2D`，其 GCD 为 `D`。

### 实现方法
遍历数组一次，找到最大值和最小值，计算差值即可。时间复杂度 `O(n)`，空间复杂度 `O(1)`。

### 可视化设计
- **动画方案**：将数组元素以柱状图展示，动态高亮最大值和最小值，计算差值并显示结果。
- **颜色标记**：最大值和最小值用不同颜色（如红色和蓝色）高亮。
- **步进控制**：允许单步执行，展示遍历过程。
- **复古像素风格**：使用 8 位像素风格渲染柱状图，背景音乐和音效增强交互体验。

## 题解评分（5星）
无其他题解，但该思路简洁高效，符合所有样例，正确性经过数学验证，评为5星。

## 最优思路提炼
**关键数学性质**：数组中最大值与最小值的差即为答案。无需复杂计算，直接遍历找极值即可。

## 同类型题
类似问题通常涉及极值或数学性质推导，如：
1. 最大子数组和（Kadane算法）
2. 寻找两个数的最大差值（股票买卖问题）
3. 最大公约数相关性质应用

## 推荐题目
1. P1216 [USACO1.5] 数字三角形 Number Triangles
2. P1115 最大子段和
3. P1029 最大公约数和最小公倍数问题

## 代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        int max_val = *max_element(a.begin(), a.end());
        int min_val = *min_element(a.begin(), a.end());
        cout << max_val - min_val << endl;
    }
    return 0;
}
```

---
处理用时：135.35秒
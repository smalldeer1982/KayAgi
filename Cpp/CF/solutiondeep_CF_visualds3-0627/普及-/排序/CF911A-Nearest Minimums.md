# 题目信息

# Nearest Minimums

## 题目描述

You are given an array of $ n $ integer numbers $ a_{0},a_{1},...,a_{n-1} $ . Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.
找到一个长度为n的序列中，距离最短的最小值的距离。

## 样例 #1

### 输入

```
2
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
9
2 1 3 5 4 1 2 3 1
```

### 输出

```
3
```

# AI分析结果



---

## **算法分类**
无算法分类

---

## **综合分析与结论**
**核心思路**：所有题解均通过两次遍历解决问题：  
1. **找最小值**：遍历数组确定最小值。  
2. **计算最小间距**：记录所有最小值的位置，比较相邻位置的差值。  
**优化亮点**：部分题解通过单次遍历优化空间复杂度至 O(1)，或在代码结构上提升可读性。  

**可视化设计**：  
- **动画方案**：高亮当前遍历元素，标记最小值位置，动态更新相邻最小值间距。  
- **复古风格**：用 8 位像素网格表示数组，最小值用红色方块，遍历指针用绿色箭头，间距计算时触发音效。  
- **交互功能**：支持单步执行，展示变量（最小值、当前位置、最短距离）的实时变化。

---

## **题解清单 (≥4星)**
### 1. **da32s1da 的题解（5星）**
- **亮点**：单次遍历，空间 O(1)，通过维护上一个最小值位置动态更新最短距离。  
- **关键代码**：  
  ```cpp
  if (minn == x && ans > i - wz) ans = i - wz;  // 动态更新最短距离
  if (minn > x) minn = x, wz = i, ans = n;      // 发现更小值时重置
  ```

### 2. **vectorwyx 的题解（4星）**  
- **亮点**：使用 `vector` 存储位置，代码结构清晰，可读性高。  
- **关键代码**：  
  ```cpp
  vector<int> wyx;                              // 动态存储最小值位置
  for (int i=1; i<l; ++i) ans = min(ans, wyx[i] - wyx[i-1]); // 计算间距
  ```

### 3. **归褯雾嵊 的题解（4星）**  
- **亮点**：直接的双遍历思路，适合快速理解问题本质。  
- **关键代码**：  
  ```cpp
  for (int i=2; i<total; i++) jl = min(jl, wz[i] - wz[i-1]); // 比较相邻位置
  ```

---

## **最优思路提炼**
1. **单次遍历优化**：在遍历时动态维护最小值及其位置，无需额外存储所有位置（空间 O(1)）。  
2. **状态重置机制**：当遇到更小的值时，立即重置最短距离和记录位置，确保后续计算正确性。  
3. **数据结构选择**：使用 `vector` 动态存储位置，避免预分配大数组，提升内存效率。

---

## **同类型题推荐**
1. **P1115 最大子段和**：动态维护当前子段和的极值。  
2. **P1217 寻找最近的回文数**：通过遍历比较相邻候选值。  
3. **P1582 倒水问题**：状态维护与极值计算的结合。

---

## **可视化代码片段（JS）**
```javascript
// 复古像素风格绘制数组
function drawArray(ctx, arr, minVal, currentIdx) {
  for (let i = 0; i < arr.length; i++) {
    ctx.fillStyle = arr[i] === minVal ? '#FF0000' : '#FFFFFF'; // 红色为最小值
    ctx.fillRect(i * 20, 0, 18, 18);
    if (i === currentIdx) {
      ctx.fillStyle = '#00FF00'; // 绿色箭头表示当前遍历位置
      ctx.fillRect(i * 20, 20, 18, 18);
    }
  }
}
```

---

## **个人心得摘录**
- **da32s1da**：通过单次遍历避免存储所有位置，“边遍历边比较”是空间优化的关键。  
- **vectorwyx**：“使用 `vector` 让代码更现代”，体现了数据结构选择对代码质量的影响。

---
处理用时：73.74秒
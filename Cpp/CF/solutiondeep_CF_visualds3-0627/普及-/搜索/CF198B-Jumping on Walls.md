# 题目信息

# Jumping on Walls

## 题目描述

瓦西亚在和忍者玩电脑游戏。在这个关卡，瓦西亚需要操控忍者走出一个很深的峡谷。

峡谷由两面垂直于地面且互相平行的墙组成，它们的高度为$n$米。我们将这些墙分成许多$1$米长的区域，并从下到上用$1$到$n$的正整数对它们进行编号。有些地方是安全的，忍者可以爬上去。有些地方石头很尖锐，忍者不能待在那里。我们称这些地区为危险地区。

最初忍者在左墙的最下方。他每秒可以执行以下操作之一：

* 向上爬一个区域；
* 向下爬一个区域；
* 跳到对面的墙上。忍者会跳到比他当前所在高度高$k$米的地方。更准确地说，如果在跳跃之前忍者位于一面墙的区域$x$，那么在跳跃之后，他位于另一面墙的区域$x + k$。

如果在某个时间点忍者到达了一个高度大于$n$的区域，那么忍者就可以从峡谷中出来了。

但峡谷被水淹没了，每秒水位会上升一米。最初，水位达到区域$1$的下边界。忍者不能待在被水淹没的地方。忍者和水轮流移动——首先忍者行动，然后水上升一米，然后忍者再行动，以此类推。

如果忍者可以离开峡谷，那这个关卡就完成了。

在几次失败的尝试之后，瓦西亚开始怀疑是否有可能完成这一关卡。请回答他的问题。

## 说明/提示

在第一个样例中，忍者可以先跳到右边的墙，然后沿着右边的墙往下走一米，然后跳到左边的墙。再跳跃一次忍者就可以离开峡谷。

在第二个样例中，忍者是无法离开峡谷的。

## 样例 #1

### 输入

```
7 3
---X--X
-X--XX-
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
6 2
--X-X-
X--XX-
```

### 输出

```
NO
```

# AI分析结果



**唯一算法分类**  
BFS  

**综合分析与结论**  

本题核心是模拟忍者在水位不断上涨的环境下寻找逃生路径的状态搜索问题。各题解主要采用 BFS 或 DFS，通过记录访问状态（墙的编号、高度）进行剪枝，避免重复搜索。关键难点在于处理水位上涨与状态有效性的关系，以及跳跃操作的越界判断。

**算法要点与解决难点**  
1. **状态表示**：用三元组（当前高度、所在墙面、当前时间）表示状态，其中时间决定了水位高度。
2. **剪枝策略**：使用二维数组 `visited[墙][高度]` 标记已访问状态。若某状态已被访问，则无需重复处理（因更早的时间步访问时存活概率更高）。
3. **操作转移**：
   - 向上/向下移动时需检查新高度是否安全且未被淹没。
   - 跳跃操作需判断目标墙和高度是否越界或安全。
4. **终止条件**：当高度超过 n 时成功逃脱；当高度被淹没或处于危险区域时失败。

**题解清单 (≥4星)**  
1. **Alex_Wei (BFS)** ★★★★☆  
   - 亮点：清晰的队列处理逻辑，通过预处理将危险区域直接标记为不可访问，优化了状态检查效率。  
   - 关键代码：在扩展状态时直接判断是否越界，避免数组越界错误。  

2. **乐乐乐还在乐 (DFS)** ★★★★☆  
   - 亮点：通过递归实现简洁的 DFS，剪枝逻辑明确（记录访问状态），代码可读性强。  
   - 关键代码：`rmb[where][height]` 标记已访问状态，防止重复搜索。  

3. **Federico2903 (BFS)** ★★★★☆  
   - 亮点：结构体封装状态，预处理危险区域，代码模块化程度高。  
   - 关键代码：在扩展跳跃操作时直接判断是否越界，提升效率。  

**最优思路提炼**  
1. **状态剪枝**：记录每个（墙，高度）组合是否已被访问，忽略时间维度（因更早时间的访问更优）。  
2. **水位逻辑**：通过时间 `t` 隐式表示水位，判断 `height > t` 即可保证存活。  
3. **跳跃优化**：跳跃操作直接检查目标高度是否越界，避免无效计算。  

**同类型题与算法套路**  
- **迷宫搜索**：类似《走迷宫》问题，需处理移动方向与障碍物（如 [P1443](https://www.luogu.com.cn/problem/P1443)）。  
- **分层 BFS**：水位上涨对应时间分层，与《推箱子》中的步数分层 BFS 相似。  
- **状态压缩**：记录多维状态避免重复，类似《八数码问题》（如 [P1379](https://www.luogu.com.cn/problem/P1379)）。  

**推荐相似题目**  
1. P1443 马的遍历（BFS 基础）  
2. P1135 奇怪的电梯（状态转移与剪枝）  
3. P1379 八数码问题（状态压缩与搜索）  

**个人心得摘录**  
- **乐乐乐还在乐**：提到未剪枝的 DFS 会导致 TLE，强调状态记录的重要性。  
- **Alex_Wei**：强调 BFS 的队列初始化与越界检查顺序，避免数组越界。  

**可视化与算法演示**  
1. **动画方案**：  
   - **网格绘制**：左右墙面以两列网格表示，高度从下到上递增，危险区域用红色标记。  
   - **状态扩展**：当前节点高亮为绿色，待访问节点加入队列时显示为黄色，已访问节点灰化。  
   - **水位上涨**：用蓝色水平线从底部逐渐上升，动态更新当前时间步。  

2. **复古像素风格**：  
   - **颜色方案**：墙面用 8 位深绿色，危险区域用暗红色，水位线用浅蓝色。  
   - **音效设计**：访问新节点时播放短促“哔”声，逃脱成功时播放胜利音效。  

3. **交互功能**：  
   - **步进控制**：支持暂停/继续/单步执行，速度可调节。  
   - **自动演示**：AI 自动运行 BFS，展示队列动态变化与状态扩展过程。  

**核心代码片段 (BFS 实现)**  
```cpp
struct pos { int h, t, way; }; // 高度、时间、墙面
queue<pos> q;
bool visited[2][MAXN];

bool bfs() {
    q.push({1, 0, 0});
    visited[0][1] = true;
    while (!q.empty()) {
        pos cur = q.front(); q.pop();
        if (cur.h > n) return true; // 成功逃脱
        if (cur.h <= cur.t) continue; // 被淹没
        // 扩展三个方向
        for (int dh : {-1, 1}) { // 上下移动
            int nh = cur.h + dh;
            if (nh > 0 && !visited[cur.way][nh] && safe[cur.way][nh]) {
                visited[cur.way][nh] = true;
                q.push({nh, cur.t + 1, cur.way});
            }
        }
        // 跳跃到对面墙
        int nh = cur.h + k;
        int nway = 1 - cur.way;
        if (nh > n) return true;
        if (nh > 0 && !visited[nway][nh] && safe[nway][nh]) {
            visited[nway][nh] = true;
            q.push({nh, cur.t + 1, nway});
        }
    }
    return false;
}
```

---
处理用时：147.71秒
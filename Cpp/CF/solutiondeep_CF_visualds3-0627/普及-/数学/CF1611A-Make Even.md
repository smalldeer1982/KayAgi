# 题目信息

# Make Even

## 题目描述

Polycarp 有一个不包含数字 $0$ 的整数 $n$。他可以使用他的数字执行以下操作数次（可能为零）：

将 $n$ 的长度 $l\ (1 \leq l \leq |n|$，这里 $|n|$ 指 $n$ 的十进制长度 $)$ 的前缀反转，即反转 $n$ 的 前 $l$ 位数字。那么，第 $1$ 个数位（默认从左向右数，下文同理）将与第 $l$ 个数位交换，第 $2$ 个数位与第 $(l-1)$ 个交换......以此类推。

例如，如果 $n=123456789$ 且 $l=5$，则 $n$ 变换后的值将为 $543216789$。

对于不同的操作，$l$ 的值可能不同。

Polycarp 喜欢偶数，并且非常不耐烦。因此，他想用最少的操作次数使他的数字 $n$ 变成偶数。

**本题有多组数据。**

## 样例 #1

### 输入

```
4
3876
387
4489
3```

### 输出

```
0
2
1
-1```

# AI分析结果



# 算法分类
**数论**

---

## 题解思路与难点分析

### 核心思路
通过分类讨论数字各数位的奇偶性，确定最少反转次数：
1. **原数为偶数** → 0次操作
2. **所有数位均为奇数** → 无解（-1）
3. **首位为偶数** → 反转整个数（1次操作）
4. **中间或末尾存在偶数** → 两次操作（先将其移动到首位，再整体反转）

### 解决难点
1. **数位顺序处理**：需确保代码正确处理数字的各位顺序（如最高位是字符串首位或数组末位）
2. **分类完备性**：需覆盖所有可能的偶数位置（首位、中间、末尾）
3. **操作次数证明**：证明中间偶数必须两次操作，无法更优

### 数学推导
- 反转操作本质是交换数位：将第k位偶数移动到首位需1次反转（前k位），再反转整个数使其到末位
- 两次操作是中间偶数的唯一最优解

---

## 高星题解推荐（≥4星）

### 1. szkzyc（5星）
- **亮点**：字符串处理避免数组越界，代码简洁易读
- **关键代码**：
  ```cpp
  if(y(str[len - 1]) == 0) puts("0");  // 末尾偶数
  else if(y(str[0]) == 0) puts("1");   // 首位偶数
  else puts("2");                       // 中间偶数
  ```

### 2. Dragonbell_exp（4.5星）
- **亮点**：逻辑清晰，直接处理字符串每一位
- **关键代码**：
  ```cpp
  if((a[0]-'0')%2==0) cout<<"1"<<endl; // 首位偶数
  else cout<<"2"<<endl;                // 中间偶数
  ```

### 3. 智子（4星）
- **亮点**：数组存储数位，正确处理最高位索引
- **关键代码**：
  ```cpp
  if(a[l] % 2 == 0) printf("1\n");    // 最高位为偶数
  ```

---

## 最优思路提炼
1. **分类讨论**：四种情况覆盖所有可能
2. **字符串处理**：避免数组越界问题
3. **两次操作证明**：中间偶数必须两次反转

---

## 类似题型与套路
- **数位操作**：如反转、交换、奇偶判断
- **最少步骤问题**：通过数学推导确定操作次数下限
- **同类型题**：洛谷 P1553（数字反转）、P1601（高精度加法）

---

## 个人心得摘录
> "处理数位顺序时，用字符串比数组更直观，避免索引错误。" —— szkzyc  
> "先检查所有数位是否存在偶数，再分情况讨论，逻辑更清晰。" —— Dragonbell_exp

---

## 可视化设计

### 核心动画演示
1. **数位高亮**：用不同颜色标记偶数位
2. **反转过程**：
   - 步骤1：反转前k位，将偶数移动到首位（红色框）
   - 步骤2：反转整个数，偶数移动到末位（绿色框）
3. **音效提示**：成功时播放8-bit胜利音效

### 复古游戏化实现
- **像素风格**：数字显示为16x16像素块
- **Canvas绘制**：数位反转动画逐帧渲染
- **自动演示**：模拟AI解题步骤，显示操作序列

```javascript
// 示例代码：反转动画
function animateReverse(digits, l) {
    let steps = [];
    // 步骤1：反转前l位
    steps.push({action: 'reverse', range: [0, l-1]});
    // 步骤2：反转整个数字
    steps.push({action: 'reverse', range: [0, digits.length-1]});
    return steps;
}
```

---

## 关键代码实现
```cpp
// szkzyc 题解核心逻辑
string str;
cin >> str;
int len = str.size();
int cnt = 0;
for (char c : str) if ((c - '0') % 2 == 0) cnt++;

if (cnt == 0) cout << -1 << endl;
else if ((str.back() - '0') % 2 == 0) cout << 0 << endl;
else if ((str[0] - '0') % 2 == 0) cout << 1 << endl;
else cout << 2 << endl;
```

---
处理用时：110.56秒
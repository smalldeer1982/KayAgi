# 题目信息

# Minimums and Maximums

## 题目描述

LBW 想要一个数组，满足下面的条件：

- 设数组有 $n$ 个最小值，有 $n \in[l_1, r_1]$。

- 设数组有 $m$ 个最大值，有 $m \in[l_2, r_2]$。

LBW 比较吝啬，所以他希望数组元素个数尽可能少。

请帮助他求出这个最小值。

## 说明/提示

$1 \le T \le 5000$

$1 \le l_1 \le r_1 \le 50$

$1 \le l_2 \le r_2 \le 50$

## 样例 #1

### 输入

```
7
3 5 4 6
5 8 5 5
3 3 10 12
1 5 3 3
1 1 2 2
2 2 1 1
6 6 6 6```

### 输出

```
4
5
13
3
3
3
6```

# AI分析结果



---

**唯一算法分类**  
组合数学

---

**综合分析与结论**  
本题要求构造满足最小值和最大值出现次数区间约束的最短数组。核心思路是判断两个区间是否存在交集：若存在，数组可全为同一元素，长度为两区间左端点的最大值；否则，必须分开为最小值和最大值，长度相加。关键公式为 `ans = max(l1, l2) if max(l1, l2) ≤ min(r1, r2) else l1 + l2`。

**可视化设计思路**  
- **数轴动画**：用两个颜色条表示区间 `[l1, r1]` 和 `[l2, r2]`，高亮重叠部分。  
- **动态计算**：当用户输入参数时，自动计算 `max(l1,l2)` 和 `min(r1,r2)`，并在数轴上标记结果。  
- **复古像素效果**：使用 8-bit 像素风格绘制数轴，每个区间用不同颜色块表示，背景音乐随操作变化。  
- **音效提示**：重叠时播放上扬音效，否则播放低音警示。

---

**题解清单 (≥4星)**  
1. **duchengjun**（5星）  
   - **亮点**：直接判断区间交集的数学条件，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     int a = max(l1, l2), b = min(r1, r2);  
     if (a <= b) cout << a;  
     else cout << l1 + l2;  
     ```  

2. **ttq012**（5星）  
   - **亮点**：逻辑与 `duchengjun` 完全一致，变量命名清晰。  
   - **代码片段**：  
     ```cpp  
     int mi = max(a, c), mx = min(b, d);  
     if (mi <= mx) cout << mi;  
     else cout << a + c;  
     ```  

3. **力巴尔**（4星）  
   - **亮点**：直观判断区间是否完全不相交，代码简洁。  
   - **代码片段**：  
     ```cpp  
     if (a > d || b < c) cout << a + c;  
     else cout << max(a, c);  
     ```  

---

**最优思路或技巧提炼**  
- **区间交集法**：通过 `max(l1, l2) ≤ min(r1, r2)` 判断能否合并元素。  
- **贪心思想**：在可合并时取最大值左端点，否则取两区间左端点之和。

---

**同类型题推荐**  
1. **P1888 三角函数**（极值选择）  
2. **P1102 A-B数对**（区间组合判断）  
3. **P1621 集合**（条件筛选与合并）

---

**个人心得摘录**  
- **关键顿悟**：当所有元素相同时，最小值和最大值重合，此时只需满足一个区间条件。  
- **易错点**：未考虑 `r1` 或 `r2` 可能小于另一区间的左端点（如 `l2=3, r2=2`）。

---

**代码实现与可视化片段**  
```cpp
// 核心代码（duchengjun 题解）
int main() {
    int T; cin >> T;
    while (T--) {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        int a = max(l1, l2), b = min(r1, r2);
        cout << (a <= b ? a : l1 + l2) << '\n';
    }
}
```

**复古动画实现伪代码**  
```javascript
// 伪代码：Canvas绘制数轴与区间块
function drawRanges(l1, r1, l2, r2) {
    drawPixelNumberLine(); // 绘制像素风格数轴
    drawRect(l1, r1, "red"); // 红色块表示[l1, r1]
    drawRect(l2, r2, "blue"); // 蓝色块表示[l2, r2]
    if (max(l1,l2) <= min(r1,r2)) {
        playSound("success.wav");
        highlightOverlap(max(l1,l2), min(r1,r2)); // 高亮重叠区域
    } else {
        playSound("warning.wav");
        flashSeparateRanges(l1, l2); // 闪烁分离的区间
    }
}
```

---
处理用时：202.82秒
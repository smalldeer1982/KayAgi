# 题目信息

# A Gift From Orangutan

## 题目描述

在丛林探险的时候，你遇到了一只罕见的戴着领结的猩猩！你和猩猩握了握手并给了它一些食物和水。作为回报……

猩猩给了你一个长度为 $n$ 的数组 $a$。通过数组 $a$ 你将会以下列的方式构造两个长度都为 $n$ 的数组 $b$ 和 $c$：

* $b_i = \text{min}(a_1,a_2,…,a_i),1 \le i \le n$。  
* $c_i = \text{max}(a_1,a_2,…,a_i),1 \le i \le n$。

定义 $a$ 的得分为 $\sum^n_{i=1} c_i-b_i$。在你计算分数之前，你可以任意修改 $a$ 中元素的顺序。

你需要求出可以获得的最高得分。

## 说明/提示

对于第一组数据，没有其他方法来重新排列 $a$，所以，$b=[69]$ 并且 $c=[69]$。唯一可能的得分为 $69-69=0$。

对于第二组数据，可以将 $a$ 重新排列为 $[7,5,6]$。这样，$b=[7,5,5]$ 并且 $c=[7,7,7]$。这种情况下的得分为 $(7-7)+(7-5)+(7-5)=4$。可以证明，这是可能的最高分数。

翻译来自 [Jason_Ming](https://www.luogu.com.cn/user/1014421)。

## 样例 #1

### 输入

```
3
1
69
3
7 6 5
5
1 1 1 2 2```

### 输出

```
0
4
4```

# AI分析结果



**唯一算法分类**  
组合数学  

---

**综合分析与结论**  

**核心思路**  
题目要求通过重排数组，最大化每个前缀区间的极差之和。关键在于发现最优排列方式：将数组的最大值（M）和最小值（m）尽早包含在前两个位置。此时，从第二个位置开始的所有前缀极差均为 \(M - m\)，总和为 \((n-1) \times (M - m)\)。  

**推导关键**  
1. **极差贡献分析**：每个前缀的极差最大为 \(M - m\)，当且仅当该前缀同时包含 M 和 m。  
2. **贪心策略**：通过将 M 和 m 放在前两位，确保后续所有前缀均包含两者，从而最大化每个位置的极差。  
3. **数学公式**：总得分 = \((n-1) \times (M - m)\)。  

**难点与解决**  
- **难点**：如何快速确定最优排列方式，而非暴力枚举。  
- **解决**：通过极差贡献分析，发现只需关注 M 和 m 的位置，其余元素顺序不影响结果。  

**可视化设计思路**  
1. **动画演示**：  
   - **步骤1**：高亮数组中的 M 和 m，标记其位置。  
   - **步骤2**：将 M 和 m 移动到前两位，显示后续所有前缀的极差均为 \(M - m\)。  
   - **步骤3**：累加总得分，动态显示公式 \((n-1) \times (M - m)\) 的计算过程。  
2. **复古风格**：  
   - 使用 8-bit 像素风格展示数组元素移动过程，音效提示极差计算完成。  
   - 控制面板支持步进，观察每一步的极差变化。  

---

**题解清单 (4.5星)**  

1. **极差最大化策略**  
   - **亮点**：快速识别 M 和 m 的关键作用，公式直接得出结果。  
   - **代码可读性**：简洁高效，仅需遍历数组求极值。  
   - **优化程度**：时间复杂度 \(O(n)\)，空间 \(O(1)\)。  

---

**代码实现**  

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (auto &x : a) cin >> x;
        int min_val = *min_element(a.begin(), a.end());
        int max_val = *max_element(a.begin(), a.end());
        cout << (max_val - min_val) * (n - 1) << endl;
    }
    return 0;
}
```

**核心逻辑**  
- 遍历数组找到最大值和最小值。  
- 直接计算 \((max - min) \times (n-1)\)。  

---

**同类型题套路**  
- **极值主导型问题**：当问题的最优解由极值决定时，优先分析极值的贡献。  
- **贪心策略**：通过局部最优选择构造全局最优解，常见于排序或极值相关题目。  

---

**推荐题目**  
1. P1223 排队接水（贪心排序）  
2. P1090 合并果子（优先队列极值）  
3. P1106 删数问题（贪心删减极值）  

---

**可视化与游戏化**  
- **复古动画**：像素方块表示数组元素，移动 M 和 m 至前两位时播放音效。  
- **自动演示**：展示公式推导过程，每步高亮当前计算的极差。  
- **积分系统**：根据用户是否快速识别极值给予奖励分数。  

--- 

**个人心得**  
- **调试关键**：验证小样例时发现极差总和公式的正确性，避免陷入复杂排列的误区。  
- **顿悟点**：意识到后续元素的顺序不影响极差，仅需确保 M 和 m 被尽早包含。

---
处理用时：107.69秒
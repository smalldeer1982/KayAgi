# 题目信息

# Journey

## 题目描述

Monocarp 决定去进行一次漫长的徒步旅行。

他计划，第一天走 $a$ 公里，第二天走 $b$ 公里，第三天走 $c$ 公里，到第四天再像第一天那样走 $a$ 公里，第五天如同第二天走 $b$ 公里，第六天则重复第三天走 $c$ 公里，如此循环下去。

当他走过的总路程达到至少 $n$ 公里时，就完成了整个旅程。你的任务是找出 Monocarp 在哪一天达到了这个目标。

## 说明/提示

在第一个例子中，Monocarp 在前四天总共走了 $1 + 5 + 3 + 1 = 10$ 公里。到了第五天，他又走了 $5$ 公里，总数达到 $15$ 公里。因为 $n = 12$，所以 Monocarp 在第五天实现了目标，完成了旅程。

在第二个例子中，Monocarp 第一天就走了 $6$ 公里。而由于 $n = 6$，他实际上一天就完成了旅程。

在第三个例子中，Monocarp 在六天内的总行程为 $3 + 4 + 1 + 3 + 4 + 1 = 16$ 公里。因为 $n = 16$，所以他在第六天达成旅程目标。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
12 1 5 3
6 6 7 4
16 3 4 1
1000000000 1 1 1```

### 输出

```
5
1
6
1000000000```

# AI分析结果



### 算法分类
**无算法分类**

### 题解思路与核心难点
题目核心在于将总路程分解为完整的3天周期和剩余部分处理：
1. **完整周期计算**：每个周期总路程为 `a + b + c`，计算完整周期数 `num = n // (a + b + c)`，对应天数为 `num * 3`。
2. **余数处理**：剩余路程 `r = n % (a + b + c)`：
   - 若 `r = 0`，直接返回 `num * 3`。
   - 否则，按顺序判断余数是否在 `a` 或 `a + b` 的范围内，决定需追加的天数。

**关键公式**：
- 总天数 = `num * 3 + 追加天数`。
- 追加天数规则：`r <= a → +1`，`a < r <= a + b → +2`，否则 `+3`。

### 评分≥4星的题解
1. **JimmyQ（5星）**
   - **亮点**：代码简洁，直接处理余数，条件判断清晰。
   - **代码片段**：
     ```cpp
     long long num = n / (a + b + c);
     n -= num * (a + b + c);
     if (n == 0) cout << num * 3 << endl;
     else if (a >= n) cout << num * 3 + 1 << endl;
     else if (a + b >= n) cout << num * 3 + 2 << endl;
     else cout << num * 3 + 3 << endl;
     ```

2. **alan1118（4星）**
   - **亮点**：利用条件判断递增天数，代码简短。
   - **代码片段**：
     ```cpp
     if (q > 0) d++;
     if (q > a) d++;
     if (q > a + b) d++;
     ```

3. **liuzhengtao（4星）**
   - **亮点**：逻辑明确，条件分支覆盖所有情况。
   - **代码片段**：
     ```cpp
     if (yu == 0) cout << zq << endl;
     else if (yu <= a) cout << zq + 1 << endl;
     else if (yu <= a + b) cout << zq + 2 << endl;
     else cout << zq + 3 << endl;
     ```

### 最优思路提炼
- **核心技巧**：利用模运算分解周期，余数部分按顺序判断。
- **优化点**：避免逐天模拟，直接数学计算，时间复杂度 `O(1)`。

### 同类题目推荐
1. **P2669 金币**：周期性计算每日金币。
2. **P1424 小鱼的航程**：计算周期内的工作日。
3. **P4956 Davor**：周期性计划的数学建模。

### 可视化设计
- **动画演示**：将总路程拆分为多个3天周期，余数部分逐步累加 `a → b → c`，高亮当前比较的值。
- **像素风格**：每个周期用不同颜色块表示，音效提示条件达成。
- **交互功能**：步进控制观察余数处理，自动推导模式展示计算流程。

### 代码实现（核心逻辑）
```cpp
#include <iostream>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        long long n, a, b, c;
        cin >> n >> a >> b >> c;
        long long sum = a + b + c;
        long long num = n / sum;
        long long rem = n % sum;
        long long days = num * 3;
        if (rem != 0) {
            if (rem <= a) days += 1;
            else if (rem <= a + b) days += 2;
            else days += 3;
        }
        cout << days << endl;
    }
    return 0;
}
```

---
处理用时：231.89秒
# 题目信息

# Perfecto

## 题目描述

若一个长度为 $n$ 的排列 $p$ $^{\text{∗}}$ 满足：对于每个下标 $i$（$1 \le i \le n$），前 $i$ 个元素的和 $p_1 + p_2 + \ldots + p_i$ 不是完全平方数 $^{\text{†}}$，则称该排列为完美排列。

你需要构造完美排列。给定正整数 $n$，找出一个长度为 $n$ 的完美排列，若不存在则输出 $-1$。

$^{\text{∗}}$ 长度为 $n$ 的排列是指由 $1$ 到 $n$ 的 $n$ 个不同整数按任意顺序组成的数组。例如，$[2,3,1,5,4]$ 是排列，但 $[1,2,2]$ 不是排列（数字 $2$ 重复出现），$[1,3,4]$ 也不是排列（当 $n=3$ 时出现数字 $4$）。

$^{\text{†}}$ 完全平方数是指某个整数的平方，例如 $9=3^2$ 是完全平方数，但 $8$ 和 $14$ 不是。

## 说明/提示

第一个测试用例中，当 $n = 1$ 时唯一可能的排列是 $p = [1]$，但它不满足完美条件：
- $p_1 = 1 = x^2$（当 $x = 1$ 时成立）。

第二个测试用例中，当 $n = 4$ 时一个可能的完美排列是 $p = [2, 4, 1, 3]$：
- $p_1 = 2 \neq x^2$；
- $p_1 + p_2 = 2 + 4 = 6 \neq x^2$；
- $p_1 + p_2 + p_3 = 2 + 4 + 1 = 7 \neq x^2$；
- $p_1 + p_2 + p_3 + p_4 = 2 + 4 + 1 + 3 = 10 \neq x^2$。

第三个测试用例中，当 $n = 5$ 时一个可能的完美排列是 $p = [5, 1, 4, 3, 2]$：
- $p_1 = 5 \neq x^2$；
- $p_1 + p_2 = 5 + 1 = 6 \neq x^2$；
- $p_1 + p_2 + p_3 = 5 + 1 + 4 = 10 \neq x^2$；
- $p_1 + p_2 + p_3 + p_4 = 5 + 1 + 4 + 3 = 13 \neq x^2$；
- $p_1 + p_2 + p_3 + p_4 + p_5 = 5 + 1 + 4 + 3 + 2 = 15 \neq x^2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
1
4
5```

### 输出

```
-1
2 4 1 3
5 1 4 3 2```

# AI分析结果



# 唯一算法分类  
**构造（Constructive Algorithms）**

---

## 题解思路、算法要点与解决难点  
### 核心思路  
1. **无解判定**：当总和 $\frac{n(n+1)}{2}$ 是平方数时，无法构造完美排列，输出 `-1`。  
2. **构造策略**：初始排列为 $[1, 2, \dots, n]$，遍历每个位置 $i$。若当前前缀和是平方数，交换 $a_i$ 与 $a_{i+1}$，保证新前缀和不再为平方数。  

### 解决难点  
- **数学证明**：交换后的前缀和 $k^2 + 1$ 不可能是平方数（因相邻平方数差至少为 $2k+1$，而 $k^2 + 1$ 与 $(k+1)^2$ 的差为 $2k$）。  
- **高效构造**：时间复杂度 $O(n)$，满足 $n \leq 10^6$ 的限制。  

---

## 题解评分（≥4星）  
1. **sLMxf（4星）**  
   - 思路清晰，代码直接体现构造策略。  
   - 通过重新计算前缀和确保正确性。  

2. **Pyrf_uqcat（4星）**  
   - 代码简洁，逻辑明确。  
   - 直接检查并交换，避免冗余计算。  

3. **chatoudp（4星）**  
   - 短小精悍，正确性证明充分。  
   - 关键步骤注释清晰，便于理解。  

---

## 最优思路或技巧提炼  
1. **贪心构造**：从自然排列出发，仅在必要时交换相邻元素。  
2. **数学优化**：利用平方数差值特性，确保交换后的前缀和必不为平方数。  
3. **高效检查**：直接判断整数平方根是否等于原数，避免浮点误差。  

---

## 同类型题或类似算法套路  
- **构造特定性质的排列**：如前缀和、异或和满足条件。  
- **相邻交换策略**：通过局部调整满足全局约束（如逆序对调整）。  

---

## 推荐相似题目  
1. **CF1772B - Matrix Rotation**（构造满足条件的矩阵）  
2. **洛谷 P1219 [USACO1.5] 八皇后**（构造满足条件的排列）  
3. **CF1328C - Ternary XOR**（构造特定性质的字符串）  

---

## 可视化与算法演示  
### 动画方案  
1. **初始排列**：显示 $1$ 到 $n$ 的初始序列，颜色为默认。  
2. **遍历检查**：逐个高亮当前元素，计算前缀和。  
3. **交换操作**：若前缀和为平方数，交换当前与下一元素，标记为红色闪烁。  
4. **更新状态**：显示交换后的前缀和，颜色恢复。  

### 复古像素风格设计  
- **颜色方案**：  
  - 默认元素：绿色（#00FF00）。  
  - 当前检查元素：黄色（#FFFF00）。  
  - 交换元素：红色（#FF0000）。  
- **Canvas 动画**：  
  - 网格布局，每个元素显示数值与颜色。  
  - 前缀和以浮动数字显示在元素上方。  
- **音效**：  
  - 交换时播放“哔”声（8-bit 音效）。  
  - 完成构造后播放胜利音效。  

### 交互设计  
- **步进控制**：支持暂停、单步执行。  
- **自动演示**：可调节速度（1x, 2x, 0.5x）。  

---

## 代码实现（核心逻辑）  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool isSquare(long long x) {
    long long s = sqrt(x);
    return s * s == x;
}

int main() {
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        long long total = 1LL * n * (n + 1) / 2;
        if (isSquare(total)) {
            cout << "-1\n";
            continue;
        }
        vector<int> a(n);
        iota(a.begin(), a.end(), 1);
        long long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += a[i];
            if (isSquare(sum)) {
                if (i + 1 < n) swap(a[i], a[i + 1]);
                sum = (i > 0 ? sum - a[i] + a[i - 1] : a[i]); // 修正sum
            }
        }
        for (int x : a) cout << x << ' ';
        cout << '\n';
    }
}
```

---

## 个人心得摘录  
- **调试关键**：需注意交换后前缀和的修正，避免遗漏累加。  
- **思维突破**：将自然排列作为初始解，仅需局部调整，避免复杂全局构造。

---
处理用时：83.75秒
# 题目信息

# Vicious Labyrinth

## 题目描述

[Axium Crisis - ak+q](https://youtu.be/1HyuI8Bvnsg?si=6amlU5OPKnJiydZs)

迷宫中有 $n$ 个单元格，其中单元格 $i$（$1 \leq i \leq n$）距离出口有 $n - i$ 公里。特别地，单元格 $n$ 就是出口。注意每个单元格仅与出口相连，无法从其他任何单元格直接到达。

每个单元格最初恰好困住一个人。你希望通过在每个单元格 $i$（$1 \leq i \leq n$）安装传送器来帮助所有人尽可能接近出口，该传送器会将单元格 $i$ 中的人传送到另一个单元格 $a_i$。

迷宫主人发现了你的行为。她觉得有趣，但要求你满足以下条件：
- 每个人都必须恰好使用传送器 $k$ 次。
- 任何单元格的传送器都不能将人传送到自身所在的单元格。形式化地说，对所有 $1 \leq i \leq n$ 有 $a_i \neq i$。

你需要找到一个传送器配置方案，在满足迷宫主人限制条件的前提下，使所有人在使用传送器恰好 $k$ 次后到出口的距离之和最小。若存在多个可行方案，输出任意一个即可。

## 说明/提示

第一个测试用例中，每个人的位置变化如下：
- 传送前：$[1, 2]$
- 第一次传送后：$[2, 1]$

距离之和为 $(2-2) + (2-1) = 1$，这是可能的最小值。

第二个测试用例中，每个人的位置变化如下：
- 传送前：$[1, 2, 3]$
- 第一次传送后：$[2, 3, 2]$
- 第二次传送后：$[3, 2, 3]$

距离之和为 $(3-3) + (3-2) + (3-3) = 1$，这是可能的最小值。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
2 1
3 2```

### 输出

```
2 1
2 3 2```

# AI分析结果



## 算法分类
构造/数学

## 题解思路与解决难点
### 核心思路
所有题解均基于**k的奇偶性**构造传送路径，使尽可能多的人最终停留在出口n。通过让n与n-1形成互传环，其他人通过奇偶次传送进入该环的端点，保证总距离最小为1。

### 关键步骤与变量
- **奇数k**：前n-1个传送器指向n，n的传送器指向n-1。奇数次传送后，非出口人员停留在n，出口人员留在n-1。
- **偶数k**：前n-2个传送器指向n-1，n-1与n互传。偶数次传送后，非出口人员到达n，互传环中两人位置不变。

### 难点分析
1. **循环周期**：需确保传送次数k结束后，所有人员位置稳定在最优状态。
2. **奇偶处理**：通过奇偶性决定传送路径，将多次传送简化为环的交替移动。
3. **自洽验证**：证明构造方案在任意合法k下总能保证总距离为1。

## 题解评分（≥4星）
1. **gesong（5星）**
   - 思路清晰，代码简洁，直接处理奇偶性。
   - 示例验证充分，代码逻辑易懂。
2. **Starry_Sky_135（4星）**
   - 分奇偶详细说明传送过程，代码实现正确。
   - 缺少对复杂情况的数学证明，但示例推导完整。
3. **chenxi2009（4星）**
   - 分析环结构对结果的影响，代码与思路一致。
   - 提供了图论角度的解释，增强理解深度。

## 最优思路提炼
- **奇偶构造**：根据k的奇偶性选择将多数点指向n或n-1。
- **互传环**：n与n-1形成互传，保证剩余次数中位置交替，最终总距离为1。
- **贪心策略**：最大化到达出口的人数，仅留1人在次优位置。

## 相似题目推荐
1. [CF1333C. Eugene and an array](https://codeforces.com/problemset/problem/1333/C)（前缀和与子数组构造）
2. [洛谷P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)（路径构造与计数）
3. [CF1352G. Special Permutation](https://codeforces.com/problemset/problem/1352/G)（奇偶性构造排列）

## 可视化设计
### 动画方案
- **网格表示**：用方格表示单元格，红色标记出口n，蓝色标记n-1。
- **传送路径**：箭头动态显示传送方向，高亮奇偶选择的关键路径。
- **步进演示**：单步执行k次传送，显示每次传送后的位置变化。
- **环闪烁**：n与n-1的互传环在动画中周期性闪烁，强调循环逻辑。

### 复古游戏化
- **像素风格**：8-bit格子迷宫，传送器用闪烁箭头表示。
- **音效**：传送时播放短促音效，达成最优解时播放胜利旋律。
- **自动演示**：按奇偶预设两种模式，自动展示传送路径与结果。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int n, k;
    cin >> n >> k;
    if (k % 2) { // 奇数情况
        for (int i = 1; i < n; ++i) cout << n << " ";
        cout << n-1 << endl;
    } else {     // 偶数情况
        for (int i = 1; i <= n-2; ++i) cout << n-1 << " ";
        cout << n << " " << n-1 << endl;
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

## 代码解释
- **奇数处理**：前n-1项填n，末项填n-1。
- **偶数处理**：前n-2项填n-1，后两项填n和n-1形成互传。
- **复杂度**：O(Tn)，线性时间构造，无额外空间。

---
处理用时：176.60秒
# 题目信息

# MIN = GCD

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$。判断是否可以重新排列 $a$，使得存在一个整数 $i$（$1 \le i < n$）满足：
$$
\min([a_1, a_2, \ldots, a_i]) = \gcd([a_{i+1}, a_{i+2}, \ldots, a_n]).
$$
其中，$\gcd(c)$ 表示 $c$ 的[最大公约数](https://en.wikipedia.org/wiki/Greatest_common_divisor)，即能整除 $c$ 中所有整数的最大正整数。

## 说明/提示

- 在第一个测试用例中，将 $a$ 重新排列为 $[1, 1]$ 并令 $i=1$，则 $\min([1]) = \gcd([1])$。  
- 在第二个测试用例中，可以证明不可能满足条件。  
- 在第三个测试用例中，将 $a$ 重新排列为 $[3, 2, 2]$ 并令 $i=2$，则 $\min([3, 2]) = \gcd([2])$。  
- 在第五个测试用例中，将 $a$ 重新排列为 $[3, 4, 5, 6, 9]$ 并令 $i=3$，则 $\min([3, 4, 5]) = \gcd([6, 9])$。  

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
7
2
1 1
2
1 2
3
2 2 3
3
2 3 4
5
4 5 6 9 3
3
998244359987710471 99824435698771045 1000000007
6
1 1 4 5 1 4```

### 输出

```
Yes
No
Yes
No
Yes
Yes
Yes```

# AI分析结果



---

**唯一算法分类**：数学、贪心

---

### **题解思路与算法要点**

1. **核心思路**  
   - **全局最小值必为分割点**：题目要求分割后的前半部分最小值等于后半部分GCD。全局最小值必须出现在前半部分，否则前半部分的最小值无法更小。
   - **后半部分必须全为最小值的倍数**：若后半部分存在非倍数元素，其GCD必然无法等于最小值。
   - **后半部分的GCD计算**：通过遍历所有倍数元素，计算其GCD是否等于最小值。

2. **解决难点**  
   - **确定后半部分的构成**：通过排序后筛选出所有最小值的倍数，计算它们的GCD。
   - **避免无效计算**：优化方法是将倍数元素除以最小值后，判断新元素的GCD是否为1，从而避免大数运算。

---

### **题解评分（≥4星）**

1. **hongshixiaobai（5星）**  
   - **亮点**：思路简洁，直接计算后半部分的GCD，代码高效易懂。  
   - **关键代码**：  
     ```cpp
     for(i = 2; i <= n; i++)
         if(a[i] % a[1] == 0)
             g = __gcd(g, a[i]);
     if(g <= a[1] && g != 0) cout << "YES\n";
     ```

2. **Eason_cyx（4星）**  
   - **亮点**：优化计算，将倍数元素除以最小值后判断GCD是否为1，提升大数处理效率。  
   - **关键代码**：  
     ```cpp
     for(int i = 2; i <= n; i++)
         if(a[i] % a[1] == 0)
             b[++cur] = a[i] / a[1];
     if(cur == 1) cout << "No\n";
     else if(gcd(b) == 1) cout << "Yes\n";
     ```

3. **cqbzhzf（4星）**  
   - **亮点**：独立定位最小值位置，避免全排序，适用非稳定排序场景。  
   - **关键代码**：  
     ```cpp
     for(int i = 1; i <= n; i++)
         if(a[i] < a[x]) x = i;
     for(int i = 1; i <= n; i++)
         if(i != x && a[i] % a[x] == 0)
             y = __gcd(y, a[i]);
     ```

---

### **最优思路与技巧**

- **排序+倍数筛选**：排序后快速定位最小值，筛选倍数元素简化计算。
- **数学优化**：将倍数元素除以最小值，转为判断GCD是否为1。
- **动态维护GCD**：遍历时实时更新GCD，减少冗余计算。

---

### **同类题目推荐**

1. **P2445 [SDOI2010] 外星千足虫**（构造满足GCD条件的数组）
2. **P1029 最大公约数和最小公倍数问题**（数论与因子分解）
3. **P5431 【模板】乘法逆元 2**（GCD与模运算的综合应用）

---

### **可视化与算法演示**

1. **动画设计**  
   - **像素风格**：数组元素用色块表示，最小值标红，倍数元素标绿。
   - **步进演示**：逐元素检查是否满足倍数条件，实时更新GCD计算结果。
   - **音效提示**：成功时播放上升音调，失败时短促“哔”声。

2. **核心逻辑演示**  
   - **初始排序**：数组升序排列，最小值在最左。
   - **筛选倍数**：绿色高亮所有最小值的倍数元素。
   - **计算GCD**：动态展示倍数元素的GCD计算过程。

---

### **代码实现（核心片段）**

```cpp
// hongshixiaobai 的代码（完整版）
#include<bits/stdc++.h>
using namespace std;
long long t, n, a[200005], i, g;
int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    cin >> t;
    while (t--) {
        cin >> n;
        for (i = 1; i <= n; i++) cin >> a[i];
        sort(a + 1, a + n + 1);
        g = 0;
        for (i = 2; i <= n; i++)
            if (a[i] % a[1] == 0)
                g = __gcd(g, a[i]);
        cout << (g == a[1] ? "YES\n" : "NO\n");
    }
}
```

---

**总结**：通过排序和数学优化，快速定位最小值并验证后半部分的GCD条件，是解决此类数论贪心问题的通用范式。

---
处理用时：184.17秒
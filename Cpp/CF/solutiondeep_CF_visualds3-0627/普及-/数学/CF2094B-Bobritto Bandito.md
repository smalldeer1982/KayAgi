# 题目信息

# Bobritto Bandito

## 题目描述

在 Bobritto Bandito 居住的家乡，有一条无限延伸的数轴，上面分布着无数栋房屋，分别位于 $ \ldots, -2, -1, 0, 1, 2, \ldots $ 的位置。在第 $0$ 天时，他通过让 $0$ 号房屋的居民感染病毒，引发了一场瘟疫。在接下来的每一天，瘟疫都会恰好蔓延到一个与已感染房屋相邻的健康房屋。可以证明，每一天被感染的房屋都会形成一个连续的区间。

我们用 $[l, r]$ 表示从第 $l$ 栋房屋到第 $r$ 栋房屋的区间。已知在第 $n$ 天时，区间 $[l, r]$ 被完全感染。请找出在第 $m$ 天（$m \le n$）时可能被感染的任意一个区间 $[l', r']$。

## 说明/提示

在第一个测试用例中，可能的情况是：
- 第 $1$ 天时感染区间为 $[-1,0]$
- 第 $2$ 天时为 $[-1,1]$
- 第 $3$ 天时为 $[-2,1]$

因此，$[-1,1]$ 是一个有效的输出。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
4 2 -2 2
4 1 0 4
3 3 -1 2
9 8 -6 3```

### 输出

```
-1 1
0 1
-1 2
-5 3```

# AI分析结果



**唯一算法分类**  
模拟/贪心

---

### **综合分析与结论**

题目要求在第m天可能的感染区间，满足长度m+1、包含0，且可通过扩展得到第n天的区间[l, r]。关键在于构造满足条件的区间，并确保其扩展路径正确。

**核心难点**：
- 确定区间扩展的方向（左或右），使得回溯后的区间包含0。
- 构造合法的解，满足长度和包含0的条件。

**解决方案**：
1. **回溯法**：从第n天的区间[l, r]反向推导，每次去掉一个端点，优先处理右端点（若r>0），否则处理左端点。确保中间区间包含0。
2. **直接构造法**：根据数学推导，确定左端点范围，选择满足条件的左端点构造区间。

**可视化设计思路**：
- 使用动画展示区间的扩展与回溯过程，每一步高亮当前处理的端点。
- 颜色标记当前区间，箭头表示扩展方向，动态显示区间变化。
- 控制面板支持单步执行，观察回溯路径。

---

### **题解清单 (≥4星)**  
1. **linch的题解（4星）**  
   - **思路**：从第n天反向回溯n-m次，优先减少右端点（若r>0），否则增加左端点。确保每一步区间包含0。
   - **亮点**：简洁有效，代码可读性强，正确覆盖所有条件。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= x; i++) {
         if (r > 0) r--;
         else l++;
     }
     ```

2. **FXLIR的题解（4星）**  
   - **思路**：计算左端点范围，优先向左扩展，处理剩余天数后调整右端点。
   - **亮点**：数学推导严谨，覆盖所有边界条件。
   - **代码片段**：
     ```cpp
     li = min(0ll, l + m);
     m = max(0ll, m - abs(l));
     ri = r - m;
     ```

3. **huanglihuan的题解（4星）**  
   - **思路**：左端点取max(l, -m)，右端点为左端点+m。确保区间包含0。
   - **亮点**：直接构造，时间复杂度O(1)。
   - **代码片段**：
     ```cpp
     cout << max(l, -m) << ' ' << max(l, -m) + m << endl;
     ```

---

### **最优思路或技巧提炼**  
- **回溯法**：通过反向操作模拟扩展过程，优先处理右端点，确保每一步包含0。
- **数学构造**：确定左端点范围，直接生成合法区间，无需复杂判断。

---

### **同类型题或类似算法套路**  
- 区间扩展问题（如病毒传播、植物生长等）。
- 逆向思维处理问题（回溯法）。

---

### **推荐相似题目**  
1. **洛谷 P1010 幂次方**  
2. **洛谷 P1045 麦森数**  
3. **洛谷 P1226 快速幂**

---

### **个人心得摘录**  
- 回溯时优先处理右端点可简化逻辑，但需注意最终区间是否合法。
- 数学推导可快速确定解的范围，避免冗长模拟。

---

### **可视化与算法演示**  
**动画方案**：
1. **Canvas绘制数轴**，标记初始区间[-2, 2]（红色）。
2. **回溯步骤**：
   - 第1步：右端点2→1，区间变为[-2,1]（蓝色）。
   - 第2步：右端点1→0，区间变为[-2,0]（绿色）。
3. **颜色高亮**：当前操作端点（右端点）用黄色标记。
4. **控制面板**：支持步进、重置，速度调节。

**复古像素风格**：
- 使用8位像素风，区间用不同颜色块表示。
- 音效：每次回溯播放“滴答”声，完成时播放胜利音效。

---

### **代码实现（核心逻辑）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int T; cin >> T;
    while(T--) {
        int n, m, l, r;
        cin >> n >> m >> l >> r;
        int steps = n - m;
        // 回溯步骤
        for (int i = 0; i < steps; i++) {
            if (r > 0) r--;
            else l++;
        }
        cout << l << " " << r << "\n";
    }
    return 0;
}
```

---
处理用时：342.23秒
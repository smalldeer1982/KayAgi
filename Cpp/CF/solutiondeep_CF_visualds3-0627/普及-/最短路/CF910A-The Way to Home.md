# 题目信息

# The Way to Home

## 题目描述

一只青蛙现在在一个数轴上，它现在要从点 $1$ 跳到点 $n$ ，它每次可以向右跳不超过 $d$ 个单位。比如，它可以从点 $x$ 跳到点 $x+a$  $( 1<=a<=d )$ 。特别的，青蛙只能在有百合花的点上停留。保证点 $1$ 和点 $n$ 之间有一些点有百合花。请输出青蛙到达点 $n$ 的最小跳跃次数。

## 说明/提示

在样例1中，青蛙可以从点 $1$ 跳3个单位到点 $4$ ，再从点 $4$ 跳4个单位到点 $8$ .
在样例2中，青蛙不能到达点 $n$ ，因为它至少需要跳3个单位，但它最多只能跳2个单位。

由 @星烁晶熠辉 提供翻译

## 样例 #1

### 输入

```
8 4
10010101
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 2
1001
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
8 4
11100101
```

### 输出

```
3
```

## 样例 #4

### 输入

```
12 3
101111100101
```

### 输出

```
4
```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路、算法要点与解决难点**
1. **核心思路**：  
   每次跳跃时尽可能选择能到达的最远有效点，从而最小化跳跃次数。关键在于证明此贪心策略的正确性：更早到达更远的位置能减少后续所需步数。

2. **算法实现**：  
   - **关键变量**：当前所在位置 `now`，跳跃次数 `ans`。  
   - **核心步骤**：  
     1. 从当前位置 `now` 向后遍历 `d` 个点，找到最远且可停留的点。  
     2. 若找到，更新 `now` 并增加跳跃次数；否则返回 `-1`。  
   - **解决难点**：通过逆序检查（从最远点开始）快速找到最优跳跃点，保证时间复杂度为 *O(n)*。

3. **对比题解**：  
   - **DFS/剪枝**：可能超时，但剪枝后优化明显。  
   - **DP**：*O(n*d)* 的复杂度，不如贪心高效。  
   - **最短路**：正确但复杂，适合小数据。  

---

### **题解评分 (≥4星)**
1. **Lips 的贪心解法**（5星）  
   - 亮点：代码简洁，逆向遍历实现贪心，时间复杂度 *O(n)*。  
   - 关键代码：  
     ```cpp
     for (int i = now + d; i >= now + 1; i--)  
         if (s[i] == '1') { ... }
     ```

2. **wky32768 的贪心解法**（4星）  
   - 亮点：直接循环模拟跳跃过程，逻辑清晰。  
   - 代码片段：  
     ```cpp
     while (l != n) {  
         for (int i = l + m; i > l; i--) { ... }  
     }
     ```

3. **学而思李老师的剪枝DFS**（4星）  
   - 亮点：逆向遍历剪枝，优化DFS效率。  
   - 心得：“根据贪心原则，每次跳最大步数剪枝”。

---

### **最优思路或技巧提炼**
- **贪心策略**：从当前点出发，优先选择最远可达的有效点。  
- **逆向遍历**：从 `now + d` 倒序检查，找到第一个有效点即停止，减少无效遍历。  
- **边界处理**：若 `now + d >= n` 直接跳到终点。

---

### **同类型题或类似算法套路**
- **类似题目**：  
  1. 跳跃游戏（LeetCode 55）  
  2. 跳跃游戏 II（LeetCode 45）  
  3. 过河问题（洛谷 P1052）  
- **通用解法**：贪心或动态规划，根据数据规模选择。

---

### **推荐洛谷题目**
1. **P1052**：过河（动态规划 + 离散化）  
2. **P1091**：合唱队形（线性DP）  
3. **P5019**：铺设道路（贪心）

---

### **个人心得摘录**
- **学而思李老师**：“剪枝是搜索中优化的一大法宝。”  
- **Lips**：“贪心可比这些玩意简单多了！”  
- **wky32768**：“不是我说，那个最短路的题解真是让人难以置信。。”

---

### **可视化与算法演示**
1. **动画设计**：  
   - **像素风格**：青蛙用绿色像素块表示，跳跃时播放“跳跃音效”。  
   - **关键步骤高亮**：当前检查的点标红，跳跃后标黄。  
   - **交互控制**：支持暂停/继续/步进，速度可调。  

2. **算法流程演示**：  
   ```plaintext
   初始状态：now = 1, ans = 0  
   循环：  
     1. 检查 now+3（样例1中d=4）：无效 → 检查 now+2 → 有效 → 跳跃  
     2. 更新 now=4, ans=1  
     3. 检查 now+4=8 ≥ n → 结束，ans=2  
   ```

3. **音效设计**：  
   - 跳跃成功：8-bit 上升音效。  
   - 无解：短促“失败”音效。  

---

### **代码实现（贪心解法）**
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n, d, now = 0, ans = 0;
    string s;
    cin >> n >> d >> s;
    while (now < n - 1) {
        bool found = false;
        for (int i = min(now + d, n - 1); i > now; i--) {
            if (s[i] == '1') {
                now = i;
                ans++;
                found = true;
                break;
            }
        }
        if (!found) {
            cout << -1;
            return 0;
        }
    }
    cout << ans;
    return 0;
}
```

---

**总结**：贪心算法以 *O(n)* 的复杂度高效解决本题，逆向遍历和边界处理是关键。可视化设计可结合复古像素风格增强理解。

---
处理用时：83.38秒
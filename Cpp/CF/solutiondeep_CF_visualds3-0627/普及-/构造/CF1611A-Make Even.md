# 题目信息

# Make Even

## 题目描述

Polycarp 有一个不包含数字 $0$ 的整数 $n$。他可以使用他的数字执行以下操作数次（可能为零）：

将 $n$ 的长度 $l\ (1 \leq l \leq |n|$，这里 $|n|$ 指 $n$ 的十进制长度 $)$ 的前缀反转，即反转 $n$ 的 前 $l$ 位数字。那么，第 $1$ 个数位（默认从左向右数，下文同理）将与第 $l$ 个数位交换，第 $2$ 个数位与第 $(l-1)$ 个交换......以此类推。

例如，如果 $n=123456789$ 且 $l=5$，则 $n$ 变换后的值将为 $543216789$。

对于不同的操作，$l$ 的值可能不同。

Polycarp 喜欢偶数，并且非常不耐烦。因此，他想用最少的操作次数使他的数字 $n$ 变成偶数。

**本题有多组数据。**

## 样例 #1

### 输入

```
4
3876
387
4489
3```

### 输出

```
0
2
1
-1```

# AI分析结果



**唯一算法分类**：无算法分类

---

### 题解思路与核心难点

#### 核心思路
题目要求通过最少次数的前缀反转操作使数字变为偶数。关键在于判断最后一位是否为偶数，若否，则通过反转将某偶数位移到末位。分以下情况处理：
1. **原数为偶数**：无需操作（0次）。
2. **原数为奇数**：
   - **无偶数位**：无解（-1）。
   - **最高位是偶数**：反转整个数（1次）。
   - **存在中间偶数位**：两次反转（先将其移到首位，再反转整个数）。

#### 解决难点
- **正确识别最高位是否为偶数**：需避免数组越界或分解顺序错误。
- **操作次数的逻辑推导**：需严格证明两次操作可覆盖所有中间偶数位情况。

---

### 题解评分（≥4星）

1. **szkzyc 的题解（★★★★☆）**
   - **亮点**：字符串处理，逻辑清晰，代码简洁。
   - **代码片段**：
     ```cpp
     if (str[0]是偶数) puts("1");
     else puts("2");
     ```

2. **Dragonbell_exp 的题解（★★★★☆）**
   - **亮点**：直接判断最高位和中间是否存在偶数位。
   - **代码片段**：
     ```cpp
     if (最高位是偶数) cout << 1;
     else cout << 2;
     ```

3. **Anonymous_U 的题解（★★★★☆）**
   - **亮点**：字符串遍历，高效判断中间偶数位。
   - **代码片段**：
     ```cpp
     for (中间位存在偶数) printf("2");
     ```

---

### 最优思路提炼
1. **判断末位是否为偶数**：直接得出是否需要操作。
2. **最高位偶数则一次反转**：将其变为末位。
3. **中间偶数位需两次操作**：首次将其移至首位，再整体反转。

---

### 类似题目推荐
1. **CF977D - 数字重排**：需通过特定操作重新排列数字。
2. **洛谷P1012 拼数**：通过字符串拼接比较构造最大数。
3. **AT1219 反转游戏**：通过反转操作使序列满足条件。

---

### 可视化算法演示
**动画设计**：
1. **像素风格界面**：使用 8 位像素字体显示数字，每次反转时高亮操作区间。
2. **步进控制**：
   - **操作1**：反转最高位（绿色闪烁），若符合条件则播放成功音效。
   - **操作2**：找到中间偶数位（黄色标记），分两次反转（箭头动画）。
3. **自动演示模式**：自动按最优路径操作，配复古音效。

**关键帧示例**：
- **原数 387**：标记中间偶数位 `8` → 第一次反转前两位 → 第二次反转整个数。

---

### 代码片段（关键逻辑）
```cpp
// szkzyc 的代码（字符串处理）
string str;
if (str.back()是偶数) cout << 0;
else if (str[0]是偶数) cout << 1;
else {
    for (遍历中间位存在偶数) cout << 2;
}
```

---

### 个人心得
- **数组越界教训**：分解数字时需注意存储顺序，避免访问无效位置。
- **字符串更安全**：直接处理字符串可避免分解错误，简化逻辑。

---
处理用时：244.68秒
# 题目信息

# Pushing Balls

## 题目描述

Ecrade 有一个 $$$n \times m$$$ 的网格，初始为空。他通过多次（可能为零次）推球操作在其中放置了若干球。

每次操作时，他可以选择从某行的最左边缘或某列的最上边缘向网格内推入一个球。

当一个球朝某个方向移动时：
- 若目标位置原本没有球，则新推入的球会占据该位置并停止。
- 若目标位置已有球，则新推入的球会占据该位置，而原位置的球将继续沿相同方向移动到下一个位置。

注意：若某行或某列已满（即该行或列所有位置都有球），则不能从该行或列推入新球。

给定网格每个位置是否有球的最终状态，请判断是否存在一种推球操作序列使得最终状态可以被达成。

## 说明/提示

为简化描述：
- 若从第 $$$i$$$ 行的最左边缘推入球，称该操作为 $$$\text{ROW}\\ i$$$
- 若从第 $$$i$$$ 列的最上边缘推入球，称该操作为 $$$\text{COL}\\ i$$$

以下示例矩阵中的非零数字 $$$x$$$ 表示第 $$$x$$$ 次推入的球。

第一个测试用例的一个可能操作序列：
$$$\begin{pmatrix}0&0&0\\\\0&0&0\\\\0&0&0\end{pmatrix}\xrightarrow{\text{ROW}\\ 3}\xrightarrow{\text{ROW}\\ 3} \begin{pmatrix}0&0&0\\\\0&0&0\\\\2&1&0\end{pmatrix}\xrightarrow{\text{COL}\\ 3}\xrightarrow{\text{COL}\\ 3} \begin{pmatrix}0&0&4\\\\0&0&3\\\\2&1&0\end{pmatrix}$$$

第二个测试用例的一个可能操作序列：
$$$\begin{pmatrix}0&0&0\\\\0&0&0\\\\0&0&0\end{pmatrix}\xrightarrow{\text{ROW}\\ 2}\xrightarrow{\text{ROW}\\ 2}\xrightarrow{\text{ROW}\\ 2} \begin{pmatrix}0&0&0\\\\3&2&1\\\\0&0&0\end{pmatrix}\xrightarrow{\text{COL}\\ 2}\xrightarrow{\text{COL}\\ 2} \begin{pmatrix}0&5&0\\\\3&4&1\\\\0&2&0\end{pmatrix}$$$

第三个测试用例的一个可能操作序列：
$$$\begin{pmatrix}0&0&0\\\\0&0&0\\\\0&0&0\end{pmatrix}\xrightarrow{\text{ROW}\\ 1}\xrightarrow{\text{ROW}\\ 2}\xrightarrow{\text{ROW}\\ 3} \begin{pmatrix}1&0&0\\\\2&0&0\\\\3&0&0\end{pmatrix}\xrightarrow{\text{COL}\\ 3}\xrightarrow{\text{COL}\\ 3}\xrightarrow{\text{COL}\\ 3} \begin{pmatrix}1&0&6\\\\2&0&5\\\\3&0&4\end{pmatrix}\xrightarrow{\text{ROW}\\ 1}\xrightarrow{\text{ROW}\\ 2}\xrightarrow{\text{ROW}\\ 3} \begin{pmatrix}7&1&6\\\\8&2&5\\\\9&3&4\end{pmatrix}$$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
3 3
001
001
110
3 3
010
111
010
3 3
111
111
111
3 3
000
000
000
3 3
000
000
001```

### 输出

```
YES
YES
YES
YES
NO```

# AI分析结果



**唯一算法分类**：贪心

---

### **题解思路与算法要点**

题目要求判断网格中的球是否可通过特定推球操作得到。核心条件是每个球必须满足其左侧或上方全被填满。各题解的核心思路如下：

- **前缀和法**：预处理行和列的前缀和，若某球所在行的前缀和等于列数（左侧全满）或列的前缀和等于行数（上方全满），则合法。
- **标记法**：两次遍历网格，先从左到右标记行中可推入的球，再从上到下标记列中可推入的球，最后检查是否有未被标记的球。
- **暴力检查**：对每个球直接遍历其左侧和上方是否存在空位，若均不满足则非法。

**解决难点**在于高效验证每个球的合法性。前缀和法与标记法通过预处理将时间复杂度优化至 $O(nm)$，远优于暴力法的 $O(nm(n+m))$。

---

### **题解评分（≥4星）**

1. **hongshixiaobai（★★★★☆）**  
   - 使用二维前缀和快速判断行/列是否填满，代码简洁高效。  
   - 核心逻辑清晰，预处理与验证分离，适合大网格。

2. **shicj（★★★★☆）**  
   - 两次遍历标记合法球，模拟推球过程，直观易懂。  
   - 空间复杂度低，适合内存敏感场景。

3. **NEKO_Daze（★★★★☆）**  
   - 预处理行和列的前缀按位与值，逻辑严密。  
   - 使用布尔数组优化判断，避免重复计算。

---

### **最优思路提炼**

**前缀和法**的核心步骤：
1. **预处理**：计算每行的列前缀和 `pre[i][j]`（第 `i` 行前 `j` 列的球数）和每列的行前缀和 `pre_col[i][j]`（第 `j` 列前 `i` 行的球数）。
2. **验证**：对每个球 `(i,j)`，若 `pre[i][j] == j`（左侧全满）或 `pre_col[i][j] == i`（上方全满），则合法。

**关键代码片段**：
```cpp
// 预处理行前缀和
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        pre[i][j] = pre[i][j-1] + a[i][j];

// 预处理列前缀和
for (int j = 1; j <= m; j++)
    for (int i = 1; i <= n; i++)
        pre_col[i][j] = pre_col[i-1][j] + a[i][j];

// 检查合法性
if (a[i][j] == 1 && pre[i][j] != j && pre_col[i][j] != i)
    return "NO";
```

---

### **相似题目推荐**

1. **CF977D Divide by Three**  
   - 要求构造特定序列，涉及前缀条件验证。
2. **Luogu P1156 垃圾陷阱**  
   - 动态验证状态合法性，需预处理条件。
3. **LeetCode 1326. Minimum Number of Taps to Open to Water a Garden**  
   - 贪心覆盖区间，类似标记法的覆盖思想。

---

### **可视化算法演示**

**动画方案**：
1. **网格绘制**：用 Canvas 绘制 $n \times m$ 网格，初始全白。
2. **推球模拟**：红色方块表示当前检查的球，绿色表示合法路径（左或上全满），黄色表示非法。
3. **高亮逻辑**：
   - 检查某球时，高亮其左侧所有格子（行判断）或上方所有格子（列判断）。
   - 若任一方向全绿，标记该球为合法；否则标记为黄，播放失败音效。
4. **复古风格**：
   - **8位像素**：网格线为深灰，合法球用绿色像素块，非法用红色。
   - **音效**：合法时播放“叮”声，非法时播放“哔”声，背景为 8-bit 循环音乐。
5. **交互控制**：
   - **步进模式**：按空格逐步执行检查。
   - **自动播放**：调整速度自动演示算法流程。

**示例动画步骤**：
1. 初始化网格，显示所有球的位置。
2. 逐个检查球，高亮左侧和上方区域。
3. 若某球不合法，网格闪烁红色，输出 "NO" 并终止。
4. 所有球合法后，显示 "YES" 并播放胜利音效。

---

**核心实现思想**：通过预处理和快速验证，确保每个球的来源合法，避免冗余计算。

---
处理用时：64.33秒
# 题目信息

# Nearest Minimums

## 题目描述

You are given an array of $ n $ integer numbers $ a_{0},a_{1},...,a_{n-1} $ . Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.
找到一个长度为n的序列中，距离最短的最小值的距离。

## 样例 #1

### 输入

```
2
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
9
2 1 3 5 4 1 2 3 1
```

### 输出

```
3
```

# AI分析结果



## 算法分类
无算法分类

---

## 综合分析与结论
题目核心在于找到数组中相邻最小值的最小间距。所有题解均采用线性遍历思想，差异主要在空间优化与遍历次数：
1. **核心思路**：先确定最小值，再比较相邻最小值位置间距。或动态记录前一个最小值位置，实时更新最小间距。
2. **关键难点**：如何在一次遍历中同时确定最小值和间距，避免存储所有位置。
3. **最优解法**（da32s1da）：单次遍历，动态更新前一个最小值位置，空间复杂度 O(1)。
4. **可视化设计**：高亮当前元素与前一个最小值位置，显示实时间距更新。复古像素风格中用绿色块表示最小值，黄色线条标记间距，音效在更新最小间距时触发。

---

## 题解清单（≥4星）
1. **da32s1da（5星）**  
   - **亮点**：单次遍历，空间 O(1)，代码简洁高效。  
   - **关键代码**：动态更新最小值位置与间距。
2. **vectorwyx（4星）**  
   - **亮点**：使用 vector 存储位置，代码清晰易读。  
   - **关键代码**：两次遍历，记录所有最小值后比较间距。

---

## 最优思路与技巧提炼
1. **动态记录前驱位置**：遍历时仅保留前一个最小值的位置，实时计算当前间距。
2. **初始值设定**：将初始最小间距设为数组长度（最大可能值），逐步优化。
3. **条件分支优化**：遇到更小值时重置记录，相等时更新间距。

---

## 关键代码实现
```cpp
// da32s1da 的解法（核心逻辑）
int minn = INF, wz, ans = n;
for (int i = 1; i <= n; i++) {
    scanf("%d", &x);
    if (minn == x && ans > i - wz) ans = i - wz; // 更新间距
    if (minn >= x) { // 更新最小值或记录位置
        if (minn > x) minn = x, ans = n;
        wz = i;
    }
}
printf("%d\n", ans);
```

---

## 同类型题与算法套路
- **相似问题**：寻找数组中相邻相同元素的最小间距、滑动窗口最小值。
- **通用解法**：线性遍历时维护关键状态（如前驱位置、当前极值）。

---

## 推荐题目
1. [洛谷 P1425 - 小鱼的游泳时间](https://www.luogu.com.cn/problem/P1425)  
   （计算时间差，需处理分段逻辑）
2. [洛谷 P1614 - 爱与愁的心痛](https://www.luogu.com.cn/problem/P1614)  
   （连续子数组最小和，动态维护窗口）
3. [洛谷 P1179 - 数字统计](https://www.luogu.com.cn/problem/P1179)  
   （统计特定数字出现次数，线性遍历）

---

## 可视化与复古游戏化设计
1. **像素风格界面**：  
   - 数组元素显示为 16x16 像素块，最小值绿色，其他灰色。
   - 当前元素高亮黄色，前一个最小值高亮蓝色。
2. **动画与音效**：  
   - 遍历时播放 "beep" 音效，更新最小间距时播放 "ding"。
   - 间距线用红色像素绘制，实时更新长度。
3. **交互控制**：  
   - 速度滑块调节遍历速度（50ms~1000ms）。
   - 暂停/继续按钮控制动画，单步执行按钮逐帧观察。

```javascript
// 伪代码示例（Canvas 绘制与音效）
function drawArray(arr, currentIdx, prevMinIdx) {
    arr.forEach((val, idx) => {
        ctx.fillStyle = (val === minVal) ? '#00FF00' : '#888888';
        if (idx === currentIdx) ctx.fillStyle = '#FFFF00';
        if (idx === prevMinIdx) ctx.fillStyle = '#0000FF';
        ctx.fillRect(idx * 20, 50, 16, 16);
    });
}
```

---
处理用时：101.75秒
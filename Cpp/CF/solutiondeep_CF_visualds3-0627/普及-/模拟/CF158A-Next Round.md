# 题目信息

# Next Round

## 题目描述

# CF158  Next Round 下一轮   
# 题意简述  
有$n$个人参加一场比赛，其中分数排名前$k$位的人将被选入下一轮（选入下一轮的人分数必须为正，见样例#2），特别的，如果几个人分数相同且刚好并列处于第$k$名（或是并列$k-i$名，但是全部算入后选入下一轮的人数超过$k$人），这几个人都将被选入下一轮（见样例#1），题目要求你输出进入下一轮的人数。输入保证已经按分数从大到小排序。

## 说明/提示

在样例#1中，第五位和第六位参赛者都获得了七分，所以有六人进入下一轮。  
在样例#2中，没有人得到大于0的评分。  

翻译提供者：n0000000000o

## 样例 #1

### 输入

```
8 5
10 9 8 7 7 7 5 5
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4 2
0 0 0 0
```

### 输出

```
0
```

# AI分析结果



**唯一算法分类**  
模拟

---

### **题解思路与算法分析**  
题目要求确定晋级人数，核心在于处理两个条件：分数必须为正，且满足排名要求。由于输入已排序，可利用数组有序性高效处理。  

**关键步骤**：  
1. **确定有效分数线**：第k名的分数必须为正，否则直接返回前m个正数（m<k）。  
2. **处理并列情况**：若前k名有效，后续分数等于第k名且为正的均晋级。  

**解决难点**：  
- **边界处理**：前k名存在0时需立即终止，后续无需检查。  
- **高效遍历**：利用有序性，遇到不满足条件的分数即可终止遍历。  

---

### **题解评分 (≥4星)**  
1. **Chtholly_L（4星）**  
   - **亮点**：直接遍历统计符合条件的元素，代码简洁清晰。  
   - **代码**：  
     ```cpp  
     for(int i=1;i<=n;i++)  
         if(a[i]>=a[k] && a[i]>0) ans++;  
     ```  

2. **Soshine_溯闪（4星）**  
   - **亮点**：分阶段处理前k名和后续并列情况，逻辑明确。  
   - **代码**：  
     ```cpp  
     for(int i=1; i<=k; i++) {  
         if(a[i]==0) return; // 前k名出现0则终止  
     }  
     for(int i=k+1; i<=n; i++) {  
         if(a[i]==a[k]) ans++; // 处理并列  
         else break;  
     }  
     ```  

3. **Konnyaku_Alan（4星）**  
   - **亮点**：简洁的单循环统计，利用逻辑表达式合并条件。  
   - **代码**：  
     ```cpp  
     for(int i=1; i<=n; i++)  
         ans += (x <= a[i] && a[i]);  
     ```  

---

### **最优思路提炼**  
1. **直接条件判断**：遍历数组，统计所有满足「分数≥第k名且>0」的元素。  
2. **利用有序性优化**：一旦遇到不满足条件的分数，可提前终止遍历。  

---

### **同类型题与算法套路**  
- **排序数组处理**：利用有序性快速定位关键分界点（如第k名）。  
- **边界检查优化**：通过提前终止减少不必要的遍历。  

**推荐题目**：  
1. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)  
2. [P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)  
3. [P5143 攀爬者](https://www.luogu.com.cn/problem/P5143)  

---

### **可视化算法演示**  
**核心逻辑动画**：  
1. **像素风格界面**：使用16色像素块表示分数，绿色表示晋级，红色表示淘汰。  
2. **步进演示**：  
   - 高亮当前检查的分数块。  
   - 若分数≥第k名且>0，标记为绿色并增加计数器。  
   - 遇到分数<第k名或为0时，停止后续遍历。  
3. **音效与交互**：  
   - **晋级音效**：8-bit上升音调。  
   - **终止音效**：短促低音。  
   - **控制面板**：支持暂停/继续/步进，速度调节。  

---

### **核心代码实现**  
**Chtholly_L 的解法**：  
```cpp  
#include<iostream>  
using namespace std;  
int a[51];  
int main() {  
    int n, k;  
    cin >> n >> k;  
    for(int i=1; i<=n; i++) cin >> a[i];  
    int ans = 0;  
    for(int i=1; i<=n; i++) {  
        if(a[i] >= a[k] && a[i] > 0) ans++;  
    }  
    cout << ans;  
    return 0;  
}  
```  

**关键逻辑解释**：  
- 遍历每个分数，同时满足「≥第k名」和「>0」时计数。  
- 数组有序性确保后续分数不会超过第k名，隐含遍历终止条件。  

---

### **总结**  
本题通过条件判断与有序性优化，高效处理晋级人数统计。最优解法直接遍历并合并条件，代码简洁且易维护。可视化方案通过像素动画与音效交互，直观展示算法流程，适合教学与自学场景。

---
处理用时：138.58秒
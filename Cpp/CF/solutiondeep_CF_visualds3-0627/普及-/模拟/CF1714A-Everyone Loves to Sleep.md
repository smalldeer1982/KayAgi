# 题目信息

# Everyone Loves to Sleep

## 题目描述

Vlad和其他人一样，非常喜欢睡觉。

Vlad每天都要做 $n$ 件事，每件事在特定时间。对于这些事情中的每一件，他都定了一个闹钟，其中第 $i$ 个在 $h_i$ 时 $m_i$ 分被触发（$0\le h_i<24,0\le m_i<60）$。

Vlad使用24小时时间格式，所以12:59之后是13:00,23:59后是00:00。

Vlad在H时M分睡觉（$0 \le H < 24， 0 \le M < 60$）。

他要你回答：在下一个闹钟响之前，他能睡多久。

如果在他上床睡觉的时候有任何闹钟响起，那么他将睡0小时0分钟。

## 样例 #1

### 输入

```
3
1 6 13
8 0
3 6 0
12 30
14 45
6 0
2 23 35
20 15
10 30```

### 输出

```
1 47
0 0
10 55```

# AI分析结果



**唯一算法分类**  
模拟

---

### 综合分析与结论  
**核心思路**：将时间统一转换为分钟数处理跨天场景，计算最小时间差。  
**解决难点**：  
1. 跨天计算：通过`(t - sleep_time + 1440) % 1440`将闹钟时间与睡眠时间的差值统一转化为非负数  
2. 时间比较：将小时和分钟合并为分钟数后，可直接用整数比较代替复杂的时间格式判断  
**可视化设计**：  
- **动画流程**：  
  - 时间轴展示睡眠时间点（红色标记）和闹钟时间点（蓝色标记）  
  - 计算每个闹钟时间点时，显示其对应的分钟数及与睡眠时间的差值  
  - 高亮当前最小时间差（绿色边框）并动态更新  
- **复古风格**：  
  - 用 8-bit 像素时钟图标表示时间点，跨天闹钟用闪烁特效  
  - 播放音效：闹钟计算时触发短促“滴答”声，找到最小值时播放胜利音效  
  - Canvas 绘制时间轴网格，每格代表10分钟  

---

### 题解清单 (≥4星)  
1. **__KrNalty__（⭐⭐⭐⭐⭐）**  
   核心亮点：最简代码，将时间差计算压缩为一行公式`ans = min(ans, (t - sleep_time + 1440) % 1440)`  

2. **happy_dengziyue（⭐⭐⭐⭐）**  
   关键优化：直接返回`(t - m + 1440) % 1440`，避免复杂分支判断  

3. **封禁用户（⭐⭐⭐⭐）**  
   代码简洁性：使用统一分钟数计算，通过`minn`变量维护最小值  

---

### 最优思路代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t; cin >> t;
    while (t--) {
        int n, H, M; 
        cin >> n >> H >> M;
        int sleep_time = H * 60 + M, min_diff = INT_MAX;
        
        for (int i = 0; i < n; ++i) {
            int h, m; cin >> h >> m;
            int alarm_time = h * 60 + m;
            int diff = (alarm_time - sleep_time + 1440) % 1440;
            min_diff = min(min_diff, diff);
        }
        
        cout << min_diff / 60 << " " << min_diff % 60 << endl;
    }
    return 0;
}
```

---

### 同类型题拓展  
**通用解法**：将时间/日期统一为基本单位（分钟、秒、天数），通过模运算处理循环周期问题  

**推荐题目**：  
1. P5707 【深基2.例12】上学迟到（时间计算与进位）  
2. P3954 [NOIP2017 普及组] 成绩（简单数学计算）  
3. P2667 [NOIP2015 提高组] 跳石头（二分答案与差值计算）  

---

### 可视化核心逻辑演示  
```javascript
// 伪代码示例：Canvas 时间轴绘制
function drawTimeline(sleepTime, alarms) {
    const pxPerMin = 2; // 每分钟2像素
    ctx.clearRect(0, 0, 2880, 100); // 48小时时间轴
    
    // 绘制睡眠时间点（红色）
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(sleepTime * pxPerMin, 0, 2, 50);
    
    // 绘制闹钟时间点（蓝色）
    alarms.forEach(t => {
        const pos = (t > sleepTime) ? t : t + 1440;
        ctx.fillStyle = (t < sleepTime) ? '#00FFFF' : '#0000FF'; // 跨天闪烁
        ctx.fillRect(pos * pxPerMin, 50, 2, 50);
    });
}
```

---

### 个人心得摘录  
> "将时间转换为分钟数后，所有问题都变成了简单的整数运算。调试时发现，跨天场景只需要加1440再取模就能统一处理，避免了复杂的if-else分支" —— __KrNalty__  

> "最初尝试逐个分钟模拟，但发现当n=10时完全可行，后来优化为数学计算后代码更简洁" —— zhicheng

---
处理用时：82.89秒
# 题目信息

# Inhabitant of the Deep Sea

## 题目描述

$n$ 艘船只开始探索海洋深处。这些船的编号从 $1$ 到 $n$ 并按升序相互跟随，第 $i$ 只船的耐久度是 $a[i]$ 。( $1 ≤ a[i] ≤ 10^9$ )

海妖按特定顺序袭击 $k$ 次船只：首先，它攻击船队的第一艘船只，然后攻击最后一艘，然后再攻击第一艘……依此类推。

海妖的每次攻击都会降低飞船的 $1$ 耐久度。当船舶的耐久性下降到 $0$ ，它就沉没了（而海妖只攻击尚未沉没的船只）。如果所有的船只都沉没了，海妖就没有什么可攻击的了，它就会游走。

给定 $n , k$ 和 $n$ 只船的耐久度，问海妖袭击后有多少艘船被击沉？

## 样例 #1

### 输入

```
6
4 5
1 2 4 3
4 6
1 2 4 3
5 20
2 7 1 8 2
2 2
3 2
2 15
1 5
2 7
5 2```

### 输出

```
2
3
5
0
2
2```

# AI分析结果



## 算法分类
贪心算法

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **攻击次数拆分**：将总攻击次数 $k$ 拆分为奇数次攻击（左攻击次数 $k1 = \lceil k/2 \rceil$）和偶数次攻击（右攻击次数 $k2 = \lfloor k/2 \rfloor$）。
2. **双指针贪心**：分别从左到右处理左攻击次数，再从右到左处理右攻击次数，优先击沉当前方向的最外侧船只，直到攻击次数用尽。
3. **避免重复计算**：左攻击处理完成后，右攻击仅处理未被左攻击击沉的船只。

### 解决难点
- **交替攻击的等效性**：虽然实际攻击顺序是左右交替，但总攻击次数固定，可以等效为连续处理左攻击和右攻击。
- **边界处理**：需确保左右攻击处理的范围不重叠，且在总耐久不足时快速返回 $n$。

---

## 题解评分（≥4星）

### 题解1：_ayaka_（4星）
- **亮点**：代码简洁，直接在输入阶段处理左攻击，避免额外遍历。
- **实现**：使用 `h` 记录左攻击击沉的最远位置，右攻击从末尾反向处理。

### 题解2：2c_s（4星）
- **亮点**：利用前缀和与后缀和快速计算击沉位置，数学推导清晰。
- **实现**：预处理前缀和数组，通过二分查找优化击沉位置判断。

### 题解3：YZMX（4星）
- **亮点**：逻辑分层明确，特判总耐久不足的情况，代码可读性高。
- **实现**：独立处理左右攻击，直接累加击沉数。

---

## 最优思路与技巧

### 关键思路
1. **攻击次数拆分**：奇数次攻击全部分配给左侧，偶数次给右侧。
2. **贪心击沉**：每次尽可能击沉当前方向的最外侧船只，剩余攻击转移至下一艘。
3. **范围隔离**：左攻击处理完成后，右攻击仅处理未被左攻击覆盖的船只。

### 核心代码片段
```cpp
// 处理左攻击
int h = 0, ans = 0;
for (int i = 1; i <= n; i++) {
    if (k1 >= a[i]) {
        k1 -= a[i];
        h = i;
    } else {
        a[i] -= k1;
        k1 = 0;
        break;
    }
}
ans = h;

// 处理右攻击
for (int i = n; i > h; i--) {
    if (k2 >= a[i]) {
        k2 -= a[i];
        ans++;
    } else break;
}
```

---

## 类似题目推荐
1. **CF977D**：交替操作模拟，需处理动态边界。
2. **LeetCode 1891**：贪心分配资源，最大化利用次数。
3. **洛谷 P1094**：双指针处理左右边界，优化时间效率。

---

## 可视化与算法演示

### 动画设计
- **动态指针**：用两个箭头标记当前左/右攻击的船只，高亮当前操作。
- **耐久条**：显示每艘船的剩余耐久，击沉后变为灰色。
- **攻击次数槽**：实时显示剩余左/右攻击次数，颜色区分。

### 复古像素风格
- **像素船模型**：船用 8x8 像素块表示，耐久用颜色深度表示。
- **音效**：攻击时播放短促“哔”声，击沉时播放爆炸音效。
- **自动演示**：按帧逐步执行攻击逻辑，支持暂停/步进。

---

## 总结
通过拆分攻击次数和贪心处理边界，本题可在 $O(n)$ 时间高效解决。关键点在于等效攻击顺序与范围隔离的实现。各题解均围绕这一核心展开，差异仅在于实现细节（如预处理数组或直接修改原数组）。

---
处理用时：269.91秒
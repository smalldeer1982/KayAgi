# 题目信息

# Manhattan Circle

## 题目描述

给定一个由“.”和“#”字符组成的n*m的网格，网格上存在一个完整的曼哈顿圆。网格的左上角坐标为(1,1)
，右下角坐标为(n,m) 。
如果|h-a| +|k-b|<r，则点（a,b）属于以（h,k）为中心的曼哈顿圆，其中r是正常数。
在网格上，作为曼哈顿圆一部分的点集被标记为“#”。找到圆心的坐标。

## 样例 #1

### 输入

```
6
5 5
.....
.....
..#..
.....
.....
5 5
..#..
.###.
#####
.###.
..#..
5 6
......
......
.#....
###...
.#....
1 1
#
5 6
...#..
..###.
.#####
..###.
...#..
2 10
..........
...#......```

### 输出

```
3 3
3 3
4 2
1 1
3 4
2 4```

# AI分析结果



---

## **算法分类**
几何、曼哈顿距离

---

## **题解思路与难点分析**

### **核心思路**
曼哈顿圆在网格中表现为菱形，圆心为菱形的对称中心。通过以下两种方法可高效求解圆心坐标：
1. **边界法**：找到菱形的最上行、最下行、最左列、最右列，圆心为它们的中间值。
2. **最长行中点法**：找到包含最多 `#` 的行，该行的第一个和最后一个 `#` 的中点即为圆心。

### **解决难点**
- **边界确定**：需遍历网格找到四个边界点，确保曼哈顿圆的对称性。
- **高效计算**：避免存储所有 `#` 的坐标，直接通过一次遍历记录关键信息（如行的最大长度或边界值）。

---

## **高分题解推荐 (≥4星)**

### **1. 边界法（作者：int_stl，5星）**
- **思路**：找到曼哈顿圆的最上行、最下行、最左列、最右列，圆心为它们的平均值。
- **亮点**：时间复杂度 O(nm)，空间 O(1)，直接利用几何对称性。
- **代码片段**：
  ```cpp
  // 找到上下左右边界
  for (int i=1; i<=n; i++) {
      if (该行有#) { shang = i; break; }
  }
  for (int i=n; i>=1; i--) {
      if (该行有#) { xia = i; break; }
  }
  // 类似处理列
  cout << (shang + xia)/2 << " " << (zuo + you)/2;
  ```

### **2. 最长行中点法（作者：BrotherCall，5星）**
- **思路**：遍历每行，记录最长行的第一个和最后一个 `#`，取中点。
- **亮点**：单次遍历，代码简洁高效。
- **代码片段**：
  ```cpp
  for (每行) {
      统计该行第一个和最后一个 # 的位置；
      if (当前行长度 > 最大长度) 更新圆心坐标；
  }
  ```

### **3. 行列统计法（作者：OPEC，4星）**
- **思路**：统计每行每列的 `#` 数量，取最多行和列的交点。
- **亮点**：直观易懂，适用于曼哈顿圆对称分布场景。
- **代码片段**：
  ```cpp
  for (统计每行每列的 # 数量)；
  int max_row = 最多 # 的行；
  int max_col = 最多 # 的列；
  cout << max_row << " " << max_col;
  ```

---

## **最优思路与技巧**
- **边界法**：直接利用曼哈顿圆的几何特性，时间复杂度最优。
- **关键技巧**：遍历网格时记录极值（如最大/最小行列），避免存储冗余数据。

---

## **相似题目推荐**
1. **P1661 扩散**：基于曼哈顿距离的覆盖问题。
2. **P3027 [USACO10DEC] The Trough Game**：二维数组中的几何分析。
3. **P2730 [IOI2008] Fish**：对称图形中心求解。

---

## **可视化算法设计**
### **动画方案**
- **网格绘制**：用 Canvas 绘制网格，`#` 显示为红色方块，圆心标记为绿色。
- **边界标记**：高亮最上行、最下行、最左列、最右列的边界线（黄色）。
- **动态遍历**：逐行扫描，实时更新最长行和其中点（蓝色闪烁）。

### **复古像素风格**
- **颜色方案**：8-bit 风格，红、绿、黄、蓝四色。
- **音效**：扫描时播放“滴”声，找到圆心时播放胜利音效。
- **交互**：支持暂停/继续，调整扫描速度。

---

## **核心代码（边界法）**
```cpp
// 寻找上下左右边界
int shang = 0, xia = 0, zuo = 0, you = 0;
for (int i = 1; i <= n; i++) {
    bool has = false;
    for (int j = 1; j <= m; j++) {
        if (grid[i][j] == '#') { has = true; break; }
    }
    if (has) { shang = i; break; }
}
// 类似处理 xia, zuo, you
cout << (shang + xia)/2 << " " << (zuo + you)/2;
```

---

通过上述分析，边界法是最优解法，既高效又直观，适用于所有合法输入。

---
处理用时：218.93秒
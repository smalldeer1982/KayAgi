# 题目信息

# Showering

## 题目描述

作为一名中学生，jmsyang0808需要每天洗澡，但悲剧的是，因为Ta还要登~~臭名昭著的~~洛谷，AK CF赛，面基等等做一些琐碎的事导致Ta没有空。因为Ta太忙了，所以Ta请你写个程序来解决这个问题。

Ta有 $m$ 单位的时间，而Ta需要用 $s$ 单位的时间来洗澡。Ta有 $n$ 件事要做，第 $i$ 件事的开始与结束时间分别为 $l_i$ 和 $r_i$ ，期间Ta无法洗澡。没有两项任务重叠。

现在jmsyang0808问你，Ta有时间洗澡吗？如果能，输出 `YES` ，否则只能输出 `NO` 了QAQ~。

## 说明/提示

下面是对于用例一的解释。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1999C/f37c16ccee56dc0e812638d809cb1411cb80cf1b.png)

Translated By @jmsyang0808.

## 样例 #1

### 输入

```
4
3 3 10
3 5
6 8
9 10
3 3 10
1 2
3 5
6 7
3 3 10
1 2
3 5
6 8
3 4 10
1 2
6 7
8 9```

### 输出

```
YES
YES
NO
YES```

# AI分析结果



### **唯一算法分类**  
**模拟**

---

### **题解思路、算法要点与解决难点**  

#### **核心思路**  
所有题解均基于以下步骤：  
1. **维护上一个任务的结束时间**：初始为 `0`，遍历每个任务时，计算当前任务的开始时间与上一任务结束时间的间隙。  
2. **检查间隙是否≥s**：若存在任一间隙满足条件，立即判定为可行。  
3. **处理首尾边界**：检查 `0` 到第一个任务的开始时间，以及最后一个任务的结束时间到 `m` 的间隙。  

#### **关键变量与逻辑**  
- **`last_r`** 或 **`prev_r`**：记录前一个任务的结束时间，用于计算间隙。  
- **最大间隙优化**：部分题解（如xxxalq）通过维护最大间隙，减少立即判断的次数。  
- **提前终止遍历**：一旦找到符合条件的间隙，立即输出结果，避免无效循环。  

#### **解决难点**  
- **边界处理**：需确保首尾间隙的正确计算，部分题解通过虚拟添加 `[0,0]` 或 `[m,m]` 简化逻辑。  
- **输入顺序保证**：题目明确任务按时间顺序排列，无需额外排序。  

---

### **题解评分 (≥4星)**  

#### **1. xxxalq (4.5星)**  
- **亮点**：代码可读性强，使用 `maxx` 维护最大间隙，统一处理边界。  
- **核心代码**：  
  ```cpp  
  last = 0;  
  maxx = max(maxx, l - last);  // 处理开头间隙  
  maxx = max(maxx, m - last);   // 处理结尾间隙  
  ```  

#### **2. Archy_ (4星)**  
- **亮点**：变量命名清晰（`lastr`），逻辑简洁。  
- **核心代码**：  
  ```cpp  
  time = max(time, l - lastr);  // 实时更新最大间隙  
  ```  

#### **3. ICU152_lowa_IS8 (4星)**  
- **亮点**：代码最短，直接维护 `ans` 并输出结果。  
- **核心代码**：  
  ```cpp  
  ans = max(ans, a[i].l - a[i-1].r);  // 计算间隙并比较  
  ```  

---

### **最优思路或技巧提炼**  
1. **线性扫描法**：遍历任务间隙，时间复杂度 `O(n)`，无需额外数据结构。  
2. **虚拟端点**：在任务列表首尾添加虚拟任务 `[0,0]` 和 `[m,m]`，统一处理逻辑。  
3. **即时判断优化**：一旦发现可行间隙立即返回，避免遍历剩余任务。  

---

### **同类型题与算法套路**  
- **区间覆盖问题**：如合并重叠区间、查找未被覆盖的区间。  
- **贪心策略**：按时间顺序处理任务，优先选择最早结束的任务。  
- **典型题目**：  
  - **洛谷 P1803**：凌乱的yyy / 线段覆盖（区间选择）  
  - **洛谷 P2249**：【深基13.例1】查找（边界处理）  
  - **LeetCode 252**：会议室（区间重叠判断）  

---

### **推荐相似题目**  
1. **CF1029C**：Maximal Intersection（区间交集处理）  
2. **洛谷 P2285**：打鼹鼠（时间轴动态规划）  
3. **洛谷 P2949**：Work Scheduling（贪心选择任务）  

---

### **个人心得摘录**  
- **@lcy0506**：  
  > “刚开始没注意到任务已排序，浪费了时间排序，后来发现题目保证 `l_i > r_{i-1}`，代码复杂度骤降。”  
- **@PineappleSummer**：  
  > “首尾间隙容易被忽略，加入虚拟端点后逻辑更统一。”  

---

### **可视化与算法演示**  

#### **动画方案设计**  
1. **时间轴绘制**：  
   - **颜色标记**：  
     - 红色：任务时间段（`[l_i, r_i]`）  
     - 绿色：空闲时间段（间隙）  
     - 黄色高亮：当前正在检查的间隙  
   - **步进控制**：单步展示每个间隙的计算过程，高亮其长度。  

2. **复古像素风格实现**：  
   - **Canvas 初始化**：绘制水平时间轴，刻度为 `0` 到 `m`。  
   - **任务块绘制**：用红色像素块表示 `[l_i, r_i]`，绿色块表示间隙。  
   - **音效触发**：  
     - 发现可行间隙时播放 `8-bit` 胜利音效。  
     - 遍历间隙时播放轻微“滴答”声。  

3. **AI 自动演示模式**：  
   - **自动播放**：按固定时间间隔遍历所有间隙，绿色块逐渐延伸至 `s` 长度。  
   - **积分系统**：每正确识别一个可行间隙得 `10` 分，错误扣 `5` 分。  

#### **关键代码片段（JS）**  
```javascript  
// 绘制时间轴与间隙  
ctx.fillStyle = "#FF0000";  
ctx.fillRect(l_i * scale, 0, (r_i - l_i) * scale, 20);  // 任务块  
ctx.fillStyle = "#00FF00";  
ctx.fillRect(last_r * scale, 0, (current_l - last_r) * scale, 20);  // 间隙块  
```  

---

### **完整参考代码**  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  

void solve() {  
    int n, s, m, last = 0;  
    cin >> n >> s >> m;  
    bool ok = false;  
    for (int i = 0; i < n; ++i) {  
        int l, r;  
        cin >> l >> r;  
        if (l - last >= s) ok = true;  
        last = r;  
    }  
    if (m - last >= s) ok = true;  
    cout << (ok ? "YES" : "NO") << endl;  
}  

int main() {  
    int T;  
    cin >> T;  
    while (T--) solve();  
    return 0;  
}  
```

---
处理用时：83.07秒
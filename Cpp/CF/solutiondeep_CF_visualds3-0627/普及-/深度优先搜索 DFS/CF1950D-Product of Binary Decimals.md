# 题目信息

# Product of Binary Decimals

## 题目描述

### 二进制小数的乘积
我们称一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，$1010111$ 是一个二进制小数，而 $10201$ 和 $787788$ 不是。

给定一个数 $n$，你被要求判断是否可能将 $n$ 表示为一些（不一定是不同的）二进制小数的乘积。

## 说明/提示

前五个测试用例可以表示为二进制小数的乘积如下：

$121 = 11 \times 11$
$1 = 1$ 已经是一个二进制小数。
$14641 = 11 \times 11 \times 11 \times 11$
$12221 = 11 \times 11 \times 101$
$10110 = 10110$ 已经是一个二进制小数。

## 样例 #1

### 输入

```
11
121
1
14641
12221
10110
100000
99
112
2024
12421
1001```

### 输出

```
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
YES```

# AI分析结果



### 算法分类  
其他搜索（动态规划预处理）  

---

### 题解思路与解决难点  
**核心思路**：判断一个数能否分解为若干二进制小数的乘积。  
**关键难点**：如何高效覆盖所有可能的因数组合，避免重复计算。  

#### 题解对比  
- **DFS递归分解**（题解1、3、4）：  
  - 预处理所有可能的二进制小数（如10, 11, 100等），通过深度优先搜索（DFS）递归试除。  
  - **缺陷**：手动打表的二进制小数可能不完整（如题解1仅覆盖到11111=31），导致无法处理大数。  
- **动态规划预处理**（题解2）：  
  - 预处理每个数是否为二进制小数或其因数是否可分解，利用动态规划标记每个数的可行性。  
  - **优势**：覆盖所有可能的分解组合（如分解为多个因数时，拆分为两步处理），确保正确性。  

---

### 题解评分（≥4星）  
1. **题解2（minVan）** ⭐⭐⭐⭐⭐  
   - **亮点**：预处理后查询复杂度O(1)，动态规划覆盖所有分解情况。  
   - **代码可读性**：简洁，使用动态规划思路。  
2. **题解1（Pink_Cut_Tree）** ⭐⭐⭐⭐  
   - **亮点**：DFS递归直观，手动打表减少计算量。  
   - **缺陷**：预处理数组不完整，无法处理大二进制小数（如100000）。  

---

### 最优思路与技巧  
- **动态规划预处理**：  
  - 对每个数i，检查其是否为二进制小数，或能否分解为两个可行因数j和i/j的乘积。  
  - **关键代码**：  
    ```cpp  
    for(int i = 1; i < N; i++) {  
        if (check(i)) vis[i] = true;  
        else {  
            for (int j = 1; j*j <= i; j++) {  
                if (i % j == 0 && vis[j] && vis[i/j]) {  
                    vis[i] = true;  
                    break;  
                }  
            }  
        }  
    }  
    ```  

---

### 同类型题与算法套路  
- **因数分解预处理**：类似“判断质数/合数”问题，但扩展为多条件分解。  
- **动态规划状态转移**：通过子问题（因数）推导父问题（原数）的可行性。  

---

### 推荐题目  
1. [P1867 素数筛法](https://www.luogu.com.cn/problem/P1867)  
2. [P2926 Patting Heads S](https://www.luogu.com.cn/problem/P2926)  
3. [P1613 小凯的疑惑](https://www.luogu.com.cn/problem/P1613)  

---

### 可视化与算法演示  
**动态规划预处理流程**：  
1. **初始化网格**：每个格子表示一个数，绿色标记二进制小数，红色标记不可行。  
2. **逐步填充**：从小到大处理每个数，若其可分解为两个绿色格子，则标记为绿色。  
3. **交互演示**：允许用户输入数值，高亮其因数分解路径。  

**复古像素风格**：  
- **颜色方案**：绿色（可行）、红色（不可行）、黄色（正在检查）。  
- **音效**：成功时播放8位音效，失败时播放低沉音。  

---

### 代码实现（题解2）  
```cpp  
#include<bits/stdc++.h>  
#define int long long  
using namespace std;  
const int N = 1e5 + 5;  
bool vis[N];  

inline bool check(int x) {  
    while(x) {  
        if(x % 10 > 1) return false;  
        x /= 10;  
    }  
    return true;  
}  

signed main() {  
    ios::sync_with_stdio(0);  
    cin.tie(0);  
    for(int i = 1; i < N; i++) {  
        if(check(i)) { vis[i] = true; continue; }  
        for(int j = 1; j*j <= i; j++) {  
            if(i % j == 0 && vis[j] && vis[i/j]) {  
                vis[i] = true;  
                break;  
            }  
        }  
    }  
    int t, n;  
    cin >> t;  
    while(t--) {  
        cin >> n;  
        cout << (vis[n] ? "YES\n" : "NO\n");  
    }  
    return 0;  
}  
```  

---

**结论**：动态规划预处理是本题最优解，兼顾正确性与效率，覆盖所有可能的分解路径。

---
处理用时：311.95秒
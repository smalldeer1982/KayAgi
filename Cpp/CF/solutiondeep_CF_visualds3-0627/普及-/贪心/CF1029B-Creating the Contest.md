# 题目信息

# Creating the Contest

## 题目描述

你有一个包含 $ n $ 个问题的问题集，其中第 $ i $ 个问题的难度为 $ a_i $ ，保证没有难度相同的两个问题，且问题难度按照递增顺序给出。

你需要在这个问题集中取一个子集（不要求问题的顺序连续），满足以下条件：对于每道题目，在该子集中不存在难度超过该问题难度2倍的题目。（仅包含一个问题的子集也是合法的）

求出这个子集最多能包含多少个问题。

## 样例 #1

### 输入

```
10
1 2 5 6 7 10 21 23 24 49
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5
2 10 50 110 250
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6
4 7 12 100 150 199
```

### 输出

```
3
```

# AI分析结果



---

## 综合分析与结论

### 题目核心与难点
- **核心目标**：在递增序列中找最长子数组，使得任意相邻元素满足后项 ≤ 前项的 2 倍。
- **难点**：证明贪心策略的正确性（连续子数组最优），避免陷入动态规划的高复杂度实现。

### 贪心策略解析
- **核心思路**：遍历数组，维护当前连续子数组长度。若 `a[i+1] ≤ 2*a[i]` 则延长序列，否则重置长度。
- **正确性证明**：假设存在非连续最优解，可通过替换中间元素构造更优连续解，矛盾。
- **可视化设计**：
  - **动画方案**：逐个高亮元素，显示当前连续长度；当条件不满足时，触发重置并记录最大值。
  - **颜色标记**：绿色高亮当前元素，红色标记断点，动态显示当前最长序列。
  - **交互设计**：支持步进/暂停，实时显示条件判断逻辑（如 `2*a[i]` 与 `a[i+1]` 的数值比较）。

---

## 题解清单（≥4星）

### 1. 一扶苏一（5星）
- **亮点**：贪心策略简洁，数学证明严谨，代码高效（O(n) 时间，O(1) 空间）。
- **代码简析**：遍历数组维护当前连续长度，更新最大值。
- **个人心得**：通过反证法证明连续性，避免动态规划的复杂实现。

### 2. MattL（4.5星）
- **亮点**：代码极简（仅 15 行），强调“最优子区间不重叠”的直观理解。
- **代码简析**：从前往后扫描，直接比较相邻元素，维护计数器。
- **关键点**：正确处理循环结束后的最大值更新。

### 3. 彭骐飞（4星）
- **亮点**：单调队列优化动态规划，提供另一种思路（O(n) 时间）。
- **代码简析**：用 `deque` 维护决策点，动态转移状态。
- **适用场景**：数据规模极大时（如 1e7）仍保持高效。

---

## 最优思路提炼
- **贪心选择依据**：利用数组递增特性，连续满足条件的子数组必为最优。
- **实现技巧**：
  1. **单次遍历**：无需额外数据结构，仅需计数器与最大值变量。
  2. **边界处理**：循环结束后需再次比较 `maxcnt` 与当前计数器。
- **反例规避**：任何非连续解均可被连续解覆盖，保证贪心正确性。

---

## 同类型题与算法套路
- **通用场景**：最长满足特定条件的连续/非连续子数组。
- **类似题目**：
  1. **最长递增子序列**（贪心 + 二分优化）。
  2. **最大连续1的个数**（LeetCode 485，类似计数器维护）。
  3. **满足和≥target的最短子数组**（滑动窗口）。
- **算法套路**：单调性利用、滑动窗口、贪心连续性证明。

---

## 推荐练习题
1. **洛谷 P1091**：合唱队形（双向贪心）。
2. **洛谷 P1280**：尼克的任务（贪心选择任务区间）。
3. **洛谷 P1230**：智力大冲浪（时间窗口贪心）。

---

## 个人心得摘录
- **调试教训**：未及时更新最大值导致 WA（需在循环内外均比较）。
- **思维顿悟**：“连续子数组最优”的证明是贪心核心，避免复杂算法设计。
- **代码优化**：从动态规划（O(n log n)）转向贪心（O(n)）大幅提升效率。

---

## 代码实现（核心贪心逻辑）
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, cnt = 1, maxcnt = 1;
    cin >> n;
    int a[n];
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n-1; ++i) {
        if (a[i+1] <= 2 * a[i]) cnt++;
        else maxcnt = max(maxcnt, cnt), cnt = 1;
    }
    cout << max(maxcnt, cnt);
    return 0;
}
```

---

## 可视化设计要点
### 复古像素风格演示
- **颜色方案**：绿色（当前元素）、黄色（当前连续序列）、红色（断点）。
- **Canvas 绘制**：网格化数组元素，动态高亮比较过程。
- **音效触发**：
  - **成功延长**：短促“滴”声。
  - **重置序列**：低沉“咚”声。
  - **更新最大值**：上扬音效。
- **AI 自动模式**：模拟遍历过程，以 0.5 秒/步自动执行，显示条件判断结果。

### 游戏化交互
- **积分系统**：连续长度每增加 1 得 10 分，打破记录额外奖励 50 分。
- **关卡设计**：每个测试用例为一关，通过后解锁更复杂数据。
- **连击奖励**：连续 5 次延长序列触发“连击”特效，加速动画。

---

**可视化示例（伪代码）**  
```javascript
// 初始化 Canvas
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

function drawArray(a, currentIdx, streakLength) {
    a.forEach((num, idx) => {
        ctx.fillStyle = idx === currentIdx ? '#00FF00' : 
                       (idx >= currentIdx - streakLength ? '#FFFF00' : '#FFFFFF');
        ctx.fillRect(idx * 30, 0, 28, 28);
        ctx.fillText(num, idx * 30 + 5, 20);
    });
}

// 音效触发函数
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---
处理用时：74.37秒
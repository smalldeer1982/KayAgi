# 题目信息

# Reverse Sort

## 题目描述

题目共给出 $t(1 \le t \le 1000)$ 组数据，每组数据包含一个正整数 $n(1 \le n \le 1000)$ 和一个长度为 $n$ 的 $01$ 串 $s$， 现在你需要在 $s$ 中选出一个子序列，将这个子序列中的字符翻转（如字符串 $10100$， 选出子序列 $1100$， 翻转得到 $0011$， 放回原串中得到 $00011$），使得翻转后的字符串字典序最小。

## 样例 #1

### 输入

```
3
7
0011111
5
10100
6
001000```

### 输出

```
0
1
4 1 3 4 5 
1
3 3 5 6```

# AI分析结果



### 综合分析与结论

**核心思路**：所有题解均基于贪心策略，通过一次反转操作将字符串变为全0在前+全1在后的最优形态。核心贪心选择为：找出前cnt0位中的1与后cnt1位中的0，反转这些位置使得所有0前移、1后移。

**贪心策略推导**：
1. **目标形态确定**：最终字符串前cnt0（0的总数）位为0，后cnt1位为1。
2. **矛盾点分析**：前cnt0位中的1和后cnt1位中的0是阻碍字典序最小的关键。
3. **交换必要性**：选中这些矛盾点进行反转，可一次性消除所有逆序对。

**难点与解决**：
- **正确统计矛盾点**：需遍历两次，分别收集前段的1和后段的0的位置。
- **边界处理**：需确保选中位置的数量相等，避免索引越界。

**可视化设计**：
- **动画步骤**：高亮前段1（红色）和后段0（蓝色），反转时交换颜色并移动至正确区域。
- **复古像素风格**：用8-bit方块表示字符，反转时播放经典音效，积分显示交换次数。
- **交互设计**：用户可调整字符数量，观察不同输入下贪心选择的变化。

---

### 题解评分（≥4星）

1. **Jerrlee✅（5星）**  
   **亮点**：代码简洁，直接统计矛盾点，逻辑清晰；预处理原串是否有序，优化判断。  
   **关键代码**：通过一次遍历统计1的数量，二次遍历收集反转位置。

2. **Jur_Cai（4星）**  
   **亮点**：双指针法高效匹配前后矛盾点，动态减少无效匹配。  
   **个人心得**："后半段中的1无需处理"的剪枝优化。

3. **YangXiaopei（4星）**  
   **亮点**：明确分两次统计矛盾点数量，输出格式处理规范。  
   **调试教训**：初始未处理输出顺序，导致WA后调整顺序。

---

### 最优思路与代码实现

**关键贪心逻辑**：
```cpp
int cnt0 = count(s.begin(), s.end(), '0'); // 统计0的总数
vector<int> ans;
// 收集前cnt0位中的1
for(int i=0; i<cnt0; i++) 
    if(s[i]=='1') ans.push_back(i+1);
// 收集后cnt1位中的0
for(int i=cnt0; i<n; i++) 
    if(s[i]=='0') ans.push_back(i+1);
// 输出一次操作及所有位置
cout << "1\n" << ans.size() << " ";
for(int x:ans) cout << x << " ";
```

**完整代码（Jerrlee优化版）**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int t; cin >> t;
    while(t--) {
        int n; string s;
        cin >> n >> s;
        int cnt0 = count(s.begin(), s.end(), '0');
        if(is_sorted(s.begin(), s.end())) { // 已有序
            cout << "0\n";
            continue;
        }
        vector<int> ans;
        for(int i=0; i<cnt0; ++i) 
            if(s[i] == '1') ans.push_back(i+1);
        for(int i=cnt0; i<n; ++i)
            if(s[i] == '0') ans.push_back(i+1);
        cout << "1\n" << ans.size() << " ";
        for(int x:ans) cout << x << " ";
        cout << "\n";
    }
}
```

---

### 相似题目推荐

1. **P1090 [NOIP2004 提高组] 合并果子** - 贪心选择最小堆  
2. **P1223 排队接水** - 贪心排序使平均等待最小  
3. **P2870 [USACO07DEC]Best Cow Line G** - 字典序贪心选择首尾字符  

---

### 可视化设计要点

1. **像素风格展示**：  
   - 每个字符显示为16x16像素块，0（蓝色），1（红色）  
   - 反转时被选块旋转90度并交换颜色，伴随8-bit音效  

2. **自动演示模式**：  
   ```js
   function autoPlay() {
       highlightFrontOnes(); // 红色闪烁前段1
       setTimeout(() => {
           highlightBackZeros(); // 蓝色闪烁后段0
           setTimeout(reverseAndMove, 1000); // 执行反转动画
       }, 1000);
   }
   ```

3. **积分与连击**：  
   - 正确识别一个矛盾点+10分，连击倍数递增  
   - 错误选择播放爆炸音效，连击重置  

---

### 个人心得摘录

> "初始认为需要多次操作，直到发现1和0的数量守恒，前段多余的1必然对应后段多余的0，一次交换即可全局最优。" —— Jerrlee  
> "调试时发现输出位置需要排序，否则可能生成非子序列导致WA。" —— wzy2021  
> "双指针法比预想的高效，O(n)时间完成匹配，避免了额外空间。" —— Jur_Cai  

---

通过上述分析与可视化设计，学习者可深入理解贪心策略在此题的应用，并通过交互演示直观感受每一步的最优选择过程。

---
处理用时：71.98秒
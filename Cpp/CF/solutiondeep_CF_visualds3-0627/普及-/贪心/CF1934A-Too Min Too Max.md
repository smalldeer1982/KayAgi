# 题目信息

# Too Min Too Max

## 题目描述

Given an array $ a $ of $ n $ elements, find the maximum value of the expression:

 $ $$$|a_i - a_j| + |a_j - a_k| + |a_k - a_l| + |a_l - a_i| $ $ </p><p>where  $ i $ ,  $ j $ ,  $ k $ , and  $ l $  are four <span class="tex-font-style-bf">distinct</span> indices of the array  $ a $ , with  $ 1 \\le i, j, k, l \\le n $ .</p><p>Here  $ |x| $  denotes the absolute value of  $ x$$$.

## 说明/提示

In the first test case, for any selection of $ i $ , $ j $ , $ k $ , $ l $ , the answer will be $ 0 $ . For example, $ |a_1 - a_2| + |a_2 - a_3| + |a_3 - a_4| + |a_4 - a_1| = |1 - 1| + |1 - 1| + |1 - 1| + |1 - 1| = 0 + 0 + 0 + 0 = 0 $ .

In the second test case, for $ i = 1 $ , $ j = 3 $ , $ k = 2 $ , and $ l = 5 $ , the answer will be $ 6 $ . $ |a_1 - a_3| + |a_3 - a_2| + |a_2 - a_5| + |a_5 - a_1| = |1 - 2| + |2 - 1| + |1 - 3| + |3 - 1| = 1 + 1 + 2 + 2 = 6 $ .

## 样例 #1

### 输入

```
5
4
1 1 1 1
5
1 1 2 2 3
8
5 1 3 2 -3 -1 10 3
4
3 3 1 1
4
1 2 2 -1```

### 输出

```
0
6
38
8
8```

# AI分析结果



---

### **唯一算法分类**  
排序 + 贪心

---

### **综合分析与结论**  
**核心思路**：  
题目要求四个不同下标对应的元素，使得表达式 `|a_i -a_j| + |a_j -a_k| + |a_k -a_l| + |a_l -a_i|` 最大。通过数学推导发现，该表达式可简化为 `2*(max1 + max2 - min1 - min2)`，其中 `max1/max2` 是数组中最大的两个元素，`min1/min2` 是最小的两个元素。排序后直接取极值点即可。

**难点与解决**：  
- 如何发现表达式可简化？观察样例并推导，发现极值点的组合能最大化总和。  
- 如何确保四个元素的排列顺序不影响结果？通过数学验证，极值点的特定排列方式使得总和最大。  

**可视化设计**：  
- **动画方案**：展示排序后的数组，高亮前两个元素（最小）和后两个元素（最大），动态绘制这四个点之间的连线，并显示总和公式。  
- **颜色标记**：红色标记最小值，蓝色标记最大值，绿色标记计算步骤。  
- **音效**：排序时播放像素音效，计算总和时播放成功音效。  

---

### **最优思路提炼**  
- **排序后取极值点**：排序数组，直接取最大两个和最小两个元素。  
- **公式推导**：通过观察样例和数学推导，得出总和公式 `2*(max1 + max2 - min1 - min2)`。  
- **复杂度优化**：排序后直接取极值，时间复杂度为 `O(n log n)`。  

---

### **题解代码**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) cin >> a[i];
        sort(a.begin(), a.end());
        int ans = 2 * (a[n-1] + a[n-2] - a[0] - a[1]);
        cout << ans << endl;
    }
    return 0;
}
```

---

### **同类型题与算法套路**  
- **极值点选择**：如最大子数组和、两数之和最大等。  
- **贪心策略**：通过排序或极值点快速确定最优解。  

---

### **推荐题目**  
1. **洛谷 P1094**（纪念品分组，贪心）  
2. **洛谷 P1223**（排队接水，排序贪心）  
3. **洛谷 P1012**（拼数，排序策略）  

---

### **可视化实现要点**  
- **Canvas 绘制**：将数组元素绘制为像素方块，排序后高亮极值点。  
- **自动演示**：自动完成排序和计算步骤，速度可调节。  
- **复古风格**：使用 8 位像素字体，背景音乐为芯片音效。  

--- 

**总结**：通过排序和极值贪心策略，快速定位最优解，时间复杂度为 `O(n log n)`，适用于大规模数据。

---
处理用时：195.02秒
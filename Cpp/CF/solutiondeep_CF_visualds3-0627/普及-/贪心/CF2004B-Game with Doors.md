# 题目信息

# Game with Doors

## 题目描述

### 题面描述
有 $100$ 个房间排成一列，之间有 $99$ 个门; 第 $i$ 个门连接第 $i$ 个房间和第 $i+1$ 个房间。每扇门可以上锁也可以不上锁。最初，所有的门都没有锁。

我们说，房间 $x$ 是可以到房间 $y$ 的，如果 $x$ 与 $y$ 之间的所有门都没锁。

你知道的:

- 爱丽丝在 $[l,r]$ 的某个房间里;
- Bob 在 $[L,R]$ 的某个房间里;
- 爱丽丝和鲍勃在不同的房间。

然而，你并不知道他们所在的确切房间。

你不希望爱丽丝和鲍勃能够联系到对方，所以你要锁上一些门来防止这种情况发生。无论 Alice 和 Bob 在给定段中的起始位置如何，您需要锁定的门的最小数量是多少？

## 样例 #1

### 输入

```
4
1 2
3 4
2 5
2 5
3 7
6 7
4 5
2 8```

### 输出

```
1
3
2
3```

# AI分析结果



**唯一算法分类**: 区间处理/贪心算法

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
问题转化为确定两区间的交集，并根据端点差异计算最小锁门数。  
1. **无交集**：锁任一中间门，答案1。  
2. **有交集**：  
   - 锁交集内所有门（门数 = 交集长度）。  
   - 若两区间左端点不同，加锁1扇门（左侧边界）。  
   - 若右端点不同，再加锁1扇门（右侧边界）。  

**解决难点**：  
- 正确计算交集并处理端点差异。  
- 数学推导确保覆盖所有情况，如区间包含、部分重叠、端点重合等。  

---

### **题解评分 (≥4星)**  
1. **NEKO_Daze（5星）**  
   - 思路清晰，代码简洁，直接处理交集与端点差异。  
   - 代码仅需10行，覆盖所有情况。  

2. **Infinite_Loop（4星）**  
   - 思路与NEKO_Daze一致，代码简洁，但变量命名稍简。  

3. **GeXiaoWei（4星）**  
   - 代码与NEKO_Daze完全一致，验证了思路的正确性。  

---

### **最优思路提炼**  
**关键公式**：  
```
ans = (交集的长度) + (左端点不同 ? 1 : 0) + (右端点不同 ? 1 : 0)
若交集为空，ans = 1。
```

**优化点**：  
- 无需交换区间顺序，直接通过`max/min`计算交集。  
- 端点差异通过布尔运算直接累加。  

---

### **同类型题与类似算法**  
- **通用解法**：区间交集与边界处理。  
- **相似题**：洛谷P1886（滑动窗口极值）、P3745（区间覆盖）。  

---

### **推荐洛谷题目**  
1. **P1886**：滑动窗口极值（区间极值）  
2. **P3745**：区间覆盖（贪心选择）  
3. **P3372**：线段树区间求和（数据结构应用）  

---

### **可视化算法演示**  
**动画设计**：  
1. **Canvas绘制**：  
   - 水平轴表示房间序列，区间用不同颜色标记。  
   - 交集区域高亮，锁门用红色方块标注。  
2. **复古像素风**：  
   - 房间为8位像素方块，门为垂直线段。  
   - 音效：锁门时播放“哔”声，成功时播放上扬音效。  
3. **步进控制**：  
   - 用户输入区间后，逐步显示交集计算、锁门位置。  
   - 自动模式可展示不同测试用例的锁门过程。  

**核心逻辑演示**：  
```javascript
// 伪代码：计算锁门位置
function calculateLocks(l, r, L, R) {
  const left = Math.max(l, L);
  const right = Math.min(r, R);
  let ans = Math.max(0, right - left);
  if (ans <= 0) return 1;
  ans += (l !== L ? 1 : 0) + (r !== R ? 1 : 0);
  return ans;
}
```

---

### **代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  int t; cin >> t;
  while (t--) {
    int l, r, L, R;
    cin >> l >> r >> L >> R;
    int ans = min(r, R) - max(l, L);
    if (ans < 0) ans = 1;
    else ans += (l != L) + (r != R);
    cout << ans << endl;
  }
}
```

---
处理用时：201.07秒
# 题目信息

# Splitting Items

## 题目描述

Alice 和 Bob 有 $n$ 个数，第 $i$ 个数为 $a_i$，他们决定玩一个游戏取走这些数。

游戏由 Alice 开始取数。

每一次玩家都可以拿走一个剩下的数，直到没有数字可拿走。

定义 $A$ 是 Alice 获取的数字和，$B$ 是 Bob 获取的数字和，游戏总分 $p = A - B$。

Alice 希望最大化 $p$，Bob 希望最小化 $p$，他们都绝顶聪明。

现在 Bob 拥有了修改数的权限，可以把一些数字（可以没有，也可以没有全部）**增加**一个整数值（可以增加不同的值），但是这样 Alice 可能会起疑心，所以总增加的数值必须小于等于 $k$。

请求出 Bob 能达到的 $p$ 的最小值。

## 样例 #1

### 输入

```
4
2 5
1 10
3 0
10 15 12
4 6
3 1 2 4
2 4
6 9```

### 输出

```
4
13
0
0```

# AI分析结果



---

## **唯一算法分类**  
贪心

---

## **题解思路与算法要点**  
### **核心思路**  
1. **排序策略**：将数组降序排列，确保Alice和Bob按最优策略依次取最大元素。
2. **贪心调整**：Bob通过增加偶数位置的元素，尽可能减少每个奇偶对的差值。每个偶数位置的元素最多增加到其前一个奇数位置元素的值。
3. **总差处理**：将所有偶数位置的差总和记为 `sum`，最终结果等于原总差减去 `min(k, sum)`，确保总增量不超过 `k`。

### **解决难点**  
- **顺序不变性**：调整偶数位置元素时，需保证排序后的顺序不变（即偶数位置元素不超过前一个奇数位置元素），否则可能被Alice取走。
- **差值计算**：通过计算每个奇偶对的差值总和，直接确定总减少量，避免遍历修改数组的复杂度。

---

## **题解评分 (≥4星)**  
1. **题解1（GY程袁浩）** ⭐⭐⭐⭐⭐  
   - **亮点**：直接计算总差之和，无需修改数组，时间复杂度最优。  
   - **代码简洁性**：仅需一次遍历计算总和，逻辑清晰。  

2. **题解2（Stars_Traveller）** ⭐⭐⭐⭐  
   - **亮点**：逐个处理偶数位置元素，直观展示调整过程。  
   - **可读性**：通过排序和遍历实现，便于理解贪心策略。  

3. **题解5（Scean_Tong）** ⭐⭐⭐⭐  
   - **亮点**：代码结构清晰，通过修改数组元素模拟调整过程。  
   - **边界处理**：正确处理奇数长度数组的最后一个元素。  

---

## **最优思路提炼**  
- **贪心排序**：降序排列后，Alice取奇数位，Bob取偶数位。  
- **差值总和法**：计算所有奇偶对的差值总和 `sum`，结果直接为 `sum - min(k, sum)`。  
- **无需遍历修改**：通过数学推导避免数组修改，时间复杂度优化至 `O(n log n)`。

---

## **同类型题与算法套路**  
- **通用解法**：贪心排序结合差值分析，适用于轮流取数的最优策略问题。  
- **类似题目**：  
  1. 洛谷 P1223（排队接水）  
  2. 洛谷 P1090（合并果子）  
  3. 洛谷 P1012（拼数）  

---

## **推荐题目**  
1. [CF1862D] 类似最优策略问题  
2. [洛谷 P1803] 线段覆盖（贪心排序）  
3. [洛谷 P1080] 国王游戏（贪心策略）  

---

## **代码核心实现**  
### **题解1（直接差值总和法）**  
```cpp
int ans = 0, sum = 0;
for (int i = 1; i <= n; i += 2) {
    if (i == n) {
        ans += a[i];
        break;
    }
    sum += a[i] - a[i + 1];
    ans += a[i] - a[i + 1];
}
cout << ans - min(sum, k) << endl;
```

### **题解2（逐个调整偶数位）**  
```cpp
sort(a + 1, a + 1 + n, greater<int>());
for (int i = 2; i <= n; i += 2) {
    if (k >= a[i - 1] - a[i]) {
        k -= a[i - 1] - a[i];
        a[i] = a[i - 1];
    } else {
        a[i] += k;
        break;
    }
}
```

---

## **可视化与算法演示**  
### **动画设计**  
1. **降序排序**：将数组按从大到小排列，用不同颜色区分奇偶位置。  
2. **差值标记**：高亮每个奇偶对的差值，显示当前 `k` 的剩余量。  
3. **逐步调整**：  
   - 若 `k` 足够，将偶数位置元素提升至前一个奇数元素的值，播放“提升音效”。  
   - 若 `k` 不足，仅提升部分值，播放“资源耗尽音效”。  
4. **结果计算**：动态展示 `A-B` 的变化，最终结果以像素风格弹出。

### **复古像素风格**  
- **颜色方案**：16色调色板，奇数为蓝色，偶数为红色，调整时闪烁黄色。  
- **音效**：8-bit 风格音效，提升时播放“嘀”声，完成时播放胜利旋律。  
- **交互控制**：支持暂停/步进，速度调节滑块，实时显示 `k` 的消耗。

---

## **个人心得摘录**  
- **索引边界**：处理奇数长度数组时，最后一个元素需单独加入总和。  
- **数学推导**：总差和 `sum` 的发现避免了复杂遍历，是优化代码的关键。  
- **贪心验证**：无论调整顺序如何，总减少量为 `min(k, sum)`，确保了算法正确性。

---
处理用时：264.62秒
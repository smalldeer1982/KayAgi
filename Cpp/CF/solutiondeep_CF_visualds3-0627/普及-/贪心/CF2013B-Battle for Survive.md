# 题目信息

# Battle for Survive

## 题目描述

Eralim（原文人名）作为 mafia（原文组织名）老大，管理着 $n$ 名战士。第 $i$ 名战士的评分为 $a_i$。

Eralim 安排了一场 $n-1$ 场战斗的锦标赛，每场战斗中都会选择两名尚未被淘汰的战士 $i$ 和 $j$（其中 $1 \le i < j \le n$），而战斗的结果是战士 $i$ 被淘汰出比赛，战士 $j$ 的评分会减去战士 $i$ 的评分相同。也就是说，$a_j$ 会减去 $a_i$。请注意，战士 $j$ 的评分可能会变为负数。战士们的编号不会改变。

Eralim 想知道，如果他最优地选择战斗，最后剩下的那名战士最多能保持多少评分。

## 说明/提示

在第一个例子中，你可以安排编号为 $1$ 和 $2$ 的战士之间的比赛，其中编号为 $2$ 的战士会获胜。最后一个战士的评分，即编号为 $2$ 的战士，将是 $1-2=-1$。

在第二个例子中，你可以先让编号为 $1$ 和 $2$ 的战士进行比赛，其中编号为 $2$ 的战士会获胜，然后让编号为 $2$ 和 $3$ 的战士进行比赛，其中编号为 $3$ 的战士会获胜。

在第一场比赛后，编号为 $2$ 的战士的评分将是 $2-2=0$。在第二场比赛后，编号为 $3$ 的战士的评分将是 $8-0=8$。

翻译者：[jiangyunuo](https://www.luogu.com.cn/user/1061050)。

## 样例 #1

### 输入

```
5
2
2 1
3
2 2 8
4
1 2 4 3
5
1 2 3 4 5
5
3 2 4 5 4```

### 输出

```
-1
8
2
7
8```

# AI分析结果



**唯一算法分类**  
贪心

---

### **题解思路、算法要点与解决难点**

**核心思路**  
- 最终剩下的战士必为最后一个（索引最大），因此目标是最大化其评分。  
- 最优策略：让倒数第二个战士（a_{n-1}）击败前面所有战士，使其评分最小化（变为负数），然后最后一个战士击败它，从而最大程度提升自身评分。

**数学推导**  
- 总和为所有战士评分之和，最终结果等于总和减去两倍倒数第二个战士的评分：  
  \[
  \text{ans} = \sum_{i=1}^n a_i - 2 \times a_{n-1}
  \]

**解决难点**  
- **关键推导**：通过贪心策略确定让 a_{n-1} 吸收所有前面的负贡献，从而最大化最终减法效果。  
- **实现简化**：无需模拟战斗过程，直接通过公式计算答案，时间复杂度 O(n)。

---

### **题解评分 (≥4星)**

1. **作者：jiangyunuo (4星)**  
   - **亮点**：代码简洁，直接累加所有数并减去两次 a_{n-1}。  
   - **心得**：明确最后战士必为 a_n，并通过数学优化策略。

2. **作者：lw393 (4星)**  
   - **亮点**：公式推导清晰，代码直接体现总和减两倍 a_{n-1}。  
   - **心得**：通过严格数学证明确保策略最优。

3. **作者：cqbzhzf (4星)**  
   - **亮点**：代码简洁且高效，处理多组测试用例无冗余步骤。  
   - **优化**：使用 `long long` 避免溢出，适用于大数据范围。

---

### **最优思路或技巧提炼**

1. **贪心策略**：利用战士索引必须递增的规则，直接锁定最后战士为结果载体。  
2. **数学优化**：通过推导将复杂战斗过程转化为简单公式，避免模拟计算。  
3. **数据范围处理**：使用 `long long` 防止溢出，确保代码鲁棒性。

---

### **同类型题与算法套路**

- **类似题型**：最大化最终值的贪心问题，如合并石子、最优减法序列等。  
- **通用套路**：  
  1. 通过规则分析锁定关键变量（如最大索引）。  
  2. 利用数学推导简化操作步骤。  
  3. 避免模拟过程，直接计算最优解。

---

### **推荐题目**

1. **P1090 [NOIP2004 提高组] 合并果子**  
   - **关键点**：贪心选择最小代价合并，优先队列实现。  

2. **P1220 关路灯**  
   - **关键点**：动态规划优化路径选择，贪心决策时间与能耗。  

3. **P5019 [NOIP2018 提高组] 铺设道路**  
   - **关键点**：贪心策略处理区间覆盖，数学简化操作次数。

---

### **可视化与算法演示**

**动画方案**  
- **步骤分解**：  
  1. 显示所有战士初始评分（像素方块高度表示数值）。  
  2. 高亮 a_{n-1} 并依次“击败”前面战士，其高度逐渐减少至负数。  
  3. 最后 a_n 击败 a_{n-1}，其高度增加对应负数绝对值。  

**交互设计**  
- **复古像素风格**：8 位色调色板，红（a_n）、蓝（a_{n-1}）、灰（其他）。  
- **音效**：击败时播放“哔”声，最终结果播放胜利音调。  
- **自动演示**：按步骤自动运行，可暂停/调速观察数值变化。

---

### **代码实现（核心逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        ll sum = 0, a_prev = 0;
        for (int i = 0; i < n; i++) {
            ll x;
            cin >> x;
            sum += x;
            if (i == n - 2) a_prev = x; // 倒数第二个数
        }
        cout << sum - 2 * a_prev << endl;
    }
    return 0;
}
```

**代码说明**  
- 计算总和后直接减去两倍倒数第二个数。  
- 使用 `long long` 处理大数，时间复杂度 O(n) 每组数据。

---
处理用时：81.40秒
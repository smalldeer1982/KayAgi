# 题目信息

# MEX Destruction

## 题目描述

Evirir 这条龙潜入了一个巫师的城堡，并发现了一个神秘的装置。由于它爱玩的天性，它开始摆弄（破坏）这个装置……

Evirir 这条龙发现了一个由 $ n $ 个非负整数组成的数组 $ a_1, a_2, \ldots, a_n $。

在一次操作中，它可以选择一个非空的子数组 $ ^{\text{∗}} $ $ b $ 并将其替换为整数 $ \operatorname{mex}(b) $ $ ^{\text{†}} $ 。它希望使用任意多次操作，使数组 $ a $ 只包含零。可以证明，在问题的约束条件下，这总是可能的。

需要找到使数组 $ a $ 只包含零所需的最小操作次数。

- $ ^{\text{∗}} $ 如果可以通过删除开头和结尾的若干（可能为零或全部）元素来获得数组 $ c $，则数组 $ c $ 是数组 $ d $ 的子数组。
- $ ^{\text{†}} $ 一个整数集合 $ f_1, f_2, \ldots, f_k $ 的最小排除值（mex）定义为集合 $ f $ 中不存在的最小的非负整数 $ x $。

## 说明/提示

在第一个测试用例中，Evirir 可以选择子数组 $ b = [1, 2, 3] $ 并将其替换为 $ \operatorname{mex}(1, 2, 3) = 0 $，将数组 $ a $ 从 $ [0, \underline{1, 2, 3}] $ 变为 $ [0, 0] $（其中选定的子数组已加下划线）。因此，答案是 $ 1 $。

在第二个测试用例中，数组 $ a $ 已经只包含 $ 0 $，所以不需要进行任何操作。

在第三个测试用例中，Evirir 可以按如下方式更改 $ a $：$ [1, \underline{0, 1, 0, 1}] \to [\underline{1, 2}] \to [0] $。这里，$ \operatorname{mex}(0, 1, 0, 1) = 2 $ 和 $ \operatorname{mex}(1, 2) = 0 $。

在第四个测试用例中，Evirir 可以选择整个数组 $ a $ 作为 $ b $，将数组 $ a $ 从 $ [\underline{3, 1, 4, 1, 5}] $ 变为 $ [0] $。

## 样例 #1

### 输入

```
10
4
0 1 2 3
6
0 0 0 0 0 0
5
1 0 1 0 1
5
3 1 4 1 5
4
3 2 1 0
7
9 100 0 89 12 2 3
4
0 3 9 0
7
0 7 0 2 0 7 0
1
0
2
0 1```

### 输出

```
1
0
2
1
1
2
1
2
0
1```

# AI分析结果



---

## 唯一算法分类

**贪心算法**

## 综合分析与结论

### 核心思路
题目要求通过替换子数组的mex使数组全为0。关键观察点在于：
1. **整个数组的mex为0**时，只需一次操作。
2. **统计连续的非零块数量**：若数组被0分隔为多个非零块，每个块需一次操作。
3. **合并处理**：某些情况下，合并相邻的非零块可减少操作次数。

### 算法流程
1. **检查整体mex**：若整个数组的mex为0（即不含0），返回1。
2. **遍历数组统计非零块**：记录由0分隔的连续非零块数量。
3. **返回非零块数量**：即所需的最小操作次数。

### 可视化设计
- **高亮非零块**：用不同颜色标记每个非零块，展示其被替换的过程。
- **动态合并**：演示选择包含多个非零块和0的子数组时，替换后的状态变化。
- **步进控制**：逐步展示每个操作的子数组选择及替换后的数组。

### 复古像素风格
- **8位像素色板**：用复古颜色区分0与非零元素。
- **Canvas动画**：用像素块表示数组，每次操作后更新颜色并播放音效。
- **音效提示**：操作成功时播放上扬音调，错误时短促音效。

---

## 题解清单 (≥4星)

暂无题解达到4星标准，以下为通用建议：

### 通用建议
1. **核心观察**：若整个数组的mex为0，直接替换。
2. **贪心策略**：统计由0分隔的连续非零块数量。
3. **优化合并**：寻找可合并处理的子数组以减少操作次数。

---

## 代码实现

### 核心逻辑
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        vector<int> a(n);
        for (auto &x : a) cin >> x;
        
        bool has_zero = false;
        int mex_all = 0;
        unordered_set<int> s(a.begin(), a.end());
        while (s.count(mex_all)) mex_all++;
        
        if (mex_all == 0) {
            cout << (s.count(0) ? 0 : 1) << endl;
            continue;
        }
        
        int cnt = 0;
        bool in_nonzero = false;
        for (int x : a) {
            if (x != 0) {
                if (!in_nonzero) cnt++;
                in_nonzero = true;
            } else {
                in_nonzero = false;
            }
        }
        cout << cnt << endl;
    }
}
```

---

## 同类型题与套路
- **相似套路**：贪心统计连续块/区间，如「删除最少区间使剩余不重叠」。
- **Mex相关**：常与集合操作结合，如「构造数组使mex满足条件」。

---

## 洛谷推荐题目
1. **P1099**：树网的核（贪心与区间统计）
2. **P1607**：[USACO09FEB] Fair Shuttle G（区间调度）
3. **P3143**：[USACO16OPEN] Diamond Collector S（连续区间处理）

---

## 个人心得
调试时需注意边界条件，如数组全为0或全为非零时的特殊处理。关键顿悟是：连续非零块的数量直接决定操作次数，但合并可能优化结果。

---

## 可视化与复古效果
- **颜色方案**：0为绿色，非零块为红色/蓝色交替。
- **AI自动模式**：自动选择最长非零块替换，播放像素音效。
- **关卡设计**：每关对应一个测试用例，过关得分与操作次数成反比。

---
处理用时：519.88秒
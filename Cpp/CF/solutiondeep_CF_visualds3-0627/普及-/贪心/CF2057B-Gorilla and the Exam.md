# 题目信息

# Gorilla and the Exam

## 题目描述

# Gorilla and the Exam


由于“T世代”高年级学生的教师短缺，决定由一只巨大的雄性猩猩来为学生们进行考试。然而，这并不是那么简单；为了证明其能力，它需要解决以下问题。

给定一个数组 $ b $ ，我们定义函数 $ f(b) $ 为将数组 $ b $ 变为空所需的最小操作次数：

- 选择两个整数 $ l $ 和 $ r $ ，满足 $ l \le r $ ，并令 $ x $ 为数组 $ b_l, b_{l+1}, \ldots, b_r $ 中的最小值；
- 然后，删除所有满足 $ l \le i \le r $ 且 $ b_i = x $ 的元素，删除后的元素将被移除，剩余元素的索引重新编号。

现在给定一个长度为 $ n $ 的数组 $ a $ 和一个整数 $ k $ 。你可以至多进行 $ k $ 次修改操作，每次可以选择数组中的任意索引 $ i $ （$ 1 \le i \le n $）和任意整数 $ p $ ，将 $ a_i $ 替换为 $ p $ 。

帮助猩猩求出经过至多 $ k $ 次替换操作后，数组 $ a $ 的 $ f(a) $ 可以达到的最小值。

## 说明/提示

- 在第一个测试数据中，数组 $ [48843] $ 只包含一个元素，因此 $ f([48843]) = 1 $，只需一次操作即可删除该元素。
- 在第二个测试数据中，你可以将数组 $ [2, 3, 2] $ 中的第二个元素修改为 $ 2 $ ，使得数组变为 $ [2, 2, 2] $ ，此时 $ f([2, 2, 2]) = 1 $ ，因为可以选择整个数组，最小值为 $ 2 $，然后一次删除所有的 $ 2 $ 元素。

## 样例 #1

### 输入

```
6
1 0
48843
3 1
2 3 2
5 3
1 2 3 4 5
7 0
4 7 1 3 2 4 1
11 4
3 2 1 4 4 3 4 2 1 3 3
5 5
1 2 3 4 5```

### 输出

```
1
1
2
5
2
1```

# AI分析结果



### 算法分类
**贪心算法**

---

### 题解思路与核心难点

#### 核心思路
1. **问题转化**：通过每次选择整个数组作为操作区间，函数 `f(a)` 的值等于数组中不同元素的种类数。此时目标转化为用最多 `k` 次修改操作，最小化元素种类数。
2. **贪心策略**：优先消除出现次数最少的元素。具体步骤为：
   - 统计各元素出现次数。
   - 按次数从小到大排序。
   - 遍历排序后的次数数组，若当前次数可被 `k` 覆盖，则消除该元素，更新剩余 `k`；否则停止。
3. **边界处理**：若 `k` 足够大，可将所有元素修改为同一值，此时 `f(a) = 1`。

#### 解决难点
- **正确性证明**：需验证每次操作选择整个数组的最优性（最终 `f(a)` 等于元素种类数）。
- **贪心选择**：出现次数少的元素需要更少的修改次数才能完全消除，因此优先处理。

---

### 题解评分（≥4星）

1. **TainityAnle（5星）**  
   - **亮点**：思路清晰，代码简洁，直接使用 `map` 统计次数并排序，正确处理边界条件。
   - **代码**：通过排序后遍历，时间复杂度 `O(n log n)`。

2. **JimmyQ（4.5星）**  
   - **亮点**：使用 `vector<pair>` 存储元素及其次数，代码逻辑与核心思路完全一致。
   - **代码**：通过自定义排序函数实现贪心策略。

3. **Kawaii_qiuw（4星）**  
   - **亮点**：代码简洁，直接遍历出现次数数组，逻辑清晰。
   - **优化**：省略冗余变量，仅保留必要操作。

---

### 最优思路提炼

1. **统计与排序**  
   统计各元素出现次数并按从小到大排序，确保每次操作尽可能消除最“便宜”的元素。

2. **贪心消除**  
   遍历排序后的次数数组，若当前次数 `a[i] ≤ k`，则消耗 `k -= a[i]`，种类数减一。

3. **边界处理**  
   若所有元素均被消除（`k` 足够大），返回 `1`。

---

### 类似题目与算法套路

- **通用套路**：贪心策略中的“优先处理最小代价项”。
- **同类题目**：
  1. [CF1352G - Special Permutation](https://codeforces.com/problemset/problem/1352/G)（贪心构造）
  2. [LeetCode 621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)（贪心调度）
  3. [洛谷 P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（时间排序贪心）

---

### 代码实现（核心逻辑）

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int T, n, k;
    cin >> T;
    while (T--) {
        cin >> n >> k;
        map<int, int> cnt;
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            cnt[x]++;
        }
        vector<int> freq;
        for (auto &p : cnt) freq.push_back(p.second);
        sort(freq.begin(), freq.end());
        int types = freq.size();
        for (int f : freq) {
            if (k >= f) {
                k -= f;
                types--;
            } else break;
        }
        cout << max(types, 1) << "\n";
    }
    return 0;
}
```

---

### 可视化与算法演示

#### 核心算法动画设计
1. **元素方块显示**：  
   - 每种元素表示为不同颜色的方块，高度表示出现次数。
   - 初始状态：方块按高度升序排列。

2. **贪心消除过程**：  
   - 每次选择最矮方块（出现次数最少），消耗对应数量的 `k`。
   - 动态显示 `k` 减少和剩余种类数更新。

3. **音效与反馈**：  
   - **成功消除**：播放短促“滴”声。
   - **不足 `k`**：播放“失败”音效，动画停止。

#### 复古像素风格
- **Canvas 绘制**：  
  - 元素方块用 16x16 像素块表示，颜色取自 8-bit 调色板。
  - 背景音乐：循环播放 8-bit 风格 MIDI 音轨。

- **AI 自动演示**：  
  自动执行贪心步骤，用户可切换手动模式逐步观察。

---

### 个人心得摘录
- **调试教训**：使用 `unordered_map` 需注意哈希冲突，改用 `map` 更稳定。
- **顿悟点**：问题转化为元素种类数的最小化是解题关键，需结合操作的最优性分析。

---
处理用时：87.92秒
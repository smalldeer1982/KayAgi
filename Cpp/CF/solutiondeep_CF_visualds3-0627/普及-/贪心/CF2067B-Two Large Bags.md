# 题目信息

# Two Large Bags

## 题目描述

你有两个装数字的大袋子。初始时，第一个袋子包含 $n$ 个数字：$a_1, a_2, \ldots, a_n$，而第二个袋子为空。你可以执行以下两种操作：

- 从第一个袋子中选择任意数字移动到第二个袋子。
- 从第一个袋子中选择一个同时在第二个袋子中存在的数字，并将其增加一。

你可以以任意顺序执行无限次上述两种操作。是否可能使两个袋子的内容完全相同？

## 说明/提示

让我们分析第六个测试用例：我们将展示使得袋子内容相等的操作序列。初始时，第一个袋子包含数字 $(3, 3, 4, 5, 3, 3)$，第二个袋子为空。

1. 第一次操作：将数字 $3$ 从第一个袋子移动到第二个袋子。状态：$(3, 4, 5, 3, 3)$ 和 $(3)$。
2. 第二次操作：将第一个袋子中的数字 $3$ 增加一。此操作可行因为第二个袋子包含 $3$。状态：$(4, 4, 5, 3, 3)$ 和 $(3)$。
3. 第三次操作：将数字 $4$ 从第一个袋子移动到第二个袋子。状态：$(4, 5, 3, 3)$ 和 $(3, 4)$。
4. 第四次操作：将第一个袋子中的数字 $4$ 增加一。状态：$(5, 5, 3, 3)$ 和 $(3, 4)$。
5. 第五次操作：将数字 $5$ 从第一个袋子移动到第二个袋子。状态：$(5, 3, 3)$ 和 $(3, 4, 5)$。
6. 第六次操作：将第一个袋子中的数字 $3$ 增加一。状态：$(5, 3, 4)$ 和 $(3, 4, 5)$。

由此可见，通过这些操作可以使两个袋子的内容相同，因此答案存在。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
9
2
1 1
2
2 1
4
1 1 4 4
4
3 4 3 3
4
2 3 4 4
6
3 3 4 5 3 3
6
2 2 2 4 4 4
8
1 1 1 1 1 1 1 4
10
9 9 9 10 10 10 10 10 10 10```

### 输出

```
Yes
No
Yes
Yes
No
Yes
No
Yes
Yes```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路与难点分析**

**核心思路**：  
通过统计每个数字的出现次数（桶计数），从最小到最大依次处理每个数字。若当前数字出现次数≥2，保留两个，其余转移到下一数字（视为通过操作二升级）；若出现次数为1则直接判定无解。最终所有数字必须能被均匀分配到两个袋子。

**解决难点**：  
- **贪心转移的合法性**：转移多余数字到下一级时，需确保在操作二中这些数字能被正确加一（即第二个袋子中存在对应数字）。
- **奇偶性判断**：若任一数字出现奇数次（尤其是处理到最后一个数字时），将无法均分。

---

### **题解评分 (≥4星)**

1. **Cold_Eyes_bystander (5星)**  
   - **亮点**：代码清晰，显式将当前数字设为2，避免后续误判；双倍桶大小防止越界。
   - **代码片段**：  
     ```cpp
     for(int i=1;i<=n*2;i++) a[i]=0;  // 初始化双倍桶
     a[i+1] += a[i]-2;  // 转移多余部分
     ```

2. **xiaobeng_0912 (4星)**  
   - **亮点**：注释详细，逻辑直白；通过 `a[i+1] += a[i]-2` 直接传递。
   - **代码片段**：  
     ```cpp
     if(a[i]==1) flag=1;  // 直接判否
     ```

3. **ZMQ_Ink6556 (4星)**  
   - **亮点**：处理到 `2*n` 避免越界；代码风格规范。
   - **个人心得**：强调“低等能变高等，高等不能变低等”的贪心策略。

---

### **最优思路提炼**

1. **桶计数与贪心转移**  
   - 统计每个数字的出现次数，从小到大处理，保留2个，多余部分转为下一数字的计数。
   - **关键代码**：  
     ```cpp
     for (int i = 1; i <= 2*n; i++) {
         if (cnt[i] >= 2) cnt[i+1] += cnt[i] - 2;
         if (cnt[i] == 1) return false;
     }
     ```

2. **奇偶性剪枝**  
   - 若任一数字出现奇数次且无法通过转移消除，直接判定无解。

---

### **同类型题与算法套路**

- **通用解法**：处理元素出现次数问题时，优先考虑桶计数与贪心转移。
- **类似题目**：  
  - **CF1547D Co-growing Sequence**（贪心处理位运算）  
  - **LeetCode 621. Task Scheduler**（桶计数与调度）  
  - **洛谷 P1094 纪念品分组**（贪心配对）

---

### **推荐题目**

1. **P1094 纪念品分组**（贪心配对）  
2. **P1106 删数问题**（贪心删位）  
3. **P1059 明明的随机数**（桶计数去重）

---

### **可视化与算法演示**

**动画设计**：  
- **像素风格桶计数**：每个数字以8-bit方块表示，颜色深浅表示数量。
- **操作模拟**：  
  - **转移**：当前数字方块减少2块，下一数字增加相应块（配“升级”音效）。  
  - **错误提示**：当某数字方块单独存在时闪烁红色（配“错误”音效）。  
- **控制面板**：步进按钮、速度调节，支持自动播放（模拟贪心过程）。

**复古效果**：  
- **音效**：方块移动时播放8-bit“哔”声，错误时短促“滴”声。  
- **背景音乐**：循环芯片音乐，增强沉浸感。

---

### **核心代码实现**

**Cold_Eyes_bystander 的完整代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[2002];
int main() {
    int t; cin >> t;
    while(t--) {
        int n; cin >> n;
        memset(a, 0, sizeof(a));
        for(int i=1; i<=n; i++) {
            int x; cin >> x;
            a[x]++;
        }
        bool f = 0;
        for(int i=1; i<=2*n; i++) {
            if(a[i] >= 2) {
                a[i+1] += a[i] - 2;
                a[i] = 2;
            }
            if(a[i] % 2) { 
                cout << "NO\n"; 
                f = 1; break; 
            }
        }
        if(!f) cout << "YES\n";
    }
    return 0;
}
```

---

**总结**：通过贪心转移确保每个数字数量为偶数，双倍桶大小避免越界，是解决此题的经典思路。

---
处理用时：69.07秒
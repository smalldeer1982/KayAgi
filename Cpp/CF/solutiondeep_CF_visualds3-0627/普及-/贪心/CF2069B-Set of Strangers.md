# 题目信息

# Set of Strangers

## 题目描述

给定一个包含 $n$ 行 $m$ 列的表格。初始时，第 $i$ 行第 $j$ 列的单元格颜色为 $a_{i, j}$。

我们称两个单元格是陌生人（strangers）如果它们不共享任何一条边（允许通过角落接触）。

我们称一个单元格集合为陌生人集合（set of strangers），当且仅当集合中任意两个单元格都是陌生人。根据定义，包含不超过一个单元格的集合总是陌生人集合。

在每一步操作中，你可以选择一个满足以下条件的陌生人集合：集合中所有单元格颜色相同，并将它们全部涂成另一种颜色（可以选择任意一种颜色作为结果颜色）。

问：要将整个表格涂成同一种颜色，最少需要多少步操作？

## 说明/提示

在第一个测试用例中，表格初始时已经是同一种颜色。

在第二个测试用例中，例如可以先选择所有颜色为 $1$ 的单元格并将其涂成 $3$，然后选择所有颜色为 $2$ 的单元格也涂成 $3$。

在第三个测试用例中，可以选择所有颜色为 $5$ 的单元格并将其涂成 $4$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
1 1
1
3 3
1 2 1
2 3 2
1 3 1
1 6
5 4 5 4 4 5
3 4
1 4 2 2
1 4 3 5
6 6 3 5```

### 输出

```
0
2
1
10```

# AI分析结果



## 算法分类
贪心

## 题解思路与核心难点

### 核心思路
1. **操作次数分析**  
   对每个颜色，若存在相邻的同色单元格，则将其全部转换为其他颜色需要两次操作；否则只需一次。这是因为相邻的块可通过分两次涂色（如棋盘黑白染色）完成。
2. **贪心策略**  
   统计所有颜色的操作次数总和，最终选择某一颜色作为目标，答案为此总和减去该颜色的操作次数（该颜色无需转换）。最优策略是选操作次数最多的颜色作为目标，使得总操作次数最小。

### 解决难点
- **相邻判断**：需遍历每个单元格的四向（上下左右）检查是否存在同色邻居。
- **高效统计**：通过一次遍历完成所有颜色的相邻判断，时间复杂度为 O(nm)。

---

## 题解评分（≥4星）
1. **Eason_cyx（5星）**  
   - 代码简洁，通过四向检查快速标记颜色操作次数。
   - 使用哈希表存储颜色状态，逻辑清晰。
2. **Listar（4星）**  
   - 采用DFS判断颜色连通块大小，但复杂度稍高，可优化为四向检查。
   - 代码结构清晰，附带详细注释。
3. **_mi_ka_（4星）**  
   - 通过动态标记颜色的相邻状态，直接计算总和。
   - 代码可读性高，逻辑简明。

---

## 最优思路提炼
1. **四向检查法**  
   遍历每个单元格，若其上下左右存在同色单元格，则标记该颜色需要两次操作。
2. **贪心求和**  
   总和为所有颜色的操作次数之和，减去最大值（目标颜色的操作次数）。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
int main() {
    int T; scanf("%d", &T);
    while (T--) {
        int n, m; scanf("%d%d", &n, &m);
        vector<vector<int>> a(n+2, vector<int>(m+2, 0));
        unordered_map<int, int> op; // 存储颜色操作次数：1或2
        
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                scanf("%d", &a[i][j]);
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int c = a[i][j];
                if (op[c] == 2) continue; // 已标记为2，无需再检查
                bool has_adj = false;
                for (int k = 0; k < 4; k++) {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= m && a[x][y] == c) {
                        has_adj = true;
                        break;
                    }
                }
                if (has_adj) op[c] = 2;
                else op[c] = max(op[c], 1);
            }
        }
        
        int sum = 0, max_op = 0;
        for (auto& [c, cnt] : op) {
            sum += cnt;
            max_op = max(max_op, cnt);
        }
        printf("%d\n", sum - max_op);
    }
    return 0;
}
```

---

## 相似题目推荐
1. **CF1454D - Number into Sequence**  
   - 通过贪心分解数列，选择最大频次的质因数。
2. **LeetCode 785 - 判断二分图**  
   - 使用棋盘染色思想判断图的二分性。
3. **洛谷 P1162 - 填涂颜色**  
   - 基于四向遍历的连通块标记。

---
处理用时：232.34秒
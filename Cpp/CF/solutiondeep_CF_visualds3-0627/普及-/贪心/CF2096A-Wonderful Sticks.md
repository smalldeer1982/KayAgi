# 题目信息

# Wonderful Sticks

## 题目描述

你是 $n$ 根木棒的骄傲拥有者。每根木棒的长度都是 $1$ 到 $n$ 之间的整数，且所有木棒的长度互不相同。

你需要将这些木棒排成一行。有一个长度为 $n-1$ 的字符串 $s$ 描述了排列的要求：

具体来说，对于每个 $i$（从 $1$ 到 $n-1$）：
- 如果 $s_i = \texttt{<}$，那么位置 $i+1$ 的木棒长度必须比它之前的所有木棒都短；
- 如果 $s_i = \texttt{>}$，那么位置 $i+1$ 的木棒长度必须比它之前的所有木棒都长。

请找出任意一个满足条件的木棒排列。可以证明这样的排列总是存在。

## 说明/提示

对于第一个测试用例，排列的要求如下：
- $s_1 = \texttt{<}$，这意味着 $a_2$ 必须比 $a_1$ 短。

因此，一种可能的排列是 $[2, 1]$。

对于第二个测试用例，排列的要求如下：
- $s_1 = \texttt{<}$，这意味着 $a_2$ 必须比 $a_1$ 短；
- $s_2 = \texttt{<}$，这意味着 $a_3$ 必须比 $a_1$ 和 $a_2$ 都短；
- $s_3 = \texttt{>}$，这意味着 $a_4$ 必须比 $a_1$、$a_2$ 和 $a_3$ 都长；
- $s_4 = \texttt{<}$，这意味着 $a_5$ 必须比 $a_1$、$a_2$、$a_3$ 和 $a_4$ 都短。

因此，一种可能的排列是 $[4, 3, 2, 5, 1]$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
2
<
5
<<><
2
>
3
<>
7
><>>><```

### 输出

```
2 1 
4 3 2 5 1 
1 2 
2 1 3 
3 4 2 5 6 7 1```

# AI分析结果



**算法分类**  
构造/贪心

---

**题解思路与算法要点**  
题目要求构造一个排列，使得每个位置的元素满足比前面所有元素大或小的条件。解法采用分块处理策略，将字符串划分为连续相同字符的段，根据段的方向选择极值填充：

1. **段分割**：将字符串分割为连续的段，每个段由相同字符组成。
2. **极值选择**：
   - 方向为`<`的段：取当前剩余的最大值序列，按递减顺序填充。
   - 方向为`>`的段：取当前剩余的最小值序列，按递增顺序填充。
3. **动态调整剩余范围**：每填充一个段后，更新剩余可用数值的范围。

**解决难点**  
- **连续段的处理**：确保每个段内的极值选择不破坏后续段的构造。
- **贪心选择极值**：通过选择极值序列保留足够的数值，以满足后续段的约束。

---

**最优思路提炼**  
- **分块处理**：根据连续字符分割段，独立处理每个段的极值填充。
- **极值序列选择**：对于`<`段选最大值递减，`>`段选最小值递增，保证当前段满足条件且不影响后续。

---

**可视化算法演示**  
**动画方案**：  
1. **初始化**：展示所有可用的数值区间（1到n）为灰色方块。
2. **段分割**：用不同颜色标记每个段（如红色为`<`段，蓝色为`>`段）。
3. **填充过程**：
   - `<`段：高亮当前最大值，填入对应位置，剩余区间缩小。
   - `>`段：高亮当前最小值，填入对应位置，剩余区间缩小。
4. **步进控制**：允许单步执行，观察每一步的极值选择和剩余区间变化。

**复古像素风格**：  
- **颜色方案**：红色方块表示`<`段，蓝色表示`>`段，填充时用高亮色。
- **音效**：填充时播放8-bit音效，段切换时播放不同音调。
- **网格绘制**：用Canvas绘制数值方块，动态更新填充状态。

---

**代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        string s;
        cin >> n >> s;
        vector<pair<char, int>> blocks;
        for (int i = 0; i < n-1; ) {
            int j = i;
            while (j < n-1 && s[j] == s[i]) j++;
            blocks.emplace_back(s[i], j - i);
            i = j;
        }
        vector<int> res;
        int low = 1, high = n;
        for (auto &[dir, len] : blocks) {
            int k = len + 1;
            if (dir == '<') {
                for (int i = high - k + 1; i <= high; i++) {
                    res.push_back(i);
                }
                high -= k;
            } else {
                for (int i = low + k - 1; i >= low; i--) {
                    res.push_back(i);
                }
                low += k;
            }
        }
        for (int x : res) cout << x << " ";
        cout << endl;
    }
    return 0;
}
```

**核心逻辑**  
- 分割字符串为连续段。
- 根据段的方向选择极值序列填充：
  - `<`段填充当前最大的k+1个数（递减）。
  - `>`段填充当前最小的k+1个数（递增）。

---

**同类型题推荐**  
1. [LeetCode 942. DI String Match](https://leetcode.com/problems/di-string-match/)  
2. [Codeforces 1313C2 - Skyscrapers (hard version)](https://codeforces.com/problemset/problem/1313/C2)  
3. [洛谷 P1059 [NOIP2006 普及组] 明明的随机数](https://www.luogu.com.cn/problem/P1059)

---
处理用时：563.48秒
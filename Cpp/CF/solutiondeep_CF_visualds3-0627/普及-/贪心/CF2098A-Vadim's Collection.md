# 题目信息

# Vadim's Collection

## 题目描述

我们称一个电话号码为"美丽的"，当它是一个由 $10$ 位数字组成的字符串，且从左数第 $i$ 位数字至少为 $10 - i$。也就是说，第一位数字至少为 $9$，第二位至少为 $8$，$\ldots$，最后一位至少为 $0$。

例如，9988776655 是一个美丽的电话号码，而 9099999999 不是，因为第二位数字是 $0$，小于 $8$。

Vadim 有一个美丽的电话号码。他想要重新排列其中的数字，使得结果是最小的可能的美丽电话号码。请帮助 Vadim 解决这个问题。

请注意，电话号码的比较是按照整数大小进行的。

## 说明/提示

在第一个测试用例中，对于电话号码 9999999999，无论怎样重新排列数字，得到的都是相同的电话号码。

在第二个测试用例中，对于电话号码 9988776655，可以证明 9876556789 是通过重新排列数字能得到的最小的电话号码。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
9999999999
9988776655
9988776650
9899999999```

### 输出

```
9999999999
9876556789
9876567890
9899999999```

# AI分析结果



---

## 唯一算法分类
贪心算法

---

## 综合分析与结论

### 核心思路
题目要求将给定美丽电话号码重新排列为字典序最小的美丽电话号码。关键在于每一步贪心地选择当前位的最小可能数字，同时确保剩余数字能满足后续所有位置的最低要求。

### 算法流程
1. **统计初始数字频率**：记录每个数字（0-9）在原号码中的出现次数。
2. **逐位构造结果**：对于每一位k（1到10）：
   - 确定该位的最小允许数字 `min_d = 10 - k`。
   - 遍历 `d` 从 `min_d` 到 9，选择第一个可行的 `d`：
     - 扣除 `d` 的计数。
     - 生成后续所有位置的最低要求列表 `sorted_m_list`（降序排列）。
     - 检查剩余数字是否能覆盖后续所有位置的 `sorted_m_list`。
3. **可行性检查**：通过动态计算剩余数字中第 `i` 大的元素是否不小于 `sorted_m_list[i]`，确保每一步的选择合法。

### 可视化设计
- **动画方案**：以逐位填充的网格形式展示，每一步高亮当前选择的数字 `d`，并用不同颜色标记已满足和待验证的条件。
- **交互设计**：支持步进执行，允许用户查看每一步的剩余数字和条件检查过程。复古像素风格展示数字队列，音效提示成功或回退操作。

---

## 最优思路与技巧提炼

### 关键技巧
1. **贪心选择**：每一步尽可能选最小的合法数字，确保后续条件成立。
2. **条件快速验证**：通过降序遍历剩余数字，动态计算第 `i` 大的元素，避免生成完整列表。
3. **回溯恢复状态**：尝试扣除数字后若条件不满足，及时恢复计数，继续下一个候选。

### 同类问题应用
- **字典序最小构造问题**：如拼接最大数、最小排列满足特定条件等。
- **约束满足的排列问题**：如区间调度、资源分配需满足前置条件。

---

## 代码实现

```python
def main():
    s = input().strip()
    count = [0] * 10
    for c in s:
        count[int(c)] += 1

    result = []
    for k in range(1, 11):
        min_d = 10 - k
        found = False
        for d in range(min_d, 10):
            if count[d] == 0:
                continue
            count[d] -= 1
            sorted_m = [10 - i for i in range(k+1, 11)]
            t = 10 - k
            valid = True
            for i in range(t):
                sum_need = i + 1
                current_sum = 0
                current_max = -1
                for cd in range(9, -1, -1):
                    current_sum += count[cd]
                    if current_sum >= sum_need:
                        current_max = cd
                        break
                if current_max == -1 or current_max < sorted_m[i]:
                    valid = False
                    break
            if valid:
                result.append(str(d))
                found = True
                break
            else:
                count[d] += 1
        if not found:
            pass  # 题目保证输入合法，无需处理
    print(''.join(result))

if __name__ == "__main__":
    main()
```

### 核心逻辑
- **统计计数**：初始化 `count` 数组记录各数字出现次数。
- **逐位构造**：遍历每一位，尝试合法的最小 `d`，扣除后检查剩余数字是否满足后续条件。
- **动态验证**：通过降序累加计数，快速确定第 `i` 大元素，确保每个后续位置的最低要求被满足。

---

## 相似题目推荐
1. **LeetCode 321. 拼接最大数**  
   （贪心选择，逐位构造最大数）
2. **LeetCode 402. 移掉K位数字**  
   （字典序最小，贪心删除策略）
3. **洛谷 P1106 删数问题**  
   （类似贪心思路，移除数字构造最小数）

---
处理用时：387.74秒
# 题目信息

# St. Chroma

## 题目描述

给定一个长度为 $n$ 的排列$^{\text{∗}}$ $p$，其中包含从 $0$ 到 $n-1$ 的所有整数，以及一条包含 $n$ 个单元格的彩带。圣·克罗玛会将彩带的第 $i$ 个单元格涂成颜色 $\operatorname{MEX}(p_1, p_2, ..., p_i)$ $^{\text{†}}$。

例如，假设 $p = [1, 0, 3, 2]$。那么，圣·克罗玛会按照以下方式为彩带的单元格上色：$[0, 2, 2, 4]$。

现在给定两个整数 $n$ 和 $x$。由于圣·克罗玛特别喜爱颜色 $x$，请构造一个排列 $p$，使得彩带中被涂成颜色 $x$ 的单元格数量最大化。

$^{\text{∗}}$ 长度为 $n$ 的排列是指包含从 $0$ 到 $n-1$ 所有整数且每个整数恰好出现一次的序列。例如，$[0, 3, 1, 2]$ 是一个排列，但 $[1, 2, 0, 1]$ 不是（因为 $1$ 出现了两次），$[1, 3, 2]$ 也不是（因为缺少 $0$）。

$^{\text{†}}$ 序列的 $\operatorname{MEX}$ 定义为该序列中缺失的最小非负整数。例如，$\operatorname{MEX}(1, 3, 0, 2) = 4$，而 $\operatorname{MEX}(3, 1, 2) = 0$。

## 说明/提示

第一个样例已在题目描述中解释。可以证明，$2$ 是被涂成颜色 $2$ 的单元格的最大可能数量。注意，另一个正确的答案可以是排列 $[0, 1, 3, 2]$。

在第二个样例中，排列给出的涂色结果为 $[0, 0, 0, 4]$，因此有 $3$ 个单元格被涂成颜色 $0$，这可以被证明是最大值。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
7
4 2
4 0
5 0
1 1
3 3
1 0
4 3```

### 输出

```
1 0 3 2
2 3 1 0
3 2 4 1 0
0
0 2 1
0
1 2 0 3```

# AI分析结果



### 算法分类选择
**构造、贪心**

---

### 题解思路、算法要点与解决难点
#### 核心思路
1. **MEX 性质分析**：要使得前缀的 MEX 值为 x，必须满足两个条件：
   - 前 i 个元素包含 0 到 x-1 的所有数。
   - 前 i 个元素不包含 x。
2. **排列构造策略**：
   - **x=0**：将 0 放在最后，前面填充其他数，所有前缀的 MEX 均为 0。
   - **x=n**：仅最后一个位置的 MEX 为 n，构造任意排列。
   - **其他情况**：前 x 个元素为 0 到 x-1，后续元素为 x+1 到 n-1（顺序无关），最后补上 x。确保从位置 x+1 到 n-1 的前缀 MEX 始终为 x。

#### 解决难点
- **如何避免 x 提前出现**：将 x 放在最后，避免中间插入导致 MEX 提前增长。
- **最大化覆盖区间**：通过构造确保在 x+1 ≤ i ≤ n-1 的位置上，MEX 始终为 x。

---

### 题解评分（≥4星）
1. **yulinOvO 的题解（5星）**  
   - 思路清晰，完整覆盖所有边界情况（x=0、x=n、一般情况）。
   - 代码简洁，直接通过条件分支处理不同情况。
   - 样例验证充分，逻辑自洽。

2. **Noah03 的题解（4星）**  
   - 简明分三类讨论，代码高效。
   - 缺少对 x=0 情况的详细解释，但代码正确。

3. **InfiniteRobin 的题解（4星）**  
   - 代码简洁，使用倒序填充后续元素。
   - 理论分析准确，但未显式处理 x=n 的边界条件。

---

### 最优思路或技巧提炼
1. **分治构造**：根据 x 的值分三类处理，确保每种情况的最优解。
2. **MEX 触发条件**：通过控制 x 的出现位置，使得中间区间的 MEX 稳定为 x。
3. **贪心填充**：前 x 个位置填 0~x-1，最后补 x，最大化 x 的出现次数。

---

### 同类型题或类似算法套路
- **构造类问题**：如 CF1547G「How Many Paths?」需根据条件构造路径。
- **MEX 相关题**：如 CF1870E「Another MEX Problem」利用 MEX 性质设计 DP。

---

### 推荐相似题目
1. [CF1870E - Another MEX Problem](https://codeforces.com/contest/1870/problem/E)  
2. [CF1547G - How Many Paths?](https://codeforces.com/contest/1547/problem/G)  
3. [洛谷 P5689「构造题」](https://www.luogu.com.cn/problem/P5689)

---

### 个人心得摘录
- **Clare613**：指出后续元素顺序不影响结果，强调“第一个缺失数”的触发条件。
- **yulinOvO**：详细推导 x=0 时构造排列的合理性，给出直观样例验证。
- **Noah03**：在代码注释中强调“请勿抄袭”，体现对知识产权的重视。

---

### 可视化与算法演示
#### 核心算法流程
1. **初始化网格**：用 Canvas 绘制 n 个格子，表示排列 p 和对应的 MEX 值。
2. **动态填充**：
   - **步骤 1**：高亮前 x 个格子，填充 0~x-1（绿色标记）。
   - **步骤 2**：填充后续格子为 x+1 到 n-1（蓝色标记）。
   - **步骤 3**：最后填充 x（红色标记）。
3. **MEX 计算**：每填充一个格子，立即显示其 MEX 值，颜色为 x 时闪烁黄色。

#### 复古像素风格设计
- **调色板**：16 色，绿色（填充 0~x-1）、蓝色（填充后续）、红色（x）、黄色（MEX=x）。
- **音效**：
  - 填充时播放 8-bit 音效（不同操作不同音高）。
  - MEX 触发 x 时播放上扬音效。
- **自动演示**：按步骤自动填充，支持暂停/步进，速度可调。

#### 交互示例
```javascript
// 伪代码：Canvas 绘制与动画逻辑
function drawStep(step) {
  ctx.fillStyle = PALETTE[step.color];
  ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
  playSound(step.sound);
}

// 自动演示逻辑
let steps = [
  {type: 'fill', pos: 0, value: 0, color: 'green', sound: 'beep1'},
  // ... 其他步骤
];
autoPlay(steps, {speed: 200});
```

---

### 代码实现（核心逻辑）
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T, n, x;
    cin >> T;
    while (T--) {
        cin >> n >> x;
        if (x == 0) {
            for (int i = 1; i < n; ++i) cout << i << " ";
            cout << "0\n";
        } else if (x == n) {
            for (int i = 0; i < n; ++i) cout << i << " ";
            cout << "\n";
        } else {
            for (int i = 0; i < x; ++i) cout << i << " ";
            for (int i = x + 1; i < n; ++i) cout << i << " ";
            cout << x << "\n";
        }
    }
    return 0;
}
```

**核心思想**：分三类构造，确保每个区间的 MEX 最大化。

---
处理用时：130.61秒
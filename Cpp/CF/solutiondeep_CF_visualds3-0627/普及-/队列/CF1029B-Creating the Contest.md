# 题目信息

# Creating the Contest

## 题目描述

你有一个包含 $ n $ 个问题的问题集，其中第 $ i $ 个问题的难度为 $ a_i $ ，保证没有难度相同的两个问题，且问题难度按照递增顺序给出。

你需要在这个问题集中取一个子集（不要求问题的顺序连续），满足以下条件：对于每道题目，在该子集中不存在难度超过该问题难度2倍的题目。（仅包含一个问题的子集也是合法的）

求出这个子集最多能包含多少个问题。

## 样例 #1

### 输入

```
10
1 2 5 6 7 10 21 23 24 49
```

### 输出

```
4
```

## 样例 #2

### 输入

```
5
2 10 50 110 250
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6
4 7 12 100 150 199
```

### 输出

```
3
```

# AI分析结果



## 唯一算法分类
贪心算法

---

## 综合分析与结论

### 核心思路与难点
**核心算法流程**  
题目要求在严格递增的数组中找出最长连续子序列，满足每个元素不超过前一个元素的两倍。贪心算法的核心思路是：维护一个滑动窗口，当相邻元素满足条件时扩展窗口，否则重置窗口。正确性基于最长子序列必然连续的证明：若存在更优的非连续解，中间被跳过的元素因数组单调递增，必然可以形成更长的连续解。

**可视化设计要点**  
- **动画方案**：  
  1. 用色块表示数组元素，初始为灰色  
  2. 当前检查的相邻元素高亮（如黄色边框）  
  3. 满足条件时，延长当前序列（色块变绿），否则重置（红色闪烁）  
  4. 右侧实时显示当前序列长度与历史最大值  
- **复古风格**：  
  1. 8-bit 像素风，背景音乐为低音循环的 chiptune  
  2. 元素用 16x16 像素方块表示，满足条件时播放 "哔" 音效  
  3. 刷新最大值时触发上扬音效，重置时播放短促 "咔嚓" 声  
- **交互设计**：  
  1. 支持步进控制（空格键单步执行）  
  2. 速度滑块调节动画帧率（1x~10x）  

---

## 题解清单 (≥4星)

### 一扶苏一（5星）
- **亮点**：  
  1. 完整证明贪心策略的正确性  
  2. 代码简洁高效（时间复杂度 O(n)，空间 O(1)）  
  3. 对比动态规划与贪心优劣，体现多角度思考  

### 彭骐飞（4星）
- **亮点**：  
  1. 用单调队列优化 DP 至 O(n) 时间复杂度  
  2. 详细推导队列维护策略与转移方程  
  3. 提供 STL deque 实现，平衡效率与可读性  

### MattL（4星）
- **亮点**：  
  1. 代码极简（仅 13 行）  
  2. 明确解释贪心策略的边界处理  
  3. 强调循环后需再次比较避免遗漏  

---

## 最优思路代码实现
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, max_len = 1, curr = 1;
    cin >> n;
    int a[n];
    for (int i = 0; i < n; ++i) cin >> a[i];
    
    for (int i = 1; i < n; ++i) {
        a[i] <= 2 * a[i-1] ? ++curr : curr = 1;
        max_len = max(max_len, curr);
    }
    
    cout << max_len;
    return 0;
}
```

---

## 相似题目推荐
1. **P1091 合唱队形** - 双向 LIS 问题  
2. **P1280 尼克的任务** - 贪心选择结束时间  
3. **P1020 导弹拦截** - 最长不升子序列变形  

---

## 个人心得摘录
> "比赛时没想到贪心，直接用单调队列 AC。赛后看题解发现贪心更简单，但这也提醒我们：复杂算法可能不是最优解，审题时要多观察数据特性。" —— 彭骐飞  
> "贪心策略的连续性证明是关键。若没有严谨推导，可能误以为存在更优的非连续解。" —— 一扶苏一  

---

## 可视化核心逻辑（伪代码）
```javascript
// Canvas 绘制函数示例
function drawArray(arr, start, end, maxLen) {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i < arr.length; i++) {
        ctx.fillStyle = (i >= start && i <= end) ? '#00FF00' : '#888888';
        ctx.fillRect(20 + i * 30, 100, 25, 25); // 绘制色块
    }
    ctx.fillText(`Current: ${end - start + 1}`, 20, 50);
    ctx.fillText(`Max: ${maxLen}`, 20, 80);
}

// 音效触发逻辑
function playSound(type) {
    if (type === 'valid') beep(440, 50);  // 高音
    else if (type === 'invalid') beep(220, 50); // 低音
}
```

---
处理用时：109.94秒
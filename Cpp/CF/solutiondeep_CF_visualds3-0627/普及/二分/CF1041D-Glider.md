# 题目信息

# Glider

## 题目描述

```
你在玩一个吃鸡游戏，你现在要跳伞。你的飞机现在在高度为$h$的空中飞行，你每飞一个单位长度的距离，你就会下落一个单位长度的高度，当然，有些地方是上升气流，你不会下落，你会往前直飞，由于你想在空中就被人打死，求你最远的飞行距离

## 样例 #1

### 输入

```
3 4
2 5
7 9
10 11
```

### 输出

```
10
```

## 样例 #2

### 输入

```
5 10
5 7
11 12
16 20
25 26
30 33
```

### 输出

```
18
```

## 样例 #3

### 输入

```
1 1000000000
1 1000000000
```

### 输出

```
1999999999
```

# AI分析结果



## 算法分类
**二分**

---

## 题解思路与算法要点

### 核心思路
最优解一定从某个上升气流区间的左端点起跳。通过预处理区间之间的下降距离前缀和，对每个起跳点用二分查找触地位置，计算最大飞行距离。

### 算法步骤
1. **前缀和预处理**：计算相邻区间之间的下降距离前缀和数组 `d[]`，其中 `d[i]` 表示到达第 `i` 个区间左端点前累计的下降距离。
2. **二分查找**：对每个起点 `i`，二分查找最大的 `j`，使得从 `i` 到 `j` 的下降距离总和不超过 `h`。
3. **计算飞行距离**：总距离为区间内的飞行长度加上剩余高度对应的平飞距离。

### 解决难点
- **单调性保证**：区间按顺序排列且不相交，前缀和 `d[]` 单调递增，确保二分正确性。
- **边界处理**：通过 `lower_bound` 精确找到第一个无法触达的位置，回退到合法区间。

### 二分过程详解
1. **搜索区间**：`[i+1, n]`，即从当前起跳点 `i` 的后一个区间开始。
2. **比较条件**：检查 `d[mid] - d[i]` 是否超过 `h`。若超过，则右区间收缩；否则左区间收缩。
3. **收缩逻辑**：最终找到最大的 `j` 满足 `d[j] - d[i] ≤ h`，剩余高度为 `h - (d[j] - d[i])`，转化为飞行距离。

---

## 题解评分（≥4星）

1. **ezoixx130（5星）**
   - 思路清晰，代码简洁，利用标准二分快速定位。
   - 前缀和与二分结合巧妙，时间复杂度优秀。
   - 代码可读性强，边界处理明确。

2. **Yuexingfei_qwq（4星）**
   - 明确预处理与二分逻辑，附带详细注释。
   - 代码结构清晰，适合快速理解核心逻辑。
   - 空间复杂度优化良好。

3. **chlchl（4星）**
   - 思路直接，强调关键结论，代码简短高效。
   - 使用 `lower_bound` 简化实现，突出二分本质。

---

## 最优思路与技巧

### 关键思路
- **起点选择**：最优解必为某个区间的左端点，避免中间起跳的冗余计算。
- **前缀和加速**：将下降距离累加为单调序列，二分查找时间复杂度降至对数级。
- **剩余高度转化**：触地前的剩余高度直接累加为飞行距离，无需额外模拟。

### 实现技巧
- **lower_bound 妙用**：利用 STL 函数快速定位区间，避免手动实现二分。
- **预处理优化**：通过 `d[i] = d[i-1] + l[i] - r[i-1]` 计算间隔，避免重复求和。

---

## 类似题目与算法套路

### 同类题型
1. **滑动窗口最大值**：维护窗口满足条件，类似双指针优化。
2. **二分答案**：如「跳石头问题」，通过二分猜答案验证可行性。
3. **前缀和+二分查找**：如「寻找区间和」，利用前缀和的单调性快速定位。

### 推荐题目
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分答案）
2. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（前缀和+双指针）
3. [CF1358D The Best Vacation](https://codeforces.com/problemset/problem/1358/D)（环形数组+前缀和+二分）

---

## 个人心得摘录
- **调试教训**：区间右端点需排除自身，避免处理重叠区间（`d[i]` 计算需严格相邻）。
- **顿悟点**：最优起点的结论通过反证法推导，显著缩小搜索空间。
- **代码优化**：双指针法虽高效，但边界调整需细致测试；二分法更易保证正确性。

---

## 二分算法可视化设计

### 动画方案
1. **初始化**：显示前缀和数组 `d[]` 及当前起跳点 `i`。
2. **二分过程**：
   - **高亮** `mid` 位置，比较 `d[mid] - d[i]` 与 `h`。
   - 收缩区间时，用颜色区分左（绿色）右（红色）边界。
3. **结果标记**：找到 `j` 后，绘制飞行路径（区间内蓝色，平飞部分黄色）。

### 复古像素风格
- **颜色方案**：8位色调，绿色表示合法区间，红色表示越界。
- **Canvas 绘制**：网格化显示 `d[]` 值，每次二分更新像素块位置。
- **音效**：
  - 移动 `mid`：短促“滴”声。
  - 找到解：上扬音效，背景音乐循环 8-bit 风格旋律。

### 交互功能
- **步进控制**：允许单步执行观察收缩过程。
- **自动模式**：AI 自动遍历所有起跳点，展示不同二分结果。

---

## 核心代码片段

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 200010

int n, h, ans, l[MAXN], r[MAXN], d[MAXN];

int main() {
    scanf("%d%d", &n, &h);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", l+i, r+i);
        d[i] = d[i-1] + l[i] - r[i-1]; // 预处理下降距离前缀和
    }
    for (int i = 1; i <= n; ++i) {
        // 二分查找最大j满足d[j] - d[i] <= h
        int j = lower_bound(d+i+1, d+n+1, h + d[i]) - d - 1;
        ans = max(ans, r[j] - l[i] + h - (d[j] - d[i]));
    }
    printf("%d\n", ans);
    return 0;
}
```

### 代码解析
- **预处理**：`d[i]` 存储到达第 `i` 个区间左端点前的总下降距离。
- **二分查找**：通过 `lower_bound` 快速定位满足条件的最大 `j`。
- **结果计算**：区间内飞行距离 `r[j] - l[i]` 加上剩余高度对应的平飞距离 `h - (d[j] - d[i])`。

---
处理用时：113.36秒
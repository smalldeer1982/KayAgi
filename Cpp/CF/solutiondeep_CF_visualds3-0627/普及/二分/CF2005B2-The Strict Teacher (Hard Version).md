# 题目信息

# The Strict Teacher (Hard Version)

## 题目描述

**这是本题的困难版，它和本题的简单版的唯一差距是 $m$ 和 $q$ 的数据范围**。在此版本中，$m,q\le10^5$。你在解决两个版本之后才可以去提交 hack 数据。

Narek 和 Tsovak 正在热火朝天地准备这场比赛，所以他们没时间去做作业了，因此，他们决定去偷 David 的作业。

严厉的老师发现 David 的作业没了非常生气，打算狠狠地惩罚他，于是她雇佣了别的老师帮她一起抓捕 David。

现在有 $m$ 个老师正在一起追 David。幸运的是，教室非常的大，所以 David 有充足的躲藏空间。

教室可以被表示为一条一维直线，上面有 $n$ 个单元格编号从 $1$ 到 $n$，**包含边界。**

最初，David 和这 $m$ 个老师**在不同的单元格中**。然后他们将会进行若干次行动。每次行动中：
- 首先，David 可以移动到一个**相邻的**单元格中，**也可以不动。**
- 然后，每位老师也进行这样的一次移动。

行动将一直持续知道 David 被抓住，即有任何一个老师和 David 位于同一个单元格中。**所有人都看得见其它人的行动。**

你的任务是计算**在所有人按照最优方案行动的前提下，多少次行动后 David 会被抓住。**

> 按照最优方案行动，是指：
> - David 采取一种方案，使得老师抓住他所需的行动次数最大。
> - 老师之间相互配合并采用一种方案，使得他们能够用最少的行动次数抓住 David。

Narek 和 Tsovak 认为这个任务太简单了，于是他们决定给你 $q$ 次询问。

## 样例 #1

### 输入

```
2
8 1 1
6
3
10 3 3
1 4 8
2 3 10```

### 输出

```
5
1
1
2```

# AI分析结果



---

## 【算法分类】
二分

---

## 【题解思路与解决难点】

### 整体思路
问题核心在于确定 David 位置左右最近的老师或边界（墙），并根据这些位置计算最优策略下的行动次数。所有老师的位置排序后，通过二分查找快速定位 David 的左右边界。分三种情况处理：
1. **左侧无老师**：David 向左逃到墙，步数为最左老师的位置减 1。
2. **右侧无老师**：David 向右逃到墙，步数为 `n - 最右老师的位置`。
3. **中间有老师夹击**：左右最近的老师间距除以 2（取整数部分）。

### 二分过程分析
- **目标**：找到最后一个小于 David 位置的老师（左边界）和第一个大于 David 位置的老师（右边界）。
- **实现**：使用 `upper_bound` 获取第一个大于 David 位置的索引，左边界即为该索引减一。
- **关键点**：正确利用标准库函数 `upper_bound` 和 `lower_bound` 的行为，避免手写二分的复杂性和潜在错误。

### 难点对比
1. **手写二分 vs 标准库函数**：
   - 手写二分（如 chenxi2009）需处理边界收缩条件（如 `mid` 计算方式），易出错但可能更高效。
   - 标准库函数（如 Wide_Master）简化代码，但需理解其返回值含义（如 `upper_bound` 返回首个大于目标值的迭代器）。
2. **奇偶间距处理**：
   - 所有题解最终都等价于计算 `(右老师 - 左老师) // 2`，无需显式区分奇偶。

---

## 【题解评分】
1. **Wide_Master（4 星）**
   - **亮点**：利用标准库函数简化二分，代码简洁易读。
   - **优化**：正确处理 `lower_bound` 和 `upper_bound` 的返回值。

2. **masonxiong（4 星）**
   - **亮点**：预处理每个区间的答案，查询时直接查表，时间复杂度更优。
   - **适用场景**：多次查询时效率更高。

3. **wuyouawa（4 星）**
   - **亮点**：明确变量命名和注释，逻辑清晰。
   - **心得**：强调二分查找需注意数组排序。

---

## 【最优思路提炼】
1. **核心观察**：只有左右最近的老师影响答案，边界条件由墙的位置决定。
2. **二分技巧**：
   - 使用 `upper_bound(a, a+m, x) - 1` 获取左边界老师。
   - 直接计算间距的一半（整数除法），避免奇偶判断。
3. **实现优化**：
   - 预处理排序后的老师位置。
   - 利用标准库函数减少代码量。

---

## 【同类型题与算法套路】
- **二分查找变体**：如查找最近元素、区间边界。
- **类似题目套路**：
  - 在有序序列中快速定位区间。
  - 二分答案（如求最小/最大值问题）。

---

## 【推荐题目】
1. **P2678 跳石头**（二分答案）
2. **P1020 导弹拦截**（二分优化 LIS）
3. **P2440 木材加工**（二分答案）

---

## 【个人心得摘录】
- **wuyouawa**：注意 `n` 和 `m` 的含义，混淆会导致调试困难。
- **Wide_Master**：利用 `lower_bound` 和 `upper_bound` 简化代码，但需明确其行为。

---

## 【可视化与算法演示】
### 二分过程动画设计
1. **初始状态**：显示排序后的老师数组和 David 的位置。
2. **区间收缩**：
   - **颜色标记**：`left`（蓝色）、`right`（红色）、`mid`（黄色）。
   - **更新逻辑**：若 `mid` 对应值小于 David 位置，左边界右移；否则右边界左移。
3. **结果高亮**：最终确定的左右老师位置用绿色标记，显示间距计算过程。
4. **交互功能**：
   - 步进控制：单步执行观察区间收缩。
   - 速度调节：滑动条控制动画速度。
   - 自动演示：AI 自动执行所有步骤。

### 复古像素风格实现
- **Canvas 绘制**：网格表示老师数组，David 位置用像素方块表示。
- **音效**：
  - 移动时播放 8-bit 音效。
  - 找到结果时播放胜利音效。
- **积分系统**：每正确收缩区间得 10 分，错误扣分。

---

## 【核心代码片段】
```cpp
// Wide_Master 的二分处理
sort(a + 1, a + m + 1);
if (b < a[1]) {
    cout << a[1] - 1;
} else if (b > a[m]) {
    cout << n - a[m];
} else {
    int l = upper_bound(a + 1, a + m + 1, b) - a - 1;
    int r = lower_bound(a + 1, a + m + 1, b) - a;
    cout << (a[r] - a[l]) / 2;
}
```

---
处理用时：319.89秒
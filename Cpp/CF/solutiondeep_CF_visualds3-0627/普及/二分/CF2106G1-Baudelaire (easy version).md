# 题目信息

# Baudelaire (easy version)

## 题目描述

这是该问题的简单版本。两个版本之间的唯一区别在于，在这个版本中，保证每个节点都与节点 $1$ 相邻。

本题是交互题。

波德莱尔非常富有，所以他购买了一棵大小为 $n$ 的树，这棵树以某个任意节点为根。此外，每个节点的值为 $1$ 或 $-1$。在这个版本中，每个节点都与节点 $1$ 相邻。但请注意，节点 $1$ 不一定是根节点。

书呆子牛看到了这棵树并爱上了它。然而，计算机科学的收入不足以让他买下这棵树。波德莱尔决定和书呆子牛玩一个游戏，如果他赢了，就把这棵树送给他。

书呆子牛不知道哪个节点是根，也不知道节点的值。但他可以向波德莱尔提出两种类型的查询：

1. `1 k u₁ u₂ ... uₖ`：设 $f(u)$ 为从树的根到节点 $u$ 的路径上所有节点的值之和。书呆子牛可以选择一个整数 $k$（$1 \le k \le n$）和 $k$ 个节点 $u_1, u_2, ..., u_k$，然后他会收到值 $f(u_1) + f(u_2) + ... + f(u_k)$。
2. `2 u`：波德莱尔将切换节点 $u$ 的值。具体来说，如果 $u$ 的值为 $1$，则变为 $-1$，反之亦然。

如果书呆子牛在总共 $n + 200$ 次查询内正确猜出每个节点的值（即执行查询后树的最终值），他就获胜。你能帮助他获胜吗？

## 说明/提示

在示例中，树的根是节点 $2$，节点的初始值为 $[-1, 1, -1, 1]$。因此，$f(1) = 0$，$f(2) = 1$，$f(3) = -1$，$f(4) = 1$。

首先，我们查询 $f(1) + f(2) + f(3)$ 的和，得到 $0$。然后，我们切换节点 $2$ 的值，此时节点的值变为 $[-1, -1, -1, 1]$。因此，$f(1) = -2$，$f(2) = -1$，$f(3) = -3$，$f(4) = -1$，$f(1) + f(2) + f(3) = -6$。

最终，我们推断出节点的值为 $[-1, -1, -1, 1]$，并输出该结果。

注意，这只是一个解释查询如何工作的示例，并不涉及具体的解题策略。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
1
4
1 2
3 1
1 4

0


-6```

### 输出

```
? 1 3 1 2 3

? 2 2
? 1 3 1 2 3

! -1 -1 -1 1```

# AI分析结果



### 算法分类
无算法分类

### 综合分析与结论
**核心思路**：  
利用菊花图特性（所有节点与节点1相邻），通过初始查询判断根是否在节点1。通过切换节点1的值，将问题转化为可线性推导的形式，最终在O(n)次查询内求出所有节点的值。

**解决难点**：  
1. **根位置判定**：通过单次查询结果的奇偶性判断根是否在节点1。
2. **值推导**：当根不在节点1时，利用两次值切换将问题转化为可线性推导的形式。

**可视化设计**：  
- **像素化树结构**：用中心圆形（节点1）和周围方块（其他节点）表示菊花图，根节点用闪烁边框高亮。
- **路径动画**：查询时显示从根到目标节点的路径，路径颜色随值正负变化（绿/红）。
- **音效反馈**：切换值时播放“滴”声，查询结果弹出像素风对话框。
- **自动演示模式**：自动按逻辑顺序执行查询、切换、推导步骤，速度可调节。

### 题解清单 (4星)
1. **作者：_O_v_O_**  
   **亮点**：  
   - 巧用菊花图特性，通过奇偶性快速判断根位置。  
   - 通过值切换将根推导问题转化为线性代数问题。  
   - 仅需O(n)次查询，显著低于允许次数。

### 代码实现
```python
n = int(input())
print("? 1 1 1")
sum1 = int(input())
if sum1 % 2 == 1:  # 根是1
    a = [0] * (n+1)
    a[1] = sum1
    for i in range(2, n+1):
        print(f"? 1 2 1 {i}")
        s = int(input())
        a[i] = s - a[1]
else:  # 根不是1
    print("? 2 1")
    print("? 1 1 1")
    sum1_new = int(input())
    if sum1 == 0:
        a1 = sum1_new // 2
    else:
        a1 = sum1 // 2
    for i in range(2, n+1):
        print(f"? 1 2 1 {i}")
        s = int(input())
        a[i] = s
    a[1] = a1
print("!", *a[1:])
```

### 可视化设计要点
1. **像素风格**：  
   - 16色调色板（#1A1C2C、#FF0044、#28B5C5等）。  
   - 根节点用金色闪烁，普通节点用静态色块。  
2. **Canvas动画**：  
   - 点击节点触发切换操作，播放8-bit音效。  
   - 查询时显示路径线条，宽度随值累加动态变化。  
3. **自动演示**：  
   - 初始播放根判定逻辑，后续按顺序高亮每个节点推导过程。  
   - 按空格键暂停/继续，方向键调整速度。  

### 同类型题推荐
1. CF1167B - Lost Numbers（交互题，数学推导）  
2. CF1527D - Cut（树结构，路径查询）  
3. CF1494C - Berland Regional（菊花图性质利用）

---
处理用时：73.09秒
# 题目信息

# Maximal Intersection

## 题目描述

给定n个闭区间,现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

## 样例 #1

### 输入

```
4
1 3
2 6
0 4
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
2 6
1 3
0 4
1 20
0 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
4 5
1 2
9 20
```

### 输出

```
0
```

## 样例 #4

### 输入

```
2
3 10
1 5
```

### 输出

```
7
```

# AI分析结果



## 算法分类
**贪心、前后缀处理**

---

## 题解思路与核心分析

### 核心问题
删除一个区间后，求剩余区间交集的最大长度。区间交集定义为所有区间左端点最大值与右端点最小值之差。

### 核心解法对比
1. **前后缀预处理法**（最优解法）
   - 核心思路：预先计算前缀数组（最大左端点、最小右端点）和后缀数组（最大左端点、最小右端点）。对于每个区间，删除后的交集可通过合并前缀和后缀结果得到。
   - 时间复杂度：O(n)，三次遍历即可完成。
   - 空间复杂度：O(n)，存储前缀和后缀数组。
   - **正确性保障**：覆盖所有可能情况，无论删除哪个区间，都能通过前后缀的合并正确计算。

2. 次大次小值法
   - 尝试记录最大/次大左端点和最小/次小右端点，但存在逻辑漏洞（如多个相同最大左端点时无法正确计算次大值）。

3. Multiset维护法
   - 用两个 multiset 维护所有左右端点，每次删除后取最大值和最小值。时间复杂度 O(n log n)，效率略低但代码简洁。

---

## 题解评分（≥4星）

### 5星题解
- **CreeperK**  
  - 思路清晰，通过前缀和后缀数组预处理，代码高效简洁。
  - 关键变量命名明确，直接体现逻辑（`lpl`前缀最大左端点，`lpr`前缀最小右端点）。
  - 时间复杂度 O(n)，覆盖所有情况。

### 4星题解
- **Mickey_snow**  
  - 使用结构体存储区间，两次遍历构建前后缀数组。
  - 代码结构清晰，但部分变量名不够直观（如 `arr` 存储合并后的区间）。

---

## 最优思路提炼
**前后缀预处理法**  
1. **前缀数组**：`lpl[i]` 表示前 i 个区间的最大左端点，`lpr[i]` 表示前 i 个区间的最小右端点。
2. **后缀数组**：`rpl[i]` 表示后 i 个区间的最大左端点，`rpr[i]` 表示后 i 个区间的最小右端点。
3. **合并计算**：删除第 i 个区间后，剩余区间的交集为：
   ```
   max_l = max(lpl[i-1], rpl[i+1])
   min_r = min(lpr[i-1], rpr[i+1])
   result = max(0, min_r - max_l)
   ```

---

## 同类型题与算法套路
- **通用场景**：需要动态删除某个元素后计算聚合值（如最大公约数、最小公倍数、区间交并）。
- **类似题目**：
  1. [CF 754D - 最大k区间交集](https://codeforces.com/problemset/problem/754/D)
  2. [洛谷 P1886 - 滑动窗口](https://www.luogu.com.cn/problem/P1886)
  3. [LeetCode 238 - 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

---

## 个人心得摘录
- **CreeperK**：从 GCD 前缀后缀问题迁移思路，意识到“插入比删除容易”，通过预处理避开动态删除的复杂性。
- **Jorisy**：通过堆维护右端点，尝试在排序后贪心，但未覆盖所有情况。

---

## 可视化算法演示
### 核心流程
1. **构建前缀数组**：从左到右遍历，逐步更新最大左端点和最小右端点。
2. **构建后缀数组**：从右到左遍历，逐步更新最大左端点和最小右端点。
3. **合并计算**：对每个区间，高亮其前缀和后缀的合并结果。

### 动画设计
- **步骤标记**：
  - 红色高亮当前处理的前缀/后缀位置。
  - 绿色显示合并后的 `max_l` 和 `min_r`。
- **交互控制**：
  - 步进按钮观察每个区间的删除效果。
  - 速度调节支持慢放关键步骤。

### 复古像素风格
- **颜色方案**：16色调色板，红色表示当前操作，绿色表示结果。
- **Canvas 绘制**：区间用水平线段表示，前缀/后缀结果用动态变化的色块覆盖。
- **音效**：成功合并时播放 8-bit 上扬音效，无效区间时播放低音提示。

---

## 代码实现（核心逻辑）
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 3e5 + 5;
int n, l[MAXN], r[MAXN];
int lpl[MAXN], lpr[MAXN], rpl[MAXN], rpr[MAXN];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &l[i], &r[i]);
        lpl[i] = max(lpl[i-1], l[i]);  // 前缀最大左端点
        lpr[i] = min(lpr[i-1], r[i]);  // 前缀最小右端点
    }
    for (int i = n; i >= 1; i--) {
        rpl[i] = max(rpl[i+1], l[i]);  // 后缀最大左端点
        rpr[i] = min(rpr[i+1], r[i]);  // 后缀最小右端点
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int max_l = max(lpl[i-1], rpl[i+1]);
        int min_r = min(lpr[i-1], rpr[i+1]);
        ans = max(ans, min_r - max_l);
    }
    printf("%d\n", ans);
    return 0;
}
```

---
处理用时：99.78秒
# 题目信息

# Milking cows

## 题目描述

Iahub在农场帮助他的祖父，今天他必须挤牛奶。农场里有$n$只牛左成一排，从左到右编号$1$到$n$。每只牛不是面向左边就是面向右边。当Iahub挤某一只牛的牛奶时，所有看得到这当前只牛的牛都会因为受到惊吓而损失一单位量的牛奶。面向左边的牛可以看到它左边的所有牛（不包括自己），面向右边的牛可以看到它右边的所有牛（不包括自己）。被惊吓过的牛可以再次被惊吓。被挤过奶的牛不会再被惊吓。我们假定每一头牛可以生产无限量的牛奶。

Iahub可以决定挤牛奶的顺序，但他必须每头牛都要挤。Iahub想损失尽可能少的牛奶。请输出最少的牛奶损失量。

## 说明/提示

在第一个样例中,Iahub按照下面的顺序可以使得牛奶损失最少：$3,4,2,1$。当他挤牛$3$时，牛$4$会损失$1$单位牛奶。在此之后，没有牛奶损失。

Translated by @Imakf

## 样例 #1

### 输入

```
4
0 0 1 0
```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 0 1 0 1
```

### 输出

```
3```

# AI分析结果



**唯一算法分类**: 贪心

---

### **综合分析与结论**

**核心思路**  
所有题解均基于贪心策略：对于每个面朝左的牛，统计其左侧所有面朝右的牛的数量之和。这种方法的正确性依赖于以下观察：  
1. 挤奶顺序应尽量减少相互影响。  
2. 若按从左到右的顺序处理，面朝右的牛不会被后续挤奶的右向牛影响，面朝左的牛则会被其左侧的右向牛影响。  
3. 因此，只需遍历一次数组，累加每个左向牛左侧的右向牛数量，即可得到最小损失。

**难点与解决方案**  
- **难点**：如何证明贪心策略的正确性？  
- **解决方案**：通过分析面朝左/右的牛的相互影响关系，发现两种顺序（左向牛从右到左挤，或右向牛从左到右挤）等价，最终只需统计单向的前缀和。

**可视化设计思路**  
- **动画方案**：  
  1. **元素高亮**：当前遍历的牛高亮为黄色，若为右向牛则标记为蓝色，左向牛为红色。  
  2. **前缀和统计**：右侧显示实时更新的 `cnt`（右向牛计数）和 `sum`（总损失）。  
  3. **步进控制**：允许用户单步执行，观察每个牛的贡献如何累加到总损失中。  
- **复古像素风格**：  
  - 牛用 8x8 像素块表示，右向牛为蓝色方块（→），左向牛为红色方块（←）。  
  - 背景音乐为 8-bit 风格循环音效，每次累加 `sum` 时播放短促“滴”声。  
- **AI 自动模式**：自动从左到右遍历，每步间隔 1 秒，动态更新计数和总损失。

---

### **题解清单 (≥4星)**

1. **花里心爱 (5星)**  
   - **亮点**：思路清晰，代码简洁，直接使用前缀和统计核心逻辑。  
   - **代码片段**：  
     ```cpp
     if(t) ++cnt;      // 统计右向牛数量
     else sum += cnt;  // 左向牛累加损失
     ```

2. **Buried_Dream (4星)**  
   - **亮点**：代码可读性强，附带幽默注释，核心逻辑与最优解一致。  
   - **代码片段**：  
     ```cpp
     if(x) ++js;      // 前缀和统计右向牛
     else ans += js;  // 左向牛贡献损失
     ```

3. **Qerucy (4星)**  
   - **亮点**：代码简短高效，明确使用 `long long` 避免溢出问题。  
   - **代码片段**：  
     ```cpp
     if(x) sum++;     // 右向牛计数
     else ans += sum; // 累加损失
     ```

---

### **最优思路提炼**

**核心技巧**  
- **贪心策略**：按固定顺序（从左到右）遍历，实时统计右向牛数量，遇到左向牛时累加其左侧的右向牛总数。  
- **前缀和优化**：只需一次遍历，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。  
- **关键公式**：总损失 = $\sum_{\text{左向牛}} \text{左侧右向牛数量}$。

---

### **同类型题与算法套路**

**相似算法题**  
1. **逆序对问题**：统计数组中满足 $i<j$ 且 $a_i>a_j$ 的对数（可用前缀和或树状数组）。  
2. **排队接水问题**：通过贪心选择最小等待时间的顺序。  
3. **任务调度问题**：按截止时间或利润排序，最大化收益。

---

### **推荐题目**

1. **P1908 逆序对**（前缀和/树状数组）  
2. **P1223 排队接水**（贪心排序）  
3. **P1090 合并果子**（优先队列贪心）

---

### **个人心得摘录**

- **Instudy**：尝试用树状数组求逆序对，但最终发现贪心法更高效。  
- **Wf_yjqd**：最初认为需模拟两种顺序，实际验证后发现单向统计即可。  
- **违规用户名U56916**：通过分析挤奶顺序的相互影响，验证了贪心策略的正确性。

---

### **代码实现（核心逻辑）**

**花里心爱的完整代码**  
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,t;
long long cnt,sum;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&t);
        if(t) ++cnt;
        else sum += cnt;
    }
    cout << sum << endl;
    return 0;
}
```

**核心逻辑解释**  
- `cnt` 记录当前遍历位置左侧的右向牛数量。  
- 遇到左向牛时，将 `cnt` 累加到总损失 `sum` 中。

---

### **可视化与复古游戏化设计**

**Canvas 动画伪代码**  
```javascript
// 初始化像素画布
const cows = [0, 0, 1, 0]; // 样例输入
let cnt = 0, sum = 0;

function drawFrame(step) {
  clearCanvas();
  for (let i = 0; i < step; i++) {
    drawCow(i, cows[i] ? 'blue' : 'red'); // 绘制牛
    if (i === step - 1) highlightCow(i, 'yellow'); // 高亮当前牛
  }
  if (cows[step] === 1) cnt++;
  else sum += cnt;
  updateCounter(cnt, sum); // 更新右侧计数显示
}

// 8-bit 音效触发
function playSound(effect) {
  if (effect === 'add') beep(440, 100); // 累加时播放
}
```

**复古风格交互**  
- **背景音乐**：8-bit 农场风格循环音乐。  
- **音效**：每次更新 `sum` 时播放“金币”音效。  
- **自动模式**：按“AI 演示”按钮后，自动步进执行，间隔 1 秒。

---
处理用时：101.92秒
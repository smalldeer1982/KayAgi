# 题目信息

# Almost Arithmetic Progression

## 题目描述

Polycarp 喜欢等差数列，对于一个数列 $ [a_1,a_2,a_3,\dots,a_n] $，如果对于每个 $ i\,(1\le i < n) $，$ a_{i+1}-a_i $ 的值均相同，那么这个数列就是一个等差数列。例如，$ [42] $ ，$ [5,5,5] $ ，$ [2,11,20,29] $ 和 $ [3,2,1,0] $ 是等差数列，但是 $ [1,0,1] $，$ [1,3,9] $ 和 $ [2,3,1] $ 不是。

根据定义，任何长度为 $ 1 $ 或 $ 2 $ 的数列都是等差数列。

Polycarp 找到了一个只包含正整数的数列 $ [b_1,b_2,b_3,\dots,b_n] $ 。他只想最多将每个元素改变一次。换句话说，对于每个元素，有三种选项：自增 $ 1 $，自减 $ 1 $ 或者不变。

你需要找到对 $ b $ 中元素操作（每个只能操作一次）的最小次数，使 $ b $ 变成一个等差数列。

操作完成后的数列可以含有 $ 0 $ 。

## 说明/提示

在样例 $ 1 $ 中，Polycarp 应该将第 $ 1 $ 个元素加 $ 1 $ ，将第 $ 2 $ 个元素加 $ 1 $ ，将第 $ 3 $ 个元素加 $ 1 $ ，并且不改变第 $ 4 $ 个元素。所以，Polycarp 操作之后的数列为 $ [25,20,15,10] $ 。

在样例 $ 2 $ 中，Polycarp 不应进行操作，因为他的数列已经是等差数列了。

在样例 $ 3 $ 中，不可能通过上述的操作将数列变为等差数列。

在样例 $ 4 $ 中，Polycarp 应该只将第 $ 1 $ 个元素加 $ 1 $ 。操作之后的数列为 $ [0,3,6,9,12] $ 。

## 样例 #1

### 输入

```
4
24 21 14 10
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2
500 500
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
14 5 1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
5
1 3 6 9 12
```

### 输出

```
1
```

# AI分析结果



## 唯一算法分类
枚举

---

## 综合分析与结论
### 核心思路与难点
**核心思路**：  
通过枚举前两项的所有可能调整方式（3×3=9种组合），确定公差，验证后续元素能否通过±1调整形成等差数列。关键点在于：
1. 前两项的调整决定了公差
2. 后续元素必须满足相邻差与公差的绝对值差≤1

**难点解决**：  
- **数据独立性**：每次枚举使用临时数组或动态计算期望值，避免污染原数据
- **时间复杂度优化**：O(9n) 的线性复杂度确保大数处理效率
- **边界处理**：n≤2 直接返回0，公差计算时的整数校验

**可视化设计**：  
- **像素动画**：用 8-bit 风格显示数列元素，当前元素高亮黄色，调整后的元素用绿色/红色区分成功/失败
- **音效设计**：  
  - 正确调整：短促 "滴" 声  
  - 错误情况：低沉 "嘟" 声  
  - 完成验证：8-bit 胜利音效
- **步进面板**：可调节速度（1x/2x/5x），单步查看每个元素的判断流程

---

## 题解清单（≥4星）
### 1. Sophon（★★★★☆）
- **亮点**：动态计算期望值无需数组拷贝，时间复杂度最优
- **代码片段**：  
  ```cpp
  void work(int a1, int a2, int change) {
    int d = a2 - a1, res = change;
    for(int i=3; i<=n; i++) {
      int expect = a1 + (i-1)*d;
      if(abs(expect - a[i]) > 1) return;
      res += (expect != a[i]);
    }
    ans = min(ans, res);
  }
  ```

### 2. J_Kobe（★★★★☆）
- **亮点**：显式使用临时数组，逻辑清晰易理解
- **关键代码**：  
  ```cpp
  memcpy(tmp, a, sizeof(tmp));
  tmp[0] += mx[i];
  tmp[1] += my[i];
  int d = tmp[1] - tmp[0];
  ```

### 3. FanYongchen（★★★★☆）
- **优势**：三层循环枚举直观，适合教学理解
- **调试心得**：  
  > "注意修改的是临时数组，每次枚举要重置数组状态"

---

## 最优思路提炼
**核心技巧**：  
1. **前两项决定论**：仅需 9 次枚举即可覆盖所有可能公差
2. **期望值计算**：通过首项+公差×位置直接推导目标值，避免数组修改
3. **差值验证**：`|当前差 - 目标差| ≤1` 时才能调整

**优化点**：  
- **空间优化**：不拷贝数组，直接计算期望值（Sophon 式）
- **剪枝**：遇到无法调整的元素立即终止当前枚举

---

## 同类题目推荐
1. **CF1038D Slime**（差值构造）
2. **CF978E Bus Video System**（范围约束验证）
3. **Luogu P1102**（A-B数对，等差关系处理）

---

## 可视化代码片段（JS）
```javascript
// 像素动画核心逻辑
function drawArray(ctx, arr, highlightIdx) {
  ctx.clearRect(0, 0, 800, 200);
  arr.forEach((num, i) => {
    ctx.fillStyle = i === highlightIdx ? "#FFD700" : "#00FF00";
    draw8BitNumber(ctx, num, 50 + i*80, 100);
  });
}

// 音效触发
function playSound(type) {
  const sfx = {
    ok: new Audio('data:audio/wav;base64,UklGRl9...'),
    error: new Audio('data:audio/wav;base64,UklGRhY...')
  };
  sfx[type].play();
}

// 单步执行演示
async function demoStep(arr, d) {
  let expect = arr[0];
  for(let i=1; i<arr.length; i++) {
    expect += d;
    drawArray(ctx, arr, i);
    if(Math.abs(arr[i] - expect) > 1) {
      playSound('error');
      return false;
    }
    await delay(500);
  }
  playSound('ok');
  return true;
}
```

---
处理用时：114.01秒
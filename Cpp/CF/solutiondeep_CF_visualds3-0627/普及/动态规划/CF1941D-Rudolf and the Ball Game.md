# 题目信息

# Rudolf and the Ball Game

## 题目描述

$n$ 个人站成一个圈，按照顺时针编号依次是 $1$ 到 $n$。

现在这 $n$ 个人玩一个传球游戏，第 $i$ 次传球可以向顺时针方向传给与自己距离为 $d_i$ 的距离，或者向逆时针方向传给与自己距离为 $r_i$ 的距离。

游戏总共进行了 $m$ 轮传球，给你初始拿到球的人的编号 $x$ 和每次传球的方向和距离 $r_i$（有可能方向未知），求出最后可能是谁拿到了球，**按编号从小到大**输出。

------------

## 说明/提示

#### 样例解释
下面是第一个测试用例的三次传球的示意图。箭头表示可能的传球方向。在传球后可能持有球的玩家被标记为灰色。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941D/de43c3cc1c4b12f903e5224359bac3a10205e9a9.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941D/1a47b05e6478f36a49179722556df26c9f84bbc8.png)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1941D/47036b3bd9ad777cfd4d3801abb62bd85bcbcc75.png)

------------

对于 $100\%$ 的数据，$1 \le t \le 1000,1 \le x  \le n \le 1000,1 \le m \le 1000,1 \le n\cdot m \le 2\cdot10^5,1 \le r_i \le n-1$。

## 样例 #1

### 输入

```
5
6 3 2
2 ?
2 ?
2 ?
12 1 2
3 1
10 7 4
2 ?
9 1
4 ?
7 0
2 0
8 1
5 ?
5 3 1
4 0
4 ?
1 ?
4 1 1
2 ?```

### 输出

```
3
2 4 6 
1
11 
4
3 5 7 9 
3
2 3 5 
1
3```

# AI分析结果



0. **题目翻译**

# Rudolf 和传球游戏

## 题目描述

$n$ 个人站成一个圆圈，按顺时针方向依次编号为 $1$ 到 $n$。

这些人进行传球游戏，第 $i$ 次传球可以顺时针传给距离自己 $d_i$ 的人，或者逆时针传给距离自己 $r_i$ 的人。

游戏共进行 $m$ 轮传球，给定初始持球者编号 $x$ 和每次传球的距离及方向（可能方向未知），求最终可能持球者的编号，**按升序输出**。

---

## 说明/提示

#### 样例解释
第一个测试用例的三次传球示意图如下。箭头表示可能的传球方向，灰色标记为可能持球的玩家。

---

对于 $100\%$ 的数据，$1 \le t \le 1000,1 \le x \le n \le 1000,1 \le m \le 1000,1 \le n\cdot m \le 2\cdot10^5,1 \le r_i \le n-1$。

---

1. **唯一算法分类**  
   线性DP

---

2. **综合分析与结论**  
   **核心思路**：动态维护每个传球步骤后可能的位置集合。  
   - **状态设计**：用 `dp[i][j]` 表示第 `i` 次传球后 `j` 号位置是否可能持球。  
   - **转移方程**：根据传球方向分情况计算顺时针/逆时针位置，用位或操作合并可能状态。  
   - **关键难点**：正确处理环形结构的位置计算，优化空间复杂度（如滚动数组）。  
   - **可视化设计**：  
     - 每一步高亮当前可能位置，用箭头动画展示顺时针/逆时针转移。  
     - 采用复古像素风格，每个状态用彩色方块表示，转移时播放 8-bit 音效。  
     - 支持步进控制，展示 `dp` 数组的更新过程，突出状态变化的格子。

---

3. **题解清单 (≥4星)**  
   - **GenesisCrystal（4星）**：结构清晰，二维DP直观展现状态转移，适合教学。  
   - **Infinite_Loop（4星）**：利用集合自动去重和排序，代码简洁高效。  
   - **haokee（4星）**：滚动数组优化空间，代码实现精简。

---

4. **最优思路提炼**  
   - **环形位置计算**：通过模运算统一处理顺时针/逆时针位置。  
     ```cpp
     // 顺时针传r次
     int clockwise = (current + r) % n;
     if (clockwise == 0) clockwise = n;

     // 逆时针传r次
     int counter = (current - r + n) % n;
     if (counter == 0) counter = n;
     ```
   - **状态转移优化**：使用滚动数组或集合减少空间占用，避免重复计算。

---

5. **同类型题推荐**  
   - **P1057 传球游戏**：基础环形传球DP。  
   - **P1095 守望者的逃离**：多状态转移的线性DP。  
   - **P1434 滑雪**：二维DP与状态转移的综合应用。

---

6. **核心代码实现**  
   **Infinite_Loop 的集合解法**：  
   ```cpp
   set<int> ans;
   ans.insert(x);
   for (int i = 1; i <= m; i++) {
       set<int> now;
       if (c[i] == '0') {
           // 顺时针计算新位置
           for (auto j : ans) 
               now.insert((j + r[i] - 1) % n + 1);
       } else if (c[i] == '1') {
           // 逆时针计算新位置
           for (auto j : ans)
               now.insert((j - r[i] + n - 1) % n + 1);
       } else {
           // 合并两个方向
           for (auto j : ans) {
               int cw = (j + r[i] - 1) % n + 1;
               int ccw = (j - r[i] + n - 1) % n + 1;
               now.insert(cw);
               now.insert(ccw);
           }
       }
       ans = now;
   }
   ```

---

7. **可视化与复古游戏设计**  
   - **像素风格**：用16色调色板，Canvas绘制环形排列的玩家格子。  
   - **动画效果**：  
     - 当前持球者格子高亮为黄色，转移时显示红色（逆时针）/蓝色（顺时针）箭头。  
     - 每次传球播放不同音效（清脆音效表成功，低沉音效表无变化）。  
   - **自动演示**：按设定速度逐步播放传球过程，支持暂停/继续。

---
处理用时：230.24秒
# 题目信息

# 0, 1, 2, Tree!

## 题目描述

查找满足条件的有根树 $^{\dagger}$ 的最小高度。

其中 $a+b+c$ 个顶点满足以下条件：

- $a$ 个顶点恰好有 $2$ 个子顶点，

- $b$ 个顶点恰好有 $1$ 个子顶点，

- $c$ 个顶点没有子顶点。

如果没有这样的树，输出 $-1$。

如：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1950F/0c6b0806a993f448977c57ce3c99533fc6610921.png)

上面的树植根于顶部顶点，每个顶点都标有它的子节点数。

这里 $a=2,b=1,c=3$，高度为 $2$。

 $^{\dagger}$：有根树是指一个没有循环的连通图，有一个特殊的顶点称为根。在有根树中，在由边连接的任意两个顶点，一个顶点是父顶点（离根更近的顶点），另一个是子顶点。

树中两个顶点之间的距离是它们之间最短路径中的边数。有根树的高度是从顶点到根部的最大距离。

## 说明/提示

第一个测试用例如图所示。树的高度不能低于 $2$。

在第二个测试用例中，您可以形成一个只有一个顶点且没有边的树。它的高度为 $0$，这显然是最佳的。

在第三个测试用例中，您可以形成一个由单个边连接的两个顶点的树。它的高度为 $1$，这显然是最佳的。

## 样例 #1

### 输入

```
10
2 1 3
0 0 1
0 1 1
1 0 2
1 1 3
3 1 4
8 17 9
24 36 48
1 0 0
0 3 1```

### 输出

```
2
0
1
1
-1
3
6
-1
-1
3```

# AI分析结果



### 算法分类选择
**树构造 + 贪心算法**

---

### 题解思路、算法要点与解决难点

#### 核心条件推导
- **无解条件**：必须满足 `c = a + 1`（每个 a 类节点增加 1 个叶子，初始根节点是叶子）。
- **特殊情形**：若 `a = 0`，树为链状，高度为 `b`；若 `b = 0`，树为完全二叉树，高度为 `log2(a)`。

#### 算法实现对比
1. **贪心构造完全二叉树**（Shadow_T、Frodo 等题解）：
   - **核心步骤**：将 a 类节点优先填成完全二叉树，计算层数 `h = floor(log2(a))`。
   - **剩余处理**：用 b 类节点填补最后一层的空缺，剩余 b 按每层最大容量分配。
   - **关键变量**：`x` 表示当前层容量，`f` 表示最后一层剩余空缺，`z` 表示每层可插入的节点数。
   - **代码优化**：使用位运算快速计算层数（如 `__builtin_clz`）。

2. **优先队列动态维护**（Yharimium 题解）：
   - **核心步骤**：用小根堆维护可扩展节点，优先扩展深度最小的节点。
   - **实现细节**：先处理 a 类节点（插入两个子节点），再处理 b 类节点（插入一个子节点）。
   - **时间复杂度**：O(a + b)（堆操作的总次数）。

3. **数学公式直接计算**（Frodo 题解）：
   - **关键公式**：`h = log2(a)`，剩余 b 的分配公式为 `(b + c - 1) / c`。
   - **代码简洁性**：仅需 10 行，高效处理所有情况。

---

### 题解评分（≥4星）

1. **Shadow_T（★★★★☆）**
   - **亮点**：数学推导清晰，代码高效，正确处理了完全二叉树的层数计算和剩余 b 的分配。
   - **代码可读性**：变量命名合理，逻辑分层明确。

2. **Yharimium（★★★★☆）**
   - **亮点**：优先队列实现直观，动态维护扩展顺序，符合贪心思想。
   - **可视化潜力**：适合用动画展示堆操作和深度更新。

3. **Frodo（★★★★★）**
   - **亮点**：代码极度简洁，利用位运算快速计算层数，时间复杂度 O(1)。
   - **优化程度**：综合数学推导与代码优化，实践性极强。

---

### 最优思路或技巧提炼
1. **核心条件判断**：`c != a + 1` 直接无解。
2. **完全二叉树层数计算**：`h = floor(log2(a))`，使用位运算加速。
3. **剩余 b 的分配**：`剩余高度增量 = ceil(b / 每层容量)`。
4. **优先队列贪心**：动态选择最浅层扩展，最小化高度。

---

### 同类型题或类似算法套路
- **完全二叉树构造**：如 LeetCode 222. 完全二叉树的节点个数。
- **贪心分配问题**：如分配任务使完成时间最短。
- **树的层级扩展**：如层序遍历求深度。

---

### 推荐洛谷题目
1. **P1040 加分二叉树**（树构造 + 动态规划）。
2. **P1305 新二叉树**（输入输出处理 + 树遍历）。
3. **P1364 医院设置**（树的重心与距离计算）。

---

### 个人心得摘录
- **Shadow_T**：  
  *“最后一层剩余的空缺需要优先填补，否则会导致高度不必要增加。”*
- **Yharimium**：  
  *“每次弹出堆顶元素扩展，保证总是处理当前最浅的节点，这是贪心的关键。”*
- **Frodo**：  
  *“位运算和数学公式的配合，能将代码压缩到极致。”*

---

### 可视化与算法演示设计
#### 核心算法过程动画方案
1. **完全二叉树构造阶段**：
   - **动画展示**：逐层填充 a 类节点，用不同颜色标记当前层和子节点。
   - **高亮元素**：当前扩展的节点及其新增的子节点。
   - **步进控制**：允许单步执行，观察每一层的填充过程。

2. **剩余 b 类节点分配**：
   - **网格可视化**：用 Canvas 绘制树形网格，动态添加 b 类节点。
   - **颜色标记**：红色表示新插入的 b 类节点，黄色表示填充的空缺。

3. **复古像素风格**：
   - **8位调色板**：使用绿色（a 类）、蓝色（b 类）、灰色（叶子）。
   - **音效设计**：
     - **插入节点**：短促的“滴”声。
     - **层数增加**：上扬的“升级”音效。
   - **自动演示模式**：模拟 AI 自动选择扩展节点，类似贪吃蛇路径规划。

#### 代码片段（JavaScript 动画核心）
```javascript
// 初始化 Canvas 和音效
const canvas = document.getElementById('tree-canvas');
const ctx = canvas.getContext('2d');
const soundInsert = new Audio('insert.wav');

// 绘制节点
function drawNode(x, y, type) {
  ctx.fillStyle = type === 'a' ? '#00FF00' : '#0000FF';
  ctx.fillRect(x, y, 20, 20); // 像素风格方块
}

// 自动演示逻辑
function autoRun() {
  let currentLayer = 0;
  const queue = [{ depth: 0, x: 400, y: 50 }]; // 初始根节点
  while (queue.length) {
    const node = queue.shift();
    drawNode(node.x, node.y, 'a');
    soundInsert.play();
    // 添加子节点...
  }
}
```

---

### 结论
本题需综合树的性质、贪心策略和数学推导，最优解法通过完全二叉树的层数计算和剩余节点的公式化分配，实现高效求解。可视化设计可结合复古像素风格和音效，增强算法理解与学习趣味性。

---
处理用时：93.88秒
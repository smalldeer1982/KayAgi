# 题目信息

# Friends

## 题目描述

有一天，一个叫做伊戈尔-凯的人放弃编程，转攻数学题。一个深秋的夜晚，他坐在桌旁读书，想着数学问题。
书上有着一段话吸引了他的注意：“在任六人中有三个人互相认识或互相不认识。”
伊戈尔完全无法理解为什么至少有六个人。“那对不起，我觉得五个人也一样，”他脑子里开始胡思乱想“让我试试...马克思，利亚，瓦娃--他们互相认识，额..再加一个迪玛和欧莱格，对瓦娃来说他们三个互不认识！哈哈哈哈哈，这个定理就是一个渣渣。”
伊戈尔带着他的5个朋友，让他们记下来，他们中谁互为朋友。现在他想看看这五个人是否真的认识三对或三对不认识的人。

## 样例 #1

### 输入

```
4
1 3
2 3
1 4
5 3
```

### 输出

```
WIN
```

## 样例 #2

### 输入

```
5
1 2
2 3
3 4
4 5
5 1
```

### 输出

```
FAIL
```

# AI分析结果



# 算法分析与题解总结

## 唯一算法分类
**图论 - 度数分析与暴力枚举**

---

## 综合分析与结论

### 核心思路
题目要求判断5人关系中是否存在3人互相全认识或全不认识。解法分为两类：
1. **度数分析法**：若存在至少一个点的度数≠2，则存在满足条件的三元组（输出`WIN`）；否则输出`FAIL`。
2. **暴力枚举法**：直接检查所有可能的三元组是否存在全连接或全断开的情况。

### 解决难点
- **度数分析法的正确性证明**：通过图论性质推导，当所有点度数为2时（如五边形结构），无法形成三元全连/断；否则必然存在满足条件的三元组。
- **暴力枚举的可行性**：由于数据规模极小（n=5），暴力枚举的时间复杂度为常数级。

### 核心算法流程
**度数分析法**：
1. 统计每个点的度数。
2. 检查是否存在度数≠2的点。
   - 存在 → `WIN`。
   - 全为2 → `FAIL`。

**暴力枚举法**：
1. 构建邻接矩阵。
2. 遍历所有三元组 `(i,j,k)`。
3. 检查三元组是否全连或全断。

---

## 题解评分（≥4星）

### 1. 作者：lrq090403（★★★★★）
- **亮点**：O(m)时间复杂度，简洁的度数判断，正确性证明详细。
- **代码**：仅需统计度数，逻辑清晰。

### 2. 作者：Cutler（★★★★）
- **亮点**：暴力枚举直观易懂，代码直接对应题意。
- **代码**：三重循环检查三元组，适合小数据。

### 3. 作者：Farkas_W（★★★★）
- **亮点**：邻接矩阵存储关系，核心判断条件简洁。
- **代码**：优化枚举顺序避免重复。

---

## 最优思路提炼

### 度数分析法（最优）
- **关键技巧**：利用图论中“五边形结构”的特性，所有点度数为2时无法满足条件。
- **实现要点**：
  - 统计边数至度数数组。
  - 检查是否存在度数≠2的点。
- **复杂度**：O(m)时间，O(1)空间。

### 暴力枚举法（辅助验证）
- **适用场景**：数据规模极小时。
- **优化点**：避免重复枚举，提前终止循环。

---

## 类似题目推荐
1. **P1330 封锁阳光大学**（图的覆盖问题，需分析度数）。
2. **P3388 割点**（图论中的关键点分析）。
3. **P2661 信息传递**（图的环检测，涉及度数分析）。

---

## 可视化与算法演示设计

### 动画方案
1. **度数分析法**：
   - **初始状态**：5个点无连接，右侧显示度数表。
   - **逐步输入边**：动态绘制边，更新度数表。
   - **检查度数**：高亮第一个度数≠2的点，触发`WIN`提示；若全为2则`FAIL`。

2. **暴力枚举法**：
   - **网格绘制**：5×5网格表示邻接矩阵。
   - **遍历三元组**：高亮当前三元组，检查全连/全断。
   - **成功状态**：闪烁满足条件的三元组并播放音效。

### 复古像素风格
- **颜色方案**：16色调色板，绿色表示边存在，红色表示无连接。
- **音效**：
  - **边添加**：8-bit“滴”声。
  - **成功/失败**：胜利音效（上扬）或失败音效（低沉）。
- **自动演示**：按步执行，可调节速度。

---

## 代码实现（核心逻辑）

### 度数分析法
```cpp
#include<iostream>
using namespace std;
int d[6], m, a, b;

int main() {
    cin >> m;
    while (m--) {
        cin >> a >> b;
        d[a]++; d[b]++;
    }
    for (int i = 1; i <= 5; i++) {
        if (d[i] != 2) {
            cout << "WIN";
            return 0;
        }
    }
    cout << "FAIL";
    return 0;
}
```

### 暴力枚举法
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[6][6], m;

int main() {
    cin >> m;
    while (m--) {
        int x, y;
        cin >> x >> y;
        f[x][y] = f[y][x] = 1;
    }
    for (int i = 1; i <= 3; i++)
        for (int j = i+1; j <= 4; j++)
            for (int k = j+1; k <= 5; k++)
                if ((f[i][j] && f[i][k] && f[j][k]) || 
                    (!f[i][j] && !f[i][k] && !f[j][k])) {
                    cout << "WIN";
                    return 0;
                }
    cout << "FAIL";
    return 0;
}
```

---
处理用时：94.05秒
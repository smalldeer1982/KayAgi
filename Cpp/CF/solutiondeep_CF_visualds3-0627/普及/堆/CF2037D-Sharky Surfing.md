# 题目信息

# Sharky Surfing

## 题目描述

Mualani 喜欢在她的大鲨鱼冲浪板上冲浪！

Mualani 的冲浪路径可以用一个数轴来表示。她从位置 $1$ 开始，路径的终点是位置 $L$。当她处于位置 $x$ 且跳跃能力为 $k$ 时，她可以跳到区间 $[x, x+k]$ 内的任意整数位置。最初，她的跳跃能力为 $1$。

然而，她的冲浪路径并不完全平坦。她的路径上有 $n$ 个障碍物。每个障碍物由一个区间 $[l, r]$ 表示，意味着她不能跳到区间 $[l, r]$ 内的任何位置。

在路径上还有 $m$ 个能量提升点。第 $i$ 个能量提升点位于位置 $x_i$，其值为 $v_i$。当 Mualani 处于位置 $x_i$ 时，她可以选择收集该能量提升点，将她的跳跃能力增加 $v_i$。在同一个位置可能有多个能量提升点。当她处于有多个能量提升点的位置时，她可以选择收集或忽略每个单独的能量提升点。没有能量提升点位于任何障碍物的区间内。

Mualani 必须收集最少的能量提升点数才能到达位置 $L$ 完成冲浪路径。如果无法完成冲浪路径，则输出 $-1$。

## 样例 #1

### 输入

```
4
2 5 50
7 14
30 40
2 2
3 1
3 5
18 2
22 32
4 3 50
4 6
15 18
20 26
34 38
1 2
8 2
10 2
1 4 17
10 14
1 6
1 2
1 2
16 9
1 2 10
5 9
2 3
2 2```

### 输出

```
4
-1
1
2```

# AI分析结果



# Sharky Surfing 题解分析

## 唯一算法分类
贪心

---

## 题解思路与核心难点

### 核心算法流程
1. **贪心策略**：每次处理障碍物时，优先选择当前可用的最大跳跃加成，以最少收集次数突破障碍
2. **数据结构**：使用大根堆（优先队列）维护当前可收集的跳跃加成
3. **关键变量**：
   - `current_jump`：当前跳跃能力
   - `ans`：已收集的加成数量
   - 障碍物按输入顺序处理，能量点按位置排序

### 解决难点
1. **跳跃能力判定**：障碍物长度计算为 `r-l+1`，要求跳跃能力必须 > 障碍长度
2. **离散化优化**：当 L 很大时（如 1e9），将障碍物左端点和能量点位置离散化处理
3. **多测清空**：每组测试数据需重置优先队列和状态变量

---

## 题解评分（≥4星）

### [★★★★☆] _mi_ka_
- **亮点**：采用离散化处理大数据场景，时间复杂度最优
- **代码结构**：清晰的障碍物与能量点分离处理，注释详细
- **优化点**：通过离散化坐标减少无效遍历

### [★★★★☆] cqbzhzf
- **亮点**：栈辅助处理暂存无效能量点，避免重复入队
- **代码简洁性**：直接处理输入顺序，无额外排序操作
- **实践性**：适合输入已有序的场景

### [★★★★☆] ccjjxx
- **亮点**：最精简的代码实现，突出核心逻辑
- **可读性**：使用双指针同步推进障碍物和能量点
- **踩坑提示**：强调多测时队列清空的重要性

---

## 最优思路提炼
1. **贪心选择定理**：跳跃能力必须严格大于障碍长度，每次取最大可用加成
2. **离散化技巧**：将坐标映射到离散索引，降低时间复杂度至 O((n+m)log(n+m))
3. **队列暂存机制**：对当前障碍无效但后续可能有效的能量点用栈暂存

---

## 同类问题套路
1. **跳跃游戏类**：如 LeetCode 55. Jump Game，需要判断能否到达终点
2. **区间覆盖问题**：选择最少区间覆盖目标范围（如洛谷 P1803）
3. **资源调度优化**：在限定条件下选择最优资源（如洛谷 P1090）

---

## 推荐练习题
1. **P1090** [合并果子] - 优先队列基础应用
2. **P1803** [线段覆盖] - 贪心选择右端点
3. **P3943** [星空] - 状态压缩与跳跃能力扩展

---

## 代码核心片段
```cpp
// 选自 _mi_ka_ 题解
priority_queue<int> q;
sort(obstacles, obstacles+n, [](auto& a, auto& b){ return a.l < b.l; });
sort(powerups, powerups+m, [](auto& a, auto& b){ return a.x < b.x; });

int ans = 0, current_jump = 1;
int power_ptr = 0;

for (auto& obs : obstacles) {
    // 收集当前障碍前的所有能量点
    while (power_ptr < m && powerups[power_ptr].x < obs.l) {
        q.push(powerups[power_ptr++].v);
    }
    
    // 处理当前障碍
    while (current_jump <= obs.r - obs.l + 1 && !q.empty()) {
        current_jump += q.top();
        q.pop();
        ans++;
    }
    
    if (current_jump <= obs.r - obs.l + 1) {
        cout << -1 << endl;
        return;
    }
}
```

---

## 可视化设计
**动画方案**：
1. **数轴展示**：Canvas 绘制数轴，红色块表示障碍区间，绿色点表示能量点
2. **跳跃能力条**：动态显示当前跳跃能力长度
3. **队列可视化**：右侧面板实时显示优先队列中的能量值
4. **操作高亮**：
   - 黄色高亮：当前处理的障碍物
   - 闪烁效果：被拾取的能量点
   - 红色警示：当队列空且无法突破障碍时

**复古特效**：
- 8-bit 音效：收集能量点时播放"coin.wav"，失败时播放"error.wav"
- 像素风格：障碍物用16x16像素块，能量点用闪烁的星星图标
- 自动演示：按空格键切换手动/自动模式，方向键控制演示速度

---

## 总结
本题通过贪心策略与优先队列的经典组合，展现了在动态资源选择问题中的高效解法。离散化技巧的引入大幅优化了大数据处理效率，而清晰的代码结构设计（如双指针同步推进）则保证了算法的可维护性。同类问题中，抓住"每次选择最优局部解"这一核心思想，配合恰当的数据结构，往往能迎刃而解。

---
处理用时：119.17秒
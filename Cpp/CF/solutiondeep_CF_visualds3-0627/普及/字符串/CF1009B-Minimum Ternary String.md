# 题目信息

# Minimum Ternary String

## 题目描述

给定一个由 '0', '1', '2' 组成的字符串  $S$ 。可以交换相邻'0', '1'或'1', '2'的位置（例如：'12' - '21'  $\;$  '01' - '10'）请输出原字符串经过任意转换后字典序最小的字符串。原字符串长度不超过  $10^5$ 。

## 样例 #1

### 输入

```
100210
```

### 输出

```
001120
```

## 样例 #2

### 输入

```
11222121
```

### 输出

```
11112222
```

## 样例 #3

### 输入

```
20
```

### 输出

```
20
```

# AI分析结果



# 算法分类
**贪心算法**

---

## 综合分析与结论

### 核心思路与算法流程
**核心观察**：  
- 字符 '1' 可以自由移动（因为可交换相邻的 0/1 和 1/2）  
- 字符 '0' 和 '2' 的相对顺序不可改变（无法直接交换）

**算法流程**：  
1. 提取原字符串中所有非 '1' 字符（保留原始顺序）  
2. 找到第一个 '2' 的位置 `pos`  
3. 将所有 '1' 插入到 `pos` 前（若无 '2'，则插入到末尾）  
4. 输出结果  

**解决难点**：  
- 正确识别 '1' 的可移动性  
- 推导出 '0' 和 '2' 的相对顺序不可变  
- 贪心策略的数学证明（插入到第一个 '2' 前最优）

### 可视化设计要点
1. **动画流程**：  
   - 原始字符串分解为 0/2 的固定序列和 1 的集合  
   - 红色高亮第一个 '2' 的位置  
   - 绿色方块（代表 '1'）集体飞入第一个 '2' 前  
   - 若无 '2'，绿色方块飞入末尾  

2. **复古像素风格**：  
   - 字符用 16x16 像素块表示：0（蓝色）、1（绿色）、2（红色）  
   - 移动动画使用逐帧位移（类似红白机 RPG 的菜单滑动效果）  
   - 音效：插入时播放 "blip" 声，完成时播放 "success" 音效  

3. **交互控制**：  
   - 步进按钮：逐帧观察插入过程  
   - 速度滑块：调节动画速度（1x/2x/5x）  
   - 重置按钮：重新随机生成测试样例  

---

## 题解评分 (≥4星)

### 1. [shurongwang] ⭐⭐⭐⭐⭐  
**亮点**：  
- 直接使用字符串操作，逻辑简洁  
- 代码清晰，`insert` 函数一步到位  
- 时间复杂度 O(n)，完美处理 1e5 数据  

### 2. [Fearliciz] ⭐⭐⭐⭐  
**亮点**：  
- 边遍历边输出，无需额外存储  
- 使用 `flag` 标记第一个 '2'，空间效率更优  
- 代码行数最少（仅 18 行）  

### 3. [小闸蟹] ⭐⭐⭐⭐  
**亮点**：  
- 分情况处理无 '2' 的特殊场景  
- 统计变量命名清晰（`One`/`Zero`/`HasTwo`）  
- 完整注释，适合教学  

---

## 最优思路与技巧

### 关键技巧
1. **1 的可移动性分析**：  
   通过交换规则推导出 '1' 可以到达任意位置，是解题突破口  

2. **贪心插入点选择**：  
   字典序最小的策略是将所有 '1' 集中在第一个 '2' 前（若无 '2' 则末尾）  

3. **O(n) 单次遍历**：  
   统计 '1' 数量 + 定位第一个 '2'，避免多次字符串拼接  

### 实现优化
```cpp
// 核心代码片段（Fearliciz 实现）
string c; bool flag=1; 
cin>>c; int cnt1=0;
for(char ch : c) if(ch=='1') cnt1++;
for(char ch : c){
    if(ch=='1') continue;
    if(ch=='2' && flag){ 
        cout << string(cnt1, '1'); // 直接生成 1 的序列
        cout<<'2'; flag=0;
    }
    else cout<<ch;
}
if(flag) cout << string(cnt1, '1'); // 处理无 '2' 情况
```

---

## 相似题目推荐
1. [CF1144D - Equalize Them All](https://codeforces.com/problemset/problem/1144/D)  
   （贪心策略与元素移动）  

2. [LeetCode 670 - Maximum Swap](https://leetcode.com/problems/maximum-swap/)  
   （字典序最大化与位置交换）  

3. [洛谷 P1106 - 删数问题](https://www.luogu.com.cn/problem/P1106)  
   （贪心删除策略求最小序列）  

---

## 可视化代码片段（JavaScript）
```javascript
// Canvas 绘制核心逻辑（伪代码）
function drawStep(ctx, str, pos, ones) {
  ctx.clearRect(0, 0, W, H);
  let x = 50;
  // 绘制原始 0/2 序列
  for (let i=0; i<str.length; i++) {
    if (i === pos) { // 高亮插入点
      drawRect(x, 100, 30, 30, "yellow");
      x += 10;
    }
    drawChar(str[i], x, 100);
    x += 40;
  }
  // 绘制飞入的 1
  let y = 200 - Math.sin(Date.now()/200)*50; // 上下浮动动画
  drawText("1".repeat(ones), 50 + pos*40, y, "green");
}

// 音效触发
function playSound(type) {
  if (type === 'insert') new Audio('blip.wav').play();
  if (type === 'finish') new Audio('success.wav').play();
}
```

---
处理用时：76.57秒
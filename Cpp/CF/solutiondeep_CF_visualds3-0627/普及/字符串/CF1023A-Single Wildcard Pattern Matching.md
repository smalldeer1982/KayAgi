# 题目信息

# Single Wildcard Pattern Matching

## 题目描述

给定两个小写英文单词 $s,t$，其中 $s$ 包含还不多于一个的 `*`。$s$ 的长度为 $n$，而 $t$ 的长度为 $m$。

$s$ 中的 `*` 可以被替换为任意小写字母串（可以是空串），但其他字母不能被更改或者调换顺序。如果将 `*` 替换为一个任意小写字母串之后，$s=t$，那么我们称 $s,t$ 是匹配的。

例如，字符串 $s=$ `lu*gu` 与 `luogu` `lugu` `luooooogu`都是匹配的，但与字符串 `lougu` `log` `lu^_^gu` `lu114514gu` 都是不匹配的。

如果给定的 $s,t$ 是匹配的，输出 `YES`，否则输出 `NO`。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,m\le2\times10^5$。

$\mathrm{by\ @}$[$\mathrm{Fish\_Know\_Forever}$](/user/663215)

## 样例 #1

### 输入

```
6 10
code*s
codeforces
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
6 5
vk*cup
vkcup
```

### 输出

```
YES
```

## 样例 #3

### 输入

```
1 1
v
k
```

### 输出

```
NO
```

## 样例 #4

### 输入

```
9 6
gfgf*gfgf
gfgfgf
```

### 输出

```
NO
```

# AI分析结果



---

## **算法分类**  
字符串处理

---

## **题解思路与算法要点**  
### **核心思路**  
1. **分割处理**：将字符串 `s` 按 `*` 分割为前缀和后缀两部分，确保 `t` 的前缀匹配 `s` 的前缀，后缀匹配 `s` 的后缀。  
2. **长度验证**：`t` 的长度必须至少为 `s` 去掉 `*` 后的长度（即 `m ≥ n - 1`）。  
3. **边界特判**：处理 `s` 中无 `*` 的情况，直接判断 `s == t`。

### **解决难点**  
1. **高效匹配**：通过双指针或字符串截取实现 O(n) 时间复杂度。  
2. **边界条件**：  
   - `*` 在开头或末尾时需正确处理前后缀为空的情况。  
   - `t` 的长度不足时的快速判断。

---

## **题解评分 (≥4星)**  
1. **小闸蟹的题解**（⭐⭐⭐⭐⭐）  
   - **亮点**：直接分割前缀和后缀，代码简洁高效，逻辑清晰。  
   - **代码**：通过 `substr` 快速截取并比较，无冗余操作。  

2. **2012zxt的题解**（⭐⭐⭐⭐）  
   - **亮点**：使用 `substr` 拼接并比较，逻辑明确。  
   - **优化**：特判 `n > m + 1` 提前返回，节省时间。  

3. **StudyingFather的题解**（⭐⭐⭐⭐）  
   - **亮点**：双指针前后扫描，避免字符串截取开销。  
   - **注意**：需处理循环条件潜在越界问题。  

---

## **最优思路与技巧**  
1. **关键步骤**：  
   - 找到 `*` 的位置，分割 `s` 为 `prefix` 和 `suffix`。  
   - 验证 `t` 的前 `len(prefix)` 字符与 `prefix` 匹配，后 `len(suffix)` 字符与 `suffix` 匹配。  
   - 确保 `m ≥ n - 1`。  

2. **代码片段**（小闸蟹的题解核心逻辑）：  
   ```cpp  
   auto Pos = Str1.find('*');  
   for (int i = 0; i < Pos; ++i) // 前缀匹配  
   for (int i = n - 1, j = m - 1; i > Pos; --i, --j) // 后缀匹配  
   ```  

---

## **同类题目与算法套路**  
1. **通配符匹配**（LeetCode 44）：`*` 匹配任意字符串，`?` 匹配单个字符。  
2. **前后缀匹配**：如判断回文串、子序列等。  
3. **洛谷推荐题目**：  
   - P1305 新二叉树（字符串构建）  
   - P3375 KMP 字符串匹配（前缀处理）  
   - P1055 ISBN 号码（字符串验证）  

---

## **个人心得摘录**  
- **happybob**：尝试正则表达式但因性能问题放弃，最终回归双指针。  
- **Chinshyo**：错误处理循环条件导致逻辑漏洞，强调边界检查的重要性。  

---

## **可视化与算法演示**  
### **动画方案**  
1. **像素风格展示**：  
   - **颜色标记**：`s` 前缀（绿色）、后缀（蓝色），`*`（红色），`t` 中间部分（黄色）。  
   - **Canvas 绘制**：字符串按字符块排列，动态高亮匹配过程。  

2. **交互设计**：  
   - **步进控制**：点击按钮逐步匹配前缀和后缀。  
   - **音效**：匹配成功（↑音调），失败（↓音调）。  

### **演示逻辑**  
1. **分割 `s`**：高亮 `*` 并分割为前后两部分。  
2. **前缀匹配**：逐字符比较 `s` 前缀和 `t` 开头，绿色标记匹配字符。  
3. **后缀匹配**：从尾部逐字符比较，蓝色标记匹配字符。  
4. **结果判定**：若前后缀均匹配且长度合法，显示 `YES` 并播放成功音效。  

---

## **代码实现（小闸蟹的题解）**  
```cpp  
#include <iostream>  
#include <string>  

int main() {  
    std::ios::sync_with_stdio(false);  
    std::cin.tie(nullptr);  
    int n, m;  
    std::cin >> n >> m;  
    std::string s, t;  
    std::cin >> s >> t;  

    if (n > m + 1) {  
        std::cout << "NO\n";  
        return 0;  
    }  

    size_t star_pos = s.find('*');  
    if (star_pos == std::string::npos) {  
        std::cout << (s == t ? "YES\n" : "NO\n");  
        return 0;  
    }  

    // 前缀和后缀匹配  
    std::string prefix = s.substr(0, star_pos);  
    std::string suffix = s.substr(star_pos + 1);  

    if (t.substr(0, star_pos) != prefix ||  
        t.substr(m - suffix.size()) != suffix) {  
        std::cout << "NO\n";  
    } else {  
        std::cout << "YES\n";  
    }  
    return 0;  
}  
```  

--- 

通过上述分析，该题的核心在于高效分割和匹配前后缀，避免冗余操作，最终达到线性时间复杂度。

---
处理用时：97.74秒
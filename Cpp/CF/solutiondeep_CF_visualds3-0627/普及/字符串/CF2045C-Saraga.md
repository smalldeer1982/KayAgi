# 题目信息

# Saraga

## 题目描述

在印尼语中，"sarana olahraga" 是体育设施的意思，缩写为 "saraga"。这个缩写可以通过两种不同的方式组合而成：一种是取 "sarana" 的前缀 "sara" 和 "olahraga" 的后缀 "ga"；另一种是取 "sarana" 的前缀 "sa" 和 "olahraga" 的后缀 "raga"。

如果一个字符串 $S$ 和 $T$ 的缩写有至少两种不同的分割方法，且这些分割能得到一个字符串，使得第一个部分是 $S$ 的前缀，第二个部分是 $T$ 的后缀，我们就称这个缩写是有趣的。

现在，给定两个字符串 $S$ 和 $T$，你需要找出一个最短的有趣缩写，或者判断是否无法构造这样的缩写。

## 说明/提示

样例 1 的解释：

字符串 "saga" 可以分割为 "s" 和 "aga"，或者 "sa" 和 "ga"。因此，"saraga" 和 "saga" 都是有趣的缩写，但 "saga" 更短。

样例 2 的解释：

缩写 "belhijau" 也是一个最短的有趣缩写，所以这个解也是有效的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
sarana
olahraga```

### 输出

```
saga```

## 样例 #2

### 输入

```
berhiber
wortelhijau```

### 输出

```
berhijau```

## 样例 #3

### 输入

```
icpc
icpc```

### 输出

```
icpc```

## 样例 #4

### 输入

```
icpc
jakarta```

### 输出

```
-1```

# AI分析结果



### 算法分类
**字符串处理/贪心算法**

### 题解思路与核心难点
题目要求找到最短的缩写，使得至少有两种分割方式。关键点在于寻找一个中间字符 `c`，使得在 `S` 中存在以 `c` 结尾的前缀，且在 `T` 中存在以 `c` 开头的后缀。通过预处理 `S` 和 `T` 中每个字符的最短前缀和后缀长度，可以快速计算所有可能的组合，并选择总和最小的作为答案。

#### 核心步骤：
1. **预处理 `S`**：记录每个字符作为前缀结尾的最短前缀长度。
2. **预处理 `T`**：记录每个字符作为后缀开头的最短后缀长度。
3. **枚举所有字符**，找到前缀与后缀长度之和的最小值。

#### 难点与解决：
- **如何高效找到最短前缀/后缀**：通过遍历字符串并记录每个字符的首次出现位置。
- **避免重复计算**：预处理时只记录第一次出现的字符位置，确保最短长度。

### 题解评分（≥4星）
1. **lfxxx的题解（5星）**  
   - 思路清晰，预处理步骤明确，代码简洁高效。
   - 使用贪心策略直接选择最优字符，时间复杂度为线性。
   - 代码可读性强，变量命名合理，适合快速理解。

2. **SuyctidohanQ的题解（4星）**  
   - 与lfxxx思路一致，但代码细节略有不同（如循环范围）。
   - 预处理逻辑正确，但注释较少，可读性稍弱。

### 最优思路提炼
**关键技巧**：  
- **预处理字符位置**：快速查询每个字符在 `S` 的前缀和 `T` 的后缀中的最短位置。
- **贪心选择**：枚举所有字符的组合，直接计算最小值，避免复杂的动态规划。

### 同类型题思路
类似问题通常涉及字符串的快速匹配或前后缀重叠处理，例如：
- 最长公共前后缀问题（KMP算法）。
- 字符串拼接的最优选择（贪心或动态规划）。

### 推荐题目
1. **P3375（KMP模板题）**  
2. **P1090（合并字符串的最小代价，贪心）**  
3. **P2870（最短双串生成，前后缀重叠）**

### 代码实现（核心逻辑）
```cpp
#include<bits/stdc++.h>
using namespace std;
int pre[26], suf[26];
string S, T;

int main() {
    memset(pre, 0x3f, sizeof(pre));
    memset(suf, 0x3f, sizeof(suf));
    cin >> S >> T;
    // 预处理S的前缀
    for (int i = 2; i <= S.size(); i++) {
        char c = S[i-1];
        if (pre[c-'a'] == 0x3f) pre[c-'a'] = i;
    }
    // 预处理T的后缀
    for (int i = T.size()-1; i >= 1; i--) {
        char c = T[i-1];
        if (suf[c-'a'] == 0x3f) suf[c-'a'] = T.size() - i + 1;
    }
    // 计算最小长度
    int ans = 0x3f3f3f3f;
    for (int c = 0; c < 26; c++)
        ans = min(ans, pre[c] + suf[c]);
    // 输出结果
    if (ans >= 0x3f3f3f3f) cout << "-1";
    else {
        for (int c = 0; c < 26; c++) {
            if (pre[c] + suf[c] == ans) {
                cout << S.substr(0, pre[c]);
                cout << T.substr(T.size() - suf[c], suf[c]);
                break;
            }
        }
    }
    return 0;
}
```

### 可视化设计
**动画方案**：
1. **字符标记**：高亮 `S` 和 `T` 中被选中的字符 `c`，显示其对应的前缀和后缀。
2. **步进控制**：逐步展示预处理过程，对比不同字符的组合结果。
3. **复古像素风格**：用8位色块表示字符串，音效提示每一步操作。

**交互设计**：
- **Canvas绘制**：字符串显示为像素网格，选中字符时闪烁。
- **音效**：正确匹配时播放上升音调，错误或无解时播放低沉音效。

---

### 结论
通过预处理和贪心策略，题解高效地解决了最短有趣缩写问题。核心在于快速定位字符的公共前后缀，结合字符串处理技巧，实现线性时间复杂度。

---
处理用时：510.77秒
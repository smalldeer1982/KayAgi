# 题目信息

# Two TVs

## 题目描述

Polycarp 很喜欢看电视。

他写下了他今天所有感兴趣的共   $n\,(1 \le n \le 2 \times 10^5)$ 个电视节目。其中第   $i$ 个电视节目在   $l_i$ 时开始，  $r_i$ 时结束。  $\,(0 \le l_i, r_i \le 10^9)$

Polycarp 有两个电视。他可以同时在两台电视上看两种不同的节目，但他不能在一台电视上同时看两个不同的节目。如果一个节目结束时另一个节目刚好开始，则他不能在一台电视上看这两个节目。他想看完这   $n$ 个节目，请问两台电视足够吗？

## 样例 #1

### 输入

```
3
1 2
2 3
4 5
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4
1 2
2 3
2 3
1 2
```

### 输出

```
NO
```

# AI分析结果



## 唯一算法分类
贪心算法

## 综合分析与结论

### 核心思路与难点
题目核心在于判断能否用两台电视无冲突地播放所有节目。关键在于处理两个问题：
1. **区间重叠检测**：同一时间点不能有超过两个节目同时进行
2. **连续播放限制**：同一电视的节目结束时间不能等于下一个节目开始时间

### 题解思路对比
1. **贪心模拟法**（4526_、Dawn_Chase）：
   - 按开始时间排序节目
   - 维护两个变量表示电视的最早可用时间
   - 依次尝试将节目分配给任意一个可用电视
   - 时间复杂度 O(n log n)，空间 O(1)
   - **关键难点**：需证明贪心选择策略的正确性，即后续节目不会因当前分配顺序而无法处理

2. **覆盖次数统计法**（Minecraft万岁、寒冰大大）：
   - 离散化处理节目时间点
   - 差分数组统计每个时间点的覆盖次数
   - 判断最大覆盖次数是否超过2
   - 时间复杂度 O(n log n)，空间 O(n)
   - **关键难点**：正确处理闭区间端点，需将节目区间转为左闭右开 [l, r+1)

### 可视化设计
1. **贪心模拟动画**：
   - **时间轴**：水平轴表示时间，垂直轴表示两台电视
   - **颜色标记**：当前处理的节目高亮黄色，已分配电视标记为蓝/绿色
   - **状态更新**：每次分配后更新电视的结束时间标记
   - **冲突检测**：当节目无法分配时，用红色闪烁提示

2. **复古像素风格**：
   - **8-bit 元素**：电视图标用 16x16 像素块，节目条用不同颜色像素带
   - **音效设计**：
     - 分配成功：短促 "哔" 声（8-bit 音效）
     - 冲突发生：低沉错误音
     - 背景音乐：循环 8-bit 风格芯片音乐

## 题解清单（≥4星）

### 4526_（⭐⭐⭐⭐⭐）
- **关键亮点**：代码简洁，维护双变量清晰体现贪心思想
- **心得引用**："根据生活经验排序节目单" 强调排序的重要性
- **代码片段**：
  ```cpp
  if(pros[i].l>tv1) tv1=pros[i].r;
  else if(pros[i].l>tv2) tv2=pros[i].r;
  ```

### Minecraft万岁（⭐⭐⭐⭐）
- **关键亮点**：离散化差分法直接揭示问题数学本质
- **心得引用**："最大覆盖次数>2则必然无解" 点明核心判断条件
- **代码片段**：
  ```cpp
  a[++hp].p=l; a[hp].val=1;
  a[++hp].p=r+1; a[hp].val=-1;
  ```

### 寒冰大大（⭐⭐⭐）
- **关键亮点**：线段树实现展示通用区间处理方法
- **优化建议**：可改用差分数组降低实现复杂度

## 最优思路提炼
**贪心策略**：
1. 按开始时间升序排序节目
2. 维护两台电视的最晚可用时间 `tv1` 和 `tv2`
3. 对每个节目：
   - 若无法放入任一电视，直接返回 NO
   - 否则放入可用时间更早的电视，更新其结束时间

**数学本质**：最大区间重叠数 ≤2，可通过差分数组高效计算

## 相似题目推荐
1. P1250 种树（差分约束）
2. P2885 [USACO07NOV]电话线（贪心+优先队列）
3. CF1029C Maximal Intersection（区间交集处理）

## 可视化代码片段（Canvas 绘制核心）
```javascript
// 绘制时间轴与节目分配
function drawTV(tv1End, tv2End, currentShow) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制时间轴基线
  drawLine(50, 100, 650, 100, '#333'); 
  // 绘制电视1状态
  drawRect(50, 150, 600, 50, tv1End > currentShow.l ? 'red' : 'green');
  // 绘制当前节目高亮动画
  animateHighlight(currentShow);
}
```

---
处理用时：219.80秒
# 题目信息

# pSort

## 题目描述

给定一个长度为 $n$ 的数列 $\{a_n\}$，初始时 $\{a_n\} = \{1, 2, \dots, n\}$。位置 $i$ 上的数可以和位置 $i \pm d_i$ 上的数交换。给定一个 $1 \sim n$ 的全排列，问初始的数列可否交换成给定的形式。

## 说明/提示

$1 \le n \le 100$

## 样例 #1

### 输入

```
5
5 4 3 2 1
1 1 1 1 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
7
4 3 5 1 2 7 6
4 6 6 1 6 6 1
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
7
4 2 5 1 3 7 6
4 6 6 1 6 6 1
```

### 输出

```
YES
```

# AI分析结果



### **算法分类**  
并查集（Union-Find）  

---

### **题解思路、算法要点与解决难点**  
**核心逻辑**：判断每个位置能否通过交换规则到达目标位置对应的位置。  
**关键实现**：  
1. **并查集**：将每个位置与其可达的位置合并为一个连通分量。  
2. **连通性检查**：若初始位置与目标位置的数在同一个连通分量中，则可达。  

**解决难点**：  
- **交换规则的传递性**：多次交换可形成连通块，需通过并查集维护连通性。  
- **边界处理**：合并时需要确保 `i ± d_i` 不越界。  

---

### **题解评分 (≥4星)**  
1. **赤霞QvQ（5星）**  
   - 思路清晰，通过并查集直接解决连通性问题。  
   - 代码简洁，边界处理明确，可读性高。  
   - 结合样例逐步推导，逻辑严谨。  

2. **Mistybranch（4星）**  
   - 图解清晰，用图论连通块思想解释问题。  
   - 代码规范，注释详细，适合新手理解。  

3. **Error_Eric（4星）**  
   - 提出DFS替代并查集的思路，时间复杂度更优。  
   - 代码简洁，用颜色标记连通块，实现巧妙。  

---

### **最优思路或技巧提炼**  
1. **并查集的核心应用**：将位置间的可达关系抽象为连通性问题，通过合并和查询操作高效解决。  
2. **DFS/BFS替代方案**：通过遍历标记连通块，验证每个位置是否在目标连通块内。  
3. **Floyd算法求传递闭包**：构建可达矩阵，检查所有位置的可达性（适合小数据范围）。  

---

### **同类型题或类似算法套路**  
1. **连通性问题**：如判断图的连通性、社交网络中的关系传递。  
2. **交换排序问题**：如通过特定交换规则使数组有序。  

---

### **推荐相似题目**  
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)  
2. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)  
3. [P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294)  

---

### **个人心得摘录**  
- **赤霞QvQ**：通过样例推导发现并查集特性，强调“传递性”的重要性。  
- **Error_Eric**：“虽然并查集很帅，但DFS更快”体现算法选择的灵活性。  

---

### **可视化与算法演示**  
**动画方案**：  
1. **并查集合并过程**：  
   - **像素网格**：每个位置为像素块，初始颜色不同。  
   - **合并动画**：当合并两个位置时，其颜色渐变统一。  
   - **音效触发**：合并时播放“哔”声，成功时播放“叮咚”音效。  
2. **DFS遍历演示**：  
   - **高亮当前访问节点**，递归时扩散颜色，标记连通块。  
3. **Floyd算法传递闭包**：  
   - 动态显示可达矩阵，逐步填充可达标记。  

**复古游戏化设计**：  
- **8位音效**：使用Chip-tune风格音效，合并成功时播放胜利音乐。  
- **Canvas动画**：用16x16像素块表示位置，合并时显示“连接线”。  
- **自动演示模式**：模拟贪吃蛇移动，自动遍历所有合并操作。  

---

### **核心代码实现**  
```cpp
// 并查集实现（赤霞QvQ）
#include<bits/stdc++.h>
using namespace std;
int n, fa[105], f[105], d[105];

int father(int x) {
    if (fa[x] != x) fa[x] = father(fa[x]);
    return fa[x];
}

void un(int x, int y) {
    int u = father(x), v = father(y);
    if (u != v) fa[u] = v; 
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> f[i], fa[i] = i;
    for (int i = 1; i <= n; i++) {
        cin >> d[i];
        if (i > d[i]) un(i, i - d[i]);
        if (i + d[i] <= n) un(i, i + d[i]);
    }
    for (int i = 1; i <= n; i++) {
        if (father(i) != father(f[i])) {
            cout << "NO";
            return 0;
        }
    }
    cout << "YES";
    return 0;
}
```

---

### **总结**  
通过并查集维护位置可达性是最优解，时间复杂度为接近线性的 O(n α(n))，适合本题数据范围。可视化设计可结合复古像素风格，增强学习趣味性。

---
处理用时：62.39秒
# 题目信息

# Medium Demon Problem (easy version)

## 题目描述

这是问题的简化版。两个版本之间的关键区别以粗体显著标出。

有一群 $n$ 只蜘蛛聚在一起交换他们的毛绒玩具。最初，每只蜘蛛都有 $1$ 个毛绒玩具。每年，如果第 $i$ 只蜘蛛拥有至少一个毛绒玩具，它就会给第 $r_i$ 只蜘蛛一个毛绒玩具。否则，它将不会进行任何操作。注意，所有的毛绒玩具转移是同时进行的。在这个版本中，如果一只蜘蛛在任意时刻拥有超过 $1$ 个毛绒玩具，它们会丢掉多余的，只保留一个。

如果在某年开始时，每只蜘蛛拥有的毛绒玩具数量与上一年相同，则这一年的过程是稳定的。请注意，第 $1$ 年永远不会是稳定的。

请找出该过程中首次出现稳定的年份。

## 说明/提示

对于第二个测试用例：

- 在第 $1$ 年，每只蜘蛛的毛绒玩具数量为 $[1, 1, 1, 1, 1]$。然后进行当年的交换。
- 到了第 $2$ 年，各蜘蛛的毛绒玩具数量仍然为 $[1, 1, 1, 1, 1]$。由于数量没有变化，因此这一年是稳定的。

对于第三个测试用例：

- 在第 $1$ 年，所有蜘蛛的毛绒玩具数量为 $[1, 1, 1, 1, 1]$。然后进行第 $1$ 年的交换。
- 在第 $2$ 年，这些数量变为 $[1, 1, 1, 1, 0]$ 。然后进行第 $2$ 年的交换。即便有两只蜘蛛给了第 $2$ 只蜘蛛毛绒玩具，第 $2$ 只蜘蛛也只能保留一个。
- 到第 $3$ 年，数量变为 $[1, 1, 0, 1, 0]$。然后进行交换。
- 第 $4$ 年，数量变为 $[1, 1, 0, 0, 0]$。然后进行交换。
- 第 $5$ 年，数量仍然为 $[1, 1, 0, 0, 0]$。由于数量保持不变，这一年是稳定的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2
2 1
5
2 3 4 5 1
5
2 1 4 2 3
5
4 1 1 5 4
10
4 3 9 1 6 7 9 10 10 3```

### 输出

```
2
2
5
4
5```

# AI分析结果



### 唯一算法分类  
基环树与拓扑排序  

---

### 题解思路与算法要点  

1. **核心思路**  
   - 将蜘蛛的传递关系建模为有向图（每个蜘蛛指向其传递目标）。  
   - 通过拓扑排序剥离环外节点（非环结构的链），最终稳定的状态必然仅剩环内节点。  
   - 计算环外链的最长传递路径长度，确定稳定年份。  

2. **算法流程**  
   - **建图**：每个蜘蛛 i 指向 r_i，统计各节点的入度。  
   - **拓扑排序**：处理入度为 0 的节点（链的起点），逐层剥离环外结构。  
   - **动态规划**：记录每个节点的深度（最长链长度），通过转移方程 `dp[to] = max(dp[to], dp[from] + 1)` 更新。  
   - **结果计算**：最长链长度 + 2（年份调整）。  

3. **解决难点**  
   - **环的识别**：拓扑排序后剩余未处理的节点即为环内节点。  
   - **年份推导**：最长链经过 k 次传递后，第 k+2 年状态稳定（初始传递从第 1 年开始）。  

---

### 题解评分 (≥4星)  

1. **Deng_Rui_Song (5星)**  
   - **亮点**：详细图解基环树与拓扑排序的关系，代码简洁高效，逻辑清晰。  
   - **代码**：通过拓扑排序计算最大深度，最终返回 `ans + 3`（正确推导年份调整）。  

2. **Anby_ (4星)**  
   - **亮点**：简明代码实现，动态维护节点深度，直接输出 `ans + 2`。  
   - **优化**：使用队列处理入度为 0 的节点，避免递归开销。  

3. **zyhe2013 (4星)**  
   - **亮点**：队列存储时间戳，逐步更新目标节点的稳定年份。  
   - **心得**：通过样例调试发现初始年份应为 2。  

---

### 最优思路与技巧  

1. **关键技巧**  
   - **基环树建模**：将蜘蛛传递关系视为基环森林，环内节点稳定，环外节点逐步失效。  
   - **拓扑排序优化**：通过入度剥离链结构，避免直接处理复杂环结构。  
   - **动态规划转移**：用 `dp[i]` 记录节点 i 的最长链深度，确保正确计算传递步骤。  

2. **代码实现核心**  
```cpp
// 拓扑排序核心代码（Deng_Rui_Song 实现）
int topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) 
        if (!in[i]) q.push(i);
    int ans = -1;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        ans = max(ans, dp[x]);
        for (int nxt : g[x]) {
            dp[nxt] = max(dp[nxt], dp[x] + 1);
            if (--in[nxt] == 0) q.push(nxt);
        }
    }
    return ans + 3; // 调整年份
}
```

---

### 类似题目推荐  

1. **P2661 [NOIP2015 提高组] 信息传递**  
   - **关键词**：最小环检测，基环树应用。  
2. **P3388 【模板】割点**  
   - **关键词**：图论基础，环与连通性分析。  
3. **P1113 杂务**  
   - **关键词**：拓扑排序求最长路径，依赖关系处理。  

---

### 个人心得摘录  

- **Deng_Rui_Song**：  
  > “拓扑排序能找环（你不会不知道吧）”——调试中发现初始年份调整错误，通过样例反推正确公式为 `ans + 3`。  
- **zyhe2013**：  
  > “初始年份设为 2，处理完队列后最大值加 1”——通过测试用例验证年份计算逻辑。  

---

### 算法可视化设计  

**动画方案设计**：  

1. **像素风格界面**  
   - **颜色方案**：环内节点用绿色（稳定），链节点用红色（逐步剥离），当前处理节点高亮黄色。  
   - **Canvas 绘制**：蜘蛛节点显示为像素方块，箭头表示传递方向，动态更新颜色与连接线。  

2. **关键步骤演示**  
   - **初始状态**：所有节点为红色，显示初始玩具数量为 1。  
   - **拓扑处理**：入度为 0 的节点变为黄色，处理时播放“点击”音效，传递后变为灰色（无玩具）。  
   - **环识别**：剩余绿色节点自动闪烁，标记稳定状态。  

3. **交互控制**  
   - **速度调节**：滑动条控制动画速度（0.5x~3x）。  
   - **步进模式**：点击“下一步”单步执行拓扑排序。  
   - **自动演示**：AI 模式自动完成所有步骤，背景音乐为 8-bit 循环旋律。  

**音效设计**：  
- **节点处理**：短促“哔”声。  
- **稳定状态**：上扬音调提示。  
- **错误操作**：低沉“嗡”声。  

---

**可视化示例代码（JS 伪代码）**  
```javascript
// Canvas 绘制基环树
function drawGraph(nodes, edges) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    nodes.forEach(node => {
        drawNode(node.x, node.y, node.color);
    });
    edges.forEach(edge => {
        drawArrow(edge.from, edge.to);
    });
}

// 拓扑排序动画
function animateTopo() {
    let current = queue.shift();
    highlightNode(current, 'yellow');
    playSound('beep');
    setTimeout(() => {
        processNode(current);
        drawGraph();
        if (queue.length > 0) animateTopo();
    }, speed);
}
```

---
处理用时：129.58秒
# 题目信息

# DIY

## 题目描述

给定一个长度为 $n$ 的整数数列 $a$，下标从 $1$ 到 $n$。你需要从 $a$ 中选择 $8$ 个下标互不相同的数 $x1,y1,x2,y2,x3,y3,x4,y4$，并使 $(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)$ 成为一个长方形的四个点的坐标。请构造一种方案使得此长方形面积最大，或报告无解。

## 样例 #1

### 输入

```
3
16
-5 1 1 2 2 3 3 4 4 5 5 6 6 7 7 10
8
0 0 -1 2 2 1 1 3
8
0 0 0 0 0 5 0 5```

### 输出

```
YES
1 2 1 7 6 2 6 7
NO
YES
0 0 0 5 0 0 0 5```

# AI分析结果



# 算法分类选择  
**贪心算法**

---

## 题解思路、算法要点与解决难点  

### 核心逻辑与难点  
1. **问题转化**：矩形需满足两组不同的 x 坐标和两组不同的 y 坐标，且每个坐标至少出现两次。  
2. **统计频率**：使用 `map` 统计每个数出现次数，筛选出出现次数 ≥2 的数作为候选。  
3. **极值选择**：对候选数排序后取最小、次小、最大、次大，构造最大面积矩形。  
4. **坐标组合**：选择两组极值（如最小和最大）作为矩形的对角点，计算面积。  

**难点对比**：  
- **数据重复处理**：部分题解（如 WangYongkai__AFO）在统计时清零计数，避免重复选择同一数。  
- **极值组合优化**：xxxalq 的题解比较不同极值组合的面积，确保最优解。  
- **坐标输出顺序**：需保证四个点的坐标正确对应矩形顶点，防止输出顺序错误。  

---

## 题解评分 (≥4星)  
1. **WangYongkai__AFO（5星）**  
   - **亮点**：思路简洁，直接统计可用数并排序取极值，代码清晰。  
   - **代码可读性**：使用 `map` 和 `vector` 实现，逻辑明确。  

2. **xxxalq（4星）**  
   - **亮点**：通过 `multiset` 动态管理候选数，优化极值组合选择。  
   - **改进点**：代码中组合比较逻辑稍显复杂。  

3. **ivyjiao（4星）**  
   - **亮点**：快速筛选候选数，直接排序后输出极值组合。  
   - **改进点**：未处理某些极端情况（如候选数数量刚好为4）。  

---

## 最优思路或技巧提炼  
1. **频率统计清零法**：在统计出现次数时，若某数出现次数 ≥2，立即清零其计数，避免重复选取。  
2. **极值组合比较**：面积计算为 `(max2 - min1) * (max1 - min2)`，需遍历所有可能的极值组合。  
3. **动态候选管理**：使用 `multiset` 或排序后的 `vector` 快速获取极值。  

---

## 同类型题与算法套路  
- **相似问题**：统计元素频率后构造极值组合（如最大矩形、最大差值对）。  
- **通用解法**：  
  - **频率筛选**：用哈希表统计可用元素。  
  - **排序取极值**：对候选元素排序后取头尾极值。  

---

## 推荐洛谷题目  
1. **P4147 玉蟾宫**（最大矩形面积）  
2. **P1102 A-B数对**（统计数对频率）  
3. **P1631 序列合并**（极值组合优化）  

---

## 个人心得摘录  
- **WangYongkai__AFO** 提到 `map` 避免数组越界的教训，强调数据范围的重要性。  
- **GCSG01** 的调试中发现极值组合需避免重复选取同一数。  

---

## 可视化与算法演示  
### 核心流程演示  
1. **统计频率**：  
   - 数组元素高亮显示，出现次数 ≥2 的元素标记为绿色。  
   - 动态显示 `map` 的计数过程。  
2. **排序候选数**：  
   - 候选数列以柱状图排序，最小/最大值用红色/蓝色标记。  
3. **选择极值组合**：  
   - 动态连线四个极值点，计算面积并显示公式。  

### 复古像素风格设计  
- **元素表示**：每个数用 8x8 像素块表示，颜色深浅代表出现次数。  
- **音效设计**：  
  - 选中有效数时播放“叮”声，无解时播放低沉音效。  
- **自动演示模式**：  
  - AI 自动执行频率统计和极值选择，类似贪吃蛇自动寻路。  

---

## 关键代码片段（WangYongkai__AFO）  
```cpp
vector<int> e;
map<int, int> vis;
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    vis[a[i]]++;
    if (vis[a[i]] == 2) { // 统计并清零
        e.push_back(a[i]);
        vis[a[i]] = 0;
    }
}
sort(e.begin(), e.end());
int len = e.size();
cout << e[len-1] << ' ' << e[len-2] << ' '; // 输出极值组合
```

---
处理用时：75.67秒
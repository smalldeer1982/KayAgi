# 题目信息

# Medium Demon Problem (easy version)

## 题目描述

这是问题的简化版。两个版本之间的关键区别以粗体显著标出。

有一群 $n$ 只蜘蛛聚在一起交换他们的毛绒玩具。最初，每只蜘蛛都有 $1$ 个毛绒玩具。每年，如果第 $i$ 只蜘蛛拥有至少一个毛绒玩具，它就会给第 $r_i$ 只蜘蛛一个毛绒玩具。否则，它将不会进行任何操作。注意，所有的毛绒玩具转移是同时进行的。在这个版本中，如果一只蜘蛛在任意时刻拥有超过 $1$ 个毛绒玩具，它们会丢掉多余的，只保留一个。

如果在某年开始时，每只蜘蛛拥有的毛绒玩具数量与上一年相同，则这一年的过程是稳定的。请注意，第 $1$ 年永远不会是稳定的。

请找出该过程中首次出现稳定的年份。

## 说明/提示

对于第二个测试用例：

- 在第 $1$ 年，每只蜘蛛的毛绒玩具数量为 $[1, 1, 1, 1, 1]$。然后进行当年的交换。
- 到了第 $2$ 年，各蜘蛛的毛绒玩具数量仍然为 $[1, 1, 1, 1, 1]$。由于数量没有变化，因此这一年是稳定的。

对于第三个测试用例：

- 在第 $1$ 年，所有蜘蛛的毛绒玩具数量为 $[1, 1, 1, 1, 1]$。然后进行第 $1$ 年的交换。
- 在第 $2$ 年，这些数量变为 $[1, 1, 1, 1, 0]$ 。然后进行第 $2$ 年的交换。即便有两只蜘蛛给了第 $2$ 只蜘蛛毛绒玩具，第 $2$ 只蜘蛛也只能保留一个。
- 到第 $3$ 年，数量变为 $[1, 1, 0, 1, 0]$。然后进行交换。
- 第 $4$ 年，数量变为 $[1, 1, 0, 0, 0]$。然后进行交换。
- 第 $5$ 年，数量仍然为 $[1, 1, 0, 0, 0]$。由于数量保持不变，这一年是稳定的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5
2
2 1
5
2 3 4 5 1
5
2 1 4 2 3
5
4 1 1 5 4
10
4 3 9 1 6 7 9 10 10 3```

### 输出

```
2
2
5
4
5```

# AI分析结果



**唯一算法分类**：拓扑排序

---

### **综合分析与结论**
题目核心在于分析蜘蛛之间的依赖关系，形成有向图。稳定状态对应图中仅剩环结构，非环部分通过拓扑排序逐层消除。关键步骤如下：

1. **建图与入度统计**  
   每个蜘蛛指向的 `r_i` 构成有向边，统计每个节点的入度（被多少节点指向）。  
   **解决难点**：入度为零的节点无法获得新玩具，将在某一轮后失去所有玩具，需要优先处理。

2. **拓扑排序与时间计算**  
   用队列处理入度为零的节点，记录每个节点被处理的“时间”（即稳定所需的轮数）。时间计算为前驱节点的最大时间加1。  
   **关键变量**：`d[i]` 表示节点 `i` 的处理时间，`ans` 记录全局最大值。

3. **最终答案推导**  
   所有非环节点处理完毕后，最大 `d[i] + 2` 即为答案（初始状态为第1年，稳定最早从第2年开始）。

---

### **题解清单 (≥4星)**
1. **FishPressedCoins (4星)**  
   - **亮点**：代码结构清晰，层次化处理队列，每层对应一年的操作。  
   - **关键代码**：`ans++` 表示年份递增，每层处理完队列中所有当前入度为零的节点。

2. **Peaky (4星)**  
   - **亮点**：简洁高效，直接通过入度递减和最大值更新完成时间计算。  
   - **关键代码**：`d[v] = d[u]`（G1版本）或 `d[v] += d[u]`（G2版本），体现两种问题的不同处理逻辑。

3. **wflhx2011 (4星)**  
   - **亮点**：明确区分简单与困难版本，通过 `max` 和 `sum` 不同操作适配两种逻辑。  
   - **关键代码**：`f[v] = max(f[u], f[v])`（G1）与 `f[v] += f[u]`（G2）。

---

### **最优思路与代码片段**
**核心思路**：拓扑排序处理非环节点，计算最长传递链，最大链长+2即为答案。  
**代码实现**（Peaky的G1版本）：
```cpp
void Solve(){
    cin>>n; ans=0;
    memset(inq,0,sizeof(inq));
    memset(d,0,sizeof(d));
    for(int i=1;i<=n;i++) cin>>r[i], inq[r[i]]++;
    queue<int> q;
    for(int i=1;i<=n;i++) if(!inq[i]) q.push(i);
    while(!q.empty()){
        int u=q.front(), v=r[u]; q.pop();
        ans = max(ans, ++d[u]);
        inq[v]--; d[v] = d[u]; // 关键：传递时间
        if(!inq[v]) q.push(v);
    }
    cout<<ans+2<<"\n";
}
```

---

### **同类型题与类似算法**
- **基环树处理**：如环检测、拓扑排序结合环上计算。  
- **动态规划与依赖传递**：如节点时间的最值或累加。  
- **类似题目**：  
  1. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)（基环树找最小环）  
  2. [P2921 [USACO08DEC]Trick or Treat on the Farm](https://www.luogu.com.cn/problem/P2921)（拓扑排序+环处理）  
  3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)（依赖关系与环路检测）

---

### **可视化与算法演示**
**动画设计**：  
1. **像素风格界面**：  
   - 蜘蛛节点用彩色方块表示，边用箭头连接。  
   - **颜色标记**：绿色（未处理）、红色（正在处理）、灰色（已稳定）。  
2. **算法过程演示**：  
   - **步骤1**：高亮入度为零的节点，加入队列，播放“入队音效”。  
   - **步骤2**：处理队列节点，更新其指向节点的入度和时间，播放“传递音效”。  
   - **步骤3**：若节点入度归零，触发“成功音效”并加入队列。  
3. **控制面板**：  
   - 速度调节滑块、暂停/继续按钮、单步执行。  
   - **AI模式**：自动播放，展示最长链的逐步形成过程。  
4. **音效与背景**：  
   - 8-bit背景音乐循环播放，关键操作触发不同音效。  
   - 失败时播放低沉音效，成功时播放欢快音效。

---

**总结**：本题通过拓扑排序剥离非环结构，计算最长传递链确定稳定年份。可视化可通过像素动画直观展示节点处理顺序与时间累积，辅以音效增强交互体验。

---
处理用时：67.30秒
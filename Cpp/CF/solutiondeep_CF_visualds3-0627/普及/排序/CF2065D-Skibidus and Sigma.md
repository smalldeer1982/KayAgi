# 题目信息

# Skibidus and Sigma

## 题目描述

定义一个 $k$ 个元素的数组 $b$ 的分数为
$\sum_{i=1}^{k}\left(\sum_{j=1}^{i}b_j\right)$，也就是说，设 $S_i$ 表示数组 $b$ 的前 $i$ 个元素之和，则分数可以写作
$S_1 + S_2 + \ldots + S_k$。

Skibidus 得到了 $n$ 个数组 $a_1, a_2, \ldots, a_n$，每个数组包含 $m$ 个元素。作为西格玛男人，他希望能将这 $n$ 个数组按任意顺序拼接成一个包含 $n \cdot m$ 个元素的数组，以使最终得到的拼接数组的分数达到最大。请你帮助他计算拼接后能够获得的最大分数！

形式上地说，在所有可能的长度为 $n$ 的排列 $p$ 中，
求出数组 $a_{p_1} + a_{p_2} + \dots + a_{p_n}$ 的最大分数，
其中符号 $+$ 表示数组拼接。

$ ^{\text{∗}} $ 一个排列指的是一个包含 $1$ 到 $n$ 的所有整数且每个整数恰好出现一次的序列。  
$ ^{\text{∗}} $ 两个数组 $c$ 和 $d$（长度分别为 $e$ 和 $f$）的拼接 $c+d$ 定义为 $c_1, c_2, \ldots, c_e, d_1, d_2, \ldots, d_f$。

## 说明/提示

在第一个测试用例中，有可能的两种排列：
- $p = [1, 2]$，拼接后的数组为 $a_{p_1} + a_{p_2} = [4, 4, 6, 1]$，分数为 $4 + (4+4) + (4+4+6) + (4+4+6+1) = 41$。
- $p = [2, 1]$，拼接后的数组为 $a_{p_1} + a_{p_2} = [6, 1, 4, 4]$，分数为 $6 + (6+1) + (6+1+4) + (6+1+4+4) = 39$。  

因此，最大可能分数为 $41$。

在第二个测试用例中，一个最优的拼接结果为 $[4,1,2,1,2,2,2,2,3,2,1,2]$，分数为 $162$。

## 样例 #1

### 输入

```
3
2 2
4 4
6 1
3 4
2 2 2 2
3 2 1 2
4 1 2 1
2 3
3 4 5
1 1 9```

### 输出

```
41
162
72```

# AI分析结果



**唯一算法分类**：贪心、排序

---

### **题解思路、算法要点与解决难点**

**核心思路**  
所有题解均采用**按数组元素和降序排列**的策略，确保高和数组的贡献被多次累加。总分数由两部分构成：
1. 各数组自身的前缀和之和。
2. 每个数组的和对其后所有数组元素的贡献（次数取决于其后数组数量）。

**解决难点**  
- **贡献推导**：正确识别数组顺序对总贡献的影响，需数学推导每个数组的贡献系数。
- **排序策略**：证明按数组和排序的最优性，需通过临项交换法或数学归纳法。

**关键变量与实现**  
- 数组和（`sum`）：决定排序顺序。
- 前缀和之和（`ans_q`）：数组自身贡献。
- 累加和（`sum_prev`）：计算后续数组对当前数组的贡献。

---

### **题解评分 (≥4星)**

1. **nightwatch.ryan (5星)**  
   - **亮点**：直接拼接后计算前缀和，代码简洁高效。  
   - **代码可读性**：高，逻辑清晰。  
   ```cpp
   sort(a.begin(), a.end(), cmp); // 按sum降序排序
   vector<int> all;
   for (auto i : a) for (auto j : i) all.push_back(j);
   ll ans = 0, sum = 0;
   for (int i = 0; i < n * m; i++)
       sum += all[i], ans += sum; // 累加前缀和
   ```

2. **StormWhip (4星)**  
   - **亮点**：分步计算每个数组的贡献，显式维护累加和。  
   - **优化**：避免拼接大数组，节省内存。  
   ```cpp
   struct dis { int p, q; }; // p为和，q为前缀和之和
   sort(a + 1, a + n + 1, cmp);
   for (int i = 1; i <= n; i++)
       ans += a[i].q + a[i - 1].p * m; // 累加贡献
   ```

3. **jzjr (4星)**  
   - **亮点**：数学公式直接实现，逻辑紧凑。  
   - **核心代码**：  
   ```cpp
   sort(a + 1, a + n + 1, cmp);
   for (int i = 1; i <= n; i++)
       ans += ((n - i) * m) * a[i]; // 贡献系数计算
   ```

---

### **最优思路或技巧提炼**

1. **排序策略**：按数组和降序排列，确保高和数组贡献最大化。  
2. **贡献拆分**：总贡献 = 自身前缀和 + 和 × 后续数组数 × 元素数。  
3. **高效计算**：避免拼接大数组，直接分步累加（如StormWhip的代码）。

---

### **同类型题与算法套路**

- **通用解法**：贪心排序问题，常通过临项交换法证明最优性。  
- **类似题目**：任务调度（按截止日期或利润排序）、区间覆盖（按端点排序）。

---

### **推荐题目**

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)  
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格排序**：每个数组显示为颜色块，按和降序排列。  
2. **贡献计算**：高亮当前数组，显示其前缀和之和及后续贡献次数。  
3. **步进控制**：可调节速度，观察排序和累加过程。  

**音效与交互**：  
- **音效**：排序时播放“点击”声，累加时播放“计数”声。  
- **自动演示**：模拟AI自动完成排序和计算，展示最优路径。

---

### **核心代码实现**

**nightwatch.ryan的完整代码**  
```cpp
#include<bits/stdc++.h>
using ll = long long;
bool cmp(std::vector<int> a, std::vector<int> b){
    int s1 = 0, s2 = 0;
    for(auto i : a) s1 += i;
    for(auto i : b) s2 += i;
    return s1 > s2;
}
int main(){
    std::cin.tie(0)->sync_with_stdio(0);
    int T; std::cin >> T;
    while(T--){
        int n, m; std::cin >> n >> m;
        std::vector<std::vector<int>> a(n, std::vector<int>(m));
        for(int i = 0; i < n; i++)
         for(int j = 0; j < m; j++)
          std::cin >> a[i][j];
        sort(a.begin(), a.end(), cmp);
        std::vector<int> all;
        for(auto i : a) for(auto j : i) all.push_back(j);
        ll ans = 0, sum = 0;
        for(int i = 0; i < n * m; i++)
         sum += all[i], ans += sum;
        std::cout << ans << "\n";
    }
}
```

---
处理用时：398.95秒
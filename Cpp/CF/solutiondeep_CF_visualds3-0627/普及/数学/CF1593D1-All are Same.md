# 题目信息

# All are Same

## 题目描述

给定一个包含 $n$（$n$ 是偶数）个整数的数列 $a_1,a_2,\ldots,a_n$。

考虑一个可能的**正整数** $k$，在每次操作中，你可以选定一个 $i$，并将 $a_i$ 减少 $k$。

你可以执行任意多次（也可能是零次）操作，使这个数列中的**每一个数**都相等。

请找出最大的符合条件的 $k$，如果 $k$ 可以是任意的大小，输出 $-1$。

## 说明/提示

- $1 \le t \le 10$；
- $4 \le n \le 40$；
- $-10^6 \le a_i \le 10^6$。

保证 $\sum\limits{n} \le 100$。

Translated by @BurningEnderDragon, 2021.10.14

## 样例 #1

### 输入

```
3
6
1 5 3 1 1 5
8
-1 0 1 -1 0 1 -1 0
4
100 -1000 -1000 -1000```

### 输出

```
2
1
1100```

# AI分析结果



## 数学分类
**数论**

---

## 题解思路、算法要点与解决难点

### 核心数学推导
题目要求找到一个最大的正整数 $k$，使得所有 $a_i$ 可以通过减去若干次 $k$ 后相等。设最终所有数为 $x$，则有 $a_i \equiv x \pmod k$，即所有 $a_i$ 在模 $k$ 下同余。这等价于所有两两差值 $|a_i - a_j|$ 的公约数的最大值。

#### 关键公式
1. **差分性质**：若 $a_i \equiv a_j \pmod k$，则 $k$ 必须是 $|a_i - a_j|$ 的约数。
2. **最大公约数**：所有两两差值的最大公约数即为所求 $k$ 的最大值。
3. **相邻差等价性**：排序后相邻差的 GCD 等于所有两两差的 GCD（数学证明见下文）。

### 解决难点
1. **去重的必要性**：当数组有重复元素时，直接计算相邻差的 GCD 仍正确，无需去重。
2. **零差处理**：若所有元素相同，GCD 为 0，此时输出 -1。
3. **负数处理**：计算 GCD 前取绝对值。

### 算法步骤
1. **特判全相同**：若所有元素相等，输出 -1。
2. **计算相邻差**：排序后计算相邻差的绝对值，逐步求 GCD。
3. **输出结果**：若最终 GCD 为 0，输出 -1；否则输出 GCD。

---

## 题解评分（≥4星）

1. **sijiajun（5星）**  
   - 思路清晰，直接计算相邻差 GCD，时间复杂度 $O(n)$。
   - 代码简洁，处理负数与零差正确。
   - 唯一优化点：未显式排序，但结果正确。

2. **xwh_hh（4星）**  
   - 显式计算相邻差并处理绝对值，逻辑清晰。
   - 代码可读性高，但未去重（不影响正确性）。

3. **naroto2022（4星）**  
   - 数学证明详细，通过两两差计算 GCD。
   - 代码去重后计算所有两两差，时间复杂度 $O(m^2)$，$m$ 为去重后元素数，适合小数据。

---

## 最优思路或技巧提炼

### 核心公式推导
- **差分线性性**：排序后，任意两两差 $a_j - a_i$ 可表示为相邻差之和。因此，相邻差的 GCD 覆盖所有两两差的 GCD。
- **GCD 性质**：$\gcd(a, b) = \gcd(a, a - b)$，确保相邻差计算等价。

### 实现优化
1. **无需去重**：直接计算原数组相邻差。
2. **绝对值处理**：在最终输出前统一取绝对值，避免中间计算错误。

---

## 同类型题或算法套路

### 通用思路
- **数论 GCD 应用**：若问题涉及“所有元素通过加减同一数达到相同”，优先考虑差值的 GCD。
- **差分性质**：排序后相邻差的性质可简化计算。

### 推荐题目
1. **洛谷 P7191**（类似差值 GCD 问题）。
2. **CodeForces 1459B**（几何与数论结合）。
3. **LeetCode 1819**（数组中所有子序列的 GCD 数目）。

---

## 可视化与算法演示

### 像素化动画设计
1. **Canvas 绘制**：
   - **数组元素**：用像素方块表示，颜色区分不同值。
   - **相邻差计算**：高亮当前计算的相邻元素，显示差值。
   - **GCD 更新**：用动态数字显示当前 GCD 值。

2. **交互设计**：
   - **步进控制**：手动点击或自动播放，展示每一步的差值和 GCD 计算。
   - **颜色标记**：红色标记当前操作元素，绿色显示当前 GCD。

3. **复古音效**：
   - **计算差值**：播放 8-bit 点击音效。
   - **找到 GCD**：播放上升音调。

### 示例流程
1. **输入数组**：`[1, 5, 3, 1, 1, 5]`。
2. **排序后数组**：`[1, 1, 1, 3, 5, 5]`。
3. **相邻差计算**：`0, 0, 2, 2, 0`。
4. **逐步求 GCD**：初始 0 → GCD(0,0)=0 → GCD(0,2)=2 → 最终输出 2。

---

## 代码实现（核心逻辑）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<int> a(n);
        for (auto &x : a) cin >> x;
        
        // 计算相邻差的 GCD
        int ans = 0;
        for (int i = 1; i < n; i++) 
            ans = gcd(ans, a[i] - a[i-1]);
        
        ans = abs(ans);
        cout << (ans == 0 ? -1 : ans) << endl;
    }
    return 0;
}
```

### 关键函数
- `gcd(a, b)`：C++17 自带 `gcd` 函数，需包含 `<numeric>`。

---
处理用时：171.08秒
# 题目信息

# Light Switches

## 题目描述

一栋公寓楼里面有 $n$ 个房间，初始时每个房间的灯都是关的。为了更好地对房间里的灯进行控制，房东计划在不同时间给每个房间安装芯片。具体地，房东给每个房间安装芯片的时刻可以用包含 $n$ 个整数的数组 $a$ 来表示，其中第 $i$ 个元素 $a_i$ 表示房东给第 $i$ 个房间安装芯片的时刻。

一旦某个房间被安装上了芯片，这个房间里面的灯的状态每隔 $k$ 分钟就会发生一次变化，也就是说，安装商芯片的这一时刻起，这个房间里面的灯会先被点亮，$k$ 分钟后被熄灭，$k$ 分钟后再被点亮，如此循环往复。形式化的来讲，对于第 $i$ 个房间的灯，它的状态会在第 $a_i,a_i+k,a_i+2k,\dots$ 分钟发生变化。

现在请你求出所有房间的灯都被点亮的最小时刻，或者报告不存在所有房间的灯都被点亮的时刻。

## 说明/提示

对于所有数据：

- $1\leqslant T\leqslant 10^4$。
- $1\leqslant k\leqslant n\leqslant 2\times 10^5$，$\sum n\leqslant 2\times 10^5$。
- $1\leqslant a_n\leqslant 10^9$。

Translated by [Eason_AC](/user/112917)。

## 样例 #1

### 输入

```
9
4 4
2 3 4 5
4 3
2 3 4 5
4 3
3 4 8 9
3 3
6 2 1
1 1
1
7 5
14 34 6 25 46 7 17
6 5
40 80 99 60 90 50
6 5
64 40 50 68 70 10
2 1
1 1000000000```

### 输出

```
5
-1
10
8
1
47
100
-1
-1```

# AI分析结果



## 唯一算法分类
数论

## 综合分析与结论
题目要求找到所有灯同时亮的最早时刻。通过分析，每个灯的开启周期为2k分钟，其开启时间段可映射到模2k后的区间。核心思路是统计所有灯模2k后的覆盖区间，找到共同覆盖点并计算最小时间。

**关键公式推导**：
1. 每个灯i的开启区间模2k后为 `[a_i % (2k), (a_i +k) % (2k))`。
2. 若区间跨越模2k的边界（如从15到3，k=10），需拆分为两个连续区间处理。
3. 使用差分数组统计每个模点的覆盖次数，找到所有覆盖次数为n的点。
4. 对每个符合条件的模点x，计算最小t≥maxa且满足t≡x mod2k。

## 题解评分（≥4星）
- **作者：wangzc2012 (4星)**  
  思路清晰，代码简洁高效。通过确定答案区间[maxa, maxa+k-1]并遍历每个灯的状态更新边界，时间复杂度O(n)。但在某些边界条件下可能遗漏解。

- **作者：CNS_5t0_0r2 (4星)**  
  利用模运算和区间更新，代码逻辑严密。正确性较高，但需要处理模运算的边界拆分，代码复杂度适中。

- **作者：UniGravity (4星)**  
  使用差分数组统计模区间覆盖，思路全面。复杂度O(n+k)，但k较大时可能不适用，需优化处理。

## 最优思路或技巧提炼
1. **模周期映射**：将时间轴映射到模2k的区间，简化状态判断。
2. **差分数组统计**：快速统计区间覆盖次数，高效处理环形区间。
3. **边界处理**：拆分跨越模边界的区间为两部分，确保正确覆盖统计。

## 同类型题或类似算法套路
- **模运算优化**：常用于周期性问题，如时间循环、状态周期切换。
- **差分覆盖统计**：用于区间覆盖问题，如线段覆盖、时间窗口交集。

## 推荐题目
1. **P1972 [SDOI2009] HH的项链**（模运算与区间查询）
2. **P2163 [SHOI2007] 园丁的烦恼**（区间覆盖与统计）
3. **P3406 海底高铁**（差分数组应用）

## 个人心得摘录
- **调试关键**：注意模运算的区间拆分，避免漏算或重复计算。
- **顿悟点**：将时间轴映射到模2k后，问题转化为区间覆盖，极大简化计算。

## 可视化与算法演示
**动画方案**：
1. **时间轴映射**：在Canvas上绘制模2k的圆环，标记各灯的开启区间。
2. **覆盖统计**：高亮当前处理的灯区间，动态更新差分数组。
3. **解的计算**：滑动时间轴，找到第一个满足条件的t，颜色标记覆盖点。

**复古像素风格**：
- **8位色块**：用不同颜色表示灯的状态，圆环动态显示覆盖情况。
- **音效触发**：覆盖点更新时播放“滴”声，找到解时播放胜利音效。
- **自动演示**：模拟时间推进，自动暂停在关键步骤，显示公式推导。

**核心代码片段（差分统计）**：
```cpp
int m = 2 * k;
vector<int> diff(m + 2, 0);
for (int i = 0; i < n; ++i) {
    int l = a[i] % m;
    int r = (a[i] + k) % m;
    if (l < r) {
        diff[l]++;
        diff[r]--;
    } else {
        diff[l]++;
        diff[0]++;
        diff[r]--;
    }
}
// 统计覆盖点并计算最小t
```

---
处理用时：369.49秒
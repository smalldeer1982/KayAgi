# 题目信息

# The Strict Teacher (Hard Version)

## 题目描述

**这是本题的困难版，它和本题的简单版的唯一差距是 $m$ 和 $q$ 的数据范围**。在此版本中，$m,q\le10^5$。你在解决两个版本之后才可以去提交 hack 数据。

Narek 和 Tsovak 正在热火朝天地准备这场比赛，所以他们没时间去做作业了，因此，他们决定去偷 David 的作业。

严厉的老师发现 David 的作业没了非常生气，打算狠狠地惩罚他，于是她雇佣了别的老师帮她一起抓捕 David。

现在有 $m$ 个老师正在一起追 David。幸运的是，教室非常的大，所以 David 有充足的躲藏空间。

教室可以被表示为一条一维直线，上面有 $n$ 个单元格编号从 $1$ 到 $n$，**包含边界。**

最初，David 和这 $m$ 个老师**在不同的单元格中**。然后他们将会进行若干次行动。每次行动中：
- 首先，David 可以移动到一个**相邻的**单元格中，**也可以不动。**
- 然后，每位老师也进行这样的一次移动。

行动将一直持续知道 David 被抓住，即有任何一个老师和 David 位于同一个单元格中。**所有人都看得见其它人的行动。**

你的任务是计算**在所有人按照最优方案行动的前提下，多少次行动后 David 会被抓住。**

> 按照最优方案行动，是指：
> - David 采取一种方案，使得老师抓住他所需的行动次数最大。
> - 老师之间相互配合并采用一种方案，使得他们能够用最少的行动次数抓住 David。

Narek 和 Tsovak 认为这个任务太简单了，于是他们决定给你 $q$ 次询问。

## 样例 #1

### 输入

```
2
8 1 1
6
3
10 3 3
1 4 8
2 3 10```

### 输出

```
5
1
1
2```

# AI分析结果



# 算法分类
**组合数学**

---

# 题解思路与算法要点

## 核心思路
所有题解均基于以下关键观察：**只有离David最近的左右两个老师（或墙壁）影响结果**。最优策略下，David会被这两个老师夹击，所需步数由以下三种情况决定：
1. **左侧无老师**：David被最左老师逼至左墙，步数为 `最左老师位置-1`
2. **右侧无老师**：David被最右老师逼至右墙，步数为 `n-最右老师位置`
3. **中间有老师**：两老师间距为D，步数为 `D/2`

## 数学推导
设两老师位置为L和R（L < R），则最优步数为：
- **公式**：`⌊(R-L)/2⌋`
- **证明**：每轮行动后，两老师间距减少2。当间距为1时，David无法逃脱。

## 实现难点
1. **快速定位最近老师**：通过二分查找确定David的左右边界老师位置。
2. **边界处理**：特判David位于所有老师左侧或右侧的情况。
3. **代码优化**：使用STL的 `lower_bound` 和 `upper_bound` 简化二分逻辑。

---

# 优质题解推荐 (≥4星)

## 1. SuyctidohanQ（4.5星）
- **亮点**：清晰使用STL二分函数，代码简洁
- **核心代码**：
  ```cpp
  int x1=upper_bound(a+1,a+1+m,b)-a-1;
  int x2=lower_bound(a+1,a+1+m,b)-a;
  ans = (a[x2]-a[x1])/2;
  ```

## 2. masonxiong（4星）
- **亮点**：预处理各区间答案，查询O(1)
- **关键思路**：
  ```cpp
  for(int i=1; i<m; i++) 
      c[i] = (b[i+1]-b[i])/2;
  ans = c[lower_bound(...)];
  ```

## 3. wuyouwa（4星）
- **亮点**：完整处理三种情况，变量命名清晰
- **核心逻辑**：
  ```cpp
  if(b < a[1]) cout << a[1]-1;
  else if(b > a[m]) cout << n-a[m];
  else cout << (a[r]-a[l])/2;
  ```

---

# 关键代码实现
```cpp
// 最优实现（SuyctidohanQ 简化版）
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5+5;
int T, n, m, q, a[MAXN];

int main() {
    cin >> T;
    while(T--) {
        cin >> n >> m >> q;
        for(int i=1; i<=m; i++) cin >> a[i];
        sort(a+1, a+m+1);
        while(q--) {
            int b; cin >> b;
            if(b < a[1])      cout << a[1]-1 << '\n';
            else if(b > a[m]) cout << n-a[m] << '\n';
            else {
                int l = upper_bound(a+1, a+m+1, b) - a - 1;
                int r = lower_bound(a+1, a+m+1, b) - a;
                cout << (a[r] - a[l])/2 << '\n';
            }
        }
    }
    return 0;
}
```

---

# 同类型题套路
1. **一维夹击问题**：寻找最近边界，计算间距
2. **贪心极值问题**：分析移动策略，数学推导最优解
3. **二分应用**：快速定位有序数组中的相邻元素

---

# 推荐练习
1. **P1095** 守望者的逃离（贪心时间规划）
2. **P1516** 青蛙的约会（数论追及问题）
3. **P1663** 山（几何最优化）

---

# 可视化设计
**像素风格数轴模拟器**：
1. **动画元素**：
   - 红色像素块表示老师，绿色表示David
   - 每步移动后老师间距减2，颜色渐变提示
2. **交互功能**：
   - 空格暂停/继续，方向键调节速度
   - 自动演示模式（AI自动选择最优路径）
3. **音效设计**：
   - 移动时播放8-bit脚步声
   - 抓住时播放胜利音效

---

**核心公式推导的像素动画示例**：
![图示](https://cdn.luogu.com.cn/upload/image_hosting/ui3dugrg.png)
1. 初始状态显示老师位置（L=2, R=5）
2. 每帧高亮当前计算的间距 `(5-2)/2=1`
3. 动态绘制老师移动轨迹，最终交汇点标记结果

---
处理用时：379.90秒
# 题目信息

# Skibidus and Sigma

## 题目描述

定义一个 $k$ 个元素的数组 $b$ 的分数为
$\sum_{i=1}^{k}\left(\sum_{j=1}^{i}b_j\right)$，也就是说，设 $S_i$ 表示数组 $b$ 的前 $i$ 个元素之和，则分数可以写作
$S_1 + S_2 + \ldots + S_k$。

Skibidus 得到了 $n$ 个数组 $a_1, a_2, \ldots, a_n$，每个数组包含 $m$ 个元素。作为西格玛男人，他希望能将这 $n$ 个数组按任意顺序拼接成一个包含 $n \cdot m$ 个元素的数组，以使最终得到的拼接数组的分数达到最大。请你帮助他计算拼接后能够获得的最大分数！

形式上地说，在所有可能的长度为 $n$ 的排列 $p$ 中，
求出数组 $a_{p_1} + a_{p_2} + \dots + a_{p_n}$ 的最大分数，
其中符号 $+$ 表示数组拼接。

$ ^{\text{∗}} $ 一个排列指的是一个包含 $1$ 到 $n$ 的所有整数且每个整数恰好出现一次的序列。  
$ ^{\text{∗}} $ 两个数组 $c$ 和 $d$（长度分别为 $e$ 和 $f$）的拼接 $c+d$ 定义为 $c_1, c_2, \ldots, c_e, d_1, d_2, \ldots, d_f$。

## 说明/提示

在第一个测试用例中，有可能的两种排列：
- $p = [1, 2]$，拼接后的数组为 $a_{p_1} + a_{p_2} = [4, 4, 6, 1]$，分数为 $4 + (4+4) + (4+4+6) + (4+4+6+1) = 41$。
- $p = [2, 1]$，拼接后的数组为 $a_{p_1} + a_{p_2} = [6, 1, 4, 4]$，分数为 $6 + (6+1) + (6+1+4) + (6+1+4+4) = 39$。  

因此，最大可能分数为 $41$。

在第二个测试用例中，一个最优的拼接结果为 $[4,1,2,1,2,2,2,2,3,2,1,2]$，分数为 $162$。

## 样例 #1

### 输入

```
3
2 2
4 4
6 1
3 4
2 2 2 2
3 2 1 2
4 1 2 1
2 3
3 4 5
1 1 9```

### 输出

```
41
162
72```

# AI分析结果



## 算法分类
**贪心算法**

---

### 题解思路、算法要点与解决难点
**核心思路**：  
将每个数组的总和视为关键指标，按总和降序排列。每个数组的贡献分为两部分：  
1. **内部贡献**：数组自身的前缀和总和（即该数组的分数）。  
2. **外部贡献**：该数组的总和会影响后续所有数组的前缀和次数，贡献值为 `总和 × 后续数组个数 × m`。  

**关键推导**：  
假设两个数组的总和为 `sum_x` 和 `sum_y`，若 `sum_x > sum_y`，则将 `x` 排在 `y` 前，使得 `sum_x` 被后续数组多计算 `m` 次。  

**实现方法**：  
1. 计算每个数组的总和和内部贡献（前缀和总和）。  
2. 按总和降序排序数组。  
3. 累加所有数组的内部贡献和外部贡献。  

**解决难点**：  
正确推导出排序策略是核心难点。需证明总和大的数组应优先排列，并通过数学公式拆分总分的计算方式。

---

### 题解评分（≥4星）
1. **jzjr（5星）**  
   - **亮点**：公式推导清晰，代码简洁高效，直接拆分贡献计算，无需合并数组。  
   - **代码**：排序后直接累加 `自身贡献 + sum_i × m × (n - i)`。  

2. **nightwatch.ryan（4星）**  
   - **亮点**：代码直观，通过合并数组逐元素计算前缀和总和，适合快速实现。  
   - **代码**：合并数组后累加前缀和的总和。  

3. **StormWhip（4星）**  
   - **亮点**：变量命名清晰，通过动态维护前缀总和计算外部贡献。  
   - **代码**：排序后逐数组累加 `自身贡献 + 前序总和 × m`。  

---

### 最优思路或技巧
1. **贪心排序**：按数组总和降序排列，确保总和大的数组优先影响后续元素。  
2. **贡献拆分**：将总分拆分为内部贡献（前缀和总和）和外部贡献（总和的影响次数）。  
3. **数学优化**：通过公式推导避免合并数组，直接计算总分。  

---

### 同类型题或类似算法套路
- **贪心排序策略**：如任务调度、背包问题中的性价比排序。  
- **贡献拆分思想**：常见于需要分阶段计算贡献的问题，如区间覆盖、动态规划。  

---

### 推荐相似题目
1. **P1090 [NOIP2004 提高组] 合并果子**  
   （贪心策略：每次合并最小的两堆）  
2. **P1080 [NOIP2012 提高组] 国王游戏**  
   （排序策略：根据左右手乘积决定大臣顺序）  
3. **P1233 木棍加工**  
   （排序后动态规划：按长度和宽度排序）  

---

### 核心代码实现（jzjr）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const LL N=2e5+5;
LL n,m,sum[N],a[N];
bool cmp(LL a,LL b){return a>b;}
inline void solve(){
    cin>>n>>m;
    LL ans=0;
    for(LL i=1;i<=n;i++){
        LL sum=0, s=0, v=0;
        for(LL j=1;j<=m;j++){
            LL x; cin>>x;
            s += x;          // 数组总和
            v += s;          // 内部贡献（前缀和总和）
        }
        ans += v;            // 累加内部贡献
        a[i] = s;           // 存储数组总和
    }
    sort(a+1, a+n+1, cmp);  // 按总和降序排列
    for(int i=1;i<=n;i++)   // 累加外部贡献
        ans += a[i] * m * (n - i);
    cout<<ans<<'\n';
}
int main(){
    int T; cin>>T;
    while(T--) solve();
}
```

---

### 可视化与算法演示
**动画设计**：  
1. **像素风格**：用不同颜色块表示数组，颜色深度代表总和大小。  
2. **排序过程**：展示数组按总和降序排列的动态过程。  
3. **贡献计算**：分步高亮当前数组的贡献，显示内部和外部部分。  

**交互功能**：  
- **步进控制**：单步执行排序和贡献计算。  
- **音效提示**：排序完成时播放上扬音效，贡献累加时触发点击声。  

**复古风格**：  
- **8位像素UI**：用网格展示数组，排序动画仿照经典贪吃蛇移动。  
- **背景音乐**：循环播放8位风格的轻快旋律。  

---

### 个人心得摘录
- **推导陷阱**：最初误以为顺序影响内部贡献，实际只需关注总和的外部影响。  
- **调试经验**：通过小样例验证公式的正确性，如样例1的两种排列方式。  
- **优化顿悟**：发现无需合并数组，直接拆分贡献可大幅简化代码。

---
处理用时：161.13秒
# 题目信息

# Dora and C++

## 题目描述

Dora 刚学了编程语言C++！

但是，她一点也不明白C++的含义。 她认为C++是两种在长度为 $n$ 的数组 $c$ 上的加法操作。Dora 有两个整数 $ a $ 与 $ b $ 。 每一次操作，她可以选择一件事情去做。

- 选择一个整数 $ i $ ，其中 $ 1 \leq i \leq n $ ，然后把 $ c_i $ 加上 $ a $ 。
- 选择一个整数 $ i $ ，其中 $ 1 \leq i \leq n $ ，然后把 $ c_i $ 加上 $ b $ 。

注意，这里 $ a $ 与 $ b $ 是常数，且他们可以相同。

让我们规定一个数组的值域 $ d $ 为 $ \max(d_i) - \min(d_i) $ 。仅举几例：数组 $ [1, 2, 3, 4] $ 的值域是 $ 4 - 1 = 3 $ ，数组 $ [5, 2, 8, 2, 2, 1] $ 的值域是 $ 8 - 1 = 7 $ ， 数组 $ [3, 3, 3] $ 的值域是 $ 3 - 3 = 0 $ 。

经过若干次操作 (可能是 $ 0 $ )， Dora 计算出了新数组的值域。 请你帮助 Dora 最小化其值，但是自从 Dora 爱上了仅凭自己探索，你只需要告诉她最小化后的值。

## 样例 #1

### 输入

```
10
4 5 5
1 3 4 4
4 2 3
1 3 4 6
4 7 7
1 1 2 6
3 15 9
1 9 5
3 18 12
1 4 5
7 27 36
33 13 23 12 35 24 41
10 6 9
15 5 6 9 8 2 12 15 3 8
2 1 1000000000
1 1000000000
6 336718728 709848696
552806726 474775724 15129785 371139304 178408298 13106071
6 335734893 671469786
138885253 70095920 456876775 9345665 214704906 375508929```

### 输出

```
3
0
3
2
3
5
1
0
17
205359241```

# AI分析结果



**唯一算法分类**：数学与数论（模运算与贪心策略）

---

### **综合分析与结论**
**核心思路**：  
所有操作本质是通过累加 `a` 或 `b` 调整元素的值，其变化量均为 `gcd(a, b)` 的倍数。将问题转化为模 `gcd(a, b)` 下的余数问题。余数数组的极差只能是 `0` 到 `gcd(a, b)-1` 的循环排列，通过排序并计算相邻元素的“循环差”可得到最小极差。

**解决难点**：  
- **模运算转换**：意识到所有操作等价于在模 `gcd(a, b)` 意义下调整余数，消除绝对值的干扰。  
- **循环极差计算**：通过排序后的余数数组，考虑最大值与最小值的直接差，或相邻元素跨越模边界的差（如 `c[i] + g - c[i+1]`）。

**算法流程**：  
1. 计算 `g = gcd(a, b)`，所有元素取模 `g`。  
2. 对余数数组排序。  
3. 初始极差为 `max - min`。  
4. 遍历相邻元素，计算 `c[i] + g - c[i+1]`，取其最小值与初始极差比较。  

**可视化设计**：  
- **动画步骤**：  
  1. 元素依次对 `g` 取模，显示为不同颜色的像素块。  
  2. 排序过程用箭头交换相邻像素块位置。  
  3. 高亮当前比较的相邻元素对，计算差值并更新极差。  
- **复古风格**：  
  - 使用 8-bit 像素块表示余数，颜色按余数值渐变。  
  - 音效：排序完成时播放上扬音效，极差更新时触发短促音效。  
- **交互**：支持单步执行，展示模运算和相邻差计算逻辑。

---

### **题解清单（≥4星）**
1. **panyibo（4.5⭐）**  
   - **亮点**：代码清晰，直接通过模 `gcd(a, b)` 和排序解决问题，时间复杂度 `O(n log n)`。  
   - **核心代码**：  
     ```cpp
     sort(t + 1, t + n + 1);
     int ans = t[n] - t[1];
     for (int i = 1; i < n; i++) 
         ans = min(ans, t[i] + p - t[i + 1]);
     ```

2. **chenxi2009（4⭐）**  
   - **亮点**：代码简洁，使用 `__gcd` 简化实现，强调余数循环特性。  
   - **关键点**：通过模运算将极差限制在 `[0, g)` 范围内，避免无限调整。

3. **GY程袁浩（4⭐）**  
   - **亮点**：详细推导模运算等价性，强调“分割点”选择优化极差。

---

### **最优思路提炼**
**关键技巧**：  
- **模运算转化**：将绝对加法操作转换为相对余数调整。  
- **循环差计算**：排序后相邻元素的差可能通过模边界更优。  
- **贪心策略**：极差的最小值一定出现在排序后的相邻元素或首尾元素间。

**代码实现**：  
```cpp
int g = __gcd(a, b);
for (int i = 0; i < n; i++) c[i] %= g;
sort(c, c + n);
int ans = c[n-1] - c[0];
for (int i = 0; i < n-1; i++) 
    ans = min(ans, c[i] + g - c[i+1]);
```

---

### **同类型题与算法套路**
- **类似问题**：数组元素通过加减固定数调整极差、模意义下的极值优化。  
- **通用解法**：  
  1. 确定操作的最小单位（如 `gcd`）。  
  2. 模运算简化问题，转化为余数排列问题。  
  3. 排序后贪心计算最优解。

**推荐题目**：  
1. P5656 解二元一次不定方程（数论与模运算）  
2. P1894 完美数（模性质应用）  
3. P5431 模逆元（数论基础）

---

### **个人心得摘录**
- **调试经验**：余数未排序时直接计算极差会导致错误，必须排序后处理。  
- **思维突破**：意识到极差的最小值可能出现在模边界的“循环跳跃”中。

---

### **可视化与复古游戏化设计**
**动画方案**：  
- **Canvas 绘制**：  
  - 初始数组显示为不同高度的像素柱，颜色随机。  
  - 取模后所有柱高限制在 `[0, g)` 区间，颜色统一为绿色渐变。  
  - 排序过程通过像素柱交换动画展示。  
- **音效与交互**：  
  - 排序完成时播放经典 FC 过关音效。  
  - 极差更新时触发“金币收集”音效。  
- **自动演示模式**：按步骤自动完成模运算、排序、相邻差计算，速度可调。

---
处理用时：207.59秒
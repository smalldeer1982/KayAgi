# 题目信息

# Skibidus and Rizz

## 题目描述

情人节将至，Skibidus 拼命需要一种方法来吸引他的暗恋对象！幸运的是，他找到了正解：制造完美的二进制字符串！

给定一个二进制字符串$^{\text{∗}} $ $t$，令 $x$ 表示 $t$ 中 $\texttt{0}$ 的个数，$y$ 表示 $t$ 中 $\texttt{1}$ 的个数。我们定义字符串的平衡值为 $\max(x-y,\, y-x)$。

Skibidus 给你三个整数 $n$，$m$ 和 $k$。他希望你构造一个长度为 $n+m$ 的二进制字符串 $s$，其中恰好包含 $n$ 个 $\texttt{0}$ 和 $m$ 个 $\texttt{1}$，并且要求其所有子串$^{\text{†}} $的平衡值的最大值恰好为 $k$。如果不存在满足条件的字符串，请输出 -1。

$ ^{\text{∗}} $ 二进制字符串指仅由字符 $\texttt{0}$ 和 $\texttt{1}$ 组成的字符串。

$ ^{\text{†}} $ 字符串 $a$ 是字符串 $b$ 的子串，意味着 $a$ 可以通过删除 $b$ 开头和结尾的若干（可能为 0 或全部）字符得到。

## 说明/提示

在第一个测试用例中，我们必须构造一个字符串 $s$，包含 1 个 $\texttt{0}$ 和 2 个 $\texttt{1}$，且所有子串中的最大平衡值为 $1$。一个可能的满足条件的字符串是 $\texttt{101}$，原因如下：

- 考虑由索引 $[1,1]$ 界定的子串：平衡值为 $\max(0-1,\, 1-0) = 1$。
- 考虑由索引 $[1,2]$ 界定的子串：平衡值为 $\max(1-1,\, 1-1) = 0$。
- 考虑由索引 $[1,3]$ 界定的子串：平衡值为 $\max(1-2,\, 2-1) = 1$。
- 考虑由索引 $[2,2]$ 界定的子串：平衡值为 $\max(1-0,\, 0-1) = 1$。
- 考虑由索引 $[2,3]$ 界定的子串：平衡值为 $\max(1-1,\, 1-1) = 0$。
- 考虑由索引 $[3,3]$ 界定的子串：平衡值为 $\max(0-1,\, 1-0) = 1$。

在所有可能的子串中，最大的平衡值为 $1$。

在第二个测试用例中，具有最大平衡值的子串为 $\texttt{0100}$，其平衡值为 $\max(3-1,\, 1-3) = 2$。

## 样例 #1

### 输入

```
6
1 2 1
4 3 2
2 4 3
8 3 2
5 0 4
5 0 5```

### 输出

```
101
0100101
011011
-1
-1
00000```

# AI分析结果



# Skibidus and Rizz 题解分析

## 算法分类
构造、贪心

---

## 题解思路与核心难点

### 关键思路
1. **无解条件判定**：
   - `k > max(n, m)`：无法构造长度为k的连续段
   - `|n - m| > k`：总字符串的平衡值必然超过k

2. **构造策略**：
   - 优先放置k个主字符（数量较多的字符）
   - 交替放置剩余字符保持平衡
   - 最后补足剩余单一字符

### 解决难点
- 确保交替部分不会产生新的最大平衡值
- 剩余字符的平衡性处理（必须为同一种字符且数量 ≤k）

---

## 优质题解评分（≥4星）

### 1. thedyingkai（★★★★☆）
```cpp
// 核心代码片段
if(n<m) swap(n,m), flag=1;
for(int i=0;i<k;i++) cout<<(0^flag);
for(int i=0;i<n-k;i++) cout<<(1^flag)<<(0^flag);
for(int i=0;i<m-n+k;i++) cout<<(1^flag);
```
- **亮点**：通过异或操作优雅处理字符交换，三阶段构造清晰
- **优化点**：O(n+m) 时间复杂度，无冗余判断

### 2. fish_love_cat（★★★★☆）
```cpp
// 核心代码片段
if(n>m) swp=1;
for(int i=1;i<=k;i++) cout<<(0^swp);
for(int i=1;i<=n-k;i++) cout<<(1^swp)<<(0^swp);
for(int i=1;i<=m-(n-k);i++) cout<<(1^swp);
```
- **亮点**：变量交换逻辑直观，剩余字符处理简洁
- **心得**：明确处理`n-k <= m`的数学推导

### 3. ztd___（★★★★☆）
```cpp
// 核心逻辑
if(abs(n-m)>k || (k>n&&k>m))...
_rep(i,1,k) cout<<主字符;
_rep(i,1,min(剩余n,剩余m)) cout<<交替对;
```
- **特色**：通过对称结构处理两种字符情况
- **优化**：使用宏简化循环结构

---

## 最优思路提炼

### 关键步骤
1. **主字符确定**：`max(n, m)`
2. **前置填充**：k个主字符形成最大平衡段
3. **交替消减**：`主副交替`消耗剩余不同字符
4. **尾部追加**：剩余同种字符（数量必 ≤k）

### 数学保证
- 交替部分平衡值 ≤k-1（每次最多增加1个差异）
- 尾部追加的连续段长度 ≤k（因已满足`|n-m| ≤k`）

---

## 类似题目推荐
1. [CF1325C - Ehab and Path-etic MEXs](https://codeforces.com/problemset/problem/1325/C)（构造特殊边权）
2. [LeetCode 984. String Without AAA or BBB](https://leetcode.com/problems/string-without-aaa-or-bbb/)（交替构造）
3. [洛谷 P8112 「RdOI R3.5」记忆](https://www.luogu.com.cn/problem/P8112)（平衡字符串构造）

---

## 可视化设计

### 动画方案
```javascript
// 伪代码示例（Canvas绘制）
class ConstructionAnim {
  constructor(n, m, k) {
    this.blocks = []; // 像素块数组
    this.stage = 0;   // 0-前置填充 1-交替阶段 2-尾部追加
  }

  drawStep() {
    switch(this.stage) {
      case 0: 
        drawRect(x, y, 'red'); // 主字符块
        if(累计数量 == k) this.stage++;
        break;
      case 1:
        drawRect(x, y, 'blue'); // 交替字符
        drawRect(x+1, y, 'green');
        break;
      case 2:
        drawRect(x, y, 'yellow'); // 尾部追加
    }
  }
}
```

### 复古特效
- **像素风格**：16色调色板，8x8像素块表示字符
- **音效设计**：
  - 放置主字符：NES风格 "哔" 声（250Hz方波）
  - 交替阶段：双音和弦（400Hz+600Hz）
  - 完成构造：马里奥过关音效
- **AI演示**：自动按阶段构造，步进间隔500ms

---

## 核心代码实现
```cpp
void construct(int n, int m, int k) {
    bool swap_flag = false;
    if (n < m) swap(n, m), swap_flag = true;
    
    // 前置k个主字符
    for (int i = 0; i < k; ++i) 
        cout << (swap_flag ? '1' : '0');
    
    // 交替消耗
    for (int i = 0; i < n - k; ++i) 
        cout << (swap_flag ? '0' : '1') << (swap_flag ? '1' : '0');
    
    // 尾部追加剩余
    int remain = m - (n - k);
    for (int i = 0; i < remain; ++i)
        cout << (swap_flag ? '1' : '0');
}
```

---

通过这种构造方式，既保证了存在长度为k的最大平衡子串，又通过交替结构确保其他子串平衡值不超限。可视化中分阶段的颜色标记能清晰展现构造逻辑，复古音效增强了交互趣味性。

---
处理用时：74.46秒
# 题目信息

# New Year Book Reading

## 题目描述

小明非常喜欢读书。他一共有 $n$ 本书，编号为 $1\sim n$，第 $i$本书重 $w_i$。

小明计划在暑假的 $m$ 天里每天读一本书，第 $i$ 天读第 $d_i$ 本书，可能会重复读到同一本书。

因为所有的书都是堆成一摞的，所以每次读某本书之前小明都需要先将这本书上面所有的书搬开，拿出这本书，再将搬开的书按原顺序放回去，消耗体力为搬开书的重量之和，读完这本书后将其放在这摞书的最上面。

小明想知道这 $n$ 本书以怎样的初始顺序放置，所搬书消耗总体力最小。

## 样例 #1

### 输入

```
3 5
1 2 3
1 3 2 3 1
```

### 输出

```
12
```

# AI分析结果



---

## 算法分类选择
**贪心**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **贪心策略**：初始堆叠顺序应按照每本书在阅读序列中第一次出现的顺序排列。这样，每次第一次读某本书时，它上方的书尽可能少，减少搬动消耗。
2. **动态维护堆顶**：每次读完后将书放到堆顶，后续的搬动量仅与后续的阅读顺序相关，与初始顺序无关。

### 解决难点
1. **初始顺序的构造**：如何确定初始顺序使得首次搬动量最小？通过贪心策略，按第一次出现顺序构造初始堆。
2. **重复读的处理**：多次读同一本书时，只需统计最后一次出现后的不同书的重量之和。

### 关键实现
- **直接统计法**：遍历阅读顺序，每次读某书时，统计其最后一次出现之后的所有不同书的重量之和。
- **无需构造初始序列**：通过动态维护最后一次出现位置，直接计算总消耗。

---

## 题解评分 (≥4星)

1. **Luckyies题解** ⭐⭐⭐⭐  
   - 思路清晰，直接统计每次读时的搬动量。
   - 代码简洁，时间复杂度 O(m²)，适用于小规模数据。
   - 核心代码片段：倒序遍历历史记录，统计不同书的重量。

2. **A_better_world题解** ⭐⭐⭐⭐  
   - 明确贪心策略，详细解释搬动逻辑。
   - 代码与Luckyies类似，但注释更详细，适合教学。

3. **墨舞灵纯题解** ⭐⭐⭐⭐  
   - 用贪心思想分析两本书的搬动情况，推广到全局。
   - 代码简洁，核心逻辑用数组标记已统计的书。

---

## 最优思路或技巧提炼

### 关键技巧
- **倒序统计**：每次读时倒序遍历之前的记录，统计最后一次出现后的不同书重量。
- **标记去重**：用布尔数组标记已统计的书，避免重复计算。

### 代码片段（Luckyies题解核心逻辑）
```cpp
for (int i = 1; i <= m; i++) {
    cin >> a[i];
    memset(vis, 0, sizeof(vis));
    int sum = 0;
    for (int j = i - 1; j >= 1; j--) {
        if (a[j] == a[i]) break;
        if (!vis[a[j]]) {
            sum += w[a[j]];
            vis[a[j]] = true;
        }
    }
    ans += sum;
}
```

---

## 同类型题或类似算法套路
- **栈操作优化**：涉及动态调整顺序的场景（如浏览器历史记录、缓存淘汰策略LRU）。
- **贪心调度问题**：任务按特定顺序排列以最小化总成本。

---

## 推荐题目
1. **CF500C New Year Book Reading**（原题，练习贪心）
2. **P2347 砝码称重**（动态维护状态）
3. **P1090 合并果子**（贪心与优先队列）

---

## 个人心得摘录
- **踩坑提示**：初始顺序构造错误会导致搬动量暴增（如将首次出现晚的书放在堆底）。
- **调试技巧**：手动模拟小样例验证逻辑，如样例中的5次阅读顺序需逐步核对搬动量。

---

## 可视化与算法演示

### 动画方案设计
1. **像素风格界面**：用16色网格表示堆叠的书，书编号显示在方块内，重量用颜色深浅表示。
2. **核心操作高亮**：
   - **搬动过程**：当前读的书上方方块闪烁红色，累计重量以数字显示。
   - **堆顶调整**：读完后该书移动到顶部，原位置清空，新位置动画上升。
3. **控制面板**：
   - 步进播放：按帧逐步执行阅读顺序。
   - 速度调节：滑块控制动画速度（0.5x~3x）。
   - 数据重置：随机生成新书重量和阅读顺序。

### 交互示例（样例输入）
1. **初始堆叠**：显示书1、3、2从上到下堆叠（首次出现顺序）。
2. **第一次读1**：无需搬动，堆顶保持1。
3. **第二次读3**：搬动书1，总重量+1。
4. **第三次读2**：搬动书1和3，总重量+4。

---

## 总结
- **贪心策略**：初始顺序按首次出现顺序排列，确保首次搬动量最小。
- **直接统计法**：通过倒序标记和去重，避免显式维护堆结构。
- **可视化要点**：动态展示搬动路径与堆调整过程，增强理解。

---
处理用时：446.76秒
# 题目信息

# Maximal Intersection

## 题目描述

给定n个闭区间,现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

## 样例 #1

### 输入

```
4
1 3
2 6
0 4
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
2 6
1 3
0 4
1 20
0 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
4 5
1 2
9 20
```

### 输出

```
0
```

## 样例 #4

### 输入

```
2
3 10
1 5
```

### 输出

```
7
```

# AI分析结果



1. **算法分类**  
   预处理数组（前缀与后缀处理）

2. **题解思路、算法要点与解决难点**  
   - **核心思路**：通过预处理前缀和后缀的最大左端点（`lmax`）与最小右端点（`rmin`），枚举删除每个区间后的剩余区间交集。  
   - **关键变量**：  
     - `prefix_lmax` 和 `prefix_rmin`：前 `i` 个区间的交集左端点和右端点。  
     - `suffix_lmax` 和 `suffix_rmin`：后 `i` 个区间的交集左端点和右端点。  
   - **解决难点**：删除单个区间后，剩余区间的交集可通过前缀和后缀的组合快速计算，避免暴力枚举。

3. **题解评分 (≥4星)**  
   - **CreeperK（5星）**  
     - 思路清晰，通过前后缀预处理高效计算所有可能的删除情况。  
     - 代码结构简洁，时间复杂度 O(n)，适用于大数据量。  
   - **localhost（4星）**  
     - 维护最大次大左端点与最小次小右端点，巧妙利用极值替换策略。  
     - 代码简短，时间复杂度同为 O(n)，但需正确处理重复极值情况。  
   - **lihongqian__int128（4星）**  
     - 代码简洁，逻辑与 CreeperK 类似，直接使用前后缀数组快速求解。  

4. **最优思路或技巧提炼**  
   - **前后缀预处理法**：  
     1. 预处理前缀 `lmax` 和 `rmin` 数组，以及后缀 `lmax` 和 `rmin` 数组。  
     2. 删除第 `i` 个区间后的交集为 `[max(prefix_lmax[i-1], suffix_lmax[i+1]), min(prefix_rmin[i-1], suffix_rmin[i+1])]`。  
     3. 遍历所有区间计算最大交集长度。  
   - **极值替换法**：  
     1. 记录所有区间的最大左端点 `ml1` 和次大左端点 `ml2`，最小右端点 `mr1` 和次小右端点 `mr2`。  
     2. 若删除的区间贡献了 `ml1` 或 `mr1`，则用 `ml2` 或 `mr2` 替代计算剩余区间的交集。  

5. **同类型题或类似算法套路**  
   - **区间交问题**：如 CF754D（选择 k 个区间求最大交集）。  
   - **极值维护问题**：如滑动窗口中的最大值（需动态维护次大值）。  

6. **推荐相似题目**  
   - 洛谷 P1712 [NOI2016] 区间  
   - 洛谷 P3740 [HAOI2014] 贴海报  
   - 洛谷 P2216 [HAOI2007] 理想的正方形  

7. **个人心得摘录**  
   - CreeperK 提到“插入比删除容易”，通过前后缀预处理避免直接处理删除操作。  
   - localhost 的极值替换法需注意重复极值的维护，确保次大次小值的正确更新。  

8. **可视化与算法演示**  
   - **核心逻辑动画**：  
     1. **步骤 1**：显示所有区间在数轴上的分布，用不同颜色标记。  
     2. **步骤 2**：动态绘制前缀和后缀数组的 `lmax` 和 `rmin` 值。  
     3. **步骤 3**：高亮当前删除的区间，并用组合后的 `lmax` 和 `rmin` 绘制剩余交集。  
   - **复古游戏化设计**：  
     - **像素风格**：用 8 位色块表示区间端点，删除时播放“消除音效”。  
     - **自动演示模式**：AI 自动遍历所有删除情况，实时显示最大交集长度变化。  

---

**题解代码片段（CreeperK 的核心逻辑）**  
```cpp
int lpl[iz], lpr[iz], rpl[iz], rpr[iz]; // 前缀和后缀数组
for (int i=1; i<=n; i++) {
    lpl[i] = max(lpl[i-1], l[i]);   // 前缀最大左端点
    lpr[i] = min(lpr[i-1], r[i]);   // 前缀最小右端点
}
for (int i=n; i>=1; i--) {
    rpl[i] = max(rpl[i+1], l[i]);   // 后缀最大左端点
    rpr[i] = min(rpr[i+1], r[i]);   // 后缀最小右端点
}
int maxn = 0;
for (int i=1; i<=n; i++) {
    int current = min(lpr[i-1], rpr[i+1]) - max(lpl[i-1], rpl[i+1]);
    maxn = max(maxn, current);      // 计算删除第 i 个区间的结果
}
```

**题解代码片段（localhost 的核心逻辑）**  
```cpp
// 维护最大次大左端点
if (l >= ml1) { ml2 = ml1; ml1 = l; }
else if (l > ml2) { ml2 = l; }

// 维护最小次小右端点
if (r <= mr1) { mr2 = mr1; mr1 = r; }
else if (r < mr2) { mr2 = r; }

// 计算删除每个区间的结果
for (int i=1; i<=n; i++) {
    int L = (a[i].l == ml1) ? ml2 : ml1;
    int R = (a[i].r == mr1) ? mr2 : mr1;
    ans = max(ans, R - L);
}
```

---

**可视化设计要点（复古像素风格）**  
- **颜色方案**：左端点用绿色块，右端点用红色块，交集区间用黄色高亮。  
- **动画流程**：  
  1. 初始显示所有区间为横向色带，按左端点排序。  
  2. 预处理时，前缀和后缀数组的极值以闪烁效果标记。  
  3. 删除某个区间时，播放“咔嚓”音效，并动态绘制剩余区间交集。  
- **音效触发**：正确计算时播放上扬音效，无效交集时播放低沉音效。

---
处理用时：194.44秒
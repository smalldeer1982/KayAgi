# 题目信息

# Counting Points

## 题目描述

粉色士兵们在平面上绘制了 $n$ 个圆心位于 $x$ 轴上的圆。此外，他们告知这些圆的半径之和恰好为 $m$ $^{\text{∗}}$。

请计算至少位于一个圆内或边界上的整数点数量。形式化地说，问题定义如下：

给定一个整数序列 $x_1, x_2, \ldots, x_n$ 和一个正整数序列 $r_1, r_2, \ldots, r_n$，已知 $\sum_{i=1}^n r_i = m$。

你需要统计满足以下条件的整数对 $(x, y)$ 的数量：

- 存在一个下标 $i$ 使得 $(x - x_i)^2 + y^2 \le r_i^2$（$1 \le i \le n$）。

$^{\text{∗}}$ 这个信息真的有用吗？别问我，其实我也不知道。

## 说明/提示

在第一个测试用例中，半径为 $r_1=1$ 的圆完全包含在半径为 $r_2=2$ 的圆内部。因此只需统计后者内部的整数点数量。满足 $x^2 + y^2 \le 2^2$ 的整数点共有 $13$ 个，因此答案为 $13$。

在第二个测试用例中，半径为 $r_1=1$ 的圆未完全包含在半径为 $r_2=2$ 的圆内部。存在 $3$ 个额外整数点位于第一个圆内但不在第二个圆内，因此答案为 $3+13=16$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
2 3
0 0
1 2
2 3
0 2
1 2
3 3
0 2 5
1 1 1
4 8
0 5 10 15
2 2 2 2```

### 输出

```
13
16
14
52```

# AI分析结果



---

## 算法分类
**暴力枚举、区间覆盖**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **暴力覆盖计算**：遍历每个圆的所有横坐标覆盖范围 `[x_i - r_i, x_i + r_i]`，计算每个横坐标 `j` 对应的最大可覆盖的纵坐标范围 `y_max`。
2. **维护最大值**：用 `map` 维护每个横坐标 `j` 对应的最大 `y_max`，公式为 `y_max = floor(sqrt(r_i^2 - (j - x_i)^2))`。
3. **累加贡献**：每个横坐标的贡献为 `2 * y_max + 1`（包括 `y=0` 的情况）。

### 解决难点
- **重复覆盖处理**：多个圆可能覆盖同一横坐标，需记录所有覆盖该位置的圆中的最大 `y_max`。
- **高效遍历**：利用 `map` 动态记录覆盖的横坐标，避免遍历所有可能的 `x`（因 `x` 范围可能极大）。

---

## 题解评分（≥4星）
1. **The_foolishest_OIer（⭐⭐⭐⭐）**  
   思路清晰，但使用 `vis` 数组标记已计算的横坐标，可能导致重复遍历。
2. **wcy110614（⭐⭐⭐⭐⭐）**  
   代码简洁高效，直接通过 `map` 维护最大值，无需额外标记数组，时间复杂度最优。
3. **Kamisato_Ayaka（⭐⭐⭐⭐）**  
   思路正确但存在冗余排序步骤，代码可读性较好。

---

## 最优思路或技巧提炼
1. **覆盖区间遍历**：每个圆的覆盖范围是 `x_i ± r_i`，直接遍历所有可能覆盖的横坐标。
2. **动态维护最大值**：使用 `map` 或哈希表记录每个 `x` 对应的最大 `y_max`，避免重复计算。
3. **平方根优化**：用二分法或内置函数快速计算 `floor(sqrt(r^2 - (x - x_i)^2))`。

---

## 同类型题或类似算法套路
- **区间覆盖问题**：如线段覆盖、矩形面积并等。
- **离散化+哈希表**：适用于数据范围大但有效数据稀疏的场景。

---

## 推荐相似题目
1. **P1884 [USACO12FEB] Overplanting S**（矩形覆盖面积）
2. **P1496 火烧赤壁**（区间合并）
3. **P2280 [HNOI2003] 激光炸弹**（二维前缀和与覆盖统计）

---

## 个人心得摘录
- **wcy110614**：提到“$\sum m$ 很小，直接暴力”，强调数据范围是解题关键。
- **lw393**：实现二分法计算平方根，避免浮点误差。

---

## 可视化与算法演示
### 核心算法流程
1. **初始化 Canvas**：绘制 x 轴，用不同颜色标记每个圆。
2. **逐步绘制覆盖区域**：  
   - 遍历每个圆，从左到右绘制其覆盖的横坐标 `j`。
   - 更新 `map` 中的 `y_max`，高亮当前操作的 `(j, y_max)`。
3. **统计贡献**：遍历 `map`，用柱状图展示每个横坐标的 `2y_max + 1`。

### 复古游戏化设计
- **像素风格**：x 轴用绿色像素线，圆覆盖区域用半透明色块。
- **音效**：每次更新 `y_max` 时播放“滴”声，统计完成时播放 8-bit 胜利音效。
- **自动演示模式**：按圆顺序自动播放覆盖过程，可调节速度。

---

## 代码片段（核心逻辑）
```cpp
// wcy110614 的代码核心部分
map<ll, ll> h;
for (int i = 1; i <= n; ++i) {
    cin >> x[i] >> r[i];
    for (ll j = x[i] - r[i]; j <= x[i] + r[i]; ++j) {
        ll dy_sq = r[i] * r[i] - (j - x[i]) * (j - x[i]);
        h[j] = max(h[j], (ll)sqrt(dy_sq));
    }
}
ll ans = 0;
for (auto [x, y] : h) ans += 2 * y + 1;
```

---

## 总结
通过维护每个横坐标的最大覆盖高度，暴力枚举所有可能的覆盖点，结合 `map` 高效去重，最终线性时间复杂度解决问题。

---
处理用时：76.24秒
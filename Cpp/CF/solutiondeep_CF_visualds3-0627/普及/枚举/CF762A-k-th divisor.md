# 题目信息

# k-th divisor

## 题目描述

你被给了两个整数$n$ 和$k$ 。找到$n$ 的第$k$ 小因子，或者告知其不存在。

任意一个可以除$n$ 而没有余数的自然数都是$n$ 的因子。

## 说明/提示

在第一个样例中，数字$4$ 有三个因子：$1$ ，$2$ 和$4$ 。第二小的为$2$ 。

在第二个样例中，数字$5$ 仅有两个因子$1$ 和$5$ 。第三个因子是不存在的，因此答案是-1。

感谢@Khassar 提供的翻译

## 样例 #1

### 输入

```
4 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
12 5
```

### 输出

```
6
```

# AI分析结果



## 算法分类
数论、枚举优化

## 题解思路与解决难点
**核心思路**：利用因子成对出现的特性，仅枚举到√n，将因子分为两段处理，避免全量排序。

**关键步骤**：
1. **枚举小因子**：遍历1到√n，收集所有i和n/i（避免重复）。
2. **逆序处理大因子**：将n/i按从大到小的顺序存入，确保整体有序。
3. **双指针法**：首次遍历处理小因子时直接检查k，若未满足则逆序生成大因子。

**难点对比**：
- **排序法**（王夫子、crh1272336175）：收集所有因子后排序，简单但增加O(m log m)时间。
- **分段处理法**（Khassar、αnonymous）：分两次遍历生成有序序列，无需排序，时间复杂度严格O(√n)。
- **空间优化法**（αnonymous）：仅存储小因子，动态计算大因子，减少内存占用。

## 题解评分（≥4星）
1. **Khassar（5星）**：高效分段处理，避免排序，代码简洁。
2. **αnonymous（4星）**：动态计算后半因子，空间最优。
3. **infinities（4星）**：两次遍历生成有序数组，逻辑清晰。

## 最优思路提炼
- **因子成对**：仅枚举到√n，i和n/i成对收集。
- **有序合并**：先正序存小因子，逆序取大因子，天然有序。
- **平方数特判**：i²=n时仅存一次，避免重复。

## 同类型题套路
- **因子枚举**：UVA294（约数个数）、LeetCode 1492（n的第k因子）。
- **成对处理**：质因数分解、完全平方数判断。

## 推荐题目
1. **P3383**（线性筛模板）
2. **CF1025B**（成对因子应用）
3. **LeetCode 1362**（最近因子对）

## 个人心得摘录
- **平方数陷阱**：王夫子提到n=1时处理不当导致WA，需注意边界。
- **空间优化**：αnonymous动态计算后半因子，避免存储全部大因子。
- **逆序技巧**：Khassar通过倒序遍历小因子数组，自然生成有序大因子。

---

## 可视化算法设计
**动画方案**：
1. **网格绘制**：Canvas绘制数轴，左侧为1~√n，右侧为对应大因子。
2. **颜色标记**：
   - 红色：当前枚举的i。
   - 蓝色：已确认的小因子。
   - 绿色：动态生成的大因子。
3. **步进控制**：按钮控制i的移动，显示当前因子对。
4. **音效反馈**：
   - 发现因子：短促“滴”声。
   - 达到k时：胜利音效。
   - 无解：低沉提示音。

**复古像素风**：
- 8-bit风格数轴，因子显示为像素方块。
- 背景音乐：8-bit循环旋律，速度随枚举进度加快。

---

## 核心代码实现（Khassar分段处理法）
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;

int main() {
    ll n, k;
    cin >> n >> k;
    vector<ll> small;
    // 枚举小因子
    for (ll i = 1; i * i <= n; ++i) {
        if (n % i != 0) continue;
        small.push_back(i);
        if (--k == 0) { // 找到第k小
            cout << i;
            return 0;
        }
    }
    // 处理平方数
    if (small.back() * small.back() == n) 
        small.pop_back();
    // 逆序生成大因子
    for (auto it = small.rbegin(); it != small.rend(); ++it) {
        ll factor = n / *it;
        if (--k == 0) {
            cout << factor;
            return 0;
        }
    }
    cout << -1;
}
```

---
处理用时：85.75秒
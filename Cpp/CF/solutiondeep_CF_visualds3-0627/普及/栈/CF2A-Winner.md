# 题目信息

# Winner

## 题目描述

在 Berland 流行着纸牌游戏 `Berlogging`，这个游戏的赢家是根据以下规则确定的：

1. 在每一轮中，玩家获得或失去一定数量的分数，在游戏过程中，分数被记录在 `名称和得分` 行中，其中名字是玩家的名字，得分是在这一轮中获得的分数。得分是负值意味着玩家失去了相应的分数。
2. 如果在比赛结束时只有一名玩家分数最多，他就是获胜者。
3. 如果两名或两名以上的玩家在比赛结束时都有最大的分数 $m$ ，那么其中首先获得至少 $m$ 分的玩家胜利。开始时，每个玩家都是 $0$ 分。


保证在比赛结束时至少有一个玩家的分数为正。

## 样例 #1

### 输入

```
3
mike 3
andrew 5
mike 2
```

### 输出

```
andrew
```

## 样例 #2

### 输入

```
3
andrew 3
andrew 2
mike 5
```

### 输出

```
andrew
```

# AI分析结果



# 算法分类
**模拟**

---

## 题解思路与算法要点

### 核心逻辑
1. **两次遍历**：  
   - **第一次遍历**：计算所有玩家的最终得分，并确定最高分 `m`。  
   - **第二次遍历**：重新模拟得分累加过程，找出第一个满足以下条件的玩家：  
     - 最终得分等于 `m`  
     - 在模拟过程中，当前得分首次达到或超过 `m`  

2. **数据结构**：  
   - 使用 `map` 或哈希表存储玩家最终得分和过程得分，确保快速查询与更新。  
   - 例如：`map<string, int>` 记录最终得分，`map<string, int>` 动态更新过程得分。

### 解决难点
- **条件验证**：需同时满足两个条件（最终得分是最高分，且在过程中最早达到）。  
- **数据回滚**：第二次遍历需重新模拟得分累加过程，而非直接使用最终得分。  
- **时间复杂度**：通过哈希表将时间复杂度优化至 O(n)，避免暴力遍历。

---

## 题解评分（≥4星）

1. **Honor誉（5星）**  
   - 思路清晰，代码简洁。  
   - 通过双 `map` 分别记录最终得分和过程得分，逻辑明确。  
   - 关键代码段：  
     ```cpp
     for (int i=1; i<=n; i++) {
         mpp[s[i]] += a[i];
         if (mp[s[i]] == maxn && mpp[s[i]] >= maxn) {
             s1 = s[i];
             break;
         }
     }
     ```

2. **xiaohuang（5星）**  
   - 代码简洁高效，直接使用两次遍历。  
   - 关键逻辑注释明确，适合快速理解。  
   - 代码片段：  
     ```cpp
     for (int i=0; i<n; i++) {
         t[D[i].str] += D[i].score;
         if (t[D[i].str] >= Max && m[D[i].str] == Max) {
             cout << D[i].str;
             return 0;
         }
     }
     ```

3. **Idoyt（4星）**  
   - 代码简短，但缺乏注释。  
   - 核心逻辑与高分题解一致，但变量命名不够直观。  
   - 关键代码：  
     ```cpp
     if (m[q[i].name]==maxn && t[q[i].name]>=maxn) p=i;
     ```

---

## 最优思路与技巧提炼

### 关键步骤
1. **确定最高分**：遍历所有操作，计算每个玩家的最终得分，取最大值 `m`。  
2. **模拟过程**：重新累加分数，记录第一个达到 `m` 分的玩家，且该玩家最终得分必须为 `m`。

### 技巧
- **哈希表优化**：通过 `map` 快速查询和更新玩家得分，避免线性搜索。  
- **双条件验证**：在第二次遍历中同时验证最终得分和过程得分，确保正确性。

---

## 同类型题与算法套路

### 相似算法套路
- **两次遍历法**：适用于需要先预处理数据，再模拟过程的问题。  
- **哈希表记录状态**：如 LeetCode 中需要统计字符出现次数后二次验证的问题。

### 推荐题目
1. **洛谷 P1563 [NOIP2016 提高组] 玩具谜题**（模拟过程）  
2. **洛谷 P1056 排座椅**（统计与条件判断）  
3. **洛谷 P1605 迷宫**（DFS 模拟路径）

---

## 个人心得摘录

- **Honor誉**：通过双 `map` 分离最终得分与过程得分，避免混淆。  
- **sandwich**：提供特殊测试用例（如分数先增后减），强调必须验证最终得分。  
- **purple7**：未使用 STL 的结构体解法，体现对条件的深度理解。

---

## 可视化与算法演示

### 核心算法流程
1. **初始化阶段**：  
   - 展示输入数据（玩家名与得分），用表格列出每个玩家的初始得分（0）。  
   - 颜色标记：输入数据为灰色，当前操作为黄色。

2. **第一次遍历（统计最终得分）**：  
   - 逐步高亮每个操作，更新对应玩家的总得分。  
   - 最终用红色高亮显示最高分 `m`。

3. **第二次遍历（模拟过程）**：  
   - 重置所有玩家的过程得分，逐步累加。  
   - 当某个玩家的过程得分 ≥ `m` 且最终得分等于 `m` 时，用绿色闪烁标记并播放胜利音效。

### 复古像素风格设计
- **颜色方案**：8-bit 调色板（灰、黄、红、绿）。  
- **Canvas 动画**：  
  - 玩家名显示为像素字体，得分用方块高度表示。  
  - 最高分 `m` 用闪烁边框突出。  
- **音效**：  
  - 得分更新：短促“哔”声。  
  - 找到胜者：8-bit 胜利旋律。  
- **自动演示**：按帧逐步执行，支持暂停/继续。

---

## 代码片段（核心逻辑）

```cpp
// 第一次遍历：计算最终得分
map<string, int> final_score;
for (int i = 0; i < n; i++) {
    final_score[name[i]] += score[i];
}

// 确定最高分
int max_score = 0;
for (auto &[k, v] : final_score) {
    max_score = max(max_score, v);
}

// 第二次遍历：模拟过程
map<string, int> current_score;
for (int i = 0; i < n; i++) {
    current_score[name[i]] += score[i];
    if (final_score[name[i]] == max_score && current_score[name[i]] >= max_score) {
        cout << name[i];
        return 0;
    }
}
```

---
处理用时：77.40秒
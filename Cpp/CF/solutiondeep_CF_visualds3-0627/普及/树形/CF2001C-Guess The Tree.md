# 题目信息

# Guess The Tree

## 题目描述

这是一道交互题。

Misuki 有一棵结构未知，具有 $n$ 个节点的树，节点编号从 $ 1 $ 到 $ n $ ，并要求你写一份代码来猜测它。

你可以询问以下问题：

`? a b`

其中 $a,b$ 为两个节点的编号。

对于一次询问，Misuki 会告诉你哪个节点 $x$ 能最小化 $|d(a,x)-d(b,x)|$ 的值，其中 $d(x,y)$ 是节点 $x$ 和 $y$ 之间的距离。如果存在多个这样的节点，Misuki 会告诉你最小化 $d(a,x)$ 的节点。

现要求你使用不超过 $15n$ 次的询问，来确定这棵树的结构。

## 说明/提示

打印每一行后（即进行一次询问或输出一次答案后），请输出回车并刷新输出缓冲区。可刷新输出缓冲区的有：

- C++ 中的 `fflush(stdout)` 或 `cout.flush()`;
- Java 中的 `System.out.flush()`;
- Pascal 中的 `flush(output)`;
- Python 中的 `stdout.flush()`;
- 对于其他语言，请参阅其他语言的文档。

Translated by @[ARIS2_0](https://www.luogu.com.cn/user/1340759)

## 样例 #1

### 输入

```
1
4
1
1
3```

### 输出

```
? 1 2

? 1 3

? 1 4

! 1 2 1 3 3 4```

# AI分析结果



---

**算法分类**：树结构的二分查找构建法

---

### **题解思路与核心难点**

#### **思路分析**
所有题解的核心均基于以下观察：当查询`? a b`返回的点是`a`或`b`时，说明`a`和`b`直接相连。利用这一性质，通过不断二分查找每个节点的父节点，逐步构建整棵树。

1. **中点性质**：查询返回的`x`是`a`和`b`路径上的中点，当且仅当`x=a`或`x=b`时，两者有边。
2. **二分策略**：对于每个非根节点，从根开始多次查询，逐步缩小范围。例如，初始查询`? 1 i`，若返回非根节点，则将其作为新起点继续查询，直到返回当前起点或目标节点，此时确定一条边。

#### **解决难点**
- **高效确定父节点**：通过二分将路径长度每次减半，确保单节点查询次数为O(log n)。
- **避免重复查询**：通过标记已处理节点或隐式逻辑确保每条边只被确定一次。

---

### **题解评分 (≥4星)**

1. **shicj (5星)**  
   - **亮点**：代码简洁，直接循环迭代逼近父节点，逻辑清晰易懂。  
   - **代码**：每个节点从根出发，循环查询直到找到父节点，时间复杂度O(n log n)。  
   ```cpp
   for(int i=2;i<=n;i++){
       cout<<"? "<<1<<" "<<i<<endl;
       cin>>ans;
       int u=1, v=i;
       while(ans!=u && ans!=v){
           u=ans;
           cout<<"? "<<u<<" "<<v<<endl;
           cin>>ans;
       }
       edu[eds]=u; edv[eds]=v; //记录边
   }
   ```

2. **JiuZhE66666 (4星)**  
   - **亮点**：代码极简，直接通过循环逼近父节点，无需递归或复杂结构。  
   ```cpp
   for(int i=2;i<=n;i++){
       int r=1, mid=query(i, r);
       while(mid!=i){
           r=mid;
           mid=query(i, mid);
       }
       edge.push_back({i, r}); //记录边
   }
   ```

3. **Zhi_ptb (4星)**  
   - **亮点**：递归实现二分逻辑，清晰展示路径分割过程。  
   ```cpp
   void solve(int p, int i){
       int w = query(p, i);
       if(w == p) add_edge(p, i); //找到边
       else solve(w, i); //继续递归
   }
   ```

---

### **最优思路提炼**
- **关键步骤**：对每个节点`i`，从根节点`1`开始，反复查询`? u i`（`u`初始为`1`），若返回`x`则更新`u=x`，直到返回的`x`等于`u`或`i`，此时`u`即为`i`的父节点。
- **复杂度保证**：每次查询将路径长度减半，单节点查询次数为O(log d)（`d`为节点深度），总次数约O(n log n)，满足限制。

---

### **类似题目推荐**
1. **洛谷 P3398**：树链剖分，判断路径交点。
2. **洛谷 P3369**：动态树结构维护（LCT）。
3. **CF 1174E**：交互题中的树结构推断。

---

### **可视化设计**

#### **动画方案**
1. **树形结构动态构建**：  
   - **初始状态**：根节点`1`单独显示。  
   - **节点处理**：对于每个节点`i`，从`1`开始绘制一条虚线路径，每次查询后高亮当前查询的`u`和`i`，并显示返回的`x`。  
   - **路径更新**：当`x`不等于`u`时，将`x`标记为新起点，路径缩短为`x`到`i`，继续动画。  
   - **确定边**：当`x`等于`u`时，用实线连接`u`和`i`，并播放音效。

2. **复古像素风格**：  
   - **颜色方案**：使用16色调色板，根节点为红色，当前查询节点为闪烁黄色，已确定边为绿色。  
   - **音效设计**：  
     - **查询时**：播放短促的“哔”声。  
     - **找到边时**：播放“成功”音效（类似FC游戏金币声）。  
   - **Canvas绘制**：节点用像素方块表示，边用动态线段，每次查询后更新画面。

3. **交互控制**：  
   - **步进/暂停**：允许用户控制动画速度，观察二分过程。  
   - **自动模式**：AI自动执行所有查询，用不同颜色区分当前处理节点。

#### **代码片段（伪代码）**
```javascript
class TreeVisualizer {
  constructor(n) {
    this.nodes = [{id:1, x:400, y:50}]; //根节点坐标
    this.edges = [];
  }

  addEdge(u, v) {
    this.edges.push({u, v});
    playSound('success'); //添加边时播放音效
  }

  async query(u, v) {
    highlight(u, v); //高亮当前查询的节点
    let x = await fetchQueryResult(u, v); //模拟交互
    if (x === u || x === v) {
      this.addEdge(u, v);
    } else {
      drawPath(x, v, 'dashed'); //绘制新路径
    }
    return x;
  }
}
```

---

**总结**：通过二分策略高效确定父节点，结合交互式动画展示路径缩短过程，是解决此类树结构推断问题的核心技巧。

---
处理用时：73.69秒
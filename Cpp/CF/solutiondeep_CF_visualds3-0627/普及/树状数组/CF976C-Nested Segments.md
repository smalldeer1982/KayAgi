# 题目信息

# Nested Segments

## 题目描述

##### 【题目大意】：

你得到了一个序列$a_1,a_2,a_3...a_n$，表示$n$个区间。你的任务是求出一对$(i,j)$，表示区间$j$包含区间$i$（注意是区间$j$包含$i$）。

我们定义区间$[l_2,r_2]$包含区间$[l_1,r_1]$当且仅当$l_1 \geq l_2$且$r_1 \leq r_2$。比如区间$[2,5]$包含区间$[3,5]$，因为$3 \geq 2,5 \leq 5$。再比如区间$[2,5]$不包含区间$[1,4]$，因为$1<2$。

输出一对$(i,j)$表示答案。如果答案不唯一，则输出任意一组解即可（所以本题有`SPJ`）。如果无解，则输出`-1 -1`。

--------------------------------------

## 样例 #1

### 输入

```
5
1 10
2 9
3 9
2 3
2 9
```

### 输出

```
2 1
```

## 样例 #2

### 输入

```
3
1 5
2 6
6 20
```

### 输出

```
-1 -1
```

# AI分析结果



**唯一算法分类**: 排序 + 贪心

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解的核心思路均围绕**排序策略**展开：
- **排序规则**：将区间按左端点升序排列，若左端点相同则按右端点降序排列。此排序保证：若存在区间包含关系，则被包含的区间一定出现在包含它的区间之后。
- **线性扫描**：排序后，只需检查相邻区间是否满足包含关系，时间复杂度为 $O(n \log n)$。

#### **解决难点**
- **正确性证明**：需证明排序后，任何包含关系必然出现在相邻区间中。反证法可证：若存在非相邻的包含关系，则排序后中间区间的左端点必然更小或右端点更大，导致无法跳过中间区间。
- **离散化优化**：部分题解（如 Fido_Puppy）通过离散化右端点结合树状数组处理，虽正确但复杂度高，不如直接排序简洁。

---

### **题解评分 (≥4星)**

1. **caibet (5星)**
   - **亮点**：代码简洁，排序策略清晰，正确性直观。
   - **代码可读性**：结构体排序逻辑明确，注释到位。
   - **优化程度**：最优的 $O(n \log n)$ 实现。

2. **__AFO__ (4星)**
   - **亮点**：补充了排序规则的详细解释，适合新手理解。
   - **不足**：代码与 caibet 重复，缺乏创新。

3. **Addicted_Game (4星)**
   - **亮点**：维护最大右端点变量，简化判断逻辑。
   - **不足**：未处理左端点相同但右端点不同的边界情况。

---

### **最优思路或技巧提炼**

**关键步骤**：
1. **排序**：`sort(a, cmp)`，其中 `cmp` 按左升序、右降序排列。
2. **相邻检查**：遍历排序后的数组，比较每个区间与前一个是否满足 $a_{i-1}.r \geq a_i.r$。

**代码片段**：
```cpp
struct node { int l, r, id; };
bool cmp(node x, node y) {
    return x.l < y.l || (x.l == y.l && x.r > y.r);
}

sort(a, a + n, cmp);
for (int i = 1; i < n; i++) {
    if (a[i-1].r >= a[i].r) {
        cout << a[i].id << " " << a[i-1].id;
        return 0;
    }
}
```

---

### **同类型题或类似算法套路**

- **逆序对问题**：如 [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)，利用排序后的相邻比较。
- **区间覆盖问题**：如 [CF1029C Maximal Intersection](https://codeforces.com/problemset/problem/1029/C)，需维护极值。

---

### **推荐相似题目**

1. **CF1029C**：寻找删除一个区间后的最大交集。
2. **P3740**：区间覆盖问题，需贪心选择右端点。
3. **P1908**：逆序对统计，需分治或树状数组。

---

### **可视化与算法演示**

**动画设计**：
1. **排序阶段**：展示区间按左端点升序、右端点降序的动态排序过程。
2. **扫描阶段**：高亮当前比较的相邻区间，若满足包含关系则标记红色。
3. **音效提示**：找到解时播放“成功”音效，否则“失败”音效。

**复古风格**：
- **像素区间条**：用 8-bit 风格绘制区间，左端点对齐，右端点延伸。
- **自动演示**：模拟排序和扫描过程，单步执行可观察每一步的对比。

**交互功能**：
- **速度调节**：滑动条控制动画速度。
- **单步调试**：允许用户点击执行下一步，观察变量变化。

---

### **代码实现 (核心逻辑)**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct Node { int l, r, id; };
Node a[300005];

bool cmp(Node x, Node y) {
    return x.l < y.l || (x.l == y.l && x.r > y.r);
}

int main() {
    int n; cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i].l >> a[i].r;
        a[i].id = i + 1;
    }
    sort(a, a + n, cmp);
    for (int i = 1; i < n; i++) {
        if (a[i-1].r >= a[i].r) {
            cout << a[i].id << " " << a[i-1].id;
            return 0;
        }
    }
    cout << "-1 -1";
    return 0;
}
```

---

**总结**：排序策略是解决该题的核心，正确性和效率均最优。其他方法虽可行，但复杂度或实现难度较高。

---
处理用时：95.40秒
# 题目信息

# Milking cows

## 题目描述

Iahub在农场帮助他的祖父，今天他必须挤牛奶。农场里有$n$只牛左成一排，从左到右编号$1$到$n$。每只牛不是面向左边就是面向右边。当Iahub挤某一只牛的牛奶时，所有看得到这当前只牛的牛都会因为受到惊吓而损失一单位量的牛奶。面向左边的牛可以看到它左边的所有牛（不包括自己），面向右边的牛可以看到它右边的所有牛（不包括自己）。被惊吓过的牛可以再次被惊吓。被挤过奶的牛不会再被惊吓。我们假定每一头牛可以生产无限量的牛奶。

Iahub可以决定挤牛奶的顺序，但他必须每头牛都要挤。Iahub想损失尽可能少的牛奶。请输出最少的牛奶损失量。

## 说明/提示

在第一个样例中,Iahub按照下面的顺序可以使得牛奶损失最少：$3,4,2,1$。当他挤牛$3$时，牛$4$会损失$1$单位牛奶。在此之后，没有牛奶损失。

Translated by @Imakf

## 样例 #1

### 输入

```
4
0 0 1 0
```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 0 1 0 1
```

### 输出

```
3```

# AI分析结果



## 算法分类
贪心

---

## 综合分析与结论
### 题目核心思路
所有题解均基于贪心策略：统计每个朝左的牛左侧朝右的牛的数量总和。通过选择挤奶顺序（如先挤朝右的牛从左到右，再挤朝左的牛从右到左），使得总损失等于所有“朝右牛在朝左牛左侧”的对数总和。

### 解决难点
1. **贪心顺序推导**：需发现挤奶顺序不影响最终总和，总损失等于所有方向相反的牛对数。
2. **等价性证明**：证明从左到右统计朝左牛的右侧朝右牛，与从右到左统计朝右牛的左侧朝左牛结果相同。
3. **线性计算**：无需模拟挤奶顺序，只需遍历一次数组，用前缀和思想统计总和。

### 核心算法流程
1. 初始化计数器 `cnt` 和 `sum`。
2. 遍历每头牛：
   - 若牛朝右，`cnt++`。
   - 若牛朝左，`sum += cnt`。
3. 最终 `sum` 即为最小损失。

---

## 题解清单（≥4星）
### 1. 花里心爱（5星）
- **亮点**：思路清晰，代码简洁，证明两种统计方式等价。
- **代码**：线性遍历+前缀和，时间复杂度 O(n)。

### 2. Buried_Dream（5星）
- **亮点**：代码可读性高，变量命名明确，直接给出贪心结论。
- **代码**：与花里心爱解法一致，注释简洁。

### 3. Qerucy（4星）
- **亮点**：明确前缀和思想，代码注释详细。
- **代码**：与主流解法一致，强调开 long long。

---

## 最优思路与技巧
### 关键技巧
- **前缀和统计**：遍历时动态维护朝右牛的数量，遇到朝左牛时累加。
- **方向等价性**：统计朝左牛左侧的朝右牛数，或朝右牛右侧的朝左牛数，结果相同。
- **线性复杂度**：无需复杂数据结构，一次遍历即可完成。

---

## 同类题目推荐
1. **P1908 逆序对**：统计逆序对数量，类似方向相反的牛对数。
2. **P1106 删数问题**：贪心策略选择最优删除顺序。
3. **P1094 纪念品分组**：贪心+双指针处理配对问题。

---

## 可视化与算法演示
### 动画设计
1. **元素表示**：
   - 牛用箭头图标表示方向（←/→）。
   - 当前遍历的牛高亮为黄色。
   - `cnt` 和 `sum` 实时显示在顶部。

2. **关键步骤**：
   - 遇到→牛，`cnt` 增加，右侧显示绿色+1动画。
   - 遇到←牛，`sum` 增加当前 `cnt`，左侧显示红色累加动画。

3. **交互功能**：
   - 步进控制：允许单步执行观察 `cnt` 和 `sum` 变化。
   - 速度调节：滑动条控制遍历速度。

### 复古像素风格
- **UI设计**：16色调色板，牛用 8x8 像素箭头表示。
- **音效**：
  - 步进音效：短促“哔”声。
  - 累加音效：硬币收集音效。
- **背景音乐**：8-bit 循环旋律。

---

## 代码片段
```cpp
// 核心代码（花里心爱题解）
#include<cstdio>
using namespace std;

int main() {
    int n, t;
    long long cnt = 0, sum = 0;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &t);
        if (t) ++cnt;
        else sum += cnt;
    }
    printf("%lld\n", sum);
    return 0;
}
```

---

## 个人心得
- **方向等价性**：最初误以为两种统计方式不同，通过数学归纳发现其本质相同。
- **前缀和陷阱**：未初始化 `cnt` 导致首个元素处理错误，调试时需注意边界。

---

**可视化示例**：  
![动画示意图](https://via.placeholder.com/400x200/000000/FFFFFF/?text=←←→←+cnt=1→sum=1)  
（图示：遍历至第四头牛（←）时，`cnt=1`，`sum` 累加为1）

---
处理用时：334.53秒
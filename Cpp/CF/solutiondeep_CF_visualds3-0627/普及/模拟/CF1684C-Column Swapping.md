# 题目信息

# Column Swapping

## 题目描述

如果一个表格每行都单调不降，称它为好的。  
给你 $t$ 个 $n_i$ 行 $m_i$ 列的表格，对于每个表格，询问是否能通过调换某两列 **（不一定不同）** 使得这个表格是好的（这样的操作需要且仅能执行一次）。如果可以，输出两列的编号；不可以，输出 $-1$。

## 说明/提示

$1\le t\le 100$  
$1\le n,m\le 2\times 10^5$  
$\sum n\times m\le 2\times 10^5$  
表格中的每一个数不超过 $10^9$  

**样例解释**  
**第一个**表格原本就是好的，因此可以将第一列和自己对调。  

**第二个**表格中，对调第 $1$ 和第 $2$ 列，会变成  
$$1,4$$  
$$3,2$$  
不是好的。如果对调任意一列和它自己，就是原本的表格，不是好的。因此输出`-1`。  

**第三个**表格中，对调第 $1$，$2$ 列，表格变为  
$$1,2$$
$$1,1$$
是好的。因此输出`1 2`。  

**第四个**表格中，调换第 $1$，$3$ 列，表格变为  
$$1,2,6$$  
$$3,4,5$$  
表格变为好的。输出 `1 3`  

**最后一个**表格中，每一行只有一个数，是单调不降的，但是只有一列，所以需要将这一列和自己对调。

## 样例 #1

### 输入

```
5
2 3
1 2 3
1 1 1
2 2
4 1
2 3
2 2
2 1
1 1
2 3
6 2 1
5 4 3
2 1
1
2```

### 输出

```
1 1
-1
1 2
1 3
1 1```

# AI分析结果



**算法分类**：模拟、贪心

---

### **题解思路与算法要点**

1. **核心思路**  
   每行排序后与原行比较，找出必须交换的两列位置。若所有行的错误位置一致，则交换这两列，并验证所有行是否非递减。

2. **关键步骤**  
   - 对每行生成排序后的版本，与原行比较，记录差异位置。
   - 若某行差异位置数超过2，无解。
   - 统一所有行的差异位置，若不一致则无解。
   - 最终交换这两列并验证所有行的有序性。

3. **解决难点**  
   - **列一致性**：所有行的差异位置必须相同或为空。
   - **原本正确的行处理**：交换后的列必须不影响其顺序（如两列值相等或交换后仍有序）。
   - **验证复杂度**：需遍历所有行检查交换后的顺序，时间复杂度仍为可接受的O(nm)。

---

### **题解评分（≥4星）**

1. **作者：fast_photon（5星）**  
   - **亮点**：通过全局变量维护交换列，最后统一验证所有行交换后的正确性。
   - **代码可读性**：逻辑清晰，注释详细。
   - **核心代码**：
     ```cpp
     if (~y1)
     for(int i = 0; i < n; i++) {
         if(a[i][y1] < a[i][y2]) {
             flag = false;
             break;
         }
     }
     ```

2. **作者：happy_dengziyue（4星）**  
   - **亮点**：直接交换并全行检查，确保正确性。
   - **代码实现**：
     ```cpp
     for(int i=1;i<m;++i)if(a[i]>a[i+1])return false; // 检查行是否有序
     ```

3. **作者：Marxistdzy（Python）（4星）**  
   - **亮点**：代码简洁，直接交换后验证所有行。
   - **代码片段**：
     ```python
     for i in range(n):
         if arr[i] != sorted(arr[i]):
             check = True
             break
     ```

---

### **最优思路与技巧**

1. **关键技巧**  
   - **排序对比法**：通过排序后的行快速定位差异位置。
   - **全局统一交换列**：确保所有行的差异位置一致。
   - **全行验证**：最终必须遍历所有行确保交换后的正确性。

2. **实现优化**  
   - 维护首行的差异列作为候选，后续行仅匹配候选列。
   - 处理原本正确的行时，确保交换列的值相等或交换后仍有序。

---

### **类似题目推荐**

1. **CF456A - Laptops**  
   - 判断是否存在两列交换后满足条件。
2. **LeetCode 942 - DI String Match**  
   - 构造满足特定增减条件的序列。
3. **洛谷 P1102 学生分组**  
   - 调整分组使满足约束，涉及贪心与分类讨论。

---

### **可视化与算法演示**

**动画设计**：
1. **网格展示**：表格以网格显示，当前行高亮，排序后的差异位置标红。
2. **交换演示**：选定两列交换，动态显示交换后行的顺序变化。
3. **验证流程**：逐行扫描，绿色表示通过，红色表示失败。

**复古像素风格**：
- **颜色方案**：8位色（红、绿、蓝、黄）表示不同状态。
- **音效**：交换时播放“点击”音效，验证通过/失败对应不同音调。
- **自动演示**：按步执行，允许暂停/调速，展示算法决策流程。

**核心逻辑演示**：
```javascript
// 伪代码示例：交换列并验证
function validateSwap(matrix, col1, col2) {
    for (let row of matrix) {
        [row[col1], row[col2]] = [row[col2], row[col1]]; // 交换
        if (!isNonDecreasing(row)) return false;
        [row[col1], row[col2]] = [row[col2], row[col1]]; // 还原
    }
    return true;
}
```

---

### **总结**

通过排序对比定位差异列，统一候选列后全体验证，确保算法正确性。关键在处理原本正确的行与全局列一致性问题。

---
处理用时：207.14秒
# 题目信息

# Caisa and Sugar

## 题目描述

Caisa 要举办一个派对，他要购买巧克力蛋糕的原料。为此，他去了镇上最大的超市。

不巧，他只有 $s$ 美元买食糖。但这可不是悲伤的理由，因为超市里有 $n$ 种食糖，或许他可以买某一个。但这还没完。超市有着非常特别的找零政策：把糖果给买家作为找零，而不是美分。当然，给的糖果的数量始终不会超过 $99$，因为每个卖家都会最大化找零中美元的数量（$100$ 美分可以换成 $1$ 美元）。

Caisa 只想买一种食糖，同时他也希望找零中的糖果数量最多。他最多能得到多少糖果？请注意，Caisa 并不想降低买食糖的开销，他只想得到最多的糖果找零。

## 说明/提示

在第一个样例中，Caisa 可以买第四种食糖，这种情况下他能得到 $50$ 个糖果找零。

## 样例 #1

### 输入

```
5 10
3 90
12 0
9 70
5 50
7 0
```

### 输出

```
50
```

## 样例 #2

### 输入

```
5 5
10 10
20 20
30 30
40 40
50 50
```

### 输出

```
-1
```

# AI分析结果



---

**唯一算法分类**  
模拟

---

**综合分析与结论**  

本题核心是模拟超市找零规则，通过遍历所有食糖选项计算最大糖果找零。关键点在于正确处理价格边界条件和找零计算，需注意以下要点：

1. **购买条件判断**  
   将美元转换为美分处理，避免浮点误差。总价格必须满足 `x*100 + y ≤ s*100`，其中 `x` 为美元，`y` 为美分。

2. **找零计算**  
   找零的糖果数为剩余美分余数，即 `(100 - y) % 100`。当 `y=0` 时，余数为 0；否则为 `100 - y`。

3. **边界情况处理**  
   - `x = s` 时，只有 `y=0` 才能购买（此时找零为 0）。
   - 所有价格超过 `s` 的选项直接跳过。

---

**题解清单 (≥4星)**  

1. **丧黑福造 (4星)**  
   - **关键亮点**：直接通过 `x < s || (x == s && y == 0)` 判断购买条件，避免全局转换美分，代码简洁高效。
   - **代码片段**：
     ```cpp
     if (x < s || (x == s && y == 0))
         ans = max(ans, y == 0 ? 0 : 100 - y);
     ```

2. **xiaobeng_0912 (4星)**  
   - **关键亮点**：统一转换为美分处理，逻辑清晰，可读性强。
   - **代码片段**：
     ```cpp
     s *= 100; // 转换为美分
     p = x * 100 + y;
     if (p <= s) maxn = max(maxn, y == 0 ? 0 : 100 - y);
     ```

3. **vincehex (4星)**  
   - **关键亮点**：通过 `x + (y > 0) ≤ s` 巧妙等价判断总价格，代码简洁。
   - **代码片段**：
     ```cpp
     x += (y > 0);
     if (x <= s) mx = max(mx, (100 - y) % 100);
     ```

---

**最优思路或技巧提炼**  

- **统一美分处理**：避免浮点误差，直接使用整数运算。
- **找零公式优化**：`(100 - y) % 100` 可同时处理 `y=0` 和 `y≠0` 的情况。
- **边界判断简化**：将总价格条件转换为 `x + (y > 0) ≤ s`，减少计算步骤。

---

**同类型题或类似算法套路**  

- **货币转换与取模**：如计算找零、时间转换等。
- **边界条件模拟**：如判断区间包含、数值范围限制。

---

**推荐洛谷题目**  

1. **P1003 铺地毯**（模拟，边界处理）  
2. **P1055 ISBN号码**（数值处理，取模运算）  
3. **P1424 小鱼的航程**（循环模拟，条件判断）

---

**个人心得摘录**  

- **调试教训**：浮点数可能导致精度问题（如 Light_Star_RPmax_AFO 的题解），应优先使用整数运算。
- **思维顿悟**：找零公式 `(100 - y) % 100` 的推导，避免复杂分情况讨论。

---

**可视化与算法演示**  

**动画方案设计**  

1. **像素风格界面**  
   - 使用 8-bit 像素风格显示食糖选项表格，每行包含 `x`, `y`, 价格（美分），是否可购买（绿/红），当前找零糖果数。
   - **颜色标记**：选中选项高亮黄色，最大值显示为金色。

2. **核心流程演示**  
   - **步骤1**：输入 `s` 美元，转换为美分（`s * 100`）显示在顶部。
   - **步骤2**：遍历每个食糖，计算 `x*100 + y`，若超过 `s*100` 标记为红色。
   - **步骤3**：对可购买的选项计算 `(100 - y) % 100`，更新最大值并播放音效。

3. **交互功能**  
   - **步进控制**：允许单步执行观察每个选项处理。
   - **音效提示**：找到更大值时播放上扬音效，无解时播放失败音效。
   - **自动模式**：模拟“AI 自动购买”，动态展示最大值变化。

**复古游戏化设计**  
- **像素音效**：使用 8-bit 音效，如“选择”声、“最大值更新”声。
- **积分系统**：每正确处理一个选项得 10 分，最终根据正确率显示评级（S/A/B/C）。

---

**代码实现（核心逻辑）**  

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, s, max_candy = -1;
    cin >> n >> s;
    s *= 100; // 转换为美分
    for (int i = 0; i < n; ++i) {
        int x, y;
        cin >> x >> y;
        int price = x * 100 + y;
        if (price > s) continue;
        int candy = (y == 0) ? 0 : 100 - y;
        max_candy = max(max_candy, candy);
    }
    cout << (max_candy == -1 ? -1 : max_candy);
    return 0;
}
```

---
处理用时：289.10秒
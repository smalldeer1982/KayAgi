# 题目信息

# New Year Book Reading

## 题目描述

小明非常喜欢读书。他一共有 $n$ 本书，编号为 $1\sim n$，第 $i$本书重 $w_i$。

小明计划在暑假的 $m$ 天里每天读一本书，第 $i$ 天读第 $d_i$ 本书，可能会重复读到同一本书。

因为所有的书都是堆成一摞的，所以每次读某本书之前小明都需要先将这本书上面所有的书搬开，拿出这本书，再将搬开的书按原顺序放回去，消耗体力为搬开书的重量之和，读完这本书后将其放在这摞书的最上面。

小明想知道这 $n$ 本书以怎样的初始顺序放置，所搬书消耗总体力最小。

## 样例 #1

### 输入

```
3 5
1 2 3
1 3 2 3 1
```

### 输出

```
12
```

# AI分析结果



## 唯一算法分类
贪心

---

## 综合分析与结论

### 核心算法流程
题目要求最小化搬书的总体力消耗，关键在于确定初始书的堆叠顺序。所有题解均基于以下贪心策略：**按照每本书第一次出现的顺序倒序排列**（即先出现的书放在上层）。每次读书时，需要搬动该书之前所有出现过的不同书的重量之和。

**可视化设计思路**：
1. 用栈结构动态维护当前书的堆叠顺序，每次读书后将该书移动到栈顶。
2. 每次计算体力时，高亮当前需要搬动的书，并动态更新栈结构。
3. 使用颜色区分已统计过的书和未统计的书，突出当前操作步骤。

### 复古像素风格实现要点
1. **8位色彩**：用8种颜色表示不同书籍，栈结构用垂直排列的方块表示。
2. **Canvas动画**：每一步操作（搬书、移动书）以方块滑动动画呈现，伴随“咔嗒”音效。
3. **音效触发**：搬动书时播放低音，找到最优解时播放胜利音效。
4. **自动演示模式**：按时间步进自动展示每次读书过程，支持暂停/继续。

---

## 题解清单 (≥4星)

### 一叶知秋（5星）
- **亮点**：通过构造初始序列并动态维护栈顺序，时间复杂度O(n²)，思路清晰。
- **关键代码**：
  ```cpp
  // 构造初始序列（按第一次出现顺序）
  while(i<=m){
      if(v[b[i]]) continue;
      xl[++k]=b[i]; v[b[i]]=true;
  }
  // 计算体力
  for(j=k;j>=1;j--){
      if(b[i]==xl[j]) break;
      s += a[xl[j]];
  }
  ```

### Luckies（4星）
- **亮点**：直接通过倒序枚举历史记录统计重量，代码简洁，时间复杂度O(m²)。
- **关键代码**：
  ```cpp
  for(int j=i-1;j>=1;j--){
      if(a[j]==a[i]) break;
      if(!vis[a[j]]) sum += w[a[j]];
  }
  ```

### 墨舞灵纯（4星）
- **亮点**：最简实现，通过memset快速重置标记数组，突出核心逻辑。
- **关键代码**：
  ```cpp
  memset(q,0,sizeof(q));
  for(int j=i-1;j;j--){
      if(b[i]==b[j]) break;
      if(!q[b[j]]) ans += a[b[j]];
  }
  ```

---

## 最优思路提炼
1. **贪心策略**：书的初始顺序按第一次出现倒序排列，确保后续操作体力最小。
2. **状态维护**：每次读书后将该书置于栈顶，后续操作只需考虑之前出现的不同书籍。
3. **高效统计**：通过倒序遍历和标记数组避免重复计算，将时间复杂度控制在可接受范围。

---

## 类似题目推荐
1. **P1090 合并果子** - 贪心+优先队列
2. **P1443 马的遍历** - BFS+路径记录
3. **P1177 快速排序** - 分治策略

---

## 可视化算法演示
```javascript
// 伪代码示例：Canvas绘制书堆栈
function drawStack(books) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    books.forEach((book, idx) => {
        drawRect(10, 100 + idx*30, book.color); 
        drawText(20, 115 + idx*30, book.id);
    });
}

// 搬书动画示例
function animateMove(bookId) {
    let targetY = 100;
    // 当前书向上滑动，其他书下移
    // 伴随"pop"音效
}
```

---

## 个人心得摘录
"发现样例中将重量调换顺序答案不变，顿悟重量不影响初始顺序排列，仅影响统计时的计算。" —— 一叶知秋

"通过倒序枚举和标记数组，既避免重复计算又简化代码，是本题的解题关键。" —— Luckies

---

**答案**
根据各题解分析，正确解法是统计每次读书时之前出现过的不同书的重量之和。最终答案的最优解为这些累加值的总和。

```cpp
// Luckies解法核心代码
#include<bits/stdc++.h>
using namespace std;
const int N = 1e3 + 5;
int n, m, w[N], a[N], ans;
bool vis[N];

int main() {
    cin >> n >> m;
    for(int i=1; i<=n; i++) cin >> w[i];
    for(int i=1; i<=m; i++) {
        cin >> a[i];
        memset(vis, 0, sizeof(vis));
        int sum = 0;
        for(int j=i-1; j>=1; j--) {
            if(a[j] == a[i]) break;
            if(!vis[a[j]]) {
                sum += w[a[j]];
                vis[a[j]] = true;
            }
        }
        ans += sum;
    }
    cout << ans;
    return 0;
}
```

---
处理用时：123.82秒
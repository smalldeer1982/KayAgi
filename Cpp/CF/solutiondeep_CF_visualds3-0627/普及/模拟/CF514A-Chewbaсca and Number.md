# 题目信息

# Chewbaсca and Number

## 题目描述

Luke Skywalker gave Chewbacca an integer number $ x $ . Chewbacca isn't good at numbers but he loves inverting digits in them. Inverting digit $ t $ means replacing it with digit $ 9-t $ .

Help Chewbacca to transform the initial number $ x $ to the minimum possible positive number by inverting some (possibly, zero) digits. The decimal representation of the final number shouldn't start with a zero.

## 样例 #1

### 输入

```
27
```

### 输出

```
22
```

## 样例 #2

### 输入

```
4545
```

### 输出

```
4444
```

# AI分析结果



---

### 唯一算法分类
无算法分类（纯模拟与贪心策略）

---

### 综合分析与结论

#### 核心思路
**贪心策略**：对每一位数字，选择原数字或反转后的数字（9-t）中的较小值。特殊处理首位，确保最终结果不以0开头。若首位处理后为0（仅当原数字为9时可能），将其修正为9。

#### 解决难点
1. **首位特殊处理**：若首位反转后为0，需强制修正为9（如输入9→处理为9而非0）。
2. **统一贪心选择**：对每一位独立比较原值与反转值，避免复杂条件分支。

#### 可视化设计
- **动画流程**：
  1. 输入数字字符串按字符分块显示。
  2. 逐位高亮当前处理字符，显示原值（如蓝色）和反转值（如红色）。
  3. 选择较小值（绿色标记），若为第一位且结果为0，触发红色闪烁并修正为9。
- **复古像素风格**：
  - 使用16色调色板（如NES风格），字符块以8x8像素呈现。
  - 音效：选择时播放短促“滴”声，修正首位时播放“升级”音效。

---

### 题解清单（≥4星）

#### 1. 引领天下（★★★★★）
- **亮点**：代码极简，`min(a[i], 9+'0'-a[i])` 统一处理所有位，逻辑清晰。
- **核心代码**：
  ```cpp
  for (int i=0;a[i];i++) a[i] = min(a[i], 9+'0'-a[i]);
  if (a[0]=='0') a[0]='9';
  ```

#### 2. Frank_R_Z（★★★★★）
- **亮点**：同思路，代码简洁易读，注释明确。
- **核心代码**：
  ```cpp
  for(int i=0;i<a.size();i++) a[i] = min(a[i], 9+48 - a[i]);
  if(a[0]=='0') a[0]='9';
  ```

#### 3. PC_DOS（★★★☆☆）
- **亮点**：首位单独判断，但条件分支较多。
- **核心代码**：
  ```cpp
  if (sNum[0] >= '5' && sNum[0] <= '8') sNum[0] = '9' - sNum[0] + '0';
  for (i=1; i<len; i++) 
      if (sNum[i] >= '5') sNum[i] = '9' - sNum[i] + '0';
  ```

---

### 最优思路提炼
**贪心策略**：逐位比较 `t` 与 `9-t`，取较小值。首位若为0则修正为9。  
**实现技巧**：
- 用字符直接运算避免类型转换（`9+'0'-a[i]`）。
- 统一处理所有位后修正首位，逻辑高度聚合。

---

### 同类型题推荐
1. **P1106 删数问题**：贪心删除k位得最小数。
2. **P1012 拼数**：贪心排序拼接最大数。
3. **P1288 取数游戏**：环形数组取数策略。

---

### 个人心得摘录
- **Frank_R_Z**：强调字符串处理的便捷性（“string最为funny”）。
- **Star_Wind**：调试时因忘记字符转换（`+'0'`）导致错误。
- **yuzhechuan**：边读边处理的首位特判方式。

---

### 核心代码实现（引领天下版）
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[20];
int main() {
    scanf("%s",a);
    for (int i=0; a[i]; i++) 
        a[i] = min(a[i], (char)(9 + '0' - a[i]));
    if (a[0] == '0') a[0] = '9';
    printf("%s",a);
}
```

---

### 可视化算法演示
**步骤**：
1. 输入数字分割为独立字符块。
2. 遍历每个块：
   - **高亮当前块**，显示原值（蓝色）与反转值（红色）。
   - 选择较小值（绿色覆盖），若为首位且为0→自动变为9（黄色闪烁）。
3. **动态效果**：
   - 像素块动画：每步0.5秒延迟，音效同步。
   - 错误提示：首位误为0时震动+警示音。

**复古风格**：
- **调色板**：黑底、蓝/红/绿块、黄闪。
- **音效**：Chip-tune风格音效（JS Audio API）。

---
处理用时：180.98秒
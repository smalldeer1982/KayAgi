# 题目信息

# L-shapes

## 题目描述

An L-shape is a figure on gridded paper that looks like the first four pictures below. An L-shape contains exactly three shaded cells (denoted by \*), which can be rotated in any way.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1722F/c4bb8e8c5c94521e87ed2d5ba5ef373384bb7be7.png)You are given a rectangular grid. Determine if it contains L-shapes only, where L-shapes can't touch an edge or corner. More formally:

- Each shaded cell in the grid is part of exactly one L-shape, and
- no two L-shapes are adjacent by edge or corner.

For example, the last two grids in the picture above do not satisfy the condition because the two L-shapes touch by corner and edge, respectively.

## 样例 #1

### 输入

```
10
6 10
........**
.**......*
..*..*....
.....**...
...*.....*
..**....**
6 10
....*...**
.**......*
..*..*....
.....**...
...*.....*
..**....**
3 3
...
***
...
4 4
.*..
**..
..**
..*.
5 4
.*..
**..
....
..**
..*.
3 2
.*
**
*.
2 3
*..
.**
3 2
..
**
*.
3 3
.**
*.*
**.
3 3
..*
.**
..*```

### 输出

```
YES
NO
NO
NO
YES
NO
NO
YES
NO
NO```

# AI分析结果



---

**算法分类选择**  
其他搜索

---

## **题解思路、算法要点与解决难点**

### **核心思路**
题目要求判断网格中的星号（`*`）是否全部组成合法的 L 型，且这些 L 型之间不通过边或角相邻。各题解的共性思路是：
1. **枚举 L 型模式**：通过检查每个 `*` 的可能形状（如 2x2 区域中的 3 个 `*`），确定其是否构成 L 型。
2. **验证周围区域**：确保 L 型周围不存在其他 `*`（避免相邻）。
3. **标记已处理单元格**：将合法 L 型的 `*` 标记为已处理，最终检查剩余 `*`。

### **解决难点**
- **L 型形状判定**：不同旋转方向的 L 型需要不同的条件判断，容易遗漏情况。
- **相邻检查**：需检查周围 8 个方向（边和角），防止非法接触。
- **覆盖所有情况**：例如连续三个 `*` 的直线、对角线的两个 `*` 等非法情况需排除。

### **搜索算法对比**
- **Binary_Lee 题解**：直接枚举四种可能的 L 型旋转方向，通过硬编码条件检查周围区域，避免搜索。
- **CodingShark 题解**：使用 BFS 遍历连通块，检查块大小是否为 3，并排除非法形状。
- **lihanwen12 题解**：逐个单元格判断是否为 L 型的一角，标记并检查周围。

---

## **题解评分 (≥4星)**

### **1. Binary_Lee 题解 (⭐⭐⭐⭐⭐)**
- **亮点**：  
  - 直接枚举四种 L 型方向，条件检查清晰。  
  - 代码简洁，通过标记清除法快速验证合法性。  
  - 无需复杂数据结构，时间复杂度低（O(nm)）。  
- **核心代码**：  
  ```cpp
  void search(int i,int j){
      // 检查四种 L 型方向，并清除合法 L 型
      if(条件1满足) {清除并返回;}
      if(条件2满足) {清除并返回;}
      // ...
  }
  ```

### **2. include_BM 题解 (⭐⭐⭐⭐)**
- **亮点**：  
  - 通过排除相邻 L 型形成的非法模式（如连续三个 `*`）。  
  - 利用 2x2 区域处理 L 型，逻辑直观。  
- **核心代码**：  
  ```cpp
  for(int i=1;i<n;++i) for(int j=1;j<m;++j){
      int num = (s[i][j]=='*') + ...; // 计算 2x2 区域的 * 数量
      if(num==3) s[i][j]=s[i+1][j]=s[i][j+1]=s[i+1][j+1]='.'; // 清除合法 L 型
  }
  ```

### **3. CodingShark 题解 (⭐⭐⭐)**
- **亮点**：  
  - 使用 BFS 检查连通块大小，系统性强。  
  - 排除直线和对角线非法情况。  
- **缺点**：  
  - 代码复杂度较高，需处理多个条件分支。

---

## **最优思路或技巧提炼**
1. **枚举 L 型方向**：通过预定义四种可能的 L 型旋转方向，减少搜索范围。
2. **标记清除法**：将合法 L 型的 `*` 标记为已处理，最终检查剩余 `*`。
3. **硬编码条件检查**：直接判断 L 型周围是否全为 `.`，避免复杂搜索。

---

## **同类型题或类似算法套路**
- **形状识别**：如判断网格中的特定模式（俄罗斯方块、数独区域）。
- **连通块合法性**：如检查岛屿是否满足特定条件（[P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)）。
- **相邻约束检查**：如扫雷中的数字与雷分布（[P2670](https://www.luogu.com.cn/problem/P2670)）。

---

## **推荐相似题目**
1. **P1162 填涂颜色**（连通块边界标记）  
2. **P2895 [USACO08FEB] Meteor Shower S**（BFS 与条件约束）  
3. **P2670 扫雷游戏**（相邻单元格检查）

---

## **可视化与算法演示**
### **动画设计**
1. **网格绘制**：以 8 位像素风格渲染网格，`*` 为黄色方块，合法 L 型标记为绿色，非法区域为红色。
2. **扫描过程**：高亮当前检查的 `*`，逐步显示四种 L 型方向的判定结果。
3. **清除效果**：合法 L 型清除时播放“叮”音效，非法时播放“哔”音效。
4. **最终检查**：剩余 `*` 闪烁提示非法。

### **交互功能**
- **步进控制**：允许单步执行，观察 L 型判定逻辑。
- **自动播放**：AI 自动扫描网格，展示合法/非法判定过程。
- **音效提示**：使用 8 位音效标记关键操作。

---

## **代码片段 (Binary_Lee 题解核心)**
```cpp
void search(int i, int j) {
    // 检查四种 L 型方向，并清除合法 L 型
    if (a[i+1][j] && a[i+1][j+1] && 周围全为 .) {
        a[i][j] = a[i+1][j] = a[i+1][j+1] = 0;
        return;
    }
    // 类似条件检查其他三种方向...
}
```

---

**总结**：通过枚举 L 型方向并硬编码条件检查，Binary_Lee 的题解以简洁高效的方式解决问题，适合快速实现。可视化设计可帮助理解 L 型的判定逻辑和相邻约束。

---
处理用时：77.19秒
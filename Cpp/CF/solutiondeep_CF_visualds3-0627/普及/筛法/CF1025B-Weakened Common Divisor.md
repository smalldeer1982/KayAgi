# 题目信息

# Weakened Common Divisor

## 题目描述

与  $GCD$  （最大公约数）类似，我们引进  $WCD$ （弱公约数）的概念， $ WCD$  的定义如下：

给出几对数 $\left( a_1,b_1 \right) ,\left( a_2,b_2 \right) ,\cdots ,\left( a_n,b_n \right)$ ，它们的  $WCD$  满足大于  $1 $ ，且能整除每个数对中至少一个数。  $WCD$  在一些情况下，可能不存在。

例如，给出这几对数 $\left[ \left( \text{12,}15 \right) ,\left( \text{25,}18 \right) ,\left( \text{10,}24 \right) \right]$  ，它们的   $WCD$  可以是 $ 2,3,5,6$  （这些数都满足严格大于  $1$  ，且能整除每个数对中至少一个数）

现在给你几对数，求他们的   $WCD$  。

## 样例 #1

### 输入

```
3
17 18
15 24
12 15
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
10 16
7 17
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
5
90 108
45 105
75 40
165 175
33 30
```

### 输出

```
5
```

# AI分析结果



## 算法分类  
**数论（质因数分解与 GCD/LCM 应用）**

---

## 题解思路与难点对比  

### 核心思路  
所有题解均围绕质因数分解与筛选展开，关键点在于：  
1. **WCD 的质因数必为答案**  
2. **只需验证候选质因数是否满足所有数对**  

### 题解对比  
1. **zhaotiensn（求 LCM 的 GCD）**  
   - **思路**：计算每对数的 LCM，求所有 LCM 的 GCD，分解其质因数。  
   - **优点**：避免分解大数，时间复杂度较低（O(n log a)）。  
   - **难点**：需数学证明此 GCD 的质因数必为 WCD。  

2. **si_zhong（分解首对数质因数+筛选）**  
   - **思路**：分解第一对数的质因数，依次验证每个质因数是否满足后续数对。  
   - **优点**：直观，避免处理复杂数论推导。  
   - **难点**：需高效分解质因数，且质因数数量为 O(log a) 级别。  

3. **Jasper08（预处理质数+分解）**  
   - **思路**：预处理小质数分解首对数，后续筛除非候选。  
   - **缺点**：预处理范围限制，可能遗漏大质数。  

### 精炼结论  
- **最优方法**：首对数质因数分解+筛选（时间复杂度最优）或 LCM 的 GCD 分解（代码更简洁）。  
- **关键变量**：质因数集合、GCD 累积值。  

---

## 题解评分 (≥4星)  

1. **zhaotiensn（4.5星）**  
   - **亮点**：数学推导巧妙，代码简洁，时间复杂度低。  
   - **代码可读性**：逻辑清晰，但需理解 GCD/LCM 转换关系。  

2. **si_zhong（4星）**  
   - **亮点**：直接分解质因数，逐步筛选，思路直观。  
   - **优化点**：可去重质因数减少验证次数。  

3. **Dreamunk（4星）**  
   - **亮点**：代码极简，仅分解首对数并线性筛选。  
   - **缺点**：未去重质因数，可能存在冗余检查。  

---

## 最优思路与技巧提炼  

### 关键思路  
1. **质因数必为答案**：若 x 是 WCD，其任意质因数 p 也是 WCD。  
2. **候选集缩小**：仅需检查首对数的质因数。  

### 技巧  
- **首对数分解**：仅分解第一对数的 a 和 b 的质因数，作为候选集。  
- **快速筛选**：对后续数对，检查候选质因数是否整除 a_i 或 b_i。  

### 代码片段（si_zhong 优化版）  
```cpp  
vector<int> get_factors(int x) {  
    vector<int> res;  
    for (int i=2; i*i<=x; ++i)  
        while (x%i == 0) res.push_back(i), x /= i;  
    if (x > 1) res.push_back(x);  
    return res;  
}  

int main() {  
    int n, a, b;  
    cin >> n >> a >> b;  
    auto factors = get_factors(a);  
    auto tmp = get_factors(b);  
    factors.insert(factors.end(), tmp.begin(), tmp.end());  
    sort(factors.begin(), factors.end());  
    factors.erase(unique(factors.begin(), factors.end()), factors.end());  

    for (int i=1; i<n; ++i) {  
        cin >> a >> b;  
        for (auto& p : factors)   
            if (a%p && b%p) p = -1;  
    }  
    for (auto p : factors)   
        if (p != -1) return cout << p, 0;  
    cout << -1;  
}  
```

---

## 类似题目推荐  
1. **P1029** 最大公约数和最小公倍数问题  
2. **P1072** Hankson 的趣味题  
3. **P2448** 无尽的任务  

---

## 可视化设计  

### 动画流程  
1. **分解质因数**：首对数的 a 和 b 被分解为质因数方块（像素风格）。  
2. **质因数队列**：显示候选质因数列表，初始颜色为绿色。  
3. **验证过程**：后续数对 (a_i, b_i) 进入，质因数方块变红若无法整除 a_i 或 b_i。  
4. **最终结果**：首个剩余绿色方块弹出，播放胜利音效。  

### 复古像素风格  
- **颜色方案**：8 位色（绿：有效，红：无效，黄：当前检查）。  
- **音效**：分解时的“切割”声，验证时的“点击”声，胜利时的 8 位音乐。  

### 交互功能  
- **步进控制**：按空格逐步执行分解和验证。  
- **自动演示**：AI 模式自动运行，速度可调。  

---

## 个人心得摘录  
> “直接求所有 LCM 的 GCD 再分解，避免了逐个分解大数的麻烦，但需要数学直觉证明其正确性。” —— zhaotiensn  
> “分解首对数后逐步排除，代码虽长但易于调试。” —— si_zhong  

---

## 核心算法演示代码（Canvas 伪代码）  
```javascript  
// 初始化质因数队列  
let factors = [2, 3, 5];  
drawFactors(factors);  

// 验证每个数对  
for (let pair of pairs) {  
    highlightPair(pair);  
    factors = factors.filter(p => divides(p, pair.a) || divides(p, pair.b));  
    updateFactorsColor(factors);  
    await sleep(1000);  
}  
```  

此代码模拟筛选过程，每步高亮当前数对并更新有效质因数。

---
处理用时：76.53秒
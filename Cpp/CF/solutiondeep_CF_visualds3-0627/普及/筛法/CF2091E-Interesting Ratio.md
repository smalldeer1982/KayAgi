# 题目信息

# Interesting Ratio

## 题目描述

最近，Misha 在 IT Campus "NEIMARK" 的夏令营中学习了新课题 —— 欧几里得算法。

当发现 $a \cdot b = \text{lcm}(a, b) \cdot \text{gcd}(a, b)$ 时，他有些惊讶。其中 $\text{gcd}(a, b)$ 是 $a$ 和 $b$ 的[最大公约数 (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor)，而 $\text{lcm}(a, b)$ 是[最小公倍数 (LCM)](https://en.wikipedia.org/wiki/Least_common_multiple)。Misha 想到既然 LCM 和 GCD 的乘积存在，或许它们的商也值得研究：$F(a, b) = \frac{\text{lcm}(a, b)}{\text{gcd}(a, b)}$。

例如，他取 $a = 2$ 和 $b = 4$，计算得到 $F(2, 4) = \frac{4}{2} = 2$，结果是一个质数（一个数如果恰好有两个因数则为质数）！现在他认为当 $a < b$ 且 $F(a, b)$ 是质数时，这个比值 $F(a, b)$ 是"有趣的比值"。

由于 Misha 刚接触数论，他需要你帮忙计算 —— 满足 $F(a, b)$ 是"有趣的比值"且 $1 \leq a < b \leq n$ 的不同数对 $(a, b)$ 有多少个？

## 说明/提示

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
5
10
34
10007```

### 输出

```
4
11
49
24317```

# AI分析结果



## 算法分类
**数论**

---

## 综合分析与结论
**核心思路**：通过数学推导发现，满足条件的数对必须满足 \( b = a \cdot p \)（\( p \) 为质数），转化为对每个质数 \( p \) 统计 \( a \) 的可能取值个数。

**算法流程**：
1. **预处理质数**：使用欧拉筛或埃氏筛法预处理范围内的质数。
2. **计算贡献**：对每个质数 \( p \)，累加 \( \lfloor n/p \rfloor \)，即满足 \( a \cdot p \le n \) 的 \( a \) 的个数。
3. **复杂度优化**：预处理质数 \( O(M) \)，查询 \( O(\pi(n)) \)。

**可视化设计**：
- **像素动画**：用网格表示数对 \( (a, p) \)，每次选中一个质数 \( p \)，动态绘制 \( \lfloor n/p \rfloor \) 个格子并累加总数。
- **音效反馈**：每选中一个质数播放“选中”音效，累计总数时播放“成功”音效。
- **步进控制**：允许单步查看每个质数的贡献。

---

## 题解清单（≥4星）
### 1. Collapsarr（5星）
- **亮点**：思路清晰，直接推导核心公式，代码简洁高效。
- **代码**：预处理质数后直接累加贡献，逻辑明确。

### 2. Error_Eric（4星）
- **亮点**：通过质因数数目统计答案，提供另一种等价思路。
- **优化**：预处理前缀和实现 \( O(1) \) 查询，适合多测试用例场景。

### 3. ZMQ_Ink6556（4星）
- **亮点**：引入指针优化枚举过程，降低冗余计算。
- **代码**：动态调整最大质数范围，提升效率。

---

## 最优思路与技巧
**关键推导**：\( F(a, b) \) 为质数当且仅当 \( b = a \cdot p \)。  
**实现技巧**：
1. **质数筛法**：预处理质数列表减少重复计算。
2. **贡献累加**：每个质数 \( p \) 的贡献为 \( \lfloor n/p \rfloor \)。

---

## 同类型题推荐
1. **P3912 素数个数**（质数筛法）
2. **P1029 最大公约数与最小公倍数问题**（gcd/lcm性质）
3. **P2429 制椅子**（质因数分解与数对统计）

---

## 个人心得摘录
- **边界条件**：注意 \( a < b \) 隐含 \( p \ge 2 \)，避免将 \( a = b \) 纳入统计。
- **筛法优化**：欧拉筛法比埃氏筛法更高效，尤其在大数据量时。

---

## 核心代码实现
```cpp
// 欧拉筛预处理质数
const int N = 1e7 + 10;
int prime[N], cnt;
bool is_prime[N];

void sieve() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    for (int i = 2; i < N; i++) {
        if (is_prime[i]) prime[++cnt] = i;
        for (int j = 1; j <= cnt && i * prime[j] < N; j++) {
            is_prime[i * prime[j]] = 0;
            if (i % prime[j] == 0) break;
        }
    }
}

// 计算答案
int solve(int n) {
    int ans = 0;
    for (int i = 1; i <= cnt && prime[i] <= n; i++) {
        ans += n / prime[i];
    }
    return ans;
}
```

---

## 可视化设计要点
- **像素风格**：用 8-bit 色块表示质数，每次选中一个质数时高亮其贡献区域。
- **动画逻辑**：
  1. 初始化质数列表，显示为红色方块。
  2. 遍历质数 \( p \)，绘制 \( \lfloor n/p \rfloor \) 个绿色方块（每个方块代表一个 \( a \)）。
  3. 累计总数显示在顶部，配动态增长效果。
- **音效触发**：
  - 选中质数：播放短促“滴”声。
  - 更新总数：播放“升级”音效。

---
处理用时：147.63秒
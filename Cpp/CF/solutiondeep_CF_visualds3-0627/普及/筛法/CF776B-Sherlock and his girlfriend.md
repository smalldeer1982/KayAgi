# 题目信息

# Sherlock and his girlfriend

## 题目描述

Sherlock 有一个新女朋友。现在情人节就要到了，他想送给她一些珠宝。 

他买了几件首饰。第 $i$ 件的价格等于 $i+ 1$，也就是说，珠宝的价格分别为 $2,3,4,n + 1$ 。

现在需要给这些珠宝首饰上色。**当一件珠宝的价格是另一件珠宝的价格的素因子时，这两件的颜色就不允许相同。** 此外，要最少化使用的颜色数量。

## 说明/提示

在第一个样例中，第一、第二和第三件首饰的价格分别为 $2$、$3$、$4$,它们的颜色分别为 $1$ 、$1$ 和 $2$。

在这种情况下，由于 $2$ 是 $4$ 的因子，所以具有因数 $2$ 和 $4$ 的珠宝的颜色必须是不同的。

Translated by @皎月半洒花。

## 样例 #1

### 输入

```
3
```

### 输出

```
2
1 1 2 ```

## 样例 #2

### 输入

```
4
```

### 输出

```
2
2 1 1 2
```

# AI分析结果



# 算法分类
**数论（素数筛法）**

---

# 题解思路与核心难点

## 核心思路
1. **质数与合数染色分离**：当且仅当一个数是另一个数的质因子时需要颜色不同。质数之间无公共质因子，可统一颜色；合数的质因子均为质数，只需与质数颜色不同。
2. **筛法标记质数**：使用埃氏筛或线性筛预处理所有数是否为质数。
3. **颜色数量决策**：当所有数均为质数时（即 `n < 3`），只需1种颜色；否则需要2种颜色。

## 解决难点
- **质因子条件理解**：需明确只有质数会作为质因子影响颜色分配，合数之间的颜色无需互斥。
- **筛法优化**：需高效标记质数以应对 `n ≤ 1e5` 的数据规模。

---

# 题解评分（≥4星）

1. **二哥啃菜包（5星）**
   - **亮点**：使用线性筛法，时间复杂度最优（O(n)），代码简洁高效。
   - **代码**：清晰标记质数后直接输出颜色，逻辑直击核心。

2. **Juanzhang（4星）**
   - **亮点**：埃氏筛优化（仅筛到√n），代码简短易理解。
   - **不足**：未完全处理线性筛的严格边界条件，但可通过题目约束规避。

3. **四氧化二磷（4星）**
   - **亮点**：结合贪心策略，直接筛法染色，代码极简。
   - **不足**：未明确说明质数颜色分配的数学依据。

---

# 最优思路与技巧提炼

1. **筛法染色法**：
   - **核心逻辑**：质数统一颜色1，合数统一颜色2。
   - **数学证明**：质数之间无公共质因子；合数的质因子必为质数，颜色已不同。
   ```cpp
   // 线性筛法标记质数
   vector<bool> is_prime(n+2, true);
   for (int i=2; i<=n+1; ++i) {
       if (is_prime[i]) {
           for (int j=2*i; j<=n+1; j+=i) 
               is_prime[j] = false;
       }
   }
   ```

2. **特判优化**：
   - **n ≤ 2** 时所有数为质数，颜色数为1。
   - **n ≥ 3** 时必含合数（如4），颜色数为2。

---

# 相似题目与算法套路

1. **质数判定与筛法**：P3383（线性筛模板）、P1217（回文质数）
2. **颜色分配优化**：P1843（奶牛分厩，类似因子互斥染色）
3. **图论二分图判定**：P1330（封锁阳光大学，质数-合数天然二分图）

---

# 推荐洛谷题目
1. **P3383** - 线性筛模板题
2. **P1217** - 质数判定与回文数结合
3. **P1835** - 质数区间筛法

---

# 可视化与算法演示

## 动画设计
- **像素风格筛法演示**：
  - **颜色标记**：质数为绿色方块，合数为红色方块。
  - **筛法过程**：高亮当前质数（如2），逐步划去其倍数（如4,6,8），触发红色闪烁。
  - **音效反馈**：划去合数时播放“哔”声，质数确认时播放“叮”声。

## 交互控制
- **步进控制**：允许单步执行筛法，观察每个质数的倍数标记。
- **速度调节**：滑动条控制动画速度（1x至10x）。

---

# 代码实现（线性筛法核心）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<bool> is_prime(n+2, true);
    is_prime[0] = is_prime[1] = false;
    for (int i=2; i<=n+1; ++i) {
        if (is_prime[i]) {
            for (int j=2*i; j<=n+1; j+=i)
                is_prime[j] = false;
        }
    }
    cout << (n < 3 ? 1 : 2) << endl;
    for (int i=2; i<=n+1; ++i)
        cout << (is_prime[i] ? 1 : 2) << " ";
    return 0;
}
```

---
处理用时：76.61秒
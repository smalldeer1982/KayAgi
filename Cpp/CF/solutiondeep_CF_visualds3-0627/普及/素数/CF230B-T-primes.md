# 题目信息

# T-primes

## 题目描述

我们知道质数是只有两个不同的正数因数的正整数。相似的，我们把一个正整数 _t_ 叫做 T质数，如果 _t_ 恰好有三个不同的正整数因数。 

你被给了一个含有 _n_ 个正整数的数组。你要给其中所有的数判断它是否是 T质数。

## 说明/提示

给定样例有三个数。第一个数4恰好有三个因数--1、2和4，因此对这个数字输出YES。第二个数5有两个因数（1和5），第三个数6有四个因数（1、2、3和6），因此这两个数的答案是NO。

## 样例 #1

### 输入

```
3
4 5 6
```

### 输出

```
YES
NO
NO
```

# AI分析结果



**唯一算法分类**：数学（数论）

---

### 题解思路、算法要点与解决难点  
**核心思路**  
T质数的定义要求数恰好有3个因数。通过数学推导可知，这样的数必须是**质数的平方**。  
- **完全平方数判定**：若 `x` 是完全平方数，则存在整数 `t` 使 `t² = x`。  
- **质数判定**：判断 `t` 是否为质数。  

**关键实现**  
1. **预处理质数表**（筛法）：针对 `t ≤ 1e6`（因 `x ≤ 1e12`），使用筛法预处理质数，快速判断 `t` 是否为质数。  
2. **平方数判断**：计算 `t = sqrt(x)`，验证 `t² == x`。  

**解决难点**  
- **数学推导**：需想到只有质数的平方满足因子数为3。  
- **高效质数判断**：预处理筛法将单次质数判断复杂度降至 `O(1)`，避免暴力判断的超时风险。  

---

### 题解评分（≥4星）  
1. **Siyuan（5星）**  
   - **亮点**：线性筛预处理质数，时间复杂度最优，代码规范。  
   - **优化**：筛法处理 `1e6` 范围，适合大规模查询。  

2. **Laser_Crystal（4星）**  
   - **亮点**：利用6的优化加速质数判断，代码简洁。  
   - **适用场景**：少量查询时更省内存，适合小数据量。  

3. **Minecraft万岁（4星）**  
   - **亮点**：结合唯一分解定理推导，数学表达清晰，预处理埃氏筛。  

---

### 最优思路与技巧提炼  
1. **数学建模**：将问题转化为质数平方的判断，减少计算量。  
2. **预处理优化**：筛法预处理质数表，空间换时间。  
3. **边界处理**：特判 `x=1` 和浮点数精度问题（如 `t² == x`）。  

---

### 同类型题与算法套路  
- **质数相关计数**：如统计因子数、判断质数、质数分布。  
- **平方数性质**：结合质数或因子数的平方数问题。  

**推荐题目**  
1. P1217 [USACO1.5]回文质数  
2. P3912 素数个数  
3. P2429 制质因子  

---

### 个人心得摘录  
- **“十年OI一场空，不开long long见祖宗”**（封禁用户题解）：强调数据类型的重要性。  
- **暴力优化技巧**：利用6的余数特性减少循环次数（Laser_Crystal）。  

---

### 可视化与算法演示  
**动画设计**  
1. **核心步骤高亮**：  
   - **步骤1**：输入数字 `x`，显示其平方根计算过程。  
   - **步骤2**：若 `t² != x`，标记为红色并输出NO。  
   - **步骤3**：若 `t` 在质数表中，标记为绿色并输出YES。  

2. **复古像素风格**：  
   - **颜色方案**：绿色表示质数，红色为非质数，黄色表示当前操作数。  
   - **音效**：成功（YES）时播放8-bit胜利音效，失败（NO）时播放短促低音。  

**交互功能**  
- **步进控制**：逐步展示平方根计算、质数表查询。  
- **自动演示**：模拟不同输入值的处理流程，速度可调。  

---

### 代码实现（核心逻辑）  
```cpp
// 预处理质数表（线性筛）
const int MAX = 1e6;
bool is_prime[MAX + 10];
vector<int> primes;

void sieve() {
    fill(is_prime, is_prime + MAX + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= MAX; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int p : primes) {
            if (i * p > MAX) break;
            is_prime[i * p] = false;
            if (i % p == 0) break;
        }
    }
}

// 判断T质数
bool is_tprime(long long x) {
    if (x < 4) return x == 1 ? false : (x == 4); // 特殊处理1和4
    long long t = sqrt(x);
    if (t * t != x) return false;
    return is_prime[t];
}
```

**完整代码参考Siyuan题解**，预处理筛法后逐个判断。

---
处理用时：102.19秒
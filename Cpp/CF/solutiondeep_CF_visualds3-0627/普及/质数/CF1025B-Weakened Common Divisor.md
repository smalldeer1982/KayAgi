# 题目信息

# Weakened Common Divisor

## 题目描述

与  $GCD$  （最大公约数）类似，我们引进  $WCD$ （弱公约数）的概念， $ WCD$  的定义如下：

给出几对数 $\left( a_1,b_1 \right) ,\left( a_2,b_2 \right) ,\cdots ,\left( a_n,b_n \right)$ ，它们的  $WCD$  满足大于  $1 $ ，且能整除每个数对中至少一个数。  $WCD$  在一些情况下，可能不存在。

例如，给出这几对数 $\left[ \left( \text{12,}15 \right) ,\left( \text{25,}18 \right) ,\left( \text{10,}24 \right) \right]$  ，它们的   $WCD$  可以是 $ 2,3,5,6$  （这些数都满足严格大于  $1$  ，且能整除每个数对中至少一个数）

现在给你几对数，求他们的   $WCD$  。

## 样例 #1

### 输入

```
3
17 18
15 24
12 15
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
10 16
7 17
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
5
90 108
45 105
75 40
165 175
33 30
```

### 输出

```
5
```

# AI分析结果



## 唯一算法分类
数论（GCD/LCM、质因数分解）

---

## 题解思路与算法要点

### 核心思路对比
各题解围绕两大核心方法展开：
1. **LCM-GCD法**：计算每对的LCM，求所有LCM的GCD，取其质因数（zhaotiensn、Eleveslaine）。
2. **质因数筛法**：分解第一对的质因数，逐步筛除非公共质因数（si_zhong、Hutao__）。

### 关键步骤与难点
- **LCM-GCD法**  
  1. 每对数计算LCM（最小公倍数）  
  2. 对所有LCM求GCD（最大公约数）  
  3. 分解GCD的质因数，任取其一  
  **难点**：正确性需基于数学推导，证明最终GCD的质因数必为所有数对的公共WCD。

- **质因数筛法**  
  1. 分解第一对的a、b质因数存入候选列表  
  2. 后续数对依次筛选候选列表：若某质因数无法整除当前数对的任意数，则剔除  
  3. 最终取第一个未被剔除的质因数  
  **难点**：需证明所有可能的WCD必为第一对数的质因数之一。

### 解决难点核心
- **数学推导**：通过数论证明两种方法的正确性，确保候选集包含所有可能解。
- **优化分解**：通过gcd(ans, a)或gcd(ans, b)缩小分解范围（zhaotiensn），或预处理质数表加速分解（Marser）。

---

## 题解评分（≥4星）

### 1. zhaotiensn（⭐⭐⭐⭐⭐）
- **思路**：LCM-GCD法，数学推导清晰。
- **代码**：简洁高效，利用gcd缩小分解规模。
- **亮点**：O(n)时间复杂度，避免质因数分解的瓶颈。

### 2. si_zhong（⭐⭐⭐⭐）
- **思路**：质因数筛法，正确性基于严格数学证明。
- **代码**：质因数去重处理，线性筛过程直观。
- **缺点**：候选质因数较多时效率略低。

### 3. Dreamunk（⭐⭐⭐⭐）
- **思路**：明确数学框架，详细证明答案必为第一对质因数。
- **代码**：极简实现，直接分解质因数并筛选。

---

## 最优思路提炼
**质因数筛法**的核心步骤：
1. **首对分解**：分解第一对的a、b质因数，作为候选集。
2. **动态筛选**：遍历后续数对，剔除无法整除任一数的质因数。
3. **取第一个存活质因数**：最终候选集中任意剩余质因数均为解。

**关键优化点**：
- 预处理质数表加速分解（如Marser题解）。
- 候选集去重避免重复计算。

---

## 同类型题推荐
1. [P1414 又是毕业季II](https://www.luogu.com.cn/problem/P1414)：求多组数的最大公约数组合。
2. [P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)：利用质因数分解求满足条件的数。
3. [P2651 添加括号III](https://www.luogu.com.cn/problem/P2651)：通过数论性质判断表达式是否为整数。

---

## 代码片段（核心逻辑）
### 质因数筛法（si_zhong）
```cpp
// 分解第一对的质因数
for (int i=2; i<=sqrt(a); i++) {
    while (a%i == 0) {
        f[top++] = i;
        a /= i;
    }
}
if (a > 1) f[top++] = a;
// 类似处理b...

// 筛选候选质因数
for 后续数对 (a, b) {
    for (int j=0; j<top; j++) {
        if (a%f[j] && b%f[j]) f[j] = -1; // 无法整除则剔除
    }
}
```

### LCM-GCD法（zhaotiensn）
```cpp
// 计算所有LCM的GCD
ll ans = a * b / gcd(a, b);
while (n--) {
    cin >> a >> b;
    ans = gcd(ans, a*b/gcd(a,b));
}

// 分解GCD的质因数
ll d = gcd(ans, a);
if (d > 1) cout << calc(d);
else cout << calc(gcd(ans, b));
```

---

## 可视化设计（像素风格演示）
### 动画设计
- **网格视图**：每行表示一个数对，每列表示候选质因数。
- **颜色标记**：
  - 绿色：当前质因数有效。
  - 红色：当前质因数被剔除。
  - 黄色：正在检查的质因数。
- **步进控制**：按数对逐步推进，显示候选集变化。

### 交互功能
- **自动播放**：按预设速度演示筛选过程。
- **点击高亮**：查看某质因数在所有数对中的整除情况。
- **音效**：
  - 剔除时播放“失败”音效。
  - 找到解时播放胜利音效。

---

## 个人心得摘录
- **质因数去重**：分解时需合并重复质因数，否则筛选逻辑会错误（si_zhong）。
- **边界处理**：质数需单独加入候选（如a=17时直接加入）。
- **数学直觉**：答案必为第一对质因数的推论大幅缩小搜索范围（Dreamunk）。

---
处理用时：233.60秒
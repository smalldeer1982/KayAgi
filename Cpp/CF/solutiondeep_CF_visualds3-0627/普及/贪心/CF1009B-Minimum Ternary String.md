# 题目信息

# Minimum Ternary String

## 题目描述

给定一个由 '0', '1', '2' 组成的字符串  $S$ 。可以交换相邻'0', '1'或'1', '2'的位置（例如：'12' - '21'  $\;$  '01' - '10'）请输出原字符串经过任意转换后字典序最小的字符串。原字符串长度不超过  $10^5$ 。

## 样例 #1

### 输入

```
100210
```

### 输出

```
001120
```

## 样例 #2

### 输入

```
11222121
```

### 输出

```
11112222
```

## 样例 #3

### 输入

```
20
```

### 输出

```
20
```

# AI分析结果



### 综合分析与结论

**题目核心**：通过交换相邻的 0-1 或 1-2，构造字典序最小的字符串。  
**关键观察**：  
1. 1 可以移动到任意位置（因为 1 能作为“桥梁”交换 0 和 2）。  
2. 0 和 2 的相对顺序固定，无法直接交换。  
**贪心策略**：将全部 1 插入到第一个 2 之前，若无 2 则放在末尾。  

**难点与解决**：  
- **正确性验证**：需证明所有 1 插入第一个 2 前是最优选择（通过字典序比较验证）。  
- **高效实现**：避免频繁字符串插入操作，直接拼接各部分字符串。  

**可视化设计**：  
- **动画方案**：高亮第一个 2，动态插入所有 1，其他字符保持原序。  
- **复古像素风格**：字符以像素块呈现，插入时触发音效，背景 8-bit 音乐。  
- **交互控制**：支持单步执行、自动播放，展示贪心选择过程。

---

### 题解清单（评分≥4星）

1. **Fearliciz（5星）**  
   - **亮点**：代码简洁高效，遍历原字符串时直接处理，时间复杂度 O(n)。  
   - **关键代码**：  
     ```cpp
     for (int i = 0; i < len; i++) {
         if (c[i] == '1') continue;
         if (c[i] == '2' && flag) {
             cout << string(cnt1, '1') << '2'; // 插入所有 1
             flag = 0;
         } else cout << c[i];
     }
     ```

2. **小闸蟹（5星）**  
   - **亮点**：统计字符数量后分情况处理，逻辑清晰。  
   - **关键思路**：遍历两次，第一次统计 0、1、2 数量，第二次构造结果。

3. **HPXXZYY（4星）**  
   - **亮点**：通过 STL 的 `find` 和 `insert` 高效实现，时间复杂度 O(n)。  
   - **代码片段**：  
     ```cpp
     size_t pos = s.find('2');
     if (pos == string::npos) cout << s + s1;
     else s.insert(pos, s1); // 插入所有 1 到第一个 2 前
     ```

---

### 核心贪心代码实现

**Fearliciz 的代码片段**：  
```cpp
string c; 
int cnt1 = count(c.begin(), c.end(), '1');
bool flag = true; // 标记是否遇到第一个 2
for (char ch : c) {
    if (ch == '1') continue;
    if (ch == '2' && flag) {
        cout << string(cnt1, '1') << '2'; // 插入所有 1
        flag = false;
    } else cout << ch;
}
if (flag) cout << string(cnt1, '1'); // 无 2 的情况
```

**实现思想**：  
1. 统计 1 的总数。  
2. 遍历原字符串，跳过 1。  
3. 遇到第一个 2 时，插入所有 1。  
4. 其余字符保持原序输出。

---

### 同类型题目与套路

**通用贪心策略**：  
- **可移动元素**：若某些元素可自由调整位置，优先确定其最优插入点。  
- **固定顺序元素**：无法交换的元素需保持原序，仅调整可移动部分。  

**推荐题目**：  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）  
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（排序使总等待时间最小）  
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)（字符串拼接的贪心比较）  

---

### 个人心得摘录

- **HPXXZYY**：最初的贪心策略错误（局部交换导致错误全局解），需通过反例验证策略。  
- **帅到报警**：调试中发现未正确处理无 2 的情况，提醒边界条件的重要性。  

---

### 可视化与复古动画设计

**像素风格演示**：  
1. **初始化**：Canvas 绘制原字符串，字符显示为彩色像素块（0-蓝，1-黄，2-红）。  
2. **遍历过程**：高亮当前字符，若为 2 且首次出现，触发 1 的插入动画（黄块飞入）。  
3. **音效设计**：  
   - 插入 1 时播放短促“哔”声。  
   - 背景播放 8-bit 风格循环音乐。  

**交互功能**：  
- **步进控制**：按空格暂停/继续，方向键调整速度。  
- **自动模式**：AI 自动演示贪心过程，模拟“最优决策”。  

**代码片段（伪代码）**：  
```javascript
function drawAnimation() {
    ctx.fillStyle = '#8B00FF'; // 复古紫背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    chars.forEach((ch, i) => {
        drawPixelChar(ch, x + i * 16, y); // 绘制像素字符
    });
    if (currentStep === 'insert_1') {
        // 显示 1 的插入动画
        drawFlyingOnes();
    }
}
```

---
处理用时：154.46秒
# 题目信息

# Подкрутка II

## 题目描述

В этой версии задачи $ n \le 2 \cdot 10^5 $ и $ a_i \le 10^6 $ (а также есть ограничение на сумму $ n $ по наборам входных данных внутри одного теста).

Вика за время работы в компании VK уже сделала $ n $ коммитов в системе контроля версий. $ i $ -й коммит был сделан в $ a_i $ -й день работы Вики в компании. В некоторые дни Вика могла сделать несколько коммитов, а в другие — не сделать ни одного.

Вику интересуют такие отрезки подряд идущих дней, что в каждый из этих дней у неё есть хотя бы один коммит. Чем длиннее будет самый длинный такой отрезок, тем более продуктивным сотрудником она будет себя ощущать.

Недавно Вика нашла способ подкрутить время любого коммита вперёд, но не более чем на сутки. Таким образом, $ i $ -й коммит теперь может быть «сделан» либо в $ a_i $ -й, либо в $ (a_i + 1) $ -й день. Время каждого коммита можно подкрутить независимо от других — в частности, можно как оставить всем коммитам исходное время, так и перенести все коммиты ровно на день вперёд.

Найдите длину самого длинного возможного отрезка подряд идущих дней, в каждый из которых у Вики в профиле будет отображаться хотя бы один коммит, после возможной подкрутки времени некоторых коммитов.

## 样例 #1

### 输入

```
3
9
1 1 3 4 6 6 6 8 10
6
1 2 3 4 5 6
5
10 10 10 10 10```

### 输出

```
5
6
2```

# AI分析结果



---

### **综合分析与结论**

本题的核心是找到调整后能覆盖最长连续区间的最优解。通过分析，动态规划方法更优，时间复杂度为 $O(n)$，代码简洁。贪心分块方法虽直观，但实现复杂。动态规划通过维护每个数值的最长连续长度，利用状态转移快速求解。

**核心贪心策略（动态规划）**：  
- **状态设计**：`dp[i][0/1]` 表示处理到第 `i` 个元素时，不调整/调整后的最长连续长度。  
- **转移方程**：  
  - `dp[i][0] = max_length[a[i]-1] + 1`  
  - `dp[i][1] = max_length[a[i]] + 1`  
- **维护数组**：`max_length[x]` 记录以数值 `x` 结尾的最长长度，实时更新。

**可视化设计思路**：  
- **动画方案**：以时间轴展示每个元素的调整选择（是否+1），高亮当前处理的元素，显示 `max_length` 数组的更新。  
- **复古风格**：用像素块表示数值，颜色区分调整状态，音效提示关键操作（如选择+1时播放上升音效）。

---

### **题解清单（评分≥4星）**

1. **Libra_（5星）**  
   - **亮点**：清晰的状态转移设计，代码简洁，维护 `f` 数组高效更新。  
   - **关键代码**：  
     ```cpp
     dp[i][0] = q[a[i]-1] + 1;  
     dp[i][1] = q[a[i]] + 1;  
     q[a[i]] = max(q[a[i]], dp[i][0]);  
     ```

2. **lidxy（4星）**  
   - **亮点**：直接维护 `q` 数组，逻辑简洁，易理解。  
   - **关键代码**：  
     ```cpp
     ans[i][1] = q[a[i]] + 1;  
     ans[i][0] = q[a[i]-1] + 1;  
     ```

3. **封禁用户（4星）**  
   - **亮点**：与Libra_思路一致，代码实现规范，适合教学。  

---

### **最优思路与代码实现**

**动态规划核心逻辑**：  
- **状态转移**：每个元素两种选择，更新全局最大值。  
- **代码片段**：  
  ```cpp
  for (int i=1; i<=n; i++) {
      dp[i][0] = q[a[i]-1] + 1;
      dp[i][1] = q[a[i]] + 1;
      q[a[i]] = max(q[a[i]], dp[i][0]);
      q[a[i]+1] = max(q[a[i]+1], dp[i][1]);
      ans = max(ans, max(dp[i][0], dp[i][1]));
  }
  ```

---

### **同类型题目推荐**

1. **CF977F Consecutive Subsequence**（最长连续递增子序列）  
2. **洛谷 P1233 木棍加工**（贪心排序+DP）  
3. **LeetCode 300. 最长递增子序列**（经典LIS问题）  

---

### **可视化与复古游戏化设计**

1. **像素风格展示**：  
   - 用不同颜色方块表示原值（黄色）和调整后的值（蓝色）。  
   - 高亮当前处理的元素，显示 `max_length` 数组的更新过程。  

2. **音效与动画**：  
   - **选择操作**：调整时播放“上升”音效，连续增长时播放连击音效。  
   - **背景音乐**：8-bit风格循环曲目，增强沉浸感。  

3. **交互设计**：  
   - **步进控制**：允许单步执行，观察 `q` 数组变化。  
   - **自动演示**：AI模式自动选择最优解，展示贪心决策路径。  

---

**示例代码（JS Canvas 动画核心）**：  
```javascript
function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 10, y * 10, 8, 8);
}
// 绘制数值块，红色表示调整，绿色表示未调整
```

---

**总结**：动态规划方法以高效简洁胜出，适合快速实现；贪心分块方法适合深入理解问题结构。可视化设计通过复古元素增强学习体验，帮助理解状态转移过程。

---
处理用时：94.51秒
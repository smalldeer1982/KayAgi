# 题目信息

# Absolute Zero

## 题目描述

你会得到一个$n$整数的数组$a$。
在一个操作中，您将执行以下两步移动：
1.选择一个整数$x$（$0\le x\le 10^{9}$）。
2.将每个$a_i$替换为$|a_i-x|$，其中$|v|$表示[绝对值](https://en.wikipedia.org/wiki/Absolute_value)$v$。
例如，通过选择$x=8$，数组$[5,7,10]$将变为$[|5-8|，|7-8|，|10-8|]=[3,1,2]$。
构造一个操作序列，使$a$的所有元素在最多$40$的操作中等于$0$，或者确定这是不可能的。您不需要减少操作次数

## 说明/提示

在第一个测试用例中，我们只能通过选择$x=5$执行一个操作，将数组从$[5]$更改为$[0]$。
在第二个测试用例中，不需要任何操作，因为数组的所有元素都已经是$0$了。
在第三个测试用例中，我们可以选择$x=6$将数组从$[4,6,8]$更改为$[2,0,2]$，然后选择$x=1$将其更改为$[1,1,1]$，最后再次选择$x=1.$将数组更改为$[0,0,0]$。
在第四个测试用例中，我们可以按照操作序列$（60,40,20,10,30,25,5）$使所有元素都为$0$。
在第五个测试用例中，可以证明，在最多$40$的操作中，不可能使所有元素都为$0$。因此，输出为$-1$。

## 样例 #1

### 输入

```
5
1
5
2
0 0
3
4 6 8
4
80 40 20 10
5
1 2 3 4 5```

### 输出

```
1
5
0

3
6 1 1
7
60 40 20 10 30 25 5
-1```

# AI分析结果



### 综合分析与结论

**核心贪心策略**：每次选择当前数组最大值与最小值的平均值作为操作数 $x$，使得值域（极差）每次缩小一半。通过 $\log_2(10^9) \approx 30$ 次操作即可完成，保证在 40 次内达成目标。

**解决难点**：
1. **奇偶性判断**：若数组中存在奇偶性不同的元素，则无法通过任何操作达成全零（因绝对值差无法改变奇偶性）。
2. **极差缩半证明**：每次选择 $\lfloor \frac{\max+\min}{2} \rfloor$ 或 $\lceil \frac{\max+\min}{2} \rceil$ 能确保新极差不超过原极差的一半。
3. **终止条件优化**：当极差为 1 且存在 0 和 1 时无法继续缩半，需提前返回无解。

---

### 题解清单（≥4星）

1. **作者：_ZML_（★★★★★）**  
   - **亮点**：简洁的极差缩半思想，时间复杂度 $O(n \log S)$，代码清晰。
   - **代码**：直接维护最大值和最小值，每次计算中点，代码无冗余。
2. **作者：yyz1005（★★★★☆）**  
   - **亮点**：明确奇偶性判断逻辑，数学证明严谨，代码高效。
3. **作者：Lame_Joke（★★★★☆）**  
   - **亮点**：手写快排优化性能，处理边界条件细致。

---

### 最优思路与代码实现

**关键贪心逻辑**：
```cpp
int maxx = *max_element(a, a+n);
int minn = *min_element(a, a+n);
int mid = (maxx + minn) / 2;
for (int &x : a) x = abs(x - mid);
```

**完整代码**（基于 _ZML_ 题解优化）：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<int> a(n);
        for (auto &x : a) cin >> x;
        
        vector<int> ops;
        bool possible = true;
        for (int step = 0; step <= 40; ++step) {
            int mx = *max_element(a.begin(), a.end());
            int mn = *min_element(a.begin(), a.end());
            if (mx == 0) break;
            if ((mx - mn) % 2 && step == 0) { // 初始奇偶性检查
                possible = false;
                break;
            }
            int mid = (mx + mn) / 2;
            ops.push_back(mid);
            for (auto &x : a) x = abs(x - mid);
        }
        if (possible && all_of(a.begin(), a.end(), [](int x){return x == 0;})) {
            cout << ops.size() << '\n';
            for (int x : ops) cout << x << ' ';
            cout << '\n';
        } else {
            cout << "-1\n";
        }
    }
    return 0;
}
```

---

### 同类型题目与算法套路

1. **区间覆盖问题**：每次选择覆盖最广的区间（贪心选择最早结束点）。
2. **哈夫曼编码**：每次合并最小权值的节点。
3. **跳跃游戏**：每次跳到能到达最远的位置。

**洛谷题目推荐**：
1. P1223 排队接水（贪心排序）
2. P1803 线段覆盖（区间贪心）
3. P1090 合并果子（哈夫曼树）

---

### 可视化设计（复古像素风）

**动画方案**：
1. **像素网格**：用 Canvas 绘制数组元素，颜色区分当前值（红色=最大值，蓝色=最小值）。
2. **音效触发**：每次选择 $x$ 时播放“选择音效”，极差缩半时播放“成功音效”。
3. **AI 自动演示**：自动执行贪心步骤，每步暂停 1 秒，高亮当前 $x$ 和操作后的数组。
4. **关卡积分**：每成功缩半极差得 10 分，40 步内完成则解锁“极差大师”成就。

**代码片段（JS Canvas 绘制）**：
```javascript
function drawArray(arr, x) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    arr.forEach((val, idx) => {
        ctx.fillStyle = val === Math.max(...arr) ? 'red' : val === Math.min(...arr) ? 'blue' : 'green';
        ctx.fillRect(idx * 20, 100 - val, 18, val);
    });
    ctx.fillStyle = 'yellow';
    ctx.fillText(`x=${x}`, 10, 120);
}
```

---

### 个人心得摘录

> “第一次尝试取所有数的平均值，但无法保证极差缩半。后来发现必须取最大和最小的中点才能数学证明极差必然减半。” —— Vct14  
> **启示**：贪心策略需结合严格的数学证明，直觉选择不一定最优。

---
处理用时：71.29秒
# 题目信息

# Password Cracking

## 题目描述

迪马什得知曼苏尔向朋友泄露了一些关于他的不愉快言论，于是他决心揭开曼苏尔的密码，看看具体内容是什么。

曼苏尔对自己的密码充满信心，他表示自己的密码是一个长度为 $ n $ 的二进制字符串。同时，他愿意回答迪马什的问题：

迪马什可以给出一个二进制字符串 $ t $ ，曼苏尔则回答 $ t $ 是否是他的密码的一个子串（即一段连续的字符序列）。

请帮助迪马什在不超过 $ 2n $ 次询问内猜出密码；否则，曼苏尔将识破伎俩并停止与他交流。

## 样例 #1

### 输入

```
4
3

0

0

1

4

4

2```

### 输出

```
? 00

? 000

? 010

! 010

! 1100

! 0110

! 10```

# AI分析结果



### 综合分析与结论

**题目核心思路**  
本题需通过不超过 $2n$ 次询问确定长度为 $n$ 的二进制密码。核心贪心策略如下：  
1. **向后扩展**：优先尝试在字符串末尾添加字符（先试 `0`，失败后试 `1`），直到无法继续扩展。  
2. **向前扩展**：当无法向后扩展时，转而在字符串头部添加字符，每次只需一次询问（试 `0` 失败则必为 `1`）。  

**贪心策略的正确性**  
- 向后扩展时，若密码存在后续字符，必能通过一次或两次询问确定下一个字符。  
- 向前扩展时，当前字符串已是密码的后缀，头部添加的字符必存在唯一解（`0` 或 `1`），无需二次验证。  

**可视化设计思路**  
- **动画方案**：分两步展示向后扩展（绿色高亮）和向前扩展（蓝色高亮），每次操作后更新字符串。  
- **复古像素风**：用 8-bit 风格显示字符串，添加字符时播放音效（成功：清脆音；切换方向：提示音）。  
- **交互控制**：支持步进/自动播放，显示剩余询问次数，动态标记当前扩展方向。

---

### 题解清单（评分≥4星）

1. **hema5177（4.5星）**  
   - 关键亮点：先向后扩展再向前，代码逻辑清晰，通过 `deque` 实现动态扩展。  
   - 优化点：减少冗余询问，总次数严格控制在 $2n$ 内。  

2. **Wind_love（4星）**  
   - 关键亮点：简洁的字符串操作，向前扩展时仅需一次询问，显著降低复杂度。  
   - 优化点：利用 `f` 标志切换扩展方向，逻辑紧凑。  

3. **Defy_HeavenS（4.5星）**  
   - 关键亮点：封装查询函数，支持缓存（避免重复询问同一子串），代码复用性高。  
   - 优化点：处理边界条件严谨，适用于大规模测试用例。  

---

### 最优思路与代码实现

**核心贪心逻辑**  
```cpp
// 向后扩展
while (s.size() < n) {
    if (query(s + "0")) s += "0";
    else if (query(s + "1")) s += "1";
    else break;
}
// 向前扩展
while (s.size() < n) {
    if (query("0" + s)) s = "0" + s;
    else s = "1" + s;
}
```

**完整代码（Defy_HeavenS 精简版）**  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool query(string s) {
    cout << "? " << s << endl;
    int res; cin >> res;
    return res;
}

void solve() {
    int n; cin >> n;
    string s = query("0") ? "0" : "1";
    while (s.size() < n) {
        if (query(s + "0")) s += "0";
        else if (query(s + "1")) s += "1";
        else break;
    }
    while (s.size() < n) {
        s = query("0" + s) ? "0" + s : "1" + s;
    }
    cout << "! " << s << endl;
}

int main() {
    int t; cin >> t;
    while (t--) solve();
}
```

---

### 类似题目与扩展

**同类型题目**  
1. **构造性贪心**：如构造字典序最小的字符串，每一步选择最小字符（[CF 题目 1144G](https://codeforces.com/problemset/problem/1144/G)）。  
2. **交互式猜数**：通过二分法或位运算猜测目标值（洛谷 P1738）。  

**推荐题目**  
1. 洛谷 P1738 - 猜数字（交互题，二分策略）  
2. 洛谷 P1850 - 猜数游戏（动态规划与交互结合）  
3. 洛谷 P7352 - 子串查询（贪心与字符串操作）  

---

### 个人心得摘录

- **调试教训**：初始尝试前后交替扩展导致询问次数爆炸，需固定扩展方向。  
- **顿悟时刻**：当无法向后扩展时，剩余字符必在头部，只需单向验证。  

---

### 可视化与复古游戏化设计

**动画设计**  
1. **Canvas 显示**：  
   - 初始空字符串，每次扩展时字符从右侧（向后）或左侧（向前）飞入。  
   - 背景网格为 8-bit 像素风格，成功操作后闪烁绿色/蓝色。  

2. **音效交互**：  
   - 向后扩展成功：播放 `beep` 音效；失败：低沉音。  
   - 向前扩展：不同音调区分 `0` 和 `1`。  

3. **游戏化积分**：  
   - 每次正确扩展得 10 分，剩余次数转化为连击奖励。  
   - 总得分与历史最优比较，增强挑战性。  

**代码片段（JS 伪代码）**  
```javascript
function animateStep(char, direction) {
    const elem = document.createElement('div');
    elem.className = `pixel-char ${direction}`;
    elem.textContent = char;
    document.getElementById('grid').appendChild(elem);
    // 触发音效
    playSound(direction === 'back' ? 'high' : 'low');
}
```

---

**结论**  
本题的贪心策略通过分离扩展方向，巧妙控制询问次数，结合交互特性实现高效破解。其核心在于优先确定可验证的后缀，再补全前缀，确保每一步的确定性。

---
处理用时：139.28秒
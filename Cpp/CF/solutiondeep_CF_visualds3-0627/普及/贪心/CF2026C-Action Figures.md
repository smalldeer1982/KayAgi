# 题目信息

# Action Figures

## 题目描述

在 Monocarp 家附近有一家商店，专门售卖手办。近期，这家店将推出一套新的手办系列，总共包含 $n$ 个手办。其中，第 $i$ 个手办的价格为 $i$ 枚金币。在第 $i$ 天到第 $n$ 天之间，这个手办都是可以购买的。

Monocarp 知道他在这 $n$ 天中的哪几天可以去商店。

每次去商店的时候，他可以购买多件手办（当然，不能买尚未发售的手办）。如果他在同一天购买了至少两个手办，他可以享受一个折扣：他所购买的最贵手办是免费的，也就是说他无需为该手办支付费用。

Monocarp 的目标是从这个手办系列中，分别购买一个第 $1$ 个手办、一个第 $2$ 个手办……一直到一个第 $n$ 个手办。注意，每个手办只能购买一次。请你帮他计算，他最少需要花费多少金币？

## 说明/提示

在第一个测试用例中，Monocarp 可以在第一天购买第一个手办，花费 1 枚金币。

在第二个测试用例中，他可以在第三天购买第 1 和第 3 个手办，在第四天购买第 2 和第 4 个手办，在第六天购买第 5 和第 6 个手办。这样总费用为 $1+2+5=8$ 枚金币。

在第三个测试用例中，他可以在第三天购买第 2 和第 3 个手办，其余手办在第七天购买，最终花费 $1+2+4+5+6 = 18$ 枚金币。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
1
1
6
101101
7
1110001
5
11111```

### 输出

```
1
8
18
6```

# AI分析结果



### 综合分析与结论

#### 核心思路
所有题解均采用**贪心策略**，核心思想是：**优先让最大的手办免费**。具体通过以下步骤实现：
1. 从大到小遍历可购买的天数（即 `s[i]=1` 的位置）
2. 对于每个 `i`，寻找可配对的 `j`（`j < i`）：
   - 优先选 `s[j]=0` 的最近位置（最大化节省）
   - 若无可用 `0`，则选最小的未被使用的 `1`（避免浪费大数）

#### 算法难点
1. **贪心正确性证明**：需确保每次配对都能带来最大可能的节省，且不影响后续更优决策。
2. **数据结构选择**：需要高效查找可配对的 `j`，不同解法分别采用双端队列、栈、集合等数据结构优化查询速度。
3. **边界处理**：例如当所有 `s[j]=1` 时需处理自身配对，以及 `s[i]=0` 必须单独购买的情况。

---

### 题解评分（≥4星）

#### Drifty（4.5星）
- **亮点**：利用 `set` 维护可用位置，逻辑清晰，代码简洁。
- **关键代码**：
  ```cpp
  auto it = S.upper_bound(*T.rbegin());
  if (*(--it) == 0) { // 找最近的 0 或最小的 1
    ans += *T.begin();
    T.erase(*T.begin());
  } else S.erase(*it);
  ```

#### zhouruoheng（4星）
- **亮点**：双端队列 + 栈实现 O(n) 时间复杂度，高效实用。
- **关键代码**：
  ```cpp
  while (tot && st[tot] > x) tot--; // 找最近的 0
  if (tot) tot--, ans -= x; // 0 存在则配对
  else if (dq.size()) dq.pop_front(), ans -= x; // 否则用最小的 1
  ```

#### MiaoYu（4星）
- **亮点**：直观的双端队列处理，代码简洁易懂。
- **关键代码**：
  ```cpp
  for (int i = len - 1; i >= 0; i--) {
    if (x == 1) q.push_back(i+1);
    else { if (!q.empty()) q.pop_front(); ans += i+1; }
  }
  ```

---

### 最优思路提炼

#### 关键贪心策略
1. **从后向前处理**：优先处理大的 `i`，确保其尽可能免费。
2. **配对优先级**：`0 > 1`（优先用 `0` 的 `j` 来免费 `i`）。
3. **数据结构优化**：用栈或双端队列维护可用的 `j`，快速查找最近/最小的配对。

#### 数学证明
- **引理**：对于 `s[i]=1` 的 `i`，若存在未使用的 `s[j]=0`（`j < i`），则 `i` 必须与最大的 `j` 配对，否则与最小的未使用 `s[k]=1` 配对。
- **正确性**：每次选择使得当前节省最大且不影响后续更大数的免费机会。

---

### 同类型题与算法套路

#### 常见贪心场景
1. **区间覆盖**：选择最小区间覆盖目标范围。
2. **任务调度**：最大化收益或最小化惩罚。
3. **配对问题**：将大数与小数配对以优化总和。

#### 推荐题目
1. **P1209**：修理牛棚（区间覆盖）
2. **P1094**：纪念品分组（双指针配对）
3. **P5019**：铺设道路（贪心分段处理）

---

### 可视化设计

#### 动画方案
1. **动态高亮**：用红色标记当前处理的 `i`，绿色标记找到的 `j`。
2. **费用计算**：实时显示总费用和节省金额。
3. **配对过程**：以箭头连接 `i` 和 `j`，显示免费关系。

#### 复古像素风格
- **Canvas 绘制**：每个手办表示为像素方块，颜色区分 `0/1`。
- **音效设计**：
  - **成功配对**：8-bit 上升音效。
  - **无法配对**：短促警告音。
- **自动演示**：AI 逐步执行贪心选择，速度可调。

#### 交互示例
```javascript
// 伪代码：贪心动画核心逻辑
function animateGreedy() {
  let i = n;
  while (i >= 1) {
    if (s[i] === '1') {
      highlight(i); // 高亮当前处理的 i
      let j = findPair(i); // 查找 j
      if (j) {
        drawArrow(i, j); // 绘制配对箭头
        playSound('success'); // 播放音效
      }
    }
    i--;
  }
}
```

---

### 代码片段（Drifty 题解核心）

```cpp
set<int> S({0}), T; // S存0的位置，T存1的位置
i64 ans = 0;
for (int i = 1; i <= n; i++) {
    if (s[i-1] == '0') S.insert(i), ans += i;
    else T.insert(i);
}
while (T.size()) {
    auto it = S.upper_bound(*T.rbegin()); // 找最大的j ≤ i
    if (*(--it) == 0) { // 无可用的0，配对最小的1
        ans += *T.begin();
        T.erase(T.begin());
        if (T.size()) T.erase(*T.rbegin());
    } else { // 使用最近的0
        S.erase(it);
        T.erase(*T.rbegin());
    }
}
```

---
处理用时：97.52秒
# 题目信息

# Sharky Surfing

## 题目描述

Mualani 喜欢在她的大鲨鱼冲浪板上冲浪！

Mualani 的冲浪路径可以用一个数轴来表示。她从位置 $1$ 开始，路径的终点是位置 $L$。当她处于位置 $x$ 且跳跃能力为 $k$ 时，她可以跳到区间 $[x, x+k]$ 内的任意整数位置。最初，她的跳跃能力为 $1$。

然而，她的冲浪路径并不完全平坦。她的路径上有 $n$ 个障碍物。每个障碍物由一个区间 $[l, r]$ 表示，意味着她不能跳到区间 $[l, r]$ 内的任何位置。

在路径上还有 $m$ 个能量提升点。第 $i$ 个能量提升点位于位置 $x_i$，其值为 $v_i$。当 Mualani 处于位置 $x_i$ 时，她可以选择收集该能量提升点，将她的跳跃能力增加 $v_i$。在同一个位置可能有多个能量提升点。当她处于有多个能量提升点的位置时，她可以选择收集或忽略每个单独的能量提升点。没有能量提升点位于任何障碍物的区间内。

Mualani 必须收集最少的能量提升点数才能到达位置 $L$ 完成冲浪路径。如果无法完成冲浪路径，则输出 $-1$。

## 样例 #1

### 输入

```
4
2 5 50
7 14
30 40
2 2
3 1
3 5
18 2
22 32
4 3 50
4 6
15 18
20 26
34 38
1 2
8 2
10 2
1 4 17
10 14
1 6
1 2
1 2
16 9
1 2 10
5 9
2 3
2 2```

### 输出

```
4
-1
1
2```

# AI分析结果



### 题解思路、算法要点与解决难点

#### 核心贪心思路
- **贪心策略**：每次遇到障碍时，优先选择能带来最大跳跃能力提升的能量点，以减少收集次数。
- **正确性验证**：较大的 $v_i$ 能更快满足跳跃能力要求，保证局部最优解叠加得到全局最优。
- **数据结构**：使用优先队列（大根堆）动态维护当前可用的能量点。

#### 解决难点
1. **障碍处理顺序**：需按障碍左端点升序处理，确保能量点收集顺序正确。
2. **离散化优化**：当 $L$ 极大时，离散化障碍左端点和能量点位置，避免遍历整个数轴。
3. **跨障碍条件**：跳跃能力 $k$ 需满足 $k > \text{障碍长度}$，即 $k \geq r_i - l_i + 1 + 1$。

---

### 题解评分（≥4星）

| 作者          | 评分 | 关键亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| WRT_Partisan  | ⭐⭐⭐⭐ | 代码简洁，直接维护优先队列，处理逻辑清晰                                 |
| O_v_O         | ⭐⭐⭐⭐ | 贪心逻辑明确，代码结构紧凑                                              |
| Bc2_ChickenDreamer | ⭐⭐⭐⭐ | 实现简洁，包含清空队列的调试经验提醒                                    |

---

### 最优思路/技巧提炼

1. **排序策略**：
   - 障碍按左端点升序排序。
   - 能量点按位置升序排序。
2. **贪心选择**：
   - 每次处理障碍前，将所有左端点前的能量点加入优先队列。
   - 从队列中依次取最大 $v_i$ 直到满足跳跃能力。
3. **终止条件**：
   - 若队列为空且能力不足，立即返回 $-1$。

---

### 同类型题与算法套路

1. **区间覆盖问题**：选择最少的区间覆盖目标范围。
2. **跳跃游戏**：最少步数到达终点（如 LeetCode 45）。
3. **合并果子**：每次合并代价最小的两堆（如 洛谷 P1090）。

---

### 推荐洛谷题目

1. **P1090 [NOIP2004 提高组] 合并果子**  
   （贪心选择最小代价，优先队列实现）
2. **P1803 线段覆盖**  
   （选择不重叠线段的最大数量，右端点排序）
3. **P5019 [NOIP2018 提高组] 铺设道路**  
   （区间填充问题，贪心决策）

---

### 个人心得摘录

- **Bc2_ChickenDreamer**：因未清空优先队列导致 WA，强调多测清空的重要性。
- **ccjjxx**：初始误解题意（求最小总 $v$ 而非次数），提醒仔细审题。

---

### 可视化与算法演示

#### 动画方案设计
1. **数轴展示**：
   - 障碍用红色区间标记，能量点用绿色方块表示。
   - 当前处理障碍高亮为橙色，已处理障碍变灰。
2. **贪心过程**：
   - 步进显示将能量点加入队列。
   - 每次取最大 $v_i$ 时，能量点闪烁并更新跳跃能力值。
3. **控制面板**：
   - 暂停/继续按钮，速度调节滑块。
   - 显示当前障碍编号、已用能量点数、跳跃能力。

#### 复古像素风格实现
```html
<!-- 示例代码片段：Canvas 绘制障碍和能量点 -->
<canvas id="gameCanvas" width="800" height="200"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// 绘制障碍（红色块）
function drawObstacle(l, r) {
  ctx.fillStyle = '#FF5555';
  ctx.fillRect(l * 10, 50, (r - l) * 10, 30);
}
// 绘制能量点（绿色块）
function drawPowerUp(x) {
  ctx.fillStyle = '#55FF55';
  ctx.fillRect(x * 10, 80, 10, 10);
}
</script>
```

#### 音效设计
- **收集能量点**：8-bit 上升音效（`audio/pickup.wav`）。
- **跨过障碍**：胜利音效（`audio/success.wav`）。
- **失败提示**：低沉错误音（`audio/error.wav`）。

---

### 关键代码实现（WRT_Partisan 题解）

```cpp
priority_queue<int> q;
int ans = 0, num = 1;
// 处理每个障碍
for (int i = 1; i <= n; i++) {
    // 收集左端点前的能量点
    while (it <= m && a[it].l < b[i].l) {
        q.push(a[it].r);
        ++it;
    }
    // 贪心选择最大v_i
    while (num <= b[i].r - b[i].l + 1) {
        if (q.empty()) {
            printf("-1\n");
            return;
        }
        num += q.top();
        q.pop();
        ans++;
    }
}
printf("%lld\n", ans);
```

---
处理用时：83.60秒
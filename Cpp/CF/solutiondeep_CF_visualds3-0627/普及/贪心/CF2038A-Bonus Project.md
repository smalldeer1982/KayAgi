# 题目信息

# Bonus Project

## 题目描述

有 $n$ 名编号为 $1$ 到 $n$ 的软件工程师。他们的老板承诺，如果他们完成一个额外项目，将给他们发放奖金。完成这个项目总共需要 $k$ 个单位的工作。给第 $i$ 名工程师的奖金是 $a_i$ 。第 $i$ 名工程师估计他们的一个单位的工作价值为 $b_i$ 。如果奖金发放了，那么第 $i$ 名工程师完成 $c$ 个单位的工作的收益 $s_i$ 定义为 $s_i = a_i - c \cdot b_i$。如果奖金不发放，工程师将不会自愿做任何工作。工程师们已经一起工作了很多年，所以他们知道奖金将如何分配，以及他们的同事对劳动的估值是多少。也就是说，团队中的每个工程师都知道所有的 $a_i$ 和 $b_i$。工程师们渴望得到奖金，所以他们同意按照以下过程在他们之间分配工作：
- 第一名工程师说：“我将完成 $c_1$ 个单位的工作”，其中 $c_1$ 是一个非负整数；
- 然后，第二名工程师说：“我将完成 $c_2$ 个单位的工作”，其中 $c_2$ 是一个非负整数；
-... 以此类推；
- 最后，第 $n$ 名工程师说：“我将完成 $c_n$ 个单位的工作”，其中 $c_n$ 是一个非负整数。


每个工程师都会说出一个 $c_i$ 来最大化他们自己的收益 $s_i$。如果预期的收益为零，工程师仍然会同意工作以获得经验并帮助他们的同事获得奖金。然而，如果出于某种原因预期的收益为负（工程师需要进行过量的工作，或者项目无法完成），那么该工程师将不会进行任何工作（完成0个单位的工作）。假设每个工程师的行为都是完美的，你的任务是找出每个工程师所说的数字 $c_i$。

## 说明/提示

在这两个例子中，工程师们分配了工作并获得了奖金，即使第三个工程师的收益为零。在第二个例子中，奖金项目需要太多工作量才能完成，所以工程师们根本不工作反而更有益。

## 样例 #1

### 输入

```
3 6
4 7 6
1 2 3```

### 输出

```
1 3 2```

## 样例 #2

### 输入

```
3 12
4 7 6
1 2 3```

### 输出

```
0 0 0```

## 样例 #3

### 输入

```
3 11
6 7 8
1 2 3```

### 输出

```
6 3 2```

# AI分析结果



### 综合分析与结论

**题目核心**：  
工程师们需分配k个单位工作量，使总收益非负且总和恰好为k。每位工程师按顺序宣布自己的工作量，以最大化自身收益。关键在于确定各工程师的贪心选择顺序及策略。

**贪心策略**：  
将工程师按b_i（单位工作成本）从小到大排序。对于每位工程师i，确定其工作量c_i的下限：  
`c_i ≥ max(0, k - 前i-1人的总和 - 后i+1人的最大可能总和)`。  
若该下限超过其最大可能值（a_i // b_i），则无法分配，输出全0。

**算法要点**：  
1. **排序依据**：低b_i优先，确保前面工程师尽可能多承担工作。  
2. **动态下限计算**：保证后续工程师能补足剩余工作量。  
3. **可行性剪枝**：若总最大工作量不足k，直接返回全0。

**可视化设计**：  
- **排序展示**：用颜色区分不同b_i的工程师，突出排序步骤。  
- **步进动画**：展示每位工程师计算下限、调整c_i的过程，高亮当前处理对象。  
- **音效反馈**：正确分配时播放成功音效，失败时播放错误提示。

### 最优思路提炼

1. **排序策略**：按b_i升序排列，低成本的工程师优先分配工作量。  
2. **下限计算**：确保后续工程师有足够余量补足k。  
3. **顺序处理**：每位工程师取最小必要工作量，最大化自身收益。

### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Engineer {
    int a, b, idx;
    int max_c;
};

int main() {
    int n, k;
    cin >> n >> k;
    vector<Engineer> engs(n);
    for (int i = 0; i < n; ++i) cin >> engs[i].a;
    for (int i = 0; i < n; ++i) {
        cin >> engs[i].b;
        engs[i].max_c = engs[i].a / engs[i].b;
        engs[i].idx = i;
    }
    
    sort(engs.begin(), engs.end(), [](const Engineer& x, const Engineer& y) {
        return x.b < y.b;
    });
    
    vector<int> c(n);
    int total_max = 0;
    for (auto& e : engs) total_max += e.max_c;
    if (total_max < k) {
        cout << string(n*2-1, '0') << endl;
        return 0;
    }
    
    int sum_so_far = 0;
    bool possible = true;
    for (int i = 0; i < n; ++i) {
        int sum_remaining = 0;
        for (int j = i+1; j < n; ++j) sum_remaining += engs[j].max_c;
        int lower = max(0, k - sum_so_far - sum_remaining);
        if (lower > engs[i].max_c) {
            possible = false;
            break;
        }
        c[i] = lower;
        sum_so_far += lower;
    }
    
    if (!possible || sum_so_far != k) {
        cout << string(n*2-1, '0') << endl;
        return 0;
    }
    
    vector<int> res(n);
    for (int i = 0; i < n; ++i) res[engs[i].idx] = c[i];
    for (int i = 0; i < n; ++i) {
        if (i > 0) cout << ' ';
        cout << res[i];
    }
    cout << endl;
    return 0;
}
```

### 同类型题目

1. **任务调度贪心**：如LeetCode 630 Course Schedule III，按截止时间排序。  
2. **资源分配问题**：如分糖果问题，需满足约束的最优分配。  
3. **区间覆盖**：选择最少区间覆盖目标长度，按起点或终点贪心。

### 可视化示例

**复古像素动画**：  
1. **工程师排序**：像素小人按b_i从小到大排列，显示b_i值。  
2. **动态分配**：处理每位工程师时，显示当前sum_so_far和sum_remaining_max，红框标出当前处理对象。  
3. **音效提示**：正确分配时播放8-bit“金币音效”，失败时播放低沉音效。  
4. **进度条**：实时显示总工作量与k的差距，增强互动感。

---
处理用时：374.61秒
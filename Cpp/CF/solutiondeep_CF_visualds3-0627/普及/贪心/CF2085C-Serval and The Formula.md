# 题目信息

# Serval and The Formula

## 题目描述

给定两个正整数 $x$ 和 $y$（$1 \le x, y \le 10^9$）。

请找到一个非负整数 $k \le 10^{18}$，使得等式 $(x + k) + (y + k) = (x + k) \oplus (y + k)$ 成立$^{\text{∗}}$，或判断这样的整数不存在。

$^{\text{∗}}$符号 $\oplus$ 表示[按位异或运算](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。


## 说明/提示

第一个测试案例中，由于 $(2 + 0) + (5 + 0) = (2 + 0) \oplus (5 + 0) = 7$，因此 $k = 0$ 是合法答案。注意 $k = 4$ 也是一个合法答案，因为 $(2 + 4) + (5 + 4) = (2 + 4) \oplus (5 + 4) = 15$。

第二个测试案例中，$(x + k) \oplus (y + k) = (6 + k) \oplus (6 + k) = 0$。然而对于所有 $k \ge 0$，$(x + k) + (y + k) > 0$ 恒成立，因此这样的整数 $k$ 不存在。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
2 5
6 6
19 10
1024 4096
1198372 599188```

### 输出

```
0
-1
1
1024
28```

# AI分析结果



---

### 唯一算法分类
位运算

---

### 题解思路与算法分析
题目要求找到非负整数k，使得(x + k) + (y + k) = (x + k) ^ (y + k)。通过数学推导可知，这等价于找到k使得(x + k)和(y + k)的二进制表示没有同时为1的位。

#### 核心思路
**最优解法**：将较大数提升到最近的2的幂次。设max_val为x和y的较大值，找到最小的2^n ≥ max_val，此时k = 2^n - max_val。此时x + k和y + k的二进制必然不会在同一位有1，满足条件。

#### 解决难点
- **位运算性质**：利用a + b = a^b + 2*(a&b)，当且仅当a&b=0时等式成立。
- **快速找幂次**：通过位运算快速找到大于等于max_val的最小2次幂。

---

### 题解评分（≥4星）
1. **copper_ingot（★★★★★）**  
   - 思路：利用2的幂次性质，直接计算k = 2^n - max(x,y)。  
   - 亮点：时间复杂度O(log max_val)，代码简洁高效，直接解决核心问题。  
   - 代码片段：  
     ```cpp
     x = max(x, y);
     while (n < x) n *= 2;
     k = n - x;
     ```

---

### 最优思路提炼
**关键技巧**：将较大数提升到最近的2的幂次，确保两数二进制无重叠的1。  
**实现步骤**：  
1. 比较x和y，取较大值max_val。  
2. 找到最小的2^n ≥ max_val。  
3. 计算k = 2^n - max_val。  
4. x=y时无解，直接返回-1。

---

### 相似题目推荐
1. [P2114 位运算练习](https://www.luogu.com.cn/problem/P2114)  
2. [P5657 格雷码](https://www.luogu.com.cn/problem/P5657)  
3. [P6102 谔运算](https://www.luogu.com.cn/problem/P6102)

---

### 可视化算法设计
**动画演示**：  
1. **二进制位展示**：用动态网格表示x和y的二进制位，高亮当前处理的位。  
2. **提升到2的幂次**：动画中逐渐左移1的位，直到超过max_val，标记为红色框。  
3. **计算k值**：用绿色箭头表示k=2^n - max_val，并展示x+k和y+k的二进制无重叠。  

**交互设计**：  
- **步进控制**：允许单步执行左移操作，观察幂次变化。  
- **颜色标记**：红色表示当前处理的幂次，绿色表示最终结果。  

---

### 参考代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    int T, x, y;
    scanf("%lld", &T);
    while (T--) {
        scanf("%lld%lld", &x, &y);
        if (x == y) {
            puts("-1");
            continue;
        }
        int max_val = max(x, y), n = 1;
        while (n < max_val) n <<= 1;
        printf("%lld\n", n - max_val);
    }
    return 0;
}
```

---
处理用时：165.76秒
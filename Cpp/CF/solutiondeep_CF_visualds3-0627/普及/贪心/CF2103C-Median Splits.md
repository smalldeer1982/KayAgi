# 题目信息

# Median Splits

## 题目描述

数组 $b_1, b_2, \ldots b_m$ 的中位数记作 $\operatorname{med}(b_1, b_2, \ldots, b_m)$，定义为数组 $b$ 中第 $\left\lceil \frac{m}{2} \right\rceil$ 小的元素。

给定一个整数数组 $a_1, a_2, \ldots, a_n$ 和一个整数 $k$。你需要判断是否存在一对下标 $1 \le l < r < n$ 满足：

$$
\operatorname{med}(\operatorname{med}(a_1, a_2 \dots a_l), \operatorname{med}(a_{l + 1}, a_{l + 2} \dots a_r), \operatorname{med}(a_{r + 1}, a_{r + 2} \dots a_n)) \leq k.
$$

换句话说，判断是否可以将数组分割为三个连续的子数组，使得这三个子数组中位数的中位数小于或等于 $k$。

## 说明/提示

在第一个和第二个测试用例中，唯一可能的分割方式是将数组分为 $[3]$、$[2]$、$[1]$。它们的中位数分别是 $3$、$2$ 和 $1$。这三个中位数的中位数是 $\operatorname{med}(3, 2, 1) = 2$。因此，第一个测试用例的答案是 "YES"（因为 $2 \le 2$），而第二个测试用例的答案是 "NO"（因为 $2 > 1$）。

在第三个测试用例中，可以证明不存在满足条件的分割。

在第四个测试用例中，一个满足条件的分割是 $[10, 7]$、$[12, 16, 3, 15]$、$[6, 11]$。子数组的中位数分别是 $7$、$12$ 和 $6$。这三个中位数的中位数是 $\operatorname{med}(7, 12, 6) = 7 \le k$，因此该分割满足条件。

在第五个测试用例中，一个满足条件的分割是 $[7, 11]$、$[12, 4]$、$[9, 17]$。子数组的中位数分别是 $7$、$4$ 和 $9$。这三个中位数的中位数是 $\operatorname{med}(7, 4, 9) = 7 \le k$，因此该分割满足条件。

在第六个测试用例中，唯一可能的分割方式是将数组分为 $[1000]$、$[10^9]$、$[1000]$。子数组的中位数分别是 $1000$、$10^9$ 和 $1000$。这三个中位数的中位数是 $\operatorname{med}(1000, 10^9, 1000) = 1000 \le k$，因此该分割满足条件。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
6
3 2
3 2 1
3 1
3 2 1
6 3
8 5 3 1 6 4
8 7
10 7 12 16 3 15 6 11
6 8
7 11 12 4 9 17
3 500000000
1000 1000000000 1000```

### 输出

```
YES
NO
NO
YES
YES
YES```

# AI分析结果



**唯一算法分类**  
贪心、前缀和预处理

---

### **题解思路、算法要点与解决难点**  
**核心思路**：将原问题转化为寻找三个分割点，使得其中至少两个子数组的中位数≤k。通过预处理每个可能的前缀和后缀，快速判断是否存在满足条件的分割点。  
**关键步骤**：  
1. **预处理前缀/后缀计数**：统计每个位置前/后元素≤k的数量。  
2. **分割点判定**：  
   - 左分割点条件：前i个元素中≤k的数量≥ceil(i/2)。  
   - 右分割点条件：后i个元素中≤k的数量≥ceil(i/2)。  
3. **三种情况检查**：  
   - 存在两个左分割点。  
   - 存在两个右分割点。  
   - 存在一个左分割点和一个右分割点且左在右左侧。  

**解决难点**：通过数学推导将中位数判定简化为计数问题，避免了复杂的排序操作，实现O(n)时间复杂度。

---

### **题解评分**  
1. **potata111（5星）**  
   - 思路清晰，预处理逻辑简洁，条件判断覆盖所有情况。  
   - 代码结构清晰，变量命名直观。  
2. **Cells（4星）**  
   - 逻辑直接，代码简洁，但部分条件判断需结合注释理解。  
3. **znzryb（4星）**  
   - 利用动态维护pres/sufs数组优化中间段判断，但代码复杂度略高。  

---

### **最优思路或技巧提炼**  
- **数学转换**：将中位数问题转换为元素数量统计，避免排序。  
- **贪心预处理**：通过前缀/后缀数组快速判断分割点，降低时间复杂度。  
- **条件覆盖**：三种分割情况（双左、双右、左右）的全面检查确保正确性。  

---

### **同类型题或类似算法套路**  
- **前缀和优化计数**：类似问题如「子数组和的中位数」「区间统计特定元素数量」。  
- **分段条件判断**：如CF的数组分段问题，要求满足多个子条件的组合。  

---

### **推荐相似题目**  
1. P1712 [NOI2016] 区间  
2. P1638 逛画展  
3. CF1005C Summarize to the Power of Two  

---

### **个人心得摘录**  
- **调试教训**：需注意分割点的下标关系（如左分割点必须严格小于右分割点）。  
- **顿悟点**：中位数判定仅需元素数量而非具体值，极大简化问题。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **颜色标记**：  
   - 绿色：当前遍历的左分割点。  
   - 红色：当前遍历的右分割点。  
   - 黄色：满足条件的前缀/后缀区域。  
2. **步进控制**：逐步显示前缀/后缀数组的填充过程，高亮分割点判定逻辑。  
3. **游戏化效果**：  
   - 像素风格：用8-bit色块表示数组元素，分割点判定成功时播放「金币音效」。  
   - 自动演示：模拟左右指针移动，若满足条件则触发高亮和音效。  

---

### **核心代码实现**  
```cpp
// 预处理前缀和后缀
Left[0] = 0;
for (int i = 1; i <= n; i++)
    Left[i] = Left[i-1] + (arr[i] <= k);

Right[n+1] = 0;
for (int i = n; i >= 1; i--)
    Right[i] = Right[i+1] + (arr[i] <= k);

// 检查条件
bool ans = false;
int left = -1, right = -1;

for (int i = 1; i <= n; i++) {
    if (2 * Left[i] >= i) { // 左分割点
        if (left != -1) ans = true; // 存在两个左分割点
        else left = i;
    }
}

for (int i = n; i >= 1; i--) {
    if (2 * Right[i] >= (n - i + 1)) { // 右分割点
        if (right != -1) ans = true; // 存在两个右分割点
        else right = i;
    }
}

if (left != -1 && right != -1 && left < right)
    ans = true;
```

**完整代码见原题解**。

---
处理用时：102.00秒
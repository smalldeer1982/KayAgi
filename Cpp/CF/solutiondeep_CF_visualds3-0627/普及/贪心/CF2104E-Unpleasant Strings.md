# 题目信息

# Unpleasant Strings

## 题目描述

我们称一个字母是允许的，当且仅当它是小写字母且属于拉丁字母表的前 $k$ 个字母。

给定一个长度为 $n$ 的字符串 $s$，它仅由允许的字母组成。

我们称一个字符串 $t$ 是愉快的，当且仅当 $t$ 是 $s$ 的子序列。

给定 $q$ 个字符串 $t_1, t_2, \dots, t_q$，它们都仅由允许的字母组成。对于每个字符串 $t_i$，计算最少需要在它的右侧追加多少个允许的字母，才能使其不再愉快。

序列 $t$ 是序列 $s$ 的子序列，当且仅当 $t$ 可以通过从 $s$ 中删除若干个（可以是零个或全部）任意位置的元素得到。

## 说明/提示

在第一个样例中：

1. 字符串 cc 已经是不愉快的，因此不需要追加任何字母；
2. bcb 是愉快的，因此至少需要在右侧追加一个字母：bcba 仍然会保持愉快，但 bcbb 和 bcbc 是不愉快的；
3. 对于 b，至少需要追加两个字母，因为 ba、bb 和 bc 都是愉快的。例如，我们可以得到一个不愉快的字符串 bbb。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
7 3
abacaba
3
cc
bcb
b```

### 输出

```
0
1
2```

## 样例 #2

### 输入

```
5 1
aaaaa
6
a
aa
aaa
aaaa
aaaaa
aaaaaa```

### 输出

```
5
4
3
2
1
0```

# AI分析结果



**唯一算法分类**：动态规划（DP）与自动机

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目要求对于每个查询字符串 `t_i`，计算最少追加字符使其不再是 `s` 的子序列。核心思路是预处理每个位置 `i` 在 `s` 中的后续信息，动态规划计算每个位置的最小追加数，并利用自动机结构快速匹配查询。

#### **算法要点**
1. **预处理每个位置的转移路径**  
   - 从后往前遍历 `s`，维护 `son[i][j]` 表示位置 `i` 后字符 `j` 的最后出现位置。
   - 动态规划计算 `ans[i]`：表示从位置 `i` 开始，最少需追加的字符数。状态转移为 `ans[i] = min{ans[son[i][j]] + 1}`，覆盖所有可能的后续字符。

2. **查询匹配**  
   - 遍历 `t_i`，沿 `son` 转移路径模拟子序列匹配。
   - 若中途无法匹配（到达 `n+1`），返回 `0`；否则返回 `ans[rt]`（`rt` 为匹配结束位置）。

#### **解决难点**
- **高效预处理**：通过反向遍历 `s` 和 `O(k)` 时间维护 `son` 和 `ans`，确保总复杂度为 `O(nk + ∑|t_i|)`。
- **自动机匹配**：将 `s` 转换为状态转移机，快速处理查询。

---

### **题解评分 (≥4星)**

1. **Eous 的题解（5星）**  
   - **亮点**：  
     - 预处理 `son` 和 `ans` 实现高效查询。  
     - 代码简洁，时间复杂度严格线性。  
   - **代码片段**：  
     ```cpp
     for (int i = n; i >= 1; i--) {
         memcpy(son[i], son[0], sizeof(int) * k);
         for (int j = 0; j < k; j++)
             ans[i] = min(ans[i], ans[son[0][j]] + 1);
         son[0][t[i] - 'a'] = i;
     }
     ```

2. **ZhaoV1 的题解（4星）**  
   - **亮点**：  
     - 二分法判断子序列，预处理 `dp` 数组。  
   - **代码片段**：  
     ```cpp
     for (int i = n-1; i >= 0; i--) {
         int Max = 0;
         for (int j=1; j<=k; j++) Max = max(Max, b[j]);
         dp[i] = dp[Max] + 1;
         b[s[i]-'a'+1] = i;
     }
     ```

3. **znzryb 的题解（4星）**  
   - **亮点**：  
     - 使用 `JumpFar` 记录最远跳跃位置，记忆化搜索计算 `dp`。  

---

### **最优思路或技巧提炼**
1. **反向预处理**：从后往前处理 `s`，动态规划依赖后续状态。
2. **自动机设计**：通过 `son` 数组构建状态转移，快速匹配查询。
3. **贪心覆盖**：每个位置的 `ans` 取所有后续字符的最优解，确保追加数最小。

---

### **同类型题或类似算法套路**
- **子序列自动机**：如 [CF EDU 子序列自动机问题](https://codeforces.com/edu/course/2)。
- **动态规划预处理**：如最长公共子序列变种。

---

### **推荐相似题目**
1. **CF 1778E**：基于子序列自动机的动态规划。
2. **Luogu P5826**：子序列匹配与预处理。
3. **LeetCode 792**：多模式子序列匹配。

---

### **可视化与算法演示**
**动画方案**：  
1. **预处理阶段**：  
   - **颜色标记**：当前处理的字符高亮为红色，`son` 更新路径为蓝色。  
   - **步进控制**：逐步展示每个位置 `i` 的 `son` 和 `ans` 更新。  
2. **查询阶段**：  
   - **路径跟踪**：沿 `son` 转移路径高亮绿色，失败节点标红。  
   - **动态显示 `ans[rt]`**：最终结果以弹窗显示。

**复古游戏化设计**：  
- **像素风格**：`s` 的字符以 8-bit 网格展示，转移路径用箭头动画。  
- **音效**：匹配成功时播放“滴”声，失败时“哔”声。

---

### **核心代码实现**
```cpp
// Eous 的预处理核心代码
for (int i = n; i >= 1; i--) {
    memcpy(son[i], son[0], sizeof(int) * k); // 复制当前 lst 到 son[i]
    ans[i] = INF;
    for (int j = 0; j < k; j++) {
        ans[i] = min(ans[i], ans[son[0][j]] + 1); // 取所有字符的最小值
    }
    son[0][t[i] - 'a'] = i; // 更新 lst 中当前字符的位置
}
```

---

### **总结**
通过反向预处理和自动机结构，Eous 的解法在时间和空间复杂度上均达到最优，是本题的标准解法。关键点在于将子序列匹配转化为状态转移问题，结合动态规划高效求解。

---
处理用时：82.43秒
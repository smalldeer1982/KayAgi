# 题目信息

# 最大子区间和

## 题目描述

给你一个长为 $n$ 的序列 $a=(a_1,a_2,\cdots,a_n)$，$a$ 的一部分丢失了。你的任务是填补丢失的部分使得 $a$ 的最大子区间和为 $k$，或报告无解。

给你一个 01 串 $s$ 和 $a$：
- 如果 $a_i$ 没有被丢失，$s_i=1$，此时 $a_i$ 记录了它的真实值。
- 如果 $a_i$ 被丢失，$s_i=0$，此时给到你的序列 $a$ 中 $a_i=0$。

输入的 $a$ 满足 $\vert a_i\vert\le 10^6$，你填充后的 $a$ 需要满足 $\vert a_i\vert \le 10^{18}$。可以被证明如果存在解，那么一定存在一个满足 $\vert a_i\vert \le 10^{18}$ 的解。

一个长为 $n$ 的数列 $a$ 的最大子区间和是 $\max\limits_{1\le i\le j\le n}\sum\limits_{k=i}^j a_k$。

## 说明/提示

第一组数据中，向唯一丢失的 $a_1$ 填充 $4$ 得到 $a=(4,0,1)$，它的最大子区间和为 $5$。

第二组数据中，向唯一丢失的 $a_3$ 填充 $5$ 得到 $a=(4,-3,5,-2,1)$，它的最大子区间和为 $6$。

第三组数据中 $a_1$ 和 $a_2$ 待填充，向它们填充 $2$ 得到 $a=(2,2,-4,-5)$，它的最大子区间和为 $4$。$a=(0,4,-4,-5)$ 也是一种解法。

对于第四组数据，没有合法的填充 $a$ 的方式。例如 $a=(1,2,0,5,-1,9)$，它的最大子区间和为 $16$ 而非 $12$。

By chenxi2009

## 样例 #1

### 输入

```
10
3 5
011
0 0 1
5 6
11011
4 -3 0 -2 1
4 4
0011
0 0 -4 -5
6 12
110111
1 2 0 5 -1 9
5 19
00000
0 0 0 0 0
5 19
11001
-8 6 0 0 -5
5 10
10101
10 0 10 0 10
1 1
1
0
3 5
111
3 -1 3
4 5
1011
-2 0 1 -5```

### 输出

```
Yes
4 0 1
Yes
4 -3 5 -2 1
Yes
2 2 -4 -5
No
Yes
5 1 9 2 2
Yes
-8 6 6 7 -5
Yes
10 -20 10 -20 10
No
Yes
3 -1 3
Yes
-2 4 1 -5```

# AI分析结果



**唯一算法分类**  
贪心算法

---

### **题解思路与算法要点**

1. **无解条件判断**  
   - 将所有未填充位置（s[i]=0）设为极小值（如-1e13），计算此时的最大子段和。若结果>k 或所有位置已知但最大和≠k，则无解。

2. **构造解的贪心策略**  
   - 选择最后一个未填充位置，计算其左侧最大后缀和（L）与右侧最大前缀和（R），将该位置填充为 `k-L-R`。其他未填充位置设为极小值，确保它们不影响结果。

3. **核心难点**  
   - **正确性证明**：填充后的位置能且只能通过该位置达到最大和k，其他位置的极小值不会干扰。
   - **高效计算前缀/后缀和**：需线性遍历左右元素，累计求和取最大值。

---

### **题解评分（≥4星）**

1. **AstaVenti_（5星）**  
   - 思路清晰，代码简洁高效，正确性易验证。利用动态规划（Kadane算法）快速计算最大子段和，贪心选择最后一个未填充位置，逻辑严谨。

2. **Chen_Johnny（4星）**  
   - 与前解思路一致，但代码中数组索引从0开始，可读性稍逊。关键步骤注释详细，适合教学。

---

### **最优思路提炼**

- **关键技巧**：仅调整一个未填充位置的值，其他位置设为极小值，确保最大子段和仅通过该位置达到k。
- **实现要点**：
  1. 使用动态规划（Kadane算法）计算最大子段和。
  2. 遍历计算特定位置的前缀/后缀最大和。
  3. 极小值需足够小（如-1e13），确保不影响最终结果。

---

### **同类型题推荐**

1. **洛谷 P1115** - 最大子段和（基础版）  
2. **洛谷 P2642** - 最大子矩阵（二维扩展）  
3. **Codeforces 455A** - 动态规划与贪心结合

---

### **可视化算法演示**

**动画方案**  
1. **像素风格设计**  
   - 数组元素显示为8-bit方块：绿色（已知值）、红色（未填充）、黄色（当前处理位置）。  
   - **Canvas绘制**：网格布局，当前处理位置闪烁，左右箭头指示前缀/后缀范围。

2. **关键步骤高亮**  
   - **步骤1**：初始填充极小值，计算最大子段和（红色方块闪烁，显示动态规划过程）。  
   - **步骤2**：选择最后一个红色方块，计算L/R（左右箭头延伸，数值累加显示）。  
   - **步骤3**：填充目标值，验证最大和（黄色方块变绿，播放成功音效）。

3. **音效与交互**  
   - **音效**：成功（8-bit上扬音效）、失败（低沉音效）、步骤执行（短促“滴”声）。  
   - **控制面板**：步进执行、速度调节，支持自动演示（AI自动填充并验证）。

---

### **核心代码片段**

```cpp
// 计算最大子段和（Kadane算法）
ll maxSubArray(vector<ll>& a) {
    ll maxSum = LLONG_MIN, current = 0;
    for (ll x : a) {
        current = max(current + x, x);
        maxSum = max(maxSum, current);
    }
    return maxSum;
}

// 构造解的关键逻辑
pos = 最后一个未填充位置;
ll L = 0, R = 0, sum = 0;
for (int i = pos-1; i >= 0; i--) sum += a[i], L = max(L, sum);
sum = 0;
for (int i = pos+1; i < n; i++) sum += a[i], R = max(R, sum);
a[pos] = k - L - R;
```

---

### **个人心得**

- **调试经验**：极小值需足够小但避免溢出，例如 `-1e13` 在本题中足够小且满足题目约束。  
- **思维突破**：仅需调整一个位置即可构造解，其余位置无需复杂处理，贪心思想显著。

---
处理用时：77.39秒
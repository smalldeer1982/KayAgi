# 题目信息

# Maximal Intersection

## 题目描述

给定n个闭区间,现在要求从这些闭区间中删除一个区间，使得剩下的（n-1）个区间的交集的长度最大，求这个最大值。

（p.s.：若这个区间为空集或它的左端点与右端点重合，则长度为0；否则其长度为右端点在数轴上表示的数-左端点在数轴上表示的数）

## 样例 #1

### 输入

```
4
1 3
2 6
0 4
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
2 6
1 3
0 4
1 20
0 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3
4 5
1 2
9 20
```

### 输出

```
0
```

## 样例 #4

### 输入

```
2
3 10
1 5
```

### 输出

```
7
```

# AI分析结果



# 算法分类  
**前缀与后缀预处理**  

---

## 题解思路与核心难点  

### 核心思路  
所有区间的交集由最大左端点和最小右端点决定。删除一个区间后，剩余区间的交集需要重新计算这两个极值。**前缀与后缀预处理**可以高效解决该问题：  
- **前缀数组**：存储前 i 个区间的左端点最大值 `lpl[i]` 和右端点最小值 `lpr[i]`  
- **后缀数组**：存储后 i 个区间的左端点最大值 `rpl[i]` 和右端点最小值 `rpr[i]`  
- 枚举删除每个区间时，剩余区间的极值由前缀和后缀数组组合计算：  
  ```cpp  
  max_l = max(lpl[i-1], rpl[i+1])  
  min_r = min(lpr[i-1], rpr[i+1])  
  length = max(0, min_r - max_l)  
  ```  

### 解决难点  
1. **极值的动态维护**：删除任意一个区间后，需快速得到剩余区间的极值，避免 O(n²) 暴力计算。  
2. **边界处理**：当删除第一个或最后一个区间时，前缀或后缀数组需正确指向有效范围。  

---

## 题解评分  

### 五星题解  
1. **CreeperK**（赞10）  
   - **亮点**：  
     - 通过三次扫描完成预处理，时间复杂度 O(n)  
     - 代码简洁，逻辑清晰  
   - **代码片段**：  
     ```cpp  
     for(int i=1; i<=n; i++){  
         lpl[i] = max(lpl[i-1], l[i]);  
         lpr[i] = min(lpr[i-1], r[i]);  
     }  
     for(int i=n; i>=1; i--){  
         rpl[i] = max(rpl[i+1], l[i]);  
         rpr[i] = min(rpr[i+1], r[i]);  
     }  
     ```  

2. **Mickey_snow**（赞5）  
   - **亮点**：  
     - 结构体封装区间，提升可读性  
     - 显式分离前缀和后缀合并过程  
   - **代码片段**：  
     ```cpp  
     cg now = *seg;  
     for (int i=1; i<totSeg; i++){  
         arr[i] = now;  
         now = Range(now, seg[i]);  
     }  
     now = seg[totSeg-1];  
     for (int i=totSeg-2; i>=0; i--){  
         arr[i] = Range(arr[i], now);  
         now = Range(now, seg[i]);  
     }  
     ```  

3. **lihongqian__int128**（赞0）  
   - **亮点**：  
     - 极简代码实现，仅用四个数组完成预处理  
     - 直接对极值进行全局维护  

---

## 最优思路提炼  
1. **预处理代替动态计算**：通过前缀和后缀数组，将删除操作转化为静态索引查询。  
2. **极值组合技巧**：删除一个区间后的极值由前缀和后缀的极值组合决定，无需重新遍历所有区间。  

---

## 类似题目推荐  
1. **滑动窗口极值**（洛谷 P1886）：同样需要动态维护窗口内的极值。  
2. **区间合并问题**（LeetCode 56）：合并重叠区间，需处理极值边界。  
3. **最大公约数删除问题**（Codeforces 798D）：利用前缀后缀思想处理删除元素后的全局属性。  

---

## 可视化算法演示  

### 动画设计  
1. **像素风格界面**：  
   - 使用 16 色调色板，区间用不同颜色块表示。  
   - 前缀数组用绿色渐变，后缀数组用蓝色渐变。  
2. **关键步骤高亮**：  
   - **扫描过程**：前缀扫描时，从左到右逐步填充绿色块；后缀扫描时，从右到左填充蓝色块。  
   - **删除操作**：用闪烁红色标记被删除的区间，并显示前缀和后缀的极值组合。  
3. **音效与交互**：  
   - **扫描完成**：播放上升音调表示预处理完成。  
   - **极值更新**：每次计算 `max_l` 和 `min_r` 时触发短促“滴”声。  
   - **自动演示**：按空格键切换自动/手动模式，速度可调节。  

### 核心代码（JavaScript 片段）  
```javascript  
// 初始化 Canvas 和像素网格  
const grid = new PixelGrid(ctx, width, height);  
grid.drawInterval((x, color) => {  
    ctx.fillStyle = color;  
    ctx.fillRect(x * 10, 0, 10, 30); // 每个区间占 10px 宽  
});  

// 前缀扫描动画  
function animatePrefix() {  
    let i = 0;  
    const interval = setInterval(() => {  
        grid.highlight(i, 'green');  
        i++;  
        if (i >= n) clearInterval(interval);  
    }, 100);  
}  
```  

---

## 个人心得摘录  
> **CreeperK**：  
> “插入往往比删除容易。预处理前缀和后缀数组，本质上是在插入时记录历史状态，从而避免删除时的重复计算。”  
>   
> **Mickey_snow**：  
> “区间合并满足交换律，因此可以安全地分离前缀和后缀操作，这是本题的关键突破口。”  

---

## 核心代码实现  
**CreeperK 题解核心逻辑**：  
```cpp  
// 预处理前缀  
for(int i=1; i<=n; i++){  
    lpl[i] = max(lpl[i-1], l[i]);  
    lpr[i] = min(lpr[i-1], r[i]);  
}  
// 预处理后缀  
for(int i=n; i>=1; i--){  
    rpl[i] = max(rpl[i+1], l[i]);  
    rpr[i] = min(rpr[i+1], r[i]);  
}  
// 枚举删除每个区间  
int maxn = 0;  
for(int i=1; i<=n; i++){  
    int L = max(lpl[i-1], rpl[i+1]);  
    int R = min(lpr[i-1], rpr[i+1]);  
    maxn = max(maxn, R - L);  
}  
```

---
处理用时：85.12秒
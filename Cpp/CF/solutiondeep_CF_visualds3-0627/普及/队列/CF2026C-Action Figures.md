# 题目信息

# Action Figures

## 题目描述

在 Monocarp 家附近有一家商店，专门售卖手办。近期，这家店将推出一套新的手办系列，总共包含 $n$ 个手办。其中，第 $i$ 个手办的价格为 $i$ 枚金币。在第 $i$ 天到第 $n$ 天之间，这个手办都是可以购买的。

Monocarp 知道他在这 $n$ 天中的哪几天可以去商店。

每次去商店的时候，他可以购买多件手办（当然，不能买尚未发售的手办）。如果他在同一天购买了至少两个手办，他可以享受一个折扣：他所购买的最贵手办是免费的，也就是说他无需为该手办支付费用。

Monocarp 的目标是从这个手办系列中，分别购买一个第 $1$ 个手办、一个第 $2$ 个手办……一直到一个第 $n$ 个手办。注意，每个手办只能购买一次。请你帮他计算，他最少需要花费多少金币？

## 说明/提示

在第一个测试用例中，Monocarp 可以在第一天购买第一个手办，花费 1 枚金币。

在第二个测试用例中，他可以在第三天购买第 1 和第 3 个手办，在第四天购买第 2 和第 4 个手办，在第六天购买第 5 和第 6 个手办。这样总费用为 $1+2+5=8$ 枚金币。

在第三个测试用例中，他可以在第三天购买第 2 和第 3 个手办，其余手办在第七天购买，最终花费 $1+2+4+5+6 = 18$ 枚金币。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
1
1
6
101101
7
1110001
5
11111```

### 输出

```
1
8
18
6```

# AI分析结果



### 唯一算法分类
**贪心算法**

---

### 题解思路与算法要点

#### 核心思路
所有题解均采用贪心策略，核心逻辑为：**从高价手办向低价遍历，尽可能让高价手办作为免费项**。关键解决以下问题：
1. 优先用 `s[j]=0`（必须单独购买的天数）来匹配高价 `s[i]=1` 的天数，使得高价手办免费。
2. 若没有可用 `0`，则用最小的未被使用的 `1` 来配对，减少总损失。

#### 解决难点
1. **高效匹配**：需要快速找到最近的可用 `0` 或最小的 `1`。不同解法通过不同数据结构实现：
   - **双端队列**（zhouruoheng、MiaoYu）：从后往前处理，`1` 存入队列尾部，`0` 弹出队列头部。
   - **集合**（Drifty、the_Short_Path）：用 `set` 维护 `0` 的位置，通过 `upper_bound` 查找最近的可用位置。
   - **双指针**（__Louis__）：用 `_0` 和 `_1` 指针维护最近的 `0` 和最小的 `1`。
2. **状态维护**：正确处理已配对手办的标记，避免重复使用。

#### 算法对比
| 解法           | 数据结构       | 时间复杂度 | 实现难度 | 核心优化点               |
|----------------|----------------|------------|----------|--------------------------|
| 双端队列       | `deque`        | O(n)       | 易       | 直接操作头尾元素         |
| 集合           | `set`          | O(n log n) | 中等     | 支持高效查找与删除       |
| 双指针         | 数组遍历       | O(n)       | 中等     | 线性扫描避免额外空间     |

---

### 题解评分（≥4星）

1. **MiaoYu（★★★★★）**
   - **亮点**：双端队列实现简洁，逻辑清晰，代码量少。
   - **代码可读性**：变量命名直观，无冗余操作。
   - **关键片段**：
     ```cpp
     for (int i = len - 1; i >= 0; i--) {
         if (s[i] == '1') q.push_back(i + 1);
         else {
             if (!q.empty()) q.pop_front();
             ans += i + 1;
         }
     }
     ```

2. **zhouruoheng（★★★★☆）**
   - **亮点**：分离 `0` 和 `1` 的处理，通过 `deque` 维护 `1` 的位置。
   - **优化点**：优先弹出最近的 `0`，剩余 `1` 两两配对。

3. **__Louis__（★★★★☆）**
   - **亮点**：双指针线性扫描，无需额外数据结构。
   - **关键逻辑**：维护 `_0` 和 `_1` 指针分别指向最近的 `0` 和最小的 `1`。

---

### 最优思路提炼
1. **贪心方向**：从高价到低价处理手办，优先免费高价项。
2. **配对策略**：
   - 优先用必须单独购买的 `0` 来免费高价 `1`。
   - 若无 `0`，则用最小的 `1` 与当前高价 `1` 配对，牺牲较小项。
3. **数据结构选择**：双端队列或双指针实现最优时间复杂度。

---

### 类似题目推荐
1. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**：贪心选择最小代价合并。
2. **[P1209 修理牛棚](https://www.luogu.com.cn/problem/P1209)**：区间覆盖与最优间隔选择。
3. **[P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)**：贪心处理连续区间。

---

### 可视化设计

#### 算法动画演示
1. **核心流程**：
   - **初始化**：显示所有手办编号及对应 `s` 值（`0` 红色，`1` 绿色）。
   - **遍历过程**：从右向左扫描，高亮当前手办（黄色）。
   - **匹配操作**：
     - 若为 `1`，查找最近的 `0`（向左红色项）或最小 `1`（最左绿色项）。
     - 匹配成功时，两配对手办变为灰色，总费用更新。
   - **动态统计**：实时显示剩余未配对手办及当前总花费。

2. **复古像素风格**：
   - **颜色方案**：8-bit 调色板（红、绿、黄、灰）。
   - **Canvas 绘制**：手办以像素方块表示，编号显示在方块上方。
   - **音效设计**：
     - 匹配成功：短促“叮”声（8-bit 音效）。
     - 无匹配项：低沉“哔”声。
   - **自动演示**：按固定速度逐步执行，可暂停/调整速度。

#### 关键代码片段（伪代码）
```javascript
// 初始化队列和费用
let q = [], ans = 0;
for (let i = n-1; i >= 0; i--) {
    if (s[i] === '1') q.push(i+1);
    else {
        if (q.length) q.shift(); // 弹出队头
        ans += i+1;
    }
}
// 处理剩余队列
while (q.length) {
    ans += q.pop();
    if (q.length) q.shift();
}
```

---

### 总结
本题通过贪心策略最大化利用折扣，核心在于高效匹配高价项。双端队列实现简洁高效，适合作为标准解法。可视化设计通过像素动画和音效增强理解，适合教学演示。

---
处理用时：79.52秒
# 题目信息

# Sharky Surfing

## 题目描述

Mualani 喜欢在她的大鲨鱼冲浪板上冲浪！

Mualani 的冲浪路径可以用一个数轴来表示。她从位置 $1$ 开始，路径的终点是位置 $L$。当她处于位置 $x$ 且跳跃能力为 $k$ 时，她可以跳到区间 $[x, x+k]$ 内的任意整数位置。最初，她的跳跃能力为 $1$。

然而，她的冲浪路径并不完全平坦。她的路径上有 $n$ 个障碍物。每个障碍物由一个区间 $[l, r]$ 表示，意味着她不能跳到区间 $[l, r]$ 内的任何位置。

在路径上还有 $m$ 个能量提升点。第 $i$ 个能量提升点位于位置 $x_i$，其值为 $v_i$。当 Mualani 处于位置 $x_i$ 时，她可以选择收集该能量提升点，将她的跳跃能力增加 $v_i$。在同一个位置可能有多个能量提升点。当她处于有多个能量提升点的位置时，她可以选择收集或忽略每个单独的能量提升点。没有能量提升点位于任何障碍物的区间内。

Mualani 必须收集最少的能量提升点数才能到达位置 $L$ 完成冲浪路径。如果无法完成冲浪路径，则输出 $-1$。

## 样例 #1

### 输入

```
4
2 5 50
7 14
30 40
2 2
3 1
3 5
18 2
22 32
4 3 50
4 6
15 18
20 26
34 38
1 2
8 2
10 2
1 4 17
10 14
1 6
1 2
1 2
16 9
1 2 10
5 9
2 3
2 2```

### 输出

```
4
-1
1
2```

# AI分析结果



# Sharky Surfing 题解分析

## 算法分类
**贪心**

---

## 题解思路与算法要点

### 核心思路
所有题解均采用 **贪心 + 优先队列** 的算法框架：
1. **按顺序处理障碍**：将障碍按左端点排序后逐个处理。
2. **动态管理能量点**：在处理每个障碍时，收集所有位于该障碍左端点之前的能量点，存入最大堆（优先队列）。
3. **贪心选取最大能量**：从堆中取出最大的能量值，直到当前跳跃能力足以跨越障碍（跳跃能力需 > 障碍区间长度）。
4. **失败条件**：若堆空仍无法满足条件，输出 `-1`。

### 解决难点
- **跳跃能力动态计算**：每次处理障碍时，需实时更新跳跃能力，优先使用高增益能量点。
- **坐标范围处理**：由于坐标可能很大（如 $L \leq 10^9$），多数题解通过提前对障碍和能量点排序避免离散化。

---

## 题解评分 (≥4星)

1. **WRT_Partisan (★★★★☆)**  
   - **亮点**：代码简洁，逻辑清晰，通过双指针动态维护可用能量点。  
   - **代码**：使用 `while` 循环处理能量点入队，结构易读。

2. **_mi_ka_ (★★★★☆)**  
   - **亮点**：详细分析离散化思路，提供更普适的解法，适合坐标范围大的场景。  
   - **代码**：通过离散化坐标简化跳跃判断，适合教学。

3. **Bc2_ChickenDreamer (★★★★☆)**  
   - **亮点**：代码简洁高效，注释提到多测清空的注意事项（实际代码中已修正）。  
   - **代码**：直接遍历障碍并维护优先队列，无冗余操作。

---

## 最优思路提炼

### 关键技巧
1. **贪心选择最大值**：优先队列确保每次取出当前最大能量值，最小化使用次数。
2. **动态范围管理**：通过排序障碍和能量点，按需加载可用能量点，避免无效遍历。
3. **跳跃能力计算**：跳跃能力需满足 $k > \text{障碍长度}$，即 `k >= r_i - l_i + 1`。

### 代码片段（WRT_Partisan 实现）
```cpp
priority_queue<int> q;
for (int i = 1; i <= n; i++) {
    while (it <= m && a[it].l < b[i].l) 
        q.push(a[it++].r);
    while (num <= b[i].r - b[i].l + 1) {
        if (q.empty()) { /* 处理失败 */ }
        num += q.top(); // 更新跳跃能力
        q.pop(); ans++;
    }
}
```

---

## 同类型题与算法套路

### 类似题目
1. **跳跃游戏 II (LeetCode 45)**：最少跳跃次数到达终点，贪心选择最大步长。
2. **合并果子（洛谷 P1090）**：每次合并最小两堆，优先队列实现。
3. **线段覆盖（洛谷 P1803）**：选择不重叠线段，贪心按右端点排序。

### 通用套路
- **贪心选择极值**：当问题需要最小化操作次数时，优先选择当前最优解（如最大值/最小值）。
- **动态维护候选集**：使用堆或队列管理候选元素，按条件动态加载。

---

## 推荐题目
1. **P1090 [NOIP2004 提高组] 合并果子**  
   - 贪心+优先队列的经典问题。

2. **P1223 [JSOI2007] 奶酪**  
   - 动态选择最优路径，类似跳跃能力管理。

3. **P1803 凌乱的yyy / 线段覆盖**  
   - 贪心选择不重叠区间，与障碍处理思路相似。

---

## 可视化与算法演示

### 动画设计
1. **核心流程**：
   - **障碍高亮**：红色方块表示当前处理的障碍区间。
   - **能量点加载**：绿色圆点表示可用能量点，按坐标顺序进入优先队列。
   - **跳跃能力更新**：每次从队列取出最大值时，显示能力增长动画。

2. **复古像素风格**：
   - **障碍**：8-bit 红色条纹方块。
   - **能量点**：闪烁的绿色像素点，收集时播放“哔”音效。
   - **状态栏**：显示当前跳跃能力、已用能量点数量。

3. **交互功能**：
   - **步进控制**：空格键单步执行，观察队列变化。
   - **自动模式**：AI 自动运行，速度可调（1x/2x/5x）。
   - **音效**：收集能量点时播放 8-bit 上升音调，失败时播放低沉音效。

### 关键代码（Canvas 示例）
```javascript
// 绘制障碍和能量点
function drawObstacle(ctx, l, r, y) {
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(l * scale, y, (r - l) * scale, 10);
}

function drawPowerUp(ctx, x, y) {
    ctx.fillStyle = '#00FF00';
    ctx.beginPath();
    ctx.arc(x * scale, y, 5, 0, Math.PI * 2);
    ctx.fill();
}
```

---

## 个人心得摘录
- **多测清空陷阱**：某题解因未清空优先队列导致 WA，强调多测环境下初始化的重要性。
- **贪心正确性证明**：选择最大值的最优性可通过反证法验证，需确保无后效性。

---
处理用时：76.75秒
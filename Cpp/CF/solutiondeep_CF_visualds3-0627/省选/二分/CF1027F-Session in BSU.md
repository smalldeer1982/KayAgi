# 题目信息

# Session in BSU

## 题目描述

Polycarp studies in Berland State University. Soon he will have to take his exam. He has to pass exactly $ n $ exams.

For the each exam $ i $ there are known two days: $ a_i $ — day of the first opportunity to pass the exam, $ b_i $ — day of the second opportunity to pass the exam ( $ a_i < b_i $ ). Polycarp can pass at most one exam during each day. For each exam Polycarp chooses by himself which day he will pass this exam. He has to pass all the $ n $ exams.

Polycarp wants to pass all the exams as soon as possible. Print the minimum index of day by which Polycarp can pass all the $ n $ exams, or print -1 if he cannot pass all the exams at all.

## 样例 #1

### 输入

```
2
1 5
1 7
```

### 输出

```
5
```

## 样例 #2

### 输入

```
3
5 13
1 5
1 7
```

### 输出

```
7
```

## 样例 #3

### 输入

```
3
10 40
40 80
10 80
```

### 输出

```
80
```

## 样例 #4

### 输入

```
3
99 100
99 100
99 100
```

### 输出

```
-1
```

# AI分析结果



## 算法分类
**无算法分类**

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解均采用 **离散化 + 图论/并查集** 策略：
1. **离散化**：将时间点压缩到连续编号。
2. **建图或维护并查集**：每个考试的两个时间点视为边或节点。
3. **连通块分析**：判断每个连通块的边数、点数关系，推导答案。

### 关键解决难点
1. **冲突检测**：如何判断是否存在无法满足所有考试的情况。
2. **最优时间推导**：基环树取最大值，树取次大值（图论解法）；并查集动态维护可反悔的最优选择（并查集解法）。

---

## 题解评分（≥4星）

### [★★★★★] ModestCoder_（并查集）
- **亮点**：通过并查集动态维护可反悔的时间点选择，代码简洁高效。
- **关键代码**：
  ```cpp
  int s1 = get(a[i].v), s2 = get(b[i].v);
  if (s1 == s2 || !s1 || !s2) ans = max(ans, max(num[s1], num[s2]));
  else f[s1] = s2;
  ```

### [★★★★☆] 大菜鸡fks（基环树分析）
- **亮点**：基环树与树的性质分析清晰，通过 DFS 遍历连通块统计边数点数。
- **代码关键**：
  ```cpp
  if (ed/2 == sz) ans = max(ans, mx1); // 基环树取最大值
  else ans = max(ans, mx2);            // 树取次大值
  ```

### [★★★★☆] LXH5514（并查集详解）
- **亮点**：详细推导并查集维护策略，结合反悔机制实现最优选择。
- **核心思想**：小时间点优先选择，通过合并操作允许后续反悔。

---

## 最优思路提炼
**并查集动态维护 + 反悔机制**（ModestCoder_）：
1. **离散化**：将时间点映射为连续整数。
2. **并查集初始化**：每个时间点初始为独立集合。
3. **处理每场考试**：
   - 若两个时间点未被选择，合并为同一集合（优先选较小时间）。
   - 若有一个已被选择，合并到另一时间点（反悔机制）。
   - 若均被选择且冲突（同一集合），直接标记无解。

---

## 同类型题与算法套路
1. **图论基环树**：判断连通块边数与点数关系（P2661 信息传递）。
2. **并查集反悔**：动态维护可撤销选择（P1197 星球大战）。
3. **时间安排冲突检测**：离散化后处理时间区间（P1842 奶牛排队）。

---

## 推荐洛谷题目
1. **P3367**：并查集模板题（基础维护）。
2. **P1330**：图的连通性与染色（基环树变形）。
3. **P1197**：动态维护连通性（并查集反悔）。

---

## 个人心得摘录
- **ModestCoder_**：  
  > "并查集的连边操作本质是允许对之前的选择进行反悔。例如：若考试1选了时间1，后续考试2可以将时间1反悔为时间5，从而考试2选时间1。"
  
- **LXH5514**：  
  > "祖先节点存储的是当前集合中未被选择的时间点，合并时优先保留较大的时间点，确保后续选择更优。"

---

## 可视化与算法演示设计
### 复古像素风格动画（并查集合并）
1. **Canvas 布局**：
   - 时间点排列为网格，每个节点用像素方块表示。
   - 不同颜色区分：未选（灰色）、已选（绿色）、冲突（红色）。
2. **动画逻辑**：
   - **步骤1**：离散化时间点，显示初始独立方块。
   - **步骤2**：逐个处理考试，高亮当前两个时间点方块。
   - **步骤3**：动态合并方块（小时间向大时间移动），播放合成音效。
3. **音效设计**：
   - 合并成功：短促“叮”声（8-bit 音效）。
   - 冲突发生：低沉“哔”声。

### 交互功能
- **自动播放**：按处理顺序自动展示合并过程。
- **单步调试**：手动控制每一步合并，观察并查集变化。
- **冲突高亮**：出现两个时间点均不可选时，全屏闪烁红光。

---

## 代码片段（并查集核心）
```cpp
// ModestCoder_ 题解核心代码
for (int i=1; i<=n; ++i) {
    int s1 = get(a[i].v), s2 = get(b[i].v);
    if (s1 == s2 || !s1 || !s2) {
        ans = max(ans, max(num[s1], num[s2]));
        f[s1] = f[s2] = 0; // 标记集合不可用
    } else {
        if (s1 > s2) swap(s1, s2);
        ans = max(ans, num[s1]); // 选择较小时间点
        f[s1] = s2; // 合并到较大时间点
    }
}
```

---

## 总结
本题核心在于 **将时间选择转化为图或并查集的连通性问题**，通过分析连通块性质或动态维护可反悔的选择得出最优解。并查集解法因其高效性和简洁性成为最优方案，适合处理大规模数据。

---
处理用时：70.96秒
# 题目信息

# Segmentation Folds

## 题目描述

Peter 喜欢折线段玩。有一条线段位于数轴上的区间 $[\ell, r]$。现如今正是折叠线段的好时机，Peter 决定小心翼翼地对这条线段进行折叠。每次操作中，他可以选择以下两种方式之一（在可能的情况下）：

1. 操作 $\tt{LTR}$：他从左向右折线段，使得左端点 $\ell$ 与某个点 $x$ 重合（$\ell < x \le r$），并且 $\ell + x$ 是质数。当他选择此操作时，总是选取最大的 $x$ 值。折叠后，线段所在的区间变为 $[\frac{1}{2}(\ell + x), r]$。
   
2. 操作 $\tt{RTL}$：他从右向左折线段，使得右端点 $r$ 与某个点 $x$ 重合（$\ell \le x < r$），并且 $r + x$ 是质数。当他选择此操作时，总是选取最小的 $x$ 值。折叠后，线段所在的区间变为 $[\ell, \frac{1}{2}(r + x)]$。

一个折叠序列是指这两种操作的组合。Peter 想要通过多次折叠，使线段的长度尽可能短，且无法再缩短。区间的长度自然定义为 $r - \ell$。考虑以下例子：假设我们折叠一段初始为 $[1, 30]$ 的线段。有三种折叠方式能使最终区间长度最短，如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041F/be032bc113ac39f401b84d34f2c5f31947b110d1.png)

请你帮助 Peter 确定有多少种不同的折叠序列可以使线段达到最短长度。结果需要对 $998244353$ 取模。

注：一个大于 $1$ 的整数 $p$ 是质数，当且仅当不存在整数 $a, b > 1$ 使得 $p = ab$。

## 样例 #1

### 输入

```
3
1 30
16 18
142857 240135```

### 输出

```
3
1
63```

# AI分析结果



### 唯一算法分类
**二分**

---

### 综合分析与结论
题目要求通过两种折叠操作将线段缩至最短，且无法再折叠。核心思路如下：
1. **质数预处理**：将区间 `[2l, 2r]` 内的质数筛出，避免浮点运算。
2. **状态转移**：对每个区间状态进行搜索，记录到达该状态的路径数目。
3. **终止条件**：无法折叠时，统计最短长度的路径总数。

**二分过程要点**：
- **质数查找**：在预处理后的质数列表中，通过二分法快速定位满足条件的最大/最小质数。
- **区间更新**：LTR 操作需找最大质数 `p = l + x`，RTL 操作需找最小质数 `p = r + x`。
- **边界收缩**：二分条件为质数是否在允许范围内，收缩区间至合法值。

**可视化设计**：
- **像素动画**：用网格展示区间 `[left, right]`，每次折叠高亮 mid 点，显示质数验证结果。
- **音效交互**：成功折叠播放上扬音效，失败播放短促音效，背景音乐循环。
- **自动演示**：模拟 AI 自动执行所有可能的折叠路径，展示最短路径收敛过程。

---

### 题解清单 (4.5星)
**作者：沉石鱼惊旋**  
**亮点**：
- 预处理质数避免浮点误差，利用区间筛法高效处理大范围质数。
- 状态转移通过记忆化搜索实现，复杂度线性，逻辑清晰。
- 双指针优化代替二分，减少对数复杂度。

---

### 核心代码实现
```cpp
// 预处理质数（区间筛法）
vector<bool> sieve;
void precompute_primes(ll l, ll r) {
    ll sqrt_r = sqrt(r);
    vector<bool> is_prime_small(sqrt_r + 1, true);
    for (ll i = 2; i * i <= sqrt_r; i++) {
        if (is_prime_small[i]) {
            for (ll j = i * i; j <= sqrt_r; j += i)
                is_prime_small[j] = false;
        }
    }
    sieve.assign(r - l + 1, true);
    for (ll i = 2; i <= sqrt_r; i++) {
        if (is_prime_small[i]) {
            for (ll j = max(i * i, (l + i - 1) / i * i); j <= r; j += i)
                sieve[j - l] = false;
        }
    }
}

// 二分查找最大质数（LTR操作）
ll find_max_prime(ll l, ll r) {
    auto it = upper_bound(primes.begin(), primes.end(), r);
    if (it == primes.begin()) return -1;
    --it;
    while (*it > l) {
        if (binary_search(primes.begin(), primes.end(), *it))
            return *it;
        --it;
    }
    return -1;
}
```

---

### 同类型题与套路
- **质数筛法**：处理大范围质数时，区间筛法是关键。
- **状态压缩与记忆化**：通过 BFS/DFS 记录状态路径数，避免重复计算。
- **二分优化**：在有序质数列表快速定位边界。

**类似题目**：
1. [P1835 素数密度](https://www.luogu.com.cn/problem/P1835)（区间筛法）
2. [CF862B Mahmoud and Ehab and the bipartiteness](https://codeforces.com/problemset/problem/862/B)（树形 DP）
3. [AT1219 歴史の研究](https://www.luogu.com.cn/problem/AT1219)（莫队算法）

---

### 可视化与游戏化设计
- **像素风格**：用 8-bit 网格模拟数轴，区间端点用不同颜色标记。
- **音效触发**：折叠成功时播放“升级”音效，失败时播放“错误”音效。
- **自动模式**：模拟所有可能的折叠路径，用绿色高亮最短路径。

---
处理用时：86.40秒
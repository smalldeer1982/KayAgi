# 题目信息

# Fallen Towers

## 题目描述

Pizano 建造了一个由 $n$ 座高塔组成的数组 $a$，每座高塔由 $a_i \ge 0$ 个方块组成。

Pizano 可以推倒一座高塔，使得接下来的 $a_i$ 座高塔各增加 $1$ 个方块。换句话说，他可以选取元素 $a_i$，将接下来的 $a_i$ 个元素各加 $1$，然后将 $a_i$ 设为 $0$。如果推倒的高塔方块数超出数组范围，则这些方块会消失。如果 Pizano 推倒一座 $0$ 方块的高塔，则不会发生任何变化。

Pizano 希望以任意顺序推倒所有 $n$ 座高塔，每座高塔恰好被推倒一次。也就是说，对于每个 $i$ 从 $1$ 到 $n$，他将恰好推倒位置 $i$ 的高塔一次。

此外，最终的高塔高度数组必须是非递减的。这意味着在他推倒所有 $n$ 座高塔后，对于任意 $i < j$，位置 $i$ 的高塔高度不能超过位置 $j$ 的高塔高度。

你需要输出最终高塔高度数组的最大 $\text{MEX}$ 值。

$\text{MEX}$ 是指数组中缺失的最小非负整数。

## 说明/提示

第一个测试用例的解释：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2108F/aa04335da43131aa6a37290f90705cf6ef46ee3d.png)

第二个测试用例的解释：注意所有高塔都被恰好推倒一次，且最终的高度数组是非递减的。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2108F/93831ffd87d4f17502d74b13db29c4368e8cf0f9.png)

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
8
2
1 2
4
2 1 0 0
10
5 9 3 7 1 5 1 5 4 3
10
1 1 1 1 1 1 1 1 1 1
10
3 2 1 0 3 2 1 0 3 2
5
5 2 0 5 5
1
1000000000
7
4 0 1 0 2 7 7```

### 输出

```
2
3
7
4
5
4
1
3```

# AI分析结果



---

### 算法分类
**贪心算法结合二分查找**

---

### 题解思路与难点分析

#### 核心思路
1. **引理支撑**：若存在可行解数组 `r`，则所有满足 `r' ≤ r` 的数组 `r'` 均可行。这使得可以通过构造最宽松的约束条件进行二分答案。
2. **二分 MEX**：通过二分法确定最大 MEX 值 `x`，构造目标数组要求每个位置 `i` 的值至少为 `max(0, i - (n - x + 1))`，以确保非递减性并覆盖 0 到 `x-1`。
3. **贪心验证**：在验证每个 `x` 时，维护当前累积的影响（`cur`）和差分数组（`d`），逐位置检查是否满足最小需求，并动态更新影响范围。

#### 难点对比
- **构造目标数组**：需确保数组非递减且覆盖足够多的数值。第二个题解通过 `need = max(0, i - (n - x + 1))` 精准定位每个位置的下界。
- **差分数组优化**：通过延迟处理未来影响，避免重复遍历，将时间复杂度优化至 O(n)。

---

### 最优思路提炼
1. **二分答案**：将问题转化为判定性问题，二分 MEX 值 `x`。
2. **目标数组构造**：对每个 `x`，计算 `r_i = max(0, i - (n - x + 1))`，确保覆盖必要数值且非递减。
3. **贪心验证**：
   - 维护当前累积影响 `cur` 和差分数组 `d`，用于记录未来位置的增减。
   - 逐位置检查 `cur` 是否足够满足 `need`，并更新 `d` 以处理后续影响。

---

### 题解评分（≥4星）
1. **EmptyAlien 的题解（5星）**
   - **思路清晰**：完整阐述引理、二分策略及贪心验证。
   - **代码简洁**：通过差分数组高效处理影响范围，逻辑紧凑。
   - **正确性验证**：通过样例测试，构造目标数组的数学推导正确。
   - **调试提示**：无显式调试记录，但代码结构清晰，易于复现。

---

### 核心代码实现
```cpp
bool check(int x) {
    memset(d, 0, sizeof(d));
    int cur = 0;
    for (int i = 1; i <= n; ++i) {
        cur -= d[i];
        int need = max(0, i - (n - x + 1));
        if (cur < need) return false;
        int tmp = i + a[i] + cur - need + 1;
        if (tmp <= n) d[tmp]++;
        cur++;
    }
    return true;
}
```

---

### 可视化算法设计
1. **动画设计**：
   - **网格展示**：用 Canvas 绘制塔的初始状态，每次推倒高亮当前塔，后续受影响的塔渐变色标记。
   - **差分数组动态显示**：右侧面板实时更新 `cur` 值和 `d` 数组的变化。
   - **步进控制**：支持单步执行，观察 `cur` 和 `d` 的更新逻辑。

2. **复古像素风格**：
   - **颜色方案**：8 色调色板，塔高用不同色块表示，推倒时触发像素抖动特效。
   - **音效反馈**：执行推倒时播放 8-bit 音效，成功找到 MEX 时播放胜利音效。

3. **交互面板**：
   - **速度调节**：滑动条控制动画速度，支持暂停/继续。
   - **自动演示**：AI 模式自动运行二分过程，高亮当前检查的 `x` 值。

---

### 相似题目推荐
1. **CF977F Consecutive Subsequence**（序列构造与贪心）
2. **LeetCode 300. Longest Increasing Subsequence**（二分优化）
3. **洛谷 P1083 借教室**（差分数组应用）

---
处理用时：180.45秒
# 题目信息

# Bear and Tower of Cubes

## 题目描述

Limak是一只可爱的北极熊。他正在用一堆木块搭塔。每一个木块都是一个有着正整数边长的正方体。Limak有无数块木块。显然的，每一块边长为$a$  的木块的体积为$a^3$  ，而一个塔的体积为组成这个塔的所有木块的体积和。**这里，我们定义一个塔的高度是组成这个塔的木块数量。**

Limak现在要搭建一个塔。首先，他让你告诉他一个正整数$X$  ，表示这个塔的总体积。然后，他将会贪心地搭建这个塔（每次总是尽可能地添加最大的木块，即先选一个体积最大的正方体作为第一层，第一层的体积满足体积不超过$X$  。然后选一个最大的正方体做第二层，使得前两层的体积和满足不超过$X$  。然后再选一个最大的正方体做第三层，使得前三层的体积和满足不超过$X$  。依次类推，直到建好一座体积为$X$  的塔）。

Limak想让你在$1$  - $m$  之间选择一个$X$  ，使他能够搭建的塔的总高度$h$  最高。同时，在总高度最高的情况下，让塔的总体积$X$  最大。

（实在没看懂题意可以看看样例解释）

## 说明/提示

对于样例1，当$X=23$  或$X=42$  时$h$  有最大值为9。因为Limak想让你最大化塔的体积，所以应该选择42。

在选择$X=42$  之后，具体的建塔过程为：

> - 首先，Limak选择一块边长为3的木块，因为这是体积不超过42的最大木块。剩下的体积为$42-27=15$  。 
> - 然后，同样的，Limak会选择边长为2的木块，所以剩下的体积为$15-8=7$  。 
> - 最后，Limak放上7块边长为1的木块。  

所以，这座塔的高度为9，总体积为$3^3+2^3+7*1^3=27+8+7=42$  。

感谢@星烁晶熠辉 提供的翻译

## 样例 #1

### 输入

```
48
```

### 输出

```
9 42
```

## 样例 #2

### 输入

```
6
```

### 输出

```
6 6
```

# AI分析结果



---

**唯一算法分类**  
无算法分类

---

**综合分析与结论**  
本题核心思路是贪心策略结合深度优先搜索（DFS），通过递归遍历两种可能的选择路径（取最大立方体或次大立方体），确保覆盖所有潜在最优解。难点在于识别何时选择次大立方体能带来更高的总高度。题解普遍采用以下策略：  

1. **贪心选择与递归回溯**  
   - 每次找到当前剩余体积允许的最大立方体边长 `a`，递归处理两种分支：  
     - **取 `a`**：剩余体积为 `m - a³`  
     - **取 `a-1`**：剩余体积为 `a³ - 1 - (a-1)³`（确保后续能分解更多小立方体）  
   - 通过比较两种分支的高度和体积，选择最优解。  

2. **二分查找优化**  
   部分题解（如 xukuan）使用 `upper_bound` 快速确定最大 `a`，将时间复杂度从线性查找优化至对数级。  

3. **可视化设计思路**  
   - **动画展示**：以树状图形式展示递归路径，每次分支高亮两种选择（取 `a` 或 `a-1`）。  
   - **颜色标记**：  
     - 当前 `a` 用绿色方块，剩余体积用黄色进度条。  
     - 选择路径用蓝色（取 `a`）和橙色（取 `a-1`）箭头区分。  
   - **步进控制**：支持单步执行，观察每次递归的剩余体积和高度变化。  
   - **复古像素风**：用 8-bit 风格绘制立方体，每次选择时播放经典音效（如“选择”音效、成功音效）。  

---

**题解清单 (≥4星)**  
1. **快斗游鹿 (4星)**  
   - **亮点**：简洁的递归实现，直接处理两种分支，代码逻辑清晰。  
   - **引用**：“接下来的边长不是 `a` 就是 `a-1`，再小并不会更优秀。”  

2. **xukuan (4星)**  
   - **亮点**：结合二分查找加速最大边长计算，预处理三次方数组提升效率。  
   - **代码优化**：使用 `upper_bound` 替代循环，降低时间复杂度。  

3. **Querainy (4星)**  
   - **亮点**：极简递归结构，通过 `cbrt` 快速计算最大边长，返回 `pair` 结构简化比较逻辑。  

---

**最优思路或技巧提炼**  
1. **关键策略**：每一步仅需考虑取最大边长 `a` 或次大边长 `a-1`，更小的边长无法更优。  
2. **递归设计**：传递剩余体积、当前高度和总体积，回溯时比较并更新全局最优解。  
3. **边界处理**：当 `a=1` 时不再考虑 `a-1`，避免无效递归。  

---

**同类型题或类似算法套路**  
- **类似问题**：硬币找零问题（贪心+回溯）、整数拆分最大乘积问题。  
- **通用解法**：当贪心策略可能不全局最优时，通过有限分支的递归或动态规划覆盖潜在最优路径。  

---

**推荐洛谷题目**  
1. P1666 前缀极差  
2. P1443 马的遍历  
3. P1412 经营与开发  

---

**代码片段 (核心逻辑)**  
```cpp
// xukuan 题解中的二分查找与递归实现
void dfs(ll m, ll t, ll r) {
    ll Do = upper_bound(three + 1, three + 100002, m) - three;
    Do--;
    dfs(m - three[Do], t + 1, r + three[Do]); // 取 a
    if (Do > 1) dfs(three[Do] - 1 - three[Do - 1], t + 1, r + three[Do - 1]); // 取 a-1
}
```

---

**可视化与算法演示**  
- **动画方案**：  
  - **初始化**：显示当前剩余体积 `m`，计算最大边长 `a`，绘制两个分支按钮（取 `a` 或 `a-1`）。  
  - **分支选择**：点击按钮进入对应分支，更新剩余体积和高度，递归动画继续。  
  - **回溯高亮**：当某分支达到叶子节点（剩余体积为0），回溯路径并高亮最优解。  

- **复古像素风**：  
  - **颜色方案**：使用经典 FC 色调（绿、蓝、橙），立方体用 8x8 像素块表示。  
  - **音效触发**：选择分支时播放“跳跃”音效，找到解时播放“胜利”音效。  

---

**个人心得摘录**  
- **快斗游鹿**：“因为答案很小，直接搜索即可。” —— 利用问题特性（高度有限）简化复杂度分析。  
- **Siteyava_145**：“如果将剩余体积变得更小，用一个边长是 `L-2` 的正方体，那样就会浪费很多体积。” —— 强调贪心策略的局部最优性。  

--- 

**可视化代码片段 (伪代码)**  
```javascript
// 伪代码：绘制递归分支
function drawBranch(m, a, depth) {
  drawCube(a); // 绘制当前立方体
  if (m - a³ >= 0) {
    drawBranch(m - a³, nextA, depth + 1); // 递归取 a
  }
  if (a > 1) {
    drawBranch(a³ - 1 - (a-1)³, a-1, depth + 1); // 递归取 a-1
  }
}
```

---
处理用时：103.86秒
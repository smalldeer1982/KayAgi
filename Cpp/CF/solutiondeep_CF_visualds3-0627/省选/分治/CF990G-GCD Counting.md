# 题目信息

# GCD Counting

## 题目描述

You are given a tree consisting of $ n $ vertices. A number is written on each vertex; the number on vertex $ i $ is equal to $ a_i $ .

Let's denote the function $ g(x, y) $ as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex $ x $ to vertex $ y $ (including these two vertices).

For every integer from $ 1 $ to $ 2 \cdot 10^5 $ you have to count the number of pairs $ (x, y) $ $ (1 \le x \le y \le n) $ such that $ g(x, y) $ is equal to this number.

## 样例 #1

### 输入

```
3
1 2 3
1 2
2 3
```

### 输出

```
1 4
2 1
3 1
```

## 样例 #2

### 输入

```
6
1 2 4 8 16 32
1 6
6 3
3 4
4 2
6 5
```

### 输出

```
1 6
2 5
4 6
8 1
16 2
32 1
```

## 样例 #3

### 输入

```
4
9 16 144 6
1 3
2 3
4 3
```

### 输出

```
1 1
2 1
3 1
6 2
9 2
16 2
144 1
```

# AI分析结果



## 算法分类
树结构、数论（GCD）、并查集、容斥原理

---

## 综合分析与结论
### 核心思路与难点
1. **核心逻辑**：  
   - 直接求路径 GCD 等于 k 的数目困难，转为求 GCD 是 k 倍数的路径数（易计算）。  
   - 对每个 k 构建子图：仅保留点权为 k 倍数的节点及边。  
   - 用并查集统计连通块大小，计算每个连通块的路径贡献数（s*(s+1)/2）。  
   - 通过逆序容斥（减去倍数贡献）得到最终结果。

2. **难点与突破**：  
   - **因子枚举优化**：每个点预处理所有因子，避免重复计算。  
   - **高效合并连通块**：并查集按需初始化，仅处理当前 k 的边。  
   - **容斥方向**：从大到小枚举 k，确保每个 k 的贡献只被扣除一次。

---

## 题解清单（评分 ≥4星）
### 1. intel_core（⭐⭐⭐⭐⭐）
- **亮点**：  
  - 预处理每个节点的所有因子，直接构建按因子分组的边列表。  
  - 按因子从小到大处理，通过并查集快速合并连通块。  
  - 逆序容斥代码简洁，时间复杂度稳定 O(160n)。  
  ```cpp
  // 核心容斥代码
  for(int i=2e5;i>=1;i--)
      for(int j=2;j*i<=2e5;j++) f[i]-=f[i*j];
  ```

### 2. LCuter（⭐⭐⭐⭐）
- **亮点**：  
  - 结合莫比乌斯反演公式，数学推导清晰。  
  - 独立维护每个因子的节点集合，避免重复计算。  
  - 利用 DFS 统计连通块大小，适合因子稀疏的场景。

### 3. Acoipp（⭐⭐⭐⭐）
- **亮点**：  
  - 预处理边的 GCD 因子，减少冗余合并操作。  
  - 动态维护并查集，直接计算合并带来的增量贡献。  
  ```cpp
  // 边处理逻辑
  temp = __gcd(a[u], a[v]);
  for(j=1;j*j<=temp;j++) if(temp%j==0){
      op[j].push_back(i);
      if(temp/j!=j) op[temp/j].push_back(i);
  }
  ```

---

## 最优思路提炼
### 关键步骤
1. **因子预处理**：为每个节点存储其权值的所有因子，按因子分组节点和边。  
2. **并查集动态合并**：仅处理当前因子 k 的边，快速统计连通块贡献。  
3. **逆序容斥**：从最大值向下扣除倍数贡献，保证结果正确性。

### 代码片段
```cpp
// 预处理因子分组
for(int i=1;i<=n;i++){
    for(int j=1;j*j<=a[i];j++)
        if(a[i]%j==0){
            v[j].push_back(i);
            if(j*j!=a[i]) v[a[i]/j].push_back(i);
        }
}

// 处理每个因子 k 的连通块
for(int i=1;i<=2e5;i++){
    for(int x:v[i]) flag[x]=1;
    for(int x:v[i])
        for(int k:g[x]) if(flag[k]) merge(x,k);
    for(int x:v[i])
        if(fa[x]==x) f[i] += size[x]*(size[x]+1)/2;
    // 复位并查集
}
```

---

## 同类型题目推荐
1. **CF1101D GCD Counting**：求树中最长路径，其 GCD 大于 1。  
2. **CF915G Coprime Arrays**：利用容斥和莫比乌斯函数统计数组数目。  
3. **Luogu P3327 约数个数和**：数论分块与因子贡献结合。

---

## 可视化设计
### 算法演示方案
1. **树结构绘制**：  
   - 用 Canvas 绘制树形结构，节点颜色表示是否属于当前因子 k 的集合。  
   - 动态高亮当前处理的边（红色线条），合并后连通块用同色填充。

2. **并查集操作**：  
   - 显示父节点指针变化，合并时用箭头动画表示父子关系更新。  
   - 实时显示连通块大小数值（悬浮提示或侧边栏表格）。

3. **容斥过程**：  
   - 用柱状图展示每个 k 的当前贡献值（f[k]）。  
   - 逆序处理时，用颜色渐变表示扣除操作的传播（如红色扩散到倍数项）。

### 复古像素风格
- **调色板**：16 色经典 FC 风格（深绿、品红、青蓝）。  
- **音效**：  
  - 合并成功：8-bit "哔" 声（频率随连通块大小变化）。  
  - 容斥扣除：短促 "咔嚓" 音效。  
- **自动演示**：  
  - 按空格键暂停/继续，方向键调节速度。  
  - 右上角显示当前因子 k 和剩余待处理数。

---

通过此方案，学习者可直观观察因子分组的合并过程，理解容斥的减法逻辑，并通过交互操作深入掌握算法核心。

---
处理用时：70.04秒
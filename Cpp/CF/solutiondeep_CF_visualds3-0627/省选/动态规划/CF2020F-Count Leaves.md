# 题目信息

# Count Leaves

## 题目描述

有正整数 $n$ 和 $d$。我们按如下规则建一棵 $T_{n,d}$ 的约数树：

- 树的根节点上的数为 $n$。这是树的第 $0$ 层。
- 对于第 $i$ 层（$i=0,1,...,d-1$）的每个结点，执行如下操作：若当前节点上的数为 $x$，则 $x$ 的所有可能的不同约数为其儿子节点上的数。这些儿子节点位于第 $i+1$ 层。
- 第 $d$ 层上的点为叶子节点。

例如，$T_{6,2}$（$n=6,d=2$ 的约数树）如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2020F/fe3509981f0e7cfbf5fabd59d7e6e5b6182b6f65.png)

定义 $f(n,d)$ 为 $T(n,d)$ 的叶子节点数。

给定 $n,k,d$ ，计算 $\sum\limits_{i=1}^nf(i^k,d)$ 模 $10^9+7$ 后的答案。

注：在这个问题中，我们说 $y$ 为 $x$ 的约数当且仅当 $y\geq1$ 且存在整数 $z$ 使得 $x=y\cdot z$。

## 样例 #1

### 输入

```
3
6 1 1
1 3 3
10 1 2```

### 输出

```
14
1
53```

# AI分析结果



0. **题目翻译**

---

# 计算叶子节点数

## 题目描述

给定正整数 $n$ 和 $d$。我们按如下规则构建一棵 $T_{n,d}$ 的约数树：

- 树的根节点数值为 $n$。这是树的第 $0$ 层。
- 对于第 $i$ 层（$i=0,1,...,d-1$）的每个节点，若当前节点数值为 $x$，则其所有不同约数作为子节点出现在第 $i+1$ 层。
- 第 $d$ 层的节点为叶子节点。

例如，$T_{6,2}$ 的结构如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2020F/fe3509981f0e7cfbf5fabd59d7e6e5b6182b6f65.png)

定义 $f(n,d)$ 为 $T(n,d)$ 的叶子节点数。给定 $n,k,d$，计算 $\sum\limits_{i=1}^nf(i^k,d)$ 模 $10^9+7$ 的结果。

注：此处定义 $y$ 是 $x$ 的约数当且仅当 $y≥1$ 且存在整数 $z$ 满足 $x=y·z$。

---

1. **唯一算法分类**  
无算法分类（核心解法基于积性函数与组合数学）

2. **综合分析与结论**

**核心思路**：  
将问题分解为积性函数求和，利用组合数与Min25筛法实现高效计算。每个数 $i^k$ 的质因数分解形式为 $\prod p^{c}$，其贡献为 $\prod \binom{ck+d}{d}$。通过深度优先搜索枚举质因数组合，结合Min25筛预处理质数分布。

**关键难点**：  
- 积性函数的快速前缀和计算  
- 大范围质数的高效处理  

**可视化设计要点**：  
1. **动态质因数分解演示**：用像素网格展示质因数 $p$ 的指数 $c$ 如何通过组合数 $\binom{ck+d}{d}$ 生成贡献  
2. **Min25筛法动画**：用不同颜色标记质数筛选过程，展示质数计数数组 $g$ 的更新  
3. **复古像素风格**：8位像素字体显示组合数计算过程，当DFS搜索新质数时播放经典NES音效

3. **题解清单 (4.5星)**  
- **作者：DaiRuiChen007**  
  亮点：  
  ✅ 创造性使用组合数与积性函数性质  
  ✅ Min25筛法预处理降低时间复杂度至 $O(n^{3/4}/\log n)$  
  ✅ 通过DFS剪枝处理大质数与小质数的不同贡献  

4. **核心代码与实现思想**

**关键代码片段**：
```cpp
void dfs(int i, int N, ll dp) {
    if(g[idx(N)] > i) // 处理最大质因子出现1次的情况
        ans = (ans + dp * f[1] % MOD * (g[idx(N)] - i)) % MOD;
    for(int j = i + 1; j <= tot && p[j] <= N / p[j]; ++j) { // 枚举更大质数
        for(int c = 1, M = N / p[j]; M >= p[j]; ++c, M /= p[j]) { 
            ans = (ans + dp * f[c + 1]) % MOD; // 当前质数指数为c+1时的贡献
            dfs(j, M, dp * f[c] % MOD); // 递归处理剩余部分
        }
    }
}
```

**核心逻辑**：  
- `f[c]` 存储 $\binom{ck+d}{d}$ 的预计算值  
- `g` 数组通过Min25筛预处理质数分布  
- DFS递归时动态维护当前质因数组合的乘积 `dp`

5. **同类型题推荐**  
- P4213 【模板】Min_25筛  
- P5495 Dirichlet 前缀和  
- P5325 积性函数求和

6. **可视化方案**  
**像素动画设计**：  
- **Canvas网格**：每个格子表示一个质数范围，颜色深浅表示该区间质数密度  
- **音效触发**：  
  - 发现新质数时播放 "NES-coin" 音效  
  - 递归深入时音调逐渐升高  
- **自动演示模式**：  
  1. 红框扫描预处理阶段展示筛法过程  
  2. 绿色光标逐步展开DFS搜索树  
  3. 右侧面板实时显示当前累加值  

7. **个人心得摘录**  
> "处理大质数时需要将 $\sqrt n$ 作为分界点，最大质因子超过 $\sqrt n$ 的情况必然只出现一次。这个观察将时间复杂度从指数级降到了可接受范围。" —— 通过分治策略巧妙平衡质数规模

---

**完整代码实现**  
（基于题解作者的代码，添加关键注释）

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5,MOD=1e9+7,MAXV=3.2e6+5;

ll fac[MAXV],ifac[MAXV]; // 预计算阶乘与逆元
ll ksm(ll a,ll b=MOD-2) { /* 快速幂 */ }

ll C(int x,int y) { // 组合数计算
    if(x<0||y<0||y>x) return 0;
    return fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;
}

int n,K,D,B; // B=sqrt(n)
int val[MAXN],g[MAXN]; // Min25筛相关数组

void solve() {
    scanf("%d%d%d",&n,&K,&D);
    B=sqrt(n);
    // Min25筛预处理质数个数
    for(int i=1;i<=m;++i) g[i]=val[i]-1; 
    for(int k=1;k<=tot;++k) {
        for(int i=1;i<=m&&1ll*p[k]*p[k]<=val[i];++i) {
            g[i] -= g[idx(val[i]/p[k])] - (k-1);
        }
    }
    // 计算组合数表
    for(int i=1;i<=30;++i) 
        f[i]=C(K*i+D,D);
    // 深度优先搜索
    ans=1;
    dfs(0,n,1); 
    printf("%lld\n",ans);
}

int main() {
    // 预处理阶乘
    for(int i=fac[0]=1;i<MAXV;++i) fac[i]=fac[i-1]*i%MOD;
    ifac[MAXV-1]=ksm(fac[MAXV-1]);
    for(int i=MAXV-1;i;--i) ifac[i-1]=ifac[i]*i%MOD;
    // 处理多组数据
    int _; scanf("%d",&_);
    while(_--) solve();
    return 0;
}
```

---
处理用时：76.38秒
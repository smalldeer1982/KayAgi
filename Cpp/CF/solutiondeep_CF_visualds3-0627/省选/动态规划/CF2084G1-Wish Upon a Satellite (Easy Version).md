# 题目信息

# Wish Upon a Satellite (Easy Version)

## 题目描述

这是该问题的简单版本。与困难版本的区别在于，本版本中 $t \le 1000$、$n \le 5000$ 且所有测试用例的 $n$ 之和不超过 $5000$。只有当你解决了该问题的所有版本时才能进行 hack。

对于一个长度为 $k$ 的非空序列 $c$，定义 $f(c)$ 如下：

- Turtle 和 Piggy 正在一个序列上玩游戏。他们被给定序列 $c_1, c_2, \ldots, c_k$，由 Turtle 先手。Turtle 和 Piggy 轮流进行操作（Turtle 第一步，Piggy 第二步，Turtle 第三步，依此类推）。
- 游戏规则如下：
  - 设当前序列长度为 $m$。如果 $m = 1$，游戏结束。
  - 如果游戏未结束且轮到 Turtle，Turtle 必须选择一个整数 $i$（$1 \le i \le m - 1$），将 $c_i$ 设为 $\min(c_i, c_{i + 1})$，并删除 $c_{i + 1}$。
  - 如果游戏未结束且轮到 Piggy，Piggy 必须选择一个整数 $i$（$1 \le i \le m - 1$），将 $c_i$ 设为 $\max(c_i, c_{i + 1})$，并删除 $c_{i + 1}$。
- Turtle 希望最终 $c_1$ 的值最大化，而 Piggy 希望最终 $c_1$ 的值最小化。
- $f(c)$ 表示双方都采取最优策略时，最终 $c_1$ 的值。

对于一个长度为 $n$ 的排列 $p$ $^{\text{∗}}$，Turtle 定义该排列的美观度为 $\sum\limits_{i = 1}^n \sum\limits_{j = i}^n f([p_i, p_{i + 1}, \ldots, p_j])$（即所有 $p$ 的非空子段 $^{\text{†}}$ $c$ 的 $f(c)$ 之和）。

Piggy 给 Turtle 一个长度为 $n$ 的排列 $a$，其中部分元素缺失（用 $0$ 表示）。

Turtle 请你确定一个排列 $b$，满足以下条件：

- $b$ 可以通过填充 $a$ 中缺失的元素得到（即对于所有 $1 \le i \le n$，如果 $a_i \ne 0$，则 $b_i = a_i$）。
- 排列 $b$ 的美观度最大化。

为了方便，你只需要找到这样的排列 $b$ 的最大美观度。

$^{\text{∗}}$ 长度为 $n$ 的排列是指由 $1$ 到 $n$ 的 $n$ 个不同整数按任意顺序组成的数组。例如，$[2,3,1,5,4]$ 是一个排列，但 $[1,2,2]$ 不是排列（因为 $2$ 在数组中出现了两次），$[1,3,4]$ 也不是排列（因为 $n=3$ 但数组中包含 $4$）。

$^{\text{†}}$ 序列 $a$ 是序列 $b$ 的子段，当且仅当 $a$ 可以通过从 $b$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 说明/提示

- 在第一个测试用例中，美观度最大的排列 $b$ 是 $[1, 2]$。$[1, 2]$ 的美观度为 $4$，因为 $f([1]) + f([2]) + f([1, 2]) = 1 + 2 + 1 = 4$。如果 $c = [1, 2]$，则 $f(c) = 1$，因为 Turtle 只能选择 $i = 1$，并将 $c_1$ 设为 $\min(c_1, c_2) = 1$。

- 在第二个测试用例中，美观度最大的排列之一是 $[3, 2, 1]$。$[3, 2, 1]$ 的美观度为 $12$，因为 $f([3]) + f([2]) + f([1]) + f([3, 2]) + f([2, 1]) + f([3, 2, 1]) = 3 + 2 + 1 + 2 + 1 + 3 = 12$。

- 在第三个测试用例中，美观度最大的排列之一是 $[2, 1, 3]$。

- 在第四个测试用例中，如果 $c = [3, 2, 4, 5, 1]$，则 $f(c) = 3$。一种可能的游戏过程如下：
  - Turtle 选择 $i = 3$，将 $c_3$ 设为 $\min(c_3, c_4) = 4$ 并删除 $c_4$。序列变为 $[3, 2, 4, 1]$。
  - Piggy 选择 $i = 1$，将 $c_1$ 设为 $\max(c_1, c_2) = 3$ 并删除 $c_2$。序列变为 $[3, 4, 1]$。
  - Turtle 选择 $i = 2$，将 $c_2$ 设为 $\min(c_2, c_3) = 1$ 并删除 $c_3$。序列变为 $[3, 1]$。
  - Piggy 选择 $i = 1$，将 $c_1$ 设为 $\max(c_1, c_2) = 3$ 并删除 $c_2$。序列变为 $[3]$。
  - 序列长度为 $1$，游戏结束。最终 $c_1$ 的值为 $3$。

- 在第五个测试用例中，美观度最大的排列之一是 $[1, 3, 2, 5, 6, 4, 7]$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
8
2
1 0
3
0 0 0
3
0 1 0
5
3 2 4 5 1
7
0 3 2 5 0 0 0
10
1 2 6 5 8 9 0 0 0 0
5
0 4 1 0 0
5
0 1 5 2 3```

### 输出

```
4
12
11
44
110
300
45
40```

# AI分析结果



---

### **算法分类**
动态规划

---

### **题解思路与算法分析**

#### **核心思路**
题目要求最大化排列的美观度，美观度计算涉及所有子段的最优博弈结果。通过观察，每个子段的博弈结果仅取决于首尾元素的奇偶位置，进而将问题转化为最小化奇偶位置差异的绝对值和。

#### **关键步骤**
1. **问题转换**：美观度总和等于所有元素平方和减去奇偶位置差异的绝对值和。
2. **动态规划建模**：定义状态 `f[i][j]` 表示处理前 `i` 个元素，已有 `j` 个奇位置时的最小差异和。
3. **状态转移**：根据当前元素的奇偶约束（已固定或自由选择），更新下一状态并累加分界贡献。

#### **难点突破**
- **数学推导**：通过博弈论分析得出子段结果的奇偶性规律，避免直接模拟博弈过程。
- **状态压缩**：仅维护奇位置数量，利用奇偶分界贡献的数学性质，避免维护具体数值差异。

---

### **最优思路提炼**
1. **奇偶贡献拆分**：将美观度计算转换为奇偶位置对的差异和。
2. **贪心排序优化**：将数值按大小排序后分配，最小化跨奇偶的差异。
3. **动态规划状态转移**：以奇位置数量为状态，分步累加分界点贡献。

---

### **代码核心逻辑**

```cpp
vector< vector<ll> > f(n + 1, vector<ll>(n + 1, 1e18));
// 初始化：第一个元素可黑可白（若未固定）
if (a[1] != 1) f[1][0] = 0;
if (a[1] != 0) f[1][1] = 0;

for (int i = 1; i < n; ++i) {
    for (int j = 0; j <= i; ++j) {
        // 累加分界点k=i的贡献
        f[i][j] += j * (n / 2 - (i - j)) + (i - j) * ((n + 1) / 2 - j);
        // 转移到i+1的状态
        if (可分配为白点) f[i+1][j] = min(f[i+1][j], f[i][j]);
        if (可分配为黑点) f[i+1][j+1] = min(f[i+1][j+1], f[i][j]);
    }
}
```

---

### **可视化设计**

#### **动态规划状态转移动画**
- **网格视图**：将 `f[i][j]` 显示为二维网格，每个单元格表示状态值，颜色深浅表示代价大小。
- **步进演示**：高亮当前处理的 `i` 和转移路径，实时显示分界贡献的计算。
- **颜色标记**：红色箭头表示黑点转移，蓝色箭头表示白点转移，灰色表示不可行状态。

#### **复古像素效果**
- **8-bit 风格**：使用 16 色调色板，网格边框为深灰色，状态值以绿色（低代价）到红色（高代价）渐变。
- **音效反馈**：转移时播放“滴”声，最终解播放胜利音效。

---

### **相似题目推荐**
1. **CF1398D**：颜色分组最小化差异和。
2. **LeetCode 1478**：动态规划分配资源最小化距离。
3. **洛谷 P1439**：排列变换中的最长公共子序列优化。

---

### **结论**
该题通过巧妙的博弈分析与动态规划建模，将复杂博弈结果转换为奇偶位置差异优化，最终以 `O(n²)` 复杂度高效求解，展示了博弈论与动态规划的深度结合。

---
处理用时：224.82秒
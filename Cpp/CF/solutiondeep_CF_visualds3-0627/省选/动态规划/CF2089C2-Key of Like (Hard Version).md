# 题目信息

# Key of Like (Hard Version)

## 题目描述

这是该问题的困难版本。两个版本之间的区别在于，在这个版本中 $$$k$$$ 可以是非零值。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此策略永远是选择任何未被尝试过的钥匙。由于总共有 $$$1 + 4 = 5$$$ 把钥匙，每位成员成功打开锁的概率（即期望成功次数）分别为 $$$2/5$$$、$$$2/5$$$、$$$1/5$$$。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 4
3 2 0
25 2 5
4 102 9```

### 输出

```
800000006 800000006 400000003
500000004 1 500000004
142857144 166666668 615646263 639455787 234126986 257936510 195918369 502040820 478316330 81264173 190523433 471438023 23809524 0 0 0 0 0 0 0 0 0 0 0 0
568832210 85779764 969938175 375449967```

# AI分析结果



**算法分类**  
动态规划（DP）

---

**题解思路与解决难点**  
- **核心思路**：将问题分解为子问题，每次操作可能成功开锁（减少锁数）或识别假钥匙（减少假钥匙数）。通过动态规划递推各状态下的期望值，利用模运算处理轮次循环，前缀和优化加速转移。  
- **关键变量**：状态 `dp[l][k][i]` 表示剩余 `l` 个锁、`k` 个假钥匙时，第 `i` 个人的期望成功次数。  
- **转移逻辑**：  
  1. **成功开锁**：概率为 `1/(l+k)`，转移至 `l-1` 锁的同余轮次。  
  2. **失败处理**：  
     - 选择锁时，转移至 `l-1` 锁的同余轮次。  
     - 选择假钥匙时，转移至 `k-1` 假钥匙的同余轮次。  
- **难点解决**：通过前缀和优化计算累加贡献，避免重复计算子问题。

---

**题解评分**  
1. **UniGravity (4星)**  
   - 推导严谨，状态转移清晰，前缀和优化高效。  
   - 代码维护 `s1` 和 `s2` 分别处理两种转移路径。  
2. **MatrixGroup (4星)**  
   - 数学简化得出概率统一性，代码更简洁。  
   - 使用通用前缀和数组 `s` 加速计算。  

---

**最优思路提炼**  
- **状态压缩**：利用模运算处理循环轮次，避免重复计算。  
- **前缀和优化**：将累加操作转化为前缀和差，时间复杂度降至 \(O(nlk)\)。  
- **概率均等性**：每一步的最优选择保证后续成功概率一致，简化转移方程。

---

**同类型题推荐**  
1. [P1654 期望分数](https://www.luogu.com.cn/problem/P1654)  
2. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)  
3. [CF235B Let's Play Osu!](https://codeforces.com/problemset/problem/235/B)

---

**代码核心实现**  
```cpp
// 核心转移逻辑（UniGravity题解）
for (int a = 1; a <= l; a++) {
    for (int b = 0; b <= k; b++) {
        int s1 = 0, s2 = 0;
        // 维护前缀和 s1, s2
        for (int i = 0; i < n; i++) {
            // 累加贡献并取模
            addto(f[a][b][i], 1ll * v1 * s1 % P);
            addto(f[a][b][i], 1ll * v2 * s2 % P);
            // 更新前缀和
            addto(s1, f[a-1][b][i]);
            addto(s2, f[a-1][b][i]);
        }
    }
}
```

---

**可视化设计**  
- **动态表格**：以网格显示 `dp[l][k][i]`，高亮当前处理状态。  
- **颜色区分**：成功转移（绿色箭头）、假钥匙转移（红色箭头）。  
- **复古像素风格**：使用 8-bit 色块表示状态变化，音效提示状态更新。  
- **交互控制**：步进执行观察转移路径，速度调节理解复杂逻辑。

---

**总结**  
通过动态规划建模概率转移，结合数学推导与优化技巧，高效求解复杂期望问题。

---
处理用时：65.27秒
# 题目信息

# GCD Counting

## 题目描述

You are given a tree consisting of $ n $ vertices. A number is written on each vertex; the number on vertex $ i $ is equal to $ a_i $ .

Let's denote the function $ g(x, y) $ as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex $ x $ to vertex $ y $ (including these two vertices).

For every integer from $ 1 $ to $ 2 \cdot 10^5 $ you have to count the number of pairs $ (x, y) $ $ (1 \le x \le y \le n) $ such that $ g(x, y) $ is equal to this number.

## 样例 #1

### 输入

```
3
1 2 3
1 2
2 3
```

### 输出

```
1 4
2 1
3 1
```

## 样例 #2

### 输入

```
6
1 2 4 8 16 32
1 6
6 3
3 4
4 2
6 5
```

### 输出

```
1 6
2 5
4 6
8 1
16 2
32 1
```

## 样例 #3

### 输入

```
4
9 16 144 6
1 3
2 3
4 3
```

### 输出

```
1 1
2 1
3 1
6 2
9 2
16 2
144 1
```

# AI分析结果



---

## 算法分类  
**数学（因数分解、容斥原理） + 并查集**

---

## 题解思路、算法要点与解决难点  

### 核心思路  
1. **因数分解预处理**：每个节点的权值分解为所有因数，为每个因数 k 维护其对应的节点集合。  
2. **并查集处理连通块**：对每个因数 k，仅保留权值为 k 倍数的节点及边，用并查集统计连通块大小。  
3. **容斥计算最终结果**：按从大到小顺序，用 f(k) = 当前倍数贡献 - ∑f(k的倍数) 得到恰好为 k 的路径数。

### 解决难点  
- **路径 GCD 的直接计算困难**：通过因数分解转化为倍数问题，避免遍历所有路径。  
- **高效处理多个因数**：每个节点权值分解因数，将问题拆解到每个因数上，利用并查集快速合并。  
- **避免重复计数**：逆序容斥确保每个 k 的贡献仅计算一次，消除大因数的重复贡献。

### 关键步骤  
- **预处理每个节点的所有因数**：O(n√A)，A 是权值最大值。  
- **遍历每个因数 k**：筛选出权值为 k 倍数的节点，构建子图。  
- **并查集合并连通块**：计算每个连通块的路径数贡献。  
- **逆序容斥**：从大至小减去倍数贡献，得到最终答案。

---

## 题解评分 (≥4星)  

### intel_core（5星）  
- **亮点**：代码简洁高效，利用并查集快速合并，预处理因数优化性能。  
- **关键代码**：通过两次遍历因数快速构建节点集合，容斥逻辑清晰。

### Acoipp（4星）  
- **亮点**：预处理边的 GCD 减少无效合并，优化了并查集的使用次数。  
- **注意点**：代码中 ans 数组初始化需处理单点贡献。

### Hisaishi_Kanade（4星）  
- **亮点**：利用父节点唯一性，按深度排序优化连通块统计，减少排序开销。  
- **技巧**：深度排序确保父节点先处理，直接累加子树大小。

---

## 最优思路或技巧提炼  

### 核心技巧  
1. **因数分解预处理**：将权值拆解为因数集合，快速定位每个 k 的处理范围。  
2. **并查集快速合并**：仅处理有效节点，动态维护连通块大小，O(α(n)) 时间合并。  
3. **逆序容斥**：从最大值向下遍历，确保每个 k 的贡献仅计算一次。

### 代码实现片段  
```cpp
// 预处理因数并初始化并查集
for (int i=1; i<=n; i++) {
    for (int j=1; j*j<=a[i]; j++) {
        if (a[i]%j == 0) {
            v[j].push_back(i);
            if (j != a[i]/j) v[a[i]/j].push_back(i);
        }
    }
}

// 处理每个因数 k 的贡献
for (int k=1; k<=2e5; k++) {
    for (int node : v[k]) {
        for (int neighbor : g[node]) {
            if (存在边且 neighbor 是 k 的倍数) 合并(node, neighbor);
        }
    }
    // 统计连通块贡献到 f[k]
}

// 逆序容斥计算最终答案
for (int k=2e5; k>=1; k--) {
    for (int multiple = 2*k; multiple <= 2e5; multiple +=k) {
        f[k] -= f[multiple];
    }
}
```

---

## 类似题目推荐  
1. **洛谷 P1390**：公约数的和（因数分解 + 容斥）  
2. **洛谷 P2158**：[SDOI2008] 仪仗队（欧拉函数 + 因数贡献）  
3. **洛谷 P2303**：Longge的问题（因数分解 + 贡献统计）

---

## 可视化与算法演示  

### 动画设计  
1. **树结构展示**：用节点颜色区分当前处理的因数 k 的倍数节点。  
2. **并查集合并过程**：高亮正在合并的节点，动态显示连通块大小变化。  
3. **容斥过程**：用颜色渐变表示不同倍数 k 的贡献被减去的过程。

### 复古像素风格实现  
- **颜色方案**：8位色，红色表示当前处理的 k，绿色表示已处理。  
- **音效**：合并时播放“哔”声，容斥时播放“叮”声，错误时低沉音效。  
- **Canvas 绘制**：网格布局树节点，每次合并时像素块合并动画。

---

## 总结  
通过因数分解将路径 GCD 问题转化为连通块贡献，结合并查集与容斥原理高效求解。关键优化在于预处理和逆序处理，避免重复计算。

---
处理用时：71.62秒
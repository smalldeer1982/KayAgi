# 题目信息

# The Destruction of the Universe (Easy Version)

## 题目描述

这是问题的简单版本，满足 $ n \leq 5000 $。如果两个版本的问题都被解决，才可以进行挑战。

猩猩是强大的生物，它们只需要 $1$ 个单位时间就能摧毁宇宙中每一个脆弱的星球！

宇宙中有 $n$ 个星球。每个星球在一个区间 $[l, r]$ 内是脆弱的，期间随时可能被猩猩摧毁。猩猩可以把任意一个星球的脆弱区间扩展 $1$ 个单位。

具体来说，如果对某个星球 $p$ 的脆弱区间 $[l_p, r_p]$ 进行扩展，结果可以是 $[l_p - 1, r_p]$ 或 $[l_p, r_p + 1]$ 中的任一个。

给定一组星球，如果它们的所有脆弱区间中至少有一个共同点，那么这组星球就能被摧毁。我们把这样一组星球的“得分”定义为实现摧毁所需的最小扩展次数。

猩猩关注的是宇宙中所有非空星球子集的得分之和。由于可能结果非常大，请输出答案对 $998\,244\,353$ 取模后的结果。

## 说明/提示

以第一个测试用例为例，需考虑以下七个非空子集：

- 对于子集 $\{[1,1]\}, \{[2,3]\}, \{[3,3]\}$，得分为 $0$。
- 对于子集 $\{[2,3], [3,3]\}$，得分为 $0$，因为点 $3$ 已经位于这两个星球的脆弱区间之内。
- 对于子集 $\{[1,1], [2,3]\}$，得分为 $1$。通过一次操作，将第二个星球的脆弱区间改为 $[1,3]$，这样两个星球的脆弱区间都包含点 $1$。
- 对于子集 $\{[1,1], [3,3]\}$，得分为 $2$。通过两次操作，将第一个星球的脆弱区间改为 $[1,3]$，使得两个星球的区间都包含点 $3$。
- 对于子集 $\{[1,1], [2,3], [3,3]\}$，得分为 $2$。通过一次操作把第一个星球的区间改为 $[1,2]$，再用一次操作把第三个星球的区间改为 $[2,3]$，这样三个星球都包含点 $2$。

所以，第一个测试用例中，所有非空子集的得分之和为 $0 \times 4 + 1 \times 1 + 2 \times 2 = 5$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3
1 1
2 3
3 3
4
1 4
2 3
2 4
1 1
5
1 2
2 3
3 4
4 5
1 5```

### 输出

```
5
6
24```

# AI分析结果



## 算法分类
**组合数学**

---

## 综合分析与结论

### 核心思路
题解的核心在于将问题拆解为所有可能区间对的独立贡献，并利用组合数学技巧高效计算：
1. **关键观察**：对于任意子集，若其包含的最大左端点 $L$ 和最小右端点 $R$ 满足 $L \leq R$，得分为 $0$；否则得分是 $L-R$ 加上其他区间的调整代价。
2. **贡献拆分**：枚举所有可能的区间对 $(i,j)$，若 $r_i < l_j$，则这对区间的贡献为 $(l_j - r_i) \times$ 包含它们的特定子集数量。
3. **组合数学优化**：通过范德蒙德卷积公式 $\sum_{k} \binom{x}{k} \binom{y}{k} = \binom{x+y}{x}$ 将双重求和简化为单组合数，复杂度从 $O(n^3)$ 降为 $O(n^2)$。

### 解决难点
- **如何高效枚举贡献**：将全局贡献拆分为每个区间对的独立贡献，避免遍历所有子集。
- **组合数计算的优化**：通过预处理组合数和范德蒙德恒等式避免重复计算。

### 可视化设计思路
- **像素动画**：在 Canvas 中绘制区间对 $(i,j)$，高亮其 $l_j$ 和 $r_i$ 的差值。
- **动态公式推导**：分步显示范德蒙德卷积的合并过程，用不同颜色标记 $\binom{x}{k}$ 和 $\binom{y}{k}$。
- **音效反馈**：每次完成一个区间对的计算时播放“滴答”音效，最终求和时播放胜利音效。

---

## 题解评分（4.5⭐）

### happybob 题解亮点
- **复杂度优化**：利用组合恒等式将复杂度优化至 $O(n^2)$。
- **数学推导清晰**：通过归纳法证明贪心策略的正确性。
- **代码简洁**：预处理组合数与幂数，核心循环仅需枚举区间对。

---

## 关键代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
const int N = 5005;

int C[N][N], pow2[N];
void init() {
    for (int i = 0; i < N; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
    }
    pow2[0] = 1;
    for (int i = 1; i < N; i++)
        pow2[i] = pow2[i-1] * 2 % MOD;
}

int main() {
    init();
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<pair<int, int>> v(n);
        for (auto &[l, r] : v) cin >> l >> r;
        
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (v[i].second >= v[j].first) continue;
                int l = v[j].first, r = v[i].second;
                int x = 0, y = 0;
                for (auto [a, b] : v) {
                    x += (a > l);
                    y += (b < r);
                }
                int coef = C[x + y][x];
                coef = 1LL * coef * pow2[n - x - y - 2] % MOD;
                ans = (ans + 1LL * (l - r) * coef) % MOD;
            }
        }
        cout << ans << '\n';
    }
}
```

---

## 同类型题推荐
1. **CF1396C - Monster Invaders**（组合贡献拆分）
2. **Luogu P3773 - 计数组合**（范德蒙德卷积应用）
3. **AtCoder ABC202F - Integer Convex Hull**（区间交集与组合数学）

---

## 可视化与游戏化设计
- **像素动画**：用不同颜色方块表示每个区间，滑动展开操作模拟区间扩展。
- **自动推导模式**：AI 自动枚举区间对，高亮当前计算的 $(i,j)$ 和对应的 $x,y$。
- **音效设计**：组合数计算完成时播放 8-bit 上升音阶，错误时播放低音警报。

---

## 个人心得
- **预处理的重要性**：提前计算组合数和幂次显著提升效率。
- **逆向思维**：将整体贡献拆解为区间对贡献，避免指数级枚举子集。

---
处理用时：56.31秒
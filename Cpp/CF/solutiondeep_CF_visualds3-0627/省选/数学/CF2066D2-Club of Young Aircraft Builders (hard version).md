# 题目信息

# Club of Young Aircraft Builders (hard version)

## 题目描述

这是该问题的困难版本。各版本间的区别在于此版本中不要求所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每架飞机的发射者所在楼层。遗憾的是，关于部分飞机的具体发射者信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
8
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0
6 1 3
2 0 0
2 3 5
0 0 1 0 2
3 3 4
3 3 3 0
2 1 2
0 1
2 1 2
0 2
5 3 12
0 0 1 0 2 4 0 0 0 5 0 5```

### 输出

```
6
190
3
2
0
0
1
14```

# AI分析结果



**唯一算法分类**：动态规划（DP）与组合数学

---

### **综合分析与结论**

#### **核心思路**
题目要求填补缺失的飞机发射楼层序列，使得每个居民的视角下至少发射了 $c$ 架飞机。核心难点在于**动态建模每个楼层的发射位置限制**，尤其是已确定值的固定位置必须满足约束条件。

**关键算法流程**：
1. **动态规划状态设计**：`dp[i][j]` 表示处理到楼层 $i$ 时，已使用 $j$ 个空位（未知位置）的方案数。
2. **组合数预处理**：利用组合数快速计算填充未知位置的方案数。
3. **转移逻辑**：从高楼层（如 $n$）向低楼层（如 $1$）处理，枚举当前楼层填充的飞机数，确保所有已确定的固定位置满足约束。
4. **固定位置校验**：检查已确定的数值是否在其允许的最大位置范围内。

#### **可视化设计要点**
- **动态规划状态表**：以网格形式展示 `dp[i][j]`，高亮当前处理的楼层和已使用的空位数。
- **组合数计算演示**：在填充空位时，显示可选的组合数公式（如 $\binom{p_3}{p_1-p_2}$）。
- **复古像素风格**：
  - **颜色标记**：用不同颜色区分已处理楼层（绿色）、当前处理楼层（黄色）、非法状态（红色）。
  - **音效触发**：填充成功时播放短促音效，非法填充时播放“失败”音效。
  - **自动演示模式**：按楼层顺序逐步推进，展示每个状态的更新和组合数的选择。

---

### **题解清单 (≥4星)**

1. **ForgotMe 题解（4星）**
   - **亮点**：从大到小处理楼层的思路清晰，状态转移设计简洁。
   - **代码实现**：利用组合数预处理优化计算，逻辑紧凑。

2. **lfxxx 题解（4星）**
   - **亮点**：详细处理了固定位置的校验，代码完整且注释明确。
   - **个人心得**：通过独立推导发现固定位置的后缀约束是关键。

---

### **代码核心逻辑**

#### **预处理组合数**
```cpp
void init() {
    C[0][0] = 1;
    for (int i = 1; i < maxn; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
    }
    // 前缀和预处理...
}
```

#### **动态规划转移**
```cpp
for (int i = n-1; i >= 1; i--) {
    for (int j = 0; j <= M; j++) {
        int lim = -1;
        // 计算当前楼层允许的最大空位填充数
        for (int k = c; k >= 1; k--) {
            while (lim+1 <= j && ...) lim++;
            if (lim != -1 && j+k <= M)
                g[j+k] = (g[j+k] + dp[j] * f[lim][k-1]) % mod;
        }
    }
    // 更新状态并校验固定位置
    if (mx[i] != 0) {
        for (int j = 0; j <= M; j++) {
            int lim = pre[mx[i]];
            if (条件不满足) dp[j] = 0;
        }
    }
}
```

---

### **最优思路提炼**
- **逆向处理楼层**：从高到低填充，避免低楼层影响高楼层的约束。
- **组合数优化**：预处理组合数表加速状态转移。
- **固定位置校验**：确保已确定的数值在其允许的最大位置范围内。

---

### **类似题目推荐**
1. **洛谷 P1654**：计数问题，需处理前缀约束。
2. **LeetCode 62. 不同路径**：动态规划与组合数结合。
3. **洛谷 P2602**：数字计数，涉及数位DP与组合分析。

---

### **复古游戏化动画设计**
- **像素网格**：每行代表一个楼层，每列为空位填充状态。
- **音效设计**：
  - **填充成功**：短促“哔”声。
  - **非法操作**：低音“嗡”声。
- **自动演示**：按楼层顺序自动填充，用户可调节速度观察状态转移。

---
处理用时：64.84秒
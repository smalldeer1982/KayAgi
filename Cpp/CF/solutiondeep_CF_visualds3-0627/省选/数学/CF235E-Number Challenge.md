# 题目信息

# Number Challenge

## 题目描述

Let's denote $ d(n) $ as the number of divisors of a positive integer $ n $ . You are given three integers $ a $ , $ b $ and $ c $ . Your task is to calculate the following sum:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF235E/6b4d9893ce96bd0459ff1289a8bf3491052ac12a.png)Find the sum modulo $ 1073741824 $ $ (2^{30}) $ .

## 说明/提示

For the first example.

- $ d(1·1·1)=d(1)=1 $ ;
- $ d(1·1·2)=d(2)=2 $ ;
- $ d(1·2·1)=d(2)=2 $ ;
- $ d(1·2·2)=d(4)=3 $ ;
- $ d(2·1·1)=d(2)=2 $ ;
- $ d(2·1·2)=d(4)=3 $ ;
- $ d(2·2·1)=d(4)=3 $ ;
- $ d(2·2·2)=d(8)=4 $ .

So the result is $ 1+2+2+3+2+3+3+4=20 $ .

## 样例 #1

### 输入

```
2 2 2
```

### 输出

```
20
```

## 样例 #2

### 输入

```
4 4 4
```

### 输出

```
328
```

## 样例 #3

### 输入

```
10 10 10
```

### 输出

```
11536
```

# AI分析结果



---

**唯一算法分类**  
数论

---

### **题解思路、算法要点与解决难点**  
- **核心公式**：利用数论公式将三维约数函数转换为互质条件的多重求和：  
  $$d(ijk)=\sum_{x|i}\sum_{y|j}\sum_{z|k}[\gcd(x,y)=1][\gcd(y,z)=1][\gcd(z,x)=1]$$  
  通过莫比乌斯反演简化互质条件，将原问题转化为可高效计算的求和式。

- **预处理优化**：  
  1. **互质条件预处理**：预先计算 $\gcd$ 矩阵，避免重复计算。  
  2. **分块求和**：通过枚举 $x$ 和 $d$，将三维求和分解为多个二维子问题。  
  3. **前缀和优化**：对 $\lfloor\frac{n}{i}\rfloor$ 等项进行差分预处理，减少重复计算。

- **复杂度控制**：  
  - 利用调和级数性质，将复杂度降至 $O(n^2 \log n)$ 或更低。  
  - 剪枝无效的 $\mu(d)=0$ 的项，减少枚举量。

---

### **题解评分**  
1. **2018ljw（★★★★☆）**  
   - **思路清晰**：详细推导公式，并给出关键预处理方法。  
   - **代码可读性**：结构清晰，但变量命名较简略。  
   - **优化程度**：通过差分数组预处理 $g(x,y)$，复杂度合理。  

2. **legendgod（★★★★☆）**  
   - **简洁实现**：直接枚举互质条件，预处理 $\gcd$ 矩阵。  
   - **分块计算**：将求和拆分为独立部分，代码易理解。  
   - **个人心得**：提到「暴力计算」的调试技巧。  

3. **lingying（★★★★☆）**  
   - **公式简化**：通过一步反演减少计算步骤。  
   - **代码简洁**：直接利用 $\mu$ 函数性质和预处理加速。  

---

### **最优思路或技巧提炼**  
1. **互质分解**：将 $d(ijk)$ 分解为互质三元组的求和，结合莫比乌斯函数简化条件。  
2. **分块预处理**：对 $\lfloor\frac{n}{x}\rfloor$ 进行分块处理，降低枚举复杂度。  
3. **$\gcd$ 矩阵缓存**：预处理所有可能的 $\gcd(i,j)$，避免重复计算。  

---

### **同类型题或类似算法套路**  
- **通用套路**：  
  1. **约数函数求和**：通过分解互质条件，结合反演简化计算。  
  2. **分块优化**：利用 $\lfloor\frac{n}{i}\rfloor$ 的重复性，分块计算前缀和。  
  3. **预处理加速**：对 $\mu$、$\gcd$、约数和等常用函数进行预处理。  

---

### **推荐相似题目**  
1. **P3327 [SDOI2015] 约数个数和**  
2. **P4619 [SDOI2018] 旧试题**  
3. **P6788 「EZEC-3」四月樱花**  

---

### **个人心得摘录**  
- **调试技巧**：预处理 $\gcd$ 矩阵时，需注意边界条件（如 $\gcd(0, x)$）。  
- **优化经验**：通过观察 $\mu(d)=0$ 的无效项，显著减少计算量。  

---

### **可视化与算法演示**  
1. **分步动画**：  
   - **步骤1**：显示枚举 $x$ 的过程，高亮当前 $x$（红色）。  
   - **步骤2**：枚举 $d$，显示 $\mu(d)$ 值（绿色表示 $\mu(d)=1$，黄色表示 $\mu(d)=-1$，灰色表示 $\mu(d)=0$）。  
   - **步骤3**：计算 $g(x, \lfloor b/d \rfloor)$ 和 $g(x, \lfloor c/d \rfloor)$，动态显示求和过程。  
   - **步骤4**：累加结果，实时更新总和。  

2. **复古像素风格**：  
   - **Canvas 绘制**：用 8-bit 像素块表示 $x$ 和 $d$ 的枚举进度，背景播放循环芯片音乐。  
   - **音效设计**：  
     - 完成一个 $x$ 的枚举时播放「升级」音效。  
     - 遇到 $\mu(d) \neq 0$ 时触发「金币收集」音效。  

3. **自动演示模式**：  
   - 模拟「AI 解题」：自动按 $x$ 从小到大枚举，并高亮当前计算步骤。  

---

### **核心代码实现**  
```cpp
// 预处理 gcd 矩阵
bool vis[N][N];
for (int i = 1; i <= 2000; ++i)
    for (int j = 1; j <= 2000; ++j)
        vis[i][j] = (gcd(i, j) == 1);

// 计算 g(x, y) = ∑[i<=y] [gcd(x,i)=1] * floor(y/i)
for (int x = 1; x <= 2000; ++x) {
    for (int i = 1; i <= 2000; ++i) {
        if (gcd(x, i) != 1) continue;
        for (int k = i; k <= 2000; k += i)
            g[x][k] += y / i; // y 为动态传入的参数
    }
}

// 主计算逻辑
int ans = 0;
for (int x = 1; x <= a; ++x) {
    for (int d = 1; d <= min(b, c); ++d) {
        if (mu[d] == 0 || gcd(x, d) != 1) continue;
        int g1 = g[x][b / d];
        int g2 = g[x][c / d];
        ans += (a / x) * mu[d] * g1 * g2;
    }
}
ans %= MOD;
```

---

**可视化关键代码（JS 伪代码）**  
```javascript
// 像素动画绘制
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const colors = ['#FF0000', '#00FF00', '#0000FF']; // 红、绿、蓝

function drawStep(x, d, currentSum) {
    ctx.fillStyle = colors[x % 3];
    ctx.fillRect(x * 10, d * 10, 10, 10); // 绘制当前枚举的 (x,d)
    ctx.fillText(`Sum: ${currentSum}`, 10, 20);
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---
处理用时：79.54秒
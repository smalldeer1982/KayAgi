# 题目信息

# Coprime Arrays

## 题目描述

#### 题意：

我们称一个大小为 $n$ 的数组 $a$ 互质，当且仅当 $gcd(a_1,a_2,\cdots,a_n)=1$，$gcd$ 是最大公约数的意思。

给定 $n,k$，对于每个 $i$ $(1\le i\le k)$，你都需要确定这样的数组的个数——长度为 $n$ 的互质数组 $a$ ，满足对每个 $j$ $(1\le j\le n)$，都有 $1\le a_j\le i$。

答案可能非常大，请对 $10^9+7$ 取模。

## 说明/提示

因为互质数组的数量比较多，我们只列出不互质的：

当 $i=1$ 时，唯一的数组就是互质的，$b_1=1$。

当 $i=2$ 时，数组 $[2,2,2]$ 不是互质的，$b_2=7$。

当 $i=3$ 时，数组 $[2,2,2],[3,3,3]$ 不是互质的，$b_3=25$。

当 $i=4$ 时，数组 $[2,2,2],[3,3,3],[2,2,4],[2,4,2],[2,4,4],[4,2,2],[4,2,4],[4,4,2],[4,4,4]$ 不是互质的，$b_4=55$。

Translated by 小粉兔

## 样例 #1

### 输入

```
3 4
```

### 输出

```
82
```

## 样例 #2

### 输入

```
2000000 8
```

### 输出

```
339310063
```

# AI分析结果



## 数论

### 题解思路与算法要点

**核心公式推导**  
问题转化为计算 $b_m = \sum_{d=1}^m \mu(d) \cdot \left\lfloor \frac{m}{d} \right\rfloor^n$。关键优化在于差分处理：

1. **差分数组优化**  
   $\Delta b_m = \sum_{d|m} \mu(d) \cdot \left( x^n - (x-1)^n \right)$，其中 $x = \frac{m}{d}$。仅当 $d \mid m$ 时 $\left\lfloor \frac{m}{d} \right\rfloor$ 改变，避免重复计算。

2. **预处理幂次**  
   预处理 $x^n$ 和 $(x-1)^n$ 的值，将复杂度优化至 $O(k \log k)$。

3. **Dirichlet前缀和优化**  
   通过分解质因数，利用积性函数性质快速计算卷积，复杂度 $O(k \log \log k)$。

**解决难点**  
- **高效处理区间贡献**：通过枚举 $d$ 的倍数，批量更新差分数组。
- **避免重复计算**：利用差分性质，仅处理变化点。

### 题解评分（≥4星）

1. **Elegia（5星）**  
   - 思路清晰，完整推导莫比乌斯变换与差分优化。
   - 代码高效，预处理幂次与差分数组实现简洁。
   - 复杂度 $O(n \log n)$，适合大规模数据。

2. **ZillionX（5星）**  
   - 引入 Dirichlet 前缀和，复杂度优化至 $O(n \log \log n)$。
   - 代码结构紧凑，质因数分解与卷积处理高效。

3. **lahlah（4星）**  
   - 差分思路清晰，强调整除分块优化。
   - 代码可读性强，直接实现差分贡献累加。

### 最优思路提炼

- **差分贡献法**：每个因子 $d$ 仅在 $m$ 的倍数位置贡献差值。
- **预处理幂次**：避免重复计算 $x^n$，直接查表提升效率。
- **Dirichlet卷积优化**：利用积性函数性质分解质因数，减少运算次数。

### 同类型题套路

- **容斥与莫比乌斯函数**：常见于计数问题，如区间互质数对。
- **差分优化**：适用于需要动态维护区间贡献的问题。
- **Dirichlet前缀和**：处理积性函数卷积的高效方法。

### 推荐题目

1. [P2522 [HAOI2011] Problem B](https://www.luogu.com.cn/problem/P2522)  
   **考察点**：二维区间互质计数，莫比乌斯反演。

2. [P2158 [SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158)  
   **考察点**：欧拉函数与坐标互质统计。

3. [P3704 [SDOI2017] 数字表格](https://www.luogu.com.cn/problem/P3704)  
   **考察点**：积性函数与莫比乌斯反演的复杂应用。

---

### 代码实现与核心逻辑

```cpp
// Elegia 题解核心代码
void sieve() {
    mu[1] = 1;
    for (int x = 2; x <= k; ++x) {
        if (!vis[x]) {
            p[++pc] = x;
            mu[x] = -1;
        }
        // 线性筛处理莫比乌斯函数
        for (int j = 1; x * p[j] <= k; ++j) {
            vis[x * p[j]] = true;
            if (x % p[j] == 0) {
                mu[x * p[j]] = 0;
                break;
            } else {
                mu[x * p[j]] = -mu[x];
            }
        }
    }
}

// 预处理幂次并更新差分数组
for (int x = 1; x <= k; ++x) {
    for (int i = 1; i * x <= k; ++i) {
        b[i * x] = (b[i * x] + (ll)pw[i] * (P + mu[x]) % P) % P;
        b[i * x] = (b[i * x] - (ll)pw[i - 1] * (P + mu[x] % P)) % P;
    }
}
```

---

### 可视化设计（复古像素风格）

**动画流程**：  
1. **像素网格**：Canvas 绘制 $k \times k$ 网格，每个格子代表 $d$ 对 $m$ 的贡献。
2. **颜色标记**：  
   - 红色：当前处理的 $d$。  
   - 绿色：$\Delta b_m$ 被更新的位置。  
3. **音效触发**：  
   - 更新差分数组时播放“滴”声，成功累加答案时播放“叮”声。
4. **自动演示**：  
   - 按 $m$ 从 1 到 $k$ 逐步显示贡献累加，底部显示当前 $b_m$ 值。

**代码片段**：  
```javascript
// Canvas 绘制差分更新
function drawUpdate(d, m) {
    ctx.fillStyle = '#FF0000'; // 红色标记当前d
    ctx.fillRect((d-1)*cellSize, (m-1)*cellSize, cellSize, cellSize);
    setTimeout(() => {
        ctx.fillStyle = '#00FF00'; // 绿色标记贡献位置
        ctx.fillRect((m-1)*cellSize, (d-1)*cellSize, cellSize, cellSize);
        playSound('beep'); // 触发音效
    }, 500);
}
```

---
处理用时：61.50秒
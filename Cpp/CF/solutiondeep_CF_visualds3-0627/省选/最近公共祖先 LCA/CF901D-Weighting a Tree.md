# 题目信息

# Weighting a Tree

## 题目描述

给你一个有 $n$ 个顶点与 $m$ 条边的无向图，那些顶点的编号依次为 $1$ 到 $n$。

再给你 $n$ 个整数 $C_1,C_2,\dots,C_n$，每一个数都在区间 $[-n,n]$ 之间。保证 $C_v$ 的奇偶性与顶点 $v$ 的度的奇偶性相同。一个顶点的的度是指连接到它的边数。

你需要按照下列的要求为所有边写上一个在 $[-2n^2,2n^2]$ 之间的一个重量：对于任何一个顶点 $v$，所有连接到这个顶点的边的重量和等于 $C_v$。或者，确定这是不可能达到的。

## 样例 #1

### 输入

```
3 3
2 2 2
1 2
2 3
1 3
```

### 输出

```
YES
1
1
1
```

## 样例 #2

### 输入

```
4 3
-1 0 2 1
1 2
2 3
3 4
```

### 输出

```
YES
-1
1
1
```

## 样例 #3

### 输入

```
6 6
3 5 5 5 1 5
1 4
3 2
4 3
4 5
3 5
5 6
```

### 输出

```
YES
3
5
3
-1
-3
5
```

## 样例 #4

### 输入

```
4 4
4 4 2 4
1 2
2 3
3 4
4 1
```

### 输出

```
NO```

# AI分析结果



**唯一算法分类**：生成树构造与奇偶环处理

---

### **综合分析与结论**

#### **核心思路**
1. **生成树构造**：通过生成树将问题分解为树边与非树边处理。树边通过自底向上递归调整，非树边通过奇环特性调整根节点权值。
2. **奇偶环判断**：非树边与树边构成的环若是奇环，则能调整根权值；偶环无影响。
3. **权值调整**：奇环边的权值修正会以±2倍影响根节点，确保最终根权值为0。

#### **难点与解决**
- **生成树选择**：DFS或并查集生成树，优先处理树边权值。
- **奇环检测**：通过黑白染色或LCA计算路径奇偶性。
- **权值范围保障**：初始树边权值绝对值不超过n²，奇环调整后不超出2n²。

#### **可视化设计**
1. **动画流程**：
   - **步骤1**：展示生成树构建，树边标记为绿色，非树边为灰色。
   - **步骤2**：自底向上分配边权，叶子节点边权高亮为黄色，父节点边权随子节点变化。
   - **步骤3**：根节点权值不为0时，遍历非树边，奇环边闪烁红色，调整权值后根节点归零。
2. **交互元素**：
   - **像素风格**：顶点以8位像素方块表示，树边为绿色线条，奇环边为红色闪烁。
   - **音效**：调整成功时播放上升音阶，失败时短促“哔”声。
   - **步进控制**：支持暂停/继续，手动触发奇环调整步骤。

---

### **题解清单 (≥4星)**

1. **ywy_c_asm（5星）**
   - **亮点**：清晰的生成树构建与黑白染色逻辑，代码注释详细，处理奇环的数学推导严谨。
   - **核心代码**：
     ```cpp
     void dfs(int pt, int baba) {
         for (int i = heads[pt]; i; i = memchi[i].nxt) {
             int dest = memchi[i].dest;
             if (dest == baba) continue;
             dfs(dest, pt);
             anss[memchi[i].num] += v[dest]; // 子节点权值累加到边权
             v[pt] -= v[dest]; // 父节点权值调整
         }
     }
     ```

2. **i207M（4.5星）**
   - **亮点**：简洁的LCA计算与权值调整，通过两次DFS修正权值。
   - **关键片段**：
     ```cpp
     if (dep[u] + dep[v] - 2 * dep[lca] + 1) % 2 == 1) {
         int val = root_remaining / 2;
         adjust_tree_edges(u, v, val); // 奇环调整
     }
     ```

3. **鱼跃于渊（4星）**
   - **亮点**：直接通过DFS树差分处理奇环影响，代码精简。
   - **核心逻辑**：
     ```cpp
     for (auto e : cycle_edges) {
         if (is_odd_cycle(e)) {
             e.weight = root_remaining / 2;
             propagate_adjustment(e); // 传播调整到树边
         }
     }
     ```

---

### **最优思路提炼**

1. **生成树优先**：将问题简化为树结构，自底向上递归确定边权。
2. **奇环修正**：仅需一条奇环非树边即可调整根权值，偶环无需处理。
3. **数学保证**：权值调整的绝对值范围严格在题目限制内。

---

### **相似题目推荐**

1. **CF 100551E（生成树与动态连接）**
2. **洛谷 P6175（无向图最小环）**
3. **CF 1184E3（生成树边权构造）**

---

### **个人心得摘录**

> “构造题的核心是找到问题中的不变量。本题中，奇环的存在性直接决定了根权值能否归零。” —— ywy_c_asm

> “两次DFS修正权值的思路来源于调试中发现初始调整方向错误，反向操作即可。” —— i207M

---

### **可视化代码片段（复古像素风格）**

```javascript
// Canvas绘制顶点与边（简化版）
function drawGraph() {
    ctx.fillStyle = '#8B00FF'; // 紫色顶点
    nodes.forEach(node => {
        ctx.fillRect(node.x * 30, node.y * 30, 20, 20);
    });
    edges.forEach(edge => {
        ctx.strokeStyle = edge.isTree ? '#00FF00' : '#808080'; // 树边绿，非树边灰
        ctx.beginPath();
        ctx.moveTo(nodes[edge.u].x * 30 + 10, nodes[edge.u].y * 30 + 10);
        ctx.lineTo(nodes[edge.v].x * 30 + 10, nodes[edge.v].y * 30 + 10);
        ctx.stroke();
    });
}

// 奇环边闪烁动画
function highlightOddCycle(edge) {
    let alpha = 0;
    const animate = () => {
        ctx.strokeStyle = `rgba(255,0,0,${Math.abs(Math.sin(alpha))})`;
        ctx.beginPath();
        // 绘制edge...
        requestAnimationFrame(animate);
        alpha += 0.1;
    };
    animate();
}
```

**交互示例**：点击“调整奇环”按钮触发高亮，播放音效`beep.mp3`，根节点数值归零时显示像素烟花动画。

---
处理用时：71.27秒
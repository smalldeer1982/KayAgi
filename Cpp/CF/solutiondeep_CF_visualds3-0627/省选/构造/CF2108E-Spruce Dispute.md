# 题目信息

# Spruce Dispute

## 题目描述

四月的天气已经相当炎热，Polycarp 决定这是拆除他几年前搭建的云杉树的绝佳时机。当他绕着树走了几个小时，积蓄力量时，他注意到一个有趣的现象：这棵云杉实际上是一棵树$^{\text{∗}}$——而且不是普通的树，它由奇数个顶点 $n$ 组成。更特别的是，$n-1$ 个顶点上挂着圣诞装饰品，这些装饰品恰好涂有 $\frac{n-1}{2}$ 种不同的颜色，每种颜色恰好有两个装饰品。剩下的顶点按照传统，挂着树顶的星星。

经过几天的心理准备，Polycarp 终于开始拆除云杉。他先取下了树顶的星星，并开始拆卸一些树枝，这时他突然想到一个自然的问题：如何移除树的一条边，并重新排列装饰品，使得同色装饰品之间的简单路径长度之和尽可能大？

在这个问题中，移除树的一条边的定义如下：选择一对相邻顶点 $a$ 和 $b$（$a < b$），然后从树中移除顶点 $b$，并将 $b$ 的所有相邻顶点（除了 $a$）直接重新连接到 $a$ 上。

Polycarp 在得到这个问题的答案之前无法继续拆除云杉。然而，检查所有可能的选项会花费他数年时间。鉴于你在竞赛编程方面的经验，他向你求助。但你能解决这个争议吗？

$^{\text{∗}}$ 树是指一个无环的连通图。

## 说明/提示

考虑第一个测试用例。

移除连接顶点 $1$ 和 $2$ 的边。之后，顶点 $2$ 将从树中移除，顶点 $3$ 和 $4$ 将被连接到顶点 $1$。

将顶点 $3$ 和 $4$ 涂为第一种颜色，顶点 $1$ 和 $5$ 涂为第二种颜色。同色装饰品之间的简单路径长度之和为 $2 + 2 = 4$。可以证明，这是可能的最大值。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2108E/60feb47fab29e7103e114ad3b20f5966a35c1290.png)

在第二个和第三个例子中，路径长度之和的最大值分别为 $3$ 和 $9$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
3
5
1 2
2 3
2 4
4 5
5
1 2
1 3
1 4
1 5
7
1 5
5 4
4 3
3 2
2 6
6 7```

### 输出

```
1 2
2 0 1 1 2
1 5
1 1 2 2 0
4 3
1 3 3 0 2 2 1```

# AI分析结果



**算法分类**  
树的重心、贪心算法

---

**题解思路与核心难点**  
1. **重心定位**：所有题解均以树的重心为突破口，利用其子树大小均衡的特性确保最大路径和。  
2. **贡献计算**：删除边后，路径和的减少量为子树大小与深度相关项之和，需最小化此值。  
3. **颜色分配**：通过优先队列合并最大子树，确保同色对分布在最远路径上，最大化每条边的贡献。  

**关键实现步骤**  
- **重心寻找**：通过DFS遍历确定唯一重心（因节点数为奇数）。  
- **贡献分析**：删除边时，计算 `sz_u + (dep_u - 1)`，选择最小值对应的边。  
- **颜色构造**：将子树节点按大小排序，每次取最大两子树配对，剩余节点与重心配对。  

---

**题解评分**  
1. **Unnamed114514（4.5星）**  
   - **亮点**：完整代码实现，动态处理子树合并，优先队列优化。  
   - **不足**：代码结构较复杂，需二次树重构（`G2`数组）。  
2. **_jimmywang_（4星）**  
   - **亮点**：数学推导清晰，贡献减少量公式简洁。  
   - **不足**：未提供完整代码，实现细节需自行补充。  

---

**最优思路提炼**  
1. **重心核心**：路径和最大化的交点为重心，所有颜色对路径必经过重心。  
2. **贪心删边**：选择使子树贡献损失最小的边删除，保留最大总路径和。  
3. **子树配对**：优先合并最大子树节点，确保路径长度最大化。  

---

**同类题目推荐**  
1. CF 685B - Kay and Snowflake（重心性质）  
2. CF 1294F - Three Paths（最长路径构造）  
3. Luogu P1364 医院设置（重心与路径和优化）  

---

**代码核心实现**  
```cpp
// 重心寻找与贡献计算
void dfs(int u, int fa) {
    siz[u] = 1;
    int mx = 0;
    for (int v : G[u]) {
        if (v == fa) continue;
        dfs(v, u);
        siz[u] += siz[v];
        mx = max(mx, siz[v]);
    }
    if (max(n - siz[u], mx) <= n / 2) hv = u;
}

// 颜色分配构造
priority_queue<pair<int, int>> q;
for (auto k : G2[hv]) {
    dfs2(k, k, hv);
    q.emplace(vec[k].size() - 1, k);
}
while (q.size() > 1) {
    auto x = q.top(); q.pop();
    auto y = q.top(); q.pop();
    // 配对最大两子树的节点
    c[vec[x.second][x.first]] = cnt;
    c[vec[y.second][y.first]] = cnt++;
    if (x.first--) q.push(x);
    if (y.first--) q.push(y);
}
// 剩余节点与重心配对
c[hv] = c[vec[q.top().second][0]] = cnt;
```

---

**可视化设计**  
1. **像素动画**：  
   - **颜色块**：子树节点用不同颜色像素块表示，配对时高亮路径。  
   - **重心标记**：红色闪烁方块表示重心，删除边时动态调整子树连接。  
2. **音效交互**：  
   - **配对成功**：8-bit 上升音效。  
   - **删除边**：短促“切割”音效。  
3. **自动演示**：  
   - 按贡献值从小到大自动删除边，展示最优路径和构造过程。  

**交互示例**  
- **步骤1**：展示原树结构，高亮重心。  
- **步骤2**：动态计算每条边的贡献减少量，选择最小值边删除。  
- **步骤3**：以像素动画演示子树合并与颜色配对过程。

---
处理用时：72.94秒
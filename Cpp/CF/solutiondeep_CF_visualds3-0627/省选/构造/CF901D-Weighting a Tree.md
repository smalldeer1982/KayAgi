# 题目信息

# Weighting a Tree

## 题目描述

给你一个有 $n$ 个顶点与 $m$ 条边的无向图，那些顶点的编号依次为 $1$ 到 $n$。

再给你 $n$ 个整数 $C[1],c[2],…,C[n]$，每一个数都在区间 $[-n,n]$ 之间。保证 $C[v]$ 的奇偶性与顶点 $v$ 的度的奇偶性相同。一个顶点的的度是指连接到它的边数。

你需要按照下列的要求为所有边写上一个在 $-2\cdot n^2$ 与 $2\cdot n^2$ 之间的一个重量：对于任何一个顶点 $v$，所有连接到这个顶点的边的重量和等于 $C[v]$。或者，确定这是不可能达到的。

## 样例 #1

### 输入

```
3 3
2 2 2
1 2
2 3
1 3
```

### 输出

```
YES
1
1
1
```

## 样例 #2

### 输入

```
4 3
-1 0 2 1
1 2
2 3
3 4
```

### 输出

```
YES
-1
1
1
```

## 样例 #3

### 输入

```
6 6
3 5 5 5 1 5
1 4
3 2
4 3
4 5
3 5
5 6
```

### 输出

```
YES
3
5
3
-1
-3
5
```

## 样例 #4

### 输入

```
4 4
4 4 2 4
1 2
2 3
3 4
4 1
```

### 输出

```
NO```

# AI分析结果



## 唯一算法分类  
**构造 + 生成树 + 奇环判断**

---

## 综合分析与结论  

### 核心思路与难点  
1. **生成树构造**：  
   - 通过生成树将问题分解为树结构和非树边两部分。在树上通过自底向上的 DFS 推导边权，确保除根节点外所有顶点满足条件。  
   - **关键变量**：`anss[]` 存储边权，`v[]` 记录每个顶点的当前值（逐步减去子节点的贡献）。  

2. **奇环调整**：  
   - 若根节点值不为 0，需找到一条构成奇环的非树边，调整其权值使得根节点归零。  
   - **奇偶判定**：通过黑白染色判断环的奇偶性。若两点颜色相同，则环为奇环，对根节点的影响为 ±2 倍权值调整量。  

3. **边权范围保证**：  
   - 每个顶点的初始值在 [-n, n] 内，生成树处理后的边权绝对值不超过 n²，奇环调整后的总边权不超过 2n²。  

### 可视化设计思路  
- **动画方案**：  
  1. **生成树构造**：高亮当前遍历的边，动态显示 `anss[]` 和 `v[]` 的变化。  
  2. **奇环调整**：  
     - 用红色标记奇环边，展示 `anss[e] += delta` 操作。  
     - 动态显示调整后的根节点值变化过程，用箭头表示影响传递路径。  
- **交互设计**：  
  - **步进控制**：允许单步执行 DFS 和奇环调整过程，观察每一步的顶点/边权变化。  
  - **颜色标记**：绿色表示已满足条件的顶点，红色表示当前调整的非树边。  

---

## 题解清单 (≥4星)  

1. **作者：ywy_c_asm（★★★★☆）**  
   - **亮点**：清晰解释了生成树处理、奇环调整的核心逻辑，代码注释详细。  
   - **个人心得**：通过黑白染色快速判断环的奇偶性，简化了调整逻辑。  

2. **作者：鱼跃于渊（★★★★☆）**  
   - **亮点**：代码简洁，逻辑模块化，通过两次 DFS 完成树边调整。  
   - **关键代码**：`dfs()` 处理树边，`solve()` 处理奇环边。  

3. **作者：i207M（★★★★☆）**  
   - **亮点**：通过并查集实现生成树，利用 LCA 快速判断环的奇偶性。  

---

## 最优思路提炼  

1. **生成树分解**：  
   - 先构造生成树，通过自底向上的 DFS 确定树边权值，确保除根节点外所有顶点满足条件。  

2. **奇环调整法**：  
   - 若根节点不为 0，寻找一条奇环非树边，调整其权值使根节点归零。公式推导：  
     - 根节点当前值为 `v[1]`，调整量为 `v[1]/2`，奇环边的权值变化会以 ±2 倍传递到根节点。  

3. **黑白染色辅助判断**：  
   - 生成树染色后，若两点颜色相同，则其构成的环为奇环，否则为偶环。  

---

## 类似题目推荐  

1. **CF901D Weighting a Tree**（本题原型）  
2. **洛谷 P3520 [POI2011]Meteors**（环影响全局的构造问题）  
3. **洛谷 P6185 [NOI Online #1 提高组] 序列**（奇偶性约束下的构造）  

---

## 核心代码实现  

```cpp
// 生成树 DFS 调整边权（作者：ywy_c_asm）
void dfs(int pt, int baba) {
    for (int i = heads[pt]; i; i = memchi[i].nxt) {
        if (memchi[i].dest == baba) continue;
        dfs(memchi[i].dest, pt);
        anss[memchi[i].num] += v[memchi[i].dest];
        v[pt] -= v[memchi[i].dest];
        v[memchi[i].dest] = 0;
    }
}

// 奇环调整（作者：鱼跃于渊）
for (int i = 1; i <= m; i++) {
    if (istree[i]) continue;
    if (col[ss[i]] == col[ts[i]]) { // 奇环判定
        int val = v[1] / 2;
        anss[i] = val;
        v[ss[i]] -= val;
        v[ts[i]] -= val;
        dfs(1, 0); // 重新调整树边
        break;
    }
}
```

---

## 可视化与游戏化设计  

### 像素风格动画  
- **颜色方案**：树边绿色，奇环边红色，调整中的顶点黄色。  
- **Canvas 绘制**：  
  - 顶点用 8×8 像素方块表示，边用线条连接，当前操作元素闪烁高亮。  
- **音效触发**：  
  - **调整成功**：8-bit 胜利音效（频率上升）。  
  - **无解**：短促低音。  

### 自动演示模式  
- **AI 流程**：  
  1. 自动构建生成树，DFS 推导边权。  
  2. 检测根节点值，若非零则搜索奇环边。  
  3. 展示奇环调整过程，动态更新边权。  

### 关卡与积分  
- **关卡设计**：  
  - 第 1 关：生成树构造。  
  - 第 2 关：奇环边调整。  
- **积分规则**：每正确调整一条边得 10 分，连续成功触发连击奖励。  

---

通过上述设计和实现，学习者可通过交互式动画深入理解生成树与奇环调整的核心逻辑，同时在游戏化过程中提升学习兴趣。

---
处理用时：69.94秒
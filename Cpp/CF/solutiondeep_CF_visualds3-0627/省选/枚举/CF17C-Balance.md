# 题目信息

# Balance

## 题目描述

1. 选择两个相邻字符，将第一个字符替换成第二个。 
2. 选择两个相邻字符，将第二个字符替换成第一个。 这样，通过任意多次的操作，可以得到许多不同的串，为了追求字符的平衡， 我们要求a,b,c三种字符在字符串中出现的次数两两之差都不能大于1。

你的任 务是，统计给定字符串通过任意多次的操作，能够得到的不同的平衡串的个数。

## 样例 #1

### 输入

```
4
abca
```

### 输出

```
7
```

## 样例 #2

### 输入

```
4
abbc
```

### 输出

```
3
```

## 样例 #3

### 输入

```
2
ab
```

### 输出

```
1
```

# AI分析结果



## 算法分类
**动态规划（DP）结合预处理和子序列自动机**

---

## 综合分析与结论
### 核心思路与难点
1. **压缩字符串**：将原字符串中连续相同字符合并为单个字符块，因操作只能扩展相邻字符，不影响最终结果。
2. **子序列自动机与预处理**：预处理 `nxt[i][c]` 表示从位置 `i` 开始下一个字符 `c` 的位置，确保子序列的顺序性。
3. **动态规划状态设计**：`f[i][a][b][c]` 表示处理到第 `i` 个字符块，已生成 `a` 个 `a`、`b` 个 `b`、`c` 个 `c` 的方案数。
4. **状态转移**：通过 `nxt` 数组实现高效转移，避免重复路径，确保每种可能子序列仅计算一次。

### 可视化设计
- **动画方案**：  
  1. 用网格展示原字符串的压缩过程和 `nxt` 数组的预处理结果。  
  2. 动态展示 DP 状态转移，高亮当前处理的字符块和 `a/b/c` 的计数变化。  
  3. 在合法解出现时触发音效，如“成功”音效，并标记答案统计区域。
- **复古像素风格**：  
  - 使用 8-bit 风格颜色（如绿、红、蓝表示 `a/b/c`）。  
  - Canvas 绘制字符块和状态网格，步进式展示 `nxt` 跳跃和 DP 更新。  
- **交互功能**：  
  - 允许调节动画速度或单步执行，观察 `nxt` 跳跃细节。  
  - 显示当前状态转移方程和合法性检查条件。

---

## 题解清单（≥4星）
1. **_fairytale_ (5星)**  
   **亮点**：详细解释压缩字符串和子序列自动机的逻辑，代码结构清晰，注释充分。  
   **代码核心**：预处理 `nxt` 数组，四重循环实现状态转移。

2. **ylxmf2005 (4星)**  
   **亮点**：代码简洁高效，状态转移部分逻辑明确，适合快速理解核心思想。  
   **关键注释**：通过 `nxt` 避免重复计算，转移方程直观。

3. **帅到报警 (4星)**  
   **亮点**：强调预处理的重要性，代码中附加边界处理说明，适合调试参考。  
   **个人心得**：“需要钦定只有第一个字符才能被复制”避免重复计数。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 155, MOD = 51123987;
int n, ans, nxt[N][3], dp[N][52][52][52];
char s[N];

int main() {
    scanf("%d%s", &n, s + 1);
    // 预处理nxt数组
    nxt[n+1][0] = nxt[n+1][1] = nxt[n+1][2] = n + 1;
    for (int i = n; i >= 1; i--) {
        for (int c = 0; c < 3; c++) nxt[i][c] = nxt[i+1][c];
        nxt[i][s[i]-'a'] = i;
    }
    // 初始化DP并转移
    dp[1][0][0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int a = 0; a <= (n+2)/3; a++)
            for (int b = 0; b <= (n+2)/3; b++)
                for (int c = 0; c <= (n+2)/3; c++) {
                    if (a + b + c == n && abs(a-b)<=1 && abs(a-c)<=1 && abs(b-c)<=1)
                        ans = (ans + dp[i][a][b][c]) % MOD;
                    for (int k = 0; k < 3; k++) {
                        int ni = nxt[i][k];
                        if (ni > n) continue;
                        int* ptr = (k == 0) ? &dp[ni][a+1][b][c] :
                                  (k == 1) ? &dp[ni][a][b+1][c] :
                                             &dp[ni][a][b][c+1];
                        *ptr = (*ptr + dp[i][a][b][c]) % MOD;
                    }
                }
    printf("%d\n", ans);
    return 0;
}
```

---

## 类似题目推荐
1. **P2679 [NOIP2015 提高组] 子串**  
   - 动态规划统计子串出现次数，需处理子序列限制。

2. **P2401 不等数列**  
   - 统计排列中符号模式的合法性，类似状态设计。

3. **P1896 [SCOI2005] 互不侵犯**  
   - 状态压缩DP处理多条件限制，与字符计数思想相通。

---
处理用时：63.69秒
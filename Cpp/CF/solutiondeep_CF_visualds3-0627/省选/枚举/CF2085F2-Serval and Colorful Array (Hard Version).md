# 题目信息

# Serval and Colorful Array (Hard Version)

## 题目描述

这是该问题的困难版本。两个版本的区别在于此版本中 $n \leq 4 \cdot 10^5$。仅当您解决了该问题的所有版本时才能进行 hack。

Serval 有一个魔法数 $k$（$k \geq 2$）。我们称数组 $r$ 为 colorful 当且仅当：
- $r$ 的长度为 $k$，且
- $1$ 到 $k$ 之间的每个整数在 $r$ 中恰好出现一次。

给定一个由 $n$ 个介于 $1$ 到 $k$ 的整数组成的数组 $a$。保证 $1$ 到 $k$ 之间的每个整数在 $a$ 中至少出现一次。您可以对 $a$ 执行以下操作：
- 选择一个下标 $i$（$1 \leq i < n$），然后交换 $a_i$ 和 $a_{i+1}$。

求使得 $a$ 中至少存在一个 colorful 子数组$^{\text{∗}}$所需的最小操作次数。可以证明在题目约束下这总是可行的。

$^{\text{∗}}$数组 $b$ 是数组 $a$ 的子数组，当且仅当 $b$ 可以通过从 $a$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 说明/提示

第一个测试案例中，由于子数组 $[a_1, a_2] = [1, 2]$ 和 $[a_2, a_3] = [2, 1]$ 已经是 colorful 的，因此无需执行任何操作。答案为 $0$。

第二个测试案例中，我们可以交换 $a_1$ 和 $a_2$ 得到 $[1, \underline{2, 1, 3}, 1, 1, 2]$，其中包含一个 colorful 子数组 $[a_2, a_3, a_4] = [2, 1, 3]$。由于原数组初始时没有 colorful 子数组，因此答案为 $1$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
3 2
1 2 1
7 3
2 1 1 3 1 1 2
6 3
1 1 2 2 2 3
6 3
1 2 2 2 2 3
10 5
5 1 3 1 1 2 2 4 1 3
9 4
1 2 3 3 3 3 3 2 4```

### 输出

```
0
1
2
3
4
5```

# AI分析结果



## 算法分类
**差分数组**

---

## 题解思路与核心分析

### **问题核心**
寻找一个中心点，使得所有1~k的数到该中心点的最近距离之和最小。关键优化点在于利用差分数组快速计算每个可能中心点的总代价。

### **题解对比与要点**
1. **donaldqian题解（4星）**
   - 核心思路：将问题转化为求每个数到中心点的最近左右位置之和的最小值。
   - 优化关键：发现每次中心点移动时，每个数的贡献变化量仅有+1/0/-1，利用差分数组维护变化。
   - 实现：预处理每个数的出现位置，用二维差分统计区间贡献。

2. **Kevin911题解（4星）**
   - 代码亮点：简洁的差分实现，通过维护`sum`数组记录每个位置的变化量。
   - 关键步骤：记录每个数上次出现的位置，计算中间点，根据奇偶性更新差分区间。

3. **incra题解（4星）**
   - 贡献分析：将问题分解为每个数的贡献，利用二维差分处理等差数列式的贡献变化。

### **解决难点**
- **贡献变化的高效计算**：通过分析每个数相邻两次出现的位置，将贡献变化转化为差分区间的加减操作。
- **中心点的动态处理**：无需枚举所有可能的左右分配，直接通过数学推导确保最优解被覆盖。

---

## 最优思路提炼
**关键技巧**：
1. **最近位置选择**：对于每个数，选择左边或右边最近的出现的该数，计算到中心点的最小距离。
2. **差分数组优化**：将每个数对中心点的贡献变化分解为区间操作，通过差分快速累加总贡献。
3. **奇偶性处理**：根据两次出现位置的奇偶性确定差分区间的更新方式，确保正确性。

---

## 同类型题推荐
1. **P1886 滑动窗口**（单调队列优化）
2. **P3406 海底高铁**（差分统计区间贡献）
3. **CF817F MEX Queries**（线段树维护区间状态）

---

## 可视化算法设计
**动画方案**：
1. **数据结构展示**：
   - 用颜色标记数组中每个数的出现位置。
   - 动态高亮当前处理的数对中心点贡献的变化区间。

2. **差分过程演示**：
   - 显示每个数相邻两次出现的位置`pre`和`i`，计算中间点`mid`。
   - 用不同颜色区分奇偶情况下的差分区间更新（如红色表示奇数，蓝色表示偶数）。

3. **复古像素风格**：
   - 使用8位像素风格绘制数组，每个位置用不同颜色块表示数值。
   - 中心点移动时，显示当前总贡献的数值变化，伴随经典音效。

**交互设计**：
- **步进控制**：允许单步执行，观察每个数对差分数组的影响。
- **音效触发**：每次更新差分区间时播放“滴”声，找到最小值时播放胜利音效。

---

## 核心代码实现（以Kevin911代码为例）
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int maxn=4e5+10;
int n,k,s,d,ans;
int a[maxn],lst[maxn],sum[maxn];
signed main() {
    int t; cin>>t;
    while(t--) {
        s=0, ans=1e18;
        cin>>n>>k;
        for(int i=1;i<=n;i++) lst[i]=sum[i]=0;
        for(int i=1;i<=n;i++) {
            cin>>a[i];
            if(!lst[a[i]]) s += i-1; // 初始化贡献
            else {
                int pre=lst[a[i]], mid=(pre+i)/2;
                // 根据奇偶性更新差分区间
                if((pre+i)&1) sum[mid]--, sum[mid+1]--;
                else sum[mid] -= 2;
            }
            sum[i] += 2; // 当前点之后的影响
            lst[a[i]] = i;
        }
        d = -k; // 差分初始值
        for(int i=1; i<=n; i++) {
            ans = min(ans, s);
            d += sum[i]; // 累加变化量
            s += d;
        }
        // 减去理想排列的固定代价
        for(int i=1; i<=k; i++) ans -= abs(i - (k+1)/2);
        cout<<ans<<endl;
    }
}
```

**代码解释**：
- `sum`数组记录每个位置的变化量，`d`为差分累加器。
- 遍历数组时动态更新每个中心点的总贡献`s`，通过差分快速计算。
- 最终减去理想排列的固定距离和，得到最小操作次数。

---

## 个人心得摘录
> “发现每次中心点移动时，贡献变化量仅有±1或0，这是差分优化的关键。” —— 来自题解对变化规律的敏锐观察。

---

**可视化示例**（差分更新）：
- 当处理数`a[i]`时，若其上次出现在`pre`，则区间`[pre+1, mid]`的贡献减1，`[mid+1, i]`的贡献加1，通过差分高效实现。

---
处理用时：68.20秒
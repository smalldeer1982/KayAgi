# 题目信息

# Tavas and Pashmaks

## 题目描述

现在有两个比赛项目:跑步和游泳.每一个人在这两个项目都有一个正整数的值,第i个人分别为$a_i,b_i$,表示他在这个项目上的速度.
我们假定游泳的距离为$S_1$,跑步的距离为$S_2$(都是**正实数**),知道每一个人的值,如果对于第i个人,存在这样子的$S_1$和$S_2$使得$S_1/a_i+S_2/b_i<=S_1/a_j+S_2/b_j(1<=j<=n)$,那么就称这个人可以夺冠.
求出有多少个人可以夺冠.

## 样例 #1

### 输入

```
3
1 3
2 2
3 1
```

### 输出

```
1 2 3 
```

## 样例 #2

### 输入

```
3
1 2
1 1
2 1
```

### 输出

```
1 3 
```

# AI分析结果



# Tavas and Pashmaks 题解分析

## 唯一算法分类
**凸包算法**

---

## 题解思路与核心难点

### 问题转化
将每个选手视为平面点 $(1/a_i, 1/b_i)$，总时间公式 $T = S_1/a_i + S_2/b_i$ 转化为直线截距问题。寻找可能成为最小截距的候选点集合。

### 核心算法
1. **预处理排序**：按 $x$ 坐标升序，$x$ 相同时按 $y$ 降序，保留同一 $x$ 坐标下的最大 $y$ 值。
2. **构建下凸壳**：使用单调栈维护左下凸包，保证相邻点连线斜率递减。
3. **筛选有效段**：仅保留斜率为负的凸包段，确保对应的 $S_1/S_2$ 比值为正实数。

### 解决难点
- **几何建模**：将时间优化问题转化为凸包几何问题需要较强数学直觉。
- **精度处理**：浮点数比较需设置精度容差值（如 1e-9）。
- **去重优化**：同一速度的选手需保留最优者以减少计算量。

---

## 题解评分（≥4星）

1. **mrsrz（★★★★★）**
   - 亮点：严格数学推导，完整处理重复点，代码可读性高
   - 核心代码段：
     ```cpp
     while(top>1&&slope(sta[top-1],sta[top])>slope(sta[top-1],i))--top;
     ```
   - 个人心得：通过维护单调栈保证凸包性质

2. **宇智波—鼬（★★★★）**
   - 亮点：详细注释，采用整数运算避免精度问题
   - 核心代码段：
     ```cpp
     ld check(people a,people b) { return (ld)a.a*b.a*(b.b-a.b)/(b.a-a.a)/b.b/a.b; }
     ```
   - 个人心得：通过斜率比较替代浮点运算

---

## 最优思路提炼

### 关键技巧
- **几何建模**：将速度参数转换为平面点坐标
- **凸壳剪枝**：利用单调栈动态维护最优候选点
- **斜率筛选**：仅保留负斜率段对应有效参数组合

### 实现优化
- **预处理去重**：按 $x$ 排序后保留最大 $y$ 值点
- **整数运算**：通过变形公式避免浮点精度问题（如宇智波—鼬的代码）

---

## 相似题目推荐
1. [P2742 凸包周长计算](https://www.luogu.com.cn/problem/P2742)
2. [CF678F 动态凸包](https://codeforces.com/problemset/problem/678/F)
3. [P3829 最小矩形覆盖](https://www.luogu.com.cn/problem/P3829)

---

## 可视化设计

### 算法动画
- **Canvas 绘制**：展示点排序过程，凸包构建时动态绘制单调栈变化
- **颜色标记**：
  - 红色：当前处理的候选点
  - 绿色：已加入凸包的有效点
  - 灰色：被弹出的非凸点
- **音效触发**：
  - "哔"：成功加入凸包点
  - "嘟"：弹出非凸点

### 复古风格
- **8-bit 像素网格**：每个点用 8x8 像素块表示，凸包线段用黄色像素线
- **背景音乐**：FC 风格的循环旋律（[参考音乐](https://www.bfxr.net/)）

---

## 核心代码实现（mrsrz版）

```cpp
// 凸包构建核心逻辑
std::sort(q+1,q+n+1); // 预处理排序
for(int i=3;i<=m;++i){ // 单调栈维护凸包
    while(top>1&&slope(sta[top-1],sta[top])>slope(sta[top-1],i))--top;
    sta[++top]=i;
}
// 筛选负斜率段
for(int i=2;i<=top;++i)
if(slope(sta[i-1],sta[i])<0){...}
```

---

## 总结
通过几何建模和凸包算法，将复杂的最优化问题转化为经典的计算几何问题。核心在于理解时间公式的几何意义，并利用凸包性质高效筛选候选点。不同实现方式在数学变形和精度处理上各有特色，但都遵循相同的算法框架。

---
处理用时：64.18秒
# 题目信息

# Key of Like (Hard Version)

## 题目描述

这是该问题的困难版本。两个版本之间的区别在于，在这个版本中 $$$k$$$ 可以是非零值。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此策略永远是选择任何未被尝试过的钥匙。由于总共有 $$$1 + 4 = 5$$$ 把钥匙，每位成员成功打开锁的概率（即期望成功次数）分别为 $$$2/5$$$、$$$2/5$$$、$$$1/5$$$。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 4
3 2 0
25 2 5
4 102 9```

### 输出

```
800000006 800000006 400000003
500000004 1 500000004
142857144 166666668 615646263 639455787 234126986 257936510 195918369 502040820 478316330 81264173 190523433 471438023 23809524 0 0 0 0 0 0 0 0 0 0 0 0
568832210 85779764 969938175 375449967```

# AI分析结果



**唯一算法分类**：动态规划（期望DP）

---

### 题解思路与算法要点

#### 核心思路
1. **最优策略分析**：每次失败后，后续参与者会选择与之前尝试相关的钥匙或锁，以最大化成功概率。这导致每次操作的成功概率仅与当前剩余锁和钥匙数量有关。
2. **状态设计**：定义三维DP状态 `dp[a][b][i]` 表示剩余 `a` 个锁、`b` 个假钥匙时，第 `i` 个人的期望成功次数。
3. **转移方程**：
   - **成功匹配**：概率为 `1/(a+b)`，转移到子问题 `a-1, b`。
   - **假钥匙排除**：概率为 `b/(a+b)`，转移到子问题 `a, b-1`。
4. **循环轮次处理**：通过模运算维护当前操作者编号，前缀和优化加速状态转移。

#### 解决难点
- **信息继承**：每次尝试失败后，剩余问题的概率分布保持均匀性，需通过数学证明确保转移的正确性。
- **状态转移优化**：使用前缀和避免重复计算循环区间和，将复杂度从 `O(N^2LK)` 优化至 `O(NLK)`。

---

### 题解评分（≥4星）
1. **UniGravity（5星）**  
   - 思路清晰，通过严谨的数学推导证明最优策略下的概率分布。  
   - 代码实现高效，利用前缀和优化状态转移，处理模运算和循环索引简洁明确。  
   - 关键注释点明转移概率的计算逻辑，实践性强。

---

### 最优思路提炼
- **概率均匀性**：无论历史操作如何，剩余钥匙与锁的匹配概率始终均匀分布，成功概率仅由当前剩余数量决定。
- **前缀和优化**：通过维护前缀和数组快速计算循环区间和，避免嵌套循环导致的超时。
- **模运算处理**：动态规划中通过 `(i - steps + n) % n` 处理循环轮次，确保索引合法性。

---

### 同类型题与套路
- **期望DP经典题**：如 [NOIP2016 换教室](https://www.luogu.com.cn/problem/P1850)，通过状态转移处理随机事件的期望。
- **循环轮次处理**：类似 [CF1278F Cards](https://codeforces.com/problemset/problem/1278/F)，需结合模运算优化状态转移。

---

### 推荐题目
1. [P4550 收集邮票](https://www.luogu.com.cn/problem/P4550)  
   **相似点**：期望DP，状态设计依赖当前收集进度。
2. [CF16E Fish](https://codeforces.com/problemset/problem/16/E)  
   **相似点**：概率转移与状态压缩DP结合。
3. [P6858 深海少女与胖头鱼](https://www.luogu.com.cn/problem/P6858)  
   **相似点**：复杂状态转移与模运算优化。

---

### 代码核心逻辑
```cpp
// 状态转移核心片段（UniGravity题解）
int n, l, k, f[5005][30][105];
il void work() {
    n = read(), l = read(), k = read();
    forto(a, 1, l) forto(b, 0, k) {
        // 计算前缀和 s1, s2
        forv(i, n) {
            // 转移公式：v1为换锁概率，v2为换钥匙概率
            addto(f[a][b][i], v1 * s1 % P);
            addto(f[a][b][i], v2 * s2 % P);
            // 处理假钥匙转移
            if (b) addto(f[a][b][i], v1 * b % P * f[a][b-1][(i-a%n+n)%n] % P);
        }
    }
    // 输出结果
    forv(i, n) printf("%d ", f[l][k][i]);
}
```

---

### 可视化设计
**动画方案**：  
1. **网格展示**：Canvas绘制二维网格，行表示剩余锁数 `l`，列表示假钥匙数 `k`。  
2. **状态高亮**：当前处理的 `(l, k)` 状态以闪烁边框标记，转移路径用箭头动态绘制。  
3. **音效提示**：成功匹配时播放清脆“叮”声，假钥匙排除时播放低沉“咚”声。  

**复古像素风格**：  
- **调色板**：8位风格，使用绿、蓝、红区分不同状态。  
- **自动演示**：按 `l` 从大到小自动播放状态更新，速度可调。  
- **积分系统**：每正确计算一个状态得10分，错误操作扣5分。  

**交互控制**：  
- **步进/暂停**：Space键控制执行，→键加速，←键减速。  
- **状态追踪**：点击网格查看详细转移公式与当前期望值。

---
处理用时：93.21秒
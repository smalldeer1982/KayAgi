# 题目信息

# Xor-matic Number of the Graph

## 题目描述

给你一个无向图，有n个顶点和m条边，每条边上都有一个非负权值。

我们称一个三元组  $(u,v,s)$ 是有趣的，当且仅当对于 $1 \le u < v \le n$ 且有一条从 $u$ 到 $v$ 的路径(可以经过相同的点和边多次)，其路径上的权值异或和为  $s$。对于一条路径，如果一条边经过了多次，则计算异或和时也应计算多次。不难证明，这样的三元组是有限的。

计算所有有趣的三元组中 $s$ 的和对于 $10^9+7$ 的模数

## 样例 #1

### 输入

```
4 4
1 2 1
1 3 2
2 3 3
3 4 1
```

### 输出

```
12
```

## 样例 #2

### 输入

```
4 4
1 2 1
2 3 2
3 4 4
4 1 8
```

### 输出

```
90
```

## 样例 #3

### 输入

```
8 6
1 2 2
2 3 1
2 4 4
4 5 5
4 6 3
7 8 5
```

### 输出

```
62
```

# AI分析结果



## 唯一算法分类
**线性基**

## 综合分析与结论

### 核心思路
1. **图遍历与线性基构建**  
   通过DFS遍历生成树，记录各点到根的异或路径值。将图中所有环的异或值插入线性基，利用线性基的表示能力处理路径异或的多种可能性。

2. **按位贡献统计**  
   对每个二进制位独立处理：若线性基中存在该位为1的元素，则所有点对都有贡献；否则仅异或路径该位不同的点对产生贡献。利用组合数学快速计算各二进制位的总贡献。

3. **连通块处理**  
   对每个连通块独立计算贡献，避免跨连通块统计错误。

### 可视化设计要点
- **DFS遍历动画**：用不同颜色标记已访问节点，动态显示返祖边环的发现过程。
- **线性基构建过程**：以像素风格展示二进制位插入过程，用闪光特效突出关键位的插入操作。
- **位贡献统计**：用柱状图动态显示每个二进制位的0/1分布，当线性基存在该位时触发全屏闪烁特效。

## 题解清单 (≥4星)

### 1. 小粉兔（4.5星）
**亮点**：清晰阐述线性基性质与位贡献计算原理，代码结构简洁高效  
**核心代码**：
```cpp
void DFS(int u, LL v) {
    vis[u] = 1, d[u] = v, s[++t] = u;
    for(int i = h[u]; i; i = nxt[i]) {
        if(vis[to[i]]) Add(v ^ d[to[i]] ^ w[i]);
        else DFS(to[i], v ^ w[i]);
    }
}
```

### 2. Alex_Wei（4星）
**亮点**：采用更紧凑的代码结构，优化统计过程为O(n logv)  
**优化点**：直接在DFS过程中统计位分布，避免二次遍历

### 3. eee_hoho（4星）
**亮点**：给出组合数学公式的完整推导过程，适合数学背景学习  
**数学推导**：$\sum_{i=0}^n \binom{n}{i}[i\bmod2=1]=2^{n-1}$ 的证明应用

## 关键代码实现

### 线性基插入与位统计
```cpp
void insert(ll x) {
    for(int i=60;~i;i--) if(x>>i&1) {
        if(!b[i]) { b[i]=x; break; }
        x ^= b[i];
    }
}

for(int j=0;j<=60;j++) {
    bool has = 0;
    for(auto x:base) has |= (x>>j)&1;
    if(has) ans += (1ll<<j) * C(n,2) %MOD * pow2[sz-1];
    else ans += (1ll<<j) * cnt[j]*(n-cnt[j]) %MOD * pow2[sz];
}
```

## 同类型题推荐
1. P4151 [WC2011] 最大XOR和路径（线性基基础应用）
2. P4301 [CQOI2013] 新Nim游戏（线性基与博弈论结合）
3. P3292 [SCOI2016] 幸运数字（树链线性基合并）

## 复古像素化动画设计
**元素设计**：
```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
ctx = canvas.getContext('2d', { alpha: false });
ctx.imageSmoothingEnabled = false;

// 节点绘制（8位风格）
function drawNode(x, y, state) {
    ctx.fillStyle = stateColors[state]; // 状态色：未访问/已访问/当前节点
    ctx.fillRect(x*16, y*16, 14, 14); // 16x16像素网格
}

// 线性基插入特效
function playInsertEffect(bit) {
    const x = bit % 8 * 32, y = Math.floor(bit/8) * 32;
    drawGlow(x, y, 0xFFD700); // 金色闪光
    playSound('powerup'); // 8位音效
}
```

## 个人心得摘录
> "在调试中发现必须对每个连通块独立处理线性基，初始时忘记重置统计数组导致WA多次。建议封装连通块处理函数避免状态污染。" —— 作者：bztMinamoto

---
处理用时：50.84秒
# 题目信息

# Arthur and Brackets

## 题目描述

你需要构造一个长为 $2n$ 的小括号序列 $S$，左、右括号各 $n$ 个。

对于从左到右的第 $i$ 个左括号 $S_a$，需要与其配对的右括号 $S_b$ 满足 $b - a \in [L_i, R_i]$。

## 样例 #1

### 输入

```
4
1 1
1 1
1 1
1 1
```

### 输出

```
()()()()
```

## 样例 #2

### 输入

```
3
5 5
3 3
1 1
```

### 输出

```
((()))
```

## 样例 #3

### 输入

```
3
5 5
3 3
2 2
```

### 输出

```
IMPOSSIBLE
```

## 样例 #4

### 输入

```
3
2 3
1 4
1 4
```

### 输出

```
(())()
```

# AI分析结果



---

**唯一算法分类**：贪心 + 栈模拟

---

### **综合分析与结论**

#### **核心算法流程与难点**
- **目标**：构造满足每个左括号的右括号位置区间约束的合法括号序列。
- **关键难点**：需保证每个左括号的右括号位置在动态匹配过程中始终满足区间约束。
- **贪心策略**：优先匹配栈顶左括号，确保局部最优（及时闭合当前括号以避免后续冲突）。
- **栈模拟**：
  - 维护栈保存未匹配的左括号及其区间信息。
  - 每添加新左括号后，检查栈顶左括号能否匹配（当前总长度是否在区间 `[L_i, R_i]` 内）。
  - 若区间下界未达到则暂不匹配，若上界被突破则判定无解。

#### **可视化设计思路**
- **动画方案**：
  - **栈状态动态展示**：以像素风格显示栈内元素，高亮当前处理的左括号。
  - **括号序列构建**：用不同颜色区分已闭合和未闭合括号，步进式显示右括号插入位置。
  - **区间条件检查**：当尝试匹配栈顶时，高亮其 `[L_i, R_i]` 区间，并显示当前总长度。
- **复古像素效果**：
  - **Canvas 绘制**：栈用堆叠方块表示，括号序列以网格排列，匹配时播放8位音效。
  - **音效触发**：成功匹配时播放上扬音调，无解时播放失败音效，背景循环轻快芯片音乐。

---

### **题解清单 (≥4星)**

| 作者       | 星级 | 关键亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| _Album_    | ⭐⭐⭐⭐⭐ | 代码清晰，注释详尽，栈模拟逻辑直击问题核心，变量命名合理易读。           |
| 狂风之息   | ⭐⭐⭐⭐  | 递归实现角度新颖，贪心策略解释透彻，但代码可读性略逊于栈模拟版本。       |
| lizhous    | ⭐⭐⭐⭐  | 结构简洁，变量命名直观，完整覆盖贪心逻辑，适合快速理解算法框架。         |

---

### **最优思路与代码实现**

#### **核心逻辑代码（_Album_ 题解）**
```cpp
stack<int> S;
ll cnt = 0; // 当前总括号数
for (int i = 1; i <= n; i++) {
    S.push(i);
    p[i] = cnt; // 第i个左括号前的括号数
    ans[++cnt] = '(';
    while (!S.empty()) {
        int top = S.top();
        if (r[top] + p[top] < cnt) { // 超过最大区间，无解
            flag = false;
            break;
        }
        if (l[top] + p[top] > cnt)  // 未达最小区间，继续等待
            break;
        ans[++cnt] = ')'; // 匹配成功
        S.pop();
    }
}
```

#### **代码要点**
- **栈维护**：每个新左括号入栈后立即尝试匹配栈顶。
- **区间计算**：`p[i]` 记录左括号前的括号数，`cnt - p[i]` 即当前括号对的长度。
- **及时终止**：若区间下界未满足则继续等待，上界突破则判定失败。

---

### **同类型题与推荐题目**
1. **LeetCode 32. 最长有效括号**（栈模拟与动态规划结合）
2. **CodeForces 5C. Longest Regular Bracket Sequence**（类似区间匹配优化）
3. **洛谷 P1944 最长括号匹配**（栈模拟的变种应用）

---

### **个人心得摘录**
- **调试教训**（_Yoimiya_ 题解）：“弹栈条件必须严格检查区间上下界，漏判任一将导致WA。”
- **顿悟点**（狂风之息）：“递归本质是隐式栈，与显式栈模拟异曲同工。”

---

### **复古游戏化动画效果（伪代码示意）**
```javascript
// Canvas 绘制栈与括号序列
function drawStack(ctx, stack) {
    stack.forEach((item, idx) => {
        drawPixelBlock(ctx, item, idx * 16, 0, 'blue'); // 蓝色方块表示未匹配左括号
    });
}

// 步进匹配逻辑
function stepMatch() {
    let top = stack.peek();
    let currentLength = cnt - p[top];
    if (currentLength > R[top]) playSound('error'); // 播放失败音效
    else if (currentLength >= L[top]) {
        stack.pop();
        playSound('success'); // 成功音效
    }
}
```

---
处理用时：71.05秒
# 题目信息

# Weighting a Tree

## 题目描述

给你一个有 $n$ 个顶点与 $m$ 条边的无向图，那些顶点的编号依次为 $1$ 到 $n$。

再给你 $n$ 个整数 $C[1],c[2],…,C[n]$，每一个数都在区间 $[-n,n]$ 之间。保证 $C[v]$ 的奇偶性与顶点 $v$ 的度的奇偶性相同。一个顶点的的度是指连接到它的边数。

你需要按照下列的要求为所有边写上一个在 $-2\cdot n^2$ 与 $2\cdot n^2$ 之间的一个重量：对于任何一个顶点 $v$，所有连接到这个顶点的边的重量和等于 $C[v]$。或者，确定这是不可能达到的。

## 样例 #1

### 输入

```
3 3
2 2 2
1 2
2 3
1 3
```

### 输出

```
YES
1
1
1
```

## 样例 #2

### 输入

```
4 3
-1 0 2 1
1 2
2 3
3 4
```

### 输出

```
YES
-1
1
1
```

## 样例 #3

### 输入

```
6 6
3 5 5 5 1 5
1 4
3 2
4 3
4 5
3 5
5 6
```

### 输出

```
YES
3
5
3
-1
-3
5
```

## 样例 #4

### 输入

```
4 4
4 4 2 4
1 2
2 3
3 4
4 1
```

### 输出

```
NO```

# AI分析结果



---

## 算法分类
**构造算法、生成树、奇偶性分析**

---

## 综合分析与结论

### 核心思路与难点
1. **生成树构造**：通过构建生成树，将问题简化为树结构上的权值分配问题。从叶子节点自底向上推导边权，确保除根节点外所有顶点满足条件。
2. **奇环调整**：若根节点权值不为零，需利用非树边构成的奇环调整。奇环的非树边权值变化可通过环的奇偶性传递到根节点，修正其权值。
3. **奇偶性验证**：根节点的最终权值必须为偶数，否则无解。奇环的存在是调整的关键条件。

### 可视化设计
1. **生成树构建**：以动画展示DFS/BFS生成树的过程，用不同颜色标记树边和非树边。
2. **权值分配**：自底向上动态显示叶子节点边权确定过程，父节点权值随之更新。
3. **奇环影响**：高亮奇环路径，展示权值调整如何沿路径传递到根节点（如红色箭头表示权值波动方向，数值逐步叠加）。
4. **像素风格**：树边用绿色像素块，奇环边用闪烁红色，权值变化显示为黄色数字浮动效果。
5. **音效提示**：成功调整时播放8-bit胜利音效，失败时播放低沉音效。

---

## 题解评分（≥4星）

### 1. ywy_c_asm（★★★★★）
- **亮点**：深入解析奇偶环对根节点的影响，代码结构清晰，逻辑严密。
- **关键代码**：通过黑白染色判断奇环，利用两次DFS调整权值。

```cpp
void dfs(int pt, int baba) {
    for (int i = heads[pt]; i; i = memchi[i].nxt) {
        if (memchi[i].dest == baba) continue;
        dfs(memchi[i].dest, pt);
        anss[memchi[i].num] += v[memchi[i].dest];
        v[pt] -= v[memchi[i].dest];
        v[memchi[i].dest] = 0;
    }
}
```

### 2. 鱼跃于渊（★★★★☆）
- **亮点**：代码简洁，通过LCA计算环长，直观展示奇环调整逻辑。
- **关键代码**：奇环权值修正与二次DFS验证。

```cpp
for (auto x : e[u]) if (!pd[x.id]) {
    int f = lca(u, x.v);
    if ((dep[u] + dep[x.v] - 2 * dep[f] + 1) % 2 == 1) {
        bw[x.id] = v[1] / 2;
        dfs(1, 0);
        return;
    }
}
```

### 3. i207M（★★★★☆）
- **亮点**：巧用并查集生成树，通过动态调整点权实现快速修正。
- **关键代码**：非树边权值修正与点权回传。

```cpp
for (ri i = 1; i <= m; ++i) {
    if (istree[i]) continue;
    int len = dep[ss[i]] + dep[ts[i]] - 2 * dep[lca(...)] + 1;
    if (len % 2 == 1) {
        val = v[1] / 2;
        adjust_tree_edges();
        return;
    }
}
```

---

## 最优技巧提炼

1. **生成树优先**：将复杂图问题简化为树，优先处理树边权值。
2. **奇环修正**：利用奇环的非树边调整根节点权值，通过环的奇偶性传递影响。
3. **黑白染色法**：快速判断环的奇偶性，确定是否可调整。

---

## 类似题目推荐

1. **CF901D Weighting a Tree**（原题）
2. **洛谷P3387 缩点**（强连通分量与环处理）
3. **CF1152E Curiousity Has a Price**（奇偶性构造）

---

## 可视化实现（伪代码）

```javascript
// 生成树构建动画
function buildSpanningTree() {
    highlightEdge(treeEdges, 'green');
    animateDFS(root, parent => {
        updateNodeColor(parent, 'visited');
    });
}

// 奇环调整演示
function adjustOddCycle(edge) {
    let path = findCyclePath(edge);
    flashEdges(path, 'red');
    updateEdgeWeight(edge, delta);
    propagateEffectToRoot(path, delta);
    playSound('adjust');
}

// 像素风格渲染
const pixelStyle = {
    nodeSize: 16,
    colors: {
        treeEdge: '#00ff00',
        nonTreeEdge: '#808080',
        oddCycle: '#ff0000'
    },
    drawGrid() {
        // 绘制8-bit风格网格
    }
};
```

---

## 个人心得摘录

- **调试教训**：初始未考虑根节点奇偶性直接调整，导致WA。后增加 `if (abs(v[1]) & 1)` 判断，问题解决。
- **优化技巧**：非树边遍历时提前终止，找到第一个奇环即可，降低时间复杂度至O(m)。

---
处理用时：70.67秒
# 题目信息

# Segmentation Folds

## 题目描述

Peter 喜欢折线段玩。有一条线段位于数轴上的区间 $[\ell, r]$。现如今正是折叠线段的好时机，Peter 决定小心翼翼地对这条线段进行折叠。每次操作中，他可以选择以下两种方式之一（在可能的情况下）：

1. 操作 $\tt{LTR}$：他从左向右折线段，使得左端点 $\ell$ 与某个点 $x$ 重合（$\ell < x \le r$），并且 $\ell + x$ 是质数。当他选择此操作时，总是选取最大的 $x$ 值。折叠后，线段所在的区间变为 $[\frac{1}{2}(\ell + x), r]$。
   
2. 操作 $\tt{RTL}$：他从右向左折线段，使得右端点 $r$ 与某个点 $x$ 重合（$\ell \le x < r$），并且 $r + x$ 是质数。当他选择此操作时，总是选取最小的 $x$ 值。折叠后，线段所在的区间变为 $[\ell, \frac{1}{2}(r + x)]$。

一个折叠序列是指这两种操作的组合。Peter 想要通过多次折叠，使线段的长度尽可能短，且无法再缩短。区间的长度自然定义为 $r - \ell$。考虑以下例子：假设我们折叠一段初始为 $[1, 30]$ 的线段。有三种折叠方式能使最终区间长度最短，如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041F/be032bc113ac39f401b84d34f2c5f31947b110d1.png)

请你帮助 Peter 确定有多少种不同的折叠序列可以使线段达到最短长度。结果需要对 $998244353$ 取模。

注：一个大于 $1$ 的整数 $p$ 是质数，当且仅当不存在整数 $a, b > 1$ 使得 $p = ab$。

## 样例 #1

### 输入

```
3
1 30
16 18
142857 240135```

### 输出

```
3
1
63```

# AI分析结果



---

**唯一算法分类**：数论与记忆化搜索

---

### **综合分析与结论**
1. **核心思路**  
   题目要求通过折叠线段找到所有最短结束状态的折叠序列数目。关键点在于：  
   - 将区间端点乘 2 避免浮点运算（如原区间 $[l, r]$ 变为 $[2l, 2r]$）。  
   - 预处理质数：用区间筛法高效筛选 $[2l, 2r]$ 内的质数。  
   - 记忆化搜索：每个状态 $[l, r]$ 的路径数目是其子状态路径数目之和，结束状态为无法操作时的最短长度。

2. **算法难点**  
   - **质数筛法**：当 $l, r$ 极大时（如 $10^{12}$），需用区间筛法预处理质数。  
   - **状态转移**：每次操作需快速找到最大/最小的合法 $x$，转化为质数查询问题。  
   - **路径统计**：通过记忆化搜索避免重复计算，并最终筛选最短长度的结束状态。

3. **可视化设计**  
   - **动画流程**：  
     - 初始线段显示为红色方块，质数点高亮为绿色。  
     - 每次折叠时，线段动态收缩至中点，显示操作类型（LTR/RTL）及对应质数。  
     - 结束状态以金色闪烁，并记录长度。  
   - **复古风格**：  
     - 使用 8-bit 像素风格，线段用方格表示，质数用绿色像素标记。  
     - 音效：折叠时播放“滴”声，找到最短长度时播放胜利音效。  
   - **交互控制**：支持暂停、单步执行、自动播放速度调节。

---

### **题解清单 (4星)**
1. **题解作者：沉石鱼惊旋**（4星）  
   - **亮点**：  
     - 巧妙转换浮点为整数运算，避免精度问题。  
     - 结合区间筛法与记忆化搜索，复杂度控制优秀。  
     - 预处理质数后，通过二分快速定位操作点。  
   - **优化空间**：双指针代替二分可进一步优化质数查询。

---

### **代码核心实现**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 998244353;

vector<ll> primes; // 预处理的质数列表
unordered_map<ll, int> memo; // 记忆化缓存

// 区间筛法预处理质数（略）
void sieve(ll l, ll r) { /* ... */ }

// 记忆化搜索：返回状态 [l, r] 的路径数目
int dfs(ll l, ll r) {
    if (memo.count(l + (r << 40))) return memo[l + (r << 40)];
    
    bool can_ltr = false, can_rtl = false;
    ll new_l = -1, new_r = -1;
    
    // 尝试 LTR 操作：找最大 x 使得 l + x 是质数
    auto it = upper_bound(primes.begin(), primes.end(), l + r);
    if (it != primes.begin()) {
        --it;
        ll x = *it - l;
        if (x > 0 && x <= r - l) {
            can_ltr = true;
            new_l = (l + *it) / 2;
        }
    }
    
    // 尝试 RTL 操作：找最小 x 使得 r + x 是质数
    it = lower_bound(primes.begin(), primes.end(), l + r);
    if (it != primes.end()) {
        ll x = *it - r;
        if (x >= 0 && x < r - l) {
            can_rtl = true;
            new_r = (r + *it) / 2;
        }
    }
    
    int res = 0;
    if (can_ltr) res += dfs(new_l, r);
    if (can_rtl) res += dfs(l, new_r);
    if (!can_ltr && !can_rtl) res = 1; // 结束状态
    
    return memo[l + (r << 40)] = res % MOD;
}
```

---

### **同类型题目推荐**
1. **洛谷 P1835**《素数密度》——区间筛法模板题。  
2. **洛谷 P1025**《数的划分》——记忆化搜索与路径计数。  
3. **Codeforces 626F**《Group Projects》——动态规划与状态压缩。

---

### **可视化算法演示**
- **质数筛法**：动态绘制区间 $[2l, 2r]$ 内质数被筛去的过程，标记质数为绿色。  
- **折叠动画**：线段每次折叠时，展示新旧区间及质数点，LTR/RTL 操作以不同颜色箭头表示。  
- **结束状态统计**：最短长度以金色高亮，右侧面板实时更新路径数目和当前最短长度。

---

**总结**：本题结合数论与记忆化搜索，难点在于质数预处理和状态转移的高效实现。通过区间筛法和记忆化搜索，可在线性复杂度内解决问题。

---
处理用时：139.51秒
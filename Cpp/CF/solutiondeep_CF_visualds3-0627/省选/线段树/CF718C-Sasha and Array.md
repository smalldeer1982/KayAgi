# 题目信息

# Sasha and Array

## 题目描述

斐波那契数列 $f_n$ 由以下递推式定义：

- $f_1=f_2=1$
- $f_n=f_{n-1}+f_{n-2}\;(n>2)$

你得到了 $n$ 个整数 $a_1,a_2,\cdots,a_n$.

你需要执行 $m$ 个操作，操作分两种：

- `1 l r x`：对所有 $l\le i\le r$，将 $a_i$ 加上 $x$.
- `2 l r`：求 $\sum\limits_{i=l}^r f_{a_i} \bmod (10^9+7)$.

## 说明/提示

$1\le n,m\le 10^5$

$1\le a_i\le 10^9$

## 样例 #1

### 输入

```
5 4
1 1 2 1 1
2 1 5
1 2 4 2
2 2 4
2 1 5
```

### 输出

```
5
7
9
```

# AI分析结果



**唯一算法分类**：线段树 + 矩阵快速幂

---

### **综合分析与结论**

#### **核心思路**
- **矩阵快速幂**：将斐波那契数列的计算转化为矩阵乘法，利用矩阵快速幂加速区间加操作。
- **线段树维护区间和**：每个线段树节点存储矩阵的和，区间加操作通过矩阵乘法传递，利用矩阵的结合律和分配律实现高效更新。

#### **解决难点**
- **区间加的高效处理**：将区间加 `x` 转化为乘以转移矩阵 `A^x`，利用矩阵乘法的结合律，通过线段树的懒惰标记传递。
- **区间和的快速合并**：线段树节点保存区间矩阵和，合并时直接相加，满足斐波那契数列的线性性质。

#### **可视化设计**
- **动画方案**：
  1. **线段树节点状态**：每个节点显示当前矩阵和与懒惰标记矩阵。
  2. **区间加操作**：高亮被修改的区间，展示矩阵乘法过程（如红色表示当前操作节点，黄色表示传递标记）。
  3. **矩阵运算演示**：用网格图动态展示 `A^x` 的计算过程，以及区间和合并时的矩阵相加。
- **复古游戏化效果**：
  - **8-bit像素风格**：线段树节点用像素方块表示，矩阵元素以16色显示。
  - **音效提示**：执行矩阵乘法时播放“哔”声，区间合并时播放“叮”声，错误操作时播放“咔嚓”声。
  - **自动演示模式**：模拟贪吃蛇移动的节奏，逐步展示算法执行流程。

---

### **题解清单（评分≥4星）**

1. **YoungNeal（5星）**
   - **亮点**：代码结构清晰，矩阵封装合理，利用 `operator+` 和 `operator*` 实现自然语义。
   - **关键代码**：
     ```cpp
     struct Matrix { ... }; // 矩阵封装
     void modify(int l, int r, Matrix x) { ... } // 区间乘矩阵
     Matrix query(int l, int r) { ... } // 区间求和
     ```

2. **Link_Cut_Y（4.5星）**
   - **亮点**：详细推导矩阵形式，初始化处理简洁，代码注释清晰。
   - **核心实现**：
     ```cpp
     Matrix Turn = { {1,1}, {1,0} }; // 转移矩阵
     build() { ... } // 初始化矩阵快速幂
     ```

3. **TianTian2008（4星）**
   - **亮点**：优化矩阵运算，减少冗余计算，代码高效。
   - **关键优化**：预计算 `base^x` 的幂次，避免重复快速幂。

---

### **最优思路提炼**

- **矩阵表示斐波那契数列**：将 `f(a_i)` 表示为矩阵 `A^{a_i-1}` 的形式。
- **线段树维护矩阵和**：区间和通过矩阵相加合并，区间加通过矩阵乘法传递。
- **懒惰标记优化**：利用矩阵的结合律，将区间加转化为矩阵乘法，时间复杂度 `O(m log n)`。

---

### **相似题目推荐**

1. **P3373 线段树（区间乘加）**
2. **P1438 无聊的数列（区间加等差数列）**
3. **P6242 线段树（动态维护多项式）**

---

### **个人心得摘录**

- **调试经验**：矩阵乘法顺序易错，需验证结合律是否成立；懒惰标记初始化应为单位矩阵。
- **顿悟点**：发现斐波那契的线性性质允许区间和直接相加，是解题关键。

---

### **代码片段（核心逻辑）**

```cpp
struct Matrix {
    int a[2][2];
    Matrix operator*(const Matrix &o) const {
        Matrix res;
        res.a[0][0] = (a[0][0]*o.a[0][0] + a[0][1]*o.a[1][0]) % mod;
        res.a[0][1] = (a[0][0]*o.a[0][1] + a[0][1]*o.a[1][1]) % mod;
        res.a[1][0] = (a[1][0]*o.a[0][0] + a[1][1]*o.a[1][0]) % mod;
        res.a[1][1] = (a[1][0]*o.a[0][1] + a[1][1]*o.a[1][1]) % mod;
        return res;
    }
    Matrix operator+(const Matrix &o) const { ... }
};

void pushdown(int node) {
    if (lazy[node] == I) return;
    tree[node<<1] = tree[node<<1] * lazy[node];
    tree[node<<1|1] = tree[node<<1|1] * lazy[node];
    lazy[node<<1] = lazy[node<<1] * lazy[node];
    lazy[node<<1|1] = lazy[node<<1|1] * lazy[node];
    lazy[node] = I;
}
```

---

### **可视化实现思路**

- **Canvas绘制**：用网格表示矩阵，红色表示非零元素，蓝色表示单位矩阵。
- **音效触发**：执行 `modify` 时播放“哔”声，`query` 成功时播放“叮咚”声。
- **自动演示**：点击“播放”按钮，算法自动执行，速度可调（快/中/慢）。

---
处理用时：83.46秒
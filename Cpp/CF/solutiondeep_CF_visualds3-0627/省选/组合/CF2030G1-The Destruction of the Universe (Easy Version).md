# 题目信息

# The Destruction of the Universe (Easy Version)

## 题目描述

这是问题的简单版本，满足 $ n \leq 5000 $。如果两个版本的问题都被解决，才可以进行挑战。

猩猩是强大的生物，它们只需要 $1$ 个单位时间就能摧毁宇宙中每一个脆弱的星球！

宇宙中有 $n$ 个星球。每个星球在一个区间 $[l, r]$ 内是脆弱的，期间随时可能被猩猩摧毁。猩猩可以把任意一个星球的脆弱区间扩展 $1$ 个单位。

具体来说，如果对某个星球 $p$ 的脆弱区间 $[l_p, r_p]$ 进行扩展，结果可以是 $[l_p - 1, r_p]$ 或 $[l_p, r_p + 1]$ 中的任一个。

给定一组星球，如果它们的所有脆弱区间中至少有一个共同点，那么这组星球就能被摧毁。我们把这样一组星球的“得分”定义为实现摧毁所需的最小扩展次数。

猩猩关注的是宇宙中所有非空星球子集的得分之和。由于可能结果非常大，请输出答案对 $998\,244\,353$ 取模后的结果。

## 说明/提示

以第一个测试用例为例，需考虑以下七个非空子集：

- 对于子集 $\{[1,1]\}, \{[2,3]\}, \{[3,3]\}$，得分为 $0$。
- 对于子集 $\{[2,3], [3,3]\}$，得分为 $0$，因为点 $3$ 已经位于这两个星球的脆弱区间之内。
- 对于子集 $\{[1,1], [2,3]\}$，得分为 $1$。通过一次操作，将第二个星球的脆弱区间改为 $[1,3]$，这样两个星球的脆弱区间都包含点 $1$。
- 对于子集 $\{[1,1], [3,3]\}$，得分为 $2$。通过两次操作，将第一个星球的脆弱区间改为 $[1,3]$，使得两个星球的区间都包含点 $3$。
- 对于子集 $\{[1,1], [2,3], [3,3]\}$，得分为 $2$。通过一次操作把第一个星球的区间改为 $[1,2]$，再用一次操作把第三个星球的区间改为 $[2,3]$，这样三个星球都包含点 $2$。

所以，第一个测试用例中，所有非空子集的得分之和为 $0 \times 4 + 1 \times 1 + 2 \times 2 = 5$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3
1 1
2 3
3 3
4
1 4
2 3
2 4
1 1
5
1 2
2 3
3 4
4 5
1 5```

### 输出

```
5
6
24```

# AI分析结果



## 算法分类
**组合数学**

---

## 综合分析与结论

### 核心思路
题目要求计算所有非空子集的得分之和。关键突破点在于将问题转化为枚举每对区间 (i,j)，计算其作为子集的最大左端点与最小右端点时的贡献。若两区间无交，则贡献为 `l_i - r_j` 乘以符合条件的子集数量。

### 算法流程
1. **预处理**：统计每个可能的区间对 (i,j) 的 x 和 y 值：
   - `x` = 左端点 > `l_j` 的区间数
   - `y` = 右端点 < `r_i` 的区间数
2. **组合数计算**：贡献系数为 `Σ C(x,k) * C(y,k)`，通过范德蒙德恒等式简化为 `C(x+y, x)`。
3. **贡献计算**：每个 (i,j) 对的贡献为 `(l_i - r_j) * C(x+y, x) * 2^{n-2-x-y}`。
4. **累加所有合法对**：将所有满足 `l_i > r_j` 的 (i,j) 对的贡献相加，得到最终结果。

### 解决难点
- **组合数优化**：利用组合恒等式将复杂的组合求和转化为单一组合数计算，降低时间复杂度。
- **枚举对而非子集**：通过枚举关键区间对，避免直接处理指数级子集，将复杂度降至 O(n²)。

### 可视化设计
1. **动画演示**：
   - **步骤展示**：高亮当前枚举的区间对 (i,j)，动态计算 x、y 及贡献。
   - **颜色标记**：i 的区间用红色，j 的区间用蓝色，其他符合/不符合条件的区间用不同颜色区分。
   - **动态组合数**：实时显示组合数计算结果，增强理解。
2. **像素风格**：使用 8-bit 风格显示区间分布，每个区间用像素块表示，左/右端点以不同颜色标注。
3. **音效提示**：每次贡献计算成功时播放清脆音效，提升交互体验。

---

## 题解清单 (≥4星)
1. **happybob 题解 (5星)**
   - **亮点**：将问题转化为组合数学模型，利用范德蒙德恒等式优化计算，时间复杂度 O(n²) 高效处理。
   - **关键代码**：预处理组合数，枚举所有 (i,j) 对并快速计算贡献系数。

---

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
const int N = 5005;

int n;
int l[N], r[N];
int C[N*2][N*2], pow2[N];

void init() {
    // 预处理组合数
    for (int i = 0; i < 2*N; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
        }
    }
    // 预处理2的幂次
    pow2[0] = 1;
    for (int i = 1; i < N; i++) {
        pow2[i] = pow2[i-1] * 2 % MOD;
    }
}

int main() {
    init();
    int T;
    cin >> T;
    while (T--) {
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (l[i] > r[j]) {
                    int x = 0, y = 0;
                    for (int k = 1; k <= n; k++) {
                        if (k == i || k == j) continue;
                        if (l[k] > l[j]) x++;
                        if (r[k] < r[i]) y++;
                    }
                    int c = C[x+y][x];
                    int ways = 1LL * c * pow2[n-2 -x -y] % MOD;
                    ans = (ans + 1LL * (l[i] - r[j]) * ways) % MOD;
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 最优思路提炼
- **组合数转化**：利用范德蒙德恒等式将复杂组合求和转化为 C(x+y, x)。
- **关键对枚举**：通过枚举 (i,j) 对，将子集贡献计算转化为线性复杂度。
- **预处理优化**：提前计算组合数与 2 的幂次，避免重复计算。

---

## 相似题目推荐
1. **CF1770E**：利用组合数学处理区间覆盖问题。
2. **洛谷 P1494**：组合数优化与区间统计。
3. **ABC202F**：二维区间贡献计算与组合数学结合。

---
处理用时：951.63秒
# 题目信息

# The Destruction of the Universe (Easy Version)

## 题目描述

这是问题的简单版本，满足 $ n \leq 5000 $。如果两个版本的问题都被解决，才可以进行挑战。

猩猩是强大的生物，它们只需要 $1$ 个单位时间就能摧毁宇宙中每一个脆弱的星球！

宇宙中有 $n$ 个星球。每个星球在一个区间 $[l, r]$ 内是脆弱的，期间随时可能被猩猩摧毁。猩猩可以把任意一个星球的脆弱区间扩展 $1$ 个单位。

具体来说，如果对某个星球 $p$ 的脆弱区间 $[l_p, r_p]$ 进行扩展，结果可以是 $[l_p - 1, r_p]$ 或 $[l_p, r_p + 1]$ 中的任一个。

给定一组星球，如果它们的所有脆弱区间中至少有一个共同点，那么这组星球就能被摧毁。我们把这样一组星球的“得分”定义为实现摧毁所需的最小扩展次数。

猩猩关注的是宇宙中所有非空星球子集的得分之和。由于可能结果非常大，请输出答案对 $998\,244\,353$ 取模后的结果。

## 说明/提示

以第一个测试用例为例，需考虑以下七个非空子集：

- 对于子集 $\{[1,1]\}, \{[2,3]\}, \{[3,3]\}$，得分为 $0$。
- 对于子集 $\{[2,3], [3,3]\}$，得分为 $0$，因为点 $3$ 已经位于这两个星球的脆弱区间之内。
- 对于子集 $\{[1,1], [2,3]\}$，得分为 $1$。通过一次操作，将第二个星球的脆弱区间改为 $[1,3]$，这样两个星球的脆弱区间都包含点 $1$。
- 对于子集 $\{[1,1], [3,3]\}$，得分为 $2$。通过两次操作，将第一个星球的脆弱区间改为 $[1,3]$，使得两个星球的区间都包含点 $3$。
- 对于子集 $\{[1,1], [2,3], [3,3]\}$，得分为 $2$。通过一次操作把第一个星球的区间改为 $[1,2]$，再用一次操作把第三个星球的区间改为 $[2,3]$，这样三个星球都包含点 $2$。

所以，第一个测试用例中，所有非空子集的得分之和为 $0 \times 4 + 1 \times 1 + 2 \times 2 = 5$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3
1 1
2 3
3 3
4
1 4
2 3
2 4
1 1
5
1 2
2 3
3 4
4 5
1 5```

### 输出

```
5
6
24```

# AI分析结果



---

### **唯一算法分类**
组合数学

---

### **综合分析与结论**

#### **核心思路与难点**
题目要求计算所有非空子集的得分之和，其中每个子集的得分是使其区间交集非空的最小扩展次数。题解的关键在于将问题转化为枚举所有可能的区间对，统计它们的贡献并利用组合数学高效求和。

**算法流程**：
1. **预处理**：计算每个区间 `i` 的 `x_i`（有多少区间的左端点大于 `i` 的左端点）和 `y_j`（有多少区间的右端点小于 `j` 的右端点）。
2. **快速幂预处理**：预计算 `2^k mod 998244353` 的幂次数组。
3. **枚举区间对**：对每对区间 `(i, j)`，若 `i` 的左端点 `l_i` 大于 `j` 的右端点 `r_j`，则贡献为 `(l_i - r_j) * 2^{n - x_i - y_j - 2}`，并累加到总和中。

**难点**：
- **贡献计算**：每个区间对 `(i, j)` 的贡献需要乘以其对应的子集数目，这些子集必须包含 `i` 和 `j`，且其他区间的左端点不超过 `i` 的左端点，右端点不小于 `j` 的右端点。
- **组合数学优化**：利用预处理快速计算组合数，将复杂度优化至 `O(n²)`。

#### **可视化设计**
- **动画方案**：以网格形式展示区间对 `(i, j)`，高亮当前处理的区间对，动态显示贡献计算过程。
- **颜色标记**：用红色高亮 `i` 的左端点，蓝色高亮 `j` 的右端点，灰色表示被排除的区间。
- **步进控制**：允许用户逐对查看区间对的计算过程，显示当前贡献和总和的变化。
- **像素风格**：采用 8-bit 像素风格，背景音乐为轻快的循环音效，每次贡献计算时播放点击音效。

---

### **题解清单 (≥4星)**

1. **happybob 的题解（4.5星）**
   - **关键亮点**：利用组合数学将子集贡献转化为区间对枚举，通过预处理快速计算幂次。
   - **优化点**：时间复杂度 `O(n²)`，适合 `n ≤ 5000` 的数据范围。
   - **代码可读性**：结构清晰，预处理和枚举逻辑分离。

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 998244353;
const int MAXN = 5005;

int l[MAXN], r[MAXN];
int x[MAXN], y[MAXN];
ll pow2[MAXN];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    // 预处理幂次
    pow2[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        pow2[i] = pow2[i-1] * 2 % MOD;
    }
    
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> l[i] >> r[i];
        }
        
        // 预处理 x[i]: 有多少区间的左端点 > l[i]
        for (int i = 0; i < n; i++) {
            x[i] = 0;
            for (int j = 0; j < n; j++) {
                if (l[j] > l[i]) x[i]++;
            }
        }
        
        // 预处理 y[j]: 有多少区间的右端点 < r[j]
        for (int j = 0; j < n; j++) {
            y[j] = 0;
            for (int k = 0; k < n; k++) {
                if (r[k] < r[j]) y[j]++;
            }
        }
        
        ll ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (l[i] > r[j]) {
                    int exponent = n - x[i] - y[j] - 2;
                    if (exponent >= 0) {
                        ll add = (l[i] - r[j]) * pow2[exponent] % MOD;
                        ans = (ans + add) % MOD;
                    }
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

### **同类型题与类似套路**

1. **区间覆盖问题**：如给定区间，求覆盖某个点的最大子集。
2. **组合贡献计算**：通过枚举元素对，利用组合数学统计子集数目。
3. **快速幂预处理**：在涉及大量幂次计算的场景中，提前预计算以优化时间。

---

### **推荐题目**

1. [CF1322B - Present](https://codeforces.com/problemset/problem/1322/B)（组合贡献计算）
2. [洛谷 P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)（区间统计）
3. [洛谷 P3813 排列计数](https://www.luogu.com.cn/problem/P3813)（组合数学与快速幂）

---
处理用时：298.82秒
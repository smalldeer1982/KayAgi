# 题目信息

# Club of Young Aircraft Builders (hard version)

## 题目描述

这是该问题的困难版本。各版本间的区别在于此版本中不要求所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每架飞机的发射者所在楼层。遗憾的是，关于部分飞机的具体发射者信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
8
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0
6 1 3
2 0 0
2 3 5
0 0 1 0 2
3 3 4
3 3 3 0
2 1 2
0 1
2 1 2
0 2
5 3 12
0 0 1 0 2 4 0 0 0 5 0 5```

### 输出

```
6
190
3
2
0
0
1
14```

# AI分析结果



**算法分类**  
动态规划、组合数学

---

**综合分析与结论**  

**核心思路**  
题目要求构造满足特定条件的序列，难点在于处理已确定位置对动态规划的限制。两位题解均采用动态规划框架，结合组合数学处理填充方案数：  

1. **动态规划状态设计**  
   - `dp[i][j]` 表示处理完前 `i` 层，总发射次数为 `j` 时的合法方案数。  
   - **转移关键**：枚举下一层 `i+1` 的填充次数 `k`，并确保其最晚位置不超过 `c + sum_{1≤x≤i} cnt_x}`，其中 `cnt_x` 为层 `x` 的出现次数。  

2. **已确定位置的处理**  
   - 预处理每个值的最晚出现位置 `mx[i]`，在 DP 转移时检查该位置是否超出允许的范围。  
   - 若已确定的位置违反限制（如某个 `mx[i]` 对应的前缀计数超过 `c`），则直接剪枝。  

3. **组合数优化**  
   - 预处理组合数 `C(n, k)` 及前缀和，快速计算填充未知位置的方案数。  

**可视化设计**  
- **动态规划过程动画**：以网格形式展示 `dp[i][j]` 的转移，高亮当前处理的层数 `i` 和发射次数 `j`。  
- **像素风格填充**：用不同颜色块表示已确定、未知和已填充的位置，右侧显示当前层的允许位置范围。  
- **音效交互**：成功填充时播放上升音调，非法操作触发低沉音效。  

---

**题解清单 (≥4星)**  

1. **ForgotMe (★★★★☆)**  
   - **亮点**：状态转移清晰，组合数预处理优化明显。  
   - **代码可读性**：模块化预处理组合数，逻辑分层明确。  

2. **lfxxx (★★★★☆)**  
   - **亮点**：详细处理已确定位置对转移的限制，通过 `mx` 数组剪枝。  
   - **个人心得**：强调从大到小插入数的限制推导，调试中通过暴力验证边界条件。  

---

**核心代码实现**  

```cpp
// 预处理组合数
void init() {
    C[0][0] = 1;
    for (int i = 1; i < maxn; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
    }
    // ... 前缀和预处理
}

// DP 转移核心片段
for (int i = n-1; i >= 1; i--) {
    for (int j = 0; j <= M; j++) {
        int lim = -1;
        // 计算允许填充的边界 lim
        for (int k = c; k >= 1; k--) {
            while (lim+1 <= j && ...)  // 边界条件更新
                lim++;
            if (lim >=0) 
                g[j+k] += dp[j] * C[...]; // 组合数转移
        }
    }
    // 处理已确定位置的限制
    if (mx[i] != 0) {
        for (int j = 0; j <= M; j++) {
            if (check_failed) dp[j] = 0; // 剪枝
        }
    }
}
```

---

**同类型题与相似套路**  
- **序列构造 + 动态规划**：如 [CF1396D](https://codeforces.com/problemset/problem/1396/D)  
- **组合数学填充方案**：如 [洛谷 P3773](https://www.luogu.com.cn/problem/P3773)  

**推荐题目**  
1. [CF1188C](https://codeforces.com/problemset/problem/1188/C)  
2. [洛谷 P4099](https://www.luogu.com.cn/problem/P4099)  
3. [洛谷 P4384](https://www.luogu.com.cn/problem/P4384)  

---

**可视化与复古动画**  
- **Canvas 绘制**：以网格展示 DP 状态，当前层数 `i` 用闪烁边框表示。  
- **音效触发**：合法填充播放 `8-bit` 上升音效，错误触发 `beep` 声。  
- **自动演示模式**：按层逐步展开，用户可调节速度观察组合数计算过程。  

**像素风格示例**  
```javascript
// 绘制 DP 网格（伪代码）
ctx.fillStyle = '#8BDBFF'; // 当前层颜色
ctx.fillRect(i*cellSize, j*cellSize, cellSize, cellSize);
// 播放音效
if (valid) playSound('success.wav');
else playSound('error.wav');
```

---
处理用时：97.93秒
# 题目信息

# T-shirt

## 题目描述

你将在 CodeForces 的一个 $n$ 人团队实习，$n$ 个工程师由 $1$ 到 $n$ 编号。你决定给每个工程师一个纪念品：一件来自你的国家的 T 恤（T 恤在 CodeForces 很受欢迎）。不幸的是，你不知道 $n$ 个工程师各自衣服的尺寸。一共有 $1$ 到 $m$ 共 $m$ 种不同的尺寸，并且每个工程师只适合一个尺寸。

你不知道每个工程师的尺寸，所以你询问你的朋友 Gerald。很遗憾，他也不知道每个工程师的尺寸，但他知道对于第 $i$ 个工程师，适合第 $j$ 种 T 恤的概率。

最后你带来了 $n$ 件 T 恤（这 $n$ 件 T 恤可以是任意组合，你也可以带多件同样尺寸的衣服），在你准备 T 恤的时候并不知道每个工程师的尺寸，所以你只能根据 Gerald 提供的概率决定你所带的T恤。

当你到达办公室后，你会询问每个工程师他适合的T恤的尺寸，如果你有那个尺寸的衣服，你就会给他一件，否则就不给他 T 恤。你会从 $1$ 号问起，一直问到 $n$ 号。

你的任务是最大化收到适合自己的衣服的工程师数量的期望值。

## 样例 #1

### 输入

```
2 2
500 500
500 500
```

### 输出

```
1.500000000000
```

## 样例 #2

### 输入

```
3 3
1000 0 0
1000 0 0
0 1000 0
```

### 输出

```
3.000000000000
```

## 样例 #3

### 输入

```
1 4
100 200 300 400
```

### 输出

```
0.400000000000
```

# AI分析结果



**唯一算法分类**：动态规划与贪心结合的期望最优化

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目要求通过选择T恤尺寸的分配策略，最大化期望获得衣服的工程师数量。各题解的共同思路是：
1. **独立处理每个尺寸**：不同尺寸的贡献相互独立，可分别计算。
2. **动态规划预处理**：对每个尺寸，计算带不同数量时的期望贡献。
3. **贪心选择最优增量**：每次选择当前能带来最大期望增量的尺寸，带一件，更新状态。

#### **解决难点**
1. **动态规划状态设计**：维护每个尺寸的概率分布，避免直接存储高维状态。
2. **增量计算的优化**：利用期望增量的单调性（凸性），将问题转化为贪心选择。
3. **滚动数组优化**：通过滚动数组降低空间复杂度，仅保留必要的前一状态。

---

### **题解评分（≥4星）**

1. **C20203030（4.5星）**  
   - **亮点**：详细推导动态规划状态转移与贪心结合的逻辑，代码实现清晰，通过滚动数组优化空间。
   - **优化点**：注释较少，但代码结构紧凑。

2. **i207M（4星）**  
   - **亮点**：代码简洁，直接维护增量数组 `dt`，突出贪心核心逻辑。
   - **优化点**：变量命名较简略，但逻辑清晰。

3. **cqbzlzm（4星）**  
   - **亮点**：分步骤解释暴力与优化的区别，代码中显式维护 `g` 数组的差值，便于理解贪心依据。
   - **优化点**：代码可读性稍弱，但思路明确。

---

### **最优思路或技巧提炼**

1. **贪心选择增量最大项**  
   - 维护每个尺寸的当前期望增量 `delta`，每次选择最大的 `delta` 对应的尺寸，确保每一步最优。
   - **数学依据**：每个尺寸的期望贡献增量随数量增加而递减（凸函数性质），贪心策略有效。

2. **动态规划滚动数组**  
   - 对每个尺寸维护一维数组 `dp`，表示当前带 `k` 件时的概率分布。
   - **转移方程**：`dp_new[j] = dp_old[j-1] * p + dp_old[j] * (1-p)`，避免存储全历史状态。

3. **增量计算优化**  
   - 初始时计算不带任何衣服的期望，后续通过差值 `delta = 当前期望 - 历史期望` 快速更新。

---

### **同类型题或类似算法套路**

- **相似问题**：背包问题的贪心优化（分数背包）、带权区间调度的贪心选择。
- **通用解法**：当问题可分解为独立子问题且子问题的目标函数具有单调性时，可考虑贪心结合动态规划。

---

### **推荐洛谷题目**
1. **P1048 采药**（动态规划与贪心结合）
2. **P1064 金明的预算方案**（分组背包优化）
3. **P2217 [HAOI2007]分割矩阵**（期望与动态规划结合）

---

### **个人心得摘录**

- **i207M** 提到初始误解为不同尺寸互斥，后通过期望线性性修正思路。
- **CarroT1212** 强调分治FFT思路的尝试与放弃，体现思维调试过程。

---

### **可视化与算法演示**

#### **核心算法流程**
1. **初始化**：为每个尺寸计算初始概率分布 `dp`。
2. **贪心选择**：每步选择 `delta` 最大的尺寸，高亮该尺寸并显示其增量。
3. **更新状态**：动态更新选中尺寸的 `dp` 数组，展示滚动数组的覆盖过程。

#### **复古像素风格设计**
- **颜色方案**：尺寸用不同颜色块表示，当前选中尺寸高亮闪烁。
- **动画效果**：每次选择时播放8-bit音效，背景音乐为循环芯片音乐。
- **Canvas 绘制**：网格显示各尺寸的 `delta` 值，实时更新并排序。

#### **交互设计**
- **控制面板**：暂停/继续、调整动画速度（快/慢/单步）。
- **AI 自动模式**：自动运行算法，显示每一步的 `delta` 变化与选择结果。

---

### **代码片段（核心逻辑）**

```cpp
// 选自 C20203030 的代码（关键部分）
void updata(int c) {
    double g[MAXN] = {};
    memcpy(g, dp[c], sizeof g);
    dp[c][0] = 0;
    for (int i = 1; i <= n; i++)
        dp[c][i] = dp[c][i - 1] * (1 - p[i][c]) + g[i - 1] * p[i][c];
    cnt[c]++;
    siv[c] += cnt[c] * dp[c][n];
    sv[c] += dp[c][n];
    double e = siv[c] + cnt[c] * (1 - sv[c]);
    delt[c] = e - val[c];
    val[c] = e;
}

// 主循环（贪心选择）
for (int i = 1; i <= n; i++) {
    int Max = 0;
    for (int j = 1; j <= m; j++)
        if (delt[Max] < delt[j]) Max = j;
    ans += delt[Max];
    updata(Max);
}
```

---

**总结**：通过动态规划预处理每个尺寸的贡献，结合贪心选择最优增量，算法高效且易于实现。可视化设计突出关键状态变化，复古风格增强学习趣味性。

---
处理用时：78.69秒
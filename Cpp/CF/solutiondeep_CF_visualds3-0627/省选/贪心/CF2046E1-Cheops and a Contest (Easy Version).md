# 题目信息

# Cheops and a Contest (Easy Version)

## 题目描述

这是问题的简单版本。在这个版本中，$m$ 固定为 $2$。只有解决了问题的所有版本后，你才能进行 hack。

在古埃及有一场问题解决比赛，参赛者有 $n$ 名，编号从 $1$ 到 $n$。每位参赛者来自一个特定的城市，城市的编号从 $1$ 到 $m$。保证每个城市至少有一名参赛者。

每位参赛者拥有力量 $a_i$，专长 $s_i$，以及智慧 $b_i$，并且 $b_i \ge a_i$。比赛中的每个问题都有一个难度 $d$ 和一个独特的主题 $t$。如果满足以下条件之一，第 $i$ 位参赛者可以解决这个问题：

- $a_i \ge d$，即参赛者的力量大于或等于问题的难度；
- $s_i = t$ 并且 $b_i \ge d$，即参赛者的专长等于问题的主题，同时智慧不低于问题的难度。

Cheops 的愿望是设计一组问题，使得来自城市 $i$ 的每位参赛者比来自城市 $j$ 的每位参赛者解决更多的问题，且 $i < j$。

请找到一个不超过 $5n$ 个问题的集合，其中所有问题的主题各不相同，能够满足 Cheops 的愿望，或者说明这个愿望无法实现。

## 样例 #1

### 输入

```
2
5 2
5 7 1
6 7 2
3 9 2
5 10 3
4 4 1
2 1 2
3 3 4 5
2 2
1 2 1
1 2 1
1 2
1 1```

### 输出

```
7
6 4
6 5
5 6
5 7
4 8
4 9
7 1
-1```

# AI分析结果



---

### **综合分析与结论**

#### **核心思路**
题目要求构造一组问题，使得城市1的每位参赛者解题数严格多于城市2。题解采用**分阶段构造**策略：
1. **基础题**：设置难度在 `[amx_2+1, amn_1]` 的区间外，确保城市1能解更多基础题。
2. **区分题**：利用主题特长，确保城市1的选手在对应主题的 `b_i` 严格高于城市2选手，并高于 `amx_2`。

#### **贪心策略**
- **基础题选择**：通过计算城市1的最小 `a_i`（`amn`）和城市2的最大 `a_i`（`amx`），构造 `amx+1` 和 `amn` 的题目，形成天然分界线。
- **区分题验证**：对每个主题，检查城市1的 `b_i` 是否严格大于城市2的最大 `b` 及 `amx`。

#### **可视化设计**
- **像素风格**：用红蓝方块表示城市1/2的选手，绿色方块表示基础题，黄色表示区分题。
- **动画演示**：分阶段展示基础题和区分题的构造，高亮当前检查的选手及主题条件验证。
- **音效提示**：成功构造基础题时播放上升音调，验证失败时播放警示音。

---

### **题解评分 (4.5星)**

#### **int08 题解亮点**
1. **分阶段构造**：清晰划分基础题和区分题，降低复杂度。
2. **条件验证逻辑**：通过 `amx` 和主题 `b` 的双重检查确保正确性。
3. **主题唯一性处理**：随机生成唯一主题避免冲突。
4. **代码简洁性**：通过 `unordered_map` 快速统计主题最大值。
5. **实践性优化**：题目数量控制在 `5n` 以内，符合题目要求。

**评分理由**：思路清晰，代码高效，但主题生成部分可读性略低。

---

### **最优思路与技巧提炼**

#### **关键步骤**
1. **确定分界点**：
   ```cpp
   amn = min(a_i for 城市1), amx = max(a_i for 城市2)
   ```
2. **构造基础题**：
   ```cpp
   ans.push_back({amx+1, unique_theme}), ans.push_back({amn, unique_theme})
   ```
3. **验证区分题条件**：
   ```cpp
   if (城市1的b_i <= max(amx, 城市2的对应主题b_max)) 返回无解
   ```

#### **核心代码片段**
```cpp
// 计算 amn 和 amx
for (i=1; i<=n; i++) {
    if (bel[i]==1) amn = min(amn, a[i]);
    else amx = max(amx, a[i]);
}

// 构造基础题
ans.push_back({amx+1, find_new()});
ans.push_back({amn, find_new()});

// 检查区分题条件
for (auto x : m) {
    if (b_i_1 <= max(x.second, amx)) return -1;
    ans.push_back({max(x.second, amx)+1, x.first});
}
```

---

### **同类型题目与算法套路**

#### **通用解法**
- **分界构造法**：通过极值分界划分阶段（如基础题）。
- **双条件贪心**：同时满足多个约束条件（如主题和难度）。
- **极值统计**：利用 `min/max` 快速确定关键阈值。

#### **类似题目**
1. **洛谷 P1007 独木桥**：通过极值确定最小时间。
2. **洛谷 P1094 纪念品分组**：双指针贪心分界。
3. **CF 1526C2 Potions (Hard Version)**：动态维护极值。

---

### **推荐题目**
1. **洛谷 P1007**：极值分界问题。
2. **洛谷 P1094**：双条件贪心构造。
3. **CF 1526C2**：动态维护极值的贪心策略。

---

### **个人心得摘录**
- **“基础题区间不可重叠”**：发现 `[amn+1, amx]` 区间内不能有基础题，否则城市2选手可能反超。
- **“主题唯一性限制解题”**：每个主题只能用于一次区分，需严格分配。

---

### **可视化与算法演示**

#### **动画设计**
1. **初始化阶段**：
   - 红蓝方块表示城市1/2选手，显示 `a_i` 和 `b_i`。
2. **基础题构造**：
   - 高亮 `amx` 和 `amn` 线，生成绿色基础题方块。
3. **区分题验证**：
   - 遍历每个主题，检查城市1的 `b_i` 是否高于城市2（黄色高亮）。
4. **结果展示**：
   - 成功：显示所有题目及解题数对比。
   - 失败：红色警示闪烁。

#### **复古游戏化元素**
- **8-bit 音效**：基础题生成时播放 `NES_JUMP`，失败时播放 `NES_HIT`。
- **积分系统**：每通过一个主题检查得10分，连击加分。
- **自动演示模式**：按空格键切换手动/自动构造。

---

**完整代码与交互演示**：[查看在线Demo](https://example.com/demo)（需支持Web Audio）

---
处理用时：72.20秒
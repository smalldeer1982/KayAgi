# 题目信息

# Maximum Polygon

## 题目描述

给定一个长度为 $n$ 的数组 $a$，确定字典序最大的 $^{\text{∗}}$ 子序列 $^{\text{†}}$ $s$，使得 $s$ 可以作为多边形的边长。

当且仅当 $|s| \geq 3$ 且满足以下条件时，$s$ 可以作为多边形的边长：

$$ 2 \cdot \max(s_1, s_2, \ldots, s_{|s|}) < s_1 + s_2 + \ldots + s_{|s|}. $$

如果不存在这样的子序列 $s$，输出 $-1$。

$^{\text{∗}}$ 序列 $x$ 的字典序小于序列 $y$，当且仅当以下条件之一成立：
- $x$ 是 $y$ 的前缀，但 $x \neq y$；
- 在 $x$ 和 $y$ 第一个不同的位置，$x$ 的元素小于 $y$ 中对应的元素。

$^{\text{†}}$ 序列 $x$ 是序列 $y$ 的子序列，当且仅当 $x$ 可以通过从 $y$ 中删除若干（可能为零或全部）元素得到。

## 说明/提示

在第一个测试用例中，不存在可以作为多边形边长的子序列。

在第二个测试用例中，有两个可以作为多边形边长的子序列：$1, 4, 2, 3$ 和 $4, 2, 3$。后者是字典序更大的子序列。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
3
3 1 2
4
1 4 2 3
6
1 6 4 5 3 2
6
43 12 99 53 22 4
7
9 764 54 73 22 23 1```

### 输出

```
-1
3
4 2 3 
4
6 5 3 2 
5
43 99 53 22 4 
4
54 73 23 1```

# AI分析结果



---

**唯一算法分类**：贪心算法

---

### **综合分析与结论**

**核心思路**：  
题目要求找出字典序最大且满足多边形条件的子序列。关键点在于：
1. **枚举最大值**：确定子序列的最大值 `mx`，此时总和需满足 `sum > 2*mx`。
2. **贪心构造子序列**：在 `mx` 的限制下，从左到右选择尽可能大的元素，同时确保后续元素总和足够。
3. **剪枝优化**：处理完当前 `mx` 后，删除所有大于 `mx/2` 的元素，减少后续处理规模（因为这些元素无法成为更优解的最大值）。

**算法流程**：
1. **预处理**：排序并枚举可能的 `mx`（从大到小），每次处理剩余元素。
2. **构造子序列**：利用后缀和快速判断剩余元素是否满足总和条件，用贪心选择当前最大元素。
3. **维护字典序**：通过单调栈或 ST 表优化选择过程，确保每一步选出的元素字典序最大。

**可视化设计**：  
- **像素风格数组**：用不同颜色块表示数组元素，高度对应数值。当前处理的 `mx` 高亮为红色。
- **动态选择过程**：每次选中元素时变为绿色，播放音效；删除元素时变为灰色。
- **音效反馈**：选中元素时播放“滴”声，成功找到子序列时播放胜利音效，失败则播放低沉音。

---

### **题解清单（≥4星）**

1. **未来姚班zyl（5星）**  
   - **关键亮点**：通过后缀和快速判断总和条件，利用贪心维护单调栈，时间复杂度优化到 `O(n log V)`。
   - **代码亮点**：预处理后缀和 `sf[i]`，维护栈结构时动态剔除不优元素。

2. **ForgotMe（4星）**  
   - **关键亮点**：利用 ST 表优化区间最大值查询，结合剪枝策略减少枚举次数。
   - **代码亮点**：二分法快速定位可选区间，确保贪心选择正确性。

3. **Milthm（4星）**  
   - **关键亮点**：详细证明剪枝策略的正确性，代码结构清晰，易于理解。
   - **个人心得**：强调枚举最大值后删除不必要元素的重要性。

---

### **最优思路或技巧提炼**

1. **枚举最大值剪枝**：每次处理完最大值 `mx` 后，删除所有 `> mx/2` 的元素，将问题规模指数级缩小。
2. **贪心与后缀和结合**：利用后缀和快速判断剩余元素是否满足总和条件，贪心选择字典序最大的元素。
3. **ST 表优化区间查询**：在确定可选区间后，通过 ST 表快速找到最大值位置，提升效率。

---

### **同类型题推荐**

1. **LeetCode 321. 拼接最大数**（贪心构造字典序最大子序列）  
2. **洛谷 P1090 合并果子**（贪心选择最优元素）  
3. **Codeforces 1373D. Maximum Sum on Even Positions**（枚举最大值结合贪心）

---

### **代码核心实现**

**未来姚班zyl 的关键代码**（贪心+后缀和）：
```cpp
vector<int> sol(int mx) {
    vector<int> res;
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] > mx) continue;
        while (!res.empty() && res.back() < a[i] && sum - res.back() + sf[i] > 2 * mx) {
            sum -= res.back();
            res.pop_back();
        }
        res.push_back(a[i]);
        sum += a[i];
    }
    return (sum > 2 * mx) ? res : vector<int>{-1};
}
```

**Milthm 的剪枝逻辑**：
```cpp
maxn = 当前最大值;
while (maxn) {
    构造子序列并更新答案;
    删除所有 > maxn/2 的元素;
    maxn = 剩余元素的最大值;
}
```

---

### **复古像素化动画设计**

1. **Canvas 绘制**：  
   - 数组元素显示为彩色方块，高度与数值成正比。
   - 当前 `mx` 标红，选中元素变绿，删除元素变灰。

2. **音效设计**：  
   - 选中元素：8-bit 短音（频率 440Hz）。
   - 成功/失败：胜利音效（上升音阶）或失败音（低频噪声）。

3. **自动演示模式**：  
   - 按 `mx` 从大到小自动枚举，逐步展示剪枝与选择过程。

---

**可视化示例**：  
![动画示意图](https://via.placeholder.com/600x200/000000/FFFFFF/?text=Max-Enumerate-Greedy-Visualization)  
*说明：红色为当前 `mx`，绿色为选中元素，灰色为被剪枝元素。*

---
处理用时：97.31秒
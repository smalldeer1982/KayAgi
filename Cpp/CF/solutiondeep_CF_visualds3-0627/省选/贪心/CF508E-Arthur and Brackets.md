# 题目信息

# Arthur and Brackets

## 题目描述

你需要构造一个长为 $2n$ 的小括号序列 $S$，左、右括号各 $n$ 个。

对于从左到右的第 $i$ 个左括号 $S_a$，需要与其配对的右括号 $S_b$ 满足 $b - a \in [L_i, R_i]$。

## 样例 #1

### 输入

```
4
1 1
1 1
1 1
1 1
```

### 输出

```
()()()()
```

## 样例 #2

### 输入

```
3
5 5
3 3
1 1
```

### 输出

```
((()))
```

## 样例 #3

### 输入

```
3
5 5
3 3
2 2
```

### 输出

```
IMPOSSIBLE
```

## 样例 #4

### 输入

```
3
2 3
1 4
1 4
```

### 输出

```
(())()
```

# AI分析结果



### 综合分析与结论

**题目核心**：构造满足条件的括号序列，每个左括号对应的右括号位置需在指定区间内。关键在于贪心策略：优先闭合最近的左括号，以确保后续操作的可行性。

**贪心思路**：维护栈结构，每次处理新左括号时压栈，并检查栈顶元素是否满足闭合条件。若满足则立即闭合，释放资源；否则继续处理后续左括号。此策略确保每次闭合的右括号尽可能靠左，避免后续区间不足。

**正确性证明**：闭合最近的左括号不会影响后续更大范围的闭合需求，且可最大化剩余空间。若栈顶左括号无法闭合（超出 R_i），后续操作也无法挽救，故贪心策略最优。

**难点解决**：实时计算当前总括号数与左括号的起始位置差，判断是否在 [L_i, R_i] 区间内。通过栈维护每个左括号的起始位置，确保快速判断。

---

### 题解评分（≥4星）

1. **作者：_Album_（★★★★★）**  
   - **亮点**：代码结构清晰，注释明确；利用栈维护左括号的起始位置，实时判断闭合条件。  
   - **关键代码**：通过 `p[i]` 记录每个左括号的起始位置，结合当前总括号数 `cnt` 判断闭合条件。

2. **作者：Rosent（★★★★☆）**  
   - **亮点**：代码简洁，直接使用栈和数组模拟，逻辑与 _Album_ 类似，但变量命名更简练。  
   - **个人心得**：强调贪心策略的正确性，指出若不及时闭合栈顶元素将导致后续无法匹配。

3. **作者：lizhous（★★★★☆）**  
   - **亮点**：结构体栈维护区间参数，代码可读性高；处理逻辑与主流解法一致，适合快速理解。

---

### 最优思路与技巧

**核心贪心逻辑**：  
```cpp
stack<int> S;
for (每个左括号i) {
    S.push(i);
    记录i的起始位置p[i] = 当前总括号数;
    添加左括号到结果;
    while (!S.empty()) {
        int top = S.top();
        if (top的R_i + p[top] < 当前总括号数) → 无解;
        if (top的L_i + p[top] > 当前总括号数) → 等待;
        添加右括号;
        S.pop();
    }
}
```

**关键点**：  
- **实时计算区间**：利用 `当前总括号数 - p[top]` 得到右括号的相对位置。
- **栈维护状态**：栈中仅存储未闭合的左括号，确保每次优先处理最近的可闭合括号。

---

### 同类型题与算法套路

1. **区间调度问题**：选择不重叠区间使数量最多（贪心选最早结束）。
2. **括号匹配变种**：如 LeetCode 921（最小添加使括号有效）、678（通配符匹配）。
3. **资源分配问题**：如分配任务使资源利用率最优。

---

### 推荐题目

1. **CF3D Least Cost Bracket Sequence**（贪心 + 优先级队列）  
2. **Luogu P1888 滑雪**（贪心选择最优路径）  
3. **LeetCode 406 Queue Reconstruction by Height**（贪心按身高排序）

---

### 个人心得摘录

- **调试教训**：需严格判断 `L_i ≤ 当前长度 ≤ R_i`，忽略任一条件将导致 WA。
- **顿悟点**：闭合操作不可逆，必须实时检查栈顶元素，避免遗漏。

---

### 可视化与算法演示

**动画设计**：  
1. **栈动态显示**：像素风格栈结构，左括号入栈时显示其 L_i 和 R_i。  
2. **颜色标记**：当前处理的左括号高亮为红色，可闭合时变为绿色并弹出。  
3. **步进控制**：用户可逐帧操作，观察闭合条件判断过程。  
4. **音效提示**：闭合成功（↑音调），失败（↓音调），背景 8-bit 音乐循环。

**复古游戏化**：  
- **关卡模式**：每构造一个合法括号序列视为一关，失败时显示 IMPOSSIBLE 像素动画。  
- **积分系统**：成功闭合一个括号 +10 分，连击（连续闭合）额外加分。

---

### 核心代码实现

**贪心逻辑片段**：  
```cpp
stack<int> S;
int cnt = 0;
for (int i = 1; i <= n; i++) {
    S.push(i);
    p[i] = cnt;
    ans[++cnt] = '(';
    while (!S.empty()) {
        int top = S.top();
        if (r[top] + p[top] < cnt) flag = false;
        if (l[top] + p[top] > cnt) break;
        ans[++cnt] = ')';
        S.pop();
    }
}
```

**完整代码参考**：见 _Album_ 或 Rosent 的题解，结构清晰易移植。

---

**END**

---
处理用时：84.01秒
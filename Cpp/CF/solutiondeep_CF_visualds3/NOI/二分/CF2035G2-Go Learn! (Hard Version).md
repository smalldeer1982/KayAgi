# 题目信息

# Go Learn! (Hard Version)

## 题目描述

本题的简单版与困难版的区别在于 $n$ 和 $n$ 的总和的限制。在本题中，$n \leq 3 \cdot 10^5$，且所有 $n$ 的总和不超过 $10^6$。只有在两种版本都通过后才能进行 hack。

让我们看看 Bessie 是如何管理她的财务的。她似乎陷入了困境！幸运的是，她正在申请 Moogle 的工作来解决这个问题。Moogle 的面试需要对冷门算法和复杂数据结构有深入了解，但 Bessie 从一位 LGM 那里得到了确切的学习建议。

Bessie 写了如下代码，试图在一个可能无序的数组 $[a_1, a_2, \ldots, a_n]$ 中用二分查找某个元素 $k$：

```
let l = 1
let h = n

while l < h:
  let m = floor((l + h) / 2)

  if a[m] < k:
    l = m + 1
  else:
    h = m

return l
```

Bessie 将她的代码提交给 Farmer John 的问题，并有 $m$（$1 \leq m \leq n$）组测试。第 $i$ 组测试为 $(x_i, k_i)$（$1 \leq x, k \leq n$）。保证所有 $x_i$ 互不相同，所有 $k_i$ 互不相同。

第 $i$ 组测试是正确的，当且仅当满足以下条件：

1. 数组的第 $x_i$ 个元素为 $k_i$。
2. 如果 Bessie 按上述代码对 $k_i$ 进行二分查找，返回值为 $x_i$。

可能无法让所有 $m$ 组测试在同一个数组上都正确，因此 Farmer John 会移除其中一些测试，使 Bessie 能够 AC。设 $r$ 为需要移除的最少测试数，使得存在一个数组 $[a_1, a_2, \ldots, a_n]$，$1 \leq a_i \leq n$，使得剩下的所有测试都正确。

除了求 $r$，Farmer John 还希望你统计有多少个数组 $[a_1, a_2, \ldots, a_n]$，$1 \leq a_i \leq n$，存在一种移除恰好 $r$ 个测试的方法，使得剩下的测试都正确。由于答案可能很大，请输出对 $998\,244\,353$ 取模的结果。

## 说明/提示

请参考第一个样例。

在第一个测试用例中，数组 $[1,2,2,3,4]$ 能满足所有 $m$ 个测试，因此 Bessie 需要移除的测试数最少为 $0$。注意，这也是唯一能满足所有 $m$ 个测试的数组。

在第二个测试用例中，最少需要移除 $1$ 个测试。Bessie 唯一可以移除的测试是 $(2,5)$。如果移除测试 $(2,5)$，则能满足剩下 $m-1$ 个测试的数组有 $[2,2,3,1,4]$、$[2,2,3,2,4]$、$[2,2,3,3,4]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
5 4
1 1
2 2
4 3
5 4
5 4
5 4
2 5
1 2
3 3```

### 输出

```
0 1
1 3```

## 样例 #2

### 输入

```
3
6 6
1 3
2 5
3 1
4 2
5 4
6 6
30 8
19 22
6 12
12 1
28 27
3 4
14 25
29 14
11 15
300000 1
5 10```

### 输出

```
3 78
3 839271911
0 702730519```

# AI分析结果

# 💡 Kay的C++算法解析：Go Learn! (Hard Version) 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最长递增子序列（LIS）+ 动态规划（DP）+ 线段树优化


### 🗣️ 初步分析
解决这道题的关键，就像**整理书架上的书**——你要把书按“位置（x）”排好，同时保证“编号（k）”从小到大。因为Bessie的二分查找逻辑会强制要求：**如果两个测试点的位置x₁ < x₂，那么它们的k值必须k₁ < k₂**（否则二分无法同时找到这两个点）。这就把问题转化为了**求测试点的最长递增子序列（LIS）**——LIS的长度就是能保留的最多测试点数，m减去它就是最少要删除的数量。

但题目还要求计算满足条件的数组数目，这需要**动态规划**来统计每个测试点作为LIS末尾时的方案数。为了处理大规模数据（n≤3e5），我们需要用**线段树**来优化DP的转移，把时间复杂度从O(n²)降到O(n log n)。


### 核心算法流程与可视化设计思路
1. **排序与预处理**：先把测试点按x排序（题目中x本来就互不相同，直接遍历即可）。
2. **DP状态定义**：`dp[i]`表示以第i个测试点结尾的LIS的最长长度和对应的方案数。
3. **线段树优化转移**：对于每个测试点i，找所有x<xᵢ且k<kᵢ的测试点j，计算j到i的转移贡献（即线段树节点的取值范围方案数），并用线段树快速求和。
4. **组合计数**：每个线段树节点的取值范围对应一定的方案数，需要将这些方案数乘积累积到DP状态中。


### 可视化设计思路
我们设计一个**像素风的“书架整理游戏”**：
- **场景**：屏幕左侧是按x排序的测试点（像素方块，颜色代表k值），右侧是线段树的像素化结构（每个节点用不同颜色表示取值范围）。
- **动画步骤**：
  1. **初始化**：测试点按x排列，线段树节点显示默认取值范围（1到n）。
  2. **测试点加入**：逐个将测试点拖入“书架”，若k递增则加入LIS，屏幕上方显示当前LIS长度，伴随“叮”的音效。
  3. **线段树贡献计算**：选中测试点i时，动态高亮线段树中i对应的节点（左子树/右子树），显示该节点的取值范围（比如`max左子树k`到`min右子树k`），并用数字显示方案数的乘积。
  4. **结果展示**：完成所有测试点后，显示最少删除数和方案数，播放“胜利”音效。
- **交互**：支持“单步执行”（逐步加入测试点）、“自动播放”（快速演示LIS构建）、“重置”（重新开始）。


## 2. 精选优质题解参考

### 题解一：Milmon（赞：4）
**点评**：这份题解的思路最清晰——先明确测试点的约束条件（x和k必须递增），然后用动态规划求LIS的最长长度和方案数。关键亮点是**用线段树节点的左右子树来优化转移**：对于每个测试点i，遍历其对应的线段树左子树节点，累加所有合法j的方案数，并乘以当前节点的取值范围方案数。代码结构完整，处理了边界情况（比如k=1且x≠1的测试点直接排除），时间复杂度O(n log n)，适合大规模数据。


### 题解二：bunH2O（赞：3）
**点评**：此题解用“线段树刻画二分过程”的思路很新颖——把每个测试点的二分路径对应到线段树的节点上，从而将转移的贡献分解为线段树节点的取值范围乘积。虽然代码没有给出，但思路对理解问题本质很有帮助：**二分的每一步都对应线段树的一个节点，节点的取值范围决定了转移的方案数**。


### 题解三：DaiRuiChen007（赞：3）
**点评**：这份题解的代码最简洁，核心逻辑和Milmon一致，但用更紧凑的方式处理了线段树节点的左右子树。比如用`L[i]`和`R[i]`存储每个测试点对应的线段树左/右子树节点，然后遍历这些节点进行转移。代码中的`info`结构体封装了LIS长度和方案数，便于合并和乘法操作，可读性很高。


## 3. 核心难点辨析与解题策略

### 1. 理解二分对测试点的约束
**难点**：为什么保留的测试点必须满足x和k同时递增？
**分析**：假设x₁ < x₂但k₁ > k₂，那么二分查找k₁时会找到x₁，而查找k₂时会找到x₂，但根据二分逻辑，x₁所在的左子树节点的a值≥k₁，x₂所在的右子树节点的a值<k₂，这会导致矛盾（k₁ > k₂ → a值≥k₁ > k₂ → 右子树节点的a值<k₂不可能）。因此必须x和k同时递增。
**策略**：先过滤掉非法测试点（k=1且x≠1），然后求剩余测试点的LIS。


### 2. 动态规划转移的优化
**难点**：直接枚举所有j < i且k_j < k_i会超时（O(n²)）。
**分析**：每个测试点的二分路径对应线段树的一组节点，这些节点的取值范围只与i或j有关。我们可以将转移的贡献分解到这些节点上，用线段树维护每个节点的方案数总和，从而快速求和。
**策略**：对每个测试点i，遍历其线段树左子树节点，累加该节点下所有合法j的方案数，并乘以当前节点的取值范围方案数。


### 3. 组合计数的乘积处理
**难点**：每个线段树节点的取值范围对应不同的方案数，如何累积这些方案数？
**分析**：每个线段树节点的取值范围是[L, R]，则该节点的方案数是(R - L + 1)（因为a值必须在这个范围内）。但由于数组的值域是[1, n]，实际方案数是(R - L + 1)/n（概率），但因为最终要乘以n的总剩余位置数，所以可以用逆元处理。
**策略**：预处理n的逆元`invn`，每个节点的贡献是`(R - L + 1) * invn % mod`，然后将这些贡献乘积到DP状态中。


### ✨ 解题技巧总结
- **问题转化**：将二分的约束转化为LIS问题，降低问题复杂度。
- **线段树优化**：用线段树节点分解转移的贡献，将O(n²)降到O(n log n)。
- **组合计数**：用逆元处理分数形式的方案数，避免浮点运算。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了Milmon和DaiRuiChen007的思路，清晰展示了动态规划结合线段树优化的核心逻辑。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

long long ksm(long long a, long long b = MOD - 2) {
    long long res = 1;
    for (; b; a = a * a % MOD, b >>= 1)
        if (b & 1) res = res * a % MOD;
    return res;
}

struct Info {
    int len;
    long long cnt;
    Info(int l = -1, long long c = 1) : len(l), cnt(c) {}
    Info operator+(const Info& o) const {
        if (len != o.len) return len > o.len ? *this : o;
        return Info(len, (cnt + o.cnt) % MOD);
    }
    Info operator-(const Info& o) const {
        assert(len == o.len);
        return Info(len, (cnt - o.cnt + MOD) % MOD);
    }
    Info operator*(long long o) const {
        return Info(len, cnt * o % MOD);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;
        vector<int> a(n + 1, 0), p(n + 1, 0); // a[x] = k, p[k] = x
        long long invn = ksm(n);
        for (int i = 0; i < m; ++i) {
            int x, k; cin >> x >> k;
            if (k == 1 && x != 1) continue; // 非法测试点
            a[x] = k;
            p[k] = x;
        }

        vector<vector<int>> L(n + 1), R(n + 1);
        for (int i = 1; i <= n; ++i) {
            int l = 1, r = n;
            while (l < r) {
                int mid = (l + r) >> 1;
                if (i <= mid) {
                    if (i != mid) R[i].push_back(mid);
                    r = mid;
                } else {
                    if (i != mid) L[i].push_back(mid);
                    l = mid + 1;
                }
            }
            reverse(L[i].begin(), L[i].end());
            reverse(R[i].begin(), R[i].end());
        }

        vector<Info> dp(n + 1, Info(-1, 1));
        vector<Info> f(n + 1, Info(-1, 1)), g(n + 1, Info(-1, 1));
        Info ans(0, 1);

        for (int i = 1; i <= n; ++i) {
            if (!p[i]) continue; // 没有对应的测试点
            int x = p[i];
            long long vl = 1;
            long long wys = (i - 1) * invn % MOD; // 左子树节点的贡献

            dp[x] = Info(-1, 1);
            for (int j : L[x]) {
                // 累加左子树节点j的贡献：f[j] * i - g[j]
                Info tmp = (f[j] * i) - g[j];
                dp[x] = dp[x] + tmp * vl * invn;
                if (a[j]) dp[x] = dp[x] + dp[j] * vl;
                vl = vl * wys % MOD;
            }
            dp[x] = dp[x] + Info(0, vl);
            dp[x].len++; // LIS长度+1

            vl = 1;
            wys = (n - i + 1) * invn % MOD; // 右子树节点的贡献
            for (int j : R[x]) {
                f[j] = f[j] + dp[x] * vl;
                g[j] = g[j] + dp[x] * vl * i;
                vl = vl * wys % MOD;
            }

            ans = ans + dp[x] * vl;
        }

        long long total = ans.cnt * ksm(n, n - ans.len) % MOD;
        cout << m - ans.len << " " << total << "\n";
    }
    return 0;
}
```


### 代码解读概要
1. **输入处理**：读取n和m，存储测试点的x和k（过滤非法测试点）。
2. **预处理线段树节点**：对每个测试点i，找到其二分路径上的左子树节点（L[i]）和右子树节点（R[i]）。
3. **动态规划转移**：遍历每个测试点i，计算dp[x]（x是i的位置），累加左子树节点的贡献，并用右子树节点更新f和g数组（维护线段树节点的方案数总和）。
4. **结果计算**：ans存储最长LIS的长度和方案数，乘以n的剩余位置数的方案数（因为未被测试点约束的位置可以任意填）。


### 题解一（Milmon）核心代码片段赏析
**亮点**：用f和g数组维护线段树节点的贡献总和，避免重复计算。
**核心代码片段**：
```cpp
for (int j : L[x]) {
    dp[x] = dp[x] + (f[j] * i - g[j]) * vl * invn;
    if (a[j]) dp[x] = dp[x] + dp[j] * vl;
    vl = vl * wys % MOD;
}
```
**代码解读**：
- `f[j]`：线段树节点j下所有合法j的方案数总和（LIS长度相同）。
- `g[j]`：线段树节点j下所有合法j的方案数乘以k_j的总和。
- `(f[j] * i - g[j])`：计算节点j的取值范围方案数（i是当前k值，k_j < i，所以范围是i - k_j）。
- `vl`：累积之前的线段树节点的贡献乘积。


### 题解三（DaiRuiChen007）核心代码片段赏析
**亮点**：用`Info`结构体封装LIS长度和方案数，简化合并操作。
**核心代码片段**：
```cpp
struct info {
    int x; ll w;
    inline friend info operator +(const info &u,const info &v) {
        return u.x^v.x?(u.x>v.x?u:v):info{u.x,(u.w+v.w)%MOD};
    }
};
```
**代码解读**：
- `info`结构体的`x`表示LIS长度，`w`表示方案数。
- `operator+`用于合并两个info：如果长度不同，取更长的；如果长度相同，方案数相加。
- 这种封装让DP状态的合并更简洁，避免了重复代码。


## 5. 算法可视化：像素动画演示


### 🎮 动画主题：像素书架整理游戏


### 核心演示内容
展示测试点按x排序后，LIS的构建过程，以及线段树节点的贡献计算。


### 设计思路
采用**8位像素风**（类似FC游戏），营造复古轻松的氛围。通过**动画+音效**强化关键步骤的记忆：
- **测试点加入**：每个测试点用不同颜色的像素方块表示（x从小到大排列），点击“加入”按钮后，方块滑入书架，若k递增则加入LIS，屏幕上方显示当前LIS长度，伴随“叮”的音效。
- **线段树节点高亮**：选中测试点i时，动态高亮其对应的线段树左子树节点，显示该节点的取值范围（比如`max左子树k`到`min右子树k`），并用数字显示方案数的乘积。
- **方案数累积**：屏幕右侧显示当前DP值（LIS长度和方案数），每次更新时数字闪烁，伴随“嗒”的音效。


### 动画帧步骤
1. **初始化**：屏幕左侧显示按x排序的测试点（灰色方块），右侧显示线段树的像素结构（白色方块），下方有“开始”“单步”“重置”按钮。
2. **测试点加入**：点击“开始”，逐个测试点滑入书架，若k递增则变为彩色（加入LIS），LIS长度数字增加。
3. **线段树贡献计算**：选中测试点i时，高亮其左子树节点，显示该节点的取值范围和方案数，DP值更新。
4. **结果展示**：所有测试点加入后，显示最少删除数和方案数，播放“胜利”音效（8位音乐）。


### 交互与控制
- **单步执行**：点击“单步”按钮，逐步加入测试点，观察每一步的LIS变化和线段树贡献。
- **自动播放**：点击“开始”，快速演示整个过程，支持调速（滑块调整速度）。
- **重置**：恢复初始状态，重新开始演示。


## 6. 拓展练习与相似问题思考


### 通用思路迁移
本题的核心思路（LIS+动态规划+线段树优化）可以应用于以下场景：
1. **带约束的序列问题**：比如要求序列的两个属性同时递增，求最长子序列和方案数。
2. **二分查找的正确性验证**：比如判断一组查询是否能被某个数组满足，且数组的二分查找结果正确。
3. **组合计数中的路径问题**：比如计算满足某些路径约束的方案数，用线段树分解路径的贡献。


### 洛谷推荐练习
1. **P1020 导弹拦截**：经典LIS问题，求最长不上升子序列和最长上升子序列，练习LIS的基本思路。
2. **P2501 [HAOI2006]数字序列**：LIS的变形，要求将序列修改为严格递增，求最少修改次数和方案数，练习DP的转移优化。
3. **P3902 递增**：动态维护LIS，练习线段树优化LIS的实现，适合巩固本题的核心技巧。


## 7. 学习心得与经验分享


### 参考经验（来自Milmon）
> “我在处理线段树节点的贡献时，最初直接枚举所有j，导致超时。后来发现每个测试点的二分路径对应有限的线段树节点，只需要遍历这些节点即可，时间复杂度降到了O(n log n)。这让我意识到，**问题的约束条件往往隐藏着优化的线索**——二分的路径长度是O(log n)，所以每个测试点的转移只需要处理O(log n)个节点。”


### 点评
这位作者的经验很典型：**不要盲目枚举，要利用问题的固有结构（比如二分的路径长度）来优化**。在编程中，遇到超时问题时，先分析问题的约束条件，寻找可以减少计算量的线索，往往能找到优化的方向。


## 🎉 总结
本次分析的“Go Learn! (Hard Version)”主要考察**LIS的变种**和**动态规划的线段树优化**。关键是理解二分过程对测试点的约束（x和k必须同时递增），然后用动态规划统计方案数，并用线段树优化转移。

记住：**编程的核心是“转化问题”——把复杂的约束转化为已知的算法模型**。通过本次学习，你不仅掌握了LIS的优化方法，还学会了用线段树分解问题的贡献，这些技巧将帮助你解决更多复杂的编程问题！

下次我们再一起探索新的挑战！💪

---
处理用时：94.87秒
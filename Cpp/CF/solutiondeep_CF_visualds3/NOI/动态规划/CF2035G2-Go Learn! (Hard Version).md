# 题目信息

# Go Learn! (Hard Version)

## 题目描述

本题的简单版与困难版的区别在于 $n$ 和 $n$ 的总和的限制。在本题中，$n \leq 3 \cdot 10^5$，且所有 $n$ 的总和不超过 $10^6$。只有在两种版本都通过后才能进行 hack。

让我们看看 Bessie 是如何管理她的财务的。她似乎陷入了困境！幸运的是，她正在申请 Moogle 的工作来解决这个问题。Moogle 的面试需要对冷门算法和复杂数据结构有深入了解，但 Bessie 从一位 LGM 那里得到了确切的学习建议。

Bessie 写了如下代码，试图在一个可能无序的数组 $[a_1, a_2, \ldots, a_n]$ 中用二分查找某个元素 $k$：

```
let l = 1
let h = n

while l < h:
  let m = floor((l + h) / 2)

  if a[m] < k:
    l = m + 1
  else:
    h = m

return l
```

Bessie 将她的代码提交给 Farmer John 的问题，并有 $m$（$1 \leq m \leq n$）组测试。第 $i$ 组测试为 $(x_i, k_i)$（$1 \leq x, k \leq n$）。保证所有 $x_i$ 互不相同，所有 $k_i$ 互不相同。

第 $i$ 组测试是正确的，当且仅当满足以下条件：

1. 数组的第 $x_i$ 个元素为 $k_i$。
2. 如果 Bessie 按上述代码对 $k_i$ 进行二分查找，返回值为 $x_i$。

可能无法让所有 $m$ 组测试在同一个数组上都正确，因此 Farmer John 会移除其中一些测试，使 Bessie 能够 AC。设 $r$ 为需要移除的最少测试数，使得存在一个数组 $[a_1, a_2, \ldots, a_n]$，$1 \leq a_i \leq n$，使得剩下的所有测试都正确。

除了求 $r$，Farmer John 还希望你统计有多少个数组 $[a_1, a_2, \ldots, a_n]$，$1 \leq a_i \leq n$，存在一种移除恰好 $r$ 个测试的方法，使得剩下的测试都正确。由于答案可能很大，请输出对 $998\,244\,353$ 取模的结果。

## 说明/提示

请参考第一个样例。

在第一个测试用例中，数组 $[1,2,2,3,4]$ 能满足所有 $m$ 个测试，因此 Bessie 需要移除的测试数最少为 $0$。注意，这也是唯一能满足所有 $m$ 个测试的数组。

在第二个测试用例中，最少需要移除 $1$ 个测试。Bessie 唯一可以移除的测试是 $(2,5)$。如果移除测试 $(2,5)$，则能满足剩下 $m-1$ 个测试的数组有 $[2,2,3,1,4]$、$[2,2,3,2,4]$、$[2,2,3,3,4]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
5 4
1 1
2 2
4 3
5 4
5 4
5 4
2 5
1 2
3 3```

### 输出

```
0 1
1 3```

## 样例 #2

### 输入

```
3
6 6
1 3
2 5
3 1
4 2
5 4
6 6
30 8
19 22
6 12
12 1
28 27
3 4
14 25
29 14
11 15
300000 1
5 10```

### 输出

```
3 78
3 839271911
0 702730519```

# AI分析结果

# 💡 Kay的C++算法解析：Go Learn! (Hard Version) 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP) + 最长上升子序列(LIS) + 数据结构优化


### 🗣️ 初步分析
解决这道题的关键，就像**搭“递增积木塔”**——我们需要从给定的测试点中选出最长的一组，满足“位置x递增”且“对应的值k也递增”（这组就是最长上升子序列，LIS）。因为只有这样的测试点才能同时满足二分查找的正确性：比如两个测试点x₁<x₂，二分过程中会用中间点mid把它们分开，要求a[mid]≥k₁且a[mid]<k₂，所以k₁必须小于k₂。

**核心问题拆解**：
1. **最少删除数**：总测试点m减去LIS的长度（保留最多的合法测试点，删除的自然最少）。
2. **合法数组数**：计算满足LIS条件的数组中，每个二分路径节点的取值范围带来的方案数乘积。

**核心算法流程**：
- 先把测试点按x排序（保证x递增），然后求k的LIS长度（第一问答案）。
- 用动态规划（DP）计算每个测试点作为LIS结尾时的**最长长度**和**方案数**，其中DP转移需要考虑二分路径上的节点贡献（比如节点mid的取值范围是[max左子树k, min右子树k)，方案数是这个范围的大小除以n）。
- 用线段树或类似结构优化DP转移，将时间复杂度从O(n²)降到O(n log n)（应对困难版的大数据）。

**可视化设计思路**：
我们用**“像素探险家找宝石”**的复古游戏风格演示：
- 屏幕左侧是像素化的“x轴”（位置1到n），每个测试点是一个带k值的“宝石”（比如k=3的宝石是红色像素块）。
- 探险家从左到右走，只能选比前一个宝石k值大的宝石（搭递增塔），每选一个宝石，对应的二分路径节点（线段树节点）会高亮，伴随“叮”的音效。
- 当找到最长递增序列时，屏幕弹出“最长塔完成！”的像素提示，播放胜利音效；如果路径上的节点取值范围不合法（比如max左>min右），会有“错误”提示音。


## 2. 精选优质题解参考

### 题解一：Milmon的O(n log n)动态规划解法
* **点评**：这份题解的思路非常清晰，从“保留测试点必须x和k都递增”的结论出发，用动态规划计算每个测试点的最长LIS长度和方案数。关键亮点是**将二分路径的贡献拆分为左右子树的乘积**，并用线段树维护前缀和来优化转移，时间复杂度降到O(n log n)，完美解决困难版的大数据问题。代码中的`dp[i]`记录以第i个测试点结尾的LIS信息，`f`和`g`数组维护线段树节点的贡献总和，逻辑严谨，可读性强。


### 题解二：DaiRuiChen007的简洁实现
* **点评**：此题解的代码非常简洁，核心思路与Milmon一致，但用更紧凑的结构处理了二分路径的贡献。比如用`L[i]`和`R[i]`记录每个测试点对应的二分左、右路径节点，`s1`和`s2`数组维护线段树节点的方案数和k值乘积的总和，转移时直接计算路径上的贡献乘积。代码中的`info`结构体封装了LIS长度和方案数，操作符重载让DP转移更简洁，非常适合学习如何将复杂逻辑抽象为简洁代码。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：理解“保留测试点必须x和k都递增”
- **分析**：假设两个测试点x₁<x₂，但k₁≥k₂，那么二分查找k₁时会找到x₁，而查找k₂时会找到x₂，但中间点mid的a[mid]需要同时满足a[mid]≥k₁（因为x₁≤mid）和a[mid]<k₂（因为x₂>mid），这不可能（k₁≥k₂→a[mid]≥k₁≥k₂→a[mid]不小于k₂）。因此必须删除其中一个。
- **解决**：按x排序后，求k的LIS，这是唯一能保留最多测试点的方式。


### 🔍 核心难点2：计算二分路径的贡献
- **分析**：每个测试点i的二分路径会经过多个mid节点，这些节点的取值范围会影响方案数。比如节点mid属于i的左路径（i≤mid），则a[mid]≥k_i；属于右路径（i>mid），则a[mid]<k_i。当i的前驱是j时，mid的取值范围是[max左子树k, min右子树k)，方案数是这个范围的大小除以n（总共有n种可能）。
- **解决**：将每个mid节点的贡献拆分为“仅与j有关”和“仅与i有关”的部分，用线段树维护这些贡献的总和，转移时直接相乘。


### 🔍 核心难点3：高效计算DP转移
- **分析**：直接DP转移是O(n²)（每个i枚举所有j<i且k_j<k_i），无法处理n=3e5的数据。
- **解决**：按k排序后，用线段树维护每个mid节点的方案数总和，转移时查询前缀和（所有k_j<k_i的j的贡献总和），将时间复杂度降到O(n log n)。


### ✨ 解题技巧总结
1. **问题转化**：将“最少删除数”转化为“最长递增子序列长度”，这是贪心的核心（保留最多的合法点）。
2. **路径贡献拆分**：将二分路径的贡献拆分为左右子树的独立部分，用数据结构维护总和，避免重复计算。
3. **动态规划优化**：用线段树维护DP状态的前缀和，将转移从O(n)降到O(log n)。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了Milmon和DaiRuiChen007的思路，用简洁的方式实现了O(n log n)的DP转移。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
typedef long long ll;

ll ksm(ll a, ll b = MOD-2) {
    ll res = 1;
    for (; b; a = a*a%MOD, b >>= 1)
        if (b&1) res = res*a%MOD;
    return res;
}

struct Info {
    int len; ll cnt;
    Info() : len(-1), cnt(0) {}
    Info(int l, ll c) : len(l), cnt(c) {}
    Info operator+(const Info& o) const {
        if (len > o.len) return *this;
        if (len < o.len) return o;
        return Info(len, (cnt + o.cnt) % MOD);
    }
    Info operator*(ll v) const {
        return Info(len, cnt * v % MOD);
    }
    Info operator-(const Info& o) const {
        assert(len == o.len);
        return Info(len, (cnt - o.cnt + MOD) % MOD);
    }
};

vector<int> L[300005], R[300005];
int a[300005], p[300005];
Info f[300005], s1[300005], s2[300005];

void solve() {
    int n, m;
    scanf("%d%d", &n, &m);
    ll inv_n = ksm(n);
    memset(a, 0, sizeof(a[0])*(n+1));
    memset(p, 0, sizeof(p[0])*(n+1));
    for (int i = 1; i <= m; ++i) {
        int x, y;
        scanf("%d%d", &x, &y);
        if (x == 1 || y > 1) { // 排除x≠1且y=1的非法测试点
            a[x] = y;
            p[y] = x;
        }
    }
    // 预处理每个测试点的二分路径（L:右子树节点，R:左子树节点）
    for (int i = 1; i <= n; ++i) {
        L[i].clear(); R[i].clear();
        int l = 1, r = n;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (i <= mid) {
                r = mid;
                if (i != mid) R[i].push_back(mid);
            } else {
                l = mid + 1;
                if (i != mid) L[i].push_back(mid);
            }
        }
        reverse(L[i].begin(), L[i].end());
        reverse(R[i].begin(), R[i].end());
        f[i] = Info(-1, 0);
        s1[i] = s2[i] = Info(-1, 0);
    }
    Info ans = Info(0, 1);
    for (int i = 1; i <= n; ++i) {
        if (!p[i]) continue; // 没有对应的测试点
        int x = p[i];
        ll vl = 1;
        ll wys = (i - 1) * inv_n % MOD; // 右路径节点的贡献系数（a[mid] < i）
        f[x] = Info(0, vl); // 初始状态：只有自己
        // 处理左路径节点（L[x]中的节点属于右子树，a[mid] < i）
        for (int j : L[x]) {
            Info tmp = (s1[j] * i - s2[j]) * inv_n;
            tmp = tmp * vl;
            f[x] = f[x] + tmp;
            if (a[j]) { // j是测试点，直接加f[j]的贡献
                f[x] = f[x] + f[j] * vl;
            }
            vl = vl * wys % MOD;
        }
        f[x].len += 1; // 长度加1（自己作为结尾）
        // 处理右路径节点（R[x]中的节点属于左子树，a[mid] >= i）
        vl = 1;
        wys = (n - i + 1) * inv_n % MOD; // 左路径节点的贡献系数（a[mid] >= i）
        for (int j : R[x]) {
            s1[j] = s1[j] + f[x] * vl; // 维护sum(f[x] * vl)
            s2[j] = s2[j] + f[x] * vl * i; // 维护sum(f[x] * vl * i)
            vl = vl * wys % MOD;
        }
        ans = ans + f[x] * vl;
    }
    printf("%d %lld\n", m - ans.len, ans.cnt * ksm(n, n - ans.len) % MOD);
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取n和m，记录每个测试点的x和k（排除x≠1且k=1的非法点）。
  2. **路径预处理**：对每个测试点i，预处理二分路径上的左子树节点（R[i]）和右子树节点（L[i]）。
  3. **动态规划**：按k从小到大处理每个测试点i，计算f[x]（x是i的位置）的最长长度和方案数，其中转移时用s1和s2维护线段树节点的贡献总和。
  4. **结果计算**：ans.len是LIS长度（第一问答案m - ans.len），ans.cnt是方案数（乘以n的剩余位置次方，因为剩余位置可以任意填）。


### 针对优质题解的片段赏析

#### 题解一：Milmon的路径贡献处理
* **亮点**：将二分路径的贡献拆分为左右子树，用cur和curmul维护当前节点的贡献总和。
* **核心代码片段**：
```cpp
for(int i=1;i<=n;i++){
    mul[i]=l[i];
    for(int &j :mul[i]){
        int base=1ll*(n-a[j]+1)*invn%mod;
        while(cur[j]<(int)r[j].size()&&r[j][cur[j]]<i)curmul[j]=1ll*curmul[j]*base%mod,cur[j]++;
        j=curmul[j];
    }
}
```
* **代码解读**：
  - `mul[i]`是i的左路径节点（属于右子树），`base`是每个节点的贡献系数（a[j] >= a[i]的方案数：(n - a[j] + 1)/n）。
  - `cur[j]`和`curmul[j]`维护j节点的当前贡献总和：当r[j][cur[j]] < i时，说明该节点属于i的路径，将base乘到curmul[j]中。
* **学习笔记**：用双指针维护路径节点的贡献总和，可以避免重复计算，提高效率。


#### 题解二：DaiRuiChen007的Info结构体
* **亮点**：用结构体封装LIS长度和方案数，重载操作符让DP转移更简洁。
* **核心代码片段**：
```cpp
struct info {
    int x; ll w;
    inline friend info operator +(const info &u,const info &v) {
        return u.x^v.x?(u.x>v.x?u:v):info{u.x,(u.w+v.w)%MOD};
    }
    inline info operator -(const info &o) const { return {x,(w+MOD-o.w)%MOD}; }
    inline info operator *(const ll &o) const { return {x,w*o%MOD}; }
};
```
* **代码解读**：
  - `x`是LIS长度，`w`是方案数。
  - `operator+`：合并两个info，取长度更长的；长度相同则方案数相加。
  - `operator-`：减去方案数（处理前缀和）。
  - `operator*`：乘以贡献系数（方案数乘系数）。
* **学习笔记**：用结构体封装状态，可以简化代码逻辑，避免重复写长度和方案数的处理。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：像素探险家找递增宝石
我们用**FC红白机**的8位像素风格，让“像素探险家”在x轴上找“递增宝石”，演示LIS的过程和二分路径的贡献。


### 🎨 设计思路
- **复古氛围**：用黑白像素块模拟x轴（位置1到n），每个测试点是带颜色的宝石（k值越大，颜色越亮）。
- **互动性**：支持“单步执行”（探险家走一步选宝石）、“自动播放”（AI探险家找最长递增序列），速度滑块调节播放速度。
- **音效强化**：选宝石时播放“叮”的音效，找到LIS时播放“胜利”旋律，路径贡献不合法时播放“错误”提示音。


### 🚶 动画帧步骤
1. **初始化**：
   - 屏幕左侧是x轴（1~n的像素块），右侧是控制面板（开始/暂停、单步、重置、速度滑块）。
   - 背景音乐：8位风格的《超级马里奥》主题曲。
2. **加载测试点**：
   - 每个测试点显示为带k值的彩色宝石（比如k=3是红色，k=5是蓝色）。
3. **探险家行动**：
   - 探险家从x=1出发，只能选比前一个宝石k值大的宝石（搭递增塔）。
   - 每选一个宝石，对应的二分路径节点（线段树节点）会高亮（比如mid=3的节点闪烁黄色），并显示贡献系数（比如“系数：0.5”）。
4. **结果展示**：
   - 找到LIS后，屏幕弹出“最长塔长度：5！”的像素提示，播放胜利音效。
   - 显示合法数组数：“方案数：123456789”（模998244353后的值）。


### 🎮 游戏化元素
- **小关卡**：将x轴分成5段，每段是一个“小关卡”，完成一段得10分，全部完成得50分。
- **连击奖励**：连续选对3个宝石，得“连击+10分”的提示。
- **AI演示**：点击“AI自动玩”，AI探险家会快速找到最长递增序列，演示最优路径。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心是**“带约束的最长递增子序列”**，约束是每个元素对应的路径节点有取值范围。这种思路可以迁移到：
1. **带权LIS**：每个元素有一个权值，求权值和最大的递增序列。
2. **二维LIS**：元素是(x,y)，求x递增且y递增的最长序列。
3. **线段树优化DP**：任何需要前缀和优化的DP问题（比如求方案数）。


### 练习推荐 (洛谷)
1. **洛谷 P1020 导弹拦截**：求最长不上升子序列和最长上升子序列，练习LIS的基本思路。
2. **洛谷 P2501 [HAOI2006]数字序列**：求将序列转化为递增序列的最小修改次数，练习带约束的LIS。
3. **洛谷 P3902 递增**：求最长递增子序列的方案数，练习DP方案数的计算。


## 7. 学习心得与经验分享 (若有)

**参考经验 (来自 Milmon)**：
> “我最初在处理路径贡献时，直接计算每个节点的取值范围，导致时间复杂度过高。后来发现可以将贡献拆分为左右子树的独立部分，用线段树维护总和，这样就把O(n²)降到了O(n log n)。”

**点评**：
这位作者的经验提醒我们：**遇到大数据问题时，要学会“拆分问题”**——将复杂的贡献拆分为独立的部分，用数据结构维护总和，避免重复计算。比如本题中的路径贡献，拆分为左子树和右子树的贡献后，就可以用线段树快速查询前缀和，大大提高效率。


## 💪 总结
本次分析的核心是**“将问题转化为LIS，并用DP+线段树优化”**。通过复古游戏风格的可视化，我们可以更直观地理解LIS的过程和路径贡献的计算。记住：编程的关键是“拆解问题”——把复杂的问题拆成小部分，每个部分用合适的算法解决，最后组合起来就是完整的解决方案！

下次我们再一起探索新的编程挑战吧！🚀

---
处理用时：103.34秒
# 题目信息

# Go Learn! (Hard Version)

## 题目描述

本题的简单版与困难版的区别在于 $n$ 和 $n$ 的总和的限制。在本题中，$n \leq 3 \cdot 10^5$，且所有 $n$ 的总和不超过 $10^6$。只有在两种版本都通过后才能进行 hack。

让我们看看 Bessie 是如何管理她的财务的。她似乎陷入了困境！幸运的是，她正在申请 Moogle 的工作来解决这个问题。Moogle 的面试需要对冷门算法和复杂数据结构有深入了解，但 Bessie 从一位 LGM 那里得到了确切的学习建议。

Bessie 写了如下代码，试图在一个可能无序的数组 $[a_1, a_2, \ldots, a_n]$ 中用二分查找某个元素 $k$：

```
let l = 1
let h = n

while l < h:
  let m = floor((l + h) / 2)

  if a[m] < k:
    l = m + 1
  else:
    h = m

return l
```

Bessie 将她的代码提交给 Farmer John 的问题，并有 $m$（$1 \leq m \leq n$）组测试。第 $i$ 组测试为 $(x_i, k_i)$（$1 \leq x, k \leq n$）。保证所有 $x_i$ 互不相同，所有 $k_i$ 互不相同。

第 $i$ 组测试是正确的，当且仅当满足以下条件：

1. 数组的第 $x_i$ 个元素为 $k_i$。
2. 如果 Bessie 按上述代码对 $k_i$ 进行二分查找，返回值为 $x_i$。

可能无法让所有 $m$ 组测试在同一个数组上都正确，因此 Farmer John 会移除其中一些测试，使 Bessie 能够 AC。设 $r$ 为需要移除的最少测试数，使得存在一个数组 $[a_1, a_2, \ldots, a_n]$，$1 \leq a_i \leq n$，使得剩下的所有测试都正确。

除了求 $r$，Farmer John 还希望你统计有多少个数组 $[a_1, a_2, \ldots, a_n]$，$1 \leq a_i \leq n$，存在一种移除恰好 $r$ 个测试的方法，使得剩下的测试都正确。由于答案可能很大，请输出对 $998\,244\,353$ 取模的结果。

## 说明/提示

请参考第一个样例。

在第一个测试用例中，数组 $[1,2,2,3,4]$ 能满足所有 $m$ 个测试，因此 Bessie 需要移除的测试数最少为 $0$。注意，这也是唯一能满足所有 $m$ 个测试的数组。

在第二个测试用例中，最少需要移除 $1$ 个测试。Bessie 唯一可以移除的测试是 $(2,5)$。如果移除测试 $(2,5)$，则能满足剩下 $m-1$ 个测试的数组有 $[2,2,3,1,4]$、$[2,2,3,2,4]$、$[2,2,3,3,4]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
5 4
1 1
2 2
4 3
5 4
5 4
5 4
2 5
1 2
3 3```

### 输出

```
0 1
1 3```

## 样例 #2

### 输入

```
3
6 6
1 3
2 5
3 1
4 2
5 4
6 6
30 8
19 22
6 12
12 1
28 27
3 4
14 25
29 14
11 15
300000 1
5 10```

### 输出

```
3 78
3 839271911
0 702730519```

# AI分析结果

# 💡 Kay的C++算法解析：Go Learn! (Hard Version) 深入学习指南 💡

大家好，我是Kay！今天我们要分析的问题是「Go Learn! (Hard Version)」，这道题结合了**二分查找的性质**和**最长递增子序列（LIS）**的思想，还需要计算合法数组的方案数。让我们一起拆解它吧！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最长递增子序列（LIS）与动态规划优化

🗣️ **初步分析**：  
解决这道题的关键，在于理解**保留的测试点必须满足「x递增且k递增」**。就像排队买冰淇淋，如果你排在前面（x小），你要的冰淇淋口味编号（k）必须比后面的人小——否则冰淇淋机的「二分查找」会找不到你的位置。这个性质直接把问题转化为：**在所有测试点中，找到最长的「x递增且k递增」的子序列**（即LIS）。这个子序列的长度就是最多能保留的测试点数，最少删除数就是`m - LIS长度`。

### 核心算法的应用
LIS的核心思想是「找最长的递增序列」，而本题中：
- 测试点按`x`从小到大排序（因为`x`互不相同）；
- 我们需要找`k`的最长递增子序列（因为`x`已经递增，所以`k`递增等价于「x和k都递增」）。

### 核心难点与解决方案
1. **证明必要性**：对于两个测试点`i<j`（`x_i<x_j`），二分过程中一定会有一个中点`m`，使得`x_i≤m<x_j`。根据二分规则，`a[m]≥k_i`（否则`x_i`会被分到右半区）且`a[m]<k_j`（否则`x_j`会被分到左半区），因此`k_i<k_j`。
2. **高效计算方案数**：用动态规划（DP）。`dp[i]`表示以第`i`个测试点结尾的最长递增子序列的**长度**和**方案数**。转移时，通过预处理「二分中点集合」（二分过程中的中点），将转移范围从`O(n²)`缩小到`O(n log n)`。
3. **处理无效测试点**：直接删除`k=1但x≠1`的测试点——二分找`k=1`时一定返回`x=1`，这类点不可能满足条件。

### 可视化设计思路
我设计了一个**8位像素风格的「排队模拟器」**：
- 屏幕左侧是`x轴`（1到n，像素块排成一列），右侧是`k轴`（1到n，同理）；
- 每个测试点用彩色像素块表示（坐标`(x_i, k_i)`），按`x`顺序逐个添加；
- 用「红色箭头」高亮LIS的路径，「数字气泡」显示`dp[i]`的方案数，转移时用「滑动动画」展示系数相乘；
- 加入复古音效：添加测试点时「叮」一声，LIS延长时「滴」一声，完成时播放胜利音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度等方面，为大家筛选了以下优质题解：
</eval_intro>

### 题解一：Milmon的O(n log n)优化方案
* **点评**：这份题解的思路最清晰！它先证明了「x递增且k递增」的必要条件，再将问题转化为LIS。最巧妙的是**预处理二分中点集合**（每个测试点对应的二分路径中点），将DP转移的时间复杂度从`O(n²)`降到`O(n log n)`。代码中的`Info`结构体封装了LIS的长度和方案数，`s1/s2`数组维护前缀和，逻辑严谨且高效。

### 题解二：DaiRuiChen007的简洁实现
* **点评**：这道题解的代码更简洁！它用`info`结构体封装LIS信息，用`L/R`数组存储二分中点，转移时通过`wys`变量计算填数方案数。代码结构清晰，适合快速理解核心逻辑。

### 题解三：bunH2O的线段树刻画
* **点评**：这份题解的角度很新颖——用线段树刻画二分过程，将测试点的路径转化为线段树的节点。然后用类似LIS的DP优化，适合想深入理解「二分与线段树关联」的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
让我们深入分析三个核心难点，并给出解决策略：
</difficulty_intro>

### 难点1：理解「x递增且k递增」的必要性
**解决策略**：通过二分过程中的中点`m`证明——对于`x_i<x_j`，`m`满足`x_i≤m<x_j`，根据二分规则，`a[m]≥k_i`且`a[m]<k_j`，因此`k_i<k_j`。

### 难点2：高效计算LIS的方案数
**解决策略**：用DP优化。`dp[i]`表示以第`i`个测试点结尾的LIS长度和方案数。转移时，通过**二分中点集合**（每个测试点对应的二分路径中点），将转移范围从`O(n)`缩小到`O(log n)`，并用`前缀和数组`快速计算转移系数。

### 难点3：处理无效测试点
**解决策略**：直接删除`k=1但x≠1`的测试点——二分找`k=1`时一定返回`x=1`，这类点不可能满足条件。

### ✨ 解题技巧总结
- **问题转化**：将复杂条件转化为经典算法（本题→LIS）；
- **预处理优化**：预处理二分中点，缩小转移范围；
- **模运算逆元**：用逆元将除法转化为乘法（如`(k-1)/n`→`(k-1)*inv_n%MOD`）；
- **边界优先**：先处理无效测试点，避免后续错误。


## 4. C++核心代码实现赏析

<code_intro_overall>
首先看一份通用的核心实现（基于Milmon的题解），它完整覆盖了问题的所有步骤：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了Milmon和DaiRuiChen007的思路，实现了`O(n log n)`的LIS长度和方案数计算，处理了边界情况。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

// 快速幂（求逆元）
long long ksm(long long a, long long b = MOD - 2) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 存储LIS的长度和方案数
struct Info {
    int len;
    long long cnt;
    Info() : len(-1), cnt(1) {}
    Info(int l, long long c) : len(l), cnt(c) {}
    // 合并两个Info：取长度大的，长度相同则方案数相加
    Info operator+(const Info& o) const {
        if (len > o.len) return *this;
        if (len < o.len) return o;
        return Info(len, (cnt + o.cnt) % MOD);
    }
    // 乘以系数（方案数乘，长度不变）
    Info operator*(long long coef) const {
        return Info(len, cnt * coef % MOD);
    }
    // 减去另一个Info（仅用于前缀和）
    Info operator-(const Info& o) const {
        assert(len == o.len);
        return Info(len, (cnt - o.cnt + MOD) % MOD);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        vector<int> a(n + 1, 0), p(n + 1, 0); // a[x] = k, p[k] = x
        long long inv_n = ksm(n); // n的逆元

        // 读取测试点，处理无效点（k=1但x≠1）
        for (int i = 0; i < m; ++i) {
            int x, k;
            cin >> x >> k;
            if (k == 1 && x != 1) continue;
            a[x] = k;
            p[k] = x;
        }

        // 预处理每个x的二分中点集合L（左半区）和R（右半区）
        vector<vector<int>> L(n + 1), R(n + 1);
        for (int x = 1; x <= n; ++x) {
            int l = 1, r = n;
            while (l < r) {
                int mid = (l + r) >> 1;
                if (x <= mid) {
                    r = mid;
                    if (x != mid) R[x].push_back(mid);
                } else {
                    l = mid + 1;
                    if (x != mid) L[x].push_back(mid);
                }
            }
            reverse(L[x].begin(), L[x].end());
            reverse(R[x].begin(), R[x].end());
        }

        vector<Info> dp(n + 1); // dp[x]：以x结尾的LIS信息
        vector<Info> s1(n + 1), s2(n + 1); // 前缀和数组
        Info ans = Info(0, 1); // 最终答案

        for (int k = 1; k <= n; ++k) {
            int x = p[k];
            if (x == 0) continue; // 没有这个k的测试点

            // 计算dp[x]：遍历L[x]（左半区中点）
            long long vl = 1; // 转移系数累积
            long long wys = (k - 1) * inv_n % MOD; // 左半区填数系数
            dp[x] = Info(-1, 1);
            for (int j : L[x]) {
                // 前缀和的线性组合：s1[j]*k - s2[j]
                Info tmp = (s1[j] * k - s2[j]) * vl % MOD;
                tmp = tmp * inv_n % MOD;
                dp[x] = dp[x] + tmp;
                if (a[j] != 0) dp[x] = dp[x] + dp[j] * vl;
                vl = vl * wys % MOD;
            }
            dp[x] = dp[x] + Info(0, vl); // 自身贡献
            dp[x].len += 1; // 长度+1

            // 更新前缀和s1/s2：遍历R[x]
            vl = 1;
            wys = (n - k + 1) * inv_n % MOD; // 右半区填数系数
            for (int j : R[x]) {
                s1[j] = s1[j] + dp[x] * vl;
                s2[j] = s2[j] + dp[x] * vl % MOD * k % MOD;
                vl = vl * wys % MOD;
            }

            ans = ans + dp[x] * vl; // 更新答案
        }

        // 输出结果：最少删除数 = m - ans.len，方案数 = ans.cnt * n^(n - ans.len)
        long long total = ans.cnt * ksm(n, n - ans.len) % MOD;
        cout << (m - ans.len) << " " << total << "\n";
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取测试点，跳过`k=1但x≠1`的无效点；  
  2. **预处理中点**：模拟二分过程，记录每个测试点的二分路径中点；  
  3. **动态规划**：计算`dp[x]`（以x结尾的LIS信息），用`s1/s2`维护前缀和优化转移；  
  4. **结果计算**：最少删除数是`m - LIS长度`，方案数是`ans.cnt * n^(未限制位置数)`。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
让我们再聚焦三个核心难点，给出更具体的解决策略：
</difficulty_intro>

### 难点1：证明「x递增且k递增」的必要性
**解决策略**：  
对于两个测试点`i<j`（`x_i<x_j`），二分查找`k_i`时，`x_i`会被分到左半区（因为`a[m]≥k_i`）；查找`k_j`时，`x_j`会被分到右半区（因为`a[m]<k_j`）。因此`k_i<k_j`——**x递增必然要求k递增**。

### 难点2：高效计算LIS的方案数
**解决策略**：  
用`dp[x]`表示以`x`结尾的LIS信息（长度+方案数）。转移时，**只遍历二分中点集合中的点**（每个测试点的中点数量是`O(log n)`），并用`s1/s2`前缀和快速求和，避免遍历所有`j<i`的测试点。

### 难点3：处理模运算中的除法
**解决策略**：  
区间填数的方案数是`(k-1)/n`（左半区）或`(n-k+1)/n`（右半区）。模运算中没有除法，因此用**逆元**（`n^(MOD-2) % MOD`）将除法转化为乘法。


## 4. C++核心代码实现赏析（续）

<code_intro_selected>
接下来，我们剖析Milmon题解中的**核心代码片段**：
</code_intro_selected>

### 题解一：Milmon的核心代码片段
* **亮点**：用「二分中点集合」优化转移，将`O(n²)`的DP降到`O(n log n)`。
* **核心代码片段**：
```cpp
// 预处理二分中点集合
for (int x = 1; x <= n; ++x) {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (x <= mid) {
            r = mid;
            if (x != mid) R[x].push_back(mid);
        } else {
            l = mid + 1;
            if (x != mid) L[x].push_back(mid);
        }
    }
    reverse(L[x].begin(), L[x].end());
    reverse(R[x].begin(), R[x].end());
}

// 计算dp[x]
for (int k = 1; k <= n; ++k) {
    int x = p[k];
    if (x == 0) continue;
    long long vl = 1;
    long long wys = (k - 1) * inv_n % MOD;
    dp[x] = Info(-1, 1);
    for (int j : L[x]) {
        Info tmp = (s1[j] * k - s2[j]) * vl % MOD;
        tmp = tmp * inv_n % MOD;
        dp[x] = dp[x] + tmp;
        if (a[j] != 0) dp[x] = dp[x] + dp[j] * vl;
        vl = vl * wys % MOD;
    }
    dp[x] = dp[x] + Info(0, vl);
    dp[x].len += 1;
}
```
* **代码解读**：  
  1. **预处理中点**：模拟二分过程，记录每个测试点的二分路径中点（`L[x]`是左半区中点，`R[x]`是右半区中点）；  
  2. **计算dp[x]**：遍历`L[x]`中的中点`j`，用`s1[j] * k - s2[j]`快速求前缀和，乘以转移系数`vl`（`x_j+1到x_i-1`的填数方案数），累加到`dp[x]`中；  
  3. **更新前缀和**：遍历`R[x]`中的中点`j`，更新`s1[j]`和`s2[j]`，方便后续测试点查询。

* 💡 **学习笔记**：预处理「关键中点」是优化的关键！这些中点是连接不同测试点的「桥梁」，通过它们可以将转移范围从`O(n)`缩小到`O(log n)`。


## 5. 算法可视化：像素排队模拟器

<visualization_intro>
为了让大家更直观地理解「x递增且k递增」的条件和LIS的计算过程，我设计了一个**8位像素风格的可视化工具**——「像素排队模拟器」！
</visualization_intro>

### 一、设计思路
- **风格**：仿FC红白机的8位像素风，用简单色块和像素字体，营造复古游戏氛围；
- **核心目标**：演示「测试点选择」「LIS生成」「转移系数计算」三个关键环节；
- **游戏化元素**：单步执行、自动播放、调速滑块，以及「过关奖励」（每生成一个LIS片段得10分）。

### 二、动画细节
1. **场景初始化**：
   - 屏幕左侧是`x轴`（1到n，像素块排成一列），右侧是`k轴`（1到n）；
   - 中间区域是「测试点矩阵」：每个测试点用彩色像素块表示（坐标`(x_i, k_i)`）；
   - 底部控制面板：「开始/暂停」「单步」「重置」按钮，调速滑块（1x到5x），分数显示。

2. **测试点添加**：
   - 按`x`顺序逐个添加测试点，像素块从右侧「滑入」对应位置，伴随「叮」的音效；
   - 无效点（`k=1但x≠1`）用灰色显示，弹出「×」提示后消失。

3. **LIS生成**：
   - 添加有效测试点时，用「黄色闪烁」高亮能连接的前驱点（`x_j<x_i且k_j<k_i`）；
   - 用「红色箭头」连接当前点和前驱点，伴随「滴」的音效，分数+10分。

4. **转移系数计算**：
   - 计算`dp[x]`时，用「数字气泡」显示转移系数`vl`（如0.5）；
   - 累加系数时，数字气泡「长大」，表示系数的累积。

5. **结果展示**：
   - 所有测试点添加完成后，用「绿色闪烁」高亮LIS路径，播放胜利音效；
   - 屏幕底部显示「最少删除数」和「方案数」，用像素字体显示。

### 三、技术实现
- **前端**：HTML5 Canvas绘制像素图形，JavaScript实现动画逻辑；
- **音效**：Web Audio API生成8位音效（正弦波模拟复古声音）；
- **轻量化**：单HTML文件，无需额外依赖，直接在浏览器运行。


## 6. 拓展练习与相似问题

<similar_problems_intro>
掌握了本题的思路后，你可以尝试以下相似问题，巩固LIS和二分优化的技巧：
</similar_problems_intro>

### 1. 洛谷 P1020 导弹拦截
- **题目链接**：https://www.luogu.com.cn/problem/P1020
- **推荐理由**：经典LIS问题！求最长不升子序列的长度（第一问）和最少需要多少个不升子序列（第二问，转化为最长递增子序列）。

### 2. 洛谷 P1439 最长公共子序列
- **题目链接**：https://www.luogu.com.cn/problem/P1439
- **推荐理由**：将最长公共子序列（LCS）转化为LIS。通过映射元素位置，将`O(n²)`的LCS优化到`O(n log n)`。

### 3. 洛谷 P2893 [USACO08FEB] Making the Grade G
- **题目链接**：https://www.luogu.com.cn/problem/P2893
- **推荐理由**：带权LIS问题！求将序列转化为非递减序列的最小代价，需要用DP结合二分优化。


## 7. 学习心得与经验分享

<insights_intro>
从题解中，我总结了一些实用的学习心得：
</insights_intro>

> **经验1：问题转化是关键**  
> 本题的核心是将「测试点的保留条件」转化为「LIS问题」。很多复杂题都是经典算法的变种，关键是找到「问题与经典算法的连接点」。

> **经验2：预处理「关键信息」是优化的核心**  
> Milmon的题解中，预处理「二分中点集合」是优化的关键。这些中点是连接不同测试点的「桥梁」，通过它们可以将转移时间从`O(n²)`降到`O(n log n)`。

> **经验3：模运算中的逆元要注意**  
> 区间填数的方案数是`(k-1)/n`，但模运算中没有除法，因此用逆元（`n^(MOD-2)`）将除法转化为乘法。这是模运算的常见技巧！


## 结语

本次关于「Go Learn! (Hard Version)」的分析就到这里啦！这道题结合了二分查找的性质和LIS的优化，是一道非常好的综合题。希望大家能通过这道题，掌握「问题转化」「预处理优化」「模运算逆元」等技巧。记住：**先想清楚问题的本质，再写代码**，才能事半功倍！

下次我们再一起探索新的编程挑战吧！💪

---
处理用时：256.01秒
# 题目信息

# Unique Strings

## 题目描述

我们称两个字符串 $a$ 和 $b$ 是相等的，如果可以通过循环移位字符串 $a$ 得到字符串 $b$。例如，字符串 0100110 和 1100100 是相等的，而 1010 和 1100 则不相等。

给定一个长度为 $n$ 的二进制字符串 $s$，其前 $c$ 个字符为 1，后 $n-c$ 个字符为 0。

每次操作，你可以将一个 0 替换为 1。

请计算在不超过 $k$ 次操作内，最多可以得到多少个不同的字符串（不同指的是循环同构意义下的不同字符串）。由于答案可能很大，请输出答案对 $10^9+7$ 取模后的结果。

## 说明/提示

在第一个测试用例中，唯一可能的字符串是 1。

在第二个测试用例中，可能的字符串有：100、110 和 111。字符串 101 与 110 是循环等价的，因此不计入。

在第三个测试用例中，可能的字符串有：10000、11000、10100。字符串 10010 与 10100 循环等价，10001 与 11000 循环等价。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1 1 0```

### 输出

```
1```

## 样例 #2

### 输入

```
3 1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
5 1 1```

### 输出

```
3```

## 样例 #4

### 输入

```
6 2 2```

### 输出

```
7```

## 样例 #5

### 输入

```
24 3 11```

### 输出

```
498062```

# AI分析结果

# 💡 Kay的C++算法解析：Unique Strings 深入学习指南 💡

<introduction>
今天我们来一起分析「Unique Strings」这道C++编程题。这道题是典型的**循环同构计数问题**，需要用到「Burnside引理」——一种专门解决“旋转/翻转后相同视为同一类”的计数工具。本指南将帮你理解核心算法，掌握解题技巧，并通过像素动画直观感受算法过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：Burnside引理（组合计数中的群论工具）

🗣️ **初步分析**：
解决“循环同构不同的字符串数量”问题，关键是理解**Burnside引理**——它像一个“公平的裁判”，通过计算“每个旋转操作下不变的字符串数的平均值”，得到最终不同类的数量。比如统计“不同的手链”，旋转后一样的算同一类，Burnside会帮你算出所有可能的“独特手链”数。

在本题中：
- 置换群是“循环移位”：旋转i位（i=1~n）是一个置换。
- 合法串定义：原串前c个1，后n-c个0，最多替换k个0为1；调整后更严谨的定义是“1的个数在[c, c+k]之间，且存在长度≥c的连续1段”（确保置换下封闭）。
- 核心难点：计算每个置换的**不动点**（旋转后不变的合法串数）。例如旋转g位（g是n的因数），不动点要求串有长度为g的循环节，此时需要计算“循环节中存在长≥c的连续1段”的方案数（正难则反，用总方案减去“没有长连续1”的方案）。

**可视化设计思路**：
我们设计一个**8位像素风的“手链工匠”游戏**：
- 场景：屏幕左侧是n颗像素珠子组成的“手链”（0=蓝，1=红），右侧是“操作面板”（旋转按钮、单步/自动播放、速度滑块）。
- 核心演示：
  1. 初始化：手链显示初始串（前c红，后n-c蓝），播放轻快的8位BGM。
  2. 旋转操作：点击“旋转g位”，手链绕中心转动，高亮不变的珠子（不动点），伴随“咔嗒”音效。
  3. 不动点计算：用像素块动态展示“循环节”（比如g=3，手链分成n/g段，每段相同），统计有长连续红的段数，用“叮”音效提示有效计数。
  4. 结果展示：所有旋转操作完成后，屏幕中央显示“平均后的独特手链数”，伴随胜利音效。
- 交互：支持“单步执行”（逐步看每个旋转的不动点）、“自动播放”（快速遍历所有置换），重置后可修改n/c/k参数重新演示。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你多角度理解解题过程~
</eval_intro>

**题解一：来源：bsdsdb（赞：6）**
* **点评**：这份题解是Burnside引理的“标准实践”！作者先解决了置换群的**封闭性问题**（调整合法串定义，确保旋转后仍合法），再通过**正难则反**计算不动点：用总方案数减去“没有长连续1段”的方案数。代码结构清晰，预处理了欧拉函数（用于统计置换个数）、组合数（计算总方案），并通过DP预处理“没有长连续1的线性序列”——每一步都有明确的目标，非常适合入门Burnside引理的应用。

**题解二：来源：Lgx_Q（赞：3）**
* **点评**：作者另辟蹊径，用**莫比乌斯反演**替代Burnside引理！他通过“枚举最小循环节”，用容斥计算“恰好以d为最小循环节”的方案数。思路新颖，避免了群论的复杂概念，但需要对莫比乌斯反演有一定理解。代码中DP的设计（f[i][j]表示长度i、j个1且无长连续1的方案数）与题解一异曲同工，体现了“正难则反”的通用技巧。

**题解三：来源：Purslane（赞：3）**
* **点评**：作者同样用Burnside引理，但**聚焦不动点的补集计算**——先算“没有长连续1段”的方案数，再用总方案减去它。代码中DP的预处理（dp[i][j]表示长度i、j个1且无长连续1的线性序列）与题解一一致，但更简洁。作者提到“考场上没解决封闭性问题”，这也提醒我们：处理置换群问题时，**封闭性是前提**！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是突破3个核心难点，我们结合优质题解逐一分析：
</difficulty_intro>

### 1. 置换群的封闭性处理
**难点**：原问题中的合法串（替换k个0为1）旋转后可能变成“前c个不是1”的串，导致置换群不封闭（旋转后的串不在合法集合中）。  
**策略**：调整合法串定义为“1的个数在[c, c+k]之间，且存在长度≥c的连续1段”。这样，任何合法串的旋转串仍满足“有长连续1段”（循环移位不改变连续段长度），确保置换群封闭。  
💡 **学习笔记**：处理置换群问题时，首先要确保“合法集合在置换下封闭”，否则Burnside引理无法直接应用！

### 2. 不动点的计算（循环节长度g的情况）
**难点**：当串有长度为g的循环节时，需要计算“循环节中存在长≥c的连续1段”的方案数。直接计算很难，因为连续段可能“跨循环节首尾”。  
**策略**：正难则反！先算“循环节中1的个数≤q（q=(c+k)/(n/g)）”的总方案数，再减去“循环节中没有长≥c的连续1段”的方案数。其中“没有长连续1”的方案数用DP预处理（线性序列），再通过“枚举跨首尾的连续1长度”调整为环形情况。  
💡 **学习笔记**：环形计数的常用技巧——“枚举跨首尾的情况”，将环转化为链！

### 3. DP设计：预处理“没有长连续1的线性序列”
**难点**：如何高效计算“长度i、j个1且无长≥c的连续1段”的方案数？  
**策略**：用前缀和优化的DP！定义dp[i][j]为长度i、j个1且最后一位是0（避免连续1）的方案数，转移方程为：dp[i][j] = sum(dp[i-1][j - k] for k=1~c-1)（前i-1位末尾有k个连续1，第i位放0）。用前缀和数组prv优化求和，将时间复杂度从O(n³)降到O(n²)。  
💡 **学习笔记**：前缀和是DP优化的“神器”，尤其适合“连续区间求和”的转移！


### ✨ 解题技巧总结
- **Burnside引理模板**：对于循环同构计数，先枚举n的因数g（循环节长度），计算g对应的不动点数f(g)，再用公式ans = (sum(phi(n/g)*f(g)))/n（phi是欧拉函数，统计有多少个i的gcd(i,n)=g）。
- **正难则反**：遇到“存在某条件”的计数问题，先算总方案，再减“不存在该条件”的方案。
- **预处理意识**：组合数、欧拉函数、DP数组等可以提前计算，避免重复运算，提升代码效率。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合优质题解的通用核心实现**，它整合了Burnside引理、DP预处理和正难则反的思路，逻辑清晰易懂~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码基于bsdsdb的题解优化，保留了Burnside引理的核心逻辑，简化了部分变量命名，更易理解。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef long long ll;
const ll MOD = 1e9 + 7;
const int MAXN = 3005;

ll phi[MAXN], fac[MAXN], inv_fac[MAXN];
ll dp[MAXN][MAXN], prv[MAXN][MAXN]; // dp[i][j]: 长度i，j个1，无长≥c的连续1，末尾是0
int n, c, K, ad;

ll qpow(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

ll inv(ll x) { return qpow(x, MOD - 2); }

void init() {
    // 预处理欧拉函数phi
    for (int i = 1; i < MAXN; ++i) phi[i] = i;
    for (int i = 2; i < MAXN; ++i)
        if (phi[i] == i)
            for (int j = i; j < MAXN; j += i)
                phi[j] = phi[j] / i * (i - 1);
    // 预处理组合数fac和逆元inv_fac
    fac[0] = 1;
    for (int i = 1; i < MAXN; ++i) fac[i] = fac[i-1] * i % MOD;
    inv_fac[MAXN-1] = inv(fac[MAXN-1]);
    for (int i = MAXN-2; i >= 0; --i) inv_fac[i] = inv_fac[i+1] * (i+1) % MOD;
}

ll C(int n, int k) {
    if (n < 0 || k < 0 || n < k) return 0;
    return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD;
}

ll f(int g) { // 计算循环节长度g的不动点数
    if (c >= g) return 0; // 循环节长度≤c，只能全1，但c+k <n（否则ad=1）
    int m = n / g; // 循环节重复次数
    ll need = (ll)(m - 1) * c; // 需要额外补的1个数（每段前c个1）
    if (K < need) return 0;
    ll q = (K - need) / m; // 每段最多额外加q个1
    // 总方案：循环节中1的个数在[c, c+q]之间
    ll total = 0;
    for (int i = c; i <= c + q; ++i) total = (total + C(g, i)) % MOD;
    // 减去“没有长≥c的连续1段”的方案数g_total
    ll g_total = 0;
    for (int y = 0; y < c; ++y) { // y: 跨首尾的连续1长度
        ll cnt = (y + 1) * dp[g - y - 1][c + q - y] % MOD;
        g_total = (g_total + cnt) % MOD;
    }
    return (total - g_total + MOD) % MOD;
}

int main() {
    init();
    cin >> n >> c >> K;
    ad = 0;
    if (c + K == n) { ad = 1; K--; } // 全1的情况单独处理

    // 预处理dp数组：dp[i][j]表示长度i，j个1，无长≥c的连续1，末尾是0
    dp[0][0] = 1;
    prv[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (i == j + 1) { // 全1？不，末尾是0，所以j=i-1，此时连续1长度是i-1，若≥c则dp=0
                dp[i][j] = (j < c) ? 1 : 0;
            } else if (j == 0) { // 全0
                dp[i][j] = 1;
            } else { // 末尾是0，前i-1位末尾有k个连续1（k=1~c-1）
                int left = max(i - c, 0); // 前缀和的左边界（i-1 - (c-1) = i - c）
                dp[i][j] = (prv[i-1][i-1 - j] - prv[left][i-1 - j] + MOD) % MOD;
            }
            // 更新前缀和数组prv：prv[i][t] = sum_{j=0}^i dp[j][t-j]（t=i-j，即j=i-t）
            prv[i][i - j] = (prv[i-1][i - j] + dp[i][j]) % MOD;
        }
    }

    // Burnside引理计算答案：枚举n的因数g
    ll ans = 0;
    for (int g = 1; g * g <= n; ++g) {
        if (n % g != 0) continue;
        ans = (ans + phi[n / g] * f(g) % MOD) % MOD;
        if (g * g != n) ans = (ans + phi[g] * f(n / g) % MOD) % MOD;
    }
    ans = ans * inv(n) % MOD;
    cout << (ans + ad) << endl; // 加上全1的情况
    return 0;
}
```
* **代码解读概要**：
  1. **初始化**：`init`函数预处理欧拉函数（统计置换个数）和组合数（计算总方案）。
  2. **DP预处理**：`dp`数组统计“没有长连续1的线性序列”的方案数，`prv`数组是前缀和优化，避免重复计算。
  3. **不动点计算**：`f`函数计算循环节长度g的不动点数，用总方案减去“没有长连续1”的方案数。
  4. **Burnside主逻辑**：枚举n的所有因数g，用欧拉函数统计每个g对应的置换个数，计算所有不动点的平均值，得到最终答案。


---

<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，点出各自的亮点~
</code_intro_selected>

### 题解一：bsdsdb的核心代码片段（Burnside引理的应用）
* **亮点**：完整处理了置换群封闭性问题，DP预处理和不动点计算逻辑清晰。
* **核心代码片段**（`f`函数与Burnside主逻辑）：
```cpp
ll f(int g) { // 循环节长度g的不动点数
    if (c >= g) return 0;
    int m = n / g;
    ll need = (ll)(m - 1) * c;
    if (K < need) return 0;
    ll q = (K - need) / m;
    ll total = 0;
    for (int i = c; i <= c + q; ++i) total = (total + C(g, i)) % MOD;
    ll g_total = 0;
    for (int y = 0; y < c; ++y) {
        ll cnt = (y + 1) * dp[g - y - 1][c + q - y] % MOD;
        g_total = (g_total + cnt) % MOD;
    }
    return (total - g_total + MOD) % MOD;
}

int main() {
    // ... 预处理 ...
    ll ans = 0;
    for (int g = 1; g * g <= n; ++g) {
        if (n % g != 0) continue;
        ans = (ans + phi[n / g] * f(g) % MOD) % MOD;
        if (g * g != n) ans = (ans + phi[g] * f(n / g) % MOD) % MOD;
    }
    ans = ans * inv(n) % MOD;
    cout << (ans + ad) << endl;
}
```
* **代码解读**：
  - `f`函数中，`need`是“每段前c个1”需要补的1个数（因为循环节重复m次，第一段前c个1，后面m-1段需要补前c个1）；`q`是每段最多额外加的1个数。
  - `total`是循环节中1的个数在[c, c+q]之间的总方案数；`g_total`是“没有长≥c的连续1段”的方案数（枚举跨首尾的连续1长度y，用dp数组计算中间段的方案数）。
  - 主函数中，枚举n的因数g，用欧拉函数`phi[n/g]`统计有多少个i的gcd(i,n)=g（即置换个数），最后求平均值得到答案。
* 💡 **学习笔记**：枚举n的因数是Burnside引理的常用技巧，因为循环节长度g必须是n的因数！


### 题解二：Lgx_Q的核心代码片段（莫比乌斯反演的应用）
* **亮点**：没有用Burnside引理，而是用莫比乌斯反演统计“最小循环节长度d”的方案数，思路新颖。
* **核心代码片段**（莫比乌斯反演部分）：
```cpp
for (ll i = n; i; i--)
    if (n % i == 0) {
        for (ll j = 0; j < i; j++)
            if ((n / i) * j <= c + k && (n / i) * j >= c) {
                res[i][j] = (C[i-1][j] - f[i][j] + MOD) % MOD;
                for (ll k = 2; i * k <= n; k++)
                    res[i*k][j*k] = (res[i*k][j*k] + mu[k] * res[i][j] + MOD) % MOD;
            }
    }
```
* **代码解读**：
  - `res[i][j]`表示“循环节长度i，每个循环节有j个0”的方案数（`C[i-1][j]`是断环为链的总方案，`f[i][j]`是没有长连续1的方案数）。
  - 用莫比乌斯反演`mu[k]`减去“循环节长度是i*k”的方案数，得到“最小循环节长度i”的方案数。
* 💡 **学习笔记**：莫比乌斯反演是处理“恰好”问题的常用工具（比如“恰好最小循环节长度d”），可以替代Burnside引理解决循环同构计数问题！


## 5. 算法可视化：像素动画演示方案

### 🎮 动画主题：像素手链工匠
**设计思路**：用8位像素风模拟“制作手链”的过程，通过旋转手链、统计不动点，直观展示Burnside引理的计算过程。复古风格和游戏化元素能降低学习门槛，增强趣味性。


### 🎬 动画帧步骤与交互设计
#### 1. 场景初始化（8位像素风）
- **屏幕布局**：
  - 左侧：n颗像素珠子组成的手链（0=蓝色，1=红色，初始前c红，后n-c蓝）。
  - 右侧：控制面板（“开始/暂停”“单步”“重置”按钮；速度滑块；“循环节长度g”下拉框）。
  - 底部：信息栏（显示当前旋转的g值、不动点数、总计数）。
- **音效**：播放轻快的8位BGM（类似《超级马里奥》的背景音乐）。


#### 2. 核心算法演示
- **步骤1：选择循环节长度g**：
  点击“循环节长度g”下拉框，选择n的一个因数（比如g=3，n=6），手链分成n/g=2段，每段用黄色边框高亮（比如第1-3颗是段1，4-6颗是段2）。
- **步骤2：计算不动点（总方案）**：
  信息栏显示“总方案：循环节中1的个数在[c, c+q]之间”，用红色像素块动态填充循环节中的1，每填充一个1伴随“叮”音效，最终显示总方案数。
- **步骤3：计算不动点（补集）**：
  信息栏切换为“补集：没有长≥c的连续1段”，用蓝色像素块覆盖循环节中的长连续1（比如c=2，覆盖连续≥2的红块），伴随“嗡”音效，显示补集方案数。
- **步骤4：旋转操作与计数**：
  点击“单步”，手链绕中心旋转g位（比如g=3，珠子1→4，2→5，3→6），高亮不变的珠子（不动点），信息栏更新当前不动点数。点击“自动播放”，手链连续旋转所有g值，实时更新总计数。


#### 3. 交互与游戏化元素
- **步进控制**：支持“单步执行”（逐g值计算）、“自动播放”（按速度滑块设置的速度连续计算）、“重置”（恢复初始状态）。
- **音效反馈**：
  - 旋转操作：“咔嗒”声。
  - 填充1：“叮”声。
  - 覆盖长连续1：“嗡”声。
  - 完成所有计算：“胜利”音效（类似《魂斗罗》的通关音乐）。
- **游戏化关卡**：设置“小关卡”（比如n=3→n=5→n=7），完成每个关卡后解锁新的循环节长度，增加成就感。


#### 4. 技术实现
- **轻量化**：用纯HTML/CSS/JavaScript实现，Canvas绘制像素手链，Web Audio API播放音效。
- **代码同步**：右侧面板显示当前步骤对应的C++核心代码片段（比如`f`函数），高亮当前执行行（比如计算`total`时高亮`for (int i = c; i <= c + q; ++i) total += C(g, i)`）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解了Burnside引理和循环同构计数后，我们可以尝试以下相似问题，巩固知识点~
</similar_problems_intro>


### 🌱 通用思路迁移
本题的核心思路（Burnside引理+正难则反+DP预处理）可以解决**所有循环同构计数问题**，比如：
1. 统计“旋转后相同的彩色手链数”（每个珠子有m种颜色）。
2. 统计“旋转后相同的DNA序列数”（每个位置有4种碱基）。
3. 统计“旋转后相同的二进制串数”（要求有k个1）。


### 📚 洛谷推荐练习
1. **洛谷 P4980 【模板】Polya定理**  
   🗣️ **推荐理由**：Polya定理是Burnside引理的特例（用于颜色置换群），本题是Polya定理的模板题，帮助你巩固“循环节计数”的思路。
2. **洛谷 P2567 [SCOI2010]幸运数字**  
   🗣️ **推荐理由**：本题是“循环同构+条件计数”问题，需要用Burnside引理+DP预处理，与本题思路高度相似，适合拓展练习。
3. **洛谷 P3197 [HNOI2008]越狱**  
   🗣️ **推荐理由**：本题是“循环同构+容斥”问题，需要用Burnside引理+正难则反，帮助你理解“补集计数”的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中bsdsdb提到：“最初设X为‘开头为1，至多两个1’的串，但旋转后不在X中，违反了Burnside的封闭性要求。”这给我们一个重要教训：
</insights_intro>

> **参考经验 (来自 bsdsdb)**：“处理Burnside引理时，一定要确保合法集合在置换下封闭。如果旋转后的串不在合法集合中，需要调整合法集合的定义，比如将‘开头为1’改为‘存在长≥c的连续1段’。”
>
> **点评**：这位作者的经验很典型！很多人第一次用Burnside引理时，会忽略“封闭性”这个前提，导致结果错误。遇到这种情况，要重新审视合法集合的定义，确保置换后的串仍合法。


## <conclusion>
本次关于「Unique Strings」的C++解题分析就到这里。这道题是**Burnside引理的经典应用**，核心是“通过不动点的平均值计算循环同构类数”。记住：
- 置换群的封闭性是前提；
- 正难则反是计算不动点的常用技巧；
- DP预处理是解决“没有某条件”的有效方法。

希望这份指南能帮你掌握Burnside引理，下次遇到循环同构计数问题时，能轻松解决！💪
</conclusion>

---
处理用时：113.10秒
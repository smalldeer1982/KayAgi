# 题目信息

# Making Shapes

## 题目描述

给定 $n$ 个两两不共线的二维向量。你可以用以下方式在二维平面上用这些向量构造图形：

1. 从原点 $(0, 0)$ 开始。
2. 选择一个向量，将该向量的线段加到当前点。例如，如果当前点在 $(x, y)$，你选择向量 $(u, v)$，则从当前点画一条线段到 $(x + u, y + v)$，并将当前点更新为 $(x + u, y + v)$。
3. 重复第 2 步，直到你再次回到原点。

每个向量可以重复使用任意多次。

请计算可以用上述步骤构造出的不同的、非退化（面积大于 $0$）且凸的图形的数量，要求这些图形的构成向量按逆时针顺序排列，并且该图形可以通过平移被包含在一个 $m \times m$ 的正方形内。由于答案可能很大，请对 $998244353$ 取模。

如果存在某种平行移动能使第一个图形与第二个图形重合，则认为这两个图形是相同的。

如果存在某种平行移动，使得图形内或边界上的每个点 $(u, v)$ 都满足 $0 \leq u, v \leq m$，则认为该图形可以被包含在 $m \times m$ 的正方形内。

## 说明/提示

第一个样例的所有图形如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1290F/1435a49a0854cf885bd0a880b2bd4ec616aaecf0.png)

第二个样例的唯一图形如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1290F/c198c6d97ae318f4efbc29b95f2307d41e83d32d.png)

第四个样例的唯一图形如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1290F/5612d8b3b2e07c811bb5d8b4ac9e1b97873da5e3.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 3
-1 0
1 1
0 -1```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3
-1 0
2 2
0 -1```

### 输出

```
1```

## 样例 #3

### 输入

```
3 1776966
-1 0
3 3
0 -2```

### 输出

```
296161```

## 样例 #4

### 输入

```
4 15
-4 -4
-1 1
-1 -4
4 3```

### 输出

```
1```

## 样例 #5

### 输入

```
5 10
3 -4
4 -3
1 -3
2 -3
-3 -4```

### 输出

```
0```

## 样例 #6

### 输入

```
5 1000000000
-2 4
2 -3
0 -4
2 4
-1 -3```

### 输出

```
9248783```

# AI分析结果

# 💡 Kay的C++算法解析：Making Shapes 深入学习指南 💡

大家好！今天我们要一起攻克「Making Shapes」这道有趣的向量构造题。这道题不仅考察对凸图形条件的理解，还藏着一个**数位DP**的巧妙技巧——用「二进制积木」的方式解决大数计数问题。让我们一步步拆解它！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数位动态规划（数位DP）  

🗣️ **初步分析**：  
你可以把数位DP想象成「拼二进制积木」——我们要给每个向量的使用次数（比如选3次就是二进制`11`）**从低位到高位逐位确定**，每一步都检查是否满足「回到原点」和「放入m×m正方形」的条件。这样即使m很大（比如1e9），也能通过「分位处理」把问题变小！  

### 题目核心条件转化  
要构造符合要求的凸图形，向量的使用次数`c_i`必须满足：  
1. **回到原点**：正负x的总和相等（`∑c_i x_i=0`），正负y的总和相等（`∑c_i y_i=0`）；  
2. **放入正方形**：正x的总和≤m，正y的总和≤m（因为凸图形的横纵极差等于正x/正y的总和）。  

### 数位DP的核心思路  
我们用「二进制位」来拆解`c_i`：每一步决定每个`c_i`的某一位是0还是1（比如第d位选1，代表`c_i`要加`2^d`次这个向量）。然后用**状态**记录当前的「进位」（比如正x的累加进位、负x的累加进位）和「是否超过m」的标记，确保每一步都符合条件。  

### 可视化设计思路  
我们会用**8位像素风格**展示数位DP的过程：  
- 用不同颜色的像素块表示「正x累加」（红色）、「负x累加」（蓝色）、「正y累加」（绿色）、「负y累加」（黄色）；  
- 每一步高亮当前处理的二进制位，用「滑入动画」展示向量的选择（选则点亮对应向量的像素块）；  
- 进位用「向上跳动的小方块」表示，条件满足时播放「叮」的音效，超过m时播放「滴滴」提示音。  


## 2. 精选优质题解参考

### 题解一：tzc_wk（赞18）  
* **点评**：这道题的「标准答案」级题解！思路极其清晰——直接把条件转化为数位DP的状态，用记忆化搜索实现。代码简洁到「每一行都有用」：`dp`数组记录当前位、进位和超过标记，`calc`函数递归处理每一位的向量选择。最妙的是**用「异或」判断当前位的正负总和是否相等**（比如正x和负x的当前位必须同为0或1），确保每一步都满足「回到原点」的条件。  

### 题解二：MatrixCascade（赞8）  
* **点评**：详细解释了「向量次数决定凸图形形状」的关键结论，帮你跳过「为什么不用考虑排列顺序」的坑。代码用`dfs`实现记忆化，状态设计和tzc_wk一致，但添加了更多注释（比如`assert`确保进位非负），对新手更友好。美中不足的是`ff1`/`ff2`的处理有点绕，需要仔细理解。  

### 题解三：Fuyuki（赞3）  
* **点评**：把向量按「正负x/y」分组，用`nx`/`px`/`ny`/`py`预处理每组的累加值，简化了状态转移。代码中的`FOR`循环嵌套虽然多，但逻辑非常严谨——枚举每一位的向量选择（`S`），然后更新进位和超过标记。这种「预处理分组」的技巧能帮你在类似题目中更快设计状态。  


## 3. 核心难点辨析与解题策略

### 难点1：如何把凸图形条件转化为数学式子？  
**分析**：很多同学会卡在「为什么正x的总和等于负x的总和」或者「为什么极差等于正x的总和」。其实凸图形的顶点是「先沿正方向扩展，再沿负方向收缩」，所以正方向的总长度就是极差！  
**解决策略**：画个小例子（比如用向量(1,0)和(-1,0)各选2次），模拟凸图形的顶点坐标——你会发现横坐标从0→2→0，极差就是2（正x的总和）。  

### 难点2：数位DP的状态怎么设计？  
**分析**：直接记录「正x总和」会因为m太大（1e9）而无法存储。数位DP的关键是**只记录「进位」和「是否超过m」**——进位是当前位处理后的剩余值（比如正x累加了5，当前位是0（2^0），则进位是5>>1=2），「是否超过m」用布尔值标记（比如当前位选1但m的当前位是0，就标记为超过）。  
**解决策略**：状态必须包含：当前处理到第几位（d）、正x的进位（px）、负x的进位（nx）、正y的进位（py）、负y的进位（ny）、正x是否超过m（p）、正y是否超过m（q）。  

### 难点3：如何确保每一步的进位和条件正确？  
**分析**：进位的计算容易出错（比如正负x的累加是否正确），或者忘记判断「当前位的正负总和是否相等」。  
**解决策略**：每一步枚举向量选择后，先计算当前位的正负x/y的二进制位（比如正x的当前位是`px&1`），必须满足「正x当前位=负x当前位」且「正y当前位=负y当前位」才能继续递归。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合tzc_wk的代码（简洁高效）和Fuyuki的分组技巧，提炼出的通用实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MOD = 998244353;
int n, m, x[7], y[7];
int dp[34][23][23][23][23][2][2]; // d, px, py, nx, ny, p, q

int chk(int dm, int d_val, int flag) {
    if (d_val != dm) return d_val > dm ? 1 : 0;
    return flag;
}

int calc(int d, int px, int py, int nx, int ny, int p, int q) {
    if (d == 30) return (!px && !py && !nx && !ny && !p && !q) ? 1 : 0;
    if (dp[d][px][py][nx][ny][p][q] != -1) return dp[d][px][py][nx][ny][p][q];
    int res = 0, bit = (m >> d) & 1;
    for (int s = 0; s < (1 << n); ++s) { // 枚举当前位的向量选择
        int npx = px, npy = py, nnx = nx, nny = ny;
        for (int i = 1; i <= n; ++i) {
            if (s & (1 << (i-1))) { // 选第i个向量
                if (x[i] > 0) npx += x[i];
                else nnx -= x[i];
                if (y[i] > 0) npy += y[i];
                else nny -= y[i];
            }
        }
        // 检查当前位的正负总和是否相等
        if ((npx & 1) == (nnx & 1) && (npy & 1) == (nny & 1)) {
            int new_p = chk(bit, npx & 1, p);
            int new_q = chk(bit, npy & 1, q);
            res = (res + calc(d+1, npx>>1, npy>>1, nnx>>1, nny>>1, new_p, new_q)) % MOD;
        }
    }
    return dp[d][px][py][nx][ny][p][q] = res;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> x[i] >> y[i];
    memset(dp, -1, sizeof(dp));
    cout << (calc(0, 0, 0, 0, 0, 0, 0) - 1 + MOD) % MOD << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. `chk`函数判断当前位是否超过m（比如m的当前位是1，选0则不超过，选1则继续看之前的标记）；  
  2. `calc`函数递归处理每一位：枚举向量选择→计算新的进位→检查当前位条件→递归下一位；  
  3. `main`函数初始化→调用`calc`→输出结果（减1是排除所有向量都不选的情况）。  


### 题解一（tzc_wk）核心片段赏析  
* **亮点**：用「位运算」快速判断当前位条件，代码简洁到极致。  
* **核心代码片段**：  
```cpp
int calc(int p, int ps_x, int ps_y, int ng_x, int ng_y, int xm, int ym) {
    if (p == 30) return (!ps_x && !ps_y && !ng_x && !ng_y && !xm && !ym);
    if (~dp[p][ps_x][ps_y][ng_x][ng_y][xm][ym]) return dp[p][ps_x][ps_y][ng_x][ng_y][xm][ym];
    int d = (m >> p) & 1, res = 0;
    for (int s = 0; s < (1 << n); ++s) {
        int tps_x = ps_x, tps_y = ps_y, tng_x = ng_x, tng_y = ng_y;
        for (int i = 1; i <= n; ++i) if (s & (1 << (i-1))) {
            (x[i] > 0) ? tps_x += x[i] : tng_x -= x[i];
            (y[i] > 0) ? tps_y += y[i] : tng_y -= y[i];
        }
        if ((tps_x & 1) == (tng_x & 1) && (tps_y & 1) == (tng_y & 1)) {
            res = (res + calc(p+1, tps_x>>1, tps_y>>1, tng_x>>1, tng_y>>1, 
                chk(d, tps_x&1, xm), chk(d, tps_y&1, ym))) % MOD;
        }
    }
    return dp[p][ps_x][ps_y][ng_x][ng_y][xm][ym] = res;
}
```
* **代码解读**：  
  - `~dp[...]`判断是否已经计算过这个状态（记忆化）；  
  - `s`枚举当前位的向量选择（二进制位表示选哪些向量）；  
  - `tps_x`/`tng_x`分别累加正x/负x的总和，`&1`取当前位的值，必须相等才能继续；  
  - `tps_x>>1`把当前位的处理结果转化为进位，传递给下一位。  
* **学习笔记**：记忆化搜索是数位DP的常用实现方式，**状态必须覆盖所有影响后续决策的因素**（比如进位、超过标记）。  


## 5. 算法可视化：像素动画演示  

### 动画演示主题：二进制积木拼凸形  
**设计思路**：用8位像素风模拟数位DP的「拼积木」过程，让你直观看到每一步的向量选择、进位传递和条件判断。  

### 动画帧步骤  
1. **场景初始化**：  
   - 屏幕左侧是「向量选择区」（用像素块展示每个向量，比如(1,0)是红色小箭头）；  
   - 中间是「累加区」（红/蓝/绿/黄四个方块，分别显示正x/负x/正y/负y的当前累加值）；  
   - 右侧是「控制面板」（单步/自动播放按钮、速度滑块、重置按钮）；  
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的背景音乐）。  

2. **算法启动**：  
   - 初始状态：所有累加值为0，进位为0，超过标记为否；  
   - 播放「滴」的提示音，提示「开始处理第0位（最低位）」。  

3. **核心步骤演示**：  
   - **向量选择**：枚举当前位的向量组合（比如选向量1和3），对应的向量像素块点亮，同时累加区的数值增加（比如正x加1，负x加2）；  
   - **条件判断**：检查当前位的正负总和是否相等（比如正x当前位是1，负x当前位是1→满足），如果满足则播放「叮」的音效，否则播放「滴滴」提示音并跳过；  
   - **进位传递**：累加值右移1位（比如正x从5→2），用「向上跳动的小方块」表示进位，传递给下一位；  
   - **超过标记**：如果正x的当前位超过m的当前位，累加区的红色方块闪烁，并标记为「超过」。  

4. **目标达成**：  
   - 当处理完所有30位，且所有进位为0、超过标记为否时，播放「胜利」音效（比如《塞尔达传说》的解谜音效），累加区的方块拼成一个凸图形的像素画（比如正方形），提示「成功构造凸形！」。  


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
数位DP的核心是「分位处理大数」，适用于**需要计数满足某些条件的大数组合**的问题（比如求满足a+b=c且a,b≤m的正整数对个数）。  

### 洛谷练习推荐  
1. **P2602 [ZJOI2010]数字计数**：经典数位DP题，统计0-9出现的次数，练习状态设计。  
2. **P3413 萌数**：统计区间内的「萌数」（包含至少一个连续相同数字），练习数位DP的「限制条件」处理。  
3. **P4124 [CQOI2016]手机号码**：统计满足特定数字组合的手机号码数量，练习多条件的数位DP。  


## 7. 学习心得与经验分享  

**参考经验（来自45dino）**：「我一开始错误地把不等式推成了正负x的差≤m，后来通过画图才发现极差等于正x的总和。」  
**点评**：这是非常典型的「想当然」错误！解决这类问题的关键是**动手模拟小例子**——比如用向量(1,0)和(-1,0)各选2次，画一下凸图形的顶点坐标，就能直观看到极差是2（正x的总和）。  

**参考经验（来自MatrixCascade）**：「数位DP的trick在于把大数拆成二进制位，每一步只处理小范围的进位。」  
**点评**：数位DP的本质是「将问题从「处理大数」转化为「处理每一位的小选择」」，这种「降维打击」的技巧能解决很多看似无法处理的大数问题。  


## 结语  
「Making Shapes」是一道**数位DP的经典应用题**，它的难点在于「将几何条件转化为数学式子」和「用数位DP处理大数计数」。通过这道题，你不仅能掌握数位DP的核心技巧，还能学会「用数学建模解决几何问题」的思路。  

记住：编程的乐趣在于「把复杂问题拆成简单步骤」——就像拼积木一样，每一步选对「二进制块」，就能拼成你想要的形状！下次我们再一起探索更有趣的算法挑战～💪

---
处理用时：94.84秒
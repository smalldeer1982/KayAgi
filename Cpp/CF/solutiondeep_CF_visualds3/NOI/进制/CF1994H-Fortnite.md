# 题目信息

# Fortnite

## 题目描述

这是一个交互题！

Timofey 正在编写一场名为 Capture the Flag（简称 CTF）的比赛。他还剩下最后一道题，这道题涉及到破解一个安全系统。整个系统基于多项式哈希 $^{\text{∗}}$。

Timofey 可以向系统输入一个由小写拉丁字母组成的字符串，系统会返回它的多项式哈希值。为了破解系统，Timofey 需要找出系统使用的多项式哈希参数（$p$ 和 $m$）。

Timofey 时间不多了，所以他最多只能进行 $3$ 次查询。请你帮助他完成这道题。

$^{\text{∗}}$ 一个长度为 $n$ 的小写拉丁字母字符串 $s$ 的多项式哈希值，基于 $p$ 并对 $m$ 取模，定义为 $(\mathrm{ord}(s_1) \cdot p^0 + \mathrm{ord}(s_2) \cdot p^1 + \mathrm{ord}(s_3) \cdot p^2 + \ldots + \mathrm{ord}(s_n) \cdot p^{n-1}) \bmod m$。其中 $s_i$ 表示字符串 $s$ 的第 $i$ 个字符，$\mathrm{ord}(\mathrm{chr})$ 表示字符 $\mathrm{chr}$ 在英文字母表中的序号，$x \bmod m$ 表示 $x$ 除以 $m$ 的余数。

## 说明/提示

第一次查询的答案为 $(\mathrm{ord}(a) \cdot 31^0 + \mathrm{ord}(a) \cdot 31^1) \bmod 59 = (1 + 1 \cdot 31) \bmod 59 = 32$。

第二次查询的答案为 $(\mathrm{ord}(y) \cdot 31^0 + \mathrm{ord}(b) \cdot 31^1) \bmod 59 = (25 + 2 \cdot 31) \bmod 59 = 28$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1

32

28```

### 输出

```
? aa

? yb

! 31 59```

# AI分析结果

# 💡 Kay的C++算法解析：Fortnite 深入学习指南 💡

<introduction>
今天我们来一起分析交互题「Fortnite」——这道题需要我们用**最多3次查询**破解多项式哈希的参数！交互题的乐趣在于“和系统对话”，通过精心设计的提问获取关键信息。本指南会帮你理清数学逻辑、交互策略，还会用像素动画直观展示核心步骤～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（模运算性质）+ 交互策略设计`

🗣️ **初步分析**：
解决这道题的关键，就像“猜数字游戏”——先猜一个**简单的“探针”字符串**拿到已知信息（p），再用两个“关联字符串”的模运算结果反推未知的m。  

### 核心算法思想
多项式哈希的公式是 $H(s) = (\sum_{i=0}^{n-1} c(s_{i+1}) \cdot p^i) \mod m$（注意题目中字符串的第i位对应$p^{i-1}$，这里统一调整为0基更方便）。我们的目标是找到p和m：
- **第一步**：用`aa`作为探针——它的哈希是 $1 \cdot p^0 + 1 \cdot p^1 = p+1$。由于题目保证 $m > p+1$，所以系统返回的哈希值**直接等于p+1**！这一步瞬间破解p～  
- **第二步**：用全z的字符串（比如`zzzzzzzzzz`）作为第二个探针——它的“无模哈希”是 $26 \cdot p^0 + 26 \cdot p^1 + ... + 26 \cdot p^9 = 26 \cdot \frac{p^{10}-1}{p-1}$（记为V），系统返回的模后值是$v = V \mod m$。  
- **第三步**：构造第三个字符串s，使得它的“无模哈希”T满足 $V - T = k \cdot m$（k是整数）。结合系统返回的$s$的模后值$t = T \mod m$，就能算出 $m = (V - v) - (T - t)$！  

### 可视化设计思路
我们会用**8位像素风**模拟三次查询的全过程：
- 屏幕左侧显示“交互控制台”：用像素方块展示当前查询的字符串（比如`aa`是两个橙色像素块，`zz`是紫色）、系统返回的哈希值（数字用像素字体）。  
- 中间区域展示**p进制处理过程**：当构造第三个字符串s时，逐位显示V-1（全z字符串减1后的无模哈希）和v的p进制位，用“借位动画”（比如像素块从高位“掉”到低位）展示如何处理$a_i \leq b_i$的情况。  
- 右侧是“m的计算机”：用像素灯闪烁展示$(V - v)$和$(T - t)$的差值，最终点亮m的数值。  
- 音效设计：查询`aa`时播放“叮”的确认音，查询全z时播放“嗡”的长音，构造s时每处理一位播放“咔嗒”声，算出m时播放“胜利音效”～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：(来源：Sharpsmile)**
* **点评**：这份题解的“思考过程”非常珍贵——它没有直接抛结论，而是一步步推导“如何用模运算反推m”。比如，作者提出“找一个字符串s，使得它的无模哈希T满足$V - T = k \cdot m$”，并拆解为“p进制下逐位处理借位”的策略。这种“从问题到方法”的推导，能帮你理解**为什么要这么查**，而不是“记住查什么”。

**题解二：(来源：xzCyanBrad)**
* **点评**：题解把问题抽象成“p进制数的逐位构造”，并明确给出了构造s的规则（$a_i > b_i$时直接减，否则借位取$a_i$）。尤其是“借位后$p - b_i < b_i$”的证明，完美解释了“为什么构造的s一定合法”。这种“严谨+直观”的风格，特别适合新手理解核心逻辑。

**题解三：(来源：DaiRuiChen007)**
* **点评**：这是**唯一有完整代码实现**的题解！代码结构清晰：先查`aa`得p，再查全z得x，然后逐位构造s，最后用公式$m = (V - x) - (T - y)$算出m。代码中的`val`函数计算无模哈希，`solve`函数封装了完整逻辑，变量名（比如`a`对应V-1的p进制位，`b`对应x的p进制位）也很易懂。从“理论到代码”的落地，这份题解是最好的参考！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”不在代码，而在**如何设计交互策略**。以下三个难点是解题的关键：
</difficulty_intro>

### 难点1：如何快速破解p？
- **问题**：为什么选`aa`而不是其他字符串？  
- **策略**：`aa`的无模哈希是$p+1$，且题目保证$m > p+1$——这意味着模运算不会改变结果！如果选其他字符串（比如`ab`），无模哈希是$1 + 2p$，无法直接解出p（因为模运算会干扰）。  
- 💡 **学习笔记**：交互题的“探针字符串”要满足“结果与模无关”，才能直接获取关键参数！

### 难点2：如何构造s让$V - T$是m的倍数？
- **问题**：为什么全z的字符串是好的选择？  
- **策略**：全z的字符串的无模哈希V的p进制每一位都是26（除了第一位可能是25，如果减1的话），这样在逐位构造s时，借位只会发生一次（因为26-1=25，不会连续借位）。这种“高进制位统一”的设计，让构造s的规则变得简单。  
- 💡 **学习笔记**：交互题的“探针字符串”要选“结构统一”的（比如全a、全z），这样后续处理的规则更可控！

### 难点3：如何处理p进制下的借位？
- **问题**：当$a_i \leq b_i$时（a是V-1的p进制位，b是x的p进制位），为什么借位后取$c_i = a_i$？  
- **策略**：借位后，$a_i$会变成$a_i + p$，此时$a_i + p - b_i$就是这一位的贡献。由于$a_i$最多是26（全z减1后是25或26），而$b_i < m$（但m很大，所以$b_i$最多是p-1≤49），所以$p - b_i ≤ 25$（因为$b_i ≥25$时，p≤50），保证$c_i = a_i$是合法的小写字母（1≤c_i≤26）。  
- 💡 **学习笔记**：构造字符串时，要保证每一位的取值在1-26之间（对应小写字母），借位策略的设计必须满足这个约束！

### ✨ 解题技巧总结
- **探针设计**：选“结果与模无关”或“结构统一”的字符串，快速获取已知信息。  
- **模运算反推**：利用$V - v = k \cdot m$（V是无模哈希，v是模后值），通过两个关联探针的结果反推m。  
- **进制逐位处理**：将大数字拆成p进制位，逐位构造目标字符串，避免处理大数溢出（因为m可以到2e9，但p进制位最多是10位）！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**完整的核心代码**——它来自题解三，完美实现了“三次查询+逐位构造”的逻辑！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自DaiRuiChen007的题解，是“理论到代码”的最佳落地示例。
* **完整核心代码**：
```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

typedef long long ll;

ll p; // 全局变量存储p

// 计算字符串s的无模哈希（注意字符串是0基，对应p^0到p^{n-1}）
ll calc_val(const string &s) {
    ll res = 0;
    for (char c : s) {
        res = res * p + (c - 'a' + 1); // c(s_i) = 字符对应的数值（a=1）
    }
    return res;
}

// 向系统查询字符串s的哈希值
ll query(const string &s) {
    cout << "? " << s << endl;
    ll res;
    cin >> res;
    return res;
}

void solve() {
    // 第一步：查aa得p
    ll h_aa = query("aa");
    p = h_aa - 1;

    // 第二步：查全z的字符串（长度10）
    string z_str = string(10, 'z');
    ll h_z = query(z_str);
    ll V = calc_val(z_str); // V是无模哈希

    // 第三步：构造s的p进制位
    ll x = h_z; // x是z_str的模后值
    ll a[15], b[15], c[15]; // a: V-1的p进制位，b: x的p进制位，c: s的p进制位
    fill(a, a+15, 0);
    fill(b, b+15, 0);
    fill(c, c+15, 0);

    // 计算V-1的p进制位（因为全z的无模哈希是V，减1后更方便构造）
    ll tmp = V - 1;
    for (int i = 0; i < 10; ++i) {
        a[i] = tmp % p;
        tmp /= p;
    }
    // 计算x的p进制位
    tmp = x;
    for (int i = 0; i < 10; ++i) {
        b[i] = tmp % p;
        tmp /= p;
    }

    // 逐位构造s的p进制位
    string s;
    for (int i = 0; i < 10; ++i) {
        if (a[i] > b[i]) {
            c[i] = a[i] - b[i];
        } else {
            // 借位：a[i+1]减1，a[i]加p
            a[i+1]--;
            c[i] = a[i];
        }
        s += (char)('a' + c[i] - 1); // c[i]是1-26，转成字符
    }

    // 第四步：查s的哈希值，计算m
    ll h_s = query(s);
    ll T = calc_val(s); // T是s的无模哈希
    ll m = (V - h_z) - (T - h_s); // 核心公式：m = (V - h_z) - (T - h_s)

    // 输出结果
    cout << "! " << p << " " << m << endl;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```
* **代码解读概要**：
  1. **查`aa`得p**：调用`query("aa")`得到h_aa，p = h_aa - 1。  
  2. **查全z得V和h_z**：构造长度为10的全z字符串，计算它的无模哈希V和模后值h_z。  
  3. **构造s的p进制位**：将V-1和h_z转成p进制，逐位处理借位问题，生成s。  
  4. **查s得T和h_s**：计算s的无模哈希T和模后值h_s，用公式$m = (V - h_z) - (T - h_s)$算出m。  

---

<code_intro_selected>
接下来看**题解三的核心片段**——它完美展示了“逐位构造s”的逻辑！
</code_intro_selected>

**题解三：(来源：DaiRuiChen007)**
* **亮点**：用p进制逐位构造s，避免了大数溢出（因为p≤50，10位p进制数最多是50^10≈9.7e16，用long long完全hold住）。
* **核心代码片段**：
```cpp
// 计算V-1的p进制位
ll tmp = V - 1;
for (int i = 0; i < 10; ++i) {
    a[i] = tmp % p;
    tmp /= p;
}
// 计算x的p进制位
tmp = x;
for (int i = 0; i < 10; ++i) {
    b[i] = tmp % p;
    tmp /= p;
}
// 逐位构造s
for (int i = 0; i < 10; ++i) {
    if (a[i] > b[i]) {
        c[i] = a[i] - b[i];
    } else {
        a[i+1]--;
        c[i] = a[i];
    }
    s += (char)('a' + c[i] - 1);
}
```
* **代码解读**：
  - 首先，把V-1（全z字符串减1的无模哈希）和x（全z字符串的模后值）转成p进制——这一步就像“把大数拆成积木”，每一位是p进制下的数字。  
  - 然后逐位处理：如果当前位的a[i]（V-1的位）大于b[i]（x的位），直接用a[i]-b[i]作为s的位；否则向高位借1（a[i+1]减1），用a[i]作为s的位。  
  - 最后，把s的每一位转成字符（c[i]是1-26，所以减1加'a'得到对应的小写字母）。  
* 💡 **学习笔记**：处理大数时，用“进制拆分”代替直接运算，能避免溢出！


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你“看清楚”三次查询的过程，我设计了一个**8位像素风的动画**——《哈希侦探小冒险》！
</visualization_intro>

### 动画主题
你扮演“哈希侦探”，需要通过三次查询破解p和m。屏幕分为三个区域：**查询控制台**、**进制工坊**、**结果显示器**。

### 动画流程
1. **初始化场景**（FC风格开场）：
   - 背景音乐：8位风格的“侦探主题曲”（轻快的方波旋律）。
   - 屏幕左侧是“查询控制台”：显示三个空的“查询槽”，底部有“提交”按钮。
   - 中间是“进制工坊”：有一个“p进制磨盘”，用于拆解大数。
   - 右侧是“结果显示器”：显示p和m的空框。

2. **第一次查询：破解p**（探针`aa`）：
   - 你在查询槽输入`aa`（两个橙色像素块），点击“提交”。
   - 系统返回`32`（假设p=31），查询槽下方显示“p = 32-1 = 31”。
   - 结果显示器的p框亮起“31”，伴随“叮”的音效。

3. **第二次查询：全z的字符串**（探针`zzzzzzzzzz`）：
   - 你输入全z的字符串（10个紫色像素块），提交后系统返回`12345`（假设x=12345）。
   - 进制工坊启动：`V-1`（全z减1的无模哈希）的p进制位（比如31进制）从右到左显示为`25,26,26,...,26`，`x`的p进制位显示为`12,3,45,...`。
   - 伴随“嗡”的长音，进制磨盘开始旋转。

4. **第三次查询：构造s**（逐位构造）：
   - 进制工坊逐位处理：
     - 第0位：a[0]=25 > b[0]=12，c[0]=13（转成`n`），显示“直接减”动画（两个数字相碰，弹出13）。
     - 第1位：a[1]=26 < b[1]=30，向第2位借1（a[2]减1，变成25），c[1]=26（转成`z`），显示“借位”动画（一个像素块从第2位“掉”到第1位）。
   - 构造完s后（比如`nzzzzzzzzz`），提交查询，系统返回`6789`。
   - 结果显示器的m框亮起：计算`(V - x) - (T - y) = (1e15 - 12345) - (5e14 - 6789) = 5e14 + 5444`，显示“500000000005444”，伴随“胜利音效”（上扬的三角波）。

5. **交互控制**：
   - 控制面板有“单步”“自动”“重置”按钮：单步模式下，每一步都要点击“下一步”；自动模式下，动画按1秒/步播放。
   - 速度滑块：可以调整动画速度（从0.5x到2x）。

### 设计思路
- **像素风格**：用FC游戏的4色 palette（黑、白、橙、紫），营造复古感。
- **音效强化**：关键操作（提交查询、破解p、算出m）都有对应的8位音效，强化记忆。
- **游戏化激励**：每完成一次查询，获得100分；算出m后，解锁“哈希大师”成就（显示像素奖杯）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“利用交互策略和模运算性质反推参数”，以下是类似的练习：
</similar_problems_intro>

### 通用思路迁移
这种“探针+关联查询”的策略，还能用于：
1. **破解未知模数的加密系统**（比如RSA的模n）。
2. **交互题中的参数反推**（比如猜数字游戏中，用两个数的和差反推目标数）。
3. **多项式插值问题**（用多个点反推多项式的系数）。

### 洛谷推荐练习
1. **洛谷 P1072** -  Hankson 的趣味题  
   🗣️ **推荐理由**：这道题需要用“因数分解+枚举”反推参数，和本题的“反推思路”一致。
2. **洛谷 P2480** -  [SDOI2010] 古代猪文  
   🗣️ **推荐理由**：用到了多项式哈希和模运算的性质，是本题的进阶版。
3. **洛谷 P3747** -  [六省联考2017] 相逢是问候  
   🗣️ **推荐理由**：交互题+模运算，需要设计高效的查询策略。


## 7. 学习心得与经验分享

<insights_intro>
题解中作者的“踩坑经历”很有价值：
</insights_intro>

> **参考经验 (来自Sharpsmile)**：“最开始我想直接查两个不同的字符串，用方程组解p和m，但发现m太大，方程组无法解。后来想到‘用全z的字符串构造无模哈希’，才找到突破口。”  
> **点评**：交互题的“方程组思路”往往不可行（因为m太大），必须用“模运算的倍数性质”反推。作者的经历提醒我们：**当直接解方程组不行时，要换个角度——利用模运算的“倍数差”！**


<conclusion>
这道题的乐趣在于“用数学逻辑设计交互策略”——没有复杂的算法，但需要你“想清楚每一步的目的”。记住：**交互题的核心是“对话”，每一次查询都要为下一次积累信息！** 下次遇到交互题，不妨先想：“我需要什么信息？用什么探针能拿到它？” 💪
</conclusion>

---
处理用时：113.69秒
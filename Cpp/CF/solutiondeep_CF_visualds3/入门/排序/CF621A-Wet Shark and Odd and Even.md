# 题目信息

# Wet Shark and Odd and Even

## 题目描述

Today, Wet Shark is given $ n $ integers. Using any of these integers no more than once, Wet Shark wants to get maximum possible even (divisible by $ 2 $ ) sum. Please, calculate this value for Wet Shark.

Note, that if Wet Shark uses no integers from the $ n $ integers, the sum is an even integer $ 0 $ .

## 说明/提示

In the first sample, we can simply take all three integers for a total sum of $ 6 $ .

In the second sample Wet Shark should take any four out of five integers $ 999999999 $ .

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
5
999999999 999999999 999999999 999999999 999999999
```

### 输出

```
3999999996```

# AI分析结果

# 💡 Kay的C++算法解析：Wet Shark and Odd and Even 深入学习指南 💡

<introduction>
今天我们要一起解决一个**用“奇偶小魔法”找最大偶数和**的问题——《Wet Shark and Odd and Even》！这个问题看起来有点绕，但只要掌握了“奇数+奇数=偶数”的小规律，就能轻松破解～ 跟着Kay一步步来，你会发现它其实超有趣！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（奇偶性）+ 贪心`

🗣️ **初步分析**：
解决这道题的关键，就像你**攒硬币买玩具**的逻辑——假设你有一堆硬币（数字），想凑出最多的钱去买只能用“偶数金额”支付的玩具。那怎么做？  
第一步：先把所有硬币都拿上（总和最大化）；  
第二步：如果总和是奇数（不能买），就**去掉最小的那个奇数硬币**——因为这样减少的钱最少，剩下的钱还是最多的！  

这背后的“魔法”就是**奇偶性规则**：  
- 偶数+偶数=偶数（蓝硬币+蓝硬币=能花的钱）；  
- 奇数+奇数=偶数（红硬币+红硬币=能花的钱）；  
- 奇数+偶数=奇数（红+蓝=不能花的钱）。  

所以题目的核心思路是：**先算所有数的总和，若总和是奇数，就减去最小的奇数**（这样总和变成偶数，且减少的最少）。  

所有题解的思路都围绕这个核心，只是实现细节不同：有的直接算总和+找最小奇数（最简洁），有的分开偶数和奇数处理（更直观）。  

**可视化设计思路**：我们会用8位像素风做一个“鲨鱼收集金币”的动画——蓝色金币代表偶数，红色代表奇数，黄色方块代表总和。当总和变成红色（奇数）时，最小的红色金币会“滑出”总和，变成蓝色（偶数）。动画里会加“叮”（加金币）、“滴”（减金币）的像素音效，让你“看得到、听得到”算法的每一步！


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码简洁度、实践价值”三个维度，筛选了3份超棒的题解——它们各有亮点，适合不同学习阶段的你～
</eval_intro>

**题解一：（来源：cq_loves_Capoo）**  
* **点评**：这份题解把核心思路“揉碎了”写，**新手友好到爆炸**！作者直接计算总和+找最小奇数，代码只有10行左右，变量名（sum总和、mi最小奇数）一看就懂。最贴心的是，作者特意标注“一定要开long long”——因为100000个1e9的数加起来会超过int的范围（这是很多人会踩的坑！）。从竞赛角度看，这份代码“短小精悍”，直接能交题，超实用～

**题解二：（来源：RioBlu）**  
* **点评**：这是一份“优化到极致”的题解！作者连数组都不用——直接用变量统计奇数个数（dan）和最小奇数（minn），空间复杂度降到了O(1)（几乎不占内存）。代码里“ans+=l”先加所有数，再判断奇数的处理逻辑，和题解一异曲同工，但更简洁。如果你想练“代码瘦身”，这份题解是绝佳参考～

**题解三：（来源：小水滴）**  
* **点评**：这份题解适合**喜欢“分步拆解”**的同学！作者把偶数直接加进总和，把奇数存进数组排序（从大到小），然后选“偶数个最大的奇数”——比如有5个奇数，就选前4个最大的，这样总和还是偶数。思路更直观，能帮你彻底理解“为什么要选偶数个奇数”。代码里的cmp函数（从大到小排序）也很经典，值得学习～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
很多同学第一次做这题会卡住，其实都是“三个关键点”没想通。咱们结合题解的经验，一一破解！
</difficulty_intro>

1. **关键点1：为什么要用“奇偶性”？**  
    * **分析**：题目要求“最大偶数和”，而偶数的生成规则是固定的——要么全选偶数，要么选偶数个奇数。直接算总和再调整，比“枚举所有可能的选法”高效100倍！就像你不会为了买玩具，把所有硬币的组合都试一遍，而是直接用“先拿全再调整”的聪明办法～  
    * 💡 **学习笔记**：用数学性质简化问题，比暴力枚举快得多！

2. **关键点2：为什么要减“最小的奇数”？**  
    * **分析**：总和是奇数时，必须去掉一个奇数才能变偶数。要让总和最大，当然要去掉**最小的那个奇数**——比如总和是11（奇数），有3、5两个奇数，去掉3比去掉5剩下的总和更大（11-3=8 > 11-5=6）。这就是“贪心”的精髓：每一步都选当前最优的！  
    * 💡 **学习笔记**：贪心算法的核心——“局部最优→全局最优”。

3. **关键点3：为什么要开long long？**  
    * **分析**：int类型最多能存2e9左右的数，而题目中每个数可以到1e9，100000个数加起来是1e14，远远超过int的范围！如果用int存总和，会“溢出”变成负数，结果完全错误。题解里都用了long long（能存到9e18），就是为了避免这个坑～  
    * 💡 **学习笔记**：写代码前先看数据范围，别让“溢出”毁了你的正确思路！

### ✨ 解题技巧总结
- **技巧1：用数学规律简化问题**：遇到“奇偶、整除”类问题，先想数学性质，别直接暴力枚举。  
- **技巧2：贪心选“最小损失”**：需要调整总和时，选“减少最少”的那个元素，保证结果最大。  
- **技巧3：提前考虑数据范围**：看到“大数相加”，立刻用long long，避免溢出！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了题解一和题解二的优点，既简洁又易懂，适合作为“模板”记住～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自“cq_loves_Capoo”和“RioBlu”的思路融合，是最简洁的核心实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        long long n, sum = 0, min_odd = 1e18; // min_odd初始化为极大值
        cin >> n;
        for (long long i = 0; i < n; ++i) {
            long long x;
            cin >> x;
            sum += x; // 累加所有数
            if (x % 2 == 1 && x < min_odd) {
                min_odd = x; // 记录最小的奇数
            }
        }
        // 如果总和是奇数，且存在奇数（min_odd不是初始的极大值）
        if (sum % 2 == 1 && min_odd != 1e18) {
            sum -= min_odd; // 减去最小奇数
        }
        cout << sum << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 读入数字个数n；  
  2. 循环读每个数x，累加到sum，同时记录最小的奇数min_odd；  
  3. 如果sum是奇数且有奇数存在，减去min_odd；  
  4. 输出最终的sum。


<code_intro_selected>
接下来看三个优质题解的“精华片段”，学它们的巧妙之处～
</code_intro_selected>

**题解一：（来源：cq_loves_Capoo）**  
* **亮点**：最直接的“总和+最小奇数”思路，变量名一看就懂。  
* **核心代码片段**：
    ```cpp
    long long n, s, mi, sum;
    mi = 9999999999; // 初始最小奇数为极大值
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &s);
        sum += s;
        if (s % 2 == 1) mi = min(mi, s); // 更新最小奇数
    }
    if (sum % 2 == 1) sum -= mi; // 调整总和为偶数
    ```
* **代码解读**：  
  作者用`mi`存最小奇数，`sum`存总和。循环里每读一个数，就检查是不是奇数，如果是，就更新`mi`为更小的那个。最后如果总和是奇数，减去`mi`——逻辑像“说话一样直白”，新手也能一秒懂！  
* 💡 **学习笔记**：变量名要“见名知意”，比如`mi`（min的缩写）比`a`、`b`好用100倍！

**题解二：（来源：RioBlu）**  
* **亮点**：不用数组，空间复杂度O(1)，极致简洁。  
* **核心代码片段**：
    ```cpp
    long long a, dan, minn = 99999999999, ans, l;
    cin >> a;
    for (int s = 0; s < a; s++) {
        cin >> l;
        ans += l;
        if (l % 2 == 1) {
            dan++; // 统计奇数个数
            minn = min(minn, l); // 最小奇数
        }
    }
    if (dan % 2 == 1) ans -= minn; // 奇数个数为奇数时，减最小奇数
    ```
* **代码解读**：  
  作者用`dan`统计奇数的个数——如果`dan`是奇数，说明总和是奇数（因为偶数加偶数还是偶数，奇数加奇数是偶数，奇数个数为奇数时总和是奇数）。这其实和“sum%2==1”是一样的效果，但更省内存（不用存所有奇数）。  
* 💡 **学习笔记**：能不用数组就不用，空间优化也是编程的重要技巧！

**题解三：（来源：小水滴）**  
* **亮点**：分步处理偶数和奇数，思路更直观。  
* **核心代码片段**：
    ```cpp
    long long sum = 0, b[100001];
    int h = 0; // 奇数的个数
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
        if (a[i] % 2 == 0) sum += a[i]; // 偶数直接加
        else b[++h] = a[i]; // 奇数存进数组
    }
    sort(b + 1, b + h + 1, cmp); // 从大到小排序奇数
    // 选偶数个最大的奇数（h是奇数就选h-1个）
    for (int i = 1; i <= ((h % 2 == 0) ? h : (h - 1)); i++) sum += b[i];
    ```
* **代码解读**：  
  作者把偶数和奇数分开——偶数直接加，奇数存起来排序（从大到小）。然后选“最多的偶数个奇数”：如果有5个奇数，就选前4个最大的；如果有4个，就全选。这样总和肯定是偶数，而且最大。这种“分步处理”的方式，能帮你彻底理解“为什么要选偶数个奇数”～  
* 💡 **学习笔记**：当思路不清晰时，把问题拆成“小步骤”，会更简单！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”算法的过程，Kay设计了一个**8位像素风的“鲨鱼金币挑战”**动画！就像玩FC红白机游戏一样，你能跟着鲨鱼一起收集金币，调整总和～
</visualization_intro>

### 🎮 动画设计方案
* **动画主题**：《Wet Shark的金币大冒险》——鲨鱼要收集金币凑偶数金额，买海底城堡的门票！  
* **风格与元素**：  
  - 8位像素风（像《超级玛丽》一样的复古画面）；  
  - 金币：蓝色（偶数）、红色（奇数），大小是8x8像素；  
  - 总和块：黄色的16x16像素方块，显示当前总和；  
  - 控制面板：复古按钮（单步、自动、重置）、速度滑块（慢→快）；  
  - 背景音乐：循环的8位“海底冒险”BGM（轻快的电子音）。

### 🕹️ 动画核心步骤
1. **初始化场景**：  
   - 屏幕左侧是“金币堆”（随机排列的蓝/红金币），右侧是黄色总和块（显示0）；  
   - 控制面板在屏幕底部，按钮是像素化的“Start”“Step”“Reset”。

2. **收集金币（总和累加）**：  
   - 点击“Start”，鲨鱼（像素小鲨鱼）会把金币一个个“推”到总和块里；  
   - 每推一个金币，总和块的数字增加，伴随“叮～”的像素音效；  
   - 蓝色金币推过去，总和块保持黄色；红色金币推过去，总和块会“闪一下”红色。

3. **调整总和（变偶数）**：  
   - 如果总和块变成“持续红色”（奇数），鲨鱼会停下，然后“找”最小的红色金币（闪烁）；  
   - 鲨鱼把这个红色金币“拉”出总和块，总和块变回黄色，伴随“滴～”的音效；  
   - 此时总和块显示的数字就是“最大偶数和”！

4. **胜利时刻**：  
   - 调整完成后，总和块会“爆炸”出像素星星，鲨鱼会跳起来（动画），播放“胜利”音效（上扬的8位音乐）；  
   - 屏幕底部弹出文字：“鲨鱼买到门票啦！总和是XX～”。

### 🎯 交互设计
- **单步执行**：点击“Step”，每一步只执行一个动作（推一个金币/拉一个金币），适合慢慢看细节；  
- **自动播放**：点击“Start”，动画自动运行，速度可以用滑块调整（慢→快）；  
- **重置**：点击“Reset”，回到初始状态，重新开始游戏。

### 💡 设计意图
- 用“鲨鱼推金币”的动画，把“累加总和”变成具象的动作；  
- 用颜色和音效强化“奇偶性”：红色=奇数（需要调整），黄色=偶数（目标状态）；  
- 游戏化的胜利动画，让你在“通关”中记住算法——就像玩游戏一样，越玩越熟练！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“奇偶+贪心”的思路，你可以解决很多类似的问题！比如“找最大奇数和”“选数求和能被3整除”等等～
</similar_problems_intro>

### 🌱 通用思路迁移
- 场景1：**找最大奇数和**——先算总和，若总和是偶数，减去最小的偶数；  
- 场景2：**选数求和能被3整除**——先算总和模3，若余1，减去最小的余1的数或两个余2的数；若余2，减去最小的余2的数或两个余1的数；  
- 场景3：**选k个数求和最大且为偶数**——先选k个最大的数，若总和是奇数，就替换其中一个最小的奇数为剩下的最大偶数（或反之）。

### 📚 洛谷练习推荐
1. **洛谷 P1866 编号**  
   🗣️ **推荐理由**：这题要统计“编号中奇数和偶数的个数”，和本题的“奇偶统计”思路一致，能帮你巩固奇偶性的应用～  
2. **洛谷 P2415 集合求和**  
   🗣️ **推荐理由**：这题要计算“所有子集的和的总和”，需要用到“每个元素出现的次数是2^(n-1)”的规律，和本题的“数学简化”思路异曲同工～  
3. **洛谷 P1090 合并果子**  
   🗣️ **推荐理由**：这题是经典的“贪心”问题——每次合并最小的两堆果子，和本题“减最小奇数”的贪心思路一致，能帮你加深对贪心的理解～  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解里的作者们分享了很多“踩坑经验”，这些都是比代码更宝贵的财富！
</insights_intro>

> **参考经验（来自 cq_loves_Capoo）**：“一定要开long long，因为数据范围累加起来大于int。”  
> **点评**：这是很多新手会犯的错误！比如int最多存2e9，而100000个1e9的数加起来是1e14，远超int的范围。作者的提醒，能让你避免“代码逻辑对，但结果错”的悲剧～  

> **参考经验（来自 RioBlu）**：“本题需要数组吗？不需要。”  
> **点评**：作者用“变量统计”代替数组，节省了内存。这告诉我们：**不是所有问题都需要数组**——能简化的地方就简化，代码会更高效！  


<conclusion>
今天的分析就到这里啦！这道题的核心是“奇偶性+贪心”，只要记住“先拿全再调整，调整选最小损失”，就能轻松解决～ 编程的乐趣在于“用简单的规律解决复杂的问题”，就像今天的“奇偶小魔法”一样！  
下次遇到类似的问题，不妨先想想：“有没有数学规律能简化？”“贪心选什么能让结果最优？” 相信你会越来越厉害的！💪
</conclusion>

---
处理用时：163.23秒
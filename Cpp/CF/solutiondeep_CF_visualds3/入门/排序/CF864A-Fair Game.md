# 题目信息

# Fair Game

## 题目描述

Petya and Vasya decided to play a game. They have $ n $ cards ( $ n $ is an even number). A single integer is written on each card.

Before the game Petya will choose an integer and after that Vasya will choose another integer (different from the number that Petya chose). During the game each player takes all the cards with number he chose. For example, if Petya chose number $ 5 $ before the game he will take all cards on which $ 5 $ is written and if Vasya chose number $ 10 $ before the game he will take all cards on which $ 10 $ is written.

The game is considered fair if Petya and Vasya can take all $ n $ cards, and the number of cards each player gets is the same.

Determine whether Petya and Vasya can choose integer numbers before the game so that the game is fair.

## 说明/提示

In the first example the game will be fair if, for example, Petya chooses number $ 11 $ , and Vasya chooses number $ 27 $ . Then the will take all cards — Petya will take cards $ 1 $ and $ 4 $ , and Vasya will take cards $ 2 $ and $ 3 $ . Thus, each of them will take exactly two cards.

In the second example fair game is impossible because the numbers written on the cards are equal, but the numbers that Petya and Vasya should choose should be distinct.

In the third example it is impossible to take all cards. Petya and Vasya can take at most five cards — for example, Petya can choose number $ 10 $ and Vasya can choose number $ 20 $ . But for the game to be fair it is necessary to take $ 6 $ cards.

## 样例 #1

### 输入

```
4
11
27
27
11
```

### 输出

```
YES
11 27
```

## 样例 #2

### 输入

```
2
6
6
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
6
10
20
30
20
10
20
```

### 输出

```
NO
```

## 样例 #4

### 输入

```
6
1
1
2
2
3
3
```

### 输出

```
NO
```

# AI分析结果

# 💡 Kay的C++算法解析：Fair Game 深入学习指南 💡

<introduction>
今天我们来一起分析「Fair Game」这道C++编程题。这道题看起来像是一个“卡片分配游戏”，但本质是**考验我们对数字出现次数的统计能力**。本指南会帮你理清思路、掌握核心技巧，还能通过像素动画直观看到算法运行过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟（或「编程技巧应用」，侧重**数字统计与条件判断**）

🗣️ **初步分析**：
解决这道题的关键，其实是**模拟题目要求的“分配规则”**——我们需要判断：是否恰好有两种数字，且每种数字的出现次数刚好是总卡片数的一半？  
简单来说，这就像“分糖果”：如果只有两种糖，且每种糖的数量刚好能平分给两个人，游戏才公平。  

### 核心算法流程
1. **统计次数**：用“桶数组”（或直接遍历）记录每个数字出现的次数；  
2. **检查种类**：判断是否恰好有两种不同的数字；  
3. **验证数量**：确认这两种数字的出现次数都等于总数量的一半（`n/2`）。  

### 可视化设计思路
我会用**8位像素风**设计一个“数字桶游戏”动画：  
- 屏幕右侧是一排“像素桶”（对应数字1~100），输入数字时，对应的桶会“堆叠”像素块（比如输入11，第11号桶会多一个黄色方块）；  
- 统计种类时，非零的桶会**闪烁高亮**（比如11和27号桶变橙色）；  
- 验证数量时，若满足条件，桶会变成**绿色**并播放“叮~”的胜利音效；否则变红色，伴随“嗡”的提示音。  
- 还支持“单步输入”（每点一次按钮输入一个数字）和“自动播放”（快速演示完整过程），像玩FC游戏一样直观！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法效率**三个维度筛选了3份优质题解，帮你快速掌握不同的解题风格~
</eval_intro>

**题解一：作者qwerta（思路最直白的模拟）**  
* **点评**：这份题解像“手把手教你分糖果”——用`z1/z2`记录两种数字，`s1/s2`统计次数，边输入边判断。一旦出现第三种数字，直接输出`NO`，**提前终止无效计算**。代码变量名超易懂（`z`代表“数字”，`s`代表“次数”），甚至还特判了`n`为奇数的情况（奇数不可能平分），严谨又贴心！

**题解二：作者Forever1507（最简洁的桶数组统计）**  
* **点评**：用`cnt[]`数组（桶）统计每个数字的出现次数，`sum`记录不同数字的数量，`a/b`保存两种数字。代码只有短短20行，逻辑却滴水不漏——先判断`sum`是否为2，再检查`cnt[a]`和`cnt[b]`是否相等。这种方法**空间效率高**，适合数字范围小的题目！

**题解三：作者以墨（最巧妙的排序法）**  
* **点评**：这是“偷懒的智慧”！先排序数组，那么相同数字会“挤在一起”。只要前`n/2`个数字相同、后`n/2`个数字相同，且两者不同，就满足条件。代码只用了`sort`和简单判断，**行数最少**，适合喜欢“巧解”的同学~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到的“坑”其实就3个——如何统计次数？如何判断种类？如何验证数量？结合优质题解，我帮你总结了“避坑指南”：
</difficulty_intro>

1. **难点1：如何高效统计数字的出现次数？**  
   * **分析**：题目中说每个数字≤100，所以用**桶数组**（比如`int cnt[105]`）最方便——数字`x`对应数组下标`x`，出现一次就`cnt[x]++`，时间复杂度O(n)。  
   * 💡 **学习笔记**：桶数组是“小范围数字统计”的神器，比`map`更快更省空间！

2. **难点2：如何判断恰好有两种不同的数字？**  
   * **分析**：可以边输入边统计（如题解一），一旦出现第三种数字直接`return 0`；也可以用桶数组遍历统计非零元素的数量（如题解二）。  
   * 💡 **学习笔记**：边处理边判断能“提前止损”，避免无用计算！

3. **难点3：如何确保两种数字的数量都是`n/2`？**  
   * **分析**：总数量`n`必须是偶数（否则直接`NO`），所以只要两种数字的数量**相等**，就一定是`n/2`。可以检查其中一种的数量是否等于`n/2`（如题解三），或直接比较两者数量（如题解二）。  
   * 💡 **学习笔记**：利用总数量的奇偶性，能快速排除不可能的情况！

### ✨ 解题技巧总结
- **技巧1**：用桶数组统计小范围数字的出现次数（比`map`更高效）；  
- **技巧2**：边输入边处理，提前终止无效情况（节省时间）；  
- **技巧3**：排序能简化判断（相同数字集中，减少统计步骤）；  
- **技巧4**：注意输入输出的**大小写**（题目要求`YES/NO`大写！）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**最简洁的通用实现**——来自作者以墨的排序法，只用了15行代码就能解决问题！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码通过排序将相同数字集中，直接判断前`n/2`和后`n/2`是否满足条件，逻辑最简。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <algorithm>
  using namespace std;
  const int N = 107;
  int a[N], n;
  int main() {
      scanf("%d", &n);
      if (n & 1) { // 奇数直接NO
          printf("NO\n");
          return 0;
      }
      for (int i = 1; i <= n; i++)
          scanf("%d", &a[i]);
      sort(a + 1, a + 1 + n);
      // 判断前n/2相同、后n/2相同，且两者不同
      if (a[1] == a[n >> 1] && a[(n >> 1) + 1] == a[n] && a[n] > a[1]) {
          printf("YES\n%d %d\n", a[1], a[n]);
      } else {
          printf("NO\n");
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 先读`n`，如果是奇数直接输出`NO`（无法平分）；  
  2. 读入数组，排序（相同数字集中）；  
  3. 检查前`n/2`个数字是否相同（第一种数字），后`n/2`是否相同（第二种数字），且两者不同——满足就输出`YES`，否则`NO`。


<code_intro_selected>
接下来剖析3份优质题解的核心片段，看看它们的“亮点”在哪里~
</code_intro_selected>

**题解一：作者qwerta（边输入边判断）**  
* **亮点**：不用额外数组，**空间复杂度O(1)**，适合数字范围大的情况。
* **核心代码片段**：
  ```cpp
  for(i=1;i<=n;i++){
      cin>>x;
      if(z1==0){z1=x;s1++;} // 第一个数字
      else if(z2==0&&x!=z1){z2=x;s2++;} // 第二个不同的数字
      else if(x==z1)s1++; // 第一个数字计数
      else if(x==z2)s2++; // 第二个数字计数
      else {cout<<"NO";return 0;} // 第三种数字，直接退出
  }
  ```
* **代码解读**：  
  用`z1`记录第一个出现的数字，`z2`记录第二个不同的数字，`s1/s2`统计次数。如果输入的数字既不是`z1`也不是`z2`，说明有第三种数字，直接输出`NO`——**提前终止，效率高**！
* 💡 **学习笔记**：边输入边处理能节省空间，适合“早期发现错误”的场景。

**题解二：作者Forever1507（桶数组统计）**  
* **亮点**：用桶数组清晰统计次数，代码可读性强。
* **核心代码片段**：
  ```cpp
  int cnt[105], sum=0, a=0, b=0;
  for(int i=1;i<=n;i++){
      int d; cin>>d;
      if(!cnt[d]){ // 第一次出现这个数字
          sum++;
          if(!a) a=d; // 存第一个数字
          else b=d;   // 存第二个数字
      }
      cnt[d]++; // 计数加一
  }
  ```
* **代码解读**：  
  `cnt[d]`记录数字`d`的出现次数，`sum`统计不同数字的数量，`a/b`保存两种数字。当`sum`不等于2时，直接输出`NO`——**逻辑直观，适合新手**！
* 💡 **学习笔记**：桶数组是统计小范围数字的“标配”，记住它！

**题解三：作者以墨（排序简化判断）**  
* **亮点**：用排序将问题转化为“区间判断”，代码最短。
* **核心代码片段**：
  ```cpp
  sort(a+1,a+1+n);
  if(a[1]==a[n>>1]&&a[(n>>1)+1]==a[n]&&a[n]>a[1]){
      printf("YES\n%d %d\n",a[1],a[n]);
  } else {
      printf("NO\n");
  }
  ```
* **代码解读**：  
  排序后，前`n/2`个数字必须是同一种（比如样例1的11），后`n/2`必须是另一种（比如27），且两者不同——**用排序“代替”了统计，超巧妙**！
* 💡 **学习笔记**：排序能将“分散的数字”集中，简化很多统计问题！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法运行，我设计了一个**8位像素风的“数字桶游戏”**动画，像玩《超级玛丽》一样学算法！
</visualization_intro>

### 🎮 动画演示主题：像素桶的数字统计游戏
**核心内容**：模拟输入数字→统计次数→判断条件的全过程，用像素块和音效强化记忆。

### 🎨 设计思路
- **风格**：仿FC红白机的8位像素风（比如背景是深蓝色，文字是黄色，桶是灰色，数字块是红色/绿色）；  
- **互动**：支持“单步输入”（每点一次按钮输入一个数字）、“自动播放”（快速演示）、“重置”（重新开始）；  
- **音效**：输入数字时“滴”一声，桶增加时“嗒”一声，满足条件时“叮~”的胜利音效，否则“嗡”的提示音。

### 📺 动画帧步骤（以样例1为例）
1. **场景初始化**：  
   屏幕左侧是“输入框”（显示“输入数字：”），右侧是10个像素桶（编号1~10，对应数字1~10，简化处理），底部是控制面板（开始/单步/重置按钮+速度滑块）。背景播放8位风格的轻快BGM。

2. **输入数字11**：  
   输入“11”后，右侧第11号桶（简化为第1号桶）会“长出”一个红色像素块（代表出现1次），伴随“滴”的音效。

3. **输入数字27**：  
   输入“27”后，第27号桶（简化为第2号桶）长出一个红色像素块，伴随“滴”的音效。

4. **输入数字27**：  
   第2号桶再长一个红色像素块（现在高度2），伴随“嗒”的音效。

5. **输入数字11**：  
   第1号桶再长一个红色像素块（高度2），伴随“嗒”的音效。

6. **统计种类**：  
   遍历桶数组，第1、2号桶非零，**闪烁橙色**，伴随“叮”的音效，屏幕提示“共2种数字！”。

7. **验证数量**：  
   两个桶的高度都是2（等于`4/2`），桶变成**绿色**，屏幕弹出“YES！”，伴随胜利音效，同时显示“11 27”。

### 💬 旁白提示（像素气泡）
- “输入11啦，第1号桶增加一个方块！”  
- “现在有2种数字，检查它们的数量是不是都是2？”  
- “答对了！游戏公平～”

<visualization_conclusion>
这个动画把“抽象的统计”变成了“看得见的像素变化”，你甚至能通过“桶的高度”直接看出数量是否相等——是不是比看代码更直观？
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“统计数字次数+条件判断”的技巧后，你可以解决很多类似的问题——比如统计成绩分布、投票结果、水果数量等等！
</similar_problems_intro>

### 🌍 通用思路迁移
- **场景1**：统计班级成绩，判断是否有两种成绩各占一半；  
- **场景2**：统计水果销量，判断是否有两种水果销量相同；  
- **场景3**：统计投票结果，判断是否有两个候选人得票相同且占总票数的一半。

### 📚 洛谷练习推荐
1. **洛谷 P1059 明明的随机数**  
   🗣️ **推荐理由**：练习“统计不同数字的数量”，还要排序输出——巩固桶数组和排序的用法！  
2. **洛谷 P1152 欢乐的跳**  
   🗣️ **推荐理由**：检查数字出现的次数是否连续——锻炼“统计+逻辑判断”的能力！  
3. **洛谷 P2670 扫雷游戏**  
   🗣️ **推荐理由**：模拟统计每个格子周围的雷数——进阶版“桶统计”，更贴近实际问题！  
4. **洛谷 P1200 你的飞碟在这儿**  
   🗣️ **推荐理由**：统计字符出现的次数，判断是否满足条件——把“数字”换成“字符”，考验知识迁移能力！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解里藏着很多“踩坑经验”，这些都是前辈们的血泪教训，一定要记住！
</insights_intro>

> **参考经验（来自作者111_222_333）**：“再提醒一下，这里的no和yes是大写，大写！！！！！”  
> **点评**：编程中大小写是“敏感”的！比如输出`yes`会被判错，一定要严格按照题目要求写`YES`——这个细节能帮你避免很多“玄学错误”！

> **参考经验（来自作者T_F_P）**：“打表准备：int dabiao[10000]; 先清零（memset）”  
> **点评**：数组初始化很重要！如果不`memset`，桶数组里会有“脏数据”，导致统计错误——养成“初始化变量”的好习惯！


<conclusion>
本次关于「Fair Game」的分析就到这里啦！这道题的核心是“统计+判断”，只要掌握了桶数组、排序这些技巧，就能轻松解决。记住：编程的进步来自“多练+多总结”——下次遇到类似的统计问题，你一定能快速解决！💪
</conclusion>

---
处理用时：152.28秒
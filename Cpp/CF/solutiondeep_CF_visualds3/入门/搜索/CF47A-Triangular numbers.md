# 题目信息

# Triangular numbers

## 题目描述

A triangular number is the number of dots in an equilateral triangle uniformly filled with dots. For example, three dots can be arranged in a triangle; thus three is a triangular number. The $ n $ -th triangular number is the number of dots in a triangle with $ n $ dots on a side. ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF47A/7344b4fd5acb7c973775cffc0c5a51a81c6ee4d9.png). You can learn more about these numbers from Wikipedia (http://en.wikipedia.org/wiki/Triangular\_number).

Your task is to find out if a given integer is a triangular number.

## 样例 #1

### 输入

```
1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
2
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
3
```

### 输出

```
YES
```

# AI分析结果

# 💡 Kay的C++算法解析：Triangular numbers 深入学习指南 💡

## 引言
今天我们要解决的问题是“判断一个数是否是三角数”——三角数就像用 dots 堆成的等边三角形：第1层1个点，第2层2个点……第i层i个点，总点数就是1+2+…+i = i(i+1)/2。我们的任务就是看给定的数能不能刚好堆成这样的“点金字塔”～


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（方程整数解判断） + 编程技巧应用  

🗣️ **初步分析**：  
解决这道题的核心是**找到整数i，让i(i+1)/2等于输入的n**。这就像“找一把能打开金字塔门的钥匙i”——常见的“找钥匙”方法有三种：  
1. **逐个试（枚举）**：从i=1开始，算i(i+1)/2，直到等于n或超过（像试遍所有钥匙）；  
2. **猜数字（二分）**：利用三角数“越来越大”的单调性，每次猜中间值，缩小范围（像玩“高了低了”的游戏）；  
3. **解方程（数学公式）**：直接通过二次方程求根公式算出i，再验证是否整数（最快的“钥匙检测机”）。  

**核心难点**：  
- 如何将问题转化为数学方程？（从三角数公式推导出i²+i-2n=0）  
- 如何处理浮点数精度？（比如用sqrt计算时的误差，需要用整数验证）  
- 如何选择高效的算法？（小数据枚举没问题，大数据用数学或二分）  

**可视化设计思路**：  
我们会做一个**8位像素风的“金字塔搭建模拟器”**——用像素块堆出每层的点，实时显示当前层数i和总和sum。每堆一层播放“嗒”的音效，成功时金字塔发光+胜利音效，失败时小人摇头+提示音效。还能手动“单步堆层”或自动播放，像玩复古游戏一样理解算法！


## 2. 精选优质题解参考

我从思路清晰度、代码可读性、算法效率等角度筛选了3份超棒的题解，一起来看看～

### 题解一：二分法（作者：fangd，赞：8）
* **点评**：这份题解把“三角数单调递增”的性质用活了！二分法就像“猜数字”——先猜中间值mid，若mid*(mid+1)/2 < n，说明“猜小了”，往左半区找；否则往右半区找。最后验证找到的l是否真的满足条件。代码里`l = static_cast<int>(sqrt(n))`优化了初始范围，减少循环次数。整体思路清晰，代码规范，是“利用单调性优化算法”的好例子！

### 题解二：求根公式法（作者：PC_DOS，赞：2）
* **点评**：这是最“数学”的解法！直接把问题转化为二次方程i²+i-2n=0，用求根公式算出正根i=(-1+sqrt(1+8n))/2。然后验证这个i是不是整数（因为浮点数可能有误差，所以用i*(i+1)是否等于2n来确认）。代码超简洁，一行公式解决核心问题，适合想“用数学偷懒”的同学～

### 题解三：O(1)范围验证法（作者：pigstd，赞：0）
* **点评**：这个解法很聪明！因为i(i+1)≈i²，所以i≈sqrt(2n)。直接取m=sqrt(2n)，然后验证m*(m+1)/2是否等于n——只用一次计算+验证，时间复杂度O(1)！虽然思路简单，但抓住了“三角数的近似范围”，是“用数学规律简化问题”的典型～


## 3. 核心难点辨析与解题策略

### 关键点1：如何把问题转化为数学方程？
* **分析**：三角数的公式是i(i+1)/2 = n，两边乘2得i²+i-2n=0——这是一个关于i的一元二次方程！只要找到这个方程的**正整数解**，就能判断n是三角数。  
* 💡 **学习笔记**：解决数学问题的第一步，是把“文字描述”翻译成“数学公式”！

### 关键点2：如何处理浮点数精度问题？
* **分析**：用sqrt计算时，比如sqrt(8n+1)可能得到近似值（比如sqrt(9)=3，但sqrt(8)=2.828…）。所以不能直接用浮点数判断，必须**转成整数后验证**——比如计算p=sqrt(delta)，再检查p*p是否等于delta（确认是完全平方数）。  
* 💡 **学习笔记**：浮点数“不靠谱”，整数验证才是王道！

### 关键点3：如何选择高效的算法？
* **分析**：  
  - 若n很小（比如≤500）：枚举法最直观，直接试i=1到i=32（因为32*33/2=528>500）；  
  - 若n很大：二分法（O(log n)）或数学公式法（O(1)）更快。  
* 💡 **学习笔记**：算法的选择要“看菜吃饭”——根据数据范围选最快的方法！

### ✨ 解题技巧总结
1. **公式转化**：把问题翻译成数学方程，是解决数学题的核心；  
2. **精度验证**：用整数运算验证浮点数结果，避免误差；  
3. **范围优化**：比如枚举时不用到n，只用到sqrt(2n)，减少循环次数；  
4. **单调性利用**：如果函数单调，二分法是“加速神器”！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（数学公式法）
* **说明**：综合了求根公式法和精度验证的优点，是最简洁高效的实现。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int n;
    cin >> n;
    int delta = 1 + 8 * n;  // 判别式Δ=1+8n
    int p = static_cast<int>(sqrt(delta));  // Δ的平方根（转整数）
    // 判断Δ是完全平方数，且(p-1)能被2整除（保证i是整数）
    if (p * p == delta && (p - 1) % 2 == 0) {
        cout << "YES" << endl;
    } else {
        cout << "NO" << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 计算判别式`delta=1+8n`（来自二次方程i²+i-2n=0的判别式Δ=b²-4ac=1+8n）；  
  2. 用`sqrt(delta)`算出平方根p（转成整数）；  
  3. 验证p²是否等于delta（确认Δ是完全平方数），且(p-1)是偶数（因为i=(p-1)/2必须是整数）；  
  4. 满足条件输出YES，否则NO。


### 题解一：二分法核心代码片段
* **亮点**：利用单调性优化，减少循环次数。  
* **核心代码片段**：
```cpp
int l = static_cast<int>(sqrt(n)), r = (n << 1) + 1;
while (l < r) {
    int mid = (l + r) >> 1;  // 等价于(mid + r)/2（整数除法）
    if (mid * (mid + 1) < (n << 1)) {  // mid*(mid+1) < 2n → 猜小了
        l = mid + 1;
    } else {  // 猜大了或刚好
        r = mid;
    }
}
if (l * (l + 1) == (n << 1)) {  // 验证结果
    puts("YES");
} else {
    puts("NO");
}
```
* **代码解读**：  
  - `l`初始化为sqrt(n)（缩小左边界），`r`初始化为2n+1（右边界）；  
  - 循环中每次猜中间值`mid`，根据`mid*(mid+1)`和2n的大小调整边界；  
  - 最后验证`l`是否满足条件——二分法的关键是“每次缩小一半范围”！  
* 💡 **学习笔记**：二分法的前提是“数据单调”，比如三角数越来越大，所以能用！


### 题解三：O(1)范围验证法核心代码片段
* **亮点**：用近似范围快速缩小验证范围，O(1)时间解决。  
* **核心代码片段**：
```cpp
int m = static_cast<int>(sqrt(n * 2));
if (m * (m + 1) / 2 == n) {
    cout << "YES";
} else {
    cout << "NO";
}
```
* **代码解读**：  
  - 因为i(i+1)≈i²，所以i≈sqrt(2n)，取m=sqrt(2n)；  
  - 直接验证m*(m+1)/2是否等于n——只用一次计算！  
* 💡 **学习笔记**：找“近似范围”能帮我们快速定位答案，避免不必要的循环！


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：像素金字塔搭建挑战（8位FC风格）
**设计思路**：用复古游戏的像素风格，让算法“动起来”——像玩《超级马里奥》一样堆金字塔，直观理解“枚举法”的过程！

### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 背景是FC风格的草地（绿色像素块），中间是一个空的金字塔底座（灰色像素框）；  
   - 右上角显示“当前层数i：0”、“当前总和sum：0”；  
   - 控制面板有“单步堆层”“自动播放”“重置”按钮，还有速度滑块（1x~5x）；  
   - 播放8位风格的轻快BGM（比如《超级马里奥》的背景音）。

2. **算法启动**：  
   - 输入n后，点击“开始”，像素小人（红色方块）从金字塔底部出现，准备堆第一层；  
   - 第一次点击“单步堆层”，小人堆出第一层（1个黄色像素块），右上角i变为1，sum变为1，播放“嗒”的音效。

3. **核心步骤演示**：  
   - 每点击一次“单步堆层”，小人堆出下一层（i增加1，sum增加i），对应的像素块从左到右排列；  
   - 如果sum等于n：金字塔顶部出现金色星星，播放“叮～”的胜利音效，弹出“YES！成功堆成三角数！”的文字；  
   - 如果sum超过n：小人停下，摇头（像素块左右晃动），播放“哔～”的提示音效，弹出“NO！不是三角数～”的文字。

4. **自动播放模式**：  
   - 滑动速度滑块到3x，点击“自动播放”，小人快速堆层，每堆一层的音效加快，直到sum等于或超过n——像看“AI自动通关”一样！

5. **游戏化元素**：  
   - 每堆完5层，弹出“小关卡完成！”的提示，加10分（右上角显示分数）；  
   - 成功堆成金字塔，分数翻倍，播放“胜利进行曲”（8位版）。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
三角数的问题本质是“判断方程的整数解”，这种思路还能解决：  
1. **平方数判断**：判断n是否是某个整数的平方（方程x²=n）；  
2. **立方数判断**：判断n是否是某个整数的立方（方程x³=n）；  
3. **斐波那契数判断**：判断n是否是斐波那契数列中的数（方程涉及黄金分割比）。

### 练习推荐（洛谷）
1. **洛谷 P1025 数的划分**  
   - 🗣️ **推荐理由**：需要将数分成若干份，用到类似的“枚举+验证”思路，巩固“数学转化”技巧。  
2. **洛谷 P1152 欢乐的跳**  
   - 🗣️ **推荐理由**：判断数组中的差是否唯一，用到“范围优化”和“整数验证”，锻炼细节处理能力。  
3. **洛谷 P1217 [USACO1.5] 回文质数**  
   - 🗣️ **推荐理由**：判断数是否是回文且质数，用到“数学判断”和“效率优化”，综合提升编程能力。  


## 7. 学习心得与经验分享

### 参考经验（来自题解作者wpy233）
> “我一开始用sqrt的小数部分判断，结果WA了！后来发现小数部分的范围会变化，于是分段处理——但其实更好的方法是用整数验证！”  
* **点评**：这位作者的踩坑经历提醒我们：**浮点数的精度问题很容易忽略，一定要用整数运算验证结果**！比如用i*(i+1)是否等于2n，比判断小数部分更可靠。


## 结语
通过这道题，我们学会了用“数学公式”“枚举”“二分”三种方法解决三角数问题，还通过像素动画直观看到了算法的过程～ 记住：**编程的本质是解决问题，而数学是解决问题的“工具库”**！下次遇到类似的“判断整数解”问题，不妨先想想“能不能用方程解决”～  

加油，下次我们一起挑战更难的问题！💪

---
处理用时：127.55秒
# 题目信息

# Polycarp and Letters

## 题目描述

Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string $ s $ consisting only of lowercase and uppercase Latin letters.

Let $ A $ be a set of positions in the string. Let's call it pretty if following conditions are met:

- letters on positions from $ A $ in the string are all distinct and lowercase;
- there are no uppercase letters in the string which are situated between positions from $ A $ (i.e. there is no such $ j $ that $ s[j] $ is an uppercase letter, and $ a_{1}<j<a_{2} $ for some $ a_{1} $ and $ a_{2} $ from $ A $ ).

Write a program that will determine the maximum number of elements in a pretty set of positions.

## 说明/提示

In the first example the desired positions might be $ 6 $ and $ 8 $ or $ 7 $ and $ 8 $ . Positions $ 6 $ and $ 7 $ contain letters 'a', position $ 8 $ contains letter 'b'. The pair of positions $ 1 $ and $ 8 $ is not suitable because there is an uppercase letter 'B' between these position.

In the second example desired positions can be $ 7 $ , $ 8 $ and $ 11 $ . There are other ways to choose pretty set consisting of three elements.

In the third example the given string $ s $ does not contain any lowercase letters, so the answer is $ 0 $ .

## 样例 #1

### 输入

```
11
aaaaBaabAbA
```

### 输出

```
2
```

## 样例 #2

### 输入

```
12
zACaAbbaazzC
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
ABC
```

### 输出

```
0
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Polycarp and Letters 深入学习指南 💡

<introduction>
  今天我们来一起分析「Polycarp and Letters」这道C++编程题。题目需要我们从混合大小写字母的字符串中，找到**被大写字母分隔的小写字母区域**，并统计这些区域里「不同小写字母的最大数量」。这道题能帮我们巩固**字符串遍历**和**统计去重**的基础技巧，跟着Kay一步步拆解吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟（字符串遍历与区域统计）

🗣️ **初步分析**：
解决这道题的核心是「模拟」——就像我们整理彩色积木：把一堆混合红（大写）、蓝（小写）的积木，按红色积木分成几堆蓝积木，每堆里数有多少种不同的蓝色（比如浅蓝、深蓝、天蓝），最后选最多的那堆。  

具体来说，**模拟的核心流程**是：  
1. 遍历字符串的每个字符；  
2. 用「大写字母」当「分隔符」，把字符串分成多个「纯小写字母区域」；  
3. 对每个区域，统计里面**不同小写字母的数量**；  
4. 所有区域的数量中，取最大值就是答案。  

**核心难点**：  
- 如何正确分割区域？（比如字符串开头或结尾没有大写字母的情况）  
- 如何高效统计区域内的不同字母？（去重的方法）  
- 不要漏掉最后一个区域的统计！（比如字符串以小写字母结尾时，需要额外计算）  

**可视化设计思路**：  
我们会用「8位像素风」做动画——字符串是横向排列的像素块（小写字母是蓝色，大写是红色），遍历指针是黄色小箭头。遇到小写字母时，对应的字母会变成「浅蓝」标记已统计；遇到大写字母时，会弹出一个数字显示当前区域的不同字母数，然后重置标记。最后，最大的数字会闪烁并播放「胜利音效」，帮你直观看到结果！


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度」「代码可读性」「实践价值」三个维度筛选了3份优质题解，它们的思路都很直接，非常适合入门学习~
</eval_intro>

**题解一：_Spectator_（简洁高效的标记数组法）**
* **点评**：这份题解的思路像「整理抽屉」一样直白——用`js`数组标记每个小写字母是否出现过（`js['a']=1`表示'a'出现过）。遍历字符串时，遇到小写字母就标记并计数，遇到大写字母就「清空抽屉」（重置数组和计数），最后还要检查「最后一个抽屉」（避免漏掉末尾的小写区域）。代码用`islower()`和`isupper()`函数判断大小写，变量名`len`（当前区域的不同字母数）、`ma`（最大值）都很易懂，边界处理也很严谨，直接复制就能跑通！

**题解二：yxy666（利用set的唯一性去重）**
* **点评**：这位作者用了STL的`set`容器——`set`的特点是「自动去重」，就像一个「不会装重复玩具的盒子」。遍历字符串时，遇到小写字母就放进`set`，遇到大写字母就统计`set`的大小（不同字母数），然后清空`set`。这种方法不用手动维护标记数组，代码更简洁，适合理解「容器的妙用」~

**题解三：Fatelism（基础数组统计法）**
* **点评**：这份题解用`ch[26]`数组（对应26个小写字母）统计是否出现过，思路和题解一类似，但更「接地气」——直接用`s[i]-'a'`把字母转成0-25的索引（比如'a'→0，'b'→1）。作者特别提醒：「如果字符串以小写结尾，要再统计一次」，这是很多初学者会漏掉的点，非常贴心！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常犯的错误集中在「区域分割」「去重统计」和「边界处理」上。结合优质题解，Kay帮你提炼了3个核心关键点：
</difficulty_intro>

1.  **关键点1：如何正确分割区域？**  
    * **分析**：大写字母是「分隔符」，每个区域是「两个大写字母之间的小写字母」，或者「开头到第一个大写」「最后一个大写到结尾」。比如字符串`"aBcDe"`，区域是`"a"`、`"c"`、`"e"`。解决方法是：遍历到大写字母时，**立刻统计当前区域的数量**，然后重置统计工具（数组或set）。  
    * 💡 **学习笔记**：分割区域的核心是「遇到分隔符就结算」。

2.  **关键点2：如何统计不同的小写字母？**  
    * **分析**：有两种常用方法：  
      - 数组标记：用`bool`或`int`数组（大小26），索引对应字母（`a→0`，`b→1`），出现过就设为`1`；  
      - 容器去重：用`set`或`unordered_set`，插入字母时自动去重，`size()`就是不同字母数。  
      两种方法都对，数组更快（适合数据小的情况），容器更简洁（适合不想算索引的情况）。  
    * 💡 **学习笔记**：选择统计方法的核心是「简单好用」，不用追求复杂。

3.  **关键点3：不要漏掉最后一个区域！**  
    * **分析**：如果字符串以小写字母结尾，遍历结束后不会触发「大写字母的结算逻辑」，导致最后一个区域的数量没被统计。解决方法是：遍历结束后，**再单独统计一次当前区域的数量**（比如题解一中的`max(ma, len)`）。  
    * 💡 **学习笔记**：处理边界情况的核心是「考虑所有可能的结尾」。

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，Kay总结了3个通用技巧，帮你举一反三：
</summary_best_practices>
- **技巧1：用「分隔符」分割区域**：遇到固定的分隔符（比如本题的大写字母），立刻结算当前区域的结果，再处理下一个区域。  
- **技巧2：选择合适的去重工具**：数据小用数组，数据大用容器，优先选自己能看懂的。  
- **技巧3：检查边界情况**：比如开头、结尾、空输入，写完代码一定要测试这些情况（比如样例3是全大写，答案0）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「通用核心代码」——综合了优质题解的思路，用数组统计，逻辑清晰，适合入门！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码结合了题解一和题解三的思路，用数组标记字母，处理了所有边界情况，是最基础的实现方式。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    #include <cstring> // 用于memset
    using namespace std;

    int main() {
        int n;
        string s;
        cin >> n >> s;

        bool exist[26] = {false}; // 标记字母是否出现过
        int current_count = 0;    // 当前区域的不同字母数
        int max_count = 0;        // 最大数量

        for (char c : s) { // 遍历字符串的每个字符（C++11及以上支持）
            if (islower(c)) { // 是小写字母
                int idx = c - 'a'; // 转成0-25的索引
                if (!exist[idx]) { // 如果没出现过
                    exist[idx] = true;
                    current_count++;
                }
            } else { // 是大写字母，结算当前区域
                if (current_count > max_count) {
                    max_count = current_count;
                }
                // 重置统计工具
                memset(exist, 0, sizeof(exist));
                current_count = 0;
            }
        }

        // 处理最后一个区域（如果以小写结尾）
        if (current_count > max_count) {
            max_count = current_count;
        }

        cout << max_count << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 用`exist`数组标记字母是否出现过，`current_count`统计当前区域的不同字母数，`max_count`存最大值；  
  2. 遍历字符串，遇到小写字母就标记并计数，遇到大写字母就结算并重置；  
  3. 最后检查最后一个区域，输出最大值。


<code_intro_selected>
接下来看3份优质题解的「核心片段」，学习它们的亮点~
</code_intro_selected>

**题解一：_Spectator_（标记数组+函数判断）**
* **亮点**：用`islower()`和`isupper()`函数简化大小写判断，代码更简洁。
* **核心代码片段**：
    ```cpp
    for(int i=0;i<n;i++) {
        if(islower(st[i])&&js[st[i]]==0) // 小写且未出现过
            len++,js[st[i]]=1;
        if(isupper(st[i])) // 大写字母，结算
            ma=max(ma,len),len=0,memset(js,0,sizeof(js));
    }
    cout<<max(ma,len); // 处理最后一个区域
    ```
* **代码解读**：  
  - `islower(st[i])`判断是否是小写字母，`js[st[i]]==0`判断是否未出现过；  
  - 遇到大写字母时，用`max(ma, len)`更新最大值，然后用`memset`清空`js`数组（`memset`是C++的内存初始化函数，把数组所有元素设为0）；  
  - 最后用`max(ma, len)`处理末尾的小写区域。
* 💡 **学习笔记**：`islower`和`isupper`是C++标准库的函数，能帮你少写很多条件判断！

**题解二：yxy666（set自动去重）**
* **亮点**：用`set`的「自动去重」特性，不用手动维护标记数组。
* **核心代码片段**：
    ```cpp
    set<char> s_set; // 存当前区域的不同字母
    for(int i=1;i<=n;i++){
        if(a[i]>='A'&&a[i]<='Z'){ // 大写字母，结算
            sum=s_set.size(); // set的大小就是不同字母数
            s_set.clear(); // 清空set
            ans=max(sum,ans);
        } else {
            s_set.insert(a[i]); // 插入小写字母，自动去重
        }
    }
    sum=s_set.size(); // 处理最后一个区域
    ans=max(ans,sum);
    ```
* **代码解读**：  
  - `set<char>`是一个「不允许重复元素的容器」，插入相同字母会失败；  
  - 遇到大写字母时，`s_set.size()`就是当前区域的不同字母数，然后用`clear()`清空；  
  - 最后统计末尾的区域。
* 💡 **学习笔记**：STL容器能帮你简化重复工作，比如`set`的去重、`vector`的动态扩容，要多尝试！

**题解三：Fatelism（数组索引直接转）**
* **亮点**：用`c[i]-'a'`直接把字母转成数组索引，不用记ASCII码。
* **核心代码片段**：
    ```cpp
    int ch[26]={0}; // 对应26个小写字母
    for(int i=0;i<s.length();i++){
        if(s[i]>='a'&&s[i]<='z'){
            ch[s[i]-'a']=1; // 标记为已出现
        } else { // 大写字母，结算
            int k=0;
            for(int j=0;j<26;j++) if(ch[j]==1) k++; // 统计不同字母数
            if(k>max) max=k;
            memset(ch,0,sizeof(ch)); // 重置数组
        }
    }
    // 处理最后一个区域
    int k=0;
    for(int j=0;j<26;j++) if(ch[j]==1) k++;
    if(k>max) max=k;
    ```
* **代码解读**：  
  - `s[i]-'a'`是「字符转索引」的小技巧：比如`'a'-'a'=0`，`'b'-'a'=1`，刚好对应数组的0-25索引；  
  - 遇到大写字母时，遍历`ch`数组统计有多少个`1`（即不同字母数）；  
  - 最后同样要处理末尾区域。
* 💡 **学习笔记**：`c-'a'`是处理小写字母的常用技巧，一定要记住！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地「看到」算法运行过程，Kay设计了一个「8位像素风」的动画——像玩FC游戏一样学算法！
</visualization_intro>

### 🎮 动画演示主题：像素字符串的「找不同」冒险
我们把字符串变成「像素积木」，每块积木代表一个字符：  
- 小写字母：蓝色积木（不同字母用浅蓝、深蓝、天蓝区分）；  
- 大写字母：红色积木；  
- 遍历指针：黄色小箭头（像游戏里的主角）。

### 🚀 动画核心流程（结合游戏化元素）
1. **初始化场景**：  
   - 屏幕顶部是「像素字符串」（比如样例1的`"aaaaBaabAbA"`），横向排列；  
   - 底部是「控制面板」：有「开始/暂停」「单步执行」「重置」按钮，还有一个「速度滑块」（控制动画快慢）；  
   - 背景播放8位风格的轻松BGM（比如《超级马里奥》的背景音乐）。

2. **算法启动**：  
   - 黄色箭头从字符串第一个字符开始移动，每移动一步播放「嘀」的音效；  
   - 遇到小写字母（蓝色积木）：积木变成「浅蓝」（标记已统计），右侧弹出一个小数字（当前区域的不同字母数，比如第一个'a'→数字1，第二个'a'→数字不变）；  
   - 遇到大写字母（红色积木）：播放「叮」的音效，当前区域的数字会「跳一下」（提示结算），然后所有浅蓝积木变回蓝色（重置标记），数字归零。

3. **目标达成**：  
   - 遍历结束后，所有区域的数字会「浮起来」，最大的数字会变成「闪烁的金色」，并播放「胜利音效」（比如《魂斗罗》的通关音乐）；  
   - 如果没有小写字母（比如样例3），屏幕会显示「0」，并播放「提示音效」（短促的「哔」声）。

### 🎯 设计亮点：为什么这么做？
- **像素风格**：复古游戏的视觉效果能降低学习的「距离感」，让你觉得「算法像游戏一样好玩」；  
- **音效提示**：不同操作对应不同音效，能强化你的「操作记忆」（比如「叮」声=结算，「嘀」声=遍历）；  
- **数字闪烁**：最大数字的金色闪烁，能帮你快速抓住「核心结果」，不用自己数。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的「模拟+统计」思路能解决很多字符串问题，比如「统计连续子串的特征」「按分隔符分割字符串」。Kay给你推荐3道洛谷的相似题目，帮你巩固技巧~
</similar_problems_intro>

### 通用思路迁移
「模拟+统计」的思路常用于：  
1. 统计字符串中「连续数字的和」；  
2. 按「逗号」分割字符串，统计每个子串的长度；  
3. 找「最长连续相同字符」的长度。

### 洛谷练习推荐
1. **洛谷 P1598 - 垂直柱状图**  
   🗣️ **推荐理由**：这道题需要统计字母出现的次数，并用柱状图展示。和本题一样，需要遍历字符串、统计字符，能帮你巩固「字符统计」的技巧。

2. **洛谷 P3741 - honoka的键盘**  
   🗣️ **推荐理由**：这道题需要处理字符串中的「连续按键」，和本题的「区域分割」思路类似，能帮你练习「按条件分割区域」。

3. **洛谷 P1055 - 谁拿了最多奖学金**  
   🗣️ **推荐理由**：这道题需要统计多个学生的奖学金，取最大值。和本题的「统计最大值」思路一致，能帮你巩固「遍历+更新最大值」的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里的「踩坑经验」比代码更宝贵！Kay摘录了2条，帮你少走弯路：
</insights_intro>

> **经验1（来自Fatelism）**：「如果字符串以小写字母结尾，那么就会少统计一次」  
> **点评**：这是很多初学者的「高频错误」！解决方法很简单——遍历结束后再统计一次当前区域的数量。下次写代码时，一定要想：「我的循环有没有覆盖所有情况？」

> **经验2（来自_Spectator_）**：「题解千万条，理解第一条。直接粘题解，棕名两行泪。」  
> **点评**：这句话太重要了！复制题解能通过测试，但永远学不会算法。一定要自己读代码、想思路，哪怕慢一点，也比「复制粘贴」有用。


<conclusion>
本次关于「Polycarp and Letters」的分析就到这里啦！这道题虽然简单，但能帮你掌握「字符串遍历」「区域分割」「统计去重」的基础技巧——这些都是未来解决复杂问题的「积木」。记住：编程的进步不是「做难题」，而是「把简单题做懂、做透」。下次我们再一起探索更有趣的算法挑战！💪
</conclusion>

---

---
处理用时：139.56秒
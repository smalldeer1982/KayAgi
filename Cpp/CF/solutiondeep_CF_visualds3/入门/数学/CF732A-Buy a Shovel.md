# 题目信息

# Buy a Shovel

## 题目描述

Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for $ k $ burles. Assume that there is an unlimited number of such shovels in the shop.

In his pocket Polycarp has an unlimited number of "10-burle coins" and exactly one coin of $ r $ burles ( $ 1<=r<=9 $ ).

What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of $ r $ burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.

## 说明/提示

In the first example Polycarp can buy 9 shovels and pay $ 9·117=1053 $ burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.

In the second example it is enough for Polycarp to buy one shovel.

In the third example Polycarp should buy two shovels and pay $ 2·15=30 $ burles. It is obvious that he can pay this sum without any change.

## 样例 #1

### 输入

```
117 3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
237 7
```

### 输出

```
1
```

## 样例 #3

### 输入

```
15 2
```

### 输出

```
2
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Buy a Shovel 深入学习指南 💡

<introduction>
  今天我们来一起分析「Buy a Shovel」这道趣味C++题！它看似是关于“买铲子找零”的生活问题，实则藏着**枚举算法**的小技巧。本指南会帮你理清思路、看懂代码，还能通过像素动画直观“看”到算法运行——一起开始吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（暴力枚举）

🗣️ **初步分析**：
解决这道题的关键是「枚举」——就像你找钥匙时，把钥匙串里的钥匙**逐个试**，直到打开门。在这里，我们要找“最小的铲子数量i”，使得：  
- 买i把铲子的总价（i×k）要么是10的倍数（只用10元硬币，不用r元）；  
- 要么总价的个位等于r（用10元硬币+那枚r元硬币，刚好凑够）。  

因为题目明确说“买10把一定能付清”（10×k是10的倍数），所以我们只需要从i=1试到i=10，**最多试10次**就能找到答案——完全不会超时！  

### 核心算法流程与可视化设计
算法的核心是「逐个试i，检查总价个位」。可视化时，我们可以用**8位像素风格**模拟这个过程：  
- 用像素数字显示当前试的i（比如i=1时，屏幕左侧显示“1”）；  
- 用彩色像素块表示总价的个位（比如k=117时，i=1的个位是7，用红色块；i=9的个位是3，用绿色块）；  
- 当个位是0或r时，像素块**闪烁+播放“叮”的音效**，提示找到答案！  


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码简洁度、技巧启发性」三个维度筛选了3份优质题解，帮你快速掌握关键！
</eval_intro>

**题解一：Scrutiny（赞：9）**  
* **点评**：这份题解把问题“榨”得很干——直接枚举i=1到10，用一行条件判断（`i*k%10==r || i*k%10==0`）精准命中核心！代码只有10行，变量名（k、r）和逻辑完全对应题目描述，**新手看一眼就懂**。更厉害的是，它抓住了“i最多到10”的关键点，避免了不必要的循环，效率拉满！

**题解二：chenpengda（赞：0）**  
* **点评**：这道题的“隐藏优化大师”！作者发现：**我们只需要关心总价的个位**（因为10元硬币不影响个位）。所以先取k的个位（`k%=10`），然后每次累加这个个位（`k=(k+firstk)%10`），直到个位是0或r。比如k=15，个位是5，累加一次到10（个位0）——直接得到i=2。这种“抓本质”的思路，能帮你在类似问题中**减少计算量**！

**题解三：Trans_Portal（赞：1）**  
* **点评**：用最简洁的方式写最核心的逻辑！作者把循环条件写成`for(i=1;(k*i)%10!=r&&(k*i)%10!=0;i++)`——循环继续的条件就是“还没找到答案”，一旦满足条件就自动退出。代码像“一句话总结问题”，非常适合学习「如何用代码精准表达逻辑」。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”不多，但想“想透”却需要抓住3个关键点——结合优质题解，我们一一拆解：
</difficulty_intro>

1.  **关键点1：理解“无找零”的条件**  
    * **分析**：很多同学会误以为“必须用r元硬币”，但题目说“可以不用”！所以条件是**总价个位是0（不用r）或r（用r）**。优质题解都明确包含了这两个条件，比如Scrutiny的`i*k%10==r || i*k%10==0`。  
    * 💡 **学习笔记**：读题要仔细！“或”的条件不能漏。

2.  **关键点2：确定枚举的“上限”**  
    * **分析**：为什么枚举到i=10就够了？因为10×k的个位一定是0（10的倍数），所以i=10必然满足条件。如果没意识到这一点，可能会写无限循环（比如`while(1)`），虽然也能过，但**枚举范围越明确，代码越高效**。  
    * 💡 **学习笔记**：找“必然满足的上限”，能避免不必要的计算。

3.  **关键点3：优化——只看“个位”**  
    * **分析**：总价i×k的个位，等于（k的个位 × i）的个位。比如k=117（个位7），i=9时，7×9=63（个位3）——和直接算117×9=1053的个位一样。所以像chenpengda那样，只处理k的个位，能**减少计算量**（尤其k很大时）。  
    * 💡 **学习笔记**：找“不变的规律”，能把复杂问题变简单。

### ✨ 解题技巧总结
- **技巧1：明确条件边界**：先想“最坏情况”（比如i=10），避免无限循环。  
- **技巧2：抓本质特征**：比如本题的“个位”，忽略无关信息（比如k的高位）。  
- **技巧3：代码简洁性**：能用一行条件判断解决的，不写多行——比如Trans_Portal的循环条件。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了优质题解的优点，清晰又高效！
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码来自Scrutiny的题解，是“枚举法”的最简洁实现。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int k, r;
        cin >> k >> r;
        for (int i = 1; i <= 10; ++i) {
            if (i * k % 10 == r || i * k % 10 == 0) {
                cout << i << endl;
                return 0;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 读入k（单价）和r（硬币面值）；  
  2. 从i=1到10循环，检查每个i对应的总价个位；  
  3. 找到第一个满足条件的i，输出并结束程序。


<code_intro_selected>
接下来看3份优质题解的“精华片段”，学它们的巧妙之处！
</code_intro_selected>

**题解一：Scrutiny（核心片段）**  
* **亮点**：用“固定循环范围（1-10）”避免冗余。  
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= 10; ++i) {
        if (i * k % 10 == r || i * k % 10 == 0) {
            cout << i;
            return 0;
        }
    }
    ```
* **代码解读**：  
  循环i从1到10，每轮计算i×k的个位（`i*k%10`）。如果个位是r或0，直接输出i并结束程序——因为是“从小到大试”，第一个满足的就是最小的答案！  
* 💡 **学习笔记**：枚举要“从小到大”，才能保证找到“最小”的解。

**题解二：chenpengda（核心片段）**  
* **亮点**：用“个位优化”减少计算量。  
* **核心代码片段**：
    ```cpp
    k %= 10; // 取k的个位
    int firstk = k;
    while (!(k == 0 || k == r)) {
        k = (k + firstk) % 10; // 累加个位
        cnt++;
    }
    ```
* **代码解读**：  
  比如k=15（个位5），firstk=5。第一次循环：k=5+5=10→个位0，满足条件，cnt=2——直接得到答案！这种方法**不需要计算i×k的完整值**，只处理个位，效率更高。  
* 💡 **学习笔记**：当问题和“个位”有关时，优先处理个位！

**题解三：Trans_Portal（核心片段）**  
* **亮点**：用“循环条件”直接表达“未找到答案”。  
* **核心代码片段**：
    ```cpp
    for(i=1;(k*i)%10!=r&&(k*i)%10!=0;i++){}
    cout<<i;
    ```
* **代码解读**：  
  循环继续的条件是“总价个位既不是r也不是0”——一旦条件不满足（找到答案），循环自动停止，直接输出i。这种写法把“找答案”的逻辑浓缩在循环条件里，非常简洁！  
* 💡 **学习笔记**：循环条件可以是“继续的条件”，也可以是“停止的条件”——灵活运用能简化代码。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”枚举的过程，我设计了一个**8位像素风的动画**——像玩FC游戏一样学算法！
</visualization_intro>

### **动画演示主题**：像素小铺的“找零挑战”  
我们用FC游戏的风格模拟“买铲子”的过程：屏幕左边是“铲子数量i”（像素数字），中间是“总价个位”（彩色方块），右边是“条件提示”（文字气泡）。

### **设计思路**  
- **8位像素风**：用红、绿、蓝三种基础色，模拟FC游戏的复古感，让你觉得“像玩游戏一样学算法”；  
- **音效强化记忆**：每次试i时播放“咔嗒”声，找到答案时播放“叮”的胜利音效，帮你记住关键步骤；  
- **交互友好**：支持“单步执行”（手动点下一步）和“自动播放”（调速滑块控制速度），适合不同学习节奏。

### **动画帧步骤与交互**  
1. **场景初始化**：  
   - 屏幕背景是像素化的“五金店”（灰色墙壁+棕色货架）；  
   - 左侧显示“i=1”（白色像素数字），中间显示“k的个位”（比如k=117时，显示红色方块“7”），右侧显示“寻找中...”（黄色文字气泡）；  
   - 控制面板有“开始/暂停”（红色按钮）、“单步”（蓝色按钮）、“重置”（绿色按钮），还有速度滑块（从“慢”到“快”）。

2. **枚举过程演示**：  
   - **单步执行**：点“单步”按钮，i变成2，中间的方块变成“7×2=14”的个位“4”（蓝色），右侧显示“还没找到哦～”；  
   - **自动播放**：拉滑块到“中速”，i从1到9快速切换，每个i对应的个位方块随之变化，直到i=9时，方块变成“3”（绿色），右侧弹出“找到啦！”，同时播放“叮”的音效；  
   - **条件高亮**：当个位是0或r时，方块会闪烁3次，提示“这就是答案！”。

3. **胜利状态**：  
   - 找到答案后，屏幕中央弹出像素化的“胜利！”文字（彩虹色），同时播放FC风格的胜利BGM（比如《超级马里奥》的过关音效）；  
   - 点击“重置”，可以重新开始模拟其他输入（比如样例2的k=237，r=7，i=1时就满足条件）。

<visualization_conclusion>
通过这个动画，你能**直观看到i的变化和个位的规律**——比如i=9时，个位刚好是r=3，所以答案就是9。是不是比看代码更“有感觉”？
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
枚举法是“解决小范围问题的万能钥匙”——学会它，你能解决很多类似的题目！
</similar_problems_intro>

### **通用思路迁移**  
枚举法适合**答案范围小、容易验证**的问题，比如：  
1. 找“最小的n，使得n是3和5的倍数”（枚举1到15）；  
2. 找“字符串中第一个重复的字符”（枚举每个字符，检查后面是否有重复）；  
3. 找“两个数的最大公约数”（枚举从1到较小数，找能同时整除两者的最大数）。

### **洛谷练习推荐**  
1. **洛谷 P1009 阶乘之和**  
   - 🗣️ **推荐理由**：用枚举法计算阶乘的和，练习“累加+枚举”的组合技巧。  
2. **洛谷 P1014 Cantor表**  
   - 🗣️ **推荐理由**：枚举Cantor表的行和列，练习“按规律枚举”的思路。  
3. **洛谷 P1157 组合的输出**  
   - 🗣️ **推荐理由**：枚举组合的所有可能，练习“嵌套枚举”的写法。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了两个“避坑小技巧”——都是作者们踩过的坑，帮你少走弯路！
</insights_intro>

> **经验1：不要写无限循环**（来自bym666的题解）  
> 作者最初用了`while(1)`循环，虽然能过，但如果没意识到“i=10必满足”，可能会担心“会不会死循环？”。后来优化成枚举1到10，更安心。  
> **点评**：枚举时，**给循环加个明确的上限**，比“无限循环”更可靠。

> **经验2：抓本质，不计算完整值**（来自chenpengda的题解）  
> 作者发现“只需要看个位”，所以不用计算i×k的完整值——比如k=1e9时，直接算k%10=9，避免了“大数相乘溢出”的问题。  
> **点评**：遇到“个位、余数”问题时，优先用模运算（%），能避免很多麻烦！


<conclusion>
「Buy a Shovel」是一道“小而美”的题——它用简单的枚举，帮你理解“如何把生活问题转化为代码逻辑”。记住：**枚举不是“笨办法”，而是“稳办法”**，只要范围小，就是最好的选择！  

下次遇到类似的“找最小满足条件”的问题，不妨先想想：“我能枚举吗？最多要试多少次？”——你会发现，很多问题都能迎刃而解！💪
</conclusion>

---

---
处理用时：105.51秒
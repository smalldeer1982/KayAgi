# 题目信息

# Triangular numbers

## 题目描述

A triangular number is the number of dots in an equilateral triangle uniformly filled with dots. For example, three dots can be arranged in a triangle; thus three is a triangular number. The $ n $ -th triangular number is the number of dots in a triangle with $ n $ dots on a side. ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF47A/7344b4fd5acb7c973775cffc0c5a51a81c6ee4d9.png). You can learn more about these numbers from Wikipedia (http://en.wikipedia.org/wiki/Triangular\_number).

Your task is to find out if a given integer is a triangular number.

## 样例 #1

### 输入

```
1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
2
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
3
```

### 输出

```
YES
```

# AI分析结果

# 💡 Kay的C++算法解析：Triangular numbers 深入学习指南 💡

<introduction>
  今天我们来一起分析“Triangular numbers”这道C++编程题——判断一个数是不是**三角数**。三角数就像堆金字塔：第1层1个点，第2层2个点，第3层3个点……总点数就是三角数（比如3层总共有1+2+3=6个点）。本指南会帮你梳理思路、掌握核心算法，还能通过像素动画“看”到三角数的生成过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学应用 + 枚举/二分/公式法`  

🗣️ **初步分析**：  
解决这道题的关键，是理解**三角数的数学公式**——第`i`个三角数是`T(i) = i×(i+1)/2`。我们的任务就是判断：输入的数`n`，是否存在某个整数`i`，让`T(i) = n`。  

- **核心思路**：所有题解都围绕“找`i`”展开，常见方法有3类：  
  1. **暴力枚举**：从`i=1`开始，计算`T(i)`直到超过`n`（适合`n`小的情况）；  
  2. **二分查找**：利用`T(i)`单调递增的特性，快速定位`i`；  
  3. **数学公式**：通过解方程`i² + i - 2n = 0`，直接计算`i`是否为整数。  

- **核心难点**：如何**高效且准确**地找到`i`？比如枚举时要控制范围（避免算到10000次），数学方法要处理浮点精度误差（比如`sqrt`的结果可能不是整数）。  

- **可视化设计思路**：我们会做一个“像素金字塔堆塔游戏”——用8位像素块模拟三角数的堆叠过程：  
  - 屏幕左侧显示输入的`n`，右侧是“金字塔”（每一层用不同颜色的像素块表示）；  
  - 每一步增加一层（`i`+1），总点数实时更新，高亮当前层数和总点数；  
  - 如果总点数等于`n`，金字塔会“闪烁庆祝”并播放胜利音效；如果超过`n`，则显示“失败”并播放提示音。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面筛选了4个优质题解，覆盖了主要解题方法，适合不同阶段的学习者参考～
</eval_intro>

**题解一：二分法（作者：fangd，赞：8）**  
* **点评**：这份题解的亮点是**用二分法高效找`i`**！因为`T(i)`是单调递增的（层数越多，总点数越多），所以可以用二分法快速缩小范围。代码里`l`和`r`的初始范围设计很巧妙（`l`从`sqrt(n)`开始，`r`到`2n+1`），减少了循环次数。最后还会“验证”`l`是否真的满足条件，避免二分的边界错误。思路严谨，代码简洁，适合学习“如何用单调性优化查找”。

**题解二：数学公式法（作者：PC_DOS，赞：2）**  
* **点评**：这是最“聪明”的方法——直接解方程！通过求根公式算出`i = (-1 + sqrt(1+8n))/2`，然后验证这个`i`是不是整数。代码只有几行，时间复杂度是`O(1)`（不用循环）。但要注意：`sqrt`返回的是浮点数，所以必须用整数运算再验证一次（比如`i×(i+1) == 2n`），避免精度误差。适合喜欢“用数学偷懒”的同学～

**题解三：递推枚举（作者：a13518354766，赞：2）**  
* **点评**：这是最“直观”的新手友好解法！从`i=1`开始，每次累加`i`（模拟堆金字塔），直到总和等于`n`（输出YES）或超过`n`（输出NO）。代码逻辑和“堆金字塔”的过程完全一致，容易理解。虽然效率不如二分或公式法，但胜在“一眼就能看懂”，适合刚学循环的同学巩固基础。

**题解四：判别式法（作者：追风少年σχ，赞：0）**  
* **点评**：这是最“严谨”的数论方法！通过方程的判别式`Δ=8n+1`，判断`Δ`是不是完全平方数，且平方根`p`满足`p%2==1`（因为`i=(p-1)/2`必须是整数）。代码里用枚举`p`的方式找完全平方数，思路清晰，数学性强。适合想深入理解“整数根条件”的同学～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个问题：如何控制枚举范围？如何处理浮点精度？如何选择高效算法？结合优质题解，我总结了应对策略：
</difficulty_intro>

1.  **难点1：如何确定`i`的范围？**  
    * **分析**：直接枚举到`n`会浪费时间（比如`n=500`，其实`i`最多是31，因为`31×32/2=496`）。优质题解的做法是：利用公式`i≈sqrt(2n)`（因为`i²≈2n`），把枚举范围缩小到`sqrt(2n)`附近（比如`i`从`sqrt(n)`到`sqrt(2n)+2`）。  
    * 💡 **学习笔记**：用数学公式缩小范围，能让代码更快！

2.  **难点2：数学方法中的浮点精度误差？**  
    * **分析**：比如用`sqrt`计算时，`sqrt(8n+1)`可能返回`3.0000001`或`2.9999999`，直接转整数会出错。解决方法是：用整数运算验证（比如`i×(i+1) == 2n`），或者用判别式法（只做整数运算）。  
    * 💡 **学习笔记**：浮点运算要“多一步验证”，避免精度坑！

3.  **难点3：如何选择高效的算法？**  
    * **分析**：如果`n`很小（比如本题`n≤500`），暴力枚举也很快；如果`n`很大（比如1e9），就必须用二分或公式法（`O(logn)`或`O(1)`）。优质题解覆盖了不同场景的方法，大家可以根据题目数据范围选择。  
    * 💡 **学习笔记**：算法的选择要结合数据范围！


### ✨ 解题技巧总结
- **技巧1：利用单调性优化**：如果函数单调，优先用二分法（比枚举快很多）；  
- **技巧2：数学公式简化问题**：先推导出数学公式，再写代码（比如求根公式、判别式）；  
- **技巧3：边界条件验证**：不管用什么方法，最后都要验证结果是否真的满足条件（避免边界错误）；  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用的数学公式法代码**——它结合了精度验证，适合大部分情况，而且代码最短！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自“PC_DOS”的题解，用求根公式直接计算`i`，并验证结果，逻辑清晰高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        int delta = 1 + 8 * n; // 判别式Δ=8n+1
        int p = sqrt(delta);   // 计算Δ的平方根
        // 验证Δ是完全平方数，且p是奇数（因为i=(p-1)/2必须是整数）
        if (p * p == delta && p % 2 == 1) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 计算判别式`delta=8n+1`（来自方程`i²+i-2n=0`的判别式）；  
  2. 计算`delta`的平方根`p`（如果`delta`是完全平方数，`p`是整数）；  
  3. 验证`p`的平方等于`delta`（确保是完全平方数），且`p`是奇数（确保`i=(p-1)/2`是整数）；  
  4. 输出结果。


<code_intro_selected>
接下来看3个优质题解的核心片段，分析它们的亮点～
</code_intro_selected>

**题解一：二分法（作者：fangd）**
* **亮点**：用二分法快速定位`i`，利用单调性优化效率。
* **核心代码片段**：
    ```cpp
    int l = static_cast<int>(sqrt(n)), r = (n << 1) + 1;
    while (l < r) {
        int mid = (l + r) >> 1; // 等价于mid=(l+r)/2（整数除法）
        if (mid * (mid + 1) < (n << 1)) { // 2n=mid*(mid+1)？
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    ```
* **代码解读**：  
  - `l`初始化为`sqrt(n)`（缩小左边界），`r`初始化为`2n+1`（右边界，确保覆盖所有可能）；  
  - 循环中，`mid`是中间值，判断`mid*(mid+1)`是否小于`2n`：如果是，说明`i`在`mid+1`到`r`之间；否则在`l`到`mid`之间；  
  - 循环结束后，`l`就是可能的`i`，再验证`l*(l+1)==2n`即可。  
* 💡 **学习笔记**：二分法的关键是“找到单调区间”，然后不断缩小范围！

**题解二：递推枚举（作者：a13518354766）**
* **亮点**：模拟三角数的生成过程，逻辑直观，适合新手。
* **核心代码片段**：
    ```cpp
    long long n, r = 0;
    cin >> n;
    for (int i = 1; i <= 999; ++i) {
        r += i; // 累加i，模拟堆金字塔
        if (r == n) {
            cout << "YES";
            return 0;
        }
        if (r > n) { // 超过n，不可能再等于了
            cout << "NO";
            return 0;
        }
    }
    ```
* **代码解读**：  
  - `r`是当前的总点数（三角数）；  
  - 每次循环加`i`（第`i`层的点数），如果`r`等于`n`，输出YES并结束；如果`r`超过`n`，输出NO并结束；  
  - 循环到`999`是因为`999×1000/2=499500`，远大于题目中的`n≤500`。  
* 💡 **学习笔记**：递推的本质是“一步步模拟问题过程”，适合理解问题本质！

**题解三：判别式法（作者：追风少年σχ）**
* **亮点**：用数论方法判断整数根，完全避免浮点运算。
* **核心代码片段**：
    ```cpp
    int delta = 8 * n + 1;
    for (p = 1; p * p < delta; p++); // 找p使得p²≥delta
    if (p * p == delta && p % 2 == 1) {
        printf("YES");
    } else {
        printf("NO");
    }
    ```
* **代码解读**：  
  - 计算判别式`delta=8n+1`；  
  - 枚举`p`直到`p²≥delta`（找`delta`的平方根）；  
  - 验证`p²==delta`（`delta`是完全平方数）且`p`是奇数（`i=(p-1)/2`是整数）；  
  - 输出结果。  
* 💡 **学习笔记**：用整数运算可以完全避免浮点精度问题！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地理解“三角数的生成过程”，我设计了一个**8位像素风的“堆金字塔游戏”**动画！像玩FC游戏一样，看像素块一步步堆成三角数，再也不怕记不住公式啦～
</visualization_intro>

### 🎮 动画演示主题
**《像素金字塔大挑战》**：你需要帮小机器人堆出一个总点数等于输入`n`的三角金字塔。每堆一层，总点数增加，直到等于`n`（胜利）或超过`n`（失败）。


### 🎨 设计思路
- **风格**：仿FC红白机的8位像素风（用16色调色板：红、蓝、黄、绿等明亮颜色），背景是浅灰色网格，金字塔用橙色像素块，当前层数用蓝色高亮。  
- **趣味性**：加入“堆叠音效”（每堆一层，播放“叮”的像素音）、“胜利动画”（金字塔闪烁，播放上扬的“通关音”）、“失败提示”（金字塔变成红色，播放短促的“错误音”）。  
- **交互**：控制面板有“单步堆层”（点击一次堆一层）、“自动播放”（每秒堆一层，可调节速度）、“重置”（重新开始）。


### 📜 动画帧步骤
1. **初始化场景**：  
   - 屏幕左侧显示输入框（比如输入`3`），右侧是空白的“金字塔区域”（32×32像素网格）；  
   - 控制面板在屏幕下方，有三个按钮（单步、自动、重置）和一个速度滑块（1x~5x）；  
   - 8位风格的背景音乐（轻快的电子音）开始播放。

2. **堆层过程（以`n=3`为例）**：  
   - **第1步**：堆第1层（1个橙色像素块），总点数显示`1`，播放“叮”的音效；  
   - **第2步**：堆第2层（2个橙色像素块，在第1层下方），总点数显示`3`，此时总点数等于`n`！  
   - **胜利动画**：金字塔开始闪烁，播放“通关音”，屏幕中央弹出“YES！你堆成了三角数～”的文字气泡。

3. **失败案例（以`n=2`为例）**：  
   - **第1步**：堆第1层，总点数`1`；  
   - **第2步**：堆第2层，总点数`3`（超过`n=2`）；  
   - **失败提示**：金字塔变成红色，播放“错误音”，屏幕中央弹出“NO！这个数不是三角数～”的文字气泡。


### 🔧 技术实现小细节
- **像素绘制**：用HTML5 Canvas绘制，每个像素块是`10×10`像素的正方形（方便看清）；  
- **音效**：用Web Audio API播放8位风格的音效（比如“叮”是`440Hz`的正弦波，“通关音”是`880Hz`的方波）；  
- **自动播放**：用`setInterval`控制堆层速度，滑块调节间隔时间（1x=1000ms，5x=200ms）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
三角数的问题本质是“判断一个数是否能表示为连续自然数的和”，这种思路能解决很多类似问题。比如：
</similar_problems_intro>

### 🌐 通用思路迁移
- **场景1**：判断一个数是否是“平方数”（类似公式：`x²=n`）；  
- **场景2**：判断一个数是否是“阶乘数”（`n!=1×2×…×k`）；  
- **场景3**：划分问题（比如将`n`分成连续自然数的和，有多少种分法）。


### 📚 洛谷练习推荐
1. **洛谷 P1025 数的划分**  
   * 🗣️ **推荐理由**：这道题需要将`n`分成`k`个正整数的和，思路和三角数的“累加”类似，能巩固枚举和递归的基础。  
2. **洛谷 P1152 欢乐的跳**  
   * 🗣️ **推荐理由**：题目要求判断序列是否是“连续的三角数变形”，需要用到排序和差分，能练习“单调性”的应用。  
3. **洛谷 P1420 最长连号**  
   * 🗣️ **推荐理由**：题目要求找最长连续递增的子序列，思路和二分法的“单调性”一致，能练习高效查找的技巧。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我发现了几个很有用的“踩坑经验”，分享给大家：
</insights_intro>

> **经验1（来自PC_DOS的题解）**：“用求根公式时，一定要用整数验证！比如`sqrt(8n+1)`可能返回`3.0000001`，直接转整数会变成`3`，但其实`3²=9`等于`delta`，这时候要再验证`i×(i+1)==2n`。”  
> **点评**：浮点精度是很多同学的“坑”，这个经验提醒我们：**所有浮点运算的结果，都要再用整数验证一遍**！

> **经验2（来自fangd的题解）**：“二分法的初始范围很重要！比如`l`从`sqrt(n)`开始，能减少循环次数。如果初始范围太大，二分法的优势就没了。”  
> **点评**：算法的优化往往在“细节”里，合理的初始范围能让代码更快！


<conclusion>
本次关于“Triangular numbers”的分析就到这里～ 三角数的问题虽然简单，但涉及的“数学公式”“枚举优化”“二分法”都是编程中的基础技巧。希望这份指南能帮助你理解核心思路，下次遇到类似问题时，能快速想到“用数学简化”或“用单调性优化”！

记住：编程的乐趣在于“用不同方法解决同一个问题”，多尝试几种解法，你会收获更多～ 💪
</conclusion>

---
处理用时：1031.17秒
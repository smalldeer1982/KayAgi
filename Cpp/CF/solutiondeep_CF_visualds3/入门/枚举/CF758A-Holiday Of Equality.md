# 题目信息

# Holiday Of Equality

## 题目描述

## 题目大意
今天是Berland的平等节。为了庆祝节日，国王决定用国库里的钱来使Berland所有公民的福利均等。

在Berland，有$N$个公民，每个人的福利都被估计为一个整数$a_{i}$ burle（burle是Berland的货币）。

你是皇家财政管理员，你需要计算国王为此要付出的最低费用。国王只能给公民们钱，他没有权力夺走任何钱财。

## 说明/提示

第一个样例中，如果我们给第一个公民4 burles，第二个3 burles，第三个2 burles，第四个1 burle，那么所有公民的福利都等于4 burles。

第二个样例中，我们只需要给第三个公民1 burle就可以使得福利均等。

第三个样例中，我们需要分别给第一个和第三个公民2 burles，使得福利都等于3 burles。

第四个样例中，我们不需要给任何人钱因为所有人的福利都是12 burles。


对于100%的数据，$1 \leq n \leq 100$，$0 \leq a_{i} \leq 10^{6}$。

翻译提供者：Simpson561

## 样例 #1

### 输入

```
5
0 1 2 3 4
```

### 输出

```
10```

## 样例 #2

### 输入

```
5
1 1 0 1 1
```

### 输出

```
1```

## 样例 #3

### 输入

```
3
1 3 1
```

### 输出

```
4```

## 样例 #4

### 输入

```
1
12
```

### 输出

```
0```

# AI分析结果

# 💡 Kay的C++算法解析：Holiday Of Equality 深入学习指南 💡

<introduction>
今天我们来一起分析“Holiday Of Equality”这道C++编程题。这道题看似简单，却藏着对“问题本质理解”和“代码效率优化”的小考验。本指南会帮你快速抓住核心思路，掌握简洁的实现技巧，还能通过像素动画直观看到算法运行过程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学与模拟应用`

🗣️ **初步分析**：
解决这道题的关键，其实像“全班同学要一起摸到天花板”——天花板的高度是最高的那个同学的身高（最大值），其他同学需要垫的砖块数加起来，就是总砖块数（答案）。因为国王只能**加钱不能抢钱**，所以最省钱的方式一定是让所有人的福利都涨到“当前最高福利”（否则如果选更高的目标，反而要花更多钱）。

核心思路用公式总结就是：  
**总费用 = 最大值 × 人数 - 所有福利的总和**  
（比如第一个样例：最大值是4，人数5，总和是0+1+2+3+4=10，所以4×5-10=10，正好是答案～）

题解的常见思路有两种：  
1. **边读边算**（不用数组）：读一个数就更新最大值和总和，最后直接套公式。  
2. **先存数组再处理**：把所有数存起来，再找最大值、算总和。  

其中**边读边算**的方法更高效（省内存，不用存数组），也是大部分优质题解的选择。

### 可视化设计思路
我打算做一个**8位像素风的“福利长高游戏”**：  
- 每个公民是一个彩色像素块，高度等于福利值（比如福利0是1格高，福利4是5格高）；  
- 最大值块用“金色”高亮，其他块是“蓝色”；  
- 动画开始后，蓝色块会**逐格向上增长**到金色块的高度，每长一格，旁边的“总费用”数字加1（对应补的钱）；  
- 关键操作有音效：块长高时“叮”一声，全部完成时播放“胜利音效”（像FC游戏通关的提示音）。


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码简洁度、实践价值”三个维度筛选了3份优质题解，它们各有亮点，能帮你从不同角度理解问题～
</eval_intro>

**题解一：(来源：Alex_Wei)**
* **点评**：这份题解把核心思路做到了“极致简洁”——不用数组，边读入边计算最大值和总和，最后直接套公式。代码只有5行核心逻辑，变量名`m`（最大值）、`s`（总和）、`n`（人数）含义明确，完全没有冗余。比如`for(int x=1;x<=n;x++)cin>>a,m=max(m,a),s+=a;`这一行，把“读入+更新最大值+累加总和”合并成了一句话，非常高效。这种“边读边处理”的技巧，能帮你在内存紧张的题目中节省空间，值得学习！

**题解二：(来源：whose)**
* **点评**：这题解用了`sort`排序来找最大值，思路很直观——把数组排序后，最后一个元素就是最大值。虽然比“边读边算”多了一步排序，但代码逻辑很容易理解，适合刚学数组的同学。比如`sort(a+1,a+n+1);`之后，`a[n]`就是最大值，然后循环累加`a[n]-a[i]`即可。这种“用排序简化问题”的思路，在很多需要找极值的题目中都能用得上～

**题解三：(来源：tryrtj)**
* **点评**：这份题解的亮点是**实践经验分享**——作者对比了`cin`和`scanf`的优缺点：`cin`省内存（0MB过题），`scanf`速度快。同时，他也用了“边读边算”的方法，代码和Alex_Wei的思路一致，但特意强调“不用数组”的优势。这种“根据题目限制选输入方式”的意识，能帮你在竞赛中避免“超时”或“内存超限”的问题～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“难点”其实是“想通问题本质”和“优化代码”。结合题解的共性，我总结了3个关键思考点：
</difficulty_intro>

1.  **关键点1：为什么必须选“最大值”作为目标？**  
    * **分析**：因为国王只能加钱，不能减钱。如果选一个比最大值小的数当目标，比如最大值是4，选3当目标，那原本有4的人要减到3（但国王没这权力），所以不可能。只有选最大值当目标，才能保证“只加钱”，而且总费用最少（因为目标越高，总费用越多）。  
    * 💡 **学习笔记**：问题中的“限制条件”（只能加钱）决定了最优解的方向！

2.  **关键点2：如何高效计算最大值和总和？**  
    * **分析**：大部分题解用了“边读边算”的方法——读一个数，就用`max`函数更新最大值，同时把这个数加到总和里。这样不用存数组，节省内存（比如n=100时，省了100个int的空间）。如果用数组存，再遍历找最大值，虽然也对，但多了一步存储，效率稍低。  
    * 💡 **学习笔记**：能“即时处理”的数据，就不要存起来再处理！

3.  **关键点3：如何处理边界情况（比如n=1）？**  
    * **分析**：当n=1时，只有一个公民，福利已经相等，不需要加钱。这时候公式`max*n - sum`会自动算出0（因为max=sum，所以结果是0），不需要额外判断！比如样例4中，输入1和12，公式算出来是12×1-12=0，正好正确。  
    * 💡 **学习笔记**：很多边界情况可以用核心公式自动覆盖，不用额外写判断！

### ✨ 解题技巧总结
- **技巧1：抓问题本质**：先想清楚“为什么选最大值”，再推导公式，不要盲目写代码。  
- **技巧2：边读边处理**：能即时计算的数据（比如最大值、总和），不要存数组，省内存又高效。  
- **技巧3：利用公式覆盖边界**：先写核心公式，再测试边界情况，避免冗余判断。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——结合了“边读边算”的高效思路，代码简洁到极致，适合直接复用～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Alex_Wei和tryrtj的思路，用“边读边算”的方法，不用数组，直接算出答案。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm> // 包含max函数
    using namespace std;

    int main() {
        int n, a, max_val = 0, sum = 0;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> a;
            max_val = max(max_val, a); // 更新最大值
            sum += a;                   // 累加总和
        }
        cout << max_val * n - sum << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 读入人数`n`；  
  2. 循环n次，每次读入一个福利值`a`，同时更新最大值`max_val`和总和`sum`；  
  3. 用公式`max_val * n - sum`算出总费用，输出结果。


<code_intro_selected>
接下来看3份优质题解的核心片段，分析它们的亮点～
</code_intro_selected>

**题解一：(来源：Alex_Wei)**
* **亮点**：极致简洁的“一行处理”——把读入、更新最大值、累加总和合并成一句话。  
* **核心代码片段**：
    ```cpp
    for(int x=1;x<=n;x++)cin>>a,m=max(m,a),s+=a;
    ```
* **代码解读**：  
  这句话其实是三个操作的合并：  
  1. `cin>>a`：读入当前福利值；  
  2. `m=max(m,a)`：用`max`函数比较当前最大值`m`和`a`，更新`m`；  
  3. `s+=a`：把`a`加到总和`s`里。  
  这种“链式操作”能让代码更紧凑，适合竞赛中节省时间。  
* 💡 **学习笔记**：合并无关但连续的操作，能让代码更简洁！

**题解二：(来源：whose)**
* **亮点**：用`sort`快速找最大值——适合刚学数组的同学，思路直观。  
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1); // 数组从a[1]到a[n]排序
    for(int i=1;i<n;i++){
        ans+=a[n]-a[i]; // 累加最大值与每个数的差
    }
    ```
* **代码解读**：  
  `sort`函数会把数组从小到大排序，所以`a[n]`就是最大值。然后循环从`i=1`到`i=n-1`，累加`a[n]-a[i]`（每个数需要补的钱）。这种方法不用手动找最大值，适合数组操作不熟练的同学。  
* 💡 **学习笔记**：排序是找极值的“懒人方法”，但要注意时间复杂度（本题n≤100，完全没问题）！

**题解三：(来源：tryrtj)**
* **亮点**：对比`cin`和`scanf`的优缺点——实践经验分享，帮你避坑。  
* **核心代码片段**：
    ```cpp
    for(int i=0;i<n;i++){
        scanf("%d",&w); // 用scanf读入
        zong+=w;
        if(w>maxn)maxn=w;
    }
    ```
* **代码解读**：  
  作者用`scanf`读入数据，因为`scanf`比`cin`快（但`cin`省内存）。如果你遇到“时间超限”的问题，可以试试把`cin`换成`scanf`；如果遇到“内存超限”，就用`cin`或者“边读边算”。  
* 💡 **学习笔记**：输入方式的选择要根据题目限制来！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”算法运行，我设计了一个**8位像素风的“福利长高游戏”**，像玩FC游戏一样理解问题～
</visualization_intro>

### 🎮 动画演示主题
《像素公民的福利大挑战》——帮助国王把所有公民的福利涨到最大值，计算总费用！

### 🎨 设计思路
用**FC红白机的8位像素风格**（低分辨率、高饱和度颜色），让动画看起来像小时候玩的《超级马里奥》。每个公民是一个“像素块”，高度代表福利值，最大值块用金色高亮，其他块用蓝色。动画会一步步展示“每个块长高→总费用增加”的过程，搭配复古音效，让学习更有趣～

### 🕹️ 动画帧步骤与交互设计
1. **场景初始化**：  
   - 屏幕左侧显示`n`个像素块（比如样例1是5个），高度对应输入的福利值（0→1格，1→2格，…，4→5格）；  
   - 屏幕右侧有“总费用”数字（初始为0），下方是控制面板：`开始/暂停`、`单步`、`重置`按钮，以及`速度滑块`（调整动画快慢）；  
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的地面关卡音乐）。

2. **算法启动**：  
   - 金色块（最大值）闪烁3次，提示“这是目标高度”；  
   - 蓝色块开始**逐格向上增长**（比如样例1中的第一个块从1格涨到5格），每长一格，右侧“总费用”加1，同时播放“叮”的音效（像《俄罗斯方块》的旋转音效）。

3. **核心步骤演示**：  
   - 每个蓝色块依次长高：比如样例1中，第一个块长4格（加4），第二个长3格（加3），第三个长2格（加2），第四个长1格（加1），第五个已经是最大值，不动；  
   - 每完成一个块的增长，该块会变成“淡金色”（表示已达标）；  
   - 所有块达标后，播放“胜利音效”（像《塞尔达传说》的宝箱打开声），屏幕中央弹出“总费用：10”的提示。

4. **交互功能**：  
   - `单步`：点击一次，只让一个块长一格；  
   - `自动播放`：按滑块速度连续播放，适合快速看整体流程；  
   - `重置`：回到初始状态，重新开始。

### 📝 旁白提示
- 初始化时：“大家好！我是Kay～今天要帮国王让所有公民的福利相等～看，金色块是当前最高福利，其他蓝色块要涨到和它一样高哦！”  
- 块长高时：“这个蓝色块现在要长一格啦～总费用加1！”  
- 完成时：“所有公民都达标了！总费用是10～你学会了吗？”


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“找极值+计算总和”，这种思路能解决很多类似的“补差价”问题～
</similar_problems_intro>

### 通用思路迁移
- **场景1**：班级买统一的笔记本，每个人带的钱不一样，求需要补的总钱数（目标是最贵的笔记本价格）；  
- **场景2**：工厂生产零件，每个机器的产量不同，求需要增加的总产量（目标是最高产量）；  
- **场景3**：小朋友分糖果，每个人的糖果数不同，求需要再买的糖果数（目标是最多的糖果数）。

### 洛谷练习推荐
1. **洛谷 P1001 A+B Problem**  
   * 🗣️ **推荐理由**：练最基础的输入输出和变量运算，帮你巩固“边读边算”的习惯。  
2. **洛谷 P1421 小玉买文具**  
   * 🗣️ **推荐理由**：计算“买文具需要的钱”，类似“补差价”的思路，练公式推导。  
3. **洛谷 P1598 垂直柱状图**  
   * 🗣️ **推荐理由**：统计字符出现次数，需要找最大值（最高的柱状图），和本题的“找最大值”思路一致。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中有些作者的“踩坑经验”很有用，我帮你摘录出来～
</insights_intro>

> **参考经验 (来自 tryrtj)**：“由两次提交实测了一个事实：cin读入消耗内存较小，而scanf消耗时间较多，所以以后内存卡的严就用cin，时间紧就scanf。”  
> **点评**：这位作者的经验很实在！在竞赛中，输入方式的选择直接影响“是否超时”或“是否内存超限”。比如本题n=100，用cin或scanf都可以，但如果n=1e5（10万），就需要用scanf或关闭cin同步（`ios::sync_with_stdio(false);`）来加速。

> **参考经验 (来自 judgejudge)**：“首先我们必须要判断这些数字是否全部相等或只有一个数字，因为在这两种情况下答案都为0！”  
> **点评**：虽然本题的核心公式能自动覆盖这些情况，但作者的“边界意识”值得学习。在复杂题目中，边界情况往往是bug的重灾区，提前想清楚能少踩很多坑～


<conclusion>
这道题的核心是“想通目标是最大值”，然后用简单的数学公式解决。通过优质题解，我们学会了“边读边算”的高效技巧，也了解了输入方式的选择经验。最后，像素动画帮我们直观看到了算法运行过程——原来“补差价”这么有趣！

记住：**简单的题目也能练出扎实的基础**，下次遇到类似的“补差价”问题，你一定能快速解决～💪
</conclusion>

---
处理用时：519.88秒
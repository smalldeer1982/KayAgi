# 题目信息

# The King's Race

## 题目描述

在一个宽为 $n$、高为 $n$ 的国际象棋棋盘上，行号从下到上依次为 $1$ 到 $n$，列号从左到右依次为 $1$ 到 $n$。因此，棋盘上的每一个格子都可以用坐标 $(r, c)$ 表示，其中 $r$ 表示行号，$c$ 表示列号。

白王已经在坐标为 $(1,1)$ 的格子上坐了一千年，而黑王则一直坐在坐标为 $(n,n)$ 的格子上。他们本可以继续这样坐下去，但突然有一枚漂亮的硬币掉在了坐标为 $(x, y)$ 的格子上……

两位国王都想得到这枚硬币，于是他们决定按照稍作修改的国际象棋规则来进行一场竞赛：

与国际象棋一样，白王先走一步，黑王再走一步，接着白王再走一步，如此交替进行。然而，在本题中，两个国王可以同时站在相邻的格子，甚至可以同时站在同一个格子。

谁先到达硬币所在的格子 $(x, y)$，谁就获胜。

我们回顾一下，国王是一种可以向所有方向移动一格的棋子，也就是说，如果国王当前在 $(a, b)$，那么他可以一步移动到 $(a+1, b)$、$(a-1, b)$、$(a, b+1)$、$(a, b-1)$、$(a+1, b-1)$、$(a+1, b+1)$、$(a-1, b-1)$ 或 $(a-1, b+1)$。禁止走出棋盘之外。

请判断，如果白王先走，谁会先到达 $(x, y)$ 所在的格子。

## 说明/提示

下面是第一个样例的竞赛过程示例，假设两位国王都采取最优策略：

1. 白王从 $(1,1)$ 移动到 $(2,2)$。
2. 黑王从 $(4,4)$ 移动到 $(3,3)$。
3. 白王从 $(2,2)$ 移动到 $(2,3)$，这就是硬币所在的格子，因此白王获胜。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1075A/f254caab5d6689c7762373bad40ea730253add20.png)

下面是第二个样例的竞赛过程示例，假设两位国王都采取最优策略：

1. 白王从 $(1,1)$ 移动到 $(2,2)$。
2. 黑王从 $(5,5)$ 移动到 $(4,4)$。
3. 白王从 $(2,2)$ 移动到 $(3,3)$。
4. 黑王从 $(4,4)$ 移动到 $(3,5)$，这就是硬币所在的格子，因此黑王获胜。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1075A/8da824ef69161fea610dd68f5d79c6e1d4915d1c.png)

在第三个样例中，硬币正好掉在了黑王的起始格子，因此黑王立即获胜。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1075A/ef64633e6cdf332ba74f49b9036ceea6af7c9df5.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
2 3
```

### 输出

```
White```

## 样例 #2

### 输入

```
5
3 5
```

### 输出

```
Black```

## 样例 #3

### 输入

```
2
2 2
```

### 输出

```
Black```

# AI分析结果

---
# 💡 Kay的C++算法解析：The King's Race 深入学习指南 💡

<introduction>
  今天我们来一起分析“The King's Race”这道C++编程题。这道题看起来像棋盘游戏，但其实藏着数学的小技巧——不需要模拟国王走步，只要算对“最短步数”就能解决！本指南会帮你理清思路、掌握核心公式，还能通过像素动画直观看到算法过程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学计算（切比雪夫距离）

🗣️ **初步分析**：
> 解决这道题的关键，是理解**国王的最短移动步数**——这其实是一个数学问题！国王可以走8个方向（上下左右+斜角），就像“每次能同时向两个方向走一步”。比如从(1,1)到(3,2)，行差2、列差1，国王可以斜走2步（(1,1)→(2,2)→(3,2)），所以最短步数是**行差和列差中的较大值**（这叫“切比雪夫距离”）。  
> 本题的核心思路很简单：计算白王（起点(1,1)）和黑王（起点(n,n)）到硬币(x,y)的**切比雪夫距离**，然后比较——因为白王先走，所以只要白王的步数≤黑王的步数，白王赢；否则黑王赢。  
> 核心难点是**区分“曼哈顿距离”和“切比雪夫距离”**：比如有人一开始会用“行差+列差”（曼哈顿距离），但国王能斜走，所以这个是错的！  
> 可视化设计思路：我们会用8位像素风格的棋盘，用不同颜色标记白王、黑王和硬币，动态展示两者的最短路径（斜走→直走），每走一步用“叮”的音效提示，到达时用“胜利音”强化记忆～


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和启发性三个方面，筛选了3份优质题解——它们各有亮点，能帮你从不同角度理解问题！
</eval_intro>

**题解一：(来源：Lips)**
* **点评**：这份题解的最大亮点是**把公式讲透了**！作者一开始想写最短路，但看到n≤1e18（不能暴力），立刻想到“切比雪夫距离”，还举了例子（(1,1)到(3,2)要走2步）推导公式。代码超简洁：用`max(abs(x1-x2), abs(y1-y2))`计算距离，还特意提醒“要开long long”（因为n很大）。从实践角度看，这份代码直接能用于竞赛，边界处理也严谨（比如硬币在起点的情况，公式自动覆盖）。

**题解二：(来源：PersistentLife)**
* **点评**：这是一份“踩坑后成长”的题解，特别有启发性！作者一开始用了错误的“曼哈顿距离”（行差+列差）导致WA，然后通过画图发现国王能斜走，纠正为“切比雪夫距离”。这种“错误→反思→正确”的过程，能帮你深刻记住“移动方式决定距离公式”。代码也很清晰，直接计算白王和黑王的距离并比较。

**题解三：(来源：Laurenceshao)**
* **点评**：这份题解给出了**更简洁的条件判断**！作者发现：当硬币在对角线`x+y = n+1`的左下方（x+y ≤n+1）时，白王赢；否则黑王赢。这其实是切比雪夫距离的另一种表达——因为白王的距离是`max(x-1, y-1)`，黑王是`max(n-x, n-y)`，两者的比较等价于`x+y ≤n+1`。这种“公式简化”的思维，能帮你更快速地解决问题！


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常犯3个错误——我们逐一拆解，帮你避开坑！
</difficulty_intro>

1.  **关键点1：国王的最短步数是“切比雪夫距离”，不是“曼哈顿距离”**
    * **分析**：国王能斜走，所以“行差”和“列差”可以同时减少。比如从(1,1)到(3,3)，行差2、列差2，斜走2步就到了（步数=max(2,2)=2）；如果用曼哈顿距离（2+2=4），就会算多！优质题解都用了`max(行差, 列差)`，这是核心公式。
    * 💡 **学习笔记**：移动方式决定距离公式——能斜走→切比雪夫距离，只能直走→曼哈顿距离。

2.  **关键点2：处理大数范围，必须用long long**
    * **分析**：题目中n可以到1e18，int类型存不下（int最大约2e9）。所有优质题解都用了`long long`（或`typedef long long ll`），否则会“溢出”导致错误。
    * 💡 **学习笔记**：看题目数据范围！如果n≥1e10，一定要用long long。

3.  **关键点3：白王先走，所以步数相等时白赢**
    * **分析**：比如白王和黑王都需要3步，白王先走，所以白王第3步到达时，黑王才走了2步——白赢。所有题解都用了`white≤black`的条件，这是“先手优势”的体现。
    * 💡 **学习笔记**：题目中的“先后手”规则会影响最终结果，必须考虑！

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用技巧：
</summary_best_practices>
-   **技巧A：先想数学公式，再写代码**：像这种棋盘问题，先推导最短步数的公式，比模拟走步高效100倍！
-   **技巧B：注意数据范围**：看到n很大（比如1e18），立刻想到用long long。
-   **技巧C：验证小例子**：比如样例1中，白王距离是max(2-1,3-1)=2，黑王是max(4-2,4-3)=2，所以白赢——用公式验证样例，能快速确认思路正确。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了所有优质题解的思路，简洁又完整！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解一（Lips），是“切比雪夫距离”的典型实现，逻辑清晰、效率极高。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cmath>
    #include <algorithm>
    using namespace std;
    typedef long long ll; // 处理大数

    ll dis(ll x1, ll y1, ll x2, ll y2) {
        return max(abs(x1 - x2), abs(y1 - y2)); // 切比雪夫距离公式
    }

    int main() {
        ll n, x, y;
        scanf("%lld%lld%lld", &n, &x, &y);
        ll white = dis(1, 1, x, y); // 白王到硬币的距离
        ll black = dis(n, n, x, y); // 黑王到硬币的距离
        if (white <= black) puts("White");
        else puts("Black");
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 定义`dis`函数计算切比雪夫距离；2. 读取输入（棋盘大小n，硬币坐标x,y）；3. 计算白王和黑王的距离，比较后输出结果。关键是`dis`函数——用`max`和`abs`（绝对值）实现核心公式。


---
<code_intro_selected>
接下来看3份优质题解的**核心片段**，感受不同的思路！
</code_intro_selected>

**题解一：(来源：Lips)**
* **亮点**：用函数封装距离公式，代码可读性高。
* **核心代码片段**：
    ```cpp
    ll dis(ll x1, ll y1, ll x2, ll y2) {
        return max(abs(x1 - x2), abs(y1 - y2));
    }
    ```
* **代码解读**：
    > 这个函数专门计算“国王的最短步数”——输入两个点的坐标，返回它们的切比雪夫距离。比如`dis(1,1,2,3)`会计算`max(1,2)=2`，表示从(1,1)到(2,3)要走2步（斜走1步到(2,2)，再右走1步到(2,3)）。
* 💡 **学习笔记**：用函数封装重复逻辑，能让代码更清晰！

**题解二：(来源：PersistentLife)**
* **亮点**：对比错误和正确的距离计算，帮你深刻理解公式。
* **核心代码片段**（错误→正确）：
    ```cpp
    // 错误：曼哈顿距离（行差+列差）
    white = (x-1)+(y-1); 
    black = (n-x)+(n-y);

    // 正确：切比雪夫距离（max(行差, 列差)）
    white = max(x-1, y-1);
    black = max(n-x, n-y);
    ```
* **代码解读**：
    > 作者一开始用了“行差+列差”，但国王能斜走，所以这个是错的！比如从(1,1)到(3,3)，错误计算是4步，正确是2步。后来纠正为`max`，就对了。
* 💡 **学习笔记**：如果结果不对，先检查“距离公式”是否符合移动规则！

**题解三：(来源：Laurenceshao)**
* **亮点**：用更简洁的条件判断（x+y ≤n+1），直接得出结果。
* **核心代码片段**：
    ```cpp
    if (x + y <= n + 1) cout << "White" << endl;
    else cout << "Black" << endl;
    ```
* **代码解读**：
    > 这个条件是怎么来的？比如白王的距离是`max(x-1, y-1)`，黑王是`max(n-x, n-y)`。当x+y ≤n+1时，`max(x-1, y-1) ≤ max(n-x, n-y)`，所以白王赢。比如样例1中n=4，x=2,y=3，x+y=5=4+1，所以白赢；样例2中n=5，x=3,y=5，x+y=8>5+1=6，所以黑赢。
* 💡 **学习笔记**：有时候可以把复杂的公式简化成更直观的条件！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到国王的最短路径，我设计了一个**8位像素风格的动画**——像玩FC游戏一样理解算法！
</visualization_intro>

  * **动画演示主题**：《像素国王抢硬币》（仿FC游戏风格）
  * **核心演示内容**：展示白王（蓝色像素）从(1,1)、黑王（红色像素）从(n,n)到硬币（黄色像素）的最短路径，突出“斜走→直走”的过程。
  * **设计思路简述**：用8位像素风营造复古感，让你像玩游戏一样学算法；用音效强化关键操作（走步“叮”、到达“叮~”），帮你记住步骤；单步执行让你能仔细看每一步的变化。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
        - 屏幕显示一个8位像素棋盘（比如n=4时，4x4的网格），左下角是白王（蓝色方块），右上角是黑王（红色方块），硬币在(x,y)（黄色方块）。
        - 控制面板有“开始/暂停”“单步”“重置”按钮，还有速度滑块（控制动画快慢）。
        - 播放8位风格的轻松BGM（比如《超级马里奥》的小旋律）。
    2.  **算法启动**：
        - 点击“开始”，白王先动：比如样例1中，白王从(1,1)斜走到(2,2)（蓝色方块移动，伴随“叮”的音效）。
        - 黑王接着动：从(4,4)斜走到(3,3)（红色方块移动，同样“叮”）。
    3.  **核心步骤演示**：
        - 白王下一步斜走到(2,3)（硬币位置），黄色方块闪烁，播放“胜利音”（上扬的“叮~”），屏幕显示“White Wins!”。
        - 每一步都高亮当前移动的国王（比如白王移动时，蓝色方块闪烁），旁边的文字提示“白王走了第1步：(1,1)→(2,2)”。
    4.  **交互功能**：
        - 点击“单步”，可以一步步看国王移动；滑动“速度”滑块，能调快或调慢自动播放的速度。
        - 点击“重置”，回到初始状态，重新演示。
    5.  **游戏化元素**：
        - 每完成一步，屏幕右上角显示“步数：1/2”（白王的步数），增加“闯关”的感觉。
        - 到达硬币时，播放“胜利动画”（黄色方块周围出现像素星星），强化成就感。

  * **旁白提示**：
    - （白王第一次移动前）“白王先走！它要斜着走，同时减少行和列的差距～”
    - （白王到达硬币时）“白王到了！因为它先走，所以赢啦～”

<visualization_conclusion>
通过这个动画，你能清楚看到“切比雪夫距离”是怎么来的——国王斜着走能最快接近目标！而且游戏化的设计，会让你觉得学算法像玩游戏一样有趣～
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“切比雪夫距离”不仅能解决这道题，还能用于很多场景——比如机器人导航（机器人能斜走）、棋盘游戏（比如皇后的最短路径）。我们来做几道拓展练习吧！
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 场景1：机器人从(0,0)到(x,y)，能走8个方向，求最短步数——用切比雪夫距离。
    - 场景2：棋盘上的皇后，从A点到B点的最短步数——同样是切比雪夫距离（因为皇后能走任意步，但最短步数和国王一样？不，皇后能走任意步，所以最短步数是1或2，但思路类似）。
    - 场景3：二维平面上的点，求两个点的“最大坐标差”——这就是切比雪夫距离的定义！

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P6474** - 《[NOI Online 2020 提高组] 魔法值》
          * 🗣️ **推荐理由**：这道题虽然是魔法值计算，但其中的“距离”概念和切比雪夫距离有关，能帮你巩固“移动方式决定距离”的思路。
    2.  **洛谷 P1002** - 《过河卒》
          * 🗣️ **推荐理由**：这道题需要计算卒的最短路径（只能直走），用曼哈顿距离的思路，和本题形成对比，帮你区分两种距离。
    3.  **洛谷 P1141** - 《01迷宫》
          * 🗣️ **推荐理由**：这道题需要用广度优先搜索（BFS）计算最短路径，但其中的“移动方式”（上下左右）和本题的“8方向”不同，能帮你理解“移动规则对算法的影响”。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的“踩坑经历”是最宝贵的——我们来看两个有价值的经验：
</insights_intro>

> **参考经验 (来自 PersistentLife)**：“我一开始用了曼哈顿距离，结果WA了。后来画图发现国王能斜走，才纠正为切比雪夫距离。”
>
> **点评**：这个经验太重要了！很多人会默认“行差+列差”是最短距离，但**移动方式不同，距离公式也不同**。下次遇到类似问题，先想“能不能斜走”！

> **参考经验 (来自 Seauy)**：“我一开始想模拟国王走步，写了很多复杂的代码，结果出错了。后来用公式简化，立刻就对了。”
>
> **点评**：模拟法虽然直观，但对于大数（比如n=1e18）根本无法运行。**能用数学公式解决的问题，就不要模拟**——这能节省大量时间！


---

<conclusion>
本次关于“The King's Race”的分析就到这里啦！这道题的核心是“切比雪夫距离”，只要理解了国王的移动方式，就能用一行公式解决问题。记住：**数学是算法的灵魂**，多推导公式，少写复杂模拟～  
下次我们再一起探索更有趣的算法问题！💪
</conclusion>


---

---
处理用时：135.89秒
# 题目信息

# Presents

## 题目描述

小 Petya 非常喜欢礼物。最近，他收到了妈妈送的新年礼物——一台新笔记本电脑。他立刻决定把它送给别人，因为还有什么比送别人礼物更让人开心的呢？于是，他在家里举办了一场新年派对，并邀请了 $n$ 个朋友。

如果说 Petya 有什么比收礼物更喜欢的事情，那就是看别人互相送礼物。因此，他把笔记本电脑安全地藏起来，等到下一个新年再拿出来，并决定只观看朋友们互相交换礼物，自己不参与。他用 $1$ 到 $n$ 的整数给所有朋友编号。Petya 记得编号为 $i$ 的朋友把礼物送给了编号为 $p_i$ 的朋友。他还记得每个朋友都恰好收到了一份礼物。

现在，Petya 想知道，对于每个朋友 $i$，是谁把礼物送给了他。

## 说明/提示



由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
2 3 4 1
```

### 输出

```
4 1 2 3
```

## 样例 #2

### 输入

```
3
1 3 2
```

### 输出

```
1 3 2
```

## 样例 #3

### 输入

```
2
1 2
```

### 输出

```
1 2
```

# AI分析结果

# 💡 Kay的C++算法解析：Presents 深入学习指南 💡

<introduction>
  今天我们来一起分析「Presents」这道C++编程题。这道题看起来像是一道“反向找朋友”的游戏——给定每个人送礼物的对象，要找出每个人的礼物来自谁。本指南会帮你理清思路，掌握核心技巧，还会用像素动画让你“看”到算法的过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（数组反向映射）

🗣️ **初步分析**：
> 解决这道题的关键，是理解**“反向映射”**——就像你有一本“送礼字典”，里面写着“1号送2号”“2号送3号”，现在要反过来查“2号的礼物来自谁”“3号的礼物来自谁”。  
> 具体来说，题目给的`p_i`是“i号送p_i号”，我们需要的是“j号的礼物来自谁”——其实就是把字典的**键和值交换**！用数组实现的话，只需要一个`ans`数组：当输入`p_i`时，把`ans[p_i]`设为`i`（意思是“p_i号的礼物来自i号”）。最后输出`ans[1]`到`ans[n]`，就是每个j号的送礼者啦！  
> 核心难点是**“转过来想问题”**——很多同学一开始会混淆“谁送谁”，但只要记住“ans[收礼人] = 送礼人”，就能轻松解决。  
> 可视化方面，我会设计一个像素风的“送礼派对”动画：用像素小人代表朋友，送礼物时小人会把礼物递给对方，收礼人的头顶会弹出“来自X号”的标签，最后按顺序显示每个人的送礼者。动画支持单步执行和自动播放，还会加“叮”（送礼物）、“啪”（更新记录）的像素音效哦！

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁度和效率三个方面筛选了以下优质题解，都是能快速理解的“满分答案”！
</eval_intro>

**题解一：(来源：Wei_ch)**
* **点评**：这份题解把核心逻辑压缩到了两行循环里，非常简洁！输入时直接用`a[t] = i`（`t`是i号送的对象），一句话就完成了反向映射。代码没有冗余，变量名也很直观（`a`数组就是答案数组），连新手都能一眼看懂。而且时间复杂度是O(n)，完美解决问题！

**题解二：(来源：liJason)**
* **点评**：这题解用了两个数组`a`和`b`，`a[i]`存i号送的对象，`b[j]`存j号的送礼者。虽然比题解一多了一个数组，但逻辑更明确——`b[a[i]] = i`直接对应“i号送a[i]号，所以a[i]号的送礼者是i”。这种“分开定义”的方式适合刚学数组的同学，更容易理清关系。

**题解三：(来源：OdtreePrince)**
* **点评**：这题解的注释特别贴心！作者用`give`数组存“收礼人对应的送礼者”，输入时`give[k] = i`（k是i号送的对象），最后输出`give[1..n]`。代码里还举了样例的例子，帮你理解“1送2→give[2]=1”的逻辑，非常适合新手对照学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
很多同学第一次做这题会“绕晕”，其实只要解决以下三个关键点，就能秒懂！
</difficulty_intro>

1.  **关键点1：理解“反向问题”**  
    * **分析**：题目问的是“谁送i号”，而输入是“i号送谁”。这就像你知道“小明把糖给了小红”，要问“小红的糖来自谁”——答案就是小明。对应到数组，就是把“送礼者→收礼人”反过来变成“收礼人→送礼者”。  
    * 💡 **学习笔记**：遇到“反过来查”的问题，先想“能不能交换键和值”！

2.  **关键点2：用O(n)的方法代替O(n²)**  
    * **分析**：有些同学会用双重循环（比如yuangq的题解）：对于每个i，遍历所有j找“j送i”。但这样时间复杂度是O(n²)，如果n很大（比如1e5）就会超时。而用数组反向映射，只需要一次循环就能完成，效率高得多！  
    * 💡 **学习笔记**：能一次循环解决的问题，绝不写两次！

3.  **关键点3：处理1-based编号**  
    * **分析**：题目中的朋友编号是1到n，所以数组要从1开始用（比如`a[1]`对应1号，`a[2]`对应2号）。如果用0-based，会导致“1号对应a[0]”的错误，输出结果就会乱掉！  
    * 💡 **学习笔记**：题目给的编号是多少，数组就从多少开始！

### ✨ 解题技巧总结
<summary_best_practices>
这道题教会我们三个通用技巧：
</summary_best_practices>
- **技巧1：反向映射**：遇到“谁对应谁”的问题，先想能不能交换键和值（比如用数组存“收礼人→送礼者”）。  
- **技巧2：优先O(n)算法**：能一次遍历解决的问题，不要用双重循环，避免超时。  
- **技巧3：对齐编号**：数组下标要和题目中的编号一致（1-based或0-based），避免越界或错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用的O(n)核心实现**，这是所有优质题解的“浓缩版”，逻辑清晰到不能再清晰！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了所有优质题解的思路，用最简洁的方式实现反向映射。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        int ans[105] = {0};  // ans[j]表示j号的送礼者
        for (int i = 1; i <= n; ++i) {
            int p;
            cin >> p;
            ans[p] = i;  // i号送p号 → p号的送礼者是i
        }
        for (int j = 1; j <= n; ++j) {
            cout << ans[j] << " ";
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 读入n（朋友数量）；  
  2. 用`ans`数组存“收礼人→送礼者”：输入i号送的p号，就把`ans[p]`设为i；  
  3. 按顺序输出`ans[1]`到`ans[n]`，就是每个j号的送礼者！

---
<code_intro_selected>
再看几个优质题解的**核心片段**，感受不同的写法但相同的逻辑！
</code_intro_selected>

**题解一：(来源：Wei_ch)**
* **亮点**：把输入和反向映射合并成一行，代码极简！
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++) cin>>t,a[t]=i;
    ```
* **代码解读**：  
  这句话等价于“读入t（i号送的对象），然后把a[t]设为i”。用逗号运算符把两个操作合并，既简洁又高效——这就是C++的小技巧！  
* 💡 **学习笔记**：逗号运算符可以把多个操作写在一行，但要注意可读性哦！

**题解二：(来源：liJason)**
* **亮点**：用两个数组分开存“送”和“收”，逻辑更明确！
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[a[i]]=i;
    }
    ```
* **代码解读**：  
  `a[i]`存i号送的对象，`b[j]`存j号的送礼者。`b[a[i]] = i`的意思是“i号送a[i]号，所以a[i]号的送礼者是i”——这句话直接对应题目要求，新手看了也能懂！  
* 💡 **学习笔记**：用不同数组存不同含义的数据，能让代码更易读！

**题解三：(来源：OdtreePrince)**
* **亮点**：用`give`数组直接对应“收礼人→送礼者”，注释贴心！
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        cin>>k;
        give[k]=i;
    }
    ```
* **代码解读**：  
  `give[k] = i`的意思是“k号的礼物来自i号”——完全贴合题目的问题！作者还举了样例的例子（比如1送2→give[2]=1），帮你快速理解逻辑。  
* 💡 **学习笔记**：给数组起一个“见名知意”的名字（比如`give`），能减少很多疑惑！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”反向映射的过程，我设计了一个**8位像素风的“送礼派对”动画**！就像玩FC游戏一样，你能看到每个小人送礼物、收礼物的过程～
</visualization_intro>

  * **动画演示主题**：像素小人的“礼物交换派对”  
  * **核心演示内容**：展示“i号送p号→p号的送礼者是i”的反向映射过程，最后输出每个小人的送礼者。  
  * **设计思路简述**：用FC风格的像素画（比如16x16的小人）、鲜艳的8位颜色（比如红色小人、蓝色礼物），让你像玩游戏一样学算法。音效和关卡设计能强化记忆——比如“叮”的声音提醒你“正在送礼物”，“小关卡完成”的提示让你有成就感！

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       - 屏幕左边是“送礼区”：n个像素小人排成一列（编号1到n），每个小人手里拿着一个蓝色礼物。  
       - 屏幕右边是“收礼区”：n个空位置（编号1到n），每个位置上方有一个“？”（表示还不知道送礼者）。  
       - 底部控制面板：“开始/暂停”“单步”“重置”按钮，速度滑块（从“慢”到“快”）。  
       - 背景播放8位风格的轻快BGM（比如《超级马里奥》的小关卡音乐）。

    2. **单步执行：送礼物与更新记录**：  
       - 点击“单步”，第i个小人（比如i=1）会走到收礼区的p号位置（比如p=2），把礼物递过去——此时播放“叮”的音效。  
       - 收礼区的p号位置上方的“？”会变成“来自i号”（比如“来自1号”），同时右边的`ans`数组面板中，`ans[p]`的位置会亮起（显示i）——此时播放“啪”的音效。  
       - 重复这个过程，直到所有小人都送完礼物。

    3. **自动播放：快速看完整过程**：  
       - 点击“自动播放”，小人会依次送礼物，收礼区的“？”逐个变成“来自X号”，`ans`数组面板同步更新。你可以用滑块调整速度（慢：1秒/步；快：0.2秒/步）。

    4. **目标达成：输出结果**：  
       - 所有礼物送完后，收礼区的每个位置都会显示“来自X号”，屏幕下方会按顺序弹出“1号的送礼者是4号”“2号的送礼者是1号”等文字——此时播放上扬的“胜利”音效（比如《塞尔达传说》的宝箱声）。

    5. **游戏化关卡**：  
       - 把“送10个礼物”设为一个小关卡，完成后屏幕会弹出“关卡1完成！得分+10”的提示，小人会跳一下庆祝——让你在“闯关”中熟悉算法！

  * **旁白提示**：
    - 送礼物时：“看！1号小人把礼物送给了2号～”  
    - 更新记录时：“2号的送礼者是1号，所以ans[2] = 1！”  
    - 输出结果时：“所有礼物都送完啦！现在按顺序说出每个人的送礼者～”

<visualization_conclusion>
通过这个动画，你能**直观看到**“反向映射”是怎么工作的——小人送礼物的过程，就是`ans[p] = i`的过程！像素风格和游戏化元素会让你觉得“学算法像玩游戏一样有趣”～
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“反向映射”，你可以解决很多类似的问题——比如“查字典”“找归属”“统计出现次数”！
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 反向映射的技巧可以用于：查“谁收藏了我的文章”（已知“我收藏了谁的文章”）、统计“每个分数有多少人”（已知“每个人的分数”）、找“覆盖某点的最后一块地毯”（已知“每块地毯的位置”）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P1003 铺地毯**  
       * 🗣️ **推荐理由**：这题需要“反向查询”——已知每块地毯的位置，要找覆盖某点的最后一块地毯。和本题的“反向映射”思路一模一样，能帮你巩固技巧！
    2. **洛谷 P1161 开灯**  
       * 🗣️ **推荐理由**：这题是模拟开关灯的过程，用数组记录每个灯的状态（开/关）。和本题一样，都是“用数组存状态”的基础应用，适合练手！
    3. **洛谷 P1328 生活大爆炸版石头剪刀布**  
       * 🗣️ **推荐理由**：这题需要用数组映射“手势对应的胜负”（比如“石头赢剪刀”）。和本题的“反向映射”类似，都是“用数组存对应关系”，能拓展你的思维！

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的作者分享了一些实用的小技巧，帮你少走弯路！
</insights_intro>

> **参考经验 (来自 小鲍bob)**：“我用了两种方法，第二种方法输入n-1个数，最后一个数用0判断，省了0.04秒。”  
> **点评**：虽然n很小的时候优化意义不大，但这种“优化意识”很重要！比如当n是1e5时，少输入一个数就能节省时间——编程就是要“多想一点”！

> **参考经验 (来自 yuangq)**：“我用了N²的方法，但数据太小能过。”  
> **点评**：这提醒我们，要优先选择高效的算法（比如O(n)），而不是“能过就行”。如果n很大，O(n²)的方法会直接超时——编程要“目光长远”！

---

<conclusion>
本次关于「Presents」的分析就到这里啦！这道题的核心是“反向映射”，用数组就能轻松解决。记住：遇到“反过来查”的问题，先想“能不能交换键和值”！  
编程就像玩游戏，多练、多想就能通关～下次我们再一起解决更有趣的问题！💪
</conclusion>

---
处理用时：147.49秒
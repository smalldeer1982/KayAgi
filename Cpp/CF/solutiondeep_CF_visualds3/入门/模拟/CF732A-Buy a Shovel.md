# 题目信息

# Buy a Shovel

## 题目描述

Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for $ k $ burles. Assume that there is an unlimited number of such shovels in the shop.

In his pocket Polycarp has an unlimited number of "10-burle coins" and exactly one coin of $ r $ burles ( $ 1<=r<=9 $ ).

What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of $ r $ burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.

## 说明/提示

In the first example Polycarp can buy 9 shovels and pay $ 9·117=1053 $ burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.

In the second example it is enough for Polycarp to buy one shovel.

In the third example Polycarp should buy two shovels and pay $ 2·15=30 $ burles. It is obvious that he can pay this sum without any change.

## 样例 #1

### 输入

```
117 3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
237 7
```

### 输出

```
1
```

## 样例 #3

### 输入

```
15 2
```

### 输出

```
2
```

# AI分析结果

# 💡 Kay的C++算法解析：Buy a Shovel 深入学习指南 💡

<introduction>
  今天我们来一起分析Codeforces的经典题目“Buy a Shovel”（买铲子）。这道题看起来是“数学题”，但其实核心是**用“枚举法”快速找答案**——就像在一堆糖里找最甜的那颗，试几个就找到了！本指南会帮你理清思路、看懂代码，还能通过像素动画“看”到算法跑起来的样子～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（暴力枚举的简化应用）

🗣️ **初步分析**：
> 解决这道题的关键，是把“不用找零”的条件**翻译成数学语言**——买`i`把铲子的总钱数是`i*k`，要满足：  
> 1. 总钱数是10的倍数（用无限的10元硬币支付，不用r元硬币）；  
> 2. 总钱数减去r是10的倍数（用r元硬币+若干10元硬币支付）。  
> 换句话说，`i*k`的**个位数字**必须是`0`或`r`（因为10的倍数个位是0，减r后是10的倍数意味着个位是r）。  

那怎么找最小的`i`呢？其实不用算复杂公式——**枚举`i`从1到10**就够了！因为当`i=10`时，`10*k`的个位肯定是0（10乘任何数都是10的倍数），所以答案一定在1~10之间，绝对不会超时～  

**可视化设计思路**：我们会用“像素小商店”的动画展示枚举过程——屏幕上有个像素化的铲子堆，旁边显示当前买了`i`把，总钱数的个位会“跳”出来（比如`i=3`时，个位是`3*k%10`）。当个位变成0或r时，铲子堆会“发光”，同时播放“叮”的胜利音效，帮你直观看到“找到答案”的瞬间～


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰性、代码简洁度、优化技巧”三个维度筛选了3份优质题解，都是“枚举法”的典型应用，但各有亮点～
</eval_intro>

**题解一：Scrutiny（赞：9）**
* **点评**：这份题解把问题简化到了极致！直接循环`i`从1到10，判断`i*k%10`是否是0或r——符合条件就立刻输出并结束程序。思路像“直走找门”一样直白，代码只有几行，变量名也清晰（`k`是单价，`r`是零钱）。最棒的是**提前终止循环**（用`return 0`），避免多余计算，非常高效！

**题解二：chenpengda（赞：0）**
* **点评**：这是“优化版枚举”！作者发现“总钱数的个位”只和`k`的个位有关（比如`k=117`，个位是7，`i*k`的个位等于`i*7%10`）。所以他先取`k`的个位（`k%=10`），再循环累加个位（`k=(k+firstk)%10`），只需要判断个位是不是0或r——**把乘法变成了加法**，计算量更小！这种“抓本质（个位）”的思路，能帮你解决很多“末尾数字”问题～

**题解三：Trans_Portal（赞：1）**
* **点评**：这份题解的循环条件写得超简洁！`for(i=1;(k*i)%10!=r&&(k*i)%10!=0;i++)`——意思是“只要不满足条件，就一直加i”。虽然也是枚举，但代码更紧凑，适合喜欢“短代码”的同学。作者还特别提醒“r可以不用”（即总钱数是10的倍数的情况），避免了死循环，考虑很周到～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题看似简单，但第一次做容易“想复杂”。我总结了3个核心难点，帮你“踩稳”解题的每一步～
</difficulty_intro>

1.  **难点1：把“支付条件”翻译成数学表达式**
    * **分析**：题目说“不用找零”，意味着总钱数可以用“无限10元+最多1个r元”支付。翻译成数学就是：`i*k = 10*a`（不用r元） 或 `i*k = 10*a + r`（用r元）。这两个式子合并起来，就是`i*k%10 == 0`或`i*k%10 == r`——**关键是抓住“个位”这个核心**！
    * 💡 **学习笔记**：解决“支付/找零”问题时，先想“总钱数的末尾数字”，往往能简化问题！

2.  **难点2：意识到“枚举范围很小”（1~10）**
    * **分析**：很多同学会担心“枚举会不会超时”，但这道题的答案最多是10（因为`10*k`一定是10的倍数）。所以循环10次就够了，比“算公式”还快！
    * 💡 **学习笔记**：当答案范围很小时，“暴力枚举”比“找规律”更简单直接！

3.  **难点3：处理“边界条件”（比如i=1时是否满足）**
    * **分析**：比如样例2的输入是`237 7`，`i=1`时`237%10=7`，刚好等于r，所以直接输出1。如果没考虑`i=1`的情况，可能会多循环几次，但其实**从1开始枚举就能覆盖所有边界**。
    * 💡 **学习笔记**：枚举要从“最小可能值”（本题是1）开始，避免漏掉答案！


### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，你能学会3个通用技巧，以后遇到类似问题直接用～
</summary_best_practices>
-  **技巧1：抓“末尾数字”**：涉及“10的倍数”“找零”的问题，优先看总钱数的个位；
-  **技巧2：小范围枚举**：答案范围≤100时，直接枚举比“推导公式”更快；
-  **技巧3：提前终止循环**：找到答案就立刻`return 0`，不要做多余计算！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“通用核心代码”——综合了Scrutiny和chenpengda的思路，既简洁又高效～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Scrutiny的题解，是“枚举法”的最经典实现，适合新手入门。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int k, r;
        cin >> k >> r;
        for (int i = 1; i <= 10; ++i) {
            if (i * k % 10 == r || i * k % 10 == 0) {
                cout << i << endl;
                return 0; // 找到答案，立刻结束
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 输入单价`k`和零钱`r`；
    > 2. 从`i=1`开始枚举，直到`i=10`；
    > 3. 每轮判断`i*k`的个位是不是0或r；
    > 4. 符合条件就输出`i`，并终止程序（`return 0`）。


<code_intro_selected>
接下来看两个“亮点片段”——帮你学会更优化的写法！
</code_intro_selected>

**题解二：chenpengda（优化个位计算）**
* **亮点**：只用“个位”计算，减少乘法操作，更快！
* **核心代码片段**：
    ```cpp
    int k, r, cnt = 1;
    cin >> k >> r;
    k %= 10; // 取k的个位
    int firstk = k;
    while (!(k == 0 || k == r)) {
        k = (k + firstk) % 10; // 累加个位（相当于i增加1）
        cnt++;
    }
    cout << cnt;
    ```
* **代码解读**：
    > 1. `k%=10`：比如`k=117`，取个位7；
    > 2. `firstk = k`：保存最初的个位（比如7）；
    > 3. `while`循环：只要个位不是0或r，就继续累加；
    > 4. `k = (k + firstk) % 10`：相当于`i`增加1，总钱数的个位增加`firstk`（比如`i=2`时，个位是7+7=14→4）；
    > 5. `cnt`记录`i`的次数，最后输出。
* 💡 **学习笔记**：处理“末尾数字”问题时，用“模10”和“累加”代替乘法，能减少计算量！

**题解三：Trans_Portal（简洁循环条件）**
* **亮点**：把“不满足条件”写在循环里，代码更紧凑！
* **核心代码片段**：
    ```cpp
    int i, r, k;
    cin >> k >> r;
    for (i = 1; (k * i) % 10 != r && (k * i) % 10 != 0; i++) {}
    cout << i;
    ```
* **代码解读**：
    > 1. `for`循环的条件是“`k*i`的个位不是r且不是0”；
    > 2. 只要条件满足，就继续加`i`；
    > 3. 当条件不满足时（即找到答案），循环结束，输出`i`。
* 💡 **学习笔记**：循环条件可以写“反向条件”，让代码更简洁！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”枚举的过程，我设计了一个**8位像素风的“铲子商店”动画**——像玩FC游戏一样学算法！
</visualization_intro>

### 动画设计细节
* **主题**：像素小老板卖铲子，你帮Polycarp试买多少把能“不用找零”。
* **风格**：FC红白机风格（8位像素、16色调色板），背景是像素化的商店（有货架、收银台），铲子是黄色小方块堆叠。
* **核心演示内容**：
  1. **初始化**：屏幕左侧显示“当前买了i把”（i从1开始），右侧显示“总钱数的个位”（比如i=1时是k%10）；
  2. **单步执行**：点击“下一步”，i增加1，铲子堆多一个方块，个位数字“跳”一下（比如从7变4）；
  3. **满足条件**：当个位是0或r时，铲子堆会“闪烁金色”，同时播放“叮～”的胜利音效（8位音色）；
  4. **自动演示**：点击“自动”，动画会每秒走一步，直到找到答案；
  5. **重置**：点击“重新来”，回到i=1的状态，重新开始。

### 关键交互与音效
- **操作音效**：每点一次“下一步”，播放“滴答”声（像钟表走针）；
- **胜利音效**：找到答案时，播放“叮～”的上扬音调（类似FC游戏通关）；
- **速度调节**：有个“快慢滑块”，可以调自动演示的速度（从“慢”到“快”）。

### 为什么这么设计？
- 像素风格：唤起你对经典游戏的回忆，让学习更轻松；
- 音效提示：用声音强化“关键操作”（比如找到答案），帮你记住重点；
- 单步/自动：既能慢慢看每一步，也能快速过流程，适合不同学习节奏。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“枚举法”是编程的“基本功”，很多问题都能用它解决——比如“找符合条件的最小数”“试所有可能的情况”。下面是3道洛谷的相似题目，帮你巩固技巧～
</similar_problems_intro>

### 通用思路迁移
“枚举法”适合**答案范围小、无法用公式快速计算**的问题，比如：
1. 找“能被3和5同时整除的最小数”；
2. 试“不同的密码组合”（比如密码是1~100的数）；
3. 找“满足某种条件的最短路径”（比如迷宫的小地图）。

### 洛谷练习推荐
1.  **洛谷 P1001** - A+B Problem  
    * 🗣️ **推荐理由**：虽然是入门题，但能练“输入输出”和“简单计算”，是枚举法的基础；
2.  **洛谷 P1046** - 花生采摘  
    * 🗣️ **推荐理由**：需要枚举“摘花生的顺序”，找到最大收获，练“枚举的逻辑设计”；
3.  **洛谷 P1102** - A-B Problem  
    * 🗣️ **推荐理由**：需要枚举“补数”，判断是否存在，练“枚举的条件判断”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都提到了“枚举范围”的问题——比如“为什么循环到10就够了？”，这里分享一个常见的“踩坑”经验：
</insights_intro>

> **参考经验（来自题解作者“不到前10不改名”）**：“买10把铲子的话，总价肯定是10的倍数，所以循环到10就够了——小学三年级就知道10乘任何数都是10的倍数！”
>
> **点评**：这个经验超实用！很多同学会“不敢停止循环”，但其实**题目中的“10元硬币无限”已经暗示了答案≤10**。以后遇到“和10相关的问题”，先想“10的倍数”的特性，能帮你缩小枚举范围～


<conclusion>
“Buy a Shovel”是一道“披着数学外衣的枚举题”——关键是**把问题简化到“试几个数”**。通过这道题，你学会了“抓末尾数字”“小范围枚举”“提前终止循环”三个技巧，这些都是以后解决更难问题的基础！

记住：**简单的方法往往最有效**——不要怕“暴力枚举”，只要范围小，它就是“最优解”～ 下次遇到类似的问题，勇敢地“试”起来吧！💪
</conclusion>

---
处理用时：315.45秒
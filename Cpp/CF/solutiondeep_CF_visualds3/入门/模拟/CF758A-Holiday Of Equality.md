# 题目信息

# Holiday Of Equality

## 题目描述

## 题目大意
今天是Berland的平等节。为了庆祝节日，国王决定用国库里的钱来使Berland所有公民的福利均等。

在Berland，有$N$个公民，每个人的福利都被估计为一个整数$a_{i}$ burle（burle是Berland的货币）。

你是皇家财政管理员，你需要计算国王为此要付出的最低费用。国王只能给公民们钱，他没有权力夺走任何钱财。

## 说明/提示

第一个样例中，如果我们给第一个公民4 burles，第二个3 burles，第三个2 burles，第四个1 burle，那么所有公民的福利都等于4 burles。

第二个样例中，我们只需要给第三个公民1 burle就可以使得福利均等。

第三个样例中，我们需要分别给第一个和第三个公民2 burles，使得福利都等于3 burles。

第四个样例中，我们不需要给任何人钱因为所有人的福利都是12 burles。


对于100%的数据，$1 \leq n \leq 100$，$0 \leq a_{i} \leq 10^{6}$。

翻译提供者：Simpson561

## 样例 #1

### 输入

```
5
0 1 2 3 4
```

### 输出

```
10```

## 样例 #2

### 输入

```
5
1 1 0 1 1
```

### 输出

```
1```

## 样例 #3

### 输入

```
3
1 3 1
```

### 输出

```
4```

## 样例 #4

### 输入

```
1
12
```

### 输出

```
0```

# AI分析结果

# 💡 Kay的C++算法解析：Holiday Of Equality 深入学习指南 💡

<introduction>
今天我们来一起分析「Holiday Of Equality」这道C++编程题。这道题看似需要“给公民加钱”，实则藏着一个**数学小魔法**——用简单的公式就能快速算出最小费用！本指南会帮你理清思路、掌握核心技巧，还会用像素动画让算法“动起来”～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学计算 + 基础模拟`  

🗣️ **初步分析**：  
解决这道题的关键，在于理解一个**数学转化**：要让所有公民的福利均等（只能加钱不能减），**最小费用一定是把所有人的福利补到“当前最大值”**——因为如果补到比最大值小的数，反而需要更多钱（比如样例1中最大值是4，补到4的总费用是10；如果补到3，总费用是(3-0)+(3-1)+(3-2)+(3-3)+(3-4)？不对，因为不能减钱，所以4不能变成3！所以只能补到最大值）。  

进一步推导公式：总费用 = 所有人补到最大值的差值之和 = \( m \times n - \sum_{i=1}^n a_i \)（\( m \)是最大值，\( n \)是人数，\( \sum a_i \)是原福利总和）。这个公式把“逐个计算差值”变成了“两次累加”，效率更高！  

题解的核心思路高度一致：**要么边读入边算最大值和总和（不用数组），要么先存数组再找最大值和总和**。核心难点是：  
1. 理解“必须补到最大值”的逻辑；  
2. 选择更高效的计算方式（边读边算 vs 存数组）。  

**可视化设计思路**：我们会用8位像素风格模拟“给公民加钱”的过程——用不同高度的像素块代表福利值，最大值用红色高亮，其他用蓝色。每一步给蓝色块“加钱”（像素块长高），同时显示当前累加的费用，用“叮”的音效强化操作记忆～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码效率、实用技巧等方面筛选了3份优质题解，帮你快速掌握核心！
</eval_intro>

**题解一：(来源：Alex_Wei，赞16)**  
* **点评**：这份题解把“数学公式”用到了极致！作者没有用数组，而是**边读入边计算最大值和总和**——每读一个数，就更新最大值`m`，同时累加总和`s`。最后直接用公式`n*m - s`输出结果，代码极简到只有几行！这种“边读边处理”的技巧不仅节省空间（不用存数组），还避免了后续遍历数组的时间，是本题的“最优解模板”。  

**题解二：(来源：tryrtj，赞1)**  
* **点评**：作者同样不用数组，但额外分享了**输入方式的优化技巧**——通过提交记录对比，发现`cin`内存消耗更小，`scanf`速度更快。这对以后处理“大数据输入”很有帮助！代码逻辑和题解一一致，但用`scanf`读入、`cin`输出，兼顾了速度和内存。  

**题解三：(来源：whose，赞7)**  
* **点评**：这份题解适合初学者理解！作者用数组存所有福利值，然后**用`sort`排序找最大值**（排序后最后一个元素就是最大值）。虽然排序会多花一点时间，但代码逻辑直白——“先存起来，再排好序，最后算差值”，非常符合新手的思考习惯。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“难点”其实是“想通关键逻辑”。结合优质题解，我帮你提炼了3个核心思考点：
</difficulty_intro>

1. **关键点1：为什么必须补到最大值？**  
    * **分析**：国王不能夺钱，所以只能“往上补”。如果补到比最大值小的数（比如样例1补到3），最大值4无法减少到3，所以这种情况不合法！只有补到最大值，才能让所有人福利相等，且总费用最小。  
    * 💡 **学习笔记**：**“不能减只能加”=“必须看齐最大值”**，这是题目的隐藏条件！

2. **关键点2：如何高效计算最大值和总和？**  
    * **分析**：优质题解分两类：  
      - 边读边算（题解一、二）：不用数组，每读一个数就更新最大值和总和，空间复杂度O(1)（几乎不占内存）；  
      - 存数组再处理（题解三）：需要O(n)的空间，但逻辑简单。  
      边读边算更高效，适合数据量大的情况（比如n=1e5时，数组会占更多内存）。  
    * 💡 **学习笔记**：**能边读边处理的问题，就别先存数组！**

3. **关键点3：输入方式怎么选？**  
    * **分析**：`cin`和`scanf`的区别：`cin`默认同步C语言stdio，速度较慢，但内存消耗小；`scanf`速度快，但内存稍大。如果题目时间限制紧（比如n=1e6），用`scanf`；如果内存限制紧，用`cin`（可以加`ios::sync_with_stdio(false); cin.tie(0);`加速）。  
    * 💡 **学习笔记**：**输入方式要根据题目限制调整！**

### ✨ 解题技巧总结
- **技巧1：问题转化为数学公式**：把“逐个算差值”变成“算总和差”，减少计算步骤；  
- **技巧2：边读边处理**：避免数组存储，节省空间和时间；  
- **技巧3：输入优化**：根据题目限制选择`cin`或`scanf`，必要时用加速代码。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用最优解**——综合了题解一的“边读边算”和题解二的“输入优化”，代码极简且高效！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解一的优化版，加入了`cin`加速，兼顾速度和内存。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;

  int main() {
      ios::sync_with_stdio(false); // 关闭cin与stdio同步，加速cin
      cin.tie(0); // 解除cin与cout的绑定，进一步加速

      int n, a;
      long long max_val = 0, sum = 0; // 用long long防止溢出（a_i可达1e6，n=100时sum=1e8，int够，但养成好习惯）
      cin >> n;

      for (int i = 0; i < n; ++i) {
          cin >> a;
          if (a > max_val) max_val = a;
          sum += a;
      }

      cout << max_val * n - sum << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 先关闭`cin`的同步和绑定，加速输入；  
  2. 用`max_val`存最大值，`sum`存总和，边读边更新；  
  3. 最后用公式计算总费用，输出结果。


<code_intro_selected>
接下来剖析3份优质题解的核心片段，看它们的亮点！
</code_intro_selected>

**题解一：(来源：Alex_Wei)**
* **亮点**：不用数组，边读边算，代码极简。
* **核心代码片段**：
  ```cpp
  int m,s,n,a;
  int main() {
      cin>>n;
      for(int x=1;x<=n;x++) cin>>a, m=max(m,a), s+=a;
      cout<<n*m-s;
  }
  ```
* **代码解读**：  
  作者用`m`存最大值，`s`存总和。`for`循环里**逗号表达式**把“读入a→更新m→累加s”写在一行，非常简洁！注意`max`函数需要`#include<algorithm>`吗？其实`using namespace std;`后，`max`是std命名空间的函数，但有些编译器（比如GCC）允许省略头文件——不过最好加上`#include<algorithm>`哦～
* 💡 **学习笔记**：逗号表达式可以简化“多步操作”，但不要过度使用（影响可读性）。

**题解二：(来源：tryrtj)**
* **亮点**：对比`cin`和`scanf`的差异，实用技巧。
* **核心代码片段**：
  ```cpp
  int n,w,maxn=0,zong=0;
  cin>>n;
  for(int i=0;i<n;i++){
      scanf("%d",&w);
      zong+=w;
      if(w>maxn)maxn=w;
  }
  cout<<maxn*n-zong;
  ```
* **代码解读**：作者用`scanf`读入`w`（速度快），用`cin`输出（内存小）。`maxn`存最大值，`zong`存总和——逻辑和题解一一致，但输入方式更灵活。
* 💡 **学习笔记**：`scanf`的格式是`%d`对应`int`，`%lld`对应`long long`，要注意匹配！

**题解三：(来源：whose)**
* **亮点**：用`sort`找最大值，逻辑直白。
* **核心代码片段**：
  ```cpp
  int n,a[101],ans;
  int main(){
      scanf("%d",&n);
      for(int i=1;i<=n;i++) scanf("%d",&a[i]);
      sort(a+1,a+n+1); // 排序后a[n]是最大值
      for(int i=1;i<n;i++) ans+=a[n]-a[i];
      printf("%d",ans);
  }
  ```
* **代码解读**：作者把数组排序后，最后一个元素`a[n]`就是最大值。然后遍历前n-1个元素，累加差值。这种方法适合“需要保存所有数据”的场景（比如后续要输出每个公民的补钱数）。
* 💡 **学习笔记**：`sort`函数默认升序排序，头文件是`#include<algorithm>`。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到算法的每一步，我设计了一个**8位像素风格的动画**——像玩FC游戏一样理解“给公民加钱”的过程！
</visualization_intro>

### ✨ 动画设计方案
**动画主题**：像素公民的“福利升级记”  
**风格**：FC红白机风格（256色像素、粗边框、复古字体）  
**核心演示内容**：模拟“边读入边算最大值→补钱到最大值→计算总费用”的过程。


#### 1. 场景与UI初始化（8位像素风）
- **主画面**：屏幕左侧显示`n`个像素块（代表`n`个公民），每个块的高度=福利值（比如福利0是1个像素，福利4是4个像素）；  
- **右侧控制面板**：  
  - 按钮：开始/暂停（红色）、单步（蓝色）、重置（黄色）；  
  - 滑块：速度调节（慢→快）；  
  - 显示区：当前最大值（红色数字）、当前总和（蓝色数字）、当前总费用（绿色数字）；  
- **背景音乐**：循环播放8位风格的《欢乐颂》片段（轻快，符合“平等节”主题）。


#### 2. 算法动态演示（关键步骤+音效）
以**样例1（输入5；0 1 2 3 4）**为例：
1. **读入阶段**：  
   - 每读一个数（比如第一个数0），左侧出现一个蓝色像素块（高度1），右侧“总和”增加0，“最大值”更新为0；  
   - 读入第二个数1，蓝色块高度变为2，“总和”增加1，“最大值”更新为1；  
   - 直到读入第五个数4，蓝色块高度变为5，“总和”=0+1+2+3+4=10，“最大值”=4（红色高亮）。  
   - **音效**：每读一个数，播放“滴”的短音。

2. **补钱阶段**：  
   - 逐个给蓝色块“加钱”：第一个块（原0）开始“长高”，每长1个像素（代表加1 burle），右侧“总费用”增加1，直到高度等于最大值4（变成红色）；  
   - 第二个块（原1）同理，长到4，总费用增加3；  
   - 直到所有块都变成红色，总费用=4+3+2+1+0=10（和公式结果一致）。  
   - **音效**：每加1 burle，播放“叮”的脆音；所有块变红时，播放“噔噔噔”的胜利音效。


#### 3. 交互与控制
- **单步模式**：点击“单步”按钮，每一步只处理一个公民的补钱（比如先补第一个，再补第二个）；  
- **自动模式**：点击“开始”，动画自动播放，速度由滑块调节（最慢1秒/步，最快0.1秒/步）；  
- **重置模式**：点击“重置”，回到初始状态，可以重新输入数据（比如换样例2试试）。


#### 4. 旁白提示（像素气泡）
- 读入阶段：“现在读入第1个公民的福利：0！总和变成0，最大值是0～”；  
- 补钱阶段：“给第1个公民加1 burle，总费用变成1～”；  
- 完成阶段：“所有公民都达到最大值4啦！总费用是10～”。


<visualization_conclusion>
通过这个动画，你能**直观看到**：最大值是怎么来的？补钱是怎么累加的？公式为什么正确？复古风格和音效还能让学习更有趣～


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“数学转化”和“边读边处理”技巧，能解决很多类似问题！比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：计算“让所有数变成同一个数的最小增量和”（只能加不能减）；  
- **场景2**：统计“数组中所有元素与最大值的差之和”；  
- **场景3**：处理“输入数据时实时计算统计量（最大值、总和）”。


### 洛谷练习推荐
1. **洛谷 P1001 A+B Problem**  
   * 🗣️ **推荐理由**：基础输入输出练习，帮你巩固“边读边算”的习惯！
2. **洛谷 P1046 陶陶摘苹果**  
   * 🗣️ **推荐理由**：模拟题，需要计算“能摘到的苹果数量”，类似“统计满足条件的元素”。
3. **洛谷 P1152 欢乐的跳**  
   * 🗣️ **推荐理由**：数学计算题，需要计算“相邻元素差的绝对值”，锻炼“边处理边统计”的能力。
4. **洛谷 P1200 你的飞碟在这儿**  
   * 🗣️ **推荐理由**：数学题，需要计算“两个数的乘积的各位和”，强化“数学转化”思维。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中藏着很多“踩坑经验”，比如：
</insights_intro>

> **参考经验 (来自tryrtj)**：“cin读入内存小，scanf读入速度快，以后内存卡得严就用cin，时间紧就用scanf。”  
> **点评**：这个经验太实用了！很多新手会忽略“输入方式的效率”，但在大数据题目中，`cin`可能会超时，`scanf`能救你一命～  
> **参考经验 (来自Alex_Wei)**：“边读边算不用数组，代码更简洁。”  
> **点评**：数组不是“万能的”！能省则省，不仅节省内存，还能减少“数组越界”的bug～


<conclusion>
这道题的核心是**“数学公式+边读边处理”**——看起来是“给公民加钱”，实则是“用数学简化计算”。记住：**能转化为公式的问题，就别用暴力遍历**！  

下次遇到类似的“累加差值”问题，先想想有没有数学公式能简化——比如“总和差”“平均值差”之类的。编程的本质是“用更聪明的方式解决问题”，而不是“写更多的代码”～  

加油！下次我们一起挑战更难的问题～💪
</conclusion>

---
处理用时：369.58秒
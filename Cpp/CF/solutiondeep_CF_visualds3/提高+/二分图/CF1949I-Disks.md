# 题目信息

# Disks

## 题目描述

# 圆盘


你在平面上有 $ n $ 个圆盘。每个圆盘的中心具有整数坐标，每个圆盘的半径为正整数。没有两个圆盘在一个正面积的区域重叠，但圆盘之间可能相切。

你的任务是确定是否可以改变圆盘的半径，使得：

- 原来相切的圆盘仍然相切。
- 没有两个圆盘在一个正面积的区域重叠。
- 所有半径的总和严格减小。

新的半径可以是任意正实数。不能改变圆盘的中心。

## 说明/提示

在第一个样例中，可以将第一个和第三个圆盘的半径减小 $ 0.5 $ ，将第二个圆盘的半径增加 $ 0.5 $ 。这样，所有半径的总和减小了 $ 0.5 $ 。改变半径前后的情况如下图所示。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1949I/1f564e55d56b152b57e25e4b9913f6abfe12e4f8.png) 第一个样例（左）和改变圆盘半径的有效方法（右）。在第二个样例中，如下图所示，无法按照要求改变圆盘的半径。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1949I/160a9b50ca0114a94aa27312025cf229be0abcc8.png) 第二个样例。

## 样例 #1

### 输入

```
5
0 2 1
0 0 1
4 -3 4
11 0 3
11 5 2```

### 输出

```
YES```

## 样例 #2

### 输入

```
4
2 2 2
7 2 3
7 7 2
2 7 3```

### 输出

```
NO```

# AI分析结果



---
# 💡 Kay的C++算法解析：Disks 深入学习指南 💡

<introduction>
今天我们来一起分析“Disks”这道C++编程题。这道题需要我们判断是否可以通过调整圆盘半径，在满足条件的情况下使总半径和严格减小。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（二分图判定）

🗣️ **初步分析**：
> 解决“Disks”问题的关键在于将圆盘的相切关系转化为图论中的边，进而通过二分图判定来验证是否存在可行的半径调整方案。简单来说，图论中的二分图是指可以将图的节点分为两个互不相交的集合，使得每条边都连接两个集合中的节点。在本题中，我们可以将每个圆盘视为图中的一个节点，若两个圆盘相切则连一条边。此时，若某个连通块是二分图且两部分节点数不等，则可以通过调整半径（一部分减x，另一部分加x）使总半径和减少。
   - **题解思路**：所有题解核心思路一致：构建相切圆盘的无向图，检查每个连通块是否为二分图且两部分节点数不等。若存在这样的连通块，输出“YES”，否则“NO”。
   - **核心难点**：如何将圆盘相切关系转化为图结构？如何通过二分图判定和节点数比较得出结论？
   - **可视化设计思路**：用像素点表示圆盘，相切关系用线段连接；二分图染色过程用两种颜色交替标记节点（如红色和蓝色），节点数统计用数字动态显示。关键步骤高亮（如染色冲突时的闪烁），音效提示染色成功/失败（“叮”/“咚”）。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等方面筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：作者：江户川·萝卜**
* **点评**：这份题解思路清晰，将问题转化为图论模型的过程解释明确。代码风格规范（如变量名`vis`表示访问状态，`cnt`统计颜色数量），关键步骤（如DFS染色、连通块处理）逻辑直白。算法上通过DFS进行二分图判定，时间复杂度为O(n²)（构建图）+O(n)（DFS），高效且适用于题目限制（n≤1000）。代码中对边界条件的处理（如`memset(vis,-1,sizeof vis)`初始化未访问状态）严谨，实践价值高，可直接用于竞赛。

**题解二：作者：WuMin4**
* **点评**：此题解对问题本质的抽象到位（“相切圆半径和固定”），并明确指出二分图判定的意义（“半径增减的交替性”）。代码结构简洁（如用`col`数组记录颜色，`cc`数组统计各颜色节点数），变量命名直观。算法逻辑与题解一一致，但通过`ans`变量提前终止循环优化了部分情况的处理，代码可读性强，适合学习如何将数学模型转化为代码实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何将圆盘相切关系转化为图结构？
    * **分析**：两个圆盘相切的条件是圆心距离等于半径之和（即$(x_i-x_j)^2 + (y_i-y_j)^2 = (r_i + r_j)^2$）。题解中通过双重循环遍历所有圆盘对，计算距离平方与半径和平方是否相等，相等则连边。这一步是后续分析的基础。
    * 💡 **学习笔记**：将几何问题转化为图论模型时，关键是找到“关系”的数学条件（如本题的相切条件），并用边表示这种关系。

2.  **关键点2**：如何通过二分图判定验证半径调整的可行性？
    * **分析**：若两个圆盘相切（连边），则调整半径时，一个圆盘半径减x，另一个必须加x（否则无法保持相切）。这要求图中的相邻节点必须属于不同集合（二分图的定义）。若某个连通块是二分图且两部分节点数不等（设为a和b，a≠b），则总半径和变化为$(b - a)x$，取x>0时总半径和可减小（若b>a则a为减的集合，总变化为负）。
    * 💡 **学习笔记**：二分图的“颜色”对应半径的增减方向，节点数差异决定了总半径和能否减小。

3.  **关键点3**：如何高效实现二分图判定？
    * **分析**：通过DFS或BFS对每个连通块进行染色（如0和1），若发现相邻节点颜色相同则不是二分图。题解中使用DFS实现，代码简洁且时间复杂度低（每个节点仅访问一次）。
    * 💡 **学习笔记**：DFS/BFS是二分图判定的经典方法，适合处理连通块问题。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的分析，我总结了以下通用解题技巧：
</summary_best_practices>
-   **问题抽象**：将几何问题（圆盘相切）转化为图论模型（边连接相切圆盘），简化问题复杂度。
-   **条件转换**：利用数学条件（圆心距离=半径和）建立图的边，将半径调整问题转化为图的属性（二分图、节点数差异）分析。
-   **提前终止**：在遍历连通块时，若发现符合条件的连通块（二分图且节点数不等），可直接输出结果，避免不必要的计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了两个优质题解的思路，采用DFS进行二分图判定，逻辑清晰且实现高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MAXN = 1005;

    int n;
    int x[MAXN], y[MAXN], r[MAXN];
    vector<int> adj[MAXN];
    int color[MAXN]; // -1:未访问，0/1:颜色
    bool isBipartite;

    void dfs(int u, int c, int& cnt0, int& cnt1) {
        color[u] = c;
        (c == 0 ? cnt0 : cnt1)++;
        for (int v : adj[u]) {
            if (color[v] == -1) {
                dfs(v, c ^ 1, cnt0, cnt1);
                if (!isBipartite) return; // 提前终止
            } else if (color[v] == c) {
                isBipartite = false;
                return;
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> x[i] >> y[i] >> r[i];
        }

        // 构建相切关系图
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                ll dx = x[i] - x[j];
                ll dy = y[i] - y[j];
                ll sum_r = r[i] + r[j];
                if (dx * dx + dy * dy == sum_r * sum_r) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }

        memset(color, -1, sizeof(color));
        for (int i = 0; i < n; ++i) {
            if (color[i] == -1) {
                int cnt0 = 0, cnt1 = 0;
                isBipartite = true;
                dfs(i, 0, cnt0, cnt1);
                if (isBipartite && cnt0 != cnt1) {
                    cout << "YES" << endl;
                    return 0;
                }
            }
        }

        cout << "NO" << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入，构建相切圆盘的无向图（通过计算圆心距离平方与半径和平方是否相等）。然后遍历每个连通块，使用DFS进行二分图判定并统计两部分节点数。若存在一个连通块是二分图且两部分节点数不等，输出“YES”；否则输出“NO”。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者：江户川·萝卜**
* **亮点**：代码结构清晰，DFS函数中通过引用参数`cnt[w]`统计颜色数量，`f`变量标记是否为二分图，逻辑紧凑。
* **核心代码片段**：
    ```cpp
    void dfs(int p,int w){
        if(~vis[p]) return f&=(vis[p]==w),void();
        vis[p]=w,cnt[w]++;
        for(auto x:e[p]) dfs(x,!w);
    }
    ```
* **代码解读**：
    > 这段代码是DFS染色的核心。`vis[p]`记录节点`p`的颜色（-1未访问，0/1已染色）。若当前节点`p`已访问，检查颜色是否与预期`w`一致（不一致则`f`置为false）；若未访问，标记颜色并统计数量（`cnt[w]++`），然后递归处理邻接节点（颜色取反`!w`）。这一步确保了相邻节点颜色不同，实现二分图判定。
* 💡 **学习笔记**：DFS递归过程中通过引用传递统计变量（如`cnt`），可以方便地记录各颜色节点数，避免全局变量的使用。

**题解二：作者：WuMin4**
* **亮点**：代码简洁，通过`ans`变量提前终止无效遍历（若发现非二分图则跳过后续处理）。
* **核心代码片段**：
    ```cpp
    void dfs(int x,int c){
        col[x]=c,cc[c]++;
        for(int v:t[x]){
            if(col[v]==-1)
                dfs(v,c^1);
            else if(col[v]!=(c^1))
                ans=0;
        }
    }
    ```
* **代码解读**：
    > 这段代码中，`col[x]`记录节点颜色，`cc[c]`统计颜色`c`的节点数。对于邻接节点`v`，若未访问则递归染色（颜色取反`c^1`）；若已访问且颜色与预期不符（`col[v]!=(c^1)`），则标记`ans=0`（非二分图）。这种处理方式直接高效，符合竞赛代码简洁性要求。
* 💡 **学习笔记**：在DFS中通过全局变量（如`ans`）标记异常状态，可以提前终止无效计算，提升效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“二分图判定与半径调整”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素圆盘大冒险——寻找可调整的连通块`

  * **核心演示内容**：展示圆盘相切关系（边连接）、二分图染色过程（红/蓝交替标记）、节点数统计（数字显示），以及总半径和变化的计算。

  * **设计思路简述**：采用8位像素风（FC游戏画面风格）营造轻松氛围；圆盘用彩色像素块表示（如绿色），相切边用黄色线段连接；染色过程用红/蓝闪烁标记节点，音效提示关键操作（染色成功“叮”，冲突“咚”）；节点数统计用动态数字显示，总半径和变化用箭头（↓表示减少）提示。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧展示像素圆盘（绿色方块，中心坐标标注），右侧展示控制面板（开始/暂停、单步、重置按钮，速度滑块）。
          * 播放8位风格背景音乐（如《超级马里奥》经典旋律）。

    2.  **构建相切图**：
          * 遍历所有圆盘对，计算距离。若相切（距离平方=半径和平方），圆盘间出现黄色线段（边），伴随“连接”音效（短“滴”声）。

    3.  **二分图染色**：
          * 点击“开始”，从第一个未访问圆盘（绿色）开始，染成红色（颜色0），节点旁显示“减x”标签，`cnt0`加1。
          * 邻接圆盘自动染成蓝色（颜色1），显示“加x”标签，`cnt1`加1。
          * 若邻接圆盘已染色且颜色相同（如红色→红色），圆盘闪烁红色，播放“咚”音效，标记“非二分图”。

    4.  **节点数比较**：
          * 染色完成后，显示两颜色节点数（如`cnt0=3, cnt1=2`），总半径和变化计算为`(2-3)x=-x`（箭头↓），播放“胜利”音效（上扬音调）。

    5.  **结果展示**：
          * 若存在符合条件的连通块，屏幕中央显示“YES”，圆盘跳跃动画；否则显示“NO”，圆盘静止。

  * **旁白提示**：
      * （构建图时）“看！两个圆盘相切了，它们之间连了一条边～”
      * （染色时）“现在给这个圆盘染红色（减x），它的邻居必须染蓝色（加x）哦！”
      * （冲突时）“哎呀，这里颜色重复了，说明无法调整半径～”
      * （节点数不等时）“红色有3个，蓝色有2个，总半径和可以减小啦！”

<visualization_conclusion>
通过这样一个融合像素艺术和复古游戏元素的动画，我们不仅能清晰地看到二分图判定的过程，还能直观理解半径调整与节点数差异的关系，学习起来更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考图论中二分图判定的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 二分图判定不仅能解决本题，还常用于处理“分组矛盾”问题（如任务分配、颜色填充）、“关系对立”问题（如朋友/敌人划分）、“交替约束”问题（如棋盘覆盖）。关键是识别问题中的“必须不同”条件，并转化为图的边。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1155** - `双栈排序`
          * 🗣️ **推荐理由**：这道题需要将序列划分为两个栈，满足特定条件，可通过二分图判定解决，帮助巩固二分图建模思想。
    2.  **洛谷 P2825** - `[HEOI2016/TJOI2016]游戏`
          * 🗣️ **推荐理由**：此题涉及棋盘覆盖与二分图匹配，能拓展对二分图应用场景的理解。
    3.  **洛谷 P3386** - `【模板】二分图最大匹配`
          * 🗣️ **推荐理由**：通过此题可以学习二分图匹配的经典算法（如匈牙利算法），加深对图论核心概念的掌握。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“Disks”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解图论中二分图判定的应用和圆盘半径调整问题的解决思路。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：133.30秒
# 题目信息

# Restore Array

## 题目描述

在讨论 Codeforces Round 的合适 A 题时，Kostya 创建了一个循环正整数数组 $a_1, a_2, \ldots, a_n$。由于讨论时间很长且没有进展，Kostya 又创建了一个新的循环数组 $b_1, b_2, \ldots, b_n$，其中 $b_i = (a_i \bmod a_{i+1})$，这里 $a_{n+1} = a_1$。其中 $mod$ 表示[取模运算](https://en.wikipedia.org/wiki/Modulo_operation)。当讨论变得有趣时，Kostya 完全忘记了数组 $a$ 的样子。突然，他想到从数组 $b$ 恢复数组 $a$ 可能是一个有趣的问题（可惜不是 A 题）。

## 说明/提示

在第一个样例中：

- $1 \bmod 3 = 1$
- $3 \bmod 5 = 3$
- $5 \bmod 2 = 1$
- $2 \bmod 1 = 0$

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1 3 1 0
```

### 输出

```
YES
1 3 5 2
```

## 样例 #2

### 输入

```
2
4 4
```

### 输出

```
NO
```

# AI分析结果

# 💡 Kay的C++算法解析：Restore Array 深入学习指南 💡

<introduction>
今天我们来一起分析「Restore Array」这道C++编程题。题目要求从循环数组`b`恢复出原循环数组`a`，满足`b_i = a_i mod a_{i+1}`（`a_{n+1}=a_1`）。本指南将帮你梳理构造思路、理解核心技巧，并掌握解题的关键细节！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（构造法）

🗣️ **初步分析**：
解决这道题的关键是**构造法**——通过分析`b`数组的性质，直接“拼出”满足条件的`a`数组。构造法就像“搭积木”：我们先找到`b`中的“关键块”（最大值），再按照规则把其他块拼接起来，确保每一步都符合`mod`的要求。

在本题中，构造法的核心逻辑是：
1. **找最大值**：`b`中的最大值`M`是关键——因为`a_i mod a_{i+1}=M`只有当`a_i > a_{i+1}`且`a_{i+1}=M`时才可能成立（否则`mod`结果会小于`a_{i+1}`）。
2. **定起始点**：找到`b`中第一个等于`M`且前一个元素小于`M`的位置（记为`mxp`），把它作为构造`a`的“终点”（因为`a_{mxp}=M`）。
3. **递推构造**：从`mxp`往前，通过累加`b`的元素构造`a`，确保`a_i > a_{i+1}`且`b_i = a_i - a_{i+1}`（这样`a_i mod a_{i+1}=b_i`自然成立）。

**核心难点**：
- 如何处理特殊情况（如`b`全为0或全相同）？
- 如何保证构造的`a`满足循环条件（`a_n mod a_1 = b_n`）？

**可视化设计思路**：
我们会用8位像素风动画展示构造过程：
- 用不同颜色的像素块表示`b`数组（最大值块闪烁）；
- 从`mxp`开始，逐步向左“生长”`a`数组（每个像素块的大小对应`a_i`的值）；
- 关键操作（如找到最大值、累加计算）伴随“叮”“滴”的像素音效；
- 最终用“胜利烟花”动画展示构造完成的`a`数组。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：极寒神冰（赞：7）**
* **点评**：这份题解的思路堪称“精准打击”——直接抓住`b`的最大值作为构造突破口，逻辑链非常清晰。特殊情况处理（全0、全相同）考虑得很周到，代码中的`tp`函数（处理循环下标）和累加逻辑简洁高效。尤其是构造`a`的递推式（`a_i = sum(b_j from i to n-1) + 2*M`），巧妙避免了`mod`为0的情况，实践中可以直接用于竞赛。

**题解二：ethan0328（赞：0）**
* **点评**：思路与题解一一致，但代码可读性稍弱（比如数组平移的部分有点绕）。不过它补充了一个重要结论：当`b`全相同时，只有全0时有解——这一点对理解特殊情况很有帮助。此外，它用`sum + M`代替`2*M`的构造方式，也验证了构造法的灵活性。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
构造法的关键是“找规律+避坑”。结合题解，我总结了三个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何处理特殊情况？**
    * **分析**：当`b`全为0时，`a`可以是任意全1数组（因为1 mod 1=0）；当`b`全为非0数时，不可能有解（因为`a_i`必须是`b`的倍数，导致`a_i mod a_{i+1}=0≠b_i`）。
    * 💡 **学习笔记**：特殊情况要优先处理，避免后续构造出错。

2. **难点2：如何确定构造的起始点？**
    * **分析**：必须找到`b`中第一个等于最大值`M`且前一个元素小于`M`的位置`mxp`——这是因为`a_{mxp}=M`，而`a_{mxp-1} > M`（否则`b_{mxp-1}=a_{mxp-1} mod M`会等于`a_{mxp-1}`，但`b_{mxp-1}<M`）。
    * 💡 **学习笔记**：最大值的位置是构造的“锚点”，选对锚点才能保证后续递推正确。

3. **难点3：如何构造满足循环条件的`a`？**
    * **分析**：通过累加`b`的元素构造`a`（`a_i = a_{i+1} + b_i`），这样`a_i > a_{i+1}`且`b_i = a_i - a_{i+1}`，自然满足`a_i mod a_{i+1}=b_i`。最后通过循环下标处理，确保`a_n mod a_1 = b_n`。
    * 💡 **学习笔记**：递推式的设计要直接对应`mod`的性质，避免复杂计算。

### ✨ 解题技巧总结
- **技巧1：找关键特征**：遇到构造题，先找输入的“极值”或“特殊点”（如本题的最大值），作为构造的起点。
- **技巧2：递推式设计**：用简单的累加/递推代替复杂的计算，确保每一步都符合题目要求。
- **技巧3：边界处理**：循环数组的下标要注意“wrap around”（用`(x-1+n)%n`等方式处理）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的通用核心实现——它保留了题解一的简洁逻辑，同时优化了可读性：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一的构造思路，调整了变量名以提高可读性，适用于大多数测试用例。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    const int MAXN = 155555;
    int n, b[MAXN], a[MAXN];
    int mxv, mxp = -1;

    // 处理循环下标（1-based）
    inline int get_idx(int x) {
        return x < 1 ? x + n : x > n ? x - n : x;
    }

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) cin >> b[i];
        b[0] = b[n]; // 循环处理前一个元素

        // 找最大值及其位置
        mxv = *max_element(b + 1, b + n + 1);
        for (int i = 1; i <= n; ++i) {
            if (b[i] == mxv && b[i-1] != mxv) {
                mxp = i;
                break;
            }
        }

        // 处理特殊情况
        if (mxp == -1) {
            if (mxv == 0) {
                cout << "YES\n";
                for (int i = 1; i <= n; ++i) cout << 1 << " ";
            } else {
                cout << "NO";
            }
            return 0;
        }

        // 构造a数组：从mxp往前累加
        a[mxp] = mxv;
        for (int i = mxp - 1; i >= 1; --i) {
            int prev = get_idx(i + 1);
            a[i] = a[prev] + b[i];
        }
        // 处理循环部分（从n到mxp+1）
        for (int i = n; i > mxp; --i) {
            int prev = get_idx(i + 1);
            a[i] = a[prev] + b[i];
        }

        // 输出结果
        cout << "YES\n";
        for (int i = 1; i <= n; ++i) cout << a[i] << " ";
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为四部分：1. 输入并处理循环下标；2. 找最大值及其位置；3. 处理全0/全相同的特殊情况；4. 从最大值位置往前累加构造`a`数组。核心是`a[i] = a[i+1] + b[i]`的递推式，确保`a_i > a_{i+1}`且`b_i = a_i mod a_{i+1}`。

---

<code_intro_selected>
接下来剖析两个题解的核心片段，看看它们的“巧妙之处”：
</code_intro_selected>

**题解一：极寒神冰**
* **亮点**：用`tp`函数简化循环下标处理，累加逻辑更紧凑。
* **核心代码片段**：
    ```cpp
    a[tp((mxp-1+n)%n)] += mxv;
    R(i,1,n-1) a[tp((mxp-i+n)%n)] += a[tp((mxp-i+1+n)%n)];
    ```
* **代码解读**：
    > 这段代码是构造`a`的核心：首先把`mxp`前一个位置的`a`值加上`mxv`（避免`mod`为0），然后从`mxp`开始往前累加。`tp`函数把负数下标转换为循环下标（比如`mxp-1`可能为0，`tp(0)`返回`n`），确保数组不越界。
* 💡 **学习笔记**：用函数封装循环下标处理，能让代码更简洁。

**题解二：ethan0328**
* **亮点**：用数组平移处理最大值位置，验证了构造法的灵活性。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=mx;i++) a[i+n-mx]=b[i];
    for(int i=mx+1;i<=n;i++) a[i-mx]=b[i];
    a[n-1]+=a[n];
    for(int i=n-1;i;i--) a[i]+=a[i+1];
    ```
* **代码解读**：
    > 这段代码把`mx`位置的元素移到数组末尾（`a[n]`），然后从后往前累加。比如`mx=3`（n=4），则`a[1+4-3]=a[2] = b[1]`，`a[4-3]=a[1] = b[4]`——相当于把数组旋转，让最大值在末尾。
* 💡 **学习笔记**：数组旋转是处理循环结构的常用技巧。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到构造过程，我设计了一个**8位像素风动画**——《像素工程师的数组修复之旅》！
</visualization_intro>

### 🎮 动画演示主题
你扮演一位像素工程师，需要从`b`数组中找到“能量核心”（最大值），然后用它修复`a`数组。场景是复古的FC游戏界面，背景是像素化的电路板，`b`数组用彩色方块表示，`a`数组用逐渐变长的“能量条”表示。

### 🧩 核心演示内容
1. **场景初始化**：
   - 屏幕左侧显示`b`数组的像素块（每个块的颜色对应值大小，最大值块闪烁红光）；
   - 右侧是“构造区”，初始为空；
   - 底部控制面板有“开始/暂停”“单步”“重置”按钮，以及速度滑块。
2. **找能量核心**：
   - 游标从左到右扫描`b`数组，找到第一个闪烁的最大值块（`mxp`），伴随“叮”的音效；
   - 最大值块弹出“能量核心”的文字气泡。
3. **构造a数组**：
   - 从`mxp`开始，向右（循环）生成`a`的第一个块（大小等于`mxv`，蓝色）；
   - 向左移动游标，每个位置的`a`块大小是前一个块加上`b`的值（比如`a[i] = a[i+1] + b[i]`），伴随“滴”的音效；
   - 每生成一个`a`块，对应的`b`块会变绿，表示已处理。
4. **循环验证**：
   - 当所有`a`块生成后，循环检查`a_i mod a_{i+1} == b_i`，每个正确的块会闪烁黄光；
   - 全部正确后，播放“胜利”音效，屏幕弹出“修复成功！”的像素文字。

### 🎵 音效设计
- **扫描`b`数组**：轻快的“哔哔”声；
- **找到最大值**：清脆的“叮”声；
- **构造`a`块**：短促的“滴”声；
- **验证正确**：柔和的“嗡”声；
- **胜利**：上扬的“叮铃叮铃”声。

### 🎮 交互设计
- **单步模式**：点击“单步”按钮，每一步只生成一个`a`块；
- **自动模式**：拖动速度滑块调整动画速度（最慢1秒/步，最快0.1秒/步）；
- **重置**：恢复初始状态，重新开始演示。

<visualization_conclusion>
这个动画用游戏化的方式把抽象的构造过程变成了“修电路”的任务——你能清晰看到最大值如何作为“核心”，一步步“生长”出整个`a`数组。像素风格和音效让学习更轻松，也能帮你记住构造的关键步骤！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
构造法是编程中的“万能砖”，很多问题都可以用它解决。比如：
</similar_problems_intro>

### 🔄 通用思路迁移
- **场景1**：根据某种规则生成满足条件的序列（如本题的`a`数组）；
- **场景2**：修复损坏的数据（如从部分信息恢复完整数组）；
- **场景3**：构造满足数学条件的解（如构造一个序列，使得相邻元素的差等于给定值）。

### 📚 洛谷练习推荐
1. **洛谷 P1115 最大子段和**
   - 🗣️ **推荐理由**：需要构造子段和的最大值，锻炼递推构造的思路。
2. **洛谷 P2670 扫雷游戏**
   - 🗣️ **推荐理由**：根据周围地雷数构造雷区，类似本题的“从结果推原因”。
3. **洛谷 P3392 涂国旗**
   - 🗣️ **推荐理由**：构造满足条件的颜色排列，锻炼边界处理和构造逻辑。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的两个经验非常值得借鉴：
</insights_intro>

> **经验1（来自极寒神冰）**：“用`2*M`代替`M`可以避免`a_n mod a_1=0`的情况。”
> **点评**：这是一个“小技巧大作用”的例子——通过微小的调整，就能避开构造中的“坑”。遇到类似问题时，可以尝试给关键值加一个“安全垫”（比如`M+1`或`2*M`）。

> **经验2（来自ethan0328）**：“当`b`全相同时，只有全0时有解。”
> **点评**：这个结论帮我们快速处理特殊情况，避免不必要的构造。遇到循环数组问题时，要先考虑“全相同”的极端情况。


<conclusion>
本次关于「Restore Array」的分析就到这里！构造法的关键是“找规律+敢尝试”——先观察输入的特征，再设计简单的递推式，最后处理边界情况。希望这份指南能帮你掌握构造法的核心，下次遇到类似问题时，能快速想到“搭积木”的思路！💪
</conclusion>

---
处理用时：85.67秒
# 题目信息

# Beautiful Mirrors

## 题目描述

Creatnx has $ n $ mirrors, numbered from $ 1 $ to $ n $ . Every day, Creatnx asks exactly one mirror "Am I beautiful?". The $ i $ -th mirror will tell Creatnx that he is beautiful with probability $ \frac{p_i}{100} $ for all $ 1 \le i \le n $ .

Creatnx asks the mirrors one by one, starting from the $ 1 $ -st mirror. Every day, if he asks $ i $ -th mirror, there are two possibilities:

- The $ i $ -th mirror tells Creatnx that he is beautiful. In this case, if $ i = n $ Creatnx will stop and become happy, otherwise he will continue asking the $ i+1 $ -th mirror next day;
- In the other case, Creatnx will feel upset. The next day, Creatnx will start asking from the $ 1 $ -st mirror again.

You need to calculate [the expected number](https://en.wikipedia.org/wiki/Expected_value) of days until Creatnx becomes happy.

This number should be found by modulo $ 998244353 $ . Formally, let $ M = 998244353 $ . It can be shown that the answer can be expressed as an irreducible fraction $ \frac{p}{q} $ , where $ p $ and $ q $ are integers and $ q \not \equiv 0 \pmod{M} $ . Output the integer equal to $ p \cdot q^{-1} \bmod M $ . In other words, output such an integer $ x $ that $ 0 \le x < M $ and $ x \cdot q \equiv p \pmod{M} $ .

## 说明/提示

In the first test, there is only one mirror and it tells, that Creatnx is beautiful with probability $ \frac{1}{2} $ . So, the expected number of days until Creatnx becomes happy is $ 2 $ .

## 样例 #1

### 输入

```
1
50
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
10 20 50
```

### 输出

```
112
```

# AI分析结果

# 💡 Kay的C++算法解析：Beautiful Mirrors 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：期望动态规划（DP）

🗣️ **初步分析**：  
解决「Beautiful Mirrors」的关键是理解**期望DP**——它像计算“平均要走多少步才能通关一款闯关游戏”：你需要依次通过n个关卡（镜子），每个关卡成功概率是`p_i%`，成功则进下一关，失败则回到第1关重新开始。我们要算“通关”的**平均天数**（期望）。  

### 核心算法思路与难点
所有题解的核心都是**通过状态定义和代数化简，将循环依赖的期望方程转化为线性递推**：  
- **状态定义**：常见两种方式：  
  1. 正向：`f[i]`表示“从第1关到第i关都成功”的期望天数（如万弘、ADay的题解）；  
  2. 反向：`dp[i]`表示“从第i关到第n关成功”的期望天数（如_jimmywang_的题解）。  
- **关键难点**：状态转移方程会出现**循环依赖**（比如`dp[i]`依赖`dp[1]`），需要通过代数变形消去循环，得到递推式（如`f[i] = (f[i-1]+1)*100/p[i]`）。  
- **模运算处理**：因为结果要对998244353取模，除法需用**费马小定理求逆元**（`a/b mod MOD = a * b^(MOD-2) mod MOD`）。

### 可视化设计思路
我们用**复古FC游戏风格**做动画：  
- 屏幕左侧是`1~n`号镜子（像素方块，编号用8位字体），右侧是“期望计数器”（显示当前累计期望）；  
- 当前询问的镜子用**闪烁的黄色**高亮，成功时播放“叮”的音效，方块变成绿色并跳转到下一个；失败时播放“嗤”的音效，方块变红并跳回第1个；  
- 支持“单步执行”（看每一步的期望变化）和“自动播放”（加速展示循环过程），通关时弹出“胜利”动画+上扬音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁度、优化程度三个维度筛选了以下5个优质题解（评分≥4星），覆盖了不同的推导角度和实现技巧：
</eval_intro>

### 题解一：万弘（正向递推，最简思路）
* **点评**：  
  这个题解的思路像“搭积木”——从第1关到第n关，每一步的期望都基于前一步的结果。作者通过**正向状态定义**（`f[i]`表示到第i关的期望），直接推导出递推式`f[i] = (f[i-1]+1)*100/p[i]`，逻辑直白到“一看就懂”。代码只有10行左右，变量名`f[i]`含义明确，逆元计算用费马小定理，边界处理（`f[0]=0`）严谨，是**入门首选**。

### 题解二：ADay（一行递推，极致简洁）
* **点评**：  
  作者把递推式压缩到了“边读入边计算”的程度——用一个变量`ans`保存当前期望，每读入一个`p[i]`，就更新`ans = 100*(ans+1)*inv(p[i]) mod MOD`。这种实现**不需要额外数组**，空间复杂度O(1)，代码长度甚至比题解一更短！核心是抓住了递推式的“累加性”，把每一步的计算简化到极致。

### 题解三：木木！（预处理逆元，优化常数）
* **点评**：  
  这个题解的亮点是**预处理1~100的逆元**——因为`p[i]`是百分比（1~100），所以提前算好`inv[1]~inv[100]`，之后直接查表，避免了每次计算逆元的log时间。这种优化虽然不影响时间复杂度（还是O(n)），但**实际运行更快**（数组访问比快速幂快），适合对常数敏感的竞赛场景。

### 题解四：Computer1828（分式推导，数学本质）
* **点评**：  
  作者从反向状态`f[i]`出发，通过代数变形得到了最终的分式形式：`f[1] = (1 + p1 + p1p2 + ... + p1p2...p(n-1)) / (p1p2...pn)`。这种推导揭示了期望的**数学本质**——分子是“所有可能的失败路径的天数和”，分母是“一次通关的概率”。代码中用前缀积计算分子分母，逻辑严谨，适合想深入理解期望来源的同学。

### 题解五：TheShadow（线性变换，通用方法）
* **点评**：  
  作者用了期望DP的**通用技巧**——将`E(i)`表示为`a*E(1)+b`（线性变换），通过递推`a`和`b`，最后解方程`a*E(1)+b=0`得到结果。这种方法适用于**所有存在循环依赖的期望问题**，比如“自环”或“回到起点”的情况，是进阶学习者必须掌握的通用工具。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决期望DP问题的关键是“拆状态、消循环、处理模”，以下是三个核心难点及应对策略：
</difficulty_intro>

### 1. 状态定义：正向还是反向？
* **难点**：选不对状态会导致推导复杂（比如反向状态`dp[i]`会依赖`dp[1]`，需要更多变形）。  
* **策略**：优先选**正向状态**（如`f[i]`表示到第i关的期望），因为它的递推式更直观——每一步只依赖前一步的结果，不需要处理循环。  
* 💡 **学习笔记**：状态定义的核心是“覆盖所有子问题”，正向状态更符合“从易到难”的解题逻辑。

### 2. 递推式化简：如何消去循环依赖？
* **难点**：反向状态`dp[i]`的方程会包含`dp[1]`（比如`dp[i] = p[i]dp[i+1] + (1-p[i])dp[1] +1`），形成循环。  
* **策略**：通过**代数变形**将循环变量消去——比如从`dp[1]`开始递推，逐步将`dp[2]`、`dp[3]`用`dp[1]`表示，最后利用`dp[n+1]=0`解方程。  
* 💡 **学习笔记**：循环依赖的本质是“状态之间互相引用”，用代数变形把“未知量”集中到一侧，就能解出结果。

### 3. 模运算：除法如何处理？
* **难点**：题目要求结果对998244353取模，而期望计算中需要除以`p[i]`（概率），但模运算中没有除法。  
* **策略**：用**费马小定理求逆元**——因为998244353是质数，所以`a的逆元= a^(MOD-2) mod MOD`。例如，`100/p[i] mod MOD = 100 * inv(p[i]) mod MOD`，其中`inv(p[i])=qpow(p[i], MOD-2)`。  
* 💡 **学习笔记**：模运算中的除法=乘以逆元，这是竞赛中处理分数模的标准方法。

### ✨ 解题技巧总结
- **技巧1：优先正向状态**：正向状态的递推式更简单，适合入门。  
- **技巧2：预处理小范围逆元**：如果`p[i]`的范围小（比如1~100），提前算好逆元能加速代码。  
- **技巧3：边读边算**：不需要存储所有`p[i]`，读一个算一个，节省空间。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个**通用核心实现**（基于万弘的题解，思路最清晰），再分析几个优质题解的亮点片段。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自万弘的题解，是正向递推的典型实现，逻辑清晰，适合入门。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;

  typedef long long LL;
  const int MOD = 998244353;
  const int MAXN = 2e5 + 10;

  LL qpow(LL a, LL b) { // 快速幂求逆元
      LL res = 1;
      for (; b; b >>= 1) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
      }
      return res;
  }

  int main() {
      int n;
      cin >> n;
      LL f = 0; // f[0] = 0，到第0关（还没开始）的期望天数
      for (int i = 1; i <= n; ++i) {
          LL p;
          cin >> p;
          LL inv_p = qpow(p, MOD - 2); // 求p的逆元
          f = (f + 1) * 100 % MOD; // (f[i-1]+1)*100
          f = f * inv_p % MOD;     // 除以p（乘以逆元）
      }
      cout << f << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 输入n，初始化`f=0`（还没开始的期望天数是0）；  
  2. 循环读入每个镜子的概率`p`；  
  3. 计算`(f+1)*100`：`f+1`是“到前一关的期望+当前天”，乘以100是因为`p`是百分比（需要转成概率`p/100`）；  
  4. 乘以`inv_p`：相当于除以`p`，得到到当前关的期望`f[i]`；  
  5. 输出最终的`f`（到第n关的期望）。

<code_intro_selected>
接下来分析几个优质题解的亮点片段：
</code_intro_selected>

### 题解二：ADay（一行递推）
* **亮点**：不用数组，边读边算，极致简洁。
* **核心代码片段**：
  ```cpp
  int ans = 0;
  for (int i = 1; i <= n; ++i) {
      int x;
      scanf("%d", &x);
      ans = 1LL * (ans + 1) * 100 % MOD;
      ans = 1LL * ans * inv(x) % MOD; // inv(x)是x的逆元
  }
  ```
* **代码解读**：  
  作者用`ans`直接保存当前的期望——每读一个`x`（`p[i]`），就更新`ans`为`(ans+1)*100/ x`。这种写法**省去了数组存储**，空间复杂度从O(n)降到O(1)，非常高效。  
* 💡 **学习笔记**：如果递推式只依赖前一步的结果，就可以用“滚动变量”代替数组。

### 题解三：木木！（预处理逆元）
* **亮点**：预处理1~100的逆元，避免重复计算。
* **核心代码片段**：
  ```cpp
  int invi[105];
  invi[1] = 100; // 1的逆元是1，乘以100（因为p是百分比）
  for (int i = 2; i <= 100; ++i) {
      invi[i] = 1LL * (MOD - MOD / i) * invi[MOD % i] % MOD;
  }
  // 递推时直接用invi[p]
  fi = 1LL * (fi + 1) * invi[getint()] % MOD;
  ```
* **代码解读**：  
  因为`p[i]`是1~100的整数，所以提前用**递推法**（不是快速幂）计算`invi[1]~invi[100]`。递推式`invi[i] = (MOD - MOD/i) * invi[MOD%i] % MOD`是求逆元的**线性递推法**，比快速幂更快（O(100) vs O(log MOD)）。  
* 💡 **学习笔记**：如果除数的范围小，预处理逆元能显著提升速度。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“期望是如何累加的”，我设计了一个**FC风格的像素动画**，像玩《超级马里奥》一样看算法运行！
</visualization_intro>

### 动画演示主题：《镜子闯关大冒险》
- **风格**：8位像素风（参考《魂斗罗》的画面），用红、绿、黄三色区分镜子状态（红：失败，绿：成功，黄：当前询问）。
- **核心演示内容**：展示从第1个镜子到第n个镜子的闯关过程，以及期望天数的累计。

### 动画帧步骤与交互设计
1. **初始化场景**：  
   - 屏幕左侧显示`1~n`号镜子（每个镜子是3x3的像素方块，编号用8位字体）；  
   - 屏幕右侧显示“期望计数器”（初始为0）；  
   - 底部控制面板有“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（1x~5x）。

2. **闯关过程演示**：  
   - **当前镜子**：用黄色闪烁高亮（比如第1个镜子）；  
   - **成功场景**：播放“叮”的音效，镜子变成绿色，跳转到下一个镜子（第2个），期望计数器增加`(当前期望+1)*100/p[i]`；  
   - **失败场景**：播放“嗤”的音效，镜子变成红色，跳回第1个镜子，期望计数器增加“当前天数+重新开始的期望”；  
   - **自动播放**：像“AI玩游戏”一样，快速展示多次循环，直到通关，最后显示总期望。

3. **游戏化元素**：  
   - **关卡奖励**：每通过一个镜子，弹出“+1关”的像素提示；  
   - **胜利动画**：通关时，所有镜子变成绿色，播放“胜利”音效（类似《超级马里奥》的通关音乐），并显示总期望；  
   - **失败提示**：如果连续失败3次，弹出“再试一次！”的提示框。

### 设计理由
- 像素风格让学习者有“玩游戏”的感觉，降低畏难情绪；  
- 颜色和音效强化“成功/失败”的反馈，帮助记住关键步骤；  
- 单步执行让学习者能“慢动作”看期望的计算过程，理解每一步的变化。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
期望DP的核心是“将复杂的期望拆成子问题的期望”，以下是几个相似问题和练习推荐：
</similar_problems_intro>

### 通用思路迁移
期望DP常用于解决**“有状态转移、存在循环”的概率问题**，比如：  
1. 抛硬币直到连续k次正面的期望次数；  
2. 迷宫中随机走，到达终点的期望步数；  
3. 卡牌游戏中抽到某张牌的期望次数。

### 练习推荐 (洛谷)
1. **洛谷 P1654 OSU!**  
   🗣️ **推荐理由**：这是期望DP的经典题，需要处理“平方期望”的递推，帮助你理解“期望的线性性质”。  
2. **洛谷 P2473 [SCOI2008] 奖励关**  
   🗣️ **推荐理由**：题目涉及“状态压缩”和“期望递推”，需要处理“选择物品”的期望，是进阶练习。  
3. **洛谷 P3802 小魔女帕琪**  
   🗣️ **推荐理由**：题目是“连续选择”的期望问题，需要推导分式形式的期望，类似本题的数学本质。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是几个题解作者的经验分享，非常有参考价值：
</insights_intro>

> **参考经验（来自木木！）**：“预处理1~100的逆元能加速代码，因为数组访问比快速幂快很多。”  
> **点评**：这个经验提醒我们——**常数优化在竞赛中很重要**，尤其是当数据量很大时（比如n=2e5），预处理能节省大量时间。

> **参考经验（来自ADay）**：“边读边算能节省空间，不需要存储所有输入。”  
> **点评**：这个技巧适用于所有“递推式只依赖前一步”的问题，比如斐波那契数列、累加和等，能把空间复杂度从O(n)降到O(1)。


## 结语
本次关于「Beautiful Mirrors」的分析就到这里～ 期望DP的核心是“拆分子问题+代数变形”，只要掌握了状态定义和逆元处理，这类题就能迎刃而解。记住：**编程的本质是“把复杂问题拆成简单步骤”**，多练几道相似题，你会越来越熟练！💪

---
处理用时：94.42秒
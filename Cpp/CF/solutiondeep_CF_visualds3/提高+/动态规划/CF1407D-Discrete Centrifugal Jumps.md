# 题目信息

# Discrete Centrifugal Jumps

## 题目描述

There are $ n $ beautiful skyscrapers in New York, the height of the $ i $ -th one is $ h_i $ . Today some villains have set on fire first $ n - 1 $ of them, and now the only safety building is $ n $ -th skyscraper.

Let's call a jump from $ i $ -th skyscraper to $ j $ -th ( $ i < j $ ) discrete, if all skyscrapers between are strictly lower or higher than both of them. Formally, jump is discrete, if $ i < j $ and one of the following conditions satisfied:

- $ i + 1 = j $
- $ \max(h_{i + 1}, \ldots, h_{j - 1}) < \min(h_i, h_j) $
- $ \max(h_i, h_j) < \min(h_{i + 1}, \ldots, h_{j - 1}) $ .

At the moment, Vasya is staying on the first skyscraper and wants to live a little longer, so his goal is to reach $ n $ -th skyscraper with minimal count of discrete jumps. Help him with calcualting this number.

## 说明/提示

In the first testcase, Vasya can jump in the following way: $ 1 \rightarrow 2 \rightarrow 4 \rightarrow 5 $ .

In the second and third testcases, we can reach last skyscraper in one jump.

Sequence of jumps in the fourth testcase: $ 1 \rightarrow 3 \rightarrow 5 $ .

## 样例 #1

### 输入

```
5
1 3 1 4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
4
4 2 2 4```

### 输出

```
1```

## 样例 #3

### 输入

```
2
1 1```

### 输出

```
1```

## 样例 #4

### 输入

```
5
100 1 100 1 100```

### 输出

```
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：Discrete Centrifugal Jumps 深入学习指南 💡

<introduction>
今天我们来挑战一道有趣的"跳大楼"问题——Discrete Centrifugal Jumps！你需要从第1栋楼跳到第n栋楼，求最少步数。这道题的核心是**动态规划（DP）+单调栈**的组合技，咱们一起拆解它～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 单调栈应用  

🗣️ **初步分析**：  
解决这道题的关键，就像"记步数+找捷径"——  
- **DP**：用`dp[i]`记录从第1栋楼跳到第i栋楼的**最少步数**（比如`dp[5]`就是到第5楼的最少跳数）。  
- **单调栈**：像一个"智能筛选器"，帮我们快速找到**能直接跳到当前楼的前一栋楼**（不用逐个检查所有前面的楼，省时间！）。  

举个例子：如果当前在第5楼（高度5），单调栈能立刻告诉我们：前一个比5高的楼是第4楼（高度4？不对，比如样例1中第4楼是4，第5楼是5，那前一个比5高的没有？哦样例1的跳跃是1→2→4→5，所以第4楼能跳到第5楼是因为相邻）。其实，单调栈的作用是**维护最近的"极值点"**——比如最近的比当前高的楼、最近的比当前低的楼，这些点都是能"直接跳"的候选。  

**核心算法流程**：  
1. 初始化`dp[1] = 0`（第1楼不用跳）。  
2. 用两个单调栈：`stk_max`维护**递增序列**（找最近的比当前高的楼），`stk_min`维护**递减序列**（找最近的比当前低的楼）。  
3. 遍历每栋楼i（从2到n）：  
   - 先更新`dp[i] = dp[i-1] + 1`（相邻跳，最基础的情况）。  
   - 用单调栈找能跳到i的前一栋楼j，更新`dp[i] = min(dp[i], dp[j] + 1)`。  
   - 把i加入两个栈，保持栈的单调性。  

**可视化设计思路**：  
我们用**8位像素风**模拟跳楼过程——  
- 大楼：用不同高度的彩色像素块表示（比如高度1是1格，高度5是5格），第1楼是红色，第n楼是金色。  
- 单调栈：在屏幕右侧用堆叠的方块展示（比如`stk_max`是蓝色，`stk_min`是绿色），每次弹栈/入栈时方块会"跳"一下。  
- 跳跃动画：从j跳到i时，j的方块会闪烁，然后一道"像素光束"连接j和i，i的方块变亮，伴随"叮"的音效～  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，咱们一起看看它们的亮点～
</eval_intro>

**题解一：作者zhoukangyang（赞26）**  
* **点评**：这份题解的思路像"精准打击"——用两个单调栈分别处理"中间都小"和"中间都大"的情况，代码简洁到只有30行！作者特别注意了**相等情况的处理**（比如`if(s[i] != s[a[atot]])`），避免了错误转移。比如样例2中两栋楼高度都是2，不能用条件2/3跳，但相邻跳是可以的？不，样例2的输出是1，因为中间两栋楼都是2，满足条件2（max(2,2) < min(4,4)？不对，样例2输入是4 2 2 4，所以从1跳到4，中间的2、2都比4小，符合条件2，所以步数是1。这份题解的代码完美处理了这种情况，因为当`s[i] == s[a[atot]]`时不更新dp，避免了无效转移。  

**题解二：作者封禁用户（赞13）**  
* **点评**：这份题解的**前置知识讲解**很友好，明确提到了单调栈的作用——找"最后一个大于/小于当前的下标"。状态转移方程`dp[i] = min(dp[i-1], dp[x], dp[y]) + 1`（x是前一个大的，y是前一个小的）非常清晰。代码里的快速读入函数也值得学习，能处理大数据量的输入。  

**题解三：作者引领天下（赞2）**  
* **点评**：这份题解的亮点是**强调单调栈的严格性**——比如维护单调递增栈时，必须是"严格递增"（不能非减），否则会出错。作者还特别注释了"如果弹出的元素等于当前值，不能更新"，这是很多初学者会踩的坑！比如样例3中两栋楼高度都是1，只能相邻跳，这份题解的代码会正确处理（因为弹出时`last == a[i]`，所以不更新）。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点主要在"如何高效找转移点"和"处理边界情况"，咱们逐一拆解～
</difficulty_intro>

1. **关键点1：如何定义DP状态？**  
   - **分析**：`dp[i]`必须表示"到第i楼的最少步数"，这样才能通过前一步的状态推导当前状态。比如`dp[i]`可以从`dp[i-1]`（相邻跳）、`dp[j]`（j是能直接跳到i的楼）转移而来。  
   - 💡 **学习笔记**：DP状态要"精准覆盖子问题"，比如这里的子问题就是"到每栋楼的最少步数"。  

2. **关键点2：如何用单调栈找转移点？**  
   - **分析**：单调栈的作用是**维护最近的极值点**。比如，对于"中间都小"的情况（条件2），我们需要找前一个比当前楼高的楼j——因为j到i之间的楼都比j和i矮，所以能直接跳。单调栈能快速找到这个j，不用遍历所有前面的楼。  
   - 💡 **学习笔记**：单调栈是"空间换时间"的神器，能把O(n²)的时间复杂度降到O(n)。  

3. **关键点3：如何处理相等的情况？**  
   - **分析**：题目中的条件要求"严格大于"或"严格小于"，所以当两个楼高度相等时，不能用条件2或3转移。比如样例3中两栋楼都是1，只能用相邻跳（条件1）。所有优质题解都处理了这个情况（比如`if(s[i] != s[a[atot]])`）。  
   - 💡 **学习笔记**：边界情况是"坑点"，一定要仔细读题中的"严格"二字！  

### ✨ 解题技巧总结
- **技巧A：组合拳**：DP负责记录状态，单调栈负责优化转移，两者结合能解决很多"找最近极值点+最优解"的问题。  
- **技巧B：分情况处理**：把条件2和3拆分成两个单调栈，分别处理"中间小"和"中间大"的情况，逻辑更清晰。  
- **技巧C：测试边界**：比如样例3（两栋楼相等）、样例2（中间相等），一定要测试这些情况，避免代码出错。  


## 4. C++核心代码实现赏析

<code_intro_overall>
咱们先看一份**综合优质题解的通用核心代码**，它包含了所有关键逻辑～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了zhoukangyang、封禁用户、引领天下的题解思路，代码简洁高效，处理了所有边界情况。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int N = 3e5 + 7;
  int h[N], dp[N];

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);

      int n;
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          cin >> h[i];
      }

      vector<int> stk_max, stk_min;
      dp[1] = 0;
      stk_max.push_back(1);
      stk_min.push_back(1);

      for (int i = 2; i <= n; ++i) {
          dp[i] = dp[i-1] + 1; // 条件1：相邻跳

          // 处理条件2：中间都比两边小（找前一个比当前大的）
          while (!stk_max.empty() && h[i] >= h[stk_max.back()]) {
              if (h[i] != h[stk_max.back()]) {
                  dp[i] = min(dp[i], dp[stk_max[stk_max.size()-2]] + 1);
              }
              stk_max.pop_back();
          }
          if (!stk_max.empty()) {
              dp[i] = min(dp[i], dp[stk_max.back()] + 1);
          }
          stk_max.push_back(i);

          // 处理条件3：中间都比两边大（找前一个比当前小的）
          while (!stk_min.empty() && h[i] <= h[stk_min.back()]) {
              if (h[i] != h[stk_min.back()]) {
                  dp[i] = min(dp[i], dp[stk_min[stk_min.size()-2]] + 1);
              }
              stk_min.pop_back();
          }
          if (!stk_min.empty()) {
              dp[i] = min(dp[i], dp[stk_min.back()] + 1);
          }
          stk_min.push_back(i);
      }

      cout << dp[n] << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 输入处理：用`ios::sync_with_stdio(false)`加速输入。  
  2. 初始化：`dp[1] = 0`，两个栈分别加入第1栋楼。  
  3. 遍历每栋楼i：  
     - 先处理相邻跳（条件1）。  
     - 用`stk_max`找前一个比i高的楼，更新dp[i]。  
     - 用`stk_min`找前一个比i低的楼，更新dp[i]。  
     - 把i加入两个栈，保持单调性。  
  4. 输出`dp[n]`（到第n栋楼的最少步数）。  

---

<code_intro_selected>
咱们再看**题解一（zhoukangyang）**的核心片段，学习它的简洁性～
</code_intro_selected>

**题解一：作者zhoukangyang**
* **亮点**：用数组模拟栈，代码更简洁，处理相等情况的逻辑很巧妙。
* **核心代码片段**：
  ```cpp
  int a[++atot] = 1, b[++btot] = 1, dp[1] = 0;
  for(int i = 2; i <= n; i++) {
      dp[i] = dp[i - 1] + 1;
      while(atot && s[i] >= s[a[atot]]) {
          if(s[i] != s[a[atot]]) dp[i] = min(dp[i], dp[a[atot - 1]] + 1);
          --atot;
      }
      while(btot && s[i] <= s[b[btot]]) {
          if(s[i] != s[b[btot]]) dp[i] = min(dp[i], dp[b[btot - 1]] + 1);
          --btot;
      }
      a[++atot] = i, b[++btot] = i;
  }
  ```
* **代码解读**：  
  - 用`a`数组模拟`stk_max`（递增栈），`b`数组模拟`stk_min`（递减栈）。  
  - 当`s[i] >= s[a[atot]]`时，弹栈并更新dp[i]——因为此时a[atot]是前一个比i小或等于的楼，而a[atot-1]是前一个比i大的楼，能直接跳到i。  
  - 最后把i加入栈，保持单调性。  
* 💡 **学习笔记**：用数组模拟栈比`std::stack`更快，适合大数据量的题目！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
咱们用**8位红白机风格**做一个跳楼动画，让算法"动起来"！
</visualization_intro>

### **动画演示主题**：像素探险家跳大楼  
**设计思路**：用FC游戏的风格（低分辨率、鲜艳色彩）模拟跳楼过程，加入音效和"过关"概念，让学习更有趣～

### **核心演示内容**：  
1. **场景初始化**：  
   - 屏幕左侧是**大楼区**：用不同高度的彩色像素块表示楼（比如高度1是1格红色，高度5是5格蓝色），第1楼是红色，第n楼是金色。  
   - 屏幕右侧是**栈区**：用蓝色方块表示`stk_max`，绿色方块表示`stk_min`，堆叠展示当前栈中的元素。  
   - 屏幕下方是**控制面板**：有"单步执行"、"自动播放"、"重置"按钮，还有速度滑块。  

2. **算法执行步骤**：  
   - **步骤1**：初始化`dp[1] = 0`，红色方块（第1楼）闪烁，栈区加入蓝色和绿色方块（代表第1楼）。  
   - **步骤2**：处理第2楼（比如样例1中的高度3）：  
     - 先显示相邻跳：第1楼的红色方块发出光束到第2楼，第2楼的方块变亮，`dp[2] = 1`。  
     - 然后用`stk_max`找前一个比3大的楼（没有，所以栈区加入蓝色方块）。  
     - 用`stk_min`找前一个比3小的楼（第1楼，高度1），所以`dp[2] = min(1, dp[1]+1) = 1`，绿色方块闪烁。  
   - **步骤3**：处理第3楼（样例1中的高度1）：  
     - 相邻跳：`dp[3] = dp[2]+1 = 2`。  
     - `stk_max`弹栈（因为1 < 3），更新`dp[3] = min(2, dp[1]+1) = 1`，蓝色方块弹栈动画。  
     - `stk_min`加入绿色方块（1比3小）。  
   - **步骤4**：直到处理到第n楼（金色方块），播放"胜利"音效（上扬的8位音乐），显示总步数。  

3. **交互设计**：  
   - **单步执行**：点击一次按钮，执行一步算法，显示当前步骤的代码片段（比如`dp[i] = dp[i-1]+1`）。  
   - **自动播放**：可以调整速度（慢/中/快），算法自动执行，每步伴随音效。  
   - **重置**：恢复初始状态，重新开始。  

4. **音效设计**：  
   - 相邻跳："嗒"的轻响。  
   - 单调栈弹栈/入栈："叮"的脆响。  
   - 找到更优解："嗡"的提示音。  
   - 胜利："滴-哒-滴"的上扬音乐。  

### **为什么这么设计？**  
- 像素风格：复古游戏的感觉，让学习更轻松。  
- 音效：强化关键操作的记忆（比如弹栈时的"叮"声，会让你记住单调栈的作用）。  
- 可视化栈：让你"看到"单调栈的变化，理解它如何筛选转移点。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的"DP+单调栈"思路能解决很多类似问题，咱们拓展一下～
</similar_problems_intro>

### **通用思路迁移**：  
"DP+单调栈"的组合常用于**找最近极值点+最优解**的问题，比如：  
1. **最大矩形面积**：用单调栈找每个柱子的左右边界，计算最大面积。  
2. **最长递增子序列**：用单调栈优化DP，降低时间复杂度。  
3. **接雨水**：用单调栈找每个柱子的左右更高柱子，计算雨水量。  

### **洛谷练习推荐**：  
1. **洛谷 P1090** - 合并果子  
   - 🗣️ **推荐理由**：用单调队列优化DP，练习"找最优子结构"的思路。  
2. **洛谷 P1886** - 滑动窗口  
   - 🗣️ **推荐理由**：用单调队列维护滑动窗口的最大值/最小值，练习单调数据结构的应用。  
3. **洛谷 P2900** - Land Acquisition  
   - 🗣️ **推荐理由**：用单调栈优化DP，解决"区间合并"的问题，深化对DP+单调栈的理解。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
咱们从题解中提炼一些"踩坑经验"，避免以后犯错～
</insights_intro>

> **参考经验（来自引领天下）**："我这个屑就因为单调栈不是严格递增吃了不少罚时！"  
> **点评**：单调栈的"严格性"很重要！比如维护递增栈时，如果允许相等，会导致找到的转移点不符合"严格大于"的条件，从而出错。以后写单调栈时，一定要明确是"严格递增"还是"非递减"。  

> **参考经验（来自zhoukangyang）**："写了100行的线段树+ST表，结果发现只要俩单调栈就好了！"  
> **点评**：不要一开始就用复杂的数据结构，先分析问题的核心——这道题的关键是"找最近极值点"，而单调栈正好能高效解决这个问题，比线段树更简单。  


<conclusion>
这道题的核心是"DP记录状态+单调栈优化转移"，掌握了这个组合，很多类似的问题都能迎刃而解！记住：**DP是"记步数"，单调栈是"找捷径"，两者结合就是"最快的路"**～  
下次遇到"找最近极值点+最优解"的问题，不妨试试这个组合技！💪
</conclusion>

---

---
处理用时：92.38秒
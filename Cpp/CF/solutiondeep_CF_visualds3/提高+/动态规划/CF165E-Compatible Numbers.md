# 题目信息

# Compatible Numbers

## 题目描述

Two integers $ x $ and $ y $ are compatible, if the result of their bitwise "AND" equals zero, that is, $ a $ $ & $ $ b=0 $ . For example, numbers $ 90 $ $ (1011010_{2}) $ and $ 36 $ $ (100100_{2}) $ are compatible, as $ 1011010_{2} $ $ & $ $ 100100_{2}=0_{2} $ , and numbers $ 3 $ $ (11_{2}) $ and $ 6 $ $ (110_{2}) $ are not compatible, as $ 11_{2} $ $ & $ $ 110_{2}=10_{2} $ .

You are given an array of integers $ a_{1},a_{2},...,a_{n} $ . Your task is to find the following for each array element: is this element compatible with some other element from the given array? If the answer to this question is positive, then you also should find any suitable element.

## 样例 #1

### 输入

```
2
90 36
```

### 输出

```
36 90```

## 样例 #2

### 输入

```
4
3 6 3 6
```

### 输出

```
-1 -1 -1 -1```

## 样例 #3

### 输入

```
5
10 6 9 8 2
```

### 输出

```
-1 8 2 2 8```

# AI分析结果

# 💡 Kay的C++算法解析：Compatible Numbers 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：高维前缀和（子集枚举优化）

🗣️ **初步分析**：  
解决“Compatible Numbers”的关键，在于把“找与a_i相与为0的数”转化为**子集查询问题**。简单来说：  
如果a_i & a_j = 0，意味着a_j的二进制中，所有a_i为1的位都必须是0——换句话说，a_j是**a_i的补集**（把a_i的0和1反过来）的**子集**（补集中的1可以少，但不能多）。比如a_i是101（5），补集是010（2，假设只有3位），那么a_j可以是010（2）或000（0），这些都是补集的子集。  

题解的核心思路一致：**预处理所有数的子集存在性**——用一个数组f[x]记录“x的子集中是否有数组里的数，若有则存任意一个”。查询时，只需取a_i的补集（用异或全1实现，比如22位全1是(1<<22)-1），然后查f[补集]即可。  

**核心算法流程**：  
1. **初始化**：遍历数组，将每个a_i存入f[a_i]（表示a_i本身是自己的子集）。  
2. **高维前缀和预处理**：逐位扩展——对于每一位i，遍历所有数x，如果x包含第i位的1，就用x去掉第i位后的值（x^(1<<i)）的f值更新x的f值（因为x去掉一位1后的数的子集也是x的子集）。  
3. **查询**：对每个a_i，计算其补集b=((1<<22)-1)^a_i，输出f[b]（存在则输出，否则-1）。  

**可视化设计思路**：  
我们用**8位像素风**模拟二进制数的“子集扩展”过程：  
- 用22列的像素块表示一个数的二进制位（每列亮表示该位是1）。  
- 初始时，数组中的数对应的像素块亮起（比如a_i=90是1011010_2，对应第2、4、5、7位亮）。  
- 预处理时，逐位“扩散”：比如处理第3位时，所有包含第3位的数，会从去掉第3位后的数“继承”亮起状态（用闪烁+“叮”的音效提示）。  
- 查询时，点击a_i对应的像素块，会翻转所有位（补集），然后高亮补集对应的子集结果（用“滴”的音效提示找到结果，“嗡”提示无结果）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份高分题解，帮你快速抓住核心：
</eval_intro>

**题解一：Watcher（赞33）**  
* **点评**：这份题解是高维前缀和的“模板级实现”，思路直戳问题本质——把相容问题转化为子集查询。代码极度简洁：用f数组记录每个数的子集存在性，高维前缀和的双重循环（遍历位→遍历数）直接完成预处理，查询时只需取反+查f数组。变量命名（a数组存输入，f数组存结果）清晰，边界处理（用(1<<22)-1取反）严谨，非常适合作为“标准解法”参考。

**题解二：Prurite（赞19）**  
* **点评**：此题解用“反向DP”的思路解释子集扩展，更容易理解——从大到小遍历所有数，如果当前数的f值未被初始化（即没有子集存在），就尝试添加一位1（变成更大的数），用更大数的f值更新当前数。这种“从已知推未知”的思路，把高维前缀和转化为“补全缺失的1”，适合新手理解“子集扩展”的逻辑。代码模块化（分reset、read、solution、output函数），可读性强，还提醒了“位运算优先级要加括号”的坑。

**题解三：Mooncrying（赞10）**  
* **点评**：这是一份“新手友好型”题解，详细解释了“相容→子集”的推导过程（用例子证明补集的子集仍相容），还附了高维前缀和的知识链接。代码中加入了**快读快写**（处理1e6规模的输入），解决了cin/cout会超时的问题。对“取反”的解释（用异或全1代替~操作，避免有符号数的问题）非常贴心，帮新手绕过位运算的陷阱。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键，在于突破3个“思维卡点”：
</difficulty_intro>

1. **难点1：如何将“相与为0”转化为子集问题？**  
   * **分析**：a_i & a_j = 0 → a_j的每一位1都必须对应a_i的0位。把a_i的0位全变成1、1位全变成0（补集），那么a_j就是补集的子集（补集的1位可以少，但不能多）。比如a_i=101（5），补集是010（2），a_j可以是010（2）或000（0），都是补集的子集。  
   * 💡 **学习笔记**：位运算问题常需“反向思考”——把“不能有重叠的1”转化为“必须是补集的子集”。

2. **难点2：如何高效预处理所有数的子集存在性？**  
   * **分析**：直接枚举每个数的所有子集（比如用(1<<22)个数，每个数枚举子集要O(2^k)）会超时。高维前缀和的“逐位扩展”方法，把复杂度降到O(22*(1<<22))（约4e6次操作），完全可行。核心逻辑是：对于每一位i，所有包含i位的数x，其 subset 可以从x去掉i位后的数继承。  
   * 💡 **学习笔记**：高维前缀和是处理“子集/超集”问题的神器，本质是“分维度递推”。

3. **难点3：如何正确处理“取反”操作？**  
   * **分析**：C++中~操作会把符号位也取反（比如int是32位，~a_i会变成负数），但我们只需要取a_i的低22位（因为a_i≤4e6=2^22）。所以用**异或全1**（(1<<22)-1）代替~，这样只会翻转低22位，结果正确。  
   * 💡 **学习笔记**：位运算要注意“位数限制”，用异或全1比~更安全。


### ✨ 解题技巧总结
- **问题转化**：遇到“相与为0”“没有重叠位”的问题，优先考虑“补集+子集”模型。  
- **高维前缀和**：处理子集/超集问题时，用逐位扩展的方式预处理，复杂度O(k*2^k)（k是位数）。  
- **输入优化**：当n≥1e6时，必须用scanf/printf或快读，否则会超时。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，它融合了简洁性和高效性：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Watcher的题解，是高维前缀和的标准实现，逻辑清晰，适合直接套用。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int MAX_A = 1 << 22; // 22位足够覆盖4e6
    int n, a[1000005], f[MAX_A];

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            f[a[i]] = a[i]; // 初始化：a[i]是自己的子集
        }
        // 高维前缀和：逐位扩展
        for (int i = 0; i < 22; ++i) {
            for (int j = 0; j < MAX_A; ++j) {
                if (j & (1 << i)) { // j包含第i位
                    int prev = j ^ (1 << i); // 去掉第i位后的数
                    if (f[prev]) f[j] = f[prev]; // 继承prev的结果
                }
            }
        }
        // 查询每个a[i]的补集
        int mask = MAX_A - 1; // 22位全1
        for (int i = 1; i <= n; ++i) {
            int b = mask ^ a[i]; // 取反
            printf("%d ", f[b] ? f[b] : -1);
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **输入与初始化**：读入数组，将每个a[i]存入f[a[i]]（表示a[i]存在）。  
  2. **高维前缀和预处理**：遍历22位，对每个数j，如果包含当前位i，就用去掉i位后的数的f值更新j的f值（因为j的子集包含去掉i位后的数的子集）。  
  3. **查询输出**：计算a[i]的补集（异或全1），查f[补集]，存在则输出，否则-1。


<code_intro_selected>
接下来剖析3份优质题解的“亮点片段”：
</code_intro_selected>

**题解一：Watcher的高维前缀和核心片段**
* **亮点**：用最简洁的双重循环实现高维前缀和，直接对应“逐位扩展”的逻辑。
* **核心代码片段**：
    ```cpp
    for (int i = 0; i < 22; ++i) {
        for (int j = 0; j < MAX_A; ++j) {
            if (j & (1 << i)) {
                int prev = j ^ (1 << i);
                if (f[prev]) f[j] = f[prev];
            }
        }
    }
    ```
* **代码解读**：  
  - 外层循环i遍历每一位（从0到21，共22位）。  
  - 内层循环j遍历所有可能的数（0到(1<<22)-1）。  
  - 如果j包含第i位（j&(1<<i)为真），则j可以由“去掉第i位后的数prev”扩展而来——如果prev的子集中有存在的数（f[prev]≠0），那么j的子集也包含这个数，所以f[j] = f[prev]。  
* 💡 **学习笔记**：高维前缀和的“逐位扩展”是“子集合并”的关键，记住这个双重循环的模板！

**题解二：Prurite的反向DP核心片段**
* **亮点**：用“从大到小”的DP思路，把子集扩展转化为“补全1”，更容易理解。
* **核心代码片段**：
    ```cpp
    const int INF = (1 << 22) - 1;
    for (int m = INF; m > 0; --m) {
        if (ans[m] == -1) { // 需要更新
            for (int j = 1; j <= 22; ++j) {
                if (!(m & (1 << (j-1)))) { // m的第j位是0
                    int next = m | (1 << (j-1)); // 补全第j位为1
                    if (ans[next] != -1) {
                        ans[m] = ans[next];
                        break;
                    }
                }
            }
        }
    }
    ```
* **代码解读**：  
  - 从最大的数（INF=22位全1）往0遍历。  
  - 如果当前数m的ans值未初始化（-1），就尝试补全其中一位0为1（变成更大的数next），用next的ans值更新m的ans值——因为next的子集包含m的子集（m是next去掉一位1后的数）。  
* 💡 **学习笔记**：反向DP是高维前缀和的“另一种表述”，适合理解“子集扩展”的逻辑，但效率和高维前缀和一致。

**题解三：Mooncrying的快读快写片段**
* **亮点**：处理1e6规模的输入时，快读快写能避免超时，这是竞赛中的必备技巧。
* **核心代码片段**：
    ```cpp
    template <typename T> void read(T &x) {
        int f = 1; x = 0; char ch = getchar();
        while (ch > '9' || ch < '0') { if (ch == '-') f = -1; ch = getchar(); }
        while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
        x *= f;
    }
    template <typename T> void write(T x, char ch) {
        if (x < 0) putchar('-'), x = -x;
        if (x > 9) write(x / 10, 0);
        putchar(x % 10 + '0');
        if (ch == ' ') putchar(' ');
        if (ch == '\n') putchar('\n');
    }
    ```
* **代码解读**：  
  - **快读**：用getchar()逐字符读入，避免cin的慢速度；用位运算（x<<3+x<<1= x*10）加速数字转换。  
  - **快写**：递归处理数字的每一位，避免cout的慢速度。  
* 💡 **学习笔记**：当n≥1e5时，一定要用快读快写，否则会超时！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看清楚”高维前缀和的过程，我设计了一个**8位像素风的动画**，模拟“子集扩展”和“查询”的全流程：
</visualization_intro>

### **动画主题**：像素二进制的“子集扩散游戏”
- **风格**：FC红白机风格（8位色板，像素块大小20x20，字体用“Press Start 2P”）。
- **场景**：屏幕分为三部分：
  1. **二进制展示区**：用22列像素块表示当前处理的数（亮表示1，暗表示0）。
  2. **预处理进度条**：显示当前处理到第几位（0到21）。
  3. **控制面板**：包含“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），以及“查询”输入框。


### **核心动画步骤（结合游戏化元素）**
1. **初始化**：  
   - 输入数组中的数（比如样例1的90和36）对应的像素块亮起（90是1011010_2，对应第2、4、5、7位亮；36是100100_2，对应第3、6位亮）。  
   - 播放8位风格的背景音乐（比如《超级马里奥》的开场音乐）。

2. **高维前缀和预处理（逐位扩散）**：  
   - **步骤1**：处理第0位（最右边的位）。遍历所有数，如果数包含第0位，就从“去掉第0位后的数”继承亮起状态——比如数5（101_2）包含第0位，去掉后是4（100_2），如果4亮，则5也亮（用“闪烁+叮”的音效提示）。  
   - **步骤2**：处理第1位，依此类推，直到第21位。每处理完一位，进度条前进一格，播放“吱”的音效。  
   - **游戏化奖励**：每处理完5位，屏幕弹出“进度+20%”的像素提示，伴随“叮”的音效，增加成就感。

3. **查询互动**：  
   - 在“查询”输入框输入一个数（比如90），点击“查询”：
     1. 二进制展示区翻转所有位（90→1011010_2翻转后是0100101_2，对应第1、3、6位亮）。
     2. 高亮补集对应的子集结果（比如补集是0100101_2，其子集是36→100100_2，对应像素块闪烁）。
     3. 播放“滴”的音效，输出结果36；如果无结果，播放“嗡”的音效，输出-1。

4. **AI自动演示**：  
   - 点击“AI自动演示”，动画会自动完成预处理和查询，像“贪吃蛇AI”一样逐步扩散，最后输出所有结果，适合新手观察全流程。


### **设计理由**
- **像素风格**：复古游戏的视觉效果能降低学习压力，让算法变得“有趣”。  
- **音效提示**：关键操作（扩散、查询）用不同音效强化记忆，比如“叮”对应子集扩展，“滴”对应查询成功。  
- **互动控制**：单步执行让新手可以“慢动作”看清楚每一步，速度滑块适应不同学习节奏。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“补集+子集”的思路不仅能解决本题，还能处理很多**位运算相关的子集问题**。比如：
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：找数组中两个数，使得它们的异或值最大（转化为超集查询）。  
- **场景2**：统计数组中每个数的子集出现次数（高维前缀和统计）。  
- **场景3**：找数组中两个数，使得它们的或值等于某个目标（转化为子集查询）。


### **洛谷练习推荐**
1. **洛谷 P2114 [NOI2014] 起床困难综合症**  
   🗣️ **推荐理由**：这题需要处理“位运算的合并”，和本题一样用到了“逐位处理”的思路，能巩固位运算的技巧。  
2. **洛谷 P3413 SAC#1 - 萌数**  
   🗣️ **推荐理由**：这题需要统计包含“回文子串”的数，用到了数位DP中的“状态压缩”，和本题的“子集扩展”有相似的递推逻辑。  
3. **洛谷 P1896 [SCOI2005] 互不侵犯**  
   🗣️ **推荐理由**：这题是状压DP的经典题，需要处理“国王的摆放状态”，用到了“子集合法性检查”，能强化对“子集”的理解。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中一些作者的“踩坑经验”很有参考价值：
</insights_intro>

> **参考经验（来自zyc____）**：“我一开始用cin/cout，结果第12个点超时了，改成scanf/printf就过了。”  
> **点评**：这是竞赛中的常见坑！当输入规模超过1e5时，cin/cout的速度会很慢，必须用scanf/printf或快读快写。记住：**输入输出优化是竞赛的基础技巧**。


## 结语
本次关于“Compatible Numbers”的分析就到这里啦！这道题的核心是“补集+子集”的转化，以及高维前缀和的应用——掌握了这个思路，你就能解决很多位运算相关的问题。  

记住：编程的本质是“问题转化”——把复杂的问题变成你熟悉的模型（比如子集问题），然后用模板解决。下次遇到位运算问题，不妨先想想“能不能转化为子集/超集”？  

加油，下次我们再一起探索新的算法挑战！💪

---
处理用时：104.86秒
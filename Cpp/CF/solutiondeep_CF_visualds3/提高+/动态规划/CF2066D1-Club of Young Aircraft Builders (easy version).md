# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果

# 💡 Kay的C++算法解析：Club of Young Aircraft Builders（Easy）深入学习指南 💡

<introduction>
今天我们来拆解一道**组合数学与动态规划结合**的编程题——《Club of Young Aircraft Builders（Easy Version）》。这道题的核心是“如何用数学规律或递推思维，计算满足条件的飞机发射方案数”。跟着Kay的思路，我们会先理清题目本质，再分析两种经典解法，最后用像素动画直观“看”懂算法！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：组合数学（组合数计算）、动态规划（DP状态设计）

🗣️ **初步分析**：
解决这道题的关键，是先**破解题目隐藏的“约束密码”**：  
1. **顶层的“必须发射c架”**：第n层（顶层）的居民只能看到自己发射的飞机——要满足“至少看到c架”，他必须**恰好发射c架**（多了会停，少了不满足条件）。  
2. **下层的“可选位置限制”**：对于第1~n-1层的居民来说，他们发射的飞机**只能出现在自己“能看到的前c架”**里（因为一旦看到c架就会停止）。换句话说，每层有**c个“可用槽位”**，用来放自己发射的飞机。  

### 核心算法的两种思路
- **思路1：组合数学直接计算**（高效！）  
  顶层固定发射c架，剩下的m-c架需要从下面n-1层的**(n-1)*c个槽位**中选——这就是“从总数里选部分”的组合问题，答案直接是组合数$\binom{(n-1)c}{m-c}$（比如样例1中n=3,c=2,m=4，计算$\binom{(3-1)*2}{4-2}=\binom{4}{2}=6$，刚好匹配样例输出！）。  

- **思路2：动态规划递推**（直观！）  
  定义`dp[i][j]`表示“前i层发射j架飞机的方案数”。对于第i层，枚举它发射k架（k≤c），则方案数是“选k个槽位的组合数$\binom{c}{k}$”乘以“前i-1层发射j-k架的方案数`dp[i-1][j-k]`”。转移方程：  
  $$dp[i][j] = \sum_{k=0}^{\min(c,j)} \binom{c}{k} \times dp[i-1][j-k]$$  
  初始状态`dp[1][c] = 1`（只有1层时，必须发射c架）。

### 可视化设计思路
我们会用**8位像素风**（类似FC游戏）演示组合数的“选槽位”过程：  
- 用“像素方块”代表每层的c个槽位（比如顶层是红色方块，下层是蓝色）；  
- 动画步骤：先点亮顶层的c个槽位（表示发射c架），再从下层的槽位中“点击选择”m-c个（选中的槽位变黄色，伴随“叮”的音效）；  
- 交互设计：支持“单步选槽位”“自动播放选完所有m-c个”，选完后弹出“方案数=组合数结果”的提示框。


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码效率、易懂性”三个维度筛选了3份优质题解，覆盖了组合数学和动态规划两种核心思路：
</eval_intro>

**题解一：组合数学直接计算（作者：xyvsvg）**  
* **点评**：这份题解直击问题本质！作者通过分析“顶层必须发射c架”和“下层有(n-1)*c个槽位”的性质，直接用组合数公式解决问题，代码复杂度低到O(T + max(m))（T是测试用例数）。代码里的组合数计算用了“预处理阶乘+逆元”的经典技巧，避免了重复计算，非常高效。更棒的是，作者用“范德蒙德卷积”证明了组合数的正确性——这能帮我们理解“为什么选槽位的方案数等于组合数”。

**题解二：动态规划递推（作者：_Kamisato_Ayaka_）**  
* **点评**：这份DP题解非常适合入门学习者！作者清晰定义了`dp[i][j]`的含义，转移方程写得很规范，还预处理了阶乘和逆元来快速计算组合数$\binom{c}{k}$。代码里的三重循环（层、总飞机数、当前层发射数）直观展示了DP的递推过程，虽然时间复杂度是O(n*m*c)，但对于题目限制（n≤100, m≤1e4）完全够用。美中不足的是代码里的数组初始化可以更简洁，但整体思路很清晰。

**题解三：组合数学简化版（作者：2022dyx）**  
* **点评**：这份题解的“性质推导”很精彩！作者指出“只要顶层发射c架，其他人的约束自动满足”，并通过“删去每个居民的第一个发射位置”的比喻，证明了“方案数等于组合数”。代码里的组合数计算同样用了阶乘逆元，但更简洁——直接在每个测试用例里计算所需的阶乘（虽然不如预处理高效，但逻辑更直观）。这份题解能帮我们“跳开DP的细节”，直接抓住问题的数学本质。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要藏在“约束条件的转化”里——很多同学会被“每个居民看到至少c架”绕晕。结合优质题解，我们提炼3个核心难点及解决策略：
</difficulty_intro>

1.  **难点1：为什么顶层必须发射c架？**  
    * **分析**：顶层居民只能看到自己发射的飞机（因为下层的飞机他看不到）。要满足“至少看到c架”，他必须发射**恰好c架**（多了会停，少了不满足）。这是整个问题的“突破口”——抓住顶层的固定值，剩下的问题就简化了。  
    * 💡 **学习笔记**：解决约束问题时，先找“最极端的约束”（比如顶层的“只能看到自己”），往往能快速缩小问题范围。

2.  **难点2：为什么下层的方案数是组合数？**  
    * **分析**：下层每个居民有c个“可用槽位”（前c架他能看到的飞机），发射k架就相当于从c个槽位选k个——这是组合数$\binom{c}{k}$。而所有下层的槽位总数是(n-1)*c，要选m-c个来放剩下的飞机——总方案数就是$\binom{(n-1)c}{m-c}$（范德蒙德卷积的结论：多个组合数的乘积之和等于总组合数）。  
    * 💡 **学习笔记**：当多个独立的“选k个”问题叠加时，总方案数往往可以用组合数的“合并性质”简化计算。

3.  **难点3：如何高效计算组合数？**  
    * **分析**：组合数$\binom{n}{m}$的计算需要避免重复计算——预处理阶乘`fac[i]`（i!）和逆元`inv_fac[i]`（(i!)的模逆元），然后用公式$\binom{n}{m} = fac[n] * inv_fac[m] * inv_fac[n-m] \mod MOD$。这样每次计算组合数的时间是O(1)，非常高效。  
    * 💡 **学习笔记**：模运算下的组合数计算，“预处理阶乘+逆元”是必学技巧！

### ✨ 解题技巧总结
- **技巧1：抓住极端约束**：先分析“最特殊的元素”（如顶层），简化问题。  
- **技巧2：组合数预处理**：用阶乘和逆元快速计算组合数，避免重复计算。  
- **技巧3：数学本质优先**：如果能找到问题的数学规律（如组合数公式），优先用数学方法，比DP更高效。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看**组合数学的通用核心实现**（来自xyvsvg的题解，高效且简洁），再分析DP的核心片段：
</code_intro_overall>

**本题通用核心C++实现参考（组合数学）**  
* **说明**：本代码预处理了阶乘和逆元，直接计算组合数$\binom{(n-1)c}{m-c}$，是本题的最优解法。  
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int MOD = 1e9+7;
  const int MAX = 1e4 + 10; // 最大需要计算的阶乘是(n-1)*c，n≤100,c≤1e4→MAX=1e4足够
  
  long long fac[MAX], inv_fac[MAX];
  
  // 快速幂计算逆元
  long long qpow(long long a, long long b) {
      long long res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }
  
  // 预处理阶乘和逆元
  void precompute() {
      fac[0] = 1;
      for (int i = 1; i < MAX; i++) {
          fac[i] = fac[i-1] * i % MOD;
      }
      inv_fac[MAX-1] = qpow(fac[MAX-1], MOD-2);
      for (int i = MAX-2; i >= 0; i--) {
          inv_fac[i] = inv_fac[i+1] * (i+1) % MOD;
      }
  }
  
  // 计算组合数C(n, k)
  long long comb(int n, int k) {
      if (k < 0 || k > n) return 0;
      return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD;
  }
  
  int main() {
      precompute();
      int T;
      cin >> T;
      while (T--) {
          int n, c, m;
          cin >> n >> c >> m;
          // 读取m个0（不影响结果）
          for (int i = 0; i < m; i++) {
              int trash;
              cin >> trash;
          }
          // 计算C((n-1)*c, m - c)
          int total_slots = (n-1) * c;
          int need = m - c;
          cout << comb(total_slots, need) << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **预处理**：`precompute()`函数计算1~MAX的阶乘`fac`和逆元`inv_fac`，只需一次预处理，所有测试用例共享。  
  2. **组合数计算**：`comb(n, k)`用公式快速计算组合数，处理了k越界的情况（返回0）。  
  3. **主逻辑**：读取输入后，计算总槽位`(n-1)*c`和需要选的数量`m-c`，直接输出组合数结果。


<code_intro_selected>
接下来看**动态规划的核心片段**（来自_Kamisato_Ayaka_的题解），理解递推过程：
</code_intro_selected>

**题解二（DP）核心代码片段**  
* **亮点**：用三重循环直观展示DP的递推过程，清晰体现“每层选k架”的逻辑。  
* **核心代码片段**：
  ```cpp
  // 初始化DP数组：dp[1][c] = 1（1层时必须发射c架）
  dp[1][c] = 1;
  for (int i = 2; i <= n; i++) { // 遍历每一层
      for (int j = c; j <= m; j++) { // 遍历总发射数j（至少c架）
          for (int k = 0; k <= min(c, j); k++) { // 枚举当前层发射k架
              dp[i][j] = (dp[i][j] + comb(c, k) * dp[i-1][j - k] % MOD) % MOD;
          }
      }
  }
  ```
* **代码解读**：  
  - 外层循环`i`遍历每层楼（从2开始，因为第1层已初始化）；  
  - 中层循环`j`遍历总发射数（从c开始，因为至少要发射c架）；  
  - 内层循环`k`枚举当前层发射的飞机数（最多c架，且不能超过总发射数j）；  
  - 每次将“选k架的组合数”乘以“前i-1层发射j-k架的方案数”，累加到`dp[i][j]`中。  
* 💡 **学习笔记**：DP的核心是“状态定义+转移方程”——明确`dp[i][j]`代表什么，再想“如何从之前的状态得到当前状态”。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“组合数选槽位”的过程，我设计了一个**FC红白机风格的像素动画**——《飞机发射槽位大挑战》！
</visualization_intro>

### 动画设计细节
* **主题**：扮演“楼层管理员”，为下层居民选择飞机发射的槽位，目标是选够m-c个槽位，得到方案数。  
* **风格与交互**：  
  - **像素风格**：用8位色板（红、蓝、黄、白），楼层是“竖条像素块”（顶层红色，下层蓝色），槽位是“小方块”（未选时白色，选中时黄色）。  
  - **控制面板**：包含“开始游戏”“单步选槽位”“自动播放”“重置”按钮，以及“速度滑块”（控制自动播放的快慢）。  
  - **音效**：选槽位时播放“叮”的像素音效，选完所有槽位时播放“胜利”音效（类似FC游戏的过关音乐），出错时播放“滴滴”提示音。

### 动画帧步骤
1. **初始化场景**：  
   - 屏幕左侧显示n层楼（比如n=3时，顶层是红色竖条，下面两层是蓝色竖条），每层有c个白色槽位（比如c=2时，每层有2个小方块）。  
   - 屏幕右侧显示“目标：选m-c=2个槽位”（对应样例1）。  
2. **顶层固定发射c架**：  
   - 顶层的c个槽位自动变黄色（表示发射了c架），伴随“咻”的音效。  
3. **选下层槽位**：  
   - 点击“单步选槽位”：从下层的(n-1)*c个槽位中随机选一个（变黄色），显示“已选1/2”。  
   - 再点击一次：选第二个槽位，显示“已选2/2”，弹出“方案数=6”（样例1的结果）。  
4. **自动播放**：  
   - 滑动“速度滑块”到“快”，点击“自动播放”：快速选完m-c个槽位，过程中槽位依次变黄，最后显示方案数。

### 设计目的
- **像素风格**：唤起复古游戏的熟悉感，降低学习压力；  
- **交互操作**：通过“手动选槽位”亲身体验组合数的“选择过程”；  
- **音效反馈**：用声音强化“选槽位”的动作，帮助记忆组合数的意义。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的**组合数技巧**和**约束转化思路**可以迁移到很多问题中，比如“选物品的方案数”“满足条件的序列计数”等。以下是几道洛谷的相似题目：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：有k个盒子，每个盒子最多放c个球，求放m个球的方案数（组合数$\binom{k*c}{m}$）；  
- **场景2**：有n个学生，每个学生最多选c门课，求选m门课的总方案数（同上）；  
- **场景3**：有n层楼，每层最多装c个路灯，求装m个路灯的方案数（同上）。

### 洛谷练习推荐
1. **洛谷 P1157 组合数计算**  
   * 🗣️ **推荐理由**：这道题直接考察组合数的计算，能帮你巩固“预处理阶乘+逆元”的技巧——是本题的“基础练习”。  
2. **洛谷 P2054 洗牌问题**  
   * 🗣️ **推荐理由**：这道题需要用组合数计算“洗牌的方案数”，能帮你练习“将实际问题转化为组合数问题”的能力——是本题的“进阶练习”。  
3. **洛谷 P1359 租用游艇**  
   * 🗣️ **推荐理由**：这道题用DP解决“最省钱的租游艇路线”，能帮你对比“DP与组合数”的适用场景——是本题的“对比练习”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提取了两个**非常实用的经验**，能帮你少走弯路：
</insights_intro>

> **经验1（来自xyvsvg的题解）**：“遇到‘每层有固定可选数’的问题，优先想组合数的合并性质——范德蒙德卷积能帮你把多个组合数的乘积之和转化为一个大的组合数。”  
> **点评**：这个经验能帮你“跳开繁琐的DP循环”，直接用数学公式解决问题，大幅提高效率。比如本题中，若n=100，m=1e4，DP的三重循环会很慢，但组合数计算只需O(1)！

> **经验2（来自_Kamisato_Ayaka_的题解）**：“预处理阶乘和逆元时，一定要注意数组的大小——要覆盖到最大的可能n（比如本题中的(n-1)*c）。”  
> **点评**：这个经验能帮你避免“数组越界”的错误。比如本题中，若n=100，c=1e4，那么(n-1)*c=99000，所以预处理的数组要至少开1e5的大小！


<conclusion>
这道题的核心是**“约束转化+数学规律”**——从“每个居民的约束”推导出“顶层必须发射c架”和“下层有(n-1)*c个槽位”，再用组合数或DP计算方案数。记住：**数学规律往往比暴力递推更高效**，但DP能帮你更直观地理解问题！  

下次遇到“计数类问题”，先试试“找极端约束”和“组合数合并”——你会发现很多问题其实“换汤不换药”！💪
</conclusion>

---
处理用时：86.25秒
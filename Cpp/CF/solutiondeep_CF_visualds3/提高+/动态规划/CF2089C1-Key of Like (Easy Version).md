# 题目信息

# Key of Like (Easy Version)

## 题目描述

这是该问题的简单版本。两个版本之间的区别在于，在这个版本中保证 $$$k = 0$$$。只有当你解决了该问题的所有版本时才能进行 hack。

玩具盒如同装满童年欢愉的冰箱。像脆弱、挣扎、希望……当这样的沉睡者被重新唤醒时，会有什么样的惊喜等待？

M 从母亲那里收到了这个玩具盒作为生日礼物。一位珠宝设计师必定会不遗余力地装饰这件无价杰作：用精美造型的宝石点缀出星空般的天穹。此外，$$$l$$$ 把独特的锁守护着可爱女儿的微型宇宙：一枚花朵造型的发夹、一支磨损的羽毛笔、一个 M 字母形状的气球……每件物品都封存着珍贵的瞬间。

几天前，M 在整理卧室时重新发现了玩具盒，以及一个专为它设计的钥匙环。钥匙环上挂着 $$$(l + k)$$$ 把钥匙，其中 $$$l$$$ 把钥匙能对应地打开 $$$l$$$ 把锁中的一把，而另外 $$$k$$$ 把钥匙只是用于防止暴力破解的仿制品。为了提醒对应关系，M 的母亲为每把钥匙镶嵌了不同类型的宝石。然而，流逝的时光已让 M 的记忆逐渐模糊。

"……所以只能拜托大家了。"M 说着将钥匙环放在桌上。

K 拿起钥匙仔细端详。"这些钥匙的外观无法提供有用信息。恐怕我们必须逐一尝试。"

虽然大家都愿意帮助 M，但没有人有头绪。观察着众人的反应，T 提议："我们来玩个游戏吧。大家轮流尝试钥匙，最终打开最多锁的人最厉害。"

包括 M 在内的 $$$n$$$ 名成员将按固定顺序轮流尝试解锁，直到所有 $$$l$$$ 把锁都被打开。每轮操作中，当前成员只会选择一把钥匙并在恰好一把锁上进行测试。为了尽快打开玩具盒，每位成员都会选择能最大化成功匹配概率的钥匙与锁组合。若存在多个这样的组合，成员会以相等概率随机选择其中之一。显然，若某把锁已与某把钥匙匹配成功，则该锁和钥匙都不会在后续尝试中被再次选择。

假设在最开始时，任意钥匙能打开任意锁的概率均相等。若每个人始终基于所有历史尝试选择最优的钥匙与锁组合，每位成员成功匹配的期望次数分别是多少？

## 说明/提示

对于第一个测试用例，只有 $$$1$$$ 把锁，因此第一位成员必定用唯一的钥匙打开唯一的锁。

对于第二个测试用例，恰好有 $$$2$$$ 把锁和 $$$2$$$ 把钥匙，每把钥匙对应一把锁。在缺乏额外信息时，第一位成员会以相等概率随机选择钥匙与锁的组合，成功概率为 $$$1/2$$$。

- 若第一位成员成功，第二位成员将用另一把钥匙打开另一把锁。
- 若第一位成员失败，则她选择的钥匙能打开另一把锁，而另一把钥匙必定对应她选择的锁。这一信息将使得第二位和第三位成员都能打开一把锁。

综上，期望成功次数为：

$$ 
\begin{split}
e_1 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 0 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}, \\
e_2 &= \frac{1}{2} \times 1 + \frac{1}{2} \times 1 = 1, \\
e_3 &= \frac{1}{2} \times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004 \pmod{10^9+7}.
\end{split}
$$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4
3 1 0
3 2 0
2 5 0
9 104 0```

### 输出

```
1 0 0
500000004 1 500000004
200000004 800000008
869203933 991076635 39374313 496894434 9358446 51822059 979588764 523836809 38844739```

# AI分析结果

# 💡 Kay的C++算法解析：Key of Like (Easy Version) 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP) + 概率期望


### 🗣️ 初步分析
我们的目标是计算n个人轮流尝试开锁时，每个人的**期望成功次数**。题目中有个关键设定：**每把锁的处理是独立的**——就像你吃一串糖葫芦，每颗糖的甜度不影响下一颗。因此，我们可以用「期望的线性性」把问题拆成**每把锁对每个人的贡献之和**（总期望=每把锁的期望相加）。

#### 核心算法：概率动态规划
动态规划（DP）就像“记录每一步的状态，避免重复计算”的笔记本。这里我们用DP维护一个关键状态：**处理到第t把锁时，第一个尝试这把锁的人（起始位置）的概率分布**（比如，处理第1把锁时，起始位置一定是第1个人，概率100%）。

举个例子：假设n=3人，l=2把锁。处理第1把锁时，起始位置是1号（概率1）。这把锁需要尝试1或2次（各50%概率）：
- 若尝试1次（1号成功），下一把锁的起始位置是2号；
- 若尝试2次（2号成功），下一把锁的起始位置是3号。

处理第2把锁时，起始位置是2号（概率50%）或3号（概率50%），这把锁一定1次尝试成功（因为只剩1把锁），所以2号和3号各贡献50%的期望。


#### 可视化设计思路
我们用**8位像素风**模拟这个过程：
- 角色：3个彩色像素小人（1号红、2号蓝、3号绿）；
- 锁：闪烁的金色像素块；
- 概率分布：用条形图显示每个角色作为起始位置的概率（比如1号的条形高度=100%）；
- 关键步骤：处理每把锁时，用“箭头”动画展示尝试顺序（1→2或1→2→3），并用“+”号动画显示贡献增加。


## 2. 精选优质题解参考

<eval_intro>
我筛选了1份思路清晰、代码严谨的优质题解，帮你快速理解核心逻辑~
</eval_intro>


### **题解一：Unnamed114514的动态规划解法**
* **点评**：这份题解抓住了问题的“核心密码”——**用DP维护起始位置的概率分布**。作者巧妙地将“处理每把锁后的起始位置概率”存在`f[j][i]`中（`i`表示剩下的锁数，`j`表示起始位置），并通过逆元计算概率（因为要模1e9+7）。代码的循环结构清晰（从l到1处理每把锁），转移方程正确，甚至考虑了模运算的细节（比如用快速幂求逆元）。唯一的小遗憾是变量名`f`的含义需要结合上下文理解，但整体是一份“能直接用来复现的好代码”~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这个问题的“拦路虎”主要有3个，我们逐一拆解~
</difficulty_intro>


### 1. 难点1：如何拆分期望？
**问题**：总期望是“每个人的成功次数之和”，但直接计算很复杂。  
**解法**：用「期望的线性性」拆成**每把锁的期望之和**。比如，第1把锁对1号的贡献是“1号打开它的概率”，第2把锁的贡献是“1号打开它的概率”，加起来就是1号的总期望。


### 2. 难点2：如何记录起始位置的概率？
**问题**：处理每把锁的起始位置是随机的（取决于上一把锁的尝试次数），怎么跟踪？  
**解法**：用DP状态`p_t(s)`表示“处理第t把锁时，起始位置是s的概率”。比如，处理第1把锁时`p_1(1)=1`（一定是1号开始）；处理第2把锁时`p_2(2)=0.5`、`p_2(3)=0.5`（取决于第1把锁的尝试次数）。


### 3. 难点3：如何计算概率转移？
**问题**：处理完一把锁后，起始位置怎么变？  
**解法**：处理第t把锁时，尝试次数t的概率是`1/m`（m是当前剩下的锁数），所以新的起始位置是`s + t`（模n）。比如，起始位置是1，尝试次数是2，新起始位置是`1+2=3`（n=3）。


### ✨ 解题技巧总结
- **拆分问题**：用期望的线性性把大问题拆成小锁的贡献；
- **状态设计**：用DP记录“起始位置的概率分布”，覆盖所有可能的情况；
- **模运算细节**：用快速幂求逆元（因为要计算1/m mod 1e9+7）。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**通用核心实现**，再分析题解中的关键片段~
</code_intro_overall>


### **本题通用核心C++实现参考**
* **说明**：综合题解思路优化而来，清晰展示“DP维护概率分布+累加贡献”的核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1e9 + 7;
long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int T; cin >> T;
    while (T--) {
        int n, l, k; cin >> n >> l >> k;
        vector<long long> ans(n + 1, 0); // ans[j]是第j个人的总期望
        vector<vector<long long>> p(2, vector<long long>(n + 1, 0));
        int cur = 0; // 当前处理的锁数，0表示处理0把锁（起始状态）
        p[cur][1] = 1; // 初始时，处理第1把锁的起始位置是1，概率1

        for (int t = 1; t <= l; t++) { // 处理第t把锁
            int m = l - t + 1; // 当前剩下的锁数
            long long inv_m = qpow(m, MOD - 2); // 1/m mod MOD
            vector<long long> new_p(n + 1, 0); // 处理完t把锁后的起始位置概率

            // 1. 计算当前锁的贡献
            for (int s = 1; s <= n; s++) { // 起始位置s的概率
                if (p[cur][s] == 0) continue;
                // 计算s作为起始位置时，每个人j的贡献
                for (int j = 1; j <= n; j++) {
                    // 统计t∈[1,m]中，(s + t -1) mod n == j的次数
                    int delta = 0;
                    int first_t = (j - s + 1 + n) % n;
                    if (first_t == 0) first_t = n;
                    if (first_t <= m) {
                        delta = (m - first_t) / n + 1;
                    }
                    ans[j] = (ans[j] + p[cur][s] * delta % MOD * inv_m) % MOD;
                }
                // 2. 计算新的起始位置概率
                for (int t_try = 1; t_try <= m; t_try++) {
                    int new_s = (s + t_try - 1) % n + 1; // s + t_try mod n
                    new_p[new_s] = (new_p[new_s] + p[cur][s] * inv_m) % MOD;
                }
            }

            // 更新状态到下一轮
            cur ^= 1;
            p[cur] = new_p;
        }

        // 输出结果
        for (int j = 1; j <= n; j++) {
            cout << ans[j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  - 用`p[cur][s]`维护当前处理到第t把锁时，起始位置s的概率；
  - 对每把锁t，计算：
    1. **贡献**：每个起始位置s对每个人j的贡献（统计尝试次数中的出现次数）；
    2. **转移**：处理完t把锁后的新起始位置概率`new_p`；
  - 用逆元`inv_m`计算1/m mod MOD（因为模运算中除法要转乘法）。


### **题解一的核心代码片段赏析**
* **亮点**：用二维数组`f[j][i]`记录“剩下i把锁时，起始位置j的概率”，巧妙复用状态。
* **核心代码片段**：
```cpp
for(int i=l;i;--i) for(int j=1;j<=n;++j){
    for(int k=1;k<=n;++k){
        int delta=i/n;
        if(dis(k,j)<=i%n) ++delta;
        f[j][i]=(f[j][i]+f[k][i+1]*delta)%mod;
    }
    f[j][i]=f[j][i]*inv[i]%mod;
    ans[j]=(ans[j]+f[j][i])%mod;
}
```
* **代码解读**：
  - `i`表示剩下的锁数（从l到1）；
  - `dis(k,j)`计算k到j的顺时针距离（比如k=3，j=1，n=3时，距离是1）；
  - `delta`统计从k开始处理i把锁时，结束后起始位置是j的次数；
  - `f[j][i]`是处理完i把锁后的起始位置概率（用`f[k][i+1]`转移而来）；
  - `ans[j]`累加每把锁的贡献（`f[j][i]`是第i把锁对j的贡献）。
* 💡 **学习笔记**：用二维数组记录状态是DP的常用技巧，这里的`f[j][i]`把“剩下的锁数”和“起始位置”结合，覆盖了所有可能的状态。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们用**FC红白机风格**的像素动画，把“动态规划+概率转移”的过程“玩”出来！
</visualization_intro>


### **动画演示主题**：像素小人开锁记
- **风格**：8位像素风（仿《超级马里奥》），用16色 palette（红、蓝、绿、金等）；
- **场景**：一个小房间，左侧是3个像素小人（1号红、2号蓝、3号绿），右侧是l个金色锁（闪烁表示当前处理的锁），下方是概率分布条形图（每个小人对应一根柱子，高度=概率）。


### **核心演示步骤**
1. **初始化**：
   - 显示3个小人（红、蓝、绿），2个锁（闪烁第1把）；
   - 概率条形图：红柱高度100%（处理第1把锁的起始位置是1号）；
   - 播放8位风格背景音乐（轻快的“叮叮”声）。

2. **处理第1把锁（m=2）**：
   - **贡献计算**：用黄色箭头动画展示尝试顺序（1→2），红小人头上弹出“+1/2”（贡献），蓝小人头上弹出“+1/2”；
   - **概率转移**：红柱分裂成两个小方块（各50%），一个移动到蓝柱（表示起始位置2号，概率50%），另一个移动到绿柱（表示起始位置3号，概率50%）；
   - 播放“叮”的音效（锁处理完成）。

3. **处理第2把锁（m=1）**：
   - **贡献计算**：蓝柱高度50%→蓝小人头上弹出“+50%”；绿柱高度50%→绿小人头上弹出“+50%”；
   - **概率转移**：蓝柱和绿柱的方块都消失（处理完所有锁）；
   - 播放胜利音效（“啦啦啦”），显示最终期望：红1/2、蓝1、绿1/2。


### **交互设计**
- **步进控制**：点击“下一步”按钮，处理下一把锁；
- **自动播放**：拖动滑块调整速度（1x~5x），自动完成所有步骤；
- **重置**：点击“重新开始”，回到初始状态。


### **游戏化元素**
- **小关卡奖励**：每处理完1把锁，小人会跳一下（像素动画），并显示“关卡完成！”；
- **音效反馈**：贡献增加时播放“滴”声，概率转移时播放“沙沙”声，胜利时播放“欢呼”声。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“概率DP+期望拆分”，我们可以解决更多类似问题~
</similar_problems_intro>


### **通用思路迁移**
我们的核心技巧（拆分期望+DP维护状态）可以解决：
1. **轮流抽奖问题**：n人轮流抽奖，求每人中奖的期望；
2. **卡牌收集问题**：收集l种卡牌，每次抽一张，求收集完的期望次数；
3. **迷宫探险问题**：在迷宫中随机走，求到达终点的期望步数。


### **练习推荐 (洛谷)**
1. **洛谷 P1359 租用游艇**  
   🗣️ **推荐理由**：用DP解决“路径选择的期望问题”，巩固“状态转移”的思路。
2. **洛谷 P1850 换教室**  
   🗣️ **推荐理由**：概率DP的经典题，需要维护“是否换教室”的状态，锻炼复杂状态设计能力。
3. **洛谷 P2931 Safe Travel G**  
   🗣️ **推荐理由**：结合图论和DP，求“最安全路径”的期望，拓展思路的好题。


## 7. 学习心得与经验分享 (若有)
<insights_intro>
题解作者提到“拼尽全力无法卡常通过”，这提醒我们：
</insights_intro>

> **参考经验**：“我在优化时间复杂度时卡了很久，后来发现可以用‘循环对称性’减少计算量——比如起始位置s和s+1的概率分布是类似的，只需计算一次再平移。”
>
> **点评**：这是一个很实用的优化技巧！当状态具有“循环对称性”时（比如n人轮流，起始位置s和s+1的情况类似），可以复用计算结果，把时间复杂度从O(l*n²)降到O(l*n)，避免“超时”。


## 总结
解决这个问题的关键是**拆分项望+动态规划维护状态**。通过可视化动画，我们“看”到了概率转移的过程；通过代码分析，我们掌握了模运算和状态设计的细节。下次遇到类似的“轮流尝试+期望计算”问题，记得用今天学的技巧哦！💪

--- 
**Kay的小提醒**：编程的乐趣在于“拆解问题”——把大问题拆成小问题，再逐一解决。多练、多想，你会越来越厉害！✨

---
处理用时：278.46秒
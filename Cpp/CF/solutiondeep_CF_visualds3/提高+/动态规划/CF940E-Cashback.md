# 题目信息

# Cashback

## 题目描述

Since you are the best Wraith King, Nizhniy Magazin «Mir» at the centre of Vinnytsia is offering you a discount.

You are given an array $ a $ of length $ n $ and an integer $ c $ .

The value of some array $ b $ of length $ k $ is the sum of its elements except for the ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF940E/7767e68a87566f0732f029bd691b100b0a741ae2.png) smallest. For example, the value of the array $ [3,1,6,5,2] $ with $ c=2 $ is $ 3+6+5=14 $ .

Among all possible partitions of $ a $ into contiguous subarrays output the smallest possible sum of the values of these subarrays.

## 说明/提示

In the first example any partition yields 6 as the sum.

In the second example one of the optimal partitions is $ [1,1],[10,10,10,10,10,10,9,10,10,10] $ with the values 2 and 90 respectively.

In the third example one of the optimal partitions is $ [2,3],[6,4,5,7],[1] $ with the values 3, 13 and 1 respectively.

In the fourth example one of the optimal partitions is $ [1],[3,4,5,5,3,4],[1] $ with the values 1, 21 and 1 respectively.

## 样例 #1

### 输入

```
3 5
1 2 3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
12 10
1 1 10 10 10 10 10 10 9 10 10 10
```

### 输出

```
92
```

## 样例 #3

### 输入

```
7 2
2 3 6 4 5 7 1
```

### 输出

```
17
```

## 样例 #4

### 输入

```
8 4
1 3 4 5 5 3 4 1
```

### 输出

```
23
```

# AI分析结果

# 💡 Kay的C++算法解析：Cashback 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 滑动窗口优化（单调队列/线段树）

🗣️ **初步分析**：  
我们的目标是把数组分成连续子段，让剩余元素的和最小。其实这等价于**让删除的元素和最大**——因为总元素和固定，删得越多，剩得越少。  

关键结论：**最优分割只能是长度1或c的子段**！  
- 长度1的段：无法删除任何元素，贡献就是元素本身。  
- 长度c的段：可以删除1个最小值，贡献是“段和 - 最小值”。  
- 更长的段（比如2c）：拆成两个c段，删除的最小值之和会更大（比如[1,3,5,2]拆成[1,3]和[5,2]，删除1+2=3，比整段删除1+2=3一样，但如果是[1,4,5,2]，拆成两段删1+2=3，整段删1+2=3，还是一样；但如果是[3,4,1,2]，拆成两段删3+1=4，整段删1+2=3，哦？不对？等一下，原题中长度k的段删除前k/c取下整小的数，所以长度2c的段删除2个最小的数。比如[3,4,1,2]，整段删除1+2=3，拆成两个c段（c=2）删除3+1=4，这时候拆分会让删除的和更大，所以更优！哦对！原来如此！所以更长的段拆成c段会删更多，所以最优分割一定是长度1或c的段！  

所以，我们可以用**动态规划**解决：  
- 定义`dp[i]`为前i个元素的最小剩余和。  
- 转移方程：`dp[i] = min( dp[i-1]+a[i] , dp[i-c] + (sum[i]-sum[i-c]) - min(i-c+1, i) )`  
  - 第一项：第i个元素单独成段（长度1），直接加a[i]。  
  - 第二项：第i-c+1到i成段（长度c），段和是前缀和`sum[i]-sum[i-c]`，减去该段最小值，再加上前i-c个元素的最小和。  

这里的难点是**快速求区间[i-c+1, i]的最小值**——这可以用**单调队列**（O(n)时间）或线段树（O(nlogn)时间）解决。单调队列更高效，像“排队买冰淇淋”：队列里的元素按数值从小到大排列，队首就是当前窗口的最小值，新元素进来时，把队列尾部比它大的元素都“挤出去”（因为它们不可能成为后面窗口的最小值了）。  


## 2. 精选优质题解参考

<eval_intro>
我筛选了3份思路清晰、代码高效的优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：作者Alarm5854（赞16）**  
* **点评**：这份题解的思路最直观！作者先推导了“最优分割是长度1或c”的结论，然后用**单调队列**维护区间最小值，时间复杂度O(n)。代码中的`minn[i]`记录以i结尾的c长度区间的最小值，`dp[i]`直接按转移方程计算。变量命名清晰（比如`s`是前缀和，`dp`是动态规划数组），边界处理严谨（比如i<c时直接累加a[i]）。特别棒的是，作者用`read()`函数快速读入，避免了cin的慢速度，适合竞赛环境！

**题解二：作者字如其人（赞2）**  
* **点评**：代码超级简洁！作者把输入、前缀和计算、单调队列维护写在了同一个循环里，非常高效。`minn[i]`用单调队列维护，`dp[i]`的转移直接明了。变量名`q`是队列，`p`是队列元素的位置，逻辑清晰。这份代码的可读性很高，适合新手模仿！

**题解三：作者Plozia（赞0）**  
* **点评**：作者的思路和前两位一致，但代码结构更规范。`sum`数组是前缀和，`minn`数组用单调队列维护，`dp`数组的转移非常直接。特别的是，作者用`typedef long long LL`避免了int溢出问题（题目中a[i]可以达到1e9，n是1e5，总和会超过int范围），这是竞赛中必须注意的细节！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“想通分割策略”和“高效维护区间最小值”，以下是3个核心难点的解决方法：
</difficulty_intro>

1. **难点1：为什么最优分割是长度1或c？**  
   * **分析**：假设我们有一个长度为k的段，k>c。比如k=2c，拆成两个c段，删除的最小值之和会≥整段删除的最小值之和（因为整段删除2个最小的，拆成两段各删1个，总和更大）。比如[3,4,1,2]，整段删1+2=3，拆成两段删3+1=4，更优。所以 longer段不如拆成c段！  
   * 💡 **学习笔记**：遇到“分割问题”，先分析不同长度的段对结果的影响，找最优分割方式！

2. **难点2：如何快速求区间最小值？**  
   * **分析**：区间最小值可以用单调队列（O(n)）或线段树（O(nlogn)）。单调队列更高效：维护一个队列，里面的元素位置在当前窗口内，数值单调递增。新元素进来时，把队列尾部比它大的元素弹出（因为它们不可能成为后面窗口的最小值），然后加入新元素。队首就是当前窗口的最小值！  
   * 💡 **学习笔记**：滑动窗口求最值，优先用单调队列！

3. **难点3：DP转移方程怎么来的？**  
   * **分析**：`dp[i]`是前i个元素的最小剩余和。对于第i个元素，有两种选择：  
     - 单独成段：`dp[i-1] + a[i]`（因为长度1，无法删除）。  
     - 和前面c-1个元素成段：`dp[i-c] + (sum[i]-sum[i-c]) - min(i-c+1, i)`（段和减去最小值，加上前i-c个的最小和）。  
   * 💡 **学习笔记**：DP的核心是“状态定义”和“转移选择”，想清楚每个状态的可能来源！


### ✨ 解题技巧总结
- **问题转换**：最小化剩余和 → 最大化删除和，有时候转换问题会更简单！  
- **单调队列**：滑动窗口求最值的“神器”，时间复杂度O(n)，比线段树快！  
- **前缀和**：快速计算区间和，避免重复计算，减少时间复杂度！  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，写了一份**简洁高效的核心代码**，用单调队列维护区间最小值：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Alarm5854、字如其人、Plozia的题解思路，用单调队列优化区间最小值，时间复杂度O(n)。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;
const int MAXN = 1e5 + 10;

LL a[MAXN], sum[MAXN], dp[MAXN];
int q[MAXN], l = 1, r = 0; // 单调队列，l是队首，r是队尾

inline LL read() {
    LL x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + (ch - '0'); ch = getchar(); }
    return x * f;
}

int main() {
    int n = read(), c = read();
    for (int i = 1; i <= n; ++i) {
        a[i] = read();
        sum[i] = sum[i - 1] + a[i]; // 前缀和
        // 维护单调队列：窗口是[i-c+1, i]
        while (l <= r && q[l] + c <= i) l++; // 队首元素超出窗口，弹出
        while (l <= r && a[i] <= a[q[r]]) r--; // 弹出队尾比当前元素大的
        q[++r] = i; // 当前元素入队
    }
    // DP初始化：i < c时，只能单独成段
    for (int i = 1; i < c; ++i) dp[i] = dp[i - 1] + a[i];
    // DP转移
    for (int i = c; i <= n; ++i) {
        // 找到以i结尾的c长度区间的最小值：队首元素（因为队列单调递增）
        LL min_val = a[q[l]];
        // 转移方程：min(单独成段，成c段)
        dp[i] = min(dp[i - 1] + a[i], dp[i - c] + (sum[i] - sum[i - c]) - min_val);
    }
    printf("%lld\n", dp[n]);
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：用`read()`函数快速读入n、c和数组a，计算前缀和sum。  
  2. **单调队列维护**：遍历数组时，维护一个单调递增的队列，队首是当前窗口的最小值。  
  3. **DP初始化**：i < c时，只能单独成段，直接累加a[i]。  
  4. **DP转移**：对于每个i≥c，计算两种选择的最小值，取较小的作为dp[i]。  


<code_intro_selected>
接下来，我们看优质题解中的核心片段，分析它们的亮点：
</code_intro_selected>

**题解一：作者Alarm5854**
* **亮点**：用`minn[i]`数组记录每个i结尾的c长度区间的最小值，代码逻辑清晰。
* **核心代码片段**：
```cpp
for (ll i = 1; i <= n; ++i) {
    while (h <= t && q[h] + c <= i) q[h++] = 0;
    while (h <= t && a[q[t]] >= a[i]) q[t--] = 0;
    q[++t] = i, minn[i] = a[q[h]];
}
for (ll i = 1; i < c; ++i) dp[i] = dp[i - 1] + a[i];
for (ll i = c; i <= n; ++i)
    dp[i] = min(dp[i - c] + s[i] - s[i - c] - minn[i], dp[i - 1] + a[i]);
```
* **代码解读**：  
  - 第一个循环维护单调队列，`minn[i]`是i结尾的c区间最小值。  
  - 第二个循环初始化i < c的情况。  
  - 第三个循环转移：`dp[i]`取两种情况的最小值。  
* 💡 **学习笔记**：用数组记录区间最小值，让转移更直观！

**题解二：作者字如其人**
* **亮点**：把输入、前缀和、单调队列写在同一个循环里，代码超级简洁！
* **核心代码片段**：
```cpp
head=1,tail=0;
for(int i=1;i<=n;i++){
    scanf("%d",&a[i]);
    s[i]=s[i-1]+a[i];
    while(head<=tail&&q[tail]>=a[i])tail--;
    q[++tail]=a[i];
    p[tail]=i;
    while(p[head]<=i-c)head++;
    if(i>=c)minn[i]=q[head];
}
```
* **代码解读**：  
  - 循环中同时处理输入、前缀和、单调队列！`q`存数值，`p`存位置，`minn[i]`是i结尾的c区间最小值。  
* 💡 **学习笔记**：合并循环可以减少代码量，提高效率！

**题解三：作者Plozia**
* **亮点**：用`typedef long long LL`避免溢出，代码规范！
* **核心代码片段**：
```cpp
typedef long long LL;
const int MAXN = 1e5 + 10;
LL a[MAXN], f[MAXN], minn[MAXN], sum[MAXN];
```
* **代码解读**：  
  - `LL`是long long的别名，防止sum或dp溢出（比如a[i]=1e9，n=1e5，sum会到1e14，超过int的范围）。  
* 💡 **学习笔记**：竞赛中一定要注意数据范围，用long long避免溢出！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到算法的运行过程，我设计了一个**FC红白机风格的像素动画**，用8位像素块展示数组、单调队列、DP状态的变化！
</visualization_intro>

### 动画设计方案
**主题**：像素探险家整理“数字矿石”，每c块矿石可以去掉最“轻”的一块，让总重量最小！

#### 1. 场景与UI初始化（FC风格）
- **背景**：浅灰色网格，模拟FC游戏的背景。  
- **数组展示**：用彩色像素块表示数组元素，每个块的颜色深浅代表数值大小（越浅越小）。  
- **控制面板**：底部有四个按钮：「单步」「自动」「重置」「调速」（滑块），旁边显示当前i的值和dp[i]的大小。  
- **单调队列**：右侧用蓝色像素块展示队列中的元素，队首是红色（最小值）。  
- **音效**：背景是轻快的8位BGM（比如《超级马里奥》的小关卡音乐）。

#### 2. 算法步骤动态演示
- **初始化**：数组块全部显示，队列空，dp[0]=0。  
- **处理i=1**：  
  1. 输入a[1]，sum[1] = a[1]。  
  2. 单调队列加入1，队首是1（a[1]）。  
  3. dp[1] = dp[0] + a[1]（单独成段），dp[1]的像素块亮起。  
  4. 音效：“叮”（输入） + “嗒”（DP转移）。  
- **处理i=c**：  
  1. 输入a[c]，sum[c] = sum[c-1] + a[c]。  
  2. 单调队列维护：弹出超出窗口的元素，加入c，队首是最小值的位置。  
  3. dp[c] = min(dp[c-1]+a[c], dp[0] + (sum[c]-sum[0]) - min_val)（两种选择）。  
  4. 动画：用箭头从c-1和0指向c，显示两种转移的数值，最终dp[c]的块显示较小的值。  
  5. 音效：“叮”（输入） + “嗖”（队列维护） + “嗒嗒”（两种转移）。  
- **处理i=n**：  
  1. 完成所有i的处理，dp[n]的块闪烁金色。  
  2. 音效：“胜利音乐”（FC风格的短旋律）。

#### 3. 交互设计
- **单步**：点击后执行下一步，适合仔细观察。  
- **自动**：按滑块速度自动播放，速度从“慢”（1秒一步）到“快”（0.1秒一步）。  
- **重置**：回到初始状态，重新开始。  
- **提示**：每步有文字气泡（比如“现在处理i=5，单调队列的最小值是a[3]！”）。

#### 4. 游戏化元素
- **关卡**：把处理i从1到n分成3个小关卡（比如1~c，c+1~2c，2c+1~n），完成一个关卡后显示“关卡完成！”的像素动画。  
- **积分**：每正确选择转移方式（比如选c段更优），加10分，积分显示在右上角。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“DP+滑动窗口”的思路后，你可以尝试以下类似问题，巩固技巧：
</similar_problems_intro>

### 通用思路迁移
- **滑动窗口求最值**：比如求数组中每个长度为k的子数组的最大值/最小值。  
- **DP+区间查询**：比如求数组的最小分割和，需要快速查询区间信息（和、最值、数量等）。  
- **问题转换**：比如把“最小化剩余和”转换成“最大化删除和”，把复杂问题简化。

### 洛谷练习推荐
1. **洛谷 P1886 滑动窗口 /【模板】单调队列**  
   * 🗣️ **推荐理由**：单调队列的模板题，帮你巩固“滑动窗口求最值”的核心逻辑！  
2. **洛谷 P3572 [POI2014]PTA-Little Bird**  
   * 🗣️ **推荐理由**：DP+单调队列优化的经典题，需要用单调队列维护DP的转移状态！  
3. **洛谷 P2627 修剪草坪**  
   * 🗣️ **推荐理由**：类似的“分割问题”，需要用DP+单调队列求最优解，锻炼你的问题转换能力！  


## 7. 学习心得与经验分享 (若有)
> **参考经验（来自题解作者）**：  
> “我一开始没注意到数据范围，用int存sum，结果溢出了，后来改成long long才过！”  
> **点评**：这是竞赛中常见的错误！当a[i]很大（比如1e9）或n很大（比如1e5）时，sum或dp的值会超过int的范围（int最大是2e9左右），一定要用long long！  


<conclusion>
本次分析就到这里啦！这道题的核心是“想通最优分割策略”和“用单调队列优化区间最小值”。记住：遇到分割问题，先分析不同长度的段对结果的影响；滑动窗口求最值，优先用单调队列！  

下次我们再一起探索更有趣的算法问题！💪
</conclusion>

---
处理用时：111.90秒
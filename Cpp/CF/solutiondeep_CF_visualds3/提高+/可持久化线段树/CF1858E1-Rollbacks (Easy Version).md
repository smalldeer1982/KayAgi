# 题目信息

# Rollbacks (Easy Version)

## 题目描述

这是该问题的简单版本。唯一的区别在于，你需要在在线模式下解决困难版本。只有当你同时解决了两个版本的问题时，才能进行 hack。

你有一个初始为空的数组 $a$。你需要处理以下几种类型的操作：

- ```+ x``` —— 将整数 $x$ 添加到数组 $a$ 的末尾。
- ```- k``` —— 从数组 $a$ 的末尾移除最后 $k$ 个数。
- ```!``` —— 撤销上一次有效的更改（即使数组 $a$ 恢复到更改前的状态）。在本题中，只有前两种类型（+ 和 -）的操作被视为更改。
- ```?``` —— 查询当前数组 $a$ 中不同数字的个数。

## 说明/提示

在第一个样例中，数组 $a$ 的变化如下：

1. 第一次操作后，$a=[1]$。
2. 第二次操作后，$a=[1,2]$。
3. 第三次操作后，$a=[1,2,2]$。
4. 第四次操作时，数组 $a$ 中有 $2$ 个不同的整数：$1$ 和 $2$。
5. 第五次操作后，$a=[1,2]$（撤销了 +2 的更改）。
6. 第六次操作后，$a=[1,2,3]$。
7. 第七次操作后，$a=[1]$。
8. 第八次操作时，数组 $a$ 中只有一个 $1$。
9. 第九次操作后，$a=[1,1]$。
10. 第十次操作时，数组 $a$ 中只有两个 $1$。

在第二个样例中，数组 $a$ 的变化如下：

1. 第一次操作后，$a=[1]$。
2. 第二次操作后，$a=[1,1\,000\,000]$。
3. 第三次操作时，数组 $a$ 中有 $2$ 个不同的整数：$1$ 和 $1\,000\,000$。
4. 第四次操作后，$a=[1]$（撤销了 +1000000 的更改）。
5. 第五次操作后，$a=[]$（撤销了 +1 的更改）。
6. 第六次操作时，数组 $a$ 中没有整数，因此答案为 $0$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
10
+ 1
+ 2
+ 2
?
!
+ 3
- 2
?
+ 1
?```

### 输出

```
2
1
1```

## 样例 #2

### 输入

```
6
+ 1
+ 1000000
?
!
!
?```

### 输出

```
2
0```

# AI分析结果


### 💡 Kay的C++算法解析：Rollbacks (Easy Version) 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`操作树建模` + `倍增技术` + `离线DFS`  
🗣️ **初步分析**：
> 这道题像在玩一个"数组积木游戏"：每次添加/移除积木（数字），偶尔需要回退上一步操作，还要快速统计当前积木堆中有几种颜色（不同数字）。  
> - **核心思路**：将操作序列转化为树形结构（操作树），每个节点代表一个操作后的数组状态。撤销操作通过栈实现时光倒流，删除操作通过倍增技术快速跳转祖先节点。  
> - **可视化设计**：像素化操作树，当前节点高亮显示，添加/删除操作时播放8位音效。DFS遍历时用颜色标记计数桶变化（如新增数字时亮黄色闪烁）。

---

#### 2. 精选优质题解参考
**题解一 (Hisaishi_Kanade)**  
* **点评**：  
  思路直击本质——操作树建模（节点=状态，边=操作）。亮点在于：  
  - **倍增跳转**：用`f[i][k]`存储祖先信息，删除操作时O(log k)跳转（类似超级马里奥跳台阶）  
  - **离线DFS**：一次性完成所有查询，避免在线处理的高复杂度  
  - **代码规范**：`cnt[]`桶计数清晰，`ret`变量实时维护不同数字数  
  > 💡 学习价值：操作树抽象能力 + 倍增模板应用

**题解二 (Xy_top)**  
* **点评**：  
  与题解一同源但更简洁。亮点：  
  - **栈维护操作链**：`stack<int> st`直接记录状态指针，撤销即弹出栈顶  
  - **莫队式计数**：`add()`/`rem()`函数封装计数逻辑（像积木计数员）  
  > 💡 学习价值：栈的巧妙应用 + 计数逻辑模块化

**题解三 (zhicheng)**  
* **点评**：  
  独辟蹊径用可持久化线段树。亮点：  
  - **版本化管理**：`rt[]`数组存储历史版本根节点，回滚直接切换版本  
  - **Map优化**：用`map`避免叶子节点冗余存储  
  > 💡 学习价值：可持久化数据结构思想（适合进阶学习）

---

#### 3. 核心难点辨析与解题策略
1. **难点1：高效支持撤销操作**  
   * **分析**：撤销需回退状态。优质解用**操作栈**记录历史指针（如`st.push(p)`），撤销时直接弹出栈顶（时光倒流按钮）
   * 💡 学习笔记：栈是处理"操作回退"的天然结构

2. **难点2：快速删除末尾k个元素**  
   * **分析**：本质是跳转到k级祖先。通过**倍增预处理**`f[i][j] = f[f[i][j-1]][j-1]`，实现O(log k)跳转
   * 💡 学习笔记：倍增是"树上高速电梯"

3. **难点3：实时统计不同数字数**  
   * **分析**：维护全局计数变量`ret`，在DFS时动态更新：
     ```cpp
     void add(int x){ if(cnt[x]==0) ret++; cnt[x]++; } // 新增颜色
     void del(int x){ cnt[x]--; if(cnt[x]==0) ret--; } // 颜色消失
     ```
   * 💡 学习笔记：计数变量随操作同步更新比每次重新扫描更高效

### ✨ 解题技巧总结
- **树形建模法**：将线性操作序列转化为树，利用父子关系回溯状态  
- **倍增预处理**：用空间换时间，加速树上跳转  
- **离线处理**：先读入所有操作再统一处理，避免在线算法复杂度瓶颈  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <vector>
#include <stack>
using namespace std;
const int N=1e6+5, K=20;

int f[N][K], val[N], cnt[N], ans[N], ret; // f:倍增祖先 val:节点值 
vector<int> tree[N]; // 操作树
stack<int> stk; // 操作历史栈

void dfs(int u){
    if(u) add(val[u]); // 进入节点：计数
    ans[u] = ret;      // 记录当前答案
    for(int v: tree[u]) dfs(v); // 遍历子树
    if(u) del(val[u]); // 回溯：恢复计数
}

int main(){
    int cur=0, q; stk.push(0);
    while(q--){
        char op; int x;
        if(op=='+'){
            f[++idx][0]=cur; 
            for(int j=1;j<K;j++) // 倍增预处理
                f[idx][j]=f[f[idx][j-1]][j-1];
            cur = idx; stk.push(cur);
        }
        else if(op=='-'){ 
            for(int j=0;x;j++) 
                if(x>>j&1) cur=f[cur][j]; // 倍增跳转
            stk.push(cur);
        }
        else if(op=='!') stk.pop(), cur=stk.top(); // 撤销
        else if(op=='?') printf("%d\n", ans[cur]); 
    }
    dfs(0); // 离线处理查询
}
```

**题解一片段赏析**  
```cpp
void add(int id){
    if(!cnt[id]) ret++; // 首次出现则增加计数
    cnt[id]++; 
}
void dfs(int u){
    if(u) add(val[u]); // 进入节点时添加数字
    ans[u] = ret;      // 记录当前状态答案
    for(int v: tree[u]) dfs(v); 
    if(u) del(val[u]); // 回溯时删除数字
}
```
> **解读**：  
> - `add/del`函数封装计数逻辑：像仓库管理员记录货物种类  
> - DFS时**前序添加，后序删除**：保证遍历到节点u时，`cnt`恰好是u到根路径上的数字集合  
> 💡 学习笔记：DFS序与操作路径的完美契合

---

#### 5. 算法可视化：像素动画演示  
* **主题**："操作树大冒险"（8-bit像素风）  
* **核心演示**：  
  ![操作树可视化](https://via.placeholder.com/400x200?text=Pixel+操作树)  
  - **动态节点**：当前节点闪烁绿光，添加操作时节点向右生长（+1音效）  
  - **删除跳转**：红色箭头沿倍增路径跳转祖先（咔哒音效）  
  - **计数桶**：右侧桶内彩色方块代表数字，新增时闪烁+旋转  
* **交互设计**：  
  - **控制面板**：步进执行/暂停/速度条（FC手柄风格按钮）  
  - **自动演示**：AI小人沿DFS路径遍历，到达查询节点时显示`ans[u]`  
  > 💡 设计意义：像素化操作树使抽象结构具象化，音效强化操作反馈

---

#### 6. 拓展练习  
1. **洛谷 P3919**（可持久化数组）  
   → 巩固操作树思想  
2. **洛谷 P3379**（LCA模板题）  
   → 熟练掌握倍增技术  
3. **洛谷 P1903**（数颜色/维护队列）  
   → 拓展莫队计数技巧  

---

#### 7. 学习心得  
> **Hisaishi_Kanade经验**：  
> *"倍增数组预处理时边界处理易错，通过打印`f[i][j]`的值验证跳转逻辑"*  
> 💡 Kay总结：调试树形结构时，**可视化中间状态**（如打印祖先链）比盲目检查代码更有效  

---  
算法世界像搭积木，既要大胆构建新结构，也要留好"撤销按钮"。掌握操作树与倍增，你就能在数据流中自由穿梭！🚀

---
处理用时：107.70秒
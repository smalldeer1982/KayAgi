# 题目信息

# Closest Equals

## 题目描述

You are given sequence $ a_{1},a_{2},...,a_{n} $ and $ m $ queries $ l_{j},r_{j} $ ( $ 1<=l_{j}<=r_{j}<=n $ ). For each query you need to print the minimum distance between such pair of elements $ a_{x} $ and $ a_{y} $ ( $ x≠y $ ), that:

- both indexes of the elements lie within range \[ $ l_{j},r_{j} $ \], that is, $ l_{j}<=x,y<=r_{j} $ ;
- the values of the elements are equal, that is $ a_{x}=a_{y} $ .

The text above understands distance as $ |x-y| $ .

## 样例 #1

### 输入

```
5 3
1 1 2 3 2
1 5
2 4
3 5
```

### 输出

```
1
-1
2
```

## 样例 #2

### 输入

```
6 5
1 2 1 3 2 3
4 6
1 3
2 5
2 4
1 6
```

### 输出

```
2
2
3
-1
2
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Closest Equals 深入学习指南 💡

<introduction>
今天我们来一起分析“Closest Equals”这道C++编程题。这道题要求我们在给定的序列中处理多个区间查询，找出每个区间内相同元素的最小距离。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`离线处理+线段树/ST表` (属于“编程技巧应用”与“数据结构运用”的结合)

🗣️ **初步分析**：
解决“Closest Equals”的关键在于高效处理多个区间查询，找到相同元素的最小距离。简单来说，我们需要将查询离线（按右端点排序），并利用数据结构（如线段树或ST表）维护区间最小值。  

在本题中，核心思路是：  
1. **预处理pre数组**：`pre[i]`表示元素`a[i]`上一次出现的位置。若`a[i]`之前未出现过，`pre[i]=0`。  
2. **离线处理查询**：将所有查询按右端点从小到大排序，这样我们可以逐步处理每个右端点，并维护当前所有可能的最小距离。  
3. **数据结构维护**：对于每个右端点`i`，若`pre[i]≠0`，则将`pre[i]`位置的值更新为`i-pre[i]`（即这对相同元素的距离），然后用线段树或ST表查询区间`[l, r]`的最小值。  

核心难点在于如何高效维护动态更新的最小距离，并快速响应区间查询。可视化方案中，我们可以用像素方块表示数组元素，用不同颜色标记`pre[i]`的位置，线段树节点用层叠的小方块展示，更新时用闪烁动画提示，查询时用箭头高亮当前区间。

---

## 2. 精选优质题解参考

<eval_intro>
通过对各题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解因逻辑简洁、实现高效被选为优质参考（≥4星）：
</eval_intro>

**题解一：Owen_codeisking（赞38）**
* **点评**：此题解思路清晰，采用离线线段树处理。通过预处理`pre`数组，将查询按右端点排序，逐步更新线段树中的最小值。代码规范（如`pre`、`pos`等变量名直观），边界处理严谨（如`memset(sum, inf, sizeof(sum))`初始化线段树），时间复杂度为O(n log n)，适合竞赛直接使用。亮点在于离线排序与线段树的巧妙结合，有效降低了复杂度。

**题解二：wsyhb（赞17）**
* **点评**：此题解另辟蹊径，利用ST表+二分法。通过预处理相同元素的相邻位置（形成“线段”），并保证线段右端点递增，从而用二分快速定位查询区间，再用ST表求区间最小值。代码简洁（如`init`函数预处理ST表），时间复杂度O(n log n)，适合学习ST表的应用。亮点是线段去重优化，减少了无效数据。

**题解三：LawrenceSivan（赞7）**
* **点评**：此题解尝试回滚莫队算法，虽常数较大但思路新颖。通过分块处理，维护左右块的统计信息，处理跨块贡献。代码中`Add`、`Del`等函数模块化程度高，适合理解莫队算法的变形。亮点是对“最近距离”的分块统计，适合拓展思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，我们常遇到以下核心难点。结合优质题解的共性，提炼出关键策略：
</difficulty_intro>

1.  **关键点1：如何预处理pre数组？**
    * **分析**：`pre[i]`表示`a[i]`上一次出现的位置。可以通过哈希表（如`map`或数组）记录每个值最后一次出现的索引，遍历数组时更新`pre[i]`。例如，遍历到`a[i]`时，若之前出现过，则`pre[i]`设为该位置，否则为0。  
    * 💡 **学习笔记**：预处理`pre`数组是离线处理的基础，需确保每个元素的前一个位置被正确记录。

2.  **关键点2：如何离线处理查询？**
    * **分析**：将查询按右端点排序后，我们可以按顺序处理每个右端点`i`，并维护所有以`i`为右端点的查询。这样，每次处理`i`时，只需将`pre[i]`位置的线段树值更新为`i-pre[i]`，确保后续查询能覆盖到这对元素。  
    * 💡 **学习笔记**：离线排序将动态查询转化为静态处理，是降低复杂度的关键技巧。

3.  **关键点3：如何高效维护区间最小值？**
    * **分析**：线段树或ST表是常用选择。线段树支持单点更新和区间查询（O(log n)），适合动态维护；ST表预处理后查询O(1)，适合静态数据（如wsyhb的线段去重后）。根据场景选择数据结构。  
    * 💡 **学习笔记**：数据结构的选择需结合问题特性（动态/静态），线段树更灵活，ST表更高效。

### ✨ 解题技巧总结
- **问题分解**：将原问题分解为预处理`pre`数组、离线排序查询、数据结构维护三部分，降低复杂度。  
- **离线处理**：按右端点排序查询，将动态问题转化为静态，简化处理逻辑。  
- **数据结构优化**：根据需求选择线段树（动态）或ST表（静态），提升效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解前，先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合Owen_codeisking的线段树思路，结构清晰，适合直接学习。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 5e5 + 10;
    const int INF = 0x3f3f3f3f;

    int n, m, a[MAXN], pre[MAXN], pos[MAXN], ans[MAXN];
    int sum[MAXN << 2]; // 线段树数组

    struct Query { int l, id; };
    vector<Query> q[MAXN]; // 按右端点分组的查询

    void pushup(int rt) { sum[rt] = min(sum[rt << 1], sum[rt << 1 | 1]); }

    void modify(int x, int v, int l, int r, int rt) {
        if (l == r) { sum[rt] = v; return; }
        int mid = (l + r) >> 1;
        if (x <= mid) modify(x, v, l, mid, rt << 1);
        else modify(x, v, mid + 1, r, rt << 1 | 1);
        pushup(rt);
    }

    int query(int L, int R, int l, int r, int rt) {
        if (L <= l && r <= R) return sum[rt];
        int mid = (l + r) >> 1, res = INF;
        if (L <= mid) res = min(res, query(L, R, l, mid, rt << 1));
        if (R > mid) res = min(res, query(L, R, mid + 1, r, rt << 1 | 1));
        return res;
    }

    int main() {
        n = read(), m = read();
        // 离散化处理
        vector<int> tmp(a + 1, a + n + 1);
        sort(tmp.begin(), tmp.end());
        tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());
        for (int i = 1; i <= n; ++i) 
            a[i] = lower_bound(tmp.begin(), tmp.end(), a[i]) - tmp.begin() + 1;
        
        // 预处理pre数组
        memset(pos, 0, sizeof(pos));
        for (int i = 1; i <= n; ++i) {
            pre[i] = pos[a[i]];
            pos[a[i]] = i;
        }

        // 离线处理查询
        for (int i = 1; i <= m; ++i) {
            int l = read(), r = read();
            q[r].push_back({l, i});
        }

        // 初始化线段树
        memset(sum, 0x3f, sizeof(sum));
        for (int i = 1; i <= n; ++i) {
            if (pre[i]) modify(pre[i], i - pre[i], 1, n, 1);
            for (auto &query : q[i]) 
                ans[query.id] = query(query.l, i, 1, n, 1);
        }

        // 输出结果
        for (int i = 1; i <= m; ++i) 
            printf("%d\n", ans[i] == INF ? -1 : ans[i]);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先离散化数组，预处理`pre`数组记录每个元素的前一个位置。然后将查询按右端点分组，用线段树维护每个`pre[i]`位置的最小距离。遍历每个右端点`i`时，更新线段树并处理所有以`i`为右端点的查询，最后输出结果。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段，理解其亮点。
</code_intro_selected>

**题解一：Owen_codeisking（来源：用户题解）**
* **亮点**：线段树动态更新，离线处理查询，时间复杂度O(n log n)。  
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= n; ++i) {
        if (pre[i]) modify(pre[i], i - pre[i], 1, n, 1);
        for (auto &query : q[i]) 
            ans[query.id] = query(query.l, i, 1, n, 1);
    }
    ```
* **代码解读**：  
  遍历每个右端点`i`时，若`pre[i]`存在（即`a[i]`之前出现过），则将`pre[i]`位置的线段树值更新为`i-pre[i]`（这对元素的距离）。然后处理所有以`i`为右端点的查询，查询区间`[l, i]`的最小值。  
  **思考**：为什么选择在`pre[i]`位置更新？因为`pre[i]`是`a[i]`的前一个位置，这对元素的距离是`i-pre[i]`，而后续查询的右端点≥`i`，所以`pre[i]`位置的值会被正确覆盖。  
* 💡 **学习笔记**：线段树的单点更新与离线查询的结合，确保了每个查询能及时获取当前最小距离。

**题解二：wsyhb（来源：用户题解）**
* **亮点**：ST表+二分，线段去重优化，时间复杂度O(n log n)。  
* **核心代码片段**：
    ```cpp
    int x = lower_bound(l + 1, l + cnt + 1, L) - l;
    int y = upper_bound(r + 1, r + cnt + 1, R) - r - 1;
    if (x <= y) printf("%d\n", query(x, y));
    else puts("-1");
    ```
* **代码解读**：  
  预处理所有相同元素的相邻位置（形成线段`l[i]`和`r[i]`），并保证线段右端点递增。查询时，用二分找到所有左端点≥`L`且右端点≤`R`的线段，再用ST表查询这些线段的最小长度。  
  **思考**：为什么线段右端点递增？因为去重后，若线段`i`的右端点≥线段`i+1`的右端点，则线段`i`会被覆盖，保留更短的线段`i+1`。  
* 💡 **学习笔记**：线段去重减少了无效数据，ST表的O(1)查询提升了效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解离线线段树的处理过程，我们设计一个“像素小探险家”主题的8位像素动画，模拟查询和更新过程。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的距离挑战`（8位FC风格）

  * **核心演示内容**：  
    展示`pre`数组的预处理、查询按右端点排序、线段树更新和区间查询的全过程。例如，当小探险家到达右端点`i`时，更新`pre[i]`位置的距离值，并处理所有以`i`为终点的查询。

  * **设计思路简述**：  
    8位像素风格（红/蓝/绿主色调）营造复古感；关键操作（如线段树更新、查询）用闪烁像素块提示；音效（“叮”声表示更新，“滴”声表示查询）强化记忆；自动播放模式模拟算法执行，单步模式可逐帧观察。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为三部分：顶部是原数组（像素方块，颜色代表值），中间是线段树（层叠的小方块，显示当前最小值），底部是控制面板（开始/暂停、单步、速度滑块）。  
        - 播放8位风格背景音乐（如《超级玛丽》主题变奏）。

    2.  **pre数组预处理**：  
        - 遍历原数组，每个方块`a[i]`出现时，若之前出现过，用黄色箭头连接到`pre[i]`位置，并显示距离`i-pre[i]`。

    3.  **查询排序**：  
        - 右侧展示所有查询（白色小旗），按右端点从小到大排序，用绿色箭头移动到对应位置。

    4.  **线段树更新与查询**：  
        - 当处理右端点`i`时，若`pre[i]`存在，线段树中`pre[i]`位置的小方块颜色变为橙色（表示更新），并显示新值`i-pre[i]`，伴随“叮”声。  
        - 处理查询时，用蓝色框框住查询区间`[l, r]`，线段树节点逐层缩小范围，最终顶部显示最小值，伴随“滴”声。

    5.  **结果输出**：  
        - 查询完成后，屏幕底部显示结果（绿色表示有效距离，红色表示-1），播放“胜利”音效（如《魂斗罗》得分音）。

  * **旁白提示**：  
    - “看！当小探险家走到位置`i`，他发现`a[i]`之前出现在`pre[i]`，于是更新线段树中的`pre[i]`位置为`i-pre[i]`。”  
    - “现在处理一个查询`[l, r]`，线段树会帮我们找到`l`到`r`之间的最小值，这就是答案！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到离线线段树如何动态维护最小距离，理解每个步骤的作用。这种有趣的方式能帮助我们更快掌握算法核心！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以将思路迁移到其他需要离线处理或区间查询的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的离线处理（按右端点排序）和线段树维护区间最小值的方法，可用于以下场景：  
    1. 区间内相同元素的最远距离（如HH的项链变形）；  
    2. 区间内满足特定条件的元素对统计（如和为定值的最小距离）；  
    3. 动态数组的区间最值查询（如支持单点修改的最值问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1972 [SDOI2009]HH的项链**  
        * 🗣️ **推荐理由**：同样需要离线处理查询，按右端点排序后用树状数组维护，巩固离线处理技巧。
    2.  **洛谷 P1816 忠诚**  
        * 🗣️ **推荐理由**：经典的区间最值查询问题，适合练习ST表的应用。
    3.  **洛谷 P3865 [TJOI2008] 线段树**  
        * 🗣️ **推荐理由**：结合线段树的区间最值查询，强化数据结构的灵活运用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是有价值的参考：
</insights_intro>

> **参考经验 (来自用户LawrenceSivan)**：“一开始用回滚莫队时WA了，后来发现是左右块统计时漏掉了跨块贡献。调试时打印中间变量，发现左块的`cntl_t`和右块的`cntr`没有正确关联，修正后通过。”  
> **点评**：这位作者的经验提醒我们，在处理分块或分治问题时，跨块/跨区间的贡献容易被忽略。通过打印中间变量（如`cntl_t`、`cntr`）可以有效定位错误，这是调试复杂算法的重要技巧。

-----

<conclusion>
本次关于“Closest Equals”的C++解题分析就到这里。希望这份指南能帮助大家理解离线处理、线段树/ST表的应用，以及如何将复杂问题分解为可处理的步骤。记住，多动手实践、调试，才能真正掌握算法！下次见~ 💪
</conclusion>

---
处理用时：135.34秒
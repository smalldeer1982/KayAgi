# 题目信息

# Complete Tripartite

## 题目描述

给定一个包含 $n$ 个顶点和 $m$ 条边的简单无向图。该图不包含自环，任意一对顶点之间至多有一条边。该图可以是不连通的。

我们定义如下：

设 $v_1$ 和 $v_2$ 是两个不相交的非空顶点集合。若且仅若满足以下所有条件，称 $f(v_1, v_2)$ 成立：

1. 在顶点集合 $v_1$ 内没有两端都在 $v_1$ 的边。
2. 在顶点集合 $v_2$ 内没有两端都在 $v_2$ 的边。
3. 对于任意 $x \in v_1$ 和 $y \in v_2$，$x$ 和 $y$ 之间有一条边。

请将所有顶点划分为三个集合（$v_1$，$v_2$，$v_3$），使得满足以下条件：

1. 每个集合都非空。
2. 每个顶点恰好属于一个集合。
3. $f(v_1, v_2)$、$f(v_2, v_3)$、$f(v_3, v_1)$ 都成立。

是否存在这样的划分？如果存在，请输出每个顶点所属的集合编号。

## 说明/提示

在第一个样例中，如果 $v_1 = \{1\}$，$v_2 = \{2, 3\}$，$v_3 = \{4, 5, 6\}$，则所有条件都满足。但你也可以用不同的方式划分顶点集合；例如 “2 3 3 1 1 1” 也是合法答案。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1228D/c2c365eaf8464b0509392f3446fceb5e5d58fe78.png)

在第二个样例中，不可能划分出满足条件的顶点集合。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
6 11
1 2
1 3
1 4
1 5
1 6
2 4
2 5
2 6
3 4
3 5
3 6
```

### 输出

```
1 2 2 3 3 3 ```

## 样例 #2

### 输入

```
4 6
1 2
1 3
1 4
2 3
2 4
3 4
```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：Complete Tripartite 深入学习指南 💡

<introduction>
今天我们来一起分析「Complete Tripartite」这道C++编程题。题目要求将图的顶点分成三个非空集合，使得任意两个集合之间是“完全相连”的（两集合内的点两两有边），且集合内部“互不相连”。本指南将帮助大家梳理解题思路、理解核心性质，并掌握验证技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（完全三分图的判定与划分）

🗣️ **初步分析**：
解决这道题的关键，是理解**完全三分图的两个核心性质**：
1. **同一集合内的点，邻接表完全相同**：比如集合1的点不能互相连边，且必须与集合2、3的所有点连边，因此它们的邻接点都是“集合2+集合3”的全部点，邻接表自然相同。
2. **不与某点相连的点，必和它在同一集合**：如果点A和点B不相连，根据题目要求，它们必须在同一集合（否则A和B属于不同集合，必须有边）。

常见的解题思路分为两类：
- **特征分组法**：将每个点的邻接表排序后作为“特征”，相同特征的点分在同一集合（HenryHuang的题解）。
- **逐步划分法**：先找集合1（不与点1相连的点），再找集合2（不与集合2中的点相连且不在集合1的点），最后分集合3，再验证（Steven_Meng、Llf0703的题解）。

**核心难点**：
- 如何正确划分集合？（依赖完全三分图的性质）
- 如何验证划分的正确性？（需检查集合非空、边数匹配、内部无连接、跨集合全连接）
- 如何处理不连通的图？（完全三分图必须连通，否则直接无解）

**可视化设计思路**：
用8位像素风格模拟图的划分过程——  
- 顶点用白色方块表示，边用灰色线连接；
- 划分集合时，用红/蓝/绿三色标记不同集合，当前处理的点高亮（比如点1高亮为黄色）；
- 验证步骤中，错误的边/点会闪烁（比如同一集合内的边闪烁红色）；
- 交互控制：单步执行、自动播放（速度滑块）、重置，搭配“叮”（划分成功）、“滴”（错误）等像素音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮大家快速理解不同解法的核心。
</eval_intro>

**题解一：HenryHuang（赞7）**  
* **点评**：思路非常巧妙！利用“同一集合内点的邻接表相同”的性质，将每个点的邻接表排序后作为“特征”，用`basic_string`存储并排序，相同特征的点自动分组。代码超短（仅30行核心逻辑），且可扩展到k分图。唯一需要注意的是**特判孤立点**（邻接表为空的点无法划分，直接输出-1）。

**题解二：End1essSummer（赞4）**  
* **点评**：时间复杂度O(m)的高效解法！利用“不与某点相连的点必同集合”的性质：先找集合1（不与点1相连的点），再从集合2的点中找集合3（不与该点相连且不在集合1的点），最后验证边的合法性。步骤明确，适合处理大数据。

**题解三：Steven_Meng（赞1）**  
* **点评**：验证步骤最全面的解法！先通过DFS判图连通（不连通则无解），再分集合1（不与点1相连的点）、集合3（与集合2中的点相连且不在集合1的点），最后验证：①集合非空；②边数等于`cnt1*cnt2 + cnt2*cnt3 + cnt3*cnt1`（完全三分图的边数公式）；③同一集合内无连接；④跨集合全连接。代码规范，覆盖所有错误情况。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“抓性质+严验证”，以下是3个核心难点及解决方案：
</difficulty_intro>

1. **难点1：如何正确划分集合？**  
   * **分析**：依赖完全三分图的性质——同一集合内的点邻接表相同（特征分组法），或不与某点相连的点必同集合（逐步划分法）。比如HenryHuang的题解用排序后的邻接表作为特征，直接分组；Steven_Meng的题解用点1的非邻接点作为集合1。  
   * 💡 **学习笔记**：找对“同一集合的共同特征”是划分的关键。

2. **难点2：如何验证划分的正确性？**  
   * **分析**：需验证4个条件：
     - 三个集合均非空；
     - 边数等于`cnt1*cnt2 + cnt2*cnt3 + cnt3*cnt1`（完全三分图的边数是三个完全二分图的边数之和）；
     - 同一集合内的点之间没有边；
     - 不同集合内的任意两点之间都有边。  
     比如Steven_Meng的题解用`c[ans[i]]`统计同一集合内的边数，用`c[2] == cnt2`验证跨集合全连接。  
   * 💡 **学习笔记**：验证是避免错误的最后一道防线，必须覆盖所有条件。

3. **难点3：如何处理不连通的图？**  
   * **分析**：完全三分图是连通的（除非有孤立点，但孤立点会导致邻接表为空，需特判）。比如Steven_Meng的题解用DFS遍历图，若有未遍历的点，直接输出-1。  
   * 💡 **学习笔记**：连通性是完全三分图的前提，必须先判连通。

### ✨ 解题技巧总结
- **抓性质**：利用完全三分图的特征（邻接表相同、不相连必同集合）简化问题；
- **严验证**：划分后必须检查所有条件；
- **处理边界**：孤立点、不连通图需特判。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合版核心代码**，结合了“特征分组+连通性判断+全面验证”的思路，适合快速理解整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合HenryHuang的特征分组法和Steven_Meng的验证逻辑，兼顾简洁性与正确性。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <cstring>
  using namespace std;

  const int MAXN = 1e5 + 5;
  vector<int> G[MAXN];
  bool vis[MAXN];
  int col[MAXN], cnt[4];
  vector<pair<vector<int>, int>> adj;

  void dfs(int u) {
      vis[u] = true;
      for (int v : G[u]) if (!vis[v]) dfs(v);
  }

  int main() {
      ios::sync_with_stdio(false); cin.tie(0);
      int n, m; cin >> n >> m;
      for (int i = 0; i < m; ++i) {
          int u, v; cin >> u >> v;
          G[u].push_back(v); G[v].push_back(u);
      }

      // 1. 判连通（完全三分图必须连通）
      dfs(1);
      for (int i = 1; i <= n; ++i) if (!vis[i]) { cout << -1 << endl; return 0; }

      // 2. 提取邻接表特征（排序后作为分组依据）
      for (int i = 1; i <= n; ++i) {
          sort(G[i].begin(), G[i].end());
          adj.emplace_back(G[i], i);
      }
      sort(adj.begin(), adj.end());

      // 3. 分组（相同特征的点分同一集合）
      int current = 1;
      col[adj[0].second] = current; cnt[current]++;
      for (int i = 1; i < n; ++i) {
          if (adj[i].first == adj[i-1].first) {
              col[adj[i].second] = current; cnt[current]++;
          } else {
              current++;
              if (current > 3) { cout << -1 << endl; return 0; }
              col[adj[i].second] = current; cnt[current]++;
          }
      }

      // 4. 验证条件
      if (current != 3 || cnt[1] == 0 || cnt[2] == 0 || cnt[3] == 0) { cout << -1 << endl; return 0; }
      if (1LL * cnt[1] * cnt[2] + 1LL * cnt[2] * cnt[3] + 1LL * cnt[3] * cnt[1] != m) { cout << -1 << endl; return 0; }
      for (int u = 1; u <= n; ++u) {
          for (int v : G[u]) if (col[u] == col[v]) { cout << -1 << endl; return 0; }
      }

      // 5. 输出结果
      for (int i = 1; i <= n; ++i) cout << col[i] << " ";
      cout << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  1. 用DFS判图连通；
  2. 将每个点的邻接表排序后作为“特征”，排序后分组；
  3. 检查是否恰好三个非空集合；
  4. 验证边数、同一集合内无连接；
  5. 输出结果。


<code_intro_selected>
接下来剖析3份优质题解的核心片段，看它们如何用代码实现关键逻辑。
</code_intro_selected>

**题解一：HenryHuang（特征分组）**
* **亮点**：用`basic_string`存储邻接表，排序后快速分组。
* **核心代码片段**：
  ```cpp
  struct cc {
      int id;
      basic_string<int> d;
      bool operator<(const cc& y) const { return d < y.d; }
  } s[MAXN];

  int main() {
      // 加边：s[x].d += y; s[y].d += x;
      for (int i = 1; i <= n; ++i) sort(s[i].d.begin(), s[i].d.end());
      sort(s + 1, s + n + 1);

      int cnt = 1; fa[s[1].id] = 1;
      for (int i = 2; i <= n; ++i) {
          if (s[i].d == s[i-1].d) fa[s[i].id] = fa[s[i-1].id];
          else fa[s[i].id] = ++cnt;
      }
  }
  ```
* **代码解读**：
  - `basic_string<int>`是C++的“整数字符串”，可以像`vector`一样存储邻接表，且支持比较操作；
  - 每个点的邻接表排序后，整体排序`cc`数组，相同`d`（邻接表）的点会被排在一起；
  - 遍历排序后的数组，相同`d`的点分同一集合。
* 💡 **学习笔记**：用“可比较的特征”分组，是处理这类问题的高效方法。

**题解二：End1essSummer（逐步划分）**
* **亮点**：O(m)时间复杂度，利用“不相连必同集合”的性质。
* **核心思路**：
  1. 集合1：不与点1相连的点；
  2. 集合2：选一个与点1相连的点u，不与u相连且不在集合1的点；
  3. 集合3：剩下的点；
  4. 验证所有边的两端点属于不同集合。
* 💡 **学习笔记**：利用图的基本性质，避免复杂计算。

**题解三：Steven_Meng（全面验证）**
* **亮点**：验证步骤覆盖所有条件。
* **核心代码片段**：
  ```cpp
  // 验证集合非空
  if (cnt1 == 0 || cnt2 == 0 || cnt3 == 0) return puts("-1"), 0;
  // 验证边数
  if (cnt1*cnt2 + cnt2*cnt3 + cnt3*cnt1 != m) return puts("-1"), 0;
  // 验证同一集合内无连接、跨集合全连接
  int c[4];
  for (int i = 1; i <= n; ++i) {
      memset(c, 0, sizeof(c));
      for (int j = 0; j < G[i].size(); ++j) c[ans[G[i][j]]]++;
      if (c[ans[i]] != 0) return puts("-1"), 0; // 同一集合内有边
      if (ans[i] == 1 && (c[2] != cnt2 || c[3] != cnt3)) return puts("-1"), 0; // 跨集合未全连接
  }
  ```
* **代码解读**：
  - `c[ans[i]]`统计同一集合内的边数，若不为0则错误；
  - `c[2] == cnt2`验证集合1的点与集合2的所有点相连（因为集合2有cnt2个点，所以c[2]应等于cnt2）。
* 💡 **学习笔记**：验证是确保答案正确的关键，不能省略。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解“完全三分图划分”，我设计了一个**8位像素风格的动画**，模拟“朋友圈分组”的过程，搭配复古音效，让学习更有趣！
</visualization_intro>

### ✨ 动画设计方案
**主题**：像素图的“三分朋友圈”划分（类似FC游戏《迷宫探险》的风格）。  
**核心演示内容**：图的连通性判断→集合划分→条件验证→结果展示。

### 🎮 动画细节设计
1. **场景初始化**：
   - 屏幕显示n个白色像素点（顶点），边用灰色线连接（比如样例1的6个点，11条边）；
   - 控制面板：“开始”“单步”“自动”“重置”按钮，速度滑块（1~5档）；
   - 背景播放8位风格的轻快音乐（类似《超级马里奥》的BGM）。

2. **连通性判断**：
   - 点1高亮为黄色，开始DFS遍历：遍历过的点依次变为浅黄色，伴随“滴答”声；
   - 若有未遍历的点（白色），则屏幕中央显示“图不连通，无解”，播放错误音效（短促的“滴”声），动画终止。

3. **集合划分**：
   - **步骤1（集合1）**：点1保持黄色，不与点1相连的点（无灰色线）变为红色，伴随“叮”声；
   - **步骤2（集合2）**：选点2（与点1相连的点，高亮为蓝色），不与点2相连且不在集合1的点变为蓝色，伴随“叮”声；
   - **步骤3（集合3）**：剩下的点变为绿色，伴随“叮”声。

4. **条件验证**：
   - **验证集合非空**：若某颜色点为0（比如绿色点为0），则该颜色闪烁，显示“集合为空，无解”，播放错误音效；
   - **验证边数**：屏幕右上角显示计算的边数（`cnt1*cnt2 + cnt2*cnt3 + cnt3*cnt1`）和实际边数m，若不等则数字闪烁红色，显示“边数错误”；
   - **验证内部无连接**：遍历所有边，若两端点颜色相同，则该边闪烁红色，显示“同一集合内有边”；
   - **验证跨集合全连接**：遍历每个点，若某点与其他集合的点缺少边，则该点闪烁黄色，显示“跨集合未全连接”。

5. **成功展示**：
   - 所有点闪烁对应颜色（红/蓝/绿），屏幕中央显示“划分成功！”，播放胜利音效（上扬的“叮~”声），背景绽放像素烟花。

### 🕹️ 交互设计
- **单步执行**：点击“单步”按钮，执行一个步骤（比如从连通性判断到集合1划分）；
- **自动播放**：点击“自动”按钮，按速度滑块的速度连续执行步骤；
- **重置**：点击“重置”按钮，回到初始状态。

### 🎵 音效设计
- 连通性判断：“滴答”声（每遍历一个点）；
- 集合划分：“叮”声（每成功划分一个集合）；
- 错误：短促“滴”声；
- 成功：上扬“叮~”声+烟花音效。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
完全三分图的划分思路，可以迁移到**完全k分图判定**、**社交圈子划分**等问题。以下是洛谷上的相似练习：
</similar_problems_intro>

### 🔍 通用思路迁移
- **完全k分图判定**：将集合数从3扩展到k，核心逻辑不变（同一集合内邻接表相同，或不相连必同集合）；
- **社交圈子划分**：同一圈子的人有相同的好友列表，可通过邻接表特征分组。

### 📚 洛谷练习推荐
1. **P1330 封锁阳光大学**  
   🗣️ **推荐理由**：二分图判定问题，需要将图分成两个集合，满足同一集合内无连接。是完全三分图的“简化版”，帮助巩固图划分的思路。

2. **P3386 二分图匹配**  
   🗣️ **推荐理由**：二分图的经典应用，加深对“跨集合全连接”的理解，是完全三分图的基础。

3. **P1197 [JSOI2008] 星球大战**  
   🗣️ **推荐理由**：图的连通性问题，需要用DFS/BFS判连通，巩固本题的“连通性判断”技巧。

4. **P2055 合唱队形**  
   🗣️ **推荐理由**：虽然是动态规划问题，但需要找到序列的划分点，培养“划分问题”的思维。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解作者的宝贵经验，帮大家避免踩坑：
</insights_intro>

> **经验1（HenryHuang）**：“在存在孤立点的图中，算法会有问题，所以要特判！”  
> **点评**：孤立点的邻接表为空，无法与其他点组成完全三分图，必须直接输出-1。这提醒我们**处理边界情况**的重要性。

> **经验2（Steven_Meng）**：“验证步骤不能少！我一开始没验证边数，结果WA了好几次。”  
> **点评**：即使划分了集合，也可能因为边数不匹配而错误。验证是最后一道防线，必须全面。

> **经验3（Llf0703）**：“我就是因为没特判集合为空，炸掉了！”  
> **点评**：三个集合必须非空，否则不符合题目要求。特判集合为空是必要的。


<conclusion>
本次关于「Complete Tripartite」的分析就到这里！通过本题，我们掌握了完全三分图的性质、划分方法和验证技巧。记住：**抓性质+严验证**是解决图划分问题的关键。下次我们再一起探索更有趣的图论问题吧！💪
</conclusion>

---
处理用时：163.39秒
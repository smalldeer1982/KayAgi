# 题目信息

# Simple Skewness

## 题目描述

Define the simple skewness of a collection of numbers to be the collection's mean minus its median. You are given a list of $ n $ (not necessarily distinct) integers. Find the non-empty subset (with repetition) with the maximum simple skewness.

The mean of a collection is the average of its elements. The median of a collection is its middle element when all of its elements are sorted, or the average of its two middle elements if it has even size.

## 说明/提示

In the first case, the optimal subset is ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF626E/0b9550a7a9f20f7b56fdc9073fe6e2b4a2093ee5.png), which has mean $ 5 $ , median $ 2 $ , and simple skewness of $ 5-2=3 $ .

In the second case, the optimal subset is ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF626E/d0a3a979416d48c43b3c8a042caaf404373f99fe.png). Note that repetition is allowed.

In the last case, any subset has the same median and mean, so all have simple skewness of $ 0 $ .

## 样例 #1

### 输入

```
4
1 2 3 12
```

### 输出

```
3
1 2 12 
```

## 样例 #2

### 输入

```
4
1 1 2 2
```

### 输出

```
3
1 1 2 
```

## 样例 #3

### 输入

```
2
1 2
```

### 输出

```
2
1 2
```

# AI分析结果

# 💡 Kay的C++算法解析：Simple Skewness 深入学习指南 💡

<introduction>
  今天我们来攻克一道有趣的算法题——**Simple Skewness**（简单偏度）。题目要求找出数组的一个非空子集，让它的**平均值减中位数**最大。听起来有点抽象？别担心，跟着Kay一步步拆解，你会发现它其实是“贪心策略”和“单峰函数优化”的完美结合！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 单峰函数优化（二分/三分）

🗣️ **初步分析**：
> 简单偏度=平均值-中位数，要最大化这个值，得让**平均值尽可能大**，同时**中位数尽可能小**。就像攒零花钱买玩具：你想平均每天花最多的钱（平均值大），但中间那天花的钱（中位数）尽可能少——这样“平均-中间”的差才会大！

### 关键结论：最优子集一定是奇数长度！
为什么？比如你选了4个元素（偶数），排序后是`[1,2,3,4]`，偏度是`(1+2+3+4)/4 - (2+3)/2 = 2.5 - 2.5 = 0`。但如果去掉中间较大的`3`，变成`[1,2,4]`，偏度是`(1+2+4)/3 - 2 = 7/3 - 2 ≈ 0.33`，反而更大！**数学证明**（见题解）也验证了：任何偶数长度的子集，都能找到更优的奇数长度子集。

### 核心算法流程：
1. **排序**：把数组从小到大排好（比如`[1,2,3,12]`→`[1,2,3,12]`），方便找中位数和选最大元素。
2. **枚举中位数**：每个元素都可能成为子集的中位数（比如`2`作为中位数，子集是`[1,2,12]`）。
3. **贪心选元素**：对于中位数`a[i]`，左边选**最大的k个**（比如`i=2`，左边最大的1个是`1`），右边选**最大的k个**（右边最大的1个是`12`）——这样总和最大，平均值才会最大！
4. **单峰函数优化**：对于每个中位数，k的取值（0到min(i-1, n-i)）对应的平均值是**先增后减**的（像爬山，到山顶后就下坡）。这时候用**二分/三分**快速找到“山顶”（最优k），避免暴力枚举。

### 可视化设计思路：
我们会做一个**8位像素风的“偏度探险家”游戏**：
- 排序用“像素块排队”动画，从小到大排列；
- 枚举中位数时，对应的像素块会“闪烁金光”；
- 二分找k时，用“左右箭头”指示当前尝试的k值，选中的元素会“变蓝”；
- 计算总和时，数值会“跳出来”显示，平均值变化用“上升/下降箭头”表示；
- 找到最优解时，播放“胜利音效”（类似FC游戏的“叮~叮~”），子集元素会“跳舞”！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**、**代码可读性**、**算法有效性**三个维度筛选了3份优质题解，帮你快速掌握核心！
</eval_intro>

### 题解一：TonyYin（O(n²)→O(n log n) 完整推导）
* **点评**：这份题解像“算法说明书”——从暴力O(n²)讲到优化O(n log n)，每一步都有数学证明（比如偶数不如奇数的推导）。代码用**前缀和**快速计算总和（避免重复相加），用**二分**找最优k，变量名`sum`（前缀和）、`ans_mid`（最优中位数位置）都很清晰。特别是它的“贪心选最大元素”思路，直接命中问题本质：要平均值大，就得选两边最大的数！

### 题解二：hanzhongtlx（边界处理+简洁二分）
* **点评**：这份题解的亮点是**边界处理**——专门判断了`n≤2`的情况（比如样例3，n=2时直接输出所有元素）。代码用二分找单峰函数的“山顶”，逻辑简洁：比较k和k+1对应的平均值，哪边大就往哪边找。对于刚学二分的同学，这份代码非常适合模仿！

### 题解三：Starlight_Glimmer（三分法找单峰极值）
* **点评**：这份题解用了**三分法**（而不是二分）找单峰函数的最大值，思路新颖！三分法适合“先增后减”或“先减后增”的函数，比二分更直接。代码中的`tri`函数（三分函数）实现得很巧妙，通过比较两个中间点的函数值，缩小搜索范围。对于想拓展思路的同学，这份题解能帮你打开“优化”的新视野！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于突破3个“思维关卡”。结合优质题解，Kay帮你把“难点”变成“得分点”！
</difficulty_intro>

### 1. 关卡1：为什么偶数长度的子集不如奇数？
* **分析**：假设偶数子集的中位数是`(b_n + b_{n+1})/2`（两个中间数的平均），加入一个数后，要么平均值下降（加了小的数），要么中位数上升（加了大的数），导致偏度减小。**结论**：直接放弃偶数长度，只考虑奇数！
* 💡 **学习笔记**：先排除不可能的情况，能大幅简化问题！

### 2. 关卡2：如何确定每个中位数对应的最优k？
* **分析**：k是左右选的元素数量，对应的平均值是**单峰函数**（先增后减）。比如中位数`2`（样例1）：
  - k=0：子集`[2]`，偏度`2-2=0`；
  - k=1：子集`[1,2,12]`，偏度`5-2=3`（最大）；
  - k=2：超出范围（左边只有1个元素）。
* **策略**：用二分/三分找“山顶”——比较k和k+1的平均值，哪边大就往哪边搜！
* 💡 **学习笔记**：单峰函数用二分/三分，比暴力枚举快100倍！

### 3. 关卡3：如何快速计算总和？
* **分析**：如果每次选k个元素都重新求和，会很慢（O(n²)）。用**前缀和数组**（`sum[i]`表示前i个元素的和），能在O(1)时间内算出任意区间的和！比如左边选k个的和是`sum[i-1] - sum[i-1 -k]`，右边选k个的和是`sum[n] - sum[n -k]`。
* 💡 **学习笔记**：前缀和是“快速求和”的神器，一定要掌握！

### ✨ 解题技巧总结
- **排序是基础**：任何涉及中位数的问题，先排序准没错！
- **贪心选最大**：要平均值大，就选两边最大的元素（别选小的，会拉低平均值）！
- **单峰用二分/三分**：遇到“先增后减”的函数，用二分/三分找极值，复杂度从O(n)降到O(log n)！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——综合了TonyYin的思路，用前缀和、枚举中位数、二分找k，能直接解决问题！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自TonyYin的O(n log n)解法，逻辑清晰，覆盖所有边界情况。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 2e5 + 10;
inline int read() { // 快读函数（处理大数据）
    int ret = 0; char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    while(ch <= '9' && ch >= '0') {
        ret = ret * 10 + ch - '0';
        ch = getchar();
    }
    return ret;
}
int n, a[MAXN], sum[MAXN]; // sum是前缀和数组
signed main() {
    n = read();
    for(int i = 1; i <= n; i++) a[i] = read();
    sort(a + 1, a + n + 1); // 1. 排序
    for(int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i]; // 2. 计算前缀和

    double ans = -1e18; // 初始化为极小值
    int ans_cnt = 0, ans_mid = 0; // ans_cnt是k，ans_mid是最优中位数位置

    for(int i = 1; i <= n; i++) { // 3. 枚举每个元素作为中位数
        int l = 1, r = min(i - 1, n - i); // k的范围：0到min(左边元素数, 右边元素数)
        int best_k = 0;
        double best_avg = a[i]; // 初始k=0，只有中位数自己

        while(l <= r) { // 4. 二分找最优k
            int mid = (l + r) >> 1; // mid是当前尝试的k
            // 计算k=mid时的总和：左边mid个 + 中位数 + 右边mid个
            int total = sum[i - 1] - sum[i - 1 - mid] + a[i] + sum[n] - sum[n - mid];
            double avg = (double)total / (2 * mid + 1); // 平均值
            if(avg > best_avg) { // 如果当前k更优，更新
                best_avg = avg;
                best_k = mid;
                l = mid + 1; // 往更大的k找
            } else {
                r = mid - 1; // 往更小的k找
            }
        }

        double current_skew = best_avg - a[i]; // 当前中位数的最大偏度
        if(current_skew > ans) { // 更新全局最优
            ans = current_skew;
            ans_cnt = best_k;
            ans_mid = i;
        }
    }

    // 输出结果
    cout << ans_cnt * 2 + 1 << endl; // 子集大小：2*k +1
    // 输出左边k个：从ans_mid - ans_cnt到ans_mid
    for(int i = ans_mid - ans_cnt; i <= ans_mid; i++) cout << a[i] << " ";
    // 输出右边k个：从n - ans_cnt +1到n
    for(int i = n - ans_cnt + 1; i <= n; i++) cout << a[i] << " ";
    return 0;
}
```
* **代码解读概要**：
  1. **排序**：把数组从小到大排好，方便找中位数和选最大元素。
  2. **前缀和**：计算`sum`数组，快速求任意区间的和。
  3. **枚举中位数**：每个元素都尝试作为中位数。
  4. **二分找k**：对每个中位数，用二分找到最优的k（左右选多少元素）。
  5. **输出结果**：根据最优的中位数和k，输出子集。


<code_intro_selected>
接下来看3份优质题解的**核心片段**，学习它们的“亮点技巧”！
</code_intro_selected>

### 题解一（TonyYin）：二分找k的核心片段
* **亮点**：用二分比较k和k+1的平均值，快速找到最优解。
* **核心代码片段**：
```cpp
while(l <= r) {
    int mid = (l + r) >> 1;
    // 计算k=mid-1的平均值
    int sum1 = sum[i-1] - sum[i - mid] + sum[n] - sum[n - mid + 1];
    double avg1 = (sum1 + a[i]) / (2 * mid - 1);
    // 计算k=mid的平均值
    int sum2 = sum[i-1] - sum[i - mid -1] + sum[n] - sum[n - mid];
    double avg2 = (sum2 + a[i]) / (2 * mid + 1);
    if(avg1 < avg2) { // k=mid更优，往更大的k找
        best_avg = avg2;
        best_k = mid;
        l = mid + 1;
    } else { // 往更小的k找
        r = mid - 1;
    }
}
```
* **代码解读**：
  - `sum1`是k=mid-1时的总和（左边mid-1个+右边mid-1个+中位数）；
  - `sum2`是k=mid时的总和（左边mid个+右边mid个+中位数）；
  - 如果`avg2`更大，说明k=mid更优，继续往更大的k找；否则往更小的k找。
* 💡 **学习笔记**：二分的关键是“比较相邻k的优劣”，找到转折点！

### 题解二（hanzhongtlx）：边界处理的核心片段
* **亮点**：专门处理`n≤2`的情况，避免不必要的计算。
* **核心代码片段**：
```cpp
if(n <= 2) {
    printf("%d\n", n);
    for(int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0;
}
```
* **代码解读**：当n≤2时，子集只能是全部元素（比如n=2时，子集`[1,2]`的偏度是`1.5-1.5=0`，但题目要求非空，所以输出全部）。
* 💡 **学习笔记**：边界情况要优先处理，避免后面的逻辑出错！

### 题解三（Starlight_Glimmer）：三分找k的核心片段
* **亮点**：用三分法找单峰函数的最大值，比二分更直观。
* **核心代码片段**：
```cpp
pair<double,int> tri(int pos,int l,int r) {
    while(l+3 < r) { // 三分的终止条件：区间足够小
        int lmid = l + (r-l)/3; // 左三分点
        int rmid = r - (r-l)/3; // 右三分点
        double lans = f(pos, lmid); // lmid对应的偏度
        double rans = f(pos, rmid); // rmid对应的偏度
        if(lans < rans) l = lmid; // 右边更优，缩小左边界
        else r = rmid; // 左边更优，缩小右边界
    }
    // 暴力枚举剩下的区间，找最大值
    pair<double,int> res = {0,0};
    for(int i=l;i<=r;i++) {
        double tmp = f(pos,i);
        if(tmp>res.first) res = {tmp,i};
    }
    return res;
}
```
* **代码解读**：
  - 三分法把区间分成三部分，比较两个三分点的函数值，缩小搜索范围；
  - 当区间足够小时，暴力枚举剩下的点，找到最大值。
* 💡 **学习笔记**：三分法适合单峰函数，比二分更直接，但要注意终止条件！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”算法的运行，Kay设计了一个**8位像素风的“偏度探险家”动画**！像玩FC游戏一样，跟着像素小人一起找最优子集~
</visualization_intro>

### ✨ 动画设计方案
#### 1. 整体风格与场景
- **8位像素风**：用FC红白机的配色（比如蓝色背景、黄色文字、红色像素块），元素都是“方块+像素点”（比如数组元素是“带数字的方块”，中位数是“带金光的方块”）。
- **场景布局**：
  - 左侧：排序后的数组（像素方块排成一列）；
  - 中间：当前选中的子集（闪烁的方块）；
  - 右侧：控制面板（开始/暂停、单步、重置按钮，速度滑块）；
  - 底部：数值显示（当前平均值、中位数、偏度）。

#### 2. 核心动画步骤（以样例1为例）
1. **初始化**：
   - 输入数组`[1,2,3,12]`，排序后变成`[1,2,3,12]`（像素方块从左到右排列）；
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。
2. **枚举中位数**：
   - 第一个中位数是`1`（最左边的方块），它“闪烁金光”，右侧显示“当前中位数：1”；
   - 计算k的范围（0到min(0, 3)=0），所以k=0，子集是`[1]`，偏度`1-1=0`（底部数值显示）。
3. **下一个中位数**：
   - 中位数是`2`（第二个方块），“闪烁金光”；
   - 二分找k：
     - 初始l=1，r=min(1,2)=1（左边有1个元素，右边有2个）；
     - mid=1，计算k=1的总和：左边1个（`1`）+中位数（`2`）+右边1个（`12`）→总和`15`，平均值`5`，偏度`5-2=3`（底部数值变红，显示“当前最大偏度：3”）；
     - 子集方块`[1,2,12]`“变蓝”，播放“叮”的音效。
4. **找到最优解**：
   - 所有中位数枚举完，最优子集是`[1,2,12]`，播放“胜利音效”（类似《魂斗罗》的通关音乐），子集方块“跳舞”（上下跳动）；
   - 右侧显示“最优偏度：3”，底部输出子集。

#### 3. 交互设计
- **单步执行**：点击“下一步”，动画走一步（比如枚举下一个中位数，或二分的一次迭代）；
- **自动播放**：点击“开始”，动画自动运行，速度用滑块调节（从“慢”到“快”）；
- **重置**：点击“重置”，回到初始状态，重新开始。

#### 4. 游戏化元素
- **关卡设计**：把“枚举中位数”分成4个小关卡（对应样例1的4个元素），完成一个关卡，显示“关卡1完成！”；
- **积分奖励**：每找到一个更优的偏度，加10分，总分显示在右上角；
- **音效提示**：
  - 排序完成：“叮~”；
  - 中位数选中：“嗒~”；
  - 找到更优解：“叮叮~”；
  - 胜利：“当当当~”。

<visualization_conclusion>
通过这个动画，你能**直观看到**排序、枚举中位数、二分找k的全过程，甚至能“听”到算法的关键步骤！就像玩游戏一样，边玩边学，轻松掌握核心逻辑~
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了这道题的思路，你可以解决**所有“中位数+贪心+优化”**的问题！下面是3道洛谷的相似题目，帮你巩固技巧~
</similar_problems_intro>

### 1. 洛谷 P2727 【USACO3.1】总分 Score Inflation
- 🗣️ **推荐理由**：这题和本题“思路完全一致”（贪心+单峰优化），是**双倍经验题**！做完这道题，你会对“单峰函数”和“二分/三分”更熟悉。

### 2. 洛谷 P1880 【NOI1995】石子合并
- 🗣️ **推荐理由**：这题用到了“区间DP+四边形不等式优化”，但核心是“单峰函数”的性质。做完这道题，你会对“优化暴力枚举”有更深的理解。

### 3. 洛谷 P3817 小A的糖果
- 🗣️ **推荐理由**：这题用到了“贪心策略”（选最大的元素），和本题的“贪心选两边最大的数”思路一致。做完这道题，你会更熟练地应用“贪心”解决问题。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“经验分享”能帮你避免踩坑，Kay整理了2条关键心得：
</insights_intro>

> **经验1**（来自TonyYin）：“我刚开始没想到偶数长度的子集不如奇数，暴力枚举了所有情况，结果超时。后来通过数学证明排除了偶数，才把复杂度降下来。”
> **点评**：**先证明结论，再写代码**！如果不先排除偶数，暴力O(n²)会超时，而证明后只需要处理奇数，复杂度直接降一半。

> **经验2**（来自hanzhongtlx）：“我刚开始没处理n≤2的情况，结果样例3输出错了。后来加了边界判断，才通过。”
> **点评**：**边界情况要优先处理**！比如n=1时，子集只能是自己；n=2时，子集只能是全部元素。这些情况不处理，会导致代码出错。


<conclusion>
本次关于**Simple Skewness**的分析就到这里啦！这道题的核心是“贪心选最大元素”+“单峰函数优化”，只要掌握这两个技巧，就能轻松解决。记住：**排序是基础，贪心是关键，优化是灵魂**！下次遇到类似的问题，你一定能快速想到解法~ 💪
</conclusion>

---
处理用时：125.25秒
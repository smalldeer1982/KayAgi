# 题目信息

# Girl Permutation

## 题目描述

Some permutation of length $ n $ is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length $ k $ is an array of size $ k $ such that each integer from $ 1 $ to $ k $ occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at that element. More formally, the element $ a_i $ is a prefix maximum if $ a_i > a_j $ for every $ j < i $ .

Similarly, suffix maximums are defined, the element $ a_i $ is a suffix maximum if $ a_i > a_j $ for every $ j > i $ .

You need to output the number of different permutations that could have been guessed.

As this number can be very large, output the answer modulo $ 10^9 + 7 $ .

## 说明/提示

The following permutations are suitable for the second set of input data:

- $ [1, 4, 3, 2] $
- $ [2, 4, 3, 1] $
- $ [3, 4, 2, 1] $

The following permutations are suitable for the sixth set of input data:

- $ [2, 1, 6, 5, 3, 4] $
- $ [3, 1, 6, 5, 2, 4] $
- $ [3, 2, 6, 5, 1, 4] $
- $ [4, 1, 6, 5, 2, 3] $
- $ [4, 2, 6, 5, 1, 3] $
- $ [4, 3, 6, 5, 1, 2] $
- $ [5, 1, 6, 4, 2, 3] $
- $ [5, 2, 6, 4, 1, 3] $
- $ [5, 3, 6, 4, 1, 2] $
- $ [5, 4, 6, 3, 1, 2] $

## 样例 #1

### 输入

```
6
1 1 1
1
1
4 2 3
1 2
2 3 4
3 3 1
1 2 3
3
5 3 4
1 2 3
2 3 4 5
20 5 4
1 2 3 4 12
12 13 18 20
6 2 3
1 3
3 4 6```

### 输出

```
1
3
1
0
317580808
10```

# AI分析结果


### 题目解读与核心算法识别
**核心算法**：组合数学（排列计数）  
**比喻解释**：想象你有一排高低不同的积木塔（排列）。前缀最大值就像从前往后看时新出现的最高塔尖（必须高于前方所有塔）；后缀最大值则是从后往前看的新最高塔尖。题目要求根据给定的塔尖位置，计算有多少种搭积木方案。  

**初步分析**：  
1. **核心思想**：最大值 `n` 必须同时是前缀/后缀最大值，因此位置 `p[m1]` 和 `s[1]` 必须重合。以此点分割序列，左右独立处理。  
2. **关键步骤**：  
   - **左区间**：从 `p[i]` 到 `p[i+1]`，需选数字填充空隙（组合数），剩余数字自由排列（阶乘）。  
   - **右区间**：类似处理，方向相反。  
3. **可视化设计**：  
   - **像素风格**：8-bit网格显示序列，用不同颜色标识最大值位置（如红色）、普通数字（蓝色）。  
   - **高亮变化**：动态显示当前处理的区间，组合数选择时闪烁待选区，阶乘排列时展示数字交换动画。  
   - **游戏化**：完成一个区间时播放“叮”音效，错误时播放“失败”音效，背景配复古芯片音乐。  

---

### 精选优质题解参考
> 基于思路清晰性、代码规范性、算法优化度筛选：

**题解一（Yharimium）**  
* **亮点**：  
  - 逻辑直白：通过不等式链 `a[p₁] < ... < a[pₘ₁] = n > ... > a[sₘ₂]` 揭示极值关系。  
  - 代码高效：预处理阶乘和逆元，组合数计算O(1)。  
  - 边界严谨：检查 `p[1]==1, s[m₂]==n, p[m₁]==s[1]` 三大条件。  

**题解二（MaxBlazeResFire）**  
* **亮点**：  
  - 创新建模：用树结构表示大小关系（父节点>子节点），方案数转化为拓扑序计数。  
  - 结构清晰：DFS递归计算子树大小，乘积公式 `n! / ∏ siz_i` 简洁优美。  

**题解三（FBW2010）**  
* **亮点**：  
  - 分步推导：从最大值拆分到子区间，逐步解释组合数来源。  
  - 实践友好：代码模块化，直接用于竞赛（含费马小定理求逆元）。  

---

### 核心难点辨析与解题策略
1. **难点1：极值位置矛盾**  
   - **问题**：若 `p[m₁] ≠ s[1]`，则最大值 `n` 位置冲突。  
   - **解法**：优先检查 `p[1]==1, s[m₂]==n, p[m₁]==s[1]`，否则输出0。  

2. **难点2：子区间独立性证明**  
   - **问题**：为何左右区间数字选择互不影响？  
   - **解法**：最大值 `n` 固定后，剩余数字的相对顺序独立，用组合数 `C(n-1, p[m₁]-1)` 分配左右集合。  

3. **难点3：区间内部约束**  
   - **问题**：`[pᵢ, pᵢ₊₁]` 内数字如何满足极值条件？  
   - **解法**：  
     1. `pᵢ₊₁` 位置放当前最大值。  
     2. 从 `pᵢ₊₁-2` 个数选 `pᵢ-1` 个放左侧（组合数）。  
     3. 剩余数字在 `(pᵢ, pᵢ₊₁)` 自由排列（阶乘）。  

**学习笔记**：  
> 组合计数 = 选择数字（组合数） × 排列数字（阶乘） × 子问题拆分

**解题技巧总结**：  
- **分治拆解**：用最大值切割序列，递归处理子区间。  
- **组合数学**：预处理阶乘逆元加速组合数计算。  
- **边界防御**：检查输入是否满足极值位置基本定理。  

---

### C++核心代码实现赏析
**通用核心实现参考**（基于Yharimium代码优化）：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5, MOD = 1e9 + 7;

ll fac[N], inv[N];
ll C(int n, int m) { 
    return (n < m) ? 0 : fac[n] * inv[m] % MOD * inv[n - m] % MOD; 
}

void init() { // 预处理阶乘和逆元
    fac[0] = inv[0] = 1;
    for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % MOD;
    inv[N - 1] = pow(fac[N - 1], MOD - 2, MOD);
    for (int i = N - 2; i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;
}

int main() {
    init();
    int T; cin >> T;
    while (T--) {
        int n, m1, m2;
        cin >> n >> m1 >> m2;
        vector<int> p(m1), s(m2);
        for (int i = 0; i < m1; i++) cin >> p[i];
        for (int i = 0; i < m2; i++) cin >> s[i];
        
        // 检查三大条件
        if (p[0] != 1 || s.back() != n || p.back() != s[0]) {
            cout << "0\n"; continue;
        }
        
        ll ans = C(n - 1, p.back() - 1); // 左右集合分配
        for (int i = m1 - 2; i >= 0; i--) { // 向左处理前缀
            int gap = p[i + 1] - p[i] - 1;
            ans = ans * C(p[i + 1] - 2, p[i] - 1) % MOD; // 选数
            ans = ans * fac[gap] % MOD; // 自由排列
        }
        for (int i = 1; i < m2; i++) { // 向右处理后缀
            int gap = s[i] - s[i - 1] - 1;
            ans = ans * C(n - s[i - 1] - 1, gap) % MOD;
            ans = ans * fac[gap] % MOD;
        }
        cout << ans << '\n';
    }
}
```

**代码解读概要**：  
1. **预处理**：`init()` 计算阶乘 `fac[]` 和逆元 `inv[]`，支持O(1)组合数查询。  
2. **条件检查**：验证 `p[0]`（首）、`s.back()`（尾）、`p.back()=s[0]`（最大）位置。  
3. **核心乘法**：  
   - **左区间**：倒序遍历前缀序列，计算组合数 `C(pᵢ₊₁-2, pᵢ-1)` 和排列数 `gap!`。  
   - **右区间**：正序遍历后缀序列，类似处理。  

---

### 算法可视化：像素动画演示
**主题**：8-bit积木排序工坊  
**核心流程**：  
1. **初始化**：显示 `n` 个灰色积木，标注位置索引（复古像素字体）。  
2. **放置最大值**：  
   - 高亮 `p[m₁]` 位置，播放“轰隆”音效，显示数字 `n`（金色积木）。  
   - 分裂序列：左侧蓝色背景，右侧绿色背景。  
3. **左区间处理**：  
   - **步骤1**：从 `p[m₁]` 向左移动，在 `pᵢ` 处放置银色积木（次大值），播放“叮”音效。  
   - **步骤2**：在 `pᵢ` 和 `pᵢ₊₁` 间生成待选积木（半透明），组合数计算时随机选中部分变实（闪烁动画）。  
   - **步骤3**：选中积木自由排列（随机交换位置动画），播放“刷啦”音效。  
4. **右区间类似**：方向相反，音效相同。  
5. **完成特效**：全部填满后，路径高亮显示，播放胜利音效+烟花动画。  

**交互设计**：  
- **控制面板**：步进/暂停/重置按钮 + 速度滑块（调速范围0.5x~3x）。  
- **AI演示**：自动模式模拟“贪吃蛇”移动，按逻辑顺序点亮积木。  
- **信息显示**：底部日志栏输出当前步骤公式（如 `C(5,3)=10`）。  

---

### 拓展练习与相似问题思考
**通用技巧迁移**：  
1. **极值约束排列**：如 [LC1536] 最小交换次数（类似后缀最大值思想）。  
2. **树形拓扑序计数**：如 [CF1329C] 树重建（子树独立性类似本题区间拆分）。  
3. **分治组合数学**：如 [ABC281F] 操作序列计数（分治+组合数）。  

**洛谷推荐**：  
1. **P1246 编码**（组合计数基础）  
   > 理由：巩固组合数 `C(n,m)` 的应用，理解字母序与数字映射。  
2. **P1754 球迷购票**（卡特兰数模型）  
   > 理由：学习栈约束下的排列计数，拓展组合思维。  
3. **P1025 数的划分**（分治+DP）  
   > 理由：强化子问题拆分能力，类比本题区间分割。  

---

### 学习心得与经验分享
> 摘自题解作者 **Yharimium** 的调试经验：  
> *“首次提交忽略了 `s[m₂]` 必须为 `n`，导致WA。通过打印中间变量 `p.back(), s[0]` 快速定位错误。建议：边界检查写为独立函数！”*  

**Kay的总结**：  
1. **调试技巧**：在关键分支打印变量（如 `cout << p[0] << s.back()...`）。  
2. **组合优化**：预处理阶乘逆元可提升效率（尤其多组询问）。  
3. **思维陷阱**：最大值位置必须重合是隐含条件，需优先验证。  

--- 

通过本指南，你掌握了排列计数的核心分治策略和组合数学技巧。接下来，尝试用像素动画可视化算法流程，并挑战推荐练习吧！

---
处理用时：180.16秒
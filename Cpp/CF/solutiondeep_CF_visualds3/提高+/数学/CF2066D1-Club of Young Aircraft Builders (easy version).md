# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果


### 题目分析报告

---
# 💡 Kay的C++算法解析：Club of Young Aircraft Builders (easy version) 深入学习指南 💡

<introduction>
今天我们来分析一道关于纸飞机发射方案的计数问题。题目来自编程竞赛，考察动态规划和组合数学的应用。本指南将帮助你理解题目核心、掌握算法思路，并通过可视化加深理解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划`与`组合数学应用`

🗣️ **初步分析**：
> 想象你是一栋大楼的居民管理员，需要安排纸飞机发射顺序。顶层的居民只能看到自己发射的飞机，所以必须发射恰好c架飞机（相当于"独立作战单位"）。其他楼层的居民发射飞机时，只能在自己看到的前c架飞机中选择时机发射（类似"在关键时间窗口行动"）。  
> - **核心思路**：动态规划（DP）逐层计算方案数，状态dp[i][j]表示前i层发射j架飞机的方案数  
> - **关键难点**：顶层特殊性处理 + 发射时机约束 + 大数取模运算  
> - **算法流程**：从顶层开始逐层计算，每层枚举发射数量k（0≤k≤c），通过组合数计算选择方案  
> - **可视化设计**：像素网格展示DP状态转移，用颜色区分层级，箭头表示状态转移路径，音效提示关键操作  

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰性、代码规范性和算法有效性，精选以下优质题解：

**题解一（作者：_Kamisato_Ayaka_）**
* **点评**：  
  这份题解采用经典DP解法，思路清晰直白：  
  - 状态定义简洁（dp[i][j] = 前i层发射j架飞机的方案数）  
  - 代码规范（预处理组合数，模块化函数设计）  
  - 算法有效性高（正确性有保障，虽然O(n·m·c)复杂度在极限数据较慢）  
  - 实践价值强（可直接用于竞赛，边界处理严谨）  
  亮点在于组合数预处理和清晰的DP转移逻辑，是学习动态规划的典范。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点：

1.  **顶层居民的特殊约束**
    * **分析**：顶层居民只能看到自己发射的飞机，因此必须发射恰好c架。这是DP初始化的基础（dp[1][c]=1）。  
    * 💡 **学习笔记**：顶层是问题的锚点，必须先确定其行为模式。

2.  **发射时机的动态约束**
    * **分析**：非顶层居民只能在看到的前c架飞机中选择发射时机。DP中通过组合数C(c,k)保证该约束，表示在当前层前c次发射中选择k次作为发射时机。  
    * 💡 **学习笔记**：组合数C(c,k)是满足发射窗口约束的核心工具。

3.  **状态转移的设计与优化**
    * **分析**：状态转移方程：  
      `dp[i][j] = ∑dp[i-1][j-k] × C(c,k) (0≤k≤min(j,c))`  
      需注意j从c开始（顶层已发射c架），且k不能超过剩余飞机数。  
    * 💡 **学习笔记**：三层循环中，k的枚举范围优化是减少计算量的关键。

### ✨ 解题技巧总结
- **技巧1：组合数预处理**：提前计算阶乘和逆元，O(1)获取组合数  
- **技巧2：从顶向下设计**：从约束最强的顶层开始推导，逐步解除约束  
- **技巧3：滚动数组优化**：dp[i]只依赖dp[i-1]，可用两个数组交替节省内存  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是基于优质题解提炼的通用DP实现，包含完整解题框架：

**本题通用核心C++实现参考**
* **说明**：综合自题解一思路，优化变量命名与注释
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9+7;
const int MAX_M = 10005;
const int MAX_N = 105;

int dp[MAX_N][MAX_M]; // dp[层数][总飞机数]
int fac[1000005], inv_fac[1000005]; // 组合数预处理

// 快速幂求逆元
int qpow(int base, int exp) {
    int res = 1;
    while (exp) {
        if (exp & 1) res = 1LL * res * base % MOD;
        base = 1LL * base * base % MOD;
        exp >>= 1;
    }
    return res;
}

// 预处理阶乘和逆元
void precompute_comb() {
    fac[0] = 1;
    for (int i = 1; i <= 1000000; ++i)
        fac[i] = 1LL * fac[i-1] * i % MOD;
    
    inv_fac[1000000] = qpow(fac[1000000], MOD-2);
    for (int i = 999999; i >= 0; --i)
        inv_fac[i] = 1LL * inv_fac[i+1] * (i+1) % MOD;
}

// 组合数计算 C(n,m)
int nCr(int n, int m) {
    if (m < 0 || m > n) return 0;
    return 1LL * fac[n] * inv_fac[m] % MOD * inv_fac[n-m] % MOD;
}

void solve() {
    int n, c, m;
    cin >> n >> c >> m;
    
    // 初始化DP数组
    memset(dp, 0, sizeof(dp));
    dp[1][c] = 1; // 顶层必须发射c架

    // 从第2层开始动态规划
    for (int i = 2; i <= n; ++i) {
        for (int j = c; j <= m; ++j) { // 总飞机数至少为c
            for (int k = 0; k <= min(j, c); ++k) { // 当前层发射k架
                dp[i][j] = (dp[i][j] + 1LL * nCr(c, k) * dp[i-1][j-k] % MOD) % MOD;
            }
        }
    }
    cout << dp[n][m] << '\n';
}

int main() {
    precompute_comb();
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：
  1. 预处理阶乘和逆元实现O(1)组合数查询
  2. DP数组dp[i][j]表示前i层发射j架飞机的方案数
  3. 核心三重循环：遍历楼层→总飞机数→当前层发射数
  4. 状态转移：dp[i][j] += C(c,k) × dp[i-1][j-k]
  5. 输出顶层到底层共发射m架飞机的方案数

---
<code_intro_selected>
**题解一核心片段深度解析**
* **亮点**：组合数预处理 + 清晰的DP状态转移
* **核心代码片段**：
```cpp
dp[1][c] = 1; // 初始化顶层
for (int i = 2; i <= n; ++i) {
    for (int j = c; j <= m; ++j) {
        for (int k = 0; k <= min(j, c); ++k) {
            dp[i][j] = (dp[i][j] + 1LL * nCr(c, k) * dp[i-1][j-k] % MOD) % MOD;
        }
    }
}
```
* **代码解读**：
  > 1. **顶层初始化**：`dp[1][c]=1`是算法起点，因为顶层必须发射c架飞机（为什么不能是其他值？因为顶层居民只能看到自己的飞机）  
  > 2. **楼层遍历**：从第2层（次顶层）开始向下计算，直到第n层（底层）  
  > 3. **飞机总数遍历**：j从c开始（顶层已用掉c架），逐步增加到m  
  > 4. **当前层发射数**：k的范围受两个限制：≤c（发射窗口约束）且≤j（不超过剩余飞机数）  
  > 5. **组合数作用**：`nCr(c,k)`计算在当前层前c次发射中选择k次作为发射时机的方案数  
  > 6. **状态转移**：从`dp[i-1][j-k]`（前i-1层发射j-k架）转移到`dp[i][j]`（前i层发射j架）  
* 💡 **学习笔记**：DP中的三层循环分别对应"楼层-总量-当前层选择"的思考层次，是分治思想的典型应用。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计复古像素风格动画演示DP状态转移过程，帮助直观理解算法：

* **主题**："纸飞机大冒险"（8-bit像素风格）  
* **核心演示**：DP状态转移过程 + 组合数选择逻辑  
* **设计思路**：用FC游戏风格降低理解门槛，音效强化关键操作记忆  

**动画实现方案**：  
1. **场景设计**：
   - 左侧：像素化大楼（每层独立色块）
   - 右侧：DP状态网格（行=楼层，列=飞机总数）
   - 底部：控制面板（开始/暂停/单步/速度条）

2. **初始化阶段**：
   - 顶层亮起，播放"准备音效"
   - 状态网格中(1,c)格变为绿色（值=1）

3. **状态转移演示**：
   ```mermaid
   graph LR
   A[前i-1层状态 j-k] -->|× Cc,k| B[当前层状态 j]
   ```
   - 箭头动画：从dp[i-1][j-k]格向dp[i][j]格绘制像素箭头
   - 颜色标记：转移源（蓝色），目标格（黄色），组合数显示在侧边栏
   - 音效：k变化时播放"选择音效"，转移成功播放"叮"声

4. **组合数可视化**：
   - 弹出像素窗口展示C(c,k)计算过程
   - 用c个格子中选k个的动画演示组合意义

5. **游戏化元素**：
   - 每完成一层：播放"过关音效" + 楼层点亮
   - 完成计算：整栋楼闪烁 + 胜利BGM
   - 错误操作：短促警告音

6. **交互控制**：
   - 单步执行：按空格逐状态转移
   - 自动模式：AI自动演示（速度可调）
   - 重置：清空状态网格

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题DP思想后，可挑战以下相似问题：

1. **洛谷 P1025 数的划分**  
   🗣️ 推荐理由：同样采用"数字划分"的DP思想，练习状态设计技巧

2. **洛谷 P1077 摆花**  
   🗣️ 推荐理由：约束条件下的计数问题，强化组合数学与DP的结合应用

3. **洛谷 P1541 乌龟棋**  
   🗣️ 推荐理由：多维状态设计的经典问题，提升DP优化能力

---

## 7. 学习心得与经验分享

<insights_intro>
题解中虽无直接经验分享，但通过代码可提炼以下经验：

1. **组合数预处理**：大数量级组合数必须预先计算，避免重复计算
2. **DP初始化技巧**：顶层作为边界条件需要单独处理
3. **循环范围优化**：j从c开始，k≤min(j,c)可减少不必要的计算

---

<conclusion>
通过本指南，你已掌握纸飞机问题的DP解法核心思想。记住：动态规划的关键在于状态设计和转移逻辑，而组合数学是处理约束条件的有力工具。继续挑战更多DP问题，你的算法能力会像纸飞机一样越飞越高！🚀
</conclusion>
```

---
处理用时：266.46秒
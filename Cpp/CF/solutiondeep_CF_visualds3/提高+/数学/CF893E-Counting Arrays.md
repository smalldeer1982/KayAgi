# 题目信息

# Counting Arrays

## 题目描述

You are given two positive integer numbers $ x $ and $ y $ . An array $ F $ is called an  $ y $ -factorization of $ x $ iff the following conditions are met:

- There are $ y $ elements in $ F $ , and all of them are integer numbers;
- ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF893E/d8d5a9dcea7fa6a7abfa89d7da34d6fb180c0f69.png).

You have to count the number of pairwise distinct arrays that are $ y $ -factorizations of $ x $ . Two arrays $ A $ and $ B $ are considered different iff there exists at least one index $ i $ ( $ 1<=i<=y $ ) such that $ A_{i}≠B_{i} $ . Since the answer can be very large, print it modulo $ 10^{9}+7 $ .

## 说明/提示

In the second testcase of the example there are six $ y $ -factorizations:

- $ {-4,-1} $ ;
- $ {-2,-2} $ ;
- $ {-1,-4} $ ;
- $ {1,4} $ ;
- $ {2,2} $ ;
- $ {4,1} $ .

## 样例 #1

### 输入

```
2
6 3
4 2
```

### 输出

```
36
6
```

# AI分析结果


### 💡 Kay的C++算法解析：Counting Arrays 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：组合数学/质因数分解应用  
🗣️ **初步分析**：  
> 解决"Counting Arrays"的关键在于将问题分解为两个独立部分：**符号处理**和**数值分配**。就像分配彩色糖果到不同盒子，既要考虑糖果数量分配（数值），又要考虑盒子标签（符号）。  
> - **核心思路**：  
>   1. **符号处理**：前`y-1`个元素可自由选择正负号（2种选择），最后一个元素符号由乘积约束确定，总方案数为`2^(y-1)`  
>   2. **数值分配**：对`x`质因数分解后，每个质因子的指数`e_i`通过插板法分配到`y`个位置，方案数为`C(e_i+y-1, y-1)`  
> - **可视化设计**：  
>   - 像素动画将展示`x`分解为质因数"矿石"（不同颜色），指数`e_i`作为小球分配到`y`个盒子（网格动画）  
>   - 符号选择阶段：前`y-1`个盒子出现正负号闪烁，伴随8-bit音效（选择时"叮"声）  
>   - 关键变量：`ans`实时显示在顶部，随质因数分解逐步更新  

---

#### 2. 精选优质题解参考
**题解一（作者：hyman00）**  
* **点评**：  
  思路直击本质——将问题分解为符号方案（`2^(y-1)`）和质因数分配（组合数乘积）。代码亮点在于：  
  - **高效预处理**：阶乘、逆元、幂次数组预计算，组合数O(1)查询  
  - **边界处理**：质因数分解循环`i*i<=x`优化，剩余质数单独处理  
  - **代码规范**：变量名`fac`（阶乘）、`fnv`（阶乘逆元）语义明确，模块化函数设计（`qpow`, `inv`）  

**题解二（作者：mydiplomacy）**  
* **点评**：  
  突出数学严谨性——详细证明符号方案数为`2^(y-1)`（奇偶分类+组合恒等式）。亮点：  
  - **数学引导**：从组合恒等式推导结论，深化理解  
  - **工程优化**：逆元递推公式`inv[i]=inv[mod%i]*(mod-mod/i)`避免快速幂开销  
  - **实践价值**：完整质因数分解框架可直接复用  

**题解三（作者：eee_hoho）**  
* **点评**：  
  提供标准化实现——线性预处理逆元降低常数。需注意：  
  - **代码简洁**：质因数分解主循环与hyman00一致  
  - **优化点**：组合数计算使用预处理的`fac`和`invfac`，但证明部分稍显冗余  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：符号方案证明**  
   * **分析**：需严格证明符号方案=`2^(y-1)`。优质题解通过奇偶分类+组合恒等式（`∑C(n,2k)=2^(n-1)`）解决，避免枚举  
   * 💡 **学习笔记**：组合恒等式是简化计算的利器  

2. **难点2：指数分配建模**  
   * **分析**：将质因数指数分配转化为插板法模型（`e_i`个相同球放入`y`个盒子）。关键变量`e_i`需通过质因数分解获取  
   * 💡 **学习笔记**：计数问题中，独立子问题的乘积=总方案数  

3. **难点3：组合数高效计算**  
   * **分析**：预处理阶乘及其逆元，实现`C(n,k)=fac[n]*inv[k]*inv[n-k]%mod`。选择逆元递推（`mydiplomacy`）或费马小定理（`hyman00`）均可  
   * 💡 **学习笔记**：模数`10^9+7`下，费马小定理求逆元更通用  

✨ **解题技巧总结**：  
- **分解问题**：将复杂问题拆解为独立子问题（符号/数值）  
- **组合模型**：识别插板法、组合恒等式等模型  
- **预处理优化**：阶乘、逆元等固定计算提前处理  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现**  
* **说明**：综合优质题解，预处理优化+质因数分解框架  
```cpp
#include <iostream>
using namespace std;
const int MOD = 1e9+7, MAXN = 2e6+5;

int fac[MAXN], invFac[MAXN], pow2[MAXN]; // 预处理数组

int qpow(int a, int b) { // 快速幂
    int res = 1;
    while (b) {
        if (b & 1) res = 1LL * res * a % MOD;
        a = 1LL * a * a % MOD;
        b >>= 1;
    }
    return res;
}

int C(int n, int k) { // 组合数计算
    if (k < 0 || k > n) return 0;
    return 1LL * fac[n] * invFac[k] % MOD * invFac[n-k] % MOD;
}

int main() {
    // 预处理：阶乘、阶乘逆元、2的幂
    fac[0] = pow2[0] = 1;
    for (int i = 1; i < MAXN; ++i) {
        fac[i] = 1LL * fac[i-1] * i % MOD;
        pow2[i] = 2LL * pow2[i-1] % MOD;
    }
    invFac[MAXN-1] = qpow(fac[MAXN-1], MOD-2);
    for (int i = MAXN-2; i >= 0; --i)
        invFac[i] = 1LL * invFac[i+1] * (i+1) % MOD;

    int T; cin >> T;
    while (T--) {
        int x, y; cin >> x >> y;
        long long ans = pow2[y-1]; // 符号方案
        
        // 质因数分解
        for (int i = 2; i*i <= x; ++i) {
            if (x % i) continue;
            int cnt = 0;
            while (x % i == 0) cnt++, x /= i;
            ans = ans * C(cnt + y - 1, y - 1) % MOD;
        }
        if (x > 1) // 剩余质因数
            ans = ans * C(1 + y - 1, y - 1) % MOD;
        
        cout << ans << "\n";
    }
}
```
* **代码解读概要**：  
  1. 预处理阶乘数组`fac`和逆元数组`invFac`实现O(1)组合数查询  
  2. 主逻辑：先计算符号方案`pow2[y-1]`，再分解`x`的质因数  
  3. 对每个质因子的指数`e_i`，用插板法计算分配方案`C(e_i+y-1, y-1)`  
  4. 关键优化：质因数循环终止于`sqrt(x)`，剩余质数单独处理  

**题解一（hyman00）片段赏析**  
* **亮点**：费马小定理求逆元，代码简洁高效  
* **核心代码**：  
  ```cpp
  int inv(int x) { return qpow(x, MOD-2); } // 逆元计算
  int C(int a, int b) { 
      return 1LL * fac[a] * fnv[b] % MOD * fnv[a-b] % MOD;
  }```
* **代码解读**：  
  > `inv()`函数通过快速幂求模逆元（费马小定理），`C()`函数直接用阶乘和逆元计算组合数。这种实现常数较大但代码直观，适合初学者理解模逆元概念。  

**题解二（mydiplomacy）片段赏析**  
* **亮点**：线性递推求逆元大幅优化常数  
* **核心代码**：  
  ```cpp
  inv[1] = 1;
  for (int i = 2; i <= N; i++) 
      inv[i] = inv[mod % i] * (mod - mod/i) % mod;```
* **代码解读**：  
  > 利用公式`inv[i] = (mod - mod/i) * inv[mod%i] % mod`递推求逆元，避免快速幂的`O(log MOD)`开销。这是竞赛常见优化，但需理解数论基础。  

---

#### 5. 算法可视化：像素动画演示  
**主题**："质因数矿工"复古像素游戏  
**设计思路**：  
- **8-bit风格**：FC红白机色调（4色：背景灰、质因数矿石彩色、盒子黄色、小球红色）  
- **核心流程**：  
  1. **分解阶段**：`x`像素块爆炸为质因数矿石（`p_i:e_i`），伴随爆破音效  
  2. **分配阶段**：  
     - 每个质因数矿石下方弹出`e_i`个小球  
     - `y`个盒子排列，玩家拖动插板（方向键控制）分割小球到盒子  
     - 实时显示当前分配方案数`C(e_i+y-1, y-1)`  
  3. **符号阶段**：前`y-1`个盒子随机闪烁±号（按A/B键选择），伴随选择音效  
- **交互控制**：  
  - 方向键移动插板  
  - A/B键选择正负号  
  - START键自动演示（AI控制插板和符号选择）  
- **音效设计**：  
  - 小球入盒：短促"嘟"声  
  - 符号选择：不同音高（正号高音，负号低音）  
  - 计算完成：马里奥过关音效  

---

#### 6. 拓展练习与相似问题思考
1. **洛谷 P1407**（质因数分解基础）  
   > 🗣️ **推荐理由**：巩固质因数分解技巧，理解指数统计  
2. **洛谷 P3811**（线性求逆元模板）  
   > 🗣️ **推荐理由**：掌握递推求逆元，优化组合数计算  
3. **洛谷 P1313**（组合数应用进阶）  
   > 🗣️ **推荐理由**：练习组合数公式在多项式展开中的应用  

---

#### 7. 学习心得与经验分享
> **参考经验**：  
> 多位作者强调：质因数分解需注意循环终止条件`i*i<=x`和剩余质数处理。  
> **点评**：这是分解质因数的核心技巧，避免遗漏大质数导致错误。建议编写分解函数后，用`x=2, x=4, x=1`等边界值测试。  

---  
**结语**：通过本题，我们掌握了组合计数问题的分解思维和优化技巧。记住：复杂问题常由独立子问题组成，预处理是优化关键！下次挑战见！💪

---
处理用时：179.26秒
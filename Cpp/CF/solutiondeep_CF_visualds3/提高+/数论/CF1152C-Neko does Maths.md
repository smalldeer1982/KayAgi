# 题目信息

# Neko does Maths

## 题目描述

Neko 喜欢因子。在最近的一节数论课上，他从数学老师那里得到了一个有趣的练习题。

Neko 有两个整数 $a$ 和 $b$。他的目标是找到一个非负整数 $k$，使得 $a+k$ 和 $b+k$ 的最小公倍数尽可能小。如果有多个最优的 $k$，他需要选择最小的那个。

鉴于他的数学天赋，Neko 在这个问题上毫无压力地得到了 Wrong Answer。你能帮他解决这个问题吗？

## 说明/提示

在第一个测试样例中，应选择 $k=2$，因为 $6+2$ 和 $10+2$ 的最小公倍数是 $24$，这是可能的最小最小公倍数。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
6 10
```

### 输出

```
2```

## 样例 #2

### 输入

```
21 31
```

### 输出

```
9```

## 样例 #3

### 输入

```
5 10
```

### 输出

```
0```

# AI分析结果


### 💡 Kay的C++算法解析：Neko does Maths 深入学习指南 💡

**引言**  
今天我们一起分析CF1152C "Neko does Maths"。这道数论题要求找到最小非负整数k，使得a+k和b+k的最小公倍数最小。本指南将解析核心算法，并提供直观的可视化方案。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论）与枚举技巧`

🗣️ **初步分析**：  
> 解决本题的关键在于理解**最小公倍数与最大公约数的关系**，并利用**固定差值约数枚举**的技巧。想象两个探险家（a和b）在数轴上同步前进k步，我们需要找到最佳汇合点使他们的"合作效率"（LCM）最高。  
> - **核心思路**：通过`gcd(a+k, b+k) = gcd(b+k, |a-b|)`将问题转化为枚举固定差值|a-b|的约数，计算最小LCM对应的k  
> - **算法流程**：计算差值d→枚举d的所有约数→对每个约数g计算k→更新最小LCM对应的k  
> - **可视化设计**：采用**像素探险游戏**风格，网格表示数轴，像素小人代表a和b，不同颜色高亮当前枚举的约数和LCM计算过程。当找到更优解时播放胜利音效，失败时播放提示音  

---

## 2. 精选优质题解参考

**题解一（来源：ljc20020730）**  
* **点评**：思路直击核心——利用差值约数性质推导k的计算公式`k=(⌊b/g⌋+1)*g-b`。代码简洁高效（O(√d)复杂度），边界处理严谨（特判整除情况）。亮点在于数学推导干净利落，变量命名清晰（w表约数），实践可直接用于竞赛。

**题解二（来源：Sincerin）**  
* **点评**：详解更相减损术原理，提供完整可运行的代码框架。亮点在于模块化设计（分离gcd/lcm函数）、防御性编程（防溢出先除后乘）、调试技巧（作者强调边界测试）。特别适合初学者理解数论基础到代码的转化。

**题解三（来源：学委）**  
* **点评**：创新性使用数学公式`k=(b/g+bool(b%g))*g-b`直接计算最优k。亮点在于用简洁数学替代条件判断，代码更紧凑。虽变量命名稍简（w1/w2），但算法有效性突出（约数成对枚举优化）。

---

## 3. 核心难点辨析与解题策略

1.  **难点一：转化LCM为GCD问题**  
    * **分析**：优质题解均利用`lcm(a+k,b+k)=(a+k)(b+k)/gcd(b+k,|a-b|)`。关键是通过固定差值|a-b|将双变量问题降维  
    * 💡 **学习笔记**：GCD的辗转相减是连接LCM与固定差值的桥梁  

2.  **难点二：高效枚举约数**  
    * **分析**：必须完整枚举d=∣a−b∣的所有约数。题解采用`i*i≤d`的遍历方式，每找到一对约数立即计算两个k值  
    * 💡 **学习笔记**：约数成对出现（i与d/i）可减少50%枚举量  

3.  **难点三：最小LCM的决策**  
    * **分析**：当多个k产生相同LCM时需取最小值。题解通过`先比较LCM大小，再比较k大小`的分级策略解决  
    * 💡 **学习笔记**：维护二元组(ans_lcm, ans_k)可同步处理最优性  

### ✨ 解题技巧总结
- **技巧1：数学先行代码后动**：先完成`lcm(a+k,b+k)`的数学推导再编码  
- **技巧2：边界防御编程**：特判a=b的情况（直接k=0）  
- **技巧3：约数枚举优化**：用`i*i≤d`避免重复计算，完全平方数特判  

---

## 4. C++核心代码实现赏析

**通用核心实现参考**  
* **说明**：综合优质题解思路，约数成对枚举+分级决策的典范  
```cpp
#include <iostream>
#include <cmath>
using namespace std;
typedef long long ll;

int main() {
    ll a, b, minLCM = 1e18, ansK = 0;
    cin >> a >> b;
    if (a < b) swap(a, b);
    ll d = a - b;
    
    for (ll g = 1; g * g <= d; g++) {
        if (d % g != 0) continue;
        for (auto x : {g, d/g}) { // 成对枚举约数
            ll k = (x - a % x) % x; // 核心公式
            ll curLCM = (a+k)/__gcd(a+k,b+k)*(b+k);
            if (tie(curLCM, k) < tie(minLCM, ansK)) 
                minLCM = curLCM, ansK = k;
        }
    }
    cout << ansK;
}
```
* **代码解读概要**：  
  1. 交换确保a≥b，计算固定差值d  
  2. 枚举d的每个约数g，利用公式`k=(g-a%g)%g`  
  3. 计算当前LCM并分级更新最优解（先比LCM大小，再比k大小）  

**题解一片段赏析**  
```cpp
if (n % i == 0) {
    w1 = i; 
    w2 = n / i;
    k = w1 - (a % w1); // 整除特判已包含
    check(k); // 更新最优解
}
```
* **亮点**：显式处理约数对(w1,w2)  
* **学习笔记**：`a%w1=0`时k=0，数学一致性极强  

**题解二片段赏析**  
```cpp
inline void check(int k) {
    ll newLCM = lcm(a+k, b+k);
    if (newLCM < minLCM || (newLCM==minLCM && k<ansK)) 
        minLCM = newLCM, ansK = k;
}
```
* **亮点**：模块化check函数提升可读性  
* **学习笔记**：LCM比较与k比较分离，逻辑清晰  

**题解三片段赏析**  
```cpp
void gate(ll g) {
    ll k = (b/g + (b%g != 0)) * g - b; // 无分支计算
    ll newVal = (b+k)/g * (a+k); // 注意此处g即gcd
    if (newVal < minVal) minVal = newVal, ansK = k;
}
```
* **亮点**：用布尔运算替代if-else，避免分支预测  
* **学习笔记**：`(bool)转整型`是高效数学编程技巧  

---

## 5. 算法可视化：像素动画演示

**设计思路**  
> 采用**8位像素风RPG探险**主题：a和b化为像素小人，差值d化为可探索的"数学山洞"。通过洞穴分裂（约数枚举）和路径点亮（LCM计算）直观演示算法  

**动画帧步骤**  
1. **场景初始化**  
   - 网格地图：x轴表k值，y轴表LCM大小  
   - 像素元素：❤️a角色，💙b角色，💎d差值（固定位置），✨约数洞口  

2. **核心流程演示**  
   ```mermaid
   graph LR
   A[起点 k=0] --> B[枚举约数g]
   B --> C[计算k= g - a%g]
   C --> D[像素角色移动到a+k/b+k]
   D --> E[显示GCD/LCM像素公式]
   E --> F{是否更新最优解}
   ```

3. **动态效果**  
   - 角色移动：❤️/💙向右侧跳跃（k增加）  
   - 约数高亮：当前枚举的g在💎洞穴闪烁绿光  
   - LCM反馈：角色脚下路径按LCM值染彩虹色（红=最优）  
   - 音效设计：  
     * 枚举成功：8-bit "叮"声  
     * 更新最优解：超级马里奥金币声  
     * 无解：塞尔达警告音  

4. **控制面板**  
   - 速度滑块：控制枚举速度  
   - 单步执行：手动触发下一个约数  
   - 自动演示：AI自动完成全流程（类似自动寻路）  

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
> 差值约数技巧还可用于：  
> 1. 线性丢番图方程求解  
> 2. 同余方程组优化  
> 3. 周期序列对齐问题  

**洛谷推荐**  
1. **P1082 同余方程**  
   → 巩固扩展欧几里得与同余转化  
2. **P2424 约数和**  
   → 约数性质与前缀和的综合应用  
3. **P5436 月之谜**  
   → 差值枚举在数位问题中的变形  

---

## 7. 学习心得与经验分享  
> 本次题解中未发现明确的作者个人心得分享，但代码实现中隐藏重要经验：  
> - 先数学证明再编码可减少80%调试时间  
> - `gcd(a,b)`标准库实现可能溢出，优先用`a/gcd*b`计算LCM  

---

**结语**  
通过差值约数枚举的精妙转化，我们将复杂LCM问题变为可控的数学探索。记住：好算法是数学与代码的二重奏！下次遇到数论题时，不妨先问："是否存在隐藏的固定差值？"

---
处理用时：118.12秒
# 题目信息

# Graph Reconstruction

## 题目描述

I have an undirected graph consisting of $ n $ nodes, numbered 1 through $ n $ . Each node has at most two incident edges. For each pair of nodes, there is at most an edge connecting them. No edge connects a node to itself.

I would like to create a new graph in such a way that:

- The new graph consists of the same number of nodes and edges as the old graph.
- The properties in the first paragraph still hold.
- For each two nodes $ u $ and $ v $ , if there is an edge connecting them in the old graph, there is no edge connecting them in the new graph.

Help me construct the new graph, or tell me if it is impossible.

## 说明/提示

The old graph of the first example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF329C/b1129560868ff844afcd23de4bd0225b3c2eaffb.png)

A possible new graph for the first example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF329C/a236c3432a9690ef14f3805128dc6f4078063345.png)

In the second example, we cannot create any new graph.

The old graph of the third example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF329C/0c623aea06e6e65528063142d300db01a6c49816.png)

A possible new graph for the third example:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF329C/a607e4e3b511cfdb5ff11751224f590048568b98.png)

## 样例 #1

### 输入

```
8 7
1 2
2 3
4 5
5 6
6 8
8 7
7 4
```

### 输出

```
1 4
4 6
1 6
2 7
7 5
8 5
2 8
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
5 4
1 2
2 3
3 4
4 1
```

### 输出

```
1 3
3 5
5 2
2 4
```

# AI分析结果

# 💡 Kay的C++算法解析：Graph Reconstruction 深入学习指南 💡

<introduction>
今天我们来一起分析“Graph Reconstruction”这道C++编程题。题目要求我们根据给定的特殊无向图（每个节点度数≤2），构造一个满足同样条件、边不重叠的新图。本指南将帮你梳理核心思路，理解随机化策略的巧妙之处，并掌握实用的解题技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟与随机化应用

🗣️ **初步分析**：
解决这道题的关键，在于利用**模拟+随机化**的思路——就像玩“洗牌连串”游戏：先把节点像扑克牌一样随机打乱，再尝试把打乱后的节点连成一条链（或环），只要链中的边在原图中没有出现过，就能得到合法解。  

**为什么可行？** 原图每个节点度数≤2，所以边数m≤n（链最多n-1条边，环正好n条边）。而补图（所有可能的边减去原图的边）的边数极其稠密（比如n=1000时，补图边数接近50万），随机排列后几乎不可能遇到“所有相邻边都在原图中”的情况。因此，多次随机尝试总能找到合法解！

**核心算法流程**：
1. **存储原图边**：用哈希结构（如`unordered_set`）快速查询边是否存在；
2. **随机生成排列**：用`shuffle`打乱节点顺序；
3. **检查合法性**：
   - 链：检查排列中相邻节点的边是否在原图中不存在；
   - 环（m=n）：额外检查排列首尾节点的边是否合法；
4. **输出结果**：若合法，输出前m条边（链）或加上首尾边（环）。

**可视化设计思路**：我们会设计一个8位像素风格的“节点洗牌机”——屏幕上的像素节点随机交换位置（伴随“哗啦”音效），逐对检查边时用绿色/红色线条标记合法/非法边，最终连成闪烁的链或环（胜利音效）。这种设计能让你直观“看”到算法的每一步！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码效率、细节优化三个维度筛选了3个优质题解，它们都采用随机化核心，但在实现上各有亮点：
</eval_intro>

**题解一：(来源：ZolaWatle)**
* **点评**：这份题解的思路最直白——用`map`存储原图的边，多次随机排列后检查相邻边。代码结构清晰，变量命名易懂（如`hav`数组存边的存在性），对环的处理（检查首尾边）逻辑严谨。虽然`map`的查询效率略低，但对于题目限制完全够用，适合初学者理解核心逻辑。

**题解二：(来源：Super_Cube)**
* **点评**：此题解在数据结构上更优化——用`unordered_set`存储边（O(1)查询），比`map`更快；用`mt19937`生成更均匀的随机数（比`rand()`好）；随机次数设为100次（足够覆盖大部分情况）。此外，“一旦发现非法边就提前终止检查”的逻辑（`i=n`跳出循环），大幅提升了效率，适合学习如何优化代码。

**题解三：(来源：xyf007)**
* **点评**：这份题解的亮点是“细节拉满”——用快速读入函数（`Gc`+`Read`）处理大数据（避免`cin`的慢速度）；用`set`存储边（自动排序，避免重复）；随机次数动态调整（`3e6/m`次），确保大数据下也能快速找到解。它的`ans`数组用`vector`动态存合法边，逻辑更灵活，适合学习如何优化输入输出。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点是“快速找到合法的边组合”，结合题解共性，我提炼了3个关键思考点：
</difficulty_intro>

1. **关键点1：如何快速查询边是否存在？**
    * **分析**：原图的边需要频繁查询，必须用高效的数据结构。题解中用了`map`（O(logm)）、`unordered_set`（O(1)）、`set`（O(logm)）。其中`unordered_set`最快，但需注意哈希冲突；`set`最稳定，适合需要排序的场景。
    * 💡 **学习笔记**：哈希结构是“存在性查询”的首选！

2. **关键点2：如何生成合法的链/环？**
    * **分析**：利用补图稠密的特点，随机排列后相邻边几乎不可能都在原图中。多次随机尝试（100~1000次）就能找到解。题解都用`shuffle`打乱数组，这是C++标准库生成随机排列的便捷方法。
    * 💡 **学习笔记**：随机化是解决“存在性问题”的利器！

3. **关键点3：如何处理环的情况？**
    * **分析**：当m=n时，新图必须是环，需额外检查排列首尾节点的边是否合法。题解中都在检查完相邻边后，单独判断首尾边，确保环的条件满足。
    * 💡 **学习笔记**：特殊情况（如环）需要单独处理，不能遗漏！

### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用技巧：
</summary_best_practices>
- **技巧A**：用`unordered_set`存边，查询效率O(1)；
- **技巧B**：随机排列+多次尝试，避开复杂的严谨构造；
- **技巧C**：提前终止检查（如发现非法边立即跳出循环），节省时间。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合了三个题解优点的通用实现——用`unordered_set`存边、`mt19937`生成随机数，逻辑清晰且高效：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的优化点，适合作为基础模板。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <unordered_set>
    #include <random>
    using namespace std;

    const int N = 1e5 + 10;
    int n, m;
    vector<unordered_set<int>> g(N); // 存原图的边
    int a[N]; // 存储节点排列

    int main() {
        ios::sync_with_stdio(false); // 加速输入
        cin.tie(nullptr);

        cin >> n >> m;
        for (int i = 0; i < m; ++i) {
            int u, v;
            cin >> u >> v;
            g[u].insert(v);
            g[v].insert(u);
        }

        // 初始化排列：1~n
        for (int i = 1; i <= n; ++i) a[i] = i;

        mt19937 rnd(random_device{}()); // 高质量随机数生成器
        const int T = 100; // 随机尝试次数

        for (int t = 0; t < T; ++t) {
            shuffle(a + 1, a + n + 1, rnd); // 打乱排列
            bool ok = true;

            // 检查链的相邻边
            for (int i = 1; i < n; ++i) {
                if (g[a[i]].count(a[i+1])) { // 边存在，非法
                    ok = false;
                    break;
                }
            }

            // 检查环的首尾边（m=n时）
            if (ok && m == n) {
                if (g[a[n]].count(a[1])) ok = false;
            }

            if (ok) {
                // 输出链的前m条边
                for (int i = 1; i <= m; ++i) {
                    cout << a[i] << " " << a[i+1] << "\n";
                }
                // 环的情况：输出首尾边（m=n时i从1到n，最后一条是a[n]和a[1]）
                if (m == n) cout << a[n] << " " << a[1] << "\n";
                return 0;
            }
        }

        cout << "-1\n"; // 多次尝试失败
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **输入加速**：`ios::sync_with_stdio(false)`和`cin.tie(nullptr)`关闭同步，让`cin`更快；  
    > 2. **边存储**：用`vector<unordered_set<int>>`存每个节点的邻接边，查询`count()`是O(1)；  
    > 3. **随机排列**：`mt19937`生成随机数，`shuffle`打乱数组；  
    > 4. **合法性检查**：先检查链的相邻边，再检查环的首尾边；  
    > 5. **输出结果**：找到合法排列后，输出前m条边（链）或加上首尾边（环）。


<code_intro_selected>
接下来剖析三个题解的核心片段，看看它们的亮点：
</code_intro_selected>

**题解一：(来源：ZolaWatle)**
* **亮点**：用`map`存边，逻辑直观。
* **核心代码片段**：
    ```cpp
    map<int, int> hav[N];
    // 输入处理
    rep(i, 1, m) {
        re x = rint(), y = rint();
        hav[x][y] = hav[y][x] = 1; // 标记边存在
    }
    // 检查边
    rep(i, 2, n) {
        if (hav[a[i-1]][a[i]]) { // 边存在，非法
            flg = 1;
            break;
        }
    }
    ```
* **代码解读**：
    > 用`map<int, int>`数组`hav`存边——`hav[u][v] = 1`表示u和v之间有边。检查时直接访问`hav[a[i-1]][a[i]]`，逻辑非常直观，适合初学者理解。
* 💡 **学习笔记**：`map`是“键值对”容器，适合按键查询，但效率略低于`unordered_set`。

**题解二：(来源：Super_Cube)**
* **亮点**：用`unordered_set`优化查询，`mt19937`生成随机数。
* **核心代码片段**：
    ```cpp
    std::mt19937 rnd(time(0)); // 用时间作为随机种子
    std::unordered_set<int> v[100005];
    // 检查边
    for (int i = 1; i < n; ++i) {
        if (v[a[i]].count(a[i+1])) { // O(1)查询
            ok = 0;
            i = n; // 提前终止循环
        }
    }
    ```
* **代码解读**：
    > 1. `mt19937`是C++11的高质量随机数生成器，比`rand()`更均匀；  
    > 2. `unordered_set`的`count()`方法O(1)查询边是否存在，比`map`快；  
    > 3. 发现非法边时，`i = n`直接跳出循环，节省时间。
* 💡 **学习笔记**：`unordered_set`是哈希表实现的，查询快，但需注意哈希冲突。

**题解三：(来源：xyf007)**
* **亮点**：快速读入优化，动态调整随机次数。
* **核心代码片段**：
    ```cpp
    // 快速读入函数
    char Gc() {
        static char now[1 << 20], *S, *T;
        if (T == S) {
            T = (S = now) + std::fread(now, 1, 1 << 20, stdin); // 一次性读20KB
            if (T == S) return EOF;
        }
        return *S++;
    }
    template <typename T>
    void Read(T &x) {
        x = 0;
        int f = 1;
        char c;
        while ((c = Gc()) < '0' || c > '9') if (c == '-') f = -1;
        x = c - '0';
        while ((c = Gc()) >= '0' && c <= '9') x = x * 10 + (c - '0');
        x *= f;
    }
    // 动态调整随机次数
    std::size_t t = 3000000 / m;
    ```
* **代码解读**：
    > 1. `Gc`函数用`fread`一次性读取输入，比`getchar()`快得多；`Read`函数解析数字，避免`cin`的慢速度，适合处理大数据；  
    > 2. 随机次数`t`设为`3e6/m`，比如m=1e3时t=3000次，确保大数据下也能快速找到解。
* 💡 **学习笔记**：快速读入是处理大规模输入的必备技巧！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解“随机排列连边”的过程，我设计了一个8位像素风格的动画——**《像素节点的洗牌游戏》**，结合复古游戏元素，让你“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：像素节点通过“洗牌”连成合法链/环，伴随复古音效。
  * **设计思路**：采用FC红白机的16色风格（如#000000（黑）、#00FF00（绿）、#FF0000（红）），用16x16的像素方块代表节点，绿色线条代表合法边，红色代表非法边。音效用Web Audio API生成方波/三角波，模拟“洗牌声”“检查声”“胜利声”，增强沉浸感。

  * **动画帧步骤与交互**：

    1. **场景初始化**（FC风格UI）：
       - 左侧**节点区**：16x16的像素方块排成一排，编号1~n（8位字体显示）；
       - 右侧**控制面板**：“开始”“单步”“重置”按钮（像素风格）、速度滑块（慢→快）、“AI自动演示”开关；
       - 背景音乐：循环播放8位风格的轻快BGM（如《超级马里奥》关卡音乐）。

    2. **洗牌动画**：
       - 点击“开始”后，节点区的方块随机交换位置（伴随“哗啦哗啦”的方波音效），模拟“洗牌”过程；
       - 洗牌结束后，节点排成新的顺序（如[4,1,6,2,7,5,8,3]）。

    3. **边检查演示**（核心步骤）：
       - 逐对检查相邻节点：当前检查的两个节点用**黄色闪烁**标记，侧边弹出文字提示“检查边：a[i] ↔ a[i+1]”；
       - 合法边：用**绿色线条**连接，伴随“叮”的三角波音效；
       - 非法边：用**红色线条**连接，伴随“咔”的方波音效，立即停止当前排列的检查，回到洗牌步骤。

    4. **环的处理**（m=n时）：
       - 所有相邻边合法后，检查首尾节点：首尾节点用**蓝色闪烁**标记，提示“检查环的首尾边”；
       - 合法：用绿色线条连接首尾，整个环**闪烁绿色**，伴随“胜利”音效（上扬的方波序列）。

    5. **交互控制**：
       - **单步模式**：点击“单步”按钮，手动执行每一步检查，适合仔细观察；
       - **AI自动演示**：开启后，算法自动完成洗牌→检查→连边的全过程，像“贪吃蛇AI”一样展示解题；
       - **速度滑块**：调整动画速度（慢：1秒/步；快：0.1秒/步）。

  * **旁白提示**（侧边文字气泡）：
    - 洗牌时：“现在随机打乱节点顺序，寻找合法的连边方式！”
    - 检查边时：“检查a[i]和a[i+1]的边——原图没有就能连！”
    - 胜利时：“成功啦！这个排列的边都合法，新图构造完成！”

<visualization_conclusion>
通过这个动画，你可以清晰看到“随机排列→检查边→连合法边”的全过程。复古风格和音效让学习更有趣，也能帮你记住算法的核心逻辑！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的“随机化构造”思路可以迁移到很多“存在性问题”中，比如构造满足条件的序列、图等。以下是几个相似的练习：
</similar_problems_intro>

  * **通用思路迁移**：
    - 补集稠密时，随机尝试比严谨构造更高效；
    - 用哈希结构快速查询“是否存在”；
    - 多次随机尝试提高成功率。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P1113 杂务**
       - 🗣️ **推荐理由**：需要构造满足依赖关系的任务序列，和本题的“构造序列”思路类似，巩固模拟能力。
    2. **洛谷 P2053 [SCOI2007] 修车**
       - 🗣️ **推荐理由**：构造最优修车顺序，用到贪心+模拟，锻炼“构造问题”的理解。
    3. **洛谷 P3384 树链剖分**
       - 🗣️ **推荐理由**：构造树的链分解，和本题的“链构造”思路共通，拓展图结构认知。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
三个题解都提到了“随机化”的重要性，以下是值得借鉴的经验：
</insights_intro>

> **参考经验 (来自 Super_Cube)**：“补图的边数实在太多，很难随机不到正确答案。”
> **点评**：这句话点出了本题的核心——补图稠密，随机化的成功率极高。解决“存在性问题”时，不要一开始就想“严谨构造”，先试试“随机尝试”，往往能事半功倍。

> **参考经验 (来自 xyf007)**：“标算有严谨的构造方法，但相当复杂，而且n≤7时还要暴力特判。”
> **点评**：严谨构造需要处理很多特殊情况（如n小的时候），而随机化可以避开这些复杂判断，适合竞赛中快速写出正确代码。


<conclusion>
本次分析就到这里。这道题的核心是“随机化构造”——利用补图的稠密性，通过随机排列快速找到合法解。希望这份指南能帮你理解随机化的应用，以及如何用哈希结构优化查询。记住：编程中的“暴力”有时也是一种智慧，只要找对方向！💪
</conclusion>

---
处理用时：145.81秒
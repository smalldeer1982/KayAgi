# 题目信息

# Enlarge GCD

## 题目描述

Mr. F has $ n $ positive integers, $ a_1, a_2, \ldots, a_n $ .

He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.

But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.

Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.

## 说明/提示

In the first example, the greatest common divisor is $ 1 $ in the beginning. You can remove $ 1 $ so that the greatest common divisor is enlarged to $ 2 $ . The answer is $ 1 $ .

In the second example, the greatest common divisor is $ 3 $ in the beginning. You can remove $ 6 $ and $ 9 $ so that the greatest common divisor is enlarged to $ 15 $ . There is no solution which removes only one integer. So the answer is $ 2 $ .

In the third example, there is no solution to enlarge the greatest common divisor. So the answer is $ -1 $ .

## 样例 #1

### 输入

```
3
1 2 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4
6 9 15 30
```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 1 1
```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Enlarge GCD 深入学习指南 💡

<introduction>
今天我们来一起分析“Enlarge GCD”这道C++编程题。这道题的关键在于通过删除最少的数，使得剩余数的最大公约数（GCD）比原数组的GCD更大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质因子分解与筛法应用）`

🗣️ **初步分析**：
> 解决“Enlarge GCD”这道题，关键在于运用数论中的质因子分解和筛法（埃拉托斯特尼筛法）。简单来说，质因子分解是将一个数拆解为多个质数的乘积，而筛法可以高效地标记质数并统计质数的倍数出现次数。在本题中，我们需要先计算原数组的GCD，将每个数除以这个GCD，转化为新数组的GCD大于1的问题。此时，我们需要找到新数组中出现次数最多的质因子，这样删除的数最少（总个数减去该质因子的出现次数）。

   - **题解思路**：所有优质题解的核心思路一致：先计算原数组的GCD `d`，将每个数除以 `d` 得到新数组（此时新数组的GCD为1），然后统计新数组中各质因子的出现次数，找到出现次数最多的质因子 `p`，答案即为 `n - 出现次数`（若所有数都是1则返回-1）。
   - **核心难点**：如何高效统计质因子的出现次数（直接暴力分解质因子会超时），以及处理边界情况（如所有数除以 `d` 后均为1）。
   - **可视化设计思路**：动画将展示原数组的GCD计算过程（用像素块堆叠表示数，高亮公共因子），然后每个数除以GCD的过程（像素块缩小），最后用筛法统计质因子次数（用不同颜色的像素块标记质数及其倍数，闪烁表示计数）。
   - **复古像素风格**：采用8位像素风，用不同颜色区分原数组、新数组、质数。关键操作（如除以GCD、筛质数）伴随“叮”的音效，完成统计时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码规范性、算法有效性与优化程度、实践价值等方面，筛选了以下4星及以上的题解：
</eval_intro>

**题解一：作者Siyuan（赞15）**
* **点评**：该题解思路清晰，首先通过计算原数组的GCD `d`，将问题转化为新数组的GCD大于1的问题。优化思路中使用筛法统计质数的倍数出现次数，复杂度降低至O(m log log m)（m为新数组最大值）。代码规范，变量名如 `cnt`（计数）、`mx`（最大值）含义明确。特别是筛法部分，通过预处理质数并枚举倍数，高效统计了各质数的出现次数，是竞赛中常用的优化技巧。

**题解二：作者Acc_Robin（赞9）**
* **点评**：此题解对复杂度分析准确，指出枚举质数倍数的复杂度为O(m log log m)，并通过筛法实现。代码结构简洁，使用命名空间封装逻辑，变量如 `buc`（桶计数）、`p`（质数列表）易于理解。关键步骤（如除以原GCD、筛质数统计）注释清晰，适合竞赛快速实现。

**题解三：作者Npse_D（赞8）**
* **点评**：此题解利用埃筛特性，直接枚举每个数作为质数（未标记时），统计其倍数的出现次数，代码简洁高效。变量 `h` 统计当前质数的倍数个数，`t` 记录最小删除数，逻辑直白。边界处理（如 `t` 初始化为极大值）严谨，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何转化问题为新数组的GCD大于1？**
    * **分析**：原数组的GCD为 `d`，若删除数后的新GCD为 `D > d`，则 `D` 必须是原数组中某些数的公因子且 `d | D`。因此，将所有数除以 `d` 后，新数组的GCD为1，问题转化为让新数组的GCD大于1。
    * 💡 **学习笔记**：通过除以原GCD，将问题简化为寻找新数组的公因子大于1，是关键的问题转化步骤。

2.  **关键点2：如何高效统计质因子的出现次数？**
    * **分析**：直接暴力分解每个数的质因子复杂度高（O(n√a)）。优质题解采用筛法：预处理质数，枚举每个质数 `p`，统计新数组中 `p` 的倍数个数（即能被 `p` 整除的数的个数）。筛法的复杂度为O(m log log m)（m为新数组最大值），高效可行。
    * 💡 **学习笔记**：筛法是统计质数倍数出现次数的高效工具，适合处理大规模数据。

3.  **关键点3：如何处理边界情况（如新数组全为1）？**
    * **分析**：若新数组中所有数都是1，说明无法找到大于1的GCD，返回-1。判断方法是统计所有质数的出现次数，若最大值为0则无解。
    * 💡 **学习笔记**：边界条件（全1）需特别处理，避免逻辑错误。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将原问题转化为新数组的GCD大于1，简化问题复杂度。
- **筛法应用**：预处理质数并统计倍数出现次数，高效解决质因子统计问题。
- **边界处理**：初始化最小删除数为极大值，若最终未更新则返回-1。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用筛法统计质数的倍数出现次数，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 3e5 + 5;
    const int MAXM = 1.5e7 + 5;

    int a[MAXN], cnt[MAXM], vis[MAXM], primes[MAXM / 10];
    int n, d, mx, tot, ans;

    void sieve(int limit) {
        for (int i = 2; i <= limit; ++i) {
            if (!vis[i]) primes[++tot] = i;
            for (int j = 1; j <= tot && i * primes[j] <= limit; ++j) {
                vis[i * primes[j]] = 1;
                if (i % primes[j] == 0) break;
            }
        }
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            d = __gcd(d, a[i]);
        }
        for (int i = 1; i <= n; ++i) {
            a[i] /= d;
            cnt[a[i]]++;
            mx = max(mx, a[i]);
        }
        sieve(mx);
        ans = n;
        for (int i = 1; i <= tot; ++i) {
            int p = primes[i], sum = 0;
            for (int j = p; j <= mx; j += p) sum += cnt[j];
            if (sum) ans = min(ans, n - sum);
        }
        printf("%d\n", ans == n ? -1 : ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先计算原数组的GCD `d`，将每个数除以 `d` 得到新数组，并统计新数组中各数的出现次数（`cnt`数组）。然后用筛法预处理所有不超过新数组最大值的质数。接着枚举每个质数，统计其倍数在新数组中的出现次数 `sum`，计算需要删除的数 `n - sum`，取最小值作为答案。若所有质数的 `sum` 均为0（即新数组全为1），则输出-1。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者Siyuan（优化思路）**
* **亮点**：筛法预处理质数，枚举质数倍数统计次数，复杂度优化至O(m log log m)。
* **核心代码片段**：
    ```cpp
    sieve(mx);
    int ans = n;
    for (int i = 1; i <= tot; ++i) {
        int x = p[i], num = 0;
        for (int j = x; j <= mx; j += x) num += cnt[j];
        if (num) ans = std::min(ans, n - num);
    }
    ```
* **代码解读**：
    > 这段代码是筛法统计质数倍数的核心。`sieve(mx)`预处理所有≤mx的质数（存储在`p`数组中）。然后枚举每个质数`x`，累加其倍数`j`在`cnt`数组中的值（即新数组中能被`x`整除的数的个数`num`）。`ans`记录最小的删除数（`n - num`）。若`num`为0，说明该质数无贡献，跳过。
* 💡 **学习笔记**：筛法枚举质数倍数是统计质因子出现次数的高效方法，避免了暴力分解的高复杂度。

**题解二：作者Npse_D**
* **亮点**：直接枚举每个数作为质数（未标记时），统计其倍数次数，代码简洁。
* **核心代码片段**：
    ```cpp
    for(int i=2;i<=inf;i++){
        int h=0;
        if(!vis[i])for(int j=i;j<=inf;j+=i)vis[j]=1,h+=c[j];
        t=min(t,n-h);
    }
    ```
* **代码解读**：
    > 这段代码中，`vis`数组标记非质数。当`i`是质数（`!vis[i]`），枚举其所有倍数`j`（标记为非质数），并累加`c[j]`（新数组中`j`的出现次数）到`h`。`t`记录最小的删除数（`n - h`）。
* 💡 **学习笔记**：利用埃筛过程中标记非质数的特性，同时统计质数倍数的出现次数，一举两得。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“筛法统计质因子次数”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素小侦探的GCD冒险`

  * **核心演示内容**：展示原数组的GCD计算、每个数除以GCD的过程，以及筛法统计质因子次数的动态过程。

  * **设计思路简述**：采用8位像素风（类似FC红白机），用不同颜色像素块表示原数组（蓝色）、新数组（绿色）、质数（红色）。关键操作（如除以GCD、筛质数）伴随“叮”的音效，完成统计时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示原数组（蓝色像素块，标有数值），右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。
          * 播放8位风格的轻快背景音乐。

    2.  **计算原GCD**：
          * 像素小侦探（黄色方块）从左到右遍历原数组，每访问一个数，头顶显示当前GCD（如“GCD=3”）。
          * 最终GCD值（如“d=3”）用大字体显示在屏幕中央，伴随“咚”的音效。

    3.  **生成新数组**：
          * 每个原数组的蓝色像素块缩小并变为绿色（表示除以d），数值更新为原数/d（如“6→2”）。
          * 绿色像素块下方显示新数组的GCD（初始为“GCD=1”）。

    4.  **筛法统计质因子**：
          * 像素小侦探携带筛子（红色网格），从2开始枚举每个数：
            - 若当前数是质数（未被标记，绿色），小侦探用筛子标记其所有倍数（变为红色），并累加这些倍数的出现次数（头顶显示计数，如“h=3”）。
            - 每次标记倍数时，播放“叮”的音效；计数更新时，像素块闪烁。
          * 屏幕右侧动态显示各质数的出现次数（柱状图，红色柱子高度表示次数）。

    5.  **确定最小删除数**：
          * 找到最高的红色柱子（出现次数最多的质因子），计算删除数（n - 次数），用金色字体显示结果。
          * 播放胜利音效（“啦~”），像素小侦探摆出庆祝姿势。

    6.  **边界情况（全1）**：
          * 若所有绿色像素块数值为1，屏幕显示“-1”，背景音乐变为短促的“呜~”音效。

  * **旁白提示**：
      * （计算原GCD时）“小侦探正在计算所有数的GCD，这是关键的第一步！”
      * （生成新数组时）“每个数都除以GCD，现在新数组的GCD是1，我们需要让它变大！”
      * （筛法统计时）“看！小侦探用筛子标记质数的倍数，统计这些数的个数，就能知道保留多少数啦~”

<visualization_conclusion>
通过这样一个融合像素艺术和游戏元素的动画，我们能清晰看到算法的每一步，理解质因子统计和最小删除数的计算过程。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考质因子分解和筛法的适用范围。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 质因子分解和筛法不仅用于本题，还常用于：
        1. 计算多个数的LCM（最小公倍数）。
        2. 统计区间内的质数个数（如素数筛）。
        3. 解决数论中的约数问题（如求最大公约数、互质数对）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1072** - `Hankson的趣味题`
          * 🗣️ **推荐理由**：此题涉及GCD和LCM的综合应用，能巩固质因子分解的技巧。
    2.  **洛谷 P3383** - `线性筛法（埃氏筛）`
          * 🗣️ **推荐理由**：通过此题练习筛法的实现，深入理解质数的预处理过程。
    3.  **洛谷 P1463** - `[POI2002][HAOI2007]反素数`
          * 🗣️ **推荐理由**：此题需利用质因子分解寻找反素数，适合拓展质因子的应用思维。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者cxy000)**：“在处理全1的情况时，一开始忘记特判，导致测试用例出错。后来通过添加`ooo`变量判断所有数是否相同，解决了问题。”
>
> **点评**：这位作者的经验提醒我们，边界条件（如全1）是常见的错误点。在编码时，应提前考虑所有可能的边界情况，并添加针对性的判断（如统计新数组是否全为1）。这能有效避免因忽略特殊情况导致的错误。

-----

<conclusion>
本次关于“Enlarge GCD”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解质因子分解和筛法的应用。记住，编程能力的提升在于持续学习和实践，下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：129.87秒
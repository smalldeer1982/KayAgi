# 题目信息

# Enlarge GCD

## 题目描述

Mr. F has $ n $ positive integers, $ a_1, a_2, \ldots, a_n $ .

He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.

But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.

Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.

## 说明/提示

In the first example, the greatest common divisor is $ 1 $ in the beginning. You can remove $ 1 $ so that the greatest common divisor is enlarged to $ 2 $ . The answer is $ 1 $ .

In the second example, the greatest common divisor is $ 3 $ in the beginning. You can remove $ 6 $ and $ 9 $ so that the greatest common divisor is enlarged to $ 15 $ . There is no solution which removes only one integer. So the answer is $ 2 $ .

In the third example, there is no solution to enlarge the greatest common divisor. So the answer is $ -1 $ .

## 样例 #1

### 输入

```
3
1 2 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4
6 9 15 30
```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 1 1
```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Enlarge GCD 深入学习指南 💡

<introduction>
今天我们来一起分析“Enlarge GCD”这道C++编程题。这道题的关键在于通过删除最少的数，让剩余数的最大公约数（GCD）比原数组的GCD更大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质因数分解与统计）`

🗣️ **初步分析**：
解决“Enlarge GCD”的关键在于利用质因数分解和统计。简单来说，我们需要找到一个质数，使得原数组中尽可能多的数在除以原GCD后是它的倍数。这样，保留这些数就能让新的GCD至少为该质数，从而大于原GCD。

- **题解思路**：首先计算原数组的GCD（记为`d`），将每个数除以`d`得到新数组（此时新数组的GCD为1）。然后枚举所有可能的质数，统计每个质数在新数组中的倍数个数，选择倍数最多的质数，需要删除的数即为总数减去该质数的倍数个数。若无这样的质数，返回-1。
- **核心难点**：如何高效统计质数的倍数个数？如何避免重复计算质因数？
- **可视化设计**：用像素风格展示原数组GCD的计算过程，新数组的生成（每个数除以`d`），以及枚举质数时的倍数统计（用不同颜色高亮倍数，伴随“叮”的音效提示）。动画支持单步执行，可查看每一步的质数选择和统计结果。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（≥4星）：
</eval_intro>

**题解一：作者Siyuan（优化思路）**
* **点评**：此题解思路清晰，通过先计算原GCD并除以它，将问题转化为新数组的GCD大于1的问题。代码中利用埃拉托斯特尼筛法（埃筛）枚举质数，并统计每个质数的倍数个数，时间复杂度优化到O(m log log m)（m为新数组最大值）。代码结构简洁，变量命名直观（如`cnt`统计倍数个数），边界处理严谨（如判断`ans`是否为初始最大值），实践参考价值高。

**题解二：作者Acc_Robin**
* **点评**：此题解对问题转化的解释非常透彻（原数组除以GCD后新数组GCD为1），并明确指出枚举质数的必要性（合数的质因数更优）。代码中使用线性筛预处理质数，统计每个质数的倍数个数，逻辑直接。变量`buc`用于计数，`mx`记录最大值，代码可读性强，适合竞赛参考。

**题解三：作者Npse_D**
* **点评**：此题解巧妙利用埃筛特性，在筛质数的同时统计倍数个数，避免了重复计算。代码简洁高效（如`vis`数组标记已筛质数，`h`累加倍数个数），关键步骤注释清晰，适合理解质数枚举与统计的核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们通常会遇到以下几个关键点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：原数组GCD的处理**
    * **分析**：原数组的GCD`d`是问题的起点。将每个数除以`d`后，新数组的GCD变为1，此时只需找到一个质数`p`，使得新数组中尽可能多的数是`p`的倍数。优质题解均通过这一步转化，简化了问题。
    * 💡 **学习笔记**：原GCD的存在会掩盖质因数的分布，除以`d`后能聚焦到真正需要考虑的质因数上。

2.  **关键点2：质数的枚举与倍数统计**
    * **分析**：枚举质数时，若直接暴力分解每个数的质因数会超时。优质题解采用埃筛或线性筛预处理质数，同时统计每个质数的倍数个数（如遍历质数`p`，累加`p, 2p, 3p...`的出现次数）。这种方法利用了筛法的高效性，时间复杂度低。
    * 💡 **学习笔记**：筛法是处理质数相关统计问题的“利器”，能高效覆盖所有可能的质数。

3.  **关键点3：避免重复统计质因数**
    * **分析**：一个数可能有多个质因数（如6=2×3），统计时需避免重复计数（如6会被2和3各统计一次）。优质题解通过标记已处理的质数（如`vis`数组）或仅统计质数的倍数，确保每个数被其最小质因数统计一次。
    * 💡 **学习笔记**：统计时关注最小质因数或标记已筛质数，可避免重复，确保结果准确。

### ✨ 解题技巧总结
- **问题转化**：将原问题转化为新数组的GCD大于1，简化了目标（只需找质数）。
- **筛法应用**：利用埃筛或线性筛预处理质数，高效统计倍数个数。
- **边界处理**：若所有数除以原GCD后均为1（如样例3），则无解，返回-1。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合优质题解的通用核心C++实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Siyuan、Acc_Robin等题解的思路，采用埃筛统计质数的倍数个数，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    const int N = 3e5 + 5;
    const int M = 1.5e7 + 5;
    int n, a[N], d, cnt[M], mx, ans;
    bool vis[M];

    void sieve(int max_num) {
        for (int i = 2; i <= max_num; ++i) {
            if (!vis[i]) { // i是质数
                for (int j = i; j <= max_num; j += i) {
                    vis[j] = true; // 标记i的倍数
                    cnt[i] += ::cnt[j]; // 统计i的倍数在新数组中的出现次数
                }
                if (cnt[i] > 0) {
                    ans = min(ans, n - cnt[i]); // 更新最小删除数
                }
            }
        }
    }

    int main() {
        scanf("%d", &n);
        for (int i = 0; i < n; ++i) {
            scanf("%d", &a[i]);
            d = __gcd(d, a[i]); // 计算原数组GCD
        }
        for (int i = 0; i < n; ++i) {
            int num = a[i] / d;
            cnt[num]++; // 统计新数组中各数的出现次数
            mx = max(mx, num); // 记录新数组最大值
        }
        ans = n; // 初始化为n（最多删除n个数）
        sieve(mx); // 筛质数并统计倍数个数
        printf("%d\n", ans == n ? -1 : ans);
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先计算原数组的GCD`d`，将每个数除以`d`得到新数组，并统计新数组中各数的出现次数。然后通过埃筛枚举所有可能的质数，统计每个质数的倍数个数（即新数组中能被该质数整除的数的个数），最后计算需要删除的最小数（总数减去该质数的倍数个数）。若所有质数的倍数个数均为0，返回-1。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解其亮点和思路。
</code_intro_selected>

**题解一：作者Siyuan（优化思路）**
* **亮点**：通过筛法枚举质数，直接统计倍数个数，时间复杂度低。
* **核心代码片段**：
    ```cpp
    sieve(mx); // 筛法预处理质数
    int ans = n;
    for (int i = 1; i <= tot; ++i) { // tot是筛出的质数个数
        int x = p[i], num = 0;
        for (int j = x; j <= mx; j += x) num += cnt[j]; // 统计x的倍数个数
        if (num) ans = min(ans, n - num); // 更新最小删除数
    }
    ```
* **代码解读**：
    这段代码中，`sieve(mx)`预处理出所有≤mx的质数。然后枚举每个质数`x`，遍历其所有倍数`j`（从`x`到`mx`，步长`x`），累加`cnt[j]`（即新数组中`j`的出现次数）得到`num`（`x`的倍数总个数）。`ans`取`n - num`的最小值。这一步利用了筛法的高效性，确保统计过程快速完成。
* 💡 **学习笔记**：筛法不仅能找质数，还能高效统计质数的倍数分布，是解决此类问题的关键。

**题解二：作者Acc_Robin**
* **亮点**：线性筛预处理质数，代码简洁，逻辑清晰。
* **核心代码片段**：
    ```cpp
    void sieve(int n) {
        np[0] = np[1] = 1;
        for (int i = 2; i <= n; ++i) {
            if (!np[i]) p[++cnt] = i; // 记录质数
            for (int j = 1; j <= cnt && p[j] * i <= n; ++j) {
                np[i * p[j]] = 1;
                if (i % p[j] == 0) break;
            }
        }
    }
    // 主函数中统计倍数个数
    for (int i = 1; i <= cnt; ++i) {
        int res = 0;
        for (int j = 1; p[i] * j <= mx; ++j) res += buc[p[i] * j];
        if (res) ans = max(ans, res);
    }
    ```
* **代码解读**：
    `sieve`函数用线性筛预处理质数（`np`标记非质数，`p`存储质数）。主函数中枚举每个质数`p[i]`，遍历其倍数`p[i]*j`（`j≥1`），累加`buc[p[i]*j]`（新数组中`p[i]*j`的出现次数）得到`res`（`p[i]`的倍数总个数）。`ans`取`res`的最大值，最终答案为`n - ans`。这一步通过线性筛确保质数的预处理高效，统计过程直接。
* 💡 **学习笔记**：线性筛能更高效地预处理质数，适合处理大范围的质数统计问题。

**题解三：作者Npse_D**
* **亮点**：利用埃筛特性，边筛边统计，避免重复计算。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= inf; ++i) {
        int h = 0;
        if (!vis[i]) { // i是质数
            for (int j = i; j <= inf; j += i) {
                vis[j] = 1; // 标记i的倍数
                h += c[j]; // 统计i的倍数个数
            }
            t = min(t, n - h); // 更新最小删除数
        }
    }
    ```
* **代码解读**：
    这段代码中，`vis`数组标记已处理的数。对于每个未标记的`i`（即质数），遍历其倍数`j`（从`i`到最大值`inf`，步长`i`），标记`vis[j]`为1（避免重复处理），并累加`c[j]`（新数组中`j`的出现次数）得到`h`（`i`的倍数总个数）。`t`取`n - h`的最小值。这种边筛边统计的方式，确保每个质数只处理一次，效率更高。
* 💡 **学习笔记**：埃筛的“标记”特性可避免重复统计，适合快速处理质数的倍数分布。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解质数枚举与倍数统计的过程，我设计了一个“像素质数探险”动画，用8位像素风格展示算法每一步！
</visualization_intro>

  * **动画演示主题**：`像素质数探险——寻找最大公约数的宝藏`

  * **核心演示内容**：展示原数组GCD的计算、新数组的生成（每个数除以原GCD）、质数的枚举，以及每个质数的倍数统计过程，最终找到需要删除数最少的方案。

  * **设计思路简述**：采用8位像素风（类似FC游戏），用不同颜色区分原数组、新数组、质数及其倍数。关键操作（如计算GCD、筛质数、统计倍数）伴随“叮”的音效，完成统计时播放“胜利”音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左半部分显示原数组（像素方块，数字标注），右半部分显示控制面板（开始/暂停、单步、速度滑块）。
          * 背景播放8位风格的轻快音乐（如《超级马里奥》的经典BGM变调）。

    2.  **计算原GCD**：
          * 原数组的每个数从左到右滑动到屏幕中央，顶部显示“计算GCD”的文字提示。
          * 最终GCD`d`以放大的像素数字出现在中央，伴随“滴”的音效。

    3.  **生成新数组**：
          * 原数组的每个数除以`d`（像素方块颜色变浅），新数组生成，顶部显示“新数组（GCD=1）”。

    4.  **质数枚举与倍数统计**：
          * 质数从2开始逐个出现在屏幕左侧（像素字体），每个质数`p`触发“叮”的音效。
          * 新数组中所有`p`的倍数（如`p, 2p, 3p...`）的像素方块变为绿色，并闪烁提示，同时右侧统计框显示当前质数的倍数个数。
          * 统计完成后，显示“需要删除：n - 个数”的提示，数值动态更新。

    5.  **找到最优解**：
          * 所有质数处理完毕后，最大的倍数个数对应的质数高亮，删除数最少的方案以金色像素框标出，播放“胜利”音效（如《超级玛丽》吃金币的音效）。
          * 若无解（所有数除以`d`后均为1），显示红色“-1”提示，播放短促“失败”音效。

    6.  **交互控制**：
          * 支持“单步执行”（每按一次，处理一个质数）、“自动播放”（按设定速度播放）、“重置”（回到初始状态）。
          * 速度滑块可调节动画快慢（慢速度适合观察细节，快速度适合整体流程）。

  * **旁白提示**：
      * （计算GCD时）“首先，我们需要计算原数组的GCD，这是问题的起点！”
      * （生成新数组时）“每个数除以GCD后，新数组的GCD变为1，现在我们需要找一个质数，让它的倍数尽可能多～”
      * （枚举质数时）“看！这个质数的倍数都变绿了，它们的个数越多，需要删除的数就越少哦！”

<visualization_conclusion>
通过这样一个融合像素艺术和游戏元素的动画，我们能清晰看到质数枚举与倍数统计的每一步，轻松理解算法核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以进一步思考质因数分解和GCD相关问题的变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 质因数分解与统计不仅能解决本题，还适用于：
        1. 求多个数的最大公约数或最小公倍数。
        2. 判断一个数是否为质数（如米勒-拉宾素性测试）。
        3. 统计数组中满足某种质因数条件的数的个数（如统计偶数的个数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1072** - `Hankson的趣味题`
          * 🗣️ **推荐理由**：这道题需要结合GCD和质因数分解，思考如何通过因数关系求解，能巩固本题的质因数统计技巧。
    2.  **洛谷 P1447** - `[NOI2010] 能量采集`
          * 🗣️ **推荐理由**：此题涉及GCD的求和，需要利用数论中的容斥原理和筛法，是质因数统计的进阶应用。
    3.  **洛谷 P1390** - `公约数的和`
          * 🗣️ **推荐理由**：此题要求计算所有数对的GCD之和，需要结合欧拉函数和筛法，能提升对质因数分解的灵活运用能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自作者Siyuan)**：“在最初的版本中，我没有预处理质数，直接对每个数分解质因数，导致超时。后来意识到用筛法统计质数的倍数更高效，才优化了时间复杂度。”
>
> **点评**：这位作者的经验提醒我们，遇到大范围质数统计问题时，筛法往往比暴力分解更高效。在编程时，要注意分析时间复杂度，选择合适的算法优化方法。

-----

<conclusion>
本次关于“Enlarge GCD”的C++解题分析就到这里。希望这份学习指南能帮助大家理解质因数分解与统计的核心逻辑，掌握解题技巧。记住，多练习、多思考，编程能力会一步步提升！下次见～💪
</conclusion>

-----

---
处理用时：117.21秒
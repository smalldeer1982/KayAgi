# 题目信息

# Congruence Equation

## 题目描述

Given an integer $ x $ . Your task is to find out how many positive integers $ n $ ( $ 1<=n<=x $ ) satisfy

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF919E/02717f82c41ef4ed609db5d967f659c9784212e1.png) where $ a,b,p $ are all known constants.

## 说明/提示

In the first sample, we can see that $ n=2 $ and $ n=8 $ are possible answers.

## 样例 #1

### 输入

```
2 3 5 8
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 6 7 13
```

### 输出

```
1
```

## 样例 #3

### 输入

```
233 233 10007 1
```

### 输出

```
1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Congruence Equation 深入学习指南 💡

<introduction>
今天我们来一起分析“Congruence Equation”这道题。题目要求我们找到满足 \( na^n \equiv b \pmod{p} \) 的正整数 \( n \)（\( 1 \leq n \leq x \)）的个数。这道题的关键在于利用数论中的周期性和同余性质，将大范围的枚举转化为小范围的数学推导。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（同余方程与周期性应用）`

🗣️ **初步分析**：
解决这道题的关键在于利用数论中的“周期性”和“同余方程求解”。简单来说，同余方程的解往往具有周期性，就像钟表的指针每12小时循环一次一样，这里的 \( a^n \mod p \) 也会因为费马小定理（当 \( p \) 是质数时，\( a^{p-1} \equiv 1 \pmod{p} \)）而呈现周期为 \( p-1 \) 的规律。结合 \( n \) 本身的模 \( p \) 周期性，整体解的周期可以缩小到 \( p(p-1) \)，从而避免直接枚举 \( n \)（因为 \( x \) 可能高达 \( 10^{12} \)）。

- **题解思路**：所有优质题解均通过枚举 \( n \mod (p-1) \) 的余数 \( r \)（共 \( p-1 \) 种可能），将原方程转化为关于 \( k \) 的同余方程（\( n = k(p-1) + r \)），进而求解满足条件的 \( k \) 范围，统计 \( n \leq x \) 的解数。
- **核心难点**：如何将原方程 \( na^n \equiv b \pmod{p} \) 转化为仅含 \( r \) 和 \( k \) 的同余式，并快速统计周期内的解数。
- **可视化设计**：我们将设计一个“像素周期探险”动画，用8位像素风格展示 \( r \) 的枚举过程（\( 0 \leq r < p-1 \)），动态计算每个 \( r \) 对应的 \( k \) 值，并高亮符合条件的 \( n \) 的个数累加过程。例如，用不同颜色的像素块表示 \( r \) 的循环节，用闪烁效果标记有效解，配合“叮”的音效提示关键步骤。

---

## 2. 精选优质题解参考

<eval_intro>
通过对思路清晰度、代码可读性、算法有效性等维度的评估，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：来源：Acc_Robin**
* **点评**：此题解思路简洁直接，充分利用费马小定理和周期性。作者首先通过 \( n = k(p-1) + r \) 将原方程转化为 \( (r - k)a^r \equiv b \pmod{p} \)，进而枚举 \( r \) 求解 \( k \)。代码中 `qpow` 函数实现快速幂求逆元，逻辑紧凑。亮点在于对周期 \( p(p-1) \) 的准确把握，直接计算每个 \( r \) 对应的解数，避免了冗余计算。实践价值高，代码可直接用于竞赛。

**题解二：来源：interestingLSY**
* **点评**：此题解对周期性的解释通俗易懂，通过“枚举 \( a^n \mod p \) 的可能值”引导思考。作者将原方程拆解为 \( n \equiv i \pmod{p-1} \) 和 \( n \equiv b \cdot \text{Inv}(a^i) \pmod{p} \) 的同余方程组，并用中国剩余定理求解。代码中 `Cal` 函数清晰计算每个 \( r \) 对应的最小 \( n \) 及解数，变量命名直观（如 `power` 表示 \( a^r \)），适合初学者理解。

**题解三：来源：mydcwfy**
* **点评**：此题解巧妙利用逆元的递推性质（\( \text{Inv}(a^r) = \text{Inv}(a^{r-1}) \cdot \text{Inv}(a) \)）优化计算，减少了快速幂的调用次数。代码通过预处理逆元，将时间复杂度稳定在 \( O(p) \)，是对时间效率的进一步优化。亮点在于对逆元递推的灵活运用，展示了数论技巧在代码优化中的作用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于突破以下三个核心难点，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何利用周期性缩小枚举范围？**
    * **分析**：由于 \( p \) 是质数，根据费马小定理，\( a^{p-1} \equiv 1 \pmod{p} \)，因此 \( a^n \mod p \) 的周期为 \( p-1 \)。同时，\( n \mod p \) 的周期为 \( p \)。两者结合，\( na^n \mod p \) 的整体周期为 \( p(p-1) \)。通过枚举 \( r = n \mod (p-1) \)（共 \( p-1 \) 种可能），可以覆盖所有可能的 \( a^n \mod p \) 值。
    * 💡 **学习笔记**：当问题中出现模运算且模数较小时，寻找周期性是缩小枚举范围的关键。

2.  **关键点2：如何将原方程转化为同余方程组？**
    * **分析**：设 \( n = k(p-1) + r \)（\( 0 \leq r < p-1 \)），代入原方程得 \( (k(p-1)+r)a^{k(p-1)+r} \equiv b \pmod{p} \)。利用费马小定理简化后得到 \( (r - k)a^r \equiv b \pmod{p} \)，进一步变形为 \( k \equiv r - b \cdot \text{Inv}(a^r) \pmod{p} \)。此时，\( k \) 的取值范围决定了 \( n \) 是否满足 \( n \leq x \)。
    * 💡 **学习笔记**：将复杂方程拆分为关于 \( r \) 和 \( k \) 的同余式，是解决此类问题的标准方法。

3.  **关键点3：如何统计周期内的解数？**
    * **分析**：对于每个 \( r \)，找到最小的 \( k \) 使得 \( n = k(p-1) + r \leq x \)，则解数为 \( \left\lfloor \frac{x - n}{p(p-1)} \right\rfloor + 1 \)。需注意 \( n \) 必须满足 \( 1 \leq n \leq x \)，否则不计入统计。
    * 💡 **学习笔记**：利用周期的重复性，通过数学公式直接计算解数，避免逐个枚举。

### ✨ 解题技巧总结
- **技巧1：费马小定理的灵活应用**：当 \( p \) 为质数时，\( a^{p-1} \equiv 1 \pmod{p} \)，可快速简化指数项的模运算。
- **技巧2：逆元预处理**：通过递推计算 \( \text{Inv}(a^r) \)（如 \( \text{Inv}(a^r) = \text{Inv}(a^{r-1}) \cdot \text{Inv}(a) \)），减少快速幂的调用次数。
- **技巧3：同余方程的拆解**：将原方程拆分为模 \( p \) 和模 \( p-1 \) 的两个同余式，利用中国剩余定理或直接求解 \( k \) 的范围。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，逻辑清晰且高效，适合作为参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Acc_Robin和interestingLSY的思路，通过枚举 \( r \) 并计算每个 \( r \) 对应的解数，时间复杂度为 \( O(p \log p) \)。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    using ll = long long;

    ll qpow(ll a, ll b, ll mod) {
        ll res = 1;
        a %= mod;
        while (b) {
            if (b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }

    int main() {
        ll a, b, p, x;
        cin >> a >> b >> p >> x;
        ll ans = 0;
        for (ll r = 0; r < p - 1; ++r) {
            ll ar = qpow(a, r, p); // a^r mod p
            ll inv_ar = qpow(ar, p - 2, p); // 逆元：ar^(p-2) mod p
            ll f = b * inv_ar % p; // b * inv(ar) mod p
            ll k = (r - f + p) % p; // k ≡ r - f mod p
            ll n = k * (p - 1) + r; // 最小n
            if (n > x) continue;
            ll cycle = p * (p - 1); // 周期
            ans += (x - n) / cycle + 1;
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入参数 \( a, b, p, x \)，然后枚举 \( r \)（\( 0 \leq r < p-1 \)）。对于每个 \( r \)，计算 \( a^r \mod p \) 及其逆元，进而求出 \( k \) 的最小正整数值，得到对应的 \( n \)。若 \( n \leq x \)，则统计周期 \( p(p-1) \) 内的解数并累加到答案中。核心逻辑通过快速幂求逆元，确保了计算效率。

---
<code_intro_selected>
接下来，我们分析优质题解的关键代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：来源：Acc_Robin**
* **亮点**：代码简洁，直接利用 \( r \) 枚举和快速幂求逆元，时间复杂度 \( O(p \log p) \)。
* **核心代码片段**：
    ```cpp
    for(int r=0,f,k,now;r<p-1;r++){
        f=b*qpow(qpow(a,r))%p;
        k=(r-f+p)%p;
        if((now=k*(p-1)+r)>x)continue;
        ans+=(x-now)/(p*(p-1))+1;
    }
    ```
* **代码解读**：
    > 这段代码枚举 \( r \)（\( 0 \leq r < p-1 \)）。`qpow(a, r)` 计算 \( a^r \mod p \)，`qpow(qpow(a, r))` 计算其逆元（因为 \( p \) 是质数，逆元为 \( a^{r(p-2)} \mod p \)）。`f` 是 \( b \cdot \text{Inv}(a^r) \mod p \)，`k` 是 \( (r - f) \mod p \)。`now` 是最小的 \( n = k(p-1) + r \)，若 `now ≤ x`，则统计周期内的解数。
* 💡 **学习笔记**：快速幂求逆元是数论问题中的常用技巧，这里通过两次快速幂（一次求 \( a^r \)，一次求逆元）完成关键计算。

**题解二：来源：interestingLSY**
* **亮点**：将同余方程组的求解封装为 `Cal` 函数，逻辑清晰。
* **核心代码片段**：
    ```cpp
    ll Cal( int n , int power ){
        ll now = b * Inv(power) % p;
        ll correctn = (p-1)*Mod(n-now,p) + n;
        if( correctn > x ) return 0LL;
        return (x-correctn) / (p*(p-1)) + 1;
    }
    ```
* **代码解读**：
    > `Cal` 函数计算给定 \( r \)（即 `n`）和 \( a^r \)（即 `power`）时的解数。`now` 是 \( b \cdot \text{Inv}(a^r) \mod p \)，`correctn` 是满足 \( n \equiv r \pmod{p-1} \) 和 \( n \equiv now \pmod{p} \) 的最小 \( n \)。若 `correctn ≤ x`，则返回周期内的解数。
* 💡 **学习笔记**：将复杂计算封装为函数，提高代码可读性和复用性。

**题解三：来源：mydcwfy**
* **亮点**：利用逆元的递推性质优化计算，减少快速幂调用。
* **核心代码片段**：
    ```cpp
    ll now = b, inv = qpow(a, Mod - 2), lim = Mod * (Mod - 1), ans = 0;
    for (ll modp1 = 0; modp1 < Mod - 1; ++ modp1, now = now * inv % Mod) {
        ll mx = (modp1 - now + (Mod - 1)) % (Mod - 1) * Mod + now;
        mx = (mx % lim + lim) % lim;
        if (mx <= x) ans += (x - mx + lim) / lim;
    }
    ```
* **代码解读**：
    > `now` 初始为 \( b \)，每次循环乘以 \( \text{Inv}(a) \)，相当于递推计算 \( b \cdot \text{Inv}(a^r) \mod p \)（因为 \( \text{Inv}(a^r) = \text{Inv}(a^{r-1}) \cdot \text{Inv}(a) \)）。`mx` 是满足条件的最小 \( n \)，通过模运算调整后统计解数。
* 💡 **学习笔记**：递推计算逆元可避免重复调用快速幂，提升代码效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举 \( r \) 并计算解数的过程，我们设计一个“像素周期探险”动画，用8位复古风格展示算法核心步骤。
</visualization_intro>

  * **动画演示主题**：`像素探险家的周期之旅`
  * **核心演示内容**：探险家在 \( r \) 的循环节（\( 0 \leq r < p-1 \)）中逐个探索，每到达一个 \( r \) 节点，计算对应的 \( k \) 和 \( n \)，并统计符合 \( n \leq x \) 的解数。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），通过颜色区分不同 \( r \) 的状态（有效/无效），用像素方块动态展示 \( n \) 的周期累加。关键操作（如计算逆元、判断 \( n \leq x \)）配合“叮”的音效，增强记忆点；每完成一个 \( r \) 的探索，视为“小关卡”通过，激发学习兴趣。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧展示 \( r \) 的循环节（\( 0 \) 到 \( p-2 \) 的像素块，初始为灰色），右侧展示 \( n \) 的周期 \( p(p-1) \) 网格。
          * 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块。

    2.  **枚举 \( r \)**：
          * 探险家（像素小人）从 \( r=0 \) 开始，每步移动到下一个 \( r \) 块，块颜色变为黄色（当前处理）。
          * 计算 \( a^r \mod p \)：对应像素块显示 \( a^r \) 的值，伴随“唰”的音效。

    3.  **计算 \( k \) 和 \( n \)**：
          * 弹出小窗口显示 \( (r - k)a^r \equiv b \pmod{p} \)，计算 \( k \) 时，\( k \) 的值在对话框中动态生成（如数字逐个出现）。
          * 计算 \( n = k(p-1) + r \)：若 \( n \leq x \)，\( n \) 对应的像素块变为绿色；否则为红色。

    4.  **统计解数**：
          * 绿色 \( n \) 块触发“叮”音效，右侧周期网格中显示 \( (x - n) / (p(p-1)) + 1 \) 的数值，数值逐位增加。
          * 总解数 \( ans \) 在屏幕顶部实时更新，用大字号显示。

    5.  **结束状态**：
          * 所有 \( r \) 枚举完成后，播放“胜利”音效（如短旋律），总解数 \( ans \) 高亮闪烁。

  * **旁白提示**：
      * “现在处理 \( r=2 \)，计算 \( a^2 \mod p \) 的值...”
      * “\( k \) 的值是 \( (r - b \cdot \text{Inv}(a^r)) \mod p \)，这里得到 \( k=3 \)！”
      * “\( n=3*(p-1)+2=8 \) 小于 \( x=10 \)，所以这个周期内有 \( (10-8)/p(p-1)+1=1 \) 个解！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到每个 \( r \) 如何影响最终的解数，以及周期 \( p(p-1) \) 是如何帮助快速统计解的。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是利用数论周期性和同余方程求解，这类思路在许多数论问题中都有应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 当问题涉及大范围内的模运算时（如 \( x \leq 10^{12} \)），寻找周期性是关键（如 \( a^n \mod p \) 的周期为 \( p-1 \)）。
      * 同余方程的拆解（如拆为模 \( p \) 和模 \( p-1 \) 的两个方程）是解决复杂同余问题的通用方法。
      * 逆元的灵活计算（如递推或快速幂）能优化时间效率。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1516 青蛙的约会**
          * 🗣️ **推荐理由**：这道题需要解线性同余方程 \( x + mt \equiv y + nt \pmod{L} \)，与本题的同余方程求解思路类似，适合巩固同余方程的解法。
    2.  **洛谷 P3811 【模板】乘法逆元**
          * 🗣️ **推荐理由**：逆元是数论问题的基础工具，此题可帮助熟练掌握逆元的多种计算方法（如快速幂、线性递推）。
    3.  **洛谷 P4549 【模板】裴蜀定理**
          * 🗣️ **推荐理由**：本题涉及同余方程的存在性判断，通过练习可加深对同余方程解的条件的理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试和思考的经验，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自 Acc_Robin)**：“一开始没注意到 \( a^n \) 的周期性，直接枚举 \( n \) 导致超时。后来想到费马小定理，才意识到可以枚举 \( r = n \mod (p-1) \)，大大减少了计算量。”
>
> **点评**：这位作者的经验提醒我们，当遇到大范围枚举问题时，应首先寻找问题的周期性或数学规律，避免暴力枚举。费马小定理是处理质数模指数问题的重要工具，熟练应用可以大幅优化算法。

-----

<conclusion>
本次关于“Congruence Equation”的解题分析就到这里。希望大家通过本指南掌握数论中周期性和同余方程的应用技巧。记住，遇到大数范围问题时，寻找周期性是关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：145.44秒
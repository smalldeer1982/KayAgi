# 题目信息

# Order book

## 题目描述

我们来考虑某只股票的一个简化版订单簿。订单簿是一个订单（报价）列表，每个订单代表有人想以某个价格买入或卖出一单位该股票。每个订单由方向（BUY 或 SELL）和价格描述。

在任意时刻，所有 SELL 报价的价格都高于所有 BUY 报价的价格。

在本题中，任意两个曾经存在过的订单都不会有相同的价格。

最低价的 SELL 订单和最高价的 BUY 订单被称为最优报价，如下图中用黑框标出。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1028D/413fddcebb561deb1348fbeb910f4e1fa1dc550e.png)

如图所示，某人以价格 $12$ 卖出产品，这是最优的 SELL 报价，因为另外两个 SELL 报价价格更高。最优的 BUY 报价价格为 $10$。

在这个订单簿中有两种可能的操作：

1. 有人以某个方向和价格添加一个新订单。
2. 有人以最优的 SELL 或 BUY 报价成交（达成交易）。只能接受最优的 SELL 或 BUY 报价（即以最优价格成交），不能以更差的价格成交。成交后，该订单会从订单簿中永久移除。

只允许添加价格低于当前最优 SELL 报价的 BUY 订单（如果你想以更高的价格买入，则应直接接受最优 SELL 报价而不是添加新订单）。同理，也不能添加价格小于等于当前最优 BUY 报价的 SELL 订单。例如，如果已经有 "BUY $20$" 或 "BUY $25$" 的订单，则不能再添加 "SELL $20$" 的订单——此时应直接接受最优 BUY 报价。

你有一份损坏的订单簿日志（初始时订单簿为空）。每个操作有两种类型：

1. "ADD $p$" 表示以价格 $p$ 添加一个新订单，但方向未知。该订单不能与当前订单簿中尚未移除的订单矛盾。
2. "ACCEPT $p$" 表示以价格 $p$ 接受一个已存在的最优报价，但方向未知。

所有操作的方向信息都丢失了。日志中的信息并不总能完全确定这些方向。请你计算有多少种方式可以为所有 ADD 操作正确恢复方向，使得在任意时刻所有描述的条件都被满足。由于答案可能很大，请输出对 $10^9+7$ 取模的结果。如果无法正确恢复方向，则输出 $0$。

## 说明/提示

在第一个样例中，每个订单都可以是 BUY 或 SELL。

在第二个样例中，价格为 $1$ 的订单必须是 BUY，价格为 $3$ 的订单必须是 SELL。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
6
ADD 1
ACCEPT 1
ADD 2
ACCEPT 2
ADD 3
ACCEPT 3
```

### 输出

```
8
```

## 样例 #2

### 输入

```
4
ADD 1
ADD 2
ADD 3
ACCEPT 2
```

### 输出

```
2
```

## 样例 #3

### 输入

```
7
ADD 1
ADD 2
ADD 3
ADD 4
ADD 5
ACCEPT 3
ACCEPT 5
```

### 输出

```
0
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Order book 深入学习指南 💡

<introduction>
今天我们来一起分析“Order book”这道C++编程题。这道题需要我们处理一个订单簿的日志，恢复丢失的订单方向（BUY/SELL），并计算合法的恢复方式数目。本指南将帮助大家梳理核心思路，掌握关键技巧，并通过可视化动画直观理解算法流程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（侧重数据结构运用与条件逻辑处理）`

🗣️ **初步分析**：
解决“Order book”的关键在于维护两个动态集合（BUY和SELL）的边界，并跟踪“缓冲区”中的元素（既可能是BUY也可能是SELL）。简单来说，我们可以把订单簿想象成一个“夹心饼干”：中间是未确定方向的缓冲区，左右分别是已确定的BUY最高价（左边界）和SELL最低价（右边界）。每次操作（ADD/ACCEPT）会影响这个“夹心”的结构，而方案数的计算就藏在缓冲区的变化中。

- **题解思路**：所有优质题解均采用有序集合（如`set`）维护所有订单价格，用左右边界标记当前BUY和SELL的极值。ADD操作时，若价格在缓冲区内（大于左边界且小于右边界），则增加缓冲区元素数；ACCEPT操作时，若价格在缓冲区内，方案数翻倍（该价格可能是BUY或SELL的极值），并更新左右边界。
- **核心难点**：如何动态维护左右边界？如何判断ACCEPT操作是否合法？缓冲区元素对方案数的贡献如何计算？
- **可视化设计**：采用8位像素风格，用蓝色块表示BUY、红色块表示SELL、黄色块表示缓冲区。ADD时黄色块滑动进入缓冲区，ACCEPT时选中的黄色块闪烁（伴随“叮”音效），左右边界更新（蓝色右移或红色左移），最后剩余黄色块数显示在积分板。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、实现高效被选为优质参考：
</eval_intro>

**题解一：木易的题解**  
* **点评**：此题解思路清晰，通过维护`set`和左右边界，直观展示了缓冲区元素的动态变化。代码中初始插入极大极小值的细节（防止迭代器越界）非常关键，是处理边界条件的典范。ACCEPT操作时的条件判断（`x>left&&x<right`）直接对应方案数翻倍的逻辑，代码注释详细，适合新手学习。

**题解二：Hoks的题解**  
* **点评**：此题解巧妙将问题转化为“分割集合”，用`mx`和`mn`表示当前BUY和SELL的边界，通过`ss`变量跟踪缓冲区元素数。代码中`Fast_IO`的快速输入输出优化体现了竞赛编程的实用技巧，`ans=ans*2%mod`的处理简洁高效，是算法优化的亮点。

**题解三：MujinH的题解**  
* **点评**：此题解以“缓冲区”为核心，用`l`和`r`明确标记边界，代码结构工整（如`cin.tie(0)`加速输入），关键步骤（如`it--; l=*it`）的迭代器操作解释清晰。最后`ans*cnt%mod`的处理准确反映了剩余缓冲区元素的贡献，是逻辑严谨的典范。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，以下三个关键点需要特别注意：
</difficulty_intro>

1.  **关键点1：如何维护BUY和SELL的边界？**  
    * **分析**：初始时，BUY的最高价（左边界）设为极小值（如`-2e9-7`），SELL的最低价（右边界）设为极大值（如`2e9+7`）。每次ACCEPT操作后，删除的价格会被其前驱（新的左边界）和后继（新的右边界）替代。例如，删除价格`x`后，左边界更新为`x`的前驱（集合中比`x`小的最大元素），右边界更新为`x`的后继（比`x`大的最小元素）。  
    * 💡 **学习笔记**：使用`set`的`lower_bound`和迭代器操作（`++`/`--`）可以高效找到前驱和后继，这是维护边界的关键。

2.  **关键点2：ACCEPT操作的合法性判断与方案数计算**  
    * **分析**：若ACCEPT的价格不在当前左、右边界之间（即小于左边界或大于右边界），说明无法满足“SELL价格>BUY价格”的条件，直接返回0。若价格在边界之间（缓冲区），则该价格可能是BUY的最高价或SELL的最低价，因此方案数乘2（两种选择）。  
    * 💡 **学习笔记**：ACCEPT缓冲区元素时，方案数翻倍的逻辑是本题的核心数学模型。

3.  **关键点3：最后剩余缓冲区元素的贡献**  
    * **分析**：所有操作结束后，剩余的缓冲区元素（价格在最终左、右边界之间）可以自由分配为BUY或SELL，共有`cnt+1`种方式（`cnt`为缓冲区元素数，例如`cnt=2`时有`(0,2),(1,1),(2,0)`三种分配方式）。  
    * 💡 **学习笔记**：最终方案数需乘`cnt+1`，这是因为每个缓冲区元素的方向选择是独立的。

### ✨ 解题技巧总结
- **数据结构选择**：使用`set`维护所有价格，利用其有序性和快速查找（O(log n)）特性，高效处理前驱、后继查询。  
- **边界初始化**：插入极大极小值作为初始边界，避免迭代器越界（如`set.insert(-2e9-7)`和`set.insert(2e9+7)`）。  
- **变量跟踪**：用`cnt`跟踪最后一次ACCEPT后的ADD操作数（缓冲区元素数），用`ans`累积方案数（每次ACCEPT缓冲区元素时乘2）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，代码简洁高效，覆盖关键逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了木易、Hoks等题解的思路，使用`set`维护价格集合，跟踪左右边界，处理ADD和ACCEPT操作，计算方案数。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <set>
    using namespace std;
    using ll = long long;
    const int MOD = 1e9 + 7;
    const ll INF = 2e18;

    int main() {
        int n;
        cin >> n;
        set<ll> s;
        ll left = -INF, right = INF; // 初始左右边界
        s.insert(left);
        s.insert(right);
        ll ans = 1;
        ll cnt = 1; // 最后一次ACCEPT后的ADD操作数（缓冲区元素数）

        for (int i = 0; i < n; ++i) {
            string opt;
            ll p;
            cin >> opt >> p;
            if (opt == "ADD") {
                s.insert(p);
                if (p > left && p < right) {
                    cnt++; // 在缓冲区内，增加可能的分配方式
                }
            } else { // ACCEPT
                if (p <= left || p >= right) { // 不在边界内，非法
                    cout << 0 << endl;
                    return 0;
                }
                if (p > left && p < right) { // 在缓冲区内，方案数翻倍
                    ans = ans * 2 % MOD;
                }
                cnt = 1; // 重置缓冲区计数
                // 更新左右边界：p的前驱为新left，p的后继为新right
                auto it = s.find(p);
                --it; left = *it;
                ++it; ++it; right = *it;
                --it; s.erase(it); // 删除p
            }
        }
        ans = ans * cnt % MOD; // 剩余缓冲区元素的贡献
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先初始化`set`并插入极大极小值作为初始边界。对于每个操作：  
  - ADD时，若价格在缓冲区内（`p>left&&p<right`），则增加`cnt`（缓冲区元素数）；  
  - ACCEPT时，检查价格是否在边界内，若在缓冲区则方案数`ans`乘2，更新左右边界并删除该价格；  
  最后，剩余缓冲区元素的贡献为`cnt+1`（代码中`cnt`已累加，直接乘`cnt`）。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：木易的题解（核心片段）**  
* **亮点**：初始插入极大极小值的细节处理，防止迭代器越界。  
* **核心代码片段**：
    ```cpp
    int left=-2e9-7,right=2e9+7;
    sss.insert(left),sss.insert(right);
    // ...
    www=sss.find(x);
    www--;
    left=*(www);
    www++,www++;
    right=*(www);
    www--;
    sss.erase(www);
    ```
* **代码解读**：  
  初始插入`left`和`right`作为边界，避免集合为空时的迭代器错误。ACCEPT操作时，通过迭代器`--`和`++`找到`x`的前驱（新`left`）和后继（新`right`），并删除`x`。这一步是维护边界的关键，确保后续操作的合法性。  
* 💡 **学习笔记**：初始边界的设置是处理空集合的重要技巧，避免运行时错误。

**题解二：Hoks的题解（核心片段）**  
* **亮点**：使用`mx`和`mn`表示当前边界，代码简洁高效。  
* **核心代码片段**：
    ```cpp
    mn=*(++a.lower_bound(x));
    mx=*(--a.lower_bound(x));
    a.erase(x);
    ```
* **代码解读**：  
  `lower_bound(x)`找到第一个不小于`x`的元素，`++`后得到`x`的后继（新`mn`），`--`后得到`x`的前驱（新`mx`）。这一步利用`set`的有序性，快速定位边界。  
* 💡 **学习笔记**：`set::lower_bound`是处理有序集合的高效工具，熟练使用可简化代码。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解缓冲区和边界的变化，我们设计一个“像素订单簿”动画，用8位复古风格模拟操作过程：
</visualization_intro>

  * **动画演示主题**：`像素订单簿：BUY与SELL的边界之战`  
  * **核心演示内容**：展示ADD操作时缓冲区的扩展，ACCEPT操作时边界的更新及方案数的翻倍，最后剩余缓冲区元素的分配方式。  

  * **设计思路简述**：采用FC红白机风格（8色调色板，像素方块），用蓝色块表示BUY、红色块表示SELL、黄色块表示缓冲区。关键操作（如ACCEPT）伴随“叮”音效，边界更新时用箭头动画提示，增强操作记忆。

  * **动画帧步骤与交互关键点**：
    1. **初始化界面**：  
       屏幕分为三部分：顶部是订单列表（像素方块横向排列），中间是控制面板（开始/暂停、单步按钮），底部是方案数计数器。初始时，左右边界用蓝色（左）和红色（右）大像素块标记，缓冲区为空。
    2. **ADD操作**：  
       输入价格`p`时，生成一个黄色像素块，若`p`在缓冲区内（`left < p < right`），则黄色块滑动到订单列表中间；否则，根据`p`与边界的关系，变为蓝色（`p < left`）或红色（`p > right`）并固定到对应边界。
    3. **ACCEPT操作**：  
       选中价格`p`时，若`p`是蓝色或红色（边界外），屏幕闪烁红色并播放“错误”音效；若`p`是黄色（缓冲区内），黄色块闪烁3次（伴随“叮”音效），方案数计数器加“×2”，然后左/右边界分别向中间移动（蓝色右移或红色左移），`p`从列表中消失。
    4. **最终结果**：  
       所有操作完成后，剩余黄色块数显示在积分板（`cnt+1`），方案数计数器显示最终结果（`ans * cnt % MOD`），播放“胜利”音效。

  * **旁白提示**：  
    - ADD时：“这个价格在缓冲区内，方向还没确定哦！”  
    - ACCEPT缓冲区元素时：“看，方案数翻倍了！因为它可以是BUY或SELL的极值～”  
    - 最终结果时：“剩余的黄色块有`cnt`个，所以总共有`cnt+1`种分配方式！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到缓冲区的动态变化、边界的更新过程，以及方案数的计算逻辑，学习起来更轻松！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是维护动态边界并计算可能的分配方式，类似的思路可迁移到其他需要处理区间划分的问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 处理“区间划分”问题（如任务分配、资源调度），可维护左右边界，跟踪中间未确定的元素数。  
    - 使用有序集合（`set`/`map`）快速查找前驱后继，处理动态插入和删除。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1098 字符串的展开**  
        * 🗣️ **推荐理由**：需要维护展开的区间边界，类似本题的动态边界处理。  
    2.  **洛谷 P1102 A-B数对**  
        * 🗣️ **推荐理由**：利用`map`统计数对，练习有序集合的应用。  
    3.  **洛谷 P1113 杂务**  
        * 🗣️ **推荐理由**：处理任务依赖关系，需要动态维护任务的最早完成时间，锻炼区间划分思维。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中提到，调试时容易因未初始化边界导致迭代器越界。例如，初始时若不插入极大极小值，删除所有元素后`set`为空，`--it`会出错。
</insights_intro>

> **参考经验 (来自木易的题解)**：“插入极大极小值作为初始的left和right，防止删除所有元素后集合为空，导致迭代器操作错误。”  
> **点评**：这是处理空集合边界的关键技巧。在编程中，尤其是涉及动态集合的问题，初始边界的设置能避免许多运行时错误。大家在写代码时，一定要考虑“空集合”的特殊情况！

---

<conclusion>
本次关于“Order book”的分析就到这里。通过理解缓冲区和边界的动态变化，掌握`set`的使用技巧，以及方案数的计算逻辑，相信大家能轻松解决这类问题。记住，多动手模拟操作流程，是理解算法的关键！下次见～💪
</conclusion>

---
处理用时：528.82秒
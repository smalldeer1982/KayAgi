# 题目信息

# Folding Strip

## 题目描述

You have a strip of paper with a binary string $ s $ of length $ n $ . You can fold the paper in between any pair of adjacent digits.

A set of folds is considered valid if after the folds, all characters that are on top of or below each other match. Note that all folds are made at the same time, so the characters don't have to match in between folds.

For example, these are valid foldings of $ s = \mathtt{110110110011} $ and $ s = \mathtt{01110} $ :

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1965C/cdcd37b9d52400313db3672e3c8605e2ff8b16ce.png)The length of the folded strip is the length seen from above after all folds are made. So for the two above examples, after the folds shown above, the lengths would be $ 7 $ and $ 3 $ , respectively.

Notice that for the above folding of $ s = \mathtt{01110} $ , if we made either of the two folds on their own, that would not be a valid folding. However, because we don't check for validity until all folds are made, this folding is valid.

After performing a set of valid folds, what is the minimum length strip you can form?

## 说明/提示

For the first example case, one optimal folding is to fold the strip in the middle, which produces a strip of length 3.

The third and fourth example cases correspond to the images above. Note that the folding shown above for $ s = \mathtt{110110110011} $ is not of minimal length.

## 样例 #1

### 输入

```
6
6
101101
1
0
12
110110110011
5
01110
4
1111
2
01```

### 输出

```
3
1
3
3
1
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：Folding Strip 深入学习指南 💡

<introduction>
今天我们来一起分析“Folding Strip”这道C++编程题。这道题的核心是通过折叠操作让二进制字符串的重叠字符一致，并找到最小可能的折叠长度。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟与贪心策略的结合应用

🗣️ **初步分析**：
解决“Folding Strip”这道题，关键在于理解折叠操作的规律并通过模拟找到最优策略。简单来说，“模拟”就像我们手动折纸条——每一步都跟踪当前的状态（比如折叠方向、左右边界），而“贪心”则是每一步都选择能让最终长度尽可能小的操作（即遇到相邻相同字符就折叠）。

在本题中，核心观察是：所有合法折叠的最终状态一定是一个01交替的字符串（没有相邻相同字符），而要达到最短长度，最优策略是每遇到相邻相同的字符就折叠一次。这是因为每次折叠都能减少有效长度，且折叠后的状态不会破坏后续的合法性。

- **题解思路对比**：多数题解（如Creeper_l、369Pai等）均指出“遇到相邻相同字符就折叠”是最优策略，差异主要在代码实现的细节（如方向变量的维护方式），但核心逻辑一致。
- **核心算法流程**：从左到右遍历字符串，维护当前折叠方向（左或右）和左右边界。每遇到相邻相同字符时反转方向，否则按当前方向扩展边界。最终的最小长度是右边界与左边界的差加1。
- **可视化设计**：采用8位像素风格，用不同颜色的像素块表示字符（0为蓝色，1为红色），折叠时用箭头动画表示方向变化（左折为←，右折为→），边界扩展时用像素块滑动动画。关键步骤（如方向反转）伴随“叮”的音效，最终结果用闪烁的金色边框高亮。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解因逻辑清晰、实现简洁且具有启发性，被选为优质题解（评分≥4星）：
</eval_intro>

**题解一：作者Creeper_l**
* **点评**：此题解直接给出了核心结论（每遇到相邻相同字符就折叠），并通过维护方向、左右边界的方式高效计算结果。代码中变量`Fangxiang`（方向）、`L`（左边界）、`R`（右边界）命名清晰，逻辑简洁。其亮点在于通过方向反转模拟折叠操作，用一次遍历完成计算，时间复杂度O(n)，非常适合竞赛场景。

**题解二：作者369Pai**
* **点评**：此题解不仅给出结论，还详细证明了“最终状态必为01交替字符串”的充分必要性，逻辑严谨。代码中`l`、`r`、`j`、`k`变量分别表示左右边界、当前位置和方向，变量含义明确。其亮点在于对折叠合法性的证明，帮助学习者理解“为什么这样折叠是最优的”。

**题解三：作者Lame_Joke**
* **点评**：此题解用简洁的代码实现了核心逻辑，变量`bz`（方向）、`ans`（当前位置）的维护方式与其他题解一致，但代码更精简。其亮点在于通过`max`和`min`直接更新边界，减少了冗余操作，适合初学者学习如何用简单变量解决复杂问题。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何理解折叠操作的合法性条件？
    * **分析**：折叠合法性要求所有重叠位置的字符相同。优质题解指出，最终合法状态必为01交替字符串（无相邻相同字符），因为若存在相邻相同字符，还可进一步折叠。例如，字符串“11011”折叠后若剩余“101”，则满足条件。
    * 💡 **学习笔记**：合法折叠的最终状态一定是01交替的，这是判断是否还能继续折叠的关键。

2.  **关键点2**：如何确定最优折叠策略？
    * **分析**：最优策略是每遇到相邻相同字符就折叠。因为每次折叠都会减少有效长度（方向反转后，后续扩展的边界会更靠近中心），而折叠次数越多，最终长度越小。例如，字符串“101101”中，位置2-3（'0'和'1'不同，不折叠），位置3-4（'1'和'1'相同，折叠，方向反转）。
    * 💡 **学习笔记**：相邻相同字符是折叠的“机会点”，抓住每个机会点能保证长度最小。

3.  **关键点3**：如何高效模拟折叠过程？
    * **分析**：通过维护方向变量（左折为1，右折为-1）和当前位置，每次遇到相邻相同字符时反转方向，否则按当前方向扩展位置。同时记录左右边界，最终长度为右边界-左边界+1。例如，初始位置为0，方向为1；遇到相同字符时方向变为-1，后续位置计算为前位置+方向。
    * 💡 **学习笔记**：方向变量和边界维护是模拟的核心，用简单变量即可完成复杂过程的跟踪。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将折叠操作抽象为方向变化和位置扩展，避免直接模拟物理折叠的复杂过程。
- **变量命名**：用清晰的变量名（如`direction`、`left`、`right`）提高代码可读性。
- **边界处理**：通过`min`和`max`实时更新左右边界，确保最终长度计算准确。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先看一个综合优质题解的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Creeper_l和369Pai的思路，通过维护方向和边界高效计算最小长度，适合作为竞赛中的标准实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int T;
        cin >> T;
        while (T--) {
            int n;
            string s;
            cin >> n >> s;
            int left = 0, right = 0, pos = 0, dir = 1;
            for (int i = 1; i < n; ++i) {
                if (s[i] == s[i-1]) {
                    dir *= -1; // 遇到相同字符，反转方向
                } else {
                    pos += dir; // 不同字符，按当前方向扩展位置
                }
                left = min(left, pos);
                right = max(right, pos);
            }
            cout << right - left + 1 << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入，然后遍历字符串。`dir`表示当前折叠方向（初始为1，右折），`pos`表示当前扩展的位置。每遇到相邻相同字符时反转方向；否则按当前方向扩展位置。`left`和`right`记录遍历过程中位置的最小和最大值，最终长度为`right - left + 1`。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：作者Creeper_l**
* **亮点**：用`Fangxiang`变量表示方向，`L`和`R`维护左右边界，代码简洁高效。
* **核心代码片段**：
    ```cpp
    int L = 1e18, R = -1e18, pos = 0;
    int Fangxiang = 1;
    for(int i = 1; i <= n; i++) {
        if(a[i] == a[i - 1]) Fangxiang *= -1;
        else pos += Fangxiang;
        L = min(L, pos), R = max(R, pos);
    }
    ```
* **代码解读**：
    > `Fangxiang`初始为1（右折方向），遍历每个字符时，若当前字符与前一个相同（`a[i] == a[i-1]`），则反转方向（`Fangxiang *= -1`）；否则按当前方向扩展位置（`pos += Fangxiang`）。`L`和`R`分别记录遍历过程中位置的最小和最大值，最终长度为`R - L + 1`。这段代码的关键是通过方向反转模拟折叠，用一次遍历完成所有计算。
* 💡 **学习笔记**：方向变量是模拟折叠的核心，每次反转方向后，后续扩展的位置会向相反方向移动，从而缩小最终长度。

**题解二：作者369Pai**
* **亮点**：明确维护`l`、`r`、`j`（当前位置）、`k`（方向），逻辑清晰。
* **核心代码片段**：
    ```cpp
    int l = 1, r = 0;
    for(int i = 0, j = 0, k = 1; i < n; i++) {
        if(i && s[i] == s[i - 1]) k *= -1;
        else {
            j += k;
            l = min(l, j);
            r = max(r, j);
        }
    }
    ```
* **代码解读**：
    > `k`是方向变量（初始为1），`j`是当前位置。遍历字符串时，若当前字符与前一个相同（`s[i] == s[i-1]`），则反转方向（`k *= -1`）；否则按当前方向扩展位置（`j += k`）。`l`和`r`分别记录位置的最小和最大值，最终长度为`r - l + 1`。这段代码的关键是通过`j`的扩展模拟折叠后的有效位置，用`min`和`max`跟踪边界。
* 💡 **学习笔记**：用`j`表示当前位置，能直观反映折叠后的字符分布，是理解问题的关键。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解折叠过程，我们设计一个“像素折叠冒险”动画，用8位风格展示方向变化和边界扩展！
</visualization_intro>

  * **动画演示主题**：`像素折叠冒险——寻找最短纸条`

  * **核心演示内容**：展示字符串折叠时的方向变化（左折/右折）、位置扩展（当前位置`pos`的移动），以及最终左右边界的计算。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），用不同颜色的像素块表示0（蓝色）和1（红色），折叠时用箭头动画表示方向反转（左折为←，右折为→），边界扩展时用像素块滑动动画。关键操作（如方向反转）伴随“叮”的音效，最终结果用金色边框高亮，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕上方显示像素化的输入字符串（如`101101`），每个字符为16x16像素块，0为蓝色，1为红色。
          * 下方显示控制面板：单步/自动播放按钮、速度滑块（1-5倍速）、重置按钮。
          * 背景音乐：8位风格的轻快旋律（如《超级玛丽》主题变奏）。

    2.  **算法启动**：
          * 初始状态：方向箭头为→（右折，`dir=1`），当前位置`pos=0`，左右边界`left=0`，`right=0`。

    3.  **核心步骤演示**：
          * **遍历字符**：用白色箭头从左到右依次指向当前字符（如第2个字符`0`）。
          * **相同字符判断**：若当前字符与前一个相同（如第3个字符`1`和第4个字符`1`），方向箭头反转（→变为←，`dir=-1`），播放“叮”音效，箭头颜色变绿（表示方向反转）。
          * **位置扩展**：若字符不同（如第1个字符`1`和第2个字符`0`），当前位置`pos`按方向移动（`dir=1`时向右滑1格，`dir=-1`时向左滑1格），播放“唰”音效，`pos`值更新并显示在屏幕下方。
          * **边界更新**：每次位置扩展后，`left`和`right`用红色/蓝色边框标记当前最小/最大位置，数值实时更新。

    4.  **目标达成**：
          * 遍历结束后，屏幕中央显示最终长度`right - left + 1`，用金色字体闪烁，播放“胜利”音效（如《魂斗罗》通关音）。

    5.  **交互控制**：
          * 单步播放：点击“单步”按钮，逐字符演示；自动播放：选择速度后自动遍历，学习者可观察整体过程。
          * 重置按钮：回到初始状态，重新开始演示。

  * **旁白提示**：
      * （方向反转时）“看！这里两个字符相同，方向要反转啦～”
      * （位置扩展时）“现在字符不同，位置按当前方向移动，注意看`pos`的变化～”
      * （结束时）“最终长度就是右边界减左边界加1，你学会了吗？”

<visualization_conclusion>
通过这个像素动画，我们能直观看到折叠方向如何变化、位置如何扩展，以及最终长度是如何计算的。这种游戏化的演示方式，让抽象的算法变得生动易懂！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以尝试以下类似问题，巩固“模拟+贪心”的解题思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“方向反转+边界维护”思想，可用于处理字符串折叠、路径追踪等问题（如回文子串折叠、迷宫路径最短问题）。
      * 贪心选择“每一步最优”的策略，适用于需要逐步决策的问题（如区间调度、任务分配）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1113** - `杂务`
          * 🗣️ **推荐理由**：这道题需要按顺序处理任务，维护时间边界，与本题的“方向+边界”思想类似，适合巩固模拟能力。
    2.  **洛谷 P1035** - `级数求和`
          * 🗣️ **推荐理由**：此题需要逐步计算级数和，维护当前项的值，与本题的“逐步遍历+状态更新”逻辑相似。
    3.  **洛谷 P1047** - `校门外的树`
          * 🗣️ **推荐理由**：此题需要处理区间覆盖，维护未被覆盖的边界，与本题的“左右边界”计算思路一致。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题时的思考过程，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自作者WeWantToRun)**：“我在草稿纸上做这个题时发现翻转顺序不影响结果，但一开始没猜到结论。后来通过模拟折叠过程，发现每次折叠后字符串会趋向01交替，才确定最优策略。”
>
> **点评**：作者的经验提醒我们，遇到结论题时，手动模拟小例子（如样例输入）是发现规律的关键。通过观察折叠后的字符串变化，能快速找到最优策略。

---

<conclusion>
本次关于“Folding Strip”的C++解题分析就到这里。希望这份学习指南能帮助大家理解折叠操作的规律，掌握“模拟+贪心”的解题技巧。记住，多动手模拟、多总结规律，是提升算法能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：111.59秒
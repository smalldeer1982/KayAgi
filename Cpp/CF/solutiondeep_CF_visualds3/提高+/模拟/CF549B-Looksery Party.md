# 题目信息

# Looksery Party

## 题目描述

Looksery 公司由  $n$  名员工所组成，每个员工都有自己的电话和联系人列表。

 最近，公司打算举办一场大型派对，每位到场的员工，都会向他的联系人发送消息，来说明这场派对有多炫酷。由于每个人都想花尽量多的时间来享受派对时光，他们会不假思索地向所有联系人发送消息，甚至包括他们自己。

 Looksery 公司的开发者 Igor 和 Max 就每个人收到了多少条消息展开了争论. Igor 钦点了  $n$  个数字，其中第  $i$  个数字表示 Igor 认为第  $i$  个人收到的消息条数。如果 Igor 猜到了至少  $1$  个数字就算他胜利，否则 Max 胜利。

 作为 Max 的支持者，你需要根据员工的联系人列表，确定是否存在 Igor 会输的情况。具体来说，你需要确定哪些人应该参加派对，使得派对结束后，任意一个人收到的消息条数与 Igor 所给出的不同。

## 样例 #1

### 输入

```
3
101
010
001
0 1 2
```

### 输出

```
1
1 
```

## 样例 #2

### 输入

```
1
1
1
```

### 输出

```
0

```

## 样例 #3

### 输入

```
4
1111
0101
1110
0001
1 0 1 0
```

### 输出

```
4
1 2 3 4 
```

# AI分析结果

# 💡 Kay的C++算法解析：Looksery Party 深入学习指南 💡

<introduction>
  今天我们来一起分析「Looksery Party」这道C++编程题。这道题看似是关于“消息传递”的模拟问题，实则藏着一个**贪心策略**的核心逻辑——每次选择“必须参加”的人，逐步构造出满足条件的派对方案。本指南会帮你理清思路、看懂代码，并通过像素动画直观感受算法的执行过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy Algorithm）

🗣️ **初步分析**：
解决「Looksery Party」的关键，在于理解**“必须选谁”**——这正是贪心算法的核心：**每次做当前最“紧迫”的选择，不回头纠结过去的决策**。就像你收拾书包时，必须先装明天要交的作业，再装其他书；这道题里，“必须选的人”就是那些**如果不参加就会直接违反条件**的人。

### 题目核心逻辑再梳理
- 每个员工参加派对→给所有联系人发消息（包括自己）。
- 目标：让每个人收到的消息数≠Igor猜的`a_i`。
- 关键隐藏条件：**每个人的联系人列表都包含自己**！（划重点！）

### 贪心策略的应用
因为“联系人包含自己”，如果某个人`i`的`a_i=0`，**他必须参加派对**——否则他收到的消息数会是0（自己没参加，其他人也没选他的话），刚好等于`a_i`，违反条件！选他之后，他会给所有联系人发消息，相当于所有人的“目标值”要**减1**（因为实际收到的消息数多了1，要避开的目标也得跟着变）。我们不断重复这个过程：找`a_i=0`的人→选他→更新目标值，直到没有`a_i=0`的人，剩下的人都不参加，这样所有条件都满足！

### 可视化设计思路
我会用**8位像素风**（像FC红白机游戏）做动画：
- 每个员工是一个带数字的像素方块（显示当前`a_i`），联系人关系用虚线连接。
- 每次选`a_i=0`的人时，方块会**闪烁红色**，并播放“叮”的音效；选完后，他的联系人方块的数字会**减少1**（用向下的箭头动画表示）。
- 动画支持“单步执行”和“自动播放”，方便你慢慢看每一步的变化。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了2份优质题解，帮你快速掌握核心逻辑！
</eval_intro>

**题解一：来源：moye到碗里来（赞：3）**
* **点评**：这份题解的代码**完整且规范**，是贪心策略的“标准实现”！作者用`num`数组存当前的“目标值”，`ans`数组记录是否参加，`to`数组存联系人关系。思路上直接对应我们的贪心逻辑：找`num[i]=0`且没选过的人→选他→更新所有联系人的`num`值。最棒的是**边界处理**——作者加了`t>n`的判断（虽然题目保证有解，但这种严谨性值得学习）。代码中的变量名（比如`num`、`to`）含义明确，新手也能快速看懂！

**题解二：来源：Node_Edge（赞：6）**
* **点评**：这份题解的**思路提炼得非常简洁**！作者用`find`函数找`a_i=0`的人，然后循环处理选人和更新。核心代码只有几行，但精准抓住了贪心的本质——“找必须选的人→更新”。美中不足的是代码不完整（缺少输入输出），但作为“思路模板”非常棒，适合快速理解算法逻辑！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**理解“必须选的人”的逻辑**和**目标值的更新**。结合优质题解，我帮你梳理了3个核心难点和解决方法：
</difficulty_intro>

1. **关键点1：为什么`a_i=0`的人必须参加？**
    * **分析**：因为每个人的联系人都有自己！如果`i`不参加，他收到的消息数里“自己发的部分”是0。如果此时没有其他人选他，他的总消息数就是0，刚好等于`a_i=0`，违反条件。所以必须选他，让他的总消息数≥1（自己发的那条），自然≠0。
    * 💡 **学习笔记**：题目中的“隐藏条件”（联系人包含自己）是贪心的起点！

2. **关键点2：选完`i`后，为什么要把他的联系人的`a_j`减1？**
    * **分析**：选`i`后，`i`会给所有联系人`j`发消息→`j`的实际消息数增加1。我们的目标是让`j`的实际消息数≠原来的`a_j`，现在实际数多了1，所以要避开的目标也得减1（变成`a_j-1`），这样才能保持“实际数≠目标”的条件。
    * 💡 **学习笔记**：更新目标值是贪心的“后续影响处理”，不能漏掉！

3. **关键点3：为什么贪心策略一定能得到解？**
    * **分析**：最坏情况下，我们会选所有人参加——此时每个人的实际消息数是“联系人列表中1的数量”（因为所有人都发了消息），而我们的目标值已经被减到负数（不可能等于实际数），所以一定满足条件。题目不存在“无解”的情况！
    * 💡 **学习笔记**：贪心策略的正确性需要“证明”，这道题的“最坏情况”就是证明的关键！

### ✨ 解题技巧总结
- **技巧1：抓隐藏条件**：题目中的“联系人包含自己”是解题的突破口，一定要仔细读题！
- **技巧2：用数组记录状态**：用`ans`数组记录是否参加，`num`数组记录当前目标值，这样代码逻辑更清晰。
- **技巧3：循环处理直到终止**：贪心通常是“循环做同一件事直到条件不满足”，比如这道题循环找`a_i=0`的人，直到没有为止。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**完整的通用核心代码**（来自题解一的优化），帮你建立整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：这份代码整合了题解一的完整逻辑，变量名更直观，注释更详细，适合直接运行和学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    const int MAXN = 105; // 最大人数，根据题目调整
    int n;                // 员工数量
    int to[MAXN][MAXN];   // to[i][j]=1表示i的联系人有j
    int num[MAXN];        // 当前需要避开的目标值（初始为a_i）
    bool ans[MAXN];       // ans[i]=true表示i参加派对
    int cnt = 0;          // 参加的人数

    int main() {
        cin >> n;
        // 输入联系人列表：每个员工的联系人（n位0/1）
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                cin >> to[i][j]; // 用%1d读入单个字符会更准确，但cin也能处理
            }
        }
        // 输入Igor猜的a数组
        for (int i = 1; i <= n; ++i) {
            cin >> num[i];
        }

        bool flag; // 是否找到需要选的人
        int t = 0; // 防止死循环（题目保证有解，实际可以不用）
        while (true) {
            t++;
            flag = false;
            // 找num[i]=0且没选过的人
            for (int i = 1; i <= n; ++i) {
                if (num[i] == 0 && !ans[i]) {
                    ans[i] = true; // 选i参加
                    cnt++;
                    // 更新i的所有联系人的num值（减1）
                    for (int j = 1; j <= n; ++j) {
                        if (to[i][j] == 1) {
                            num[j]--;
                        }
                    }
                    flag = true;
                    break; // 只选一个，继续循环找下一个
                }
            }
            if (!flag) break; // 没有需要选的人，结束
            if (t > n) { cout << -1; return 0; } // 理论上不会执行
        }

        // 输出结果
        cout << cnt << endl;
        for (int i = 1; i <= n; ++i) {
            if (ans[i]) {
                cout << i << " ";
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 输入联系人列表和Igor的猜测；2. 贪心循环选“必须参加”的人；3. 输出结果。核心逻辑在`while`循环里：每次找`num[i]=0`且没选过的人，选他后更新所有联系人的`num`值，直到没有这样的人。


<code_intro_selected>
接下来看两个优质题解的核心片段，学习它们的亮点！
</code_intro_selected>

**题解一：来源：moye到碗里来**
* **亮点**：完整的输入处理+清晰的变量命名，适合新手模仿。
* **核心代码片段**：
    ```cpp
    // 找num[i]=0且没选过的人
    for (int i = 1; i <= n; ++i) {
        if (num[i] == 0 && ans[i] == 0) {
            ans[i] = 1;
            cnt ++;
            // 更新联系人的num值
            for(int j = 1; j <= n; ++j){
                if(to[i][j] == 1) num[j] --;
            }
            flag = 1;
            break;
        }
    }
    ```
* **代码解读**：
    > 这段代码是贪心的“核心循环体”。`num[i]==0`表示当前必须选i，`ans[i]==0`表示i还没选过。选i后，`ans[i]`设为1（标记参加），`cnt`加1（统计人数），然后遍历i的所有联系人j，如果`to[i][j]==1`（i的联系人有j），就把`num[j]`减1（更新目标值）。最后`flag=1`表示找到了人，`break`是为了每次只选一个人（贪心的“一步一步来”）。
* 💡 **学习笔记**：用`break`保证每次只处理一个人，避免一次处理多个导致逻辑混乱！

**题解二：来源：Node_Edge**
* **亮点**：用函数封装“找必须选的人”，代码更简洁。
* **核心代码片段**：
    ```cpp
    // 找num[i]=0的人，返回索引（没有返回0）
    int find() {
        for (int i=1; i<=n; i++) {
            if (!num[i]) return i;
        }
        return 0; 
    }

    while(1) {
        int flag = find();
        if (!flag) break;
        ans[++m] = flag; // 记录参加的人
        // 更新联系人的num值
        for(int i=1; i<=n; ++i) {
            if(s[flag][i] == '1') num[i]--;
        }
    }
    ```
* **代码解读**：
    > 作者把“找必须选的人”封装成`find`函数，这样`while`循环的逻辑更简洁：调用`find`找`num[i]=0`的人，如果找不到就break；否则记录这个人，然后更新他的联系人的`num`值。这种“函数封装”的技巧能让代码更模块化，读起来更轻松！
* 💡 **学习笔记**：把重复的逻辑封装成函数，是提升代码可读性的好方法！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”贪心的过程，我设计了一个**8位像素风的动画**——像玩《超级玛丽》一样，一步步看算法选人的过程！
</visualization_intro>

  * **动画演示主题**：像素员工“派对报名记”（FC红白机风格）
  * **核心演示内容**：展示贪心策略的每一步——找`num[i]=0`的人→选他→更新联系人的`num`值。
  * **设计思路简述**：用8位像素风是因为它“复古又亲切”，像小时候玩的游戏；音效和动画能强化你的记忆（比如选人的“叮”声，更新的“咻”声）；单步执行让你能慢慢琢磨每一步的逻辑！

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
       - 屏幕左侧是**员工网格**：每个员工是一个16x16的像素方块，上面显示`num[i]`（比如`num[1]=0`就显示“0”），方块颜色：未选是浅蓝色，已选是红色。
       - 屏幕右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，还有速度滑块（1x~5x）。
       - 背景播放**8位轻松BGM**（像《坦克大战》的背景音乐）。
    2. **算法启动**：
       - 初始状态：所有员工是浅蓝色，`num`值显示初始的`a_i`。
       - 点击“开始”，动画自动找第一个`num[i]=0`的人（比如员工1），他的方块会**闪烁红色**（3次），伴随“叮~”的音效。
    3. **选人的过程**：
       - 选完员工1后，他的方块变成**红色**（标记已选），然后他的所有联系人（比如员工1、2、3）的方块会**向下弹出一个小箭头**，并播放“咻”的音效——表示`num`值减1（比如员工1的`num`从0变-1，员工2的`num`从1变0）。
    4. **循环处理**：
       - 接下来找下一个`num[i]=0`的人（比如员工2），重复上面的过程：闪烁→变红→更新联系人的`num`值。
    5. **结束状态**：
       - 当没有`num[i]=0`的人时，所有已选的员工方块是红色，未选的是浅蓝色。屏幕弹出“派对方案完成！”的像素文字，伴随**胜利音效**（像《超级玛丽》通关的音乐）。
    6. **交互设计**：
       - **单步执行**：点击“单步”，动画走一步（找一个人→选他→更新），方便你仔细看每一步。
       - **速度滑块**：调整自动播放的速度（1x最慢，5x最快）。
       - **重置**：回到初始状态，重新演示。

  * **旁白提示**：
    - 选员工1时：“看！员工1的num是0，必须参加派对！”
    - 更新联系人时：“员工1参加了，他的联系人的num都要减1哦！”
    - 结束时：“所有必须选的人都选完啦，剩下的人不用参加~”

<visualization_conclusion>
通过这个动画，你能清楚看到**贪心是“一步一步选必须的人”**，而不是“一下子选所有人”。像素风格和音效让学习更有趣，也更容易记住核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法的应用非常广，只要问题能分解成“每次选最紧迫的选项”，都可以用贪心解决。比如：
</similar_problems_intro>

  * **通用思路迁移**：
    - 问题1：合并果子（每次选最小的两堆合并，总代价最小）→贪心选“当前最小的”。
    - 问题2：区间调度（选最多不重叠的区间）→贪心选“结束最早的”。
    - 问题3：零钱兑换（用最少的硬币凑钱）→贪心选“最大的硬币”（前提是硬币是标准的，比如1、5、10）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P1090** - 合并果子
       * 🗣️ **推荐理由**：经典贪心问题，帮你巩固“选当前最优”的思路。
    2. **洛谷 P1208** - 翻硬币
       * 🗣️ **推荐理由**：贪心+模拟，锻炼“处理后续影响”的能力（和本题的“更新num值”类似）。
    3. **洛谷 P2123** - 皇后游戏
       * 🗣️ **推荐理由**：较难的贪心问题，需要推导“排序规则”，提升你的贪心思维深度。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者们的经验很宝贵，我摘录了2条关键心得：
</insights_intro>

> **经验1（来自moye到碗里来）**：“每次找出收到信息为0的，必须去，由于题目保证有自己给自己发信息，所以去了之后这个点就一定满足了。”
> **点评**：作者抓住了“联系人包含自己”这个关键条件！如果没注意到这点，根本想不出“必须选num[i]=0的人”的逻辑。这提醒我们：**读题要仔细，特别是“隐藏条件”**！

> **经验2（来自Node_Edge）**：“最坏情况下，所有人都能变成0，这时n个人参加派对，仍然满足，故不存在-1的情况。”
> **点评**：作者证明了“贪心策略一定有解”，这是算法正确性的关键！学习算法不仅要会写代码，还要会**证明思路的正确性**。


<conclusion>
本次关于「Looksery Party」的分析就到这里！这道题的核心是**贪心策略**——每次选“必须参加”的人，逐步构造解。记住：贪心的关键是“找当前最紧迫的选择”，而题目中的“隐藏条件”（联系人包含自己）是打开思路的钥匙！

编程的进步在于“多思考、多练习”——下次遇到贪心问题时，不妨先想想：“当前最必须做的事是什么？” 加油！💪
</conclusion>

---
处理用时：109.69秒
# 题目信息

# Leha and another game about graph

## 题目描述

Leha plays a computer game, where is on each level is given a connected graph with $ n $ vertices and $ m $ edges. Graph can contain multiple edges, but can not contain self loops. Each vertex has an integer $ d_{i} $ , which can be equal to $ 0 $ , $ 1 $ or $ -1 $ . To pass the level, he needs to find a «good» subset of edges of the graph or say, that it doesn't exist. Subset is called «good», if by by leaving only edges from this subset in the original graph, we obtain the following: for every vertex i, $ d_{i} $ = - 1 or it's degree modulo 2 is equal to $ d_{i} $ . Leha wants to pass the game as soon as possible and ask you to help him. In case of multiple correct answers, print any of them.

## 说明/提示

In the first sample we have single vertex without edges. It's degree is 0 and we can not get 1.

## 样例 #1

### 输入

```
1 0
1
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
4 5
0 0 0 -1
1 2
2 3
3 4
1 4
2 4
```

### 输出

```
0
```

## 样例 #3

### 输入

```
2 1
1 1
1 2
```

### 输出

```
1
1
```

## 样例 #4

### 输入

```
3 3
0 -1 1
1 2
2 3
1 3
```

### 输出

```
1
2
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Leha and another game about graph 深入学习指南 💡

<introduction>
今天我们来一起分析“Leha and another game about graph”这道C++编程题。这道题需要我们找到一个满足特定度数奇偶性的边子集，或判断其不存在。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（生成树构造+DFS遍历）`

🗣️ **初步分析**：
解决这道题的关键在于利用图的连通性构造生成树，并通过DFS遍历树结构来动态调整边的选择，以满足各节点的度数奇偶性要求。简单来说，生成树就像图的“骨架”，能帮我们将复杂的图结构简化为树结构，而DFS遍历则像“自底向上的检查员”，逐个确认每个子树的度数是否符合要求。

在本题中，图论的核心应用体现在：
- **生成树构造**：利用图的连通性，任选一棵生成树（如DFS生成树），将问题限制在树结构上，避免处理环的复杂性。
- **DFS遍历决策**：从叶子节点开始，逐层向上判断是否需要选择当前节点与父节点的边，以满足当前节点的度数要求。若当前节点是-1（无度数限制），则灵活调整，确保总度数为偶数。

核心难点在于：如何通过生成树的DFS遍历，动态调整边的选择，同时处理-1节点的灵活性。优质题解普遍采用生成树+DFS的策略，通过递归回溯时的状态传递（如当前节点是否需要调整度数），高效解决问题。

可视化设计思路：采用8位像素风格，用不同颜色标记节点（如红色表示度数需为奇数，蓝色表示偶数，黄色表示-1），边用白色像素线表示。DFS遍历时，用绿色箭头标记当前处理的边，选中的边变为红色并伴随“叮”的音效；处理-1节点时，节点颜色闪烁，提示其灵活性。控制面板支持单步执行、自动播放（速度可调），同步显示当前处理的代码行。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者doge233（赞：9）**
* **点评**：此题解思路清晰，代码规范。通过DFS生成树，利用递归回溯处理每个节点的度数需求，变量命名直观（如`vis`标记访问、`ans`存储结果边）。亮点在于对-1节点的处理（`if(d[x]==-1) res=0`）和总度数奇偶性的快速判断（`ok^=d[i]`），代码简洁高效，适合竞赛参考。

**题解二：作者Zero_Legend（赞：6）**
* **点评**：此题解逻辑推导详细，明确解释了构造方法的正确性（如根节点必满足条件的证明）。代码结构工整（`dfs`函数返回当前节点是否满足限制），变量名含义明确（`root`标记-1节点、`sum`统计总度数）。亮点在于对生成树构造的简化（直接DFS建树），降低了实现复杂度。

**题解三：作者TMLY114514（赞：2）**
* **点评**：此题解包含详细的IO优化，代码兼容性强。核心逻辑与其他优质题解一致，但通过`vector`存储边和结果，代码更符合现代C++风格。亮点在于对递归过程的清晰注释（`传回这个点的子树需要连多少边`），适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何处理-1节点的灵活性？**
    * **分析**：-1节点的度数无限制，可视为“调节器”。当总度数为奇数时，选择一个-1节点将其度数设为1（调整奇偶性）；否则设为0。优质题解中，通过`be=-1`标记-1节点，并在DFS时忽略其度数限制（`if(d[x]==-1) res=0`），确保其他节点的度数需求优先满足。
    * 💡 **学习笔记**：-1节点是问题的“弹性点”，利用其无限制特性调整总度数奇偶性是关键。

2.  **关键点2：如何通过生成树构造边集？**
    * **分析**：生成树是图的“骨架”，避免了环的干扰。通过DFS遍历生成树，自底向上判断是否选择当前边：若子节点需要调整度数（`dfs(v)`返回true），则选择当前边（`ans[++tot]=(i+1)/2`），并翻转当前节点的度数状态（`res^=1`）。
    * 💡 **学习笔记**：生成树简化了问题，DFS遍历确保子树优先满足条件，父节点仅需处理剩余需求。

3.  **关键点3：如何确保总度数为偶数？**
    * **分析**：无向图中，每条边贡献2度，总度数必为偶数。若没有-1节点且总度数为奇数（`ok=1`），则无解。优质题解通过`ok^=d[i]`快速统计总度数奇偶性，若`be==-1&&ok`则直接输出-1。
    * 💡 **学习笔记**：总度数奇偶性是问题的“硬约束”，必须优先检查。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题简化**：利用生成树将图问题转化为树问题，避免环的干扰。
- **自底向上决策**：DFS遍历生成树，子树优先满足条件，父节点仅处理剩余需求。
- **灵活处理-1节点**：将-1节点作为“调节器”，调整总度数奇偶性，确保问题有解。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了doge233和Zero_Legend的题解思路，保留了关键逻辑并优化了可读性，适合作为竞赛模板。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 3e5 + 10;
    int n, m, cnt;
    int d[N], h[N];
    int ans[N << 1], tot;
    bool vis[N];
    struct Edge {
        int to, next;
    } e[N << 1];

    inline void add(int from, int to) {
        e[++cnt] = {to, h[from]};
        h[from] = cnt;
    }

    bool dfs(int x) {
        vis[x] = 1;
        bool res = d[x];
        for (int i = h[x]; i; i = e[i].next) {
            int v = e[i].to;
            if (vis[v]) continue;
            if (dfs(v)) {
                ans[++tot] = (i + 1) / 2; // 边编号从1开始
                res ^= 1;
            }
        }
        if (d[x] == -1) res = 0; // -1节点无度数限制
        return res;
    }

    int main() {
        int be = -1, ok = 0;
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &d[i]);
            if (d[i] == -1) be = i;
            else ok ^= d[i]; // 统计总度数奇偶性
        }
        for (int i = 1, u, v; i <= m; ++i) {
            scanf("%d%d", &u, &v);
            add(u, v); add(v, u); // 无向图，双向加边
        }
        if (be == -1 && ok) { // 无-1节点且总度数奇数，无解
            puts("-1");
            return 0;
        }
        if (be == -1) be = 1; // 无-1节点时，选1号节点为根
        dfs(be);
        printf("%d\n", tot);
        sort(ans + 1, ans + tot + 1); // 按输入顺序排序
        for (int i = 1; i <= tot; ++i)
            printf("%d\n", ans[i]);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入，统计-1节点和总度数奇偶性。通过邻接表存储图结构，构造DFS生成树。`dfs`函数递归处理每个节点，若子节点需要调整度数（返回true），则选择当前边并翻转当前节点的度数状态。-1节点无度数限制（`res=0`）。最终输出选中的边。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者doge233**
* **亮点**：代码简洁高效，利用位运算（`res^=1`）快速翻转度数状态，`ans`数组直接存储边编号，避免复杂操作。
* **核心代码片段**：
    ```cpp
    bool dfs(int x) {
        vis[x] = 1;
        bool res = d[x];
        for (int i = h[x]; i; i = e[i].next) {
            int v = e[i].to;
            if (vis[v]) continue;
            if (dfs(v))
                ans[++tot] = (i + 1) / 2, res ^= 1;
        }
        if (d[x] == -1) res = 0;
        return res;
    }
    ```
* **代码解读**：
    > `dfs`函数返回当前节点是否需要调整度数。递归处理子节点，若子节点需要调整（`dfs(v)`返回true），则将当前边加入结果（`ans[++tot]=(i+1)/2`），并翻转当前节点的度数状态（`res^=1`）。-1节点直接忽略度数限制（`res=0`）。这一逻辑确保子树优先满足条件，父节点仅处理剩余需求。
* 💡 **学习笔记**：递归回溯时的状态传递是核心，通过`res`变量传递当前节点的度数需求。

**题解二：作者Zero_Legend**
* **亮点**：明确解释了构造方法的正确性（根节点必满足条件），代码中`root`变量标记-1节点，逻辑清晰。
* **核心代码片段**：
    ```cpp
    int dfs(int now) {
        int flag = d[now];
        vis[now] = true;
        for (int i = head[now]; i; i = t[i].nex) {
            int y = t[i].to;
            if (vis[y]) continue;
            if (dfs(y)) {
                ans[++cnt] = (i + 1) / 2;
                flag = (1 - flag);
            }
        }
        if (d[now] == -1) flag = 0;
        return flag;
    }
    ```
* **代码解读**：
    > `dfs`函数返回当前节点的度数需求（`flag`）。处理子节点后，若子节点需要调整（`dfs(y)`返回true），则选择当前边（`ans[++cnt]=(i+1)/2`），并翻转当前节点的需求（`flag=1-flag`）。-1节点重置需求（`flag=0`），确保不影响父节点判断。
* 💡 **学习笔记**：`flag`变量直观表示当前节点的度数需求，递归传递时自然处理子树影响。

**题解三：作者TMLY114514**
* **亮点**：包含IO优化，代码兼容性强，`vector`存储边和结果，符合现代C++风格。
* **核心代码片段**：
    ```cpp
    inline int dfs(int u) {
        int res = d[u];
        vis[u] = 1;
        for (auto i : e[u]) {
            int v = i.first;
            if (vis[v]) continue;
            if (dfs(v)) res ^= 1, ans.push_back(i.second);
        }
        if (!~d[u]) res = 0;
        return res;
    }
    ```
* **代码解读**：
    > 使用`vector`存储邻接表（`e[u]`），每个元素包含邻接点和边编号（`i.second`）。递归处理子节点，若子节点需要调整（`dfs(v)`返回true），则将边加入结果（`ans.push_back(i.second)`）并翻转当前节点需求（`res^=1`）。`!~d[u]`等价于`d[u]==-1`，重置需求为0。
* 💡 **学习笔记**：`vector`的使用提高了代码的灵活性，适合处理大规模数据。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解生成树构造和DFS遍历的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素森林的度数调整之旅`（结合FC红白机风格）

  * **核心演示内容**：展示生成树的构造、DFS遍历过程中边的选择，以及-1节点的灵活调整。例如，从根节点开始，绿色箭头标记当前处理的边，选中的边变为红色并伴随“叮”声；-1节点用黄色闪烁表示其无限制特性。

  * **设计思路简述**：采用8位像素风（16色调色板）营造复古氛围，节点用圆形像素块表示（红：需奇数度，蓝：需偶数度，黄：-1），边用白色像素线连接。音效（如“叮”提示选边，“叮咚”提示完成）强化操作记忆；单步/自动播放功能允许学习者控制节奏，同步显示代码高亮，帮助理解逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧为像素网格（节点用圆形块，边用白色线），右侧为控制面板（开始/暂停、单步、速度滑块）和代码高亮区。
          * 播放8位风格BGM（如《超级玛丽》主题变奏），节点按输入数据着色（红/蓝/黄）。

    2.  **生成树构造**：
          * 根节点（黄色或默认）闪烁，绿色箭头从根出发，逐步连接子节点，形成生成树（非树边淡化）。

    3.  **DFS遍历决策**：
          * 绿色箭头进入子节点（递归调用），子节点处理完成后返回结果（如红色表示需要调整）。
          * 若子节点需要调整，当前边变为红色，播放“叮”声，父节点颜色翻转（红→蓝或蓝→红）。
          * -1节点处理时，节点黄色闪烁，父节点颜色不变。

    4.  **结果展示**：
          * 所有节点满足条件时，播放“叮咚”胜利音效，红色边高亮；若无解，播放“滴滴”提示音，根节点红色闪烁。

  * **旁白提示**：
      * （进入子节点时）“现在处理子节点v，它的度数需求是d[v]，需要检查是否满足...”
      * （选边时）“子节点v需要调整，选择当前边，父节点的度数需求翻转！”
      * （处理-1节点时）“这是-1节点，度数无限制，无需调整父节点！”

<visualization_conclusion>
通过这样一个融合像素艺术和复古游戏元素的动画，我们不仅能清晰看到生成树构造和DFS遍历的过程，还能在轻松的氛围中理解度数调整的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考图论构造类问题的通用思路，例如生成树应用、度数奇偶性调整等。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 生成树构造：适用于需要简化图结构的问题（如最小生成树、连通性问题）。
      * 自底向上决策：适用于树/图的递归处理（如树形DP、路径统计）。
      * 度数奇偶性调整：适用于无向图中需要满足度数条件的问题（如欧拉回路、匹配问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1197 星球大战** - `并查集+逆向处理`
          * 🗣️ **推荐理由**：练习图的连通性处理，理解生成树在动态图中的应用。
    2.  **洛谷 P3366 最小生成树** - `Kruskal算法`
          * 🗣️ **推荐理由**：巩固生成树构造，学习如何选择最优边集。
    3.  **洛谷 P5318 【深基18.例3】查找文献** - `DFS/BFS遍历`
          * 🗣️ **推荐理由**：练习图的遍历，理解不同遍历方式的差异。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如处理-1节点时的初始状态设置，或生成树构造时的边编号错误。这些经验对避免常见错误很有帮助：
</insights_intro>

> **参考经验 (来自doge233题解)**：“在调试时，发现-1节点的处理容易出错，需确保递归返回时重置其度数需求（`if(d[x]==-1) res=0`），否则可能导致父节点错误调整。”
>
> **点评**：这位作者的经验提醒我们，-1节点的无限制特性需要显式处理，否则可能影响父节点的度数判断。在编写代码时，应特别注意这类“特殊节点”的边界条件，通过测试用例验证其正确性。

-----

<conclusion>
本次关于“Leha and another game about graph”的C++解题分析就到这里。希望这份学习指南能帮助大家理解图论构造的核心思想，掌握生成树+DFS的解题技巧。记住，多动手编写代码、调试测试，是提升算法能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：137.53秒
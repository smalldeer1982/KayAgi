# 题目信息

# Divisibility by 25

## 题目描述

You are given an integer $ n $ from $ 1 $ to $ 10^{18} $ without leading zeroes.

In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words, after each move the number you have cannot contain any leading zeroes.

What is the minimum number of moves you have to make to obtain a number that is divisible by $ 25 $ ? Print -1 if it is impossible to obtain a number that is divisible by $ 25 $ .

## 说明/提示

In the first example one of the possible sequences of moves is 5071 $ \rightarrow $ 5701 $ \rightarrow $ 7501 $ \rightarrow $ 7510 $ \rightarrow $ 7150.

## 样例 #1

### 输入

```
5071
```

### 输出

```
4
```

## 样例 #2

### 输入

```
705
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1241367
```

### 输出

```
-1
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Divisibility by 25 深入学习指南 💡

<introduction>
今天我们来一起分析“Divisibility by 25”这道C++编程题。这道题需要通过交换相邻数字（不产生前导零），找到使数字能被25整除的最少交换次数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与字符串处理`

🗣️ **初步分析**：
解决这道题的关键在于利用数论性质：能被25整除的数末两位只能是`00`、`25`、`50`或`75`。我们需要枚举这四种情况，计算每种情况所需的最小交换次数，最终取最小值。

- **题解思路**：主流题解通过枚举四种目标后缀（`00`、`25`、`50`、`75`），分别找到原数字中对应两个字符的位置（从右往左找，确保尽可能减少交换次数），计算将它们移动到末尾所需的交换次数，并处理前导零问题。例如，对于`25`后缀，需找到最右的`5`和次右的`2`，计算交换步数。
- **核心难点**：
  1. 如何正确定位两个目标字符的位置（避免遗漏或顺序错误）。
  2. 计算交换次数时需考虑字符位置的顺序（若`a`在`b`右边，需额外调整）。
  3. 处理前导零（确保剩余字符无前置零，需统计前导零的数量并加到总步数）。
- **可视化设计**：采用8位像素风格动画，展示数字字符串的每个字符为像素方块。关键步骤高亮目标字符（如`5`和`2`），用箭头模拟交换过程，动态显示交换次数。音效设计：每次交换时播放“滴答”声，找到可行解时播放“叮”的成功音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性和算法有效性的评估，筛选出以下优质题解：
</eval_intro>

**题解一：作者CGDGAD（赞：7）**
* **点评**：此题解思路清晰，直接针对四种目标后缀设计函数`f(a,b)`，通过从右往左查找目标字符位置，计算交换次数并处理前导零。代码结构简洁，变量命名明确（如`p1`、`p2`分别表示目标字符的位置），边界条件处理严谨（如未找到目标字符时返回极大值）。实践价值高，可直接用于竞赛场景，是典型的“枚举+字符串处理”解法。

**题解二：作者Pecco（赞：2）**
* **点评**：此题解同样枚举四种后缀，函数`run(a,b)`通过反向查找目标字符位置，考虑了字符顺序颠倒时的额外步数（`lasta > lastb`时加1），并巧妙处理前导零（统计前导零数量加到总步数）。代码逻辑严谨，虽解释较少但实现高效，适合理解交换次数的计算细节。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下几个关键点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1：准确定位目标字符的位置**
    * **分析**：为了最小化交换次数，应从右往左查找目标字符。例如，对于`25`后缀，先找最右的`5`（`p1`），再在剩余字符中找最右的`2`（`p2`）。若未找到则该情况不可行。
    * 💡 **学习笔记**：反向查找能确保目标字符尽可能靠右，减少交换次数。

2.  **关键点2：计算交换次数时的顺序问题**
    * **分析**：若`a`（如`2`）在`b`（如`5`）的右边（即`p2 > p1`），则交换`a`和`b`的顺序会额外需要1次交换（因为原本`a`在`b`左边，现在需要调整）。
    * 💡 **学习笔记**：顺序颠倒时需额外加1步，这是容易忽略的细节。

3.  **关键点3：处理前导零**
    * **分析**：将目标字符移到末尾后，剩余字符可能有前导零。需统计剩余字符中前导零的数量（即连续`0`的个数），并将其加到总步数（因为需要将第一个非零字符移到最前面，这需要交换前导零的数量次）。
    * 💡 **学习笔记**：前导零的处理是保证结果合法性的关键，需单独计算其贡献。

### ✨ 解题技巧总结
- **枚举目标后缀**：直接枚举四种可能的末两位（`00`、`25`、`50`、`75`），覆盖所有能被25整除的情况。
- **反向查找字符**：从右往左找目标字符，确保交换次数最少。
- **前导零统计**：剩余字符的前导零数量需加到总步数，避免结果出现前导零。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，清晰展示枚举四种后缀、计算交换次数的过程。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了CGDGAD题解的思路，通过函数`f(a,b)`计算将后缀变为`ab`的最小步数，最终取四种情况的最小值。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    #include <algorithm>
    using namespace std;

    string s;

    int f(char a, char b) {
        string x = s;
        int len = x.size();
        // 找最右边的b
        int p1 = x.rfind(b);
        if (p1 == string::npos) return 1e9; // 未找到b，不可行
        x.erase(p1, 1); // 删除b，剩下的字符找a
        int p2 = x.rfind(a);
        if (p2 == string::npos) return 1e9; // 未找到a，不可行
        x.erase(p2, 1);
        // 统计前导零数量
        int leading_zero = 0;
        while (leading_zero < x.size() && x[leading_zero] == '0') 
            leading_zero++;
        // 总步数 = 前导零数 + (将b移到末尾的步数) + (将a移到倒数第二的步数)
        return leading_zero + (len - 1 - p1) + (len - 2 - p2);
    }

    int main() {
        cin >> s;
        int ans = min({f('0', '0'), f('2', '5'), f('5', '0'), f('7', '5')});
        cout << (ans >= 1e9 ? -1 : ans) << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先读取输入字符串`s`，定义函数`f(a,b)`计算将后缀变为`ab`的最小步数。`f`函数中，先找最右的`b`（`p1`），删除后找最右的`a`（`p2`），统计剩余字符的前导零数量，最后计算总步数。主函数中取四种情况的最小值，输出结果。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者CGDGAD**
* **亮点**：函数`f(a,b)`设计简洁，通过反向查找和删除字符的方式，清晰计算交换次数，前导零处理逻辑明确。
* **核心代码片段**：
    ```cpp
    int f(char a,char b) {
        std::string x = s; 
        int len = x.size();
        int p1 = x.rfind(b);
        if (p1 == -1) return 99999999;
        x.erase(p1, 1);
        int p2 = x.rfind(a);
        if (p2 == -1) return 99999999;
        x.erase(p2, 1);
        int sum = 0;
        while (x[sum] == '0') sum += 1;
        return sum + (len - 1 - p1) + (len - 2 - p2);
    }
    ```
* **代码解读**：
  - `x.rfind(b)`从右往左找`b`的位置`p1`，若不存在返回极大值。
  - 删除`b`后，`x.rfind(a)`找`a`的位置`p2`，若不存在返回极大值。
  - `sum`统计剩余字符的前导零数量（需交换这些零到后面）。
  - 总步数为前导零数 + 将`b`移到末尾的步数（`len-1-p1`） + 将`a`移到倒数第二的步数（`len-2-p2`）。
* 💡 **学习笔记**：反向查找和删除操作是定位目标字符的关键，前导零的统计确保结果无前置零。

**题解二：作者Pecco**
* **亮点**：考虑字符顺序颠倒的情况（`lasta > lastb`时加1），前导零处理逻辑更细致。
* **核心代码片段**：
    ```cpp
    int run(int a, int b) {
        int lasta = -1, lastb = -1;
        for (int i = m - 1; i >= 0; --i) // 找最右的b
            if (D[i] == b) { lastb = i; break; }
        for (int i = m - 1; i >= 0; --i) // 找最右的a（非b的位置）
            if (D[i] == a && i != lastb) { lasta = i; break; }
        if (lasta == -1 || lastb == -1) return INT_MAX;
        int extra = 0;
        for (int i = 0; i < m && (D[i] == 0 || i == lasta || i == lastb); i++)
            extra += (i != lasta && i != lastb); // 统计前导零数
        return (m - lasta - 2) + (m - lastb - 1) + extra + (lasta > lastb);
    }
    ```
* **代码解读**：
  - `lasta`和`lastb`分别存储`a`和`b`的最右位置（`b`优先）。
  - `extra`统计前导零数量（排除`a`和`b`的位置）。
  - 总步数包含顺序颠倒的额外步数（`lasta > lastb`时加1）。
* 💡 **学习笔记**：顺序颠倒的额外步数容易遗漏，需特别注意。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解如何找到目标后缀并计算交换次数，我们设计一个“像素数字探险”动画，用8位复古风格展示算法过程。
</visualization_intro>

  * **动画演示主题**：`像素数字探险——寻找25的倍数`
  * **核心演示内容**：展示数字字符串的每个字符为像素方块（如`5071`显示为四个彩色方块），模拟寻找`00`、`25`、`50`、`75`后缀的过程，高亮目标字符，动态计算交换次数。
  * **设计思路简述**：8位像素风格营造轻松氛围，关键步骤高亮（如`5`和`0`变为红色），交换时用箭头动画模拟相邻交换，音效强化操作记忆（交换时“滴答”，成功时“叮”）。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕上方显示像素数字串（如`5071`），每个数字为16x16像素方块，颜色不同（如`5`橙色，`0`白色，`7`绿色，`1`蓝色）。
        - 控制面板包含“开始”“单步”“重置”按钮和速度滑块（1-5倍速）。

    2.  **枚举目标后缀**：
        - 顶部文字提示当前枚举的后缀（如“检查后缀25”），数字串下方显示目标后缀`25`。

    3.  **反向查找目标字符**：
        - 从右往左扫描数字串，找到`5`（橙色方块）时，用黄色边框高亮并播放“叮”声，记录位置`p1`（如`5071`中的`5`在位置0）。
        - 删除`5`后，剩余数字串变为`071`，继续从右往左找`2`（未找到则显示“不可行”）。

    4.  **计算交换次数**：
        - 用箭头动画模拟`5`移到末尾的过程（`5071`→`5701`→`7501`→`7510`→`7150`），每交换一次播放“滴答”声，步数显示增加。
        - 统计前导零（如剩余数字`71`无零，步数为4）。

    5.  **结果对比**：
        - 依次演示四种后缀的计算过程，最终显示最小步数（如`5071`的最小步数为4）。

  * **旁白提示**：
    - “现在我们要找后缀25，先找最右边的5！”
    - “找到5了，位置是0，现在需要把它移到最后一位，需要3步。”
    - “接下来找2，没找到，所以25后缀不可行。”

<visualization_conclusion>
通过这样的动画，我们能清晰看到如何定位目标字符、计算交换次数，以及前导零的处理过程，轻松理解算法核心。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下拓展练习，巩固枚举和字符串处理的技巧。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 本题的枚举目标后缀思路可迁移到“被4、125整除”的问题（末两位/三位需满足条件）。
    - 字符串反向查找和交换次数计算的技巧，适用于“通过交换相邻字符构造特定字符串”的问题（如构造回文串）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1106** - `删数问题`
        * 🗣️ **推荐理由**：练习字符串处理和贪心选择，与本题的交换次数计算有相似的字符操作逻辑。
    2.  **洛谷 P1618** - `三连击（升级版）`
        * 🗣️ **推荐理由**：巩固枚举技巧，需枚举多种组合并验证条件，与本题枚举四种后缀的思路类似。
    3.  **洛谷 P1055** - `ISBN号码`
        * 🗣️ **推荐理由**：练习字符串处理和校验规则，与本题的字符位置处理有共通之处。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“Divisibility by 25”的C++解题分析就到这里。希望这份指南能帮助大家掌握枚举目标后缀、处理前导零等关键技巧。记住，多动手模拟交换过程，多测试边界条件，是解决此类问题的关键。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：123.32秒
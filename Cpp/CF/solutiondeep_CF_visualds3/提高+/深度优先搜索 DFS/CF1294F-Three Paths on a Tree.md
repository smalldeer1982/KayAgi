# 题目信息

# Three Paths on a Tree

## 题目描述

You are given an unweighted tree with $ n $ vertices. Recall that a tree is a connected undirected graph without cycles.

Your task is to choose three distinct vertices $ a, b, c $ on this tree such that the number of edges which belong to at least one of the simple paths between $ a $ and $ b $ , $ b $ and $ c $ , or $ a $ and $ c $ is the maximum possible. See the notes section for a better understanding.

The simple path is the path that visits each vertex at most once.

## 说明/提示

The picture corresponding to the first example (and another one correct answer):

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1294F/77ac761e87577c88357c329d0c2cba3e83446e14.png)

If you choose vertices $ 1, 5, 6 $ then the path between $ 1 $ and $ 5 $ consists of edges $ (1, 2), (2, 3), (3, 4), (4, 5) $ , the path between $ 1 $ and $ 6 $ consists of edges $ (1, 2), (2, 3), (3, 4), (4, 6) $ and the path between $ 5 $ and $ 6 $ consists of edges $ (4, 5), (4, 6) $ . The union of these paths is $ (1, 2), (2, 3), (3, 4), (4, 5), (4, 6) $ so the answer is $ 5 $ . It can be shown that there is no better answer.

## 样例 #1

### 输入

```
8
1 2
2 3
3 4
4 5
4 6
3 7
3 8```

### 输出

```
5
1 8 6```

# AI分析结果

# 💡 Kay的C++算法解析：Three Paths on a Tree 深入学习指南 💡

<introduction>
今天我们来一起分析经典树论问题——**Three Paths on a Tree**（树上的三条路径）。这道题需要我们在树上选三个点，让它们两两路径的边并集最长。听起来有点复杂？别担心，我们会用“主链+最长分支”的比喻帮你理解核心思路，还会用像素动画展示算法流程，保证你学懂！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`树的直径 + 最远点搜索`  
（属于「图论-树结构」分类，核心技巧是**利用树的直径最大化路径并**）

🗣️ **初步分析**：
解决这道题的关键，在于理解一个重要结论——**选的三个点中，有两个一定是树的直径的端点**。什么是树的直径？它就像树的“主链”，是树上最长的一条路径（比如样例中的1→2→3→4→5就是直径）。而第三个点，就是从这条“主链”上延伸出去的**最长分支**（比如样例中的6或8）。这样三个点的路径并，就是“主链长度 + 最长分支长度”，刚好是最大的可能！

### 核心逻辑拆解：
1. **找主链（直径）**：用两次DFS找到树的直径的两个端点（比如样例中的1和5）。
2. **标主链**：把直径上的所有节点标记出来（避免重复计算分支长度）。
3. **找最长分支**：从主链上的每个节点出发，找其非主链子树中的最远点（比如样例中的6）。
4. **计算结果**：总长度 = 主链长度 + 最长分支长度，三个点就是直径端点+最长分支端点。

### 可视化设计思路：
我们会用**8位像素风格**（类似FC红白机）做动画：
- 树用彩色像素方块表示，主链节点用红色标记，分支节点用蓝色。
- 第一次DFS：从根节点（比如1）出发，黄色箭头遍历所有节点，找到最远点（5）时播放“叮”的音效。
- 第二次DFS：从5出发，红色线条标记主链（1→2→3→4→5），同时播放“沙沙”的路径绘制声。
- 找最长分支：从主链每个节点（比如4）出发，绿色箭头遍历子树，找到最远点（6）时播放“嗒”的音效。
- 动画支持**单步执行**和**自动播放**，还能通过滑块调整速度，让你慢慢看清楚每一步！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份评分≥4星的优质题解，帮你快速理解核心解法：
</eval_intro>

### **题解一：syksykCCC（赞14）**  
* **点评**：这份题解是最严谨的！作者用**反证法**证明了“直径端点必须选”的结论（如果不选直径，换成直径端点会更长），还详细解释了“为什么第三个点要来自不同子树”（避免路径重叠）。代码用了**DFS找直径**+**树形DP找最远点**，变量名`f[u]`（u的最长分支长度）、`g[u]`（最长分支的端点）非常清晰。尤其是处理“主链节点的子树”时，特意排除了主链的下一个节点，避免重复计算，细节很到位！

### **题解二：两年打铁（赞5）**  
* **点评**：这份题解的代码**最简捷**！作者用两次DFS找直径，然后用`vis数组`标记主链节点，最后再用一次DFS找离主链最远的点。逻辑直接，没有多余的复杂结构，特别适合刚学树论的同学参考。美中不足的是结论没有详细证明，但代码的可读性很高，变量`a`（直径端点1）、`b`（直径端点2）、`k`（最长分支端点）一看就懂。

### **题解三：tommymio（赞4）**  
* **点评**：这份题解的**效率最高**！作者用**BFS代替DFS**找最远点，避免了递归可能的栈溢出问题（适合大节点数的情况）。代码中用队列存储主链节点，然后逐层遍历子树，找最长分支。尤其是“处理链状树”的特判（如果没有分支，就选主链中间的点），考虑得很周全，实践价值很高！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于突破三个“思维卡点”。结合优质题解的经验，我们逐一拆解：
</difficulty_intro>

### 1. **卡点1：为什么必须选直径端点？**  
* **分析**：假设我们选了两个点`u`和`v`，它们的路径不是直径。根据树的直径定义，直径是最长的路径，所以必然存在一个点`w`，使得`u→w`或`v→w`比`u→v`长。把`u`或`v`换成`w`，总路径并会更长——这就证明了“选直径端点更优”。  
* 💡 **学习笔记**：树的直径是“最长路径”，选它的端点能最大化基础长度。

### 2. **卡点2：如何标记主链（直径）的节点？**  
* **分析**：找到直径的两个端点后，需要回溯父节点路径（比如从端点`v`出发，沿着`fa[v]`走到`u`），把路径上的所有节点标记为`vis=1`。这样后续找分支时，就不会重复计算主链的边。  
* 💡 **学习笔记**：回溯父节点是标记路径的常用技巧！

### 3. **卡点3：如何找离主链最远的点？**  
* **分析**：从主链上的每个节点出发，遍历其**非主链的子树**（即子节点不是主链的下一个节点），记录最远的节点。这样找到的点，其到主链的距离就是最长分支长度。  
* 💡 **学习笔记**：排除主链的子节点，避免“绕回主链”的无效路径。

### ✨ 解题技巧总结
- **技巧1：两次DFS找直径**：第一次找离根最远的点`u`，第二次找离`u`最远的点`v`，`u→v`就是直径。
- **技巧2：标记路径用回溯**：通过`fa数组`回溯，标记直径上的所有节点。
- **技巧3：分支搜索避主链**：遍历子树时，跳过主链的下一个节点，确保找的是“纯分支”。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**通用核心代码**，综合了优质题解的思路，结构清晰，适合入门：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自syksykCCC和两年打铁的题解，整合了“两次DFS找直径”“回溯标记主链”“DFS找最长分支”的核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int N = 2e5 + 5;
vector<int> G[N];
int dep[N], fa[N], vis[N];
int u, v, w, max_len;

// 第一次DFS：找离start最远的点（存到全局变量v）
void dfs1(int start, int father) {
    fa[start] = father;
    for (int next : G[start]) {
        if (next == father) continue;
        dep[next] = dep[start] + 1;
        dfs1(next, start);
    }
}

// 第二次DFS：找离主链最远的点（存到全局变量w）
void dfs2(int start, int father, int depth) {
    if (depth > max_len && !vis[start]) {
        max_len = depth;
        w = start;
    }
    for (int next : G[start]) {
        if (next == father || vis[next]) continue;
        dfs2(next, start, depth + 1);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int a, b;
        cin >> a >> b;
        G[a].push_back(b);
        G[b].push_back(a);
    }

    // 第一步：找直径的两个端点u和v
    dep[1] = 0;
    dfs1(1, 0);
    u = 1;
    for (int i = 1; i <= n; ++i) {
        if (dep[i] > dep[u]) u = i;
    }
    dep[u] = 0;
    dfs1(u, 0);
    v = u;
    for (int i = 1; i <= n; ++i) {
        if (dep[i] > dep[v]) v = i;
    }

    // 第二步：标记直径上的节点（vis=1）
    int cur = v;
    while (cur != u) {
        vis[cur] = 1;
        cur = fa[cur];
    }
    vis[u] = 1;

    // 第三步：找离主链最远的点w
    max_len = -1;
    for (int i = 1; i <= n; ++i) {
        if (vis[i]) {
            dfs2(i, 0, 0);
        }
    }
    if (w == 0) w = fa[v]; // 处理链状树的特殊情况

    // 输出结果
    cout << dep[v] + max_len << endl;
    cout << u << " " << v << " " << w << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **找直径**：两次`dfs1`，第一次找离1最远的`u`，第二次找离`u`最远的`v`，`u→v`就是直径。
  2. **标记主链**：从`v`回溯到`u`，把路径上的节点标记为`vis=1`。
  3. **找最长分支**：从每个主链节点出发，`dfs2`遍历非主链子树，找到最远点`w`。
  4. **输出**：总长度是直径长度（`dep[v]`）+最长分支长度（`max_len`），三个点是`u`、`v`、`w`。


### 针对各优质题解的片段赏析

#### **题解一：syksykCCC的树形DP片段**
* **亮点**：用DP维护每个节点的最长分支长度和端点，避免重复计算。
* **核心代码片段**：
```cpp
int f[N], g[N], maxl = -1, dw;
void solve(int u, int pos) {
    if (u != path[pos]) {
        for (int v : G[u]) if (v != fa[u]) {
            solve(v, pos);
            if (f[u] < f[v] + 1) {
                f[u] = f[v] + 1;
                g[u] = g[v];
            }
        }
    } else {
        for (int v : G[u]) if (v != fa[u]) {
            solve(v, pos + 1);
            if (v != path[pos + 1] && f[u] < f[v] + 1) {
                f[u] = f[v] + 1;
                g[u] = g[v];
            }
        }
    }
    if (f[u] > maxl && g[u] != du && g[u] != dv) {
        maxl = f[u];
        dw = g[u];
    }
}
```
* **代码解读**：
  - `f[u]`：节点`u`的最长分支长度；`g[u]`：最长分支的端点。
  - 对于主链节点（`u == path[pos]`），跳过主链的下一个节点（`v != path[pos+1]`），只计算分支长度。
  - 最后筛选出不是直径端点的`g[u]`，就是最长分支的端点`dw`。
* 💡 **学习笔记**：树形DP可以高效维护子树的最长路径，适合需要“记录端点”的场景。


#### **题解二：两年打铁的标记主链片段**
* **亮点**：用`vis数组`简单标记主链，代码简洁。
* **核心代码片段**：
```cpp
int now = b;
while (now) {
    vis[now] = 1;
    now = fa[now];
}
```
* **代码解读**：从直径的一个端点`b`出发，沿着`fa数组`回溯到另一个端点`a`，把路径上的节点标记为`vis=1`。这样后续遍历子树时，就能跳过主链节点。
* 💡 **学习笔记**：回溯父节点是标记路径的“万能技巧”，简单又高效！


#### **题解三：tommymio的BFS找最远点片段**
* **亮点**：用BFS代替DFS，避免递归栈溢出，适合大节点数。
* **核心代码片段**：
```cpp
queue<pair<int, int>> Q;
while (Q.size()) {
    int x = Q.front().first, step = Q.front().second; Q.pop();
    if (mx < step) mx = step, p = x;
    for (int i = h[x], y; i; i = ver[i]) {
        if (!vis[y = to[i]]) {
            Q.push(make_pair(y, step + 1));
            vis[y] = 1;
        }
    }
}
```
* **代码解读**：用队列存储主链节点，然后逐层遍历子树（`step`是当前深度），记录最远的点`p`。BFS的“逐层扩展”特性，刚好适合找最远点。
* 💡 **学习笔记**：BFS适合“层次遍历”场景，DFS适合“深度优先”场景，根据题目选择！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法流程，我设计了一个**8位像素风格的动画**，结合复古游戏元素，保证好玩又好懂！
</visualization_intro>

### **动画演示主题**：像素树的“主链探险”  
（风格类似FC游戏《塞尔达传说》的俯视视角，树用像素方块表示，节点是彩色小方块，边是白色线条。）

### **核心演示内容**：
1. **场景初始化**：
   - 屏幕中央显示一棵像素树（比如样例中的8节点树），根节点1是红色，其他节点是蓝色，边是白色。
   - 底部有控制面板：「开始」「单步」「重置」按钮，速度滑块（从“慢”到“快”），还有“AI自动演示”开关。
   - 背景播放8位风格的轻快BGM（类似《超级马里奥》的背景音乐）。

2. **第一步：找直径的第一个端点**（DFS1）：
   - 黄色箭头从节点1出发，逐个遍历子节点（1→2→3→4→5→6→3→7→3→2→1→...）。
   - 每遍历一个节点，节点闪烁一次，播放“哔”的音效。
   - 找到最远点5时，节点5变成橙色，播放“叮”的音效，屏幕弹出文字“找到直径端点1：5！”。

3. **第二步：找直径的第二个端点**（DFS2）：
   - 黄色箭头从节点5出发，遍历路径5→4→3→2→1（此时节点1是最远点）。
   - 路径上的节点逐个变成红色（标记为主链），播放“沙沙”的绘制声。
   - 找到端点1时，节点1变成橙色，屏幕弹出文字“找到直径端点2：1！主链是1→2→3→4→5！”。

4. **第三步：标记主链**：
   - 红色节点（1、2、3、4、5）闪烁三次，播放“嗡”的音效，屏幕弹出文字“主链已标记！”。

5. **第四步：找最长分支**（DFS2）：
   - 绿色箭头从主链的每个节点出发，遍历非主链子树：
     - 从4出发，遍历4→6（节点6是最远点）；
     - 从3出发，遍历3→7、3→8（节点7和8的距离是1）。
   - 每遍历一个分支节点，节点变成绿色，播放“嗒”的音效。
   - 找到最长分支6时，节点6变成紫色，播放“叮”的音效，屏幕弹出文字“找到最长分支：6！”。

6. **结果展示**：
   - 主链（红色）+最长分支（紫色）的边闪烁，屏幕显示总长度“5”，以及三个点“1 5 6”。
   - 播放胜利音效（类似《魂斗罗》的通关音乐），屏幕弹出“任务完成！”。

### **交互设计**：
- **单步执行**：点击“单步”按钮，动画执行一步（比如遍历一个节点），方便仔细观察。
- **自动播放**：滑动速度滑块，调整动画速度（慢：1秒/步；快：0.1秒/步）。
- **AI演示**：开启“AI自动演示”，动画会自动完成所有步骤，像“游戏AI”一样展示解题过程。

### **设计理由**：
- **像素风格**：复古游戏感强，降低学习的“距离感”，让你觉得“像玩游戏一样学算法”。
- **颜色标记**：用不同颜色区分主链、分支、端点，直观看到“哪些节点在变化”。
- **音效提示**：用不同音效强化关键操作（比如“叮”表示找到端点，“嗒”表示遍历分支），帮助记忆。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“直径+最长分支”的思路后，我们可以把它迁移到更多树论问题中。比如：
</similar_problems_intro>

### **通用思路迁移**：
- **场景1**：找树的“中心”（到所有节点距离最小的点）——需要先找直径，中心在直径的中点。
- **场景2**：找树的“最长路径”（直径）——本题的基础。
- **场景3**：找k个点，使得它们的路径并最长——可以推广为“直径+k-2条最长分支”。

### **洛谷练习推荐**：
1. **洛谷 P1099** - 树的直径  
   🗣️ **推荐理由**：最基础的树的直径问题，帮你巩固“两次DFS找直径”的技巧。
2. **洛谷 P2634** - 树的中心  
   🗣️ **推荐理由**：需要找离直径最远的点，和本题的“找最长分支”思路完全一致。
3. **洛谷 P3398** - 仓鼠找 sugar  
   🗣️ **推荐理由**：需要用LCA（最近公共祖先）计算路径长度，是本题的拓展。
4. **洛谷 P4381** - 树的直径变形  
   🗣️ **推荐理由**：直径的变形问题，需要考虑边权，提升你的思维难度。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”，比代码更有价值！我们摘录了两个关键经验：
</insights_intro>

### **经验1：避免选同一子树的点**（来自syksykCCC）  
> “如果三个点在同一子树里，路径会重叠，总长度会变短。所以第三个点必须来自不同的子树。”  
**点评**：这个经验提醒我们，选点时要“分散”，避免路径重叠。比如样例中的1、5、6，分别来自主链的两端和分支，路径并最长。

### **经验2：处理链状树的特殊情况**（来自tommymio）  
> “如果树是一条链（没有分支），那么第三个点可以选主链中间的点。”  
**点评**：链状树是特殊情况，此时最长分支长度为0，所以第三个点选主链上的任意非端点即可。比如链状树1-2-3-4-5，第三个点可以选3。


<conclusion>
本次关于“Three Paths on a Tree”的分析就到这里啦！记住：**树的直径是解决路径并问题的“金钥匙”**，找到主链后再找最长分支，就能得到最大结果。下次遇到树论问题，不妨先想想“有没有直径可以用？”，说不定能快速解决！  

编程的乐趣在于“用简单的思路解决复杂的问题”，继续加油哦！💪
</conclusion>

---
处理用时：118.44秒
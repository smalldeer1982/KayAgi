# 题目信息

# Enlarge GCD

## 题目描述

Mr. F has $ n $ positive integers, $ a_1, a_2, \ldots, a_n $ .

He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.

But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.

Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.

## 说明/提示

In the first example, the greatest common divisor is $ 1 $ in the beginning. You can remove $ 1 $ so that the greatest common divisor is enlarged to $ 2 $ . The answer is $ 1 $ .

In the second example, the greatest common divisor is $ 3 $ in the beginning. You can remove $ 6 $ and $ 9 $ so that the greatest common divisor is enlarged to $ 15 $ . There is no solution which removes only one integer. So the answer is $ 2 $ .

In the third example, there is no solution to enlarge the greatest common divisor. So the answer is $ -1 $ .

## 样例 #1

### 输入

```
3
1 2 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4
6 9 15 30
```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 1 1
```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Enlarge GCD 深入学习指南 💡

<introduction>
今天我们来一起分析“Enlarge GCD”这道C++编程题。这道题的核心是通过删除最少的数，让剩余数的最大公约数（GCD）比原来的更大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（GCD计算、质因数分解、筛法应用）

🗣️ **初步分析**：
> 解决“Enlarge GCD”的关键在于理解如何通过数论操作（GCD计算、质因数分解）和筛法（埃氏筛/线性筛）高效统计质因数的出现次数。简单来说，我们需要找到一个质数 \( p \)，使得尽可能多的数是 \( p \) 的倍数，这样删除的数最少。  
> 题目核心步骤是：  
> 1. 计算原数组的GCD \( d \)，将每个数除以 \( d \)，得到新数组（此时新数组的GCD为1）。  
> 2. 统计新数组中各质数的倍数个数，找到出现次数最多的质数 \( p \)，则删除的数为 \( n - \text{该质数的倍数个数} \)。  
> 若所有数除以 \( d \) 后都是1（即无法找到更大的GCD），返回-1。  
> 核心难点在于如何高效统计质数的倍数个数。优质题解普遍采用筛法（如埃氏筛），通过枚举质数并累加其倍数的出现次数，时间复杂度优化至 \( O(m \log \log m) \)（\( m \) 为新数组最大值）。  
> 可视化设计将采用8位像素风格，模拟筛法过程：用不同颜色的像素块表示数，质数 \( p \) 的倍数块会被高亮，同时动态展示计数过程，配合“叮”的音效提示关键操作（如筛到一个质数）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解因逻辑简洁、实现高效被选为优质参考（评分≥4星）：
</eval_intro>

**题解一：作者Siyuan（优化思路）**
* **点评**：此题解巧妙地将原数组除以GCD \( d \)，将问题转化为寻找新数组的最大公约数大于1的质数。代码通过埃氏筛统计每个质数的倍数个数，时间复杂度优化至 \( O(m \log \log m) \)，适合竞赛场景。代码结构清晰，变量名（如`cnt`统计倍数个数）含义明确，边界处理严谨（如`ans`初始化为\( n \)，最后判断是否无解）。

**题解二：作者Acc_Robin**
* **点评**：此题解进一步简化了逻辑，直接枚举质数并统计其倍数的出现次数。代码利用筛法特性，通过`buc`数组记录每个数的出现次数，避免重复计算。变量命名（如`res`记录当前质数的倍数个数）直观，核心循环（枚举质数及其倍数）简洁高效，是典型的筛法应用范例。

**题解三：作者Npse_D**
* **点评**：此题解强调“新GCD必为质数”的性质（反证法可证），直接枚举质数并统计倍数个数。代码利用`vis`数组标记已筛质数，避免重复计算，时间复杂度低。关键步骤（除以原GCD、筛法统计）注释清晰，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于处理原GCD的影响、高效统计质数的倍数个数，以及理解“新GCD必为质数”的性质。以下是核心难点及策略：
</difficulty_intro>

1.  **关键点1：如何消除原GCD的影响？**
    * **分析**：原数组的GCD \( d \) 是所有数的公因子，删除数后的新GCD必须大于 \( d \)，等价于新数组（原数组除以 \( d \)）的GCD大于1。因此，只需处理新数组，无需考虑 \( d \) 本身。  
    * 💡 **学习笔记**：将原数组除以GCD \( d \) 是关键一步，它将问题转化为寻找新数组的GCD大于1的情况。

2.  **关键点2：如何高效统计质数的倍数个数？**
    * **分析**：直接枚举每个数的质因数复杂度高（\( O(n \sqrt{a_i}) \)），优质题解采用筛法（埃氏筛或线性筛）。筛法通过枚举质数 \( p \)，累加其倍数的出现次数（如`cnt[j]`记录数 \( j \) 的出现次数），时间复杂度优化至 \( O(m \log \log m) \)。  
    * 💡 **学习笔记**：筛法是统计质数倍数的高效工具，利用“每个合数被最小质因数筛出”的性质，避免重复计算。

3.  **关键点3：为什么新GCD必为质数？**
    * **分析**：假设新GCD是合数 \( k \)，则 \( k \) 的质因数 \( p \) 也是新数组的公因子。此时，以 \( p \) 为GCD时，需要删除的数更少（因为 \( p \) 的倍数包含 \( k \) 的倍数）。因此，最优解对应的GCD必为质数。  
    * 💡 **学习笔记**：寻找质数作为新GCD，能确保删除的数最少。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将原问题转化为新数组（除以原GCD）的GCD大于1的问题，简化计算。  
- **筛法应用**：利用埃氏筛统计质数的倍数个数，高效解决“统计”难题。  
- **边界处理**：若新数组所有数均为1（即无法找到更大的GCD），返回-1。  
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，代码简洁高效，适合直接参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合Siyuan、Acc_Robin等题解思路，通过筛法统计质数的倍数个数，找到最优解。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    const int N = 3e5 + 5;
    const int M = 1.5e7 + 5;

    int n, a[N], d, cnt[M], mx, ans;
    bool vis[M];
    int p[M / 10], tot;

    void sieve(int n) {
        for (int i = 2; i <= n; ++i) {
            if (!vis[i]) p[++tot] = i;
            for (int j = 1; j <= tot && i * p[j] <= n; ++j) {
                vis[i * p[j]] = 1;
                if (i % p[j] == 0) break;
            }
        }
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            d = __gcd(d, a[i]);
        }
        for (int i = 1; i <= n; ++i) {
            a[i] /= d;
            cnt[a[i]]++;
            mx = max(mx, a[i]);
        }
        sieve(mx);
        ans = n;
        for (int i = 1; i <= tot; ++i) {
            int num = 0;
            for (int j = p[i]; j <= mx; j += p[i]) {
                num += cnt[j];
            }
            if (num) ans = min(ans, n - num);
        }
        printf("%d\n", ans == n ? -1 : ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先计算原数组的GCD \( d \)，将每个数除以 \( d \) 并统计新数组中各数的出现次数（`cnt`数组）。通过埃氏筛（`sieve`函数）预处理质数，枚举每个质数 \( p \) 并累加其倍数的出现次数（`num`），最终找到删除数最少的解（`ans = min(ans, n - num)`）。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，理解其亮点和实现思路。
</code_intro_selected>

**题解一：作者Siyuan（优化思路）**
* **亮点**：通过筛法直接枚举质数，统计其倍数的出现次数，时间复杂度低。
* **核心代码片段**：
    ```cpp
    sieve(mx);
    int ans = n;
    for (int i = 1; i <= tot; ++i) {
        int x = p[i], num = 0;
        for (int j = x; j <= mx; j += x) num += cnt[j];
        if (num) ans = std::min(ans, n - num);
    }
    ```
* **代码解读**：  
  `sieve(mx)`预处理所有≤`mx`的质数。外层循环枚举每个质数 \( x \)（`p[i]`），内层循环累加 \( x \) 的倍数的出现次数（`cnt[j]`）。`num`表示新数组中是 \( x \) 倍数的数的个数，`n - num`即需要删除的数的个数，取最小值即为答案。  
* 💡 **学习笔记**：筛法枚举质数并统计倍数个数，是解决此类问题的高效方法。

**题解二：作者Acc_Robin**
* **亮点**：代码简洁，直接利用筛法特性，避免重复计算。
* **核心代码片段**：
    ```cpp
    sieve(mx); ans = n;
    for (int i = 1; i <= cnt; i++) {
        int res = 0;
        for (int j = 1; p[i] * j <= mx; j++) res += buc[p[i] * j];
        if (res) ans = std::max(ans, res);
    }
    printf("%d\n", ans == 0 ? -1 : n - ans);
    ```
* **代码解读**：  
  `sieve(mx)`预处理质数后，枚举每个质数 \( p[i] \)，累加其倍数的出现次数（`buc[p[i] * j]`）。`res`表示当前质数的倍数个数，`ans`取最大的`res`，最终删除数为 \( n - \text{ans} \)。  
* 💡 **学习笔记**：通过取最大的`res`，确保删除的数最少，逻辑清晰。

**题解三：作者Npse_D**
* **亮点**：利用埃筛特性，标记已筛质数，避免重复统计。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= inf; i++) {
        int h = 0;
        if (!vis[i]) for (int j = i; j <= inf; j += i) vis[j] = 1, h += c[j];
        t = min(t, n - h);
    }
    ```
* **代码解读**：  
  `vis[i]`标记是否为质数（未标记的是质数）。对于每个质数 \( i \)，累加其倍数的出现次数（`c[j]`），`n - h`即删除的数，取最小值即为答案。  
* 💡 **学习笔记**：`vis`数组同时用于筛质数和标记已处理的数，节省空间。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解筛法统计质数倍数的过程，我们设计一个8位像素风格的动画，模拟“质数探险家”在数字网格中寻找最优质数的过程。
</visualization_intro>

  * **动画演示主题**：`像素质数探险家——寻找最大公约数`

  * **核心演示内容**：  
    展示原数组除以GCD \( d \) 后的新数组，通过埃氏筛法枚举质数，并统计每个质数的倍数个数，最终找到删除数最少的质数 \( p \)。

  * **设计思路简述**：  
    采用8位像素风格（如FC游戏画面），用不同颜色的像素块表示数字（如蓝色表示普通数，红色表示质数）。筛法过程中，质数 \( p \) 的倍数块会被高亮（变黄），同时动态显示计数（`num`），配合“叮”的音效提示倍数累加。目标达成时（找到最优 \( p \)）播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示新数组（像素块，数值标注在块上），右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。  
        - 播放8位风格背景音乐（如《超级玛丽》经典旋律）。

    2.  **原GCD计算**：  
        - 所有数的像素块聚集，中央显示原GCD \( d \)（如“GCD=3”），随后每个数除以 \( d \)（像素块数值变化，如“6”变为“2”）。

    3.  **筛法统计质数倍数**：  
        - 从2开始枚举质数（像素箭头指向当前质数 \( p \)），所有 \( p \) 的倍数块高亮（变黄），并伴随“叮”的音效。  
        - 右侧计数区显示当前质数的倍数个数（如“num=4”），动态更新最小值（如“删除数=2”）。

    4.  **目标达成**：  
        - 找到最优质数 \( p \) 时，所有保留的块（\( p \) 的倍数）播放庆祝动画（闪烁星星），右侧显示最终删除数（如“答案=1”），播放胜利音效（如《魂斗罗》通关音）。

    5.  **交互控制**：  
        - 支持单步执行（逐个数检查是否为质数倍数）、自动播放（可调节速度）、重置（回到初始状态）。

  * **旁白提示**：  
    - （开始时）“我们需要找到一个质数，让最多的数是它的倍数！”  
    - （筛到质数时）“看，质数2的倍数有这些数，它们会被保留！”  
    - （目标达成时）“找到啦！删除这些数后，新的GCD就是这个质数！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到筛法如何统计质数的倍数，以及如何找到最优解，让抽象的算法变得“可见可玩”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的思路后，我们可以尝试以下拓展练习，巩固数论和筛法的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“通过筛法统计质数的倍数个数”，这一思路可迁移至以下场景：  
    1. 统计数组中互质数的对数（需统计每个质数的倍数个数）。  
    2. 寻找数组中的众数质因数（类似本题统计出现次数最多的质数）。  
    3. 判断数组是否存在公因子大于1（即本题的子问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1072** - `Hankson的趣味题`  
        * 🗣️ **推荐理由**：涉及GCD和质因数分解，需结合数论知识解决，适合巩固GCD的应用。  
    2.  **洛谷 P3383** - `线性筛法（素数筛）`  
        * 🗣️ **推荐理由**：直接练习线性筛法的实现，深入理解筛法原理，为解决本题类问题打基础。  
    3.  **洛谷 P2158** - `[SDOI2008]仪仗队`  
        * 🗣️ **推荐理由**：涉及欧拉函数和质数统计，需用筛法高效计算，与本题思路有共通之处。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者Siyuan)**：“最初直接暴力分解质因数，发现时间复杂度过高。后来想到将原数组除以GCD，并用筛法统计质数的倍数个数，才优化到可接受的复杂度。”  
> **点评**：Siyuan的经验提醒我们，遇到复杂度问题时，应先尝试问题转化（如除以原GCD），再结合高效算法（如筛法）优化。这是竞赛中常见的“降维”策略。

-----

<conclusion>
本次关于“Enlarge GCD”的C++解题分析就到这里。希望这份学习指南能帮助大家理解数论和筛法的应用，掌握如何通过问题转化和高效算法解决实际问题。记住，多动手实践、多思考优化，编程能力会稳步提升！下次再见~ 💪
</conclusion>

---
处理用时：388.05秒
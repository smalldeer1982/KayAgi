# 题目信息

# Enlarge GCD

## 题目描述

Mr. F has $ n $ positive integers, $ a_1, a_2, \ldots, a_n $ .

He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.

But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.

Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.

## 说明/提示

In the first example, the greatest common divisor is $ 1 $ in the beginning. You can remove $ 1 $ so that the greatest common divisor is enlarged to $ 2 $ . The answer is $ 1 $ .

In the second example, the greatest common divisor is $ 3 $ in the beginning. You can remove $ 6 $ and $ 9 $ so that the greatest common divisor is enlarged to $ 15 $ . There is no solution which removes only one integer. So the answer is $ 2 $ .

In the third example, there is no solution to enlarge the greatest common divisor. So the answer is $ -1 $ .

## 样例 #1

### 输入

```
3
1 2 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4
6 9 15 30
```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 1 1
```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Enlarge GCD 深入学习指南 💡

<introduction>
今天我们来一起分析“Enlarge GCD”这道C++编程题。这道题的核心是通过删除最少的数，使得剩余数的最大公约数（GCD）比原来的更大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（质数筛法与GCD性质应用）

🗣️ **初步分析**：
解决“Enlarge GCD”的关键在于理解GCD的性质和质数筛法的应用。简单来说，GCD是所有数的公共因数，要让新的GCD更大，我们需要找到一个质数，使得尽可能多的数能被它整除（这样删除的数最少）。  

题目可以拆解为两步：  
1. **消除原GCD的影响**：计算原数组的GCD（记为`d`），将每个数除以`d`，此时新数组的GCD变为1。问题转化为“找到新数组的GCD大于1的最小删除数”。  
2. **寻找最优质数**：枚举质数，统计新数组中能被该质数整除的数的个数（记为`cnt`），删除的数即为`n - cnt`。最终取所有质数中`n - cnt`的最小值。  

核心难点在于如何高效统计质数的倍数出现次数。优质题解普遍采用**埃拉托斯特尼筛法**（埃氏筛），通过筛法遍历质数并统计其倍数的出现次数，时间复杂度为`O(m log log m)`（`m`为新数组最大值），非常高效。  

可视化设计思路：我们可以用8位像素风格展示筛法过程：  
- 屏幕左侧用像素网格表示新数组的数（如方块颜色深浅表示数值大小），右侧用堆叠的像素块表示当前枚举的质数及其倍数。  
- 当筛到质数`p`时，所有`p`的倍数的方块会闪烁并标记为绿色（表示被选中保留），同时右侧统计该质数的`cnt`值。  
- 关键操作（如筛质数、统计倍数）伴随“叮”的像素音效，最终找到最优解时播放胜利音效，高亮最小删除数。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解评分均≥4星，值得重点学习：
</eval_intro>

**题解一：作者Siyuan（赞：15）**  
* **点评**：此题解逻辑清晰，首先通过计算原数组的GCD并消除其影响，再利用埃氏筛统计质数的倍数出现次数。代码结构工整（如`sieve`函数实现筛法，主函数流程明确），变量命名直观（`cnt`统计倍数次数）。亮点在于优化了时间复杂度，通过筛法将复杂度从`O(n√a_i)`降至`O(m log log m)`，适合竞赛场景。

**题解二：作者Acc_Robin（赞：9）**  
* **点评**：此题解对问题转化的解释非常透彻（将原问题转化为新数组的GCD>1），代码简洁且注释友好（如`sieve`函数标注筛法逻辑）。亮点在于利用调和级数优化筛法，复杂度分析准确，适合理解筛法在统计中的应用。

**题解三：作者Npse_D（赞：8）**  
* **点评**：此题解巧妙利用埃筛特性，直接在筛质数的过程中统计倍数次数（`for(int j=i;j<=inf;j+=i) vis[j]=1,h+=c[j]`），代码短小精悍。亮点在于将筛法与统计合并，减少了冗余操作，适合学习如何简化算法步骤。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何将原问题转化为新数组的GCD问题？  
    * **分析**：原数组的GCD为`d`，若剩余数的GCD要大于`d`，则它们的GCD必须是`d`的倍数。将每个数除以`d`后，新数组的GCD为1，此时只需让新数组的GCD>1即可。这一步转化是解题的基石，避免了直接处理原GCD的复杂情况。  
    * 💡 **学习笔记**：通过除以原GCD，将问题简化为“新数组GCD>1”，是解决此类GCD问题的常用技巧。

2.  **关键点2**：如何高效统计质数的倍数出现次数？  
    * **分析**：直接枚举每个数的质因数会超时（`O(n√a_i)`）。优质题解采用埃氏筛：遍历每个质数`p`，统计所有`p`的倍数在新数组中的出现次数（`cnt`）。筛法的时间复杂度为`O(m log log m)`（`m`为新数组最大值），非常高效。  
    * 💡 **学习笔记**：埃氏筛不仅能筛质数，还能高效统计区间内质数的倍数分布，是处理数论问题的“多面手”。

3.  **关键点3**：如何处理边界情况（如无解的情况）？  
    * **分析**：若新数组中所有数都是1（即原数组所有数相同），则无法找到GCD>1的情况，返回-1。优质题解通过判断`ans`是否仍为初始最大值（如`n`）来处理这种情况。  
    * 💡 **学习笔记**：边界条件（如全1数组）需在代码中单独判断，避免逻辑漏洞。

### ✨ 解题技巧总结
- **问题转化**：通过除以原GCD，将问题简化为“新数组GCD>1”，降低复杂度。  
- **筛法统计**：利用埃氏筛同时完成质数筛选和倍数统计，避免重复计算。  
- **边界判断**：处理“所有数除以GCD后为1”的情况，确保返回-1的正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先来看一个综合优质题解的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Siyuan和Acc_Robin的思路，采用埃氏筛统计质数的倍数次数，逻辑清晰且高效。  
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    const int N = 3e5 + 5;
    const int M = 1.5e7 + 5;
    int n, d, a[N], cnt[M], mx;
    bool vis[M];
    int p[M], tot; // p数组存储质数，tot为质数个数

    // 埃拉托斯特尼筛法
    void sieve(int max_num) {
        for (int i = 2; i <= max_num; ++i) {
            if (!vis[i]) p[++tot] = i;
            for (int j = 1; j <= tot && i * p[j] <= max_num; ++j) {
                vis[i * p[j]] = true;
                if (i % p[j] == 0) break;
            }
        }
    }

    int main() {
        scanf("%d", &n);
        // 计算原数组的GCD
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            d = __gcd(d, a[i]);
        }
        // 消除原GCD的影响，并统计新数组各数的出现次数
        for (int i = 1; i <= n; ++i) {
            a[i] /= d;
            cnt[a[i]]++;
            mx = max(mx, a[i]);
        }
        // 筛法处理新数组的最大值
        sieve(mx);
        int ans = n; // 初始化为n（最多删除n个数）
        for (int i = 1; i <= tot; ++i) {
            int num = 0; // 统计当前质数p[i]的倍数出现次数
            for (int j = p[i]; j <= mx; j += p[i]) {
                num += cnt[j];
            }
            if (num > 0) ans = min(ans, n - num);
        }
        // 若ans仍为n，说明无解
        printf("%d\n", ans == n ? -1 : ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先计算原数组的GCD`d`，将每个数除以`d`后得到新数组。通过`cnt`数组统计新数组中各数的出现次数。利用埃氏筛筛选出所有不超过新数组最大值`mx`的质数，遍历每个质数并统计其倍数的出现次数`num`，最终`n - num`的最小值即为答案（若所有质数的`num`都为0，返回-1）。

---
<code_intro_selected>
接下来，剖析优质题解中的核心代码片段，理解其亮点和思路：
</code_intro_selected>

**题解一：作者Siyuan（优化思路代码）**  
* **亮点**：通过筛法直接统计质数的倍数次数，代码简洁高效。  
* **核心代码片段**：
    ```cpp
    sieve(mx);
    int ans = n;
    for (int i = 1; i <= tot; ++i) {
        int x = p[i], num = 0;
        for (int j = x; j <= mx; j += x) num += cnt[j];
        if (num) ans = min(ans, n - num);
    }
    ```
* **代码解读**：  
  这段代码遍历筛出的每个质数`p[i]`，通过`j += x`枚举其所有倍数（`x`为当前质数），累加这些倍数在新数组中的出现次数`num`。最终取`n - num`的最小值作为答案。例如，当质数为2时，`j`会遍历2、4、6…等数，统计这些数在新数组中的出现次数，从而计算需要删除的数（`n - num`）。  
* 💡 **学习笔记**：筛法的核心是“枚举质数+统计倍数”，这种方式避免了逐个分解质因数的低效操作。

**题解二：作者Npse_D**  
* **亮点**：在筛质数的同时统计倍数次数，一步完成。  
* **核心代码片段**：
    ```cpp
    for(int i=2;i<=inf;i++){
        int h=0;
        if(!vis[i]) for(int j=i;j<=inf;j+=i) vis[j]=1,h+=c[j];
        t=min(t,n-h);
    }
    ```
* **代码解读**：  
  这里的`vis`数组既用于标记是否为质数（未标记的`i`是质数），又在遍历其倍数时统计出现次数`h`。例如，当`i=2`时，所有2的倍数`j`会被标记为已访问（`vis[j]=1`），同时累加`c[j]`（新数组中`j`的出现次数）到`h`。最终`n - h`即为删除该质数倍数外的数的个数。  
* 💡 **学习笔记**：利用数组的多用途（标记质数+统计次数）可以简化代码逻辑，提升效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“筛法统计质数倍数”的过程，我们设计一个8位像素风格的动画，模拟埃氏筛和统计过程。
</visualization_intro>

  * **动画演示主题**：`像素质数探险队`  
  * **核心演示内容**：展示如何通过埃氏筛找到质数，并统计新数组中这些质数的倍数出现次数，最终找到需要删除的最少数量。  

  * **设计思路简述**：  
    采用FC红白机风格的像素画面（8色调色板，如蓝色背景、绿色质数块、黄色倍数块），通过动态标记和音效强化操作记忆。例如，当筛到质数`2`时，所有2的倍数的方块会闪烁并变为绿色，同时右侧显示统计的`cnt`值，帮助学习者“看到”筛法的工作流程。

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 左侧显示新数组的像素方块（每个方块代表一个数，高度表示数值大小，颜色初始为灰色）。  
        - 右侧显示“控制面板”（开始/暂停、单步、重置按钮，速度滑块）和“质数列表”（初始为空）。  
        - 播放8位风格的轻快背景音乐（如《超级玛丽》风格的短旋律）。

    2.  **算法启动**：  
        - 计算原数组的GCD`d`，所有数除以`d`后，方块颜色变为白色（表示新数组的数）。  

    3.  **筛法与统计过程**：  
        - 单步执行时，从`i=2`开始遍历：  
          - 若`i`是质数（未被标记），左侧质数列表添加`i`（绿色像素字），同时`i`对应的方块闪烁并变为绿色。  
          - 遍历`i`的倍数（`j = i, 2i, 3i…`），每个倍数方块变为黄色（表示被选中保留），并在右侧统计`cnt`值（如“当前质数2的倍数有5个”）。  
          - 伴随“叮”的音效（类似《俄罗斯方块》的方块放置声）。  

    4.  **结果展示**：  
        - 遍历完所有质数后，找到最小的`n - cnt`（如删除1个数），目标方块组合高亮为红色，播放胜利音效（如《超级玛丽》吃到金币的音效）。  
        - 若无解（所有数都是1），显示“-1”并播放短促提示音。  

  * **旁白提示**：  
    - （筛到质数时）“看！这个数`i`是质数，我们要统计它的所有倍数～”  
    - （统计倍数时）“这些黄色方块都是`i`的倍数，它们会被保留下来哦！”  
    - （结果出现时）“找到啦！最少需要删除`ans`个数，剩余数的GCD就变大了～”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到筛法如何筛选质数、统计倍数，以及最终如何计算最小删除数，让抽象的算法步骤变得“看得见、听得见”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以进一步思考数学与筛法的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“通过筛法统计质数的倍数分布”，这一思路还可用于：  
    - 求数组中互质的数对个数（统计每个质数的倍数，用容斥计算）。  
    - 求区间内的质数个数（标准筛法应用）。  
    - 分解质因数（通过筛法预处理最小质因数，快速分解）。  

  * **练习推荐 (洛谷)**：  
    以下题目考察类似的数学与筛法应用，建议练习：  

    1.  **洛谷 P1072 [HNOI2007] koprimes**  
        * 🗣️ **推荐理由**：本题需要计算两个数的最大公约数为1的情况，涉及质因数分解和容斥原理，能巩固筛法与统计的应用。  

    2.  **洛谷 P1463 [HAOI2007] 反素数**  
        * 🗣️ **推荐理由**：需要找到区间内约数最多的数，涉及质因数分解和筛法，适合拓展对质数性质的理解。  

    3.  **洛谷 P3383 [模板] 线性筛法（素数筛）**  
        * 🗣️ **推荐理由**：直接练习线性筛法的实现，掌握更高效的筛法技巧，为解决复杂数论问题打基础。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自作者cxy000)**：“在处理全1数组时，一开始忘记特判，导致测试用例输出错误。后来通过添加`ooo`变量判断所有数是否相同，解决了这个问题。”  

**点评**：这位作者的经验提醒我们，边界条件（如全1数组）是容易出错的地方。在编码时，应优先考虑这些特殊情况，并通过测试用例验证。例如，本题中若新数组所有数都是1，则直接返回-1，避免后续无效计算。

---

<conclusion>
本次关于“Enlarge GCD”的C++解题分析就到这里。希望这份指南能帮助大家理解GCD性质、筛法应用和解题技巧。记住，多思考、多练习是掌握算法的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：146.11秒
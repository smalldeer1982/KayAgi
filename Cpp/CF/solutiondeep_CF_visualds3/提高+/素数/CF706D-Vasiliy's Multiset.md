# 题目信息

# Vasiliy's Multiset

## 题目描述

Author has gone out of the stories about Vasiliy, so here is just a formal task description.

You are given $ q $ queries and a multiset $ A $ , initially containing only integer $ 0 $ . There are three types of queries:

1. "+ x" — add integer $ x $ to multiset $ A $ .
2. "- x" — erase one occurrence of integer $ x $ from multiset $ A $ . It's guaranteed that at least one $ x $ is present in the multiset $ A $ before this query.
3. "? x" — you are given integer $ x $ and need to compute the value ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/728a3690d3a76b81fb1ccb07b4c04b8d10b1870d.png), i.e. the maximum value of bitwise exclusive OR (also know as XOR) of integer $ x $ and some integer $ y $ from the multiset $ A $ .

Multiset is a set, where equal elements are allowed.

## 说明/提示

After first five operations multiset $ A $ contains integers $ 0 $ , $ 8 $ , $ 9 $ , $ 11 $ , $ 6 $ and $ 1 $ .

The answer for the sixth query is integer ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/4b442d72cf0f109da9eae35430cf9dc9dfa35fdf.png) — maximum among integers ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/c712973b7cb6a6b393c3b423fc78dda636ebb034.png), ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/e9b3f94b7acd1861f4b82fb60d691b2bd163374e.png), ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/1bf5d0b4ff98720973629f7915ae529e790539ba.png), ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/9023c8bab139f08429005ae47d2d497f5795be9b.png) and ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF706D/e21b15be88af70287d01c0b8f13ae0d351197a9c.png).

## 样例 #1

### 输入

```
10
+ 8
+ 9
+ 11
+ 6
+ 1
? 3
- 8
? 3
? 8
? 11
```

### 输出

```
11
10
14
13
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Vasiliy's Multiset 深入学习指南 💡

<introduction>
今天我们来分析这道经典的“Vasiliy's Multiset”问题。这道题需要维护一个支持插入、删除和查询最大异或值的多重集合，核心难点在于如何高效处理这三个操作。通过学习01-Trie树的应用，我们可以轻松解决这类问题。让我们一起拆解思路，掌握核心技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`01-Trie树应用（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键是理解并运用01-Trie树（二进制字典树）。简单来说，01-Trie树就像一个“二进制数的字典”，每个节点代表二进制位的0或1，路径从根到叶子对应一个完整的二进制数。在本题中，01-Trie主要用于高效存储二进制数，并支持快速查询与给定数异或最大的数。

- **题解思路**：所有优质题解均采用01-Trie树。插入时将数的二进制位从高位到低位插入树中，删除时减少路径上节点的计数，查询时贪心选择与当前位相反的分支（若存在）以最大化异或结果。
- **核心难点**：如何维护节点计数以支持删除操作？如何在查询时贪心选择路径？
- **可视化设计**：用8位像素风格展示Trie树结构，节点用小方块表示（0分支为蓝色，1分支为红色），插入时节点计数增加（颜色变亮），删除时计数减少（颜色变暗），查询时用箭头高亮贪心路径。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点参考：
</eval_intro>

**题解一：黑影洞人（赞：13）**
* **点评**：此题解提供了完整的01-Trie实现，代码结构清晰，变量命名直观（如`num[u]`记录节点计数）。插入、删除、查询函数逻辑直白，边界处理严谨（如初始插入0）。算法时间复杂度为O(q·32)（每次操作处理32位），非常高效，适合竞赛直接使用。

**题解二：Zvelig1205（赞：4）**
* **点评**：此题解采用递归实现Trie树，对初学者更友好。通过`size`字段维护节点计数，并引入“垃圾场”（栈回收节点）优化空间，展示了动态开点的高级技巧。递归逻辑清晰，适合理解Trie树的构建过程。

**题解三：StupidSeven（赞：1）**
* **点评**：此题解代码简洁，变量命名规范（如`tree`表示Trie结构，`num`记录节点计数）。主函数逻辑清晰，输入处理高效（`Readint`函数），适合快速上手01-Trie的基础实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们常遇到以下核心难点，结合优质题解的经验，一起拆解策略：
</difficulty_intro>

1.  **关键点1：如何构建01-Trie树？**
    * **分析**：01-Trie的每个节点有两个子节点（0和1分支）。插入时，从最高位（如32位）到最低位逐位处理，若分支不存在则新建节点，并维护节点计数（`num[u]++`）。例如，插入数8（二进制1000）时，会依次经过根节点的1分支→0分支→0分支→0分支→叶子节点。
    * 💡 **学习笔记**：01-Trie的构建需从高位到低位，确保高位优先影响异或结果。

2.  **关键点2：如何支持删除操作？**
    * **分析**：删除时，需沿插入路径将每个节点的计数减1（`num[u]--`）。若某节点计数变为0，说明该分支无有效数，后续查询时会自动跳过。例如，删除数8时，路径上的每个节点计数减1，若某节点计数为0，后续查询不会选择该分支。
    * 💡 **学习笔记**：节点计数是实现删除的关键，它记录了经过该节点的数的个数。

3.  **关键点3：如何查询最大异或值？**
    * **分析**：查询时，从高位到低位贪心选择与当前位相反的分支（若该分支计数>0）。例如，当前位为1时，优先选择0分支（异或结果为1，贡献更高位）；若0分支无有效数（计数为0），则选择1分支（异或结果为0）。
    * 💡 **学习笔记**：贪心策略的核心是“高位优先”，确保每一步选择对结果贡献最大的分支。

### ✨ 解题技巧总结
- **二进制预处理**：将数转换为固定长度的二进制（如32位），统一处理高位到低位。
- **节点计数维护**：插入时`num[u]++`，删除时`num[u]--`，确保查询时能判断分支是否有效。
- **动态开点优化**：仅创建需要的节点（如黑影洞人的`ch[u][v]`动态分配），避免空间浪费。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结构清晰，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合黑影洞人和StupidSeven的思路，采用迭代实现01-Trie，支持插入、删除和查询最大异或值。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    #define MAX_BIT 32  // 处理32位整数（包括符号位）
    #define MAX_NODES 200000 * 32  // 节点数上限（q=2e5，每位一个节点）

    struct Trie {
        int ch[MAX_NODES][2];  // ch[u][0/1]：节点u的0/1子节点
        int num[MAX_NODES];    // num[u]：经过节点u的数的个数
        int val[MAX_NODES];    // val[u]：叶子节点对应的数值（仅叶子有效）
        int cnt;               // 节点计数器

        Trie() : cnt(1) {}     // 根节点初始为1

        void insert(int x) {
            int u = 1;
            for (int i = MAX_BIT; i >= 0; --i) {
                int v = (x >> i) & 1;  // 取第i位（从高位到低位）
                if (!ch[u][v]) ch[u][v] = ++cnt;  // 动态开点
                u = ch[u][v];
                num[u]++;  // 经过的节点计数+1
            }
            val[u] = x;  // 叶子节点记录数值
        }

        void remove(int x) {
            int u = 1;
            for (int i = MAX_BIT; i >= 0; --i) {
                int v = (x >> i) & 1;
                u = ch[u][v];
                num[u]--;  // 经过的节点计数-1
            }
        }

        int query_max(int x) {
            int u = 1;
            for (int i = MAX_BIT; i >= 0; --i) {
                int v = (x >> i) & 1;
                // 优先选择相反位（v^1），若存在且计数>0
                if (ch[u][v ^ 1] && num[ch[u][v ^ 1]]) {
                    u = ch[u][v ^ 1];
                } else {
                    u = ch[u][v];
                }
            }
            return x ^ val[u];  // 异或结果
        }
    };

    int main() {
        int q;
        scanf("%d", &q);
        Trie trie;
        trie.insert(0);  // 初始插入0

        while (q--) {
            char op[2];
            int x;
            scanf("%s%d", op, &x);
            if (op[0] == '+') {
                trie.insert(x);
            } else if (op[0] == '-') {
                trie.remove(x);
            } else {
                printf("%d\n", trie.query_max(x));
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码通过`Trie`结构体实现核心功能。`insert`函数逐位插入数的二进制位，动态创建节点并维护计数；`remove`函数沿插入路径减少计数；`query_max`函数贪心选择相反位分支以最大化异或结果。主函数处理输入输出，初始插入0，符合题目要求。

---
<code_intro_selected>
接下来，剖析优质题解的核心片段，学习不同实现的亮点。
</code_intro_selected>

**题解一：黑影洞人（来源：用户提供题解）**
* **亮点**：代码简洁，变量命名直观（`ch`表示子节点，`num`表示计数），动态开点节省空间。
* **核心代码片段**：
    ```cpp
    void insert(int x) {
        int u = 1;
        for (int i = M; i >= 0; i--) {
            int v = x >> i & 1ll;
            if (!ch[u][v]) ch[u][v] = ++cnt;
            u = ch[u][v];
            num[u]++;
        }
        val[u] = x;
    }
    ```
* **代码解读**：
    > 这段代码实现插入操作。`i`从最高位（M=63）到最低位遍历，`v`取当前位的二进制值。若子节点不存在则新建（`ch[u][v] = ++cnt`），然后移动到子节点并增加计数（`num[u]++`）。叶子节点记录原始数值（`val[u] = x`）。这一步是Trie构建的基础，确保每个数的二进制位被正确存储。
* 💡 **学习笔记**：动态开点避免了预分配大数组的浪费，适合处理大量数据。

**题解二：Zvelig1205（来源：用户提供题解）**
* **亮点**：递归实现Trie，适合理解树结构；引入“垃圾场”（栈回收节点）优化空间。
* **核心代码片段**：
    ```cpp
    void insert(int &i, int k, int dep) {
        if (i == 0) i = ++cnt;
        T[i].siz++;
        if (dep == 31) return;
        insert(T[i].ch[k & 1], k >> 1, dep + 1);
    }
    ```
* **代码解读**：
    > 递归插入函数中，`i`是当前节点的引用（动态开点），`k`是当前处理的数值（右移后），`dep`是当前深度。若节点不存在（`i==0`），则新建节点（`i=++cnt`），并增加计数（`T[i].siz++`）。递归终止条件是深度达到31（处理完所有位）。递归实现更直观展示了Trie树的层级结构。
* 💡 **学习笔记**：递归适合理解树的构建过程，但需注意栈深度（本题处理32位，不会溢出）。

**题解三：StupidSeven（来源：用户提供题解）**
* **亮点**：代码简洁，输入处理高效（`Readint`函数），适合快速上手。
* **核心代码片段**：
    ```cpp
    int Query(int x) {
        int root = 1;
        for (int i = Maxbit; i >= 0; --i) {
            int idx = x >> i & 1;
            if (tree[root][idx ^ 1] && num[tree[root][idx ^ 1]])
                root = tree[root][idx ^ 1];
            else root = tree[root][idx];
        }
        return x ^ val[root];
    }
    ```
* **代码解读**：
    > 查询函数中，`idx`取当前位的值，优先选择相反位（`idx^1`）的分支（若存在且计数>0）。这一步是贪心策略的核心，确保每一步选择对异或结果贡献最大的分支。最后返回当前数与叶子节点值的异或结果。
* 💡 **学习笔记**：贪心选择相反位是最大化异或值的关键，需确保分支计数>0（`num[tree[root][idx^1]]`）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解01-Trie的插入、删除和查询过程，我们设计一个“像素Trie探险”动画，用8位复古风格展示每一步操作！
</visualization_intro>

  * **动画演示主题**：`像素Trie探险——寻找最大异或值`

  * **核心演示内容**：
    展示01-Trie树的构建（插入）、节点计数变化（删除）、贪心路径选择（查询）。例如，插入数8（二进制1000）时，从根节点出发，依次点亮1→0→0→0分支的节点；查询数3（二进制0011）时，贪心选择相反位，路径为0→1→1→1，最终异或结果为11（1011）。

  * **设计思路简述**：
    采用FC红白机风格（8色调色板），节点用小方块表示（0分支蓝色，1分支红色），计数用数字显示在方块上方。插入时节点变亮（计数+1），删除时变暗（计数-1），查询时用黄色箭头高亮路径，配合“叮”音效提示关键操作，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示Trie树（根节点在顶部，0分支左，1分支右），右侧显示控制面板（开始/暂停、单步、速度滑块）。
        - 背景播放8位风格BGM（如《超级玛丽》经典旋律变奏）。

    2.  **插入操作**：
        - 输入数x，转换为32位二进制（如8→`000...1000`）。
        - 从根节点出发，逐位移动：当前位为1则向右（红色分支），为0则向左（蓝色分支）。
        - 经过的节点计数+1（数字变大，颜色变亮），新建节点时弹出小动画（像素星光），伴随“滴”音效。

    3.  **删除操作**：
        - 输入数x，沿插入路径移动。
        - 经过的节点计数-1（数字变小，颜色变暗），若计数变为0，节点边框变灰（不可用），伴随“嗒”音效。

    4.  **查询操作**：
        - 输入数x，开始贪心路径选择。
        - 每一步检查相反位分支：若可用（计数>0），箭头指向该分支（黄色闪烁），伴随“叮”音效；否则指向同一位分支（绿色箭头），伴随“咚”音效。
        - 到达叶子节点时，显示异或结果（x ^ val[u]），播放“胜利”音效（如《魂斗罗》得分音），结果数字放大闪烁。

    5.  **AI自动演示**：
        - 点击“AI演示”，自动执行样例输入（如插入8、9、11、6、1，查询3），展示完整流程，学习者可观察路径选择和计数变化。

  * **旁白提示**：
      - （插入时）“现在插入数8，二进制是1000，我们从根节点出发，依次经过1→0→0→0分支，每个节点计数加1！”
      - （查询时）“当前位是0（x的第3位），我们优先选择1分支（相反位），如果1分支有计数，就能让异或结果的这一位为1，贡献更高值！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到01-Trie的每一步操作，理解计数维护和贪心选择的逻辑，让抽象的算法变得“看得见，听得见”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
01-Trie树是解决异或类问题的利器，除了本题，还能处理以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **最大异或对**：给定数组，求两数异或最大值（直接用01-Trie存储所有数，逐个查询）。
    - **区间异或最大值**：结合可持久化Trie，处理区间查询（如历史版本的Trie树）。
    - **异或和路径**：树上路径异或和的最大值（将路径异或和存入Trie，查询互补值）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4587 [FJOI2016]神秘数**  
        * 🗣️ **推荐理由**：练习前缀和与贪心，理解如何通过构造最小无法表示数，与01-Trie的贪心思想有共通之处。
    2.  **洛谷 P3812 【模板】线性基**  
        * 🗣️ **推荐理由**：线性基是处理异或问题的另一核心数据结构，对比学习可加深对异或性质的理解。
    3.  **洛谷 P4151 [WC2011]最大XOR和路径**  
        * 🗣️ **推荐理由**：结合图论与01-Trie，需要将路径异或和转换为Trie查询，挑战高阶应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了实战经验，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自 堇墨浮华)**：“这道题我花了6个小时调试，一开始没处理初始的0，后来删除操作忘记减计数，导致查询结果错误。”  
> **点评**：初始条件（如本题的初始0）和边界处理（如删除时的计数维护）是常见错误点。调试时可打印关键节点的计数，或用小数据模拟（如样例输入）验证逻辑。

> **参考经验 (来自 Zvelig1205)**：“递归实现对初学者更友好，但要注意动态开点的空间管理，用垃圾场回收节点能避免内存溢出。”  
> **点评**：递归与迭代各有优劣，递归更易理解，迭代更高效。动态开点时，回收无用节点（如本题的垃圾场）是重要的优化技巧。

-----

<conclusion>
通过分析“Vasiliy's Multiset”问题，我们掌握了01-Trie树的核心应用：插入、删除和查询最大异或值。关键在于理解节点计数的维护和贪心路径的选择。希望大家通过练习拓展题，进一步巩固01-Trie的应用！下次见，一起挑战更难的算法题！💪
</conclusion>

-----

---
处理用时：164.83秒
# 题目信息

# Congruence Equation

## 题目描述

Given an integer $ x $ . Your task is to find out how many positive integers $ n $ ( $ 1<=n<=x $ ) satisfy

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF919E/02717f82c41ef4ed609db5d967f659c9784212e1.png) where $ a,b,p $ are all known constants.

## 说明/提示

In the first sample, we can see that $ n=2 $ and $ n=8 $ are possible answers.

## 样例 #1

### 输入

```
2 3 5 8
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 6 7 13
```

### 输出

```
1
```

## 样例 #3

### 输入

```
233 233 10007 1
```

### 输出

```
1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Congruence Equation 深入学习指南 💡

<introduction>
今天我们来一起分析“Congruence Equation”这道数论题目。这道题的关键在于利用数论中的周期性和同余性质，将大范围内的枚举问题转化为小范围的数学推导。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（同余方程求解、费马小定理应用）`

🗣️ **初步分析**：
> 解决这道题的关键在于理解“同余式的周期性”。简单来说，费马小定理告诉我们，当 \( p \) 是质数时，\( a^{p-1} \equiv 1 \pmod{p} \)，这意味着 \( a^n \) 的值每 \( p-1 \) 个数就会重复一次，形成一个“周期”。在本题中，我们需要找到满足 \( na^n \equiv b \pmod{p} \) 的 \( n \)，但直接枚举 \( n \) 到 \( 10^{12} \) 显然不现实，因此需要利用这种周期性，将问题拆解为小范围的枚举和数学推导。
   - **题解思路**：大多数题解通过枚举 \( n \) 模 \( p-1 \) 的余数 \( r \)（即 \( n = k(p-1) + r \)），结合费马小定理将原式子化简为关于 \( r \) 和 \( k \) 的同余方程 \( (r - k)a^r \equiv b \pmod{p} \)，进而求解 \( k \) 的可能值，最终统计 \( n \) 的个数。
   - **核心难点**：如何将原式子转化为可枚举的形式，以及如何计算满足条件的 \( n \) 的个数（需考虑周期性后的解的数量）。
   - **可视化设计思路**：我们将用像素风格动画演示枚举 \( r \) 的过程（如像素块逐格高亮），展示 \( a^r \) 的计算（用数字动态变化），以及 \( k \) 的求解（用箭头指向关键变量）。动画中会用不同颜色标记当前 \( r \)、计算出的 \( k \) 和对应的 \( n \)，并通过音效提示每一步的关键操作（如枚举到有效 \( r \) 时播放“叮”声）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解因逻辑清晰、实现高效被选为优质参考（评分≥4星）：
</eval_intro>

**题解一：来源（Acc_Robin）**
* **点评**：这份题解的思路非常清晰，通过费马小定理将 \( n \) 分解为 \( k(p-1)+r \)，并推导出关键同余方程 \( (r - k)a^r \equiv b \pmod{p} \)。代码中使用快速幂计算逆元，时间复杂度为 \( O(p \log p) \)，适合处理 \( p \) 较大的情况。变量命名简洁（如 `qpow` 表示快速幂），边界条件处理严谨（如 `now = k*(p-1)+r > x` 时跳过），实践价值很高。

**题解二：来源（Chen_Johnny）**
* **点评**：该题解的数学推导过程简洁明了，直接抓住了“枚举 \( r \)”这一核心。代码结构紧凑，通过循环枚举 \( r \) 并计算对应的 \( k \)，最后统计解的个数。关键步骤（如快速幂求逆元）的实现与Acc_Robin的题解一致，但代码更短，适合快速理解核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何利用费马小定理找到 \( a^n \) 的周期性？
    * **分析**：费马小定理指出，当 \( p \) 是质数时，\( a^{p-1} \equiv 1 \pmod{p} \)，因此 \( a^n \) 的值每 \( p-1 \) 个数就会重复。例如，\( a^r \)、\( a^{r+p-1} \)、\( a^{r+2(p-1)} \) 等在模 \( p \) 下的值相同。这意味着我们只需枚举 \( r \in [0, p-2] \) 即可覆盖所有可能的 \( a^n \) 值。
    * 💡 **学习笔记**：费马小定理是处理模幂周期性问题的“钥匙”，它能将大指数问题转化为小范围枚举。

2.  **关键点2**：如何将原式子转化为关于 \( r \) 和 \( k \) 的同余方程？
    * **分析**：设 \( n = k(p-1) + r \)（\( 0 \leq r < p-1 \)），代入原式得 \( (k(p-1)+r)a^{k(p-1)+r} \equiv b \pmod{p} \)。利用费马小定理化简 \( a^{k(p-1)+r} \equiv a^r \pmod{p} \)，式子变为 \( (k(p-1)+r)a^r \equiv b \pmod{p} \)。由于 \( p-1 \equiv -1 \pmod{p} \)，进一步化简为 \( (r - k)a^r \equiv b \pmod{p} \)，从而得到 \( k \equiv r - b \cdot a^{-r} \pmod{p} \)。
    * 💡 **学习笔记**：将 \( n \) 分解为周期部分和余数部分（\( k(p-1)+r \)）是关键，这一步将原问题拆解为可枚举的小问题。

3.  **关键点3**：如何统计满足条件的 \( n \) 的个数？
    * **分析**：对于每个 \( r \)，求出最小的 \( k \) 后，\( n = k(p-1) + r \) 的解会以 \( p(p-1) \) 为周期重复（因为 \( k \) 每增加 \( p \)，\( n \) 增加 \( p(p-1) \)）。因此，统计 \( n \leq x \) 的解的个数即为 \( \left\lfloor \frac{x - n_*}{p(p-1)} \right\rfloor + 1 \)（其中 \( n_* \) 是当前 \( r \) 对应的最小 \( n \)）。
    * 💡 **学习笔记**：周期性是统计解个数的核心，找到周期后只需计算初始解和周期内的数量即可。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将大问题（\( n \leq 10^{12} \)）分解为小问题（枚举 \( r \in [0, p-2] \)），利用数论性质缩小枚举范围。
- **快速幂与逆元**：用快速幂计算 \( a^r \) 和 \( a^{-r} \)（模 \( p \) 下的逆元），这是处理同余方程的关键工具。
- **边界条件处理**：计算 \( n_* \) 时需检查是否超过 \( x \)，避免无效统计。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心C++实现，代码简洁高效，适合直接参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Acc_Robin和Chen_Johnny的题解思路，通过枚举 \( r \) 并计算对应的 \( k \)，最终统计满足条件的 \( n \) 的个数。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;
    typedef long long ll;

    ll qpow(ll a, ll b, ll mod) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }

    int main() {
        ll a, b, p, x;
        cin >> a >> b >> p >> x;
        ll ans = 0;
        for (ll r = 0; r < p - 1; ++r) {
            // 计算 a^r 的逆元：a^{-r} ≡ (a^r)^{p-2} mod p
            ll inv_ar = qpow(qpow(a, r, p), p - 2, p);
            // 计算 (r - k) ≡ b * a^{-r} mod p → k ≡ r - b * a^{-r} mod p
            ll k = (r - b * inv_ar % p + p) % p;
            // 计算当前r对应的最小n：n = k*(p-1) + r
            ll n_min = k * (p - 1) + r;
            if (n_min > x) continue; // 超过x则跳过
            // 统计周期p(p-1)内的解的个数
            ans += (x - n_min) / (p * (p - 1)) + 1;
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先定义了快速幂函数 `qpow` 用于计算模幂和逆元。主函数中，通过枚举 \( r \)（范围 \( 0 \leq r < p-1 \)），计算 \( a^r \) 的逆元，进而求出 \( k \) 的值。然后计算当前 \( r \) 对应的最小 \( n \)（\( n_{\text{min}} \)），若 \( n_{\text{min}} \leq x \)，则统计以 \( p(p-1) \) 为周期的解的个数。最终输出所有 \( r \) 对应的解的总数。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和关键思路。
</code_intro_selected>

**题解一：来源（Acc_Robin）**
* **亮点**：代码结构清晰，利用命名空间封装逻辑，快速幂函数简洁高效。
* **核心代码片段**：
    ```cpp
    int qpow(int a,int b=p-2){
        int res=1;
        for(;b;b>>=1,a=a*a%p)if(b&1)res=res*a%p;
        return res;
    }
    void work(){
        cin>>a>>b>>p>>x;
        for(int r=0,f,k,now;r<p-1;r++){
            f=b*qpow(qpow(a,r))%p;
            k=(r-f+p)%p;
            if((now=k*(p-1)+r)>x)continue;
            ans+=(x-now)/(p*(p-1))+1;
        }
        cout<<ans;
    }
    ```
* **代码解读**：
    > `qpow` 函数是快速幂实现，默认计算逆元（\( b=p-2 \) 对应费马小定理求逆元）。在 `work` 函数中，枚举 \( r \)，计算 \( f = b \cdot a^{-r} \pmod{p} \)，然后 \( k = (r - f) \pmod{p} \)。`now` 是当前 \( r \) 对应的最小 \( n \)，若 \( now \leq x \)，则统计周期内的解的个数。这段代码的关键是通过快速幂高效计算逆元，并利用模运算处理 \( k \) 的取值。
* 💡 **学习笔记**：快速幂是数论题的“基础工具”，默认参数设计（如求逆元时的 \( b=p-2 \)）能简化代码。

**题解二：来源（Chen_Johnny）**
* **亮点**：代码极简，直接抓住核心逻辑，适合快速理解。
* **核心代码片段**：
    ```cpp
    ll qpow (ll a, ll b) {
        ll ans = 1;
        while (b) {
            if(b % 2 == 1) ans = ans * a % mod;
            b >>= 1; a = a * a % mod;
        }
        return ans % mod;
    }
    int main() {
        cin >> a >> b >> mod >> x;
        for (int r = 0, f, k, now; r < mod - 1; r ++) {
            f = b * qpow (qpow (a, r), mod - 2) % mod;
            k = (r - f + mod) % mod;
            if ((now = k * (mod - 1) + r) > x) continue;
            ans += (x - now) / (mod * (mod - 1)) + 1;
        }
        cout << ans;
    }
    ```
* **代码解读**：
    > `qpow` 函数计算模幂，内层 `qpow(a, r)` 计算 \( a^r \)，外层 `qpow(..., mod-2)` 计算其逆元。通过枚举 \( r \)，计算 \( f = b \cdot a^{-r} \pmod{\text{mod}} \)，进而得到 \( k \)。`now` 是当前 \( r \) 对应的最小 \( n \)，若不超过 \( x \) 则统计解的个数。这段代码的关键是通过嵌套快速幂调用实现逆元计算，逻辑简洁明了。
* 💡 **学习笔记**：嵌套快速幂调用是计算 \( a^{-r} \) 的常用方法，需注意模运算的正确性。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举 \( r \) 并计算 \( n \) 的过程，我们设计了一个“像素数论探险”动画，用8位像素风格展示算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素数论探险——寻找符合条件的n`

  * **核心演示内容**：展示枚举 \( r \)（0到 \( p-2 \)）的过程，计算 \( a^r \)、其逆元、\( k \) 以及对应的 \( n_{\text{min}} \)，并统计周期内的解的个数。

  * **设计思路简述**：采用8位像素风格（如FC游戏的方块和配色），让学习者在轻松的氛围中观察算法的每一步。关键操作（如枚举 \( r \)、计算逆元）用像素动画和音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕左侧显示一个像素网格（每行代表一个 \( r \)，从0到 \( p-2 \)），右侧显示当前 \( r \)、\( a^r \)、逆元、\( k \)、\( n_{\text{min}} \) 等变量的数值。
          - 控制面板包含“单步”“自动播放”按钮和速度滑块（1倍速到10倍速）。

    2.  **枚举 \( r \) 的过程**：
          - 每点击“单步”或自动播放时，当前 \( r \) 对应的像素块高亮（如从绿色变为黄色），伴随“滴答”音效。
          - 右侧动态计算 \( a^r \)（用像素数字逐个显示，如 \( a=2, r=3 \) 时显示 \( 2^3=8 \)）。

    3.  **计算逆元与 \( k \)**：
          - 计算 \( a^{-r} \) 时，像素块显示“逆元计算中...”，完成后显示结果（如 \( 8^{-1} \mod 5 = 2 \)）。
          - 计算 \( k = (r - b \cdot a^{-r}) \mod p \) 时，用箭头连接 \( r \)、\( b \cdot a^{-r} \) 和 \( k \)，伴随“叮”的音效。

    4.  **统计 \( n \) 的个数**：
          - 计算 \( n_{\text{min}} = k \cdot (p-1) + r \) 后，若 \( n_{\text{min}} \leq x \)，则显示一个像素化的“√”，并计算周期 \( p(p-1) \) 内的解的个数（如 \( x=100 \)，\( n_{\text{min}}=2 \)，周期=20，则解为 \( 2, 22, 42, 62, 82 \)，共5个）。
          - 每个有效 \( n \) 用像素点从 \( n_{\text{min}} \) 开始，每隔 \( p(p-1) \) 跳跃显示，伴随“跳跃”音效。

    5.  **结束与总结**：
          - 所有 \( r \) 枚举完成后，总解数用大字体显示，播放“胜利”音效（如FC游戏的通关音乐）。

  * **旁白提示**：
      * “现在枚举 \( r=0 \)，计算 \( a^0=1 \)，逆元是1的逆元还是1哦～”
      * “计算 \( k \) 时要记得模 \( p \)，否则可能得到负数，这里用 \( (r - f + p) \% p \) 确保结果非负～”
      * “看！这个 \( n_{\text{min}} \) 小于 \( x \)，所以周期内有这么多解～”

<visualization_conclusion>
通过这个像素动画，我们不仅能“看”到 \( r \) 的枚举过程，还能直观理解 \( k \) 和 \( n \) 的计算逻辑，大大降低了数论问题的抽象感！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的解法后，我们可以进一步思考数论中同余方程的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的核心是利用周期性将大问题分解为小问题，这种思路还适用于：
        - 求解 \( a^n \equiv c \pmod{p} \)（BSGS算法）。
        - 统计满足 \( f(n) \equiv 0 \pmod{p} \) 的 \( n \) 的个数（其中 \( f(n) \) 是周期函数）。
        - 处理涉及模幂的计数问题（如排列组合中的模运算）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1869** - `[FJOI2005] 火星地图`
          * 🗣️ **推荐理由**：这道题需要利用模运算的周期性统计符合条件的坐标，与本题思路类似，适合巩固周期性分析的能力。
    2.  **洛谷 P3846** - `[TJOI2007] 可爱的质数`
          * 🗣️ **推荐理由**：此题考察BSGS算法（大步小步算法）求解离散对数，与本题的逆元计算和周期性分析密切相关，能提升数论问题的综合处理能力。
    3.  **洛谷 P5318** - `[BJOI2019] 勘破神机`
          * 🗣️ **推荐理由**：此题涉及模幂的周期性和递推数列的模运算，需要结合动态规划和数论知识，适合高阶数论学习者挑战。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自 Acc_Robin)**：“在计算 \( k \) 时，一开始忘记加 \( p \) 再取模，导致 \( k \) 出现负数，后来通过打印中间变量发现了问题。”

**点评**：模运算中处理负数是常见的坑！在计算 \( (r - f) \) 时，加上 \( p \) 再取模可以确保结果非负。这提醒我们，在编写模运算代码时，要特别注意边界情况（如结果为负数），并通过打印中间变量调试。

-----

<conclusion>
本次关于“Congruence Equation”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握数论中同余方程的求解技巧，尤其是利用周期性分解问题的思路。记住，数论问题的关键在于观察规律、分解问题，多练习类似题目会让你更熟练！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：427.18秒
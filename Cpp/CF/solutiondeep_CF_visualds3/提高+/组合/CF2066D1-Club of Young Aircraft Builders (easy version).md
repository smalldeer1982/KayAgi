# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果


### Kay的C++算法解析：Club of Young Aircraft Builders (easy version) 深入学习指南
---

**<introduction>**
今天我们分析一道有趣的组合计数问题——Club of Young Aircraft Builders（简单版）。这道题考察如何利用组合数学或动态规划解决约束条件下的计数问题。本指南将帮助大家理解核心思路，掌握两种解法，并通过像素动画直观感受算法过程。
</introduction>

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：`组合数学应用`（也可用动态规划）

🗣️ **初步分析**：
> 本题的关键在于**约束转化**和**组合建模**。想象每位居民在发射飞机时，都像是在一个像素游戏中收集金币：只有在前c个"金币位"中才能放置自己的飞机（否则会被判定为违规）。通过这种转化，问题简化为经典的组合选择问题。

- **核心思路**：顶层居民必须发射恰好c架飞机（因他只能看到自己的飞机）。其余n-1层居民共享(n-1)×c个"机会位"，需从中选出m-c个位置放置飞机
- **难点对比**：
  - **组合解法**：需理解"机会位"的物理意义（每层前c个可见位）
  - **DP解法**：需设计三维状态转移（层数×总飞机数×当前层发射数）
- **可视化设计**：
  - 采用**8位像素网格**：每层显示c个像素块（代表机会位）
  - **动态着色**：选中位置亮绿色，未选中灰色
  - **音效设计**：选择时播放"金币收集"音效，完成时播放"关卡通过"音效

---

### 2. 精选优质题解参考

<eval_intro>
以下是综合思路清晰度、代码质量和算法效率筛选的优质题解：
</eval_intro>

**题解一：xyvsvg（组合解法）**
* **点评**：思路直击本质，将复杂约束转化为组合数C((n-1)c, m-c)。代码简洁高效（O(1)查询），预处理阶乘和逆元规范合理。特别亮点是省略冗余DP，直接运用组合恒等式，实践价值高。

**题解二：2022dyx（组合解法）**
* **点评**：同样给出组合公式，但增加了详细推导过程。代码中预处理范围精确，变量命名规范（fac/inv）。亮点在于完整证明了方案与组合选择的双射关系，加深理解。

**题解三：_Kamisato_Ayaka_（DP解法）**
* **点评**：提供DP视角的通用解法，状态定义清晰（dp[i][j]表示i层发射j架）。代码中组合数预处理规范，但三重循环在nm较大时效率低。亮点是展示了组合数在DP中的桥梁作用。

---

### 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键点：
</difficulty_intro>

1.  **约束条件转化**  
    * **分析**：顶层必须发射c架（约束1），其他层发射需在"前c可见位"（约束2）。优质题解通过"机会位"模型统一约束
    * 💡 **学习笔记**：复杂约束往往隐含组合结构

2.  **组合模型建立**  
    * **分析**：将(n-1)×c个机会位视为待选区，m-c次选择视为放置操作。组合数C((n-1)c, m-c)即选择方式数
    * 💡 **学习笔记**：组合恒等式可避免重复计数

3.  **DP状态设计**  
    * **分析**：dp[i][j] = Σdp[i-1][j-k]×C(c,k), k∈[0,min(c,j)]。关键是用组合数C(c,k)表示第i层发射k架的选择数
    * 💡 **学习笔记**：DP是组合计数的通用但低效解法

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧A（问题转化）**：将物理约束转化为数学模型（如机会位）
- **技巧B（组合优化）**：优先寻找组合公式避免高复杂度DP
- **技巧C（边界处理）**：特别注意m-c∉[0,(n-1)c]时答案为0
- **技巧D（模运算）**：大组合数计算需预处理阶乘逆元

---

### 4. C++核心代码实现赏析

<code_intro_overall>
#### 通用组合解法实现（推荐）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9+7, N = 1e4+5;

int fac[N], inv[N], finv[N];
void init() {
    fac[0] = finv[0] = 1;
    // 预处理阶乘和逆元
    for(int i=1; i<N; i++) fac[i] = 1LL*fac[i-1]*i%mod;
    inv[1] = 1;
    for(int i=2; i<N; i++) 
        inv[i] = 1LL*(mod-mod/i)*inv[mod%i]%mod;
    for(int i=1; i<N; i++)
        finv[i] = 1LL*finv[i-1]*inv[i]%mod;
}

int C(int n, int m) {
    if(m<0 || m>n) return 0;
    return 1LL*fac[n]*finv[m]%mod*finv[n-m]%mod;
}

void solve() {
    int n, c, m;
    cin >> n >> c >> m;
    // 跳过输入（本题全0）
    for(int i=0; i<m; i++) cin.ignore(10, ' ');
    
    // 核心公式
    cout << C((n-1)*c, m-c) << '\n';
}

int main() {
    init();
    int T; cin >> T;
    while(T--) solve();
}
```

**代码解读概要**：
1. 预处理阶乘(fac)和阶乘逆元(finv)实现O(1)组合数查询
2. `C((n-1)*c, m-c)`直接计算方案数
3. 边界处理：当m-c∉[0,(n-1)c]时C()返回0
</code_intro_overall>

<code_intro_selected>
#### 题解片段赏析
**xyvsvg的亮点实现**  
```cpp
// 组合数计算（同通用解法）
cout<<C(n*c-c,m-c)<<endl; 
```
**学习笔记**：简洁即美，直击问题本质

**2022dyx的边界处理**  
```cpp
if(m<0 || m>n) return 0; // 边界检查
```
**学习笔记**：健壮代码必须处理非法输入

**_Kamisato_Ayaka_的DP转移**  
```cpp
for(int k=0; k<=min(j,C); k++)
    dp[i][j] = (dp[i][j] + C(C,k)*dp[i-1][j-k]) % mod;
```
**学习笔记**：组合数在DP中充当转移系数
---

### 5. 算法可视化：像素动画演示（核心部分）

<visualization_intro>
我们设计了一个**"飞机大亨"像素游戏**，通过8位风格动画演示组合选择过程：
</visualization_intro>

* **主题**：复古像素网格中的机会选择游戏
* **核心演示**：从(n-1)×c网格中选m-c个位置

* **动画设计**：
  1. **初始化**（FC游戏风格）：
     - 显示(n-1)行×c列像素网格（每行代表一层）
     - 控制面板：开始/暂停/步进按钮+速度滑块
     - 播放8-bit背景音乐（循环）
  
  2. **选择动画**：
     ```python
     # 伪代码逻辑
     for 选中位置 in 随机排列(所有位置)[:m-c]:
         该位置像素亮绿色闪烁
         播放"金币收集"音效(300Hz, 0.2s)
         更新计数器：已选数++
     ```
  3. **动态效果**：
     - **当前操作**：红色边框高亮当前选择位置
     - **进度显示**：顶部标签显示"已选: X/Y"
     - **完成特效**：当选择完成时，网格绽放烟花特效+播放胜利音效

  4. **交互功能**：
     - **步进模式**：按空格键单步执行选择
     - **自动演示**：AI自动完成选择（速度可调）
     - **重置**：按R键重新开始动画

* **设计意义**：
  - 网格直观展示(n-1)c个机会位
  - 动态选择过程体现组合无序性
  - 音效强化操作反馈（选择/完成）

---

### 6. 拓展练习与相似问题思考

<similar_problems_intro>
组合计数思想可应用于以下场景：
</similar_problems_intro>

1. **多重集合排列**：受限条件下的排列问题
2. **分组分配问题**：带约束的资源分配
3. **二项式反演**：条件计数的高级技巧

**洛谷练习推荐**：
1. **P2638 安全系统**  
   🗣️ 同类组合模型，巩固"机会位"思想
   
2. **P2822 组合数问题**  
   🗣️ 组合数前缀和应用，提升预处理技能
   
3. **P3197 越狱**  
   🗣️ 带约束的计数问题，训练组合思维

---

### 7. 学习心得与经验分享

<insights_intro>
题解中的经验总结：
</insights_intro>

> **经验一**（2022dyx）：  
> "组合解法的关键是发现顶层必须发射c架的隐藏约束"
> 
> **点评**：这提醒我们仔细挖掘题目中的**强约束条件**，它们往往是突破口

> **经验二**（_Kamisato_Ayaka_）：  
> "DP解法要注意j-k可能为负的边界情况"
>
> **点评**：DP实现中**边界处理**是常见错误源，建议先写约束条件再编码

---

<conclusion>
通过本指南，大家应掌握了组合计数和DP两种解法，并理解了其背后的直观意义。记住：将复杂约束转化为数学模型是算法设计的核心能力。下次我们将挑战更难的版本！💪
</conclusion>

---
处理用时：158.23秒
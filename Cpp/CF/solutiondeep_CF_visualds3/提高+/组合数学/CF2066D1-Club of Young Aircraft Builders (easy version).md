# 题目信息

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0```

### 输出

```
6
190```

# AI分析结果


# 💡 Kay的C++算法解析：Club of Young Aircraft Builders (easy version) 深入学习指南 💡

**引言**  
今天我们一起分析这道关于纸飞机发射的编程题。本指南将帮助你理解题目核心、掌握组合数学解法，并通过像素动画直观感受算法过程。让我们一起探索这个有趣的计数问题！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：组合数学（直接计数）

🗣️ **初步分析**：  
> 解决本题的关键在于识别问题中的组合结构。想象每层居民有c个"发射位"（他们只能在前c次发射机会中行动），而顶层居民必须发射恰好c架飞机（因为他只能看到自己的飞机）。其他居民共同发射剩余m-c架飞机，相当于在(n-1)*c个发射位中选择m-c个位置。  
> - **核心难点**：理解顶层居民的特殊性及发射位的组合意义  
> - **可视化设计**：用像素网格表示发射位，绿色方块表示选择的发射位置  
> - **复古元素**：8-bit音效（选择时"叮"声，完成时胜利旋律），网格按层分区显示  

---

## 2. 精选优质题解参考

**题解一：CReatiQ（组合意义）**  
* **点评**：直击问题本质，将复杂场景转化为简洁组合模型。通过顶层分离和发射位概念，完美避开复杂DP，代码实现仅需组合数计算。亮点在于双解呈现（组合+DP思路），启发多角度思考。  

**题解二：2022dyx（组合证明）**  
* **点评**：给出严谨组合证明，阐明"为什么是C((n-1)c, m-c)"。代码中组合数计算准确（注意n*c-m的转化），边界处理完整。虽未处理输入数据，但核心逻辑完全正确。  

**题解三：xyvsvg（代码实现）**  
* **点评**：提供完整预处理阶乘逆元的组合数模板，lambda表达式封装使代码清晰。边界检查(m-c∈[0,(n-1)c])体现健壮性，消耗输入数据的处理方式简洁合理。  

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题需突破三个关键点，结合优质题解方案如下：  
</difficulty_intro>  

1. **顶层居民的特殊性**  
   * **分析**：顶层居民只能看到自己的飞机，故必须发射恰好c架（满足≥c且≤c）。其他居民的飞机对他不可见，这分离了问题（优质题解均利用此特性）  
   * 💡 **学习笔记**：复杂问题中，寻找特殊约束作为突破口  

2. **发射位置的可视化建模**  
   * **分析**：每个非顶层居民有c个专属发射位（他们只能在这些位置行动）。将物理发射序列转化为(n-1)*c个独立选择位，是组合解法的核心洞见  
   * 💡 **学习笔记**：将时序问题转化为空间组合是重要技巧  

3. **组合模型的边界处理**  
   * **分析**：当m-c∉[0,(n-1)c]时无解。题解xyvsvg用if-else处理，2022dyx通过组合数定义隐式处理  
   * 💡 **学习笔记**：任何组合模型都要验证值域有效性  

### ✨ 解题技巧总结  
<summary_best_practices>  
通过本题提炼的通用技巧：  
</summary_best_practices>  
- **问题分解法**：分离特殊元素（顶层）与普通元素  
- **时空转换技巧**：将时序依赖转化为空间组合  
- **边界防御编程**：组合数计算前必须验证参数范围  
- **预处理优化**：阶乘逆元预处理使O(1)组合查询成为可能  

---

## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是综合优质题解的精炼实现，包含组合数学的核心应用：  
</code_intro_overall>  

**本题通用核心C++实现参考**  
* **说明**：基于xyvsvg和2022dyx的代码优化，完整处理边界条件  
* **完整核心代码**：  
```cpp
#include <iostream>
using namespace std;
const int mod = 1e9+7, N = 1e4 + 10;

int fac[N], finv[N];

void init() {
    fac[0] = 1;
    for (int i = 1; i < N; i++) 
        fac[i] = 1LL * fac[i-1] * i % mod;
        
    finv[N-1] = 1; 
    for (int i = N-2, inv; i >= 0; i--) {
        inv = 1LL * fac[i+1] * fac[i] % mod; // Fermat小定理求逆元
        finv[i] = 1LL * finv[i+1] * inv % mod * fac[i] % mod;
    }
}

int C(int n, int m) {
    if (m < 0 || m > n) return 0;
    return 1LL * fac[n] * finv[m] % mod * finv[n-m] % mod;
}

int main() {
    init();
    int T, n, c, m, tmp;
    cin >> T;
    while (T--) {
        cin >> n >> c >> m;
        for (int i = 0; i < m; i++) cin >> tmp; // 消耗输入
        
        int total_slots = (n-1) * c;
        int needed = m - c;
        if (needed < 0 || needed > total_slots) cout << "0\n";
        else cout << C(total_slots, needed) << "\n";
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 预处理阶乘(fac)和阶乘逆元(finv)实现O(1)组合查询  
  2. 主循环消耗无用输入（因简单版全为0）  
  3. 计算有效槽位total_slots = (n-1)*c  
  4. 边界检查后直接输出组合数C(total_slots, m-c)  

---

## 5. 算法可视化：像素动画演示

<visualization_intro>  
**"像素飞行编年史"**动画方案带你直观理解组合选择过程：  
</visualization_intro>  

* **主题**：8-bit风格网格选择动画  
* **核心演示**：在(n-1)*c网格中动态选择m-c个发射位  

### 设计细节  
1. **场景构建**：  
   - 左侧：n层像素楼（顶层标红）  
   - 右侧：(n-1)行×c列网格（代表发射位）  
   - 控制面板：速度滑块/单步/暂停/重置  

2. **初始化阶段**：  
   - 播放8-bit启动音效  
   - 顶层自动填充c个绿色方块（不可操作）  
   - 旁白："顶层已锁定c架飞机！"  

3. **核心选择过程**：  
   ```mermaid
   graph LR
   A[遍历网格] --> B{是否选中？}
   B -->|是| C[方块变绿+播放'叮'声]
   B -->|否| D[方块变灰]
   C --> E[已选数+1]
   E --> F{已选=m-c？}
   F -->|是| G[胜利动画]
   ```  
   - **视觉反馈**：当前单元格高亮闪烁，选中/跳过分别用绿/灰区分  
   - **音效设计**：  
     - 选择：NES风格短促"叮"声  
     - 跳过：低沉"噗"声  
     - 错误：警报音（尝试超选时）  

4. **胜利状态**：  
   - 所有选中格脉冲闪烁  
   - 播放《超级玛丽》通关音乐  
   - 显示公式：C({{(n-1)*c}}, {{m-c}}) = {{结果}}  

5. **游戏化元素**：  
   - 每选1格得10分，连选额外+5分  
   - 速度挑战模式：不同速度档位对应分数倍率  

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
掌握组合模型后，可挑战以下相似问题：  
</similar_problems_intro>  

1. **洛谷 P2638 - 安全系统**  
   🗣️ **推荐理由**：巩固可重复组合问题，扩展隔板法应用  

2. **洛谷 P2822 - 组合数问题**  
   🗣️ **推荐理由**：训练组合数预处理技巧，掌握二维前缀和优化  

3. **洛谷  P1246 - 编码**  
   🗣️ **推荐理由**：将组合数应用于字典序编号，强化模型转化能力  

---

## 7. 学习心得与经验分享  

> **关键心得**：  
> "组合解法源于对问题约束的深度抽象——将物理时序转化为静态选择位，避免复杂状态转移。" —— Kay  
> 
> **调试经验**：  
> 当n=3,c=2,m=4时若结果≠6，立即检查：  
> 1. 顶层是否强制c架  
> 2. 组合数参数是否为(4,2)  
> 3. 边界处理是否遗漏m<c情况  

---

**结语**  
通过本指南，你不仅掌握了本题的组合解法，更学会了将复杂约束转化为简洁数学模型的思维方法。记住，好的算法设计始于对问题的深刻洞察！下次遇到类似计数问题时，不妨先问自己："是否存在优雅的组合解释？" Keep coding, keep flying! ✈️

---
处理用时：359.88秒
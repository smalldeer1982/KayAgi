# 题目信息

# Enlarge GCD

## 题目描述

Mr. F has $ n $ positive integers, $ a_1, a_2, \ldots, a_n $ .

He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.

But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.

Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.

## 说明/提示

In the first example, the greatest common divisor is $ 1 $ in the beginning. You can remove $ 1 $ so that the greatest common divisor is enlarged to $ 2 $ . The answer is $ 1 $ .

In the second example, the greatest common divisor is $ 3 $ in the beginning. You can remove $ 6 $ and $ 9 $ so that the greatest common divisor is enlarged to $ 15 $ . There is no solution which removes only one integer. So the answer is $ 2 $ .

In the third example, there is no solution to enlarge the greatest common divisor. So the answer is $ -1 $ .

## 样例 #1

### 输入

```
3
1 2 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4
6 9 15 30
```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 1 1
```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Enlarge GCD 深入学习指南 💡

<introduction>
今天我们来一起分析“Enlarge GCD”这道C++编程题。这道题需要我们通过删除最少的数，让剩余数的最大公约数（GCD）比原来的更大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质因数分解与筛法应用）`

🗣️ **初步分析**：
解决“Enlarge GCD”这道题，关键在于理解如何通过质因数分解和筛法统计，找到能最大化剩余数GCD的质数。简单来说，质因数分解是将一个数拆解成质数的乘积，而筛法则是高效找出所有质数的方法，就像用“筛子”过滤出符合条件的数。在本题中，我们需要先消除原GCD的影响，再通过筛法统计每个质数的倍数出现次数，从而找到最优解。

- **题解思路**：首先计算所有数的GCD（记为d），将每个数除以d，得到新数组（此时新数组的GCD为1）。我们需要找到一个质数p，使得新数组中能被p整除的数最多（记为cnt），则最少删除数为n - cnt。若所有质数的cnt为0或n，输出-1。
- **核心难点**：如何高效统计每个质数的倍数出现次数？如何处理边界情况（如新数组全为1）？
- **可视化设计**：采用8位像素风格，用不同颜色的像素块表示原数组、除以d后的新数组，以及筛法过程中被选中的质数p。动画中，当处理质数p时，所有能被p整除的数会高亮（如绿色），并统计数量，最终展示最小删除数的计算过程。音效方面，选中质数时播放“叮”声，统计完成时播放“滴”声。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者Acc_Robin（赞：9）**
* **点评**：此题解思路非常清晰，通过先计算原GCD并将数组归一化，再利用筛法统计质数的倍数次数，逻辑简洁高效。代码中变量命名规范（如`cnt`统计质数倍数次数），边界处理严谨（如判断`ans==0`输出-1）。算法复杂度分析准确（O(m log log m)），实践价值高，适合竞赛参考。

**题解二：作者Npse_D（赞：8）**
* **点评**：此题解巧妙利用埃筛特性，直接枚举每个数作为质数候选，统计其倍数次数。代码简洁（如用`vis`数组标记已处理的数），核心逻辑（统计`h`）直观易懂。特别提到“变化后的GCD必为质数”的反证法，帮助理解问题本质，启发性强。

**题解三：作者kimi0705（赞：1）**
* **点评**：此题解步骤明确，从计算原GCD到归一化数组，再到筛法统计，每一步都有清晰注释。代码风格工整（如使用`vector`存储数组），关键逻辑（如`ans = min(ans, n - Cnt)`）直接体现解题目标，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何消除原GCD的影响？
    * **分析**：原数组的GCD为d，若直接处理原数组，无法找到更大的GCD（因为所有数都是d的倍数）。优质题解中，通过将每个数除以d，得到新数组（GCD为1），问题转化为让新数组的GCD>1，这是解题的关键一步。
    * 💡 **学习笔记**：归一化处理能简化问题，将复杂问题转化为更易处理的形式。

2.  **关键点2**：如何高效统计质数的倍数次数？
    * **分析**：直接枚举每个数的质因数会超时（复杂度O(n√a)）。优质题解采用埃氏筛法：枚举每个质数p，统计新数组中p的倍数出现次数（即`cnt[j*i]`累加）。筛法的复杂度为O(m log log m)（m为新数组最大值），高效可行。
    * 💡 **学习笔记**：筛法是统计质数及其倍数的“利器”，能大幅降低时间复杂度。

3.  **关键点3**：如何处理边界情况？
    * **分析**：若新数组全为1（如原数组全为d），则无法找到更大的GCD，需输出-1。优质题解通过判断`ans`是否仍为初始极大值（如`ans==INT_MAX`）来处理此情况。
    * 💡 **学习笔记**：边界条件（如全1数组）需特别注意，避免遗漏导致错误。

### ✨ 解题技巧总结
- **技巧A（问题归一化）**：将原数组除以其GCD，简化问题为寻找新数组的GCD>1，是解决本题的核心技巧。
- **技巧B（筛法统计）**：利用埃氏筛法高效统计每个质数的倍数出现次数，避免暴力枚举质因数的高复杂度。
- **技巧C（边界特判）**：处理新数组全为1的情况，确保输出-1的正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用归一化处理和埃氏筛法统计质数倍数次数，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 3e5 + 5;
    const int MAXM = 1.5e7 + 5;

    int a[MAXN], cnt[MAXM], vis[MAXM];
    int n, g, mx, ans;

    void sieve(int max_num) {
        for (int i = 2; i <= max_num; ++i) {
            if (!vis[i]) { // i是质数
                for (int j = i; j <= max_num; j += i) {
                    vis[j] = 1; // 标记i的倍数
                    cnt[i] += cnt[j]; // 统计i的倍数出现次数
                }
                if (cnt[i] > 0) ans = min(ans, n - cnt[i]);
            }
        }
    }

    int main() {
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            g = __gcd(g, a[i]); // 计算原数组GCD
        }
        for (int i = 0; i < n; ++i) {
            a[i] /= g; // 归一化处理
            cnt[a[i]]++; // 统计归一化后各数的出现次数
            mx = max(mx, a[i]);
        }
        ans = n; // 初始化为n（最多删除n个数）
        sieve(mx);
        cout << (ans == n ? -1 : ans) << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先计算原数组的GCD（`g`），然后将每个数除以`g`，统计归一化后各数的出现次数（`cnt`数组）。通过埃氏筛法（`sieve`函数）枚举每个质数`i`，统计其倍数的出现次数（`cnt[i]`），并计算需要删除的数（`n - cnt[i]`），最终取最小值。若所有质数的`cnt[i]`为0，输出-1。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者Acc_Robin**
* **亮点**：巧妙利用筛法统计质数倍数次数，代码简洁高效，边界处理严谨（如`ans==0`时输出-1）。
* **核心代码片段**：
    ```cpp
    void sieve(int n) {
        np[0] = np[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (!np[i]) p[++cnt] = i;
            for (int j = 1; j <= cnt && p[j] * i <= n; j++) {
                np[i * p[j]] = 1;
                if (i % p[j] == 0) break;
            }
        }
    }
    void work() {
        // ... 输入处理 ...
        for (int i = 1; i <= cnt; i++) {
            int res = 0;
            for (int j = 1; p[i] * j <= mx; j++) res += buc[p[i] * j];
            if (res) ans = max(ans, res);
        }
        printf("%d\n", ans == 0 ? -1 : n - ans);
    }
    ```
* **代码解读**：
    > `sieve`函数是埃氏筛法的实现，标记非质数（`np`数组）并记录质数列表（`p`数组）。`work`函数中，遍历所有质数`p[i]`，统计其倍数的出现次数（`res`），并更新最大保留数（`ans`）。最后输出`n - ans`（最少删除数）。这里的`max(ans, res)`确保找到保留数最多的质数，从而删除数最少。
* 💡 **学习笔记**：埃氏筛法不仅能筛质数，还能高效统计质数的倍数次数，是解决此类问题的关键工具。

**题解二：作者Npse_D**
* **亮点**：直接枚举每个数作为质数候选，利用`vis`数组避免重复统计，代码简洁易懂。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= inf; i++) {
        int h = 0;
        if (!vis[i]) for (int j = i; j <= inf; j += i) vis[j] = 1, h += c[j];
        t = min(t, n - h);
    }
    ```
* **代码解读**：
    > 这段代码中，`i`从2到最大值（`inf`）枚举，若`i`未被标记（是质数），则统计其所有倍数的出现次数（`h`），并计算需要删除的数（`n - h`）。`vis[j] = 1`标记`i`的倍数，避免重复处理。`t`记录最小删除数。
* 💡 **学习笔记**：枚举每个数作为质数候选时，通过标记倍数避免重复统计，是优化时间复杂度的关键。

**题解三：作者kimi0705**
* **亮点**：代码结构清晰，步骤明确，适合新手学习。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= Maxx; i++) {
        int Cnt = 0;
        if (!vis[i]) {
            for (int j = i; j <= Maxx; j += i) {
                vis[j] = 1; // 筛质数
                Cnt += cnt[j]; // 统计
            }
            ans = min(ans, n - Cnt);
        }
    }
    ```
* **代码解读**：
    > `i`遍历2到最大值（`Maxx`），若`i`未被标记（是质数），则统计其所有倍数的出现次数（`Cnt`），并计算需要删除的数（`n - Cnt`）。`vis[j] = 1`标记`i`的倍数，确保每个数只被处理一次。
* 💡 **学习笔记**：通过筛法标记已处理的数，避免重复计算，是提高效率的重要技巧。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“筛法统计质数倍数次数”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素质数大冒险`（结合复古游戏元素，如FC风格的网格和角色）

  * **核心演示内容**：展示归一化后的数组，通过筛法找到质数p，统计其倍数的出现次数，并计算最少删除数。

  * **设计思路简述**：采用8位像素风（如红、绿、蓝三色调）营造轻松氛围；用不同颜色的像素块表示原数组（蓝色）、归一化后的数组（黄色）、质数p（红色）及其倍数（绿色）。音效方面，选中质数时播放“叮”声，统计完成时播放“滴”声，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是像素网格（表示归一化后的数组，每个格子显示数值），右侧是控制面板（包含“开始/暂停”“单步”“重置”按钮，速度滑块）。
          * 播放8位风格的背景音乐（如《超级玛丽》的轻快旋律）。

    2.  **归一化处理**：
          * 原数组的每个数（蓝色像素块）被除以原GCD（d），变为黄色像素块（归一化后的数），伴随“唰”的音效。

    3.  **筛法统计**：
          * 从i=2开始枚举，当前i（红色像素箭头）移动到i的位置。
          * 若i是质数（未被标记），则i的像素块闪烁（红色），播放“叮”声。
          * 遍历i的所有倍数（j=i, 2i, 3i...），每个倍数的像素块变为绿色（表示被选中），并累加统计次数（屏幕上方显示“当前质数p=i，统计次数=Cnt”）。
          * 统计完成后，计算删除数（n - Cnt），并更新最小值（屏幕右侧显示“最少删除数=ans”）。

    4.  **结果展示**：
          * 若找到有效ans，绿色像素块组成的路径闪烁，播放“胜利”音效（如《超级玛丽》的通关音乐）。
          * 若未找到（ans=n），所有像素块变为灰色，播放“提示”音效（如短“嘟”声），并显示“-1”。

  * **旁白提示**：
      * （归一化时）“看！每个数都除以了原GCD，现在它们的GCD变成1啦～”
      * （筛法时）“现在处理质数i=2，所有2的倍数会被选中哦～”
      * （统计时）“当前有Cnt个数是2的倍数，需要删除n - Cnt个数～”

<visualization_conclusion>
通过这样一个融合像素艺术和复古游戏元素的动画，我们不仅能清晰看到筛法统计的过程，还能在轻松有趣的氛围中理解如何找到最少删除数。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考质因数分解和筛法的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 质因数分解和筛法不仅能解决本题，还常用于以下场景：
        - 计算多个数的最大公约数或最小公倍数。
        - 统计区间内质数的个数（如素数筛问题）。
        - 判断一个数是否为质数（如Miller-Rabin素性测试）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1072** - `Hankson的趣味题`
          * 🗣️ **推荐理由**：这道题需要计算多个数的GCD和LCM，能帮助你巩固GCD的计算和质因数分解的应用。
    2.  **洛谷 P1029** - `最大公约数和最小公倍数问题`
          * 🗣️ **推荐理由**：此题要求找出满足GCD和LCM条件的数对，是对GCD和质因数分解的综合应用。
    3.  **洛谷 P1518** - `两只塔姆沃斯牛`
          * 🗣️ **推荐理由**：此题需要计算两个数的移动周期，涉及最小公倍数的应用，能提升对筛法和数论的理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些对我们有很大参考价值：
</insights_intro>

> **参考经验 (来自作者Acc_Robin)**：“在调试时，我发现当新数组全为1时，ans会保持初始值n，此时需要输出-1。这提醒我要特别注意边界条件的处理。”
>
> **点评**：这位作者的经验非常实用。在编程中，边界条件（如新数组全为1）容易被忽略，通过测试用例或手动模拟可以有效避免错误。大家在编码时，一定要考虑所有可能的输入情况，尤其是极端情况（如全1数组）。

-----

<conclusion>
本次关于“Enlarge GCD”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解质因数分解、筛法和GCD的应用。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：415.68秒
# 题目信息

# Congruence Equation

## 题目描述

Given an integer $ x $ . Your task is to find out how many positive integers $ n $ ( $ 1<=n<=x $ ) satisfy

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF919E/02717f82c41ef4ed609db5d967f659c9784212e1.png) where $ a,b,p $ are all known constants.

## 说明/提示

In the first sample, we can see that $ n=2 $ and $ n=8 $ are possible answers.

## 样例 #1

### 输入

```
2 3 5 8
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 6 7 13
```

### 输出

```
1
```

## 样例 #3

### 输入

```
233 233 10007 1
```

### 输出

```
1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Congruence Equation 深入学习指南 💡

<introduction>
今天我们来一起分析“Congruence Equation”这道C++编程题。这道题需要我们计算满足 \( n a^n \equiv b \pmod{p} \) 的正整数 \( n \) 的个数（\( 1 \leq n \leq x \)）。通过分析题解，我们会发现这道题的关键在于利用数论中的周期性和同余性质，将大问题拆解为可枚举的小问题。让我们一步步深入！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论应用）

🗣️ **初步分析**：
解决这道题的核心在于理解数论中的“周期性”和“同余方程求解”。简单来说，数论中的周期性就像钟表的指针——每过固定的时间（周期），指针的位置会重复。例如，根据费马小定理，当 \( p \) 是质数时，\( a^{p-1} \equiv 1 \pmod{p} \)，这意味着 \( a^n \mod p \) 的值每 \( p-1 \) 个数就会重复一次。这种周期性可以帮我们将大问题（\( x \) 很大）拆解为枚举 \( n \mod (p-1) \) 的小问题。

- **题解思路**：所有优质题解的核心思路都是枚举 \( n \mod (p-1) \) 的余数 \( r \)，将原问题转化为关于 \( r \) 和 \( k \)（\( n = k(p-1)+r \)）的同余方程，再通过求解方程并统计满足 \( 1 \leq n \leq x \) 的解的个数。
- **核心难点**：如何将 \( n a^n \equiv b \pmod{p} \) 转化为与 \( r \) 和 \( k \) 相关的同余方程？如何高效统计所有可能的 \( n \)？
- **可视化设计**：我们将设计一个“像素周期探索”动画，用不同颜色的方块表示 \( r \)（余数），动态展示 \( k \) 的变化如何影响 \( n \) 的取值，并高亮满足条件的 \( n \)。动画中会有“周期钟”（类似钟表）显示 \( a^n \mod p \) 的重复规律，每完成一个 \( r \) 的枚举，播放“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选出3个优质题解，它们的核心思路一致但实现各有特色，值得我们重点学习：
</eval_intro>

**题解一：作者Acc_Robin**
* **点评**：这是一份逻辑非常清晰的题解！作者首先利用费马小定理将 \( n \) 分解为 \( k(p-1)+r \)，推导出 \( (r - k)a^r \equiv b \pmod{p} \)，通过枚举 \( r \) 计算 \( k \)，并统计满足 \( n \leq x \) 的解的个数。代码中变量命名如 `qpow`（快速幂）、`ans`（答案）直观易懂，时间复杂度 \( O(p \log p) \) 完全适配 \( p \leq 10^6 \) 的限制。亮点在于将复杂的同余方程转化为简单的枚举问题，代码简洁高效，适合直接用于竞赛。

**题解二：作者interestingLSY**
* **点评**：此题解的优势在于对周期性的强调！作者明确指出 \( a^n \mod p \) 的周期是 \( p-1 \)，并通过枚举 \( a^n \mod p \) 的值，将原问题转化为 \( n \equiv b \cdot (a^n)^{-1} \pmod{p} \)。代码中关键函数 `Qpow`（快速幂）和 `Inv`（逆元）实现规范，`Cal` 函数负责计算每个 \( r \) 对应的解的个数，逻辑分层清晰。亮点是将抽象的周期性用“枚举 \( a^n \mod p \)”的方式具象化，适合理解周期性的应用。

**题解三：作者XenonKnight**
* **点评**：此题解的推导过程虽然稍显简略，但抓住了同余方程的核心！作者通过展开 \( n a^n \equiv b \pmod{p} \)，将 \( n \) 表示为 \( s(p-1)+t \)，并推导出 \( s \) 的表达式，最终统计解的个数。代码中 `qpow` 函数正确实现了快速幂，`ans` 的累加逻辑直接。亮点是将同余方程的求解与变量替换结合，适合理解同余式的变形技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们需要突破以下3个关键点：
</difficulty_intro>

1.  **关键点1：如何利用费马小定理分解 \( n \)？**
    * **分析**：费马小定理告诉我们，当 \( p \) 是质数且 \( a \) 不被 \( p \) 整除时，\( a^{p-1} \equiv 1 \pmod{p} \)。因此 \( a^n \mod p \) 的周期是 \( p-1 \)，即 \( a^n \equiv a^{n \mod (p-1)} \pmod{p} \)。我们可以将 \( n \) 写成 \( n = k(p-1) + r \)（\( 0 \leq r < p-1 \)），这样 \( a^n \mod p = a^r \mod p \)，从而将原问题转化为关于 \( r \) 和 \( k \) 的方程。
    * 💡 **学习笔记**：费马小定理是数论中的“周期钥匙”，能将大指数问题转化为小指数枚举。

2.  **关键点2：如何将原方程转化为同余方程组？**
    * **分析**：将 \( n = k(p-1) + r \) 代入原方程 \( n a^n \equiv b \pmod{p} \)，得到 \( (k(p-1) + r) a^r \equiv b \pmod{p} \)。由于 \( p-1 \equiv -1 \pmod{p} \)（因为 \( p-1 = p - 1 \)，模 \( p \) 后为 \( -1 \)），所以 \( k(p-1) \equiv -k \pmod{p} \)，方程简化为 \( (r - k) a^r \equiv b \pmod{p} \)。两边乘以 \( a^{-r} \mod p \)（即 \( a^r \) 的逆元），得到 \( r - k \equiv b a^{-r} \pmod{p} \)，即 \( k \equiv r - b a^{-r} \pmod{p} \)。
    * 💡 **学习笔记**：同余式的变形需要灵活运用模运算的性质（如 \( p-1 \equiv -1 \pmod{p} \)）。

3.  **关键点3：如何统计满足 \( 1 \leq n \leq x \) 的解的个数？**
    * **分析**：对于每个 \( r \)，我们可以求出最小的 \( k \) 使得 \( n = k(p-1) + r \geq 1 \) 且 \( n \leq x \)。由于 \( k \) 的周期是 \( p \)（因为 \( k \equiv c \pmod{p} \)），所以 \( n \) 的周期是 \( p(p-1) \)（\( p \) 是 \( k \) 的周期，\( p-1 \) 是 \( r \) 的周期）。统计时，先找到第一个满足条件的 \( n_* \)，然后计算 \( n_* + t \cdot p(p-1) \leq x \) 的 \( t \) 的个数，即 \( \lfloor \frac{x - n_*}{p(p-1)} \rfloor + 1 \)。
    * 💡 **学习笔记**：周期的叠加（\( p \times (p-1) \)）是统计解个数的关键。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将大问题（\( x \) 很大）通过周期性分解为小问题（枚举 \( r \)）。
- **逆元计算**：利用快速幂求逆元（\( a^{-r} \equiv a^{p-1 - r} \pmod{p} \)），简化同余式变形。
- **周期统计**：通过找到第一个解 \( n_* \)，利用周期 \( p(p-1) \) 快速计算所有可能的解的个数。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合Acc_Robin的题解（逻辑最清晰、代码最简洁），提供一个通用的核心C++实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Acc_Robin题解的思路，通过枚举 \( r \) 计算 \( k \)，并统计满足条件的 \( n \) 的个数，代码简洁高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int a, b, p, x;
        cin >> a >> b >> p >> x;
        int ans = 0;

        auto qpow = [p](int a, int b) {
            int res = 1;
            for (; b; b >>= 1, a = 1LL * a * a % p)
                if (b & 1) res = 1LL * res * a % p;
            return res;
        };

        for (int r = 0; r < p - 1; ++r) {
            int a_r = qpow(a, r);        // a^r mod p
            int inv_a_r = qpow(a_r, p-2); // a^{-r} mod p
            int f = 1LL * b * inv_a_r % p; // b * a^{-r} mod p
            int k = (r - f + p) % p;      // k ≡ r - f mod p
            int n = k * (p - 1) + r;      // 计算最小的n
            if (n <= 0) n += p * (p - 1); // 确保n≥1（可能需要调整）
            if (n > x) continue;
            ans += (x - n) / (p * (p - 1)) + 1; // 统计周期内的解个数
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入 \( a, b, p, x \)，然后定义快速幂函数 `qpow` 用于计算 \( a^r \mod p \) 和逆元 \( a^{-r} \mod p \)。通过枚举 \( r \)（\( 0 \leq r < p-1 \)），计算每个 \( r \) 对应的 \( k \) 和最小 \( n \)，最后统计满足 \( n \leq x \) 的解的个数。核心逻辑在循环中完成，时间复杂度为 \( O(p \log p) \)，适用于 \( p \leq 10^6 \) 的情况。

---
<code_intro_selected>
接下来，我们剖析3个优质题解的核心代码片段，学习它们的亮点：
</code_intro_selected>

**题解一：作者Acc_Robin**
* **亮点**：代码简洁，直接利用 \( k \equiv r - f \mod p \) 计算 \( k \)，并通过 \( (x - n) / (p*(p-1)) + 1 \) 统计解个数。
* **核心代码片段**：
    ```cpp
    for(int r=0,f,k,now;r<p-1;r++){
        f=b*qpow(qpow(a,r))%p;
        k=(r-f+p)%p;
        if((now=k*(p-1)+r)>x)continue;
        ans+=(x-now)/(p*(p-1))+1;
    }
    ```
* **代码解读**：
    - `qpow(a, r)` 计算 \( a^r \mod p \)，`qpow(qpow(a,r))` 计算其逆元（因为 `qpow` 默认指数为 \( p-2 \)，即费马小定理求逆元）。
    - `f = b * inv(a^r) mod p` 对应 \( b \cdot a^{-r} \mod p \)。
    - `k = (r - f + p) % p` 确保 \( k \) 非负，对应 \( k \equiv r - f \mod p \)。
    - `now` 是第一个满足条件的 \( n \)，若 `now > x` 则跳过；否则统计周期内的解个数。
* 💡 **学习笔记**：逆元的计算是数论问题的常见操作，快速幂求逆元是基础技巧。

**题解二：作者interestingLSY**
* **亮点**：通过 `Cal` 函数封装解的计算，逻辑分层清晰。
* **核心代码片段**：
    ```cpp
    il ll Cal( int n , int power ){
        ll now = b * Inv(power) % p;
        ll correctn = (p-1)*Mod(n-now,p) + n;
        if( correctn > x ) return 0LL;
        return (x-correctn) / (p*(p-1)) + 1;
    }
    ```
* **代码解读**：
    - `power` 是 \( a^n \mod p \)（即 \( a^r \mod p \)），`Inv(power)` 计算其逆元。
    - `now = b * Inv(power) mod p` 对应 \( b \cdot a^{-r} \mod p \)。
    - `correctn` 是第一个满足条件的 \( n \)（即 \( k(p-1) + r \)），通过 `Mod(n-now, p)` 计算 \( k \)（\( k = (n - now) \mod p \)）。
    - 若 `correctn > x` 则返回0，否则统计周期内的解个数。
* 💡 **学习笔记**：函数封装可以提高代码的可读性和复用性。

**题解三：作者XenonKnight**
* **亮点**：通过变量替换将同余式转化为 \( s \) 的表达式，直接计算解个数。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=p-1;i++){
        int t=qpow(qpow(a,p-2,p),i,p);
        t=t*b%p;
        t=(t-i+p)%p;
        t=t*qpow(p-1,p-2,p)%p;
        int k=x/p*p;
        if(t*(p-1)+i>x)	continue;
        ans+=((x-i)/(p-1)-t)/p+1;
    }
    ```
* **代码解读**：
    - `qpow(a,p-2,p)` 计算 \( a \) 的逆元，`qpow(..., i, p)` 计算 \( a^{-i} \mod p \)。
    - `t = a^{-i} * b mod p` 对应 \( b \cdot a^{-r} \mod p \)（这里 \( r = i \)）。
    - `t = (t - i + p) % p` 对应 \( k \equiv r - t \mod p \)（即 \( k \equiv i - t \mod p \)）。
    - `t*(p-1)+i` 是第一个满足条件的 \( n \)，统计解个数。
* 💡 **学习笔记**：变量替换是简化同余式的重要手段。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举 \( r \) 并统计解个数”的过程，我们设计一个名为“像素周期探险家”的8位像素风格动画！让我们一起“看”到 \( n \) 的周期性和同余方程的求解过程。
</visualization_intro>

  * **动画演示主题**：像素周期探险家——寻找满足 \( n a^n \equiv b \pmod{p} \) 的 \( n \)！

  * **核心演示内容**：展示 \( r \)（\( n \mod (p-1) \)）的枚举过程，每个 \( r \) 对应一个“周期钟”（类似钟表，共 \( p-1 \) 格），指针指向当前 \( r \)。同时，动态计算 \( k \) 和 \( n \)，并标记满足 \( n \leq x \) 的 \( n \)。

  * **设计思路简述**：8位像素风格（如FC红白机）能营造轻松的学习氛围；“周期钟”直观展示 \( a^n \mod p \) 的周期性；每完成一个 \( r \) 的枚举，播放“叮”的音效，强化操作记忆；统计解个数时，用“像素星星”奖励，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕分为左右两部分：左侧是“周期钟”（圆形，\( p-1 \) 个像素格，每个格标有 \( r=0,1,...,p-2 \)），右侧是“解统计区”（显示当前 \( r \)、\( k \)、\( n \) 和总解数）。
          - 控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。
          - 播放8位风格的背景音乐（如《超级玛丽》的轻快旋律）。

    2.  **枚举 \( r \) 与计算 \( k \)**：
          - 点击“开始”，周期钟的指针从 \( r=0 \) 开始顺时针移动（像素动画：指针滑动，伴随“滴答”音效）。
          - 对于当前 \( r \)，右侧显示 \( a^r \mod p \)（用像素方块显示数值），计算 \( b \cdot a^{-r} \mod p \)（显示为黄色方块），然后计算 \( k = (r - f) \mod p \)（显示为绿色方块）。

    3.  **计算 \( n \) 并统计解**：
          - 计算 \( n = k(p-1) + r \)，若 \( n > x \)（显示为红色闪烁），则跳过；否则，在解统计区用蓝色像素点标记 \( n \)，并计算周期内的解个数（如 \( n, n+p(p-1), ... \)），每标记一个解，播放“叮”的音效。

    4.  **目标达成**：
          - 当所有 \( r \) 枚举完成，总解数显示为金色，播放“胜利”音效（如《超级玛丽》吃金币声），并弹出“恭喜！找到所有解！”的像素文字。

  * **旁白提示**：
      - （指针移动时）“当前枚举 \( r=0 \)，\( a^0 \mod p=1 \)，计算 \( b \cdot 1^{-1} \mod p = b \)。”
      - （计算 \( k \) 时）“\( k = (0 - b) \mod p \)，得到 \( k \) 的值。”
      - （统计解时）“\( n = k(p-1) + 0 \) 满足条件，周期为 \( p(p-1) \)，所以 \( n, n+p(p-1), ... \) 都满足条件！”

<visualization_conclusion>
通过这个动画，我们不仅能看到 \( r \) 的枚举过程，还能直观理解 \( n \) 的周期性和同余方程的求解逻辑，让抽象的数论问题变得“可见”又有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是利用数论的周期性和同余方程求解，这类思路在数论题中非常通用。我们可以将其迁移到以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - **求解 \( n \cdot f(n) \equiv c \pmod{m} \)**（\( f(n) \) 是周期性函数）。
      - **统计满足 \( n \equiv a \pmod{p} \) 且 \( n \equiv b \pmod{q} \) 的 \( n \) 的个数**（中国剩余定理）。
      - **处理大指数问题**（如 \( a^n \mod m \)，利用欧拉定理找周期）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1082** - `同余方程`
          * 🗣️ **推荐理由**：直接考察同余方程 \( ax \equiv 1 \pmod{b} \) 的求解，是本题逆元计算的基础。
    2.  **洛谷 P3811** - `乘法逆元`
          * 🗣️ **推荐理由**：练习快速幂求逆元和线性求逆元，巩固数论基础。
    3.  **洛谷 P5431** - `乘法逆元2`
          * 🗣️ **推荐理由**：在逆元基础上增加多组数据处理，提升代码效率和鲁棒性。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者Acc_Robin提到：“一开始可能会被 \( x \) 的大数值吓到，但注意到 \( p \) 很小，想到用费马小定理找周期，问题就迎刃而解了。” 这对我们有很大启发！
</insights_intro>

> **参考经验 (来自 Acc_Robin)**：“遇到大数值问题时，先观察其他变量的范围（如本题的 \( p \) 很小），寻找周期性或模数性质，往往能将大问题拆解为小问题。”
>
> **点评**：Acc_Robin的经验非常实用！在编程竞赛中，数据范围往往是解题的关键线索。当 \( x \) 很大但 \( p \) 很小时，数论的周期性（如费马小定理）是常用的突破口。这提醒我们，遇到问题时要先分析数据范围，寻找可能的“小变量”作为切入点。

-----

<conclusion>
本次关于“Congruence Equation”的C++解题分析就到这里。通过学习数论的周期性和同余方程求解，我们掌握了处理大数值问题的关键技巧。记住，数论问题的核心是观察规律、利用性质，多练习类似题目会让你越来越熟练！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：188.45秒
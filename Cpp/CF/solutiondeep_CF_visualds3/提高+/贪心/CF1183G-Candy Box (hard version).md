# 题目信息

# Candy Box (hard version)

## 题目描述

本题是同场比赛中 D 题的一个变种，增加了一些额外的限制和任务。

有 $n$ 颗糖果放在一个糖果盒中。第 $i$ 颗糖果的类型为 $a_i$（$1 \le a_i \le n$）。

你需要用这些糖果中的一部分来准备一份礼物，满足以下限制：在礼物中，每种类型的糖果数量必须互不相同（例如，包含两颗 1 型糖果和两颗 2 型糖果的礼物是不合法的）。

某些类型的糖果可以完全不出现在礼物中。某些类型的糖果也可以只取其中一部分放入礼物。

你特别喜欢其中一些糖果，不想把它们放进礼物，而是想自己吃。对于每颗糖果，给定一个数 $f_i$，如果 $f_i = 0$，表示你想自己留着第 $i$ 颗糖果；如果 $f_i = 1$，表示你不介意把它放进礼物。同一种类型的两颗糖果，$f_i$ 的值可能不同。

你希望礼物中糖果的数量尽可能多，但又不想把太多自己想吃的糖果放进礼物。因此，你需要计算在满足条件的情况下，礼物中最多能包含多少颗糖果；在所有能达到最大数量的方案中，你还希望礼物中 $f_i = 1$ 的糖果数量尽可能多。

你需要回答 $q$ 个独立的询问。

如果你使用 Python 编程，建议提交时使用 PyPy 以提高运行效率。

## 说明/提示

在第一个询问中，你可以选择两颗 4 型糖果和一颗 5 型糖果，它们的 $f_i$ 都为 $1$，你不介意把它们送出去作为礼物。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
8
1 0
4 1
2 0
4 1
5 1
6 1
3 0
2 0
4
1 1
1 1
2 1
2 1
9
2 0
2 0
4 1
4 1
4 1
7 0
7 1
7 0
7 1
```

### 输出

```
3 3
3 3
9 5
```

# AI分析结果


### 💡 Kay的C++算法解析：Candy Box (hard version) 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`贪心算法 + 优先队列优化`  
🗣️ **初步分析**：  
> 这道题就像在糖果工厂挑选礼盒：每种糖果数量必须独一无二（如不能有两个"苹果味"各2颗），同时要**最大化总糖果数**和**自愿赠送的糖果数**（f_i=1）。核心思路是：
> - **贪心策略**：从高到低枚举目标数量（如先尝试放5颗某种糖，再放4颗另一种...）
> - **优先队列优化**：动态选择当前最优糖果类型，类似游戏中的"道具选择系统"
> - **关键难点**：数量枚举时需实时筛选可用糖果类型，并优先选择自愿糖果多的类型
> - **可视化设计**：将用像素网格展示糖果类型（不同颜色方块），高亮当前选择的数量值（如"5"闪烁），优先队列显示为浮动道具栏，伴随"叮"的音效提示选择

---

#### 精选优质题解参考
**题解一（Eibon）**  
* **点评**：  
思路清晰直击双目标优化，核心逻辑用优先队列动态维护可用类型。代码中`q.push(cnt[now].num[1])`精准捕获自愿糖果数，`max(i-q.top(),0ll)`巧妙计算损耗。边界处理完整（清空队列和计数器），竞赛实用性强。亮点在于用数学思维简化自愿糖果计算。

**题解二（wucstdio）**  
* **点评**：  
从简单版延伸的思维迁移优秀，`sa`数组排序后倒序枚举保证数量互异。`num+=min(v,i)`直接累积自愿糖果数，逻辑更直观。代码规范（结构体封装数据），但变量名`cnt0`实际存储f_i=1易混淆，需注意命名一致性。

---

#### 核心难点辨析与解题策略
1. **动态维护可用类型集合**  
   *分析*：枚举数量i时需快速获取所有≥i的糖果类型。优质题解用排序+指针（如`now`）筛选，配合优先队列实时更新，时间复杂度优化至O(n log n)  
   💡 **学习笔记**：排序预处理是降低实时查询复杂度的关键

2. **双目标优化取舍**  
   *分析*：先保证总糖果最大（取所有可用类型），再选自愿糖果最多的类型（优先队列按cnt1排序）。数学证明交换选择不会更优  
   💡 **学习笔记**：多目标优化时，分层处理可避免目标冲突

3. **避免重复计数**  
   *分析*：同类型糖果在不同数量枚举中仅出现一次。代码通过`sort`后单指针移动（`now--`）和弹出队列(`q.pop()`)保证  
   💡 **学习笔记**：集合元素的删除需与添加严格对应

### ✨ 解题技巧总结
- **分层贪心**：优先满足主目标（总糖果数），再优化次要目标（自愿糖果）
- **实时更新结构**：指针+优先队列组合应对动态查询
- **数学化损耗**：总损耗 = Σ(max(0, i - cnt1)) 避免复杂分类讨论

---

### C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
const int MAX=2e5+5;

struct Type { int total, volunteer; }; // total=总糖果, volunteer=f_i=1数
Type cnt[MAX];

int main() {
    int T; cin>>T;
    while(T--) {
        int n, a, f; cin>>n;
        for(int i=1; i<=n; i++) cnt[i]={0,0}; // 初始化
        
        // 1. 统计每种糖果数据
        for(int i=0; i<n; i++) {
            cin>>a>>f;
            cnt[a].total++;
            if(f) cnt[a].volunteer++;
        }
        
        // 2. 按总糖果数排序
        sort(cnt+1, cnt+n+1, [](Type x, Type y){
            return x.total > y.total; 
        });
        
        // 3. 贪心选取
        priority_queue<int> q; // 存volunteer数
        int totalCandy=0, volunteerSum=0, idx=1;
        for(int num=n; num>=1; num--) { // 从大到小枚举目标数量
            while(idx<=n && cnt[idx].total>=num) {
                q.push(cnt[idx].volunteer);
                idx++;
            }
            if(q.empty()) continue;
            int cur = q.top(); q.pop();
            totalCandy += num;
            volunteerSum += min(num, cur); // 关键优化点
        }
        cout << totalCandy << " " << volunteerSum << endl;
    }
    return 0;
}
```
**代码解读概要**：  
1. 初始化糖果类型统计数组  
2. 按总糖果数**降序排序**  
3. 倒序枚举目标数量，动态维护可用类型队列  
4. 每次选择自愿糖果最多的类型，累加结果  

---

**题解一片段赏析**  
```cpp
while(now&&cnt[now].num[0]+cnt[now].num[1]>=i){
    q.push(cnt[now].num[1]); // 重点！volunteer数入队
    now--;
}
if(!q.empty()){
    ans1 += i; // 累加总糖果
    tot += max(i-q.top(),0ll); // 计算损耗
    q.pop();
}
```
💡 **学习笔记**：`max(i-q.top(),0ll)`精妙处理了当需求超过自愿糖果的情况

---

### 算法可视化：像素动画演示
* **主题**：糖果工厂装配线（8-bit像素风）  
* **核心流程**：  
  ![](https://via.placeholder.com/400x200/FF6B6B/FFFFFF?text=Pixel+Animation)  
  1. **初始化**：糖果类型显示为颜色方块（大小=总量），右侧控制面板含速度滑块  
  2. **数量枚举**：顶部显示当前目标数量`i`（闪烁红色），传送带运送≥i的类型  
  3. **队列操作**：合格类型进入优先队列（浮动窗口按自愿数降序排列）  
  4. **选择动画**：取队首时播放"叮"音效，该类型方块放大显示取值过程  
  5. **数据更新**：底部面板实时显示总糖果/自愿糖果数，达成最大时播放胜利音效  

* **交互设计**：  
  - 单步/自动模式可切换，调速滑块控制动画速度  
  - 错误提示：当类型不足时播放低沉音效  
  - 游戏化：每完成一个数量值获得金币特效，集齐n个解锁成就  

---

### 拓展练习与相似问题
1. **洛谷 P1090** - 合并果子  
   🗣️ 同款优先队列贪心，巩固队列维护技巧  
2. **洛谷 P1208** - 混合牛奶  
   🗣️ 双目标优化（成本最小+数量足），训练分层贪心思维  
3. **洛谷 P5019** - 铺设道路  
   🗣️ 变种数量分配问题，强化枚举策略  

---

### 学习心得与经验分享
> **Eibon的调试经验**："最初忽略类型总数与自愿数的独立统计，导致队列逻辑混乱"  
> **Kay总结**：核心教训是**明确数据结构含义**——优先队列存的是volunteer数而非类型对象。建议：  
> 1. 复杂问题先用注释明确变量含义  
> 2. 小规模数据手动模拟队列操作  

---
> 掌握贪心+队列的配合，就像获得游戏中的终极装备！下次遇到动态选择问题，记得先排序再队列维护~ 🎮✨

---
处理用时：137.80秒
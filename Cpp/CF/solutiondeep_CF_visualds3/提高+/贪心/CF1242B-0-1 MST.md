# 题目信息

# 0-1 MST

## 题目描述

Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on $ n $ vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either $ 0 $ or $ 1 $ ; exactly $ m $ edges have weight $ 1 $ , and all others have weight $ 0 $ .

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

## 说明/提示

The graph from the first sample is shown below. Dashed edges have weight $ 0 $ , other edges have weight $ 1 $ . One of the minimum spanning trees is highlighted in orange and has total weight $ 2 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1242B/fca3e805aa04953bd891689ec1c79b03eae5d280.png)In the second sample, all edges have weight $ 0 $ so any spanning tree has total weight $ 0 $ .

## 样例 #1

### 输入

```
6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 0
```

### 输出

```
0
```

# AI分析结果


# 💡 Kay的C++算法解析：0-1 MST 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`补图连通分量` (图论/并查集应用)

🗣️ **初步分析**：
> 这道题的核心在于理解**补图思想**——想象原始完全图中所有边原本都是0权边，但题目指定了m条1权边。我们可以把问题转化为求**0权边构成的子图**的连通分量个数，答案就是`(连通分量个数-1)`。为什么呢？因为每个连通分量内部可以用0权边连接，而连通分量之间只需1条1权边就能串联。

> 题解主要分为两类思路：
> 1. **并查集优化**：利用度数最小点（1权边最少的点）快速形成大连通块，再处理剩余点
> 2. **补图遍历**：用set维护未访问节点，BFS/DFS遍历0权边构成的补图
>
> 可视化设计要点：我们将用像素方块表示节点，同色方块表示同一连通块。动画将高亮显示度数最小点，逐步展示连通块合并过程，关键合并步骤会触发"叮"声，最终用不同颜色区分连通块。

---

## 2. 精选优质题解参考

### 题解一（作者：zhoukangyang）
* **点评**：思路清晰抓住度数最小点性质，代码规范使用bitset优化存储。算法高效（O(n+m)），实践性强：通过抽屉原理证明剩余点数O(m/n)，用并查集合并时避免无效检查。亮点是严格复杂度证明和变量名含义明确（deg/minn等），竞赛适用性强。

### 题解二（作者：RedLycoris）
* **点评**：代码极度简洁（仅20行）而高效，用set实现补图BFS核心逻辑清晰。亮点是`unvisited`集合动态维护未访问节点，删除操作与BFS结合巧妙。时间复杂度O(n log n + m)稍高但易实现，适合快速解题。

### 题解三（作者：quanjun）
* **点评**：参考官方题解的动态连通块思路，使用vector维护连通块列表，map统计边数。代码结构工整，解释清楚状态转移逻辑。亮点是详细说明合并条件`cnt[root] < sz[root]`的推导过程，教学价值高。

---

## 3. 核心难点辨析与解题策略

1. **难点：避免显式构建补图**
   * 分析：补图边数达O(n²)无法直接存储
   * 解决：只存储1权边，用集合运算判断0权边
   * 💡 学习笔记：补图问题常转化为"总边集-给定边集"

2. **难点：高效求连通分量**
   * 分析：朴素BFS/DFS复杂度可能达O(n²)
   * 解决：利用度数最小点性质（度数≤2m/n）缩小问题规模
   * 💡 学习笔记：最值点性质往往是优化突破口

3. **难点：处理大规模合并**
   * 分析：并查集合并需避免重复检查
   * 解决：动态维护连通块列表，仅检查必要点对
   * 💡 学习笔记：减少无效操作比优化单次操作更重要

### ✨ 解题技巧总结
- **问题转化**：将MST问题转化为连通分量计数
- **数据结构**：优先选择set维护未访问节点，并查集维护连通性
- **边界处理**：特判m=0时直接输出0
- **复杂度证明**：利用抽屉原理分析剩余点规模
- **调试技巧**：小数据模拟验证合并逻辑

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;

set<int> g[N]; // g[u]: 与u相连的1权边节点
set<int> unvis; // 未访问节点集合

int main() {
    int n, m; cin >> n >> m;
    for(int i=1; i<=n; i++) unvis.insert(i);
    while(m--) {
        int u, v; cin >> u >> v;
        g[u].insert(v); g[v].insert(u);
    }

    int comp = 0;
    for(int i=1; i<=n; i++) {
        if(unvis.find(i) == unvis.end()) continue;
        comp++;
        queue<int> q; q.push(i);
        unvis.erase(i);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            vector<int> rm;
            for(int v : unvis) 
                if(g[u].find(v) == g[u].end()) 
                    rm.push_back);
            for(int v : rm) {
                unvis.erase(v);
                q.push(v);
            }
        }
    }
    cout << comp-1 << endl;
}
```
* **说明**：综合优质题解的最简实现，采用补图BFS
* **代码解读概要**：用全局`unvis`集合跟踪未访问节点。对每个新连通块启动BFS：遍历当前节点的补图邻居（无1权边即入队），动态更新未访问集合。

### 题解一核心片段（zhoukangyang）
```cpp
// 找度数最小点minn
for(int i=1; i<=m; i++) deg[u]++, deg[v]++; 
int minn = min_element(deg+1, deg+n+1) - deg;

// 合并0权边邻居
for(int i=1; i<=n; i++) 
    if(!g[minn].count(i)) 
        f[find(i)] = minn; 

// 处理剩余点
for(int u : rest) 
    for(int v=1; v<=n; v++)
        if(!g[u].count(v) && !same(u,v)) 
            merge(u,v);
```
**亮点**：利用度数最小点快速收缩问题规模  
**学习笔记**：最值点性质将问题规模降至O(m/n)

### 题解二核心片段（quanjun）
```cpp
vector<int> compRoots; // 连通块根节点
for(int u=1; u<=n; u++) {
    map<int,int> edgeCnt; // 当前点到各连通块的1权边数
    for(int v : g[u]) 
        if(v < u) edgeCnt[find(v)]++;
    
    for(int root : compRoots) {
        if(edgeCnt[root] < sz[root]) // 存在0权边
            merge(u, root);
    }
    if(find(u)==u) compRoots.push_back(u);
}
```
**亮点**：动态维护连通块并统计边界数量  
**学习笔记**：map计数避免全连通块扫描

---

## 5. 算法可视化：像素动画演示

**主题**：像素探险家合并连通块大冒险  
**核心演示**：度数最小点优先扩展策略  
**像素设计**：
- 8-bit风格，节点用16x16像素方块表示
- 连通块内同色（调色板：#FF5555,#55FF55,#5555FF）
- 控制面板：步进/播放/速度滑块

**动画流程**：
1. 初始化显示n个独立方块（图1）
   ``` 
   □ □ □ □ 
   □ □ □ □ 
   □ □ □ □ 
   ```
2. **定位度数最小点**：闪烁黄色边框（音效：叮~）
3. **合并0权邻居**：相邻方块渐变成同色（音效：咔嚓）
4. **处理剩余点**：
   - 检查新点与各连通块连接（高亮连接线）
   - 存在0权边时触发合并动画（粒子效果）
5. **结果展示**：显示连通块数量及最终答案

**交互设计**：
- 空格键单步执行
- 速度滑块调节自动播放速度（0.5x~3x）
- 成功合并时+100分（8-bit音效）

---

## 6. 拓展练习与相似问题

**通用技巧迁移**：
1. 补图连通性问题（如动态加边）
2. 稀疏图上的连通分量统计
3. 带约束的最小生成树变种

**洛谷推荐**：
1. **P1547 [POI2005]KLO-Building blocks**  
   → 巩固连通块计数技巧
2. **P2502 [POJ2007]旅行**  
   → 补图思想在路径问题应用
3. **CF920E Connected Components?**  
   → 直接求补图连通分量（本题进阶版）

---

## 7. 学习心得与经验分享

> **参考经验（zhoukangyang）**：  
> "第一次打div1...利用度数最小点的性质，将暴力O(n²)优化到线性"

> **点评**：这提醒我们注意题目隐含的最值性质（如最小/最大度数），这类性质往往能突破常规复杂度限制，是竞赛解题的关键洞察点。

本次题解中多位作者强调了**问题转化**的重要性——将MST转化为连通分量问题。在日常练习中，建议多训练这种"等价转换"的思维模式。

---

掌握补图思想和连通分量计数技巧，你就能高效解决这类看似复杂的图论问题！继续加油，下次见！🚀

---
处理用时：195.53秒
# 题目信息

# Compatible Numbers

## 题目描述

Two integers $ x $ and $ y $ are compatible, if the result of their bitwise "AND" equals zero, that is, $ a $ $ & $ $ b=0 $ . For example, numbers $ 90 $ $ (1011010_{2}) $ and $ 36 $ $ (100100_{2}) $ are compatible, as $ 1011010_{2} $ $ & $ $ 100100_{2}=0_{2} $ , and numbers $ 3 $ $ (11_{2}) $ and $ 6 $ $ (110_{2}) $ are not compatible, as $ 11_{2} $ $ & $ $ 110_{2}=10_{2} $ .

You are given an array of integers $ a_{1},a_{2},...,a_{n} $ . Your task is to find the following for each array element: is this element compatible with some other element from the given array? If the answer to this question is positive, then you also should find any suitable element.

## 样例 #1

### 输入

```
2
90 36
```

### 输出

```
36 90```

## 样例 #2

### 输入

```
4
3 6 3 6
```

### 输出

```
-1 -1 -1 -1```

## 样例 #3

### 输入

```
5
10 6 9 8 2
```

### 输出

```
-1 8 2 2 8```

# AI分析结果



---
# 💡 Kay的C++算法解析：Compatible Numbers 深入学习指南 💡

<introduction>
今天我们来一起分析“Compatible Numbers”这道C++编程题。这道题的核心是通过位运算和高效预处理，快速找到与每个数相容的另一个数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（侧重位运算与高维前缀和预处理）`

🗣️ **初步分析**：
解决“Compatible Numbers”的关键在于理解：两个数相容（即按位与为0）的本质是，其中一个数的二进制位只能在另一个数为0的位上有1。简单来说，若把数a的二进制位看作“禁止区”（1的位置），那么相容的数b的二进制位必须全在“允许区”（a的0的位置）内。这就像在棋盘上放置棋子，b的1不能落在a的1的位置上。

在本题中，我们需要为每个a_i找到一个a_j，使得a_j的所有1位都在a_i的0位上。这可以通过预处理所有可能的“允许区”子集，记录每个子集是否存在对应的数。核心算法是**高维前缀和（或状压DP）**，用于高效预处理每个可能的“允许区”子集是否存在解。

- **题解思路对比**：多数题解采用高维前缀和预处理，通过逐位扩展的方式，将每个数的取反后的子集标记为存在解。例如，作者__Watcher的代码直接使用高维前缀和预处理，而Prurite的题解则通过反向DP更新每个数的解。
- **核心算法流程**：预处理阶段，将数组中所有数的取反值（即“允许区”的最大范围）标记为存在解；然后通过逐位扩展（高维前缀和），将每个子集的解传递给其超集（即允许区减少一位的情况）。查询时，只需检查a_i对应的允许区是否有解。
- **可视化设计**：采用8位像素风格，用网格表示二进制位（每个格子代表一位），动态展示预处理时如何从初始解（标记的取反值）逐步扩展到所有子集。关键步骤高亮当前处理的位和更新的子集，伴随“叮”的音效提示扩展操作。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者__Watcher（赞：33）**
* **点评**：这份题解思路简洁，直接点明高维前缀和的应用。代码规范，变量命名清晰（如f数组存储子集解），预处理逻辑高效。通过逐位扩展的高维前缀和，确保每个子集都能继承其超集的解，时间复杂度O(22*2^22)，适合处理大规模数据。实践价值高，可直接用于竞赛。

**题解二：作者Prurite（赞：19）**
* **点评**：此题解从DP角度解释问题，将预处理过程描述为“从大往小更新”，逻辑易懂。代码模块化（reset、read、solution、output函数），结构清晰。特别强调位运算的优先级问题（如取反时用&INF限制范围），避免了常见错误，对新手友好。

**题解三：作者Mooncrying（赞：10）**
* **点评**：此题解详细解释了高维前缀和的原理，并链接了相关学习资料，适合扩展理解。代码中使用read/write函数优化输入输出，处理大规模数据更高效。预处理部分逐位更新的逻辑与__Watcher的解法一致，但注释更详细，便于学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：理解相容数的二进制本质**
    * **分析**：相容数a_j必须满足a_i & a_j = 0，即a_j的所有1位都在a_i的0位上。这等价于a_j是a_i按位取反后的子集（取反后，a_i的0位变为1位，a_j的1位必须落在这些位置）。例如，a_i=90（二进制1011010），取反后为0100101（假设22位），a_j必须是这个取反值的子集（如36的二进制100100）。
    * 💡 **学习笔记**：相容数的本质是子集关系，取反操作将问题转化为“子集存在性”判断。

2.  **关键点2：高效预处理子集解**
    * **分析**：直接枚举所有子集时间复杂度太高（2^22≈4e6，子集数量是指数级）。优质题解采用高维前缀和（或状压DP），逐位扩展：对于每个数，若其缺少某一位后的超集已有解，则继承该解。例如，若数x缺少第i位后的数x^(1<<i)有解，则x也有解。
    * 💡 **学习笔记**：高维前缀和通过逐位处理，将指数级的子集枚举优化到线性复杂度（O(位数*2^位数)）。

3.  **关键点3：处理取反的边界条件**
    * **分析**：由于C++中负数的取反是补码形式（带符号位），直接取反会超出22位范围。优质题解通过异或(1<<22 - 1)实现“无符号取反”（仅保留低22位），确保取反后的数在预处理范围内。
    * 💡 **学习笔记**：位运算时需注意数据范围，用掩码（如(1<<22)-1）限制位数是常见技巧。

### ✨ 解题技巧总结
- **问题转化**：将“寻找相容数”转化为“判断取反后的子集是否存在解”，简化问题。
- **高维前缀和预处理**：通过逐位扩展，高效记录每个子集的解，避免重复计算。
- **位运算掩码**：用(1<<22)-1限制取反后的位数，避免符号位干扰。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了__Watcher、Mooncrying等优质题解的思路，采用高维前缀和预处理，高效解决问题。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAX = (1 << 22) - 1; // 22位掩码
    int n, a[1000005], f[MAX + 1]; // f数组存储每个子集的解

    int main() {
        scanf("%d", &n);
        memset(f, -1, sizeof(f)); // 初始化为-1（无解）
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            f[a[i]] = a[i]; // 初始解：数本身是自己的子集
        }
        // 高维前缀和预处理：逐位扩展
        for (int i = 0; i < 22; ++i) {
            for (int j = 0; j <= MAX; ++j) {
                if ((j & (1 << i)) && f[j ^ (1 << i)] != -1) {
                    f[j] = f[j ^ (1 << i)]; // 继承超集的解
                }
            }
        }
        // 查询每个a_i的解
        for (int i = 1; i <= n; ++i) {
            int target = MAX ^ a[i]; // 取反后的数（低22位）
            printf("%d ", f[target] != -1 ? f[target] : -1);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入数组，并将每个数初始化为自己的解（因为数本身是自己的子集）。然后通过高维前缀和逐位扩展，将每个数的解传递给其超集（即缺少某一位的数）。最后，对于每个a_i，计算其取反后的数target，查询f[target]是否存在解（存在则输出，否则输出-1）。

---
<code_intro_selected>
接下来，我们将剖析优质题解中最能体现核心逻辑的代码片段，并点出各自的亮点。
</code_intro_selected>

**题解一：作者__Watcher**
* **亮点**：代码简洁高效，直接使用高维前缀和预处理，时间复杂度最优。
* **核心代码片段**：
    ```cpp
    for(int i=0;i<=21;i++) {
        for(int j=0;j<(1<<22);j++) {
            if((j&(1<<i))&&f[j^(1<<i)]) f[j]=f[j^(1<<i)];
        }
    }
    ```
* **代码解读**：
    这段代码是高维前缀和的核心。外层循环枚举每一位（0~21），内层循环枚举所有可能的数j。如果j的第i位是1（j&(1<<i)），且j去掉第i位后的数j^(1<<i)有解（f[j^(1<<i)]不为0），则j的解继承j^(1<<i)的解。这相当于将解从“缺少某一位的超集”传递给“包含该位的子集”。
* 💡 **学习笔记**：高维前缀和通过逐位处理，将每个子集的解快速传递，避免了枚举所有子集的高复杂度。

**题解二：作者Prurite**
* **亮点**：反向DP更新，从大往小处理，逻辑直观。
* **核心代码片段**：
    ```cpp
    for(int m=INF;m>0;m--) 
        if(ans[m]==-1) 
            for(int j=1;j<=22;j++)
                if(!(m&1<<j-1) && ans[m|1<<j-1]!=-1) {
                    ans[m]=ans[m|1<<j-1];
                    break;
                }
    ```
* **代码解读**：
    这段代码从最大的数（INF=(1<<22)-1）开始，逆序处理每个数m。如果m无解（ans[m]==-1），则尝试将m的某一位0变为1（m|1<<j-1），若该超集有解，则m继承其解。例如，m=5（二进制101），若m|(1<<1)=7（二进制111）有解，则m的解就是7的解。
* 💡 **学习笔记**：反向DP通过“补位”操作，从大到小更新，确保每个数的解是其所有可能超集中最小的解（或任意解）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解高维前缀和的预处理过程，我设计了一个8位像素风格的动画演示方案，模拟“允许区”子集的扩展过程。
</visualization_intro>

  * **动画演示主题**：`像素位探宝——寻找相容数的冒险`

  * **核心演示内容**：展示高维前缀和如何从初始解（标记的取反值）逐步扩展到所有子集，最终找到每个a_i对应的相容数。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用网格表示22位二进制数（每行11位，共2行），每个格子代表一位（绿色表示1，灰色表示0）。动画通过“点亮”格子和“传递”解的方式，模拟高维前缀和的扩展过程，配合音效增强记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是22位的二进制网格（像素块），右侧是预处理数组f的状态（每个数对应一个像素块，绿色表示有解，红色表示无解）。
          * 控制面板包含“单步”、“自动播放”、“重置”按钮，以及速度滑块。

    2.  **初始解标记**：
          * 输入数组中的每个数a_i，其取反后的数target（即MAX^a_i）对应的f[target]被标记为绿色（有解），伴随“滴”的音效。

    3.  **高维前缀和扩展**：
          * 逐位处理（i从0到21），当前处理位用黄色箭头标注。
          * 对于每个数j，若j的第i位是1（网格对应位绿色），且j^(1<<i)（去掉第i位后的数）有解（绿色），则j的f[j]被标记为绿色（继承解），网格中j的第i位闪烁，伴随“叮”的音效。

    4.  **查询演示**：
          * 输入a_i后，计算其取反数target，对应的f[target]若为绿色，网格中target的位全部高亮（蓝色），并弹出“找到相容数！”的提示；若为红色，提示“无解”。

    5.  **游戏化元素**：
          * 每成功扩展一个子集，得分+1，屏幕显示“得分：XXX”。
          * 自动播放模式下，算法像“探宝小人”一样逐个点亮子集，增加趣味性。

  * **旁白提示**：
      * “现在处理第i位，检查每个数j的第i位是否为1……”
      * “看！j去掉第i位后的数有解，所以j也继承这个解~”
      * “查询时，取反后的数target对应的f[target]如果是绿色，就说明存在相容数！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到高维前缀和如何一步步扩展解，理解“子集继承解”的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考高维前缀和与位运算的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 高维前缀和不仅用于相容数问题，还可处理“子集最值”、“子集和”等问题（如求每个数的子集最大值）。
      * 位运算的取反、掩码技巧在“二进制状态压缩”问题中常见（如棋盘覆盖、状态转移）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1896 [SCOI2005] 互不侵犯**  
        * 🗣️ **推荐理由**：涉及二进制状态压缩和动态规划，需处理状态间的相容关系（类似本题的位与为0条件）。
    2.  **洛谷 P3171 [CQOI2015] 网络吞吐量**  
        * 🗣️ **推荐理由**：结合图论与位运算，需用高维前缀和预处理节点间的相容路径。
    3.  **洛谷 P5504 [JSOI2011] 柠檬**  
        * 🗣️ **推荐理由**：涉及二进制位的统计与高维前缀和，需处理不同位的贡献。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者zyc____)**：“一开始用cin/cout会TLE，改成scanf/printf就AC了。”  
> **点评**：处理大规模数据时（n≤1e6），输入输出效率很关键。使用scanf/printf或快读快写能显著提升速度，避免超时。

---

<conclusion>
本次关于“Compatible Numbers”的C++解题分析就到这里。希望这份学习指南能帮助大家理解高维前缀和与位运算的应用。记住，多动手调试、分析二进制位的变化，是掌握这类问题的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：305.78秒
# 题目信息

# Maximum White Subtree

## 题目描述

You are given a tree consisting of $ n $ vertices. A tree is a connected undirected graph with $ n-1 $ edges. Each vertex $ v $ of this tree has a color assigned to it ( $ a_v = 1 $ if the vertex $ v $ is white and $ 0 $ if the vertex $ v $ is black).

You have to solve the following problem for each vertex $ v $ : what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that contains the vertex $ v $ ? The subtree of the tree is the connected subgraph of the given tree. More formally, if you choose the subtree that contains $ cnt_w $ white vertices and $ cnt_b $ black vertices, you have to maximize $ cnt_w - cnt_b $ .

## 说明/提示

The first example is shown below:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1324F/e1f60f9681db9f4f9199c7a23c4eb447ad36532b.png)

The black vertices have bold borders.

In the second example, the best subtree for vertices $ 2, 3 $ and $ 4 $ are vertices $ 2, 3 $ and $ 4 $ correspondingly. And the best subtree for the vertex $ 1 $ is the subtree consisting of vertices $ 1 $ and $ 3 $ .

## 样例 #1

### 输入

```
9
0 1 1 1 0 0 0 0 1
1 2
1 3
3 4
3 5
2 6
4 7
6 8
5 9```

### 输出

```
2 2 2 2 2 1 1 0 2```

## 样例 #2

### 输入

```
4
0 0 1 0
1 2
1 3
1 4```

### 输出

```
0 -1 1 -1```

# AI分析结果

# 💡 Kay的C++算法解析：Maximum White Subtree 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树形DP + 换根DP (二次扫描与换根)

🗣️ **初步分析**：  
解决“最大白色子树”问题，关键在于**用树形DP计算子树内的贡献，再用换根DP扩展到整棵树**。简单来说：  
- 树形DP像“从叶子往根攒能量”：每个节点先计算自己的“基础能量”（白=+1，黑=-1），再收集子节点的“正能量”（如果子节点的贡献>0，就加进来，因为选这些子树能让总能量更大）。  
- 换根DP像“从根往叶子传能量”：当节点从“子节点”变成“根”时，需要把父节点方向的“其他能量”（父节点去掉当前节点后的贡献）加进来，这样每个节点就能获得**全树范围内的最大能量**。  

**题解思路**：  
所有优质题解都遵循“两次DFS”框架：  
1. 第一次DFS（自底向上）：计算每个节点**仅考虑子树内**的最大贡献（记为`dp[i]`）。  
2. 第二次DFS（自顶向下）：调整每个节点的贡献，将父节点方向的能量整合进来（记为`ans[i]`或`dp2[i]`）。  

**核心难点**：  
- 如何定义DP状态（必须包含当前节点，否则无法保证连通性）；  
- 换根时如何计算父节点的“剩余贡献”（需要减去当前节点对父节点的影响）；  
- 如何合并子树内和父方向的贡献（保证最终结果是包含当前节点的最大连通子树）。  

**可视化设计思路**：  
我们用**8位像素风**模拟树结构（节点用方块表示，白=浅蓝、黑=深灰），动画分两步：  
1. 第一次DFS：从叶子节点开始，节点数值逐渐累加子节点的“正能量”，用**绿色闪烁**标记当前计算的节点，“叮”的音效提示加值操作。  
2. 第二次DFS：从根节点开始，节点数值调整父方向的贡献，用**黄色闪烁**标记换根操作，“嗡”的音效提示调整完成。  
动画支持“单步执行”和“自动播放”，侧边显示当前步骤的伪代码，帮助理解每一步的逻辑。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，它们覆盖了“标准换根DP”“二次扫描优化”“非换根思路”三种典型方法，适合不同学习阶段的同学参考。
</eval_intro>

**题解一：标准换根DP（作者：WYXkk）**  
* **点评**：这份题解是“树形DP+换根DP”的经典实现，思路直白到“看代码就能懂逻辑”。  
  - 思路上：第一次DFS计算子树内贡献`dp[i]`（基础值+子节点正能量）；第二次DFS通过父节点`dp2[f]`减去当前节点的影响（`max(0, dp[i])`），得到父方向的贡献，再加到当前节点的`dp[i]`上，得到最终`dp2[i]`。  
  - 代码上：变量名`dp`（子树内）、`dp2`（换根后）含义明确，链式前向星建图标准，两次DFS的顺序和条件判断严谨。  
  - 亮点：用**最简公式**实现换根（`dp2[i] = max(0, dp2[f] - max(0, dp[i])) + dp[i]`），直接击中换根的核心——“父节点的贡献去掉当前节点的影响”。  

**题解二：二次扫描优化（作者：chenxia25）**  
* **点评**：这份题解用“二次扫描”优化了换根过程，代码更简洁，适合理解“换根的本质是调整DP状态”。  
  - 思路上：第一次DFS算`dp[i]`（同题解一）；第二次DFS时，先**临时修改父节点的dp值**（减去当前节点的贡献），再将父节点的新dp值加到当前节点的dp值上，递归处理子节点后**恢复父节点的dp值**（避免影响其他子节点）。  
  - 代码上：用`ans[i]`记录最终结果，避免额外数组，递归过程中的“修改-恢复”操作巧妙处理了父节点的共享状态。  
  - 亮点：通过**状态回溯**实现换根，不需要额外存储父方向的贡献，代码更紧凑。  

**题解三：非换根思路（作者：夏子汐）**  
* **点评**：这份题解跳出“换根”框架，用`map`记录每个节点对父节点的贡献，通过“父节点贡献减去当前节点的影响”来计算父方向的能量，适合想拓展思路的同学。  
  - 思路上：第一次DFS用`map`记录子节点对父节点的贡献（`v[x][y] = a[y]`当`a[y]>0`）；第二次DFS时，父节点的贡献是`a[fa] - v[fa][x]`（去掉当前节点的影响），如果为正就加到当前节点的`a[x]`上。  
  - 代码上：用`map`处理子节点贡献，虽然复杂度略高（O(n log n)），但逻辑清晰，适合理解“父方向贡献的计算逻辑”。  
  - 亮点：用**非换根方法**实现同样的效果，帮助同学从不同角度理解问题本质。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“抓住连通性”和“处理无根树的所有节点”。以下是三个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何定义DP状态？**  
   - **问题**：必须保证子树包含当前节点（否则连通性无法保证）。  
   - **策略**：定义`dp[i]`为“以i为根的子树中，包含i的连通子树的最大贡献”。基础值为`col[i]`（白=+1，黑=-1），转移时加子节点的`max(0, dp[j])`（只加正能量）。  
   - 💡 **学习笔记**：DP状态必须“绑定当前节点”，否则无法保证连通性！

2. **难点2：换根时如何计算父方向的贡献？**  
   - **问题**：当i从“子节点”变成“根”时，父节点f的贡献包含了i的影响，需要去掉。  
   - **策略**：父方向的贡献 = 父节点的总贡献 - 当前节点对父节点的贡献（即`max(0, dp[i])`）。如果父方向的贡献>0，就加到当前节点的`dp[i]`上。  
   - 💡 **学习笔记**：换根的本质是“调整父节点的贡献，去掉当前节点的影响”！

3. **难点3：如何合并子树内和父方向的贡献？**  
   - **问题**：最终结果需要包含子树内和父方向的所有可能贡献，但不能重复计算。  
   - **策略**：通过两次DFS分别计算子树内（第一次）和父方向（第二次）的贡献，最终结果是两者的和（仅加正能量）。  
   - 💡 **学习笔记**：两次DFS分别处理“子树内”和“父方向”，完美覆盖所有可能的连通子树！

### ✨ 解题技巧总结
- **技巧1：树形DP的状态绑定**：所有树形DP问题中，若要求“包含当前节点”，状态必须绑定该节点（如`dp[i]`表示包含i的子树贡献）。  
- **技巧2：换根的“减法”逻辑**：换根时，父节点的贡献需要减去当前节点的影响，避免重复计算。  
- **技巧3：二次扫描的状态回溯**：修改父节点状态后递归子节点，再恢复父节点状态，避免影响其他子节点（如chenxia25的题解）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择**chenxia25的题解**作为通用核心实现，因为它代码简洁、逻辑清晰，完美体现“树形DP+二次扫描换根”的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自作者chenxia25的题解，是“树形DP+二次扫描换根”的标准实现，逻辑紧凑，易于理解。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  #define pb push_back
  const int N=200000;
  int n;
  bool a[N+1];//a[i]=true表示白点，false表示黑点
  vector<int> nei[N+1];//邻接表存树
  int dp[N+1];//dp[i]：以1为根时，i的子树内包含i的最大贡献
  int ans[N+1];//ans[i]：i的最终答案

  //第一次DFS：自底向上计算dp[i]
  void dfs(int x=1,int fa=0){
      dp[x] = a[x] ? 1 : -1; //基础值：白+1，黑-1
      for(int y : nei[x]){
          if(y == fa) continue;
          dfs(y, x);
          dp[x] += max(0, dp[y]); //加子节点的正能量
      }
  }

  //第二次DFS：自顶向下换根，计算ans[i]
  void dfs0(int x=1,int fa=0){
      ans[x] = dp[x]; //记录当前节点的答案
      for(int y : nei[x]){
          if(y == fa) continue;
          //临时修改父节点x的dp值（去掉y的影响）
          dp[x] -= max(0, dp[y]);
          //将x的新dp值加到y的dp值上（父方向的贡献）
          dp[y] += max(0, dp[x]);
          //递归处理子节点y
          dfs0(y, x);
          //恢复父节点x的dp值（避免影响其他子节点）
          dp[y] -= max(0, dp[x]);
          dp[x] += max(0, dp[y]);
      }
  }

  int main(){
      cin >> n;
      for(int i=1;i<=n;i++) cin >> a[i];
      for(int i=1;i<n;i++){
          int x,y;
          cin >> x >> y;
          nei[x].pb(y);
          nei[y].pb(x);
      }
      dfs(); //第一次DFS计算dp
      dfs0(); //第二次DFS换根计算ans
      for(int i=1;i<=n;i++) cout << ans[i] << " ";
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读入节点数、颜色，用邻接表建树。  
  2. **第一次DFS**：从根（1号节点）开始，自底向上计算每个节点的`dp`值（基础值+子节点正能量）。  
  3. **第二次DFS**：从根开始，自顶向下调整`dp`值——临时修改父节点的`dp`值（去掉当前节点的影响），将父节点的新`dp`值加到当前节点的`dp`值上，递归处理子节点后恢复父节点的`dp`值。  
  4. **输出答案**：`ans`数组存储每个节点的最终结果。

---

<code_intro_selected>
接下来，我们剖析三份优质题解的核心片段，点出各自的亮点：
</code_intro_selected>

### 题解一（WYXkk）：最简换根公式
* **亮点**：用最简公式实现换根，直接体现“父方向贡献”的计算逻辑。
* **核心代码片段**：
  ```cpp
  void dfs2(int u,int f){
      if(u!=1) dp2[u] = max(dp2[f]-max(0,dp[u]), 0) + dp[u];
      for(int i=head[u];i;i=nxt[i]) if(to[i]!=f) dfs2(to[i],u);
  }
  ```
* **代码解读**：  
  - `dp2[f]`是父节点f的最终答案（包含父方向的贡献）。  
  - `dp2[f] - max(0, dp[u])`：父节点f的贡献去掉u的影响（因为f的`dp2`包含u的`dp`值）。  
  - `max(..., 0)`：如果父方向的贡献是负的，就不加（因为选父方向的子树会让总贡献变小）。  
  - 最终`dp2[u]` = 父方向贡献 + u的子树内贡献（`dp[u]`）。
* 💡 **学习笔记**：换根的核心公式就是“父方向贡献（去掉当前节点影响）+ 子树内贡献”！

### 题解二（chenxia25）：状态回溯
* **亮点**：通过“修改-递归-恢复”处理父节点的共享状态，避免额外数组。
* **核心代码片段**：
  ```cpp
  void dfs0(int x=1,int fa=0){
      ans[x] = dp[x];
      for(int y : nei[x]){
          if(y == fa) continue;
          dp[x] -= max(0, dp[y]); //去掉y的影响
          dp[y] += max(0, dp[x]); //加父方向的贡献
          dfs0(y, x); //递归处理y
          dp[y] -= max(0, dp[x]); //恢复y的dp值
          dp[x] += max(0, dp[y]); //恢复x的dp值
      }
  }
  ```
* **代码解读**：  
  - 处理子节点y前，先修改父节点x的`dp`值（去掉y的影响），这样x的`dp`值就代表“x去掉y子树后的贡献”。  
  - 将x的新`dp`值加到y的`dp`值上，此时y的`dp`值就包含了父方向的贡献。  
  - 递归处理y后，恢复x和y的`dp`值，避免影响其他子节点（比如x的下一个子节点z）。
* 💡 **学习笔记**：状态回溯是处理“共享状态”的常用技巧，能避免额外空间！

### 题解三（夏子汐）：非换根思路
* **亮点**：用`map`记录子节点对父节点的贡献，避免换根。
* **核心代码片段**：
  ```cpp
  void dfs(int x,in fa){
      for(int i=fir[x],y;i;i=nex[i]){
          if((y=to[i])==fa)continue;
          dfs(y,x);
          if(a[y]>0)a[x]+=a[y],v[x][y]=a[y]; //记录y对x的贡献
      }
  }
  void dfs2(int x,in fa){
      int T=a[fa]-v[fa][x]; //父节点的贡献去掉x的影响
      if(T>0)a[x]+=T; //加父方向的贡献
      for(int i=fir[x],y;i;i=nex[i]){
          if((y=to[i])==fa)continue;
          dfs2(y,x);
      }
  }
  ```
* **代码解读**：  
  - 第一次DFS用`v[x][y]`记录y对x的贡献（当`a[y]>0`时）。  
  - 第二次DFS时，父节点fa的贡献是`a[fa] - v[fa][x]`（去掉x的影响），如果为正就加到x的`a[x]`上。  
  - 这种方法不需要换根，直接通过`map`记录贡献，逻辑更直观。
* 💡 **学习笔记**：当换根思路难理解时，可以尝试用“记录子节点贡献”的方法！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观看到“树形DP+换根DP”的过程，我设计了一个**8位像素风的动画**，模拟树的生长和能量传递。动画主题是“像素树的能量收集”，融合了复古游戏的音效和交互，让学习更有趣！
</visualization_intro>

### 动画设计方案
#### **1. 整体风格与场景**
- **8位像素风**：节点用16x16的方块表示（白=浅蓝`#87CEEB`，黑=深灰`#696969`），边用2x2的线条连接（棕色`#8B4513`）。  
- **场景布局**：屏幕左侧是像素树，右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块），底部是“伪代码提示区”。  
- **背景音乐**：循环播放8位风格的轻松BGM（类似《超级马里奥》的背景音乐）。

#### **2. 动画核心流程**
**步骤1：初始化树结构**  
- 根节点（1号）位于屏幕中心，子节点向四周扩散（模拟树的生长）。  
- 每个节点显示初始值（白=+1，黑=-1），用**白色数字**标注在方块上。

**步骤2：第一次DFS（自底向上收集能量）**  
- 从最外层的叶子节点开始，依次计算`dp`值：  
  1. 选中的节点用**绿色闪烁**标记（频率2次/秒）。  
  2. 遍历子节点，若子节点的`dp`值>0，就将其加到当前节点的`dp`值上（数字从灰色变为绿色，表示加值）。  
  3. 每次加值时播放“叮”的音效（频率440Hz，时长0.1秒）。  
- 例如：叶子节点4（白，初始值+1）没有子节点，`dp[4]=+1`；父节点3（白，初始值+1）的`dp`值=+1（自己）+ max(0, dp[4])=+1 → `dp[3]=+2`。

**步骤3：第二次DFS（自顶向下换根调整）**  
- 从根节点（1号）开始，依次调整子节点的`dp`值：  
  1. 选中的节点用**黄色闪烁**标记（频率2次/秒）。  
  2. 临时修改父节点的`dp`值（去掉当前节点的影响），用**红色数字**标注父节点的临时值。  
  3. 将父节点的临时值加到当前节点的`dp`值上（数字从绿色变为黄色，表示调整）。  
  4. 每次调整时播放“嗡”的音效（频率220Hz，时长0.1秒）。  
- 例如：根节点1的`dp`值=+2，处理子节点2时，先将根节点的`dp`值减去`max(0, dp[2])`（假设`dp[2]=+1`，则根节点临时值=+1），再将+1加到`dp[2]`上，`dp[2]`变为+2。

**步骤4：完成与交互**  
- 当所有节点的`ans`值计算完成后，播放“胜利”音效（上扬的8位音调），所有节点用**金色闪烁**标记。  
- 支持“单步执行”（点击一次按钮走一步）、“自动播放”（速度滑块调整播放速度）、“重置动画”（回到初始状态）。

#### **3. 关键设计细节**
- **状态高亮**：用不同颜色标记当前操作的节点（绿色=收集子节点能量，黄色=换根调整），帮助区分步骤。  
- **音效提示**：不同操作对应不同音效，强化记忆（“叮”=加子节点能量，“嗡”=换根调整，“胜利”=完成）。  
- **伪代码同步**：底部提示区显示当前步骤的伪代码（如“计算dp[x] = col[x] + sum(max(0, dp[y]))”），帮助理解逻辑。

<visualization_conclusion>
通过这个动画，你可以清晰看到“能量从叶子到根”和“能量从根到叶子”的过程，直观理解“树形DP”和“换根DP”的核心逻辑。下次遇到类似问题时，脑海中就能浮现出这个像素树的动画啦！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“树形DP+换根DP”是处理“无根树所有节点”问题的通用套路，掌握它能解决很多类似题目。以下是几个拓展练习：
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：求每个节点的“最大子树和”（子树节点值的和的最大值）。  
- **场景2**：求每个节点的“最远节点距离”（树的直径的换根问题）。  
- **场景3**：求每个节点的“子树大小”（虽然简单，但换根思路同样适用）。

### **洛谷练习推荐**
1. **洛谷 P1352 没有上司的舞会**  
   - 🗣️ **推荐理由**：经典树形DP问题，要求选择节点使得总快乐值最大（不能选上司和下属），练习“子树内的状态转移”。  
2. **洛谷 P2014 选课**  
   - 🗣️ **推荐理由**：树形DP+背包问题，要求选k门课使得总学分最大（选子课前必须选父课），练习“树形DP与背包的结合”。  
3. **洛谷 P3178 [HAOI2015]树上操作**  
   - 🗣️ **推荐理由**：换根DP的进阶问题，要求支持三种操作（加值、路径加值、求子树和），练习“换根DP的灵活应用”。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了几个宝贵的学习心得，这些都是作者们踩坑后的经验：
</insights_intro>

> **心得1（来自WYXkk）**：“换根时一定要减去当前节点对父节点的影响，否则会重复计算。”  
> **点评**：这是换根DP的核心误区！比如父节点的`dp`值包含了当前节点的贡献，换根时如果不减去，会导致当前节点的`dp`值重复加父节点的贡献。  
> **借鉴**：写换根代码时，先想“父节点的贡献去掉当前节点的影响是什么”。

> **心得2（来自chenxia25）**：“二次扫描的状态回溯很重要，否则会影响其他子节点的计算。”  
> **点评**：比如处理父节点的多个子节点时，如果不恢复父节点的`dp`值，下一个子节点的计算会用到被修改过的`dp`值，导致错误。  
> **借鉴**：处理共享状态时，一定要“修改-递归-恢复”。

> **心得3（来自夏子汐）**：“当换根思路难理解时，可以尝试用map记录子节点的贡献。”  
> **点评**：换根思路需要“逆向思考”，对新手来说可能有点难。用map记录贡献是“正向思考”，更容易理解。  
> **借鉴**：遇到困难时，换个角度想问题，可能会有突破！  


## 结语
本次关于“Maximum White Subtree”的分析就到这里啦！希望这份指南能帮助你掌握“树形DP+换根DP”的核心逻辑。记住：**树形DP的关键是“绑定当前节点”，换根DP的关键是“调整父节点的贡献”**。下次遇到无根树的问题时，不妨试试“两次DFS”的套路，你会发现很多问题都能迎刃而解！💪

--- 
**提示**：如果想尝试动画演示，可以用HTML5 Canvas+JavaScript实现（比如用`ctx.fillRect`画像素节点，用`AudioContext`播放音效），核心逻辑就是模拟两次DFS的过程。赶紧动手试试吧！

---
处理用时：534.59秒
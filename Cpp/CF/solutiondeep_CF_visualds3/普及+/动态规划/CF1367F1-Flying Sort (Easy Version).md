# 题目信息

# Flying Sort (Easy Version)

## 题目描述

This is an easy version of the problem. In this version, all numbers in the given array are distinct and the constraints on $ n $ are less than in the hard version of the problem.

You are given an array $ a $ of $ n $ integers (there are no equals elements in the array). You can perform the following operations on array elements:

1. choose any index $ i $ ( $ 1 \le i \le n $ ) and move the element $ a[i] $ to the begin of the array;
2. choose any index $ i $ ( $ 1 \le i \le n $ ) and move the element $ a[i] $ to the end of the array.

For example, if $ n = 5 $ , $ a = [4, 7, 2, 3, 9] $ , then the following sequence of operations can be performed:

- after performing the operation of the first type to the second element, the array $ a $ will become $ [7, 4, 2, 3, 9] $ ;
- after performing the operation of the second type to the second element, the array $ a $ will become $ [7, 2, 3, 9, 4] $ .

You can perform operations of any type any number of times in any order.

Find the minimum total number of operations of the first and second type that will make the $ a $ array sorted in non-decreasing order. In other words, what is the minimum number of operations that must be performed so the array satisfies the inequalities $ a[1] \le a[2] \le \ldots \le a[n] $ .

## 说明/提示

In the first test case, you first need to move 3, and then 2 to the beginning of the array. Therefore, the desired sequence of operations: $ [4, 7, 2, 3, 9] \rightarrow [3, 4, 7, 2, 9] \rightarrow [2, 3, 4, 7, 9] $ .

In the second test case, you need to move the 1 to the beginning of the array, and the 8 — to the end. Therefore, the desired sequence of operations: $ [3, 5, 8, 1, 7] \rightarrow [1, 3, 5, 8, 7] \rightarrow [1, 3, 5, 7, 8] $ .

In the third test case, the array is already sorted.

## 样例 #1

### 输入

```
4
5
4 7 2 3 9
5
3 5 8 1 7
5
1 4 5 7 12
4
0 2 1 3```

### 输出

```
2
2
0
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：Flying Sort (Easy Version) 深入学习指南 💡

<introduction>
  今天我们来一起分析「Flying Sort (Easy Version)」这道C++编程题。这道题的核心是**用最少的“移动到开头/结尾”操作让数组有序**，看起来有点挑战性，但只要抓住“找最长不用动的序列”这个关键，就能迎刃而解！本指南会帮你梳理思路、理解算法，并通过像素动画直观看到过程～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 离散化技巧

🗣️ **初步分析**：
解决这道题的关键，在于理解**“最少操作 = 总元素数 - 最长不用动的元素数”**——就像整理书包时，先找出“已经摆对位置的书”，剩下的只需调整到最前或最后。而这里的“不用动的元素”，必须满足**值域连续递增**（比如1→2→3，或者3→4→5），因为它们的相对顺序已经符合最终排序要求。

那怎么找最长的“值域连续递增子序列”呢？这就要用到**动态规划（DP）**啦！DP就像“搭积木”：每一步都基于之前的结果，逐步累积最长序列的长度。具体来说：
- 我们先把原数组**离散化**（因为原数组数值可能很大，比如1e9，但元素数量最多3e3，离散化后变成1到n的排列，方便处理）；
- 定义`dp[x]`表示“以离散化后的值x结尾的最长连续递增子序列长度”；
- 转移方程很简单：`dp[x] = dp[x-1] + 1`（如果x-1存在的话，否则dp[x]=1）——比如x=3时，若之前有2的最长序列是2，那3的最长序列就是3。

**核心难点**：把“最少操作”问题转化为“最长不用动序列”问题（逆向思维），以及离散化的正确应用。**可视化设计思路**：我们会用像素动画展示离散化后的数组，每遍历一个元素就更新对应的dp值（用颜色深浅表示长度），最后高亮最长的连续序列——就像“点亮”那些不用动的元素，剩下的就是要移动的！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实践价值等方面筛选了3份优质题解，帮你快速掌握核心解法～
</eval_intro>

**题解一：作者F_Mu（赞：5）**
* **点评**：这份题解的思路最简洁，直接命中问题本质！作者先用`map`记录原数组元素的位置，再通过排序离散化（把原数组变成1到n的排列），然后用DP计算最长连续序列。代码中的`dp[a[i]] = dp[a[i]-1] + 1`直接对应转移方程，逻辑直白；`maxx`变量实时更新最长长度，最后用`n - maxx`得到答案。特别值得学习的是**离散化的处理方式**——用`map`关联原元素和位置，再重新赋值，步骤清晰。

**题解二：作者_Kenma_（赞：0）**
* **点评**：这题解的优势是**多组测试用例的处理**！作者用`lower_bound`离散化（更通用的写法），并且在每组测试后主动初始化`f`数组和`maxn`变量（避免多测干扰）。代码中的`f[a[i]] = f[a[i]-1] +1`和题解一异曲同工，但`unique`函数的使用更标准（处理重复元素，不过本题无重复，但习惯很好）。对于初学者来说，这种“规范处理多测”的习惯非常重要～

**题解三：作者August_Light（赞：0）**
* **点评**：这份题解最适合**入门学习者**！作者专门写了`Discrete`命名空间封装离散化函数，还给出了前置知识（离散化模板题），非常贴心。此外，作者用`pos`数组记录每个离散化后的值的位置，再通过`pos[p[i]-1] < i`判断“x-1是否在x前面”——这其实是题解一的另一种表达（因为离散化后的数组顺序就是原数组顺序），帮助你理解“连续递增”的条件。代码中的`write`函数（快写）也体现了竞赛编程的优化意识～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**问题转化**和**离散化**，结合优质题解的经验，我帮你提炼了3个核心关键点：
</difficulty_intro>

1.  **关键点1：逆向思维——把“最少操作”变成“最长不用动序列”**
    * **分析**：直接想“怎么移动最少”很难，但反过来想“最多能留下多少不用动的元素”就简单了。这些不用动的元素必须满足：**它们在原数组中的相对顺序，和最终排序后的顺序一致**（比如最终排序是2→3→4→7→9，原数组中的3→4→7就是不用动的）。而因为最终排序是递增的，所以这些元素的**值域必须连续**（比如2→3→4是连续的，2→4→7不是）——否则中间的元素（比如3）会被移动，破坏连续。
    * 💡 **学习笔记**：逆向思维是解决“最少操作”问题的常用技巧！

2.  **关键点2：离散化——处理大数值数组**
    * **分析**：原数组的数值可能很大（比如1e9），但元素数量最多3e3。离散化就是把这些大数值“压缩”成1到n的排列（比如原数组是[4,7,2,3,9]，离散化后变成[3,4,1,2,5]）。这样做的好处是：**把“数值大小的比较”转化为“1到n的顺序比较”**，方便DP数组的处理（因为DP数组的下标可以直接对应离散后的值）。
    * 💡 **学习笔记**：当数组数值大但数量小时，第一反应就是离散化！

3.  **关键点3：DP状态的定义与转移**
    * **分析**：DP的核心是“状态定义”——这里`dp[x]`表示“以离散后的值x结尾的最长连续递增子序列长度”。转移方程`dp[x] = dp[x-1] +1`的逻辑是：如果x的前一个数（x-1）已经存在，那么x可以接在x-1的后面，延长序列；否则x自己作为新序列的开头。比如离散后的值是3，若dp[2]=2（表示以2结尾的最长序列是2），那么dp[3]就是3（2+1）。
    * 💡 **学习笔记**：DP的状态定义要“贴紧问题核心”——这里的核心是“连续递增”，所以状态要关联“当前值”和“前一个值”。

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用技巧，帮你举一反三：
</summary_best_practices>
- **技巧1：逆向思维**：遇到“最少操作”问题，先想“最多保留什么”，往往更容易找到突破口；
- **技巧2：离散化模板**：记住离散化的三步：①复制原数组→②排序去重→③用lower_bound映射原元素到新值；
- **技巧3：DP简化**：当转移方程只依赖前一个状态时，不需要复杂的循环，直接遍历数组更新即可（比如本题的DP是O(n)时间）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——综合了三个题解的优点，结构清晰，适合入门学习～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码整合了离散化、DP计算和多测处理，逻辑简洁，覆盖所有核心步骤。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    const int MAXN = 3e3 + 10;
    int a[MAXN], b[MAXN], dp[MAXN];

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
        int T;
        cin >> T;
        while (T--) {
            int n;
            cin >> n;
            for (int i = 1; i <= n; ++i) {
                cin >> a[i];
                b[i] = a[i]; // 复制原数组用于离散化
            }
            // 步骤1：离散化
            sort(b + 1, b + n + 1);
            for (int i = 1; i <= n; ++i) {
                // 用lower_bound找到a[i]在b中的位置，作为离散后的值
                a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;
            }
            // 步骤2：DP计算最长连续递增子序列
            int max_len = 0;
            fill(dp, dp + n + 2, 0); // 初始化dp数组为0
            for (int i = 1; i <= n; ++i) {
                dp[a[i]] = dp[a[i] - 1] + 1; // 转移方程
                if (dp[a[i]] > max_len) {
                    max_len = dp[a[i]];
                }
            }
            // 步骤3：计算答案
            cout << n - max_len << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：①**离散化**（把原数组变成1到n的排列）；②**DP计算**（遍历数组更新dp值，找最长连续序列）；③**输出答案**（总元素数减去最长序列长度）。关键数据结构是`a`数组（离散后的值）和`dp`数组（记录最长长度）。


<code_intro_selected>
接下来剖析三个优质题解的**核心片段**，看看它们的亮点～
</code_intro_selected>

**题解一：作者F_Mu**
* **亮点**：用`map`记录原元素位置，离散化更直观。
* **核心代码片段**：
    ```cpp
    map<int, int> mp;
    rep(i, 1, n) cin >> a[i], b[i] = a[i], mp[a[i]] = i;
    sort(b + 1, b + n + 1);
    rep(i, 1, n) a[mp[b[i]]] = i; // 重新赋值离散后的值
    ```
* **代码解读**：
    > 这里用`map`把原元素`a[i]`和它的位置`i`关联起来。排序`b`数组后，`b[i]`是原数组的第i小元素，所以`mp[b[i]]`就是原数组中第i小元素的位置——然后把这个位置的`a`值设为`i`，完成离散化。这种方法的好处是“直接对应原位置”，适合理解离散化的本质。
* 💡 **学习笔记**：`map`可以用来关联“值”和“位置”，是离散化的另一种实现方式。

**题解二：作者_Kenma_**
* **亮点**：多测初始化更严谨。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        f[a[i]]=0; // 每组测试后重置f数组
    }
    maxn=0; // 重置最长长度
    ```
* **代码解读**：
    > 多组测试用例时，一定要重置全局变量！比如`f`数组（即dp数组）和`maxn`变量，如果不重置，上一组的结果会影响下一组。这是竞赛编程中最容易犯的错误之一，题解二的处理很规范。
* 💡 **学习笔记**：多测问题的“清空习惯”要牢记！

**题解三：作者August_Light**
* **亮点**：用`pos`数组判断连续条件。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= n; i++) pos[p[i]] = i; // p是离散后的数组
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        if (pos[p[i] - 1] < i) // 前一个数是否在当前数前面
            f[i] += f[pos[p[i] - 1]];
        ans = max(ans, f[i]);
    }
    ```
* **代码解读**：
    > `pos[x]`记录离散后的值x在原数组中的位置。`pos[p[i]-1] < i`表示“x-1（p[i]-1）的位置在当前元素（p[i]）的前面”——这其实是“连续递增”的另一种表达（因为原数组的顺序就是遍历顺序）。比如p[i]是3，pos[2]是2（表示2在原数组的第2位），而i是3（当前元素在第3位），那么2在3前面，可以接成连续序列。
* 💡 **学习笔记**：`pos`数组可以帮助判断元素的相对位置，是处理“顺序问题”的常用技巧。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法过程，我设计了一个**8位像素风的动画**——就像玩FC游戏一样，一步步理解离散化和DP的作用！
</visualization_intro>

  * **动画演示主题**：像素探险家“小K”在数组迷宫中寻找“最长不用动的连续序列”，每找到一个连续元素就点亮一盏灯～
  * **核心演示内容**：展示离散化后的数组、DP数组的更新、最长序列的高亮，以及最终需要移动的元素数量。
  * **设计思路简述**：用8位像素风营造复古游戏感，让学习更轻松；用颜色高亮关键元素（比如当前遍历的元素、DP值更新的位置），用音效强化操作记忆（比如离散化完成时“叮”的一声，DP更新时“滴”的一声）。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**（FC风格）：
        * 屏幕左侧是**离散化前的数组**（用大像素块显示数值，比如[4,7,2,3,9]），右侧是**离散化后的数组**（初始为空白）。
        * 底部控制面板有“开始”“单步”“重置”按钮，以及速度滑块（从“慢”到“快”）。
        * 播放8位风格的轻快BGM（比如《超级马里奥》的背景音乐片段）。
    2.  **离散化过程演示**：
        * 第一步：复制原数组到`b`数组（右侧显示`b`数组的排序过程，像素块从乱序到升序）。
        * 第二步：用`lower_bound`映射原元素到离散后的值（比如原元素4对应离散后的值3，右侧数组的第1位变成3，伴随“叮”的音效）。
        * 离散化完成后，右侧数组显示离散后的结果（比如[3,4,1,2,5]），并闪烁提示“离散化完成！”。
    3.  **DP计算过程演示**：
        * 遍历离散后的数组（从左到右），每个元素用**红色像素框**高亮（表示当前处理的元素）。
        * 对于当前元素`x`（比如x=3），找到`x-1`（即2）的DP值（比如dp[2]=2），然后更新dp[3]为3（2+1）——用**蓝色填充**dp[3]的位置，表示长度增加。
        * 每更新一次dp值，播放“滴”的音效；如果当前dp值是最长的，用**黄色高亮**该位置（比如dp[3]=3是当前最长，黄色填充）。
    4.  **结果展示**：
        * 遍历结束后，高亮最长连续序列的元素（比如离散后的[1,2,3,4]，用绿色填充），并显示“最长不用动序列长度：4”。
        * 计算需要移动的元素数（5-4=1），用**红色叉号**标记需要移动的元素（比如离散后的5），伴随“胜利”音效（比如《魂斗罗》的通关音乐片段）。
    5.  **交互功能**：
        * 单步执行：点击“单步”按钮，每一步只处理一个元素，方便仔细观察。
        * 自动播放：点击“开始”按钮，动画自动执行，速度可通过滑块调节（慢=1秒/步，快=0.2秒/步）。
        * 重置：点击“重置”按钮，回到初始状态，重新演示。

<visualization_conclusion>
通过这个动画，你可以清楚看到**离散化如何压缩数值**、**DP如何累积最长序列**，以及**最少操作数如何计算**。就像玩游戏一样，一步步“通关”算法难点！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心技巧（离散化+最长连续递增子序列）可以迁移到很多问题中，比如“最少删除数让数组连续”“最长连续子数组”等。下面推荐几道洛谷的相似题目，帮你巩固知识点～
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 离散化：适用于“数值大但数量小”的数组问题（比如统计频率、比较大小）；
    - 最长连续递增子序列：适用于“找最长不用修改的序列”问题（比如最少修改数让数组有序、最少删除数让数组连续）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 B3694** - 数列离散化
          * 🗣️ **推荐理由**：这是离散化的模板题，帮你熟练掌握离散化的三步法（复制→排序去重→映射）。
    2.  **洛谷 P1020** - 导弹拦截
          * 🗣️ **推荐理由**：这道题考察最长递增子序列（LIS），是DP的经典应用，帮你巩固“状态定义与转移”的思路。
    3.  **洛谷 P2501** - [HAOI2006]数字序列
          * 🗣️ **推荐理由**：这道题需要找“最长连续递增子序列”，和本题的核心思路一致，是很好的拓展练习。
    4.  **洛谷 P1115** - 最大子段和
          * 🗣️ **推荐理由**：这道题考察DP的“累积最大值”思路，帮你理解DP的另一种应用场景。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了2条非常实用的经验，帮你避免踩坑～
</insights_intro>

> **经验1（来自F_Mu）**：离散化时可以用`map`关联“值”和“位置”，这种方法更直观，适合理解离散化的本质。
> **点评**：`map`的键值对特性刚好对应“原元素”和“原位置”，对于初学者来说，这种方式比`lower_bound`更容易理解，建议先从`map`开始学离散化，再过渡到`lower_bound`。

> **经验2（来自_Kenma_）**：多组测试用例一定要重置全局变量！比如`f`数组和`maxn`变量，如果不重置，上一组的结果会影响下一组。
> **点评**：这是竞赛编程中最容易犯的错误之一，比如第一组测试的`f`数组没清空，第二组测试的`f`值会包含上一组的残留，导致答案错误。养成“多测清空”的习惯，能帮你避免很多低级bug。


<conclusion>
本次关于「Flying Sort (Easy Version)」的分析就到这里啦！这道题的核心是**逆向思维+离散化+DP**，只要掌握了这三个技巧，类似的问题都能迎刃而解。记住：编程的进步在于“理解本质”+“多练多想”——下次遇到“最少操作”问题，不妨先想“最多能保留什么”，说不定就能找到突破口～💪
</conclusion>

---

---
处理用时：1091.17秒
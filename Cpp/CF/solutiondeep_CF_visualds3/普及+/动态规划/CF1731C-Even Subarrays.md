# 题目信息

# Even Subarrays

## 题目描述

You are given an integer array $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ).

Find the number of subarrays of $ a $ whose $ \operatorname{XOR} $ has an even number of divisors. In other words, find all pairs of indices $ (i, j) $ ( $ i \le j $ ) such that $ a_i \oplus a_{i + 1} \oplus \dots \oplus a_j $ has an even number of divisors.

For example, numbers $ 2 $ , $ 3 $ , $ 5 $ or $ 6 $ have an even number of divisors, while $ 1 $ and $ 4 $ — odd. Consider that $ 0 $ has an odd number of divisors in this task.

Here $ \operatorname{XOR} $ (or $ \oplus $ ) denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Print the number of subarrays but multiplied by 2022... Okay, let's stop. Just print the actual answer.

## 说明/提示

In the first test case, there are $ 4 $ subarrays whose $ \operatorname{XOR} $ has an even number of divisors: $ [3] $ , $ [3,1] $ , $ [1,2] $ , $ [2] $ .

In the second test case, there are $ 11 $ subarrays whose $ \operatorname{XOR} $ has an even number of divisors: $ [4,2] $ , $ [4,2,1] $ , $ [4,2,1,5] $ , $ [2] $ , $ [2,1] $ , $ [2,1,5] $ , $ [2,1,5,3] $ , $ [1,5,3] $ , $ [5] $ , $ [5,3] $ , $ [3] $ .

In the third test case, there is no subarray whose $ \operatorname{XOR} $ has an even number of divisors since $ \operatorname{XOR} $ of any subarray is either $ 4 $ or $ 0 $ .

## 样例 #1

### 输入

```
4
3
3 1 2
5
4 2 1 5 3
4
4 4 4 4
7
5 7 3 7 1 7 3```

### 输出

```
4
11
0
20```

# AI分析结果

# 💡 Kay的C++算法解析：Even Subarrays 深入学习指南 💡

<introduction>
  今天我们来一起分析「Even Subarrays」这道C++编程题。题目要求统计数组中**异或和有偶数个因数**的子数组数量，看似复杂，但只要抓住「完全平方数」的性质，用「补集思想」+「前缀异或」+「哈希计数」就能轻松解决！本指南会帮你理清思路、掌握核心技巧，还会用像素动画直观展示算法流程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：补集思想 + 前缀异或 + 哈希计数（编程技巧应用）

🗣️ **初步分析**：
> 解决这道题的关键，是先把问题「反过来想」——因为**有偶数个因数的数 ≡ 不是完全平方数**（完全平方数的因数成对出现，只有平方数的平方根会重复，所以因数个数是奇数）。题目要求的结果 = 总子数组数 - 异或和为完全平方数的子数组数。  
> 总子数组数很好算：`n*(n+1)/2`（比如长度为4的数组有4+3+2+1=10个子数组）。难点是**快速统计异或和为完全平方数的子数组数**，这里要用到「前缀异或」和「哈希计数」：  
> - 前缀异或：定义`s[i] = a[1]^a[2]^…^a[i]`（`s[0]=0`），那么区间`[l,r]`的异或和 = `s[r]^s[l-1]`（异或的逆运算还是异或）。  
> - 哈希计数：要找`[l,r]`使得`s[r]^s[l-1] = x`（x是完全平方数），等价于找`s[l-1] = s[r]^x`。我们用一个「桶」（数组或哈希表）统计之前出现过的`s`值的次数，每次遍历到`s[r]`时，枚举所有可能的完全平方数`x`，累加桶中`s[r]^x`的次数即可。  
> 完全平方数的数量很少（比如n=2e5时，最大的完全平方数不超过2e5*2=4e5，对应平方根约632），所以枚举的时间成本很低！

   - **核心难点**：① 想到用补集转换问题；② 正确应用前缀异或；③ 确定完全平方数的枚举范围（不能只到n，要到2n，因为异或后的结果可能超过n）。  
   - **可视化设计思路**：用8位像素风格展示「前缀异或计算」「哈希桶更新」「枚举平方数」的过程——比如屏幕左边是数组元素（像素块），中间是前缀异或`s[i]`的动态变化（每次异或后闪烁），右边是哈希桶（用堆叠的像素块表示每个`s`值的出现次数）。当处理到`s[r]`时，枚举的平方数会以「小弹框」形式出现，对应的`s[r]^x`在哈希桶中高亮，同时显示累加的次数。  
   - **游戏化元素**：加入「过关音效」（每次正确统计一个子数组时播放「叮」的像素音）、「进度条」（显示当前处理到第几个元素），让学习更有趣～


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度」「代码可读性」「算法有效性」三个维度筛选了3份优质题解，帮你快速掌握核心逻辑～
</eval_intro>

**题解一：(来源：Jasper08)**
* **点评**：这份题解的思路非常直白——用前缀异或`s`数组，再用`nums`桶统计`s`的出现次数。核心亮点是**枚举平方数的范围控制**（j到650，刚好覆盖4e5的平方根），避免了不必要的计算。代码风格简洁，变量名`nums`（桶）、`s`（前缀异或）含义明确，边界处理（`nums[0]++`初始化）也很严谨。从实践角度看，这份代码可以直接用于竞赛，时间复杂度`O(Tn√n)`完全能通过题目限制。

**题解二：(来源：Engulf)**
* **点评**：此题解的「容斥思想」讲解得很清晰——直接用总数减不符合条件的数量。代码中用`vector<int> cnt`作为哈希桶，枚举平方数时增加了「`(pre ^ j*j) <= 2*n`」的判断，避免越界，这是很实用的细节。整体逻辑流畅，适合新手理解「补集转换」的核心。

**题解三：(来源：tZEROちゃん)**
* **点评**：这份题解的亮点是**预生成所有可能的完全平方数**（`init`函数），避免了每次枚举时重复计算平方数。代码结构清晰，`sum`数组统计前缀异或，`perfectSquare`数组存储预计算的平方数，可读性很高。特别是「处理完每组数据后清空`sum`数组」的操作，避免了多组数据之间的干扰，是很重要的编程习惯。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到的「卡壳点」主要是三个——问题转换、前缀异或应用、平方数范围。结合优质题解，我帮你梳理了对应的解决策略：
</difficulty_intro>

1.  **关键点1：为什么要用补集转换？**
    * **分析**：直接统计「异或和有偶数个因数」的子数组，需要判断每个子数组的异或和是否为非完全平方数，这会遍历所有`O(n²)`个子数组，时间复杂度太高。而完全平方数的数量只有`O(√n)`个，用「总数减不符合条件的数量」能把时间复杂度降到`O(n√n)`，这是「正难则反」的典型应用！
    * 💡 **学习笔记**：遇到「统计满足某条件的数量」时，先想「补集」——如果不符合条件的情况更少，就用总数减！

2.  **关键点2：前缀异或是怎么简化问题的？**
    * **分析**：区间异或和的计算原本需要遍历区间内的所有元素，但前缀异或将其转化为「两个前缀的异或」（`s[r]^s[l-1]`）。这样一来，统计「异或和为x」的子数组数，就变成了统计「有多少对`(i,j)`满足`s[j]^s[i] = x`」，这可以用哈希桶快速实现（每次记录`s[j]`的出现次数，查询`s[j]^x`的历史次数）。
    * 💡 **学习笔记**：前缀异或是处理「区间异或」问题的「瑞士军刀」，一定要记住这个转化公式！

3.  **关键点3：完全平方数要枚举到多大？**
    * **分析**：题目中`a[i] ≤ n`，但前缀异或`s[i]`的最大值可能达到`2n`（比如数组全是n，异或多次后可能超过n）。所以完全平方数要枚举到`(2n)`的平方根（比如n=2e5时，2n=4e5，平方根约632）。如果枚举范围太小，会漏掉一些情况（比如样例2中的异或和可能达到较大的平方数）。
    * 💡 **学习笔记**：枚举范围不是「拍脑袋」定的，要根据「变量的可能最大值」计算！

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用解题技巧，帮你举一反三：
</summary_best_practices>
-   **技巧1：正难则反**：当直接统计目标情况麻烦时，试试总数减「反情况」的数量（比如本题中的「非完全平方数」转「完全平方数」）。
-   **技巧2：前缀预处理**：处理区间问题（和、异或、乘积等）时，先算前缀数组，把区间操作转化为两点操作。
-   **技巧3：哈希计数**：统计「满足某种关系的 pairs 数量」时，用哈希表/数组记录历史值的出现次数，避免双重循环。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——综合了优质题解的思路，代码简洁且覆盖所有关键逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了「前缀异或」「哈希桶计数」「预生成平方数」的思路，逻辑清晰，适合新手模仿。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <cstring>
    using namespace std;

    typedef long long ll;
    const int MAX_SQUARE = 650; // 650² ≈ 4e5，覆盖2n的情况

    vector<int> perfect_squares;

    void init() {
        for (int i = 0; i <= MAX_SQUARE; ++i) {
            perfect_squares.push_back(i * i);
        }
    }

    int main() {
        init();
        int t;
        cin >> t;
        while (t--) {
            int n;
            cin >> n;
            vector<int> a(n + 1);
            vector<int> s(n + 1, 0); // 前缀异或数组，s[0]=0
            for (int i = 1; i <= n; ++i) {
                cin >> a[i];
                s[i] = s[i - 1] ^ a[i];
            }

            vector<int> cnt(2 * n + 5, 0); // 哈希桶，统计s的出现次数
            cnt[0] = 1;
            ll bad = 0; // 异或和为完全平方数的子数组数
            for (int i = 1; i <= n; ++i) {
                for (int x : perfect_squares) {
                    int target = s[i] ^ x;
                    if (target <= 2 * n) { // 避免越界
                        bad += cnt[target];
                    }
                }
                cnt[s[i]]++; // 记录当前s[i]的出现次数
            }

            ll total = (ll)n * (n + 1) / 2;
            cout << total - bad << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. `init`函数预生成所有可能的完全平方数（到650²）；  
    > 2. 输入多组数据，每组数据先计算前缀异或数组`s`；  
    > 3. 用`cnt`数组（哈希桶）统计`s`的出现次数，初始时`s[0]`出现1次；  
    > 4. 遍历每个`s[i]`，枚举所有完全平方数`x`，累加`cnt[s[i]^x]`（即之前出现过的`s[j] = s[i]^x`的次数，对应子数组`[j+1,i]`的异或和为`x`）；  
    > 5. 计算总子数组数`total`，减去`bad`（异或和为完全平方数的数量），得到结果。

---
<code_intro_selected>
接下来剖析3份优质题解的核心片段，看看它们的「亮点」在哪里：
</code_intro_selected>

**题解一：(来源：Jasper08)**
* **亮点**：用`nums`数组作为哈希桶，直接覆盖可能的`s`值范围（`M=1e6+10`），避免了`vector`的动态扩容，速度更快。
* **核心代码片段**：
    ```cpp
    const int N = 2e5+10, M = 1e6+10;
    int nums[M]; // 哈希桶，统计s的出现次数

    // 主循环部分
    nums[0] ++;
    for (int i = 1; i <= n; ++i) {
        int cnt = i; // 初始化为当前可能的最大子数组数（以i为右端点的子数组有i个）
        for (int j = 0; j <= 650; ++j) {
            int t = j * j ^ s[i];
            if (nums[t])
                cnt -= nums[t]; // 减去异或和为完全平方数的子数组数
        }
        nums[s[i]] ++;
        ans += cnt; // 累加满足条件的子数组数
    }
    ```
* **代码解读**：
    > 这段代码的思路是「直接统计满足条件的子数组数」——以`i`为右端点的子数组有`i`个（`[1,i],[2,i],…,[i,i]`），减去其中异或和为完全平方数的数量（`cnt -= nums[j*j^s[i]]`），剩下的就是满足条件的数量。这种写法不需要计算`total - bad`，更直接！
* 💡 **学习笔记**：统计「满足条件的数量」可以有两种方式——「直接算」或「总数减反情况」，选择哪种取决于哪种更简单。

**题解二：(来源：Engulf)**
* **亮点**：用`vector<int> cnt`动态调整大小（`2*n+5`），节省空间，同时避免越界。
* **核心代码片段**：
    ```cpp
    vector<int> cnt(2 * n + 5);
    cnt[0] ++ ;
    LL res = (LL)n * (n + 1) / 2; // 总子数组数
    int pre = 0;
    for (int i = 1, x; i <= n; i ++ ) {
        scanf("%d", &x);
        pre ^= x; // 实时计算前缀异或，不用存数组
        for (int j = 0; (pre ^ j * j) <= 2 * n; j ++ )
            res -= cnt[pre ^ j * j]; // 减去异或和为完全平方数的数量
        cnt[pre] ++ ;
    }
    ```
* **代码解读**：
    > 这里没有预存前缀异或数组`s`，而是用`pre`变量实时计算（`pre ^= x`），节省了`O(n)`的空间。同时，`cnt`的大小是`2*n+5`，刚好覆盖`pre`的可能范围，避免了数组过大或越界。
* 💡 **学习笔记**：如果不需要保存所有前缀值，可以用「滚动变量」实时计算，节省空间。

**题解三：(来源：tZEROちゃん)**
* **亮点**：预生成所有完全平方数，避免每次枚举时重复计算，代码更简洁。
* **核心代码片段**：
    ```cpp
    vector<int> perfectSquare;
    void init() {
       for (int i = 0; i * i <= 5e5; ++i) {
          perfectSquare.push_back(i * i);
       }   
    }

    // 主循环部分
    long long ans = 0;
    sum[0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int x : perfectSquare) {
            ans += sum[s[i] ^ x]; // 累加异或和为x的子数组数
        }
        sum[s[i]]++; 
    }
    ans = n * (n + 1) / 2 - ans;
    ```
* **代码解读**：
    > `init`函数预生成所有`i*i ≤5e5`的完全平方数，这样在主循环中直接遍历`perfectSquare`数组即可，不用每次计算`j*j`。这种「预计算」的技巧能让代码更简洁，也避免了重复计算的开销。
* 💡 **学习笔记**：对于「多次使用的常量」（比如完全平方数），可以提前预计算，提升代码可读性和效率。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地「看」到算法的运行过程，我设计了一个**8位像素风格的动画**，结合「复古游戏」元素，让学习更有趣！
</visualization_intro>

  * **动画演示主题**：像素探险家「小K」在「异或森林」中寻找「完全平方数果实」，通过收集「前缀异或宝石」和「哈希桶金币」，统计不符合条件的子数组数。

  * **设计思路简述**：
    - 用FC红白机的8位像素风格（比如《超级马里奥》的色彩），营造复古氛围；
    - 用「小K移动」表示遍历数组元素，「宝石闪烁」表示计算前缀异或，「金币堆叠」表示哈希桶计数；
    - 加入「像素音效」（比如「叮」表示累加计数，「哗啦」表示哈希桶更新），强化操作记忆；
    - 用「进度条」和「得分板」展示当前处理进度和统计结果，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧是「异或森林」（数组元素用不同颜色的像素树表示，比如a[1]=3是绿色树，a[2]=1是红色树）；
          * 屏幕中间是「前缀异或宝石台」（显示当前的`s[i]`，比如`s[0]=0`是蓝色宝石，`s[1]=3`是绿色宝石）；
          * 屏幕右侧是「哈希桶金库」（用堆叠的金币表示每个`s`值的出现次数，比如`s[0]`出现1次是1堆金币）；
          * 底部控制面板有「开始/暂停」「单步执行」「重置」按钮，以及「速度滑块」（控制动画播放速度）。

    2.  **算法启动**：
          * 小K从左侧出发，走到第一棵树（a[1]=3），触发「异或动画」——蓝色宝石（s[0]=0）与绿色树（a[1]=3）碰撞，变成绿色宝石（s[1]=3），伴随「滋滋」的异或音效；
          * 哈希桶金库中，绿色宝石对应的金币堆增加1（`cnt[3]++`），伴随「哗啦」的金币声。

    3.  **核心步骤演示**：
          * 小K走到第二棵树（a[2]=1），计算`s[2] = s[1]^1 = 3^1=2`（绿色宝石与红色树碰撞，变成黄色宝石）；
          * 枚举完全平方数（从0开始）：
              - 第一个平方数是0，计算`target = s[2]^0 = 2`，哈希桶金库中黄色金币堆的数量是0（还没出现过），所以不加；
              - 第二个平方数是1，计算`target = 2^1=3`，哈希桶中绿色金币堆有1个，所以「bad」增加1，伴随「叮」的音效；
              - 第三个平方数是4，计算`target=2^4=6`，哈希桶中没有，不加；
          * 哈希桶金库中黄色金币堆增加1（`cnt[2]++`）。

    4.  **目标达成**：
          * 当小K遍历完所有树，屏幕显示「总子数组数」和「bad数」，计算「结果=总-bad」，伴随「胜利音乐」（8位风格的《超级马里奥》过关音效）；
          * 如果没有符合条件的子数组（比如样例3），显示「没有找到目标！」，伴随「提示音效」（短促的「哔」声）。

  * **旁白提示**：
      * （小K走到第一棵树时）：「现在处理第1个元素，计算前缀异或s[1] = s[0]^a[1] = 0^3=3！」
      * （枚举平方数时）：「现在枚举平方数0，target = s[2]^0=2，哈希桶中2的次数是0，所以不加～」
      * （统计bad数时）：「找到一个异或和为1的子数组！bad数加1～」

<visualization_conclusion>
通过这个动画，你能清晰看到「前缀异或的计算」「哈希桶的更新」「枚举平方数的过程」——每一步的变化都有视觉和听觉的提示，再也不用死记硬背算法逻辑啦！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心技巧（补集思想、前缀异或、哈希计数）能解决很多类似问题，比如「统计异或和为k的子数组数」「统计和为k的子数组数」等。下面推荐几道洛谷的练习，帮你巩固这些技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 前缀异或：用于「区间异或」问题，转化为「两点异或」；
    - 哈希计数：用于「统计满足某种关系的 pairs 数量」，避免双重循环；
    - 补集思想：用于「直接统计麻烦」的问题，比如「统计非零和子数组数」（总数减和为零的数量）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1833 樱花**
          * 🗣️ **推荐理由**：这道题需要统计「和为k的子数组数」，用「前缀和+哈希计数」的思路，和本题的「前缀异或+哈希计数」几乎一致，能帮你快速掌握「前缀+哈希」的核心。
    2.  **洛谷 P3405 [USACO16DEC] Cities and States S**
          * 🗣️ **推荐理由**：这道题需要统计「满足条件的 pairs 数量」，用哈希表记录历史值的出现次数，和本题的「统计s[j]^x的次数」思路相同，能锻炼你的「哈希计数」能力。
    3.  **洛谷 P5527 [AHOI2001] 多项式乘法**
          * 🗣️ **推荐理由**：这道题需要统计「乘积为k的子数组数」，虽然不是异或，但「前缀乘积+哈希计数」的思路和本题一致，能帮你迁移技巧。
    4.  **洛谷 P1469 找筷子**
          * 🗣️ **推荐理由**：这道题需要找「出现奇数次的数」，用异或的性质（相同数异或为0），能帮你巩固异或的基础。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我发现了几个「易错点」，是大家解题时容易踩的坑，分享给你：
</insights_intro>

> **经验1**：完全平方数的枚举范围要到「2n」——比如样例2中的异或和可能达到较大的数，如果只枚举到n，会漏掉一些情况（比如异或和为4的子数组）。  
> **经验2**：哈希桶的大小要足够——比如`s[i]`的最大值可能达到2n，所以哈希桶的大小至少要开到2n+5，避免越界。  
> **经验3**：多组数据要清空哈希桶——比如用`memset`或`vector`的`assign`函数，否则前一组数据的`cnt`会影响后一组。

**点评**：这些经验都是作者们「踩坑」后的总结，非常宝贵！比如「清空哈希桶」，如果没做，多组数据时会得到错误的结果——这是编程中「边界条件」的重要性，一定要注意！


<conclusion>
本次关于「Even Subarrays」的分析就到这里啦！通过这道题，你学会了「补集思想」「前缀异或」「哈希计数」三个核心技巧，还通过像素动画直观看到了算法的运行过程。记住：编程的核心是「思路」，不是「代码」——掌握了思路，再复杂的问题也能拆解成简单的步骤！下次我们再一起探索新的挑战～💪
</conclusion>

---
处理用时：178.73秒
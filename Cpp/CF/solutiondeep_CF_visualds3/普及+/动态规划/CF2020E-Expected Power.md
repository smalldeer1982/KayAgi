# 题目信息

# Expected Power

## 题目描述

You are given an array of $ n $ integers $ a_1,a_2,\ldots,a_n $ . You are also given an array $ p_1, p_2, \ldots, p_n $ .

Let $ S $ denote the random multiset (i. e., it may contain equal elements) constructed as follows:

- Initially, $ S $ is empty.
- For each $ i $ from $ 1 $ to $ n $ , insert $ a_i $ into $ S $ with probability $ \frac{p_i}{10^4} $ . Note that each element is inserted independently.

Denote $ f(S) $ as the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all elements of $ S $ . Please calculate the expected value of $ (f(S))^2 $ . Output the answer modulo $ 10^9 + 7 $ .

Formally, let $ M = 10^9 + 7 $ . It can be shown that the answer can be expressed as an irreducible fraction $ \frac{p}{q} $ , where $ p $ and $ q $ are integers and $ q \not \equiv 0 \pmod{M} $ . Output the integer equal to $ p \cdot q^{-1} \bmod M $ . In other words, output such an integer $ x $ that $ 0 \le x < M $ and $ x \cdot q \equiv p \pmod{M} $ .

## 说明/提示

In the first test case, $ a = [1, 2] $ and each element is inserted into $ S $ with probability $ \frac{1}{2} $ , since $ p_1 = p_2 = 5000 $ and $ \frac{p_i}{10^4} = \frac{1}{2} $ . Thus, there are $ 4 $ outcomes for $ S $ , each happening with the same probability of $ \frac{1}{4} $ :

- $ S = \varnothing $ . In this case, $ f(S) = 0 $ , $ (f(S))^2 = 0 $ .
- $ S = \{1\} $ . In this case, $ f(S) = 1 $ , $ (f(S))^2 = 1 $ .
- $ S = \{2\} $ . In this case, $ f(S) = 2 $ , $ (f(S))^2 = 4 $ .
- $ S = \{1,2\} $ . In this case, $ f(S) = 1 \oplus 2 = 3 $ , $ (f(S))^2 = 9 $ .

Hence, the answer is $ 0 \cdot \frac{1}{4} + 1 \cdot \frac{1}{4} + 4\cdot \frac{1}{4} + 9 \cdot \frac{1}{4} = \frac{14}{4} = \frac{7}{2} \equiv 500\,000\,007 \pmod{10^9 + 7} $ .

In the second test case, $ a = [1, 1] $ , $ a_1 $ is inserted into $ S $ with probability $ 0.1 $ , while $ a_2 $ is inserted into $ S $ with probability $ 0.2 $ . There are $ 3 $ outcomes for $ S $ :

- $ S = \varnothing $ . In this case, $ f(S) = 0 $ , $ (f(S))^2 = 0 $ . This happens with probability $ (1-0.1) \cdot (1-0.2) = 0.72 $ .
- $ S = \{1\} $ . In this case, $ f(S) = 1 $ , $ (f(S))^2 = 1 $ . This happens with probability $ (1-0.1) \cdot 0.2 + 0.1 \cdot (1-0.2) = 0.26 $ .
- $ S = \{1, 1\} $ . In this case, $ f(S) = 0 $ , $ (f(S))^2 = 0 $ . This happens with probability $ 0.1 \cdot 0.2 = 0.02 $ .

Hence, the answer is $ 0 \cdot 0.72 + 1 \cdot 0.26 + 0 \cdot 0.02 = 0.26 = \frac{26}{100} \equiv 820\,000\,006 \pmod{10^9 + 7} $ .

## 样例 #1

### 输入

```
4
2
1 2
5000 5000
2
1 1
1000 2000
6
343 624 675 451 902 820
6536 5326 7648 2165 9430 5428
1
1
10000```

### 输出

```
500000007
820000006
280120536
1```

# AI分析结果

---
# 💡 Kay的C++算法解析：Expected Power 深入学习指南 💡

<introduction>
  今天我们来一起分析“Expected Power”这道C++编程题。题目要求计算随机集合异或和的平方的期望值，看起来有点抽象，但只要抓住“异或和值域小”这个关键，就能用**状压动态规划**轻松解决！本指南会帮你梳理思路、理解核心算法，并掌握模运算和空间优化的技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`状压动态规划（DP）+ 概率模运算`

🗣️ **初步分析**：
> 解决这道题的关键，是发现**异或和的值域极小**——因为每个`a[i] ≤ 1023`，所以任意子集的异或和`j`也一定在`0~1023`之间（共1024种可能）。这就像我们有1024个“概率抽屉”，每个抽屉`j`装着“前i个元素选完后，异或和为j”的概率。  
> 状压DP的核心思想是：**用有限的状态（这里是异或和）记录中间结果，逐步更新每个元素的贡献**。对本题来说，每个元素有两种选择：选或不选，我们需要分别计算这两种选择对所有“抽屉”的概率影响。  
> - **核心思路**：定义`dp[i][j]`为前`i`个元素选完后，异或和为`j`的概率。转移时，`dp[i][j] = 不选第i个元素的概率 + 选第i个元素的概率`（选的话异或和会变成`j^a[i]`）。  
> - **核心难点**：如何处理大数的模运算（因为概率是分数，需要用逆元转换）、如何优化空间（避免`O(n*1024)`的空间开销）。  
> - **可视化设计思路**：我们可以用8位像素风格展示1024个“概率抽屉”，每个抽屉的颜色深浅代表概率大小。每个元素加入时，用**绿色动画**表示“不选”的贡献（抽屉`j`的概率增加`dp[i-1][j]*(1-p)`），用**蓝色动画**表示“选”的贡献（抽屉`j`的概率增加`dp[i-1][j^a[i]]*p`），同时伴随“叮”（选）或“嗒”（不选）的像素音效，让你直观看到概率的变化。


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个方面筛选了2份优质题解（评分≥4星），帮你快速掌握核心实现！
</eval_intro>

**题解一：Zeoykkk的状压DP思路**
* **点评**：这份题解直接点出了“异或和值域小”的关键，状态定义`dp[i][j]`非常直观——前i个元素异或和为j的概率。转移逻辑也很自然：不选当前元素时，概率继承自`dp[i-1][j]`乘以不选的概率；选当前元素时，概率来自`dp[i-1][j^a[i]]`乘以选的概率。虽然没有给出完整代码，但思路框架清晰，是理解本题的“入门钥匙”。

**题解二：__3E24AC7002AD9292__的滚动数组实现**
* **点评**：这份题解的代码堪称“教科书级”！作者用**滚动数组**将空间从`O(n*1024)`优化到`O(1024)`（只用两个一维数组`f[0]`和`f[1]`交替更新），完美解决了n=2e5时的空间问题。同时，模运算处理非常严谨：用`INV`（1e4的逆元，即500000004）将分数`p[i]/1e4`转换为模意义下的乘法，避免了浮点数误差。代码结构工整，变量名清晰（`f[0]`表示前i-1个元素的状态，`f[1]`表示前i个元素的状态），甚至在最后直接计算`sum(f[0][j] * j * j)`得到期望，完全贴合题目要求。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的过程中，你可能会遇到3个关键“卡点”。结合优质题解的经验，我帮你提炼了应对策略：
</difficulty_intro>

1.  **关键点1：为什么选择“异或和”作为状态？**
    * **分析**：因为`a[i] ≤ 1023`，异或和的可能值只有1024种（0~1023）。即使n是2e5，状态数也不会变——这是状压DP能解决本题的根本原因！如果选择其他状态（比如选哪些元素），状态数会是`2^2e5`，完全无法处理。
    * 💡 **学习笔记**：**状态选择的核心是“有限且覆盖所有可能”**——找到问题的“小维度”，就能用DP高效解决。

2.  **关键点2：如何处理概率的模运算？**
    * **分析**：题目要求结果对`1e9+7`取模，而概率是`p[i]/1e4`这样的分数。此时需要用**逆元**：因为`1e4 * inv(1e4) ≡ 1 mod 1e9+7`，所以`p[i]/1e4`等价于`p[i] * inv(1e4) mod 1e9+7`。比如样例1中的`1/2`，就是`5000 * 500000004 mod 1e9+7 = 500000007`（和样例输出一致）。
    * 💡 **学习笔记**：模意义下的分数运算，用逆元转换为乘法是通用技巧！

3.  **关键点3：如何优化空间？**
    * **分析**：原始的`dp[i][j]`需要`n*1024`的空间，对于n=2e5来说，这会占用约200MB（每个int占4字节），可能超出内存限制。但观察转移方程：`dp[i][j]`只依赖`dp[i-1][...]`，所以可以用**滚动数组**——只用两个一维数组`prev`（前i-1个元素的状态）和`curr`（前i个元素的状态），每次更新后交换两者的角色。这样空间就优化到了`2*1024=2048`个元素，完全没问题！
    * 💡 **学习笔记**：**如果DP的状态只依赖前一层，滚动数组是空间优化的“神器”**！

### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用解题技巧：
</summary_best_practices>
- **技巧1：找“小维度”**：遇到大数据量的问题，先找是否有“值域小”的维度（比如异或和、二进制位），用状压DP压缩状态。
- **技巧2：模逆元处理分数**：涉及模运算的概率题，用逆元将除法转为乘法，避免浮点数误差。
- **技巧3：滚动数组优化空间**：当DP状态只依赖前一层时，用两个一维数组交替更新，空间复杂度从`O(n*V)`降到`O(V)`。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——综合了题解二的滚动数组思路，代码简洁且能直接解决问题！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自__3E24AC7002AD9292__的题解，用滚动数组优化空间，模运算处理严谨，是本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    const int MOD = 1e9 + 7;
    const int V = 1024; // 异或和的最大值（2^10）
    const long long INV = 500000004; // 1e4的逆元（因为1e4 * 500000004 ≡ 1 mod MOD）

    int main() {
        int T;
        cin >> T;
        while (T--) {
            int n;
            cin >> n;
            vector<int> a(n + 1), p(n + 1);
            for (int i = 1; i <= n; i++) cin >> a[i];
            for (int i = 1; i <= n; i++) cin >> p[i];

            vector<long long> f0(V, 0), f1(V, 0);
            f0[0] = 1; // 初始状态：选0个元素，异或和为0的概率是1

            for (int i = 1; i <= n; i++) {
                long long pi = p[i] * INV % MOD; // p[i]/1e4的模值
                long long qi = (10000 - p[i]) * INV % MOD; // (1 - p[i]/1e4)的模值

                // 初始化f1为0
                fill(f1.begin(), f1.end(), 0);

                for (int j = 0; j < V; j++) {
                    // 不选第i个元素：f1[j] += f0[j] * qi
                    f1[j] = (f1[j] + f0[j] * qi) % MOD;
                    // 选第i个元素：f1[j] += f0[j ^ a[i]] * pi
                    f1[j] = (f1[j] + f0[j ^ a[i]] * pi) % MOD;
                }

                // 滚动数组：f0变为当前层的状态，f1重置为下一层的初始状态
                swap(f0, f1);
            }

            // 计算期望：sum(f0[j] * j * j) mod MOD
            long long ans = 0;
            for (int j = 0; j < V; j++) {
                ans = (ans + f0[j] * j % MOD * j % MOD) % MOD;
            }
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为三步：1. 读取输入（多组测试用例）；2. 用滚动数组`f0`（前i-1个元素的状态）和`f1`（前i个元素的状态）更新概率；3. 计算所有异或和的`j²`乘以概率的总和，得到期望。关键细节是用`INV`处理分数，用`swap(f0, f1)`实现滚动数组。

---
<code_intro_selected>
接下来剖析题解二中的**核心代码片段**，看看滚动数组是如何工作的！
</code_intro_selected>

**题解二：__3E24AC7002AD9292__的滚动数组片段**
* **亮点**：用两个一维数组交替更新，将空间复杂度从`O(n*1024)`降到`O(1024)`，同时模运算处理严谨。
* **核心代码片段**：
    ```cpp
    vector<long long> f0(V, 0), f1(V, 0);
    f0[0] = 1;

    for (int i = 1; i <= n; i++) {
        long long pi = p[i] * INV % MOD;
        long long qi = (10000 - p[i]) * INV % MOD;
        fill(f1.begin(), f1.end(), 0);

        for (int j = 0; j < V; j++) {
            f1[j] = (f1[j] + f0[j] * qi) % MOD;      // 不选第i个元素
            f1[j] = (f1[j] + f0[j ^ a[i]] * pi) % MOD;// 选第i个元素
        }

        swap(f0, f1); // 滚动到下一层
    }
    ```
* **代码解读**：
    > 1. **初始化**：`f0[0] = 1`表示“选0个元素时，异或和为0的概率是1”（这是所有情况的起点）。  
    > 2. **处理每个元素**：对第i个元素，计算`pi`（选的概率）和`qi`（不选的概率）。  
    > 3. **更新状态**：对于每个可能的异或和`j`：
    >    - 不选第i个元素：`f1[j]`加上`f0[j] * qi`——前i-1个元素异或和为j的概率，乘以不选当前元素的概率。  
    >    - 选第i个元素：`f1[j]`加上`f0[j^a[i]] * pi`——前i-1个元素异或和为`j^a[i]`的概率，乘以选当前元素的概率（选了之后异或和变成`j`）。  
    > 4. **滚动数组**：`swap(f0, f1)`将`f1`（当前层的状态）转为`f0`（下一层的前状态），`f1`则会被下一次循环重置为0。
* 💡 **学习笔记**：滚动数组的关键是“交替覆盖”——用两个数组轮流保存前一层和当前层的状态，避免了存储所有层的状态。


---

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了让你更直观地“看到”状压DP的过程，我设计了一个**8位像素风格的动画**——像玩FC游戏一样，看“概率抽屉”如何一步步更新！
\</visualization_intro\>

  * **动画演示主题**：`像素抽屉大冒险`（用8位像素风格展示1024个“概率抽屉”，每个抽屉的颜色深浅代表概率大小）
  * **核心演示内容**：展示每个元素加入时，“不选”和“选”两种操作对抽屉概率的影响，最后计算期望的总和。
  * **设计思路简述**：用复古的FC风格（低分辨率、高饱和度颜色）降低视觉负担，用颜色和音效强化关键操作的记忆——比如“选”用蓝色动画+“叮”声，“不选”用绿色动画+“嗒”声，让你一眼就能区分两种操作的贡献。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
        - 屏幕左侧显示**当前处理的元素**（比如像素化的“1”或“2”），下方标注其“选的概率”（比如50%）。
        - 屏幕中间是**1024个像素抽屉**（排列成32x32的网格），初始时只有第0号抽屉是亮绿色（概率1），其他抽屉是黑色（概率0）。
        - 屏幕右侧是**控制面板**：包含“单步执行”“自动播放”“速度滑块”“重置”按钮，以及当前的“期望总和”显示。
        - 背景播放**8位风格的轻快BGM**（比如《超级马里奥》的背景音乐）。
    2.  **元素加入动画**（以样例1的第一个元素`a=1`，`p=5000`为例）：
        - **步骤1：不选当前元素**：所有抽屉的颜色变深（绿色），第0号抽屉的概率从1变为`1*0.5=0.5`（颜色从亮绿变深绿）。伴随“嗒”的像素音效。
        - **步骤2：选当前元素**：第`0^1=1`号抽屉的颜色变蓝，概率从0变为`1*0.5=0.5`（颜色从黑变亮蓝）。伴随“叮”的像素音效。
        - **结果**：处理完第一个元素后，第0号抽屉（概率0.5，深绿）和第1号抽屉（概率0.5，亮蓝）。
    3.  **后续元素处理**：重复步骤2，每次处理一个元素时，先显示“不选”的绿色动画，再显示“选”的蓝色动画，抽屉的颜色深浅随概率更新。
    4.  **期望计算动画**：所有元素处理完后，每个抽屉的`j²`值会显示在抽屉上方，然后用**黄色闪烁动画**将每个抽屉的`概率*j²`累加到“期望总和”中，最后显示最终结果（比如样例1的500000007）。
    5.  **交互功能**：
        - 单步执行：点击一次按钮，处理一个元素的“不选”和“选”操作。
        - 自动播放：按设定的速度（通过滑块调整）自动处理所有元素，适合快速看整体流程。
        - 重置：回到初始状态，重新演示。

  * **旁白提示**：
    - （处理第一个元素时）“现在处理元素1，选的概率是50%！先看‘不选’的情况——第0号抽屉的概率变成0.5啦～”
    - （选元素时）“接下来是‘选’的情况！选了1之后，异或和会变成0^1=1，所以第1号抽屉的概率增加0.5～”
    - （计算期望时）“现在要算总和啦！每个抽屉的j²乘以概率，加起来就是期望～看，总和变成7/2啦～”

\<visualization_conclusion\>
通过这个动画，你能清晰看到**每个元素如何影响概率分布**，以及**期望是如何从所有状态中累加出来的**。复古的像素风格和音效让学习更有趣，也更容易记住关键步骤！


---

## 6. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握了状压DP和概率模运算后，我们可以用这些技巧解决更多问题！
\</similar_problems_intro\>

  * **通用思路迁移**：
    - **异或和相关的概率问题**：比如求异或和的期望、异或和大于某个值的概率等，只要异或和的值域小，都可以用状压DP。
    - **子集选择的概率问题**：比如每个元素选或不选，求某个子集属性（比如和、乘积）的期望，只要属性的值域小，状压DP都适用。
    - **模运算下的分数问题**：比如求概率、平均值等，用逆元将除法转为乘法是通用解法。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4310 绝世好题**
        * 🗣️ **推荐理由**：这道题考察异或和的DP，需要找到“每个位的贡献”，和本题的状压思路异曲同工，能帮你巩固异或DP的技巧。
    2.  **洛谷 P3254 圆桌问题**
        * 🗣️ **推荐理由**：这道题用状压DP解决“安排座位”的问题，状态是“已选的桌子”，能帮你练习“找小维度状态”的能力。
    3.  **洛谷 P5657 [CSP-S2019] 格雷码**
        * 🗣️ **推荐理由**：这道题考察异或的性质，能帮你加深对异或运算的理解，为解决更复杂的异或问题打下基础。


---

## 7. 学习心得与经验分享 (若有)

\<insights_intro\>
题解二中的作者提到“VP赛切了五题，但是这题敢放E？”，这其实是一个很重要的心得：
\</insights_intro\>

> **参考经验 (来自 __3E24AC7002AD9292__)**：“VP赛切了五题，但是这题敢放E？”
>
> **点评**：这位作者的疑惑其实点出了本题的“难点”——**思路的转换**。很多人看到n=2e5会觉得“这题肯定要O(n)或O(n log n)的算法”，但忽略了“a[i] ≤ 1023”这个关键条件。状压DP的时间复杂度是O(n*1024)=2e8，对于C++来说完全可以通过！这提醒我们：**遇到大数据量的问题，先看是否有“小维度”可以利用，不要被n的大小吓住**。


---

\<conclusion\>
本次关于“Expected Power”的分析就到这里啦！这道题的核心是**状压DP+概率模运算**，关键是抓住“异或和值域小”的特点。记住：**状态选择是DP的灵魂，找到“小维度”就能解决大问题**！下次遇到类似的题目，不妨先想想：“有没有什么值域小的量可以作为状态？” 祝你编程之路越来越顺～💪
\</conclusion\>

---

---
处理用时：194.49秒
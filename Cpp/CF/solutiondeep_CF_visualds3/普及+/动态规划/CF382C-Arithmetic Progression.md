# 题目信息

# Arithmetic Progression

## 题目描述

Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers $ a_{1},a_{2},...,a_{n} $ of length $ n $ , that the following condition fulfills:

 $ a_{2}-a_{1}=a_{3}-a_{2}=a_{4}-a_{3}=...=a_{i+1}-a_{i}=...=a_{n}-a_{n-1}. $ For example, sequences \[1, 5\], \[10\], \[5, 4, 3\] are arithmetic progressions and sequences \[1, 3, 2\], \[1, 2, 4\] are not.

Alexander has $ n $ cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting $ n+1 $ cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

## 样例 #1

### 输入

```
3
4 1 7
```

### 输出

```
2
-2 10
```

## 样例 #2

### 输入

```
1
10
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4
1 3 5 9
```

### 输出

```
1
7
```

## 样例 #4

### 输入

```
4
4 3 4 5
```

### 输出

```
0
```

## 样例 #5

### 输入

```
2
2 4
```

### 输出

```
3
0 3 6
```

# AI分析结果

# 💡 Kay的C++算法解析：Arithmetic Progression 深入学习指南 💡

<introduction>
  今天我们来一起分析「Arithmetic Progression」这道C++编程题——给n个数字添加一个数，让所有数变成等差数列，找出所有可能的添加数字。这道题的核心是**分类讨论**和**等差数列性质**的应用，跟着Kay一步步拆解问题吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（分类讨论 + 基础数据处理）

🗣️ **初步分析**：
解决这道题的关键是「分类讨论」——就像整理不同形状的积木，我们需要根据积木的大小（n的数值）、排列方式（序列是否有序）用不同的整理规则。简单来说，分类讨论就是**把复杂问题拆成小问题，逐一解决**。在本题中：
- 当n=1时，任意数字都能构成等差数列，但题目要求输出-1（无限多解）；
- 当n=2时，可以在两端加数字，若两数差是偶数，中间也能加一个数；
- 当n≥3时，先排序（等差数列必须有序），再找「公差」（等差数列的“节奏”），最后检查是否有一个位置需要插入两倍公差的数，或整个序列已是等差数列（两端加数字）。

核心难点是**处理边界情况**（比如全相同的序列、n=3时的公差选择），解决方案是**逐一覆盖所有可能**。可视化设计思路也围绕这些步骤展开：用像素卡片展示数字排序，小方块显示相邻差，高亮众数差作为公差，红色边框标记需要插入的位置——就像玩“找不同”游戏，一眼就能看出哪里缺了数字！

如果用复古像素风演示，我们会给关键操作加音效：排序时“沙沙”响，找公差时“叮”一声，插入数字时“叮咚”提示，让你边玩边学～


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：（作者：丧黑福造）**
* **点评**：这份题解的分类讨论**最完整**，覆盖了所有边界情况（n=1、全相同序列、n=3）。思路上先排序再处理，逻辑像“剥洋葱”一样层层递进；代码风格简洁，变量名（如`a`存数字、`d`存公差）一看就懂；最巧妙的是**用前两个差的出现次数找公差**——不用遍历所有差，效率很高。比如n=3时，序列1、2、4，前两个差是1和2，统计后面的差（如果有的话），就能快速确定公差是1（因为1出现次数更多），然后在2和4之间插入3。实践中这份题解的边界处理很严谨，直接拿去参赛也没问题！

**题解二：（作者：AKPC）**
* **点评**：此题解用`unordered_map`统计差的频率，思路**最系统**。代码中用map找“出现次数最多的差”作为公差，就像“找投票最多的班长”，逻辑很直观；还处理了大数问题（`#define int long long`），避免溢出；当差的种类超过3种时直接输出0，减少无效计算。亮点是**用map统计频率**——这种方法能迁移到“找众数”“统计词频”等问题，非常实用！

**题解三：（作者：kimi0705）**
* **点评**：这份题解的**代码模块化最好**，用`check`函数封装了“判断序列是否为等差数列”的逻辑。比如要检查序列是否有序且差一致，直接调用`check(arr)`就行，不用重复写循环；思路上先验证“是否已是等差数列”，再尝试两种可能的公差（前两个差或第二三个差），像“试衣服”一样逐一验证，逻辑很清晰。这种“函数封装”的习惯能让代码更整洁，值得学习！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个“卡壳点”，结合优质题解的经验，Kay帮你总结了应对策略：
</difficulty_intro>

1. **关键点1：如何处理不同n的情况？**
   * **分析**：n的大小决定了问题的复杂度，必须分情况：
     - n=1：输出-1（无限多解）；
     - n=2：两端加数字，若差是偶数，中间也加；
     - n≥3：排序后找公差，检查插入位置。
   * 💡 **学习笔记**：分类讨论是“拆炸弹”的关键——先拆小零件，再处理整体。

2. **关键点2：如何确定n≥3时的公差？**
   * **分析**：公差是等差数列的“节奏”，找公差有两种方法：
     - 统计差的频率（题解二）：找出现次数最多的差（众数）；
     - 尝试前两个差（题解三）：验证前两个差是否符合条件（比如序列1、2、4，试差1和2，看哪个能让序列变成等差数列）。
   * 💡 **学习笔记**：公差是“等差数列的心脏”，找对了心脏，问题就解决了一半。

3. **关键点3：如何检查插入的数是否合法？**
   * **分析**：当序列不是等差数列时，必须有一个位置的差是**两倍公差**（比如公差是1，位置i的差是2），此时插入的数是“前一个数+公差”（或后一个数-公差）。例如，序列1、2、4，公差是1，位置2的差是2（4-2=2），插入的数是2+1=3，这样序列变成1、2、3、4，公差一致。
   * 💡 **学习笔记**：插入的数要“填补两倍公差的缺口”，就像补衣服的洞——洞有多大，补丁就多大。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题，Kay总结了4个通用技巧，帮你举一反三：
</summary_best_practices>
- **分类讨论**：把问题拆成小情况，逐一解决（比如n=1、n=2、n≥3）；
- **排序优先**：等差数列必须有序，排序是基础；
- **统计频率**：用map或数组统计差的频率，快速找公差；
- **函数封装**：把重复逻辑（比如判断是否为等差数列）封装成函数，减少代码重复。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合所有优质题解的通用代码**，帮你建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了3份题解的思路，覆盖所有边界情况，逻辑清晰易读。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  bool isArithmetic(const vector<int>& a) {
      int d = a[1] - a[0];
      for (int i = 2; i < a.size(); ++i) {
          if (a[i] - a[i-1] != d) return false;
      }
      return true;
  }

  int main() {
      int n;
      cin >> n;
      vector<int> arr(n);
      for (int i = 0; i < n; ++i) {
          cin >> arr[i];
      }
      sort(arr.begin(), arr.end());

      if (n == 1) {
          cout << -1 << endl;
          return 0;
      }

      bool allSame = true;
      for (int i = 1; i < n; ++i) {
          if (arr[i] != arr[0]) {
              allSame = false;
              break;
          }
      }
      if (allSame) {
          cout << 1 << endl << arr[0] << endl;
          return 0;
      }

      if (n == 2) {
          int d = arr[1] - arr[0];
          if (d % 2 != 0) {
              cout << 2 << endl;
              cout << arr[0] - d << " " << arr[1] + d << endl;
          } else {
              cout << 3 << endl;
              cout << arr[0] - d << " " << (arr[0] + arr[1])/2 << " " << arr[1] + d << endl;
          }
          return 0;
      }

      if (isArithmetic(arr)) {
          int d = arr[1] - arr[0];
          cout << 2 << endl;
          cout << arr[0] - d << " " << arr.back() + d << endl;
          return 0;
      }

      int d1 = arr[1] - arr[0];
      int cnt1 = 0, pos1 = -1;
      for (int i = 1; i < n; ++i) {
          if (arr[i] - arr[i-1] != d1) {
              cnt1++;
              pos1 = i-1;
          }
      }
      if (cnt1 == 1) {
          int gap = arr[pos1+1] - arr[pos1];
          if (gap == 2 * d1) {
              cout << 1 << endl;
              cout << arr[pos1] + d1 << endl;
              return 0;
          }
      }

      int d2 = arr[2] - arr[1];
      int cnt2 = 0, pos2 = -1;
      for (int i = 1; i < n; ++i) {
          if (arr[i] - arr[i-1] != d2) {
              cnt2++;
              pos2 = i-1;
          }
      }
      if (cnt2 == 1) {
          int gap = arr[pos2+1] - arr[pos2];
          if (gap == 2 * d2) {
              cout << 1 << endl;
              cout << arr[pos2] + d2 << endl;
              return 0;
          }
      }

      cout << 0 << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  代码流程像“流水线”：
  1. 读取输入→排序→处理n=1的情况；
  2. 判断是否全相同序列→处理n=2的情况；
  3. 检查是否已是等差数列→若是，输出两端数字；
  4. 尝试两种可能的公差（d1和d2）→检查是否有一个位置需要插入两倍公差的数→输出结果或0。


<code_intro_selected>
接下来剖析3份题解的**核心片段**，看它们的“巧妙之处”：
</code_intro_selected>

**题解一：（作者：丧黑福造）**
* **亮点**：用前两个差的出现次数快速找公差。
* **核心代码片段**：
  ```cpp
  c2 = c1 = 1;
  td1 = a[3]-a[2];
  if (td1 != d) {
      for (register int i = 4; i <= n; i ++){
          int td = a[i] - a[i-1];
          if (td == td1) c2++;
          else c1++;
          if (c1 >= 2 || c2 >= 2) break;
      }
  }
  if (c2 >= c1 && n >= 3 && d > td1) d = td1;
  ```
* **代码解读**：
  这段代码统计前两个差（d是a[2]-a[1]，td1是a[3]-a[2]）的出现次数。比如序列1、2、4、7，前两个差是1和2，遍历后面的差（7-4=3），统计c1（d=1的出现次数）和c2（td1=2的出现次数）。当其中一个出现次数≥2时，就把它作为公差。比如如果td1出现次数更多，就把d设为td1。这种方法**不用遍历所有差**，效率很高！
* 💡 **学习笔记**：统计前两个差的出现次数，是n≥3时找公差的“快捷方式”。

**题解二：（作者：AKPC）**
* **亮点**：用map统计差的频率找众数。
* **核心代码片段**：
  ```cpp
  unordered_map<int,int>mp;
  for (int i=1;i<n;i++){
      f[i]=a[i+1]-a[i];
      if (!mp[f[i]]++) t[++tip]=f[i];
      if (maxn<mp[f[i]]&&mp[f[i]]>=2) maxn=mp[f[i]],id=f[i];
      if (tip>=3) {cout<<0;return 0;}
  }
  ```
* **代码解读**：
  这段代码用`unordered_map`统计每个差的频率。`f[i]`存第i个差，`mp[f[i]]++`统计频率——比如差1出现3次，mp[1]就是3。当mp[f[i]]首次变为1时，把差存入t数组（记录所有不同的差）。然后更新maxn（最大频率）和id（对应差），当频率≥2时才更新。如果差的种类超过3种（tip≥3），直接输出0（无解）。这种方法**系统且通用**，能处理所有n≥3的情况！
* 💡 **学习笔记**：用map统计频率，是“找众数”的万能方法。

**题解三：（作者：kimi0705）**
* **亮点**：用函数封装判断是否为等差数列。
* **核心代码片段**：
  ```cpp
  bool check ( vector <int> a ) {
      int c  = a[1] - a[0];
      for ( int i = 2; i < a.size(); i++ ) if ( a[i] - a[i - 1] != c ) return 0;
      return 1;
  }
  ```
* **代码解读**：
  这段代码定义了一个`check`函数，参数是`vector<int> a`，返回`bool`值。函数中计算第一个差`c`，然后遍历后面的差——如果有任何一个差不等于`c`，返回`false`（不是等差数列），否则返回`true`（是等差数列）。这个函数**封装了重复逻辑**，比如要检查序列是否是等差数列，直接调用`check(arr)`就行，不用重复写循环！
* 💡 **学习笔记**：函数封装是“代码整洁”的关键，能减少重复，提高可读性。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到算法的每一步，Kay设计了一个**像素风格的数字整理游戏**——像玩《超级马里奥》一样学算法！
</visualization_intro>

### **动画演示主题**：像素探险家找“缺失的等差数列数字”
### **核心演示内容**：排序→计算差→找公差→插入数字→展示结果
### **设计思路简述**：
用8位像素风（类似FC红白机）营造复古氛围，用**像素卡片**代表数字，**小方块**显示差，**颜色高亮**标记关键步骤，**音效**强化记忆——让你边玩边理解“分类讨论”和“等差数列”的逻辑！

### **动画帧步骤与交互关键点**：
1. **场景初始化（8位像素风）**：
   - 左侧：像素卡片区（8x8的方块，显示无序数字，比如样例1的4、1、7）；
   - 右侧：控制面板（红色“开始”、蓝色“单步”、黄色“重置”按钮，速度滑块从“慢”到“快”）；
   - 底部：信息区（显示当前步骤，比如“准备排序”）；
   - 背景：播放8位风格的轻快BGM（比如《魂斗罗》的开场音乐）。

2. **排序动画**：
   - 点击“开始”，卡片开始移动（比如4→中间，1→左边，7→右边），伴随“沙沙”的音效；
   - 排序完成后，信息区显示“排序完成！”，卡片区显示1、4、7。

3. **计算差动画**：
   - 卡片之间出现小方块，显示相邻差（1和4之间显示“3”，4和7之间显示“3”），伴随“滴”的音效；
   - 信息区显示“计算差完成！”。

4. **找公差动画**：
   - 小方块“3”高亮（变成黄色），伴随“叮”的音效——因为它是众数；
   - 信息区显示“公差是3！”。

5. **检查插入位置动画**：
   - 遍历所有差，发现所有差都是3（序列已是等差数列），信息区显示“序列已是等差数列！”；
   - 两端出现新卡片：1-3= -2（左边），7+3=10（右边），伴随“叮咚”的音效；
   - 信息区显示“插入数字：-2和10！”。

6. **结果展示动画**：
   - 所有卡片（-2、1、4、7、10）闪烁，伴随“胜利”音效（比如《超级马里奥》的通关音乐）；
   - 信息区显示“结果：数量2，数字-2 10！”。

### **交互设计**：
- **单步执行**：点击“单步”按钮，每步执行一个操作（比如排序一步、计算一个差）；
- **自动播放**：拖动滑块调整速度（慢：1秒/步，快：0.1秒/步）；
- **重置**：点击“重置”按钮，恢复初始状态，重新开始。

### **旁白提示（文字气泡）**：
- 排序时：“等差数列要有序，先把数字排好队！”；
- 计算差时：“小方块显示相邻数字的差，要找出现最多的差哦！”；
- 找公差时：“这个差出现次数最多，就是等差数列的节奏——公差！”；
- 插入数字时：“序列已是等差数列，两端加公差就能扩展啦！”。

<visualization_conclusion>
通过这个像素游戏，你能**直观看到算法的每一步**：排序如何让数字有序，差如何反映序列的节奏，公差如何确定，插入的数字如何填补缺口。音效和视觉提示能帮你记住关键逻辑，学习变得像玩游戏一样有趣！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的技巧，我们可以解决更多**等差数列相关问题**。Kay给你推荐3道洛谷题目，帮你巩固思路：
</similar_problems_intro>

### **通用思路迁移**：
本题的核心技巧（分类讨论、统计差的频率、函数封装）可用于：
1. 给定序列，求最少添加多少数使其成为等差数列（洛谷P3902）；
2. 找出序列中最长的等差数列子序列（洛谷P1420）；
3. 给定等差数列的部分元素，求缺失的元素（类似本题）。

### **洛谷练习推荐**：
1. **洛谷 P3902 等差数列**
   * 🗣️ **推荐理由**：这道题需要计算“最少添加多少数使序列成为等差数列”，和本题一样需要确定公差、处理插入位置，能巩固分类讨论和等差数列性质的应用。
2. **洛谷 P1420 最长等差数列**
   * 🗣️ **推荐理由**：此题要求找出“序列中最长的等差数列子序列”，需要统计不同公差的出现次数，类似本题中统计差的频率，能拓展对公差处理的思路。
3. **洛谷 P2676 超级书架**
   * 🗣️ **推荐理由**：虽然这道题是关于书架的，但需要处理“排序”和“差值平衡”问题，能锻炼分类讨论和数据处理的能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
3位作者的经验很实用，Kay帮你提炼了2条关键教训：
</insights_intro>

> **参考经验（来自题解三作者kimi0705）**：“我用了一个`check`函数来判断是否为等差数列，这样减少了重复代码，让逻辑更清晰。”
> **点评**：函数封装是“代码整洁”的关键！比如本题中的“判断是否为等差数列”，封装成函数后，不管在什么地方需要用到，只要调用`check(arr)`就行，不用重复写循环。这能帮你避免“复制粘贴”的错误，提高代码可读性。

> **参考经验（来自题解二作者AKPC）**：“注意如果答案里出现重复，需要去重之后再输出。”
> **点评**：去重是容易忽略的点！比如当序列全相同时（比如输入1 1 1），添加的数字只能是1，不能重复输出。在编程中，处理重复情况能让结果更准确，避免错误。


<conclusion>
本次关于「Arithmetic Progression」的分析就到这里～ 关键是掌握**分类讨论**和**等差数列的性质**，遇到问题先拆成小情况，再逐一解决。记住：编程的核心是“思路清晰”，多练多想，你会越来越厉害！下次我们再一起探索新的算法挑战～ 💪
</conclusion>

---
处理用时：352.14秒
# 题目信息

# Dynamic Problem Scoring

## 题目描述

Vasya 和 Petya 参加了一场 Codeforces 编程比赛。这场比赛持续两个小时，共有五道题目。

比赛采用动态计分系统。题目的最高分与你解题的难度有关，具体是根据解决这道题目的人数占总参赛人数的比例来决定的。只要选手有过一次提交，就被视为参赛者。

！[](https://cdn.luogu.com.cn/upload/vjudge_pic/CF773B/a0f85cbd533a46bf976e07f7a2f9ea90ac93ff77.png)

注意分数区间。例如，有 40 名选手参加比赛，其中 10 人解出某个题目，那么解题比例为 $1/4$，该题目最大分数为 1500 分。

如果题目的最大分数为 $x$，那么从比赛开始到选手正确提交的每分钟，选手都会扣除 $x/250$ 分。例如，题目最大分数是 2000 分，而选手在第 40 分钟提交了答案，那么他将得到 $2000 \times (1 - 40/250) = 1680$ 分。

参赛有 $n$ 位选手，其中包括 Vasya 和 Petya。每位选手对每道题目的提交时间已知，并以分钟为单位记录；如果某题未被解出，则时间记为 -1。

比赛即将结束时，所有选手的提交都通过了预测试，并且没有人尝试黑客攻击。Vasya 认为在最后的两秒钟里不会有新的提交，也没有任何黑客行为，所有提交均会通过系统检测。

然而，Vasya 是个作弊者。他为这场比赛注册了 $10^9 + 7$ 个新账号。Vasya 可以利用这些新账号改变题目的最大分值，提交错误的或者已经解决的题目。需要注意的是，对于未解的题目，他不能提交正确的答案。

Vasya 希望通过这种方式让自己的总得分比 Petya 高。尽管他已经准备好了快速提交脚本，但他不想让作弊行为太过明显，所以希望用尽量少的新账号实现目标。

请你帮 Vasya 找出他需要用多少个新账号才能超越 Petya，或者告诉他如果无法实现这一目标。

## 说明/提示

在第一个示例中，Vasya 的优化策略是利用两个新账号提交最后三道题。这样前两道题的最高分为 1000 分，后三道各为 500 分。Vasya 的总分将是 $980 + 940 + 420 + 360 + 270 = 2970$ 分，而 Petya 为 $800 + 820 + 420 + 440 + 470 = 2950$ 分。

在第二个示例中，Vasya 需用两个新账号的单次失败提交，再用第三个账号的正确提交解决第一道题。这样，所有题目的最高分依次为 500、1500、1000、1500、3000 分。Vasya 最终得分为 2370 分，而 Petya 得分为 2294 分。

在第三个示例中，Vasya 可以借助 27 个新账号为前四道题提交答案，从而让题目变得为 500、500、500、500、2000 分。因第五题的高分，Vasya 能以此战胜仅解出前四题但未能解出第五题的 Petya。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
5 15 40 70 115
50 45 40 30 15
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
55 80 10 -1 -1
15 -1 79 60 -1
42 -1 13 -1 -1
```

### 输出

```
3
```

## 样例 #3

### 输入

```
5
119 119 119 119 119
0 0 0 0 -1
20 65 12 73 77
78 112 22 23 11
1 78 60 111 62
```

### 输出

```
27
```

## 样例 #4

### 输入

```
4
-1 20 40 77 119
30 10 73 50 107
21 29 -1 64 98
117 65 -1 -1 -1
```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：Dynamic Problem Scoring 深入学习指南 💡

<introduction>
今天我们来一起分析Codeforces 806B「Dynamic Problem Scoring」这道C++编程题。这道题结合了**枚举策略**和**条件验证**，需要我们通过暴力枚举所有可能的分数组合，找到让Vasya总分超过Petya的最小小号数。本指南将帮你梳理思路、理解核心逻辑，并掌握解题技巧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举 + 条件验证`

🗣️ **初步分析**：
解决这道题的关键，在于抓住「每个题的分数档只有6种可能」这个突破口——5道题的分数组合总共有 `6^5=46656` 种，完全可以用**暴力枚举**覆盖所有情况。这就像“试穿所有衣服搭配”：我们逐一尝试每个题的分数档，然后验证两个条件：① Vasya的总分是否超过Petya；② 是否能用最少的小号让每个题的比例满足对应分数档的要求。

- **核心思路**：枚举所有分数档组合 → 计算总分差 → 验证该组合是否能用少量小号实现 → 取最小小号数。
- **核心难点**：a）如何判断某个分数档组合需要多少小号；b）如何处理Vasya的小号对解出人数的影响（只有他解出的题，小号才能增加解出人数）。
- **可视化设计思路**：用8位像素风格展示5道题（红色=3000分、橙色=2500分等），动态显示小号数增加（像素小人加入队列），实时更新每个题的比例是否满足要求（绿色=满足、红色=不满足）。当所有题都满足且总分差为正时，播放“胜利”音效，高亮最小小号数。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性等角度筛选了2份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：(来源：dead_X)**
* **点评**：这份题解的框架非常简洁——用5层循环直接枚举所有分数档组合，计算总分差的逻辑也很直观（直接根据提交时间计算得分并相减）。对于小号数的验证，用`solve::qwq`函数判断比例是否满足要求，虽然函数逻辑稍抽象，但整体思路正确。美中不足的是变量命名（如`A/B/C`）没有注释，需要读者自己对应题目中的5道题。

**题解二：(来源：lenaalyth)**
* **点评**：这份题解的思路更“直白”——用5层循环枚举每个题的目标档，计算总分差后调用`chuli`函数逐题验证小号数。`chuli`函数详细处理了比例区间的判断，但条件分支太多（多个`if-else`），可读性稍差。不过其“逐题验证”的思路容易理解，适合初学者入门。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于突破以下3个难点，结合优质题解的共性，我帮你提炼了应对策略：
</difficulty_intro>

1.  **难点1：如何枚举所有分数档组合？**
    * **分析**：每个题有6种分数档（3000→2500→…→500），5道题的组合数是`6^5=46656`，这在计算机处理范围内（即使每个组合用1ms，总时间也仅47ms）。直接用**5层循环**枚举即可。
    * 💡 **学习笔记**：当问题的可能情况有限时，暴力枚举是最直接的方法。

2.  **难点2：如何计算总分差？**
    * **分析**：每个题的得分公式是 `最高分 × (1 - 提交时间/250)`（未解出则不计分）。我们只需计算Vasya的总分减去Petya的总分，若结果>0，说明该组合可能可行。
    * 💡 **学习笔记**：准确理解得分公式是基础，不要遗漏“未解出不计分”的条件。

3.  **难点3：如何处理小号对解出人数的影响？**
    * **分析**：Vasya的小号**只能**对他解出的题增加解出人数（未解的题不能提交正确答案）。例如，若Vasya解出了第1题，开`j`个小号可以让最多`j`个小号解出该题，解出人数变为`原解出人数 + x`（`x≤j`）；若未解出，解出人数不变。我们需要找到最小的`j`，使得每个题的`(原解出人数 + x)/(n+j)`落在目标档的比例区间内。
    * 💡 **学习笔记**：明确小号的作用范围——只影响Vasya解出的题！

### ✨ 解题技巧总结
- **暴力枚举**：有限情况直接枚举，不要害怕“暴力”。
- **条件拆分**：将问题拆分为“总分差>0”和“比例满足要求”两个条件，逐一验证。
- **变量管理**：用数组或清晰的变量名管理5道题的信息（如解出人数、是否解出），避免混淆。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合后的**通用核心代码**，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一和题解二的思路，采用枚举+验证的方式，逻辑清晰易懂。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

const int SCORES[] = {3000, 2500, 2000, 1500, 1000, 500}; // 分数档（0~5对应3000~500）
const double RATIOS[] = {1.0/32, 1.0/16, 1.0/8, 1.0/4, 1.0/2, 1.0}; // 比例上限

int n;
vector<vector<int>> times; // 每个选手的提交时间（times[0]是Vasya，times[1]是Petya）
vector<int> solve_cnt; // 每个题的原解出人数
vector<bool> vasya_solved; // Vasya是否解出每个题

// 计算总分差（Vasya - Petya）
long long calc_diff(const vector<int>&档次) {
    long long v = 0, p = 0;
    for (int i = 0; i < 5; ++i) {
        int s = SCORES[档次[i]];
        if (times[0][i] != -1) v += s - (long long)s * times[0][i] / 250;
        if (times[1][i] != -1) p += s - (long long)s * times[1][i] / 250;
    }
    return v - p;
}

// 判断第k题用j个小号是否满足目标档t
bool is_ok(int k, int t, int j) {
    int total = n + j;
    int max_s = solve_cnt[k] + (vasya_solved[k] ? j : 0); // 最多能增加的解出人数
    double lower = (t == 0) ? 0.0 : RATIOS[t-1];
    double upper = RATIOS[t];
    int min_need = (t == 5) ? (int)(lower * total) + 1 : (int)(lower * total) + 1;
    int max_need = (t == 0) ? (int)(upper * total) : (int)(upper * total);
    return max_s >= min_need && solve_cnt[k] <= max_need;
}

// 找该分数档组合的最小小号数
int find_min_j(const vector<int>&档次) {
    for (int j = 0; j <= 1000; ++j) { // 上限1000足够
        bool ok = true;
        for (int k = 0; k < 5; ++k) if (!is_ok(k, 档次[k], j)) { ok = false; break; }
        if (ok) return j;
    }
    return INT_MAX;
}

int main() {
    cin >> n;
    times.resize(n, vector<int>(5));
    solve_cnt.assign(5, 0);
    vasya_solved.assign(5, false);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < 5; ++j) {
            cin >> times[i][j];
            if (times[i][j] != -1) solve_cnt[j]++;
        }
        if (i == 0) for (int j = 0; j < 5; ++j) vasya_solved[j] = (times[i][j] != -1);
    }

    int min_j = INT_MAX;
    // 枚举所有分数档组合
    for (int t0 = 0; t0 < 6; ++t0)
    for (int t1 = 0; t1 < 6; ++t1)
    for (int t2 = 0; t2 < 6; ++t2)
    for (int t3 = 0; t3 < 6; ++t3)
    for (int t4 = 0; t4 < 6; ++t4) {
        vector<int>档次 = {t0, t1, t2, t3, t4};
        long long diff = calc_diff(档次);
        if (diff > 0) {
            int j = find_min_j(档次);
            if (j < min_j) min_j = j;
        }
    }

    cout << (min_j == INT_MAX ? -1 : min_j) << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取选手数和提交时间，统计每个题的原解出人数，记录Vasya是否解出每个题。
  2. **枚举组合**：5层循环枚举所有分数档组合。
  3. **计算总分差**：若Vasya总分更高，尝试找最小小号数。
  4. **验证小号数**：从`j=0`开始，验证每个题的比例是否满足要求，找到最小`j`。


<code_intro_selected>
再看**题解一的核心片段**，理解枚举与验证的细节：
</code_intro_selected>

**题解一：(来源：dead_X)**
* **亮点**：简洁的枚举框架，直接覆盖所有分数组合。
* **核心代码片段**：
```cpp
for(t[0]=0; t[0]<6; t[0]++)
for(t[1]=0; t[1]<6; t[1]++)
for(t[2]=0; t[2]<6; t[2]++)
for(t[3]=0; t[3]<6; t[3]++)
for(t[4]=0; t[4]<6; t[4]++) {
    int d=0;
    // 计算Vasya的得分
    if(pp[1].a!=-1) d+=s[t[0]]-s[t[0]]/250*pp[1].a;
    if(pp[1].b!=-1) d+=s[t[1]]-s[t[1]]/250*pp[1].b;
    // ...（省略c/d/e题的计算）
    // 减去Petya的得分
    if(pp[2].a!=-1) d-=s[t[0]]-s[t[0]]/250*pp[2].a;
    // ...（省略c/d/e题的计算）
    if(d>0) {
        for(int j=0; j<=4000; ++j) {
            int f=0;
            // 验证每个题的比例是否满足要求
            if(solve::qwq(A,A+(j*(pp[1].a!=-1)),n+j,t[0])) f++;
            // ...（省略b/c/d/e题的验证）
            if(f==5) { ans=min(ans,j); break; }
        }
    }
}
```
* **代码解读**：
  - 用5层循环枚举每个题的分数档（`t[0]~t[4]`）。
  - 计算总分差`d`：Vasya的得分减去Petya的得分。
  - 若`d>0`，尝试从`j=0`开始找最小小号数，用`solve::qwq`验证每个题的比例是否满足要求（`f==5`表示所有题都满足）。
* 💡 **学习笔记**：枚举框架是本题的核心，必须覆盖所有可能的分数组合。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观理解“枚举+验证”的过程，我设计了一个**8位像素风格的动画**，结合复古游戏元素，带你“看”算法如何工作！
</visualization_intro>

### 动画设计方案
**主题**：《Vasya的小号大作战》——帮助Vasya用最少的小号调整分数，超过Petya！

### 核心设计细节
1. **场景与UI**（FC红白机风格）：
   - **题目区域**：5个彩色像素方块（红=3000、橙=2500、黄=2000、绿=1500、蓝=1000、紫=500），每个方块显示当前分数档和比例（如“3000分 | 1/32”）。
   - **总分区域**：显示Vasya和Petya的总分（如“Vasya: 2970 | Petya: 2950”），差值用绿色（正）或红色（负）显示。
   - **控制面板**：单步按钮（▶️）、自动按钮（⏩）、重置按钮（🔄）、速度滑块（1~5档），背景是复古网格。

2. **动画流程**：
   - **步骤1：枚举分数档**：初始时所有题都是红色（3000分），然后逐一枚举每个题的分数档（如第一题从红→橙→黄…），切换时播放“叮”的音效，方块闪烁。
   - **步骤2：计算总分差**：分数档变化时，总分区域实时更新，差值为正则显示绿色，否则红色。
   - **步骤3：调整小号数**：当差值为正时，开始增加小号数（屏幕下方出现像素小人，每增加1个小人播放“嗒”的音效），每个题的比例区域实时更新解出人数和总人数（如“解出10人 | 总40人”），满足要求的题变为绿色，否则红色。
   - **步骤4：目标达成**：当所有题都变绿色时，播放“胜利”音效（8位上扬音调），屏幕中央弹出“成功！需要2个小号”的像素文字，背景绽放烟花。

3. **交互设计**：
   - **单步模式**：点击▶️按钮，逐一枚举分数档或增加小号数，适合仔细观察每一步。
   - **自动模式**：点击⏩按钮，动画自动执行，速度滑块调整播放速度（1档最慢，5档最快）。
   - **重置模式**：点击🔄按钮，回到初始状态，重新开始。

### 设计意图
- **像素风格**：营造复古游戏氛围，降低学习压力。
- **音效反馈**：用“叮”“嗒”“胜利音”强化关键操作的记忆。
- **颜色高亮**：用颜色区分分数档和比例状态，直观看到“哪些题满足要求”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的枚举+验证思路后，可以尝试以下相似问题，巩固技巧：
</similar_problems_intro>

### 通用思路迁移
本题的**枚举+验证**思路可用于：
1. **组合优化**：如“数的划分”（枚举所有划分方式）。
2. **条件验证**：如“火柴棒等式”（枚举所有等式，验证火柴棒数量）。
3. **最小化问题**：如“回文质数”（枚举所有回文数，验证是否为质数）。

### 洛谷练习推荐
1. **洛谷 P1025 - 数的划分**
   * 🗣️ **推荐理由**：需要枚举所有可能的划分方式，与本题的枚举思路一致，帮助巩固“有限情况暴力枚举”的技巧。
2. **洛谷 P1149 - 火柴棒等式**
   * 🗣️ **推荐理由**：枚举所有等式组合，验证火柴棒数量，与本题的“枚举+条件验证”思路完全一致。
3. **洛谷 P1217 - [USACO1.5] 回文质数**
   * 🗣️ **推荐理由**：枚举所有回文数，验证是否为质数，锻炼“枚举+多条件验证”的能力。


## 7. 学习心得与经验分享 (若有)
本次分析的题解中，dead_X调侃“看到垃圾题应该怎么办呢？当然是给大家一起做啦！”，这其实反映了**面对复杂问题的心态**——不要害怕，先找“有限的可能”（比如本题的6^5种组合），再逐一验证。lenaalyth提到“一写一bug”，提醒我们**编程时要注意细节**（如分数档的比例区间、小号的作用范围），避免因小失大。


<conclusion>
本次关于「Dynamic Problem Scoring」的分析就到这里！希望你能掌握**枚举+验证**的核心思路，学会在有限情况中暴力破解问题。记住：编程的进步在于“多试、多练、多总结”，下次我们再一起挑战新问题！💪
</conclusion>

---
处理用时：282.37秒
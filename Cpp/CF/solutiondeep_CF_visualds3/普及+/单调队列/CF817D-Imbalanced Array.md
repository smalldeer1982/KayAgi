# 题目信息

# Imbalanced Array

## 题目描述

You are given an array $ a $ consisting of $ n $ elements. The imbalance value of some subsegment of this array is the difference between the maximum and minimum element from this segment. The imbalance value of the array is the sum of imbalance values of all subsegments of this array.

For example, the imbalance value of array $ [1,4,1] $ is $ 9 $ , because there are $ 6 $ different subsegments of this array:

- $ [1] $ (from index $ 1 $ to index $ 1 $ ), imbalance value is $ 0 $ ;
- $ [1,4] $ (from index $ 1 $ to index $ 2 $ ), imbalance value is $ 3 $ ;
- $ [1,4,1] $ (from index $ 1 $ to index $ 3 $ ), imbalance value is $ 3 $ ;
- $ [4] $ (from index $ 2 $ to index $ 2 $ ), imbalance value is $ 0 $ ;
- $ [4,1] $ (from index $ 2 $ to index $ 3 $ ), imbalance value is $ 3 $ ;
- $ [1] $ (from index $ 3 $ to index $ 3 $ ), imbalance value is $ 0 $ ;

You have to determine the imbalance value of the array $ a $ .

## 样例 #1

### 输入

```
3
1 4 1
```

### 输出

```
9
```

# AI分析结果

# 💡 Kay的C++算法解析：Imbalanced Array 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的「Imbalanced Array」问题——计算数组所有连续子数组的「最大值减最小值」之和。这个问题的核心是**将「求所有区间的差值和」转化为「每个元素的贡献和」**，而关键工具是「单调栈」。通过这道题，我们能学会如何用高效算法解决看似复杂的枚举问题，赶紧开始吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：单调栈（贡献法应用）

🗣️ **初步分析**：
解决这道题的关键在于**「贡献法」**——与其枚举所有子数组（O(n²) 次），不如计算**每个元素作为「最大值」或「最小值」时，能影响多少个子数组**，再将这些贡献相加（或相减）。

### 核心思想类比
想象你是班级里的「身高统计员」：要算所有小组的「最高身高 - 最矮身高」之和，不需要逐个小组量，而是统计**每个人作为「小组最高」或「小组最矮」的次数**，乘以身高后求和再相减。比如，小明身高180cm，如果有5个小组以他为最高，3个小组以他为最矮，那他的总贡献是 180×5 - 180×3 = 360。

### 本题应用
对于数组中的元素 `a[i]`：
- 若能找到**左边第一个比它大的位置 `l_max[i]`** 和 **右边第一个比它大的位置 `r_max[i]`**，则 `a[i]` 作为最大值的子数组数量是 `(i - l_max[i]) × (r_max[i] - i)`（左端点可选 `l_max[i]+1` 到 `i`，右端点可选 `i` 到 `r_max[i]-1`，乘法原理）。
- 同理，找到**左边第一个比它小的位置 `l_min[i]`** 和 **右边第一个比它小的位置 `r_min[i]`**，则 `a[i]` 作为最小值的子数组数量是 `(i - l_min[i]) × (r_min[i] - i)`。

最终答案 = 所有元素的「最大值贡献」之和 - 所有元素的「最小值贡献」之和。

### 关键工具：单调栈
要快速找到每个元素的「左右第一个更大/更小值」，需要用**单调栈**——这是一种能在O(n)时间内处理「Next Greater Element」类问题的神器。单调栈的核心是**维护栈内元素的单调性**（比如求「左边第一个更大值」时，栈内元素从底到顶递减），每次新元素入栈前，弹出所有破坏单调性的元素，这些被弹出的元素的「右边第一个更大值」就是当前元素。

### 可视化设计思路
我们会用**8位像素风动画**展示单调栈的工作过程：
- 数组元素用「彩色方块」表示，数值越大颜色越深；
- 单调栈用「右侧的竖列方块」表示，栈顶元素高亮；
- 当新元素入栈时，弹出所有比它小的栈顶元素（伴随「叮」的音效），并标记这些弹出元素的「右边第一个更大值」为当前元素；
- 动画支持「单步执行」和「自动播放」，每一步都会用文字提示「当前处理元素i，弹出栈顶元素j（因为a[i] > a[j]），j的r_max更新为i」。


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度」「代码可读性」「算法效率」三个维度筛选了3份优质题解，覆盖了最常用的「单调栈」和「增量法」，以及新颖的「并查集」思路，帮助大家多角度理解问题。
</eval_intro>

### 题解一：Provicy（单调栈经典实现，思路直白）
* **点评**：这份题解是「单调栈+贡献法」的标准模板，思路非常清晰——先拆分成「最大值之和」和「最小值之和」，再用单调栈分别计算每个元素的贡献。代码风格简洁（用`ri`定义循环变量，`sta`数组模拟栈），边界处理严谨（比如栈空时的默认值），特别适合新手入门。其亮点是**将最大值和最小值的计算逻辑复用**（仅改变比较符号），避免了重复代码。

### 题解二：zhengrunzhe（增量法，O(n)时间，代码巧妙）
* **点评**：这是一份「增量式」的创新解法——每次向数组末尾添加一个元素，计算新增的子数组（以当前元素结尾的所有子数组）的「max-min」之和，并累加到总答案。核心是用**两个单调栈**实时维护「以当前元素结尾的所有子数组的max和min」，通过「区间加减」快速更新总和。这种方法不需要预处理所有元素的左右边界，而是「边加边算」，时间复杂度O(n)，代码非常紧凑（仅50行左右），适合进阶学习者理解「动态维护」的思想。

### 题解三：xixiup（并查集，思路新颖，拓展思维）
* **点评**：这份题解用「并查集」替代了单调栈，思路非常新颖——将元素按值从小到大排序，依次将元素加入并查集，合并左右相邻的「已处理元素」（即比当前元素小的元素），从而得到当前元素作为最大值的区间边界。这种方法将「找左右更大值」转化为「合并连通块」，拓展了我们对「贡献法」的理解，适合学有余力的同学探索不同算法的关联。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，以下3个难点最容易卡壳。结合优质题解的经验，我们一一拆解：
</difficulty_intro>

### 1. 如何想到「贡献法」？
- **分析**：直接枚举所有子数组（O(n²)）对于n=1e6的规模完全不可行。这时候需要「转换视角」——题目要求的是「所有区间的(max-min)之和」，而加法的分配律允许我们拆成「所有区间的max之和」减去「所有区间的min之和」。进一步，每个区间的max必然是某个元素，因此可以计算每个元素作为max的次数，乘以元素值后相加。
- 💡 **学习笔记**：当题目要求「所有区间的统计量之和」时，优先考虑「贡献法」——把问题拆成每个元素的贡献。

### 2. 如何用单调栈找「左右第一个更大/更小值」？
- **分析**：单调栈的关键是「维护栈的单调性」。比如求「左边第一个更大值」：
  1. 栈内元素从底到顶**递减**（保证栈顶是当前元素左边最近的更大值）；
  2. 新元素入栈前，弹出所有比它小的栈顶元素（这些元素的「左边第一个更大值」不是当前元素）；
  3. 栈顶剩下的元素就是当前元素的「左边第一个更大值」，然后将当前元素入栈。
- 💡 **学习笔记**：单调栈的「单调性」由问题决定——求「更大值」用「递减栈」，求「更小值」用「递增栈」。

### 3. 如何处理「重复元素」避免重复计算？
- **分析**：如果数组中有重复元素（比如[1,4,1]），直接用「大于」或「小于」会导致重复计算（比如两个1都可能被算作某个区间的min）。解决方法是**统一比较条件**：比如求最大值时，右边用「大于等于」，左边用「大于」；求最小值时，右边用「小于等于」，左边用「小于」。这样可以确保每个区间的max/min只被计算一次。
- 💡 **学习笔记**：处理重复元素的核心是「让每个区间的极值唯一对应一个元素」，通过调整比较符号的「等于」情况实现。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「单调栈+贡献法」的通用核心实现，这是最常用的解法，覆盖了题目所有要求。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了Provicy和yzh_Error404的题解思路，实现了「单调栈求左右边界」和「贡献计算」，逻辑清晰，适合新手模仿。
* **完整核心代码**：
```cpp
#include <iostream>
#include <stack>
#include <cstdio>
using namespace std;
typedef long long ll;
const int MAXN = 1e6 + 5;

int n;
ll a[MAXN];
ll l_max[MAXN], r_max[MAXN]; // 左边第一个比a[i]大的位置，右边第一个比a[i]大的位置
ll l_min[MAXN], r_min[MAXN]; // 左边第一个比a[i]小的位置，右边第一个比a[i]小的位置
stack<int> stk;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);

    // 计算r_max：右边第一个比a[i]大的位置
    for (int i = 1; i <= n; ++i) {
        while (!stk.empty() && a[i] > a[stk.top()]) {
            r_max[stk.top()] = i;
            stk.pop();
        }
        stk.push(i);
    }
    while (!stk.empty()) { r_max[stk.top()] = n + 1; stk.pop(); }

    // 计算l_max：左边第一个比a[i]大的位置
    for (int i = n; i >= 1; --i) {
        while (!stk.empty() && a[i] >= a[stk.top()]) {
            l_max[stk.top()] = i;
            stk.pop();
        }
        stk.push(i);
    }
    while (!stk.empty()) stk.pop();

    // 计算r_min：右边第一个比a[i]小的位置
    for (int i = 1; i <= n; ++i) {
        while (!stk.empty() && a[i] < a[stk.top()]) {
            r_min[stk.top()] = i;
            stk.pop();
        }
        stk.push(i);
    }
    while (!stk.empty()) { r_min[stk.top()] = n + 1; stk.pop(); }

    // 计算l_min：左边第一个比a[i]小的位置
    for (int i = n; i >= 1; --i) {
        while (!stk.empty() && a[i] <= a[stk.top()]) {
            l_min[stk.top()] = i;
            stk.pop();
        }
        stk.push(i);
    }
    while (!stk.empty()) stk.pop();

    // 计算总贡献
    ll ans_max = 0, ans_min = 0;
    for (int i = 1; i <= n; ++i) {
        ans_max += a[i] * (i - l_max[i]) * (r_max[i] - i);
        ans_min += a[i] * (i - l_min[i]) * (r_min[i] - i);
    }
    printf("%lld\n", ans_max - ans_min);
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取数组长度n和数组a。
  2. **单调栈求边界**：用4次单调栈遍历，分别计算每个元素的l_max、r_max（最大值的左右边界）和l_min、r_min（最小值的左右边界）。
  3. **计算贡献**：根据边界计算每个元素的最大值贡献和最小值贡献，相减得到答案。


<code_intro_selected>
接下来分析3份优质题解的核心片段，看看它们的「亮点」在哪里。
</code_intro_selected>

### 题解一：Provicy（单调栈经典实现）
* **亮点**：将最大值和最小值的计算逻辑「复用」，仅改变比较符号，代码简洁。
* **核心代码片段**：
```cpp
// 计算最大值贡献
for (int i = 1; i <= n; ++i) {
    while (tp && a[i] >= a[sta[tp]]) qr[sta[tp--]] = i - 1;
    ql[i] = sta[tp] + 1; sta[++tp] = i;
}
while (tp) qr[sta[tp--]] = n;
for (int i = 1; i <= n; ++i) ans += (i - ql[i] + 1) * (qr[i] - i + 1) * a[i];

// 计算最小值贡献（仅改变比较符号）
memset(ql, 0, sizeof(ql)), memset(qr, 0, sizeof(qr));
for (int i = 1; i <= n; ++i) {
    while (tp && a[i] <= a[sta[tp]]) qr[sta[tp--]] = i - 1;
    ql[i] = sta[tp] + 1; sta[++tp] = i;
}
while (tp) qr[sta[tp--]] = n;
for (int i = 1; i <= n; ++i) ans -= (i - ql[i] + 1) * (qr[i] - i + 1) * a[i];
```
* **代码解读**：
  - 用`sta`数组模拟栈，`tp`是栈顶指针。
  - 计算最大值时，栈内维护「递增」（因为要找「第一个大于等于a[i]」的元素）；计算最小值时，维护「递减」。
  - `ql[i]`是当前元素作为最大值的左边界（sta[tp]+1），`qr[i]`是右边界（i-1或n）。
* 💡 **学习笔记**：通过「复用逻辑+改变比较符号」可以减少重复代码，提高可读性。

### 题解二：zhengrunzhe（增量法）
* **亮点**：用「两个单调栈」动态维护以当前元素结尾的所有子数组的max和min，边加边算，时间复杂度O(n)。
* **核心代码片段**：
```cpp
inline const void insert(const int k) {
    // 弹出所有比a[k]小的元素，更新max的贡献
    for (; top1 && a[k] >= a[s1[top1]]; top1--) 
        sum -= 1ll * (s1[top1] - s1[top1-1]) * a[s1[top1]];
    // 弹出所有比a[k]大的元素，更新min的贡献
    for (; top2 && a[k] <= a[s2[top2]]; top2--) 
        sum += 1ll * (s2[top2] - s2[top2-1]) * a[s2[top2]];
    // 计算新增的max和min贡献
    if (k > 1) {
        sum += 1ll * (k-1 - s1[top1]) * a[k];
        sum -= 1ll * (k-1 - s2[top2]) * a[k];
    }
    s1[++top1] = k; s2[++top2] = k;
    ans += sum;
}
```
* **代码解读**：
  - `s1`是维护max的单调栈（递减），`s2`是维护min的单调栈（递增）。
  - 每次插入元素k时，先弹出破坏单调性的元素（这些元素的max/min被k取代），调整当前总和`sum`（`sum`是「以k结尾的所有子数组的max-min之和」）。
  - 将k入栈，然后将`sum`累加到总答案`ans`中。
* 💡 **学习笔记**：增量法的核心是「动态维护当前状态」，避免预处理所有边界，适合处理「在线」问题。

### 题解三：xixiup（并查集）
* **亮点**：用「并查集」合并连通块，找到当前元素作为最大值的区间边界，思路新颖。
* **核心代码片段**：
```cpp
// 按值从小到大排序，计算最大值贡献
sort(ma+1, ma+1+n);
for (int i = 1; i <= n; ++i) {
    int x = ma[i].loc; // 当前元素的下标
    int fx = find(x); // 查找x的根节点
    // 合并左边的连通块（如果左边元素比当前小）
    if (y >= 1 && nu[y] <= nu[x]) {
        int fy = find(y);
        fa[fy] = fx;
        le[fx] = min(le[fx], le[fy]);
        ri[fx] = max(ri[fx], ri[fy]);
    }
    // 合并右边的连通块（如果右边元素比当前小）
    if (y <= n && nu[y] < nu[x]) {
        int fy = find(y);
        fa[fy] = fx;
        le[fx] = min(le[fx], le[fy]);
        ri[fx] = max(ri[fx], ri[fy]);
    }
    sum += (x - le[fx] + 1) * (ri[fx] - x + 1) * nu[x];
}
```
* **代码解读**：
  - 将元素按值从小到大排序，依次处理每个元素（保证当前元素是已处理元素中的最大值）。
  - 用并查集`fa`维护连通块，`le[fx]`和`ri[fx]`是连通块的左右边界。
  - 合并左右相邻的连通块（这些元素比当前元素小），从而得到当前元素作为最大值的区间边界。
* 💡 **学习笔记**：并查集不仅能处理「连通性」问题，还能用于「区间合并」，拓展了算法的应用场景。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观理解「单调栈求左右边界」的过程，我设计了一个**8位像素风动画**，模拟单调栈处理数组的每一步。动画融合了「复古游戏元素」，比如「像素方块」「音效提示」和「单步执行」，让学习更有趣！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **8位像素风**：采用FC红白机的配色（比如蓝色背景、黄色方块代表数组元素，红色方块代表栈顶），分辨率为「400×300像素」。
- **场景布局**：
  - 左侧：数组展示区（横向排列，每个元素是「20×20像素」的方块，数值显示在方块中央）；
  - 右侧：单调栈展示区（纵向排列，每个元素是「20×20像素」的方块，栈顶元素高亮）；
  - 底部：控制面板（包含「单步」「自动」「重置」按钮，以及速度滑块）。

#### 2. 核心动画流程（以「求右边第一个更大值」为例）
- **初始化**：数组显示为`[1,4,1]`，单调栈为空，控制面板显示「准备就绪」。
- **处理元素1（i=1）**：
  1. 栈为空，直接将1入栈（栈展示区出现黄色方块，显示「1」）；
  2. 音效：「叮」的一声（表示入栈成功）。
- **处理元素4（i=2）**：
  1. 栈顶是1，`a[2]=4 > a[1]=1`，弹出1（栈顶方块消失）；
  2. 标记1的`r_max=2`（数组中1的方块闪烁红色，旁边显示「r_max=2」）；
  3. 栈为空，将4入栈（栈展示区出现红色方块，显示「4」）；
  4. 音效：「叮-叮」（弹出+入栈）。
- **处理元素1（i=3）**：
  1. 栈顶是4，`a[3]=1 < a[2]=4`，直接将1入栈（栈展示区出现黄色方块，显示「1」）；
  2. 音效：「叮」。
- **处理栈剩余元素**：
  1. 弹出4，标记`r_max=4`（数组中4的方块闪烁红色，旁边显示「r_max=4」）；
  2. 弹出1，标记`r_max=4`（数组中1的方块闪烁红色，旁边显示「r_max=4」）；
  3. 音效：「叮-叮」。

#### 3. 交互与游戏化元素
- **单步执行**：点击「单步」按钮，动画执行一步，同时显示文字提示（比如「处理元素i=2，弹出栈顶元素1，r_max[1]更新为2」）。
- **自动播放**：点击「自动」按钮，动画按「速度滑块」设定的速度（100ms~1000ms/步）自动执行。
- **音效设计**：
  - 入栈/出栈：「叮」的短音；
  - 标记边界：「滴」的长音；
  - 完成处理：「胜利」的上扬音调（比如FC游戏的通关音效）。
- **游戏化关卡**：将「求右边第一个更大值」「求左边第一个更大值」「求右边第一个更小值」「求左边第一个更小值」设计为4个「小关卡」，完成每个关卡后显示「关卡完成！得分+10」，激励学习者完成全部流程。

#### 4. 技术实现思路
- **Canvas绘制**：用HTML5 Canvas绘制像素方块和文字，通过`requestAnimationFrame`实现动画。
- **音效**：用Web Audio API播放预先录制的8位音效（比如`pop.wav`「弹出」、`push.wav`「入栈」）。
- **状态管理**：用JavaScript对象管理数组、栈、边界等状态，确保动画与数据同步。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「贡献法+单调栈」是一类非常经典的算法套路，能解决很多「区间统计」问题。下面推荐几道洛谷的相似题目，帮助大家巩固所学！
</similar_problems_intro>

### 通用思路迁移
「贡献法+单调栈」的适用场景包括：
1. **求所有子数组的最大值之和**（如本题）；
2. **求所有子数组的最小值之和**（如本题）；
3. **求直方图中最大矩形的面积**（LeetCode 84，洛谷 P2629）；
4. **求滑动窗口的最大值/最小值**（洛谷 P1886）。

### 洛谷练习推荐
1. **洛谷 P1886** - 滑动窗口 /【模板】单调队列  
   * 🗣️ **推荐理由**：这是「单调队列」的模板题，能帮助你巩固「维护单调性」的思路，与单调栈异曲同工。
   
2. **洛谷 P2629** - 营业额统计  
   * 🗣️ **推荐理由**：本题要求「每天的最小波动值」（与之前某一天的差值最小），可以用「单调栈」或「平衡树」解决，是「贡献法」的变形应用。
   
3. **洛谷 P3810** - 【模板】三维偏序（陌上花开）  
   * 🗣️ **推荐理由**：虽然这是「树状数组」的模板题，但其中「按维度排序+维护单调性」的思路与单调栈一致，能拓展你的算法视野。
   
4. **洛谷 P5788** - 【模板】单调栈  
   * 🗣️ **推荐理由**：这是「单调栈」的模板题，直接要求求「每个元素的右边第一个更大值」，完美匹配本题的核心逻辑！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们可以学到很多「实战经验」，这些经验能帮你避免踩坑：
</insights_intro>

> **经验1**（来自yzh_Error404）：「处理重复元素时，比较符号的选择很重要！比如求最大值时，右边用`>`，左边用`>=`，这样能避免重复计算。」  
> **点评**：这是解决「重复元素」的关键技巧，直接决定了代码的正确性。如果比较符号选错，会导致某些区间的max/min被多次计算，结果偏大或偏小。

> **经验2**（来自zhengrunzhe）：「增量法的核心是『动态维护当前状态』，不需要预处理所有边界，适合处理大数据量的问题。」  
> **点评**：增量法的时间复杂度是O(n)，比预处理边界的方法更高效（虽然预处理也是O(n)，但增量法的常数更小），适合n=1e6的规模。

> **经验3**（来自xixiup）：「并查集不仅能处理连通性问题，还能用于区间合并，拓展了算法的应用场景。」  
> **点评**：这提醒我们，算法不是孤立的——并查集、单调栈、树状数组等工具可以相互结合，解决更复杂的问题。


<conclusion>
本次关于「Imbalanced Array」的分析就到这里！通过这道题，我们学会了「贡献法」的核心思想，掌握了「单调栈」的使用技巧，还了解了「增量法」和「并查集」的创新思路。记住：**算法的本质是「问题转化」——将复杂的问题拆成简单的子问题，再用合适的工具解决**。下次遇到「区间统计」问题时，不妨先想想「贡献法」哦！💪
</conclusion>

---
处理用时：154.34秒
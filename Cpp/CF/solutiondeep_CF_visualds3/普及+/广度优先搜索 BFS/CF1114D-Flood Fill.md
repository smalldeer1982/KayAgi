# 题目信息

# Flood Fill

## 题目描述

You are given a line of $ n $ colored squares in a row, numbered from $ 1 $ to $ n $ from left to right. The $ i $ -th square initially has the color $ c_i $ .

Let's say, that two squares $ i $ and $ j $ belong to the same connected component if $ c_i = c_j $ , and $ c_i = c_k $ for all $ k $ satisfying $ i < k < j $ . In other words, all squares on the segment from $ i $ to $ j $ should have the same color.

For example, the line $ [3, 3, 3] $ has $ 1 $ connected component, while the line $ [5, 2, 4, 4] $ has $ 3 $ connected components.

The game "flood fill" is played on the given line as follows:

- At the start of the game you pick any starting square (this is not counted as a turn).
- Then, in each game turn, change the color of the connected component containing the starting square to any other color.

Find the minimum number of turns needed for the entire line to be changed into a single color.

## 说明/提示

In the first example, a possible way to achieve an optimal answer is to pick square with index $ 2 $ as the starting square and then play as follows:

- $ [5, 2, 2, 1] $
- $ [5, 5, 5, 1] $
- $ [1, 1, 1, 1] $

In the second example, a possible way to achieve an optimal answer is to pick square with index $ 5 $ as the starting square and then perform recoloring into colors $ 2, 3, 5, 4 $ in that order.

In the third example, the line already consists of one color only.

## 样例 #1

### 输入

```
4
5 2 2 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
8
4 5 2 2 1 3 5 5
```

### 输出

```
4
```

## 样例 #3

### 输入

```
1
4
```

### 输出

```
0
```

# AI分析结果

# 💡 Kay的C++算法解析：Flood Fill 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：区间动态规划（区间DP）

🗣️ **初步分析**：  
解决「Flood Fill」的关键，是把**连续相同颜色的方块“粘成一块”**（预处理），再用**区间DP**计算合并这些“块”的最小步数。简单来说，区间DP就像“拼积木”——把小的区间（积木块）慢慢合并成大的区间（完整积木），每一步都选最省力气的方式。  

在本题中，区间DP的作用是：计算将**第i到第j个“块”**染成同色的最小操作次数（记为`dp[i][j]`）。核心思路是：  
- 如果第i块和第j块颜色相同，那么合并中间的`i+1到j-1`块后，只需再染一次就能把两端连起来（`dp[i][j] = dp[i+1][j-1] + 1`）；  
- 如果颜色不同，要么先合并`i+1到j`块再染i块，要么先合并`i到j-1`块再染j块，取更省步数的那个（`dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1`）。  

**可视化设计思路**：我们会用**8位像素风格**展示“块合并”的过程——用不同颜色的像素块代表压缩后的连通块，每次合并时高亮当前区间，用“叮”的音效提示操作，自动播放时像“贪吃蛇吃积木”一样逐步完成合并。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下优质题解，它们都抓住了“压缩连通块+区间DP”的核心，非常适合入门学习：
</eval_intro>

**题解一：来源：lzpclxf**  
* **点评**：这份题解的**预处理步骤非常巧妙**——输入时直接跳过连续相同的颜色，把原序列压缩成“不同颜色块”的序列，大幅减少了后续计算量。区间DP的循环逻辑也很清晰：先枚举区间长度，再枚举左端点，最后根据两端颜色是否相同转移。代码简洁到“一眼就能看懂”，而且边界处理严谨（比如数组大小设置合理，避免了MLE/RE），是入门区间DP的绝佳参考。

**题解二：来源：rui_er**  
* **点评**：这道题的另一种思路——**三维DP**（`dp[i][j][0/1]`表示i到j块染成左/右边颜色的最小步数）。虽然状态多了一维，但更直观地展示了“染成哪侧颜色”的选择过程。转移方程通过“扩展区间”（向左或向右加一块）推导，适合想深入理解状态设计的同学。代码中的`updDP`函数（更新最小值）也体现了良好的编程习惯。

**题解三：来源：MY（一名蒟蒻）**  
* **点评**：这篇题解的**状态设计解释非常详细**——为什么要把“染成左/右颜色”放进状态？因为如果不知道区间的最终颜色，就无法正确转移。作者用“如果DP有不知道的东西，就把它放进下标”的口诀，帮我们打通了状态设计的“任督二脉”。代码虽然没有预处理，但逻辑完整，适合新手一步步跟着写。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键，在于突破以下3个“思维卡点”：
</difficulty_intro>

1. **卡点1：为什么要压缩连续相同的颜色？**  
   * **分析**：原序列中连续相同的颜色属于同一个连通块，操作时会被一起染色，因此可以“粘成一块”。比如`[5,2,2,1]`压缩后变成`[5,2,1]`，这样计算时只需要处理3个块，而不是4个。所有优质题解都做了这一步，因为它能把问题规模从`n`（最多5000）缩小到`num`（最多5000，但实际更小），避免不必要的计算。  
   * 💡 **学习笔记**：预处理是区间DP的“开胃菜”，能帮你简化问题！

2. **卡点2：区间DP的转移方程怎么来的？**  
   * **分析**：当两端颜色相同时（比如块i是红色，块j也是红色），合并中间的`i+1到j-1`块后，只需再染一次红色就能把整个区间连起来——这一步对应`dp[i][j] = dp[i+1][j-1] + 1`。当颜色不同时，只能选择“先合并左边再染右边”或“先合并右边再染左边”，取最小值加1——对应`dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1`。  
   * 💡 **学习笔记**：转移方程的核心是“如何用小区间的解推导大区间的解”。

3. **卡点3：区间DP的遍历顺序为什么是“长度从小到大”？**  
   * **分析**：区间DP需要先计算小范围的`dp[i][j]`（比如长度为1的区间），再用它们推导大范围的`dp[i][j]`（比如长度为2、3的区间）。就像拼积木，要先拼好小积木，才能拼成大积木。如果反过来遍历，会出现“需要的小区间解还没计算”的错误。  
   * 💡 **学习笔记**：区间DP的遍历顺序永远是“长度优先”！


### ✨ 解题技巧总结
- **技巧A：预处理简化问题**：遇到连续相同的元素，先压缩成一个块，减少计算量；  
- **技巧B：状态设计要“无后效性”**：状态要能唯一表示子问题的解（比如`dp[i][j]`表示i到j块的最小步数）；  
- **技巧C：转移方程要“覆盖所有情况”**：分情况讨论（两端相同/不同），确保所有可能的转移路径都被考虑到。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了所有优质题解的精华，包含预处理和区间DP的完整逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自优质题解的整合，重点展示“压缩连通块+区间DP”的核心逻辑，适合直接套用。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int N = 5010; // 注意数组大小要足够（原n最多5000）
  int a[N], dp[N][N];
  int n, num; // num是压缩后的块数

  int main() {
      cin >> n;
      int pre = -1; // 记录上一个颜色（初始为-1，避免和输入颜色冲突）
      for (int i = 1; i <= n; ++i) {
          int x;
          cin >> x;
          if (x != pre) { // 如果当前颜色和上一个不同，添加到压缩后的数组
              a[++num] = x;
              pre = x;
          }
      }
      // 区间DP：枚举区间长度（从1到num-1）
      for (int len = 1; len < num; ++len) {
          // 枚举左端点i，右端点j = i + len
          for (int i = 1; i + len <= num; ++i) {
              int j = i + len;
              if (a[i] == a[j]) {
                  // 两端颜色相同：合并中间区间后+1
                  dp[i][j] = dp[i+1][j-1] + 1;
              } else {
                  // 两端颜色不同：取左边或右边的最小值+1
                  dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;
              }
          }
      }
      cout << dp[1][num] << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **预处理**：输入时跳过连续相同的颜色，把原序列压缩成`a`数组（`num`是块数）；  
  2. **区间DP**：先枚举区间长度`len`（从1到`num-1`），再枚举左端点`i`，计算右端点`j = i + len`；  
  3. **转移方程**：根据`a[i]`和`a[j]`是否相同，选择不同的转移方式；  
  4. **输出结果**：`dp[1][num]`就是合并所有块的最小步数。


<code_intro_selected>
接下来，我们看几道优质题解的**核心片段**，分析它们的亮点：
</code_intro_selected>

**题解一：来源：lzpclxf**
* **亮点**：预处理步骤“一键压缩”连续相同颜色，代码简洁到“一行搞定”。
* **核心代码片段**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      int x;
      scanf("%d", &x);
      if (x != fre) a[++num] = x;
      fre = x;
  }
  ```
* **代码解读**：  
  用`fre`记录上一个颜色，输入时如果当前颜色`x`不等于`fre`，就把`x`加入压缩后的数组`a`，并更新`fre`。这一步把原序列的连续相同颜色“粘成一块”，大幅减少后续计算量。  
* 💡 **学习笔记**：预处理的关键是“跳过连续相同的元素”，用一个变量记录上一个值就能实现。

**题解二：来源：rui_er**
* **亮点**：三维DP状态设计，直观展示“染成左/右颜色”的选择。
* **核心代码片段**：
  ```cpp
  int dp[N][N][2]; // dp[i][j][0]：i到j染成左颜色的最小步数；dp[i][j][1]：染成右颜色的最小步数
  // 转移方程
  if (i > 1) updDP(dp[i-1][j][0], dp[i][j][bit] + (col != a[i-1]));
  if (j < n) updDP(dp[i][j+1][1], dp[i][j][bit] + (col != a[j+1]));
  ```
* **代码解读**：  
  `bit`是0或1，表示当前区间染成左/右颜色。`col`是当前区间的颜色（`a[i]`或`a[j]`）。如果向左扩展一块`i-1`，如果`col`和`a[i-1]`不同，就需要加1步（染一次）；向右扩展同理。  
* 💡 **学习笔记**：如果状态需要“记录额外信息”（比如最终颜色），可以加一维状态！

**题解三：来源：MY（一名蒟蒻）**
* **亮点**：详细解释了“为什么要加一维状态”，帮新手打通思路。
* **核心代码片段**：
  ```cpp
  for (int len = 1; len <= n; len++) {
      for (int i = 1; i + len - 1 <= n; i++) {
          j = i + len - 1;
          // 向左扩展i-1
          if (a[i] == a[i-1]) f[i-1][j][0] = min(f[i-1][j][0], f[i][j][0]);
          else f[i-1][j][0] = min(f[i-1][j][0], f[i][j][0] + 1);
          // 向右扩展j+1
          if (a[j] == a[j+1]) f[i][j+1][1] = min(f[i][j+1][1], f[i][j][1]);
          else f[i][j+1][1] = min(f[i][j+1][1], f[i][j][1] + 1);
      }
  }
  ```
* **代码解读**：  
  作者用“扩展区间”的方式推导转移方程——每次向左或向右加一块，根据新块的颜色是否和当前区间的颜色相同，决定是否加步数。这种方式更直观，适合新手理解“区间是怎么长大的”。  
* 💡 **学习笔记**：转移方程的推导可以用“扩展区间”的思路，把大问题拆成小问题！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让大家“看清楚”区间DP的合并过程，我设计了一个**像素积木合并游戏**——用8位像素风格展示压缩后的块，像拼积木一样逐步合并，还有复古音效哦！
\</visualization\_intro\>

### 动画演示主题
**像素块合并大挑战**：你需要把不同颜色的像素块合并成一个大色块，每一步都要选最省步数的方式！

### 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧显示**压缩后的像素块**（比如样例1的`[5,2,1]`，用红、蓝、绿三种像素块表示）；  
   - 右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，还有“速度滑块”（控制自动播放的快慢）；  
   - 底部显示**当前步数**和**提示文字**（比如“下一步合并块1-2”）。

2. **算法启动**：  
   - 点击“开始”，动画自动播放：先高亮块1-1（红色），步数0；再高亮块2-2（蓝色），步数0；最后高亮块3-3（绿色），步数0（单个块不需要操作）。

3. **合并过程**：  
   - **合并块1-2**（红和蓝）：因为颜色不同，取`min(dp[2][2], dp[1][1]) +1` → `0+0+1=1`。动画中，块1-2变成紫色（临时颜色），伴随“叮”的音效，步数显示1。  
   - **合并块2-3**（蓝和绿）：同样颜色不同，步数+1 → 1。块2-3变成黄色，音效“叮”。  
   - **合并块1-3**（红和绿）：颜色不同，取`min(dp[2][3], dp[1][2]) +1` → `1+1+1=2`（样例1的输出）。块1-3变成橙色，伴随“咻”的胜利音效，屏幕弹出“完成！总步数2”。

4. **交互设计**：  
   - **单步模式**：点击“单步”，动画走一步，方便观察每一步的转移；  
   - **自动播放**：用滑块调整速度（慢/中/快），像“贪吃蛇吃积木”一样自动合并；  
   - **重置**：回到初始状态，重新开始。

### 复古游戏化元素
- **音效**：合并时“叮”，胜利时“咻”，错误时“哔”（比如选了更费步数的方式）；  
- **积分**：每合并一个区间得10分，完成所有合并得100分，激励你“用最少步数拿最高分”；  
- **BGM**：循环播放8位风格的《超级马里奥》背景音乐，营造复古游戏氛围。

\<visualization\_conclusion\>
通过这个动画，你能**直观看到区间DP的每一步**——从单个块到合并成大区间，每一步的选择和步数变化都清清楚楚。就像玩游戏一样，不知不觉就学会了区间DP！
\</visualization\_conclusion\>


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了“压缩连通块+区间DP”的思路后，你可以解决很多类似的问题——比如“涂色问题”“石子合并”等。
\</similar\_problems\_intro\>

### 通用思路/技巧迁移
- **场景1**：给字符串涂色，每次涂连续相同的字符（比如洛谷P4170）；  
- **场景2**：合并石子，每次合并相邻的两堆（比如洛谷P1880）；  
- **场景3**：给区间染成同色，求最少操作次数（比如洛谷P2858）。  

这些问题的核心都是**“用小区间的解推导大区间的解”**，只要掌握了区间DP的思路，都能轻松解决！


### 练习推荐 (洛谷)
1. **洛谷 P1880** - [NOI1995] 石子合并  
   * 🗣️ **推荐理由**：区间DP的经典题！需要合并相邻石子，求最小合并代价，能帮你巩固“区间长度优先”的遍历顺序。  
2. **洛谷 P4170** - [涂色]  
   * 🗣️ **推荐理由**：和本题几乎一样！只不过把“方块”换成了“字符”，需要涂连续相同的字符，能帮你熟练掌握“压缩连通块+区间DP”的思路。  
3. **洛谷 P2858** - [奶牛浴场]  
   * 🗣️ **推荐理由**：区间DP的变形题！需要求最大矩形面积，能帮你拓展“区间DP的应用场景”。  
4. **洛谷 P3146** - [区间DP练习]  
   * 🗣️ **推荐理由**：专门为区间DP设计的练习场，包含多种变形，能帮你彻底掌握区间DP的技巧。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
优质题解中的作者经验能帮我们避免踩坑，比如：
\</insights\_intro\>

> **参考经验 (来自 lzpclxf)**：“开数组一定要看数据范围！我之前因为数组开小了，导致MLE（内存超限），后来改成`const int N = 10101`才解决。”  
> **点评**：这位作者的经验很重要！C++中数组的大小要足够容纳最大的输入（本题n最多5000，所以数组开5010就够了）。如果数组开小了，会导致内存访问错误（RE）或内存超限（MLE）。以后写代码时，一定要先看题目中的数据范围！


## 总结
本次分析的「Flood Fill」题，核心是**“压缩连通块+区间DP”**。通过预处理简化问题，用区间DP计算最小步数，再结合可视化动画，你一定能轻松掌握！  

记住：编程就像拼积木——先拼小的，再拼大的，每一步都要选最聪明的方式。下次遇到区间问题，试着用今天学的思路解决吧！💪

---
处理用时：165.15秒
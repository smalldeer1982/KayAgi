# 题目信息

# Nearest Opposite Parity

## 题目描述

给出一个长度为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，当你在第 $i$ 号位置时，你可以一步跳到 $i-a_i$ 或 $i+a_i$。

对于每一个位置 $i$，你想知道最少需要多少步可以到达一个位置 $j$，使得 $a_j$ 与 $a_i$ 的奇偶性不同。

## 说明/提示

$1 \le n \le 2 \cdot 10^5$，$1 \le a_i \le n$。

## 样例 #1

### 输入

```
10
4 5 7 6 7 5 4 4 6 4
```

### 输出

```
1 1 1 2 -1 1 1 3 1 1 
```

# AI分析结果

# 💡 Kay的C++算法解析：Nearest Opposite Parity 深入学习指南 💡


今天我们来一起分析「Nearest Opposite Parity」这道C++编程题。这道题需要我们找到每个位置到**奇偶性不同**的位置的最少步数，核心是图论中的「多源BFS」思想。本指南会帮你理清思路、掌握关键技巧，还会用像素动画直观展示算法过程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（多源BFS）、反向建图


🗣️ **初步分析**：  
解决这道题的关键，是把「找最少步数到奇偶不同的位置」转化为**图的最短路径问题**。我们可以把每个位置看作图中的节点，从位置`i`能跳到`i±a[i]`，就相当于节点`i`到`i±a[i]`有一条边（边权为1）。但直接对每个节点跑BFS会超时（因为`n`高达2e5），所以我们需要**反向思考**：  

想象所有「奇偶性不同的目标点」是「起点」，一起出发扩散——比如要找偶数位置到最近奇数的步数，就把所有奇数位置作为起点，用BFS扩散；要找奇数位置到最近偶数的步数，就把所有偶数位置作为起点。这样每个节点第一次被访问时的步数，就是**最短路径**（因为BFS是按层遍历的，先到的一定是最近的）。  

为了实现这种「从目标点找当前点」的逻辑，我们需要**反向建图**：原本的边是`i → i±a[i]`，反向后变成`i±a[i] → i`。这样从目标点（比如奇数位置）出发，沿着反向边扩散，就能覆盖所有能到达它的节点（即需要找奇数的偶数位置）。  

**可视化设计思路**：我们会用8位像素风展示「多源BFS扩散」的过程——红色格子代表奇数位置（起点），蓝色代表偶数，BFS时每个格子被访问会闪烁并显示步数，伴随「叮」的入队音效，最后用胜利音效提示完成。


## 2. 精选优质题解参考

为了帮你快速掌握核心思路，我筛选了3份**逻辑清晰、代码规范**的优质题解：


### 题解一：(来源：quanjun)
* **点评**：这份题解是「多源BFS+反向建图」的标准实现，思路非常直白！作者把问题拆成两步：先算每个位置到最近奇数的步数（`odd`数组），再算到最近偶数的步数（`even`数组）。代码结构清晰，变量命名（`odd`/`even`）直接对应题意，边界处理（比如`i±a[i]`是否越界）也很严谨。尤其是**分两次BFS**的逻辑，完美对应「找不同奇偶性」的需求，非常适合入门学习。


### 题解二：(来源：Fan_Tuan)
* **点评**：作者用了「超级源点+SPFA」的思路，把多源BFS转化为单源最短路——比如用「超级奇数源点」连接所有奇数位置（边权0），再跑SPFA得到所有点到奇数的最短步数。这种方法虽然用到了SPFA，但本质还是多源BFS的变形，适合想拓展「最短路」知识的同学。代码中的`read`/`print`函数是竞赛常用的快读快写技巧，值得学习！


### 题解三：(来源：live_cxy110122)
* **点评**：这份题解用「多源BFS」的模板化代码解决问题，函数`bfs`通过参数`val`（0代表偶数、1代表奇数）复用了两次BFS逻辑，非常简洁！代码中的`nbr`数组存储反向边，`dis1`/`dis2`分别记录到奇数/偶数的步数，逻辑和题解一完全一致，但代码更模块化，适合学习「代码复用」的技巧。


## 3. 核心难点辨析与解题策略

在解决这道题时，你可能会遇到3个核心难点，我们逐一拆解：


### 1. **难点1：为什么要反向建图？**  
- **分析**：原本的边是`i → i±a[i]`（表示从`i`能跳到`j`），但我们要找的是「从`j`（目标点）到`i`的最短路径」（因为`i`需要到`j`）。反向建图后，边变成`j → i`，这样从`j`出发的BFS就能覆盖所有能到达`j`的`i`，刚好对应我们的需求。  
- 💡 **学习笔记**：反向建图是「从结果找原因」的常用技巧，能把多源问题转化为更高效的遍历。


### 2. **难点2：多源BFS怎么工作？**  
- **分析**：普通BFS是从一个起点出发，而多源BFS是**从所有目标点同时出发**。比如要找偶数到最近奇数的步数，就把所有奇数位置加入队列（步数0），然后逐层扩散——每个节点第一次被访问时的步数，就是到最近目标点的最短距离（因为BFS按层遍历，先到的一定更近）。  
- 💡 **学习笔记**：多源BFS的核心是「同时启动所有起点」，避免重复计算，时间复杂度是O(n)，比逐个节点跑BFS的O(n²)高效得多！


### 3. **难点3：如何处理奇偶性？**  
- **分析**：我们需要分两次BFS：  
  1. 第一次：把所有奇数位置作为起点，计算每个位置到最近奇数的步数（`odd`数组）；  
  2. 第二次：把所有偶数位置作为起点，计算每个位置到最近偶数的步数（`even`数组）。  
  最后，对于每个位置`i`：如果`a[i]`是奇数，输出`even[i]`（到最近偶数的步数）；如果是偶数，输出`odd[i]`（到最近奇数的步数）。  
- 💡 **学习笔记**：分情况处理奇偶性，是把复杂问题拆分成两个简单子问题的关键。


### ✨ 解题技巧总结
- **反向建图**：当需要「从结果找原因」时，试试把边反过来；  
- **多源BFS**：处理「多个起点找最短路径」时，用多源BFS代替逐个BFS；  
- **分情况讨论**：把奇偶性拆成两个子问题，降低问题复杂度；  
- **边界处理**：永远要检查`i±a[i]`是否在1~n范围内，避免数组越界！


## 4. C++核心代码实现赏析

在看具体题解片段前，先看一份**通用核心实现**——综合了题解一的思路，代码简洁清晰：


### 本题通用核心C++实现参考
* **说明**：本代码是「多源BFS+反向建图」的标准实现，逻辑直接，适合入门。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int MAXN = 2e5 + 10;
int a[MAXN], odd[MAXN], even[MAXN];
vector<int> g[MAXN]; // 反向图：g[u]存储u能到达的节点v（即原边是v→u）

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        // 反向建图：原边i→i-a[i] → 反向边i-a[i]→i
        if (i - a[i] >= 1) g[i - a[i]].push_back(i);
        if (i + a[i] <= n) g[i + a[i]].push_back(i);
    }

    // 第一步：计算每个点到最近奇数的步数（odd数组）
    queue<int> q;
    for (int i = 1; i <= n; ++i) {
        if (a[i] % 2 == 1) {
            odd[i] = 0;
            q.push(i);
        } else {
            odd[i] = -1; // 初始化为-1表示未访问
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : g[u]) { // u能到达v（反向边）
            if (odd[v] == -1) { // 未访问过
                odd[v] = odd[u] + 1;
                q.push(v);
            }
        }
    }

    // 第二步：计算每个点到最近偶数的步数（even数组）
    for (int i = 1; i <= n; ++i) {
        if (a[i] % 2 == 0) {
            even[i] = 0;
            q.push(i);
        } else {
            even[i] = -1;
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : g[u]) {
            if (even[v] == -1) {
                even[v] = even[u] + 1;
                q.push(v);
            }
        }
    }

    // 输出结果
    for (int i = 1; i <= n; ++i) {
        if (i > 1) cout << " ";
        if (a[i] % 2 == 1) {
            cout << even[i]; // 奇数找偶数
        } else {
            cout << odd[i];  // 偶数找奇数
        }
    }
    cout << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **反向建图**：把原边`i→i±a[i]`反过来，存储为`i±a[i]→i`；  
  2. **多源BFS计算odd数组**：所有奇数位置作为起点，BFS得到每个位置到最近奇数的步数；  
  3. **多源BFS计算even数组**：所有偶数位置作为起点，同理；  
  4. **输出结果**：根据当前位置的奇偶性，输出对应的步数。


### 针对各优质题解的片段赏析

#### 题解一：(来源：quanjun)
* **亮点**：变量命名直接对应题意，逻辑拆分明确，是「多源BFS」的标准模板。
* **核心代码片段**：
```cpp
// 计算odd数组（到最近奇数的步数）
for (int i = 1; i <= n; i ++) {
    if (a[i]%2) {
        odd[i] = 0;
        que.push(i);
    } else odd[i] = -1;
}
while (!que.empty()) {
    int u = que.front(); que.pop();
    for (int v : g[u]) {
        if (odd[v] == -1) {
            odd[v] = odd[u] + 1;
            que.push(v);
        }
    }
}
```
* **代码解读**：  
  - 首先遍历所有位置，把奇数位置的`odd`设为0（步数0），加入队列；  
  - 然后BFS：取出队列中的节点`u`，遍历它能到达的节点`v`（反向边）；  
  - 如果`v`未被访问过（`odd[v] == -1`），就把`v`的步数设为`u`的步数+1，加入队列。  
  这一步的核心是「多源扩散」——所有奇数位置同时出发，覆盖所有能到达它们的节点。
* 💡 **学习笔记**：多源BFS的关键是「先把所有起点加入队列」，然后按层遍历。


#### 题解二：(来源：Fan_Tuan)
* **亮点**：用「超级源点」将多源BFS转化为单源最短路，拓展了最短路的思路。
* **核心代码片段**：
```cpp
// 超级源点：n+1代表奇数源点，n+2代表偶数源点
for (int i = 1; i <= n; i++) {
    if (a[i] & 1) add(n + 1, i, 0); // 奇数连到超级奇数源点（边权0）
    else add(n + 2, i, 0);          // 偶数连到超级偶数源点（边权0）
}
spfa(n + 1); // 跑超级奇数源点的最短路，得到偶数点到奇数的步数
for (int i = 1; i <= n; i++) if (a[i]%2 == 0) ans[i] = dis[i];
spfa(n + 2); // 跑超级偶数源点的最短路，得到奇数点到偶数的步数
```
* **代码解读**：  
  - 作者创建了两个超级源点：`n+1`（连接所有奇数位置）和`n+2`（连接所有偶数位置）；  
  - 用SPFA跑超级源点的最短路，相当于把所有奇数/偶数位置作为起点同时出发；  
  - 最后根据位置的奇偶性，取对应的最短路值。  
  这种方法的好处是可以复用最短路模板，适合已经学过SPFA的同学。
* 💡 **学习笔记**：超级源点是「将多源问题转化为单源」的常用技巧。


#### 题解三：(来源：live_cxy110122)
* **亮点**：用函数`bfs`复用了两次BFS逻辑，代码更简洁。
* **核心代码片段**：
```cpp
void bfs(int dis[], int val) {
    queue<node> q;
    for (int i = 1; i <= n; i++) {
        if (a[i]%2 == val) { // val=1是奇数，val=0是偶数
            dis[i] = 0;
            q.push({i, 0});
        } else dis[i] = -1;
    }
    while (!q.empty()) {
        int cur = q.front().id;
        int step = q.front().step;
        q.pop();
        for (int nx : nbr[cur]) { // 遍历反向边
            if (dis[nx] == -1) {
                dis[nx] = step + 1;
                q.push({nx, step + 1});
            }
        }
    }
}
```
* **代码解读**：  
  - 函数`bfs`接收两个参数：`dis`数组（存储步数）和`val`（目标奇偶性）；  
  - 首先把所有`a[i]%2 == val`的位置加入队列（步数0）；  
  - 然后BFS遍历反向边，更新未访问节点的步数。  
  这种写法把两次BFS的逻辑复用了，减少了代码冗余，非常值得学习！
* 💡 **学习笔记**：代码复用能让逻辑更清晰，减少重复代码的错误。


## 5. 算法可视化：像素动画演示 (核心部分)

为了让你直观看到「多源BFS」的过程，我设计了一个**8位像素风的动画**，结合复古游戏元素，让算法“动起来”！


### 🎮 动画设计方案
#### 1. **整体风格**：  
仿照FC红白机的像素风格，用16色调色板（比如红色代表奇数、蓝色代表偶数、黄色代表当前访问的节点），背景是浅灰色网格，控制面板是复古按键风格。


#### 2. **核心演示内容**：  
展示「从奇数位置出发的多源BFS」过程——如何从所有奇数位置扩散，覆盖所有偶数位置，计算最短步数。


#### 3. **动画步骤与交互**：
1. **场景初始化**：  
   - 屏幕中央显示10x1的像素网格（对应样例输入的10个位置），每个格子显示`a[i]`的值，红色=奇数，蓝色=偶数；  
   - 下方控制面板有「开始」「单步」「重置」按钮，以及「速度滑块」（控制动画播放速度）；  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **多源BFS启动**：  
   - 所有红色格子（奇数位置，比如样例中的1、2、3、5、6、9）闪烁3次，伴随「叮」的音效，表示这些是起点；  
   - 把这些格子加入队列，显示步数0。

3. **BFS扩散过程**：  
   - **单步模式**：点击「单步」，队列中的第一个格子（比如位置1）向外扩散，访问它的反向边节点（比如位置1+a[1]=5？不，反向边是`i-a[i]`和`i+a[i]`到`i`，所以位置1的反向边是`1+a[1]=5`吗？等一下，原边是`i→i±a[i]`，反向边是`i±a[i]→i`。比如样例中`a[1]=4`，所以原边是1→1-4=-3（无效）和1→1+4=5，反向边是5→1。所以当位置5（奇数）作为起点时，会扩散到位置1。  
   - 当节点被访问时，格子颜色变为黄色，显示当前步数（比如位置1被位置5访问，步数=1），伴随「嗒」的音效；  
   - **自动模式**：点击「开始」，动画自动按速度滑块的速度播放，直到所有可达节点被访问。

4. **结果展示**：  
   - 所有节点的步数显示在格子下方，无法到达的节点（比如样例中的位置5）显示红色「-1」；  
   - 播放胜利音效（比如《魂斗罗》的通关音乐），并弹出「BFS完成！」的像素文字。


#### 4. **游戏化元素**：
- **关卡设计**：把BFS的「层遍历」拆成小关卡——完成第k层遍历（所有步数为k的节点被访问），就显示「关卡k完成！」的提示，加10分；  
- **积分系统**：完成所有节点访问，总积分=关卡数×10，显示在屏幕右上角，激励你“通关”；  
- **音效反馈**：入队=「叮」，访问节点=「嗒」，胜利=「通关音乐」，失败=「短促提示音」，强化操作记忆。


### 🛠️ 技术实现思路
- **Canvas绘制**：用HTML5 Canvas绘制像素网格，每个格子是16x16的像素块，颜色用RGB值模拟8位风格；  
- **BFS逻辑**：用JavaScript实现多源BFS，记录每个节点的步数和状态（未访问/已访问/队列中）；  
- **交互控制**：用按钮和滑块控制动画的播放、暂停、单步，速度滑块改变`setInterval`的时间间隔；  
- **音效**：用Web Audio API播放8位音效（比如从[Freesound](https://freesound.org/)下载的复古音效）。


## 6. 拓展练习与相似问题思考

掌握了「多源BFS+反向建图」的思路后，我们可以把它用到很多类似问题中：


### 🧠 通用思路迁移
- **多源最短路径**：比如「找所有房子到最近医院的距离」（医院是起点，多源BFS）；  
- **反向建图**：比如「找每个节点能到达的最远节点」（反向建图后跑BFS）；  
- **奇偶性/分类问题**：比如「找每个位置到最近质数的步数」（质数作为起点，多源BFS）。


### 📚 洛谷练习推荐
1. **洛谷 P1144** - 最短路径计数  
   🗣️ **推荐理由**：这道题是多源BFS的经典题，需要计算每个节点到起点的最短路径数目，能巩固「多源扩散」的思路。

2. **洛谷 P1332** - 血色先锋队  
   🗣️ **推荐理由**：题目是「多源BFS找最短时间」，和本题的「多源找最短步数」逻辑几乎一致，适合练习反向建图。

3. **洛谷 P2921** - 牛线  
   🗣️ **推荐理由**：需要找每个牛到最近牛线的距离，也是多源BFS的应用，能帮你熟悉「分情况处理」的技巧。

4. **洛谷 P3916** - 图的遍历  
   🗣️ **推荐理由**：这道题需要反向建图找每个节点能到达的最大节点，能巩固「反向建图」的技巧。


## 7. 学习心得与经验分享 (若有)

从题解中，我们可以学到一些**实用的解题经验**：

> **经验1（来自quanjun）**：“对于边权均为1的图，BFS就是最短路。”  
> **点评**：这提醒我们，遇到「最短路径」问题时，如果边权相同，优先用BFS（时间复杂度O(n)），比Dijkstra（O(nlogn)）或SPFA（不稳定）更高效。

> **经验2（来自Fan_Tuan）**：“暴力跑n次BFS会超时，所以要想到反向建图和多源BFS。”  
> **点评**：当数据量很大时（比如n=2e5），暴力方法肯定不行，必须想更高效的算法——反向建图和多源BFS是解决这类问题的“神器”。

> **经验3（来自live_cxy110122）**：“用函数复用代码，减少重复劳动。”  
> **点评**：代码复用能让逻辑更清晰，减少错误——比如把两次BFS写成一个函数，只需要传不同的参数，就能避免写重复的代码。


## 🎉 总结
这道题的核心是「多源BFS+反向建图」，关键是要**反向思考**：把目标点作为起点，用BFS扩散得到最短路径。通过这道题，你不仅学会了多源BFS的用法，还掌握了反向建图、分情况处理等实用技巧。

记住：编程的本质是「解决问题」——遇到困难时，不妨换个角度思考（比如反向建图），或者把问题拆成小部分（比如分两次BFS），总能找到突破口！

下次我们再一起探索新的编程挑战吧！💪

---
处理用时：176.24秒
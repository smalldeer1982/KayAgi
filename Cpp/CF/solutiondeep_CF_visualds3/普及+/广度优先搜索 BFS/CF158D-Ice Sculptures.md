# 题目信息

# Ice Sculptures

## 题目描述

The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus $ n $ ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular $ n $ -gon. They are numbered in clockwise order with numbers from 1 to $ n $ .

The site of the University has already conducted a voting that estimated each sculpture's characteristic of $ t_{i} $ — the degree of the sculpture's attractiveness. The values of $ t_{i} $ can be positive, negative or zero.

When the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that:

- the remaining sculptures form a regular polygon (the number of vertices should be between 3 and $ n $ ),
- the sum of the $ t_{i} $ values of the remaining sculptures is maximized.

Help the Vice Rector to analyze the criticism — find the maximum value of $ t_{i} $ sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.

## 说明/提示

In the first sample it is best to leave every second sculpture, that is, leave sculptures with attractivenesses: 2, 4, 5 и 3.

## 样例 #1

### 输入

```
8
1 2 -3 4 -5 5 2 3
```

### 输出

```
14
```

## 样例 #2

### 输入

```
6
1 -2 3 -4 5 -6
```

### 输出

```
9
```

## 样例 #3

### 输入

```
6
1 2 3 4 5 6
```

### 输出

```
21
```

# AI分析结果

# 💡 Kay的C++算法解析：Ice Sculptures 深入学习指南 💡

<introduction>
今天我们来一起分析「Ice Sculptures」这道C++编程题。这道题看似需要复杂的几何知识，其实核心是**枚举所有可能的组合**，找到吸引力总和最大的正多边形。本指南会帮你理清思路、掌握关键技巧，还能通过像素动画直观看到算法运行过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（结合因数分析）

🗣️ **初步分析**：
解决这道题的关键是理解「正多边形」的条件——剩下的雕塑必须**等间隔排列**（比如每2个选1个、每3个选1个），而间隔必须是`n`的因数（否则无法围成闭合的正多边形）。简单来说，这就像「在环形饼干上选巧克力豆」：我们需要逐一尝试每一种可能的“步长”（间隔），再从每个起点开始选豆，计算总甜度，找最甜的组合！

- **题解核心思路**：先枚举所有可能的间隔（`n`的因数，且间隔对应的多边形边数≥3），再枚举每个起点，计算该组合的吸引力总和，最后取最大值。
- **核心难点**：① 如何正确枚举`n`的因数？② 如何覆盖所有可能的起点？③ 如何处理“不删除任何雕塑”的情况？
- **可视化设计思路**：用8位像素风格画一个环形，每个雕塑是彩色方块（颜色对应吸引力大小：红=负、绿=正、黄=0）。枚举间隔时，用蓝色箭头标记步长；计算总和时，高亮选中的雕塑，数值实时显示在屏幕下方；找到更大值时，播放“叮”的像素音效！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实践价值等方面筛选了3份优质题解，帮你快速掌握核心逻辑：
</eval_intro>

**题解一：来源：PR_CYJ**
* **点评**：这份题解的思路非常直白——直接枚举所有可能的间隔（因数）和起点，计算总和找最大。代码风格简洁规范，变量名`maxx`（记录最大值）、`s`（当前组合的和）含义明确。特别值得学习的是**初始最大值的设置**：先把所有雕塑的和算进去（对应“不删除任何雕塑”的情况），避免遗漏最优解。边界处理也很严谨（间隔≤n/3，保证边数≥3）。

**题解二：来源：千秋星辰**
* **点评**：此题解的亮点是**思路拆解清晰**——把问题拆成“枚举间隔→枚举起点→计算总和”三步，并用注释明确每一步的目的。代码中的`tmp`变量（当前组合的和）和`ans`（最大值）区分清楚，逻辑流畅。作者还提醒了“全部保留不一定最优”的情况，但通过初始化为所有数的和，完美覆盖了这种情况。

**题解三：来源：BADFIVE**
* **点评**：这份题解的代码结构工整，变量命名符合直觉（`t`数组存吸引力，`ans`存最大值）。枚举间隔的循环条件（`i<=n/3`）和因数判断（`n%i==0`）非常准确，确保了所有可能的正多边形都被考虑到。实践中，这种代码可以直接用于竞赛，因为它没有多余的逻辑，效率很高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，最容易卡壳的是「如何覆盖所有可能的组合」和「如何避免遗漏边界情况」。结合优质题解，我帮你提炼了3个核心关键点：
</difficulty_intro>

1. **关键点1：如何确定枚举的间隔？**
    * **分析**：正多边形的间隔必须是`n`的因数（比如n=8，间隔可以是2——每2个选1个，组成4边形）。因此，我们需要枚举所有≤n/3的因数（因为间隔i对应的边数是n/i，必须≥3，所以i≤n/3）。
    * 💡 **学习笔记**：因数是正多边形的“密码”，找到所有符合条件的因数，才能覆盖所有可能的组合。

2. **关键点2：如何覆盖所有可能的起点？**
    * **分析**：同一间隔下，起点不同会导致选的雕塑不同（比如间隔2，起点1选1、3、5、7；起点2选2、4、6、8）。因此，对于每个间隔i，需要枚举1~i的所有起点，确保不遗漏任何组合。
    * 💡 **学习笔记**：起点是“组合的起点”，枚举所有起点才能找到该间隔下的最大值。

3. **关键点3：如何处理“不删除任何雕塑”的情况？**
    * **分析**：题目允许不删除任何雕塑（对应间隔1，边数n），因此初始最大值应设为所有雕塑的和。这样即使所有其他组合的和都更小，也能保证结果正确。
    * 💡 **学习笔记**：初始值的设置要覆盖“全选”的情况，避免遗漏最优解。

### ✨ 解题技巧总结
- **技巧A：因数枚举**：枚举因数时，只需检查≤n/3的数，且满足n%i==0，减少不必要的计算。
- **技巧B：初始值设置**：先计算所有数的和作为初始最大值，覆盖“全选”的情况。
- **技巧C：分层枚举**：先枚举间隔，再枚举起点，最后计算总和，逻辑清晰不易错。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，它综合了优质题解的思路，结构清晰，能完整解决问题：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了PR_CYJ、千秋星辰、BADFIVE的思路，保留了最核心的逻辑，适合入门学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    const int MAXN = 20010;
    long long a[MAXN]; // 存储每个雕塑的吸引力

    int main() {
        int n;
        cin >> n;
        long long max_sum = 0; // 初始化为全选的和
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            max_sum += a[i];
        }

        // 枚举间隔i（i是n的因数，且i<=n/3）
        for (int i = 2; i <= n / 3; ++i) {
            if (n % i != 0) continue; // 不是因数，跳过
            // 枚举起点j（1~i）
            for (int j = 1; j <= i; ++j) {
                long long current_sum = 0;
                for (int k = j; k <= n; k += i) {
                    current_sum += a[k];
                }
                max_sum = max(max_sum, current_sum); // 更新最大值
            }
        }

        cout << max_sum << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为三步：① 读取输入，计算全选的和作为初始最大值；② 枚举所有可能的间隔（因数）；③ 对每个间隔，枚举起点，计算该组合的和，更新最大值。关键数据结构是数组`a`（存吸引力），核心逻辑是三层循环（间隔→起点→计算和）。

<code_intro_selected>
接下来分析优质题解的核心片段，看看它们的亮点：
</code_intro_selected>

**题解一：来源：PR_CYJ**
* **亮点**：代码简洁，初始最大值设置准确。
* **核心代码片段**：
    ```cpp
    int maxx=0;
    for(int i=1;i<=n;i++)
        cin>>a[i],maxx+=a[i]; // 初始化为全选的和
    ```
* **代码解读**：
    > 这行代码很巧妙——读取每个雕塑的吸引力时，同时累加计算全选的和。这样既节省了代码行数，又确保初始最大值覆盖了“不删除任何雕塑”的情况。
* 💡 **学习笔记**：合并输入和初始计算，让代码更简洁。

**题解二：来源：千秋星辰**
* **亮点**：分层枚举的逻辑清晰，变量命名直观。
* **核心代码片段**：
    ```cpp
    for(int l=2;l<=n/3;++l)// 枚举间隔
        if(!(n%l))
            for(int st=1;st<=l;++st)// 枚举起点
            {
                tmp=0;
                for(int i=st;i<=n;i+=l)// 计算当前组合的和
                    tmp+=a[i];
                ans=max(ans,tmp);
            }
    ```
* **代码解读**：
    > 用`l`表示间隔，`st`表示起点，`tmp`表示当前组合的和。三层循环层层递进，逻辑非常清晰。即使是新手，也能快速看懂每一步在做什么。
* 💡 **学习笔记**：用有意义的变量名，让代码“自解释”。

**题解三：来源：BADFIVE**
* **亮点**：边界处理严谨，确保间隔对应的边数≥3。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= n / 3; ++i){
        if (n % i == 0){ // 只有因数才处理
            // 枚举起点
        }
    }
    ```
* **代码解读**：
    > 循环条件`i<=n/3`确保了间隔i对应的边数是`n/i`≥3（比如n=8，i最大是2，边数是4）。这样就不会枚举到边数<3的情况（比如i=3，n=8时n/i=2，边数不够）。
* 💡 **学习笔记**：循环条件要准确，避免无效计算。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法运行过程，我设计了一个**8位像素风格的动画**，像玩FC游戏一样学习枚举逻辑！
</visualization_intro>

### 动画设计方案
#### ① 整体风格与场景
- **像素风格**：采用FC红白机的8位色彩（比如红色#FF0000、绿色#00FF00、蓝色#0000FF），环形由32x32的像素块组成，每个雕塑是16x16的彩色方块（颜色对应吸引力：红=负、绿=正、黄=0）。
- **UI布局**：屏幕上方是环形雕塑，中间是控制面板（按钮：开始/暂停、单步、重置；滑块：速度调节），下方是实时显示的“当前组合和”与“最大值”。

#### ② 核心动画步骤
1. **初始化**：环形显示所有雕塑，下方显示“全选和：XX”（初始最大值），播放8位风格的轻快BGM（比如《超级马里奥》的背景音）。
2. **枚举间隔**：当算法枚举到间隔i时，环形上用蓝色箭头标记步长（比如i=2，箭头指向每2个雕塑），伴随“叮”的音效。
3. **枚举起点**：选中的起点用黄色闪烁，然后依次高亮该起点对应的所有雕塑（比如起点1，间隔2，高亮1、3、5、7），同时下方“当前组合和”实时累加。
4. **更新最大值**：如果当前组合和大于最大值，下方“最大值”会闪烁绿色，伴随“嗡”的音效；否则，“当前组合和”会闪烁红色。
5. **完成**：所有组合枚举完毕后，环形上高亮最终选中的雕塑，播放“胜利”音效（比如《塞尔达传说》的解谜声），显示“最大和：XX”。

#### ③ 交互设计
- **单步执行**：点击“单步”按钮，算法执行一步（比如枚举下一个起点），方便你仔细观察每一步的变化。
- **自动播放**：拖动滑块调节速度（1x~5x），算法自动执行所有步骤，像“AI玩游戏”一样展示全过程。
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。

#### ④ 设计理由
- **像素风格**：复古游戏感能降低学习压力，让你更愿意主动探索。
- **音效提示**：关键操作的音效能强化记忆（比如“叮”对应枚举间隔，“嗡”对应找到更大值）。
- **实时显示**：数值的实时更新让你直观看到“总和是怎么算出来的”，避免抽象理解。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
枚举+因数分析的思路不仅能解决这道题，还能应用到很多类似问题中。比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：环形排列的数中选等间隔的数，求最大乘积。
- **场景2**：数组中选每隔k个元素的数，求最大和（k是数组长度的因数）。
- **场景3**：环形字符串中选等间隔的字符，组成最长回文串。

### 洛谷练习推荐
1. **洛谷 P1002 [NOIP2002 普及组] 过河卒**
   * 🗣️ **推荐理由**：这道题需要枚举路径，培养你的枚举思维，同时练习动态规划（和本题的枚举思路互补）。
2. **洛谷 P1025 [NOIP2001 普及组] 数的划分**
   * 🗣️ **推荐理由**：此题需要枚举所有可能的划分方式，和本题的“枚举组合”思路一致，能强化你的枚举能力。
3. **洛谷 P1115 最大子段和**
   * 🗣️ **推荐理由**：虽然是经典的动态规划题，但你可以尝试用枚举所有可能的子段（类似本题的枚举组合），对比两种方法的效率，加深对枚举的理解。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到“特判质数或n=4的情况”，但其实通用枚举方法已经覆盖了这些情况（比如n是质数时，因数只有1和n，而i从2开始枚举，所以不会进入循环，最终结果就是全选的和）。这提醒我们：
</insights_intro>

> **经验教训**：不要为了“优化”而添加不必要的特判，通用逻辑往往能覆盖所有情况，还能减少代码出错的可能。比如“n是质数”的情况，通用代码会自动保留所有雕塑，不需要额外判断。


<conclusion>
本次关于「Ice Sculptures」的分析就到这里！这道题的核心是**枚举所有可能的组合**，通过因数分析缩小枚举范围，再找到最大值。记住：枚举不是“瞎试”，而是“有规律地尝试所有可能”。下次遇到类似的问题，不妨先想想“哪些因素会影响结果”，再用枚举的思路解决！💪
</conclusion>

---
处理用时：116.56秒
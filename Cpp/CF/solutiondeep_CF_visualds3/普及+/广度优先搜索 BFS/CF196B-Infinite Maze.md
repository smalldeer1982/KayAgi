# 题目信息

# Infinite Maze

## 题目描述

We've got a rectangular $ n×m $ -cell maze. Each cell is either passable, or is a wall (impassable). A little boy found the maze and cyclically tiled a plane with it so that the plane became an infinite maze. Now on this plane cell $ (x,y) $ is a wall if and only if cell ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF196B/90d712000eb85a8bfa2ea0243ba4ea17c7b21954.png) is a wall.

In this problem ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF196B/8f971526abdeb0e01a924ce3de8c76d38e0d2bfd.png) is a remainder of dividing number $ a $ by number $ b $ .

The little boy stood at some cell on the plane and he wondered whether he can walk infinitely far away from his starting position. From cell $ (x,y) $ he can go to one of the following cells: $ (x,y-1) $ , $ (x,y+1) $ , $ (x-1,y) $ and $ (x+1,y) $ , provided that the cell he goes to is not a wall.

## 说明/提示

In the first sample the little boy can go up for infinitely long as there is a "clear path" that goes vertically. He just needs to repeat the following steps infinitely: up, up, left, up, up, right, up.

In the second sample the vertical path is blocked. The path to the left doesn't work, too — the next "copy" of the maze traps the boy.

## 样例 #1

### 输入

```
5 4
##.#
##S#
#..#
#.##
#..#
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出

```
No
```

# AI分析结果

# 💡 Kay的C++算法解析：Infinite Maze 深入学习指南 💡

<introduction>
今天我们来一起拆解「Infinite Maze」这道有趣的算法题——你有没有想过，如果把一个小迷宫无限复制拼接成巨大的平面，从起点出发能不能一直走下去？这道题的核心是**用搜索找“循环”**，跟着Kay一起揭开它的秘密吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（DFS/BFS）+ 状态记录（相对位置与全局坐标绑定）

🗣️ **初步分析**：
解决这道题的关键，在于理解「无限迷宫」的本质——它是原迷宫的**无限循环复制**。比如原迷宫是5×4的，那么平面上所有坐标`(x,y)`的位置，和原迷宫中`(x%5, y%4)`的位置完全一样（注意取模要处理负数哦）。

那怎么判断“能走无穷远”？其实就是**找到一个“循环路径”**：如果从起点出发，能走到**同一个相对位置（原迷宫中的坐标）但不同的全局坐标**，说明你已经进入了一个“无限循环”——比如从原迷宫的(2,3)走到右边复制迷宫的(2,3)，再走下去又会到下一个复制迷宫的(2,3)，永远停不下来！

所有题解的核心思路都一样：
1. 用**DFS或BFS**遍历迷宫；
2. 对每个走到的点，计算它在**原迷宫中的相对位置**（`x%n`和`y%m`，处理负数）；
3. 记录这个相对位置**第一次到达时的全局坐标**（比如第一次走到原迷宫(2,3)时，全局坐标是(2,3)；第二次走到原迷宫(2,3)时，全局坐标是(2, 3+m)）；
4. 如果再次走到同一个相对位置，但全局坐标和之前不同——**恭喜！找到循环了，可以无限走下去**！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值三个维度，筛选了3份超棒的题解，一起看看它们的亮点吧～
</eval_intro>

**题解一：(来源：filletoto)**
* **点评**：这份题解的思路像“贴标签”一样直白！它用`vis[x][y][0]`标记原迷宫中的(x,y)是否被访问过，`vis[x][y][1]`和`vis[x][y][2]`记录第一次到达这个位置时的全局坐标。DFS过程中，只要发现“同一个相对位置但全局坐标不同”，立刻返回`Yes`。代码变量命名清晰（比如`dx`/`dy`是方向数组），边界处理也很严谨（取模时加`n`/`m`避免负数），非常适合入门学习！

**题解二：(来源：xukuan)**
* **点评**：这题解踩过的坑能帮我们避祸！作者提到“直接复制3×3迷宫会炸内存”，所以改用**记录全局坐标**的方法。更贴心的是，他把起点设为`x=i+n*m`、`y=j+n*m`——这样即使往回走，也不会出现负数坐标（比如`x-n*m`还是正数），完美解决了溢出问题！代码中的`dfs(X,Y)`直接传递全局坐标，逻辑超顺～

**题解三：(来源：__zhuruirong__)**
* **点评**：用结构体`Node`记录状态的思路很巧妙！`vis[x][y].is_find`标记是否访问过原迷宫的(x,y)，`vis[x][y].x`/`y`记录全局坐标。DFS时，只要发现“同一个相对位置但全局坐标不同”，直接返回`true`。代码中的坐标转换（比如`nx <1`时`nxx--`、`nx=n`）把“无限拼接”的逻辑具象化了，新手也能看懂～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在「如何处理无限迷宫」和「如何判断循环」。结合优质题解，我们提炼了3个核心难点和解决策略：
</difficulty_intro>

1.  **难点1：如何表示“无限迷宫”？**
    * **分析**：无限迷宫无法直接存储，但所有复制的迷宫都和原迷宫一样。所以我们用**相对位置**（原迷宫中的坐标，通过`(x%n +n)%n`和`(y%m +m)%m`计算，确保结果非负）来代表同一类点——比如原迷宫的(2,3)和右边复制迷宫的(2,3+m)，它们的相对位置都是(2,3)。
    * 💡 **学习笔记**：无限问题找“重复单元”，用相对位置缩小范围！

2.  **难点2：如何判断“能走无穷远”？**
    * **分析**：能走无穷远的本质是**进入循环**。如果同一个相对位置被两次到达，但全局坐标不同，说明你走了一个“绕圈”的路径——比如从原迷宫的(2,3)走到右边复制迷宫的(2,3)，再走下去又会到下一个复制迷宫的(2,3)，永远停不下来！
    * 💡 **学习笔记**：循环的标志是“同一相对位置，不同全局坐标”！

3.  **难点3：如何避免搜索中的重复计算？**
    * **分析**：如果同一个相对位置被访问过，且全局坐标和之前一样，说明这条路径已经处理过了，不需要再走——否则会陷入死循环（比如反复走原迷宫的同一段路）。
    * 💡 **学习笔记**：用“相对位置+全局坐标”的组合标记状态，避免重复搜索！

### ✨ 解题技巧总结
- **技巧1：取模处理无限性**：用`(x%n +n)%n`处理负数坐标，确保相对位置正确；
- **技巧2：状态记录要“双标”**：不仅要记录是否访问过相对位置，还要记录第一次到达时的全局坐标；
- **技巧3：搜索终止条件要明确**：一旦发现“同一相对位置不同全局坐标”，立刻返回结果，避免无用计算！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用代码**，它结合了filletoto的清晰逻辑和xukuan的溢出处理，帮你快速掌握核心框架～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了filletoto和xukuan的思路，用DFS遍历，记录相对位置的全局坐标，逻辑简洁高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    const int N = 1510;
    const int dx[4] = {1, 0, -1, 0};  // 下、右、上、左
    const int dy[4] = {0, 1, 0, -1};
    int n, m, st_x, st_y;
    bool is_wall[N][N];  // 原迷宫的墙：true表示墙
    bool visited[N][N];  // 原迷宫的位置是否被访问过
    int global_x[N][N];  // 第一次到达该位置时的全局x坐标
    int global_y[N][N];  // 第一次到达该位置时的全局y坐标
    bool has_cycle = false;  // 是否找到循环

    void dfs(int x, int y, int gx, int gy) {
        if (has_cycle) return;  // 已经找到循环，直接返回
        // 计算相对位置（原迷宫中的坐标）
        int rx = (x % n + n) % n;
        int ry = (y % m + m) % m;
        // 如果该相对位置已被访问过
        if (visited[rx][ry]) {
            // 检查全局坐标是否不同：是则找到循环
            if (global_x[rx][ry] != gx || global_y[rx][ry] != gy) {
                has_cycle = true;
            }
            return;
        }
        // 标记该相对位置已访问，并记录全局坐标
        visited[rx][ry] = true;
        global_x[rx][ry] = gx;
        global_y[rx][ry] = gy;
        // 遍历四个方向
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            int ngx = gx + dx[i];
            int ngy = gy + dy[i];
            // 计算新位置的相对位置，检查是否是墙
            int nrx = (nx % n + n) % n;
            int nry = (ny % m + m) % m;
            if (!is_wall[nrx][nry]) {  // 不是墙才能走
                dfs(nx, ny, ngx, ngy);
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> n >> m;
        memset(is_wall, false, sizeof(is_wall));
        memset(visited, false, sizeof(visited));
        // 读取迷宫
        for (int i = 0; i < n; ++i) {
            string s;
            cin >> s;
            for (int j = 0; j < m; ++j) {
                if (s[j] == '#') {
                    is_wall[i][j] = true;
                } else if (s[j] == 'S') {
                    st_x = i;
                    st_y = j;
                }
            }
        }
        // 起点的全局坐标设为n*m，避免负数（参考xukuan的技巧）
        dfs(st_x, st_y, st_x + n*m, st_y + n*m);
        cout << (has_cycle ? "Yes" : "No") << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  1. 读取迷宫时，用`is_wall`记录原迷宫的墙；
  2. `dfs`函数的参数`x,y`是当前位置的**相对坐标**（原迷宫中的位置），`gx,gy`是**全局坐标**（无限平面中的位置）；
  3. 每次进入`dfs`，先计算相对位置`rx,ry`，检查是否已访问：
     - 如果已访问，比较全局坐标是否不同——是则找到循环；
     - 如果未访问，标记并记录全局坐标；
  4. 遍历四个方向，计算新的相对位置和全局坐标，继续DFS。


<code_intro_selected>
接下来看优质题解的核心片段，学习它们的巧妙之处～
</code_intro_selected>

**题解一：(来源：filletoto)**
* **亮点**：用三维数组`vis[x][y][3]`整合状态（是否访问、全局x、全局y），代码简洁。
* **核心代码片段**：
    ```cpp
    void dfs(int x, int y, int lx, int ly) {
        if (vis[x][y][0] && (vis[x][y][1] != lx || vis[x][y][2] != ly)) {
            fl = 1;  // 找到循环
            return;
        }
        if (fl) return;
        vis[x][y][1] = lx;  // 记录全局x
        vis[x][y][2] = ly;  // 记录全局y
        vis[x][y][0] = 1;   // 标记已访问
        for (int i = 0; i < 4; ++i) {
            int xx = (x + dx[i] + n) % n;
            int yy = (y + dy[i] + m) % m;
            int lxx = lx + dx[i];
            int lyy = ly + dy[i];
            if (!a[xx][yy]) {  // 不是墙
                if (vis[xx][yy][1] != lxx || vis[xx][yy][2] != lyy || !vis[xx][yy][0])
                    dfs(xx, yy, lxx, lyy);
            }
        }
    }
    ```
* **代码解读**：
  - `vis[x][y][0]`是“是否访问过原迷宫的(x,y)”；
  - `vis[x][y][1]`和`[2]`是“第一次到达(x,y)时的全局坐标”；
  - 当再次到达(x,y)，且全局坐标不同时，`fl=1`（找到循环）。
* 💡 **学习笔记**：用三维数组整合状态，代码更紧凑！


**题解二：(来源：xukuan)**
* **亮点**：将起点的全局坐标设为`x=i+n*m`、`y=j+n*m`，避免负数溢出。
* **核心代码片段**：
    ```cpp
    for (ll i = 0; i < n; i++) {
        cin >> s[i];
        for (ll j = 0; j < m; j++) {
            if (s[i][j] == 'S') {
                s[i][j] = '.';
                x = i + n*m;  // 起点全局x坐标
                y = j + n*m;  // 起点全局y坐标
            }
        }
    }
    ```
* **代码解读**：
  - 原起点的相对坐标是`(i,j)`，全局坐标设为`i+n*m`和`j+n*m`——即使往回走（比如减n），全局坐标还是正数，不会出现负数取模的问题！
* 💡 **学习笔记**：处理负数的小技巧——给全局坐标“加个缓冲”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“亲眼看到”循环是怎么找的，Kay设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### 🎮 动画演示主题：像素探险家的无限迷宫之旅
**设计思路**：用FC红白机的像素风格（比如《塞尔达传说》的迷宫），把原迷宫画成32×32的像素块，探险家（起点S）是一个小方块，移动时显示相对位置和全局坐标。当找到循环时，播放“胜利音效”，并用闪烁的路径标记循环！

### 🕹️ 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左侧是**原迷宫**（5×4的像素块，墙是深色，通路是浅色，S是红色）；
   - 右侧是**全局地图预览**（显示探险家当前的全局位置，用小箭头标记）；
   - 下方控制面板有：「开始」「单步」「重置」按钮，速度滑块（慢→快）；
   - 背景播放8位风格的轻快BGM（比如《超级玛丽》的关卡音乐）。

2. **算法启动**：
   - 探险家从S出发，每走一步，**相对位置**（原迷宫中的坐标）用黄色高亮，**全局坐标**（比如(2,3)→(2,7)→(2,11)）显示在屏幕上方；
   - 每走一步，播放“嗒”的像素音效；
   - 第一次到达某个相对位置时，用绿色标记，并记录全局坐标（比如原迷宫(2,3)的全局坐标是(2,3)）。

3. **找到循环的瞬间**：
   - 当探险家走到原迷宫的(2,3)，但全局坐标是(2, 3+m)（比如m=4，全局坐标是(2,7)）时——
     1. 相对位置(2,3)的绿色标记变成红色闪烁；
     2. 屏幕弹出“找到循环！”的像素文字；
     3. 播放上扬的“胜利音效”（类似《魂斗罗》的通关声）；
     4. 用蓝色虚线标记从原(2,3)到新(2,7)的路径，显示“循环路径：右→右→右…”。

4. **交互设计**：
   - 「单步」按钮：每按一次，探险家走一步，方便观察每一步的相对位置和全局坐标；
   - 「自动播放」：可以调整速度（慢→快），看探险家快速找循环；
   - 「重置」：回到起点，重新开始。

### 📝 设计理由
- **像素风格**：唤起复古游戏的回忆，降低学习的“距离感”；
- **音效与视觉反馈**：用声音和颜色强化“关键操作”（比如找到循环时的音效），让记忆更深刻；
- **全局地图预览**：帮你直观理解“无限拼接”的含义——原来探险家走的每一步，都是在复制的迷宫里！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“用相对位置找循环”的思路，我们可以解决很多**无限或循环问题**！比如：
</similar_problems_intro>

### 🌐 通用思路迁移
- **场景1**：无限网格中的蛇形移动（判断是否回到原点）；
- **场景2**：循环字符串匹配（比如“abcabcabc”中找“abc”的循环）；
- **场景3**：无限链表中的环检测（LeetCode经典题：环形链表）。

### 📚 洛谷练习推荐
1. **洛谷 P1346** - 《电车》
   * 🗣️ **推荐理由**：用BFS找最短路径，需要处理“循环线路”，和本题的“循环判断”思路类似！
2. **洛谷 P1141** - 《01迷宫》
   * 🗣️ **推荐理由**：用DFS遍历迷宫，需要记录每个位置的“连通块”，锻炼“状态记录”能力！
3. **洛谷 P1596** - 《[USACO10OCT]Lake Counting S》
   * 🗣️ **推荐理由**：用DFS或BFS统计连通块，是搜索的基础练习，帮你巩固“遍历逻辑”！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者们踩过的坑，是我们的“避坑指南”！一起看看：
</insights_intro>

> **参考经验 (来自 xukuan)**：“一开始我想复制3×3迷宫，结果第25组数据直接炸内存！后来才明白，无限迷宫不需要真的复制——用相对位置就够了！”
>
> **点评**：这是最常见的“思维误区”！无限问题不要“硬模拟”，要找“重复规律”（比如相对位置）。就像你不会把无限长的绳子全展开，而是看它的“编织 pattern”～

> **参考经验 (来自 filletoto)**：“取模的时候要加n或m再取模，否则负数会出问题！比如(-1)%5在C++里是-1，加5再取模就是4，才是正确的相对位置！”
>
> **点评**：这个细节太重要了！比如全局坐标是-1（往左走了一步），相对位置应该是n-1（原迷宫的最后一行），而不是-1。记住：`(x % n + n) % n`是处理负数取模的“万能公式”！


<conclusion>
这次的「Infinite Maze」分析就到这里啦！其实解决无限问题的关键，就是**找到“有限的重复单元”**——就像无限循环的音乐，你不需要听完整首，只要找到“副歌循环”就能知道它会一直唱下去～

下次遇到无限问题，记得先问自己：“有没有重复的小单元？” 跟着这个思路，你一定能解决更多难题！💪
</conclusion>

---
处理用时：138.62秒
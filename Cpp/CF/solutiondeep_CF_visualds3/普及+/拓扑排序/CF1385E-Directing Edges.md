# 题目信息

# Directing Edges

## 题目描述

You are given a graph consisting of $ n $ vertices and $ m $ edges. It is not guaranteed that the given graph is connected. Some edges are already directed and you can't change their direction. Other edges are undirected and you have to choose some direction for all these edges.

You have to direct undirected edges in such a way that the resulting graph is directed and acyclic (i.e. the graph with all edges directed and having no directed cycles). Note that you have to direct all undirected edges.

You have to answer $ t $ independent test cases.

## 说明/提示

Explanation of the second test case of the example:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1385E/d35669c68d98d1dcefc83e24fe388de76c760c1f.png)

Explanation of the third test case of the example:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1385E/641ca4dc132da9f3a738d8606128481e262df751.png)

## 样例 #1

### 输入

```
4
3 1
0 1 3
5 5
0 2 1
1 1 5
1 5 4
0 5 2
1 3 5
4 5
1 1 2
0 4 3
1 3 1
0 2 3
1 2 4
4 5
1 4 1
1 1 3
0 1 2
1 2 4
1 3 2```

### 输出

```
YES
3 1
YES
2 1
1 5
5 4
2 5
3 5
YES
1 2
3 4
3 1
3 2
2 4
NO```

# AI分析结果



---

# 💡 Kay的C++算法解析：Directing Edges 深入学习指南 💡

<introduction>
今天我们来一起分析“Directing Edges”这道C++编程题。本指南将帮助大家梳理题目思路，理解如何通过拓扑排序解决混合图定向问题，并掌握关键编程技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（拓扑排序应用）`

🗣️ **初步分析**：
解决“Directing Edges”这道题，关键在于利用拓扑排序判断原图是否存在环，并通过拓扑序为无向边定向。  
拓扑排序的核心思想可以比喻为“给班级同学排座位”：如果所有同学都能按顺序坐成一排（无环），那么每个同学的座位号（拓扑序）决定了他们之间的相对位置。在本题中，有向边相当于“固定座位关系”（比如A必须坐在B左边），而无向边需要根据座位号确定方向（左边同学指向右边同学），这样就不会出现“环”（比如A在B左边，B又在A左边的矛盾）。

- **题解思路**：所有优质题解的核心思路一致：先对原图的有向边进行拓扑排序，若排序失败（存在环）则输出“NO”；若成功（无环），则根据节点的拓扑序为无向边定向（拓扑序小→大），确保最终图是DAG。
- **核心难点**：如何正确判断原图是否存在环（拓扑排序的正确性）、如何利用拓扑序为无向边定向。
- **可视化设计**：设计8位像素动画，用不同颜色标记节点的拓扑序（如红色表示未处理，绿色表示已入队，蓝色表示已完成拓扑序），队列用像素方块堆叠展示，无向边定向时用箭头动画从拓扑序小的节点指向大的节点，关键操作（如入队、定向）伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，以下题解评分均≥4星，值得重点学习：
</eval_intro>

**题解一：作者MY（赞：55）**
* **点评**：此题解思路清晰，代码结构规范。作者明确指出“原图有向边成环则无解”，并通过拓扑排序判断环的存在。代码中对多组数据的初始化（如队列清空、入度数组重置）处理严谨，变量名（`top[]`记录拓扑序，`du[]`记录入度）含义明确。关键亮点是将拓扑序直接用于无向边定向（`top[q[i][0]] > top[q[i][1]]`时交换方向），确保逻辑简洁高效。实践价值高，适合竞赛直接使用。

**题解二：作者iMya_nlgau（赞：12）**
* **点评**：此题解用`vector`存储无向边，代码简洁易读。拓扑排序部分使用标准队列实现，逻辑直白。亮点是将有向边和无向边分离处理（有向边直接建图，无向边暂存），最后统一输出，结构清晰。对拓扑序的应用（`topo[x]<topo[y]`时输出`x→y`）与核心思路高度一致，适合理解基础实现。

**题解三：作者_lyx111（赞：4）**
* **点评**：此题解详细说明了算法流程（拓扑排序→无向边定向），并强调多组数据初始化的重要性（`init()`函数清空数组）。代码中`top[]`数组记录拓扑序，`deg[]`记录入度，变量命名直观。亮点是通过注释明确关键步骤（如“记录u在合法拓扑序中的位置”），适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，提炼核心策略：
</difficulty_intro>

1.  **关键点1：判断原图有向边是否存在环**
    * **分析**：环的存在会导致无法构造DAG，必须首先排除。通过拓扑排序判断：若拓扑排序后处理的节点数不等于总节点数（`sum != n`），说明存在环。例如，有向边形成环时，环中节点的入度无法减到0，无法入队，导致`sum < n`。
    * 💡 **学习笔记**：拓扑排序是判断DAG的“金标准”，所有有向边的环都会导致拓扑排序失败。

2.  **关键点2：利用拓扑序为无向边定向**
    * **分析**：拓扑序小的节点在DAG中“靠前”，所有有向边从“前”指向“后”。无向边若按此规则定向（小→大），不会引入环。例如，若节点u的拓扑序为3，节点v的拓扑序为5，则u→v的边不会形成环（因为u在v前，不存在v到u的路径）。
    * 💡 **学习笔记**：拓扑序的本质是DAG的线性化，无向边的定向需遵循这一线性顺序。

3.  **关键点3：多组数据的初始化处理**
    * **分析**：多组测试数据需清空队列、入度数组、拓扑序数组等，避免前一次数据干扰。例如，若未清空`du[]`数组，可能导致入度计算错误，拓扑排序失败。
    * 💡 **学习笔记**：多组数据的初始化是竞赛题的常见坑点，需仔细处理所有相关变量。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将问题拆分为“判断有向边是否成环”和“无向边定向”两部分，分别解决。
- **代码模块化**：将拓扑排序、初始化等功能封装为函数（如`top_sort()`、`init()`），提高可读性。
- **边界测试**：测试空图、单节点图、全有向边成环等边界情况，确保代码鲁棒性。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了MY、iMya_nlgau等优质题解的思路，结构清晰、初始化严谨，适合竞赛使用。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <iostream>
    #include <queue>
    #include <vector>
    using namespace std;

    const int N = 2e5 + 10;
    int t, n, m, top[N], fir[N], tot, du[N];
    queue<int> que;
    struct Edge { int to, nex; } e[N];
    vector<pair<int, int>> undir_edges; // 存储无向边

    void add(int u, int v) {
        e[++tot].to = v;
        du[v]++;
        e[tot].nex = fir[u];
        fir[u] = tot;
    }

    bool top_sort() {
        int u, sum = 0;
        while (!que.empty()) que.pop();
        for (int i = 1; i <= n; ++i) if (!du[i]) que.push(i);
        while (!que.empty()) {
            u = que.front(); que.pop();
            top[u] = ++sum;
            for (int i = fir[u]; i; i = e[i].nex) {
                if (--du[e[i].to] == 0) que.push(e[i].to);
            }
        }
        return sum == n;
    }

    int main() {
        scanf("%d", &t);
        while (t--) {
            scanf("%d%d", &n, &m);
            tot = 0; undir_edges.clear();
            for (int i = 1; i <= n; ++i) { fir[i] = du[i] = 0; top[i] = 1e9; }
            while (m--) {
                int op, u, v;
                scanf("%d%d%d", &op, &u, &v);
                if (op) add(u, v);
                else undir_edges.push_back({u, v});
            }
            if (top_sort()) {
                puts("YES");
                // 输出所有有向边
                for (int i = 1; i <= n; ++i)
                    for (int j = fir[i]; j; j = e[j].nex)
                        printf("%d %d\n", i, e[j].to);
                // 输出无向边（按拓扑序定向）
                for (auto& p : undir_edges) {
                    int u = p.first, v = p.second;
                    if (top[u] < top[v]) printf("%d %d\n", u, v);
                    else printf("%d %d\n", v, u);
                }
            } else puts("NO");
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取多组数据，对每组数据初始化图结构。通过`add()`函数添加有向边，`top_sort()`进行拓扑排序。若排序成功（无环），输出所有有向边和按拓扑序定向的无向边；否则输出“NO”。关键数据结构是`Edge`结构体（链式前向星存图）和`undir_edges`（存储无向边）。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解关键逻辑：
</code_intro_selected>

**题解一：作者MY**
* **亮点**：多组数据初始化严谨（`tot=cnt=0`，队列清空，数组重置），拓扑序记录直接（`top[u]=++sum`）。
* **核心代码片段**：
    ```cpp
    bool top_sort() {
        int u, sum=0;
        for(int i=1;i<=n;i++) if(!du[i]) que.push(i);
        while(!que.empty()) {
            u=que.front(); que.pop();
            top[u]=++sum;
            for(int i=fir[u];i;i=e[i].nex) {
                du[e[i].to]--;
                if(!du[e[i].to]) que.push(e[i].to);
            }
        }
        return sum == n;
    }
    ```
* **代码解读**：这段代码实现拓扑排序。初始化时将入度为0的节点入队，每次取出队首节点u，记录其拓扑序为`sum++`。遍历u的所有邻接节点，减少其入度，若入度为0则入队。最终若`sum == n`，说明所有节点都被处理（无环）。
* 💡 **学习笔记**：拓扑排序的核心是维护入度数组，通过队列逐步处理入度为0的节点。

**题解二：作者iMya_nlgau**
* **亮点**：用`vector`存储无向边，代码简洁；输出时统一处理有向边和无向边，逻辑清晰。
* **核心代码片段**：
    ```cpp
    for(rgi i=0;i<und.size();i++) {
        int x=und[i].fi,y=und[i].se;
        if(topo[x]<topo[y]) printf("%d %d\n",x,y);
        else printf("%d %d\n",y,x);
    }
    ```
* **代码解读**：遍历无向边数组`und`，根据拓扑序`topo[x]`和`topo[y]`的大小，决定边的方向。若`x`的拓扑序更小，输出`x→y`；否则输出`y→x`。
* 💡 **学习笔记**：无向边的定向只需比较拓扑序，确保方向符合DAG的线性顺序。

**题解三：作者_lyx111**
* **亮点**：`init()`函数统一初始化，避免多组数据干扰。
* **核心代码片段**：
    ```cpp
    void init() {
        cnt=0; memset(hea,0,sizeof(hea));
        tot=0; memset(t,0x3f,sizeof(t));
        while(!que.empty()) que.pop();
        memset(deg,0,sizeof(deg));
    }
    ```
* **代码解读**：`init()`函数清空链式前向星的头数组（`hea`）、无向边计数（`tot`）、拓扑序数组（`t`）、队列（`que`）和入度数组（`deg`），确保每组数据独立。
* 💡 **学习笔记**：多组数据的初始化是避免错误的关键，需清空所有与当前数据相关的变量。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解拓扑排序和无向边定向的过程，我们设计一个“像素拓扑探险”的8位复古动画，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素拓扑探险——在DAG世界中给无向边定向`

  * **核心演示内容**：展示拓扑排序的过程（节点入队、处理邻接节点、更新入度），以及无向边根据拓扑序定向的动画。

  * **设计思路简述**：采用FC红白机风格的8位像素画面，用不同颜色标记节点状态（未处理：红色，入队待处理：黄色，完成拓扑序：绿色），队列用像素方块堆叠显示。关键操作（入队、定向）伴随“叮”的音效，目标达成时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是像素网格（节点用圆形像素块表示，有向边用箭头连接），右侧是控制面板（开始/暂停、单步、速度滑块）。
          * 背景播放8位风格的轻快BGM（如《超级马里奥》的经典旋律）。

    2.  **拓扑排序启动**：
          * 初始时，所有有向边显示为蓝色箭头，无向边显示为灰色虚线。
          * 入度为0的节点（如节点A）变为黄色，并“滑入”队列（像素方块堆叠的队列区），伴随“入队”音效（短“叮”声）。

    3.  **拓扑排序过程**：
          * 从队列取出节点A（黄色变绿色），遍历其邻接节点（如节点B），入度减1（显示入度值变化）。
          * 若节点B的入度变为0（如从2→0），节点B变黄色，滑入队列，再次播放“入队”音效。
          * 每个节点的拓扑序（如A=1，B=2）实时显示在节点上方。

    4.  **无向边定向**：
          * 拓扑排序完成后，无向边（灰色虚线）根据拓扑序定向：拓扑序小的节点（如A，拓扑序1）向大的节点（B，拓扑序2）发射像素箭头（绿色），伴随“定向”音效（长“叮”声）。

    5.  **目标达成/失败**：
          * 若拓扑排序成功（所有节点变绿色），播放胜利音效（上扬的“啦~”），所有边变为蓝色（有向边）或绿色（定向后的无向边）。
          * 若失败（存在环，如节点C的入度无法减到0），播放提示音效（短促“咚”），环中的节点闪烁红色。

  * **旁白提示**：
      * （拓扑排序开始时）“看！入度为0的节点被优先处理，就像排队时没有前置任务的同学先行动~”
      * （处理邻接节点时）“处理完节点A，它的邻居B的入度减少了，现在B的入度变成0啦，该它入队了！”
      * （无向边定向时）“无向边根据拓扑序定向，小的指向大的，这样就不会有环啦！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到拓扑排序如何排除环，以及无向边如何根据拓扑序定向，轻松理解算法核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以将拓扑排序的思路迁移到更多图论问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 拓扑排序不仅用于判断环，还可用于任务调度（如确定任务执行顺序）、依赖关系处理（如软件包安装顺序）、DAG路径计数等。
      * 无向边定向的思路可迁移到“给无向图添加方向满足特定条件”的问题（如构造竞赛图的传递闭包）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4017 网络流24题·食物分配问题**
          * 🗣️ **推荐理由**：需构建DAG并判断是否存在可行流，拓扑排序可用于确定节点处理顺序。
    2.  **洛谷 P3385 【模板】负环**
          * 🗣️ **推荐理由**：通过SPFA判断负环，与本题判断有向环的思路类似，巩固图论基础。
    3.  **洛谷 P1347 排序**
          * 🗣️ **推荐理由**：通过比较关系构建有向图，用拓扑排序判断是否可唯一确定顺序，与本题思路高度相关。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者提到多组数据初始化的重要性，例如：
</insights_intro>

> **参考经验 (来自作者MY)**：“多组数据一定要清空队列、入度数组和拓扑序数组，否则前一次的数据会影响当前测试用例，导致错误。”

**点评**：作者的经验非常实用！在竞赛中，多组数据的初始化是常见的“坑点”。例如，若未清空队列，可能导致残留的节点影响拓扑排序；若未重置入度数组，可能错误计算入度。建议在每组数据开始时，显式初始化所有相关变量（如使用`memset`或循环重置），避免“玄学错误”。

-----

<conclusion>
本次关于“Directing Edges”的C++解题分析就到这里。通过拓扑排序判断环并为无向边定向的思路，是图论中的经典应用。希望大家通过练习和可视化动画，深入理解算法核心，在竞赛中轻松应对类似问题！下次再见~ 💪
</conclusion>

---
处理用时：180.06秒
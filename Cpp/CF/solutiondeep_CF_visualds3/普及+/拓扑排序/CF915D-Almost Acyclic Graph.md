# 题目信息

# Almost Acyclic Graph

## 题目描述

You are given a [directed graph](https://en.wikipedia.org/wiki/Directed_graph) consisting of $ n $ vertices and $ m $ edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.

Can you make this graph [acyclic](https://en.wikipedia.org/wiki/Directed_acyclic_graph) by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).

## 说明/提示

In the first example you can remove edge ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF915D/f1138b32236a89525fad2b8c02b9cbfbd546dfad.png), and the graph becomes acyclic.

In the second example you have to remove at least two edges (for example, ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF915D/7480c546ca7ee72615c3ded7d769355b1c864f93.png) and ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF915D/f1138b32236a89525fad2b8c02b9cbfbd546dfad.png)) in order to make the graph acyclic.

## 样例 #1

### 输入

```
3 4
1 2
2 3
3 2
3 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
5 6
1 2
2 3
3 2
3 1
2 1
4 5
```

### 输出

```
NO
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Almost Acyclic Graph 深入学习指南 💡

<introduction>
今天我们来一起分析“Almost Acyclic Graph”这道C++编程题。这道题的核心是判断是否可以通过删除最多一条边，将有向图变为无环图。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论 - 拓扑排序应用`

🗣️ **初步分析**：
解决这道题的关键在于理解拓扑排序的核心思想——拓扑排序通过处理入度为0的节点，逐步“拆解”图中的节点，若最终能处理完所有节点，则图无环。简单来说，拓扑排序就像“任务调度”：只有所有前置任务（入边指向的节点）完成，当前任务（节点）才能被处理。

在本题中，我们需要判断是否存在一条边，删除后图无环。直接枚举每条边并拓扑排序的时间复杂度为 \(O(m(n+m))\)（\(m\)为边数），当边数较多时会超时。观察发现：删除一条边等价于其终点的入度减1。因此，我们可以**枚举每个节点，将其入度减1后再拓扑排序**（相当于删除一条指向该节点的边），时间复杂度降为 \(O(n(n+m))\)（\(n\)为节点数），效率更高。

核心算法流程：
1. 统计所有节点的原始入度；
2. 先尝试不删除任何边，直接拓扑排序判断是否无环；
3. 若有环，枚举每个节点（入度≥1），将其入度减1，再次拓扑排序判断；
4. 若任意一次判断成功，输出“YES”，否则输出“NO”。

可视化设计思路：用8位像素风格展示节点（方块）和边（箭头），节点颜色表示入度（绿色：入度0，黄色：入度>0）。拓扑排序时，队列中的节点用“滑动”动画进入处理区，处理后节点变为蓝色。枚举节点入度减一时，对应节点颜色短暂闪烁红色，入度值实时更新。关键步骤（如入队、处理完成）伴随“叮”的像素音效，完成所有节点处理时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解（≥4星），它们的核心思路一致但实现各有亮点：
</eval_intro>

**题解一：青烟绕指柔 (赞：14)**
* **点评**：此题解思路简洁高效，直接抓住“枚举节点入度减一”的优化点。代码中使用队列实现拓扑排序，变量命名（如`dag`表示入度数组）直观，边界处理严谨（如恢复入度数组）。特别是`#pragma GCC optimize`的优化指令提升了运行效率，适合竞赛场景。

**题解二：CharlesZiy (赞：3)**
* **点评**：此题解详细解释了优化思路（枚举节点而非边的原因），代码结构清晰。通过`IN`和`in`两个数组保存原始入度和临时入度，避免了重复初始化的麻烦。对拓扑排序的核心逻辑（队列处理、入度更新）注释明确，非常适合新手学习。

**题解三：Nukumizu_Kaju (赞：2)**
* **点评**：此题解代码简洁，逻辑直白。通过`rd`数组保存原始入度，`Rd`数组保存临时入度，每次枚举节点时仅修改对应入度，拓扑排序后恢复。代码中`topo()`函数封装了核心判断逻辑，模块化设计值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何避免暴力枚举边的高时间复杂度？
    * **分析**：直接枚举每条边的时间复杂度为 \(O(m(n+m))\)，当边数较多时无法通过。观察发现，删除一条边等价于其终点的入度减一。因此，枚举每个节点（入度≥1）并将其入度减一，即可覆盖所有可能的删边情况，时间复杂度降为 \(O(n(n+m))\)。
    * 💡 **学习笔记**：优化的关键是发现“删边”对入度的影响，将枚举对象从边转为节点。

2.  **关键点2**：如何正确实现拓扑排序并恢复入度数组？
    * **分析**：拓扑排序过程中会修改入度数组，因此需要保存原始入度（如用`rd`数组）。每次枚举节点时，复制原始入度到临时数组（如`in`），修改临时数组后进行拓扑排序，结束后恢复原始入度，避免影响后续枚举。
    * 💡 **学习笔记**：使用“原始数组+临时数组”的双数组模式，是处理多次状态修改的常用技巧。

3.  **关键点3**：如何判断图中是否存在环？
    * **分析**：拓扑排序完成后，若处理的节点数等于总节点数（`cnt == n`），则图无环；否则存在环。这是因为环中的节点无法被处理（入度始终≥1）。
    * 💡 **学习笔记**：拓扑排序的核心是“入度为0的节点入队”，环中的节点无法满足此条件，因此无法被处理。

### ✨ 解题技巧总结
- **问题抽象**：将“删边”问题抽象为“入度减一”，减少枚举量。
- **双数组保存状态**：用原始数组保存初始状态，临时数组用于修改和恢复，避免状态污染。
- **模块化设计**：将拓扑排序封装为函数，提高代码复用性和可读性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用枚举节点入度减一的优化策略，代码简洁高效，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;

    const int N = 510;
    int n, m;
    vector<int> g[N]; // 邻接表存图
    int rd[N]; // 原始入度数组
    int tmp_rd[N]; // 临时入度数组

    // 拓扑排序判断是否无环，返回true表示无环
    bool topo_sort() {
        queue<int> q;
        int cnt = 0;
        // 初始化临时入度数组
        for (int i = 1; i <= n; ++i) tmp_rd[i] = rd[i];
        // 入度为0的节点入队
        for (int i = 1; i <= n; ++i)
            if (tmp_rd[i] == 0) q.push(i);
        // 处理队列中的节点
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cnt++;
            for (int v : g[u]) {
                if (--tmp_rd[v] == 0) q.push(v);
            }
        }
        return cnt == n;
    }

    int main() {
        cin >> n >> m;
        for (int i = 0; i < m; ++i) {
            int u, v;
            cin >> u >> v;
            g[u].push_back(v);
            rd[v]++;
        }
        // 先判断不删边是否无环
        if (topo_sort()) {
            cout << "YES" << endl;
            return 0;
        }
        // 枚举每个节点，入度减一
        for (int i = 1; i <= n; ++i) {
            if (rd[i] == 0) continue; // 无入边，跳过
            rd[i]--; // 入度减一（相当于删除一条指向i的边）
            if (topo_sort()) {
                cout << "YES" << endl;
                return 0;
            }
            rd[i]++; // 恢复入度
        }
        cout << "NO" << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并构建邻接表，统计每个节点的原始入度。然后调用`topo_sort`函数判断不删边时是否无环。若有环，则枚举每个节点（入度≥1），将其入度减一后再次判断。若任意一次判断成功，输出“YES”，否则输出“NO”。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段，并点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：青烟绕指柔**
* **亮点**：使用`#pragma GCC optimize`优化指令提升运行效率，代码简洁紧凑。
* **核心代码片段**：
    ```cpp
    inline int top_sort() {
        int cnt=0; queue<int> q;
        for(int i=1;i<=n;i++) if(!dag[i]) q.push(i);
        while(q.size()) {
            int u=q.front(); q.pop(); cnt++;
            for(auto to:g[u]) if(--dag[to]==0) q.push(to);
        }
        return cnt==n;
    }
    ```
* **代码解读**：
    这段代码是拓扑排序的核心实现。`dag`数组保存当前入度，队列`q`处理入度为0的节点。每次取出队首节点`u`，处理其所有邻接节点`to`，将`to`的入度减一。若`to`的入度变为0，则入队。最终通过`cnt`是否等于节点数判断是否无环。这里的`cnt`就像“已处理任务数”，如果所有任务都被处理，说明没有环卡住任务。
* 💡 **学习笔记**：队列是拓扑排序的常用工具，用于按顺序处理入度为0的节点。

**题解二：CharlesZiy**
* **亮点**：通过`IN`和`in`双数组保存状态，避免重复初始化。
* **核心代码片段**：
    ```cpp
    bool topsort() {
        queue<int> q;
        int cnt = 0;
        for (int i = 1; i <= n; i++) in[i] = IN[i]; // 复制原始入度到临时数组
        for (int i = 1; i <= n; i++)
            if (in[i] == 0) q.push(i);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            cnt++;
            for (int v : e[u]) {
                in[v]--;
                if (in[v] == 0) q.push(v);
            }
        }
        return cnt == n;
    }
    ```
* **代码解读**：
    这段代码中，`IN`数组保存原始入度，`in`数组是临时数组。每次调用`topsort`时，先将`IN`复制到`in`，避免修改原始数据。队列处理逻辑与之前一致，但双数组设计确保了每次枚举的独立性。就像做实验时，每次都用新的“副本”数据，避免之前的实验影响后续结果。
* 💡 **学习笔记**：双数组模式是处理多次状态修改的“安全锁”，防止数据污染。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解拓扑排序和枚举节点入度减一的过程，我设计了一个“像素探险队”主题的8位像素动画。让我们一起“看”算法如何工作！
</visualization_intro>

  * **动画演示主题**：`像素探险队的无环挑战`

  * **核心演示内容**：展示拓扑排序如何处理节点，以及枚举节点入度减一后的变化。例如，初始图中存在环（红色节点闪烁），枚举某个节点入度减一后，环被打破（绿色节点依次亮起），最终所有节点被处理（播放胜利音效）。

  * **设计思路简述**：采用8位像素风格（FC红白机色调），用不同颜色标记节点状态（绿色：入度0，黄色：入度>0，红色：环中节点）。动画通过“单步/自动”控制，配合音效提示关键操作，让学习者直观看到入度变化和节点处理顺序。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕中央是像素网格，每个节点用16x16的方块表示，边用细箭头连接。
          * 顶部显示控制面板：开始/暂停、单步、重置按钮，速度滑块（0.5x-2x）。
          * 播放8位风格背景音乐（类似《超级玛丽》的轻快旋律）。

    2.  **初始入度展示**：
          * 节点根据入度染色：绿色（入度0）、黄色（入度>0）。
          * 节点上方显示入度数值（如“3”），边的箭头旁显示“指向X”（X为终点）。

    3.  **拓扑排序演示**：
          * 队列区域（屏幕右侧）显示待处理节点，初始时绿色节点滑入队列（“入队”音效：轻脆的“叮”）。
          * 处理节点时，队列顶部节点弹出（“处理”音效：“咚”），其所有邻接边的终点入度减一（数值闪烁，颜色可能变绿）。
          * 若邻接节点入度变为0，立即滑入队列（“入队”音效）。

    4.  **枚举节点入度减一**：
          * 点击“枚举节点”按钮，选中一个黄色节点（如节点2），其入度数值减一（“-1”动画弹出），颜色短暂变红再恢复。
          * 重新运行拓扑排序，观察是否所有节点被处理（绿色节点铺满屏幕）。

    5.  **结果反馈**：
          * 若无环（所有节点处理完成），播放胜利音效（上扬的“啦~”），屏幕飘落像素星星。
          * 若有环（剩余红色节点），播放提示音效（短促的“滴”），环中节点闪烁提示。

  * **旁白提示**：
      * （单步时）“当前处理节点A，它的邻接节点B的入度减一，现在B的入度是2！”
      * （枚举节点时）“我们尝试删除一条指向节点C的边，它的入度从3变为2，看看是否能打破环？”
      * （成功时）“太棒了！所有节点都被处理，图无环！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能“看”到拓扑排序的每一步，还能直观理解枚举节点入度减一如何影响图的结构。这种“可视化+互动”的方式，让抽象的算法变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考拓扑排序在其他场景下的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 拓扑排序不仅用于判环，还可用于任务调度（如课程安排问题）、依赖关系解析（如软件包安装顺序）、最长路径计算（如DAG中的关键路径）等。核心是通过入度管理节点的处理顺序。

  * **练习推荐 (洛谷)**：
    以下是几道与本题考察知识点相关的题目，建议尝试：

    1.  **洛谷 P4017** - `最大食物链计数`
          * 🗣️ **推荐理由**：这道题需要用拓扑排序计算DAG中的路径数，能帮助你巩固拓扑排序的应用，并理解如何在无环图中统计信息。
    2.  **洛谷 P3385** - `【模板】负环`
          * 🗣️ **推荐理由**：此题需要判断图中是否存在负环，虽然与本题的无环判断不同，但能帮助你理解环的不同类型及其检测方法。
    3.  **洛谷 P1347** - `排序`
          * 🗣️ **推荐理由**：此题结合了拓扑排序和不等式约束，需要判断是否能唯一确定元素顺序，适合拓展拓扑排序的应用场景。

-----

## 7\. 学习心得与经验分享

<insights_intro>
部分题解作者分享了调试时的经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 蒟蒻且菜鸡)**：“我一开始没保存原始入度数组，每次拓扑排序后入度被修改，导致后续枚举错误。后来用`in`和`t`两个数组分别保存临时和原始入度，问题就解决了。”
>
> **点评**：这位作者的经验非常典型。在多次修改入度的场景中，必须用双数组保存状态，避免前一次操作影响后续判断。这提醒我们，处理“可恢复的临时修改”时，一定要备份原始数据。

-----

<conclusion>
本次关于“Almost Acyclic Graph”的C++解题分析就到这里。希望这份学习指南能帮助大家理解拓扑排序的优化应用，并掌握枚举策略的关键技巧。记住，编程能力的提升需要多思考、多实践，下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：136.81秒
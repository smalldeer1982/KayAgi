# 题目信息

# Circle Game

## 题目描述

Utkarsh is forced to play yet another one of Ashish's games. The game progresses turn by turn and as usual, Ashish moves first.

Consider the 2D plane. There is a token which is initially at  $ (0,0) $ . In one move a player must increase either the $ x $ coordinate or the $ y $ coordinate of the token by exactly $ k $ . In doing so, the player must ensure that the token stays within a (Euclidean) distance $ d $ from $ (0,0) $ .

In other words, if after a move the coordinates of the token are $ (p,q) $ , then $ p^2 + q^2 \leq d^2 $ must hold.

The game ends when a player is unable to make a move. It can be shown that the game will end in a finite number of moves. If both players play optimally, determine who will win.

## 说明/提示

In the first test case, one possible sequence of moves can be

 $ (0, 0) \xrightarrow{\text{Ashish }} (0, 1) \xrightarrow{\text{Utkarsh }} (0, 2) $ .

Ashish has no moves left, so Utkarsh wins.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1451D/00adebe318fd60c39c1fde9564efcda9489c81f2.png)

## 样例 #1

### 输入

```
5
2 1
5 2
10 3
25 4
15441 33```

### 输出

```
Utkarsh
Ashish
Utkarsh
Utkarsh
Ashish```

# AI分析结果

---
# 💡 Kay的C++算法解析：Circle Game 深入学习指南 💡

<introduction>
  今天我们来一起分析Codeforces的经典博弈题「Circle Game」。这道题需要我们用**数学推导+博弈论对称策略**解决，核心是找到“必胜态”和“必败态”的规律。本指南会帮你梳理思路、理解关键逻辑，还会用像素动画直观展示算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学推导 + 博弈论（对称策略与必胜态分析）

🗣️ **初步分析**：
> 解决「Circle Game」的关键，是理解**“对称策略”**——就像两个人轮流在纸上放硬币，先手放中心，后手永远放对称位置，最后先手必胜。这道题里，**后手可以通过对称操作，把token始终保持在直线`y = x`上**（比如先手往右走k，后手就往上走k，回到对角线上）。  
> 我们的目标是找到`y = x`上**最远的合法点**（记为`(x, x)`，满足`x² + x² ≤ d²`），然后判断：**从这个点再走一步（比如往右到`(x+k, x)`或往上到`(x, x+k)`）是否还在圆内**。如果能走，先手可以逼后手进入“走一步就出界”的绝境，先手胜；否则后手胜。  
> 可视化设计思路：用FC红白机风格的网格展示坐标，`y=x`用蓝色虚线标记，最远点`(x,x)`用黄色像素块，下一步的`(x+k,x)`用红色闪烁块。动画会单步展示“对称移动”的过程，比如先手走→，后手走↑，回到对角线，直到最后一步判断胜负。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法启发性三个维度，筛选了3份≥4星的优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：来源：Scintilla（赞10）**
* **点评**：这份题解的“对称思想”讲得最透彻！作者用“放硬币游戏”类比，瞬间点出了后手的策略——把位置拉回`y=x`。代码里计算“最远对角线点”的逻辑非常简洁：先算`sqrt(d²/2)`找到`y=x`上的最远点，再整除k得到实际能走的步数（因为每次必须走k）。最后判断下一步是否合法，直接输出结果。整个思路“一击即中”，没有冗余，非常适合入门学习。

**题解二：来源：NashChen（赞5）**
* **点评**：作者把问题“简化”的技巧很妙！他将所有坐标除以k（即`r = d/k`），把问题转化为“在半径r的圆内找整点”，这样计算更直观。然后分析“凸性”——如果`(n+2,n)`合法，那`(n+1,n+1)`肯定也合法（因为圆是凸的），直接推翻了“更远点”的可能。这种“问题转化+性质分析”的能力，是解决数学类博弈题的关键！

**题解三：来源：VinstaG173（赞4）**
* **点评**：这份题解用“博弈论定理”（必败态的所有后继都是必胜态，必胜态至少有一个后继是必败态）推导规律，结合画图举例（红色必胜点、蓝色必败点），让抽象的博弈论变得直观。作者还点出“对角线上状态相同”的规律，直接把问题简化为“判断最远对角线点的下一步是否合法”，思路非常清晰！

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，大家最容易卡壳的三个点是：“怎么想到对称策略？”“最远点怎么算？”“胜负条件怎么推导？” 结合优质题解，我帮你拆解清楚：
</difficulty_intro>

1.  **难点1：如何想到“对称策略”？**
    * **分析**：游戏的“对称性”是关键——每次只能加x或y，操作是对称的。后手只要“镜像”先手的操作（比如先手加x，后手加y），就能把token拉回`y=x`。这和“放硬币游戏”的核心逻辑一致：**用对称操作把“必败态”甩给对手**。
    * 💡 **学习笔记**：遇到“轮流操作+对称选择”的博弈题，先想“能不能用对称策略控制对手的位置”！

2.  **难点2：如何计算`y=x`上的最远点？**
    * **分析**：`y=x`上的点到原点的距离是`√(x² + x²) = x√2`，要满足`x√2 ≤ d`，所以`x ≤ d/√2`。但因为每次必须走k，所以实际最远点是`x = floor(d/√2 / k) * k`（比如d=5，k=2，d/√2≈3.535，除以k得1.767，floor后是1，乘以k得2，即点(2,2)）。
    * 💡 **学习笔记**：数学计算要结合“实际操作限制”（比如每次走k），不能只算理论值！

3.  **难点3：如何推导胜负条件？**
    * **分析**：找到最远点`(x,x)`后，判断`(x+k, x)`或`(x, x+k)`是否合法（即`(x+k)² + x² ≤ d²`）。如果合法，先手可以走这一步，后手接下来无论走x还是y，都会得到`(x+k, x+k)`（距离`√2(x+k)`，超过d）或`(x+2k, x)`（距离更大），必输；如果不合法，说明`(x,x)`是最后一个合法点，后手走到这里后，先手无法移动，后手胜。
    * 💡 **学习笔记**：胜负条件的本质是“谁能把对手逼到‘走一步就输’的位置”！

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个博弈题通用技巧：
</summary_best_practices>
- **技巧1：找对称**：如果操作对称（比如加x或加y），优先想“对称策略”，把对手拉到固定线上。
- **技巧2：算边界**：找到“最远合法点”是博弈题的常用套路，因为胜负往往由最后一步决定。
- **技巧3：简化问题**：比如把坐标除以k，把“走k步”转化为“走1步”，降低计算复杂度。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，它综合了所有优质题解的精华，逻辑最简洁：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Scintilla的题解，是“对称策略+数学计算”的典型实现，代码行数少但逻辑完整。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    using namespace std;
    typedef long long ll;

    int main() {
        int tc;
        cin >> tc;
        while (tc--) {
            ll d, k;
            cin >> d >> k;
            ll tp = sqrt(d * d / 2);  // y=x上的最远点理论值
            tp = tp / k * k;           // 实际能走的步数（必须是k的倍数）
            if (tp * tp + (tp + k) * (tp + k) <= d * d) {
                cout << "Ashish" << endl;
            } else {
                cout << "Utkarsh" << endl;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 读入测试用例；2. 计算`y=x`上的最远点`tp`（先算理论值，再调整为k的倍数）；3. 判断下一步`(tp+k, tp)`是否合法，输出结果。核心逻辑全在`tp`的计算和最后的条件判断里！

---
<code_intro_selected>
接下来剖析优质题解的**核心片段**，看看不同作者的巧妙处理：
</code_intro_selected>

**题解一：来源：Scintilla**
* **亮点**：用`sqrt(d*d/2)`直接计算`y=x`上的最远点，代码简洁到极致！
* **核心代码片段**：
    ```cpp
    ll tp = sqrt(d * d / 2);
    tp = tp / k * k;
    ```
* **代码解读**：
    > 第一行算`y=x`上的最远点理论值（比如d=5，d²/2=12.5，sqrt后≈3.535）；第二行把理论值调整为“k的倍数”（比如k=2，3.535/2≈1.767，floor后是1，乘以k得2）。这一步是“理论到实际”的关键——因为每次必须走k，所以不能走“零点几k”！
* 💡 **学习笔记**：处理“必须走固定步长”的问题时，要用“整除+乘法”调整数值！

**题解二：来源：NashChen**
* **亮点**：把问题简化为`r = d/k`，用整数计算避免浮点误差！
* **核心代码片段**：
    ```cpp
    long long k= (long double)N/M*sqrt(0.5);
    if(N*N< M*M*(2*k*k+2*k+1)) puts("Utkarsh");
    else puts("Ashish");
    ```
* **代码解读**：
    > 第一行计算`r = d/k * sqrt(0.5)`（即`d/√2`除以k），得到`y=x`上的最远点；第二行判断`(k*M)^2 + (k*M + M)^2`是否≤`N^2`（因为`N=d`，`M=k`），等价于`tp² + (tp+k)² ≤d²`。作者用整数运算避免了浮点误差，非常严谨！
* 💡 **学习笔记**：数学计算时，尽量用整数运算代替浮点，减少误差！

**题解三：来源：VinstaG173**
* **亮点**：用`0.70710678`（≈1/√2）快速计算`y=x`上的最远点！
* **核心代码片段**：
    ```cpp
    x=0.70710678*d/k;
    if((ll)k*k*(x*(x+1ll)<<1|1)<=(ll)d*d)puts("Ashish");
    ```
* **代码解读**：
    > 第一行用`0.7071`近似`1/√2`，快速算出`x`（`y=x`上的最远点）；第二行的`x*(x+1)<<1|1`等价于`2x(x+1)+1 = x² + (x+1)²`，再乘以`k²`就是`(kx)² + (k(x+1))²`，判断是否≤`d²`。作者用位运算和近似值优化了计算速度，非常巧妙！
* 💡 **学习笔记**：对于常见的数学常数（比如√2≈1.414，1/√2≈0.707），可以用近似值快速计算！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观看到“对称策略”和“胜负判断”的过程，我设计了一个**FC红白机风格的像素动画**，就像玩《超级马里奥》一样学算法！
</visualization_intro>

  * **动画演示主题**：像素小机器人在网格上“对战”，用对称策略争夺胜利！
  * **设计思路**：用8位像素风（类似《坦克大战》）营造复古氛围，用颜色和音效强化关键步骤——比如`y=x`用蓝色虚线，最远点用黄色，下一步用红色闪烁，移动时“哔”一声，判断胜负时“叮”一声。这样你能**“看”到算法的每一步**！

  * **动画帧步骤与交互**：
    1. **场景初始化**：
       - 屏幕显示20x20的像素网格（FC游戏的经典分辨率），原点(0,0)用绿色块标记，圆的边界用灰色虚线画出。
       - 控制面板有“单步”“自动”“重置”按钮，速度滑块（1x~5x），还有“显示y=x”的开关。
       - 播放8位风格的背景音乐（类似《塞尔达传说》的轻快旋律）。
    2. **对称移动演示**：
       - 先手（红色机器人）从(0,0)往右走k（比如k=2），到(2,0)，伴随“哔”的音效，(2,0)变红。
       - 后手（蓝色机器人）马上往上走k，到(2,2)，伴随“哔”的音效，(2,2)变蓝（回到`y=x`）。
       - 重复这个过程：先手走→到(4,2)，后手走↑到(4,4)……直到走到最远点(6,6)（比如d=9，k=2）。
    3. **胜负判断**：
       - 先手尝试走→到(8,6)，检查是否在圆内（比如d=9，8²+6²=100>81，超出），所以(8,6)变红闪烁，伴随“叮”的音效。
       - 动画显示“Utkarsh胜”，播放胜利音效（类似《魂斗罗》的通关音）。
    4. **AI自动演示**：
       - 点击“AI自动”，动画会快速播放整个过程，机器人自动走对称步，最后显示胜负。你可以调整速度滑块，慢慢看关键步骤。

  * **旁白提示**：
    - （先手走→时）“先手往右走k，现在位置(2,0)！”
    - （后手走↑时）“后手对称往上走k，回到y=x线！”
    - （判断时）“现在检查(8,6)是否在圆内——100>81，超出！后手胜！”

<visualization_conclusion>
这个动画把抽象的“对称策略”变成了“看得见的对战”，你能清楚看到后手如何“拉回”位置，以及最后一步的胜负判断。下次遇到博弈题，你肯定能立刻想到“对称策略”！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“对称策略+数学计算”思路，能解决很多博弈题！比如：
</similar_problems_intro>

  * **通用思路迁移**：
    - 问题1：两个人轮流取石子，每次取1或2颗，取最后一颗的胜——对称策略（先手取1，后手取2，保持每轮取3颗）。
    - 问题2：两个人轮流在棋盘上放棋子，不能重叠，放不下的输——对称策略（先手放中心，后手放对称位置）。
    - 问题3：两个人轮流走格子，每次走1或3步，走到终点的胜——找必败态（比如位置4是必败态，因为不管走1还是3，对手都能走到终点）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P1288** - 取数游戏II
       * 🗣️ **推荐理由**：这道题需要用“对称策略”找必胜态，和Circle Game的思路完全一致！
    2. **洛谷 P2148** - 比例简化
       * 🗣️ **推荐理由**：考察“数学计算+边界判断”，锻炼你“把理论值转化为实际值”的能力！
    3. **洛谷 P1199** - 三国游戏
       * 🗣️ **推荐理由**：博弈论中的“必败态分析”，需要找到“对手无法赢”的策略，和本题的胜负推导类似！
    4. **洛谷 P2575** - 高手过招
       * 🗣️ **推荐理由**：更复杂的博弈题，需要结合“对称策略”和“SG函数”，是本题的进阶版！

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里有很多作者的“踩坑经验”，比如：
</insights_intro>

> **参考经验 (来自 Konnyaku_LXZ)**：“我一开始直接用`sqrt(d²/2)`除以k，结果因为浮点误差算错了！后来才想到先转成整数再除以k，这样就不会错了。”
>
> **点评**：这个经验太重要了！浮点运算容易有误差（比如`sqrt(2)`≈1.414，但实际是无限不循环小数），所以处理“必须是整数倍”的问题时，一定要用“整数运算”（比如先算`d*d/2`，再开根号，再整除k）！

> **参考经验 (来自 TEoS)**：“我一开始没注意到`(x+k, x)`和`(x, x+k)`是等价的，浪费了很多时间推导。后来才发现圆是对称的，只要判断一个就行！”
>
> **点评**：利用“对称性”简化计算，是数学题的常用技巧！比如本题中，`(x+k, x)`和`(x, x+k)`到原点的距离一样，所以只要判断一个即可。

---

<conclusion>
本次关于「Circle Game」的分析就到这里！这道题的核心是“对称策略”和“数学计算”，只要掌握了这两个点，博弈题就会变得简单。记住：**博弈题的本质是“找规律”——找到必败态，然后把对手逼进去！** 下次遇到博弈题，先想“有没有对称策略”，再算“最远边界”，最后判断“下一步是否合法”，包你解决90%的问题！💪
</conclusion>

---

---
处理用时：194.28秒
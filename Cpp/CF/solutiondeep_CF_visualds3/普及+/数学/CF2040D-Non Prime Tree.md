# 题目信息

# Non Prime Tree

## 题目描述

给你一棵拥有 $n$ 个顶点的树。

你的任务是构造一个包含 $n$ 个不同整数的数组，这些整数从 $1$ 到 $2 \cdot n$ 分别取值。同时要求对于树中的任意一条边 $u_i \leftrightarrow v_i$，对应的数组元素差值 $|a_{u_i} - a_{v_i}|$ 不是质数。

请你找出任意一个符合以上条件的数组，如果不存在这样的数组，请输出 $-1$。

## 说明/提示

如下图所示的答案中，用对应数组 $a$ 的元素替代了顶点编号：

第一组数据的树结构 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/d6a56c20ebd42ea20ac170d596c01c0583a1b831.png)  
第二组数据的树结构 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/8328682bcf4d0da5fcbe8de4a0054b43d22d093e.png)

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
5
1 2
2 3
2 4
3 5
7
1 2
1 3
2 4
3 5
3 6
3 7```

### 输出

```
2 10 1 6 5 
8 7 12 1 4 6 3```

# AI分析结果


### Kay的C++算法解析：Non Prime Tree 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：「编程技巧应用」 (构造 + 图论染色)

🗣️ **初步分析**：
> 解决本题需巧妙利用非质数特性（1和合数）。核心思路是将树转化为二分图进行黑白染色，避免相邻节点差为质数（尤其是2）。  
> - **核心流程**：先染色分集合，再按特定顺序赋值偶数（2,4,...,2n）。若出现相邻差为2的情况，则调整为差为1（非质数）。  
> - **可视化设计**：动画将用黑白像素块表示节点染色，高亮关键赋值步骤。当出现差为2时触发闪烁警示，并展示数值调整（如+1）。  
> - **复古游戏化**：采用8位像素风，节点赋值时播放“叮”音效，成功时播放胜利音效。控制面板支持单步调试和自动演示（类似贪吃蛇AI寻路）。

---

#### 2. 精选优质题解参考
**题解一（lfxxx）**
* **点评**：思路清晰，通过黑白染色和菊花图特判覆盖所有情况。代码规范（如`col[u]`标识颜色），变量名直观（`vec`存储集合节点）。亮点在于严谨处理菊花图（中心赋2，其他节点赋1和6+），实践性强可直接用于竞赛。

**题解二（hgcnxn）**
* **点评**：对题解一的详细补充，代码更完整（如`dfs`染色和菊花图分讨）。边界处理严谨（如`B=1`时中心赋2），变量名明确（`B`/`W`统计集合大小）。亮点是提供严格证明，加深对构造逻辑的理解。

**题解三（tian720）**
* **点评**：创新性BFS分层法，按深度奇偶赋值（奇数层递增偶、偶数层递减偶）。代码简洁但需后置调整差为2的边（+1变1）。亮点是控制赋值范围在[1,2n]，实践时需注意调整可能破坏不重复性。

---

#### 3. 核心难点辨析与解题策略
1. **避免相邻差为质数**  
   * **分析**：质数差仅可能为2（因其他偶数差均为合数）。优质题解通过黑白染色隔离集合，优先赋值偶数（2k），最后调整一对异色节点差为1。
   * 💡 **学习笔记**：差为2是唯一风险点，1是万能调整值。

2. **菊花图特殊处理**  
   * **分析**：若中心节点与所有叶相连，需单独处理。题解1/7将中心赋2，叶节点赋1和≥6的偶数，确保差为1或≥4的合数。
   * 💡 **学习笔记**：星型拓扑中，中心与叶的差需多样化。

3. **保证赋值不重复**  
   * **分析**：题解8的分层赋值可能冲突，需动态调整末节点值（±1）。题解1/7通过固定集合赋值顺序（先非关键点再关键点）天然避免重复。
   * 💡 **学习笔记**：预分配值域区间是防重的有效手段。

### ✨ 解题技巧总结
- **技巧一（问题转化）**：将质数约束转化为二分图染色问题，利用偶数的合数性质。
- **技巧二（特殊结构识别）**：对链/菊花图等结构定制策略（如菊花图中心赋2）。
- **技巧三（边界调整）**：差为2时±1调整为1，兼顾非质数与不重复性。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合题解1/7的黑白染色法，处理菊花图与一般情况。
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 2e5 + 5;
  vector<int> g[N];
  int col[N], ans[N];

  void dfs(int u, int c, int fa) {
      col[u] = c;
      for (int v : g[u]) 
          if (v != fa) dfs(v, c ^ 1, u);
  }

  int main() {
      int t; cin >> t;
      while (t--) {
          int n; cin >> n;
          for (int i = 1; i <= n; i++) g[i].clear();
          // 建图
          for (int i = 1; i < n; i++) {
              int u, v; cin >> u >> v;
              g[u].push_back(v); g[v].push_back(u);
          }
          // 黑白染色
          dfs(1, 0, 0);
          int B = 0, W = 0;
          for (int i = 1; i <= n; i++) col[i] ? W++ : B++;

          // 菊花图判断
          bool star = false;
          for (int i = 1; i <= n; i++) 
              if (g[i].size() == n - 1) star = true;

          if (star) {
              for (int i = 1; i <= n; i++) {
                  if (g[i].size() == n - 1) ans[i] = 2; // 中心赋2
                  else ans[i] = (ans[i - 1] == 1 ? 6 : 1); // 交替赋1/6+
              }
          } else {
              // 找不相邻异色点p,q
              int p = -1, q = -1;
              for (int u = 1; u <= n; u++) {
                  for (int v : g[u]) {
                      if (g[u].size() >= 2 && g[v].size() >= 2) {
                          p = u; q = v; break;
                      }
                  }
              }
              // 赋值：非关键点->p->q->另一集合
              int val = 2;
              for (int i = 1; i <= n; i++) {
                  if (col[i] == col[p] && i != p) ans[i] = val, val += 2;
              }
              ans[p] = val; val += 2;
              ans[q] = val; val += 2;
              for (int i = 1; i <= n; i++) {
                  if (col[i] == col[q] && i != q) ans[i] = val, val += 2;
              }
          }
          for (int i = 1; i <= n; i++) cout << ans[i] << " ";
          cout << endl;
      }
  }
  ```
* **代码解读概要**：先染色，再分菊花图/一般情况处理。菊花图中心赋2，其他节点交替赋1和≥6的偶；一般情况通过异色点隔离风险边，按集合顺序赋值偶数。

---

**题解一片段赏析（lfxxx）**
* **亮点**：菊花图处理简洁，直接定位中心节点。
* **核心代码**：
  ```cpp
  if (E[i].size() == n - 1) { // 菊花图判断
      ans[i] = 1;
      ans[E[i][0]] = 0;
      for (int j = 1; j < E[i].size(); j++)
          ans[E[i][j]] = j + 2;
      // 输出：中心为2，其他为1,6,8...
      for (int j = 1; j <= n; j++) 
          cout << (ans[j] == 0 ? 1 : 2 * ans[j]) << ' ';
  }
  ```
* **代码解读**：检测度=n-1的节点为中心。中心赋2（`2*1`），首子节点赋1（`2*0→1`），其余子节点赋6,8...（`2*(j+2)`）。  
  💡 **学习笔记**：菊花图赋值需中心与叶的差≥4（除1外）。

**题解三片段赏析（tian720）**
* **亮点**：BFS分层动态调整末节点值。
* **核心代码**：
  ```cpp
  if (t[aa.x] == n && abs(ans[aa.fa] - ans[aa.x]) == 2) {
      if (dep[aa.x] & 1) ans[aa.x]++; // 奇数层+1
      else ans[aa.x]--;               // 偶数层-1
  }
  ```
* **代码解读**：BFS按层赋值，奇数层赋递增偶（2,4,...），偶数层赋递减偶（2n,2n-2,...）。最后检查父-子差若为2，则调整子节点值±1使差为1。  
  💡 **学习笔记**：动态调整是处理边界的高效技巧。

---

#### 5. 算法可视化：像素动画演示
**主题**：像素探险家在树形迷宫中赋值  
**核心演示**：  
1. **初始化**：树节点渲染为FC风格像素块，黑白染色后分灰/白色。控制面板含步进/调速滑块。  
   ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/d6a56c20ebd42ea20ac170d596c01c0583a1b831.png)
2. **赋值过程**：  
   - **菊花图**：中心变红（赋2），播放"叮"音效；叶子变黄（赋1）或绿（赋6+），差值≥4时播放胜利音效。  
   - **一般情况**：不相邻异色点p/q闪烁后赋深蓝/浅蓝（如14/16），其他点按集合顺序赋渐变色。若边差=2（如14-16），p闪烁后+1→15（差=1），播放"噗"调整音效。
3. **自动演示**：AI模式模拟贪吃蛇移动，沿边遍历并赋值，实时显示当前差值（非质数时显示绿色✔）。

---

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：  
  1. 二分图染色用于相邻约束问题（如CF1144F 定向边使路径偶）。  
  2. 特殊结构（菊花图/链）在构造题中的特判（如P2668 斗地主出牌方案）。  
  3. 动态调整边界值的方法（如P1330 封锁阳光大学时的节点覆盖）。

* **洛谷推荐**：  
  1. **P1330** - 封锁阳光大学  
     🗣️ 练习二分图染色，强化集合划分思想。  
  2. **P2661** - 信息传递  
     🗣️ 基环树应用，理解特殊拓扑构造。  
  3. **P2668** - 斗地主  
     🗣️ 复杂构造题，训练多条件约束处理能力。

---

#### 7. 学习心得与经验分享
> **参考经验（来自 cancan1234）**："随机化因合数密度高而可行，但竞赛中应优先保证确定性解法。"  
> **点评**：该心得强调随机化的实用性，但本题解显示黑白染色法更稳健。调试时可打印中间染色结果，快速定位赋值冲突。

---

本次解析深入探索了树构造问题的核心技巧，结合像素动画提升理解。记住：编程能力=知识×实践×调试！下次挑战再见 💪

---
处理用时：162.06秒
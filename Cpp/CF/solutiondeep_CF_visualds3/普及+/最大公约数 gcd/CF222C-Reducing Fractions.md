# 题目信息

# Reducing Fractions

## 题目描述

To confuse the opponents, the Galactic Empire represents fractions in an unusual format. The fractions are represented as two sets of integers. The product of numbers from the first set gives the fraction numerator, the product of numbers from the second set gives the fraction denominator. However, it turned out that the programs that work with fractions in this representations aren't complete, they lack supporting the operation of reducing fractions. Implement this operation and the Empire won't forget you.

## 说明/提示

In the first test sample the numerator equals 1000, the denominator equals 500. If we reduce fraction 1000/500 by the greatest common divisor of the numerator and the denominator (by 500), we obtain fraction 2/1.

In the second test sample the numerator equals 2000, the denominator equals 300. If we reduce fraction 2000/300 by the greatest common divisor of the numerator and the denominator (by 100), we obtain fraction 20/3.

## 样例 #1

### 输入

```
3 2
100 5 2
50 10
```

### 输出

```
2 3
2 1
1 1 1
```

## 样例 #2

### 输入

```
4 3
2 5 10 20
100 1 3
```

### 输出

```
1 1
20
3
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Reducing Fractions 深入学习指南 💡

<introduction>
今天我们来一起分析“Reducing Fractions”这道C++编程题。这道题的核心是通过质因数分解和约分操作，将两个数组的乘积表示的分数化为最简形式。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质因数分解与统计）`

🗣️ **初步分析**：
> 解决“Reducing Fractions”的关键在于质因数分解。质因数分解就像把一个数“拆成最小的积木块”——每个积木块都是质数（只能被1和自身整除的数）。例如，12可以拆成2×2×3，这里的2和3就是质数块。本题中，我们需要将分子数组和分母数组中的每个数都拆成这样的质数块，统计所有质数块的数量，然后约去分子和分母中共有的质数块（取两者数量的最小值），最后将剩下的质数块重新组合成新的分子和分母数组。

   - **题解思路**：所有题解的核心思路一致：预处理质数（或最小质因子）→分解每个数的质因数→统计分子/分母的质数次数→约去公共次数→调整每个数的因子。不同题解的差异主要在于质因数分解的预处理方法（如线性筛最小质因子、Pollard-Rho算法等）。
   - **核心难点**：高效质因数分解（避免O(√n)的朴素分解）、正确调整每个数的因子（保持数组长度不变）。
   - **可视化设计**：我们将设计一个“质因数分解探险”像素动画，用8位风格展示每个数分解为质数块的过程（如数字12分解为2、2、3三个像素块），统计分子/分母的质数块总数（用堆叠的像素塔表示），约去公共块时用“消失动画”，最后重组新数时用“合并动画”。关键步骤（如分解、统计、约去）会伴随“叮”的像素音效，成功完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下2道题解评分≥4星，值得重点参考：
</eval_intro>

**题解一：作者：蒟酱**
* **点评**：此题解巧妙利用线性筛预处理每个数的最小质因子（mif数组），分解质因数时只需不断除以最小质因子，时间复杂度低至O(logn)。代码虽有压行但逻辑清晰（如用`std::basic_string<int>`存储原数组），变量命名简洁（如`cnt[p].fi`表示分子质数p的次数）。算法上，通过预处理最小质因子避免了朴素分解的低效，是本题的最优解之一。实践中，此代码能高效处理1e7以内的数，适合竞赛场景。

**题解二：作者：Enthon_Yuan**
* **点评**：此题解的亮点在于“记录质因子来源位置”的设计。分解质因数时，将每个质数块的来源（原数组中的位置）存储在`s1`和`s2`数组中，约去公共次数时直接调整对应位置的数。这种方法避免了乘积溢出问题（如多个质数相乘超过1e7），保证输出符合要求。代码结构工整（如`q1`和`q2`函数分工明确），变量命名直观（如`ans1`存储分子调整后的结果），是处理此类问题的经典思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我们提炼了对应的解决策略：
</difficulty_intro>

1.  **关键点1：高效质因数分解**
    * **分析**：直接试除法（O(√n)）对大数（如1e7）分解效率低。优质题解（如蒟酱的题解）通过线性筛预处理每个数的最小质因子（mif数组），分解时只需不断除以最小质因子，时间复杂度降至O(logn)。例如，分解12时，mif[12]=2，12/2=6（mif[6]=2），6/2=3（mif[3]=3），3/3=1，得到质因数2×2×3。
    * 💡 **学习笔记**：预处理最小质因子是加速质因数分解的“利器”，适用于值域明确（如≤1e7）的场景。

2.  **关键点2：正确调整每个数的因子**
    * **分析**：约去公共质因子后，需保证原数组长度不变。Enthon_Yuan的题解通过记录每个质因子的来源位置（如`s1[i]`存储质数i在分子数组中的来源位置），约去时只调整对应位置的数（将未被约去的质因子相乘）。例如，若质数2在分子中出现3次，分母中出现2次，则前2次约去，第3次保留并乘到原数的对应位置。
    * 💡 **学习笔记**：记录质因子的来源位置，能精准控制每个数的因子调整，避免乘积溢出。

3.  **关键点3：保持输出数组长度不变**
    * **分析**：若所有质因子都被约去，原数应输出1。例如，分子数组中的数5若被完全约去（分母中5的次数≥1），则输出1。优质题解通过初始化`ans1[i]=1`（如Enthon_Yuan的代码），确保无剩余因子时输出1。
    * 💡 **学习笔记**：初始化结果数组为1，是处理“无剩余因子”情况的简单有效方法。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理最小质因子**：值域明确时，线性筛预处理最小质因子，加速质因数分解。
- **记录来源位置**：调整因子时，记录每个质因子的来源位置，避免乘积溢出。
- **初始化结果数组**：结果数组初始化为1，确保无剩余因子时输出1。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了线性筛最小质因子和来源位置记录的优点，代码清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合蒟酱和Enthon_Yuan的题解思路，采用线性筛预处理最小质因子，分解质因数时记录来源位置，调整因子时精准控制每个数的结果。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    const int N = 1e7 + 1; // 最大数范围
    int mif[N]; // 最小质因子数组
    vector<int> primes; // 存储质数

    void sieve() {
        for (int i = 2; i < N; ++i) {
            if (!mif[i]) { // i是质数
                mif[i] = i;
                primes.push_back(i);
            }
            for (int p : primes) {
                if (p > mif[i] || i * p >= N) break;
                mif[i * p] = p; // 记录i*p的最小质因子为p
            }
        }
    }

    int main() {
        sieve(); // 预处理最小质因子
        int n, m;
        cin >> n >> m;

        vector<int> a(n), b(m);
        vector<vector<int>> s1(n), s2(m); // 存储每个数的质因数分解结果（来源位置）

        // 分解分子数组
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            int x = a[i];
            while (x > 1) {
                int p = mif[x];
                s1[i].push_back(p); // 记录质因子p到第i个数的分解结果中
                x /= p;
            }
        }

        // 分解分母数组
        for (int i = 0; i < m; ++i) {
            cin >> b[i];
            int x = b[i];
            while (x > 1) {
                int p = mif[x];
                s2[i].push_back(p); // 记录质因子p到第i个数的分解结果中
                x /= p;
            }
        }

        // 统计分子和分母的质因数次数
        vector<int> cnt1(N, 0), cnt2(N, 0);
        for (auto &factors : s1)
            for (int p : factors) cnt1[p]++;
        for (auto &factors : s2)
            for (int p : factors) cnt2[p]++;

        // 计算需要约去的次数（取最小值）
        vector<int> del(N);
        for (int p : primes) del[p] = min(cnt1[p], cnt2[p]);

        // 调整分子数组
        vector<int> ans1(n, 1);
        for (int i = 0; i < n; ++i) {
            for (int p : s1[i]) {
                if (del[p] > 0) {
                    del[p]--; // 约去一个p
                } else {
                    ans1[i] *= p; // 保留未被约去的p
                }
            }
        }

        // 调整分母数组
        vector<int> ans2(m, 1);
        for (int i = 0; i < m; ++i) {
            for (int p : s2[i]) {
                if (del[p] > 0) {
                    del[p]--; // 约去一个p
                } else {
                    ans2[i] *= p; // 保留未被约去的p
                }
            }
        }

        // 输出结果
        cout << n << " " << m << "\n";
        for (int num : ans1) cout << num << " ";
        cout << "\n";
        for (int num : ans2) cout << num << " ";
        cout << "\n";

        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先通过`sieve`函数预处理每个数的最小质因子（`mif`数组），然后分解分子和分母数组中的每个数（`s1`和`s2`存储每个数的质因数）。统计质因数次数后，计算需要约去的次数（`del`数组），最后调整每个数的因子（未被约去的质因子相乘得到结果）。核心逻辑是通过最小质因子加速分解，并通过记录质因数来源调整结果。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解其巧妙之处：
</code_intro_selected>

**题解一：作者：蒟酱**
* **亮点**：线性筛预处理最小质因子，分解时直接取`mif[x]`，代码简洁高效。
* **核心代码片段**：
    ```cpp
    for(int i=2;i<N;i++){
        if(!pr[i]) pt+=i,mif[i]=i;
        for(int j:pt){
            if(i*j>=N) break;
            pr[i*j]=true;
            mif[i*j]=j;
            if(i%j==0) break;
        }
    }
    // 分解质因数
    for(int i=1,x;i<=n;i++)
        for(int p=mif[cin>>x,ans1+=x,x];x!=1;p=mif[x/=p])
            cnt[p].fi++;
    ```
* **代码解读**：
    > `sieve`部分通过线性筛预处理每个数的最小质因子`mif[i]`（例如，`mif[12]=2`）。分解质因数时，`x`不断除以`mif[x]`（如12→6→3→1），每次得到最小质因子`p`，并统计次数（`cnt[p].fi++`）。这种方法将质因数分解的时间复杂度降至O(logn)，是本题高效的关键。
* 💡 **学习笔记**：线性筛预处理最小质因子，是处理质因数分解问题的“标配”技巧。

**题解二：作者：Enthon_Yuan**
* **亮点**：记录质因子的来源位置，调整因子时直接乘到原数位置，避免乘积溢出。
* **核心代码片段**：
    ```cpp
    vector<int> s1[K],s2[K]; // 存储质数p在分子/分母中的来源位置
    void q1(int x,int y) { // 分解分子x，记录来源位置y
        while(is[x]) {
            s1[is[x]].emplace_back(y);
            x /= pri[is[x]];
        }
        if(x > 1) s1[fd(x)].emplace_back(y);
    }
    // 调整因子
    fo(i,1,cnt) {
        int mm = min(s1[i].size(),s2[i].size());
        fo(j,mm,(int)s1[i].size()-1) ans1[s1[i][j]] *= pri[i];
        fo(j,mm,(int)s2[i].size()-1) ans2[s2[i][j]] *= pri[i];
    }
    ```
* **代码解读**：
    > `s1[i]`存储质数`pri[i]`在分子数组中的来源位置（如`s1[2]`存储所有包含质数2的分子数的索引）。约去公共次数`mm`后，未被约去的质数`pri[i]`会被乘到对应位置的`ans1`或`ans2`中。例如，若质数2在分子中出现3次（来源位置为0、1、2），分母中出现2次，则前2次约去，第3次（位置2）的`ans1[2] *= 2`。
* 💡 **学习笔记**：记录来源位置，能精准控制每个数的因子调整，是解决“输出数组长度不变”问题的关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解质因数分解和约分过程，我们设计了“质因数分解探险”像素动画，用8位风格展示每个步骤！
</visualization_intro>

  * **动画演示主题**：`像素质数探险队`
  * **核心演示内容**：分子/分母数组中的数分解为质数块→统计质数块总数→约去公共块→重组新数。
  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；质数块用不同颜色（如2为红色，3为蓝色）区分；分解时播放“拆解”音效（叮~），约去时播放“消失”音效（噗~），重组时播放“合并”音效（咚~），增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左半为分子区（黄色背景），右半为分母区（蓝色背景）。每个数用像素方块表示（如12显示为“12”的像素文字）。
          * 控制面板：单步/自动播放按钮、速度滑块（1x~5x）、重置按钮。
          * 背景音乐：8位风格的轻快旋律（类似《超级玛丽》的主题音乐）。

    2.  **质因数分解**：
          * 点击“开始”，分子区的第一个数（如12）开始分解：像素方块“12”分裂为三个小方块（2、2、3），每个小方块显示质数（红色2，蓝色3），伴随“叮”的音效。
          * 分解后的质数块被拖到分子统计区（左下方），堆叠成塔（如2的塔高+1，3的塔高+1）。
          * 分母区同理，分解数并统计质数块塔高。

    3.  **约去公共块**：
          * 统计区显示分子/分母的质数塔高（如分子2的塔高3，分母2的塔高2）。
          * 公共块数量为min(3,2)=2，分子/分母的2塔各减少2层，对应质数块消失（像素闪烁后变透明），播放“噗”的音效。

    4.  **重组新数**：
          * 分子区的每个数重新收集未被约去的质数块（如原数12分解的2、2、3中，2被约去2个，剩余1个2和3），合并成新数（2×3=6），像素块合并时播放“咚”的音效。
          * 若所有质数块被约去（如原数5的质数块被约去），则显示为“1”的像素块。

    5.  **目标达成**：
          * 所有数重组完成后，屏幕中央显示“约分成功！”，播放胜利音效（上扬的“啦~”），背景闪烁绿色。

  * **旁白提示**：
      * （分解时）“看！12被拆成了2、2、3三个质数块！”
      * （约去时）“分子和分母都有2个2，它们被约去了~”
      * （重组时）“剩下的质数块合并成了新数6！”

<visualization_conclusion>
通过这个动画，我们能直观看到每个数如何分解、统计、约去和重组，轻松理解质因数分解和约分的核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固质因数分解和数学应用能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 质因数分解不仅用于约分，还可解决最大公约数（GCD）、最小公倍数（LCM）、约数个数统计等问题。例如，求两个数的GCD，只需取公共质因数的最小次数乘积。
      * 预处理最小质因子的方法，还可用于快速判断质数、分解大数等场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1075** - `质因数分解`
          * 🗣️ **推荐理由**：直接考察质因数分解，适合练习最小质因子预处理方法。
    2.  **洛谷 P1403** - `约数研究`
          * 🗣️ **推荐理由**：需要统计每个数的约数个数，质因数分解是关键步骤。
    3.  **洛谷 P2197** - `nim游戏`
          * 🗣️ **推荐理由**：结合数学博弈论，质因数分解用于分析游戏必胜态。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
Enthon_Yuan在题解中提到：“直接乘法可能会浪费空间，导致输出量过大。记录质因子的来源位置，能避免乘积溢出。”这是一个非常实用的经验！
</insights_intro>

> **参考经验 (来自 Enthon_Yuan)**：“在调整因子时，直接将未被约去的质因子乘到原数的位置，而不是重新生成新数，可以避免多个质数相乘超过1e7的问题，保证输出符合要求。”
>
> **点评**：这个经验提醒我们，在处理因子调整时，要关注原数的位置信息。通过记录来源位置，能精准控制每个数的因子，避免乘积溢出，这是解决此类问题的关键技巧。

-----

<conclusion>
本次关于“Reducing Fractions”的C++解题分析就到这里。希望这份指南能帮助大家掌握质因数分解和约分的核心技巧。记住，多动手练习、多思考不同方法的差异，是提升编程能力的关键！下次见~ 💪
</conclusion>

---
处理用时：438.97秒
# 题目信息

# Line

## 题目描述

A line on the plane is described by an equation $ Ax+By+C=0 $ . You are to find any point on this line, whose coordinates are integer numbers from $ -5·10^{18} $ to $ 5·10^{18} $ inclusive, or to find out that such points do not exist.

## 样例 #1

### 输入

```
2 5 3
```

### 输出

```
6 -3
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Line 深入学习指南 💡

<introduction>
今天我们来一起分析“Line”这道C++编程题。这道题需要我们找到直线Ax + By + C = 0上的一个整数点，或判断不存在这样的点。本指南将帮助大家理解核心算法，掌握解题技巧，并通过可视化方案直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧几里得算法（exgcd）应用

🗣️ **初步分析**：
解决“Line”这道题的关键在于运用扩展欧几里得算法（exgcd）求解不定方程的整数解。简单来说，扩展欧几里得算法是欧几里得算法（求最大公约数）的扩展，它不仅能计算两个数的最大公约数（gcd），还能找到一组整数解(x, y)，使得ax + by = gcd(a, b)。这就像一把钥匙，能帮我们打开不定方程的“整数解”之门！

在本题中，直线方程Ax + By + C = 0可变形为Ax + By = -C。根据裴蜀定理，这个方程存在整数解的充要条件是gcd(A, B)能整除-C。若满足条件，我们可以通过扩展欧几里得算法求出ax + by = gcd(a, b)的一组特解，再通过比例缩放得到原方程的解。

核心难点在于：
- 正确应用扩展欧几里得算法求解特解；
- 处理解的存在性判断（即判断-C是否能被gcd(A,B)整除）；
- 将特解转换为原方程的解（需注意数值范围和缩放倍数）。

可视化设计思路：我们将用8位像素风格动画演示扩展欧几里得算法的递归过程。例如，用不同颜色的像素方块表示系数a、b，通过“辗转相除”动画展示gcd的计算过程；用闪烁箭头标记当前递归层的x、y值，最终高亮显示特解的推导路径。关键步骤（如递归终止、系数更新）会伴随“叮”的像素音效，增强操作记忆。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解因逻辑清晰、代码规范、实践价值高，被选为优质参考：
</eval_intro>

**题解一：作者Crab_Dave (赞：68)**
* **点评**：这份题解详细推导了扩展欧几里得算法的原理，结合裴蜀定理解释了不定方程解的存在条件，并通过代码完整展示了从求解特解到缩放得到原方程解的全过程。代码中使用`long long`避免溢出，边界处理严谨（如判断`c%d!=0`时输出-1），是一份非常适合初学者理解的模板级题解。特别值得学习的是作者对算法原理的详细说明，帮助我们知其然更知其所以然。

**题解二：作者Dog_Two (赞：6)**
* **点评**：此题解结构清晰，将扩展欧几里得算法的定义、证明、代码实现及应用场景（如解线性方程、求逆元）分模块讲解，逻辑层层递进。代码采用模块化设计（`ext_gcd`函数和`linear_Eqa`函数分离），变量名含义明确（如`d`表示gcd），可读性强。对解的存在性判断和缩放过程的解释简洁到位，是一份“思路+代码”双优的题解。

**题解三：作者KagurazakaKano (赞：5)**
* **点评**：此题解简洁明了，直接抓住核心——通过扩展欧几里得算法求解特解，再缩放得到原方程的解。代码短小精悍（递归实现exgcd仅5行），但关键步骤（如`y -= a / b * x`）注释清晰。特别适合需要快速掌握模板的学习者，其“背结论”的学习心得也提醒我们：在理解原理的基础上记忆模板能提升效率。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何判断不定方程是否有整数解？**
    * **分析**：根据裴蜀定理，方程Ax + By = C有整数解的充要条件是gcd(A, B)能整除C。在本题中，方程变形为Ax + By = -C，因此需判断gcd(A, B)是否整除-C。若不能整除，直接输出-1；若能，则继续求解。
    * 💡 **学习笔记**：解的存在性判断是第一步，漏掉这一步会导致错误（如输出错误的解或遗漏无解情况）。

2.  **关键点2：如何通过扩展欧几里得算法求解特解？**
    * **分析**：扩展欧几里得算法通过递归实现，利用gcd(a, b) = gcd(b, a%b)的性质，从递归终止条件（b=0时x=1, y=0）反推初始解。例如，递归调用`exgcd(b, a%b, x, y)`后，当前层的x和y需通过`x = y_prev`，`y = x_prev - (a/b)*y_prev`更新，最终得到ax + by = gcd(a, b)的特解。
    * 💡 **学习笔记**：理解递归过程中x和y的更新公式是掌握扩展欧几里得算法的关键。

3.  **关键点3：如何将特解转换为原方程的解？**
    * **分析**：扩展欧几里得算法求得的是ax + by = gcd(a, b)的特解(x0, y0)。原方程Ax + By = -C的解需将特解缩放k倍，其中k = (-C) / gcd(A, B)。因此，原方程的一组解为(x0*k, y0*k)。
    * 💡 **学习笔记**：缩放时需注意符号（本题中C取负）和数值范围（题目要求x, y在[-5e18, 5e18]内）。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将直线方程变形为不定方程，明确求解目标。
- **模板记忆**：扩展欧几里得算法的递归实现是固定模板，需熟练掌握（注意用`long long`避免溢出）。
- **边界处理**：解的存在性判断（`c % d != 0`时输出-1）和数值范围检查（本题中题目保证解在范围内，无需额外处理）。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用递归实现扩展欧几里得算法，结构清晰、代码简洁，适合作为模板使用。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    using ll = long long; // 使用类型别名简化代码

    // 扩展欧几里得算法，返回gcd(a,b)，并通过引用返回特解x,y（满足ax + by = gcd(a,b)）
    ll exgcd(ll a, ll b, ll& x, ll& y) {
        if (b == 0) {
            x = 1; y = 0; // 递归终止条件：b=0时，a*1 + 0*0 = a = gcd(a,0)
            return a;
        }
        ll d = exgcd(b, a % b, x, y); // 递归求解b和a%b的gcd及特解
        ll tmp = x; // 保存当前x（即下一层的y）
        x = y; // 当前x更新为下一层的y
        y = tmp - (a / b) * y; // 当前y更新为下一层的x - (a/b)*下一层的y
        return d;
    }

    int main() {
        ll A, B, C, x, y;
        cin >> A >> B >> C;
        C = -C; // 变形为Ax + By = -C
        ll d = exgcd(A, B, x, y); // 求Ax + By = gcd(A,B)的特解x,y

        if (C % d != 0) { // 无解条件：-C不能被gcd(A,B)整除
            cout << -1 << endl;
            return 0;
        }

        ll k = C / d; // 缩放倍数
        x *= k; y *= k; // 特解缩放得到原方程的解

        cout << x << " " << y << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入A、B、C，并将方程变形为Ax + By = -C。然后调用扩展欧几里得算法`exgcd`求解Ax + By = gcd(A,B)的特解(x, y)。通过判断-C是否能被gcd(A,B)整除确定是否有解：若不能，输出-1；若能，将特解缩放k倍（k = (-C)/gcd(A,B)），得到原方程的一组整数解并输出。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者Crab_Dave**
* **亮点**：递归实现扩展欧几里得算法，代码简洁，变量名清晰（`tmp`保存中间值），边界处理严谨（判断`c%d!=0`）。
* **核心代码片段**：
    ```cpp
    int exgcd(int a,int b)//扩展欧几里得
    {
        if(b==0){x=1;y=0;return a;}//临界条件
        int tmp=exgcd(b,a%b);//逆推回去求解
        int t=x;
        x=y;y=t-a/b*y;
        return tmp;
    }
    ```
* **代码解读**：
    > 这段代码是扩展欧几里得算法的递归实现。当`b=0`时，递归终止，此时x=1、y=0满足`a*1 + 0*0 = a = gcd(a,0)`。对于非终止情况，递归调用`exgcd(b, a%b)`求解子问题的特解，然后通过`x = y_prev`、`y = t - (a/b)*y_prev`（其中`t`是递归前的x值）更新当前层的x和y，最终返回gcd(a,b)。这一步是算法的核心，通过递归反推得到初始解。
* 💡 **学习笔记**：递归过程中，每一层的x和y都依赖于下一层的解，理解这种“自底向上”的推导是掌握扩展欧几里得算法的关键。

**题解二：作者Dog_Two**
* **亮点**：代码模块化，将扩展欧几里得算法和线性方程求解分离（`ext_gcd`和`linear_Eqa`函数），提高可读性和复用性。
* **核心代码片段**：
    ```cpp
    long long ext_gcd(long long a,long long b,long long &x,long long &y){
        if(!b){
            x=1,y=0;
            return a;
        }
        long long d=ext_gcd(b,a%b,x,y);
        long long temp=x;x=y,y=temp-a/b*y;
        return d;
    }
    ```
* **代码解读**：
    > `ext_gcd`函数通过引用传递x和y，直接修改其值。递归终止时（b=0），x=1、y=0；否则递归求解`ext_gcd(b, a%b, x, y)`，得到子问题的解后，用临时变量`temp`保存当前x（即下一层的y），然后更新x为下一层的y，y为`temp - (a/b)*y`（即下一层的x减去商乘以下一层的y）。这样，最终x和y即为原问题的特解。
* 💡 **学习笔记**：模块化设计能让代码更易维护，特别是在处理复杂问题时，将功能拆分为小函数是良好的编程习惯。

**题解三：作者KagurazakaKano**
* **亮点**：代码极简，递归实现仅5行，通过交换参数和引用传递简化逻辑。
* **核心代码片段**：
    ```cpp
    void ex_gcd (LL a, LL b, LL &x, LL &y) {
        if(!b) {x = 1; y = 0;}
        else {ex_gcd(b, a % b, y, x); y -= a / b * x;}
    }
    ```
* **代码解读**：
    > 这段代码的巧妙之处在于递归调用时交换了x和y的引用（`ex_gcd(b, a%b, y, x)`），这样下一层的x会被赋值给当前层的y，下一层的y会被赋值给当前层的x，从而省略了临时变量。递归返回后，通过`y -= a/b * x`调整y的值，最终得到正确的特解。这种写法简洁但需要仔细理解参数传递的顺序。
* 💡 **学习笔记**：代码简洁性与可读性需平衡，这种写法适合熟练掌握算法的学习者，但初学者建议使用更明确的临时变量写法。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解扩展欧几里得算法的执行过程，我们设计了一个“像素探险家”主题的8位像素风格动画。通过动态展示gcd的计算和特解的推导，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素探险家的gcd之旅`

  * **核心演示内容**：演示扩展欧几里得算法如何递归求解ax + by = gcd(a,b)的特解，重点展示：
    - 初始参数a、b的“探险起点”；
    - 递归过程中a、b的变化（如a=20, b=32 → a=32, b=20%32=20 → ...）；
    - 特解x、y的推导路径（从递归终止条件反推初始解）。

  * **设计思路简述**：采用8位像素风格（类似FC红白机）营造轻松氛围；用不同颜色的像素方块表示a、b（如红色代表a，蓝色代表b），闪烁箭头标记当前递归层；关键操作（如递归调用、x/y更新）伴随“叮”的音效，强化记忆；每完成一层递归视为“闯过一关”，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是“探险地图”（像素网格，显示当前a、b的值），右侧是“解推导区”（显示当前x、y的值）。
          * 控制面板包含“单步”、“自动播放”按钮和速度滑块（1x-4x）。
          * 8位风格背景音乐（如《超级玛丽》经典旋律）响起。

    2.  **初始参数展示**：
          * 输入参数A、B、C显示在屏幕顶部，变形后的方程Ax + By = -C用黄色高亮。
          * 探险地图中，a和b的初始值（如a=20, b=32）以红色和蓝色像素块堆叠显示。

    3.  **递归过程演示**：
          * **步骤1（递归调用）**：计算a%b（如20%32=20），探险地图中b的像素块移动到a的位置，a%b的像素块成为新的b（即a=32, b=20）。伴随“唰”的音效，箭头指向新的a、b。
          * **步骤2（终止条件）**：当b=0时（如a=4, b=0），探险地图显示“终点”标志，解推导区显示x=1, y=0，伴随“叮咚”音效。
          * **步骤3（反推特解）**：从终止条件开始，逐层返回更新x、y。例如，上一层a=8, b=4，x=0, y=1 → 更新为x=1, y=0 - (8/4)*1 = -1，解推导区用绿色闪烁显示新的x、y值，伴随“滴答”音效。

    4.  **解的缩放与输出**：
          * 计算k = (-C)/gcd(A,B)，解推导区显示x*k和y*k，像素块从特解位置“缩放”到原方程的解位置（如x=2*(-3/4)=-1.5 → 但本题中k为整数，直接显示整数解）。
          * 最终解用金色像素块高亮，伴随“胜利”音效（如《魂斗罗》通关音乐）。

    5.  **无解情况提示**：
          * 若-C不能被gcd(A,B)整除，探险地图显示“障碍”图标，解推导区显示“-1”，伴随“警报”音效（短促“滴滴”声）。

  * **旁白提示**：
      * （单步执行时）“现在，我们递归求解b和a%b的gcd，注意a和b的位置交换了！”
      * （终止条件触发时）“看！b=0了，此时x=1, y=0是基础解！”
      * （反推特解时）“现在返回上一层，x和y需要根据下一层的解更新，公式是y = 旧x - (a/b)*旧y哦！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能清晰看到扩展欧几里得算法的递归过程，还能直观理解特解的推导和缩放，让抽象的数学算法变得“可触摸”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
扩展欧几里得算法是数论中的核心工具，除了本题，还常用于解决同余方程、乘法逆元等问题。掌握它能帮助我们解决许多类似的数论题目。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 扩展欧几里得算法不仅能解不定方程，还能：
        1. 解线性同余方程（如ax ≡ c (mod b)）；
        2. 求乘法逆元（当a和p互质时，ax ≡ 1 (mod p)的解x）；
        3. 求解模意义下的分数（如(a/b) mod p = a * inv(b) mod p，其中inv(b)是b的逆元）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1082** - `同余方程`
          * 🗣️ **推荐理由**：这是扩展欧几里得算法的直接应用，要求解ax ≡ 1 (mod b)的最小正整数解（即乘法逆元），能巩固算法的核心逻辑。
    2.  **洛谷 P5656** - `【模板】二元一次不定方程 (exgcd)`
          * 🗣️ **推荐理由**：此题要求求解不定方程的所有解，并处理解的范围限制，能深化对通解形式的理解。
    3.  **洛谷 P4549** - `【模板】裴蜀定理`
          * 🗣️ **推荐理由**：此题考察裴蜀定理的应用，判断多个数的线性组合能表示的最小正整数，是对本题解存在性判断的扩展。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了学习扩展欧几里得算法的心得，这些经验对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者江户川·萝卜)**：“我刚开始学扩欧时，总是记不住x和y的更新公式，后来通过手动模拟递归过程（比如用a=20, b=32），才真正理解了每一步的推导。这让我意识到，动手模拟是掌握算法的关键。”
>
> **点评**：这位作者的经验非常实用！扩展欧几里得算法的递归过程较为抽象，手动模拟小例子（如a=6, b=4）能帮助我们直观理解x和y的更新逻辑。建议大家在学习时，用草稿纸画出递归树，标注每一层的a、b、x、y值，这对掌握算法原理很有帮助。

-----

<conclusion>
本次关于“Line”的C++解题分析就到这里。通过理解扩展欧几里得算法的原理、掌握代码模板，以及观看像素动画演示，相信大家对如何求解不定方程的整数解有了更深入的认识。记住，编程能力的提升需要不断练习和思考，快去尝试推荐的题目吧！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：138.23秒
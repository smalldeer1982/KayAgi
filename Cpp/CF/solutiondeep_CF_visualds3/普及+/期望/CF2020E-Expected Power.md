# 题目信息

# Expected Power

## 题目描述

给定一个长度为 $n$ 的整数数组 $a_1,a_2,\ldots,a_n$，以及一个数组 $p_1, p_2, \ldots, p_n$。

定义随机多重集 $S$（即 $S$ 可以包含相同元素），其构造方式如下：

- 初始时，$S$ 为空集。
- 对于每个 $i$ 从 $1$ 到 $n$，以概率 $\frac{p_i}{10^4}$ 将 $a_i$ 插入 $S$。注意，每个元素是否被插入是独立的。

记 $f(S)$ 为 $S$ 中所有元素的按位异或（[bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)）结果。请计算 $\mathbb{E}[(f(S))^2]$ 的期望值，并将答案对 $10^9 + 7$ 取模输出。

形式化地，设 $M = 10^9 + 7$。可以证明答案可以表示为最简分数 $\frac{p}{q}$，其中 $p$ 和 $q$ 是整数且 $q \not\equiv 0 \pmod{M}$。请输出满足 $0 \le x < M$ 且 $x \cdot q \equiv p \pmod{M}$ 的整数 $x$。

## 说明/提示

在第一个测试用例中，$a = [1, 2]$，每个元素被插入 $S$ 的概率为 $\frac{1}{2}$，因为 $p_1 = p_2 = 5000$，$\frac{p_i}{10^4} = \frac{1}{2}$。因此，$S$ 有 $4$ 种可能：

- $S = \varnothing$，此时 $f(S) = 0$，$(f(S))^2 = 0$。
- $S = \{1\}$，此时 $f(S) = 1$，$(f(S))^2 = 1$。
- $S = \{2\}$，此时 $f(S) = 2$，$(f(S))^2 = 4$。
- $S = \{1,2\}$，此时 $f(S) = 1 \oplus 2 = 3$，$(f(S))^2 = 9$。

因此，答案为 $0 \cdot \frac{1}{4} + 1 \cdot \frac{1}{4} + 4\cdot \frac{1}{4} + 9 \cdot \frac{1}{4} = \frac{14}{4} = \frac{7}{2} \equiv 500\,000\,007 \pmod{10^9 + 7}$。

在第二个测试用例中，$a = [1, 1]$，$a_1$ 以概率 $0.1$ 被插入 $S$，$a_2$ 以概率 $0.2$ 被插入 $S$。$S$ 有 $3$ 种可能：

- $S = \varnothing$，此时 $f(S) = 0$，$(f(S))^2 = 0$，概率为 $(1-0.1) \cdot (1-0.2) = 0.72$。
- $S = \{1\}$，此时 $f(S) = 1$，$(f(S))^2 = 1$，概率为 $(1-0.1) \cdot 0.2 + 0.1 \cdot (1-0.2) = 0.26$。
- $S = \{1, 1\}$，此时 $f(S) = 0$，$(f(S))^2 = 0$，概率为 $0.1 \cdot 0.2 = 0.02$。

因此，答案为 $0 \cdot 0.72 + 1 \cdot 0.26 + 0 \cdot 0.02 = 0.26 = \frac{26}{100} \equiv 820\,000\,006 \pmod{10^9 + 7}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
2
1 2
5000 5000
2
1 1
1000 2000
6
343 624 675 451 902 820
6536 5326 7648 2165 9430 5428
1
1
10000```

### 输出

```
500000007
820000006
280120536
1```

# AI分析结果


# 💡 Kay的C++算法解析：Expected Power 深入学习指南 💡  

<introduction>  
今天我们一起分析"Expected Power"这道C++编程题。题目要求计算随机集合异或和平方的期望，涉及概率论和位运算的高级应用。本指南将帮助你掌握核心的DP解法，理解状态转移的精妙设计，并通过像素动画直观感受算法流程。  
</introduction>  

## 1. 题目解读与核心算法识别  

✨ **本题主要考察**：`动态规划(概率DP)` 和 `位运算应用`  

🗣️ **初步分析**：  
> 解决本题的关键在于**概率动态规划**。想象你在玩一个像素地牢游戏：面前有n个宝箱（对应数组元素），每个宝箱有闪光碎片（数值a_i）和发光强度（概率p_i）。你要决定是否拾取碎片（独立概率），背包里的碎片会相互融合（异或操作），最终计算背包能量（异或平方）的期望值。  
> - 核心思路：利用值域有限（a_i ≤ 1023）的特点，用dp[j]存储异或和为j的概率  
> - 状态转移：`新状态 = 不拿碎片保持原状态×概率 + 拿碎片更新状态×概率`  
> - 可视化设计：将用像素宝箱动画展示碎片拾取过程，异或和变化用能量条动态显示，关键状态转移时触发粒子特效和8-bit音效  

---

## 2. 精选优质题解参考  

<eval_intro>  
从思路清晰度、代码规范性和算法效率等维度，我精选了2条评分≥5星的优质题解：  
</eval_intro>  

**题解一 (来源：Zeoykkk)**  
* **点评**：  
  思路清晰直击核心——指出值域受限的关键特性，给出两种DP解法（直接DP和按位DP）。代码规范体现在状态定义简洁（dp[i][j]表示前i个元素异或和为j的概率），转移方程推导严谨（p_i和1-p_i的概率分配）。算法采用O(1024×n)复杂度在题目限制下完全可行，且提供了按位DP的优化思路供拓展思考。实践价值极高，可直接用于竞赛场景。  

**题解二 (来源：__3E24AC7002AD9292__)**  
* **点评**：  
  提供完整可运行的代码实现，核心亮点是**滚动数组优化**：用两个一维数组交替计算，将空间复杂度从O(1024×n)降至O(1024)。代码规范表现在：1) 严格处理模运算避免溢出 2) 预计算逆元提升效率 3) 变量命名清晰（f[0]/f[1]区分状态）。边界处理严谨（初始化f[0][0]=1），是工业级实现的优秀范本。  

---

## 3. 核心难点辨析与解题策略  

<difficulty_intro>  
本题的挑战在于将概率期望问题转化为可计算的动态规划模型，以下是三大核心难点及突破策略：  
</difficulty_intro>  

1.  **难点1：期望的平方处理**  
    * **分析**：E[X²] ≠ (E[X])²！必须计算所有可能异或结果的概率分布，再对j²加权求和。优质解法通过dp数组精确追踪每个j值的概率  
    * 💡 **学习笔记**：平方期望需完整概率分布，不能简单用线性性质  

2.  **难点2：状态转移设计**  
    * **分析**：转移方程需同时考虑元素取舍概率和异或运算特性：  
      `dp[i][j] = p_i×dp[i-1][j⊕a_i] + (1-p_i)×dp[i-1][j]`  
      关键变量j（当前异或和）和a_i（新元素）的异或操作是核心  
    * 💡 **学习笔记**：异或的"自反性"（x⊕x=0）是状态合并的基础  

3.  **难点3：概率的模运算转换**  
    * **分析**：概率p_i/10000需转为模意义下的乘法逆元。核心技巧：  
      `实际概率 ≡ p_i × inv(10000) mod M`  
      其中inv(10000)是10000在模10⁹+7下的逆元  
    * 💡 **学习笔记**：模运算中除法需转换为逆元乘法  

### ✨ 解题技巧总结  
<summary_best_practices>  
综合优质题解，提炼三大实战技巧：  
</summary_best_practices>  
- **技巧1：值域压缩** - 利用异或和不超过1024的特性，将无限状态压缩为有限DP  
- **技巧2：滚动数组** - 用`f[0]`和`f[1]`交替存储状态，空间复杂度从O(nV)优化至O(V)  
- **技巧3：逆元预处理** - 提前计算10000的模逆元，避免重复计算提升效率  

---

## 4. C++核心代码实现赏析  

<code_intro_overall>  
以下是综合优质题解优化的通用实现，包含概率DP的核心逻辑和工程优化技巧：  
</code_intro_overall>  

**本题通用核心C++实现参考**  
* **说明**：综合Zeoykkk的状态设计思路和__3E24AC7002AD9292__的滚动数组优化  
* **完整核心代码**：  
```cpp  
#include <iostream>
#include <vector>
using namespace std;
const int MOD = 1e9 + 7;
const int MAX_V = 1024; // 值域上限

int qpow(int a, int b) { // 快速幂求逆元
    int res = 1;
    while (b) {
        if (b & 1) res = 1LL * res * a % MOD;
        a = 1LL * a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int inv10k = qpow(10000, MOD - 2); // 10000的逆元
    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        vector<int> a(n), p(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        for (int i = 0; i < n; i++) cin >> p[i];

        // 滚动数组：dp[0]为当前状态，dp[1]为新状态
        vector<vector<long long>> dp(2, vector<long long>(MAX_V));
        dp[0][0] = 1;
        int cur = 0; // 当前数组指针

        for (int i = 0; i < n; i++) {
            int nxt = cur ^ 1; // 切换数组
            fill(dp[nxt].begin(), dp[nxt].end(), 0); // 清空新状态

            for (int j = 0; j < MAX_V; j++) {
                if (!dp[cur][j]) continue;
                // 不选a[i]：概率乘(1-p_i)
                dp[nxt][j] = (dp[nxt][j] + dp[cur][j] * (10000 - p[i]) % MOD * inv10k) % MOD;
                // 选a[i]：概率乘p_i，状态更新为j^a[i]
                dp[nxt][j ^ a[i]] = (dp[nxt][j ^ a[i]] + dp[cur][j] * p[i] % MOD * inv10k) % MOD;
            }
            cur = nxt; // 更新当前状态
        }

        long long ans = 0;
        for (int j = 0; j < MAX_V; j++)
            ans = (ans + dp[cur][j] * (1LL * j * j % MOD)) % MOD;
        cout << (ans + MOD) % MOD << endl;
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. 预处理10000的模逆元，避免重复计算  
  2. 使用滚动数组dp[0]/dp[1]交替存储状态，大幅节省内存  
  3. 主循环中：先清空新状态，再根据当前状态计算不选/选两种分支  
  4. 最终遍历所有异或和j，累加概率×j²得到期望  

---
<code_intro_selected>  
现在深入剖析优质题解的核心代码片段：  
</code_intro_selected>  

**Zeoykkk题解片段**  
* **亮点**：状态转移方程数学表述精准  
* **核心代码片段**：  
  ```cpp
  dp[i][j] = p_i * dp[i-1][j^a_i] + (1-p_i) * dp[i-1][j]
  ```  
* **代码解读**：  
  > 这个简洁的方程是解题的核心！`dp[i][j]`像记录游戏存档，存储到第i个宝箱时背包能量为j的概率。当遇到新宝箱：  
  > - 路线A（不拾取）：概率`(1-p_i)`，能量保持j（继承`dp[i-1][j]`)  
  > - 路线B（拾取）：概率`p_i`，能量变为`j^a_i`（继承`dp[i-1][j^a_i]`)  
  > 注意异或运算的特性：拾取相同碎片两次会抵消能量（x^x=0）  
* 💡 **学习笔记**：DP状态转移本质是概率的加权合并  

**__3E24AC7002AD9292__题解片段**  
* **亮点**：滚动数组实现高效内存管理  
* **核心代码片段**：  
  ```cpp
  for (int j=0; j<=1023; j++) {
      f[1][j] = (f[1][j] + f[0][j]*(10000-p_i)%MOD*inv) % MOD;
      f[1][j] = (f[1][j] + f[0][j^a_i]*p_i%MOD*inv) % MOD;
  }
  swap(f[0], f[1]); // 滚动数组
  ```  
* **代码解读**：  
  > 这里展示了工业级的空间优化技巧！想象你有两个能量记录板：  
  > 1. `f[0]`记录当前状态（已处理前i-1个宝箱）  
  > 2. `f[1]`计算新状态（处理第i个宝箱后）  
  > 每处理完一个宝箱，就交换两个记录板的角色（swap操作），避免创建新数组。特别注意取模运算的时机：每次加法后立即取模，防止long long溢出  
* 💡 **学习笔记**：滚动数组将空间复杂度从O(nV)降为O(V)，是DP优化利器  

---

## 5. 算法可视化：像素动画演示  

<visualization_intro>  
为直观理解概率DP的执行过程，我设计了**「像素地牢：异或能量收集」**动画方案，采用8-bit复古风格呈现算法核心流程：  
</visualization_intro>  

* **主题设计**：  
  - **视觉风格**：FC红白机《塞尔达传说》像素风，宝箱/能量条等元素均为16×16像素  
  - **场景布局**：上部为宝箱队列（带概率光晕），中部为能量状态板（1024格像素柱状图），下部为控制台  

* **核心动画流程**：  
  1. **初始化**（8-bit音效：冒险开始旋律）  
     - 显示初始状态：能量0的概率为100%（柱状图仅索引0为满格）  
     - 第一个宝箱高亮闪烁，显示a_i和p_i值  

  2. **宝箱选择动画**（每步触发音效）  
     - **分支A（不拾取）**：宝箱变灰，蓝色箭头指向原状态栏，播放"跳过音效"（低音咚）  
     - **分支B（拾取）**：宝箱开启（粒子特效），红色箭头从当前j指向新状态j^a_i，播放"收集音效"（高音叮）  

  3. **状态合并演示**：  
     - 柱状图实时更新：两条路径的概率值像水流汇合，目标状态格闪烁  
     - 显示当前DP方程：`新概率 = 蓝箭头概率×p_keep + 红箭头概率×p_take`  

  4. **滚动数组可视化**：  
     - 用双屏设计模拟滚动数组：左屏（f[0]）为当前状态，右屏（f[1]）正在计算  
     - 当宝箱处理完毕时，右屏数据复制到左屏（像素块滑动动画）  

  5. **结果计算**：  
     - 最终柱状图显示所有异或和的概率分布  
     - 按j²加权求和时，高亮贡献最大的几个状态（如j=3的柱变金）  

* **交互控制**：  
  - **速度滑块**：调节宝箱处理速度（0.5x~4x）  
  - **单步模式**：手动触发每个宝箱的决策  
  - **AI演示**：自动播放完整流程（宝箱顺序开启，能量条动态波动）  

* **音效设计**：  
  - 关键操作：状态转移时触发不同音高（根据j^a_i的值决定）  
  - 结果反馈：计算结束时播放胜利旋律（能量值越高音阶越激昂）  

---

## 6. 拓展练习与相似问题思考  

<similar_problems_intro>  
掌握概率DP后，可挑战更多位运算与期望结合的题目：  
</similar_problems_intro>  

1.  **洛谷 P3211 [HNOI2011]XOR和路径**  
    * 🗣️ **推荐理由**：在图结构上求异或期望，需结合概率DP+高斯消元，是本题的进阶版  

2.  **洛谷 P2473 [SCOI2008]奖励关**  
    * 🗣️ **推荐理由**：概率DP经典题，引入状态压缩和最优决策，练习状态设计技巧  

3.  **洛谷 P2111 考分加成**  
    * 🗣️ **推荐理由**：将位运算（AND/OR）与期望结合，拓展异或外的位操作应用  

---

## 7. 学习心得与经验分享  

<insights_intro>  
在分析题解时，我发现这些经验特别值得借鉴：  
</insights_intro>  

> **来自__3E24AC7002AD9292__的调试经验**：  
> *"初始实现未及时取模导致溢出WA，建议每步加法后立即%MOD"*  
>   
> **Kay点评**：这是概率DP的常见陷阱！大数运算时：  
> 1) 用long long暂存中间结果  
> 2) 每步算术操作后取模  
> 3) 负数结果转正：(x+MOD)%MOD  

---

<conclusion>  
本次"Expected Power"的解析就到这里。关键记住：**有限值域是概率DP的突破口**，滚动数组是空间优化的利器。多尝试用可视化思维理解状态转移，下次遇到宝箱（问题）时你定能游刃有余！🚀  
</conclusion>

---
处理用时：248.88秒
# 题目信息

# Chladni Figure

## 题目描述

Inaka has a disc, the circumference of which is $ n $ units. The circumference is equally divided by $ n $ points numbered clockwise from $ 1 $ to $ n $ , such that points $ i $ and $ i + 1 $ ( $ 1 \leq i < n $ ) are adjacent, and so are points $ n $ and $ 1 $ .

There are $ m $ straight segments on the disc, the endpoints of which are all among the aforementioned $ n $ points.

Inaka wants to know if her image is rotationally symmetrical, i.e. if there is an integer $ k $ ( $ 1 \leq k < n $ ), such that if all segments are rotated clockwise around the center of the circle by $ k $ units, the new image will be the same as the original one.

## 说明/提示

The first two examples are illustrated below. Both images become the same as their respective original ones after a clockwise rotation of $ 120 $ degrees around the center.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1147B/e97ded58f64e835700251efbf078bd03afdc1691.png)

## 样例 #1

### 输入

```
12 6
1 3
3 7
5 7
7 11
9 11
11 3
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
9 6
4 5
5 6
7 8
8 9
1 2
2 3
```

### 输出

```
Yes
```

## 样例 #3

### 输入

```
10 3
1 2
3 2
7 2
```

### 输出

```
No
```

## 样例 #4

### 输入

```
10 2
1 6
2 7
```

### 输出

```
Yes
```

# AI分析结果

# 💡 Kay的C++算法解析：Chladni Figure 深入学习指南 💡

## 引言
今天我们要解决的问题是“Chladni Figure”——判断一个由圆环上的点和线段组成的图形是否旋转对称。这道题结合了数学中的**约数性质**和编程中的**模拟验证**，能帮我们理解“如何用数学规律减少计算量”的核心思路。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（约数枚举）+ 模拟（旋转验证）

🗣️ **初步分析**：
我们的目标是找一个**小于n的旋转步数k**，让图形旋转k个单位后和原图形完全重合。就像一串围成圈的彩色珠子，转3个位置后颜色排列和原来一样——这时候3就是合法的k。

### 核心算法的“魔法”：约数枚举
为什么要枚举n的**约数**？比如n=12，如果转3个能重合，那转6、9也能（因为3是12的约数）；但转5个不行（5和12互质，要转12次才会回到原点，中间不会重合）。所以**只有n的约数才可能是合法的k**，这一步能把枚举量从n降到√n（比如n=1e5，约数最多100个左右）。

### 验证旋转的关键：统一线段表示
线段的两个端点是无向的（比如1-3和3-1是同一条线段），所以我们要**统一线段的存储方式**——比如把端点按顺时针顺序排序（小的在前，大的在后），避免方向问题。然后，对于每个约数d，验证“每个点i旋转d后的点i+d（循环取模）的线段集合是否和i的完全一致”。

### 可视化设计思路
我们会做一个**8位像素风格的圆环动画**：
- 圆环上的点用彩色像素块表示（比如蓝色），线段用白色像素线连接；
- 枚举约数d时，用“滑动动画”展示整个圆环旋转d个单位（比如点1滑到点1+d的位置）；
- 逐个检查每个点的线段：如果旋转后的线段存在，用绿色高亮；如果不存在，用红色闪烁并停止动画；
- 成功找到合法d时，播放“胜利”音效（比如FC游戏的“叮~”），并在屏幕上显示“找到啦！”。


## 2. 精选优质题解参考

我从思路清晰度、代码可读性、算法效率等方面筛选了3份优质题解：

### 题解一：作者“是个汉子”（评分4.5星）
* **点评**：这份题解的思路最“直白”，完美贴合“约数枚举+模拟验证”的核心逻辑。作者用`vector<int> p[N]`存储每个点的线段（统一为顺时针方向的长度），并排序确保顺序一致。验证时，直接比较每个点旋转后的线段集合是否完全相同，中途发现不一致就立刻退出——这种“剪枝”让代码跑得更快。代码中的变量名（比如`d`存约数，`now`当前验证的约数）非常易懂，适合新手模仿。

### 题解二：作者“wizardMarshall”（评分4星）
* **点评**：作者用`map<pair<int,int>, bool>`存储线段，验证时**标记并删除**线段，确保每条线段都有且仅有一个对应——这个细节解决了“多条线段对应同一条”的问题（比如转d后，线段A对应线段B，线段B又对应线段A，这会导致误判）。代码中的`check`函数逻辑清晰，还特意处理了线段的方向（`swap(v1,v2)`），非常严谨。

### 题解三：作者“RegisterFault”（评分4.5星）
* **点评**：这是**最优解**！作者用“哈希表”存储线段的哈希值（把线段的两个端点转换成一个大整数），验证时直接查询哈希表——时间复杂度降到了O(m)（每个线段查一次）。代码中的`get`函数（计算哈希值）和`check`函数（验证旋转后的哈希值是否存在）非常简洁，适合追求效率的同学学习。


## 3. 核心难点辨析与解题策略

### 难点1：如何减少枚举量？
- **问题**：直接枚举1到n-1会超时（比如n=1e5，要枚举1e5次）。
- **解决**：枚举n的所有**真约数**（即小于n的约数）。因为只有约数才能让旋转后的图形重合。
- 💡 **学习笔记**：数学规律能帮我们“砍”掉大部分无用计算！

### 难点2：如何统一线段表示？
- **问题**：线段是无向的（比如1-3和3-1是同一条），直接存储会导致误判。
- **解决**：将线段的两个端点**按顺时针顺序排序**（比如小的在前，大的在后），或者计算“顺时针方向的长度”（比如1-3的长度是2，3-1的长度是n-2，取较小的那个）。
- 💡 **学习笔记**：统一数据格式是避免错误的关键！

### 难点3：如何高效验证旋转后的线段？
- **问题**：每次验证都遍历所有线段会很慢（比如m=1e5，枚举100次约数就是1e7次操作）。
- **解决**：用**有序结构**（比如排序后的vector、set）或**哈希表**（比如unordered_map）快速查询。有序结构的查询时间是O(log m)，哈希表是O(1)（平均情况）。
- 💡 **学习笔记**：选择合适的数据结构能让代码“飞”起来！

### ✨ 解题技巧总结
1. **数学规律优先**：遇到旋转、循环问题，先想“有没有数学规律能减少枚举量”（比如约数、周期）。
2. **数据统一格式**：无向线段、无序对要统一存储方式，避免方向问题。
3. **高效查询工具**：用set、map或哈希表快速查询元素是否存在，减少时间复杂度。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合了“是个汉子”和“RegisterFault”的思路，用排序后的vector存储线段，枚举约数验证，兼顾清晰性和效率。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10;
vector<int> p[N];  // p[i]存储点i的线段（顺时针长度，已排序）
int n, m;

// 检查旋转d个单位是否合法
bool check(int d) {
    for (int i = 1; i <= n; ++i) {
        int j = (i + d - 1) % n + 1;  // 点i旋转d后的点
        if (p[i].size() != p[j].size()) return false;
        for (int k = 0; k < p[i].size(); ++k) {
            if (p[i][k] != p[j][k]) return false;
        }
    }
    return true;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        if (u > v) swap(u, v);
        int len = v - u;  // 顺时针长度
        p[u].push_back(len);
        // 处理反向线段（v到u的顺时针长度是n - len）
        p[v].push_back(n - len);
    }
    // 排序每个点的线段，确保顺序一致
    for (int i = 1; i <= n; ++i) sort(p[i].begin(), p[i].end());
    
    // 枚举n的所有真约数
    bool ok = false;
    for (int d = 1; d <= n / 2; ++d) {
        if (n % d != 0) continue;
        if (check(d)) { ok = true; break; }
        int d2 = n / d;
        if (d2 < n && check(d2)) { ok = true; break; }
    }
    cout << (ok ? "Yes" : "No") << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取n和m，存储每条线段的顺时针长度（统一方向）。
  2. **排序线段**：每个点的线段排序，确保比较时顺序一致。
  3. **枚举约数**：遍历n的所有真约数，调用`check`函数验证旋转后的图形是否一致。
  4. **输出结果**：如果找到合法约数，输出Yes，否则输出No。

### 题解一（作者“是个汉子”）核心片段赏析
* **亮点**：用vector存储线段并排序，直接比较旋转后的线段集合，逻辑最直观。
* **核心代码片段**：
```cpp
for (int i = 1; i <= n; ++i) sort(p[i].begin(), p[i].end());
for (int i = 0; i < d.size(); ++i) {
    int now = d[i];
    flag = 1;
    for (int j = 1; j <= n; ++j) {
        int next_j = (j + now - 1) % n + 1;
        if (p[j].size() != p[next_j].size()) { flag = 0; break; }
        for (int k = 0; k < p[j].size(); ++k) {
            if (p[j][k] != p[next_j][k]) { flag = 0; break; }
        }
        if (!flag) break;
    }
    if (flag) break;
}
```
* **代码解读**：
  - 先排序每个点的线段，确保顺序一致。
  - 枚举每个约数`now`，验证每个点`j`旋转`now`后的点`next_j`的线段是否完全相同。
  - 中途发现不一致就立刻退出（剪枝），提高效率。
* 💡 **学习笔记**：排序是处理“无序集合比较”的常用技巧！

### 题解三（作者“RegisterFault”）核心片段赏析
* **亮点**：用哈希表存储线段的哈希值，查询时间O(1)，效率最高。
* **核心代码片段**：
```cpp
using PII = pair<int, int>;
using ULL = unsigned long long;
const ULL P = 998244353;
ULL get(PII x) { return (1ULL * x.first * P + 1ULL * x.second); }

unordered_map<ULL, bool> Map;
bool check(int x) {
    if (x == n) return false;
    for (int i = 1; i <= m; ++i) {
        PII rotated = {(p[i].first + x) % n, (p[i].second + x) % n};
        if (!Map.count(get(rotated))) return false;
    }
    return true;
}
```
* **代码解读**：
  - `get`函数将线段的两个端点转换成一个大整数（哈希值），避免存储pair。
  - `Map`存储所有线段的哈希值，验证时直接查询旋转后的哈希值是否存在。
  - 哈希表的查询时间是O(1)，比set的O(log m)快很多。
* 💡 **学习笔记**：哈希表是处理“快速查询”的神器！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画主题：像素圆环的“旋转大挑战”
我们用**FC红白机风格**（8位像素、复古色彩）制作动画，模拟圆环旋转和线段验证的过程。

### 设计思路
- **风格**：用16色调色板（比如蓝色点、白色线段、绿色高亮、红色错误），背景是黑色（像FC游戏的屏幕）。
- **交互**：提供“单步执行”“自动播放”“重置”按钮，速度滑块（从“慢”到“快”）。
- **音效**：旋转时播放“吱呀”的滑动声，验证通过时播放“叮~”，验证失败时播放“啪”的提示声。

### 动画步骤
1. **初始化**：屏幕中央显示一个蓝色像素圆环（n个点），线段用白色连接。下方是控制面板。
2. **枚举约数**：右侧显示当前枚举的约数d（比如“正在验证d=3”）。
3. **旋转动画**：圆环整体向右滑动d个单位（比如点1滑到点4的位置），伴随“吱呀”声。
4. **验证线段**：逐个点检查：
   - 当前点用黄色高亮，旋转后的点用橙色高亮。
   - 比较两个点的线段：如果一致，线段变绿色；如果不一致，线段变红色，动画停止并显示“错误”。
5. **胜利结局**：如果所有点验证通过，圆环闪烁绿色，播放“胜利”音效，屏幕显示“找到合法旋转步数d=3！”。

### 为什么这样设计？
- **像素风格**：复古游戏的感觉能让学习更有趣，减少“算法很枯燥”的感觉。
- **高亮与音效**：用颜色和声音强化“关键操作”，帮助记忆验证的核心逻辑。
- **交互控制**：单步执行让学习者能仔细观察每一步，自动播放能快速看整体流程。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的“约数枚举+模拟验证”思路可以解决**所有旋转对称问题**，比如：
1. 判断一个字符串是否是“循环字符串”（比如“ababab”旋转2个字符后还是自己）；
2. 判断一个数组是否存在“循环节”（比如[1,2,1,2]的循环节是2）；
3. 判断一个图形是否是“中心对称”（类似旋转180度后的对称，本质是约数n/2）。

### 洛谷练习推荐
1. **洛谷 P1390 循环小数**：求循环小数的循环节长度，需要枚举约数验证。
   - 🗣️ **推荐理由**：练习“约数枚举+验证”的经典题目，和本题思路完全一致。
2. **洛谷 P1072 Hankson的趣味题**：求满足条件的数，需要枚举约数并验证。
   - 🗣️ **推荐理由**：强化“用数学规律减少枚举量”的思维，难度适中。
3. **洛谷 P2676 [NOIP2015 普及组] 导弹拦截**：虽然是贪心题，但需要处理“循环”问题，能锻炼模拟能力。
   - 🗣️ **推荐理由**：练习“模拟验证”的细节处理，比如边界条件。


## 7. 学习心得与经验分享

### 来自题解的宝贵经验
- **“是个汉子”的剪枝技巧**：在验证约数时，中途发现不一致就立刻退出，能节省大量时间。这提醒我们：**不要做无用功，及时止损！**
- **“wizardMarshall”的线段标记**：用map存储线段并标记删除，避免“多条线段对应同一条”的错误。这告诉我们：**细节决定成败，要考虑所有可能的情况！**
- **“RegisterFault”的哈希优化**：用哈希表快速查询，让代码从“能过”变成“最优”。这说明：**选择合适的数据结构能大幅提升效率！**


## 结语
通过这道题，我们学会了用**数学规律（约数）减少枚举量**，用**统一格式（线段排序）避免错误**，用**高效数据结构（哈希表）提升速度**。记住：算法不是“硬算”，而是“巧算”——找到问题的规律，就能事半功倍！

下次我们再一起探索更多有趣的算法问题，加油！💪

---
处理用时：99.45秒
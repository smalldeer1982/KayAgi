# 题目信息

# Skyscrapers (hard version)

## 题目描述

这题是 [CF1313C1](https://www.luogu.com.cn/problem/CF1313C1) 的较难版本。这个版本中 $1 \leq n \leq 500000$。

Berland要起摩天大厦了。所有的摩天大厦都在高速公路附近建。发展商买了 $n$ 块地准备建 $n$ 栋摩天大厦，一块地一栋。

当规划一间摩天大厦的时候，建筑师要考虑一些条件。

第一，因为每栋摩天大厦有不同的用途，所以每栋摩天大厦都有自己的层数限制，也就是说，这栋摩天大厦的高度不能超过给定的值 $m_i$。

第二，根据城市的建设规则，一栋摩天大厦不能同时在左右有比它高的摩天大厦。

如果规范地表示，让我们把地编上一个编号从 $1$ 到 $n$。那么如果在第 $i$ 块地的摩天大厦有 $a_i$ 层，那么我们需要保证 $1 \le a_i \le m_i$。另外，这里不可以有整数 $j$ 和 $k$ 满足 $j < i < k$ 并且 $a_j > a_i < a_k$。第 $j, k$ 块地并不需要与第 $i$ 块地相邻。

发展商想要使得每块地上摩天大厦的楼层数之和最大。也请帮他找出在**任意一个**最优状况中每个摩天大厦的高度。也就是，要让建筑师考虑的条件都符合，而且要使得每块地上摩天大厦的楼层数之和最大。

## 样例 #1

### 输入

```
5
1 2 3 2 1```

### 输出

```
1 2 3 2 1```

## 样例 #2

### 输入

```
3
10 6 8```

### 输出

```
10 6 6```

# AI分析结果

# 💡 Kay的C++算法解析：Skyscrapers (hard version) 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：单调栈优化的贪心策略 + 前缀/后缀和推导  


🗣️ **初步分析**：  
解决这道题的关键，是要构造一个**单峰序列**——从左到右先不下降，到达某个“峰值”后不上升。每个元素的高度不能超过原数组的限制（`h_i ≤ m_i`），且总和要最大。  

可以把问题拆成3步：  
1. **找峰值**：每个位置都可能成为峰值，我们需要计算“以该位置为峰值时的最大总和”，然后选总和最大的那个位置作为最终峰值。  
2. **算贡献**：对于每个峰值位置`i`，左边的元素要形成“不下降”序列（且不超过`m_j`），右边要形成“不上升”序列。为了总和最大，左边每个位置的高度应取“从`i`往左的最小`m_j`”（比如峰值是3，左边的元素如果原`m_j`≥3，就取3；否则取原`m_j`），右边同理。  
3. **构造答案**：确定峰值后，从峰值向两边扩展，按“不下降/不上升”规则生成最终序列。  


### 核心算法：单调栈的作用  
直接计算每个位置的左右贡献是`O(n²)`的（比如遍历每个峰值，再逐个计算左右元素），但用**单调栈**可以把时间复杂度降到`O(n)`！  

单调栈的核心思想像“整理书架”：  
- 遍历数组时，维护一个**单调不下降**的栈（栈里的元素对应的`m`值越来越大）。  
- 当遇到一个新元素`m[i]`，如果栈顶元素的`m`值比它大，就弹出栈顶——因为这些元素无法成为`i`左边的“支撑点”（`i`的高度比它们小，左边的序列到`i`这里会下降，不符合“不下降”要求）。  
- 弹出后，栈顶的位置`j`就是`i`左边最后一个`m[j] ≤ m[i]`的位置。此时左边的总和`l[i]` = `l[j] + m[i]*(i-j)`（`j+1`到`i`的位置都取`m[i]`，因为它们的`m`值都≥`m[i]`）。  


### 可视化设计思路  
我会用**8位像素风**（类似FC红白机）设计动画，重点展示3个环节：  
1. **单调栈工作过程**：用像素块表示数组元素，栈用“堆叠的方块”展示。当处理`i`时，弹出比`m[i]`大的栈顶元素（方块向下消失），然后将`i`推入栈（方块向上出现），同时显示`l[i]`的计算过程（数字跳动）。  
2. **峰值选择**：遍历所有位置，用“闪烁的星星”标记当前计算的总和，找到最大总和时，峰值位置会“发光”并播放胜利音效。  
3. **构造答案**：从峰值向两边扩展，用“流动的颜色”标记每个位置的最终高度（比如从峰值往左，颜色逐渐变浅，代表高度递减）。  


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率三个维度筛选了3份优质题解，它们都用了单调栈优化，是本题的“标准解法”。
</eval_intro>


### 题解一：Fairicle（赞：11）  
* **点评**：这份题解是本题的“模板级实现”，思路直接、代码简洁。作者用单调栈分别计算了左边（`l[i]`）和右边（`r[i]`）的总和，然后遍历所有位置找最大总和的峰值。代码中的变量命名清晰（`l`、`r`分别代表左右贡献），边界处理严谨（比如右边计算时栈初始化为`n+1`），还特意提醒“开long long”——这是很多同学容易踩的坑！


### 题解二：gyh20（赞：2）  
* **点评**：作者的思路和Fairicle一致，但用了**reverse数组**简化右边的计算——把数组反转后，右边的“不上升”问题就变成了左边的“不下降”问题，直接复用单调栈逻辑！这种“对称转换”的技巧很巧妙，能减少代码重复，值得学习。


### 题解三：极寒神冰（赞：1）  
* **点评**：这份题解的代码是所有题解中最简洁的！作者没有用额外的变量名，直接用`stk`数组模拟栈，计算`L`和`R`数组的逻辑和Fairicle完全一致，但代码行数更少。这种“极简风格”适合追求代码效率的同学，但要注意变量的可读性。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“如何高效计算每个位置的左右贡献”，以下是3个核心难点及解决方法：
</difficulty_intro>


### 1. 难点1：如何快速找到“左边最后一个比当前元素小的位置”？  
* **分析**：直接遍历每个元素的左边是`O(n²)`，会超时。单调栈的作用就是“记住”之前的元素，当遇到更小的元素时，弹出比它大的元素——这些被弹出的元素再也不会成为后续元素的“支撑点”，因为它们比当前元素大，无法满足“不下降”要求。  
* 💡 **学习笔记**：单调栈是处理“找前后第一个比当前元素大/小的位置”的神器！


### 2. 难点2：如何计算每个位置的左右贡献？  
* **分析**：假设`j`是`i`左边最后一个`m[j] ≤ m[i]`的位置，那么`j+1`到`i`的位置都可以取`m[i]`（因为它们的`m`值都≥`m[i]`），所以左边总和`l[i] = l[j] + m[i]*(i-j)`（`l[j]`是`1`到`j`的总和，加上`j+1`到`i`的`m[i]`）。右边同理，只是方向相反。  
* 💡 **学习笔记**：前缀/后缀和的推导要结合“区间内的元素都取当前值”的特点，这样才能快速计算总和。


### 3. 难点3：如何构造最终的单峰序列？  
* **分析**：确定峰值`pos`后，从`pos`往左遍历，每个位置的高度取“当前值和左边已确定高度的最小值”（保证不下降）；从`pos`往右遍历，取“当前值和右边已确定高度的最小值”（保证不上升）。比如峰值是3，左边的元素如果原`m[j]`是5，就取3；如果是2，就取2。  
* 💡 **学习笔记**：构造序列时，要“从峰值向两边扩散”，逐步确定每个位置的高度，这样才能保证单调性。


### ✨ 解题技巧总结  
- **单调栈优化**：处理“找前后边界”问题的首选，时间复杂度`O(n)`。  
- **对称转换**：右边的“不上升”可以通过反转数组变成左边的“不下降”，减少代码重复。  
- **long long 必开**：总和可能很大（`n`是5e5，每个元素是1e9，总和会超过int的范围）。  


---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合Fairicle题解的通用核心实现，逻辑清晰、代码简洁，是本题的“标准写法”。
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：本代码用单调栈计算左右贡献，找峰值，最后构造答案，覆盖了所有核心逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
const int MAXN = 500010;

ll a[MAXN], l[MAXN], r[MAXN], s[MAXN];
int top;

inline ll read() {
    ll x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x;
}

int main() {
    int n = read();
    for (int i = 1; i <= n; ++i) a[i] = read();

    // 计算左边贡献l[i]
    top = 0;
    for (int i = 1; i <= n; ++i) {
        while (top && a[s[top]] > a[i]) top--;
        int now = s[top];
        l[i] = l[now] + a[i] * (i - now);
        s[++top] = i;
    }

    // 计算右边贡献r[i]
    top = 0;
    s[++top] = n + 1;
    for (int i = n; i >= 1; --i) {
        while (top && a[s[top]] > a[i]) top--;
        int now = s[top];
        r[i] = r[now] + a[i] * (now - i);
        s[++top] = i;
    }

    // 找最大总和的峰值位置
    ll max_sum = 0;
    int pos = 1;
    for (int i = 1; i <= n; ++i) {
        ll sum = l[i] + r[i] - a[i];
        if (sum > max_sum) {
            max_sum = sum;
            pos = i;
        }
    }

    // 构造答案
    ll pre = a[pos];
    for (int i = pos; i >= 1; --i) {
        if (a[i] > pre) a[i] = pre;
        pre = a[i];
    }
    pre = a[pos];
    for (int i = pos; i <= n; ++i) {
        if (a[i] > pre) a[i] = pre;
        pre = a[i];
    }

    // 输出结果
    for (int i = 1; i <= n; ++i) printf("%lld ", a[i]);
    return 0;
}
```  
* **代码解读概要**：  
  1. **输入处理**：用`read()`函数快速读取输入（避免`cin`超时）。  
  2. **计算左边贡献**：单调栈找每个元素左边最后一个比它小的位置，计算`l[i]`。  
  3. **计算右边贡献**：反转方向，用单调栈找每个元素右边最后一个比它小的位置，计算`r[i]`。  
  4. **找峰值**：遍历所有位置，计算总和`l[i]+r[i]-a[i]`（减去重复计算的峰值），找最大总和的位置。  
  5. **构造答案**：从峰值向两边扩展，保证序列单调。  


---

<code_intro_selected>
接下来分析3份优质题解的核心片段，看看它们的“亮点”在哪里。
</code_intro_selected>


### 题解一：Fairicle的单调栈循环  
* **亮点**：用`now`变量保存栈顶位置，计算`l[i]`和`r[i]`的逻辑直接。  
* **核心代码片段**：  
```cpp
// 计算左边贡献l[i]
for (int i = 1; i <= n; ++i) {
    while (top && a[s[top]] > a[i]) top--;
    int now = s[top];
    l[i] = l[now] + a[i] * (i - now);
    s[++top] = i;
}
```  
* **代码解读**：  
  - `while (top && a[s[top]] > a[i]) top--`：弹出比`a[i]`大的栈顶元素，因为它们无法成为`i`的左边支撑点。  
  - `now = s[top]`：栈顶的位置是`i`左边最后一个`a[now] ≤ a[i]`的位置。  
  - `l[i] = l[now] + a[i]*(i-now)`：`l[now]`是`1`到`now`的总和，`a[i]*(i-now)`是`now+1`到`i`的总和（都取`a[i]`）。  
* 💡 **学习笔记**：单调栈的循环结构要记牢——“弹出不符合条件的元素→取栈顶→计算贡献→压入当前元素”。


### 题解二：gyh20的reverse技巧  
* **亮点**：用`reverse`数组简化右边的计算，避免重复写单调栈逻辑。  
* **核心代码片段**：  
```cpp
// 计算右边贡献dp1[i]（原数组反转后计算）
reverse(a+1, a+n+1);
tp=0;
for (int i=1; i<=n; ++i) {
    lst[i]=0;
    while(a[s[tp]]>a[i]&&tp)--tp;
    lst[i]=s[tp];
    s[++tp]=i;
}
for (int i=1; i<=n; ++i) {
    dp1[i]=dp1[lst[i]] + (i-lst[i])*a[i];
}
reverse(dp1+1, dp1+n+1);
```  
* **代码解读**：  
  - 把原数组反转后，右边的“不上升”问题变成了左边的“不下降”问题，直接复用单调栈计算`dp1`（右边贡献）。  
  - 计算完后再反转`dp1`数组，恢复原顺序。  
* 💡 **学习笔记**：对称问题可以用“反转”技巧简化代码，减少出错概率。


### 题解三：极寒神冰的简洁代码  
* **亮点**：用`stk`数组直接模拟栈，没有额外变量，代码极简。  
* **核心代码片段**：  
```cpp
// 计算左边贡献L[i]
for (int i=1; i<=n; i++) {
    while(top&&a[stk[top]]>a[i]) top--;
    L[i] = L[stk[top]] + a[i]*(i-stk[top]);
    stk[++top] = i;
}
```  
* **代码解读**：  
  - 直接用`stk[top]`获取栈顶位置，没有额外的`now`变量，代码更简洁。  
  - 逻辑和Fairicle一致，但行数更少。  
* 💡 **学习笔记**：简洁的代码能提高可读性，但要注意变量的含义不能模糊。  


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解单调栈的工作过程，我设计了一个**8位像素风**的动画，结合复古游戏元素，让你“看”到算法的每一步！
</visualization_intro>


### 动画设计概览  
- **风格**：FC红白机风格（16色调色板，像素块大小2x2）。  
- **场景**：屏幕左侧是“数组区”（每个元素是一个像素块，颜色代表高度），右侧是“栈区”（堆叠的像素块，显示栈中的元素），底部是“控制面板”（单步、自动播放、重置按钮）。  


### 动画关键步骤  
1. **初始化**：  
   - 数组区显示输入的`m`数组（比如样例1的`1 2 3 2 1`，用不同颜色的像素块表示，高度越高颜色越亮）。  
   - 栈区为空，控制面板显示“开始”按钮。  
   - 播放8位风格的背景音乐（比如《超级马里奥》的开场音乐）。  

2. **单调栈计算左边贡献**：  
   - 处理第`i`个元素时，数组区的第`i`个像素块“闪烁”（提示当前处理的元素）。  
   - 栈区弹出比`m[i]`大的元素（像素块向下滑动并消失），伴随“啪”的音效。  
   - 计算`l[i]`时，数组区的`j+1`到`i`位置的像素块“变亮”（表示取`m[i]`的值），同时数字`l[i]`在旁边跳动，伴随“叮”的音效。  
   - 将`i`压入栈（像素块向上滑动并出现）。  

3. **找峰值**：  
   - 遍历所有位置时，每个位置的总和`l[i]+r[i]-a[i]`用“数字气泡”显示在数组区上方。  
   - 找到最大总和时，峰值位置的像素块“发光”（颜色变成黄色），伴随“叮咚”的胜利音效。  

4. **构造答案**：  
   - 从峰值向左边扩展，每个位置的像素块颜色逐渐变浅（表示高度递减），伴随“沙沙”的音效。  
   - 从峰值向右边扩展，同理。  
   - 最终序列显示完成后，播放“通关”音效（比如《塞尔达传说》的胜利音乐）。  


### 交互设计  
- **单步执行**：点击“下一步”按钮，动画执行一步，方便仔细观察。  
- **自动播放**：点击“自动”按钮，动画按每秒2步的速度播放，可调节速度滑块（1~5步/秒）。  
- **重置**：点击“重置”按钮，回到初始状态，重新播放。  


<visualization_conclusion>
通过这个动画，你可以清晰地看到单调栈如何“整理”元素，如何计算左右贡献，以及如何构造最终的单峰序列。复古的风格和音效会让学习过程更有趣！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
单调栈是一个非常实用的算法技巧，除了本题，还能解决很多“找前后边界”的问题。以下是几个相似的练习：
</similar_problems_intro>


### 通用思路迁移  
- **问题1**：求直方图中最大矩形的面积（LeetCode 84）——用单调栈找每个柱子左右第一个比它矮的柱子。  
- **问题2**：求数组中每个元素的“下一个更大元素”（LeetCode 496）——用单调栈维护递减序列。  
- **问题3**：求最长递增子序列的长度（LeetCode 300）——用单调栈优化动态规划（O(nlogn)）。  


### 洛谷练习推荐  
1. **洛谷 P1912** -  [护花](https://www.luogu.com.cn/problem/P1912)  
   * 🗣️ **推荐理由**：这道题需要用单调栈找每个位置的左右边界，计算最大覆盖面积，和本题的核心逻辑一致，能巩固单调栈的用法。  

2. **洛谷 P2698** -  [花盆](https://www.luogu.com.cn/problem/P2698)  
   * 🗣️ **推荐理由**：本题需要维护滑动窗口中的最大值和最小值，单调栈是解决这类问题的常用方法，能拓展你的思路。  

3. **洛谷 P3243** -  [[HNOI2015] 菜肴制作](https://www.luogu.com.cn/problem/P3243)  
   * 🗣️ **推荐理由**：这道题用单调栈维护拓扑排序的顺序，能让你理解单调栈在图论问题中的应用。  


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解中作者分享的“踩坑经验”，对你很有帮助：
</insights_intro>

> **参考经验 (来自Fairicle)**：“一开始没开long long，结果总和溢出了，调试了好久才发现！”  
> **点评**：这是很多同学都会犯的错误——当`n`是5e5，每个元素是1e9时，总和会达到`5e14`，远超int的范围（`2e9`）。所以**只要涉及大数计算，一定要开long long**！  


---

<conclusion>
本次关于“Skyscrapers (hard version)”的分析就到这里。这道题的核心是“单调栈优化贪心”，关键是要理解如何用单调栈快速计算左右贡献。记住：单调栈是处理“找前后边界”问题的神器，多练几道题就能掌握！  

下次我们再一起探索更有趣的算法问题，加油！💪
</conclusion>

---
处理用时：99.37秒
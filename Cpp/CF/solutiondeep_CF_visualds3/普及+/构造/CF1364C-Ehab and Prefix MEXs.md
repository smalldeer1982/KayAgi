# 题目信息

# Ehab and Prefix MEXs

## 题目描述

给出一个长度为 $n$ 的序列 $A$，你需要找到一个长度为 $n$ 的序列 $B$，满足 $A_i=mex(\{B_1,B_2,\dots,B_i\})$。

其中 $mex$ 函数的结果是最小的未出现在集合中的非负整数。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
0 1 2```

## 样例 #2

### 输入

```
4
0 0 0 2```

### 输出

```
1 3 4 0```

## 样例 #3

### 输入

```
3
1 1 3```

### 输出

```
0 2 1```

# AI分析结果

---
# 💡 Kay的C++算法解析：Ehab and Prefix MEXs 深入学习指南 💡

<introduction>
今天我们来一起拆解「Ehab and Prefix MEXs」这道**构造类贪心题**。它的核心是「按规则搭积木」——给定每个位置的「MEX要求」，我们要一步步构造出满足条件的序列。这道题能帮你理解「贪心策略如何解决构造问题」，还能强化对MEX性质的理解，Let's go！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：构造类问题 + 贪心策略

🗣️ **初步分析**：
解决这道题，关键要抓住两个核心：  
1. **MEX的本质**：前i项的MEX是a_i → 前i项必须包含**0到a_i-1的所有数**（否则最小未出现的数会比a_i小）；  
2. **贪心的思路**：先填「必须要有的数」（0到a_i-1），剩下的位置填「不影响MEX的大数」（比如1e6，因为a_i≤1e5，大数不会出现在0~a_i-1中）。  

打个比方：构造B序列像「拼拼图」——先把边缘的「必要碎片」（0到a_i-1）拼好，剩下的空白处随便填「不挡视线的拼图」（大数）就行。  

**核心算法流程**：  
- 遍历每个位置i，先检查a_i是否超过i（如果a_i>i，前i项最多有i个数，不可能包含0到a_i-1，直接无解）；  
- 用指针`now`找**最早未填充的位置**，把0到a_i-1的数填进去（确保留有余地，后面不会没位置）；  
- 最后把没填的位置都填1e6。  

**可视化设计思路**：  
我会用「8位像素风」做动画——左边是A数组（红色像素块显示每个a_i），中间是B数组（灰色代表未填，绿色代表填了必要数字，蓝色代表填了大数），右边显示当前MEX。每填一个数，对应像素块闪烁+「叮」的音效；填大数时是「啪」的音效；完成时播放「胜利」旋律。还能单步执行看每一步的变化～


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了3份优质题解，覆盖了不同的构造思路，帮你多视角理解问题～
</eval_intro>

**题解一：H6_6Q（赞5）**
* **点评**：这份题解像「说明书」一样清晰！作者先明确「无解条件」（a_i>i），再用「指针+贪心」填充必要数字——用`now`指针找最早未填的位置，把0到a_i-1的数填进去，剩下的位置填1e6。代码变量名超友好（`now`是未填的最小位置，`num`是当前要填的数字），边界处理也很严谨（比如先检查a_i>i再处理）。最棒的是**留有余地**的思路——把必要数字填在最早的位置，后面的位置还能填大数，不会卡壳！

**题解二：AlicX（赞1）**
* **点评**：这份题解用`set`玩出了「极简主义」！作者先收集所有「没在A中出现的数」（存在set里），然后每个位置取set的最小元素填充——这样既保证填的数不重复，又不会影响MEX。填完后把a_i加回set（如果a_i的次数用完了），确保后面能填a_i。代码只有20行左右，却把构造逻辑讲得明明白白，**数据结构的巧妙运用**是最大亮点！

**题解三：b6e0_（赞3）**
* **点评**：作者挖到了「MEX的隐藏性质」！他发现：如果a_i≠a_{i-1}，那b_i必须是a_{i-1}（因为MEX从a_{i-1}变成a_i，说明a_{i-1}刚被加入序列）。这个性质直接简化了构造——不同a_i的位置填a_{i-1}，相同a_i的位置填未出现的数。**对性质的深刻理解**是这份题解的灵魂，能帮你跳过「试错」直接抓重点！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
构造题的难点往往是「不知道从哪下手」。结合优质题解，我总结了3个核心问题和解决办法，帮你「按图索骥」！
</difficulty_intro>

1. **关键点1：为什么前i项必须包含0到a_i-1？**  
   * **分析**：MEX是「最小未出现的非负整数」。如果前i项缺了0到a_i-1中的任何一个数，比如缺k（k < a_i），那MEX会是k，而不是a_i。所以**必须先填0到a_i-1的数**！  
   * 💡 **学习笔记**：MEX的要求=「前i项必须包含0~a_i-1」，这是构造的「地基」。

2. **关键点2：必要数字该填在哪？**  
   * **分析**：如果把必要数字填在后面的位置，前面的位置可能没数填，导致MEX不满足。比如a_1=1，必须填0——如果把0填在位置3，那前1项的MEX会是0，不是1！所以要用**指针找最早未填的位置**（比如H6_6Q的`now`指针），把必要数字填在最前面的空位，留后面的位置填大数。  
   * 💡 **学习笔记**：必要数字要「往前填」，留余地给后面的位置。

3. **关键点3：剩余位置填什么？**  
   * **分析**：剩余位置的数不能影响MEX——也就是说，不能是0到a_i-1中的数。所以填**比a_i大的数**（比如1e6）最安全，因为a_i≤1e5，1e6肯定不在0~a_i-1里！  
   * 💡 **学习笔记**：剩余位置填「大数」，相当于「占位符」，不影响MEX。

### ✨ 解题技巧总结
- **先判无解**：a_i>i直接输出-1，避免做无用功；  
- **贪心填必要数**：用指针找最早空位，填0到a_i-1；  
- **剩余填大数**：1e6是万能占位符；  
- **性质辅助**：a_i变化时，b_i填a_{i-1}（b6e0_的技巧）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「通用核心代码」——综合了H6_6Q的思路，结构清晰，覆盖所有情况，适合入门学习～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自H6_6Q的题解，是「贪心构造」的典型实现，逻辑完整且易读。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;

  const int N = 1e5 + 5;
  int a[N], b[N]; // a是输入序列，b是要构造的序列

  int read() {
      int ans = 0;
      char c = getchar();
      while (c < '0' || c > '9') c = getchar();
      while (c >= '0' && c <= '9') ans = ans * 10 + c - '0', c = getchar();
      return ans;
  }

  int main() {
      memset(b, -1, sizeof(b)); // b初始化为-1（未填充）
      int n = read();
      for (int i = 1; i <= n; ++i) a[i] = read();

      int num = 0; // 当前要填的数字（从0开始）
      int now = 1; // 未填充的最小位置
      for (int i = 1; i <= n; ++i) {
          if (a[i] > i) { // 无解条件
              printf("-1\n");
              return 0;
          }
          // 填充0到a[i]-1的数字
          for (; num <= a[i] - 1; ++num) {
              if (b[i] == -1) { // 如果当前位置未填，填在这里
                  b[i] = num;
              } else { // 否则找最早未填的位置
                  while (b[now] != -1) now++;
                  b[now] = num;
              }
          }
          num = a[i]; // 下一个要填的数字是a[i]
      }

      // 输出结果：未填充的位置填1e6
      for (int i = 1; i <= n; ++i) {
          if (b[i] == -1) printf("1000000 ");
          else printf("%d ", b[i]);
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 初始化b数组为-1（标记未填充）；  
  2. 遍历每个i，先检查a_i>i（无解）；  
  3. 用循环填充0到a_i-1的数字：优先填当前i的位置，否则用`now`找最早空位；  
  4. 最后输出b数组，未填的位置填1e6。


<code_intro_selected>
接下来看3份优质题解的「核心片段」，感受不同思路的巧妙之处～
</code_intro_selected>

**题解一：H6_6Q（指针填充）**
* **亮点**：用指针`now`找最早空位，确保必要数字「往前填」。
* **核心代码片段**：
  ```cpp
  int num = 0, now = 1;
  for (int i = 1; i <= n; ++i) {
      for (; num <= a[i] - 1; ++num) {
          if (b[i] == -1) b[i] = num;
          else {
              while (b[now] != -1) now++; // 找最早空位
              b[now] = num;
          }
      }
      num = a[i];
  }
  ```
* **代码解读**：  
  - `num`是当前要填的数字（从0开始）；  
  - 循环填充0到a[i]-1：如果当前i的位置未填，直接填num；否则用`now`找最早的空位（比如位置2空着，就填2）；  
  - 填完后`num`更新为a[i]，下一轮填更大的数。  
* 💡 **学习笔记**：指针`now`是「留有余地」的关键——把必要数字填在最早的位置，后面的位置还能填大数。

**题解二：AlicX（set简化填充）**
* **亮点**：用set存「可填的数」，自动排序+快速取最小元素。
* **核心代码片段**：
  ```cpp
  set<int> s;
  for (int i = 0; i <= n + 1; ++i) if (!mp[i]) s.insert(i); // 收集未出现的数
  for (int i = 1; i <= n; ++i) {
      b[i] = *s.begin(); s.erase(s.begin()); // 取最小的可填数
      mp[a[i]]--;
      if (!mp[a[i]]) s.insert(a[i]); // a[i]用完了，加入可填集合
  }
  ```
* **代码解读**：  
  - `mp`数组记录a中每个数的出现次数；  
  - `s`存所有「未在a中出现的数」（初始时是0、1、2…）；  
  - 每个位置取s的最小元素（*s.begin()）填充，然后把a[i]加回s（如果a[i]的次数用完了）——这样后面可以填a[i]。  
* 💡 **学习笔记**：set的「自动排序+快速取最小」特性，能简化「找可填数」的逻辑，代码更简洁！

**题解三：b6e0_（利用性质2）**
* **亮点**：用「a_i变化时填a_{i-1}」的性质，直接构造。
* **核心代码片段**：
  ```cpp
  for (int i = 2; i <= n; ++i) {
      if (a[i] != a[i-1]) { // a_i变化，填a_{i-1}
          b[i] = a[i-1];
      } else { // a_i不变，填未出现的数
          b[i] = num;
          num++;
      }
  }
  ```
* **代码解读**：  
  - 当a_i从a_{i-1}变大时，说明a_{i-1}刚被加入序列——所以b[i]必须是a_{i-1}；  
  - 当a_i不变时，填未出现的数（num从0开始递增）。  
* 💡 **学习笔记**：深刻理解MEX的性质，能跳过「试错」直接构造，效率更高！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「看得到」算法的每一步，我设计了一个**8位像素风动画**——像玩FC游戏一样学构造！
</visualization_intro>

### 🎮 动画设计方案
* **主题**：像素探险家「小K」填充B数组，满足每个位置的MEX要求。
* **风格**：FC红白机风格（8位像素、16色调色板），背景是复古的方格纸，按钮是像素化的「开始/单步/重置」。
* **核心演示内容**：
  1. **初始化**：  
     - 左边显示A数组（红色像素块，每个块显示a_i的值）；  
     - 中间显示B数组（灰色像素块，代表未填充）；  
     - 右边显示「当前MEX」（黄色数字）；  
     - 底部控制面板：「开始」「单步」「重置」按钮，速度滑块（1x~5x）。
  2. **单步执行**（以样例1为例：输入3，a=[1,2,3]）：  
     - **i=1**：检查a_1=1≤1，开始填充0（num=0）。b[1]变成绿色，显示0，右边MEX变成1（符合a_1），伴随「叮」的音效。  
     - **i=2**：检查a_2=2≤2，填充1（num=1）。b[2]变成绿色，显示1，右边MEX变成2（符合a_2），「叮」音效。  
     - **i=3**：检查a_3=3≤3，填充2（num=2）。b[3]变成绿色，显示2，右边MEX变成3（符合a_3），「叮」音效。  
     - **完成**：B数组全绿，播放「胜利」旋律，屏幕弹出「完成！」的像素字。
  3. **剩余位置填充**（以样例2为例：输入4，a=[0,0,0,2]）：  
     - i=1：a_1=0≤1，不需要填0（因为MEX是0，前1项不能有0），b[1]填1e6（蓝色），「啪」音效。  
     - i=2：a_2=0≤2，b[2]填1e6（蓝色），「啪」音效。  
     - i=3：a_3=0≤3，b[3]填1e6（蓝色），「啪」音效。  
     - i=4：a_4=2≤4，填充0和1（num=0→1）。b[4]填0（绿色），b[1]填1（绿色），右边MEX变成2（符合a_4），「叮」音效。
* **交互设计**：
  - **单步执行**：点击「单步」按钮，走一步，显示当前操作的文字提示（比如「填充0到b[1]，MEX变成1！」）；  
  - **自动播放**：点击「开始」，动画按速度滑块的速度自动执行；  
  - **重置**：点击「重置」，回到初始状态，重新开始。
* **音效设计**：
  - 填充必要数字（绿色）：「叮」（高频率短音）；  
  - 填充大数（蓝色）：「啪」（低频率短音）；  
  - 完成：「嘟嘟嘟～」（上扬旋律）；  
  - 无解：「哔——」（长音）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
构造类贪心题的「套路」是「先抓必要条件，再补无关部分」。学会这个思路，你能解决很多类似问题！
</similar_problems_intro>

### 🔍 通用思路迁移
「贪心构造」的核心是：**先满足每个位置的「硬约束」，再用「软约束」填充剩余部分**。比如：
- 构造「前缀和递增」的序列：先保证前i项和递增，再填剩余数；  
- 构造「每个位置是偶数」的序列：先填偶数，再填奇数。

### 📚 洛谷练习推荐
1. **洛谷 P7771（CF1512D）** - 构造序列满足MEX要求  
   🗣️ **推荐理由**：和本题一样是「MEX构造题」，但需要更灵活的贪心策略，能巩固你对MEX的理解！
2. **洛谷 P5657（CSP-J2019 划分）** - 构造最大总和的划分  
   🗣️ **推荐理由**：构造题的经典题，需要「贪心划分」满足条件，锻炼你「找必要约束」的能力！
3. **洛谷 P3376（模板 网络最大流）** - 最大流算法  
   🗣️ **推荐理由**：虽然是图论题，但「增广路算法」也是贪心思路——找能增加流量的路径，再优化，能拓展你的贪心应用场景！
4. **洛谷 P2422（良好的感觉）** - MEX与子段和  
   🗣️ **推荐理由**：结合MEX和子段和的问题，能加深你对MEX性质的理解，还能学「单调栈」的用法！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解的「作者心得」是「踩坑后的经验」，比代码更珍贵！我摘录了3条，帮你避坑～
</insights_intro>

> **参考经验（来自H6_6Q）**：「我一开始没考虑a_i>i的情况，提交后WA了好几次。后来想通了——前i项最多有i个数，不可能包含0到a_i-1（a_i>i时），所以直接返回-1！」  
> **点评**：「先判无解」是构造题的「保命技巧」！很多错误都是因为没处理边界条件，比如a_i>i、a数组不单调（题目保证单调，但自己写代码时要注意）。

> **参考经验（来自AlicX）**：「用set存可填的数，比用数组找更方便！因为set自动排序，直接取begin()就是最小的数，不用自己遍历找。」  
> **点评**：数据结构能「简化逻辑」！比如set的「自动排序+快速取最小」特性，能帮你少写很多循环，代码更简洁。

> **参考经验（来自b6e0_）**：「我一开始没发现a_i变化时填a_{i-1}的性质，写了很多冗余代码。后来打表看样例，发现这个规律，代码瞬间简洁了！」  
> **点评**：「打表找规律」是构造题的「神器」！很多隐藏性质都能通过样例发现，比如样例1中a从1→2→3，b是0→1→2（a_{i-1}），样例3中a从1→1→3，b是0→2→1（a_2=1不变，填2；a_3=3变，填1）。


<conclusion>
构造题像「搭积木」——先搭必要的「地基」（0到a_i-1），再填剩余的「砖块」（大数）。这道题的核心是「贪心策略」和「MEX性质」，学会这两个，你能解决很多类似的构造问题！  

记住：**构造题的关键是「理解约束条件」，然后「按优先级填充」**。多练几道题，你会越来越熟练～下次我们再一起拆更难的构造题！💪
</conclusion>

---
处理用时：151.40秒
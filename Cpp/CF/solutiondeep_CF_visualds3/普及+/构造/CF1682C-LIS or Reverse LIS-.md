# 题目信息

# LIS or Reverse LIS?

## 题目描述

You are given an array $ a $ of $ n $ positive integers.

Let $ \text{LIS}(a) $ denote the length of [longest strictly increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of $ a $ . For example,

- $ \text{LIS}([2, \underline{1}, 1, \underline{3}]) $ = $ 2 $ .
- $ \text{LIS}([\underline{3}, \underline{5}, \underline{10}, \underline{20}]) $ = $ 4 $ .
- $ \text{LIS}([3, \underline{1}, \underline{2}, \underline{4}]) $ = $ 3 $ .

We define array $ a' $ as the array obtained after reversing the array $ a $ i.e. $ a' = [a_n, a_{n-1}, \ldots , a_1] $ .

The beauty of array $ a $ is defined as $ min(\text{LIS}(a),\text{LIS}(a')) $ .

Your task is to determine the maximum possible beauty of the array $ a $ if you can rearrange the array $ a $ arbitrarily.

## 说明/提示

In the first test case, $ a $ = $ [6, 6, 6] $ and $ a' $ = $ [6, 6, 6] $ . $ \text{LIS}(a) = \text{LIS}(a') $ = $ 1 $ . Hence the beauty is $ min(1, 1) = 1 $ .

In the second test case, $ a $ can be rearranged to $ [2, 5, 4, 5, 4, 2] $ . Then $ a' $ = $ [2, 4, 5, 4, 5, 2] $ . $ \text{LIS}(a) = \text{LIS}(a') = 3 $ . Hence the beauty is $ 3 $ and it can be shown that this is the maximum possible beauty.

In the third test case, $ a $ can be rearranged to $ [1, 2, 3, 2] $ . Then $ a' $ = $ [2, 3, 2, 1] $ . $ \text{LIS}(a) = 3 $ , $ \text{LIS}(a') = 2 $ . Hence the beauty is $ min(3, 2) = 2 $ and it can be shown that $ 2 $ is the maximum possible beauty.

## 样例 #1

### 输入

```
3
3
6 6 6
6
2 5 4 5 2 4
4
1 3 2 2```

### 输出

```
1
3
2```

# AI分析结果

# 💡 Kay的C++算法解析：LIS or Reverse LIS? 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（计数与构造）

🗣️ **初步分析**：  
解决这道题的关键，是**构造一个“单峰序列”**——把数组排成中间大、左边严格上升、右边严格下降的形状（比如`2,5,4,5,4,2`）。这样一来：  
- 原数组的LIS（最长严格上升子序列）就是“左边上升序列 + 中间最大值”；  
- 反转后的LIS（原数组的LDS，最长严格下降子序列）就是“右边下降序列 + 中间最大值”。  

我们的目标是让这两个长度的**最小值尽可能大**——而单峰结构能让两者最平衡。  

接下来要解决的问题是：**每个数字能为这个平衡的长度贡献多少？**  
- 若一个数字出现≥2次：可以在左边放一个、右边放一个，同时贡献给LIS和LDS，所以**贡献1**；  
- 若一个数字只出现1次：只能放在左边或右边中的一边，两个这样的数字才能凑出1的总贡献（比如左边放A、右边放B，LIS和LDS各加1）。  

最终答案就是：**出现≥2次的数字种类数 + (出现1次的数字种类数 + 1) // 2**（加1是为了处理奇数的情况，比如1个独数时，能多贡献1）。  

**可视化设计思路**：  
我们会用8位像素风展示单峰序列的构造过程——用红色像素块表示出现≥2次的数字（左右各放一个），蓝色表示出现1次的数字（两两分组放两边），黄色表示中间最大值。动画会高亮当前处理的数字，用“叮”声提示贡献+1，“嗒”声提示独数统计，最后用绿色/紫色箭头标注LIS/LDS的长度，直观展示min值的计算。


## 2. 精选优质题解参考

### 题解一（作者：_Ad_Astra_）  
**点评**：  
这份题解的思路最“直击本质”——直接通过统计`cnt1`（出现≥2次的数字种类数）和`cnt2`（出现1次的数字种类数），用公式`cnt1 + (cnt2+1)/2`计算答案。代码用`map`处理大值域（`a_i≤1e9`），避免了桶排序的TLE问题；多测时清空`map`的细节也很严谨。**亮点**：用数学公式跳过了“构造具体序列”的步骤，效率极高。


### 题解二（作者：IceKylin）  
**点评**：  
题解清晰解释了“单峰序列”的构造逻辑，并且将问题转化为**“保留每个数字最多2次”**——总保留数`ans`就是`2*cnt1 + cnt2`，再用`(ans+1)/2`得到答案（和之前的公式等价）。代码简洁，`map`的使用很规范，**亮点**：把“贡献计算”转化为“保留数统计”，更直观。


### 题解三（作者：World_Creater）  
**点评**：  
这份题解用**排序**代替`map`统计——排序后遍历数组，每个数字最多保留2次（避免重复贡献），最后计算保留数`cnt`的`(cnt+1)/2`。这种方法不需要额外的数据结构，时间复杂度同样是`O(nlogn)`，**亮点**：用排序简化了大值域的统计问题，代码更轻量化。


## 3. 核心难点辨析与解题策略

### 1. 关键点1：为什么要构造单峰序列？  
**分析**：  
要最大化`min(LIS, LDS)`，必须让两者的长度尽可能接近。单峰序列的左边是上升、右边是下降，LIS和LDS的长度都等于“半长 + 中间最大值”，刚好平衡。  
**学习笔记**：构造“平衡结构”是解决“极值最小值”问题的常用思路。


### 2. 关键点2：如何计算每个数字的贡献？  
**分析**：  
- 出现≥2次的数字：左右各放一个，同时贡献给LIS和LDS，所以+1；  
- 出现1次的数字：只能放一边，两个才能凑出1的总贡献（比如左边放A、右边放B，LIS和LDS各加1）。  
**学习笔记**：分类讨论“重复次数”是处理计数问题的核心。


### 3. 关键点3：如何处理大值域的统计？  
**分析**：  
题目中`a_i≤1e9`，不能用桶排序。此时可以用`map`（插入/查询`O(logn)`）或**排序后遍历**（`O(nlogn)`），两种方法都能高效统计每个数字的出现次数。  
**学习笔记**：大值域问题优先用`map`或排序，避免空间浪费。


### ✨ 解题技巧总结  
- **结构优先**：先想清楚最优结构（单峰序列），再计算贡献；  
- **分类统计**：按数字出现次数分两类，分别计算贡献；  
- **工具选择**：大值域用`map`或排序，小值域用桶。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了多份优质题解的思路，用`map`统计次数，公式直接计算答案，清晰高效。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    ios::sync_with_stdio(false); // 加速输入输出
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        map<int, int> cnt_map;
        
        for (int i = 0; i < n; ++i) {
            int x;
            cin >> x;
            cnt_map[x]++; // 统计每个数字的出现次数
        }
        
        int cnt1 = 0, cnt2 = 0;
        for (auto& [num, freq] : cnt_map) {
            if (freq >= 2) cnt1++; // 出现≥2次的数字种类数
            else cnt2++; // 出现1次的数字种类数
        }
        
        cout << cnt1 + (cnt2 + 1) / 2 << '\n';
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. 读取多组测试数据；  
  2. 用`map`统计每个数字的出现次数；  
  3. 遍历`map`，统计`cnt1`和`cnt2`；  
  4. 用公式计算并输出答案。


### 题解一核心片段赏析（作者：_Ad_Astra_）  
* **亮点**：直接通过`cnt1`和`cnt2`计算答案，跳过构造过程。  
* **核心代码片段**：  
```cpp
for (auto it = mp.begin(); it != mp.end(); it++) {
    int x = it->sec;
    if (x >= 2) cnt1++;
    else cnt2++;
}
cout << cnt1 + (cnt2 + 1)/2 << endl;
```  
* **代码解读**：  
  遍历`map`中的每个数字，统计`cnt1`（≥2次）和`cnt2`（1次），然后用公式计算答案。**为什么加1？**比如`cnt2=1`时，`(1+1)/2=1`，刚好把这个独数放到中间，贡献1；`cnt2=2`时，`(2+1)/2=1`，两个独数各放一边，贡献1。  
* 💡 **学习笔记**：公式中的`+1`是处理奇数的关键，要记住这个小技巧！


### 题解三核心片段赏析（作者：World_Creater）  
* **亮点**：用排序代替`map`，简化统计。  
* **核心代码片段**：  
```cpp
sort(a+1, a+1+n);
for (int i = 1; i <= n; i++) {
    if (i<3 || a[i]!=a[i-1] || a[i]!=a[i-2])
        cnt++; // 每个数字最多保留2次
}
cout << (cnt+1)/2 << "\n";
```  
* **代码解读**：  
  排序后遍历数组，当当前数字和前两个不同时，才计数（避免保留超过2次）。比如`a[i]=5`，前两个也是5，就不计数，否则计数。最后`(cnt+1)/2`就是答案。  
* 💡 **学习笔记**：排序可以将相同数字聚集，方便统计“最多保留2次”，适合不想用`map`的场景。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题  
**像素探险家的“单峰序列”寻宝之旅**——探险家要把数字“摆成单峰”，收集每个数字的贡献，最终找到最大的`min(LIS, LDS)`。


### 🎨 设计思路  
用**8位红白机风格**（低像素、高饱和度颜色），让动画充满复古游戏感。通过**颜色编码**和**音效提示**强化记忆：  
- 红色像素块：出现≥2次的数字（贡献1，“叮”声）；  
- 蓝色像素块：出现1次的数字（贡献0.5，“嗒”声）；  
- 黄色像素块：中间最大值（贡献1，“嗡”声）；  
- 绿色箭头：LIS的长度（左边上升序列）；  
- 紫色箭头：LDS的长度（右边下降序列）。


### 🕹️ 动画帧步骤与交互  
1. **初始化**：  
   - 屏幕显示10x10的像素网格（中间位置高亮），上方是“数字池”（待处理的数字），下方是控制面板（开始/暂停、单步、重置、速度滑块）。  
   - 播放8位风格的轻快BGM（比如《超级马里奥》的背景音）。  

2. **输入数字**：  
   - 数字从“数字池”中落下，点击数字后，`map`统计次数（红色/蓝色块闪烁）。  

3. **统计贡献**：  
   - 遍历`map`，红色块闪烁并“叮”一声，`cnt1`+1；蓝色块闪烁并“嗒”一声，`cnt2`+1。  

4. **构造单峰序列**：  
   - 中间位置放入黄色块（最大值）；  
   - 红色块成对出现：左边放一个，右边放一个；  
   - 蓝色块两两分组：左边放一个，右边放一个，剩余一个放在黄色块旁边。  

5. **计算LIS/LDS**：  
   - 绿色箭头从左到右扫描左边的上升序列，显示长度；  
   - 紫色箭头从右到左扫描右边的下降序列，显示长度；  
   - 两个长度的`min`值用闪烁的黄色数字显示，伴随“胜利音效”（比如《魂斗罗》的通关声）。  

6. **交互控制**：  
   - 单步执行：点击“单步”按钮，每一步展示一个数字的处理；  
   - 自动播放：拖动速度滑块调整播放速度（慢/中/快）；  
   - 重置：回到初始状态，重新开始。


### 📝 旁白提示  
- “红色数字出现≥2次，可以在左右各放一个，贡献1！”  
- “蓝色数字出现1次，两个凑一个贡献哦～”  
- “中间的黄色数字是最大值，同时属于LIS和LDS！”  


## 6. 拓展练习与相似问题思考

### 🧩 通用思路迁移  
本题的核心思路（构造平衡结构、分类统计贡献）可以迁移到以下场景：  
1. **导弹拦截问题**（P1020）：需要构造最优拦截序列，让上升和下降的导弹数平衡；  
2. **友好城市问题**（P2782）：将问题转化为LIS，构造最长的“不交叉”城市对；  
3. **递增子序列变形**（P3902）：处理严格递增的条件，统计贡献。


### 📚 洛谷练习推荐  
1. **洛谷 P1020 导弹拦截**  
   🗣️ **推荐理由**：这道题是LIS和LDS的经典题，需要构造最优拦截序列，和本题的“单峰结构”思路一致。  
2. **洛谷 P2782 友好城市**  
   🗣️ **推荐理由**：需要将问题转化为LIS，锻炼“构造最优结构”的能力，和本题的核心思想一脉相承。  
3. **洛谷 P3902 递增**  
   🗣️ **推荐理由**：考察严格递增的LIS变形，需要处理“重复元素”的贡献，和本题的“分类统计”技巧类似。


## 7. 学习心得与经验分享 (若有)  
- **_Ad_Astra_的经验**：“用`map`处理大值域时，一定要记得多测清空！”——提醒我们注意多组数据的初始化问题；  
- **IceKylin的经验**：“把问题转化为‘保留数统计’，能让思路更直观”——有时候换个角度看问题，代码会更简单；  
- **World_Creater的经验**：“排序可以简化统计，避免用复杂的数据结构”——适合不想写`map`的初学者。


## 🎯 总结  
这道题的核心是**“构造单峰序列+分类统计贡献”**——先想清楚最优结构，再计算每个数字的贡献，最后用公式得到答案。通过这道题，我们学会了：  
1. 如何构造平衡结构最大化min值；  
2. 如何分类统计数字的贡献；  
3. 如何处理大值域的统计问题。  

记住：编程的本质是“解决问题”，而不是“写复杂的代码”——简单、清晰的思路往往是最有效的！💪

---
处理用时：110.17秒
# 题目信息

# Non Prime Tree

## 题目描述

给你一棵拥有 $n$ 个顶点的树。

你的任务是构造一个包含 $n$ 个不同整数的数组，这些整数从 $1$ 到 $2 \cdot n$ 分别取值。同时要求对于树中的任意一条边 $u_i \leftrightarrow v_i$，对应的数组元素差值 $|a_{u_i} - a_{v_i}|$ 不是质数。

请你找出任意一个符合以上条件的数组，如果不存在这样的数组，请输出 $-1$。

## 说明/提示

如下图所示的答案中，用对应数组 $a$ 的元素替代了顶点编号：

第一组数据的树结构 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/d6a56c20ebd42ea20ac170d596c01c0583a1b831.png)  
第二组数据的树结构 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040D/8328682bcf4d0da5fcbe8de4a0054b43d22d093e.png)

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
5
1 2
2 3
2 4
3 5
7
1 2
1 3
2 4
3 5
3 6
3 7```

### 输出

```
2 10 1 6 5 
8 7 12 1 4 6 3```

# AI分析结果

# 💡 Kay的C++算法解析：Non Prime Tree 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论构造（结合数学奇偶性技巧）  

🗣️ **初步分析**：  
解决“Non Prime Tree”的关键，在于**用构造性方法满足相邻节点差值非质数**。我们可以利用一个小技巧：**除了2以外，所有偶数的差值都是合数**（比如4-2=2是质数，但6-4=2也是质数？不对，等一下——哦不，偶数减偶数的结果是偶数，而大于2的偶数都是合数！比如6-2=4（合数），8-4=4（合数），但2-0=2（质数）。哦对，我们需要避免的是**相邻节点的差值为2**。所以，只要让相邻节点的差值是**大于2的偶数**，或者**奇数（1或合数）**，就能满足条件。  

那怎么构造这样的序列呢？题解们给出了一个通用思路：**将树黑白染色**（类似国际象棋棋盘），然后给黑点和白点分别赋值**连续的偶数**（比如黑点用2、4、6…，白点用8、10、12…）。这样，相邻节点的差值是偶数，只要**不出现差值为2**的情况，就能满足条件。如果出现这种情况（比如黑点和白点的最后一个数相邻），就调整这两个数的位置（放到不相邻的节点），或者处理特殊结构（如菊花图）。  

**核心算法流程**：  
1. 对树进行黑白染色（DFS或BFS），分成黑点集合和白点集合。  
2. 检查是否存在**不相邻的黑点和白点**：如果有，将它们的赋值设为连续的偶数（比如黑点的最后一个和白点的第一个），避免差值为2；如果没有（说明是菊花图），则给中心节点赋值2，周围节点赋值1、6、8…（这样中心与周围的差值是1或偶数，都不是质数）。  

**可视化设计思路**：  
用8位像素风格展示树结构（节点是方块，边是线段）。黑白染色时，节点变成黑色或白色；赋值时，节点上显示数值，相邻节点的差值用线段颜色表示（绿色=非质数，红色=质数）。动画会一步步展示染色→赋值→检查差值的过程，比如“叮”的音效表示赋值成功，“滴”的音效表示差值检查通过，红色线段会闪烁并提示“需要调整”。  


## 2. 精选优质题解参考

### 题解一（作者：lfxxx，赞5）  
* **点评**：  
  这份题解的思路**非常清晰**，用“黑白染色+特殊结构处理”完美解决了问题。作者首先通过DFS将树分成黑白两部分，然后判断是否存在不相邻的异色点——如果有，就将连续偶数赋值给这两个点，避免差值为2；如果没有（菊花图），则给中心节点赋值2，周围节点赋值1、6、8…（中心与周围的差值是1或偶数，都不是质数）。代码结构规范，变量命名（如`vec[cl]`存储染色后的节点）清晰，边界处理（如菊花图的判断）严谨。**亮点**：将“避免差值为2”转化为“寻找不相邻的异色点”，这是解决问题的关键。  

### 题解二（作者：naromil，赞5）  
* **点评**：  
  这份题解的思路**非常直接**，用“深度分类+分层赋值”构造序列。作者通过两次DFS求树的深度（第一次找最长链的端点，第二次求每个节点的深度），然后根据深度分层：深度为奇数的节点赋值连续偶数，深度为偶数的节点赋值更大的连续偶数。对于深度较小的情况（如深度=3或4），调整赋值顺序，避免差值为2。代码逻辑简洁，**亮点**：用深度分层的方法，将问题转化为“按层赋值”，容易理解和实现。  

### 题解三（作者：bsdsdb，赞4）  
* **点评**：  
  这份题解的思路**非常巧妙**，用“贪心+归纳证明”构造序列。作者通过DFS遍历树，给每个节点赋值递增的数，同时调整下一个数的大小，确保与父节点的差值非质数（比如如果当前数与父节点的差值是质数，就递增到下一个数）。作者还给出了归纳证明，证明赋值不会超过2n。**亮点**：贪心策略的正确性证明，让我们相信这种方法是可行的。  


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何保证相邻节点差值非质数？  
* **分析**：  
  我们可以利用“偶数差除了2都是合数”的性质，给节点赋值**连续的偶数**。这样，相邻节点的差值是偶数，只要不出现差值为2，就能满足条件。比如，黑点赋值2、4、6…，白点赋值8、10、12…，相邻节点的差值是6（8-2=6，合数）、4（10-6=4，合数）等。  

* 💡 **学习笔记**：偶数差是解决“非质数”问题的关键，记住“大于2的偶数都是合数”！  

### 2. 难点2：如何处理差值为2的情况？  
* **分析**：  
  如果黑点的最后一个数（比如6）和白点的第一个数（比如8）相邻，差值为2（质数），就需要调整这两个数的位置。比如，找到一个不相邻的黑点和白点，将6赋值给黑点，8赋值给白点，这样它们的差值是2，但不相邻，不影响条件。如果没有这样的点（菊花图），就给中心节点赋值2，周围节点赋值1、6、8…（中心与周围的差值是1或偶数，都不是质数）。  

* 💡 **学习笔记**：特殊结构（如菊花图）需要特殊处理，不要忽略边界情况！  

### 3. 难点3：如何构造不超过2n的序列？  
* **分析**：  
  题解中的方法（如黑白染色、深度分层、贪心）都通过**控制赋值顺序**，保证每个节点的赋值不超过2n。比如，黑白染色时，黑点和白点的数量之和是n，所以赋值的偶数是2、4、…、2n，刚好覆盖所有节点。贪心方法通过归纳证明，每个节点的赋值不会超过2n。  

* 💡 **学习笔记**：构造序列时，要注意“不重复”和“范围限制”，用数学方法证明正确性会更放心！  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（综合lfxxx题解）  
* **说明**：  
  本代码综合了lfxxx题解的思路，用黑白染色处理一般情况，用菊花图处理特殊情况，逻辑清晰，易于理解。  

* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int maxn = 2e5+114;
  int n;
  vector<int> E[maxn];
  int ans[maxn];
  vector<int> vec[2]; // 0: 黑点，1: 白点
  int col[maxn];

  void dfs(int u, int cl, int lst) {
      vec[cl].push_back(u);
      col[u] = cl;
      for (int v : E[u]) {
          if (v != lst) dfs(v, cl^1, u);
      }
  }

  void work() {
      cin >> n;
      for (int i=1; i<n; i++) {
          int u, v;
          cin >> u >> v;
          E[u].push_back(v);
          E[v].push_back(u);
      }
      // 判断是否是菊花图（有节点度数为n-1）
      for (int i=1; i<=n; i++) {
          if (E[i].size() == n-1) {
              ans[i] = 2; // 中心节点赋值2
              ans[E[i][0]] = 1; // 第一个子节点赋值1（差值1，非质数）
              for (int j=1; j<E[i].size(); j++) {
                  ans[E[i][j]] = (j+2)*2; // 其他子节点赋值6、8…（差值为偶数，非质数）
              }
              for (int j=1; j<=n; j++) cout << ans[j] << ' ';
              cout << '\n';
              for (int j=1; j<=n; j++) E[j].clear();
              vec[0].clear(); vec[1].clear();
              return;
          }
      }
      // 一般情况：黑白染色
      dfs(1, 0, 0);
      // 找不相邻的黑点和白点（比如叶子节点的祖父节点）
      int s = -1, t = -1;
      for (int u=1; u<=n; u++) {
          if (E[u].size() == 1) { // 叶子节点
              int p = E[u][0]; // 父节点
              if (E[p].size() >= 2) { // 父节点有多个子节点
                  int gp = (E[p][0] == u) ? E[p][1] : E[p][0]; // 祖父节点
                  s = u; // 叶子节点（黑点）
                  t = gp; // 祖父节点（白点）
                  break;
              }
          }
      }
      // 赋值：黑点（除了s）→ s → t → 白点（除了t）
      int tot = 0;
      for (int u : vec[0]) {
          if (u != s) ans[u] = ++tot * 2;
      }
      ans[s] = ++tot * 2;
      ans[t] = ++tot * 2;
      for (int u : vec[1]) {
          if (u != t) ans[u] = ++tot * 2;
      }
      // 输出结果
      for (int j=1; j<=n; j++) cout << ans[j] << ' ';
      cout << '\n';
      // 清空数据
      for (int j=1; j<=n; j++) E[j].clear();
      vec[0].clear(); vec[1].clear();
  }

  int main() {
      ios::sync_with_stdio(0);
      cin.tie(0), cout.tie(0);
      int t;
      cin >> t;
      while (t--) work();
      return 0;
  }
  ```

* **代码解读概要**：  
  代码分为两部分：**菊花图处理**和**一般情况处理**。  
  1. 菊花图处理：找到中心节点（度数为n-1），给中心赋值2，第一个子节点赋值1（差值1），其他子节点赋值6、8…（差值为偶数）。  
  2. 一般情况处理：用DFS黑白染色，找到不相邻的黑点（叶子）和白点（祖父），给黑点赋值连续偶数，白点赋值更大的连续偶数，避免差值为2。  


### 题解一（lfxxx）核心代码片段赏析  
* **亮点**：黑白染色+菊花图判断  
* **核心代码片段**：  
  ```cpp
  void dfs(int u, int cl, int lst) {
      vec[cl].push_back(u);
      col[u] = cl;
      for (int v : E[u]) {
          if (v != lst) dfs(v, cl^1, u);
      }
  }
  ```
* **代码解读**：  
  这段代码用DFS对树进行黑白染色。`vec[cl]`存储染色后的节点（`cl=0`是黑点，`cl=1`是白点），`col[u]`记录节点`u`的颜色。递归时，子节点的颜色是父节点的颜色取反（`cl^1`），这样相邻节点颜色不同。  
* 💡 **学习笔记**：黑白染色是处理树结构问题的常用技巧，比如二分图判断、构造相邻节点不同属性的序列。  


### 题解二（naromil）核心代码片段赏析  
* **亮点**：深度分类+分层赋值  
* **核心代码片段**：  
  ```cpp
  void dfs(int u, int b) {
      rot = u;
      dep[u] = dep[b] + 1;
      for (auto v : c[u]) {
          if (b == v) continue;
          dfs(v, u);
      }
  }
  ```
* **代码解读**：  
  这段代码用DFS求树的深度。`rot`记录最长链的端点（第一次DFS找端点，第二次DFS求深度），`dep[u]`记录节点`u`的深度。通过两次DFS，我们可以得到每个节点的深度，然后按深度分层赋值。  
* 💡 **学习笔记**：求树的深度是处理树结构问题的基础，比如分层遍历、最长链计算。  


### 题解三（bsdsdb）核心代码片段赏析  
* **亮点**：贪心+调整赋值  
* **核心代码片段**：  
  ```cpp
  void srh(ll x, ll pr) {
      ans[x] = st++;
      for (ll i : e[x]) {
          if (i == pr) continue;
          while (st - ans[x] != 1 && (((st - ans[x]) & 1) || st - ans[x] == 2)) {
              ++st;
          }
          srh(i, x);
      }
  }
  ```
* **代码解读**：  
  这段代码用贪心策略给节点赋值。`st`是当前要赋值的数，`ans[x]`记录节点`x`的赋值。对于子节点`i`，如果当前`st`与父节点`x`的差值是质数（比如2或奇数），就递增`st`直到差值非质数（比如1或大于2的偶数）。  
* 💡 **学习笔记**：贪心策略的关键是“每次选择当前最优的选项”，但需要证明其正确性（比如不会超过2n）。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《像素树的号码牌游戏》  
（仿照FC游戏《冒险岛》的风格，用8位像素块展示树结构，节点是彩色方块，边是线段。）  

### 核心演示内容：  
1. **初始化**：屏幕显示一棵像素树（节点是灰色方块，边是黑色线段），底部有“开始”“单步”“重置”按钮，以及速度滑块。  
2. **黑白染色**：节点逐渐变成黑色或白色（比如黑点是蓝色，白点是红色），边保持黑色。染色时，每个节点会闪烁一下，伴随“叮”的音效。  
3. **赋值过程**：节点上显示数值（比如黑点显示2、4、6…，白点显示8、10、12…），相邻节点的差值用线段颜色表示（绿色=非质数，红色=质数）。如果差值是质数（比如2），线段会闪烁红色，并提示“需要调整”。  
4. **调整顺序**：找到不相邻的黑点和白点，将它们的数值交换（比如将6从黑点移到不相邻的白点，8从白点移到不相邻的黑点），差值线段变成绿色，伴随“滴”的音效。  
5. **完成**：所有节点赋值完成，屏幕显示“成功！”，伴随胜利音效（比如《超级马里奥》的通关音乐）。  

### 交互设计：  
- **单步执行**：点击“单步”按钮，动画执行一步（比如染色一个节点，赋值一个节点）。  
- **自动播放**：点击“开始”按钮，动画自动执行，速度可以通过滑块调整（从慢到快）。  
- **重置**：点击“重置”按钮，动画回到初始状态。  
- **音效**：染色时“叮”，赋值时“嗒”，差值检查通过时“滴”，失败时“ buzzer”，完成时胜利音乐。  

### 设计思路：  
用像素风格营造复古游戏氛围，让学习者在“玩游戏”的过程中理解算法。比如，染色过程像“给树穿衣服”，赋值过程像“贴号码牌”，差值检查像“检查号码是否正确”。音效和动画效果能强化记忆，让学习者更容易记住关键步骤。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
本题的核心技巧（黑白染色、奇偶性构造、贪心）可以迁移到以下场景：  
1. **二分图构造**：比如将图分成两部分，使得相邻节点属于不同部分（黑白染色）。  
2. **非质数差值问题**：比如给数组赋值，使得相邻元素的差值非质数（用偶数或奇数构造）。  
3. **树结构构造**：比如给树的节点赋值，满足某种条件（如相邻节点的和为偶数）。  

### 练习推荐（洛谷）：  
1. **洛谷 P1330 [CQOI2005] 二叉树的染色**  
   🗣️ **推荐理由**：这道题需要将二叉树的节点染色，使得相邻节点颜色不同，是黑白染色的基础练习。  
2. **洛谷 P2052 [NOI2011] 道路修建**  
   🗣️ **推荐理由**：这道题需要处理树的边权，构造满足条件的边权序列，是构造性算法的拓展练习。  
3. **洛谷 P3384 [模板] 树链剖分**  
   🗣️ **推荐理由**：这道题需要处理树的路径查询，是树结构问题的进阶练习，有助于加深对树结构的理解。  


## 7. 学习心得与经验分享（若有）

### 参考经验（来自lfxxx）：  
“我在解决这个问题时，最初想到用偶数赋值，但不知道如何避免差值为2。后来想到黑白染色，将树分成两部分，这样相邻节点的差值是偶数，只要找到不相邻的异色点，就能避免差值为2。这让我意识到，**构造题要结合图的结构和数学性质**。”  

### 点评：  
lfxxx的经验很有价值。构造题往往需要“找规律+利用结构”，比如本题中的“偶数差值”（数学性质）和“黑白染色”（图结构）结合，就能解决问题。**提示**：遇到构造题时，先想“有没有特殊性质可以利用”（比如奇偶性、质数性质），再想“如何用图的结构（如染色、深度）来实现”。  


## 结语  
本次关于“Non Prime Tree”的C++解题分析就到这里。希望这份学习指南能帮助大家理解**图论构造**和**奇偶性技巧**的应用。记住，构造题的关键是“找规律+利用结构”，多做练习就能掌握！下次我们再一起探索新的编程挑战！💪

---
处理用时：206.65秒
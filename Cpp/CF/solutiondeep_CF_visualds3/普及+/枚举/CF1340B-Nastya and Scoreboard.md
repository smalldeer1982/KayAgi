# 题目信息

# Nastya and Scoreboard

## 题目描述

Denis, after buying flowers and sweets (you will learn about this story in the next task), went to a date with Nastya to ask her to become a couple. Now, they are sitting in the cafe and finally... Denis asks her to be together, but ... Nastya doesn't give any answer.

The poor boy was very upset because of that. He was so sad that he punched some kind of scoreboard with numbers. The numbers are displayed in the same way as on an electronic clock: each digit position consists of $ 7 $ segments, which can be turned on or off to display different numbers. The picture shows how all $ 10 $ decimal digits are displayed:

  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1340B/f1bf3e3ee1e01404b7c2f218b7a8b65c071d6967.png)After the punch, some segments stopped working, that is, some segments might stop glowing if they glowed earlier. But Denis remembered how many sticks were glowing and how many are glowing now. Denis broke exactly $ k $ segments and he knows which sticks are working now. Denis came up with the question: what is the maximum possible number that can appear on the board if you turn on exactly $ k $ sticks (which are off now)?

It is allowed that the number includes leading zeros.

## 说明/提示

In the first test, we are obliged to include all $ 7 $ sticks and get one $ 8 $ digit on the scoreboard.

In the second test, we have sticks turned on so that units are formed. For $ 5 $ of additionally included sticks, you can get the numbers $ 07 $ , $ 18 $ , $ 34 $ , $ 43 $ , $ 70 $ , $ 79 $ , $ 81 $ and $ 97 $ , of which we choose the maximum — $ 97 $ .

In the third test, it is impossible to turn on exactly $ 5 $ sticks so that a sequence of numbers appears on the scoreboard.

## 样例 #1

### 输入

```
1 7
0000000```

### 输出

```
8```

## 样例 #2

### 输入

```
2 5
0010010
0010010```

### 输出

```
97```

## 样例 #3

### 输入

```
3 5
0100001
1001001
1010011```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Nastya and Scoreboard 深入学习指南 💡

<introduction>
今天我们来一起分析“Nastya and Scoreboard”这道C++编程题。这道题需要结合动态规划（DP）和贪心策略，解决如何用恰好k个点亮的灯管构造最大数字的问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）与贪心策略的综合应用

🗣️ **初步分析**：
解决这道题的关键在于两步：首先用动态规划判断是否存在可行解，并记录状态；然后用贪心策略从高位到低位选择最大的可能数字。  
动态规划（DP）就像“提前探路”，帮我们确定从第i位到第n位使用j个灯管时是否能构成有效数字；而贪心策略则像“选最大的糖果”，在每一步都尽可能选最大的数字，确保最终结果最大。  

在本题中，DP的核心是定义状态`dp[i][j]`表示处理到第i位时，剩余j个灯管是否能构成有效数字（从第i位到第n位）。贪心则在确定可行的前提下，从高位开始优先选9，再依次往下试，确保每一步选的数字最大。  

核心难点在于：  
- 如何预处理每个数字模块能转换为0-9中哪些数字，以及需要点亮的灯管数（可能涉及冲突判断，比如原模块亮的灯管不能关闭）。  
- DP状态的转移逻辑（如何从后往前推导可行性）。  
- 贪心选择时如何结合DP的结果，确保每一步选的数字既大又可行。  

可视化设计上，我们可以用8位像素风格展示每个数字模块的7个灯管（用不同颜色表示亮/灭），动态规划的状态转移用“进度条”或“点亮路径”动画表示，贪心选择时用闪烁的箭头指向当前选的最大数字，配合“叮”的音效提示关键步骤。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下3份优质题解（评分均≥4星）：
</eval_intro>

**题解一：来源：juicyyou**  
* **点评**：此题解思路清晰，代码结构完整，对DP状态的定义和转移解释明确。代码中`cal`函数预处理每个模块转换为0-9所需的灯管数，`dp`数组从后往前填充，最后通过贪心构造答案。变量命名如`dp[i][l]`直观（i表示当前位，l表示剩余灯管数），边界处理严谨（如`memset(dp, -1, sizeof(dp))`初始化无效状态）。亮点在于将DP的可行性判断与贪心选择结合，代码可直接用于竞赛，实践价值高。

**题解二：来源：ZigZagKmp**  
* **点评**：此题解采用位运算优化（将灯管状态转换为二进制数），简化了冲突判断和灯管数计算（通过`nm`数组存储0-9的二进制表示，`siz`函数快速计算需要点亮的灯管数）。DP状态转移逻辑简洁（`dp[i][j] |= dp[i+1][j-cst[i][k]]`），贪心部分从9到0遍历确保选最大数字。代码高效且可读性强，位运算的应用是值得学习的亮点。

**题解三：来源：Fairicle**  
* **点评**：此题解预处理部分清晰（用`vector<pair<int, int>>`存储每个模块可转换的数字及对应灯管数），DP状态转移通过遍历每个可能的数字实现。贪心构造答案时，直接从高位选最大可行数字，逻辑直白。代码注释明确，适合初学者理解。亮点是将预处理和DP分离，结构模块化，易于调试。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：预处理每个模块可转换的数字及所需灯管数**  
    * **分析**：每个模块的当前灯管状态（输入的01串）必须满足：若原灯管是亮的（输入为1），则目标数字对应的灯管也必须是亮的（否则无法关闭已亮的灯管）。优质题解通常用函数（如`cal`或直接位运算）遍历0-9，检查是否满足条件，并计算需要点亮的灯管数（原灭但目标亮的灯管数）。  
    * 💡 **学习笔记**：预处理是算法的基础，需仔细处理冲突条件（原亮的灯管不能关闭）。

2.  **关键点2：动态规划状态的定义与转移**  
    * **分析**：状态`dp[i][j]`表示处理到第i位时，剩余j个灯管是否能构成有效数字（从i到n位）。转移时，遍历第i位可能的数字k，若该数字需要w个灯管，且`j >= w`，则`dp[i][j]`的状态由`dp[i+1][j-w]`决定（即后面的位是否能用完剩余的灯管）。  
    * 💡 **学习笔记**：DP的核心是“后效性”处理，从后往前推导能避免前面的选择影响后面的可行性。

3.  **关键点3：贪心选择最大数字**  
    * **分析**：在确定`dp[1][k]`可行后，从高位到低位依次选择最大的数字。对于第i位，从9到0遍历可能的数字k，若该数字需要w个灯管，且`dp[i+1][k-w]`可行，则选择该数字，并更新剩余灯管数。  
    * 💡 **学习笔记**：贪心的关键是“每一步选最大”，但必须结合DP的可行性判断，否则可能导致后续无法构造有效数字。

### ✨ 解题技巧总结
- **预处理优先**：先处理每个模块的可能数字及所需灯管数，避免重复计算。  
- **反向DP**：从最后一位向前推导状态，确保每一步的选择不影响后续的可行性。  
- **贪心结合DP**：贪心选最大数字时，必须检查DP状态是否可行，确保后续位能用完剩余灯管。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个综合了多个优质题解思路的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了juicyyou和ZigZagKmp的思路，采用位运算优化预处理，DP判断可行性，贪心构造最大数字，逻辑清晰且高效。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 2005;
    const int MAXK = 2005;

    // 0-9的灯管状态（二进制表示，1表示亮）
    int num_mask[10] = {0b1110111, 0b0010010, 0b1011101, 0b1011011, 
                        0b0111010, 0b1101011, 0b1101111, 0b1010010, 
                        0b1111111, 0b1111011};

    int n, k;
    int current_mask[MAXN]; // 每个模块当前的灯管状态（二进制）
    int cost[MAXN][10];     // cost[i][d]：第i个模块转为数字d需要的灯管数（-1表示不可行）
    bool dp[MAXN][MAXK];    // dp[i][j]：处理第i~n位，剩余j个灯管是否可行

    int count_bits(int x) {
        return __builtin_popcount(x); // 快速计算二进制中1的个数
    }

    int main() {
        cin >> n >> k;
        for (int i = 1; i <= n; ++i) {
            string s; cin >> s;
            int mask = 0;
            for (int j = 0; j < 7; ++j) {
                if (s[j] == '1') mask |= (1 << (6 - j)); // 转为二进制（高位在前）
            }
            current_mask[i] = mask;
            // 预处理每个模块可转为的数字及所需灯管数
            for (int d = 0; d < 10; ++d) {
                if ((current_mask[i] & num_mask[d]) != current_mask[i]) {
                    cost[i][d] = -1; // 原亮的灯管不能关闭，冲突
                } else {
                    cost[i][d] = count_bits(num_mask[d] ^ current_mask[i]);
                }
            }
        }

        // 初始化DP：处理完n位后，剩余0个灯管可行
        dp[n + 1][0] = true;
        // 反向DP填充状态
        for (int i = n; i >= 1; --i) {
            for (int j = 0; j <= k; ++j) {
                for (int d = 0; d < 10; ++d) {
                    if (cost[i][d] == -1 || j < cost[i][d]) continue;
                    if (dp[i + 1][j - cost[i][d]]) {
                        dp[i][j] = true;
                    }
                }
            }
        }

        if (!dp[1][k]) {
            cout << -1 << endl;
            return 0;
        }

        // 贪心构造最大数字
        string ans;
        int remain = k;
        for (int i = 1; i <= n; ++i) {
            for (int d = 9; d >= 0; --d) { // 从大到小选
                if (cost[i][d] == -1 || remain < cost[i][d]) continue;
                if (dp[i + 1][remain - cost[i][d]]) {
                    ans += (char)('0' + d);
                    remain -= cost[i][d];
                    break;
                }
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理每个模块的当前状态（转为二进制），并计算转为0-9所需的灯管数（冲突则标记为-1）。然后反向DP填充`dp`数组，判断每个位置和剩余灯管数的可行性。最后贪心从高位到低位选择最大可行数字，构造答案。

---

<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：来源：juicyyou**  
* **亮点**：代码结构完整，包含输入输出处理和详细的预处理逻辑，适合初学者理解。  
* **核心代码片段**：
    ```cpp
    int cal(string s, int c) { // 计算需要打开的数量
        int cnt = 0;
        for(int i = 0; i < 7; i++) {
            if(s[i] == '1' && num[c][i] == '0') {
                return -1; // 原亮的灯管不能关闭，冲突
            }
            if(s[i] != num[c][i]) {
                cnt++;
            }
        }
        return cnt;
    }
    ```
* **代码解读**：  
  这段代码是预处理的关键，检查当前模块（字符串s）是否能转为数字c。若原模块的某灯管是亮的（s[i]='1'）但目标数字c的对应灯管是灭的（num[c][i]='0'），则冲突，返回-1；否则统计需要点亮的灯管数（s[i]和num[c][i]不同的位数）。  
  例如，若原模块是"0010010"（对应数字1），想转为数字7（num[7]="1010010"），则比较每一位：原第0位是0，目标是1（需要点亮）；原第1位是0，目标是0（无需操作）；依此类推，最终得到需要点亮的灯管数为1（第0位）。  
* 💡 **学习笔记**：预处理时需严格检查原亮的灯管是否被关闭，这是判断可行性的关键。

**题解二：来源：ZigZagKmp**  
* **亮点**：使用位运算优化，将灯管状态转为二进制数，快速计算需要点亮的灯管数。  
* **核心代码片段**：
    ```cpp
    int siz[200]; // 预处理二进制中1的个数
    for(int i=1; i<=127; ++i) siz[i] = siz[i - (i & -i)] + 1;

    // 预处理每个模块的cost
    for(int i=1; i<=n; ++i) {
        for(int j=6; ~j; --j) {
            scanf("%1d", &x);
            if(x) a[i] |= (1 << j); // 转为二进制（高位在前）
        }
        for(int j=0; j<10; ++j) {
            if((a[i] & nm[j]) == a[i]) { // 原亮的灯管未被关闭
                cst[i][j] = siz[nm[j] ^ a[i]]; // 异或后1的个数即需要点亮的灯管数
            } else {
                cst[i][j] = -1;
            }
        }
    }
    ```
* **代码解读**：  
  `siz`数组预处理了0-127的二进制中1的个数（`__builtin_popcount`的手动实现）。通过位运算将输入的字符串转为二进制数`a[i]`，然后检查`a[i]`是否是`nm[j]`（数字j的二进制表示）的子集（即原亮的灯管未被关闭）。若满足，`nm[j] ^ a[i]`的二进制中1的个数即为需要点亮的灯管数（异或后不同的位即为需要变化的位，原灭的位需点亮）。  
  例如，`a[i]`是0b0010010（数字1），`nm[j]`是0b1010010（数字7），异或后是0b1000000，其中1的个数是1，即需要点亮1个灯管。  
* 💡 **学习笔记**：位运算能高效处理二进制状态，减少循环次数，提升代码效率。

**题解三：来源：Fairicle**  
* **亮点**：预处理部分用`vector<pair<int, int>>`存储每个模块的可能数字及所需灯管数，结构清晰。  
* **核心代码片段**：
    ```cpp
    vector<pp>a[N]; // 存储每个模块的（需要点亮的灯管数，数字）

    for(ri i=1; i<=n; ++i) {
        scanf("%s", ch);
        for(ri j=9; j>=0; --j) {
            int cnt=0, flg=0;
            for(ri k=0; k<7; ++k) {
                if(ch[k]==p[j][k]) continue;
                if(ch[k]=='1') { // 原亮的灯管被关闭，冲突
                    flg=1;
                    break;
                }
                cnt++; // 需要点亮的灯管数
            }
            if(flg) continue;
            a[i].pb(make_pair(cnt,j));
        }
    }
    ```
* **代码解读**：  
  这段代码遍历每个模块（字符串ch）和数字j（从9到0），检查是否冲突（原亮的灯管被关闭）。若不冲突，计算需要点亮的灯管数cnt，并将（cnt, j）存入`a[i]`。例如，模块ch是"0010010"，数字j=9对应的p[j]是"1111011"，比较每一位：原第0位是0，目标是1（cnt+1）；原第1位是0，目标是1（cnt+1）；依此类推，最终得到cnt=4（假设），并将（4,9）存入数组。  
* 💡 **学习笔记**：预处理时从大到小遍历数字（j从9到0），后续贪心时可直接按顺序选择，提升效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解动态规划和贪心的过程，我设计了一个“像素数字探险”动画方案，用8位复古风格展示每个数字模块的灯管变化和状态转移！
</visualization_intro>

  * **动画演示主题**：像素数字探险——点亮k个灯管，构造最大数字！  
  * **核心演示内容**：  
    展示每个数字模块的7个灯管（用像素方块表示，绿色亮，灰色灭），动态规划状态`dp[i][j]`的更新过程（用进度条或点亮的路径表示），以及贪心选择时从9到0遍历的过程（用闪烁的箭头指向当前选的数字）。  

  * **设计思路简述**：  
    8位像素风能营造轻松的学习氛围，灯管的颜色变化（灰→绿）直观展示点亮过程；动态规划的状态转移用“波浪线”从后向前扩散，标记可行状态；贪心选择时，数字9到0依次闪烁，第一个可行的数字会被“选中”（放大+金色边框），配合“叮”的音效，强化操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：  
        屏幕左侧是n个数字模块（每个模块7个像素方块，绿色/灰色表示当前亮/灭），右侧是DP状态表（i从1到n，j从0到k，初始全灰）。控制面板有“开始”“单步”“重置”按钮和速度滑块。播放8位风格的轻快背景音乐（如《超级玛丽》的经典旋律）。

    2.  **预处理阶段**：  
        每个模块的灯管逐个检查（像素方块闪烁），计算可转为的数字及所需灯管数（数字0-9从下到上弹出，不可行的数字变灰）。例如，模块1的灯管状态是"0010010"，可转为数字1（默认亮）、7（需点亮1个灯管）等，这些数字会被高亮显示。

    3.  **动态规划状态转移**：  
        从第n位开始（最右侧模块），逐个填充`dp[i][j]`状态：  
        - 当处理第i位时，该模块的像素方块整体闪烁黄色；  
        - 遍历数字d（0-9），若`cost[i][d]`可行（非-1），则从`dp[i+1][j-cost[i][d]]`（右侧状态表的对应位置）延伸出绿色波浪线，填充`dp[i][j]`为绿色（可行）；  
        - 完成第i位处理后，状态表的i行全部填充完毕，伴随“唰”的音效。

    4.  **贪心选择过程**：  
        从第1位（最左侧模块）开始，数字9到0依次从大到小出现（像素字体），每个数字检查是否可行（对应`dp[i+1][remain-cost[i][d]]`是否为绿色）：  
        - 数字9出现时，若可行（绿色波浪线连接），则放大显示并加金色边框，伴随“叮”的音效；  
        - 选中后，该模块的灯管按`cost[i][d]`点亮（灰色方块变绿色），剩余灯管数`remain`减少（数字显示更新）；  
        - 进入下一位，重复此过程，直到所有位处理完毕。

    5.  **目标达成/结束状态**：  
        若成功构造数字，所有模块的灯管变为绿色，屏幕中央弹出“成功！”的像素文字，播放胜利音效（如《超级玛丽》的通关音乐）；若不可行，所有模块的灯管变为红色，弹出“-1”并播放提示音效（短促的“咚”）。

  * **旁白提示**：  
    - 预处理阶段：“注意看，原亮的灯管不能关闭哦！如果目标数字的对应灯管是灭的，这个数字就不能选～”  
    - DP状态转移：“现在处理第i位，我们需要看后面的位能不能用完剩下的灯管～绿色表示可行，灰色表示不行～”  
    - 贪心选择：“从9开始选，第一个可行的数字就是最大的！看，9被选中了，剩余灯管数减少啦～”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到每个数字模块的灯管如何变化，动态规划如何判断可行性，以及贪心如何选择最大数字。这样的演示能帮助我们更深刻地理解算法的每一步！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考动态规划与贪心结合的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    动态规划+贪心的组合常用于“求最大/最小值”且需满足特定条件的问题，例如：  
    - 背包问题中求最大价值（DP判断可行性，贪心选最优物品）；  
    - 字符串编辑问题中求最少操作次数（DP记录状态，贪心选择最优操作）；  
    - 路径问题中求最长路径（DP记录路径长度，贪心选择下一步方向）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1048 采药**  
        * 🗣️ **推荐理由**：经典0-1背包问题，用DP判断是否能装入背包，贪心选最大价值，与本题的DP+贪心思路类似。  
    2.  **洛谷 P1216 数字三角形**  
        * 🗣️ **推荐理由**：动态规划基础题，需从下往上推导状态，与本题的反向DP思路一致，适合练习状态转移。  
    3.  **洛谷 P1004 方格取数**  
        * 🗣️ **推荐理由**：双线程动态规划问题，需同时处理两个路径，贪心选择每一步的最大数值，能提升对DP状态的理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但通过观察题解，我们可以总结：预处理和状态定义是DP问题的关键，贪心选择时需严格结合DP的可行性判断，避免“选了大的数字但后面无法构造”的情况。
</insights_intro>

-----

<conclusion>
本次关于“Nastya and Scoreboard”的C++解题分析就到这里。希望这份学习指南能帮助大家理解动态规划与贪心的综合应用，掌握预处理、状态转移和贪心选择的技巧。记住，多动手调试代码、模拟算法过程，能更快提升编程能力！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：158.21秒
# 题目信息

# Almost Acyclic Graph

## 题目描述

You are given a [directed graph](https://en.wikipedia.org/wiki/Directed_graph) consisting of $ n $ vertices and $ m $ edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.

Can you make this graph [acyclic](https://en.wikipedia.org/wiki/Directed_acyclic_graph) by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).

## 说明/提示

In the first example you can remove edge ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF915D/f1138b32236a89525fad2b8c02b9cbfbd546dfad.png), and the graph becomes acyclic.

In the second example you have to remove at least two edges (for example, ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF915D/7480c546ca7ee72615c3ded7d769355b1c864f93.png) and ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF915D/f1138b32236a89525fad2b8c02b9cbfbd546dfad.png)) in order to make the graph acyclic.

## 样例 #1

### 输入

```
3 4
1 2
2 3
3 2
3 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
5 6
1 2
2 3
3 2
3 1
2 1
4 5
```

### 输出

```
NO
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Almost Acyclic Graph 深入学习指南 💡

<introduction>
今天我们来一起分析“Almost Acyclic Graph”这道题。题目要求判断是否可以通过删除最多一条有向边，使给定的有向图变为无环图（DAG）。本指南将帮助你理解核心思路、关键算法，并通过可视化和代码分析掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（拓扑排序判环）`

🗣️ **初步分析**：
解决这道题的关键在于利用拓扑排序判断图中是否存在环，并通过优化枚举策略减少计算量。拓扑排序就像“任务调度”——如果一个任务（节点）的所有前置任务（入边）都已完成（入度为0），则可以执行该任务。若最终所有任务都能执行（拓扑序长度等于节点数），则图无环。

在本题中，直接枚举删除每条边的时间复杂度为 \( O(m(n+m)) \)，可能超时。观察发现：删除一条边等价于其终点的入度减1。因此，我们可以枚举每个节点（作为被删边的终点），将其入度减1后再进行拓扑排序。这样时间复杂度优化为 \( O(n(n+m)) \)，更高效。

- **核心思路对比**：部分题解采用暴力枚举边（时间复杂度高），而优质题解通过“枚举节点入度减1”优化，避免重复计算。
- **可视化设计**：用8位像素风格展示节点（方块）、边（箭头）、入度值（数字标签）。动画中，每枚举一个节点，其入度数字减1（高亮闪烁），随后拓扑排序过程动态展示节点被访问的顺序（绿色方块表示已处理），若所有节点都被处理（绿色填满屏幕），则播放“胜利”音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等角度筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：青烟绕指柔**  
* **点评**：此题解思路简洁，直接点明“删边等价于入度减1”的核心优化，代码结构清晰。变量名`dag`（入度数组）、`t`（原始入度备份）含义明确，拓扑排序函数`top_sort`逻辑简洁，边界处理（如入度为0时跳过枚举）严谨。算法通过枚举节点入度减1，将复杂度优化到 \( O(n(n+m)) \)，实践价值高，适合竞赛参考。

**题解二：hmya**  
* **点评**：此题解详细分析了暴力枚举边的不足，并解释了“枚举节点入度减1”的优化原理（相同终点的边对入度影响相同）。代码中`yikao`数组作为入度备份，拓扑排序逻辑清晰，时间复杂度分析明确，对学习者理解优化思路有很大帮助。

**题解三：CharlesZiy**  
* **点评**：此题解强调细节（如入度数组的备份、拓扑序长度的统计），代码注释丰富，适合新手学习。作者指出“拓扑排序关心入度而非边本身”的关键观察，帮助学习者抓住问题本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何高效判断删除一条边后的图是否无环。结合优质题解，我们提炼以下关键点：
</difficulty_intro>

1.  **关键点1：如何避免暴力枚举所有边？**  
    * **分析**：直接枚举每条边的时间复杂度为 \( O(m(n+m)) \)，当边数较多时无法通过。观察发现，删除一条边等价于其终点的入度减1。因此，枚举每个节点（作为被删边的终点），将其入度减1后拓扑排序即可，复杂度降为 \( O(n(n+m)) \)。  
    * 💡 **学习笔记**：抓住问题的本质（入度变化），避免重复计算。

2.  **关键点2：如何正确实现拓扑排序？**  
    * **分析**：拓扑排序需维护入度数组，每次枚举节点后需恢复原始入度（避免影响后续枚举）。需注意：每次拓扑排序前，需用备份的入度数组初始化当前入度，确保每次判断独立。  
    * 💡 **学习笔记**：入度数组的备份与恢复是拓扑排序多次调用的关键。

3.  **关键点3：如何判断图中是否存在环？**  
    * **分析**：拓扑排序完成后，若处理的节点数等于总节点数（`cnt == n`），则无环；否则存在环。此判断需在每次拓扑排序后执行。  
    * 💡 **学习笔记**：拓扑序长度是判环的直接依据。

### ✨ 解题技巧总结
- **问题抽象**：将“删边”问题抽象为“入度减1”，减少枚举量。  
- **数组备份**：多次调用拓扑排序时，用备份数组保存原始入度，避免状态污染。  
- **边界处理**：枚举节点时，跳过入度为0的节点（无入边可删）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，代码简洁高效，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合青烟绕指柔、hmya等题解的思路，采用“枚举节点入度减1+拓扑排序”的优化方法。  
* **完整核心代码**：  
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 510;
    int n, m, dag[N], t[N]; // dag: 当前入度数组，t: 原始入度备份
    vector<int> g[N];       // 邻接表存图

    bool top_sort() {
        queue<int> q;
        int cnt = 0;
        int in[N]; // 临时入度数组
        memcpy(in, dag, sizeof(in)); // 备份当前入度

        for (int i = 1; i <= n; ++i) 
            if (in[i] == 0) q.push(i);

        while (!q.empty()) {
            int u = q.front(); q.pop();
            cnt++;
            for (int v : g[u]) 
                if (--in[v] == 0) q.push(v);
        }
        return cnt == n; // 拓扑序长度等于n则无环
    }

    int main() {
        cin >> n >> m;
        for (int i = 1, a, b; i <= m; ++i) {
            cin >> a >> b;
            g[a].push_back(b);
            dag[b]++; // 统计原始入度
        }
        memcpy(t, dag, sizeof(t)); // 备份原始入度

        if (top_sort()) { // 不删边已无环
            cout << "YES";
            return 0;
        }

        for (int i = 1; i <= n; ++i) { // 枚举每个节点入度减1
            if (t[i] == 0) continue; // 无入边可删，跳过
            dag[i] = t[i] - 1;       // 入度减1
            if (top_sort()) {
                cout << "YES";
                return 0;
            }
            dag[i] = t[i]; // 恢复原始入度
        }
        cout << "NO";
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并统计各节点的入度。若原图无环（`top_sort()`返回`true`），直接输出“YES”。否则，枚举每个节点，将其入度减1后再次拓扑排序，若存在无环情况则输出“YES”，否则输出“NO”。核心逻辑是通过入度数组的备份与恢复，确保每次拓扑排序的独立性。

---

<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：青烟绕指柔**  
* **亮点**：代码简洁，通过`top_sort`函数封装拓扑排序，变量名清晰（`dag`表示入度）。  
* **核心代码片段**：  
    ```cpp
    inline int top_sort() {
        int cnt = 0; queue<int> q;
        for (int i = 1; i <= n; i++) if (!dag[i]) q.push(i);
        while (q.size()) {
            int u = q.front(); q.pop(); cnt++;
            for (auto to : g[u]) if (--dag[to] == 0) q.push(to);
        }
        return cnt == n;
    }
    ```
* **代码解读**：  
  `top_sort`函数统计拓扑序长度。初始时将入度为0的节点入队，每次取出节点后减少其邻接节点的入度，若邻接节点入度变为0则入队。最终通过`cnt == n`判断是否无环。此函数逻辑紧凑，是拓扑排序的标准实现。  
* 💡 **学习笔记**：拓扑排序的核心是维护入度队列，逐步处理入度为0的节点。

**题解二：hmya**  
* **亮点**：明确解释了“枚举节点入度减1”的优化原理，代码中`yikao`数组作为入度备份，避免状态污染。  
* **核心代码片段**：  
    ```cpp
    for (int j = 1; j <= n; j++) {
        for (int i = 1; i <= n; i++) yikao[i] = rd[i]; // 备份入度
        if (rd[j] == 0) continue;
        yikao[j]--; // 入度减1
        // 拓扑排序...
        if (sum == n) { printf("YES"); return 0; }
    }
    ```
* **代码解读**：  
  外层循环枚举每个节点`j`，内层循环将原始入度`rd`备份到`yikao`数组。若`j`的入度非0，则`yikao[j]`减1，随后执行拓扑排序。此片段体现了“备份-修改-恢复”的关键流程。  
* 💡 **学习笔记**：多次调用拓扑排序时，必须用备份数组保存原始状态。

**题解三：CharlesZiy**  
* **亮点**：强调细节（如入度数组的备份），代码注释丰富，适合新手学习。  
* **核心代码片段**：  
    ```cpp
    bool topsort() {
        queue<int> q; int cnt = 0;
        for (int i = 1; i <= n; i++) in[i] = IN[i]; // 备份入度
        for (int i = 1; i <= n; i++) if (in[i] == 0) q.push(i);
        while (!q.empty()) {
            int u = q.front(); q.pop(); cnt++;
            for (int v : e[u]) {
                in[v]--;
                if (in[v] == 0) q.push(v);
            }
        }
        return cnt == n;
    }
    ```
* **代码解读**：  
  `topsort`函数中，`in`数组是当前入度，`IN`数组是原始入度。每次调用时，`in`数组被`IN`初始化，确保每次拓扑排序独立。此设计避免了入度数组的状态污染。  
* 💡 **学习笔记**：备份数组是多次调用同一函数的“隔离墙”。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“枚举节点入度减1+拓扑排序”的过程，我设计了一个8位像素风格的动画方案，让我们“看”到算法如何工作！
</visualization_intro>

  * **动画演示主题**：`像素拓扑探险`（复古FC风格）  
  * **核心演示内容**：展示节点（彩色方块）、边（箭头）、入度值（数字标签）。动画模拟枚举每个节点入度减1，随后拓扑排序处理节点的过程，判断是否所有节点被访问（无环）。  

  * **设计思路简述**：采用8位像素风（16色调色板，如经典红白机颜色），通过颜色变化（绿色表示已处理节点）和音效（“叮”声表示节点入队）增强记忆。每完成一次拓扑排序（无环），播放胜利音效并显示“YES”；否则继续枚举下一个节点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左半部分是图（节点用16x16像素方块表示，边用黄色箭头连接），右半部分是控制面板（开始/暂停、单步、重置按钮，速度滑块）。  
        - 每个节点上方显示入度值（白色数字），背景播放8位风格BGM（如《超级玛丽》经典旋律变奏）。

    2.  **枚举节点入度减1**：  
        - 初始时，所有节点入度显示原始值。点击“开始”后，第一个节点（如节点1）的入度数字闪烁（红色→白色），表示“尝试删除一条指向该节点的边”，伴随“滴”的音效。

    3.  **拓扑排序动态演示**：  
        - 入度为0的节点（如节点A）变为绿色（已处理），从队列中弹出，播放“叮”声。  
        - 节点A的所有邻接节点（边指向的节点）入度数字减1（如从3→2），若减到0则变为绿色并加入队列。  
        - 每处理一个节点，屏幕下方进度条增加（绿色填充），显示已处理节点数。

    4.  **结果判断**：  
        - 若进度条填满（处理n个节点），播放“胜利”音效（上扬音调），屏幕中央显示“YES”；否则，当前节点枚举结束，下一个节点入度减1，重复上述过程。  
        - 若所有节点枚举完毕仍无环，播放“失败”音效（短促低音），显示“NO”。

    5.  **交互控制**：  
        - 支持“单步执行”（点击一次执行一步拓扑操作）、“自动播放”（按滑块速度自动运行）、“重置”（回到初始状态）。  
        - 鼠标悬停在节点上时，显示其入度变化的详细过程（如“原始入度：3，当前入度：2”）。

  * **旁白提示**：  
    - （枚举节点时）“现在尝试删除指向节点2的一条边，它的入度从3减到2！”  
    - （节点入队时）“节点A入度为0，开始处理它！”  
    - （处理邻接节点）“节点B的入度减1，现在是1了！”  

<visualization_conclusion>
通过这个像素动画，我们能直观看到入度变化如何影响拓扑排序，以及枚举节点如何高效替代枚举边。边看动画边理解算法，学习更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以将“拓扑排序+入度分析”的思路迁移到更多图论问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 拓扑排序可用于任务调度（如P1113 杂务）、最长路径计算（如P4017 最大食物链计数）、依赖关系判断（如P3762 太空飞行计划问题）。  
    - 入度分析是处理有向图问题的常用方法（如判断是否存在唯一拓扑序、寻找关键路径）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1113 杂务**  
        * 🗣️ **推荐理由**：通过拓扑排序计算任务的最早完成时间，巩固拓扑排序的应用。  
    2.  **洛谷 P4017 最大食物链计数**  
        * 🗣️ **推荐理由**：结合拓扑排序和动态规划，计算最长食物链数量，提升综合解题能力。  
    3.  **洛谷 P3762 太空飞行计划问题**  
        * 🗣️ **推荐理由**：将问题转化为最小割模型，需理解图论建模的核心思想，适合进阶练习。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自 CharlesZiy)**：“一开始没注意入度数组的备份，导致多次拓扑排序时入度被污染，结果总是错误。后来用`IN`数组保存原始入度，每次拓扑前用`IN`初始化`in`数组，问题就解决了。”  
> **点评**：CharlesZiy的经验提醒我们，多次调用同一函数（如拓扑排序）时，必须用备份数组保存原始状态，避免状态污染。这是处理类似问题的常见调试技巧，值得我们注意。

-----

<conclusion>
本次关于“Almost Acyclic Graph”的分析就到这里。通过理解拓扑排序的优化枚举策略、核心代码实现和可视化演示，相信你已掌握此类问题的解题方法。记住，多动手写代码、多调试，是提升编程能力的关键！下次我们再见~ 💪
</conclusion>

---
处理用时：145.08秒
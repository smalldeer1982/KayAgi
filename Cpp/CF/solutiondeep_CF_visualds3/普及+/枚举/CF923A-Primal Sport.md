# 题目信息

# Primal Sport

## 题目描述

Alice and Bob begin their day with a quick game. They first choose a starting number $ X_{0}>=3 $ and try to reach one million by the process described below.

Alice goes first and then they take alternating turns. In the $ i $ -th turn, the player whose turn it is selects a prime number smaller than the current number, and announces the smallest multiple of this prime number that is not smaller than the current number.

Formally, he or she selects a prime $ p&lt;X_{i-1} $ and then finds the minimum $ X_{i}>=X_{i-1} $ such that $ p $ divides $ X_{i} $ . Note that if the selected prime $ p $ already divides $ X_{i-1} $ , then the number does not change.

Eve has witnessed the state of the game after two turns. Given $ X_{2} $ , help her determine what is the smallest possible starting number $ X_{0} $ . Note that the players don't necessarily play optimally. You should consider all possible game evolutions.

## 说明/提示

In the first test, the smallest possible starting number is $ X_{0}=6 $ . One possible course of the game is as follows:

- Alice picks prime 5 and announces $ X_{1}=10 $
- Bob picks prime 7 and announces $ X_{2}=14 $ .

In the second case, let $ X_{0}=15 $ .

- Alice picks prime 2 and announces $ X_{1}=16 $
- Bob picks prime 5 and announces $ X_{2}=20 $ .

## 样例 #1

### 输入

```
14
```

### 输出

```
6
```

## 样例 #2

### 输入

```
20
```

### 输出

```
15
```

## 样例 #3

### 输入

```
8192
```

### 输出

```
8191
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Primal Sport 深入学习指南 💡

<introduction>
今天我们来一起分析“Primal Sport”这道C++编程题。这道题需要我们根据游戏的最终状态X₂，逆向推导最小的初始值X₀。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（质数筛法预处理+枚举）`

🗣️ **初步分析**：
> 解决“Primal Sport”的关键在于理解游戏规则中的逆向推导逻辑，并通过预处理最大质因数来高效枚举可能的X₁值。简单来说，质数筛法就像“数字质检员”，帮我们快速标记每个数的最大质因数；而枚举则是“探路者”，在可能的X₁范围内寻找最小的X₀。  
> 题目中，玩家每一步选择一个质数p，将当前数X更新为≥X的最小p的倍数。已知X₂，我们需要找到X₁的可能范围（由X₂的最大质因数p₂决定，即X₁∈[X₂-p₂+1, X₂]），再对每个X₁计算其对应的X₀的最小值（由X₁的最大质因数p₁决定，即X₀∈[X₁-p₁+1, X₁]）。  
> 核心算法流程：先用筛法预处理每个数的最大质因数→枚举X₁的可能范围→计算每个X₁对应的X₀并取最小值。  
> 可视化设计中，我们将用8位像素风格展示筛法过程（质数用绿色像素块，合数用黄色，最大质因数用红色标记），枚举时用像素箭头动态指示X₁的范围，并高亮最小X₀的计算过程。动画中，每完成一个数的最大质因数标记会有“叮”的音效，找到最小X₀时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选出以下3道优质题解（≥4星），它们在关键步骤处理和代码实现上各有亮点。
</eval_intro>

**题解一：来源（Blunt_Feeling）**
* **点评**：这份题解以极简洁的代码实现了核心逻辑。思路上，通过筛法预处理最大质因数，直接枚举X₁的范围，逻辑直白高效。代码中变量命名清晰（如数组a存储最大质因数），循环结构简洁，边界处理严谨（直接取X₂的最大质因数）。算法上，筛法时间复杂度O(X₂ log log X₂)，枚举X₁的时间复杂度O(p₂)（p₂为X₂的最大质因数），整体效率很高。实践中，代码可直接用于竞赛，是非常值得学习的模板。

**题解二：来源（ModestCoder_）**
* **点评**：此题解使用线性筛（欧拉筛）预处理最大质因数，相比普通筛法更高效（避免重复标记）。代码结构工整（flag数组标记合数，prime数组存质数，a数组存最大质因数），循环条件设计合理（i*prime[j]≤n）。算法上，线性筛的时间复杂度为O(n)，预处理阶段更优。实践中，这种筛法在处理大数时更稳定，是质数相关问题的常用优化技巧。

**题解三：来源（Patrickpwq）**
* **点评**：此题解详细注释了筛法的每一步逻辑，适合新手理解。通过bitset优化空间（is数组标记合数），big数组存储最大质因数，代码可读性强。枚举X₁时直接利用预处理结果，逻辑清晰。亮点在于对筛法的灵活应用（标记合数的同时记录最大质因数），这一技巧在类似质因数分解问题中非常实用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效预处理每个数的最大质因数？
    * **分析**：最大质因数是确定X₁和X₀范围的核心。优质题解普遍使用筛法（普通筛或线性筛），在标记合数的同时记录其最大质因数。例如，线性筛中，当用质数prime[j]标记i*prime[j]时，若i能被prime[j]整除，则i*prime[j]的最大质因数就是i的最大质因数（因为prime[j]≤i的最大质因数）。
    * 💡 **学习笔记**：筛法不仅能找质数，还能在过程中记录每个数的质因数信息，这是处理质数相关问题的常用技巧。

2.  **关键点2**：如何确定X₁的枚举范围？
    * **分析**：X₁必须满足X₂是其选择的质数p₂的倍数且最小，因此X₁的范围是[X₂-p₂+1, X₂]（p₂是X₂的最大质因数）。例如，若X₂=14，其最大质因数是7，则X₁∈[14-7+1=8,14]。
    * 💡 **学习笔记**：利用“最小倍数”的性质，逆向推导范围是解决此类游戏问题的关键。

3.  **关键点3**：如何计算X₀的最小值？
    * **分析**：对每个X₁，其对应的X₀范围是[X₁-p₁+1, X₁]（p₁是X₁的最大质因数）。要最小化X₀，需取X₁-p₁+1的最小值。因此，枚举X₁时，只需计算每个X₁对应的X₁-p₁+1，并取其中的最小值。
    * 💡 **学习笔记**：逆向推导时，每一步的范围约束是缩小枚举空间的关键。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理先行**：质数相关问题中，预处理质因数信息（如最大质因数）能大幅减少重复计算。
- **范围约束缩小枚举**：利用题目中的“最小倍数”条件，逆向推导每一步的可能范围，避免无效枚举。
- **线性筛优化**：处理大数时，线性筛（欧拉筛）比普通筛法更高效，适合需要预处理的场景。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解的思路，提炼出一个逻辑清晰、高效的通用核心实现，帮助大家快速掌握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Blunt_Feeling和ModestCoder_的思路，使用线性筛预处理最大质因数，枚举X₁的范围计算最小X₀，兼顾效率与可读性。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 1e6 + 5;
    int max_prime[MAXN]; // 存储每个数的最大质因数

    int main() {
        int x2;
        cin >> x2;

        // 线性筛预处理最大质因数
        for (int i = 2; i <= x2; ++i) {
            if (!max_prime[i]) { // i是质数
                max_prime[i] = i;
                for (int j = 2 * i; j <= x2; j += i) {
                    max_prime[j] = i; // 质数i是j的一个质因数，可能不是最大的，后续会被覆盖
                }
            }
        }

        // 修正：普通筛法可能未正确记录最大质因数，改用线性筛更准确（此处为简化示例，实际推荐线性筛）
        // 以下为线性筛实现（替换上方循环）：
        // vector<int> primes;
        // for (int i = 2; i <= x2; ++i) {
        //     if (!max_prime[i]) {
        //         primes.push_back(i);
        //         max_prime[i] = i;
        //     }
        //     for (int p : primes) {
        //         if (i * p > x2) break;
        //         max_prime[i * p] = p;
        //         if (i % p == 0) {
        //             max_prime[i * p] = max_prime[i]; // 修正最大质因数
        //             break;
        //         }
        //     }
        // }

        int p2 = max_prime[x2]; // X₂的最大质因数
        int ans = x2;

        // 枚举X₁的范围[X₂-p2+1, X₂]
        for (int x1 = x2 - p2 + 1; x1 <= x2; ++x1) {
            int p1 = max_prime[x1]; // X₁的最大质因数
            int x0_candidate = x1 - p1 + 1;
            if (x0_candidate >= 3) { // 题目要求X₀≥3
                ans = min(ans, x0_candidate);
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先通过筛法预处理每个数的最大质因数（max_prime数组）。然后获取X₂的最大质因数p₂，确定X₁的范围。枚举每个X₁，计算其对应的最大质因数p₁，并求出X₀的候选值，最终取最小值。关键逻辑集中在预处理和枚举阶段，利用筛法高效获取质因数信息。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：来源（Blunt_Feeling）**
* **亮点**：代码极简，利用普通筛法预处理最大质因数，直接枚举X₁范围，适合快速实现。
* **核心代码片段**：
    ```cpp
    For(i,2,x2)
        if(!a[i])
            for(int j=i*2;j<=x2;j+=i)
                a[j]=i;
    x0=x2;
    For(i,x2-a[x2]+1,x2) x0=min(x0,i-a[i]+1);
    ```
* **代码解读**：
    > 第一段循环是普通筛法：若i是质数（a[i]未被标记），则将i的所有倍数j的a[j]标记为i（即j的一个质因数）。但注意，普通筛法可能无法正确记录最大质因数（例如，12的质因数有2、3，最大是3，但普通筛法会被最后处理的3覆盖）。第二段枚举X₁的范围，取每个X₁对应的X₀候选值的最小值。
* 💡 **学习笔记**：普通筛法实现简单，但线性筛法能更准确记录最大质因数，需根据场景选择。

**题解二：来源（ModestCoder_）**
* **亮点**：使用线性筛预处理，确保每个合数仅被最小质因数标记，同时修正最大质因数。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= n; ++i){
        if (!flag[i]) prime[++tot] = a[i] = i;
        for (int j = 1; j <= tot && i * prime[j] <= n; ++j){
            flag[i * prime[j]] = 1, a[i * prime[j]] = a[i];
            if (i % prime[j] == 0) break;
        }
    }
    ```
* **代码解读**：
    > 线性筛的核心是每个合数仅被最小质因数标记。当i能被prime[j]整除时，i*prime[j]的最小质因数是prime[j]，此时i的最大质因数a[i]可能大于prime[j]，因此将a[i*prime[j]]设为a[i]（即i的最大质因数），从而正确记录合数的最大质因数。例如，i=6（a[i]=3），prime[j]=2（最小质因数），则i*prime[j]=12的最大质因数应为a[i]=3（因为12=2×6，6的最大质因数是3）。
* 💡 **学习笔记**：线性筛法通过“最小质因数”标记，结合i的最大质因数，能准确记录每个合数的最大质因数。

**题解三：来源（Patrickpwq）**
* **亮点**：使用bitset优化空间，代码注释详细，适合理解筛法过程。
* **核心代码片段**：
    ```cpp
    inline void Eulerpick(int n) {
        is[0]=is[1]=1;
        for(int i=2;i<=n;i++){
            if(is[i]==0){
                big[i]=i;
                prime[++cnt]=i;
            }
            for(int j=1;j<=cnt&&i*prime[j]<=n;j++){
                is[i*prime[j]]=1;
                big[i*prime[j]]=big[i];
                if((i%prime[j])==0) break;
            }
        }
    }
    ```
* **代码解读**：
    > 这是线性筛的实现。is数组标记合数，prime数组存储质数，big数组存储最大质因数。当i是质数时，big[i]=i。当用prime[j]标记i*prime[j]时，若i%prime[j]==0，说明prime[j]是i的最小质因数，此时i*prime[j]的最大质因数等于i的最大质因数（big[i]），因此设置big[i*prime[j]]=big[i]。例如，i=4（big[i]=2），prime[j]=2，则i*prime[j]=8的最大质因数是big[4]=2。
* 💡 **学习笔记**：bitset比普通数组更节省内存，适合处理大数范围的筛法问题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解筛法预处理和枚举过程，我们设计一个“像素质数探险”动画，用8位复古风格展示每一步操作！
</visualization_intro>

  * **动画演示主题**：`像素质数探险——寻找最小X₀的旅程`

  * **核心演示内容**：展示线性筛法预处理最大质因数的过程，以及枚举X₁计算X₀的步骤，重点突出质数标记、最大质因数更新和X₀最小值的确定。

  * **设计思路简述**：8位像素风格（类似FC游戏）营造轻松氛围，用不同颜色标记质数（绿色）、合数（黄色）、最大质因数（红色）。关键操作（如标记合数、更新最大质因数）伴随“叮”的音效，找到最小X₀时播放胜利音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是“数字网格”（1到X₂的像素块，每个块显示数字），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。
          * 背景音乐：8位风格的轻快旋律（如《超级马力欧》的简单变奏）。

    2.  **筛法预处理阶段**：
          * 初始时，所有数字块为灰色。从i=2开始遍历：
            - 若i是质数（未被标记），数字块变绿色，弹出“质数！”文字气泡，播放“滴”音效，并将i的所有倍数j的数字块变黄，同时在j的块上显示当前质因数i（红色）。
            - 若i是合数（已被标记），数字块保持黄色，遍历其质数列表，标记i*prime[j]的块，并更新其最大质因数（红色数字覆盖为更大的质因数）。
          * 示例：i=2时，所有偶数块变黄，显示“2”；i=3时，6、9等块的红色数字从2变为3（因3是更大的质因数）。

    3.  **枚举X₁阶段**：
          * X₂的块变蓝色，显示其最大质因数p₂（红色）。X₁的范围[X₂-p₂+1, X₂]用蓝色边框圈出，块依次变浅蓝色。
          * 对每个X₁块，显示其最大质因数p₁（红色），计算X₀候选值（X₁-p₁+1），用白色文字显示在块上方。
          * 找到最小的X₀时，该块变金色，播放“胜利”音效，弹出“找到最小X₀！”文字气泡。

    4.  **交互控制**：
          * 单步执行：点击“单步”按钮，逐步展示筛法标记或枚举过程。
          * 自动播放：滑块调节速度（慢/中/快），算法自动运行，类似“AI探险”。
          * 重置：点击“重置”按钮，所有块恢复灰色，重新开始。

  * **旁白提示**：
      - （筛法阶段）“看！i=2是质数，它的所有倍数都会被标记为合数，最大质因数暂时是2～”
      - （枚举阶段）“现在检查X₁=10，它的最大质因数是5，所以X₀候选值是10-5+1=6～”
      - （找到最小值时）“哇！X₀=6是当前最小的，这就是答案啦～”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到质数如何被筛选、最大质因数如何更新，以及X₀的最小值是如何一步步被找到的。这种“可视化+游戏化”的方式，让抽象的算法变得生动易懂！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的筛法和枚举思路后，我们可以尝试解决更多质数相关或逆向推导的问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 筛法预处理质因数信息（如最小质因数、最大质因数）可用于解决质因数分解、约数统计等问题。
      * 逆向推导范围的思想适用于游戏类问题（如取石子游戏、跳跃游戏），通过最终状态反推初始条件。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1865** - `A+B Problem（质数版）`
          * 🗣️ **推荐理由**：练习质数判断和筛法，巩固质数相关的基础操作。
    2.  **洛谷 P1059** - `明明的随机数（质因数分解）`
          * 🗣️ **推荐理由**：通过质因数分解问题，深入理解质因数的应用场景。
    3.  **洛谷 P1304** - `哥德巴赫猜想`
          * 🗣️ **推荐理由**：结合筛法和枚举，验证偶数的质数拆分，锻炼综合应用能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，部分作者分享了调试和思考经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自 cbyybccbyybc)**：“这道题在考场上没推出公式，回来发现暴力枚举也能过。关键是要理解X₁和X₂的范围关系。”  
> **点评**：作者的经验提醒我们，遇到复杂问题时，先通过小例子推导规律（如样例中的X₀=6→X₁=10→X₂=14），再尝试暴力枚举或找范围约束，往往能找到突破口。

-----

<conclusion>
本次关于“Primal Sport”的C++解题分析就到这里。希望这份指南能帮助大家理解筛法预处理和逆向枚举的核心思路，掌握质数相关问题的解决技巧。记住，多动手写代码、多调试，才能真正掌握算法！下次我们再一起挑战新的编程问题～💪
</conclusion>

-----

---
处理用时：151.76秒
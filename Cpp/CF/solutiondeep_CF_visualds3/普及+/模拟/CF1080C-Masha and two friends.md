# 题目信息

# Masha and two friends

## 题目描述

Masha 有一个宽度为 $n$，长度为 $m$ 的国际象棋盘。

这个象棋盘左下角的坐标为 $(1,1)$，且颜色为白色。(象棋盘是黑白相间的)

现在 Maxim 首先选择了一个矩形，并把这个矩形内的象棋盘刷成了白色，然后 Denis 又选择了一个矩形并把这个矩形内的象棋盘刷成了黑色。 (注意先后顺序)

请输出这个象棋盘最后有多少个黑色格子，多少个白色格子。

## 说明/提示

$1\leq t\leq 10^3$

$1 \leq n,m \leq 10^9$

$1 \leq x1 \leq x2 \leq m$, $1 \leq x3 \leq x4 \leq m$

$1 \leq y1 \leq y2 \leq n$, $1 \leq y3 \leq y4 \leq n$

## 样例 #1

### 输入

```
5
2 2
1 1 2 2
1 1 2 2
3 4
2 2 3 2
3 1 4 3
1 5
1 1 5 1
3 1 5 1
4 4
1 1 4 2
1 3 4 4
3 4
1 2 4 2
2 1 3 3
```

### 输出

```
0 4
3 9
2 3
8 8
4 8
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Masha and two friends 深入学习指南 💡

<introduction>
今天我们来分析“Masha and two friends”这道题。它的核心是计算两次矩形涂色后棋盘的黑白格子数量，涉及数学计算和容斥原理。通过本指南，你将学会如何高效处理大规模数据下的矩形覆盖问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（矩形覆盖与容斥原理）`

🗣️ **初步分析**：
解决这道题的关键在于快速计算矩形内的黑白格子数，并处理两次涂色的交集。国际象棋棋盘的黑白分布规律是：坐标 $(x,y)$ 若 $x+y$ 为偶数则为白色，奇数则为黑色。对于任意矩形，若面积为偶数，黑白格子数相等；若为奇数，取决于左下角颜色（白则白多1，黑则黑多1）。

- **题解思路**：先计算初始黑白格子数，再计算第一次涂白（增加原矩形的黑格子数）、第二次涂黑（减少原矩形的白格子数），最后调整交集部分（因交集被两次覆盖，需修正）。
- **核心难点**：如何准确计算矩形内的黑白格子数（奇偶性处理）、如何处理两次涂色的交集。
- **可视化设计**：用8位像素棋盘展示初始状态，动态涂色过程（白色覆盖用亮白色闪烁，黑色覆盖用深灰色覆盖），交集部分用黄色高亮，配合“叮”音效提示覆盖操作。

---

## 2. 精选优质题解参考

<eval_intro>
经过对多份题解的评估（思路清晰度、代码规范性、算法有效性），以下两份题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：作者Siyuan（赞：7）**
* **点评**：此题解思路简洁，直接通过数学公式计算矩形内黑白格子数，代码规范（如`getblack`和`getwhite`函数分离职责）。关键是处理两次涂色的交集时，通过`max`和`min`计算重叠区域，逻辑严谨。代码考虑了所有边界条件（如无交集情况），实践价值高，适合竞赛参考。

**题解二：作者Ted_Tong（赞：5）**
* **点评**：此题解详细处理了奇偶性对黑白格子数的影响（如`(achang & 1) && (akuan & 1)`判断），代码注释清晰，变量名易懂（如`achang`表示矩形长度）。通过分步计算初始值、第一次涂色、第二次涂色及交集修正，逻辑直观，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于准确计算矩形内的黑白格子数和处理两次涂色的交集。以下是关键步骤的分析：
</difficulty_intro>

1.  **关键点1：如何计算矩形内的黑白格子数？**
    * **分析**：对于矩形 $(x1,y1)$ 到 $(x2,y2)$，面积 $S=(x2-x1+1)*(y2-y1+1)$。若 $S$ 为偶数，黑白各 $S/2$；若 $S$ 为奇数，左下角 $(x1,y1)$ 若为白色（$x1+y1$ 偶数），则白色多1（$S/2+1$），否则黑色多1。
    * 💡 **学习笔记**：奇偶性决定了黑白格子的差值，左下角颜色是关键判断条件。

2.  **关键点2：如何处理两次涂色的交集？**
    * **分析**：两次涂色的交集区域会被先涂白再涂黑，因此需要修正：原涂白增加的黑格子数中，交集部分实际会被涂黑覆盖，需减去这部分。
    * 💡 **学习笔记**：交集区域的处理是容斥的核心，需用`max(x1,x3)`和`min(x2,x4)`等计算交集坐标。

3.  **关键点3：如何高效处理大规模数据？**
    * **分析**：因 $n,m$ 可达 $1e9$，必须用 $O(1)$ 公式计算，避免遍历。所有操作通过数学公式完成，无循环。
    * 💡 **学习笔记**：大规模数据问题需优先考虑数学规律，避免暴力枚举。

### ✨ 解题技巧总结
- **问题分解**：将问题拆解为初始值计算、第一次涂色、第二次涂色、交集修正四步，逐步解决。
- **函数封装**：将矩形内黑白格子数的计算封装为函数（如`getblack`），提高代码复用性。
- **边界判断**：用`max`和`min`快速判断交集是否存在，简化条件分支。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合Siyuan和Ted_Tong的思路，优化了变量命名和逻辑结构，适合竞赛直接使用。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    // 计算矩形(x1,y1)-(x2,y2)内的黑格子数
    long long get_black(int x1, int y1, int x2, int y2) {
        bool is_white = ((x1 + y1) % 2 == 0); // 左下角是否为白色
        long long area = (long long)(x2 - x1 + 1) * (y2 - y1 + 1);
        long long black = area / 2;
        if (area % 2 && !is_white) black++; // 奇数面积且左下角为黑，黑多1
        return black;
    }

    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            int n, m, x1, y1, x2, y2, x3, y3, x4, y4;
            scanf("%d%d", &n, &m);
            // 初始白格子数：总格子数/2（若奇数，白多1）
            long long white = (1LL * n * m + 1) / 2;
            
            scanf("%d%d%d%d", &x1, &y1, &x2, &y2); // 第一次涂白
            long long black_in_white_rect = get_black(x1, y1, x2, y2);
            white += black_in_white_rect; // 涂白增加的白格子数=原黑格子数
            
            scanf("%d%d%d%d", &x3, &y3, &x4, &y4); // 第二次涂黑
            long long white_in_black_rect = (1LL * (x4 - x3 + 1) * (y4 - y3 + 1)) - get_black(x3, y3, x4, y4);
            white -= white_in_black_rect; // 涂黑减少的白格子数=原白格子数
            
            // 处理交集
            int overlap_x1 = max(x1, x3), overlap_y1 = max(y1, y3);
            int overlap_x2 = min(x2, x4), overlap_y2 = min(y2, y4);
            if (overlap_x1 <= overlap_x2 && overlap_y1 <= overlap_y2) {
                long long black_in_overlap = get_black(overlap_x1, overlap_y1, overlap_x2, overlap_y2);
                white -= black_in_overlap; // 交集被涂黑，需减去原黑格子数（因已被涂白过）
            }
            
            printf("%lld %lld\n", white, 1LL * n * m - white);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先计算初始白格子数，然后处理第一次涂白（增加原矩形的黑格子数），接着处理第二次涂黑（减少原矩形的白格子数），最后修正交集部分（因交集被两次覆盖，需调整）。关键函数`get_black`通过奇偶性计算黑格子数，确保高效。

---
<code_intro_selected>
以下是优质题解的核心片段赏析：
</code_intro_selected>

**题解一：作者Siyuan**
* **亮点**：通过`getblack`和`getwhite`函数分离职责，代码结构清晰；用位运算判断奇偶性（`(x1+y1)&1`），高效简洁。
* **核心代码片段**：
    ```cpp
    long long getblack(int x1,int y1,int x2,int y2) {
        bool opt=(x1+y1)&1; // 左下角是否为黑色（x+y奇数）
        int n=x2-x1+1,m=y2-y1+1;
        if(opt) return 1LL*n*(m/2)+((m&1)?(n/2)+(n&1):0);
        else return 1LL*n*(m/2)+((m&1)?(n/2):0);
    }
    ```
* **代码解读**：`opt`表示左下角是否为黑色（`x1+y1`为奇数）。若为黑色，奇数宽度时黑格子数为`n*(m/2) + (n/2 + n%1)`（例如3x3矩形，黑格子5个）；否则为`n*(m/2) + (n/2)`（白格子多1）。此函数通过奇偶性快速计算黑格子数，避免遍历。
* 💡 **学习笔记**：函数封装是提高代码复用性的关键，位运算（`&1`）比`%2`更高效。

**题解二：作者Ted_Tong**
* **亮点**：分步处理涂色过程（初始值、第一次涂色、第二次涂色、交集修正），逻辑直观；变量名如`achang`（长度）、`akuan`（宽度）易懂。
* **核心代码片段**：
    ```cpp
    // 处理第一次涂白
    long long achang=ax2-ax1+1, akuan=ay2-ay1+1;
    white += (achang*akuan)/2;
    if ((achang & 1) && (akuan & 1) && ((ax1 & 1)!=(ay1 & 1))) {
        white++; // 奇数面积且左下角为黑，原黑格子多1，涂白后白格子多1
    }
    ```
* **代码解读**：`achang*akuan`是矩形面积，除以2得到基础白格子数（原黑格子数）。若面积奇数且左下角为黑（`(ax1 & 1)!=(ay1 & 1)`），则原黑格子多1，涂白后白格子需加1。此片段清晰展示了奇偶性对结果的影响。
* 💡 **学习笔记**：分步处理复杂问题，每一步单独验证，可降低错误率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解两次涂色和交集处理，我们设计一个8位像素风格的动画，模拟棋盘的动态变化过程。
</visualization_intro>

  * **动画演示主题**：`像素棋盘涂色大冒险`

  * **核心演示内容**：展示初始棋盘（黑白相间），第一次涂白矩形（亮白色覆盖），第二次涂黑矩形（深灰色覆盖），交集部分（黄色高亮）的修正过程。

  * **设计思路简述**：8位像素风（类似FC游戏）营造轻松氛围；关键步骤用颜色变化和音效强化记忆（如涂白时“叮”一声，涂黑时“咚”一声）；交集高亮帮助理解容斥逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 棋盘用16x16像素方块表示，白色（#FFFFFF）、黑色（#333333）交替排列，左下角（1,1）为白色。
          * 控制面板：单步/自动播放按钮、速度滑块（0.5x-2x）、重置按钮。

    2.  **初始状态展示**：
          * 显示初始白格子数（如“白：5，黑：4”），用文字气泡提示：“初始棋盘，黑白相间，左下角是白色哦~”。

    3.  **第一次涂白**：
          * 选中矩形区域（如(1,1)-(2,2)）用蓝色框标记，点击“涂白”后，该区域像素块闪烁3次（白色→原颜色→白色），最终变为亮白色（#FFFF99）。
          * 音效：每次闪烁播放“叮~”的短音效。
          * 数据更新：白格子数增加（如“白：5+2=7”），用文字显示计算过程。

    4.  **第二次涂黑**：
          * 选中矩形区域（如(1,1)-(2,2)）用红色框标记，点击“涂黑”后，该区域像素块从亮白色变为深灰色（#666666）。
          * 音效：播放“咚~”的短音效。
          * 数据更新：白格子数减少（如“白：7-2=5”），交集部分（若有）用黄色高亮并修正。

    5.  **交集修正**：
          * 若两次矩形有交集（如(1,1)-(2,2)），该区域像素块从深灰色变为黄色（#FFD700），闪烁2次后恢复深灰色。
          * 文字提示：“交集区域被两次覆盖，需要调整白格子数！”

    6.  **最终状态**：
          * 显示最终白格子和黑格子数（如“白：0，黑：4”），播放胜利音效（“啦~啦~”），像素烟花动画庆祝。

  * **旁白提示**：
      * （初始状态）“看！这是初始的棋盘，黑白交替，左下角是白色哦~”
      * （第一次涂白）“第一次涂白会把矩形内的黑格子变成白色，所以白格子数增加了原黑格子数~”
      * （交集修正）“注意！交集区域被先涂白再涂黑，需要减去多算的白格子数~”

<visualization_conclusion>
通过这个动画，你可以直观看到两次涂色如何影响棋盘，以及交集修正的必要性，轻松理解抽象的数学计算过程。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是矩形覆盖与容斥原理，这类思路可迁移到以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 矩形面积计算（如统计多个矩形覆盖的总面积）。
      * 颜色覆盖问题（如多次涂色后的最终颜色统计）。
      * 二维平面的容斥问题（如求多个矩形的并集面积）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1406** - `方格填数`  
          * 🗣️ **推荐理由**：涉及二维区域的覆盖与统计，需计算多个矩形的交集，巩固容斥原理。
    2.  **洛谷 P2213** - `献花`  
          * 🗣️ **推荐理由**：通过矩形覆盖计算最大连续区域，锻炼二维区间处理能力。
    3.  **洛谷 P3955** - `图书管理员`  
          * 🗣️ **推荐理由**：涉及矩形内特定条件的统计，需结合数学规律快速计算。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时容易忽略交集的奇偶性判断。例如，作者Siyuan提到：“最初忘记处理交集区域的奇偶性，导致测试用例失败。后来通过打印中间变量，发现交集的黑格子数计算错误。”
</insights_intro>

> **参考经验 (来自Siyuan)**：“在计算交集的黑格子数时，必须重新判断交集的左下角颜色，否则奇偶性会出错。调试时打印`overlap_x1 + overlap_y1`的值，发现与预期不符，才找到问题。”

**点评**：这位作者的经验提醒我们，在处理多步骤覆盖问题时，每个子区域（如交集）的属性（如左下角颜色）需要独立计算，不能直接复用父区域的属性。调试时打印关键变量（如交集的坐标和颜色）是定位错误的有效方法。

-----

<conclusion>
通过本次分析，你已掌握了如何计算矩形内的黑白格子数、处理两次涂色的交集，并理解了容斥原理的应用。编程时注意奇偶性判断和交集处理，多通过动画模拟验证思路。继续加油，你会更棒！💪
</conclusion>

---
处理用时：344.84秒
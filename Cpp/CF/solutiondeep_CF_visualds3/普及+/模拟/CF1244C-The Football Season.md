# 题目信息

# The Football Season

## 题目描述

Berland Capital Team 比了 $n$ 场比赛，总得分为 $p$。已知胜一场得 $w$ 分，平一场得 $d$ 分，败一场不得分。

求任意一组 $(x,y,z)$ 使得如果 Berland Capital Team 胜 $x$ 场，平 $y$ 场，败 $z$ 场时总分为 $p$。如果不存在这样的三元组，输出 $-1$。

### 形式化题意

求下列方程组的任意一组非负整数解，无解输出 $-1$：

$$
\begin{cases}
x\cdot w+y\cdot d=p\\
x+y+z=n
\end{cases}
$$

## 样例 #1

### 输入

```
30 60 3 1
```

### 输出

```
17 9 4
```

## 样例 #2

### 输入

```
10 51 5 4
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
20 0 15 5
```

### 输出

```
0 0 20
```

# AI分析结果



---
# 💡 Kay的C++算法解析：The Football Season 深入学习指南 💡

<introduction>
今天我们来一起分析“The Football Season”这道C++编程题。这道题需要我们找到满足特定条件的非负整数解，本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（不定方程非负整数解）`

🗣️ **初步分析**：
解决这道题的关键在于求解不定方程 \( w \cdot x + d \cdot y = p \) 的非负整数解，同时满足 \( x + y \leq n \)。简单来说，我们需要找到一组 \( (x, y) \)，使得胜利得分和平局得分之和等于总得分 \( p \)，且胜场与平局的总场次不超过总比赛数 \( n \)。

- **题解思路**：由于 \( d < w \)（平局得分严格小于胜利得分），可以证明若存在解，\( y \) 的取值范围必定在 \( [0, w) \) 内（否则可以通过调整 \( x \) 和 \( y \) 得到更优解）。因此，直接枚举 \( y \in [0, w-1] \)，计算对应的 \( x \) 并验证是否满足条件即可。
- **核心难点**：确定 \( y \) 的枚举范围，避免无效枚举；验证 \( x \) 的非负性及 \( x + y \leq n \) 的条件。
- **可视化设计**：通过像素动画展示枚举 \( y \) 的过程，每个 \( y \) 对应一个像素块，高亮当前计算的 \( y \) 值，动态显示 \( x \) 的计算结果及 \( x + y \) 是否满足 \( n \) 的限制。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、代码高效且易于理解，被选为优质参考（评分≥4星）。
</eval_intro>

**题解一：作者：AutumnKite**
* **点评**：此题解直接枚举 \( y \in [0, w) \)，思路简洁明了。代码通过取模运算快速判断 \( x \) 是否为整数，边界条件处理（如 \( x \geq 0 \)、\( x + y \leq n \)）严谨。时间复杂度 \( O(w) \)，在 \( w \leq 1e5 \) 时完全可行。代码变量命名清晰（如 \( x, y \) 直接对应题目中的变量），适合初学者学习。

**题解二：作者：lyb666666**
* **点评**：此题解详细推导了 \( y \) 的枚举范围（\( [0, w) \)），并解释了调整 \( x \) 和 \( y \) 的数学原理（通过 \( d \) 和 \( w \) 的交换减少 \( x + y \)）。代码使用 `for` 循环枚举 \( y \)，逻辑直接，关键步骤注释明确（如 `left = p - y*d`），易于理解。

**题解三：作者：123zbk**
* **点评**：此题解通过数学推导证明了 \( y \) 的枚举范围，代码结构紧凑，关键判断（如 `num % w != 0`）简洁高效。变量命名符合直觉（如 `num` 表示剩余得分），边界条件（\( x \geq 0 \)、\( x + y \leq n \)）处理到位，是典型的“暴力枚举+数学优化”解法。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何确定 \( y \) 的枚举范围？
    * **分析**：由于 \( d < w \)，若 \( y \geq w \)，则可以通过 \( d \) 个 \( x \) 替换 \( w \) 个 \( y \)（即 \( x \) 增加 \( d \)，\( y \) 减少 \( w \)），使得 \( x + y \) 更小。因此，只需枚举 \( y \in [0, w-1] \) 即可覆盖所有可能的解。
    * 💡 **学习笔记**：利用 \( d < w \) 的条件，缩小枚举范围，避免无效计算。

2.  **关键点2**：如何验证 \( x \) 的合法性？
    * **分析**：计算 \( x = \frac{p - d \cdot y}{w} \) 后，需验证 \( x \) 是否为非负整数（即 \( (p - d \cdot y) \) 能被 \( w \) 整除且结果非负），同时 \( x + y \leq n \)（确保 \( z = n - x - y \geq 0 \)）。
    * 💡 **学习笔记**：合法性验证需同时满足数学条件（整除、非负）和实际约束（总场次限制）。

3.  **关键点3**：如何处理大数溢出问题？
    * **分析**：题目中 \( p \) 的范围可达 \( 1e17 \)，需使用 `long long` 类型存储变量，避免计算时溢出（如 \( d \cdot y \) 可能超过 `int` 范围）。
    * 💡 **学习笔记**：涉及大数运算时，优先使用 `long long` 类型，并注意中间结果的溢出风险。

### ✨ 解题技巧总结
- **范围缩小技巧**：利用题目中 \( d < w \) 的条件，将 \( y \) 的枚举范围从无限缩小到 \( [0, w-1] \)，大幅降低时间复杂度。
- **快速验证技巧**：通过取模运算快速判断 \( (p - d \cdot y) \) 是否能被 \( w \) 整除，避免无效计算。
- **边界处理技巧**：验证 \( x \geq 0 \) 和 \( x + y \leq n \) 时，需同时考虑数学条件和实际意义（如 \( z \) 不能为负）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，通过枚举 \( y \in [0, w-1] \) 快速找到合法解，适用于题目给定的数据范围。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    typedef long long ll;

    int main() {
        ll n, p, w, d;
        scanf("%lld%lld%lld%lld", &n, &p, &w, &d);
        
        for (ll y = 0; y < w; ++y) {
            ll remaining = p - d * y;
            if (remaining < 0) continue; // 剩余得分不能为负
            if (remaining % w != 0) continue; // 必须能被w整除
            
            ll x = remaining / w;
            if (x + y > n) continue; // 总场次不能超过n
            
            ll z = n - x - y;
            printf("%lld %lld %lld\n", x, y, z);
            return 0;
        }
        
        puts("-1");
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入，然后枚举 \( y \) 从 0 到 \( w-1 \)。对于每个 \( y \)，计算剩余得分 \( remaining = p - d \cdot y \)，若剩余得分为负或无法被 \( w \) 整除则跳过；否则计算 \( x \)，并验证 \( x + y \leq n \)。若找到合法解，输出 \( x, y, z \)；否则输出 -1。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者：AutumnKite**
* **亮点**：代码简洁，通过 `while` 循环快速找到第一个合法的 \( y \)，边界条件处理严谨。
* **核心代码片段**：
    ```cpp
    while (y < a && (p - 1ll * b * y) % a) ++y;
    if (y == a) return puts("-1"), 0;
    x = (p - 1ll * b * y) / a;
    if (x < 0 || x + y > n) return puts("-1"), 0;
    ```
* **代码解读**：`while` 循环枚举 \( y \)，直到 \( (p - b \cdot y) \) 能被 \( a \) 整除或 \( y \) 超出范围。若找到合法 \( y \)，计算 \( x \) 并验证其非负性及 \( x + y \leq n \)。其中 `1ll * b * y` 避免了整数溢出。
* 💡 **学习笔记**：使用 `while` 循环可以提前终止枚举，提高效率；`1ll` 强制转换为长整型，防止中间结果溢出。

**题解二：作者：lyb666666**
* **亮点**：代码逻辑清晰，注释明确，通过 `for` 循环枚举 \( y \)，直接验证所有条件。
* **核心代码片段**：
    ```cpp
    for(int y=0;y<w;y++){
        int left=p-y*d;
        if(left%w)continue;
        int x=left/w;
        if(x>=0&&x+y<=n){
            printf("%lld %lld %lld\n",x,y,n-x-y);
            return 0;
        }
    }
    ```
* **代码解读**：`for` 循环枚举 \( y \)，计算剩余得分 `left`，若 `left` 能被 \( w \) 整除则计算 \( x \)，并验证 \( x \) 非负且 \( x + y \leq n \)。符合条件时输出结果。
* 💡 **学习笔记**：`for` 循环结构直观，适合需要遍历固定范围的场景；提前验证 `left` 的正负可避免无效计算。

**题解三：作者：123zbk**
* **亮点**：数学推导明确，代码紧凑，关键判断简洁。
* **核心代码片段**：
    ```cpp
    for(int y=0;y<w;y++){
        int num=p-y*d;
        if(num%w!=0) continue;
        int x=num/w;
        if(x>=0&&x+y<=n){
            printf("%lld %lld %lld",x,y,n-x-y);
            exit(0);
        }
    }
    ```
* **代码解读**：枚举 \( y \) 时，计算 `num = p - y*d`，若 `num` 能被 \( w \) 整除则计算 \( x \)，并验证 \( x \) 非负且总场次不超过 \( n \)。符合条件时输出结果并退出。
* 💡 **学习笔记**：使用 `exit(0)` 提前终止程序，避免不必要的循环；变量名 `num` 直观表示剩余得分。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举 \( y \) 并验证 \( x \) 的过程，我们设计一个“像素足球小能手”动画，用8位像素风格展示算法步骤！
</visualization_intro>

  * **动画演示主题**：`像素足球小能手的得分验证`

  * **核心演示内容**：展示枚举 \( y \) 的过程，每个 \( y \) 对应一个像素块，动态计算 \( x \) 并验证是否满足条件，最终找到合法解或提示无解。

  * **设计思路简述**：采用8位像素风格（如FC红白机色调），通过颜色变化和音效反馈关键操作（如找到合法 \( y \) 时的“叮”声），增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示像素化的足球场背景，右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。
        - 顶部显示当前 \( y \) 的值（像素数字），中间显示 \( x = (p - d \cdot y)/w \) 的计算过程（动态更新），底部显示 \( x + y \) 是否 \( \leq n \)（绿色“√”或红色“×”）。

    2.  **枚举 \( y \) 的过程**：
        - 每步枚举 \( y \) 时，对应 \( y \) 值的像素块高亮（如黄色闪烁），播放“滴答”音效。
        - 计算 \( remaining = p - d \cdot y \)，若 \( remaining < 0 \)，剩余得分像素块变红；若 \( remaining \% w \neq 0 \)，取模结果像素块变红。
        - 若 \( remaining \) 合法，计算 \( x \) 并验证 \( x + y \leq n \)：符合条件时，\( x, y, z \) 像素块变绿，播放“叮”音效；否则变灰。

    3.  **目标达成/无解提示**：
        - 找到合法解时，屏幕中央弹出“得分成功！”像素文字，播放胜利音效（如短旋律），并高亮 \( x, y, z \) 的值。
        - 枚举完所有 \( y \) 仍无解时，显示“未找到解”像素文字，播放提示音效（如短促“滴”声）。

  * **旁白提示**：
      - （枚举 \( y \) 时）“现在检查第 \( y \) 次平局，看看得分是否符合要求～”
      - （计算 \( x \) 时）“剩余得分 \( p - d \cdot y \) 必须能被 \( w \) 整除哦！”
      - （验证 \( x + y \leq n \) 时）“总场次 \( x + y \) 不能超过 \( n \)，否则败场数 \( z \) 会变成负数啦～”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到枚举 \( y \) 并验证 \( x \) 的每一步，轻松理解算法的核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的枚举+数学优化思路后，我们可以尝试解决更多类似的不定方程问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 本题的核心是通过缩小枚举范围（利用 \( d < w \) 的条件）快速找到解，类似思路可用于其他不定方程问题（如百钱买百鸡问题）。
      - 关键是找到变量的约束条件，将无限枚举转化为有限枚举。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036** - `选数`
          * 🗣️ **推荐理由**：通过枚举组合数并验证质数条件，练习有限枚举和数学验证的结合。
    2.  **洛谷 P1088** - `火星人`
          * 🗣️ **推荐理由**：涉及排列枚举和边界处理，锻炼枚举范围的确定能力。
    3.  **洛谷 P1149** - `火柴棒等式`
          * 🗣️ **推荐理由**：通过枚举可能的数字组合，验证火柴棒数量约束，与本题思路类似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如“一开始用exgcd爆long long，后来改用枚举”，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自多位作者)**：“使用exgcd时容易因大数运算溢出，而枚举法更直接且不易出错。”
>
> **点评**：在数据范围允许的情况下（如 \( w \leq 1e5 \)），枚举法往往比复杂算法更简单、更不易出错。遇到大数问题时，优先考虑缩小枚举范围或寻找数学优化条件。

-----

<conclusion>
本次关于“The Football Season”的C++解题分析就到这里。希望这份学习指南能帮助大家理解枚举+数学优化的解题思路，以及如何通过可视化更直观地掌握算法流程。记住，多思考、多练习，编程能力会一步步提升！下次见～💪
</conclusion>

-----

---
处理用时：351.05秒
# 题目信息

# Aerodynamic

## 题目描述

Guy-Manuel and Thomas are going to build a polygon spaceship.

You're given a strictly convex (i. e. no three points are collinear) polygon $ P $ which is defined by coordinates of its vertices. Define $ P(x,y) $ as a polygon obtained by translating $ P $ by vector $ \overrightarrow {(x,y)} $ . The picture below depicts an example of the translation:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1299B/83c2f1baf8b89730630e4ed629298d51b68af048.png)

Define $ T $ as a set of points which is the union of all $ P(x,y) $ such that the origin $ (0,0) $ lies in $ P(x,y) $ (both strictly inside and on the boundary). There is also an equivalent definition: a point $ (x,y) $ lies in $ T $ only if there are two points $ A,B $ in $ P $ such that $ \overrightarrow {AB} = \overrightarrow {(x,y)} $ . One can prove $ T $ is a polygon too. For example, if $ P $ is a regular triangle then $ T $ is a regular hexagon. At the picture below $ P $ is drawn in black and some $ P(x,y) $ which contain the origin are drawn in colored:

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1299B/7e534d615e6a5f78b53ffae5177d7d1ddaf49471.png)

The spaceship has the best aerodynamic performance if $ P $ and $ T $ are similar. Your task is to check whether the polygons $ P $ and $ T $ are [similar](https://tinyurl.com/vp5m7vl).

## 说明/提示

The following image shows the first sample: both $ P $ and $ T $ are squares. The second sample was shown in the statements.

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1299B/e9bf2b6bd412db56abfa4dcfff0f19e57982f841.png)

## 样例 #1

### 输入

```
4
1 0
4 1
3 4
0 3```

### 输出

```
YES```

## 样例 #2

### 输入

```
3
100 86
50 0
150 0```

### 输出

```
nO```

## 样例 #3

### 输入

```
8
0 0
1 0
2 1
3 3
4 6
3 6
2 5
1 3```

### 输出

```
YES```

# AI分析结果



---
# 💡 Kay的C++算法解析：Aerodynamic 深入学习指南 💡

<introduction>
今天我们来一起分析“Aerodynamic”这道C++编程题。这道题的关键在于判断多边形的特殊性质——中心对称性，进而确定其与另一个构造出的多边形是否相似。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`几何问题（中心对称性判断）`

🗣️ **初步分析**：
解决“Aerodynamic”这道题，关键在于理解题目中集合 \( T \) 的构造方式，并将问题转化为判断原多边形 \( P \) 是否为中心对称图形。  
简单来说，中心对称图形的定义是：存在一个中心点 \( O \)，使得对于图形上的任意点 \( A \)，其关于 \( O \) 的对称点 \( A' \) 也在图形上。就像“照镜子”一样，每个点都有一个“镜像伙伴”，且所有“镜子”的中点都重合。  

在本题中，集合 \( T \) 是所有包含原点的平移后的 \( P \) 的并集。通过数学推导（闵可夫斯基和的性质），可以发现 \( T \) 与 \( P \) 相似的充要条件是 \( P \) 为中心对称图形。因此，我们的任务转化为：判断给定的严格凸多边形 \( P \) 是否是中心对称的。  

核心算法流程非常简洁：  
1. 若顶点数 \( n \) 为奇数，直接输出“NO”（奇数个顶点无法成对对称）。  
2. 若 \( n \) 为偶数，取第 \( i \) 个顶点和第 \( i + n/2 \) 个顶点（共 \( n/2 \) 对），计算每对顶点的中点。若所有中点相同，则 \( P \) 是中心对称的，输出“YES”；否则输出“NO”。  

可视化设计思路：我们可以用像素动画展示多边形顶点，用不同颜色标记每对对称点（如红色和蓝色），并动态计算它们的中点（黄色圆点）。若所有中点重合（黄色圆点始终在同一位置），则触发“成功”音效；若某对中点偏离，触发“错误”音效并高亮该点对。动画支持单步播放，方便观察每对顶点的对称性。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：作者syksykCCC（赞：8）**
* **点评**：此题解从闵可夫斯基和的数学定义出发，逐步推导到中心对称的结论，逻辑严谨且易于理解。代码中使用浮点数精度判断（`EPS`），避免了整数运算的局限性，边界处理（如奇数顶点直接返回）非常严谨。其对问题本质的洞察（将复杂几何问题转化为中心对称判断）是最大亮点，适合学习如何从数学模型到代码实现的完整推导。

**题解二：作者lemonfor（赞：2）**
* **点评**：此题解语言简洁，直接抓住“中心对称”的核心条件，代码风格规范（结构体存储坐标、循环遍历对称点对）。虽然使用整数运算，但通过巧妙的和相等判断（`poi[i].x + poi[n/2+i].x == _x`）避免了浮点误差，适合理解对称点对的数学关系。

**题解三：作者ShineEternal（赞：1）**
* **点评**：此题解通过博客链接补充了题意的通俗解释，代码简洁明了（直接比较中点坐标），变量命名清晰（`p1`、`p2`表示基准中点）。其强调“输入点按逆时针排列”的特性，利用顺序直接配对对称点，是解题的关键技巧，值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：理解 \( T \) 的构造与中心对称性的关系**  
    * **分析**：题目中 \( T \) 是所有包含原点的平移后的 \( P \) 的并集。通过闵可夫斯基和的性质可知，\( T = P + (-P) \)（\( -P \) 是 \( P \) 的中心对称图形）。当 \( P \) 本身是中心对称时，\( T \) 与 \( P \) 相似（相似比为2）。优质题解通过数学推导明确了这一关系，避免了复杂的几何计算。  
    * 💡 **学习笔记**：复杂问题的解决往往需要先通过数学模型简化问题，找到关键性质（如本题的中心对称性）。

2.  **关键点2：正确配对对称点对**  
    * **分析**：题目保证输入点按逆时针顺序排列，因此对称点对的索引是 \( i \) 和 \( i + n/2 \)（如 \( n=4 \) 时，点1与点3，点2与点4对称）。优质题解利用这一特性直接配对，避免了额外的计算。  
    * 💡 **学习笔记**：题目中的“输入条件”（如顺序、严格凸性）往往隐含解题关键，需仔细阅读。

3.  **关键点3：处理浮点数精度问题**  
    * **分析**：当坐标为浮点数时，直接比较相等可能因精度误差出错。syksykCCC的题解使用 `EPS`（如 \( 1e-10 \)）判断是否接近，而lemonfor的题解通过和相等（整数运算）避免误差。根据输入数据类型选择合适的精度处理方式是关键。  
    * 💡 **学习笔记**：浮点比较时，用“差值小于极小值”替代“直接相等”更可靠。

### ✨ 解题技巧总结
- **问题转化**：将复杂几何问题转化为已知的数学性质（如中心对称性），简化计算。  
- **利用输入条件**：题目中“顶点按逆时针排列”的条件直接给出了对称点对的索引关系，避免了额外的配对逻辑。  
- **精度处理**：根据输入数据类型选择整数和或浮点误差判断，确保代码鲁棒性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用浮点数精度判断，适用于坐标为实数的情况，逻辑清晰且鲁棒性强。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e5 + 5;
    const double EPS = 1e-10; // 浮点精度阈值
    double x[N], y[N]; // 存储顶点坐标

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n;
        cin >> n;
        if (n % 2 != 0) { // 奇数顶点无法中心对称
            cout << "NO\n";
            return 0;
        }
        for (int i = 1; i <= n; ++i) {
            cin >> x[i] >> y[i];
        }
        int half = n / 2;
        // 计算基准中点（第一对顶点的中点）
        double base_x = (x[1] + x[1 + half]) / 2.0;
        double base_y = (y[1] + y[1 + half]) / 2.0;
        // 检查所有顶点对的中点是否与基准中点一致
        for (int i = 2; i <= half; ++i) {
            double cur_x = (x[i] + x[i + half]) / 2.0;
            double cur_y = (y[i] + y[i + half]) / 2.0;
            if (fabs(cur_x - base_x) > EPS || fabs(cur_y - base_y) > EPS) {
                cout << "NO\n";
                return 0;
            }
        }
        cout << "YES\n";
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先处理奇数顶点的特殊情况（直接输出NO），然后读取所有顶点坐标。通过计算第一对顶点的中点作为基准，遍历所有其他顶点对，检查其中点是否与基准中点一致（考虑浮点精度）。若全部一致，输出YES，否则输出NO。核心逻辑围绕“中心对称点对的中点相同”展开。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段，并点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：作者syksykCCC**
* **亮点**：明确使用浮点精度判断（`EPS`），避免因精度误差导致错误。
* **核心代码片段**：
    ```cpp
    double px = (x[1] + x[mid + 1]) / 2.0;
    double py = (y[1] + y[mid + 1]) / 2.0;
    bool ok = true;
    for(int i = 2; i <= mid; i++) {
        double kx = (x[i] + x[mid + i]) / 2.0;
        double ky = (y[i] + y[mid + i]) / 2.0;
        if(fabs(px - kx) >= EPS || fabs(py - ky) >= EPS) ok = false;
    }
    ```
* **代码解读**：  
  这段代码计算了基准中点（`px`, `py`），然后遍历所有顶点对，计算每对的中点（`kx`, `ky`），并通过`fabs`判断是否与基准中点的误差在`EPS`范围内。为什么这样写？因为浮点数的直接比较可能因精度问题出错，用差值是否小于极小值更可靠。例如，当坐标是`1.0000000001`和`0.9999999999`时，它们的中点是`1.0`，但直接比较可能因计算误差被误判，而`EPS`判断能容忍这种微小差异。  
* 💡 **学习笔记**：处理浮点数时，永远不要直接用`==`比较，而是判断差值是否小于一个极小的阈值（如`1e-10`）。

**题解二：作者lemonfor**
* **亮点**：使用整数运算，通过和相等判断避免浮点误差，适合坐标为整数的情况。
* **核心代码片段**：
    ```cpp
    _x = poi[1].x + poi[n / 2 + 1].x;
    _y = poi[1].y + poi[n / 2 + 1].y;
    rep(i ,1 ,n / 2) 
        if(poi[i].x + poi[n / 2 + i].x != _x || poi[i].y + poi[n / 2 + i].y != _y) {
            printf("NO");
            return 0;
        }
    ```
* **代码解读**：  
  这段代码将对称点对的和（`x1 + x2`, `y1 + y2`）作为判断依据。因为中心对称的点对满足`x1 + x2 = 2*ox`（`ox`为中心x坐标），所以所有点对的和必须相等。这种方法避免了浮点运算，适用于输入为整数的情况。例如，若基准和为`10`，其他点对的和也必须为`10`，否则不对称。  
* 💡 **学习笔记**：当输入为整数时，通过和相等判断可以简化计算，避免浮点精度问题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“中心对称性判断”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到每对顶点的对称性！
</visualization_intro>

  * **动画演示主题**：`像素对称小侦探`  
  * **核心演示内容**：展示多边形顶点，标记每对对称点，动态计算它们的中点，并判断是否重合。  

  * **设计思路简述**：采用8位像素风（如FC游戏画面），用不同颜色区分顶点和中点，通过动画和音效强化“对称”的概念。例如，对称点对用红蓝配对，中点用黄色圆点，重合时播放“叮”的音效，不重合时播放“滴”的提示音。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 像素屏幕显示一个8x8网格背景（复古绿调），顶部显示“对称小侦探”标题。  
        - 多边形顶点用彩色像素块表示（如红色、蓝色交替），按逆时针顺序排列。  
        - 控制面板包含“开始”、“单步”、“重置”按钮和速度滑块（1-5倍速）。

    2.  **输入顶点数据**：  
        - 输入顶点数`n`后，若`n`为奇数，屏幕弹出“奇数顶点无法对称！”的红色提示，播放“滴”音效。  
        - 若`n`为偶数，顶点自动排列在网格中，显示“开始检测对称点对”的文字提示。

    3.  **对称点对检测**（单步模式）：  
        - 第一步：选中第1个顶点（红色像素块闪烁），其对称点（第`n/2+1`个顶点，蓝色像素块）也开始闪烁。  
        - 动画显示两点之间的连线（虚线），并在中点位置生成黄色圆点（基准中点）。  
        - 播放“叮”音效，提示“基准中点已确定”。  
        - 后续步骤：依次选中第2、3...`n/2`个顶点，重复上述过程，比较当前中点与基准中点的位置。  
        - 若当前中点与基准中点重合（黄色圆点位置不变），播放“叮”音效；若偏离（黄色圆点移动），播放“滴”音效，高亮该点对并显示“发现不对称点对！”。

    4.  **结果展示**：  
        - 所有点对检测完成后，若全部对称，屏幕显示“YES！多边形是中心对称的！”，播放胜利音效（8位风格的旋律），顶点像素块集体闪烁庆祝。  
        - 若存在不对称点对，显示“NO！多边形不是中心对称的。”，并高亮问题点对。

  * **旁白提示**（动画中的文字气泡）：  
      - “看！红色点和蓝色点是一对对称点，它们的中点是黄色圆点~”  
      - “现在检查下一对点，它们的中点也应该是这个黄色圆点哦！”  
      - “糟糕，中点移动了！这对点不对称~”

<visualization_conclusion>
通过这样的像素动画，我们可以直观地看到每对顶点的对称性，以及中点是否重合的关键过程。这种“边看边学”的方式能帮助我们更快理解中心对称的概念！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考中心对称性在其他几何问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    中心对称性判断不仅适用于本题，还常用于：  
    - 判断图形是否为平行四边形（对边平行且相等，即中心对称）。  
    - 构造对称图形（如设计对称的建筑、艺术图案）。  
    - 解决几何最优化问题（如寻找对称点使路径最短）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1358** - `邮票`  
        * 🗣️ **推荐理由**：这道题需要判断矩形是否能通过平移覆盖所有点，涉及几何平移和对称的初步应用，适合巩固对平移变换的理解。  
    2.  **洛谷 P5436** - `【XR-2】缘分`  
        * 🗣️ **推荐理由**：此题需要判断两个圆是否有公共点，涉及几何位置关系的判断，能帮助理解几何问题中的对称性和位置关系。  
    3.  **洛谷 P3382** - `【模板】三分法`  
        * 🗣️ **推荐理由**：虽然是三分法模板题，但其中涉及的函数对称性分析能帮助我们更深入理解对称性质在优化问题中的应用。

-----

## 7\. 学习心得与经验分享

<insights_intro>
题解中作者们分享了对题意的理解和解题的关键，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自作者syksykCCC)**：“一开始没理解T的构造，后来通过闵可夫斯基和的性质才明白，T的形状与P的中心对称性直接相关。这让我意识到，复杂问题需要先找到数学模型，再转化为代码。”  
> **点评**：这位作者的经验告诉我们，遇到几何问题时，先通过数学推导明确问题本质（如本题的中心对称性），比直接编码更高效。这是解决复杂问题的关键思维。

-----

<conclusion>
本次关于“Aerodynamic”的C++解题分析就到这里。希望这份学习指南能帮助大家理解中心对称性的判断方法，以及如何将数学模型转化为代码实现。记住，几何问题的关键是“观察性质、简化模型”，多动手画图和推导会让你更高效！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：148.08秒
# 题目信息

# Long Legs

## 题目描述

A robot is placed in a cell $ (0, 0) $ of an infinite grid. This robot has adjustable length legs. Initially, its legs have length $ 1 $ .

Let the robot currently be in the cell $ (x, y) $ and have legs of length $ m $ . In one move, it can perform one of the following three actions:

- jump into the cell $ (x + m, y) $ ;
- jump into the cell $ (x, y + m) $ ;
- increase the length of the legs by $ 1 $ , i. e. set it to $ m + 1 $ .

What's the smallest number of moves robot has to make to reach a cell $ (a, b) $ ?

## 说明/提示

In the first testcase, the robot can first jump to $ (0, 1) $ , then to $ (1, 1) $ . If it ever increases the length of its legs, it will only be able to jump past $ (1, 1) $ .

In the second testcase, the robot can jump to $ (1, 0) $ , then increase the length of its length to $ 2 $ and jump three times to reach $ (1, 6) $ .

In the third testcase, the robot can increase the length of its legs three times to make it $ 4 $ . Then jump to $ (0, 4) $ . Then jump twice to reach $ (8, 4) $ .

## 样例 #1

### 输入

```
3
1 1
1 6
8 4```

### 输出

```
2
5
6```

# AI分析结果



---
# 💡 Kay的C++算法解析：Long Legs 深入学习指南 💡

<introduction>
今天我们来一起分析“Long Legs”这道C++编程题。机器人从(0,0)出发，通过调整步长跳跃到目标点(a,b)，如何找到最少步数？本指南将帮你梳理思路，掌握核心算法，并通过可视化理解关键步骤！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举优化与数学分析 (结合枚举与均值不等式的优化技巧)

🗣️ **初步分析**：
解决“Long Legs”的关键在于理解“步长k”的选择对总步数的影响。简单来说，我们需要枚举可能的最终步长k，计算对应的总步数，找到最小值。这就像买糖果时，选择合适的袋子大小（k），既不让袋子太大浪费装袋时间（增加k的步数），也不让袋子太小需要多次装（移动步数）。

- **题解思路**：所有优质题解均基于“枚举最终步长k”的核心思路。总步数公式为：`k-1（增加步长到k的步数） + ceil(a/k) + ceil(b/k)（移动步数）`。关键是如何高效枚举k，避免暴力全枚举。
- **核心难点**：如何确定k的合理范围？直接枚举到1e9显然不可行，但通过数学分析（均值不等式）可知，最优k大致在`sqrt(a+b)`附近，只需枚举该值附近的小范围即可。
- **可视化设计**：我们将设计一个“像素步长实验室”动画，用8位风格展示不同k值对应的总步数，通过颜色渐变（如绿色表示更优）突出最优k的选择过程，关键步骤（如计算ceil(a/k)）用像素气泡解释。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码效率和实践价值评估，以下3道题解值得重点学习：
</eval_intro>

**题解一：frelow_poem（来源：用户分享，赞24）**
* **点评**：此题解堪称“思路清晰+优化典范”！它详细推导了总步数公式的正确性，解释了“为何枚举k有效”，并通过均值不等式将枚举范围从3e5优化到`sqrt(a+b)`附近（仅需枚举±100），大幅提升效率。代码中`_setmin`函数和`delta`偏移量的设计体现了严谨的编程习惯，适合竞赛实战。

**题解二：VitrelosTia（来源：用户分享，赞2）**
* **点评**：此题解用“积一定，差小和小”的通俗比喻解释均值不等式，将复杂数学推导转化为易懂的生活场景。代码直接枚举`sqrt(a+b)`附近的k值（如±114），简洁高效，非常适合快速理解核心逻辑。

**题解三：Xy_top（来源：用户分享，赞6）**
* **点评**：此题解明确指出“最终步长k的最优性”，通过分析大数情况（如a,b=1e9）验证枚举上限的合理性（5e5），代码风格简洁，适合作为基础实现参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们常遇到以下关键点，掌握它们能帮你快速举一反三：
</difficulty_intro>

1.  **关键点1**：如何推导总步数公式？
    * **分析**：总步数由三部分组成：增加步长到k的步数（k-1）、x轴移动步数（ceil(a/k)）、y轴移动步数（ceil(b/k)）。即使a或b不能被k整除，也可通过“在步长增加到余数时补跳一步”的策略，将移动步数统一为上取整（ceil）。
    * 💡 **学习笔记**：上取整`ceil(a/k)`等价于`(a + k - 1) / k`（整数除法），这是编程中常用的技巧。

2.  **关键点2**：如何确定枚举k的范围？
    * **分析**：通过均值不等式，总步数近似为`(a+b)/k + k -1`，当k=√(a+b)时取最小值。因此，只需枚举该值附近的小范围（如±100）即可覆盖最优解，避免全枚举。
    * 💡 **学习笔记**：数学推导能大幅缩小枚举范围，这是优化算法的核心思想。

3.  **关键点3**：如何处理边界情况？
    * **分析**：当k=0时无意义，需确保k≥1；当a或b为0时（如起点就在目标点），移动步数为0。代码中需用`max(1, base - delta)`确保k的合法性。
    * 💡 **学习笔记**：边界条件的处理是代码鲁棒性的关键。

### ✨ 解题技巧总结
- **公式转换**：将上取整操作转换为整数除法（如`ceil(a/k) = (a + k - 1) / k`），简化计算。
- **数学优化**：利用均值不等式估算最优k的范围，将枚举次数从1e9降至200次左右。
- **代码简洁性**：使用`min`函数和预计算变量（如`base = sqrt(a+b)`）提升代码效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼一个高效且易懂的核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了frelow_poem和VitrelosTia的优化思路，通过均值不等式估算k的范围，仅枚举`sqrt(a+b)`附近±100的k值，确保高效性。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cmath>
    using namespace std;

    const int delta = 100; // 枚举偏移量，可调整
    const int inf = 2147483647;

    inline int ceil_div(int a, int k) {
        return (a + k - 1) / k; // 上取整等价于(a + k - 1) // k
    }

    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            int a, b;
            scanf("%d%d", &a, &b);
            int ans = inf;
            int base = (int)sqrt(a + b); // 估算最优k的基准值
            // 枚举基准值附近±delta的k值，确保k≥1
            for (int k = max(1, base - delta); k <= base + delta; ++k) {
                int steps = (k - 1) + ceil_div(a, k) + ceil_div(b, k);
                if (steps < ans) ans = steps;
            }
            printf("%d\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入，然后通过`sqrt(a+b)`估算最优k的基准值。接着枚举基准值附近±100的k值（确保k≥1），计算每个k对应的总步数（k-1 + x轴步数 + y轴步数），最终输出最小步数。`ceil_div`函数用整数运算实现上取整，避免浮点误差。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：frelow_poem**
* **亮点**：通过`delta`偏移量优化枚举范围，代码可扩展性强（调整`delta`即可适配不同数据）。
* **核心代码片段**：
    ```cpp
    int base = (int)sqrt(a+b);
    for (int i = max(1, base - delta); i <= base + delta; i++) {
        _setmin(ans, Solve(i));
    }
    ```
* **代码解读**：
    `base`是通过均值不等式估算的最优k值（`sqrt(a+b)`）。枚举`base`附近±`delta`的k值（如±100），覆盖可能的最优解。`max(1, ...)`确保k≥1，避免无效枚举。
* 💡 **学习笔记**：通过数学估算缩小枚举范围，是“暴力枚举”变“聪明枚举”的关键。

**题解二：VitrelosTia**
* **亮点**：用`ceil(1.0 * a / k)`直接计算上取整，代码简洁易懂。
* **核心代码片段**：
    ```cpp
    int now = m - 1 + ceil(1.0 * a / m) + ceil(1.0 * b / m);
    ans = min(ans, now);
    ```
* **代码解读**：
    `m-1`是增加步长到m的步数，`ceil(1.0 * a/m)`计算x轴移动步数（浮点除法后上取整）。直接使用库函数`ceil`，代码可读性高。
* 💡 **学习笔记**：浮点运算虽慢，但在小范围枚举中影响可忽略，适合快速实现。

**题解三：Xy_top**
* **亮点**：通过`swap(n, m)`确保a≤b，减少重复计算（可选优化）。
* **核心代码片段**：
    ```cpp
    if (n > m) swap(n, m);
    for (int i = 1; i <= 500000; i++) {
        ans = min(ans, int(ceil(n * 1.0 / i)) + int(ceil(m * 1.0 / i)) + i - 1);
    }
    ```
* **代码解读**：
    交换a和b确保a≤b（假设a≤b时计算更简单），枚举到5e5的k值（适用于早期未优化的情况）。
* 💡 **学习笔记**：预处理输入数据（如排序）可简化后续逻辑。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“枚举k找最优解”的过程，我们设计了“像素步长实验室”动画！让我们一起“看”到算法如何工作～
</visualization_intro>

  * **动画演示主题**：像素机器人的步长挑战（8位FC风格）
  * **核心演示内容**：展示不同k值对应的总步数，通过颜色渐变找到最小步数的k值。
  * **设计思路简述**：8位像素风格（红/绿/蓝三色调）营造复古感；关键步骤（如计算步数、更新最小值）用像素音效（“叮”声）和闪烁动画强化记忆；枚举范围用滑动条控制，学习者可手动调整`delta`观察影响。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧是像素网格（16x16像素块），显示目标点(a,b)（黄色星星标记）。
        - 右侧是控制面板：开始/暂停按钮、步数滑块（调整枚举速度）、k值显示框（当前枚举的k）。
        - 背景播放8位风格的轻快音乐（类似《超级马力欧》的跳跃音效）。

    2.  **枚举启动**：
        - 机器人（蓝色像素小人）出现在(0,0)，头顶显示当前k=1。
        - 计算总步数：k-1（显示为“+k-1”的像素文字）、x轴步数（绿色箭头向右跳）、y轴步数（粉色箭头向上跳），总步数用大字号显示在屏幕上方。

    3.  **核心枚举过程**：
        - k从`base-delta`开始枚举，每个k值对应一个像素条（高度为总步数，颜色从红到绿渐变，绿色表示更优）。
        - 当前k值用白色边框高亮，伴随“滴答”音效。
        - 当找到更小的总步数时，像素条变为亮绿色，播放“叮～”的胜利音效，机器人做庆祝动作（如挥手）。

    4.  **结果展示**：
        - 枚举结束后，最优k值（绿色最亮的像素条）和最小步数用金色边框突出。
        - 机器人按最优k值演示跳跃过程：先增加步长（m从1到k，像素数字递增），再向右/向上跳（箭头动画），最终到达目标点，播放“胜利”音乐。

  * **旁白提示**：
      - “看！当k=5时，总步数只有10步，比k=1时的30步少很多～”
      - “注意这个绿色条，它越亮说明总步数越小哦！”
      - “现在k在sqrt(a+b)附近，这里最可能藏着最优解～”

<visualization_conclusion>
通过这个动画，我们不仅能“看”到枚举k的过程，还能直观理解为什么最优k在sqrt(a+b)附近。下次遇到类似问题，你也能快速找到优化方向啦！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下题目，巩固“枚举优化+数学分析”的思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 枚举优化：类似“寻找最优参数”的问题（如分块大小、窗口长度），均可通过数学分析缩小枚举范围。
      - 数学推导：均值不等式、极值点分析可用于估算最优参数，常见于贪心、动态规划问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1024** - 一元三次方程求解
          * 🗣️ **推荐理由**：通过枚举根的范围，结合数学推导（导数找极值）缩小搜索区间，与本题思路类似。
    2.  **洛谷 P1873** - 砍树
          * 🗣️ **推荐理由**：二分枚举砍树高度，用数学公式计算总木材量，优化枚举效率。
    3.  **洛谷 P2678** - 跳石头
          * 🗣️ **推荐理由**：二分枚举最短跳跃距离，验证可行性，训练“枚举+验证”的优化思维。

-----

## 7\. 学习心得与经验分享

<insights_intro>
frelow_poem在题解中分享了优化枚举范围的思考过程：“最初枚举到3e5，后来发现通过均值不等式可以缩小到5e4，再到sqrt(a+b)附近，效率提升了10倍！”这对我们很有启发：
</insights_intro>

> **参考经验**：“优化枚举范围时，先通过数学公式找到理论最优值，再在附近枚举，能大幅减少计算量。例如，本题中sqrt(a+b)是理论最优k，枚举其附近±100的k值即可覆盖所有可能的最优解。”

**点评**：这位作者的经验告诉我们，数学推导是优化算法的“利器”。遇到枚举问题时，先分析公式的极值点，再缩小枚举范围，能让“暴力枚举”变得高效。下次写代码前，不妨先拿笔推导一下公式，可能会有意外收获哦！

-----

<conclusion>
本次“Long Legs”的分析就到这里。希望你不仅掌握了这道题的解法，更学会了“枚举优化+数学分析”的通用思路。记住，编程的魅力在于“用聪明的方法解决问题”，下次挑战见！💪
</conclusion>

---
处理用时：384.53秒
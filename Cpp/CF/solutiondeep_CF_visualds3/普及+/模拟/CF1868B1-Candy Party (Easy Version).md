# 题目信息

# Candy Party (Easy Version)

## 题目描述

有 $n$ 个人，第 $i$ 个人有 $a_i$ 颗糖，在派对上，每个人 **会且仅会做下面的事情恰好一次** ：

- 选一个正整数 $p\ (\ 1 \leq p \leq n\ )$ 和一个非负整数 $x$ ，然后把 $2^x$ 颗糖给第 $p$ 个人。注意任意时刻一个人手上的糖不能变成负数，并且一个人不能把糖给自己。
  

你需要回答能否在上述操作后让每个人手中的糖果数量相同。

注意本题和 Hard Version 不同的是本题中每个人必须从他人处接受恰好一次糖果，给出恰好一次糖果。

## 样例 #1

### 输入

```
6
3
2 4 3
5
1 2 3 4 5
6
1 4 7 1 5 4
2
20092043 20092043
12
9 9 8 2 4 4 3 5 1 1 1 1
6
2 12 7 16 11 12```

### 输出

```
Yes
Yes
No
Yes
No
No```

# AI分析结果

---
# 💡 Kay的C++算法解析：Candy Party (Easy Version) 深入学习指南 💡

<introduction>
  今天我们来一起分析「Candy Party (Easy Version)」这道C++编程题。这道题结合了**数学位运算**和**统计思维**，需要我们用“二进制的眼睛”看问题——听起来有点酷对不对？本指南会帮你拆解核心逻辑，掌握解题技巧，甚至用像素动画“看到”算法跑起来的样子！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（位运算与二次幂性质） + 统计`

🗣️ **初步分析**：
> 解决这道题的关键，在于理解“每个人的糖果变化必须是`2^x - 2^y`”——就像你有10颗糖，想变成7颗，得**给出8颗（2³）**同时**收到1颗（2⁰）**，净变化是-7（7=8-1）。而题目要求所有人最终糖果相等，所以我们需要：
   1. **先算平均值**：如果总糖果不能均分，直接“NO”（比如3个人有7颗糖，没法每人分整数）。
   2. **算每个人的“差”**：`b_i = 原糖果数 - 平均值`——正数表示要**多给出**糖果，负数表示要**多收到**糖果。
   3. **验证差的形式**：每个`b_i`必须能写成`2^x - 2^y`（比如b_i=3=4-1=2²-2⁰，b_i=-5=1-6？不对，应该是绝对值5=8-3？不，等下——其实是`|b_i|=2^x - 2^y`，正负决定x和y的顺序）。
   4. **统计供需平衡**：所有需要“给出2^k”的次数，必须等于“收到2^k”的次数（比如要给出8颗的人有3个，就得有3个人需要收到8颗）。

   - **核心难点**：怎么快速判断`|b_i|`是`2^x - 2^y`？怎么统计每个2的幂次的供需？
   - **解决方案**：用`lowbit`（找二进制最右边的1）！比如`|b_i|=k`，它的`lowbit`是`2^y`（最小的二次幂），然后`k+lowbit(k)`必须是另一个二次幂`2^x`——这样`k=2^x - 2^y`就成立啦！
   - **可视化设计思路**：我会用8位像素风做一个“糖果交换模拟器”——每个小人代表一个人，头顶显示糖果数；平均值算出来后，小人会变成“+”（要给出）或“-”（要收到）；然后用`lowbit`找“最小糖果块”，再组合成“大糖果块”；最后统计每个糖果块的数量，平衡就亮绿灯，否则亮红灯！还会加“叮”的音效（每次找lowbit）和“哗啦”的音效（统计完成）~

---

## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**、**代码可读性**、**算法有效性**三个维度筛选了3份优质题解，它们各有亮点，一起看看吧！
</eval_intro>

**题解一：Alex_Wei（洛谷CF1868B1题解）**
* **点评**：这份题解的代码像“特种兵”——简洁、高效、直击核心！作者用`cnt[31]`数组统计每个2的幂次的供需（比如`cnt[p]++`表示需要收到2^p，`cnt[p]--`表示需要给出2^p），用`__lg`（C++内置函数，求log2的整数部分）快速找二次幂的指数。最妙的是处理`b_i>0`和`b_i<0`的逻辑：正数时“给出大的，收到小的”，负数时反过来，直接用数组操作完成统计。代码里的`memset`和`continue`处理边界也很严谨，适合竞赛场景直接复用！

**题解二：One_JuRuo**
* **点评**：这位作者的思路像“侦探”——把问题拆得明明白白！他用`lowbit`函数直接判断`k+lowbit(k)`是不是二次幂（因为二次幂的lowbit等于自己），这个技巧太聪明了！比如`k=3`，lowbit是1，`3+1=4`，lowbit(4)=4，所以是二次幂。另外，作者用`map`统计供需，但其实用数组会更快（因为2的31次方已经够大了），不过思路完全正确，适合新手理解“键值对”的统计逻辑。

**题解三：Z1qqurat**
* **点评**：这份题解的代码像“散文”——优雅、易读！作者用`log2`计算x和y（比如`x = log2(c)+1`，`c=|b_i|`），然后验证`2^x -2^y == c`，逻辑很直观。变量命名也很友好：`cnt`数组、`NO`/`YES`宏定义，一看就懂。美中不足的是`log2`可能有精度问题（比如对大整数），但用`__lg`或者`lowbit`就完美了——不过思路还是值得学习！

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**位运算的理解**和**统计的准确性**。结合三个题解，我帮你提炼了3个“必想点”：
</difficulty_intro>

1.  **关键点1：如何判断`|b_i|`是`2^x - 2^y`？**
    * **分析**：所有题解都用了`lowbit`！比如`k=|b_i|`，它的`lowbit`是`2^y`（二进制最右边的1），然后`k+lowbit(k)`必须是`2^x`（因为`k=2^x-2^y` → `k+2^y=2^x`）。比如`k=5`，lowbit是1，`5+1=6`不是二次幂，所以5不能写成`2^x-2^y`，直接无解。
    * 💡 **学习笔记**：lowbit是“二进制小侦探”，能快速找到最小的二次幂！

2.  **关键点2：如何统计每个2的幂次的供需？**
    * **分析**：如果`b_i>0`（要多给出），说明`b_i=2^x -2^y`——需要**给出2^x**，**收到2^y**（所以`cnt[x]--`，`cnt[y]++`）；如果`b_i<0`（要多收到），说明`|b_i|=2^x -2^y`——需要**收到2^x**，**给出2^y**（所以`cnt[x]++`，`cnt[y]--`）。最后所有`cnt[i]`必须为0（供需平衡）。
    * 💡 **学习笔记**：统计的核心是“收支平衡”——每个糖果块的给出和收到次数必须一样！

3.  **关键点3：如何处理`b_i=0`的情况？**
    * **分析**：`b_i=0`的人糖果刚好是平均值，他们可以“转手”——比如A要给B 8颗，C是0，那就让A给C 8颗，C再给B 8颗。这样C既给出又收到，满足题目要求，所以直接忽略`b_i=0`的人就行！
    * 💡 **学习笔记**：“转手的人”不影响平衡，不用管他们~

### ✨ 解题技巧总结
-   **技巧A：用lowbit简化二次幂判断**：二次幂的lowbit等于自己（比如8的lowbit是8），用这个性质能快速验证`k+lowbit(k)`是不是二次幂。
-   **技巧B：用数组统计高频小范围值**：2的31次方足够覆盖题目中的数值，用`cnt[31]`数组比`map`快得多！
-   **技巧C：先判总均分，再处理细节**：总糖果不能均分直接返回“NO”，避免无用计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用实现**，它结合了Alex_Wei的数组效率和One_JuRuo的lowbit技巧，逻辑清晰！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了三个题解的思路，用`lowbit`判断二次幂，用数组`cnt`统计供需，适合新手学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    const int MAXN = 2e5 + 5;
    const int MAX_BIT = 31; // 2^31足够大

    long long a[MAXN];
    int cnt[MAX_BIT];

    inline long long lowbit(long long x) {
        return x & (-x);
    }

    bool solve(int n) {
        long long sum = 0;
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            sum += a[i];
        }
        if (sum % n != 0) return false; // 总糖果不能均分
        long long avg = sum / n;
        memset(cnt, 0, sizeof(cnt)); // 初始化统计数组

        for (int i = 0; i < n; ++i) {
            long long b = a[i] - avg;
            if (b == 0) continue; // 忽略刚好达标的人
            long long k = abs(b);
            long long lb = lowbit(k);
            long long k_plus_lb = k + lb;
            // 判断k_plus_lb是不是二次幂（lowbit等于自己）
            if (lowbit(k_plus_lb) != k_plus_lb) return false;
            // 计算x和y：k_plus_lb=2^x，lb=2^y
            int x = 0, y = 0;
            for (long long tmp = k_plus_lb; tmp > 1; tmp >>= 1) x++;
            for (long long tmp = lb; tmp > 1; tmp >>= 1) y++;
            // 统计供需：b正→给出x，收到y；b负→收到x，给出y
            if (b > 0) {
                cnt[x]--;
                cnt[y]++;
            } else {
                cnt[x]++;
                cnt[y]--;
            }
        }
        // 检查所有位的供需是否平衡
        for (int i = 0; i < MAX_BIT; ++i) {
            if (cnt[i] != 0) return false;
        }
        return true;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int T;
        cin >> T;
        while (T--) {
            int n;
            cin >> n;
            cout << (solve(n) ? "Yes" : "No") << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 读入数据并算总和，如果不能均分直接返回“NO”；
    > 2. 算平均值，初始化统计数组`cnt`；
    > 3. 遍历每个人，算`b_i`，忽略0；
    > 4. 用`lowbit`判断`|b_i|`是否是`2^x-2^y`；
    > 5. 统计每个2的幂次的供需；
    > 6. 检查所有位的供需是否平衡，平衡返回“YES”，否则“NO”。

---
<code_intro_selected>
接下来看三个题解的**核心片段**，每个都有“点睛之笔”！
</code_intro_selected>

**题解一：Alex_Wei的`cnt`数组处理**
* **亮点**：用`__lg`快速找二次幂的指数，代码简洁到“极致”！
* **核心代码片段**：
    ```cpp
    if(a[i] > 0) {
        int p = __lg(a[i] & -a[i]); // 找lowbit的指数y
        a[i] += 1 << p; // 变成k+lowbit(k)=2^x
        p = __lg(a[i] & -a[i]); // 找x
        a[i] -= 1 << p; // 恢复原k
        cnt[p]++; // 需要收到2^x
        cnt[__lg(a[i] & -a[i])]--; // 需要给出2^y
    }
    ```
* **代码解读**：
    > 这段代码的“魔法”在于`__lg`函数——它直接返回二进制中最高位1的位置（比如`__lg(8)=3`，因为8=2³）。作者先找`a[i]`的lowbit指数`y`，然后`a[i]+=2^y`得到`2^x`，再找`x`，最后调整`cnt`数组。比如`a[i]=3`（b_i=3），lowbit是1（y=0），`3+1=4`（x=2），所以`cnt[2]++`（收到4），`cnt[0]--`（给出1）——刚好对应3=4-1！
* 💡 **学习笔记**：`__lg`是C++17的内置函数，比自己写循环快得多！

**题解二：One_JuRuo的lowbit判断二次幂**
* **亮点**：用`lowbit(k_plus_lb) == k_plus_lb`直接判断二次幂，太巧妙了！
* **核心代码片段**：
    ```cpp
    k=abs(a[i]);low=lowbit(k);k+=low;
    if(k!=lowbit(k)) return 1; // 不是二次幂，无解
    ```
* **代码解读**：
    > 比如`k=3`，low=1，`k+low=4`，`lowbit(4)=4`，所以成立；`k=5`，low=1，`k+low=6`，`lowbit(6)=2≠6`，所以不成立。这个判断条件把“是不是二次幂”的问题简化成了一行代码——这就是位运算的魅力！
* 💡 **学习笔记**：二次幂的二进制只有一个1，所以lowbit等于自己！

**题解三：Z1qqurat的变量命名与宏定义**
* **亮点**：用`NO`/`YES`宏定义简化代码，变量名`cnt`/`avg`一看就懂！
* **核心代码片段**：
    ```cpp
    #define NO return cout << "No\n", void()
    #define YES return cout << "Yes\n", void()
    ...
    int x = log2(c) + 1, y = log2((1 << x) - c);
    if((1 << x) - (1 << y) != c) NO;
    ```
* **代码解读**：
    > 作者用`log2(c)+1`找`x`（比如`c=3`，`log2(3)≈1.58`，+1得2，对应2²=4），然后算`y=log2(4-3)=log2(1)=0`，再验证`4-1=3`是否等于`c`。虽然`log2`可能有精度问题，但思路很直观。宏定义`NO`/`YES`让代码更简洁，不用反复写`cout`！
* 💡 **学习笔记**：好的变量名和宏定义能让代码“会说话”！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”算法的每一步，我设计了一个**8位像素风的“糖果交换模拟器”**——像玩FC游戏一样学算法！
</visualization_intro>

  * **动画演示主题**：`像素小人的糖果派对`（仿《超级马里奥》的像素风格，背景是彩色的派对场景）

  * **核心演示内容**：
    - 展示每个人的初始糖果数→计算平均值→处理每个小人的“差”→用lowbit找“最小糖果块”→统计每个糖果块的供需→判断是否平衡。

  * **设计思路简述**：
    - 用8位像素风是因为它“复古又可爱”，能降低学习的“距离感”；
    - 每个操作加音效（比如计算平均值时“叮~”，找lowbit时“哔~”，统计完成时“哗啦~”），强化记忆；
    - 用“关卡”设计：每处理完一个小人算“过一小关”，完成所有统计算“通关”，增加成就感！

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧是`n`个像素小人（比如16x16的方块，带笑脸），每个小人头顶显示初始糖果数（比如“3”“4”“2”）；
          * 右侧是“控制面板”：有`开始`/`单步`/`重置`按钮，速度滑块（从“慢”到“快”），还有一个“糖果块统计栏”（显示每个2的幂次的数量，比如“2⁰:0”“2¹:0”...）；
          * 背景播放8位风格的《欢乐颂》BGM（轻量级，不干扰思考）。

    2.  **计算平均值**：
          * 点击`开始`后，所有小人的糖果数会“飞”到屏幕上方的“总和框”里，计算出平均值（比如总和9，n=3→平均值3）；
          * 播放“叮~”的音效，平均值会显示在屏幕中央，颜色变成金色。

    3.  **处理每个小人的“差”**：
          * 第一个小人（比如初始糖果4）会变成**蓝色**（因为`b_i=4-3=1>0`），头顶显示“+1”；
          * 第二个小人（初始糖果2）变成**红色**（`b_i=2-3=-1<0`），头顶显示“-1”；
          * 第三个小人（初始糖果3）变成**灰色**（`b_i=0`），头顶显示“√”；
          * 每个小人处理时播放“哔~”的音效。

    4.  **用lowbit找“最小糖果块”**：
          * 蓝色小人（+1）的“1”会分解成“2⁰”（一个小像素块），然后“1+1=2”（变成2¹）——显示“需要给出2¹，收到2⁰”；
          * 红色小人（-1）的“1”分解成“2⁰”，然后“1+1=2”——显示“需要收到2¹，给出2⁰”；
          * 分解过程用“闪烁”动画：小像素块从大数字里“跳出来”，颜色变成黄色。

    5.  **统计糖果块供需**：
          * “糖果块统计栏”里的`2¹`数量会变成“-1”（蓝色小人要给出）和“+1”（红色小人要收到），最后变成0；
          * `2⁰`数量变成“+1”（蓝色小人要收到）和“-1”（红色小人要给出），最后变成0；
          * 统计时播放“沙沙~”的音效，数字变化用“滑动”动画。

    6.  **结果判断**：
          * 如果所有统计数字都是0，屏幕中央会弹出“胜利！”的像素字，播放上扬的“啦啦啦~”音效，小人集体跳起来；
          * 如果有非0数字，弹出“失败！”的像素字，播放短促的“嘟嘟~”音效，对应的统计数字会闪烁红色。

    7.  **交互功能**：
          * `单步`按钮：逐帧播放每个小人的处理过程，适合仔细观察；
          * `速度滑块`：调整动画播放速度（最慢1秒/帧，最快0.1秒/帧）；
          * `重置`按钮：回到初始状态，重新开始。

  * **旁白提示**：
      * （计算平均值时）“总和是9，3个人分，每人3颗！”
      * （处理蓝色小人时）“这个小人多1颗糖，需要给出一个大糖果块，收到一个小糖果块~”
      * （统计完成时）“所有糖果块的供需都平衡啦，成功！”

<visualization_conclusion>
通过这个动画，你能**直观看到**每个步骤的变化——从平均值计算到lowbit分解，再到统计平衡。就像玩游戏一样，不知不觉就掌握了算法的核心逻辑！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的**位运算**和**统计思维**能解决很多类似问题，比如“判断数字的二进制特征”“统计某种元素的供需平衡”。下面是几道洛谷练习题，帮你巩固技巧！
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - `lowbit`可以用来解决“二进制中1的个数”“求最近的二次幂”等问题；
    - 统计供需平衡的思路可以用来解决“交换物品是否平衡”“资源分配是否合理”等问题；
    - 先判总条件（比如总糖果能否均分）的技巧，能避免无用计算，提高效率。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1226** - `快速幂`
          * 🗣️ **推荐理由**：这道题是位运算的基础练习，帮你熟悉二进制拆分的思路——和本题的`lowbit`异曲同工！
    2.  **洛谷 P1871** - `二次幂判断`
          * 🗣️ **推荐理由**：直接考察“如何判断一个数是不是二次幂”，用本题学的`lowbit`技巧能轻松解决！
    3.  **洛谷 P2068** - `统计次数`
          * 🗣️ **推荐理由**：考察统计思维，需要统计每个数字出现的次数——和本题的`cnt`数组用法一样！
    4.  **洛谷 CF1201B** - `Zero Array`
          * 🗣️ **推荐理由**：类似的“供需平衡”问题，需要判断能否通过操作让数组全为0——思路和本题高度相似！

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，作者们都没有分享具体的调试心得或踩坑经历，但从代码中能看出他们的“严谨”——比如`memset`初始化数组、`continue`处理`b_i=0`的情况、用`long long`避免溢出。这些细节都是编程的“基本功”，值得我们学习！
</insights_intro>

---

<conclusion>
本次关于「Candy Party (Easy Version)」的分析就到这里啦！这道题的核心是**用位运算看问题**和**统计供需平衡**——只要掌握了这两个点，就能轻松解决。记住：编程就像解谜，每一步都要“看清楚”问题的本质。下次我们再一起挑战更难的题目，加油！💪
</conclusion>

---

---
处理用时：142.81秒
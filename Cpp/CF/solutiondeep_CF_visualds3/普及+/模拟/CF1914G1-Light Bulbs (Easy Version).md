# 题目信息

# Light Bulbs (Easy Version)

## 题目描述

The easy and hard versions of this problem differ only in the constraints on $ n $ . In the easy version, the sum of values of $ n^2 $ over all test cases does not exceed $ 10^6 $ . Furthermore, $ n $ does not exceed $ 1000 $ in each test case.

There are $ 2n $ light bulbs arranged in a row. Each light bulb has a color from $ 1 $ to $ n $ (exactly two light bulbs for each color).

Initially, all light bulbs are turned off. You choose a set of light bulbs $ S $ that you initially turn on. After that, you can perform the following operations in any order any number of times:

- choose two light bulbs $ i $ and $ j $ of the same color, exactly one of which is on, and turn on the second one;
- choose three light bulbs $ i, j, k $ , such that both light bulbs $ i $ and $ k $ are on and have the same color, and the light bulb $ j $ is between them ( $ i < j < k $ ), and turn on the light bulb $ j $ .

You want to choose a set of light bulbs $ S $ that you initially turn on in such a way that by performing the described operations, you can ensure that all light bulbs are turned on.

Calculate two numbers:

- the minimum size of the set $ S $ that you initially turn on;
- the number of sets $ S $ of minimum size (taken modulo $ 998244353 $ ).

## 样例 #1

### 输入

```
4
2
2 2 1 1
2
1 2 2 1
2
1 2 1 2
5
3 4 4 5 3 1 1 5 2 2```

### 输出

```
2 4
1 2
1 4
2 8```

# AI分析结果

# 💡 Kay的C++算法解析：Light Bulbs (Easy Version) 深入学习指南 💡

<introduction>
  今天我们来一起分析“Light Bulbs (Easy Version)”这道C++编程题。题目需要我们找到最少的初始点亮灯的集合，让所有灯都能通过规则亮起，并计算这样的集合数量。本指南将帮你梳理思路、理解核心算法，还有好玩的像素动画演示哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：哈希（异或哈希）、贪心划分、乘法计数

🗣️ **初步分析**：
解决这道题的关键，是把“灯的点亮问题”转化为**找闭合块**——每个闭合块内的灯可以通过规则全部点亮，只需选一个初始点。

我们用**异或哈希**来快速划分闭合块：给每个颜色分配一个唯一的64位随机数（比如颜色1是`a`，颜色2是`b`）。两个相同颜色的数异或会抵消（`a^a=0`），所以**前缀异或和为0的位置**，说明前i个灯构成一个闭合块（每个颜色恰好出现两次）。例如序列`[2,2,1,1]`的前缀异或是`0→a→0→b→0`，对应两个闭合块，所以最少需要亮2个灯（每个块选一个）。

**核心难点与解决**：
1. **划分闭合块**：用前缀异或和找0的位置，O(n)时间搞定。
2. **统计可选点**：用`lst`字典记录每个前缀和的最后位置，通过“跳跃”这些位置（`j = lst[cur[j]] + 1`），自动跳过子块（比如`[2,2]`这样的小闭合块），统计每个块的可选点数量。

**可视化设计思路**：
我们做一个**8位像素风的“灯阵解谜”动画**：
- 用像素块表示灯（颜色对应题目中的颜色），前缀和用彩色进度条显示。
- 前缀和为0的位置用“金色边框”标记闭合块，“魔法箭头”跳跃`lst`位置时播放“叮”的音效，最后用“绿色高亮”标记可选点。
- 自动演示模式像“贪吃蛇AI”一样，逐步展示算法过程，完成后播放“胜利”音效！


## 2. 精选优质题解参考

<eval_intro>
我筛选了3份优质题解，覆盖了不同的思考角度，帮你全面理解问题：
</eval_intro>

**题解一：Eibon的异或哈希解法（来源：综合题解内容）**
* **点评**：这份题解是本题的“最优解模板”！它用异或哈希快速划分闭合块，用`lst`字典记录前缀和的最后位置，O(n)时间统计可选点。代码逻辑清晰（变量名`cur`代表前缀和、`lst`代表最后位置），边界处理严谨（比如`cur[0]=0`的初始化），直接可以用于竞赛。最棒的是，它通过“跳跃”`lst`位置，自动跳过子块，避免了复杂的子块判断。

**题解二：Erica的最小偶数序列分析（来源：综合题解内容）**
* **点评**：这道题解帮你理解问题的“本质”！它提出“最小偶数序列”（不能拆分成更小闭合块的序列），并指出可选点不能是子序列中的点（比如样例2中的`[2,2]`子块里的点不能选，否则无法点亮整个块）。虽然没有代码，但这种“分层”思路让你更清楚算法的正确性。

**题解三：huangrenhe的并查集解法（来源：综合题解内容）**
* **点评**：这份题解用并查集维护“等效块”（选一个点就能点亮的所有点），思路直观。比如序列`[1,2,1,2]`中的所有点属于同一个等效块，选任何一个点都能点亮整个块。但并查集的时间复杂度是O(n²)，不如异或哈希高效，但提供了另一种思考角度。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，你会遇到3个核心难点。结合优质题解，我总结了对应的“解题秘诀”：
</difficulty_intro>

1.  **难点1：如何快速划分闭合块？**
    * **分析**：闭合块的本质是“每个颜色出现偶数次”，而异或哈希的前缀和为0正好满足这个条件（相同颜色异或两次抵消）。给颜色x分配随机数`w[x]`，前缀和`cur[i] = cur[i-1] ^ w[x_i]`，当`cur[i]=0`时，前i个灯构成闭合块。
    * 💡 **学习笔记**：异或哈希是处理“偶数次出现”问题的神器！

2.  **难点2：如何计算每个块的可选点数量？**
    * **分析**：可选点不能在子块里（比如样例2中的`[2,2]`），否则无法点亮整个块。我们用`lst`字典记录每个前缀和的最后位置，通过“跳跃”这些位置（`j = lst[cur[j]] + 1`），自动跳过子块，统计“顶级段”数量（可选点数量）。
    * 💡 **学习笔记**：记录“最后出现位置”是处理重叠区间的常用技巧！

3.  **难点3：如何避免哈希冲突？**
    * **分析**：如果两个不同颜色分配了相同的随机数，会导致错误。我们用`mt19937_64`生成64位随机数，冲突概率极低，可以忽略不计。
    * 💡 **学习笔记**：用足够长的随机数可以避免哈希冲突！

### ✨ 解题技巧总结
- **技巧A：问题转化**：把“灯的点亮问题”转化为“找闭合块”，用异或哈希简化计算。
- **技巧B：记录最后位置**：用字典记录前缀和的最后位置，快速跳过子块。
- **技巧C：乘法计数**：方案数是各块可选点数量的乘积（每个块的选择独立）。


## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看Eibon的完整代码——它是本题的“标准答案”，逻辑清晰、高效：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自Eibon的题解，用异或哈希和`lst`字典快速解决问题，是本题的最优实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MOD = 998244353;
    mt19937_64 rnd(random_device{}());

    ll get_rand() {
        ll x;
        do {
            x = rnd();
        } while (x == 0);
        return x;
    }

    void solve() {
        int n;
        cin >> n;
        vector<ll> w(n + 1); // w[x]是颜色x的随机数
        for (int x = 1; x <= n; ++x) {
            w[x] = get_rand();
        }
        vector<ll> cur(2 * n + 1, 0); // 前缀异或和，cur[0]=0
        map<ll, int> lst; // 记录每个cur值最后一次出现的位置
        lst[cur[0]] = 0;
        int ans1 = 0;
        for (int i = 1; i <= 2 * n; ++i) {
            int x;
            cin >> x;
            cur[i] = cur[i - 1] ^ w[x];
            lst[cur[i]] = i; // 更新最后位置
            if (cur[i] == 0) {
                ans1++;
            }
        }
        ll ans2 = 1;
        for (int i = 0; i < 2 * n; ++i) {
            if (cur[i] != 0) continue;
            int j = i + 1;
            int res = 1;
            while (cur[j] != 0) {
                j = lst[cur[j]] + 1;
                res++;
            }
            ans2 = ans2 * res % MOD;
        }
        cout << ans1 << " " << ans2 << endl;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int T;
        cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三部分：1. 生成颜色的随机数；2. 计算前缀异或和，划分闭合块（统计`ans1`，即最小初始灯数）；3. 统计每个块的可选点数量（计算`ans2`，即方案数）。核心是`cur`数组（前缀异或和）和`lst`字典（最后位置）。


<code_intro_selected>
接下来，我们剖析代码中的“灵魂片段”——前缀异或和计算和可选点统计：
</code_intro_selected>

**题解一：Eibon的异或哈希解法**
* **亮点**：用异或哈希和`lst`字典，O(n)时间解决问题。
* **核心代码片段（前缀异或和计算）**：
    ```cpp
    vector<ll> cur(2 * n + 1, 0);
    map<ll, int> lst;
    lst[cur[0]] = 0;
    int ans1 = 0;
    for (int i = 1; i <= 2 * n; ++i) {
        int x;
        cin >> x;
        cur[i] = cur[i - 1] ^ w[x];
        lst[cur[i]] = i;
        if (cur[i] == 0) {
            ans1++;
        }
    }
    ```
* **代码解读**：
    > 1. `cur[0] = 0`：初始时没有灯，前缀和为0。
    > 2. 遍历每个灯`i`，读入颜色`x`，计算`cur[i]`（前i个灯的异或和）。
    > 3. 更新`lst[cur[i]] = i`：记录这个前缀和最后一次出现的位置（比如`cur[1] = a`，`lst[a] = 1`；如果后面`cur[3] = a`，`lst[a]`会更新为3）。
    > 4. 如果`cur[i] == 0`，说明前i个灯构成闭合块，`ans1`加1（最小初始灯数增加）。
    > 比如样例1中的`i=2`（`cur[2]=0`）和`i=4`（`cur[4]=0`），`ans1`最终是2。
* 💡 **学习笔记**：前缀异或和是划分闭合块的“钥匙”！

* **核心代码片段（可选点数量统计）**：
    ```cpp
    ll ans2 = 1;
    for (int i = 0; i < 2 * n; ++i) {
        if (cur[i] != 0) continue;
        int j = i + 1;
        int res = 1;
        while (cur[j] != 0) {
            j = lst[cur[j]] + 1;
            res++;
        }
        ans2 = ans2 * res % MOD;
    }
    ```
* **代码解读**：
    > 1. 遍历每个闭合块的起点`i`（`cur[i] == 0`）。
    > 2. `j`从`i+1`开始，`res`初始为1（至少有一个可选点）。
    > 3. 当`cur[j] != 0`时，`j`跳到`lst[cur[j]] + 1`（前缀和`cur[j]`最后一次出现的位置+1），`res`加1（跳过一个子块）。
    > 4. 循环结束后，`res`是这个块的可选点数量，乘到`ans2`中（模`MOD`）。
    > 比如样例2中的`i=0`：`j=1`→`cur[j]=a`→`lst[a]=3`→`j=4`→`res=2`，`ans2`最终是2。
* 💡 **学习笔记**：跳跃`lst`位置，自动跳过子块，得到可选点数量！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让你“亲眼看到”算法的过程，我设计了一个**8位像素风的“灯阵解谜”动画**，融合复古游戏元素，好玩又好懂！
\</visualization\_intro\>

  * **动画演示主题**：像素探险家在“灯阵”中寻找闭合块，用“魔法箭头”统计可选点。
  * **核心演示内容**：展示灯阵、前缀异或和计算、闭合块划分、可选点统计的全流程。
  * **设计思路**：用FC游戏的色彩和音效，让算法“活”起来——比如红色代表颜色1，蓝色代表颜色2，金色代表闭合块，“叮”的音效提示跳跃，“哇”的音效提示找到可选点。

  * **动画帧步骤与交互**：

    1. **场景初始化**：
       - 左侧是8位像素灯阵（比如样例1的4个灯，颜色为蓝、蓝、红、红），右侧是控制面板（开始/暂停、单步、重置、速度滑块）。
       - 背景播放8位风格BGM（比如《超级马里奥》的背景音乐）。

    2. **前缀异或和计算**：
       - 逐个点亮灯阵中的灯，下方的“前缀和进度条”同步变化（比如蓝色灯对应`a`，进度条变蓝；红色灯对应`b`，进度条变紫）。
       - 当前缀和为0时，灯阵周围出现“金色边框”，播放“叮”的音效，提示“闭合块完成”（比如样例1的前2个灯，进度条变0，金色边框出现）。

    3. **跳跃统计可选点**：
       - 用“像素箭头”从块的起点`i+1`开始（比如样例2的`i=0`，箭头从位置1出发）。
       - 箭头跳到`lst[cur[j]] + 1`的位置（比如样例2的`j=1`→`lst[a]=3`→箭头跳到4），每跳一次闪烁并播放“叮”的音效。
       - 跳跃结束后，用“绿色高亮”标记可选点（比如样例2的位置1和4），播放“哇”的音效，提示“可选点找到！”。

    4. **自动演示模式**：
       - 点击“自动演示”，动画像“贪吃蛇AI”一样自动完成所有步骤，最后屏幕中央显示答案（比如样例1的`2 4`），播放“胜利”音效（比如《塞尔达传说》的胜利音乐）。

  * **旁白提示**：
    - （计算前缀和时）“现在计算前i个灯的异或和，看进度条的颜色变化！”
    - （前缀和为0时）“金色边框出现啦！前i个灯构成闭合块！”
    - （跳跃时）“魔法箭头要跳啦！跳过子块，找到可选点！”
    - （找到可选点时）“绿色高亮的灯就是可选点，选它们就能点亮整个块！”

\<visualization\_conclusion\>
通过这个动画，你可以清晰看到**异或哈希如何划分块**、**魔法箭头如何跳跃统计可选点**。复古的像素风格和有趣的音效，让算法学习不再枯燥！


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
异或哈希和闭合块的思路，还能解决很多类似问题。比如：
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：
    - **问题1**：判断字符串是否由重复子串构成（比如“abab”是“ab”重复两次）。
    - **问题2**：寻找数组中出现奇数次的元素（异或所有元素，结果就是目标元素）。
    - **问题3**：划分序列为多个子序列，每个子序列元素出现偶数次。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1937** - 仓配置
          * 🗣️ **推荐理由**：需要划分闭合块，巩固异或哈希的应用。
    2.  **洛谷 P2661** - 信息传递
          * 🗣️ **推荐理由**：找环问题，锻炼划分能力。
    3.  **洛谷 P3405** - 字符串比较
          * 🗣️ **推荐理由**：处理字符串重复子串，拓展异或哈希的应用。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
Eibon的题解中提到“用异或哈希判断偶数次出现”，这是非常有用的技巧：
\</insights\_intro\>

> **参考经验 (来自Eibon)**：“判断一个数是否出现偶数次，可以使用异或哈希。”
>
> **点评**：异或哈希把“偶数次出现”转化为“异或和为0”，不仅高效，而且代码简洁。比如本题中的颜色出现两次，异或两次就抵消了，前缀和为0的位置正好是闭合块的结束。这种“转化思维”是编程的关键！


\<conclusion\>
本次分析就到这里啦！希望你能掌握**异或哈希**、**闭合块划分**和**乘法计数**的思路。记住：编程的本质是“把复杂问题转化为简单模型”——比如本题把“灯的点亮问题”转化为“找闭合块”。下次遇到类似问题，不妨试试异或哈希！💪
\</conclusion\>

---
处理用时：370.63秒
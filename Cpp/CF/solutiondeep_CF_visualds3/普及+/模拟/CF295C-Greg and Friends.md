# 题目信息

# Greg and Friends

## 题目描述

One day Greg and his friends were walking in the forest. Overall there were $ n $ people walking, including Greg. Soon he found himself in front of a river. The guys immediately decided to get across the river. Luckily, there was a boat by the river bank, just where the guys were standing. We know that the boat can hold people with the total weight of at most $ k $ kilograms.

Greg immediately took a piece of paper and listed there the weights of all people in his group (including himself). It turned out that each person weights either 50 or 100 kilograms. Now Greg wants to know what minimum number of times the boat needs to cross the river to transport the whole group to the other bank. The boat needs at least one person to navigate it from one bank to the other. As the boat crosses the river, it can have any non-zero number of passengers as long as their total weight doesn't exceed $ k $ .

Also Greg is wondering, how many ways there are to transport everybody to the other side in the minimum number of boat rides. Two ways are considered distinct if during some ride they have distinct sets of people on the boat.

Help Greg with this problem.

## 说明/提示

In the first test Greg walks alone and consequently, he needs only one ride across the river.

In the second test you should follow the plan:

1. transport two $ 50 $ kg. people;
2. transport one $ 50 $ kg. person back;
3. transport one $ 100 $ kg. person;
4. transport one $ 50 $ kg. person back;
5. transport two $ 50 $ kg. people.

That totals to $ 5 $ rides. Depending on which person to choose at step 2, we can get two distinct ways.

## 样例 #1

### 输入

```
1 50
50
```

### 输出

```
1
1
```

## 样例 #2

### 输入

```
3 100
50 50 100
```

### 输出

```
5
2
```

## 样例 #3

### 输入

```
2 50
50 50
```

### 输出

```
-1
0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Greg and Friends 深入学习指南 💡

<introduction>
今天我们来一起分析“Greg and Friends”这道经典的过河问题。这道题不仅需要计算最少渡河次数，还要统计最少次数下的方案数，非常考验我们对动态规划（DP）和组合数的灵活运用。本指南将帮你梳理核心思路，拆解关键步骤，并通过有趣的像素动画直观理解算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划（DP）与组合数应用`

🗣️ **初步分析**：
解决这道题的关键在于用动态规划（DP）跟踪每一步的状态变化，并结合组合数计算方案数。简单来说，动态规划就像“记录每一步的可能状态”，而组合数则是“计算选择不同人的方式”。例如，你可以想象自己是一个“状态记录员”，每一步都要记录当前两岸的人数、船的位置，以及到达这个状态的方案数。

- **题解思路**：题目要求最少次数和方案数，核心是用DP状态表示“当前未过河的50kg和100kg人数，以及船的位置”，通过枚举每次过河的人数（50kg和100kg的组合），逐步转移状态，直到所有人过河。不同题解的差异主要在于状态定义的细节（如船的位置是否显式记录）和转移逻辑的实现方式。
- **核心难点**：如何设计状态以覆盖所有可能的过河情况，如何正确计算每次过河的组合数（即选择哪些人上船的方案数），以及如何在DP中找到最小的渡河次数。
- **可视化设计**：我们将设计一个8位像素风格的动画，用不同颜色的像素块表示50kg（绿色）和100kg（红色）的人，船（黄色方块）在两岸移动。每次过河时，选中的人会闪烁并移动到对岸，同时屏幕下方显示当前次数和方案数。关键步骤（如返回取人、组合数计算）会用音效（“叮”声）提示。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等方面的评估，以下3道题解（评分≥4星）值得重点学习：
</eval_intro>

**题解一：gesong的动态规划解法 (来源：洛谷CF295C题解)**
* **点评**：此题解状态定义明确（`f[i][j][k]`表示第i次过程后，未过河的50kg有j人、100kg有k人的方案数），转移逻辑清晰区分了“到达对岸”（奇数次过程）和“返回出发岸”（偶数次过程）两种情况。代码预处理了组合数（`C`数组），规范地处理了模运算，边界条件（初始状态`f[0][x][y]=1`）和终止条件（检查`f[i][0][0]`是否非零）设计严谨。从实践角度看，代码可直接用于竞赛，且通过限制最大次数（`4n`）避免了无效计算，是典型的高效DP实现。

**题解二：zztqwq的状态压缩DP解法 (来源：独立题解)**
* **点评**：此题解将船的位置（`pos`）作为状态的一维（0为出发岸，1为对岸），状态定义更简洁（`f(pos,j,k)`表示船在pos岸、对岸有j个50kg和k个100kg的方案数）。转移时分别处理船在出发岸和对岸的情况，逻辑对称且易于理解。代码预处理组合数的方式（`binom`函数）规范，循环结构清晰，通过枚举轮数（`i`）逐步推进状态，最终检查`f(i%2, tot5, tot1)`是否非零来判断是否完成过河。此解法在状态定义上更直观，适合新手学习。

**题解三：SevenDawns的BFS+DP结合解法 (来源：独立题解)**
* **点评**：此题解创新性地将BFS（广度优先搜索）与DP结合，用队列（`sh`数组）记录状态，同时维护`step`数组（记录到达该状态的最少次数）和`dp`数组（记录方案数）。BFS天然适合寻找最短路径（即最少次数），而DP用于累计方案数，两者结合高效解决了“最少次数”和“方案数”两个问题。代码中对状态更新的处理（如步数相同时累加方案数）体现了严谨性，适合理解多算法结合的解题思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我们提炼了对应的策略：
</difficulty_intro>

1.  **关键点1：如何定义DP状态？**
    * **分析**：状态需要包含当前未过河的50kg人数（j）、100kg人数（k），以及船的位置（pos）。例如，gesong的题解用`f[i][j][k]`表示第i次过程后的状态，zztqwq的题解用`f(pos,j,k)`显式记录船的位置。状态定义的关键是覆盖所有可能的过河情况，避免遗漏或重复。
    * 💡 **学习笔记**：状态定义要“全而不冗”——必须包含影响后续决策的所有信息（如船的位置、剩余人数），但避免冗余维度（如已过河的人数可由总人数推导）。

2.  **关键点2：如何计算每次过河的方案数？**
    * **分析**：每次过河需要从当前岸选择若干50kg和100kg的人，方案数是组合数的乘积（从j个50kg中选a个的方式数 × 从k个100kg中选b个的方式数）。例如，gesong的代码中用`C[j+a][a] * C[k+b][b]`计算“从j+a个50kg中选a个”的方案数（因为j是未过河的人数，j+a是当前岸的总人数）。
    * 💡 **学习笔记**：组合数的计算需要预处理（如杨辉三角或阶乘逆元），以避免重复计算，提高效率。

3.  **关键点3：如何确定最少渡河次数？**
    * **分析**：最少次数可通过在DP过程中，首次出现“所有人过河”的状态时的次数确定。例如，gesong的代码中，每次转移后检查`f[i][0][0]`是否非零，若为真则输出当前次数i。SevenDawns的BFS解法中，`step`数组直接记录到达每个状态的最少次数，天然保证首次到达即为最短路径。
    * 💡 **学习笔记**：最短路径问题中，BFS或按次数递增的DP转移是找到最小次数的关键。

### ✨ 解题技巧总结
<summary_best_practices>
- **状态压缩**：将船的位置（pos）作为状态的一维，可简化状态定义（如zztqwq的`f(pos,j,k)`）。
- **预处理组合数**：提前计算组合数表（如杨辉三角），避免重复计算，提高代码效率。
- **边界条件检查**：初始状态（所有人在出发岸，船在出发岸）和终止状态（所有人在对岸，船在对岸）需明确初始化和检查。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合了gesong和zztqwq的题解，提炼出一个逻辑清晰、结构简洁的通用核心C++实现，适合新手学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了动态规划的状态定义和组合数预处理，通过枚举每次过河的人数（50kg和100kg的组合）逐步转移状态，最终找到最少次数和方案数。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MOD = 1e9 + 7, N = 60;
    int f[2][N][N]; // f[pos][j][k]: 船在pos岸（0为出发岸，1为对岸），对岸有j个50kg、k个100kg的方案数
    int C[N][N];    // 组合数表，C[n][k]表示n选k的方案数
    int n, k, tot5, tot1; // tot5:50kg总人数，tot1:100kg总人数

    int main() {
        // 预处理组合数
        for (int i = 0; i < N; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j)
                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
        }

        // 输入处理
        cin >> n >> k;
        for (int i = 0; i < n; ++i) {
            int x; cin >> x;
            if (x == 50) tot5++;
            else tot1++;
        }
        k /= 50; // 转换为50kg为单位，简化计算（100kg=2*50kg）

        // 初始化：船在出发岸（pos=0），对岸无人（j=0,k=0）的方案数为1
        f[0][0][0] = 1;

        // 枚举次数i（最多4n次）
        for (int i = 1; i <= 4 * n; ++i) {
            int pos = i % 2; // 当前船的位置（奇数次在对岸，偶数次在出发岸）
            memset(f[pos], 0, sizeof(f[pos])); // 初始化当前状态

            if (pos == 1) { // 奇数次：船从出发岸到对岸（运送人）
                for (int j = 0; j <= tot5; ++j) { // 对岸已有的50kg人数
                    for (int k_100 = 0; k_100 <= tot1; ++k_100) { // 对岸已有的100kg人数
                        if (f[!pos][j][k_100] == 0) continue; // 上一状态无方案，跳过

                        // 枚举本次运送的50kg人数a，100kg人数b（转换为50kg单位：b*2）
                        for (int a = 0; a <= tot5 - j; ++a) {
                            for (int b = 0; b <= tot1 - k_100; ++b) {
                                if (a == 0 && b == 0) continue; // 至少1人
                                if (a + 2 * b > k) continue; // 总重量超过限制

                                // 对岸新增a个50kg和b个100kg，计算组合数
                                int ways = (C[tot5 - j][a] * 1LL * C[tot1 - k_100][b]) % MOD;
                                f[pos][j + a][k_100 + b] = (f[pos][j + a][k_100 + b] + f[!pos][j][k_100] * 1LL * ways) % MOD;
                            }
                        }
                    }
                }
            } else { // 偶数次：船从对岸返回出发岸（接人）
                for (int j = 0; j <= tot5; ++j) {
                    for (int k_100 = 0; k_100 <= tot1; ++k_100) {
                        if (f[!pos][j][k_100] == 0) continue;

                        // 枚举本次返回的50kg人数a，100kg人数b（对岸有j个50kg，k_100个100kg）
                        for (int a = 0; a <= j; ++a) {
                            for (int b = 0; b <= k_100; ++b) {
                                if (a == 0 && b == 0) continue;
                                if (a + 2 * b > k) continue;

                                int ways = (C[j][a] * 1LL * C[k_100][b]) % MOD;
                                f[pos][j - a][k_100 - b] = (f[pos][j - a][k_100 - b] + f[!pos][j][k_100] * 1LL * ways) % MOD;
                            }
                        }
                    }
                }
            }

            // 检查是否所有人已过河（对岸有tot5个50kg，tot1个100kg，且船在对岸）
            if (pos == 1 && f[pos][tot5][tot1] != 0) {
                cout << i << "\n" << f[pos][tot5][tot1] << endl;
                return 0;
            }
        }

        // 超过4n次仍未完成，输出无解
        cout << "-1\n0" << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理组合数表，然后输入数据并统计50kg和100kg的总人数。通过二维数组`f[pos][j][k]`记录船在`pos`岸、对岸有`j`个50kg和`k`个100kg的方案数。枚举每次过河的次数，根据船的位置（奇数次在对岸，偶数次在出发岸）枚举运送或返回的人数，计算组合数并更新状态。当首次出现所有人过河的状态时，输出次数和方案数。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的亮点和技巧：
</code_intro_selected>

**题解一：gesong的动态规划解法 (来源：洛谷CF295C题解)**
* **亮点**：状态定义简洁（`f[i][j][k]`表示第i次过程后未过河的人数），转移逻辑清晰区分奇偶过程，组合数预处理高效。
* **核心代码片段**：
    ```cpp
    // 预处理组合数
    C[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
    }

    // 状态转移（奇数次过程，到达对岸）
    if (i & 1) {
        for (int a = 0; a <= x - j; a++) {
            for (int b = 0; b <= y - k; b++) {
                if (!(a == 0 && b == 0) && 50*a + 100*b <= m)
                    f[i][j][k] = (f[i][j][k] + f[i-1][j+a][k+b] * C[j+a][a] % mod * C[k+b][b] % mod) % mod;
            }
        }
    }
    ```
* **代码解读**：
    这段代码首先预处理组合数表`C`，用于快速计算从`n`人中选`k`人的方案数。在奇数次过程（到达对岸）中，枚举从当前未过河的`j+a`个50kg和`k+b`个100kg中选`a`和`b`人过河，组合数`C[j+a][a]`表示从`j+a`个50kg中选`a`人的方式数，`C[k+b][b]`同理。通过累加这些方案数，更新当前状态的方案数。
* 💡 **学习笔记**：预处理组合数是处理此类组合问题的关键，能大幅提高代码效率。

**题解二：zztqwq的状态压缩DP解法 (来源：独立题解)**
* **亮点**：显式记录船的位置（`pos`），状态定义更直观，转移逻辑对称。
* **核心代码片段**：
    ```cpp
    // 船在出发岸（pos=0）时的转移
    if (i & 1) {
        for (int c5 = 0; c5 <= tot5 - j; c5++) {
            for (int c1 = 0; c1 <= tot1 - k; c1++) {
                if (!c5 && !c1) continue;
                if (50*c5 + 100*c1 > K) continue;
                f[1][j + c5][k + c1] = (f[1][j + c5][k + c1] + 1LL * binom(tot5 - j, c5) * binom(tot1 - k, c1) % mod * f[0][j][k]) % mod;
            }
        }
    }
    ```
* **代码解读**：
    当船在出发岸（`i`为奇数，`pos=1`），枚举运送的50kg人数`c5`和100kg人数`c1`。`binom(tot5 - j, c5)`表示从出发岸剩余的`tot5 - j`个50kg中选`c5`人的方案数，`binom(tot1 - k, c1)`同理。通过这些组合数，将当前状态`f[0][j][k]`的方案数累加到新状态`f[1][j+c5][k+c1]`中。
* 💡 **学习笔记**：状态中显式记录船的位置，能更清晰地区分“运送”和“返回”两种操作。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解动态规划的状态转移和组合数计算，我们设计了一个8位像素风格的动画——“过河小勇士”！通过像素块的移动和颜色变化，你可以清晰看到每次过河的人数、船的位置变化，以及方案数的累加过程。
</visualization_intro>

  * **动画演示主题**：`像素小勇士过河记`
  * **核心演示内容**：展示每次过河时，50kg（绿色方块）和100kg（红色方块）的人如何被选中上船（黄色船），船从出发岸（左）到对岸（右）的移动，以及方案数的动态计算（屏幕下方数字跳动）。

  * **设计思路简述**：采用FC红白机的8位像素风格（16色调色板），用不同颜色区分人物类型和船的位置，配合“叮”声（关键操作）和“胜利”音效（完成过河），增强记忆点。动画的步进控制（单步/自动播放）让学习者可以逐帧观察状态转移。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景 (8位像素风)**：
          - 屏幕分为左右两岸（各有一个平台），出发岸（左）有`tot5`个绿色方块（50kg）和`tot1`个红色方块（100kg），对岸（右）初始为空。
          - 船（黄色方块）停在出发岸，控制面板有“开始”“暂停”“单步”“重置”按钮，以及速度滑块（1-5倍速）。
          - 播放8位风格的轻快背景音乐（如《超级马里奥》经典旋律变奏）。

    2.  **首次运送（奇数次过程）**：
          - 单步点击“开始”，船从出发岸出发。枚举可能的`a`（50kg人数）和`b`（100kg人数），例如样例2中第一次运送2个50kg（绿色方块闪烁）。
          - 选中的2个绿色方块移动到船上（船变为“绿+绿”组合），伴随“叮”声。
          - 船移动到对岸（右平台），方块从船上卸下，对岸新增2个绿色方块。
          - 屏幕下方显示当前次数（1）和方案数（1，若有多种选择则数字跳动）。

    3.  **返回接人（偶数次过程）**：
          - 船在对岸，需要返回接人。枚举返回的人数（如样例2中返回1个50kg）。
          - 选中的1个绿色方块移动到船上（船变为“绿”），伴随“叮”声。
          - 船返回出发岸，方块卸下，出发岸重新出现该绿色方块。
          - 次数增加到2，方案数根据组合数累加（如样例2中此时有2种选择，方案数变为2）。

    4.  **目标达成**：
          - 当所有方块移动到对岸（右平台），船停在对岸时，播放“胜利”音效（如《超级玛丽》吃金币音效变调），屏幕弹出“完成！”字样，显示最少次数和方案数。
          - 若超过4n次仍未完成，播放“失败”音效（短促“滴”声），显示“无解”。

    5.  **交互控制**：
          - 单步模式：点击“单步”按钮，逐次执行过河或返回操作，观察每一步的状态变化。
          - 自动模式：选择速度（如2倍速），船自动执行最优路径，学习者可观察整体流程。
          - 方案数显示：屏幕右侧用数字实时更新当前状态的方案数（如`f[pos][j][k]`的值），帮助理解组合数的累加逻辑。

  * **旁白提示**：
      - （首次运送前）“现在船在出发岸，我们需要选择一些人过河！注意总重量不能超过k哦～”
      - （返回时）“船需要有人开回来接下一批，所以得选至少1个人返回！”
      - （目标达成时）“看！所有人都到对岸了，这就是最少次数的方案～”

<visualization_conclusion>
通过这个像素动画，你不仅能“看到”动态规划的状态如何一步步转移，还能直观理解组合数在计算方案数中的作用。下次遇到类似问题时，你可以想象自己在操作这个动画，逐步推导状态！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是动态规划结合组合数，这类思路可迁移到许多“状态转移+方案计数”的问题中。以下是一些相似场景和练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - **多状态计数**：如“不同颜色球的排列问题”（状态为剩余各颜色球的数量）。
      - **最短路径计数**：如“网格中的最短路径数”（状态为当前坐标，转移为上下左右移动）。
      - **资源分配问题**：如“分糖果问题”（状态为剩余糖果数和已分配人数，转移为分配不同数量的糖果）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1006** - `传纸条`
          * 🗣️ **推荐理由**：经典的动态规划问题，需同时考虑两个路径的状态转移，与本题的多维度状态定义思路相似。
    2.  **洛谷 P1156** - `垃圾陷阱`
          * 🗣️ **推荐理由**：涉及时间和能量的状态转移，需结合组合数计算不同选择的方案数，锻炼状态设计能力。
    3.  **洛谷 P1832** - `A+B Problem（再升级）`
          * 🗣️ **推荐理由**：需计算质数的组合数，结合动态规划统计方案数，与本题的组合数预处理思路类似。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自gesong的题解)**：“在调试时，我发现组合数的计算容易出错（如越界或模运算错误），后来通过打印中间结果（如`C[5][2]`的值）快速定位了问题。”
>
> **点评**：组合数的预处理是本题的关键步骤，作者的经验提醒我们：在编写组合数代码后，应通过小例子（如`C[3][1]=3`）验证其正确性。打印中间变量是调试动态规划问题的有效方法，尤其在状态转移复杂时。

---

<conclusion>
本次关于“Greg and Friends”的分析就到这里。通过动态规划记录状态、组合数计算方案数，我们不仅解决了过河问题，还掌握了一类“状态转移+方案计数”问题的通用解法。记住，多动手写代码、画状态转移图，是理解动态规划的关键！下次见～ 💪
</conclusion>

---
处理用时：185.39秒
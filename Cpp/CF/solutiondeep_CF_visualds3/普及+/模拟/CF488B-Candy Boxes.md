# 题目信息

# Candy Boxes

## 题目描述

There is an old tradition of keeping $ 4 $ boxes of candies in the house in Cyberland. The numbers of candies are special if their arithmetic mean, their median and their range are all equal. By definition, for a set $ {x_{1},x_{2},x_{3},x_{4}} $ ( $ x_{1}<=x_{2}<=x_{3}<=x_{4} $ ) arithmetic mean is ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF488B/4ced3a9ae4181924c136bcc46ede19844528fdef.png), median is ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF488B/2d7e14bfd580007a1d694763c07f2437bb7e66e6.png) and range is $ x_{4}-x_{1} $ . The arithmetic mean and median are not necessary integer. It is well-known that if those three numbers are same, boxes will create a "debugging field" and codes in the field will have no bugs.

For example, $ 1,1,3,3 $ is the example of $ 4 $ numbers meeting the condition because their mean, median and range are all equal to $ 2 $ .

Jeff has $ 4 $ special boxes of candies. However, something bad has happened! Some of the boxes could have been lost and now there are only $ n $ ( $ 0<=n<=4 $ ) boxes remaining. The $ i $ -th remaining box contains $ a_{i} $ candies.

Now Jeff wants to know: is there a possible way to find the number of candies of the $ 4-n $ missing boxes, meeting the condition above (the mean, median and range are equal)?

## 说明/提示

For the first sample, the numbers of candies in $ 4 $ boxes can be $ 1,1,3,3 $ . The arithmetic mean, the median and the range of them are all $ 2 $ .

For the second sample, it's impossible to find the missing number of candies.

In the third example no box has been lost and numbers satisfy the condition.

You may output $ b $ in any order.

## 样例 #1

### 输入

```
2
1
1
```

### 输出

```
YES
3
3
```

## 样例 #2

### 输入

```
3
1
1
1
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
4
1
2
2
3
```

### 输出

```
YES
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Candy Boxes 深入学习指南 💡

<introduction>
今天我们来一起分析「Candy Boxes」这道C++编程题。这道题的核心是**通过数学推导简化条件**，再**分类讨论不同输入情况**来构造或验证解。跟着Kay的思路，你会发现复杂的条件其实藏着简洁的规律，分类讨论也能变得清晰有序！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学推导 + 分类讨论（编程技巧应用）

🗣️ **初步分析**：
解决「Candy Boxes」的关键，是把题目中的“均值=中位数=范围”这三个条件**转化为更简单的数学等式**。我们一步步拆解：

原条件是：  
$$\frac{a_1+a_2+a_3+a_4}{4} = \frac{a_2+a_3}{2} = a_4 - a_1$$  
（其中 $a_1 \leq a_2 \leq a_3 \leq a_4$）

**第一步变形**：把前两个等式相乘4，得到：  
$$a_1+a_2+a_3+a_4 = 2(a_2+a_3) \implies a_1 + a_4 = a_2 + a_3$$  

**第二步变形**：把后两个等式相乘4，结合上面的结论，得到：  
$$a_1+a_2+a_3+a_4 = 4(a_4 - a_1) \implies (a_2+a_3) + (a_1+a_4) = 4(a_4 - a_1)$$  
代入 $a_1+a_4 = a_2+a_3$，简化后得到：  
$$2(a_1+a_4) = 4(a_4 - a_1) \implies a_4 = 3a_1$$  

**最终结论**：所有满足条件的四元组必须满足两个核心规律：  
1. $a_4 = 3a_1$（最大数是最小数的3倍）；  
2. $a_2 + a_3 = 4a_1$（中间两个数的和是最小数的4倍）；  
3. 同时保持 $a_1 \leq a_2 \leq a_3 \leq a_4$（顺序约束）。

接下来，我们只需要**根据给定的n（0-4）分类讨论**：  
- 若n=0/1/2/3：构造缺失的数，验证是否满足上述规律；  
- 若n=4：直接验证是否满足规律。

**可视化设计思路**：我们会用**8位像素风**设计一个“糖果盒填充游戏”——屏幕上有4个像素盒子，初始显示给定的数字（比如n=2时显示两个1），然后逐步填充缺失的数字（比如3和3），同时用**颜色高亮**展示核心规律（比如a4变成3倍a1时，盒子变红；a2+a3等于4倍a1时，两个盒子闪黄色）。还会加入**像素音效**：填充正确时播放“叮”的音效，完成所有条件时播放胜利音乐！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，它们分别代表了“数学推导派”“暴力验证派”和“详细分析派”的思路，一起看看吧！
</eval_intro>

**题解一：数学推导派（作者：N_z_，赞：5）**
* **点评**：这份题解的**核心亮点是“精准的数学推导+简洁的分类讨论”**。作者直接抓住了“a4=3a1”和“a2+a3=4a1”这两个关键结论，然后按n的不同情况逐一构造解：  
  - n=0时，直接输出特解（1,1,3,3）；  
  - n=1时，构造a1=a[1]，a2=a1，a3=3a1，a4=3a1；  
  - n=2时，验证a2≤3a1后，构造a3=4a1-a2，a4=3a1；  
  - n=3时，分三种情况验证（比如a3是否是3a1，或a2+a3是否等于4a1）；  
  - n=4时，直接验证条件。  
  代码**逻辑紧凑、变量命名清晰**（比如用a[1]-a[4]对应四元组），边界条件处理严谨（比如n=2时检查a2≤3a1），非常适合初学者学习“如何把数学结论转化为代码”。

**题解二：暴力验证派（作者：QQH08，赞：4）**
* **点评**：这份题解的**亮点是“暴力枚举的实用性”**。作者意识到n≤4时，缺失的数不会太大（比如枚举到1500），于是直接枚举缺失的数，排序后验证是否满足条件。这种方法虽然“笨”，但**思路直观、容易理解**，适合刚接触分类讨论的同学——当你暂时想不清数学推导时，暴力枚举是“保底”的好方法。比如n=2时，枚举两个缺失的数i和j，排序后检查是否满足“a1+a4=a2+a3”和“3a1=a4”，非常直白。

**题解三：详细分析派（作者：luuia，赞：0）**
* **点评**：这份题解的**亮点是“对每个n的情况做了深度分析”**。比如n=2时，作者详细推导了“为什么a2≤3a1是可行条件”：当a2≤3a1时，构造的a3=4a1-a2会满足a2≤a3≤3a1（即a4）；n=3时，作者分三种情况（未给出a1、a2/a3、a4）逐一验证，覆盖了所有可能的缺失位置。虽然代码和题解一类似，但**分析过程更细致**，适合想“知其然更知其所以然”的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，同学们常遇到三个“卡壳点”。结合优质题解的经验，Kay为你总结了对应的解决策略：
</difficulty_intro>

1.  **难点1：如何将复杂条件转化为简洁等式？**
    * **分析**：题目中的三个条件（均值、中位数、范围相等）看起来很复杂，但只要**逐步变形等式**，就能找到核心规律。比如先把前两个等式相乘4，消去分母，得到a1+a4=a2+a3；再把后两个等式结合这个结论，就能得到a4=3a1。关键是**不要害怕代数变形**，多写几步就能简化问题。
    * 💡 **学习笔记**：复杂条件的本质是“隐藏的简单规律”，通过代数变形可以“拆穿”它！

2.  **难点2：如何处理不同n的分类讨论？**
    * **分析**：n的取值有0-4五种情况，每种情况的缺失位置不同，需要**明确“已知数的角色”**（比如n=2时，已知的两个数是a1和a2，还是a1和a4？）。优质题解的做法是**先排序已知数**（确保a1≤a2≤…≤an），再假设已知数是四元组的前k个（比如n=2时，已知a1和a2），这样就能统一构造逻辑。
    * 💡 **学习笔记**：分类讨论前，先排序已知数，能减少“位置混乱”的问题！

3.  **难点3：如何确保构造的数满足顺序约束？**
    * **分析**：四元组必须满足a1≤a2≤a3≤a4，所以构造的数要**验证顺序**。比如n=2时，构造的a3=4a1-a2需要满足a2≤a3≤3a1（即a4），而这一点可以通过“a2≤3a1”来保证（因为4a1-a2≥a2等价于a2≤2a1，而a2≤3a1包含了这个情况）。
    * 💡 **学习笔记**：顺序约束不是“额外负担”，而是“构造解的必要条件”，要把它融入构造逻辑中！

### ✨ 解题技巧总结
- **技巧1：代数变形简化条件**：遇到多个等式条件时，先相乘消去分母，再代入已知结论，能快速找到核心规律。  
- **技巧2：排序已知数**：不管n是多少，先排序已知数，能统一假设已知数是四元组的前k个，减少分类次数。  
- **技巧3：边界条件验证**：构造完缺失的数后，一定要验证是否满足顺序约束（比如a3≤a4），避免“构造了但不符合要求”的错误。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合数学推导和分类讨论的通用核心代码**，它来自题解一（N_z_），逻辑清晰、代码简洁，能覆盖所有情况。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一的思路，直接基于“a4=3a1”和“a2+a3=4a1”的结论，按n的不同情况构造或验证解，是最简洁高效的实现方式。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;

    int a[5]; // 存储已知的n个数，排序后使用

    int main() {
        int n;
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
        }
        sort(a + 1, a + 1 + n); // 排序已知数，确保a1<=a2<=...<=an

        if (n == 0) {
            cout << "YES\n1\n1\n3\n3" << endl;
        } else if (n == 1) {
            int x = a[1];
            cout << "YES\n" << x << "\n" << 3 * x << "\n" << 3 * x << endl;
        } else if (n == 2) {
            int x = a[1], y = a[2];
            if (y <= 3 * x) {
                cout << "YES\n" << 4 * x - y << "\n" << 3 * x << endl;
            } else {
                cout << "NO" << endl;
            }
        } else if (n == 3) {
            int x = a[1], y = a[2], z = a[3];
            if (z == 3 * x) {
                cout << "YES\n" << 4 * x - y << endl;
            } else if (3 * x >= z && y + z == 4 * x) {
                cout << "YES\n" << 3 * x << endl;
            } else if (z % 3 == 0 && x + y == 4 * (z / 3)) {
                cout << "YES\n" << z / 3 << endl;
            } else {
                cout << "NO" << endl;
            }
        } else if (n == 4) {
            int x = a[1], y = a[2], z = a[3], w = a[4];
            if (w == 3 * x && y + z == 4 * x) {
                cout << "YES" << endl;
            } else {
                cout << "NO" << endl;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. **输入与排序**：读取n和已知数，排序后存储在a[1]-a[n]中（确保顺序）；  
  2. **分类处理**：  
     - n=0：直接输出特解（1,1,3,3）；  
     - n=1：构造a2=a1，a3=3a1，a4=3a1（满足a2+a3=4a1和a4=3a1）；  
     - n=2：验证a2≤3a1后，构造a3=4a1-a2，a4=3a1；  
     - n=3：分三种情况验证（z是否是3x，或y+z是否是4x，或z是3的倍数且x+y是4*(z/3)）；  
     - n=4：直接验证w=3x且y+z=4x。

---
<code_intro_selected>
接下来，我们看两个**核心代码片段**，分别来自“暴力验证派”和“详细分析派”，感受不同思路的差异。
</code_intro_selected>

**题解二：暴力验证派（作者：QQH08）**
* **亮点**：用暴力枚举覆盖所有可能的缺失数，思路直观。
* **核心代码片段**：
    ```cpp
    // n=2时的暴力枚举
    for (int i = 1; i <= 1500; ++i) {
        for (int j = 1; j <= 1500; ++j) {
            int x = a[1], y = a[2];
            a[3] = i, a[4] = j;
            sort(a + 1, a + 5); // 排序四元组
            if (a[1] + a[4] == a[2] + a[3] && 3 * a[1] == a[4]) {
                cout << "YES\n" << min(i, j) << "\n" << max(i, j) << endl;
                return 0;
            }
            a[1] = x, a[2] = y; // 恢复已知数
        }
    }
    ```
* **代码解读**：
  - 枚举两个缺失的数i和j（范围1-1500）；  
  - 将i和j加入已知数，排序后得到四元组；  
  - 验证核心条件（a1+a4=a2+a3和3a1=a4）；  
  - 若满足，输出结果并结束程序。  
  这个片段的**关键是“枚举+验证”**，适合暂时想不清数学推导的同学，但要注意枚举范围不能太小（比如1500足够覆盖所有可能的解）。
* 💡 **学习笔记**：暴力枚举是“笨办法”，但也是“稳办法”，适合n小的问题！

**题解三：详细分析派（作者：luuia）**
* **亮点**：n=3时的深度分析，覆盖所有缺失位置。
* **核心代码片段**：
    ```cpp
    // n=3时的分类处理
    sort(a + 1, a + 4);
    int x = a[1], y = a[2], z = a[3];
    if (z == 3 * x) { // 缺失a2：a4=z=3x，构造a2=4x-y
        cout << "YES\n" << 4 * x - y << endl;
    } else if (3 * x >= z && y + z == 4 * x) { // 缺失a4：构造a4=3x
        cout << "YES\n" << 3 * x << endl;
    } else if (z % 3 == 0 && x + y == 4 * (z / 3)) { // 缺失a1：构造a1=z/3
        cout << "YES\n" << z / 3 << endl;
    } else {
        cout << "NO" << endl;
    }
    ```
* **代码解读**：
  - n=3时，已知三个数x≤y≤z，可能缺失a1、a2或a4：  
    1. 若z=3x（说明z是a4），则缺失的是a2，构造a2=4x-y；  
    2. 若y+z=4x且z≤3x（说明x是a1），则缺失的是a4，构造a4=3x；  
    3. 若z是3的倍数且x+y=4*(z/3)（说明z是a4），则缺失的是a1，构造a1=z/3；  
  - 这三种情况覆盖了所有可能的缺失位置，确保不会遗漏。
* 💡 **学习笔记**：分类讨论时，要“穷举所有可能的缺失位置”，避免漏解！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“核心规律”，Kay设计了一个**8位像素风的“糖果盒填充游戏”**。你会看到四个像素盒子，逐步填充缺失的数字，同时通过颜色和音效感受条件的满足过程！
</visualization_intro>

### ✨ 动画设计方案
**动画主题**：像素探险家“小糖”填充糖果盒，满足“a4=3a1”和“a2+a3=4a1”的条件，最终激活“无bug领域”。

**风格与交互**：
- **8位像素风**：背景是FC游戏的蓝底白块，四个盒子是棕色像素块，数字用黄色点阵字体显示；  
- **控制面板**：包含“开始/暂停”“单步执行”“重置”按钮，以及“速度滑块”（控制动画播放速度）；  
- **音效**：填充正确数字时播放“叮”的音效，完成所有条件时播放胜利音乐（类似《超级马里奥》的通关音效），错误时播放“ buzzer ”声。

### 🎬 动画帧步骤（以样例1为例：n=2，输入1和1）
1. **初始化场景**：屏幕显示四个棕色盒子，前两个盒子显示“1”（黄色），后两个是空的（灰色）；控制面板显示“开始”按钮。
2. **步骤1：确定a1和a2**：前两个盒子的“1”闪烁绿色，旁白提示：“已知a1=1，a2=1，接下来要构造a3和a4！”
3. **步骤2：计算a4=3a1**：第四个盒子突然亮起，显示“3”（红色），伴随“叮”的音效，旁白提示：“a4是a1的3倍，所以a4=3×1=3！”
4. **步骤3：计算a3=4a1-a2**：第三个盒子亮起，显示“3”（黄色），伴随“叮”的音效，旁白提示：“a2+a3=4a1，所以a3=4×1-1=3！”
5. **步骤4：验证顺序**：四个盒子依次闪烁蓝色，旁白提示：“检查顺序：1≤1≤3≤3，满足条件！”
6. **胜利状态**：四个盒子同时闪烁金色，播放胜利音乐，屏幕显示“无bug领域激活！”

### 🎮 游戏化元素
- **关卡设计**：将n=0到n=4分为5个“小关卡”，完成一个关卡解锁下一个；  
- **积分系统**：每正确构造一个数字得10分，完成所有条件得50分，积分解锁“像素皮肤”（比如给盒子换颜色）；  
- **AI演示模式**：点击“AI自动演示”，小糖会自动填充数字，展示完整过程，适合新手观察。

<visualization_conclusion>
通过这个动画，你能**“看得到”数学规律的应用**——a4如何变成3倍a1，a3如何由a1和a2计算而来，顺序约束如何验证。像素风格和游戏化元素让学习更轻松，音效则强化了关键步骤的记忆！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路是“数学推导+分类讨论”，这种思路能解决很多“给定部分条件，构造或验证解”的问题。我们来看几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：给定三角形的两边，求第三边的可能值（需要满足三角形不等式）；  
- **场景2**：给定等差数列的部分项，求缺失项（需要满足等差数列的通项公式）；  
- **场景3**：给定矩形的周长，求面积的最大值（需要用数学公式推导最大值条件）。

### 洛谷练习推荐
1. **洛谷 P1025 数的划分**  
   🗣️ **推荐理由**：这道题需要将数分成k个正整数的和，需要数学推导（动态规划或组合数学）和分类讨论，能巩固“将问题转化为数学模型”的能力。
2. **洛谷 P1161 开灯**  
   🗣️ **推荐理由**：这道题需要找出哪些灯会亮着，核心是数学中的“约数个数”规律，能锻炼“从现象中提炼数学规律”的能力。
3. **洛谷 P1567 统计天数**  
   🗣️ **推荐理由**：这道题需要统计连续上升的天数，虽然简单，但需要分类讨论（连续或中断），能巩固“分类处理边界条件”的能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中没有明确的作者个人心得，但Kay想分享一个**常见的“踩坑点”**：
</insights_intro>

> **经验分享**：很多同学在n=2时，会忘记验证“a2≤3a1”，导致构造的a3=4a1-a2小于a2，违反顺序约束。比如输入是1和4（n=2），此时3a1=3，而a2=4>3，构造的a3=4×1-4=0，小于a2=4，这显然不符合顺序要求。  
> **点评**：顺序约束不是“可有可无”的，一定要把它融入构造逻辑中。比如n=2时，先检查a2≤3a1，再构造a3和a4，就能避免这种错误！


<conclusion>
本次关于「Candy Boxes」的分析就到这里。这道题的核心是**数学推导简化条件**，再**分类讨论处理不同情况**。记住：复杂的问题往往藏着简单的规律，只要你愿意“拆”开它，就能找到解决办法！下次我们再一起探索新的编程挑战吧！💪
</conclusion>

---

---
处理用时：137.61秒
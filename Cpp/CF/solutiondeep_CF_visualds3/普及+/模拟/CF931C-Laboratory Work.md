# 题目信息

# Laboratory Work

## 题目描述

$Anya$ 和 $Kirill$ 正在做一个物理实验，他们必须测量一些值 $n$ 次，然后求出平均值以降低误差。



$Kirill$ 已经完成了测量，得到了 $n$ 个数据：$x_1,x_2,\dots,x_n$。这些值非常接近，其中的最大值与最小值之差不超过 $2$。



$Anya$ 不想去测量，但是他也不能直接抄 $Kirill$ 的数据，因为每次测量的误差是随机的，如果直接抄的话会被老师发现。$Anya$ 想要得到一组数据 $y_1,y_2,\dots,y_n$ ，这组数据满足如下条件：



* $x_1,x_2,\dots,x_n$ 的平均值要等于 $y_1,y_2,\dots,y_n$ 的平均值。

* $\max(y_1,y_2,\dots,y_n) \le \max(x_1,x_2,\dots,x_n)$ 并且 $\min(y_1,y_2,\dots,y_n) \ge \min(x_1,x_2,\dots,x_n)$。

* 两组数据中相等的数尽可能少，即你造的数据中尽量不要出现 $Kirill$ 的数据中出现过的数。



找出这样的一组测量值。

## 说明/提示

$1 \le n \le 100000$。



$-100000 \le x_i \le 100000$



[样例解释]



第一个样例中，$0,0,0,0,0,0$ 与 $-1,1,1,0,0,-1$ 的平均值相等，只有两个相等的 $0$。



第二个样例中，要想使平均值相等，$Anya$ 的测量值只能与 $Kirill$ 的测量值相等。



第三个样例中，最少也要有 $5$ 个相等的数。



translated by [yu__xuan](https://www.luogu.com.cn/user/142110).

## 样例 #1

### 输入

```
6
-1 1 1 0 0 -1
```

### 输出

```
2
0 0 0 0 0 0 
```

## 样例 #2

### 输入

```
3
100 100 101
```

### 输出

```
3
101 100 100 
```

## 样例 #3

### 输入

```
7
-10 -9 -10 -8 -10 -9 -9
```

### 输出

```
5
-10 -10 -9 -9 -9 -9 -9 
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Laboratory Work 深入学习指南 💡

<introduction>
今天我们来一起分析“Laboratory Work”这道C++编程题。题目要求构造一个新的数列，使其与原数列平均值相同、范围不扩大，且相同元素尽可能少。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法应用

🗣️ **初步分析**：
解决这道题的关键在于利用贪心策略，选择最优的调整方式减少相同元素。贪心算法的核心思想是“每一步选择当前最优解，最终达到全局最优”，就像分糖果时每次选最大的分给最需要的人，最终整体分配更合理。

在本题中，原数列的最大值与最小值之差最多为2，因此数据只有三种可能值（当差为2时）。我们需要比较两种调整方式的效果：
- 方式1：将最小和最大值转为中间值（减少最小/最大值的数量，增加中间值的数量）；
- 方式2：将中间值转为最小和最大值（减少中间值的数量，增加最小/最大值的数量）。

通过统计三种值的出现次数，选择能减少更多相同元素的方式。可视化设计中，我们可以用不同颜色的像素块代表三种值，动画演示调整过程（如将红色块（最小值）和蓝色块（最大值）变为绿色块（中间值）），高亮变化的块并配合“叮”的音效，直观展示调整效果。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下3道优质题解（评分≥4星）：
</eval_intro>

**题解一：作者：开始新的记忆**
* **点评**：此题解思路清晰，通过排序和统计三种值的数量（最小、中间、最大值），明确比较两种调整方式（转中间值或转最小/最大值）的效果。代码结构规范（如变量`num_min`、`num_max`命名直观），边界处理严谨（如极差≤1时直接输出原数列）。算法复杂度O(n)，适合竞赛场景，是理解本题的典型参考。

**题解二：作者：王熙文**
* **点评**：此题解数学推导深入，明确指出“相同元素数为各值出现次数的最小值之和”，并通过计算两种调整方式的结果（`ans1`和`ans2`）选择更优解。代码简洁高效（如位运算`cnt2&1`处理奇偶），逻辑直接，对核心公式的解释能帮助学习者理解贪心选择的本质。

**题解三：作者：lmy_2011**
* **点评**：此题解步骤明确，通过排序后统计各值数量，分别处理两种调整方式。代码中`for`循环遍历统计清晰，调整过程的数组操作直观（如`a[i]=m+1`修改最小值为中间值），适合新手理解如何将思路转化为代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何选择最优的调整方式。结合优质题解，我们提炼以下关键点：
</difficulty_intro>

1.  **关键点1：判断是否需要调整**
    * **分析**：当原数列的最大值与最小值之差≤1时，无法调整（调整后范围会扩大），只能输出原数列。例如，若所有数都是100或101（差为1），调整任何数都会导致最大值超过101或最小值低于100，违反条件。
    * 💡 **学习笔记**：极差≤1时，原数列是唯一可行解。

2.  **关键点2：统计三种值的出现次数**
    * **分析**：当极差为2时，原数列包含最小值（min）、中间值（min+1）、最大值（min+2）。统计三者的出现次数（记为`cnt1`、`cnt2`、`cnt3`）是调整的基础。例如，样例1中输入为`-1,1,1,0,0,-1`，排序后min=-1，max=1（差为2），中间值为0，统计得`cnt1=2`（-1）、`cnt2=2`（0）、`cnt3=2`（1）。
    * 💡 **学习笔记**：统计是贪心选择的前提，需确保计数准确。

3.  **关键点3：选择最优调整方式**
    * **分析**：比较两种调整方式的效果：
      - 方式1（转中间值）：最多可调整`min(cnt1,cnt3)`次，每次减少2个相同元素（1个min和1个max）；
      - 方式2（转min/max）：最多可调整`cnt2//2`次，每次减少2个相同元素（2个中间值）。
      选择调整次数更多的方式，以减少最多的相同元素。
    * 💡 **学习笔记**：贪心的核心是比较两种操作的“收益”，选收益更高的。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“是否调整”→“统计数量”→“选择方式”三步骤，降低复杂度。
- **边界优先**：先处理极差≤1的特殊情况，避免后续逻辑出错。
- **变量命名清晰**：用`cnt1`、`cnt2`、`cnt3`等直观命名，提升代码可读性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了“开始新的记忆”和“王熙文”题解的思路，统计三种值的数量后选择最优调整方式。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        vector<int> a(n);
        int min_val = INT_MAX, max_val = INT_MIN;
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            min_val = min(min_val, a[i]);
            max_val = max(max_val, a[i]);
        }

        if (max_val - min_val <= 1) { // 无法调整，输出原数列
            cout << n << endl;
            for (int num : a) cout << num << " ";
            return 0;
        }

        // 统计三种值的数量
        int cnt1 = 0, cnt2 = 0, cnt3 = 0;
        for (int num : a) {
            if (num == min_val) cnt1++;
            else if (num == min_val + 1) cnt2++;
            else cnt3++;
        }

        // 计算两种调整方式的收益
        int t = min(cnt1, cnt3); // 方式1最多调整次数
        int k = cnt2 / 2;         // 方式2最多调整次数

        if (t > k) { // 选择方式1：转中间值
            int adjust = t;
            cnt1 -= adjust;
            cnt3 -= adjust;
            cnt2 += 2 * adjust;
            cout << n - 2 * adjust << endl;
        } else { // 选择方式2：转min/max
            int adjust = k;
            cnt1 += adjust;
            cnt3 += adjust;
            cnt2 -= 2 * adjust;
            cout << n - 2 * adjust << endl;
        }

        // 输出调整后的数列
        for (int i = 0; i < cnt1; ++i) cout << min_val << " ";
        for (int i = 0; i < cnt2; ++i) cout << min_val + 1 << " ";
        for (int i = 0; i < cnt3; ++i) cout << min_val + 2 << " ";
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并统计最小/最大值，判断是否需要调整。若无需调整则输出原数列；否则统计三种值的数量，计算两种调整方式的最大调整次数，选择更优方式调整数量，最后按调整后的数量输出数列。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者：开始新的记忆**
* **亮点**：通过排序后直接修改数组元素，直观展示调整过程。
* **核心代码片段**：
    ```cpp
    int num_min=0,num_max=0,num_mid=0;
    for(int i=1;i<=n;++i){
        if(a[i]==a[1]) num_min++;
        else if(a[i]==a[n]) num_max++;
        else num_mid++;
    }
    int t=min(num_min,num_max),k=num_mid/2;
    if(t>k){
        for(int i=1;i<=t;++i) a[i]=st+1;
        for(int i=n;i>n-t;--i) a[i]=st+1;
    }
    ```
* **代码解读**：
    这段代码统计了最小值（`a[1]`）、最大值（`a[n]`）和中间值的数量。通过比较`t`（方式1的调整次数）和`k`（方式2的调整次数），选择调整方式。若`t>k`，则将前`t`个最小值和后`t`个最大值改为中间值（`st+1`）。例如，若原数组前两个是min，后两个是max，则修改为中间值，减少相同元素。
* 💡 **学习笔记**：直接修改数组元素是直观的调整方式，但需注意排序后的顺序。

**题解二：作者：王熙文**
* **亮点**：通过数学公式直接计算两种方式的相同元素数，选择更优解。
* **核心代码片段**：
    ```cpp
    int ans1=cnt1+cnt3+(cnt2&1),ans2=abs(cnt1-cnt3)+cnt2;
    if(ans1<ans2){
        // 输出方式2的调整结果
    }else{
        // 输出方式1的调整结果
    }
    ```
* **代码解读**：
    `ans1`是方式2调整后的相同元素数（`cnt1`和`cnt3`各增加`cnt2//2`，剩余中间值为`cnt2%2`），`ans2`是方式1调整后的相同元素数（`cnt1`和`cnt3`的差加上中间值数量）。比较两者选择更小的，确保相同元素最少。例如，若`ans1=3`，`ans2=5`，则选择方式2。
* 💡 **学习笔记**：数学推导能快速计算结果，避免复杂的数组操作。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解调整过程，我们设计一个“像素实验室”动画，用8位像素风格展示数列调整！
</visualization_intro>

  * **动画演示主题**：`像素实验室的调整实验`

  * **核心演示内容**：原数列的三种值（红：min，绿：中间值，蓝：max）通过调整变为新数列，高亮变化的像素块，展示相同元素减少的过程。

  * **设计思路简述**：8位像素风营造复古感，颜色区分三种值；调整时像素块闪烁并变换颜色，配合“叮”音效强化记忆；每完成一次调整视为“小关卡”，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示原数列（红、绿、蓝像素块排列），右侧显示控制面板（单步、自动、调速按钮）。
        - 顶部显示三种值的数量（`cnt1=2`，`cnt2=2`，`cnt3=2`）。
        - 播放8位风格背景音乐（如《超级马里奥》经典旋律）。

    2.  **调整前展示**：
        - 原数列块静止，旁白：“原数列有红（min）2个，绿（中间值）2个，蓝（max）2个。”

    3.  **方式1调整演示**：
        - 点击“方式1”按钮，前2个红块和后2个蓝块开始闪烁（黄色边框）。
        - 闪烁3次后，红/蓝块变为绿块（中间值），伴随“叮”音效。
        - 顶部数量更新（`cnt1=0`，`cnt2=6`，`cnt3=0`），旁白：“将2个红和2个蓝转为绿，相同元素减少4个！”

    4.  **方式2调整演示**：
        - 重置后点击“方式2”按钮，中间的2个绿块闪烁。
        - 绿块分裂为1个红和1个蓝块，伴随“叮”音效。
        - 顶部数量更新（`cnt1=3`，`cnt2=0`，`cnt3=3`），旁白：“将2个绿转为1红1蓝，相同元素减少2个！”

    5.  **最优选择**：
        - 比较两种方式的相同元素数（方式1减少更多），最优方式的块高亮（金色边框），播放“胜利”音效（上扬音调）。
        - 旁白：“选择方式1，相同元素最少！”

  * **旁白提示**：
    - “看！红色和蓝色块在闪烁，它们要变成绿色块了～”
    - “听到‘叮’声了吗？这是一次成功的调整哦！”
    - “最终，我们选择了减少最多相同元素的方式，太棒了！”

<visualization_conclusion>
通过这样的动画，我们能直观看到调整过程，理解贪心策略如何选择最优解。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的贪心策略可迁移到多种需要“最小化/最大化某种指标”的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **数据分布调整**：如调整班级分数段分布，使优秀率和及格率满足要求；
    - **资源分配**：如调整不同面额硬币的数量，使总金额不变但硬币数最少；
    - **任务调度**：调整任务顺序，使总等待时间最短。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1020 导弹拦截**  
        * 🗣️ **推荐理由**：需贪心选择拦截系统，与本题“每一步选最优”的思路类似。
    2.  **洛谷 P1216 数字三角形**  
        * 🗣️ **推荐理由**：动态规划与贪心结合，训练对路径选择的敏感度。
    3.  **洛谷 P1094 纪念品分组**  
        * 🗣️ **推荐理由**：通过贪心分组使总组数最少，与本题调整数量的思路相似。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中虽未明确作者心得，但通过分析可知：统计数量时需仔细，避免因计数错误导致调整方式选择错误。例如，若误将中间值计为最大值，会导致调整后范围扩大，违反条件。
</insights_intro>

---

<conclusion>
本次关于“Laboratory Work”的分析就到这里。希望大家掌握贪心策略的应用，通过调整数据分布解决类似问题。记住，多思考、多练习，编程能力会稳步提升！下次见～💪
</conclusion>

---
处理用时：139.05秒
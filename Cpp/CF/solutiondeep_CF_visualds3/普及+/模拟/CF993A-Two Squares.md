# 题目信息

# Two Squares

## 题目描述

给出两个正方形，其中一个正方形的边恰好与坐标轴平行，而另一个呈  $45\degree$  角倾斜。

请你判断这两个正方形是否重叠。（如果两个正方形有点或边重合了，也算作重叠）

## 说明/提示

- 第  $1$  组样例的解释：

因为第  $2$  个正方形完全被第  $1$  个正方形包含，也算作重叠，故输出  $Yes$  或  $YES$ 。

- 第  $2$  组样例的解释：

因为两个正方形完全没有重叠，故输出  $No$  或  $NO$ 。

- 第  $3$  组样例的解释：

因为两个正方形有一小部分重叠，故输出  $Yes$  或  $YES$ 。

每个样例对应的图像如下所示。

感谢@Sooke 提供翻译

## 样例 #1

### 输入

```
0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
0 0 6 0 6 6 0 6
7 3 9 5 11 3 9 1
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
6 0 6 6 0 6 0 0
7 4 4 7 7 10 10 7
```

### 输出

```
YES
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Two Squares 深入学习指南 💡

<introduction>
今天我们来分析“Two Squares”这道题。题目要求判断一个轴对齐的正方形和一个45度倾斜的正方形是否重叠（包括点或边重合）。本指南将帮助大家理解核心思路、关键算法，并通过可视化方案直观感受解题过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：几何图形重叠判断（编程技巧应用）

🗣️ **初步分析**：
解决这道题的关键在于如何高效判断两个特殊正方形的重叠。轴对齐的正方形可以直接通过坐标范围判断点是否在内部；而45度倾斜的正方形，其边界可以通过坐标变换（x+y和x-y）转换为矩形范围。  
- **核心思路**：枚举所有可能的整数点（因坐标范围小），判断该点是否同时属于两个正方形。若存在这样的点，说明重叠。  
- **核心难点**：如何将倾斜正方形的边界转换为易于处理的形式，以及如何高效枚举点而不遗漏。  
- **可视化设计**：采用8位像素风格，用不同颜色标记两个正方形覆盖的区域，枚举点时用闪烁像素点表示当前检查点，找到重叠点时高亮并播放“叮”音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的评估（思路清晰性、代码规范性、算法有效性），筛选出以下优质题解：
</eval_intro>

**题解一：作者：zhang_kevin**
* **点评**：此题解思路简洁高效，通过坐标变换将倾斜正方形转换为矩形范围，枚举所有可能的整数点判断重叠。代码结构清晰（如`check`函数封装判断逻辑），变量命名直观（`minx1`/`maxx1`等表示轴对齐正方形的边界）。算法复杂度仅为O(4e4)（枚举-100到100的x和y），适合竞赛场景。其坐标变换的技巧（将倾斜正方形转换为x+y和x-y的范围）是最大亮点，极大简化了判断逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，主要会遇到以下核心难点，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何表示倾斜正方形的边界？**
    * **分析**：倾斜正方形的边与坐标轴成45度，其内部点满足x+y和x-y的范围固定。例如，将倾斜正方形的四个顶点转换为(x+y, x-y)后，其边界可表示为min(x+y) ≤ x+y ≤ max(x+y)，min(x-y) ≤ x-y ≤ max(x-y)。这一步转换将倾斜正方形的判断转化为矩形范围判断，简化了问题。
    * 💡 **学习笔记**：坐标变换是处理倾斜图形的常用技巧，通过转换可将复杂图形的边界条件转化为简单的矩形范围。

2.  **关键点2：如何高效枚举可能的重叠点？**
    * **分析**：由于题目中坐标范围较小（样例中点的坐标绝对值不超过100），枚举x和y在-100到100之间的所有整数点是可行的。通过双重循环遍历这些点，利用`check`函数判断是否同时满足两个正方形的条件，即可找到重叠点。
    * 💡 **学习笔记**：当数据范围较小时，暴力枚举是简单有效的方法，但需注意枚举范围的合理性。

3.  **关键点3：如何处理边界条件？**
    * **分析**：需要确保枚举点包含正方形的边和顶点（如轴对齐正方形的边界是闭区间[minx1, maxx1]）。优质题解中通过直接使用`min`和`max`函数获取正方形的边界，确保了边界条件的正确性。
    * 💡 **学习笔记**：几何问题中，边界条件（如闭区间、包含端点）的处理直接影响结果正确性，需特别注意。

### ✨ 解题技巧总结
- **坐标变换**：将倾斜图形转换为轴对齐的矩形范围，简化判断逻辑。
- **枚举范围控制**：根据题目数据范围，合理设置枚举的上下限（如-100到100），确保覆盖所有可能的重叠点。
- **函数封装**：将核心判断逻辑（如`check`函数）封装，提高代码可读性和复用性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选取zhang_kevin的题解作为代表，其代码逻辑清晰、实现高效，能完整解决问题。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了坐标变换和暴力枚举的思路，通过转换倾斜正方形的边界，高效判断重叠。
* **完整核心代码**：
    ```cpp
    #include<iostream>
    #include<algorithm>
    using namespace std;

    int x1[5], y1[5], x2[5], y2[5];
    int minx1, miny1, maxx1, maxy1; // 轴对齐正方形的边界
    int minx2, miny2, maxx2, maxy2; // 倾斜正方形转换后的边界（x+y和x-y的范围）

    inline bool check(int i, int j) {
        // 判断点(i,j)是否在轴对齐正方形内，且满足倾斜正方形的x+y、x-y范围
        return (minx1 <= i && i <= maxx1) && 
               (miny1 <= j && j <= maxy1) && 
               (minx2 <= i + j && i + j <= maxx2) && 
               (miny2 <= i - j && i - j <= maxy2);
    }

    int main() {
        // 输入轴对齐正方形的四个顶点
        for(int i = 0; i < 4; i++) 
            cin >> x1[i] >> y1[i];
        // 计算轴对齐正方形的边界
        minx1 = min({x1[0], x1[1], x1[2], x1[3]});
        maxx1 = max({x1[0], x1[1], x1[2], x1[3]});
        miny1 = min({y1[0], y1[1], y1[2], y1[3]});
        maxy1 = max({y1[0], y1[1], y1[2], y1[3]});

        // 输入倾斜正方形的四个顶点，并转换为x+y和x-y的坐标
        for(int i = 0; i < 4; i++) {
            cin >> x2[i] >> y2[i];
            x1[i] = x2[i] + y2[i]; // x+y
            y1[i] = x2[i] - y2[i]; // x-y
        }
        // 计算倾斜正方形转换后的边界
        minx2 = min({x1[0], x1[1], x1[2], x1[3]});
        maxx2 = max({x1[0], x1[1], x1[2], x1[3]});
        miny2 = min({y1[0], y1[1], y1[2], y1[3]});
        maxy2 = max({y1[0], y1[1], y1[2], y1[3]});

        // 枚举所有可能的整数点
        for(int i = -100; i <= 100; i++) {
            for(int j = -100; j <= 100; j++) {
                if(check(i, j)) {
                    cout << "YES" << endl;
                    return 0;
                }
            }
        }
        cout << "NO" << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取两个正方形的顶点坐标。对于轴对齐正方形，直接计算其横纵坐标的最小和最大值（边界）；对于倾斜正方形，将每个顶点转换为(x+y, x-y)的坐标，再计算这两个新坐标的边界。随后枚举-100到100的所有整数点，判断是否同时满足两个正方形的边界条件，存在则输出“YES”。

---
<code_intro_selected>
下面重点分析zhang_kevin题解的核心代码片段：
</code_intro_selected>

**题解一：作者：zhang_kevin**
* **亮点**：通过坐标变换将倾斜正方形转换为矩形范围，大大简化了重叠判断；枚举范围合理（-100到100），确保覆盖所有可能的重叠点。
* **核心代码片段**：
    ```cpp
    inline bool check(int i, int j) {
        return (minx1 <= i && i <= maxx1) && 
               (miny1 <= j && j <= maxy1) && 
               (minx2 <= i + j && i + j <= maxx2) && 
               (miny2 <= i - j && i - j <= maxy2);
    }
    ```
* **代码解读**：  
  这个`check`函数是核心判断逻辑。参数`i`和`j`是枚举的点的坐标。前两个条件判断点是否在轴对齐正方形内（横纵坐标在`minx1~maxx1`和`miny1~maxy1`之间）；后两个条件判断点是否在倾斜正方形内（x+y在`minx2~maxx2`之间，x-y在`miny2~maxy2`之间）。四个条件同时满足时，说明该点是重叠点。
* 💡 **学习笔记**：函数封装使逻辑更清晰，`inline`关键字提升了函数调用效率（因频繁调用）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举和判断过程，我们设计一个“像素寻宝”动画，用8位风格展示两个正方形的位置及重叠点的查找。
</visualization_intro>

  * **动画演示主题**：像素世界的正方形重叠检测  
  * **核心演示内容**：轴对齐正方形（蓝色）和倾斜正方形（红色）的位置，枚举点（黄色闪烁）逐一检查，找到重叠点（绿色高亮）时播放胜利音效。

  * **设计思路简述**：8位像素风格降低学习压力，颜色区分不同正方形；枚举点的闪烁和高亮突出关键步骤；音效强化操作记忆（如“叮”表示找到重叠点）。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕中央显示201x201的像素网格（对应x/y从-100到100），左上角显示“开始/暂停/单步”按钮和速度滑块。  
        - 轴对齐正方形用蓝色像素块填充，倾斜正方形用红色像素块填充（仅显示边界）。

    2.  **枚举过程演示**：  
        - 黄色像素点从(-100,-100)开始，按行遍历每个点（i从-100到100，j从-100到100）。  
        - 当前枚举点用黄色闪烁标记，同时显示其坐标（如“检查点(0,0)”）。

    3.  **重叠判断可视化**：  
        - 调用`check`函数时，蓝色正方形的边界（minx1, maxx1等）和红色正方形的转换边界（minx2, maxx2等）用虚线高亮。  
        - 若点满足条件（重叠），该点变为绿色并放大，播放“叮~”音效，动画暂停并显示“找到重叠点！”。

    4.  **控制交互**：  
        - 支持单步执行（每次移动一个枚举点）、自动播放（速度可调）、重置（回到初始状态）。  
        - 自动播放时，背景播放8位风格的轻快音乐。

  * **旁白提示**：  
    - （枚举开始）“现在开始检查所有可能的点，从(-100,-100)开始~”  
    - （判断时）“这个点在蓝色正方形内吗？在红色正方形内吗？”  
    - （找到重叠点）“看！绿色点就是两个正方形的重叠点，输出‘YES’！”

<visualization_conclusion>
通过这个动画，我们能直观看到枚举的每一步和重叠判断的逻辑，轻松理解两个正方形如何重叠。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的坐标变换和枚举技巧后，可尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    坐标变换（如将旋转图形转换为轴对齐）和暴力枚举在几何问题中应用广泛，例如：  
    - 判断矩形与菱形的重叠；  
    - 检测点是否在旋转后的矩形内；  
    - 计算两个多边形的最小距离。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1125** - 笨小猴  
        * 🗣️ **推荐理由**：锻炼枚举和边界条件处理，与本题的枚举思路类似。
    2.  **洛谷 P1428** - 小鱼比可爱  
        * 🗣️ **推荐理由**：通过枚举解决统计问题，强化循环和条件判断的应用。
    3.  **洛谷 P5730** - 【深基5.例10】显示屏  
        * 🗣️ **推荐理由**：涉及坐标变换和图形显示，与本题的几何处理相关。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
通过对“Two Squares”的分析，我们掌握了坐标变换、暴力枚举等技巧，并通过可视化动画直观理解了算法过程。希望大家在练习中多思考、多尝试，几何问题也能轻松解决！下次见~ 💪
</conclusion>

-----

---
处理用时：376.16秒
# 题目信息

# Tree with Maximum Cost

## 题目描述

You are given a tree consisting exactly of $ n $ vertices. Tree is a connected undirected graph with $ n-1 $ edges. Each vertex $ v $ of this tree has a value $ a_v $ assigned to it.

Let $ dist(x, y) $ be the distance between the vertices $ x $ and $ y $ . The distance between the vertices is the number of edges on the simple path between them.

Let's define the cost of the tree as the following value: firstly, let's fix some vertex of the tree. Let it be $ v $ . Then the cost of the tree is $ \sum\limits_{i = 1}^{n} dist(i, v) \cdot a_i $ .

Your task is to calculate the maximum possible cost of the tree if you can choose $ v $ arbitrarily.

## 说明/提示

Picture corresponding to the first example: ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1092F/fdd33998ce4716fa490f243f16a780e7d58d0e7e.png)

You can choose the vertex $ 3 $ as a root, then the answer will be $ 2 \cdot 9 + 1 \cdot 4 + 0 \cdot 1 + 3 \cdot 7 + 3 \cdot 10 + 4 \cdot 1 + 4 \cdot 6 + 4 \cdot 5 = 18 + 4 + 0 + 21 + 30 + 4 + 24 + 20 = 121 $ .

In the second example tree consists only of one vertex so the answer is always $ 0 $ .

## 样例 #1

### 输入

```
8
9 4 1 7 10 1 6 5
1 2
2 3
1 4
1 5
5 6
5 7
5 8
```

### 输出

```
121
```

## 样例 #2

### 输入

```
1
1337
```

### 输出

```
0
```

# AI分析结果

# 💡 Kay的C++算法解析：Tree with Maximum Cost 深入学习指南 💡

<introduction>
今天我们来一起分析「Tree with Maximum Cost」这道经典的树型动态规划问题。题目要求我们在树中找到一个顶点，使得所有顶点到它的距离乘以权值的总和最大。这道题的核心是**换根动态规划（二次换根法）**，掌握它能帮我们高效解决大量树型问题。让我们一步步拆解思路吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（换根DP）

🗣️ **初步分析**：
解决这道题的关键是**换根DP**——一种能在O(n)时间内计算所有节点作为根时的答案的技巧。简单来说，换根DP就像“搬家”：
1. 先选一个临时根（比如节点1），算出以它为根的总费用（所有节点到它的距离×权值之和）；
2. 然后“搬到”相邻节点，利用临时根的费用快速算出新根的费用（不用重新计算所有节点）。

在本题中，换根DP的核心逻辑是：**当根从u转移到它的子节点v时，v的子树内的所有节点距离减少1（总费用减少子树权值和s[v]），其他节点距离增加1（总费用增加总权值sum - s[v]）**。因此，新根v的费用 = 原根u的费用 + (sum - s[v]) - s[v] = 原根费用 + sum - 2×s[v]。

**可视化设计思路**：
我们会用**8位像素风**（类似FC红白机）展示树结构：
- 节点用不同颜色的像素块表示（根节点闪烁），边用像素线连接；
- 第一次DFS时，子树权值和s[v]用“像素块颜色加深”表示，费用累加用“数字跳动”展示；
- 第二次DFS换根时，用“箭头指向新根”+“音效（叮~）”提示转移，费用变化用“红色减号/绿色加号”标注。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，它们都完美诠释了换根DP的核心逻辑：
</eval_intro>

**题解一：作者CreeperK**
* **点评**：这份题解堪称换根DP的“入门模板”！作者先解释了O(n²)的暴力思路（不适合大数据），再引出O(n)的换根DP。两次DFS的分工非常明确：第一次算子树权值和s[u]和根节点的费用s2[u]，第二次用“根转移公式”快速推导所有节点的费用。代码简洁，变量命名清晰（s[u]是子树权值和，s2[u]是子树内费用），还提到了与洛谷P2986的关联（双倍经验！），非常适合初学者参考。

**题解二：作者_l_l_**
* **点评**：这份题解的亮点是**把换根公式讲透了**！作者用一张图直观展示了根从u到v的变化：v的子树费用减s[v]，其他部分加(sum - s[v])，最终得出核心公式ans_v = ans_u + sum - 2×s[v]。代码中的变量命名也很友好（size[v]是子树权值和，dp[v]是v为根的费用），边界条件处理严谨（比如根节点1的费用计算）。

**题解三：作者lgswdn_SA**
* **点评**：这份题解的代码**最简炼**！作者用dfs1算子树权值和s[u]和根节点的费用ans[1]，用dfs2直接套用换根公式推导所有节点的费用。代码只有50行左右，却覆盖了所有核心逻辑，变量命名（s[u]、ans[u]）一看就懂，非常适合作为“模板代码”背诵。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
换根DP的思路不难，但要真正写对代码，需要突破三个核心难点：
</difficulty_intro>

1. **难点1：第一次DFS的状态设计——如何算子树权值和与根费用？**
    * **分析**：第一次DFS要算两个东西：
      - s[u]：以u为根的子树的权值总和（s[u] = a[u] + 所有子节点v的s[v]）；
      - ans[1]：以1为根的总费用（每个节点的深度×权值之和）。
    * 关键技巧：在DFS子节点v时，v的深度是u的深度+1，所以ans[1]可以累加a[v]×(dep[u]+1)，或者像题解中那样用“子树费用累加”（f[u] += f[v] + s[v]，因为子树v的每个节点到u的距离比到v多1，所以费用加s[v]）。
    * 💡 **学习笔记**：第一次DFS是“自底向上”收集子树信息，为第二次换根做准备。

2. **难点2：换根公式的推导——为什么ans[v] = ans[u] + sum - 2×s[v]？**
    * **分析**：当根从u到v时：
      - v的子树内的所有节点（共s[v]权值）到新根的距离减少1，总费用减少s[v]；
      - 其他节点（共sum - s[v]权值）到新根的距离增加1，总费用增加sum - s[v]；
      - 所以总变化是：(sum - s[v]) - s[v] = sum - 2×s[v]。
    * 关键技巧：画个图！把树分成v的子树和其他部分，就能直观理解费用变化。
    * 💡 **学习笔记**：换根公式是换根DP的“灵魂”，一定要推导一遍再用。

3. **难点3：数据类型——为什么要用long long？**
    * **分析**：题目中的n可以达到2e5，a[i]可以是很大的数，总费用很容易超过int的范围（2e9）。比如样例1的输出是121，但若n=2e5，a[i]=1e9，总费用会达到2e14，必须用long long存储。
    * 关键技巧：所有涉及费用、权值和的变量都要定义为long long（比如s[u]、ans[u]、sum）。
    * 💡 **学习笔记**：遇到大数问题，先想long long！

### ✨ 解题技巧总结
- **技巧1：先暴力，再优化**：如果想不出O(n)的方法，可以先想O(n²)的暴力（枚举每个根，DFS算费用），再思考如何用换根DP优化。
- **技巧2：画图辅助推导**：树型问题的公式推导，画个小例子（比如样例1的树）比空想更有效。
- **技巧3：模板化代码**：换根DP的代码结构固定（两次DFS），可以总结成模板：
  1. 第一次DFS算子树信息（s[u]、根费用）；
  2. 第二次DFS用换根公式推导所有节点的费用；
  3. 取最大值/最小值。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们以**lgswdn_SA的代码**为基础，提炼出通用核心实现。这份代码最简炼，覆盖了所有核心逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了换根DP的核心逻辑，用两次DFS解决问题，适合作为模板使用。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long  // 所有int都是long long，避免溢出
using namespace std;
const int N=2e5+9;

struct Edge { int to, nxt; } e[N*2];
int hd[N], tot;
void add(int u, int v) { e[++tot] = {v, hd[u]}; hd[u] = tot; }

int n, a[N], sum;
int s[N], ans[N], anss;  // s[u]子树权值和，ans[u]u为根的费用，anss最大值

// 第一次DFS：算s[u]和ans[1]
void dfs1(int u, int fa) {
    s[u] = a[u];
    for (int i=hd[u]; i; i=e[i].nxt) {
        int v = e[i].to;
        if (v == fa) continue;
        dfs1(v, u);
        s[u] += s[v];
        ans[1] += ans[v] + s[v];  // ans[1]累加子树v的费用（每个节点距离+1）
    }
}

// 第二次DFS：换根推导所有ans[u]
void dfs2(int u, int fa) {
    for (int i=hd[u]; i; i=e[i].nxt) {
        int v = e[i].to;
        if (v == fa) continue;
        ans[v] = ans[u] + sum - 2*s[v];  // 核心换根公式
        dfs2(v, u);
    }
    anss = max(anss, ans[u]);  // 更新最大值
}

signed main() {
    scanf("%lld", &n);
    for (int i=1; i<=n; i++) {
        scanf("%lld", &a[i]);
        sum += a[i];  // 总权值和
    }
    for (int i=1; i<n; i++) {
        int u, v;
        scanf("%lld%lld", &u, &v);
        add(u, v); add(v, u);  // 建双向边
    }
    dfs1(1, 0);  // 以1为根第一次DFS
    dfs2(1, 0);  // 换根DFS
    printf("%lld", anss);
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取n、每个节点的权值a[i]，并计算总权值sum；
  2. **建图**：用链式前向星存储树的边（双向）；
  3. **第一次DFS（dfs1）**：从根节点1出发，计算每个节点的子树权值和s[u]，以及根节点1的费用ans[1]；
  4. **第二次DFS（dfs2）**：从根节点1出发，用换根公式推导所有节点的费用ans[v]，并记录最大值anss；
  5. **输出结果**：打印最大值anss。

---

<code_intro_selected>
我们再剖析优质题解中的核心片段，看看它们的亮点：
</code_intro_selected>

**题解一：作者CreeperK**
* **亮点**：用s2[u]明确表示子树内的费用，逻辑更直观。
* **核心代码片段**：
```cpp
void dfs1(int u,int fa){
    s[u]=a[u]; s2[u]=0;
    for(int i=h[u],v;i;i=nex[i]){
        if((v=to[i])==fa)continue;
        dfs1(v,u);
        s[u]+=s[v];
        s2[u]+=s[v]+s2[v];  // s2[u]是子树内的费用，每个子节点v的费用加s[v]（距离+1）
    }
}
```
* **代码解读**：
  - s[u]是子树权值和，s2[u]是子树内的总费用（以u为根）；
  - 当处理子节点v时，v的子树内的每个节点到u的距离比到v多1，所以s2[u]要加上s[v]（每个节点的权值×1）和s2[v]（v子树内的费用）。
* 💡 **学习笔记**：用s2[u]单独存储子树费用，能让第一次DFS的逻辑更清晰。

**题解二：作者_l_l_**
* **亮点**：直接计算根节点1的费用（用depth[i]×a[i]），更直观。
* **核心代码片段**：
```cpp
void dfs1(int x, int fa, int dep) {
    depth[x] = dep;
    size[x] = a[x];
    for (int i=head[x]; i; i=edges[i].nxt) {
        int v = edges[i].to;
        if (v == fa) continue;
        dfs1(v, x, dep+1);
        size[x] += size[v];
    }
}

// 主函数中计算ans[1]：
for (int i=1; i<=n; i++) dp[1] += depth[i] * a[i];
```
* **代码解读**：
  - dfs1计算每个节点的深度depth[x]和子树权值和size[x]；
  - 主函数中直接遍历所有节点，计算根节点1的费用（depth[i]×a[i]之和）。
* 💡 **学习笔记**：如果觉得“子树费用累加”不好理解，可以用这种“直接计算深度”的方式，更直观。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地看到换根DP的过程，我设计了一个**8位像素风的动画**，结合复古游戏元素（比如FC的音效、像素块），让算法“动”起来！
</visualization_intro>

### **动画设计方案**
#### **1. 整体风格与场景**
- **8位像素风**：用FC红白机的配色（比如蓝色背景、黄色节点、绿色边），节点是3×3的像素块，边是1像素的线；
- **场景布局**：
  - 左侧：像素树（根节点1在顶部，子节点向下展开）；
  - 右侧：控制面板（开始/暂停、单步、重置按钮，速度滑块）；
  - 底部：信息栏（显示当前根节点、当前费用、s[v]、sum等）。

#### **2. 核心动画步骤**
**Step 1：初始化**
- 树结构展开（节点1闪烁，其他节点灰色）；
- 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

**Step 2：第一次DFS（计算s[u]和ans[1]）**
- 从节点1出发，递归访问子节点（比如节点2、4、5）；
- 每访问一个子节点v：
  - v的像素块颜色从灰色变黄色（表示已访问）；
  - s[v]的数值在信息栏跳动（比如s[2] = a[2] = 4）；
  - 当回溯到父节点u时，s[u]累加s[v]（比如s[1] = a[1] + s[2] + s[4] + s[5] = 9+4+7+10=30）；
  - 播放“滴~”的音效（表示累加完成）。

**Step 3：第二次DFS（换根推导ans[v]）**
- 根节点从1转移到2：
  - 箭头从1指向2（表示换根）；
  - 信息栏显示“ans[2] = ans[1] + sum - 2×s[2]”（比如ans[1]=初始费用，sum=30+...？不对，sum是总权值和，比如样例1的sum=9+4+1+7+10+1+6+5=43）；
  - ans[2]的数值在信息栏跳动（比如从ans[1]的某个值变成新值）；
  - 播放“叮~”的音效（表示换根完成）；
- 依次转移到所有节点，每个节点的费用显示在信息栏。

**Step 4：结果展示**
- 所有节点的费用计算完成后，最大值节点（比如样例1的节点3）闪烁红色；
- 播放“胜利”音效（比如《魂斗罗》的通关音乐）；
- 信息栏显示最终结果（比如121）。

#### **3. 交互设计**
- **单步执行**：点击“单步”按钮，动画执行一步（比如访问一个子节点、换根一次）；
- **自动播放**：点击“开始”按钮，动画自动执行，速度可以通过滑块调节（慢→快）；
- **重置**：点击“重置”按钮，回到初始状态，重新开始。

#### **4. 游戏化元素**
- **关卡设计**：把第一次DFS和第二次DFS分成两个“小关卡”，完成一个关卡后，信息栏显示“关卡1完成！”并播放提示音效；
- **积分奖励**：每完成一次换根，奖励10分，积分显示在信息栏右上角，增加成就感。

<visualization_conclusion>
通过这个像素动画，你能清楚看到换根DP的每一步：子树权值和的累加、根节点的转移、费用的变化。复古游戏元素让学习更有趣，再也不用死记硬背公式啦！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
换根DP是树型问题的“万能钥匙”，掌握它能解决很多类似问题。比如：
</similar_problems_intro>

### **通用思路迁移**
换根DP适用于**需要计算所有节点作为根时的某个值**的问题，比如：
1. 求树中每个节点的子树大小（已经会了！）；
2. 求树中每个节点的最远节点距离（树的直径问题）；
3. 求树中每个节点的最小/最大费用（比如本题的最大费用）。

### **洛谷练习推荐**
1. **洛谷 P2986** - 伟大的奶牛聚集
   * 🗣️ **推荐理由**：本题的“孪生兄弟”！要求找一个节点，使得所有奶牛到它的距离×数量之和最小，换根公式几乎一样，直接套用模板就能过。
2. **洛谷 P3478** - Tree Query
   * 🗣️ **推荐理由**：求树中每个节点的子树内的节点数，以及父节点方向的节点数，是换根DP的基础练习。
3. **洛谷 P5043** - 树的同构
   * 🗣️ **推荐理由**：需要用换根DP计算树的哈希值，判断两棵树是否同构，是换根DP的进阶应用。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们能学到很多“踩坑”经验：
</insights_intro>

> **参考经验（来自CreeperK）**：“这题是洛谷P2986的双倍经验！”
> **点评**：多做相似题能快速掌握算法套路。比如P2986是求最小值，本题是求最大值，换根公式完全一样，只是最后取最大值还是最小值的区别。

> **参考经验（来自lgswdn_SA）**：“记得用long long！”
> **点评**：这是很多初学者会犯的错误。比如样例1的总费用是121，用int没问题，但当n=2e5时，总费用会超过int的范围（2e9），必须用long long。


<conclusion>
本次关于「Tree with Maximum Cost」的分析就到这里啦！换根DP的核心是“先算一个根，再快速推导其他根”，关键是要理解换根公式的推导过程。记住：画图辅助、多做相似题、注意数据类型，你一定能掌握换根DP！下次我们再一起探索更复杂的树型问题吧！💪
</conclusion>

---
处理用时：156.43秒
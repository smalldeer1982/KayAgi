# 题目信息

# Cover it!

## 题目描述

You are given an undirected unweighted connected graph consisting of $ n $ vertices and $ m $ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.

Your task is to choose at most $ \lfloor\frac{n}{2}\rfloor $ vertices in this graph so each unchosen vertex is adjacent (in other words, connected by an edge) to at least one of chosen vertices.

It is guaranteed that the answer exists. If there are multiple answers, you can print any.

You will be given multiple independent queries to answer.

## 说明/提示

In the first query any vertex or any pair of vertices will suffice.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1176E/425f889a93c1cbf45927e909f714357cbb29729c.png)Note that you don't have to minimize the number of chosen vertices. In the second query two vertices can be enough (vertices $ 2 $ and $ 4 $ ) but three is also ok.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1176E/95acc958b4ac046071fd74b6c58c6e3e5d349deb.png)

## 样例 #1

### 输入

```
2
4 6
1 2
1 3
1 4
2 3
2 4
3 4
6 8
2 5
5 4
4 3
4 1
1 3
2 3
2 6
5 6
```

### 输出

```
2
1 3
3
4 3 6
```

# AI分析结果

# 💡 Kay的C++算法解析：Cover it! 深入学习指南 💡

<introduction>
今天我们来一起分析「Cover it!」这道C++编程题。题目要求我们在无向连通图中选最多⌊n/2⌋个顶点，让每个未选顶点至少有一个邻居被选。本指南会帮你梳理核心思路、理解关键算法，并通过像素动画直观感受过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论 - 二分图奇偶层划分  

🗣️ **初步分析**：  
解决这道题的关键，在于利用**「树的二分性」**——所有树（连通无环图）都是二分图，可以把节点按「深度奇偶性」分成两个集合（比如奇数层是“黑”，偶数层是“白”），相邻节点的颜色一定不同。  

在本题中，我们可以先给原图找一棵生成树（因为原图连通，生成树一定存在），然后把生成树的节点按深度奇偶分成两个集合。由于两个集合的大小之和是n，**必有一个集合的大小≤⌊n/2⌋**（比如n=4时，两个集合可能是2和2；n=5时是2和3）。选这个较小的集合就满足条件：未选的节点都在另一个集合，必然与选中的节点相邻（因为相邻节点颜色不同）。  

- **核心算法流程**：用DFS/BFS遍历生成树→记录每个节点的深度→按奇偶分两个集合→选较小的集合输出。  
- **可视化设计思路**：用FC红白机风格的像素块展示节点，DFS遍历时高亮当前节点，用“黑/白”像素块标记奇偶层，最后闪烁选中的集合，伴随“叮”的音效强化关键操作。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：(来源：hzjnsy，赞3)**  
* **点评**：这份题解的思路非常简洁——用DFS找生成树，按深度奇偶分集合，选较小的那个。它的核心亮点是**用反证法证明了必有一个集合≤⌊n/2⌋**（如果两个集合都超过n/2，总和会超过n，矛盾），逻辑严谨。时间复杂度O(n+m)，完全覆盖题目要求，是最经典的解法。

**题解二：(来源：registerGen，赞2)**  
* **点评**：这是一种“贪心”变形思路——枚举每个未访问的节点u，把u加入集合S，把u的未访问邻居加入集合T。最后选S或T中较小的。虽然没有显式生成树，但本质还是利用了“相邻节点分属不同集合”的特性，代码更简洁（用col数组标记集合），适合新手理解。

**题解三：(来源：Ryo_Yamada，赞2)**  
* **点评**：这份题解的代码最清晰——用DFS遍历生成树，记录每个节点的深度，分两个数组存奇偶层节点，最后选较小的数组输出。它处理了多连通块的情况（虽然题目保证连通，但代码通用性强），变量命名直观（比如d[0]存偶数层，d[1]存奇数层），非常适合学习“如何把思路转化为代码”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于理解三个“为什么”——为什么奇偶层划分有效？为什么集合大小满足要求？为什么生成树可行？
</difficulty_intro>

1. **关键点1：为什么奇偶层划分的集合满足条件？**  
   * **分析**：生成树中，相邻节点的深度奇偶性一定不同（比如父节点深度是k，子节点是k+1）。如果选中奇数层的节点，那么偶数层的节点必然与父节点（奇数层）相邻；反之亦然。因此未选节点一定有邻居被选。  
   * 💡 **学习笔记**：相邻节点深度奇偶不同，是奇偶层划分有效的核心！

2. **关键点2：为什么必有一个集合≤⌊n/2⌋？**  
   * **分析**：设两个集合的大小为a和b，a + b = n。如果a > ⌊n/2⌋，那么b = n - a ≤ n - (⌊n/2⌋ + 1) = ⌊n/2⌋（比如n=5，a=3>2，b=2≤2；n=4，a=3>2，b=1≤2）。因此必有一个集合满足要求。  
   * 💡 **学习笔记**：利用“总和固定”的性质，反证法能快速证明集合大小的限制！

3. **关键点3：为什么用生成树而不是原图？**  
   * **分析**：原图可能有环，但生成树保留了原图的连通性，且没有环（是二分图）。用生成树的奇偶层划分，结果对原图依然有效——因为原图的边要么在生成树里（已考虑），要么是环的边（不影响相邻关系）。  
   * 💡 **学习笔记**：生成树是处理连通图问题的常用技巧，能简化问题！

### ✨ 解题技巧总结
- **技巧A：问题转化**：把“覆盖所有未选节点”转化为“选二分图的一个集合”，利用二分图的性质简化问题。  
- **技巧B：反证法**：当需要证明“必有一个满足条件”时，反证法是利器（比如证明集合大小≤⌊n/2⌋）。  
- **技巧C：生成树简化**：连通图的问题，常可以先找生成树，把复杂的图转化为简单的树处理。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——综合了Ryo_Yamada和hzjnsy的思路，用DFS遍历生成树，分奇偶层选较小集合，代码清晰易读。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Ryo_Yamada的题解，调整了变量命名使其更直观，是最经典的奇偶层划分实现。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cstring>
  using namespace std;

  const int N = 2e5 + 5;
  int n, m;
  vector<int> e[N];  // 邻接表存图
  bool vis[N];       // 标记是否访问过
  int dep[N];        // 记录节点深度
  vector<int> d[2];  // d[0]存偶数层节点，d[1]存奇数层节点

  // DFS遍历生成树，记录深度
  void dfs(int u, int fa) {
    vis[u] = true;
    dep[u] = dep[fa] + 1;  // 子节点深度=父节点深度+1
    d[dep[u] % 2].push_back(u);  // 按奇偶存入不同数组
    for (int v : e[u]) {
      if (!vis[v] && v != fa) {
        dfs(v, u);
      }
    }
  }

  int main() {
    int T;
    cin >> T;
    while (T--) {
      cin >> n >> m;
      // 初始化
      for (int i = 1; i <= n; ++i) {
        e[i].clear();
        vis[i] = false;
      }
      d[0].clear();
      d[1].clear();
      dep[0] = 0;  // 根节点的父节点深度为0

      // 读入边
      for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
      }

      // DFS遍历（从1号节点开始，父节点是0）
      dfs(1, 0);

      // 选较小的集合输出
      vector<int> &ans = d[0].size() <= d[1].size() ? d[0] : d[1];
      cout << ans.size() << endl;
      for (int u : ans) {
        cout << u << " ";
      }
      cout << endl;
    }
    return 0;
  }
  ```
* **代码解读概要**：  
  1. 用邻接表`e`存图，`vis`标记访问，`dep`记录深度，`d`数组存奇偶层节点。  
  2. `dfs`函数从根节点（1号）开始，递归遍历子节点，记录每个节点的深度和奇偶层。  
  3. 最后比较`d[0]`和`d[1]`的大小，选较小的输出。


<code_intro_selected>
再看两份优质题解的核心片段，学习不同的实现风格！
</code_intro_selected>

**题解二：(来源：registerGen)**
* **亮点**：不用DFS，直接贪心枚举节点，代码更简洁。
* **核心代码片段**：
  ```cpp
  int col[N + 10];  // 1表示集合S，2表示集合T
  bool vis[N + 10];

  void mian() {
    // 读入n,m和边...
    for (int u = 1; u <= n; u++)
      if (!vis[u]) {
        vis[u] = 1;
        col[u] = 1;  // u加入S
        for (int i = head[u]; i; i = e[i].nxt) {
          int v = e[i].to;
          if (!vis[v]) {
            vis[v] = 1;
            col[v] = 2;  // v加入T
          }
        }
      }
    // 选S或T中较小的输出...
  }
  ```
* **代码解读**：  
  枚举每个未访问的节点u，把u加入集合S（col[u]=1），然后把u的未访问邻居加入集合T（col[v]=2）。这样S和T中的节点相邻，最后选较小的集合。这种方法不用递归，适合怕栈溢出的情况！
* 💡 **学习笔记**：贪心是DFS的简化版，本质还是二分集合！

**题解三：(来源：Ryo_Yamada)**
* **亮点**：处理多连通块（虽然题目保证连通，但代码通用）。
* **核心代码片段**：
  ```cpp
  rep(i, 1, n) if(!vis[i]) {  // 遍历每个未访问的连通块
    d[0].clear(), d[1].clear();
    c[0] = c[1] = 0;
    dfs(i, 0);  // 遍历当前连通块
    if(c[0] > c[1]) for(int v : d[1]) ans.pb(v);
    else for(int v : d[0]) ans.pb(v);
  }
  ```
* **代码解读**：如果图有多个连通块（比如题目没说连通，但本题保证连通），需要对每个连通块单独处理，选每个连通块的较小集合，合并起来就是答案。这种写法通用性强，值得学习！
* 💡 **学习笔记**：处理多连通块时，要遍历每个未访问的节点，单独处理！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观看到「奇偶层划分」的过程，我设计了一个**FC红白机风格的像素动画**——像玩《超级马里奥》一样看算法运行！
</visualization_intro>

### 动画方案详情
* **动画主题**：像素探险家在「树迷宫」中标记奇偶层，最后收集较小的集合。
* **设计思路**：用8位像素风格（比如《塞尔达传说》的画面），让算法步骤像游戏关卡一样有趣，用音效强化关键操作，帮助记忆。


#### 1. 场景与UI初始化 (FC风格)
- **画布**：用320x240的Canvas，背景是浅灰色，节点是16x16的像素块（红色=未访问，蓝色=奇数层，绿色=偶数层）。
- **控制面板**：下方有「开始/暂停」「单步」「重置」按钮，以及速度滑块（1x~5x）。
- **背景音乐**：循环播放《超级马里奥》的8位BGM（轻快的钢琴音）。


#### 2. 算法步骤动态演示
- **步骤1：初始化**：所有节点是红色（未访问），根节点（1号）闪烁，伴随“叮”的音效（提示开始）。
- **步骤2：DFS遍历**：
  - 点击「单步」，根节点变成蓝色（奇数层，depth=1），然后递归访问它的邻居（子节点）。
  - 子节点变成绿色（偶数层，depth=2），再访问子节点的邻居（depth=3，蓝色），依此类推。
  - 每访问一个节点，播放轻微的“咔嗒”声，当前节点用黄色边框高亮（提示“正在处理这个节点”）。
- **步骤3：分集合**：遍历结束后，蓝色和绿色节点分别闪烁，旁边显示“蓝色集合大小：X”“绿色集合大小：Y”。
- **步骤4：选较小集合**：较小的集合（比如绿色）开始闪烁，伴随“胜利”音效（上升的音阶），提示“这是选中的节点！”。


#### 3. 交互设计
- **单步模式**：点击「单步」，每一步只处理一个节点，适合慢慢看流程。
- **自动模式**：滑动速度滑块，算法自动运行（1x=每秒1步，5x=每秒5步），像看游戏AI通关。
- **重置**：点击「重置」，所有节点回到红色，重新开始。


#### 4. 旁白提示（文字气泡）
- 开始时：“探险家要给树节点分颜色啦！红色是未访问，蓝色是奇数层，绿色是偶数层～”
- 访问节点时：“现在处理节点X，它的深度是Y，属于[蓝色/绿色]层！”
- 选集合时：“绿色集合更小，选它！未选的蓝色节点都和绿色相邻哦～”


<visualization_conclusion>
这个动画把抽象的“奇偶层划分”变成了可看、可玩的游戏，你能清楚看到每个节点的深度变化，以及最终选中的集合。下次遇到类似问题，你肯定能立刻想起这个“像素探险家”的故事！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「奇偶层划分」的思路不仅能解决这道题，还能用到很多图论问题中——比如封锁图、选点覆盖等。
</similar_problems_intro>

### 通用思路迁移
- **场景1**：封锁图（比如P1330 封锁阳光大学）：选最少的点，让每条边至少有一个端点被选——本质是选二分图的较小集合。
- **场景2**：树的染色问题：给树染色，相邻节点颜色不同，求最少用多少种颜色——二分图只需要2种！
- **场景3**：最大独立集：选最多的点，使得没有两个点相邻——选二分图的较大集合！


### 洛谷练习推荐
1. **洛谷 P1330 - 封锁阳光大学**  
   🗣️ **推荐理由**：这道题是「奇偶层划分」的直接应用，要求选最少的点封锁所有边，和本题思路完全一致，帮你巩固基础！

2. **洛谷 P2051 - [AHOI2009] 中国象棋**  
   🗣️ **推荐理由**：虽然是象棋问题，但用到了“分层选点”的思路，帮你拓展思维，学会把新问题转化为旧模型！

3. **洛谷 P1196 - [NOI2002] 银河英雄传说**  
   🗣️ **推荐理由**：这道题需要用并查集维护树的结构，和本题的“生成树遍历”结合，帮你加深对树结构的理解！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了自己的“踩坑”经历，这些经验能帮你少走弯路！
</insights_intro>

> **参考经验 (来自__Deng_Rui_Song__)**：“我一开始跑了两次DFS（选点1和不选点1），但后来发现其实不用——因为两个集合的大小之和是n，选较小的就行！”  
> **点评**：这位作者的经历提醒我们——**不要做多余的工作**！题目只要求选一个满足条件的集合，不需要跑两次DFS，用奇偶层划分一次就能解决。


<conclusion>
本次关于「Cover it!」的分析就到这里。记住：图论问题的核心是**找模型**——把“覆盖未选节点”转化为“二分图选集合”，问题就变得简单了！下次遇到图论问题，先想想“能不能用二分图的性质？”，你会发现很多问题都能迎刃而解～💪
</conclusion>

---
处理用时：149.08秒
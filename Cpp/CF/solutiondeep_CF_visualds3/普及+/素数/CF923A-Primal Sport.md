# 题目信息

# Primal Sport

## 题目描述

Alice and Bob begin their day with a quick game. They first choose a starting number $ X_{0}>=3 $ and try to reach one million by the process described below.

Alice goes first and then they take alternating turns. In the $ i $ -th turn, the player whose turn it is selects a prime number smaller than the current number, and announces the smallest multiple of this prime number that is not smaller than the current number.

Formally, he or she selects a prime $ p&lt;X_{i-1} $ and then finds the minimum $ X_{i}>=X_{i-1} $ such that $ p $ divides $ X_{i} $ . Note that if the selected prime $ p $ already divides $ X_{i-1} $ , then the number does not change.

Eve has witnessed the state of the game after two turns. Given $ X_{2} $ , help her determine what is the smallest possible starting number $ X_{0} $ . Note that the players don't necessarily play optimally. You should consider all possible game evolutions.

## 说明/提示

In the first test, the smallest possible starting number is $ X_{0}=6 $ . One possible course of the game is as follows:

- Alice picks prime 5 and announces $ X_{1}=10 $
- Bob picks prime 7 and announces $ X_{2}=14 $ .

In the second case, let $ X_{0}=15 $ .

- Alice picks prime 2 and announces $ X_{1}=16 $
- Bob picks prime 5 and announces $ X_{2}=20 $ .

## 样例 #1

### 输入

```
14
```

### 输出

```
6
```

## 样例 #2

### 输入

```
20
```

### 输出

```
15
```

## 样例 #3

### 输入

```
8192
```

### 输出

```
8191
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Primal Sport 深入学习指南 💡

<introduction>
今天我们来一起分析“Primal Sport”这道C++编程题。这道题需要我们根据给定的X₂，逆向推导出最小的可能起始值X₀。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质因数分解与预处理）`

🗣️ **初步分析**：
解决“Primal Sport”这道题，关键在于理解如何通过逆向推导，利用质因数的性质找到最小的X₀。简单来说，质因数分解就像“拆数字的积木”，每个数都能被分解成若干质数的乘积，而最大质因数则是其中最大的那块“积木”。在本题中，我们需要通过预处理每个数的最大质因数，逆向推导X₁的可能范围，再从X₁推导X₀的最小值。

- **题解思路**：所有优质题解的核心思路都是：首先预处理每个数的最大质因数（类似筛法求质数），然后根据X₂的最大质因数p₂，确定X₁的可能范围是[X₂-p₂+1, X₂]。接着枚举这个范围内的每个X₁，计算其最大质因数p₁，从而得到X₀的可能值（X₁-p₁+1），最终取所有可能的X₀中的最小值。
- **核心难点**：如何高效预处理每个数的最大质因数？如何确定X₁的范围并枚举？
- **可视化设计**：我们计划用8位像素风格动画演示筛法预处理最大质因数的过程（如用不同颜色的像素块标记质数和合数，高亮每个数的最大质因数），以及枚举X₁时如何计算X₀的最小值（用箭头动态展示X₁到X₀的推导）。动画中会加入“叮”的音效提示关键步骤（如标记质数、更新最大质因数），完成计算时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者Blunt_Feeling**
* **点评**：这份题解思路非常简洁，通过筛法预处理每个数的最大质因数，代码仅用了20行左右。其亮点在于用数组a[j]=i标记j的最大质因数（i是质数），这种预处理方法高效且易于理解。代码变量名清晰（如x2表示输入的X₂，x0表示最终结果），边界处理严谨（直接取x0的最小值）。从实践角度看，这段代码可以直接用于竞赛，时间复杂度为O(X₂)，适合处理较大的输入。

**题解二：作者Jasper08**
* **点评**：此题解详细推导了X₁和X₀的范围（X_i-P_i+1 ≤ X_{i-1} ≤ X_i），逻辑推导过程清晰。代码中通过分解质因数求最大质因数（如循环分解t的质因数，记录最大的p2），虽然时间复杂度略高（O(√X₂)分解质因数），但适合理解核心逻辑。变量命名直观（如p2表示X₂的最大质因数），对边界条件（X0≥3）的处理很细致。

**题解三：作者ModestCoder_**
* **点评**：此题解使用线性筛法（欧拉筛）预处理最大质因数数组a，时间复杂度为O(X₂)，效率更高。代码中flag数组标记合数，prime数组存储质数，a数组记录每个数的最大质因数，这种方法在处理大数时更高效。枚举X₁的循环简洁（直接遍历n-a[n]+1到n），代码结构工整，适合学习线性筛的应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效预处理每个数的最大质因数？
    * **分析**：预处理最大质因数是解题的基础。优质题解通常使用筛法（如埃氏筛或欧拉筛）：遍历每个数i，如果i是质数（未被标记），则将其所有倍数的最大质因数标记为i。例如，埃氏筛中，对于每个质数i，标记i的倍数j的最大质因数为i（因为i是j的最小质因数，但后续更大的质因数会覆盖它吗？不，这里需要注意：实际上，最大质因数需要在筛的过程中逐步更新。例如，欧拉筛中，每个合数j=i*prime[k]的最大质因数是i的最大质因数，因为prime[k]是i的最小质因数，所以i的最大质因数一定≥prime[k]。因此，用欧拉筛可以正确记录最大质因数。）
    * 💡 **学习笔记**：筛法不仅能找质数，还能预处理每个数的最大质因数，这在数论问题中非常实用。

2.  **关键点2**：如何确定X₁的可能范围？
    * **分析**：根据题意，X₂是Bob选择的质数p₂的倍数且≥X₁，因此X₁的最小可能值是X₂-p₂+1（因为p₂是X₂的最大质因数，若X₁更小，则X₂-p₂也是p₂的倍数且≥X₁，矛盾）。因此X₁的范围是[X₂-p₂+1, X₂]。
    * 💡 **学习笔记**：逆向推导时，抓住“X_i是p_i的倍数且最小”这一条件，可确定X_{i-1}的下界。

3.  **关键点3**：如何从X₁推导X₀的最小值？
    * **分析**：X₀的范围是[X₁-p₁+1, X₁]（p₁是X₁的最大质因数），要使X₀最小，需取X₁-p₁+1。因此枚举X₁的可能值，计算对应的X₁-p₁+1，取其中最小的≥3的值即可。
    * 💡 **学习笔记**：X₀的最小值由X₁的最大质因数决定，因此找到每个X₁的最大质因数是关键。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理最大质因数**：使用筛法（如欧拉筛）预处理每个数的最大质因数数组，时间复杂度O(n)，高效且代码简洁。
- **逆向推导范围**：根据题意，利用“X_i是p_i的最小倍数≥X_{i-1}”，逆向推出X_{i-1}的范围[X_i-p_i+1, X_i]。
- **枚举优化**：在确定的X₁范围内枚举，仅需遍历O(p₂)个数（p₂是X₂的最大质因数，通常远小于X₂），时间复杂度低。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先看一个综合了多个优质题解思路的通用核心C++实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Blunt_Feeling、ModestCoder_等题解的思路，使用欧拉筛预处理最大质因数数组，高效且易于理解。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    const int MAXN = 1e6 + 10;
    int max_prime[MAXN]; // 记录每个数的最大质因数
    bool is_composite[MAXN]; // 标记是否为合数

    int main() {
        int x2;
        cin >> x2;

        // 欧拉筛预处理最大质因数
        for (int i = 2; i <= x2; ++i) {
            if (!is_composite[i]) { // i是质数
                max_prime[i] = i;
                for (int j = 2 * i; j <= x2; j += i) {
                    is_composite[j] = true;
                    max_prime[j] = i; // 初始标记为i（可能被更大的质因数覆盖）
                }
            }
        }
        // 修正最大质因数（埃氏筛的优化版）
        for (int i = x2; i >= 2; --i) {
            if (is_composite[i]) {
                for (int j = 2 * i; j <= x2; j += i) {
                    max_prime[j] = max(max_prime[j], i);
                }
            }
        }

        int p2 = max_prime[x2];
        int ans = x2;

        // 枚举X1的可能范围：[x2 - p2 + 1, x2]
        for (int x1 = x2 - p2 + 1; x1 <= x2; ++x1) {
            int p1 = max_prime[x1];
            int x0 = x1 - p1 + 1;
            if (x0 >= 3) { // 题目要求X0 >= 3
                ans = min(ans, x0);
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先使用欧拉筛预处理每个数的最大质因数数组`max_prime`。然后根据输入的X₂，找到其最大质因数p₂，确定X₁的范围。接着枚举该范围内的每个X₁，计算其最大质因数p₁，从而得到X₀的可能值，最终取最小的有效X₀（≥3）。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：作者Blunt_Feeling**
* **亮点**：代码极简，利用埃氏筛直接标记每个合数的最大质因数（i是质数时，标记其倍数的最大质因数为i）。
* **核心代码片段**：
    ```cpp
    For(i,2,x2)
        if(!a[i])
            for(int j=i*2;j<=x2;j+=i)
                a[j]=i;
    ```
* **代码解读**：
    这里的`a`数组就是最大质因数数组。外层循环遍历2到X₂的每个数i，如果i未被标记（是质数），则将其所有倍数j的`a[j]`标记为i（即j的最大质因数至少是i）。例如，i=2时，j=4,6,8...的`a[j]`被标记为2；i=3时，j=6,9,12...的`a[j]`被更新为3（因为3>2）。最终，`a[j]`存储的是j的最大质因数。
* 💡 **学习笔记**：埃氏筛不仅能找质数，还能通过反向标记（从小到大遍历质数）间接得到每个数的最大质因数。

**题解二：作者Jasper08**
* **亮点**：通过分解质因数直接求最大质因数，适合理解质因数分解的过程。
* **核心代码片段**：
    ```cpp
    int t = x2, p2 = 1;
    for (int i = 2; i <= t/i; ++i) {
        while (t % i == 0)
            t /= i, p2 = i;
    }
    if (t > 1) p2 = t;
    ```
* **代码解读**：
    这段代码分解x2的质因数，记录最大的质因数p2。例如，x2=14时，分解为2×7，p2=7；x2=20时，分解为2²×5，p2=5。循环遍历i从2到√t，每次将t除以i（直到不能整除），最后若t>1则t本身是质数（最大质因数）。
* 💡 **学习笔记**：分解质因数是求最大质因数的基本方法，适合小范围数的处理。

**题解三：作者ModestCoder_**
* **亮点**：使用线性筛（欧拉筛）预处理最大质因数，时间复杂度O(n)，效率更高。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= n; ++i) {
        if (!flag[i]) prime[++tot] = a[i] = i;
        for (int j = 1; j <= tot && i * prime[j] <= n; ++j) {
            flag[i * prime[j]] = 1, a[i * prime[j]] = a[i];
            if (i % prime[j] == 0) break;
        }
    }
    ```
* **代码解读**：
    `flag`数组标记合数，`prime`数组存储质数，`a`数组记录最大质因数。对于每个数i，若i是质数（未被标记），则将其加入prime数组，且a[i]=i。然后用i乘以已找到的质数prime[j]，标记合数i*prime[j]，并将其最大质因数设为a[i]（即i的最大质因数）。由于欧拉筛每个合数只被最小质因数筛一次，因此a[i*prime[j]]的最大质因数是i的最大质因数（因为prime[j]是i的最小质因数，i的最大质因数≥prime[j]）。
* 💡 **学习笔记**：线性筛的时间复杂度更低，适合处理大范围的数（如1e6以上）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“预处理最大质因数”和“枚举X₁求X₀”的过程，我设计了一个8位像素风格的动画演示方案。让我们一起“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素质数探险——寻找最小X₀大冒险`

  * **核心演示内容**：演示欧拉筛预处理最大质因数的过程，以及枚举X₁时如何计算X₀的最小值。

  * **设计思路简述**：采用8位像素风（类似FC游戏），用不同颜色的像素块表示质数（绿色）、合数（黄色）、最大质因数（红色标记）。通过动态标记和合数的生成，帮助理解筛法的原理；通过箭头和数字变化，展示X₁到X₀的推导过程。音效（如“叮”声）提示关键操作（如标记质数、更新最大质因数），增加记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧是一个像素网格（10x10），每个格子代表一个数（1到X₂），初始颜色为灰色。
          * 右侧是控制面板：开始/暂停、单步、重置按钮，速度滑块（1-5级）。
          * 播放8位风格的轻快背景音乐（类似《超级玛丽》的过场音乐）。

    2.  **筛法预处理最大质因数**：
          * **标记质数**：从i=2开始，若当前数i是灰色（未被标记），则变为绿色（质数），播放“叮”音效。然后遍历i的倍数j（i*2, i*3...），将j的颜色变为黄色（合数），并在j的格子上显示红色数字（当前i，即j的最大质因数候选）。
          * **更新最大质因数**：当i增大时（如i=3），若j=6已被标记为合数（黄色），但i=3>之前的红色数字2，则将j的红色数字更新为3，播放“滴答”音效（表示更新）。

    3.  **枚举X₁求X₀**：
          * 输入X₂（如14），找到其最大质因数p₂（7），在网格中高亮X₂的格子（蓝色），并显示p₂=7。
          * 确定X₁的范围[14-7+1=8, 14]，用蓝色箭头从X₂向左延伸，覆盖8到14的格子。
          * 逐个枚举X₁（如8,9,10,11,12,13,14），计算每个X₁的最大质因数p₁，并显示X₀=X₁-p₁+1。例如，X₁=10时，p₁=5（最大质因数），X₀=10-5+1=6，此时X₀的格子（6）变为紫色（候选最小值）。
          * 最终找到最小的X₀（如6），播放胜利音效（上扬的“啦”声），并在屏幕中央显示“最小X₀是6！”。

    4.  **交互控制**：
          * 单步执行：点击“单步”按钮，每次执行一个筛法步骤或一个X₁的枚举。
          * 自动播放：调整速度滑块（慢到快），算法自动运行，学习者可观察整体流程。
          * 重置：点击“重置”按钮，清空网格，重新开始。

  * **旁白提示**：
      * （筛法步骤）“看！i=2是质数，它的倍数4、6、8...都被标记为合数，它们的最大质因数暂时是2哦～”
      * （更新最大质因数）“现在i=3是质数，它的倍数6、9、12...的最大质因数会被更新为3，因为3比之前的2大！”
      * （枚举X₁）“X₂=14的最大质因数是7，所以X₁的范围是8到14。我们需要计算每个X₁的最大质因数，找到最小的X₀～”

<visualization_conclusion>
通过这样的像素动画，我们不仅能直观看到筛法如何预处理最大质因数，还能清晰理解X₁和X₀的推导过程，让抽象的数论问题变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考质因数分解在其他问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 质因数分解不仅用于本题，还常用于处理数论中的最大公约数、最小公倍数、约数个数等问题。
      - 预处理最大质因数的方法可以迁移到“求某个范围内每个数的质因数分解”“判断数的互质性”等场景。
      - 逆向推导范围的思想在类似“根据最终状态求初始状态”的问题中（如游戏回溯、动态规划逆推）也很常见。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1075 [NOIP2012 提高组] 质因数分解**
          * 🗣️ **推荐理由**：这道题直接考察质因数分解，帮助巩固质因数分解的基本方法。
    2.  **洛谷 P1069 [NOIP2009 普及组] 细胞分裂**
          * 🗣️ **推荐理由**：此题需要结合质因数分解和数学推导，锻炼逆向思考能力。
    3.  **洛谷 P1579 哥德巴赫猜想（升级版）**
          * 🗣️ **推荐理由**：通过质因数分解判断质数，适合练习筛法的应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但根据题解内容，我们可以总结：预处理最大质因数是解决此类问题的关键，而筛法是高效预处理的核心工具。在编码时，建议先画流程图理清X₀、X₁、X₂的关系，再编写筛法和枚举逻辑，避免因逻辑混乱导致错误。
</insights_intro>

-----

<conclusion>
本次关于“Primal Sport”的C++解题分析就到这里。希望这份学习指南能帮助大家理解质因数分解的应用和逆向推导的思路。记住，编程能力的提升需要多思考、多练习，下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：152.65秒
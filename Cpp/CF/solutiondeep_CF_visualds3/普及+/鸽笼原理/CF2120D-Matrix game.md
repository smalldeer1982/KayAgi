# 题目信息

# Matrix game

## 题目描述

Aryan 和 Harshith 玩一个游戏。他们都从三个整数 $a$、$b$ 和 $k$ 开始。然后 Aryan 给 Harshith 两个整数 $n$ 和 $m$。接着，Harshith 给 Aryan 一个 $n$ 行 $m$ 列的矩阵 $X$，其中 $X$ 的每个元素都在 $1$ 到 $k$（包含 $k$）之间。之后，如果 Aryan 能在 $X$ 中找到一个 $a$ 行 $b$ 列的子矩阵 $Y$，且 $Y$ 的所有元素都相等，则 Aryan 获胜。

例如，当 $a=2$，$b=2$，$k=6$，$n=3$ 且 $m=3$ 时，如果 Harshith 给 Aryan 如下矩阵，则 Aryan 获胜，因为其中存在一个所有元素都为 $1$ 的 $2\times 2$ 子矩阵，如下所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2120D/ff9ee31dfc04aa73a7daca458dede1d4462758ef.png)

Aryan 给你 $a$、$b$ 和 $k$ 的值。他让你帮他找到字典序最小的二元组 $(n, m)$，使得无论 Harshith 如何选择矩阵 $X$，Aryan 都能获胜。请帮助 Aryan 赢得游戏。假设 Harshith 总是最优地选择矩阵。$n$ 和 $m$ 的值可能很大，请输出它们对 $10^9+7$ 取模后的结果。

一个二元组 $(n_1, m_1)$ 被认为比 $(n_2, m_2)$ 字典序更小，当且仅当 $n_1 < n_2$，或者 $n_1 = n_2$ 且 $m_1 < m_2$。

$^*$ 矩阵的子矩阵是通过从原矩阵中去除若干行和/或列得到的。

## 说明/提示

对于第一个测试用例，任意 $n\times m$ 的矩阵都包含一个 $1\times 1$ 的所有元素相等的子矩阵。$(1,1)$ 是所有可能二元组中字典序最小的。

对于第二个测试用例，可以验证，无论 Harshith 如何选择 $3\times 7$ 的矩阵，Aryan 总能找到一个 $2\times 2$ 的所有元素相等的子矩阵。$(3,7)$ 也是所有可能二元组中字典序最小的。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
1 1 5
2 2 2
90000 80000 70000```

### 输出

```
1 1
3 7
299929959 603196135```

# AI分析结果


### 题目分析报告

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：组合数学与鸽巢原理应用  
🗣️ **初步分析**：  
> 本题本质是寻找最小矩阵尺寸 $(n, m)$，使得任意 $n×m$ 矩阵都包含一个全等 $a×b$ 子矩阵。核心思想是**双重鸽巢原理**：  
> - **行数 $n$ 确定**：每列需保证至少一个数字出现 $a$ 次，故最小 $n = k(a-1)+1$（$k$ 种数字各占 $a-1$ 个位置后，下一位置必重复）。  
> - **列数 $m$ 确定**：每列有 $C(n,a) \cdot k$ 种「$a$ 个相同数字」的方案组合，需保证至少 $b$ 列方案相同，故最小 $m = C(n,a) \cdot k \cdot (b-1) + 1$。  
>  
> **可视化设计思路**：  
> - **像素风格**：8-bit 网格矩阵，不同颜色代表数字，高亮满足条件的子矩阵。  
> - **动态演示**：  
>   1. 列填充动画：每列数字均匀分布（避免出现 $a$ 个相同），填充至第 $k(a-1)+1$ 行时触发闪烁和音效，强制出现 $a$ 个同色块。  
>   2. 子矩阵形成：扫描多列，当 $b$ 列在相同位置出现同色块时，高亮边框并播放胜利音效。  
> - **交互控制**：步进/自动模式（调速滑块）、重置按钮；关键操作配像素音效（入队/成功/失败）。

---

#### 2. 精选优质题解参考
**题解一（_O_v_O_）**  
* **点评**：直接应用鸽巢原理，逻辑清晰；代码用逆元计算组合数，但未处理 $n$ 取模对组合数的影响；变量名简洁（`n, m`），边界处理严谨；提供通用公式推导，实践参考价值高。  
**亮点**：简洁推导 + 模块化逆元函数。

**题解二（w9095）**  
* **点评**：详细证明 $n, m$ 的最小性，深入解释方案数上界；预处理阶乘逆元优化组合数计算；代码规范（`jc[], inv[]`），但阶乘数组大小需扩展；严格处理负数取模。  
**亮点**：严谨数学证明 + 组合数优化计算。

**题解三（yitinboge_fan）**  
* **点评**：聚焦字典序最小化过程；代码极简（循环计算组合数），但误用取模后 $n$ 导致潜在错误；强调一列中数字的最优分布策略。  
**亮点**：问题拆解清晰 + 高效代码实现。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：最小行数 $n$ 的推导**  
   * **分析**：需保证每列至少一个数字出现 $a$ 次。Harshith 会均匀分布数字避免重复，鸽巢原理给出下界 $n = k(a-1)+1$。  
   * 💡 **学习笔记**：行数下界由数字种类 $k$ 和重复要求 $a$ 决定。

2. **难点2：最小列数 $m$ 的推导**  
   * **分析**：每列有 $C(n,a) \cdot k$ 种避免形成子矩阵的方案。$m$ 需保证至少 $b$ 列方案相同，故 $m = C(n,a) \cdot k \cdot (b-1) + 1$。  
   * 💡 **学习笔记**：列数下界由方案总数和列重复要求 $b$ 决定。

3. **难点3：大组合数取模计算**  
   * **分析**：$n$ 可达 $10^{10}$，$a \leq 10^5$，直接计算 $C(n,a)$ 需循环 $a$ 次并每一步取模：  
     $$C(n,a) \mod M = \prod_{i=0}^{a-1} (n-i) \cdot (\text{inv}(a!)) \mod M$$  
   * 💡 **学习笔记**：组合数分子需用原始 $n$（非取模值）逐步计算，分母用阶乘逆元优化。

**✨ 解题技巧总结**  
- **鸽巢双重应用**：先固定行重复，再固定列重复。  
- **组合数优化**：预计算阶乘逆元或循环乘逆元。  
- **边界处理**：检查 $a=1$ 或 $b=1$ 的特殊情况。  

---

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD = 1e9+7;

ll qpow(ll base, ll exp) { // 快速幂
    ll res = 1;
    while (exp) {
        if (exp & 1) res = res * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return res;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll a, b, k; cin >> a >> b >> k;
        ll n = k * (a-1) + 1;  // 最小行数
        ll comb = 1;
        // 计算 C(n, a) 分子部分（逐步乘+取模）
        for (int i = 0; i < a; i++) 
            comb = comb * (n - i) % MOD;
        // 除以 a! 的逆元
        ll fact = 1;
        for (int i = 1; i <= a; i++) 
            fact = fact * i % MOD;
        comb = comb * qpow(fact, MOD-2) % MOD;
        // 最小列数
        ll m = (k * comb % MOD) * (b-1) % MOD + 1;
        cout << n % MOD << ' ' << m % MOD << '\n';
    }
}
```
**代码解读概要**：  
1. 计算最小行数 `n = k*(a-1)+1`  
2. 组合数 $C(n,a)$ 通过分子连乘和分母逆元计算  
3. 最小列数 `m = k*C(n,a)*(b-1) + 1`  
4. 全程取模避免溢出  

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit 鸽巢矩阵冒险  
**核心流程**：  
1. **初始化**：  
   - 网格矩阵（行 $n$，列 $m$），控制面板（步进/自动/重置）。  
   - 每列独立填充，数字 $1$ 至 $k$ 用不同颜色像素块表示。  
2. **行填充动画**：  
   - 列填充至 $k(a-1)$ 行：数字均匀分布（无重复 $a$ 次）。  
   - 第 $k(a-1)+1$ 行：强制出现 $a$ 个同色块，触发闪烁和「叮！」音效。  
3. **子矩阵扫描**：  
   - 自动模式：AI 扫描各列，记录相同位置同色块。  
   - 发现 $b$ 列满足条件：高亮 $a×b$ 子矩阵边框，播放胜利音效 + 像素烟花特效。  
**技术细节**：  
- **Canvas 绘制**：网格动态生成，同色块用相同 RGB 值填充。  
- **音效触发**：Web Audio API 播放 8-bit 音效（关键操作/成功/失败）。  
- **游戏化**：每列填充为「小关卡」，完成得像素星星奖励。  

---

#### 6. 拓展练习与相似问题思考
1. **鸽巢原理扩展应用**：  
   - 生日悖论（最小人群生日重复概率）  
   - 文件哈希冲突分析  
   - 网络数据传输的冗余校验  
2. **洛谷习题推荐**：  
   - P1102 A-B 数对（鸽巢原理基础）  
   - P2218 [HAOI2007] 覆盖问题（二维鸽巢应用）  
   - P4137 Rmq Problem（区间 mex 问题）  

---

#### 7. 学习心得与经验分享
> 作者 w9095 强调：**「预处理阶乘逆元可显著优化组合数计算」**  
> Kay 点评：预处理是处理大组合数的关键技巧，尤其适用于多组查询。调试时需验证 $n < a$ 时组合数为 $0$ 的边界情况。

---

### 总结
本题通过双重鸽巢原理和组合数学，解决了最小矩阵尺寸问题。关键点在于：  
1. 行数 $n$ 由单列数字重复限制确定  
2. 列数 $m$ 由多列方案重复限制确定  
3. 组合数计算需处理大数取模和优化  
可视化方案将抽象原理转化为直观像素冒险，助力理解算法本质。

---
处理用时：292.34秒
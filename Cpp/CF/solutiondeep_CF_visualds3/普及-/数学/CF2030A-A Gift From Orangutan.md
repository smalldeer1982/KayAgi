# 题目信息

# A Gift From Orangutan

## 题目描述

在丛林探险的时候，你遇到了一只罕见的戴着领结的猩猩！你和猩猩握了握手并给了它一些食物和水。作为回报……

猩猩给了你一个长度为 $n$ 的数组 $a$。通过数组 $a$ 你将会以下列的方式构造两个长度都为 $n$ 的数组 $b$ 和 $c$：

* $b_i = \text{min}(a_1,a_2,…,a_i),1 \le i \le n$。  
* $c_i = \text{max}(a_1,a_2,…,a_i),1 \le i \le n$。

定义 $a$ 的得分为 $\sum^n_{i=1} c_i-b_i$。在你计算分数之前，你可以任意修改 $a$ 中元素的顺序。

你需要求出可以获得的最高得分。

## 说明/提示

对于第一组数据，没有其他方法来重新排列 $a$，所以，$b=[69]$ 并且 $c=[69]$。唯一可能的得分为 $69-69=0$。

对于第二组数据，可以将 $a$ 重新排列为 $[7,5,6]$。这样，$b=[7,5,5]$ 并且 $c=[7,7,7]$。这种情况下的得分为 $(7-7)+(7-5)+(7-5)=4$。可以证明，这是可能的最高分数。

翻译来自 [Jason_Ming](https://www.luogu.com.cn/user/1014421)。

## 样例 #1

### 输入

```
3
1
69
3
7 6 5
5
1 1 1 2 2```

### 输出

```
0
4
4```

# AI分析结果


### Kay的C++算法解析：A Gift From Orangutan 深入学习指南 💡

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`贪心算法`与`数学推导`  
🗣️ **初步分析**：  
> 解决这道题的关键在于发现**极值对得分的决定性作用**。想象你在玩一个搭积木游戏：每次新增积木时，记录当前最高塔（最大值）和最低塔（最小值）的高度差。最优策略是**尽早让最高和最低积木亮相**，使后续所有位置都能贡献最大高度差。  
> - 核心思路：通过数学推导发现，最优排列下得分恒为`(n-1)×(max-min)`，与中间值无关  
> - 可视化设计：用像素塔楼动态展示极值固定过程（最大值用红色塔，最小值用蓝色塔），新增积木时触发"叮"音效，高度差区域用金色闪烁  

---

#### 2. 精选优质题解参考  
**题解：Kay的极值定理推导法**  
* **点评**：  
  直接揭示问题本质——得分仅取决于极值和序列长度。代码极致简洁（仅需排序和一次乘法），时间复杂度O(n log n)来自排序，空间复杂度O(1)。边界处理完善（单独处理n=1），变量命名清晰(`max_val`/`min_val`)，实践价值满分。  

---

#### 3. 核心难点辨析与解题策略  
1.  **关键点1：识破得分的数学本质**  
    * **分析**：多数初学者会陷入排列组合的误区。实际上通过拆解公式：  
      `总得分 = ∑(前缀最大值) - ∑(前缀最小值)`  
      发现当极值在第二位置固定后，后续所有前缀极值不变
    * 💡 **学习笔记**：复杂问题常存在隐藏的数学简化规律  

2.  **关键点2：构造极值早现策略**  
    * **分析**：最优排列只需保证前两位含全局极值（如`[最大值, 最小值, ...]`），后续值可任意安排。用`std::sort`预处理即可获得极值
    * 💡 **学习笔记**：贪心算法的核心是识别"牵一发而动全身"的关键元素  

3.  **关键点3：处理重复极值**  
    * **分析**：当存在多个相同最大值/最小值时（如样例3），公式`(n-1)×(max-min)`依然成立，因为相同值不影响高度差计算
    * 💡 **学习笔记**：极值重复时贪心策略依然稳健  

### ✨ 解题技巧总结  
- **技巧1 问题降维**：将动态前缀问题转化为静态极值计算  
- **技巧2 边界防御**：单独处理`n=1`的特殊情况  
- **技巧3 极值分离**：用`std::sort`或遍历一次同时记录max/min  

---

#### 4. C++核心代码实现赏析  
**通用核心实现**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<long long> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        
        if (n == 1) {
            cout << "0\n";
        } else {
            sort(a.begin(), a.end());
            cout << (n - 1) * (a[n-1] - a[0]) << "\n";
        }
    }
    return 0;
}
```
**代码解读概要**：  
> 1. 读入测试用例数`T`  
> 2. 对每组数据：  
>    - 通过排序锁定极值`a[0]`(min)和`a[n-1]`(max)  
>    - 直接应用公式`(n-1)×(max-min)`输出结果  
> 3. 特判`n=1`时得分为0  

---

#### 5. 算法可视化：像素塔楼建造  
* **主题**：`像素积木大师`（复古工坊风格）  
* **核心演示**：  
  ![PixelAnimation](https://via.placeholder.com/400x200/000000/FFFFFF?text=动态演示图占位)  
  **动画流程**：  
  1. **初始化**：8-bit风格工坊背景，待搭建积木排序显示  
  2. **首块放置**：  
     - 红塔（最大值）落地，音效🔊"咚！"  
     - 信息板显示：`当前得分=0`  
  3. **次块放置**：  
     - 蓝塔（最小值）落地，音效🔊"叮！"  
     - 金色闪光覆盖两塔，显示：`+${max-min}分`  
  4. **后续放置**：  
     - 黄/绿积木随机落下，但红蓝塔保持不动  
     - 每新增积木，信息板金色闪烁：`+${max-min}分`  
  5. **结果展示**：  
     - 最后块放置时，所有塔楼绽放烟花  
     - 总分公式`(n-1)×(max-min)`以像素字体弹出  

---

#### 6. 拓展练习  
1. **洛谷 P1090** [合并果子]  
   → 巩固贪心策略+优先队列应用  
2. **洛谷 P1223** [排队接水]  
   → 贪心策略中的时序问题变形  
3. **洛谷 P1803** [凌乱的yyy]  
   → 贪心算法在区间调度中的经典应用  

---

< conclusion >  
通过极值定理的巧妙运用，这道题展现了贪心算法化繁为简的魅力。记住：当遇到前缀累积问题时，尝试寻找"早现关键元素"的突破口！下次见啦，小码农们~ ✨  
< /conclusion >

---
处理用时：241.70秒
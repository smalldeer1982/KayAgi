# 题目信息

# Prime Square

## 题目描述

Sasha likes investigating different math objects, for example, magic squares. But Sasha understands that magic squares have already been studied by hundreds of people, so he sees no sense of studying them further. Instead, he invented his own type of square — a prime square.

A square of size $ n \times n $ is called prime if the following three conditions are held simultaneously:

- all numbers on the square are non-negative integers not exceeding $ 10^5 $ ;
- there are no prime numbers in the square;
- sums of integers in each row and each column are prime numbers.

Sasha has an integer $ n $ . He asks you to find any prime square of size $ n \times n $ . Sasha is absolutely sure such squares exist, so just help him!

## 样例 #1

### 输入

```
2
4
2```

### 输出

```
4 6 8 1
4 9 9 9
4 10 10 65
1 4 4 4
1 1
1 1```

# AI分析结果

# 💡 Kay的C++算法解析：Prime Square 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（构造题）  

🗣️ **初步分析**：  
解决“Prime Square”的关键是**构造一个满足特定条件的矩阵**——就像搭积木一样，我们需要用“非质数”的“积木块”（如0、1），按照某种规则摆放，让每行每列的“积木总和”变成质数。  

- **核心思路**：  
  题解的共同特点是**用非质数组合出质数和**。比如：  
  - 45dino的方法：每行每列放2个1（非质数），其余放0（非质数），总和为2（质数）；  
  - tuzhewen的方法：先全放1（非质数），再修改对角线元素，让总和变成大于n的质数。  
- **核心难点**：  
  ① 如何保证所有元素都是非质数？② 如何让每行每列的和是质数？③ 如何处理不同大小的n（奇偶）？  
- **可视化设计思路**：  
  用8位像素风展示矩阵，1用红色块、0用蓝色块，每行每列的和用绿色数字显示在旁边。当填充1时，红色块“弹出”，和随之增加；当和为质数时，播放“叮”的像素音效，强化记忆。  


## 2. 精选优质题解参考

### 题解一（作者：45dino，赞8）  
* **点评**：  
  这道题解的思路**像“画对角线”一样简单直接**！作者用0和1填充矩阵，每行每列恰好有2个1（比如第i行的第i列和第i+1列，循环往复）。这样一来，每行每列的和都是2（质数），而且0和1都不是质数，完美满足所有条件。代码非常简洁，只用了两层循环，适合初学者快速理解构造题的核心逻辑。  


### 题解二（作者：tuzhewen，赞6）  
* **点评**：  
  这道题解的思路**更灵活**，适合处理更复杂的情况。作者先把整个矩阵填成1（非质数），此时每行每列的和是n。如果n是质数，直接输出；如果n是合数，就找一个大于n的质数sum，把对角线元素改成sum-n+1（这样每行每列的和变成sum）。关键是要确保sum-n+1不是质数——作者用筛法预处理了质数，然后循环找符合条件的sum。这种方法能处理所有n的情况，是构造题中“先填基础值，再调整”的典型案例。  


## 3. 核心难点辨析与解题策略

### 1. 如何保证元素都是非质数？  
* **分析**：  
  非质数包括0、1、4、6、8、9等。题解中常用**0和1**，因为它们最简单，而且不会超过1e5的限制。比如45dino用0和1，tuzhewen用1和sum-n+1（需要判断是否为非质数）。  
* 💡 **学习笔记**：选简单的非质数（如0、1）能减少判断成本，是构造题的常用技巧。  


### 2. 如何让每行每列的和是质数？  
* **分析**：  
  方法有两种：① 固定和为小质数（如2），用固定数量的1（比如2个1）；② 找大于n的质数sum，调整元素使得和为sum。比如45dino用方法①，tuzhewen用方法②。  
* 💡 **学习笔记**：固定小质数（如2）是最省心的方式，适合入门；找sum的方法更灵活，适合进阶。  


### 3. 如何处理不同大小的n？  
* **分析**：  
  45dino的方法适用于所有n，因为每行每列的1的数量是固定的（2个）；tuzhewen的方法通过修改对角线元素，不管n是奇数还是偶数，都能调整和为sum。  
* 💡 **学习笔记**：构造题的解法要尽量“通用”，避免针对不同n写不同的逻辑。  


### ✨ 解题技巧总结  
- **技巧1：用简单元素构造**：优先选0、1等简单非质数，减少判断成本；  
- **技巧2：固定和为小质数**：比如2，容易满足条件；  
- **技巧3：先填基础值再调整**：比如先填1，再修改部分元素，适合处理复杂情况。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（基于45dino的思路）  
* **说明**：这是构造题中最简洁的实现，适用于所有n，思路清晰。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  using namespace std;

  int main() {
      int t, n;
      cin >> t;
      while (t--) {
          cin >> n;
          for (int i = 1; i <= n; ++i) {
              for (int j = 1; j <= n; ++j) {
                  // 每行每列放2个1：第i列和第i+1列（循环）
                  if (j == i || j == i % n + 1) {
                      cout << "1 ";
                  } else {
                      cout << "0 ";
                  }
              }
              cout << endl;
          }
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  外层循环处理多组测试用例，内层循环填充每行。对于第i行，第i列和第i+1列（模n循环）放1，其余放0。这样每行每列恰好有2个1，和为2（质数）。  


### 题解一（45dino）核心代码片段赏析  
* **亮点**：用循环条件快速定位1的位置，代码简洁。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= n; ++j) {
          if (j == i || j == i % n + 1) {
              cout << "1 ";
          } else {
              cout << "0 ";
          }
      }
      cout << endl;
  }
  ```  
* **代码解读**：  
  比如n=3时，第1行的1在第1列和第2列，第2行的1在第2列和第3列，第3行的1在第3列和第1列（因为i%n+1=3%3+1=1）。这样每行每列都有2个1，和为2。  
* 💡 **学习笔记**：循环条件中的`i%n+1`是关键，它实现了“循环”放置1的效果。  


### 题解二（tuzhewen）核心代码片段赏析  
* **亮点**：用筛法预处理质数，灵活调整对角线元素。  
* **核心代码片段**：  
  ```cpp
  // 筛法预处理质数
  void shai() {
      for (int i = 2; i <= 100000; ++i) isp[i] = 1;
      for (int i = 2; i <= 100000; ++i) {
          if (isp[i]) prime[++cnt] = i;
          for (int j = 1; j <= cnt; ++j) {
              if (i * (long long)prime[j] > 100000) break;
              isp[i * prime[j]] = 0;
          }
      }
  }

  // 找符合条件的sum
  do {
      int pos = upper_bound(prime + 1, prime + 1 + cnt, sum) - prime;
      sum = prime[pos];
  } while (isp[sum - n + 1]);
  ```  
* **代码解读**：  
  筛法预处理了1到1e5的质数，然后找大于当前sum（初始为n）的质数，直到sum-n+1不是质数。这样修改对角线元素后，每行每列的和是sum（质数），而sum-n+1是非质数。  
* 💡 **学习笔记**：筛法是处理质数问题的常用工具，upper_bound能快速找到大于某个值的质数。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素积木搭矩阵  
**风格**：8位像素风（类似FC游戏），用红色块（1）、蓝色块（0）、绿色数字（和）。  
**核心演示内容**：展示45dino的构造过程，逐行填充1，实时显示每行每列的和。  


### 动画帧步骤与交互关键点  
1. **初始化**：屏幕显示n×n的蓝色网格（0），下方有“开始”“单步”“重置”按钮，右侧显示每行每列的和（初始为0）。  
2. **逐行填充**：  
   - 点击“单步”，第1行的第1列和第2列变成红色（1），右侧第1行的和变成2（绿色），第1列和第2列的和也变成2；  
   - 再点击“单步”，第2行的第2列和第3列变成红色，第2行的和变成2，第2列和第3列的和变成2；  
   - 直到所有行填充完毕，所有行和列的和都是2（绿色）。  
3. **音效与反馈**：  
   - 填充红色块时，播放“咔嗒”的像素音效；  
   - 当某行或某列的和变成2（质数）时，播放“叮”的音效，绿色数字闪烁。  
4. **自动播放**：点击“开始”，动画自动逐行填充，速度可通过滑块调整。  


### 设计思路  
- **像素风格**：复古的8位风格能让学习者感到亲切，减少对算法的距离感；  
- **颜色标记**：红色（1）、蓝色（0）、绿色（和）清晰区分元素类型，便于观察；  
- **音效反馈**：关键操作（填充1、和为质数）的音效能强化记忆，让学习更有趣。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
构造题的核心是**找到固定模式**，本题的技巧可以迁移到以下场景：  
- 构造幻方（每行每列和相等）；  
- 构造矩阵满足特定元素条件（如全为偶数）；  
- 构造字符串满足特定规则（如回文）。  


### 练习推荐 (洛谷)  
1. **洛谷 P1002** - 过河卒  
   🗣️ **推荐理由**：这道题需要构造一个路径矩阵，练习“先填基础值再调整”的思路。  
2. **洛谷 P1003** - 铺地毯  
   🗣️ **推荐理由**：这道题需要构造一个地毯覆盖的矩阵，练习“标记特定位置”的技巧。  
3. **洛谷 P1004** - 方格取数  
   🗣️ **推荐理由**：这道题需要构造一个取数路径，练习“动态规划+构造”的结合。  


## 7. 学习心得与经验分享 (若有)  
- **45dino的心得**：“用0和1构造是最省心的，因为它们不会超过限制，而且和容易控制。”  
  **点评**：这提醒我们，构造题要优先选简单的元素，减少不必要的判断。  
- **tuzhewen的心得**：“筛法预处理质数能快速找到符合条件的sum，避免重复计算。”  
  **点评**：预处理是处理大数据的常用技巧，能提高代码效率。  


## 结语  
本次关于“Prime Square”的分析就到这里！构造题的关键是**找模式**，只要掌握了用简单元素组合的技巧，就能轻松解决这类问题。记住，编程就像搭积木，多尝试、多思考，你一定能搭出属于自己的“完美矩阵”！💪

---
处理用时：133.86秒
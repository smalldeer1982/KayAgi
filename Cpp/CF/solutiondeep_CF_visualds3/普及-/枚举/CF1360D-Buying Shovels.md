# 题目信息

# Buying Shovels

## 题目描述

Polycarp wants to buy exactly $ n $ shovels. The shop sells packages with shovels. The store has $ k $ types of packages: the package of the $ i $ -th type consists of exactly $ i $ shovels ( $ 1 \le i \le k $ ). The store has an infinite number of packages of each type.

Polycarp wants to choose one type of packages and then buy several (one or more) packages of this type. What is the smallest number of packages Polycarp will have to buy to get exactly $ n $ shovels?

For example, if $ n=8 $ and $ k=7 $ , then Polycarp will buy $ 2 $ packages of $ 4 $ shovels.

Help Polycarp find the minimum number of packages that he needs to buy, given that he:

- will buy exactly $ n $ shovels in total;
- the sizes of all packages he will buy are all the same and the number of shovels in each package is an integer from $ 1 $ to $ k $ , inclusive.

## 说明/提示

The answer to the first test case was explained in the statement.

In the second test case, there is only one way to buy $ 8 $ shovels — $ 8 $ packages of one shovel.

In the third test case, you need to buy a $ 1 $ package of $ 6 $ shovels.

## 样例 #1

### 输入

```
5
8 7
8 1
6 10
999999733 999999732
999999733 999999733```

### 输出

```
2
8
1
999999733
1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Buying Shovels 深入学习指南 💡

<introduction>
今天我们来一起分析“Buying Shovels”这道C++编程题。这道题看似简单，却需要巧妙运用数学中的因数性质。本指南将帮助大家梳理题目思路，理解核心算法，并掌握高效解题的技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（因数枚举）`

🗣️ **初步分析**：
> 解决“Buying Shovels”的关键在于找到1到k之间n的最大因数。简单来说，因数就像拼图的“配对块”——如果i是n的因数，那么n/i也是n的因数（比如n=8，i=2时，n/i=4也是因数）。在本题中，我们需要找到这样的“配对块”中最大的那个（≤k），这样购买次数（n/因数）才会最小。
   - **题解思路**：所有优质题解都围绕“枚举n的因数”展开，通过枚举到√n（因数的“中点”），同时检查i和n/i是否≤k，从而高效找到最小购买次数。
   - **核心难点**：如何避免暴力枚举1到k（时间复杂度O(k)），转而利用因数的成对性将时间复杂度降至O(√n)；如何处理边界条件（如k≥n时直接返回1）。
   - **可视化设计**：我们将设计一个8位像素风动画，用“因数探险家”在数字网格中寻找配对块的过程演示算法。每找到一个有效因数（i或n/i≤k），对应像素块会高亮并播放“叮”的音效；最终找到最大因数时，播放胜利音效并展示购买次数。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的思路清晰度、代码规范性、算法有效性等维度的评估，以下3道题解因逻辑简洁、实现高效且易于学习，被选为优质参考：
</eval_intro>

**题解一：作者：丧黑福造 (赞：8)**
* **点评**：此题解思路非常清晰，直接抓住“因数成对性”这一核心，通过枚举到√n高效找到所有可能的因数。代码变量命名直观（如ans表示最小购买次数），边界处理严谨（初始化为0x7fffffff），时间复杂度O(√n)完全满足题目要求。实践中，这段代码可直接用于竞赛，是新手学习的典范。

**题解二：作者：andyli (赞：4)**
* **点评**：此题解提供了两种实现方式，其中第二种利用`upper_bound`在排序后的因数列表中快速查找，虽然稍复杂，但展示了对标准库的灵活运用。代码结构工整，适合有一定基础的学习者拓展思路。

**题解三：作者：_GW_ (赞：2)**
* **点评**：此题解通过vector存储所有因数，排序后逆序查找最大符合条件的因数，逻辑直白易懂。虽然多了一步排序，但对因数数量较少的场景（如n为质数）仍保持高效，适合理解因数枚举的完整流程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下3个关键点。结合优质题解的共性，我们提炼了对应的解决策略：
</difficulty_intro>

1.  **关键点1：如何高效枚举n的因数？**
    * **分析**：直接枚举1到k会超时（k可能到1e9）。优质题解利用因数的“成对性”——若i是n的因数，则n/i也是因数。因此只需枚举到√n（i的最大可能值为√n），即可覆盖所有因数。
    * 💡 **学习笔记**：枚举到√n是因数问题的经典优化，时间复杂度从O(n)降至O(√n)。

2.  **关键点2：如何处理因数的“配对”？**
    * **分析**：对于每个i（i≤√n），需同时检查i和n/i是否≤k。例如，n=8，i=2时，n/i=4。若k≥4，则4是更优的因数（购买次数8/4=2）；若k<4但≥2，则i=2是次优选择（购买次数8/2=4）。
    * 💡 **学习笔记**：每枚举一个i，需处理两个可能的因数，避免遗漏。

3.  **关键点3：如何处理边界条件？**
    * **分析**：当k≥n时，n本身就是因数（i=n≤k），此时购买次数为1（n/n=1）。优质题解通常会先判断此情况，直接返回1，避免不必要的枚举。
    * 💡 **学习笔记**：边界条件（如k≥n）需优先处理，简化后续逻辑。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将“最少购买次数”问题转化为“寻找最大有效因数”，抓住问题本质。
- **因数配对枚举**：利用i和n/i的成对性，仅枚举到√n，大幅降低时间复杂度。
- **边界优先处理**：先判断k≥n的情况，直接返回1，减少计算量。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合了优质题解思路的通用核心实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“丧黑福造”和“_GW_”的题解思路，采用最简洁的枚举方式，适用于所有测试用例。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <climits> // 用于INT_MAX
    using namespace std;

    int main() {
        int t;
        cin >> t;
        while (t--) {
            int n, k;
            cin >> n >> k;
            int ans = INT_MAX; // 初始化为最大整数，表示未找到
            // 枚举到sqrt(n)即可覆盖所有因数对
            for (int i = 1; i * i <= n; ++i) {
                if (n % i == 0) { // i是n的因数
                    // 情况1：i作为因数，检查是否≤k
                    if (i <= k) ans = min(ans, n / i);
                    // 情况2：n/i作为因数，检查是否≤k
                    if (n / i <= k) ans = min(ans, i);
                }
            }
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取测试用例数t，然后对每个用例读取n和k。通过枚举i从1到√n，检查i是否为n的因数。对于每个因数i，分别判断i和n/i是否≤k，并更新最小购买次数ans。最终输出ans。

---
<code_intro_selected>
接下来，我们剖析3个优质题解的核心代码片段，理解其独特亮点。
</code_intro_selected>

**题解一：作者：丧黑福造**
* **亮点**：代码简洁，直接通过循环枚举因数，变量初始化和边界处理严谨。
* **核心代码片段**：
    ```cpp
    int ans = 0x7fffffff;
    for (register int i = 1; i * i <= n; i ++) {
        if (n % i == 0) {
            if (i <= k) ans = min(ans, n / i);
            if (n / i <= k) ans = min(ans, i);
        }
    }
    ```
* **代码解读**：
    > `ans`初始化为0x7fffffff（最大int值），确保第一次找到的有效值能正确更新。循环条件`i * i <= n`避免使用sqrt函数，提高效率。对于每个i，若i是因数，同时检查i和n/i是否≤k，用`min`更新ans。这一步是算法核心，确保找到最小的购买次数。
* 💡 **学习笔记**：用`i * i <= n`代替`i <= sqrt(n)`可避免浮点数精度问题，更可靠。

**题解二：作者：andyli（第二种实现）**
* **亮点**：利用`upper_bound`在排序后的因数列表中快速查找，展示了对标准库的灵活运用。
* **核心代码片段**：
    ```cpp
    vector<int> v;
    for (int i = 1; i * i < n; i++)
        if (n % i == 0) v.push_back(i);
    for (int i = sqrt(n); i >= 1; i--)
        if (n % i == 0) v.push_back(n / i);
    writeln(n / *--std::upper_bound(v.begin(), v.end(), k));
    ```
* **代码解读**：
    > 首先收集所有因数到vector中（i从1到√n-1），然后逆序添加n/i（避免重复）。排序后，用`upper_bound`找到第一个大于k的因数，其前一个即为最大的有效因数。最后输出n除以该因数。这种方法适合需要多次查询的场景。
* 💡 **学习笔记**：`upper_bound`是STL中高效查找的利器，适用于有序数据的快速定位。

**题解三：作者：_GW_**
* **亮点**：通过vector存储因数并排序，逆序查找最大有效因数，逻辑直观。
* **核心代码片段**：
    ```cpp
    vector<int> v;
    for(int i=1;i<=sqrt(n);i++) {
        if(n%i==0) {
            v.push_back(i);
            if(i*i!=n) v.push_back(n/i);
        }
    }
    sort(v.begin(),v.end());
    for(int i=v.size()-1;i>=0;i--) {
        if(v[i]<=m) {
            cout<<n/v[i]<<endl;
            return;
        }
    }
    ```
* **代码解读**：
    > 先收集所有因数到vector（避免i=√n时重复添加），排序后逆序遍历，找到第一个≤k的因数（即最大有效因数），输出n除以该因数。这种方法适合理解因数的完整收集和排序过程。
* 💡 **学习笔记**：逆序遍历有序列表可快速找到最大符合条件的元素，简化逻辑。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“因数枚举”的过程，我们设计了一个名为“因数探险家”的8位像素动画。通过像素方块的移动和高亮，你可以“看到”算法如何找到最大有效因数！
</visualization_intro>

  * **动画演示主题**：`“因数探险家”在数字网格中寻找宝藏`

  * **核心演示内容**：模拟枚举i从1到√n，检查i和n/i是否≤k，最终找到最大有效因数的过程。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色的像素块表示n的因数（如i为蓝色，n/i为绿色），关键操作（如找到有效因数）伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示一个像素网格（1到√n的数字块），右侧显示对应的n/i值（如i=2时，右侧显示4）。
          * 控制面板包含“开始/暂停”、“单步”、“重置”按钮和速度滑块（0.5x-2x）。
          * 播放8位风格的轻快背景音乐（如《超级马里奥》的经典旋律）。

    2.  **算法启动**：
          * 探险家（一个像素小人）从i=1的位置出发，头顶显示当前i值（如“i=1”）。
          * 检查i是否为n的因数：若n%i==0，i的像素块变为黄色（表示是因数），右侧n/i的像素块同步变为黄色。

    3.  **核心步骤演示**：
          * **检查i≤k**：若i≤k，i的像素块变为绿色（有效因数），播放“叮”音效，屏幕显示“i有效！购买次数：n/i”。
          * **检查n/i≤k**：若n/i≤k，n/i的像素块变为绿色，播放“叮”音效，屏幕显示“n/i有效！购买次数：i”。
          * 探险家移动到下一个i（i++），重复上述步骤，直到i*i>n。

    4.  **目标达成**：
          * 所有i枚举完成后，绿色像素块中最大的那个（即最大有效因数）会闪烁，播放胜利音效（如《超级玛丽》的“吃金币”音）。
          * 屏幕中央显示最终购买次数（n/最大有效因数），并弹出“成功找到！”的文字提示。

    5.  **交互控制**：
          * 单步模式：点击“单步”按钮，探险家每次移动一格，适合仔细观察每一步。
          * 自动模式：点击“开始”，探险家自动遍历所有i，速度可通过滑块调整。
          * 重置模式：点击“重置”，清空所有高亮，探险家回到起点，重新开始。

  * **旁白提示**：
      * （i=1时）“现在检查i=1，1是任何数的因数！如果k≥1，购买次数是n/1=n次。”
      * （i=2，n=8时）“i=2是8的因数，n/i=4。如果k≥4，购买次数是2次（更优哦！）。”
      * （找到最大有效因数时）“看！这个绿色块就是最大的有效因数，购买次数最少！”

<visualization_conclusion>
通过这个像素动画，你不仅能直观看到因数枚举的每一步，还能在游戏化的互动中深刻理解“因数配对”和“最小购买次数”的关系。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“因数枚举”的核心技巧后，我们可以将其应用到更多数学类问题中。以下是一些拓展练习和相似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 因数枚举不仅适用于本题，还常用于：
        1. **质因数分解**（如求n的质因数个数）。
        2. **最大公约数（GCD）计算**（通过枚举公共因数）。
        3. **完全数判断**（如6的因数和等于自身）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1075** - `质因数分解`
          * 🗣️ **推荐理由**：这道题需要枚举因数并判断质数，能巩固“因数枚举”和“质数判断”的综合应用。
    2.  **洛谷 P1403** - `约数研究`
          * 🗣️ **推荐理由**：计算1到n每个数的约数个数之和，需要高效枚举因数，适合拓展因数统计的思路。
    3.  **洛谷 P2615** - `神奇的幻方`
          * 🗣️ **推荐理由**：虽然是幻方问题，但构造过程中需要理解数的排列规律，培养数学敏感度。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试时的经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自 丧黑福造)**：“刚开始我忘记初始化ans为很大的值，导致小数据正确但大数据出错。后来通过打印中间变量发现了问题，这让我意识到初始化的重要性。”

> **点评**：这位作者的经验提醒我们，在编程中变量初始化是关键步骤（尤其是最小值/最大值问题）。通过打印中间变量（如ans的当前值）可以快速定位错误，这是非常实用的调试技巧。

-----

<conclusion>
本次关于“Buying Shovels”的C++解题分析就到这里。希望这份指南能帮助你理解因数枚举的核心思想，并掌握高效解题的技巧。记住，遇到数学类问题时，先尝试抽象问题本质（如本题的“最大有效因数”），再利用数学性质（如因数成对性）优化算法。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：142.27秒
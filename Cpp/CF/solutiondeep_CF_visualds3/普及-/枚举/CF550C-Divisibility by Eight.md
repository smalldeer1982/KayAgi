# 题目信息

# Divisibility by Eight

## 题目描述

You are given a non-negative integer $ n $ , its decimal representation consists of at most $ 100 $ digits and doesn't contain leading zeroes.

Your task is to determine if it is possible in this case to remove some of the digits (possibly not remove any digit at all) so that the result contains at least one digit, forms a non-negative integer, doesn't have leading zeroes and is divisible by 8. After the removing, it is forbidden to rearrange the digits.

If a solution exists, you should print it.

## 样例 #1

### 输入

```
3454
```

### 输出

```
YES
344
```

## 样例 #2

### 输入

```
10
```

### 输出

```
YES
0
```

## 样例 #3

### 输入

```
111111
```

### 输出

```
NO
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Divisibility by Eight 深入学习指南 💡

<introduction>
今天我们来一起分析“Divisibility by Eight”这道C++编程题。这道题的关键在于利用被8整除的数学性质，通过枚举不同长度的子序列来解决问题。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（暴力搜索）与数学性质应用

🗣️ **初步分析**：
解决“Divisibility by Eight”这道题，关键在于理解被8整除的数的数学性质：一个数能被8整除，当且仅当它的最后三位能被8整除（若位数不足三位，则直接判断整个数）。简单来说，枚举就像“地毯式搜索”，我们需要检查原数字字符串中是否存在长度为1、2或3的子序列（保持顺序），其值能被8整除。

- **题解思路**：所有优质题解均采用暴力枚举策略，先特判是否存在0（直接输出0），再依次枚举1位（如8）、2位、3位的子序列，检查是否能被8整除。若存在则输出，否则输出NO。
- **核心难点**：确保枚举所有可能的子序列且不遗漏，同时正确处理前导零（如样例2中单独的0是合法的）。
- **可视化设计**：我们将设计一个8位像素风格的动画，用彩色像素方块表示数字字符串，通过高亮不同长度的子序列（1位、2位、3位）并动态检查是否能被8整除，配合“叮”的音效提示成功，“滴”的音效提示失败。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等方面评估，以下题解评分均≥4星：
</eval_intro>

**题解一：作者：灵光一闪**
* **点评**：此题解思路非常清晰，直接利用被8整除的数学性质，通过三重循环枚举所有可能的1位、2位、3位子序列。代码结构工整，变量命名直观（如`s[i]`表示第i位数字），边界处理严谨（如特判0的情况）。算法时间复杂度为O(n³)，在n≤100时完全可行，是竞赛中典型的“暴力但高效”解法。

**题解二：作者：FuriousC**
* **点评**：此题解与灵光一闪的思路一致，但代码更简洁。通过`str.find('0')`快速判断是否存在0，减少了冗余判断。三重循环逻辑直接，变量`a`、`b`、`c`分别表示子序列的各位数字，可读性强。特别值得学习的是其“提前返回”的优化（找到解后立即输出并终止程序），避免了不必要的计算。

**题解三：作者：Creator_157**
* **点评**：此题解结构清晰，注释明确，适合初学者理解。代码中先特判0和8，再依次枚举两位、三位子序列，逻辑层层递进。变量`i`、`j`、`l`的命名虽简单但含义明确，循环范围控制准确（如`j=i+1`确保顺序不变），是暴力枚举的典型实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们可能会遇到以下核心难点，结合优质题解的经验，一起看看如何突破：
</difficulty_intro>

1.  **关键点1：如何正确处理“0”的情况？**
    * **分析**：题目允许输出单独的0（如样例2），但需注意原数字中可能包含多个0。优质题解通常先检查是否存在0（`s.find('0') < s.size()`），若存在则直接输出0，避免后续冗余计算。
    * 💡 **学习笔记**：特判0是解题的“快速通道”，能大幅减少后续枚举的工作量。

2.  **关键点2：如何枚举所有可能的子序列？**
    * **分析**：子序列需保持原顺序，因此枚举时需保证索引递增（如三位子序列的索引`i < j < k`）。优质题解通过三重循环（i从0到n-1，j从i+1到n-1，k从j+1到n-1）覆盖所有可能的三位子序列，两位和一位同理。
    * 💡 **学习笔记**：索引递增是保证子序列顺序不变的关键，循环变量的范围需严格控制。

3.  **关键点3：如何避免前导零？**
    * **分析**：除了单独的0外，其他子序列不能以0开头（如“08”不合法）。优质题解通过先特判0，后续枚举时保证子序列的首位不为0（如三位子序列的`s[i]`若为0则不可能被选中，因为0已被特判）。
    * 💡 **学习笔记**：特判0后，后续枚举的子序列首位一定非0（否则0已被输出），无需额外处理前导零。

### ✨ 解题技巧总结
<summary_best_practices>
- **数学性质优先**：利用被8整除的数的性质（末三位决定整体），将问题简化为枚举1-3位的子序列。
- **特判加速**：先检查是否存在0或8，快速得到部分解，减少后续计算量。
- **循环有序**：枚举子序列时，通过索引递增保证顺序不变，避免重复或错误。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心C++实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了灵光一闪、FuriousC等题解的思路，采用暴力枚举1-3位子序列，特判0的情况，是本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        string s;
        cin >> s;
        // 特判0：存在0则直接输出0
        if (s.find('0') != string::npos) {
            cout << "YES\n0" << endl;
            return 0;
        }
        // 枚举1位：是否是8
        for (int i = 0; i < s.size(); ++i) {
            if ((s[i] - '0') % 8 == 0) {
                cout << "YES\n" << s[i] << endl;
                return 0;
            }
        }
        // 枚举2位
        for (int i = 0; i < s.size(); ++i) {
            for (int j = i + 1; j < s.size(); ++j) {
                int num = (s[i] - '0') * 10 + (s[j] - '0');
                if (num % 8 == 0) {
                    cout << "YES\n" << s[i] << s[j] << endl;
                    return 0;
                }
            }
        }
        // 枚举3位
        for (int i = 0; i < s.size(); ++i) {
            for (int j = i + 1; j < s.size(); ++j) {
                for (int k = j + 1; k < s.size(); ++k) {
                    int num = (s[i] - '0') * 100 + (s[j] - '0') * 10 + (s[k] - '0');
                    if (num % 8 == 0) {
                        cout << "YES\n" << s[i] << s[j] << s[k] << endl;
                        return 0;
                    }
                }
            }
        }
        // 无符合条件的子序列
        cout << "NO" << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先特判是否存在0（直接输出0），然后依次枚举1位（检查是否为8）、2位（两位数是否被8整除）、3位（三位数是否被8整除）的子序列。找到符合条件的子序列后立即输出并终止程序，否则输出NO。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的亮点和思路。
</code_intro_selected>

**题解一：作者：灵光一闪**
* **亮点**：代码结构清晰，通过嵌套循环覆盖所有可能的子序列，特判0的逻辑简洁高效。
* **核心代码片段**：
    ```cpp
    if(a<s.size()){
        puts("YES");
        puts("0");
        return 0;
    }
    for(int i=0;i<s.size();i++){
        for(int j=i+1;j<s.size();j++){
            for(int k=j+1;k<s.size();k++){
                if(((s[i]-'0')*100+(s[j]-'0')*10+(s[k]-'0'))%8==0){
                    puts("YES");
                    cout<<s[i]<<s[j]<<s[k]<<endl;
                    return 0;
                }
            }
            // 两位的判断...
        }
        // 一位的判断...
    }
    ```
* **代码解读**：这段代码首先检查是否存在0（`a<s.size()`），若存在则直接输出0。随后通过三重循环枚举三位子序列，计算其数值并检查是否被8整除。一旦找到符合条件的子序列，立即输出并终止程序，避免冗余计算。
* 💡 **学习笔记**：提前返回（`return 0`）是优化暴力枚举的重要技巧，能显著减少不必要的循环次数。

**题解二：作者：FuriousC**
* **亮点**：代码简洁，变量命名直观（如`a`、`b`、`c`分别表示子序列的各位数字），逻辑直接。
* **核心代码片段**：
    ```cpp
    for(int i=0;i<str.size();i++){
        a=str[i]-'0';
        for(int j=i+1;j<str.size();j++){
            int b=str[j]-'0';
            for(int k=j+1;k<str.size();k++){
                int c=str[k]-'0';
                if((a*100+b*10+c)%8==0){
                    cout<<"YES\n"<<a<<b<<c;
                    return 0;
                }
            }
            // 两位的判断...
        }
        // 一位的判断...
    }
    ```
* **代码解读**：这段代码通过三重循环枚举三位子序列，变量`a`、`b`、`c`分别表示子序列的百位、十位、个位数字。计算其数值后检查是否被8整除，逻辑清晰易懂。
* 💡 **学习笔记**：将字符转换为数字（`-'0'`）是处理数字字符串的基础操作，需熟练掌握。

**题解三：作者：Creator_157**
* **亮点**：注释明确，适合初学者理解，循环范围控制准确（如`j=i+1`保证顺序）。
* **核心代码片段**：
    ```cpp
    for(int i=0;i<s.size();i++){
        for(int j=i+1;j<s.size();j++){
            for(int l=j+1;l<s.size();l++){
                if(((s[i]-'0')*100+(s[j]-'0')*10+(s[l]-'0'))%8==0){
                    printf("YES\n");
                    cout<<s[i]<<s[j]<<s[l];
                    return 0;
                }
            }
            // 两位的判断...
        }
        // 一位的判断...
    }
    ```
* **代码解读**：这段代码通过三重循环枚举三位子序列，索引`i < j < l`保证了子序列的顺序不变。计算数值时使用`(s[i]-'0')*100 + ...`，正确转换为整数后检查是否被8整除。
* 💡 **学习笔记**：循环变量的范围（如`j=i+1`）是保证子序列顺序的关键，需仔细设置。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举过程，我们设计一个“像素数字探险家”动画，用8位像素风格展示如何搜索符合条件的子序列。
</visualization_intro>

  * **动画演示主题**：像素数字探险——寻找8的倍数宝藏

  * **核心演示内容**：动画将展示一个由像素方块组成的数字字符串（如“3454”），探险家（一个小像素人）依次检查1位、2位、3位的子序列，找到能被8整除的子序列时触发“宝藏”动画。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），通过颜色高亮当前检查的子序列，配合音效强化操作记忆。每找到一个符合条件的子序列，视为“找到宝藏”，增加学习成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕下方显示像素数字串（每个数字为一个彩色方块，如红色“3”、蓝色“4”等）。
          * 顶部显示控制面板：开始/暂停、单步、重置按钮，速度滑块（调节动画速度）。
          * 播放8位风格的轻快背景音乐。

    2.  **特判0**：
          * 探险家移动到数字串中第一个“0”的位置（若存在），该方块闪烁绿色，播放“叮”的音效，弹出文字“发现0，直接输出！”。

    3.  **枚举1位**：
          * 探险家依次检查每个数字方块，当前检查的方块变为黄色。若数字是8，方块变为绿色，播放“叮”的音效，弹出文字“找到8，成功！”。

    4.  **枚举2位**：
          * 探险家选择第一个数字（i），该方块变为黄色；然后选择第二个数字（j>i），j方块变为橙色。计算两位数的数值，若被8整除，两个方块同时变为绿色，播放“叮”的音效，弹出文字“两位数符合条件！”。

    5.  **枚举3位**：
          * 探险家选择i、j、k（i<j<k）三个方块，分别变为黄、橙、粉色。计算三位数的数值，若被8整除，三个方块同时变为绿色，播放“叮”的音效，弹出文字“三位数符合条件！”。

    6.  **目标达成**：
          * 找到符合条件的子序列时，播放上扬的“胜利”音效，所有相关方块闪烁星星动画。
          * 若未找到，播放短促“滴”的音效，弹出文字“未找到符合条件的子序列”。

  * **旁白提示**：
      * （特判0时）“注意！如果有0，直接输出0即可！”
      * （枚举1位时）“现在检查是否有数字8，它本身能被8整除！”
      * （枚举2位时）“两位数的组合，比如16、24，是否能被8整除？”
      * （枚举3位时）“三位数的组合，比如344，末三位决定了整个数是否能被8整除！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到枚举的每一步，理解如何通过检查1-3位的子序列解决问题，让抽象的枚举过程变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下题目，巩固枚举和数学性质的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 枚举不仅适用于被8整除的问题，还可用于寻找其他数的倍数（如被3、4、5整除）、子序列最值等问题。
      * 数学性质（如被n整除的数的特征）能大幅简化枚举范围，是解决大数问题的关键。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1100 高低位交换** - 位运算与枚举
          * 🗣️ **推荐理由**：这道题需要枚举位的位置并进行交换，能帮助你巩固枚举的应用。
    2.  **洛谷 P1042 乒乓球** - 模拟与枚举
          * 🗣️ **推荐理由**：通过枚举比赛的每一分，模拟得分过程，锻炼逻辑清晰的枚举能力。
    3.  **洛谷 P1059 明明的随机数** - 排序与枚举去重
          * 🗣️ **推荐理由**：需要枚举数组中的元素并去重，适合练习枚举与数据处理。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了特判0的重要性，这是解题的关键步骤。例如，作者“灵光一闪”提到：“只要有一个0存在，就可以直接输出0。”这提醒我们在解题时要优先考虑特殊情况，避免遗漏。
</insights_intro>

> **参考经验 (来自 灵光一闪)**：“首先：只要有一个0存在，cout<<YES<<endl<<"0"<<endl;”
>
> **点评**：特判0是本题的“快速通道”，能避免后续冗余的枚举。这提示我们在遇到类似问题时，要先观察是否有特殊情况（如0、1等），可能大幅简化问题。

-----

<conclusion>
本次关于“Divisibility by Eight”的C++解题分析就到这里。希望这份指南能帮助你理解枚举的应用和数学性质的重要性。记住，多动手编写代码、调试测试，是提升编程能力的关键！下次再见~ 💪
</conclusion>

-----

---
处理用时：146.78秒
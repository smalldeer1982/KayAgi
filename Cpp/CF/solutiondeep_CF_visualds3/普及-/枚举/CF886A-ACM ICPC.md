# 题目信息

# ACM ICPC

## 题目描述

In a small but very proud high school it was decided to win ACM ICPC. This goal requires to compose as many teams of three as possible, but since there were only $ 6 $ students who wished to participate, the decision was to build exactly two teams.

After practice competition, participant number $ i $ got a score of $ a_{i} $ . Team score is defined as sum of scores of its participants. High school management is interested if it's possible to build two teams with equal scores. Your task is to answer that question.

## 说明/提示

In the first sample, first team can be composed of $ 1 $ st, $ 2 $ nd and $ 6 $ th participant, second — of $ 3 $ rd, $ 4 $ th and $ 5 $ th: team scores are $ 1+3+1=2+1+2=5 $ .

In the second sample, score of participant number $ 6 $ is too high: his team score will be definitely greater.

## 样例 #1

### 输入

```
1 3 2 1 2 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
1 1 1 1 1 99
```

### 输出

```
NO
```

# AI分析结果



---
# 💡 Kay的C++算法解析：ACM ICPC 分组问题 深入学习指南 💡

<introduction>
今天我们来一起分析“ACM ICPC 分组问题”这道C++编程题。题目要求判断6个学生的分数能否分成两组，每组3人且总分相等。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举算法应用

🗣️ **初步分析**：
解决这道题的关键在于“枚举所有可能的3人组合”，判断是否存在两组不重叠的3人组，其总分相等。简单来说，枚举就像“逐个检查所有可能性”，比如你要在6本书中选3本，需要把所有可能的选法都列出来看看。本题中，枚举的核心是找到所有3人组合的总分，然后检查是否有两个组合的总分相等（且不重复使用学生）。

- **题解思路对比**：多个题解均采用枚举法，但实现方式不同：有的暴力生成所有排列（如Dog_Two），有的直接三重循环枚举不重复的3人组合（如chufuzhe、hello2020），还有的用DFS搜索（如AmaZingFantasy）。其中，三重循环枚举i<j<k的方式最高效（仅需20次循环），避免了重复计算。
- **核心算法流程**：先计算总分，若总分是奇数则直接输出NO（因为无法均分）；否则目标为总分的一半，枚举所有3人组合，检查是否存在和为目标的组合。
- **可视化设计思路**：用像素网格展示6个学生的分数，用不同颜色标记当前枚举的3人组（如红色方块），动态计算其和并与目标值（黄色数字）对比。关键步骤高亮（如找到符合条件的组合时，方块闪烁并播放“叮”的音效）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法效率等，我为大家筛选了以下优质题解：
</eval_intro>

**题解一：chufuzhe（赞：4）**
* **点评**：此题解思路非常清晰！首先计算总分，若为奇数直接排除；否则通过三重循环枚举所有不重复的3人组合（i<j<k），检查和是否为总分的一半。代码变量命名规范（如`ans`表示结果，`s`表示总和），循环结构简洁，避免了重复枚举，时间复杂度仅O(20)，非常高效。实践中可直接用于竞赛，边界处理（如i≠j≠k）严谨，是学习枚举法的优秀范例。

**题解二：hello2020（赞：2）**
* **点评**：此题解同样采用三重循环枚举i<j<k的3人组，代码极其简洁。通过限制循环范围（i≤4, j≤5, k≤6）确保不重复，直接检查和是否为目标值。虽然赞数较少，但逻辑直白，变量命名清晰（如`sum`表示总和），是暴力枚举的典型实现，适合初学者理解核心逻辑。

**题解三：Dog_Two（赞：3）**
* **点评**：此题解利用全排列（next_permutation）枚举所有可能的前3人组合，思路新颖但效率稍低（6! = 720次循环）。代码中先排序再排列，避免了完全重复的排列，且对总和为奇数的情况做了特判，体现了一定的优化意识。适合理解排列与枚举的关系，但实际竞赛中更推荐前两种高效方法。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们常遇到以下关键点，结合优质题解的经验，一起来拆解：
</difficulty_intro>

1.  **关键点1：如何避免重复枚举？**
    * **分析**：枚举3人组时，若不限制顺序（如i<j<k），会重复计算同一组合的不同排列（如选1、2、3和选2、1、3是同一组合）。优质题解（如chufuzhe、hello2020）通过设置i<j<k的循环条件，确保每个组合仅计算一次，大大减少了循环次数（从720次降至20次）。
    * 💡 **学习笔记**：枚举组合时，限制索引递增（i<j<k）是避免重复的关键技巧。

2.  **关键点2：如何处理总和为奇数的情况？**
    * **分析**：若总分是奇数，无法分成两个整数和的3人组（因为3个数的和必为整数）。优质题解（如chufuzhe、hello2020）首先判断`s%2==0`，直接排除这种情况，减少后续计算。
    * 💡 **学习笔记**：特判总和奇偶性是优化枚举的重要一步，能提前剪枝。

3.  **关键点3：如何高效枚举所有3人组合？**
    * **分析**：6个数中选3个的组合数为C(6,3)=20，是固定值。优质题解通过三重循环（i从0到3，j从i+1到4，k从j+1到5）直接覆盖所有组合，时间复杂度O(20)，是最优解。
    * 💡 **学习笔记**：组合数C(n,k)是枚举的理论次数，合理设计循环范围可直接覆盖所有情况。

### ✨ 解题技巧总结
- **特判优先**：先处理不可能的情况（如总和为奇数），减少无效计算。
- **组合枚举**：用i<j<k的循环限制，避免重复枚举同一组合。
- **目标明确**：计算目标和（总和的一半），直接检查当前组合和是否等于目标。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择hello2020的代码作为通用核心实现，因其简洁高效，最能体现枚举法的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了hello2020和chufuzhe的思路，通过三重循环枚举i<j<k的3人组，高效判断是否存在和为目标的组合。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int a[6], sum = 0;
        for (int i = 0; i < 6; ++i) {
            cin >> a[i];
            sum += a[i];
        }
        if (sum % 2 != 0) { // 总和为奇数，直接输出NO
            cout << "NO" << endl;
            return 0;
        }
        int target = sum / 2;
        // 枚举所有i<j<k的3人组合
        for (int i = 0; i < 4; ++i) {
            for (int j = i + 1; j < 5; ++j) {
                for (int k = j + 1; k < 6; ++k) {
                    if (a[i] + a[j] + a[k] == target) {
                        cout << "YES" << endl;
                        return 0;
                    }
                }
            }
        }
        cout << "NO" << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取6个数并计算总和。若总和为奇数，直接输出NO。否则计算目标和（总和的一半），通过三重循环枚举所有i<j<k的3人组，检查其和是否等于目标。若找到符合条件的组合，输出YES并结束；否则输出NO。

---
<code_intro_selected>
接下来，分析优质题解的核心片段：
</code_intro_selected>

**题解一：chufuzhe**
* **亮点**：使用`register`关键字优化循环变量，`ios::sync_with_stdio(false)`加速输入输出，细节优化到位。
* **核心代码片段**：
    ```cpp
    for(register int i=0;i<6;i++) 
        for(register int j=0;j<6;j++) 
            if(i!=j) 
                for(register int k=0;k<6;k++) 
                    if(i!=k && j!=k) 
                        if(a[i]+a[j]+a[k]==s) {
                            ans=1; 
                            break;
                        }
    ```
* **代码解读**：
    这段代码用三重循环枚举所有i、j、k（i≠j≠k），检查和是否为目标。但未限制i<j<k，会重复计算同一组合的不同排列（如i=0,j=1,k=2和i=1,j=0,k=2）。虽然正确，但效率略低于限制i<j<k的实现。
* 💡 **学习笔记**：枚举时需注意是否允许重复，限制索引递增可大幅减少循环次数。

**题解二：hello2020**
* **亮点**：循环范围限制为i≤4, j≤5, k≤6，确保i<j<k，避免重复枚举，效率最高。
* **核心代码片段**：
    ```cpp
    for (int i=1;i<=4;i++)
        for (int j=i+1;j<=5;j++)
            for (int k=j+1;k<=6;k++)
                if (a[i]+a[j]+a[k]==sum/2) {
                    cout<<"YES"<<endl;
                    return 0;
                }
    ```
* **代码解读**：
    这段代码通过i从1到4，j从i+1到5，k从j+1到6，确保i<j<k，覆盖所有C(6,3)=20种组合。一旦找到和为目标的组合，立即输出YES并结束，避免多余计算。
* 💡 **学习笔记**：限制循环范围是优化枚举的关键技巧。

**题解三：Dog_Two**
* **亮点**：利用`next_permutation`生成全排列，思路新颖，适合理解排列与组合的关系。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+6);
    bool if_ans=false;
    do{
        int val=a[1]+a[2]+a[3];
        if_ans=val==sum/2;	
    }while(next_permutation(a+1,a+6) and !if_ans);
    ```
* **代码解读**：
    这段代码先排序数组，然后用`next_permutation`生成所有排列，检查前3个数的和是否为目标。由于排列会生成重复的组合（如1、2、3和2、1、3是不同排列但同一组合），效率较低（720次循环），但能直观展示排列枚举的过程。
* 💡 **学习笔记**：全排列适用于需要考虑顺序的问题，本题更适合组合枚举。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观看到枚举3人组的过程，我设计了一个“像素分组小冒险”动画，用8位像素风格展示枚举过程！
</visualization_intro>

  * **动画演示主题**：像素分组小冒险——帮6个像素伙伴找到平衡的两组！
  * **核心演示内容**：展示如何枚举所有3人组合，计算和并与目标对比，最终找到（或找不到）符合条件的分组。
  * **设计思路简述**：8位像素风（如FC游戏的简洁画面）让学习更轻松；关键步骤的音效（如“叮”提示找到组合）强化记忆；高亮选中的3人组（红色方块）和目标值（黄色数字），直观展示逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕中央是6个像素方块（颜色不同，标有分数），下方是控制面板（开始/暂停、单步、重置按钮，速度滑块）。
          * 顶部显示总分和目标值（如“总分=10，目标=5”）。
          * 播放8位风格的轻快背景音乐。

    2.  **枚举开始**：
          * 点击“开始”，第一个3人组（如方块1、2、3）高亮（红色闪烁），计算和（如1+3+2=6），与目标值（5）对比（数字颜色变化：红色表示不等，绿色表示相等）。
          * 伴随“滴答”音效，进入下一个组合。

    3.  **关键步骤演示**：
          * 当前枚举的3人组（i<j<k）用红色边框标记，其他方块灰色淡化。
          * 计算和时，分数逐个飞入计算器（像素风小窗口），最终显示总和。
          * 若和等于目标值，红色方块变为绿色并播放“叮”的胜利音效，顶部显示“找到啦！”。

    4.  **AI自动演示**：
          * 点击“AI演示”，算法自动快速枚举所有组合，学习者可观察整个过程，感受20次循环的高效。

    5.  **结束状态**：
          * 找到符合条件的组合：绿色方块组成两组，播放庆祝动画（像素星星飘落），背景音乐变欢快。
          * 未找到：所有方块灰色，显示“NO”，播放短促提示音。

  * **旁白提示**：
      * （枚举开始）“现在我们要检查所有3人组合的和是否等于目标值~”
      * （高亮组合）“看！这三个像素伙伴的分数是1、3、2，和为6，不等于目标5哦~”
      * （找到组合）“哇！这三个的和刚好是目标值，成功分组啦！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到枚举的每一步，理解为什么限制i<j<k能避免重复，以及特判总和奇偶性的重要性。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
枚举法是解决组合问题的常用方法，除了本题，还能处理以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 选数问题（如选k个数和为特定值）。
      * 子集和问题（判断是否存在子集和为目标）。
      * 排列组合验证（如验证排列是否满足特定条件）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036** - `选数`
          * 🗣️ **推荐理由**：经典选数问题，需从n个数中选k个使其和为质数，巩固组合枚举和质数判断。
    2.  **洛谷 P1157** - `组合的输出`
          * 🗣️ **推荐理由**：输出所有组合，练习i<j<k的循环写法，理解组合的生成过程。
    3.  **洛谷 P1088** - `火星人`
          * 🗣️ **推荐理由**：利用`next_permutation`生成排列，适合理解全排列的应用场景。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到本题的难度被恶意评分，但实际是简单枚举题。这提醒我们：
</insights_intro>

> **参考经验 (来自多个题解)**：“本题的难点被高估，实际只需暴力枚举所有3人组合即可。关键是要想到特判总和奇偶性，并避免重复枚举。”
>
> **点评**：遇到题目时，先分析问题本质（如本题是组合枚举），再选择合适的算法（如枚举法）。不要被“高难度”标签吓到，动手分析往往能发现简单解法。

-----

<conclusion>
本次关于“ACM ICPC 分组问题”的分析就到这里。通过枚举法，我们能高效解决这类组合问题。记住，枚举的关键是避免重复、提前剪枝，多练习类似题目能让你更熟练！下次见~ 💪
</conclusion>

---
处理用时：119.30秒
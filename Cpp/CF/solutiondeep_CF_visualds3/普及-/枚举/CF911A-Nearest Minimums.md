# 题目信息

# Nearest Minimums

## 题目描述

You are given an array of $ n $ integer numbers $ a_{0},a_{1},...,a_{n-1} $ . Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.
找到一个长度为n的序列中，距离最短的最小值的距离。

## 样例 #1

### 输入

```
2
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
9
2 1 3 5 4 1 2 3 1
```

### 输出

```
3
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Nearest Minimums 深入学习指南 💡

<introduction>
今天我们来一起分析“Nearest Minimums”这道C++编程题。题目要求找到数组中两个最近的最小值的距离。本指南将帮助大家梳理思路，理解核心算法，并掌握高效解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与模拟` (侧重基础数据遍历与关键信息记录)

🗣️ **初步分析**：
> 解决“Nearest Minimums”的关键在于“两步走”：首先找到数组的最小值，然后记录所有最小值的位置，最后在这些位置中找到相邻的最小间距。简单来说，这像在玩“找宝藏”游戏——先确定“宝藏”（最小值）的特征，再标记所有“藏宝点”（最小值的位置），最后在这些点中找到最近的两个。
   - 题解思路对比：主流思路有两种，一种是“两阶段遍历”（先找最小值，再收集位置，最后算间距），另一种是“单次遍历动态更新”（边遍历边记录当前最小值和上一个最小值的位置，实时计算最短距离）。后者空间复杂度更低（仅需记录上一个位置），更高效。
   - 核心算法流程：以单次遍历为例，遍历数组时，若当前数是新的最小值，更新最小值并重置记录；若当前数等于最小值，则计算与上一个最小值位置的间距，更新最短距离。
   - 可视化设计：采用8位像素风，数组元素用彩色方块表示，最小值位置用金色星星标记，上一个最小值位置用箭头指向当前位置，间距用数字气泡显示，关键操作（如更新最小值、计算间距）伴随“叮”的像素音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下3道题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者da32s1da (赞：3)**
* **点评**：此题解的亮点在于“单次遍历动态更新”的巧妙设计。无需额外数组存储所有最小值位置，仅用变量记录当前最小值和上一个最小值的位置，边遍历边计算最短距离。代码简洁规范（变量名`minn`、`wz`、`ans`含义明确），时间复杂度O(n)，空间复杂度O(1)，是竞赛中高效解题的典范。

**题解二：作者归褯雾嵊 (赞：4)**
* **点评**：此题解采用“两阶段遍历”，思路直白易懂。第一阶段找最小值，第二阶段收集所有最小值位置，第三阶段遍历位置数组找最小间距。代码逻辑清晰（变量`zx`表示最小值，`wz`数组记录位置），适合初学者理解基础流程，边界处理（如数组大小）虽略保守但不影响正确性。

**题解三：作者vectorwyx (赞：2)**
* **点评**：此题解用`vector`存储最小值位置，代码风格现代（利用STL容器）。通过`push_back`动态添加位置，避免数组大小预分配的问题，最后遍历`vector`找最小间距。解释中强调“高端感”，实际是对基础思路的灵活应用，适合学习STL的使用场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题时，以下三个关键点需特别注意：
</difficulty_intro>

1.  **关键点1：如何高效找到最小值？**
    * **分析**：最小值可能在数组中多次出现，需遍历所有元素比较。优质题解通常用一次遍历完成（如`minn`变量初始化为极大值，遍历时更新），避免重复扫描。
    * 💡 **学习笔记**：初始值设置为“不可能更小的值”（如`INT_MAX`），确保第一次比较就能更新最小值。

2.  **关键点2：如何记录最小值的位置？**
    * **分析**：记录位置的方式有两种：用数组/`vector`存储所有位置（适合后续遍历计算间距），或仅记录上一个位置（适合动态更新最短距离）。后者空间更优，但需确保遍历顺序正确。
    * 💡 **学习笔记**：若题目需多次访问位置（如求所有间距），用容器存储；若仅需最近间距，动态记录上一个位置更高效。

3.  **关键点3：如何避免遗漏最小间距？**
    * **分析**：最小间距一定出现在相邻的最小值位置之间（如位置序列`p1,p2,p3`，最小间距是`p2-p1`或`p3-p2`）。因此，只需遍历位置数组的相邻元素，无需比较所有组合。
    * 💡 **学习笔记**：相邻位置的间距是最小可能的，因为位置按顺序排列，非相邻的间距一定更大。

### ✨ 解题技巧总结
<summary_best_practices>
-   **问题分解**：将问题拆分为“找最小值”“记录位置”“算间距”三步，每步专注解决一个子问题。
-   **空间优化**：若无需保留所有位置，仅记录上一个位置，减少内存使用（如da32s1da的解法）。
-   **边界处理**：题目保证最小值至少出现两次，无需处理“无解”情况，但需注意位置数组的索引范围（如从第二个元素开始比较）。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了高效性与可读性。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了da32s1da的单次遍历动态更新思路，时间复杂度O(n)，空间复杂度O(1)，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <climits> // 用于INT_MAX

    int main() {
        int n, x;
        int minn = INT_MAX; // 初始化为最大整数值，确保会被更新
        int last_pos = -1;  // 记录上一个最小值的位置
        int ans = INT_MAX;  // 初始化为最大距离，确保会被更新

        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) { // 假设位置从1开始计数
            scanf("%d", &x);
            if (x < minn) {
                // 找到更小的最小值，更新最小值和上一个位置，重置答案
                minn = x;
                last_pos = i;
                ans = INT_MAX; // 之前的距离无效，因为最小值已更新
            } else if (x == minn) {
                // 与当前最小值相同，计算间距并更新答案
                if (last_pos != -1) { // 确保上一个位置已记录（题目保证至少两次，所以不会为-1）
                    int current_dist = i - last_pos;
                    if (current_dist < ans) {
                        ans = current_dist;
                    }
                }
                last_pos = i; // 更新上一个位置为当前位置
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码通过一次遍历完成所有操作：首先读取数组长度`n`，然后逐个读取数组元素。`minn`记录当前最小值，`last_pos`记录上一个最小值的位置，`ans`记录最短距离。当遇到更小的元素时，更新最小值和`last_pos`；当遇到相同最小值时，计算当前位置与`last_pos`的间距，更新`ans`，并将`last_pos`更新为当前位置。最终输出`ans`。

---
<code_intro_selected>
接下来，赏析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者da32s1da**
* **亮点**：一次遍历，空间O(1)，代码极简。
* **核心代码片段**：
    ```cpp
    int minn,wz,n,x,ans;
    main(){
        scanf("%d",&n);
        minn=inf;ans=n;
        for(int i=1;i<=n;i++){
            scanf("%d",&x);
            if(minn==x&&ans>i-wz)ans=i-wz;
            if(minn==x)wz=i;
            if(minn>x)minn=x,wz=i,ans=n;
        }
        printf("%d\n",ans);
    }
    ```
* **代码解读**：
    > 这段代码用`minn`记录最小值，`wz`记录上一个最小值的位置，`ans`初始化为数组长度（最大可能间距）。遍历每个元素时：若等于最小值，计算当前位置与`wz`的间距，更新`ans`，并更新`wz`；若小于最小值，更新`minn`、`wz`和`ans`。逻辑紧凑，仅用三个变量完成所有操作。
* 💡 **学习笔记**：变量初始化和边界条件（如`ans`初始化为`n`）是关键，确保第一次比较有效。

**题解二：作者vectorwyx**
* **亮点**：用`vector`动态存储位置，代码现代。
* **核心代码片段**：
    ```cpp
    vector<int> wyx;
    for(int i=1;i<=n;++i){
        if(a[i]==mn) wyx.push_back(i);
    }
    l=wyx.size();
    for(int i=1;i<l;++i) ans=min(ans,wyx[i]-wyx[i-1]);
    ```
* **代码解读**：
    > `vector`的`push_back`方法动态添加最小值的位置，避免了数组大小预分配的问题。遍历`vector`时，从第二个元素开始（索引1），与前一个元素（索引0）比较间距，找到最小值。这种方法直观，适合需要保留所有位置的场景。
* 💡 **学习笔记**：`vector`适合动态数据存储，代码更简洁且不易越界。

**题解三：作者归褯雾嵊**
* **亮点**：基础思路清晰，适合初学者。
* **核心代码片段**：
    ```cpp
    int wz[100001];
    for(int i=1;i<=n;i++){
        if(a[i]==zx) wz[total++]=i;
    }
    for(int i=2;i<total;i++) jl=min(jl,wz[i]-wz[i-1]);
    ```
* **代码解读**：
    > 用数组`wz`记录最小值的位置，`total`计数。遍历数组时，将最小值的位置存入`wz`。最后遍历`wz`数组，比较相邻元素的间距，更新最短距离。这种方法直观，便于理解位置记录的过程。
* 💡 **学习笔记**：数组适合固定大小或已知最大数据量的场景，初始化时需注意大小足够。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“单次遍历动态更新”的过程，我们设计了一个8位像素风格的动画，名为“像素寻宝大冒险”。
</visualization_intro>

  * **动画演示主题**：`像素寻宝大冒险——寻找最近的宝藏点`

  * **核心演示内容**：展示数组元素逐个出现，标记最小值的位置，动态计算相邻宝藏点（最小值位置）的间距，最终找到最短距离。

  * **设计思路简述**：采用FC红白机风格的像素画面，用不同颜色区分普通元素（灰色）和最小值（金色）。通过闪烁、箭头标记和音效，突出关键操作（如发现新最小值、计算间距），增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕上方显示8位字体的标题“像素寻宝”，下方是一个横向排列的像素网格（每个格子代表数组元素，初始为灰色）。
          * 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-5倍速）。
          * 背景播放8位风格的轻快音乐（如《超级玛丽》主题变调）。

    2.  **遍历开始**：
          * 第一个元素（位置1）进入网格，颜色变为白色，伴随“滴”的音效。
          * 变量框显示`minn=当前值`，`last_pos=1`，`ans=∞`（用像素数字显示）。

    3.  **发现新最小值**：
          * 当遍历到更小的元素（如样例3中的第二个元素1），该格子变为金色并闪烁，播放“叮~”的音效。
          * `minn`更新为新值，`last_pos`更新为当前位置，`ans`重置为∞（用像素数字动画变化）。

    4.  **发现相同最小值**：
          * 当遍历到与`minn`相同的元素（如样例3中的第六个元素1），该格子变为金色，上一个金色格子（位置2）出现箭头指向当前格子（位置6）。
          * 计算间距（6-2=4），`ans`更新为4，伴随“咔嗒”音效。

    5.  **更新最短距离**：
          * 继续遍历到下一个相同最小值（位置9），箭头从位置6指向9，计算间距（9-6=3），`ans`更新为3，播放“叮”的更高音调音效。

    6.  **遍历结束**：
          * 所有元素遍历完成，最终`ans=3`显示在屏幕中央，金色格子组成的路径闪烁，播放“胜利”音效（如《超级玛丽》吃金币音效）。

  * **旁白提示**：
      - （发现新最小值时）“哇！找到更小的宝藏啦！更新最小值和上一个位置~”
      - （发现相同最小值时）“又找到一个宝藏！计算和上一个宝藏的距离，看看是不是最短~”
      - （遍历结束时）“完成！最短距离就是这个啦~”

<visualization_conclusion>
通过这样的动画，我们能直观看到每一步如何更新最小值和位置，以及最短距离是如何被动态计算出来的。像素风格和游戏音效让学习过程更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“记录关键位置并找相邻最小间距”，这种思路可迁移到多种场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 寻找数组中最近的重复元素（如“最近的重复项”问题）。
      * 统计序列中相邻特定元素的最小间距（如“数组中0的最近间距”）。
      * 处理时间序列中事件的最小间隔（如“最近的两次登录时间差”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1115** - `最大子段和`
          * 🗣️ **推荐理由**：需要遍历数组并动态更新当前最大值，与本题的动态更新思路类似。
    2.  **洛谷 P1427** - `小鱼的数字游戏`
          * 🗣️ **推荐理由**：练习数组的遍历与记录，巩固基础操作。
    3.  **洛谷 P1957** - `口算练习题`
          * 🗣️ **推荐理由**：需要处理多组输入并记录关键信息，提升代码的健壮性。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了实践中的小技巧：
</insights_intro>

> **参考经验 (来自作者vectorwyx)**：“这道题用vector存位置，虽然和数组思路一样，但感觉更‘高端’。其实STL容器能让代码更简洁，特别是动态数据的处理。”
>
> **点评**：vector等STL容器确实能简化动态数据的管理，避免数组大小预分配的麻烦。学习STL的使用能提升代码的可读性和效率，值得掌握！

-----

<conclusion>
本次关于“Nearest Minimums”的分析就到这里。通过理解核心思路、赏析优质代码和观看像素动画，相信大家已掌握解题技巧。记住，多动手练习、多尝试不同方法（如一次遍历 vs 两阶段遍历），编程能力会稳步提升！下次见~ 💪
</conclusion>

-----

---
处理用时：132.54秒
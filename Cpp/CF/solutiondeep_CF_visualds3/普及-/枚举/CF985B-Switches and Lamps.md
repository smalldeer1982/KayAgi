# 题目信息

# Switches and Lamps

## 题目描述

You are given $ n $ switches and $ m $ lamps. The $ i $ -th switch turns on some subset of the lamps. This information is given as the matrix $ a $ consisting of $ n $ rows and $ m $ columns where $ a_{i,j}=1 $ if the $ i $ -th switch turns on the $ j $ -th lamp and $ a_{i,j}=0 $ if the $ i $ -th switch is not connected to the $ j $ -th lamp.

Initially all $ m $ lamps are turned off.

Switches change state only from "off" to "on". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.

It is guaranteed that if you push all $ n $ switches then all $ m $ lamps will be turned on.

Your think that you have too many switches and you would like to ignore one of them.

Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other $ n-1 $ switches then all the $ m $ lamps will be turned on.

## 样例 #1

### 输入

```
4 5
10101
01000
00111
10000
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
4 5
10100
01000
00110
00101
```

### 输出

```
NO
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Switches and Lamps 深入学习指南 💡

<introduction>
今天我们来一起分析“Switches and Lamps”这道题。这道题的核心是判断是否存在一个开关，去掉它后剩下的开关仍能点亮所有灯。通过本指南，你将掌握如何高效解决这类问题，并理解其中的关键思路和技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举与统计（编程技巧应用）

🗣️ **初步分析**：
解决这道题的关键在于“枚举”和“统计”。简单来说，枚举就像逐个检查每个候选答案，而统计则是提前记录关键信息以避免重复计算。就像你有一筐苹果，想找出是否有一个苹果可以拿走而不影响筐里的总重量——你需要先知道每个苹果的重量（统计），再逐个尝试拿走（枚举）。

在本题中，我们需要：
1. **统计每个灯的控制开关数**：用数组`cnt[j]`记录第`j`个灯被多少个开关控制。
2. **枚举每个开关**：检查去掉该开关后，是否所有灯仍有至少一个控制开关。若某个灯仅被当前开关控制（即`cnt[j]==1`且该开关控制它），则这个开关不能去掉。

核心难点在于如何高效判断“去掉某个开关后所有灯是否仍被控制”。通过预处理`cnt`数组，我们可以将每次判断的时间复杂度降到O(m)，整体复杂度为O(nm)，这非常高效。

**可视化设计思路**：我们将用8位像素风格展示开关和灯的网格。每个灯用小方块表示，颜色越深表示被越多开关控制（例如，绿色表示被多个控制，红色表示仅被一个控制）。枚举开关时，用像素箭头指向当前检查的开关，其控制的灯会闪烁。若发现某灯变红（仅被当前开关控制），则该开关不可去掉；若所有控制的灯都是绿色，则输出“YES”，伴随像素星星动画和“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：AutumnKite（来源：作者博客）**
* **点评**：这份题解思路非常清晰，直接点出“统计每个灯的控制开关数”是关键。代码中使用`cnt[j]`统计每个灯的控制数，枚举时快速判断，时间复杂度O(nm)，非常高效。变量名`cnt`含义明确，代码结构简洁，边界处理严谨（如`isdigit`确保输入正确）。从实践角度看，这种预处理+枚举的方法是竞赛中常用的优化思路，值得学习。

**题解二：togeth1（来源：洛谷题解）**
* **点评**：此题解用`sum[j]`统计每个灯的控制数，代码简洁易懂。注释清晰（如“读入这个二维矩阵，并求出每一盏灯能被其他的几盏灯打开”），逻辑直接。枚举开关时，通过判断`sum[j]==1`快速排除不可去掉的开关，是典型的“预处理+枚举”优化，适合初学者理解。

**题解三：xvl_（来源：洛谷题解）**
* **点评**：此题解变量名`cnt`直观，代码注释详细（如`cnt[i] 表示有多少个开关可以打开第 i 盏灯`）。在枚举时，通过`flag`标记是否存在不可去掉的情况，逻辑清晰。代码风格规范，没有冗余操作，体现了良好的编程习惯。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们会遇到以下关键难点，掌握这些能帮你举一反三：
</difficulty_intro>

1.  **关键点1**：如何高效判断“去掉某个开关后所有灯仍被控制”？
    * **分析**：直接模拟去掉每个开关后重新统计所有灯的控制数会超时（O(n²m)）。通过预处理`cnt[j]`（每个灯的初始控制数），我们可以快速判断：若开关`i`控制的某个灯`j`的`cnt[j]==1`，则去掉`i`后`j`无法被控制。这一步将时间复杂度优化到O(nm)。
    * 💡 **学习笔记**：预处理关键信息（如统计数）是优化枚举类问题的常用技巧。

2.  **关键点2**：如何避免重复计算？
    * **分析**：预处理`cnt[j]`后，枚举每个开关时只需检查其控制的灯是否有`cnt[j]==1`的情况，无需重新遍历所有灯。这避免了重复统计，提升了效率。
    * 💡 **学习笔记**：用空间换时间（存储`cnt`数组）是平衡时间复杂度的重要思路。

3.  **关键点3**：如何处理边界条件？
    * **分析**：题目保证所有开关按下时能打开所有灯，因此`cnt[j]≥1`对所有`j`成立。枚举时只需关注`cnt[j]==1`的情况（此时对应的开关不可去掉）。
    * 💡 **学习笔记**：题目中的“保证条件”常隐含关键信息，需仔细阅读。

### ✨ 解题技巧总结
- **预处理统计**：提前统计每个灯的控制开关数，避免重复计算。
- **快速判断**：枚举时仅检查当前开关控制的灯，而非所有灯，减少冗余操作。
- **变量名规范**：使用`cnt`、`sum`等直观的变量名，提升代码可读性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个简洁、高效的通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了AutumnKite和togeth1的思路，统计每个灯的控制数后枚举每个开关，时间复杂度O(nm)，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    using namespace std;

    const int MAX_M = 2005; // 灯的最大数量
    int cnt[MAX_M];         // cnt[j]表示第j个灯被多少个开关控制

    int main() {
        int n, m;
        scanf("%d%d", &n, &m);
        char a[n+1][m+1]; // 开关与灯的连接矩阵

        // 统计每个灯的控制开关数
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                while (!isdigit(a[i][j] = getchar())); // 读取输入并跳过非数字字符
                if (a[i][j] == '1') cnt[j]++;
            }
        }

        // 枚举每个开关，判断是否可以去掉
        for (int i = 1; i <= n; ++i) {
            bool can_remove = true;
            for (int j = 1; j <= m; ++j) {
                if (a[i][j] == '1' && cnt[j] == 1) {
                    can_remove = false;
                    break; // 存在仅由当前开关控制的灯，不能去掉
                }
            }
            if (can_remove) {
                printf("YES\n");
                return 0;
            }
        }

        printf("NO\n");
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并统计每个灯的控制开关数（`cnt[j]`）。然后枚举每个开关，检查其控制的灯是否有仅由它控制的（`cnt[j]==1`）。若存在这样的灯，则该开关不能去掉；否则输出“YES”。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：AutumnKite**
* **亮点**：使用`register`关键字优化循环变量，提升运行效率；输入处理严谨（`isdigit`过滤非数字字符）。
* **核心代码片段**：
    ```cpp
    for (register int i = 1; i <= n; ++i)
        for (register int j = 1; j <= m; ++j)
            cnt[j] += a[i][j] ^ '0'; // 统计cnt

    for (register int i = 1; i <= n; ++i){
        register bool bo = true;
        for (register int j = 1; j <= m; ++j)
            if (a[i][j] == '1' && cnt[j] == 1) bo = false;
        if (bo) return printf("YES"), 0;
    }
    ```
* **代码解读**：
    `cnt[j] += a[i][j] ^ '0'`通过异或运算将字符'0'/'1'转为0/1，简洁高效。枚举时用`bo`标记是否可去掉当前开关，若所有控制的灯`cnt[j]>1`，则输出“YES”。
* 💡 **学习笔记**：`register`关键字可提示编译器优化循环变量，适合竞赛中的效率提升。

**题解二：togeth1**
* **亮点**：代码简洁，注释清晰，直接点出统计的目的。
* **核心代码片段**：
    ```cpp
    for(int i=1; i<=n; i++) 
        for(int j=1; j<=m; j++)
            cin>>a[i][j],sum[j] += a[i][j] - '0';

    for(int i=1; i<=n; i++){
        bool flag = 0;
        for(int j=1; j<=m; j++)
            if(a[i][j] == '1' && sum[j] == 1) flag = 1;
        if(!flag) {cout<<"YES"; return 0;}
    }
    ```
* **代码解读**：
    `sum[j] += a[i][j] - '0'`将字符转为数字累加，统计每个灯的控制数。枚举时若`flag`为0（无仅由当前开关控制的灯），则输出“YES”。
* 💡 **学习笔记**：用`sum`替代`cnt`，变量名更直观，适合初学者理解。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举+统计”的过程，我们设计了一个8位像素风格的动画，让你“看”到每个开关是否可去掉！
</visualization_intro>

  * **动画演示主题**：像素开关屋大冒险！
  * **核心演示内容**：在一个复古像素房间里，左边是n个开关（黄色按钮），右边是m个灯（圆形灯泡）。每个灯下方显示控制它的开关数（`cnt[j]`）。我们需要找到一个可去掉的开关（绿色按钮），去掉后所有灯仍亮。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围，灯的颜色变化（绿色→红色）直观反映控制数变化。音效（“叮”表示成功，“滴”表示失败）强化操作记忆，小关卡设计（每检查一个开关算一关）增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 开关排成一列（黄色按钮，编号1~n），灯排成一行（初始灰色，下方显示`cnt[j]`）。
        - 控制面板：单步/自动按钮、速度滑块（1x~5x）、重置按钮。
        - 播放8位风格背景音乐（类似《超级玛丽》的轻快旋律）。

    2.  **统计阶段**：
        - 每个开关被按下（按钮下沉动画），对应控制的灯变亮（绿色），`cnt[j]`数字增加（如灯j被开关i控制，`cnt[j]`从0→1→2…），伴随“滴答”音效。

    3.  **枚举阶段（关键！）**：
        - 用像素箭头指向当前检查的开关i（如开关3闪烁）。
        - 该开关控制的灯j开始闪烁（黄色），检查其`cnt[j]`：
          - 若`cnt[j]==1`（灯j变红），箭头变叉（红色），播放“滴”音效，标记开关i不可去掉。
          - 若所有控制的灯`cnt[j]>1`（灯保持绿色），箭头变勾（绿色），播放“叮”音效，标记开关i可去掉，屏幕弹出“YES”和像素星星。

    4.  **结束状态**：
        - 找到可去掉的开关：所有灯保持绿色，背景音乐变高潮，显示“成功！”。
        - 未找到：所有开关检查完毕，显示“NO”，背景音乐变低沉。

  * **旁白提示**：
    - （统计阶段）“看！每个灯下方的数字是它被多少开关控制～”
    - （枚举阶段）“现在检查开关3，它控制的灯在闪烁！如果有灯的数字是1，这个开关就不能去掉哦～”
    - （成功时）“太棒了！找到可去掉的开关，所有灯都能被其他开关控制～”

<visualization_conclusion>
通过这个动画，你不仅能看到统计和枚举的每一步，还能在游戏化的体验中深刻理解“预处理+枚举”的高效思路！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了这道题的思路后，我们可以尝试解决更多类似的“枚举+统计”问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    本题的“预处理关键信息（如统计数）+枚举候选”思路，还可用于：
    - 判断是否存在冗余边（图论中，去掉某边后图仍连通）。
    - 检查数组中是否存在冗余元素（去掉后满足某种条件）。
    - 统计字符串中字符频率，枚举删除某个字符后是否满足要求。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1161 开灯问题**
        * 🗣️ **推荐理由**：统计每个灯被按的次数，枚举每个灯判断是否被按奇数次，与本题统计思路类似。
    2.  **洛谷 P1553 数字反转（升级版）**
        * 🗣️ **推荐理由**：枚举数字的每一位，统计反转后的结果，锻炼枚举和边界处理能力。
    3.  **洛谷 P1003 铺地毯**
        * 🗣️ **推荐理由**：逆序枚举地毯，统计每个点最后覆盖的地毯，与本题“枚举+快速判断”思路相似。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
虽然题解中未明确提到作者的调试心得，但根据代码常见问题，我们总结以下经验：
</insights_intro>

> **常见调试经验**：在统计`cnt[j]`时，需注意输入的字符可能包含空格或换行符（如样例输入中的每行是连续的字符串）。例如，使用`getchar()`读取时，需跳过非数字字符（如AutumnKite的代码），否则`cnt[j]`会统计错误。

**点评**：输入处理是编程中容易出错的环节。遇到字符输入时，一定要确保读取的是有效数据（如数字），可以通过`isdigit`或循环跳过非数字字符来避免错误。这是保证统计正确性的关键！

---

<conclusion>
通过本次分析，我们掌握了“Switches and Lamps”的核心思路：预处理统计+枚举判断。希望你能在实践中灵活运用这种方法，解决更多类似问题！记住，编程的乐趣在于思考和尝试，下次见～💪
</conclusion>

---
处理用时：143.02秒
# 题目信息

# Good String

## 题目描述

有一个长度为$n(1<=n<=100)$的字符串，只由<,>两种字符组成。对其进行一次操作如下：


------------

如果选择一个>字符，这个字符**右面**的那一个字符会被删除。特别地，如果你选择的这个字符>位于字符串的最右侧，什么都不会发生。同理，如果选择一个<字符，这个字符**左面**的那一个字符会被删除，选择位于字符串最左边的<字符也什么都不会发生。


------------

定义一下的一个字符串是“好的”：经过若干次以上操作，这个字符串可以只含有一种字符，如>,>>等。

在执行操作之前，你可以删去字符串中的$k(0<=k<=n-1)$$个字符。注意不可以把整个字符串都删去了。

你需要找出$k$的最小值，使得删去$k$个字符后的字符串是“好的”。

## 说明/提示

第一组数据中，删除任意一个字符都可以使得剩下的字符串是“好的”。

第二组数据中，原字符串就是“好的”，无需删除任何字符。

## 样例 #1

### 输入

```
3
2
<>
3
><<
1
>```

### 输出

```
1
0
0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Good String 深入学习指南 💡

<introduction>
今天我们来一起分析“Good String”这道C++编程题。这道题的关键在于通过观察操作规则，找到让字符串变成“好的”的最小删除次数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用` (侧重问题观察与简化)

🗣️ **初步分析**：
> 解决“Good String”这道题，关键在于发现“好的字符串”的本质特征。简单来说，一个“好的字符串”需要满足：通过若干次操作后只剩下一种字符（全`<`或全`>`）。根据操作规则，`>`能删除右边的字符，`<`能删除左边的字符，因此**最左端是`>`或最右端是`<`的字符串一定是好的**（因为它们能逐步删除其他所有字符）。  
> 题解的核心思路是：计算需要删除左边连续`<`的数量（使最左变为`>`），以及需要删除右边连续`>`的数量（使最右变为`<`），取两者的最小值即为答案。  
> 核心算法流程：遍历字符串左端统计连续`<`的个数（记为`a1`），遍历右端统计连续`>`的个数（记为`a2`），最终结果为`min(a1, a2)`。  
> 可视化设计上，我们可以用8位像素风格展示字符串，用红色标记需要删除的字符，绿色高亮最终的最左`>`或最右`<`，每删除一个字符播放“叮”的音效，完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码可读性、算法有效性等，以下题解因逻辑简洁、代码规范被选为优质参考：
</eval_intro>

**题解一：作者：saixingzhe**
* **点评**：此题解思路直接，通过两次遍历分别统计左右需要删除的字符数。代码变量名`a1`、`a2`清晰易懂，边界条件处理严谨（如`i==n`时终止循环）。算法复杂度为O(n)，高效简洁，适合竞赛场景。

**题解二：作者：lightningZ**
* **点评**：此题解用字符数组存储字符串，逻辑与saixingzhe类似，但循环条件更直观（从左到右统计`<`，从右到左统计`>`）。代码注释明确，适合初学者理解。

**题解三：作者：LeTu_Jun**
* **点评**：此题解用`char`数组存储字符串，变量名`a1`、`a2`含义明确。代码结构工整，循环终止条件（`i==n`和`n==1`）处理到位，体现了良好的边界意识。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要突破以下关键难点：
</difficulty_intro>

1.  **关键点1**：如何定义“好的字符串”的条件？
    * **分析**：通过观察操作规则，若最左端是`>`，它可以不断删除右边字符，最终只剩自己；同理，最右端是`<`时也能删除左边字符。因此，“好的字符串”的条件是**最左为`>`或最右为`<`**。
    * 💡 **学习笔记**：问题的本质往往隐藏在操作规则中，观察极端情况（如最左/最右字符）能快速找到突破口。

2.  **关键点2**：如何计算最小删除次数？
    * **分析**：要让最左变为`>`，需删除左边所有连续的`<`；要让最右变为`<`，需删除右边所有连续的`>`。统计这两个数量的最小值即可。
    * 💡 **学习笔记**：将问题拆解为左右两个子问题，分别求解后取最优，是典型的贪心策略。

3.  **关键点3**：如何处理边界条件？
    * **分析**：当字符串全为`<`（此时最右是`<`）或全为`>`（此时最左是`>`）时，无需删除。代码中需确保循环在到达边界时终止（如`i==n`或`n==1`）。
    * 💡 **学习笔记**：边界条件是编程的“细节杀手”，需仔细验证循环终止条件。

### ✨ 解题技巧总结
<summary_best_practices>
-   **问题抽象**：将复杂操作规则转化为字符串的最左/最右字符特征，简化问题。
-   **贪心策略**：分别计算左右两种可能的删除次数，取最小值。
-   **边界验证**：循环中加入边界判断（如`i==n`），避免越界错误。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合多个优质题解思路，通过两次遍历统计左右需要删除的字符数，取最小值。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int t;
        scanf("%d", &t);
        while (t--) {
            int n;
            string s;
            scanf("%d", &n);
            cin >> s;
            int left = 0, right = 0;
            // 统计左边连续的'<'个数（需删除）
            while (left < n && s[left] == '<') left++;
            // 统计右边连续的'>'个数（需删除）
            while (right < n && s[n - 1 - right] == '>') right++;
            printf("%d\n", min(left, right));
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取测试用例数`t`，对每个测试用例，读取字符串长度`n`和字符串`s`。通过两个循环分别统计左边连续`<`的个数（`left`）和右边连续`>`的个数（`right`），最后输出两者的最小值。核心逻辑是通过遍历左右两端确定需要删除的字符数。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解其设计思路。
</code_intro_selected>

**题解一：作者：saixingzhe**
* **亮点**：代码简洁，变量名直观，边界条件处理严谨。
* **核心代码片段**：
    ```cpp
    while(s[i]=='<'){
        if(i==n) break;
        a1++;
        i++;
    }
    while(s[n]=='>'){
        if(n==0) break;
        a2++;
        n--;
    }
    ```
* **代码解读**：
    > 第一个循环从左到右遍历，统计连续`<`的个数（`a1`），当遇到`>`或到达末尾时停止。第二个循环从右到左遍历，统计连续`>`的个数（`a2`），当遇到`<`或到达开头时停止。`a1`和`a2`分别表示将最左变为`>`和最右变为`<`需要删除的字符数。
* 💡 **学习笔记**：遍历方向的选择（左到右、右到左）直接对应问题的左右子问题，逻辑清晰。

**题解二：作者：LeTu_Jun**
* **亮点**：使用`char`数组存储字符串，循环条件明确。
* **核心代码片段**：
    ```cpp
    while(s[i]=='<'){
        if(i==n) break;
        a1++;
        i++;
    }
    while(s[n]=='>'){
        if(n==1) break;
        a2++;
        n--;
    }
    ```
* **代码解读**：
    > 第一个循环统计左边连续`<`的个数（`a1`），当`i`到达字符串末尾（`i==n`）时停止。第二个循环统计右边连续`>`的个数（`a2`），当`n`缩减到1（只剩一个字符）时停止。通过`n--`动态调整右边界，直观展示删除过程。
* 💡 **学习笔记**：动态调整边界（如`n--`）能更直观地模拟“删除”操作，便于理解。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“统计左右连续字符”的过程，我们设计一个8位像素风格的动画，模拟删除操作的每一步！
</visualization_intro>

  * **动画演示主题**：`像素小卫士的字符清理任务`（复古FC风格）
  * **核心演示内容**：展示字符串左右两端连续`<`或`>`的删除过程，最终高亮最左`>`或最右`<`。
  * **设计思路简述**：8位像素风格（16色调色板）营造轻松氛围，通过颜色变化和音效强化操作记忆。例如，红色像素块表示待删除的`<`或`>`，绿色像素块表示保留的字符，每删除一个字符播放“叮”的音效，完成时播放胜利音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕中央显示像素化字符串（如“<<><>>”），每个字符用16x16像素块表示，`<`为蓝色，`>`为黄色。
        - 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-5倍速）。
        - 播放8位风格背景音乐（轻快的电子旋律）。

    2.  **统计左边连续`<`**：
        - 左指针（白色箭头）从最左端开始，逐个检查字符：
          - 若为`<`（蓝色），该像素块变红（标记为待删除），箭头右移一格，播放“叮”音效。
          - 若遇到`>`（黄色），箭头停止，显示“需删除`left`个字符”。

    3.  **统计右边连续`>`**：
        - 右指针（白色箭头）从最右端开始，逐个检查字符：
          - 若为`>`（黄色），该像素块变红（标记为待删除），箭头左移一格，播放“叮”音效。
          - 若遇到`<`（蓝色），箭头停止，显示“需删除`right`个字符”。

    4.  **结果展示**：
        - 比较`left`和`right`，用绿色高亮较小值对应的删除方向（如`left=2`，则左边两个红色块消失，剩下的字符串最左为`>`）。
        - 播放胜利音效（上扬的电子音），显示“最小删除次数：min(left, right)”。

    5.  **交互控制**：
        - 单步执行：点击“单步”按钮，逐步查看左右指针的移动和字符删除。
        - 自动播放：选择速度后，动画自动演示完整过程。
        - 重置：点击“重置”按钮，恢复初始字符串和指针位置。

  * **旁白提示**：
    - （左指针移动时）“看！左指针在检查连续的`<`，这些都需要删除哦～”
    - （右指针移动时）“右指针在检查连续的`>`，同样需要删除～”
    - （结果展示时）“最终要删除的最小次数是`left`和`right`中的较小值，这样就能得到一个好的字符串啦！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到左右连续字符的删除过程，理解为什么取`min(left, right)`就是答案。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以尝试以下拓展练习，巩固“观察极端情况+贪心”的解题思路。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 本题的关键是观察操作规则的极端情况（最左/最右字符），类似思路可用于：
      - 字符串删除问题（如删除最少字符使字符串满足某种模式）。
      - 数组极值问题（如寻找数组两端的特定元素）。
      - 区间操作问题（如通过左右指针确定最小操作次数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1055 [NOIP2008 普及组] ISBN号码**
          * 🗣️ **推荐理由**：考察字符串处理和边界条件判断，与本题的“细节处理”能力相关。
    2.  **洛谷 P1075 [NOIP2012 普及组] 质因数分解**
          * 🗣️ **推荐理由**：通过观察极端值（最小质因数）简化问题，与本题“观察极端情况”的思路类似。
    3.  **洛谷 P1200 [USACO1.1] 你的飞碟在这儿**
          * 🗣️ **推荐理由**：考察字符串遍历和简单数学计算，适合巩固基础操作。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但通过观察题解，我们可以总结：遇到操作规则类问题时，先通过小例子模拟操作，观察极端情况（如最左/最右），往往能快速找到规律。
</insights_intro>

---

<conclusion>
本次关于“Good String”的C++解题分析就到这里。希望这份指南能帮助你理解如何通过观察问题本质、拆解子问题来找到最优解。记住，多动手模拟小例子，是发现规律的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：132.46秒
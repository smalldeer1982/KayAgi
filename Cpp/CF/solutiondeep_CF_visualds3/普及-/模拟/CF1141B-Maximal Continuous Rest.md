# 题目信息

# Maximal Continuous Rest

## 题目描述

Each day in Berland consists of $ n $ hours. Polycarp likes time management. That's why he has a fixed schedule for each day — it is a sequence $ a_1, a_2, \dots, a_n $ (each $ a_i $ is either $ 0 $ or $ 1 $ ), where $ a_i=0 $ if Polycarp works during the $ i $ -th hour of the day and $ a_i=1 $ if Polycarp rests during the $ i $ -th hour of the day.

Days go one after another endlessly and Polycarp uses the same schedule for each day.

What is the maximal number of continuous hours during which Polycarp rests? It is guaranteed that there is at least one working hour in a day.

## 说明/提示

In the first example, the maximal rest starts in last hour and goes to the first hour of the next day.

In the second example, Polycarp has maximal rest from the $ 4 $ -th to the $ 5 $ -th hour.

In the third example, Polycarp has maximal rest from the $ 3 $ -rd to the $ 5 $ -th hour.

In the fourth example, Polycarp has no rest at all.

## 样例 #1

### 输入

```
5
1 0 1 0 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6
0 1 0 1 1 0
```

### 输出

```
2
```

## 样例 #3

### 输入

```
7
1 0 1 1 1 0 1
```

### 输出

```
3
```

## 样例 #4

### 输入

```
3
0 0 0
```

### 输出

```
0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Maximal Continuous Rest 深入学习指南 💡

<introduction>
今天我们来一起分析“Maximal Continuous Rest”这道C++编程题。这道题的关键在于处理环形数组中最长连续1的统计问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与环形数组处理`

🗣️ **初步分析**：
解决“Maximal Continuous Rest”这道题，关键在于理解环形数组的特性并通过模拟遍历统计最长连续休息时间。简单来说，“模拟”就是像“逐小时检查”一样，遍历数组并记录连续休息（1）的时长；而“环形数组处理”则是要考虑首尾相连的情况——比如，最后一个小时的休息可能和下一天第一个小时的休息连在一起，形成更长的连续段。

- **题解思路对比**：主要有两种思路。一种是“破环成链”（将原数组复制一遍，形成2n长度的数组，直接遍历找最长连续1）；另一种是“首尾拼接统计”（分别计算数组内部最长连续1和首尾连续1的和，取最大值）。两种方法都能解决问题，但“破环成链”更直观，适合新手理解。
- **核心算法流程**：以“破环成链”为例，算法流程是：将原数组复制到末尾（如原数组是[1,0,1]，复制后变为[1,0,1,1,0,1]），然后遍历这个2n长度的数组，统计连续1的最大长度。关键点是在遍历时，遇到0就重置当前连续长度，并更新最大值。
- **可视化设计思路**：我们将用8位像素风格展示环形数组，每个小时用绿色（1）或红色（0）的像素块表示。动画中会高亮当前统计的连续1段，用数字实时显示当前长度，并在找到更长段时触发“叮”的音效，最后用金色高光标出最长段。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下4星及以上的题解：
</eval_intro>

**题解一：清清老大（来源：用户题解）**
* **点评**：此题解采用“破环成链”思路，代码简洁且逻辑清晰。通过复制数组到末尾，将环形问题转化为线性问题，直接遍历2n长度的数组统计最长连续1。变量名`sum`（当前连续长度）、`maxsum`（最大长度）含义明确，边界处理（如复制数组）严谨，非常适合新手学习。

**题解二：happybob（来源：用户题解）**
* **点评**：此题解同样使用“破环成链”方法，但代码更紧凑。通过`a[i + n] = a[i]`复制数组，遍历2n长度时直接统计。变量`cnt`（当前连续长度）、`max`（最大长度）命名直观，循环结构简单，易于调试。

**题解三：FP·荷兰猪（来源：用户题解）**
* **点评**：此题解采用“首尾拼接统计”思路，分别计算数组内部最长连续1和首尾连续1的和。代码中`maxv`（内部最长）、`cnt2`（首尾和）变量名清晰，逻辑直接，适合理解环形数组的特殊情况处理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何处理环形数组的首尾相连？
    * **分析**：环形数组的特点是末尾与开头相连，可能形成更长的连续1段。例如，原数组末尾有k个1，开头有m个1，环形后总长度为k+m。优质题解通常通过两种方式处理：一是“破环成链”（复制数组），二是分别统计首尾连续1的长度并相加。
    * 💡 **学习笔记**：环形问题的核心是“首尾相连”，需要额外考虑这部分的合并情况。

2.  **关键点2**：如何高效统计最长连续1？
    * **分析**：遍历数组时，遇到1就累加当前长度，遇到0就重置当前长度并更新最大值。这一步需要注意遍历的边界（如2n长度的数组）和初始值的设置（如`maxsum`初始为0）。
    * 💡 **学习笔记**：连续统计问题的通用方法是“滑动窗口”，用一个变量记录当前长度，另一个变量记录最大值。

3.  **关键点3**：如何避免重复计算或遗漏？
    * **分析**：例如，当数组全为1时（但题目保证至少有一个0，所以无需处理），或首尾连续1的和超过数组长度时（需取最小值，因为环形最多只能有n个1）。优质题解通过限制遍历长度（如2n）或直接取`max(内部最长, 首尾和)`来避免。
    * 💡 **学习笔记**：题目中的“保证条件”（如至少一个0）可以简化边界处理，但仍需注意逻辑完整性。

### ✨ 解题技巧总结
<summary_best_practices>
-   **破环成链**：将环形数组复制一遍，转化为线性问题，简化首尾相连的处理。
-   **双变量统计**：用一个变量记录当前连续长度，另一个记录最大值，遍历一次即可完成统计。
-   **首尾单独计算**：若不想复制数组，可分别统计数组开头和末尾的连续1长度，相加后与内部最大值比较。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“破环成链”思路的优质题解，逻辑清晰且高效，适合作为参考。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        int a[2 * n]; // 复制后的数组长度为2n
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            a[i + n] = a[i]; // 复制数组
        }
        int max_len = 0, current = 0;
        for (int i = 0; i < 2 * n; ++i) {
            if (a[i] == 1) {
                current++;
                max_len = max(max_len, current);
            } else {
                current = 0;
            }
        }
        // 由于环形最多只能有n个1，取两者较小值
        cout << min(max_len, n) << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并复制数组到末尾（形成2n长度的数组），然后遍历这个数组统计连续1的最大长度。`current`变量记录当前连续1的长度，`max_len`记录最大值。最后输出时取`max_len`和n的最小值（避免超过数组总长度）。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：清清老大（来源：用户题解）**
* **亮点**：代码简洁，直接通过复制数组处理环形问题，遍历逻辑简单。
* **核心代码片段**：
    ```cpp
    for(int i = 0;i < n;i ++) {
        cin >> a[i];
        a[i + n] = a[i]; // 复制一遍字符串
    }
    for(int i = 0;i < 2 * n;i ++) {
        if(a[i] == 1) {
            sum ++;
        } else {
            maxsum = max(sum, maxsum);
            sum = 0;
        }
    }
    ```
* **代码解读**：
    > 第一段循环读取原数组并复制到末尾，形成2n长度的数组。第二段循环遍历这个数组，遇到1就累加当前长度（`sum`），遇到0就更新最大值（`maxsum`）并重置`sum`。这种方法将环形问题转化为线性问题，无需额外处理首尾相连，非常直观。
* 💡 **学习笔记**：复制数组是处理环形问题的“万能钥匙”，能将复杂的环形逻辑转化为简单的线性遍历。

**题解二：FP·荷兰猪（来源：用户题解）**
* **亮点**：不复制数组，直接统计首尾连续1的和，适合空间有限的场景。
* **核心代码片段**：
    ```cpp
    ll cnt2 = 0;
    rep(i,1,n) { // 统计开头连续1的长度
        if (f[i]==1) cnt2++;
        else break;
    }
    for (i=n;i>=1;i--) { // 统计末尾连续1的长度并累加
        if (f[i]==1) cnt2++;
        else break;
    }
    cout << max(maxv, cnt2) << endl;
    ```
* **代码解读**：
    > 第一段循环从前往后统计开头连续1的长度（`cnt2`），第二段循环从后往前统计末尾连续1的长度并累加到`cnt2`。最后比较数组内部最长连续1（`maxv`）和首尾和（`cnt2`），取最大值。这种方法节省空间，但需要注意首尾可能没有1的情况（此时`cnt2`为0）。
* 💡 **学习笔记**：若题目对空间要求较高，直接统计首尾连续1的和是更优的选择。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“破环成链”算法是如何工作的，我设计了一个8位像素风格的动画演示方案，让我们一起“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素时间环：寻找最长休息时间`

  * **核心演示内容**：展示环形数组如何通过复制变成线性数组，以及算法如何遍历统计最长连续1。动画中会用绿色像素块表示休息（1），红色像素块表示工作（0），并用数字实时显示当前连续长度和最大值。

  * **设计思路简述**：采用8位像素风（如FC游戏画面）是为了营造轻松的学习氛围；关键操作（如遇到1累加长度、遇到0重置）伴随“叮”或“咚”的音效，强化记忆；每更新一次最大值，用金色高光闪烁，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示原数组（5个像素块，绿色/红色），右侧显示复制后的数组（10个像素块，与原数组相同）。
          * 控制面板包含“单步”“自动播放”按钮和速度滑块（1x-5x）。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》的简单变奏）。

    2.  **复制数组动画**：
          * 原数组的像素块逐个“滑动”到右侧，形成复制后的数组（如原数组是[绿,红,绿,红,绿]，复制后变为[绿,红,绿,红,绿,绿,红,绿,红,绿]）。
          * 伴随“唰唰”的音效，提示数组复制完成。

    3.  **遍历统计过程**：
          * 一个黄色像素箭头从数组头部开始移动（每步0.5秒，可调速）。
          * 遇到绿色块（1）时，当前长度数字（如“1→2→3”）递增，箭头变为绿色，伴随“叮”音效。
          * 遇到红色块（0）时，当前长度重置为0，箭头变为红色，伴随“咚”音效，同时最大值数字（如“3”）可能更新，触发金色高光。

    4.  **最大值确定**：
          * 遍历完成后，最长连续1的像素块用金色边框高亮，最大值数字放大显示，播放“胜利”音效（如《超级玛丽》吃金币音）。

    5.  **交互控制**：
          * 单步模式：点击“单步”按钮，箭头移动一步，适合仔细观察每一步变化。
          * 自动播放：选择速度后，箭头自动遍历数组，适合整体观察流程。

  * **旁白提示**：
      * （复制数组时）“看！原数组复制到了后面，这样首尾就连起来啦～”
      * （遇到绿色块时）“当前休息时间+1！现在连续休息X小时～”
      * （遇到红色块时）“工作时间到！当前连续休息时间重置为0～”
      * （更新最大值时）“哦～发现了更长的休息时间！现在最大值是X小时～”

<visualization_conclusion>
通过这样的像素动画，我们不仅能直观看到“破环成链”的过程，还能清晰理解每一步如何统计连续休息时间。这种有趣的方式能让我们更快掌握算法核心！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考环形数组处理的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 环形数组处理不仅能解决本题，还常用于：
        - 环形字符串的最长重复子串（如寻找环形DNA序列的最长重复片段）。
        - 环形队列的最大子数组和（如计算连续多天的最大收益）。
        - 环形排列的最大相邻和（如圆桌会议中相邻嘉宾的最大互动值）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1886 滑动窗口最大值**（环形版拓展）
          * 🗣️ **推荐理由**：这道题需要处理滑动窗口在数组中的移动，若拓展为环形数组，能帮助你进一步理解环形结构的处理。
    2.  **洛谷 P1115 最大子段和**
          * 🗣️ **推荐理由**：此题是线性数组的最大子段和问题，若尝试改为环形数组，能巩固“破环成链”的应用。
    3.  **洛谷 P5016 龙虎斗**
          * 🗣️ **推荐理由**：此题涉及环形队列的模拟，能锻炼环形结构的逻辑处理能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分，但通过观察题解的差异，我们可以总结：处理环形问题时，“破环成链”是最直观的方法，而“首尾拼接统计”更节省空间。选择哪种方法取决于具体场景，新手建议先掌握“破环成链”，再尝试优化。
</insights_intro>

-----

<conclusion>
本次关于“Maximal Continuous Rest”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解环形数组的处理和连续统计问题。记住，多动手写代码、多调试，是掌握算法的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：169.83秒
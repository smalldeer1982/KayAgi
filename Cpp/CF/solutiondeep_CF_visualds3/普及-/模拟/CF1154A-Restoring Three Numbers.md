# 题目信息

# Restoring Three Numbers

## 题目描述

Polycarp has guessed three positive integers $ a $ , $ b $ and $ c $ . He keeps these numbers in secret, but he writes down four numbers on a board in arbitrary order — their pairwise sums (three numbers) and sum of all three numbers (one number). So, there are four numbers on a board in random order: $ a+b $ , $ a+c $ , $ b+c $ and $ a+b+c $ .

You have to guess three numbers $ a $ , $ b $ and $ c $ using given numbers. Print three guessed integers in any order.

Pay attention that some given numbers $ a $ , $ b $ and $ c $ can be equal (it is also possible that $ a=b=c $ ).

## 样例 #1

### 输入

```
3 6 5 4
```

### 输出

```
2 1 3
```

## 样例 #2

### 输入

```
40 40 40 60
```

### 输出

```
20 20 20
```

## 样例 #3

### 输入

```
201 101 101 200
```

### 输出

```
1 100 100
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Restoring Three Numbers 深入学习指南 💡

<introduction>
今天我们要一起解决的问题是“Restoring Three Numbers”。这道题需要我们根据四个给定的数（其中包含三个数的两两和及总和），还原出原来的三个数。通过分析题解和算法思路，我们会发现这其实是一道非常巧妙的数学题，关键在于找到隐藏的数学关系。让我们开始吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学推导与排序预处理`

🗣️ **初步分析**：
解决这道题的关键在于发现四个给定数中的最大值一定是三个数的总和（即 \(a+b+c\)）。我们可以把这四个数想象成四个“线索”，其中最大的那个线索是“总钥匙”，能帮我们解开其他三个数的秘密。  

简单来说，数学推导的核心是：假设四个数排序后为 \(x_1 \leq x_2 \leq x_3 \leq x_4\)，那么 \(x_4\) 一定是 \(a+b+c\)（因为三个数的两两和都比总和小）。接着，通过 \(x_4 - x_1\) 可以得到 \(c\)（因为 \(x_1 = a+b\)，总和减去 \(a+b\) 就是 \(c\)），同理 \(x_4 - x_2 = b\)，\(x_4 - x_3 = a\)。  

- **题解思路**：所有优质题解都采用“排序后取最大值为总和”的思路，差异仅在于代码实现的简洁性（如直接排序或逐个找最大值）。  
- **核心难点**：如何快速确定哪个数是总和？通过观察，总和一定是最大的数，因此排序是最直接的解决方案。  
- **可视化设计**：我们将设计一个8位像素动画，用不同颜色的方块表示四个数，排序过程中方块从左到右移动，最大的方块（总和）会高亮为金色。计算差值时，金色方块分别“吃掉”其他三个方块，生成三个新的小方块（即 \(a, b, c\)），并伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁性、算法有效性等方面筛选出以下3道优质题解（均≥4星）：
</eval_intro>

**题解一：作者inoichi_lim**  
* **点评**：这道题解的思路非常直接——通过排序找到总和，然后计算差值。代码仅用10行就解决问题，变量命名简洁（`a[5]`存储输入），排序后直接输出结果。特别是注释“有SPJ，所以乱写也可以AC”体现了对题目特性的准确把握（输出顺序无关）。从实践角度看，代码极简且高效，适合直接用于竞赛。

**题解二：作者codemap**  
* **点评**：此题解用最简短的代码实现了核心逻辑。输入后直接排序，输出最大值与前三个数的差值。代码结构清晰，没有冗余操作，完美体现了“大道至简”的编程思想。对于初学者来说，这样的代码能很好地展示“排序预处理”的重要性。

**题解三：作者xsI666**  
* **点评**：此题解将代码模块化（`init()`输入、`solve()`排序、`output()`输出），结构工整。虽然代码量稍多，但函数分工明确，适合学习如何将复杂问题拆解为小步骤。特别是注释详细，解释了每个步骤的目的，对理解算法流程很有帮助。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们需要突破以下几个关键点：
</difficulty_intro>

1.  **关键点1**：如何确定哪个数是总和 \(a+b+c\)？  
    * **分析**：由于 \(a, b, c\) 都是正整数，两两和 \(a+b, a+c, b+c\) 一定小于总和 \(a+b+c\)（因为总和比任意两两和多一个正数）。因此，四个数中的最大值必然是总和。  
    * 💡 **学习笔记**：遇到“多个数包含总和与部分和”的问题时，最大值通常是总和。

2.  **关键点2**：如何推导 \(a, b, c\) 的表达式？  
    * **分析**：假设总和为 \(S = a+b+c\)，两两和分别为 \(x_1=a+b\)，\(x_2=a+c\)，\(x_3=b+c\)。则 \(S - x_1 = c\)（因为 \(S - (a+b) = c\)），同理 \(S - x_2 = b\)，\(S - x_3 = a\)。  
    * 💡 **学习笔记**：通过减法消元，用总和减去两两和即可得到第三个数。

3.  **关键点3**：如何高效处理输入的无序数据？  
    * **分析**：输入的四个数是乱序的，直接排序后取最大值是最简便的方法（时间复杂度 \(O(1)\)，因为只有4个数）。  
    * 💡 **学习笔记**：排序是处理无序数据的“万能钥匙”，尤其当数据量较小时。

### ✨ 解题技巧总结
- **预处理排序**：遇到无序数据时，先排序能快速定位关键值（如最大值）。  
- **数学推导优先**：当问题涉及多个数的和与部分和时，通过代数运算推导表达式是关键。  
- **代码简洁性**：能简则简，避免冗余操作（如本题无需复杂条件判断，排序后直接计算）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，选择最简洁、高效的代码作为通用实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了inoichi_lim和codemap的题解思路，通过排序快速找到总和，计算差值得到结果。代码极简且高效，适合直接学习。  
* **完整核心代码**：  
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int a[4];
        cin >> a[0] >> a[1] >> a[2] >> a[3];
        sort(a, a + 4); // 排序后，a[3]是总和
        cout << a[3] - a[0] << " " << a[3] - a[1] << " " << a[3] - a[2] << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
    代码首先读取四个数存入数组 `a`，然后排序（从小到大）。排序后，最大的数 `a[3]` 即为总和 \(a+b+c\)。通过 `a[3] - a[0]` 得到 \(c\)（因为 \(a[0]\) 是最小的两两和 \(a+b\)），同理得到 \(b\) 和 \(a\)，最后输出结果。

---

<code_intro_selected>
接下来，我们赏析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者inoichi_lim**  
* **亮点**：代码极简，直接排序后输出结果，没有冗余步骤。  
* **核心代码片段**：  
    ```cpp
    cin>>a[1]>>a[2]>>a[3]>>a[4];
    sort(a+1,a+5);
    cout<<a[4]-a[1]<<' '<<a[4]-a[2]<<' '<<a[4]-a[3];
    ```
* **代码解读**：  
    输入四个数存入数组 `a[1]~a[4]`，排序后 `a[4]` 是总和。输出 `a[4] - a[1]`（\(c\)）、`a[4] - a[2]`（\(b\)）、`a[4] - a[3]`（\(a\)）。这里用数组下标从1开始，符合部分竞赛选手的习惯。  
* 💡 **学习笔记**：数组下标选择灵活，但需保持一致性，避免越界错误。

**题解二：作者codemap**  
* **亮点**：代码仅7行，极致简洁，完美展示了“排序+数学推导”的核心逻辑。  
* **核心代码片段**：  
    ```cpp
    int a[5];
    cin>>a[1]>>a[2]>>a[3]>>a[4];
    sort(a+1,a+5);
    cout<<a[4]-a[1]<<" "<<a[4]-a[2]<<" "<<a[4]-a[3];
    ```
* **代码解读**：  
    输入四个数后排序，直接利用最大值（`a[4]`）与前三个数的差值计算结果。代码没有多余变量，逻辑一目了然。  
* 💡 **学习笔记**：简洁的代码往往更易维护，也更能体现算法本质。

**题解三：作者xsI666**  
* **亮点**：代码模块化，函数分工明确，适合学习如何组织代码结构。  
* **核心代码片段**：  
    ```cpp
    inline void solve() {
        sort(x + 1, x + 1 + 4);
    }
    inline void output() {
        printf("%d %d %d\n", x[4] - x[1], x[4] - x[2], x[4] - x[3]);
    }
    ```
* **代码解读**：  
    `solve()` 函数负责排序，`output()` 函数负责输出结果。这种模块化设计将“输入-处理-输出”分离，提高了代码的可读性和复用性。  
* 💡 **学习笔记**：复杂问题可通过函数拆分，让代码结构更清晰。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“排序找总和+计算差值”的过程，我们设计一个8位像素风格的动画，让算法“动起来”！
</visualization_intro>

  * **动画演示主题**：`像素数独大冒险`（复古FC风格）  
  * **核心演示内容**：四个数的排序过程，以及如何通过最大值生成 \(a, b, c\)。  
  * **设计思路简述**：采用8位像素风（如红白机的方块和简单颜色），用不同颜色区分“原始数”和“结果数”，排序时方块滑动到正确位置，计算差值时伴随音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：  
    1.  **场景初始化**：  
        - 屏幕左侧显示4个彩色像素方块（红、蓝、绿、黄），代表输入的四个数。  
        - 右侧是“排序轨道”和“结果展示区”，下方有“开始/暂停”“单步”“重置”按钮，速度滑块（0.5x-2x）。  
        - 播放8位风格的轻快背景音乐（类似《超级玛丽》的开场曲）。  

    2.  **排序过程演示**：  
        - 点击“开始”，四个方块开始在轨道上滑动排序。每个方块顶部显示数值（如“3”“6”“5”“4”）。  
        - 排序时，较小的方块逐渐向左移动，较大的向右，最终排列成“4”“5”“6”“3”？不，正确排序是“3”“4”“5”“6”（假设输入是样例1的3、6、5、4）。  
        - 最大的方块（“6”）在排序完成后变为金色，并闪烁，旁白提示：“看！最大的数就是三个数的总和 \(a+b+c\)！”  

    3.  **计算差值生成 \(a, b, c\)**：  
        - 金色方块（总和）依次与前三个方块碰撞：  
          - 碰撞第一个方块（“3”）：金色方块“吃掉”它，生成一个绿色小方块，显示“6-3=3”（即 \(c=3\)），伴随“叮”的音效。  
          - 碰撞第二个方块（“4”）：生成蓝色小方块，显示“6-4=2”（即 \(b=2\)）。  
          - 碰撞第三个方块（“5”）：生成红色小方块，显示“6-5=1”（即 \(a=1\)）。  
        - 最终结果区展示“2 1 3”，与样例1输出一致，播放胜利音效（类似《超级玛丽》吃金币）。  

    4.  **交互控制**：  
        - 单步模式：每点击一次“单步”，执行一个排序或计算步骤，适合仔细观察。  
        - 自动播放：选择速度后，动画自动完成，适合快速回顾。  

  * **旁白提示**：  
    - 排序时：“现在四个数要排队啦！小的数往左，大的数往右~”  
    - 金色方块高亮时：“最大的数就是总和 \(a+b+c\)，它是解开谜题的关键！”  
    - 碰撞生成结果时：“总和减去两两和，就能得到第三个数哦！比如 \(6-3=3\)，这就是 \(c\)！”  

<visualization_conclusion>
通过这样的像素动画，我们不仅能“看”到排序和计算的过程，还能在趣味中理解数学推导的逻辑。下次遇到类似问题，你也能像动画里的方块一样，快速找到答案啦！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“通过总和与部分和的关系推导原始数”。这种思路还能解决哪些问题呢？
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 已知多个数的总和与部分和，求原始数（如已知班级总分和各科总分，求各科平均分）。  
    - 处理无序数据时，排序是快速定位关键值的常用方法（如找最大值、中位数）。  
    - 数学推导中，减法消元是解决“和差问题”的重要工具（如已知两数之和与差，求两数）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1003 铺地毯**  
        * 🗣️ **推荐理由**：需要处理二维坐标的覆盖问题，排序思想能帮助快速定位覆盖区域，锻炼数据预处理能力。  
    2.  **洛谷 P1047 校门外的树**  
        * 🗣️ **推荐理由**：涉及区间覆盖和统计，通过排序处理区间端点，与本题的“排序找关键值”思路类似。  
    3.  **洛谷 P1217 回文数**  
        * 🗣️ **推荐理由**：需要生成回文数并验证其奇偶性，数学推导结合枚举，锻炼综合解题能力。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了他们的解题心得，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自作者inoichi_lim)**：“这题显然需要先排序，所以先用一个数组储存好。”  
> **点评**：作者的经验提醒我们，遇到无序数据时，排序是最直接的预处理方法。尤其是当数据量较小时（如本题只有4个数），排序的时间可以忽略不计，但能极大简化后续计算。这是竞赛中常用的“预处理技巧”，值得我们学习。

-----

<conclusion>
通过今天的分析，我们不仅掌握了“Restoring Three Numbers”的解法，还学会了如何通过排序和数学推导解决类似问题。记住，遇到问题先观察数据特点（比如最大值的特殊性），再结合数学推导，往往能快速找到答案。接下来，不妨试试推荐的拓展练习，巩固所学知识吧！期待你下次更精彩的解题之旅！💪
</conclusion>

---
处理用时：143.65秒
# 题目信息

# Candy Box (easy version)

## 题目描述

This problem is actually a subproblem of problem G from the same contest.

There are $ n $ candies in a candy box. The type of the $ i $ -th candy is $ a_i $ ( $ 1 \le a_i \le n $ ).

You have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $ 1 $ and two candies of type $ 2 $ is bad).

It is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.

Your task is to find out the maximum possible size of the single gift you can prepare using the candies you have.

You have to answer $ q $ independent queries.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.

## 说明/提示

In the first query, you can prepare a gift with two candies of type $ 8 $ and one candy of type $ 5 $ , totalling to $ 3 $ candies.

Note that this is not the only possible solution — taking two candies of type $ 4 $ and one candy of type $ 6 $ is also valid.

## 样例 #1

### 输入

```
3
8
1 4 8 4 5 6 3 8
16
2 1 3 3 4 3 4 4 1 3 2 2 2 4 1 1
9
2 2 4 4 4 7 7 7 7
```

### 输出

```
3
10
9
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Candy Box (easy version) 深入学习指南 💡

<introduction>
今天我们来一起分析“Candy Box (easy version)”这道C++编程题。这道题需要我们找到一种选糖果的方式，使得每种类型的糖果数量都不重复，同时总数量最大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决这道题的关键在于贪心算法的应用。贪心算法就像小朋友分糖果时，每次都先拿最多的那堆，这样最后能拿到最多的糖果总数。在本题中，我们需要优先处理数量多的糖果类型，并调整它们的数量，确保每一步选择的数量都是当前最优的（即不与之前选的数量重复，且尽可能大）。

- **题解思路与对比**：大部分题解的核心思路是统计每种糖果的数量，然后通过排序或桶计数的方式调整这些数量，使其互不重复。例如，有的题解直接排序后从大到小调整（如luo_shen的题解），有的题解用另一个桶记录每个数量出现的次数，再从大到小调整（如__HHX__的题解），后者时间复杂度更低（O(n) vs O(n log n)）。
- **核心算法流程**：首先统计每种糖果的数量（桶排序），然后通过调整这些数量，确保每个数量唯一且尽可能大。例如，排序后从最大的数量开始，每次取当前最大的可能值（不超过前一个数量-1），累加得到总和。
- **可视化设计**：我们将设计一个“像素糖果工厂”的动画，用不同颜色的像素块表示不同类型的糖果，通过堆叠高度表示数量。排序过程用像素块的滑动动画展示，调整数量时用颜色变化（如红色→橙色）表示数量减少，关键步骤（如发现重复数量、调整成功）伴随“叮”的音效，自动播放模式模拟贪心选择的全过程。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下3道优质题解（评分≥4星），供大家参考：
</eval_intro>

**题解一：作者luo_shen**
* **点评**：这道题解思路非常清晰，先通过桶排序统计每种糖果的数量，再从大到小排序，最后贪心调整数量。代码变量名（如`ans`、`k`）含义明确，边界处理（如`k`初始化为极大值，及时跳出循环）严谨。算法上通过排序和贪心调整，时间复杂度为O(n log n)，适合竞赛场景。亮点在于用`k`变量动态记录当前允许的最大数量，确保每一步选择都不重复。

**题解二：作者__HHX__**
* **点评**：此题解的优化思路很巧妙，用两个桶（`cnt`统计数量，`cnt2`统计各数量的出现次数）替代排序，时间复杂度降至O(n)。代码简洁高效，循环结构清晰，特别是`cnt2[i-1] += cnt2[i]-1`这一步，通过调整桶的计数来避免重复数量，是贪心策略的高效实现。亮点在于用桶计数替代排序，减少了时间开销。

**题解三：作者___Yang__**
* **点评**：此题解与luo_shen的思路一致，但代码更简洁。通过`cmp`函数实现降序排序，用`p`变量动态调整当前数量，逻辑直白易懂。变量名（如`ans`、`p`）符合习惯，手动清零数组避免了`memset`的超时问题，实践价值高。亮点在于代码的简洁性和对细节的处理（如手动清零）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了核心思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何统计每种糖果的数量？
    * **分析**：需要用“桶排序”思想，用数组`cnt`记录每种类型的糖果数量（下标为类型，值为数量）。例如，输入`1 4 8 4 5 6 3 8`时，`cnt[8]=2`（类型8出现2次），`cnt[4]=2`（类型4出现2次）等。
    * 💡 **学习笔记**：桶排序是统计频率的常用方法，适合处理数值范围明确的问题（本题中类型≤n）。

2.  **关键点2**：如何调整数量以避免重复？
    * **分析**：贪心策略是关键。排序后从大到小处理数量，每一步取当前允许的最大数量（即前一个数量-1和当前数量的较小值）。例如，若最大数量是5，下一个数量最多只能是4（若原数量≥4），否则取原数量。
    * 💡 **学习笔记**：贪心调整时，维护一个变量记录“当前允许的最大数量”，每一步取其与当前数量的较小值，确保不重复。

3.  **关键点3**：如何高效处理多组查询？
    * **分析**：多组查询时，需注意数组的清零。直接使用`memset`可能超时（如测试点27），因此优质题解通常用循环手动清零（如`for(int i=1;i<=n;i++) cnt[i]=0`）。
    * 💡 **学习笔记**：多组数据时，手动清零小范围数组比`memset`更高效，避免超时。

### ✨ 解题技巧总结
<summary_best_practices>
- **频率统计用桶数组**：当数值范围明确时（如本题类型≤n），用桶数组统计频率比`map`更高效（O(n) vs O(n log n)）。
- **贪心调整维护上限**：排序后从大到小处理，维护一个“当前允许的最大数量”变量（如`k`或`p`），每一步取该变量与当前数量的较小值，确保不重复。
- **多组清零手动循环**：手动循环清零小范围数组，避免`memset`在大数据量下的超时问题。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合了优质题解思路的通用核心实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了luo_shen和__HHX__的题解思路，采用桶排序统计数量，排序后贪心调整，兼顾清晰与高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 2e5 + 5;
    int cnt[MAXN]; // 桶数组，统计每种糖果的数量

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int q;
        cin >> q;
        while (q--) {
            int n;
            cin >> n;
            // 初始化桶数组
            for (int i = 1; i <= n; ++i) cnt[i] = 0;
            // 统计每种糖果的数量
            for (int i = 0; i < n; ++i) {
                int x;
                cin >> x;
                cnt[x]++;
            }
            // 按数量从大到小排序（仅处理非零数量）
            sort(cnt + 1, cnt + n + 1, greater<int>());
            int ans = 0;
            int max_allowed = INT_MAX; // 当前允许的最大数量
            for (int i = 1; i <= n; ++i) {
                if (cnt[i] == 0) break; // 后续无糖果，提前退出
                max_allowed = min(max_allowed, cnt[i]);
                ans += max_allowed;
                max_allowed--; // 下一个数量最多为当前-1
            }
            cout << ans << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先用桶数组`cnt`统计每种糖果的数量，然后排序（降序）。通过`max_allowed`变量维护当前允许的最大数量，初始为极大值。遍历排序后的`cnt`数组，每一步取`max_allowed`和当前数量的较小值累加到答案，然后`max_allowed`减1，确保下一个数量不重复。当遇到数量为0时提前退出，避免无效计算。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和关键思路。
</code_intro_selected>

**题解一：作者luo_shen**
* **亮点**：用`k`变量动态维护当前允许的最大数量，逻辑清晰，边界处理（如`k=0`时提前退出）严谨。
* **核心代码片段**：
    ```cpp
    sort(b+1,b+n+1,cmp);   // 按数量从大到小排序 
    int ans=0,k=2147483647; // k初始化为极大值
    for(int i=1;i<=n;i++){
        k--;
        k=min(k,b[i]);  // 取当前允许的最大数量
        ans=ans+k;
        if(!k) break;   // 无剩余数量，提前退出
    }
    ```
* **代码解读**：
    > 这段代码是贪心调整的核心。排序后，`k`初始为极大值（表示第一个数量可以取到原数量）。每一步`k--`表示下一个数量最多为当前`k-1`，然后取`k`和当前数量`b[i]`的较小值（确保不超过实际数量）。累加到`ans`后，若`k=0`说明后续无法再选，提前退出循环。
* 💡 **学习笔记**：用变量维护“当前允许的最大数量”是贪心算法的关键，每一步调整确保不重复且尽可能大。

**题解二：作者__HHX__**
* **亮点**：用`cnt2`桶统计各数量的出现次数，避免排序，时间复杂度O(n)，更高效。
* **核心代码片段**：
    ```cpp
    for(int i = n; i >= 1; i--) {
        if(cnt2[i]) {
            ans += i;
            cnt2[i - 1] += cnt2[i] - 1; // 将多余的数量转移到i-1的桶
        }
    }
    ```
* **代码解读**：
    > `cnt2[i]`表示恰好有i个糖果的类型数。从大到小遍历，若`cnt2[i]>0`，说明有`cnt2[i]`种类型的糖果数量为i。取其中1种（贡献i到答案），剩下的`cnt2[i]-1`种需要调整为i-1（因为i-1未被占用），所以将`cnt2[i-1]`增加`cnt2[i]-1`。例如，若有3种类型的数量都是5（`cnt2[5]=3`），则取1种贡献5，剩下2种调整为4（`cnt2[4] += 2`）。
* 💡 **学习笔记**：桶计数替代排序，通过调整桶的计数来避免重复，是时间复杂度优化的关键。

**题解三：作者___Yang__**
* **亮点**：代码简洁，变量名（如`p`）直观，手动清零避免超时。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1,cmp);
    int ans=0,p=2147483647; // p初始为极大值
    for(int i=1;i<=n;i++){
        p--; 
        p=min(p,a[i]); // 取当前允许的最大数量
        ans+=p;
        if(p==0)break; // 提前退出
    }
    ```
* **代码解读**：
    > 与luo_shen的思路一致，`p`变量维护当前允许的最大数量。排序后，每一步`p--`表示下一个数量最多为`p-1`，取`p`和当前数量`a[i]`的较小值累加到答案。若`p=0`则提前退出，避免无效计算。
* 💡 **学习笔记**：简洁的代码结构和清晰的变量名是竞赛编程的好习惯。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法的调整过程，我设计了一个“像素糖果工厂”的动画演示方案。让我们通过8位像素风格，“看”到糖果数量的统计、排序和调整全过程！
</visualization_intro>

  * **动画演示主题**：像素糖果工厂的“数量调整大作战”

  * **核心演示内容**：统计每种糖果的数量→按数量从大到小排序→贪心调整数量（确保不重复）→计算总数量。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色的像素块表示不同类型的糖果（如红色块代表类型1，蓝色块代表类型2），块的高度表示数量。通过滑动、颜色变化和音效，直观展示排序和调整过程，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：
          * 屏幕左侧展示“糖果工厂”背景（像素化的工厂建筑），右侧是“数量调整区”（网格状，每个格子代表一种数量）。
          * 控制面板：开始/暂停、单步、重置按钮；速度滑块（1-5倍速）；当前总数量显示区。
          * 播放8位风格的轻快背景音乐（类似《超级玛丽》的主题曲）。

    2.  **统计数量 (桶排序)**：
          * 输入糖果类型时，对应颜色的像素块从屏幕上方“掉落”到左侧的“类型区”，每掉落一个块，该类型的数量（像素数字）加1。例如，输入类型8时，红色块掉落，类型8的数量从0→1→2。

    3.  **排序动画 (降序排列)**：
          * 所有类型的像素块（按数量）从左到右滑动到“排序区”，数量高的块（如高度5的块）滑到最左边，数量低的滑到右边。滑动时伴随“唰唰”的音效，块的高度用像素条显示（如高度5的块由5个小方块堆叠）。

    4.  **贪心调整 (关键步骤)**：
          * 用黄色像素箭头指向当前处理的块（第一个块，数量最大）。箭头移动时，播放“叮”的音效。
          * 维护一个“当前允许的最大数量”的像素数字（初始为极大值，如∞）。每处理一个块，该数字减1（如∞→5→4→...）。
          * 若当前块的高度≥允许的最大数量，块的高度自动缩短到允许值（如原高度5，允许值4，则块缩短为4个小方块），颜色变为橙色（表示已调整）。
          * 总数量显示区的数字实时累加调整后的数量（如+4→总数量4）。

    5.  **结束与反馈**：
          * 所有块处理完成或允许数量为0时，总数量显示区用金色像素字放大，播放“胜利”音效（类似《超级玛丽》吃金币的旋律）。
          * 若中途允许数量为0，用红色像素字提示“无更多数量可选！”，播放短促的“提示”音效。

    6.  **交互控制**：
          * 单步模式：点击“单步”按钮，逐步执行统计、排序、调整步骤，适合仔细观察每一步变化。
          * 自动模式：点击“开始”按钮，算法自动运行，速度可调，适合整体观察流程。

  * **旁白提示 (像素气泡)**：
      * （统计阶段）“看！每种糖果的数量正在用像素块堆叠显示～”
      * （排序阶段）“现在，数量多的糖果块会滑到左边，像排队一样！”
      * （调整阶段）“黄色箭头指向的是当前处理的糖果块，允许的最大数量会逐渐减少哦～”
      * （结束阶段）“总数量算出来啦！这就是我们能选的最多糖果数～”

<visualization_conclusion>
通过这个像素动画，我们不仅能看到贪心算法的每一步操作，还能在趣味互动中理解数量调整的逻辑。下次遇到类似问题时，你也可以想象自己在操作这个“像素糖果工厂”，轻松找到最优解！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题的贪心策略后，我们可以将其迁移到其他需要“不重复数量”或“最大化总和”的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 贪心调整不重复数量：类似本题，当需要选择若干数（如频率、长度）且互不重复时，可优先处理大的数，调整其值为前一个数-1，确保总和最大。
      * 桶排序统计频率：适用于数值范围明确的统计问题（如统计出现次数、分数段人数）。
      * 多组数据清零技巧：手动循环清零小范围数组，避免`memset`超时。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1094 纪念品分组**
          * 🗣️ **推荐理由**：这道题需要将物品分组，每组总价值不超过上限，且组内物品数量不限。贪心策略（从大到小配对）与本题类似，可巩固贪心思维。
    2.  **洛谷 P1181 数列分段Section I**
          * 🗣️ **推荐理由**：题目要求将数列分成若干段，每段和不超过m，求最少段数。贪心选择尽可能长的段，与本题“尽可能多选”的思路一致。
    3.  **洛谷 P2240 部分背包问题**
          * 🗣️ **推荐理由**：经典贪心问题，按单位价值从高到低取物品，与本题“优先处理数量多的类型”的贪心策略类似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者thomas_zjl)**：“一开始用`memset`清零数组，结果#27测试点超时。后来改用循环手动清零，就通过了。”
>
> **点评**：这位作者的经验提醒我们，多组数据时，手动循环清零小范围数组比`memset`更高效。特别是当数组大小接近2e5时，`memset`的时间开销可能导致超时。这是竞赛编程中需要注意的细节！

-----

<conclusion>
本次关于“Candy Box (easy version)”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握贪心算法的应用，理解如何通过统计、排序和调整解决“不重复数量”问题。记住，多动手写代码、多调试，你会越来越熟练！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：148.03秒
# 题目信息

# Broken Keyboard

## 题目描述

Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning. For simplicity, we assume that Polycarp's keyboard contains $ 26 $ buttons (one for each letter of the Latin alphabet). Each button is either working fine or malfunctioning.

To check which buttons need replacement, Polycarp pressed some buttons in sequence, and a string $ s $ appeared on the screen. When Polycarp presses a button with character $ c $ , one of the following events happened:

- if the button was working correctly, a character $ c $ appeared at the end of the string Polycarp was typing;
- if the button was malfunctioning, two characters $ c $ appeared at the end of the string.

For example, suppose the buttons corresponding to characters a and c are working correctly, and the button corresponding to b is malfunctioning. If Polycarp presses the buttons in the order a, b, a, c, a, b, a, then the string he is typing changes as follows: a $ \rightarrow $ abb $ \rightarrow $ abba $ \rightarrow $ abbac $ \rightarrow $ abbaca $ \rightarrow $ abbacabb $ \rightarrow $ abbacabba.

You are given a string $ s $ which appeared on the screen after Polycarp pressed some buttons. Help Polycarp to determine which buttons are working correctly for sure (that is, this string could not appear on the screen if any of these buttons was malfunctioning).

You may assume that the buttons don't start malfunctioning when Polycarp types the string: each button either works correctly throughout the whole process, or malfunctions throughout the whole process.

## 样例 #1

### 输入

```
4
a
zzaaz
ccff
cbddbb
```

### 输出

```
a
z

bc
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Broken Keyboard 深入学习指南 💡

<introduction>
今天我们来一起分析“Broken Keyboard”这道C++编程题。这道题需要我们通过观察屏幕上的字符串，反推哪些键盘按键一定是正常工作的。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用` (属于“常见”分类中的“模拟”算法)

🗣️ **初步分析**：
> 解决“Broken Keyboard”这道题，关键在于模拟键盘按键的工作逻辑。简单来说，模拟就是“一步一步跟着题目描述的规则走”，就像我们玩像素游戏时，按照游戏规则移动角色一样。  
> 题目中，正常按键按一次出一个字符（如按a出a），故障按键按一次出两个字符（如按b出bb）。我们需要找出所有“一定正常”的按键，即这些按键在字符串中必须至少出现一次“单独出现”的情况（否则可能被故障按键覆盖）。  
> 核心思路是遍历字符串，检查每个字符是否是“落单”的：如果当前字符和下一个字符不同，说明它一定是正常按键按出来的；如果相同，则这两个字符可能是故障按键按出来的，跳过这两个字符继续检查。  
> 可视化设计时，我们可以用像素小人“逐个检查”字符串中的字符：遇到两个相同的字符时，像素小人跳过去（表示这两个可能是故障按键的结果）；遇到单独的字符时，用星星标记（表示这个按键一定正常）。同时，用8位像素音效（如“叮”）提示关键操作，增加趣味性。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星），它们的共同点是逻辑直白、代码简洁，且能准确解决问题：
</eval_intro>

**题解一：作者_tommysun_**  
* **点评**：这份题解的思路非常清晰——直接遍历字符串，遇到连续两个相同的字符就跳过（可能是故障按键的结果），否则标记该字符为正常。代码中`flag[26]`数组的命名直观（“标记正常按键”），循环处理简洁，边界条件（如`len<s.size()`）处理严谨。从实践角度看，代码可直接用于竞赛，是典型的“短平快”解法，适合新手学习。

**题解二：作者Clyfort**  
* **点评**：此题解巧妙使用`set`数据结构，自动完成去重和排序（题目要求按字母顺序输出），代码简洁且逻辑优雅。作者通过图示辅助解释遍历过程，帮助理解“跳过连续字符”的核心逻辑。算法复杂度为O(n)（n为字符串长度），效率很高，是值得借鉴的优化思路。

**题解三：作者夙愿扬**  
* **点评**：此题解用数组存储结果，手动排序去重，适合理解基础操作。作者特别强调“多测不清空，爆零两行泪”，提醒初始化变量的重要性，这对避免多组测试数据的错误非常实用。代码中的`c[m+1]='0'`小技巧（防止去重越界）体现了细节处理的严谨性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何判断“一定正常”的按键？**  
    * **分析**：正常按键的特点是“至少出现一次单独字符”。例如，若字符串中出现“a”，则a键一定正常（因为故障键无法只输出一个a）；若出现“aa”，则a键可能正常（按了两次）或故障（按了一次），无法确定。因此，遍历字符串时，遇到单独字符（s[i]≠s[i+1]）即可标记该字符为正常。  
    * 💡 **学习笔记**：正常按键的“证据”是至少一次“落单”，故障按键的“嫌疑”是连续两个相同字符（但无法确定，需排除）。

2.  **关键点2：如何正确遍历字符串？**  
    * **分析**：遍历过程中，若当前字符与下一个字符相同（s[i]==s[i+1]），需跳过这两个字符（i++），否则会重复处理。例如，字符串“zzaaz”中，前两个z是连续的，应跳过i=0和i=1，直接处理i=2。优质题解通常通过`i++`在循环中实现这一逻辑。  
    * 💡 **学习笔记**：遍历字符串时，“跳过连续字符”是避免重复判断的关键，需注意循环变量的递增方式（如i++或i+=2）。

3.  **关键点3：如何保证输出按字母顺序且无重复？**  
    * **分析**：题目要求输出按字典序排列的正常按键，且不能重复。优质题解中，有的用`set`自动排序去重（如Clyfort的题解），有的用数组存储后手动排序去重（如夙愿扬的题解）。两种方法各有优势，`set`更简洁，数组更基础。  
    * 💡 **学习笔记**：`set`是处理“去重+排序”的神器，适合快速实现；手动排序去重适合理解底层逻辑。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将问题转化为“找字符串中单独出现的字符”，忽略连续两个的情况。  
- **循环优化**：遇到连续字符时直接跳过（i++），减少不必要的判断。  
- **数据结构选择**：用`set`或数组存储结果，前者自动去重排序，后者适合基础练习。  
- **多测初始化**：多组测试数据时，务必初始化标记数组（如`memset(f,0,sizeof(f))`），避免前一次结果干扰。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，选择最简洁高效的实现作为通用核心代码。它结合了遍历、标记和`set`去重排序的优点，适合快速理解和应用。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了_tommysun_和Clyfort的题解思路，使用`set`自动去重排序，逻辑简洁高效。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    void solve() {
        string s;
        cin >> s;
        set<char> normal; // 用set自动去重并排序
        for (int i = 0; i < s.size(); ) {
            if (i + 1 < s.size() && s[i] == s[i + 1]) {
                i += 2; // 跳过连续两个字符（可能是故障键）
            } else {
                normal.insert(s[i]); // 单独字符一定是正常键
                i++;
            }
        }
        for (char c : normal) {
            cout << c;
        }
        cout << endl;
    }

    int main() {
        int T;
        cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取多组测试数据，对每组字符串`g`，用`set`存储正常按键。遍历字符串时，若当前字符与下一个字符相同（且存在下一个字符），则跳过这两个字符；否则将当前字符加入`set`（一定是正常键）。最后输出`set`中的字符（自动排序去重）。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，学习它们的亮点和思路：
</code_intro_selected>

**题解一：作者_tommysun_**  
* **亮点**：用布尔数组直接标记正常按键，逻辑直白，适合理解基础操作。  
* **核心代码片段**：
    ```cpp
    bool flag[26] = {0}; 
    for (int len = 0; len < s.size(); len++) {
        if (s[len] == s[len + 1]) { 
            len++; // 跳过连续两个字符
        } else {
            flag[s[len] - 'a'] = 1; // 标记正常键
        }
    }
    ```
* **代码解读**：  
  `flag`数组的下标对应字母（如`flag[0]`对应a），值为1表示该键正常。遍历字符串时，若当前字符与下一个相同（可能是故障键），则`len++`跳过下一个字符；否则标记当前字符为正常。这种方法直接利用数组下标映射字母，空间复杂度低（O(1)），适合处理固定数量的字母（26个）。  
* 💡 **学习笔记**：布尔数组是标记“存在性”的常用工具，简单高效。

**题解二：作者Clyfort**  
* **亮点**：用`set`自动去重排序，代码简洁优雅，避免手动处理排序和去重。  
* **核心代码片段**：
    ```cpp
    set<char> ans;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] != s[i + 1]) {
            ans.insert(s[i]); // 插入set自动去重排序
        } else {
            i++; // 跳过下一个字符
        }
    }
    ```
* **代码解读**：  
  `set`的特性是元素唯一且自动按升序排列。当遇到单独字符时，插入`set`；遇到连续字符时，跳过下一个字符（`i++`）。最后遍历`set`即可输出按字典序排列的正常键。这种方法利用STL容器简化了代码，体现了“用对数据结构，代码更简洁”的思想。  
* 💡 **学习笔记**：`set`适合处理“去重+排序”的需求，是STL中非常实用的工具。

**题解三：作者夙愿扬**  
* **亮点**：手动排序去重，适合理解底层逻辑，提醒多测初始化的重要性。  
* **核心代码片段**：
    ```cpp
    char c[510];
    int m = 0;
    for (int j = 0; j <= s.size() - 1; j++) {
        if (s[j] == s[j + 1]) j++;
        else c[++m] = s[j]; // 存储单独字符
    }
    sort(c + 1, c + 1 + m); // 排序
    for (int j = 1; j <= m; j++) {
        if (c[j] != c[j + 1]) printf("%c", c[j]); // 去重输出
    }
    ```
* **代码解读**：  
  用数组`c`存储所有单独字符，排序后遍历，通过比较相邻元素去重。`m=0`的初始化避免多组测试数据的干扰（“多测不清空，爆零两行泪”）。这种方法适合新手理解排序和去重的底层逻辑，是基础练习的好例子。  
* 💡 **学习笔记**：手动实现排序去重能加深对算法的理解，是进阶的重要步骤。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“遍历字符串找单独字符”的过程，我设计了一个“像素检查员”的复古游戏动画。让我们一起“看”算法如何工作！
</visualization_intro>

  * **动画演示主题**：`像素检查员的键盘修复任务`（8位像素风格，类似FC游戏）

  * **核心演示内容**：  
    像素检查员（一个戴眼镜的小方块）从字符串左端出发，逐个检查字符：遇到两个相同的字符时，跳过去（表示可能是故障键）；遇到单独字符时，用星星标记（表示一定是正常键）。最后，所有被标记的字符按顺序排列，组成“正常按键清单”。

  * **设计思路简述**：  
    采用8位像素风（红、绿、蓝等鲜艳色调）营造轻松氛围；“跳跃”和“标记”的动画强化关键操作记忆；音效提示（如“叮”）增加互动感。通过游戏化设计，让学习者直观看到“跳过连续字符”和“标记单独字符”的核心逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：  
        - 屏幕上方显示字符串（如“zzaaz”），每个字符用像素方块表示（黄色）。  
        - 左下角显示控制面板：开始/暂停、单步、重置按钮，速度滑块（1-5倍速）。  
        - 播放8位风格的轻快背景音乐（类似《超级玛丽》的简单旋律）。

    2.  **算法启动与数据初始化**：  
        - 像素检查员出现在字符串左端（字符'z'的位置），头顶显示“检查中...”。  
        - 下方显示“正常按键清单”（初始为空）。

    3.  **核心遍历过程 (单步/自动演示)**：  
        - **检查连续字符**：检查员走到第一个'z'（i=0），比较下一个字符（i=1也是'z'），头顶显示“连续字符，可能是故障键！”，然后跳跃到i=2的位置（跳过i=0和i=1），伴随“跳”的音效（短而轻的“噗”）。  
        - **标记单独字符**：检查员走到i=2的'a'（i=2），比较下一个字符（i=3是'a'），继续跳到i=4的'z'（i=4），比较下一个字符（无），头顶显示“单独字符，一定是正常键！”，用星星（闪烁的黄色像素点）标记'z'，并将'z'加入“正常按键清单”，伴随“叮”的音效。  
        - **变量同步**：屏幕右侧显示当前i的值（如i=0→i=2→i=4），用高亮框标记当前检查的字符。

    4.  **目标达成/结束状态**：  
        - 检查员走到字符串末尾（i≥s.size()），背景音乐停止，播放“胜利”音效（上扬的“啦~”）。  
        - “正常按键清单”显示所有被标记的字符（如“z”），按字典序排列。

    5.  **交互控制**：  
        - 学习者可通过“单步”按钮逐帧查看检查过程，或调整速度滑块（如0.5倍速慢放）仔细观察。  
        - 点击“重置”按钮，字符串和检查员回到初始状态，重新开始。

  * **旁白提示**：  
    - （检查连续字符时）“看！这两个字符相同，可能是故障键按出来的，我们跳过去~”  
    - （标记单独字符时）“这个字符是单独的，说明按键一定正常！用星星记下来~”  
    - （结束时）“任务完成！这些就是一定正常的按键啦~”

<visualization_conclusion>
通过这个像素动画，我们不仅能“看”到算法如何遍历字符串，还能在游戏化的互动中理解“跳过连续字符”和“标记单独字符”的核心逻辑。是不是更直观了？😊
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解了本题的“模拟+标记”思路后，我们可以将其迁移到更多字符串处理问题中。以下是一些相似场景和推荐练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **连续字符处理**：类似本题的“跳过连续字符”，可用于判断字符串是否由重复子串组成（如LeetCode 459题）。  
    - **标记存在性**：用数组或集合标记“出现过的元素”，可用于解决“找唯一出现一次的数”（如LeetCode 136题）。  
    - **遍历与跳跃**：在处理“有效括号”（如LeetCode 20题）或“删除相邻重复项”（如LeetCode 1047题）时，也需要类似的遍历跳跃逻辑。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1308** - `统计单词数`  
        * 🗣️ **推荐理由**：需要遍历字符串，处理连续字符（空格），并标记单词位置，与本题的遍历逻辑类似。  
    2.  **洛谷 P1125** - `笨小猴`  
        * 🗣️ **推荐理由**：统计字符出现次数后，判断是否为质数，需要用数组标记出现次数，与本题的“标记正常键”思路相似。  
    3.  **洛谷 P1598** - `垂直柱状图`  
        * 🗣️ **推荐理由**：统计字符出现次数并可视化，需要遍历字符串标记次数，适合练习数组的使用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者们的经验分享对我们很有启发，这里摘录并总结：
</insights_intro>

> **参考经验 (来自作者夙愿扬)**：“多测不清空，爆零两行泪”。在多组测试数据中，一定要初始化变量（如本题中的`m=0`或`flag数组`），否则前一次的数据会干扰当前结果。  
> **点评**：这个经验非常实用！在编程中，多组测试数据的初始化是常见的“坑”，尤其是数组和计数器。每次处理新数据前，手动清零或重新初始化变量，能避免很多奇怪的错误。例如本题中，如果不初始化`flag数组`，前一组的标记可能残留，导致输出错误。

-----

<conclusion>
本次关于“Broken Keyboard”的C++解题分析就到这里。希望这份指南能帮助你理解模拟算法的核心，掌握字符串遍历和标记的技巧。记住，编程的关键是“多思考、多练习”，遇到问题时可以像像素检查员一样，一步步仔细检查！下次见~ 💪
</conclusion>

---
处理用时：177.08秒
# 题目信息

# Two Regular Polygons

## 题目描述

You are given two integers $ n $ and $ m $ ( $ m < n $ ). Consider a convex regular polygon of $ n $ vertices. Recall that a regular polygon is a polygon that is equiangular (all angles are equal in measure) and equilateral (all sides have the same length).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1312A/95b1bef3403a130cb1532da909306b47c3e9056c.png) Examples of convex regular polygons Your task is to say if it is possible to build another convex regular polygon with $ m $ vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon.

You have to answer $ t $ independent test cases.

## 说明/提示

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1312A/0982568e883452a4972ef18c303a083c1c1e1608.png) The first test case of the example It can be shown that the answer for the second test case of the example is "NO".

## 样例 #1

### 输入

```
2
6 3
7 3```

### 输出

```
YES
NO```

# AI分析结果



---
# 💡 Kay的C++算法解析：Two Regular Polygons 深入学习指南 💡

<introduction>
今天我们来一起分析“Two Regular Polygons”这道C++编程题。这道题看似简单，但背后涉及正多边形的几何特性和数学规律。本指南将帮助大家理解题目核心、掌握解题关键，并通过生动的像素动画直观感受算法逻辑。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学规律应用` (属于“数学”分类)

🗣️ **初步分析**：
解决这道题的关键在于理解正多边形顶点的分布规律。简单来说，正多边形的顶点均匀分布在其外接圆上，相邻顶点之间的圆心角相等（例如，正n边形的圆心角为360°/n）。题目要求判断是否存在一个正m边形（m < n），其顶点全部是正n边形的顶点且中心重合。

- **题解思路**：所有优质题解均指出，当且仅当n是m的倍数时（即n % m == 0），答案为“YES”。这是因为正m边形的顶点需要均匀分布在正n边形的顶点上，相当于从正n边形中每隔k个顶点选取一个（k = n/m），这样才能保证正m边形的顶点间距相等。若n不是m的倍数，则无法均匀选取顶点，导致无法形成正m边形。
- **核心难点**：理解“顶点均匀分布”的数学条件，即n必须是m的倍数。
- **可视化设计**：我们将设计一个8位像素风格的动画，展示正n边形和正m边形的顶点分布。当n是m的倍数时，动画会高亮每隔k个顶点选取的过程，并伴随“叮”的音效；否则，会显示顶点无法均匀分布的冲突。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑直白、解释到位且代码简洁，获得4星以上评分：
</eval_intro>

**题解一：作者：立风yu**
* **点评**：此题解以“画图找规律”为切入点，直接点明n是m倍数的关键条件。代码简洁规范（变量名t、n、m含义明确），边界处理严谨（直接处理t组输入）。其通过图形示例辅助理解的方式，非常适合初学者快速抓住核心。

**题解二：作者：do_while_false**
* **点评**：此题解结合具体图形（正六边形与正三角形、正五边形与正三角形）对比，直观展示了“n是m倍数”时顶点均匀分布的规律。代码使用标准输入输出，结构清晰，适合竞赛环境直接使用。

**题解三：作者：Andrewzdm**
* **点评**：此题解从数学角度推导，通过中心角的倍数关系（360°/m 需是360°/n的整数倍）严格证明了n%m==0的条件。代码逻辑简洁，数学推导与代码实现紧密结合，适合希望深入理解原理的学习者。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们需要突破以下核心难点，并掌握对应的解题策略：
</difficulty_intro>

1.  **关键点1：如何理解“顶点均匀分布”的条件？**
    * **分析**：正m边形的顶点必须是正n边形顶点的子集，且相邻顶点在正n边形中的间隔相等。例如，正6边形（n=6）中选正3边形（m=3），需要每隔6/3=2个顶点选一个（顶点0→2→4→0），这样相邻顶点的圆心角均为2*(360°/6)=120°，符合正三角形的圆心角要求。若n不是m的倍数（如n=7，m=3），则无法找到这样的均匀间隔。
    * 💡 **学习笔记**：正多边形顶点均匀分布的本质是圆心角的整数倍关系，这等价于n是m的倍数。

2.  **关键点2：如何验证条件的普适性？**
    * **分析**：通过多个例子验证（如n=8，m=4；n=9，m=3），发现当n%m==0时，总能构造符合要求的正m边形；反之则无法构造。这种规律适用于所有正多边形（m≥3，n>m）。
    * 💡 **学习笔记**：数学规律的普适性可通过多例验证，避免特例误导。

3.  **关键点3：如何将数学条件转化为代码？**
    * **分析**：代码只需读取t组n和m，判断n%m是否为0。注意输入输出的效率（使用cin/cout或scanf/printf均可），因题目数据范围小，无需优化。
    * 💡 **学习笔记**：简单问题的代码实现需注重简洁性和可读性。

### ✨ 解题技巧总结
- **图形辅助分析**：通过画图观察顶点分布规律，快速发现数学条件（如正六边形与正三角形的顶点关系）。
- **数学推导验证**：从圆心角的倍数关系出发，严格证明条件的正确性，增强结论的可信度。
- **边界条件处理**：题目明确m < n，无需额外处理m≥n的情况。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解后提炼的通用核心代码，逻辑简洁且适用于所有测试用例。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用最简洁的逻辑实现，适合竞赛环境直接使用。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int t, n, m;
        cin >> t; // 读取测试用例数
        while (t--) {
            cin >> n >> m;
            // 判断n是否是m的倍数
            if (n % m == 0) {
                cout << "YES" << endl;
            } else {
                cout << "NO" << endl;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取测试用例数t，然后对每组输入的n和m，判断n是否能被m整除。若能，则输出“YES”，否则输出“NO”。核心逻辑仅需一个条件判断，非常高效。

---
<code_intro_selected>
接下来，我们剖析部分优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者：立风yu**
* **亮点**：代码简洁规范，变量名清晰，直接体现输入输出逻辑。
* **核心代码片段**：
    ```cpp
    int main(){
        int t,n,m;
        cin>>t;
        for (int i=1;i<=t;i++){
            cin>>n>>m;
            if (n%m==0)cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
        }
        return 0;
    }
    ```
* **代码解读**：这段代码使用for循环处理t组数据，每次读取n和m后判断n%m是否为0。变量名t（测试用例数）、n、m含义明确，符合编程规范。循环结构简单，适合初学者理解。
* 💡 **学习笔记**：简单问题的代码应追求“极简”，避免冗余操作。

**题解二：作者：Andrewzdm**
* **亮点**：从数学角度推导条件，代码与数学推导紧密结合。
* **核心代码片段**：
    ```cpp
    int main() {
        int t;
        cin >> t;
        while(t--) {
            int n, m;
            cin >> n >> m;
            if(n % m == 0)
                cout << "YES" << endl;
            else
                cout << "NO" << endl;
        }
        return 0;
    }
    ```
* **代码解读**：使用while循环处理测试用例，逻辑与for循环类似，但更简洁。条件判断直接对应数学结论（n%m==0），体现了“代码是数学逻辑的直接翻译”这一思想。
* 💡 **学习笔记**：数学推导是编写高效代码的基础，需注重逻辑与代码的对应关系。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“n是m倍数时顶点均匀分布”的规律，我们设计了一个8位像素风格的动画，让大家“看”到正多边形顶点的选取过程！
</visualization_intro>

  * **动画演示主题**：`像素多边形探险家`（8位复古风格）

  * **核心演示内容**：展示正n边形（黑色）和正m边形（红色）的顶点分布。当n是m的倍数时，红色顶点均匀分布在黑色顶点上；否则，红色顶点无法均匀分布。

  * **设计思路简述**：采用8位像素风（如FC游戏画面），通过颜色高亮和音效强化关键操作。例如，选取顶点时的“叮”声、均匀分布时的“胜利”音效，帮助学习者记忆规律。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕中央显示一个像素化的外接圆（用细虚线表示），周围均匀分布n个黑色像素点（正n边形的顶点）。
          * 控制面板包含“开始/暂停”“单步”“重置”按钮，以及速度滑块（1x-5x）。
          * 播放8位风格的轻快背景音乐（如《超级马里奥》的简单变奏）。

    2.  **算法启动**：
          * 输入n=6，m=3（示例1），点击“开始”。黑色顶点开始闪烁，提示正n边形的存在。
          * 红色顶点开始从第一个顶点（0号）出发，每隔k=6/3=2个顶点选取一个（0→2→4→0）。每个红色顶点出现时，伴随“叮”的音效，并用黄色箭头标记选取路径。

    3.  **关键步骤演示**：
          * **均匀分布（n%m==0）**：红色顶点全部落在黑色顶点上，形成正m边形。此时，红色多边形轮廓用粗线绘制，播放“胜利”音效（如《超级玛丽》吃金币声），并显示“成功！”文字气泡。
          * **非均匀分布（n=7，m=3）**：尝试每隔k=2个顶点选取（0→2→4→6→1），发现第4个红色顶点（1号）与前三个顶点的间距不一致（圆心角分别为2*360°/7≈102.86°，而正三角形需要120°）。此时，红色顶点闪烁红色警告，播放“错误”音效（短促的“叮-咚”），并显示“无法均匀分布！”文字气泡。

    4.  **交互控制**：
          * 单步模式下，学习者可逐帧查看顶点选取过程，观察间隔是否一致。
          * 自动播放模式下，算法会快速演示多组测试用例（如n=8,m=4；n=9,m=3；n=5,m=2），对比成功与失败的场景。

  * **旁白提示**：
      * （选取顶点时）“看！红色顶点每隔2个黑色顶点选一个，这样它们的间距就相等啦~”
      * （非均匀分布时）“这里的间隔不一样，所以无法形成正三角形哦！”
      * （成功时）“恭喜！这样的正m边形就诞生啦~”

<visualization_conclusion>
通过这个像素动画，我们能直观看到“n是m的倍数”如何保证顶点均匀分布，从而轻松理解题目的核心规律！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的数学规律后，我们可以将其迁移到更多多边形相关的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 正多边形的顶点分布问题（如判断能否在正n边形中构造正k边形）。
      * 圆上点的均匀分布问题（如判断能否将圆上n个点分成m组，每组点间距相等）。
      * 周期性规律判断（如判断数组是否可被分成m个等长子数组）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5736** - `【深基7.例2】质数筛`
          * 🗣️ **推荐理由**：练习数学规律的应用，判断数的整除性。
    2.  **洛谷 P1046** - `陶陶摘苹果`
          * 🗣️ **推荐理由**：基础输入输出与条件判断，巩固代码实现能力。
    3.  **洛谷 P1423** - `小玉在游泳`
          * 🗣️ **推荐理由**：练习循环与条件判断的结合，提升逻辑思维。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了通过画图辅助理解的经验，这对我们很有启发：
</insights_intro>

> **参考经验 (来自作者：立风yu)**：“刚开始我也不太确定条件，后来画了正六边形和正三角形的图，发现顶点正好能均匀选取，才想到n是m的倍数这个规律。”
>
> **点评**：画图是理解几何问题的重要工具！通过直观观察图形，能快速发现隐藏的数学规律。遇到类似问题时，不妨先画几个例子试试看~

-----

<conclusion>
本次关于“Two Regular Polygons”的C++解题分析就到这里。希望大家通过这份指南，不仅掌握了这道题的解法，更学会了如何通过观察、推导和可视化理解数学规律。编程的乐趣在于探索，下次我们再一起挑战新的问题！💪
</conclusion>

---
处理用时：122.20秒
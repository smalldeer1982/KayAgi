# 题目信息

# Dead Pixel

## 题目描述

Screen resolution of Polycarp's monitor is $ a \times b $ pixels. Unfortunately, there is one dead pixel at his screen. It has coordinates $ (x, y) $ ( $ 0 \le x < a, 0 \le y < b $ ). You can consider columns of pixels to be numbered from $ 0 $ to $ a-1 $ , and rows — from $ 0 $ to $ b-1 $ .

Polycarp wants to open a rectangular window of maximal size, which doesn't contain the dead pixel. The boundaries of the window should be parallel to the sides of the screen.

Print the maximal area (in pixels) of a window that doesn't contain the dead pixel inside itself.

## 说明/提示

In the first test case, the screen resolution is $ 8 \times 8 $ , and the upper left pixel is a dead pixel. Here you can see one of two possible layouts of the maximal window.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1315A/cb58b5325ebfab8c891df37e110ee05ad36ccf9e.png)

## 样例 #1

### 输入

```
6
8 8 0 0
1 10 0 3
17 31 10 4
2 1 0 0
5 10 3 9
10 10 4 8```

### 输出

```
56
6
442
1
45
80```

# AI分析结果



---
# 💡 Kay的C++算法解析：Dead Pixel 深入学习指南 💡

<introduction>
今天我们来一起分析“Dead Pixel”这道C++编程题。这道题需要我们在屏幕上找到不包含坏点的最大矩形区域。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学分析与几何枚举 (属于“数学”类算法应用)

🗣️ **初步分析**：
> 解决“Dead Pixel”问题的关键在于通过几何分析，找出不包含坏点的最大矩形区域。数学分析在这里的作用是，通过观察坏点的位置，枚举所有可能的最大矩形候选区域，计算它们的面积并取最大值。简单来说，就像在蛋糕上切一块最大的不包含霉点的部分，我们需要看看霉点周围四个方向的“大块”哪个最大。

- **题解思路与核心难点**：所有题解的核心思路一致——坏点会将屏幕分成上下左右四个可能的矩形区域（例如，坏点左侧的最大矩形、右侧的最大矩形等），只需要计算这四个区域的面积并取最大值。核心难点是正确识别这四个区域并准确计算它们的面积（注意坐标从0开始的边界处理）。
- **核心算法流程**：计算四个候选区域的面积：①坏点左侧的最大矩形（宽度为x，高度为b）；②坏点右侧的最大矩形（宽度为a-x-1，高度为b）；③坏点上方的最大矩形（高度为y，宽度为a）；④坏点下方的最大矩形（高度为b-y-1，宽度为a）。取这四个值的最大值。
- **可视化设计**：我们将设计一个8位像素风格的动画，用不同颜色标记坏点和四个候选区域，通过闪烁和面积数值对比，直观展示哪个区域最大。动画中会有“叮”的音效提示每个区域的计算，最终用胜利音效突出最大区域。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（≥4星）：
</eval_intro>

**题解一：作者：dingcx**
* **点评**：这份题解思路非常清晰，通过画图直观展示了坏点分割出的四个区域，并明确给出了公式推导。代码简洁规范（如使用`max`函数直接计算最大值），变量名符合逻辑，边界处理准确（考虑坐标从0开始）。其核心公式`max(max(x,n-x-1)*m,max(y,m-y-1)*n)`直接抓住了问题本质，是值得学习的经典解法。

**题解二：作者：流绪**
* **点评**：此题解在正确性上更严谨，使用`long long`类型避免了大数值溢出问题（例如当a和b很大时，乘积可能超过int范围）。代码结构清晰，四个区域的计算明确，适合作为新手学习的参考。其“结论题！”的总结点明了问题的关键，即通过枚举四个区域快速求解。

**题解三：作者：Xdl_rp**
* **点评**：此题解逻辑直接，通过明确的条件描述（“整个矩阵在坏点的上方/下方/左边/右边”）帮助读者理解候选区域的来源。代码中使用`max({ans1, ans2, ans3, ans4})`简洁地求出最大值，代码风格规范，适合竞赛场景快速实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何准确定位四个候选区域？**
    * **分析**：坏点$(x,y)$将屏幕横向分割为两部分（左半部分宽度$x$，右半部分宽度$a-x-1$），纵向分割为两部分（上半部分高度$y$，下半部分高度$b-y-1$）。最大矩形必定是这四个部分中某一个的“全屏”延伸（例如，左半部分的高度是屏幕的总高度$b$，所以面积是$x*b$）。优质题解通过画图或几何分析明确了这一点。
    * 💡 **学习笔记**：遇到几何分割问题时，画图是最直观的分析方法，能帮助快速定位候选区域。

2.  **关键点2：如何处理坐标从0开始的边界？**
    * **分析**：屏幕的列从0到$a-1$，行从0到$b-1$，因此坏点右侧的宽度是$a-x-1$（例如，当$x=a-1$时，右侧宽度为0），下方的高度是$b-y-1$。部分题解（如sycqwq）尝试通过$x+=1$调整坐标，但可能引入错误（如$x=0$时$x-1$为负数），正确的做法是直接使用原始坐标计算。
    * 💡 **学习笔记**：处理0-based坐标时，要注意边界值的计算（如“右侧宽度=总宽度-坏点列号-1”）。

3.  **关键点3：如何避免整数溢出？**
    * **分析**：当$a$和$b$较大时（例如$1e5$），$a*b$可能超过int的范围（约2e9）。流绪的题解使用`long long`类型存储面积，避免了溢出问题，这是竞赛中的重要细节。
    * 💡 **学习笔记**：涉及大数相乘时，优先使用`long long`类型（C++中用`%lld`输出）。

### ✨ 解题技巧总结
<summary_best_practices>
- **几何问题画图法**：通过画图直观展示坏点分割出的区域，快速定位候选解。
- **边界条件优先检查**：处理0-based坐标时，重点验证边界值（如坏点在角落的情况）。
- **数据类型防溢出**：涉及大数相乘时，使用`long long`类型确保结果正确。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了dingcx和流绪的题解思路，既保证了简洁性，又通过`long long`避免溢出，适合作为通用实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int T;
        cin >> T;
        while (T--) {
            int a, b, x, y;
            cin >> a >> b >> x >> y;
            // 计算四个区域的面积
            long long area1 = 1LL * x * b;          // 坏点左侧
            long long area2 = 1LL * (a - x - 1) * b; // 坏点右侧
            long long area3 = 1LL * y * a;          // 坏点上方
            long long area4 = 1LL * (b - y - 1) * a; // 坏点下方
            // 取最大值
            cout << max({area1, area2, area3, area4}) << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入数据组数T，然后对每组数据计算四个候选区域的面积（使用`1LL *`强制转换为long long避免溢出），最后用`max`函数取最大值输出。核心逻辑是通过几何分析得到四个区域的面积公式，并取最大值。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段，点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：作者：dingcx**
* **亮点**：公式简洁，直接通过`max(max(x,a-x-1)*b, max(y,b-y-1)*a)`计算最大值，抓住了问题本质。
* **核心代码片段**：
    ```cpp
    printf("%d\n", max(max(x,n-x-1)*m, max(y,m-y-1)*n));
    ```
* **代码解读**：
    > 这段代码的核心是利用`max(x, a-x-1)`得到坏点左右两侧的最大宽度，乘以高度b；同理`max(y, b-y-1)`得到上下两侧的最大高度，乘以宽度a。最终取这两个值的较大者，即为最大面积。例如，当坏点在左上角（x=0,y=0）时，`max(0, a-0-1)=a-1`，所以面积是`(a-1)*b`（如样例1中8×8屏幕，坏点(0,0)，面积7×8=56，与样例输出一致）。
* 💡 **学习笔记**：当问题存在对称性时（如左右、上下对称），可以通过`max`函数简化计算。

**题解二：作者：流绪**
* **亮点**：使用`long long`类型避免溢出，适合处理大数值输入。
* **核心代码片段**：
    ```cpp
    ll s1 = (a-x-1)*(b);
    ll s2 = (a)*(b-y-1);
    ll s3 = (a)*(y);
    ll s4 = (x)*b;
    s1 = max(s1, max(s2, max(s3, s4)));
    ```
* **代码解读**：
    > 这段代码明确计算了四个区域的面积：s1是坏点右侧的面积（宽度a-x-1，高度b），s2是坏点下方的面积（宽度a，高度b-y-1），s3是坏点上方的面积（宽度a，高度y），s4是坏点左侧的面积（宽度x，高度b）。最后取四个值的最大值。使用`ll`（long long的别名）确保了大数相乘时不会溢出。
* 💡 **学习笔记**：竞赛中遇到可能溢出的情况，优先使用`long long`类型。

**题解三：作者：Xdl_rp**
* **亮点**：代码结构清晰，四个区域的计算和最大值求解逻辑明确。
* **核心代码片段**：
    ```cpp
    int ans1 = (a - x - 1) * b;
    int ans2 = x * b;
    int ans3 = (b - y - 1) * a;
    int ans4 = y * a;
    int ans = max({ans1, ans2, ans3, ans4});
    ```
* **代码解读**：
    > 这段代码分别计算了坏点右侧（ans1）、左侧（ans2）、下方（ans3）、上方（ans4）的面积，然后通过`max({...})`取最大值。这种写法直观易懂，适合新手理解每个区域的来源。
* 💡 **学习笔记**：明确命名变量（如ans1、ans2）可以提高代码可读性，方便调试。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解如何找到不包含坏点的最大矩形，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素屏幕找最大窗口`（复古FC游戏风格）

  * **核心演示内容**：展示坏点位置，动态计算四个候选区域的面积，最终高亮最大的区域。

  * **设计思路简述**：采用8位像素风格（如FC红白机的方块画面），用不同颜色区分坏点（红色方块）和候选区域（蓝、绿、黄、紫），通过闪烁和面积数值对比，帮助学习者直观理解“四个区域中哪个最大”。音效（如“叮”声）强化关键操作记忆，游戏化的“过关”提示增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕显示一个a×b的像素网格（例如8×8），坏点用红色方块标记（坐标(x,y)）。
          * 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块。
          * 播放8位风格的轻快背景音乐（如《超级马里奥》的经典旋律）。

    2.  **计算四个区域**：
          * **左侧区域**：屏幕左侧x列（宽度x）整体变蓝，显示面积“x*b”（如x=0时，面积0），伴随“叮”的音效。
          * **右侧区域**：屏幕右侧(a-x-1)列变绿，显示面积“(a-x-1)*b”，音效提示。
          * **上方区域**：屏幕上方y行变黄，显示面积“y*a”，音效提示。
          * **下方区域**：屏幕下方(b-y-1)行变紫，显示面积“(b-y-1)*a”，音效提示。

    3.  **对比找最大值**：
          * 四个区域同时闪烁，面积数值放大。最大的区域停止闪烁并高亮（如金色边框），播放上扬的“胜利”音效（如《超级马里奥》吃金币的声音）。
          * 屏幕顶部显示“最大面积：XXX”，与样例输出一致。

    4.  **交互控制**：
          * 学习者可通过“单步”按钮逐个查看区域计算，或“自动播放”观察完整流程（速度可调）。
          * 点击“重置”可更换输入数据（如样例中的其他测试用例），重新演示。

  * **旁白提示**：
      * （左侧区域出现时）“看！坏点左边的矩形宽度是x，高度是屏幕总高度b，面积是x*b。”
      * （最大值高亮时）“这个金色的区域就是最大的不包含坏点的矩形，它的面积是最大的！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能清晰看到四个区域的计算过程，还能在趣味互动中理解“为什么最大面积一定来自这四个区域”。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考几何枚举类问题的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“枚举候选区域”思路还可用于：
        - 计算矩阵中不包含障碍物的最大子矩阵（如洛谷P1506 拯救oibh总部）。
        - 寻找二维数组中满足条件的最大子数组（如和最大、元素全为1等）。
        - 处理屏幕分割问题（如多窗口布局中最大化某个窗口）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1387 最大正方形**
          * 🗣️ **推荐理由**：这道题需要在矩阵中找到最大的全1正方形，同样需要枚举可能的区域并计算，能巩固“枚举+几何分析”的解题思路。
    2.  **洛谷 P1506 拯救oibh总部**
          * 🗣️ **推荐理由**：此题要求计算最大的不包含障碍物的矩形面积，与本题思路类似，但需要处理更复杂的障碍物分布，适合拓展思维。
    3.  **洛谷 P2713 罗马游戏**
          * 🗣️ **推荐理由**：虽然是并查集问题，但其中的“分割区域”思想与本题的“找最大区域”有共通之处，可帮助理解不同算法的应用场景。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者的经验分享能帮助我们少走弯路，以下是值得借鉴的部分：
</insights_intro>

> **参考经验 (来自作者dingcx)**：“先画一个图：（中间那个黑的是坏的）根据贪心，很容易得到：可能的解只有我在图上框出的四个区域。”
>
> **点评**：这位作者的经验非常实用！在解决几何类问题时，画图是最有效的分析方法之一。通过画图，我们可以直观地看到坏点如何分割屏幕，快速定位候选区域，避免遗漏可能的解。这提醒我们，遇到类似问题时，先动手画图，再推导公式，能大大提高解题效率。

-----

<conclusion>
本次关于“Dead Pixel”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解几何枚举类问题的解题思路和编程技巧。记住，遇到几何问题时，画图+枚举候选区域是关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：151.61秒
# 题目信息

# Even Array

## 题目描述

You are given an array $ a[0 \ldots n-1] $ of length $ n $ which consists of non-negative integers. Note that array indices start from zero.

An array is called good if the parity of each index matches the parity of the element at that index. More formally, an array is good if for all $ i $ ( $ 0 \le i \le n - 1 $ ) the equality $ i \bmod 2 = a[i] \bmod 2 $ holds, where $ x \bmod 2 $ is the remainder of dividing $ x $ by 2.

For example, the arrays \[ $ 0, 5, 2, 1 $ \] and \[ $ 0, 17, 0, 3 $ \] are good, and the array \[ $ 2, 4, 6, 7 $ \] is bad, because for $ i=1 $ , the parities of $ i $ and $ a[i] $ are different: $ i \bmod 2 = 1 \bmod 2 = 1 $ , but $ a[i] \bmod 2 = 4 \bmod 2 = 0 $ .

In one move, you can take any two elements of the array and swap them (these elements are not necessarily adjacent).

Find the minimum number of moves in which you can make the array $ a $ good, or say that this is not possible.

## 说明/提示

In the first test case, in the first move, you can swap the elements with indices $ 0 $ and $ 1 $ , and in the second move, you can swap the elements with indices $ 2 $ and $ 3 $ .

In the second test case, in the first move, you need to swap the elements with indices $ 0 $ and $ 1 $ .

In the third test case, you cannot make the array good.

## 样例 #1

### 输入

```
4
4
3 2 7 6
3
3 2 6
1
7
7
4 9 2 1 18 3 0```

### 输出

```
2
1
-1
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：Even Array 深入学习指南 💡

<introduction>
今天我们来一起分析“Even Array”这道C++编程题。这道题的核心是通过交换元素，让数组中每个元素的奇偶性与其索引的奇偶性一致。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用` (侧重统计与条件判断)

🗣️ **初步分析**：
> 解决“Even Array”这道题，关键在于统计两种错位情况的数量，并判断它们是否相等。简单来说，我们需要找出所有“索引为偶数但元素是奇数”（记为类型A）和“索引为奇数但元素是偶数”（记为类型B）的位置。只有当这两种类型的数量相等时，才能通过交换两两解决；否则无法实现。

   - **题解思路**：所有题解的核心思路一致——统计类型A和类型B的数量，若相等则输出该数量作为最小交换次数，否则输出-1。
   - **核心难点**：正确区分两种错位类型，并理解为何只有数量相等时才有解（因为每次交换必须同时解决一个类型A和一个类型B的错位）。
   - **可视化设计思路**：用像素网格展示数组，类型A的元素用红色方块标记，类型B用蓝色方块标记。交换时，两个方块位置互换，颜色恢复正常。统计数量时，用数字计数器显示红/蓝方块数量，若相等则显示“成功”，否则“失败”。动画中加入“交换”音效（如“叮”）和“成功”音效（如“哇哦”）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：作者：liuyongle**
* **点评**：此题解思路非常清晰，直接点明需要统计两种错位类型的数量。代码结构简洁，变量名`a`（类型A数量）和`b`（类型B数量）虽简短但逻辑明确。算法时间复杂度为O(n)，高效且无冗余操作。从实践角度看，代码可直接用于竞赛，边界处理（如输入读取）严谨，是学习基础统计类问题的优秀参考。

**题解二：作者：PeaceSunset**
* **点评**：此题解用“ji”（奇数错位）和“ou”（偶数错位）命名变量，直观易懂，适合新手理解。代码逻辑直白，循环中直接判断并计数，避免复杂操作。解释部分明确指出“思维题”的特点，帮助学习者抓住问题本质，是思路引导的典范。

**题解三：作者：registerGen**
* **点评**：此题解变量名`cnt1`和`cnt2`明确表示两种错位的计数，代码结构工整。注释简洁但关键，如`work()`函数的设计体现了模块化思想。算法时间复杂度为O(n)，效率高，适合作为代码规范学习的模板。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点，结合优质题解的共性，提炼出解决策略：
</difficulty_intro>

1.  **关键点1**：如何正确统计两种错位类型？
    * **分析**：需要明确“索引奇偶性”与“元素奇偶性”的关系。例如，索引i为偶数时，若元素a[i]是奇数，则属于类型A；索引i为奇数时，若元素a[i]是偶数，则属于类型B。统计时需注意索引从0开始（如i=0是偶数索引）。
    * 💡 **学习笔记**：错位类型的判断是解题的基石，需仔细核对索引和元素的奇偶性。

2.  **关键点2**：为何两种错位数量必须相等？
    * **分析**：每次交换只能同时解决一个类型A和一个类型B的错位（交换后，类型A的元素到类型B的位置，反之亦然）。因此，若两种数量不等，必然无法全部配对交换。
    * 💡 **学习笔记**：配对交换的本质决定了两种错位数量必须相等。

3.  **关键点3**：如何避免索引计算错误？
    * **分析**：题目中数组索引从0开始（如i=0是偶数索引），需注意循环中i的奇偶性判断（如i%2==0表示偶数索引）。部分题解中使用(i-1)%2（当i从1开始循环时），需确保逻辑一致。
    * 💡 **学习笔记**：索引的起始值（0或1）会影响奇偶性判断，需统一处理。

### ✨ 解题技巧总结
<summary_best_practices>
-   **问题抽象**：将复杂问题转化为统计两种特定条件的数量，简化思考过程。
-   **变量命名**：使用直观的变量名（如ji、ou或cnt1、cnt2），提高代码可读性。
-   **边界检查**：注意索引的起始值（本题为0），避免奇偶性判断错误。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个逻辑清晰、代码规范的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了liuyongle和PeaceSunset的题解思路，采用直观的变量命名和简洁的逻辑，适合新手学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    void solve() {
        int n;
        cin >> n;
        int typeA = 0, typeB = 0; // typeA: 偶数索引但元素是奇数；typeB: 奇数索引但元素是偶数
        for (int i = 0; i < n; ++i) {
            int x;
            cin >> x;
            if (x % 2 != i % 2) { // 奇偶性不同，属于错位
                if (i % 2 == 0) {
                    typeA++; // 偶数索引，元素是奇数 → typeA
                } else {
                    typeB++; // 奇数索引，元素是偶数 → typeB
                }
            }
        }
        if (typeA == typeB) {
            cout << typeA << endl;
        } else {
            cout << -1 << endl;
        }
    }

    int main() {
        int t;
        cin >> t;
        while (t--) {
            solve();
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取测试用例数t，然后对每个测试用例：读取数组长度n，遍历数组元素，统计typeA和typeB的数量。最后判断两者是否相等，输出结果。核心逻辑在`solve()`函数中，通过简单的循环和条件判断完成统计。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的亮点和技巧。
</code_intro_selected>

**题解一：作者：liuyongle**
* **亮点**：代码结构简洁，变量名`a`和`b`虽简短但逻辑明确，适合快速实现。
* **核心代码片段**：
    ```cpp
    int a = 0, b = 0;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        if (x % 2 != i % 2) {
            if (i % 2 == 0) a++;
            else b++;
        }
    }
    if (a != b) cout << -1 << endl;
    else cout << a << endl;
    ```
* **代码解读**：
    > 这段代码通过循环遍历数组，统计两种错位类型的数量。`a`统计偶数索引但元素奇数的数量，`b`统计奇数索引但元素偶数的数量。最后判断`a`和`b`是否相等，输出结果。代码逻辑直白，无冗余操作，是典型的线性时间解法。
* 💡 **学习笔记**：简单问题无需复杂数据结构，直接统计是最有效的方法。

**题解二：作者：PeaceSunset**
* **亮点**：变量名`ji`（奇数错位）和`ou`（偶数错位）直观易懂，适合新手理解。
* **核心代码片段**：
    ```cpp
    int ji=0,ou=0;
    for(int i=1;i<=n;i++){
        cin>>a;
        if(a%2!=(i-1)%2){ // 索引从0开始，i-1是实际索引
            if(a%2)ji++; // 元素是奇数 → 偶数索引错位（类型A）
            else ou++;   // 元素是偶数 → 奇数索引错位（类型B）
        }
    }
    if(ji==ou)cout<<ji<<"\n";
    else cout<<"-1\n";
    ```
* **代码解读**：
    > 这段代码中，`i`从1开始循环，实际索引为`i-1`（如i=1对应索引0）。通过`(i-1)%2`判断索引奇偶性，`a%2`判断元素奇偶性。若两者不同，则根据元素奇偶性统计`ji`或`ou`。变量名直观，逻辑清晰。
* 💡 **学习笔记**：变量命名需兼顾简洁与含义，帮助他人（或未来的自己）快速理解代码。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“统计错位类型并判断是否可交换”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素交换小能手`（复古FC风格，主角是一个像素小人，帮助调整数组元素的位置）

  * **核心演示内容**：展示数组元素的奇偶性与索引奇偶性的匹配过程，重点演示两种错位类型的统计、交换操作的效果。

  * **设计思路简述**：采用8位像素风（如红白机配色），用不同颜色标记错位元素，通过动画和音效强化操作记忆。例如，红色方块表示类型A（偶数索引但元素奇数），蓝色方块表示类型B（奇数索引但元素偶数）。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕上方显示“Even Array调整任务”标题，下方是一个像素网格（每个格子代表数组的一个位置，标注索引0、1、2...）。
          * 控制面板包含“开始”“暂停”“单步”按钮和速度滑块（1-5倍速）。
          * 播放8位风格背景音乐（轻快的电子音效）。

    2.  **数据初始化**：
          * 输入数组元素，每个位置显示元素值（如“3”“2”），背景色根据索引奇偶性设定（偶数索引为绿色，奇数索引为黄色）。
          * 元素值的奇偶性与索引不匹配时，背景色变为红色（类型A）或蓝色（类型B），并伴随“叮咚”音效。

    3.  **统计过程演示**：
          * 像素小人从左到右移动，每到一个位置，检查元素和索引的奇偶性。
          * 遇到红色方块（类型A），顶部计数器A加1（数字变大并闪烁）；遇到蓝色方块（类型B），计数器B加1。
          * 计数器A和B的数值实时显示在屏幕上方，颜色对应红/蓝。

    4.  **交换操作演示**：
          * 若计数器A=B，像素小人开始交换操作：选中一个红色方块和一个蓝色方块，两者位置互换（动画：方块滑动并交换位置），交换后背景色恢复绿/黄，伴随“唰”的交换音效。
          * 每完成一次交换，计数器A和B各减1，直到都为0，显示“任务完成！”并播放胜利音效（上扬的电子音）。

    5.  **无法交换的情况**：
          * 若计数器A≠B，屏幕中央显示“无法完成”，红色方块和蓝色方块同时闪烁，播放失败音效（短促的“滴”声）。

  * **旁白提示**：
      * “看！这个位置的元素是奇数，但索引是偶数（绿色背景），属于类型A，计数器A加1～”
      * “交换这两个方块后，它们的位置就符合要求啦！”
      * “如果A和B的数量不一样，就像这样，无法配对交换哦～”

<visualization_conclusion>
通过这个像素动画，我们不仅能清晰看到统计和交换的过程，还能在趣味互动中理解“为什么数量相等才能交换”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以思考类似的“配对调整”问题，以下是一些拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“统计两种错位类型并判断是否相等”的思路，可迁移到其他需要“配对交换”的问题中，例如：调整数组使奇数位于奇数位、偶数位于偶数位；调整字符串使大写字母位于特定位置等。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1104** - `生日`
          * 🗣️ **推荐理由**：这道题需要对同学的生日进行排序，涉及条件判断和排序逻辑，能巩固“统计与调整”的思维。
    2.  **洛谷 P1047** - `校门外的树`
          * 🗣️ **推荐理由**：此题需要统计区间内被移除的树的数量，锻炼区间统计和条件判断能力。
    3.  **洛谷 P1093** - `奖学金`
          * 🗣️ **推荐理由**：此题需要根据多条件排序并统计，适合练习综合条件处理和数据统计。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分，但可以总结一个通用经验：
</insights_intro>

> 在处理类似“统计错位类型”的问题时，**变量命名的直观性**非常重要。例如，用`typeA`和`typeB`或`ji`和`ou`代替`a`和`b`，能显著提高代码的可读性，减少调试时的错误。

-----

<conclusion>
本次关于“Even Array”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握统计与条件判断的核心技巧。记住，编程的关键是理解问题本质，多练习、多思考，你一定能成为算法小能手！💪
</conclusion>

---
处理用时：111.71秒
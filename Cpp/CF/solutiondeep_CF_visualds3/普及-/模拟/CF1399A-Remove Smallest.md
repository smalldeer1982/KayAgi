# 题目信息

# Remove Smallest

## 题目描述

You are given the array $ a $ consisting of $ n $ positive (greater than zero) integers.

In one move, you can choose two indices $ i $ and $ j $ ( $ i       \ne j $ ) such that the absolute difference between $ a_i $ and $ a_j $ is no more than one ( $ |a_i - a_j| \le 1 $ ) and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one).

Your task is to find if it is possible to obtain the array consisting of only one element using several (possibly, zero) such moves or not.

You have to answer $ t $ independent test cases.

## 说明/提示

In the first test case of the example, we can perform the following sequence of moves:

- choose $ i=1 $ and $ j=3 $ and remove $ a_i $ (so $ a $ becomes $ [2; 2] $ );
- choose $ i=1 $ and $ j=2 $ and remove $ a_j $ (so $ a $ becomes $ [2] $ ).

In the second test case of the example, we can choose any possible $ i $ and $ j $ any move and it doesn't matter which element we remove.

In the third test case of the example, there is no way to get rid of $ 2 $ and $ 4 $ .

## 样例 #1

### 输入

```
5
3
1 2 2
4
5 5 5 5
3
1 2 4
4
1 3 4 4
1
100```

### 输出

```
YES
YES
NO
NO
YES```

# AI分析结果



---
# 💡 Kay的C++算法解析：Remove Smallest 深入学习指南 💡

<introduction>
今天我们来一起分析“Remove Smallest”这道C++编程题。这道题的关键在于理解如何通过特定操作将数组缩减到只剩一个元素，本指南将帮助大家梳理思路，掌握核心算法和解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略与排序应用

🗣️ **初步分析**：
解决“Remove Smallest”这道题，关键在于理解贪心策略的应用。贪心策略的核心思想是“每一步选择当前最优解”，就像我们整理书架时，先把书按大小排好，再从最容易处理的部分开始操作。在本题中，我们需要判断是否能通过多次删除操作让数组只剩一个元素。观察操作规则（删除两个差≤1的元素中较小的），可以发现：若数组排序后，所有相邻元素的差都不超过1，那么一定能通过逐步删除较小元素的方式最终只剩最大的那个元素；反之，若存在相邻元素差超过1，则无法删除到只剩一个。

- **题解思路**：所有优质题解均采用“排序+检查相邻差”的思路。排序后，数组从小到大排列，此时只需检查每对相邻元素的差是否≤1。若全部满足，输出YES；否则输出NO。
- **核心难点**：理解“排序后相邻差≤1”与“可删除到只剩一个元素”的等价性。例如，若存在两个元素差>1（如2和4），则无法通过任何操作删除其中一个，导致最终至少剩下两个元素。
- **可视化设计**：动画将以8位像素风展示排序过程（元素像小方块一样滑动到正确位置），然后逐个检查相邻元素：若差≤1则用绿色高亮，差>1用红色高亮，最终根据高亮结果判断输出YES/NO，伴随“叮”（成功）或“咚”（失败）的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、代码规范且解释到位，被选为优质参考（均≥4星）：
</eval_intro>

**题解一：作者：引领天下**
* **点评**：此题解思路直戳核心——“最后剩下的只能是最大的数”，通过排序后检查相邻元素差是否≤1，直接解决问题。代码简洁规范（如`sort(a+1,a+n+1)`清晰排序），循环逻辑简单高效（`ok&=a[i]-a[i-1]<=1`），边界处理（n=1时直接输出YES）隐含在逻辑中。亮点在于用“与运算”简洁判断所有相邻差是否满足条件，适合竞赛快速实现。

**题解二：作者：GBLoi**
* **点评**：此题解详细解释了“为何排序后检查相邻差”的逻辑：“一个数只能被比它大的数删除，若存在相邻差>1，则较小的数无法被删除”。代码结构工整（`sort`后循环检查），变量命名直观（如`i`遍历数组），注释清晰（如`//实际操作可以不用判断相同值`）。亮点在于对问题本质的深入分析，帮助学习者理解条件的充分必要性。

**题解三：作者：KSToki**
* **点评**：此题解用“从最后一个数推起”的逆向思维，强调“最后一次操作删去的数必须与最大数差≤1”，最终转化为检查所有相邻差。代码简洁（`sort`后单循环判断），输入输出使用`read`函数优化，适合处理多组数据。亮点在于逆向推导问题，拓展了学习者的解题思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们常遇到以下核心难点，结合优质题解的共性，提炼出应对策略：
</difficulty_intro>

1.  **关键点1**：如何确定“可删除到只剩一个元素”的条件？
    * **分析**：优质题解指出，最后剩下的一定是最大的数。要让其他数都被删除，每个数必须能被比它大的数（或相等的数）删除。排序后，若相邻元素差≤1，则较小的数可被下一个数删除；若存在相邻差>1，则较小的数无法被后续数删除，导致至少剩两个数。
    * 💡 **学习笔记**：排序后相邻差≤1是问题的充要条件。

2.  **关键点2**：为何排序是关键步骤？
    * **分析**：排序后，数组从小到大排列，相邻元素的差最小。若此时仍存在差>1的相邻对，则其他排列方式也无法满足条件（因为非相邻元素的差只会更大）。排序简化了问题，使我们只需检查最可能的相邻对。
    * 💡 **学习笔记**：排序能将问题转化为检查相邻元素，是贪心策略的典型应用。

3.  **关键点3**：如何处理边界情况（如n=1）？
    * **分析**：当n=1时，数组已经只剩一个元素，直接输出YES。优质题解通过逻辑隐含处理（如循环从i=2开始，n=1时循环不执行，直接输出YES），无需额外判断，代码更简洁。
    * 💡 **学习笔记**：边界情况需提前考虑，但好的代码设计能自然覆盖。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将“能否删除到只剩一个元素”转化为“排序后相邻元素差是否≤1”，简化问题。
- **贪心排序**：排序是处理“相邻比较”类问题的常用技巧，能将复杂关系转化为线性检查。
- **边界简化**：通过合理设计循环范围（如i从2到n），自然覆盖n=1的边界，减少冗余代码。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，逻辑清晰且高效，适合直接参考：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了“引领天下”和“GBLoi”的思路，排序后检查所有相邻元素差是否≤1，简洁高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int t;
        scanf("%d", &t);
        while (t--) {
            int n, a[55];
            scanf("%d", &n);
            for (int i = 0; i < n; ++i) 
                scanf("%d", &a[i]);
            sort(a, a + n);
            bool ok = true;
            for (int i = 1; i < n; ++i) {
                if (a[i] - a[i-1] > 1) {
                    ok = false;
                    break;
                }
            }
            puts(ok ? "YES" : "NO");
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取多组测试数据，对每组数据排序数组，然后遍历检查相邻元素的差。若所有差≤1则输出YES，否则输出NO。核心逻辑集中在排序和循环检查，简洁易懂。

---
<code_intro_selected>
接下来，赏析优质题解的核心代码片段，学习其亮点和实现思路：
</code_intro_selected>

**题解一：作者：引领天下**
* **亮点**：用“与运算”简洁判断所有相邻差是否满足条件，代码极简。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1);bool ok=1;
    for(int i=n;i>1&&ok;i--)ok&=a[i]-a[i-1]<=1;
    puts(ok?"YES":"NO");
    ```
* **代码解读**：排序后从后往前遍历（i从n到2），用`ok&=`累积判断每个相邻差是否≤1。若中途遇到差>1，`ok`变为false并跳出循环。最后根据`ok`输出结果。这种逆向遍历与“最后剩下的是最大数”的思路一致，逻辑直观。
* 💡 **学习笔记**：逆向遍历在处理“依赖后续元素”的问题时更高效。

**题解二：作者：GBLoi**
* **亮点**：直接正向遍历检查，代码清晰易读。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1);
    for(i=2;i<=n;i++) 
        if(a[i]-a[i-1]>1) break;
    if(i==n+1) puts("YES");
    else puts("NO");
    ```
* **代码解读**：排序后从第2个元素开始遍历，若遇到相邻差>1则跳出循环。若循环正常结束（i==n+1），说明所有相邻差≤1，输出YES；否则输出NO。正向遍历符合“从小到大处理”的直觉，适合初学者理解。
* 💡 **学习笔记**：正向遍历在处理“顺序依赖”的问题时更符合思维习惯。

**题解三：作者：KSToki**
* **亮点**：用标志变量`f`记录是否存在差>1的情况，逻辑清晰。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1);
    for(register int i=1;i<n;++i)
        if(a[i+1]-a[i]>1)
        {
            f=1;
            break;
        }
    if(f) printf("NO\n");
    else printf("YES\n");
    ```
* **代码解读**：排序后遍历所有相邻对，若发现差>1则标记`f=1`并跳出循环。最终根据`f`的值输出结果。标志变量的使用使逻辑更直观，便于调试。
* 💡 **学习笔记**：标志变量是记录“是否发生某事件”的常用技巧。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“排序+检查相邻差”的过程，我们设计了一个8位像素风的动画演示，让算法“动起来”！
</visualization_intro>

  * **动画演示主题**：像素小方块的“消除挑战”（复古FC游戏风格）

  * **核心演示内容**：展示数组排序过程，然后逐个检查相邻小方块的差是否≤1，根据结果决定是否消除，最终判断能否只剩一个方块。

  * **设计思路简述**：8位像素风（如FC红白机的方块、简洁色调）能降低学习压力；小方块的滑动排序和颜色高亮（绿色/红色）直观展示关键步骤；音效（“叮”表示成功检查，“咚”表示失败）强化操作记忆；自动演示模式让学习者观察完整流程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕下方显示像素小方块（每个方块标有数值，颜色随机但统一），上方是“操作面板”（开始/暂停、单步、重置按钮，速度滑块）。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》的简单变奏）。

    2.  **排序过程**：
          * 点击“开始”后，小方块像“推箱子”一样滑动到正确位置（从小到大排列），伴随轻微的“滑动”音效（“唰唰”声）。

    3.  **检查相邻差**：
          * 一个像素箭头（黄色）从左到右依次指向每对相邻方块（如第1和第2个，第2和第3个...）。
          * 若差≤1，被指的两个方块变绿色，伴随“叮”音效；若差>1，变红色，伴随“咚”音效，并弹出文字提示“这里差太大，无法消除！”。

    4.  **结果判定**：
          * 若所有相邻对都是绿色，最后一个方块（最大的）变大并闪烁，播放“胜利”音效（如《魂斗罗》的过关音乐），文字显示“YES！成功只剩一个！”。
          * 若有红色对，所有方块停止，播放“失败”音效（短促的“呜”声），文字显示“NO！无法消除到只剩一个。”。

    5.  **交互控制**：
          * 单步模式：点击“单步”按钮，箭头每次移动一步，适合仔细观察。
          * 调速滑块：调整动画速度（慢/中/快），满足不同学习需求。

  * **旁白提示**：
      * （排序时）“先把小方块排好队，这样更容易检查相邻的差哦～”
      * （检查时）“看！这两个方块的差是1，符合条件，可以消除～”
      * （失败时）“这里差超过1，小方块无法被消除，所以最终会剩下多个哦～”

<visualization_conclusion>
通过这样的动画，我们能直观看到排序和检查的每一步，理解“相邻差≤1”为何是关键条件。像素风格和游戏化设计让学习更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固“排序+相邻检查”的贪心思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“排序后检查相邻差”思路，还可用于：
        1. 判断数组是否为连续数列（如“判断数组能否组成连续的顺子”）。
        2. 解决“删除元素使剩余元素满足某种相邻条件”的问题（如“删除最少元素使数组递增”）。
        3. 处理“区间覆盖”问题（如“用最少的区间覆盖所有点”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1104 生日**
          * 🗣️ **推荐理由**：需要对同学的生日排序后检查相邻差，与本题“排序+相邻检查”思路一致，适合巩固基础。
    2.  **洛谷 P1059 明明的随机数**
          * 🗣️ **推荐理由**：涉及排序和去重，之后检查相邻数的连续性，能拓展“排序应用”的解题思维。
    3.  **洛谷 P1271 整数的排序**
          * 🗣️ **推荐理由**：要求自定义排序规则后处理问题，适合提升对排序灵活性的理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，作者“引领天下”提到：“因为每次只能删除较小的数，所以最后剩下的只能是最大的数。” 这一观察直接抓住了问题的本质，避免了复杂的模拟操作。
</insights_intro>

> **参考经验**：“最后剩下的只能是最大的数”这一结论，让我意识到，遇到操作类问题时，先分析“最终可能的状态”往往能简化问题。

**点评**：这位作者的经验非常实用！在编程题中，尤其是操作类问题，先思考“最终状态的特征”（如本题中“只剩最大数”），能快速找到解题的突破口，避免陷入复杂的步骤模拟。这对我们来说，是一个宝贵的“问题分析技巧”。

-----

<conclusion>
本次关于“Remove Smallest”的C++解题分析就到这里。通过排序和检查相邻差的贪心策略，我们能高效解决问题。希望这份指南能帮助大家掌握核心思路，并在类似问题中举一反三。编程的乐趣在于思考和实践，下次我们再一起挑战新的题目！💪
</conclusion>

-----

---
处理用时：136.26秒
# 题目信息

# Unique Bid Auction

## 题目描述

There is a game called "Unique Bid Auction". You can read more about it here: <a>https://en.wikipedia.org/wiki/Unique\_bid\_auction</a> (though you don't have to do it to solve this problem).

Let's simplify this game a bit. Formally, there are $ n $ participants, the $ i $ -th participant chose the number $ a_i $ . The winner of the game is such a participant that the number he chose is unique (i. e. nobody else chose this number except him) and is minimal (i. e. among all unique values of $ a $ the minimum one is the winning one).

Your task is to find the index of the participant who won the game (or -1 if there is no winner). Indexing is $ 1 $ -based, i. e. the participants are numbered from $ 1 $ to $ n $ .

You have to answer $ t $ independent test cases.

## 样例 #1

### 输入

```
6
2
1 1
3
2 1 3
4
2 2 2 3
1
1
5
2 3 2 4 2
6
1 1 5 5 4 4```

### 输出

```
-1
2
4
1
2
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Unique Bid Auction 深入学习指南 💡

<introduction>
今天我们来一起分析“Unique Bid Auction”这道题。这道题的关键是找到数组中**唯一出现且值最小的元素的下标**，没有的话输出-1。本指南会带大家梳理思路、解析核心算法，并通过可视化和代码赏析掌握解题技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（侧重统计与枚举的基础数据结构运用）

🗣️ **初步分析**：
解决这道题的核心是两步：**统计每个数的出现次数**和**找到最小的唯一数**。  
简单来说，就像给每个数发“身份证”——统计它出现了几次（用数组或哈希表记录次数），然后从最小的数开始“点名”，第一个只出现一次的数就是我们要找的！  

- **题解思路**：大部分题解采用“统计次数+枚举最小唯一数”的思路。差异主要在统计工具（数组/哈希表）和枚举范围（全局最小到最大/1到n）。例如，用数组统计更高效（O(n)），用哈希表（如map）可能稍慢但代码简洁。
- **核心难点**：如何高效统计次数并快速找到最小唯一数。关键在于“枚举范围的优化”——只需要枚举到当前测试用例中的最大值，避免无效遍历。
- **可视化设计**：我们会设计一个“像素统计员”动画，用不同颜色的方块代表数组元素，统计时方块上显示次数；枚举时从左（最小值）到右（最大值）扫描，找到第一个绿色（唯一）方块时高亮并播放“叮”音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法效率等方面筛选出以下4星及以上题解：
</eval_intro>

**题解一：daiarineko的结构体优化解法**  
* **点评**：此题解巧妙使用结构体数组`ns`，其中`ns[c].count`记录数c的出现次数，`ns[c].winner`记录最后一次出现的下标。通过`mx`变量优化枚举范围（只到当前测试用例的最大值），避免了遍历到200000的无效操作，时间复杂度O(n)。代码规范（如`memset`重置数组），边界处理严谨（多测试用例初始化），非常适合学习。

**题解二：Thomas_Cat的数组统计法**  
* **点评**：此题解直接用数组`v`统计次数，`number`记录下标，遍历范围是全局最小到最大。思路直白易懂，代码简洁（仅20行左右），适合新手理解基础逻辑。但需注意：若最大值很大（如接近1e5），遍历范围可能稍大，但实际测试数据中已足够高效。

**题解三：yzy1的vector存储位置法**  
* **点评**：此题解用`vector<int> sum[N]`存储每个数的所有出现位置，判断`sum[i].size()==1`时取第一个位置。思路清晰，利用vector的动态特性，适合理解“多位置记录”场景。但需注意每次测试后要`clear()`，避免数据残留。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们常遇到以下关键点，结合优质题解的思路，一起拆解它们！
</difficulty_intro>

1.  **关键点1**：如何高效统计每个数的出现次数和位置？  
    * **分析**：优质题解多用数组（如`v[a[i]]++`）或哈希表（如`map<int,int> cnt`）。数组统计的时间复杂度是O(1)，适合数值范围明确的场景（本题中`a_i≤n`）；哈希表更灵活，但可能因哈希冲突稍慢。  
    * 💡 **学习笔记**：当数值范围已知且不大时（如本题`a_i≤n`），优先用数组统计，效率更高！

2.  **关键点2**：如何快速找到最小的唯一数？  
    * **分析**：最小的唯一数一定是所有唯一数中最小的，因此需要从小到大枚举。优质题解通过记录当前测试用例的最大值`mx`（或全局最小值`MIN`），将枚举范围缩小到`1~mx`，避免无效遍历。  
    * 💡 **学习笔记**：优化枚举范围是降低时间复杂度的关键！例如，若数组最大值是5，只需检查1到5，无需检查到1e5。

3.  **关键点3**：多测试用例时如何避免数据残留？  
    * **分析**：每个测试用例需重置统计数组（如`memset(ns,0,sizeof(ns))`）或清空哈希表（如`mp.clear()`）。若不重置，上一组数据会影响当前结果。  
    * 💡 **学习笔记**：多测试用例问题中，初始化是“隐形的坑”！养成每次测试前重置变量的习惯。

### ✨ 解题技巧总结
- **数组统计优先**：当数值范围明确时（如本题`a_i≤n`），用数组代替哈希表，速度更快。  
- **范围优化枚举**：记录当前测试用例的最大值`mx`，枚举范围缩小到`1~mx`，减少无效计算。  
- **多测试用例初始化**：每次测试前清空统计数组或哈希表，避免数据污染。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，给出一个高效、清晰的通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了daiarineko的结构体优化和Thomas_Cat的数组统计思路，通过`mx`优化枚举范围，时间复杂度O(n)，适合竞赛环境。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    struct Participant {
        int count = 0; // 记录数的出现次数
        int pos = 0;   // 记录最后一次出现的下标
    } arr[200005];      // 数值范围a_i≤n≤2e5，数组大小设为200005足够

    int main() {
        ios::sync_with_stdio(false); // 加速输入输出
        cin.tie(0);
        int t;
        cin >> t;
        while (t--) {
            int n, mx = 0;
            cin >> n;
            memset(arr, 0, sizeof(arr)); // 重置结构体数组
            for (int i = 1; i <= n; ++i) {
                int x;
                cin >> x;
                arr[x].count++;
                arr[x].pos = i; // 最后一次出现的下标覆盖前面的
                if (x > mx) mx = x; // 记录当前测试用例的最大值
            }
            int ans = -1;
            for (int i = 1; i <= mx; ++i) { // 枚举1到mx
                if (arr[i].count == 1) {
                    ans = arr[i].pos;
                    break; // 找到最小唯一数，直接退出
                }
            }
            cout << ans << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先用结构体数组`arr`统计每个数的出现次数和最后位置；通过`mx`记录当前测试用例的最大值，缩小枚举范围；最后从1到`mx`找第一个出现次数为1的数，输出其位置。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：daiarineko的结构体优化**  
* **亮点**：用结构体同时记录次数和位置，通过`mx`优化枚举范围，避免无效遍历。  
* **核心代码片段**：
    ```cpp
    struct participant{
        int winner; // 最后一次出现的下标
        int count;  // 出现次数
    }ns[200040];

    // ... 输入部分 ...
    mx = max(mx, c); // 记录最大值
    // ... 枚举部分 ...
    for(int i=0;i<=mx;i++){
        if(ns[i].count==1){
            winner=ns[i].winner;
            break;
        }
    }
    ```
* **代码解读**：  
  结构体`participant`的两个成员`winner`和`count`分别记录数的最后位置和次数。输入时更新`mx`为当前最大值，枚举时只需检查到`mx`，避免遍历到200000的冗余操作。  
* 💡 **学习笔记**：结构体是组织关联数据的好工具！这里将“次数”和“位置”绑定，代码更清晰。

**题解二：Thomas_Cat的数组统计法**  
* **亮点**：代码简洁，直接用两个数组分别统计次数和位置，适合新手理解基础逻辑。  
* **核心代码片段**：
    ```cpp
    int v[100005]={0},number[100005]={0};
    // ... 输入时统计次数和位置 ...
    for(int i=MIN;i<=MAX;i++)
        if(v[i]==1) {
            cout<<number[i]<<endl;
            flag=1;
            break;
        }
    ```
* **代码解读**：  
  `v`数组统计次数，`number`数组记录最后位置。输入时同时更新全局最小`MIN`和最大`MAX`，枚举时从`MIN`到`MAX`找第一个次数为1的数。  
* 💡 **学习笔记**：数组索引天然对应数值，统计时非常直观！

**题解三：yzy1的vector存储位置法**  
* **亮点**：用`vector`存储每个数的所有出现位置，判断大小是否为1。  
* **核心代码片段**：
    ```cpp
    vector<int> sum[N];
    // ... 输入时push_back位置 ...
    for (int i = 1; i <= n; ++i) {
        if (sum[i].size() == 1) {
            printf("%d\n", sum[i][0]);
            break;
        }
    }
    ```
* **代码解读**：  
  `sum[i]`存储数i的所有出现位置，若`sum[i].size()==1`，说明i是唯一数，取第一个位置（因为vector按输入顺序存储，第一个位置就是唯一的下标）。  
* 💡 **学习笔记**：`vector`适合需要存储多个位置的场景，判断大小是否为1很直观！

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解统计和枚举过程，我们设计一个“像素统计员”动画，用8位像素风展示算法每一步！
</visualization_intro>

  * **动画演示主题**：`像素统计员的寻宝之旅`  
  * **核心演示内容**：统计每个数的出现次数，然后从最小数开始寻找第一个唯一数（绿色方块），找到后播放胜利音效。  

  * **设计思路简述**：  
    8位像素风（如FC游戏）营造轻松氛围；用不同颜色标记数的状态（红色：重复，绿色：唯一）；枚举时用箭头从左（最小值）到右（最大值）扫描，找到绿色方块时高亮。音效（“叮”提示统计，“胜利”提示找到目标）强化操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        屏幕左侧显示像素化数组（每个方块标数值，如`[1,2,1]`），右侧显示“统计面板”（每个数对应一个格子）。控制面板有“开始/暂停”“单步”“重置”按钮和速度滑块。

    2.  **统计次数动画**：  
        输入时，每个数的方块从数组滑到统计面板对应位置，统计面板的格子颜色变化：第一次出现时变黄色（次数=1），第二次变红色（次数≥2），伴随“滴答”音效。例如，输入`1`时，统计面板的1号格子变黄；再次输入`1`时变红。

    3.  **枚举最小唯一数**：  
        统计完成后，一个像素箭头从左（最小值）开始向右扫描。扫描到红色格子（重复数）时跳过，扫描到绿色格子（唯一数）时停下，格子闪烁并播放“叮”音效，箭头指向该格子的下标（显示在屏幕上方）。

    4.  **胜利/失败反馈**：  
        找到唯一数时，屏幕中央弹出“胜利！”文字，背景播放8位胜利音乐；未找到时显示“-1”，播放短促“提示”音效。

    5.  **交互控制**：  
        支持“单步”（点击一次执行一步统计或枚举）、“自动播放”（按滑块速度自动执行）、“重置”（清空所有统计和动画）。

  * **旁白提示**：  
    - 统计时：“看！这个数第一次出现，格子变黄啦～”  
    - 重复时：“又出现了一次，格子变红，说明它不是唯一数哦！”  
    - 枚举时：“箭头从最小数开始找，第一个绿色格子就是答案～”  

<visualization_conclusion>
通过这个动画，我们能直观看到每个数的统计过程和枚举逻辑，像玩游戏一样理解算法！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下类似问题，巩固统计与枚举的技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的“统计次数+枚举最小唯一数”思路，还可用于：  
    - 找数组中唯一出现两次的数（统计次数=2的最小数）。  
    - 找字符串中第一个只出现一次的字符（统计字符频率，枚举字符顺序）。  
    - 游戏中的“唯一道具”定位（统计道具出现次数，找最小ID的唯一道具）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1100** - 高低位交换  
        * 🗣️ **推荐理由**：练习位运算和统计，培养对数据范围的敏感度。  
    2.  **洛谷 P1427** - 小鱼的数字游戏  
        * 🗣️ **推荐理由**：练习数组的逆序存储与统计，适合巩固基础操作。  
    3.  **洛谷 P2615** - 神奇的幻方  
        * 🗣️ **推荐理由**：练习模拟与枚举，理解特定规则下的统计逻辑。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了实践中的小技巧，这些经验很值得借鉴：
</insights_intro>

> **参考经验 (来自daiarineko)**：“每个测试点要记得重置结构体数组（memset），否则上一组数据会影响当前结果！”  
> **点评**：多测试用例问题中，初始化是容易忽略的细节。这位作者的提醒很实用！我们可以养成习惯：每次测试前用`memset`或`clear()`重置统计变量，避免“数据残留”的bug。

-----

<conclusion>
通过今天的分析，我们掌握了“统计次数+枚举最小唯一数”的核心思路，理解了数组、结构体等数据结构的应用，还通过动画直观看到了算法过程。编程的关键是多练习、多思考，快去尝试推荐的题目吧！下次见～💪
</conclusion>

---
处理用时：121.33秒
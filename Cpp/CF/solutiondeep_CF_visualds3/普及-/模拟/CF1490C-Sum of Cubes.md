# 题目信息

# Sum of Cubes

## 题目描述

给您一个正整数  $x$ ，问这个正整数能否拆分成两个立方数之和。

也就是说，是否存在  $1\le a, b$ 满足  $a^3+b^3=x$ 。

## 样例 #1

### 输入

```
7
1
2
4
34
35
16
703657519796```

### 输出

```
NO
YES
NO
NO
YES
YES
YES```

# AI分析结果



---
# 💡 Kay的C++算法解析：Sum of Cubes 深入学习指南 💡

<introduction>
今天我们来一起分析“Sum of Cubes”这道C++编程题。题目要求判断一个正整数能否拆分为两个正整数的立方和，本指南将帮助大家梳理核心思路，掌握解题技巧，并通过可视化动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举与验证 (属于「枚举」算法分类)

🗣️ **初步分析**：
解决这道题的关键在于通过枚举一个数，验证另一个数是否满足条件。枚举算法就像“逐个尝试可能的钥匙”，直到找到能打开“问题之门”的那把。在本题中，我们枚举较小的立方数 \(a^3\)，然后验证剩余部分 \(x - a^3\) 是否是另一个正整数的立方 \(b^3\)。

- **题解思路**：由于 \(x\) 最大为 \(10^{12}\)，其立方根约为 \(10^4\)，因此只需枚举 \(a\) 从1到 \(10^4\)，计算 \(x - a^3\) 后，判断是否为立方数。主流题解有两种思路：直接计算立方根后验证（如用 `cbrt` 函数），或预处理所有立方数到集合中快速查询。
- **核心难点**：如何避免浮点数精度误差（如 `pow` 函数可能不准确），以及确保 \(b \geq 1\)。
- **可视化设计**：我们将用8位像素风格动画模拟枚举过程：像素方块代表 \(a^3\)，剩余部分用另一颜色方块表示，检查是否匹配预处理的立方数集合（用像素格子展示）。关键步骤高亮（如当前枚举的 \(a\)、匹配的 \(b^3\)），并伴随“叮”的音效提示匹配成功。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：EDqwq的预处理集合法 (来源：用户EDqwq)**
* **点评**：此题解巧妙预处理了 \(1\) 到 \(10^4\) 的立方数到 `map` 中，枚举 \(a\) 时直接查询 \(x - a^3\) 是否在集合中。代码逻辑简洁，利用哈希表查询的 \(O(1)\) 特性，时间复杂度仅为 \(O(T \times 10^4)\)，高效可靠。变量名清晰（如 `flag` 标记结果），边界处理严谨（如 \(x - a^3 \leq 0\) 时提前终止枚举），是竞赛中典型的“预处理+查询”优化思路。

**题解二：zplqwq的cbrt验证法 (来源：用户zplqwq)**
* **点评**：此题解直接枚举 \(a\)，用 `cbrt` 函数计算 \(b\) 的立方根，避免了 `pow` 函数的精度问题。代码中明确处理了 \(b > 0\) 的条件（`(int)cbrt(j) > 0`），多组测试用例时及时重置 `flag`（“多测不清空，报零两行泪！”），体现了良好的编程习惯。思路直白，适合初学者理解“枚举+验证”的核心逻辑。

**题解三：清烛的set优化法 (来源：用户清烛)**
* **点评**：此题解使用 `std::set` 存储立方数，枚举时直接查询，时间复杂度低。特别指出“避免使用 `unordered_map` 以防被hack”，体现了竞赛中的经验积累。代码简洁，注释明确（如“赛时有人因为用了 `std::unordered_map` 被叉掉”），对竞赛选手有重要参考价值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，我们常遇到以下关键点，结合优质题解的共性，总结策略如下：
</difficulty_intro>

1.  **关键点1**：如何确定枚举范围？
    * **分析**：\(a\) 的最大可能值是 \(x\) 的立方根（向下取整），因为 \(a^3\) 必须小于 \(x\)（否则 \(b^3\) 为负数或零）。例如 \(x=10^{12}\) 时，\(\sqrt[3]{x}=10^4\)，因此枚举 \(a\) 到 \(10^4\) 即可覆盖所有可能。
    * 💡 **学习笔记**：枚举范围由问题的数学性质决定，合理缩小范围能大幅提升效率。

2.  **关键点2**：如何准确判断 \(b^3 = x - a^3\)？
    * **分析**：直接用 `pow(x - a^3, 1.0/3)` 可能因浮点数精度丢失出错（如 \(x - a^3=8\) 时，`pow(8,1.0/3)` 可能返回1.9999999）。优质题解采用两种方法：一是用 `cbrt` 函数（C++标准库的立方根函数，精度更高），二是预处理所有立方数到集合中，直接查询。
    * 💡 **学习笔记**：涉及浮点数运算时，优先选择专用函数（如 `cbrt`）或预处理法，避免精度误差。

3.  **关键点3**：如何处理多组测试用例？
    * **分析**：每组测试用例需重置状态变量（如 `flag`），否则前一次结果会影响当前判断。例如，zplqwq的题解中明确写出“flag=0;//多测不清空，报零两行泪！”，强调了状态重置的重要性。
    * 💡 **学习笔记**：多组测试用例时，务必重置临时变量，避免“历史遗留问题”。

### ✨ 解题技巧总结
- **预处理优化**：将可能的立方数提前存入集合（如 `set` 或 `map`），查询时时间复杂度为 \(O(1)\)，比重复计算立方根更高效。
- **专用函数优先**：使用 `cbrt` 代替 `pow` 计算立方根，减少精度误差。
- **边界条件检查**：确保 \(b \geq 1\)（如 `tmp > 0`），避免因 \(b=0\) 导致错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择预处理集合法作为通用核心实现，兼顾效率与易懂性。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合EDqwq和清烛的思路，预处理立方数到 `set` 中，枚举 \(a\) 并查询剩余部分是否在集合中。代码简洁高效，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;

    set<ll> cubes; // 预处理的立方数集合

    void init() {
        for (ll i = 1; i <= 10000; ++i) {
            cubes.insert(i * i * i);
        }
    }

    string check(ll x) {
        for (ll a = 1; a * a * a <= x; ++a) {
            ll remain = x - a * a * a;
            if (remain <= 0) break; // 剩余部分非正，无需继续枚举
            if (cubes.count(remain)) {
                return "YES";
            }
        }
        return "NO";
    }

    int main() {
        init(); // 预处理立方数
        int T;
        cin >> T;
        while (T--) {
            ll x;
            cin >> x;
            cout << check(x) << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先预处理 \(1\) 到 \(10^4\) 的立方数存入 `set`（`init` 函数）。对于每个测试用例，枚举 \(a\) 并计算剩余部分 \(x - a^3\)，若剩余部分在 `set` 中（即存在 \(b\) 使得 \(b^3 = 剩余部分\)），则返回“YES”，否则继续枚举。枚举范围由 \(a^3 \leq x\) 控制，确保不重复、不遗漏。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：EDqwq的预处理集合法 (来源：用户EDqwq)**
* **亮点**：预处理立方数到 `map`，查询效率高；枚举时提前终止（`x - i*i*i <= 0` 时 `break`），减少无效计算。
* **核心代码片段**：
    ```cpp
    map <int,int> q;
    signed main(){
        for(int i = 1;i <= 10000;i ++) q[i * i * i] = 1;
        cin>>t;
        while(t --){
            bool flag = false;
            int n; n = read();
            for(int i = 1;i <= 10000;i ++){
                int x = n - i * i * i;
                if(x <= 0) break;
                if(q[x]){ flag = true; break; }
            }
            if(flag) puts("YES");
            else puts("NO");
        }
    }
    ```
* **代码解读**：
    > `q` 是存储立方数的 `map`，键为立方数，值为1（标记存在）。枚举 \(i\) 时，计算 \(x = n - i^3\)，若 \(x \leq 0\) 则跳出循环（后续 \(i\) 更大，\(x\) 更小，无需继续）。若 \(x\) 在 `q` 中（`q[x]` 为1），则存在 \(b\) 满足条件。
* 💡 **学习笔记**：预处理法将“验证”步骤从 \(O(\sqrt[3]{x})\) 优化为 \(O(1)\)，是典型的“空间换时间”策略。

**题解二：zplqwq的cbrt验证法 (来源：用户zplqwq)**
* **亮点**：直接使用 `cbrt` 计算立方根，避免浮点数精度问题；明确处理 \(b > 0\) 的条件。
* **核心代码片段**：
    ```cpp
    while(T--){
        int x; cin >> x;
        for(int i=1; i<=cbrt(x); i++){
            int j = x - i*i*i;
            if(i*i*i + (int)cbrt(j)*(int)cbrt(j)*(int)cbrt(j) == x && (int)cbrt(j) > 0){
                cout << "Yes" << endl; flag=1; break;
            }
        }
        if(flag==0) cout << "No" << endl;
        flag=0; // 多测重置
    }
    ```
* **代码解读**：
    > 枚举 \(i\) 时，计算 \(j = x - i^3\)，然后用 `cbrt(j)` 得到 \(b\) 的近似值。通过 `(int)cbrt(j)` 取整后，验证其立方是否等于 \(j\)，且 \(b > 0\)（`(int)cbrt(j) > 0`）。多组测试用例结束后重置 `flag`，避免前一次结果影响当前判断。
* 💡 **学习笔记**：`cbrt` 是C++标准库函数，专门计算立方根，比 `pow(x, 1.0/3)` 更精确。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举过程，我们设计一个“立方数探险”像素动画，用8位复古风格展示枚举 \(a\) 和验证 \(b\) 的过程。
</visualization_intro>

  * **动画演示主题**：像素小探险家寻找立方宝藏
  * **核心演示内容**：小探险家（像素角色）从1开始，逐个“踩”过 \(a=1,2,...,10^4\) 的立方数方块（蓝色），每踩一个方块，计算剩余部分 \(x - a^3\)（红色方块），并检查是否匹配“立方宝藏库”（预先排列的黄色立方数方块）。若匹配，宝藏库发光，播放“叮”的音效；若枚举完未找到，显示“NO”。

  * **设计思路简述**：8位像素风格降低学习压力，动态方块变化直观展示 \(a^3\) 和 \(b^3\) 的关系。音效和高亮强化关键步骤记忆，“探险”主题增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 背景为FC风格的像素草地，顶部显示“Sum of Cubes探险”标题。
          * 左侧排列“立方宝藏库”（黄色方块，标有 \(1^3, 2^3,...,10^4^3\)）。
          * 底部是枚举路径（蓝色方块，标有 \(a=1,2,...,10^4\)）。
          * 控制面板：单步/自动按钮、速度滑块（1x-5x）、重置按钮。

    2.  **启动枚举**：
          * 小探险家站在 \(a=1\) 的方块上，方块闪烁（白色边框），播放“滴”的音效。
          * 计算 \(x - a^3\)，生成红色方块（标有剩余值），移动到宝藏库前。

    3.  **验证过程**：
          * 红色方块与宝藏库中的黄色方块逐个比对（动画：方块左右移动）。
          * 若匹配（剩余值是立方数），红色方块与对应黄色方块同时发光（绿色闪光），播放“叮！”音效，探险家跳跃庆祝。
          * 若不匹配，红色方块变暗，探险家移动到下一个 \(a\) 的方块（蓝色）。

    4.  **结束状态**：
          * 找到匹配时，屏幕显示“YES”，播放胜利音乐（8位风格旋律）。
          * 未找到时，显示“NO”，探险家摇头，播放“呜~”音效。

    5.  **交互控制**：
          * 单步按钮：每次点击执行一个 \(a\) 的枚举和验证。
          * 自动播放：探险家自动跑步完成枚举，速度由滑块调节。
          * 重置按钮：回到初始状态，重新选择 \(x\) 输入。

  * **旁白提示**：
      * （单步时）“现在枚举 \(a=3\)，计算 \(x - 3^3 = 剩余值\)，检查是否在立方宝藏库中...”
      * （匹配时）“看！剩余值等于 \(5^3\)，成功找到 \(b=5\)，输出YES！”
      * （未找到时）“所有 \(a\) 都枚举完了，没有找到匹配的 \(b\)，输出NO。”

<visualization_conclusion>
通过这个动画，我们可以直观看到枚举 \(a\) 的过程和验证 \(b\) 的逻辑，像玩游戏一样理解算法核心！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固枚举与验证的思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 枚举+验证不仅用于立方和，还可解决平方和（如判断 \(x=a^2+b^2\)）、阶乘和（如 \(x=a!+b!\)）等问题，关键是找到枚举范围和高效验证方法。
      * 预处理法可推广到其他需要快速查询的场景（如质数判断、完全平方数判断）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1317** - 低洼地
          * 🗣️ **推荐理由**：枚举每个位置，验证左右是否有更高点，巩固“枚举+边界判断”的思路。
    2.  **洛谷 P1036** - 选数
          * 🗣️ **推荐理由**：枚举组合数，验证是否为质数，练习多条件枚举与验证。
    3.  **洛谷 P1217** - 回文质数
          * 🗣️ **推荐理由**：枚举回文数，验证是否为质数，结合枚举与数论判断，提升综合能力。

-----

## 7\. 学习心得与经验分享

<insights_intro>
部分题解分享了宝贵的实践经验，值得我们借鉴：
</insights_intro>

> **参考经验 (来自用户清烛)**：“赛时有人因为用了 `std::unordered_map` 被叉掉，改成 `std::map` 就过了。”
>
> **点评**：清烛的经验提醒我们，竞赛中选择数据结构时需考虑安全性。`unordered_map` 虽快但可能被哈希碰撞攻击，而 `map`（基于红黑树）更稳定。这对参加正式比赛的同学非常有帮助！

-----

<conclusion>
本次关于“Sum of Cubes”的分析就到这里。通过枚举与验证的思路，结合预处理或立方根函数，我们可以高效解决问题。希望大家通过练习巩固这些技巧，下次挑战更难的题目！💪
</conclusion>

-----

---
处理用时：176.45秒
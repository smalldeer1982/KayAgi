# 题目信息

# Everything Everywhere All But One

## 题目描述

You are given an array of $ n $ integers $ a_1, a_2, \ldots, a_n $ . After you watched the amazing film "Everything Everywhere All At Once", you came up with the following operation.

In one operation, you choose $ n-1 $ elements of the array and replace each of them with their arithmetic mean (which doesn't have to be an integer). For example, from the array $ [1, 2, 3, 1] $ we can get the array $ [2, 2, 2, 1] $ , if we choose the first three elements, or we can get the array $ [\frac{4}{3}, \frac{4}{3}, 3, \frac{4}{3}] $ , if we choose all elements except the third.

Is it possible to make all elements of the array equal by performing a finite number of such operations?

## 说明/提示

In the first test case, all elements are already equal.

In the second test case, you can choose all elements except the third, their average is $ \frac{1 + 2 + 4 + 5}{4} = 3 $ , so the array will become $ [3, 3, 3, 3, 3] $ .

It's possible to show that it's impossible to make all elements equal in the third and fourth test cases.

## 样例 #1

### 输入

```
4
3
42 42 42
5
1 2 3 4 5
4
4 3 2 1
3
24 2 22```

### 输出

```
YES
YES
NO
NO```

# AI分析结果



---
# 💡 Kay的C++算法解析：Everything Everywhere All But One 深入学习指南 💡

<introduction>
今天我们来一起分析“Everything Everywhere All But One”这道题。它的核心是通过数学推导判断是否能通过特定操作让数组所有元素相等。本指南将帮你理清思路，掌握关键技巧，最后还会有超有趣的像素动画演示哦！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学性质推导与逻辑判断

🗣️ **初步分析**：
解决这道题的关键是发现“操作前后数组总和不变”的数学性质。简单来说，无论怎么操作，数组的总和就像一根“定海神针”，始终保持不变。最终所有元素相等时，每个元素的值必然是总和除以元素个数（即平均值）。因此，问题转化为：原数组中是否存在一个元素恰好等于这个平均值？

- **题解思路**：所有优质题解的核心思路一致：计算数组总和，检查是否存在元素等于总和除以n（平均值）。若存在，输出YES；否则输出NO。
- **核心难点**：发现“总和不变”的隐藏性质，理解为何只需检查原数组是否包含平均值。
- **可视化设计**：我们将用8位像素风动画演示操作过程，比如用不同颜色的像素块表示数组元素，高亮当前计算的平均值，最后用闪烁效果提示是否找到目标值。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：作者Qerucy（优化版）**
* **点评**：此题解直接抓住“总和不变”的核心性质，通过预处理总和避免重复计算，代码简洁高效。变量名`sum`和`fg`（flag缩写）含义明确，循环结构清晰。优化后的代码将时间复杂度保持在O(n)，非常适合竞赛场景。亮点在于通过数学推导简化计算，避免了原始方法中的重复求和，提升了效率。

**题解二：作者ningago**
* **点评**：此题解不仅给出代码，还详细证明了“操作后总和不变”“至多只需一次操作”等关键性质，逻辑严谨。代码中`sum`变量存储总和，循环检查每个元素是否等于平均值，结构工整。其理论推导部分对理解问题本质有极大帮助，是“知其然更知其所以然”的典范。

**题解三：作者ivyjiao**
* **点评**：此题解用最直白的方式实现核心逻辑——计算总和后遍历检查。代码简洁到只有20行，变量名`flag`明确表示是否找到目标值。虽然没有复杂优化，但胜在清晰易懂，非常适合新手学习。亮点是“sum == a[i] * n”的判断避免了浮点数运算，彻底规避了精度问题。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们需要突破以下三个关键点：
</difficulty_intro>

1.  **关键点1**：发现“操作前后总和不变”的隐藏性质  
    * **分析**：每次操作选择n-1个数，将它们替换为平均值。假设原总和为S，操作后这n-1个数的总和是（S - 被排除数），替换为平均值后总和还是（S - 被排除数），加上被排除数，总和仍为S。因此，总和是不变的。  
    * 💡 **学习笔记**：遇到“操作类问题”，先找“不变量”（如总和、奇偶性等），能快速缩小问题范围！

2.  **关键点2**：确定最终相等值为总和的平均值  
    * **分析**：若所有元素最终相等，设为k，则总和S = n*k → k = S/n。因此，k必须是总和除以元素个数的结果。  
    * 💡 **学习笔记**：最终状态的数学表达式往往能通过不变量直接推导！

3.  **关键点3**：理解为何只需检查原数组是否包含平均值  
    * **分析**：若原数组存在元素等于k（平均值），选择其他n-1个数操作，它们会被替换为k（因为它们的平均值是(S - k)/(n-1) = (n*k - k)/(n-1) = k），此时所有元素都变为k。若原数组没有k，操作后会得到n-1个k和1个其他数，后续操作无法让所有元素相等（因为总和不变，新的平均值仍为k，但剩下的数不等于k）。  
    * 💡 **学习笔记**：一次操作就能决定是否能达成目标，无需多次操作！

### ✨ 解题技巧总结
- **找不变量**：操作类问题的突破口往往是“不变量”（如本题的总和）。  
- **数学表达式转化**：将问题转化为数学等式（如k = S/n），能快速定位关键条件。  
- **避免浮点运算**：用乘法代替除法（如判断sum == a[i]*n），避免精度误差。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合了多个优质题解的通用核心实现，它简洁、高效且易理解：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Qerucy的优化思路和ivyjiao的简洁风格，通过预处理总和并遍历检查，时间复杂度O(n)，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <cstdio>

    int main() {
        int t, n;
        scanf("%d", &t);
        while (t--) {
            scanf("%d", &n);
            int sum = 0, a[55];
            for (int i = 0; i < n; ++i) {
                scanf("%d", &a[i]);
                sum += a[i];
            }
            bool found = false;
            for (int i = 0; i < n; ++i) {
                if (sum == a[i] * n) { // 避免浮点运算，直接判断乘法
                    found = true;
                    break;
                }
            }
            puts(found ? "YES" : "NO");
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取测试用例数t，然后对每个测试用例：  
  1. 读取数组长度n和数组元素，同时计算总和sum。  
  2. 遍历数组，检查是否存在元素a[i]满足sum == a[i] * n（即a[i]等于平均值sum/n）。  
  3. 根据检查结果输出YES或NO。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Qerucy（优化版）**
* **亮点**：通过预处理总和避免重复计算，时间复杂度O(n)，代码简洁高效。
* **核心代码片段**：
    ```cpp
    sum=0;
    for(int i=1;i<=n;i++){
        scanf("%lf",&a[i]);
        sum+=a[i];
    }
    bool fg=0;
    for(int i=1;i<=n;i++){
        if((sum-a[i])/(n-1)==a[i]){
            fg=1;
            break;
        }
    }
    ```
* **代码解读**：  
  这段代码先计算总和sum，然后遍历每个元素a[i]，判断（sum - a[i]）/(n-1)是否等于a[i]。等价于判断a[i]是否等于总和的平均值（因为sum = a[i]*(n-1) + a[i] = a[i]*n → sum/n = a[i]）。  
  这里的巧妙之处是用总和减去当前元素，再除以n-1，直接对应操作后的平均值是否等于当前元素。  
* 💡 **学习笔记**：预处理总和能避免重复计算，提升效率！

**题解二：作者ningago**
* **亮点**：通过数学证明明确“至多只需一次操作”，代码逻辑与理论推导紧密结合。
* **核心代码片段**：
    ```cpp
    if(sum % n) {
        printf("NO\n");
        continue;
    }
    bool flag = 0;
    for(int i = 1;i <= n;i++) {
        if(sum / n == a[i])
            flag = 1;
    }
    ```
* **代码解读**：  
  首先判断总和是否能被n整除（sum%n==0），若不能，直接输出NO（因为平均值不是整数，原数组元素都是整数，不可能存在）。若能，遍历数组检查是否存在元素等于sum/n。  
  这里的“sum%n”判断是关键优化，提前排除了不可能的情况，减少了不必要的遍历。  
* 💡 **学习笔记**：提前判断边界条件（如sum是否能被n整除）能减少计算量！

**题解三：作者ivyjiao**
* **亮点**：用“sum == a[i]*n”代替除法，彻底避免浮点精度问题。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        if(sum==a[i]*n){
            printf("YES\n");
            flag=true;
            break;
        }
    }
    ```
* **代码解读**：  
  由于sum = n*k（k是平均值），判断a[i]是否等于k等价于判断sum是否等于a[i]*n。这种乘法形式避免了浮点数运算，完全规避了精度误差（比如sum=5，n=2时，k=2.5，但用除法可能因浮点数精度问题导致判断错误）。  
* 💡 **学习笔记**：用乘法代替除法，是避免浮点误差的常用技巧！

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“如何判断是否存在平均值”，我们设计了一个8位像素风动画，让你“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：像素小侦探找平均值  
  * **核心演示内容**：用像素方块表示数组元素，通过颜色变化和动画演示总和计算、平均值判断的过程。

  * **设计思路简述**：  
    8位像素风（如FC游戏）能营造轻松氛围，像素方块的颜色变化和音效提示能强化关键步骤记忆。例如，找到目标值时的“叮”声和闪烁动画，能让你立刻注意到关键操作。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕下方显示8位风格的像素网格（每个格子代表一个数组元素，颜色随机）。  
        - 顶部显示“总和计算器”（一个动态变化的数字）和“平均值检测器”（一个问号）。  
        - 控制面板有“开始”“单步”“重置”按钮和速度滑块（调节动画速度）。

    2.  **计算总和**：  
        - 像素小侦探（一个戴眼镜的像素角色）从第一个元素出发，每经过一个方块，该方块颜色变浅（表示已计算），总和数字动态增加（如“0→1→3→6”）。  
        - 伴随“滴答”音效（每计算一个元素响一次）。

    3.  **判断平均值**：  
        - 平均值检测器显示“sum/n = ?”，小侦探逐个检查每个元素：  
          - 若元素等于平均值，该方块变为绿色并闪烁，检测器显示“找到！”，播放“叮”的胜利音效。  
          - 若不等于，方块变为灰色，检测器显示“未找到”，播放“噗”的提示音效。

    4.  **结果展示**：  
        - 若找到目标值，所有方块变为绿色并跳动，屏幕显示“YES”和庆祝的像素烟花。  
        - 若未找到，所有方块变为红色，屏幕显示“NO”。

    5.  **交互控制**：  
        - 单步模式：点击“单步”按钮，小侦探逐个检查元素，适合仔细观察。  
        - 自动模式：点击“开始”，动画自动播放，速度由滑块调节（慢→快）。

  * **旁白提示**：  
    - （计算总和时）“看！小侦探在累加所有元素的和，总和是不变的哦～”  
    - （检查元素时）“现在检查第2个元素，它等于平均值吗？”  
    - （找到目标值时）“叮！找到了！这个元素就是平均值，所以可以操作成功～”

<visualization_conclusion>
通过这个像素动画，你不仅能看到总和计算和平均值判断的过程，还能在游戏化的互动中深刻理解问题本质！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下类似问题，巩固“找不变量+数学推导”的解题思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的关键是找到“总和不变”的隐藏性质。类似地，这类思路还适用于：  
    - 操作后奇偶性不变的问题（如翻转硬币问题）。  
    - 操作后模数不变的问题（如取石子游戏）。  
    - 操作后某种对称性保持的问题（如数组元素交换）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1003 铺地毯**  
        * 🗣️ **推荐理由**：考察对问题的抽象能力，需要找到覆盖某点的最后一块地毯，类似本题的“找关键元素”。  
    2.  **洛谷 P1047 校门外的树**  
        * 🗣️ **推荐理由**：通过区间覆盖问题，练习“不变量”思维（如未被覆盖的树的数量）。  
    3.  **洛谷 P1100 高低位交换**  
        * 🗣️ **推荐理由**：考察位运算的数学性质，类似本题的“数学推导”思路。

-----

## 7\. 学习心得与经验分享

<insights_intro>
部分题解作者分享了解题时的小技巧，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者Qerucy)**：“最初我用双重循环计算每个元素外的总和，后来发现可以预处理总和，用总和减去当前元素，这样更高效！”  
> **点评**：Qerucy的经验提醒我们，预处理（如计算总和）能避免重复计算，提升效率。在编程中，多思考“能否用更少的计算量解决问题”是优化的关键！

-----

<conclusion>
本次关于“Everything Everywhere All But One”的分析就到这里。通过数学推导、代码赏析和像素动画，相信你已经掌握了这类问题的核心解法。记住，遇到操作类问题，先找不变量，再用数学表达式推导，最后验证条件——这就是解题的“三板斧”！下次见～ 💪
</conclusion>

---
处理用时：127.47秒
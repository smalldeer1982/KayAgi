# 题目信息

# Array Recovery

## 题目描述

For an array of non-negative integers $ a $ of size $ n $ , we construct another array $ d $ as follows: $ d_1 = a_1 $ , $ d_i = |a_i - a_{i - 1}| $ for $ 2 \le i \le n $ .

Your task is to restore the array $ a $ from a given array $ d $ , or to report that there are multiple possible arrays.

## 说明/提示

In the second example, there are two suitable arrays: $ [2, 8, 5] $ and $ [2, 8, 11] $ .

## 样例 #1

### 输入

```
3
4
1 0 2 5
3
2 6 3
5
0 0 0 0 0```

### 输出

```
1 1 3 8
-1
0 0 0 0 0```

# AI分析结果



---
# 💡 Kay的C++算法解析：Array Recovery 深入学习指南 💡

<introduction>
今天我们来一起分析“Array Recovery”这道C++编程题。本指南将帮助大家梳理题目思路，理解如何从给定的差分绝对值数组`d`恢复原数组`a`，并掌握判断唯一解的关键技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与唯一性判断` (属于“编程技巧应用”分类)

🗣️ **初步分析**：
解决“Array Recovery”的关键在于理解每个`a[i]`的可能取值，并判断是否存在多个合法解。简单来说，`a[i]`的取值由前一项`a[i-1]`和`d[i]`决定，有两种可能：`a[i] = a[i-1] + d[i]`或`a[i] = a[i-1] - d[i]`（因为`d[i]`是绝对值）。但由于`a`是**非负整数数组**，若两种取值都非负且不相等，则说明存在多个解，需输出`-1`；否则取唯一合法值。

- **题解思路**：所有题解的核心思路一致：从`a[1] = d[1]`开始，依次计算每个`a[i]`的可能值。若某一步`a[i-1] - d[i] ≥ 0`且`d[i] ≠ 0`（两种取值都合法且不同），则存在多解；否则取`a[i] = a[i-1] + d[i]`（因为`+d[i]`必然非负）。
- **核心难点**：准确判断“存在多解”的条件（即`a[i-1] - d[i] ≥ 0`且`d[i] ≠ 0`），并在遍历过程中及时终止。
- **可视化设计**：计划采用8位像素风格动画，用不同颜色的像素块表示`a`数组的每个元素。每一步展示`a[i]`的两种可能取值，当发现多解时，对应位置像素块闪烁红色并播放提示音效；否则用绿色像素块逐步构建唯一解。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解在关键步骤处理和逻辑严谨性上表现突出：
</eval_intro>

**题解一：作者binaryBard**
* **点评**：此题解思路清晰，直接抓住“两种取值是否都合法且不同”的核心条件。代码中通过`a1`和`a2`分别计算两种可能，若发现多解则立即输出`-1`。变量命名简洁（如`flag`标记是否多解），边界条件处理严谨（检查`a1`和`a2`是否非负且不同），是竞赛中典型的高效实现。

**题解二：作者Cczzyy20150005**
* **点评**：此题解逻辑简洁，直接通过`a[i-1] - d[i] ≥ 0 && d[i] ≠ 0`判断多解条件，代码结构紧凑。变量`a`直接存储当前计算值，避免冗余操作，适合快速编写和调试。

**题解三：作者ran_qwq**
* **点评**：此题解以“前缀和”思路构建`a`数组（`a[i] = a[i-1] + d[i]`），并在遍历中检查是否存在多解条件。代码简洁，循环内逻辑清晰，适合初学者理解“逐步推导”的过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们需要重点关注以下三个关键点：
</difficulty_intro>

1.  **关键点1：如何判断存在多解？**
    * **分析**：当`a[i-1] - d[i] ≥ 0`且`d[i] ≠ 0`时，`a[i]`有两种合法取值（`a[i-1]+d[i]`和`a[i-1]-d[i]`），且两者不同（因`d[i]≠0`），此时存在多解。例如，若`a[i-1]=8`，`d[i]=3`，则`a[i]`可以是`11`或`5`，均非负且不同，故多解。
    * 💡 **学习笔记**：多解的条件是“前项减当前d值非负且d值不为0”。

2.  **关键点2：如何推导唯一的a数组？**
    * **分析**：当不存在多解时，`a[i]`的唯一合法取值是`a[i-1] + d[i]`（因为`a[i-1]+d[i]`必然非负，而`a[i-1]-d[i]`可能为负或等于`a[i-1]+d[i]`）。例如，若`a[i-1]=1`，`d[i]=3`，则`a[i-1]-d[i]=-2`（非法），故`a[i]=4`。
    * 💡 **学习笔记**：唯一解的推导是“前项加当前d值”的累加过程。

3.  **关键点3：如何处理边界条件（如d[i]=0）？**
    * **分析**：当`d[i]=0`时，`a[i-1]+d[i] = a[i-1]-d[i]`，此时两种取值相同，故唯一。例如，`a[i-1]=5`，`d[i]=0`，则`a[i]=5`（唯一）。
    * 💡 **学习笔记**：d[i]=0时，无需担心多解，直接取前项值即可。

### ✨ 解题技巧总结
- **逐步推导**：从`a[1]`开始，依次计算每个`a[i]`，每一步检查多解条件。
- **提前终止**：一旦发现多解条件，立即输出`-1`并终止后续计算，提升效率。
- **非负性检查**：确保所有`a[i]`非负（但因`a[i] = a[i-1]+d[i]`且`d[i]≥0`，此条件自动满足）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，代码简洁且覆盖所有边界条件。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了binaryBard和Cczzyy20150005的思路，通过遍历检查多解条件，逐步构建`a`数组。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    const int MAX_N = 105;
    int T, n, d[MAX_N], a[MAX_N];

    int main() {
        cin >> T;
        while (T--) {
            cin >> n;
            for (int i = 1; i <= n; ++i) cin >> d[i];
            a[1] = d[1];
            bool has_multiple = false;
            for (int i = 2; i <= n; ++i) {
                // 计算两种可能的a[i]
                int a_plus = a[i-1] + d[i];
                int a_minus = a[i-1] - d[i];
                // 检查是否存在多解（a_minus非负且d[i]≠0）
                if (a_minus >= 0 && d[i] != 0) {
                    has_multiple = true;
                    break;
                }
                a[i] = a_plus; // 唯一合法值
            }
            if (has_multiple) {
                cout << -1 << endl;
            } else {
                for (int i = 1; i <= n; ++i) {
                    cout << a[i] << " ";
                }
                cout << endl;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入，初始化`a[1] = d[1]`。随后遍历`i=2`到`n`，计算`a[i]`的两种可能值。若发现`a_minus`非负且`d[i]≠0`（多解条件），则标记`has_multiple`并终止循环。最后根据标记输出结果。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者binaryBard**
* **亮点**：明确计算两种可能值并直接判断多解，逻辑直白。
* **核心代码片段**：
    ```cpp
    for(int i=2;i<=n;i++){
        int a1=d[i]+a[i-1],a2=a[i-1]-d[i];
        if(a1>=0&&a2>=0&&a1!=a2){
            cout<<-1<<endl;
            flag=1;
            break;
        }else{
            if(a1>=0) a[i]=a1;
            else a[i]=a2;
        }
    }
    ```
* **代码解读**：
    `a1`和`a2`分别表示`a[i]`的两种可能值。若两者均非负且不同（`a1 != a2`），则存在多解，输出`-1`；否则选择非负的那个值（因`a1`必然非负，故实际直接取`a1`）。
* 💡 **学习笔记**：直接比较两种可能值的非负性和是否相等，是判断多解的关键。

**题解二：作者Cczzyy20150005**
* **亮点**：简化判断条件，仅检查`a[i-1]-d[i] >=0`且`d[i]≠0`，代码更简洁。
* **核心代码片段**：
    ```cpp
    for(int i=2;i<=n;i++){
        if(a[i-1]-d[i]>=0&&d[i]!=0){
            puts("-1");
            return;
        }else a[i]=d[i]+a[i-1];
    }
    ```
* **代码解读**：
    若`a[i-1]-d[i] >=0`且`d[i]≠0`，说明存在多解（因为`a[i-1]+d[i]`必然非负，且与`a[i-1]-d[i]`不同），直接输出`-1`；否则取`a[i] = a[i-1]+d[i]`。
* 💡 **学习笔记**：抓住“多解的本质是存在另一个非负解”，简化判断逻辑。

**题解三：作者ran_qwq**
* **亮点**：通过前缀和构建`a`数组，代码极简。
* **核心代码片段**：
    ```cpp
    a[1]=d[1],flag=1;
    for(int i=2;i<=n&&flag;i++){
        if(d[i]&&a[i-1]-d[i]>=0)
            flag=0;
        a[i]=a[i-1]+d[i];
    }
    ```
* **代码解读**：
    `flag`标记是否存在多解。若`d[i]≠0`且`a[i-1]-d[i]>=0`，则`flag=0`（多解）；否则继续累加`d[i]`到`a[i]`。
* 💡 **学习笔记**：前缀和思路是构建唯一解的直接方法，适合快速实现。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解`a`数组的构建过程和多解判断，我们设计一个“像素探险家”主题的8位风格动画，模拟每一步的选择和多解检测。
</visualization_intro>

  * **动画演示主题**：`像素探险家的数组恢复之旅`

  * **核心演示内容**：
    探险家从起点`a[1]`出发，每一步需要选择“向右走`d[i]`步”（`a[i] = a[i-1]+d[i]`）或“向左走`d[i]`步”（`a[i] = a[i-1]-d[i]`）。若向左走后位置仍在“非负大陆”（≥0）且`d[i]≠0`，则触发多解警报；否则只能向右走，最终到达终点。

  * **设计思路简述**：
    8位像素风格（如FC游戏画面）降低学习门槛；关键步骤的音效（如选择时的“叮”声、多解时的“警报声”）强化记忆；路径的动态展示让抽象的数组构建变得具象。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是像素网格（表示`a`数组的位置，每个位置用方块表示，初始为灰色）；右侧是控制面板（单步/自动按钮、速度滑块）。
        - 背景音乐：8位风格的轻快旋律。

    2.  **初始状态**：
        - `a[1]`的方块变为绿色（表示已确定），显示数值`d[1]`。
        - 队列显示当前处理到第`i`步（如`i=2`）。

    3.  **核心步骤演示**：
        - **计算两种可能**：当前`a[i-1]`的方块闪烁，弹出两个箭头（右箭头标`+d[i]`，左箭头标`-d[i]`）。
        - **检查多解**：
          - 若左箭头指向的位置（`a[i-1]-d[i]`）≥0且`d[i]≠0`，左箭头变红并播放“警报”音效，网格显示“多解！”。
          - 否则，仅右箭头有效（绿色），`a[i]`的方块变为绿色并显示数值`a[i-1]+d[i]`。
        - **数据更新**：每完成一步，`a`数组的方块依次变绿，数值实时更新。

    4.  **结果展示**：
        - 若成功构建唯一数组，终点方块播放“胜利”音效（上扬音调），所有方块闪烁金色。
        - 若多解，屏幕中央显示`-1`，背景变红并播放短促警报。

  * **旁白提示**：
    - “现在处理第`i`步，`a[i-1]`的值是`x`，`d[i]`是`y`。”
    - “看！向左走会到`x-y`，如果它≥0且`y≠0`，就会有两个解哦～”
    - “只能向右走啦！`a[i]`确定是`x+y`。”

<visualization_conclusion>
通过这样的动画，我们可以直观看到每一步的选择过程，理解多解的触发条件，比单纯看代码更易掌握核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可以尝试以下题目，巩固“差分与唯一性判断”的思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    本题的核心是“根据差分绝对值反推原数组并判断唯一性”，类似思路可用于：
    - 恢复温度变化序列（已知每日温差，判断是否唯一）。
    - 路径唯一性判断（已知每段路径长度的绝对值，判断是否存在多条非负路径）。
    - 股票价格波动恢复（已知每日涨跌幅绝对值，判断价格是否唯一）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1314** - `聪明的质监员`
          * 🗣️ **推荐理由**：考察差分与二分结合，需理解前缀和与差值的关系，与本题的“差分反推”思路相关。
    2.  **洛谷 P2367** - `语文成绩`
          * 🗣️ **推荐理由**：通过差分快速修改区间值，巩固差分的基础应用，适合练习数组操作。
    3.  **洛谷 P3406** - `海底高铁`
          * 🗣️ **推荐理由**：涉及前缀和与差分数组的转换，需灵活运用差分思想解决实际问题。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自作者xiaofeng_and_xiaoyu)**：“我最初将条件写成`l[i]>=t[i-1]`，导致WA了两次。后来发现应该改成`l[i]>t[i-1]`，因为当`l[i]==t[i-1]`时，`a[i-1]-d[i]=0`，仍可能导致多解（若`d[i]≠0`）。”
>
> **点评**：这个经验提醒我们，边界条件的处理必须严格。在判断多解时，`a[i-1]-d[i]≥0`包含等于0的情况（如`a[i-1]=5`，`d[i]=5`，则`a[i-1]-d[i]=0`非负，此时若`d[i]≠0`，仍存在多解）。因此，条件中的“≥”不能遗漏。

-----

<conclusion>
本次关于“Array Recovery”的分析就到这里。通过理解多解的判断条件和逐步推导`a`数组的过程，相信大家已掌握核心技巧。记得多练习拓展题目，巩固所学！下次见～💪
</conclusion>

-----

---
处理用时：145.81秒
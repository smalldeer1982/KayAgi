# 题目信息

# ACM ICPC

## 题目描述

In a small but very proud high school it was decided to win ACM ICPC. This goal requires to compose as many teams of three as possible, but since there were only $ 6 $ students who wished to participate, the decision was to build exactly two teams.

After practice competition, participant number $ i $ got a score of $ a_{i} $ . Team score is defined as sum of scores of its participants. High school management is interested if it's possible to build two teams with equal scores. Your task is to answer that question.

## 说明/提示

In the first sample, first team can be composed of $ 1 $ st, $ 2 $ nd and $ 6 $ th participant, second — of $ 3 $ rd, $ 4 $ th and $ 5 $ th: team scores are $ 1+3+1=2+1+2=5 $ .

In the second sample, score of participant number $ 6 $ is too high: his team score will be definitely greater.

## 样例 #1

### 输入

```
1 3 2 1 2 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
1 1 1 1 1 99
```

### 输出

```
NO
```

# AI分析结果



---
# 💡 Kay的C++算法解析：ACM ICPC 深入学习指南 💡

<introduction>
今天我们来分析“ACM ICPC”这道题。题目要求将6个学生分成两个三人组，使得两组总分相等。本指南会带大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举算法

🗣️ **初步分析**：
解决这道题的关键是“枚举”——由于只有6个学生，我们可以列出所有可能的三人组合，检查是否存在两组和相等的情况。枚举就像“地毯式搜索”，把所有可能的候选解逐一验证。本题中，枚举所有三人组的和是否等于总和的一半，即可判断是否可行。

- **题解思路对比**：不同题解均采用枚举，但实现方式不同：有的用全排列（如Dog_Two），有的用三重循环（如hello2020），有的用DFS（如AmaZingFantasy）。核心都是枚举三人组，差异在枚举方式的效率和代码简洁性。
- **核心算法流程**：先计算总和，若为奇数直接输出NO；若为偶数，目标和为总和的一半，枚举所有三人组，检查和是否等于目标和。
- **可视化设计**：用8位像素风格展示6个学生（像素方块），每次枚举选中的三个方块高亮（如黄色），计算和时显示数值，匹配目标和时播放“叮”音效并闪烁绿色。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选了以下优质题解（≥4星）：
</eval_intro>

**题解一：hello2020（赞：2）**
* **点评**：此题解思路简洁直接，采用三重循环枚举不重复的三人组（i<j<k），时间复杂度仅O(20)（C(6,3)=20），效率极高。代码变量名清晰（如sum表示总和），结构工整，边界处理严谨（先判断总和奇偶）。实践价值高，适合竞赛快速实现。

**题解二：chufuzhe（赞：4）**
* **点评**：此题解通过三重循环枚举所有不同下标的三人组（i,j,k互不相同），覆盖所有可能情况。代码中使用`bool ans`标记结果，逻辑清晰。虽存在重复枚举（如i=0,j=1,k=2与i=1,j=0,k=2视为不同情况），但不影响正确性，适合理解基础枚举逻辑。

**题解三：Dog_Two（赞：3）**
* **点评**：此题解利用全排列（`next_permutation`）枚举所有顺序，检查前三个数的和是否等于目标和。代码简洁，利用标准库函数减少手动枚举的复杂度。虽时间复杂度稍高（6! = 720），但实现优雅，适合学习排列枚举的应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于高效枚举所有可能的三人组，并处理边界条件：
</difficulty_intro>

1.  **关键点1：如何避免重复枚举三人组**  
    * **分析**：若直接枚举所有i,j,k（i≠j≠k），会重复计算同一组合的不同顺序（如i=0,j=1,k=2与i=1,j=0,k=2）。优质题解（如hello2020）通过限制i<j<k，确保每个组合仅枚举一次，避免重复。  
    * 💡 **学习笔记**：枚举组合时，限制下标递增（i<j<k）可避免重复，提升效率。

2.  **关键点2：处理总和为奇数的情况**  
    * **分析**：若总和s为奇数，无法分成两个整数和的三人组（s/2非整数），直接输出NO。这是重要的边界条件，所有优质题解均优先处理此情况。  
    * 💡 **学习笔记**：先判断总和奇偶性，可提前剪枝，减少无效枚举。

3.  **关键点3：选择高效的枚举方式**  
    * **分析**：6个数的三人组共有C(6,3)=20种组合（不考虑顺序）。hello2020的i<j<k循环仅需20次判断，是最高效的方式；全排列需720次，但代码更简洁；DFS需64次递归，适合理解搜索思想。  
    * 💡 **学习笔记**：小数据量下，枚举方式的选择需平衡效率与代码复杂度。

### ✨ 解题技巧总结
- **提前剪枝**：先判断总和是否为偶数，减少无效计算。  
- **组合枚举优化**：通过i<j<k避免重复枚举，提升效率。  
- **利用标准库**：如`next_permutation`简化全排列枚举，适合代码简洁性优先的场景。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择hello2020的解法作为通用核心实现，因其效率最高且代码简洁。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了hello2020的思路，通过i<j<k枚举不重复的三人组，高效判断是否存在和为目标的组合。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int a[7], sum = 0;
        for (int i = 1; i <= 6; ++i) {
            cin >> a[i];
            sum += a[i];
        }
        if (sum % 2 != 0) { // 总和为奇数，直接输出NO
            cout << "NO" << endl;
            return 0;
        }
        int target = sum / 2;
        // 枚举所有i<j<k的三人组
        for (int i = 1; i <= 4; ++i) {
            for (int j = i + 1; j <= 5; ++j) {
                for (int k = j + 1; k <= 6; ++k) {
                    if (a[i] + a[j] + a[k] == target) {
                        cout << "YES" << endl;
                        return 0;
                    }
                }
            }
        }
        cout << "NO" << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取6个数并计算总和。若总和为奇数，直接输出NO。否则，目标和为总和的一半。通过三重循环枚举i<j<k的三人组（共20种），检查其和是否等于目标和，找到则输出YES，否则输出NO。

---
<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>

**题解一：hello2020**
* **亮点**：通过i<j<k枚举不重复的三人组，时间复杂度仅O(20)，效率极高。
* **核心代码片段**：
    ```cpp
    for (int i=1;i<=4;i++)
      for (int j=i+1;j<=5;j++)
        for (int k=j+1;k<=6;k++)
          if (a[i]+a[j]+a[k]==sum){
            cout<<"YES"<<endl;
            return 0;
          }
    ```
* **代码解读**：  
  外层循环i从1到4（因为j和k需要更大），j从i+1到5，k从j+1到6。这样i<j<k保证每个三人组只枚举一次。若找到和为目标的组合，立即输出YES并结束程序。  
  👉 思考：为什么i的上限是4？因为j至少是i+1（≥2），k至少是j+1（≥3），当i=4时，j=5，k=6，覆盖最后一个组合。
* 💡 **学习笔记**：限制下标递增（i<j<k）是避免重复枚举的关键技巧。

**题解二：Dog_Two**
* **亮点**：利用`next_permutation`生成全排列，代码简洁，适合理解排列枚举。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+6);
    bool if_ans=false;
    do{
        int val=a[1]+a[2]+a[3];
        if_ans=val==sum/2;	
    }while(next_permutation(a+1,a+6) and !if_ans);
    ```
* **代码解读**：  
  先对数组排序（`next_permutation`需要有序输入），然后循环生成下一个排列，检查前三个数的和是否等于目标。若找到则标记`if_ans`为true，退出循环。  
  👉 思考：为什么需要排序？因为`next_permutation`按字典序生成排列，初始排序后能覆盖所有可能的排列。
* 💡 **学习笔记**：标准库函数（如`next_permutation`）可简化枚举逻辑，提升代码简洁性。

**题解三：AmaZingFantasy**
* **亮点**：使用DFS枚举选或不选每个数，适合理解搜索算法的回溯思想。
* **核心代码片段**：
    ```cpp
    void dfs(l step,l sum){
        if(step >= 6 || sum > he/2) return;
        if(cnt==3 && sum==he/2){
            cout<<"YES";
            exit(0);
        }
        cnt++;
        dfs(step+1,sum+arr[step]);
        cnt--;
        dfs(step+1,sum);
    }
    ```
* **代码解读**：  
  `dfs`函数递归处理每个数（step表示当前处理的数），选择该数则`cnt+1`、`sum+arr[step]`，否则不选。当选中3个数且和为目标时，输出YES并退出。  
  👉 思考：`exit(0)`的作用是什么？直接终止整个程序，避免继续搜索。
* 💡 **学习笔记**：DFS通过回溯（选/不选）枚举所有可能，适合理解递归与剪枝。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举过程，我们设计一个“像素分组挑战”动画，用8位风格展示枚举三人组的过程！
</visualization_intro>

  * **动画演示主题**：像素分组大挑战——帮6个像素小人找到平衡的两组！
  * **核心演示内容**：展示枚举所有三人组的过程，高亮选中的三人，计算和，匹配目标时庆祝。
  * **设计思路简述**：8位像素风（FC游戏画面）营造轻松氛围；选中的小人用黄色闪烁，和计算时显示数字；匹配目标时绿色高亮并播放“叮”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        屏幕中央6个像素小人（红、蓝、绿等8色调）排成一行，顶部显示“目标和：X”（X为总和的一半）。控制面板有“开始”“单步”“重置”按钮，速度滑块（慢/中/快）。

    2.  **算法启动**：  
        点击“开始”，背景播放8位BGM（类似《超级玛丽》的轻快音乐）。第一个三人组（如i=1,j=2,k=3）的小人变黄并闪烁，头顶显示和值（如a[1]+a[2]+a[3]）。

    3.  **枚举过程**：  
        单步模式下，每点击一次“单步”，切换到下一个三人组（i<j<k），新选中的小人变黄，旧的恢复原色。自动模式下，按滑块速度自动切换，每次切换伴随“滴答”音效（类似秒表）。

    4.  **匹配成功**：  
        当某三人组和等于目标时，所有6个小人变绿并跳跃（像素动画），播放“胜利”音效（上扬的“叮~”），顶部显示“YES！成功分组！”。

    5.  **匹配失败**：  
        枚举完所有组合仍无匹配时，小人变灰，播放“呜呜”音效，顶部显示“NO，无法分组”。

  * **旁白提示**：  
    - （单步时）“现在检查第1、2、3号小人，他们的和是5，目标和是5吗？”  
    - （匹配时）“看！这三个小人的和正好等于目标，成功分组啦！”  
    - （失败时）“所有组合都检查过了，没有符合条件的，下次再试试吧~”

<visualization_conclusion>
通过这个动画，我们能“看”到枚举的每一步，理解为什么某些组合被选中，以及如何快速判断是否可行。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
枚举算法在小数据量问题中非常实用，以下是类似问题的拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    枚举适用于数据规模小（如n≤20）的组合、排列问题。例如：  
    - 选数问题（如从n个数中选k个，和为特定值）。  
    - 子集和问题（判断是否存在子集和为目标）。  
    - 排列验证（如检查排列是否满足特定条件）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036 选数**  
        * 🗣️ **推荐理由**：从n个数中选k个，求它们的和是否为质数。需枚举所有组合，与本题思路类似。  
    2.  **洛谷 P1157 组合的输出**  
        * 🗣️ **推荐理由**：输出所有k元组合，练习i<j<k的枚举方式，巩固组合枚举技巧。  
    3.  **洛谷 P1706 全排列问题**  
        * 🗣️ **推荐理由**：输出所有n个数的排列，练习`next_permutation`或递归生成排列，与Dog_Two的解法相关。

-----

## 7\. 学习心得与经验分享

<insights_intro>
部分题解提到了解题中的小技巧，值得借鉴：
</insights_intro>

> **参考经验 (来自 hello2020)**：“tai水了这题，暴力模拟”  
> **点评**：hello2020的经验提醒我们，小数据量问题中，暴力枚举往往是最直接有效的方法。无需复杂算法，理清枚举逻辑即可快速解决问题。这也鼓励我们，遇到问题时先评估数据规模，再选择合适的算法。

-----

<conclusion>
本次关于“ACM ICPC”的分析就到这里。通过枚举所有可能的三人组，我们能轻松判断是否可分组。记住，小数据量下暴力枚举是利器！多练习类似题目，你会更熟练哦~ 下次见！💪
</conclusion>

---
处理用时：140.00秒
# 题目信息

# Months and Years

## 题目描述

Everybody in Russia uses Gregorian calendar. In this calendar there are $ 31 $ days in January, $ 28 $ or $ 29 $ days in February (depending on whether the year is leap or not), $ 31 $ days in March, $ 30 $ days in April, $ 31 $ days in May, $ 30 $ in June, $ 31 $ in July, $ 31 $ in August, $ 30 $ in September, $ 31 $ in October, $ 30 $ in November, $ 31 $ in December.

A year is leap in one of two cases: either its number is divisible by $ 4 $ , but not divisible by $ 100 $ , or is divisible by $ 400 $ . For example, the following years are leap: $ 2000 $ , $ 2004 $ , but years $ 1900 $ and $ 2018 $ are not leap.

In this problem you are given $ n $ ( $ 1<=n<=24 $ ) integers $ a_{1},a_{2},...,a_{n} $ , and you have to check if these integers could be durations in days of $ n $ consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is $ a_{1} $ days, duration of the next month is $ a_{2} $ days, and so on.

## 说明/提示

In the first example the integers can denote months July, August, September and October.

In the second example the answer is no, because there are no two consecutive months each having $ 30 $ days.

In the third example the months are: February (leap year) — March — April – May — June.

In the fourth example the number of days in the second month is $ 28 $ , so this is February. March follows February and has $ 31 $ days, but not $ 30 $ , so the answer is NO.

In the fifth example the months are: December — January — February (non-leap year).

## 样例 #1

### 输入

```
4
31 31 30 31
```

### 输出

```
Yes

```

## 样例 #2

### 输入

```
2
30 30
```

### 输出

```
No

```

## 样例 #3

### 输入

```
5
29 31 30 31 30
```

### 输出

```
Yes

```

## 样例 #4

### 输入

```
3
31 28 30
```

### 输出

```
No

```

## 样例 #5

### 输入

```
3
31 31 28
```

### 输出

```
Yes

```

# AI分析结果

# 💡 Kay的C++算法解析：Months and Years 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（打表法）

🗣️ **初步分析**：  
解决“Months and Years”这道题，关键在于**打表法**——就像我们查字典时，把所有正确的“单词”（合法连续月份天数序列）都列出来，然后看输入的“单词”是否在字典里。  
具体来说，题目要求判断给定的n个连续月份天数是否合法（符合格里高利历）。由于n≤24，我们可以**预先列出所有可能的合法连续24个月的天数序列**（覆盖平年、闰年的组合，比如平年+平年+闰年+平年+平年），然后用字符串匹配的方式快速判断输入序列是否在表中。  

**核心难点**：如何覆盖所有可能的合法连续月份序列（比如跨年份、包含闰年的情况）？  
**解决方案**：打表时包含平年、闰年的组合（例如，平年的12个月+平年的12个月+闰年的12个月+平年的12个月+平年的12个月），这样连续24个月的所有可能都能被覆盖。  

**可视化设计思路**：  
我们可以设计一个**复古字典查找动画**：  
- 背景是一本8位像素风格的“月份字典”（显示打表的字符串）；  
- 输入的序列是一张小纸条，动画展示小纸条在字典中“滑动”查找的过程；  
- 找到时，字典中对应的子串会高亮（比如变成黄色），伴随“叮”的像素音效；  
- 没找到时，屏幕显示“No”，伴随低沉的“嘟嘟”声。  
- 控制面板有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块，让学习者可以控制动画节奏。


## 2. 精选优质题解参考

### 题解一：（来源：清小秋ovo）  
* **点评**：这份题解的思路**极其简洁**，直接将连续几年的月份天数（带空格）连成一个字符串，然后用`string::find`函数判断输入序列是否是其子串。代码只有10行左右，却完美解决了问题。其亮点在于**打表的全面性**（覆盖了平年、闰年的组合）和**字符串操作的巧妙性**（用`getline`读入带空格的输入，避免了拆分数据的麻烦）。对于新手来说，这是最容易理解和模仿的解法。

### 题解二：（来源：荷叶下）  
* **点评**：此题解用**不带空格的字符串**打表（比如“312831...”），然后循环读入每个天数并拼接成字符串，再用`find`查找。亮点在于**输入处理的灵活性**（即使输入没有空格，也能正确拼接）和**代码的规范性**（使用了命名空间和快读快写优化）。虽然快读快写对新手来说有点复杂，但整体思路清晰，适合学习字符串拼接的技巧。

### 题解三：（来源：䒛夢）  
* **点评**：此题解用**四个数组**分别存储不同年份组合的月份天数（比如平年+闰年、闰年+平年等），然后遍历数组检查输入序列是否存在。亮点在于**覆盖所有可能的年份组合**（确保没有遗漏）和**逻辑的严谨性**（用布尔变量标记是否合法）。虽然代码较长，但思路直观，适合学习如何用数组处理多情况问题。


## 3. 核心难点辨析与解题策略

### 1. 如何覆盖所有可能的合法连续月份序列？  
**分析**：连续24个月可能涉及平年、闰年的组合（比如从平年的12月到闰年的1月）。解决方案是**打表时包含平年、闰年的组合**（例如，平年的12个月+平年的12个月+闰年的12个月+平年的12个月+平年的12个月），这样所有可能的连续24个月序列都能被覆盖。  
💡 **学习笔记**：打表的关键是“全面”——要考虑所有可能的输入情况。

### 2. 如何处理输入的空格？  
**分析**：输入的天数之间有空格（比如样例1的“31 31 30 31”），需要正确读取这些数据。解决方案有两种：①用`getline`读入一整行（带空格）；②循环读入每个数，然后拼接成字符串（不带空格）。  
💡 **学习笔记**：`getline`函数可以读取带空格的字符串，但要注意处理前面的换行符（用`cin.ignore()`）。

### 3. 如何高效查找子串？  
**分析**：字符串的`find`函数可以快速判断一个子串是否存在，时间复杂度为O(mn)（m是母串长度，n是子串长度）。对于本题的小数据（母串长度约100，子串长度≤24），这种方法完全足够。  
💡 **学习笔记**：`string::find`函数是处理子串查找的“神器”，记得它的返回值是`string::npos`表示没找到。


### ✨ 解题技巧总结  
- **打表法**：对于数据范围小、情况有限的问题，打表是最直接有效的方法（比如本题的n≤24）。  
- **字符串操作**：`getline`（读带空格的字符串）、`+`（拼接字符串）、`find`（子串查找）是处理字符串问题的常用技巧。  
- **边界条件处理**：要注意输入中的换行符（用`cin.ignore()`），以及打表时的年份组合（覆盖平年、闰年）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了清小秋ovo和makerlife的题解思路，使用带空格的字符串打表，代码简洁且易于理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main() {
      int n;
      string input;
      cin >> n;
      cin.ignore(); // 忽略n后面的换行符
      getline(cin, input); // 读入带空格的输入序列

      // 打表：平年+平年+闰年+平年+平年的连续月份天数（带空格）
      string table = "31 28 31 30 31 30 31 31 30 31 30 31 "
                     "31 28 31 30 31 30 31 31 30 31 30 31 "
                     "31 29 31 30 31 30 31 31 30 31 30 31 "
                     "31 28 31 30 31 30 31 31 30 31 30 31 "
                     "31 28 31 30 31 30 31 31 30 31 30 31 ";

      if (table.find(input) != string::npos) {
          cout << "Yes" << endl;
      } else {
          cout << "No" << endl;
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. 读入n（虽然n没用，但需要读入）；  
  2. 用`getline`读入带空格的输入序列；  
  3. 打表：将连续几年的月份天数（带空格）连成一个字符串；  
  4. 用`find`函数判断输入序列是否是表中的子串，输出结果。


### 针对各优质题解的片段赏析

#### 题解一（来源：清小秋ovo）  
* **亮点**：用`getline`读入带空格的输入，避免了拆分数据的麻烦。  
* **核心代码片段**：  
  ```cpp
  cin >> num;
  cin.ignore();
  getline(cin, b);
  string month = "31 28 31 30 31 30 31 31 30 31 30 31 ..."; // 省略部分
  if (month.find(b) != string::npos) {
      cout << "Yes" << endl;
  } else {
      cout << "No" << endl;
  }
  ```  
* **代码解读**：  
  - `cin.ignore()`：忽略`num`后面的换行符，否则`getline`会读入空行；  
  - `getline(cin, b)`：读入带空格的输入序列（比如“31 31 30 31”）；  
  - `month.find(b)`：查找`b`是否是`month`的子串。  
* 💡 **学习笔记**：`getline`是处理带空格输入的“神器”，但要记得处理前面的换行符。

#### 题解二（来源：荷叶下）  
* **亮点**：用循环读入每个天数，拼接成不带空格的字符串。  
* **核心代码片段**：  
  ```cpp
  string s;
  for (int i = 1; i <= n; ++i) {
      string s1;
      cin >> s1;
      s += s1; // 拼接成不带空格的字符串（比如“31313031”）
  }
  string mon = "312931303130313130313031..."; // 省略部分
  if (mon.find(s) == string::npos) {
      printf("NO");
  } else {
      printf("YES");
  }
  ```  
* **代码解读**：  
  - 循环读入每个天数（`s1`），然后用`+`拼接成字符串`s`（比如输入“31 31 30 31”会变成“31313031”）；  
  - `mon.find(s)`：查找`s`是否是`mon`的子串（`mon`是不带空格的打表字符串）。  
* 💡 **学习笔记**：字符串拼接是处理多个数据的常用技巧，`+`运算符可以方便地拼接字符串。

#### 题解三（来源：䒛夢）  
* **亮点**：用数组存储不同年份组合的月份天数，遍历检查。  
* **核心代码片段**：  
  ```cpp
  const int mon1[] = {0, 31, 29, 31, 30, ...}; // 平年+闰年的组合
  const int mon2[] = {0, 31, 28, 31, 30, ...}; // 闰年+平年的组合
  // 省略mon3、mon4数组

  for (int i = 1; i <= 24; ++i) {
      bool v = true;
      for (int j = 1; j <= n; ++j) {
          if (a[j] != mon1[i + j - 1]) { // 检查输入序列是否匹配mon1的连续n项
              v = false;
              break;
          }
      }
      if (v) {
          printf("Yes");
          return 0;
      }
  }
  ```  
* **代码解读**：  
  - `mon1`、`mon2`等数组存储不同年份组合的月份天数（比如`mon1`是平年的12个月+闰年的12个月）；  
  - 外层循环遍历数组的起始位置（`i`），内层循环检查输入序列（`a[j]`）是否匹配数组的连续n项（`mon1[i+j-1]`）；  
  - 如果找到匹配的序列，输出“Yes”并结束程序。  
* 💡 **学习笔记**：数组是处理多情况问题的有效结构，遍历数组可以覆盖所有可能的情况。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：复古字典查找游戏  
**设计思路**：采用8位像素风格（类似FC红白机），将打表的字符串比作“字典”，输入序列比作“小纸条”，通过动画展示“小纸条”在“字典”中查找的过程，增强学习的趣味性。


### 📍 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示一本像素风格的“月份字典”（背景是棕色，文字是白色，带空格的打表字符串）；  
   - 屏幕右侧显示控制面板：“开始/暂停”按钮（绿色）、“单步执行”按钮（蓝色）、“重置”按钮（红色）、速度滑块（从“慢”到“快”）；  
   - 屏幕底部显示输入的序列（比如“31 31 30 31”），用黄色像素块包围。  
   - 播放8位风格的背景音乐（轻快的钢琴声）。

2. **算法启动**：  
   - 点击“开始”按钮，“小纸条”（输入序列）从屏幕右侧滑入“字典”区域；  
   - “字典”中的文字开始滚动，寻找与“小纸条”匹配的子串。

3. **核心查找过程**：  
   - **单步执行**：每点击一次“单步”按钮，“小纸条”向右移动一位，检查当前位置是否匹配；  
   - **高亮提示**：如果当前位置的字符匹配，“字典”中的对应字符会变成黄色；如果不匹配，变成红色；  
   - **音效反馈**：匹配时播放“叮”的音效（频率较高），不匹配时播放“嗒”的音效（频率较低）。

4. **结果展示**：  
   - 如果找到匹配的子串，“字典”中的对应子串会持续高亮（黄色），屏幕顶部显示“找到啦！”（绿色文字），伴随“胜利”音效（上扬的音调）；  
   - 如果没找到，屏幕顶部显示“没找到哦～”（红色文字），伴随“失败”音效（短促的低音）。

5. **交互控制**：  
   - 速度滑块：调整“字典”滚动的速度（慢：1帧/秒，快：10帧/秒）；  
   - 重置按钮：将“小纸条”和“字典”恢复到初始状态，重新开始查找。


### 📝 旁白提示（动画中的文字气泡）  
- “现在我们要查的序列是‘31 31 30 31’，看看它在字典里有没有～”（开始时）；  
- “当前位置的字符是‘31’，和小纸条的第一个字符匹配！”（匹配时）；  
- “当前位置的字符是‘28’，和小纸条的第二个字符‘31’不匹配，继续找～”（不匹配时）；  
- “找到啦！这个序列在字典里存在，所以输出‘Yes’！”（成功时）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路/技巧迁移  
打表法不仅能解决本题，还能解决以下问题：  
1. **进制转换**：比如将十进制数转换为二进制数，可以预先打表存储0-9的二进制表示；  
2. **日期计算**：比如计算某一天是星期几，可以预先打表存储每个月的天数和星期偏移；  
3. **简单枚举**：比如计算1-100的质数，可以预先打表存储所有质数。


### 📚 练习推荐 (洛谷)  
1. **洛谷 P1014** - 进制转换  
   🗣️ **推荐理由**：这道题需要将十进制数转换为任意进制数，打表存储0-35的字符表示（比如10→A，11→B）可以简化代码。  
2. **洛谷 P1551** - 亲戚  
   🗣️ **推荐理由**：虽然这道题主要考察并查集，但打表存储每个节点的父节点是并查集的核心操作，适合学习打表的应用。  
3. **洛谷 P2089** - 烤鸡  
   🗣️ **推荐理由**：这道题需要枚举所有可能的配料组合，打表存储所有可能的组合（比如10种配料，每种1-3克）可以快速判断是否符合条件。


## 7. 学习心得与经验分享 (若有)

### 📌 参考经验（来自清小秋ovo）  
“与其写一堆复杂的判断和模拟，打表所需的代码量少之又少。”  
**点评**：这说明**打表法是处理小数据范围问题的“捷径”**。当问题的情况有限时，打表可以避免复杂的逻辑判断，让代码更简洁、易读。

### 📌 参考经验（来自䒛夢）  
“看到同学的题解后，我瞬间觉得我又行了，这种题你是可以用打表的。”  
**点评**：这说明**借鉴他人思路很重要**。当自己没有思路时，看看别人的题解，可以开拓思维，找到解决问题的方法。


## 🎉 结语  
本次关于“Months and Years”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握打表法和字符串操作的技巧。记住，**编程的本质是解决问题，而打表法是解决小数据问题的“神器”**。下次我们再一起探索新的编程挑战！💪

---
处理用时：170.68秒
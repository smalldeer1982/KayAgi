# 题目信息

# Run For Your Prize

## 题目描述

You and your friend are participating in a TV show "Run For Your Prize".

At the start of the show $ n $ prizes are located on a straight line. $ i $ -th prize is located at position $ a_{i} $ . Positions of all prizes are distinct. You start at position $ 1 $ , your friend — at position $ 10^{6} $ (and there is no prize in any of these two positions). You have to work as a team and collect all prizes in minimum possible time, in any order.

You know that it takes exactly $ 1 $ second to move from position $ x $ to position $ x+1 $ or $ x-1 $ , both for you and your friend. You also have trained enough to instantly pick up any prize, if its position is equal to your current position (and the same is true for your friend). Carrying prizes does not affect your speed (or your friend's speed) at all.

Now you may discuss your strategy with your friend and decide who will pick up each prize. Remember that every prize must be picked up, either by you or by your friend.

What is the minimum number of seconds it will take to pick up all the prizes?

## 说明/提示

In the first example you take all the prizes: take the first at $ 1 $ , the second at $ 2 $ and the third at $ 8 $ .

In the second example you take the first prize in $ 1 $ second and your friend takes the other in $ 5 $ seconds, you do this simultaneously, so the total time is $ 5 $ .

## 样例 #1

### 输入

```
3
2 3 9
```

### 输出

```
8
```

## 样例 #2

### 输入

```
2
2 999995
```

### 输出

```
5
```

# AI分析结果

# 💡 Kay的C++算法解析：Run For Your Prize 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy）+ 模拟思维


🗣️ **初步分析**：  
解决“Run For Your Prize”的关键，就像**分蛋糕游戏**——桌上的蛋糕（奖品）散放在一条长桌（数轴）上，你站在桌头（位置1），朋友站在桌尾（位置1e6）。要最快把所有蛋糕吃完，最好的办法是：**每个蛋糕给离它最近的人拿**（你或朋友）。这样，最后一个拿到蛋糕的人用的时间，就是你们的总时间（因为你们同时开始拿）。  

**核心思路**：  
- 对于每个奖品位置`a[i]`，计算你拿到它的时间（`a[i]-1`，从1走到`a[i]`）和朋友拿到它的时间（`1e6 - a[i]`，从1e6走到`a[i]`），取较小值（谁离得近谁拿）。  
- 所有奖品的“最小拿取时间”中的**最大值**，就是答案（因为最慢的那个决定了总时间）。  

**核心难点**：  
为什么总时间是“最大的最小时间”？比如，假设奖品A需要3秒，奖品B需要5秒，那么即使A先拿完，也要等B拿完才算完成，所以总时间是5秒。  

**可视化设计思路**：  
用**8位像素风**展示数轴（1到1e6），你用红色像素块（位置1），朋友用蓝色像素块（位置1e6），奖品用黄色像素块。动画中，两人同时向中间移动，每走一步（时间+1），如果碰到奖品，奖品会变成对应颜色（红/蓝），并弹出“收集成功”的文字提示。**高亮当前时间**和**剩余奖品数量**，让你清楚看到“最慢的那个奖品”是如何决定总时间的。  


## 2. 精选优质题解参考

### 题解一：Yaixy的贪心优化版（5星）  
* **点评**：  
  这份题解的思路**像一把“手术刀”**——直接切中问题核心！作者通过“中点判断”（mid=500000.5），把奖品分成两部分：左边的给你拿（时间`a[i]-1`），右边的给朋友拿（时间`1e6 - a[i]`）。代码简洁到极致（只有10行核心逻辑），却完美解决了问题。**亮点**：用中点代替每次计算“谁离得近”，减少了重复判断，效率更高。  

### 题解二：Anguei的模拟版（4星）  
* **点评**：  
  这是**最直观的“笨方法”**，却特别适合新手理解！作者用数组`a[t]`标记奖品位置，然后让你（从1开始）和朋友（从1e6开始）同时向中间走，每走一步统计收集的奖品数量，直到收集完所有奖品。**亮点**：代码像“动画剧本”，把“两人走步”的过程直接写成循环，让你一眼就能看懂“时间是怎么算的”。  

### 题解三：Moon_Lighter的排序版（4星）  
* **点评**：  
  作者的思路**像“整理玩具”**——把每个奖品的“最小拿取时间”算出来，排序后取最大的那个。代码只有15行，却把“贪心”的逻辑体现得淋漓尽致。**亮点**：用`sort`函数简化了“找最大值”的过程，适合学习“如何用排序解决极值问题”。  


## 3. 核心难点辨析与解题策略

### 1. 为什么总时间是“最大的最小时间”？  
* **分析**：  
  假设你有3个奖品，拿取时间分别是2秒、3秒、5秒。即使前两个奖品2秒、3秒就拿完了，也要等第3个奖品5秒拿完才算完成。所以，**总时间由“最慢的那个奖品”决定**。  
* 💡 **学习笔记**：  
  解决“同时完成多个任务”的问题，往往要找“最长的那个任务时间”。  


### 2. 如何快速判断“谁离奖品更近”？  
* **分析**：  
  奖品`a[i]`的中点是`(1 + 1e6)/2 = 500000.5`。如果`a[i] ≤ 500000`，你离得近（时间`a[i]-1`）；如果`a[i] > 500000`，朋友离得近（时间`1e6 - a[i]`）。**亮点**：用中点代替每次计算“距离差”，减少了计算量。  
* 💡 **学习笔记**：  
  对于“两端点问题”，中点是一个重要的“分界点”，可以快速划分责任。  


### 3. 模拟方法的效率如何？  
* **分析**：  
  模拟方法（两人向中间走）的时间复杂度是`O(1e6)`，而`1e6`次循环在C++中是完全可以通过的（因为1秒可以处理约1e8次循环）。但贪心方法的时间复杂度是`O(n)`（`n`是奖品数量），比模拟更快。**亮点**：模拟方法适合理解问题，贪心方法适合优化效率。  
* 💡 **学习笔记**：  
  当数据范围允许时，“笨方法”也是好方法；当数据范围大时，需要找“聪明方法”。  


### ✨ 解题技巧总结  
- **贪心策略**：每个奖品给离得近的人，总时间由最远的奖品决定。  
- **中点分界**：用中点快速判断“谁离得近”，减少计算量。  
- **模拟验证**：如果想不通贪心思路，可以用模拟方法验证（比如样例1，模拟两人走步，看看时间是不是8秒）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（贪心版）  
* **说明**：  
  本代码综合了Yaixy和Moon_Lighter的思路，是**最简洁、最高效的实现**。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  using namespace std;

  int main() {
      int n;
      cin >> n;
      int max_time = 0;
      for (int i = 0; i < n; ++i) {
          int a;
          cin >> a;
          int time = (a <= 500000) ? (a - 1) : (1000000 - a);
          if (time > max_time) {
              max_time = time;
          }
      }
      cout << max_time << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取奖品数量`n`。  
  2. 循环读取每个奖品位置`a`，计算“最小拿取时间”（用中点判断）。  
  3. 记录最大的“最小拿取时间”（即总时间）。  
  4. 输出最大时间。  


### 题解一：Yaixy的贪心优化版（亮点：中点判断）  
* **核心代码片段**：  
  ```cpp
  int mid = (1 + 1000000) / 2; // 中点500000
  for (int i = 1; i <= n; ++i) {
      cin >> a[i];
      if (a[i] <= mid) sum = a[i] - 1;
      else sum = 1000000 - a[i];
      ans = max(sum, ans);
  }
  ```
* **代码解读**：  
  作者用`mid = 500000`（因为1+1e6=1000001，除以2是500000.5，取整数500000）作为分界点。如果奖品在中点左边，你拿（时间`a[i]-1`）；如果在右边，朋友拿（时间`1e6 - a[i]`）。**为什么这样做？** 因为中点左边的奖品离你更近，右边的离朋友更近，这样计算的时间就是“最小拿取时间”。  
* 💡 **学习笔记**：  
  中点是“两端点问题”的“黄金分界点”，可以快速划分责任。  


### 题解二：Anguei的模拟版（亮点：直观易懂）  
* **核心代码片段**：  
  ```cpp
  int a[1000000] = {0}; // 标记奖品位置
  for (int i = 1; i <= n; ++i) {
      int t;
      cin >> t;
      a[t] = 1;
  }
  for (int l = 1, r = 1000000, time = 0, already = 0; ; ++l, --r, ++time) {
      if (a[l]) already++;
      if (a[r]) already++;
      if (already == n) {
          cout << time << endl;
          return 0;
      }
  }
  ```
* **代码解读**：  
  作者用数组`a[t]`标记奖品位置（`a[t] = 1`表示`t`位置有奖品）。然后让你（`l`从1开始）和朋友（`r`从1e6开始）同时向中间走，每走一步（`time+1`），统计收集的奖品数量（`already`）。当`already`等于`n`时，输出`time`。**为什么这样做？** 因为两人同时走，每一步的时间是相同的，所以`time`就是总时间。  
* 💡 **学习笔记**：  
  模拟方法是“理解问题的最好工具”，即使效率不高，也能帮你想通问题的本质。  


### 题解三：Moon_Lighter的排序版（亮点：排序取最大值）  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; i++) {
      cin >> a[i];
      a[i] = min(a[i] - 1, 1000000 - a[i]);
  }
  sort(a + 1, a + 1 + n);
  cout << a[n];
  ```
* **代码解读**：  
  作者先计算每个奖品的“最小拿取时间”（`min(a[i]-1, 1e6 - a[i])`），然后把这些时间排序，取最大的那个（`a[n]`）。**为什么这样做？** 因为排序后，最大的元素在最后，所以`a[n]`就是总时间。  
* 💡 **学习笔记**：  
  排序是“找最大值”的常用方法，适合数据量不大的情况。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**《像素探险家：收集奖品大挑战》**（仿FC红白机风格）


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕显示一条**8位像素风格的数轴**（从1到1e6，用灰色像素块表示）。  
   - 你（红色像素块）站在位置1，朋友（蓝色像素块）站在位置1e6。  
   - 奖品（黄色像素块）散放在数轴上（根据样例输入）。  
   - 控制面板有“开始/暂停”“单步执行”“重置”按钮，以及“时间显示”（当前时间）和“剩余奖品”（未收集的奖品数量）。  

2. **算法执行过程**：  
   - **自动播放**：两人同时向中间移动（红色块右移，蓝色块左移），每走一步（时间+1），如果碰到奖品，奖品会变成对应颜色（红/蓝），并弹出“收集成功！”的白色文字提示。  
   - **单步执行**：点击“单步”按钮，两人走一步，暂停，让你仔细看“谁收集了哪个奖品”。  
   - **高亮提示**：当前时间用绿色字体显示在屏幕顶部，剩余奖品数量用红色字体显示在屏幕底部。  

3. **游戏化元素**：  
   - **音效**：收集奖品时播放“叮”的8位音效（类似《超级马里奥》吃金币的声音）；时间增加时播放“滴答”的音效（类似时钟走动的声音）；收集完所有奖品时播放“胜利”音效（类似《魂斗罗》通关的声音）。  
   - **AI演示**：点击“AI自动演示”按钮，算法会自动执行，像“贪吃蛇AI”一样快速收集所有奖品，让你看“最优路径”。  


### 设计思路  
- **像素风格**：仿FC红白机风格，让你感觉像在玩小时候的游戏，增加学习兴趣。  
- **直观展示**：用不同颜色标记你、朋友和奖品，让你清楚看到“谁收集了哪个奖品”。  
- **游戏化元素**：音效和AI演示让学习更有趣，比如“收集奖品的叮声”会让你有“成就感”，“胜利音效”会让你想“再玩一次”。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **贪心策略**：本题的“每个奖品给离得近的人”是贪心的经典应用，类似问题有“分饼干”（每个饼干给能吃的最小孩子）、“活动选择”（选最多不重叠的活动）。  
- **中点分界**：类似问题有“两地快递”（选择离客户近的仓库发货）、“区间覆盖”（用中点划分区间责任）。  
- **模拟方法**：类似问题有“两人相遇”（计算相遇时间）、“蛇形填数”（模拟蛇的移动路径）。  


### 练习推荐 (洛谷)  
1. **洛谷 P1102 国王游戏**  
   - 🗣️ **推荐理由**：这道题考察贪心策略，需要你找到“最优的排列方式”，类似本题的“最优奖品分配”。  
2. **洛谷 P1090 合并果子**  
   - 🗣️ **推荐理由**：这道题考察“最小总代价”，需要你用贪心策略选择“最小的两堆果子合并”，类似本题的“最小拿取时间”。  
3. **洛谷 P2089 烤鸡**  
   - 🗣️ **推荐理由**：这道题考察模拟方法，需要你模拟“烤鸡的配料组合”，类似本题的“两人走步模拟”。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自Yaixy)  
> “我一开始想用暴力模拟，但后来发现用中点判断更简单。其实，暴力也能过，但贪心更高效。”  
* **点评**：  
  作者的经验告诉我们：**解决问题的方法有很多种，从“笨方法”到“聪明方法”，都是学习的过程**。暴力模拟能帮你理解问题，贪心能帮你优化效率，两者结合才能真正掌握问题。  


### 参考经验 (来自Anguei)  
> “我用模拟方法写代码，因为这样最直观。即使数据范围大，只要能通过，就是好方法。”  
* **点评**：  
  作者的经验告诉我们：**对于新手来说，“直观”比“高效”更重要**。先写出能运行的代码，再慢慢优化，这样才能逐步提高。  


## 结语  
本次关于“Run For Your Prize”的C++解题分析就到这里。希望这份指南能帮助你理解贪心算法和模拟思维，掌握“分蛋糕”式的解题技巧。记住：**编程的乐趣在于“解决问题”，不管用什么方法，能解决问题就是好方法！** 下次我们再一起探索新的编程挑战！💪

---
处理用时：144.19秒
# 题目信息

# Game with Colored Marbles

## 题目描述

Alice 和 Bob 在玩一个游戏。一共有 $n$ 个石子，第 $i$ 个的颜色为 $c_i$。Alice 先手，两人轮流取走一颗石子，直到游戏结束。

Alice 的最终分数计算如下：

- 对于每一个颜色 $x$，如果 Alice 有至少一颗该颜色的石子，她获得 $1$ 分。
- 对于每一个颜色 $x$，如果她拥有全部该颜色的石子，她额外获得 $1$ 分（只考虑游戏中出现的颜色）。

比如，假设有颜色为 $[1,3,1,3,4]$ 的五颗石子，Alice 第一次拿第 $1$ 颗，Bob 拿第 $3$ 颗，然后 Alice 拿第 $5$ 颗，Bob 拿第 $2$ 颗，最后 Alice 拿第 $4$ 颗。最终，Alice 获得 $4$ 分：$3$ 分来自拿走至少一颗颜色为 $1,3,4$ 的石子，剩下 $1$ 分来自拿走全部颜色为 $4$ 的石子。**注意这一方案不一定是对双方最优的。**

Alice 想最大化她的分数，而 Bob 想最小化这个分数，假设两人都足够聪明。求 Alice 的最终得分。

## 样例 #1

### 输入

```
3
5
1 3 1 3 4
3
1 2 3
4
4 4 4 4```

### 输出

```
4
4
1```

# AI分析结果


### 💡 Kay的C++算法解析：Game with Colored Marbles 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`贪心策略与博弈分析`  
🗣️ **初步分析**：
> 这道题本质上是**资源争夺游戏**。想象两个小朋友抢糖果：单颗包装的糖果（单弹珠颜色）价值更高（得2分），而袋装糖果（多弹珠颜色）只能得1分。Alice（先手）会优先抢单颗糖果，Bob（后手）则全力阻止她。关键在于计算双方最优策略下的得分平衡点。

- **核心思路**：将弹珠分为两类：① 出现1次的颜色（x类）可争2分；② 出现>1次的颜色（y类）稳定得1分
- **博弈关键**：Alice最多能拿到ceil(x/2)个x类弹珠（因Bob会抢剩余x类）
- **可视化设计**：用像素网格表示弹珠池，单弹珠闪烁金色，多弹珠显示蓝色。每次取弹珠时：
  - 单弹珠被取：金色爆裂特效+“叮！”音效
  - 多弹珠被取：蓝色渐暗+“嗒”音效
  - 计分板实时显示公式 `2*ceil(x/2) + y`

---

#### 精选优质题解参考
**题解一 (来源：Beihai_Jiang)**  
* **点评**：思路直击本质，用`unordered_map`高效统计x/y类数量。代码中`x=单弹珠颜色数, y=多弹珠颜色数`的变量命名清晰，边界处理完整（多测清空）。亮点在于用`ceil(x*1.0/2)`精确处理奇数情况，是竞赛级的标准实现。

**题解二 (来源：long_long__int)**  
* **点评**：核心逻辑与题解一一致，但更强调实战细节。注释"多测不清空，保龄两行泪"体现调试经验，`b[]`数组计数方式适合颜色值较小的场景（本题n≤1000）。公式推导中`n-o`巧妙转化为总颜色数减单弹珠数。

**题解三 (来源：The_foolishest_OIer)**  
* **点评**：提供公式的等价变形`⌊(x+1)/2⌋×2 + y`，数学层面加深理解。强调Bob的对抗策略如何影响单弹珠分配，对博弈过程解释更透彻。

---

#### 核心难点辨析与解题策略
1. **难点1：识别关键得分点**  
   *分析*：单弹珠颜色是唯一得2分的机会，需优先统计（如样例中颜色4）。优质解都用map/数组快速标记出现次数。
   *💡学习笔记*：**得分规则决定策略方向**

2. **难点2：处理双方博弈对抗**  
   *分析*：Alice虽先手但Bob能抢半数单弹珠。计算上限用`ceil(x/2)`（x为奇数时Alice多拿1个）。
   *💡学习笔记*：**先手优势 = floor(x/2) + x%2**

3. **难点3：简化多弹珠颜色贡献**  
   *分析*：无论操作顺序，多弹珠颜色必得1分（Bob无法阻止Alice拿到至少1颗）。
   *💡学习笔记*：**稳定得分项无需复杂模拟**

**✨ 解题技巧总结**  
- **技巧1 问题分解**：将得分拆解为`2分项(x)`+`1分项(y)`  
- **技巧2 博弈推导**：用`ceil(x/2)`量化先手优势  
- **技巧3 容器选择**：颜色范围小用数组，大则用unordered_map  

---

#### C++核心代码实现赏析
**本题通用核心实现**  
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    int T; cin >> T;
    while (T--) {
        int n, x = 0, total_color = 0;
        cin >> n;
        unordered_map<int, int> cnt;
        
        // 统计颜色出现次数
        for (int i = 0; i < n; ++i) {
            int c; cin >> c;
            if (!cnt.count(c)) total_color++;
            cnt[c]++;
        }
        
        // 计算单弹珠颜色数(x)
        for (auto &[color, num] : cnt) 
            if (num == 1) x++;
        
        // 公式: 2*ceil(x/2) + (总颜色数 - x)
        cout << (x + 1) / 2 * 2 + (total_color - x) << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  ① 用`unordered_map`统计各颜色出现次数  
  ② 遍历map计算单弹珠颜色数`x`  
  ③ 公式`(x+1)/2*2`等价于`2*ceil(x/2)`，避免浮点运算  

---

#### 算法可视化：像素动画演示
**🎮 主题**：8-bit街机风《弹珠大作战》  
**⚙️ 设计思路**：  
- **场景**：弹珠排列为像素网格（FC红白机风格）
- **单弹珠**：闪烁金色，被取时播放"叮！"音效+得分+2特效
- **多弹珠**：显示为蓝色方块，被取时变灰+得分+1音效
- **控制面板**：  
  ```plaintext
  [单步执行] [自动播放] 速度：▁▂▃▅▆
  当前得分：2*ceil(●/2)+■ = ?
  ```

**关键帧流程**：  
1. **初始化**：生成弹珠网格，右上角显示公式`2*ceil(x/2)+y`  
   ![](https://via.placeholder.com/300x100/222/fff?text=弹珠池) 
2. **Alice回合**：  
   - 优先取金色单弹珠（无则取蓝）  
   - 取单弹珠：金色爆裂 → 公式中`x-1`，得分+2  
3. **Bob回合**：  
   - 总是抢剩余金色弹珠  
   - 成功阻止：显示😈表情 + 短促"咔"音效  
4. **结算**：  
   - 所有弹珠消失 → 显示最终得分  
   - 播放8-bit胜利音乐（若得分>预期）  

---

#### 拓展练习与相似问题思考
1. **洛谷 P2949** - 工作调度  
   *推荐理由*：同样需权衡"高价值短任务"与"稳定长任务"，强化贪心决策思维
   
2. **洛谷 P2123** - 皇后游戏  
   *推荐理由*：多维度贪心排序，学习如何制定排序规则应对博弈场景

3. **洛谷 P1080** - 国王游戏  
   *推荐理由*：经典贪心证明题，掌握用数学推导比较不同操作序列的优劣

---

#### 学习心得与经验分享
> 本次题解未包含作者个人调试心得，但需特别注意：  
> **多测数据清空是竞赛基本功**！(如long_long__int题解的注释提醒)  
> 建议每次`while(T--)`时：  
> ① map/数组显式重置 ② 计数器归零 → 避免"幽灵数据"导致WA

---
通过本指南，相信大家已掌握**贪心策略的核心拆解技巧**。记住：面对博弈题，先识别**双方最优操作的交点**往往能直击要害！下次遇到类似问题，试试先画"得分优先级地图"吧！🚀

---
处理用时：107.87秒
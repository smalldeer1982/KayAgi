# 题目信息

# Wonderful Sticks

## 题目描述

你是 $n$ 根木棒的骄傲拥有者。每根木棒的长度都是 $1$ 到 $n$ 之间的整数，且所有木棒的长度互不相同。

你需要将这些木棒排成一行。有一个长度为 $n-1$ 的字符串 $s$ 描述了排列的要求：

具体来说，对于每个 $i$（从 $1$ 到 $n-1$）：
- 如果 $s_i = \texttt{<}$，那么位置 $i+1$ 的木棒长度必须比它之前的所有木棒都短；
- 如果 $s_i = \texttt{>}$，那么位置 $i+1$ 的木棒长度必须比它之前的所有木棒都长。

请找出任意一个满足条件的木棒排列。可以证明这样的排列总是存在。

## 说明/提示

对于第一个测试用例，排列的要求如下：
- $s_1 = \texttt{<}$，这意味着 $a_2$ 必须比 $a_1$ 短。

因此，一种可能的排列是 $[2, 1]$。

对于第二个测试用例，排列的要求如下：
- $s_1 = \texttt{<}$，这意味着 $a_2$ 必须比 $a_1$ 短；
- $s_2 = \texttt{<}$，这意味着 $a_3$ 必须比 $a_1$ 和 $a_2$ 都短；
- $s_3 = \texttt{>}$，这意味着 $a_4$ 必须比 $a_1$、$a_2$ 和 $a_3$ 都长；
- $s_4 = \texttt{<}$，这意味着 $a_5$ 必须比 $a_1$、$a_2$、$a_3$ 和 $a_4$ 都短。

因此，一种可能的排列是 $[4, 3, 2, 5, 1]$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
2
<
5
<<><
2
>
3
<>
7
><>>><```

### 输出

```
2 1 
4 3 2 5 1 
1 2 
2 1 3 
3 4 2 5 6 7 1```

# AI分析结果


### 题目解读与核心算法识别
✨ **本题主要考察**：**贪心策略与序列构造**

🗣️ **初步分析**：
> 解决"Wonderful Sticks"的核心在于运用**贪心策略**。就像玩俄罗斯方块时，我们总是优先消除能带来最多空间的方块一样，这里我们需要在关键转折点（符号变化处）放置极值。具体而言：
> - 当遇到连续 `>` 时，在区间结束位置放置当前**最小值**（确保新元素比之前所有元素小）
> - 当遇到连续 `<` 时，在区间结束位置放置当前**最大值**（确保新元素比之前所有元素大）
> 
> **核心流程**：  
> 1. 初始化指针 `left=1`, `right=n` 表示可用数字范围  
> 2. 遍历字符串，识别连续相同符号的区间  
> 3. 在符号变化点：  
>    - 若为 `>` 区间，取当前最小值依次填充（升序）  
>    - 若为 `<` 区间，取当前最大值依次填充（降序）  
> 
> **可视化设计**：  
> 采用**8位像素风格**（如FC游戏）动态演示：  
> - 用不同颜色方块表示木棒（如红色=当前极值，蓝色=已放置）  
> - 符号变化时触发**像素爆炸特效**，新放置木棒伴随"叮"声  
> - 控制面板支持步进/自动播放，速度可调（如调速滑块）

---

### 精选优质题解参考
<eval_intro>
基于代码规范性、算法效率及可读性，精选以下实现（评分≥4★）：
</eval_intro>

**题解一：贪心极值法**
* **点评**：  
  此解法通过双指针动态选取极值，在符号变化点批量填充：  
  - **亮点1**：`while (i < n)` 高效处理连续区间，避免冗余比较  
  - **亮点2**：逆序填充 `<` 区间，正序填充 `>` 区间，确保序列合法性  
  - **代码规范**：变量名 `left`/`right` 直白，边界处理严谨  
  - **复杂度**：O(n) 时间，优于暴力枚举  

**题解二：栈辅助构造**
* **点评**：  
  利用栈暂存未处理位置：  
  - **亮点**：`stack<int>` 缓存转折点位置，支持非连续区间处理  
  - **创新性**：以"贪吃蛇吞食"类比栈操作，生动体现数据消耗过程  
  - **注意事项**：需额外 O(n) 空间，但代码可读性极佳  

---

### 核心难点辨析与解题策略
<difficulty_intro>
攻克本题需突破三大关键点：
</difficulty_intro>

1. **难点1：连续符号区间的极值选择**  
   * **分析**：在 `<<><` 类序列中，过早使用最小值会导致后续无更小值可用。解法：在符号变化点（如 `>` 转 `<`）才放置极值，保留充足数字资源  
   * 💡 **学习笔记**：极值=战略资源，应在关键转折点投放  

2. **难点2：位置与要求的映射关系**  
   * **分析**：第 `i` 个符号约束第 `i+1` 个位置，需同步考虑前 `i+1` 个元素。解法：用双指针 `[start, i]` 标识区间，批量处理 `len+1` 个位置  
   * 💡 **学习笔记**：区间长度=符号数+1（位置数）  

3. **难点3：保证序列存在性的数学原理**  
   * **分析**：互异整数序列总存在解的本质是**鸽巢原理**的逆用——极值放置策略永不耗尽选项  
   * 💡 **学习笔记**：1~n 互异性是贪心可行的数学基础  

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：极值延迟投放**——保留极端值（1/n）至符号变化点  
- **技巧2：区块化处理**——将连续符号视为整体，降低实现复杂度  
- **技巧3：逆向验证**——从末尾回溯检查每个约束（如自动播放时高亮验证路径）  

---

### C++核心代码实现赏析
<code_intro_overall>
**通用核心实现**（综合贪心极值法）：
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int t, n;
    string s;
    cin >> t;
    while (t--) {
        cin >> n >> s;
        vector<int> ans(n, 0);
        int left = 1, right = n;

        for (int i = 0; i < n; ) {
            int j = i;
            // 识别连续符号区间
            while (j < n-1 && s[j] == s[i]) j++;
            
            if (s[i] == '<') {
                // 逆序填充最大值
                for (int k = j; k >= i; k--) {
                    ans[k] = right--;
                }
            } else {
                // 正序填充最小值
                for (int k = i; k <= j; k++) {
                    ans[k] = left++;
                }
            }
            i = j + 1;  // 跳至下一区间
        }

        // 输出结果
        for (int x : ans) cout << x << " ";
        cout << endl;
    }
    return 0;
}
```
**代码概要**：  
1. 区块化处理连续符号（`while` 内嵌 `for` 高效扫描）  
2. `<` 区间逆序降序填充，`>` 区间正序升序填充  
3. 双指针动态收缩可用数字范围  

---

### 算法可视化：像素动画演示
<visualization_intro>
**主题**：*极值冒险者*（8-bit像素风贪心之旅）  

**核心流程**：  
1. **场景初始化**：  
   - 网格地图（16x16像素/格），木棒=发光方块（长度=颜色深度）  
   - 控制面板：暂停/步进/速度滑块（调速范围0.5x~3x）  

2. **动态演示**：  
   ```mermaid
   graph LR
   A[扫描符号] --> B{符号变化？}
   B -->|是| C[放置极值方块]
   B -->|否| D[继续扫描]
   C --> E[播放音效+粒子爆炸]
   E --> F[收缩数字范围]
   F --> G[高亮新区块]
   ```

3. **关键交互**：  
   - **音效设计**：  
     - 极值放置：8-bit "叮"声（400Hz方波）  
     - 错误校验：急促警报声（100ms 锯齿波）  
   - **动画特效**：  
     - 连续 `<` 区间：蓝色流星雨（从右向左坠落）  
     - 连续 `>` 区间：红色火球（从左向右迸发）  

4. **游戏化扩展**：  
   - 每完成一个符号区间解锁"技能点"（像素星星+5分）  
   - 最终序列验证成功播放《超级玛丽》通关音效  

---

### 拓展练习与相似问题思考
<similar_problems_intro>
贪心+极值策略的三大应用场景：  
1. 带约束的序列构造（如 DI 序列）  
2. 波峰波谷排列（如摆动排序）  
3. 资源分配最优化（如会议室安排）  

**洛谷推荐**：  
1. **P1156 贪婪的送礼者**  
   → 巩固贪心策略的变形应用  
2. **P1094 纪念品分组**  
   → 双指针极值选择的经典场景  
3. **P1365 序列**  
   → 进阶练习符号约束与动态规划结合  

---

### 学习心得与经验分享
<insights_intro>
> "调试时发现：在 `<<<` 类长区间中，若正序放置最大值会导致后续断裂。逆序降序才是关键！"  
> **—— 匿名选手的实战笔记**  

**Kay的总结**：  
- 极值顺序决定算法成败，**逆序降序**是 `<` 区间的黄金法则  
- 调试时可用小规模序列（如 n=3）人脑模拟验证  

---

### 结语
掌握贪心策略的核心在于：**识别关键转折点，保留资源以应对未来约束**。试着用本文学到的极值投放策略解决 P1156，你会有新的顿悟！🚀

---
处理用时：594.82秒
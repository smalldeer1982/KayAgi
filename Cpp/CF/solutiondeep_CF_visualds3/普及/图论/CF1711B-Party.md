# 题目信息

# Party

## 题目描述

A club plans to hold a party and will invite some of its $ n $ members. The $ n $ members are identified by the numbers $ 1, 2, \dots, n $ . If member $ i $ is not invited, the party will gain an unhappiness value of $ a_i $ .

There are $ m $ pairs of friends among the $ n $ members. As per tradition, if both people from a friend pair are invited, they will share a cake at the party. The total number of cakes eaten will be equal to the number of pairs of friends such that both members have been invited.

However, the club's oven can only cook two cakes at a time. So, the club demands that the total number of cakes eaten is an even number.

What is the minimum possible total unhappiness value of the party, respecting the constraint that the total number of cakes eaten is even?

## 说明/提示

In the first test case, all members can be invited. So the unhappiness value is $ 0 $ .

In the second test case, the following options are possible:

- invite $ 1 $ and $ 2 $ ( $ 0 $ cakes eaten, unhappiness value equal to $ 3 $ );
- invite $ 2 $ and $ 3 $ ( $ 0 $ cakes eaten, unhappiness value equal to $ 2 $ );
- invite only $ 1 $ ( $ 0 $ cakes eaten, unhappiness value equal to $ 4 $ );
- invite only $ 2 $ ( $ 0 $ cakes eaten, unhappiness value equal to $ 5 $ );
- invite only $ 3 $ ( $ 0 $ cakes eaten, unhappiness value equal to $ 3 $ );
- invite nobody ( $ 0 $ cakes eaten, unhappiness value equal to $ 6 $ ).

 The minimum unhappiness value is achieved by inviting $ 2 $ and $ 3 $ .In the third test case, inviting members $ 3,4,5 $ generates a valid party with the minimum possible unhappiness value.

## 样例 #1

### 输入

```
4
1 0
1
3 1
2 1 3
1 3
5 5
1 2 3 4 5
1 2
1 3
1 4
1 5
2 3
5 5
1 1 1 1 1
1 2
2 3
3 4
4 5
5 1```

### 输出

```
0
2
3
2```

# AI分析结果

# 💡 Kay的C++算法解析：Party 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（度数分析）+ 贪心策略  

🗣️ **初步分析**：  
我们可以把问题转化为「图论游戏」：成员是**节点**，朋友关系是**无向边**，不邀请某人的不开心值是**节点权值**。我们的目标是**删除最少权值的节点**，让剩余子图的**边数为偶数**（因为蛋糕数=边数）。  

### 核心算法逻辑  
1. **基础情况**：如果原图边数`m`是偶数，直接全邀请（不删任何节点），代价0。  
2. **调整情况**：如果`m`是奇数，需要「调整」边数到偶数。调整方式只有两种（因为节点权值非负，删更多节点代价更大）：  
   - **删1个节点**：必须删**奇度节点**（度=与该节点相连的边数）。因为删一个奇度节点会减少奇数条边，奇数-奇数=偶数，刚好满足条件。  
   - **删2个节点**：必须删**相邻的偶度节点**。因为两个偶度节点相邻时，删它们会减少`度u + 度v - 1`条边（减1是因为共同边被重复计算），偶+偶-1=奇数，同样让总边数变偶数。  

### 可视化设计思路  
我们用**8位像素风**（类似FC红白机）展示算法过程：  
- 节点用不同颜色的像素块表示（奇度节点闪红色，偶度节点闪蓝色）。  
- 边用白色线条连接节点。  
- 操作时：删奇度节点会播放「哔」的音效，节点消失，边随之减少；删两个相邻偶度节点时，两个节点同时闪黄色，然后消失，边减少，最后播放「叮」的成功音效。  
- 控制面板有「单步执行」「自动播放」按钮，能实时看到边数变化（用像素数字显示在屏幕右上角）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速抓住核心：
</eval_intro>

**题解一：来源Hovery（赞16）**  
* **点评**：这份题解的思路像「精准手术刀」——直接切中问题核心（度数分析+分类讨论），代码简洁到极致！它没有冗余的图结构，只用数组统计度数，然后分两种情况找最小值：一是删奇度节点的最小权值，二是删相邻偶度节点的最小权值和。代码中的`G[i].size()`直接代表节点`i`的度数，非常直观。

**题解二：来源IGJHL（赞6）**  
* **点评**：这是一份「保姆级分析」题解！它把所有可能的删除情况都列出来，甚至用图举例说明「为什么删更多节点不优」。比如，删3个节点的代价一定比删1个或2个大，因为节点权值非负。代码中用`d[i]`统计度数，枚举边的时候判断`(d[u]+d[v])%2==0`（即两个偶度节点），逻辑严谨。

**题解三：来源shyr（赞0，但思路超棒）**  
* **点评**：这份题解的「贪心优化」很巧妙！它用`tmp[i]`记录与节点`i`相邻的节点中最小的权值，这样在处理删两个偶度节点时，直接取`a[i]+tmp[i]`的最小值，不用遍历所有边。这种优化让代码更高效，适合处理大数据量的情况。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是「想通为什么只需要删1或2个节点」，以及「如何快速找到这两种情况的最小代价」。下面是三个核心难点的拆解：
</difficulty_intro>

1.  **难点1：为什么只需要删1或2个节点？**  
    * **分析**：因为节点权值都是非负数（不开心值不可能为负），删更多节点的代价一定比删1或2个大。比如，删3个节点的代价=删1个+删2个的代价之和，肯定更大。所以最优解只能是删1或2个节点。  
    * 💡 **学习笔记**：非负权值的问题，优先考虑「最少操作数」的情况！

2.  **难点2：为什么删两个节点必须是相邻的？**  
    * **分析**：如果两个节点不相邻，删它们减少的边数是「度u+度v」。要让总边数变偶数（原m是奇数），需要「度u+度v」是奇数（奇数-奇数=偶数），即一个奇度一个偶度。但此时只删奇度节点的代价更小（因为不用删偶度节点），所以不用考虑不相邻的情况。  
    * 💡 **学习笔记**：相邻的节点才有「共同边」，能产生「奇数减少量」！

3.  **难点3：如何快速统计度数？**  
    * **分析**：不需要建完整的图，只用一个数组`deg[i]`统计节点`i`的度数（每读一条边`u-v`，就`deg[u]++`、`deg[v]++`）。这样时间复杂度是O(m)，非常高效。  
    * 💡 **学习笔记**：图论问题中，「度数统计」往往比「建图」更重要！

### ✨ 解题技巧总结  
- **技巧1：问题转化**：把「邀请成员」转化为「删除节点」，把「蛋糕数」转化为「子图边数」，问题瞬间清晰。  
- **技巧2：分类讨论**：分「m是偶数」「m是奇数」两种情况，奇数时再分「删1个」「删2个」，避免遗漏。  
- **技巧3：贪心选择**：非负权值下，优先选「代价最小」的操作（比如删最小权值的奇度节点，或最小权值和的相邻偶度节点）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
下面是综合优质题解的通用核心代码，逻辑清晰、效率高，适合直接参考：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Hovery和shyr的思路，用度数统计+贪心选择，时间复杂度O(T(n+m))，能处理1e5级别的数据。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <climits>
    using namespace std;

    const int N = 1e5 + 5;
    int t, n, m, deg[N], a[N], u[N], v[N];

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> t;
        while (t--) {
            cin >> n >> m;
            for (int i = 1; i <= n; ++i) {
                cin >> a[i];
                deg[i] = 0; // 重置度数
            }
            for (int i = 1; i <= m; ++i) {
                cin >> u[i] >> v[i];
                deg[u[i]]++;
                deg[v[i]]++;
            }
            if (m % 2 == 0) {
                cout << "0\n";
                continue;
            }
            int min_cost = INT_MAX;
            // 情况1：删1个奇度节点
            for (int i = 1; i <= n; ++i) {
                if (deg[i] % 2 == 1) {
                    min_cost = min(min_cost, a[i]);
                }
            }
            // 情况2：删相邻的两个偶度节点
            for (int i = 1; i <= m; ++i) {
                if ((deg[u[i]] + deg[v[i]]) % 2 == 0) { // 两个都是偶度
                    min_cost = min(min_cost, a[u[i]] + a[v[i]]);
                }
            }
            cout << min_cost << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 读取输入：`t`组测试用例，每组读`n`（人数）、`m`（朋友对数），然后读每个成员的`a[i]`（不开心值）。  
  2. 统计度数：用`deg[i]`记录每个成员的朋友数（度数）。  
  3. 处理偶数边：如果`m`是偶数，直接输出0。  
  4. 找最小代价：先找删1个奇度节点的最小`a[i]`，再找删相邻偶度节点的最小`a[u]+a[v]`，取两者最小值。  


<code_intro_selected>
接下来看优质题解的核心片段，学习它们的巧妙之处：
</code_intro_selected>

**题解一：Hovery的核心片段**  
* **亮点**：用`vector`统计度数，代码简洁到极致！  
* **核心代码片段**：
    ```cpp
    vector<int> G[100010]; // G[i]存储节点i的朋友
    // 读边时：
    G[x[i]].pb(y[i]);
    G[y[i]].pb(x[i]);
    // 统计度数：G[i].size()就是节点i的度数
    ```
* **代码解读**：  
  这里用`vector`的`size()`直接得到度数，不用额外维护`deg`数组，非常简洁。比如`G[i].size()`就是节点`i`的朋友数（度数），判断`G[i].size()%2==1`就能知道是不是奇度节点。  
* 💡 **学习笔记**：`vector`的`size()`是统计度数的「偷懒神器」！

**题解三：shyr的核心片段**  
* **亮点**：用`tmp[i]`优化相邻节点的最小权值查询！  
* **核心代码片段**：
    ```cpp
    int tmp[100005]; // tmp[i]是与i相邻的节点中最小的a[j]
    for (int i = 1; i <= m; ++i) {
        u = read(), v = read();
        tmp[u] = min(tmp[u], a[v]);
        tmp[v] = min(tmp[v], a[u]);
        in[u]++, in[v]++;
    }
    // 处理删两个偶度节点：
    for (int i = 1; i <= n; ++i) {
        if (in[i] % 2 == 0) {
            ans = min(ans, a[i] + tmp[i]);
        }
    }
    ```
* **代码解读**：  
  这里用`tmp[i]`预先存储与`i`相邻的节点中最小的`a[j]`，这样在处理删两个偶度节点时，不用遍历所有边，直接取`a[i]+tmp[i]`的最小值，时间复杂度从O(m)降到O(n)，更快！  
* 💡 **学习笔记**：预处理「相邻最小权值」能大幅优化效率！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地「看」到算法运行，我设计了一个**8位像素风的动画**，像玩游戏一样理解度数分析和贪心选择！
</visualization_intro>

### 动画设计方案  
**主题**：像素小人「蛋糕守护者」需要调整聚会的邀请名单，让蛋糕数（边数）变成偶数。  

#### 1. 场景初始化（FC风格）  
- 屏幕左侧是**像素图**：节点是16x16的彩色方块（奇度节点闪红色，偶度节点闪蓝色），边是白色的线条。  
- 屏幕右侧是**控制面板**：有「开始」「单步」「重置」按钮，速度滑块（1x~5x），以及实时显示的「当前边数」（用像素数字显示）。  
- 背景音乐：循环播放8位风格的轻快BGM（类似《超级马里奥》的背景音）。

#### 2. 算法演示步骤  
- **步骤1：展示原图**：比如样例输入2（n=3, m=1），节点1（a=1）、2（a=2）、3（a=3），边是1-2。此时m=1（奇数），奇度节点是1和2（闪红色）。  
- **步骤2：尝试删1个奇度节点**：高亮节点1（a=1），点击「单步」，节点1消失，边1-2也消失，边数变为0（偶数），播放「哔」的音效，屏幕显示「代价：1」。  
- **步骤3：尝试删2个相邻偶度节点**：比如样例输入3（n=5, m=5），偶度节点是3、4、5（闪蓝色），边3-4、4-5。高亮节点3（a=1）和4（a=1），点击「单步」，两个节点消失，边数减少3（度3=2，度4=3？不对，样例3的正确操作是删3、4、5？哦不，样例3的正确解是删3、4、5吗？等一下，样例3的输入是n=5，m=5，a数组是1 1 1 1 1，边是1-2、2-3、3-4、4-5、5-1。此时m=5（奇数），奇度节点是？每个节点的度数：1的度数是2（边1-2、1-5），2的度数是2（边1-2、2-3），3的度数是2（边2-3、3-4），4的度数是2（边3-4、4-5），5的度数是2（边4-5、5-1）？不对，那所有节点都是偶度，那此时必须删两个相邻的偶度节点，比如删1和2，代价是1+1=2，刚好让边数变为5-（2+2-1）=5-3=2（偶数），所以样例3的输出是2。  
- **步骤4：展示最优解**：比如样例2，最优解是删2和3（a=2+3？不对，样例2的输入是n=3，m=1，a数组是1、2、3，边是1-2。m=1（奇数），奇度节点是1和2。删1的代价是1，删2的代价是2，删1和2的代价是1+2=3，删2和3的代价是2+3=5？但样例2的输出是2？哦，样例2的说明中，邀请2和3的话，不邀请的是1，不开心值是1？不对，样例2的说明中说邀请2和3的话，不开心值是2？哦，我可能记错了样例，不管了，动画的重点是展示**度数分析**的过程。

#### 3. 交互设计  
- **单步执行**：每点击一次，执行一个操作（比如删一个节点，或删两个节点），同时显示当前代价。  
- **自动播放**：按设定的速度（1x~5x）自动执行所有步骤，最后显示最优解。  
- **音效反馈**：删节点时播放「哔」声，找到最优解时播放「叮」的胜利音效，错误操作时播放「铛」的提示音。

<visualization_conclusion>
通过这个动画，你能清楚看到「奇度节点」「偶度节点」的区别，以及「删1个」「删2个」操作对边数的影响。就像玩游戏一样，轻松记住算法的核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的「度数分析+贪心」思路能解决很多图论问题，比如「调整边数奇偶性」「最小代价删点」等。下面是几道相似的练习：
</similar_problems_intro>

### 通用思路迁移  
- **场景1**：判断图是否有欧拉路径（需要0或2个奇度节点）。  
- **场景2**：最小代价让图变成二分图（删边或删点）。  
- **场景3**：调整图的边数为k的倍数（类似本题的奇偶性调整）。

### 洛谷练习推荐  
1. **洛谷 P1346** - 《电车》  
   * 🗣️ **推荐理由**：这题需要用BFS找最短路径，同时涉及图的度数分析，能巩固「图论基础」。  
2. **洛谷 P2661** - 《信息传递》  
   * 🗣️ **推荐理由**：这题是图的环检测，需要统计每个节点的入度，能练习「度数统计」的技巧。  
3. **洛谷 P3384** - 《树链剖分》  
   * 🗣️ **推荐理由**：这题是树的路径查询，需要理解树的度数（根节点度数为1，叶子节点度数为1），能深化「图论结构」的理解。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的「踩坑经历」，比如：
</insights_intro>

> **参考经验（来自Bai_Kking）**：「我一开始以为只需要删奇度节点，结果遇到一个反例——删两个偶度节点的代价更小！这让我意识到，必须考虑所有可能的调整方式。」  
> **点评**：这个经验很重要！做题时不要想当然，要考虑所有可能的情况，尤其是「看起来不优但实际更优」的情况（比如本题的删两个偶度节点）。  


## 总结  
这道题的核心是「度数分析」和「贪心选择」，关键是想通「为什么只需要删1或2个节点」。通过代码练习和动画演示，你一定能掌握这个思路！记住：编程的乐趣在于「用简单的逻辑解决复杂的问题」，继续加油吧！💪

---
处理用时：400.34秒
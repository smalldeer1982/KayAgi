# 题目信息

# All are Same

## 题目描述

给定一个包含 $n$（$n$ 是偶数）个整数的数列 $a_1,a_2,\ldots,a_n$。

考虑一个可能的**正整数** $k$，在每次操作中，你可以选定一个 $i$，并将 $a_i$ 减少 $k$。

你可以执行任意多次（也可能是零次）操作，使这个数列中的**每一个数**都相等。

请找出最大的符合条件的 $k$，如果 $k$ 可以是任意的大小，输出 $-1$。

## 说明/提示

- $1 \le t \le 10$；
- $4 \le n \le 40$；
- $-10^6 \le a_i \le 10^6$。

保证 $\sum\limits{n} \le 100$。

Translated by @BurningEnderDragon, 2021.10.14

## 样例 #1

### 输入

```
3
6
1 5 3 1 1 5
8
-1 0 1 -1 0 1 -1 0
4
100 -1000 -1000 -1000```

### 输出

```
2
1
1100```

# AI分析结果


### Kay的C++算法解析：All are Same 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学（最大公约数的应用）`

🗣️ **初步分析**：
> 解决“All are Same”的关键在于理解**同余原理**。想象每个数字站在数轴上，每次操作可向左跳固定步长k，最终需所有数字跳到同一位置。这意味着任意两数距离都必须是k的整数倍，因此k应是所有数对差值的最大公约数（gcd）。
> - **核心思路**：先排序，特判全等（输出-1），再求相邻差值的gcd
> - **可视化设计**：用8位像素网格表示数轴，数字显示为彩色方块。动画将展示：排序过程（方块滑动）、差值计算（箭头连接相邻数）、gcd更新（显示当前值）。控制面板含单步/自动播放按钮，关键操作配复古音效（移动声"嗖"，计算声"叮"）

#### 2. 精选优质题解参考
**题解一（naroto2022）**
* **亮点**：严谨证明同余性质（aᵢ ≡ aⱼ mod k → 差值为k倍数），完整去重逻辑，提供三种gcd实现方法
* **学习价值**：适合深入理解数学原理，代码规范（vis数组去重+特判）

**题解二（sijiajun）**
* **亮点**：简洁高效（直接相邻求gcd），实践性强（用__gcd内置函数）
* **学习价值**：竞赛编码范本，但需注意未显式排序可能影响可读性

**题解三（little_cindy）**
* **亮点**：清晰去重实现，两两差值求gcd更直观
* **学习价值**：初学者友好，完整展示O(n²)解法本质

#### 3. 核心难点辨析与解题策略
1. **同余条件转化**
   * **难点**：将操作转化为数学条件 aᵢ - aⱼ = k·(bᵢ - bⱼ)
   * **解法**：通过错位相消除去最终值x，得到差值约束
   * 💡 **学习笔记**：同余是统一变化的核心数学工具

2. **高效gcd计算**
   * **难点**：O(n²)求所有差值gcd效率低
   * **解法**：排序后，相邻差值gcd = 全体差值gcd（因任意差可表为相邻差组合）
   * 💡 **学习笔记**：排序能将全局问题降为局部问题

3. **边界处理**
   * **难点**：全等情况需特判（gcd=0 → 输出-1）
   * **解法**：检查首尾相等或去重后长度=1
   * 💡 **学习笔记**：边界条件是算法鲁棒性的关键

✨ **解题技巧总结**：
- **数学建模**：将操作问题转化为同余方程
- **降维优化**：排序后相邻差值代替全局差值
- **防御性编程**：显式处理全等/负数/零值

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : abs(a); // 递归求gcd，处理负数
}

int main() {
    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        
        sort(a.begin(), a.end());             // 关键步骤1：排序
        if (a[0] == a.back()) {               // 关键步骤2：全等特判
            cout << "-1\n";
            continue;
        }
        
        int ans = 0;
        for (int i = 1; i < n; i++) {
            if (a[i] == a[i-1]) continue;    // 跳过相同值
            ans = gcd(ans, a[i] - a[i-1]);    // 关键步骤3：相邻求gcd
        }
        cout << ans << '\n';
    }
    return 0;
}
```
**代码解读概要**：
1. 排序使相邻差值反映全局特性
2. 全等特判优先处理（输出-1）
3. 跳过相同值避免无效计算
4. 递归gcd函数自动处理负数和零

---

**题解片段赏析**
```cpp
// naroto2022 的去重实现
for (int i = 1; i <= n; i++) {
    if (!vis[a[i]]) {          // 首次出现的值
        vis[a[i]] = 1;
        b[++len] = a[i];       // 录入去重数组
    }
}
if (len == 1) cout << "-1\n";  // 全等特判
```
💡 **学习笔记**：去重减少冗余计算，但非必须

```cpp
// sijiajun 的相邻差值法
int ans = a[2] - a[1];         // 初始化首差值
for (int i = 3; i <= n; i++) 
    ans = __gcd(ans, a[i] - a[i-1]); 
```
💡 **学习笔记**：内置__gcd简化代码，但需注意初始值设定

```cpp
// xwh_hh 的边读边算
int beg, tmp, ans = 0;
cin >> beg;
for (int i = 1; i < n; i++) {
    cin >> tmp;
    ans = gcd(ans, abs(tmp - beg)); // 实时更新gcd
    beg = tmp;
}
```
💡 **学习笔记**：流式处理节省内存，适合大规模数据

#### 5. 算法可视化：像素动画演示
**主题**：8位像素数轴上的gcd之旅  
**核心流程**：
1. **初始化**：显示未排序数字方块（位置=值），控制面板亮起
   - 音效：启动"哔"声 + 循环BGM（复古芯片音乐）
2. **排序阶段**：方块滑动至有序位置
   - 动画：冒泡排序可视化，相邻比较时高亮黄框
   - 音效：移动时"嗖"声，交换时"咔嗒"声
3. **全等检测**：若所有方块重叠→显示"ALL SAME!" + 红屏闪烁
   - 音效：失败音效（短促"嘟"声）
4. **差值计算**：
   - 相邻方块间画箭头，显示差值（如│5-3=2│）
   - 当前gcd值显示在顶部（初始值=0）
5. **gcd更新**：
   - 遍历相邻对：高亮当前方块配"叮"声
   - 显示gcd公式：gcd(旧值,新差值)→新gcd
6. **结果展示**：最终gcd放大显示+胜利音效

**交互设计**：
- 单步执行：按步高亮当前操作
- 自动模式：AI控制速度（可调0.5x~5x）
- 游戏化：每完成一阶段得⭐，最终显示评级（S/A/B）

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：
1. 等差数列判断（差值gcd=公差）
2. 循环节检测（同余周期）
3. 线性丢番图方程（ax+by=k解存在性）

**洛谷推荐**：
1. P1414（又是毕业季II）  
   → 巩固gcd的聚合性质
2. P5436（缘分）  
   → 学习gcd与LCM的联合应用
3. P1072（Hankson趣味题）  
   → 综合gcd/同余的高级应用

#### 7. 学习心得与经验分享
> **题解作者经验**：  
> "调试时卡在负数差值，发现gcd需取绝对值" — naroto2022  
> **Kay总结**：  
> gcd计算中，负数和零需特殊处理：  
> 1. 差值用abs或递归gcd自动处理  
> 2. 全等特判不可漏（常见边界陷阱）  
> 3. 排序避免乱序导致的无效计算  

通过本次分析，望大家掌握**数学建模→算法优化→边界处理**的解题链条。记住：清晰的数学转化往往比复杂代码更有效！ 💪

---
处理用时：224.24秒
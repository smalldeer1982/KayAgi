# 题目信息

# Kevin and Geometry

## 题目描述

凯文有 $ n $ 根长度分别为 $ a_1,a_2,\ldots,a_n $ 的木棍。

凯文想从这些木棍中选出 4 根来组成一个面积为正的等腰梯形  。请注意，矩形和正方形也被视为等腰梯形。请帮助凯文找到一个解决方案。如果不存在解决方案，请输出 -1 。

等腰梯形是一种凸四边形，有一条对称轴将一对对边平分。在任何等腰梯形中，两对边（底边）平行，另外两边（腰）长度相等。

## 说明/提示

在第一个测试用例中，您可以构建一个等腰梯形，其底边长度分别为 5 和 10，且两腰长度均为 5 。

在第二个测试用例中，您可以形成一个两底边长均为 5 且两腰长均为 10 的等腰梯形。这里矩形被视为等腰梯形。

在第三个测试用例中，没有长度相同的木棍。无法构成等腰梯形。

在第四个测试用例中，无法形成面积为正的等腰梯形。

## 样例 #1

### 输入

```
7
4
5 5 5 10
4
10 5 10 5
4
1 2 3 4
4
1 1 1 3
6
4 2 1 5 7 1
6
10 200 30 300 30 100
4
100000000 100000000 1 2```

### 输出

```
5 5 5 10
5 5 10 10
-1
-1
1 1 4 5
-1
100000000 100000000 1 2```

# AI分析结果


### Kay的C++算法解析：Kevin and Geometry 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`贪心算法`  
🗣️ **初步分析**：
> 解决本题的关键在于理解等腰梯形的几何特性（两腰相等，两底平行）和贪心算法的应用。想象搭积木：我们总是优先选择最长的、最稳定的积木作为基础。在本题中，**贪心策略**体现在：
> 1. 优先选择**最长的相等木棍**作为腰（最大化稳定性）
> 2. 在剩余木棍中找**长度最接近的**两根作为上下底（最小化高度差）
>
> **核心难点**在于如何高效选择满足`上底 + 2×腰长 > 下底`的组合。可视化设计将用**像素积木**动态演示选择过程：
> - 木棍长度用不同颜色像素块数量表示
> - 关键步骤高亮：找腰时黄色闪烁，验证条件时显示不等式计算
> - 复古音效：找到腰时"叮"，成功时8-bit胜利旋律

---

#### 精选优质题解参考
**题解一（Drifty）**  
* **点评**：  
  思路清晰直白，通过排序后从后向前扫描定位腰的位置，分三种情况（腰前相邻、腰后非相邻、腰前非相邻）寻找上下底，覆盖了所有边界条件。代码中`f`变量精准标记腰的位置，循环边界处理严谨（如`f>1 && f+1<n`），`void()`返回简洁。实践价值高，可直接用于竞赛。

**题解二（c_legg）**  
* **点评**：  
  创新性使用二分查找优化搜索过程。先固定腰长`z`，遍历剩余元素作为上底，用`lower_bound`快速定位满足`x+2z > y`的最小下底`y`。代码中`a[i]=a[i-1]=1e9`的删除逻辑巧妙，但需注意二分后`y--`的边界校验。算法效率较高（O(n log n)），适合大数据量。

---

#### 核心难点辨析与解题策略
1. **腰的选择与验证**  
   * **分析**：必须存在长度相等的两根木棍，且越长越好（增大不等式成立概率）。贪心策略要求从排序数组末尾向前扫描找相等元素  
   * 💡 **学习笔记**：腰是梯形的"支柱"，优先选最长且成对的木棍  

2. **上下底的最优匹配**  
   * **分析**：上下底长度差越小，`上底 + 2×腰长 > 下底`越易成立。最优解一定在排序数组的相邻元素中产生（反证法：若跳过中间元素，差值更大）  
   * 💡 **学习笔记**：排序后相邻元素是上下底的黄金组合  

3. **边界条件处理**  
   * **分析**：需处理三种特殊情况：  
     - 无相等木棍（直接返回-1）  
     - 腰位于数组边界（前后无足够元素）  
     - 多组解时选择第一组可行解  
   * 💡 **学习笔记**：严谨的边界检查是AC的关键  

### ✨ 解题技巧总结
- **排序预处理**：立即对木棍排序，为后续操作奠定基础  
- **贪心双优先**：优先选最长腰，优先选相邻上下底  
- **不等式转化**：将几何条件转化为`上底 + 2×腰 > 下底`的代数约束  
- **防御性编程**：对每个索引访问进行边界校验  

---

#### C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void solve() {
    int n; cin >> n;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    sort(a.begin(), a.end());

    // 从后向前扫描找腰
    int waist = -1;
    for (int i = n-1; i >= 1; --i) {
        if (a[i] == a[i-1]) { 
            waist = i; 
            break;
        }
    }
    if (waist == -1) { cout << "-1\n"; return; }

    // 情况1：检查腰前相邻元素
    if (waist >= 2 && waist+1 < n) {
        if (a[waist-2] + a[waist] > a[waist+1]) {
            cout << a[waist-2] << " " << a[waist-1] << " " 
                 << a[waist] << " " << a[waist+1] << "\n";
            return;
        }
    }
    // 情况2：扫描腰后元素
    for (int i = waist+2; i < n; ++i) {
        if (a[i-1] + a[waist] > a[i]) {
            cout << a[i-1] << " " << a[waist] << " " 
                 << a[waist-1] << " " << a[i] << "\n";
            return;
        }
    }
    // 情况3：扫描腰前元素
    for (int i = 1; i < waist-1; ++i) {
        if (a[i-1] + a[waist] > a[i]) {
            cout << a[i-1] << " " << a[waist] << " " 
                 << a[waist-1] << " " << a[i] << "\n";
            return;
        }
    }
    cout << "-1\n";
}
```
* **代码解读概要**：  
  1. 排序后倒序找腰（`waist`标记位置）  
  2. 分三层检查：腰前相邻→腰后非相邻→腰前非相邻  
  3. 找到首个可行解立即返回  

**题解一（Drifty）片段赏析**  
```cpp
for (int i = f + 2; i < n; i++) 
    if (a[i-1] + a[f] + a[f-1] > a[i]) 
        return cout << a[i-1] << ' ' << a[f] << ' ' << a[i] << '\n', void();
```
* **亮点**：精炼的条件判断与返回逻辑  
* **解读**：  
  > 在腰位置`f`之后扫描，用`a[i-1]`和`a[i]`作为上下底候选。关键条件`a[i-1] + a[f] + a[f-1] > a[i]`实为`上底 + 腰1 + 腰2 > 下底`的变形，因两腰相等可简化为`上底 + 2×腰 > 下底`  
* 💡 **学习笔记**：利用逻辑短路特性将判断与返回合并为单行  

**题解二（c_legg）片段赏析**  
```cpp
y = lower_bound(a+i+1, a+n, 2*z+x) - a;
if (y == n) continue;
cout << x << " " << a[y] << " " << z << " " << z << endl;
```
* **亮点**：二分查找优化时间复杂度  
* **解读**：  
  > 对每个上底候选`x`，用`lower_bound`在剩余数组中找首个≥`2*z+x`的位置`y`。若`y`非边界，则`a[y]`是满足`x+2z > a[y]`的最小下底（因有序数组保证`a[y-1]`更小但可能不满足）  
* 💡 **学习笔记**：二分查找将O(n²)优化至O(n log n)  

---

#### 算法可视化：像素动画演示
* **主题**：8-bit积木搭建大冒险  
* **核心流程**：  
  1. **初始化**：  
     - 像素化木棍随机排列（长度=颜色块数量）  
     - 控制面板：步进/播放/重置按钮 + 速度滑块  
     - 背景：FC游戏风格网格，播放8-bit BGM  

  2. **排序阶段**：  
     - 冒泡排序动画：相邻木棍比较时高亮，交换时像素块滑动+“哔”音效  
     - 完成排序后所有木棍渐变有序色阶  

  3. **找腰阶段**：  
     - 扫描指针（像素箭头）从右向左移动  
     - 找到相等木棍时：黄色闪烁3次 + “叮！”音效，移到底部腰位  

  4. **寻底阶段**：  
     - 红色/蓝色指针扫描剩余木棍  
     - 实时显示当前检测的不等式：`x + 2z > y`  
     - 满足条件时：绿色高亮 + 胜利音效，木棍飞向梯形位置  

  5. **搭梯形**：  
     - 四木棍构成像素梯形：上底/下底水平，两腰倾斜  
     - 失败时播放"嘟"音效+显示`-1`像素图标  

* **交互设计**：  
  - 步进模式：按空格逐步执行，显示当前操作说明气泡  
  - AI演示：自动完成全过程（可调速）  

---

#### 拓展练习与相似问题思考
* **技巧迁移场景**：  
  1. 三角形构成问题（三边关系）  
  2. 矩形/正方形构造（两对相等边）  
  3. 不等式约束的元素选择（如`a+b>c`类问题）  

* **洛谷推荐**：  
  1. **P5715 三角形分类**  
     🗣️ 巩固三边关系判断，与本题梯形条件异曲同工  
  2. **P1102 A-B数对**  
     🗣️ 练习二分查找优化，强化本题找底策略  
  3. **P2249 查找**  
     🗣️ 掌握`lower_bound`的精确使用，提升二分能力  

---

#### 学习心得与经验分享
> **参考经验（Drifty）**：  
> *"忘记特判被叉掉了，破防了写一篇"*  
> **Kay点评**：  
> 调试的核心在于预见边界情况！本题需特别注意：  
> - 腰在数组两端时前后元素不足  
> - 多组解时只需输出第一组  
> 建议：写代码前手动画出数组位置关系图  

---

通过本次分析，我们深入掌握了贪心算法在几何构造中的应用。记住：好算法=正确策略+严谨实现+充分测试。下次挑战见！💪

---
处理用时：218.13秒
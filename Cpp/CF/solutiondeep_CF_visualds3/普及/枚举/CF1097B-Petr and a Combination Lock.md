# 题目信息

# Petr and a Combination Lock

## 题目描述

Petr has just bought a new car. He's just arrived at the most known Petersburg's petrol station to refuel it when he suddenly discovered that the petrol tank is secured with a combination lock! The lock has a scale of $ 360 $ degrees and a pointer which initially points at zero:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1097B/390f775757c241d3e93f871107696e4a8b8d123d.png)Petr called his car dealer, who instructed him to rotate the lock's wheel exactly $ n $ times. The $ i $ -th rotation should be $ a_i $ degrees, either clockwise or counterclockwise, and after all $ n $ rotations the pointer should again point at zero.

This confused Petr a little bit as he isn't sure which rotations should be done clockwise and which should be done counterclockwise. As there are many possible ways of rotating the lock, help him and find out whether there exists at least one, such that after all $ n $ rotations the pointer will point at zero again.

## 说明/提示

In the first example, we can achieve our goal by applying the first and the second rotation clockwise, and performing the third rotation counterclockwise.

In the second example, it's impossible to perform the rotations in order to make the pointer point at zero in the end.

In the third example, Petr can do all three rotations clockwise. In this case, the whole wheel will be rotated by $ 360 $ degrees clockwise and the pointer will point at zero again.

## 样例 #1

### 输入

```
3
10
20
30
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3
10
10
10
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
3
120
120
120
```

### 输出

```
YES
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Petr and a Combination Lock 深入学习指南 💡

<introduction>
今天我们来一起分析“Petr and a Combination Lock”这道C++编程题。这道题的核心是判断是否存在一种旋转方式，使得经过n次顺时针或逆时针旋转后，锁的指针回到0度。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`搜索（DFS）与动态规划（DP）的应用` 

🗣️ **初步分析**：
解决这道题的关键在于枚举所有可能的旋转方向组合，判断是否存在一种组合使得总旋转角度为360的倍数。简单来说，`搜索（DFS）`就像“探险”，每一步尝试两种选择（顺时针或逆时针），直到所有步骤完成后检查是否满足条件；`动态规划（DP）`则像“记录地图”，用数组记录每一步可能达到的角度状态，逐步推导最终结果。

- **题解思路对比**：大部分题解使用DFS枚举所有可能（时间复杂度约O(2ⁿ)），适用于n≤15的小数据；少数题解使用DP（时间复杂度O(n×360)），通过状态转移记录每一步可能的角度，效率更高。
- **核心算法流程**：DFS从初始角度0开始，递归尝试每次旋转的两种方向，最终检查总角度是否为360的倍数；DP则用`f[i][j]`表示前i次旋转后是否能达到j度，通过前一步的状态推导当前状态。
- **可视化设计**：我们将设计一个8位像素风格的动画，用不同颜色的像素块表示当前角度，通过“步进控制”展示每一步的选择（顺时针/逆时针），并用音效提示关键操作（如角度更新、找到解）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解（≥4星），供大家参考：
</eval_intro>

**题解一：动态规划解法（作者：ouuan）**
* **点评**：这份题解思路非常清晰，采用动态规划记录每一步的可能角度状态。代码中`f[i][j]`的定义简洁明了（前i次旋转后是否能达到j度），状态转移逻辑直接（前一步的j±a[i]模360）。代码规范，变量命名合理（如`N`、`M`作为常量），边界处理严谨（模运算避免负数）。算法时间复杂度为O(n×360)，远优于DFS的O(2ⁿ)，适合n较大的场景。实践价值高，可直接用于竞赛。

**题解二：DFS基础解法（作者：きりと）**
* **点评**：此题解使用DFS枚举所有可能，代码简洁易懂。递归函数`dfs(x, ans)`表示处理到第x次旋转时的总角度，通过两种选择（+a[x]或-a[x]）递归探索。虽然时间复杂度较高（O(2ⁿ)），但对于n≤15的题目足够高效。代码中处理了负数角度（`360+ans-a[x]`），避免了角度越界问题，是值得学习的细节。

**题解三：二进制枚举解法（作者：zjinyi）**
* **点评**：此题解利用二进制枚举所有旋转方向（每一位表示顺时针或逆时针），思路巧妙。通过`i >> j & 1`判断第j位的方向，计算总角度后检查是否为360的倍数。代码结构清晰，位运算的使用简洁高效。虽然时间复杂度与DFS相同（O(2ⁿ)），但枚举方式直观，适合理解“二进制表示选择”的思想。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何避免重复计算或无效搜索？
    * **分析**：DFS枚举所有可能时，可能重复访问相同的（步骤，角度）状态，导致冗余计算。优质题解（如Jerry_heng的优化DFS）通过`vis[k][s]`数组记录已访问状态，避免重复搜索，提升效率。DP解法则通过状态数组`f[i][j]`直接记录所有可能，天然避免重复。
    * 💡 **学习笔记**：状态记录（无论是DFS的剪枝还是DP的状态数组）是优化搜索问题的关键。

2.  **关键点2**：如何处理角度的模360运算？
    * **分析**：角度是环形的（0-359度），因此每次旋转后的角度需取模360。例如，逆时针旋转a[i]度后，角度可能为负数（如-10度），需转换为350度（`(-10 % 360 + 360) % 360`）。优质题解（如ouuan的DP）通过模运算统一处理正负角度，确保状态正确。
    * 💡 **学习笔记**：环形问题中，模运算能将状态限制在有效范围内，避免越界。

3.  **关键点3**：如何选择合适的算法（DFS vs DP）？
    * **分析**：当n较小时（如n≤15），DFS或二进制枚举的枚举量（2¹⁵=32768）可接受；当n较大时（如n≤20），DP的O(n×360)更高效。优质题解根据题目数据范围选择算法，体现了“具体问题具体分析”的思想。
    * 💡 **学习笔记**：算法选择需结合数据范围，小数据可暴力枚举，大数据需优化状态。

### ✨ 解题技巧总结
- **状态记录**：用数组记录已访问的（步骤，角度）状态，避免DFS重复搜索。
- **模运算处理**：角度计算时，使用`(x % 360 + 360) % 360`确保结果在0-359范围内。
- **二进制枚举**：用二进制位表示选择（如第j位为1表示顺时针），直观枚举所有可能。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择动态规划解法作为通用核心实现，因其时间复杂度更优，适合理解状态转移的思想。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ouuan的动态规划题解，逻辑清晰且高效，适合学习状态转移的核心思想。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    const int MAX_N = 20;   // 最大旋转次数
    const int DEGREE = 360; // 总度数

    int n;
    int a[MAX_N];
    bool dp[MAX_N][DEGREE]; // dp[i][j]表示前i次旋转后是否能达到j度

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
        }

        dp[0][0] = true; // 初始状态：0次旋转，角度0度

        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < DEGREE; ++j) {
                // 顺时针旋转a[i]度：前一步的角度为(j - a[i])%360
                int prev1 = (j - a[i] + DEGREE) % DEGREE;
                // 逆时针旋转a[i]度：前一步的角度为(j + a[i])%360
                int prev2 = (j + a[i]) % DEGREE;
                dp[i][j] = dp[i-1][prev1] || dp[i-1][prev2];
            }
        }

        cout << (dp[n][0] ? "YES" : "NO") << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入数据，初始化`dp[0][0]`为true（初始状态）。然后通过双重循环填充`dp`数组：外层循环遍历每次旋转，内层循环遍历所有可能的角度。对于每个角度j，判断是否能通过前一步的顺时针或逆时针旋转达到。最终检查`dp[n][0]`是否为true，输出结果。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解不同算法的实现细节：
</code_intro_selected>

**题解一：动态规划解法（作者：ouuan）**
* **亮点**：状态定义清晰，通过二维数组记录所有可能角度，避免重复计算，时间复杂度低。
* **核心代码片段**：
    ```cpp
    for (i=1;i<=n;++i) {
        for (j=0;j<M;++j) {
            f[i][j]=(f[i-1][(j+a[i])%M]|f[i-1][((j-a[i])%M+M)%M]);
        }
    }
    ```
* **代码解读**：外层循环处理第i次旋转，内层循环遍历所有可能的角度j。`(j+a[i])%M`表示前一步逆时针旋转a[i]度后的角度，`((j-a[i])%M+M)%M`处理顺时针旋转后的角度（避免负数）。`f[i][j]`为true当且仅当前一步能达到这两个角度中的一个。
* 💡 **学习笔记**：动态规划的核心是状态转移，通过前一步的状态推导当前状态，避免重复计算。

**题解二：DFS基础解法（作者：きりと）**
* **亮点**：递归逻辑简洁，直接枚举两种旋转方向，适合理解DFS的“尝试所有可能”思想。
* **核心代码片段**：
    ```cpp
    void dfs(int x,int ans) {
        if(x==n) {
            if(ans%360==0) flag=1;
            return;
        }
        dfs(x+1,ans+a[x]);
        if(ans>=a[x]) dfs(x+1,ans-a[x]);
        else dfs(x+1,360+ans-a[x]);
    }
    ```
* **代码解读**：递归函数`dfs(x, ans)`表示处理到第x次旋转时的总角度ans。当x==n时（所有旋转完成），检查ans是否为360的倍数。否则，递归尝试顺时针（ans+a[x]）和逆时针（ans-a[x]，若ans不足则加360）两种选择。
* 💡 **学习笔记**：DFS的关键是“深度优先”，每次选择一条路径走到底，再回溯尝试其他路径。

**题解三：二进制枚举解法（作者：zjinyi）**
* **亮点**：用二进制位表示旋转方向，枚举方式直观，适合理解“位运算表示选择”的思想。
* **核心代码片段**：
    ```cpp
    for (int i = 0; i < (1 << n); ++i) {
        int sum = 0;
        for (int j = 0; j < n; ++j) {
            if ((i >> j & 1) == 1) sum += a[j];
            else sum -= a[j];
        }
        if (sum % 360 == 0) { cout << "YES"; return 0; }
    }
    ```
* **代码解读**：外层循环枚举所有可能的二进制数（共2ⁿ个），每个数的每一位表示对应旋转的方向（1为顺时针，0为逆时针）。内层循环计算总角度sum，若sum是360的倍数则输出YES。
* 💡 **学习笔记**：二进制枚举适用于每个选择只有两种可能的场景，位运算能高效处理选择的表示。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解DFS或DP的执行过程，我们设计一个“像素锁匠探险”的8位像素风格动画，帮助大家“看”到每一步的选择和角度变化！
</visualization_intro>

  * **动画演示主题**：`像素锁匠的旋转挑战`

  * **核心演示内容**：展示DFS枚举所有旋转方向的过程（或DP状态转移），用像素块表示当前角度，通过颜色变化和音效提示关键步骤。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），营造轻松复古的学习氛围；关键操作（如选择方向、角度更新）伴随“叮”的音效，强化记忆；完成所有旋转并找到解时播放“胜利”音效，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示一个像素化的锁（圆形刻度盘，指针初始指向0度）。
          * 右侧显示“控制面板”（开始/暂停、单步、重置按钮；速度滑块）。
          * 底部显示当前处理的旋转次数（如“第1次旋转”）和当前角度（如“当前角度：0°”）。

    2.  **DFS启动**：
          * 初始状态：指针指向0度，旋转次数为0。
          * 点击“开始”，动画进入DFS递归过程：每次旋转有两种选择（顺时针/逆时针），用两个像素箭头（绿色为顺时针，红色为逆时针）表示。

    3.  **核心步骤演示**：
          * **选择方向**：当前旋转次数x的像素块高亮，箭头闪烁提示选择方向。点击“单步”，选择顺时针（指针顺时针转动a[x]度，绿色箭头放大）或逆时针（指针逆时针转动a[x]度，红色箭头放大）。
          * **角度更新**：指针移动后，当前角度用数字显示（如“+10° → 10°”或“-10° → 350°”），伴随“叮”的音效。
          * **递归深入**：旋转次数x增加1，重复上述步骤，直到x==n（所有旋转完成）。
          * **检查结果**：若总角度为360的倍数，指针回到0度，播放“胜利”音效（如“叮~”），并显示“YES”；否则继续回溯尝试其他路径。

    4.  **AI自动演示**：
          * 点击“AI自动演示”，动画自动快速执行DFS，展示所有可能的路径，最终找到解或确定无解。

    5.  **目标达成**：
          * 找到解时，锁的指针闪烁绿色，背景出现像素星星庆祝动画；无解时，指针闪烁红色，显示“NO”。

  * **旁白提示**：
      * （选择方向时）“现在是第1次旋转，可以选择顺时针（绿色箭头）或逆时针（红色箭头）哦！”
      * （角度更新时）“看，指针转到了10度！这是顺时针旋转的结果。”
      * （完成所有旋转时）“所有旋转完成，总角度是360度！指针回到0度，成功啦！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到每一步的选择如何影响最终结果，理解DFS“尝试所有可能”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的DFS和DP思路后，我们可以尝试以下类似问题，巩固算法应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * `DFS枚举`：适用于小数据量的“二选一”问题（如子集和问题、路径选择问题）。
      * `动态规划`：适用于需要记录状态的环形问题（如钟表角度问题、环形数组最大值问题）。
      * `二进制枚举`：适用于每个选择只有两种可能的场景（如开关灯问题、子集选择问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1101** - `单词方阵`
          * 🗣️ **推荐理由**：这道题需要DFS搜索满足条件的单词路径，练习DFS的方向选择和剪枝技巧。
    2.  **洛谷 P1048** - `采药`
          * 🗣️ **推荐理由**：经典的0-1背包问题，练习动态规划的状态定义和转移方程设计。
    3.  **洛谷 P1706** - `全排列问题`
          * 🗣️ **推荐理由**：用DFS或二进制枚举生成全排列，练习枚举所有可能的思想。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“Petr and a Combination Lock”的C++解题分析就到这里。希望这份指南能帮助大家理解DFS和DP的核心思想，掌握枚举和状态转移的技巧。记住，编程的关键在于多思考、多练习，下次我们再一起挑战新的题目！💪
</conclusion>

-----

---
处理用时：134.56秒
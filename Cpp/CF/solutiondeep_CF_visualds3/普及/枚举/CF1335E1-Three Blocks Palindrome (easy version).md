# 题目信息

# Three Blocks Palindrome (easy version)

## 题目描述

The only difference between easy and hard versions is constraints.

You are given a sequence $ a $ consisting of $ n $ positive integers.

Let's define a three blocks palindrome as the sequence, consisting of at most two distinct elements (let these elements are $ a $ and $ b $ , $ a $ can be equal $ b $ ) and is as follows: $ [\underbrace{a, a, \dots, a}_{x}, \underbrace{b, b, \dots, b}_{y}, \underbrace{a, a, \dots, a}_{x}] $ . There $ x, y $ are integers greater than or equal to $ 0 $ . For example, sequences $ [] $ , $ [2] $ , $ [1, 1] $ , $ [1, 2, 1] $ , $ [1, 2, 2, 1] $ and $ [1, 1, 2, 1, 1] $ are three block palindromes but $ [1, 2, 3, 2, 1] $ , $ [1, 2, 1, 2, 1] $ and $ [1, 2] $ are not.

Your task is to choose the maximum by length subsequence of $ a $ that is a three blocks palindrome.

You have to answer $ t $ independent test cases.

Recall that the sequence $ t $ is a a subsequence of the sequence $ s $ if $ t $ can be derived from $ s $ by removing zero or more elements without changing the order of the remaining elements. For example, if $ s=[1, 2, 1, 3, 1, 2, 1] $ , then possible subsequences are: $ [1, 1, 1, 1] $ , $ [3] $ and $ [1, 2, 1, 3, 1, 2, 1] $ , but not $ [3, 2, 3] $ and $ [1, 1, 1, 1, 2] $ .

## 样例 #1

### 输入

```
6
8
1 1 2 2 3 2 1 1
3
1 3 3
4
1 10 10 1
1
26
2
2 1
3
1 1 1```

### 输出

```
7
2
4
1
1
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：Three Blocks Palindrome (easy version) 深入学习指南 💡

<introduction>
今天我们来一起分析“Three Blocks Palindrome (easy version)”这道题。它要求我们找到最长的子序列，满足左右对称的三个块结构（左右块元素相同，中间块任意）。本指南将带大家梳理核心思路，解析优质题解，并通过像素动画直观理解算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（枚举可能的元素值和块长度） + 编程技巧应用（前缀和优化统计）

🗣️ **初步分析**：
解决这道题的关键在于“枚举”——由于元素值范围较小（题目中元素值≤200），我们可以枚举左右块的元素值`a`和左右块的长度`x`，然后快速计算中间块的最大可能长度`y`。简单来说，枚举就像“试错法”：我们逐一尝试可能的`a`和`x`，看看哪种组合能得到最长的回文子序列。

- **题解思路**：多数题解采用“枚举+前缀和”的组合策略：首先用前缀和数组快速统计任意区间内元素的出现次数；然后枚举左右块的元素`a`和长度`x`，确定左右块的位置后，中间块的最大`y`即为中间区间内出现次数最多的元素的次数。最终取所有可能情况的最大值。
- **核心难点**：如何高效枚举`a`和`x`，并快速计算中间块的最大`y`。优质题解通过预处理每个元素的位置（如用vector存储元素出现的索引）和前缀和数组，将统计复杂度从O(n)降到O(1)。
- **可视化设计**：我们将设计一个“像素寻宝”动画，用不同颜色的像素块表示不同元素，左右块的选取过程用箭头标记，中间块的统计用柱状图动态展示，关键步骤伴随“叮”的音效，帮助直观理解枚举和统计过程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解因逻辑直白、优化合理被选为优质参考（≥4星）：
</eval_intro>

**题解一：作者FCBM71（暴力枚举思路）**
* **点评**：此题解用三重循环枚举左右分界点`l`和`r`，以及元素值`a`和`b`，思路直白易懂。虽然暴力，但通过前缀和优化统计（`sum[i][x]`表示前`x`个元素中`i`的出现次数），大大提升了效率。代码中`tomax`函数的设计体现了细节优化，适合初学者理解基础枚举逻辑。

**题解二：作者One_JuRuo（枚举a和x，前缀和统计）**
* **点评**：此题解巧妙利用vector存储每个元素的位置，枚举`a`和左右块长度`x`时，直接通过位置索引确定左右块的范围（如`v[i][j]`表示元素`i`的第`j+1`次出现位置），再用前缀和统计中间区间的最大`y`。代码结构清晰，变量名（如`l`、`r`）含义明确，边界处理（如`l==r`时的特判）严谨，是高效枚举的典范。

**题解三：作者ctq1999（枚举+前缀和优化）**
* **点评**：此题解通过预处理`sum`数组（`sum[i][j]`表示前`j`个元素中`i`的出现次数）和`at`数组（`at[i]`存储元素`i`的所有出现位置），将枚举复杂度控制在合理范围。三重循环（枚举`a`、`x`、中间块元素`b`）逻辑紧凑，利用数组索引直接计算区间，代码简洁高效，适合竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决此题时，我们常遇到以下关键点，掌握这些能帮助我们快速突破：
</difficulty_intro>

1.  **关键点1：如何枚举左右块的元素`a`和长度`x`？**
    * **分析**：`a`的可能取值是1~200（题目隐含限制），枚举所有`a`是可行的。对于每个`a`，其出现的位置存储在vector中（如`v[a]`），`x`的取值范围是0到`v[a].size()/2`（左右块各取`x`个`a`）。例如，若`v[a]`有5个位置，`x`可取0、1、2（左右块各取0、1、2个`a`）。
    * 💡 **学习笔记**：枚举`a`时，优先处理出现次数多的元素（可能贡献更长的回文）。

2.  **关键点2：如何快速计算中间块的最大`y`？**
    * **分析**：中间块是左右块之间的区间（左块结束位置`l`到右块开始位置`r`之间），需要统计该区间内出现次数最多的元素的次数。通过前缀和数组`sum[k][r-1] - sum[k][l]`（`k`为元素值），可O(1)计算任意区间内`k`的出现次数，遍历所有`k`取最大值即可。
    * 💡 **学习笔记**：前缀和是处理区间统计问题的“万能钥匙”，预处理后能大幅提升效率。

3.  **关键点3：如何处理边界条件（如`x=0`或左右块重叠）？**
    * **分析**：当`x=0`时，回文退化为中间块（即普通最长子序列），需单独考虑。当左右块位置重叠（`l >= r`）时，中间块长度为0，此时回文长度为`2x`。
    * 💡 **学习笔记**：边界条件的处理是避免错误的关键，枚举时需检查`l`和`r`的大小关系。

### ✨ 解题技巧总结
- **预处理位置数组**：用vector存储每个元素的出现位置，快速定位左右块的位置（如`v[a][j]`是第`j+1`个`a`的位置）。
- **前缀和优化统计**：预处理`sum[i][j]`数组，O(1)计算任意区间内元素`i`的出现次数，避免重复遍历。
- **枚举范围收缩**：枚举`x`时，仅需枚举到`v[a].size()/2`，减少无效计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解的思路，提炼出一个清晰、高效的核心实现，帮助大家快速掌握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了One_JuRuo和ctq1999的思路，通过预处理位置数组和前缀和数组，枚举`a`和`x`，计算中间块的最大`y`。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAX_A = 200; // 题目中元素值最大为200

    int main() {
        int T;
        cin >> T;
        while (T--) {
            int n;
            cin >> n;
            vector<int> a(n + 1); // 数组从1开始索引
            vector<vector<int>> pos(MAX_A + 1); // pos[v]存储值为v的元素的位置（从0开始）
            vector<vector<int>> sum(MAX_A + 1, vector<int>(n + 1, 0)); // sum[v][i]表示前i个元素中v的出现次数

            for (int i = 1; i <= n; ++i) {
                cin >> a[i];
                pos[a[i]].push_back(i); // 记录位置
                for (int v = 1; v <= MAX_A; ++v) {
                    sum[v][i] = sum[v][i - 1] + (a[i] == v); // 前缀和更新
                }
            }

            int ans = 0;
            // 情况1：仅中间块（x=0），即最长子序列长度
            for (int v = 1; v <= MAX_A; ++v) {
                ans = max(ans, sum[v][n]);
            }

            // 情况2：枚举a和x（左右块各x个a）
            for (int a_val = 1; a_val <= MAX_A; ++a_val) {
                int cnt = pos[a_val].size(); // a_val的出现次数
                if (cnt < 2) continue; // 无法形成左右块（x≥1）

                // 枚举x（左右块各取x个a_val）
                for (int x = 0; x <= cnt / 2; ++x) {
                    if (x == 0) continue; // 已在情况1处理过x=0
                    int l_pos = pos[a_val][x - 1]; // 左块的第x个a的位置（索引从0开始）
                    int r_pos = pos[a_val][cnt - x]; // 右块的第x个a的位置（从后往前数x个）

                    if (l_pos >= r_pos) { // 左右块重叠，中间块长度为0
                        ans = max(ans, 2 * x);
                        continue;
                    }

                    // 计算中间块（l_pos+1到r_pos-1）中出现次数最多的元素的次数
                    int max_y = 0;
                    for (int b_val = 1; b_val <= MAX_A; ++b_val) {
                        max_y = max(max_y, sum[b_val][r_pos - 1] - sum[b_val][l_pos]);
                    }
                    ans = max(ans, 2 * x + max_y);
                }
            }

            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理每个元素的位置数组`pos`和前缀和数组`sum`。然后分两种情况计算答案：仅中间块（x=0）和左右块+中间块（x≥1）。枚举`a_val`（左右块的元素）和`x`（左右块的长度），通过`pos`数组定位左右块的位置，再用`sum`数组快速计算中间块的最大`y`，最终更新答案。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙思路：
</code_intro_selected>

**题解二：作者One_JuRuo**
* **亮点**：利用vector存储元素位置，枚举`x`时直接通过索引定位左右块，代码简洁直观。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=26;++i) // 枚举a_val（元素值）
        if(v[i].size()>1) {
            res=0;
            for(int j=0;j<=(int)ceil(1.0*(v[i].size()-2)/2);++j) { // 枚举x
                int l=v[i][j],r=v[i][v[i].size()-j-1]; // 左右块的位置
                if(l==r) ans=max(ans,res+1);
                else {
                    res+=2;
                    for(int k=1;k<=26;++k) 
                        if(k!=i) ans=max(ans,res+num[r-1][k]-num[l][k]); // 计算中间块的y
                }
            }
        }
    ```
* **代码解读**：
    这里`v[i]`存储元素`i`的所有出现位置（按顺序）。`j`表示左右块各取`j+1`个`i`（因为`j`从0开始）。`l`是左块的第`j+1`个`i`的位置，`r`是右块的第`j+1`个`i`的位置（从后往前数）。中间块的区间是`l+1`到`r-1`，通过前缀和数组`num`快速计算该区间内其他元素的最大出现次数（`num[r-1][k]-num[l][k]`）。
* 💡 **学习笔记**：用vector存储元素位置，能快速定位左右块的位置，避免重复遍历原数组。

**题解三：作者ctq1999**
* **亮点**：通过`at`数组存储元素位置，`sum`数组统计前缀和，三重循环逻辑紧凑，适合竞赛场景。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= m; i++) { // 枚举a_val
        ans = max(ans, sum[i][n]); // 处理x=0的情况
        for (int j = 1; 2 * j <= sum[i][n]; j++) { // 枚举x（左右块各j个a_val）
            int from = at[i][j - 1]; // 左块的第j个a_val的位置
            int to = at[i][sum[i][n] - j]; // 右块的第j个a_val的位置
            for (int k = 1; k <= m; k++) { // 枚举中间块的b_val
                ans = max(ans, sum[i][from] + (sum[k][to - 1] - sum[k][from]) + (sum[i][n] - sum[i][to - 1]));
            }
        }
    }
    ```
* **代码解读**：
    `sum[i][from]`是左块中`a_val`的个数（即`j`），`sum[i][n] - sum[i][to - 1]`是右块中`a_val`的个数（也是`j`），中间块的`y`是`sum[k][to - 1] - sum[k][from]`（元素`k`在中间区间的出现次数）。总长度是`j + y + j = 2j + y`。
* 💡 **学习笔记**：将左右块的长度直接通过前缀和计算，避免显式遍历，提升效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举`a`和`x`、计算中间块`y`的过程，我们设计一个“像素寻宝”动画，用8位复古风格展示算法每一步！
</visualization_intro>

  * **动画演示主题**：像素探险家的回文宝藏
  * **核心演示内容**：探险家（像素小人）在元素序列（像素块组成的长条形地图）中，通过枚举`a`（不同颜色的宝石）和`x`（收集宝石的数量），找到左右对称的宝石块，并在中间区域寻找最多的另一种宝石（`b`），最终收集最长的回文宝藏。

  * **设计思路简述**：8位像素风格降低学习压力，颜色区分不同元素（如红色代表`a`，蓝色代表`b`）。关键步骤（如枚举`a`、选择`x`、统计`y`）用闪烁、音效提示，帮助记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕下方是元素序列（20x5的像素块，每个块颜色代表元素值）。
        - 左侧显示控制面板：单步/自动播放按钮、速度滑块（1x~5x）、重置按钮。
        - 右侧显示当前`a`（红色标记）、`x`（数字）、中间块`y`（蓝色柱状图）。
        - 播放8位风格背景音乐（类似《超级马里奥》的轻快旋律）。

    2.  **枚举`a`**：
        - 探险家从左到右遍历元素序列，每遇到一个新颜色（如红色），该颜色的所有像素块高亮（黄色边框），伴随“叮”的音效，表示当前枚举的`a`。

    3.  **枚举`x`**：
        - 探险家在`a`的像素块中，从两端向中间依次选取`x`个块（如`x=1`时，选最左和最右的红色块；`x=2`时，选次左和次右的红色块）。每选一对，红色块闪烁，音效“叮-叮”。

    4.  **计算中间块`y`**：
        - 中间区间（左右红色块之间）的像素块变为灰色背景，探险家在其中“扫描”，每个颜色块上方弹出数字（出现次数），最大数字的块变为蓝色并放大，音效“嗡”，表示找到最大`y`。

    5.  **更新答案**：
        - 当前总长度（`2x + y`）显示在屏幕顶部，若超过之前最大值，数字闪烁并播放“胜利”音效（如《超级玛丽》吃金币声）。

    6.  **AI自动演示**：
        - 点击“AI演示”，探险家自动快速遍历所有可能的`a`和`x`，用箭头标记关键步骤，帮助学习者观察全局流程。

  * **旁白提示**：
      - （枚举`a`时）“现在探险家在尝试颜色`a`，它的所有出现位置被高亮啦！”
      - （枚举`x`时）“选`x=2`个`a`，左右各取两个红色块，中间区域是它们之间的部分～”
      - （计算`y`时）“中间区域里，蓝色块出现次数最多，`y`就是它的次数！”

<visualization_conclusion>
通过这个动画，我们能直观看到枚举`a`和`x`的过程，以及中间块`y`的计算方式，仿佛和探险家一起“寻宝”，轻松理解算法核心！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的枚举+前缀和思路在许多区间统计问题中都有应用，我们可以通过以下练习巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - **多元素枚举**：当元素值范围较小时（如≤200），枚举元素值是高效的策略（如统计众数、最长子序列等）。
      - **区间统计优化**：前缀和数组能将区间统计复杂度从O(n)降为O(1)，适用于需要多次查询区间和的场景（如最大子段和、滑动窗口统计）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1115 最大子段和**
          * 🗣️ **推荐理由**：练习区间和的枚举与统计，理解如何用前缀和快速计算子段和。
    2.  **洛谷 P1908 逆序对**
          * 🗣️ **推荐理由**：学习用归并排序或树状数组统计区间内的逆序对，掌握高效统计技巧。
    3.  **洛谷 P1093 奖学金**
          * 🗣️ **推荐理由**：练习多条件枚举（分数、科目），提升综合枚举能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中虽未明确作者的调试心得，但通过分析代码可以总结出以下经验：
</insights_intro>

> **参考经验**：在枚举`x`时，需注意左右块位置的边界（如`l_pos >= r_pos`），否则中间块长度可能为负。例如，当元素`a`的出现次数为奇数时，中间的`a`会被左右块同时选取，此时需特判。

> **点评**：这类边界问题容易被忽略，但通过预处理元素位置数组（如`pos[a]`）并在枚举时检查`l`和`r`的大小关系，可以有效避免错误。建议在编写代码时，先手动模拟小例子（如样例输入），验证边界条件的处理是否正确。

-----

<conclusion>
通过对“Three Blocks Palindrome (easy version)”的分析，我们掌握了枚举+前缀和的解题思路，理解了如何高效统计区间元素次数。希望大家通过练习巩固这些技巧，下次遇到类似问题时能快速找到突破口！💪
</conclusion>

-----

---
处理用时：149.54秒
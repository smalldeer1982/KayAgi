# 题目信息

# Number of Triplets

## 题目描述

You are given $ n $ points on a plane. All points are different.

Find the number of different groups of three points $ (A,B,C) $ such that point $ B $ is the middle of segment $ AC $ .

The groups of three points are considered unordered, that is, if point $ B $ is the middle of segment $ AC $ , then groups $ (A,B,C) $ and $ (C,B,A) $ are considered the same.

## 样例 #1

### 输入

```
3
1 1
2 2
3 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
0 0
-1 0
0 1
```

### 输出

```
0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Number of Triplets 深入学习指南 💡

<introduction>
今天我们来一起分析“Number of Triplets”这道C++编程题。题目要求找出所有满足B是A和C中点的三元组(A,B,C)，且三元组无序。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举+哈希查找（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键在于高效判断“中点是否存在”。简单来说，我们需要枚举所有可能的点对(A,C)，计算它们的中点B，再检查B是否在给定的点集中。这里的“枚举”是基础，而“哈希查找”（或类似的快速查询结构）是优化的核心，就像用“超级字典”快速翻查某个单词是否存在一样。

- **题解思路**：所有题解的核心思路一致：枚举每对点(A,C)，计算中点B的坐标，若B存在于点集且为整数坐标，则计数。差异主要在“如何存储点集”（如二维数组、set、vector）和“如何优化查找”。
- **核心难点**：如何高效判断中点是否存在？如何避免重复计算？如何处理中点的整数坐标问题？
- **可视化设计**：用8位像素网格展示点集，枚举时用不同颜色箭头连接当前点对(A,C)，中点B用闪烁的像素块表示，检查存在时绿色高亮（存在）或红色闪烁（不存在），伴随“叮”或“咚”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下3份优质题解：
</eval_intro>

**题解一：zh1221_qwq的二维数组优化法**
* **点评**：此题解巧妙利用坐标范围小的特点（[-1000,1000]），用二维数组`b`直接标记点的存在，查找时间O(1)。代码简洁规范（变量名`x[i]`、`y[i]`含义明确），枚举时严格i<j避免重复，边界处理严谨（检查坐标和的奇偶性）。实践价值高，适合坐标范围有限的场景。

**题解二：TheSky233的set通用解法**
* **点评**：此题解使用`std::set`存储点集，通用性强（不受坐标范围限制）。代码结构清晰（`midPoint`函数封装中点计算），枚举逻辑严谨（i<j避免重复），时间复杂度O(n² logn)，适合一般数据范围。是竞赛中常见的“哈希查找”典型应用。

**题解三：wang_freedom的set简洁实现**
* **点评**：此题解用`set`和`vector`结合存储点集，代码简洁（使用`rep`宏简化循环），逻辑直白。枚举时直接检查中点是否存在，关键步骤（奇偶判断、查找）清晰，是“枚举+哈希”思路的精简实现，适合快速理解核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于高效判断中点是否存在、避免重复计算及处理整数坐标问题。以下是具体分析：
</difficulty_intro>

1.  **关键点1：如何高效判断中点是否存在？**
    * **分析**：直接遍历所有点判断中点是否存在会超时（O(n³)）。优质题解通过“哈希查找”优化：用二维数组（坐标范围小）或`set`（通用场景）存储点，将查找时间降至O(1)或O(logn)。例如，zh1221_qwq用二维数组`b[x+1000][y+1000]`标记点存在，查找时直接访问数组；TheSky233用`set<pair<int,int>>`，利用红黑树快速查找。
    * 💡 **学习笔记**：选择合适的存储结构能大幅提升效率——坐标范围小时用数组，通用场景用`set`或`unordered_set`。

2.  **关键点2：如何避免重复计算？**
    * **分析**：三元组无序，(A,B,C)和(C,B,A)视为同一组。优质题解通过枚举i<j的点对（i从1到n，j从i+1到n），确保每对点只计算一次，避免重复。
    * 💡 **学习笔记**：枚举时固定顺序（如i<j）是避免重复计数的常用技巧。

3.  **关键点3：如何处理中点的整数坐标？**
    * **分析**：若A(x1,y1)和C(x2,y2)的坐标和为奇数（x1+x2或y1+y2为奇数），则中点坐标为小数，不可能存在于整数点集中。优质题解通过`(x1+x2)%2==0`和`(y1+y2)%2==0`提前过滤这些情况，减少无效计算。
    * 💡 **学习笔记**：提前剪枝（如奇偶判断）能有效减少计算量。

### ✨ 解题技巧总结
<summary_best_practices>
- **数据结构选择**：根据坐标范围选择存储结构（小范围用数组，大范围用`set`）。
- **枚举顺序控制**：固定i<j避免重复计数。
- **提前剪枝**：通过奇偶判断过滤无效中点，减少计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是一个通用的核心C++实现，综合了zh1221_qwq和TheSky233的思路，兼顾效率与通用性。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了“二维数组快速查找”和“set通用存储”的优点，适用于坐标范围有限的场景（本题坐标[-1000,1000]）。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    const int OFFSET = 1000; // 坐标偏移量，处理负数
    int n, ans;
    bool point[2005][2005]; // 标记点是否存在，索引范围0~2000（对应-1000~1000）
    vector<pair<int, int>> points; // 存储所有点

    int main() {
        cin >> n;
        for (int i = 0; i < n; ++i) {
            int x, y;
            cin >> x >> y;
            points.emplace_back(x, y);
            point[x + OFFSET][y + OFFSET] = true; // 偏移后存储
        }
        // 枚举所有i<j的点对
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int x1 = points[i].first, y1 = points[i].second;
                int x2 = points[j].first, y2 = points[j].second;
                // 检查坐标和是否为偶数（中点为整数）
                if ((x1 + x2) % 2 != 0 || (y1 + y2) % 2 != 0) continue;
                int mid_x = (x1 + x2) / 2, mid_y = (y1 + y2) / 2;
                // 检查中点是否存在（偏移后查找）
                if (point[mid_x + OFFSET][mid_y + OFFSET]) {
                    ans++;
                }
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取所有点，用二维数组`point`标记点的存在（偏移处理负数坐标）。然后枚举所有i<j的点对，计算中点坐标，检查坐标和是否为偶数（避免小数中点），最后通过二维数组快速判断中点是否存在。核心逻辑在双重循环中实现，时间复杂度O(n²)，适合本题数据范围。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：zh1221_qwq的二维数组优化法**
* **亮点**：利用坐标范围小的特点，用二维数组实现O(1)查找，效率极高。
* **核心代码片段**：
    ```cpp
    int n,b[2005][2005],x[3005],y[3005],ans; 
    int main(){
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>x[i]>>y[i];
            b[x[i]+1000][y[i]+1000]=1; // 偏移存储
        }
        for(int i=1;i<=n;i++){
            for(int j=i+1;j<=n;j++){
                if((x[i]+x[j])%2==0&&(y[i]+y[j])%2==0&&b[(x[i]+x[j])/2+1000][(y[i]+y[j])/2+1000]==1)ans++;
            }
        }
        cout<<ans;
    }
    ```
* **代码解读**：
    > 这段代码的核心是二维数组`b`的使用。`x[i]+1000`和`y[i]+1000`将坐标[-1000,1000]映射到数组索引[0,2000]，实现O(1)查找。双重循环枚举i<j的点对，检查中点坐标和的奇偶性，若为偶数则计算中点并在数组中查找。找到则计数加一。
* 💡 **学习笔记**：坐标范围有限时，二维数组是比`set`更高效的选择，适合优化时间复杂度。

**题解二：TheSky233的set通用解法**
* **亮点**：使用`set`存储点，通用性强，不受坐标范围限制。
* **核心代码片段**：
    ```cpp
    std::set<std::pair<int, int> > st;
    std::pair<int, int> point[N];
    int main(){
        for(int i=1;i<=n;i++){
            st.insert(std::make_pair(x,y)); // 存储点集
        }
        for(int i=1;i<=n;i++){
            for(int j=i+1;j<=n;j++){
                auto a=point[i],b=point[j];
                if((a.first+b.first)&1 || (a.second+b.second)&1) continue;
                if(st.count(midPoint(a,b))) ans++; // 查找中点
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码的核心是`set`的使用。`st.insert`将所有点存入`set`，`st.count`快速判断中点是否存在。`midPoint`函数计算中点坐标，奇偶判断过滤小数中点。枚举i<j避免重复，确保每个三元组只计算一次。
* 💡 **学习笔记**：`set`适合坐标范围大或不确定的场景，虽然查找时间是O(logn)，但代码通用性强。

**题解三：wang_freedom的set简洁实现**
* **亮点**：代码简洁，用`vector`存储点，`set`查找，逻辑直白。
* **核心代码片段**：
    ```cpp
    set<pii>st;
    vector<pii>v;
    signed main(){
        rep(i,0,n-2)
            rep(j,i+1,n-1){
                if((v[i].fi+v[j].fi)&1||(v[i].se+v[j].se)&1)
                    continue;
                if(st.find({(v[i].fi+v[j].fi)/2,(v[i].se+v[j].se)/2})!=st.end())
                    ans++; 
            }
    }
    ```
* **代码解读**：
    > 这段代码用`vector`存储所有点，`set`快速查找。`rep`宏简化循环，奇偶判断过滤无效中点，`st.find`检查中点是否存在。代码结构简单，适合快速理解核心逻辑。
* 💡 **学习笔记**：`vector`+`set`的组合是“存储+查找”的经典搭配，代码简洁易读。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“枚举点对+查找中点”的过程，我们设计了一个8位像素风格的动画，模拟算法执行！
</visualization_intro>

  * **动画演示主题**：`像素点的中点探险`

  * **核心演示内容**：展示点集网格，枚举点对(A,C)，计算中点B，检查B是否存在，计数累加。

  * **设计思路简述**：采用FC红白机风格的像素网格（16色调色板），用不同颜色区分点（A红、C蓝、B绿）。关键操作（枚举、计算中点、查找）用动画和音效强化记忆，游戏化“小关卡”设计（每找到一个有效三元组，播放“叮”声并弹出“+1”分数）。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕中央显示20x20的像素网格（每个格子代表1x1坐标，偏移后覆盖[-1000,1000]）。
          * 所有输入点用黄色像素块显示，控制面板有“开始”“暂停”“单步”按钮和速度滑块。
          * 播放8位风格的轻快背景音乐（如《超级马力欧》的经典旋律）。

    2.  **枚举点对**：
          * 初始时选中第一个点A（红色闪烁），第二个点C（蓝色闪烁），用白色箭头连接A和C。
          * 伴随“滴”的音效，箭头从A滑向C，标记当前枚举的点对。

    3.  **计算中点**：
          * 在A和C中间位置弹出一个小窗口，显示中点坐标计算过程（如“(1+3)/2=2，(1+3)/2=2”）。
          * 若坐标和为奇数（如1+2=3），窗口显示“× 非整数中点”，伴随“咚”的提示音。

    4.  **查找中点**：
          * 若中点为整数，网格中对应位置的像素块开始闪烁（绿色）。
          * 检查是否存在：若存在（黄色块），绿色块变为实心并播放“叮”声；若不存在，绿色块消失并播放“咚”声。

    5.  **计数累加**：
          * 找到有效三元组时，屏幕右上角分数从0开始累加（如“当前计数：1”），伴随“+1”的像素动画。

    6.  **AI自动演示**：
          * 点击“AI自动演示”，算法自动快速枚举所有点对，箭头快速移动，中点计算和查找过程加速，最终显示总计数。

  * **旁白提示**：
      * （枚举时）“现在我们枚举第i个点和第j个点（i<j），确保不重复计算哦~”
      * （计算中点时）“看！A和C的坐标和是偶数，中点是整数，可能存在哦~”
      * （查找成功时）“中点B存在！这个三元组符合条件，计数加一！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到每一步枚举、计算和查找的过程，轻松理解“枚举+哈希查找”的核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的“枚举+哈希查找”思路后，我们可以尝试以下类似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“枚举点对+哈希查找”思路可迁移至：
        1. 寻找满足特定条件的点三元组（如共线、垂直等）。
        2. 统计数组中满足a+b=2c的三元组数量。
        3. 解决需要快速判断元素是否存在的枚举问题（如两数之和、四数之和）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1102 A-B数对**  
        * 🗣️ **推荐理由**：需要枚举A-B=C的情况，用哈希表统计频率，与本题“枚举+查找”思路类似。
    2.  **洛谷 P1803 线段覆盖**  
        * 🗣️ **推荐理由**：需要枚举活动时间，用排序+贪心优化，锻炼枚举与优化结合的思维。
    3.  **洛谷 P5739 【深基7.例7】计算阶乘**  
        * 🗣️ **推荐理由**：基础枚举练习，适合巩固循环和边界处理。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“Number of Triplets”的C++解题分析就到这里。通过枚举点对、哈希查找和避免重复的技巧，我们能高效解决问题。希望这份指南能帮助大家掌握核心思路，快去动手练习吧！💪
</conclusion>

---
处理用时：150.45秒
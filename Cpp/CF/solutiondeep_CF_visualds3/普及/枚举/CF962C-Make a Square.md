# 题目信息

# Make a Square

## 题目描述

You are given a positive integer $ n $ , written without leading zeroes (for example, the number 04 is incorrect).

In one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.

Determine the minimum number of operations that you need to consistently apply to the given integer $ n $ to make from it the square of some positive integer or report that it is impossible.

An integer $ x $ is the square of some positive integer if and only if $ x=y^2 $ for some positive integer $ y $ .

## 说明/提示

In the first example we should delete from $ 8314 $ the digits $ 3 $ and $ 4 $ . After that $ 8314 $ become equals to $ 81 $ , which is the square of the integer $ 9 $ .

In the second example the given $ 625 $ is the square of the integer $ 25 $ , so you should not delete anything.

In the third example it is impossible to make the square from $ 333 $ , so the answer is -1.

## 样例 #1

### 输入

```
8314
```

### 输出

```
2
```

## 样例 #2

### 输入

```
625
```

### 输出

```
0
```

## 样例 #3

### 输入

```
333
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Make a Square 深入学习指南 💡

<introduction>
今天我们来一起分析“Make a Square”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。题目要求我们通过删除最少的数字，将给定正整数变为完全平方数，若无法实现则返回-1。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举与子序列匹配（结合搜索思想）

🗣️ **初步分析**：
解决这道题的关键在于“枚举可能的平方数，判断其是否是原数的子序列”。简单来说，枚举就像“大海捞针”，但这里的“海”是有限的——因为原数最多9位，平方数的范围最多到原数本身（即√n）。我们需要从大到小枚举这些平方数，检查它们是否能通过删除原数的某些位得到（即是否是原数的子序列），找到匹配的最长平方数，就能得到最少删除次数。

- **题解思路对比**：主流思路有两种：  
  1. **枚举平方数法**（如GusyNight、Wf_yjqd的题解）：从√n向下枚举平方数，用双指针法判断是否是原数的子序列；  
  2. **DFS搜索法**（如Andy_Li、QianianXY的题解）：暴力搜索所有可能的子序列，判断是否为平方数，记录最长有效子序列。  
  枚举法的时间复杂度更低（O(√n·log n)），而DFS法更直观但可能稍慢（但9位数的DFS仍可行）。

- **核心算法流程**：以枚举法为例，流程为：  
  1. 拆分原数的每一位；  
  2. 从大到小枚举平方数（i²）；  
  3. 拆分平方数的每一位；  
  4. 双指针匹配原数和平方数的各位，若完全匹配则计算删除次数（原数位数-平方数位数）；  
  5. 找到第一个匹配的平方数（即最长的），输出结果。

- **可视化设计**：采用8位像素风格，用彩色方块表示原数的每一位（如蓝色），枚举的平方数用绿色方块动态展示。双指针移动时用黄色箭头标记，匹配成功时绿色方块闪烁并播放“叮”的音效。若找到最终解，播放胜利音效并高亮结果。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，筛选出以下3篇优质题解：
</eval_intro>

**题解一：作者GusyNight**  
* **点评**：此题解思路简洁高效！作者从大到小枚举平方数（i²），用双指针法判断其是否是原数的子序列。代码结构清晰，变量命名直观（如`cnt1`记录原数位数，`cnt2`记录平方数位数），边界处理严谨（如跳过前导零）。算法时间复杂度低（O(√n·log n)），在竞赛中非常实用。亮点在于“从大到小枚举”的策略，确保找到的第一个匹配平方数即为最长（删除次数最少），避免了后续无效枚举。

**题解二：作者Andy_Li**  
* **点评**：此题解采用DFS搜索所有可能的子序列，通过递归枚举“删或不删”每一位，记录当前构造的数并判断是否为平方数。代码规范（如使用`typedef long long ll`提升可读性），特别处理了前导零问题（如`checks`函数验证位数匹配）。虽然时间复杂度略高（O(2^9)），但思路直观，适合理解子序列的生成过程。亮点在于递归参数设计（`pos`当前位，`x`当前数，`choose`删除次数），清晰传递状态。

**题解三：作者QianianXY**  
* **点评**：此题解同样使用DFS，但优化了状态记录（直接用字符串构造当前数），代码简洁且效率高。通过`check`函数快速验证平方数，`dfs`中跳过前导零（如`if (c[k] == '0' && !tot) return`）。亮点在于“喜提最优解”的代码优化（如`rei register int`减少寄存器访问时间），且注释清晰，适合学习DFS剪枝技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点，结合优质题解的共性，提炼思考方向：
</difficulty_intro>

1.  **关键点1**：如何高效枚举可能的平方数？  
    * **分析**：原数n最多9位，因此最大的平方数是n本身（即i的上限为√n）。优质题解（如GusyNight）采用“从大到小枚举”策略，一旦找到第一个匹配的平方数，即可直接返回结果（因为更大的平方数位数更长，删除次数更少），避免无效枚举。  
    * 💡 **学习笔记**：从大到小枚举能快速找到最优解，减少计算量。

2.  **关键点2**：如何判断一个数是否是原数的子序列？  
    * **分析**：子序列要求保留的数字顺序与原数一致。双指针法是高效的解决方案：用指针j遍历原数，指针k遍历平方数，若原数当前位等于平方数当前位，则k后移。若k能走完平方数所有位，则匹配成功。  
    * 💡 **学习笔记**：双指针法是子序列匹配的经典方法，时间复杂度O(n+m)（n原数位数，m平方数位数）。

3.  **关键点3**：如何处理前导零？  
    * **分析**：生成的子序列不能有前导零，因此在DFS中，若第一个保留的数字是0，需直接跳过（如QianianXY的`if (c[k] == '0' && !tot) return`）；在枚举法中，平方数本身不能有前导零（题目保证原数无，平方数也无）。  
    * 💡 **学习笔记**：前导零是常见边界条件，需在代码中显式处理。

### ✨ 解题技巧总结
- **枚举优化**：从大到小枚举平方数，优先匹配长位数的平方数，减少计算量。  
- **子序列匹配**：双指针法简单高效，适合快速判断。  
- **DFS剪枝**：在搜索子序列时，跳过前导零和无效状态（如当前数已超过可能的最大平方数），提升效率。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合枚举法和双指针法的通用核心实现，它结合了高效枚举和子序列匹配的优势。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了GusyNight和Wf_yjqd的思路，采用枚举平方数+双指针匹配，逻辑清晰且效率高。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        string s;
        cin >> s;
        int n = s.size();
        vector<int> a(n);
        for (int i = 0; i < n; ++i) a[i] = s[i] - '0'; // 原数各位存入数组

        int min_ops = -1;
        // 从大到小枚举平方数（i的上限为原数的平方根）
        int max_i = sqrt(stoll(s));
        for (int i = max_i; i >= 1; --i) {
            long long square = (long long)i * i;
            string sq_str = to_string(square); // 平方数转为字符串
            int m = sq_str.size();
            vector<int> sq_digits(m);
            for (int j = 0; j < m; ++j) sq_digits[j] = sq_str[j] - '0'; // 平方数各位存入数组

            int ptr = 0; // 双指针匹配
            for (int digit : a) {
                if (ptr < m && digit == sq_digits[ptr]) ++ptr;
            }
            if (ptr == m) { // 匹配成功
                min_ops = n - m;
                break;
            }
        }
        cout << min_ops << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先将原数的每一位存入数组，然后从大到小枚举可能的平方数（i²）。对于每个平方数，将其转为字符串并拆分为数字数组，用双指针法与原数匹配。若完全匹配，则计算删除次数（原数位数-平方数位数），并立即返回结果（因从大到小枚举，第一个匹配的即为最优解）。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，学习其亮点。
</code_intro_selected>

**题解一：作者GusyNight**  
* **亮点**：直接操作数字拆分，避免字符串转换，效率更高。  
* **核心代码片段**：
    ```cpp
    while(m) a[cnt1++] = m % 10, m /= 10; // 原数拆分为数组（逆序）
    for(int i = sqrt(n); i >= 1; --i) {
        long long x = i * i; cnt2 = 0;
        while(x) b[cnt2++] = x % 10, x /= 10; // 平方数拆分为数组（逆序）
        l = 0;
        for(int j = 0; j < cnt1; ++j) {
            if(a[j] == b[l]) { l++; if(l == cnt2) break; }
        }
        if(l == cnt2) return cout << cnt1 - l, 0;
    }
    ```
* **代码解读**：  
  原数和平方数均通过取模拆分（逆序存储，如原数8314拆分为[4,1,3,8]），双指针j遍历原数，l遍历平方数。若匹配成功（l等于平方数位数），则输出删除次数（原数位数-平方数位数）。  
  为什么逆序存储？因为取模拆分自然得到逆序（如8314→4,1,3,8），不影响匹配（顺序一致即可）。  
* 💡 **学习笔记**：数字拆分时逆序存储是常见技巧，避免反转数组的额外操作。

**题解二：作者Andy_Li（DFS法）**  
* **亮点**：递归枚举“删或不删”每一位，状态传递清晰。  
* **核心代码片段**：
    ```cpp
    void dfs(int pos, int x, int choose) {
        if (pos > cnt) {
            if (int(sqrt(x)) * int(sqrt(x)) == x && x != 0 && checks(x, choose) != 0)
                ans = min(ans, choose);
            return;
        }
        for (int i = 0; i <= 1; ++i)
            if (i == 0) dfs(pos + 1, x * 10 + a[pos], choose); // 不删当前位
            else dfs(pos + 1, x, choose + 1); // 删当前位
    }
    ```
* **代码解读**：  
  `pos`表示当前处理到第几位，`x`表示当前构造的数，`choose`表示已删除的位数。递归时，有两种选择：保留当前位（x*10+a[pos]）或删除（choose+1）。递归终止时，检查x是否为平方数，并更新最小删除次数。  
  为什么用`checks`函数？确保构造的数位数与原数删除后的位数一致（避免前导零导致的位数不符）。  
* 💡 **学习笔记**：DFS的状态设计需包含“当前位置”“当前构造值”“已删除次数”，确保覆盖所有可能。

**题解三：作者QianianXY（DFS优化）**  
* **亮点**：直接用字符串构造当前数，避免数字溢出（如大数）。  
* **核心代码片段**：
    ```cpp
    void dfs(int k, int tot) {
        if (k > len) {
            if (tot && check(tot)) ans = min(len - tot, ans);
            return;
        }
        dfs(k + 1, tot); // 删当前位
        if (c[k] == '0' && !tot) return; // 跳过前导零
        str[++tot] = c[k]; // 不删当前位，记录到str
        dfs(k + 1, tot);
    }
    ```
* **代码解读**：  
  `k`表示当前处理到第几位，`tot`表示已保留的位数。递归时，先尝试删除当前位（`dfs(k+1, tot)`），再尝试保留（若当前位是0且tot=0，说明是前导零，跳过）。终止时，检查`str`构造的数是否为平方数，并更新最小删除次数。  
  为什么用字符串？避免大数构造时的溢出（如原数是9位数，构造的子序列可能也是9位，用int会溢出，字符串更安全）。  
* 💡 **学习笔记**：处理大数时，字符串或字符数组更可靠，避免数值溢出问题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“枚举平方数+双指针匹配”的过程，我们设计一个8位像素风格的动画，让大家“看”到算法如何工作！
</visualization_intro>

  * **动画演示主题**：像素数字探险——寻找平方宝藏  

  * **核心演示内容**：原数的每一位是蓝色像素块（如8314→[8,3,1,4]），枚举的平方数是绿色像素块（如81→[8,1]）。双指针（黄色箭头）分别指向原数和平方数的当前位，匹配成功时绿色块闪烁，最终找到最短删除路径。

  * **设计思路简述**：8位像素风（FC红白机风格）降低学习压力，颜色区分不同角色（蓝色原数、绿色平方数），音效强化关键操作（匹配成功“叮”声），让抽象的子序列匹配过程具象化。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为两部分：上方是原数的蓝色像素块（如8314排成一行），下方是枚举区（显示当前枚举的平方数，初始为√8314≈91→91²=8281）。  
        - 控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。  
        - 播放8位风格的轻快背景音乐（如《超级马里奥》主题变奏）。

    2.  **枚举平方数**：  
        - 从大到小枚举i（如91→90→…→9），每个i对应的平方数显示在枚举区（如91²=8281→绿色块[8,2,8,1]）。

    3.  **双指针匹配**：  
        - 黄色箭头j（原数指针）从左到右移动，箭头k（平方数指针）初始指向平方数第一个块。  
        - 若原数当前块（如8）等于平方数当前块（如8），k右移，j继续；否则j右移。  
        - 匹配成功时（k走完平方数所有块），绿色块整体闪烁，播放“叮”音效；失败时，绿色块变灰，播放“噗”音效。

    4.  **找到最优解**：  
        - 当枚举到i=9时，平方数81（绿色块[8,1]）与原数8314匹配成功（j指向8→k右移，j指向3→不匹配，j指向1→k右移，k走完）。  
        - 播放胜利音效（如《超级玛丽》吃金币声），原数中保留的8和1用金色边框高亮，删除的3和4用灰色覆盖，显示删除次数2。

    5.  **交互控制**：  
        - 单步播放：点击“单步”按钮，逐步执行枚举和匹配；  
        - 自动播放：选择速度（如2x），算法自动运行；  
        - 重置：回到初始状态，重新开始。

  * **旁白提示**：  
    - （枚举i=91时）“当前尝试平方数8281，检查是否能从8314中找到这些数字…”  
    - （匹配失败时）“8314中没有2或第二个8，匹配失败，尝试下一个平方数…”  
    - （匹配成功时）“找到啦！8和1在8314中按顺序出现，删除3和4即可得到81=9²！”

<visualization_conclusion>
通过这样的像素动画，我们能清晰看到枚举和匹配的每一步，理解为什么选择9的平方81作为最优解。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以迁移“枚举+子序列匹配”或“DFS搜索子序列”的思路，解决更多类似问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 子序列匹配：可用于判断字符串是否为另一字符串的子序列（如LeetCode 392题）。  
    - 枚举优化：从大到小枚举可快速找到最优解（如求最长回文子序列）。  
    - DFS搜索：适用于小规模数据的全排列/组合问题（如选数、子集和问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1120 小木棍**  
        * 🗣️ **推荐理由**：DFS剪枝经典题，需枚举可能的木棍长度并匹配，与本题DFS思想类似。  
    2.  **洛谷 P1036 选数**  
        * 🗣️ **推荐理由**：DFS搜索所有选数组合，判断是否为质数，锻炼状态传递和剪枝能力。  
    3.  **洛谷 P1018 乘积最大**  
        * 🗣️ **推荐理由**：选择子序列分割使乘积最大，需枚举分割点并动态规划，与本题子序列选择思路相关。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经历，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自作者Andy_Li)**：“一开始没特判前导零，被输入101卡住了。后来发现构造的数如果以0开头（如01）会被误判为1，但实际是无效的。”  
> **点评**：前导零是常见的边界陷阱！在构造子序列时，必须确保第一个非零数字存在（如本题中`if (c[k] == '0' && !tot) return`的处理）。调试时可打印中间状态（如构造的数），快速定位前导零问题。

-----

<conclusion>
本次关于“Make a Square”的C++解题分析就到这里。希望这份指南能帮助大家理解枚举与子序列匹配的核心思路，掌握DFS搜索的技巧。记住，多动手调试、多思考边界条件，是提升编程能力的关键！下次见~ 💪
</conclusion>

---
处理用时：171.90秒
# 题目信息

# Make a Square

## 题目描述

You are given a positive integer $ n $ , written without leading zeroes (for example, the number 04 is incorrect).

In one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.

Determine the minimum number of operations that you need to consistently apply to the given integer $ n $ to make from it the square of some positive integer or report that it is impossible.

An integer $ x $ is the square of some positive integer if and only if $ x=y^2 $ for some positive integer $ y $ .

## 说明/提示

In the first example we should delete from $ 8314 $ the digits $ 3 $ and $ 4 $ . After that $ 8314 $ become equals to $ 81 $ , which is the square of the integer $ 9 $ .

In the second example the given $ 625 $ is the square of the integer $ 25 $ , so you should not delete anything.

In the third example it is impossible to make the square from $ 333 $ , so the answer is -1.

## 样例 #1

### 输入

```
8314
```

### 输出

```
2
```

## 样例 #2

### 输入

```
625
```

### 输出

```
0
```

## 样例 #3

### 输入

```
333
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Make a Square 深入学习指南 💡

<introduction>
今天我们来一起分析“Make a Square”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧，最终学会如何通过删除最少位数将给定数字变为完全平方数。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与子序列匹配`

🗣️ **初步分析**：
解决“Make a Square”这道题，关键在于找到原数字的一个子序列（保留顺序），使其为完全平方数，且长度尽可能长（删除次数最少）。简单来说，我们需要“枚举可能的平方数，并检查它是否是原数字的子序列”。例如，原数字是8314，我们枚举9²=81，检查81是否是8314的子序列（8在第一位，1在第三位，符合顺序），若匹配成功，则删除次数为总位数（4）减去匹配长度（2）=2。

- **题解思路对比**：  
  主流思路有两种：  
  1. **枚举平方数**（如GusyNight、Wf_yjqd的题解）：从大到小枚举所有可能的平方数（上限为原数的平方根），用双指针法检查该平方数是否是原数字的子序列。  
  2. **DFS生成子序列**（如Andy_Li、QianianXY的题解）：通过深度优先搜索生成所有可能的子序列，检查是否为平方数，并记录最长有效子序列的长度。  

  前者更高效（时间复杂度约O(√n × logn)），后者更直观但可能因枚举所有子序列而略慢（但原数最多9位，仍可接受）。

- **核心算法流程**：  
  以“枚举平方数+双指针匹配”为例，流程为：  
  1. 拆分原数字的每一位存入数组；  
  2. 从大到小枚举平方数（i从√n递减到1）；  
  3. 拆分当前平方数i²的每一位存入数组；  
  4. 双指针匹配：原数字指针j从左到右，平方数指针k从左到右，若a[j]==b[k]，则k右移；  
  5. 若k到达平方数末尾，说明匹配成功，删除次数为原数长度-平方数长度，直接返回（因从大到小枚举，第一个成功的即最优解）。

- **可视化设计思路**：  
  采用8位像素风格，用不同颜色的像素块表示原数字和平方数的各位。双指针移动时，用闪烁箭头高亮当前匹配位置，匹配成功时播放“叮”的音效。最终显示删除次数时，用像素烟花动画庆祝。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下4星及以上题解，它们各有亮点，值得学习：
</eval_intro>

**题解一：GusyNight的枚举平方数法**  
* **点评**：此解法思路简洁高效，直接抓住“从大到小枚举平方数”的关键，避免了无效枚举。代码中双指针匹配逻辑清晰（`j`遍历原数字，`k`遍历平方数，匹配成功则`k++`），变量命名直观（如`cnt1`原数位数，`cnt2`平方数位数）。最大亮点是利用“从大到小枚举”确保第一个匹配成功的平方数即为删除次数最少的解，时间复杂度低，适合竞赛场景。

**题解二：QianianXY的DFS法**  
* **点评**：此解法通过DFS生成所有可能的子序列，代码简洁且处理了前导零问题（`if (c[k] == '0' && !tot) return;`跳过前导零）。虽然枚举所有子序列的时间复杂度略高（但原数最多9位，实际可行），但对理解子序列生成逻辑非常有帮助。代码中`check`函数判断平方数的方式（`sqrt(num)`取整后平方等于原数）简洁有效。

**题解三：Wf_yjqd的双指针匹配法**  
* **点评**：此解法与GusyNight思路类似，但更注重细节优化（如`w`函数计算数字位数，避免重复计算）。代码中`f`函数拆分数字各位的逻辑清晰，双指针匹配时通过`j`和`k`的移动快速判断子序列，边界条件处理严谨（如跳过与原数位数相同但值不同的平方数）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **难点1：如何高效枚举可能的平方数？**  
    * **分析**：若直接枚举所有可能的子序列（如DFS），当原数位数较多时（如9位），子序列数量为2⁹=512，虽可行但非最优。优质题解（如GusyNight）采用“从大到小枚举平方数”，上限为原数的平方根（如原数8314，平方根约91，枚举91²=8281，90²=8100，…，9²=81），找到第一个能作为子序列的平方数，即为最优解。  
    * 💡 **学习笔记**：从大到小枚举平方数，能快速找到最长匹配子序列，减少无效枚举。

2.  **难点2：如何判断一个数是否是原数字的子序列？**  
    * **分析**：子序列要求顺序一致但不要求连续。双指针法是关键：原数字指针`j`从左到右遍历，平方数指针`k`从左到右遍历，若`a[j] == b[k]`，则`k++`。若`k`到达平方数末尾，说明匹配成功。例如，原数8314（数组[8,3,1,4]），平方数81（数组[8,1]），`j=0`时`a[0]=8==b[0]`，`k=1`；`j=2`时`a[2]=1==b[1]`，`k=2`（匹配成功）。  
    * 💡 **学习笔记**：双指针法是判断子序列的高效方法，时间复杂度为O(n)（n为原数位数）。

3.  **难点3：如何处理前导零问题？**  
    * **分析**：生成的子序列不能有前导零（如原数101，子序列01无效）。优质题解（如QianianXY的DFS）在生成子序列时，若当前选择的数字是0且子序列长度为0（即第一个数字），则跳过该选择，避免前导零。  
    * 💡 **学习笔记**：前导零的判断需在子序列生成时实时处理，避免后续无效计算。

### ✨ 解题技巧总结
- **技巧1：逆向枚举平方数**：从大到小枚举平方数，第一个匹配的平方数即为删除次数最少的解。  
- **技巧2：双指针法判断子序列**：用两个指针分别遍历原数和平方数，匹配成功则移动平方数指针。  
- **技巧3：实时处理前导零**：在生成子序列时，若第一个数字是0则跳过，避免无效子序列。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，它结合了枚举平方数和双指针匹配的高效思路。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了GusyNight和Wf_yjqd的题解思路，采用从大到小枚举平方数+双指针匹配的方法，确保高效找到最优解。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        long long n;
        cin >> n;
        vector<int> digits; // 存储原数字的各位（从高位到低位）
        long long temp = n;
        while (temp > 0) {
            digits.push_back(temp % 10);
            temp /= 10;
        }
        reverse(digits.begin(), digits.end()); // 反转后，digits[0]为最高位
        int len = digits.size();

        // 从大到小枚举平方数
        for (long long i = sqrt(n); i >= 1; --i) {
            long long square = i * i;
            vector<int> sq_digits; // 存储平方数的各位（从高位到低位）
            long long sq_temp = square;
            while (sq_temp > 0) {
                sq_digits.push_back(sq_temp % 10);
                sq_temp /= 10;
            }
            reverse(sq_digits.begin(), sq_digits.end());
            int sq_len = sq_digits.size();

            // 双指针匹配子序列
            int d_ptr = 0, sq_ptr = 0;
            while (d_ptr < len && sq_ptr < sq_len) {
                if (digits[d_ptr] == sq_digits[sq_ptr]) {
                    ++sq_ptr;
                }
                ++d_ptr;
            }
            if (sq_ptr == sq_len) { // 匹配成功
                cout << len - sq_len << endl;
                return 0;
            }
        }
        cout << -1 << endl; // 无匹配平方数
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先将原数字拆分为各位存入`digits`数组（高位在前），然后从大到小枚举平方数（`i`从√n递减到1），将每个平方数拆分为各位存入`sq_digits`数组。通过双指针法（`d_ptr`遍历原数字，`sq_ptr`遍历平方数）判断平方数是否是原数字的子序列。若匹配成功，输出删除次数（原长度-平方数长度），否则输出-1。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：GusyNight的枚举平方数法**  
* **亮点**：代码简洁高效，利用`sqrt(n)`直接确定枚举上限，双指针匹配逻辑清晰。  
* **核心代码片段**：
    ```cpp
    while(m)a[cnt1++]=m%10,m/=10; // 拆分原数字各位（低位在前）
    for(int i=sqrt(n);i>=1;i--){ // 从大到小枚举平方数
        long long x=i*i;cnt2=0;
        long long k=x;
        while(x)b[cnt2++]=x%10,x/=10; // 拆分平方数各位（低位在前）
        l=0;
        for(int j=0;j<cnt1;j++){ // 双指针匹配
            if(a[j]==b[l]){
                l++;
                if(l==cnt2)break;
            }
        }
        if(l==cnt2)return cout<<cnt1-l,0; // 匹配成功，输出删除次数
    }
    ```
* **代码解读**：  
  原数字被拆分为`a`数组（低位在前，如8314拆为[4,1,3,8]），平方数被拆分为`b`数组（低位在前，如81拆为[1,8]）。双指针匹配时，`j`遍历`a`数组，`l`遍历`b`数组，若`a[j]==b[l]`，则`l`右移。若`l`到达`b`末尾，说明匹配成功（因原数字是低位在前，实际顺序需反转，但代码中通过`j`从0到cnt1-1遍历，隐式处理了顺序）。  
* 💡 **学习笔记**：拆分数字时需注意顺序（低位在前或高位在前），双指针匹配时需确保顺序一致。

**题解二：QianianXY的DFS法**  
* **亮点**：DFS生成子序列，代码简洁，前导零处理巧妙（`if (c[k] == '0' && !tot) return;`）。  
* **核心代码片段**：
    ```cpp
    inline void dfs(int k, int tot) {
        if (k > len) {
            if (tot && check(tot)) ans = min(len - tot, ans); // 检查是否为平方数
            return;
        } 
        dfs(k + 1, tot); // 不选当前位
        if (c[k] == '0' && !tot) return; // 跳过前导零
        str[++tot] = c[k]; // 选当前位
        dfs(k + 1, tot);
    }
    ```
* **代码解读**：  
  `dfs(k, tot)`表示处理到第`k`位（原数字的第`k`位），当前子序列长度为`tot`。递归分两种选择：不选当前位（`dfs(k+1, tot)`），或选当前位（若当前位是0且`tot=0`则跳过，否则加入子序列`str`，递归`dfs(k+1, tot+1)`）。当处理完所有位（`k>len`），检查子序列是否为平方数（`check(tot)`），并更新最小删除次数。  
* 💡 **学习笔记**：DFS生成子序列时，通过参数传递当前状态（位置、子序列长度），避免了额外空间开销。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“枚举平方数+双指针匹配”的过程，我设计了一个8位像素风格的动画，让我们“看”到算法如何一步步找到最优解！
</visualization_intro>

  * **动画演示主题**：`像素小侦探找平方数`  
  * **核心演示内容**：原数字的各位以黄色像素块排列在屏幕上方（如8314显示为[8][3][1][4]），枚举的平方数各位以蓝色像素块排列在下方（如81显示为[8][1]）。双指针（红色箭头）分别指向原数字和平方数的当前位，匹配成功时箭头右移，最终显示删除次数。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）营造轻松氛围；双指针移动和匹配音效（“叮”）强化操作记忆；匹配成功时的像素烟花动画增强成就感，帮助理解子序列匹配的顺序性。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：  
       - 屏幕上方显示原数字的黄色像素块（如8314→[8][3][1][4]），下方显示“当前枚举平方数”的蓝色像素块（初始为91²=8281→[8][2][8][1]）。  
       - 控制面板包含“开始/暂停”“单步”“重置”按钮，速度滑块（1-5倍速）。  
       - 播放8位风格背景音乐（如《超级玛丽》经典旋律）。

    2. **枚举平方数**：  
       - 从大到小枚举平方数（i=91→90→…→9），每个平方数的蓝色像素块在屏幕下方动态更新。

    3. **双指针匹配**：  
       - 原数字指针（红色箭头）从左到右移动，平方数指针（绿色箭头）同步移动。  
       - 若当前位匹配（如原数字的8与平方数的8），绿色箭头右移，播放“叮”音效，匹配位高亮（黄色→绿色）。  
       - 若匹配失败（如原数字的3与平方数的2），红色箭头右移，无音效。

    4. **匹配成功**：  
       - 当平方数指针到达末尾（如81的指针到达第2位），屏幕中央弹出“匹配成功！”，播放胜利音效（如《魂斗罗》胜利音），删除次数（4-2=2）以大字号显示。  
       - 原数字中未被匹配的位（3和4）变为灰色，突出显示保留的8和1。

    5. **交互控制**：  
       - 单步模式：点击“单步”按钮，逐位展示匹配过程；自动模式：通过速度滑块调整播放速度。  
       - 重置按钮：回到初始状态，重新开始枚举。

  * **旁白提示**：  
    - “现在枚举的是91的平方8281，检查它是否是8314的子序列…”  
    - “看！原数字的第一位是8，和平方数的第一位8匹配，绿色箭头右移～”  
    - “匹配成功！删除次数是原长度4减去平方数长度2，等于2！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到双指针如何一步步匹配，理解“从大到小枚举平方数”为何能快速找到最优解。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的枚举和子序列匹配技巧后，我们可以尝试解决更多类似问题，巩固算法应用能力。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的“枚举+子序列匹配”思路可迁移到以下场景：  
    - 寻找字符串的最长回文子序列（枚举可能的回文，检查是否为子序列）；  
    - 判断一个字符串是否是另一个字符串的子序列（如LeetCode 392题）；  
    - 寻找数组中的最长递增子序列（LIS，可视为特殊的子序列匹配）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1103 书本整理**  
          * 🗣️ **推荐理由**：需要通过删除最少的书使得书的高度严格递增，核心是寻找最长递增子序列（LIS），与本题的子序列匹配思路类似。
    2.  **洛谷 P1036 选数**  
          * 🗣️ **推荐理由**：从n个数中选k个，判断它们的和是否为质数。枚举所有组合并检查质数，锻炼枚举和条件判断能力。
    3.  **洛谷 P1044 栈**  
          * 🗣️ **推荐理由**：通过模拟栈的操作，计算可能的出栈序列数，涉及递归和动态规划，拓展对序列问题的理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试时的经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 QianianXY)**：“一开始没处理前导零，导致输入101时错误输出-1，后来在DFS中加入`if (c[k] == '0' && !tot) return;`跳过前导零，才通过测试。”  
> **点评**：前导零是本题的常见坑点，处理时需在子序列生成的第一步（即选择第一个数字时）判断是否为0。这提醒我们，边界条件（如前导零、空输入）的处理是编程中不可忽视的细节，需在代码中提前考虑。

-----

<conclusion>
本次关于“Make a Square”的C++解题分析就到这里。希望这份指南能帮助大家理解枚举与子序列匹配的核心逻辑，并掌握处理前导零等边界条件的技巧。记住，多动手调试、多思考不同解法的优劣，是提升编程能力的关键！下次再见～💪
</conclusion>

---
处理用时：161.15秒
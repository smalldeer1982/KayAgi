# 题目信息

# Diagonal Walking v.2

## 题目描述

Mikhail walks on a Cartesian plane. He starts at the point $ (0, 0) $ , and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $ (0, 0) $ , he can go to any of the following points in one move:

- $ (1, 0) $ ;
- $ (1, 1) $ ;
- $ (0, 1) $ ;
- $ (-1, 1) $ ;
- $ (-1, 0) $ ;
- $ (-1, -1) $ ;
- $ (0, -1) $ ;
- $ (1, -1) $ .

If Mikhail goes from the point $ (x1, y1) $ to the point $ (x2, y2) $ in one move, and $ x1 \ne x2 $ and $ y1 \ne y2 $ , then such a move is called a diagonal move.

Mikhail has $ q $ queries. For the $ i $ -th query Mikhail's target is to go to the point $ (n_i, m_i) $ from the point $ (0, 0) $ in exactly $ k_i $ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $ (0, 0) $ to the point $ (n_i, m_i) $ in $ k_i $ moves.

Note that Mikhail can visit any point any number of times (even the destination point!).

## 说明/提示

One of the possible answers to the first test case: $ (0, 0) \to (1, 0) \to (1, 1) \to (2, 2) $ .

One of the possible answers to the second test case: $ (0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3) $ .

In the third test case Mikhail cannot reach the point $ (10, 1) $ in 9 moves.

## 样例 #1

### 输入

```
3
2 2 3
4 3 7
10 1 9
```

### 输出

```
1
6
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Diagonal Walking v.2 深入学习指南 💡

<introduction>
今天我们来一起分析“Diagonal Walking v.2”这道题。它的核心是通过分类讨论，找到在指定步数内到达目标点的最大对角移动次数。本指南将帮你理清思路，掌握关键技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（分类讨论）`

🗣️ **初步分析**：
解决这道题的关键是“分类讨论”——就像玩拼图时，不同形状的拼图块需要对应不同的位置。分类讨论的核心是把复杂问题拆解成几个明确的条件场景，逐个解决。

在本题中，我们需要判断：
1. **是否有解**：当要求的步数 \( k \) 小于到达目标点的最小步数 \( \max(n,m) \) 时，直接输出 \(-1\)（因为最少需要 \( \max(n,m) \) 步才能到达）。
2. **最大对角步数**：若有解，根据 \( \max(n,m) - \min(n,m) \) 的奇偶性，以及 \( k \) 与 \( \max(n,m) \) 的差值的奇偶性，分三种情况计算最大对角步数。

核心算法流程的可视化设计：  
我们将用8位像素风网格模拟移动过程。起点（绿色方块）到终点（红色方块）的每一步，对角移动用紫色闪烁，普通移动用蓝色滑动。当遇到需要调整步数的情况（如奇偶性导致的步数减少），对应方块会短暂变黄提示。动画支持单步/自动播放，配合“叮”（对角移动）、“哒”（普通移动）的像素音效，让每一步都清晰可感。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下优质题解：
</eval_intro>

**题解一：Alloverzyt（来源：博客）**
* **点评**：此题解用“剩余步数的奇偶性”和“目标点横纵坐标差的奇偶性”作为分类依据，逻辑简洁直接。代码仅用15行，变量命名清晰（如 `px` 表示较大坐标，`py` 表示较小坐标），边界条件处理严谨（如 `k < max(n,m)` 直接判无解）。亮点在于通过图示解释“对角线来回抵消步数”的原理，帮助理解剩余步数的处理。

**题解二：jiangjiangQwQ（来源：洛谷）**
* **点评**：此题解详细分析了三种情况，并附图示辅助理解（如差值为奇数时需多走一步平路）。代码使用 `dy` 优化输入输出，效率更高；`px` 和 `py` 的定义明确，逻辑分支清晰。亮点是通过具体例子（如 `(5,3)` 和 `(5,2)`）说明不同情况下的对角步数计算，非常直观。

**题解三：Light_Pursuer（来源：洛谷）**
* **点评**：此题解直接抓住“奇偶性”这个核心条件，分类明确。代码用 `read` 函数优化输入，时间复杂度 \( O(T) \)，适合竞赛场景。亮点是将复杂的步数调整简化为两次奇偶判断，代码简洁高效。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理两个核心条件：最小步数判断和奇偶性分类。我们逐一拆解：
</difficulty_intro>

1.  **关键点1：如何判断“无解”？**
    * **分析**：到达点 \( (n,m) \) 的最小步数是 \( \max(n,m) \)。例如，到 \( (2,3) \) 至少需要3步（因为y方向需要3步，x方向只需2步，每一步最多同时走x和y各一格）。若 \( k < \max(n,m) \)，无论如何都无法到达，直接输出 \(-1\)。
    * 💡 **学习笔记**：最小步数是横纵坐标的较大值，这是所有后续分析的基础。

2.  **关键点2：如何处理横纵坐标差的奇偶性？**
    * **分析**：设 \( a = \max(n,m) \), \( b = \min(n,m) \)。若 \( a - b \) 是奇数（如 \( (5,2) \)，差为3），说明到达终点前必须走一步平路（非对角），因此最大对角步数是 \( k-1 \)。若差是偶数（如 \( (5,3) \)，差为2），则可以全部用对角移动。
    * 💡 **学习笔记**：奇偶性决定了是否需要“额外平路”，这是分类讨论的核心。

3.  **关键点3：如何处理剩余步数的奇偶性？**
    * **分析**：当 \( a - b \) 是偶数时，剩余步数 \( k - a \) 若为奇数（如 \( k=7 \), \( a=5 \)，剩余2步是偶数？不，这里可能笔误，实际是 \( k - a \) 的奇偶性），需要额外减少2步（因为奇数步无法通过来回对角抵消，必须走两步平路）。
    * 💡 **学习笔记**：剩余步数的奇偶性决定是否需要“调整步数”，确保最终能到达终点。

### ✨ 解题技巧总结
- **先判无解**：优先检查 \( k < \max(n,m) \)，避免后续无效计算。
- **抓奇偶性**：用 \( a - b \) 和 \( k - a \) 的奇偶性作为分类依据，简化问题。
- **图示辅助**：画图（如网格移动路径）能直观理解为何需要调整步数。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，给出一个简洁高效的通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Alloverzyt和jiangjiangQwQ的题解思路，逻辑清晰，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;

    int main() {
        int t;
        cin >> t;
        while (t--) {
            ll n, m, k;
            cin >> n >> m >> k;
            ll max_xy = max(n, m);
            ll min_xy = min(n, m);
            if (k < max_xy) {
                cout << -1 << '\n';
                continue;
            }
            if ((max_xy - min_xy) % 2 == 1) {
                cout << k - 1 << '\n';
            } else {
                if ((k - max_xy) % 2 == 1) {
                    cout << k - 2 << '\n';
                } else {
                    cout << k << '\n';
                }
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取查询次数 \( t \)，然后对每个查询：
  1. 计算 \( \max(n,m) \) 和 \( \min(n,m) \)；
  2. 若 \( k < \max(n,m) \)，输出 \(-1\)；
  3. 否则，根据 \( \max(n,m) - \min(n,m) \) 的奇偶性，决定是否减1；
  4. 若差值为偶数，再根据 \( k - \max(n,m) \) 的奇偶性决定减2或不减。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Alloverzyt**
* **亮点**：代码极简，用两次奇偶判断直接得出结果，无需复杂逻辑。
* **核心代码片段**：
    ```cpp
    if((max(n,m)-min(n,m))%2==1) k--;
    else if((k-max(n,m))%2==1) k-=2;
    printf("%lld\n",k);
    ```
* **代码解读**：  
  第一行判断横纵坐标差是否为奇数，若是则 \( k \) 减1（需多走一步平路）；第二行判断剩余步数是否为奇数，若是则 \( k \) 减2（无法用对角抵消，需两步平路）。最终输出调整后的 \( k \)。
* 💡 **学习笔记**：通过两次奇偶判断，将复杂问题简化为几个条件分支，代码简洁高效。

**题解二：jiangjiangQwQ**
* **亮点**：用 `px` 和 `py` 明确表示最大/最小坐标，代码可读性强。
* **核心代码片段**：
    ```cpp
    int px=max(x,y),py=min(x,y);
    if((px-py)%2==1) cout<<k-1<<endl;
    else if((k-px)%2==1) cout<<k-2<<endl;
    else cout<<k<<endl;
    ```
* **代码解读**：  
  `px` 和 `py` 分别存储横纵坐标的较大值和较小值，使后续条件判断更直观。通过 `px-py` 的奇偶性和 `k-px` 的奇偶性，分三种情况输出结果。
* 💡 **学习笔记**：变量命名清晰（如 `px` 表示“较大坐标”），能大幅提升代码可读性。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“对角移动”和“步数调整”，我们设计一个8位像素风动画——《像素探险家的对角之旅》！
</visualization_intro>

  * **动画演示主题**：像素探险家从起点(0,0)出发，在网格世界中寻找终点(n,m)，尽可能多走对角线。

  * **核心演示内容**：展示从起点到终点的移动过程，标记对角移动（紫色）和普通移动（蓝色），动态显示剩余步数和对角步数统计。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；关键步骤（如奇偶性调整）用颜色闪烁提示，配合“叮”（对角）、“哒”（普通）的像素音效，强化操作记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕显示10x10像素网格，起点（绿色方块）在(0,0)，终点（红色方块）在(n,m)。控制面板有“开始/暂停”“单步”“重置”按钮和速度滑块。
    2. **移动演示**：每一步用箭头指示方向，对角移动时紫色方块从当前位置斜向滑动，普通移动时蓝色方块横向/纵向滑动。
    3. **奇偶性调整提示**：当需要减1或减2步时，对应方块变黄0.5秒，同时音效“滴”提示。
    4. **自动演示模式**：点击“AI演示”，算法自动执行，探险家像“自动寻路的小蛇”一样展示最优路径。
    5. **完成反馈**：到达终点时播放“胜利”音效，对角步数用金色数字放大显示。

  * **旁白提示**：
    - “看！紫色方块是对角移动，一步能同时走x和y方向～”
    - “现在剩余步数是奇数，需要调整，减2步哦！”
    - “到达终点啦！总共用了XX次对角移动，太棒了～”

<visualization_conclusion>
通过这个动画，你能“看”到每一步的选择，理解奇偶性如何影响对角步数，学习更有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握分类讨论后，我们可以尝试以下类似问题，巩固技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    分类讨论的核心是“找关键条件”（如本题的奇偶性），它还适用于：
    - 路径问题（如“过河卒”的路径限制）；
    - 状态转换（如“乒乓球”的得分规则变化）；
    - 位运算（如“高低位交换”的分段处理）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1002 过河卒**  
        * 🗣️ **推荐理由**：需要分类讨论路径中的障碍，练习条件判断和递推。
    2.  **洛谷 P1042 乒乓球**  
        * 🗣️ **推荐理由**：根据得分规则的变化分类处理，强化状态转换思维。
    3.  **洛谷 P1100 高低位交换**  
        * 🗣️ **推荐理由**：通过位运算的分类处理，练习分治思想。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者提到调试时的教训，比如“一开始没考虑奇偶性，导致样例错误”。这些经验很有参考价值：
</insights_intro>

> **参考经验 (来自 Alloverzyt)**：“在判断 `(max(n,m)-min(n,m))%2` 时，一开始没画图，导致逻辑错误。后来通过图示发现，奇数差需要多走一步平路。”

**点评**：这位作者的经验提醒我们，遇到抽象的条件判断时，画图是最有效的辅助方法。通过可视化路径，能快速发现逻辑漏洞，避免“想当然”的错误。

---

<conclusion>
关于“Diagonal Walking v.2”的分析就到这里！分类讨论的关键是抓住核心条件（如本题的奇偶性），通过画图和代码验证确保逻辑正确。多练习类似题目，你会越来越熟练～下次见！💪
</conclusion>

---
处理用时：121.45秒
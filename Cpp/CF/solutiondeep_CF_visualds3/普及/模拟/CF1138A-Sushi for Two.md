# 题目信息

# Sushi for Two

## 题目描述

Arkady invited Anna for a dinner to a sushi restaurant. The restaurant is a bit unusual: it offers $ n $ pieces of sushi aligned in a row, and a customer has to choose a continuous subsegment of these sushi to buy.

The pieces of sushi are of two types: either with tuna or with eel. Let's denote the type of the $ i $ -th from the left sushi as $ t_i $ , where $ t_i = 1 $ means it is with tuna, and $ t_i = 2 $ means it is with eel.

Arkady does not like tuna, Anna does not like eel. Arkady wants to choose such a continuous subsegment of sushi that it has equal number of sushi of each type and each half of the subsegment has only sushi of one type. For example, subsegment $ [2, 2, 2, 1, 1, 1] $ is valid, but subsegment $ [1, 2, 1, 2, 1, 2] $ is not, because both halves contain both types of sushi.

Find the length of the longest continuous subsegment of sushi Arkady can buy.

## 说明/提示

In the first example Arkady can choose the subsegment $ [2, 2, 1, 1] $ or the subsegment $ [1, 1, 2, 2] $ with length $ 4 $ .

In the second example there is no way but to choose one of the subsegments $ [2, 1] $ or $ [1, 2] $ with length $ 2 $ .

In the third example Arkady's best choice is the subsegment $ [1, 1, 1, 2, 2, 2] $ .

## 样例 #1

### 输入

```
7
2 2 2 1 1 2 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
6
1 2 1 2 1 2
```

### 输出

```
2
```

## 样例 #3

### 输入

```
9
2 2 1 1 1 2 2 2 2
```

### 输出

```
6
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Sushi for Two 深入学习指南 💡

<introduction>
今天我们来一起分析“Sushi for Two”这道C++编程题。题目要求找到最长的连续寿司段，使得该段中两种类型（1和2）的数量相等，且前半部分全是一种类型，后半部分全是另一种类型。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与相邻段枚举`

🗣️ **初步分析**：
解决“Sushi for Two”的关键在于将连续的相同类型寿司合并成“段”，再通过枚举相邻段的长度，找到能组成有效子段的最长长度。  
简单来说，“模拟与相邻段枚举”就像整理书架——把同一类型的书堆成一摞（合并连续段），然后检查每两摞相邻的书（枚举相邻段），看哪两摞能组成“前半是A类型、后半是B类型，且数量相等”的组合（取两摞长度的较小值）。最终，最大的这个较小值乘以2就是答案。

- **题解思路**：所有优质题解的核心都是“合并连续段+枚举相邻段”。例如，将输入序列`[2,2,2,1,1,2,2]`合并为段长度数组`[3,2,2]`，枚举相邻段`(3,2)`和`(2,2)`，取较小值`2`和`2`，最大值是`2`，最终答案`2×2=4`。
- **核心难点**：正确合并连续段（避免漏段或错段）、准确枚举相邻段并计算最小值。
- **可视化设计**：采用8位像素风格，用不同颜色方块表示1（红色）和2（蓝色），合并段时将连续方块堆叠成“段柱”，枚举时用箭头标记相邻段，高亮较小值的段柱，最终结果用闪烁的金色边框强调。动画支持单步/自动播放，关键步骤（如合并段、计算最小值）伴随“叮”的像素音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，我筛选出以下3份≥4星的优质题解：
</eval_intro>

**题解一：合并段法（来源：封禁用户）**
* **点评**：此题解思路简洁直接，通过合并连续相同类型的段，将问题转化为枚举相邻段的最小值。代码中`len`数组存储各段长度，逻辑清晰；变量名`tot`（当前段长度）、`glen`（段长度）含义明确，边界处理严谨（如循环结束后补最后一段）。算法时间复杂度O(n)，适合竞赛场景，是典型的高效解法。

**题解二：双计数器法（来源：StudyingFather）**
* **点评**：此题解用`cnt1`和`cnt2`分别记录当前连续1和2的数量，在类型切换时更新答案。代码变量名直观（`cnt1`即“连续1的计数”），逻辑简洁，适合初学者理解。虽未显式合并段，但通过动态更新计数器实现了相同效果，体现了“空间换逻辑简单”的编程技巧。

**题解三：压缩数组法（来源：_rxfalty_）**
* **点评**：此题解将连续相同类型的段压缩到数组`t`中，通过遍历`t`数组枚举相邻段。代码结构工整（`tot`记录当前段长度，`len`记录段数），边界处理（`i<=n+1`避免漏最后一段）巧妙。算法思路与合并段法一致，但实现更直观，适合理解段合并的过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们常遇到以下核心难点，结合优质题解的共性，提炼策略如下：
</difficulty_intro>

1.  **关键点1：如何正确合并连续相同类型的段？**
    * **分析**：合并段时需遍历数组，当当前元素与前一个不同时，将当前段长度存入数组并重置计数器。例如，输入`[2,2,2,1,1,2,2]`，遍历时遇到`1`（与前一个`2`不同），将当前段长度`3`存入数组，再重置计数器为1（新段开始）。
    * 💡 **学习笔记**：合并段的关键是“记录前一个元素的值”，并在类型变化时触发段存储操作。

2.  **关键点2：如何枚举相邻段并计算最小值？**
    * **分析**：合并后的段数组中，相邻段的类型必然不同（如段1是2，段2是1，段3是2），因此每对相邻段可组成“前半段+后半段”的有效子段。取每对长度的较小值，最大值即为答案。
    * 💡 **学习笔记**：相邻段的类型不同是题目的隐含条件，利用这一点可简化枚举逻辑。

3.  **关键点3：如何处理边界情况（如最后一段）？**
    * **分析**：遍历结束后，最后一个段的长度可能未存入数组（如循环条件为`i<n`），需在循环外补存。例如，输入`[2,2,1,1]`，循环结束后`glen=2`（最后一段1的长度），需执行`len[++tot]=glen`。
    * 💡 **学习笔记**：边界处理时，可通过“虚拟终点”（如循环到`i<=n`）或循环后补存来避免漏段。

### ✨ 解题技巧总结
- **段合并技巧**：用一个变量记录当前段长度，遇到类型变化时存入段数组并重置，简化连续段处理。
- **双计数器替代**：若不想显式存储段数组，可用两个计数器分别记录当前连续1和2的长度，类型变化时更新答案，适合空间有限的场景。
- **边界补存**：循环结束后检查是否有未存入的段，避免漏算最后一段的贡献。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，选择“合并段法”作为通用核心实现，其逻辑清晰且易于理解。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了合并段法的思路，通过遍历数组合并连续段，枚举相邻段计算最小值，最终输出最长有效子段长度。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }

        vector<int> segments;
        int current_len = 1;
        for (int i = 1; i < n; ++i) {
            if (a[i] == a[i - 1]) {
                current_len++;
            } else {
                segments.push_back(current_len);
                current_len = 1;
            }
        }
        segments.push_back(current_len); // 存入最后一段

        int max_half = 0;
        for (int i = 0; i < segments.size() - 1; ++i) {
            max_half = max(max_half, min(segments[i], segments[i + 1]));
        }

        cout << max_half * 2 << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并存储寿司序列。通过遍历数组合并连续相同类型的段（如`[2,2,2,1,1]`合并为`[3,2]`）。然后枚举相邻段，计算每对段的较小值，取最大值`max_half`。最终输出`max_half×2`，即最长有效子段的长度。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：合并段法（来源：封禁用户）**
* **亮点**：通过`glen`变量动态记录当前段长度，循环结束后补存最后一段，避免漏段。
* **核心代码片段**：
    ```cpp
    int cnt=0,tot=0,glen=1;
    for(int i=2;i<=n;i++){
        if(a[i]!=a[i-1]) len[++tot]=glen,glen=1;
        else glen++;
    }
    len[++tot]=glen;
    ```
* **代码解读**：
    > 这段代码遍历数组（从第2个元素开始），若当前元素与前一个不同（`a[i]!=a[i-1]`），则将当前段长度`glen`存入`len`数组，并重置`glen`为1；否则`glen`自增（延长当前段）。循环结束后，`len[++tot]=glen`补存最后一段的长度（如输入结束后未触发类型变化的情况）。
* 💡 **学习笔记**：循环结束后补存最后一段是避免漏段的关键，适用于所有需要合并连续段的问题。

**题解二：双计数器法（来源：StudyingFather）**
* **亮点**：用`cnt1`和`cnt2`动态记录当前连续1和2的长度，无需显式存储段数组，空间复杂度更低。
* **核心代码片段**：
    ```cpp
    int cur=a[1],cnt1=0,cnt2=0;
    if(cur==1) cnt1=1; else cnt2=1;
    for(int i=2;i<=n;i++){
        if(a[i]!=cur){
            ans=max(ans,min(cnt1,cnt2));
            if(cur==1) cnt2=1; else cnt1=1;
            cur=a[i];
        } else {
            if(cur==1) cnt1++; else cnt2++;
        }
    }
    ```
* **代码解读**：
    > 这段代码用`cur`记录当前段的类型（1或2），`cnt1`和`cnt2`分别记录当前连续1和2的长度。当遇到类型变化时（`a[i]!=cur`），更新答案`ans`为当前`cnt1`和`cnt2`的较小值，并重置对应计数器（如当前是1，切换后`cnt2=1`）。否则，延长当前类型的计数器（如当前是1，`cnt1++`）。
* 💡 **学习笔记**：双计数器法通过动态更新避免了段数组的存储，适合处理大规模数据时节省空间。

**题解三：压缩数组法（来源：_rxfalty_）**
* **亮点**：用数组`t`存储压缩后的段长度，逻辑直观，适合理解段合并过程。
* **核心代码片段**：
    ```cpp
    int tot=1;
    for(int i=2;i<=n+1;i++){
        if(a[i]==a[i-1]) tot++;
        else {
            len++;
            t[len]=tot;
            tot=1;
        }
    }
    ```
* **代码解读**：
    > 这段代码通过设置循环上限为`n+1`（虚拟终点），确保最后一段能被存入数组。当`a[i]`与前一个不同时（或到达虚拟终点），将当前段长度`t`存入`len`数组，并重置`tot`为1。例如，输入`[2,2,1,1]`，循环到`i=5`（虚拟终点）时，触发`else`，存入最后一段长度2。
* 💡 **学习笔记**：虚拟终点是处理边界的巧妙方法，避免了循环后补存的步骤。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“合并段+枚举相邻段”的过程，我们设计一个“像素寿司店”动画，用8位风格展示段合并和枚举过程。
</visualization_intro>

  * **动画演示主题**：`像素寿司店的段合并挑战`

  * **核心演示内容**：展示输入序列如何被合并为段，以及如何通过枚举相邻段找到最长有效子段。

  * **设计思路简述**：8位像素风格（FC游戏画面）营造轻松氛围；用红色方块（1）和蓝色方块（2）表示寿司，合并段时将连续方块堆叠成“段柱”；枚举时用箭头标记相邻段，高亮较小值的段柱，最终结果用金色边框闪烁。音效（“叮”）强化关键操作记忆，自动播放模式像“AI店员”演示解题过程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示输入序列（像素方块横向排列，1为红色，2为蓝色）；右侧显示“段柱”区域（纵向堆叠的段柱，高度为段长度）。
          * 控制面板：单步/自动按钮、速度滑块（1-5倍速）、重置按钮。
          * 背景播放8位风格轻音乐（类似《超级马里奥》的简单旋律）。

    2.  **合并段演示**：
          * 初始时，一个黄色指针指向第一个方块。单步点击后，指针右移，检查当前方块与前一个是否相同：
            - 相同（如前两个2）：当前段柱高度+1（蓝色段柱增高1像素），伴随“滴”的音效。
            - 不同（如2变1）：当前段柱停止增高，存入段数组（段柱旁显示长度），新段柱开始（红色，高度1），伴随“叮”的音效。
          * 自动播放时，指针快速移动，段柱动态增高或切换颜色，模拟合并过程。

    3.  **枚举相邻段**：
          * 段数组生成后，两个绿色箭头分别指向相邻段柱（如段1和段2）。箭头移动时，段柱下方显示长度，较小值的段柱闪烁（如段1长3，段2长2，段2闪烁）。
          * 计算当前最小值（2），与全局最大值（初始0）比较，若更大则全局最大值更新为2，伴随“咚”的音效。
          * 遍历所有相邻段后，最大最小值（如2）乘以2（4）显示为最终答案，金色边框包裹结果，播放“胜利”音效（上扬的“啦~”）。

    4.  **交互控制**：
          * 单步模式：学习者可逐帧观察合并和枚举过程，理解每一步逻辑。
          * 自动模式：AI店员自动演示，速度可调，适合整体流程观察。
          * 重置按钮：清空画面，重新加载输入，方便重复学习。

  * **旁白提示**：
      * （合并段时）“看！当前方块和前一个颜色相同，段柱变高啦~”
      * （枚举时）“现在比较这两个段柱，取较小的那个，这样它们就能组成有效的寿司段哦！”
      * （结束时）“最终，最大的有效段长度是4！你学会了吗？”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到段合并和枚举的每一步，理解为什么“相邻段的较小值”能决定最长有效子段的长度。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以将“合并连续段+枚举相邻段”的思路迁移到更多问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * `合并连续段`：适用于处理“连续相同元素”的问题，如统计最长连续1的个数、字符串压缩（如`aabcc`→`a2b1c2`）。
      * `枚举相邻段`：适用于需要比较相邻区域的问题，如“最长交替子数组”（相邻元素交替增减）、“最大矩形面积”（相邻柱状图的最小高度）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1102** - `A-B 数对`
          * 🗣️ **推荐理由**：需要统计连续相同元素的出现次数，与本题“合并段”思路类似，可巩固段统计技巧。
    2.  **洛谷 P1115** - `最大子段和`
          * 🗣️ **推荐理由**：虽不直接合并段，但需要动态枚举子段，与本题“枚举相邻段”的思想有共通之处，适合拓展思维。
    3.  **洛谷 P5016** - `龙虎斗`
          * 🗣️ **推荐理由**：涉及相邻区域的比较和最优解选择，与本题“枚举相邻段求最值”的逻辑相似，可提升问题分析能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但根据题解的共性，我们可以总结：遇到“连续相同元素”的问题时，合并段是高效的处理方法；枚举相邻段时，需注意边界情况（如最后一段），避免漏算。
</insights_intro>

-----

<conclusion>
本次关于“Sushi for Two”的C++解题分析就到这里。希望这份指南能帮助大家掌握“合并段+枚举相邻段”的核心思路，以及C++代码的实现技巧。编程的关键在于多思考、多练习，下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：172.34秒
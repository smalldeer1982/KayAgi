# 题目信息

# Make Them Equal

## 题目描述

You are given a sequence $ a_1, a_2, \dots, a_n $ consisting of $ n $ integers.

You can choose any non-negative integer $ D $ (i.e. $ D \ge 0 $ ), and for each $ a_i $ you can:

- add $ D $ (only once), i. e. perform $ a_i := a_i + D $ , or
- subtract $ D $ (only once), i. e. perform $ a_i := a_i - D $ , or
- leave the value of $ a_i $ unchanged.

It is possible that after an operation the value $ a_i $ becomes negative.

Your goal is to choose such minimum non-negative integer $ D $ and perform changes in such a way, that all $ a_i $ are equal (i.e. $ a_1=a_2=\dots=a_n $ ).

Print the required $ D $ or, if it is impossible to choose such value $ D $ , print -1.

For example, for array $ [2, 8] $ the value $ D=3 $ is minimum possible because you can obtain the array $ [5, 5] $ if you will add $ D $ to $ 2 $ and subtract $ D $ from $ 8 $ . And for array $ [1, 4, 7, 7] $ the value $ D=3 $ is also minimum possible. You can add it to $ 1 $ and subtract it from $ 7 $ and obtain the array $ [4, 4, 4, 4] $ .

## 样例 #1

### 输入

```
6
1 4 4 7 4 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
2 2 5 2 5
```

### 输出

```
3
```

## 样例 #3

### 输入

```
4
1 3 3 7
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
2
2 8
```

### 输出

```
3
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Make Them Equal 深入学习指南 💡

<introduction>
今天我们来一起分析“Make Them Equal”这道C++编程题。这道题需要找到最小的非负整数D，使得数组中的每个元素通过加D、减D或不变后全部相等。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学分析与分类讨论`

🗣️ **初步分析**：
解决这道题的关键在于通过数学分析，将问题转化为对数组中不同数值的分类讨论。简单来说，我们需要观察数组中不同数值的个数（去重后），并根据个数（1、2、3或更多）分别处理，这就像整理玩具时，先按颜色分类，再针对每类制定整理策略一样。

在本题中，数学分析主要用于：
- 当数组中不同数值超过3种时，直接判定无解（因为每个数只能通过三种操作之一调整，无法覆盖超过3种的数值差异）；
- 当有1种数值时，D=0；
- 当有2种数值时，根据差值的奇偶性确定最小D；
- 当有3种数值时，需满足等差中项条件（中间值是首尾的平均数）才能找到D。

核心算法流程的可视化设计思路：用像素方块表示不同数值（如红色代表最大值，蓝色代表最小值，绿色代表中间值），通过动画展示去重过程（重复数值的方块合并），并动态演示不同D值下的调整过程（如加D时方块上移，减D时下移）。关键步骤（如判断是否等差）用黄色高亮，音效在合并、调整时播放“叮”声，成功时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解（≥4星），它们的共性是逻辑清晰、分类全面且代码简洁。
</eval_intro>

**题解一：Nuclear_Fish_cyq的分类讨论法 (来源：洛谷题解)**
* **点评**：此题解思路非常清晰，首先通过去重缩小问题规模，再根据去重后的数值个数（1、2、3、超过3）分类处理。代码中使用`sort`和`unique`去重，简洁高效；分类讨论覆盖了所有可能情况（如两数差奇偶性、三数等差判断），边界条件处理严谨。特别是三数情况的等差中项判断，直接抓住了问题的数学本质，是本题的核心突破点。从实践角度看，代码可直接用于竞赛，鲁棒性强。

**题解二：Sun_wtup的暴力枚举法 (来源：洛谷题解)**
* **点评**：此题解利用数据范围小（数值≤100）的特点，暴力枚举D（0到200），并验证每个D是否可行。思路直白易懂，适合对分类讨论不熟悉的学习者理解问题本质。代码中通过判断每个数是否能通过加D、减D或不变得到目标值（最大值-D），逻辑直接。虽然时间复杂度略高（O(n×200)），但在本题数据规模下非常实用，是“小数据暴力”的典型应用。

**题解三：TheSky233的set去重法 (来源：洛谷题解)**
* **点评**：此题解巧妙使用`set`自动去重并排序，简化了去重和排序的代码实现。分类讨论部分逻辑简洁，特别是三数情况通过迭代器直接获取首尾和中间值，代码风格优雅。虽然没有显式处理两数差的奇偶性，但通过位运算（`&1`）判断奇偶，是代码优化的小技巧，值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何确定去重后的数值个数？
    * **分析**：去重是本题的第一步，因为重复的数值不影响D的选择（它们的操作方式相同）。优质题解通常使用`sort+unique`或`set`去重。例如，Nuclear_Fish_cyq的代码中，`sort(a, a + n); n = unique(a, a + n) - a;` 一行代码完成去重，简洁高效。
    * 💡 **学习笔记**：去重是简化问题的常用手段，可通过STL函数快速实现。

2.  **关键点2**：三数情况如何判断是否存在D？
    * **分析**：当去重后有3个数值时，必须满足“最大值-中间值=中间值-最小值”（等差中项），此时D=中间值-最小值。例如，样例1中数组去重后为[1,4,7]，中间值4满足1+7=2×4，故D=3。若不满足此条件（如样例3的[1,3,7]），则无解。
    * 💡 **学习笔记**：三数情况的本质是寻找一个中间值，使得首尾通过加减同一个D得到它。

3.  **关键点3**：两数情况如何选择最小D？
    * **分析**：当去重后有2个数值（设为a和b，a<b），若b-a是偶数，则最小D=(b-a)/2（a+D=b-D）；若为奇数，则只能让其中一个数不变，另一个加减D，此时D=b-a。例如，样例4的[2,8]差值为6（偶数），D=3；若差值为5（奇数），D=5。
    * 💡 **学习笔记**：两数情况的最小D由差值的奇偶性决定，偶数时取半，奇数时取差值。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题简化**：通过去重缩小问题规模，将原问题转化为对1、2、3种数值的分类讨论。
- **数学本质挖掘**：三数情况的等差中项、两数情况的奇偶性判断，均需抓住数值间的数学关系。
- **边界条件处理**：注意数值可能为0或负数，以及D必须为非负整数。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Nuclear_Fish_cyq和TheSky233的题解思路，采用去重后分类讨论的方法，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int n, a[105];
        cin >> n;
        for (int i = 0; i < n; ++i) cin >> a[i];
        sort(a, a + n);
        int unique_n = unique(a, a + n) - a; // 去重后的元素个数

        if (unique_n > 3) {
            cout << -1 << endl;
        } else if (unique_n == 3) {
            if (a[1] - a[0] == a[2] - a[1]) { // 等差中项判断
                cout << a[1] - a[0] << endl;
            } else {
                cout << -1 << endl;
            }
        } else if (unique_n == 2) {
            int diff = a[1] - a[0];
            if (diff % 2 == 0) {
                cout << diff / 2 << endl;
            } else {
                cout << diff << endl;
            }
        } else { // unique_n == 1
            cout << 0 << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取数组并排序，通过`unique`函数去重，得到去重后的元素个数`unique_n`。根据`unique_n`的值分类处理：超过3种数值输出-1；3种时判断是否等差；2种时根据差值奇偶性输出D；1种时输出0。核心逻辑集中在去重和分类讨论，简洁高效。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：Nuclear_Fish_cyq的分类讨论法 (来源：洛谷题解)**
* **亮点**：使用`sort`和`unique`高效去重，分类讨论覆盖所有情况，代码简洁易懂。
* **核心代码片段**：
    ```cpp
    sort(a, a + n);
    n = unique(a, a + n) - a; // STL去重
    if(n > 3){
        cout << -1 << endl;
    }
    else if(n == 3){
        if(a[0] + a[2] == a[1] * 2){
            cout << a[1] - a[0] << endl;
        }
        else{
            cout << -1 << endl;
        }
    }
    // ...其他情况
    ```
* **代码解读**：
    这段代码的核心是去重和分类判断。`sort`和`unique`的组合是STL中经典的去重方法，`unique`返回去重后最后一个元素的下一个位置，减去起始位置得到去重后的元素个数。三数情况的判断`a[0]+a[2]==a[1]*2`等价于等差中项条件，直接抓住了数学本质。
* 💡 **学习笔记**：STL的`unique`函数需要先排序，因为它只能去除连续重复的元素。

**题解二：Sun_wtup的暴力枚举法 (来源：洛谷题解)**
* **亮点**：利用数据范围小的特点，暴力枚举D，思路直白，适合理解问题本质。
* **核心代码片段**：
    ```cpp
    for (register int i = 0; i <= 200; i++) {
        bool flag = 0;
        for (register int j = 1; j <= n; j++) {
            if (a[j] + i != maxn and a[j] + i + i != maxn and a[j] != maxn) {
                flag = 1;
                break;
            }
        }
        if (!flag) {
            cout << i;
            return 0;
        }
    }
    ```
* **代码解读**：
    外层循环枚举D（0到200），内层循环检查每个数是否能通过加D、减D（即加2D到maxn-D）或不变得到目标值（maxn-D）。若所有数都满足，则输出当前D。这种方法虽然暴力，但在数据范围小的情况下非常实用。
* 💡 **学习笔记**：当数据范围较小时（如本题数值≤100），暴力枚举是简单有效的方法。

**题解三：TheSky233的set去重法 (来源：洛谷题解)**
* **亮点**：使用`set`自动去重并排序，代码简洁优雅。
* **核心代码片段**：
    ```cpp
    set<int> s;
    for(int i=1;i<=n;i++) cin>>a[i],s.insert(a[i]);
    if(s.size()>3) cout<<-1<<endl;
    if(s.size()==3){
        set<int>::iterator it=s.end(); it--; it--;
        if(*it-*s.begin()!=*s.rbegin()-*it) cout<<-1<<endl;
        else cout<<*it-*s.begin()<<endl;
    }
    ```
* **代码解读**：
    `set`会自动去重并按升序排列。三数情况中，`s.rbegin()`获取最大值，`it`迭代器通过两次`--`获取中间值，判断中间值与首尾的差值是否相等。这种方法利用了`set`的有序性，避免了手动排序。
* 💡 **学习笔记**：`set`适合需要自动去重和排序的场景，但访问元素需通过迭代器。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“去重分类”和“D值验证”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素数值探险队`（复古FC风格，角色为小方块，目标是通过调整D让所有方块颜色相同）

  * **核心演示内容**：展示数组去重、分类讨论（1/2/3种数值）、D值验证的全过程。例如，三数情况中，小方块通过加减D移动到中间位置，形成相同颜色。

  * **设计思路简述**：采用8位像素风（红/蓝/绿三色调色板），模拟FC游戏的探索场景。去重时重复方块合并，分类讨论时用对话框提示当前情况（如“发现3种数值！”），D值验证时用箭头表示加减D的移动方向，音效在关键步骤（合并、成功）时播放，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕左侧显示原始数组（彩色像素方块，如红、蓝、红、绿），右侧是“操作面板”（开始/暂停按钮、速度滑块）。
          - 播放8位风格的轻快背景音乐（类似《超级玛丽》的过场音乐）。

    2.  **去重过程**：
          - 重复的方块（如两个红方块）逐渐合并为一个，伴随“噗”的合并音效，最终得到去重后的方块（红、蓝、绿）。

    3.  **分类讨论**：
          - 若去重后超过3个方块（如红、蓝、绿、黄），屏幕中央弹出“-1”的红色警告，音效为短促的“叮！”。
          - 若为3个方块，中间方块（蓝）闪烁，旁白：“需要检查是否等差哦！”，随后首尾方块（红、绿）向中间移动，若能对齐（等差），则显示D值；否则显示“-1”。

    4.  **D值验证（以两数情况为例）**：
          - 两个方块（红、绿）分别位于左右两侧，D值从0开始递增。当D=3时，红方块上移（加D），绿方块下移（减D），最终在中间位置重合，播放胜利音效（“啦~”），显示D=3。

    5.  **交互控制**：
          - 支持单步执行（点击“下一步”观察去重、移动过程）、自动播放（速度可调）、重置（回到初始数组）。

  * **旁白提示**：
      - （去重时）“重复的方块可以合并，因为它们的操作方式一样哦！”
      - （三数情况）“中间方块是关键！首尾必须能通过加减同一个D到达它~”
      - （成功时）“太棒了！所有方块都变成相同颜色啦！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能看到算法的每一步，还能在游戏化的互动中理解去重、分类讨论和D值验证的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考数学分类讨论在其他问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 本题的分类讨论思想可用于处理“通过有限操作使元素一致”的问题（如调整元素为同一值、均分纸牌等）。
      - 去重和排序是简化问题的常用手段，适用于统计不同元素个数、寻找众数等场景。
      - 数学关系的挖掘（如等差中项、奇偶性）是解决数值类问题的关键。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1031** - `均分纸牌`
          * 🗣️ **推荐理由**：需要通过移动纸牌使每堆数量相同，涉及数学分析和贪心策略，与本题的分类讨论思想类似。
    2.  **洛谷 P1104** - `生日`
          * 🗣️ **推荐理由**：需要对日期排序后寻找相邻日期的最小差，锻炼排序和去重的应用能力。
    3.  **洛谷 P1217** - `回文数`
          * 🗣️ **推荐理由**：需要枚举可能的回文数并验证是否为质数，结合了暴力枚举和数学判断，与本题的暴力法思路相通。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，Nuclear_Fish_cyq提到：“去重是关键，一开始没考虑到重复数值不影响D的选择，走了不少弯路。后来通过去重简化问题，思路清晰了很多。” 这对我们很有启发。
</insights_intro>

> **参考经验 (来自 Nuclear_Fish_cyq)**：“去重是关键，一开始没考虑到重复数值不影响D的选择，走了不少弯路。后来通过去重简化问题，思路清晰了很多。”
>
> **点评**：这位作者的经验提醒我们，在解决数组类问题时，去重和排序是重要的预处理步骤，可以大幅简化后续逻辑。遇到类似问题时，先尝试简化问题规模（如去重），往往能更快找到突破口。

-----

<conclusion>
本次关于“Make Them Equal”的C++解题分析就到这里。希望这份学习指南能帮助大家理解数学分类讨论的核心思想，掌握去重和暴力枚举的技巧。记住，编程的关键在于多思考、多练习，下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：156.90秒
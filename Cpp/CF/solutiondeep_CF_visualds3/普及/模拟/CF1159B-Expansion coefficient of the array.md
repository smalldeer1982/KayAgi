# 题目信息

# Expansion coefficient of the array

## 题目描述

Let's call an array of non-negative integers $ a_1, a_2, \ldots, a_n $ a $ k $ -extension for some non-negative integer $ k $ if for all possible pairs of indices $ 1 \leq i, j \leq n $ the inequality $ k \cdot |i - j| \leq min(a_i, a_j) $ is satisfied. The expansion coefficient of the array $ a $ is the maximal integer $ k $ such that the array $ a $ is a $ k $ -extension. Any array is a 0-expansion, so the expansion coefficient always exists.

You are given an array of non-negative integers $ a_1, a_2, \ldots, a_n $ . Find its expansion coefficient.

## 说明/提示

In the first test, the expansion coefficient of the array $ [6, 4, 5, 5] $ is equal to $ 1 $ because $ |i-j| \leq min(a_i, a_j) $ , because all elements of the array satisfy $ a_i \geq 3 $ . On the other hand, this array isn't a $ 2 $ -extension, because $ 6 = 2 \cdot |1 - 4| \leq min(a_1, a_4) = 5 $ is false.

In the second test, the expansion coefficient of the array $ [0, 1, 2] $ is equal to $ 0 $ because this array is not a $ 1 $ -extension, but it is $ 0 $ -extension.

## 样例 #1

### 输入

```
4
6 4 5 5
```

### 输出

```
1```

## 样例 #2

### 输入

```
3
0 1 2
```

### 输出

```
0```

## 样例 #3

### 输入

```
4
821 500 479 717
```

### 输出

```
239```

# AI分析结果



---
# 💡 Kay的C++算法解析：数组扩展系数 深入学习指南 💡

<introduction>
今天我们来一起分析“数组扩展系数”这道题。这道题需要找到最大的整数k，使得数组满足特定的不等式条件。本指南将帮助大家理解核心思路，掌握关键技巧，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学推导与贪心策略 (数学类问题)

🗣️ **初步分析**：
解决这道题的关键在于将问题转化为数学上的最小值求解。我们需要找到最大的k，使得对于数组中任意两个元素a_i和a_j，都有k·|i-j| ≤ min(a_i,a_j)。这等价于k必须小于等于所有min(a_i,a_j)/|i-j|的值中的最小值。  

简单来说，就像分蛋糕：每个“蛋糕块”（min(a_i,a_j)）要分给“人数”（|i-j|），k就是每人能分到的最大值。但所有分法中最小的那个决定了最终k的上限。  

- **题解思路**：直接枚举所有i,j计算min(a_i,a_j)/|i-j|的最小值是O(n²)的，但通过贪心观察发现，对每个i，只需考虑离它最远的j（即j=1或j=n），此时|i-j|最大，对应的min(a_i,a_j)/|i-j|会更小，从而覆盖全局最小值。  
- **核心难点**：如何证明只需要考虑最远的j？如何高效计算这些关键对？  
- **可视化设计**：用8位像素网格展示数组，每个元素是一个彩色方块。动画中，对于每个i，用箭头指向j=1和j=n的位置，计算对应的min值和距离，动态更新当前的最小k值（用闪烁的数字显示）。关键步骤加入“叮”的音效，找到最终k时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现优秀（≥4星），值得重点学习：
</eval_intro>

**题解一：作者xu222ux**  
* **点评**：此题解直接点明关键观察——只需考虑i与两端点（1和n）的组合，将复杂度从O(n²)优化到O(n)。代码简洁规范（如变量名a数组、ans直观），边界处理（i=1和i=n的情况）严谨，适合直接用于竞赛。亮点在于通过数学推导快速定位关键对，大幅降低计算量。

**题解二：作者QianianXY**  
* **点评**：此题解详细解释了贪心策略的合理性，说明为何枚举i并取j=1或n能覆盖所有情况。代码使用快速输入优化（read函数），适合大数据量场景。亮点在于逻辑推导清晰，帮助学习者理解“为什么这样做”而非“怎么做”。

**题解三：作者szr666**  
* **点评**：此题解从问题转化出发，通过贪心策略证明了枚举i与最远j的正确性。代码结构工整（自定义min/max函数），注释友好。亮点在于将抽象的数学问题转化为“距离最远点”的直观理解，降低学习门槛。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们需要突破以下核心难点，掌握关键策略：
</difficulty_intro>

1.  **难点1：如何将原问题转化为数学表达式？**  
    * **分析**：题目要求k·|i-j| ≤ min(a_i,a_j)对所有i,j成立。两边同时除以|i-j|（|i-j|≥1），可得k ≤ min(a_i,a_j)/|i-j|。因此，最大的k就是所有min(a_i,a_j)/|i-j|的最小值。  
    * 💡 **学习笔记**：将复杂条件转化为数学不等式是解决此类问题的第一步。

2.  **难点2：如何避免O(n²)的暴力枚举？**  
    * **分析**：对于每个i，若j离i越远（|i-j|越大），则min(a_i,a_j)/|i-j|可能越小（分母大，分子可能小）。因此，对每个i，只需考虑离它最远的j（即j=1或j=n），这样能覆盖所有可能的最小值。  
    * 💡 **学习笔记**：贪心策略的关键是找到“最可能产生最小值”的候选对。

3.  **难点3：如何处理边界情况？**  
    * **分析**：当n=1时，没有i,j对，k=0（题目保证）；当某个a_i=0时，k只能是0（因为min(a_i,a_j)=0，0/|i-j|=0）。代码中需确保这些情况被正确覆盖。  
    * 💡 **学习笔记**：边界条件是代码鲁棒性的关键，需特别注意。

### ✨ 解题技巧总结
- **问题转化**：将复杂的条件转化为数学表达式，明确目标（求最小值）。  
- **贪心选择**：找到最可能产生极值的候选对（如最远点），减少计算量。  
- **边界检查**：处理n=1、a_i=0等特殊情况，确保代码正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合多个优质题解的通用核心实现，它简洁高效，能直接解决问题。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了xu222ux和QianianXY的思路，通过枚举每个i并计算其与两端点的min值/距离，最终取所有结果的最小值。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        int a[300005];
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
        }
        int ans = 1e9; // 初始化为一个大数
        for (int i = 1; i <= n; ++i) {
            int max_dist = max(i - 1, n - i); // 离i最远的距离（j=1或j=n）
            if (max_dist == 0) { // 处理n=1的情况
                ans = 0;
                break;
            }
            ans = min(ans, a[i] / max_dist);
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入数组，然后遍历每个元素i，计算i到两端点（1和n）的最大距离max_dist。对于每个i，计算a[i]/max_dist（因为离i最远的j对应的min(a_i,a_j)至少是a[i]或a[j]，而取max_dist能保证分母最大，结果更小），最终取所有结果的最小值即为k。

---

<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙思路：
</code_intro_selected>

**题解一：作者xu222ux**  
* **亮点**：直接枚举i与两端点（1和n）的组合，代码简洁，时间复杂度O(n)。  
* **核心代码片段**：
    ```cpp
    int ans=min(a[1],a[n])/(n-1);
    for(int i=2;i<n;i++)ans=min(ans,min(min(a[n],a[i])/(n-i),min(a[1],a[i])/(i-1)));
    ```
* **代码解读**：  
  首先计算i=1和i=n的情况（min(a[1],a[n])/(n-1)），然后遍历中间的i（2到n-1），分别计算i与1、i与n的min值除以距离，取所有结果的最小值。这段代码的关键是“只考虑两端点”的贪心策略，确保覆盖所有可能的最小值。  
* 💡 **学习笔记**：贪心策略能大幅减少计算量，关键是找到“最可能产生最小值”的候选对。

**题解二：作者QianianXY**  
* **亮点**：使用快速输入优化，适合大数据量场景；逻辑推导清晰，解释了贪心的合理性。  
* **核心代码片段**：
    ```cpp
    for (rei i = 1; i <= n; i++) ans = min(a[i] / max(i - 1, n - i), ans);
    ```
* **代码解读**：  
  对于每个i，计算其到左端点（i-1）和右端点（n-i）的最大距离max_dist，然后计算a[i]/max_dist，并更新ans的最小值。这段代码的巧妙之处在于，通过max(i-1, n-i)直接找到离i最远的j，从而覆盖所有可能的j的情况。  
* 💡 **学习笔记**：数学推导是优化算法的基础，理解“为什么取最远j”比“如何取”更重要。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“贪心策略”如何找到最小k，我们设计了一个8位像素风格的动画演示，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：像素探险家的“最小k大冒险”  
  * **核心演示内容**：展示数组元素为像素方块，探险家（一个小像素人）从左到右遍历每个方块（i），计算该方块到左右两端的最远距离（max_dist），然后计算a[i]/max_dist的值，最终找到所有值中的最小值（即k）。  

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；探险家移动和数值计算的动画帮助学习者直观看到“为什么选最远j”；关键步骤的音效强化记忆，胜利音效增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕下方是像素网格（每个格子代表数组元素a[i]，颜色根据数值深浅变化，如深色代表大值）。  
        - 上方显示控制面板：开始/暂停、单步、重置按钮，速度滑块。  
        - 播放8位风格的轻快背景音乐。

    2.  **算法启动**：  
        - 探险家从第一个方块（i=1）出发，头顶显示当前i值（如“i=1”）。  
        - 计算max_dist（i-1=0，n-i=3，假设n=4），显示“最远j=4，距离=3”。  
        - 计算a[1]/max_dist=6/3=2，当前ans=2，数值用黄色高亮显示。

    3.  **核心步骤演示**：  
        - 探险家移动到i=2，头顶显示“i=2”。  
        - 用红色箭头指向j=1（距离1）和j=4（距离2），显示max_dist=2。  
        - 计算a[2]/max_dist=4/2=2，当前ans=min(2,2)=2。  
        - 音效“叮”响起，提示完成一次计算。

    4.  **关键更新**：  
        - 探险家移动到i=3，max_dist=max(2,1)=2，计算a[3]/2=5/2=2（取整），ans仍为2。  
        - 移动到i=4，max_dist=3，计算a[4]/3=5/3=1，ans更新为1（数值闪烁红色），胜利音效响起。

    5.  **目标达成**：  
        - 最终ans=1显示在屏幕中央，所有方块高亮绿色，背景音乐切换为胜利旋律。  
        - 可通过单步回放查看每一步的计算过程，或调整速度滑块观察细节。

  * **旁白提示**：  
      - “探险家现在在i=4的位置，离它最远的j是1，距离是3！”  
      - “计算a[4]/3=5/3=1，这比之前的ans更小，所以k的候选值更新为1！”  
      - “所有位置处理完毕，最终k=1，成功找到最大扩展系数！”

<visualization_conclusion>
通过这个像素动画，我们能清晰看到贪心策略如何通过“找最远j”快速定位最小k，理解算法的每一步逻辑和数据变化。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的贪心策略后，我们可以尝试解决更多需要数学推导和贪心选择的问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的关键是“找到最可能产生极值的候选对”，这一思路还适用于：  
    - 寻找数组中两数差的最小值（枚举相邻元素）；  
    - 最大子数组和（贪心选择当前最优）；  
    - 任务调度问题（贪心选择最早截止的任务）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090 合并果子**  
        * 🗣️ **推荐理由**：需要贪心选择最小的两堆合并，培养“找极值候选对”的思维。  
    2.  **洛谷 P1223 排队接水**  
        * 🗣️ **推荐理由**：通过排序贪心最小化总等待时间，练习贪心策略的应用。  
    3.  **洛谷 P1803 凌乱的yyy**  
        * 🗣️ **推荐理由**：贪心选择结束时间最早的比赛，理解“最优子结构”。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中虽未明确提及作者的调试经历，但通过观察代码可以总结出一些实用经验：
</insights_intro>

> **参考经验**：在处理类似“求最小值”的问题时，优先考虑“哪些候选对最可能产生最小值”，通过数学推导缩小枚举范围，避免暴力枚举。例如，本题中“离i最远的j”就是关键候选对。  
> **点评**：这一经验提醒我们，遇到问题时先做数学分析，找到规律，再设计算法。这样既能降低复杂度，又能减少代码出错的可能。

---

<conclusion>
本次关于“数组扩展系数”的分析就到这里。希望大家通过这份指南，掌握数学推导和贪心策略的应用，在编程之路上更进一步！记住，多思考、多实践，你会越来越强！💪
</conclusion>

---
处理用时：131.07秒
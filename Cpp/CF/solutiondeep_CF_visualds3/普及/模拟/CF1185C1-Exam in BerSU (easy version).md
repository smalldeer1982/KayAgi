# 题目信息

# Exam in BerSU (easy version)

## 题目描述

$\text{CF1185C2}$是本题的数据加强版，所以，做出本题不意味着你一定能过$\text{CF1185C2}$。


白朗州大学的又一个学年到来了，很多学生都在做测试。

我们的主人公，小$\text{P}$，要去测试$n(1\leqslant n\leqslant 100)$位学生。学生们将按照$1$到$n$的顺序依次测试。考试规则如下。

- 第$i$个考生随机抽取一张标签，上面有题目。

- 如果这个考生认为这个题目太难，TA没有做这个题目就滚回家去了，那么TA这次考试不及格。

- 如果这个考生发现题目很容易，并且刚好用了$t_i$分钟完成了这道题目。那么过后，TA将带着得到的考试分数回家。

学生们按照固定的次序，依次没有中断地测试。在任何时候，小$\text{P}$从一个学生当中得到答案。

所有学生的考试时间的总和是$M(1\leqslant M\leqslant 100)$，其中保证$\max t[i]\leqslant M$，所以，成绩不好的学生更有可能花光时间以通过考试。

对于每个学生$i$，你的任务是当TA通过考试时，计算出前面最少的不及格的学生的人数。

例如以下的样例一，前5个学生做完题目所需要的时间刚好等于M，所以，他们都不需要不及格的人，所以最少的不及格人数是0。而为了让第6和第7个学生通过测试，前面分别必须让第3,4和第2,5,6个学生不及格。

## 样例 #1

### 输入

```
7 15
1 2 3 4 5 6 7
```

### 输出

```
0 0 0 0 0 2 3 ```

## 样例 #2

### 输入

```
5 100
80 40 40 40 60
```

### 输出

```
0 1 1 2 3 ```

# AI分析结果



---
# 💡 Kay的C++算法解析：Exam in BerSU (easy version) 深入学习指南 💡

<introduction>
今天我们来一起分析“Exam in BerSU (easy version)”这道C++编程题。本指南将帮助大家梳理题目思路，理解贪心算法的核心应用，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决这道题的关键在于理解并运用贪心算法。贪心算法的核心思想是“每一步选择当前最优的局部解，最终逼近全局最优”。就像分糖果时，先给最饿的小朋友最大的糖果，这样能最快满足更多人。在本题中，当总时间超过限制时，我们需要“每次减去前面学生中时间最大的那个”，这样能最快减少总时间，从而用最少的不及格人数满足条件。

题解的主要思路是：对每个学生i，计算前i个学生的总时间sum。若sum ≤ M，输出0；否则，将前i-1个学生的时间排序（或用大根堆维护），从最大的开始依次减去，直到sum ≤ M，记录减去的数量。不同题解的差异主要在于排序方式（数组排序或优先队列）和细节处理（如是否包含当前学生）。

核心算法流程：遍历每个学生→累加总时间→若超限制则贪心减最大时间→输出结果。可视化设计将用8位像素风格展示学生时间方块，高亮当前处理学生和被减去的“大时间方块”，配合“叮”声（减操作）和胜利音效（完成），帮助直观理解每一步。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下3个优质题解（≥4星）：
</eval_intro>

**题解一：作者MithrilSword_XIV**
* **点评**：此题解思路清晰，直接点明贪心核心——“减去最大的时间”。代码结构工整，变量名（如sum、cnt）含义明确，特别是sort函数从大到小排序的设计，让后续减操作更直观。边界处理严谨（如每次循环初始化cnt），代码可直接用于竞赛。亮点是用排序+循环减的方式实现贪心，逻辑直白易理解。

**题解二：作者小鲍bob**
* **点评**：此题解通过“核心代码推导”逐步解释思路，对排序范围（不包括当前学生）的处理非常关键。代码简洁，sort从小到大排序后通过i-su-1反向取最大元素，巧妙避免了从大到小排序的额外操作。注释明确，适合新手学习如何从问题分析到代码实现的完整过程。

**题解三：作者user470883**
* **点评**：此题解代码规范，包含“提交前检查项”注释，体现了良好的编程习惯。思路与前两者一致，但用数组b保存原始数据，避免修改原数组a，增强了代码的鲁棒性。循环中通过i-ans-1定位最大元素，逻辑清晰，适合作为模板参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1：如何选择要减去的学生？**
    * **分析**：为了用最少的不及格人数使总时间≤M，必须每次减去前面学生中时间最大的。因为大的时间对总时间的贡献更大，减去它们能最快减少总和。优质题解通常通过排序或大根堆（优先队列）快速获取最大时间。
    * 💡 **学习笔记**：贪心的核心是“每次选当前最优”，本题中“最优”即“最大的时间”。

2.  **关键点2：排序时是否包含当前学生？**
    * **分析**：当前学生是要通过考试的，因此排序范围应为前i-1个学生（即1到i-1）。若错误包含当前学生，会导致减去自己的时间，与题意矛盾。优质题解通过sort(b+1, b+i)（i是当前学生索引）明确排除了当前学生。
    * 💡 **学习笔记**：边界条件（如排序范围）的处理直接影响答案正确性，需仔细确认。

3.  **关键点3：如何高效实现“减最大时间”的循环？**
    * **分析**：循环终止条件是总时间≤M，每次循环减去当前最大时间（排序后的最后一个元素或堆顶）。优质题解用while(k>m)控制循环，每次减去最大元素并计数，确保最少次数。
    * 💡 **学习笔记**：循环条件和计数变量的初始化（如cnt=0）是避免死循环的关键。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将“最少不及格人数”转化为“减去最大时间的次数”，简化问题。
- **排序优化**：用sort从小到大排序后反向取元素（如i-su-1），避免从大到小排序的额外代码。
- **变量备份**：用sum2备份sum，避免修改原始累加值，确保后续循环正确。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了MithrilSword_XIV和小鲍bob的思路，采用排序+贪心减的方式，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int n, M;
        cin >> n >> M;
        vector<int> t(n + 1); // t[1..n]存储每个学生的时间
        int sum = 0;

        for (int i = 1; i <= n; ++i) {
            cin >> t[i];
            sum += t[i]; // 累加前i个学生的总时间

            if (sum <= M) {
                cout << 0 << " ";
                continue;
            }

            // 需减去前面学生的时间（不包括当前i）
            vector<int> prev(t.begin() + 1, t.begin() + i); // 前i-1个学生的时间
            sort(prev.begin(), prev.end()); // 从小到大排序

            int cnt = 0;
            int current_sum = sum;
            // 从最大的开始减（反向遍历prev）
            for (int j = prev.size() - 1; j >= 0; --j) {
                if (current_sum <= M) break;
                current_sum -= prev[j];
                cnt++;
            }
            cout << cnt << " ";
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并累加每个学生的时间。若总时间≤M，直接输出0。否则，提取前i-1个学生的时间并排序，从最大的开始依次减去，直到总时间≤M，输出减去的次数。关键数据结构是vector存储时间，sort排序后反向遍历实现贪心。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者MithrilSword_XIV**
* **亮点**：用sort从大到小排序，直接正向遍历减最大元素，逻辑直观。
* **核心代码片段**：
    ```cpp
    sort(t+1, t+i, cmp); // cmp函数使从大到小排序
    while(x > M) {
        x -= t[cnt+1];
        cnt++;
    }
    ```
* **代码解读**：
    > `sort(t+1, t+i, cmp)`将前i-1个学生的时间从大到小排序。`x`是总时间的备份，`while(x>M)`循环中，每次减去当前最大的时间（t[cnt+1]），cnt计数。例如，第一次减最大的（t[1]），第二次减次大的（t[2]），直到x≤M。这样能确保用最少次数减少总时间。
* 💡 **学习笔记**：从大到小排序后正向遍历，代码更易理解，适合新手。

**题解二：作者小鲍bob**
* **亮点**：从小到大排序后反向取元素（i-su-1），避免从大到小排序的额外代码。
* **核心代码片段**：
    ```cpp
    sort(b+1, b+i); // 从小到大排序前i-1个学生的时间
    while(k > m) {
        k -= b[i - su - 1];
        su++;
    }
    ```
* **代码解读**：
    > `sort(b+1, b+i)`将前i-1个时间从小到大排序（b数组存储原始时间）。`i-su-1`是反向索引：su=0时取b[i-1]（最大的），su=1时取b[i-2]（次大的），以此类推。例如，i=6时，数组b[1..5]排序后，i-su-1=5-su，su从0开始，依次取5、4、3…位置的元素（即从大到小）。这种方式省去了自定义cmp函数，更简洁。
* 💡 **学习笔记**：反向索引是排序问题中的常用技巧，能简化代码。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法的执行过程，我们设计一个“像素时间管理器”动画，用8位复古风格展示每一步操作！
</visualization_intro>

  * **动画演示主题**：像素时间教室——帮小P管理考试时间！

  * **核心演示内容**：学生按顺序进入教室，每个学生头顶显示自己的时间（像素数字）。总时间显示在教室上方的电子屏。当总时间超过M时，教室右侧的“时间池”会弹出前面学生的时间方块（按从小到大排序），最大的方块被“移除”（变透明并下落），总时间减少，直到电子屏显示≤M。

  * **设计思路简述**：8位像素风格（红、绿、蓝等明快色调）营造轻松氛围，时间方块的移动和消失动画强化“减去”操作的记忆。音效（“叮”声）在每次移除方块时播放，胜利音效在总时间达标时播放，增加互动感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 教室背景（像素风格桌椅），顶部电子屏显示“当前总时间：0”。
          * 控制面板：单步/自动按钮、速度滑块（1x-5x）、重置按钮。
          * 播放8位风格BGM（轻快的电子音乐）。

    2.  **学生入场与总时间累加**：
          * 第i个学生从左侧入场，头顶显示t[i]（如“5”用绿色像素块）。
          * 电子屏总时间更新为sum += t[i]（如从10→15）。

    3.  **超限时的贪心操作**：
          * 若sum > M，电子屏变红，触发“警报”音效（短促的“滴滴”声）。
          * 右侧“时间池”弹出前i-1个学生的时间方块（从小到大排列，如[2,3,4]）。
          * 最大的方块（如4）开始闪烁（黄色→红色），伴随“叮”声，变透明并下落消失，sum减少4。
          * 重复此过程，直到sum ≤ M，电子屏变绿，播放胜利音效（上扬的“啦~”）。

    4.  **交互控制**：
          * 单步模式：点击“下一步”，手动触发一次方块移除。
          * 自动模式：根据速度滑块（如2x）自动播放移除动画，学习者可观察连续操作。
          * 重置按钮：重置所有学生和总时间，重新开始演示。

  * **旁白提示**：
      * （学生入场时）“现在处理第i个学生，总时间变为sum！”
      * （超限时）“总时间超过M啦！需要移除前面最大的时间方块~”
      * （移除方块时）“看，这个最大的时间被移除了，总时间减少到sum - t_max！”

<visualization_conclusion>
通过这样的动画，我们能清晰看到贪心算法如何“聪明”地选择最大的时间移除，用最少次数满足条件。像素风格和音效让学习过程更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在“选择最优局部解”的问题中应用广泛，以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 活动选择问题：选择结束时间最早的活动，最大化活动数量（贪心选局部最优）。
      * 合并果子：每次合并最小的两堆，最小化总代价（贪心选局部最小）。
      * 背包问题（贪心版）：优先装单位价值最高的物品（贪心选局部最优）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090** - `合并果子`
          * 🗣️ **推荐理由**：练习用优先队列实现贪心，每次选最小元素合并，与本题“选最大元素移除”思路互补。
    2.  **洛谷 P1803** - `线段覆盖`
          * 🗣️ **推荐理由**：贪心选择结束时间最早的线段，与本题“选最大时间移除”均需“局部最优”思维。
    3.  **洛谷 P2240** - `部分背包问题`
          * 🗣️ **推荐理由**：贪心选择单位价值最高的物品，强化“每一步最优”的贪心思想。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到“排序时不要包括当前学生”的调试经验，这对避免错误非常关键：
</insights_intro>

> **参考经验 (来自小鲍bob的题解)**：“在调试时发现，最初错误地将当前学生的时间排序，导致减去自己的时间，输出错误。后来通过打印排序后的数组，发现了问题。”

> **点评**：这位作者的经验提醒我们，边界条件（如排序范围）的处理需要格外仔细。调试时打印中间变量（如排序后的数组）是定位错误的有效方法，这对我们来说是一个宝贵的调试技巧。

-----

<conclusion>
本次关于“Exam in BerSU (easy version)”的C++解题分析就到这里。希望这份指南能帮助大家掌握贪心算法的核心应用，学会用排序或优先队列解决类似问题。记住，多动手调试、观察中间步骤，是提升编程能力的关键！下次挑战更难的题目吧，加油！💪
</conclusion>

---
处理用时：163.17秒
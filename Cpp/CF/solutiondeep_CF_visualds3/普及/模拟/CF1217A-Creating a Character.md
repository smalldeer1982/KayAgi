# 题目信息

# Creating a Character

## 题目描述

You play your favourite game yet another time. You chose the character you didn't play before. It has $ str $ points of strength and $ int $ points of intelligence. Also, at start, the character has $ exp $ free experience points you can invest either in strength or in intelligence (by investing one point you can either raise strength by $ 1 $ or raise intelligence by $ 1 $ ).

Since you'd like to make some fun you want to create a jock character, so it has more strength than intelligence points (resulting strength is strictly greater than the resulting intelligence).

Calculate the number of different character builds you can create (for the purpose of replayability) if you must invest all free points. Two character builds are different if their strength and/or intellect are different.

## 说明/提示

In the first query there are only three appropriate character builds: $ (str = 7, int = 5) $ , $ (8, 4) $ and $ (9, 3) $ . All other builds are either too smart or don't use all free points.

In the second query there is only one possible build: $ (2, 1) $ .

In the third query there are two appropriate builds: $ (7, 6) $ , $ (8, 5) $ .

In the fourth query all builds have too much brains.

## 样例 #1

### 输入

```
4
5 3 4
2 1 0
3 5 5
4 10 6
```

### 输出

```
3
1
2
0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Creating a Character 深入学习指南 💡

<introduction>
今天我们来一起分析“Creating a Character”这道C++编程题。这道题的核心是通过分配经验值，让角色的力量严格大于智力。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学问题（不等式求解与区间计算）`

🗣️ **初步分析**：
> 解决这道题的关键在于通过数学推导，找到满足条件的力量值范围。简单来说，我们需要确定力量（str）的最小可能值和最大可能值，然后计算这两个值之间的方案数。  
> 题目要求最终的力量（str+x）严格大于智力（int+y），其中x+y=exp（x是分配给力量的经验值，y是分配给智力的经验值）。通过变形不等式可以得到：str + x > int + (exp - x)，即 2x > int - str + exp。由此可以推导出x的取值范围，进而得到力量值的范围。  
> 核心难点在于处理边界条件（如经验值为0、初始力量小于智力等）和正确计算有效区间的长度。不同题解的思路大多围绕“找力量的最小/最大值”展开，差异主要在于具体推导方式（如直接解不等式、通过总和奇偶性分析等）。  
> 可视化设计时，我们可以用像素方格动态展示力量和智力的变化：初始时用两个长条分别表示力量和智力，经验值用零散的“经验点”像素块。每分配一个经验点（点击或自动播放），对应长条增长，同时检查力量是否严格大于智力。关键步骤（如确定最小值、最大值）用高亮框标注，最终方案数用“有效区间”的像素条长度表示。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下3份优质题解（≥4星），它们各有亮点，值得学习：
</eval_intro>

**题解一：作者：弦巻こころ**
* **点评**：这份题解思路简洁直接，通过数学推导快速定位力量的最小和最大值。代码中巧妙利用总和的奇偶性计算最小值（力量刚好超过智力的临界值），并通过`min(c+1, max(0ll, maxx - minn + 1ll))`处理边界条件（如经验值全部分配的情况）。变量命名清晰（`minn`/`maxx`），代码结构工整，适合竞赛快速实现。

**题解二：作者：YGB_XU**
* **点评**：此题解另辟蹊径，通过分析力量与智力的差值变化来计算方案数。将问题转化为“差值大于0”的条件，利用`tmp1 = a - b + c`（最大可能差值）和`tmp2 = a - b - c`（最小可能差值）快速判断是否存在解，并通过`(tmp1 + 1)/2`直接计算有效方案数。代码极简洁，逻辑跳跃但准确，体现了数学抽象的魅力。

**题解三：作者：开始新的记忆**
* **点评**：此题解通过逆向思考，先将所有经验值分配给智力，再逐步调整到力量，利用差值的变化规律计算方案数。虽然变量名（如`n`代表经验值）稍显模糊，但核心逻辑清晰（差值每减少2，方案数减少1），适合理解分配过程的动态变化。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们通常会遇到以下几个关键点，结合优质题解的共性，总结策略如下：
</difficulty_intro>

1.  **关键点1：如何确定力量的最小值？**
    * **分析**：力量的最小值是“力量刚好严格大于智力”的临界值。假设总经验值全部分配后，力量+智力的总和为`a + b + c`（a是初始力量，b是初始智力，c是经验值）。若总和为偶数，则力量最小值为`(总和/2) + 1`（确保严格大于）；若为奇数，则最小值为`(总和 + 1)/2`（直接取整后自然严格大于）。  
    * 💡 **学习笔记**：总和的奇偶性决定了力量的最小临界值，这是数学推导的核心。

2.  **关键点2：如何处理边界条件？**
    * **分析**：常见边界包括：经验值为0（此时需初始力量已大于智力）、初始力量小于智力（需先分配经验值弥补差距）、所有分配都无法满足条件（直接输出0）。优质题解通过`min(c+1, ...)`和`max(0, ...)`等操作确保结果非负且不超过总方案数（c+1种可能）。  
    * 💡 **学习笔记**：边界条件是编程题的“陷阱”，需逐一验证（如经验值为0、初始力量≤智力等）。

3.  **关键点3：如何高效计算有效方案数？**
    * **分析**：有效方案数是力量最大值（初始力量+所有经验值）与最小值的差值加1。但需注意，若最小值大于最大值（无解）或方案数超过总可能数（c+1种），需取较小值。  
    * 💡 **学习笔记**：方案数的计算需结合数学区间和实际分配限制（经验值必须全部分配）。

### ✨ 解题技巧总结
-   **问题抽象**：将分配问题转化为不等式求解，用数学表达式简化逻辑（如`2x > int - str + exp`）。
-   **边界优先**：先处理特殊情况（如经验值为0、初始力量≤智力），避免后续计算出错。
-   **奇偶性利用**：总和的奇偶性直接影响力量最小值的计算，是快速推导的关键。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼一个简洁、通用的核心实现，帮助大家快速掌握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了弦巻こころ和YGB_XU的思路，通过总和奇偶性计算力量最小值，直接计算有效方案数，兼顾清晰与高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int t;
        cin >> t;
        while (t--) {
            int a, b, c; // a:初始力量，b:初始智力，c:经验值
            cin >> a >> b >> c;
            int total = a + b + c; // 总属性和
            int minn;
            // 计算力量最小值（严格大于智力的临界值）
            if (total % 2 == 0)
                minn = total / 2 + 1;
            else
                minn = (total + 1) / 2;
            int maxx = a + c; // 力量最大值（经验全部分配给力量）
            int ans = max(0, maxx - minn + 1); // 有效方案数
            ans = min(ans, c + 1); // 不超过总可能数（c+1种分配方式）
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入，计算总属性和`total`。通过总属性和的奇偶性确定力量的最小值`minn`（确保严格大于智力）。力量的最大值`maxx`是初始力量加所有经验值（全部分配给力量）。有效方案数是`maxx - minn + 1`，但需取不超过总可能数（c+1种分配方式）的最小值，最后输出结果。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙思路。
</code_intro_selected>

**题解一：作者：弦巻こころ**
* **亮点**：通过总和奇偶性直接计算力量最小值，代码简洁且逻辑清晰。
* **核心代码片段**：
    ```cpp
    if ((a + b + c) % 2 == 0) {
        minn = (a + b + c) / 2 + 1;
    } else {
        minn = (a + b + c + 1) / 2;
    }
    maxx = a + c;
    printf("%I64d\n", min(c + 1, max(0ll, maxx - minn + 1ll)));
    ```
* **代码解读**：
    > 这段代码的核心是计算力量的最小值`minn`。总属性和为偶数时，力量至少需要`总和/2 + 1`才能严格大于智力（因为总和=力量+智力，力量>智力意味着力量>总和/2）；奇数时，`(总和+1)/2`自然大于智力。最大值`maxx`是力量全部分配经验的情况。最终方案数取有效区间长度和总可能数的较小值，确保结果合理。
* 💡 **学习笔记**：总和的奇偶性是关键，直接决定了力量的最小临界值。

**题解二：作者：YGB_XU**
* **亮点**：通过差值变化快速计算方案数，避免复杂的区间分析。
* **核心代码片段**：
    ```cpp
    int tmp1 = a - b + c; // 最大可能差值（经验全给力量）
    int tmp2 = a - b - c; // 最小可能差值（经验全给智力）
    if (tmp2 > 0) {
        printf("%d\n", c + 1); // 所有分配都满足
    } else if (tmp1 <= 0) {
        printf("%d\n", 0); // 所有分配都不满足
    } else {
        printf("%d\n", (tmp1 + 1) / 2); // 有效方案数
    }
    ```
* **代码解读**：
    > 这里的`tmp1`是力量与智力的最大可能差值（经验全给力量），`tmp2`是最小可能差值（经验全给智力）。若`tmp2 > 0`，说明所有分配都满足条件，方案数为`c+1`（c+1种分配方式）；若`tmp1 <= 0`，无解；否则，有效方案数是`(最大差值 + 1)/2`（因为差值每增加2，对应一种有效分配）。
* 💡 **学习笔记**：差值的变化规律是解题的另一种视角，能简化计算。

**题解三：作者：开始新的记忆**
* **亮点**：逆向思考，从全部分配智力出发，逐步调整到力量。
* **核心代码片段**：
    ```cpp
    int s = n + 1; // 总分配方式数（n是经验值）
    b += n; // 智力全部分配经验
    int nn = b - a; // 智力与力量的差值
    if (nn > 0)
        s -= (nn / 2 + 1); // 每减少2差值，方案数减少1
    cout << max(s, 0) << endl;
    ```
* **代码解读**：
    > 初始假设经验全部分配给智力（b += n），此时智力与力量的差值为`nn`。若`nn > 0`，说明需要将部分经验从智力转移到力量，每转移1点经验（智力-1，力量+1），差值减少2。需要转移至少`nn/2 + 1`次才能让力量>智力，因此方案数减少相应次数。
* 💡 **学习笔记**：逆向分配是一种直观的思考方式，适合理解动态调整过程。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解经验分配的过程，我们设计一个“像素经验分配器”动画，用8位像素风格展示力量和智力的变化，以及有效方案数的计算！
</visualization_intro>

  * **动画演示主题**：`像素经验分配器——打造力量型角色`

  * **核心演示内容**：展示经验值分配的每一步，力量和智力的变化，以及如何计算满足条件的方案数。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色的长条表示力量（红色）和智力（蓝色），经验值用黄色小方块表示。通过动态分配经验值，观察长条长度变化，当红色长条严格长于蓝色时，计数有效方案。关键步骤（如计算最小值、最大值）用文字气泡提示，增强互动性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕上方显示“力量”（红色长条）和“智力”（蓝色长条），初始长度为输入的`a`和`b`。
          * 下方显示“经验值”（c个黄色小方块）和控制面板（单步/自动播放按钮、速度滑块）。
          * 播放8位风格的轻快背景音乐。

    2.  **经验分配演示**：
          * 点击“自动播放”，黄色小方块逐个飞向红色或蓝色长条（模拟分配），每分配一个，对应长条长度增加1，伴随“叮”的音效。
          * 分配完成后，检查红色长条是否严格长于蓝色长条：若是，该分配方案有效（绿色勾标记）；否则无效（红色叉标记）。

    3.  **关键步骤高亮**：
          * 当分配到力量的最小值时（如`minn`），红色长条闪烁并显示“最小有效力量”；分配到最大值时（`maxx`），显示“最大有效力量”。
          * 有效方案数用绿色数字在屏幕中央弹出，伴随“胜利”音效。

    4.  **交互控制**：
          * 支持“单步执行”：点击一次分配一个经验值，观察长条变化；
          * “重置”按钮：回到初始状态，重新分配；
          * 速度滑块：调整自动播放速度（慢/中/快）。

    5.  **游戏化元素**：
          * 每完成一个有效方案，屏幕飘落像素星星；
          * 全部有效方案展示后，显示“成功打造力量型角色！”，播放庆祝音乐。

  * **旁白提示**：
      * （分配前）“现在，我们需要把所有经验值分配给力量或智力，让力量严格大于智力！”
      * （分配中）“看，力量增加了！现在力量是XX，智力是YY，满足条件吗？”
      * （计算时）“有效方案数是最大值减最小值加1，注意不能超过总分配方式哦！”

<visualization_conclusion>
通过这个像素动画，我们不仅能“看到”经验分配的过程，还能直观理解力量最小值、最大值和方案数的计算逻辑，学习更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下类似问题，巩固数学分析和不等式求解的能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的核心是“分配后满足某种条件”，类似问题包括：资源分配（如分糖果，要求A类≥B类）、任务调度（如时间分配，要求某任务时间更长）、统计符合条件的组合数（如两数之和大于第三数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1035** - `级数求和`  
          * 🗣️ **推荐理由**：通过数学推导确定项数，锻炼不等式求解能力。
    2.  **洛谷 P1088** - `火星人`  
          * 🗣️ **推荐理由**：涉及排列组合的边界条件处理，与本题的“方案数计算”思维类似。
    3.  **洛谷 P1217** - `回文数`  
          * 🗣️ **推荐理由**：通过数学规律缩小搜索范围，与本题的“找最小/最大值”思路相似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 幽界の冥神)**：“本题我交了两遍才过，挂在了一些细节上。比如初始力量小于智力时，需要先分配经验值弥补差距，否则直接计算会出错。”
>
> **点评**：这位作者的经验提醒我们，边界条件（如初始力量≤智力）是常见的错误点。在编程时，应优先处理这些特殊情况，避免逻辑漏洞。可以通过手动模拟小样例（如样例输入）来验证代码的正确性。

-----

<conclusion>
本次关于“Creating a Character”的C++解题分析就到这里。希望这份指南能帮助大家掌握数学分析和边界条件处理的技巧。记住，多动手模拟、多总结规律，编程能力会越来越强！下次再见～💪
</conclusion>

-----

---
处理用时：186.34秒
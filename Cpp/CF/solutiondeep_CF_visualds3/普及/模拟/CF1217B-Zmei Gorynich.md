# 题目信息

# Zmei Gorynich

## 题目描述

You are fighting with Zmei Gorynich — a ferocious monster from Slavic myths, a huge dragon-like reptile with multiple heads!

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1217B/7c3f181294cd1faa21453100051e900a119a772c.png)Initially Zmei Gorynich has $ x $ heads. You can deal $ n $ types of blows. If you deal a blow of the $ i $ -th type, you decrease the number of Gorynich's heads by $ min(d_i, curX) $ , there $ curX $ is the current number of heads. But if after this blow Zmei Gorynich has at least one head, he grows $ h_i $ new heads. If $ curX = 0 $ then Gorynich is defeated.

You can deal each blow any number of times, in any order.

For example, if $ curX = 10 $ , $ d = 7 $ , $ h = 10 $ then the number of heads changes to $ 13 $ (you cut $ 7 $ heads off, but then Zmei grows $ 10 $ new ones), but if $ curX = 10 $ , $ d = 11 $ , $ h = 100 $ then number of heads changes to $ 0 $ and Zmei Gorynich is considered defeated.

Calculate the minimum number of blows to defeat Zmei Gorynich!

You have to answer $ t $ independent queries.

## 说明/提示

In the first query you can deal the first blow (after that the number of heads changes to $ 10 - 6 + 3 = 7 $ ), and then deal the second blow.

In the second query you just deal the first blow three times, and Zmei is defeated.

In third query you can not defeat Zmei Gorynich. Maybe it's better to convince it to stop fighting?

## 样例 #1

### 输入

```
3
3 10
6 3
8 2
1 4
4 10
4 1
3 2
2 6
1 100
2 15
10 11
14 100
```

### 输出

```
2
3
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Zmei Gorynich 深入学习指南 💡

<introduction>
今天我们来一起分析“Zmei Gorynich”这道C++编程题。这道题需要我们找到击败恶龙的最少攻击次数，涉及贪心算法的巧妙应用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法应用

🗣️ **初步分析**：
解决“Zmei Gorynich”这道题，关键在于运用贪心策略——每一步选择当前最优的攻击方式，以最小化总攻击次数。贪心算法的核心思想就像“每一步都选能让你离终点最近的路”，比如找宝藏时每次都往宝藏方向走。在本题中，我们需要找到两种关键“最优选择”：

- **最后一击的最优选择**：用单次伤害最大的攻击（记为`d_max`），因为最后一击后恶龙不会再长头，所以直接选伤害最大的。
- **前期消耗的最优选择**：用净伤害最大的攻击（记为`k_max = d_i - h_i`的最大值），因为每次攻击后恶龙会恢复头，所以要选“砍得多、长得少”的攻击，尽可能减少总头数。

### 题解思路与核心难点：
所有题解的核心思路一致：
1. 若`d_max >= x`（能直接秒杀），答案是1次。
2. 若`k_max <= 0`（每次攻击后头数不减或增加），无法杀死，答案是-1。
3. 否则，用`k_max`攻击将头数消耗到`d_max`能秒杀的状态，总次数为`ceil((x - d_max)/k_max) + 1`（+1是最后一击）。

**核心难点**：正确识别`d_max`和`k_max`的作用，以及计算次数时的上取整处理（例如，剩余头数不足`k_max`时仍需1次攻击）。

### 可视化设计思路：
我们将设计一个8位像素风格的动画，场景是“恶龙的头数变化”：
- 用像素方块表示恶龙的头（绿色），每次攻击后用红色方块表示砍掉的头，黄色方块表示新长的头。
- 控制面板包含“单步执行”“自动播放”按钮，速度滑块调节播放速度。
- 关键步骤高亮：使用`d_max`攻击时，最后一击的像素方块闪烁金色；使用`k_max`攻击时，净伤害的数字（`d_i - h_i`）用蓝色高亮。
- 音效：每次攻击播放“叮”的音效，秒杀时播放“胜利”音效，无法杀死时播放“提示”音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解评分均≥4星，值得参考：
</eval_intro>

**题解一：作者knsg251**
* **点评**：此题解思路简洁直接，明确指出了三种情况（秒杀、无法杀死、正常计算）。代码中变量名`maxn`（`d_max`）和`ans`（`k_max`）含义清晰，边界处理严谨（如`if(maxn >= x)`的特判）。公式计算部分`(x - maxn + ans - 1) / ans + 1`巧妙实现了上取整，是贪心策略的典型应用，适合新手学习。

**题解二：作者qpzc**
* **点评**：此题解将问题类比为“蜗牛爬井”，用生活中的例子帮助理解。代码简洁，变量名`mx1`（`d_max`）和`mx2`（`k_max`）直观，公式`ceil((x-mx1)*1.0/mx2)+1`直接体现了贪心思路。特别指出“最后一次攻击后不再长头”的关键点，逻辑清晰。

**题解三：作者Dreamerly**
* **点评**：此题解明确标注了“贪心”策略，并详细解释了两个特判条件的意义。代码中使用`read()`和`write()`函数优化输入输出，适合竞赛场景。公式部分用`ceil(1.0*(x-sk_max)/k_max)+1`，强调了浮点数计算的上取整，对边界条件的处理（如`k_max<=0`）非常严谨。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点，结合优质题解的共性，一起梳理解决策略：
</difficulty_intro>

1.  **关键点1：如何确定最后一击的攻击方式？**
    * **分析**：最后一击后恶龙不会再长头，因此应选择单次伤害最大的攻击（`d_max`）。例如，若`d_max=10`，恶龙剩余头数为8，用这一击即可秒杀，无需考虑后续恢复。
    * 💡 **学习笔记**：最后一击是“无副作用”的，优先选伤害最大的攻击能最小化总次数。

2.  **关键点2：如何判断是否能杀死恶龙？**
    * **分析**：若所有攻击的净伤害（`d_i - h_i`）的最大值`k_max <=0`，说明每次攻击后头数不减或增加，无法杀死。例如，攻击A砍3头长3头（净伤害0），攻击B砍2头长3头（净伤害-1），此时无论如何攻击，头数不会减少。
    * 💡 **学习笔记**：`k_max`是“有效伤害”的关键，若其≤0则直接输出-1。

3.  **关键点3：如何计算最少攻击次数？**
    * **分析**：假设当前头数为`x`，先用`k_max`攻击将头数消耗到`d_max`能秒杀的状态。剩余头数为`x - d_max`，需要`ceil((x - d_max)/k_max)`次攻击（上取整，因为不足`k_max`时也需1次），加上最后一击，总次数为`ceil((x - d_max)/k_max) + 1`。
    * 💡 **学习笔记**：上取整公式`(a + b - 1) / b`可以避免浮点运算，更高效。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将问题转化为“找两个关键值（`d_max`和`k_max`）”，简化复杂场景。
- **边界特判**：优先处理“秒杀”和“无法杀死”的情况，避免后续计算错误。
- **公式优化**：用整数运算实现上取整（如`(x - d_max + k_max - 1) / k_max`），避免浮点精度问题。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心C++实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用贪心策略，清晰处理三种情况，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int t;
        cin >> t;
        while (t--) {
            int n, x;
            cin >> n >> x;
            int d_max = -1, k_max = -1; // d_max: 最大单次伤害，k_max: 最大净伤害
            for (int i = 0; i < n; ++i) {
                int d, h;
                cin >> d >> h;
                d_max = max(d_max, d);
                k_max = max(k_max, d - h);
            }
            if (d_max >= x) { // 情况1：直接秒杀
                cout << 1 << endl;
            } else if (k_max <= 0) { // 情况2：无法杀死
                cout << -1 << endl;
            } else { // 情况3：计算次数
                int remain = x - d_max;
                int steps = (remain + k_max - 1) / k_max; // 上取整
                cout << steps + 1 << endl;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取测试用例数`t`，然后对每个用例：
    > 1. 读取攻击种类数`n`和初始头数`x`。
    > 2. 遍历所有攻击，计算`d_max`（最大单次伤害）和`k_max`（最大净伤害）。
    > 3. 根据三种情况输出结果：`d_max >=x`时输出1；`k_max <=0`时输出-1；否则计算剩余头数需要的攻击次数（上取整），加最后一击的总次数。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和实现思路。
</code_intro_selected>

**题解一：作者knsg251**
* **亮点**：用整数运算实现上取整，避免浮点误差，代码简洁高效。
* **核心代码片段**：
    ```cpp
    cout << (x - maxn + ans - 1) / ans + 1 << endl;
    ```
* **代码解读**：
    > 这段代码计算总攻击次数。`x - maxn`是最后一击前需要消耗的头数，`ans`是`k_max`（最大净伤害）。`(x - maxn + ans - 1) / ans`通过整数运算实现上取整（例如，若剩余头数为5，`k_max=3`，则`(5+3-1)/3=7/3=2`，即需要2次攻击）。最后加1是最后一击的次数。
* 💡 **学习笔记**：用`(a + b - 1) / b`替代`ceil(a*1.0/b)`，避免浮点运算，更高效。

**题解二：作者qpzc**
* **亮点**：直接使用`ceil`函数，代码可读性高，适合理解逻辑。
* **核心代码片段**：
    ```cpp
    cout << ceil((x - mx1) * 1.0 / mx2) + 1 << endl;
    ```
* **代码解读**：
    > 这段代码中，`(x - mx1)`是最后一击前需要消耗的头数，`mx2`是`k_max`。`ceil((x - mx1)*1.0/mx2)`计算上取整的次数，加1是最后一击的次数。例如，若剩余头数为5，`mx2=3`，则`ceil(5/3)=2`，总次数为2+1=3。
* 💡 **学习笔记**：`ceil`函数直观，但需注意转换为浮点数，避免整数除法的截断问题。

**题解三：作者Dreamerly**
* **亮点**：使用`read()`和`write()`优化输入输出，适合竞赛中处理大数据。
* **核心代码片段**：
    ```cpp
    int read() { 
        int num=0,sign=1;
        char ch=getchar();
        while(ch<'0'||ch>'9'){
            if(ch=='-') sign=-1;
            ch=getchar();
        }
        while(ch>='0'&&ch<='9'){
            num=(num<<3)+(num<<1)+(ch^48);
            ch=getchar(); 
        }
        return num*sign;
    }
    ```
* **代码解读**：
    > 这段代码实现了快速输入函数`read()`，通过位运算（`num<<3`等价于`num*8`，`num<<1`等价于`num*2`）加速数字读取，比`cin`更高效。在竞赛中，处理大量输入时能节省时间。
* 💡 **学习笔记**：竞赛中常用快速输入输出优化，减少I/O时间。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心策略的执行过程，我们设计了一个“恶龙砍头”像素动画，用8位复古风格展示每次攻击后头数的变化。
</visualization_intro>

  * **动画演示主题**：像素勇士砍恶龙（8位FC风格）

  * **核心演示内容**：展示如何用`d_max`和`k_max`攻击逐步减少恶龙的头数，最终秒杀。

  * **设计思路简述**：采用8位像素风格（红绿蓝主色调），模拟FC游戏画面，让学习更有趣。通过颜色高亮关键攻击（`d_max`金色，`k_max`蓝色），音效提示操作（攻击“叮”声，秒杀“胜利”声），帮助记忆核心步骤。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示恶龙（像素化龙形），头顶显示当前头数（绿色数字）。
          * 右侧显示攻击面板，列出所有攻击的`d_i`和`h_i`（红色数字）。
          * 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1-5倍速）。

    2.  **计算关键值**：
          * 动画自动计算`d_max`（金色高亮该攻击）和`k_max`（蓝色高亮该攻击），伴随“叮”音效。

    3.  **攻击演示**：
          * **秒杀情况**：若`d_max >=x`，勇士使用金色攻击，恶龙头顶数字变为0，播放“胜利”音效，龙消失。
          * **无法杀死情况**：若`k_max <=0`，每次攻击后，头数不减或增加（如从5→5→5），播放“提示”音效，显示“无法杀死”文字。
          * **正常情况**：先用蓝色攻击（`k_max`），头数减少（如10→7→4），每次攻击播放“叮”声；最后用金色攻击（`d_max`），头数变为0，播放“胜利”音效。

    4.  **AI自动演示**：
          * 点击“AI演示”，动画自动执行最优攻击序列，学习者可观察头数变化过程。

    5.  **目标达成**：
          * 成功杀死时，屏幕弹出“胜利！”像素文字，背景闪烁金色；失败时显示“无法杀死”，背景闪烁红色。

  * **旁白提示**：
      - “看，金色攻击是单次伤害最大的，最后用它可以直接秒杀！”
      - “蓝色攻击每次能减少最多的头数（砍3长1，净减2），所以前期用它最划算～”
      - “如果蓝色攻击的净伤害≤0，每次攻击后头数不会减少，恶龙永远杀不死哦！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到贪心策略如何选择攻击顺序，以及`d_max`和`k_max`在不同情况下的作用，让抽象的算法变得“看得见、摸得着”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在解决“最优选择”类问题中非常常用，掌握本题的思路后，可以尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 贪心算法适用于“每一步选择当前最优”的问题，例如：
        - 活动选择问题（选结束最早的活动，最大化数量）。
        - 硬币找零问题（优先用面值大的硬币，最小化数量）。
        - 任务调度问题（优先处理截止时间早的任务，避免超时）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1223 排队接水**
          * 🗣️ **推荐理由**：经典贪心问题，需要按接水时间排序，最小化总等待时间，巩固“当前最优”的选择思路。
    2.  **洛谷 P1803 线段覆盖**
          * 🗣️ **推荐理由**：选择不重叠的线段，最大化数量，需要按右端点排序，理解“局部最优→全局最优”的逻辑。
    3.  **洛谷 P2240 硬币问题**
          * 🗣️ **推荐理由**：用贪心策略选择硬币，最小化数量，注意“贪心失效”的情况（如硬币面值不满足贪心条件时），培养对算法适用场景的判断能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试时的经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者xiaoqian02)**：“码风奇丑勿喷～ 但要注意特判`x<=maxx`的情况，否则会RE（运行时错误）。”
>
> **点评**：这段经验提醒我们，边界条件的处理非常重要。例如，当`x`刚好等于`d_max`时，必须直接输出1，否则后续计算会出错。在编程中，多测试边界情况（如x=0、x=d_max）能有效避免RE或WA（答案错误）。

-----

<conclusion>
本次关于“Zmei Gorynich”的C++解题分析就到这里。通过贪心策略的应用，我们学会了如何选择最优攻击顺序，以及处理边界条件的技巧。记住，贪心算法的关键是找到“当前最优”的选择，多练习类似题目能加深理解。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：174.83秒
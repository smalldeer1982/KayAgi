# 题目信息

# The Number Of Good Substrings

## 题目描述

You are given a binary string $ s $ (recall that a string is binary if each character is either $ 0 $ or $ 1 $ ).

Let $ f(t) $ be the decimal representation of integer $ t $ written in binary form (possibly with leading zeroes). For example $ f(011) = 3, f(00101) = 5, f(00001) = 1, f(10) = 2, f(000) = 0 $ and $ f(000100) = 4 $ .

The substring $ s_{l}, s_{l+1}, \dots , s_{r} $ is good if $ r - l + 1 = f(s_l \dots s_r) $ .

For example string $ s = 1011 $ has $ 5 $ good substrings: $ s_1 \dots s_1 = 1 $ , $ s_3 \dots s_3 = 1 $ , $ s_4 \dots s_4 = 1 $ , $ s_1 \dots s_2 = 10 $ and $ s_2 \dots s_4 = 011 $ .

Your task is to calculate the number of good substrings of string $ s $ .

You have to answer $ t $ independent queries.

## 样例 #1

### 输入

```
4
0110
0101
00001000
0001000
```

### 输出

```
4
3
4
3
```

# AI分析结果



---
# 💡 Kay的C++算法解析：The Number Of Good Substrings 深入学习指南 💡

<introduction>
今天我们来一起分析“The Number Of Good Substrings”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过分析优质题解、核心代码和可视化演示，相信你会对这类问题有更深刻的理解！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举优化（结合编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键在于优化暴力枚举。简单来说，枚举就是逐个检查可能的子串，但直接枚举所有子串会超时（时间复杂度O(n²)）。因此需要找到“剪枝”方法——利用二进制数的特性，限制枚举的范围。

二进制数的十进制值增长非常快（每次左移一位，值×2），而子串长度最多是原字符串长度n。因此，对于每个起始位置，我们只需枚举最多log₂(n)次（因为超过n后值一定大于长度）。同时，前导零不会改变二进制值（例如“001”和“1”的十进制值相同），所以可以预处理每个位置之后第一个“1”的位置（记为next数组），跳过前导零，减少无效枚举。

- **题解思路**：所有优质题解均采用“预处理next数组+限制枚举次数”的思路。预处理next[i]表示从i开始第一个“1”的位置（包括i自己），然后从next[i]开始枚举子串右端点，计算二进制值，判断是否等于子串长度。
- **核心难点**：如何高效处理前导零，避免无效枚举；如何确定枚举的终止条件（当二进制值超过n时停止）。
- **可视化设计**：用8位像素风展示字符串（每个字符为一个像素块，“1”红色，“0”灰色），动态标注next数组的位置（黄色箭头），枚举时用绿色框圈住当前子串，数值显示区实时更新二进制值，当值等于长度时播放“叮”的音效并高亮。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者Miracle_1024**
* **点评**：此题解思路清晰，代码简洁规范。预处理next数组的方式（从后往前遍历，记录每个位置之后第一个“1”的位置）非常巧妙，直接跳过前导零。枚举时通过限制二进制值不超过n来剪枝，时间复杂度O(n log n)，适合竞赛场景。代码中变量名如`a[i]`（next数组）、`poww`（当前二进制值）含义明确，边界处理严谨（如`j < s.size()`）。

**题解二：作者Dream_poetry**
* **点评**：此题解逻辑直白，代码结构工整。通过`now`变量动态更新next数组，与Miracle_1024的思路一致但实现更简洁。枚举时直接从next[i]开始，避免前导零的无效计算，代码可读性高，适合新手学习。

**题解三：作者minVan**
* **点评**：此题解代码简洁高效，变量命名规范（如`ans`统计答案，`t`记录当前二进制值）。通过位运算`<<`优化乘法（`t <<= 1`等价于`t *= 2`），体现了良好的编程技巧。剪枝条件`if(t > n) break`精准，避免不必要的循环。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点，结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何处理前导零，避免无效枚举？
    * **分析**：前导零不会改变二进制值（如“001”和“1”的十进制值相同），但会增加枚举次数。优质题解通过预处理`next[i]`（从i开始第一个“1”的位置），直接从`next[i]`开始枚举，跳过前导零。例如，若i位置是“0”，则`next[i]`指向后面第一个“1”的位置j，枚举从j开始，而不是i。
    * 💡 **学习笔记**：预处理前导零的位置，是减少无效计算的关键技巧。

2.  **关键点2**：如何确定枚举的终止条件？
    * **分析**：二进制值随长度增长呈指数级增长（每次左移一位，值×2），而子串长度最多为n。因此，当二进制值超过n时，后续枚举的子串长度会更大，值也会更大，不可能满足“值=长度”的条件，此时可以提前终止枚举。
    * 💡 **学习笔记**：利用二进制值的指数增长特性，设置剪枝条件（值>n时break），将时间复杂度从O(n²)优化到O(n log n)。

3.  **关键点3**：如何高效计算子串的二进制值？
    * **分析**：从左到右遍历子串，逐位计算二进制值（当前值×2 + 当前位是否为1）。例如，子串“101”的计算过程是：初始值0→0×2+1=1→1×2+0=2→2×2+1=5。优质题解通过循环累加实现这一过程，代码简洁高效。
    * 💡 **学习笔记**：逐位计算二进制值是处理二进制子串问题的通用方法。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理前导零**：用数组记录每个位置之后第一个“1”的位置，跳过前导零的无效枚举。
- **指数增长剪枝**：利用二进制值的指数增长特性，当值超过n时提前终止枚举。
- **逐位计算二进制值**：从左到右逐位计算子串的二进制值，避免重复计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Miracle_1024、Dream_poetry等优质题解的思路，预处理next数组+限制枚举次数，代码简洁高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e5 + 10;
    int next_pos[N]; // next_pos[i]表示从i开始第一个'1'的位置（包括i）

    int main() {
        int t;
        cin >> t;
        while (t--) {
            string s;
            cin >> s;
            int n = s.size();
            // 预处理next_pos数组
            next_pos[n] = n; // 边界：超出字符串范围设为n
            for (int i = n - 1; i >= 0; --i) {
                if (s[i] == '1') next_pos[i] = i;
                else next_pos[i] = next_pos[i + 1];
            }
            int ans = 0;
            // 枚举每个起始位置i
            for (int i = 0; i < n; ++i) {
                int num = 0; // 当前子串的二进制值
                // 从next_pos[i]开始枚举右端点j（跳过前导零）
                for (int j = next_pos[i]; j < n; ++j) {
                    num = num * 2 + (s[j] == '1'); // 计算二进制值
                    if (num == j - i + 1) ans++; // 满足条件，计数+1
                    if (num > n) break; // 剪枝：值超过n，后续不可能满足
                }
            }
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理`next_pos`数组，记录每个位置之后第一个“1”的位置。然后枚举每个起始位置i，从`next_pos[i]`开始枚举右端点j，逐位计算子串的二进制值`num`。当`num`等于子串长度（`j-i+1`）时计数，若`num`超过n则提前终止枚举。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Miracle_1024**
* **亮点**：预处理`a`数组（即next数组）的方式简洁，枚举时用`poww`记录二进制值，剪枝条件明确。
* **核心代码片段**：
    ```cpp
    for(int i=s.size()-1;i>=0;i--){
        if(s[i]=='1')a[i]=i;
        else a[i]=a[i+1];
    }
    for(int i=0;i<s.size();i++){
        poww=0;
        for(int j=a[i];j<s.size();j++){
            poww*=2;
            if(s[j]=='1')poww++;
            if(poww>s.size())break;
            if(j-i+1==poww)ans++;
        }
    }
    ```
* **代码解读**：
    第一段循环从后往前预处理`a`数组：若当前字符是“1”，则`a[i]=i`；否则`a[i]`等于后面第一个“1”的位置（即`a[i+1]`）。第二段循环枚举每个起始位置i，从`a[i]`（第一个“1”的位置）开始枚举右端点j，计算二进制值`poww`。当`poww`超过字符串长度时break（剪枝），若等于子串长度（`j-i+1`）则ans加1。
* 💡 **学习笔记**：预处理数组的方向（从后往前）是关键，确保每个位置都能快速找到后面的“1”。

**题解二：作者minVan**
* **亮点**：用位运算`<<`优化乘法（`t <<= 1`等价于`t *= 2`），代码更高效。
* **核心代码片段**：
    ```cpp
    for(int i = n - 1, t = n; i >= 0; i--) {
        if(s[i] == '1') { t = i; }
        a[i] = t;
    }
    for(int i = 0; i < n; i++) {
        int t = 0;
        for(int j = a[i]; j < n; j++) {
            t <<= 1;
            if(s[j] == '1') { ++t; }
            if(t == j - i + 1) { ++ans; }
            if(t > n) { break; }
        }
    }
    ```
* **代码解读**：
    预处理`a`数组时，用变量`t`动态记录当前第一个“1”的位置，避免数组越界。枚举时用`t`记录二进制值，`<<=`是位左移操作（等价于乘以2），比乘法更高效。当`t`等于子串长度时ans加1，超过n时break。
* 💡 **学习笔记**：位运算可以提升代码效率，适合竞赛场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“预处理next数组+限制枚举”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素小探险家的二进制寻宝`（结合红白机风格）

  * **核心演示内容**：展示预处理next数组的过程，以及枚举子串时二进制值的计算和判断过程。

  * **设计思路简述**：8位像素风（16色调色板，如红色“1”、灰色“0”）营造轻松氛围；关键步骤（如找到“1”、计算二进制值）用音效和高亮提示，强化记忆；每找到一个好子串，视为“小关卡”完成，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕上方显示像素化的二进制字符串（每个字符为16x16像素块，“1”红色，“0”灰色）。
          * 下方显示控制面板：开始/暂停、单步、重置按钮，速度滑块（1-10倍速）。
          * 播放8位风格的背景音乐（如《超级马里奥》经典旋律）。

    2.  **预处理next数组**：
          * 从右到左遍历字符串，用黄色箭头标记当前处理位置i。
          * 当遇到“1”时，箭头变为绿色，标记`next_pos[i]=i`；遇到“0”时，箭头指向`next_pos[i+1]`（即后面第一个“1”的位置）。
          * 下方动态显示`next_pos`数组（如“next[3]=5”表示位置3的下一个“1”在位置5）。

    3.  **枚举子串并计算二进制值**：
          * 用蓝色框圈住当前起始位置i，红色框圈住`next_pos[i]`（第一个“1”的位置）。
          * 从`next_pos[i]`开始，逐个向右扩展右端点j，用绿色框圈住当前子串`[i,j]`。
          * 数值显示区实时更新二进制值（如“当前值：3”）和子串长度（如“长度：3”）。
          * 当值等于长度时，绿色框变为金色，播放“叮”的音效（类似FC游戏得分声），ans计数加1。
          * 当值超过n时，绿色框变为灰色，播放“噗”的音效（提示剪枝），停止扩展。

    4.  **AI自动演示模式**：
          * 点击“AI演示”，算法自动运行，小探险家（像素角色）从左到右移动，每处理一个起始位置i，就在该位置跳跃，遇到“1”时欢呼（像素动画）。

    5.  **结束状态**：
          * 所有起始位置处理完毕后，显示最终ans值（如“总共有4个好子串！”），播放胜利音效（如《超级马里奥》通关音乐），屏幕飘落像素星星。

  * **旁白提示**：
      * （预处理时）“看！黄色箭头在找后面的‘1’，遇到‘0’就跳转到后面的‘1’位置～”
      * （枚举时）“现在处理起始位置i=2，第一个‘1’在j=3，开始计算子串[2,3]的二进制值……”
      * （找到好子串时）“哇！值等于长度，这个子串是好的，ans加1！”

<visualization_conclusion>
通过这个像素动画，我们不仅能看到算法如何跳过前导零、计算二进制值，还能在趣味中理解剪枝的意义。下次遇到类似问题，你也能像小探险家一样高效解决啦！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以尝试以下拓展练习，巩固二进制子串处理和枚举优化的技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      本题的“预处理前导零+限制枚举次数”思路，还可用于：
      - 统计满足特定条件的二进制子串（如值为质数、值为偶数等）。
      - 处理其他进制（如八进制、十六进制）的子串问题。
      - 字符串中连续字符的统计问题（如最长连续1的子串）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1102** - `A-B数对`
          * 🗣️ **推荐理由**：考察哈希表优化枚举，与本题“剪枝优化”思路类似，适合练习枚举优化技巧。
    2.  **洛谷 P1361** - `小M的作物`
          * 🗣️ **推荐理由**：涉及二进制状态枚举，需要合理剪枝，能提升对枚举边界的理解。
    3.  **洛谷 P1439** - `排列LCS问题`
          * 🗣️ **推荐理由**：结合LCS和二进制优化，适合挑战进阶枚举技巧。

-----

## 7\. 学习心得与经验分享

<insights_intro>
部分题解作者分享了调试和优化的经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者liyp)**：“最初直接枚举所有子串，结果超时。后来发现前导零会导致大量无效枚举，于是预处理next数组跳过前导零，时间复杂度从O(n²)降到O(n log n)，成功通过。”
>
> **点评**：作者的经验告诉我们，遇到超时问题时，要分析无效计算的来源（如本题的前导零），通过预处理或剪枝优化。这是竞赛中常见的优化思路，值得我们学习！

-----

<conclusion>
本次关于“The Number Of Good Substrings”的分析就到这里。希望你掌握了“预处理前导零+限制枚举次数”的核心技巧，以及如何通过可视化理解算法流程。记住，编程的关键是多思考、多练习，遇到问题时尝试分析无效计算并优化。下次见！💪
</conclusion>

---
处理用时：189.98秒
# 题目信息

# Skyscrapers (easy version)

## 题目描述

这题是 [CF1313C2](https://www.luogu.com.cn/problem/CF1313C2) 的简单版本。这个版本中 $1 \leq n \leq 1000$。

Berland要起摩天大厦了。所有的摩天大厦都在高速公路附近建。发展商买了 $n$ 块地准备建 $n$ 栋摩天大厦，一块地一栋。

当规划一间摩天大厦的时候，建筑师要考虑一些条件。

第一，因为每栋摩天大厦有不同的用途，所以每栋摩天大厦都有自己的层数限制，也就是说，这栋摩天大厦的高度不能超过给定的值 $m_i$。

第二，根据城市的建设规则，一栋摩天大厦不能同时在左右有比它高的摩天大厦。

如果规范地表示，让我们把地编上一个编号从 $1$ 到 $n$。那么如果在第 $i$ 块地的摩天大厦有 $a_i$ 层，那么我们需要保证 $1 \le a_i \le m_i$。另外，这里不可以有整数 $j$ 和 $k$ 满足 $j < i < k$ 并且 $a_j > a_i < a_k$。第 $j, k$ 块地并不需要与第 $i$ 块地相邻。

发展商想要使得每块地上摩天大厦的楼层数之和最大。也请帮他找出在**任意一个**最优状况中每个摩天大厦的高度。也就是，要让建筑师考虑的条件都符合，而且要使得每块地上摩天大厦的楼层数之和最大。

## 样例 #1

### 输入

```
5
1 2 3 2 1```

### 输出

```
1 2 3 2 1```

## 样例 #2

### 输入

```
3
10 6 8```

### 输出

```
10 6 6```

# AI分析结果



---
# 💡 Kay的C++算法解析：Skyscrapers (easy version) 深入学习指南 💡

<introduction>
今天我们来一起分析“Skyscrapers (easy version)”这道C++编程题。这道题的关键在于构造一个满足特定条件的“山形”数组，使得总高度最大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举与贪心策略（结合数组约束处理）

🗣️ **初步分析**：
解决这道题的关键在于理解题目中的核心条件——不能存在某个位置i，其左右都有比它高的大厦。这意味着最终的高度数组必须是“山形”的：存在一个最高点k，左边的高度单调不降（从左到k逐渐升高或相等），右边的高度单调不升（从k到右逐渐降低或相等）。

简单来说，枚举与贪心策略就像“试穿衣服”：我们枚举每一个可能的“山顶”k，然后为这个k“量身定制”左右两边的高度（左边尽可能高但不破坏非降，右边尽可能高但不破坏非升），最后选择总高度最大的那个方案。

- **题解思路**：所有优质题解均采用枚举山顶k的策略（n≤1000时，O(n²)复杂度可行）。对于每个k，从k向左遍历，确保每个位置j的高度不超过k且不超过j+1的高度；同理向右遍历处理。计算总高度后，保留最大的那个方案。
- **核心难点**：如何证明“山形”结构是唯一满足条件的？如何高效处理左右两边的约束？
- **可视化设计**：我们将用8位像素风格动画演示枚举k的过程：每个k作为候选山顶时，左右两边的像素块逐渐“收缩”（若原高度超过约束则降低），同时显示当前总高度。关键步骤（如k的选择、左右约束处理）用高亮颜色和音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）。
</eval_intro>

**题解一：作者123456zmy**
* **点评**：此题解思路简洁直接，通过枚举每个k作为山顶，分别计算左右两边的约束高度，最终选择总高度最大的方案。代码结构清晰（变量名如`ans1`、`ansi`含义明确），边界处理严谨（如从i-1到1的循环）。亮点在于用`k=min(m[j],k)`巧妙维护当前约束高度，避免了复杂的数据结构，非常适合新手学习。

**题解二：作者Night_sea_64**
* **点评**：此题解明确指出“山形”结构的必要性，并通过`memcpy`直接复制数组保存最优解，代码简洁高效。其核心循环（左右约束处理）逻辑直白，易于理解。亮点在于用`b[j]=min(b[j+1],a[j])`直观体现了“左边非降”的约束，是典型的贪心实现。

**题解三：作者Ludo**
* **点评**：此题解通过详细的注释和分步处理（先左后右），清晰展示了每个步骤的目的。代码中`mini`变量的维护（记录当前最小约束高度）是关键，确保了左右两边的高度不会超过前一个位置的约束。亮点在于对“山形”结构的直观解释，帮助学习者理解为何这样的约束能满足题目条件。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：为什么“山形”结构是唯一满足条件的？
    * **分析**：假设存在一个位置i，其左右都有比它高的大厦（即存在j<i<k，a_j>a_i且a_k>a_i），则i是一个“低谷”。为避免这种情况，数组必须是单峰的（先升后降）。优质题解通过枚举山顶k，确保所有位置要么在上升段（左边），要么在下降段（右边），从而消除“低谷”。
    * 💡 **学习笔记**：题目中的条件等价于数组不能有“低谷”，因此必须是单峰结构。

2.  **关键点2**：如何处理左右两边的约束？
    * **分析**：对于山顶k，左边的每个位置j（j<k）的高度不能超过k，且不能超过j+1的高度（否则j+1的高度会比j低，破坏非降）。因此，从k向左遍历，每个j的高度取`min(m[j], 前一个位置的高度)`。同理，右边从k向右遍历，取`min(m[j], 前一个位置的高度)`。优质题解用`k=min(m[j],k)`或`b[j]=min(b[j+1],a[j])`实现这一逻辑。
    * 💡 **学习笔记**：约束处理的核心是“前一个位置的高度”作为当前的上限。

3.  **关键点3**：如何高效枚举山顶k？
    * **分析**：n≤1000时，直接枚举每个k（O(n)），对每个k处理左右两边（各O(n)），总复杂度O(n²)，足够通过。优质题解均采用此方法，代码简单且高效。
    * 💡 **学习笔记**：当n较小时，暴力枚举是最直接有效的策略。

### ✨ 解题技巧总结
-   **问题抽象**：将题目条件转化为“单峰数组”问题，简化思考。
-   **贪心约束**：处理左右两边时，用前一个位置的高度作为当前上限，确保非降/非升。
-   **数组复制**：用临时数组保存当前k对应的高度，避免修改原数组。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用枚举山顶k的策略，处理左右约束并记录最优解，适合新手学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    const int MAXN = 1005;
    int n, m[MAXN], ans[MAXN];
    int max_sum = 0;

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) cin >> m[i];

        for (int k = 1; k <= n; ++k) { // 枚举山顶k
            int tmp[MAXN]; // 临时数组保存当前k的高度
            int sum = 0;

            // 处理左边：从k向左，确保非降
            tmp[k] = m[k];
            sum += tmp[k];
            int current = tmp[k];
            for (int j = k - 1; j >= 1; --j) {
                current = min(m[j], current);
                tmp[j] = current;
                sum += tmp[j];
            }

            // 处理右边：从k向右，确保非升
            current = tmp[k];
            for (int j = k + 1; j <= n; ++j) {
                current = min(m[j], current);
                tmp[j] = current;
                sum += tmp[j];
            }

            // 更新最优解
            if (sum > max_sum) {
                max_sum = sum;
                memcpy(ans, tmp, sizeof(tmp));
            }
        }

        for (int i = 1; i <= n; ++i) cout << ans[i] << " ";
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入数组m，然后枚举每个可能的山顶k。对于每个k，先处理左边（从k向左遍历，每个位置取原高度和前一个位置高度的较小值），再处理右边（从k向右遍历，同样取较小值）。计算当前k的总高度后，保留最大的那个方案，最后输出最优数组。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，点出亮点和关键思路。
</code_intro_selected>

**题解一：作者123456zmy**
* **亮点**：用`k=min(m[j],k)`简洁维护当前约束高度，代码极简。
* **核心代码片段**：
    ```cpp
    for(int j=i-1;j>0;j--)ans+=(k=min(m[j],k));
    k=m[i];
    for(int j=i+1;j<=n;j++)ans+=(k=min(m[j],k));
    ```
* **代码解读**：
    > 这段代码处理左右两边的约束。左边循环中，`k`初始为m[i]（山顶高度），每次取m[j]和当前k的较小值，确保左边非降。右边同理，`k`重新初始化为m[i]，确保右边非升。`ans+=(k=min(...))`同时完成约束更新和求和，非常巧妙。
* 💡 **学习笔记**：用一个变量维护当前约束高度，避免了额外数组，节省空间。

**题解二：作者Night_sea_64**
* **亮点**：用`memcpy`直接复制数组保存最优解，代码简洁高效。
* **核心代码片段**：
    ```cpp
    if(sum>maxn){
        maxn=sum;
        memcpy(ans,b,sizeof(ans));
    }
    ```
* **代码解读**：
    > 当当前k的总高度sum大于之前的最大值maxn时，用`memcpy`将临时数组b复制到ans数组。这比逐个元素赋值更高效，且代码更简洁。
* 💡 **学习笔记**：合理使用内存复制函数可以简化代码。

**题解三：作者Ludo**
* **亮点**：分步处理左右约束，注释清晰，易于理解。
* **核心代码片段**：
    ```cpp
    for (long long j=i-1;j>=1;j--) {
        if (b[j]>mini) b[j]=mini;
        mini=min(b[j],mini);
        tmp+=b[j];
    }
    ```
* **代码解读**：
    > 左边处理中，`mini`初始为山顶高度m[i]。对于每个j，若b[j]超过mini（即当前约束），则将其设为mini，然后更新mini为当前b[j]和mini的较小值（确保下一个j的约束不超过当前）。这样逐步向左约束，保证左边非降。
* 💡 **学习笔记**：分步处理和变量维护是约束处理的关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举山顶和约束处理的过程，我设计了一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：「山顶探险家」——在像素大陆上寻找最优摩天大厦布局

  * **核心演示内容**：枚举每个k作为候选山顶，左右两边的像素大厦逐渐“收缩”（若原高度超过约束则降低），同时显示当前总高度，最终选出总高度最大的山顶。

  * **设计思路简述**：8位像素风（如FC游戏画面）营造轻松氛围；关键步骤（山顶选择、约束处理）用高亮和音效强化记忆；总高度动态显示，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕中间是n个像素大厦（每个大厦用不同高度的彩色方块表示，颜色根据位置渐变）。
          * 控制面板：开始/暂停、单步、重置按钮；速度滑块；当前山顶k显示框。
          * 背景音乐：8位风格的轻快旋律。

    2.  **枚举山顶k**：
          * 候选山顶k的像素大厦闪烁黄色，显示“当前山顶候选：k”。

    3.  **左边约束处理**：
          * 从k向左遍历，每个大厦j的像素块颜色变为蓝色（表示处理中）。
          * 若j的原高度（红色）超过前一个位置的高度（绿色），则像素块高度逐渐降低到约束值（绿色），伴随“叮”的音效。
          * 实时显示当前约束高度和累加的总高度。

    4.  **右边约束处理**：
          * 从k向右遍历，类似左边，像素块颜色变为紫色（表示处理中）。
          * 高度调整时同样有动画和音效。

    5.  **总高度比较**：
          * 当前k的总高度与之前最大值比较，若更大则播放“胜利”音效，k的像素大厦变为金色。

    6.  **最终结果展示**：
          * 最优山顶k的像素大厦高亮，左右两边显示最终高度（绿色），总高度用大字体显示。

  * **旁白提示**：
      * （左边处理时）“看，左边的大厦不能比右边的高哦！如果当前大厦太高，就会被压低～”
      * （右边处理时）“右边的大厦也不能比左边的高，同样需要压低～”
      * （总高度比较时）“这个山顶的总高度更高，我们记录下来！”

<visualization_conclusion>
通过这样的像素动画，我们能清晰看到每个山顶k的处理过程，理解约束如何一步步形成“山形”结构，以及总高度是如何计算的。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考贪心枚举和单峰数组的应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 单峰数组构造：类似问题如“最长单峰子数组”“最大矩形面积”等，需构造或寻找单峰结构。
      * 贪心约束处理：在数组构造问题中，常通过前一个位置的状态约束当前位置，如“非降子序列”“非升子序列”。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1091 合唱队形**
          * 🗣️ **推荐理由**：这道题要求构造单峰队列，与本题的“山形”结构类似，能帮助巩固单峰数组的构造方法。
    2.  **洛谷 P1359 租用游艇**
          * 🗣️ **推荐理由**：此题需枚举中间点，计算最优路径，与本题枚举山顶的思路相似，适合练习枚举策略。
    3.  **洛谷 P1803 凌乱的yyy**
          * 🗣️ **推荐理由**：此题需选择最多的不重叠区间，贪心策略的应用与本题的约束处理有共通之处。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如作者Ludo提到“复制数组时要注意初始化”，这对避免错误很有帮助。
</insights_intro>

> **参考经验 (来自作者Ludo)**：“复制到b数组，方便操作”——在处理临时数据时，使用临时数组避免修改原数组，是避免错误的关键。

> **点评**：作者的经验提醒我们，在枚举不同山顶时，必须用临时数组保存当前k的高度，否则会影响后续枚举。这是处理多状态问题的常见技巧，值得学习。

-----

<conclusion>
本次关于“Skyscrapers (easy version)”的C++解题分析就到这里。希望这份学习指南能帮助大家理解枚举与贪心策略的应用，掌握单峰数组的构造方法。记住，多动手实践、多分析题解，编程能力会稳步提升！下次见～💪
</conclusion>

---
处理用时：131.09秒
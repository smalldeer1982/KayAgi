# 题目信息

# Move Brackets

## 题目描述

You are given a bracket sequence $ s $ of length $ n $ , where $ n $ is even (divisible by two). The string $ s $ consists of $ \frac{n}{2} $ opening brackets '(' and $ \frac{n}{2} $ closing brackets ')'.

In one move, you can choose exactly one bracket and move it to the beginning of the string or to the end of the string (i.e. you choose some index $ i $ , remove the $ i $ -th character of $ s $ and insert it before or after all remaining characters of $ s $ ).

Your task is to find the minimum number of moves required to obtain regular bracket sequence from $ s $ . It can be proved that the answer always exists under the given constraints.

Recall what the regular bracket sequence is:

- "()" is regular bracket sequence;
- if $ s $ is regular bracket sequence then "(" + $ s $ + ")" is regular bracket sequence;
- if $ s $ and $ t $ are regular bracket sequences then $ s $ + $ t $ is regular bracket sequence.

For example, "()()", "(())()", "(())" and "()" are regular bracket sequences, but ")(", "()(" and ")))" are not.

You have to answer $ t $ independent test cases.

## 说明/提示

In the first test case of the example, it is sufficient to move the first bracket to the end of the string.

In the third test case of the example, it is sufficient to move the last bracket to the beginning of the string.

In the fourth test case of the example, we can choose last three openning brackets, move them to the beginning of the string and obtain "((()))(())".

## 样例 #1

### 输入

```
4
2
)(
4
()()
8
())()()(
10
)))((((())```

### 输出

```
1
0
1
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：Move Brackets 深入学习指南 💡

<introduction>
今天我们来一起分析“Move Brackets”这道C++编程题。这道题的关键是通过贪心策略快速统计需要移动的括号数量。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法`

🗣️ **初步分析**：
> 解决“Move Brackets”这道题，关键在于理解并运用贪心算法。贪心算法的核心思想是“每一步选择当前最优解”，就像吃糖果时每次选最甜的，最终整体会更甜~ 在本题中，贪心策略体现为：遍历括号序列时，遇到无法立即匹配的右括号，就将其“移动”（通过计数模拟），因为后续的左括号无法匹配前面的右括号，此时移动是最优选择。
   - **题解思路**：所有优质题解均采用遍历统计的方法。维护一个计数器`sum`（左括号+1，右括号-1），当`sum<0`时，说明当前右括号无法匹配，需移动（`ans++`），并重置`sum`为0。最终`ans`即为最少移动次数。
   - **核心算法流程**：遍历每个括号，更新`sum`；若`sum`为负，记录一次移动并重置`sum`。可视化设计中，需高亮当前处理的括号、`sum`的变化，以及移动操作的模拟（如右括号闪烁后移动到末尾）。
   - **复古像素设计**：采用8位像素风格，括号用不同颜色（左括号绿色，右括号红色），遍历指针为黄色箭头。移动操作时，右括号像素块闪烁后滑到屏幕右侧，伴随“叮”的音效；`sum`值实时显示在屏幕上方，用数字动画更新。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出以下优质题解（均≥4星）：
</eval_intro>

**题解一：作者：Acestar**
* **点评**：此题解思路直白，代码规范。通过`sum`计数器和`ans`统计无法匹配的右括号，逻辑简洁。变量名`sum`和`ans`含义明确，边界处理严谨（如`sum`重置为0）。算法时间复杂度O(n)，高效适用于题目约束（n≤50）。代码可直接用于竞赛，是典型的贪心实现。

**题解二：作者：Clouder**
* **点评**：此题解将括号转换为+1/-1的数学模型，思路巧妙。代码结构工整，循环从1到n（数组从1开始），符合部分竞赛选手的习惯。对算法的数学证明（如移动右括号后剩余括号的匹配性）有简要说明，增强了启发性。

**题解三：作者：zdxx**
* **点评**：此题解用`l`和`r`分别记录可匹配的左括号和需移动的右括号，逻辑清晰。输入处理（`read()`函数）体现了竞赛编程的高效性，代码简洁且无冗余。通过`l--`模拟匹配过程，直观易懂。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何判断一个右括号是否需要移动？
    * **分析**：当遍历到右括号时，若当前左括号数量（`sum`）为0，说明该右括号无法与前面的左括号匹配，必须移动。优质题解通过维护`sum`计数器，当`sum<0`时（即右括号数量超过左括号），立即统计一次移动并重置`sum`，确保后续括号的正确匹配。
    * 💡 **学习笔记**：`sum`的作用是跟踪当前可匹配的左括号数量，负值代表右括号“超前”，需移动。

2.  **关键点2**：为什么移动次数等于统计的`ans`？
    * **分析**：每次`sum<0`时统计的`ans`，实际上是无法被前面左括号匹配的右括号数量。由于题目保证总括号数相等，这些右括号最终会被移动到末尾，与后面的左括号匹配。因此，`ans`即为最少移动次数。
    * 💡 **学习笔记**：贪心策略的正确性基于“无法匹配的右括号必须移动”，且移动后不影响后续匹配。

3.  **关键点3**：如何处理边界情况（如全左或全右括号）？
    * **分析**：题目保证左右括号数量相等，因此全左或全右的情况不可能出现。但需注意初始`sum`为0时，遇到右括号直接`ans++`；遇到左括号则`sum++`。
    * 💡 **学习笔记**：边界处理的核心是初始化`sum=0`，并在每次操作后更新状态。

### ✨ 解题技巧总结
<summary_best_practices>
- **模型转换**：将括号问题转换为+1/-1的数学模型，简化匹配判断。
- **计数器维护**：用`sum`跟踪当前可匹配的左括号数量，负值时立即统计移动次数。
- **代码简洁性**：避免复杂数据结构，用基础变量（`sum`、`ans`）即可解决问题。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，逻辑清晰且高效，适用于题目约束。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        int t;
        cin >> t;
        while (t--) {
            int n;
            string s;
            cin >> n >> s;
            int sum = 0, ans = 0;
            for (char c : s) {
                if (c == '(') sum++;
                else sum--;
                if (sum < 0) { // 当前右括号无法匹配，需移动
                    ans++;
                    sum = 0; // 重置sum，后续括号重新匹配
                }
            }
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取测试用例数`t`，然后对每个测试用例：读取括号序列长度`n`和字符串`s`。遍历字符串，`sum`记录左括号减右括号的数量。当`sum<0`时，说明当前右括号无法匹配，`ans`加1并重置`sum`。最终输出`ans`，即最少移动次数。

---
<code_intro_selected>
接下来，我们将剖析优质题解中最能体现核心逻辑的代码片段。
</code_intro_selected>

**题解一：作者：Acestar**
* **亮点**：代码简洁，变量名清晰，直接体现贪心逻辑。
* **核心代码片段**：
    ```cpp
    for(int i=0; i<len; i++) {
        if(s[i]=='(') sum++;
        else sum--;
        if(sum<0) ans++,sum=0;
    }
    ```
* **代码解读**：
    > 这段代码遍历每个字符。遇到左括号，`sum`加1；右括号则减1。若`sum<0`（右括号无法匹配），`ans`加1并重置`sum`。例如，字符串`) (`中，第一个字符是`)`，`sum`变为-1，`ans`加1，`sum`重置为0；第二个字符是`(`，`sum`加1，最终`ans=1`，正确。
* 💡 **学习笔记**：`sum<0`的判断是关键，它直接标记了需要移动的右括号。

**题解二：作者：zdxx**
* **亮点**：用`l`和`r`分别记录可匹配的左括号和需移动的右括号，逻辑直观。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        scanf("%c",&x);
        if(x=='(') l++;
        else if(l) l--;
        else r++;
    }
    ```
* **代码解读**：
    > 遍历每个字符，左括号增加`l`；右括号若`l>0`则匹配（`l--`），否则`r`（需移动的右括号）加1。例如，字符串`))((`中，前两个`)`因`l=0`，`r`加2；后两个`(`增加`l`，最终`r=2`，但题目保证总括号数相等，实际答案应为2（但根据题目样例，可能需调整逻辑，此处代码正确）。
* 💡 **学习笔记**：`l`和`r`的命名更直观，适合理解匹配过程。

**题解三：作者：PragmaGCC**
* **亮点**：代码简洁，用`sta`代替`sum`，逻辑一致。
* **核心代码片段**：
    ```cpp
    for (int i = 0; i < n; i++) {
        if (s[i] == '(')
            sta++;
        else{
            if(sta==0)
                ans++;
            else
                sta--;
        }
    }
    ```
* **代码解读**：
    > `sta`记录当前可匹配的左括号数量。遇到右括号时，若`sta=0`（无左括号可匹配），`ans`加1；否则`sta--`（匹配一个左括号）。例如，字符串`)()(`中，第一个`)`使`ans=1`，第二个`(`使`sta=1`，第三个`)`使`sta=0`，第四个`(`使`sta=1`，最终`ans=1`，正确。
* 💡 **学习笔记**：`sta`的命名强调“栈”的概念，暗示括号匹配的后进先出特性。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法如何统计需要移动的括号，我设计了一个“像素括号探险”动画方案！让我们一起“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素括号大冒险——寻找合法序列`

  * **核心演示内容**：模拟括号序列的遍历过程，用像素块表示括号，高亮当前处理的括号，实时显示`sum`值，当`sum<0`时，右括号像素块闪烁后移动到屏幕右侧（模拟移动操作），并统计`ans`。

  * **设计思路简述**：8位像素风格（类似FC游戏）营造轻松氛围；颜色区分左右括号（左绿右红），指针用黄色箭头；移动时的闪烁和音效强化操作记忆；`sum`值实时显示在屏幕上方，帮助理解匹配状态。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为上下两部分：上方是`sum`和`ans`的数值显示（像素字体），下方是括号序列（每个括号是8x8像素块，左绿右红）。
          * 控制面板包含“开始/暂停”、“单步”、“重置”按钮，以及速度滑块（1-5倍速）。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》主题变奏）。

    2.  **算法启动**：
          * 黄色箭头指向第一个括号（位置0），播放“滴”的提示音。
          * `sum`初始化为0，`ans`初始化为0。

    3.  **核心步骤演示**：
          * **处理左括号**：箭头指向左括号（绿色），`sum`加1（数字动画从0→1），播放“叮”的轻响。
          * **处理右括号**：
            - 若`sum>0`：箭头指向右括号（红色），`sum`减1（数字动画从1→0），播放“嗒”的轻响。
            - 若`sum=0`：右括号像素块闪烁（红→黄→红），播放“嗡”的提示音，随后该括号像素块滑到屏幕右侧（模拟移动到末尾），`ans`加1（数字动画从0→1），`sum`重置为0。

    4.  **AI自动演示**：
          * 点击“AI自动”按钮，算法自动遍历所有括号，箭头自动移动，`sum`和`ans`实时更新，移动操作自动触发。学习者可观察完整过程。

    5.  **结束状态**：
          * 遍历完成后，所有括号变为蓝色（合法），播放“胜利”音效（如《超级玛丽》吃金币音），`ans`值放大显示。
          * 若中途出错（如`sum`异常），播放“滴滴”警告音，箭头停在错误位置并闪烁。

    6.  **游戏化关卡**：
          * 将每个测试用例视为一个“小关卡”，完成一个关卡后，屏幕弹出“通关成功！”的像素文字，奖励100分。连续通关可触发“连击”特效（如星星闪烁）。

  * **旁白提示**：
      - （处理左括号时）“遇到左括号，当前可匹配的左括号数量+1！”
      - （处理右括号且`sum>0`时）“右括号匹配了一个左括号，可匹配数量-1~”
      - （处理右括号且`sum=0`时）“这个右括号无法匹配，需要移动到末尾！`ans`加1~”

<visualization_conclusion>
通过这样的像素动画，我们能清晰看到每个括号的处理过程，以及`sum`和`ans`的变化，轻松理解贪心算法的核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考贪心算法在括号匹配问题中的其他应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 贪心算法在括号匹配中常用于统计无法直接匹配的括号数量（如本题）。
      * 类似地，它还可用于：
        1. 判断括号序列是否合法（如洛谷P1739）。
        2. 计算最少添加括号数使序列合法（如LeetCode 921）。
        3. 分割最长有效括号子串（如LeetCode 32）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1739** - `表达式括号匹配`
          * 🗣️ **推荐理由**：这道题是括号匹配的基础题，帮助巩固“栈”或计数器的使用，与本题思路密切相关。
    2.  **洛谷 P1541** - `乌龟棋`
          * 🗣️ **推荐理由**：此题需用动态规划结合贪心思想，锻炼多维度状态转移的思考能力。
    3.  **洛谷 P1241** - `括号序列`
          * 🗣️ **推荐理由**：此题需处理更复杂的括号嵌套，挑战对贪心策略的灵活应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题过程中的经验，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自作者：45dino)**：“类似P1739的题目做过，所以想到用贪心。遇到右括号且`cnt=0`时，直接统计移动次数，不需要真的移动。”
>
> **点评**：这位作者的经验提醒我们，做类似题目时，多总结经典问题（如P1739）的解法，能快速迁移思路。遇到新问题时，先联想是否有类似模型，是高效解题的关键！

-----

<conclusion>
本次关于“Move Brackets”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解贪心算法和括号匹配问题。记住，多练习、多总结，编程能力会越来越强！下次再见~ 💪
</conclusion>

-----

---
处理用时：138.14秒
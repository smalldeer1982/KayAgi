# 题目信息

# Division

## 题目描述

Oleg's favorite subjects are History and Math, and his favorite branch of mathematics is division.

To improve his division skills, Oleg came up with $ t $ pairs of integers $ p_i $ and $ q_i $ and for each pair decided to find the greatest integer $ x_i $ , such that:

- $ p_i $ is divisible by $ x_i $ ;
- $ x_i $ is not divisible by $ q_i $ .

 Oleg is really good at division and managed to find all the answers quickly, how about you?

## 说明/提示

For the first pair, where $ p_1 = 10 $ and $ q_1 = 4 $ , the answer is $ x_1 = 10 $ , since it is the greatest divisor of $ 10 $ and $ 10 $ is not divisible by $ 4 $ .

For the second pair, where $ p_2 = 12 $ and $ q_2 = 6 $ , note that

- $ 12 $ is not a valid $ x_2 $ , since $ 12 $ is divisible by $ q_2 = 6 $ ;
- $ 6 $ is not valid $ x_2 $ as well: $ 6 $ is also divisible by $ q_2 = 6 $ .

 The next available divisor of $ p_2 = 12 $ is $ 4 $ , which is the answer, since $ 4 $ is not divisible by $ 6 $ .

## 样例 #1

### 输入

```
3
10 4
12 6
179 822```

### 输出

```
10
4
179```

# AI分析结果



---
# 💡 Kay的C++算法解析：Division 深入学习指南 💡

<introduction>
今天我们来一起分析“Division”这道C++编程题。题目要求我们找到最大的整数x，使得x是p的因数且x不被q整除。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质因数分解与数论应用）`

🗣️ **初步分析**：
解决“Division”问题的关键在于利用质因数分解的思想。简单来说，质因数分解就像把一个数“拆成积木块”——每个质数是一块积木，指数是积木的数量。例如，12可以拆成2²×3¹。本题中，我们需要通过分解q的质因数，调整p的质因数次数，构造出符合条件的x。

- **题解思路**：当p不能被q整除时，直接取x=p（因为p本身是最大的因数且不被q整除）。当p是q的倍数时，q的所有质因数必然包含在p的质因数中。此时，我们需要找到p的一个因数x，使得x中至少有一个质因数的次数小于q中对应质因数的次数（这样x就不会被q整除）。通过枚举q的每个质因数，调整p中该质因数的次数为q中次数减一，其他质因数次数保持最大，取这些情况的最大值即为答案。
- **核心难点**：如何高效分解q的质因数，以及如何正确调整p中各质因数的次数。
- **可视化设计**：我们将设计一个“质因数拆解工厂”的像素动画，用不同颜色的方块代表不同质因数（如红色方块代表2，蓝色代表3），通过动画展示q的分解过程（方块堆叠成q的形状，再逐个拆解），以及p调整次数的过程（减少某类方块的数量后，重新组合成x的形状）。关键步骤高亮显示，比如当某个质因数的次数被减少时，对应方块闪烁并伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：作者Zesty_Fox**
* **点评**：此题解思路清晰，逻辑严谨。作者首先处理了p不能被q整除的特殊情况，直接返回p；对于p是q倍数的情况，通过分解q的质因数，枚举每个质因数调整p的次数，最终取最大值。代码规范，变量名如`pr`（质数数组）、`cnt`（质数计数）含义明确，边界处理（如q分解后剩余大质数的处理）严谨。亮点在于对质因数分解的高效实现（预筛质数表）和枚举调整的巧妙逻辑，适合竞赛参考。

**题解二：作者灵茶山艾府（Golang版，C++思路一致）**
* **点评**：此题解简洁高效，直接分解q的质因数，逐个处理每个质因数。代码逻辑直白，通过循环分解q的质因数，计算p中对应质因数的次数，调整次数后取最大值。虽然用Golang实现，但思路普适性强，适合理解核心逻辑。亮点是对分解后剩余大质数的处理（`if q > 1`的判断），避免了遗漏。

**题解三：作者Midoria7**
* **点评**：此题解代码简洁，变量名清晰（如`Div`函数分解质因数，`qpow`计算幂次）。作者明确指出“枚举每一个质因数，让x中该质因数的次数为q中次数减一”的核心思路，代码实现直接。亮点是多测不清空的提示（“多测不清空 爆零两行泪”），提醒学习者注意细节，实践价值高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：质因数分解的高效实现**
    * **分析**：q的范围是2到10⁹，直接分解可能耗时。优质题解通常预筛小质数（如筛到4e4），用预筛质数分解q，剩余部分若大于1则为大质数。例如，Zesty_Fox预筛到1e5的质数表，快速分解q的质因数。
    * 💡 **学习笔记**：预筛小质数表是分解大整数质因数的常用技巧，能显著提升效率。

2.  **关键点2：调整质因数次数的逻辑**
    * **分析**：当p是q的倍数时，p中每个质因数的次数≥q中的次数。要使x不被q整除，需让x中至少一个质因数的次数<q中的次数。最优策略是枚举每个质因数，将其次数调整为q中次数-1（其他次数拉满），取最大值。例如，q=6=2¹×3¹，p=12=2²×3¹，调整2的次数为0（2¹-1=0），得到x=3；调整3的次数为0（1-1=0），得到x=4，取最大值4。
    * 💡 **学习笔记**：枚举每个质因数调整次数，是构造最大x的关键策略。

3.  **关键点3：处理大质数的边界情况**
    * **分析**：分解q时，可能剩余一个大于预筛范围的大质数（如q=822=2×3×137，137是大质数）。需单独处理该质数，避免遗漏。例如，灵茶山艾府的题解中，分解完小质数后，若q>1，则q本身是大质数，需处理。
    * 💡 **学习笔记**：分解质因数后，检查剩余部分是否大于1，是处理大质数的关键步骤。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“p不是q倍数”和“p是q倍数”两种情况，分别处理。
- **质因数分解预筛**：预筛小质数表，加速大整数的质因数分解。
- **枚举调整**：枚举q的每个质因数，调整p中对应次数，取最大值。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Zesty_Fox和灵茶山艾府的思路，预筛小质数表加速质因数分解，处理大质数边界，逻辑清晰高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;
    typedef long long ll;

    const int MAX_PRIME = 1e5; // 预筛质数表到1e5
    vector<int> primes;
    bool is_prime[MAX_PRIME + 1];

    void sieve() { // 埃氏筛法预筛质数
        fill(is_prime, is_prime + MAX_PRIME + 1, true);
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= MAX_PRIME; ++i) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (int j = i * 2; j <= MAX_PRIME; j += i) {
                    is_prime[j] = false;
                }
            }
        }
    }

    ll max_x(ll p, ll q) {
        if (p % q != 0) return p; // 情况1：p不是q的倍数

        ll ans = 0;
        // 分解q的质因数
        vector<pair<ll, int>> factors; // (质因数, 次数)
        for (int prime : primes) {
            if (prime * prime > q) break;
            if (q % prime == 0) {
                int cnt = 0;
                while (q % prime == 0) {
                    q /= prime;
                    cnt++;
                }
                factors.emplace_back(prime, cnt);
            }
        }
        if (q > 1) factors.emplace_back(q, 1); // 处理剩余大质数

        // 枚举每个质因数，调整p的次数
        for (auto [pr, cnt_q] : factors) {
            ll tmp_p = p;
            int cnt_p = 0;
            while (tmp_p % pr == 0) {
                tmp_p /= pr;
                cnt_p++;
            }
            if (cnt_p < cnt_q) continue; // p中该质因数次数不足，跳过

            ll current = tmp_p;
            for (int i = 0; i < cnt_q - 1; ++i) { // 次数调整为cnt_q-1
                current *= pr;
            }
            ans = max(ans, current);
        }
        return ans;
    }

    int main() {
        sieve();
        int t;
        cin >> t;
        while (t--) {
            ll p, q;
            cin >> p >> q;
            cout << max_x(p, q) << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预筛小质数表（`sieve`函数），然后处理每组输入。对于每组p和q，若p不是q的倍数，直接输出p；否则分解q的质因数（`factors`存储质因数和次数），枚举每个质因数调整p的次数（将次数设为q中次数-1，其他质因数次数拉满），取最大值作为答案。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段。
</code_intro_selected>

**题解一：作者Zesty_Fox（核心片段）**
* **亮点**：预筛质数表加速分解，处理剩余大质数，代码规范。
* **核心代码片段**：
    ```cpp
    void pre(int lim) { // 预筛质数表
        for(int i=2; i<=lim; i++) {
            if(!vis[i]) {
                vis[i]=1; pr[++cnt]=i;
                for(int j=i; j<=lim/i; j++) vis[i*j]=1;
            }
        }
    }

    // main函数中处理分解和枚举调整
    ```
* **代码解读**：
    `pre`函数使用埃氏筛法预筛质数表（`pr`数组存储质数，`vis`标记合数），加速后续质因数分解。在`main`函数中，分解q时遍历预筛的质数表，处理每个质数的次数，剩余部分若大于1则为大质数。枚举调整时，计算p中该质因数的次数，调整后取最大值。
* 💡 **学习笔记**：预筛质数表是处理大数质因数分解的高效方法，能显著减少重复计算。

**题解二：作者Midoria7（核心片段）**
* **亮点**：代码简洁，直接分解q的质因数，枚举调整。
* **核心代码片段**：
    ```cpp
    inline void Div(long long x) { // 分解x的质因数
        v[0] = c[0] = 0;
        long long temp = x;
        for (int i = 2; i * i <= x; i++) {
            if (temp % i) continue;
            v[++v[0]] = i; c[v[0]] = 0;
            while (temp % i == 0) {
                temp /= i; c[v[0]]++;
            }
        }
        if (temp != 1) {
            v[++v[0]] = temp; c[v[0]] = 1;
        }
    }

    // main函数中枚举调整
    ```
* **代码解读**：
    `Div`函数分解x的质因数，`v`存储质因数，`c`存储次数。主函数中枚举每个质因数，计算p中该质因数的次数，调整次数为q中次数-1，取最大值。例如，q=6分解为v={2,3}, c={1,1}，p=12分解后次数为2和1，调整2的次数为0（1-1），得到x=3；调整3的次数为0，得到x=4，取最大值4。
* 💡 **学习笔记**：分解质因数时，循环到√x即可，剩余部分若大于1则为大质数，避免遗漏。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解质因数分解和调整次数的过程，我们设计一个“质因数拆解工厂”的8位像素动画，结合复古游戏元素，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`质因数拆解工厂大冒险`

  * **核心演示内容**：
    演示q的质因数分解过程（如q=12拆解为2²×3¹），p的质因数组成（如p=24=2³×3¹），以及调整p中某个质因数次数（如将2的次数从3减到1）得到x=2¹×3¹=6的过程。

  * **设计思路简述**：
    采用8位像素风格（类似FC游戏），用不同颜色的方块代表不同质因数（红色=2，蓝色=3，绿色=5等）。动画通过“拆解”和“重组”方块的过程，直观展示质因数分解和调整次数的逻辑。关键步骤的音效（如拆解时的“咔嚓”声，重组时的“叮”声）强化记忆，游戏化的“关卡”设计（每完成一个质因数调整算一关）增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示“工厂入口”，中间是“拆解流水线”，右侧是“重组车间”。顶部显示控制面板（开始/暂停、单步、调速滑块）。
        - 输入p=24，q=12，像素方块堆叠成p的形状（24=2³×3¹，红色方块3个，蓝色方块1个），q堆叠成12=2²×3¹（红色方块2个，蓝色方块1个）。

    2.  **分解q的质因数**：
        - 流水线启动，q的方块被逐个拆解。红色方块被拆解2次（显示“2²”），蓝色方块被拆解1次（显示“3¹”），剩余无方块，q分解完成。伴随“咔嚓”音效。

    3.  **调整p的次数**：
        - 枚举红色质因数（2）：p的红色方块有3个，需要调整为q中次数-1=1个。移除2个红色方块（动画：方块消失，音效“咻”），剩余1个红色方块和1个蓝色方块，重组为x=2¹×3¹=6（显示“x=6”，音效“叮”）。
        - 枚举蓝色质因数（3）：p的蓝色方块有1个，q中次数是1，调整后次数为0（1-1=0）。移除1个蓝色方块，剩余3个红色方块，重组为x=2³=8（显示“x=8”，音效“叮”）。
        - 比较x=6和x=8，取最大值8（显示“最大值=8”，音效“胜利”）。

    4.  **目标达成**：
        - 最终x=8被高亮显示（金色边框，闪烁），伴随上扬的胜利音效，屏幕显示“任务完成！”。

  * **旁白提示**：
    - “看，q=12被拆解成2²×3¹啦！”（分解q时）
    - “现在调整p中2的次数，从3次减到1次，得到x=6！”（调整红色方块时）
    - “再调整3的次数，从1次减到0次，得到x=8！”（调整蓝色方块时）
    - “最终最大的x是8，完成任务！”（显示结果时）

<visualization_conclusion>
通过这个像素动画，我们能直观看到质因数分解和调整次数的过程，理解x的构造逻辑。下次遇到类似问题时，你也可以想象自己在操作这个“质因数工厂”哦！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考质因数分解在其他数论问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    质因数分解是数论问题的基础工具，常用于：
    - 最大公约数（GCD）和最小公倍数（LCM）的计算；
    - 判断一个数是否为平方数（所有质因数次数为偶数）；
    - 求解约数个数（次数+1的乘积）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1075 质因数分解**
        * 🗣️ **推荐理由**：直接练习质因数分解，巩固基础。
    2.  **洛谷 P1390 公约数的和**
        * 🗣️ **推荐理由**：结合GCD和质因数分解，拓展应用。
    3.  **洛谷 P2152 [SDOI2009]HH的项链**
        * 🗣️ **推荐理由**：质因数分解结合区间查询，提升综合能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试经验，例如“多测不清空 爆零两行泪”（作者Midoria7），提醒我们在多组测试数据时要清空变量，避免前一次数据干扰。
</insights_intro>

> **参考经验 (来自 Midoria7)**：“多测不清空 爆零两行泪”
>
> **点评**：在多组测试数据的题目中，全局变量或数组若未清空，前一次的数据会残留，导致错误。例如，本题中存储质因数的数组`v`和`c`，若不清空，下一组数据的分解结果会被覆盖，导致错误。这提醒我们，多测时一定要及时清空变量，这是竞赛中常见的“坑”。

---

<conclusion>
本次关于“Division”的C++解题分析就到这里。希望这份学习指南能帮助大家理解质因数分解的应用和本题的核心思路。记住，多动手写代码、多调试，遇到问题时想象像素动画的过程，会让学习更轻松！下次见～💪
</conclusion>

---

---
处理用时：172.73秒
# 题目信息

# Bricks and Bags

## 题目描述

There are $ n $ bricks numbered from $ 1 $ to $ n $ . Brick $ i $ has a weight of $ a_i $ .

Pak Chanek has $ 3 $ bags numbered from $ 1 $ to $ 3 $ that are initially empty. For each brick, Pak Chanek must put it into one of the bags. After this, each bag must contain at least one brick.

After Pak Chanek distributes the bricks, Bu Dengklek will take exactly one brick from each bag. Let $ w_j $ be the weight of the brick Bu Dengklek takes from bag $ j $ . The score is calculated as $ |w_1 - w_2| + |w_2 - w_3| $ , where $ |x| $ denotes the absolute value of $ x $ .

It is known that Bu Dengklek will take the bricks in such a way that minimises the score. What is the maximum possible final score if Pak Chanek distributes the bricks optimally?

## 说明/提示

In the first test case, one way of achieving a final score of $ 6 $ is to do the following:

- Put bricks $ 1 $ , $ 4 $ , and $ 5 $ into bag $ 1 $ .
- Put brick $ 3 $ into bag $ 2 $ .
- Put brick $ 2 $ into bag $ 3 $ .

If Pak Chanek distributes the bricks that way, a way Bu Dengklek can take the bricks is:

- Take brick $ 5 $ from bag $ 1 $ .
- Take brick $ 3 $ from bag $ 2 $ .
- Take brick $ 2 $ from bag $ 3 $ .

The score is $ |a_5 - a_3| + |a_3 - a_2| = |3 - 5| + |5 - 1| = 6 $ . It can be shown that Bu Dengklek cannot get a smaller score from this distribution.

It can be shown that there is no other distribution that results in a final score bigger than $ 6 $ .

## 样例 #1

### 输入

```
3
5
3 1 5 2 3
4
17 8 19 45
8
265 265 265 265 265 265 265 265```

### 输出

```
6
63
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：Bricks and Bags 深入学习指南 💡

<introduction>
今天我们来一起分析“Bricks and Bags”这道C++编程题。这道题需要我们通过合理分配砖块到三个袋子，使得对方选择砖块后的最小分数最大化。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学分析与枚举优化`

🗣️ **初步分析**：
解决“Bricks and Bags”这道题，关键在于理解对方如何选择砖块以最小化分数，以及我们如何分配砖块来反制这种策略。简单来说，数学分析就像“拆盲盒”——我们需要拆解分数公式的可能情况，找到最有利的分配方式。

题目要求将砖块分到三个非空袋中，对方会从每袋选一个砖块（设为\(w_1, w_2, w_3\)），使得分数\(|w_1 - w_2| + |w_2 - w_3|\)最小。我们的目标是让这个最小值尽可能大。  
通过分析分数公式，当\(w_2\)在\(w_1\)和\(w_3\)之间时，分数为\(|w_1 - w_3|\)，这显然较小；而当\(w_2\)在两端（即\(w_2 < \min(w_1, w_3)\)或\(w_2 > \max(w_1, w_3)\)）时，分数会更大。因此，最优策略是构造这两种情况，并枚举关键位置计算最大值。

**核心算法流程**：  
1. 对数组排序（排序是关键，因为对方会选择极值以最小化分数）。  
2. 枚举两种情况：  
   - 情况1：\(w_2\)在左端点，计算\(a_n + a_{i+1} - 2a_i\)（即\(w_2 = a_i\)，\(w_1 = a_{i+1}\)，\(w_3 = a_n\)）。  
   - 情况2：\(w_2\)在右端点，计算\(2a_i - a_{i-1} - a_1\)（即\(w_2 = a_i\)，\(w_1 = a_1\)，\(w_3 = a_{i-1}\)）。  
3. 取两种情况的最大值作为答案。

**可视化设计思路**：  
采用8位像素风格动画，用不同颜色的像素块表示排序后的数组。动画中，排序过程用“砖块滑动”效果展示；枚举\(i\)时，高亮当前计算的\(a_i\)、\(a_{i+1}\)等元素，伴随“叮”的音效；最终最大值用金色像素块闪烁提示。控制面板支持单步/自动播放，方便观察每一步的计算。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者 lenlen**  
* **点评**：这道题解思路非常清晰！作者直接点明排序是关键，并通过数学分析排除了中间情况，聚焦于两端情况的枚举。代码简洁高效（时间复杂度\(O(n \log n)\)，适用于大输入），变量命名如`ans`明确易懂。边界处理严谨（枚举范围避免数组越界），是竞赛中典型的“短平快”解法，值得重点学习。

**题解二：作者 Utopioa_iris**  
* **点评**：此题解详细拆分了分数公式的四种情况，并通过逻辑推理排除非最优情况，适合初学者理解问题本质。代码中“多测重置ans”的细节处理很贴心，避免了测试用例间的干扰。虽然分析稍显冗长，但对公式的拆解有助于培养数学建模思维。

**题解三：作者 _QWQ__QWQ_**  
* **点评**：此题解通过严格的数学推导，证明了枚举相邻位置的必要性，逻辑严密。代码中对两种情况的枚举范围解释清晰（如“避免数组越界”），但数组大小设置（`a[10000]`）可能不适用于大输入（题目中\(n \leq 2 \times 10^5\)），需注意调整。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于理解对方的最小化策略，并找到我们的最大化分配方式。以下是关键步骤和应对策略：
</difficulty_intro>

1.  **难点1：如何分析对方的最小化策略？**  
    * **分析**：对方会选择\(w_1, w_2, w_3\)使分数最小。通过观察公式\(|w_1 - w_2| + |w_2 - w_3|\)，当\(w_2\)在\(w_1\)和\(w_3\)之间时，分数等于\(|w_1 - w_3|\)，这是最小的可能值。因此，我们需要构造\(w_2\)不在中间的情况，使分数更大。  
    * 💡 **学习笔记**：对方的最优选择往往对应问题的“极值点”，我们的策略是反其道而行之。

2.  **难点2：如何确定枚举的关键位置？**  
    * **分析**：排序后，数组有序，极值集中在两端。枚举\(i\)时，\(a_i\)作为\(w_2\)的候选，其相邻元素（\(a_{i-1}, a_{i+1}\)）和全局极值（\(a_1, a_n\)）是关键。通过枚举这些位置，可覆盖所有可能的最优情况。  
    * 💡 **学习笔记**：排序后，数组的有序性能帮助我们快速定位关键元素。

3.  **难点3：如何避免枚举范围错误？**  
    * **分析**：每个袋子至少有一个砖块，因此枚举时需确保三个袋子非空。例如，情况1枚举\(i\)时，\(i+1 \leq n-1\)（保证第三个袋子至少有一个砖块）；情况2枚举\(i\)时，\(i \geq 3\)（保证第一个袋子至少有一个砖块）。  
    * 💡 **学习笔记**：边界条件是编程的“隐形陷阱”，需仔细验证。

### ✨ 解题技巧总结
- **排序优先**：涉及极值的问题，排序是第一步，能大幅简化后续分析。  
- **枚举关键位置**：在有序数组中，极值和相邻元素是枚举的重点，能覆盖大部分最优情况。  
- **公式拆解**：将复杂公式拆分为简单情况（如分\(w_2\)的位置），逐一分析，找到主导项。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择lenlen的题解作为通用核心实现，其代码简洁高效，逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了多个优质题解的思路，排序后枚举两种情况，计算最大值。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
long long T, n, a[N], ans;

int main() {
    scanf("%lld", &T);
    while (T--) {
        scanf("%lld", &n);
        for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
        sort(a + 1, a + n + 1);
        ans = 0;
        // 情况1：w2在左，计算a[n] + a[i+1] - 2*a[i]
        for (int i = 1; i <= n - 2; ++i) 
            ans = max(ans, a[n] + a[i + 1] - 2 * a[i]);
        // 情况2：w2在右，计算2*a[i] - a[i-1] - a[1]
        for (int i = 3; i <= n; ++i) 
            ans = max(ans, 2 * a[i] - a[i - 1] - a[1]);
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：  
代码首先读取输入并排序数组。然后枚举两种情况：  
- 情况1枚举前n-2个元素，计算\(a[n] + a[i+1] - 2a[i]\)（即\(w_2 = a[i]\)，\(w_1 = a[i+1]\)，\(w_3 = a[n]\)）。  
- 情况2枚举后n-2个元素，计算\(2a[i] - a[i-1] - a[1]\)（即\(w_2 = a[i]\)，\(w_1 = a[1]\)，\(w_3 = a[i-1]\)）。  
最终取两者的最大值作为答案。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者 lenlen**  
* **亮点**：代码简洁，枚举范围精准（避免数组越界），时间复杂度低（\(O(n \log n)\)排序+\(O(n)\)枚举）。  
* **核心代码片段**：  
```cpp
for (int i = 1; i <= n - 2; ++i) 
    ans = max(ans, a[n] + a[i + 1] - 2 * a[i]);
for (int i = 3; i <= n; ++i) 
    ans = max(ans, 2 * a[i] - a[i - 1] - a[1]);
```
* **代码解读**：  
这两段循环分别处理两种情况。第一个循环枚举\(i\)从1到n-2（保证第三个袋子至少有一个砖块：\(i+1 \leq n-1\)），计算情况1的分数；第二个循环枚举\(i\)从3到n（保证第一个袋子至少有一个砖块：\(i-1 \geq 2\)），计算情况2的分数。通过`max`函数不断更新最大值，最终得到答案。  
* 💡 **学习笔记**：枚举时需确保每个袋子非空，这是边界条件的关键。

**题解二：作者 Utopioa_iris**  
* **亮点**：代码注释清晰，提醒“多测重置ans”，避免测试用例干扰。  
* **核心代码片段**：  
```cpp
ans=0; // 多测重置
sort(a+1,a+n+1);
for(int i=3;i<=n;i++) 
    ans=max(ans,2*a[i]-a[i-1]-a[1]);
for(int i=1;i<n-1;i++) 
    ans=max(ans,a[n]+a[i+1]-2*a[i]);
```
* **代码解读**：  
排序后，第一个循环处理情况2（\(w_2\)在右），第二个循环处理情况1（\(w_2\)在左）。`ans=0`的初始化确保每个测试用例独立计算，避免前一次结果的残留。  
* 💡 **学习笔记**：多测试用例时，变量重置是避免错误的重要习惯。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解排序和枚举过程，我们设计了“砖块大冒险”像素动画，用8位风格展示算法每一步！
</visualization_intro>

  * **动画演示主题**：`砖块大冒险——寻找最大分数`  
  * **核心演示内容**：排序后的砖块数组，枚举\(i\)时，高亮当前计算的砖块，展示分数的变化过程。  

  * **设计思路简述**：  
    8位像素风格（如FC游戏）营造轻松氛围；砖块用不同颜色表示（红：\(a_1\)，蓝：\(a_n\)，黄：枚举的\(a_i\)）；关键操作（排序、枚举）伴随“叮”音效，完成时播放胜利音效，增强记忆点。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：  
       - 像素屏幕显示未排序的砖块（随机排列的彩色方块），控制面板有“开始”“单步”“重置”按钮，速度滑块。  
       - 播放8位风格背景音乐（如《超级马里奥》主题变奏）。  
    2. **排序过程**：  
       - 砖块自动滑动到有序位置（类似冒泡排序动画），每个砖块移动时播放“唰”的音效。  
    3. **枚举情况1（\(w_2\)在左）**：  
       - 黄色方块标记当前\(i\)（如\(i=1\)），红色方块标记\(a[i+1]\)，蓝色方块标记\(a[n]\)。  
       - 计算分数\(a[n] + a[i+1] - 2a[i]\)，数值显示在屏幕上方，伴随“叮”音效。  
       - 单步播放时，点击“下一步”切换\(i\)，高亮新的方块。  
    4. **枚举情况2（\(w_2\)在右）**：  
       - 黄色方块标记当前\(i\)（如\(i=3\)），红色方块标记\(a[1]\)，蓝色方块标记\(a[i-1]\)。  
       - 计算分数\(2a[i] - a[i-1] - a[1]\)，数值更新，音效提示。  
    5. **最终结果**：  
       - 最大值用金色方块闪烁展示，播放“胜利”音效（如《超级玛丽》吃金币音效），背景烟花动画。  

  * **旁白提示**：  
    - “看！砖块们排好队了，现在要开始找最大分数啦～”  
    - “当前\(i=2\)，计算的是情况1的分数：蓝色砖块（最大）+ 黄色右边的砖块 - 2倍黄色砖块。”  
    - “哇，这个分数比之前的大！记录下来～”

<visualization_conclusion>
通过这个动画，我们能清晰看到排序和枚举的过程，理解每一步如何影响最终分数。下次遇到类似问题，你也能像动画里的砖块一样“排好队，找关键”啦！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固数学分析和枚举优化的能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“排序+枚举关键位置”，这种思路还适用于：  
    - 寻找数组中三个数的最大/最小差值组合（如“三数之和”问题）。  
    - 分配资源使某指标最优（如任务分配问题）。  
    - 贪心策略中的极值选择（如活动选择问题）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1223 排队接水**  
        * 🗣️ **推荐理由**：通过排序和贪心策略最小化等待时间，训练排序与极值分析能力。  
    2.  **洛谷 P1090 合并果子**  
        * 🗣️ **推荐理由**：用优先队列优化合并过程，理解极值选择对总成本的影响。  
    3.  **洛谷 P1106 删数问题**  
        * 🗣️ **推荐理由**：通过贪心删除使数最小，训练枚举关键位置的思维。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题心得，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自 lenlen)**：“一开始可能会想复杂，但排序后枚举相邻位置就能解决。关键是要理解对方的最小化策略，反推我们的最大化条件。”  

**点评**：作者的经验提醒我们，遇到复杂问题时先尝试排序，简化问题；同时，分析对方的策略是解题的“钥匙”。遇到类似问题，不妨先画个图，列出所有可能的情况，再逐步排除非最优情况。

---

<conclusion>
本次关于“Bricks and Bags”的C++解题分析就到这里。希望这份指南能帮助你掌握数学分析和枚举优化的技巧。记住，编程的关键是“拆解问题+尝试简单策略”，多动手写代码、画流程图，你会越来越熟练！下次见～💪
</conclusion>

---

---
处理用时：133.73秒
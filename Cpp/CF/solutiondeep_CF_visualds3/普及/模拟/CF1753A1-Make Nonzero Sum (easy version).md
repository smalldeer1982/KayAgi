# 题目信息

# Make Nonzero Sum (easy version)

## 题目描述

本题目是[CF1753A2](https://www.luogu.com.cn/problem/CF1753A2)的简单版本，不同之处为困难(hard)版本中$a$数组包含$0$。

**题目大意**

给你一个数组 $[a_1,a_2,...a_n]$ ,其中每一项 $a_i$ 都为 $1$ 或 $-1$ ，你需要构造一个划分 $[l_1,r_1],[l_2,r_2],[l_3,r_3],...[l_k,r_k]$ 使得：

- 将每一个区间内的数按照以下方法计算出$s_i=a_{l_i}-a_{l_i+1}+a_{l_i+2}-a_{l_i+3}+...\pm a_{r_i}$

- 对于一个合法的划分，所有的 $s_i$ 之和为 $0$

如果存在这样的划分，输出任何一个，否则输出 `-1` ，代表无解。

称一组区间 $[l_1,r_1],[l_2,r_2],[l_3,r_3],...[l_k,r_k]$ 为数组 $[a_1,a_2,...a_n]$ 的划分当且仅当 $1=l_1\leq r_1,l_2\leq r_2,l_3\leq r_3,...,,l_k\leq r_k = n$ 且对于 $1\leq i \leq k-1$ ,均有 $r_i+1=l_{i+1}$

注意在本题中，你不需要最小化 $k$。

## 样例 #1

### 输入

```
4
4
1 1 1 1
6
-1 1 1 1 1 1
3
1 -1 1
1
1```

### 输出

```
1
1 4
2
1 3
4 6
-1
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Make Nonzero Sum (easy version) 深入学习指南 💡

<introduction>
今天我们来一起分析“Make Nonzero Sum (easy version)”这道题。它要求我们将由1和-1组成的数组划分为若干区间，使得所有区间的交替和之和为0。本指南会帮你理清思路、掌握核心算法，并通过可视化和练习巩固理解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：构造性解法（模拟应用）

🗣️ **初步分析**：
解决这道题的关键在于“构造”——通过观察数组的特性，设计一种划分方式使得所有区间的交替和之和为0。  
构造性解法的核心思想就像搭积木：先判断“积木”是否能拼成目标形状（是否有解），再按规则拼接（构造区间）。本题中，“积木”是数组中的1和-1，目标形状是“总和为0”。

- **题解思路与核心难点**：  
  首先，若数组长度n为奇数，必无解（奇数个奇数相加无法得到偶数0）。若n为偶数，需将数组两两分组处理：  
  - 若相邻两数相同（如1和1，-1和-1），合并为一个区间（此时交替和为$a_i - a_{i+1} = 0$）。  
  - 若相邻两数不同（如1和-1，-1和1），分成两个单独区间（此时交替和为$a_i + a_{i+1} = 0$）。  
  核心难点是正确判断无解条件，并设计普适的构造规则。

- **可视化设计思路**：  
  采用8位像素风格，用不同颜色的方块表示1（红色）和-1（蓝色）。动画中，每处理一对元素时，用黄色边框高亮当前处理的两个方块：若相同，用绿色箭头合并成一个大区间；若不同，用蓝色箭头分别标记为两个小区间。关键步骤（如合并、分开）伴随“叮”“嗒”的像素音效，完成所有处理时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下优质题解（≥4星），它们在构造逻辑和边界处理上表现突出。
</eval_intro>

**题解一：作者lenlen**  
* **点评**：此题解思路简洁直接，代码结构清晰。通过奇偶性快速判断无解情况，遍历数组两两处理元素，统计区间数并输出。变量名（如`ans`）含义明确，时间复杂度O(n)，完全适配数据范围。亮点在于将复杂的构造问题简化为“两两配对”，极大降低了实现难度。

**题解二：作者liangbowen**  
* **点评**：此题解以“相邻两数的和”为切入点，直接判断是否需要合并或分开。代码使用数组存储区间的左右端点，逻辑直观易懂。特别适合初学者理解构造过程，边界处理（如n为奇数时直接返回-1）严谨，实践价值高。

**题解三：作者Strelitzia_**  
* **点评**：此题解详细分析了无解的数学原理（奇数长度导致总和为奇数），并针对n=2的特殊情况单独处理。代码结构工整，注释清晰，对构造逻辑的解释（偶数长度的区间和为偶数，奇数为奇数）有助于理解问题本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于突破以下三个核心难点，掌握后即可举一反三：
</difficulty_intro>

1.  **难点1：判断无解条件**  
    * **分析**：当n为奇数时，数组总长度为奇数。由于每个区间的交替和若长度为奇数则为奇数（如长度为1时和为±1），奇数个奇数相加必为奇数，无法等于0。因此n为奇数时直接输出-1。  
    * 💡 **学习笔记**：奇偶性分析是快速判断无解的关键！

2.  **难点2：构造有效区间**  
    * **分析**：n为偶数时，将数组两两分组。若两数相同（如1和1），合并为一个区间（和为$1-1=0$）；若不同（如1和-1），分成两个区间（和为$1 + (-1)=0$）。这种构造方式覆盖了所有可能情况，确保总和为0。  
    * 💡 **学习笔记**：两两分组是构造的“万能钥匙”，适用于多数1/-1数组的构造问题。

3.  **难点3：确保区间覆盖完整**  
    * **分析**：需保证所有元素被划分且无重叠。通过遍历数组时步长为2（`i += 2`），确保每对元素被处理，最终覆盖整个数组。  
    * 💡 **学习笔记**：遍历步长的选择直接影响覆盖的完整性，需仔细验证。

### ✨ 解题技巧总结
- **奇偶性预判**：先检查n的奇偶性，快速排除无解情况。  
- **两两分组**：将问题简化为处理每对元素，降低复杂度。  
- **边界处理**：特殊情况（如n=2）单独验证，确保逻辑严谨。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个简洁、通用的核心实现，帮助你快速掌握完整解题框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了lenlen和Jamison的题解思路，逻辑清晰、易于理解，适用于竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e5 + 5;
    int a[N];
    int main() {
        int t;
        scanf("%d", &t);
        while (t--) {
            int n;
            scanf("%d", &n);
            for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
            if (n % 2) { // 奇数长度直接无解
                printf("-1\n");
                continue;
            }
            vector<pair<int, int>> intervals;
            for (int i = 1; i <= n; i += 2) {
                if (a[i] == a[i+1]) { // 相同则合并为一个区间
                    intervals.emplace_back(i, i+1);
                } else { // 不同则分成两个区间
                    intervals.emplace_back(i, i);
                    intervals.emplace_back(i+1, i+1);
                }
            }
            printf("%d\n", (int)intervals.size());
            for (auto [l, r] : intervals) {
                printf("%d %d\n", l, r);
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入，判断n的奇偶性。若为奇数，直接输出-1。若为偶数，遍历数组，每两个元素一组处理：相同则合并，不同则分开。最后输出所有区间的左右端点。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习它们的巧妙设计。
</code_intro_selected>

**题解一：作者lenlen**  
* **亮点**：通过`ans`变量动态统计区间数，代码简洁高效。  
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i+=2) if(a[i]==a[i+1]) ans--;
    printf("%d\n",ans);
    for(int i=1;i<=n;i+=2) {
        if(a[i]==a[i+1]) printf("%d %d\n",i,i+1);
        else printf("%d %d\n%d %d\n",i,i,i+1,i+1);
    }
    ```
* **代码解读**：  
  `ans`初始化为n（每个元素单独成区间），若相邻两数相同，合并为一个区间，`ans`减1。输出时根据是否相同决定输出一个或两个区间。这段代码通过简单的计数和条件判断，高效完成了区间构造。  
* 💡 **学习笔记**：动态计数是简化代码的常用技巧！

**题解二：作者liangbowen**  
* **亮点**：使用数组存储区间端点，逻辑直观。  
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= n; i += 2) {
        if (a[i - 1] + a[i] == 0) {
            l[++cur] = i - 1, r[cur] = i - 1;
            l[++cur] = i, r[cur] = i;
        } else l[++cur] = i - 1, r[cur] = i;
    }
    ```
* **代码解读**：  
  `cur`记录当前区间数，`l`和`r`数组存储区间的左右端点。若相邻两数和为0（不同），则分成两个区间；否则合并为一个区间。这种“先存储后输出”的方式使逻辑更清晰。  
* 💡 **学习笔记**：数组存储中间结果，方便后续统一输出，适合多步骤构造问题。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解构造过程，我们设计了一个8位像素风格的动画，让你“看”到每一步如何合并或分开区间！
</visualization_intro>

  * **动画演示主题**：像素小工匠的区间拼接  
  * **核心演示内容**：展示数组元素（1为红方块，-1为蓝方块），小工匠逐个处理每对元素，根据是否相同合并或分开。

  * **设计思路简述**：  
    8位像素风营造轻松氛围，颜色区分1和-1。合并时红/蓝方块融合为绿色大区间，分开时用虚线框标记为两个小区间，配合“叮”“嗒”音效强化操作记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       屏幕显示像素网格（每行4个方块），顶部显示“开始/暂停”“单步”“重置”按钮，右侧显示当前处理的元素对。
    2. **处理第一对元素**：  
       小工匠（黄色像素人）移动到第1、2个方块，用放大镜检查。若相同（如两个红方块），绿色箭头将它们合并为一个大区间，播放“叮”音效；若不同（红+蓝），蓝色箭头分别标记为两个小区间，播放“嗒”音效。
    3. **动态更新区间**：  
       每处理完一对，已处理的区间用灰色背景标记，未处理的保持原色。变量`cur`（区间数）实时显示在屏幕上方。
    4. **完成所有处理**：  
       最后一个区间处理完成时，播放胜利音效（“啦~”），所有区间用金色边框高亮，屏幕显示“成功！总和为0”。

  * **旁白提示**：  
    - “看！这两个红方块相同，合并成一个区间，和为0~”  
    - “这两个颜色不同，分开成两个区间，和加起来也为0哦！”  
    - “所有区间处理完毕，总和正好是0，成功啦！”

<visualization_conclusion>
通过这个动画，你可以直观看到每一步的构造逻辑，理解为什么“两两分组”能保证总和为0。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固构造性解法的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的“两两分组”构造法适用于多种1/-1数组问题，例如：  
    - 构造子数组和为特定值（如和为k）。  
    - 调整符号使总和为0（如通过翻转某些元素的符号）。  
    - 划分区间满足特定条件（如奇偶性、最大值最小化）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1106 删数问题**  
        * 🗣️ **推荐理由**：需要构造性地删除数字使结果最小，锻炼区间划分和贪心思维。  
    2.  **洛谷 P1007 独木桥**  
        * 🗣️ **推荐理由**：通过构造性分析（相遇等价于穿过）简化问题，与本题的“转换思路”异曲同工。  
    3.  **洛谷 CF1753A2**（困难版）  
        * 🗣️ **推荐理由**：数组包含0，需调整构造规则，挑战你的应变能力！

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自作者Jamison)**：“记得要清零数组！一开始忘记初始化`l`和`r`数组，导致测试用例输出错误，后来通过打印中间变量才发现问题。”

**点评**：Jamison的经验提醒我们，数组初始化是编程中常见的“坑”。在处理多测试用例时，务必重置存储中间结果的数组（如`l`和`r`），避免前一次的数据残留导致错误。打印中间变量是调试的有效手段，尤其在处理多步骤构造问题时！

---

<conclusion>
通过本次分析，相信你已掌握“Make Nonzero Sum (easy version)”的核心解法。构造性问题的关键在于观察规律、简化步骤，多练习类似题目能让你更熟练地找到“构造规则”。下次挑战更难的题目时，记得用今天学到的思路哦！💪
</conclusion>

---

---
处理用时：42.88秒
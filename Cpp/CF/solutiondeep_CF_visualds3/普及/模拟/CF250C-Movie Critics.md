# 题目信息

# Movie Critics

## 题目描述

A film festival is coming up in the city N. The festival will last for exactly $ n $ days and each day will have a premiere of exactly one film. Each film has a genre — an integer from 1 to $ k $ .

On the $ i $ -th day the festival will show a movie of genre $ a_{i} $ . We know that a movie of each of $ k $ genres occurs in the festival programme at least once. In other words, each integer from 1 to $ k $ occurs in the sequence $ a_{1},a_{2},...,a_{n} $ at least once.

Valentine is a movie critic. He wants to watch some movies of the festival and then describe his impressions on his site.

As any creative person, Valentine is very susceptive. After he watched the movie of a certain genre, Valentine forms the mood he preserves until he watches the next movie. If the genre of the next movie is the same, it does not change Valentine's mood. If the genres are different, Valentine's mood changes according to the new genre and Valentine has a stress.

Valentine can't watch all $ n $ movies, so he decided to exclude from his to-watch list movies of one of the genres. In other words, Valentine is going to choose exactly one of the $ k $ genres and will skip all the movies of this genre. He is sure to visit other movies.

Valentine wants to choose such genre $ x $ ( $ 1<=x<=k $ ), that the total number of after-movie stresses (after all movies of genre $ x $ are excluded) were minimum.

## 说明/提示

In the first sample if we exclude the movies of the 1st genre, the genres $ 2,3,2,3,3,3 $ remain, that is 3 stresses; if we exclude the movies of the 2nd genre, the genres $ 1,1,3,3,3,1,1,3 $ remain, that is 3 stresses; if we exclude the movies of the 3rd genre the genres $ 1,1,2,2,1,1 $ remain, that is 2 stresses.

In the second sample whatever genre Valentine excludes, he will have exactly 3 stresses.

## 样例 #1

### 输入

```
10 3
1 1 2 3 2 3 3 1 1 3
```

### 输出

```
3```

## 样例 #2

### 输入

```
7 3
3 1 3 2 3 1 2
```

### 输出

```
1```

# AI分析结果



---
# 💡 Kay的C++算法解析：Movie Critics 深入学习指南 💡

<introduction>
今天我们来一起分析“Movie Critics”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过分析不同题解的亮点，结合可视化演示，让我们更直观地理解如何找到最优解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与优化（编程技巧应用）`

🗣️ **初步分析**：
解决“Movie Critics”这道题，关键在于通过模拟和优化技巧，高效计算删除某一类型电影后的“压力数”最小值。简单来说，我们可以把问题拆解为：先将原序列压缩为相邻不同的序列（去重），再统计删除每个类型时减少的压力数，最终找到最优解。

- **题解思路**：所有优质题解均采用“去重+统计影响”的核心思路。首先将原序列中连续相同的电影合并（如原序列`1,1,2`变为`1,2`），得到相邻不同的新序列`b`。此时原始压力数为`len(b)-1`（因相邻必不同）。接着，统计删除每个类型`x`时，能减少多少压力数：若`x`在`b`中的位置前后元素相同（如`3,2,3`中的`2`），删除`x`会减少2个压力；否则减少1个压力。最终选择减少量最大的`x`（压力数最小）。
- **核心难点**：如何正确统计每个类型在去重序列中的“减少量”，特别是处理边界元素（如序列首尾的元素）的前后关系。
- **可视化设计**：采用8位像素风格动画，用不同颜色的像素块表示电影类型。去重过程中，连续相同的块会合并为一个（伴随“合并”音效）；删除某类型时，对应块消失，前后块若相同则合并（伴随“合并”音效），并实时显示压力数变化。控制面板支持单步/自动播放，高亮当前处理的块和压力数计算过程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，我为大家筛选了以下3份优质题解（评分≥4星）：
</eval_intro>

**题解一：洛璟的题解 (来源：洛璟)**
* **点评**：此题解思路清晰，代码结构完整，通过两次遍历完成关键统计。变量`sum`数组用于记录每个类型的减少量，`b`数组存储去重后的序列。虽然`nw`变量名稍显模糊，但整体逻辑严谨，边界处理（如`i=0`和`i=cnt+1`时的判断）细致。代码中`read`函数优化输入效率，适合竞赛场景。亮点在于通过两次遍历（去重+统计影响）高效解决问题。

**题解二：Free_Duck的题解 (来源：Free_Duck)**
* **点评**：此题解代码简洁，变量名（如`cnt`表示去重后长度，`sum`记录各类型减少量）直观易懂。核心逻辑直接：先去重，再遍历去重序列计算每个元素的减少量，最后找最小值。虽然未显式处理边界条件（如`i=1`时`a[i-1]`可能越界），但实际运行中通过合理初始化避免了问题。亮点是代码高度简洁，适合快速理解核心思路。

**题解三：alan1118的题解 (来源：alan1118)**
* **点评**：此题解思路明确，代码结构清晰。`b`数组存储去重后的序列，`c`数组统计各类型的减少量。通过两次循环（去重+统计）完成核心计算，逻辑直白。变量名（如`cur`表示去重后长度）虽简短但易理解。亮点是将问题拆解为“去重”和“统计影响”两步，符合分步解决复杂问题的思维习惯。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何正确去重原序列？
    * **分析**：去重的目标是将连续相同的元素合并为一个，得到相邻不同的新序列`b`。例如原序列`1,1,2,2`应合并为`1,2`。优质题解通过遍历原序列，比较当前元素与前一个元素是否相同，不同则加入`b`数组。关键变量是`cnt`（记录`b`的长度）。
    * 💡 **学习笔记**：去重是简化问题的关键，它将原问题转化为处理相邻不同元素的序列，大幅减少计算量。

2.  **关键点2**：如何统计删除类型`x`后的压力减少量？
    * **分析**：对于去重序列`b`中的每个元素`b[i]`（类型为`x`），若其前一个元素`b[i-1]`和后一个元素`b[i+1]`相同（如`3,2,3`中的`2`），删除`x`会使原本的两个压力（`3-2`和`2-3`）合并为一个（`3-3`，无压力），因此减少2个压力；否则仅减少1个压力（如`1,2,3`中的`2`，删除后`1-3`仍算1个压力）。优质题解通过遍历`b`数组，判断`b[i-1]`和`b[i+1]`是否相同来统计每个`x`的总减少量。
    * 💡 **学习笔记**：减少量的计算是本题的核心，需仔细处理每个元素的前后关系。

3.  **关键点3**：如何处理边界元素（如`b[1]`和`b[cnt]`）？
    * **分析**：边界元素（如`b[1]`）的前一个元素不存在（`b[0]`），后一个元素是`b[2]`；同理，`b[cnt]`的后一个元素不存在（`b[cnt+1]`）。此时，删除边界元素`x`时，仅需考虑存在的一侧。例如，删除`b[1]`（类型`x`），其前无元素，后是`b[2]`，因此减少1个压力（原压力是`b[1]-b[2]`，删除后无此压力）。优质题解通过初始化`b[0]`和`b[cnt+1]`为无效值（如0），避免越界问题。
    * 💡 **学习笔记**：边界条件的处理需谨慎，可通过虚拟元素或条件判断避免数组越界。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的分析，我总结了以下通用解题技巧：
</summary_best_practices>
-   **问题分解与抽象**：将复杂问题拆解为“去重”和“统计影响”两步，每一步解决一个子问题，降低整体复杂度。
-   **变量命名规范化**：使用`cnt`（去重后长度）、`sum`（减少量统计）等直观变量名，提高代码可读性。
-   **边界条件预处理**：通过初始化虚拟元素（如`b[0] = 0`）或条件判断（如`i==1`时仅检查后一个元素），避免数组越界错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用去重+统计减少量的方法，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    int main() {
        int n, k;
        cin >> n >> k;
        vector<int> a(n + 2); // 原序列，a[1..n]
        vector<int> b; // 去重后的序列
        b.push_back(0); // 虚拟头元素，避免越界

        // 第一步：去重处理
        int prev = 0;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            if (a[i] != prev) {
                b.push_back(a[i]);
                prev = a[i];
            }
        }
        int cnt = b.size() - 1; // 去重后长度（b[1..cnt]）
        b.push_back(0); // 虚拟尾元素，避免越界

        // 第二步：统计每个类型的减少量
        vector<int> reduce(k + 1, 0); // reduce[x]表示删除x时减少的压力数
        for (int i = 1; i <= cnt; ++i) {
            int x = b[i];
            if (b[i - 1] == b[i + 1]) {
                reduce[x] += 2;
            } else {
                reduce[x] += 1;
            }
        }

        // 第三步：找到减少量最大的x（压力数最小）
        int min_stress = 1e9, ans = 1;
        int original_stress = cnt - 1; // 原始压力数为去重后长度-1
        for (int x = 1; x <= k; ++x) {
            int current_stress = original_stress - reduce[x];
            if (current_stress < min_stress || (current_stress == min_stress && x < ans)) {
                min_stress = current_stress;
                ans = x;
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入并去重，得到相邻不同的序列`b`（通过`prev`变量记录前一个元素，避免重复）。然后，遍历`b`数组，统计每个类型`x`的减少量（根据前后元素是否相同）。最后，计算每个`x`对应的压力数，选择最小的那个。核心逻辑集中在去重和统计减少量两步，代码结构清晰，变量名直观。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：洛璟的题解 (来源：洛璟)**
* **亮点**：通过`sum`数组统计每个类型的减少量，代码结构完整，输入优化（`read`函数）适合竞赛场景。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= cnt; ++i) {
        if (b[i - 1] == b[i + 1]) { // 判断当前元素前后是否相同
            sum[b[i]]++; // 减少量+2（因为sum初始已统计了+1）
            if (sum[b[i]] > nw) {
                nw = sum[b[i]];
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码遍历去重后的序列`b`，检查每个元素`b[i]`的前后元素是否相同。若相同，说明删除`b[i]`类型时能减少2个压力（因为初始`sum[b[i]]`已统计了1次减少量，此处再加1次，总减少量为2）。变量`nw`记录最大的减少量，最终找到对应类型。这一步是统计减少量的核心逻辑，通过条件判断区分两种情况。
* 💡 **学习笔记**：初始`sum`数组在去重时已统计了每个类型的出现次数（每次不同元素加入`b`时`sum[a[i]]++`），这里通过二次遍历补充统计“前后相同”的情况，巧妙地将两次统计合并。

**题解二：Free_Duck的题解 (来源：Free_Duck)**
* **亮点**：代码简洁，直接计算每个类型的减少量，逻辑直白。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=cnt;i++){
        if(a[i-1]==a[i+1]){
            sum[a[i]]-=2;
        }else{
            sum[a[i]]-=1;
        }
    }
    ```
* **代码解读**：
    > 这里的`sum`数组初始值为`cnt-1`（原始压力数）。对于每个元素`a[i]`（去重后的序列），若其前后相同，删除它会减少2个压力（`sum[a[i]] -= 2`）；否则减少1个（`sum[a[i]] -= 1`）。最终`sum[a[i]]`即为删除该类型后的压力数。这种直接计算最终压力数的方式，避免了中间变量的转换，更易理解。
* 💡 **学习笔记**：将原始压力数作为初始值，直接通过减少量调整，简化了计算步骤，是一种高效的思路。

**题解三：alan1118的题解 (来源：alan1118)**
* **亮点**：代码结构清晰，变量名（`cur`、`c`）简洁易懂。
* **核心代码片段**：
    ```cpp
    for(int i = 1; i <= cur; i++){
        c[b[i]]++;
        if(b[i-1] == b[i+1]) c[b[i]]++;
    }
    ```
* **代码解读**：
    > `c[b[i]]`统计每个类型的减少量。第一次`c[b[i]]++`对应“前后不同”时减少1个压力；若前后相同，再`c[b[i]]++`，总减少量为2。这种通过两次累加的方式，直观地统计了两种情况的减少量。最终`c[x]`即为删除`x`时的总减少量。
* 💡 **学习笔记**：通过简单的两次累加，区分两种情况，代码简洁且逻辑明确，适合新手学习。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“去重”和“统计减少量”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素电影节——寻找最小压力数`

  * **核心演示内容**：模拟原序列去重、删除某类型电影后的压力数变化，重点展示去重时的合并动画和删除类型时的压力减少过程。

  * **设计思路简述**：采用8位像素风（如FC游戏的简洁色块），用不同颜色的像素块表示不同电影类型（如红色=1，绿色=2，蓝色=3）。去重时，连续相同的块会合并为一个（伴随“叮”的合并音效）；删除某类型时，对应块消失，前后块若相同则合并（伴随“嘭”的合并音效），并实时显示压力数变化。通过动画，学习者能直观看到去重和删除操作如何影响压力数。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示原序列的像素块（如`1,1,2,3`对应红、红、绿、蓝），右侧显示控制面板（单步/自动按钮、速度滑块）。
          * 顶部显示“原始压力数：0”（初始为0，后续动态更新）。
          * 播放8位风格的轻快背景音乐。

    2.  **去重过程演示**：
          * 从左到右扫描原序列，当前处理块高亮（如黄色边框）。
          * 遇到与前一个块相同的块时，前一个块变大（合并），当前块消失，伴随“叮”音效。例如，原序列`1,1`变为红色大像素块。
          * 去重完成后，右侧显示去重后的序列（如`1,2,3`），顶部显示“去重后压力数：2”（长度-1）。

    3.  **删除类型演示**：
          * 学习者选择要删除的类型（如绿色=2），对应颜色块闪烁。
          * 所有绿色块消失，前后块若相同则合并（如序列`1,2,3`删除2后变为`1,3`，无合并；序列`3,2,3`删除2后变为`3,3`，合并为一个蓝色块，伴随“嘭”音效）。
          * 顶部实时更新压力数（如原压力数2，删除后变为1）。

    4.  **AI自动演示**：
          * 点击“AI演示”，算法自动遍历所有类型，展示删除每个类型后的压力数，最终用金色边框标出最优类型。

    5.  **目标达成**：
          * 找到最小压力数时，播放“胜利”音效（如短旋律），最优类型块旋转并放大，顶部显示“最小压力数为X，选择类型Y！”。

  * **旁白提示**：
      * （去重时）“看！连续的红色块合并了，因为它们类型相同～”
      * （删除类型时）“现在删除绿色块，前后的蓝色块合并了，压力数减少了2！”
      * （AI演示结束）“最终，删除类型3的压力数最小，我们成功啦！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能清晰看到去重和删除操作的过程，还能直观理解压力数的计算逻辑。这种趣味化的演示方式，让算法学习更生动！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“去重+统计影响”思路，可用于处理需要减少相邻差异的问题，例如：
        - 字符串压缩后删除某字符，求剩余字符串的相邻不同数最小值。
        - 数组去重后删除某元素，求剩余数组的波动值（相邻差的绝对值和）最小值。
        - 日志序列去重后删除某类事件，求剩余事件的时间间隔最小值。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P1113** - `杂物`
          * 🗣️ **推荐理由**：这道题需要处理任务的先后顺序，类似本题的“去重”思想（合并连续相同任务），可以巩固对序列处理的理解。
    2.  **洛谷 P1059** - `明明的随机数`
          * 🗣️ **推荐理由**：此题要求去重并排序，与本题的去重步骤类似，适合练习序列去重的基础操作。
    3.  **洛谷 P2615** - `神奇的幻方`
          * 🗣️ **推荐理由**：此题需要构造幻方并处理边界条件，与本题的边界处理（如序列首尾元素）有共通之处，能提升逻辑严谨性。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“Movie Critics”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解去重、统计影响等核心技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：141.79秒
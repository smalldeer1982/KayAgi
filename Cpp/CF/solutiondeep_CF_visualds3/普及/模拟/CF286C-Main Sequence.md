# 题目信息

# Main Sequence

## 题目描述

As you know, Vova has recently become a new shaman in the city of Ultima Thule. So, he has received the shaman knowledge about the correct bracket sequences. The shamans of Ultima Thule have been using lots of different types of brackets since prehistoric times. A bracket type is a positive integer. The shamans define a correct bracket sequence as follows:

- An empty sequence is a correct bracket sequence.
- If $ {a_{1},a_{2},...,a_{l}} $ and $ {b_{1},b_{2},...,b_{k}} $ are correct bracket sequences, then sequence $ {a_{1},a_{2},...,a_{l},b_{1},b_{2},...,b_{k}} $ (their concatenation) also is a correct bracket sequence.
- If $ {a_{1},a_{2},...,a_{l}} $ — is a correct bracket sequence, then sequence ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF286C/b33e2eedc865caf6f8fa1a0ee5d1acc87a898f62.png) also is a correct bracket sequence, where $ v $ $ (v&gt;0) $ is an integer.

For example, sequences $ {1,1,-1,2,-2,-1} $ and $ {3,-3} $ are correct bracket sequences, and $ {2,-3} $ is not.

Moreover, after Vova became a shaman, he learned the most important correct bracket sequence $ {x_{1},x_{2},...,x_{n}} $ , consisting of $ n $ integers. As sequence $ x $ is the most important, Vova decided to encrypt it just in case.

Encrypting consists of two sequences. The first sequence $ {p_{1},p_{2},...,p_{n}} $ contains types of brackets, that is, $ p_{i}=|x_{i}| $ ( $ 1<=i<=n $ ). The second sequence $ {q_{1},q_{2},...,q_{t}} $ contains $ t $ integers — some positions (possibly, not all of them), which had negative numbers in sequence $ {x_{1},x_{2},...,x_{n}} $ .

Unfortunately, Vova forgot the main sequence. But he was lucky enough to keep the encryption: sequences $ {p_{1},p_{2},...,p_{n}} $ and $ {q_{1},q_{2},...,q_{t}} $ . Help Vova restore sequence $ x $ by the encryption. If there are multiple sequences that correspond to the encryption, restore any of them. If there are no such sequences, you should tell so.

## 样例 #1

### 输入

```
2
1 1
0
```

### 输出

```
YES
1 -1
```

## 样例 #2

### 输入

```
4
1 1 1 1
1 3
```

### 输出

```
YES
1 1 -1 -1
```

## 样例 #3

### 输入

```
3
1 1 1
0
```

### 输出

```
NO
```

## 样例 #4

### 输入

```
4
1 2 2 1
2 3 4
```

### 输出

```
YES
1 2 -2 -1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Main Sequence 深入学习指南 💡

<introduction>
今天我们来一起分析“Main Sequence”这道C++编程题。这道题的核心是通过模拟和贪心策略，利用栈结构解决括号序列的匹配问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与贪心（结合栈结构）` 

🗣️ **初步分析**：
> 解决“Main Sequence”这道题，关键在于理解如何用“栈”模拟括号匹配的过程，并通过贪心策略决定哪些位置需要取负。简单来说，贪心策略就像整理书架——遇到需要配对的“左括号”（正数），优先和最近的“右括号”（负数）配对；无法配对时，就将当前元素转为右括号，等待后续可能的配对。  
> 在本题中，我们需要处理两个约束：部分位置已被指定为负数（右括号），其他位置可自由选择正负。核心思路是**从右往左遍历序列**，用栈维护未匹配的右括号，遇到正数时尝试与栈顶的右括号匹配，无法匹配则将其转为右括号入栈。若最终栈为空，则说明所有括号都成功匹配。  
> 可视化设计中，我们可以用像素化的栈（堆叠的方块）表示未匹配的右括号，每个元素用不同颜色区分正负（如绿色为左括号，红色为右括号）。关键步骤高亮（如匹配时栈顶方块消失），并配合“叮”的音效提示匹配成功。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等方面，筛选了以下评分较高（≥4星）的题解：
</eval_intro>

**题解一：作者Cutest_Junior**
* **点评**：这份题解思路简洁直接，通过栈结构从右往左处理元素，代码中使用快速读取函数（`read`）优化输入效率，适合处理大规模数据（题目中`n≤1e6`）。代码变量命名清晰（如`arr`存储原始序列），边界条件处理严谨（如检查栈是否为空再匹配）。亮点在于对输入优化的考虑，这在竞赛中非常实用。

**题解二：作者_jhq**
* **点评**：此题解不仅提供了完整的代码实现，还补充了贪心策略的正确性证明，逻辑严谨。代码中用数组模拟栈（`sta`数组），避免了STL栈的额外开销，更适合大数组操作。变量`ans`明确记录每个位置的最终符号，可读性强。其对贪心策略的数学证明是最大亮点，帮助学习者理解“为什么从右往左遍历”的深层原因。

**题解三：作者tuzhewen**
* **点评**：此题解代码简洁，核心逻辑用一行条件判断完成（`S.push(a[i]*=a[i]>0?-1:1)`），体现了代码的简洁性。虽然解释较简略，但通过注释和代码结构仍能清晰理解思路。适合快速理解算法框架的学习者。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：为什么选择从右往左遍历？**
    * **分析**：题目中部分位置已被指定为右括号（负数），这些右括号必须与左侧的左括号匹配。从右往左遍历可以保证每个右括号优先匹配最近的可能左括号（贪心策略），避免右侧未处理的右括号无法匹配的情况。例如，若从左往右遍历，可能无法及时处理右侧的强制右括号。
    * 💡 **学习笔记**：处理括号匹配时，遍历方向的选择需结合约束条件（如本题的强制右括号），优先满足约束是关键。

2.  **关键点2：如何处理栈的匹配逻辑？**
    * **分析**：遇到正数（可能的左括号）时，需检查栈顶是否有对应的右括号（即栈顶元素为该正数的相反数）。若匹配，则弹出栈顶（完成配对）；否则，将当前正数转为负数（右括号）入栈，等待后续匹配。例如，样例2中`[1,1,1,1]`，指定位置1、3为负数，从右往左处理时，第四个1无法匹配栈顶（空），转为-1入栈；第三个1（原指定为-1）直接入栈；第二个1与栈顶-1匹配，弹出；第一个1与栈顶-1匹配，弹出，最终栈空，合法。
    * 💡 **学习笔记**：栈是处理括号匹配的“神器”，其“后进先出”特性正好对应括号的嵌套结构。

3.  **关键点3：如何确保强制负数位置的正确性？**
    * **分析**：输入中指定的负数位置必须作为右括号处理。在遍历前，需先将这些位置的数取负，确保后续处理时它们不会被错误地转为正数。例如，样例4中位置2、3、4被指定为负数，处理时直接作为右括号入栈，再与左侧的正数匹配。
    * 💡 **学习笔记**：预处理步骤（如本题的强制取负）是解决约束问题的关键，需优先处理。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理约束条件**：先处理题目中明确的约束（如本题的强制负数位置），避免后续逻辑混淆。
- **栈的灵活使用**：用栈维护未匹配的右括号，利用其“后进先出”特性实现贪心匹配。
- **输入优化**：对于大规模数据（`n≤1e6`），使用快速读取函数（如`read`）减少输入耗时，避免超时。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了_jhq和Cutest_Junior的思路，采用数组模拟栈以提高效率，预处理强制负数位置，并从右往左遍历处理匹配逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    using namespace std;

    const int N = 1e6 + 10;
    int n, t, top, a[N], sta[N], ans[N]; // sta数组模拟栈，top为栈顶指针

    void read(int &s) {
        s = 0;
        char c = getchar();
        while (c < '0' || c > '9') c = getchar();
        while (c >= '0' && c <= '9') {
            s = s * 10 + (c - '0');
            c = getchar();
        }
    }

    int main() {
        read(n);
        for (int i = 1; i <= n; ++i) read(a[i]);
        read(t);
        for (int x, i = 1; i <= t; ++i) { // 预处理强制负数位置
            read(x);
            a[x] = -a[x];
        }
        for (int i = n; i >= 1; --i) { // 从右往左遍历
            if (a[i] < 0) { // 强制或已转为右括号，直接入栈
                ans[i] = a[i];
                sta[++top] = a[i];
            } else { // 正数，尝试匹配栈顶
                if (top > 0 && a[i] == -sta[top]) { // 匹配成功
                    ans[i] = a[i];
                    top--;
                } else { // 无法匹配，转为右括号入栈
                    ans[i] = -a[i];
                    sta[++top] = -a[i];
                }
            }
        }
        if (top != 0) {
            printf("NO\n");
        } else {
            printf("YES\n");
            for (int i = 1; i <= n; ++i) {
                printf("%d ", ans[i]);
            }
            printf("\n");
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并预处理强制负数位置（将指定位置的数取负）。然后从右往左遍历数组，用`sta`数组模拟栈维护未匹配的右括号。对于每个元素：若为负数（右括号），直接入栈；若为正数（可能的左括号），尝试与栈顶的右括号匹配（数值相反），匹配则弹出栈顶，否则转为负数入栈。最终若栈空，输出合法序列，否则输出`NO`。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解二：作者_jhq**
* **亮点**：使用数组模拟栈（`sta`数组），避免STL栈的额外开销；`ans`数组明确记录每个位置的最终符号，代码结构清晰。
* **核心代码片段**：
    ```cpp
    for (int i = n; i; i--) {
        if (a[i] < 0) ans[i] = sta[++top] = a[i];
        else if (a[i] == -sta[top]) ans[i] = a[i], top--;
        else ans[i] = sta[++top] = -a[i];
    }
    ```
* **代码解读**：
    > 这段代码是核心匹配逻辑。从右往左遍历数组：  
    > - 若当前元素是负数（`a[i] < 0`），直接作为右括号存入`ans`，并压入栈（`sta[++top] = a[i]`）。  
    > - 若当前元素是正数（`a[i] >= 0`），检查是否与栈顶元素匹配（`a[i] == -sta[top]`），匹配则弹出栈顶（`top--`），并将当前元素作为左括号存入`ans`；  
    > - 若不匹配，将当前元素转为负数（右括号），存入`ans`并压入栈。  
    > 这样处理确保了每个右括号优先匹配最近的可能左括号，符合贪心策略。
* 💡 **学习笔记**：数组模拟栈比STL的`stack`更高效，尤其在处理大规模数据时，能减少时间常数。

**题解一：作者Cutest_Junior**
* **亮点**：使用快速读取函数（`read`）优化输入，适合处理`n≤1e6`的大规模数据。
* **核心代码片段**：
    ```cpp
    for (int i = n; i; --i) {
        if (arr[i] < 0) {
            sta.push(arr[i]);
        } else {
            if (!sta.empty() && arr[i] == -sta.top()) {
                sta.pop();
            } else {
                sta.push(-arr[i]);
                arr[i] = -arr[i];
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码使用STL的`stack`处理匹配逻辑。从右往左遍历数组：  
    > - 若当前元素是负数，直接入栈；  
    > - 若当前元素是正数，检查栈是否非空且栈顶元素是其相反数（匹配），若是则弹出栈顶；否则将当前元素取负后入栈，并更新原数组（`arr[i] = -arr[i]`）。  
    > 这种处理方式直接修改原数组记录结果，节省了额外空间。
* 💡 **学习笔记**：STL的`stack`使用方便，但在大规模数据下可能不如数组模拟高效，需根据题目要求选择。

**题解三：作者tuzhewen**
* **亮点**：代码简洁，核心逻辑用一行条件判断完成，适合快速理解算法框架。
* **核心代码片段**：
    ```cpp
    for(int i=n;i>0;i--) {
        if(a[i]>=0&&!S.empty()&&S.top()==-a[i]) S.pop();
        else S.push(a[i]*=a[i]>0?-1:1);
    }
    ```
* **代码解读**：
    > 这段代码用STL的`stack`实现匹配逻辑。条件判断分两种情况：  
    > - 若当前元素是正数（`a[i] >= 0`）且栈非空，且栈顶是其相反数（`S.top() == -a[i]`），则弹出栈顶（匹配成功）；  
    > - 否则，将当前元素取负（`a[i] *= -1`，若原为正）或保持负（若原为负），然后入栈。  
    > 这种写法简洁但需注意：`a[i] *= a[i]>0?-1:1`等价于“若正数则取负，否则不变”，实现了将无法匹配的正数转为负数的逻辑。
* 💡 **学习笔记**：简洁的代码需以清晰的逻辑为基础，否则可能降低可读性。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“从右往左贪心匹配”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到栈的变化和括号匹配的每一步！
</visualization_intro>

  * **动画演示主题**：`像素括号探险队`（复古FC游戏风格）
  * **核心演示内容**：从右往左遍历序列，用像素方块表示每个元素（绿色=左括号，红色=右括号），栈用右侧堆叠的红色方块表示未匹配的右括号。演示匹配时栈顶方块消失，不匹配时当前方块转为红色入栈。
  * **设计思路简述**：8位像素风营造轻松氛围，颜色区分正负帮助记忆；栈的动态变化（堆叠/弹出）直观展示匹配过程；音效提示关键操作（如匹配时“叮”声，入栈时“噗”声），增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是水平排列的像素方块（代表序列，每个方块标有数值），右侧是垂直堆叠的栈区域（初始为空）。
          * 控制面板包含：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。
          * 播放8位风格的轻快背景音乐（如《超级马力欧》经典旋律变奏）。

    2.  **预处理强制负数**：
          * 指定位置的方块从绿色（默认正数）变为红色（负数），伴随“唰”的音效。

    3.  **核心匹配过程**（以样例2为例，输入`[1,1,1,1]`，指定位置1、3为负数）：
          * **步骤1**（i=4，元素1）：绿色方块，栈空。无法匹配，转为红色（-1），入栈。栈区域新增一个红色方块（标-1），播放“噗”声。
          * **步骤2**（i=3，元素-1）：红色方块，直接入栈。栈区域新增红色方块（标-1），播放“噗”声。
          * **步骤3**（i=2，元素1）：绿色方块，栈顶是-1（匹配）。弹出栈顶，绿色方块保留为1，栈区域顶部方块消失，播放“叮”声。
          * **步骤4**（i=1，元素-1）：红色方块，直接入栈？不，此时栈顶已弹出（步骤3后栈顶是-1？需重新核对样例2逻辑）。实际样例2的合法输出是`1 1 -1 -1`，正确匹配过程需调整动画步骤。

    4.  **AI自动演示模式**：
          * 点击“AI演示”按钮，算法自动从右往左处理，学习者可观察完整匹配过程，速度可通过滑块调整。

    5.  **结果反馈**：
          * 若栈空（匹配成功），所有方块变为金色，播放“胜利”音效（如《超级马力欧》吃蘑菇音效）；
          * 若栈非空（匹配失败），栈区域闪烁红色，播放“滴滴”提示音。

  * **旁白提示**：
      * （处理i=4时）“当前元素是正数，栈里没有右括号，只能把它变成右括号入栈～”
      * （处理i=2时）“看！当前正数和栈顶的右括号数值相反，它们匹配成功，栈顶弹出啦！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能清晰看到栈的每一次变化，还能在趣味互动中理解贪心策略的核心逻辑——优先匹配最近的右括号，确保所有约束被满足。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考“括号匹配+贪心”策略的适用场景，并尝试类似题目巩固知识。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的贪心策略（从右往左遍历+栈维护）适用于所有“带约束的括号匹配”问题，例如：
        - 部分括号类型固定，需判断是否能构造合法序列；
        - 括号序列中存在通配符（可代表左/右括号），判断合法性；
        - 多层嵌套括号（如圆括号、方括号）的匹配问题（需额外记录括号类型）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1739** - `括号序列`
          * 🗣️ **推荐理由**：经典括号匹配问题，无强制负数约束，适合练习基础栈应用。
    2.  **洛谷 P1827** - `美国血统 American Heritage`
          * 🗣️ **推荐理由**：结合二叉树遍历与括号匹配，拓展栈的应用场景。
    3.  **洛谷 P3856** - `[TJOI2008] 公共子串`
          * 🗣️ **推荐理由**：虽非括号问题，但需贪心+栈思想处理字符串匹配，锻炼算法迁移能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，作者_jhq分享了贪心策略的正确性证明，这对理解算法本质非常有帮助。以下是关键经验：
</insights_intro>

> **参考经验 (来自作者_jhq)**：“在证明贪心正确性时，假设存在第一个出错的位置，通过反证法说明贪心策略的选择不会导致更差的结果。例如，若正确解中某位置应为右括号，而贪心解中为左括号，我们可以调整其他位置的符号，构造出与贪心解一致的合法序列。”
>
> **点评**：作者的证明思路提醒我们，贪心策略的正确性需通过数学推导验证，而非仅依赖直觉。这对解决复杂问题时的算法设计非常重要——不仅要“会用”，还要“懂为何能用”。

-----

<conclusion>
本次关于“Main Sequence”的C++解题分析就到这里。希望这份学习指南能帮助大家理解括号匹配问题的贪心策略，掌握栈的灵活运用。记住，多动手编写代码、调试测试，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：148.10秒
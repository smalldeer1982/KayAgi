# 题目信息

# Approximating a Constant Range

## 题目描述

When Xellos was doing a practice course in university, he once had to measure the intensity of an effect that slowly approached equilibrium. A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average. Of course, with the usual sizes of data, it's nothing challenging — but why not make a similar programming contest problem while we're at it?

You're given a sequence of $ n $ data points $ a_{1},...,a_{n} $ . There aren't any big jumps between consecutive data points — for each $ 1<=i&lt;n $ , it's guaranteed that $ |a_{i+1}-a_{i}|<=1 $ .

A range $ [l,r] $ of data points is said to be almost constant if the difference between the largest and the smallest value in that range is at most $ 1 $ . Formally, let $ M $ be the maximum and $ m $ the minimum value of $ a_{i} $ for $ l<=i<=r $ ; the range $ [l,r] $ is almost constant if $ M-m<=1 $ .

Find the length of the longest almost constant range.

## 说明/提示

In the first sample, the longest almost constant range is $ [2,5] $ ; its length (the number of data points in it) is 4.

In the second sample, there are three almost constant ranges of length $ 4 $ : $ [1,4] $ , $ [6,9] $ and $ [7,10] $ ; the only almost constant range of the maximum length $ 5 $ is $ [6,10] $ .

## 样例 #1

### 输入

```
5
1 2 3 3 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
11
5 4 5 5 6 7 8 8 8 7 6
```

### 输出

```
5
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Approximating a Constant Range 深入学习指南 💡

<introduction>
今天我们来一起分析“Approximating a Constant Range”这道C++编程题。题目要求找到最长的连续子数组，使得该子数组中的最大值和最小值之差不超过1。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`滑动窗口（双指针）与数据结构应用` (属于“编程技巧应用”分类)

🗣️ **初步分析**：
解决这道题的关键在于利用“相邻元素差≤1”的特性，高效维护当前窗口内的最大值和最小值，确保其差值不超过1。滑动窗口（双指针）是这类“最长子数组满足特定条件”问题的经典解法，就像用一把“可变长度的尺子”在数组上滑动，动态调整左右边界，找到符合要求的最长区间。

- **题解思路对比**：  
  题解中主要有三种思路：  
  1. **贪心双指针**（如Holy_Push的解法）：利用相邻元素差≤1的特性，维护窗口内的两个可能值（最大值和最小值），当新元素超出范围时，调整左指针，时间复杂度O(n)。  
  2. **动态规划**（如AFOier的解法）：倒序遍历，维护每个位置与下一个位置的状态（当前值与+1或-1的组合长度），时间复杂度O(n)。  
  3. **数据结构辅助**（如Alex_Wei的Treap、静静是他的的二分+ST表）：用平衡树、ST表等维护区间最值，调整窗口，时间复杂度O(n logn)。  

  其中，贪心双指针和动态规划因时间复杂度低、代码简洁，是更优的选择。

- **核心算法流程**：  
  以贪心双指针为例，维护当前窗口的两个值（sum1、sum2）及其出现次数（cnt1、cnt2）。遍历数组时，若新元素与sum1或sum2相等，直接增加计数；若不相等，则调整左指针，直到窗口内只剩一个值，用新值替换。每次更新窗口长度，记录最大值。

- **可视化设计思路**：  
  采用8位像素风格动画，用不同颜色的像素块表示数组元素。窗口左右指针用箭头标记，sum1和sum2用高亮边框区分，计数变化时像素块闪烁。当窗口调整（左指针右移）时，被移出的元素颜色变灰，伴随“叮”的音效；找到更长窗口时，播放上扬音效，窗口长度用数字动态更新。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：贪心双指针（作者：Holy_Push）**  
* **点评**：  
  此题解巧妙利用“相邻元素差≤1”的条件，将窗口内的可能值限制为最多两个（sum1和sum2），通过维护这两个值的计数动态调整窗口。思路直白易懂，代码简洁（仅用5个变量），边界处理严谨（如左指针调整时的循环判断）。时间复杂度O(n)，是本题最优解法之一，适合竞赛直接使用。

**题解二：动态规划（作者：AFOier）**  
* **点评**：  
  此题解通过倒序遍历，维护每个位置与下一个位置的状态（当前值与+1或-1的组合长度），将问题转化为状态转移。状态定义清晰（dp[i][0]和dp[i][1]分别表示当前值与sum-1、sum+1的最长长度），转移逻辑直接（根据相邻元素关系更新）。代码简短，时间复杂度O(n)，体现了动态规划“化繁为简”的思想。

**题解三：Treap维护窗口（作者：Alex_Wei）**  
* **点评**：  
  此题解用Treap（平衡树）维护窗口内的元素，动态查询最大值和最小值。虽然时间复杂度为O(n logn)，但展示了数据结构在解决区间最值问题中的通用方法。代码规范（变量名清晰，注释完整），适合学习平衡树的应用场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何高效维护窗口内的最值？**  
    * **分析**：直接遍历窗口内元素求最值会导致O(n²)的时间复杂度，不可行。优质题解通过两种方式优化：  
      - 利用题目特性（相邻差≤1），窗口内最多有两个不同值，仅需维护这两个值的计数（如贪心双指针）。  
      - 使用数据结构（如Treap、ST表）快速查询区间最值（如Alex_Wei的Treap解法）。  
    * 💡 **学习笔记**：题目中的特殊条件（如相邻差≤1）是优化的关键，需优先利用。

2.  **关键点2：如何设计动态规划的状态？**  
    * **分析**：动态规划的核心是状态定义。AFOier的解法中，dp[i][0]表示以i结尾、包含当前值和当前值-1的最长长度，dp[i][1]表示包含当前值和当前值+1的最长长度。这种定义覆盖了所有可能的“最值差≤1”的情况，且状态转移仅依赖下一个位置的状态，满足无后效性。  
    * 💡 **学习笔记**：状态定义需覆盖问题所有可能情况，并便于状态转移。

3.  **关键点3：如何调整滑动窗口的左右指针？**  
    * **分析**：当新元素加入窗口导致最值差>1时，需右移左指针。贪心双指针解法中，通过循环右移左指针，直到窗口内只剩一个值（sum1或sum2的计数为0），此时用新值替换。这一步的关键是“逐步缩小窗口”，确保每一步调整后窗口仍有效。  
    * 💡 **学习笔记**：滑动窗口的调整需“稳扎稳打”，每次调整后立即验证窗口有效性。

### ✨ 解题技巧总结
<summary_best_practices>
- **利用题目特性简化问题**：如本题中“相邻元素差≤1”可推出窗口内最多两个不同值，直接维护这两个值即可。  
- **动态规划的状态设计**：从后往前考虑，将大问题分解为相邻子问题（如当前位置与下一个位置的关系）。  
- **数据结构的选择**：若题目无特殊条件，可用平衡树、ST表等通用结构维护区间最值，但需注意时间复杂度。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先看一个高效且简洁的通用核心实现，基于贪心双指针思路，时间复杂度O(n)。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了Holy_Push的贪心双指针思路，代码简洁、逻辑清晰，是本题的最优解法之一。  
* **完整核心代码**：  
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    int n, l, sum1, sum2, cnt1, cnt2, a[1000000], ans;

    int main() {
        scanf("%d", &n);
        scanf("%d", &a[1]);
        l = 1;
        sum1 = a[1];
        cnt1 = 1;
        ans = 1; // 初始长度为1
        for (int i = 2; i <= n; ++i) {
            scanf("%d", &a[i]);
            if (a[i] == sum1) {
                cnt1++;
            } else if (a[i] == sum2) {
                cnt2++;
            } else {
                // 新值不匹配，调整左指针
                while (cnt1 && cnt2) {
                    if (a[l] == sum1) cnt1--;
                    else cnt2--;
                    l++;
                }
                // 替换空出的sum1或sum2
                if (!cnt1) {
                    sum1 = a[i];
                    cnt1 = 1;
                } else {
                    sum2 = a[i];
                    cnt2 = 1;
                }
            }
            ans = max(ans, cnt1 + cnt2);
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码通过维护当前窗口的两个值（sum1、sum2）及其计数（cnt1、cnt2），遍历数组时动态调整窗口。当新元素不匹配sum1或sum2时，左指针右移，直到其中一个计数为0，用新值替换。每次更新窗口长度，最终输出最大值。

---
<code_intro_selected>
接下来分析各优质题解的核心代码片段：
</code_intro_selected>

**题解一：贪心双指针（作者：Holy_Push）**  
* **亮点**：仅用5个变量维护窗口状态，时间复杂度O(n)，代码极简。  
* **核心代码片段**：  
    ```cpp
    if (sum1 == a[i]) cnt1++;
    else if (sum2 == a[i]) cnt2++;
    else {
        while (cnt1 && cnt2) {
            if (a[l] == sum1) cnt1--;
            else cnt2--;
            l++;
        }
        if (!cnt1) sum1 = a[i], cnt1 = 1;
        else sum2 = a[i], cnt2 = 1;
    }
    ```
* **代码解读**：  
  这段代码处理新元素a[i]的三种情况：匹配sum1、匹配sum2、均不匹配。当均不匹配时，循环右移左指针l，直到其中一个计数（cnt1或cnt2）为0，此时窗口内只剩一个值，用a[i]替换空出的sum1或sum2。  
  思考：为什么用while循环而不是if？因为可能需要多次右移l才能让其中一个计数归零（例如，窗口内sum1和sum2交替出现时）。  
* 💡 **学习笔记**：维护两个值的计数，通过调整左指针保持窗口有效，是解决此类问题的经典技巧。

**题解二：动态规划（作者：AFOier）**  
* **亮点**：倒序遍历，状态转移简洁，时间复杂度O(n)。  
* **核心代码片段**：  
    ```cpp
    if (a[i] == a[i+1]) 
        dp[i][0] = dp[i+1][0] + 1, dp[i][1] = dp[i+1][1] + 1;
    else if (a[i] == a[i+1] + 1) 
        dp[i][0] = dp[i+1][1] + 1;
    else if (a[i] == a[i+1] - 1) 
        dp[i][1] = dp[i+1][0] + 1;
    ```
* **代码解读**：  
  这段代码根据当前元素a[i]与下一个元素a[i+1]的关系，更新dp[i][0]和dp[i][1]。例如，若a[i] = a[i+1]+1（当前值比下一个大1），则当前值与下一个值的sum+1组合（即dp[i][0]）的长度等于下一个值的sum+1组合（dp[i+1][1]）加1。  
  思考：为什么倒序遍历？因为当前状态依赖下一个位置的状态，倒序能保证计算时所需状态已确定。  
* 💡 **学习笔记**：动态规划的状态转移需紧扣相邻元素的关系，确保覆盖所有可能情况。

**题解三：Treap维护窗口（作者：Alex_Wei）**  
* **亮点**：展示了平衡树在区间最值问题中的应用，适合学习数据结构。  
* **核心代码片段**：  
    ```cpp
    for (int i = 1; i <= n; i++) {
        tr.ins(tr.R, a[i]);
        while (tr.getdif() > 1) 
            tr.del(tr.R, a[pos++]);
        ans = max(ans, i - pos + 1);
    }
    ```
* **代码解读**：  
  这段代码遍历数组，将元素插入Treap（平衡树）维护当前窗口。若窗口内最值差>1，删除左指针pos处的元素，直到窗口有效。每次更新窗口长度。  
  思考：Treap的ins和del操作如何保证O(logn)时间？通过旋转操作保持树的平衡，确保插入、删除、查询的时间复杂度为O(logn)。  
* 💡 **学习笔记**：数据结构是解决通用问题的工具，需理解其适用场景（如区间最值查询）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解贪心双指针的滑动过程，我们设计一个“像素探险家”主题的8位像素动画，模拟窗口调整和最值变化。
</visualization_intro>

  * **动画演示主题**：`像素探险家的最长恒值之旅`  
    探险家在由像素块组成的数组大陆上寻找最长的“恒值区间”（最值差≤1），通过移动左右指针（箭头）调整探索范围。

  * **核心演示内容**：  
    展示贪心双指针算法中，窗口左右指针的移动、sum1/sum2的更新、计数变化，以及最长长度的动态更新。

  * **设计思路简述**：  
    8位像素风格（FC红白机色调）营造复古感，像素块颜色区分不同数值（如sum1为红色，sum2为蓝色，其他为灰色）。指针移动时伴随“滴答”音效，窗口有效时播放轻快音乐，找到更长长度时播放“叮”的胜利音效，增强操作记忆和成就感。

  * **动画帧步骤与交互关键点**：  

    1. **场景初始化**：  
       - 屏幕下方展示像素数组（每个元素为16x16像素块，颜色对应数值大小）。  
       - 上方显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。  
       - 右侧显示当前sum1、sum2及其计数（cnt1、cnt2），以及当前最长长度ans。

    2. **算法启动**：  
       - 初始时，左指针l=1（绿色箭头），右指针i=1（黄色箭头），sum1=a[1]（红色块高亮），cnt1=1，ans=1。

    3. **右指针右移（i++）**：  
       - 右箭头向右移动一格，新元素a[i]的像素块闪烁（白色）。  
       - 若a[i]等于sum1或sum2，对应计数（cnt1或cnt2）增加，数值显示区更新（如cnt1从1变2），伴随“滴”音效。  
       - 若a[i]不匹配sum1/sum2，进入调整左指针阶段。

    4. **左指针调整（l右移）**：  
       - 左箭头向右移动，被移出的元素颜色变灰（失去高亮）。  
       - 若移出的是sum1，cnt1减1；若是sum2，cnt2减1。计数为0时，sum1或sum2替换为a[i]，对应像素块颜色更新（如sum1从红色变紫色）。  
       - 调整过程中，窗口长度（i-l+1）动态显示，直到最值差≤1。

    5. **更新最长长度**：  
       - 每次窗口有效时，ans与当前长度比较，若更大则更新（ans数值变大，伴随“叮”音效），并在屏幕上方用金色星星动画庆祝。

    6. **交互控制**：  
       - 支持单步执行（每次i++）、自动播放（速度可调）、重置（回到初始状态）。  
       - 代码同步区高亮当前执行的代码行（如`if (a[i] == sum1) cnt1++`），并显示注释解释操作目的。

<visualization_conclusion>
通过这个动画，我们能直观看到双指针如何动态调整窗口，sum1/sum2如何更新，以及最长长度的诞生过程，让抽象的算法变得“可见可感”。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的滑动窗口和动态规划思想可迁移到多种区间问题中，以下是拓展练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    滑动窗口适用于“最长子数组满足某条件”的问题（如和≤k、不同字符数≤k）；动态规划适用于“状态可由相邻子问题推导”的问题（如最长递增子序列、编辑距离）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1638 逛画展**  
          * 🗣️ **推荐理由**：同样使用双指针维护窗口，要求窗口内包含所有画家作品，巩固滑动窗口的调整逻辑。
    2.  **洛谷 P1886 滑动窗口 /【模板】单调队列**  
          * 🗣️ **推荐理由**：学习单调队列维护区间最值，与本题的Treap解法异曲同工。
    3.  **洛谷 P5677 [GZOI2017]配对统计**  
          * 🗣️ **推荐理由**：结合滑动窗口和哈希表，处理区间内特定条件的统计问题，拓展思路。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自 to_be_continued)**：“暴力解法TLE后，发现当当前答案足够大时，后面的枚举无法超过它，于是加了`if (n - answer < i) break;`优化，成功AC。”  
> **点评**：这位作者的经验提醒我们，暴力解法并非一无是处，通过观察问题特性（如答案的单调性），可以添加剪枝条件，大幅优化时间。这对竞赛中快速通过部分测试点很有帮助。

-----

<conclusion>
本次关于“Approximating a Constant Range”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握滑动窗口、动态规划等核心算法，理解如何利用题目特性优化代码。记住，多动手写代码、调试，才能真正掌握算法思想！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：168.38秒
# 题目信息

# New Skateboard

## 题目描述

Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by $ 4 $ .

You are given a string $ s $ consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by $ 4 $ . A substring can start with a zero.

A substring of a string is a nonempty sequence of consecutive characters.

For example if string $ s $ is 124 then we have four substrings that are divisible by $ 4 $ : 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.

## 样例 #1

### 输入

```
124
```

### 输出

```
4
```

## 样例 #2

### 输入

```
04
```

### 输出

```
3
```

## 样例 #3

### 输入

```
5810438174
```

### 输出

```
9
```

# AI分析结果



---
# 💡 Kay的C++算法解析：New Skateboard 深入学习指南 💡

<introduction>
今天我们来一起分析“New Skateboard”这道C++编程题。题目要求我们计算一个数字字符串中有多少个子串能被4整除。本指南将帮助大家梳理核心思路，理解关键算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论性质应用）`

🗣️ **初步分析**：
解决“New Skateboard”这道题，关键在于运用数论中的一个经典性质：**一个数能被4整除当且仅当它的末两位组成的数能被4整除**。就像我们检查一个数是否是偶数时只看最后一位，这里我们只需要关注最后两位。

举个简单的例子，数字124的末两位是24（24÷4=6），所以124能被4整除；而数字04的末两位是04（04÷4=1），所以04也能被4整除。此外，单独一位数的0、4、8本身也能被4整除，这是需要单独考虑的情况。

题解的核心思路分为两部分：
1. **单字符子串**：直接检查每个字符是否是0、4、8（这三个数字能被4整除）。
2. **双字符及以上子串**：遍历所有连续两个字符组成的数，若该数能被4整除，则所有以这两个字符结尾的子串（包括它们自己）都能被4整除，这样的子串数量等于这两个字符前面的字符数+1（例如，位置i和i+1的两个字符符合条件，则有i+1个子串：从位置0到i+1，位置1到i+1，…，位置i到i+1）。

核心难点在于正确统计所有符合条件的子串数量，尤其是双字符及以上的情况容易漏算或重复计算。可视化设计时，可以用像素动画逐个高亮检查的字符，当发现符合条件的单字符或双字符时，用不同颜色标记，并动态显示累加的答案。例如，采用8位像素风格的界面，每个数字作为一个像素块，检查到单字符符合条件时，该块闪烁并播放“叮”的音效；检查到双字符符合条件时，两个块同时闪烁，并显示新增的子串数量。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解表现突出（≥4星），值得重点学习：
</eval_intro>

**题解一：作者Marsrayd**
* **点评**：此题解详细解释了数学原理（末两位能被4整除的性质），并通过代码实现了高效统计。代码中使用`is[10][10]`数组预存所有能被4整除的两位数，避免了重复计算；通过`getchar()`逐字符读取，优化了输入效率。边界处理严谨（如最后一位的单独判断），是竞赛中典型的高效实现。

**题解二：作者Engulf**
* **点评**：此题解代码简洁清晰，直接遍历字符串处理单字符和双字符情况。变量命名直观（如`ans`表示答案），逻辑直白：先统计所有单字符符合条件的数量，再遍历双字符并累加对应子串数。代码风格符合竞赛规范，适合新手学习。

**题解三：作者chlchl**
* **点评**：此题解结构清晰，分两部分处理：第一部分统计单字符符合条件的数量，第二部分遍历双字符并累加对应子串数。代码中使用`scanf`和`strlen`优化输入输出，符合题目对“快速输入输出”的要求。注释明确，关键步骤解释到位，适合理解核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1：正确应用数论性质**
    * **分析**：需要明确“末两位能被4整除”的性质仅适用于长度≥2的数，而长度为1的数需单独判断（0、4、8）。优质题解通常会分别处理这两种情况，避免漏算或重复。
    * 💡 **学习笔记**：数论性质是解题的“钥匙”，先理解性质再设计算法能事半功倍。

2.  **关键点2：统计双字符及以上子串的数量**
    * **分析**：若位置i和i+1的两个字符组成的数能被4整除，则以这两个字符结尾的子串数量为i+1（起始位置可以是0到i）。例如，字符串“124”中，位置1和2的字符“2”和“4”组成24（能被4整除），则子串有“24”（起始位置1）和“124”（起始位置0），共2个（i+1=1+1=2）。
    * 💡 **学习笔记**：双字符符合条件时，子串数量等于其前面的字符数+1，这是统计的核心逻辑。

3.  **关键点3：处理边界条件**
    * **分析**：最后一个字符需要单独检查是否为0、4、8（因为它无法与下一个字符组成双字符）。优质题解通常会在循环结束后单独处理最后一位，确保无遗漏。
    * 💡 **学习笔记**：边界条件（如字符串首尾）是易错点，需特别注意。

### ✨ 解题技巧总结
- **预计算优化**：预存所有能被4整除的两位数（如00、04、08…96），避免每次计算时重复取模（如Marsrayd的`is[10][10]`数组）。
- **输入输出优化**：使用`scanf/printf`或`getchar`代替`cin/cout`，避免超时（题目数据量可能很大）。
- **分情况处理**：明确单字符和双字符的不同统计方式，逻辑更清晰。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，逻辑清晰且高效，适合直接学习和应用。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Marsrayd和Engulf的思路，处理单字符和双字符情况，优化了输入输出，并确保边界条件正确。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cstring>
    using namespace std;

    int main() {
        char s[300005];
        scanf("%s", s);
        long long ans = 0;
        int len = strlen(s);

        // 处理单字符子串（0、4、8）
        for (int i = 0; i < len; ++i) {
            if ((s[i] - '0') % 4 == 0) {
                ans++;
            }
        }

        // 处理双字符及以上子串（末两位能被4整除）
        for (int i = 0; i < len - 1; ++i) {
            int num = (s[i] - '0') * 10 + (s[i + 1] - '0');
            if (num % 4 == 0) {
                ans += (i + 1); // 有i+1个子串以这两位结尾
            }
        }

        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取字符串，然后分两部分统计答案：
    1. 遍历每个字符，检查是否为0、4、8，统计单字符子串数量。
    2. 遍历每对连续字符，计算它们组成的两位数是否能被4整除，若能则累加对应的子串数量（i+1）。
    最后输出总答案，时间复杂度为O(n)，适用于大输入规模。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，学习其中的亮点和关键思路。
</code_intro_selected>

**题解一：作者Marsrayd**
* **亮点**：预存所有能被4整除的两位数，避免重复取模；使用`getchar`逐字符读取，优化输入效率。
* **核心代码片段**：
    ```cpp
    bool is[10][10];
    int main() {
        ch=pre=getchar(),ans=(ch=='0'||ch=='4'||ch=='8');
        for(int i=0;i<=96;i+=4) is[i/10][i%10]=1;
        while(ch>='0'&&ch<='9') {
            ch=getchar(),++sum;
            if(ch>'9'||ch<'0') break;
            if(is[pre-'0'][ch-'0']) ans+=sum;
            if((ch=='0')||(ch=='4')||(ch=='8')) ++ans;
            pre=ch;
        }
        printf("%lld",ans);
    }
    ```
* **代码解读**：
    `is[10][10]`数组预存所有能被4整除的两位数（如i=0时，i/10=0，i%10=0，对应00；i=4时，对应04，以此类推）。通过`getchar`逐字符读取，`pre`保存前一个字符，`ch`保存当前字符。当`pre`和`ch`组成的数在`is`数组中标记为`true`时，累加`sum`（当前已处理的字符数，即i+1）。同时检查当前字符是否为0、4、8，累加单字符情况。
* 💡 **学习笔记**：预计算常用值（如能被4整除的两位数）可以减少运行时计算量，提升效率。

**题解二：作者Engulf**
* **亮点**：代码简洁，逻辑直白，直接遍历字符串处理两种情况，适合新手理解。
* **核心代码片段**：
    ```cpp
    int main() {
        ios::sync_with_stdio(false),cin.tie(nullptr);
        string s;
        cin>>s;
        long long ans=0;
        for(auto &c:s) if((c-'0')%4==0) ans++;
        for(int i=s.size()-1;i>=1;i--) {
            int x = (s[i-1]-'0')*10+(s[i]-'0');
            if(x%4==0) ans+=i;
        }
        cout<<ans<<endl;
    }
    ```
* **代码解读**：
    第一个循环统计所有单字符符合条件的数量。第二个循环从后往前遍历，计算每对连续字符组成的数是否能被4整除，若能则累加`i`（即i=当前位置，对应i+1个子串？需注意这里的索引可能与其他题解不同，实际`i`是当前字符的位置，前一个字符是i-1，所以子串数量是i-1+1=i，与通用代码一致）。
* 💡 **学习笔记**：从后往前遍历和从前往后遍历效果相同，但需注意索引的对应关系。

**题解三：作者chlchl**
* **亮点**：代码结构清晰，分两部分处理单字符和双字符，注释明确。
* **核心代码片段**：
    ```cpp
    int main() {
        scanf("%s", s);
        n = strlen(s);
        for(int i=0;i<n;i++) {
            int a = s[i] - '0';
            if(a % 4 == 0) ans++;
        }
        for(int i=0;i<n-1;i++) {
            int a = (s[i] - '0') * 10 + (s[i + 1] - '0');
            if(a % 4 == 0) ans += i + 1;
        }
        printf("%lld\n", ans);
    }
    ```
* **代码解读**：
    第一个循环处理单字符情况，第二个循环处理双字符情况。`i+1`表示以第i和i+1位结尾的子串数量（起始位置从0到i，共i+1个）。代码逻辑与通用实现一致，易于理解。
* 💡 **学习笔记**：分步骤处理不同情况（单字符、双字符）可以让代码更易维护和调试。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解算法如何统计符合条件的子串，我们设计一个“像素数字探险”动画，以8位复古风格展示每一步的检查过程。
</visualization_intro>

  * **动画演示主题**：`像素数字探险——寻找4的倍数子串`

  * **核心演示内容**：
    动画将展示一个由像素方块组成的数字字符串（如“124”），逐个检查每个单字符和双字符是否能被4整除。当发现符合条件的子串时，对应的方块会高亮，并动态显示答案的累加过程。

  * **设计思路简述**：
    采用8位像素风格（如FC游戏画面），颜色简洁（如蓝色背景，白色数字方块）。单字符符合条件时，方块闪烁绿色；双字符符合条件时，两个方块同时闪烁黄色，并显示新增的子串数量（如“+2”）。音效方面，单字符匹配时播放“叮”声，双字符匹配时播放“叮咚”声，完成所有检查后播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕上方显示像素化的数字字符串（如“124”），每个数字占一个像素方块（20x20像素），背景为淡蓝色。
        - 下方控制面板包含“开始”“暂停”“单步”“重置”按钮和速度滑块（1-5倍速）。
        - 播放8位风格的轻快背景音乐（如《超级玛丽》的经典旋律变奏）。

    2.  **单字符检查**：
        - 动画从左到右移动一个像素箭头（红色），指向当前检查的字符（如第一个字符“1”）。
        - 检查该字符是否为0、4、8：若不是（如“1”），箭头继续右移；若是（如“4”），该字符方块变为绿色并闪烁，答案计数器加1，播放“叮”声。

    3.  **双字符检查**：
        - 箭头变为两个（蓝色），分别指向当前字符和下一个字符（如“1”和“2”）。
        - 计算这两个字符组成的数（12），检查是否能被4整除：若不能（12%4=0？不，12%4=0？12/4=3，能被4整除？哦，12能被4整除吗？12÷4=3，是的。所以“12”符合条件。此时，两个方块变为黄色并闪烁，答案计数器加i+1（i=0，所以+1），播放“叮咚”声，并显示“新增1个子串（12）”。

    4.  **目标达成**：
        - 所有字符检查完成后，答案计数器显示最终结果（如“4”），数字字符串整体变为金色，播放胜利音效（如《超级玛丽》的通关音乐）。

    5.  **交互控制**：
        - 单步模式：点击“单步”按钮，动画逐字符/逐对检查；自动模式：选择速度后，动画自动播放。
        - 重置按钮：清空计数器，回到初始状态。

  * **旁白提示**：
    - （单字符检查时）“看！这个数字是0、4或8吗？如果是，它自己就是一个符合条件的子串~”
    - （双字符检查时）“现在检查这两个数字组成的数，能被4整除吗？如果能，前面所有以它们结尾的子串都符合条件哦！”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到每个子串的检查过程，理解答案是如何一步步累加的，学习起来更轻松有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的数论性质应用后，我们可以尝试解决更多类似问题，巩固对“子串整除”的理解。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    本题的核心是利用数论性质（末几位决定整除性）简化问题。类似地，判断子串是否能被2、5、8、25等数整除时，也可以利用末位或末几位的性质。例如：
    - 被2整除：末位是偶数。
    - 被5整除：末位是0或5。
    - 被8整除：末三位能被8整除。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1100** - `高低位交换`
          * 🗣️ **推荐理由**：本题涉及二进制位的高低位交换，需要理解数的位值原理，与本题的“末位决定整除性”有相似的思维方式。
    2.  **洛谷 P1304** - `哥德巴赫猜想`
          * 🗣️ **推荐理由**：本题需要判断质数和数的分解，锻炼数论基础，与本题的数论应用思路互补。
    3.  **洛谷 P1047** - `校门外的树`
          * 🗣️ **推荐理由**：本题涉及区间处理和统计，锻炼逻辑思维和边界条件处理，与本题的子串统计有相似的细节需要注意。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但通过观察题解，我们可以总结：在处理数论相关的字符串问题时，关键是先理解数的整除性质，再设计高效的统计方法，同时注意边界条件（如字符串首尾的处理）。
</insights_intro>

-----

<conclusion>
本次关于“New Skateboard”的C++解题分析就到这里。希望这份指南能帮助大家理解数论性质的应用和子串统计的技巧。记住，多动手编写代码、调试测试，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：178.64秒
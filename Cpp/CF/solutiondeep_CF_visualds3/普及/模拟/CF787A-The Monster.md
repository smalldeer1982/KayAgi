# 题目信息

# The Monster

## 题目描述

A monster is chasing after Rick and Morty on another planet. They're so frightened that sometimes they scream. More accurately, Rick screams at times $ b,b+a,b+2a,b+3a,... $ and Morty screams at times $ d,d+c,d+2c,d+3c,... $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF787A/23c11249630f1c4252ef0b9cda8ec1bf9b317b5a.png)The Monster will catch them if at any point they scream at the same time, so it wants to know when it will catch them (the first time they scream at the same time) or that they will never scream at the same time.

## 说明/提示

In the first sample testcase, Rick's $ 5 $ th scream and Morty's $ 8 $ th time are at time $ 82 $ .

In the second sample testcase, all Rick's screams will be at odd times and Morty's will be at even times, so they will never scream at the same time.

## 样例 #1

### 输入

```
20 2
9 19
```

### 输出

```
82
```

## 样例 #2

### 输入

```
2 1
16 12
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：The Monster 深入学习指南 💡

<introduction>
今天我们来一起分析“The Monster”这道C++编程题。题目要求找出Rick和Morty尖叫时间的最小公共点，或判断不存在。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论应用）`  

🗣️ **初步分析**：  
解决这道题的关键在于理解两个等差数列的公共项问题。可以将问题转化为求解方程 \( b + a \cdot x = d + c \cdot y \)，即 \( a \cdot x - c \cdot y = d - b \)。根据数论中的贝祖定理，该方程有解当且仅当 \( \gcd(a,c) \) 能整除 \( d - b \)（\( \gcd \) 表示最大公约数）。若有解，则需找到最小的公共时间；若无解，输出 `-1`。  

- **题解思路对比**：  
  主要有两种思路：  
  1. **数论判断+模拟**：先通过贝祖定理判断是否有解，若有解则模拟递增较小的数列（如 \( b < d \) 时让 \( b \) 不断加 \( a \)，反之让 \( d \) 加 \( c \)），直到两者相等。  
  2. **暴力枚举**：直接枚举 \( x \) 和 \( y \) 的可能值（如 \( x, y \leq 100 \)），寻找满足条件的 \( b + a \cdot x = d + c \cdot y \)。但暴力法在 \( a,c \) 较大时可能超时。  

- **核心算法流程**：  
  数论解法的核心步骤是：计算 \( \gcd(a,c) \)，判断 \( (d - b) \) 是否能被其整除。若能，通过模拟递增找到最小公共时间；若不能，直接输出 `-1`。  

- **可视化设计思路**：  
  设计8位像素风格动画，用两个“时间精灵”分别代表Rick和Morty的尖叫时间。精灵在时间轴上按 \( a \) 和 \( c \) 的步长跳跃，当两者跳到同一位置时高亮并播放“叮”的音效。控制面板支持单步/自动播放，实时显示当前时间和跳跃次数。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下优质题解（≥4星）：
</eval_intro>

**题解一：Alex_Wei（赞14）**  
* **点评**：此题解思路简洁高效，结合数论判断和模拟操作。首先用贝祖定理快速判断是否存在解，避免了暴力枚举的低效；模拟部分通过“谁小加谁”的策略，确保找到最小公共时间。代码风格规范（如 `gcd` 函数简洁），边界处理严谨（直接 `exit(0)` 避免无效计算）。实践价值高，适用于竞赛场景。

**题解二：Cutest_Junior（赞1）**  
* **点评**：此题解通过枚举可能的公共时间 \( x \)（从 \( \max(b,d) \) 到 \( 10000 \)），并利用同余条件 \( x \equiv b \pmod{a} \) 和 \( x \equiv d \pmod{c} \) 判断是否满足。思路直观，代码简洁，适合理解同余方程的应用。虽时间复杂度略高（\( O(10000) \)），但在题目数据范围内足够高效。

**题解三：肖恩Sean（赞1）**  
* **点评**：此题解使用扩展欧几里得算法求解同余方程 \( x \equiv b \pmod{a} \) 和 \( x \equiv d \pmod{c} \)，合并为 \( x \equiv f \pmod{e} \) 形式，最终找到最小解。算法专业，适合进阶学习同余方程的合并技巧，代码逻辑严谨（如处理负数解的模运算），是数论解法的深度实践。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于判断是否存在解，以及高效找到最小公共时间。以下是关键分析：
</difficulty_intro>

1.  **关键点1：判断是否存在解**  
    * **分析**：根据贝祖定理，方程 \( a \cdot x - c \cdot y = d - b \) 有解的充要条件是 \( \gcd(a,c) \mid (d - b) \)。例如，样例2中 \( a=2, c=12 \)，\( \gcd(2,12)=2 \)，但 \( d - b = 16 - 2 = 14 \)，\( 14 \div 2 = 7 \) 余0？不，样例2的正确输入是 \( a=2, b=2, c=12, d=16 \)，则 \( d - b = 14 \)，\( \gcd(2,12)=2 \)，14能被2整除，但实际输出是-1？哦，原题样例2输入是：输入为2 1 16 12（即a=2,b=1,c=16,d=12），则 \( d - b = 11 \)，\( \gcd(2,16)=2 \)，11不能被2整除，故无解。这说明贝祖定理的正确应用是关键。  
    * 💡 **学习笔记**：贝祖定理是判断线性不定方程是否有解的核心工具，需正确计算 \( \gcd(a,c) \) 并验证整除性。

2.  **关键点2：找到最小公共时间**  
    * **分析**：若存在解，需找到最小的 \( x \) 满足 \( b + a \cdot x = d + c \cdot y \)。数论解法通过“谁小加谁”的模拟（如 \( b < d \) 时 \( b += a \)），确保每次递增都逼近可能的公共时间；扩展欧几里得解法通过求解同余方程直接找到最小解。  
    * 💡 **学习笔记**：模拟法直观易实现，适合小数据；扩展欧几里得法高效，适合大数据。

3.  **关键点3：避免暴力枚举的超时问题**  
    * **分析**：暴力枚举 \( x,y \) 的范围需合理设置（如 \( \leq 100 \)），但 \( a,c \) 较大时可能遗漏解（如 \( a=100, c=100 \)，公共时间可能在 \( 100 \times 100 = 10000 \) 处）。因此，暴力法仅适用于数据范围小的场景。  
    * 💡 **学习笔记**：优先选择数论或扩展欧几里得解法，确保效率。

### ✨ 解题技巧总结  
- **问题转化**：将实际问题转化为数学方程（如 \( a \cdot x - c \cdot y = d - b \)），利用数论工具快速判断。  
- **模拟优化**：模拟时采用“谁小加谁”策略，避免无效计算。  
- **边界处理**：枚举时注意 \( x,y \) 从0开始（可能 \( b=d \) 时直接输出）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合数论判断和模拟，高效且简洁：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合Alex_Wei和sodak的题解，通过数论判断是否有解，模拟递增找到最小公共时间。  
* **完整核心代码**：  
    ```cpp
    #include <iostream>
    using namespace std;

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    int main() {
        int a, b, c, d;
        cin >> a >> b >> c >> d;

        int delta = d - b;
        int g = gcd(a, c);
        if (delta % g != 0) { // 贝祖定理判断是否有解
            cout << -1 << endl;
            return 0;
        }

        // 模拟递增，直到b和d相等
        while (b != d) {
            if (b < d) {
                b += a;
            } else {
                d += c;
            }
        }

        cout << b << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先计算 \( \gcd(a,c) \)，判断 \( d - b \) 是否能被其整除（无解则输出-1）。若有解，通过循环递增较小的数（\( b \) 或 \( d \)），直到两者相等，此时即为最小公共时间。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Alex_Wei**  
* **亮点**：数论判断+模拟递增，时间复杂度 \( O(\max(a,c)/g) \)（\( g \) 为 \( \gcd(a,c) \)），高效简洁。  
* **核心代码片段**：  
    ```cpp
    if((d-b)%gcd(a,c))cout<<-1,exit(0);
    while(b!=d)b<d?b+=a:d+=c;
    ```
* **代码解读**：  
  第一行通过 \( \gcd(a,c) \) 判断是否有解（若 \( (d - b) \) 不能被 \( \gcd \) 整除，直接输出-1）。第二行循环递增较小的数（\( b < d \) 时 \( b += a \)，否则 \( d += c \)），直到两者相等，得到最小公共时间。  
* 💡 **学习笔记**：模拟时“谁小加谁”的策略能快速逼近解，避免冗余计算。

**题解二：Cutest_Junior**  
* **亮点**：枚举可能的公共时间 \( x \)，利用同余条件判断，代码直观。  
* **核心代码片段**：  
    ```cpp
    for (int i = max(b, d); i <= 10000; ++i) {
        if (i % a == b % a && i % c == d % c) {
            printf("%d", i);
            return 0;
        }
    }
    ```
* **代码解读**：  
  从 \( \max(b,d) \) 开始枚举 \( x \)，判断 \( x \) 是否满足 \( x \equiv b \pmod{a} \)（即 \( x \% a == b \% a \)）和 \( x \equiv d \pmod{c} \)（即 \( x \% c == d \% c \)）。若满足，\( x \) 即为最小公共时间。  
* 💡 **学习笔记**：同余条件的应用是关键，\( x \% a == b \% a \) 等价于 \( x - b \) 是 \( a \) 的倍数。

**题解三：肖恩Sean**  
* **亮点**：扩展欧几里得求解同余方程，适合大数据场景。  
* **核心代码片段**：  
    ```cpp
    int exgcd(int a, int b, int &x, int &y) {
        if (!b) { x = 1; y = 0; return a; }
        int tmp = exgcd(b, a % b, y, x);
        y -= a / b * x;
        return tmp;
    }
    // 合并同余方程并求解
    ```
* **代码解读**：  
  `exgcd` 函数求解 \( ax + by = \gcd(a,b) \) 的一组解 \( (x,y) \)。通过扩展欧几里得算法求解 \( a \cdot x - c \cdot y = d - b \)，找到最小非负解后调整到大于 \( \max(b,d) \) 的最小解。  
* 💡 **学习笔记**：扩展欧几里得算法是求解线性同余方程的核心工具，适用于需要高效计算的场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解两个数列的生成和相遇过程，我们设计一个“时间精灵跳跃”的8位像素动画：
</visualization_intro>

  * **动画演示主题**：`时间精灵的相遇挑战`  
  * **核心演示内容**：两个像素精灵（蓝色代表Rick，绿色代表Morty）在时间轴上按 \( a \) 和 \( c \) 的步长跳跃，寻找第一次相遇的时间点。  

  * **设计思路简述**：  
    8位像素风格营造轻松氛围，精灵跳跃动画强化步长概念；关键步骤（如相遇）的高亮和音效提示，帮助记忆核心逻辑。

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：  
       - 时间轴为水平像素条（每格代表1单位时间），起点分别为 \( b \)（蓝色精灵）和 \( d \)（绿色精灵）。  
       - 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块。  
       - 播放8位风格背景音乐（如《超级玛丽》主题变奏）。  

    2. **算法启动**：  
       - 点击“开始”，精灵按步长跳跃（蓝色每次跳 \( a \) 格，绿色跳 \( c \) 格）。  
       - 跳跃时播放“滴答”音效，精灵脚下出现像素波纹动画。  

    3. **核心步骤演示**：  
       - **当前时间高亮**：精灵所在时间格用黄色边框闪烁。  
       - **数据变化**：屏幕上方显示当前时间 \( b \) 和 \( d \) 的值，实时更新。  
       - **相遇判断**：若两精灵跳到同一格，该格变为红色，播放“叮”的胜利音效，动画暂停并显示“找到啦！”。  

    4. **无解提示**：  
       - 若超过一定步数（如1000步）未相遇，时间轴变为灰色，播放“呜”的提示音，显示“无解”。  

    5. **交互控制**：  
       - 单步模式：每点击一次“单步”，精灵跳跃一步，便于观察细节。  
       - 速度滑块：调整跳跃间隔（0.5s/步到0.1s/步）。  

  * **旁白提示**：  
    - “看！蓝色精灵从时间 \( b \) 出发，每次跳 \( a \) 步～”  
    - “绿色精灵从 \( d \) 出发，每次跳 \( c \) 步哦～”  
    - “它们相遇啦！这就是最小的共同时间！”  

<visualization_conclusion>
通过这个动画，我们能直观看到两个数列的生成过程，以及数论判断如何避免无效枚举，轻松理解算法核心！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下拓展练习，巩固数论和枚举的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的数论判断和模拟思想可用于解决：  
    1. 两个等差数列的公共项问题（如求第 \( k \) 小公共项）。  
    2. 同余方程组的最小解（如中国剩余定理的应用）。  
    3. 周期性事件的重叠时间（如火车发车时间、节日重合问题）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1082** - `同余方程`  
        * 🗣️ **推荐理由**：直接应用扩展欧几里得算法求解线性同余方程，巩固数论基础。  
    2.  **洛谷 P2058** - `海港`  
        * 🗣️ **推荐理由**：涉及多周期事件的重叠判断，需结合队列和时间计算，锻炼综合思维。  
    3.  **洛谷 P5656** - `【模板】二元一次不定方程 (exgcd)`  
        * 🗣️ **推荐理由**：系统练习扩展欧几里得算法，掌握线性不定方程的解的结构。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到暴力枚举的循环次数设置问题，例如“i和j到100就足够了”，但实际可能因数据范围遗漏解。这些经验提醒我们：
</insights_intro>

> **参考经验 (来自xujian)**：“双重循环的i和j到100就足够了，但要注意边界值问题，否则会WA。”  
> **点评**：虽然暴力法在小数据下可行，但需根据题目数据范围调整循环次数（如本题 \( a,c \leq 100 \)，循环到10000更稳妥）。更推荐数论解法，避免因循环次数不足导致错误。

-----

<conclusion>
本次关于“The Monster”的解题分析就到这里。希望大家通过数论判断和模拟的结合，掌握解决等差数列公共项问题的核心技巧。记住，遇到类似问题时，先转化为数学方程，再选择高效算法！下次见～💪
</conclusion>

---
处理用时：155.13秒
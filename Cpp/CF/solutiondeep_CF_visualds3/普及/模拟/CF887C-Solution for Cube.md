# 题目信息

# Solution for Cube

## 题目描述

During the breaks between competitions, top-model Izabella tries to develop herself and not to be bored. For example, now she tries to solve Rubik's cube 2x2x2.

It's too hard to learn to solve Rubik's cube instantly, so she learns to understand if it's possible to solve the cube in some state using 90-degrees rotation of one face of the cube in any direction.

To check her answers she wants to use a program which will for some state of cube tell if it's possible to solve it using one rotation, described above.

Cube is called solved if for each face of cube all squares on it has the same color.

<a>https://en.wikipedia.org/wiki/Rubik's\_Cube</a>

## 说明/提示

In first test case cube looks like this:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF887C/73004469d714c2206d92e2fac016d4fc092e2426.png)In second test case cube looks like this:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF887C/37b512d2c715516faa04a8cfe0023b26918d7893.png)It's possible to solve cube by rotating face with squares with numbers 13, 14, 15, 16.

## 样例 #1

### 输入

```
2 5 4 6 1 3 6 2 5 5 1 2 3 5 3 1 1 2 4 6 6 4 3 4
```

### 输出

```
NO```

## 样例 #2

### 输入

```
5 3 5 3 2 5 2 5 6 2 6 2 4 4 4 4 1 1 1 1 6 3 6 3
```

### 输出

```
YES```

# AI分析结果



---
# 💡 Kay的C++算法解析：Cube问题深入学习指南 💡

<introduction>
今天我们来一起分析“Cube”这道C++编程题。这道题需要判断一个2x2x2的魔方是否可以通过一次90度旋转某个面来解决（即每个面颜色相同）。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举` (属于“常见算法分类”中的枚举技巧)

🗣️ **初步分析**：
> 解决“Cube”问题的关键在于枚举所有可能的单次旋转情况，判断是否存在一种旋转能让所有面颜色统一。简单来说，“枚举”就像“尝试所有可能性”——比如魔方有6个面，每个面可能顺时针或逆时针转90度（但2x2魔方单次旋转的实际有效情况有限），我们需要把这些可能的旋转都试一遍，看看有没有符合条件的。  
> 本题的核心难点是：如何正确建模魔方的面和旋转后的状态，确保枚举所有可能的旋转情况而不遗漏。优质题解通常通过直接枚举所有可能的旋转后的面颜色组合，用`check`函数验证是否满足条件。  
> 核心算法流程是：定义`check`函数判断四个颜色是否相同→枚举所有可能的单次旋转后的面组合→若存在任意一种组合满足所有面颜色相同，输出`YES`，否则`NO`。  
> 可视化方案将采用8位像素风格，用不同颜色的像素块代表魔方的各个面，通过动态旋转动画展示每次枚举的旋转操作（如某个面顺时针转90度），并用高亮标记当前旋转的面和变化的颜色块，配合“叮”的音效提示关键操作。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下3个优质题解（评分≥4星）：
</eval_intro>

**题解一：作者：流绪**
* **点评**：这份题解思路非常清晰，直接枚举所有可能的单次旋转后的面组合。代码使用一维数组存储颜色（`ch`数组），通过`check`函数快速判断四个颜色是否相同。变量命名简洁（如`ch`代表“颜色”），逻辑直白，覆盖了所有可能的有效旋转情况（共6种），实践价值高（可直接用于竞赛）。亮点在于将复杂的魔方旋转转化为简单的面组合枚举，避免了繁琐的三维坐标计算。

**题解二：作者：OIerZhang**
* **点评**：此题解通过复制原数组到临时数组`t`，模拟每种旋转后的状态，再调用`check`函数验证所有面是否同色。代码结构工整（每个旋转情况单独处理），虽然代码较长但逻辑清晰，适合理解“枚举+模拟”的解题流程。亮点是通过临时数组`t`隔离原数据和旋转后数据，避免了修改原数组的风险。

**题解三：作者：kimi0705**
* **点评**：此题解与流绪的思路高度一致，但代码更简洁（直接通过`else if`枚举所有情况）。`check`函数复用性强，变量命名直观（`ch`数组），边界处理严谨（覆盖所有6种可能的旋转情况）。亮点是将枚举逻辑压缩到连续的`if-else`中，代码可读性高，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何建模魔方的面和旋转后的状态？**
    * **分析**：2x2x2魔方共有6个面，每个面4个块。输入的24个数字按顺序对应这24个块（如第1-4号是前面，5-8号是右面等）。旋转一个面会导致相邻面的块位置变化。优质题解通过直接枚举旋转后的面组合（如旋转前面后，哪些块的颜色应相同），避免了复杂的坐标计算。
    * 💡 **学习笔记**：对于魔方问题，直接枚举旋转后的面组合比模拟三维旋转更简单。

2.  **关键点2：如何枚举所有可能的单次旋转情况？**
    * **分析**：2x2魔方的有效单次旋转共有6种（每个面顺时针或逆时针转90度，但实际部分旋转等价，因此优质题解枚举6种情况）。需要确保覆盖所有可能的旋转，否则会遗漏正确解。例如，流绪的题解枚举了“前面旋转后的两种可能”“右面旋转后的两种可能”等，共6种。
    * 💡 **学习笔记**：枚举时需明确每种旋转对应的面块变化，确保无遗漏。

3.  **关键点3：如何高效判断所有面是否颜色统一？**
    * **分析**：通过`check`函数判断四个块颜色是否相同（如`check(a,b,c,d)`判断`ch[a]`到`ch[d]`是否同色）。优质题解复用`check`函数，避免重复代码，提高效率。
    * 💡 **学习笔记**：复用函数是提高代码效率和可读性的关键。

### ✨ 解题技巧总结
<summary_best_practices>
-   **问题简化**：将复杂的三维旋转问题转化为面组合的枚举问题，避免三维坐标计算。
-   **函数复用**：用`check`函数统一判断颜色是否相同，减少重复代码。
-   **边界覆盖**：枚举时确保覆盖所有可能的旋转情况（如本题的6种），避免遗漏。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了流绪和kimi0705的题解思路，采用一维数组存储颜色，枚举所有可能的单次旋转情况，通过`check`函数验证。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int ch[25]; // 存储24个块的颜色（索引1-24）

    // 检查四个块颜色是否相同
    bool check(int a, int b, int c, int d) {
        return ch[a] == ch[b] && ch[a] == ch[c] && ch[a] == ch[d];
    }

    int main() {
        for (int i = 1; i <= 24; ++i) cin >> ch[i];
        bool flag = false;

        // 枚举所有可能的单次旋转后的面组合
        flag |= check(13,14,15,16) && check(17,18,19,20) && check(2,4,22,24) && check(1,3,6,8) && check(5,7,10,12);
        flag |= check(13,14,15,16) && check(17,18,19,20) && check(2,4,5,7) && check(6,8,9,11) && check(10,12,22,24);
        flag |= check(1,2,3,4) && check(9,10,11,12) && check(5,6,15,16) && check(17,18,7,8) && check(21,22,19,20);
        flag |= check(1,2,3,4) && check(9,10,11,12) && check(7,8,13,14) && check(19,20,5,6) && check(23,24,17,18);
        flag |= check(5,6,7,8) && check(21,22,23,24) && check(1,2,17,19) && check(13,15,3,4) && check(11,12,14,16);
        flag |= check(5,6,7,8) && check(21,22,23,24) && check(3,4,18,20) && check(14,16,1,2) && check(9,10,13,15);

        cout << (flag ? "YES" : "NO") << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取24个颜色值存入`ch`数组。`check`函数判断四个块颜色是否相同。主函数中枚举6种可能的单次旋转后的面组合（每种组合对应旋转某个面后的各面颜色状态），只要有一个组合满足所有面颜色相同，`flag`设为`true`，最终输出`YES`或`NO`。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：作者：流绪**
* **亮点**：代码简洁，通过连续的`if`语句枚举所有情况，`check`函数复用性强。
* **核心代码片段**：
    ```cpp
    bool check(int a,int b,int c,int d) {
        if(ch[a]==ch[b]&&ch[a]==ch[c]&&ch[a]==ch[d]) return 1;
        return 0;
    }
    // main函数中枚举6种情况...
    ```
* **代码解读**：
    > `check`函数接收四个块的索引，判断它们的颜色是否相同。为什么这样设计？因为每次旋转后，多个面的块会重新组合，需要验证这些新组合的块是否颜色统一。例如，旋转前面后，右面、上面等面的块会形成新的组合，`check`函数能快速验证这些组合是否符合要求。
* 💡 **学习笔记**：复用`check`函数可以避免重复编写颜色判断代码，提高效率。

**题解二：作者：OIerZhang**
* **亮点**：通过临时数组`t`模拟旋转后的状态，隔离原数据，避免修改原数组。
* **核心代码片段**：
    ```cpp
    void yes() { cout << "YES"; }
    void no() { cout << "NO"; }

    int main() {
        for (int i = 1; i <= 24; i++) cin >> a[i];
        memset(t, 0, sizeof(t));
        // 模拟第一种旋转，修改t数组...
        if (check()) { yes(); return 0; }
        // 其他旋转情况...
    }
    ```
* **代码解读**：
    > 作者将原数据存入`a`数组，每次旋转时复制到`t`数组并修改`t`，再调用`check`验证`t`。这样做的好处是不破坏原数据，确保每次旋转的模拟独立。例如，第一次旋转时，`t`数组是原数据的副本，修改`t`后检查，不影响后续的旋转模拟。
* 💡 **学习笔记**：使用临时数组隔离原数据和模拟数据，是避免错误的重要技巧。

**题解三：作者：kimi0705**
* **亮点**：代码结构紧凑，通过`else if`连续枚举，避免冗余判断。
* **核心代码片段**：
    ```cpp
    int main() {
        for (int i = 1; i <= 24; i++) cin >> ch[i];
        if (check(...)) cout << "YES\n";
        else if (check(...)) cout << "YES\n";
        // 其他情况...
        else cout << "NO\n";
    }
    ```
* **代码解读**：
    > 作者用`else if`连接所有枚举情况，一旦某个情况满足，立即输出`YES`并结束。这样可以提前终止不必要的判断，提高效率。例如，若第一种旋转情况满足条件，后面的情况无需再检查。
* 💡 **学习笔记**：用`else if`连接枚举条件，可提前终止，优化运行时间。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举所有单次旋转”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到每次旋转后的魔方状态！
</visualization_intro>

  * **动画演示主题**：`像素魔方小能手`（复古FC风格，主角通过旋转魔方块闯关）

  * **核心演示内容**：展示魔方的6个面（用不同颜色像素块表示），枚举每次旋转操作（如前面顺时针转90度），动态更新各面颜色，最终判断是否所有面颜色统一。

  * **设计思路简述**：采用8位像素风（如FC红白机的简洁色调），让学习更轻松；每次旋转时用“滑动”动画模拟面的转动，配合“叮”的音效强化操作记忆；完成一次有效旋转时，播放“胜利”音效，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是像素魔方（6个面用2x2网格表示，颜色对应输入值），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块）。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》的简单变奏）。

    2.  **枚举开始**：
          * 初始状态显示输入的魔方颜色，每个面用像素块标出索引（如前面1-4号块）。
          * 点击“开始”后，动画自动播放，依次演示每种旋转操作。

    3.  **旋转动画演示**：
          * **当前旋转高亮**：当前旋转的面（如前面）用黄色边框闪烁，伴随“滴”的提示音。
          * **块位置更新**：旋转时，该面的4个块顺时针或逆时针滑动（如前面顺时针转，1号块滑到2号位置，2号到4号，4号到3号，3号到1号），相邻面的块同步更新（如右面的部分块会移动到上面）。
          * **颜色验证**：旋转完成后，所有面的块用绿色（同色）或红色（不同色）高亮，若全部绿色则播放“胜利”音效（如《魂斗罗》的通关音）。

    4.  **交互控制**：
          * 支持“单步”：点击一次播放一步旋转，适合仔细观察每个操作。
          * 支持“调速”：滑块调整动画速度（0.5倍速到2倍速），满足不同学习需求。

    5.  **结束状态**：
          * 若存在有效旋转，动画停在成功画面（所有面绿色高亮，显示“YES”）；否则停在初始画面（显示“NO”）。

  * **旁白提示**：
      * （旋转前）“现在尝试旋转前面顺时针转90度，注意看右面和上面的块如何移动~”
      * （旋转后）“前面旋转完成，检查各面颜色：前面同色，右面同色... 哦，上面不同色，这次旋转不行！”
      * （成功时）“找到啦！这次旋转后所有面颜色相同，输出YES！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能看到每次旋转的具体操作，还能直观理解为什么某些旋转无效、哪些旋转有效，学习效率大大提升！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解了本题的枚举思路后，我们可以思考枚举技巧在其他问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 枚举技巧适用于“可能情况有限”的问题，例如：判断密码是否正确（枚举所有可能的密码）、检查排列是否满足条件（枚举所有排列）等。本题的关键是“可能的单次旋转情况有限”，因此枚举可行。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036 选数** 
          * 🗣️ **推荐理由**：这道题需要枚举所有可能的选数组合，判断是否为质数，能巩固枚举技巧的应用。
    2.  **洛谷 P1157 组合的输出** 
          * 🗣️ **推荐理由**：枚举所有组合并输出，适合练习枚举的边界处理和循环控制。
    3.  **洛谷 P1618 三连击（升级版）** 
          * 🗣️ **推荐理由**：通过枚举所有可能的数字组合，验证是否满足特定条件，与本题的枚举思路类似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，流绪提到“一开始用二维数组存，写得人都懵了，改成一维数组后世界清晰多了”。这是非常宝贵的经验！
</insights_intro>

> **参考经验 (来自流绪)**：“一开始我用二维数组存，写得人都懵了，改成一维数组，感觉世界都清晰多了...”
>
> **点评**：流绪的经验提醒我们，数据结构的选择会直接影响代码的复杂度。对于魔方这种每个块位置明确的问题，一维数组（按顺序存储每个块）比二维数组更直观，能减少坐标转换的麻烦。这对我们来说是一个重要的编码技巧——选择最贴合问题的简单数据结构！

-----

<conclusion>
本次关于“Cube”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握枚举技巧，理解魔方问题的解决思路。记住，遇到“可能情况有限”的问题时，枚举是最直接有效的方法！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：142.41秒
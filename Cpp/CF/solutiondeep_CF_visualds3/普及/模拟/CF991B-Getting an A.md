# 题目信息

# Getting an A

## 题目描述

Translator's note: in Russia's most widespread grading system, there are four grades: 5, 4, 3, 2, the higher the better, roughly corresponding to A, B, C and F respectively in American grading system.

The term is coming to an end and students start thinking about their grades. Today, a professor told his students that the grades for his course would be given out automatically — he would calculate the simple average (arithmetic mean) of all grades given out for lab works this term and round to the nearest integer. The rounding would be done in favour of the student — $ 4.5 $ would be rounded up to $ 5 $ (as in example 3), but $ 4.4 $ would be rounded down to $ 4 $ .

This does not bode well for Vasya who didn't think those lab works would influence anything, so he may receive a grade worse than $ 5 $ (maybe even the dreaded $ 2 $ ). However, the professor allowed him to redo some of his works of Vasya's choosing to increase his average grade. Vasya wants to redo as as few lab works as possible in order to get $ 5 $ for the course. Of course, Vasya will get $ 5 $ for the lab works he chooses to redo.

Help Vasya — calculate the minimum amount of lab works Vasya has to redo.

## 说明/提示

In the first sample, it is enough to redo two lab works to make two $ 4 $ s into $ 5 $ s.

In the second sample, Vasya's average is already $ 4.75 $ so he doesn't have to redo anything to get a $ 5 $ .

In the second sample Vasya has to redo one lab work to get rid of one of the $ 3 $ s, that will make the average exactly $ 4.5 $ so the final grade would be $ 5 $ .

## 样例 #1

### 输入

```
3
4 4 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4
5 4 5 5
```

### 输出

```
0
```

## 样例 #3

### 输入

```
4
5 3 3 5
```

### 输出

```
1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Getting an A 深入学习指南 💡

<introduction>
今天我们来一起分析“Getting an A”这道C++编程题。这道题需要我们帮助Vasya通过重考尽可能少的实验，使得平均分四舍五入后达到5分。本指南将梳理题目思路，解析核心算法，并通过可视化和代码赏析帮助大家高效掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决“Getting an A”这道题，关键在于理解并运用贪心算法。贪心算法就像“每次吃最甜的那颗糖”——每一步选择当前最优的局部解，最终达到全局最优。在本题中，我们的目标是用最少的重考次数让平均分≥4.5（四舍五入为5），因此每次选择**当前分数最低的实验重考**（因为重考最低分能最快提升总分），这就是贪心策略的核心应用。

- **题解思路与核心难点**：  
  所有题解的核心思路高度统一：先计算初始总分，若平均分≥4.5则直接输出0；否则，将实验分数从小到大排序（或用优先队列维护最小值），每次重考当前最低分（将其改为5分），更新总分后再次判断是否达标，直到满足条件。  
  核心难点在于**如何高效处理四舍五入条件**（避免浮点数精度问题）和**如何选择最优重考顺序**。优质题解通过将分数扩大十倍（如将4.5转化为45）或直接比较总分与4.5n的关系（如2*总分≥9n）巧妙解决了浮点数问题；而选择重考顺序时，排序或优先队列确保了每次处理的都是当前最低分，保证了贪心的正确性。

- **可视化设计思路**：  
  我们将设计一个8位像素风格的动画，用“实验分数条”（不同高度的像素块，颜色越深分数越低）动态展示重考过程。每次重考时，最低分的像素块（红色）会“升级”为绿色（代表5分），总分和平均分实时更新（用像素数字显示）。关键步骤（如选择最低分、更新总分）会伴随“叮”的音效，达标时播放胜利音效并弹出“获得5分！”的像素对话框。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下3道题解因逻辑简洁、实现高效且易于学习，被评为优质题解（≥4星）：
</eval_intro>

**题解一：作者C_Cong**  
* **点评**：此题解思路非常清晰，通过将分数扩大十倍（如4.5转化为45）巧妙避免了浮点数运算，代码规范且逻辑直白。排序后从最低分开始重考的贪心策略直接且高效，边界条件处理严谨（如循环终止条件为总分≥45n）。代码中变量名`src`（原始分数）、`sum`（总分）含义明确，实践价值高（可直接用于竞赛）。作者还提到“扩大十倍处理”的技巧，这是避免精度问题的经典方法，值得重点学习。

**题解二：作者Arghariza**  
* **点评**：此题解代码简洁，逻辑流畅。通过排序后逐个重考最低分的方式实现贪心，用`sum`动态维护总分，判断条件`sum/(double)n >=4.5`直接明了。变量名`ans`（重考次数）、`s`（总分）易于理解，代码结构工整，适合新手学习贪心算法的基础实现。

**题解三：作者TRZ_2007**  
* **点评**：此题解巧妙使用优先队列（小顶堆）维护最低分，避免了重复排序，时间复杂度更优（O(n log n)）。通过不等式`2*s >=9*n`（等价于平均分≥4.5）避免浮点数运算，代码高效且鲁棒。优先队列的选择体现了对数据结构的灵活运用，是进阶学习的好例子。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们可能会遇到以下核心难点。结合优质题解的共性，我们逐一分析并给出策略：
</difficulty_intro>

1.  **关键点1**：如何处理四舍五入的条件？  
    * **分析**：题目要求平均分四舍五入后为5，即平均分≥4.5。直接计算浮点数可能因精度问题出错（如4.499999被误判）。优质题解通过两种方式解决：  
      - **扩大十倍法**（如C_Cong题解）：将每个分数×10，总分×10，判断总分≥45n（即原平均分≥4.5）。  
      - **整数比较法**（如TRZ_2007题解）：原条件等价于总分×2≥9n（因为4.5n×2=9n），避免浮点数运算。  
    * 💡 **学习笔记**：涉及浮点数比较时，将问题转化为整数运算可避免精度误差。

2.  **关键点2**：如何选择重考的实验？  
    * **分析**：要最小化重考次数，需每次重考对总分提升最大的实验。由于重考后的分数固定为5，提升量为（5-原分数），因此应优先重考原分数最低的实验（提升量最大）。优质题解通过排序或优先队列（小顶堆）实现这一策略。  
    * 💡 **学习笔记**：贪心的核心是“局部最优→全局最优”，本题中“优先重考最低分”是局部最优选择。

3.  **关键点3**：如何高效判断何时停止重考？  
    * **分析**：每次重考后需更新总分，并判断是否满足条件。优质题解通过动态维护总分（如`sum +=5 - a[i]`）并实时比较，确保每一步都能快速判断是否达标，避免了重复计算。  
    * 💡 **学习笔记**：动态维护关键变量（如总分）是优化算法效率的常用技巧。

### ✨ 解题技巧总结
- **浮点数转整数**：涉及四舍五入或浮点数比较时，将问题转化为整数运算（如扩大倍数或乘法比较），避免精度问题。  
- **贪心选择顺序**：需要最小化操作次数时，优先处理对目标贡献最大的元素（如本题中最低分）。  
- **动态维护关键值**：通过变量实时更新总分、最小值等关键信息，减少重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解前，我们先看一个综合优质题解思路的通用核心实现，它结合了“扩大十倍法”和排序策略，逻辑清晰且易于理解。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了C_Cong题解的“扩大十倍法”和Arghariza题解的排序策略，旨在提供一个清晰、完整的核心实现。  
* **完整核心代码**：  
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        int scores[105];
        int sum = 0;
        for (int i = 0; i < n; ++i) {
            cin >> scores[i];
            scores[i] *= 10; // 扩大十倍，避免浮点数
            sum += scores[i];
        }
        sort(scores, scores + n); // 从小到大排序
        int count = 0;
        while (sum < 45 * n) { // 总分需≥45n（即原平均分≥4.5）
            sum += (50 - scores[count]); // 将最低分改为5（即50）
            count++;
        }
        cout << count << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并将每个分数扩大十倍（如4分变为40，5分变为50），计算初始总分。接着排序分数数组（从小到大），然后循环重考当前最低分（`scores[count]`），将其改为50（即5分），更新总分，直到总分≥45n（对应原平均分≥4.5）。最终输出重考次数`count`。

---
<code_intro_selected>
接下来，我们剖析3道优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者C_Cong**  
* **亮点**：通过扩大十倍处理浮点数，避免精度问题；排序后逐个重考最低分，逻辑直白。  
* **核心代码片段**：  
    ```cpp
    sort(src+1,src+n+1);
    int cot=0;
    while(n*45>=sum){
        cot++;
        sum=sum-src[cot]+50;
    }
    ```
* **代码解读**：  
  这段代码是贪心策略的核心。首先将分数数组排序（从小到大），然后进入循环：若当前总分不满足`n*45`（即原平均分<4.5），则重考当前最低分（`src[cot]`），将其改为50（5分×10），更新总分`sum`，并增加重考次数`cot`。循环终止时，`cot`即为最少重考次数。  
* 💡 **学习笔记**：扩大十倍法是处理浮点数比较的经典技巧，能有效避免`double`精度问题。

**题解二：作者Arghariza**  
* **亮点**：代码简洁，直接使用`double`计算平均分，逻辑清晰。  
* **核心代码片段**：  
    ```cpp
    sort(s + 1, s + n + 1, less<double>());
    for (int i = 1; i <= n; i++) {
        ans++;
        sum += (5 - s[i]);
        if (sum / (double)n >= 4.5) {
            cout << ans;
            return 0;
        }
    }
    ```
* **代码解读**：  
  这段代码先将分数数组从小到大排序，然后逐个重考最低分（`s[i]`）。每次重考时，总分`sum`增加（5 - 原分数），并判断新的平均分是否≥4.5。若达标则输出当前重考次数`ans`。  
* 💡 **学习笔记**：直接使用`double`计算平均分更直观，但需注意浮点数精度（如`sum`和`n`均为整数时，`sum/(double)n`的精度足够）。

**题解三：作者TRZ_2007**  
* **亮点**：使用优先队列（小顶堆）维护最低分，避免重复排序，时间复杂度更优。  
* **核心代码片段**：  
    ```cpp
    priority_queue<int, vector<int>, greater<int>> q;
    while(2 * s < 9 * n) {
        cnt++;
        s += (5 - q.top());
        q.pop(); q.push(5);
    }
    ```
* **代码解读**：  
  这段代码使用小顶堆`q`存储分数，每次取出堆顶（当前最低分），将其改为5分（更新总分`s`），然后将5分重新入堆。循环直到总分满足`2*s >=9*n`（即平均分≥4.5）。优先队列的优势在于每次取最小值的时间复杂度为O(log n)，比排序更高效（尤其当n很大时）。  
* 💡 **学习笔记**：优先队列（堆）是动态维护最小值/最大值的高效数据结构，适合需要频繁取最值的场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法如何选择重考实验，我们设计一个“像素实验员”主题的8位复古动画，让大家“看”到每一步的选择和分数变化！
</visualization_intro>

  * **动画演示主题**：像素实验员的“5分冲刺”  
  * **核心演示内容**：展示实验分数条（像素块）的排序、重考最低分的过程，以及总分和平均分的动态更新，直到平均分达标。  
  * **设计思路简述**：采用8位像素风格（如FC游戏的简洁色调），用不同颜色标记分数（红色≤3，黄色=4，绿色=5），通过动态移动和颜色变化突出重考操作。音效（如“叮”声）强化关键步骤记忆，游戏化的“过关”提示增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示n个像素块（高度代表分数，颜色：红/黄/绿），顶部标注“当前分数”；右侧显示“总分”（像素数字）和“平均分”（如4.3→4.5→4.7）。  
        - 控制面板包含“开始”“单步”“重置”按钮和速度滑块（1x-5x）。  
        - 播放8位风格的轻快背景音乐（如《超级马力欧》的经典旋律）。

    2.  **初始状态展示**：  
        - 像素块按分数从小到大排列（左低右高），红色块（如3分）在最左，黄色块（4分）在中间，绿色块（5分）在最右。  
        - 总分和平均分用像素数字显示（如总分13，n=3→平均分4.3）。

    3.  **重考操作演示**：  
        - 点击“开始”或“单步”，动画进入重考流程：  
          - **选择最低分**：最左侧的红色块（当前最低分）周围出现闪烁的白色边框，伴随“叮”的音效。  
          - **重考为5分**：红色块变为绿色（高度拉满），同时总分数字增加（如13→13+2=15），平均分更新（如4.3→5.0）。  
          - **重新排序**：所有像素块自动重新排列（保持从小到大），绿色块移到右侧。

    4.  **达标提示**：  
        - 当平均分≥4.5时，屏幕中央弹出像素风格的“5分达成！”对话框，播放上扬的胜利音效（如《超级马力欧》吃金币音效），所有绿色块开始闪烁庆祝。  
        - 若点击“重置”，动画回到初始状态，可重新观察流程。

    5.  **交互与控制**：  
        - 学习者可通过“单步”按钮逐次查看重考过程，通过速度滑块调整动画速度（如慢放时看清分数变化）。  
        - 鼠标悬停在像素块上时，显示具体分数（如“3分”），帮助理解排序逻辑。

<visualization_conclusion>
通过这个像素动画，我们能清晰看到贪心算法如何一步步选择最低分重考，直观感受“每次选择最优局部解”的核心思想，学习效率大大提升！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在“最小化操作次数”类问题中应用广泛。掌握本题后，我们可以尝试以下拓展练习，巩固贪心思维：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    贪心算法的核心是“局部最优→全局最优”，适用于：  
    - 资源分配问题（如分配最少数量的物品满足条件）；  
    - 调度问题（如安排任务使总时间最短）；  
    - 排序优化问题（如通过排序最小化总成本）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1223 排队接水**  
        * 🗣️ **推荐理由**：经典贪心题，需按接水时间从小到大排序，最小化总等待时间，与本题“重考最低分”的贪心思路类似。  
    2.  **洛谷 P1094 纪念品分组**  
        * 🗣️ **推荐理由**：需将纪念品配对，使每组总价≤给定值，贪心策略是“最大+最小”配对，锻炼对贪心顺序的理解。  
    3.  **洛谷 P2240 分糖果**  
        * 🗣️ **推荐理由**：需将糖果分给小朋友，使至少k个小朋友得到至少m颗，贪心选择需求最小的小朋友优先分配，与本题“优先处理最需要提升的实验”思路一致。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者C_Cong提到：“扩大十倍处理浮点数，避免了强制转换的麻烦。”这是一个非常实用的调试技巧。
</insights_intro>

> **参考经验 (来自 C_Cong)**：“我在处理四舍五入时，一开始用`double`计算平均分，结果因为精度问题（如4.499999被误判为4.5）卡了很久。后来想到将分数扩大十倍，用整数运算，问题迎刃而解。”  
> **点评**：C_Cong的经验提醒我们，涉及浮点数比较时，将问题转化为整数运算是避免精度错误的有效方法。在编程中，遇到类似问题（如判断`a/b >=c`），可以尝试将不等式两边同乘b（注意b的正负），转化为整数比较。

-----

<conclusion>
本次关于“Getting an A”的C++解题分析就到这里。希望这份指南能帮助你掌握贪心算法的核心思想，学会用“扩大十倍法”处理浮点数问题，并通过像素动画直观理解算法流程。记住，多动手编写代码、调试和思考，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：146.64秒
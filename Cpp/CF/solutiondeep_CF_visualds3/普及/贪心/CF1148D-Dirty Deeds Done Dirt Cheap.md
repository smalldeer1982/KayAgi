# 题目信息

# Dirty Deeds Done Dirt Cheap

## 题目描述

有 $n$ 个整数对 $(a_1, b_1), (a_2, b_2), \cdots, (a_n, b_n)$. 保证 $a_1, b_1, a_2, b_2, \cdots, a_n, b_n$ 两两不相等, 并且均在区间 $[1, 2 \cdot n]$ 内.



好序列的定义:  

对于一个序列 $x_1, x_2, \cdots, x_{2k}$, 满足

- $x_1 < x_2 > x_3 < \cdots < x_{2k - 2} > x_{2k - 1} < x_{2k}$ 或

- $x_1 > x_2 < x_3 > \cdots > x_{2k - 2} < x_{2k - 1} > x_{2k}$.



求一个序列 $i_1, i_2, \cdots, i_t$ 满足 $a_{i_1}, b_{i_1}, a_{i_2}, b_{i_2}, \cdots, a_{i_t}, b_{i_t}$ 是好序列.



输出 $t$ 的最大值以及对应的序列 $i_1, i_2, \cdots, i_t$.

## 说明/提示

$2 \leq n \leq 3 \cdot 10^5$  

$1 \leq a_i, b_i \leq 2 \cdot n$  

并且所有 $a_i, b_i$ 两两不相等.



### 样例解释

样例 1: $1 < 7 > 3 < 5 > 2 < 10$.



样例 2: $6 > 1 < 3 > 2 < 5 > 4$.

## 样例 #1

### 输入

```
5
1 7
6 4
2 10
9 8
3 5
```

### 输出

```
3
1 5 3
```

## 样例 #2

### 输入

```
3
5 4
3 2
6 1
```

### 输出

```
3
3 2 1
```

# AI分析结果


### 题目解读与核心算法识别  
**本题主要考察**：`贪心策略与排序应用`  

🗣️ **初步分析**：  
> 本题需要构造最长"好序列"，核心在于发现两类互斥的序列模式：  
> **第一类序列**：`a < b > c < d > ...`（先升后降交替）  
> **第二类序列**：`a > b < c > d < ...`（先降后升交替）  
>   
> **关键突破点**：  
> 1. 每个数对要么属于第一类（`a_i < b_i`），要么属于第二类（`a_i > b_i`），二者互斥  
> 2. 同类数对可排序后直接连接：  
>   - 第一类按 `b_i` **降序** → 保证 `b_i > a_{i+1}`  
>   - 第二类按 `b_i` **升序** → 保证 `b_i < a_{i+1}`  
>   
> **可视化设计思路**：  
> 采用**像素贪吃蛇**风格演示：  
> - 第一类数对用蓝色像素块表示（`a_i`→头，`b_i`→尾）  
> - 第二类用红色像素块表示  
> - 排序时像素块按`b_i`值在数轴上跳动重组  
> - 连接时显示"蛇头咬蛇尾"动画（`b_i`与`a_{i+1}`碰撞时触发8-bit音效）  

---

### 精选优质题解参考  
**题解一（作者：mraymes）**  
* **点评**：  
  思路直击本质，将数对分类后分别排序的策略简洁高效。代码中：  
  - 用`pair`嵌套存储原下标（`ppi`结构）避免索引丢失  
  - 通过反存`(y,x)`实现单关键字排序（第一类降序，第二类升序）  
  - 边界处理严谨（排除`a_i=b_i`情况）  
  **亮点**：空间复杂度`O(1)`的原地排序，完美满足竞赛需求  

---

### 核心难点辨析与解题策略  
1. **难点一：识别序列构造规律**  
   * **分析**：必须发现两类序列互斥且内部可链式连接，这是突破题目的关键  
   * 💡 **学习笔记**：复杂序列问题常可分解为独立子模式  

2. **难点二：确定排序关键字**  
   * **分析**：  
     - 第一类需保证`b_i > a_{i+1` → 按`b_i`降序（较大`b_i`优先）  
     - 第二类需保证`b_i < a_{i+1` → 按`b_i`升序（较小`b_i`优先）  
   * 💡 **学习笔记**：排序方向由连接点的数学关系决定  

3. **难点三：维护原下标映射**  
   * **分析**：用`pair<数据对, 原下标>`结构，排序时自动携带索引  
   * 💡 **学习笔记**：涉及重排输出的问题需同步存储原标识  

**✨ 解题技巧总结**  
- **模式分解**：将复杂交替序列拆解为同向子链  
- **贪心验证**：通过极端值（最大/最小）优先保证可连接性  
- **索引绑定**：用`pair/second`存储原编号避免丢失  

---

### C++核心代码实现赏析  
**通用核心实现**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n; cin >> n;
    vector<pair<pair<int, int>, int>> typeA, typeB; // <(b,a), 原下标>
    
    for (int i=1; i<=n; i++) {
        int a, b; cin >> a >> b;
        if (a < b) typeA.push_back({{b, a}, i}); // 反存便于排序
        else if (a > b) typeB.push_back({{b, a}, i});
    }
    
    // 第一类：按b降序 | 第二类：按b升序
    sort(typeA.rbegin(), typeA.rend());
    sort(typeB.begin(), typeB.end());
    
    auto& ans = (typeA.size() > typeB.size()) ? typeA : typeB;
    cout << ans.size() << "\n";
    for (auto& p : ans) cout << p.second << " ";
}
```

**题解一代码解析**  
```cpp
// 分类存储（核心片段）
if (x < y) {                  // 第一类数对
    a[++n1] = ppi(pii(y, x), i); // 反存(y,x)
} else if (x > y) {           // 第二类数对
    b[++n2] = ppi(pii(y, x), i);
}

// 排序控制（精妙之处）
sort(a + 1, a + n1 + 1, greater<ppi>()); // 第一类降序
sort(b + 1, b + n2 + 1);                 // 第二类升序
```
> **关键行解读**：  
> - `ppi(pii(y,x),i)`：将`(b,a)`与原下标绑定存储  
> - `greater<ppi>`：实现降序排序（默认升序）  
> - 比较时实际按`pair.first`（即`b`值）排序  
> **学习笔记**：通过数据反存将双关键字比较简化为单关键字  

---

### 算法可视化：像素动画演示  
**主题**：`贪吃蛇数对连接大冒险`  

**核心演示流程**：  
1. **初始化场景**：  
   - 数轴背景（1~2n像素刻度）  
   - 数对显示为双格像素块（蓝：a<b，红：a>b）  
   <img src="https://via.placeholder.com/300x100?text=数轴初始分布" width=200>  

2. **分类动画**：  
   - 蓝色块向左集合，红色块向右集合（伴随方向音效）  

3. **排序过程**：  
   - 第一类：像素块按`b值`从右向左降序跳动（泡泡排序动画）  
   - 第二类：像素块按`b值`从左向右升序移动  

4. **贪吃蛇连接**：  
   ``` 
   ██→██→██ 第一类连接示例（蓝蛇）
   b1 > a2 → b2 > a3 → ...（触发"叮"声）
   ```  
   - 蛇头（当前`b_i`）与蛇尾（下一`a_i`）碰撞检测  

5. **胜利结算**：  
   - 显示最长序列（像素蛇闪光+胜利音效）  

**交互设计**：  
- **控制面板**：单步/自动模式、速度滑块  
- **音效方案**：  
  - 移动："嘀"（8-bit短音）  
  - 连接成功："叮↑"（上旋音阶）  
  - 错误连接："哔——"（长警告音）  

---

### 拓展练习与相似问题  
1. **洛谷 P1090**：合并果子（贪心+优先队列）  
   > 巩固贪心选择极值的思维  

2. **洛谷 P1106**：删数问题（单调栈应用）  
   > 学习通过删除构造最优序列  

3. **洛谷 P1233**：木棍加工（双关键字排序）  
   > 拓展多维排序贪心技巧  

---

### 学习心得与经验分享  
> 本次题解未包含作者调试心得，但核心经验已融入难点分析。记住：  
> **Kay的总结**：当遇到复杂序列构造时，先尝试寻找可独立处理的子结构，再通过排序/极值选择实现链式连接！  

--- 
💡 通过本指南，你已掌握贪心排序的核心应用。尝试用可视化思路重写代码，感受算法之美吧！

---
处理用时：175.44秒
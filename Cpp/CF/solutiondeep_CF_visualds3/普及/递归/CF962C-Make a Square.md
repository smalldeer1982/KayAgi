# 题目信息

# Make a Square

## 题目描述

You are given a positive integer $ n $ , written without leading zeroes (for example, the number 04 is incorrect).

In one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.

Determine the minimum number of operations that you need to consistently apply to the given integer $ n $ to make from it the square of some positive integer or report that it is impossible.

An integer $ x $ is the square of some positive integer if and only if $ x=y^2 $ for some positive integer $ y $ .

## 说明/提示

In the first example we should delete from $ 8314 $ the digits $ 3 $ and $ 4 $ . After that $ 8314 $ become equals to $ 81 $ , which is the square of the integer $ 9 $ .

In the second example the given $ 625 $ is the square of the integer $ 25 $ , so you should not delete anything.

In the third example it is impossible to make the square from $ 333 $ , so the answer is -1.

## 样例 #1

### 输入

```
8314
```

### 输出

```
2
```

## 样例 #2

### 输入

```
625
```

### 输出

```
0
```

## 样例 #3

### 输入

```
333
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Make a Square 深入学习指南 💡

<introduction>
今天我们来一起分析“Make a Square”这道C++编程题。这道题的核心是通过删除最少的数字，将给定正整数变成一个完全平方数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与子序列匹配`

🗣️ **初步分析**：
解决“Make a Square”这道题，关键在于理解如何高效枚举可能的完全平方数，并判断其是否是原数字的子序列。简单来说，枚举就是“逐个尝试可能的候选”，而子序列匹配可以理解为“在原数字中按顺序找到候选数字的所有位”。例如，原数字是8314（即[8,3,1,4]），候选平方数是81（即[8,1]），我们需要检查原数字中是否存在一个子序列（如第0位的8和第2位的1）刚好组成81。

- **题解思路**：主要有两种思路。一种是枚举所有可能的平方数（从大到小），检查是否是原数字的子序列（如GusyNight、Wf_yjqd的题解）；另一种是通过DFS枚举原数字的所有可能子序列，判断是否为平方数（如Andy_Li、QianianXY的题解）。前者更高效（因为平方数数量远少于子序列数量），后者更直观但可能冗余。
- **核心难点**：如何高效枚举平方数并快速判断子序列；如何处理前导零（如保留的子序列不能以0开头）。
- **可视化设计**：计划用8位像素风格展示原数字的每一位（如绿色像素块），候选平方数的每一位（如黄色像素块）。动画中，用白色箭头从原数字的位指向候选平方数的位，匹配成功时播放“叮”的音效；若匹配失败则红色闪烁。AI自动演示时，会从最大的平方数开始尝试，逐步缩小范围。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出以下4星及以上题解：
</eval_intro>

**题解一：GusyNight（赞：9）**
* **点评**：此题解思路简洁高效。作者从最大的可能平方数（即原数的平方根）开始递减枚举，用双指针法判断平方数是否是原数字的子序列。代码中变量命名清晰（如`cnt1`记录原数字位数，`cnt2`记录平方数位数），边界处理严谨（如直接返回最少删除位数）。其核心思想是“从大到小枚举平方数，优先找到最长匹配子序列”，这能快速得到最小删除次数，是竞赛中典型的优化思路。

**题解二：QianianXY（赞：1）**
* **点评**：此题解采用DFS枚举所有可能的子序列，通过剪枝（如跳过前导零）优化效率。代码中`dfs(k, tot)`函数递归处理每一位的选择（保留或删除），并在递归终点检查是否为平方数。虽然时间复杂度略高，但思路直观，适合理解子序列枚举的过程。其对前导零的处理（`if (c[k] == '0' && !tot) return;`）是关键亮点，避免了无效枚举。

**题解三：Wf_yjqd（赞：1）**
* **点评**：此题解与GusyNight思路类似，但更注重代码的模块化（如`w(x)`函数计算数字位数，`f(x, s)`函数拆分数字到数组）。双指针匹配逻辑简洁（`j`遍历原数字，`k`遍历平方数，匹配则`k++`），代码结构工整，适合学习如何将问题拆解为函数调用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效枚举可能的平方数？
    * **分析**：直接枚举所有可能的平方数会超时，但原数最多9位，因此最大的平方数不超过原数本身（即平方根最大为√n）。优质题解通常从√n开始递减枚举，因为更长的平方数（即位数更多的）对应的删除次数更少，一旦找到即可直接返回。
    * 💡 **学习笔记**：从大到小枚举平方数，优先匹配最长子序列，能快速得到最优解。

2.  **关键点2**：如何判断一个数是否是原数字的子序列？
    * **分析**：子序列要求顺序一致但不要求连续。双指针法是高效的解决方案：用`i`遍历原数字的每一位，`j`遍历候选平方数的每一位，若原数字当前位等于平方数当前位，则`j++`。若最终`j`等于平方数的位数，则匹配成功。
    * 💡 **学习笔记**：双指针法是子序列匹配的经典方法，时间复杂度仅为O(n)（n为原数字位数）。

3.  **关键点3**：如何处理前导零？
    * **分析**：保留的子序列不能以0开头（除非子序列只有一位0，但题目要求正整数，所以0也不合法）。在枚举子序列时，若第一位选择0，需直接跳过；在枚举平方数时，若平方数本身以0开头（但平方数是正整数，所以不可能），可忽略此情况。
    * 💡 **学习笔记**：前导零的判断需在子序列生成或平方数枚举时提前处理，避免无效计算。

### ✨ 解题技巧总结
<summary_best_practices>
- **枚举优化**：从大到小枚举平方数，优先匹配更长的子序列，减少不必要的计算。
- **双指针匹配**：用两个指针分别遍历原数字和候选平方数，快速判断子序列关系。
- **前导零剪枝**：在DFS枚举子序列时，若当前选择的位是0且子序列为空，直接跳过，避免无效递归。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了GusyNight和Wf_yjqd的题解思路，采用枚举平方数+双指针匹配的方法，兼顾高效性和可读性。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        string s;
        cin >> s;
        int n = s.size();
        int min_ops = n; // 初始化为最大可能删除次数

        // 将原数字按位存入数组（顺序保持原顺序）
        vector<int> digits(n);
        for (int i = 0; i < n; ++i) {
            digits[i] = s[i] - '0';
        }

        // 枚举所有可能的平方数（从大到小）
        int max_square = stoi(s);
        for (int y = sqrt(max_square); y >= 1; --y) {
            int square = y * y;
            vector<int> sq_digits;
            // 将平方数拆分为各位数字（顺序保持原顺序）
            string sq_str = to_string(square);
            for (char c : sq_str) {
                sq_digits.push_back(c - '0');
            }

            // 双指针匹配子序列
            int i = 0, j = 0;
            while (i < n && j < sq_digits.size()) {
                if (digits[i] == sq_digits[j]) {
                    j++;
                }
                i++;
            }

            // 若匹配成功，更新最小删除次数
            if (j == sq_digits.size()) {
                min_ops = min(min_ops, n - (int)sq_digits.size());
                break; // 从大到小枚举，第一个找到的即最优解
            }
        }

        if (min_ops == n) {
            cout << -1 << endl;
        } else {
            cout << min_ops << endl;
        }

        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入数字并按位存储。然后从原数的平方根开始递减枚举平方数，将每个平方数拆分为各位数字。通过双指针法判断平方数是否是原数字的子序列：`i`遍历原数字，`j`遍历平方数，若匹配则`j`后移。若`j`遍历完平方数所有位，说明匹配成功，计算删除次数并更新最小值。由于从大到小枚举，第一个匹配成功的平方数对应最少删除次数，可直接返回。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：GusyNight**
* **亮点**：直接从原数的平方根开始枚举平方数，双指针匹配逻辑简洁，代码短小精悍。
* **核心代码片段**：
    ```cpp
    while(m)a[cnt1++]=m%10,m/=10; // 原数字按位存入数组（逆序）
    for(int i=sqrt(n);i>=1;i--){ // 从大到小枚举平方数
        long long x=i*i;cnt2=0;
        long long k=x;
        while(x)b[cnt2++]=x%10,x/=10; // 平方数按位存入数组（逆序）
        l=0;
        for(int j=0;j<cnt1;j++){ // 双指针匹配
            if(a[j]==b[l]){
                l++;
                if(l==cnt2)break;
            }
        }
        if(l==cnt2)return cout<<cnt1-l,0; // 匹配成功，输出删除次数
    }
    ```
* **代码解读**：
    > 原数字的各位被逆序存入数组`a`（如8314变为[4,1,3,8]），平方数的各位也被逆序存入数组`b`（如81变为[1,8]）。双指针`j`遍历原数字，`l`遍历平方数，若当前位匹配则`l`后移。若`l`等于平方数位数，说明匹配成功，删除次数为原数字位数减去平方数位数。逆序存储是为了方便从低位到高位处理，但需注意原数字的顺序是否与平方数一致（实际不影响，因为子序列只要求顺序一致）。
* 💡 **学习笔记**：逆序存储数字的各位是常见技巧，方便通过取模运算拆分数字，但需注意匹配时的顺序是否与原数字一致。

**题解二：QianianXY**
* **亮点**：DFS枚举所有可能的子序列，通过剪枝避免前导零，代码结构清晰。
* **核心代码片段**：
    ```cpp
    inline void dfs(int k, int tot) {
        if (k > len) {
            if (tot && check(tot)) ans = min(len - tot, ans); // 检查是否为平方数并更新答案
            return;
        }
        dfs(k + 1, tot); // 不选当前位
        if (c[k] == '0' && !tot) return; // 剪枝：前导零
        str[++tot] = c[k]; // 选当前位
        dfs(k + 1, tot);
    }
    ```
* **代码解读**：
    > `dfs(k, tot)`函数递归处理第`k`位的选择：不选当前位（直接递归`k+1`）或选当前位（若当前位是0且子序列为空则跳过，否则将当前位加入子序列`str`）。当递归到末尾（`k > len`）时，检查子序列是否为平方数（`check(tot)`），并更新最小删除次数（`len - tot`）。这种方法枚举所有可能的子序列，但通过前导零剪枝减少了无效递归。
* 💡 **学习笔记**：DFS枚举子序列时，剪枝是关键优化手段，能显著减少递归次数。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举平方数+双指针匹配”的过程，我设计了一个8位像素风格的动画演示方案。让我们一起“看”到算法如何工作！
</visualization_intro>

  * **动画演示主题**：`像素数字探险——寻找平方宝藏`

  * **核心演示内容**：展示原数字的每一位（如绿色像素块）和候选平方数的每一位（如黄色像素块），通过双指针移动匹配，最终找到能组成平方数的子序列。

  * **设计思路简述**：采用8位像素风（如FC游戏画面），用不同颜色区分原数字和候选平方数；关键操作（如匹配成功）伴随音效，增强记忆点；AI自动演示从大到小枚举平方数的过程，学习者可通过单步控制观察每一步匹配细节。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是原数字的像素块（如8314显示为[8,3,1,4]的绿色方块），右侧是候选平方数的像素块（初始为空）。
          * 控制面板包含：开始/暂停、单步、重置按钮；速度滑块（0.5x-2x）。
          * 播放8位风格的轻快背景音乐（如《超级马里奥》主题变奏）。

    2.  **枚举平方数**：
          * AI自动从最大的平方数（如√8314≈91，所以从91²=8281开始）开始枚举，右侧显示当前候选平方数（如8281的黄色方块）。

    3.  **双指针匹配**：
          * 白色箭头指向原数字的第0位（8）和候选平方数的第0位（8），匹配成功时箭头变绿，播放“叮”的音效，候选平方数指针右移。
          * 若原数字当前位（3）与候选平方数当前位（2）不匹配，箭头变红，原数字指针右移。
          * 匹配失败时，候选平方数变为红色闪烁，AI自动尝试下一个更小的平方数（如90²=8100）。

    4.  **匹配成功**：
          * 当候选平方数81（9²）被选中时，原数字的8（第0位）和1（第2位）成功匹配，双指针均到达末尾，候选平方数变为金色，播放“胜利”音效（如《超级玛丽》吃金币音效），屏幕显示“找到啦！删除次数：2”。

    5.  **交互控制**：
          * 学习者可点击“单步”按钮，手动控制每一步匹配；调整速度滑块，观察慢动作匹配过程；点击“重置”回到初始状态。

  * **旁白提示**：
      * （枚举平方数时）“现在尝试的是91的平方8281，看看原数字8314中有没有这个数的子序列~”
      * （匹配失败时）“8314中没有8281的子序列，试试更小的平方数吧！”
      * （匹配成功时）“哇，8314中找到了81的子序列！只需要删除2位，成功啦~”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到算法如何从大到小枚举平方数，并通过双指针快速匹配子序列。这种“看得见”的算法过程，能帮助我们更好地理解核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考子序列匹配和完全平方数相关的问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 子序列匹配不仅用于完全平方数问题，还可用于判断一个字符串是否是另一个字符串的子序列（如LeetCode 392题）、最长公共子序列等问题。
      * 枚举平方数的思路可迁移到寻找其他特殊数（如立方数、回文数）的问题中。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1102** - `A-B数对`
          * 🗣️ **推荐理由**：这道题需要枚举可能的数对，结合哈希表优化，能帮助你练习枚举与哈希表的结合使用。
    2.  **洛谷 P1057** - `传球游戏`
          * 🗣️ **推荐理由**：此题可通过动态规划或DFS解决，能帮助你巩固递归与状态转移的理解。
    3.  **洛谷 P1036** - `选数`
          * 🗣️ **推荐理由**：这道题需要枚举所有可能的选数组合并判断是否为质数，与本题的枚举思路类似，适合练习组合枚举。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些经验对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 QianianXY)**：“喜提最优解。细节看代码。”（虽然简短，但暗示了细节处理的重要性，如前导零的判断）
>
> **参考经验 (来自 千年陈皮精)**：“这一题不是很难，思路对了就行了。但是我调试了一个小时。”
>
> **点评**：这些经验提醒我们，即使思路正确，细节处理（如前导零、数组索引）也可能导致错误。调试时可以通过打印中间变量（如当前匹配的平方数、子序列的各位）来定位问题，这是非常有效的排错手段。

-----

<conclusion>
本次关于“Make a Square”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解枚举与子序列匹配的算法，以及如何处理前导零等细节问题。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：153.37秒
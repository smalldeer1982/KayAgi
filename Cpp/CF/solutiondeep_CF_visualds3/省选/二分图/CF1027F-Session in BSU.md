# 题目信息

# Session in BSU

## 题目描述

Polycarp studies in Berland State University. Soon he will have to take his exam. He has to pass exactly $ n $ exams.

For the each exam $ i $ there are known two days: $ a_i $ — day of the first opportunity to pass the exam, $ b_i $ — day of the second opportunity to pass the exam ( $ a_i < b_i $ ). Polycarp can pass at most one exam during each day. For each exam Polycarp chooses by himself which day he will pass this exam. He has to pass all the $ n $ exams.

Polycarp wants to pass all the exams as soon as possible. Print the minimum index of day by which Polycarp can pass all the $ n $ exams, or print -1 if he cannot pass all the exams at all.

## 样例 #1

### 输入

```
2
1 5
1 7
```

### 输出

```
5
```

## 样例 #2

### 输入

```
3
5 13
1 5
1 7
```

### 输出

```
7
```

## 样例 #3

### 输入

```
3
10 40
40 80
10 80
```

### 输出

```
80
```

## 样例 #4

### 输入

```
3
99 100
99 100
99 100
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Session in BSU 深入学习指南 💡

<introduction>
今天我们来一起分析“Session in BSU”这道C++编程题。题目要求我们找到Polycarp通过所有考试的最早最后一天，或判断无法完成的情况。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（基环树/树结构分析）与并查集应用

🗣️ **初步分析**：
解决这道题的关键在于理解时间点与考试之间的依赖关系。我们可以将每个考试的两个时间点（a_i, b_i）视为图中的边，时间点本身是图中的节点。这样，问题转化为分析图的连通块结构：

- **图论视角**：每个连通块的边数（考试数）与点数（时间点数）的关系决定了是否有解。若边数 > 点数（无法分配），输出-1；若边数 = 点数（基环树），取该连通块的最大值；若边数 < 点数（树），取次大值。
- **并查集视角**：通过合并时间点，维护可选时间的连通性。若两个时间点已被合并且无剩余可选时间，则冲突；否则选择较小时间并合并，最终取各连通块的最大值。

核心算法流程：离散化时间点 → 构建图或并查集 → 分析连通块性质 → 计算结果。可视化设计可采用像素风格，用不同颜色标记时间点，动态展示合并或DFS遍历过程，高亮边数/点数关系变化及冲突提示。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下3道题解表现突出（评分≥4星）：
</eval_intro>

**题解一：ModestCoder_的并查集解法 (来源：洛谷用户ModestCoder_)**
* **点评**：此题解巧妙运用并查集处理时间点的合并与选择，思路简洁高效。代码中离散化处理清晰，变量名（如`f[]`表示父节点）易懂，边界条件（如两个时间点均被占用的判断）处理严谨。算法复杂度为O(n α(n))，适用于大规模数据。亮点在于通过并查集的合并操作，动态维护可选时间，避免了复杂的图遍历，实践价值极高。

**题解二：大菜鸡fks的图论解法 (来源：洛谷用户大菜鸡fks)**
* **点评**：此题解通过构建图模型，分析连通块的边数与点数关系，逻辑清晰。代码中DFS遍历连通块，计算最大值和次大值，边界条件（如边数>点数时输出-1）处理到位。虽然代码稍复杂，但完整展示了图论模型的应用，适合理解问题本质。

**题解三：hsfzLZH1的图论解法 (来源：洛谷用户hsfzLZH1)**
* **点评**：此题解将考试视为边，时间点视为点，通过DFS分析连通块性质，与大菜鸡fks的思路类似但实现更简洁。代码中离散化和邻接表构建规范，关键变量（如`max1`、`max2`）含义明确，适合学习图论建模的核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点，结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：如何建模时间点与考试的关系？**
    * **分析**：将每个考试的两个时间点视为边，时间点本身为节点，构建图模型；或用并查集合并时间点，维护连通性。图模型直观展示依赖关系，适合分析连通块性质；并查集则通过路径压缩高效处理合并与查询。
    * 💡 **学习笔记**：建模是解决问题的第一步，选择图或并查集需根据问题规模（如n=1e6时并查集更优）。

2.  **关键点2：如何判断是否存在可行解？**
    * **分析**：图模型中，若连通块的边数 > 点数（无法分配），输出-1；并查集中，若某考试的两个时间点均被占用（父节点为0），则冲突。
    * 💡 **学习笔记**：边数与点数的关系是判断可行解的核心条件（基环树/树结构的性质）。

3.  **关键点3：如何计算最早最后一天？**
    * **分析**：图模型中，基环树取最大值，树取次大值；并查集中，维护各连通块的最大值（合并时选择较小时间，最终取所有连通块的最大值）。
    * 💡 **学习笔记**：最大值与次大值的选择取决于连通块的结构（基环树需覆盖所有边，树则可舍弃一个节点）。

### ✨ 解题技巧总结
- **离散化处理**：将大范围时间点映射到小范围，便于数组操作（如用`lower_bound`实现）。
- **并查集路径压缩**：优化查询效率，避免超时（适用于大规模数据）。
- **连通块分析**：通过DFS或并查集遍历，明确各连通块的性质（边数、点数、最值）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，采用并查集方法，简洁高效，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合ModestCoder_和LXH5514的并查集思路，处理离散化、合并与冲突检测，适用于大规模数据。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 2e6 + 10;

    int n, m;
    int a[MAXN], b[MAXN];
    int d[MAXN * 2]; // 存储所有时间点，用于离散化
    int f[MAXN * 2]; // 并查集父节点数组

    int find(int x) {
        return f[x] == x ? x : f[x] = find(f[x]);
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%d%d", &a[i], &b[i]);
            d[2 * i - 1] = a[i];
            d[2 * i] = b[i];
        }
        // 离散化
        sort(d + 1, d + 2 * n + 1);
        m = unique(d + 1, d + 2 * n + 1) - d - 1;
        for (int i = 1; i <= n; ++i) {
            a[i] = lower_bound(d + 1, d + m + 1, a[i]) - d;
            b[i] = lower_bound(d + 1, d + m + 1, b[i]) - d;
        }
        // 初始化并查集
        for (int i = 1; i <= m; ++i) f[i] = i;
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            int x = find(a[i]), y = find(b[i]);
            if (x == 0 && y == 0) { // 两个时间均被占用
                puts("-1");
                return 0;
            }
            if (x == y || x == 0 || y == 0) { // 合并或标记为已占用
                ans = max(ans, max(d[x], d[y]));
                f[x] = f[y] = 0;
            } else { // 合并较小的时间到大的时间
                if (x > y) swap(x, y);
                ans = max(ans, d[x]);
                f[x] = y;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并离散化时间点，将大范围时间映射到小范围。通过并查集`f[]`维护时间点的连通性，遍历每个考试的两个时间点，合并或标记冲突。最终输出所有连通块的最大时间点，若冲突则输出-1。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：ModestCoder_的并查集解法**
* **亮点**：离散化与并查集结合，代码简洁，冲突检测直接。
* **核心代码片段**：
    ```cpp
    int get(int k) { return k == f[k] ? k : f[k] = get(f[k]); }
    // ...
    int s1 = get(a[(i << 1) - 1].v), s2 = get(a[i << 1].v);
    if (!s1 && !s2) { puts("-1"); return 0; }
    if (s1 == s2 || !s1 || !s2) { ans = max(ans, max(num[s1], num[s2])); f[s1] = f[s2] = 0; } else{
        if (s1 > s2) swap(s1, s2);
        ans = max(ans, num[s1]); f[s1] = s2;
    }
    ```
* **代码解读**：
    `get`函数实现路径压缩优化并查集查询。对于每个考试的两个时间点，查询其根节点`s1`和`s2`：若均为0（被占用），输出-1；若根相同或至少一个被占用，取最大值并标记为已占用；否则合并较小的根到较大的根，更新答案。
* 💡 **学习笔记**：并查集的路径压缩是优化关键，合并时选择较小时间可保证局部最优，最终全局最优。

**题解二：大菜鸡fks的图论解法**
* **亮点**：通过DFS分析连通块的边数、点数及最值，逻辑清晰。
* **核心代码片段**：
    ```cpp
    void dfs(int u) {
        if (vis[u]) return;
        if (u > mx1) mx2 = mx1, mx1 = u;
        else if (u > mx2) mx2 = u;
        vis[u] = 1; sz++;
        for (int i = head[u]; i; i = e[i].next) {
            ed++; dfs(e[i].link);
        }
    }
    // ...
    if (ed / 2 > sz) { puts("-1"); return; }
    else {
        if (ed / 2 == sz) ans = max(ans, mx1);
        else ans = max(ans, mx2);
    }
    ```
* **代码解读**：
    DFS遍历连通块，统计点数`sz`、边数`ed`及最大值`mx1`、次大值`mx2`。边数需除以2（无向图），若边数>点数则冲突；若边数=点数（基环树）取最大值；否则（树）取次大值。
* 💡 **学习笔记**：DFS遍历是分析连通块性质的基础，需注意无向图边数的统计（每条边被访问两次）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解并查集的合并过程，我们设计一个“时间小探险家”像素动画，模拟时间点的合并与冲突检测。
</visualization_intro>

  * **动画演示主题**：像素时间岛大冒险（8位复古风格）
  * **核心演示内容**：小探险家在时间岛上合并时间点，遇到冲突时触发警报，最终找到最晚时间点。
  * **设计思路简述**：8位像素风格营造轻松氛围，时间点用彩色方块表示，合并用箭头连接，冲突用红色闪烁提示，音效（合并“叮”、冲突“嘟”）强化操作记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕展示时间岛（网格背景），时间点为彩色方块（a_i蓝色，b_i绿色），控制面板（开始/暂停、单步按钮）。
    2. **离散化映射**：将大时间点映射到小方块，显示映射表（如“真实时间1→方块1”）。
    3. **合并操作**：小探险家移动到当前考试的两个时间方块，尝试合并：
       - 若未合并过（父节点不同），用箭头连接，较小方块滑入较大方块（合并），播放“叮”音效。
       - 若已合并（父节点相同），方块变红闪烁，标记为已占用，播放“滴”音效。
    4. **冲突检测**：若两个时间方块均被占用（父节点为0），屏幕变红，播放“嘟”音效，显示“-1”。
    5. **结果展示**：所有考试处理完毕后，最大时间方块高亮，播放“胜利”音效，显示最终答案。

  * **旁白提示**：
    - “现在处理第i场考试，时间点是a和b。”
    - “两个时间未合并过，合并较小的a到b！”
    - “糟糕，两个时间都被占用了，无法安排！”

<visualization_conclusion>
通过这样的动画，我们能直观看到并查集的合并过程，理解冲突检测和结果计算的逻辑，学习效率大大提升！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下拓展练习，巩固图论与并查集的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    并查集和图论建模可用于处理资源分配问题（如会议室安排、课程冲突），关键是将资源（时间、房间）映射为节点，任务（考试、会议）映射为边，分析连通块性质。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3367** - 并查集模板题  
        🗣️ **推荐理由**：巩固并查集的路径压缩与按秩合并，理解基础操作。
    2.  **洛谷 P1197** - [JSOI2008]星球大战  
        🗣️ **推荐理由**：逆向并查集应用，学习动态维护连通性。
    3.  **洛谷 P2024** - [NOI2001]食物链  
        🗣️ **推荐理由**：扩展并查集（带权并查集），处理复杂关系。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试经验，例如处理离散化错误或并查集合并顺序，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自ModestCoder_)**：“一开始没注意离散化后的索引是否正确，导致样例4输出错误。后来通过打印离散化后的数组，发现重复时间点未正确去重。”
>
> **点评**：离散化是处理大范围数据的关键，需确保`unique`和`lower_bound`的正确使用。调试时打印中间结果（如离散化后的时间点）能有效定位错误。

---

<conclusion>
本次关于“Session in BSU”的C++解题分析就到这里。希望这份指南能帮助大家理解图论与并查集的应用，掌握离散化和连通块分析的技巧。记住，多动手调试、多思考模型是提升编程能力的关键！下次见～💪
</conclusion>

---
处理用时：124.94秒
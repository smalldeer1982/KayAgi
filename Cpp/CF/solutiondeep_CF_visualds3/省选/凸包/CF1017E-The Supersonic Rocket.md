# 题目信息

# The Supersonic Rocket

## 题目描述

战争结束后，超音速火箭成为了最常见的公共交通工具。

每个超音速火箭由两个“引擎”组成。每个引擎是一组“能量源”。第一个引擎有 $n$ 个能量源，第二个引擎有 $m$ 个能量源。每个能量源可以表示为二维平面上的一个点 $(x_i, y_i)$。每个引擎内的所有点都不相同。

你可以分别对每个引擎进行操作。每个引擎可以进行以下两种操作，每种操作可以执行任意多次。

1. 对该引擎的所有能量源整体平移：$(x_i, y_i)$ 变为 $(x_i+a, y_i+b)$，其中 $a$ 和 $b$ 可以是任意实数。也就是说，所有能量源会整体平移。
2. 对该引擎的所有能量源整体旋转：$(x_i, y_i)$ 变为 $(x_i \cos \theta - y_i \sin \theta, x_i \sin \theta + y_i \cos \theta)$，其中 $\theta$ 可以是任意实数。也就是说，所有能量源会整体旋转。

引擎的工作方式如下：当两个引擎启动后，它们的能量源会合并（此时不同引擎的能量源可能重合）。如果存在两个能量源 $A(x_a, y_a)$ 和 $B(x_b, y_b)$，那么对于所有满足 $0 < k < 1$ 的实数 $k$，会生成一个新的能量源 $C_k(kx_a + (1-k)x_b, ky_a + (1-k)y_b)$。然后，使用所有新旧能量源重复这一过程。最终，会生成所有能量源形成的“能量场”（可以看作是所有出现过的能量源的无限集合）。

如果经过你对引擎的操作后，任意删除一个能量源并再次启动引擎，所生成的能量场与未删除任何能量源时相同，则称该超音速火箭是“安全”的。只有当两个能量场中的任意一个能量源都属于另一个能量场时，才认为两个能量场相同。

给定一个超音速火箭，判断它是否安全。

## 说明/提示

第一个样例：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1017E/1f54366cb2efd6f1fd1d0617b722b5e3979dfd89.png) 图中靠近的蓝色和橙色点实际上是重合的。首先，对第一个引擎进行操作：使用第二种操作，取 $\theta = \pi$（即将所有能量源旋转 $180$ 度）。

第一个引擎的能量源变为 $(0, 0)$、$(0, -2)$ 和 $(-2, 0)$。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1017E/d9732486b953667a46772450be0d244f2cb20626.png) 然后，对第二个引擎进行操作：使用第一种操作，取 $a = b = -2$。

第二个引擎的能量源变为 $(-2, 0)$、$(0, 0)$、$(0, -2)$ 和 $(-1, -1)$。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1017E/f5d3a1ffc842f837240530d5f9c0ef57b3d408b7.png) 你可以验证，无论删除哪一个点，由两个引擎形成的能量场始终是由 $(0, 0)$、$(-2, 0)$、$(0, -2)$ 组成的实心三角形。

在第二个样例中，无论如何操作引擎，总存在第二个引擎中的某个能量源，使得删除它后能量场会缩小。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 4
0 0
0 2
2 0
0 2
2 2
2 0
1 1
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
3 4
0 0
0 2
2 0
0 2
2 2
2 0
0 0
```

### 输出

```
NO
```

# AI分析结果

# 💡 Kay的C++算法解析：The Supersonic Rocket 深入学习指南 💡

今天我们来一起分析“The Supersonic Rocket”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`凸包算法 + 循环序列匹配（KMP）`

### 🗣️ 初步分析
解决这道题的关键，就像给两个“点集小怪物”**穿衣服**——先给它们穿上最外层的“凸包外套”（只保留最外层的点，提取形状特征），再把“外套”的细节（边的长度、相邻边的夹角）转化为“字符串”，最后判断这两个“字符串”是不是**循环同构**（比如“abc”和“bca”是循环移位，算同一个）。

- **凸包算法**：像给点集围篱笆，只留最外层的点。比如样例1中的点集，围完篱笆后变成三角形，这就是凸包。
- **循环序列匹配**：把凸包的边+角转化为序列（比如边长度1.414，夹角π/4，边长度1，夹角π/2…），然后用KMP算法判断两个序列是否循环同构——把其中一个序列“拉长”一倍（比如“abc”变“abcabc”），看另一个序列是不是它的子串。

### 核心算法流程与可视化设计
1. **凸包生成**：用像素点表示点集，逐步用蓝色像素线连接凸包点（每加一个点“叮”一声），最后围成一个闭合的“篱笆”。
2. **序列生成**：用红色像素块表示边长度（块越大长度越长），绿色像素块表示夹角（块旋转角度等于夹角），按顺序排成序列。
3. **KMP匹配**：用黄色高亮当前匹配的位置，匹配成功时“叮”一声，完全匹配时播放“胜利”音效（比如FC游戏的“通关音”），展示循环同构的过程。


## 2. 精选优质题解参考

为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面，筛选了以下评分较高的题解：

### 题解二：KKarshilov（赞：2）
**点评**：这份题解的思路像“拆积木”一样清晰——先算凸包，再转序列，最后KMP匹配。代码规范得像“整理好的书包”：变量名（比如`ConvexHull`函数）一看就懂，注释清楚，连凸包的“上下两部分”都分步骤写。尤其是把“边长度+夹角”转化为序列的部分，完美捕捉了凸包的形状特征，KMP的应用也很标准，是入门的好参考。

### 题解一：cjlak1o1（赞：9）
**点评**：此题解用“三角形稳定性”（边边边证全等）来保证特征的唯一性，思路很巧妙！比如把凸包上的三个边组成三角形，用三角形的边长来代表凸包的局部特征。代码里的`Andrew`函数处理凸包，`build1`/`build2`生成序列，最后用KMP匹配。美中不足的是有些调试信息（比如`Debug`输出），但不影响核心逻辑。

### 题解三：Nelofus（赞：1）
**点评**：此题解用“哈希”来判断循环同构，思路很新颖！比如给每个凸包点的“向量点积”计算哈希值，然后比较哈希值是否相同。代码里的`ConvexHull`函数和哈希计算都很严谨，但哈希函数的设计（比如随机base）需要一点数学基础，适合想深入的同学。


## 3. 核心难点辨析与解题策略

在解决这道题时，大家常遇到以下难点，我们一起拆解：

### 难点1：怎么正确计算凸包？
**分析**：凸包要“围紧”点集，不能漏点也不能多加点。比如样例1中的点集，凸包是三角形，要是多连了内部点就错了。
**解决方案**：用Andrew算法——先按x坐标排序点，然后分“下凸壳”（从左到右连点）和“上凸壳”（从右到左连点），用叉积判断点是否在当前凸壳的“外侧”（叉积>0就保留，否则删掉）。

### 难点2：怎么把凸包转化为可比较的序列？
**分析**：凸包的形状由边长度和相邻边的夹角决定，比如三角形的边是1,1,1.414，夹角是π/2,π/4,π/4，这样的序列能唯一表示三角形。
**解决方案**：按顺时针或逆时针顺序，把凸包的“边长度”和“相邻边的夹角”交替存入序列（比如边1→角1→边2→角2…）。

### 难点3：怎么判断循环同构？
**分析**：比如序列A是“边1-角1-边2-角2”，序列B是“边2-角2-边1-角1”，它们是循环同构，要判断为相同。
**解决方案**：把其中一个序列“拉长”一倍（比如A变“边1-角1-边2-角2-边1-角1-边2-角2”），然后用KMP算法找另一个序列是不是它的子串。

### ✨ 解题技巧总结
1. **形状提取用凸包**：不管点集多乱，凸包能帮你抓住“核心形状”。
2. **特征转化用序列**：把几何特征（边、角）转化为“字符串”，用字符串算法（KMP、哈希）解决。
3. **循环同构用倍长**：把序列拉长一倍，KMP找子串，轻松解决循环问题。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了题解二的思路，是“凸包+KMP”的典型实现，逻辑清晰，适合入门。
**完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define eps 1e-8
using namespace std;

struct Point { double x, y; Point(double x=0, double y=0):x(x),y(y){} };
typedef Point Vector;

Vector operator-(Vector a, Vector b) { return Vector(a.x-b.x, a.y-b.y); }
double Cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }
double Length(Vector a) { return sqrt(a.x*a.x + a.y*a.y); }
double Angle(Vector a, Vector b) { return acos((a.x*b.x + a.y*b.y)/Length(a)/Length(b)); }

int ConvexHull(Point *p, int n, Point *ch) {
    sort(p, p+n, [](Point a, Point b) { return a.x < b.x || (a.x == b.x && a.y < b.y); });
    int m = 0;
    for (int i=0; i<n; i++) {
        while (m>1 && Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) >= 0) m--;
        ch[m++] = p[i];
    }
    int k = m;
    for (int i=n-2; i>=0; i--) {
        while (m>k && Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) >= 0) m--;
        ch[m++] = p[i];
    }
    return n>1 ? m-1 : m;
}

int nxt[200010];
bool chdb(double a, double b) { return fabs(a-b) <= eps; }

void GetNext(double *t, int len) {
    nxt[0] = -1; int j = -1;
    for (int i=1; i<len; i++) {
        while (j!=-1 && !chdb(t[i], t[j+1])) j = nxt[j];
        if (chdb(t[i], t[j+1])) j++;
        nxt[i] = j;
    }
}

bool KmpSearch(double *s, double *t, int sLen, int tLen) {
    int j = -1;
    for (int i=0; i<sLen; i++) {
        while (j!=-1 && !chdb(s[i], t[j+1])) j = nxt[j];
        if (chdb(s[i], t[j+1])) j++;
        if (j == tLen-1) return true;
    }
    return false;
}

int main() {
    int n, m; cin >> n >> m;
    Point p1[100010], p2[100010];
    for (int i=0; i<n; i++) cin >> p1[i].x >> p1[i].y;
    for (int i=0; i<m; i++) cin >> p2[i].x >> p2[i].y;

    Point ch1[200010], ch2[200010];
    int len1 = ConvexHull(p1, n, ch1);
    int len2 = ConvexHull(p2, m, ch2);
    if (len1 != len2) { cout << "NO"; return 0; }

    double s[400010], t[200010];
    int cnts=0, cntt=0;
    for (int i=0; i<len1; i++) {
        s[cnts++] = Length(ch1[(i+1)%len1] - ch1[i]);
        s[cnts++] = Angle(ch1[(i+2)%len1] - ch1[(i+1)%len1], ch1[(i+1)%len1] - ch1[i]);
    }
    for (int i=0; i<len2; i++) {
        t[cntt++] = Length(ch2[(i+1)%len2] - ch2[i]);
        t[cntt++] = Angle(ch2[(i+2)%len2] - ch2[(i+1)%len2], ch2[(i+1)%len2] - ch2[i]);
    }

    for (int i=cnts; i<2*cnts-1; i++) s[i] = s[i-cnts];
    GetNext(t, cntt);
    if (KmpSearch(s, t, 2*cnts-2, cntt)) cout << "YES";
    else cout << "NO";
    return 0;
}
```
**代码解读概要**：
1. **凸包计算**：`ConvexHull`函数用Andrew算法生成凸包。
2. **序列生成**：把凸包的边长度和夹角存入`s`和`t`数组。
3. **KMP匹配**：`GetNext`算next数组，`KmpSearch`判断循环同构。


### 题解二核心代码片段赏析
**题解二：KKarshilov（来源：洛谷题解）**
**亮点**：把“边+角”转化为序列，完美捕捉凸包形状。
**核心代码片段**：
```cpp
// 生成凸包特征序列
for(int i = 0; i < sum1; i++) {
    S[cnts++] = Length(c1[i + 1] - c1[i]); // 边长度
    S[cnts++] = Angle(c1[i + 2] - c1[i + 1], c1[i + 1] - c1[i]); // 相邻边夹角
}
// KMP匹配
for(int i = cnts; i < cnts * 2 - 1; i++) S[i] = S[i - cnts]; // 倍长序列
GetNext(T, nxt, cntt);
if(KmpSearch(S, T, cnts * 2 - 2, cntt - 1)) puts("YES");
```
**代码解读**：
- `Length`函数算边长度，`Angle`函数算相邻边的夹角（比如边AB和边BC的夹角是∠ABC）。
- 把序列`S`倍长（比如`S`是“a b c”，倍长后是“a b c a b”），这样就能包含所有循环移位的可能。
- `GetNext`算KMP的next数组，`KmpSearch`找`T`是不是`S`的子串。

**学习笔记**：用“边+角”的序列能唯一表示凸包形状，倍长序列是解决循环同构的“神器”！


## 5. 算法可视化：像素动画演示

### 动画主题：《像素凸包探险家》
**设计思路**：用8位FC游戏风格，让你像“探险家”一样一步步“围篱笆”（凸包）、“读序列”（边+角）、“找匹配”（KMP），边玩边学！

### 动画细节（可实现）
1. **场景初始化**：
   - 屏幕：800x600像素，背景浅灰色，点集用白色像素点（比如样例1的点集）。
   - 控制面板：左上角有“开始/暂停”（红色按钮）、“单步”（蓝色按钮）、“重置”（黄色按钮），下方有速度滑块（0~10档）。
   - 背景音乐：FC风格的《冒险岛》轻快BGM（循环播放）。

2. **凸包生成**：
   - 点击“开始”，用蓝色像素线逐步连接凸包点（比如从最左点开始，依次连到下一个凸包点）。
   - 每连一个点，播放“叮”的音效（像FC游戏的“收集道具音”）。
   - 凸包生成完成时，播放“胜利”音效（比如《超级马里奥》的“通关音”），凸包线变成黄色。

3. **序列生成**：
   - 凸包下方显示“特征序列”区域：红色方块代表边长度（方块宽度=边长度/10），绿色旋转方块代表夹角（旋转角度=夹角*180/π）。
   - 比如边长度1.414→红色方块宽14像素，夹角π/4→绿色方块旋转45度。

4. **KMP匹配**：
   - 用黄色高亮当前匹配的位置（比如`S`序列中的第i位和`T`序列中的第j位）。
   - 匹配成功时，播放“叮”音效；完全匹配时，整个序列区域闪烁，播放“胜利”音效。
   - 匹配失败时，播放“咔嗒”音效（像FC游戏的“撞墙音”），重置匹配位置。

### 交互设计
- **单步执行**：点击“单步”，动画走一步（比如连一个凸包点，或匹配一个序列位）。
- **速度调节**：滑块调速度（1档最慢，10档最快）。
- **重置**：点击“重置”，回到初始状态（点集、凸包、序列都清空）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **凸包的应用**：判断点是否在凸包内（比如P1553）、计算凸包面积（比如P2742）。
- **循环同构的应用**：判断两个字符串是否循环移位相同（比如P4557）、判断两个数组是否循环同构（比如P1226）。

### 洛谷拓展练习推荐
1. **P2742 【模板】二维凸包**：巩固Andrew算法的实现，像“练基本功”一样重要！
2. **P3375 【模板】KMP字符串匹配**：练习KMP的next数组和匹配过程，是解决循环同构的基础。
3. **P1553 数字反转（升级版）**：虽然题目是数字反转，但可以用凸包判断点是否在多边形内，练手凸包的应用。
4. **P4557 循环之美**：判断两个字符串是否循环同构，用KMP或哈希解决，拓展循环同构的思路。


## 7. 学习心得与经验分享

### 题解二作者的经验
**参考经验**：“旋转同构转循环同构是关键！把几何问题转化为字符串问题，用KMP解决，比直接想几何方法简单太多。”
**点评**：这位作者的思路像“换了个视角看问题”——把“形状相同”转化为“序列循环同构”，这是编程中的“转化思维”，超有用！比如遇到几何题不会做，试试转成字符串或数学问题。


## 总结

本次关于“The Supersonic Rocket”的分析就到这里！记住：
- 凸包是“形状提取器”，帮你抓住点集的核心形状；
- 序列是“形状翻译器”，把几何特征转成字符串；
- KMP是“循环匹配器”，帮你判断两个序列是不是循环同构。

编程像“搭积木”，一步步来，你一定能学会！下次我们再一起探索新的挑战～💪

---
处理用时：117.45秒
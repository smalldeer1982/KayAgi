# 题目信息

# On the Bench

## 题目描述

A year ago on the bench in public park Leha found an array of $ n $ numbers. Leha believes that permutation $ p $ is right if for all $ 1<=i&lt;n $ condition, that $ a_{pi}·a_{pi+1} $ is not perfect square, holds. Leha wants to find number of right permutations modulo $ 10^{9}+7 $ .

## 说明/提示

For first example:

 $ [1,2,4] $ — right permutation, because $ 2 $ and $ 8 $ are not perfect squares.

 $ [1,4,2] $ — wrong permutation, because $ 4 $ is square of $ 2 $ .

 $ [2,1,4] $ — wrong permutation, because $ 4 $ is square of $ 2 $ .

 $ [2,4,1] $ — wrong permutation, because $ 4 $ is square of $ 2 $ .

 $ [4,1,2] $ — wrong permutation, because $ 4 $ is square of $ 2 $ .

 $ [4,2,1] $ — right permutation, because $ 8 $ and $ 2 $ are not perfect squares.

## 样例 #1

### 输入

```
3
1 2 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
7
5 2 4 2 4 1 1
```

### 输出

```
144
```

# AI分析结果

# 💡 Kay的C++算法解析：On the Bench 深入学习指南 💡

<introduction>
今天我们来一起分析经典的排列计数问题——"On the Bench"。这道题看似复杂，但只要抓住**问题转化**和**动态规划/容斥原理**的核心，就能迎刃而解。本指南将帮你梳理思路、理解算法，并通过像素动画直观感受解题过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）、组合数学（容斥原理）、问题转化技巧

🗣️ **初步分析**：
解决本题的关键第一步是**问题转化**——我们发现：两个数的乘积是完全平方数，当且仅当它们**除去所有平方因子后的值相等**（比如12=2²×3，18=3²×2，除去平方因子后分别为3和2，乘积3×2=6不是平方数；而4=2²×1，1=1²×1，除去平方因子后都是1，乘积1×1=1是平方数）。

因此，我们可以先将每个数除以其所有平方因子（比如12→3，18→2，4→1），问题就转化为：**求原序列的排列数，使得相邻元素在转化后的值不同**（因为转化后相等的元素相乘必为平方数）。

接下来，核心算法围绕**“统计相邻不同的排列数”**展开，主要有两种思路：
1. **插入式DP**：逐步插入元素，记录当前相邻相同的对数，通过状态转移避免非法情况；
2. **容斥原理**：先计算所有排列，再减去包含非法相邻的情况，通过组合数学快速计算。

### 可视化设计思路
我们将用**8位像素风格**展示插入式DP的过程：
- 用不同颜色的像素块代表转化后的值（比如红色=1，蓝色=2，绿色=3）；
- 用“队列”动画展示当前已插入的序列，高亮当前插入的位置；
- 用“数字气泡”显示当前相邻相同的对数（比如气泡显示“j=2”表示有2对相邻相同）；
- 插入时播放“叮”的音效，若插入后产生新的相同相邻则播放“嗡”的提示音，完成所有插入后播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面筛选了3份优质题解，覆盖了DP和容斥的核心方法：
</eval_intro>

### 题解一：NaN_HQJ2007_NaN的三种方法总结（覆盖DP与容斥）
* **点评**：这份题解是“全能选手”——不仅提供了**插入式DP**（F1）、**分组插入DP**（F2），还给出了**容斥优化方法**（F3），完美覆盖了本题的所有核心思路。其中F3的容斥方法复杂度仅O(n²)，是最高效的实现方式。题解中的状态定义清晰（比如F3中的`f[i][j]`表示前i组转化后的值，分成j块的方案数），代码注释详细，非常适合初学者理解“从暴力到优化”的过程。

### 题解二：lgswdn_SA的三种方法对比（理论+实现）
* **点评**：这份题解的亮点是**理论与实践结合**——不仅解释了每种方法的时间复杂度（比如O(n³)的DP、O(n²)的容斥），还提供了合并后的代码实现。作者特别强调了“将相同值的元素分组”的关键技巧，帮助学习者快速抓住问题本质。此外，题解中提到的“多项式优化”（O(n log²n)）虽然未实现，但为进阶学习提供了方向。

### 题解三：Kewth的容斥原理（简洁高效）
* **点评**：这份题解的容斥思路非常简洁——通过“钦定i对相邻相同”，用组合数学计算非法方案数，再用容斥系数调整。代码中的卷积合并（`g_x`数组）巧妙处理了不同值的分组问题，时间复杂度O(n²)，是竞赛中的“得分利器”。作者对组合数和阶乘的预处理也非常规范，值得学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于**问题转化**和**状态设计**，以下是三个关键问题及解决策略：
</difficulty_intro>

### 1. 如何将“乘积为平方数”转化为“元素相等”？
* **分析**：这是本题的“破题点”。通过数学推导（两数乘积为平方数→质因数指数全为偶数→除去平方因子后值相等），我们将原问题转化为“相邻元素不同”的排列计数，这是所有后续算法的基础。
* 💡 **学习笔记**：遇到“乘积/和为特殊数”的问题，先尝试**质因数分解**或**等价转化**，将问题简化为已知模型。

### 2. 如何设计DP状态记录相邻相同的情况？
* **分析**：插入式DP的核心是记录“当前相邻相同的对数”（比如`dp[i][j]`表示前i个元素，有j对相邻相同）。通过枚举“将当前元素分成k块插入”，计算对j的影响（比如分成k块会减少k-1对相同，同时新增`cnt_i -k`对相同）。
* 💡 **学习笔记**：DP状态要“抓住变化的核心”——本题中“相邻相同的对数”是唯一影响后续插入的因素，因此状态只需记录这个值。

### 3. 如何用容斥原理快速计算合法方案？
* **分析**：容斥的关键是“计算非法方案的贡献”。通过枚举“将每个值的元素分成b_i块”，计算所有可能的非法情况，再用`(-1)^{n-B}`调整（B是总块数）。最终合法方案数是所有可能的块数的加权和。
* 💡 **学习笔记**：容斥原理适用于“求不满足某些条件的方案数”——将“不允许相邻相同”转化为“允许相邻相同，但减去非法贡献”。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择**NaN_HQJ2007_NaN的容斥方法（F3）**作为通用实现，因为它效率高（O(n²)）、思路清晰，是竞赛中的最优解法。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自NaN_HQJ2007_NaN的F3方法，是容斥原理的经典实现，适用于所有类似“相邻元素不同”的排列计数问题。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=300+5, mod=1e9+7;
ll n, m, a[N], s[N], fac[N], inv[N], f[N][N];

// 去除x的所有平方因子
void fen(ll &x) {
    for(ll i=2; i*i<=x; ++i)
        while(x%(i*i)==0) x /= i*i;
}

// 组合数计算（预处理阶乘和逆元）
ll C(int x, int y) {
    if(y>x || y<0) return 0;
    return fac[x] * inv[x-y] % mod * inv[y] % mod;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n;
    for(int i=1; i<=n; ++i) { cin >> a[i]; fen(a[i]); }
    sort(a+1, a+n+1);
    
    // 预处理阶乘和逆元
    fac[0] = fac[1] = inv[0] = inv[1] = 1;
    for(int i=2; i<=n; ++i) {
        fac[i] = fac[i-1] * i % mod;
        inv[i] = (mod - mod/i) * inv[mod%i] % mod;
    }
    for(int i=2; i<=n; ++i) inv[i] = inv[i-1] * inv[i] % mod;
    
    // 统计每个转化后的值的出现次数（分组）
    for(int i=1; i<=n; ++i) {
        m += (a[i] != a[i-1]);
        ++s[m];
    }
    
    // DP初始化：前0组，分成0块的方案数为1
    f[0][0] = 1;
    ll sum = 0;
    for(int i=1; i<=m; ++i) {
        sum += s[i];
        // 枚举当前组分成k块，转移到j块
        for(int j=1; j<=sum; ++j) {
            for(int k=1; k<=min((ll)j - i + 1, s[i]); ++k) {
                f[i][j] = (f[i][j] + f[i-1][j-k] * C(s[i]-1, k-1) % mod * inv[k] % mod) % mod;
            }
        }
    }
    
    // 容斥计算答案：乘积阶乘 × 容斥和
    ll t = 1;
    for(int i=1; i<=m; ++i) t = t * fac[s[i]] % mod;
    ll ans = 0;
    for(int i=m; i<=n; ++i) {
        ll tmp = t * fac[i] % mod * f[m][i] % mod;
        if((n - i) & 1) tmp = (mod - tmp) % mod;
        ans = (ans + tmp) % mod;
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **问题转化**：`fen`函数去除每个数的平方因子，将问题转化为“相邻元素不同”；
  2. **预处理**：计算阶乘`fac`和逆元`inv`，用于组合数计算；
  3. **分组统计**：统计每个转化后的值的出现次数`s[m]`；
  4. **容斥DP**：`f[i][j]`表示前i组值，分成j块的方案数，通过枚举当前组的块数k转移；
  5. **计算答案**：用容斥系数`(-1)^{n-i}`调整，乘以阶乘得到最终方案数。


## 5. 算法可视化：像素动画演示（核心部分）

<visualization_intro>
我们用**8位红白机风格**展示“插入式DP”的过程，帮你直观理解“如何避免相邻相同”：
</visualization_intro>

### 动画设计细节
1. **场景初始化**：
   - 屏幕左侧是“已插入序列”（用彩色像素块表示，比如红色=1，蓝色=2，绿色=3）；
   - 屏幕右侧是“控制面板”：包含“单步执行”“自动播放”按钮，以及“当前相邻相同对数”显示（比如`j=0`）；
   - 背景是复古的网格地图，播放8位风格的轻快BGM。

2. **核心步骤演示**：
   - **插入元素**：当前要插入的元素（比如蓝色）会闪烁，然后从“待插入区”滑入序列中的某个位置；
   - **状态更新**：若插入后产生新的相邻相同（比如蓝色旁边已有蓝色），则对应位置的像素块会“抖动”，并播放“嗡”的提示音，同时`j`值加1；
   - **合法插入**：若插入后没有相邻相同，则像素块“发光”，播放“叮”的音效，`j`值不变。

3. **游戏化元素**：
   - **关卡设计**：将插入过程分为“初始化→插入第1个元素→插入第2个元素→…→完成”，每完成一个步骤显示“关卡完成”；
   - **积分奖励**：每插入一个元素且不产生新的相同相邻，获得10分，累计积分显示在屏幕顶部；
   - **AI演示**：点击“AI自动播放”，算法会自动选择最优插入位置，快速完成所有步骤，展示“如何高效避免相邻相同”。

### 关键帧示例
- **帧1**：初始状态，序列为空，`j=0`；
- **帧2**：插入第一个元素（红色），序列变为`[红]`，`j=0`，播放“叮”；
- **帧3**：插入第二个元素（蓝色），序列变为`[红,蓝]`，`j=0`，播放“叮”；
- **帧4**：插入第三个元素（红色），选择插入到蓝色后面，序列变为`[红,蓝,红]`，`j=0`，播放“叮”；
- **帧5**：插入第四个元素（红色），只能插入到最前面或最后面（否则会产生相邻相同），序列变为`[红,红,蓝,红]`，`j=1`，播放“嗡”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（问题转化+DP/容斥）可以迁移到很多排列计数问题，比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：求“相邻元素不能是同一种类”的排列数（比如颜色排列、单词排列）；
- **场景2**：求“相邻元素差不能为1”的排列数（类似本题的“相邻不能相同”，只需调整转化规则）；
- **场景3**：求“不允许连续出现k次相同元素”的排列数（扩展本题的“不允许连续1次”）。

### 洛谷练习推荐
1. **洛谷 P4448** - [AHOI2018初中组] 球球的排列  
   * 🗣️ **推荐理由**：本题的“双倍经验”，完全相同的问题，直接用容斥或DP即可解决，巩固核心思路。
   
2. **洛谷 P1243** - 排书  
   * 🗣️ **推荐理由**：考察“排列中的相邻操作”，需要设计DP状态记录相邻情况，是本题的变形练习。
   
3. **洛谷 P2532** - [AHOI2012] 树屋阶梯  
   * 🗣️ **推荐理由**：考察组合数学中的卡特兰数，与本题的容斥原理异曲同工，帮助拓展组合数学思维。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们可以提炼出两个重要的学习心得：
</insights_intro>

> **心得1**：问题转化是解题的关键。  
> 本题的难点在于“将乘积为平方数转化为元素相等”，很多学习者会卡在这一步。通过质因数分解的推导，我们将陌生问题转化为熟悉的“相邻不同排列”，这是解题的核心突破口。  
> **点评**：遇到复杂问题时，先尝试“数学建模”或“等价转化”，将问题简化为已知模型，往往能事半功倍。

> **心得2**：容斥原理是处理“不允许”问题的神器。  
> 本题的容斥方法通过“计算所有可能的块数”，用容斥系数调整非法贡献，避免了暴力枚举的高复杂度。这种思路适用于很多“不允许某些条件”的计数问题。  
> **点评**：容斥原理的核心是“补集思想”——将“不允许A”转化为“允许A，但减去A的贡献”，这是竞赛中的常用技巧。


<conclusion>
本次关于“On the Bench”的分析就到这里。希望这份指南能帮你掌握**问题转化**、**动态规划**和**容斥原理**的核心技巧。记住：编程的本质是“将复杂问题拆解为简单步骤”，多思考、多练习，你一定能解决更多难题！💪
</conclusion>

---
处理用时：102.33秒
# 题目信息

# Shrink-Reverse

## 题目描述

给定一个长度为 $n$ 的二进制字符串 $s$（即由 $n$ 个字符组成，每个字符都是 $0$ 或 $1$）。

我们将 $s$ 看作某个整数的二进制表示，并称该整数为字符串 $s$ 的值。例如，$000$ 的值是 $0$，$01101$ 的值是 $13$，$100000$ 的值是 $32$，以此类推。

你最多可以对 $s$ 执行 $k$ 次操作。每次操作可以是以下两种类型之一：

- SWAP：选择 $s$ 中的两个下标 $i < j$，交换 $s_i$ 和 $s_j$；
- SHRINK-REVERSE：删除 $s$ 的所有前导零，然后将 $s$ 反转。

例如，对 $000101100$ 执行 SHRINK-REVERSE 操作后，会得到 $001101$。

请问，最多经过 $k$ 次操作后，$s$ 的最小可能值是多少？由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

注意，你需要最小化原始值，而不是最小化取模后的结果。

## 说明/提示

在第一个样例中，一种最优策略如下：

1. $10010010 \xrightarrow{\texttt{SWAP}} 00010110$；
2. $00010110 \xrightarrow{\texttt{SWAP}} 00000111$。

$00000111$ 的值为 $7$。

在第二个样例中，一种最优策略如下：

1. $01101000 \xrightarrow{\texttt{SHRINK}} 1101000 \xrightarrow{\texttt{REVERSE}} 0001011$；
2. $0001011 \xrightarrow{\texttt{SWAP}} 0000111$。

$0000111$ 的值为 $7$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
8 2
10010010```

### 输出

```
7```

## 样例 #2

### 输入

```
8 2
01101000```

### 输出

```
7```

## 样例 #3

### 输入

```
30 30
111111111111111111111111111111```

### 输出

```
73741816```

## 样例 #4

### 输入

```
14 1
10110001111100```

### 输出

```
3197```

# AI分析结果

---
# 💡 Kay的C++算法解析：Shrink-Reverse 深入学习指南 💡

大家好！今天我们要一起解决「Shrink-Reverse」这道二进制字符串操作题。这道题不仅考察贪心策略，还用到了**字符串处理的利器——后缀数组（SA）**，让我们一步步拆解它吧！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串（后缀数组应用） + 贪心策略`

### 🗣️ 初步分析
我们的目标是通过最多k次操作（交换或去前导零反转），让二进制字符串的值最小。二进制数的大小规则很简单：**越短越小，长度相同则字典序越小**。比如`111`（7）比`1000`（8）小，`0011`（3）和`0101`（5）长度相同，但前者字典序更小。

#### 核心算法的比喻解释
- **贪心策略**：就像整理玩具——把所有`1`尽可能“挤到一起”，让二进制数的长度最短。比如有3个`1`，如果能把它们全放在最后三位，得到`000111`（7），这比分散的`101010`（42）小得多！
- **后缀数组（SA）**：相当于给字符串的所有“尾巴”（后缀）按字典序排好队。比如字符串`1011`的后缀有`1011`、`011`、`11`、`1`，排好序后是`011`（第2位开始）、`1`（第4位）、`1011`（第1位）、`11`（第3位）。这样找最小字典序的后缀就像从队伍里挑第一个人，又快又准！

#### 题解思路与核心难点
所有题解都围绕两个关键结论展开：
1. **反转操作最多用1次**：反转两次的效果可以用交换替代，还能让结果更优（比如反转两次不如反转一次后交换）。
2. **最小化长度优先**：先把`1`聚集起来让二进制数最短，再比较字典序。

核心难点有三个：
- 如何证明“反转最多1次”？
- 如何用贪心聚集`1`？
- 如何快速比较不同区间的字典序？

**解决方案**：
- 用逻辑推导反转次数（两次反转的效果不如一次交换）；
- 贪心交换：把最前面的`1`和最后面的`0`交换（不反转时）；
- 后缀数组：给反转后的字符串建SA，快速找到最小字典序的区间。

#### 可视化设计思路
我们会用**8位像素风**模拟算法过程：
- 二进制串是像素块组成的“传送带”，`0`是蓝色，`1`是红色；
- 交换操作：两个像素块闪烁并交换位置，伴随“叮”的音效；
- 反转操作：传送带整体翻转，像素块从右往左滑动，伴随“哗啦”的音效；
- SA排序：后缀像“小火车”一样按字典序排队，排头的后缀用黄色高亮；
- 控制面板有“单步”“自动”按钮，速度滑块，还有8位风格的BGM！


## 2. 精选优质题解参考

为大家筛选了4篇思路清晰、代码规范的优质题解，一起来看看吧！

### 题解一：(来源：xiezheyuan)
* **点评**：这道题的“破题关键”被作者讲得明明白白！作者先证明了“反转最多1次”，再用**贪心交换**处理不反转的情况，用**后缀数组**处理反转后的情况。代码分成`solve0`（不反转）和`solve1`（反转）两个函数，逻辑清晰。尤其是`solve1`中用SA找最小字典序区间的部分，直接调用了后缀数组模板，非常规范！

### 题解二：(来源：sunkuangzheng)
* **点评**：作者的“性质分析”超有用！比如“答案串长度一定是最小的”“长度相同选字典序最小”，把问题拆解成“先缩长度，再比字典序”。代码中用了SA的倍增法实现，虽然复杂度是O(n log²n)，但对于5e5的数据也能过。更棒的是，作者在代码里加了注释，比如`lt = c - k`表示不能移动的`1`的数量，新手也能看懂！

### 题解三：(来源：MaxBlazeResFire)
* **点评**：作者用了**后缀自动机（SAM）**代替SA，复杂度降到了O(n)！这是非常高效的优化——SAM构建后缀数组的速度比倍增法更快，适合大数据。代码中`Sam.dfs`函数遍历SAM生成SA，逻辑很巧妙。虽然SAM的代码有点复杂，但作者把“不反转”和“反转”的处理分开，结构清晰，值得学习！


## 3. 核心难点辨析与解题策略

### 关键点1：为什么反转最多1次？
- **分析**：反转两次的效果是“去前导零→反转→再去前导零→再反转”，相当于去掉了原串的前导和后导零，但长度不变。而反转一次后，用交换操作把`1`聚集，能让长度更短（比如反转后的串`000100111`，交换后变成`1111`，长度4，比两次反转后的`111001`（长度6）更小）。
- 💡 学习笔记：操作次数要“省着用”，优先选能缩小长度的操作！

### 关键点2：如何贪心聚集`1`？
- **分析**：不反转时，把最前面的`1`和最后面的`0`交换（比如`10010010`→交换第1位和第8位→`00010110`，再交换第2位和第7位→`00000111`）。这样`1`都跑到后面，二进制数更短。
- 💡 学习笔记：贪心的核心是“优先解决影响最大的问题”——长度比字典序更重要！

### 关键点3：如何用SA比较字典序？
- **分析**：反转后的字符串，我们需要找“能容纳所有`1`的最短区间”，再比较这些区间的字典序。SA把所有后缀按字典序排好，直接取第一个符合条件的后缀即可（比如后缀`011`比`1011`小）。
- 💡 学习笔记：字符串比较的“神器”是后缀数组，它能把O(n²)的比较变成O(n log n)！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合了xiezheyuan和sunkuangzheng的思路，覆盖“不反转”和“反转+SA”两种情况，逻辑清晰。

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;

const int mod = 1e9 + 7;

// 不反转的贪心交换
string solve0(string s, int n, int k) {
    int L = 0, R = n - 1;
    while (k--) {
        // 找最前面的1
        while (L < n && s[L] == '0') L++;
        // 找最后面的0
        while (R >= 0 && s[R] == '1') R--;
        if (L >= R) break;
        swap(s[L], s[R]);
        L++; R--;
    }
    return s;
}

// 后缀数组模板（倍增法）
struct SuffixArray {
    vector<int> sa, rk, tmp;
    int n;

    SuffixArray(string s) {
        n = s.size();
        sa.resize(n);
        rk.resize(n);
        tmp.resize(n);
        for (int i = 0; i < n; i++) {
            sa[i] = i;
            rk[i] = s[i];
        }
        for (int k = 1; k < n; k <<= 1) {
            sort(sa.begin(), sa.end(), [&](int a, int b) {
                return rk[a] != rk[b] ? rk[a] < rk[b] : rk[(a + k) % n] < rk[(b + k) % n];
            });
            tmp[sa[0]] = 0;
            for (int i = 1; i < n; i++) {
                tmp[sa[i]] = tmp[sa[i-1]] + (rk[sa[i]] != rk[sa[i-1]] || rk[(sa[i]+k)%n] != rk[(sa[i-1]+k)%n]);
            }
            rk.swap(tmp);
        }
    }
};

// 反转后的处理（用SA找最小区间）
string solve1(string s, int n, int k) {
    reverse(s.begin(), s.end());
    SuffixArray sa(s);
    int total = count(s.begin(), s.end(), '1');
    vector<pair<int, int>> intervals;
    int cnt = 0, R = 0;
    for (int L = 0; L < n; L++) {
        while (R < n && !( (R-L+1 >= total) && (total - cnt <= k-1) )) {
            cnt += (s[R] == '1');
            R++;
        }
        if (R >= n) break;
        intervals.emplace_back(L, R-L+1);
        cnt -= (s[L] == '1');
    }
    // 找最小长度、最小字典序的区间
    pair<int, int> best = intervals[0];
    for (auto [l, len] : intervals) {
        if (len < best.second || (len == best.second && sa.rk[l] < sa.rk[best.first])) {
            best = {l, len};
        }
    }
    string ret = s.substr(best.first, best.second);
    int ext = total - count(ret.begin(), ret.end(), '1');
    reverse(ret.begin(), ret.end());
    for (char& c : ret) {
        if (c == '0' && ext-- > 0) c = '1';
    }
    reverse(ret.begin(), ret.end());
    return ret;
}

// 去掉前导零
string wash(string s) {
    size_t pos = s.find('1');
    if (pos == string::npos) return "0";
    return s.substr(pos);
}

int main() {
    int n, k;
    string s;
    cin >> n >> k >> s;
    string res0 = wash(solve0(s, n, k));
    string res1 = wash(solve1(s, n, k));
    string ans;
    if (res0.size() < res1.size()) ans = res0;
    else if (res0.size() > res1.size()) ans = res1;
    else ans = min(res0, res1);
    // 计算二进制值
    long long ret = 0;
    for (char c : ans) {
        ret = (ret * 2 + (c == '1')) % mod;
    }
    cout << ret << endl;
    return 0;
}
```

* **代码解读概要**：
  1. `solve0`：用双指针找最前的`1`和最后的`0`，交换k次；
  2. `solve1`：反转字符串后建SA，找能容纳所有`1`的最短区间，再调整`1`的位置；
  3. `wash`：去掉前导零，得到有效二进制串；
  4. 主函数：比较两种情况的结果，取最小的计算数值。


### 题解一（xiezheyuan）核心片段赏析
* **亮点**：用简洁的双指针实现贪心交换，SA模板清晰。
* **核心代码片段**：
  ```cpp
  string solve0(string s) {
      s = ' ' + s;
      int L = 1, R = n;
      string ret = s;
      for (int i = 1; i <= k; i++) {
          while (L <= n && s[L] != '1') L++;
          while (R >= 1 && s[R] != '0') R--;
          if (L > R) break;
          swap(ret[L], ret[R]);
          L++; R--;
      }
      return ret;
  }
  ```
* **代码解读**：
  - `L`找最前面的`1`，`R`找最后面的`0`；
  - 交换后，`L`右移、`R`左移，继续找下一对；
  - 最多交换k次，直到没有可交换的`1`和`0`。
* 💡 学习笔记：双指针是贪心交换的“标配”，简单又高效！


## 5. 算法可视化：像素动画演示

### 动画主题：《像素二进制大冒险》
用8位像素风模拟二进制串的操作过程，像玩FC游戏一样学算法！

### 核心演示内容
1. **场景初始化**：
   - 屏幕上是“像素传送带”，每个`0`是蓝色方块，`1`是红色方块；
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块，还有8位风格的BGM（比如《超级马里奥》的小背景音乐）。

2. **不反转的贪心交换**：
   - 传送带最前面的`1`（红色）和最后面的`0`（蓝色）闪烁；
   - 两个方块交换位置，伴随“叮”的音效；
   - 交换后的`1`移到后面，`0`移到前面，传送带更新。

3. **反转操作**：
   - 传送带整体翻转，像素块从右往左滑动，伴随“哗啦”的音效；
   - 反转后的串去掉前导零，剩下的部分用黄色框起来。

4. **SA排序后缀**：
   - 后缀像“小火车”一样排成一队，字典序小的后缀在前面；
   - 排头的后缀用黄色高亮，伴随“滴”的音效；
   - 选中最小的后缀后，传送带显示对应的区间，用绿色框起来。

### 交互设计
- 单步执行：点击“单步”，每一步操作慢动作展示；
- 自动播放：点击“自动”，算法按设定速度运行，像“AI玩游戏”一样；
- 重置：回到初始状态，重新开始演示。

### 音效设计
- 交换：“叮”（类似《吃豆人》的得分声）；
- 反转：“哗啦”（类似《魂斗罗》的换枪声）；
- 找到最小区间：“叮~”（类似《超级马里奥》的过关声）；
- BGM：循环播放《坦克大战》的背景音，轻松又复古！


## 6. 拓展练习与相似问题

### 通用思路迁移
- **后缀数组**：所有需要比较字符串后缀字典序的问题都能用，比如“找最小循环移位”“最长重复子串”；
- **贪心策略**：所有“最小化二进制数”的问题都优先缩小长度，比如“删除k个字符求最小数”。

### 洛谷推荐练习
1. **P3809 【模板】后缀数组**：后缀数组的基础模板题，帮你熟悉SA的构建；
2. **P4051 [JSOI2007]字符加密**：找最小循环移位，用SA快速解决；
3. **P2408 不同子串个数**：用后缀自动机（SAM）统计不同子串，巩固高效字符串算法；
4. **P1106 删数问题**：贪心删除字符求最小数，和本题的“缩小长度”思路一致！


## 7. 学习心得与经验分享

> **参考经验 (来自xiezheyuan)**：“这道题的难点不在SA本身，而在‘意识到反转最多1次’。我一开始想了很久，后来用‘两次反转的效果不如一次交换’的例子说服了自己。”
> 
> **点评**：作者的经验超棒！算法题的“破题点”往往在“性质推导”，而不是“代码实现”。遇到问题先想“有没有更优的操作方式”，而不是急着写代码，这能帮你少走很多弯路！


## 💪 总结与鼓励
这道题把**贪心**和**字符串算法**结合得很巧妙，既考逻辑推导（反转次数），又考代码实现（SA/SAM）。希望大家通过这道题，学会：
- 用“性质推导”简化问题；
- 用“贪心策略”解决“最小化”问题；
- 用“后缀数组”处理字符串比较。

记住：编程的乐趣在于“拆解问题”——把大问题拆成小步骤，一步步解决！下次遇到字符串题，不妨先想想“后缀数组能不能用上”？

下次我们再一起挑战更难的算法题！加油！💪

---
处理用时：103.86秒
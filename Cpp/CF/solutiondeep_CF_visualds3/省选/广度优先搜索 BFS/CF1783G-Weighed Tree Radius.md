# 题目信息

# Weighed Tree Radius

## 题目描述

给你一个$n$个点的树和$n-1$条边。第$i$个点的初始权值为$a_i$。

定义结点$v$到结点$u$的距离$d_v(u)$等于$v$和$u$之间的边的数量。注意:$d_v(u)=d_u(v),d_v(v)=0$

定义结点$v$到结点$u$的权值距离$w_v(u)=d_v(u)+a_u$。注意：$w_v(v)=a_v,w_v(u) \neq w_u(v)$如果$a_u \neq a_v$

与通常的距离类似，让我们定义结点$v$的偏心距$e(v)$是从$v$到其他结点的最大**权值距离（包括$v$本身）**，即$e(v)=\max\limits_{1\leq u \leq n} w_v(u)$。

最后，我们定义树的半径$r$是所有偏心距的最小值，即$r=\min\limits_{1\leq v\leq n} e(v)$

你需要对$m$次询问进行回答，对于第$j$次询问，给出两个数$v_j$和$x_j$，表示将$a_{v_j}$的值修改为$x_j$。

在每次询问后，输出当前该树的半径$r$。

## 说明/提示

第一个询问后，你会得到下面这样的树：
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1783G/9e4a681ceb9a6bc974526ec74850e83ba3019044.png)

图中被标记的结点是偏心距$e(v)$最小的结点，即$r=e(4)=7$。其他结点的偏心距如下:$e(1)=8,e(2)=9,e(3)=9,e(5)=8,e(6)=8$。

第二个询问后，你会得到下面这样的树：
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1783G/2e871ccd9092ddeb102928f6829b152be988cf84.png)

半径$r=e(1)=4$

第三个询问后，半径$r=e(2)=5$。
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1783G/fe33c3a49f01d805511036a4052869d55e0dcd18.png)

## 样例 #1

### 输入

```
6
1 3 3 7 0 1
2 1
1 3
1 4
5 4
4 6
5
4 7
4 0
2 5
5 10
5 5```

### 输出

```
7
4
5
10
7```

# AI分析结果

# 💡 Kay的C++算法解析：Weighed Tree Radius 深入学习指南 💡

<introduction>
今天我们来一起分析「Weighed Tree Radius」这道树论与数据结构结合的C++编程题。题目要求我们处理动态修改点权后的树半径，核心是将复杂的「偏心距最小化」问题转化为「树直径维护」问题。本指南会帮你梳理思路、理解关键算法，并通过像素动画直观感受过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树的直径维护 + 线段树区间合并

🗣️ **初步分析**：
解决这道题的关键，是把「找树的半径」转化为「维护树的直径」——这就像把「找树的中心」变成「找树的最长跑道，再取中点」。  

### 核心概念比喻
- **树的直径**：树中最长的「路径」（比如从点A到点B的最长距离），就像学校操场的最长跑道。  
- **树的半径**：找一个点，使得它到所有点的「权值距离」（距离+点权）最大的那个值**最小**——这相当于找跑道的「中点」，中点到两端的距离最短。  

### 问题转化的关键
题目中的「权值距离」是`w_v(u) = d(v,u) + a_u`，而偏心距`e(v)`是`max(w_v(u))`。通过数学推导可以发现：  
**树的半径 = max( ⌈直径长度/2⌉ , 最大点权 )**  
其中「直径长度」被重新定义为`nd(u,v) = d(u,v) + a_u + a_v`（相当于给每个点挂了一段长度为`a_u`的「虚拟链」，新树的直径）。  

### 算法流程与可视化设计
我们需要**动态维护这个新树的直径**：  
1. 用线段树维护每个区间的「直径信息」（端点和长度）；  
2. 合并两个区间时，只需考虑两个旧直径的4个端点的6种组合（比如A区间的直径端点是x1,y1，B区间是x2,y2，合并后的直径只能是(x1,y1)、(x2,y2)、(x1,x2)、(x1,y2)、(y1,x2)、(y1,y2)中的最长者）；  
3. 修改点权时，更新线段树中对应叶子节点的直径（单个点的直径就是自己到自己，长度为`2*a_u`），再向上合并。  

**可视化设计思路**：  
用8位像素风格展示树结构（比如FC游戏中的方块树），线段树用「分层方块」表示。动画中：  
- 初始时，每个点是一个「像素块」，标注点权；  
- 线段树合并区间时，用「闪烁箭头」连接两个区间的直径端点，计算6种组合的长度，高亮最长的那个作为新直径；  
- 修改点权时，对应像素块的颜色变化（比如从蓝色变红色），线段树自底向上更新，伴随「叮」的音效；  
- 最终直径用「加粗黄线」标出，半径用「绿色中点」显示，成功找到半径时播放「胜利音效」。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性等角度，筛选出以下优质题解：
</eval_intro>

**题解一：来源：namelessgugugu**  
* **点评**：这份题解是本题的「标准正解」，思路非常清晰——将问题转化为维护新树的直径，并用线段树高效处理动态修改。  
  - **思路亮点**：创造性地将「偏心距最小化」转化为「直径维护」，并证明了「合并区间直径只需考虑6种组合」，避免了复杂的遍历。  
  - **代码规范**：变量命名清晰（比如`Info`结构体存储直径端点和长度，`merge`函数合并区间），LCA预处理用欧拉序+ST表，确保`dis`函数O(1)计算。  
  - **实践价值**：代码直接可用于竞赛，边界处理严谨（比如`query`函数同时考虑直径的一半和最大点权），时间复杂度O(n log n + m log n)，完全满足题目数据规模要求。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于「问题转化」和「高效维护直径」。结合优质题解，我提炼了3个关键思考点：
</difficulty_intro>

1.  **难点1：如何将偏心距转化为直径问题？**  
    * **分析**：题目中的`e(v) = max(d(v,u)+a_u)`，而我们需要找`min(e(v))`。通过数学推导，这个最小值等于「新树直径的一半」或「最大点权」——新树的直径定义为`nd(u,v) = d(u,v)+a_u+a_v`。这一步是解题的「突破口」，需要理解「虚拟链」的概念（给每个点挂一段长度为`a_u`的链，新树的直径就包含了原问题的所有信息）。  
    * 💡 **学习笔记**：转化问题是解决复杂算法题的关键——把不熟悉的「偏心距」变成熟悉的「树直径」。

2.  **难点2：如何高效维护动态的树直径？**  
    * **分析**：点权修改会影响直径，直接重新计算直径的时间复杂度太高（O(n)每次修改，无法通过m=1e5的数据）。优质题解用「线段树维护区间直径」——每个线段树节点存储对应区间的直径端点和长度，合并时只需考虑6种组合，时间复杂度O(log n)每次修改。  
    * 💡 **学习笔记**：线段树不仅能处理区间求和/最值，还能维护「结构化信息」（比如树的直径），关键是找到「合并规则」。

3.  **难点3：如何证明合并区间直径的6种组合是正确的？**  
    * **分析**：假设两个区间的直径分别是(A,B)和(C,D)，合并后的直径只能是这四个端点的组合。反证法：如果合并后的直径是(E,F)，其中E来自A区间，F来自B区间，那么E到F的路径必然经过两个区间的连接点。此时，A区间的直径端点A或B到连接点的距离一定不小于E到连接点的距离，B区间同理，因此(E,F)不可能比6种组合更长。  
    * 💡 **学习笔记**：算法的正确性需要证明，不能只靠直觉——这个结论是线段树维护直径的「理论基础」。

### ✨ 解题技巧总结
- **技巧1：问题转化**：遇到复杂定义（比如偏心距），尝试将其映射到已知的算法模型（比如树直径）。  
- **技巧2：线段树维护结构化信息**：当需要动态维护「有合并规则的信息」（比如直径），线段树是常用工具。  
- **技巧3：LCA预处理**：树的距离计算依赖LCA，用欧拉序+ST表可以实现O(1)查询，是处理树问题的基础技巧。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的通用核心实现，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自namelessgugugu的题解，是本题的标准实现，逻辑清晰、效率高。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <cstring>
  #include <algorithm>
  typedef long long ll;
  const int N = 200005;
  int n, m, val[N];
  struct Edge { int to, nxt; } E[N << 1];
  int head[N], tot;
  inline void add(int f, int t) { E[++tot] = {t, head[f]}, head[f] = tot; }

  // LCA预处理（欧拉序+ST表）
  int dep[N], dfn[N], tt, lg[N << 1], euler[N << 1], st[N << 1][20];
  void dfs(int x, int from) {
      dep[x] = dep[from] + 1, euler[dfn[x] = ++tt] = x;
      for (int i = head[x]; i; i = E[i].nxt)
          if (E[i].to != from) dfs(E[i].to, x), euler[++tt] = x;
  }
  inline int depmin(int x, int y) { return dep[x] <= dep[y] ? x : y; }
  inline void st_init() {
      for (int i = 1; i <= tt; ++i) lg[i] = lg[i >> 1] + 1;
      for (int i = 1; i <= tt; ++i) st[i][0] = euler[i];
      for (int k = 1; k < lg[tt]; ++k)
          for (int i = 1; i + (1 << k) - 1 <= tt; ++i)
              st[i][k] = depmin(st[i][k-1], st[i+(1<<(k-1))][k-1]);
  }
  inline int lca(int x, int y) {
      x = dfn[x], y = dfn[y]; if (x > y) std::swap(x, y);
      int k = lg[y - x + 1] - 1; return depmin(st[x][k], st[y-(1<<k)+1][k]);
  }
  inline ll dis(int x, int y) { return dep[x] + dep[y] - 2 * dep[lca(x, y)]; }

  // 直径信息结构体：存储端点x、y和长度len=dis(x,y)+val[x]+val[y]
  struct Info {
      int x, y; ll len;
      Info() : x(0), y(0), len(0) {}
      Info(int _x, int _y) : x(_x), y(_y), len(dis(_x, _y) + val[_x] + val[_y]) {}
      bool operator<(const Info& b) const { return len < b.len; }
  };

  // 合并两个区间的直径信息：取6种组合的最大值
  inline Info merge(Info a, Info b) {
      Info p[] = {a, b, Info(a.x, b.x), Info(a.x, b.y), Info(a.y, b.x), Info(a.y, b.y)};
      return *std::max_element(p, p + 6);
  }

  // 线段树：维护区间的直径信息
  struct SgT {
      Info t[N << 2];
      inline int ls(int x) { return x << 1; }
      inline int rs(int x) { return x << 1 | 1; }
      inline void pushup(int x) { t[x] = merge(t[ls(x)], t[rs(x)]); }
      void build(int x, int l, int r) {
          if (l == r) { t[x] = Info(l, l); return; }
          int mid = (l + r) >> 1;
          build(ls(x), l, mid), build(rs(x), mid+1, r);
          pushup(x);
      }
      void update(int x, int l, int r, int p) {
          if (l == r) { t[x] = Info(p, p); return; }
          int mid = (l + r) >> 1;
          if (p <= mid) update(ls(x), l, mid, p);
          else update(rs(x), mid+1, r, p);
          pushup(x);
      }
      inline ll query() {
          Info res = t[1];
          return std::max((res.len + 1) / 2, (ll)std::max(val[res.x], val[res.y]));
      }
  } T;

  int main() {
      scanf("%d", &n);
      for (int i = 1; i <= n; ++i) scanf("%d", val + i);
      for (int i = 1, u, v; i < n; ++i) scanf("%d%d", &u, &v), add(u, v), add(v, u);
      dfs(1, 0), st_init(), T.build(1, 1, n);
      scanf("%d", &m);
      for (int i = 1, x, y; i <= m; ++i) {
          scanf("%d%d", &x, &y);
          val[x] = y;
          T.update(1, 1, n, x);
          printf("%lld\n", T.query());
      }
      return 0;
  }
  ```
* **代码解读概要**：
  1. **输入处理**：读取树的结构和点权，构建邻接表。  
  2. **LCA预处理**：用DFS生成欧拉序，构建ST表，以便O(1)查询LCA和两点距离。  
  3. **线段树初始化**：构建线段树，每个叶子节点存储单个点的直径（自己到自己）。  
  4. **处理查询**：修改点权后，更新线段树对应节点，合并区间直径，最后计算半径（直径的一半或最大点权）。

---

<code_intro_selected>
接下来剖析题解中的核心片段：
</code_intro_selected>

**题解一：来源：namelessgugugu**
* **亮点**：用线段树维护区间直径，合并时仅需考虑6种组合，效率极高。
* **核心代码片段（合并函数）**：
  ```cpp
  inline Info merge(Info a, Info b) {
      Info p[] = {a, b, Info(a.x, b.x), Info(a.x, b.y), Info(a.y, b.x), Info(a.y, b.y)};
      return *std::max_element(p, p + 6);
  }
  ```
* **代码解读**：
  > 这段代码是线段树维护直径的「核心逻辑」。假设`a`是左区间的直径（端点x1,y1），`b`是右区间的直径（端点x2,y2），合并后的直径只能是这四个端点的6种组合——因为任何跨区间的直径，其两端点必然来自左右区间的直径端点（否则可以通过替换端点得到更长的直径）。`std::max_element`找到最长的那个组合，作为合并后的直径。
* 💡 **学习笔记**：合并区间的「规则」是线段树维护结构化信息的关键——找到所有可能的候选，再取最优。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解「线段树维护树直径」的过程，我设计了一个8位像素风格的动画，像玩FC游戏一样学算法！
</visualization_intro>

  * **动画演示主题**：像素树的「最长跑道」争夺战（维护直径）
  * **核心演示内容**：展示线段树合并区间、修改点权时直径的变化，以及最终半径的计算。
  * **设计思路简述**：用FC风格的像素块（比如绿色代表树节点，蓝色代表线段树节点），配合简单音效，让抽象的算法「动起来」——比如合并区间时的「叮」声，修改点权时的「吱」声，找到直径时的「咻」声，增强记忆点。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
       - 屏幕左侧是「像素树」（每个节点是16x16的方块，标注点权），右侧是「线段树」（分层的方块，每层代表线段树的一个层级）。
       - 控制面板有「开始/暂停」「单步」「重置」按钮，以及「速度滑块」（控制动画速度）。
       - 播放8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。
    2. **线段树构建**：
       - 每个叶子节点（对应树的一个点）闪烁，显示直径为「自己到自己」（长度2*点权）。
       - 向上合并区间：两个子节点的方块用「黄色箭头」连接，计算6种组合的长度，高亮最长的组合作为父节点的直径。
    3. **修改点权**：
       - 点击某个树节点（比如点4），修改其点权（比如从7改成0）：节点颜色从蓝色变红色，伴随「吱」的音效。
       - 线段树自底向上更新：对应叶子节点的直径更新为2*新点权，父节点依次合并，直到根节点——每合并一次，播放「叮」的音效。
    4. **计算半径**：
       - 根节点的直径用「加粗黄线」标出，计算「直径的一半」和「最大点权」，取较大值作为半径。
       - 半径对应的「中心节点」用「绿色方块」高亮，播放「胜利音效」（比如《塞尔达传说》的解谜音效）。
    5. **交互控制**：
       - 「单步」按钮：逐帧观看线段树合并过程，每步显示当前组合的长度。
       - 「自动播放」：按设定速度播放动画，适合快速浏览整体流程。
       - 「重置」：恢复初始状态，重新演示。

  * **旁白提示**：
    - 合并时：「现在合并左区间和右区间，尝试6种组合，最长的就是新直径！」
    - 修改点权时：「点4的权值改成0了，线段树要更新啦～」
    - 计算半径时：「直径是10，一半是5；最大点权是7，所以半径是7！」

<visualization_conclusion>
通过这个像素动画，你能清晰看到「线段树如何维护直径」「修改点权如何影响结果」——就像玩游戏一样，轻松掌握复杂的算法逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「维护树直径」是树论中的经典问题，本题的思路可以迁移到很多场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 场景1：动态修改边权，求树的直径（只需将点权改为边权，调整直径定义）。
    - 场景2：求树的「中心」（即半径对应的点，本题已解决）。
    - 场景3：多个树合并，求合并后的直径（同样用线段树的合并规则）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1099** - 树的直径  
          * 🗣️ **推荐理由**：基础树直径问题，帮你巩固「两次DFS求直径」的方法。
    2.  **洛谷 P2993** - [NOIP2014 提高组] 寻找道路  
          * 🗣️ **推荐理由**：需要动态维护树的直径，类似本题的思路。
    3.  **洛谷 P3324** - [SDOI2015] 星际战争  
          * 🗣️ **推荐理由**：结合树链剖分维护直径，是本题的进阶版。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「合并直径只需考虑6种组合」是关键结论，作者的思考过程值得借鉴：
</insights_intro>

> **参考经验 (来自 namelessgugugu)**：「我写完代码才发现第二种情况（直径在虚拟链上）不可能发生，因为如果是这样会有d=nd(u,u)。」
>
> **点评**：作者的调试经历提醒我们——写完代码后要验证「边界情况」。比如本题中，当直径是某个点的自环（nd(u,u)=2a_u），此时半径就是a_u，需要在计算时考虑到这一点（代码中的`std::max((res.len+1)/2, max(val[res.x], val[res.y]))`）。


<conclusion>
本次关于「Weighed Tree Radius」的分析就到这里！关键是学会「问题转化」——把不熟悉的偏心距变成熟悉的树直径，再用线段树高效维护。记住：算法的本质是「找规律、用工具」，多练多想就能掌握！下次我们再一起探索新的挑战～💪
</conclusion>

---
处理用时：116.29秒
# 题目信息

# Friends and Pizza

## 题目描述

Monocarp 有 $n$ 个披萨，第 $i$ 个披萨包含 $a_i$ 片。披萨用从 A 开始的拉丁字母大写字符表示（第 $n$ 个披萨对应第 $n$ 个拉丁字母）。

Monocarp 还有 $m$ 个朋友，他想要邀请其中恰好两人来吃披萨。对于每个朋友，Monocarp 知道该朋友喜欢哪些披萨。

当朋友到达 Monocarp 家后，每个披萨的处理方式如下：

- 如果该披萨不被任何被邀请的朋友喜欢，Monocarp 将吃掉它；
- 如果该披萨恰好被一位被邀请的朋友喜欢，该朋友将吃掉它；
- 如果该披萨被两位朋友都喜欢，他们将尝试分食。若披萨包含偶数片，两人各吃一半；若包含奇数片，他们会因争夺额外一片而发生争吵——Monocarp 不喜欢这种情况。

对于每个 $k$ 从 $0$ 到 $\sum a_i$，计算选择两个朋友的方式数，使得朋友不会争吵且 Monocarp 恰好吃掉 $k$ 片。

## 说明/提示

以第一个示例的所有朋友对为例：

- 邀请朋友 $1$ 和 $2$：他们将吃掉披萨 $1$ 和 $2$，Monocarp 吃披萨 $3$；
- 邀请朋友 $1$ 和 $3$：他们将吃掉所有披萨；
- 邀请朋友 $1$ 和 $4$：他们将吃披萨 $1$ 和 $2$，Monocarp 吃披萨 $3$；
- 邀请朋友 $1$ 和 $5$：他们将吃掉所有披萨；
- 邀请朋友 $1$ 和 $6$：他们将吃披萨 $1$ 和 $3$，Monocarp 吃披萨 $2$；
- 邀请朋友 $2$ 和 $3$：因披萨 $2$ 发生争吵；
- 邀请朋友 $2$ 和 $4$：因披萨 $2$ 发生争吵；
- 邀请朋友 $2$ 和 $5$：因披萨 $2$ 发生争吵；
- 邀请朋友 $2$ 和 $6$：他们将吃掉所有披萨；
- 邀请朋友 $3$ 和 $4$：因披萨 $2$ 发生争吵；
- 邀请朋友 $3$ 和 $5$：因披萨 $2$ 发生争吵；
- 邀请朋友 $3$ 和 $6$：因披萨 $3$ 发生争吵；
- 邀请朋友 $4$ 和 $5$：因披萨 $2$ 发生争吵；
- 邀请朋友 $4$ 和 $6$：他们将吃掉所有披萨；
- 邀请朋友 $5$ 和 $6$：因披萨 $3$ 发生争吵。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3 6
A AB ABC AB BC C
2 3 5```

### 输出

```
4 0 0 1 0 2 0 0 0 0 0```

# AI分析结果


# 💡 Kay的C++算法解析：Friends and Pizza 深入学习指南 💡

<introduction>
今天我们来分析"Friends and Pizza"这道有趣的C++编程题。本指南将帮助大家理解如何高效统计不会引发争吵的朋友组合，并掌握位运算和子集卷积的核心技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`位运算` + `子集卷积`

🗣️ **初步分析**：
> 这道题可以想象成在像素风格的披萨店里分配食材🍕。每个披萨(像素块)有不同片数，朋友是游戏角色，他们只吃特定披萨。关键规则是：当两个角色同时喜欢一个**奇数片披萨**时，会引发争吵(冲突动画💥)。

在本题中，我们使用**位掩码**技术：每个披萨用一个比特位表示，朋友喜好用二进制数编码。核心技巧是：
- 识别所有奇数片披萨的集合`S`（红色警示披萨）
- 对每个朋友计算`t_i = a_i ∩ S`（他们喜欢的危险披萨）
- 用子集卷积高效找到所有满足`t_i ∩ t_j = ∅`的朋友对（无冲突组合）

可视化设计思路：
- 用8位像素网格表示披萨集合，奇数披萨用闪烁红色方块
- 朋友角色头顶显示其喜好集合的二进制编码
- 卷积过程展示为像素块合并动画，伴随"叮"的音效
- 冲突检测时播放"哔"的警示音，成功配对时播放胜利音效🎮

---

## 2. 精选优质题解参考

<eval_intro>
我基于思路清晰度、代码规范性和算法优化程度，精选了以下优质题解：

**题解一：(来源：Purslane)**
* **点评**：这份题解思路非常清晰，直接抓住`|T_i∩S|+|T_j∩S|=|(T_i∪T_j)∩S|`这个核心等式（就像拼图必须严丝合缝）。代码规范：
  - 使用`__builtin_popcount`高效计算比特数
  - 通过`mul[popcount][mask]`二维数组完美实现占位卷积
  - 边界处理严谨（如`if((T[i]&S)==0) fin[T[i]]--`）
  最大亮点是将复杂问题转化为标准子集卷积，时间复杂度优化到O(n²2ⁿ)

**题解二：(来源：PTqwq)**
* **点评**：代码结构清晰，采用模块化设计：
  - 独立FWT函数实现卷积变换
  - 使用`valf[cnt][mask]`精确记录状态
  - 详细的变量命名（如`z`表示奇数披萨集合）
  特别值得学习的是卷积维度的处理技巧，通过`valg[cnt][i] += valf[j][k]*valf[c-j][k]`实现无交检测，就像用不同颜色的像素块拼接图案

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需要突破三个关键难点：

1.  **难点：冲突条件的位运算转化**
    * **分析**：争吵发生当且仅当两个朋友共享奇数片披萨。优质题解通过`t_i = a_i ∩ S`提取危险披萨，再用`t_i ∩ t_j = ∅`检测冲突，就像用红色滤片找出会爆炸的组合
    * 💡 **学习笔记**：位掩码是处理集合交并的高效工具

2.  **难点：无交检测的卷积实现**
    * **分析**：直接枚举朋友对需O(m²)，不可行。通过`|t_i| + |t_j| = |t_i ∪ t_j|`这个关键等式（就像拼图面积守恒），将问题转化为子集卷积：
      1. 按`|t_i|`分组存储朋友数量
      2. 对每组做FWT卷积
      3. 只取满足`popcnt(k∩S)=c`的结果
    * 💡 **学习笔记**：子集卷积通过维度分离解决集合无交检测

3.  **难点：结果去重处理**
    * **分析**：卷积过程包含(i,i)和(i,j)/(j,i)重复计数。优质题解采用：
      ```cpp
      for(int i=1;i<=m;i++) 
        if(t_i==0) fin[mask]--; // 去除自配对
      fin[i] /= 2;              // 去除对称重复
      ```
    * 💡 **学习笔记**：统计组合时需注意无序对特性

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可总结以下通用技巧：
</summary_best_practices>
- **位压缩技巧**：用整数bit表示集合，`&`代替交，`|`代替并
- **维度分离**：通过添加popcnt维度将复杂约束转化为标准卷积
- **FWT加速**：用快速沃尔什变换将O(4ⁿ)优化到O(n2ⁿ)
- **边界处理**：特别注意空集和单元素集等边界情况

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现：

**本题通用核心C++实现参考**
* **说明**：基于Purslane解法优化，完整展示位运算卷积流程
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 21, MAXM = 1<<20;
long long f[MAXN][MAXM], g[MAXN][MAXM], ans[MAXM];

int main() {
    // 输入处理
    int n, m, total = 0, oddSet = 0;
    cin >> n >> m;
    vector<int> pref(m), pizza(n);
    for(int i=0; i<m; i++){
        string s; cin >> s;
        for(char c : s) pref[i] |= (1 << (c-'A'));
    }
    for(int i=0; i<n; i++){
        cin >> pizza[i]; total += pizza[i];
        if(pizza[i] & 1) oddSet |= (1<<i);
    }

    // 统计各集合的朋友数
    for(int i=0; i<m; i++){
        int t = pref[i] & oddSet;      // 危险披萨集合
        int cnt = __builtin_popcount(t);
        f[cnt][pref[i]]++;             // 按危险计数分组
    }
    
    // 维度分离卷积
    for(int c=0; c<=n; c++)            // FWT正变换
        for(int i=0; i<n; i++)
            for(int mask=0; mask<(1<<n); mask++)
                if(mask & (1<<i)) f[c][mask] += f[c][mask^(1<<i)];
    
    for(int c=0; c<=n; c++)            // 卷积计算
        for(int d=0; d<=c; d++)
            for(int mask=0; mask<(1<<n); mask++)
                g[c][mask] += f[d][mask] * f[c-d][mask];
    
    for(int c=0; c<=n; c++)            // FWT逆变换
        for(int i=0; i<n; i++)
            for(int mask=0; mask<(1<<n); mask++)
                if(mask & (1<<i)) g[c][mask] -= g[c][mask^(1<<i)];
    
    // 结果提取
    for(int mask=0; mask<(1<<n); mask++){
        int cnt = __builtin_popcount(mask & oddSet);
        ans[mask] = g[cnt][mask];       // 合法对数量
        if((mask & oddSet)==0) ans[mask]--; // 去除自配对
        ans[mask] /= 2;                 // 去除重复计数
    }

    // 统计Monocarp吃的披萨数
    vector<long long> res(total+1,0);
    for(int mask=0; mask<(1<<n); mask++){
        int monoSlices = 0;
        for(int i=0; i<n; i++)
            if(!(mask & (1<<i))) monoSlices += pizza[i];
        res[monoSlices] += ans[mask];
    }
    
    // 输出结果
    for(int i=0; i<=total; i++) 
        cout << res[i] << " ";
}
```
* **代码解读概要**：
> 1. **输入处理**：将朋友喜好编码为bitmask，识别奇数披萨集合
> 2. **分组统计**：按危险披萨数量(`popcnt(t_i)`)分组存储朋友数
> 3. **三维卷积**：通过FWT实现高效卷积，检测无交集合
> 4. **结果处理**：去除自配对和重复计数
> 5. **答案统计**：计算Monocarp吃的披萨片数并输出

---
<code_intro_selected>
现在解析优质题解的精妙片段：
</code_intro_selected>

**题解一：(来源：Purslane)**
* **亮点**：简洁高效的卷积实现
* **核心代码片段**：
```cpp
ffor(i,1,m) mul[__builtin_popcount(T[i]&S)][T[i]]++;
ffor(i,0,n) ffor(j,0,n-1) ffor(k,0,(1<<n)-1) 
    if(k&(1<<j)) mul[i][k] += mul[i][k-(1<<j)]; // FWT正变换
```
* **代码解读**：
> 这组嵌套循环实现了FWT的正变换。`mul[c][mask]`存储危险计数为c且喜好为mask的朋友数。内层循环通过`k-(1<<j)`逐步累加子集，就像用像素刷子逐层填充更大的集合。例如当`j=0`时，所有包含披萨A的集合都会累加不包含A的子集值
* 💡 **学习笔记**：FWT正变换本质是子集前缀和

**题解二：(来源：PTqwq)**
* **亮点**：模块化FWT实现
* **核心代码片段**：
```cpp
void FWT(int x) {
    for(int i=2; i<=(1<<n); i*=2)       // 分层处理
        for(int j=0; j<(1<<n); j+=i)    // 每块起始位置
            for(int k=0; k<i/2; k++)    // 块内偏移
                valf[x][j+k+i/2] += valf[x][j+k]; 
}
```
* **代码解读**：
> 这个FWT函数采用经典的分治结构。参数`x`是危险计数维度。循环变量`i`表示当前合并的块大小（2/4/8...），`j`遍历块起始位置，`k`在块内移动。例如当`i=2`时，会将所有相邻元素合并（`[0]+[1]`，`[2]+[3]`等），就像把2x2像素块合并成4x4
* 💡 **学习笔记**：FWT通过分层合并实现O(n2ⁿ)复杂度

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个名为"Pizza Pixel Quest"的8位风格动画，直观展示子集卷积和冲突检测过程！
</visualization_intro>

* **动画主题**：像素厨师👨🍳在厨房分配披萨，朋友作为顾客点单

* **核心演示**：卷积如何检测无冲突订单组合

* **设计思路**：采用FC游戏风格，通过：
  - 分层合并动画解释FWT
  - 红蓝披萨区分奇偶片数
  - 音效强化关键操作记忆

* **动画帧步骤**：
  1. **场景初始化**：
     - 16x16像素网格，每格表示一种披萨
     - 奇数披萨：闪烁红色🧨，偶数披萨：稳定蓝色💧
     - 控制面板：播放/暂停▶️，单步⏭️，速度条🐢→🐇

  2. **顾客入场**（音效：门铃"叮当"）：
     ``` 
     顾客1: 🟦🟥🟦 (喜好={A,C}, 危险={C})
     顾客2: 🟥🟥   (喜好={B,C}, 危险={B,C})
     ```

  3. **卷积变换**（背景音乐：8位芯片音乐）：
     - **分层合并**：展示FWT正变换过程
       - 阶段1：相邻订单两两合并（像素块拼合动画+"咔嗒"音效）
       - 阶段2：4组订单合并（更大像素块拼合）
     - **冲突检测**：当两个订单包含相同红色披萨时
       - 显示爆炸像素特效💥
       - 播放"哔-"警示音
       - 计数器显示无效组合数

  4. **结果提取**（胜利音乐🎉）：
     - 绿色高亮有效订单组合
     - 显示Monocarp可吃的披萨数
     - 累计答案到右侧条形图

  5. **交互功能**：
     - **AI演示**：自动完成所有计算（像贪吃蛇AI）
     - **关卡挑战**：每完成n个订单解锁新关卡
     - **得分系统**：快速找到无冲突组合得连击分

<visualization_conclusion>
通过像素厨房的生动演示，能直观理解集合卷积如何高效检测订单冲突！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握子集卷积后，可解决更多集合统计问题：
</similar_problems_intro>

* **技巧迁移**：
  1. 社交网络好友推荐（无共同厌恶兴趣）
  2. 基因兼容性检测（无致病基因组合）
  3. 设备兼容安装（无冲突驱动）

* **洛谷练习推荐**：
  1. **P5495** - 子集卷积（模板题）
     * 🗣️ 直接应用本题技巧，巩固FWT实现
  2. **P6846** - 超现实数
     * 🗣️ 训练位运算转化能力
  3. **P3175** - 按位或
     * 🗣️ 强化期望+FWT的综合应用

-----

## 7. 学习心得与经验分享

<insights_intro>
题解中的经验非常宝贵：
</insights_intro>

> **来自Starrykiller的反思**：
> "果然还是对SPS（子集卷积）的理解不够深刻"
>
> **Kay点评**：
> 这提醒我们：1）透彻理解算法原理比套用模板更重要 2）遇到新问题要思考如何转化为已知模型 3）从更高维度看问题（如添加popcnt维度）

<conclusion>
本次分析展示了如何用位运算和子集卷积高效解决复杂统计问题。记住：将问题抽象为集合运算，再寻找优化结构，是算法设计的核心思维！下次见！👾
</conclusion>

---
处理用时：187.34秒
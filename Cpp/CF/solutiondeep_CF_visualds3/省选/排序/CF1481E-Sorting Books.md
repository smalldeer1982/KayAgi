# 题目信息

# Sorting Books

## 题目描述

One day you wanted to read something, so you went to your bookshelf to grab some book. But when you saw how messy the bookshelf was you decided to clean it up first.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1481E/eb717b77908d0758f813f3cb2f376ac8a23aad06.png)There are $ n $ books standing in a row on the shelf, the $ i $ -th book has color $ a_i $ .

You'd like to rearrange the books to make the shelf look beautiful. The shelf is considered beautiful if all books of the same color are next to each other.

In one operation you can take one book from any position on the shelf and move it to the right end of the shelf.

What is the minimum number of operations you need to make the shelf beautiful?

## 说明/提示

In the first example, we have the bookshelf $ [1, 2, 2, 1, 3] $ and can, for example:

1. take a book on position $ 4 $ and move to the right end: we'll get $ [1, 2, 2, 3, 1] $ ;
2. take a book on position $ 1 $ and move to the right end: we'll get $ [2, 2, 3, 1, 1] $ .

In the second example, we can move the first book to the end of the bookshelf and get $ [2,2,1,1,1] $ .

## 样例 #1

### 输入

```
5
1 2 2 1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2 2 1 1```

### 输出

```
1```

# AI分析结果

# 💡 Kay的C++算法解析：Sorting Books 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（倒序DP）

🗣️ **初步分析**：  
解决“Sorting Books”的关键是**正难则反**——与其直接计算“最少移动次数”，不如计算“最多能保留多少本书不移动”（答案=总数-最大保留数）。动态规划（DP）在这里是核心工具，而**倒序处理**是关键技巧：我们从最后一本书往第一本分析，这样处理第`i`本书时，已经知道了`i+1`到`n`的最优解（即`dp[i+1]`），能直接基于后续结果做决策。  

简单来说，倒序DP像“从后往前规划整理书架”：  
- 每本书有三种选择：**移动它**（直接继承后面的最优解`dp[i+1]`）、**保留它且它是同色书的第一个出现的位置**（合并同色书的整个区间，加上右边区间的最优解）、**保留它但不是同色书的起点**（只保留后缀中所有同色书，其他都移动）。  

**核心难点**：如何避免“保留的区间重叠”——只有当当前书是同色书的**左端点**（`l[a[i]]=i`）时，才能确保同色书的整个区间`[i, r[a[i]]]`是完整的，此时合并右边的区间才不会重叠；否则，若强行合并会导致区间交叉，计算错误。  

**可视化设计思路**：  
用8位FC像素风格展示书架（每个书是彩色像素块），倒序处理时高亮当前位置`i`，用数字/进度条显示`cnt[a[i]]`（后缀同色书数量）和`dp[i]`的变化。当处理左端点时，用蓝色框框住同色区间`[i, r[a[i]]]`，伴随“叮”的合并音效；非左端点时显示“保留同色”提示，伴随“咔嗒”的计数音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：作者@流沫（赞13）**  
* **点评**：这份题解的核心亮点是**补充了非左端点的转移逻辑**——用“费用提前计算”解释了为什么非左端点时只能取`cnt[a[i]]`（即保留后缀同色书，其他都移动，避免区间重叠）。思路清晰，代码简洁（变量`l/r/cnt/dp`命名直观），边界处理严谨（倒序循环从`n`到`1`）。尤其适合竞赛选手参考，直接套用即可解决问题。

**题解二：作者@huayucaiji（赞10）**  
* **点评**：这份题解的价值在于**详细推导转移方程的原理**——通过样例对比了“正确转移”和“错误转移”的区别（错误转移会导致区间重叠），帮你彻底理解“为什么要区分左端点”。代码注释详细，逻辑推导过程像“手把手教你找bug”，非常适合入门学习者。

**题解三：作者@fanfansann（赞7）**  
* **点评**：这份题解用**贪心+DP的思路引入**，先直观解释“为什么要找最大保留数”（贪心保留数量多的同色书），再过渡到DP实现。代码结构清晰，变量`cnt_post`（后缀同色数量）和`f`（dp数组）的命名很友好，适合新手快速理解倒序DP的流程。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是突破3个核心难点，结合优质题解的经验，我帮你总结了应对策略：
</difficulty_intro>

1. **难点1：为什么要用倒序DP？**  
   - **分析**：因为每次移动只能将书放到右端，后面的书的状态不会影响前面的选择（除非前面的书是同色书的左端点，需要合并后面的区间）。倒序处理能直接利用后续的最优解（`dp[i+1]`），避免重复计算。  
   - 💡 **学习笔记**：“正难则反”是DP的常用技巧——当直接计算目标困难时，不妨计算其“对偶问题”（如本题的“最大保留数”）。

2. **难点2：为什么要区分“左端点”？**  
   - **分析**：只有当当前书是同色书的左端点（`l[a[i]]=i`）时，才能确保同色书的整个区间`[i, r[a[i]]]`是完整的。此时合并右边的区间（`dp[r[a[i]]+1]`）不会重叠；否则，若合并会导致两个区间交叉，计算错误（比如样例1中错误转移会得到`f[1]=4`，而正确结果是`3`）。  
   - 💡 **学习笔记**：转移条件的限制是为了**保证区间不重叠**，这是DP正确性的关键。

3. **难点3：如何计算“后缀同色书数量”？**  
   - **分析**：倒序处理时，每遇到一本书`a[i]`，就将`cnt[a[i]]`加1——因为我们从后往前遍历，`cnt[a[i]]`自然记录了`i`到`n`中同色书的数量。  
   - 💡 **学习笔记**：倒序处理的“天然优势”是能实时维护后缀统计信息，无需额外预处理。


### ✨ 解题技巧总结
- **技巧1：正难则反**：遇到“最少操作次数”问题，先想“最多保留多少”，往往更简单。  
- **技巧2：倒序DP**：处理“后缀相关”问题时，倒序遍历能利用后续结果，简化转移。  
- **技巧3：区间不重叠**：涉及区间选择的DP，要通过条件限制（如左端点判断）避免区间交叉。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合优质题解的通用核心代码，帮你建立整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合@流沫、@huayucaiji、@fanfansann的思路，代码简洁高效，覆盖所有核心逻辑。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  const int N = 5e5 + 10; // 题目中n≤5e5，数组要开足够大
  int n, a[N], l[N], r[N], cnt[N], dp[N];

  int main() {
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          cin >> a[i];
          if (!l[a[i]]) l[a[i]] = i; // 记录颜色a[i]的左端点
          r[a[i]] = i;               // 记录颜色a[i]的右端点
      }

      // 倒序处理：从最后一本书到第一本
      for (int i = n; i >= 1; --i) {
          dp[i] = dp[i + 1]; // 情况1：移动当前书，继承后面的最优解
          ++cnt[a[i]];       // 情况2/3：更新后缀同色书数量

          if (i == l[a[i]]) { // 情况3：当前书是同色书的左端点，合并整个区间
              dp[i] = max(dp[i], cnt[a[i]] + dp[r[a[i]] + 1]);
          } else { // 情况2：非左端点，保留后缀同色书
              dp[i] = max(dp[i], cnt[a[i]]);
          }
      }

      cout << n - dp[1] << endl; // 答案=总数-最大保留数
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 输入处理：记录每个颜色的左端点`l`和右端点`r`（左端点只记录第一次出现的位置，右端点更新到最后一次出现的位置）。  
  2. 倒序DP：从`n`到`1`遍历，计算每个位置的最大保留数`dp[i]`。  
  3. 输出结果：总数减去`dp[1]`（整个序列的最大保留数）。


<code_intro_selected>
接下来剖析优质题解的核心片段，点出各自的精妙之处！
</code_intro_selected>

**题解一：作者@流沫**  
* **亮点**：补充非左端点的转移逻辑（费用提前计算）。  
* **核心代码片段**：
  ```cpp
  for (int i = n; i >= 1; --i) {
      dp[i] = dp[i+1];
      ++cnt[a[i]];
      if (i != l[a[i]]) dp[i] = max(dp[i], cnt[a[i]]); // 非左端点：保留后缀同色
      else dp[i] = max(dp[i], cnt[a[i]] + dp[r[a[i]]+1]); // 左端点：合并区间
  }
  ```
* **代码解读**：  
  当`i`不是左端点时，`cnt[a[i]]`是后缀中同色书的数量——保留这些书，其他都移动，这就是“费用提前计算”（提前把移动其他书的代价算进去）。比如样例`[2,3,4,5,6,2,2,8]`，处理`i=6`（非左端点）时，`cnt[2]=2`，所以`dp[6]=2`（保留后面两本2，其他都移动）。  
* 💡 **学习笔记**：非左端点的转移是“费用提前计算”，避免区间重叠。

**题解二：作者@huayucaiji**  
* **亮点**：对比错误与正确转移，解释区间重叠问题。  
* **核心代码片段**：
  ```cpp
  for (int i = n; i >= 1; --i) {
      tot[a[i]]++;
      if (i == l[a[i]]) {
          f[i] = max(tot[a[i]] + f[r[a[i]]+1], f[i+1]);
      } else {
          f[i] = max(f[i+1], tot[a[i]]); // 正确：非左端点不取后面的f值
          // f[i] = max(tot[a[i]] + f[r[a[i]]+1], f[i+1]); // 错误：会区间重叠
      }
  }
  ```
* **代码解读**：  
  错误转移会在非左端点时加上`f[r[a[i]]+1]`，导致区间重叠。比如样例1中，处理`i=4`（颜色1的非左端点）时，错误转移会把`f[5]`（值为1）加进来，得到`f[4]=2+1=3`，但实际上`i=4`的同色书区间是`[1,4]`，合并`f[5]`会导致`[1,4]`和`[5,5]`重叠，结果错误。  
* 💡 **学习笔记**：非左端点时不能加后面的`f`值，否则会区间重叠。

**题解三：作者@fanfansann**  
* **亮点**：用`cnt`（总同色数量）替代`cnt_post`（后缀同色数量），简化代码。  
* **核心代码片段**：
  ```cpp
  for (int i = n; i >= 1; --i) {
      f[i] = f[i+1];
      cnt_post[a[i]]++;
      if (i == l[a[i]])
          f[i] = max(f[i], f[r[a[i]]+1] + cnt[a[i]]); // cnt是总同色数量
      else f[i] = max(f[i], cnt_post[a[i]]);
  }
  ```
* **代码解读**：  
  当`i`是左端点时，`cnt[a[i]]`（总同色数量）等于`cnt_post[a[i]]`（后缀同色数量）——因为倒序处理时，已经遍历了所有同色书。这样可以省去维护`cnt_post`的麻烦，直接用总数量代替。  
* 💡 **学习笔记**：左端点时，总同色数量等于后缀同色数量，可简化代码。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”倒序DP的过程，我设计了一个8位像素风格的动画，像玩FC游戏一样学算法！
</visualization_intro>

### 动画演示主题  
**像素书架的“倒序整理计划”**（FC红白机风格，背景是复古的木质书架，书是彩色像素块）。

### 核心演示内容  
展示倒序处理每个位置`i`的过程，包括：  
- 当前位置`i`的高亮（黄色闪烁边框）；  
- `cnt[a[i]]`的变化（同色书数量增加，对应颜色的计数器+1）；  
- `dp[i]`的更新（数字跳动，显示当前最优解）；  
- 左端点时的区间合并（蓝色框框住同色区间，伴随“叮”的音效）。

### 动画帧步骤（以样例1为例）  
样例1输入：`5 1 2 2 1 3`，书的颜色序列是`[1,2,2,1,3]`。

1. **初始化**：  
   - 屏幕左侧：5个像素块（颜色依次为红、绿、绿、红、蓝）；  
   - 右侧控制面板：“开始”“单步”“重置”按钮，速度滑块；  
   - 底部状态区：`i=5`，`cnt[蓝]=0`，`dp[5]=0`；  
   - 背景音乐：8位风格的《卡农》片段。

2. **处理i=5（颜色3，左端点）**：  
   - 高亮`i=5`（黄色边框）；  
   - `cnt[蓝]`变为1（状态区蓝色计数器+1）；  
   - 因为是左端点，`dp[5] = max(dp[6]=0, 1 + dp[6]=0) =1`（状态区dp数值跳变为1）；  
   - 用蓝色框框住`i=5`（区间`[5,5]`），伴随“叮”的音效；  
   - 旁白：“处理位置5，是颜色3的左端点，保留1本，dp[5]=1！”。

3. **处理i=4（颜色1，非左端点）**：  
   - 高亮`i=4`；  
   - `cnt[红]`变为1；  
   - 非左端点，`dp[4] = max(dp[5]=1, 1) =1`？不对，等一下——倒序处理到`i=4`时，`cnt[红]`是`i=4`到`5`的红书数量（1本），但样例中`i=4`的红书后面还有`i=1`的红书，所以非左端点时保留后缀红书（1本），`dp[4]=1`？不，等样例1的正确dp数组是`dp[1]=3`，`dp[2]=3`，`dp[3]=2`，`dp[4]=2`，`dp[5]=1`——哦，我刚才算错了，`i=4`的`cnt[红]`应该是2？因为倒序处理到`i=4`时，`i=4`是红书，`i=1`还没处理，所以`cnt[红]`是`i=4`到`5`的红书数量？不对，等原代码中`cnt`数组是全局的，倒序处理时，`i`从`n`到`1`，每遇到`a[i]`就`cnt[a[i]]++`，所以对于样例1：  
     - `i=5`：`a[5]=3`，`cnt[3]=1`；  
     - `i=4`：`a[4]=1`，`cnt[1]=1`；  
     - `i=3`：`a[3]=2`，`cnt[2]=1`；  
     - `i=2`：`a[2]=2`，`cnt[2]=2`；  
     - `i=1`：`a[1]=1`，`cnt[1]=2`；  
   所以`i=4`的`cnt[1]=1`，非左端点，`dp[4] = max(dp[5]=1, 1) =1`？但样例1的正确`dp[4]`是2？哦，原代码中的`cnt`数组是**后缀中同色书的数量**，但样例1中`i=4`的后缀是`[1,3]`，红书数量是1，绿书0，蓝书1——那`dp[4]`为什么是2？哦，等原代码中的`dp[4]`是`max(dp[5]=1, cnt[1]=1)`？不对，样例1的正确`dp`数组应该是：  
   原代码运行样例1的情况：  
   - `dp[6]=0`；  
   - `i=5`：`dp[5]=max(0, 1+0)=1`；  
   - `i=4`：`dp[4]=max(1, 1)=1`（因为`i=4`不是左端点，`cnt[1]=1`）；  
   - `i=3`：`a[3]=2`，`cnt[2]=1`，非左端点，`dp[3]=max(1,1)=1`；  
   - `i=2`：`a[2]=2`，`cnt[2]=2`，是左端点（`l[2]=2`），`dp[2]=max(1, 2+dp[4]=1)=3`；  
   - `i=1`：`a[1]=1`，`cnt[1]=2`，是左端点（`l[1]=1`），`dp[1]=max(3, 2+dp[5]=1)=3`；  
   所以`n-dp[1]=5-3=2`，正确。哦，原来我之前对`dp[4]`的理解错了，`dp[4]`是1，`dp[2]`是3（因为`i=2`是左端点，合并`dp[4]=1`，得到`2+1=3`）。  

   回到动画步骤：  
3. **处理i=4（颜色1，非左端点）**：  
   - 高亮`i=4`（红色像素块）；  
   - `cnt[红]`变为1（状态区红色计数器+1）；  
   - 非左端点，`dp[4] = max(dp[5]=1, 1) =1`（状态区dp数值跳变为1）；  
   - 旁白：“处理位置4，不是颜色1的左端点，保留后缀中1本红书，dp[4]=1！”。

4. **处理i=3（颜色2，非左端点）**：  
   - 高亮`i=3`（绿色像素块）；  
   - `cnt[绿]`变为1；  
   - 非左端点，`dp[3] = max(dp[4]=1,1)=1`；  
   - 旁白：“处理位置3，不是颜色2的左端点，保留后缀中1本绿书，dp[3]=1！”。

5. **处理i=2（颜色2，左端点）**：  
   - 高亮`i=2`；  
   - `cnt[绿]`变为2；  
   - 是左端点，`dp[2] = max(dp[3]=1, 2 + dp[4]=1) =3`；  
   - 用蓝色框框住`i=2`到`i=3`（区间`[2,3]`），伴随“叮”的音效；  
   - 旁白：“处理位置2，是颜色2的左端点，保留2本绿书+右边的1本，dp[2]=3！”。

6. **处理i=1（颜色1，左端点）**：  
   - 高亮`i=1`；  
   - `cnt[红]`变为2；  
   - 是左端点，`dp[1] = max(dp[2]=3, 2 + dp[5]=1) =3`；  
   - 用蓝色框框住`i=1`到`i=4`（区间`[1,4]`），伴随“叮”的音效；  
   - 旁白：“处理位置1，是颜色1的左端点，保留2本红书+右边的1本，dp[1]=3！”。

7. **完成**：  
   - 书架变为`[2,2,3,1,1]`（同色书相邻）；  
   - 状态区显示：`dp[1]=3`，移动次数`5-3=2`；  
   - 播放胜利音效（8位风格的“叮当当”）；  
   - 旁白：“整理完成！最少需要移动2次！”。


### 交互设计  
- **单步执行**：按“下一步”按钮，逐帧观看处理过程；  
- **自动播放**：拖动速度滑块调整播放速度（慢/中/快）；  
- **重置**：回到初始状态，重新开始；  
- **音效控制**：可开关背景音乐和操作音效。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
倒序DP的思想能解决很多“正难则反”的问题，下面是几个经典应用场景和练习推荐：
</similar_problems_intro>

### 通用思路迁移  
倒序DP常用于以下场景：  
1. **最少删除次数使序列递增**：倒序计算最长递增子序列（LIS），删除次数=总数-LIS长度；  
2. **最多保留多少元素使区间不重叠**：倒序处理区间，选择不重叠的区间；  
3. **最少操作次数使字符串变回文**：倒序计算最长回文子序列（LPS），操作次数=长度-LPS长度。

### 洛谷练习推荐  
1. **洛谷P1048 采药**（01背包，倒序DP）  
   - 🗣️ **推荐理由**：经典的倒序DP问题，练习“从后往前决策”的思路，巩固DP的状态转移。  
2. **洛谷P1156 垃圾陷阱**（倒序DP）  
   - 🗣️ **推荐理由**：需要考虑“时间倒序”的DP问题，锻炼状态转移的条件判断能力。  
3. **洛谷P1216 数字三角形**（倒序DP）  
   - 🗣️ **推荐理由**：入门级倒序DP问题，帮助理解“从后往前累加最优解”的核心思想。  
4. **洛谷P3902 递增**（倒序DP）  
   - 🗣️ **推荐理由**：与本题思路类似，计算最长递增子序列，练习“正难则反”的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的作者心得能帮你避免踩坑，我摘录了2条最有价值的：
</insights_intro>

> **参考经验（来自@huayucaiji）**：“我最初在非左端点时错误地加上了`f[r[a[i]]+1]`，导致结果错误。后来通过样例分析发现，这会导致区间重叠——比如样例1中`i=4`的同色区间是`[1,4]`，合并`f[5]`会让`[1,4]`和`[5,5]`重叠，结果偏大。”  
> **点评**：很多学习者会忽略转移条件的限制，这位作者的经验提醒我们：**转移方程的每一步都要理解本质，不能想当然**。通过样例验证能快速发现错误。

> **参考经验（来自@流沫）**：“我补充了非左端点的转移理由——‘费用提前计算’，这让我明白为什么要取`cnt[a[i]]`：非左端点时，保留后缀同色书意味着其他书都要移动，所以直接取同色书数量，提前把移动成本算进去。”  
> **点评**：补充细节能帮你深入理解算法。对于复杂的转移条件，一定要问自己“为什么要这样写”，而不是死记硬背。


## 结论  
本次分析帮你掌握了“Sorting Books”的核心思路——倒序DP计算最大保留数。记住：**正难则反**是DP的常用技巧，**倒序处理**能简化后缀问题，**区间不重叠**是转移的关键限制。  

编程能力的提升在于“思考+练习”：多想“为什么”，多做相似题，你会越来越熟练！下次我们再一起探索新的算法挑战~ 💪

---
处理用时：185.30秒
# 题目信息

# MCMF?

## 题目描述

给定两个整数数组 $a$ 和 $b$（$b_i \neq 0$ 且 $|b_i| \leq 10^9$）。数组 $a$ 已按非递减顺序排序。

定义子数组 $a[l:r]$ 的代价如下：

- 如果 $ \sum\limits_{j = l}^{r} b_j \neq 0 $，则该子数组的代价未定义。
- 否则：
  
  - 构建一个二分图流网络，包含 $r-l+1$ 个顶点，编号为 $l$ 到 $r$，所有 $b_i<0$ 的顶点在左侧，$b_i>0$ 的顶点在右侧。对于每一对 $i, j$ 满足 $l \leq i, j \leq r$，$b_i<0$ 且 $b_j>0$，从 $i$ 向 $j$ 连一条容量为无穷大、单位流量费用为 $|a_i-a_j|$ 的边。
  - 再添加两个顶点：源点 $S$ 和汇点 $T$。
  - 对于每个 $l \leq i \leq r$ 且 $b_i<0$，从 $S$ 向 $i$ 连一条容量为 $|b_i|$、费用为 $0$ 的边。
  - 对于每个 $l \leq i \leq r$ 且 $b_i>0$，从 $i$ 向 $T$ 连一条容量为 $|b_i|$、费用为 $0$ 的边。
  - 子数组的代价定义为从 $S$ 到 $T$ 的最大流的最小费用。

你将会得到 $q$ 个询问，每个询问给出两个整数 $l$ 和 $r$。你需要计算每个询问对应的子数组 $a[l:r]$ 的代价，结果对 $10^9+7$ 取模。

如果你不了解最小费用最大流的含义，可以阅读[这里](https://en.wikipedia.org/wiki/Minimum-cost_flow_problem)。

## 说明/提示

在第一个询问中，最大可能流量为 $1$，即从源点到 $2$，再从 $2$ 到 $3$，最后从 $3$ 到汇点，流量均为 $1$。流量的总代价为 $0 \cdot 1 + |2 - 4| \cdot 1 + 0 \cdot 1 = 2$。

在第二个询问中，最大可能流量仍为 $1$，即从源点到 $7$，$7$ 到 $6$，$6$ 到汇点，总代价为 $0 \cdot |10 - 10| \cdot 1 + 0 \cdot 1 = 0$。

在第三个询问中，流网络如左图所示，边上标注了容量，括号内为费用。右图展示了最优流量分配。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1682F/b6040909c6a89f65b5b7d87c18e4b15cd451816a.png) 最大流量为 $3$，总代价为 $0 \cdot 3 + 1 \cdot 1 + 4 \cdot 2 + 0 \cdot 1 + 0 \cdot 2 = 9$。

在第四个询问中，流网络如下所示——

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1682F/785b5422d5947aa6cf07e9905d5c183db07a5c80.png)

最小费用最大流的最优分配如下——

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1682F/58ed2fd428ae0881741713ff33b82d81dd69edde.png)

上述网络的最大流量为 $4$，最小费用为 $15$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
8 4
1 2 4 5 9 10 10 13
6 -1 1 -3 2 1 -1 1
2 3
6 7
3 5
2 6```

### 输出

```
2
0
9
15```

# AI分析结果


### 💡 Kay的C++算法解析：MCMF? 深入学习指南 💡

<introduction>
今天我们分析一道巧妙结合网络流与数学转化的题目"MCMF?"。你将学会如何将复杂的最小费用最大流问题转化为简洁的数学表达式，并掌握利用数据结构高效处理查询的技巧。准备好开始算法探险了吗？
</introduction>

---
## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学转化 + 数据结构优化`  

🗣️ **初步分析**：
> 这道题看似需要计算最小费用最大流，实则可通过数学洞察转化为优雅的表达式。想象在一条数轴上（如经典游戏《铁路大亨》），**入口**(b>0)和**出口**(b<0)分别位于坐标a_i处。人们从入口移动到出口时，总路程可拆解为相邻坐标间路段的累计通行量：
>   - **核心公式**：代价 = Σ(a_{i+1}-a_i)×|前缀和s_i - s_{l-1}|（s为b的前缀和）
>   - **关键难点**：绝对值导致分段函数，需分类讨论s_i与s_{l-1}的大小关系
>   - **可视化设计**：像素数轴动态显示入口(绿)/出口(红)位置，实时统计路段通行量（计数器↑↓）。树状数组更新时触发"滴"音效，查询完成播放胜利音效
>   - **游戏化元素**：数轴采用8-bit风格（如《超级玛丽》地面），控制面板支持调速/单步执行，通关动画显示总代价

---
## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码质量、算法优化等维度精选3篇≥4星题解，助你快速掌握核心技巧：
</eval_intro>

**题解一：(来源：feecle6418)**
* **点评**：直击本质！仅用两行推导出核心公式（∑(a_{i+1}-a_i)|s_i-s_{l-1}|），揭示本题与经典问题"LNOI2022盒"的等价性。虽未提供代码，但思路启发性强，堪称"解题模板书"级示范。

**题解二：(来源：qczrz6v4nhp6u)**
* **点评**：完美诠释"问题转化"艺术——将网络流建模为**数轴人口迁移问题**（入口挤满人→移动到出口）。代码中离散化前缀和+拆绝对值处理清晰规范（如s_i>s_{l-1}和s_i≤s_{l-1}分类），二维数点实现简洁，实践参考价值极高。

**题解三：(来源：lingfunny)**
* **点评**：独创性提出**拆点排序匹配法**，虽初始思路复杂（拆成|b_i|个点），最终仍收敛到同一公式。亮点在利用**后缀差分性质**（ans[l]-ans[r+1]）降低复杂度。线段树实现完整，变量命名规范（rk/memo），边界处理严谨。

---
## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关键点，结合优质题解策略总结如下：
</difficulty_intro>

1.  **关键点1：网络流模型到数轴迁移的转化**
    * **分析**：洞察"费用=移动距离总和"是突破核心（如qczrz6v4nhp6u的比喻）。迁移时，相邻点间路段通过量=|s_i-s_{l-1}|，类似火车轨道通行计数。
    * 💡 **学习笔记**：复杂模型常蕴含简单物理意义，尝试构建现实比喻

2.  **关键点2：绝对值的分段处理**
    * **分析**：|s_i-s_{l-1}|需按s_i>s_{l-1}和s_i≤s_{l-1}分类（如lingfunny代码的if(b_i>0)分支）。离散化前缀和后，可用数据结构维护分段函数。
    * 💡 **学习笔记**：拆解绝对值本质是划分定义域，树状数组天然支持分段统计

3.  **关键点3：多查询的高效处理**
    * **分析**：离线查询+扫描线是关键（如Purslane解法）。将查询按右端点排序，遍历时动态维护当前位置对各类s_{l-1}的贡献，避免重复计算。
    * 💡 **学习笔记**：离线处理是区间查询优化利器，配合离散化效果更佳

### ✨ 解题技巧总结
<summary_best_practices>
掌握以下技巧，轻松应对同类问题：
</summary_best_practices>
-   **技巧1：模型转化优先** - 复杂问题先寻找等价物理模型（如数轴迁移），避免直接硬解
-   **技巧2：贡献拆解** - 将整体代价拆为元素/相邻对的独立贡献（如(a_{i+1}-a_i)独立计算）
-   **技巧3：离散化+数据结构** - 遇到绝对值/前缀和比较时，离散化后使用树状数组/线段树维护分段函数
-   **技巧4：差分性质利用** - 当∑b_i=0时，考虑后缀差分解法（ans[l]-ans[r+1]）

---
## 4. C++核心代码实现赏析

<code_intro_overall>
以下通用实现基于Purslane解法优化，融合离线处理+树状数组，兼顾效率与可读性：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合优质题解思路，采用树状数组维护离散化前缀和，支持高效查询
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;
    const int MAXN = 2e5 + 10, MOD = 1e9 + 7;
    int n, q, a[MAXN], b[MAXN], pre[MAXN], lsh[MAXN * 2], tot, ans[MAXN];
    vector<tuple<int, int, int>> qr[MAXN];  // (查询基准值, 查询id, 符号)

    struct BIT {
        vector<int> tr; int n;
        void init(int N) { n = N; tr.resize(N + 1); }
        void update(int pos, int v) {
            for (; pos <= n; pos += pos & -pos) 
                tr[pos] = (tr[pos] + v) % MOD;
        }
        int query(int pos) {
            int res = 0;
            for (; pos; pos -= pos & -pos)
                res = (res + tr[pos]) % MOD;
            return res;
        }
    } T1, T2;  // T1: Σ(a_i * s_i), T2: Σa_i

    signed main() {
        // 输入与预处理
        cin >> n >> q;
        for (int i = 1; i <= n; i++) cin >> a[i];
        for (int i = 1; i <= n; i++) cin >> b[i];
        
        // 计算前缀和并离散化
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + b[i];
        for (int i = 0; i <= n; i++) lsh[++tot] = pre[i];
        sort(lsh + 1, lsh + tot + 1);
        tot = unique(lsh + 1, lsh + tot + 1) - lsh - 1;
        for (int i = 0; i <= n; i++)
            pre[i] = lower_bound(lsh + 1, lsh + tot + 1, pre[i]) - lsh;

        // 存储查询（离线）
        for (int i = 1; i <= q; i++) {
            int l, r; cin >> l >> r;
            qr[r].emplace_back(pre[l - 1], i, 1);
            if (l > 1) qr[l - 1].emplace_back(pre[l - 1], i, -1);
        }

        T1.init(tot); T2.init(tot);
        for (int i = 1; i <= n; i++) {
            // 加入当前点贡献
            T1.update(pre[i - 1], a[i] * (lsh[pre[i - 1]] % MOD) % MOD);
            T2.update(pre[i - 1], a[i] % MOD);
            T1.update(pre[i], -a[i] * (lsh[pre[i]] % MOD) % MOD);
            T2.update(pre[i], -a[i] % MOD);

            // 处理以i结尾的查询
            for (auto [val, id, sgn] : qr[i]) {
                int sum1 = T1.query(val), sum2 = T2.query(val);
                int sum_all1 = T1.query(tot), sum_all2 = T2.query(tot);
                int res = (lsh[val] * sum2 - sum1) % MOD;
                res += (sum_all1 - T1.query(val)) - lsh[val] * (sum_all2 - sum2) % MOD;
                ans[id] = (ans[id] + sgn * res) % MOD;
            }
        }
        // 输出结果
        for (int i = 1; i <= q; i++)
            cout << (ans[i] + MOD) % MOD << '\n';
    }
    ```
* **代码解读概要**：
    > 1. **预处理**：计算前缀和`pre`并离散化（所有查询基准值s_{l-1}对应离散值）  
    > 2. **离线查询**：按右端点存储查询，便于扫描线处理  
    > 3. **双树状数组**：  
    >    - `T1`维护a_i * s_i的贡献  
    >    - `T2`维护a_i的系数  
    > 4. **动态更新**：遍历时先更新当前点对树状数组的贡献（pre[i-1]加，pre[i]减）  
    > 5. **分段计算**：对每个查询按val分段计算∑|s_i - val|  

---
<code_intro_selected>
精选题解核心片段解析：
</code_intro_selected>

**题解一：(来源：feecle6418)**
* **亮点**：用物理直觉直击核心公式，避开复杂实现
* **核心代码片段**：
    ```cpp
    // 理论核心：单行公式解决
    ans = Σ_{i=l}^{r-1} (a_{i+1} - a_i) * |s_i - s_{l-1}|;
    ```
* **代码解读**：
    > 该解法揭示本质规律：代价仅取决于**相邻a的差值**和**前缀和相对位置**。类比"山丘高度差×通过人数"，无需显式建图
* 💡 **学习笔记**：数学洞察可降维打击复杂算法模型

**题解二：(来源：qczrz6v4nhp6u)**
* **亮点**：完美结合问题转化与离散化
* **核心代码片段**：
    ```cpp
    // 离散化前缀和
    sort(sa, sa + n);
    tot = unique(sa, sa + n) - sa;
    // 拆解绝对值为4部分
    res += Σ_{s_i>val} c_i*s_i - val*Σ_{s_i>val} c_i;
    res -= Σ_{s_i≤val} c_i*s_i - val*Σ_{s_i≤val} c_i;
    ```
* **代码解读**：
    > 1. **离散化**：`unique`压缩前缀和值域  
    > 2. **拆绝对值**：将|s_i-val|分解为四个求和项，类似解方程时移项  
    > 3. **二维数点**：对每个查询的val，计算其与s_i的大小关系分类求和  
* 💡 **学习笔记**：拆绝对值本质是线性分段函数的表达式展开

**题解三：(来源：lingfunny)**
* **亮点**：后缀差分降低复杂度
* **核心代码片段**：
    ```cpp
    // 利用后缀性质：ans[l] = f(l) - f(r+1)
    for (int i = 1; i <= n; i++) {
        ans[i] = -T.query(rk[i]);  // 初始化
        /* 更新线段树（略） */
        ans[i] = (ans[i] + T.query(rk[i])) % MOD;
    }
    // 查询时做差分
    printf("%lld\n", (ans[l] - ans[r+1] + mod) % mod);
    ```
* **代码解读**：
    > 1. **后缀定义**：`ans[i]`表示从位置i开始到结尾的代价  
    > 2. **差分妙用**：因区间和∑b_i=0，[l,r]的代价=ans[l]-ans[r+1]  
    > 3. **线段树**：动态维护每个后缀起始点对应的贡献  
* 💡 **学习笔记**：当区间性质满足可减性时，前缀/后缀差分是降复杂度的利器

-----
## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
**"数轴迁移大冒险"**：通过8-bit像素动画演示算法核心流程。你将化身列车调度员，在FC风格数轴上指挥人口迁移，直观理解代价计算过程！
</visualization_intro>

  * **主题**：像素列车调度模拟（参考《铁路大亨》视觉风格）
  * **核心演示**：数轴人口迁移模型 + 树状数组动态更新
  * **设计思路**：采用像素风格强化位置/移动的直观感知；音效提示关键操作；树状数组可视化帮助理解离线查询优化

  * **动画帧步骤**：
    1. **场景初始化**：
        - 8-bit横向数轴（棕色像素块），标度a_i值
        - 入口站台（绿色▲）：b_i>0，显示|b_i|人数
        - 出口站台（红色▼）：b_i<0，显示待接收人数
        - 控制面板：速度滑块/单步/暂停/重置按钮

    2. **扫描线推进（像素列车动画）**：
        ```python
        # 伪代码：动画帧逻辑
        for i in range(1, n+1):
            高亮当前位置i的站台
            播放"叮"音效 # 提示新站点
            更新树状数组：
                绘制像素箭头从pre[i-1]→pre[i]
                T1节点显示a_i*lsh[pre[i-1]]（绿色↑）
                T2节点显示a_i（蓝色↑）
                播放"滴嘟"更新音效
            若当前点存在查询：
                数轴上方显示"计算区间[l,"+str(i)+"]"
                高亮所有s_i>s_{l-1}的站台（金边）
                动态绘制各路段通行量（计数器↑）
                完成时播放胜利音效+像素烟花
        ```

    3. **树状数组交互**：
        - **结构**：二叉树像素化（节点含区间范围/当前值）
        - **更新**：修改节点时触发脉冲光圈（黄→红渐变）
        - **查询**：点击节点时显示路径（蓝光连线），值求和时播放"咔嗒"音效

    4. **关键操作提示**：
        - 旁白气泡："正在更新位置"+str(i)+"，影响前缀和"+str(pre[i])
        - 高亮变化：当s_i>s_{l-1}时，对应路段通行量标记为↑红色箭头

    5. **游戏化元素**：
        - **关卡制**：每个查询视为1关，通关显示"代价="+计算结果
        - **评分系统**：根据计算速度（实际复杂度）给予★/★★/★★★评价
        - **BGM**：8-bit循环背景乐（类似《俄罗斯方块》），胜利时变奏

<visualization_conclusion>
通过像素动画，你将直观感受：**相邻a的差**是轨道长度，**前缀和差**是通行量，**树状数组**是高效调度器。这种视觉化训练能强化"贡献拆解"的思维模式！
</visualization_conclusion>

-----
## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题核心思想——**贡献拆解+离散化处理**，可解决以下相似问题：
</similar_problems_intro>

  * **技巧迁移场景**：
    1. 区间绝对值和问题（如P2512糖果传递）
    2. 带权逆序对统计（如P1969积木大赛变形）
    3. 离线查询结合扫描线（如P5490扫描线）

  * **练习推荐 (洛谷)**：
    1.  **P2512 [HAOI2008]糖果传递**  
        🗣️ **推荐理由**：环形版人口迁移问题，强化前缀和与中位数应用
    2.  **P1969 积木大赛**  
        🗣️ **推荐理由**：差分数组经典应用，训练相邻元素贡献思维
    3.  **P5490 【模板】扫描线**  
        🗣️ **推荐理由**：掌握离线处理+线段树维护的通用范式

-----
## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中藏有宝贵实战经验，值得借鉴：
</insights_intro>

> **参考经验 (来自 lingfunny)**：  
> "拆点时曾忽略b_i符号处理，调试发现贡献计算反向后，增加符号断言检查"  
>
> **点评**：这提醒我们：  
> 1. **边界测试**：务必验证b_i>0和b_i<0的对称性  
> 2. **防御性编程**：关键分支前加assert(b_i!=0)  
> 3. **调试技巧**：小规模数据手工验算（如样例4的迁移路径）  

<conclusion>
本次探索揭示了算法优化的精髓：通过**数学转化**将复杂网络流问题降维为可计算的表达式，再借**数据结构**实现高效求解。记住，优秀的程序员既是数学家也是工程师！下次挑战再见！💪
</conclusion>
```

---
处理用时：240.95秒
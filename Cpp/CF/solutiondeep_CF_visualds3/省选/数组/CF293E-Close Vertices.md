# é¢˜ç›®ä¿¡æ¯

# Close Vertices

## é¢˜ç›®æè¿°

You've got a weighted tree, consisting of $ n $ vertices. Each edge has a non-negative weight. The length of the path between any two vertices of the tree is the number of edges in the path. The weight of the path is the total weight of all edges it contains.

Two vertices are close if there exists a path of length at most $l$ between them and a path of weight at most $w$ between them. Count the number of pairs of vertices $v,u(v<u)$, such that vertices $v$ and $u$ are close.

## æ ·ä¾‹ #1

### è¾“å…¥

```
4 4 6
1 3
1 4
1 3
```

### è¾“å‡º

```
4
```

## æ ·ä¾‹ #2

### è¾“å…¥

```
6 2 17
1 3
2 5
2 13
1 6
5 9
```

### è¾“å‡º

```
9
```

# AIåˆ†æç»“æœ


### ğŸ’¡ Kayçš„C++ç®—æ³•è§£æï¼šClose Vertices æ·±å…¥å­¦ä¹ æŒ‡å— ğŸ’¡

#### 1. é¢˜ç›®è§£è¯»ä¸æ ¸å¿ƒç®—æ³•è¯†åˆ«
âœ¨ **æœ¬é¢˜ä¸»è¦è€ƒå¯Ÿ**ï¼šç‚¹åˆ†æ²» + æ ‘çŠ¶æ•°ç»„ï¼ˆäºŒç»´ååºå¤„ç†ï¼‰

ğŸ—£ï¸ **åˆæ­¥åˆ†æ**ï¼š
> è§£å†³"Close Vertices"çš„å…³é”®åœ¨äºç‚¹åˆ†æ²»æ¡†æ¶é…åˆæ ‘çŠ¶æ•°ç»„å¤„ç†äºŒç»´ååºã€‚ç‚¹åˆ†æ²»å¦‚åŒåœ¨è¿·å®«ä¸­å¯»æ‰¾ä¸­å¿ƒæŒ‡æŒ¥éƒ¨ï¼Œå°†æ ‘åˆ†è§£ä¸ºæ›´å°çš„å­é—®é¢˜ï¼›æ ‘çŠ¶æ•°ç»„åˆ™åƒé«˜æ•ˆçš„åˆ†ç±»æ”¶çº³ç›’ï¼Œå¿«é€Ÿç»Ÿè®¡æ»¡è¶³åŒé™åˆ¶çš„è·¯å¾„æ•°é‡ã€‚

- **æ ¸å¿ƒæ€è·¯**ï¼šé€šè¿‡ç‚¹åˆ†æ²»éå†é‡å¿ƒï¼Œå¯¹æ¯ä¸ªé‡å¿ƒæ”¶é›†å­æ ‘è·¯å¾„ä¿¡æ¯ï¼ˆé•¿åº¦+æƒå€¼ï¼‰ã€‚é€šè¿‡æ’åºé™ç»´åï¼Œç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤é•¿åº¦é™åˆ¶ï¼ŒåŒæŒ‡é’ˆå¤„ç†æƒå€¼é™åˆ¶ã€‚
- **ç®—æ³•æµç¨‹**ï¼š
  1. æ‰¾é‡å¿ƒ â†’ 2. æ”¶é›†è·¯å¾„ â†’ 3. æŒ‰æƒå€¼æ’åº â†’ 4. åŒæŒ‡é’ˆæ‰«æï¼ˆæƒå€¼é™åˆ¶ï¼‰â†’ 5. æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ï¼ˆé•¿åº¦é™åˆ¶ï¼‰
- **å¯è§†åŒ–è®¾è®¡**ï¼šé‡‡ç”¨8ä½åƒç´ é£æ ¼ï¼ˆFCçº¢ç™½æœºUIï¼‰ã€‚æ ‘ç»“æ„ç”¨å½©è‰²åƒç´ å—è¡¨ç¤ºï¼Œé‡å¿ƒé—ªçƒé‡‘è‰²å…‰èŠ’ã€‚åŒæŒ‡é’ˆç§»åŠ¨æ—¶è§¦å‘è“è‰²/çº¢è‰²é«˜äº®ï¼Œæ ‘çŠ¶æ•°ç»„æ›´æ–°æ—¶æ˜¾ç¤ºç»¿è‰²æ³¢åŠ¨ã€‚éŸ³æ•ˆåŒ…æ‹¬ï¼š"å®"ï¼ˆæ’å…¥ï¼‰ã€"å’”å—’"ï¼ˆæŸ¥è¯¢ï¼‰ã€èƒœåˆ©éŸ³æ•ˆï¼ˆæ‰¾åˆ°è§£ï¼‰ã€‚

---

### 2. ç²¾é€‰ä¼˜è´¨é¢˜è§£å‚è€ƒ
**é¢˜è§£ä¸€ï¼ˆä½œè€…ï¼šda32s1daï¼‰**
* **ç‚¹è¯„**ï¼šæ€è·¯æ¸…æ™°åº¦â˜…â˜…â˜…â˜…â˜…ã€‚æ ¸å¿ƒè´¡çŒ®åœ¨äºå°†äºŒç»´é™åˆ¶æ‹†è§£ï¼šæƒå€¼æ’åº+åŒæŒ‡é’ˆç»´æŠ¤åŒºé—´ï¼Œé•¿åº¦ç”¨æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡ã€‚ä»£ç è§„èŒƒæ€§â˜…â˜…â˜…â˜…ï¼ˆå˜é‡å`dis/dep`å«ä¹‰æ˜ç¡®ï¼‰ï¼Œè¾¹ç•Œå¤„ç†ä¸¥è°¨ï¼ˆ`+1`é¿å…é›¶ä¸‹æ ‡ï¼‰ã€‚ç®—æ³•äº®ç‚¹ï¼šç©ºé—´ä¼˜åŒ–ï¼ˆO(n)ï¼‰ï¼Œå®è·µå¯ç›´æ¥ç”¨äºç«èµ›ã€‚

**é¢˜è§£äºŒï¼ˆä½œè€…ï¼šConan15ï¼‰**
* **ç‚¹è¯„**ï¼šæ€è·¯æ¸…æ™°åº¦â˜…â˜…â˜…â˜…â˜†ã€‚é‡‡ç”¨ç»å…¸ç‚¹åˆ†æ²»æ¡†æ¶ï¼Œæ ‘çŠ¶æ•°ç»„åŒé‡é™åˆ¶å¤„ç†ç›´æ¥ã€‚ä»£ç å¯è¯»æ€§â˜…â˜…â˜…â˜…ï¼ˆç»“æ„ä½“å°è£…è·¯å¾„æ•°æ®ï¼‰ã€‚äº®ç‚¹ï¼šå®Œæ•´æ³¨é‡Šè¯´æ˜å®¹æ–¥åŸç†ï¼Œè°ƒè¯•æŠ€å·§ï¼ˆè¾¹ç•Œæ¡ä»¶æ‰“å°ï¼‰æå…·å‚è€ƒä»·å€¼ã€‚

---

### 3. æ ¸å¿ƒéš¾ç‚¹è¾¨æä¸è§£é¢˜ç­–ç•¥
1. **éš¾ç‚¹ï¼šäºŒç»´é™åˆ¶çš„ååŒå¤„ç†**
   * **åˆ†æ**ï¼šå•ç‹¬å¤„ç†ä»»ä¸€é™åˆ¶ï¼ˆé•¿åº¦æˆ–æƒå€¼ï¼‰è¾ƒç®€å•ï¼Œä½†åŒé™åˆ¶éœ€é«˜æ•ˆäºŒç»´ç»Ÿè®¡ã€‚ä¼˜è´¨é¢˜è§£é€šè¿‡"æ’åºé™ç»´+æ ‘çŠ¶æ•°ç»„"å°†é—®é¢˜è½¬åŒ–ä¸ºO(n log n)å¯è§£é—®é¢˜ã€‚
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šäºŒç»´ååºé—®é¢˜ï¼Œå›ºå®šä¸€ç»´å¤„ç†å¦ä¸€ç»´æ˜¯é€šç”¨æŠ€å·§ã€‚

2. **éš¾ç‚¹ï¼šé¿å…é‡å¤è®¡æ•°**
   * **åˆ†æ**ï¼šç‚¹åˆ†æ²»ä¸­åŒä¸€å­æ ‘ç‚¹å¯¹è¢«é‡å¤ç»Ÿè®¡ã€‚è§£å†³æ–¹æ¡ˆï¼šå…ˆç®—æ•´æ£µæ ‘ç‚¹å¯¹ï¼Œå†å‡å­æ ‘å†…ç‚¹å¯¹ï¼ˆå®¹æ–¥ï¼‰ã€‚
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼š"æ•´ä½“-å±€éƒ¨"å®¹æ–¥æ˜¯ç‚¹åˆ†æ²»é˜²é‡çš„æ ¸å¿ƒæ‰‹æ®µã€‚

3. **éš¾ç‚¹ï¼šæ ‘çŠ¶æ•°ç»„è¾¹ç•Œå¤„ç†**
   * **åˆ†æ**ï¼šè·¯å¾„é•¿åº¦å¯èƒ½ä¸º0å¯¼è‡´æ ‘çŠ¶æ•°ç»„ä¸‹æ ‡é”™è¯¯ã€‚è§£å†³æ–¹æ¡ˆï¼šç»Ÿä¸€`dep+1`åç§»ã€‚
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šæ ‘çŠ¶æ•°ç»„/çº¿æ®µæ ‘ä¸­ï¼Œä¸‹æ ‡ä»1å¼€å§‹æ—¶éœ€é¢„åç§»ã€‚

âœ¨ **è§£é¢˜æŠ€å·§æ€»ç»“**ï¼š
- **é™ç»´æ‰“å‡»**ï¼šé«˜ç»´é™åˆ¶é€šè¿‡æ’åºé™è‡³ä½ç»´å¤„ç†
- **åˆ†æ²»ç­–ç•¥**ï¼šç‚¹åˆ†æ²»é€’å½’æ—¶ä¼˜å…ˆå¤„ç†å¤§å­æ ‘æå‡æ•ˆç‡
- **é˜²å¾¡æ€§ç¼–ç¨‹**ï¼šè¾¹ç•Œæ£€æŸ¥ï¼ˆå¦‚`if(dis>w) continue`æå‰å‰ªæï¼‰

---

### 4. C++æ ¸å¿ƒä»£ç å®ç°èµæ
**é€šç”¨æ ¸å¿ƒå®ç°å‚è€ƒ**
```cpp
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;

struct BIT { // æ ‘çŠ¶æ•°ç»„æ¨¡æ¿
    int t[N];
    void update(int x, int v) { 
        for(x++; x < N; x += x&-x) t[x] += v; 
    }
    int query(int x) { 
        int res = 0;
        for(x = min(x+1, N-1); x; x -= x&-x) res += t[x];
        return res;
    }
} bit;

void solve(int u) {
    vector<pair<int, int>> paths; // å­˜å‚¨è·¯å¾„(dep, dis)
    // 1. æ”¶é›†æ‰€æœ‰å­æ ‘è·¯å¾„
    for(auto [v, w] : G[u]) { 
        vector<pair<int, int>> tmp;
        dfs(v, u, 1, w, tmp); // DFSæ”¶é›†è·¯å¾„
        // 2. å®¹æ–¥ï¼šå…ˆå‡å­æ ‘å†…ç‚¹å¯¹
        ans -= count_pairs(tmp); 
        paths.insert(paths.end(), tmp.begin(), tmp.end());
    }
    // 3. è®¡ç®—æ•´æ£µæ ‘ç‚¹å¯¹
    ans += count_pairs(paths);
}

ll count_pairs(vector<pair<int, int>>& v) {
    sort(v.begin(), v.end(), [](auto a, auto b){
        return a.second < b.second; // æŒ‰æƒå€¼æ’åº
    });
    ll res = 0;
    int r = v.size() - 1;
    // 4. åŒæŒ‡é’ˆ+æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡
    for(int l = 0; l < v.size(); l++) {
        while(r >= l && v[l].second + v[r].second > W) {
            bit.update(v[r].first, -1); r--;
        }
        res += bit.query(L - v[l].first); // é•¿åº¦é™åˆ¶æŸ¥è¯¢
        bit.update(v[l].first, 1);
    }
    // 5. æ¸…ç†æ ‘çŠ¶æ•°ç»„
    for(int i = 0; i <= r; i++) bit.update(v[i].first, -1);
    return res;
}
```

---

### 5. ç®—æ³•å¯è§†åŒ–ï¼šåƒç´ åŠ¨ç”»æ¼”ç¤º
**ä¸»é¢˜**ï¼š"åƒç´ æ¢é™©å®¶"çš„æ ‘å½¢è¿·å®«  
**æ ¸å¿ƒæ¼”ç¤º**ï¼š
```mermaid
graph LR
  A[é‡å¿ƒ] --> B[å­æ ‘1æ”¶é›†è·¯å¾„]
  A --> C[å­æ ‘2æ”¶é›†è·¯å¾„]
  B --> D[æŒ‰æƒå€¼æ’åº]
  C --> D
  D --> E[åŒæŒ‡é’ˆæ‰«æ]
  E --> F[æ ‘çŠ¶æ•°ç»„æ›´æ–°]
```

**åŠ¨ç”»æµç¨‹**ï¼š
1. **åœºæ™¯åˆå§‹åŒ–**ï¼šæ ‘ç»“æ„åŒ–ä¸ºç½‘æ ¼è¿·å®«ï¼Œé‡å¿ƒé—ªçƒé‡‘å…‰ï¼Œå­æ ‘ç”¨ä¸åŒé¢œè‰²åŒºå—æ ‡è¯†
2. **è·¯å¾„æ”¶é›†é˜¶æ®µ**ï¼šDFSç§»åŠ¨åƒç´ å°äººï¼Œè½¨è¿¹æ˜¾ç¤ºè·¯å¾„é•¿åº¦/æƒå€¼ï¼ˆå¦‚æƒå€¼â†’é«˜åº¦ï¼Œé•¿åº¦â†’é¢œè‰²æ·±åº¦ï¼‰
3. **æ’åºè¿‡ç¨‹**ï¼šè·¯å¾„æ°”æ³¡æŒ‰æƒå€¼ä¸Šå‡æ’åˆ—ï¼Œä¼´éš"å—–"çš„éŸ³æ•ˆ
4. **åŒæŒ‡é’ˆæ“ä½œ**ï¼š
   - å·¦æŒ‡é’ˆï¼ˆè“è‰²ï¼‰å³ç§»ï¼šè§¦å‘"å®"å£°ï¼Œæ ‘çŠ¶æ•°ç»„å¯¹åº”é•¿åº¦ä½ç½®äº®ç»¿å…‰
   - å³æŒ‡é’ˆï¼ˆçº¢è‰²ï¼‰å·¦ç§»ï¼šè§¦å‘"å’”"å£°ï¼Œæ ‘çŠ¶æ•°ç»„ä½ç½®ç­ç¯
5. **ç»“æœåé¦ˆ**ï¼šæ‰¾åˆ°åˆæ³•è·¯å¾„æ—¶ç›®æ ‡èŠ‚ç‚¹æ”¾çƒŸèŠ±ï¼Œæ’­æ”¾èƒœåˆ©éŸ³æ•ˆ

**äº¤äº’æ§åˆ¶**ï¼š
- æ­¥è¿›æ¨¡å¼ï¼šç©ºæ ¼é”®å•æ­¥æ‰§è¡Œ
- è‡ªåŠ¨æ¼”ç¤ºï¼šé€Ÿåº¦æ»‘å—è°ƒèŠ‚ï¼ˆ1x-5xï¼‰
- é‡ç½®æŒ‰é’®ï¼šRé”®é‡å¯åŠ¨ç”»

---

### 6. æ‹“å±•ç»ƒä¹ ä¸ç›¸ä¼¼é—®é¢˜
1. **P4178 Tree**  
   â†’ åŒç±»ç‚¹åˆ†æ²»é—®é¢˜ï¼Œä»…å•ç»´é™åˆ¶ï¼ˆæƒå€¼ï¼‰
2. **P4149 [IOI2011]Race**  
   â†’ è¾¹æƒé™åˆ¶+è¾¹æ•°æœ€å°åŒ–ï¼ŒåŒé™åˆ¶å˜ç§
3. **CF161D Distance in Tree**  
   â†’ å›ºå®šé•¿åº¦è·¯å¾„è®¡æ•°ï¼Œç‚¹åˆ†æ²»åŸºç¡€è®­ç»ƒ

---

> ç®—æ³•å­¦ä¹ å¦‚åŒæ¢é™©ï¼Œæ¯ä¸€æ­¥çªç ´éƒ½æ˜¯æ–°å¤§é™†çš„å‘ç°ã€‚Keep coding, the next breakthrough is just around the corner! ğŸš€

---
å¤„ç†ç”¨æ—¶ï¼š112.64ç§’
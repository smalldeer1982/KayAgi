# 题目信息

# Complete Mirror

## 题目描述

给定一棵包含 $n$ 个顶点的树。选择一个顶点作为根节点，使其满足以下条件：

- 对于所有顶点 $v_1$ 和 $v_2$，如果 $distance(root, v_1) = distance(root, v_2)$，那么 $degree(v_1) = degree(v_2)$。其中 $degree$ 表示该顶点连接的顶点数，$distance$ 表示两个顶点之间的边数。

判断是否存在这样的根节点，并输出任意一个满足条件的根节点编号。如果有多个答案，输出其中任意一个。

## 说明/提示

下图为第一个样例的树结构。$1$、$5$、$7$ 也可以作为合法答案。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1182D/bcfdfd4a236e739c696e71629ab4415dcf5e3015.png)

下图为第二个样例的树结构。可以发现无法找到满足条件的根节点。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1182D/20dc627549d275e9f12102ecd454db1d1ee42f2f.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
7
1 2
2 3
3 4
4 5
3 6
6 7
```

### 输出

```
3
```

## 样例 #2

### 输入

```
6
1 3
2 3
3 4
4 5
4 6
```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：Complete Mirror 深入学习指南 💡

<introduction>
今天我们来一起分析「Complete Mirror」这道C++编程题。题目要求找到一棵树的根节点，使得同一深度的所有节点度数相同。这道题非常考验我们对**树的结构性质**（比如重心）和**子树同构判断**的理解。本指南会帮你梳理思路、掌握核心技巧，还会用像素动画直观展示算法流程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树论（重心性质）、子树结构检查（同深度度数一致）

🗣️ **初步分析**：
解决这道题的关键，在于**利用树的重心性质缩小候选范围**，再暴力验证候选节点是否合法。简单来说：  
- **树的重心**是删除后最大子树大小最小的节点。如果一个根有多个儿子（即不是链状），它必须是重心——否则删掉它后会有一个子树太大，无法满足“同深度节点度数相同”的条件（比如样例2中，根3有3个儿子，其中两个子树大小为1，一个为3，显然无法对称）。  
- 候选节点只有两类：**树的重心**，或者**重心的链状子树的端点**（比如样例1中，重心是3，它的链状子树端点1、5、7也是合法根）。  

**核心算法流程**：  
1. 找树的重心；  
2. 检查重心是否合法；  
3. 若不合法，检查重心的链状子树端点是否合法；  
4. 都不合法则输出-1。  

**可视化设计思路**：  
我们会用**8位像素风格**展示树的结构（节点用彩色方块，边用线条），重心用**闪烁的黄色**标记，检查时同深度节点用**相同颜色**高亮，度数不同的节点用**红色闪烁**提示错误。还会加入“单步执行”“自动播放”功能，以及复古音效（比如找重心时的“滴滴”声，检查成功时的“叮”声）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速理解不同解法的核心逻辑：
</eval_intro>

**题解一：litble（赞9）**  
* **点评**：这份题解是最简洁、最贴合题意的解法！作者直接抓住了“合法根必是重心或链端点”的核心性质，步骤清晰：  
  - 用`getrt`函数找重心（经典的DFS计算子树大小）；  
  - 用`check`函数验证节点合法性（DFS计算深度，然后检查同深度节点度数）；  
  - 用`is_line`函数判断重心的子树是否是链，并返回链长和端点。  
  代码风格规范（变量名如`sz`表示子树大小，`dep`表示深度，易懂），边界处理严谨（比如链的判断条件`du[x]>2`），实践价值极高——直接可以用于竞赛。

**题解二：i207M（赞5）**  
* **点评**：作者用了**树的直径**思路（直径是树中最长路径），认为合法根要么是直径端点，要么是直径中点。这种思路拓展了我们的视野，但需要注意：  
  - 直径中点的处理（如果直径长度是偶数，没有中点）；  
  - 用树哈希（双模数）判断子树同构。  
  作者提到自己调了1小时才A，提醒我们**不要漏掉验证直径中点**，这是很好的调试经验！

**题解三：ywy_c_asm（赞2）**  
* **点评**：这份题解用了**换根DP+树哈希**，是最系统的解法！作者先DFS计算子树哈希（`dp`数组），判断子树是否合法（`candown`标记）；再换根DFS计算父方向的哈希（`dpup`数组），最终找到合法根。这种方法适用于更复杂的树同构问题，但代码较长，适合进阶学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于**如何缩小候选范围**和**高效验证合法性**。结合优质题解，我总结了3个关键点：
</difficulty_intro>

1. **关键点1：为什么合法根必是重心？**  
   * **分析**：如果根有多个儿子（不是链），删除根后每个子树的大小必须相等——否则同深度会出现度数不同的节点。而树的重心是唯一满足“删除后最大子树最小”的节点，所以只有重心能满足这个条件。  
   * 💡 **学习笔记**：树的重心是解决“对称树”问题的常用切入点！

2. **关键点2：如何高效验证节点合法性？**  
   * **分析**：验证的核心是**计算每个节点的深度**，然后检查同一深度的所有节点度数是否相同。litble的`check`函数用DFS计算深度（`dep`数组），再用`orz`数组按深度分组，最后遍历每组验证度数——时间复杂度O(n)，非常高效。  
   * 💡 **学习笔记**：按深度分组是处理“同深度条件”的常用技巧！

3. **关键点3：如何处理链状子树？**  
   * **分析**：当重心不合法时，合法根可能在重心的链状子树端点（比如样例1中，重心3的子树1-2-3是链，端点1合法）。`is_line`函数通过递归判断子树是否是链（度数≤2），并返回链端点——这样只需检查少量候选节点，避免暴力枚举。  
   * 💡 **学习笔记**：链状结构的判断条件是“所有节点度数≤2”！

### ✨ 解题技巧总结
- **性质优先**：先利用树的重心、直径等性质缩小候选范围，再暴力验证，避免枚举所有节点；  
- **分组检查**：处理“同深度”条件时，按深度分组后验证，效率更高；  
- **链状判断**：链状子树的端点是重要候选，需单独处理。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合litble题解的通用核心实现**，它覆盖了所有关键步骤，逻辑清晰：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自litble的题解，是最简洁的核心实现，涵盖“找重心→检查重心→检查链端点”的完整流程。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cstdio>
  #include <algorithm>
  using namespace std;

  const int N = 100005;
  int n, tot, rt, mi, krt, rt2, len_rt2;
  int h[N], ne[N<<1], to[N<<1], du[N], sz[N], dep[N];
  vector<int> orz[N];

  void add(int x, int y) { to[++tot] = y; ne[tot] = h[x]; h[x] = tot; }

  // 找重心
  void getrt(int x, int las) {
      sz[x] = 1; int bl = 0;
      for (int i = h[x]; i; i = ne[i]) {
          if (to[i] == las) continue;
          getrt(to[i], x);
          bl = max(bl, sz[to[i]]);
          sz[x] += sz[to[i]];
      }
      bl = max(bl, n - sz[x]);
      if (bl < mi) { mi = bl; rt = x; }
  }

  // 计算深度
  void dfs(int x, int las) {
      dep[x] = dep[las] + 1;
      for (int i = h[x]; i; i = ne[i])
          if (to[i] != las) dfs(to[i], x);
  }

  // 检查节点x是否合法
  void check(int x) {
      dfs(x, 0);
      for (int i = 1; i <= n; ++i) orz[i].clear();
      for (int i = 1; i <= n; ++i) orz[dep[i]].push_back(i);
      for (int i = 1; i <= n; ++i) {
          for (int j = 1; j < orz[i].size(); ++j)
              if (du[orz[i][j]] != du[orz[i][0]]) return;
      }
      printf("%d\n", x); exit(0);
  }

  // 判断子树是否是链，返回链长（0表示不是链），krt记录链端点
  int is_line(int x, int las) {
      if (du[x] > 2) return 0;
      if (du[x] == 1) { krt = x; return 1; }
      for (int i = h[x]; i; i = ne[i]) {
          if (to[i] == las) continue;
          int res = is_line(to[i], x);
          if (!res) return 0;
          else return res + 1;
      }
  }

  int main() {
      scanf("%d", &n);
      for (int i = 1; i < n; ++i) {
          int x, y; scanf("%d%d", &x, &y);
          add(x, y); add(y, x);
          du[x]++; du[y]++;
      }
      mi = 1e9; getrt(1, 0); // 找重心
      check(rt); // 检查重心
      // 检查重心的链状子树端点
      for (int i = h[rt]; i; i = ne[i]) {
          int len = is_line(to[i], rt);
          if (!len) continue;
          if (rt2 && len != len_rt2) { check(krt); break; }
          if (!rt2) { rt2 = krt; len_rt2 = len; check(krt); }
      }
      puts("-1");
      return 0;
  }
  ```
* **代码解读概要**：  
  1. `add`函数：建图（链式前向星）；  
  2. `getrt`函数：DFS找重心（计算子树大小`sz`，记录最大子树`bl`，更新重心`rt`）；  
  3. `dfs`函数：计算每个节点的深度`dep`；  
  4. `check`函数：按深度分组`orz`，验证同深度节点度数是否相同；  
  5. `is_line`函数：判断子树是否是链，返回链长和端点`krt`；  
  6. `main`函数：读入数据→找重心→检查重心→检查链端点→输出结果。

---

<code_intro_selected>
接下来剖析litble题解的**核心片段**，理解关键逻辑：
</code_intro_selected>

**题解一：litble**
* **亮点**：用重心性质缩小候选范围，代码简洁高效。
* **核心代码片段（找重心）**：
  ```cpp
  void getrt(int x, int las) {
      sz[x] = 1; int bl = 0;
      for (int i = h[x]; i; i = ne[i]) {
          if (to[i] == las) continue;
          getrt(to[i], x);
          bl = max(bl, sz[to[i]]);
          sz[x] += sz[to[i]];
      }
      bl = max(bl, n - sz[x]);
      if (bl < mi) { mi = bl; rt = x; }
  }
  ```
* **代码解读**：  
  - `sz[x]`记录以`x`为根的子树大小，初始为1；  
  - 遍历`x`的所有子节点`to[i]`，递归计算子树大小，更新最大子树`bl`；  
  - `n - sz[x]`是父方向的子树大小（删除`x`后，父方向的连通块大小）；  
  - 若`bl`（最大子树）比当前最小`mi`小，更新重心`rt`。  
* 💡 **学习笔记**：找重心的核心是计算“删除节点后最大子树的大小”，并取最小值对应的节点！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观理解“找重心→检查合法性”的过程，我设计了一个**8位像素风格的动画**，融合复古游戏元素，比如“重心探险家”在树中寻找正确的根！
</visualization_intro>

### 动画设计详情
#### 1. 整体风格与场景
- **像素风格**：采用FC红白机的8位色（比如节点用蓝色方块，边用灰色线条，重心用黄色闪烁）；  
- **场景布局**：屏幕左侧是树的可视化区域（节点按层次排列），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块）；  
- **背景音乐**：循环播放轻松的8位BGM（比如《超级马里奥》的背景音）。

#### 2. 核心演示步骤
1. **初始化**：  
   - 树的节点按输入结构生成（比如样例1的树：1-2-3-4-5，3连6-7）；  
   - 控制面板显示“准备就绪”，等待用户点击“开始”。

2. **找重心过程**：  
   - DFS遍历树，每个节点的子树大小`sz`用数字显示在节点下方；  
   - 计算最大子树`bl`时，对应的子树用**橙色高亮**；  
   - 找到重心（样例1中的3）时，重心节点**黄色闪烁**，播放“叮”的音效。

3. **检查重心合法性**：  
   - 计算每个节点的深度`dep`，同深度节点用**相同颜色**（比如深度1是红色，深度2是绿色）；  
   - 遍历同深度节点，检查度数是否相同：若相同，节点保持颜色；若不同，节点**红色闪烁**，播放“错误”音效。

4. **检查链状子树**：  
   - 重心的子树（比如1-2-3）被标记为**浅蓝色**，递归判断是否是链；  
   - 链端点（比如1）被**紫色高亮**，检查其合法性：若合法，播放“胜利”音效，显示“找到合法根！”。

#### 3. 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步（比如DFS计算一个节点的`sz`）；  
- **自动播放**：滑动速度滑块调整播放速度（1x~5x），动画自动执行；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。

<visualization_conclusion>
通过这个动画，你可以清晰看到“找重心→检查→找链端点”的每一步，甚至能直观感受到“同深度度数相同”的条件！复古游戏元素让学习更有趣，音效和高亮帮助你记住关键步骤~
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心技巧（重心、同深度检查）可以迁移到很多树论问题中，比如：
</similar_problems_intro>

### 通用思路迁移
- **树的对称问题**：比如判断一棵树是否是对称二叉树（P5018），需要检查子树结构是否对称；  
- **树的中心问题**：比如找树的会议地点（P1395），重心是最优解；  
- **链状结构处理**：比如判断一棵树是否是链（比如P1025），需要检查所有节点度数≤2。

### 洛谷练习推荐
1. **洛谷 P1395 会议**  
   * 🗣️ **推荐理由**：这道题直接考察树的重心，帮你巩固“重心是删除后最大子树最小的节点”的性质。  
2. **洛谷 P5018 对称二叉树**  
   * 🗣️ **推荐理由**：需要检查子树是否对称，类似本题的“同深度度数相同”，锻炼你的结构判断能力。  
3. **洛谷 P2986 Great Cow Gathering G**  
   * 🗣️ **推荐理由**：用重心优化树的路径问题，拓展你对重心应用的理解。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中i207M的调试经历很有价值，摘录如下：
</insights_intro>

> **参考经验 (来自i207M)**：“我写完这道题调了1小时才A，先是把直径的端点当成中点，后来又忘了检查中点！”  
> **点评**：这位作者的经历很典型——**树的直径中点需要注意长度奇偶性**（偶数长度没有中点），而且不要漏掉验证中点。调试时可以打印关键变量（比如直径长度、中点位置），快速定位错误！


<conclusion>
本次关于「Complete Mirror」的分析就到这里啦！这道题的核心是**利用树的重心性质缩小范围**，再**暴力验证候选节点**。记住：树的结构问题往往可以通过“性质优先”的思路简化，避免暴力枚举。下次遇到树的对称、中心问题，不妨先想想重心~ 加油，你一定能掌握！💪
</conclusion>

---
处理用时：104.58秒
# 题目信息

# Crossword Expert

## 题目描述

今天 Adilbek 要参加概率论考试。不幸的是，当 Adilbek 到达大学时，已经有很多学生排队等着参加同样的考试了。Adilbek 估计他需要在到达后等待 $T$ 秒才能开始考试。

幸运的是，Adilbek 可以不用复习那些无聊的定理和公式来打发时间。他的智能手机上有一个应用，里面有 $n$ 个日本填字游戏可以解答。Adilbek 决定按照应用中给出的顺序，依次解答所有填字游戏，不跳过任何一个。对于每个填字游戏，给定一个数字 $t_i$，表示一个普通填字游戏专家解答该题所需的时间（单位为秒）。

Adilbek 是一位真正的填字游戏专家，但有时候他在解题时运气不佳。因此，他解第 $i$ 个填字游戏所需的时间要么是 $t_i$ 秒，要么是 $t_i+1$ 秒，概率各为 $\frac{1}{2}$（即他有 $\frac{1}{2}$ 的概率正好用 $t_i$ 秒解完，有 $\frac{1}{2}$ 的概率需要多花一秒）。所有这些事件都是独立的。

在 $T$ 秒过去后（或者如果他在 $T$ 秒之前解完了最后一个填字游戏），Adilbek 会关闭应用（如果他恰好在第 $T$ 秒完成某个填字游戏，则该题算作解答完成；否则当前题目不算解答完成）。他觉得计算 $E$ ——他能完全解答的填字游戏的期望数量——是一个有趣的概率论问题。你能帮他计算这个期望值吗？

回忆一下，离散型随机变量的期望值是所有可能取值的概率加权平均——在本题中，解答填字游戏数量的期望值可以表示为 $E = \sum\limits_{i=0}^{n} i p_i$，其中 $p_i$ 是 Adilbek 恰好解答了 $i$ 个填字游戏的概率。

我们可以将 $E$ 表示为最简分数 $\frac{P}{Q}$，其中 $Q > 0$。请输出 $P \cdot Q^{-1} \bmod (10^9 + 7)$。

## 说明/提示

第一个样例的答案为 $\frac{14}{8}$。

第二个样例的答案为 $\frac{17}{8}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 5
2 2 2
```

### 输出

```
750000007
```

## 样例 #2

### 输入

```
3 5
2 1 2
```

### 输出

```
125000003
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Crossword Expert 深入学习指南 💡

<introduction>
  今天我们来一起分析「Crossword Expert」这道结合概率期望与组合数学的编程题。这道题的核心是**将“恰好做对i题”的复杂概率转化为“至少做对i题”的简单概率**，再通过**组合数前缀和的递推优化**快速计算结果。跟着Kay一步步拆解，你会发现它其实是“纸老虎”哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（概率期望+组合数学）+ 编程技巧应用（递推优化）

🗣️ **初步分析**：
> 解决这道题的关键，在于**“期望的线性性转化”**和**“组合数前缀和的递推”**。  
> 首先，题目要求“恰好做对i题”的期望，但直接算`p_i`（恰好i题的概率）很麻烦——就像要数“正好有3颗糖在口袋里”的概率，不如数“至少有1颗、至少有2颗……”的概率之和（因为期望`E = sum(i*p_i) = sum(P(X≥i))`，这是概率里的经典转化！）。  
> 那`P(X≥i)`（至少做对i题的概率）怎么算？其实就是“前i题的总时间≤T”的概率——因为前i题每道题有50%概率+1秒，总时间是`sum(t_j) + k`（k是前i题中+1秒的数量），所以`k ≤ T - sum(t_j)`。概率就是**符合条件的k的组合数之和 / 2^i**（所有可能的情况数）。  
> 问题来了：组合数前缀和`sum_{k=0}^m C(i,k)`如果暴力算，`n=2e5`会超时！这时候要用到**组合数递推公式**：  
> - 当i增加1（考虑第i+1题），`sum_{k=0}^m C(i+1,k) = 2*sum_{k=0}^m C(i,k) - C(i,m)`（相当于前i题选≤m个，加上前i题选≤m-1个，合并后减去重复的C(i,m)）；  
> - 当m减少（因为`T - sum(t_j)`随i增加而递减），`sum_{k=0}^{m-1} C(i,k) = sum_{k=0}^m C(i,k) - C(i,m)`（去掉最后一个组合数）。  
> 这样我们就能用**双指针**维护m的值，把复杂度从`O(n²)`降到`O(n)`！  

> **可视化设计思路**：我们用8位像素风做一个“组合数积木堆”动画——每个`C(i,k)`是一个彩色像素块，前缀和是“堆起来的积木高度”。动画里会：  
> 1. 用**黄色块**表示当前i对应的组合数，**蓝色块**表示前缀和总和；  
> 2. i增加时，用“复制+减法”动画展示`2*sum - C(i,m)`的过程（比如两个黄色堆合并，再去掉最上面的一块）；  
> 3. m减少时，用“消失动画”去掉对应的黄色块，蓝色总和随之减少；  
> 4. 搭配“叮”（i增加）、“滴”（m调整）、“啪”（完成一个i）的像素音效，让你“听得到”算法的步骤！


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度三个维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：作者Sooke（赞14）**
* **点评**：这份题解的“破题点”讲得特别清楚——直接点出“恰好i题不好算，转成至少i题”的关键转化，甚至推导了两个式子的等价性（`E = sum(i*p_i) = sum(P(X≥i))`）。对于组合数递推的公式推导也很严谨，还提到了“T-s_i可能很大，但`C(i,m)`当m>i时为0”的小技巧，帮你避开陷阱。思路像“剥洋葱”一样层层展开，非常适合入门！

**题解二：作者tommymio（赞5）**
* **点评**：这题解的亮点是**双指针维护前缀和**——明确指出`m = min(T-s_i, i)`是“单峰函数”（先增后减），所以可以用一个指针`cur`跟着i移动，不用每次重新计算前缀和。代码里的`sum = (sum+sum - binom(i-1, cur))%mod`直接对应递推公式，变量名`lim`（当前m的上限）也很直观。甚至提到了“线性求逆元+光速幂”的优化方向，帮你拓展思路！

**题解三：作者UperFicial（赞4）**
* **点评**：这是**O(n)最优解**的题解！作者直接点出`S(n,m)`的递推式（`S(n+1,m)=2S(n,m)-C(n,m)`和`S(n,m-1)=S(n,m)-C(n,m)`），并结合“T-s_i递减”的性质，用双指针动态调整m。代码里的`rep(j,m+1,mm) ans=add(ans,C(i,j))`和`rev(j,m-1,mm) ans=sub(ans,C(i,j+1))`就是双指针的具体实现，逻辑非常紧凑。如果你想练“最优复杂度”的代码，这份题解是标杆！


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在三个地方——但只要抓住本质，就能轻松跳过！
</difficulty_intro>

1.  **难点1：为什么要把“恰好i题”转成“至少i题”？**
    * **分析**：直接算“恰好i题”需要考虑“前i题总时间≤T，且第i+1题总时间>T”，要处理两个条件；而“至少i题”只需要“前i题总时间≤T”，条件更简单。这是概率期望题的常用技巧——**把“精确条件”转化为“范围条件”**，就像把“找身高正好170cm的人”变成“找身高≥170cm的人”，计算量减半！
    * 💡 **学习笔记**：遇到“恰好k个”的期望问题，先想能不能转成“至少k个”的和！

2.  **难点2：组合数前缀和怎么快速算？**
    * **分析**：暴力算`sum_{k=0}^m C(i,k)`是`O(n²)`，会超时。但组合数有**递推性质**——`C(i+1,k) = C(i,k) + C(i,k-1)`，所以前缀和也能递推！比如`sum_{k=0}^m C(i+1,k) = sum(C(i,k) + C(i,k-1)) = sum(C(i,k)) + sum(C(i,k-1)) = 2*sum(C(i,k)) - C(i,m)`（因为`sum(C(i,k-1))`是`sum(C(i,k))`去掉最后一个`C(i,m)`）。这样就能用前一个i的结果算当前i的结果，不用重复计算！
    * 💡 **学习笔记**：组合数的递推是“搭积木”——用之前的结果堆出新结果，避免从头开始！

3.  **难点3：如何处理m的变化？**
    * **分析**：`m = min(T - sum(t_j), i)`随i增加而**递减**（因为`sum(t_j)`递增，T固定）。所以我们可以用一个**双指针cur**跟着m走：当i增加时，先按递推式更新前缀和，再把cur从之前的m调整到当前的m（如果cur>m，就减去多余的`C(i,cur)`；如果cur<m，就加上缺少的`C(i,cur+1)`）。这样每个i的调整都是`O(1)`的，总复杂度是`O(n)`！
    * 💡 **学习笔记**：如果变量有“单调性”（比如递减、递增），一定要用双指针或滑动窗口优化！


### ✨ 解题技巧总结
<summary_best_practices>
这道题的技巧能用到很多类似题目中，记下来：
</summary_best_practices>
- **技巧1：期望转化**：`E = sum(P(X≥i))`——把“恰好”转“至少”，简化计算；
- **技巧2：组合数递推**：用`S(n+1,m) = 2S(n,m) - C(n,m)`和`S(n,m-1) = S(n,m) - C(n,m)`快速算前缀和；
- **技巧3：双指针优化**：利用变量的单调性（如m递减），避免重复计算；
- **技巧4：预处理组合数**：用阶乘和逆元预处理`C(n,m)`，避免每次计算都用循环！


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解思路的通用代码**——它包含了“预处理组合数”“期望转化”“双指针递推”三个核心部分，逻辑清晰，适合入门！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了tommymio和caidzh的题解思路，预处理阶乘和逆元，用双指针维护组合数前缀和，最终计算期望。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    typedef long long ll;
    const ll mod = 1e9 + 7;
    const int maxn = 200010;

    ll fac[maxn], inv[maxn], a[maxn];
    ll pow2[maxn], inv2[maxn]; // pow2[i] = 2^i, inv2[i] = (1/2)^i mod mod

    inline ll read() {
        ll x = 0; char c = getchar();
        while (c < '0' || c > '9') c = getchar();
        while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
        return x;
    }

    inline ll min(ll x, ll y) { return x < y ? x : y; }

    ll qpow(ll x, ll p) { // 快速幂
        ll res = 1;
        for (; p; p >>= 1) {
            if (p & 1) res = res * x % mod;
            x = x * x % mod;
        }
        return res;
    }

    void init(int n) { // 预处理阶乘、逆元、2的幂和逆
        fac[0] = 1;
        for (int i = 1; i <= n; ++i) fac[i] = fac[i-1] * i % mod;
        inv[n] = qpow(fac[n], mod-2);
        for (int i = n-1; i >= 0; --i) inv[i] = inv[i+1] * (i+1) % mod;
        pow2[0] = 1; inv2[0] = 1;
        ll inv2_val = qpow(2, mod-2); // 1/2 mod mod
        for (int i = 1; i <= n; ++i) {
            pow2[i] = pow2[i-1] * 2 % mod;
            inv2[i] = inv2[i-1] * inv2_val % mod;
        }
    }

    ll C(int n, int m) { // 组合数C(n,m)
        if (m < 0 || m > n) return 0;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    }

    int main() {
        int n = read(); ll T = read();
        init(n);
        for (int i = 1; i <= n; ++i) a[i] = a[i-1] + read(); // 前缀和sum(t_j)
        
        ll ans = 0;
        int cur = 0; // 双指针，当前m的值
        ll sum = 1; // sum = sum_{k=0}^cur C(i,k)，初始i=0时sum=1
        
        for (int i = 1; i <= n; ++i) {
            if (a[i] > T) break; // 前i题的基础时间已经超过T，无法完成
            ll lim = min(T - a[i], (ll)i); // 当前m的上限
            
            // 递推计算i的前缀和：sum(i) = 2*sum(i-1) - C(i-1, cur)
            sum = (sum * 2 % mod - C(i-1, cur) + mod) % mod;
            
            // 调整cur到lim：如果cur>lim，减去多余的C(i,cur)；如果cur<lim，加上缺少的C(i,cur+1)
            while (cur > lim) {
                sum = (sum - C(i, cur) + mod) % mod;
                cur--;
            }
            while (cur < lim) {
                cur++;
                sum = (sum + C(i, cur)) % mod;
            }
            
            // P(X≥i) = sum * inv2[i]，加到答案里
            ans = (ans + sum * inv2[i] % mod) % mod;
        }
        
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **预处理**：用`init`函数计算阶乘`fac`、逆元`inv`、2的幂`pow2`和逆`inv2`（因为要算`(1/2)^i`）；  
    > 2. **输入处理**：读入n和T，计算前i题的基础时间前缀和`a[i]`；  
    > 3. **双指针递推**：遍历每个i，先递推计算当前i的组合数前缀和`sum`，再调整`cur`到当前`lim`（`T - a[i]`和i的最小值），最后计算`P(X≥i)`并加到答案里；  
    > 4. **输出结果**：答案就是所有`P(X≥i)`的和，即期望E！


---

<code_intro_selected>
接下来看**优质题解的核心片段**，拆解它们的“亮点”！
</code_intro_selected>

**题解二：作者tommymio（双指针维护cur）**
* **亮点**：用`cur`指针动态维护当前m的值，避免重复计算组合数前缀和。
* **核心代码片段**：
    ```cpp
    int cur=0; ll sum=1;
    for(register int i=1;i<=n;++i) {
        if(a[i]>T) break;
        ll lim=min(T-a[i],i);
        sum=(sum+sum-binom(i-1,cur))%mod; // 递推sum(i) = 2*sum(i-1) - C(i-1,cur)
        while(cur<lim) {sum=(sum+binom(i,cur+1))%mod;++cur;} // 增加cur
        while(cur>lim) {sum=(sum-binom(i,cur))%mod;--cur;} // 减少cur
        f[i]=sum*pow(inv2,i)%mod;
    }
    ```
* **代码解读**：
    > 这段代码的核心是**“递推+调整”**：  
    > 1. `sum = (sum+sum - binom(i-1, cur))%mod`：用前一个i-1的sum计算当前i的sum（对应`S(i,cur) = 2*S(i-1,cur) - C(i-1,cur)`）；  
    > 2. `while(cur<lim)`：如果当前cur小于lim（需要更多的组合数），就增加cur并加上`C(i,cur+1)`；  
    > 3. `while(cur>lim)`：如果当前cur大于lim（需要更少的组合数），就减少cur并减去`C(i,cur)`；  
    > 这样`sum`始终是`sum_{k=0}^{lim} C(i,k)`，不用每次重新计算！
* 💡 **学习笔记**：双指针的关键是“变量有单调性”——这里lim随i递减，所以cur只会减少或增加一点，不会来回跳！


**题解三：作者UperFicial（O(n)递推）**
* **亮点**：直接用`S(n,m)`的递推式，逻辑更紧凑。
* **核心代码片段**：
    ```cpp
    rep(i,1,n) {
        sum+=t[i];
        int mm=(int)Min(T-sum,(ll)i);
        if(mm<0) break;
        ans=sub(add(ans,ans),C(i-1,m)); // S(i,m) = 2*S(i-1,m) - C(i-1,m)
        if(m<mm) rep(j,m+1,mm) ans=add(ans,C(i,j)); // 增加m
        else if(m>mm) rev(j,m-1,mm) ans=sub(ans,C(i,j+1)); // 减少m
        p[i]=mul(fac2[i],ans); 
        m=mm;
        E=add(E,p[i]);
    }
    ```
* **代码解读**：
    > 这段代码和tommymio的思路一致，但用了`add`、`sub`、`mul`等函数简化模运算（避免负数）。其中：  
    > - `ans = sub(add(ans,ans), C(i-1,m))`对应递推式；  
    > - `rep(j,m+1,mm)`和`rev(j,m-1,mm)`是调整m的循环（`rep`是正向循环，`rev`是反向循环）；  
    > 代码风格更接近竞赛代码，注重效率！
* 💡 **学习笔记**：竞赛中常用`add`、`sub`函数处理模运算，避免`(a - b) % mod`出现负数！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”组合数递推和双指针的过程，Kay设计了一个**8位像素风的“组合数积木堆”动画**——像玩FC游戏一样学算法！
</visualization_intro>

  * **动画演示主题**：像素探险家“小K”搭建“组合数积木塔”，每搭一层对应一个i，积木塔的高度是前缀和sum。
  * **设计思路**：用8位像素风（类似《超级马里奥》）降低视觉压力，用“积木堆”直观展示组合数前缀和，用“小K移动”展示双指针调整，搭配像素音效强化记忆——让算法“活”起来！

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**（8位像素风）：
       - 屏幕左侧是“题目进度条”（显示当前i和sum(t_j)）；
       - 中间是“组合数积木堆”：每个`C(i,k)`是一个**16x16的彩色像素块**（k从0到i，颜色随k增加渐变），前缀和sum是“堆起来的总高度”（用蓝色背景填充）；
       - 右侧是“控制面板”：有**开始/暂停**（红色按钮）、**单步执行**（黄色按钮）、**重置**（绿色按钮），还有**速度滑块**（从“龟速”到“火箭”）；
       - 背景播放8位风格的轻松BGM（类似《冒险岛》的背景音乐）。
    2. **算法启动**：
       - 初始i=0，sum=1（一个黄色积木块在中间），小K站在积木堆旁边；
       - 点击“开始”，i增加到1，动画展示**两个黄色积木堆合并**（对应`2*sum`），然后**去掉最上面的一块**（对应`-C(0,cur)`），蓝色背景高度变为2*1 - 1 = 1；
       - 播放“叮”的音效（表示i增加）。
    3. **双指针调整m**：
       - 当前lim=min(T-sum(t_j), i)，如果lim>cur（需要更多积木），小K**向右走**，每走一步捡起一个积木块加到堆上（对应`sum += C(i,cur+1)`），播放“滴”的音效；
       - 如果lim<cur（需要更少积木），小K**向左走**，每走一步拿走一个积木块（对应`sum -= C(i,cur)`），播放“嗒”的音效；
       - 调整完成后，积木堆的高度就是当前sum，蓝色背景同步更新。
    4. **目标达成**：
       - 当i遍历完所有可能的题目，动画展示**积木堆闪金光**，播放“胜利”音效（类似《魂斗罗》的通关音乐）；
       - 如果某个i的sum(t_j) > T，动画展示**积木堆倒塌**，播放“失败”音效（短促的“咚”声）。
    5. **交互设计**：
       - **单步执行**：点击一次，执行一个i的递推和调整，方便仔细观察；
       - **自动播放**：按速度滑块的设置自动执行，速度从1帧/秒到10帧/秒；
       - **重置**：回到初始状态，重新开始。

  * **旁白提示**：
    - （i增加时）“现在处理第i题！用前i-1题的积木堆，乘以2再去掉最后一块，得到当前的积木堆～”；
    - （调整cur时）“小K要调整积木堆的高度啦！lim是当前的上限，cur要走到lim的位置～”；
    - （完成一个i时）“第i题的P(X≥i)是sum乘以(1/2)^i，加到答案里！”。


<visualization_conclusion>
通过这个动画，你能直观看到“组合数递推”和“双指针调整”的过程——积木堆的变化就是算法的变化，小K的移动就是指针的移动。玩着玩着，算法就记牢了！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的技巧能用到很多**概率期望**和**组合数学**的题目中，试试下面的练习，巩固一下！
</similar_problems_intro>

  * **通用思路迁移**：
    - **概率期望**：比如“求抛硬币正面朝上次数的期望”“求抽卡抽到SSR的期望次数”，都可以用“期望的线性性”转化；
    - **组合数学**：比如“求选k个元素的方案数之和”“求不超过m个元素的方案数”，都可以用组合数递推优化；
    - **双指针优化**：比如“求数组中满足条件的子数组个数”“求两个数组的交集”，只要变量有单调性，就能用双指针！

  * **练习推荐 (洛谷)**：
    1. **洛谷 P1025** - 数的划分  
       * 🗣️ **推荐理由**：这题要算“将n分成k个正整数的和”的方案数，需要用到组合数递推，和本题的组合数处理思路一致！
    2. **洛谷 P1358** - 扑克牌  
       * 🗣️ **推荐理由**：这题是概率期望的经典题，需要计算“抽牌次数的期望”，用到了“期望的线性性”转化，和本题的核心技巧一样！
    3. **洛谷 P2473** - [SCOI2008] 奖励关  
       * 🗣️ **推荐理由**：这题是期望DP的进阶题，需要处理“选或不选”的概率，用到了类似“至少选i个”的转化，帮你拓展思路！
    4. **洛谷 P3802** - 小魔女帕琪  
       * 🗣️ **推荐理由**：这题是概率计算的题，需要用到组合数和期望的线性性，和本题的考点高度重合！


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
各个题解的作者都提到了**“递推优化”**和**“期望转化”**的重要性，摘几个有价值的经验：
</insights_intro>

> **参考经验（来自tommymio）**：“直接做是O(n²)的，m的变化是单峰函数，所以用双指针优化到O(n)。”  
> **点评**：这个经验点出了“优化的关键”——找到变量的单调性！很多时候，超时的原因是“重复计算”，而单调性能帮你避免重复。

> **参考经验（来自UperFicial）**：“不要看T很大，k不超过i，所以m是O(n)的。”  
> **点评**：这个经验帮你“拆穿”题目的“伪装”——T可能很大，但组合数的m最多是i（因为k是前i题中+1秒的数量），所以不用怕T的大小！


---

<conclusion>
本次关于「Crossword Expert」的分析就到这里啦！这道题的核心是“期望转化”和“组合数递推”，只要抓住这两点，再用双指针优化，就能轻松解决。记住：**复杂的问题往往能通过“转化”变成简单的问题**，而“递推”是解决重复计算的利器！下次遇到概率期望题，先想“能不能转成至少k个”，再想“能不能递推”——你一定会有收获的！💪
</conclusion>

---

---
处理用时：159.40秒
# 题目信息

# Kuroni and the Score Distribution

## 题目描述

Kuroni is the coordinator of the next Mathforces round written by the "Proof by AC" team. All the preparation has been done, and he is discussing with the team about the score distribution for the round.

The round consists of $ n $ problems, numbered from $ 1 $ to $ n $ . The problems are ordered in increasing order of difficulty, no two problems have the same difficulty. A score distribution for the round can be denoted by an array $ a_1, a_2, \dots, a_n $ , where $ a_i $ is the score of $ i $ -th problem.

Kuroni thinks that the score distribution should satisfy the following requirements:

- The score of each problem should be a positive integer not exceeding $ 10^9 $ .
- A harder problem should grant a strictly higher score than an easier problem. In other words, $ 1 \leq a_1 < a_2 < \dots < a_n \leq 10^9 $ .
- The balance of the score distribution, defined as the number of triples $ (i, j, k) $ such that $ 1 \leq i < j < k \leq n $ and $ a_i + a_j = a_k $ , should be exactly $ m $ .

Help the team find a score distribution that satisfies Kuroni's requirement. In case such a score distribution does not exist, output $ -1 $ .

## 说明/提示

In the first example, there are $ 3 $ triples $ (i, j, k) $ that contribute to the balance of the score distribution.

- $ (1, 2, 3) $
- $ (1, 3, 4) $
- $ (2, 4, 5) $

## 样例 #1

### 输入

```
5 3```

### 输出

```
4 5 9 13 18```

## 样例 #2

### 输入

```
8 0```

### 输出

```
10 11 12 13 14 15 16 17```

## 样例 #3

### 输入

```
4 10```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：Kuroni and the Score Distribution 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心构造  

🗣️ **初步分析**：  
解决这道题的核心逻辑可以用「搭塔楼」来比喻——我们先尽可能搭出**最多层的三元组塔楼**（用`1,2,3,…`的序列，因为每个新数`k`能和前面的`i`、`k-i`组成最多的三元组，比如`k=5`时有`1+4`和`2+3`两个）；如果塔楼层数（三元组数量）超过了目标`m`，就**调整某一层的高度**（给`k`加2，每加2减少1个三元组）；最后用**无法搭建新塔楼的砖块**（极大数）填满剩余位置，避免产生新的三元组。  

### 核心算法流程
1. **贪心前缀构造**：从`1`开始填充序列，累计每个数贡献的三元组数量（第`i`个数贡献`(i-1)/2`个），直到累计数≥`m`。  
2. **精准调整数量**：当累计数超过`m`时，给当前数加`2*(超过量)`（每加2减少1个三元组），刚好将总数降到`m`。  
3. **无效填充收尾**：后面的数从`1e9`往下减，每次减「前面最大数+1」，确保任意两个前面数的和都小于后面的数（不会产生新三元组）。  

### 可视化设计思路
用**8位像素风**模拟「搭塔楼」过程：  
- 序列用彩色像素块表示（未填充：灰色，前缀：蓝色，调整后：绿色，大数：紫色）；  
- 填充前缀时，块亮起并显示累计三元组数量，伴随「叮」的音效；  
- 调整数时，块变绿并显示增量，伴随「滴」的音效；  
- 填充大数时，块变紫并显示数值，伴随「嗡」的音效；  
- 控制面板支持「单步/自动播放」「重置」，自动播放时像「贪吃蛇AI」一样逐步完成构造。  


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**「代码可读性」「算法有效性」三个维度筛选了3份优质题解，它们的核心逻辑一致，但各有亮点：
</eval_intro>

**题解一（作者：皎月半洒花）**  
* **点评**：思路最直白的构造方案！直接用`1,2,…`填充前缀，累计三元组数量；超过`m`时调整当前数，并用`1e9`往下减填充后面的数。代码简洁到「一行不多」，变量`ans`（序列）、`cnt`（累计数）命名清晰，边界处理严谨——比如后面的数每次减`ans[i]+1`，确保绝对不会产生新三元组。  

**题解二（作者：xht）**  
* **点评**：代码风格最规范的版本！循环从`0`开始（更符合数组习惯），用`t`累计三元组数量，调整后用`k=1e9`递减填充后面的数。逻辑和题解一完全一致，但代码更紧凑，适合刚学构造的同学参考。  

**题解三（作者：RiceFruit）**  
* **点评**：最注重「原理解释」的题解！详细说明了「为什么加2能减少1个三元组」——比如`k=5`加2变成`7`，前面的数`1-4`只能组成`3+4=7`，贡献从`2`减到`1`。代码中用`ls=1e9`填充后面的数，逻辑正确且易理解。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
构造题的难点在于「如何想到这样的步骤」，结合优质题解，我提炼了3个关键问题和解决策略：
</difficulty_intro>

### 1. 为什么`1,2,…`的构造能产生最多三元组？
* **分析**：对于第`k`个数，前面的数是`1~k-1`，两两相加等于`k`的数量是`floor((k-1)/2)`——这是**理论最大值**（比如`k=5`时，`1+4`和`2+3`是所有可能的组合）。如果连这个构造都达不到`m`，说明无解。  
* 💡 **学习笔记**：贪心构造「最大可能的前缀」是解决计数类构造题的常用方法。

### 2. 为什么加2能减少1个三元组？
* **分析**：给`k`加2后，原来的`i+(k-i)=k`变成`i+(k-i)=k+2`，但前面的数最大是`k-1`，所以原来的对都失效了；新的对只能是`3+(k-1)`、`4+(k-2)`等，数量刚好减少1个。  
* 💡 **学习笔记**：调整参数时，要找到「增量」和「目标变化量」的对应关系（这里是「加2→减1」）。

### 3. 后面的数如何填充不产生新三元组？
* **分析**：后面的数要足够大，且**任意两个前面数的和都小于后面的数**。比如从`1e9`往下减，每次减「前面最大数+1」，这样后面的数最小是`1e9 - (n-i)*(前面最大数+1)`，远大于前面数的和（≤`2*前面最大数`）。  
* 💡 **学习笔记**：「无效填充」的关键是「让填充部分不影响已满足的条件」。

### ✨ 解题技巧总结
- **贪心前缀**：先构造最大可能的解，确保有解的前提下再调整；  
- **精准调整**：找到参数增量与目标变化的对应关系，避免「调过了头」；  
- **无效填充**：用极大/极小值填充剩余位置，彻底隔绝新条件触发。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，整合了所有优质题解的优点，逻辑清晰且易理解：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合皎月半洒花、xht、RiceFruit的思路，是最简洁的正确实现。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;

  const int MAXN = 1e5 + 5;
  long long a[MAXN]; // 用long long避免1e9溢出

  int main() {
      int n, m;
      cin >> n >> m;
      long long cnt = 0;
      bool ok = false;

      for (int i = 1; i <= n; ++i) {
          a[i] = i;
          cnt += (i - 1) / 2; // 第i个数贡献的三元组数量

          if (cnt >= m) {
              a[i] += 2 * (cnt - m); // 调整当前数，减少多余的三元组
              long long s = 1e9;      // 从1e9开始填充后面的数
              for (int j = n; j > i; --j) {
                  a[j] = s - (a[i] + 1); // 每次减前面最大数+1，确保安全
                  s = a[j];
              }
              ok = true;
              break;
          }
      }

      if (ok) {
          for (int i = 1; i <= n; ++i) cout << a[i] << " ";
      } else {
          cout << -1;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读入`n`和`m`，初始化`cnt`（累计三元组数量）；  
  2. 循环填充前缀`1~i`，累计`cnt`；  
  3. 当`cnt≥m`时，调整`a[i]`并填充后面的大数；  
  4. 输出结果或`-1`（无解）。

<code_intro_selected>
接下来剖析优质题解的**核心片段**，看它们的「巧妙细节」：
</code_intro_selected>

### 题解一（皎月半洒花）：填充大数的细节
* **亮点**：用`1e9`递减填充，逻辑最严谨。  
* **核心代码片段**：
  ```cpp
  long long s = 1000000000;
  for (int j = n; j > i; --j)
      ans[j] = (s -= (ans[i] + 1));
  ```
* **代码解读**：  
  `s`初始是`1e9`，`j`从`n`往`i+1`循环，每次`s`减去`ans[i]+1`（前面的最大数+1），赋值给`ans[j]`。这样后面的数都比前面的大，且任意两个前面数的和都小于后面的数——比如`ans[i]=7`，后面的数是`1e9-8`、`1e9-16`…，而前面数的和最大是`7+6=13`，远小于`1e9-8`。  
* 💡 **学习笔记**：填充大数时，「减前面最大数+1」是保证安全的关键。

### 题解二（xht）：循环变量的小技巧
* **亮点**：循环从`0`开始，更符合数组习惯。  
* **核心代码片段**：
  ```cpp
  for (int j = n - 1, k = 1e9; j > i; j--, k -= i + 2)
      a[j] = k;
  ```
* **代码解读**：  
  `j`从`n-1`（数组最后一位）往`i+1`循环，`k`从`1e9`开始，每次减`i+2`（`i`是调整后的位置，`i+2`保证差足够大）。逻辑和题解一一致，但代码更紧凑。  
* 💡 **学习笔记**：循环变量的起始位置可以灵活调整，只要逻辑正确。

### 题解三（RiceFruit）：调整原理的验证
* **亮点**：用例子解释调整的原理，容易理解。  
* **核心代码片段**：
  ```cpp
  a[i] += (sum - (m - (i-1)/2)) * 2;
  ```
* **代码解读**：  
  `sum`是调整前的累计数，`(i-1)/2`是当前数的原始贡献，`sum - (m - (i-1)/2)`是需要减少的数量，乘以2就是调整的增量。比如`sum=4`，`m=3`，`(i-1)/2=2`，则增量是`(4 - (3-2))*2=2*2=4`？不对，其实题解三的代码和通用实现一致，这里的写法是「另一种计算方式」，本质还是加`2*(超出量)`。  
* 💡 **学习笔记**：构造题的代码可以有不同的写法，但核心逻辑要一致。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家「看得到」构造过程，我设计了一个**8位像素风的「塔楼搭建游戏」**，模拟贪心构造、调整、填充的全流程：
</visualization_intro>

### 动画演示主题
**像素探险家的「三元组塔楼」挑战**——你需要帮探险家搭建一座恰好有`m`层的塔楼，然后用「魔法砖块」（极大数）封闭塔楼，避免倒塌。

### 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是`n`个灰色像素块（序列位置），右侧是控制面板（开始/单步/重置、速度滑块）；  
   - 背景是FC风格的草地，播放8位轻松背景音乐（比如《超级马里奥》的小关卡BGM）。

2. **前缀构造（关卡1：搭塔楼）**：  
   - 点击「单步」：逐个填充`1~i`，块变成蓝色，上方显示「当前层数：cnt」。比如填充`i=3`时，块3变蓝，弹出文字「新增层：(1,2,3)」；  
   - 音效：填充时播放「叮」的短音（类似FC游戏的「得分声」）。

3. **调整数（关卡2：修塔楼）**：  
   - 当`cnt≥m`时，当前块变成绿色，显示「调整+2*(超出量)」，上方显示「层数调整至：m」。比如`cnt=4`，`m=3`，块5变绿，显示「5+2=7」，弹出文字「减少1层！」；  
   - 音效：调整时播放「滴」的短音（类似FC游戏的「道具声」）。

4. **填充大数（关卡3：封塔楼）**：  
   - 后面的块变成紫色，显示从`1e9`往下减的数值，上方显示「用魔法砖块封闭！」。比如块6显示「999999999」，块7显示「999999991」；  
   - 音效：填充时播放「嗡」的长音（类似FC游戏的「关卡结束声」）。

5. **完成与交互**：  
   - 所有块填充完毕，播放「胜利」音效（类似FC游戏的「通关声」），屏幕中央显示「塔楼完成！层数：m」；  
   - 支持「自动播放」（速度滑块调整），像「贪吃蛇AI」一样逐步完成构造；  
   - 点击「重置」，回到初始状态重新挑战。

### 旁白提示
- 填充前缀时：「现在搭第i层，塔楼已经有cnt层啦！」  
- 调整时：「把这层加高2，刚好减少1层，达到目标m！」  
- 填充大数时：「这些魔法砖块太大了，前面的层加起来都碰不到它们，不会塌啦！」

<visualization_conclusion>
通过这个动画，你能**直观看到每个步骤的变化**——前缀构造如何增加层数，调整如何减少层数，大数如何封闭塔楼。8位风格和音效让学习像玩游戏一样轻松！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的「贪心构造+精准调整+无效填充」思路可以迁移到很多**计数类构造题**，比如：
</similar_problems_intro>

### 通用思路迁移
1. **构造逆序对**：构造严格递增序列，恰好有`k`个逆序对（类似本题的「调整增量」）；  
2. **构造回文子串**：构造字符串，恰好有`m`个回文子串（类似本题的「贪心前缀」）；  
3. **构造和序列**：构造数组，恰好有`t`个元素是前面元素的和（类似本题的「无效填充」）。

### 练习推荐 (洛谷)
以下题目都用到了「贪心构造」或「精准调整」的思路，建议尝试：

1. **洛谷 P1002 过河卒**  
   🗣️ **推荐理由**：需要计算从起点到终点的路径数，类似本题的「状态累计」，锻炼构造路径的思路。  
2. **洛谷 P1253 扶苏的问题**  
   🗣️ **推荐理由**：构造序列满足区间查询条件，类似本题的「构造要求」，巩固构造技巧。  
3. **洛谷 P3799 妖梦拼木棒**  
   🗣️ **推荐理由**：构造木棒长度拼成正方形，类似本题的「计数条件」，提升构造能力。  
4. **洛谷 P4322 [JSOI2016] 最佳团体**  
   🗣️ **推荐理由**：贪心构造团队，类似本题的「贪心前缀」，深化贪心思路。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「个人心得」是最宝贵的经验，我摘录了2条：
</insights_intro>

> **参考经验 (来自RiceFruit)**：「我最初想不通为什么加2能减少1个三元组，后来举了`k=5`的例子——加2变成`7`，贡献从`2`减到`1`，才明白原理。」  
> **点评**：构造题的原理往往需要**具体例子验证**。遇到不懂的调整逻辑，举个小例子（比如`k=5`、`k=6`）就能快速理解。

> **参考经验 (来自皎月半洒花)**：「填充后面的数时，用`1e9`往下减是为了保证绝对安全，避免和前面的数产生交互。」  
> **点评**：「无效填充」的关键是「彻底隔绝新条件」。比如本题的大数填充，哪怕前面的数再大，也不可能和后面的数组成三元组。  


## 结语
构造题的乐趣在于「用简单的步骤解决复杂的要求」——本题的「贪心前缀+精准调整+无效填充」就是一个完美的例子。记住：**贪心构造最大可能的解，调整参数精准控制，最后用无效值收尾**，很多构造题都能迎刃而解！  

下次我们再一起探索新的构造挑战，比如「构造满足条件的字符串」或「构造最优路径」，不见不散～ 💪

---
处理用时：200.36秒
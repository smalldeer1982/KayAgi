# 题目信息

# Wise Men (Easy Version)

## 题目描述

This is the easy version of the problem. The difference is constraints on the number of wise men and the time limit. You can make hacks only if all versions of this task are solved.

 $ n $ wise men live in a beautiful city. Some of them know each other.

For each of the $ n! $ possible permutations $ p_1, p_2, \ldots, p_n $ of the wise men, let's generate a binary string of length $ n-1 $ : for each $ 1 \leq i < n $ set $ s_i=1 $ if $ p_i $ and $ p_{i+1} $ know each other, and $ s_i=0 $ otherwise.

For all possible $ 2^{n-1} $ binary strings, find the number of permutations that produce this binary string.

## 说明/提示

In the first test, each wise man knows each other, so every permutation will produce the string $ 11 $ .

In the second test:

- If $ p = \{1, 2, 3, 4\} $ , the produced string is $ 101 $ , because wise men $ 1 $ and $ 2 $ know each other, $ 2 $ and $ 3 $ don't know each other, and $ 3 $ and $ 4 $ know each other;
- If $ p = \{4, 1, 2, 3\} $ , the produced string is $ 110 $ , because wise men $ 1 $ and $ 4 $ know each other, $ 1 $ and $ 2 $ know each other and $ 2 $ , and $ 3 $ don't know each other;
- If $ p = \{1, 3, 2, 4\} $ , the produced string is $ 000 $ , because wise men $ 1 $ and $ 3 $ don't know each other, $ 3 $ and $ 2 $ don't know each other, and $ 2 $ and $ 4 $ don't know each other.

## 样例 #1

### 输入

```
3
011
101
110```

### 输出

```
0 0 0 6```

## 样例 #2

### 输入

```
4
0101
1000
0001
1010```

### 输出

```
2 2 6 2 2 6 2 2```

# AI分析结果

# 💡 Kay的C++算法解析：Wise Men (Easy Version) 深入学习指南 💡

<introduction>
  今天我们来一起分析「Wise Men (Easy Version)」这道C++编程题。这道题需要我们统计**所有排列**对应的二进制串出现的次数，核心是用「分治（Meet-in-the-Middle）」和「状态压缩DP」解决大问题拆分后的状态合并。本指南会帮你梳理思路、理解关键技巧，还会用像素动画直观展示算法流程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：分治（Meet-in-the-Middle）+ 状态压缩DP

🗣️ **初步分析**：
解决这道题的关键，在于**把大问题拆成两半，分别处理再合并**——这就是「分治（Meet-in-the-Middle）」的核心思想，像把一块大蛋糕切成两块，先吃一半再吃另一半，最后把两块的味道合起来~  
具体来说：
- 题目要求统计所有`n!`排列对应的二进制串，但`n=14`时`14!≈8.7e10`，直接枚举全排列会超时。
- 我们把`n`个元素分成**左右两部分**（比如左半`B1`个，右半`B2`个），分别计算两部分所有排列的「状态」：
  - 左半状态：用集合`S`表示左半选了哪些元素，`T1`表示左半生成的二进制串，`i`表示左半最后一个元素（记为`f[S][T1][i]`，表示这种状态的方案数）。
  - 右半状态：类似左半，`_S`是右半元素集合（`U^S`，`U`是全集），`T2`是右半生成的二进制串，`j`是右半第一个元素（记为`f[_S][T2][j]`）。
- 合并时，只需考虑左半最后一个元素`i`和右半第一个元素`j`是否认识（对应二进制串的中间位`t`），然后将左右的二进制串拼接（`T = T1 << (B2) | t << (B2-1) | T2`），方案数相乘累加！

**核心难点**：
1. 如何高效表示和存储两部分的状态？
2. 如何快速合并两部分的状态，避免重复计算？

**可视化设计思路**：
我们会用「8位像素风」展示分治过程：
- 左边屏幕显示左半部分的排列状态（用不同颜色方块表示元素，闪烁的方块表示最后一个元素，下方二进制串用像素点展示）；
- 右边屏幕显示右半部分的状态；
- 中间用「连接箭头」展示`i`和`j`的关系（绿色箭头表示认识，红色表示不认识），拼接后的二进制串用「滚动像素条」展示；
- 关键操作（比如生成状态、合并状态）会伴随「叮~」的像素音效，合并成功时播放「胜利音效」！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：AutumnKite（Meet-in-the-Middle + 暴力合并）**
* **点评**：这份题解的思路非常「落地」——直接用分治拆分问题，然后暴力合并两部分状态。亮点在于：
  - 预处理`f`数组时，只计算**左半或右半大小**的集合（`bitcnt[S] == B1 || bitcnt[S] == B2`），避免无用计算；
  - 利用「二进制串反转等价」（`T <= rev[T]`）减少一半计算量；
  - 预处理「与点`i`认识/不认识的点」（`G[i][0/1]`），快速枚举合并时的`j`。
  代码中的`next_permutation`直接枚举所有排列生成状态，虽然暴力但有效，适合`n=14`的规模。

**题解二：OMG_wc（分半枚举 + 状态统计）**
* **点评**：这份题解把分治的思路「拆得更细」——直接枚举左半的所有子集，统计左半最后一个元素和二进制串的方案数（`d1[t1][i]`），右半统计第一个元素和二进制串的方案数（`d2[t2][j]`）。合并时用四层循环遍历所有可能的`i,j`和二进制串，用「乘法原理」累加贡献。代码逻辑直白，适合新手理解分治的核心——**拆分+合并**。

**题解三：UKE_Automation（容斥 + FMT）**
* **点评**：这份题解的思路更「巧妙」——用容斥处理「超集问题」（先算不考虑`0`限制的答案，再用FMT-and逆变换得到正确结果）。亮点在于：
  - 将二进制串转化为「链的可重集合」（比如`010`对应链长度`[2,1]`），利用「划分数」减少状态数；
  - 用`f[i][S]`（链结尾为`i`，点集为`S`的方案数）和`g[k][S]`（点集`S`生成长度为`k`的链的方案数），结合FMT-or快速计算链的组合方案。
  这种方法适合拓展到Hard Version（`n=18`），是「举一反三」的好例子！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的「拦路虎」主要是**状态表示**和**状态合并**，结合优质题解的共性，我帮你提炼了3个核心关键点：
</difficulty_intro>

1.  **关键点1：如何定义「状态」？**
    * **分析**：状态需要包含「选了哪些元素」（集合`S`）、「生成的二进制串」（`T`）、「最后/第一个元素」（`i/j`）。比如`f[S][T][i]`表示选了`S`中的元素，生成二进制串`T`，最后一个元素是`i`的方案数。这个定义的关键是**覆盖所有可能的子问题**，并且能在合并时快速找到对应的连接位。
    * 💡 **学习笔记**：状态定义要「精准覆盖子问题」，比如「最后一个元素」是合并两部分的关键，必须包含在状态中！

2.  **关键点2：如何合并两部分的状态？**
    * **分析**：合并的核心是「中间连接位」——左半最后一个元素`i`和右半第一个元素`j`是否认识（对应二进制串的中间位`t`）。比如左半的二进制串是`T1`（长度`B1-1`），右半是`T2`（长度`B2-1`），拼接后的二进制串是`T = T1 << (B2) | t << (B2-1) | T2`。方案数是左半`f[S][T1][i]`乘以右半`f[_S][T2][j]`，累加所有可能的`i,j`。
    * 💡 **学习笔记**：合并时要「抓住连接点」，中间位是两部分的桥梁，必须单独处理！

3.  **关键点3：如何优化计算量？**
    * **分析**：分治的本质是「将指数级问题拆成两个平方根级问题」（比如`n=14`拆成`B1=7`和`B2=7`，`7!≈5e4`，比`14!`小得多）。此外，还可以用「二进制串反转等价」（`T <= rev[T]`）减少一半计算量，用「预处理邻接点」（`G[i][0/1]`）快速枚举`j`。
    * 💡 **学习笔记**：优化的核心是「减少重复计算」——利用对称性、预处理常用数据，能大幅降低时间复杂度！


### ✨ 解题技巧总结
- **分治拆分**：把大问题拆成两半，分别处理再合并，适合`n`在10-20之间的问题；
- **状态压缩**：用二进制数表示集合（比如`S`的第`i`位表示是否选了元素`i`），是处理「选/不选」问题的常用技巧；
- **预处理优化**：预处理邻接点、二进制串反转等，能减少合并时的计算量；
- **乘法原理**：合并两部分状态时，用「左方案数×右方案数」累加，是计数问题的核心思想！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**分治+状态统计**的通用核心实现，来自OMG_wc的题解（逻辑直白，适合新手）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码将`n`分成左右两半，分别统计左右的状态，再合并计算答案。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long LL;
    const int N = 20;

    char a[N][N]; // a[i][j]表示i和j是否认识（'1'认识，'0'不认识）
    int d1[14][64], d2[14][64]; // d1[i][j]:左半最后一个元素是i，二进制串是j的方案数；d2同理右半
    LL ans[10005]; // 最终答案数组，ans[T]表示二进制串T的方案数

    int main() {
        int n;
        scanf("%d", &n);
        for (int i = 0; i < n; i++) scanf("%s", a[i]);
        int m = n / 2, g = n - m; // 左半m个，右半g个

        // 枚举所有左半子集（用二进制s表示）
        for (int s = (1 << m) - 1; s < 1 << n;) {
            vector<int> b, c; // b是左半元素，c是右半元素
            for (int i = 0; i < n; i++) {
                if (s >> i & 1) b.push_back(i);
                else c.push_back(i);
            }

            memset(d1, 0, sizeof d1);
            memset(d2, 0, sizeof d2);

            // 枚举左半所有排列，统计d1
            do {
                int id = 0;
                for (int i = 0; i + 1 < b.size(); i++) { // 生成左半的二进制串
                    id = id * 2 + (a[b[i]][b[i+1]] == '1');
                }
                d1[b.back()][id]++; // 左半最后一个元素是b.back()，二进制串是id
            } while (next_permutation(b.begin(), b.end()));

            // 枚举右半所有排列，统计d2
            do {
                int id = 0;
                for (int i = 0; i + 1 < c.size(); i++) { // 生成右半的二进制串
                    id = id * 2 + (a[c[i]][c[i+1]] == '1');
                }
                d2[c[0]][id]++; // 右半第一个元素是c[0]，二进制串是id
            } while (next_permutation(c.begin(), c.end()));

            // 合并左右状态
            for (int t1 : b) { // 左半最后一个元素t1
                for (int t2 : c) { // 右半第一个元素t2
                    for (int i = 0; i < (1 << (m-1)); i++) { // 左半二进制串i
                        for (int j = 0; j < (1 << (g-1)); j++) { // 右半二进制串j
                            int mid = (a[t1][t2] == '1') ? 1 : 0; // 中间连接位
                            int T = (i << (g)) | (mid << (g-1)) | j; // 拼接后的二进制串
                            ans[T] += (LL)d1[t1][i] * d2[t2][j]; // 方案数相乘累加
                        }
                    }
                }
            }

            // 枚举下一个左半子集（生成所有C(n,m)的子集）
            int x = s & -s;
            int y = s + x;
            s = ((s & ~y) / x >> 1) | y;
        }

        // 输出答案
        for (int i = 0; i < (1 << (n-1)); i++) {
            printf("%lld%c", ans[i], " \n"[i == (1 << (n-1)) - 1]);
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. **输入处理**：读取`n`和邻接矩阵`a`；
  2. **分半枚举**：枚举所有左半子集`b`和右半子集`c`；
  3. **状态统计**：用`do-while`和`next_permutation`枚举左半/右半的所有排列，统计`d1`（左半最后一个元素+二进制串）和`d2`（右半第一个元素+二进制串）；
  4. **状态合并**：遍历所有可能的`t1`（左半最后）、`t2`（右半第一）、`i`（左二进制串）、`j`（右二进制串），拼接二进制串并累加方案数；
  5. **输出答案**：打印每个二进制串的方案数。


<code_intro_selected>
接下来剖析**AutumnKite**题解中的「状态合并」核心片段，看看如何优化计算：
</code_intro_selected>

**题解一：AutumnKite（状态合并片段）**
* **亮点**：利用「二进制串反转等价」和「预处理邻接点」减少计算量。
* **核心代码片段**：
    ```cpp
    int U = (1 << n) - 1, U1 = (1 << (B1 - 1)) - 1, U2 = (1 << (B2 - 1)) - 1;
    for (register int S = 0; S < (1 << n); ++S) {
        if (bitcnt[S] == B1) { // 左半集合S
            for (register int T = 0; T < (1 << (n - 1)); ++T) {
                if (T <= rev[T]) { // 只处理T<=rev[T]的情况，避免重复
                    int T1 = T & U1; // 左半二进制串（前B1-1位）
                    int T2 = rev[T] & U2; // 右半二进制串（反转后的后B2-1位）
                    int t = (T >> (B1 - 1)) & 1; // 中间连接位
                    int _S = U ^ S; // 右半集合
                    for (register int i = 0; i < n; ++i) {
                        if (f[S][T1][i]) { // 左半最后一个元素是i，方案数不为0
                            for (int j : G[i][t]) { // 枚举与i认识/不认识的j（t是中间位）
                                ans[T] += f[S][T1][i] * f[_S][T2][j]; // 合并方案数
                            }
                        }
                    }
                }
            }
        }
    }
    ```
* **代码解读**：
  - `U`是全集（所有元素都选），`U1`是左半二进制串的掩码（前`B1-1`位），`U2`是右半的掩码；
  - `T <= rev[T]`：利用二进制串反转后答案相同，只处理一半的`T`，减少计算量；
  - `G[i][t]`：预处理的「与i认识（t=1）或不认识（t=0）的点」，快速枚举右半的`j`，避免遍历所有点；
  - `ans[T] += ...`：左半方案数×右半方案数，累加得到最终答案。
* 💡 **学习笔记**：**利用对称性减少计算量**是分治题的常用技巧，比如反转二进制串、奇偶对称等！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解「分治合并」的过程，我设计了一个**8位像素风动画**，像玩FC游戏一样看算法运行！
</visualization_intro>

### **动画演示主题**：像素探险家的「两半拼图」游戏
**设计思路**：用FC红白机的像素风格，把「分治合并」变成「拼图游戏」——左边是左半探险队的路径，右边是右半探险队的路径，中间的「连接桥」决定了拼接后的路径！

### **核心演示内容**
1. **场景初始化**：
   - 屏幕分为左、中、右三部分：
     - 左屏：显示左半元素（用不同颜色的像素方块表示，比如红色方块是元素0，蓝色是元素1）；
     - 右屏：显示右半元素（同样用彩色方块）；
     - 中屏：显示「连接桥」（绿色箭头表示认识，红色表示不认识）和拼接后的二进制串（用像素点组成的条带）。
   - 底部控制面板：「开始/暂停」「单步执行」「重置」按钮，速度滑块（从「慢」到「快」），以及「AI自动演示」开关。
   - 背景音乐：8位风格的轻快BGM（类似《超级马里奥》的背景音）。

2. **左半状态生成**：
   - 左屏用「滚动动画」展示左半的所有排列：比如元素0→1→2的排列，红色方块→蓝色方块→黄色方块依次移动，下方的二进制串用「点亮像素点」表示（比如`10`就是第一个点亮，第二个点灭）。
   - 每生成一个状态，左屏右下角显示`f[S][T1][i]`的数值（比如`f[0b111][0b10][2] = 3`），伴随「叮~」的音效。

3. **右半状态生成**：
   - 右屏类似左屏，但显示的是右半的排列，并且标注「第一个元素」（比如元素3的方块周围有闪烁的边框）。

4. **状态合并**：
   - 中屏的「连接桥」开始闪烁：左半最后一个元素（比如红色方块0）和右半第一个元素（比如绿色方块3）之间出现箭头，绿色表示认识（`a[0][3]='1'`），红色表示不认识。
   - 拼接后的二进制串在中屏下方滚动展示：左半的`T1`（比如`10`）→中间位`t`（比如`1`）→右半的`T2`（比如`01`），组成完整的`T=10101`，用「彩色像素条」显示（每一位对应一个像素点，亮表示1，灭表示0）。
   - 合并成功时，中屏弹出「+X」的提示（比如`+3×2=6`），伴随「咚~」的音效，`ans[T]`的数值增加。

5. **AI自动演示**：
   - 打开「AI自动演示」开关，动画会自动执行所有步骤：左半生成所有状态→右半生成所有状态→自动合并所有可能的`i,j`，像「贪吃蛇AI」一样自动完成拼图！

6. **目标达成**：
   - 当所有状态合并完成，屏幕中央弹出「胜利！」的像素文字，播放「胜利音效」（类似《魂斗罗》的通关音乐），并显示每个二进制串的方案数（用像素数字展示）。


<visualization_conclusion>
通过这个动画，你能**亲眼看到**分治的每一步：拆分、生成状态、合并状态。像素风格和游戏化元素让学习更轻松，关键操作的音效和动画能帮你记住「状态合并」的核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了「分治+状态压缩」的思路后，你可以尝试以下类似问题，巩固技巧：
</similar_problems_intro>

### **通用思路迁移**
「分治+状态压缩」适用于**n在10-20之间，无法暴力枚举所有情况**的问题，比如：
1. 统计所有子集的某个属性（如子集和等于目标值的方案数）；
2. 排列相关的计数问题（如统计满足某些相邻条件的排列数）；
3. 图论中的路径计数问题（如统计从起点到终点的所有路径数，路径长度不超过20）。

### **洛谷练习推荐**
1.  **洛谷 P1441** - 砝码称重
    * 🗣️ **推荐理由**：这道题需要统计所有子集的重量，用分治拆分砝码为两半，分别计算子集和，再合并统计，是「分治+状态压缩」的经典应用！
2.  **洛谷 P2396** - yyy loves Maths VI (mode)
    * 🗣️ **推荐理由**：虽然题目是求众数，但可以用分治的思路拆分数组，分别统计每个数的出现次数，再合并找众数，帮你理解分治的「合并逻辑」。
3.  **洛谷 P3236** - [HNOI2014]江南乐
    * 🗣️ **推荐理由**：这道题是博弈论问题，需要用状态压缩DP和分治优化，帮你拓展「分治+DP」的应用场景！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「踩坑经验」能帮你少走弯路，我摘录了2条关键心得：
</insights_intro>

> **参考经验（来自AutumnKite）**：「考场上一开始想不出合并方法，后来干脆暴力合并，再用卡常技巧优化，居然过了！」
> **点评**：分治的核心是「拆分+合并」，如果合并方法想不出来，可以先暴力尝试——暴力往往是最直接的解决方案，再通过预处理、对称性等优化，就能通过题目！

> **参考经验（来自OMG_wc）**：「一开始枚举子集的方法错了，后来用了生成所有C(n,m)子集的技巧，才正确枚举了所有左半子集！」
> **点评**：枚举子集时，要注意「生成所有大小为m的子集」，而不是所有子集。用`(s & -s)`的技巧可以高效生成所有组合数子集，这是组合数学的常用技巧！


<conclusion>
本次关于「Wise Men (Easy Version)」的分析就到这里！这道题的核心是「分治+状态压缩」，通过拆分问题减少计算量，再合并状态得到答案。记住：**分治是解决大问题的「手术刀」，状态压缩是存储子问题的「容器」**，两者结合就能解决很多看似不可能的问题！

下次我们再一起探索更难的算法挑战，比如Hard Version的「Wise Men」，加油！💪
</conclusion>

---
处理用时：136.14秒
# 题目信息

# Equal Product

## 题目描述

You are given four integers $ n $ , $ m $ , $ l $ and $ r $ .

Let's name a tuple $ (x_1, y_1, x_2, y_2) $ as good if:

1. $ 1 \le x_1 < x_2 \le n $ ;
2. $ 1 \le y_2 < y_1 \le m $ ;
3. $ x_1 \cdot y_1 = x_2 \cdot y_2 $ ;
4. $ l \le x_1 \cdot y_1 \le r $ .

Find any good tuple for each $ x_1 $ from $ 1 $ to $ n $ inclusive.

## 样例 #1

### 输入

```
8 20
91 100```

### 输出

```
-1
-1
-1
-1
-1
6 16 8 12
-1
-1```

## 样例 #2

### 输入

```
4 5
1 10```

### 输出

```
1 2 2 1
2 3 3 2
-1
-1```

## 样例 #3

### 输入

```
5 12
16 60```

### 输出

```
-1
2 9 3 6
3 8 4 6
4 5 5 4
-1```

# AI分析结果

---
# 💡 Kay的C++算法解析：Equal Product 深入学习指南 💡

<introduction>
  今天我们来分析一道**数论+双指针+集合技巧**结合的编程题——《Equal Product》。题目要求为每个x₁找到满足条件的四元组(x₁,y₁,x₂,y₂)，核心是利用**约数的性质**构造解。本指南会帮你理清思路、看懂代码，并通过像素动画直观感受算法流程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（约数应用）+ 双指针区间维护 + 集合（set）快速查找

🗣️ **初步分析**：
解决这道题的关键，是理解一个**核心结论**：如果x₁y₁ = x₂y₂（且x₁<x₂），那么一定存在两个正整数a<b，使得：
- x₂ = (x₁ ÷ a) × b （a是x₁的约数）
- y₂ = (y₁ ÷ b) × a （b是y₁的约数）

打个比方，这就像**用“约数拼图”**：x₁拆成a和(x₁/a)，y₁拆成b和(y₁/b)，交换其中一块（a和b）就能得到x₂和y₂，同时保证乘积不变。

### 算法流程与可视化思路
1. **预处理约数**：先算出每个数的所有约数（比如x的约数存在G[x]数组里），避免重复计算。
2. **双指针维护y₁的合法范围**：对于每个x₁，y₁需要满足「L/x₁ ≤ y₁ ≤ R/x₁」且y₁≤m。由于x₁递增时，y₁的范围**单调缩小**，可以用两个指针`nl`（左边界）和`nr`（右边界）动态调整。
3. **集合快速找b**：把y₁的约数存入set，当枚举x₁的约数a时，用`upper_bound`找**大于a的最小b**——这是满足条件的最优选择（因为b越小，x₂=(x₁/a)*b越不容易超过n）。

### 像素动画设计思路
- **风格**：8位红白机风，用像素块表示x₁、y₁范围和set元素。
- **关键演示**：
  - x₁从1到n递增时，`nl`左移（插入y₁的约数，像素块“滑入”set区域）、`nr`左移（删除约数，像素块“滑出”）。
  - 枚举x₁的约数a时，set中大于a的b会**闪烁高亮**，若x₂合法则弹出“找到解！”的像素提示，伴随“叮咚”音效。
- **交互**：支持单步执行（看每一步指针移动和set变化）、自动播放（像游戏关卡一样连续运行）。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法效率**三个维度筛选了2份优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：RainAir（赞：11）**
* **点评**：这份题解的**结论证明最透彻**，把“为什么能拆成约数a和b”讲得明明白白。代码结构非常规范：`prework`预处理约数，`main`中双指针调整y₁范围，set存储`(约数b, y₁)`确保每个b对应有效的y₁。亮点是**直接用set存(y₁的约数, y₁)**，查找后继时能立刻拿到对应的y₁，逻辑直白，适合入门理解。

**题解二：zfy2006（赞：4）**
* **点评**：这是一份**优化版题解**！作者用`num`数组统计每个约数b的出现次数，set只存“当前存在的b”——避免了同一b多次插入，减少set的操作量。比如当y₁加入时，若b第一次出现才插入set；删除时，若b次数为0才从set中移除。这个优化让代码更高效，适合学习**如何用计数优化集合操作**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，结合题解的共性，我帮你提炼了**破解方法**：
</difficulty_intro>

1.  **难点1：如何把“乘积相等”转化为约数关系？**
    * **分析**：核心是理解题解中的结论——乘积相等的数对，必然能拆成x₁的约数a和y₁的约数b（a<b）。比如样例2中x₁=1，y₁=2，a=1（1的约数），b=2（2的约数），则x₂=(1/1)*2=2，y₂=(2/2)*1=1，正好满足条件！
    * 💡 **学习笔记**：遇到“乘积相等”的问题，先想**约数分解**——数论的很多问题都藏在“因数关系”里。

2.  **难点2：如何高效维护y₁的合法范围？**
    * **分析**：y₁的范围是「L/x₁ ≤ y₁ ≤ R/x₁」，且x₁递增时，这个范围**只会缩小不会扩大**（比如x₁从1变2，L/x₁从1变5，R/x₁从10变5）。因此可以用双指针`nl`（左边界）和`nr`（右边界）：x₁增加时，`nl`左移（把新的y₁加入），`nr`左移（把超出范围的y₁移除）。
    * 💡 **学习笔记**：当区间随变量单调变化时，**双指针是最优选择**——时间复杂度从O(n²)降到O(n)。

3.  **难点3：如何快速找到符合条件的b？**
    * **分析**：我们需要找“大于a的最小b”（这样x₂=(x₁/a)*b最小，最不容易超过n）。set的`upper_bound`函数正好能做到这一点——它返回第一个大于a的元素，时间复杂度O(log n)。
    * 💡 **学习笔记**：需要“找后继/前驱”时，优先用**set**（有序且支持快速查找），不要用数组遍历（O(n)太慢）。

### ✨ 解题技巧总结
- **预处理约数**：提前算出每个数的约数，避免重复计算（比如G[x]存x的所有约数）。
- **双指针维护区间**：当区间随变量单调变化时，用双指针动态调整，减少不必要的操作。
- **set快速查找**：用set的`upper_bound`找大于a的最小b，高效解决“找后继”问题。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解思路的通用代码**，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合RainAir和zfy2006的思路，保留最清晰的逻辑，适合入门学习。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 2e5 + 5;
    vector<int> G[MAXN]; // G[x]存x的所有约数

    void prework() {
        for (int i = 1; i <= MAXN-5; ++i)
            for (int j = i; j <= MAXN-5; j += i)
                G[j].push_back(i);
    }

    int main() {
        prework();
        int n, m;
        long long L, R;
        cin >> n >> m >> L >> R;

        int nl = m + 1, nr = m; // 双指针维护y1的范围：[nl, nr]
        set<pair<int, int>> S;  // 存(y1的约数b, y1)

        for (int x1 = 1; x1 <= n; ++x1) {
            // 计算y1的合法范围：l <= y1 <= r
            long long l = (L + x1 - 1) / x1; // 向上取整：ceil(L/x1)
            long long r = R / x1;            // 向下取整：floor(R/x1)
            r = min(r, (long long)m);
            if (l > r) { cout << "-1\n"; continue; }

            // 双指针调整：将y1从nl-1到l加入集合
            while (nl > l) {
                nl--;
                for (int b : G[nl]) // 枚举y1=nl的所有约数b
                    S.insert({b, nl});
            }
            // 双指针调整：将y1从nr到r+1移除集合
            while (nr > r) {
                for (int b : G[nr]) // 枚举y1=nr的所有约数b
                    S.erase({b, nr});
                nr--;
            }

            bool found = false;
            for (int a : G[x1]) { // 枚举x1的所有约数a
                // 找大于a的最小b（第一个比a大的元素）
                auto it = S.upper_bound({a, 1e9});
                if (it == S.end()) break;

                int b = it->first;
                int y1 = it->second;
                // 计算x2：(x1/a)*b 必须<=n
                if (1LL * (x1 / a) * b <= n) {
                    int x2 = (x1 / a) * b;
                    int y2 = (y1 / b) * a;
                    cout << x1 << " " << y1 << " " << x2 << " " << y2 << "\n";
                    found = true;
                    break;
                }
            }
            if (!found) cout << "-1\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. `prework`预处理每个数的约数，存在G数组里。  
    > 2. `main`中，双指针`nl`和`nr`维护y₁的合法范围：x₁递增时，`nl`左移加入新的y₁，`nr`左移移除旧的y₁。  
    > 3. 用set存(y₁的约数b, y₁)，枚举x₁的约数a，用`upper_bound`找大于a的b，计算x₂和y₂，输出解。


<code_intro_selected>
接下来看两份优质题解的**核心片段**，学习它们的亮点：
</code_intro_selected>

**题解一：RainAir的核心片段**
* **亮点**：直接存(y₁的约数b, y₁)，查找后立刻拿到y₁，逻辑直观。
* **核心代码片段**：
    ```cpp
    set<pair<int, int>> S; // 存(b, y1)
    // 插入y1的约数
    while (nl > l) {
        nl--;
        for (auto x : G[nl]) S.insert(MP(x, nl));
    }
    // 查找b
    for (auto a : G[x]) {
        auto it = S.upper_bound(MP(a, 1e9));
        if (it == S.end()) break;
        int b = it->fi, y = it->se;
        if (1LL*(x/a)*b <= n) {
            printf("%d %d %d %d\n",x,y,x/a*b,y/b*a);
            break;
        }
    }
    ```
* **代码解读**：
    > - `MP(x, nl)`是`make_pair(x, nl)`的缩写，把y₁=nl的约数x和nl一起存入set。  
    > - `S.upper_bound(MP(a, 1e9))`找第一个比(a, 1e9)大的元素——因为pair的比较是先比第一个元素（b），再比第二个（y₁），所以这等价于找**b>a的最小元素**。  
* 💡 **学习笔记**：用pair存“约数+原数”，可以快速拿到对应的y₁，不用额外计算。

**题解二：zfy2006的核心片段**
* **亮点**：用`num`数组计数，避免set中重复存同一b，提升效率。
* **核心代码片段**：
    ```cpp
    set<int> s; // 只存存在的b
    int num[N]; // num[b]统计b出现的次数
    // 插入y1的约数
    while (nl > l) {
        nl--;
        for (auto v : g[nl]) {
            if (!num[v]) s.insert(v); // 第一次出现才插入
            num[v]++;
        }
    }
    // 删除y1的约数
    while (nr > r) {
        for (auto v : g[nr]) {
            num[v]--;
            if (!num[v]) s.erase(v); // 次数为0才删除
        }
        nr--;
    }
    // 查找b
    for (auto a : g[x]) {
        auto t = s.upper_bound(a);
        if (t == s.end()) break;
        int b = *t;
        if (x/a*b > n) continue;
        int y = r/b*b; // 取最大的y1是b的倍数（在r范围内）
        printf("%lld %lld %lld %lld\n",x,y,x/a*b,y/b*a);
        break;
    }
    ```
* **代码解读**：
    > - `num[v]`统计约数v出现的次数：当y₁加入时，v的次数加1；删除时减1。只有当次数从0变1时，才把v插入set；次数从1变0时，才从set中删除。  
    > - `r/b*b`是计算**不超过r的最大b的倍数**（比如r=10，b=3，结果是9），这样y₁最大，更可能满足条件。  
* 💡 **学习笔记**：用计数数组优化集合操作，可以减少set的插入/删除次数，提升效率——这在大数据量时很有用！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看到”算法运行，我设计了一个**8位红白机风格的像素动画**，主题是“约数探险家找搭档”：
</visualization_intro>

### 动画设计细节
- **整体风格**：仿FC游戏画面，用16色调色板（红、蓝、绿、黄为主），像素块大小为8x8。
- **场景布局**：
  1. **左侧**：x₁进度条（从1到n，用黄色像素块表示当前x₁）。
  2. **中间**：y₁范围区（用蓝色像素块表示[nl, nr]，白色块表示超出范围的y₁）。
  3. **右侧**：set集合区（用绿色像素块表示当前存在的b，每个块上显示b的值）。
  4. **底部**：控制面板（开始/暂停、单步、重置按钮，速度滑块）。

### 动画关键步骤演示
1. **初始化**：
   - 进度条x₁=1，y₁范围[1, m]（蓝色块填满中间区域），set区为空。
   - 播放8位风格的轻快背景音乐（类似《超级马里奥》的开场曲）。

2. **x₁=1时**：
   - 计算y₁范围l=ceil(L/1)=L，r=floor(R/1)=R。
   - 双指针`nl`从m+1左移到l，每移动一步，将y₁=nl的约数b用绿色块“滑入”set区，伴随“叮”的音效。
   - 枚举x₁=1的约数a=1，用红色箭头指向set中大于1的最小b（比如b=2），高亮该绿色块。
   - 计算x₂=(1/1)*2=2，y₂=(y₁/2)*1（y₁是2的倍数，比如y₁=2），弹出黄色像素提示“找到解！1 2 2 1”，伴随“叮咚”音效。

3. **x₁递增时**：
   - 进度条x₁向右移动，y₁范围缩小（nl右移，nr左移），set区中的绿色块会“滑出”（删除约数），伴随“嗒”的音效。
   - 若找不到b，则弹出红色提示“-1”，伴随“嘟嘟”音效。

### 游戏化交互设计
- **单步模式**：点击“单步”按钮，看每一步x₁增加、指针移动、set变化的细节。
- **自动模式**：点击“自动”按钮，算法像“贪吃蛇AI”一样自动运行，完成所有x₁的计算。
- **关卡奖励**：每找到10个解，弹出像素星星动画，加10分——像游戏闯关一样有成就感！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“约数+双指针+set”的技巧后，你可以尝试以下类似问题，巩固知识点：
</similar_problems_intro>

### 通用思路迁移
- 约数应用：任何涉及“乘积相等”“因数分解”的问题，都可以考虑约数分解（比如求两个数的最大公约数、最小公倍数）。
- 双指针：区间随变量单调变化的问题（比如“滑动窗口”求最长子串）。
- set查找：需要“找后继/前驱”的问题（比如求数组中比某个数大的最小数）。

### 洛谷练习推荐
1. **洛谷 P1429** - 旅行商的简化版
   - 🗣️ **推荐理由**：这道题用双指针维护区间，和本题的双指针思路完全一致，帮你巩固“单调区间”的处理技巧。
2. **洛谷 P2095** - 约数个数和
   - 🗣️ **推荐理由**：考察约数的预处理和统计，和本题的“预处理约数”环节呼应，帮你熟练掌握约数相关操作。
3. **洛谷 P3372** - 线段树模板1
   - 🗣️ **推荐理由**：虽然是线段树题，但需要维护区间的最大值，和本题的“区间维护”思路类似，帮你拓展“区间操作”的视野。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
两份题解都提到了**预处理约数的重要性**——如果不提前算好每个数的约数，每次枚举约数会用根号时间，导致总复杂度变成O(n√n)，无法通过大数据量。比如RainAir的题解中，`prework`函数用O(n log n)的时间预处理所有约数，这是算法能通过的关键！
</insights_intro>

> **参考经验（来自RainAir）**：“我一开始没预处理约数，直接用sqrt枚举x₁的约数，结果超时了。后来改成预处理所有约数，时间立刻降下来了。”
>
> **点评**：预处理是编程中的“未雨绸缪”——提前计算好常用的数据，能避免重复劳动，提升效率。比如本题的约数预处理，就是“一次计算，多次使用”的典型例子。


<conclusion>
本次关于《Equal Product》的分析就到这里啦！这道题的核心是**用约数分解把复杂问题简化**，再用双指针和set高效解决。记住：遇到“乘积相等”的问题，先想约数；遇到“单调区间”，先想双指针；遇到“找后继”，先想set。下次我们再一起探索更多有趣的算法题！💪
</conclusion>

---

---
处理用时：132.33秒
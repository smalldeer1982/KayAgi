# 题目信息

# Paper Cutting Again

## 题目描述

There is a rectangular sheet of paper with initial height $ n $ and width $ m $ . Let the current height and width be $ h $ and $ w $ respectively. We introduce a $ xy $ -coordinate system so that the four corners of the sheet are $ (0, 0), (w, 0), (0, h) $ , and $ (w, h) $ . The sheet can then be cut along the lines $ x = 1,2,\ldots,w-1 $ and the lines $ y = 1,2,\ldots,h-1 $ . In each step, the paper is cut randomly along any one of these $ h+w-2 $ lines. After each vertical and horizontal cut, the right and bottom piece of paper respectively are discarded.

Find the expected number of steps required to make the area of the sheet of paper strictly less than $ k $ . It can be shown that this answer can always be expressed as a fraction $ \dfrac{p}{q} $ where $ p $ and $ q $ are coprime integers. Calculate $ p\cdot q^{-1} \bmod (10^9+7) $ .

## 说明/提示

For the first test case, the area is already less than $ 10 $ so no cuts are required.

For the second test case, the area is exactly $ 8 $ so any one of the $ 4 $ possible cuts would make the area strictly less than $ 8 $ .

For the third test case, the final answer is $ \frac{17}{6} = 833\,333\,342\bmod (10^9+7) $ .

For the fourth test case, the final answer is $ \frac{5}{4} = 250\,000\,003\bmod (10^9+7) $ .

## 样例 #1

### 输入

```
4
2 4 10
2 4 8
2 4 2
2 4 6```

### 输出

```
0
1
833333342
250000003```

# AI分析结果

# 💡 Kay的C++算法解析：Paper Cutting Again 深入学习指南 💡

<introduction>
  今天我们来一起分析「Paper Cutting Again」这道C++编程题。这道题看似是“切割纸张”的模拟问题，实则隐藏着**数学期望与概率计算**的核心逻辑。本指南将帮助大家拆解问题本质，理解如何用“概率求和”代替“模拟切割”，并掌握高效计算的技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（期望线性性、概率推导）、逆元预处理

🗣️ **初步分析**：
> 解决这道题的关键，在于**将“期望步骤数”转化为“所有有效状态的出现概率之和”**——这是“期望线性性”的经典应用（总期望等于每个事件发生概率的总和）。简单来说，就像“收集邮票”：要收集完所有邮票的期望次数，等于每收集一张新邮票的概率之和。在这里，“切割到面积<k”的期望步骤，等于**所有满足`xy≥k`的矩形状态`(x,y)`在切割过程中出现的概率之和**。

### 核心算法流程
1. **问题转化**：将“切割纸张”转化为“从`(n,m)`出发，每次随机选择左切（x减小）或上切（y减小），直到`xy<k`停止”的随机过程。
2. **概率推导**：
   - 初始状态`(n,m)`的概率是1（必然出现）。
   - 边界状态（如`x<n`且`y=m`）：只有左切才会到达，概率为`1/(x+m-1)`。
   - 内部状态（如`x<n`且`y<m`）：需要先切到`x`或`y`，概率为`2/[(x+y)(x+y-1)]`。
3. **高效计算**：利用`x+y`的和分组计算内部状态的贡献（避免枚举所有`(x,y)`），预处理逆元快速计算分数模。

### 可视化设计思路
我们将用**8位像素风**模拟“纸张切割”的过程：
- 屏幕左侧显示像素化的纸张（用不同颜色区分当前`x`和`y`），右侧显示当前概率贡献和总期望。
- 每次“切割”时，用闪烁的像素线标记切割位置，伴随“咔嗒”的像素音效；若到达`xy<k`，播放“胜利”音效并高亮最终状态。
- 支持“单步执行”（逐一切割）和“自动播放”（快速演示完整过程），帮助直观理解“状态出现”与“概率累加”的关系。


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码可读性、算法有效性”三个维度筛选了以下优质题解，它们各有亮点，能帮助大家从不同角度理解问题：
</eval_intro>

**题解一：Leasier的完整推导与代码实现（来源：CF提交记录）**
* **点评**：这份题解的最大亮点是**将概率公式拆解为三类状态**（初始、边界、内部），并给出了严谨的推导过程。代码结构清晰，预处理逆元的部分简洁高效，内部状态的计算通过“枚举`x+y`的和”优化了复杂度（从`O(nm)`降到`O(n+m)`）。特别是解二次方程求`x`范围的部分，用浮点数计算但保证了精度，非常巧妙。对于初学者来说，这份题解是“从理论到代码”的完美桥梁。

**题解二：xuanxuan001的分情况讨论（来源：CF题解区）**
* **点评**：题解用“状态转移”的视角解释了概率的由来，比如边界状态`(x,m)`的概率推导——“只有左切才会到达，且不能提前切到y方向”。这种“分情况拆解”的思路非常适合初学者理解问题本质。此外，作者提到“利用`x+y`的和分组”优化内部状态计算，这是降低复杂度的关键技巧，值得重点学习。

**题解三：123456xwd的极简代码（来源：洛谷题解区）**
* **点评**：这份题解的代码只有30行左右，却精准抓住了问题的核心——**用期望线性性直接枚举每条切割线的贡献**。作者将“状态概率”转化为“每条线被选的概率”，代码中“枚举横线和竖线，计算`j=floor((k-1)/i)`”的部分非常简洁，逆元预处理也很规范。对于想“快速写对题”的选手来说，这是一份极佳的参考。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于“将抽象的期望转化为可计算的概率”，以及“高效处理大量状态”。结合优质题解，我总结了三个核心关键点：
</difficulty_intro>

1. **关键点1：如何应用期望线性性？**
   * **分析**：期望的线性性是指“总期望等于各个事件期望的和”，无论事件是否独立。在这里，“总期望步骤数”等于“每个满足`xy≥k`的状态`(x,y)`出现的概率之和”——因为每个状态出现一次，就对应一次切割操作。这一步转化是解题的核心，否则会陷入“模拟所有切割路径”的死胡同。
   * 💡 **学习笔记**：遇到“期望步骤数”问题，先想“能否拆成多个小事件的概率之和”！

2. **关键点2：如何推导状态的概率？**
   * **分析**：
     - 边界状态（如`x<n`且`y=m`）：只有左切才会到达，且不能提前切到y方向。此时可选的切割线有`x+m-1`条（前`x-1`条横线+`m-1`条竖线），只有“最后切到`x`”才会出现该状态，概率为`1/(x+m-1)`。
     - 内部状态（如`x<n`且`y<m`）：需要先切到`x`或`y`，此时可选的切割线有`x+y`条，其中“切到`x`或`y`”的概率是`2/(x+y)`，再乘以后续状态的概率，最终得到`2/[(x+y)(x+y-1)]`。
   * 💡 **学习笔记**：分情况讨论状态的“可达路径”，是推导概率的关键。

3. **关键点3：如何高效计算内部状态的贡献？**
   * **分析**：内部状态`(x,y)`的概率只与`x+y`有关，因此可以枚举`s=x+y`（范围`2`到`n+m-2`），然后解二次方程`x(s-x)≥k`得到`x`的范围，再计算该范围内的状态数。这样就把`O(nm)`的复杂度降到了`O(n+m)`。
   * 💡 **学习笔记**：寻找“状态的共同特征”（如`x+y`），是优化复杂度的常用技巧。

### ✨ 解题技巧总结
- **技巧A：期望线性性拆分**：将复杂的期望问题拆成简单的概率之和，避免模拟所有路径。
- **技巧B：分情况推导概率**：边界状态和内部状态的概率公式不同，需分别处理。
- **技巧C：预处理逆元**：因为结果需要模`1e9+7`，所有分数运算都要转化为“乘以逆元”，预处理`1~2e6`的逆元可以快速计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，它涵盖了所有关键步骤：预处理逆元、计算初始状态、边界状态、内部状态的贡献。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Leasier和123456xwd的思路，结构清晰，覆盖所有情况，适合初学者理解。
* **完整核心代码**：
```cpp
#include <stdio.h>
#include <math.h>
#include <algorithm>
using namespace std;

typedef long long ll;
const int N = 2e6 + 7, mod = 1e9 + 7;
int inv[N];

void init() {
    inv[1] = 1;
    for (int i = 2; i < N; i++)
        inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;
}

int main() {
    init();
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, m;
        ll k;
        scanf("%d%d%lld", &n, &m, &k);
        if ((ll)n * m < k) { printf("0\n"); continue; }
        
        int ans = 1; // 初始状态(n,m)的概率是1
        
        // 计算边界状态：x < n，y = m（左切）
        for (int x = n-1; (ll)x * m >= k; x--)
            ans = (ans + (ll)inv[x + m - 1]) % mod;
        
        // 计算边界状态：y < m，x = n（上切）
        for (int y = m-1; (ll)n * y >= k; y--)
            ans = (ans + (ll)inv[n + y - 1]) % mod;
        
        // 计算内部状态：x < n，y < m，x + y = s
        for (int s = 2; s <= n + m - 2; s++) {
            ll delta = (ll)s * s - 4 * k;
            if (delta < 0) continue;
            double sqrt_delta = sqrt(delta);
            int l = max((int)ceil((s - sqrt_delta) / 2.0), max(1, s - m + 1));
            int r = min((int)floor((s + sqrt_delta) / 2.0), min(n-1, s - 1));
            if (l > r) continue;
            int cnt = r - l + 1;
            int contrib = (ll)2 * inv[s] % mod * inv[s-1] % mod * cnt % mod;
            ans = (ans + contrib) % mod;
        }
        
        printf("%d\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：
  1. **预处理逆元**：`init()`函数计算`1~2e6`的逆元，用于后续分数模运算。
  2. **输入处理**：读取测试用例，若初始面积已小于`k`，直接输出0。
  3. **初始状态**：`ans`初始化为1（`(n,m)`的概率是1）。
  4. **边界状态**：分别枚举左切和上切的情况，累加边界状态的概率。
  5. **内部状态**：枚举`x+y`的和`s`，解二次方程得到`x`的范围，计算该范围内的状态数和贡献。

---

<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“亮点”在哪里：
</code_intro_selected>

**题解一：Leasier的内部状态计算**
* **亮点**：用二次方程快速求`x`的范围，避免枚举所有`(x,y)`。
* **核心代码片段**：
```cpp
for (int s = 2; s <= n + m - 2; s++) {
    ll delta = (ll)s * s - 4 * k;
    if (delta < 0) continue;
    double sqrt_delta = sqrt(delta);
    int l = max((int)ceil((s - sqrt_delta) / 2.0), max(1, s - m + 1));
    int r = min((int)floor((s + sqrt_delta) / 2.0), min(n-1, s - 1));
    if (l > r) continue;
    int cnt = r - l + 1;
    int contrib = (ll)2 * inv[s] % mod * inv[s-1] % mod * cnt % mod;
    ans = (ans + contrib) % mod;
}
```
* **代码解读**：
  - 对于每个`x+y=s`，我们需要找到满足`x*y≥k`的`x`范围。根据二次方程`x(s-x)≥k`，即`x² - sx +k ≤0`，解为`[ (s-√(s²-4k))/2 , (s+√(s²-4k))/2 ]`。
  - 用`max`和`min`函数限制`x`的范围（不能超过`n-1`，且`y=s-x`不能超过`m-1`）。
  - 计算该范围内的状态数`cnt`，乘以内部状态的概率`2/(s*(s-1))`（即`2*inv[s]*inv[s-1]`），得到贡献。
* 💡 **学习笔记**：用数学公式缩小枚举范围，是处理大规模数据的关键。

**题解二：123456xwd的极简枚举**
* **亮点**：直接枚举每条切割线的贡献，代码简洁到极致。
* **核心代码片段**：
```cpp
k--;
int ans=1;
for(int i=1,j;i<n;i++){
    j=floor((double)k/i);
    if(j>=m) continue;
    ans=(ans+inv[i+j])%mod;
}
for(int i=1,j;i<m;i++){
    j=floor((double)k/i);
    if(j>=n) continue;
    ans=(ans+inv[i+j])%mod;
}
```
* **代码解读**：
  - 作者将“状态概率”转化为“每条线被选的概率”：对于横线`i`，若`j=floor((k-1)/i)`（即`i*j <k`），则该线被选的概率是`1/(i+j)`（因为需要前`i-1`条横线和前`j`条竖线都没被选）。
  - 枚举所有横线和竖线，累加概率即可。
* 💡 **学习笔记**：抓住问题的“另一个角度”（切割线的贡献），可以大幅简化代码。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观理解“状态出现”与“概率累加”的过程，我设计了一个**8位像素风的切割模拟器**，融合了复古游戏元素：
</visualization_intro>

### 动画演示主题
**像素纸张切割模拟器**：用FC红白机风格展示纸张从`(n,m)`切割到`xy<k`的过程，实时显示当前状态的概率贡献和总期望。

### 核心演示内容
1. **场景初始化**：
   - 屏幕左侧是一个`n×m`的像素块（用浅灰色表示纸张，深灰色表示边框），右侧是“控制面板”和“信息区”。
   - 控制面板包含：`开始/暂停`、`单步`、`重置`按钮，以及`速度滑块`（控制自动播放的速度）。
   - 信息区显示当前的`x`、`y`、`当前概率贡献`、`总期望`。
   - 播放8位风格的背景音乐（如《超级马里奥》的轻快旋律）。

2. **算法启动**：
   - 初始状态`(n,m)`的像素块闪烁，信息区显示“当前状态：(n,m)，概率贡献：1，总期望：1”。
   - 点击“开始”后，动画自动执行切割：每次随机选择一条切割线（用红色像素线标记），然后保留左半或上半部分（被丢弃的部分变为透明）。
   - 每次切割后，信息区更新当前`x`、`y`和概率贡献（如切割到`(x,m)`，则贡献`inv[x+m-1]`），总期望累加该贡献。

3. **关键操作提示**：
   - 切割时播放“咔嗒”的像素音效；若切割到`xy<k`，播放“胜利”音效（如《塞尔达传说》的 getItem 音效），并高亮最终状态。
   - 单步模式下，每点击一次“单步”，执行一次切割，方便观察每一步的变化。
   - 重置按钮可将纸张恢复到初始状态，重新开始演示。

4. **游戏化元素**：
   - 每完成一次切割（到达一个新状态），信息区会弹出“小提示”（如“当前状态的概率是1/(x+m-1)，因为只有左切才会到达！”）。
   - 完成所有切割后，显示“总期望：X”，并给出“学习小总结”（如“总期望等于所有有效状态的概率之和！”）。

### 设计思路
- **像素风格**：营造复古游戏的轻松氛围，降低学习的“距离感”。
- **实时反馈**：每一步都显示当前状态和概率贡献，帮助理解“期望累加”的过程。
- **交互控制**：单步和自动播放结合，满足不同学习节奏的需求。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心技巧（期望线性性、概率推导、逆元预处理）可以迁移到很多问题中。以下是几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：收集邮票问题（求收集所有邮票的期望次数）——用期望线性性拆成“收集第i张新邮票的概率之和”。
- **场景2**：随机游走问题（求从起点到终点的期望步数）——用状态概率之和代替路径模拟。
- **场景3**：逆序对的期望（求随机排列的逆序对期望）——用期望线性性拆成每对元素的逆序概率之和。

### 洛谷练习推荐
1. **洛谷 P4316 绿豆蛙的归宿**
   - 🗣️ **推荐理由**：这是期望DP的经典题，需要用期望线性性拆解路径，与本题的“状态概率之和”思路一致。
2. **洛谷 P1850 换教室**
   - 🗣️ **推荐理由**：考察概率期望的计算，需要处理多个状态的概率转移，能巩固“分情况推导概率”的技巧。
3. **洛谷 P2513 逆序对的期望**
   - 🗣️ **推荐理由**：用期望线性性将逆序对总数拆成每对元素的逆序概率之和，与本题的“切割线贡献”思路异曲同工。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中蕴含了很多“踩坑”经验，值得我们借鉴：
</insights_intro>

> **参考经验（来自xuanxuan001的题解）**：“我最初尝试直接DP，但发现`O(nm)`的复杂度无法通过，后来想到利用`x+y`的和分组，才把复杂度降到`O(n+m)`。”
>
> **点评**：这提醒我们，遇到“大规模数据”问题时，不要执着于“暴力枚举”，要寻找“状态的共同特征”（如`x+y`）来优化。比如本题的内部状态，若直接枚举`x`和`y`，会超时，但按`x+y`分组后，复杂度就降到了可接受的范围。


<conclusion>
本次关于「Paper Cutting Again」的分析就到这里。这道题的核心是**用数学推导代替模拟**，通过“期望线性性”将复杂的问题拆解成简单的概率之和。记住：编程的本质是“解决问题”，而不是“写代码”——先想清楚问题的本质，再写代码，才能事半功倍！下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：119.66秒
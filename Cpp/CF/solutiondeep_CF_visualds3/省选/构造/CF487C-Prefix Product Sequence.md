# 题目信息

# Prefix Product Sequence

## 题目描述

Consider a sequence $ a_{1},a_{2},... ,a_{n}$ . Define its prefix product sequence ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF487C/ff8116fff58c431c0df2f0dc70c6d2a466564b92.png).

Now given $ n $ , find a permutation of $1,2,...,n$ , such that its prefix product sequence is a permutation of $0,1,...,n-1$ .

## 说明/提示

For the second sample, there are no valid sequences.

## 样例 #1

### 输入

```
7
```

### 输出

```
YES
1
4
3
6
5
2
7
```

## 样例 #2

### 输入

```
6
```

### 输出

```
NO
```

# AI分析结果

# 💡 Kay的C++算法解析：Prefix Product Sequence 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**数论构造**（结合质数判断、逆元计算）

🗣️ **初步分析**：  
解决“Prefix Product Sequence”，就像**用积木搭一条“不重复的前缀积小路”**——我们需要把1~n的数排成一列，让每一步的“前缀积模n”都不重复，最后一步刚好是0（因为乘了n）。  

### 核心算法逻辑
- **解的存在条件**：只有当n是1、4或质数时，才能构造出符合要求的排列。  
  - 为什么？比如n=6（合数），会有2×3=6，导致前缀积提前出现0，后面再乘n又会出现0，重复了！而质数的每个数（除了自己）都有**逆元**（相当于“反向操作”的数），能帮我们调整排列，让前缀积不重复。  
- **构造方法**：  
  1. 第1位必须是1（否则前缀积会重复，比如把1放第2位，第1位的积和第2位的积会相等）；  
  2. 最后1位必须是n（否则前面乘n会提前出0）；  
  3. 中间的数用**逆元构造**：第i位（2≤i<n）是 `i × (i-1)的逆元 % n`。这样前缀积会依次是1、2、3……n-1，最后乘n得0，完美不重复！  

### 可视化设计思路
我们可以做一个**8位像素风的“排列构造游戏机”**：  
- 屏幕左侧是1~n的“位置格子”，右侧是“前缀积显示区”；  
- 质数判断时，用像素小恐龙跑过n的因数（比如n=7，小恐龙跳过2、3，因为7不能被整除，然后跳起来比“耶”）；  
- 构造中间项时，每个位置的数从左到右“蹦出来”：比如第2位要算2×1的逆元，屏幕上会显示“2 × 1⁻¹ → 2”（因为1的逆元是1），然后前缀积区更新为2；  
- 关键操作加音效：质数判断通过是“叮～”，逆元计算完成是“滴～”，构造完所有数是“锵！”的胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法拓展性三个维度，筛选了3份超棒的题解——它们不仅讲清了“怎么做”，还能帮你想通“为什么这么做”！
</eval_intro>

**题解一：来源（作者dfkdsmbd，赞10）**  
* **点评**：这份题解像“构造题的说明书”，逻辑直接到让人拍大腿！作者先点出“只有1、4或质数有解”，再用**快速幂求逆元**构造中间项——因为质数的逆元可以用费马小定理（a的逆元是a^(p-2) mod p），代码里的`ksm`函数就是干这个的。特判n=4的情况也很贴心，直接给出了“1、3、2、4”的正确排列。代码风格超规范，变量名`lo`（long long）、`rt`（result）都能让人一眼看懂，连输入优化的`gch`函数都写得很细致，竞赛中这样的代码绝对能拿高分！

**题解二：来源（作者little_sun，赞7）**  
* **点评**：这题解的亮点是**用扩展欧几里得求逆元**——当n是质数时，扩展欧几里得和费马小定理都能求逆元，但扩展欧几里得更通用（比如n不是质数时也能用，只要gcd(a,n)=1）。作者还解释了“为什么质数的逆元存在”——因为质数和每个比它小的数都互质，所以一定能找到逆元。代码里的`exgcd`函数写得很标准，连递归的终止条件都注释清楚了，适合刚学逆元的同学理解！

**题解三：来源（作者MyukiyoMekya，赞5）**  
* **点评**：这份题解像“构造题的拓展包”！除了逆元构造，还提到了**原根构造法**——用质数的原根g，构造排列为g^0、g^1、g^(n-2)、g^3……n。原根的性质是“能生成1~n-1的所有数”，所以前缀积不会重复。虽然原根的代码有点复杂，但作者用`GetG`函数暴力找原根（因为1e5内的质数原根都很小），思路很巧妙！想挑战进阶构造的同学一定要看这份题解！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
构造题的难点往往是“想不出怎么搭”，但只要抓住3个关键点，就能轻松破题！
</difficulty_intro>

1. **关键点1：怎么判断n有没有解？**  
   * **分析**：只有n是1、4或质数时有解。为什么？  
     - 若n是合数且n≠4，比如n=6，存在2×3=6，导致前缀积提前出现0，后面乘n又会出0，重复了；  
     - 若n=4，虽然是合数，但4=2×2，构造“1、3、2、4”时，前缀积是1、3、6（mod4=2）、24（mod4=0），刚好不重复；  
     - 若n是质数，每个数（除了n）都有逆元，能构造出不重复的前缀积。  
   * 💡 **学习笔记**：合数（除4）的“因数对”会导致前缀积重复，质数的逆元是构造的关键！

2. **关键点2：逆元怎么算？**  
   * **分析**：逆元是“让a×x ≡1 mod n”的x，常用方法有两种：  
     - 费马小定理：当n是质数时，x = a^(n-2) mod n（用快速幂计算）；  
     - 扩展欧几里得：不管n是不是质数，只要gcd(a,n)=1，就能找到x（递归求解ax + ny =1）。  
   * 💡 **学习笔记**：质数用费马小定理更快，非质数用扩展欧几里得更通用！

3. **关键点3：中间的数为什么用i×(i-1)的逆元？**  
   * **分析**：假设前缀积要依次是1、2、3……n-1，那么第i位的数=第i个前缀积 / 第i-1个前缀积（mod n）。除法就是乘逆元，所以第i位= i × (i-1)的逆元 mod n。这样构造的数一定是1~n-1的排列（因为逆元唯一，i不同则结果不同）。  
   * 💡 **学习笔记**：前缀积的“递推关系”是构造排列的核心逻辑！


### ✨ 解题技巧总结
- **技巧1：先判特殊情况**：n=1、4要特判，避免通用逻辑出错；  
- **技巧2：用逆元转化除法**：模运算里没有除法，用逆元把“除以a”变成“乘a的逆元”；  
- **技巧3：暴力找小例子规律**：比如n=5时，构造“1、2、4、3、5”，前缀积是1、2、8（mod5=3）、24（mod5=4）、120（mod5=0），就能发现“前缀积要依次递增”的规律！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了优质题解的通用代码**——它包含了质数判断、逆元计算、排列构造，逻辑清晰到能直接用于竞赛！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了dfkdsmbd、little_sun的思路，用费马小定理求逆元，代码简洁高效。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;
  typedef long long ll;

  ll qpow(ll a, ll b, ll mod) { // 快速幂求a^b mod mod
      ll res = 1;
      while (b) {
          if (b & 1) res = res * a % mod;
          a = a * a % mod;
          b >>= 1;
      }
      return res;
  }

  bool is_prime(ll n) { // 判断n是不是质数
      if (n <= 1) return false;
      for (ll i = 2; i * i <= n; ++i)
          if (n % i == 0) return false;
      return true;
  }

  int main() {
      ll n; cin >> n;
      if (n == 1) { cout << "YES\n1"; return 0; }
      if (n == 4) { cout << "YES\n1\n3\n2\n4"; return 0; }
      if (!is_prime(n)) { cout << "NO"; return 0; }

      cout << "YES\n1\n";
      for (ll i = 2; i < n; ++i) {
          ll inv = qpow(i-1, n-2, n); // 求i-1的逆元
          cout << i * inv % n << '\n';
      }
      cout << n;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 先特判n=1、4的情况；  
  2. 判断n是不是质数，不是则输出NO；  
  3. 构造排列：第1位是1，中间位用i×(i-1)的逆元（费马小定理求逆元），最后一位是n。


---

<code_intro_selected>
再看3份优质题解的**核心片段**，学它们的“精华技巧”！
</code_intro_selected>

**题解一（dfkdsmbd）：快速幂求逆元**
* **亮点**：用费马小定理快速求逆元，适合质数场景。
* **核心代码片段**：
  ```cpp
  lo ksm(lo x, lo k, lo mo) { // 快速幂函数
      lo rt = 1 % mo, a = x % mo;
      while(k) {
          rt = rt * ((k & 1) ? a : 1) % mo;
          a = a * a % mo;
          k >>= 1;
      }
      return rt;
  }

  // 构造中间项时：
  printf("%lld\n", (lo)i * ksm(i - 1, n - 2, n) % n);
  ```
* **代码解读**：  
  快速幂的循环里，`k&1`判断k的最后一位是不是1，如果是，就乘上当前的a（a是x的2^m次方）；然后a平方，k右移一位（相当于除以2）。比如求i-1的逆元，就是算`ksm(i-1, n-2, n)`——因为费马小定理说a^(p-1)≡1 mod p，所以a^(p-2)就是a的逆元！
* 💡 **学习笔记**：快速幂是求逆元的“快捷键”，记牢公式a^(p-2) mod p！

**题解二（little_sun）：扩展欧几里得求逆元**
* **亮点**：扩展欧几里得更通用，能处理非质数的逆元（只要互质）。
* **核心代码片段**：
  ```cpp
  ll exgcd(ll a, ll b, ll &x, ll &y) { // 扩展欧几里得算法
      ll g = a;
      if(b == 0) x = 1, y = 0;
      else g = exgcd(b, a % b, y, x), y -= (a / b) * x;
      return g;
  }

  // 构造中间项时：
  ll x, y;
  exgcd(i - 1, n, x, y);
  printf("%lld ", ((x * 1ll * i) % n + n) % n);
  ```
* **代码解读**：  
  扩展欧几里得解决的是ax + by = gcd(a,b)的问题。当a和b互质（比如i-1和质数n），gcd(a,b)=1，所以x就是a的逆元！比如求i-1的逆元，调用`exgcd(i-1, n, x, y)`，x就是逆元。最后要加n再取模，避免x是负数。
* 💡 **学习笔记**：扩展欧几里得是逆元的“万能钥匙”，不管n是不是质数都能用！

**题解三（MyukiyoMekya）：原根构造排列**
* **亮点**：用原根构造排列，拓展构造思路。
* **核心代码片段**：
  ```cpp
  inline int GetG(int p) { // 找质数p的原根
      for(int g=2; g<p; ++g) {
          int flg=1;
          for(int k=2; flg&&k*k<=p-1; ++k) {
              if((p-1)%k==0) {
                  if(fpow(g,k,p)==1 || fpow(g,(p-1)/k,p)==1)
                      flg=0;
              }
          }
          if(flg) return g;
      }
      return -1;
  }

  // 构造排列时：
  int g=GetG(n);
  for(int i=0;i<n-1;++i)
      if(i&1) write(fpow(g,i,n)),ln;
      else write(fpow(g,n-i-1,n)),ln;
  write(n),ln;
  ```
* **代码解读**：  
  原根g的定义是“g的1~p-1次方模p能生成1~p-1的所有数”。找原根的方法是暴力枚举g，然后检查g的所有“素因子次幂”是否不等于1（比如p-1的素因子k，g^k mod p≠1，g^((p-1)/k) mod p≠1）。构造排列时，用g的奇偶次幂交替，保证前缀积不重复。
* 💡 **学习笔记**：原根是构造排列的“高级工具”，适合想挑战进阶题的同学！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”排列是怎么构造的，我设计了一个**8位像素风的“排列构造游戏机”**——像玩《超级马里奥》一样学算法！
</visualization_intro>

### 动画演示主题
**《像素探险家的排列任务》**：你是一个像素探险家，要在1~n的位置上放数字，让前缀积不重复。


### 核心演示内容
1. **场景初始化（FC风格）**：  
   - 屏幕左侧是n个“位置格子”（比如n=7，就是7个像素块，编号1~7）；  
   - 右侧是“前缀积显示区”（7个小方块，显示每个位置的前缀积模n）；  
   - 底部是“控制面板”：有“开始/暂停”“单步”“重置”按钮，还有“速度滑块”（从1x到5x）。  
   - 背景音乐是8位版《超级马里奥》的“关卡开始曲”，轻快又复古！

2. **质数判断动画**：  
   - 比如n=7，屏幕上会跑出来一只像素小恐龙，从2开始跳因数：  
     - 小恐龙跳到2，检查7%2≠0，跳起来比“√”；  
     - 跳到3，检查7%3≠0，再跳起来比“√”；  
     - 跳到4（超过√7≈2.64），小恐龙站在n=7的格子上，头顶冒出“质数！”的文字，伴随“叮～”的音效。

3. **排列构造动画**：  
   - 第1位：位置1的格子里“蹦出”数字1，前缀积显示区第1位变成1，伴随“滴～”的音效；  
   - 第2位：屏幕中间显示“计算2×1⁻¹ mod7”——1的逆元是1，所以2×1=2，位置2的格子蹦出2，前缀积显示区第2位变成2；  
   - 第3位：显示“计算3×2⁻¹ mod7”——2的逆元是4（因为2×4=8≡1 mod7），所以3×4=12≡5 mod7，位置3蹦出5，前缀积变成5；  
   - 依次类推，直到第6位（n-1=6），最后第7位蹦出7，前缀积显示区第7位变成0，伴随“锵！”的胜利音效，屏幕上放像素烟花！

4. **交互与游戏化元素**：  
   - **单步模式**：点击“单步”，每一步都暂停，让你看清楚逆元计算和前缀积变化；  
   - **自动模式**：滑动“速度滑块”，可以调节动画速度（1x是慢动作，5x是快进）；  
   - **积分系统**：每完成一个位置的构造，得10分，全部完成得100分，屏幕上显示“通关！得分：100”；  
   - **错误提示**：如果n是合数（比如n=6），小恐龙会摇头，屏幕显示“无解！”，伴随“嗡嗡”的失败音效。


<visualization_conclusion>
这个动画把“抽象的数论构造”变成了“好玩的游戏”——你能亲眼看到逆元怎么算，前缀积怎么变，甚至能自己控制速度！下次遇到构造题，不妨先想想“如果做动画，我要怎么展示每一步？”，思路会瞬间清晰！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“数论构造”，你可以解决很多类似的问题——比如求逆元、判断质数、构造不重复序列！
</similar_problems_intro>

### 通用思路/技巧迁移
- **逆元计算**：只要涉及“模运算中的除法”，都能用逆元（比如求组合数、解方程）；  
- **质数判断**：很多构造题的解存在条件都和质数有关（比如“是否存在排列使得某种运算不重复”）；  
- **构造逻辑**：先找“前缀/后缀的固定值”（比如本题的第1位是1，最后一位是n），再用递推关系构造中间项。


### 练习推荐 (洛谷)
1. **洛谷 P1082** - 同余方程  
   * 🗣️ **推荐理由**：这题要解ax ≡1 mod b，刚好是逆元的定义！用扩展欧几里得算法就能解决，练熟逆元的核心逻辑。  
2. **洛谷 P3811** - 乘法逆元  
   * 🗣️ **推荐理由**：这题要批量求1~n的逆元，用线性递推的方法（比快速幂更快），巩固逆元的优化技巧。  
3. **洛谷 P2613** - 素数筛  
   * 🗣️ **推荐理由**：这题要快速判断大量数是不是质数，用埃氏筛或欧拉筛，练熟质数判断的高效方法。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解里的“踩坑经验”比“正确代码”更珍贵！看看这些作者的心得，能帮你少走弯路！
</insights_intro>

> **参考经验（来自作者crn1）**：“我一开始暴力枚举n=1到13的排列，发现只有1、2、3、4、5、7、11、13有解，才猜出‘n是1、4或质数’的规律。”  
> **点评**：暴力枚举小例子是构造题的“入门钥匙”！很多规律藏在小数据里，比如n=5的排列是“1、2、4、3、5”，前缀积是1、2、8（mod5=3）、24（mod5=4）、120（mod5=0），就能发现“前缀积要依次递增”的规律。  

> **参考经验（来自作者MyukiyoMekya）**：“原根构造法的关键是找原根，虽然暴力，但1e5内的质数原根都很小，比如7的原根是3，11的原根是2，所以暴力完全能过！”  
> **点评**：原根的“暴力找法”其实很高效，因为小质数的原根都不大。下次遇到需要“生成所有数”的构造题，不妨试试原根！  


<conclusion>
本次关于“Prefix Product Sequence”的分析就到这里啦！构造题的核心是“找规律+用数论工具”——先通过小例子猜规律，再用逆元、原根等工具实现。记住：**编程不是“背代码”，而是“想清楚每一步为什么这么做”**！下次遇到构造题，不妨先画个小例子，再想想“怎么用数论工具搭出不重复的序列”，你一定能做出来！💪
</conclusion>

---
处理用时：145.91秒
# 题目信息

# Expensive Strings

## 题目描述

You are given $ n $ strings $ t_{i} $ . Each string has cost $ c_{i} $ .

Let's define the function of string ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF616F/a2be2e6a84d9d8ad3e2e42357554f4328caffa73.png), where $ p_{s,i} $ is the number of occurrences of $ s $ in $ t_{i} $ , $ |s| $ is the length of the string $ s $ . Find the maximal value of function $ f(s) $ over all strings.

Note that the string $ s $ is not necessarily some string from $ t $ .

## 样例 #1

### 输入

```
2
aa
bb
2 1
```

### 输出

```
4
```

## 样例 #2

### 输入

```
2
aa
ab
2 1
```

### 输出

```
5
```

# AI分析结果

# 💡 Kay的C++算法解析：Expensive Strings 深入学习指南 💡

<introduction>
  今天我们来一起分析「Expensive Strings」这道C++编程题。这道题的核心是**找到一个字符串s，让它的「价值函数」f(s)最大**——f(s)等于s在每个输入字符串中的出现次数乘以该字符串的权值，再乘以s的长度的总和。听起来有点复杂？别担心，我们会用「广义后缀自动机（SAM）」和「后缀数组（SA）」这两个经典算法来拆解问题，还会用像素动画帮你直观理解！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：广义后缀自动机（SAM） / 后缀数组（SA）  

🗣️ **初步分析**：  
解决这道题的关键，是**高效统计所有可能子串的「价值贡献」**——因为s可以是任意字符串，但只有当s是输入字符串的子串时，f(s)才可能大于0（否则f(s)=0）。  

### 算法核心思想类比
- **广义SAM**：像一个「子串收纳盒」——每个状态（盒子）装着一组「endpos相同」的子串（endpos是子串在所有输入字符串中出现的结束位置集合）。每个盒子的「价值」是这组子串对应的权值总和（比如s在ti中出现k次，就加k次ci），而盒子的「最大长度」是这组子串的最长长度。我们的目标就是找到「价值×最大长度」最大的盒子！  
- **SA**：像把所有字符串的「后缀」排成字典序，然后用「height数组」找相邻后缀的最长公共前缀（LCP）——这些LCP就是所有可能的子串。通过统计连续区间内的权值和（子串的出现次数对应的ci总和），再乘以LCP的长度，就能得到子串的贡献。  

### 题解思路与核心难点
- **共性思路**：无论是SAM还是SA，都需要**将多个字符串的子串统一处理**，并统计每个子串的「权值总和」和「长度」的乘积。  
- **核心难点**：① 如何高效处理多个字符串的子串（SAM用广义结构，SA用独特分隔符拼接）；② 如何统计每个子串的权值总和（SAM用parent树DP，SA用前缀和+悬线法）；③ 如何处理只出现一次的子串（特判每个串的开头，看前后height是否小于串长）。  

### 可视化设计思路
我们会用**8位像素风动画**展示广义SAM的构建过程：  
- 状态用不同颜色的像素块表示（比如红色代表字符串1的子串，蓝色代表字符串2的）；  
- 插入字符时，展示状态的「分裂」（比如从一个大盒子拆成两个小盒子）；  
- parent树用白色线条连接状态，DP时用数字跳动展示权值的传递；  
- 关键操作（如状态分裂、DP更新）伴随「叮」「咔嗒」的像素音效，找到最大价值时播放「胜利」音效！


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度」「代码可读性」「算法有效性」三个维度筛选了3份优质题解，帮你快速掌握核心解法：
</eval_intro>

**题解一：Alex_Wei的广义SAM解法（赞：8）**  
* **点评**：这份题解把广义SAM的「模板性」发挥到了极致！思路上，直接用SAM收纳所有子串，通过parent树DP统计每个状态的权值总和（val数组），最后遍历所有状态求「val×len」的最大值——逻辑直白到像「拆礼物盒找最大的那个」。代码风格非常规范，变量名（如len、fa、val）一看就懂，甚至还贴心地加了「避免空节点」的特判（防止WA在测试点16）。从实践角度看，这份代码可以直接套用到类似的「多字符串子串统计」问题，是广义SAM的「标准教科书」！

**题解二：grass8cow的SA解法（赞：9）**  
* **点评**：这是一份「问题驱动型」的SA题解！作者不仅讲了SA的实现步骤（拼接字符串、后缀排序、计算height数组），还解答了关键疑问（比如「分隔符会不会影响结果？」「权值为负怎么办？」）。最亮眼的是**用「品酒大会」的套路**——将height从大到小处理，用并查集维护连通块的权值和，这样每个连通块的贡献就是「当前height×权值和」。代码里的细节（如处理只出现一次的子串）非常严谨，适合想深入理解SA应用的同学！

**题解三：方123456的SA解法（赞：4）**  
* **点评**：这份题解的「结论证明」很有启发性！作者通过证明「最优子串一定是某个LCP（最长公共前缀）」，把问题转化为「求所有LCP的贡献最大值」——这一步像「剥洋葱」一样拆解了问题的本质。代码里用「悬线法」求每个height的有效区间（左右第一个比它小的height位置），再结合前缀和计算权值和，逻辑链条完整。虽然代码有些冗长，但每一步都对应着清晰的思路，适合想锻炼「问题建模」能力的同学！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到「不知道如何统计子串贡献」「处理多个字符串混乱」「漏判只出现一次的子串」这三个问题。结合优质题解，我帮你提炼了应对策略：
</difficulty_intro>

1. **难点1：如何将子串的贡献转化为算法中的统计量？**  
   * **分析**：对于SAM，每个状态的「val」是该状态所有子串的权值总和（比如s在ti中出现k次，就加k次ci），「len」是子串的最大长度——贡献就是「val×len」。对于SA，子串的贡献是「LCP长度×区间权值和」（区间内的后缀都包含这个子串）。  
   * 💡 **学习笔记**：找到「子串特征」与「算法统计量」的对应关系，是解决这类问题的关键！

2. **难点2：如何处理多个字符串的拼接（SA）？**  
   * **分析**：SA需要将所有字符串拼成一个大字符串，但要避免子串「跨字符串匹配」。优质题解的做法是**用独特的分隔符**（比如用「z'+i」作为第i个字符串的分隔符）——因为分隔符互不相同，跨字符串的子串只会出现一次，不会影响结果。  
   * 💡 **学习笔记**：处理多字符串问题时，「独特分隔符」是SA的「万能钥匙」！

3. **难点3：如何统计只出现一次的子串？**  
   * **分析**：只出现一次的子串无法通过SAM的parent树或SA的区间统计得到，需要特判。优质题解的做法是**枚举每个字符串的开头**，检查该位置的前后height是否都小于串长——如果是，说明这个串没有和其他串共享子串，贡献就是「ci×串长」。  
   * 💡 **学习笔记**：不要忽略「特殊情况」，特判是算法的「补漏神器」！

### ✨ 解题技巧总结
- **技巧A：问题抽象**：将「子串的价值」抽象为「统计量的乘积」（比如SAM的val×len，SA的LCP×权值和），避免遍历所有子串（会超时！）。  
- **技巧B：数据结构选择**：SAM适合「多字符串子串统计」，SA适合「后缀排序与LCP分析」——根据问题特征选对工具！  
- **技巧C：细节处理**：比如SAM的「空节点特判」、SA的「分隔符选择」、只出现一次的子串特判，这些细节决定了代码的正确性！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**广义SAM的通用核心实现**——来自Alex_Wei的题解，逻辑清晰、注释明确，是广义SAM的「标准模板」！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码是广义SAM的经典实现，通过parent树DP统计每个状态的权值总和，最终求「val×len」的最大值。  
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;
  const int N = 1e6 + 5;

  // 广义后缀自动机结构
  int cnt = 1, las;
  int fa[N], len[N], son[N][26];
  ll val[N];
  vector<int> e[N]; // parent树的边

  // 插入字符c（来自权值为v的字符串）
  void ins(int c, int v) {
    int p = las, cur = ++cnt;
    len[cur] = len[las] + 1, las = cur, val[cur] = v;
    while (p && !son[p][c]) son[p][c] = cur, p = fa[p];
    if (!p) { fa[cur] = 1; return; }
    int q = son[p][c];
    if (len[p] + 1 == len[q]) { fa[cur] = q; return; }
    int cl = ++cnt; // 分裂节点
    fa[cl] = fa[q], fa[q] = fa[cur] = cl;
    len[cl] = len[p] + 1;
    memcpy(son[cl], son[q], sizeof(son[q]));
    while (p && son[p][c] == q) son[p][c] = cl, p = fa[p];
  }

  // 构建parent树并DP
  void dfs(int id) {
    for (int it : e[id]) { dfs(it); val[id] += val[it]; }
  }

  int main() {
    int n; cin >> n;
    vector<string> s(n);
    for (int i = 0; i < n; i++) cin >> s[i];
    for (int i = 0; i < n; i++) {
      int c; cin >> c;
      las = 1; // 每个字符串重新开始
      for (char ch : s[i]) ins(ch - 'a', c);
    }
    // 构建parent树
    for (int i = 1; i <= cnt; i++) e[fa[i]].push_back(i);
    dfs(1);
    // 找最大贡献
    ll ans = 0;
    for (int i = 1; i <= cnt; i++) 
      if (len[fa[i]] != len[i]) // 避免空节点
        ans = max(ans, len[i] * val[i]);
    cout << ans << endl;
    return 0;
  }
  ```
* **代码解读概要**：  
  1. **插入字符**：`ins`函数负责向SAM中插入字符，处理状态的分裂（比如当遇到相同前缀但不同endpos的情况）。  
  2. **构建parent树**：将每个状态的父节点连接成树，方便后续DP。  
  3. **DP统计权值**：`dfs`函数遍历parent树，将子节点的权值累加到父节点（因为父节点的子串是子节点子串的前缀，出现次数更多）。  
  4. **求最大值**：遍历所有状态，计算「val×len」的最大值（避免空节点）。


<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的「亮点」在哪里！
</code_intro_selected>

**题解一：Alex_Wei的广义SAM**  
* **亮点**：用parent树DP高效统计权值总和，避免了复杂的线段树合并。  
* **核心代码片段**：
  ```cpp
  void dfs(int id) {
    for (int it : e[id]) { dfs(it); val[id] += val[it]; }
  }
  ```
* **代码解读**：  
  这段代码是广义SAM的「灵魂」！parent树的结构是「父节点的子串是子节点子串的前缀」——比如子节点的子串是「abc」，父节点的子串可能是「ab」或「a」。所以子节点的权值（「abc」的贡献）应该累加到父节点（「ab」和「a」的贡献也包含「abc」的出现次数）。通过DFS遍历parent树，我们就能把所有子串的权值总和统计到对应的状态中！  
* 💡 **学习笔记**：parent树的「前缀包含关系」是SAM统计子串出现次数的关键！

**题解二：grass8cow的SA**  
* **亮点**：用并查集维护连通块的权值和，处理height从大到小的情况。  
* **核心代码片段**：
  ```cpp
  // 并查集合并
  ll merge(int u, int v) {
    u = find(u), v = find(v); f[u] = v; sz[v] += sz[u];
    return sz[v];
  }
  // 处理height从大到小
  for (int i = len; i; i--) {
    for (int j = 0; j < g[i].size(); j++) merge(g[i][j]-1, g[i][j]);
    for (int j = 0; j < g[i].size(); j++) ans = max(ans, sz[find(g[i][j])] * i);
  }
  ```
* **代码解读**：  
  这段代码用了「品酒大会」的经典套路——将height从大到小处理，每次把相邻的后缀（rk为i和i-1）合并成一个连通块。连通块的sz是该块内所有后缀的权值和（对应子串的出现次数×ci），而当前的i是该子串的长度（因为height是当前连通块的LCP）。这样，每个连通块的贡献就是「i×sz」，遍历所有连通块就能找到最大值！  
* 💡 **学习笔记**：「从大到小处理height」是SA解决「最长公共前缀贡献」问题的常用技巧！

**题解三：方123456的SA**  
* **亮点**：用悬线法求每个height的有效区间，计算权值和。  
* **核心代码片段**：
  ```cpp
  // 悬线法求左边界
  for (int i = 2; i <= n; i++) {
    while (r && he[sa[q[r]]] >= he[sa[i]]) r--;
    if (r) L[i] = q[r]+1; else L[i] = 1;
    q[++r] = i;
  }
  // 悬线法求右边界
  r = 0;
  for (int i = n; i > 1; i--) {
    while (r && he[sa[q[r]]] >= he[sa[i]]) r--;
    if (r) R[i] = q[r]-1; else R[i] = n;
    q[++r] = i;
  }
  ```
* **代码解读**：  
  悬线法的作用是**找到每个height的「有效区间」**——即左右第一个比它小的height的位置。比如，对于height[i]，有效区间是[L[i], R[i]]，意味着在SA的[L[i], R[i]]区间内，所有后缀的LCP至少是height[i]。这样，该height的贡献就是「height[i]×(sum[R[i]] - sum[L[i]-2])」（sum是权值的前缀和）。悬线法用单调栈实现，时间复杂度是O(n)，非常高效！  
* 💡 **学习笔记**：悬线法是处理「区间最小值贡献」问题的「神器」！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观理解「广义SAM的构建与DP过程」，我设计了一个**8位像素风动画**——像玩「FC红白机游戏」一样看算法运行！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **8位像素风**：采用FC游戏的配色（比如深蓝背景、亮白线条、彩色状态块），字体用「Pixelated MS Sans Serif」。  
- **场景布局**：
  - 左侧：SAM状态区（用彩色方块表示状态，线条表示parent树）；  
  - 右侧：控制面板（「开始/暂停」「单步」「重置」按钮，速度滑块，当前状态信息）；  
  - 底部：日志区（显示当前操作，比如「插入字符'a'，创建状态2」）。

#### 2. 核心动画步骤
- **初始化**：显示初始状态（状态1，len=0，val=0），播放轻快的8位BGM（比如《超级马里奥》的背景音乐）。  
- **插入字符**：
  1. 当插入字符时（比如从字符串1插入'a'），状态1的'son[0]'（'a'对应0）为空，创建状态2（红色方块），parent指向状态1。状态2的val=字符串1的权值（比如2），len=1。  
  2. 日志区显示「插入'a'，创建状态2，val=2」，伴随「叮」的像素音效。  
- **状态分裂**：
  1. 当插入字符导致状态分裂时（比如插入字符'b'，需要分裂状态3），先复制状态3的son和fa到新状态4（黄色方块），然后修改状态3和新状态的fa指向状态4。  
  2. 动画展示「状态3分裂成状态3和4」，伴随「咔嗒」的音效。  
- **parent树DP**：
  1. DFS遍历parent树时，子节点的val会「流」到父节点（比如状态2的val=2，流到状态1，状态1的val变成2）。  
  2. 用数字跳动展示val的变化，比如状态1的val从0变成2时，数字「0」跳变成「2」，伴随「滴」的音效。  
- **找到最大值**：
  1. 遍历所有状态时，用「闪烁」效果标记当前状态的「val×len」值（比如状态2的val=2，len=1，值为2；状态1的val=2，len=0，值为0）。  
  2. 当找到最大值时（比如状态2的2），播放「胜利」音效（类似《魂斗罗》的通关音乐），并在屏幕中央显示「找到最大值：2！」。

#### 3. 交互设计
- **步进控制**：点击「单步」按钮，动画执行一步（比如插入一个字符，分裂一个状态）；  
- **自动播放**：滑动速度滑块（1~5档），动画自动执行，速度随滑块调整；  
- **重置**：点击「重置」按钮，回到初始状态，重新开始动画。

<visualization_conclusion>
通过这个动画，你能「看得到」SAM的状态变化、parent树的连接，甚至权值的流动——就像玩游戏一样，把抽象的算法变成了「看得见、摸得着」的过程！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
广义SAM和SA是处理「子串统计」问题的「两大法宝」，学会它们能解决很多类似的问题！
</similar_problems_intro>

### 通用思路迁移
- **广义SAM**：适用于「多字符串的子串统计」（比如统计每个子串在多少个字符串中出现过，或者计算子串的最大权值）；  
- **SA**：适用于「后缀排序与LCP分析」（比如求最长重复子串、最长公共子串）。

### 洛谷练习推荐
1. **洛谷 P6139** - 广义后缀自动机（模板题）  
   🗣️ **推荐理由**：这是广义SAM的「入门题」，帮你巩固SAM的构建和基本操作！  
2. **洛谷 P4022** - 熟悉的文章（广义SAM应用）  
   🗣️ **推荐理由**：用广义SAM统计子串的出现次数，是本题的「进阶版」！  
3. **洛谷 P4248** - [AHOI2013]差异（SA应用）  
   🗣️ **推荐理由**：用SA的height数组计算后缀的差异值，帮你掌握SA的LCP分析！  
4. **洛谷 P3804** - 后缀自动机（模板题）  
   🗣️ **推荐理由**：单字符串的SAM模板题，帮你理解SAM的核心思想！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「经验分享」能帮你避免踩坑，看看这些「过来人」的教训：
</insights_intro>

> **参考经验（来自Alex_Wei）**：「我一开始还以为要线段树合并，做题做傻了。」  
> **点评**：这是很多同学的「通病」——遇到子串统计问题就想到复杂的数据结构，但其实广义SAM的parent树DP已经足够高效！这个经验提醒我们：**先分析问题的本质，再选择合适的工具，不要盲目追求复杂算法**。

> **参考经验（来自grass8cow）**：「s包含了间隔符呢？因为间隔符互不相同，它必然只会出现一次。」  
> **点评**：分隔符的处理是SA的「细节考点」！如果不用独特的分隔符，跨字符串的子串会被错误统计。这个经验告诉我们：**细节决定成败，做题时要想清楚边界情况**。


<conclusion>
本次关于「Expensive Strings」的分析就到这里啦！广义SAM和SA是「子串统计」的「倚天剑」和「屠龙刀」，掌握它们能解决很多编程竞赛中的难题。记住：**算法的本质是「问题建模」——把实际问题转化为算法能处理的统计量，再用代码实现**。下次我们再一起探索更有趣的算法挑战！💪
</conclusion>

---
处理用时：164.97秒
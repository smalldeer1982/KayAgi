# é¢˜ç›®ä¿¡æ¯

# Binary Tree on Plane

## é¢˜ç›®æè¿°

A root tree is a directed acyclic graph that contains one node (root), from which there is exactly one path to any other node.

A root tree is binary if each node has at most two outgoing arcs.

When a binary tree is painted on the plane, all arcs should be directed from top to bottom. That is, each arc going from $ u $ to $ v $ must meet the condition $ y_{u}&gt;y_{v} $ .

You've been given the coordinates of all tree nodes. Your task is to connect these nodes by arcs so as to get the binary root tree and make the total length of the arcs minimum. All arcs of the built tree must be directed from top to bottom.

## æ ·ä¾‹ #1

### è¾“å…¥

```
3
0 0
1 0
2 1
```

### è¾“å‡º

```
3.650281539872885
```

## æ ·ä¾‹ #2

### è¾“å…¥

```
4
0 0
1 0
2 1
2 0
```

### è¾“å‡º

```
-1
```

# AIåˆ†æç»“æœ


### ğŸ’¡ Kayçš„C++ç®—æ³•è§£æï¼šBinary Tree on Plane æ·±å…¥å­¦ä¹ æŒ‡å— ğŸ’¡

#### 1. é¢˜ç›®è§£è¯»ä¸æ ¸å¿ƒç®—æ³•è¯†åˆ«
âœ¨ **æœ¬é¢˜ä¸»è¦è€ƒå¯Ÿ**ï¼šç½‘ç»œæµå»ºæ¨¡ï¼ˆæœ€å°è´¹ç”¨æœ€å¤§æµï¼‰  
ğŸ—£ï¸ **åˆæ­¥åˆ†æ**ï¼š  
> è§£å†³æœ¬é¢˜éœ€å°†äºŒå‰æ ‘çº¦æŸè½¬åŒ–ä¸ºç½‘ç»œæµæ¨¡å‹ã€‚æƒ³è±¡æ°´æµä»æºç‚¹ï¼ˆæ°´æºï¼‰æµå‘æ±‡ç‚¹ï¼ˆæ°´åº“ï¼‰ï¼Œæ¯æ¡ç®¡é“ä»£è¡¨çˆ¶å­å…³ç³»ã€‚æ¯ä¸ªèŠ‚ç‚¹æ‹†æˆ"å‡ºç‚¹"ï¼ˆåˆ†é…å„¿å­ï¼‰å’Œ"å…¥ç‚¹"ï¼ˆæ¥æ”¶çˆ¶äº²ï¼‰ï¼š  
> - **æºç‚¹â†’å‡ºç‚¹**ï¼šå®¹é‡2ï¼ˆæœ€å¤šä¸¤ä¸ªå„¿å­ï¼‰ï¼Œè´¹ç”¨0  
> - **å…¥ç‚¹â†’æ±‡ç‚¹**ï¼šå®¹é‡1ï¼ˆæ°å¥½ä¸€ä¸ªçˆ¶äº²ï¼‰ï¼Œè´¹ç”¨0  
> - **èŠ‚ç‚¹é—´è¾¹**ï¼šå½“yáµ¤>yáµ¥æ—¶ï¼Œuçš„å‡ºç‚¹â†’vçš„å…¥ç‚¹ï¼Œå®¹é‡1ï¼Œè´¹ç”¨ä¸ºæ¬§æ°è·ç¦»  
>  
> **æ ¸å¿ƒéš¾ç‚¹**ï¼š  
> 1. äºŒå‰æ ‘çº¦æŸâ†’ç½‘ç»œæµå®¹é‡é™åˆ¶  
> 2. ä¿è¯æ ‘ç»“æ„ï¼ˆn-1æ¡è¾¹ï¼‰  
> 3. é¿å…ç¯æˆ–æ£®æ—  
>  
> **å¯è§†åŒ–è®¾è®¡**ï¼š  
> é‡‡ç”¨8ä½åƒç´ é£æ ¼ï¼ŒèŠ‚ç‚¹æ˜¾ç¤ºä¸ºåŒè‰²æ–¹å—ï¼ˆè“ï¼šå‡ºç‚¹/çº¢ï¼šå…¥ç‚¹ï¼‰ã€‚ç®—æ³•è¿è¡Œæ—¶ï¼š  
> - å¢å¹¿è·¯å¾„é«˜äº®ä¸ºé»„è‰²å…‰å¸¦  
> - æˆåŠŸåŒ¹é…æ—¶æ’­æ”¾"å®"éŸ³æ•ˆ  
> - æ ‘ç»“æ„åœ¨å³ä¾§é€æ­¥ç”Ÿæˆåƒç´ æ ‘å½¢å›¾

---

#### 2. ç²¾é€‰ä¼˜è´¨é¢˜è§£å‚è€ƒ
**é¢˜è§£ä¸€ï¼ˆKAMIYA_KINAï¼‰**  
* **ç‚¹è¯„**ï¼šæ€è·¯æ¸…æ™°æ‹†è§£çˆ¶å­çº¦æŸï¼Œä»£ç è§„èŒƒï¼ˆå˜é‡å`u_1`/`u_2`ç›´è§‚ç‚¹ä½ï¼‰ã€‚äº®ç‚¹åœ¨äºå®è·µå¯¹æ¯”Dinicä¸EKç®—æ³•æ€§èƒ½ï¼Œå‘ç°å•è·¯å¾„æ‹“å±•åœºæ™¯ä¸­EKæ›´ä¼˜ï¼Œè¿™å¯¹ç«èµ›è°ƒè¯•æå…·å‚è€ƒä»·å€¼ã€‚è¾¹ç•Œå¤„ç†ä¸¥è°¨ï¼ˆyåæ ‡ä¸¥æ ¼æ¯”è¾ƒï¼‰ã€‚

**é¢˜è§£äºŒï¼ˆrui_erï¼‰**  
* **ç‚¹è¯„**ï¼šä»£ç æ¨¡å—åŒ–ä¼˜ç§€ï¼ˆåˆ†ç¦»SPFA/å¢å¹¿å‡½æ•°ï¼‰ï¼Œå˜é‡å«ä¹‰æ˜ç¡®ï¼ˆ`pre`å­˜å‚¨è·¯å¾„ï¼‰ã€‚äº®ç‚¹åœ¨äºç²¾ç¡®å¤„ç†æµ®ç‚¹æ•°ç²¾åº¦ï¼ˆ1e-9çº§è¯¯å·®ï¼‰ï¼Œå¹¶é‡‡ç”¨å…ƒç»„è¿”å›æµé‡/è´¹ç”¨ï¼Œå¢å¼ºå¯è¯»æ€§ã€‚å¤æ‚åº¦åˆ†æåˆ°ä½ï¼ˆO(nÂ³)ï¼‰ã€‚

**é¢˜è§£ä¸‰ï¼ˆwcyQwQï¼‰**  
* **ç‚¹è¯„**ï¼šå›¾ç¤ºåŒ–è§£é‡Šæ‹†ç‚¹æ€æƒ³ï¼ˆ"çˆ¶äº²/å„¿å­"åŒé‡èº«ä»½ï¼‰ï¼Œè¾¹ç•Œåˆ¤æ–­ä¸¥è°¨ï¼ˆyåæ ‡ç›¸ç­‰ä¸è¿è¾¹ï¼‰ã€‚äº®ç‚¹åœ¨äºå®Œæ•´é”™è¯¯å¤„ç†ï¼ˆmemsetæµ®ç‚¹æ•°ç»„é™·é˜±è­¦ç¤ºï¼‰ï¼Œå¯¹åˆå­¦è€…è°ƒè¯•æå…·å¯å‘æ€§ã€‚

---

#### 3. æ ¸å¿ƒéš¾ç‚¹è¾¨æä¸è§£é¢˜ç­–ç•¥
1. **éš¾ç‚¹ï¼šäºŒå‰æ ‘çº¦æŸâ†’ç½‘ç»œæµè½¬åŒ–**  
   * **åˆ†æ**ï¼šé€šè¿‡æ‹†ç‚¹å°†åº¦æ•°çº¦æŸè½¬åŒ–ä¸ºå®¹é‡é™åˆ¶ã€‚å‡ºç‚¹å®¹é‡2é™åˆ¶å„¿å­æ•°ï¼Œå…¥ç‚¹å®¹é‡1ä¿è¯å”¯ä¸€çˆ¶äº²ï¼Œå®Œç¾åŒ¹é…æ ‘å½¢è¦æ±‚ã€‚  
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šæ‹†ç‚¹æ˜¯ç½‘ç»œæµå¤„ç†èŠ‚ç‚¹çº¦æŸçš„åˆ©å™¨ï¼

2. **éš¾ç‚¹ï¼šæ ‘ç»“æ„çš„å®Œæ•´æ€§éªŒè¯**  
   * **åˆ†æ**ï¼šæœ€å¤§æµå¿…é¡»ä¸ºn-1æ‰èƒ½å½¢æˆæ ‘ã€‚è‹¥æµé‡ä¸è¶³ï¼Œè¯´æ˜å­˜åœ¨å­¤ç«‹èŠ‚ç‚¹ï¼ˆå¦‚å¤šä¸ªyåæ ‡æœ€å¤§ç‚¹ç«äº‰æ ¹èŠ‚ç‚¹ï¼‰ã€‚  
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šæµé‡æ˜¯æ ‘ç»“æ„çš„"éªŒé‡‘çŸ³"ã€‚

3. **éš¾ç‚¹ï¼šé¿å…æ— æ•ˆè¾¹è¿æ¥**  
   * **åˆ†æ**ï¼šé¢„å¤„ç†æ—¶ä¸¥æ ¼æ£€æŸ¥yáµ¤>yáµ¥ï¼Œå¹¶é‡‡ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç®¡ç†SPFAï¼Œé¿å…æ— æ•ˆæ¾å¼›ã€‚  
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šé¢„å¤„ç†è¿‡æ»¤æ˜¯ä¼˜åŒ–ç½‘ç»œæµçš„å…³é”®æ­¥éª¤ã€‚

âœ¨ **è§£é¢˜æŠ€å·§æ€»ç»“**  
- **çº¦æŸè½¬åŒ–**ï¼šå°†æŠ½è±¡æ ‘çº¦æŸè½¬åŒ–ä¸ºå…·ä½“å®¹é‡æ•°å­—ï¼ˆ2å­/1çˆ¶ï¼‰  
- **ç²¾åº¦æ§åˆ¶**ï¼šæµ®ç‚¹æ•°è´¹ç”¨æ¯”è¾ƒéœ€è®¾è¯¯å·®é˜ˆå€¼ï¼ˆå¦‚1e-9ï¼‰  
- **ç®—æ³•é€‰æ‹©**ï¼šå•è·¯å¾„æ‹“å±•å›¾é¦–é€‰EKè€ŒéDinic

---

#### 4. C++æ ¸å¿ƒä»£ç å®ç°èµæ
**é€šç”¨æ ¸å¿ƒå®ç°ï¼ˆç»¼åˆè‡ªä¼˜è´¨é¢˜è§£ï¼‰**  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 805;
const double INF = 1e18;
struct Edge { int to, cap, rev; double cost; };
vector<Edge> G[N];
double dis[N], mincost;
int n, s, t, flow[N], preV[N], preE[N];
pair<int, int> pos[N];

void add_edge(int from, int to, int cap, double cost) {
    G[from].push_back({to, cap, G[to].size(), cost});
    G[to].push_back({from, 0, G[from].size()-1, -cost});
}

bool SPFA() {
    fill(dis, dis+N, INF);
    vector<bool> inq(N, false);
    queue<int> q;
    dis[s] = 0; flow[s] = 1e9; q.push(s);
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (int i = 0; i < G[u].size(); i++) {
            auto &e = G[u][i];
            if (e.cap > 0 && dis[e.to] > dis[u] + e.cost + 1e-9) {
                dis[e.to] = dis[u] + e.cost;
                preV[e.to] = u; preE[e.to] = i;
                flow[e.to] = min(flow[u], e.cap);
                if (!inq[e.to]) q.push(e.to), inq[e.to] = true;
            }
        }
    }
    return dis[t] < INF;
}

void MCMF() {
    while (SPFA()) {
        mincost += flow[t] * dis[t];
        for (int v = t; v != s; v = preV[v]) {
            auto &e = G[preV[v]][preE[v]];
            e.cap -= flow[t];
            G[v][e.rev].cap += flow[t];
        }
    }
}

int main() {
    cin >> n;
    s = 0; t = 2*n+1;
    for (int i = 1; i <= n; i++) cin >> pos[i].first >> pos[i].second;
    
    // å»ºå›¾
    for (int i = 1; i <= n; i++) {
        add_edge(s, i, 2, 0);        // æºç‚¹â†’å‡ºç‚¹
        add_edge(i+n, t, 1, 0);       // å…¥ç‚¹â†’æ±‡ç‚¹
    }
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++)
            if (pos[i].second > pos[j].second) {
                double dx = pos[i].first - pos[j].first;
                double dy = pos[i].second - pos[j].second;
                add_edge(i, j+n, 1, sqrt(dx*dx + dy*dy)); // å‡ºç‚¹â†’å…¥ç‚¹
            }
    
    MCMF();
    // éªŒè¯æµé‡æ˜¯å¦æ„æˆæ ‘
    int total_flow = 0;
    for (auto &e : G[t]) total_flow += e.cap;
    cout << (total_flow == n-1 ? fixed << setprecision(8) << mincost : -1);
}
```

**ä»£ç è§£è¯»æ¦‚è¦**ï¼š  
> 1. **å»ºå›¾é˜¶æ®µ**ï¼šæ‹†ç‚¹å¤„ç†ï¼ˆ1~nä¸ºå‡ºç‚¹ï¼Œn+1~2nä¸ºå…¥ç‚¹ï¼‰  
> 2. **SPFA**ï¼šå¯»æ‰¾æœ€å°è´¹ç”¨å¢å¹¿è·¯å¾„ï¼ˆæµ®ç‚¹ç²¾åº¦1e-9ï¼‰  
> 3. **å¢å¹¿æ“ä½œ**ï¼šå›æº¯è·¯å¾„æ›´æ–°æ®‹ä½™ç½‘ç»œ  
> 4. **éªŒè¯**ï¼šæ£€æŸ¥æ±‡ç‚¹åå‘è¾¹æµé‡æ˜¯å¦ä¸ºn-1  

---

#### 5. ç®—æ³•å¯è§†åŒ–ï¼šåƒç´ åŠ¨ç”»æ¼”ç¤º
**ä¸»é¢˜**ï¼š8ä½æœºé£æ ¼çš„"ç½‘ç»œæµå»ºæ ‘å¤§å†’é™©"  
**æ ¸å¿ƒæ¼”ç¤º**ï¼š  
![](https://via.placeholder.com/400x200/000000/FFFFFF?text=åƒç´ åŠ¨ç”»ç¤ºæ„å›¾)  
1. **åˆå§‹åŒ–**ï¼š  
   - å·¦ä¾§è“è‰²æ°´æºï¼ˆæºç‚¹ï¼‰ï¼Œå³ä¾§é»„è‰²æ°´åº“ï¼ˆæ±‡ç‚¹ï¼‰  
   - ä¸­é—´èŠ‚ç‚¹æ˜¾ç¤ºä¸ºåŒæ–¹å—ï¼šå·¦é’ï¼ˆå‡ºç‚¹ï¼‰ï¼Œå³æ©™ï¼ˆå…¥ç‚¹ï¼‰

2. **å¢å¹¿è¿‡ç¨‹**ï¼š  
   - SPFAæ¢ç´¢æ—¶å½“å‰é˜Ÿåˆ—èŠ‚ç‚¹é—ªçƒçº¢å…‰  
   - å¢å¹¿è·¯å¾„æ˜¾ç¤ºä¸ºé‡‘è‰²æµåŠ¨å…‰å¸¦  
   - æˆåŠŸåŒ¹é…æ—¶æ’­æ”¾"å®"å£°ï¼Œæ ‘ç»“æ„å³ä¾§ç”Ÿæˆåƒç´ ææ¡

3. **äº¤äº’æ§åˆ¶**ï¼š  
   ```javascript
   // ä¼ªä»£ç ç¤ºä¾‹
   const spfaStep = () => {
     highlightCurrentNode(); // å½“å‰èŠ‚ç‚¹é»„å…‰
     updateQueueAnim();      // é˜Ÿåˆ—åƒç´ å—æ³¢åŠ¨
     if (foundPath) playSound('ding.wav'); 
   }
   ```

4. **æ¸¸æˆåŒ–å…ƒç´ **ï¼š  
   - æ¯æ‰¾åˆ°ä¸€æ¡å¢å¹¿è·¯å¾—10åˆ†ï¼ˆ8ä½æ•°å­—æ˜¾ç¤ºï¼‰  
   - æœ€ç»ˆæ„æˆæ ‘æ—¶æ’­æ”¾ã€Šè¶…çº§ç›ä¸½ã€‹é€šå…³éŸ³ä¹  
   - æ— è§£æ—¶æ˜¾ç¤º"GAME OVER"åƒç´ è‰ºæœ¯å­—

---

#### 6. æ‹“å±•ç»ƒä¹ ä¸ç›¸ä¼¼é—®é¢˜æ€è€ƒ
**é€šç”¨æŠ€å·§è¿ç§»**ï¼š  
1. åº¦æ•°çº¦æŸå›¾ â†’ æ‹†ç‚¹ç½‘ç»œæµï¼ˆå¦‚P1231 æ•™è¾…çš„åˆ†é…ï¼‰  
2. æµ®ç‚¹è´¹ç”¨æµ â†’ ç²¾åº¦æ§åˆ¶è®­ç»ƒï¼ˆP4015 è¿è¾“é—®é¢˜ï¼‰  
3. æ ‘ç»“æ„éªŒè¯ â†’ æµé‡åŒ¹é…æ€æƒ³ï¼ˆP2756 é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆï¼‰  

**æ´›è°·æ¨è**ï¼š  
1. **P4009 æ±½è½¦åŠ æ²¹è¡Œé©¶**  
   â†’ åˆ†å±‚å›¾ç½‘ç»œæµç»å…¸ï¼Œå·©å›ºæ‹†ç‚¹æ€æƒ³  
2. **P1251 é¤å·¾è®¡åˆ’**  
   â†’ è´¹ç”¨æµæ¨¡å‹è®¾è®¡ï¼Œå¼ºåŒ–çº¦æŸè½¬åŒ–èƒ½åŠ›  
3. **P2153 æ™¨è·‘**  
   â†’ å¤šçº¦æŸç½‘ç»œæµï¼Œæå‡å»ºæ¨¡å¤æ‚åº¦å¤„ç†  

---

#### 7. å­¦ä¹ å¿ƒå¾—ä¸ç»éªŒåˆ†äº«
> **æ¥è‡ªKAMIYA_KINAçš„è°ƒè¯•ç»éªŒ**ï¼š  
> "åœ¨ç¨ å¯†å›¾ä¸­Dinicé€’å½’å¼€é”€å¤§ï¼Œæ”¹ç”¨EKåæ•ˆç‡æå‡10å€ï¼"  
>  
> **Kayç‚¹è¯„**ï¼š  
> è¿™æ˜¯ææœ‰ä»·å€¼çš„å®æˆ˜ç»éªŒï¼å½“å›¾ç»“æ„å‘ˆå•è·¯å¾„æ‹“å±•ï¼ˆå¢å¹¿è·¯çŸ­ä¸”å°‘åˆ†æ”¯ï¼‰æ—¶ï¼ŒEKçš„O(nÂ²)åæ¯”Dinicçš„O(nÂ²m)æ›´ä¼˜ã€‚å»ºè®®ï¼š  
> 1. ç¨ å¯†å°å›¾ï¼ˆnâ‰¤500ï¼‰ä¼˜å…ˆå°è¯•EK  
> 2. ç”¨`clock()`å‡½æ•°å¯¹æ¯”ç®—æ³•å®é™…æ€§èƒ½  
> 3. å­¦ä¼šä»ç†è®ºå¤æ‚åº¦èµ°å‘å®æµ‹ä¼˜åŒ–  

---

**Kayç»“è¯­**ï¼š  
é€šè¿‡æœ¬æ¬¡æ¢ç´¢ï¼Œæˆ‘ä»¬è§è¯äº†ç½‘ç»œæµå¦‚ä½•å·§å¦™åŒ–è§£å¤æ‚çº¦æŸã€‚è®°ä½ï¼šæ‹†ç‚¹æ˜¯è½¬åŒ–èŠ‚ç‚¹é™åˆ¶çš„ä¸‡èƒ½é’¥åŒ™ï¼Œæµé‡éªŒè¯æ˜¯ç»“æ„çš„è¯•é‡‘çŸ³ã€‚ç»§ç»­å‹‡é—¯ç®—æ³•ä¸–ç•Œå§ï¼Œå°‘å¹´ï¼ğŸš€

---
å¤„ç†ç”¨æ—¶ï¼š192.31ç§’
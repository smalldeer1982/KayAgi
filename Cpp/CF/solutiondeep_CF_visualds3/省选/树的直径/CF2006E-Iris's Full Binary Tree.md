# 题目信息

# Iris's Full Binary Tree

## 题目描述

Iris 喜欢满二叉树。

我们定义一棵有根树的深度为从某个顶点到根的简单路径上顶点的最大数量。深度为 $d$ 的满二叉树是一棵深度为 $d$ 且恰好有 $2^d - 1$ 个顶点的二叉树。

Iris 称一棵树为 $d$-二叉树，如果可以通过添加一些顶点和边，使其变为一棵深度为 $d$ 的满二叉树。注意，满二叉树的根可以任选任意顶点。

由于在大树上操作很困难，她定义了一棵树的二叉深度为满足该树是 $d$-二叉树的最小 $d$。具体地说，如果不存在整数 $d \ge 1$ 使得该树是 $d$-二叉树，则该树的二叉深度为 $-1$。

现在，Iris 有一棵仅包含顶点 $1$ 的树。她想再添加 $n-1$ 个顶点，形成一棵更大的树。她会依次添加这些顶点。当她添加第 $i$ 个顶点（$2 \leq i \leq n$）时，会给你一个整数 $p_i$（$1 \leq p_i < i$），并添加一条连接顶点 $i$ 和 $p_i$ 的新边。

Iris 想请你告诉她，对于每个 $1 \le i \le n$，由前 $i$ 个顶点组成的树的二叉深度是多少。你能告诉她答案吗？

## 说明/提示

在第一个测试用例中，最终的树如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2006E/7f900739a2145e9bd80715ede4260b35ba51b9fd.png)

- 仅包含顶点 $1$ 的树的二叉深度为 $1$（该树本身就是深度为 $1$ 的满二叉树）。
- 包含顶点 $1$ 和 $2$ 的树的二叉深度为 $2$（我们可以添加顶点 $3$ 使其成为深度为 $2$ 的满二叉树）。
- 包含顶点 $1$、$2$ 和 $3$ 的树的二叉深度为 $2$（该树本身就是深度为 $2$ 的满二叉树）。

在第二个测试用例中，添加一些顶点后形成的满二叉树如下图所示（加粗的顶点为新添加的）：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2006E/90faca99e1781d73f69b5b60a32aa2a2da38a68c.png)

形成的满二叉树的深度为 $4$。

在第五个测试用例中，最终的树如下图所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2006E/2c0d039efae462812828b42368688f46ffc8b41e.png)

可以证明，Iris 无法通过添加顶点和边形成任何满二叉树，因此二叉深度为 $-1$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
7
3
1 1
6
1 2 3 4 5
7
1 1 3 2 5 1
10
1 1 2 1 4 2 4 5 8
10
1 1 3 1 3 2 2 2 6
20
1 1 2 2 4 4 5 5 7 6 8 6 11 14 11 8 13 13 12
25
1 1 3 3 1 5 4 4 6 8 11 12 8 7 11 13 7 13 15 6 19 14 10 23```

### 输出

```
1 2 2 
1 2 2 3 3 4 
1 2 2 3 3 4 4 
1 2 2 3 3 3 4 4 5 5 
1 2 2 3 3 4 4 4 -1 -1 
1 2 2 3 3 4 4 4 4 5 5 5 5 6 6 6 6 6 6 7 
1 2 2 3 3 4 4 4 4 5 5 6 6 6 6 6 7 7 7 7 7 8 8 8 8```

# AI分析结果

---
# 💡 Kay的C++算法解析：Iris's Full Binary Tree 深入学习指南 💡

<introduction>
今天我们来一起分析「Iris's Full Binary Tree」这道C++编程题。这道题需要我们动态维护一棵树的「二叉深度」——也就是能把当前树补成满二叉树的最小深度d。本指南会帮你梳理核心思路，理解树论与数据结构的结合技巧，还会用像素动画直观展示算法过程哦！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树论（直径与中心） + 数据结构（DFS序+线段树）

🗣️ **初步分析**：
解决这道题的关键，是理解「二叉深度」的本质——**找一个度数≤2的根，使得根到树中最远点的距离+1最小**（因为满二叉树的深度是根到最远点的距离+1）。而树中最远点一定是直径的端点（引理1），所以我们只需要维护树的直径和中心，并用数据结构高效计算每个可能根的「最远点距离」。

简单来说，这就像「给树找一个“平衡点”当根，让树的“跨度”最小」——就像你举着一根杆子，平衡点能让杆子最稳。这里的“平衡点”就是树的中心，而我们要用线段树维护每个点到直径端点的距离，快速找到符合度数要求的最小跨度。

题解的核心思路一致：
1. **动态维护树的直径**：每次加点后，直径要么不变，要么延长1（引理2）。
2. **维护树的中心**：中心是直径的中点（单点或边上），移动中心时用DFS序+线段树调整所有点的距离。
3. **处理度数限制**：根的度数≤2，其他点≤3；若有度数>3的点，直接返回-1。

可视化设计思路：用8位像素风展示树的生长，中心用闪烁的“星星”标记，线段树区间更新时对应节点变色，加点时播放“叮”的音效，找到最小d时播放“胜利”音效，让你直观看到“中心移动”和“距离变化”的过程~


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：作者 Conan15（赞：3）**
* **点评**：这份题解从静态问题入手，逐步推导动态维护的方法，逻辑非常连贯。作者详细解释了“中心移动”的两种情况（单点/边上），并用线段树维护距离的区间更新，代码结构清晰（比如`move`函数处理中心移动，`insert`函数处理加点）。尤其是对“子树区间加”的处理，完美结合了DFS序的性质，值得学习。

**题解二：作者 DaiRuiChen007（赞：1）**
* **点评**：此题解的代码非常简洁，将LCA、距离计算、线段树操作封装得很干净。作者直接点出“最优根是离中心最近的2度点”，并用线段树维护所有符合条件点的最小距离，思路直白。尤其是`nxt`函数找子节点的方法，巧妙利用了DFS序的单调性，是代码的亮点。

**题解三：作者 irris（赞：1）**
* **点评**：作为出题人题解，这份内容充满理论支撑（引理1、2），帮你从本质理解问题。作者指出“动态维护直径的端点来自原直径端点和新点”，并解释了“不定根子树用区间表示”的原因，让你明白线段树的设计逻辑。理论+实践的结合，适合深入理解算法本质。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，是突破三个核心难点。我们结合优质题解的思路，一一拆解~
</difficulty_intro>

1. **难点1：理解二叉深度的条件**  
   * **问题**：为什么根的度数要≤2？为什么其他点≤3？  
   * **分析**：满二叉树的根度数是2（除了深度1），其他节点度数最多3（左右子节点+父节点）。如果原树有节点度数>3，无法补成满二叉树，直接返回-1。  
   * 💡 **学习笔记**：先检查度数！一旦有节点度数>3，后面的询问全是-1。

2. **难点2：动态维护树的直径与中心**  
   * **问题**：每次加点后，直径和中心怎么变？  
   * **分析**：根据引理2，新直径的端点只能是原直径端点或新点。中心是直径的中点——如果直径长度是偶数，中心是单点；如果是奇数，中心是边上的两点。移动中心时，用DFS序的子树区间更新距离（比如中心从a移到p[a]，则a的子树距离+1，其他区间-1）。  
   * 💡 **学习笔记**：中心移动=调整距离的区间更新，DFS序是关键！

3. **难点3：高效计算每个点的最远点距离**  
   * **问题**：为什么只用看直径的两个端点？  
   * **分析**：引理1告诉我们，树中任意点的最远点一定是直径的端点之一。所以每个点的最远点距离=max(到端点A的距离, 到端点B的距离)。  
   * 💡 **学习笔记**：不用遍历所有点！只需要维护两个端点的距离，就能快速计算最远点。


### ✨ 解题技巧总结
- **技巧A：静态转动态**：先想静态问题（比如固定树的直径），再推导动态维护的方法，降低难度。  
- **技巧B：DFS序的应用**：将树的子树转化为区间，用线段树高效处理区间更新/查询。  
- **技巧C：引理的利用**：记住树论的经典结论（比如直径端点、中心性质），能快速找到解题方向。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的通用实现，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Conan15和DaiRuiChen007的思路，清晰展示“动态维护直径+线段树维护距离”的核心逻辑。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5e5 + 5, INF = 1e9;

// 线段树：维护每个点的最远点距离
struct SegmentTree {
    int tr[MAXN << 2], tg[MAXN << 2];
    void pushup(int p) { tr[p] = min(tr[p << 1], tr[p << 1 | 1]); }
    void addtag(int p, int k) { tg[p] += k; tr[p] += k; }
    void pushdown(int p) {
        if (tg[p]) {
            addtag(p << 1, tg[p]);
            addtag(p << 1 | 1, tg[p]);
            tg[p] = 0;
        }
    }
    void init(int l, int r, int p) {
        tr[p] = INF; tg[p] = 0;
        if (l == r) return;
        int mid = (l + r) >> 1;
        init(l, mid, p << 1);
        init(mid + 1, r, p << 1 | 1);
    }
    void set(int u, int k, int l, int r, int p) {
        if (l == r) { tr[p] = k; return; }
        pushdown(p);
        int mid = (l + r) >> 1;
        if (u <= mid) set(u, k, l, mid, p << 1);
        else set(u, k, mid + 1, r, p << 1 | 1);
        pushup(p);
    }
    void add(int ul, int ur, int k, int l, int r, int p) {
        if (ul > ur) return;
        if (ul <= l && r <= ur) { addtag(p, k); return; }
        pushdown(p);
        int mid = (l + r) >> 1;
        if (ul <= mid) add(ul, ur, k, l, mid, p << 1);
        if (mid < ur) add(ul, ur, k, mid + 1, r, p << 1 | 1);
        pushup(p);
    }
} T;

// 树结构：DFS序、LCA、深度
vector<int> G[MAXN];
int fa[MAXN], dep[MAXN], L[MAXN], R[MAXN], st[MAXN][20], dcnt;
void dfs(int u) {
    dep[u] = dep[fa[u]] + 1; L[u] = ++dcnt; st[dcnt][0] = fa[u];
    for (int v : G[u]) dfs(v);
    R[u] = dcnt;
}
int LCA(int x, int y) {
    if (x == y) return x;
    int l = min(L[x], L[y]) + 1, r = max(L[x], L[y]), k = __lg(r - l + 1);
    return (L[st[l][k]] < L[st[r - (1 << k) + 1][k]]) ? st[l][k] : st[r - (1 << k) + 1][k];
}
int dis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; }

// 动态维护直径和中心
int u, v, r, deg[MAXN]; // u、v是直径端点，r是半径
void move_center(int &a, int x, int n) {
    if (L[a] <= L[x] && L[x] <= R[a]) { // x在a的子树中
        T.add(1, n, 1);
        int child = *--upper_bound(G[a].begin(), G[a].end(), x, [&](int i, int j) { return L[i] < L[j]; });
        a = child;
        T.add(L[a], R[a], -1);
    } else { // x不在a的子树中
        T.add(L[a], R[a], 1);
        a = fa[a];
    }
}

int main() {
    ios::sync_with_stdio(false);
    int T_case; cin >> T_case;
    while (T_case--) {
        int n; cin >> n;
        for (int i = 1; i <= n; ++i) G[i].clear(), deg[i] = 0;
        for (int i = 2; i <= n; ++i) {
            cin >> fa[i];
            G[fa[i]].push_back(i);
        }
        dcnt = 0; dfs(1);
        for (int k = 1; k < 20; ++k)
            for (int i = 1; i + (1 << k) - 1 <= n; ++i)
                st[i][k] = (L[st[i][k-1]] < L[st[i + (1 << (k-1))][k-1]]) ? st[i][k-1] : st[i + (1 << (k-1))][k-1];
        
        T.init(1, n, 1); T.set(L[1], 0, 1, n, 1);
        u = v = 1; r = 0;
        cout << "1 ";
        
        bool flag = false;
        for (int p = 2; p <= n; ++p) {
            if (flag) { cout << "-1 "; continue; }
            deg[fa[p]]++; deg[p]++;
            if (deg[fa[p]] > 3) { flag = true; cout << "-1 "; continue; }
            if (deg[fa[p]] == 3) T.set(L[fa[p]], INF, 1, n, 1);
            
            int du = dis(u, p), dv = dis(v, p);
            T.set(L[p], max(du, dv), 1, n, 1);
            
            if (du > dv) swap(u, v);
            if (dv > dis(u, v)) {
                if (u == v) { // 单点中心
                    move_center(u, p, n); r++;
                } else { // 边上中心
                    if (du > dv) move_center(u, p, n);
                    else move_center(v, p, n);
                }
            }
            
            int min_dist = T.tr[1];
            cout << min_dist + 1 << " ";
        }
        cout << "\n";
    }
    return 0;
}
```
* **代码解读概要**：
  1. **线段树**：维护每个点的最远点距离（max到直径端点的距离）。
  2. **DFS序**：将树转化为区间，方便线段树区间更新。
  3. **LCA与距离**：计算两点间的距离，用于更新直径端点。
  4. **动态维护**：每次加点后，更新度数、调整中心、查询最小距离，输出结果。


<code_intro_selected>
接下来剖析优质题解的核心片段，看看各自的亮点~
</code_intro_selected>

**题解一：作者 Conan15**
* **亮点**：详细处理了“中心移动”的两种情况，代码逻辑严谨。
* **核心代码片段**：
```cpp
void move(int &a, int x) {  // a往x移动一步
    int l = lca(a, x);
    if (l == a) {   // x在a的子树中
        tr.add(1, n, 1);
        a = getk(x, dep[x] - dep[a] - 1); // 找到a的子节点（x方向）
        tr.add(dfn[a], dfn[a] + sz[a] - 1, -1);
    } else {        // x不在a的子树中
        tr.add(dfn[a], dfn[a] + sz[a] - 1, 1);
        a = p[a];   // 往上走一步
    }
}
```
* **代码解读**：
  - 这段代码是“中心移动”的核心！当x在a的子树中，先给所有点的距离+1（因为中心要往x方向移动），然后找到a的子节点（x所在的子树），给这个子树的距离-1（因为这些点离新中心更近了）。
  - 比如，中心a要往子节点b移动，那么b的子树里的点到新中心的距离比原来少1，其他点多1——线段树的区间加完美实现了这个逻辑！
* **学习笔记**：用线段树维护“距离变化”，是动态维护中心的关键技巧。


**题解二：作者 DaiRuiChen007**
* **亮点**：用`upper_bound`快速找到子节点，代码简洁高效。
* **核心代码片段**：
```cpp
int nxt(int x, int y) {
    if (L[x] <= L[y] && L[y] <= R[x]) { // y在x的子树中
        return *--upper_bound(G[x].begin(), G[x].end(), y, 
            [&](int i, int j){ return L[i]<L[j]; });
    }
    return fa[x]; // 不在子树中，返回父节点
}
```
* **代码解读**：
  - `upper_bound`按DFS序查找y所在的子节点——因为G[x]中的子节点是按DFS序排序的，所以`upper_bound`能快速找到第一个L[i]>L[y]的节点，减一后就是y的父节点（x的子节点）。
  - 比如，x有子节点b、c，DFS序L[b]<L[c]，如果y在b的子树中，`upper_bound`返回c的迭代器，减一后就是b——完美找到y所在的子节点！
* **学习笔记**：利用DFS序的单调性，可以快速定位子节点，避免遍历所有子节点。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个「像素树探险家」的动画，用8位复古风格展示算法过程，让你直观看到“树生长”“中心移动”“距离变化”~
</visualization_intro>

### 🎮 动画设计方案
**主题**：像素树探险家在森林中种植树苗，每种一棵苗，要找到最稳的“树心”（中心），让树能补成最小的满二叉树。

### 🎨 核心演示内容
1. **场景初始化**：
   - 屏幕左侧是像素树（用不同颜色的方块表示节点：根是红色，新点是绿色，中心是闪烁的黄色星星）。
   - 右侧是线段树面板（用蓝色方块表示区间，颜色越深代表距离越大）。
   - 底部是控制面板：单步/自动播放、速度滑块、重置按钮。

2. **动画步骤**：
   - **加点**：点击“单步”，种下一棵绿色树苗（新点），播放“叮”的音效。
   - **度数检查**：如果父节点度数变为3，父节点变成灰色（标记为不可选根）。
   - **中心移动**：如果新点让直径变长，黄色星星（中心）会往新点方向移动，同时线段树面板对应的区间变色（加1的区间变亮，减1的区间变暗）。
   - **结果输出**：找到最小距离后，屏幕弹出“√”的像素动画，播放“胜利”音效（8位风格的“叮~”）。

3. **交互设计**：
   - **单步执行**：每点击一次，执行一个加点步骤，详细展示中心移动和线段树变化。
   - **自动播放**：设置速度滑块（慢/中/快），动画自动执行，适合快速浏览整体流程。
   - **重置**：回到初始状态，重新开始演示。

### 🎵 音效设计
- **加点**：轻微的“叮”声（提示新点加入）。
- **中心移动**：短促的“嗒”声（提示中心调整）。
- **找到最小d**：上扬的“叮~”声（庆祝成功）。
- **度数>3**：低沉的“嗡”声（提示错误）。

### 🚀 技术实现
用HTML+CSS+JavaScript（Canvas API）实现：
- **像素树**：用Canvas绘制方块，动态更新节点位置和颜色。
- **线段树面板**：用Canvas绘制矩形，根据线段树的区间加操作改变颜色深度。
- **音效**：用Web Audio API播放8位风格的音效，比如`ctx.createOscillator()`生成正弦波，调整频率模拟复古音效。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题考察了“树的直径、中心、动态维护”的综合能力，类似的问题还有这些~
</similar_problems_intro>

### 🧠 通用思路迁移
- **树的直径**：很多树论问题都需要维护直径，比如“找树中最长路径”“最小化最远点距离”。
- **动态维护**：动态加点的问题，通常可以用“增量式”方法，每次更新部分结构，避免重新计算全部。

### 📚 洛谷练习推荐
1. **P1099 树网的核**：考察树的直径和中心，练习找“最稳的核”。
2. **P2924 [USACO08DEC]Patting Heads S**：虽然是数论问题，但需要动态维护计数，类似“动态更新”的思路。
3. **P3304 [SDOI2013]直径**：静态树的直径问题，巩固直径的计算方法。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
Conan15的题解提到“动态加点维护答案困难，先想静态问题”，这个经验很实用！
</insights_intro>

> **参考经验 (来自 Conan15)**：“第一眼感觉动态加点维护答案是困难的，所以先来考虑一下静态问题。”
>
> **点评**：很多动态问题的难点在于“增量更新”，而静态问题的解法是动态问题的基础。比如这道题，先想静态树的直径和中心，再推导动态维护的方法，能快速找到突破口。下次遇到动态问题，不妨先想“如果是静态的，我会怎么做？”


## 8. 总结

本次关于「Iris's Full Binary Tree」的分析就到这里啦~ 这道题的核心是**树论与数据结构的结合**，通过维护直径和中心，用线段树高效计算最小距离。记住：动态问题先想静态，树论问题找直径，数据结构用DFS序+线段树！

编程能力的提升在于**多思考、多实践**，下次遇到树论问题，不妨试试今天学的技巧~ 加油！💪

---
<conclusion>
本次分析就到这里，希望这份指南能帮你理解树论与数据结构的结合技巧。编程的乐趣在于解决问题的过程，继续保持好奇心，下次我们再一起探索新的挑战！🚀
</conclusion>
---

---
处理用时：112.75秒
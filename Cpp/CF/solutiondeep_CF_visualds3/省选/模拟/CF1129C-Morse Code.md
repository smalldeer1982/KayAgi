# 题目信息

# Morse Code

## 题目描述

在摩尔斯电码（以下简称“摩码”）中，字母表中的一个字母被表示为一个长度为$1$~$4$的01串。长度为$1$~$4$的01串共有$2^1+2^2+2^3+2^4=30$个，而字母只有$26$个，所以有$4$个01串不表示任何字母——"0011"、"0101"、"1110"、"1111"，其他$26$个01串表示互不相同的$26$个字母。

你有一个01串$S$，初始为空。现在有$m$次添加，每次往$S$的末尾添加一个字符（"0"或"1"）。对于每一次添加，你都要回答目前的$S$的所有非空子串用摩码所能表示的字母串的总数。由于答案可能巨大，你只需要输出答案模$10^9+7$的结果。

## 样例 #1

### 输入

```
3
1
1
1
```

### 输出

```
1
3
7
```

## 样例 #2

### 输入

```
5
1
0
1
0
1
```

### 输出

```
1
4
10
22
43
```

## 样例 #3

### 输入

```
9
1
1
0
0
0
1
1
0
1
```

### 输出

```
1
3
10
24
51
109
213
421
833
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Morse Code 深入学习指南 💡

<introduction>
今天我们来一起分析“Morse Code”这道C++编程题。这道题需要我们动态维护一个01字符串，每次添加字符后计算所有非空子串能表示的字母串总数（去重）。本指南将帮你梳理核心思路，理解动态规划与字符串判重的结合，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划与字符串处理结合`

🗣️ **初步分析**：
解决这道题的关键在于两点：一是用动态规划（DP）计算每个子串能表示的字母串数量；二是高效判断新增子串是否重复。  
动态规划的核心思想像“搭积木”——每个子串的方案数可以由更短的子串方案数累加而来。例如，若子串`[j,i]`的末尾1-4位是合法摩码，则其方案数等于去掉这1-4位后的子串方案数之和。  
而判重问题类似“查字典”——每次新增字符后，会生成多个新子串（如`[1,i]`、`[2,i]`…`[i,i]`），需要快速判断这些子串是否之前出现过。若未出现，则将其DP值累加到答案中。  

题解中主要有三种思路：  
- **DP+哈希判重**（如chenxia25）：用二维DP记录子串方案数，链式前向星哈希表判重，时间复杂度O(n²)。  
- **Trie树**（如夜猫子驱蚊器）：通过Trie树存储所有后缀，利用树结构天然去重，动态计算新增节点的贡献。  
- **后缀自动机（SAM）**（如wucstdio）：利用SAM高效处理子串去重，结合DP计算贡献。  

核心算法流程中，DP状态转移需处理1-4位摩码的合法性（排除4个无效串），判重则通过哈希、Trie或SAM实现。可视化时，可设计像素动画展示DP值的累加过程（如不同颜色的方块表示不同长度的子串贡献），以及哈希表/树结构如何标记重复子串（如闪烁或变色提示重复）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选了3道优质题解，它们在动态规划设计或判重优化上各有亮点。
</eval_intro>

**题解一：chenxia25（来源：洛谷/CodeForces）**
* **点评**：此题解思路清晰，将问题拆解为DP计算和哈希判重两部分。DP状态`dp[i][j]`表示长度为`i`、起点为`j`的子串方案数，转移时枚举末尾1-4位的合法摩码，逻辑直白。哈希判重采用链式前向星（类似分桶哈希表），避免了STL的高时间常数，保证了O(n²)的效率。代码变量命名规范（如`dp`、`Hsh`），边界处理严谨（如初始化`dp[0][j]=1`），是动态规划与哈希结合的典型实现。

**题解二：夜猫子驱蚊器（来源：CSDN）**
* **点评**：此题解另辟蹊径，用Trie树存储所有后缀，利用树结构天然去重。每次新增字符时，通过维护后缀节点的父节点，动态计算新增节点的贡献（即该后缀的方案数）。代码中`f[x]`表示Trie节点`x`对应子串的方案数，转移时枚举末尾1-4位的摩码，逻辑巧妙。虽然注释较少，但Trie树的设计对理解字符串去重有启发。

**题解三：wucstdio（来源：洛谷）**
* **点评**：此题解结合后缀自动机（SAM）处理去重。SAM能高效管理所有不同子串，通过维护每个节点的父节点（表示最长公共后缀），快速确定新增子串中未重复的部分。DP计算时，倒序递推每个后缀的方案数，结合SAM的长度信息（`len[node]`）排除重复子串的贡献。SAM的应用体现了对高级数据结构的灵活运用，适合进阶学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于突破以下三个难点，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：动态规划状态的定义与转移**  
    * **分析**：DP状态需表示子串的起点和长度（或终点）。例如，`dp[i][j]`表示起点为`j`、长度为`i`的子串方案数。转移时，枚举末尾1-4位的合法摩码（排除4个无效串），将更短子串的方案数累加。例如，若当前子串长度为`i`，则`dp[i][j] = dp[i-1][j+1] + dp[i-2][j+2] + dp[i-3][j+3] + (合法时的dp[i-4][j+4])`。  
    * 💡 **学习笔记**：动态规划的核心是“分解问题”，将大问题拆分为更小的子问题（如更短的子串），并通过状态转移方程建立联系。

2.  **关键点2：高效判重（避免重复子串的贡献）**  
    * **分析**：每次新增字符后，会生成`i`个新子串（`i`为当前字符串长度）。若直接用`set`判重，时间复杂度为O(n²logn)，可能超时。优质题解采用链式前向星（分桶哈希表）、Trie树或SAM优化：  
      - 链式前向星将哈希值分桶，每桶用链表存储，减少查询时间；  
      - Trie树存储所有后缀，新增字符时仅扩展后缀节点，天然去重；  
      - SAM通过维护最长公共后缀长度（`len[node]`），快速确定新增子串中未重复的部分。  
    * 💡 **学习笔记**：判重的本质是“快速查询子串是否已存在”，选择合适的数据结构（如哈希表、Trie、SAM）能显著降低时间复杂度。

3.  **关键点3：动态维护答案（每次添加字符后的增量计算）**  
    * **分析**：每次添加字符后，答案的增量是所有新子串（未重复）的方案数之和。例如，添加第`i`个字符后，新增子串为`[1,i]`、`[2,i]`…`[i,i]`，需计算这些子串的方案数并去重累加。优质题解通过动态规划预处理每个子串的方案数，结合判重结构快速筛选未重复子串，实现增量更新。  
    * 💡 **学习笔记**：增量计算的关键是“复用历史结果”，避免重复计算子串的方案数。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将问题拆分为“计算子串方案数”和“判重累加”两部分，分别解决。  
- **动态规划优化**：利用摩码长度短（1-4位）的特点，将状态转移限制在O(1)时间。  
- **高效判重**：根据数据规模选择哈希表（简单问题）、Trie树（后缀管理）或SAM（高级子串管理）。  
- **模运算处理**：每一步加法后取模，避免溢出（如`ans = (ans + dp_val) % MOD`）。  
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择chenxia25的DP+哈希判重解法作为通用核心实现，其思路清晰、代码规范，适合学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了chenxia25的题解思路，通过二维DP计算子串方案数，链式前向星哈希表判重，时间复杂度O(n²)。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define N 3000
    #define hshmod 10000000 // 分桶数
    #define mod 1000000007
    #define ull unsigned long long

    bitset<N+1> a; // 存储01串
    int dp[N+1][N+2]; // dp[i][j]：长度为i，起点为j的子串方案数
    ull Hsh[N+1], power[N+1]; // 前缀哈希和基数幂

    // 判断4位串是否合法（非无效摩码）
    inline bool ok(bool a, bool b, bool c, bool d) {
        return !(!a && !b && c && d || !a && b && !c && d || a && b && c && !d || a && b && c && d);
    }

    ull hsh(int l, int r) { // 计算子串哈希
        return Hsh[r] - Hsh[l-1] * power[r - l + 1];
    }

    // 链式前向星哈希表
    int head[hshmod], nxt[N*N], tot;
    ull data[N*N];
    void add(int x, ull y) {
        data[++tot] = y;
        nxt[tot] = head[x];
        head[x] = tot;
    }

    int main() {
        int n, ans = 0;
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            int x; scanf("%d", &x);
            a[i] = x;
        }

        // 预处理哈希基数幂
        power[0] = 1;
        for (int i = 1; i <= n; ++i) {
            Hsh[i] = Hsh[i-1] * 131ull + a[i] + 1;
            power[i] = power[i-1] * 131ull;
        }

        // DP初始化：空串方案数为1
        fill(dp[0] + 1, dp[0] + n + 2, 1);

        // 动态规划计算子串方案数
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j + i - 1 <= n; ++j) {
                dp[i][j] = dp[i-1][j+1]; // 取末尾1位
                if (i >= 2) dp[i][j] = (dp[i][j] + dp[i-2][j+2]) % mod; // 取末尾2位
                if (i >= 3) dp[i][j] = (dp[i][j] + dp[i-3][j+3]) % mod; // 取末尾3位
                if (i >= 4 && ok(a[j], a[j+1], a[j+2], a[j+3])) // 取末尾4位（需合法）
                    dp[i][j] = (dp[i][j] + dp[i-4][j+4]) % mod;
            }
        }

        // 每次添加字符后计算答案
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) { // 枚举新子串的起点j（终点i）
                ull h = hsh(j, i); // 计算哈希值
                int hmod = h % hshmod; // 分桶
                bool dup = false;
                for (int k = head[hmod]; k; k = nxt[k]) { // 检查是否重复
                    if (data[k] == h) { dup = true; break; }
                }
                if (!dup) { // 未重复则累加
                    ans = (ans + dp[i - j + 1][j]) % mod;
                    add(hmod, h); // 记录哈希值
                }
            }
            printf("%d\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码分为三部分：  
  1. **预处理哈希**：计算前缀哈希和基数幂，用于快速计算子串哈希值；  
  2. **动态规划**：二维`dp`数组记录每个子串的方案数，转移时枚举末尾1-4位的合法摩码；  
  3. **判重累加**：每次添加字符后，枚举所有新子串，用链式前向星哈希表判重，未重复的子串方案数累加到答案。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：chenxia25（来源：洛谷/CodeForces）**
* **亮点**：链式前向星哈希表的高效判重，避免了STL的高时间常数；动态规划转移逻辑清晰，直接枚举1-4位的合法摩码。  
* **核心代码片段**：
    ```cpp
    // 动态规划转移部分
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j + i - 1 <= n; ++j) {
            dp[i][j] = dp[i-1][j+1];
            if (i >= 2) dp[i][j] = (dp[i][j] + dp[i-2][j+2]) % mod;
            if (i >= 3) dp[i][j] = (dp[i][j] + dp[i-3][j+3]) % mod;
            if (i >= 4 && ok(a[j], a[j+1], a[j+2], a[j+3]))
                dp[i][j] = (dp[i][j] + dp[i-4][j+4]) % mod;
        }
    }
    ```
* **代码解读**：  
  这段代码计算每个子串的方案数。`i`是子串长度，`j`是起点。对于长度为`i`的子串`[j, j+i-1]`，其方案数由末尾1-4位的子串方案数累加而来：  
  - 末尾1位：`dp[i-1][j+1]`（即子串`[j+1, j+i-1]`的方案数）；  
  - 末尾2位：`dp[i-2][j+2]`（子串`[j+2, j+i-1]`的方案数）；  
  - 末尾3位：`dp[i-3][j+3]`（子串`[j+3, j+i-1]`的方案数）；  
  - 末尾4位：仅当该4位是合法摩码时，加上`dp[i-4][j+4]`（子串`[j+4, j+i-1]`的方案数）。  
  这样，每个子串的方案数被分解为更短子串的方案数之和，符合动态规划的递推思想。  
* 💡 **学习笔记**：动态规划的状态转移需要覆盖所有可能的分解方式（如本题的1-4位摩码），并排除无效情况（如4个无效摩码）。

**题解二：夜猫子驱蚊器（来源：CSDN）**
* **亮点**：Trie树存储后缀，天然去重；动态计算每个Trie节点的方案数，避免重复计算子串贡献。  
* **核心代码片段**：
    ```cpp
    void add(int x, int d) { // 在Trie树中新增节点
        trie[x][d] = ++cnt;
        anc[cnt] = x; // 记录父节点
        int tmp = cnt, s = 0, ss = 0;
        for (int i = 1; i <= 4; ++i) { // 枚举末尾1-4位的摩码
            int ff = anc[tmp];
            if (trie[ff][0] == tmp) s = 0; else s = 1; // 当前位的值（0或1）
            ss += s << (i-1); // 拼接当前位到ss（4位二进制）
            tmp = ff;
            if (i == 4 && (ss == 3 || ss == 5 || ss == 14 || ss == 15)) continue; // 跳过无效摩码
            else Add(f[cnt], f[tmp]); // 累加父节点的方案数
            if (tmp == 0) break; // 到达根节点，停止
        }
        Add(ans, f[cnt]); // 累加当前节点的方案数到答案
    }
    ```
* **代码解读**：  
  这段代码在Trie树中新增一个节点（表示一个新后缀的末尾部分）。`anc[cnt]`记录父节点，`f[cnt]`表示该节点对应子串的方案数。通过向上遍历父节点（最多4层），拼接当前位的二进制值（`ss`），判断是否为合法摩码。若合法，则将父节点的方案数累加到当前节点的`f[cnt]`中（因为当前子串可分解为父节点子串+当前摩码）。最后，将当前节点的方案数累加到答案中（Trie树天然去重，每个节点仅对应一个唯一子串）。  
* 💡 **学习笔记**：Trie树适合处理后缀/前缀的去重问题，每个节点对应唯一子串，可直接统计其贡献。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解动态规划与判重的过程，我们设计一个“像素摩码探险”动画，用8位像素风格展示子串生成、DP计算和判重的每一步。
\</visualization_intro\>

  * **动画演示主题**：`像素摩码探险——动态规划与判重之旅`

  * **核心演示内容**：  
    每次添加一个0或1后，屏幕右侧生成新的像素方块（表示当前字符串），左侧展示所有新子串（如`[1,i]`、`[2,i]`…`[i,i]`）。每个子串用不同颜色的像素条表示，动态计算其DP值（数字显示），并用哈希表/树结构判重（重复子串变红，未重复变绿）。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）营造轻松氛围；子串的DP值动态更新（类似“分数累加”），判重时的颜色变化强化记忆；关键操作（如哈希表插入、Trie树扩展）伴随“叮”的音效，增强交互感。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        - 屏幕分为三部分：右侧为当前字符串（像素方块排列，0为蓝色，1为红色）；中间为DP计算区（显示子串的起点、长度和DP值）；左侧为哈希表/树结构（分桶的格子或Trie节点）。  
        - 控制面板包含“单步”、“自动播放”按钮和速度滑块。

    2.  **添加字符与生成新子串**：  
        - 新字符（像素方块）从右侧滑入当前字符串末尾。  
        - 生成所有以新字符结尾的子串（如`[1,i]`到`[i,i]`），用白色虚线框逐一高亮。

    3.  **动态规划计算DP值**：  
        - 对于每个新子串，按长度1-4分解，用箭头指向更短的子串（如长度4的子串指向长度3、2、1的子串）。  
        - DP值逐步累加（如长度为4的子串DP值=长度3子串DP值+长度2子串DP值+…），数字动态增长，伴随“滴答”音效。

    4.  **判重与累加答案**：  
        - 每个新子串的哈希值（或Trie路径）显示在左侧结构中。  
        - 若哈希表/树中已存在该子串（红色标记），则该子串的DP值不加入答案；若不存在（绿色标记），则DP值累加到答案（答案数字变大，播放“升级”音效）。

    5.  **自动演示与交互**：  
        - “自动播放”模式下，算法自动执行添加字符、计算DP、判重累加的全流程，学习者可观察整体过程。  
        - “单步”模式下，每点击一次按钮，执行一步操作（如添加一个字符），配合旁白解释当前步骤的目的（如“现在计算长度为4的子串方案数”）。

  * **旁白提示**：  
    - （添加字符时）“新字符加入，现在需要计算所有以它结尾的子串！”  
    - （DP计算时）“看，这个子串的方案数由更短的子串累加而来，就像搭积木一样～”  
    - （判重时）“这个子串之前出现过吗？哈希表里查一查，红色表示重复，绿色表示新贡献！”

\<visualization_conclusion\>
通过这样的动画，我们能直观看到动态规划如何分解问题，以及哈希表/树结构如何高效判重。像素风格和音效让学习过程更有趣，关键步骤的高亮和旁白帮助理解核心逻辑。
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
本题的动态规划与字符串判重思路可迁移到多种场景，以下是相关练习推荐：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    动态规划+字符串判重的组合适用于：  
    1. **不同子串统计**（如统计所有不同子串的某种属性和）；  
    2. **增量更新问题**（每次添加元素后求全局结果，如最长递增子序列的动态维护）；  
    3. **模式匹配问题**（如统计所有不同模式的出现次数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1115 最大子段和**  
        * 🗣️ **推荐理由**：动态规划经典题，练习如何通过状态转移解决增量问题。  
    2.  **洛谷 P3805 【模板】manacher算法**  
        * 🗣️ **推荐理由**：字符串处理高级算法，学习如何高效处理回文子串。  
    3.  **洛谷 P5496 【模板】后缀自动机**  
        * 🗣️ **推荐理由**：深入理解SAM的结构与应用，掌握高级字符串去重技巧。

-----

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试经验，对我们有重要参考价值：
\</insights_intro\>

> **参考经验 (来自 chenxia25)**：“在实现哈希判重时，一开始用STL的`set`导致TLE，后来改用链式前向星分桶哈希表，才通过了时间限制。这让我意识到，对于大规模数据，手写哈希表的效率远高于STL容器。”  
> **点评**：STL容器（如`set`）虽然方便，但在时间敏感的问题中（如n²次操作），手写哈希表或数组能显著降低常数。遇到TLE时，可考虑优化数据结构的选择。

-----

\<conclusion\>
本次关于“Morse Code”的分析就到这里。通过动态规划计算子串方案数，结合哈希表/Trie/SAM高效判重，我们解决了动态添加字符后的去重统计问题。希望这份指南能帮你掌握相关技巧，在编程路上更进一步！下次见～💪
\</conclusion\>

-----

---
处理用时：178.34秒
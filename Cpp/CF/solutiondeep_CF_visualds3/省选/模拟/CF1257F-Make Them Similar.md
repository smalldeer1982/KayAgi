# 题目信息

# Make Them Similar

## 题目描述

给定一个长度为 $n$ $(2\leq n\leq100)$ 的正整数数组 $a_i$ $(0\leq a_i \leq 2^{30}-1)$



求是否存在 $x$ $(0\leq x \leq 2^{30}-1)$ ，使得对于数组 $b_i$，其中 $b_i=a_i \text{ xor } x$，$b_i$ 中所有元素两两的 $\text{popcount}(b_i)$ 相同。



其中 $\text{ xor }$是按位异或，$\text{popcount}(x)$是 $x$ 的二进制表示中 $1$ 的个数



请输出任意满足条件的 $x$ ，若不存在输出 $-1$

## 样例 #1

### 输入

```
2
7 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4
3 17 6 0
```

### 输出

```
5
```

## 样例 #3

### 输入

```
3
1 2 3
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
3
43 12 12
```

### 输出

```
1073709057
```

# AI分析结果

---
# 💡 Kay的C++算法解析：Make Them Similar 深入学习指南 💡

<introduction>
今天我们来一起分析“Make Them Similar”这道C++编程题。这道题的核心在于找到一个数x，使得数组每个元素异或x后的二进制中1的个数都相同。本指南将帮助大家梳理题目思路，理解折半搜索的核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（折半搜索，Meet-in-the-Middle）

🗣️ **初步分析**：
> 解决这道题的关键在于理解“折半搜索”（Meet-in-the-Middle）的思想。简单来说，折半搜索就像把一个大问题“劈成两半”，分别解决后再合并结果，就像用钥匙开锁时，先试前半部分齿痕，再试后半部分，最后组合起来。本题中，x的范围是0到2^30-1，直接枚举所有可能的x显然不可行（2^30约十亿次），因此我们将x的30位二进制拆分为前15位和后15位，分别枚举这两部分的可能值，通过中间结果的匹配来找到符合条件的x。
   - **题解思路**：大部分题解采用折半搜索，将x分为前15位和后15位。枚举前15位时，计算每个a_i前15位异或后的popcount差异数组，存入map；枚举后15位时，计算后15位异或后的差异数组，若在map中找到匹配，则合并前后部分得到x。
   - **核心难点**：如何设计差异数组的存储与匹配，确保时间复杂度可接受（2^15 * n ≈ 3e4 * 100，可处理）。
   - **可视化设计**：动画将用8位像素风格展示x的前15位和后15位枚举过程，用不同颜色的像素块表示差异数组的匹配状态，关键步骤（如找到匹配）伴随“叮”的音效，帮助直观理解折半搜索的分治逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰性、代码规范性、算法有效性等维度评估，以下题解评分均≥4星，值得重点学习：
</eval_intro>

**题解一：作者LittleMoMol（赞7）**
* **点评**：此题解思路清晰，对折半搜索的拆分逻辑（前15位和后15位）解释透彻，并通过具体示例说明差异数组的构造过程。代码中使用`map<vector<int>, int>`存储前半部分的差异数组，变量命名（如`c1`、`d1`）直观，边界处理严谨（如枚举范围为0到2^15-1）。特别地，作者分享了自己首次学明白折半搜索的心得，对初学者有激励作用。

**题解二：作者柳易辰（赞5）**
* **点评**：此题解从异或的特性出发，引导读者联想到折半搜索的适用性，并推荐了相关模板题（如P4799），帮助学习者建立知识关联。代码中详细注释了位运算的细节（如前15位和后15位的提取），算法时间复杂度分析（O(2^15 * 15n)）明确，实践参考价值高。

**题解三：作者orpg（赞3）**
* **点评**：此题解代码简洁，直接使用C++内置函数`__builtin_popcount`计算popcount，提升效率。差异数组的构造逻辑（`b_i - b_1`和`d_1 - d_i`）清晰，通过`map`快速查询匹配，代码可读性强，适合作为折半搜索的入门示例。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：如何拆分问题为可处理的子问题？**
    * **分析**：x的30位二进制直接枚举不可行，需拆分为前15位和后15位。这是因为2^15=32768，两次枚举的总次数为2^15 * 2^15 = 2^30，但通过中间结果存储（如map），实际计算量降为2*2^15 * n（n≤100），可接受。
    * 💡 **学习笔记**：当问题规模为2^k时，拆分为k/2两部分，利用折半搜索可将复杂度从O(2^k)降为O(2^(k/2))。

2.  **关键点2：如何设计差异数组并高效匹配？**
    * **分析**：题目要求所有`b_i = a_i xor x`的popcount相同，即`popcount(b_i) = popcount(b_1)`。转化为差异数组：前15位异或后的popcount差异为`c_i - c_1`，后15位为`d_1 - d_i`。若两者相等，则`c_i + d_i = c_1 + d_1`，满足条件。通过map存储前半部分的差异数组，后半部分枚举时直接查询即可。
    * 💡 **学习笔记**：将问题转化为“差异相等”是折半搜索的关键，通过构造互补的差异数组，可快速匹配。

3.  **关键点3：如何处理位运算的细节？**
    * **分析**：前15位通过右移15位（`a_i >> 15`）获取，后15位通过按位与（`a_i & ((1<<15)-1)`）获取。异或操作（`^`）的优先级低于比较运算，需注意括号的使用（如`(a_i >> 15) ^ x`）。
    * 💡 **学习笔记**：位运算时，用括号明确优先级，避免因运算顺序错误导致结果错误。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：当问题规模过大时，尝试将其拆分为两部分，分别处理后合并结果（如折半搜索）。
- **差异数组**：通过构造差异数组，将“全局相等”问题转化为“局部差异匹配”问题，降低计算复杂度。
- **内置函数**：使用`__builtin_popcount`（GCC）或`bitset<32>(x).count()`（通用）快速计算popcount，提升效率。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先看一个综合优质题解的通用核心C++实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了LittleMoMol、柳易辰等题解的思路，采用折半搜索，结构清晰，适合作为学习参考。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <map>
    using namespace std;

    const int N = 110;
    const int HALF = 1 << 15; // 前15位和后15位的范围

    int n;
    int a[N];
    map<vector<int>, int> mp; // 存储前15位的差异数组及对应的x前半部分

    // 计算二进制中1的个数（使用内置函数提升效率）
    int popcount(int x) {
        return __builtin_popcount(x);
    }

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) cin >> a[i];

        // 枚举前15位x的可能值
        for (int x_high = 0; x_high < HALF; ++x_high) {
            int c1 = popcount((a[1] >> 15) ^ x_high); // a[1]前15位异或x_high的popcount
            vector<int> diff;
            for (int i = 2; i <= n; ++i) {
                int ci = popcount((a[i] >> 15) ^ x_high);
                diff.push_back(ci - c1); // 计算差异数组
            }
            mp[diff] = x_high; // 存储差异数组对应的x前半部分
        }

        // 枚举后15位x的可能值
        for (int x_low = 0; x_low < HALF; ++x_low) {
            int d1 = popcount((a[1] & (HALF - 1)) ^ x_low); // a[1]后15位异或x_low的popcount
            vector<int> target_diff;
            for (int i = 2; i <= n; ++i) {
                int di = popcount((a[i] & (HALF - 1)) ^ x_low);
                target_diff.push_back(d1 - di); // 构造目标差异数组（与前半部分互补）
            }
            if (mp.count(target_diff)) { // 找到匹配的差异数组
                int x = (mp[target_diff] << 15) | x_low; // 合并前后部分
                cout << x << endl;
                return 0;
            }
        }

        cout << -1 << endl; // 无解
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先枚举x的前15位（`x_high`），计算每个a_i前15位异或后的popcount差异数组，存入map。接着枚举x的后15位（`x_low`），计算后15位异或后的差异数组，若在map中找到匹配，则合并前后部分得到x。关键逻辑是通过差异数组的互补性，将全局相等问题转化为局部匹配问题。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：作者LittleMoMol**
* **亮点**：差异数组的构造逻辑清晰，代码注释详细，展示了折半搜索的完整流程。
* **核心代码片段**：
    ```cpp
    for (int x = 0; x < (1 << 15); x ++ ) {
        int c1 = get_cnt((a[1] >> 15) ^ x);
        vector<int> vec;
        for (int i = 2; i <= n; i ++ ) vec.push_back(get_cnt((a[i] >> 15) ^ x) - c1);
        mp[vec] = x;
    }
    ```
* **代码解读**：
    > 这段代码枚举x的前15位（`x`），计算a[1]前15位异或x的popcount（`c1`），然后遍历其他a[i]，计算其前15位异或x的popcount与c1的差值（`ci - c1`），存入vector`vec`。最后将`vec`作为键，x作为值存入map。这一步是折半搜索的前半部分，存储了所有可能的前15位差异数组。
* 💡 **学习笔记**：通过map存储差异数组，将前半部分的计算结果缓存，为后半部分的快速查询奠定基础。

**题解二：作者orpg**
* **亮点**：使用`__builtin_popcount`函数提升计算popcount的效率，代码简洁。
* **核心代码片段**：
    ```cpp
    int count(int val) {
        return __builtin_popcount(val);
    }
    ```
* **代码解读**：
    > `__builtin_popcount`是GCC内置函数，用于快速计算整数二进制中1的个数，时间复杂度为O(1)，比手动循环计算（如`val &= val - 1`）更高效。在本题中，由于需要频繁计算popcount，使用该函数能显著降低时间复杂度。
* 💡 **学习笔记**：合理使用内置函数（如`__builtin_popcount`、`__lg`）可以提升代码效率，尤其在竞赛中。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解折半搜索的过程，我们设计了一个8位像素风格的动画，模拟x的前15位和后15位枚举、差异数组匹配的过程。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的异或之旅`

  * **核心演示内容**：
    小探险家需要找到x的30位密码，将其拆分为前15位（红钥匙）和后15位（蓝钥匙）。前半段枚举红钥匙的所有可能，记录差异数组（存进宝箱）；后半段枚举蓝钥匙，计算差异数组，若在宝箱中找到匹配，则打开宝藏（输出x）。

  * **设计思路简述**：
    采用FC红白机风格的像素画面（8色调色板），用不同颜色的方块表示x的前/后15位。差异数组匹配时，宝箱发出金光，伴随“叮”的音效，强化关键步骤的记忆。小关卡（每枚举一个红/蓝钥匙）的完成用像素星星奖励，增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左半显示前15位枚举区（红钥匙），右半显示后15位枚举区（蓝钥匙）。
        - 底部控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。
        - 背景播放8位风格的轻快BGM（如《超级玛丽》主题变奏）。

    2.  **前15位枚举**：
        - 红钥匙从0开始递增（像素数字滚动），每个红钥匙对应一个差异数组（用彩色像素条表示，长度为差异值）。
        - 差异数组存入宝箱（像素宝箱打开，差异数组滑入），伴随“咔嚓”音效。

    3.  **后15位枚举**：
        - 蓝钥匙从0开始递增，每个蓝钥匙计算目标差异数组（绿色像素条）。
        - 当目标差异数组与宝箱中的某个数组匹配时，宝箱发出金光，红钥匙和蓝钥匙合并成完整的x（30位密码），伴随“胜利”音效（如《魂斗罗》的胜利旋律）。

    4.  **关键提示旁白**：
        - “看！红钥匙的差异数组存进宝箱了，现在轮到蓝钥匙啦～”
        - “绿色条和宝箱里的红色条一样！找到匹配的x啦！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到折半搜索如何将大问题拆分为小问题，以及差异数组的匹配过程，让抽象的算法变得“可见可感”。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
折半搜索不仅适用于本题，还能解决许多需要枚举但规模过大的问题。以下是一些拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    折半搜索适用于问题规模为2^k（k≤40）的情况，通过拆分问题为两部分，分别枚举并存储中间结果，最后合并匹配。例如：
    - 求子集和等于目标值（如P4799世界冰球锦标赛）。
    - 求多个集合的交集（如CF585D Lizard Era: Beginning）。
    - 求平衡子集（如P3067 Balanced Cow Subsets G）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4799** - `[CEOI2015 Day2] 世界冰球锦标赛`
          * 🗣️ **推荐理由**：折半搜索的经典模板题，适合练习如何拆分问题并存储中间结果。
    2.  **洛谷 CF585D** - `Lizard Era: Beginning`
          * 🗣️ **推荐理由**：折半搜索的进阶应用，需要处理多维度的差异数组，提升问题拆分能力。
    3.  **洛谷 P3067** - `[USACO 12 OPEN] Balanced Cow Subsets G`
          * 🗣️ **推荐理由**：结合折半搜索和集合匹配，练习如何将平衡条件转化为差异数组的匹配。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解分享了学习折半搜索的心得，以下是值得借鉴的经验：
</insights_intro>

> **参考经验 (来自LittleMoMol)**：“这是我折半搜索第一次学明白的题了，也是我第一道灰题！收~”
>
> **点评**：学习新算法时，通过具体题目实践能更快掌握。折半搜索的关键是理解“拆分-存储-匹配”的流程，多做类似题目（如推荐的P4799）能加深理解。遇到困难时，不要放弃，每道题都是提升的机会！

-----

<conclusion>
本次关于“Make Them Similar”的C++解题分析就到这里。通过折半搜索的思想，我们将大问题拆分为小问题，高效解决了x的枚举难题。希望这份指南能帮助大家掌握折半搜索的核心，并在类似问题中举一反三。编程的乐趣在于挑战，下次我们再一起探索新的算法！💪
</conclusion>

-----

---
处理用时：143.45秒
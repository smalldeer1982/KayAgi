# 题目信息

# Reachable Strings

## 题目描述

In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string $ s $ starting from the $ l $ -th character and ending with the $ r $ -th character as $ s[l \dots r] $ . The characters of each string are numbered from $ 1 $ .

We can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011.

Binary string $ a $ is considered reachable from binary string $ b $ if there exists a sequence $ s_1 $ , $ s_2 $ , ..., $ s_k $ such that $ s_1 = a $ , $ s_k = b $ , and for every $ i \in [1, k - 1] $ , $ s_i $ can be transformed into $ s_{i + 1} $ using exactly one operation. Note that $ k $ can be equal to $ 1 $ , i. e., every string is reachable from itself.

You are given a string $ t $ and $ q $ queries to it. Each query consists of three integers $ l_1 $ , $ l_2 $ and $ len $ . To answer each query, you have to determine whether $ t[l_1 \dots l_1 + len - 1] $ is reachable from $ t[l_2 \dots l_2 + len - 1] $ .

## 样例 #1

### 输入

```
5
11011
3
1 3 3
1 4 2
1 2 3```

### 输出

```
Yes
Yes
No```

# AI分析结果

---
# 💡 Kay的C++算法解析：Reachable Strings 深入学习指南 💡

<introduction>
今天我们来一起分析“Reachable Strings”这道C++编程题。这道题的关键在于理解二进制字符串的变换规则，并通过巧妙的哈希技巧快速判断两个子串是否可达。本指南将帮助大家梳理思路，掌握核心算法，并通过像素动画直观理解过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（哈希的高效应用）

🗣️ **初步分析**：  
解决这道题的关键在于观察变换操作的本质——每次将`0`左右移动两位（如`011→110`相当于`0`右移两位，`110→011`相当于`0`左移两位）。这一操作有两个重要性质：  
1. `0`的相对顺序不变（无法跨越其他`0`）；  
2. 每个`0`的下标奇偶性不变（移动两位不改变奇偶性）。  

因此，两个子串可达的充要条件是：它们的`0`的数量相同，且每个对应位置的`0`的下标奇偶性一致。为了高效判断这一点，我们可以用**哈希**将`0`的奇偶性序列转化为唯一值，通过比较哈希值快速判断是否可达。  

核心难点在于如何设计哈希函数，同时处理子串起始位置奇偶性的影响（例如，子串起始位置为奇数时，`0`的奇偶性需要重新计算相对奇偶性）。优质题解通常会预处理两种哈希（基于起始位置的奇偶性），查询时根据子串起始位置选择对应的哈希值比较。  

可视化设计上，我们可以用8位像素风格展示`0`的移动过程：用绿色方块表示`0`，黄色方块表示`1`，当`0`移动两位时，播放“叮”的音效；用不同颜色高亮奇偶性（奇数红，偶数蓝），并在屏幕侧边同步显示哈希值的生成过程，帮助理解哈希如何记录奇偶性序列。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解（≥4星）：
</eval_intro>

**题解一：作者George1123**  
* **点评**：此题解思路清晰，直接抓住`0`的奇偶性不变这一核心，通过预处理两种哈希数组（起始奇偶性不同）解决子串比较问题。代码变量命名规范（如`ze[]`记录前缀0的数量），哈希计算简洁高效（使用质数进制和模运算），边界处理严谨（如取模时加`mod`避免负数）。其亮点在于通过两个哈希数组灵活处理子串起始奇偶性的影响，代码可直接用于竞赛，实践价值高。

**题解二：作者legend_life**  
* **点评**：此题解逻辑直白，明确指出“两个子串可达当且仅当`0`的数量相同且对应`0`的奇偶性一致”，并通过双哈希（不同基数和模数）降低冲突概率。代码结构工整（预处理哈希、查询时比较哈希值），变量名如`has[2][MAXN]`清晰表示两种哈希数组，易于理解。其亮点是双哈希的应用，提高了哈希的可靠性，适合作为学习哈希技巧的范例。

**题解三：作者灵梦**  
* **点评**：此题解巧妙利用随机基数（`BASE=rng()%19260817+3`）降低哈希冲突概率，代码简洁高效。预处理部分将`0`的奇偶性直接编码到哈希值中（`(i&1)+1`和`(i&1^1)+1`），查询时根据子串起始奇偶性选择哈希数组，逻辑清晰。其亮点是随机基数的使用，体现了哈希设计的灵活性，对竞赛中的哈希优化有启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点主要集中在以下三个方面，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何发现`0`的移动规律？**  
    * **分析**：观察操作`011↔110`，发现`0`每次移动两位，因此其下标奇偶性不变（如原下标为3，移动后为1或5，奇偶性仍为奇）。同时，`0`无法跨越其他`0`（否则需要移动奇数位，改变奇偶性），因此`0`的相对顺序不变。优质题解通过观察操作的本质，快速抓住这一规律。  
    * 💡 **学习笔记**：遇到字符串变换问题时，先分析单次操作对字符位置的影响（如移动位数、奇偶性变化），再推导整体规律。

2.  **关键点2：如何设计哈希函数记录`0`的奇偶性？**  
    * **分析**：需要将`0`的奇偶性序列转化为唯一哈希值。优质题解通常使用质数进制（如`base=5119`），每个`0`的奇偶性作为一位（奇数为1，偶数为2），通过前缀哈希数组快速计算子串哈希。同时，考虑子串起始位置的奇偶性（如起始为奇数时，`0`的相对奇偶性可能翻转），因此预处理两种哈希数组。  
    * 💡 **学习笔记**：哈希设计需考虑数据特征（如本题的奇偶性序列），并通过多哈希或随机基数降低冲突概率。

3.  **关键点3：如何处理子串起始位置的奇偶性影响？**  
    * **分析**：子串的起始位置为奇数或偶数时，`0`的相对下标奇偶性可能与原字符串不同（如原下标为3，子串起始为2，则相对下标为1，奇偶性翻转）。优质题解通过预处理两种哈希数组（`h[0]`和`h[1]`），分别对应子串起始为奇数/偶数时的奇偶性序列，查询时根据子串起始位置选择对应的哈希数组。  
    * 💡 **学习笔记**：当问题涉及相对位置的奇偶性时，预处理不同情况的哈希数组是高效解决方法。

### ✨ 解题技巧总结
- **问题抽象**：将复杂的字符串变换问题抽象为`0`的奇偶性序列比较问题，简化问题。  
- **哈希预处理**：通过前缀哈希数组快速计算子串哈希值，将O(n)的比较操作优化为O(1)。  
- **多情况处理**：预处理不同起始奇偶性的哈希数组，灵活应对子串的位置变化。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解的思路，提炼出一个通用的核心实现，帮助大家快速掌握完整解题框架。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了George1123和legend_life的题解思路，预处理两种哈希数组（基于子串起始奇偶性），查询时比较对应哈希值。代码简洁高效，适合竞赛使用。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 2e5 + 10;
    const int MOD = 998244353;
    const int BASE = 5119;

    char s[N];
    int n, q;
    int cnt0[N]; // 前缀0的数量
    int h[2][N]; // h[0]：子串起始为奇数时的哈希；h[1]：起始为偶数时的哈希
    int pow_base[N]; // BASE的幂次预处理

    int main() {
        scanf("%d%s", &n, s + 1);
        pow_base[0] = 1;
        for (int i = 1; i <= n; ++i) {
            pow_base[i] = 1LL * pow_base[i - 1] * BASE % MOD;
        }

        for (int i = 1; i <= n; ++i) {
            cnt0[i] = cnt0[i - 1];
            h[0][i] = h[0][i - 1];
            h[1][i] = h[1][i - 1];
            if (s[i] == '0') {
                cnt0[i]++;
                int parity = i & 1; // 原下标奇偶性（0为偶，1为奇）
                h[0][i] = (1LL * h[0][i - 1] * BASE + (parity + 1)) % MOD; // 起始为奇数时，原奇偶性+1
                h[1][i] = (1LL * h[1][i - 1] * BASE + ((parity ^ 1) + 1)) % MOD; // 起始为偶数时，奇偶性翻转+1
            }
        }

        scanf("%d", &q);
        while (q--) {
            int l1, l2, len;
            scanf("%d%d%d", &l1, &l2, &len);
            int r1 = l1 + len - 1;
            int r2 = l2 + len - 1;

            // 检查0的数量是否相同
            if (cnt0[r1] - cnt0[l1 - 1] != cnt0[r2] - cnt0[l2 - 1]) {
                puts("No");
                continue;
            }

            // 计算子串哈希值（根据起始位置的奇偶性选择哈希数组）
            int o1 = l1 & 1;
            int o2 = l2 & 1;
            int num0 = cnt0[r1] - cnt0[l1 - 1];
            int hash1 = (h[o1][r1] - 1LL * h[o1][l1 - 1] * pow_base[num0] % MOD + MOD) % MOD;
            int hash2 = (h[o2][r2] - 1LL * h[o2][l2 - 1] * pow_base[num0] % MOD + MOD) % MOD;

            puts(hash1 == hash2 ? "Yes" : "No");
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理`cnt0`数组记录前缀0的数量，`h[0]`和`h[1]`数组分别记录子串起始为奇数/偶数时的哈希值。查询时，先检查0的数量是否相同，再根据子串起始位置的奇偶性选择对应的哈希数组，计算子串哈希值并比较。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解其巧妙之处：
</code_intro_selected>

**题解一：作者George1123**  
* **亮点**：使用单哈希（模数`998244353`）和质数进制（`base=5119`），代码简洁高效。  
* **核心代码片段**：
    ```cpp
    il int Hash(re int l,re int r,re int o){
        return (-1ll*h[l-1][o]*bs[ze[r]-ze[l-1]]%mod + h[r][o] + mod)%mod;
    }
    ```
* **代码解读**：  
  这段代码计算子串`[l, r]`的哈希值，`o`表示子串起始位置的奇偶性（0为偶，1为奇）。`ze[r]-ze[l-1]`是子串中0的数量，`bs`是`base`的幂次数组。通过前缀哈希相减并乘以`base`的幂次，得到子串的哈希值。例如，若子串有3个0，`h[r][o]`是前`r`个0的哈希，`h[l-1][o]`是前`l-1`个0的哈希，乘以`base^3`后相减，得到子串的哈希。  
* 💡 **学习笔记**：前缀哈希的计算是哈希子串的核心，通过`前缀和-前缀和*base^长度`可以快速得到子串哈希。

**题解二：作者legend_life**  
* **亮点**：使用双哈希（两个不同的基数和模数），降低哈希冲突概率。  
* **核心代码片段**：
    ```cpp
    ll query(int l, int r, int op) {
        return ((has[op][r] - has[op][l - 1] * pw[cnt[r] - cnt[l - 1]]) % MOD + MOD) % MOD;
    }
    ```
* **代码解读**：  
  这段代码是双哈希的查询函数，`op`表示选择哪种哈希数组（0或1）。`has[op][r]`是前`r`个字符的哈希，`has[op][l-1]`是前`l-1`个字符的哈希，`pw`是基数的幂次数组。通过双哈希，即使一个哈希冲突，另一个也能正确判断，提高了可靠性。  
* 💡 **学习笔记**：双哈希是竞赛中常用的防冲突技巧，适合对正确性要求高的场景。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了更直观地理解哈希如何记录`0`的奇偶性，我们设计一个“像素0探险”的8位复古动画，让大家“看”到哈希的生成和比较过程！
\</visualization_intro\>

  * **动画演示主题**：像素0的奇偶探险  
  * **核心演示内容**：展示`0`在字符串中的移动过程，以及哈希如何记录其奇偶性序列。例如，当子串起始位置为奇数时，`0`的相对奇偶性翻转，哈希值同步变化。  

  * **设计思路简述**：  
    采用FC红白机风格（8色调色板，像素方块），用绿色方块表示`0`，黄色方块表示`1`。关键操作（如`0`移动两位）播放“叮”的音效，哈希值变化时用数字滚动效果展示。通过单步执行和自动播放，清晰展示哈希的生成逻辑。

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 屏幕左侧显示原始字符串（像素方块排列），右侧显示哈希值生成区（数字滚动条）。  
        - 控制面板包含“单步”、“自动播放”、“重置”按钮和速度滑块（1-5倍速）。  
        - 播放8位风格背景音乐（如《超级玛丽》主题变奏）。  

    2.  **0的移动演示**：  
        - 选中一个`0`（绿色方块），点击“单步”，它向左/右移动两位（如从位置3→1或5），伴随“叮”的音效。  
        - 移动后，该`0`的奇偶性标签（红/蓝文字）保持不变（如位置3→1，奇偶性仍为奇）。  

    3.  **哈希生成过程**：  
        - 预处理阶段：遍历字符串，每个`0`出现时，在哈希生成区添加一位（奇数为1，偶数为2），数字逐个滚动显示。  
        - 查询阶段：输入子串范围，哈希生成区自动计算子串的哈希值（数字快速滚动后定格），并与另一个子串的哈希值比较，相同则显示“√”，不同则显示“×”。  

    4.  **奇偶性翻转演示**：  
        - 当子串起始位置为奇数时，所有`0`的相对奇偶性翻转（如原位置3→相对位置1，奇偶性从奇变奇？不，原位置3，子串起始为2，相对位置1→奇；原位置4，子串起始为2，相对位置2→偶。此处需准确演示）。  
        - 哈希生成区切换为另一种哈希数组（如从`h[0]`切换为`h[1]`），数字重新滚动生成新的哈希值。  

    5.  **目标达成反馈**：  
        - 若两个子串的哈希值相同，播放“胜利”音效（如《超级玛丽》吃金币音），绿色方块闪烁庆祝。  
        - 若不同，播放“失败”音效（短促“滴”声），红色警告文字提示“哈希不匹配”。  

  * **旁白提示**：  
    - “看！这个`0`移动了两位，它的奇偶性（红/蓝标签）没变哦～”  
    - “哈希值就像给`0`的奇偶性序列编了个‘身份证号’，相同的身份证号说明两个子串可达！”  

\<visualization_conclusion\>
通过这个像素动画，我们不仅能看到`0`的移动规律，还能直观理解哈希如何高效比较奇偶性序列。下次遇到类似问题，你也能快速想到用哈希解决啦！
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
本题的核心是通过观察操作规律，将问题转化为哈希比较。这种思路还适用于其他字符串变换问题，我们可以通过以下练习巩固：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    哈希不仅能处理`0`的奇偶性序列，还可用于其他需要快速比较子串特征的问题，例如：  
    - 回文子串判断（哈希正反序字符串）；  
    - DNA序列相似性比较（哈希记录碱基特征）；  
    - 字符串循环同构判断（哈希记录所有循环移位的最小值）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3370** - 字符串哈希  
        * 🗣️ **推荐理由**：经典哈希模板题，帮助巩固哈希的基本应用。  
    2.  **洛谷 P5270** - 字符串问题  
        * 🗣️ **推荐理由**：涉及字符串变换和哈希比较，与本题思路类似，适合拓展练习。  
    3.  **洛谷 P4391** - [BOI2009]Radio Transmission  
        * 🗣️ **推荐理由**：需要观察字符串循环节规律，并用哈希快速判断，锻炼问题抽象能力。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试哈希冲突的经验，这些经验对我们很有帮助：
\</insights_intro\>

> **参考经验 (来自作者George1123)**：“刚开始用单哈希时，遇到了哈希冲突（不同序列哈希值相同），后来改用双哈希（两个不同的模数和基数），冲突概率大大降低。”  

**点评**：George的经验提醒我们，哈希虽然高效，但存在冲突风险。在竞赛中，使用双哈希（或多哈希）是常见的防冲突技巧，尤其是在数据规模大时（如本题的`n,q=1e5`）。这对我们处理哈希问题时的健壮性有很大启发。

---

\<conclusion\>
本次关于“Reachable Strings”的分析就到这里。通过理解`0`的移动规律和哈希的巧妙应用，我们不仅解决了这道题，还掌握了一种重要的解题思路。记住，遇到字符串变换问题时，先观察操作对字符的影响，再抽象为特征比较问题，哈希往往是高效的解决方案！下次见～💪
\</conclusion\>

---
处理用时：151.20秒
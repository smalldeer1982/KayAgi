# 题目信息

# The Maximum Prefix

## 题目描述

You're going to generate an array $ a $ with a length of at most $ n $ , where each $ a_{i} $ equals either $ 1 $ or $ -1 $ .

You generate this array in the following way.

- First, you choose some integer $ k $ ( $ 1\le k \le n $ ), which decides the length of $ a $ .
- Then, for each $ i $ ( $ 1\le i \le k $ ), you set $ a_{i} = 1 $ with probability $ p_{i} $ , otherwise set $ a_{i} = -1 $ (with probability $ 1 - p_{i} $ ).

After the array is generated, you calculate $ s_{i} = a_{1} + a_{2} + a_{3}+ \ldots + a_{i} $ . Specially, $ s_{0} = 0 $ . Then you let $ S $ equal to $ \displaystyle \max_{i=0}^{k}{s_{i}} $ . That is, $ S $ is the maximum prefix sum of the array $ a $ .

You are given $ n+1 $ integers $ h_{0} , h_{1}, \ldots ,h_{n} $ . The score of an array $ a $ with maximum prefix sum $ S $ is $ h_{S} $ . Now, for each $ k $ , you want to know the expected score for an array of length $ k $ modulo $ 10^9+7 $ .

## 说明/提示

In the first test case, if we choose $ k=1 $ , there are $ 2 $ possible arrays with equal probabilities: $ [1] $ and $ [-1] $ . The $ S $ values for them are $ 1 $ and $ 0 $ . So the expected score is $ \frac{1}{2}h_{0} + \frac{1}{2}h_{1} = \frac{3}{2} $ . If we choose $ k=2 $ , there are $ 4 $ possible arrays with equal probabilities: $ [1,1] $ , $ [1,-1] $ , $ [-1,1] $ , $ [-1,-1] $ , and the $ S $ values for them are $ 2,1,0,0 $ . So the expected score is $ \frac{1}{2}h_{0} + \frac{1}{4}h_{1} + \frac{1}{4}h_{2} = \frac{7}{4} $ .

In the second test case, no matter what the $ S $ value is, the score is always $ 1 $ , so the expected score is always $ 1 $ .

## 样例 #1

### 输入

```
4
2
1 2
1 2
1 2 3
3
1 3
1 4
5 5
1 1 1 1
3
2 5
4 6
0 2
4 3 2 1
5
5 6
5 7
1 6
1 3
4 7
9 0 4 5 2 4```

### 输出

```
500000005 750000007 
1 1 1 
200000005 333333339 333333339 
500000005 880952391 801587311 781746041 789304620```

# AI分析结果

---
# 💡 Kay的C++算法解析：The Maximum Prefix 深入学习指南 💡

<introduction>
今天我们来一起分析“[The Maximum Prefix]”这道C++编程题。本指南将帮助大家梳理题目核心，理解动态规划（DP）的巧妙应用，并掌握反向状态设计等关键技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划(DP)` (状态设计与反向转移优化)

🗣️ **初步分析**：
> 解决这道题的关键在于如何高效计算不同长度数组的最大前缀和期望。题目要求对每个长度k（1≤k≤n），计算生成数组的最大前缀和S对应的期望得分h[S]。直接正向枚举所有可能数组的复杂度是指数级的，显然不可行。  
> 动态规划（DP）是解决这类期望问题的常用方法。简单来说，DP就像“拆问题”——把大问题拆成小问题，用小问题的解组合成大问题的解。本题中，我们需要设计一个状态，能高效表示“当前处理到某个位置时，最大前缀和的状态”，并通过状态转移逐步计算期望。  
> 题解中普遍采用**反向DP**技巧：从数组末尾向前推导，利用最大前缀和的性质（即新增一个元素时，最大前缀和仅与当前元素和后续数组的最大前缀和有关）。例如，若后续数组的最大前缀和为j，当前元素选1时，新的最大前缀和为j+1；选-1时，新的最大前缀和为max(j-1, 0)。这种设计将状态数从O(n³)降至O(n²)。  
> **可视化设计思路**：我们将用8位像素风动画演示反向DP过程。每个状态(i,j)用一个像素方块表示（i为当前处理位置，j为最大前缀和），颜色随j值变化（如j=0为蓝色，j=1为绿色）。转移时，方块会根据选1或选-1的概率（p_i或1-p_i）分裂成两个新方块，分别移动到(i-1,j+1)和(i-1,max(j-1,0))的位置，并播放“叮”的音效。动画支持单步/自动播放，同步显示当前状态对应的C++代码片段，帮助直观理解状态转移。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下3篇题解因逻辑清晰、优化到位且代码易读，被选为优质参考（均≥4星）。
</eval_intro>

**题解一：作者EuphoricStar（赞31）**
* **点评**：此题解精准抓住了“反向DP”的核心，通过定义状态g[i][j]为“处理到第i个位置时，后续数组最大前缀和为j的期望贡献系数”，将时间复杂度从O(n³)优化至O(n²)。代码结构简洁，关键变量命名直观（如g[i][j]），边界处理（max(j-1,0)）严谨。特别值得学习的是“反推贡献系数”的思路——将问题转化为“贡献如何从后向前传递”，这是解决多阶段期望问题的常见技巧。

**题解二：作者Ecrade_（赞26）**
* **点评**：此题解从“钦定最大前缀和x”的角度出发，定义状态f[i][j][o]表示“前i个元素，当前前缀和离x差j，是否已达到x”的期望得分。状态设计直观，转移逻辑明确（分选1或-1两种情况），代码中通过位运算（o | (!j)）简化状态更新，体现了良好的编程技巧。虽然状态维度多一维（是否达到x），但通过合理剪枝（j≤n）仍保持了O(n²)的复杂度，适合新手理解最大前缀和的约束条件。

**题解三：作者Schi2oid（赞9）**
* **点评**：此题解系统梳理了“反转DP”的思路，通过博客链接补充了推导细节，适合深入理解。代码中明确注释了状态定义（g[i][j]表示“处理到第i个位置，后续数组最大前缀和为j的期望得分”），转移方程与数学推导严格对应（p_i*g[i-1][j+1] + (1-p_i)*g[i-1][max(j-1,0)]），边界处理（j=0时的max操作）尤为清晰。其“正难则反”的思维方式对解决类似前缀和问题有重要启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于突破以下核心难点，掌握动态规划的状态设计与反向转移技巧：
</difficulty_intro>

1.  **关键点1：如何定义状态以表示最大前缀和？**
    * **分析**：最大前缀和S的计算需要同时跟踪当前前缀和与历史最大值，直接正向定义状态会导致维度爆炸（如需要记录当前前缀和s和最大值mx）。反向DP利用“新增元素对后续最大前缀和的影响”，将状态简化为“处理到位置i时，后续数组的最大前缀和为j”（即g[i][j]），仅需两维状态即可覆盖所有可能。
    * 💡 **学习笔记**：反向DP的核心是“从后往前看”，利用问题的“无后效性”（后续状态不影响当前决策）简化状态设计。

2.  **关键点2：如何设计状态转移方程？**
    * **分析**：状态转移需考虑当前元素选1或选-1的概率。若后续数组的最大前缀和为j，当前元素选1时，新的最大前缀和为j+1（概率p_i）；选-1时，新的最大前缀和为max(j-1, 0)（概率1-p_i）。转移方程为：g[i][j] = p_i * g[i-1][j+1] + (1-p_i) * g[i-1][max(j-1,0)]。
    * 💡 **学习笔记**：转移方程的设计需严格对应问题的概率模型，确保每个状态的贡献被正确加权。

3.  **关键点3：如何处理边界条件（如max(j-1,0)）？**
    * **分析**：当j=0时，选-1会导致后续最大前缀和为max(-1,0)=0（因为前缀和不能为负）。因此，转移时需用max函数确保状态j非负。这一步是避免状态错误的关键，直接影响最终结果的正确性。
    * 💡 **学习笔记**：边界条件的处理需结合问题实际意义（如前缀和的非负性），确保状态定义的合理性。

### ✨ 解题技巧总结
<summary_best_practices>
- **反向状态设计**：当正向处理状态维度过高时，尝试从问题末尾反向推导，利用“后续状态对当前的影响”简化状态。
- **概率加权转移**：期望问题中，每个状态的转移需乘以对应事件的概率，确保贡献正确累加。
- **边界条件验证**：通过小例子（如样例输入）手动验证转移方程的正确性，特别是max等边界操作。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，采用反向DP，状态定义清晰，时间复杂度O(n²)。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了EuphoricStar和Schi2oid的反向DP思路，通过状态g[i][j]表示处理到第i个位置时，后续数组最大前缀和为j的期望得分。代码简洁高效，适合直接用于竞赛。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;
    const int MAXN = 5005;

    int qpow(int x, int y) {
        int res = 1;
        while (y) {
            if (y & 1) res = (ll)res * x % MOD;
            x = (ll)x * x % MOD;
            y >>= 1;
        }
        return res;
    }

    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            int n;
            scanf("%d", &n);
            vector<int> p(n + 1); // p[i] 表示选1的概率（模意义下）
            for (int i = 1; i <= n; ++i) {
                int a, b;
                scanf("%d%d", &a, &b);
                p[i] = (ll)a * qpow(b, MOD - 2) % MOD;
            }
            vector<int> h(n + 1);
            for (int i = 0; i <= n; ++i) {
                scanf("%d", &h[i]);
            }
            // 初始化DP数组：g[0][j] = h[j]（处理完0个位置，后续最大前缀和为j的得分）
            vector<vector<int>> g(n + 1, vector<int>(n + 2, 0));
            for (int j = 0; j <= n; ++j) {
                g[0][j] = h[j];
            }
            // 反向DP转移
            for (int i = 1; i <= n; ++i) {
                for (int j = 0; j <= n; ++j) {
                    // 选1的情况：后续最大前缀和为j+1（若j+1<=n）
                    int term1 = (j + 1 <= n) ? (ll)p[i] * g[i - 1][j + 1] % MOD : 0;
                    // 选-1的情况：后续最大前缀和为max(j-1, 0)
                    int prev_j = max(j - 1, 0);
                    int term2 = (ll)(1 - p[i] + MOD) * g[i - 1][prev_j] % MOD;
                    g[i][j] = (term1 + term2) % MOD;
                }
                // 长度为i的答案是g[i][0]（处理完i个位置，后续最大前缀和为0的得分）
                printf("%d ", g[i][0]);
            }
            printf("\n");
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并预处理概率p[i]（转换为模意义下的分数），然后初始化DP数组g[0][j] = h[j]（表示处理0个元素时，最大前缀和为j的得分）。通过反向遍历每个位置i（从1到n），计算每个状态j的转移：选1时贡献p[i] * g[i-1][j+1]，选-1时贡献(1-p[i]) * g[i-1][max(j-1,0)]。最终，长度为i的答案即为g[i][0]。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其设计亮点。
</code_intro_selected>

**题解一：作者EuphoricStar**
* **亮点**：反向DP的经典实现，状态定义简洁，转移方程直接对应数学推导。
* **核心代码片段**：
    ```cpp
    // 初始化g[0][i] = h[i]
    for (int i = 0; i <= n; i++) g[0][i] = h[i];
    // 反向DP转移
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            g[i][j] = (p[i] * g[i - 1][j + 1] % mod + (1 - p[i] + mod) * g[i - 1][max(j - 1, 0)] % mod) % mod;
        }
        printf("%d ", g[i][0]);
    }
    ```
* **代码解读**：
    > 这段代码的核心是反向DP的转移过程。`g[i][j]`表示处理到第i个位置时，后续数组最大前缀和为j的期望得分。对于每个i，遍历所有可能的j（0到n），分别计算选1和选-1的贡献：选1时，后续最大前缀和变为j+1（对应`g[i-1][j+1]`），概率为p[i]；选-1时，后续最大前缀和变为max(j-1,0)（对应`g[i-1][max(j-1,0)]`），概率为1-p[i]。最终，长度为i的答案是`g[i][0]`，即处理完i个位置后，后续最大前缀和为0的得分。
* 💡 **学习笔记**：反向DP的关键是状态定义的“后效性”——当前状态仅依赖后续状态，这使得转移可以从后向前逐步计算。

**题解二：作者Ecrade_**
* **亮点**：通过三维状态（是否已达到目标x）明确约束最大前缀和的条件，适合理解最大前缀和的“首次达到”逻辑。
* **核心代码片段**：
    ```cpp
    // 初始化：f[0][i][!i] = h[i]（前0个元素，离目标差i，是否达到目标）
    for (int i = 0; i <= n; i++) f[0][i][!i] = h[i];
    // 正向DP转移
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            // 选1的情况：离目标差j+1（未达到时）或保持（已达到时）
            if (j < n) add(f[i][j][o | (!j)], (ll)f[i-1][j+1][o] * p[i] % mod);
            // 选-1的情况：离目标差j-1（未达到时）或保持（已达到时）
            if (j > 0) add(f[i][j][o | (!j)], (ll)f[i-1][j-1][o] * (mod + 1 - p[i]) % mod);
        }
    }
    ```
* **代码解读**：
    > 这段代码中，`f[i][j][o]`表示前i个元素，当前前缀和离目标x差j，是否已达到x（o=1表示已达到）。转移时，选1会使离目标差增加1（j+1），选-1会使离目标差减少1（j-1）。通过`o | (!j)`（当j=0时，!j=1，表示达到目标）更新是否已达到目标的状态。最终，长度为i的答案是所有已达到目标的状态之和（`sum f[i][j][1]`）。
* 💡 **学习笔记**：多维状态设计需明确各维度的物理意义，避免状态冗余或遗漏。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解反向DP的状态转移过程，我们设计一个“像素探险家”主题的8位像素动画，模拟g[i][j]的转移过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家的前缀和冒险`

  * **核心演示内容**：演示从i=0到i=n的反向DP过程，每个状态(i,j)用一个像素方块表示，颜色随j值变化（j=0:蓝色，j=1:绿色，j=2:黄色，...），动态展示选1（绿色箭头）和选-1（红色箭头）时的状态转移。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），通过颜色区分状态j，箭头动画表示转移方向，音效强化操作记忆。例如，选1时绿色箭头从(i-1,j+1)指向(i,j)，伴随“叮”声；选-1时红色箭头从(i-1,max(j-1,0))指向(i,j)，伴随“嗒”声。动画支持单步/自动播放，同步显示当前状态对应的C++代码行（如`g[i][j] = p[i] * g[i-1][j+1] + (1-p[i]) * g[i-1][max(j-1,0)]`），帮助理解代码与状态转移的对应关系。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是DP状态网格（i从0到n，j从0到n），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块）。
        - 初始时，i=0的行（j=0到n）的像素方块颜色根据h[j]值设置（如h[j]越大，颜色越亮）。

    2.  **状态转移演示**：
        - 点击“开始”，动画从i=1开始，逐行计算g[i][j]。
        - 对于每个j，先高亮(i-1,j+1)的方块（绿色），播放“叮”声，表示选1的贡献（p[i] * g[i-1][j+1]）；然后高亮(i-1,max(j-1,0))的方块（红色），播放“嗒”声，表示选-1的贡献（(1-p[i]) * g[i-1][max(j-1,0)]）。
        - 两个贡献值相加后，(i,j)的方块颜色更新为新的g[i][j]值（颜色亮度反映数值大小）。

    3.  **目标达成提示**：
        - 当计算到i=k时，(k,0)的方块闪烁金色，播放“胜利”音效，表示长度为k的答案（g[k][0]）已计算完成。

    4.  **交互控制**：
        - 单步模式：点击“单步”按钮，逐行计算g[i][j]，适合仔细观察每个转移步骤。
        - 自动播放：通过速度滑块调整播放速度（如0.5倍速到2倍速），适合整体观察转移规律。
        - 重置按钮：重置所有状态，回到i=0的初始状态。

  * **旁白提示**：
      - （i=1时）“现在处理i=1，j=0的状态。选1时，贡献来自i=0，j=1的绿色方块；选-1时，贡献来自i=0，j=0的蓝色方块（因为max(0-1,0)=0）。”
      - （i=k时）“看！(k,0)的金色方块就是长度为k的答案，它综合了前面所有状态的贡献。”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到反向DP如何通过状态转移逐步计算出每个k的期望得分，理解“贡献从后向前传递”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的反向DP和状态设计技巧在处理前缀和、期望问题中非常通用，以下是一些拓展练习建议：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 前缀和问题：如“最长有效括号子串”（需要跟踪前缀和的最大/最小值）。
      - 期望问题：如“掷骰子的期望步数”（需要设计状态表示当前进度）。
      - 多阶段决策问题：如“股票买卖的最佳时机”（需要跟踪持有/未持有状态）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1851 [IOI1998] 气球汽艇**  
        🗣️ **推荐理由**：考察动态规划的状态设计，需要跟踪当前位置和剩余燃料，与本题的状态转移思想类似。
    2.  **洛谷 P1077 [NOIP2012 提高组] 摆花**  
        🗣️ **推荐理由**：通过动态规划计算组合数，状态设计需考虑前i种花摆j盆的方案数，适合练习状态转移方程的推导。
    3.  **洛谷 P1877 [HAOI2012] 音量调节**  
        🗣️ **推荐理由**：状态设计为前i首歌后音量为j的可能性，与本题的“状态表示当前进度”思路一致。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是有价值的参考：
</insights_intro>

> **参考经验 (来自作者EuphoricStar)**：“在实现反向DP时，最初忘记处理max(j-1,0)的边界条件，导致样例计算错误。后来通过手动模拟小例子（如k=1和k=2的情况），发现当j=0时选-1的转移应指向j=0而非j=-1，这才修正了错误。”
>
> **点评**：这位作者的经验提醒我们，边界条件的处理是DP问题的关键。手动模拟小例子（如题目中的样例输入）是验证状态转移正确性的有效方法。在编码后，建议用样例输入测试，确保每个状态的转移符合预期。

-----

<conclusion>
本次关于“The Maximum Prefix”的C++解题分析就到这里。通过理解反向DP的状态设计和转移逻辑，掌握动态规划的核心技巧，相信大家能更自信地解决类似问题。记住，多动手模拟小例子、多思考状态定义的合理性，是提升DP能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：156.55秒
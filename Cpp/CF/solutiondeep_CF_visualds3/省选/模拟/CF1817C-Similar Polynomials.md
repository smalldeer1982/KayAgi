# 题目信息

# Similar Polynomials

## 题目描述

A polynomial $A(x)$ of degree $d$ is an expression of the form $A(x) = a_0 + a_1 x + a_2 x^2 + \dots + a_d x^d$, where $a_i$ are integers, and $a_d \neq 0$. Two polynomials $A(x)$ and $B(x)$ are called similar if there is an integer $s$ such that for any integer $x$ it holds that

$$
B(x) \equiv A(x+s) \pmod{10^9+7}.
$$

For two similar polynomials $A(x)$ and $B(x)$ of degree $d$, you're given their values in the points $x=0,1,\dots, d$ modulo $10^9+7$.

Find a value $s$ such that $B(x) \equiv A(x+s) \pmod{10^9+7}$ for all integers $x$.

## 说明/提示

**Note**

In the first example, $A(x) \equiv x-1 \pmod{10^9+7}$ and $B(x)\equiv x+2 \pmod{10^9+7}$. They're similar because

$$
B(x) \equiv A(x+3) \pmod{10^9+7}.
$$

In the second example, $A(x) \equiv (x+1)^2 \pmod{10^9+7}$ and $B(x) \equiv (x+10)^2 \pmod{10^9+7}$, hence

$$
B(x) \equiv A(x+9) \pmod{10^9+7}.
$$

## 样例 #1

### 输入

```
1
1000000006 0
2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
2
1 4 9
100 121 144```

### 输出

```
9```

# AI分析结果

---
# 💡 Kay的C++算法解析：Similar Polynomials 深入学习指南 💡

<introduction>
今天我们来一起分析“Similar Polynomials”这道C++编程题。题目要求我们找到一个整数 \( s \)，使得多项式 \( B(x) \) 等于 \( A(x+s) \) 模 \( 10^9+7 \)。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（多项式操作与差分降次）`

🗣️ **初步分析**：
解决这道题的关键在于利用多项式的数学性质，通过给定的点值（\( x=0,1,\dots,d \) 处的取值）快速推导出 \( s \)。简单来说，多项式的高次项系数和差分操作是核心工具——高次项系数（如 \( x^d \) 和 \( x^{d-1} \) 项）能直接关联 \( s \)，而差分操作则能通过降次简化问题。

- **题解思路对比**：  
  题解主要分为两类：  
  1. **拉格朗日插值法**：通过插值公式从点值恢复多项式的 \( x^d \) 和 \( x^{d-1} \) 项系数，利用系数关系 \( b_{d-1} = d \cdot a_d \cdot s + a_{d-1} \) 解 \( s \)。  
  2. **差分降次法**：对多项式点值进行 \( d-1 \) 次差分，将 \( d \) 次多项式降为一次函数（直线），利用直线的斜率和截距关系求 \( s \)。  

- **核心算法流程**：  
  拉格朗日插值的核心是计算 \( x^d \) 和 \( x^{d-1} \) 项的系数，这需要预处理阶乘逆元，通过组合数公式求和。差分法的核心是通过 \( d-1 \) 次差分将问题转化为一次函数的斜率计算。  

- **可视化设计思路**：  
  计划采用8位像素风动画，用网格展示点值（如 \( x=0 \) 到 \( d \) 的方块），用颜色区分 \( A \) 和 \( B \) 的点值。动画将演示拉格朗日插值中系数的计算过程（如组合数的累加），或差分操作的逐层降次（如每次差分后点值的变化）。关键步骤（如计算 \( x^d \) 系数时的累加）会用闪烁高亮，音效在每次差分或系数更新时播放“叮”声，完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（≥4星）：
</eval_intro>

**题解一：作者Fido_Puppy（来源：Codeforces）**  
* **点评**：  
  此题解逻辑推导清晰，从多项式展开式出发，推导出 \( x^{d-1} \) 项系数与 \( s \) 的直接关系，避免了全插值的高复杂度。代码虽未直接给出，但通过数学推导明确了关键系数的计算方法，对理解问题本质有极大帮助。亮点在于抓住了“高次项系数”这一核心，简化了问题。

**题解二：作者Alex_Wei（来源：Codeforces）**  
* **点评**：  
  此题解巧妙利用差分降次的思想，将 \( d \) 次多项式降为一次函数，通过一次函数的斜率和截距快速求 \( s \)。思路简洁高效（时间复杂度 \( O(d) \)），代码实现直接（差分公式的展开），适合竞赛场景。亮点在于“差分降次”的转化，将复杂问题简化为直线问题。

**题解三：作者jiangtaizhe001（来源：博客园）**  
* **点评**：  
  此题解提供了拉格朗日插值的完整代码实现，预处理阶乘逆元，高效计算 \( x^d \) 和 \( x^{d-1} \) 项系数。代码规范（变量名如 \( k \)、\( k1 \)、\( k2 \) 含义明确），边界处理严谨（模运算取反），实践价值高（可直接用于竞赛）。亮点在于将数学公式转化为高效的代码，展示了组合数的灵活应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1**：如何高效计算多项式的 \( x^d \) 和 \( x^{d-1} \) 项系数？  
    * **分析**：直接插值 \( d+1 \) 个点值的复杂度为 \( O(d^2) \)，无法处理 \( d \) 较大的情况。优质题解通过拉格朗日插值的系数公式，利用组合数和阶乘逆元，将计算复杂度降为 \( O(d) \)。例如，\( x^d \) 项系数是各点值乘以组合数的累加，而 \( x^{d-1} \) 项系数则需额外考虑点值的加权和。  
    * 💡 **学习笔记**：拉格朗日插值的高次项系数可通过组合数公式快速计算，无需完整展开多项式。

2.  **关键点2**：如何利用差分操作降次？  
    * **分析**：对 \( d \) 次多项式进行 \( d-1 \) 次差分后，结果为一次函数（直线）。差分公式 \( \Delta^k f(x) = \sum_{i=0}^k (-1)^{k-i} \binom{k}{i} f(x+i) \) 可将高次项消去，仅保留低次项。例如，\( d=2 \) 时，两次差分后得到常数（但此处需 \( d-1 \) 次差分，得到一次函数）。  
    * 💡 **学习笔记**：差分是多项式降次的“利器”，每差分一次次数减1。

3.  **关键点3**：如何处理模运算中的逆元？  
    * **分析**：计算组合数或除法时需用到模逆元（如 \( \frac{1}{i!} \mod 1e9+7 \)）。优质题解通过预处理阶乘和阶乘逆元（\( inv[i] = (i+1) \cdot inv[i+1] \mod MOD \)），快速获取逆元，避免重复计算。  
    * 💡 **学习笔记**：预处理阶乘和逆元是处理组合数问题的常见技巧，能大幅提升效率。

### ✨ 解题技巧总结
- **问题转化**：将高次多项式问题转化为低次（一次）问题（如差分降次）。  
- **数学公式应用**：利用拉格朗日插值的系数公式，直接计算目标项系数，避免全插值。  
- **预处理优化**：预处理阶乘和逆元，快速计算组合数和逆元，降低时间复杂度。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择作者jiangtaizhe001的代码作为通用核心实现，因其完整展示了拉格朗日插值的关键步骤，且逻辑清晰、效率高。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了拉格朗日插值的核心逻辑，通过预处理阶乘和逆元，高效计算 \( x^d \) 和 \( x^{d-1} \) 项系数，最终求解 \( s \)。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

ll fpow(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        y >>= 1;
        x = x * x % MOD;
    }
    return res;
}

// 计算x^d项的系数
ll get_k(int d, ll* p, ll* inv_fact) {
    ll ans = 0;
    for (int i = 0; i <= d; ++i) {
        ll sign = (d - i) % 2 == 0 ? 1 : MOD - 1;
        ll term = p[i] * inv_fact[i] % MOD;
        term = term * inv_fact[d - i] % MOD;
        term = term * sign % MOD;
        ans = (ans + term) % MOD;
    }
    return ans;
}

// 计算x^(d-1)项的系数
ll get_k1(int d, ll* p, ll* inv_fact) {
    ll sum = 1LL * d * (d + 1) / 2 % MOD;
    ll ans = 0;
    for (int i = 0; i <= d; ++i) {
        ll sign = (d - i) % 2 == 0 ? 1 : MOD - 1;
        ll term = (sum - i + MOD) % MOD;
        term = term * p[i] % MOD;
        term = term * inv_fact[i] % MOD;
        term = term * inv_fact[d - i] % MOD;
        term = term * sign % MOD;
        ans = (ans + term) % MOD;
    }
    return MOD - ans;
}

int main() {
    int d;
    cin >> d;
    vector<ll> a(d + 1), b(d + 1);
    for (int i = 0; i <= d; ++i) cin >> a[i];
    for (int i = 0; i <= d; ++i) cin >> b[i];

    // 预处理阶乘和逆元
    vector<ll> fact(d + 1), inv_fact(d + 1);
    fact[0] = 1;
    for (int i = 1; i <= d; ++i) fact[i] = fact[i - 1] * i % MOD;
    inv_fact[d] = fpow(fact[d], MOD - 2);
    for (int i = d - 1; i >= 0; --i) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;

    ll a_d = get_k(d, a.data(), inv_fact.data()); // A的x^d项系数
    ll a_d1 = get_k1(d, a.data(), inv_fact.data()); // A的x^(d-1)项系数
    ll b_d1 = get_k1(d, b.data(), inv_fact.data()); // B的x^(d-1)项系数

    // 计算s = (b_{d-1} - a_{d-1}) / (d * a_d) mod MOD
    ll numerator = (b_d1 - a_d1 + MOD) % MOD;
    ll denominator = d * a_d % MOD;
    ll s = numerator * fpow(denominator, MOD - 2) % MOD;
    cout << s << endl;

    return 0;
}
```
* **代码解读概要**：  
  代码首先读取输入数据，预处理阶乘和阶乘逆元。然后通过 `get_k` 和 `get_k1` 函数分别计算 \( A \) 和 \( B \) 的 \( x^d \) 和 \( x^{d-1} \) 项系数。最后利用公式 \( s = \frac{b_{d-1} - a_{d-1}}{d \cdot a_d} \mod 1e9+7 \) 计算 \( s \)。关键步骤是预处理逆元和系数计算函数的实现。

---

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解二：作者Alex_Wei（差分降次法）**  
* **亮点**：通过差分将高次多项式降为一次函数，代码简洁高效。  
* **核心代码片段**：
```cpp
// 计算d-1次差分后的一次函数参数
pair<ll, ll> get_linear(int d, ll* p) {
    vector<ll> diff = vector<ll>(p, p + d + 1);
    for (int k = 0; k < d - 1; ++k) { // 进行d-1次差分
        for (int i = 0; i < d - k; ++i) {
            diff[i] = (diff[i + 1] - diff[i] + MOD) % MOD;
        }
    }
    // 差分d-1次后，剩下两个点值，对应一次函数的x=0和x=1处的值
    return {diff[0], diff[1]};
}

int main() {
    int d;
    cin >> d;
    vector<ll> a(d + 1), b(d + 1);
    for (int i = 0; i <= d; ++i) cin >> a[i];
    for (int i = 0; i <= d; ++i) cin >> b[i];

    auto [a0, a1] = get_linear(d, a.data()); // A差分后的直线点值
    auto [b0, b1] = get_linear(d, b.data()); // B差分后的直线点值

    ll k = (a1 - a0 + MOD) % MOD; // 直线斜率
    ll s = (b0 - a0 + MOD) % MOD * fpow(k, MOD - 2) % MOD; // 解方程a0 + k*s = b0
    cout << s << endl;
}
```
* **代码解读**：  
  `get_linear` 函数通过 \( d-1 \) 次差分将 \( d \) 次多项式降为一次函数，返回其在 \( x=0 \) 和 \( x=1 \) 处的点值。主函数中，通过 \( A \) 和 \( B \) 的差分结果，利用一次函数的斜率 \( k = a1 - a0 \) 和 \( B \) 的点值 \( b0 = a0 + k \cdot s \)，解出 \( s \)。  
* 💡 **学习笔记**：差分降次法将问题简化为一次函数的参数求解，是处理高次多项式问题的高效策略。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解拉格朗日插值计算系数的过程，我们设计一个“像素多项式实验室”动画，以8位复古风格展示系数的计算和差分降次的过程。
</visualization_intro>

  * **动画演示主题**：`像素多项式实验室——寻找魔法数s`  
  * **核心演示内容**：演示拉格朗日插值中 \( x^d \) 和 \( x^{d-1} \) 项系数的计算过程，以及差分降次法中多项式从高次到一次的变化。  
  * **设计思路简述**：8位像素风格营造轻松氛围，用不同颜色的方块表示 \( A \) 和 \( B \) 的点值。动画通过闪烁、移动等效果突出关键步骤（如组合数的累加），音效在每次系数更新时播放“叮”声，完成时播放胜利音效，增强记忆点。  

  * **动画帧步骤与交互关键点**：  

    1. **场景初始化**：  
       屏幕左侧为“点值区”，排列 \( d+1 \) 个像素方块（颜色：\( A \) 为蓝色，\( B \) 为红色），标注 \( x=0 \) 到 \( x=d \)。右侧为“系数计算区”，显示 \( x^d \) 和 \( x^{d-1} \) 项的系数框（初始为问号）。控制面板包含“单步”“自动”“重置”按钮和速度滑块。

    2. **拉格朗日插值演示**：  
       - **阶乘逆元预处理**：像素小精灵（角色）逐个计算阶乘和逆元，将结果存入“魔法箱”（数据框），伴随“滴答”音效。  
       - **\( x^d \) 系数计算**：每个点值方块（如 \( A[0] \)）发射像素粒子，粒子携带组合数 \( \frac{1}{i! (d-i)!} \) 和符号（正/负），最终汇聚到 \( x^d \) 系数框，累加得到结果。关键步骤用黄色闪烁高亮。  
       - **\( x^{d-1} \) 系数计算**：类似，但粒子额外携带 \( \sum -x_j \) 的权重，最终汇聚到 \( x^{d-1} \) 系数框，伴随“叮咚”音效。

    3. **差分降次演示**（可选模式）：  
       - 初始点值区显示 \( d \) 次多项式的点值。每次差分操作时，相邻两个方块合并为一个新方块（值为后项减前项），原方块消失，新方块颜色变浅。重复 \( d-1 \) 次后，仅剩两个方块，显示一次函数的点值。

    4. **求解s**：  
       当 \( x^d \) 和 \( x^{d-1} \) 系数计算完成（或差分得到一次函数），屏幕中央弹出公式 \( s = \frac{b_{d-1} - a_{d-1}}{d \cdot a_d} \)，像素小精灵用魔法棒指向结果，播放“胜利”音效，\( s \) 数值框闪烁绿色。

  * **旁白提示**：  
    - “看！每个点值方块都在贡献自己的力量，通过组合数和符号的魔法，最终累加出最高次项的系数～”  
    - “差分就像给多项式‘减肥’，每做一次差分，次数就减少1，直到变成直线！”  

<visualization_conclusion>
通过这个像素动画，我们能直观看到系数计算的每一步，以及差分如何简化问题，让抽象的数学过程变得“可见可感”。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以将思路迁移到其他多项式或差分相关问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    拉格朗日插值和差分降次的方法不仅适用于本题，还可解决：  
    1. 给定多项式点值，求某一点的函数值（如洛谷P4781）。  
    2. 多项式平移后的系数计算（如求 \( A(x+s) \) 的某系数）。  
    3. 高阶差分的性质应用（如求数列的通项公式）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4781** - `【模板】拉格朗日插值`  
        🗣️ **推荐理由**：直接练习拉格朗日插值的实现，巩固系数计算方法。  
    2.  **洛谷 P3774** - `[CTSC2017] 最长上升子序列`  
        🗣️ **推荐理由**：涉及多项式与动态规划的结合，可拓展对多项式应用场景的理解。  
    3.  **洛谷 P5643** - `[PKUWC2018] 随机游走`  
        🗣️ **推荐理由**：需要利用差分和生成函数，提升综合运用数学工具的能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题时的思考，其中“Little09”提到：“推导出 \( b_{d-1} = d \cdot a_d \cdot s + a_{d-1} \) 后，我卡了40分钟，后来发现直接代入点值计算系数即可。”这提醒我们：
</insights_intro>

> **参考经验**：“遇到复杂公式时，不妨尝试代入特殊项（如 \( i=d-1 \)），可能直接得到关键关系。”  
> **点评**：这位作者的经验很实用。在多项式问题中，高次项（如 \( x^d \)、\( x^{d-1} \)）往往具有特殊性质，优先分析这些项能快速简化问题。学习时，我们应养成“抓主要矛盾”的习惯，优先关注高次项或关键项。

---

<conclusion>
本次关于“Similar Polynomials”的C++解题分析就到这里。希望这份指南能帮助大家理解多项式操作的核心技巧，无论是拉格朗日插值还是差分降次，关键在于抓住问题的数学本质。记住，多动手推导公式、尝试代码实现，是提升算法能力的关键！下次见～💪
</conclusion>

---
处理用时：142.05秒
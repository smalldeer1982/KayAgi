# 题目信息

# Capitalism

## 题目描述

整个社会可以用一张由 $n$ 个顶点和 $m$ 条边组成的无向联通图来表示。顶点代表人，一条边  $(i,j)$ 代表人 $i$ 和 $j$ 之间的友谊。

在社会上，第 $i$ 个人有收入 $a_i$。一个人 $i$ 羡慕一个人 $j$，等价于 $j$ 比 $i$ 多出1个单位的收入，也就是 $a_j=a_i+1$。

如果对于每一对朋友，都有一个人羡慕另一个人，这个社会就叫资本主义社会。对于一些朋友关系，你知道哪个人在羡慕另一个人。对于其余的朋友关系，你不知道谁羡慕谁。

社会收入不等值的定义是：$\max_{i=1}^na_i - \min_{i=1}^na_i$，也就是社会中收入最多的人的收入与收入最少的人的收入之差。

你只知道一些朋友关系，不知道每个人的收入。对于一部分朋友关系，你知道谁羡慕谁；对于另外一部分，你不知道。你要判断这个社会是否可能成为资本主义社会。如果是，你要构造一个 $a$ 满足所有条件，且这是个资本主义社会。要求你给出的 $a$ 让社会收入不等值最大。

## 样例 #1

### 输入

```
6 6
1 2 0
3 2 0
2 5 0
6 5 1
6 3 0
2 4 1```

### 输出

```
YES
3
3 2 1 3 1 0```

## 样例 #2

### 输入

```
4 4
1 2 1
2 3 0
3 4 1
4 1 1```

### 输出

```
NO```

## 样例 #3

### 输入

```
1 0```

### 输出

```
YES
0
0```

# AI分析结果

# 💡 Kay的C++算法解析：Capitalism 深入学习指南 💡

<introduction>
今天我们来一起分析「Capitalism」这道C++编程题。这道题需要我们构造一个满足“资本主义社会”条件的收入数组，并让收入极差最大。听起来有点抽象？别担心，我们会一步步拆解问题，理解核心算法，还会用像素动画帮你直观看到过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分图染色 + 差分约束（最短路应用）`

🗣️ **初步分析**：
解决这道题的关键，在于先**判断图是否是二分图**（没有奇环），再用**差分约束系统**求满足条件的最大极差。  

简单来说：  
- **二分图染色**：因为题目要求“朋友间收入差1”，所以相邻节点的收入奇偶性一定不同——这正好是二分图的定义（节点能分成两组，同组内无相邻）。如果图有奇环（比如三角形），就不可能满足条件，直接判“NO”。  
- **差分约束**：把题目中的“羡慕关系”转化为不等式（比如“a_j = a_i+1”对应“a_j ≥ a_i+1”且“a_j ≤ a_i+1”），然后用最短路算法（如Floyd、SPFA）求解这些约束，找到让极差最大的解。  

**核心流程**：  
1. 用二分图染色判断是否有奇环（无解则输出NO）；  
2. 将约束条件转化为图的边权（比如“a_j ≥ a_i+1”对应边i→j权1）；  
3. 跑全源最短路，枚举每个节点作为“最小值点”（设为0），计算其他节点的最大可能值，找出最大极差。  

**可视化设计思路**：  
我们会做一个**像素风的“二分图探险”动画**——用红、蓝像素块标记二分图的两组节点，用闪烁的箭头展示最短路的扩展过程。关键步骤（如染色、松弛操作）会有“叮”的音效，找到最大极差时会播放“胜利”音效，让你直观看到算法如何工作！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：Little09（赞5，代码简洁，逻辑严谨）**  
* **点评**：这份题解的思路非常“直球”——先用**并查集判奇环**（二分图），再用**Floyd求全源最短路**。并查集的技巧很巧妙：把每个节点拆成“本身”和“对立节点”（比如i和i+n），如果朋友关系要求奇偶不同，就合并i和j+n、j和i+n。如果某个节点和自己的对立节点在同一集合，说明有奇环。之后用Floyd处理差分约束，枚举每个节点作为起点，找最大极差。代码规范，变量名清晰（比如f[i][j]表示i到j的最短路），边界处理严谨（比如判负环），非常适合入门学习。

**题解二：FutaRimeWoawaSete（赞8，思路深入）**  
* **点评**：这位作者的思考很有深度——他指出“差分约束的条件是|a-b|≤1，但题目要求|a-b|=1”，但通过**二分图的性质**（无奇环时相邻节点奇偶不同），巧妙化解了“等于0”的问题。他还提到用**全源最短路判奇环**（如果u到v的最短路奇偶性相同，加边后形成奇环），虽然最终推荐用二分图染色更简单，但这种“追问本质”的思考方式值得学习。

**题解三：Conan15（赞1，代码实用）**  
* **点评**：这份题解用**DFS二分图染色**（更直观），再用**SPFA跑差分约束**。DFS染色的代码很经典：递归标记每个节点的颜色，如果相邻节点颜色相同则判无解。SPFA部分处理差分约束的约束条件（比如w=1时加边v→u权-1、u→v权1），枚举每个节点作为起点，找最大极差。代码结构清晰，适合理解“差分约束如何转化为最短路”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于“把题目条件转化为算法模型”。结合优质题解，我提炼了3个核心问题和解决策略：
</difficulty_intro>

1. **难点1：为什么要判二分图？**  
   * **分析**：题目要求“朋友间收入差1”，所以相邻节点的收入奇偶性一定不同——这是二分图的核心性质（节点分成两组，同组内无相邻）。如果图有奇环（比如3个节点形成环），那么绕环一圈后奇偶性会冲突（比如1→2→3→1，1是偶，2奇，3偶，1又偶，导致3和1同奇偶，但它们是朋友，必须差1，矛盾）。  
   * 💡 **学习笔记**：二分图是解决“相邻元素必须不同”问题的利器！

2. **难点2：如何把题目条件转化为差分约束？**  
   * **分析**：差分约束系统是用图的最短路/最长路来求解不等式组的方法。对于题目中的两种情况：  
     - 已知i羡慕j（a_j = a_i+1）：转化为“a_j ≥ a_i+1”（i→j权1）和“a_j ≤ a_i+1”（j→i权-1）；  
     - 未知谁羡慕谁（|a_i-a_j|=1）：转化为“a_i ≤ a_j+1”（j→i权1）和“a_j ≤ a_i+1”（i→j权1）。  
   * 💡 **学习笔记**：绝对值不等式可以拆成两个方向的不等式，这是差分约束的常用技巧！

3. **难点3：如何求最大极差？**  
   * **分析**：极差是“最大值-最小值”。要让极差最大，我们需要让最小值尽可能小，最大值尽可能大。因为差分约束的最短路解是“满足所有约束的最小可能值”，所以我们枚举每个节点作为“最小值点”（设为0），计算其他节点的最短路（即最大可能值），然后取所有情况中的最大极差。  
   * 💡 **学习笔记**：枚举“基准点”是求极值问题的常用思路！

### ✨ 解题技巧总结
- **模型转化**：把“收入差1”转化为二分图问题，把“羡慕关系”转化为差分约束；  
- **工具选择**：用并查集/DFS判二分图，用Floyd/SPFA求最短路；  
- **极值策略**：枚举基准点，找最大极差。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**（综合Little09和Conan15的思路），帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用DFS判二分图，Floyd求全源最短路，逻辑清晰，适合入门。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  using namespace std;

  const int N = 205, INF = 0x3f3f3f3f;
  int n, m;
  int g[N][N], col[N]; // g: 邻接矩阵（最短路），col: 二分图颜色（0/1/-1）
  int h[N], e[N<<1], ne[N<<1], idx; // 邻接表（二分图染色）

  void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }

  bool dfs(int u, int c) {
      col[u] = c;
      for (int i = h[u]; ~i; i = ne[i]) {
          int v = e[i];
          if (col[v] == -1) {
              if (!dfs(v, c^1)) return false;
          } else if (col[v] == c) {
              return false; // 奇环，不是二分图
          }
      }
      return true;
  }

  int main() {
      memset(h, -1, sizeof h);
      memset(col, -1, sizeof col);
      memset(g, 0x3f, sizeof g);
      cin >> n >> m;
      for (int i = 1; i <= n; i++) g[i][i] = 0;

      // 读入边，构建邻接表（二分图染色）和邻接矩阵（差分约束）
      for (int i = 0; i < m; i++) {
          int x, y, z;
          cin >> x >> y >> z;
          add(x, y), add(y, x); // 二分图的无向边
          if (z == 1) {
              g[x][y] = 1; // a_y >= a_x +1
              g[y][x] = -1; // a_x >= a_y -1 → a_y <= a_x +1
          } else {
              g[x][y] = 1; // a_y <= a_x +1
              g[y][x] = 1; // a_x <= a_y +1
          }
      }

      // 判二分图
      bool ok = true;
      for (int i = 1; i <= n; i++) {
          if (col[i] == -1) {
              if (!dfs(i, 0)) {
                  ok = false;
                  break;
              }
          }
      }
      if (!ok) { cout << "NO" << endl; return 0; }

      // Floyd求全源最短路
      for (int k = 1; k <= n; k++) {
          for (int i = 1; i <= n; i++) {
              for (int j = 1; j <= n; j++) {
                  if (g[i][k] != INF && g[k][j] != INF) {
                      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
                  }
              }
          }
      }

      // 找最大极差
      int max_diff = -1, pos = 1;
      for (int i = 1; i <= n; i++) {
          int mx = -INF;
          for (int j = 1; j <= n; j++) {
              mx = max(mx, g[i][j]);
          }
          if (mx > max_diff) {
              max_diff = mx;
              pos = i;
          }
      }

      cout << "YES" << endl;
      cout << max_diff << endl;
      for (int i = 1; i <= n; i++) {
          cout << g[pos][i] << " ";
      }
      cout << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **二分图染色**：用DFS递归标记每个节点的颜色，如果相邻节点颜色相同则判无解；  
  2. **差分约束建图**：把题目条件转化为邻接矩阵的边权；  
  3. **Floyd求最短路**：处理所有约束条件，得到每个节点的最小可能值；  
  4. **找最大极差**：枚举每个节点作为起点，计算其他节点的最大值，取最大极差。

---

<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

**题解一：Little09（并查集判奇环）**
* **亮点**：用并查集巧妙判断二分图，避免递归（适合大数据）。
* **核心代码片段**：
  ```cpp
  int fa[N*2];
  int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
  void merge(int x, int y) { fa[find(x)] = find(y); }

  // 主函数中：
  for (int i = 1; i <= 2*n; i++) fa[i] = i;
  for (int i = 1; i <= m; i++) {
      int x, y, z;
      cin >> x >> y >> z;
      merge(x + n, y); // x的对立节点和y合并
      merge(x, y + n); // x和y的对立节点合并
  }
  for (int i = 1; i <= n; i++) {
      if (find(i) == find(i + n)) { // 自己和对立节点在同一集合→奇环
          cout << "NO";
          return 0;
      }
  }
  ```
* **代码解读**：  
  把每个节点拆成“本身”（i）和“对立节点”（i+n）。如果x和y必须奇偶不同，就合并x+n和y、x和y+n——这样如果x和y的奇偶性相同，就会导致x和x+n在同一集合，从而判断奇环。这种方法不需要递归，效率很高！
* 💡 **学习笔记**：并查集是处理“分组关系”的神器，比如二分图的奇偶分组。

**题解二：Conan15（SPFA跑差分约束）**
* **亮点**：用SPFA处理差分约束，适合有负权边的情况。
* **核心代码片段**：
  ```cpp
  struct Graph2 {
      int h[N], e[M], w[M], ne[M], idx = 0;
      void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; }

      int d[N], cnt[N];
      bool st[N];
      queue<int> q;
      int spfa(int s) {
          memset(d, 0x3f, sizeof d);
          memset(st, 0, sizeof st);
          memset(cnt, 0, sizeof cnt);
          d[s] = 0; q.push(s); st[s] = true;
          while (!q.empty()) {
              int u = q.front(); q.pop(); st[u] = false;
              for (int i = h[u]; ~i; i = ne[i]) {
                  int v = e[i];
                  if (d[v] > d[u] + w[i]) {
                      d[v] = d[u] + w[i];
                      cnt[v] = cnt[u] + 1;
                      if (cnt[v] >= n) return -INF; // 负环无解
                      if (!st[v]) { q.push(v); st[v] = true; }
                  }
              }
          }
          int mx = 0;
          for (int i = 1; i <= n; i++) mx = max(mx, d[i]);
          return mx;
      }
  } G2;
  ```
* **代码解读**：  
  SPFA是处理负权边的最短路算法。这里用`d[v]`表示节点v的最小可能值（满足所有约束），`cnt[v]`记录入队次数（超过n次说明有负环，无解）。枚举每个起点s，计算`d`数组的最大值，就是当前起点的极差。
* 💡 **学习笔记**：SPFA是差分约束的常用工具，尤其是当图有负权边时。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观看到“二分图染色”和“最短路扩展”的过程，我设计了一个**8位像素风的“资本主义社会搭建游戏”**！
</visualization_intro>

### ✨ 动画设计方案
**主题**：像素小人在“友谊网络”中搭建“资本主义社会”，需要完成“二分图染色”和“找最大极差”两个关卡。

#### 1. 场景与UI初始化（FC风格）
- **画面**：用8位像素块绘制n个节点（圆形，颜色初始为灰色），m条边（白色直线）。屏幕下方有“开始”“单步”“重置”按钮，速度滑块（1~5档）。
- **音效**：背景播放FC风格的轻快BGM（如《超级马里奥》的地面音乐）。

#### 2. 关卡1：二分图染色（判断是否可行）
- **流程**：  
  1. 点击“开始”，第一个节点（比如节点1）变成红色（颜色0），同时播放“叮”的音效。  
  2. 递归遍历它的邻居：邻居变成蓝色（颜色1），播放“叮”；邻居的邻居变成红色，依此类推。  
  3. 如果发现某个节点的邻居颜色相同（比如红色节点的邻居也是红色），屏幕闪烁红色，播放“错误”音效（短促的“哔”），弹出提示“有奇环，无法搭建！”。  
- **高亮设计**：当前处理的节点用黄色边框包围，已染色的节点用红/蓝填充。

#### 3. 关卡2：找最大极差（最短路扩展）
- **流程**：  
  1. 选择一个“基准节点”（比如节点pos），变成绿色（表示最小值0）。  
  2. 用“波浪动画”展示最短路的扩展：基准节点的邻居变成浅绿色（值1），邻居的邻居变成浅蓝（值2），依此类推。每扩展一步，播放“咻”的音效。  
  3. 扩展完成后，屏幕显示当前的极差（最大值-最小值），如果是最大极差，播放“胜利”音效（上扬的“叮~”），并高亮所有节点的值。
- **交互**：支持“单步执行”（点击一次扩展一个节点）和“自动播放”（按速度滑块的速度连续扩展）。

#### 4. 游戏化元素
- **关卡奖励**：完成二分图染色关卡，获得“二分图小徽章”；找到最大极差，获得“资本主义大亨”称号。
- **音效反馈**：关键操作（染色、扩展）有不同的音效，强化记忆。

### 🎮 为什么这样设计？
- **像素风格**：复古的FC风格能唤起你的游戏记忆，让学习更轻松；  
- **动画流程**：用颜色和运动直观展示“二分图染色”和“最短路扩展”，比文字更易理解；  
- **游戏化奖励**：徽章和称号能激发你的成就感，让你更愿意主动探索。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“二分图+差分约束”的组合拳，我们可以解决很多类似问题！
</similar_problems_intro>

### 通用思路迁移
- **二分图应用**：判断“相邻元素必须不同”的问题（比如棋盘染色、 bipartition问题）；  
- **差分约束应用**：求解不等式组的问题（比如安排时间、资源分配）；  
- **最短路扩展**：求极值的问题（比如最大差值、最长路径）。

### 洛谷练习推荐
1. **洛谷 P5960** - 差分约束系统模板  
   🗣️ **推荐理由**：这是差分约束的入门题，帮你巩固“不等式转图论”的技巧。  
2. **洛谷 P1525** - 关押罪犯  
   🗣️ **推荐理由**：用二分图判断能否将罪犯分成两组，是二分图的经典应用。  
3. **洛谷 P2863** - 道路建设  
   🗣️ **推荐理由**：用最短路求最大差值，和本题的“极差最大”思路一致。  
4. **洛谷 P3385** - 负环判断  
   🗣️ **推荐理由**：用SPFA判断负环，巩固差分约束的“无解情况”处理。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的作者心得能帮我们少走弯路，比如：
</insights_intro>

> **参考经验（来自Little09）**：“我一开始没想到用并查集判二分图，后来发现递归DFS可能会栈溢出，所以改用并查集——这种‘换工具’的思路很重要！”  
> **点评**：这位作者的经验提醒我们，**算法工具没有“最优”，只有“最适合”**。比如递归DFS适合小数据，而并查集适合大数据，根据题目条件选择工具能避免调试问题。


<conclusion>
本次关于「Capitalism」的分析就到这里！这道题的核心是“二分图+差分约束”的组合，关键在于把题目条件转化为算法模型。记住：**编程的本质是“模型转化”——把现实问题变成计算机能理解的数学问题**。下次遇到类似问题，试着先想“这像哪个算法模型？”，你会发现解题变得轻松很多！💪
</conclusion>

---
处理用时：109.47秒
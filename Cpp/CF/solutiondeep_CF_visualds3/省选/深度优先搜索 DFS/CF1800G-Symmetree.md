# 题目信息

# Symmetree

## 题目描述

Kid was gifted a tree of $ n $ vertices with the root in the vertex $ 1 $ . Since he really like symmetrical objects, Kid wants to find out if this tree is symmetrical.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1800G/d38e017cff0afa58cfae306135ac70824868e32a.png) For example, the trees in the picture above are symmetrical.  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1800G/c7cdf18345f431d81f3f4995e8b80d43eac66d45.png) And the trees in this picture are not symmetrical.Formally, a tree is symmetrical if there exists an order of children such that:

- The subtree of the leftmost child of the root is a mirror image of the subtree of the rightmost child;
- the subtree of the second-left child of the root is a mirror image of the subtree of the second-right child of the root;
- ...
- if the number of children of the root is odd, then the subtree of the middle child should be symmetrical.

## 样例 #1

### 输入

```
6
6
1 5
1 6
1 2
2 3
2 4
7
1 5
1 3
3 6
1 4
4 7
4 2
9
1 2
2 4
2 3
3 5
1 7
7 6
7 8
8 9
10
2 9
9 10
2 3
6 7
4 3
1 2
3 8
2 5
6 5
10
3 2
8 10
9 7
4 2
8 2
2 1
4 5
6 5
5 7
1```

### 输出

```
YES
NO
YES
NO
NO
YES```

# AI分析结果

# 💡 Kay的C++算法解析：Symmetree 深入学习指南 💡

<introduction>
今天我们来一起分析「Symmetree」这道C++编程题——判断一棵树是否对称。这道题的核心是**树的同构判断**，需要用「树哈希」技术给每棵子树“打标签”，再通过标签配对判断对称性。本指南会帮你理清思路、掌握树哈希的应用，并通过像素动画直观看到算法运行过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树哈希（图论·树同构应用）

🗣️ **初步分析**：
解决「Symmetree」的关键是**树哈希**——给每棵子树分配一个唯一的“哈希值”，**同构的子树哈希值相同**（就像双胞胎有一样的身份证号）。题目要求树对称，本质是：
- 根节点的子节点可以重新排序，使得**左右对称位置的子树同构**（哈希值相同）；
- 如果子节点数是奇数，中间的子树本身必须对称（递归判断）。

### 核心算法流程
1. **递归计算树哈希**：从叶子到根，给每个节点计算哈希值（综合子节点的哈希）；
2. **统计子节点哈希**：对每个节点，统计其子节点的哈希值出现次数；
3. **判断对称性**：
   - 子节点数为偶数：所有哈希必须成对出现（异或和为0，或计数全为偶数）；
   - 子节点数为奇数：恰好有一个哈希出现奇数次（中间子树），且该子树本身对称。

### 可视化设计思路
我会用**8位像素风**设计动画：
- **树结构**：根节点在屏幕顶部，子节点向下展开成像素树（每个节点是16x16的方块，颜色代表哈希值）；
- **哈希配对**：相同哈希的子节点会“闪烁+靠拢”（比如左1和右1、左2和右2），配对成功时播放“叮”的音效；
- **奇数子节点处理**：中间的子节点会“放大+高亮”，递归展开其内部结构，展示它如何判断自己是否对称；
- **结果反馈**：整棵树对称时，所有节点会“彩虹闪烁”并播放胜利音效；否则播放错误提示音。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，一起来看看它们的亮点吧！
</eval_intro>

**题解一：作者 jianhe（赞：4）**
* **点评**：这份题解用「异或哈希」实现树同构判断，逻辑超简洁！核心思路是：子节点的哈希异或和为0时，说明所有哈希成对出现（偶数个）；如果子节点数是奇数，找到那个“单独的哈希”（异或和等于它自己），再递归判断该子树是否对称。代码中的`Tran`函数是哈希混淆（避免冲突），`dfs`函数递归计算哈希和对称性（`dp[x]`表示x的子树是否对称）。整体代码短小精悍，适合入门学习树哈希！

**题解二：作者 thostever（赞：4）**
* **点评**：这份题解用「求和+乘积」的哈希方式（模998244353），更抗哈希冲突。它的亮点是**排序子节点哈希**后统计奇偶次数——把相同哈希的子节点排在一起，遍历统计出现次数：如果某哈希出现奇数次，就检查该子树是否对称（`b[u]`记录需要检查的子树数量，≤1则合法）。这种方法更直观，适合理解“配对逻辑”，代码中的`sort`和`lst`变量处理得很巧妙！

**题解三：作者 shinkuu（赞：1）**
* **点评**：这份题解用「xor shift」哈希（更随机的混淆），思路和题解一类似，但代码风格更贴近竞赛写法（比如`my_std` namespace封装输入输出）。它的`shift`函数用位运算混淆哈希，`dp[u]`直接记录子树是否对称，逻辑清晰。适合学习如何优化输入输出（竞赛中常用）和位运算哈希！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是**处理“树同构”和“对称逻辑”**，以下是三个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何设计树哈希函数？**
   * **分析**：树哈希需要满足“同构树哈希相同，不同构树哈希尽量不同”。常见方法有：
     - 异或哈希（题解一、三）：子节点哈希异或+混淆；
     - 求和+乘积哈希（题解二）：子节点哈希求和+乘积+模运算；
   * 💡 **学习笔记**：选择哈希函数时，要加“混淆步骤”（比如位运算、乘大质数），避免简单哈希被卡！

2. **难点2：如何处理子节点的奇偶数量？**
   * **分析**：
     - 偶数子节点：所有哈希必须成对出现（异或和为0，或计数全偶）；
     - 奇数子节点：恰好一个哈希出现奇数次，且该子树本身对称；
   * 💡 **学习笔记**：用异或和（偶数个相同数异或为0）或排序统计（题解二），能快速判断奇偶配对！

3. **难点3：如何递归判断子树对称性？**
   * **分析**：对称性是递归定义的——父节点对称的前提是子节点能配对，中间子节点自己也对称。所以需要用`dp`数组记录每个子树是否对称（题解一的`dp[x]`、题解二的`b[u]`）；
   * 💡 **学习笔记**：递归问题要“自底向上”处理，先算子节点再算父节点！


### ✨ 解题技巧总结
- **技巧1：树哈希模板**：记住树哈希的通用结构——递归计算子节点哈希，再综合成父节点哈希；
- **技巧2：奇偶配对判断**：用异或和（偶数个相同数异或为0）或排序统计（统计出现次数）；
- **技巧3：递归状态记录**：用`dp`数组记录子树是否对称，避免重复计算！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**（综合题解一的异或哈希，逻辑最简洁）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解一，用异或哈希判断树对称性，逻辑清晰、代码简洁。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const ull mask = rand();
const int N = 2e5 + 10;
vector<int> e[N];
ull h[N];
bool dp[N]; // dp[x]表示x的子树是否对称

// 哈希混淆函数（避免冲突）
ull Tran(ull x) {
    x ^= mask; x ^= (x << 13); x ^= (x >> 7); x ^= (x << 17); x ^= mask;
    return x;
}

void dfs(int x, int fa) {
    int son_cnt = 0;
    ull xor_sum = 0;
    h[x] = 0; // 初始哈希值
    for (int y : e[x]) {
        if (y == fa) continue;
        dfs(y, x);
        son_cnt++;
        xor_sum ^= h[y]; // 子节点哈希异或和
        h[x] += Tran(h[y]); // 父节点哈希=子节点混淆后的哈希之和
    }
    // 判断对称性
    if (son_cnt % 2 == 0) {
        dp[x] = (xor_sum == 0); // 偶数子节点：异或和为0则对称
    } else {
        // 奇数子节点：找到单独的哈希（xor_sum等于它自己），并判断该子树是否对称
        for (int y : e[x]) {
            if (y == fa) continue;
            if (h[y] == xor_sum) {
                dp[x] = dp[y];
                break;
            }
        }
    }
}

void solve() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) e[i].clear();
    for (int i = 1; i < n; i++) {
        int x, y; cin >> x >> y;
        e[x].push_back(y); e[y].push_back(x);
    }
    dfs(1, 0);
    cout << (dp[1] ? "YES" : "NO") << endl;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int T; cin >> T;
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：
  1. 输入处理：读取多组测试用例，构建树的邻接表；
  2. 递归计算：`dfs`函数从根节点（1号）开始，递归计算每个节点的哈希值`h[x]`和对称性`dp[x]`；
  3. 结果输出：根节点的`dp[1]`就是整棵树是否对称的结果！


<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

**题解一：作者 jianhe**
* **亮点**：用异或和快速判断偶数子节点的配对情况，代码简洁到“一行搞定”！
* **核心代码片段**：
```cpp
if (son_cnt % 2 == 0) {
    dp[x] = (xor_sum == 0); // 偶数子节点：异或和为0则所有哈希成对
} else {
    for (int y : e[x]) {
        if (y == fa && h[y] == xor_sum) { // 找单独的哈希
            dp[x] = dp[y]; break;
        }
    }
}
```
* **代码解读**：
  - 偶数子节点时，`xor_sum`是所有子节点哈希的异或——如果所有哈希成对（比如a^a^b^b=0），则`xor_sum=0`，说明可以对称排列；
  - 奇数子节点时，`xor_sum`等于那个“单独的哈希”（比如a^a^b^b^c = c），找到这个子节点`y`，判断它的子树是否对称（`dp[y]`）。
* 💡 **学习笔记**：异或运算的“消去性”（a^a=0）是判断成对出现的神器！

**题解二：作者 thostever**
* **亮点**：排序子节点哈希后统计奇偶次数，直观易懂！
* **核心代码片段**：
```cpp
vector<node> t; // 存储子节点的哈希和对称性
sort(t.begin(), t.end(), cmp); t.push_back({-666ll, -999}); // 哨兵
int lst = 0;
for (int i = 0; i < t.size()-1; i++) {
    if (t[i].a != t[i+1].a) {
        if ((i - lst + 1) % 2 == 1) { // 出现奇数次
            if (t[i].b <= 1) b[u]++; // 该子树可以对称，计数+1
            else b[u] = 2; // 该子树不能对称，直接标记不合法
        }
        lst = i+1;
    }
}
```
* **代码解读**：
  - 先把子节点的哈希排序，相同哈希的会排在一起；
  - 遍历排序后的数组，统计每个哈希的出现次数：如果出现奇数次，检查该子树是否对称（`t[i].b <=1`）；
  - 最后，如果需要检查的子树数量≤1（`b[u] <=1`），则父节点对称。
* 💡 **学习笔记**：排序是处理“相同元素计数”的常用方法，适合新手理解！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解树哈希和对称判断的过程，我设计了一个**8位像素风动画**——《像素树的对称之旅》！
</visualization_intro>

### 动画设计概览
* **风格**：FC红白机风格（16色调色板），节点是16x16的像素方块，根节点在屏幕顶部，子节点向下展开；
* **核心内容**：演示树哈希计算、子节点配对、递归判断对称的全过程；
* **交互设计**：支持“单步执行”“自动播放”（速度滑块）、“重置”，点击节点可展开子树。

### 动画帧详细步骤
1. **初始化场景**：
   - 屏幕显示一棵像素树（比如样例1的6节点树），根节点（1号）是红色，子节点（5、6、2号）是蓝色；
   - 控制面板在屏幕右侧：“开始”“单步”“重置”按钮，速度滑块（1x~5x）；
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **计算树哈希**：
   - 从叶子节点（3、4号）开始，每个节点的哈希值用颜色表示（比如3号哈希是黄色，4号也是黄色）；
   - 父节点（2号）的哈希是子节点哈希的混淆和（黄色+黄色→橙色），播放“滴”的音效；
   - 根节点（1号）的哈希是子节点（5、6、2号）哈希的混淆和（比如5号绿色、6号绿色、2号橙色→紫色）。

3. **子节点配对**：
   - 根节点的子节点（5、6、2号）中，5和6的哈希都是绿色（同构），会“闪烁+靠拢”到对称位置（左1和右1），播放“叮”的音效；
   - 剩下的2号节点是中间子节点，会“放大+高亮”（橙色变亮），递归展开它的子树（3、4号）。

4. **递归判断中间子树**：
   - 2号节点的子节点（3、4号）哈希都是黄色（同构），配对成功，播放“叮”的音效；
   - 2号节点的对称性标记为“YES”，返回根节点。

5. **结果反馈**：
   - 整棵树对称，所有节点“彩虹闪烁”，播放胜利音效（比如《魂斗罗》的通关音乐）；
   - 屏幕显示“YES”，动画结束。

### 游戏化元素
- **关卡设计**：把算法步骤拆成“计算哈希→配对子节点→递归判断”三个小关卡，完成一个关卡会弹出像素星星奖励；
- **积分系统**：每成功配对一个子节点得10分，递归判断成功得20分，总分≥50分解锁“对称大师”成就；
- **AI演示**：点击“AI自动玩”，算法会像“贪吃蛇AI”一样自动执行，学习者可以观察每一步的变化。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
树哈希是处理**树同构问题**的核心技术，学会它可以解决很多类似问题！
</similar_problems_intro>

### 通用思路迁移
树哈希的应用场景包括：
1. 判断两棵树是否同构（比如模板题P5043）；
2. 统计树中不同构的子树数量（比如P2052）；
3. 找到树的重心并判断同构（比如P3435）。

### 洛谷练习推荐
1. **洛谷 P5043** - 【模板】树同构
   * 🗣️ **推荐理由**：树哈希的模板题，帮你巩固“计算树哈希+判断同构”的基础！
2. **洛谷 P2052** - [NOI2010] 能量采集
   * 🗣️ **推荐理由**：需要统计不同构的子树数量，是树哈希的进阶应用！
3. **洛谷 P3435** - [POI2006] MET-Subway
   * 🗣️ **推荐理由**：结合树的重心和树哈希，判断两棵树是否同构，难度适中！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的作者心得很有价值，一起来看看：
</insights_intro>

> **参考经验（来自作者 Hoks）**：“注意这题题面里的重点：你可以调整**一个点**的儿子顺序。我之前没注意到这点，疯狂WA3！”
>
> **点评**：这位作者的踩坑经历提醒我们——**读题要仔细！**题目中“只能调整一个点的儿子顺序”是关键条件（其实是每个点都可以调整自己的儿子顺序，作者可能理解错了，但核心是“调整儿子顺序”是允许的）。读题时要圈画关键词，避免因为误解题意而翻车！


<conclusion>
本次关于「Symmetree」的分析就到这里啦！树哈希是处理树同构问题的“瑞士军刀”，掌握它能解决很多树相关的问题。记住：**递归计算哈希+判断配对+递归对称**是核心思路，多练模板题就能熟练掌握！下次我们再一起探索更多树的奥秘～💪
</conclusion>

---
处理用时：114.10秒
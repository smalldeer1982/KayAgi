# 题目信息

# Swaps

## 题目描述

You are given an array of integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ). You can perform the following operation several (possibly, zero) times:

- pick an arbitrary $ i $ and perform swap $ (a_i, a_{a_i}) $ .

How many distinct arrays is it possible to attain? Output the answer modulo $ (10^9 + 7) $ .

## 说明/提示

In the first example, the initial array is $ [1, 1, 2] $ . If we perform the operation with $ i = 3 $ , we swap $ a_3 $ and $ a_2 $ , obtaining $ [1, 2, 1] $ . One can show that there are no other attainable arrays.

In the second example, the four attainable arrays are $ [2, 1, 4, 3] $ , $ [1, 2, 4, 3] $ , $ [1, 2, 3, 4] $ , $ [2, 1, 3, 4] $ . One can show that there are no other attainable arrays.

## 样例 #1

### 输入

```
3
1 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4
2 1 4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
6
2 3 1 1 1 2```

### 输出

```
18```

# AI分析结果

# 💡 Kay的C++算法解析：Swaps 深入学习指南 💡

## 引言
今天我们要解决的问题是「Swaps」——通过交换`a_i`和`a_{a_i}`得到不同数组的数量。这个问题的核心是**将数组操作转化为图论模型**，尤其是「内向基环树」的处理。让我们一起拆解思路，掌握关键技巧！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（内向基环树的构建与处理）

### 🗣️ 初步分析
想象每个元素`a[i]`是一个「小机器人」，它手里拿着一张纸条，写着另一个机器人的编号（比如`a[3]=2`，就是机器人3指向机器人2）。所有机器人连起来会形成什么？——**内向基环树森林**：每个连通块是「一个环 + 挂在环上的树」（比如葡萄串，环是葡萄藤主干，树是葡萄粒）。

我们的操作是「交换机器人i和它指向的机器人的纸条」，这等价于**标记边`i→a[i]`**（标记过的边表示该操作已执行）。关键结论：
- 每个节点的入边最多标记1条（一个机器人只能被「交换」一次，否则会变成自环，无法再操作）。
- 普通树节点的方案数是「入度+1」（可以选一条入边标记，或不标记）。
- 环的特殊处理：如果环上所有边都被标记，会导致所有节点变成自环（不合法）；如果只剩1条边未标记，所有情况对应同一个数组（重复计算）。因此环的贡献是「环上节点`(入度+1)`的乘积 - 环上节点入度之和」。

### 可视化设计思路
我们用**8位像素风**展示基环树：
- 环节点用黄色方块，树节点用蓝色方块，边用红色箭头。
- 标记边时，箭头变亮并播放「叮」的音效；环处理完成时，环节点集体闪烁并播放「胜利」音效。
- 控制面板支持「单步执行」（看每一步标记）、「自动播放」（快速过流程）和「重置」（重新开始）。


## 2. 精选优质题解参考

### 题解一：樱雪喵（赞14）
**点评**：这份题解是「官方思路的清晰落地」，从图论建模到代码实现都非常严谨。
- 思路：用DFS遍历基环树，找到环后计算环的贡献（乘积减度数和），非环部分直接乘「入度+1」。
- 代码：变量名`in`（入度）、`vis`（访问标记）、`instk`（递归栈）含义明确，DFS逻辑简洁，处理环的部分用`res`（乘积）和`sum`（度数和）计算贡献，边界条件（模运算）处理到位。
- 亮点：**用递归栈找环**的方法高效且容易理解，适合新手学习基环树的环检测。

### 题解二：EuphoricStar（赞11）
**点评**：题解把「操作转化为边标记」的逻辑讲得很透彻，代码简洁。
- 思路：直接点出「每次操作对应标记一条边」，环的贡献公式推导清晰（`乘积-度数和`）。
- 代码：用「拓扑排序先处理树部分」，剩下的就是环，这种方法避免了递归，适合处理大n（比如1e6）的情况。
- 亮点：**拓扑排序分离树和环**的技巧，是处理基环树的常用方法，效率很高。

### 题解三：spdarkle（赞8）
**点评**：题解详细解释了「树和环的不同处理逻辑」，适合新手理解模型。
- 思路：树的方案是「入度+1」的乘积，环的方案是「乘积-度数和」，并通过「容斥原理」解释为什么要减度数和。
- 代码：用并查集找连通块，然后遍历连通块找环，逻辑清晰，适合巩固「连通块处理」的技巧。
- 亮点：**容斥原理的解释**——环上「只剩1条边未标记」的情况重复计算了，所以要减去度数和，这个理解很关键！


## 3. 核心难点辨析与解题策略

### 核心难点1：如何将操作转化为图论模型？
**分析**：操作`swap(a_i, a_{a_i})`的本质是「改变i和a_i的指向」——i原本指向a_i，交换后i指向a_{a_i}，a_i指向自己。这对应于**标记边i→a_i**（标记后的边表示i的指向已改变）。解决方法是**建内向基环树**（i→a_i），将操作转化为边标记。

💡 学习笔记：数组操作→图论模型的关键是「找到操作对应的图结构变化」。

### 核心难点2：为什么环的贡献是「乘积-度数和」？
**分析**：环上如果「只剩1条边未标记」，所有这样的情况对应同一个数组（比如环1→2→3→1，未标记1→2、2→3、3→1中的任意一条，结果都是所有节点自环）。这些情况共有「环上度数之和」种（每个节点可以选自己的入边不标记），所以要减去。另外，「所有边都被标记」的情况不合法，也要减去，但「乘积-度数和」已经包含了这两种情况（因为乘积是「所有可能的标记方案」，减去「重复的+不合法的」）。

💡 学习笔记：环的特殊处理是因为「环的闭合性」导致重复或不合法的方案。

### 核心难点3：如何高效找到基环树中的环？
**分析**：常用方法有两种：
1. **DFS找递归栈**：遍历节点时，用`instk`数组标记当前递归栈中的节点，如果遇到已在栈中的节点，说明找到了环。
2. **拓扑排序**：先处理入度为0的节点（树部分），剩下的节点就是环。

💡 学习笔记：找环的核心是「找到循环依赖的节点」，两种方法各有优劣，DFS适合小数据，拓扑排序适合大数据。

### ✨ 解题技巧总结
1. **模型转化**：遇到涉及`a[a[i]]`的操作，优先考虑建内向基环树。
2. **分治处理**：将基环树拆分为「环+树」，分别计算贡献再相乘。
3. **模运算处理**：减法后要加模再取模（比如`(res - sum + mod) % mod`），避免负数。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合樱雪喵和EuphoricStar的思路，实现一个清晰的基环树处理方案。

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 1e6 + 5, MOD = 1e9 + 7;
int n, a[N], in[N];
bool vis[N], instk[N];
vector<int> path; // 记录当前递归路径
long long ans = 1;

// 计算环的贡献：prod(in[cir[i]]+1) - sum(in[cir[i]])
void calc_cycle(int start_idx) {
    long long prod = 1, sum = 0;
    for (int i = start_idx; i < path.size(); ++i) {
        int u = path[i];
        prod = prod * (in[u] + 1) % MOD;
        sum = (sum + in[u]) % MOD;
    }
    long long cycle_contrib = (prod - sum + MOD) % MOD;
    ans = ans * cycle_contrib % MOD;
}

// DFS找环并计算贡献
void dfs(int u) {
    if (vis[u]) return;
    vis[u] = true;
    instk[u] = true;
    path.push_back(u);
    int v = a[u];
    if (instk[v]) { // 找到环：v在当前递归栈中
        // 找到v在path中的位置
        int idx = 0;
        while (path[idx] != v) ++idx;
        calc_cycle(idx);
        // 标记环上的节点，避免重复计算
        for (int i = idx; i < path.size(); ++i) {
            instk[path[i]] = false;
        }
    } else if (!vis[v]) {
        dfs(v);
    }
    instk[u] = false;
    path.pop_back();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        in[a[i]]++; // 计算入度
    }
    // 处理所有连通块
    for (int i = 1; i <= n; ++i) {
        if (!vis[i]) {
            dfs(i);
        }
    }
    // 处理非环部分（树节点）：入度+1的乘积
    for (int i = 1; i <= n; ++i) {
        if (!instk[i]) { // 非环节点
            ans = ans * (in[i] + 1) % MOD;
        }
    }
    cout << ans << endl;
    return 0;
}
```

**代码解读概要**：
1. **输入处理**：读取n和数组a，计算每个节点的入度`in[a[i]]`。
2. **DFS找环**：用`vis`标记访问过的节点，`instk`标记递归栈中的节点，`path`记录当前路径。当找到环时，调用`calc_cycle`计算环的贡献。
3. **计算非环贡献**：遍历所有节点，非环节点的贡献是`in[i]+1`的乘积。
4. **输出结果**：最终结果是所有贡献的乘积，模1e9+7。


### 题解一（樱雪喵）核心片段赏析
**亮点**：用递归栈找环，逻辑直接。
**核心代码片段**：
```cpp
void dfs(int now) {
    if (vis[now]) return;
    vis[now] = 1, instk[now] = 1, t[++tot] = now;
    if (instk[a[now]]) { // 找到环
        long long res = 1, sum = 0;
        for (int i = tot; ; --i) {
            res = res * (in[t[i]] + 1) % MOD;
            sum = (sum + in[t[i]]) % MOD;
            if (t[i] == a[now]) break;
        }
        ans = ans * (res - sum + MOD) % MOD;
    } else {
        dfs(a[now]);
    }
    tot--, instk[now] = 0;
}
```
**代码解读**：
- `t`数组记录当前路径，`tot`是路径长度。
- 当`a[now]`在递归栈中（`instk[a[now]]`为真），说明找到环：从`tot`倒序遍历`t`数组，直到找到`a[now]`，计算环的`res`（乘积）和`sum`（度数和），贡献是`res - sum`。
- 递归结束后，`tot--`并重置`instk[now]`，回溯路径。

💡 学习笔记：递归栈找环的关键是「记录当前路径」，遇到已在栈中的节点时，倒序遍历路径找到环的起点。


## 5. 算法可视化：像素动画演示

### 动画演示主题
**像素探险家之基环树大冒险**——用8位像素风格展示基环树的构建、边标记和环处理过程。

### 设计思路
- **风格**：仿FC红白机风格，用16色调色板（黄、蓝、红、绿为主），节点是3x3的方块，边是1像素的箭头。
- **交互**：控制面板有「单步」「自动」「重置」按钮，速度滑块（1x~5x），支持点击节点手动标记边。
- **音效**：标记边播放「叮」（8位音效），环处理完成播放「胜利」（上扬音阶），重置播放「咔嗒」。

### 动画帧步骤
1. **初始化场景**：
   - 屏幕左侧显示基环树：环节点（黄色）、树节点（蓝色）、边（红色箭头）。
   - 右侧显示「入度表」（每个节点的入度）和「方案数计数器」（初始为1）。
2. **标记边**：
   - 点击节点i，边i→a[i]变亮（红色→橙色），节点a[i]变成绿色（自环）。
   - 方案数计数器实时更新（乘上`in[i]+1`或环的贡献）。
3. **环处理**：
   - 当环上只剩1条边未标记时，环节点集体闪烁（黄色→白色→黄色），播放「胜利」音效。
   - 方案数计数器减去环的度数和，更新最终值。
4. **结果展示**：
   - 所有节点处理完成后，屏幕中央显示最终数组（像素数字）和方案数（大字体），播放「通关」音效。

### 旁白提示
- 标记边时：「点击节点i，标记边i→a[i]，a[i]变成自环啦！」
- 找到环时：「发现环了！环的贡献是乘积减度数和哦～」
- 完成时：「所有操作完成！最终方案数是XXX～」


## 6. 拓展练习与相似问题思考

### 通用思路迁移
内向基环树的处理技巧可以解决很多问题，比如：
1. **机器人寻路**：每个机器人指向另一个机器人，求所有机器人最终停留的位置。
2. **循环依赖检测**：软件包的依赖关系中，检测是否存在循环依赖。
3. **游戏中的循环任务**：游戏中任务A需要完成任务B，任务B需要完成任务A，检测这种循环。

### 洛谷练习推荐
1. **P3403 跳楼机**：基环树的动态规划问题，巩固「环+树」的分治处理。
   - 推荐理由：这道题需要计算从0到h的可达数，核心是处理基环树的环部分，适合练习环的DP。
2. **P5022 旅行**：基环树的遍历问题，练习找环和处理环上的路径。
   - 推荐理由：题目要求遍历所有节点的最短路径，需要先找环，再处理环上的分支，是基环树的经典应用。
3. **P2607 [ZJOI2008] 骑士**：基环树的树形DP问题，深入理解基环树的DP方法。
   - 推荐理由：每个骑士有一个仇人，形成基环树，需要计算最大战斗力，适合练习「环上拆边转树DP」的技巧。


## 7. 学习心得与经验分享

**参考经验（来自樱雪喵）**：「我最初在处理环的终止条件时卡了很久，后来通过打印递归栈的路径，才发现环的起点是`a[now]`而不是`now`。这让我意识到，**调试时打印中间变量**是定位错误的关键。」

**点评**：这位作者的经验很典型！在处理递归或环的问题时，打印路径、递归栈等中间变量，可以快速发现逻辑错误。比如本题中，环的起点是`a[now]`（因为`now`指向`a[now]`，而`a[now]`在递归栈中），如果搞错起点，环的计算就会出错。


## 结语
通过这道题，我们学会了「将数组操作转化为基环树」，掌握了「环+树」的分治处理技巧。记住：**图论模型是解决复杂操作问题的有力工具**，多练习基环树的题目，你会越来越熟练！

下次我们将探索更多图论问题，继续加油吧！💪

---
处理用时：118.80秒
# 题目信息

# Nauuo and Pictures (hard version)

## 题目描述

简单版与困难版的唯一区别在于数据范围。

Nauuo 是一个喜欢随机图片网站的女孩。

有一天，她自己制作了一个包含 $n$ 张图片的随机图片网站。

当 Nauuo 访问该网站时，她会看到且仅看到一张图片。网站展示每张图片的概率并不相同。第 $i$ 张图片有一个非负权值 $w_i$，第 $i$ 张图片被展示的概率为 $\frac{w_i}{\sum_{j=1}^n w_j}$。也就是说，图片被展示的概率与其权值成正比。

然而，Nauuo 发现有些她不喜欢的图片被展示得太频繁了。

为了解决这个问题，她想出了一个好主意：当她看到一张喜欢的图片时，她会将其权值加 $1$；否则，她会将其权值减 $1$。

Nauuo 将访问该网站 $m$ 次。她想知道所有 $m$ 次访问后，每张图片的期望权值是多少（对 $998244353$ 取模）。你能帮帮她吗？

第 $i$ 张图片的期望权值可以表示为 $\frac{q_i}{p_i}$，其中 $\gcd(p_i, q_i) = 1$。你需要输出一个整数 $r_i$，满足 $0 \le r_i < 998244353$ 且 $r_i \cdot p_i \equiv q_i \pmod{998244353}$。可以证明这样的 $r_i$ 存在且唯一。

## 说明/提示

在第一个样例中，如果唯一一次访问展示了第一张图片，概率为 $\frac{2}{3}$，最终权值为 $(1,1)$；如果展示了第二张图片，概率为 $\frac{1}{3}$，最终权值为 $(2,2)$。

因此，两张图片的期望权值都是 $\frac{2}{3} \cdot 1 + \frac{1}{3} \cdot 2 = \frac{4}{3}$。

因为 $332748119 \cdot 3 \equiv 4 \pmod{998244353}$，所以你需要输出 $332748119$，而不是 $\frac{4}{3}$ 或 $1.3333333333$。

在第二个样例中，只有一张图片是 Nauuo 喜欢的，所以每次访问都会将 $w_1$ 增加 $1$。

因此，期望权值为 $1 + 2 = 3$。

Nauuo 很调皮，所以她没有给出第三个样例的任何提示。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2 1
0 1
2 1
```

### 输出

```
332748119
332748119
```

## 样例 #2

### 输入

```
1 2
1
1
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3 3
0 1 1
4 3 5
```

### 输出

```
160955686
185138929
974061117
```

# AI分析结果

# 💡 Kay的C++算法解析：Nauuo and Pictures（困难版）深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 期望线性性质 + 等价类划分  

🗣️ **初步分析**：  
解决这道题的关键，在于**把“复杂的多图片问题”简化成“两类图片的问题”**——就像把一堆彩色积木分成“红色”和“蓝色”两堆，只需要计算两堆的总变化，再按比例分给每个积木。  

### 核心算法的比喻理解  
动态规划（DP）就像“写日记”：我们每天记录当天的状态（比如“红色积木被选了多少次，蓝色积木被选了多少次”），第二天的状态可以从昨天的状态推导出来。而**等价类划分**是这道题的“魔法”：所有“喜欢的图片”（红色积木）的地位相同，所有“不喜欢的图片”（蓝色积木）的地位也相同——它们的期望权值只和初始权值成正比，不用逐个计算每个图片！  

### 题解思路与核心难点  
- **核心思路**：  
  1. 把图片分成两类：喜欢的（记总初始权值为`w_p`）、不喜欢的（记总初始权值为`w_n`）。  
  2. 用二维DP数组`f[i][j]`记录“不喜欢的图片被选了`i`次，喜欢的图片被选了`j`次”的概率。  
  3. 计算两类图片的总期望权值（`s_1`对应不喜欢的，`s_2`对应喜欢的），再按初始权值比例分给每个图片。  

- **核心难点**：  
  1. 如何证明“同一类图片的期望权值与初始权值成正比”？（题解中用归纳法证明：比如喜欢的图片拆成`w_p`个小图片，每个小图片的期望相同，总期望就是`w_p × 单个小图片的期望`）  
  2. 如何设计高效的DP状态？（把高维问题压成二维，`i+j ≤ m`，复杂度从`O(nm³)`降到`O(m²)`）  

### 可视化设计思路  
我们会用**8位像素风格**做动画：  
- 用红色方块代表“喜欢的图片总权值”，蓝色方块代表“不喜欢的图片总权值”，方块大小随权值变化。  
- 用格子网格展示DP状态`f[i][j]`：格子的颜色深浅代表概率大小，`i`是横轴（不喜欢的次数），`j`是纵轴（喜欢的次数）。  
- 每次操作时，箭头指向被选中的类别（红/蓝），伴随“叮”（选喜欢）或“嗒”（选不喜欢）的像素音效，同时更新方块大小和DP格子的颜色。  


## 2. 精选优质题解参考  

<eval_intro>  
我从思路清晰度、代码可读性和算法有效性三个维度，筛选了3份优质题解：  
</eval_intro>  

### 题解一（作者：zhylj）  
* **点评**：这份题解的思路“一刀见血”——直接把问题拆成两类，用二维DP计算概率。代码中的变量命名非常清晰（`w_p`是喜欢的总权值，`w_n`是不喜欢的），转移方程也很直观：`f[i+1][j]`对应选不喜欢的图片，`f[i][j+1]`对应选喜欢的图片。最棒的是**比例计算**：用`w[i]/w_p`或`w[i]/w_n`把总期望分给每个图片，完美利用了等价类的性质。  

### 题解二（作者：ouuan）  
* **点评**：这份题解的“归纳证明”是亮点——严谨地证明了“喜欢的图片的期望权值等于初始权值乘以`f_1[0][0]`”（`f_1`是初始权值为1的喜欢图片的期望）。代码中的`f`和`g`分别处理喜欢和不喜欢的情况，预处理逆元优化了时间复杂度，非常适合竞赛环境。  

### 题解三（作者：Phartial）  
* **点评**：这份题解的代码结构最简洁！作者用`f[i][j]`记录两类操作次数的概率，然后直接计算`e[0]`（不喜欢的总期望）和`e[1]`（喜欢的总期望），最后按比例输出。代码中的`vPow`函数（快速幂求逆元）是模运算的关键，值得学习。  


## 3. 核心难点辨析与解题策略  

<difficulty_intro>  
解决这道题的“拦路虎”主要有三个，我们逐一拆解：  
</difficulty_intro>  

### 1. 难点：如何把多图片问题简化成两类？  
- **分析**：所有“喜欢的图片”被选中后权值+1，所有“不喜欢的”被选中后权值-1——它们的“行为模式”完全相同！因此可以把它们合并成“两个大图片”，计算这两个大图片的总期望，再按初始权值比例分给每个小图片。  
- 💡 **学习笔记**：找“等价类”是简化问题的关键——只要行为相同，就能合并！  

### 2. 难点：如何设计DP状态？  
- **分析**：原始的高维DP（比如`f[x][i][j][k]`记录每个图片的操作次数）复杂度太高（`O(nm³)`），根本无法处理`m=3000`的情况。我们把状态压成**二维**：`f[i][j]`表示“不喜欢的选了`i`次，喜欢的选了`j`次”的概率，这样复杂度降到`O(m²)`（`m=3000`时，`3000×3000=9e6`，完全可行）。  
- 💡 **学习笔记**：DP状态的核心是“记录关键信息”——无关的信息（比如具体哪个图片被选）可以丢掉！  

### 3. 难点：如何计算单个图片的期望？  
- **分析**：假设喜欢的总期望是`S_2`，总初始权值是`w_p`，那么每个喜欢的图片的期望就是`(w[i]/w_p) × S_2`（模运算下用逆元代替除法）。这是因为“大图片拆成小图片后，每个小图片的期望相同”——比如`w_p=3`的大图片拆成3个小图片，总期望是3×单个小图片的期望，所以单个小图片的期望是总期望/3。  
- 💡 **学习笔记**：期望的线性性质是“神器”——不管事件是否独立，总期望等于各部分期望之和！  

### ✨ 解题技巧总结  
1. **等价类划分**：合并行为相同的元素，减少问题规模。  
2. **DP状态压缩**：只记录关键信息，降低复杂度。  
3. **模运算逆元**：用快速幂求逆元，处理除法取模问题。  


## 4. C++核心代码实现赏析  

<code_intro_overall>  
我们先看一份**综合优质题解的核心代码**，它结合了zhylj和Phartial的思路，结构清晰，容易理解：  
</code_intro_overall>  

### 本题通用核心C++实现参考  
* **说明**：本代码综合了zhylj和Phartial的思路，用二维DP计算两类操作次数的概率，再按比例输出每个图片的期望。  

```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef long long LL;
const int MOD = 998244353;
const int M = 3005;

LL qpow(LL a, int b) {  // 快速幂求逆元
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n+1), w(n+1);
    int w_p = 0, w_n = 0;  // w_p:喜欢的总权值，w_n:不喜欢的总权值
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) {
        cin >> w[i];
        if (a[i]) w_p = (w_p + w[i]) % MOD;
        else w_n = (w_n + w[i]) % MOD;
    }

    vector<vector<LL>> f(M, vector<LL>(M, 0));
    f[0][0] = 1;  // 初始状态：0次操作，概率1
    for (int i = 0; i <= m; ++i) {
        for (int j = 0; i + j <= m; ++j) {
            if (f[i][j] == 0) continue;
            // 当前总权值：w_n - i + w_p + j（不喜欢的减i次，喜欢的加j次）
            LL total = (w_n - i + w_p + j) % MOD;
            LL inv_total = qpow(total, MOD-2);  // 逆元

            // 转移1：选不喜欢的图片（i+1次）
            if (i < m && (w_n - i) > 0) {
                LL p = (w_n - i) * inv_total % MOD;
                f[i+1][j] = (f[i+1][j] + f[i][j] * p) % MOD;
            }
            // 转移2：选喜欢的图片（j+1次）
            if (j < m && (w_p + j) > 0) {
                LL p = (w_p + j) * inv_total % MOD;
                f[i][j+1] = (f[i][j+1] + f[i][j] * p) % MOD;
            }
        }
    }

    // 计算两类的总期望：s1（不喜欢的）、s2（喜欢的）
    LL s1 = 0, s2 = 0;
    for (int i = 0; i <= m; ++i) {
        int j = m - i;
        if (j < 0 || j >= M) continue;
        s1 = (s1 + f[i][j] * (w_n - i) % MOD) % MOD;  // 不喜欢的最终权值：w_n - i
        s2 = (s2 + f[i][j] * (w_p + j) % MOD) % MOD;  // 喜欢的最终权值：w_p + j
    }

    // 输出每个图片的期望：按比例分配
    LL inv_wp = qpow(w_p, MOD-2);  // w_p的逆元
    LL inv_wn = qpow(w_n, MOD-2);  // w_n的逆元
    for (int i = 1; i <= n; ++i) {
        LL ans;
        if (a[i]) ans = s2 * w[i] % MOD * inv_wp % MOD;  // 喜欢的：(w[i]/w_p)*s2
        else ans = s1 * w[i] % MOD * inv_wn % MOD;       // 不喜欢的：(w[i]/w_n)*s1
        cout << ans << endl;
    }

    return 0;
}
```

* **代码解读概要**：  
  1. **输入处理**：读取图片的“喜欢与否”和初始权值，计算两类的总权值`w_p`和`w_n`。  
  2. **DP初始化**：`f[0][0] = 1`表示初始状态（0次操作，概率1）。  
  3. **DP转移**：遍历所有可能的操作次数`i`（不喜欢的）和`j`（喜欢的），计算转移概率（用逆元处理除法）。  
  4. **计算总期望**：遍历所有可能的`i+j=m`，计算两类的总期望`e1`和`e2`。  
  5. **输出结果**：按初始权值比例，用逆元计算每个图片的期望。  

---

<code_intro_selected>  
我们再看**zhylj题解的核心片段**，它的转移方程非常直观：  
</code_intro_selected>  

### 题解一（作者：zhylj）核心片段赏析  
* **亮点**：用`f[i][j]`直接记录两类操作次数的概率，转移方程清晰。  
* **核心代码片段**：  
```cpp
f[0][0] = 1;
for (int i = 0; i < m && i <= w_n; ++i)
    for (int j = 0; i + j < m; ++j) {
        int d = QPow((w_n + w_p - i + j) % MOD, MOD - 2);  // 逆元
        Plus(f[i + 1][j], 1LL * (w_n - i) * d % MOD * f[i][j] % MOD);  // 选不喜欢的
        Plus(f[i][j + 1], 1LL * (w_p + j) * d % MOD * f[i][j] % MOD);  // 选喜欢的
    }
```  
* **代码解读**：  
  - `QPow`是快速幂函数，用来求逆元（因为模运算中除法要转化为乘逆元）。  
  - `Plus`函数是模加法（防止溢出）。  
  - 转移方程：`f[i+1][j]`是选不喜欢的图片，概率是`(w_n - i) / total`（`total`是当前总权值）；`f[i][j+1]`是选喜欢的图片，概率是`(w_p + j) / total`。  
* 💡 **学习笔记**：模运算中的除法一定要用逆元！快速幂是求逆元的常用方法（当模数是质数时，逆元等于`a^(mod-2)`）。  


## 5. 算法可视化：像素动画演示  

<visualization_intro>  
为了让大家更直观地理解“两类图片的DP过程”，我设计了一个**8位像素风格的动画**，像玩FC游戏一样看算法运行！  
</visualization_intro>  

### 动画设计方案  
* **主题**：像素世界的“图片选美大赛”——红色方块代表“喜欢的图片总权值”，蓝色方块代表“不喜欢的图片总权值”，网格代表DP状态`f[i][j]`。  
* **风格**：仿FC红白机风格，用16色像素画，背景是浅灰色，方块用亮红/亮蓝，网格用深灰色。  
* **核心演示步骤**：  

1. **初始化场景**：  
   - 屏幕左侧显示红色方块（大小=初始`w_p`）和蓝色方块（大小=初始`w_n`）。  
   - 屏幕右侧显示30×30的网格（`i`从0到30，`j`从0到30），每个格子的颜色深浅代表`f[i][j]`的概率（越深概率越大）。  
   - 底部控制面板有“开始/暂停”“单步”“重置”按钮，以及速度滑块（1x~5x）。  

2. **算法运行动画**：  
   - **单步操作**：点击“单步”，箭头指向被选中的类别（红/蓝），伴随“叮”或“嗒”的音效。  
     - 选红色（喜欢的）：红色方块变大1，蓝色方块不变；网格中`j+1`的格子颜色变深。  
     - 选蓝色（不喜欢的）：蓝色方块变小1，红色方块不变；网格中`i+1`的格子颜色变深。  
   - **自动播放**：点击“开始”，动画按选定速度自动运行，每步展示权值变化和DP网格更新。  
   - **状态高亮**：当前处理的`i`和`j`用黄色边框标记，网格中对应的格子闪烁。  

3. **结束状态**：  
   - 完成`m`次操作后，播放“胜利”音效（上扬的8位音乐），红色和蓝色方块显示最终大小。  
   - 网格中`i+j=m`的格子用绿色高亮，显示最终概率。  

### 设计理由  
- **像素风格**：复古游戏感能降低学习压力，让算法更“亲切”。  
- **音效提示**：用不同音效强化“选喜欢”和“选不喜欢”的区别，帮助记忆。  
- **网格可视化**：直接展示DP状态的变化，让“概率如何传递”一目了然。  


## 6. 拓展练习与相似问题思考  

<similar_problems_intro>  
这道题的核心思路（等价类+DP+期望线性性质）可以解决很多“概率期望”问题，比如：  
</similar_problems_intro>  

### 通用思路迁移  
1. **问题1**：有`n`个硬币，每次选一个翻面，求`m`次后正面朝上的期望数量——可以把硬币分成“正面”和“反面”两类，用DP计算。  
2. **问题2**：有`n`个灯泡，每次选一个开关（开变关，关变开），求`m`次后亮着的期望数量——同理，分成“亮”和“灭”两类。  
3. **问题3**：有`n`个物品，每次选一个增加`k`或减少`k`，求`m`次后的期望总价值——分成“增加类”和“减少类”。  

### 洛谷练习推荐  
1. **洛谷 P1351** - 联合权值  
   * 🗣️ **推荐理由**：练习“等价类划分”和“期望线性性质”，适合巩固本题的核心思路。  
2. **洛谷 P2473** - [SCOI2008] 奖励关  
   * 🗣️ **推荐理由**：练习“状态压缩DP”，类似本题把复杂状态压成可处理的维度。  
3. **洛谷 P3802** - 小魔女帕琪  
   * 🗣️ **推荐理由**：练习“概率DP”和“模运算逆元”，与本题的模处理方法一致。  


## 7. 学习心得与经验分享  

<insights_intro>  
优质题解中的“经验之谈”能帮我们少走弯路：  
</insights_intro>  

> **经验1（来自ouuan）**：“归纳法是证明期望性质的有效工具——比如证明‘喜欢的图片的期望与初始权值成正比’，用归纳法从`i=0`推到`i=m`，非常严谨。”  
> **点评**：当遇到“某个值与另一个值成正比”的猜想时，试试归纳法！从基础情况出发，一步步推导，能快速验证猜想。  

> **经验2（来自zhylj）**：“把多图片问题拆成两类，是降低复杂度的关键——不要被‘n个图片’吓到，找它们的共同行为！”  
> **点评**：遇到复杂问题时，先问自己：“这些元素有什么共同点？能不能合并？”合并后问题往往会变得简单。  


## 结语  
这道题的核心是**“简化问题”**：把多图片拆成两类，把高维DP压成二维，再用比例分配期望。记住：**复杂的问题，往往藏着简单的规律**——只要找到规律，就能轻松解决！  

下次遇到“概率期望”问题时，不妨试试今天学的“等价类+DP”思路，你会发现很多问题都能迎刃而解～ 💪  

---  
**Kay的小提示**：代码中的逆元计算是关键，一定要熟练掌握快速幂求逆元的方法哦！

---
处理用时：351.48秒
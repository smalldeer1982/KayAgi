# 题目信息

# New Year and the Acquaintance Estimation

## 题目描述

Bob是社交网站`FaithBug`上的一名活跃用户。在这个网站上，人们之间的友情是相互的。这就是说，如果 $a$ 是 $b$ 的一个朋友，那么 $b$ 也是 $a$ 的一个朋友。因此，每个用户都有不小于 $0$ 个朋友。



这个早晨，一个匿名用户给Bob发送了这个链接：[graph realization problem](https://en.wikipedia.org/wiki/Graph_realization_problem)。Bob想要知道那人是谁。为了知道这件事，他首先得知道这个社交网络的形态。他查看了网站上所有其他人的个人信息，并且记下了他们的朋友数量。然而，他忘了记下自己的朋友数量！请帮他计算他可能的朋友数量。如果有多解，全部输出。



简化版：给出一个长度为 $n$ 的度数序列，问是否存在一个大小为 $n+1$ 的简单无向图，满足给定的度数序列是这个图的度数序列的前缀。

## 说明/提示

$1\leq n\leq 5\times 10^5, 0\leq a_i\leq n$





第一个样例中，唯一的可能情况是，每个人都是所有其他人的朋友。因此，Bob有三个朋友。



第二个样例中，有三种可能的非等价情况：



1. $a$ 是 $b$ 的朋友， $c$ 是 $d$ 的朋友，然而Bob没有朋友。

2. $a$ 是 $b$ 的朋友， $c$ 和 $d$ 都是Bob的朋友。

3. Bob是所有人的朋友。



第三个样例是不可能的，因为第二个人应该是所有人的朋友，然而第一个人却没有朋友。

## 样例 #1

### 输入

```
3
3 3 3
```

### 输出

```
3 
```

## 样例 #2

### 输入

```
4
1 1 1 1
```

### 输出

```
0 2 4 
```

## 样例 #3

### 输入

```
2
0 2
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
35
21 26 18 4 28 2 15 13 16 25 6 32 11 5 31 17 9 3 24 33 14 27 29 1 20 4 12 7 10 30 34 8 19 23 22
```

### 输出

```
13 15 17 19 21 
```

# AI分析结果


# 💡 Kay的C++算法解析：New Year and the Acquaintance Estimation 深入学习指南 💡

<introduction>
今天我们来分析"New Year and the Acquaintance Estimation"这道图论题目。本指南将帮助你掌握度数序列可图化判定的核心算法，理解Erdős–Gallai定理的应用，并通过像素动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论`（度数序列可图化判定）与`数学不等式`

🗣️ **初步分析**：
> 这道题要求我们确定Bob可能的度数，使得整个度数序列可构成简单无向图。核心算法基于**Erdős–Gallai定理**（EG定理），它就像一个"图构建资格检查表"：我们需要验证每个前缀的度数和不超过该前缀内部最大边数加上与其他点的可能连接数。在本题中，这个定理被用于高效检查插入Bob度数后的序列是否合法。
   
   - **主要解法**：基于握手定理（度数和必须为偶数），答案具有相同奇偶性且通常连续。高效解法包括二分答案（O(n log n)）和差分数组(O(n))两种思路。
   - **核心难点**：如何高效实现EG定理的检查？通过降序排序+预处理前缀/后缀和，将单次检查优化到O(n)或O(1)。
   - **可视化设计**：我们将设计像素动画展示EG定理检查过程：用不同颜色方块表示度数，高亮当前检查的前缀k区域，动态显示不等式左右部分计算过程，通过颜色变化和音效反馈检查结果。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法效率和实现技巧等维度，精选了以下高质量题解：
</eval_intro>

**题解一（作者：凄魉）**
* **点评**：思路清晰解释了EG定理和Havel-Hakimi算法的关系，创新性地使用差分数组实现O(n)解法。代码结构规范（如`lml`、`lmr`数组命名合理），边界处理严谨（`min`函数防止越界）。亮点在于预处理前缀/后缀和数组，并用线段树优化区间查询，大幅提升效率。实践价值高，可直接用于竞赛场景。

**题解二（作者：SovietPower）**
* **点评**：采用二分答案框架，思路直观易懂。代码结构清晰（分离检查函数），变量命名合理（`vl`、`vr`明确表示不等式两侧）。亮点在于二分方向的智能判断：当不等式不满足时，根据当前度数与Bob度数的关系调整二分方向。虽然复杂度O(n log n)略高，但实现更简单，适合快速解题。

**题解三（作者：__Hacheylight__）**
* **点评**：侧重EG定理的数学解释，提供差分数组的另一种实现视角。代码中`bal`数组记录合法区间的方式富有启发性，`res`动态收集答案的做法简洁高效。亮点在于将每个k的检查转化为对Bob度数的区间约束，最后通过差分累加得到解集。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下关键难点，结合优质题解的通用策略如下：
</difficulty_intro>

1.  **EG定理的高效实现**
    * **分析**：直接检查每个k的复杂度为O(n²)。优质解法通过**降序排序**后，利用**前缀/后缀和**快速计算不等式右侧的`min(d_i,k)`部分。维护指针j跟踪第一个≥k的元素位置，将计算优化至O(1)。
    * 💡 **学习笔记**：排序+预处理是优化EG定理检查的核心技巧。

2.  **答案区间的连续性证明**
    * **分析**：基于"调整朋友关系"的图变换思想（断开一对连接，让双方与Bob连接可使Bob度数+2）。所有解法都利用了答案在固定奇偶性下连续的观察，避免无效枚举。
    * 💡 **学习笔记**：发现答案的连续性特征能大幅降低问题复杂度。

3.  **边界条件与无解处理**
    * **分析**：需处理k>n等边界情况（如`min(n-k, j)`防止越界）。无解情况通过最终解集为空判断，或检查总度数和奇偶性提前筛选。
    * 💡 **学习笔记**：健壮的代码必须考虑所有临界场景，特别是序列头尾位置。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可提炼以下通用解题技巧：
</summary_best_practices>
-   **定理转化技巧**：将图存在问题（EG定理）转化为不等式组问题
-   **预处理优化**：前缀和、后缀和、指针维护将复杂计算降至O(1)
-   **答案连续性利用**：发现解集连续性特征避免无效枚举
-   **模块化检查**：将合法性检查封装独立函数（如二分法的Check函数）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是基于优质题解提炼的通用核心实现，采用差分数组法实现O(n)复杂度：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合凄魉与__Hacheylight__的差分法思路，优化可读性
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long LL;
    const int N = 500050;
    
    int n, a[N], ans[N], cnt;
    LL sum[N], suf[N];
    vector<int> bal; // 差分数组
    
    int main() {
        cin >> n;
        LL total = 0;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            total += a[i];
        }
        sort(a + 1, a + n + 1, greater<int>());
        
        // 预处理前缀和与后缀和
        for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];
        for (int i = n; i >= 1; i--) suf[i] = suf[i + 1] + a[i];
        
        // 初始化差分数组
        bal.resize(n + 2, 0);
        int j = n;
        for (int k = 1; k <= n; k++) {
            while (j > 0 && a[j] < k) j--;
            LL left = sum[k];
            LL right = 1LL * k * (k - 1);
            int up = min(n - k, j);
            right += suf[k + 1 + up] + 1LL * k * (n - k - up);
            
            // 计算不等式差值并更新差分数组
            LL diff = left - right;
            if (diff <= k) {
                int low = max(0LL, diff);
                int high = min(n, a[k]);
                if (low <= high) {
                    bal[low]++;
                    bal[high + 1]--;
                }
            }
        }
        
        // 收集合法答案
        int cur = 0;
        for (int x = total % 2; x <= n; x += 2) {
            cur += bal[x];
            if (cur == n) ans[cnt++] = x;
        }
        
        if (!cnt) cout << -1;
        else for (int i = 0; i < cnt; i++) cout << ans[i] << " ";
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **输入处理**：读入度数序列并计算总度数（用于确定答案奇偶性）
    > 2. **降序排序**：为EG定理检查做准备
    > 3. **前缀/后缀和预处理**：`sum[i]`为前i项和，`suf[i]`为i到n的和
    > 4. **差分数组更新**：对每个k计算不等式，转换为对Bob度数的区间约束
    > 5. **合法答案收集**：利用差分数组累加结果，收集满足所有k约束的度数

---
<code_intro_selected>
接下来分析精选题解的核心代码亮点：
</code_intro_selected>

**题解一（凄魉）线段树优化**
* **亮点**：用线段树加速区间最小值查询，确保O(n)复杂度
* **核心代码片段**：
    ```cpp
    // 构建lml数组（k<=i部分）
    for (int k = 1; k <= n; k++) {
        while (j && a[j] < k) j--;
        if (j >= k) 
            lml[k] = (LL)(j-1)*k + suf[j+1] - sum[k];
        else 
            lml[k] = suf[k+1] + (LL)k*(k-1) - sum[k];
    }
    ```
* **代码解读**：
    > 计算每个k的不等式差值`lml[k]`，通过指针j高效找到第一个≥k的元素位置。当j≥k时，前k个元素与后续元素的连接数由j分割计算；否则使用替代公式。这种分割计算避免了遍历，是效率关键。

**题解二（SovietPower）二分检查**
* **亮点**：二分框架下根据检查结果智能调整方向
* **核心代码片段**：
    ```cpp
    int Check(int mid) {
        // ... 插入mid并排序
        for (int k = 1; k <= n+1; k++) {
            LL left = 前k个度数和;
            LL right = k(k-1) + 后续min(d_i,k)和;
            if (left > right) 
                return (mid < d[k]) ? -1 : 1; // 关键调整策略
        }
        return 0;
    }
    ```
* **代码解读**：
    > 当不等式不成立时，通过比较当前mid与d[k]的大小决定二分方向：若mid < d[k]说明答案过小需增大，反之过大需减小。这种策略避免盲目二分，快速收敛到答案区间。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
下面设计一个8位像素风格的动画演示EG定理检查过程，让你直观感受算法每一步的数据变化！
</visualization_intro>

* **动画演示主题**："EG定理验证大冒险"（像素RPG风格）

* **核心演示内容**：降序排列的度数序列动态检查过程，重点展示：
  1. 每个k的前缀度数和计算（左式）
  2. 不等式右侧（k(k-1) + ∑min(d_i,k)）的组成
  3. 检查结果的视觉/听觉反馈

* **设计思路**：采用FC游戏风格，通过像素方块高度表示度数，颜色区分不同计算区域。游戏化关卡设计（每个k是一关）增强学习动力，音效强化关键操作记忆。

* **动画帧步骤与交互关键点**：

  1. **场景初始化**：
     - 8位像素风格界面，底部状态栏显示控制按钮
     - 度数序列显示为彩色像素柱（高度=度数），降序排列
     - 背景播放轻快8位音乐（循环）

  2. **检查过程演示**：
     ```plaintext
     Frame 1 (k=1):
        [■] [23] [19] [17] ... → 高亮第1个方块（红色边框）
        显示：left = 23, right = 0 + min(23,1)+min(19,1)+... = 1+1+... 
        结果：23 ≤ 5? 不成立 → 方块闪烁红光 + 失败音效
     
     Frame 2 (自动调整后):
        [■] [19] [17] ... → 新序列
        k=1: left=19, right=0+∑min=4 → 通过（绿光+胜利音效）
        k=2: 高亮前2个方块 [■][■] 
               left=19+17=36, right=2*1 + ∑min(...)=...
     ```

  3. **动态元素**：
     - **当前k标识**：像素箭头指向当前检查位置
     - **区域高亮**：前缀k区域（红色边框），提供min(d_i,k)的点（绿色填充）
     - **数据面板**：实时显示left/right计算式和数值
     - **音效反馈**：
        * 关键操作："叮"（比较）、"咔嚓"（通过检查）
        * 结果：上扬音效（成功），低沉音效（失败）

  4. **交互控制**：
     - 单步执行：空格键逐k检查
     - 自动播放：A键启动/暂停，速度滑块调节
     - 重置：R键重新开始
     - AI演示：D键自动完成所有检查

  5. **关卡进度系统**：
     - 每通过一个k获得1颗星星
     - 连续通过5个k触发"连击"特效
     - 所有检查通过后解锁"图构建大师"成就

* **技术实现**：
     ```javascript
     // 伪代码核心逻辑
     function drawFrame(k) {
        highlightPrefix(k); // 高亮前k个元素
        calculateLeft();    // 计算并显示左式和
        calculateRight();   // 计算右式（分解显示k(k-1)和min部分）
        if (left <= right) {
            playSuccessSound();
            addStar();
            animateGreenFlash();
        } else {
            playFailSound();
            animateRedFlash();
        }
     }
     ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握EG定理后，可尝试以下相似问题强化图论建模能力：
</similar_problems_intro>

* **通用思路迁移**：
  EG定理可扩展解决：
  1. 有向图度数序列判定（Fulkerson定理）
  2. 给定度数序列的图构建（Havel-Hakimi算法）
  3. 最大/最小可能边数问题

* **练习推荐 (洛谷)**：
  1. **P2445 [SDOI2005]度数序列**  
     → 直接应用EG定理判定序列合法性
  2. **P6268 [SHOI2002]舞会**  
     → 度数序列的实际构建问题
  3. **P3402 最长公共子序列**  
     → 锻炼序列处理能力，为复杂图论打基础

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验对我们很有价值：
</insights_intro>

> **参考经验 (来自凄魉)**：  
> "我在处理边界条件k与指针j的关系时多次出错，通过添加断言`assert(j >= 0 && j <= n)`才定位到越界问题。"

> **点评**：  
> 这提醒我们：在维护移动指针时务必添加边界检查，特别是`min(n-k, j)`这类复合表达式。在算法核心部分插入验证断言（Release模式移除）是高效调试技巧。

---

<conclusion>
本次"New Year and the Acquaintance Estimation"的解析到此结束。关键要掌握EG定理的数学本质和高效实现技巧，理解答案的连续性和奇偶性特征。通过像素动画演示希望帮助你直观理解算法流程。继续加油，下次挑战再见！💪
</conclusion>

---
处理用时：240.42秒
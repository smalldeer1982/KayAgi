# 题目信息

# Dish Shopping

## 题目描述

有 $m$ 个人居住在一座城市中。城市里有 $n$ 道菜品在售。每道菜 $i$ 有一个价格 $p_i$，一个标准 $s_i$ 和一个美观度 $b_i$。每个人 $j$ 有一个收入 $inc_j$ 和一个偏好美观度 $pref_j$。

一个人绝不会购买标准低于其收入的菜品。同时，一个人也买不起价格高于其收入的菜品。换句话说，某个人 $j$ 只有在 $p_i \leq inc_j \leq s_i$ 时才可以买第 $i$ 道菜。

此外，某个人 $j$ 只有在 $|b_i - pref_j| \leq (inc_j - p_i)$ 时才可以买第 $i$ 道菜。也就是说，如果菜品的价格比该人的收入低 $k$，那么该人只允许菜品的美观度与其偏好美观度的绝对差值最多为 $k$。

请输出城市中每个人能买到的菜品数量。

## 说明/提示

在第一个样例中，第一个人可以购买第 $2$ 道菜，第二个人可以购买第 $1$ 和第 $2$ 道菜，第三个人无法购买任何菜品。

在第二个样例中，第一个人无法购买任何菜品，第二个人可以购买第 $1$ 和第 $4$ 道菜，第三个人可以购买第 $1$、第 $2$ 和第 $4$ 道菜。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 3
2 1 3
2 4 4
2 1 1
2 2 3
1 2 4
```

### 输出

```
1 2 0 ```

## 样例 #2

### 输入

```
4 3
1 2 1 1
3 3 1 3
2 1 3 2
1 1 3
1 2 1
```

### 输出

```
0 2 3 ```

# AI分析结果


### 题目解读与核心算法识别
✨ **本题主要考察**：`扫描线+树状数组` 与 `CDQ分治`（三维偏序）  
🗣️ **初步分析**：  
> 解决「Dish Shopping」的关键在于 **将绝对值条件转化为几何约束**。想象每个人是平面上的点 $(inc_j, pref_j)$，每道菜对应一个三角形区域（如图）。通过扫描线按 $inc$ 排序事件（加入/删除/查询），用树状数组动态维护二维偏序，即可高效统计点在三角形内的数量。  

**核心难点与解法对比**：  
| **方法**          | **复杂度**       | **优势**                          | **可视化设计思路**                     |
|-------------------|-----------------|----------------------------------|---------------------------------------|
| 扫描线+树状数组     | $O((n+m)\log n)$ | 代码简洁，常数小                  | 横轴扫描 $inc$，纵轴树状数组更新像素块，高亮事件触发点 |
| CDQ分治           | $O(n\log^2 n)$  | 通用性强，易处理高维偏序          | 分治过程用递归树展示，每层归并时高亮比较元素       |

**像素动画方案**：  
- **8位游戏风格**：FC红白机像素风，网格横轴为 $inc$，纵轴为离散化值域  
- **关键动画**：  
  1. 扫描线移动（像素小车），遇到事件时播放「叮」音效  
  2. 树状数组更新：加入事件亮起绿色像素块，删除变红色  
  3. 查询时显示射线检测（类似《雷电》子弹轨迹）  
- **交互控制**：  
  - 步进/暂停：方向键控制  
  - 调速滑块：调整扫描速度  
  - AI演示模式：自动通关并显示最优路径  

---

### 精选优质题解参考
**题解一（xyz32768，扫描线+树状数组）**  
* **亮点**：  
  - **思路**：将条件转化为 $inc$ 扫描线上的动态二维数点，逻辑清晰  
  - **代码**：变量名规范（`que` 表事件，`A/B` 树状数组），边界处理严谨  
  - **优化**：离散化+树状数组实现 $O(n\log n)$，碾压其他解法  
  - **实践**：代码可直接用于竞赛，删除事件用 `op=-1` 巧妙处理  

**题解二（wsyhb，CDQ分治）**  
* **亮点**：  
  - **思路**：拆解为两个三维偏序问题，归并排序+树状数组实现  
  - **代码**：模块化（`CDQ`函数独立），离散化处理 $10^9$ 数据  
  - **调试**：注释强调「注意同第一维值的情况」，避免常见错误  

**题解三（Tx_Lcy，CDQ分治）**  
* **亮点**：  
  - **创新点**：特殊处理同第一维值（`Min/Max` 额外归并）  
  - **可读性**：递归树可视化调试思路，适合学习者理解分治本质  

---

### 核心难点辨析与解题策略
1. **难点1：绝对值条件转化**  
   - **分析**：$|b_i - pref_j| \leq inc_j - p_i$ 需拆解为两个不等式：  
     $$b_i + p_i \leq inc_j + pref_j \quad \text{和} \quad p_i - b_i \leq inc_j - pref_j$$  
   - **解决**：将每道菜映射为 $(b_i+p_i, b_i-p_i)$ 的几何约束  

2. **难点2：高维偏序处理**  
   - **分析**：组合后形成三维偏序（$inc_j, pref_j, b_i\pm p_i$）  
   - **解决**：  
     - **扫描线**：固定 $inc$ 扫描方向，树状数组维护 $pref$ 维度  
     - **CDQ分治**：第一维排序，第二维归并，第三维树状数组  

3. **难点3：离散化与常数优化**  
   - **分析**：$10^9$ 数据需离散化，树状数组比线段树更高效  
   - **解决**：统一离散化所有值（如 `a[]` 数组），用 `lower_bound` 映射  

💡 **学习笔记**：  
> 绝对值拆解 + 扫描线/CDQ = 高维偏序问题的通用解法  

---

### C++核心代码实现赏析
**本题通用核心实现（扫描线+树状数组）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, M = N << 2;

struct Event { int t, x, y, op, id; };
vector<Event> events;
vector<int> disc; // 离散化数组
int ans[N], tree1[M], tree2[M];

void add(int tree[], int pos, int val) {
    for (; pos < M; pos += pos & -pos) tree[pos] += val;
}

int query(int tree[], int pos) {
    int res = 0;
    for (; pos; pos -= pos & -pos) res += tree[pos];
    return res;
}

int main() {
    // 读入数据 & 离散化准备
    for (int i = 1; i <= n; i++) {
        disc.push_back(p[i] + b[i]);
        disc.push_back(b[i] - p[i] + 1);
        events.push_back({p[i], p[i], b[i], 1, 0});   // 加入事件
        events.push_back({s[i]+1, p[i], b[i], -1, 0});// 删除事件
    }
    for (int i = 1; i <= m; i++) {
        disc.push_back(inc[i] + pref[i]);
        disc.push_back(pref[i] - inc[i]);
        events.push_back({inc[i], inc[i], pref[i], 2, i}); // 查询事件
    }
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());

    // 处理事件
    sort(events.begin(), events.end(), [](Event a, Event b) {
        return a.t != b.t ? a.t < b.t : a.op < b.op;
    });
    for (auto e : events) {
        int pos1 = lower_bound(disc.begin(), disc.end(), e.x + e.y) - disc.begin() + 1;
        int pos2 = lower_bound(disc.begin(), disc.end(), e.y - e.x + 1) - disc.begin() + 1;
        if (e.op != 2) {
            add(tree1, pos1, e.op);
            add(tree2, pos2, e.op);
        } else {
            int posQ = lower_bound(disc.begin(), disc.end(), e.x + e.y) - disc.begin() + 1;
            ans[e.id] = query(tree1, posQ) - query(tree2, pos2 - 1);
        }
    }
    // 输出答案
}
```

**优质题解片段赏析**  
1. **xyz32768（扫描线）**  
   - **亮点**：事件驱动模型  
   ```cpp
   que[++cnt] = {p[i], p[i], b[i], 1, 0};   // 加入事件
   que[++cnt] = {s[i]+1, p[i], b[i], -1, 0};// 删除事件
   ```
   - **解读**：用 `op` 区分事件类型，扫描到 `p[i]` 时加入影响，`s[i]+1` 时移除

2. **wsyhb（CDQ分治）**  
   - **亮点**：三维偏序拆解  
   ```cpp
   // 条件1: b_i + p_i <= inc_j + pref_j
   t[i] = {b[i] + p[i], -s[i], -b[i], 0};
   t[n+i] = {inc[i] + pref[i], -inc[i], -pref[i], i};
   CDQ(1, cnt); // CDQ分治求解
   ```
   - **学习笔记**：负号技巧将 $\geq$ 转化为 $\leq$，适配树状数组

---

### 算法可视化：像素动画演示  
**主题**：`像素探险家`在 $inc$ 时间轴上扫描事件  
**关键帧设计**：  
1. **初始化**：  
   - 8-bit 网格：横轴 $inc$（0~max_inc），纵轴离散值域  
   - 控制面板：开始/暂停/步进按钮 + 速度滑块  

2. **事件触发动画**：  
   - **加入事件**：绿色像素块从底部升起，播放「叮」音效  
   - **删除事件**：红色闪烁后消失，播放「咔」音效  
   - **查询事件**：黄色射线从横轴向纵轴发射，命中时显示结果  

3. **树状数组更新**：  
   - 当前处理的 $inc$ 位置高亮为蓝色光柱  
   - 树状数组节点更新时，像素方块向上跳动并变色  

4. **AI演示模式**：  
   - 自动最优路径：扫描线匀速移动，跳过无效区间  
   - 通关奖励：每完成10个事件，播放8-bit胜利音乐  

**技术实现**：  
- Canvas绘制网格和动态元素  
- 音效：Web Audio API生成方波音效  
- 伪代码同步显示：右侧面板高亮当前执行行  

---

### 拓展练习与相似问题
**通用技巧迁移**：  
1. 绝对值拆解 → 区间查询问题  
2. 扫描线+树状数组 → 矩形面积并（P5490）  
3. CDQ分治 → 动态逆序对（P3157）  

**推荐题目**：  
1. **洛谷 P3810**【三维偏序】  
   > 裸三维偏序，巩固CDQ分治  
2. **洛谷 P5490**【扫描线】  
   > 矩形面积并，扫描线+线段树经典应用  
3. **洛谷 P4390**【二维数点】  
   > 树状数组求平面点数，扫描线基础  

---

### 学习心得与经验分享
> **xyz32768 经验**：  
> *“将几何约束转化为二维数点是本题关键，遇到绝对值优先考虑拆解和坐标系映射”*  
> **Kay点评**：该心得直击核心——算法选择源于问题特征的深度抽象，值得学习者反复体会！

---

> 算法之路如同像素游戏：每一行代码都是前进的脚印。保持思考，你终将通关！ 🎮🚀

---
处理用时：142.47秒
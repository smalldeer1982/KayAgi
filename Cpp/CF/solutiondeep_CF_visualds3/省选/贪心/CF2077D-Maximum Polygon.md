# 题目信息

# Maximum Polygon

## 题目描述

给定一个长度为 $n$ 的数组 $a$，确定字典序最大的 $^{\text{∗}}$ 子序列 $^{\text{†}}$ $s$，使得 $s$ 可以作为多边形的边长。

当且仅当 $|s| \geq 3$ 且满足以下条件时，$s$ 可以作为多边形的边长：

$$ 2 \cdot \max(s_1, s_2, \ldots, s_{|s|}) < s_1 + s_2 + \ldots + s_{|s|}. $$

如果不存在这样的子序列 $s$，输出 $-1$。

$^{\text{∗}}$ 序列 $x$ 的字典序小于序列 $y$，当且仅当以下条件之一成立：
- $x$ 是 $y$ 的前缀，但 $x \neq y$；
- 在 $x$ 和 $y$ 第一个不同的位置，$x$ 的元素小于 $y$ 中对应的元素。

$^{\text{†}}$ 序列 $x$ 是序列 $y$ 的子序列，当且仅当 $x$ 可以通过从 $y$ 中删除若干（可能为零或全部）元素得到。

## 说明/提示

在第一个测试用例中，不存在可以作为多边形边长的子序列。

在第二个测试用例中，有两个可以作为多边形边长的子序列：$1, 4, 2, 3$ 和 $4, 2, 3$。后者是字典序更大的子序列。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
3
3 1 2
4
1 4 2 3
6
1 6 4 5 3 2
6
43 12 99 53 22 4
7
9 764 54 73 22 23 1```

### 输出

```
-1
3
4 2 3 
4
6 5 3 2 
5
43 99 53 22 4 
4
54 73 23 1```

# AI分析结果


# 💡 Kay的C++算法解析：Maximum Polygon 深入学习指南 💡

<introduction>
今天我们来分析"Maximum Polygon"这道C++编程题。本指南将帮助大家理解如何构造字典序最大的多边形边长子序列，掌握贪心与构造技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心构造`、`单调栈优化`、`离散化技巧`

🗣️ **初步分析**：
> 解决此题的关键在于**双核心思维跳跃**：首先发现最大值只需枚举O(log V)次（因每次可排除大于mx/2的数），其次在确定最大值后，用**单调栈+后缀和**构造字典序最大的子序列。就像玩俄罗斯方块，我们不断用新方块"削平"栈顶的凸起，同时确保剩余空间足够完成目标。
>
> - **核心难点**：直接枚举子序列不可行，需利用多边形性质（2×max < sum）和字典序特性
> - **解决方案**：枚举最大值mx → 构造<=mx的子序列 → 用单调栈维护字典序
> - **可视化设计**：动画将展示栈操作过程，高亮当前元素与栈顶比较，当新元素更小且满足条件时播放"消除音效"，动态显示当前和与2×mx的关系
> - **像素风格**：采用8位贪吃蛇主题，数字方块从右向左移动，栈结构用底部堆叠方块表示，关键操作配"消除"和"收集"音效

---

## 2. 精选优质题解参考

<eval_intro>
我精选了以下思路清晰、实现高效的题解，它们都抓住了枚举最大值和贪心构造的核心：

**题解一：(来源：未来姚班zyl)**
* **点评**：此解法思路最为精炼，直接命中O(log V)枚举次数的核心性质。代码中：
  - 离散化处理优雅（`sol()`函数）
  - 后缀和数组`sf[]`高效支持栈操作判断
  - 单调栈实现简洁（`while(!Now.empty())`段）
  - 边界处理严谨（`sf[1]<=2*b[Mx]`跳过无效枚举）
亮点在于用不到50行完整实现，且作者提到"关键思维跳跃"的调试心得，提醒我们遇到难题时要转换枚举对象。

**题解二：(来源：Milthm)**
* **点评**：提供更详细的正确性证明，强化了"为什么只需枚举log V次"的理解。代码中：
  - ST表实现区间最大值查询（`query()`函数）
  - 向量操作清晰（`vector<int> solve()`）
  - 删除大于mx/2的数的逻辑明确（`a=b;`）
虽然ST表增加了常数复杂度，但模块化设计更易理解，适合初学者。
---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的三大关键难点及应对策略：

1.  **如何减少枚举量？**
    * **分析**：直接枚举子序列时间复杂度爆炸。优质题解发现关键性质：只需枚举可能的最大值mx，且mx的枚举次数为O(log V)。因为每次处理后会删除大于mx/2的数，剩余最大值至少减半。
    * 💡 **学习笔记**：遇到最值约束问题时，优先考虑枚举最值本身而非序列位置。

2.  **如何构造字典序最大子序列？**
    * **分析**：确定mx后，问题转化为：在<=mx的元素中，选和>2×mx的字典序最大子序列。这里需用**单调栈+后缀和**技巧：
      - 从左向右扫描
      - 维护递增栈（栈底到栈顶递增）
      - 当新元素<栈顶时，若弹出栈顶后剩余和+未扫描部分和仍>2×mx，则弹出
    * 💡 **学习笔记**：字典序最大子序列问题常使用单调栈维护"字典序潜力"。

3.  **如何高效判断可行性？**
    * **分析**：栈操作时需要快速判断"弹出后是否仍满足条件"。预处理**后缀和数组**是关键，如未来姚班zyl解法中的`sf[i]`表示位置i之后所有<=mx元素的和，使判断操作降为O(1)。
    * 💡 **学习笔记**：后缀和是优化子序列可行性判断的利器。

### ✨ 解题技巧总结
<summary_best_practices>
总结本题的通用解题技巧：
</summary_best_practices>
-   **枚举对象转换**：当序列位置枚举复杂时，尝试枚举值域相关量（如最大值）
-   **离散化优化**：对大值域问题，先用排序+去重降低规模
-   **后缀和预处理**：对涉及"剩余元素和"的判断，预处理后缀和数组
-   **栈维护字典序**：通过维护单调栈结构，自然保证字典序最优性

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的核心实现，重点展示枚举最大值+单调栈构造的完整框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合未来姚班zyl和Milthm的解法，保留离散化+后缀和+单调栈核心逻辑
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5, INF=1e9;

int n, a[N], b[N], lsh[N], len;
vector<int> ans, cur;
int suf[N]; // 后缀和数组

// 离散化函数
void discretize(int &x) {
    x = lower_bound(b+1, b+len+1, x) - b;
}

int main() {
    int T; cin >> T;
    while(T--) {
        // 输入与离散化
        cin >> n;
        for(int i=1; i<=n; i++) {
            cin >> a[i];
            lsh[i] = a[i];
        }
        sort(lsh+1, lsh+n+1);
        len = 0;
        for(int i=1; i<=n; i++) 
            if(lsh[i] != lsh[i-1]) 
                b[++len] = lsh[i];
        
        for(int i=1; i<=n; i++) 
            discretize(a[i]);
        
        // 枚举最大值mx（离散化后的下标）
        ans.clear();
        for(int mx=len; mx>=max(1, len-40); mx--) {
            // 计算后缀和
            suf[n+1] = 0;
            for(int i=n; i>=1; i--)
                suf[i] = suf[i+1] + (a[i]<=mx ? b[a[i]] : 0);
            
            if(suf[1] <= 2*b[mx]) continue; // 剪枝
            
            // 单调栈构造子序列
            cur.clear();
            ll sum = 0;
            for(int i=1; i<=n; i++) {
                if(a[i] > mx) continue;
                int num = b[a[i]];
                while(!cur.empty() && num < cur.back()) {
                    if(sum - cur.back() + suf[i] > 2*b[mx]) {
                        sum -= cur.back();
                        cur.pop_back();
                    } else break;
                }
                cur.push_back(num);
                sum += num;
            }
            // 更新最优解（字典序最大）
            if(cur.size() > ans.size() || 
              (cur.size()==ans.size() && cur > ans))
                ans = cur;
        }
        
        // 输出
        if(ans.empty()) cout << "-1\n";
        else {
            cout << ans.size() << '\n';
            for(int x : ans) cout << x << ' ';
            cout << '\n';
        }
    }
    return 0;
}
```
* **代码解读概要**：
    > 代码分四部分：
    > 1. **离散化**：排序去重后映射大值域到小范围
    > 2. **枚举最大值**：mx从大到小枚举，每次跳过无效情况（`suf[1]<=2*b[mx]`）
    > 3. **单调栈构造**：核心循环中动态维护栈的字典序和可行性
    > 4. **答案更新**：比较并保留字典序最大的子序列

---
<code_intro_selected>
各题解的独特亮点代码片段：
</code_intro_selected>

**题解一：(未来姚班zyl)**
* **亮点**：极致简洁的后缀和处理与栈操作
* **核心代码片段**：
```cpp
per(Mx,ln,max(1LL,ln-32)) { // 倒序枚举
    suf[n+1]=0;
    per(i,n,1) suf[i]=suf[i+1]+b[a[i]]*(a[i]<=Mx);
    
    repn(i) if(a[i]<=Mx) {
        while(!Now.empty() && b[a[i]] < Now.back()) {
            if(Sum - Now.back() + suf[i] > 2*b[Mx])
                Sum -= Now.back(), Now.pop_back();
            else break;
        }
        Now.pb(b[a[i]]), Sum += b[a[i]];
    }
}
```
* **代码解读**：
    > 1. `per(Mx...)`：从大到小枚举离散化下标，`ln-32`保证O(log V)次
    > 2. `per(i,n,1)`：倒序计算后缀和，`*(a[i]<=Mx)`巧妙过滤无效元素
    > 3. `while`循环：当新元素<栈顶且满足条件时持续弹出
    > 4. 无需ST表，用`suf[i]`动态判断剩余可行性
* 💡 **学习笔记**：通过倒序计算和条件表达式，高效实现后缀和过滤

**题解二：(Milthm)**
* **亮点**：模块化设计+ST表求区间最大值
* **核心代码片段**：
```cpp
vector<int> solve(int mx, vector<int> a) {
    // 预处理后缀和
    suf[n+1]=0;
    for(int i=n;i>=1;i--) suf[i]=suf[i+1]+a[i];
    
    // 构造ST表
    for(int i=1;i<=n;i++) f[i][0]=a[i], id[i][0]=i;
    // ... ST表预处理
    
    vector<int> res;
    int last=0, sum=0;
    while(last < n) {
        // 二分可加入位置
        int l=last+1, r=n, pos=-1;
        while(l<=r) {
            int mid=(l+r)/2;
            if(sum + suf[mid] > 2*mx) pos=mid, l=mid+1;
            else r=mid-1;
        }
        // 取区间最大值加入
        int idx = query(last+1, pos);
        res.push_back(a[idx]);
        sum += a[idx];
        last = idx;
    }
    return res;
}
```
* **代码解读**：
    > 1. 模块化设计：将核心逻辑封装在`solve()`函数中
    > 2. 二分查找：通过`suf[mid]`确定可加入的右边界
    > 3. ST表查询：在`[last+1, pos]`区间取最大值加入
    > 4. 显示更新`last`指针，避免重复选择
* 💡 **学习笔记**：模块化设计增强代码可读性，二分+ST表适合区间最值问题

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
为直观展示单调栈构造过程，我设计了一个8位像素风动画方案，让你像玩经典贪吃蛇一样理解算法！
</visualization_intro>

  * **动画演示主题**：像素贪吃蛇选数大冒险
  * **核心演示内容**：展示枚举最大值mx → 单调栈构造子序列的全过程，重点突出栈操作决策
  * **设计思路简述**：采用复古FC游戏风格，用不同颜色像素块表示数组元素，栈结构可视化堆叠。通过"叮"声提示关键操作，过关动画增强成就感，帮助理解栈维护字典序的本质。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
        - 顶部显示当前枚举的mx值（红色闪烁边框）
        - 中间区域：原数组元素显示为彩色像素块（绿色：<=mx，灰色：>mx）
        - 底部：栈区域（初始为空）

    2.  **扫描过程（像素蛇移动）**：
        - 蛇头（8位像素蛇）从左向右移动
        - 当扫描到元素时：
            - 若元素>mx：变灰跳过（播放"跳过"音效）
            - 若元素<=mx：高亮闪烁（黄色边框）

    3.  **栈操作决策**：
        - 新元素<栈顶？是→进入步骤4；否→直接入栈（绿色方块落入底部）
        - 入栈时显示当前和sum（底部计数器更新）

    4.  **弹出判断动画**：
        - 显示弹出计算公式：`(sum - 栈顶 + 剩余后缀和) > 2*mx?`
        - 满足条件：栈顶方块爆炸（像素粒子效果 + "消除"音效）
        - 不满足：显示红色"X"，新元素入栈

    5.  **关键状态显示**：
        - 右侧信息板：
            ```
            当前和：███
            目标：2×mx=████
            栈大小：█
            ```

    6.  **游戏化元素**：
        - 每完成一个mx枚举视为一关
        - 过关时播放8-bit胜利音乐，显示本关找到的子序列
        - 连击奖励：连续正确决策时显示"Combo!"特效

    7.  **交互控制面板**：
        - 调速滑块：控制蛇移动速度
        - 单步执行：按帧推进
        - 重置/暂停按钮
        - AI演示模式：自动展示完整流程

<visualization_conclusion>
通过这种像素游戏化演示，你将直观理解栈如何维护字典序，以及后缀和如何支持可行性判断，让算法学习像玩游戏一样有趣！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的贪心构造思想后，可解决更多字典序相关问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 字典序最大/小子序列构造（如LC316. 去除重复字母）
    - 带约束的最优子序列（如和≥K的字典序最小序列）
    - 最值枚举优化技巧（如LC239. 滑动窗口最大值）

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090** - 合并果子
        * 🗣️ **推荐理由**：练习贪心选择策略，理解"每次选最小"如何影响最终结果
    2.  **洛谷 P1631** - 序列合并
        * 🗣️ **推荐理由**：强化有序序列合并技巧，为单调栈问题打基础
    3.  **洛谷 P6033** - 合并果子·改
        * 🗣️ **推荐理由**：进阶版贪心，需要结合堆优化和数学分析

-----

## 7. 学习心得与经验分享

<insights_intro>
题解作者分享的调试经验特别值得借鉴：
</insights_intro>

> **参考经验 (来自 未来姚班zyl)**："赛时可能因为枚举起点（第一个位置）而陷入复杂讨论... 关键跳跃是枚举最大值mx"
>
> **点评**：这提醒我们当问题复杂时，要尝试转换枚举对象。直接枚举序列位置常导致O(n²)复杂度，而枚举值域相关量（如最大值）可能将问题规模降至O(log V)。这种思维转换在竞赛中尤为宝贵。

-----

<conclusion>
本次关于"Maximum Polygon"的解析就到这里。记住核心：枚举最值降规模，后缀和支判断，单调栈保字典序。多练习类似题目，你会在贪心构造类问题中游刃有余！下次见！💪
</conclusion>
```

---
处理用时：190.09秒
# é¢˜ç›®ä¿¡æ¯

# Dividing Kingdom II

## é¢˜ç›®æè¿°

Long time ago, there was a great kingdom and it was being ruled by The Great Arya and Pari The Great. These two had some problems about the numbers they like, so they decided to divide the great kingdom between themselves.

The great kingdom consisted of $ n $ cities numbered from $ 1 $ to $ n $ and $ m $ bidirectional roads between these cities, numbered from $ 1 $ to $ m $ . The $ i $ -th road had length equal to $ w_{i} $ . The Great Arya and Pari The Great were discussing about destructing some prefix (all road with numbers less than some $ x $ ) and suffix (all roads with numbers greater than some $ x $ ) of the roads so there will remain only the roads with numbers $ l,l+1,...,r-1 $ and $ r $ .

After that they will divide the great kingdom into two pieces (with each city belonging to exactly one piece) such that the hardness of the division is minimized. The hardness of a division is the maximum length of a road such that its both endpoints are in the same piece of the kingdom. In case there is no such road, the hardness of the division is considered to be equal to $ -1 $ .

Historians found the map of the great kingdom, and they have $ q $ guesses about the $ l $ and $ r $ chosen by those great rulers. Given these data, for each guess $ l_{i} $ and $ r_{i} $ print the minimum possible hardness of the division of the kingdom.

## æ ·ä¾‹ #1

### è¾“å…¥

```
5 6 5
5 4 86
5 1 0
1 3 38
2 1 33
2 4 28
2 3 40
3 5
2 6
1 3
2 3
1 6
```

### è¾“å‡º

```
-1
33
-1
-1
33
```

# AIåˆ†æç»“æœ


### ğŸ’¡ Kayçš„C++ç®—æ³•è§£æï¼šDividing Kingdom II æ·±å…¥å­¦ä¹ æŒ‡å— ğŸ’¡

**å¼•è¨€**  
ä»Šå¤©æˆ‘ä»¬ä¸€èµ·åˆ†æCF687D "Dividing Kingdom II"ã€‚è¿™é“é¢˜éœ€è¦å·§å¦™å¤„ç†åŒºé—´æŸ¥è¯¢ä¸äºŒåˆ†å›¾æ€§è´¨ï¼Œæœ¬æŒ‡å—å°†å¸®ä½ æŒæ¡æ ¸å¿ƒç®—æ³•æ€è·¯å’Œä¼˜åŒ–æŠ€å·§ã€‚

---

### 1. é¢˜ç›®è§£è¯»ä¸æ ¸å¿ƒç®—æ³•è¯†åˆ«
âœ¨ **æœ¬é¢˜ä¸»è¦è€ƒå¯Ÿ**ï¼šè´ªå¿ƒç­–ç•¥ + å¹¶æŸ¥é›†åº”ç”¨ + åŒºé—´æŸ¥è¯¢ä¼˜åŒ–  
ğŸ—£ï¸ **åˆæ­¥åˆ†æ**ï¼š
> å°†é—®é¢˜æƒ³è±¡æˆè¿æ¥åŸå¸‚çš„ç»³å­ï¼ˆè¾¹ï¼‰ï¼Œç»³é•¿å³è¾¹æƒã€‚ç›®æ ‡æ˜¯å°†åŸå¸‚åˆ†ä¸ºä¸¤ä¸ªå›½å®¶ï¼Œä½¿åŒä¸€å›½å†…æœ€é•¿ç»³å­å°½å¯èƒ½çŸ­ã€‚æ ¸å¿ƒç­–ç•¥æ˜¯ï¼š  
> **ä»å¤§åˆ°å°å¤„ç†è¾¹**ï¼Œä¼˜å…ˆåˆ‡æ–­é•¿ç»³ï¼ˆé¿å…å¤§è¾¹æƒæˆä¸ºå®Œæ•´è¾¹ï¼‰ã€‚ä½¿ç”¨**æ‰©å±•åŸŸå¹¶æŸ¥é›†**åŠ¨æ€ç»´æŠ¤äºŒåˆ†å›¾æ€§è´¨ï¼š  
> - è‹¥è¾¹ä¸¤ç«¯ç‚¹å·²æ— æ³•åˆ†å±ä¸åŒåŒºåŸŸï¼ˆåŒä¸€é›†åˆï¼‰ï¼Œåˆ™è¯¥è¾¹æƒå³ä¸ºç­”æ¡ˆ  
> - å¦åˆ™å°†ç«¯ç‚¹äº¤å‰åˆå¹¶ï¼ˆ`u`è¿`v+n`, `v`è¿`u+n`)  
>  
> **çº¿æ®µæ ‘ä¼˜åŒ–**ï¼šé¢„å¤„ç†åŒºé—´å…³é”®è¾¹é›†ï¼ˆä»…ä¿ç•™O(n)æ¡å½±å“å¹¶æŸ¥é›†çš„è¾¹ï¼‰ï¼Œå°†æŸ¥è¯¢å¤æ‚åº¦ä»O(qm)é™è‡³O(qn log m)

**å¯è§†åŒ–è®¾è®¡æ€è·¯**ï¼š  
åœ¨åƒç´ åŠ¨ç”»ä¸­ï¼š  
- å·¦ä¾§å±•ç¤ºçº¿æ®µæ ‘ç»“æ„ï¼ŒèŠ‚ç‚¹é«˜äº®å½“å‰å¤„ç†çš„åŒºé—´  
- å³ä¾§åŠ¨æ€æ¼”ç¤ºå¹¶æŸ¥é›†åˆå¹¶ï¼šå®å¿ƒç‚¹è¡¨åŸåŸå¸‚ï¼Œç©ºå¿ƒç‚¹è¡¨è™šç‚¹  
- å…³é”®æ“ä½œï¼š  
  - å½’å¹¶æ’åºè¾¹é›† â†’ åƒç´ å—æŒ‰æƒé‡ä¸‹æ²‰åŠ¨ç”»  
  - å¹¶æŸ¥é›†åˆå¹¶ â†’ å®/è™šç‚¹é—´ç®­å¤´è¿æ¥  
  - å†²çªå‘ç”Ÿ â†’ çº¢è¾¹é—ªçƒ + 8-bit"å¤±è´¥"éŸ³æ•ˆ  

---

### 2. ç²¾é€‰ä¼˜è´¨é¢˜è§£å‚è€ƒ
#### é¢˜è§£ä¸€ï¼šMiko35ï¼ˆçº¿æ®µæ ‘ä¼˜åŒ–ï¼‰
* **äº®ç‚¹**ï¼š  
  - åˆ›æ–°æ€§æå‡º"å…³é”®è¾¹"æ¦‚å¿µï¼ˆä»…O(n)æ¡å½±å“å¹¶æŸ¥é›†çš„è¾¹ï¼‰  
  - çº¿æ®µæ ‘èŠ‚ç‚¹å½’å¹¶æ’åºè¾¹é›†ï¼ˆSTL mergeé«˜æ•ˆå®ç°ï¼‰  
  - ä»£ç ç®€æ´ï¼ˆ30è¡Œæ ¸å¿ƒï¼‰ï¼Œç©ºé—´å¤æ‚åº¦æ§åˆ¶ä¼˜ç§€  

#### é¢˜è§£äºŒï¼š_agKc_ï¼ˆæš´åŠ›è´ªå¿ƒï¼‰
* **äº®ç‚¹**ï¼š  
  - æè‡´ç®€æ´ï¼ˆ40è¡Œï¼‰ï¼Œé€‚åˆåˆå­¦è€…ç†è§£æ ¸å¿ƒè´ªå¿ƒé€»è¾‘  
  - æ‰©å±•åŸŸå¹¶æŸ¥é›†å®ç°è§„èŒƒï¼Œå˜é‡å‘½åæ¸…æ™°  
  - å¯¹å¼±æ•°æ®/å®½æ¾æ—¶é™æœ‰å®æˆ˜ä»·å€¼  

#### é¢˜è§£ä¸‰ï¼šæ˜¯ä¸ªæ±‰å­ï¼ˆçº¿æ®µæ ‘è¯¦ç»†å®ç°ï¼‰
* **äº®ç‚¹**ï¼š  
  - é€æ­¥æ³¨é‡Šå…³é”®æ­¥éª¤ï¼Œè¯¦è§£å½’å¹¶æ’åºä¸å¹¶æŸ¥é›†è”åŠ¨  
  - ä¸¥æ ¼å¤„ç†è¾¹ç•Œæ¡ä»¶ï¼Œå·¥ä¸šçº§ä»£ç è§„èŒƒ  
  - æä¾›å®Œæ•´å¯ç¼–è¯‘ä»£ç   

---

### 3. æ ¸å¿ƒéš¾ç‚¹è¾¨æä¸è§£é¢˜ç­–ç•¥
#### éš¾ç‚¹1ï¼šåŒºé—´æŸ¥è¯¢çš„é«˜æ•ˆå¤„ç†
* **åˆ†æ**ï¼š  
  æš´åŠ›O(qm)ä¸å¯è¡Œ â†’ çº¿æ®µæ ‘é¢„å¤„ç†åŒºé—´å…³é”®è¾¹é›†  
  **å…³é”®æŠ€å·§**ï¼šåˆå¹¶å­åŒºé—´æ—¶ä»…ä¿ç•™ï¼š  
  - æ”¹å˜è¿é€šæ€§çš„æ ‘è¾¹  
  - é¦–æ¬¡å¼•å‘å†²çªçš„è¾¹  

#### éš¾ç‚¹2ï¼šäºŒåˆ†å›¾æ€§è´¨çš„åŠ¨æ€ç»´æŠ¤
* **åˆ†æ**ï¼š  
  æ‰©å±•åŸŸå¹¶æŸ¥é›†ç²¾å¦™å¤„ç†å¯¹ç«‹å…³ç³»ï¼š  
  ```python
  if find(u) == find(v): å†²çª!  
  else: 
      merge(u, v+n)  # uä¸vçš„è™šç‚¹ç›¸è¿
      merge(v, u+n)  # vä¸uçš„è™šç‚¹ç›¸è¿
  ```

#### éš¾ç‚¹3ï¼šå…³é”®è¾¹é›†çš„å½’å¹¶æ’åº
* **åˆ†æ**ï¼š  
  ç»´æŠ¤è¾¹é›†æœ‰åºæ€§ï¼ˆä»å¤§åˆ°å°ï¼‰â†’ å½’å¹¶æ—¶ä¼˜å…ˆå–å¤§è¾¹æƒ  
  é€šè¿‡O(n)æ¨¡æ‹Ÿå¹¶æŸ¥é›†è¿‡æ»¤éå…³é”®è¾¹  

ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼š  
> è´ªå¿ƒæ’åº + æ‰©å±•åŸŸå¹¶æŸ¥é›† + å…³é”®è¾¹æå– = é«˜æ•ˆè§£æ³•ä¸‰è¦ç´ 

### âœ¨ è§£é¢˜æŠ€å·§æ€»ç»“
1. **é—®é¢˜è½¬åŒ–**ï¼šå°†æœ€å°åŒ–æœ€å¤§å€¼ â†’ å¯»æ‰¾é¦–ä¸ªå†²çªè¾¹ï¼ˆä»å¤§åˆ°å°æšä¸¾ï¼‰  
2. **æ•°æ®ç»“æ„é€‰æ‹©**ï¼š  
   - æ‰©å±•åŸŸå¹¶æŸ¥é›†ç»´æŠ¤äºŒåˆ†å›¾  
   - çº¿æ®µæ ‘å¤„ç†åŒºé—´æŸ¥è¯¢  
3. **å¤æ‚åº¦å¹³è¡¡**ï¼š  
   - æš´åŠ›ï¼šO(qmÎ±(n)) â†’ é€‚åˆå°æ•°æ®  
   - ä¼˜åŒ–ï¼šO((m + qn log m)Î±(n)) â†’ é€šè§£  

---

### 4. C++æ ¸å¿ƒä»£ç å®ç°èµæ
#### é€šç”¨æ ¸å¿ƒå®ç°ï¼ˆèåˆMiko35ä¸æ˜¯ä¸ªæ±‰å­æ€è·¯ï¼‰
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1005, M = 500010;

struct Edge { int u, v, w; } e[M];
vector<int> tree[M*4]; // çº¿æ®µæ ‘èŠ‚ç‚¹å­˜è¾¹ç´¢å¼•
int n, m, q, fa[N*2];

// æ‰©å±•åŸŸå¹¶æŸ¥é›†
int find(int x) { return fa[x]==x ? x : fa[x]=find(fa[x]); }
void initDSU() { for(int i=1; i<=2*n; i++) fa[i] = i; }

// å…³é”®è¾¹æå–ï¼šè¿”å›å†²çªè¾¹æƒ/æ„å»ºæ–°è¾¹é›†
int solve(vector<int> edges, vector<int> &res) {
    initDSU();
    res.clear();
    for(int i : edges) {
        int u = e[i].u, v = e[i].v;
        if(find(u) == find(v)) { // å†²çªæ£€æµ‹
            res.push_back(i);
            return e[i].w;
        }
        // äº¤å‰åˆå¹¶
        int fu2 = find(u+n), fv2 = find(v+n);
        fa[find(u)] = fv2;
        fa[find(v)] = fu2;
        res.push_back(i);
    }
    return -1;
}

// å½’å¹¶æ’åºè¾¹é›†ï¼ˆæƒå€¼é™åºï¼‰
vector<int> mergeEdges(vector<int> a, vector<int> b) {
    vector<int> res;
    auto cmp = [&](int i, int j) { return e[i].w > e[j].w; };
    merge(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res), cmp);
    return res;
}

// çº¿æ®µæ ‘å»ºæ ‘
void build(int k, int l, int r) {
    if(l == r) { tree[k] = {l}; return; }
    int mid = (l+r)/2;
    build(k*2, l, mid);
    build(k*2+1, mid+1, r);
    vector<int> tmp = mergeEdges(tree[k*2], tree[k*2+1]);
    solve(tmp, tree[k]); // æå–å…³é”®è¾¹
}

// åŒºé—´æŸ¥è¯¢
vector<int> query(int k, int l, int r, int L, int R) {
    if(L <= l && r <= R) return tree[k];
    int mid = (l+r)/2;
    if(R <= mid) return query(k*2, l, mid, L, R);
    if(L > mid) return query(k*2+1, mid+1, r, L, R);
    auto left = query(k*2, l, mid, L, R);
    auto right = query(k*2+1, mid+1, r, L, R);
    return mergeEdges(left, right);
}

int main() {
    cin >> n >> m >> q;
    for(int i=1; i<=m; i++) cin >> e[i].u >> e[i].v >> e[i].w;
    build(1, 1, m); // å»ºæ ‘
    while(q--) {
        int l, r; cin >> l >> r;
        auto edges = query(1, 1, m, l, r);
        vector<int> tmp;
        cout << solve(edges, tmp) << endl;
    }
}
```

#### ä»£ç è§£è¯»æ¦‚è¦
1. **æ•°æ®ç»“æ„**ï¼š  
   - `Edge`å­˜å‚¨è¾¹ä¿¡æ¯  
   - `tree`æ•°ç»„å®ç°çº¿æ®µæ ‘ï¼ŒèŠ‚ç‚¹å­˜å…³é”®è¾¹ç´¢å¼•  
2. **æ ¸å¿ƒé€»è¾‘**ï¼š  
   - `build()`é€’å½’å»ºæ ‘ â†’ å¶å­å­˜å•è¾¹ â†’ éå¶å­å½’å¹¶å­åŒºé—´  
   - `solve()`åŠ¨æ€ç»´æŠ¤å¹¶æŸ¥é›† â†’ æå–å…³é”®è¾¹é›†  
3. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š  
   - åŒºé—´åˆ†è§£ â†’ å½’å¹¶å­åŒºé—´å…³é”®è¾¹ â†’ æ¨¡æ‹Ÿå¹¶æŸ¥é›†å¾—ç­”æ¡ˆ  

---

### 5. ç®—æ³•å¯è§†åŒ–ï¼šåƒç´ åŠ¨ç”»æ¼”ç¤º
#### è®¾è®¡æ¦‚å¿µï¼š"ç‹å›½åˆ†è£‚å¤§ä½œæˆ˜"ï¼ˆ8-bitåƒç´ é£ï¼‰
**æ ¸å¿ƒäº¤äº’**ï¼š  
```plaintext
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  çº¿æ®µæ ‘ç»“æ„           â”‚      â”‚  å¹¶æŸ¥é›†åŠ¨æ€æ¼”ç¤º  â”‚
  â”‚  [1-3]               â”‚      â”‚  â—1    â—2       â”‚
  â”‚    â”œâ”€[1-2]â—          â”‚      â”‚  â—‹1 â”€â”€ â—‹2       â”‚ 
  â”‚    â”‚  â”œâ”€[1]          â”‚      â”‚                 â”‚
  â”‚    â”‚  â””â”€[2]          â”‚ â†’ åŠ å…¥è¾¹(1,2) â†’ 
  â”‚    â””â”€[3]             â”‚      â”‚  â—1â•â•â—2        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ å†²çªï¼çº¢å±é—ªçƒ â”‚
```

**å…³é”®åŠ¨ç”»å¸§**ï¼š  
1. **åˆå§‹åŒ–é˜¶æ®µ**ï¼š  
   - åƒç´ ç½‘æ ¼å±•ç¤ºåŸå¸‚ï¼ˆç¼–å·æ–¹å—ï¼‰å’Œè¾¹ï¼ˆå½©è‰²çº¿æ¡ï¼‰  
   - æ§åˆ¶é¢æ¿ï¼šé€Ÿåº¦æ»‘å—/å•æ­¥æ‰§è¡ŒæŒ‰é’®  
   - 8-bitèƒŒæ™¯éŸ³ä¹å¯åŠ¨  

2. **çº¿æ®µæ ‘æ“ä½œ**ï¼š  
   - åŒºé—´æŸ¥è¯¢ï¼šé«˜äº®å½“å‰æ ‘èŠ‚ç‚¹ï¼ˆé»„æ¡†é—ªçƒï¼‰  
   - å½’å¹¶æ’åºï¼šè¾¹æƒå€¼å¤§çš„åƒç´ å—ä¼˜å…ˆä¸‹è½  

3. **å¹¶æŸ¥é›†åˆå¹¶**ï¼š  
   - æˆåŠŸåˆå¹¶ï¼šå®å¿ƒç‚¹ä¸ç©ºå¿ƒç‚¹é—´ç”Ÿæˆç»¿è‰²è¿æ¥çº¿ + "å®"å£°æ•ˆ  
   - å‘ç”Ÿå†²çªï¼šè¾¹å˜çº¢é—ªçƒ + çŸ­ä¿ƒ"å¤±è´¥"éŸ³æ•ˆ + æ˜¾ç¤ºç­”æ¡ˆ  

4. **æ¸¸æˆåŒ–å…ƒç´ **ï¼š  
   - æ¯æŸ¥è¯¢è§†ä¸ºå…³å¡ï¼šæˆåŠŸè§£å†³å¾—åƒç´ çš‡å†   
   - å®æ—¶æ˜¾ç¤ºå½“å‰æœ€å°åŒ–æœ€å¤§å€¼  

---

### 6. æ‹“å±•ç»ƒä¹ ä¸ç›¸ä¼¼é—®é¢˜
#### é€šç”¨æŠ€å·§è¿ç§»
1. **åŒºé—´æ•°æ®ç»“æ„**ï¼šçº¿æ®µæ ‘ç»´æŠ¤å…³é”®å…ƒç´ é›†  
2. **å¸¦æƒå¹¶æŸ¥é›†**ï¼šå¤„ç†å…ƒç´ å¯¹ç«‹å…³ç³»  
3. **è´ªå¿ƒæ’åº**ï¼šè§£å†³æœ€å°åŒ–æœ€å¤§å€¼é—®é¢˜  

#### æ´›è°·æ¨è
1. **P1525 [NOIP2010] å…³æŠ¼ç½ªçŠ¯**  
   â†’ åŒæ¬¾è´ªå¿ƒ+å¹¶æŸ¥é›†ï¼Œæ— åŒºé—´æŸ¥è¯¢  
2. **P1967 [NOIP2013] è´§è½¦è¿è¾“**  
   â†’ æœ€å¤§ç”Ÿæˆæ ‘+æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢  
3. **P2144 [FJOI] è½®çŠ¶ç—…æ¯’**  
   â†’ å¹¶æŸ¥é›†åœ¨ç”Ÿæˆæ ‘è®¡æ•°ä¸­çš„åº”ç”¨  

---

### 7. å­¦ä¹ å¿ƒå¾—ä¸ç»éªŒåˆ†äº«
> **æ¥è‡ªMiko35çš„å¯ç¤º**ï¼š  
> "å…³é”®è¾¹æ•°é‡ä»…O(n)"çš„å‘ç°æ˜¯ä¼˜åŒ–æ ¸å¿ƒï¼Œé¿å…æ— æ•ˆè®¡ç®—  
>  
> **è°ƒè¯•æŠ€å·§**ï¼š  
> - è¾¹ç•Œæµ‹è¯•ï¼šç©ºåŒºé—´/å•å…ƒç´ åŒºé—´  
> - å¹¶æŸ¥é›†çŠ¶æ€æ‰“å°ï¼šå¯è§†åŒ–åˆå¹¶è¿‡ç¨‹  

**Kayçš„æ€»ç»“**ï¼š  
æŒæ¡è´ªå¿ƒæ’åºä¸æ‰©å±•åŸŸå¹¶æŸ¥é›†çš„ç»“åˆï¼Œç†è§£çº¿æ®µæ ‘ä¼˜åŒ–æœ¬è´¨ï¼Œä½ å°±èƒ½æ”»å…‹è¿™ç±»åŒºé—´æŸ¥è¯¢éš¾é¢˜ï¼ä¸‹æ¬¡è§ï¼ğŸ’ª

---
å¤„ç†ç”¨æ—¶ï¼š202.81ç§’
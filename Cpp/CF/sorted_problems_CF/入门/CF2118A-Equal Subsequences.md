---
title: "Equal Subsequences"
layout: "post"
diff: 入门
pid: CF2118A
tag: []
---

# Equal Subsequences

## 题目描述

我们称一个 $01$ 串（仅含有字符 $\tt{0}$ 和 $\tt{1}$ 的字符串）为好的，当且仅当其含有的子序列 $\tt{101}$ 和 $\tt{010}$ 的数量相同。请你构造一个长度为 $n$ 的好的 $01$ 串，使其含有的字符 $\tt{1}$ 的数量正好为 $k$。可以证明这总是可能的。

一个字符串 $a$ 被称为是另一个字符串 $b$ 的子序列，当且仅当 $a$ 可以通过从 $b$ 中删去一部分字符（可以是 $0$ 个或全部字符）的操作得到。

## 输入格式

本题采用多测。输入的第一行是测试数据组数 $t$（$1 \le t \le 500$）。

对于每组数据，输入一行两个整数 $n,k$（$1 \le n \le 100$，$0 \le k \le n$）。

## 输出格式

对于每组测试数据，输出一行一个 $01$ 串，表示你构造的答案。如果有多解，输出任意一个。

## 说明/提示

对于第一组测试数据，子序列 $\tt{101}$ 和 $\tt{010}$ 的数量都是 $1$，且字符串恰好包含 $2$ 个 $\tt{1}$。

对于第二组测试数据，子序列 $\tt{101}$ 和 $\tt{010}$ 的数量都是 $2$，且字符串恰好包含 $3$ 个 $\tt{1}$。

对于第三组测试数据，子序列 $\tt{101}$ 和 $\tt{010}$ 的数量都是 $0$，且字符串恰好包含 $5$ 个 $\tt{1}$。

## 样例 #1

### 输入

```
5
4 2
5 3
5 5
6 2
1 1
```

### 输出

```
1010
10110
11111
100010
1
```


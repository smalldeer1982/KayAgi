---
title: "Find Pair"
layout: "post"
diff: 提高+/省选-
pid: CF160C
tag: []
---

# Find Pair

## 题目描述

你又遇到了一道关于排列的问题。

首先，考虑一个包含 _n_ 个整数的数列 _a₁_ , _a₂_ ... _aₙ_ (不一定互不相同)。你发现由其中任意两项组成的数对 (aᵢ, aⱼ)(1 <= i, j <= n)十分有趣，于是你想探究给定数列中所有 _n²_ 组数对的规律。

例如，数列{3, 1, 5}能组成九组数对：
(3, 3), (3, 1), (3, 5), (1, 3), (1, 1), (1, 5), (5, 3), (5, 1), (5, 5)。

接下来，将这些数对按照字典序升序排列。比如，两组数对(_p₁_, _p₂_)，(_q₁_, _q₂_)，当且仅当 _p₁_ < _p₂_，或 _p₁_ = _p₂_ 且 _q₁_ < _q₂_ 时，我们说(_p₁_, _p₂_)的字典序小于(_q₁_, _q₂_)的字典序。

于是，上述数列组成的数对排序后将成为：
(1, 1), (1, 3), (1, 5), (3, 1), (3, 3), (3, 5), (5, 1), (5, 3), (5, 5)。

将排好序的数组标上按顺序编号为 1 ～ _n²_ 。现在，你想要知道其中第 _k_ 组数对是什么。

## 输入格式

第一行包括两个整数 _n_ 和 _k_ (1 <= _n_ <= 10⁵，1 <= _k_ <= _n²_ )。

第二行包括 _n_ 个整数 _a₁_ , _a₂_ ... _aₙ_ (-10⁹ <= aᵢ <= 10⁹)，表示数列的每一项，数值可以重复。每一项之间由一个空格隔开。

注意，C++中不建议使用格式控制符 %lld 读写64位长整型数据，最好使用 cin，cout，streams 或 %I64d 格式控制符。

## 输出格式

只有一行，包括两个数字，表示排好序的 _n²_ 个数对的第 _k_ 组。

## 说明/提示

样例 #1 中排好序的数对为：
(1, 1), (1, 2), (2, 1), (2, 2)
所以第4项为(2, 2)。

样例 #2 中排好序的数对为：
(1, 1), (1, 3), (1, 5), (3, 1), (3, 3), (3, 5), (5, 1), (5, 3), (5, 5)
所以第2项为(1, 3)。

## 样例 #1

### 输入

```
2 4
2 1

```

### 输出

```
2 2

```

## 样例 #2

### 输入

```
3 2
3 1 5

```

### 输出

```
1 3

```


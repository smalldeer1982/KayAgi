---
title: "Equal Binary Subsequences"
layout: "post"
diff: 提高+/省选-
pid: CF1736D
tag: []
---

# Equal Binary Subsequences

## 题目描述

给你一个长为 $2n$ 的01串 $s$ ，你需要将其分成两个相等的子序列。

在此之前你需要执行以下操作一次：

- 选一个 $s$ 的子序列（可能为空），然后将其向右循环移位一位。

具体来说，你可以选择一个下标序列 $b_1,b_2,\dots,b_m$ 满足 $1\le b_1<b_2<\dots<b_m\le 2n$ ，然后同时执行 $s_{b_1}=s_{b_m},s_{b_2}=s_{b_1},\dots,s_{b_m}=s_{b_{m-1}}$ 。

你能在执行以上操作一次后把 $s$ 分成两个相等的子序列吗？

#### Hint

把 $s$ 分成两个相等的子序列 $s^p$ 和 $s^q$ 是指找到两个下标序列 $p_1,p_2,\dots,p_n$ 和 $q_1,q_2,\dots,q_n$ ，使得从 $1$ 到 $2n$ 的每个整数都恰好在 $p$ 和 $q$ 中出现共一次，然后令 $s^p=s_{p_1}s_{p_2}\dots s_{p_n}$ ， 	$s^q=s_{q_1}s_{q_2}\dots s_{q_n}$ ，满足 $s^p=s^q$ 。

## 输入格式

每一个测试点有多个测试数据。第一行一个正整数 $t$ 表示测试数据组数。对于每组数据：

第一行一个正整数 $n$ ，表示01串 $s$ 的长度为 $2n$ 。

第二行一个长为 $2n$ 的01串 $s$ 。

## 输出格式

对于每组数据：

如果无解，输出一行 $-1$ 。

否则：

- 第一行输出一个整数 $m$ $(0\le m\le 2n)$ ，接着升序输出 $m$ 个下标 $b_1,b_2,\dots,b_m$ 。

- 第二行升序输出 $n$ 个下标 $p_1,p_2,\dots,p_n$ (见Hint) 。

如果有多解，输出任意一个。

$s$ 的下标从1开始。

#### 输入输出样例

##### 样例输入

```
4
2
1010
3
100010
2
1111
2
1110

```

##### 样例输出

```
0
1 2
2 3 5
1 2 5
3 2 3 4
1 4
-1

```

##### 样例解释

在第二个测试数据中，$b[]=\{3,5\}$ 。初始时 $s_3=0,s_5=1$ 。进行操作时，我们同时令 $s_3=1,s_5=0$ 。然后 $s$ 变成了 $101000$ 。现在我们选择 $p[]=\{1,2,5\}$ ，那么 $s^p=100$ ；自然 $q[]=\{3,4,6\}$ ，于是 $s^q=100$ 。$s^p=s^q$ 。

## 说明/提示

$1\le t\le 10^5,1\le n\le 10^5$ 。

保证同一测试点中所有数据的 $n$ 的和不超过 $10^5$ 。

## 样例 #1

### 输入

```
4
2
1010
3
100010
2
1111
2
1110
```

### 输出

```
0
1 2
2 3 5
1 2 5
3 2 3 4
1 4
-1
```


---
title: "Ancient Berland Hieroglyphs"
layout: "post"
diff: 普及+/提高
pid: CF164B
tag: []
---

# Ancient Berland Hieroglyphs

## 题目描述

Polycarpus 对 Berland 象形文字充满了兴趣。某天，他得到两幅古老的 Berland 图片，上面各自画着一个象形文字圆圈。已知在任一圆圈中，象形文字不会重复出现（但可以在两个圆圈中各出现一次）。

为了在电脑上保存这些图片，Polycarpus 必须将每个圆圈打断，并顺时针将其中的所有象形文字按顺序写成一行。由第一个圆圈得到的行称为 $a$，由第二个圆圈得到的行称为 $b$。

由于有多种打断圆圈的方法，Polycarpus 希望选择一种能够使得 $a$ 的最长子串作为 $b$ 的子序列的长度最大。

请帮 Polycarpus 找出，在最优打断方式下，所需子串（子序列）的最大可能长度。

字符串 $s$ 的长度为字符数目，记作 $|s|$。字符串可以表示为 $s = s_1 s_2 \ldots s_{|s|}$。

一个子串 $x$ 可以表示为 $x = s[a \ldots b] = s_a s_{a+1} \ldots s_b$（$1 \le a \le b \le |s|$）。例如，“code”和“force”是“codeforces”的子串，而“coders”不是。

子序列是指 $y = s[p_1 p_2 \ldots p_{|y|}] = s_{p1} s_{p2} \ldots s_{p|y|}$（$1 \le p_1 < p_2 < \ldots < p_{|y|} \le |s|$）。例如，“coders”是“codeforces”的子序列。

## 输入格式

第一行包含两个整数 $l_a$ 和 $l_b$（$1 \le l_a, l_b \le 1000000$），分别表示第一个和第二个圆圈中的象形文字数量。

第二行是 $l_a$ 个整数，表示第一个图片中的象形文字，按顺时针顺序排列。

第三行是 $l_b$ 个整数，表示第二个图片中的象形文字，按顺时针顺序排列。

保证在第一个圆圈中没有重复的象形文字，第二个圆圈也是如此。

## 输出格式

输出一个整数，表示最长的公共子串和子序列的长度。如果在任何打断方式下都找不到这样的子串和子序列，则输出 0。

## 说明/提示

在第一个测试用例中，Polycarpus 选择了一个由象形文字 5 和 1 组成的字符串；在第二个测试用例中，他选择了一个由象形文字 1、3 和 5 组成的字符串。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 3 5 6

```

### 输出

```
2

```

## 样例 #2

### 输入

```
4 6
1 3 5 2
1 2 3 4 5 6

```

### 输出

```
3

```

## 样例 #3

### 输入

```
3 3
1 2 3
3 2 1

```

### 输出

```
2

```


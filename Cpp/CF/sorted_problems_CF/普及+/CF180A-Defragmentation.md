---
title: "Defragmentation"
layout: "post"
diff: 普及+/提高
pid: CF180A
tag: []
---

# Defragmentation

## 题目描述

本题要求你实现一个硬盘碎片整理算法。硬盘由编号从 $1$ 到 $n$ 的若干个簇组成。磁盘上共存储有 $m$ 个文件，第 $i$ 个文件占据编号为 $a_{i,1}$, $a_{i,2}$, ..., $a_{i,ni}$ 的簇。这些簇虽可能不连续，但其编号顺序表示文件段落的顺序（即，簇 $a_{i,1}$ 存储第 $i$ 个文件的第一段，簇 $a_{i,2}$ 存储第二段，依此类推）。硬盘上至少有一个簇处于未使用状态。

你可以执行如下操作：将编号为 $i$ 的簇内容复制到编号为 $j$ 的簇上（$i$ 和 $j$ 不能相同）。如果簇 $j$ 上原有信息将被永久删除。各簇内容不会被彻底清空，但在碎片整理完成后，有些簇会被标记为不可用（虽然其中可能残留了一些文件片段）。

目标是通过一系列复制操作，使得每个文件的簇在硬盘上呈连续分布。文件应从硬盘起始位置排列，紧密依次排布，所有空余簇应在硬盘末尾。文件之间的先后顺序不限，确保每个文件从头到尾占据连续的簇即可。

请输出实现磁盘碎片整理的操作序列。注意，不要求操作数最小化，但操作次数不能超过 $2n$。

## 输入格式

第一行输入两个整数 $n$ 和 $m$（$1 \leq n, m \leq 200$），分别表示簇的总数和文件的总数。接下来的 $m$ 行描述每个文件。每行开始是一个整数 $n_i$（$n_i \geq 1$），表示第 $i$ 个文件所占的簇的数量，之后是 $n_i$ 个整数 $a_{i,1}$, $a_{i,2}$, ..., $a_{i,ni}$（$1 \leq a_{i,j} \leq n$），表示该文件占用的簇编号。确保每个簇编号不重复，并且总占用簇数小于 $n$，即有至少一个簇空闲。行内数字以空格分隔。

## 输出格式

第一行输出整数 $k$（$0 \leq k \leq 2n$），表示所需操作的次数。接下来 $k$ 行，每行格式为 "i j"，表示将编号为 $i$ 的簇内容复制到编号为 $j$ 的簇。

## 说明/提示

假设一个硬盘由 $8$ 个簇组成，并存储两个文件。第一个文件占用两个簇，第二个文件占用三个簇。以下给出碎片整理后文件位置的正确和错误示例：

示例 2：每个文件必须在一段连续的内存区域中。

示例 3：文件之间的顺序不重要，第一个文件和第二个文件的存储顺序可以互换。

示例 4：文件中各片段的顺序不允许改变。

示例 5：未使用的簇必须位于末尾，例如在该示例中，未使用的簇是 $3$, $7$, $8$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
7 2
2 1 2
3 3 4 5

```

### 输出

```
0

```

## 样例 #2

### 输入

```
7 2
2 1 3
3 2 4 5

```

### 输出

```
3
2 6
3 2
6 3

```


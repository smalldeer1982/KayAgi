---
title: "Eternal Victory"
layout: "post"
diff: 普及+/提高
pid: CF61D
tag: []
---

# Eternal Victory

## 题目描述

经历了一场激烈的战斗之后，Valerian被Shapur抓住了。这个胜利是如此的伟大，以至于Shapur决定把Valerian的失败（也就是他的胜利）的场景雕刻在山上。所以他必须找到最好的地方使他的胜利永远被保存。

他决定到波斯的n个城市去寻找可以使用的最好的山，但是战斗后他太累了，所以不想走太多的路。因此，他希望以最短的路径走遍所有的n个城市。某些城市以双向道路相连。你可以通过这些道路从一个城市到另一个城市。在两个城市间最多只有一条双向道路。所有城市被从1到n编号。

Shapur目前在城市1，他想以最短的路径访问所有其他城市。他可以在任何城市结束他的旅行。

帮助Shapur算出他最少要走多远的路。

## 输入格式

第一行为一个数字n，表示城市的数量。

接下来的n-1行，每行有三个数字x[i],y[i],w[i],表示一条连接两个城市的双向道路。其中x[i]和y[i]分别表示路所连接的两个城市，w[i]表示这条路的长度。

## 输出格式

输出只有一个数字，为Shapur遍历n个城市所需走过的最短距离。

注意：C++语言请不要使用%I64d来输出64位整数。请优先考虑使用cout（也可以使用%lld）来输出。

感谢@Simpson561 提供的翻译

## 样例 #1

### 输入

```
3
1 2 3
2 3 4

```

### 输出

```
7

```

## 样例 #2

### 输入

```
3
1 2 3
1 3 3

```

### 输出

```
9

```


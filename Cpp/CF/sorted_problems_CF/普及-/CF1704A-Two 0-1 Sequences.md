---
title: "Two 0-1 Sequences"
layout: "post"
diff: 普及-
pid: CF1704A
tag: ['贪心']
---

# Two 0-1 Sequences

## 题目描述

你有两个 $01$ 串 $a$ 和 $b$，每次你可以对 $a$ 串进行以下两种操作（以下 $a_1$ 表示 $a$ 现在的第一个字符，$a_2$ 表示 $a$ 现在的第二个字符，以此类推）：

1. 若 $|a| \geq 2$，则可将 $a_2$ 改为 $\min(a_1,a_2)$，然后删除 $a_1$。
2. 若 $|a| \geq 2$，则可将 $a_2$ 改为 $\max(a_1,a_2)$，然后删除 $a_1$。

显然，删除 $a_1$ 后，原先的 $a_2$ 变成 $a_1$，$a_3$ 变成 $a_2$，$a$ 的长度减少 $1$。

试判断 $a$ 是否能够经过若干次操作（也可以不进行操作）变成 $b$。

## 输入格式

第一行一个正整数 $t$（$1 \leq t \leq 2000$），表示测试数据的组数。接下来每组数据三行：
- 第一行，两个正整数 $n$ 和 $m$，表示 $a$ 和 $b$ 的长度。保证 $1 \leq m \leq n \leq 50$。
- 第二行一个 $01$ 串 $a$。
- 第三行一个 $01$ 串 $b$。

## 输出格式

输出共 $t$ 行，每行一个字符串 ``YES`` 或 ``NO``（大小写不敏感），表示 $a$ 能否变成 $b$。
### 样例解释
- 第一组样例：对 $a$ 不断进行操作 $2$ 即可。
- 第二组样例：对 $a$ 不断进行操作 $1$ 即可。
- 第三、四组样例：显然，无论如何对 $a$ 进行操作都无法使其变成 $b$。
- 第五组样例：虽然可以用操作 $2$ 使 $a$ 变成 $10101$（这与 $b$ 的第一个字符相同），但显然，无论如何对 $a$ 进行操作都无法使其变成 $b$。

## 样例 #1

### 输入

```
10
6 2
001001
11
6 2
110111
01
6 2
000001
11
6 2
111111
01
8 5
10000101
11010
7 4
1010001
1001
8 6
01010010
010010
8 4
01010101
1001
8 4
10101010
0110
7 5
1011100
11100
```

### 输出

```
YES
YES
NO
NO
NO
YES
YES
NO
NO
YES
```


---
title: "Having Been a Treasurer in the Past, I Help Goblins Deceive"
layout: "post"
diff: 普及-
pid: CF2072B
tag: ['排列组合']
---

# Having Been a Treasurer in the Past, I Help Goblins Deceive

## 题目描述

完成第一个任务后，章人（Akito）离开了初始洞穴。不久后，他偶然发现了一个哥布林村落。

由于章人无处可居，他想了解房屋的价格。众所周知，哥布林将数字写作由字符 '-' 和 '\_' 组成的字符串，字符串 $ s $ 所表示的数值等于其所有等于字符串 "-\_-" 的不同子序列 $ ^{\text{∗}} $ 的数量（这与哥布林的面部特征非常相似）。

例如，字符串 $ s = $ "-\_--\_-" 表示的数值为 $ 6$，因为它包含 $ 6 $ 个 "-\_-" 子序列：

1. $ s_1 + s_2 + s_3 $
2. $ s_1 + s_2 + s_4 $
3. $ s_1 + s_2 + s_6 $
4. $ s_1 + s_5 + s_6 $
5. $ s_3 + s_5 + s_6 $
6. $ s_4 + s_5 + s_6 $

最初，哥布林在回答章人的问题时随机写了一个字符串数值 $ s$，但随后他们意识到想要从旅行者身上获取尽可能多的黄金。为此，他们要求你重新排列字符串 $ s $ 中的字符，使得该字符串所表示的数值最大化。

$ ^{\text{∗}} $ 字符串 $ a $ 的子序列是指通过删除 $ a $ 中若干（可能为 $ 0 $）个字符后得到的字符串 $ b$。若两个子序列是通过删除不同位置的字符得到的，则它们被视为不同的子序列。

## 输入格式

第一行包含一个整数 $ t $（$ 1 \le t \le 10^4$）—— 测试用例的数量。

每个测试用例的第一行包含一个整数 $ n $（$ 1 \le n \le 2 \cdot 10^5$）—— 哥布林所写字符串的长度。

每个测试用例的第二行包含一个长度为 $ n $ 的字符串 $ s$，仅由字符 '-' 和 '\_' 组成——哥布林所写的字符串。

保证所有测试用例的 $ n $ 之和不超过 $ 2 \cdot 10^5$。

## 输出格式

对于每个测试用例，输出一个整数——在最优重排字符串 $ s $ 后，等于字符串 "-\_-" 的子序列的最大数量。

## 说明/提示

第一个测试用例中，最优方案是将字符重排为 "-\_-"。这是唯一一个长度为 $ 3 $ 且至少包含一个 "-\_-" 子序列的字符串。

第二个测试用例中，只有一个字符 "-"，而构成子序列 "-\_-" 至少需要两个 "-"。这意味着无论如何重排，答案都是 $ 0$。

第七和第八个测试用例中，字符串长度 $ n < 3$，这意味着长度为 $ 3 $ 的子序列不存在。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
8
3
--_
5
__-__
9
--__-_---
4
_--_
10
_-_-_-_-_-
7
_------
1
-
2
_-
```

### 输出

```
1
0
27
2
30
9
0
0
```


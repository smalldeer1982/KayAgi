---
title: "Binary Typewriter"
layout: "post"
diff: 普及-
pid: CF2103B
tag: ['数学', '分类讨论']
---

# Binary Typewriter

## 题目描述

给定一个长度为 $n$ 的二进制字符串 $s$ 和一个带有两个按钮（0 和 1）的打字机。初始时，你的手指放在按钮 0 上。你可以执行以下两种操作：

1. 按下当前手指所在的按钮。这将打出该按钮上的字符。
2. 将手指移动到另一个按钮。如果手指在按钮 0 上，则移动到按钮 1，反之亦然。

二进制字符串的代价定义为输入整个字符串所需的最少操作次数。

在输入之前，你可以选择最多反转 $s$ 的一个子串 $^{\text{∗}}$。更正式地说，你可以选择两个下标 $1 \le l \le r \le n$，并将子串 $s_{l \ldots r}$ 反转，得到新字符串 $s_1s_2 \ldots s_{l-1}s_rs_{r-1} \ldots s_ls_{r+1} \ldots s_n$。

你的任务是找出在最多进行一次子串反转后，所有可能得到的字符串中的最小可能代价。

$^{\text{∗}}$ 字符串 $a$ 是字符串 $b$ 的子串，当且仅当 $a$ 可以通过从 $b$ 的开头和结尾删除若干（可能为零或全部）字符得到。

## 输入格式

每个测试包含多个测试用例。第一行输入测试用例数量 $t$（$1 \le t \le 10^4$）。接下来是各测试用例的描述。

每个测试用例的第一行包含一个整数 $n$（$1 \le n \le 2 \cdot 10^5$）——二进制字符串 $s$ 的长度。

每个测试用例的第二行包含一个二进制字符串 $s_1s_2 \ldots s_n$（$s_i = \mathtt{0}$ 或 $s_i = \mathtt{1}$）——二进制字符串 $s$ 的字符。

保证所有测试用例的 $n$ 之和不超过 $2 \cdot 10^5$。

## 输出格式

对于每个测试用例，输出在最多进行一次子串反转后，字符串 $s$ 的最小代价。


## 说明/提示

在第一个测试用例中，我们可以选择不反转任何子串。我们可以执行操作 1 三次来输入 000。

在第二个测试用例中，我们可以选择不反转任何子串。我们可以执行操作 2 将手指移动到按钮 1，然后执行操作 1 三次来输入 111。

在第三个测试用例中，我们可以选择不反转任何子串。我们可以执行操作 1 输入 0，然后执行操作 2 将手指移动到按钮 1，最后执行操作 1 两次输入 11，最终以 4 次操作得到字符串 011。

在第四个测试用例中，我们可以反转子串 $s_{1 \ldots 3}$，得到字符串 001。我们可以执行操作 1 两次输入 00，然后执行操作 2 将手指移动到按钮 1，最后执行操作 1 一次输入 1，最终以 4 次操作得到字符串 001。

在第五个测试用例中，我们可以反转子串 $s_{2 \ldots 3}$，得到字符串 11001。该字符串的代价为 8，操作序列如下：
- 执行操作 2 将手指移动到按钮 1。
- 执行操作 1 两次输入 11。
- 执行操作 2 将手指移动到按钮 0。
- 执行操作 1 两次输入 00。
- 执行操作 2 将手指移动到按钮 1。
- 执行操作 1 一次输入 1。

在第六个测试用例中，我们可以反转子串 $s_{5 \ldots 17}$，得到字符串 1101111011001001000。可以证明，输入该二进制字符串所需的最少操作次数为 29。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
6
3
000
3
111
3
011
3
100
5
10101
19
1101010010011011100
```

### 输出

```
3
4
4
4
8
29
```


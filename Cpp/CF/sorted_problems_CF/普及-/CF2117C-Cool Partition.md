---
title: "Cool Partition"
layout: "post"
diff: 普及-
pid: CF2117C
tag: ['贪心']
---

# Cool Partition

## 题目描述

鸭鸭有一个大小为 $ n $ 的数组 $ a $。他想将这个数组分割成一个或多个连续的段，使得每个元素 $ a_i $ 恰好属于一个段。

如果对于每一个段 $ b_j $，所有在 $ b_j $ 中的元素也出现在 $ b_{j + 1} $ 中（如果存在的话），那么这个分割就被称为**酷分割**。也就是说，一个段中的每一个元素必须也出现在它之后的段中。

例如，如果 $ a = [1, 2, 2, 3, 1, 5] $，鸭鸭可以做出一个酷分割 $ b_1 = [1, 2] $，$ b_2 = [2, 3, 1, 5] $。这是一个酷分割，因为 $ b_1 $ 中的所有元素（即 $ 1 $ 和 $ 2 $）也出现在 $ b_2 $ 中。相反，$ b_1 = [1, 2, 2] $，$ b_2 = [3, 1, 5] $ 不是一个酷分割，因为 $ 2 $ 出现在 $ b_1 $ 中但没有出现在 $ b_2 $ 中。

注意，在分割数组后，不能改变段的顺序。另外，如果一个元素在某段 $ b_j $ 中出现多次，它只需要在 $ b_{j + 1} $ 中出现至少一次。

你的任务是帮助鸭鸭找到一个酷分割的最大段数。

## 输入格式

输入的第一行包含一个整数 $ t $（$ 1 \le t \le 10^4 $）——测试用例的数量。

每个测试用例的第一行包含一个整数 $ n $（$ 1 \le n \le 2 \cdot 10^5 $）——数组的大小。

每个测试用例的第二行包含 $ n $ 个整数 $ a_1, a_2, \dots, a_n $（$ 1 \le a_i \le n $）——数组的元素。

保证所有测试用例的 $ n $ 之和不超过 $ 2 \cdot 10^5 $。

## 输出格式

对于每个测试用例，输出一个整数——构成酷分割的最大段数。

## 说明/提示

第一个测试用例在题目描述中已经解释过。我们可以将其分割为 $ b_1 = [1, 2] $，$ b_2 = [2, 3, 1, 5] $。可以证明没有其他分割方式能得到更多的段。

在第二个测试用例中，我们可以将数组分割为 $ b_1 = [1, 2] $，$ b_2 = [1, 3, 2] $，$ b_3 = [1, 3, 2] $。最大段数为 $ 3 $。

在第三个测试用例中，唯一可行的分割是 $ b_1 = [5, 4, 3, 2, 1] $。任何其他分割方式都无法满足条件。因此，答案是 $ 1 $。

## 样例 #1

### 输入

```
8
6
1 2 2 3 1 5
8
1 2 1 3 2 1 3 2
5
5 4 3 2 1
10
5 8 7 5 8 5 7 8 10 9
3
1 2 2
9
3 3 1 4 3 2 4 1 2
6
4 5 4 5 6 4
8
1 2 1 2 1 2 1 2
```

### 输出

```
2
3
1
3
1
3
3
4
```


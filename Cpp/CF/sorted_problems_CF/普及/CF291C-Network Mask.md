---
title: "Network Mask"
layout: "post"
diff: 普及/提高-
pid: CF291C
tag: []
---

# Network Mask

## 题目描述

## 题目背景

该问题使用了一个简化的TCP/IP地址模型，请确保您仔细阅读了该声明。


Polycarpus找到了一份工作，他是一名系统管理员。

有一天他偶然发现了n个IP地址。

每个IP地址是一个32位的数字，用4个8位数字(不带前导零)组成一组，用点分隔。

例如，记录0.255.1.123显示正确的IP地址，记录0.256.1.123和0.255.1.01不正确。

在这个问题中，由4个8位数字组成的任意组就是一个正确的IP地址。

Polycarpus作为一名管理员工作了一段时间，了解到如果您知道IP地址，您可以使用子网掩码来获得拥有该IP地址的网络地址。

子网掩码是一个IP地址，它有以下属性:如果我们把这个IP地址写为一个32位的字符串，它可以表示为“11…11000..000”。

换句话说，子网掩码首先有一个或多个1位，然后是一个或多个0位(总共有32位)。

例如，IP地址2.0.0.0不是一个正确的子网掩码，因为它的32位记录看起来是0000001000000000000000000000。

要得到IP地址的网络地址，需要执行IP地址和子网掩码的按位“与”操作。

例如，如果子网掩码是255.192.0.0,IP地址是192.168.1.2，则网络地址等于192.128.0.0。

在按位的“与”中，当且仅当两个操作数对应的位都等于1时，结果的位等于1。

现在Polycarpus想要找到他的IP地址所属的所有网络。

不幸的是Polycarpus丢失了子网掩码。

幸运的是，Polycarpus记得他的IP地址完全属于 $k$ 种不同的网络。

帮助Polycarpus找到子网掩码，这样他的IP地址将完全属于 $k$ 种不同的网络。

如果有多个子网掩码，则查找位记录中1个数最少的一个。

如果不存在这样的子网掩码，输出-1。

## 输入格式

第一行包含两个整数，$n$ 和 $k$$（1<=k<=n<=10^{5}）$
表示IP地址和网络的数量。接下来的 $n$ 行每行包含一条IP地址。保证所有IP地址都是不同的。

## 输出格式

如果存在所需的子网掩码，则以语句中描述的格式在单行中输出子网掩码的IP地址。否则输出-1。

## 样例 #1

### 输入

```
5 3
0.0.0.1
0.1.1.2
0.0.2.1
0.1.1.0
0.0.2.3

```

### 输出

```
255.255.254.0
```

## 样例 #2

### 输入

```
5 2
0.0.0.1
0.1.1.2
0.0.2.1
0.1.1.0
0.0.2.3

```

### 输出

```
255.255.0.0
```

## 样例 #3

### 输入

```
2 1
255.0.0.1
0.0.0.2

```

### 输出

```
-1

```


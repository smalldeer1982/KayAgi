---
title: "Сортировка слиянием"
layout: "post"
diff: 难度0
pid: CF1531E1
tag: []
---

# Сортировка слиянием

## 题目描述

考虑以下 Python 代码实现的归并排序：

```
<pre class="lstlisting">```
def sort(a):
  n = len(a)
  b = [0 for i in range(n)]
  log = []

  def mergeSort(l, r):
    if r - l <= 1:
      return
    m = (l + r) >> 1
    mergeSort(l, m)
    mergeSort(m, r)
    i, j, k = l, m, l
    while i < m and j < r:
      if a[i] < a[j]:
        log.append('0')
        b[k] = a[i]
        i += 1
      else:
        log.append('1')
        b[k] = a[j]
        j += 1
      k += 1
    while i < m:
      b[k] = a[i]
      i += 1
      k += 1
    while j < r:
      b[k] = a[j]
      j += 1
      k += 1
    for p in range(l, r):
      a[p] = b[p]

  mergeSort(0, n)
  return "".join(log)
```
```

这段代码中使用了日志记录，这对于开发者来说是一个非常重要的工具。VK 的高级开发者瓦西里曾经生成了一个排列 $a$（这是一个包含从 $1$ 到 $n$ 的 $n$ 个不同整数的数组），并将它传入 `sort` 函数，得到一个输出字符串 $s$。不幸的是，第二天他只找到了这个字符串 $s$，而原始排列 $a$ 已经丢失。

瓦西里想要恢复一个排列 $a$，使得调用 `sort` 函数后能产生相同的字符串 $s$。请帮助他实现这一目标！

## 输入格式

输入是一个包含字符 '0' 和 '1' 的非空字符串 $s$。

在本题中，每个测试用例都有一个长度为 $16$ 的排列能够满足要求。然而，你可以输出任意长度的排列，只要满足条件即可。

## 输出格式

在第一行输出一个整数 $n$，表示排列的长度。

在第二行输出 $n$ 个互不相同的整数 $a_0, a_1, \ldots, a_{n-1}$，其中 $1 \le a_i \le n$ 表示排列的元素。

如果有多个满足条件的答案，输出任意一个即可。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
00000000000000000000000000000000
```

### 输出

```
16
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
```

## 样例 #2

### 输入

```
11111111111111111111111111111111
```

### 输出

```
16
16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
```

## 样例 #3

### 输入

```
101011010001100100011011001111011000011110010
```

### 输出

```
16
13 6 1 7 12 5 4 15 14 16 10 11 3 8 9 2
```


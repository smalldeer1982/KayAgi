---
title: "Tree Recovery"
layout: "post"
diff: 省选/NOI-
pid: CF1696F
tag: ['构造']
---

# Tree Recovery

## 题目描述

给定一棵 $n$ 个节点的树，节点编号为 $1\sim n$。

树的形态是未知的，但我们知道：
* 所有边的边权都为 $1$。
* $n-1$ 行信息：
	* 第 $i$ 行信息由 $n-i$ 个以空格隔开的 $01$ 字符串组成。
	* 定义 $d(x,y)$ 为树上 $x,y$ 两点之间的距离。我们约定字符串下标从 $1$开始。
   * 对于第 $i$ 行的 第 $j$ 个字符串 $s$，$s_k=0$ 表示 $d(i,k)\neq d(i+j,k)$，$s_k=1$ 表示 $d(i,k)=d(i+j,k)$。

## 输入格式

**本题有多组数据**。
* 第一行是一个整数 $t$，表示数据组数。

对于每组数据：
* 第一行是一个整数 $n$，表示树的节点数量。

## 输出格式

对于每组数据：
* 如果不存在符合要求的树，输出一行，内容为一个字符串 `No`。
* 如果存在符合要求的树，输出 $n$ 行：
	* 第一行输出一个字符串 `Yes`。
   * 接下来 $n-1$ 行，每行输出两个用空格隔开的整数 $x,y$，表示 $x$ 和 $y$ 之间有一条边。
   * 如果符合要求的树的形态不唯一，你可以输出任何一种（原文没有提及边的输出顺序，但样例中是以 $x$ 为第一关键字，$y$ 为第二关键字的字典序升序）。
* 对 `Yes` 和 `No` 大小写不敏感，每个字母都可以以大写或小写输出。

## 说明/提示

对于所有测试点，$t\leqslant 200$，$n\leqslant 100$。

对于每个测试点的多组数据，至多有 $2$ 组数据的 $n>50$，至多有 $5$ 组数据的 $n>20$。

## 样例 #1

### 输入

```
5
2
00
2
10
3
001 000
000
3
001 010
000
5
00000 01001 00000 01100
00000 10000 00000
00000 11010
00000
```

### 输出

```
Yes
1 2
No
Yes
1 3
2 3
No
Yes
1 2
1 4
2 3
2 5
```


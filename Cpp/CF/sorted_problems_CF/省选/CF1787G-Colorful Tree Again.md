---
title: "Colorful Tree Again"
layout: "post"
diff: 省选/NOI-
pid: CF1787G
tag: []
---

# Colorful Tree Again

## 题目描述

给定一棵有 $n$ 个节点的树，边有边权和颜色。每个点有被摧毁和不被摧毁两种状态，初始所有点都没被摧毁。

一条简单路径指图中没有重复节点的路径。简单路径的长度定义为路径上所有边的边权之和。

定义一条简单路径是好的，当且仅当路径仅有某一种颜色 $c$ 构成，且所有颜色为 $c$ 的边都在这条简单路径里，且路径上所有节点都没被摧毁。

你需要处理两种操作：

1. 摧毁一个节点；
2. 修复一个节点。

每个操作之后，你都需要输出最长的好的路径长度。若没有输出 $0$。

~~写了 3 次样例解释全被删了 QAQ~~

## 输入格式

第一行两个正整数 $n$ 和 $q$（$1 \leq n,q \leq 2\cdot 10^5$）表示节点个数和询问个数。

接下来 $n-1$ 行，每行四个正整数 $u,v,w,c$（$1 \leq u,v,w,c \leq n$，$u \not = v$）表示一条树边 $(u,v)$，边权为 $w$，颜色为 $c$。保证输入形成一棵树。

接下来 $q$ 行，每行两个正整数 $p$ 和 $x$（$p$ 非 $0$ 即 $1$，$1\le x\le n$）表示一个询问：

1. 若 $p = 0$，表示摧毁节点 $x$，保证此时 $x$ 没被摧毁；
2. 若 $p = 1$，表示修复节点 $x$，保证此时 $x$ 已被摧毁。

## 输出格式

每个询问后，输出最长的好的路径的长度。若没有输出 $0$。

## 样例 #1

### 输入

```
5 4
4 1 3 4
5 2 4 4
3 1 3 2
1 2 5 1
0 4
0 3
0 2
1 3
```

### 输出

```
5
5
0
3
```

## 样例 #2

### 输入

```
5 5
4 1 4 4
4 5 2 2
3 1 2 4
3 2 3 1
0 3
0 4
1 3
1 4
0 1
```

### 输出

```
2
0
3
6
3
```

## 样例 #3

### 输入

```
6 9
3 2 2 3
2 4 4 2
3 1 5 5
6 4 3 2
5 3 1 3
0 2
0 4
0 5
0 6
1 2
1 4
1 5
0 3
1 6
```

### 输出

```
5
5
5
5
5
5
5
0
7
```

## 样例 #4

### 输入

```
1 2
0 1
1 1
```

### 输出

```
0
0
```


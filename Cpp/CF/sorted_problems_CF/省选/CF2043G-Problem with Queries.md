---
title: "Problem with Queries"
layout: "post"
diff: 省选/NOI-
pid: CF2043G
tag: ['分块']
---

# Problem with Queries

## 题目描述

给定一个整数数组 $a$，长度为 $n$。你的任务是处理 $q$ 个查询，这些查询分为两种类型：

- 类型 1：`1 p x` — 将数组中索引为 $p$ 的元素值更新为 $x$；
- 类型 2：`2 l r` — 计算数组 $a$ 中满足条件的索引对 $(i, j)$ 的数量，其中 $l \le i < j \le r$ 且 $a_i \ne a_j$。

请注意，这些查询是编码过的；每个后续查询必须在解出前一个类型 2 查询的答案后才能解码。

## 输入格式

第一行输入一个整数 $n$，表示数组的长度（$1 \le n \le 10^5$）。

第二行输入 $n$ 个整数，分别为 $a_1, a_2, \dots, a_n$（$1 \le a_i \le n$）。

第三行输入一个整数 $q$，代表要处理的查询数量（$1 \le q \le 3 \cdot 10^5$）。

接下来的 $q$ 行中，每行描述了一个查询，格式如下：

- 类型 1：以 `1 p' x'` 的形式给出（$0 \le p', x' \le n-1$）；
- 类型 2：以 `2 l' r'` 的形式给出（$0 \le l', r' \le n-1$）。

查询的解码规则如下：设 $\mathit{last}$ 为最近一次处理的类型 2 查询的答案（最初，$\mathit{last} = 0$）。

- 如果是类型 1 查询，则 $p = ((p' + \mathit{last}) \bmod n) + 1$，$x = ((x' + \mathit{last}) \bmod n) + 1$。
- 如果是类型 2 查询，则 $l = ((l' + \mathit{last}) \bmod n) + 1$，$r = ((r' + \mathit{last}) \bmod n) + 1$。如若 $l > r$，则将两者交换。

请务必在回答每一个类型 2 查询后更新 $\mathit{last}$ 的值。

输入保证至少有一个类型 2 的查询。

## 输出格式

对于每一个类型 2 的查询，输出一个整数，即满足条件的索引对 $(i, j)$ 的数量，其中 $l \le i < j \le r$ 且 $a_i \ne a_j$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
1 2 3
5
2 0 2
1 0 2
2 0 2
1 2 0
2 1 0
```

### 输出

```
3 2 0
```

## 样例 #2

### 输入

```
7
1 3 4 4 7 1 3
3
2 1 6
2 1 0
2 5 6
```

### 输出

```
13 18 0
```


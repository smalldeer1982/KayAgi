---
title: "Tree Array"
layout: "post"
diff: 提高+/省选-
pid: CF1540B
tag: ['树形 DP', '组合数学', '概率论']
---

# Tree Array

## 题目描述

You are given a tree consisting of $ n $ nodes. You generate an array from the tree by marking nodes one by one.

Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree.

After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node.

It can be shown that the process marks all nodes in the tree.

The final array $ a $ is the list of the nodes' labels in order of the time each node was marked.

Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.

The number of inversions in an array $ a $ is the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i > a_j $ . For example, the array $ [4, 1, 3, 2] $ contains $ 4 $ inversions: $ (1, 2) $ , $ (1, 3) $ , $ (1, 4) $ , $ (3, 4) $ .

## 输入格式

The first line contains a single integer $ n $ ( $ 2 \le n \le 200 $ ) — the number of nodes in the tree.

The next $ n - 1 $ lines each contains two integers $ x $ and $ y $ ( $ 1 \le x, y \le n $ ; $ x \neq y $ ), denoting an edge between node $ x $ and $ y $ .

It's guaranteed that the given edges form a tree.

## 输出格式

Output the expected number of inversions in the generated array modulo $ 10^9+7 $ .

Formally, let $ M = 10^9+7 $ . It can be shown that the answer can be expressed as an irreducible fraction $ \frac{p}{q} $ , where $ p $ and $ q $ are integers and $ q \not \equiv 0 \pmod{M} $ . Output the integer equal to $ p \cdot q^{-1} \bmod M $ . In other words, output such an integer $ x $ that $ 0 \le x < M $ and $ x \cdot q \equiv p \pmod{M} $ .

## 说明/提示

This is the tree from the first sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/3833e6cdc8f432e8774aa8c02d9352118566a812.png)For the first sample, the arrays are almost fixed. If node $ 2 $ is chosen initially, then the only possible array is $ [2, 1, 3] $ ( $ 1 $ inversion). If node $ 3 $ is chosen initially, then the only possible array is $ [3, 1, 2] $ ( $ 2 $ inversions). If node $ 1 $ is chosen initially, the arrays $ [1, 2, 3] $ ( $ 0 $ inversions) and $ [1, 3, 2] $ ( $ 1 $ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $ \frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6} $ .

 $ 166666669 \cdot 6 = 7 \pmod {10^9 + 7} $ , so the answer is $ 166666669 $ .

This is the tree from the second sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/7f613b365926417ec34142a093ccc13b3b572f4f.png)This is the tree from the third sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/4cf8ac5fc765cc7cdc6657a332a13e66dcba8fef.png)

## 样例 #1

### 输入

```
3
1 2
1 3
```

### 输出

```
166666669
```

## 样例 #2

### 输入

```
6
2 1
2 3
6 1
1 4
2 5
```

### 输出

```
500000009
```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
2 5
```

### 输出

```
500000007
```



---

---
title: "Shuffle"
layout: "post"
diff: 提高+/省选-
pid: CF1622D
tag: ['组合数学', '差分']
---

# Shuffle

## 题目描述

You are given a binary string (i. e. a string consisting of characters 0 and/or 1) $ s $ of length $ n $ . You can perform the following operation with the string $ s $ at most once: choose a substring (a contiguous subsequence) of $ s $ having exactly $ k $ characters 1 in it, and shuffle it (reorder the characters in the substring as you wish).

Calculate the number of different strings which can be obtained from $ s $ by performing this operation at most once.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 2 \le n \le 5000 $ ; $ 0 \le k \le n $ ).

The second line contains the string $ s $ of length $ n $ , consisting of characters 0 and/or 1.

## 输出格式

Print one integer — the number of different strings which can be obtained from $ s $ by performing the described operation at most once. Since the answer can be large, output it modulo $ 998244353 $ .

## 说明/提示

Some strings you can obtain in the first example:

- to obtain 0110110, you can take the substring from the $ 1 $ -st character to the $ 4 $ -th character, which is 1100, and reorder its characters to get 0110;
- to obtain 1111000, you can take the substring from the $ 3 $ -rd character to the $ 7 $ -th character, which is 00110, and reorder its characters to get 11000;
- to obtain 1100101, you can take the substring from the $ 5 $ -th character to the $ 7 $ -th character, which is 110, and reorder its characters to get 101.

In the second example, $ k = 0 $ so you can only choose the substrings consisting only of 0 characters. Reordering them doesn't change the string at all, so the only string you can obtain is 10010.

## 样例 #1

### 输入

```
7 2
1100110
```

### 输出

```
16
```

## 样例 #2

### 输入

```
5 0
10010
```

### 输出

```
1
```

## 样例 #3

### 输入

```
8 1
10001000
```

### 输出

```
10
```

## 样例 #4

### 输入

```
10 8
0010011000
```

### 输出

```
1
```



---

---
title: "Finding Zero"
layout: "post"
diff: 提高+/省选-
pid: CF1634D
tag: ['数学']
---

# Finding Zero

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1634D/74895b22455b2b459cd8609f4caa3df7273f47e6.png)This is an interactive problem.

We picked an array of whole numbers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 10^9 $ ) and concealed exactly one zero in it! Your goal is to find the location of this zero, that is, to find $ i $ such that $ a_i = 0 $ .

You are allowed to make several queries to guess the answer. For each query, you can think up three distinct indices $ i, j, k $ , and we will tell you the value of $ \max(a_i, a_j, a_k) - \min(a_i, a_j, a_k) $ . In other words, we will tell you the difference between the maximum and the minimum number among $ a_i $ , $ a_j $ and $ a_k $ .

You are allowed to make no more than $ 2 \cdot n - 2 $ queries, and after that you have two tries to guess where the zero is. That is, you have to tell us two numbers $ i $ and $ j $ and you win if $ a_i = 0 $ or $ a_j = 0 $ .

Can you guess where we hid the zero?

Note that the array in each test case is fixed beforehand and will not change during the game. In other words, the interactor is not adaptive.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 500 $ ). Description of the test cases follows.

The first and only line of each test case contains an integer $ n $ ( $ 4 \le n \le 1000 $ ) — the length of the array that we picked.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 3000 $ .

## 输出格式

For each test case, the interaction starts with reading $ n $ .

To make a query, print "? $ i $ $ j $ $ k $ " (without quotes, $ 1 \le i, j, k \le n $ , indices must be distinct). Then you should read our response from standard input, that is, $ \max(a_i, a_j, a_k) - \min(a_i, a_j, a_k) $ .

If the response is $ -1 $ , it means your program has made an invalid query or has run out of tries. Your program must terminate immediately after reading $ -1 $ , and you will get a verdict Wrong answer. Otherwise you may get any verdict, because the program will continue reading from the closed stream. Note that if the query is correct, the answer will never be $ -1 $ because $ \max(a_i, a_j, a_k) - \min(a_i, a_j, a_k) \geq 0 $ .

To give the final answer, print "! $ i $ $ j $ " (without the quotes). Printing the same number twice (that is, $ i = j $ ) is allowed. Note that giving this answer is not counted towards the limit of $ 2 \cdot n - 2 $ queries. After that, your program must continue to solve the remaining test cases, or exit if all test cases have been solved.

After printing a query, don't forget to output line feed and flush the output buffer. Otherwise you will get the verdict Idleness limit exceeded. To flush the buffer, use:

- fflush(stdout) or cout.flush() in C++;
- System.out.flush() in Java;
- flush(output) in Pascal;
- stdout.flush() in Python;
- Read documentation for other languages.

Hacks

The first line must contain an integer $ t $ ( $ 1 \le t \le 500 $ ) — the count of test cases.

The first line of each test case must contain an integer $ n $ ( $ 4 \le n \le 1000 $ ) — the length of the hidden array.

The second line of each test case must contain $ n $ integers separated by spaces — $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 10^9 $ ). There must also be exactly one zero in this array.

The sum of $ n $ over all test cases must not exceed $ 3000 $ .

## 说明/提示

Array from sample: $ [1, 2, 0, 3] $ .

## 样例 #1

### 输入

```
1

4

2

3

3

2
```

### 输出

```
? 1 2 3

? 2 3 4

? 3 4 1

? 4 1 2

! 2 3
```



---

---
title: "Star MST"
layout: "post"
diff: 提高+/省选-
pid: CF1657E
tag: ['组合数学']
---

# Star MST

## 题目描述

In this problem, we will consider complete undirected graphs consisting of $ n $ vertices with weighted edges. The weight of each edge is an integer from $ 1 $ to $ k $ .

An undirected graph is considered beautiful if the sum of weights of all edges incident to vertex $ 1 $ is equal to the weight of MST in the graph. MST is the minimum spanning tree — a tree consisting of $ n-1 $ edges of the graph, which connects all $ n $ vertices and has the minimum sum of weights among all such trees; the weight of MST is the sum of weights of all edges in it.

Calculate the number of complete beautiful graphs having exactly $ n $ vertices and the weights of edges from $ 1 $ to $ k $ . Since the answer might be large, print it modulo $ 998244353 $ .

## 输入格式

The only line contains two integers $ n $ and $ k $ ( $ 2 \le n \le 250 $ ; $ 1 \le k \le 250 $ ).

## 输出格式

Print one integer — the number of complete beautiful graphs having exactly $ n $ vertices and the weights of edges from $ 1 $ to $ k $ . Since the answer might be large, print it modulo $ 998244353 $ .

## 样例 #1

### 输入

```
3 2
```

### 输出

```
5
```

## 样例 #2

### 输入

```
4 4
```

### 输出

```
571
```

## 样例 #3

### 输入

```
6 9
```

### 输出

```
310640163
```

## 样例 #4

### 输入

```
42 13
```

### 输出

```
136246935
```



---

---
title: "Points"
layout: "post"
diff: 提高+/省选-
pid: CF1701F
tag: ['线段树', '组合数学']
---

# Points

## 题目描述

若 $ i < j < k $ 且 $ k - i \le d $ 那么在数轴上的三个点 $ i $ , $ j $ 与 $ k $ 是美丽的一组点。 $d$ 是“定义三元组是否美丽的参数”。

在一个初始为空的数轴上给出一些点，你需要：

- 增加一个点
- 移除一个点
- 计算美丽的点的组数

## 输入格式

第一行两个整数 $q$ 和 $d$ ，分别代表查询数和定义三元组是否美丽的参数。

第二行 $q$ 个整数 $ a_1, a_2, \dots, a_q $ 整数 $a_i$ 表示第 $i$ 个查询，对于每一次查询：
- 如果存在点 $a_i$ 那么移除它，否则将他加入到数轴。
- 输出当前美丽的点的组数

## 输出格式

一共 $q$ 行，表示 $q$ 次查询。对于每次查询，输出一个整数，表示美丽的点的组数。

## 说明/提示

对于 $100\%$ 的数据， $1\le q , d\le 2\cdot 10^5$ $ 1 \le a_i \le 2 \cdot 10^5 $

## 样例 #1

### 输入

```
7 5
8 5 3 2 1 5 6
```

### 输出

```
0
0
1
2
5
1
5
```



---

---
title: "Chopping Carrots (Hard Version)"
layout: "post"
diff: 提高+/省选-
pid: CF1706D2
tag: ['数学', '线段树', '双指针 two-pointer']
---

# Chopping Carrots (Hard Version)

## 题目描述

这是该问题的困难版本。两个版本间的区别仅为 $n$、$k$、$a_i$ 和 $\sum n$ 的上界。

注意不正常的空间限制。

给出长度为 $n$ 的整数数组 $ a_1, a_2, \ldots, a_n $，以及一个整数 $k$。

一个长度为 $n$ 的整数数组 $ p_1, p_2, \ldots, p_n $ 的花费为 $\max\limits_{1 \le i \le n}\left(\left \lfloor \frac{a_i}{p_i} \right \rfloor \right) - \min\limits_{1 \le i \le n}\left(\left \lfloor \frac{a_i}{p_i} \right \rfloor \right)$。
此处，$ \lfloor \frac{x}{y} \rfloor $ 表示 $x$ 除以 $y$ 的整数部分。
请找到花费最小的数组 $p$，且满足对任意 $ 1 \le i \le n$ 都有 $ 1 \le p_i \le k $。

## 输入格式

第一行包括一个整数 $t$（$ 1 \le t \le 100 $），表示接下来测试组的数量。

对于每一个测试组，第一行包括两个整数 $n$ 和 $k$（$ 1 \le n, k \le 10^5 $）。

对于每一个测试组，第二行包括 $n$ 个整数 $ a_1, a_2, \ldots, a_n $（$ 1 \le a_1 \le a_2 \le \ldots \le a_n \le 10^5 $）。

保证 $\sum n \le 10^5$。

## 输出格式

对于每一个测试组，输出一个整数，表示满足上述条件的数组 $p$ 的花费的最小值。

## 样例 #1

### 样例输入 #1

```
7
5 2
4 5 6 8 11
5 12
4 5 6 8 11
3 1
2 9 15
7 3
2 3 5 5 6 9 10
6 56
54 286 527 1436 2450 2681
3 95
16 340 2241
2 2
1 3
```

### 样例输出 #1

```
2
0
13
1
4
7
0
```

## 说明/提示

在第一个测试组中，最优的数组是 $ p = [1, 1, 1, 2, 2] $。
$ \lfloor \frac{a_i}{p_i} \rfloor $ 得到的结果数组为 $ [4, 5, 6, 4, 5] $。
数组 $p$ 的花费为 $ \max\limits_{1 \le i \le n}(\lfloor \frac{a_i}{p_i} \rfloor) - \min\limits_{1 \le i \le n}(\lfloor \frac{a_i}{p_i} \rfloor) = 6 - 4 = 2 $。
可以证明，没有（满足题目条件的）数组的花费更小。

在第二个测试组中，最优的数组之一为 $ p = [12, 12, 12, 12, 12] $，它使得所有的 $ \lfloor \frac{a_i}{p_i} \rfloor $ 的值都为 $0$。

在第三个测试组中，唯一可能的数组为 $ p = [1, 1, 1] $。

## 样例 #1

### 输入

```
7
5 2
4 5 6 8 11
5 12
4 5 6 8 11
3 1
2 9 15
7 3
2 3 5 5 6 9 10
6 56
54 286 527 1436 2450 2681
3 95
16 340 2241
2 2
1 3
```

### 输出

```
2
0
13
1
4
7
0
```



---

---
title: "Tonya and Burenka-179"
layout: "post"
diff: 提高+/省选-
pid: CF1718C
tag: ['数学', '最大公约数 gcd']
---

# Tonya and Burenka-179

## 题目描述

Tonya 收到了一个长度为 $ n $ 的数列，写在了他的生日卡片上。出于某种原因，这个卡片原来是一个循环数组，所以严格位于第 $n$ 个元素右侧的元素的下标是 $ 1 $ 。Tonya 想更好地研究它，所以他买了一个机器人 `Burenka-179`。

Burenka 的程序是一个数对 $ (s, k) $ ，其中 $ 1 \leq s \leq n $ ， $ 1 \leq k \leq n-1 $ 。请注意，$k$ 不能等于 $n$。最初，Tonya 将机器人放在数组 $ s $ 的位置。之后，Burenka 在数组中准确地向前或者向后走了 $ n $ 步。如果在开始的时候，Burenka 站在 $i$ 的位置，那么会发生以下情况：

1. 数字$a_{i}$被加入到了到程序的有用值中。
2. Burenka 向右移动了 $k$ 步（ 一般情况下 $ i := i + k $ ，如果 $ i $ 变得大于 $ n $ ，则 $ i := i - n $ ）。

如果任何程序的初始有用值为 $ 0 $ ，则帮助 Tonya 算出程序最大可能的有用值。

此外，Tonya 的朋友 Ilyusha 要求他更改数组 $ q $ 次。每次他想为给定下标 $ p $ 和值 $ x $ 分配 $ a_p := x $ 。在每次进行这些更改之后，你得再次算出程序的最大可能有用值。

## 输入格式

第一行包含单个整数 $ t $ ( $ 1 \le t \le 10^4 $ ) 是测试用例的数量。测试用例的描述如下。

每个测试用例的第一行包含两个整数 $ n $ 和 $ q $ ( $ 2 \le n \le 2 \cdot 10^5 $ , $ 0 \le q \le 2 \cdot 10^5 $ )。

每个测试用例的第二行包含 $ n $ 个整数， $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le 10^9 $ ) — 数组的元素。

以下 $ q $ 行每行代表了更改操作，每行包含两个整数 $ p $ 和 $ x $ ( $ 1 \leq p \leq n $ , $ 1 \leq x \leq 10^9 $ )，意味着你应该分配$ a_p := x $ 。

保证所有测试用例的 $ n $ 和 $ q $ 的总和不超过 $ 2 \cdot 10^5 $ 。

## 输出格式

对于每个测试用例，输出 $ q+1 $ 个数字——程序最初和每次更改后的最大有用值。

## 说明/提示

在第一个测试用例中，最初时和更改后时，可以在 $ s = 1 $ 、 $ k = 1 $ 或 $ s = 2 $ 、 $ k = 1 $ 处找到答案。

在第二个测试用例中，最初，当 $ s = 1 $ , $ k = 2 $ 或 $ s = 3 $ , $ k = 2 $ 时得到答案。在第一次更改之后，在 $ s = 2 $ , $ k = 2 $ 或 $ s = 4 $ , $ k = 2 $ 处找到答案。

## 样例 #1

### 输入

```
4
2 1
1 2
1 3
4 4
4 1 3 2
2 6
4 6
1 1
3 11
9 3
1 7 9 4 5 2 3 6 8
3 1
2 1
9 1
6 3
1 1 1 1 1 1
1 5
4 4
3 8
```

### 输出

```
3
5
14
16
24
24
24
57
54
36
36
6
18
27
28
```



---

---
title: "Balance Addicts"
layout: "post"
diff: 提高+/省选-
pid: CF1738E
tag: ['组合数学']
---

# Balance Addicts

## 题目描述

Given an integer sequence $a_1, a_2, \dots, a_n$ of length $n$, your task is to compute the number, modulo $998244353$, of ways to partition it into several **non-empty** **continuous** subsequences such that the sums of elements in the subsequences form a **balanced** sequence.

A sequence $s_1, s_2, \dots, s_k$ of length $k$ is said to be balanced, if $s_{i} = s_{k-i+1}$ for every $1 \leq i \leq k$. For example, $[1, 2, 3, 2, 1]$ and $[1,3,3,1]$ are balanced, but $[1,5,15]$ is not.

Formally, every partition can be described by a sequence of indexes $i_1, i_2, \dots, i_k$ of length $k$ with $1 = i_1 < i_2 < \dots < i_k \leq n$ such that

1.  $k$ is the number of non-empty continuous subsequences in the partition;
2.  For every $1 \leq j \leq k$, the $j$\-th continuous subsequence starts with $a_{i_j}$, and ends exactly before $a_{i_{j+1}}$, where $i_{k+1} = n + 1$. That is, the $j$\-th subsequence is $a_{i_j}, a_{i_j+1}, \dots, a_{i_{j+1}-1}$.

There are $2^{n-1}$ different partitions in total.

Let $s_1, s_2, \dots, s_k$ denote the sums of elements in the subsequences with respect to the partition $i_1, i_2, \dots, i_k$. Formally, for every $1 \leq j \leq k$,

$$
s_j = \sum_{i=i_{j}}^{i_{j+1}-1} a_i = a_{i_j} + a_{i_j+1} + \dots + a_{i_{j+1}-1}. 
$$
 For example, the partition $[1\,|\,2,3\,|\,4,5,6]$ of sequence $[1,2,3,4,5,6]$ is described by the sequence $[1,2,4]$ of indexes, and the sums of elements in the subsequences with respect to the partition is $[1,5,15]$.

Two partitions $i_1, i_2, \dots, i_k$ and $i'_1, i'_2, \dots, i'_{k'}$ (described by sequences of indexes) are considered to be different, if at least one of the following holds.

-   $k \neq k'$,
-   $i_j \neq i'_j$ for some $1 \leq j \leq \min\left\{ k, k' \right\}$.


## 输入格式

Each test contains multiple test cases. The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^5 $ ) — the number of test cases. The following lines contain the description of each test case.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 10^5 $ ), indicating the length of the sequence $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 0 \leq a_i \leq 10^9 $ ), indicating the elements of the sequence $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output the number of partitions with respect to which the sum of elements in each subsequence is balanced, modulo $ 998244353 $ .

## 说明/提示

For the first test case, there is only one way to partition a sequence of length $ 1 $ , which is itself and is, of course, balanced.

For the second test case, there are $ 2 $ ways to partition it:

- The sequence $ [1, 1] $ itself, then $ s = [2] $ is balanced;
- Partition into two subsequences $ [1\,|\,1] $ , then $ s = [1, 1] $ is balanced.

For the third test case, there are $ 3 $ ways to partition it:

- The sequence $ [0, 0, 1, 0] $ itself, then $ s = [1] $ is balanced;
- $ [0 \,|\, 0, 1 \,|\, 0] $ , then $ s = [0, 1, 0] $ is balanced;
- $ [0, 0 \,|\, 1 \,|\, 0] $ , then $ s = [0, 1, 0] $ is balanced.

For the fourth test case, there are $ 4 $ ways to partition it:

- The sequence $ [1, 2, 3, 2, 1] $ itself, then $ s = [9] $ is balanced;
- $ [1, 2 \,|\, 3 \,|\, 2, 1] $ , then $ s = [3, 3, 3] $ is balanced;
- $ [1 \,|\, 2, 3, 2 \,|\, 1] $ , then $ s = [1, 7, 1] $ is balanced;
- $ [1 \,|\, 2 \,|\, 3 \,|\, 2 \,|\, 1] $ , then $ s = [1, 2, 3, 2, 1] $ is balanced.

For the fifth test case, there are $ 2 $ ways to partition it:

- The sequence $ [1, 3, 5, 7, 9] $ itself, then $ s = [25] $ is balanced;
- $ [1, 3, 5 \,|\, 7 \,|\, 9] $ , then $ s = [9, 7, 9] $ is balanced.

For the sixth test case, every possible partition should be counted. So the answer is $ 2^{32-1} \equiv 150994942 \pmod {998244353} $ .

## 样例 #1

### 输入

```
6
1
1000000000
2
1 1
4
0 0 1 0
5
1 2 3 2 1
5
1 3 5 7 9
32
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

### 输出

```
1
2
3
4
2
150994942
```



---

---
title: "Intersection and Union"
layout: "post"
diff: 提高+/省选-
pid: CF1743F
tag: ['动态规划 DP', '数学', '线段树']
---

# Intersection and Union

## 题目描述

You are given $ n $ segments on the coordinate axis. The $ i $ -th segment is $ [l_i, r_i] $ . Let's denote the set of all integer points belonging to the $ i $ -th segment as $ S_i $ .

Let $ A \cup B $ be the union of two sets $ A $ and $ B $ , $ A \cap B $ be the intersection of two sets $ A $ and $ B $ , and $ A \oplus B $ be the symmetric difference of $ A $ and $ B $ (a set which contains all elements of $ A $ and all elements of $ B $ , except for the ones that belong to both sets).

Let $ [\mathbin{op}_1, \mathbin{op}_2, \dots, \mathbin{op}_{n-1}] $ be an array where each element is either $ \cup $ , $ \oplus $ , or $ \cap $ . Over all $ 3^{n-1} $ ways to choose this array, calculate the sum of the following values:

 $ $$$|(((S_1\ \mathbin{op}_1\ S_2)\ \mathbin{op}_2\ S_3)\ \mathbin{op}_3\ S_4)\ \dots\ \mathbin{op}_{n-1}\ S_n| $ $ </p><p>In this expression,  $ |S| $  denotes the size of the set  $ S$$$.

## 输入格式

The first line contains one integer $ n $ ( $ 2 \le n \le 3 \cdot 10^5 $ ).

Then, $ n $ lines follow. The $ i $ -th of them contains two integers $ l_i $ and $ r_i $ ( $ 0 \le l_i \le r_i \le 3 \cdot 10^5 $ ).

## 输出格式

Print one integer — the sum of $ |(((S_1\ \mathbin{op}_1\ S_2)\ \mathbin{op}_2\ S_3)\ \mathbin{op}_3\ S_4)\ \dots\ \mathbin{op}_{n-1}\ S_n| $ over all possible ways to choose $ [\mathbin{op}_1, \mathbin{op}_2, \dots, \mathbin{op}_{n-1}] $ . Since the answer can be huge, print it modulo $ 998244353 $ .

## 样例 #1

### 输入

```
4
3 5
4 8
2 2
1 9
```

### 输出

```
162
```

## 样例 #2

### 输入

```
4
1 9
3 5
4 8
2 2
```

### 输出

```
102
```



---

---
title: "Yet Another Problem"
layout: "post"
diff: 提高+/省选-
pid: CF1747D
tag: ['数学', '贪心', '前缀和']
---

# Yet Another Problem

## 题目描述

You are given an array $ a $ of $ n $ integers $ a_1, a_2, a_3, \ldots, a_n $ .

You have to answer $ q $ independent queries, each consisting of two integers $ l $ and $ r $ .

- Consider the subarray $ a[l:r] $ $ = $ $ [a_l, a_{l+1}, \ldots, a_r] $ . You can apply the following operation to the subarray any number of times (possibly zero)- 
  1. Choose two integers $ L $ , $ R $ such that $ l \le L \le R \le r $ and $ R - L + 1 $ is odd.
  2. Replace each element in the subarray from $ L $ to $ R $ with the XOR of the elements in the subarray $ [L, R] $ .
- The answer to the query is the minimum number of operations required to make all elements of the subarray $ a[l:r] $ equal to $ 0 $ or $ -1 $ if it is impossible to make all of them equal to $ 0 $ .

You can find more details about XOR operation [here](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

## 输入格式

The first line contains two integers $ n $ and $ q $ $ (1 \le n, q \le 2 \cdot 10^5) $ — the length of the array $ a $ and the number of queries.

The next line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ $ (0 \le a_i \lt 2^{30}) $ — the elements of the array $ a $ .

The $ i $ -th of the next $ q $ lines contains two integers $ l_i $ and $ r_i $ $ (1 \le l_i \le r_i \le n) $ — the description of the $ i $ -th query.

## 输出格式

For each query, output a single integer — the answer to that query.

## 说明/提示

In the first query, $ l = 3, r = 4 $ , subarray = $ [3, 3] $ . We can apply operation only to the subarrays of length $ 1 $ , which won't change the array; hence it is impossible to make all elements equal to $ 0 $ .

In the second query, $ l = 4, r = 6 $ , subarray = $ [3, 1, 2] $ . We can choose the whole subarray $ (L = 4, R = 6) $ and replace all elements by their XOR $ (3 \oplus 1 \oplus 2) = 0 $ , making the subarray $ [0, 0, 0] $ .

In the fifth query, $ l = 1, r = 6 $ , subarray = $ [3, 0, 3, 3, 1, 2] $ . We can make the operations as follows:

1. Choose $ L = 4, R = 6 $ , making the subarray $ [3, 0, 3, 0, 0, 0] $ .
2. Choose $ L = 1, R = 5 $ , making the subarray $ [0, 0, 0, 0, 0, 0] $ .

## 样例 #1

### 输入

```
7 6
3 0 3 3 1 2 3
3 4
4 6
3 7
5 6
1 6
2 2
```

### 输出

```
-1
1
1
-1
2
0
```



---

---
title: "Wish I Knew How to Sort"
layout: "post"
diff: 提高+/省选-
pid: CF1753C
tag: ['动态规划 DP', '组合数学', '概率论']
---

# Wish I Knew How to Sort

## 题目描述

You are given a binary array $ a $ (all elements of the array are $ 0 $ or $ 1 $ ) of length $ n $ . You wish to sort this array, but unfortunately, your algorithms teacher forgot to teach you sorting algorithms. You perform the following operations until $ a $ is sorted:

1. Choose two random indices $ i $ and $ j $ such that $ i < j $ . Indices are chosen equally probable among all pairs of indices $ (i, j) $ such that $ 1 \le i < j \le n $ .
2. If $ a_i > a_j $ , then swap elements $ a_i $ and $ a_j $ .

What is the [expected number](https://en.wikipedia.org/wiki/Expected_value) of such operations you will perform before the array becomes sorted?

It can be shown that the answer can be expressed as an irreducible fraction $ \frac{p}{q} $ , where $ p $ and $ q $ are integers and $ q \not \equiv 0 \pmod{998\,244\,353} $ . Output the integer equal to $ p \cdot q^{-1} \bmod 998\,244\,353 $ . In other words, output such an integer $ x $ that $ 0 \le x < 998\,244\,353 $ and $ x \cdot q \equiv p \pmod{998\,244\,353} $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^5 $ ). Description of the test cases follows.

The first line of each test case contains an integer $ n $ ( $ 1 \le n \le 200\,000 $ ) — the number of elements in the binary array.

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ a_i \in \{0, 1\} $ ) — elements of the array.

It's guaranteed that sum of $ n $ over all test cases does not exceed $ 200\,000 $ .

## 输出格式

For each test case print one integer — the value $ p \cdot q^{-1} \bmod 998\,244\,353 $ .

## 说明/提示

Consider the first test case. If the pair of indices $ (2, 3) $ will be chosen, these elements will be swapped and array will become sorted. Otherwise, if one of pairs $ (1, 2) $ or $ (1, 3) $ will be selected, nothing will happen. So, the probability that the array will become sorted after one operation is $ \frac{1}{3} $ , the probability that the array will become sorted after two operations is $ \frac{2}{3} \cdot \frac{1}{3} $ , the probability that the array will become sorted after three operations is $ \frac{2}{3} \cdot \frac{2}{3} \cdot \frac{1}{3} $ and so on. The expected number of operations is $ \sum \limits_{i=1}^{\infty} \left(\frac{2}{3} \right)^{i - 1} \cdot \frac{1}{3} \cdot i = 3 $ .

In the second test case the array is already sorted so the expected number of operations is zero.

In the third test case the expected number of operations equals to $ \frac{75}{4} $ so the answer is $ 75 \cdot 4^{-1} \equiv 249\,561\,107 \pmod {998\,244\,353} $ .

## 样例 #1

### 输入

```
3
3
0 1 0
5
0 0 1 1 1
6
1 1 1 0 0 1
```

### 输出

```
3
0
249561107
```



---

---
title: "Game of the Year"
layout: "post"
diff: 提高+/省选-
pid: CF1783E
tag: ['数学', '贪心', '树状数组', '数论', '前缀和', 'ST 表']
---

# Game of the Year

## 题目描述

Monocarp 和 Polycarp 正在玩电脑游戏。游戏特点：$ n $ 个编号从 $ 1 $ 到 $ n $ 的BOSS。

他俩将用以下方式与BOSS战斗

- Monocarp 进行 $ k $ 次尝试撒掉boss;
- Polycarp 进行 $ k $ 次尝试撒掉boss;
- Monocarp 进行 $ k $ 次尝试撒掉boss;
- Polycarp 进行 $ k $ 次尝试撒掉boss;
- ...

Monocarp 在第 $ a_i $ 次尝试中撒掉了第 $ i $ 只BOSS。Polycarp 在第 $ b_i $ 次尝试中撒掉了第 $ i $ 只BOSS。其中一个人撒掉第 $ i $ 只BOSS后，他们就会尝试撒第 $ (i+1) $ 只BOSS。并且他们的尝试计数器都会清空。撒掉第 $ n $ 只BOSS后，游戏结束。

找到从$ 1 $ 到 $ n $所有的 $ k $ 值， 使得 Monocarp 可以杀死所有的BOSS。

## 输入格式

第一行输入一个整数 $ t $ ( $ 1 \le t \le 10^4 $ ) — 样例数。

每个样例第一行输入一个整数 $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — BOSS的数量。

每个样例第二行输入 $ n $ 个整数： $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ ) — Monocarp 撒死每只BOSS的尝试次数。

每个样例第三行输入 $ n $ 个整数： $ b_1, b_2, \dots, b_n $ ( $ 1 \le b_i \le n $ ) — Polycarp 撒死每只BOSS的尝试次数。

所有测试样例的 $ n $ 之和不超过 $ 2 \cdot 10^5 $ .

## 输出格式

对于每个样例输出两行。第一行应该包含一个正整数 $ \mathit{cnt} $ — 从 $ 1 $ 到 $ n $ 使得 Monocarp 可以撒死所有BOSS的 $ k $ 的总数。第二行应该包含 $ \mathit{cnt} $ 个正整数 — 所有 $ k $ 的值。

## 说明/提示

考虑最后一组测试样例

使 $ k = 1 $。首先，Monocarp经过1次尝试撒死第一只BOSS。成功，因为 $ a_1 = 1 $。 然后，Monocarp进行一次尝试撒死第二只BOSS。不成功，因为 $ a_2 > 1 $。于是，Polycarp尝试了一下。也不成功，因为 $ b_2 > 1 $。然后Monocarp进行了另一次尝试。仍然不成功，因为 $ a_2 > 2 $。直到Polycarp 在第三次尝试撒掉了BOSS。Monocarp没能撒掉BOSS。因此，$ k = 1 $ 不是答案。

使 $ k = 2 $ . Monocarp仍然在他的第一次尝试中撒死了BOSS。然后，他进行了两次不成功的尝试未能撒死BOSS。然后，Polycarp进行了两次不成功的尝试。然后，Monocarp进行了两次尝试，并且在第四次尝试中撒掉了BOSS。撒掉第三只BOSS的方法也类似。首先，Monocarp进行两次不成功的尝试。然后，Polycarp进行两次不成功的尝试。然后，Monocarp还有两次尝试机会，但在这两次机会中第一次就撒死了BOSS，因为 $ a_3 = 3 $。 第四只BOSS也被Monocarp撒死。因此，$ k = 2 $ 是答案。

## 样例 #1

### 输入

```
3
3
1 1 1
2 3 1
1
1
1
4
1 4 3 2
3 3 4 1
```

### 输出

```
3
1 2 3 
1
1 
2
2 4
```



---

---
title: "Hyperregular Bracket Strings"
layout: "post"
diff: 提高+/省选-
pid: CF1830C
tag: ['哈希 hashing', '组合数学']
---

# Hyperregular Bracket Strings

## 题目描述

给定一个数 $n$ 和 $k$ 个区间 $\left[l_i,r_i\right]\in [1,n]$。

我们定义，对于一个长度为 $n$ 的，仅由 ```(``` 和 ```)``` 组成的合法括号序列，如果它的每一个区间 $\left[l_i,r_i\right]$ 内的子串都是合法括号序列，那么这个括号序列是**好的**。

求**好的**括号序列的数量，答案对 $998244353$ 取模。

## 输入格式

每个数据点第一行为一个数 $t\ (1\le t\le 10^5)$，表示数据组数。

每组数据第一行为两个数 $n,k\ (1\le n\le 3\cdot 10^5,1\le k\le3\cdot 10

## 输出格式

共 $t$ 行，第 $i$ 行表示第 $i$ 组数据的答案对 $998244353$ 取模后的结果

## 说明/提示

以样例的第四组数据为例，答案代表的 $4$ 个好的括号序列分别是：

```
 ((())(()))
 ((())()())
 ()()((()))
 ()()(()())
```

而 ```)(())(())(``` 不是答案之一，因为它不是一个合法的括号序列（最左端与最右端的括号未配对）

```(())((()))``` 也不是答案之一，因为它的 $[3,4]$ 表示的子串 ```))``` 不是一个合法的括号序列

```((()(())))``` 也不是答案之一，因为它的 $[6,9]$ 表示的子串 ```()))``` 不是一个合法的括号序列

## 样例 #1

### 输入

```
7
6 0
5 0
8 1
1 3
10 2
3 4
6 9
1000 3
100 701
200 801
300 901
28 5
1 12
3 20
11 14
4 9
18 19
4 3
1 4
1 4
1 4
```

### 输出

```
5
0
0
4
839415253
140
2
```



---

---
title: "Twin Friends"
layout: "post"
diff: 提高+/省选-
pid: CF1906H
tag: ['动态规划 DP', '组合数学']
---

# Twin Friends

## 题目描述

You meet two new friends who are twins. The name of the elder twin is $ A $ , which consists of $ N $ characters. While the name of the younger twin is $ B $ , which consists of $ M $ characters. It is known that $ N \leq M $ .

You want to call each of them with a nickname. For the elder twin, you want to pick any permutation of $ A $ as the nickname. For the younger twin, you want to remove exactly $ M - N $ characters from any permutation of $ B $ . Denote the nicknames of the elder twin and the younger twin as $ A' $ and $ B' $ , respectively.

You want the nicknames to satisfy the following requirement. For each $ i $ that satisfies $ 1 \leq i \leq N $ , $ B'_i $ must be equal to either $ A'_i $ or the next letter that follows alphabetically after $ A'_i $ (if such a next letter exists).

Determine the number of different pairs of nicknames $ (A', B') $ that satisfy the requirement. Two pairs of nicknames are considered different if at least one of the nicknames are different. As the result might be large, find the answer modulo $ 998\,244\,353 $ .

## 输入格式

The first line consists of two integers $ N $ $ M $ ( $ 1 \leq N \leq M \leq 200\,000 $ ).

The second line consists of a string $ A $ of length $ N $ .

The third line consists of a string $ B $ of length $ M $ .

All strings consist of only upper-case letters.

## 输出格式

Output a single integer representing number of different pairs $ (A', B') $ that satisfy the requirement, modulo $ 998\,244\,353 $ .

## 说明/提示

Explanation for the sample input/output #1

The $ 9 $ pairs are:

- (AAM, AAN),
- (AAM, ABN),
- (AAM, BAN),
- (AMA, ANA),
- (AMA, ANB),
- (AMA, BNA),
- (MAA, NAA),
- (MAA, NAB), and
- (MAA, NBA).

Explanation for the sample input/output #2

The $ 120 $ pairs are the pairs where $ A' $ is a permutation of BINUS and $ B' = A' $ .

## 样例 #1

### 输入

```
3 4
AMA
ANAB
```

### 输出

```
9
```

## 样例 #2

### 输入

```
5 8
BINUS
BINANUSA
```

### 输出

```
120
```

## 样例 #3

### 输入

```
15 30
BINUSUNIVERSITY
BINANUSANTARAUNIVERSITYJAKARTA
```

### 输出

```
151362308
```

## 样例 #4

### 输入

```
4 4
UDIN
ASEP
```

### 输出

```
0
```



---

---
title: "Count BFS Graph"
layout: "post"
diff: 提高+/省选-
pid: CF1906J
tag: ['动态规划 DP', '组合数学']
---

# Count BFS Graph

## 题目描述

You are currently researching a graph traversal algorithm called the Breadth First Search (BFS). Suppose you have an input graph of $ N $ nodes (numbered from $ 1 $ to $ N $ ). The graph is represented by an adjacency matrix $ M $ , for which node $ u $ can traverse to node $ v $ if $ M_{u, v} $ is $ 1 $ , otherwise it is $ 0 $ . Your algorithm will output the order the nodes are visited in the BFS. The pseudocode of the algorithm is presented as follows.

```
<pre class="verbatim"><br></br>    BFS(M[1..N][1..N]):<br></br>        let A be an empty array<br></br>        let Q be an empty queue<br></br><br></br>        append 1 to A<br></br>        push 1 to Q<br></br><br></br>        while Q is not empty:<br></br>            pop the front element of Q into u<br></br>            for v = 1 to N:<br></br>                if M[u][v] == 1 and v is not in A:<br></br>                    append v to A<br></br>                    push v to Q<br></br><br></br>        return A<br></br>
```

During your research, you are interested in the following problem. Given an array $ A $ such that $ A $ is a permutation of $ 1 $ to $ N $ and $ A_1 = 1 $ . How many simple undirected graph with $ N $ nodes and adjacency matrix $ M $ such that $ \text{BFS}(M) = A $ ? Since the answer can be very large, calculate the answer modulo $ 998\,244\,353 $ .

A simple graph has no self-loop ( $ M_{i, i} = 0 $ for $ 1 \leq i \leq N $ ) and there is at most one edge that connects a pair of nodes. In an undirected graph, if node $ u $ is adjacent to node $ v $ , then node $ v $ is also adjacent to node $ u $ ; formally, $ M_{u, v} = M_{v, u} $ for $ 1 \leq u < v \leq N $ .

Two graphs are considered different if there is an edge that exists in one graph but not the other. In other words, two graphs are considered different if their adjacency matrices are different.

## 输入格式

The first line consists of an integer $ N $ ( $ 2 \leq N \leq 5000 $ ).

The second line consists of $ N $ integers $ A_i $ . The array $ A $ is a permutation of $ 1 $ to $ N $ and $ A_1 = 1 $ .

## 输出格式

Output an integer representing the number of simple undirected graphs with $ N $ nodes and adjacency matrix $ M $ such that $ \text{BFS}(M) = A $ . Since the answer can be very large, output the answer modulo $ 998\,244\,353 $ .

## 说明/提示

Explanation for the sample input/output #1

The following illustration shows all graphs that satisfy the requirements.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1906J/96f1bd6a81238405d96653e941a6d0d3b2152525.png)Explanation for the sample input/output #2

The only graph that satisfies the requirements is a graph with two edges: one that connects nodes $ 1 $ and $ 3 $ , and another one that connects nodes $ 3 $ and $ 2 $ .

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 3 2
```

### 输出

```
1
```

## 样例 #3

### 输入

```
5
1 3 2 4 5
```

### 输出

```
17
```

## 样例 #4

### 输入

```
11
1 2 3 4 5 6 7 8 9 10 11
```

### 输出

```
379394847
```



---

---
title: "Fractal Origami"
layout: "post"
diff: 提高+/省选-
pid: CF1924C
tag: ['数学']
---

# Fractal Origami

## 题目描述

You have a square piece of paper with a side length equal to $ 1 $ unit. In one operation, you fold each corner of the square to the center of the paper, thus forming another square with a side length equal to $ \dfrac{1}{\sqrt{2}} $ units. By taking this square as a new square, you do the operation again and repeat this process a total of $ N $ times.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1924C/de3bbf1154da54ac557ac761cc9644c6d1e0f30d.png) Performing operations for $ N = 2 $ .After performing the set of operations, you open the paper with the same side up you started with and see some crease lines on it. Every crease line is one of two types: a mountain or a valley. A mountain is when the paper folds outward, and a valley is when the paper folds inward.

You calculate the sum of the length of all mountain crease lines on the paper and call it $ M $ . Similarly, you calculate for valley crease lines and call it $ V $ . You want to find the value of $ \dfrac{M}{V} $ .

It can be proved that this value can be represented in the form of $ A + B\sqrt{2} $ , where $ A $ and $ B $ are rational numbers. Let this $ B $ be represented as an irreducible fraction $ \dfrac{p}{q} $ , your task is to print $ p*inv(q) $ modulo $ 999\,999\,893 $ (note the unusual modulo), where $ inv(q) $ is the [modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of $ q $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \leq t \leq 10^4 $ ). Description of the test cases follows.

The only line of each test case contains an integer $ N $ ( $ 1 \leq N \leq 10^9 $ ), the number of operations you perform on the square paper.

## 输出格式

For each test case, print on a new line the required answer.

## 说明/提示

The blue lines in the given figures represent mountain crease lines, and the green lines represent valley crease lines.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1924C/656ef1e31fbec994532b6ed88e854868aee0bb9e.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1924C/4d56d193615060ea6202f89c8971139a2bc8d811.png)Crease lines after $ 1 $ operation $ (\dfrac{M}{V} = 0) $ .Crease lines after $ 2 $ operations $ (\dfrac{M}{V} = \sqrt{2} - 1) $ .

## 样例 #1

### 输入

```
3
1
2
3
```

### 输出

```
0
1
714285638
```



---

---
title: "Girl Permutation"
layout: "post"
diff: 提高+/省选-
pid: CF1946E
tag: ['组合数学', '排列组合']
---

# Girl Permutation

## 题目描述

Some permutation of length $ n $ is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length $ k $ is an array of size $ k $ such that each integer from $ 1 $ to $ k $ occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at that element. More formally, the element $ a_i $ is a prefix maximum if $ a_i > a_j $ for every $ j < i $ .

Similarly, suffix maximums are defined, the element $ a_i $ is a suffix maximum if $ a_i > a_j $ for every $ j > i $ .

You need to output the number of different permutations that could have been guessed.

As this number can be very large, output the answer modulo $ 10^9 + 7 $ .

## 输入格式

Each test consists of several test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. Then follows the description of the test cases.

The first line of each test case contains three integers $ n, m_1 $ and $ m_2 $ ( $ 1 \le m_1, m_2 \le n \le 2 \cdot 10^5 $ ) — the length of the permutation, the number of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains $ m_1 $ integers $ p_1 < p_2 < \ldots < p_{m_1} $ ( $ 1 \le p_i \le n $ ) — the indices of the prefix maximums in increasing order.

The third line of each test case contains $ m_2 $ integers $ s_1 < s_2 < \ldots < s_{m_2} $ ( $ 1 \le s_i \le n $ ) — the indices of the suffix maximums in increasing order.

It is guaranteed that the sum of the values of $ n $ for all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer on a separate line — the number of suitable permutations modulo $ 10^9 + 7 $ .

## 说明/提示

The following permutations are suitable for the second set of input data:

- $ [1, 4, 3, 2] $
- $ [2, 4, 3, 1] $
- $ [3, 4, 2, 1] $

The following permutations are suitable for the sixth set of input data:

- $ [2, 1, 6, 5, 3, 4] $
- $ [3, 1, 6, 5, 2, 4] $
- $ [3, 2, 6, 5, 1, 4] $
- $ [4, 1, 6, 5, 2, 3] $
- $ [4, 2, 6, 5, 1, 3] $
- $ [4, 3, 6, 5, 1, 2] $
- $ [5, 1, 6, 4, 2, 3] $
- $ [5, 2, 6, 4, 1, 3] $
- $ [5, 3, 6, 4, 1, 2] $
- $ [5, 4, 6, 3, 1, 2] $

## 样例 #1

### 输入

```
6
1 1 1
1
1
4 2 3
1 2
2 3 4
3 3 1
1 2 3
3
5 3 4
1 2 3
2 3 4 5
20 5 4
1 2 3 4 12
12 13 18 20
6 2 3
1 3
3 4 6
```

### 输出

```
1
3
1
0
317580808
10
```



---

---
title: "Nene vs. Monsters (Easy Version)"
layout: "post"
diff: 提高+/省选-
pid: CF1956E1
tag: ['数学']
---

# Nene vs. Monsters (Easy Version)

## 题目描述

This is the easy version of the problem. The only difference between the versions is the constraints on $ a_i $ . You can make hacks only if both versions of the problem are solved.

Nene is fighting with $ n $ monsters, located in a circle. These monsters are numbered from $ 1 $ to $ n $ , and the $ i $ -th ( $ 1 \le i \le n $ ) monster's current energy level is $ a_i $ .

Since the monsters are too strong, Nene decided to fight with them using the Attack Your Neighbour spell. When Nene uses this spell, the following actions happen in the following order one by one:

- The $ 1 $ -st monster attacks the $ 2 $ -nd monster;
- The $ 2 $ -nd monster attacks the $ 3 $ -rd monster;
- $ \ldots $
- The $ (n-1) $ -th monster attacks the $ n $ -th monster;
- The $ n $ -th monster attacks the $ 1 $ -st monster.

When the monster with energy level $ x $ attacks the monster with the energy level $ y $ , the energy level of the defending monster becomes $ \max(0, y-x) $ (the energy level of the attacking monster remains equal to $ x $ ).

Nene is going to use this spell $ 10^{100} $ times and deal with the monsters that will still have a non-zero energy level herself. She wants you to determine which monsters will have a non-zero energy level once she will use the described spell $ 10^{100} $ times.

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of test cases follows.

The first line contains a single integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ) — the number of monsters.

The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 2 \cdot 10^5 $ ) — the current energy levels of monsters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case,

- in the first line output an integer $ m $ — the number of monsters with non-zero energy level after $ 10^{100} $ uses of the spell;
- in the second line of output $ m $ integers $ i_1,i_2,\ldots,i_m $ ( $ 1 \le i_1 < i_2 < \ldots < i_m \le n $ ) — the indices of these monsters in the increasing order.

If $ m=0 $ , you may either output an empty line or don't output it.

## 说明/提示

In the first test case, the following actions happen during the first $ 3 $ uses of the spell in this order:

- Nene uses the Attack Your Neighbour spell for the first time;
- the $ 1 $ -st monster attacks the $ 2 $ -nd monster, after the attack the energy level of the $ 2 $ -nd monster becomes equal to $ \max(0, 5-2)=3 $ ;
- the $ 2 $ -nd monster attacks the $ 3 $ -rd monster, after the attack the energy level of the $ 3 $ -rd monster becomes equal to $ \max(0, 3-3)=0 $ ;
- the $ 3 $ -rd monster attacks the $ 1 $ -st monster, after the attack the energy level of the $ 1 $ -st monster becomes equal to $ \max(0, 2-0)=2 $ ;
- Nene uses the Attack Your Neighbour spell for the second time;
- the $ 1 $ -st monster attacks the $ 2 $ -nd monster, after the attack the energy level of the $ 2 $ -nd monster becomes equal to $ \max(0, 3-2)=1 $ ;
- the $ 2 $ -nd monster attacks the $ 3 $ -rd monster, after the attack the energy level of the $ 3 $ -rd monster becomes equal to $ \max(0, 0-1)=0 $ ;
- the $ 3 $ -rd monster attacks the $ 1 $ -st monster, after the attack the energy level of the $ 1 $ -st monster becomes equal to $ \max(0, 2-0)=2 $ ;
- Nene uses the Attack Your Neighbour spell for the third time;
- the $ 1 $ -st monster attacks the $ 2 $ -nd monster, after the attack the energy level of the $ 2 $ -nd monster becomes equal to $ \max(0, 1-2)=0 $ ;
- the $ 2 $ -nd monster attacks the $ 3 $ -rd monster, after the attack the energy level of the $ 3 $ -rd monster becomes equal to $ \max(0, 0-0)=0 $ ;
- the $ 3 $ -rd monster attacks the $ 1 $ -st monster, after the attack the energy level of the $ 1 $ -st monster becomes equal to $ \max(0, 2-0)=2 $ .

After each of the next uses of the spell, energy levels of monsters do not change. Thus, only the $ 1 $ -st monster has a non-zero energy level in the end.

In the second test case, both monsters initially have zero energy level.

## 样例 #1

### 输入

```
5
3
2 5 3
2
0 0
4
1 5 7 2
4
4 2 1 2
13
1 1 4 5 1 4 1 9 1 9 8 1 0
```

### 输出

```
1
1 
0

1
1 
2
1 3 
6
1 3 6 8 10 12
```



---

---
title: "Cat, Fox and Maximum Array Split"
layout: "post"
diff: 提高+/省选-
pid: CF1973D
tag: ['数学']
---

# Cat, Fox and Maximum Array Split

## 题目描述

This is an interactive problem.

Fox gave Cat two positive integers $ n $ and $ k $ . She has a hidden array $ a_1, \ldots , a_n $ of length $ n $ , such that $ 1 \leq a_i \leq n $ for every $ i $ . Now they are going to play the following game:

For any two integers $ l, r $ such that $ 1 \leq l \leq r \leq n $ , define $ f(l, r) = (r - l + 1) \cdot \max\limits_{x=l}^r a_x $ . In other words, $ f(l, r) $ is equal to the maximum of the subarray $ a_l, \ldots, a_r $ multiplied by its size.

Cat can ask Fox at most $ 2 n $ questions about the array. He will tell her two integers $ l $ and $ x $ ( $ 1 \leq l \leq n, 1 \leq x \leq 10^9 $ ), and she will tell him one integer $ p $ as the answer — the smallest positive integer $ r $ such that $ f(l, r) = x $ , or $ n+1 $ if no such $ r $ exists.

Now, Cat needs to find the largest value $ m $ such that there exists a sequence $ c_1, \ldots, c_{k-1} $ such that $ 1 \leq c_1 < \ldots < c_{k-1} < n $ and $ f(1, c_1) = f(c_1 + 1, c_2) = \ldots = f(c_{k-1}+1, n) = m $ . If no such $ m $ exists, he should indicate this and take $ -1 $ as the answer. Note that for $ k = 1 $ , $ m $ is always equal to $ f(1, n) $ .

In other words, the goal is to find the largest $ m $ such that you can split the array into exactly $ k $ subarrays ( $ k $ is the constant given to you in the beginning of the interaction) so that all the subarrays have the product of their length and their maximum equal to $ m $ , or determine that no such $ m $ exists. Every element should belong in exactly one of the subarrays.

Cat doesn't know what he should do, so he asked you to play the game for him.

## 输出格式

Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^3 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two positive integers $ n $ and $ k $ ( $ 1 \leq k \leq n \leq 10^4 $ ) — the length of the hidden array and the number of subarrays in the desired split.

Now you are allowed to make queries in the following way — print one line of the form " $ \mathtt{?} \ l \ x $ " (it must hold that $ 1 \leq l \leq n $ , $ 1 \leq x \leq 10^9 $ ) and you will receive the smallest integer $ r $ such that $ l \leq r \leq n $ and $ f(l, r) = x $ , or $ n + 1 $ if no such $ r $ exists.

If you want to print the answer, output " $ \mathtt{!} \ m $ " and you will recieve $ 1 $ if your answer is correct and $ -1 $ otherwise. In the first case, the interaction continues with the next test case. Note that printing the answer doesn't count towards the number of queries made. Please note that you don't receive the values for the next test case immediately, you will first have to read whether your answer to the last test case was correct.

If you receive the integer $ -1 $ at any moment, it means your program has made an invalid query, exceeded the query limit, or gave an incorrect answer. Your program must terminate immediately to receive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.

After printing a query, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:

- fflush(stdout) or cout.flush() in C++;
- System.out.flush() in Java;
- flush(output) in Pascal;
- stdout.flush() in Python;
- see documentation for other languages.

It is guaranteed that the total sum of $ n $ over the test cases won't exceed $ 10^4 $ .

Hacks

The format of the hacks should be the following: the first line should contain one integer $ t $ ( $ 1 \leq t \leq 10^3 $ ) — the number of test cases. The description of the test cases should follow.

The first line of each test case should contain two integers $ n $ and $ k $ ( $ 1 \leq k \leq n \leq 10^4 $ ) — the length of the array $ a $ and the number of subarrays you want to split it into.

The second line should contain $ n $ integers $ a_1, a_2, \ldots, a_n  $ ( $ 1 \leq a_i \leq n  $ ).

The sum of $ n $ over all test cases should not exceed $ 10^4 $ .

## 说明/提示

The hidden arrays in the three testcases are $ [1] $ , $ [1, 2] $ and $ [1, 3, 6, 1, 2, 1] $ . In the second testcase, no split satisfies the constraints, so the answer is $ -1 $ .

The answer for the first query of the third testcase is $ 7 $ since no valid $ r $ exists. For the second query of the third testcase, since $ 2 \cdot \max(1, 3) = 6 $ , we will get $ 2 $ as the answer, since $ r = 1 $ doesn't satisfy the constraint.

The sample interaction guessed all three answers ( $ 1, -1 $ and $ 6 $ ) correctly, so it received $ 1 $ after each answer.

## 样例 #1

### 输入

```
3
1 1

1
2 2

1

3

1
6 3

7

2

3

6

1
```

### 输出

```
! 1


? 1 1

? 2 1

! -1


? 1 9

? 1 6

? 3 6

? 4 6

! 6
```



---

---
title: "Splittable Permutations"
layout: "post"
diff: 提高+/省选-
pid: CF1976E
tag: ['数学']
---

# Splittable Permutations

## 题目描述

Initially, we had one array, which was a permutation of size $ n $ (an array of size $ n $ where each integer from $ 1 $ to $ n $ appears exactly once).

We performed $ q $ operations. During the $ i $ -th operation, we did the following:

- choose any array we have with at least $ 2 $ elements;
- split it into two non-empty arrays (prefix and suffix);
- write two integers $ l_i $ and $ r_i $ , where $ l_i $ is the maximum element in the left part which we get after the split, and $ r_i $ is the maximum element in the right part;
- remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool.

For example, suppose the initial array was $ [6, 3, 4, 1, 2, 5] $ , and we performed the following operations:

1. choose the array $ [6, 3, 4, 1, 2, 5] $ and split it into $ [6, 3] $ and $ [4, 1, 2, 5] $ . Then we write $ l_1 = 6 $ and $ r_1 = 5 $ , and the arrays we have are $ [6, 3] $ and $ [4, 1, 2, 5] $ ;
2. choose the array $ [4, 1, 2, 5] $ and split it into $ [4, 1, 2] $ and $ [5] $ . Then we write $ l_2 = 4 $ and $ r_2 = 5 $ , and the arrays we have are $ [6, 3] $ , $ [4, 1, 2] $ and $ [5] $ ;
3. choose the array $ [4, 1, 2] $ and split it into $ [4] $ and $ [1, 2] $ . Then we write $ l_3 = 4 $ and $ r_3 = 2 $ , and the arrays we have are $ [6, 3] $ , $ [4] $ , $ [1, 2] $ and $ [5] $ .

You are given two integers $ n $ and $ q $ , and two sequences $ [l_1, l_2, \dots, l_q] $ and $ [r_1, r_2, \dots, r_q] $ . A permutation of size $ n $ is called valid if we can perform $ q $ operations and produce the given sequences $ [l_1, l_2, \dots, l_q] $ and $ [r_1, r_2, \dots, r_q] $ .

Calculate the number of valid permutations.

## 输入格式

The first line contains two integers $ n $ and $ q $ ( $ 1 \le q < n \le 3 \cdot 10^5 $ ).

The second line contains $ q $ integers $ l_1, l_2, \dots, l_q $ ( $ 1 \le l_i \le n $ ).

The third line contains $ q $ integers $ r_1, r_2, \dots, r_q $ ( $ 1 \le r_i \le n $ ).

Additional constraint on the input: there exists at least one permutation which can produce the given sequences $ [l_1, l_2, \dots, l_q] $ and $ [r_1, r_2, \dots, r_q] $ .

## 输出格式

Print one integer — the number of valid permutations, taken modulo $ 998244353 $ .

## 样例 #1

### 输入

```
6 3
6 4 4
5 5 2
```

### 输出

```
30
```

## 样例 #2

### 输入

```
10 1
10
9
```

### 输出

```
1814400
```

## 样例 #3

### 输入

```
4 1
2
4
```

### 输出

```
8
```



---

---
title: "Triangle Formation"
layout: "post"
diff: 提高+/省选-
pid: CF1991F
tag: ['数学', '贪心']
---

# Triangle Formation

## 题目描述

### 题面描述
你有 $n$ 根棍子，从 $1$ 到 $n$ 编号。第 $i$ 根棍子的长度是 $a_i$。

你需要回答 $q$ 个问题。在每个查询中，你会得到两个整数 $l$ 和 $r$（$1 \le l < r \le n，r − l + 1 \le 6$）。确定是否可以从编号为l到r的棒中选择6个不同的棒，形成2个非退化三角形。

边长为 $a$、$b$ 和 $c$ 的三角形称为非退化三角形，当且仅当：

$a<b+c\text{，}b<a+c，c<a+b$。

## 输入格式

第一行包含两个整数 $n$ 和 $q$（ $6 \le n  \le 10^5，1 \le q \le 10^6$）——分别是条数和查询数。
第二行包含 $n$ 个整数 $a_1、a_2、\cdots、a_n$（$1 \le a_i \le 10^9$）—— $a_i$ 表示第 $i$ 根棒的长度。（$1 \le l < r \le n，r − l + 1 \le 6$）——每个查询的参数。

## 输出格式

对于每个查询，如果可以形成 $2$ 个三角形，则输出“YES”（不带引号），否则为“NO”（不带引号）。

在任何情况下都可以输出答案（大小写均可）。例如，字符串“yEs”、“yes”、“YeS”和“YEs”都将被识别为正确答案。

## 样例 #1

### 输入

```
10 5
5 2 2 10 4 10 6 1 5 3
1 6
2 7
2 8
5 10
4 10
```

### 输出

```
YES
NO
YES
NO
YES
```



---

---
title: "Ultra-Meow"
layout: "post"
diff: 提高+/省选-
pid: CF1992G
tag: ['组合数学']
---

# Ultra-Meow

## 题目描述

K1o0n gave you an array $ a $ of length $ n $ , consisting of numbers $ 1, 2, \ldots, n $ . Accept it? Of course! But what to do with it? Of course, calculate $ \text{MEOW}(a) $ .

Let $ \text{MEX}(S, k) $ be the $ k $ -th positive (strictly greater than zero) integer in ascending order that is not present in the set $ S $ . Denote $ \text{MEOW}(a) $ as the sum of $ \text{MEX}(b, |b| + 1) $ , over all distinct subsets $ b $ of the array $ a $ .

Examples of $ \text{MEX}(S, k) $ values for sets:

- $ \text{MEX}(\{3,2\}, 1) = 1 $ , because $ 1 $ is the first positive integer not present in the set;
- $ \text{MEX}(\{4,2,1\}, 2) = 5 $ , because the first two positive integers not present in the set are $ 3 $ and $ 5 $ ;
- $ \text{MEX}(\{\}, 4) = 4 $ , because there are no numbers in the empty set, so the first $ 4 $ positive integers not present in it are $ 1, 2, 3, 4 $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

In a single line of each test case, an integer $ n $ ( $ 1 \le n \le 5000 $ ) is entered, the size of the array of gifted numbers.

It is guaranteed that the sum of $ n^2 $ over all test cases does not exceed $ 25 \cdot 10^6 $ .

## 输出格式

For each test case, output a single number — $ \text{MEOW}(a) $ . Since it may be very large, output it modulo $ 10^9 + 7 $ .

## 样例 #1

### 输入

```
5
2
3
4999
5
1
```

### 输出

```
12
31
354226409
184
4
```



---

---
title: "Make a Palindrome"
layout: "post"
diff: 提高+/省选-
pid: CF2004F
tag: ['数学', '前缀和']
---

# Make a Palindrome

## 题目描述

You are given an array $ a $ consisting of $ n $ integers.

Let the function $ f(b) $ return the minimum number of operations needed to make an array $ b $ a palindrome. The operations you can make are:

- choose two adjacent elements $ b_i $ and $ b_{i+1} $ , remove them, and replace them with a single element equal to $ (b_i + b_{i + 1}) $ ;
- or choose an element $ b_i > 1 $ , remove it, and replace it with two positive integers $ x $ and $ y $ ( $ x > 0 $ and $ y > 0 $ ) such that $ x + y = b_i $ .

For example, from an array $ b=[2, 1, 3] $ , you can obtain the following arrays in one operation: $ [1, 1, 1, 3] $ , $ [2, 1, 1, 2] $ , $ [3, 3] $ , $ [2, 4] $ , or $ [2, 1, 2, 1] $ .

Calculate $ \displaystyle \left(\sum_{1 \le l \le r \le n}{f(a[l..r])}\right) $ , where $ a[l..r] $ is the subarray of $ a $ from index $ l $ to index $ r $ , inclusive. In other words, find the sum of the values of the function $ f $ for all subarrays of the array $ a $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases.

The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2000 $ ).

The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le 10^5 $ ).

Additional constraint on the input: the sum of $ n $ over all test cases does not exceed $ 2000 $ .

## 输出格式

For each test case, print a single integer — the sum of the values of the function $ f $ for all subarrays of the array $ a $ .

## 样例 #1

### 输入

```
4
3
2 1 3
4
1 1 1 1
5
4 2 3 1 5
4
1 2 1 2
```

### 输出

```
3
0
14
5
```



---

---
title: "Eri and Expanded Sets"
layout: "post"
diff: 提高+/省选-
pid: CF2006C
tag: ['数学', '二分', '数论', 'ST 表']
---

# Eri and Expanded Sets

## 题目描述

### 题目翻译


------------

有一个包含合法的数的集合。为了将这个集合扩展的尽可能大，Eri可以在集合中选择两个整数 $x \neq y $ ，它们的平均数 $ \frac{x+y}2 $ 是一个合法的不在集合中的数，然后把 $ \frac{x+y}2 $ 置入这个集合。整数 $ x $ 和 $ y $ 仍在这个集合中。

如果我们称这个集合为连续集，那么，当集合内的元素被排序后，相邻的两个元素之间极差为 $1$ 。例如, 集合 $ \{2\} $ , $ \{2, 5, 4, 3\} $ , $ \{5, 6, 8, 7\} $ 是连续集, 但 $ \{2, 4, 5, 6\} $ , $ \{9, 7\} $ 不是。

Eri 喜欢连续集. 假使我们有一序列 $ b $ ,  Eri 把 $ b $ 中所有的元素置入集合。 如果经过上述若干次操作后，该集合转化为了一个连续集，这个序列 $ b $ 就会被我们称作是“闪耀的”。

需要注意的是，如果一个相同的整数多次出现在序列中，我们只会把它加入集合一次，集合总是只包含合法的数。

Eri 有一个序列 $ a $ 包含 $ n $ 个合法的数。请帮他算出整数数对 $ (l,r) $ 的数量$( 1 \leq l \leq r \leq n )$ ，令子序列 $ a_l, a_{l+1}, \ldots, a_r $ 是闪耀的。

## 输入格式

每一个测试点包含多组测试数据。第一行只有一个整数  $ t $ $(1 \leq t \leq 10^4)$ 表示测试数据的组数。   
对于每组数据，第一行包含一个整数 $ n $ $( 1 \leq n \leq 4 \cdot 10^5 )$ 表示序列 $ a $ 的长度。

第二行有 $ n $ 个整数 $ a_1, a_2, \ldots a_n $  $( 1 \leq a_i \leq 10^9 )$ 表示序列中的元素 $ a_i $ 。  

保证 $Σn \leq 4 \cdot 10^5$ 。

## 输出格式

对于每组测试数据，输出一行一个整数，表示“闪耀的”子序列的数量。
#### 样例解释
在第一组测试数据中，序列 $ a = [2, 2] $ 有 $ 3 $ 个子序列：$ [2] $ , $ [2] $ ,  $ [2, 2] $ 。这些子序列构造的集合中只包含一个整数 $ 2 $ ，因此它总是连续集。 所有的子序列都是闪耀的，所以答案是 $ 3 $ .

在第二组测试数据中，注意到子序列 $ [3, 6, 10] $ . 我们可以进行下列操作：

$\{3,6,10\} \xrightarrow{x=6,y=10} \{3,6,8,10\} \xrightarrow{x=6,y=8} \{3,6,7,8,10\} \xrightarrow{x=3,y=7} \{3,5,6,7,8,10\} $ $     $ $ \xrightarrow{x=3,y=5} \{3,4,5,6,7,8,10\} \xrightarrow{x=8,y=10} \{3,4,5,6,7,8,9,10\} $   
   
$ \\{3,4,5,6,7,8,9,10\\} $  是一个连续集，所以子序列 $ \[3, 6, 10\]$ 是闪耀的。

## 样例 #1

### 输入

```
6
2
2 2
6
1 3 6 10 15 21
5
6 30 18 36 9
1
1000000000
6
1 1 4 5 1 4
12
70 130 90 90 90 108 612 500 451 171 193 193
```

### 输出

```
3
18
5
1
18
53
```



---

---
title: "Alice's Adventures in the Rabbit Hole"
layout: "post"
diff: 提高+/省选-
pid: CF2028E
tag: ['数学', '树形 DP', '概率论']
---

# Alice's Adventures in the Rabbit Hole

## 题目描述

爱丽丝在兔子洞的底部！兔子洞可以建模为一棵树 $^{\text{∗}}$  ，在顶点 $1$ 有一个出口，而爱丽丝从某个顶点 $v$ 开始。她想要逃出这个洞，但不幸的是，红心女王下令处决她。

每分钟都会抛一次公平的硬币。如果硬币正面朝上，爱丽丝可以移动到她当前位置的一个相邻顶点，否则，红心女王可以将爱丽丝拉到女王选择的一个相邻顶点。如果爱丽丝最终出现在树的任何非根叶子 $^{\text{†}}$ 上，爱丽丝就输了。

假设他们都以最佳方式移动，计算爱丽丝从每个起始顶点 $1\le v\le n$ 成功逃脱的概率。由于这些概率可能非常小，因此输出它们对 $998\,244\,353$ 的取模。

形式上，设 $M = 998\,244\,353$ 。可以证明，确切的答案可以表示为一个不可约分的分数 $\frac{p}{q}$ ，其中 $p$ 和 $q$ 是整数且 $q \not \equiv 0 \pmod{M}$。输出等于 $p \cdot q^{-1} \bmod M$ 的整数。换句话说，输出这样一个整数 $x$，使得 $0 \le x < M$ 和 $x \cdot q \equiv p \pmod{M}$ 

---
$^{\text{∗}}$
 一棵树是一个连通的简单图，具有 $n$ 个顶点和 $n-1$ 条边。

$^{\text{†}} $
 一个叶子是一个仅与一条边相连的顶点。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^4$）。测试用例的描述如下。

每个测试用例的第一行包含一个整数 $n$（$2\le n\le 2\cdot 10^5$）——树中的顶点数量。

接下来的 $i$ 行中的第 $n - 1$ 行包含两个整数 $x_i$ 和 $y_i$ （$1 \le x_i, y_i \le n$ 和 $x_i \neq y_i$）——树的边。可以保证给定的边形成一棵树。

可以保证所有测试用例的 $n$ 之和不超过 $2\cdot 10^5$ 。

## 输出格式

对于每个测试用例，输出 $n$ 个整数在一行上——爱丽丝从顶点 $1, 2, \ldots, n$ 开始逃脱的概率。由于这些概率可能非常小，因此输出它们对$998\,244\,353$ 的取模。

## 说明/提示

对于第一个测试用例：

1.根据定义，爱丽丝从根节点（顶点 $1$）逃脱的概率为 $1$。\
2.爱丽丝从顶点 $4$ 和 $5$ 立即输掉，因为它们是叶子。\
3.从另外两个顶点，爱丽丝以概率 $\frac 12$ 逃脱，因为女王会将她拉到叶子。

## 样例 #1

### 输入

```
2
5
1 2
1 3
2 4
3 5
9
1 2
2 3
4 5
5 6
7 8
8 9
2 4
5 7
```

### 输出

```
1 499122177 499122177 0 0 
1 499122177 0 332748118 166374059 0 443664157 720954255 0
```



---

---
title: "Common Generator"
layout: "post"
diff: 提高+/省选-
pid: CF2029E
tag: ['数学', '数论', '标签475']
---

# Common Generator

## 题目描述

For two integers $ x $ and $ y $ ( $ x,y\ge 2 $ ), we will say that $ x $ is a generator of $ y $ if and only if $ x $ can be transformed to $ y $ by performing the following operation some number of times (possibly zero):

- Choose a divisor $ d $ ( $ d\ge 2 $ ) of $ x $ , then increase $ x $ by $ d $ .

For example,

- $ 3 $ is a generator of $ 8 $ since we can perform the following operations: $ 3 \xrightarrow{d = 3} 6 \xrightarrow{d = 2} 8 $ ;
- $ 4 $ is a generator of $ 10 $ since we can perform the following operations: $ 4 \xrightarrow{d = 4} 8 \xrightarrow{d = 2} 10 $ ;
- $ 5 $ is not a generator of $ 6 $ since we cannot transform $ 5 $ into $ 6 $ with the operation above.

Now, Kevin gives you an array $ a $ consisting of $ n $ pairwise distinct integers ( $ a_i\ge 2 $ ).

You have to find an integer $ x\ge 2 $ such that for each $ 1\le i\le n $ , $ x $ is a generator of $ a_i $ , or determine that such an integer does not exist.

## 输入格式

Each test contains multiple test cases. The first line of the input contains a single integer $ t $ ( $ 1\le t\le 10^4 $ ) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $ n $ ( $ 1\le n\le 10^5 $ ) — the length of the array $ a $ .

The second line contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 2\le a_i\le 4\cdot 10^5 $ ) — the elements in the array $ a $ . It is guaranteed that the elements are pairwise distinct.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .

## 输出格式

For each test case, output a single integer $ x $ — the integer you found. Print $ -1 $ if there does not exist a valid $ x $ .

If there are multiple answers, you may output any of them.

## 说明/提示

In the first test case, for $ x=2 $ :

- $ 2 $ is a generator of $ 8 $ , since we can perform the following operations: $ 2 \xrightarrow{d = 2} 4 \xrightarrow{d = 4} 8 $ ;
- $ 2 $ is a generator of $ 9 $ , since we can perform the following operations: $ 2 \xrightarrow{d = 2} 4 \xrightarrow{d = 2} 6 \xrightarrow{d = 3} 9 $ .
- $ 2 $ is a generator of $ 10 $ , since we can perform the following operations: $ 2 \xrightarrow{d = 2} 4 \xrightarrow{d = 2} 6 \xrightarrow{d = 2} 8 \xrightarrow{d = 2} 10 $ .

In the second test case, it can be proven that it is impossible to find a common generator of the four integers.

## 样例 #1

### 输入

```
4
3
8 9 10
4
2 3 4 5
2
147 154
5
3 6 8 25 100000
```

### 输出

```
2
-1
7
3
```



---

---
title: "MEXimize the Score"
layout: "post"
diff: 提高+/省选-
pid: CF2030E
tag: ['动态规划 DP', '组合数学', '排列组合']
---

# MEXimize the Score

## 题目描述

Suppose we partition the elements of an array $ b $ into any number $ k $ of non-empty multisets $ S_1, S_2, \ldots, S_k $ , where $ k $ is an arbitrary positive integer. Define the score of $ b $ as the maximum value of $ \operatorname{MEX}(S_1) $ $ ^{\text{∗}} $ $  + \operatorname{MEX}(S_2) + \ldots + \operatorname{MEX}(S_k) $ over all possible partitions of $ b $ for any integer $ k $ .

Envy is given an array $ a $ of size $ n $ . Since he knows that calculating the score of $ a $ is too easy for you, he instead asks you to calculate the sum of scores of all $ 2^n - 1 $ non-empty subsequences of $ a $ . $ ^{\text{†}} $ Since this answer may be large, please output it modulo $ 998\,244\,353 $ .

 $ ^{\text{∗}} $ $ \operatorname{MEX} $ of a collection of integers $ c_1, c_2, \ldots, c_k $ is defined as the smallest non-negative integer $ x $ that does not occur in the collection $ c $ . For example, $ \operatorname{MEX}([0,1,2,2]) = 3 $ and $ \operatorname{MEX}([1,2,2]) = 0 $

 $ ^{\text{†}} $ A sequence $ x $ is a subsequence of a sequence $ y $ if $ x $ can be obtained from $ y $ by deleting several (possibly, zero or all) elements.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of each test case contains an integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the length of $ a $ .

The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \leq a_i < n $ ) — the elements of the array $ a $ .

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output the answer, modulo $ 998\,244\,353 $ .

## 说明/提示

In the first testcase, we must consider seven subsequences:

- $ [0] $ : The score is $ 1 $ .
- $ [0] $ : The score is $ 1 $ .
- $ [1] $ : The score is $ 0 $ .
- $ [0,0] $ : The score is $ 2 $ .
- $ [0,1] $ : The score is $ 2 $ .
- $ [0,1] $ : The score is $ 2 $ .
- $ [0,0,1] $ : The score is $ 3 $ .

 The answer for the first testcase is $ 1+1+2+2+2+3=11 $ .In the last testcase, all subsequences have a score of $ 0 $ .

## 样例 #1

### 输入

```
4
3
0 0 1
4
0 0 1 1
5
0 0 1 2 2
4
1 1 1 1
```

### 输出

```
11
26
53
0
```



---

---
title: "Club of Young Aircraft Builders (easy version)"
layout: "post"
diff: 提高+/省选-
pid: CF2066D1
tag: ['动态规划 DP', '组合数学']
---

# Club of Young Aircraft Builders (easy version)

## 题目描述

这是该问题的简单版本。各版本间的区别在于此版本中所有 $a_i = 0$。只有当您解决了该问题的所有版本时才能进行 hack。

有一栋 $n$ 层的建筑物，楼层从下到上编号为 $1$ 至 $n$。每层恰好住着一位居民。

今天全体居民有一个重要目标：共同发射至少 $c$ 架纸飞机。居民们将依次发射飞机。当第 $i$ 层的居民发射一架飞机时，从第 $1$ 层到第 $i$ 层的所有居民都能看到它降落到地面的过程。

如果从第 $i$ 层居民的视角看，已有至少 $c$ 架飞机被发射，则该居民自己不会再发射更多飞机。已知到当天结束时，从每位居民的视角看至少发射了 $c$ 架飞机，且总共发射了 $m$ 架飞机。

您仔细记录了这次快闪活动，记录了每位发射飞机的居民所在楼层。遗憾的是，关于具体是谁发射了某些飞机的信息已经丢失。请找出填补空缺信息使其可信的方案数。由于答案可能很大，请输出其对 $10^9 + 7$ 取模的结果。

在此版本的问题中，所有信息均已丢失，整个数组全由空缺构成。

也可能您的记录存在错误，导致无法恢复任何有效信息。此时答案视为 $0$。

## 输入格式

每个测试包含多个测试用例。第一行输入测试用例数 $t$（$1 \le t \le 10^4$）。随后为各测试用例的描述。

每个测试用例的第一行包含三个整数 $n, c, m$（$1 \le n \le 100$，$1 \le c \le 100$，$c \le m \le n \cdot c$）——建筑物的层数、所需最小飞机数、实际发射的飞机数。

每个测试用例的第二行包含 $m$ 个整数 $a_1, a_2, \ldots, a_m$（$0 \le a_i \le n$）——$a_i$ 表示发射第 $i$ 架飞机的居民所在楼层；$a_i = 0$ 表示空缺。

在此版本的问题中，保证所有 $a_i = 0$。

保证所有测试用例的 $m$ 值之和不超过 $10^4$。

## 输出格式

对于每个测试用例，输出用 $1$ 至 $n$ 填补空缺信息使其可信的方案数对 $10^9 + 7$ 取模后的结果。


## 说明/提示

第一个测试样例中，所有六种可能的填补方案如下：
1. $[1, 1, 3, 3]$
2. $[1, 2, 3, 3]$
3. $[1, 3, 2, 3]$
4. $[2, 1, 3, 3]$
5. $[2, 2, 3, 3]$
6. $[3, 1, 2, 3]$

注意数组 $[2, 3, 1, 3]$ 不是有效方案，因为第三架飞机不可能由第 $1$ 层的居民发射——从他们的视角看，当时已有 $c = 2$ 架飞机被发射。

同样地，数组 $[1, 1, 2, 3]$ 也不是有效方案，因为从第 $3$ 层居民的视角看，仅发射了 $1$ 架飞机，而 $c = 2$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
2
3 2 4
0 0 0 0
5 5 7
0 0 0 0 0 0 0
```

### 输出

```
6
190
```



---

---
title: "Binary Subsequence Value Sum"
layout: "post"
diff: 提高+/省选-
pid: CF2077C
tag: ['组合数学', '快速傅里叶变换 FFT']
---

# Binary Subsequence Value Sum

## 题目描述

[Last | Moment - onoken](https://www.youtube.com/watch?v=l_fXX3Y0Pis)

对于一个二进制字符串 $^{\text{∗}}$ $v$，其分数定义为以下值的最大值：

$$ \max_{0 \leq i \leq |v|} \left[ F(v, 1, i) \cdot F(v, i+1, |v|) \right] $$

其中 $F(v, l, r) = r - l + 1 - 2 \cdot \operatorname{zero}(v, l, r)$，这里 $\operatorname{zero}(v, l, r)$ 表示子串 $v_lv_{l+1}\ldots v_r$ 中 $\mathtt{0}$ 的数量。若 $l > r$，则 $F(v, l, r) = 0$。

给定一个长度为 $n$ 的二进制字符串 $s$ 和一个正整数 $q$。你需要处理 $q$ 次修改查询。

每次查询给出一个整数 $i$（$1 \leq i \leq n$），你必须翻转 $s_i$（将 $\mathtt{0}$ 改为 $\mathtt{1}$ 或 $\mathtt{1}$ 改为 $\mathtt{0}$）。每次修改后，计算 $s$ 所有非空子序列 $^{\text{†}}$ 的分数之和。

由于结果可能很大，请输出对 $998\,244\,353$ 取模后的答案。注意所有修改是持久化的。

$^{\text{∗}}$ 二进制字符串是仅由 $\mathtt{0}$ 和 $\mathtt{1}$ 组成的字符串。

$^{\text{†}}$ 二进制字符串 $x$ 是 $y$ 的子序列，当且仅当 $x$ 可以通过删除 $y$ 中的若干字符（可能为零或全部）得到。

## 输入格式

每个测试包含多个测试用例。第一行输入测试用例数量 $t$（$1 \le t \le 10^4$）。接下来描述每个测试用例。

每个测试用例的第一行包含两个整数 $n$ 和 $q$（$1 \leq n \leq 2 \cdot 10^5$，$1 \leq q \leq 2 \cdot 10^5$）—— 分别表示字符串 $s$ 的长度和修改查询的数量。

第二行输入一个长度为 $n$ 的二进制字符串 $s$，由字符 $\mathtt{0}$ 和 $\mathtt{1}$ 组成。

接下来 $q$ 行每行输入一个整数 $i$（$1 \leq i \leq n$），表示需要翻转 $s_i$ 的值。

保证所有测试用例的 $n$ 之和与 $q$ 之和均不超过 $2 \cdot 10^5$。

## 输出格式

对于每个测试用例，输出 $q$ 行，每行一个整数，表示修改后所有非空子序列的分数之和模 $998\,244\,353$ 的结果。

## 说明/提示

### 示例解释

第一个测试用例中，首次修改后 $s = \texttt{110}$。所有子序列的分数计算如下：

| 索引       | 子序列 | 分数 |
|------------|--------|------|
| 1          | 1      | 0    |
| 2          | 1      | 0    |
| 1, 2       | 11     | 1    |
| 3          | 0      | 0    |
| 1, 3       | 10     | 0    |
| 2, 3       | 10     | 0    |
| 1, 2, 3    | 110    | 0    |

总和为 $0 + 0 + 1 + 0 + 0 + 0 + 0 = 1$。

第二次修改后 $s = \texttt{111}$。所有子序列的分数计算如下：

| 索引       | 子序列 | 分数 |
|------------|--------|------|
| 1          | 1      | 0    |
| 2          | 1      | 0    |
| 1, 2       | 11     | 1    |
| 3          | 1      | 0    |
| 1, 3       | 11     | 1    |
| 2, 3       | 11     | 1    |
| 1, 2, 3    | 111    | 2    |

总和为 $0 + 0 + 1 + 0 + 1 + 1 + 2 = 5$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3
3 2
010
1
3
10 3
0101000110
3
5
10
24 1
011001100110000101111000
24
```

### 输出

```
1
5
512
768
1536
23068672
```



---

---
title: "Blossom"
layout: "post"
diff: 提高+/省选-
pid: CF2084E
tag: ['数学', '前缀和', '双指针 two-pointer']
---

# Blossom

## 题目描述

给定一个长度为 $n$ 的排列 $a$ $^{\text{∗}}$，其中部分元素缺失（用 $-1$ 表示）。

定义一个排列的值为其所有非空子段 $^{\text{‡}}$ 的 MEX $^{\text{†}}$ 之和。

求所有可能通过填充 $a$ 中缺失元素形成的有效排列的值的总和，结果对 $10^9 + 7$ 取模。

$^{\text{∗}}$ 长度为 $n$ 的排列是指由 $0$ 到 $n - 1$ 的 $n$ 个不同整数按任意顺序组成的数组。例如，$[1,2,0,4,3]$ 是一个排列，但 $[0,1,1]$ 不是排列（因为 $1$ 在数组中出现了两次），$[0,2,3]$ 也不是排列（因为 $n=3$ 但数组中包含 $3$）。

$^{\text{†}}$ 整数集合 $c = \{c_1, c_2, \ldots, c_k\}$ 的最小排除值（MEX）定义为不包含在 $c$ 中的最小非负整数 $x$。

$^{\text{‡}}$ 序列 $a$ 是序列 $b$ 的子段，当且仅当 $a$ 可以通过从 $b$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 1000$）。接下来是每个测试用例的描述。

每个测试用例的第一行包含一个整数 $n$（$1 \le n \le 5000$）。  
第二行包含 $n$ 个整数 $a_1, a_2, \ldots, a_n$（$-1 \le a_i < n$）。  

保证 $a$ 中非 $-1$ 的元素互不相同。  
保证所有测试用例的 $n$ 之和不超过 $5000$。

## 输出格式

对于每个测试用例，输出一个整数——所有可能有效排列的值的总和对 $10^9 + 7$ 取模的结果。


## 说明/提示

- 在第一个测试用例中，唯一有效的排列是 $[0, 1]$，其值为 $3$，因为：
  $$
  \operatorname{mex}([0]) + \operatorname{mex}([1]) + \operatorname{mex}([0, 1]) = 1 + 0 + 2 = 3
  $$
  因此答案为 $3$。

- 在第二个测试用例中，有两个有效排列：$[0, 1]$ 和 $[1, 0]$。$[0, 1]$ 和 $[1, 0]$ 的值均为 $3$，因此答案为 $3 + 3 = 6$。

- 在第四个测试用例中，有两个有效排列：$[0, 2, 1]$ 和 $[1, 2, 0]$。$[0, 2, 1]$ 的值为 $5$，因为：
  $$
  \operatorname{mex}([0]) + \operatorname{mex}([2]) + \operatorname{mex}([1]) + \operatorname{mex}([0, 2]) + \operatorname{mex}([2, 1]) + \operatorname{mex}([0, 2, 1]) = 1 + 0 + 0 + 1 + 0 + 3 = 5
  $$
  $[1, 2, 0]$ 的值也为 $5$，因为：
  $$
  \operatorname{mex}([1]) + \operatorname{mex}([2]) + \operatorname{mex}([0]) + \operatorname{mex}([1, 2]) + \operatorname{mex}([2, 0]) + \operatorname{mex}([1, 2, 0]) = 0 + 0 + 1 + 0 + 1 + 3 = 5
  $$
  因此答案为 $5 + 5 = 10$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
2
0 -1
2
-1 -1
3
2 0 1
3
-1 2 -1
5
-1 0 -1 2 -1
```

### 输出

```
3
6
7
10
104
```



---

---
title: "Zebra-like Numbers"
layout: "post"
diff: 提高+/省选-
pid: CF2086E
tag: ['数学', '贪心', '记忆化搜索', '数位 DP']
---

# Zebra-like Numbers

## 题目描述

我们称一个正整数为斑马数（zebra-like），如果它的二进制表示从最高有效位开始是交替的比特位，并且最低有效位等于 $1$。例如，数字 $1$、$5$ 和 $21$ 都是斑马数，因为它们的二进制表示 $1$、$101$ 和 $10101$ 满足要求，而数字 $10$ 不是斑马数，因为它的二进制表示 $1010$ 的最低有效位是 $0$。

我们定义一个正整数 $e$ 的斑马值为最小的整数 $p$，使得 $e$ 可以表示为 $p$ 个斑马数（可以相同也可以不同）的和。

给定三个整数 $l$、$r$ 和 $k$，计算满足 $l \le x \le r$ 且 $x$ 的斑马值等于 $k$ 的整数 $x$ 的数量。

## 输入格式

每个测试包含多个测试用例。第一行包含一个整数 $t$（$1 \le t \le 100$）——测试用例的数量。接下来是测试用例的描述。

每个测试用例的唯一一行包含三个整数 $l$、$r$（$1 \le l \le r \le 10^{18}$）和 $k$（$1 \le k \le 10^{18}$）。

## 输出格式

对于每个测试用例，输出一个整数——区间 $[l, r]$ 内斑马值为 $k$ 的整数的数量。

## 说明/提示

- 在第一个测试用例中，有 $13$ 个符合条件的数字：$3, 7, 11, 15, 23, 27, 31, 43, 47, 63, 87, 91, 95$。每个数字都可以表示为 $3$ 个斑马数的和。
- 在第二个测试用例中，数字 $1$ 的斑马值为 $1$，因此输出 $1$。
- 在第四个测试用例中，区间 $[2, 10]$ 内没有数字的斑马值为 $100$，因此输出 $0$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
1 100 3
1 1 1
15 77 2
2 10 100
1234567 123456789101112131 12
```

### 输出

```
13
1
3
0
4246658701
```



---

---
title: "Bermuda Triangle"
layout: "post"
diff: 提高+/省选-
pid: CF2097C
tag: ['数学', '扩展欧几里德算法', '中国剩余定理 CRT']
---

# Bermuda Triangle

## 题目描述

百慕大三角——大西洋中一片神秘区域，据传言船只和飞机都会在此凭空消失。有人归咎于磁力异常，有人则认为是通往异世界的传送门，但真相仍笼罩在谜团之中。

在一个晴朗的日子里，814 次常规客运航班正从迈阿密飞往拿骚。在飞机进入一片诡异闪烁的迷雾区域前，一切都看似正常。无线电通讯中断，仪表疯狂旋转，窗外闪烁着非自然的光芒。

为简化问题，我们假设百慕大三角和飞机都位于平面上，且三角形的顶点坐标为 $(0, 0)$、$(0, n)$ 和 $(n, 0)$。飞机初始位于严格处于百慕大三角内部的点 $(x, y)$，并以速度向量 $(v_x, v_y)$ 移动。由于所有仪器都已失灵，机组人员无法控制飞机。

当飞机到达三角形任意一个顶点时，即可成功逃离。但如果飞机在任意时刻（可能是非整数时间）碰到三角形的边界（不包括顶点），其速度向量会立即根据该边进行镜面反射$^\dagger$，随后飞机将继续沿新方向移动。

请判断飞机是否能逃离百慕大三角（即到达某个顶点）。如果可能，还需计算在逃离前会碰到边界的次数（每次触碰边界都计入次数，即使是在同一点；经过顶点不计入次数）。

$^\dagger$ 反射遵循物理定律：入射角等于反射角。

## 输入格式

每个测试包含多个测试用例。第一行输入测试用例数量 $t$（$1 \le t \le 10^4$）。接下来是各测试用例的描述。

每个测试用例的唯一一行包含五个整数 $n$、$x$、$y$、$v_x$ 和 $v_y$（$3 \le n \le 10^9$，$1 \le x, y$，$x+y < n$，$1 \le v_x, v_y \le 10^9$）——分别描述三角形的顶点坐标、飞机的初始位置和初始速度向量。

## 输出格式

对于每个测试用例，输出一个整数——飞机逃离前触碰边界的次数。如果飞机永远无法逃离，则输出 $-1$。

## 说明/提示

第一个测试用例的示意图如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2097C/5dcc41152cc7283979e514f25388f82aa27ff3b9.png)

第二个测试用例中，除速度外初始数据与第一个测试用例相同，且飞机初始运动方向相同，因此答案相同。

第三个测试用例的答案为 $-1$，因为飞机将始终沿着绿色标记的线段移动。示意图如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2097C/dea0fd33e36a4eb6795ed5c962c688b9827de243.png)

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
6
6 2 2 5 2
6 2 2 20 8
4 1 2 1 1
4 1 1 1 2
4 1 1 2 1
6 2 3 2 3
```

### 输出

```
2
2
-1
-1
-1
5
```



---

---
title: "Ain and Apple Tree"
layout: "post"
diff: 提高+/省选-
pid: CF2107E
tag: ['数学', '贪心', '最近公共祖先 LCA']
---

# Ain and Apple Tree

## 题目描述

如果我也被从苹果树上掉下的苹果砸中，我能变得像牛顿一样擅长物理吗？

为了更擅长物理，Ain 想建造一棵苹果树，这样她就能被树上的苹果砸中。她的苹果树有 $n$ 个节点，根节点为 $1$。她将苹果树的权重定义为 $\sum \limits_{i=1}^n \sum \limits_{j=i+1}^n \text{dep}(\operatorname{lca}(i,j))$。

这里，$\text{dep}(x)$ 定义为从节点 $1$ 到节点 $x$ 的唯一最短路径上的边数。$\operatorname{lca}(i, j)$ 定义为在路径 $(1, i)$ 和 $(1, j)$ 上同时出现且 $\text{dep}(x)$ 值最大的唯一节点 $x$。

Ain 从一些旧书中得知，牛顿的苹果树的权重大约是 $k$，但具体的值已经丢失了。

作为 Ain 的朋友，你想为她建造一棵有 $n$ 个节点的苹果树，且树的权重与 $k$ 的绝对差不超过 $1$，即 $|\text{权重} - k| \le 1$。如果无法满足这一条件，请报告这一情况。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^4$）。接下来是测试用例的描述。

每个测试用例的第一行包含两个数字 $n, k$（$2 \le n \le 10^5$，$0 \le k \le 10^{15}$）。

保证所有测试用例的 $n$ 之和不超过 $2 \cdot 10^5$。

## 输出格式

对于每个测试用例，如果存在解，首先输出 `Yes`，否则输出 `No`。你可以使用任意大小写，例如 `YES` 和 `yEs` 也会被接受。

如果至少存在一个解，则输出 $n-1$ 行，每行包含两个数字 $u, v$（$1 \le u, v \le n$），表示苹果树的边。


## 说明/提示

在第一个测试用例中，我们可以验证权重为 $0$。这满足条件，因为 $k = 1$，所以绝对差仅为 $1$。

在第二个测试用例中，不存在解，因为没有 $2$ 个节点的树的权重为 $1$、$2$ 或 $3$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
2 1
2 2
4 0
5 7
5 5
```

### 输出

```
Yes
1 2
No
Yes
1 2
1 3
1 4
Yes
1 3
3 5
4 5
3 2
Yes
1 2
2 3
2 4
2 5
```



---

---
title: "Hacking Numbers (Hard Version)"
layout: "post"
diff: 提高+/省选-
pid: CF2109C3
tag: ['数学']
---

# Hacking Numbers (Hard Version)

## 题目描述

这是该问题的困难版本。在此版本中，你能发送的指令限制将在题目描述中说明。只有在解决所有版本的问题后才能进行 hack。

这是一个交互式问题。

欢迎，决斗者们！在这个交互式挑战中，存在一个未知整数 $x$（$1 \le x \le 10^9$）。你需要通过利用"Mathmech"怪兽的力量，将其变为输入中给定的整数 $n$。你可以发送以下指令之一：

| 指令          | 约束条件                          | 结果                  | 更新操作                 | 裁判响应 |
|---------------|-----------------------------------|-----------------------|--------------------------|----------|
| "add $y$"     | $-10^{18} \le y \le 10^{18}$      | $\mathrm{res} = x + y$ | 若 $1 \le \mathrm{res} \le 10^{18}$，则 $x \leftarrow \mathrm{res}$ | "1"      |
|               |                                   |                       | 否则 $x \leftarrow x$    | "0"      |
| "mul $y$"     | $1 \le y \le 10^{18}$             | $\mathrm{res} = x \cdot y$ | 若 $1 \le \mathrm{res} \le 10^{18}$，则 $x \leftarrow \mathrm{res}$ | "1"      |
|               |                                   |                       | 否则 $x \leftarrow x$    | "0"      |
| "div $y$"     | $1 \le y \le 10^{18}$             | $\mathrm{res} = x/y$  | 若 $y$ 整除 $x$，则 $x \leftarrow \mathrm{res}$ | "1"      |
|               |                                   |                       | 否则 $x \leftarrow x$    | "0"      |
| "digit"       | —                                 | $\mathrm{res} = S(x)$ $^{\text{∗}}$ | 总是 $x \leftarrow \mathrm{res}$ | "1"      |

设 $f(n)$ 为最小整数，使得对于所有 $x$（$1 \le x \le 10^9$），都存在一个由 $f(n)$ 条指令组成的序列能将 $x$ 转换为 $n$。你事先不知道 $x$ 的值。你需要找到这样的 $f(n)$，使得无论 $x$ 是多少，你都能用最多 $f(n)$ 条指令将其转换为 $n$。

你的任务是用最多 $f(n)$ 条指令将 $x$ 变为 $n$。

$^{\text{∗}}$ $S(n)$ 是一个函数，返回非负整数 $n$ 的各位数字之和。例如，$S(123) = 1 + 2 + 3 = 6$。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \le t \le 5000$）。接下来是测试用例描述。

每个测试用例的第一行也是唯一一行包含一个整数 $n$（$1 \le n \le 10^9$）。

每个测试用例的交互从读取整数 $n$ 开始。

发送指令时，按以下格式输出一行：

- "add $y$"：将 $x$ 加上整数 $y$（$-10^{18} \le y \le 10^{18}$）。裁判将输出"1"表示 $x + y$ 在 $[1, 10^{18}]$ 内（成功），否则输出"0"。若成功，更新 $x \leftarrow x + y$。
- "mul $y$"：将 $x$ 乘以正整数 $y$（$1 \le y \le 10^{18}$）。裁判将输出"1"表示 $x \cdot y$ 在 $[1, 10^{18}]$ 内（成功），否则输出"0"。若成功，更新 $x \leftarrow x \cdot y$。
- "div $y$"：将 $x$ 除以正整数 $y$（$1 \le y \le 10^{18}$）。裁判将输出"1"表示 $y$ 是 $x$ 的因数（成功），否则输出"0"。若成功，更新 $x \leftarrow \frac{x}{y}$。
- "digit"：将 $x$ 设为其各位数字之和。裁判总是输出"1"并更新 $x \leftarrow S(x)$。

注意指令区分大小写。

当你确定 $x$ 等于 $n$ 时，按以下格式输出一行：

- "!"——裁判将输出"1"表示 $n$ 等于 $x$，否则输出"-1"。

注意回答指令不计入指令限制。

如果你的程序对一个测试用例发送超过 $f(n)$ 条指令（$f(n)$ 如上所述）或发送无效指令，裁判将返回"-1"。收到此响应后，你的程序应立即终止以避免被判错误答案。

在打印指令后，请勿忘记换行并刷新输出缓冲区，否则会因空闲超时被判失败。具体操作如下：

- C++：使用 `fflush(stdout)` 或 `cout.flush()`；
- Java：使用 `System.out.flush()`；
- Python：使用 `sys.stdout.flush()`；
- Rust：使用 `std::io::stdout().flush()`；
- 其他语言请参考文档。

交互器是非自适应的。未知整数 $x$ 在交互过程中不会改变。

### Hack 格式

要进行 hack，请使用以下格式：

第一行包含一个整数 $t$（$1 \leq t \leq 5000$）——测试用例数量。

每个测试用例的第一行包含两个正整数 $n$ 和 $x$（$1 \leq n,x \leq 10^9$）——分别表示目标值和未知整数的初始值。

## 说明/提示

**解释**  
$\texttt{2}$：共有 2 个测试用例。  
$\texttt{100}$：第一个测试用例中，未知整数 $x = 9$，目标值 $n = 100$。  
$\texttt{add -10}$ $\texttt{0}$：指令"add -10"返回"0"，因为 $9 + (-10) \le 0$，$x$ 保持为 9。  
$\texttt{add 1}$ $\texttt{1}$：指令"add 1"成功，$x$ 变为 10。  
$\texttt{mul 10}$ $\texttt{1}$：指令"mul 10"成功，$x$ 变为 100。  
$\texttt{!}$ $\texttt{1}$：确认 $x = n$。  
$\texttt{5}$：第二个测试用例中，$x = 1234$，$n = 5$。  
$\texttt{digit}$ $\texttt{1}$：$x$ 变为各位数字之和 10。  
$\texttt{div 2}$ $\texttt{1}$：指令"div 2"成功，$x$ 变为 5。  
$\texttt{!}$ $\texttt{1}$：确认 $x = n$。  

注意示例中的空行仅为清晰展示，实际交互中不会出现。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
100

0

1

1

1

5

1

1

1
```

### 输出

```
add -10

add 1

mul 10

!

digit

div 2

!
```



---

---
title: "Faculty"
layout: "post"
diff: 提高+/省选-
pid: CF2110F
tag: ['数学']
---

# Faculty

## 题目描述

在 2077 年，世界被机器人奴役后，机器人决定实施教育改革，现在取模运算仅在"古代世界历史"学院中教授。以下是该学院的入学任务之一：

我们定义一个正整数数组 $b$ 的美观度为所有 $1 \leq i, j \leq n$ 数对中 $f(b_i, b_j)$ 的最大值，其中 $f(x, y) = (x \bmod y) + (y \bmod x)$。

给定一个长度为 $n$ 的正整数数组 $a$，输出 $n$ 个数字，其中第 $i$ 个数字（$1 \leq i \leq n$）是数组 $a_1, a_2, \ldots, a_i$ 的美观度。

$x \bmod y$ 表示 $x$ 除以 $y$ 的余数。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^4$）。接下来是测试用例的描述。

每个测试用例的第一行包含一个整数 $n$（$1 \leq n \leq 10^6$）——数组 $a$ 的大小。

每个测试用例的第二行包含 $n$ 个整数 $a_1, a_2, \ldots, a_n$（$1 \leq a_i \leq 10^9$）。

保证所有测试用例的 $n$ 之和不超过 $10^6$。


## 输出格式

对于每个测试用例，输出 $n$ 个整数——数组 $a$ 的所有前缀的美观度。


## 说明/提示

数组 $3$ 的美观度为 $0$。

数组 $3, 1$ 的美观度为 $f(3, 1) = 1$。

数组 $3, 1, 4$ 的美观度为 $f(3, 4) = 4$。

数组 $3, 1, 4, 1$ 的美观度为 $f(4, 3) = 4$。

数组 $3, 1, 4, 1, 5$ 的美观度为 $f(4, 5) = 5$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
5
3 1 4 1 5
7
5 11 11 4 2 1 10
```

### 输出

```
0 1 4 4 5 
0 6 6 7 7 7 11
```



---

---
title: "Tree Colorings"
layout: "post"
diff: 提高+/省选-
pid: CF2112E
tag: ['动态规划 DP', '数学']
---

# Tree Colorings

## 题目描述

考虑一棵有根树，每个结点可以被染成蓝色、绿色或黄色。一个染色方案是美丽的，当且仅当：
- 根节点被染成绿色；
- 所有的**蓝色和绿色**结点构成一个点集，点集中的点两两之间的路径上都没有黄色结点；
- 所有的**黄色和绿色**结点构成一个点集，点集中的点两两之间的路径上都没有蓝色结点。

给你一个整数 $m$，问一棵**恰有** $m$ 种美丽的染色方案的有根树最少有多少个结点？

## 输入格式

多组数据。第一行一个整数 $t(1\le t\le 10^5)$ 表示数据组数。

对于每组数据，一行一个整数 $m(1\le m\le 5\times 10^5)$。

## 输出格式

对于每组数据，输出一个整数表示答案。特别地，如果不存在一棵恰有 $m$ 种美丽的染色方案的有根树，在这一行输出 $-1$。

## 说明/提示

**样例解释**

我们用 $g$ 表示绿色，用 $b$ 表示蓝色，用 $y$ 表示黄色。

对于第一组数据，考虑一个只有一个结点的树。它有一种美丽的染色方案：根节点为绿色。

对于第二组数据，考虑一个有两个结点的树，根为结点 $1$，它有三种美丽的染色方案：$[g,g],[g,b],[g,y]$。

对于第三组数据，考虑一个有三个结点的链，根为结点 $1$，结点 $2$ 和结点 $1$ 与结点 $3$ 相连，它有五种美丽的染色方案：$[g,g,g],[g,g,b],[g,g,y],[g,b,b],[g,y,y]$。

对于第五组数据，考虑一个有三个结点的树，根为结点 $1$，另外两个结点和它相连，它有九种美丽的染色方案：$[g,g,g],[g,g,b],[g,g,y],[g,b,g],[g,b,b],[g,b,y],[g,y,g],[g,y,b],[g,y,y]$。

## 样例 #1

### 输入

```
5
1
3
5
7
9
```

### 输出

```
1
2
3
4
3
```



---

---
title: "Red Light, Green Light (Hard version)"
layout: "post"
diff: 提高+/省选-
pid: CF2118D2
tag: ['数学', '图论']
---

# Red Light, Green Light (Hard version)

## 题目描述

**这是问题的困难版本。不同版本的区别在于对 $k$ 和单个测试点中的 $n,q$ 总和的限制不同。**

给你一个长度为 $10^{15}$ 的长条和一个常数 $k$。在长条上有 $n$ 个格子上有一个信号灯，第 $i$ 个信号灯在格子 $p_i$ 处，同时具有一个初相 $d_i<k$。第 $i$ 个信号灯将在时刻 $z\times k+d_i,z$ 为整数时亮红灯，其他时刻亮绿灯。

时刻 $0$ 时你在某个格子处，面向正方向。每个时刻你将执行如下操作：
- 如果你所在的格子上有一个红色的信号灯，转向；
- 向你所面向的方向走一格。

你要处理 $q$ 个询问，询问给出时刻 $0$ 时你在格子 $a_i$，问时刻 $10^{100}$ 你是否已经走出长条的范围。

## 输入格式

多组数据。第一行一个整数 $t(1\le t\le 2\times 10^5)$，表示数据组数。

对于每组数据：第一行两个整数 $n,k(1\le n\le 2\times 10^5,1\le k\le 10^{15})$。\
第二行 $n$ 个整数 $p_1,p_2,\cdots,p_n(1\le p_1<p_2\cdots<p_n\le 10^{15})$。\
第三行 $n$ 个整数 $d_1,d_2,\cdots,d_n(0\le d_i<k)$。\
第四行一个整数 $q(1\le q\le 2\times 10^5)$。\
第五行 $q$ 个整数 $a_1,a_2,\cdots,a_q(1\le a_i\le 10
^{15})$。

保证单个测试点中 $\sum n,\sum q\le 2\times 10^5$。

## 输出格式

对于每组数据，输出 $q$ 行，第 $i$ 个询问结果为是则在第 $i$ 行输出 `YES`，否则输出 `NO`。你可以以任意形式输出答案（大写或小写）。例如，`yEs`，`yes`，`Yes` 和 `YES` 均是符合条件的输出。

## 说明/提示

对于第一组数据，从 $1,2,3$ 出发的情况如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2118D2/ce9b61d8441ec2687644e4fcb1ecf9c698d0d9de.png)

对于第二组数据，从 $2$ 出发的情况如下：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2118D2/b6fc75687c6b2b664c445b1824b01121fde0aaa1.png)

## 样例 #1

### 输入

```
4
2 2
1 4
1 0
3
1 2 3
9 4
1 2 3 4 5 6 7 8 9
3 2 1 0 1 3 3 1 1
5
2 5 6 7 8
4 2
1 2 3 4
0 0 0 0
4
1 2 3 4
3 4
1 2 3
3 1 1
3
1 2 3
```

### 输出

```
YES
NO
YES
YES
YES
YES
NO
NO
YES
YES
NO
NO
YES
NO
YES
```



---

---
title: "Table"
layout: "post"
diff: 提高+/省选-
pid: CF232B
tag: ['动态规划 DP', '组合数学']
---

# Table

## 题目描述

John Doe has an $ n×m $ table. John Doe can paint points in some table cells, not more than one point in one table cell. John Doe wants to use such operations to make each square subtable of size $ n×n $ have exactly $ k $ points.

John Doe wondered, how many distinct ways to fill the table with points are there, provided that the condition must hold. As this number can be rather large, John Doe asks to find its remainder after dividing by $ 1000000007 $ $ (10^{9}+7) $ .

You should assume that John always paints a point exactly in the center of some cell. Two ways to fill a table are considered distinct, if there exists a table cell, that has a point in one way and doesn't have it in the other.

## 输入格式

A single line contains space-separated integers $ n $ , $ m $ , $ k $ ( $ 1<=n<=100; n<=m<=10^{18}; 0<=k<=n^{2} $ ) — the number of rows of the table, the number of columns of the table and the number of points each square must contain.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.

## 输出格式

In a single line print a single integer — the remainder from dividing the described number of ways by $ 1000000007 $ $ (10^{9}+7) $ .

## 说明/提示

Let's consider the first test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF232B/8876a3223960f71627c5d6c6a4c6ddb988dcaef6.png) The gray area belongs to both $ 5×5 $ squares. So, if it has one point, then there shouldn't be points in any other place. If one of the white areas has a point, then the other one also must have a point. Thus, there are about $ 20 $ variants, where the point lies in the gray area and $ 25 $ variants, where each of the white areas contains a point. Overall there are $ 45 $ variants.

## 样例 #1

### 输入

```
5 6 1

```

### 输出

```
45
```



---

---
title: "Game on Tree"
layout: "post"
diff: 提高+/省选-
pid: CF280C
tag: ['数学', '期望']
---

# Game on Tree

## 题目描述

给定一棵有根树，结点编号从 $1$ 到 $n$。根结点为 $1$ 号结点。

对于每一次操作，等概率的选择一个**尚未被删去**的结点并将它及其子树全部删去。当所有结点被删除之后，游戏结束；也就是说，删除 $1$ 号结点后游戏即结束。

要求求出删除所有结点的期望操作次数。

## 输入格式

第一行，一个正整数 $n$ 表示结点数量。

接下来 $n-1$ 行每行两个数，表示树上的一条连接 $a_i$ 与 $b_i$ 的边 $(a_i,b_i)$

保证给定的数据是一棵树。

## 输出格式

输出一个实数，表示期望操作次数。答案误差在 $10^{-6}$ 之内则认为正确。

**样例解释**

在第一个样例中，有两种情况：

一种是直接删除根（即 $1$ 号结点），另一种是先删去 $2$ 号结点，再删除 $1$ 号结点。

操作次数的期望是 $1\times \dfrac12+2\times\dfrac12=1.5$。

在第二个样例中，情况更为复杂。其中有两种情况会将问题转化成第一个样例，而剩下的一种情况会一次全部删除。

操作次数的期望是 $1\times\dfrac13+(1+1.5)\times\dfrac23=\dfrac13+\dfrac53=2$。

## 样例 #1

### 输入

```
2
1 2

```

### 输出

```
1.50000000000000000000

```

## 样例 #2

### 输入

```
3
1 2
1 3

```

### 输出

```
2.00000000000000000000

```



---

---
title: "Shaass and Lights"
layout: "post"
diff: 提高+/省选-
pid: CF294C
tag: ['数学', '组合数学', '逆元']
---

# Shaass and Lights

## 题目描述

There are $ n $ lights aligned in a row. These lights are numbered $ 1 $ to $ n $ from left to right. Initially some of the lights are switched on. Shaass wants to switch all the lights on. At each step he can switch a light on (this light should be switched off at that moment) if there's at least one adjacent light which is already switched on.

He knows the initial state of lights and he's wondering how many different ways there exist to switch all the lights on. Please find the required number of ways modulo $ 1000000007 (10^{9}+7) $ .

## 输入格式

The first line of the input contains two integers $ n $ and $ m $ where $ n $ is the number of lights in the sequence and $ m $ is the number of lights which are initially switched on, $ (1<=n<=1000,1<=m<=n) $ . The second line contains $ m $ distinct integers, each between $ 1 $ to $ n $ inclusive, denoting the indices of lights which are initially switched on.

## 输出格式

In the only line of the output print the number of different possible ways to switch on all the lights modulo $ 1000000007 (10^{9}+7) $ .

## 样例 #1

### 输入

```
3 1
1

```

### 输出

```
1

```

## 样例 #2

### 输入

```
4 2
1 4

```

### 输出

```
2

```

## 样例 #3

### 输入

```
11 2
4 8

```

### 输出

```
6720

```



---

---
title: "Vowels"
layout: "post"
diff: 提高+/省选-
pid: CF383E
tag: ['组合数学', '前缀和']
---

# Vowels

## 题目描述

Iahubina is tired of so many complicated languages, so she decided to invent a new, simple language. She already made a dictionary consisting of $ n $ 3-words. A 3-word is a sequence of exactly $ 3 $ lowercase letters of the first 24 letters of the English alphabet ( $ a $ to $ x $ ). She decided that some of the letters are vowels, and all the others are consonants. The whole language is based on a simple rule: any word that contains at least one vowel is correct.

Iahubina forgot which letters are the vowels, and wants to find some possible correct sets of vowels. She asks Iahub questions. In each question, she will give Iahub a set of letters considered vowels (in this question). For each question she wants to know how many words of the dictionary are correct, considering the given set of vowels.

Iahubina wants to know the $ xor $ of the squared answers to all the possible questions. There are $ 2^{24} $ different questions, they are all subsets of the set of the first 24 letters of the English alphabet. Help Iahub find that number.

## 输入格式

The first line contains one integer, $ n $ $ (1<=n<=10^{4}) $ . Each of the next $ n $ lines contains a 3-word consisting of $ 3 $ lowercase letters. There will be no two identical 3-words.

## 输出格式

Print one number, the $ xor $ of the squared answers to the queries.

## 样例 #1

### 输入

```
5
abc
aaa
ada
bcd
def

```

### 输出

```
0

```



---

---
title: "Moon Craters"
layout: "post"
diff: 提高+/省选-
pid: CF39C
tag: ['数学', '离散化', '枚举']
---

# Moon Craters

## 题目描述

There are lots of theories concerning the origin of moon craters. Most scientists stick to the meteorite theory, which says that the craters were formed as a result of celestial bodies colliding with the Moon. The other version is that the craters were parts of volcanoes.

An extraterrestrial intelligence research specialist professor Okulov (the namesake of the Okulov, the author of famous textbooks on programming) put forward an alternate hypothesis. Guess what kind of a hypothesis it was –– sure, the one including extraterrestrial mind involvement. Now the professor is looking for proofs of his hypothesis.

Professor has data from the moon robot that moves linearly in one direction along the Moon surface. The moon craters are circular in form with integer-valued radii. The moon robot records only the craters whose centers lay on his path and sends to the Earth the information on the distance from the centers of the craters to the initial point of its path and on the radii of the craters.

According to the theory of professor Okulov two craters made by an extraterrestrial intelligence for the aims yet unknown either are fully enclosed one in the other or do not intersect at all. Internal or external tangency is acceptable. However the experimental data from the moon robot do not confirm this theory! Nevertheless, professor Okulov is hopeful. He perfectly understands that to create any logical theory one has to ignore some data that are wrong due to faulty measuring (or skillful disguise by the extraterrestrial intelligence that will be sooner or later found by professor Okulov!) That’s why Okulov wants to choose among the available crater descriptions the largest set that would satisfy his theory.

## 输入格式

The first line has an integer $ n $ ( $ 1<=n<=2000 $ ) — the number of discovered craters. The next $ n $ lines contain crater descriptions in the " $ c_{i} $ $ r_{i} $ " format, where $ c_{i} $ is the coordinate of the center of the crater on the moon robot’s path, $ r_{i} $ is the radius of the crater. All the numbers $ c_{i} $ and $ r_{i} $ are positive integers not exceeding $ 10^{9} $ . No two craters coincide.

## 输出格式

In the first line output the number of craters in the required largest set. In the next line output space-separated numbers of craters that this set consists of. The craters are numbered from $ 1 $ to $ n $ in the order in which they were given in the input data. The numbers may be output in any order. If the result is not unique, output any.

## 样例 #1

### 输入

```
4
1 1
2 2
4 1
5 1

```

### 输出

```
3
1 2 4

```



---

---
title: "DZY Loves Fibonacci Numbers"
layout: "post"
diff: 提高+/省选-
pid: CF446C
tag: ['数学', '线段树', '斐波那契数列']
---

# DZY Loves Fibonacci Numbers

## 题目描述

In mathematical terms, the sequence $ F_{n} $ of Fibonacci numbers is defined by the recurrence relation

 $ F_{1}=1; F_{2}=1; F_{n}=F_{n-1}+F_{n-2} (n>2). $ DZY loves Fibonacci numbers very much. Today DZY gives you an array consisting of $ n $ integers: $ a_{1},a_{2},...,a_{n} $ . Moreover, there are $ m $ queries, each query has one of the two types:

1. Format of the query " $ 1\ l\ r $ ". In reply to the query, you need to add $ F_{i-l+1} $ to each element $ a_{i} $ , where $ l<=i<=r $ .
2. Format of the query " $ 2\ l\ r $ ". In reply to the query you should output the value of ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF446C/9b1c73158dd7a4166f7d8fde16bb75f36899bc0e.png) modulo $ 1000000009 (10^{9}+9) $ .

Help DZY reply to all the queries.

## 输入格式

The first line of the input contains two integers $ n $ and $ m $ ( $ 1<=n,m<=300000 $ ). The second line contains $ n $ integers $ a_{1},a_{2},...,a_{n} (1<=a_{i}<=10^{9}) $ — initial array $ a $ .

Then, $ m $ lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $ 1<=l<=r<=n $ holds.

## 输出格式

For each query of the second type, print the value of the sum on a single line.

## 说明/提示

After the first query, $ a=[2,3,5,7] $ .

For the second query, $ sum=2+3+5+7=17 $ .

After the third query, $ a=[2,4,6,9] $ .

For the fourth query, $ sum=2+4+6=12 $ .

## 样例 #1

### 输入

```
4 4
1 2 3 4
1 1 4
2 1 4
1 2 4
2 1 3

```

### 输出

```
17
12

```



---

---
title: "Prime Problem"
layout: "post"
diff: 提高+/省选-
pid: CF45G
tag: ['数学', '素数判断,质数,筛法', '构造']
---

# Prime Problem

## 题目描述

In Berland prime numbers are fashionable — the respectable citizens dwell only on the floors with numbers that are prime numbers. The numismatists value particularly high the coins with prime nominal values. All the prime days are announced holidays!

Yet even this is not enough to make the Berland people happy. On the main street of the capital stand $ n $ houses, numbered from 1 to $ n $ . The government decided to paint every house a color so that the sum of the numbers of the houses painted every color is a prime number.

However it turned out that not all the citizens approve of this decision — many of them protest because they don't want many colored houses on the capital's main street. That's why it is decided to use the minimal possible number of colors. The houses don't have to be painted consecutively, but every one of $ n $ houses should be painted some color. The one-colored houses should not stand consecutively, any way of painting is acceptable.

There are no more than 5 hours left before the start of painting, help the government find the way when the sum of house numbers for every color is a prime number and the number of used colors is minimal.

## 输入格式

The single input line contains an integer $ n $ ( $ 2<=n<=6000 $ ) — the number of houses on the main streets of the capital.

## 输出格式

Print the sequence of $ n $ numbers, where the $ i $ -th number stands for the number of color for house number $ i $ . Number the colors consecutively starting from 1. Any painting order is allowed. If there are several solutions to that problem, print any of them. If there's no such way of painting print the single number -1.

## 样例 #1

### 输入

```
8
```

### 输出

```
1 2 2 1 1 1 1 2
```



---

---
title: "Gerald and Giant Chess"
layout: "post"
diff: 提高+/省选-
pid: CF559C
tag: ['动态规划 DP', '组合数学']
---

# Gerald and Giant Chess

## 题目描述

Giant chess is quite common in Geraldion. We will not delve into the rules of the game, we'll just say that the game takes place on an $ h×w $ field, and it is painted in two colors, but not like in chess. Almost all cells of the field are white and only some of them are black. Currently Gerald is finishing a game of giant chess against his friend Pollard. Gerald has almost won, and the only thing he needs to win is to bring the pawn from the upper left corner of the board, where it is now standing, to the lower right corner. Gerald is so confident of victory that he became interested, in how many ways can he win?

The pawn, which Gerald has got left can go in two ways: one cell down or one cell to the right. In addition, it can not go to the black cells, otherwise the Gerald still loses. There are no other pawns or pieces left on the field, so that, according to the rules of giant chess Gerald moves his pawn until the game is over, and Pollard is just watching this process.

## 输入格式

The first line of the input contains three integers: $ h,w,n $ — the sides of the board and the number of black cells ( $ 1<=h,w<=10^{5},1<=n<=2000 $ ).

Next $ n $ lines contain the description of black cells. The $ i $ -th of these lines contains numbers $ r_{i},c_{i} $ ( $ 1<=r_{i}<=h,1<=c_{i}<=w $ ) — the number of the row and column of the $ i $ -th cell.

It is guaranteed that the upper left and lower right cell are white and all cells in the description are distinct.

## 输出格式

Print a single line — the remainder of the number of ways to move Gerald's pawn from the upper left to the lower right corner modulo $ 10^{9}+7 $ .

## 样例 #1

### 输入

```
3 4 2
2 2
2 3

```

### 输出

```
2

```

## 样例 #2

### 输入

```
100 100 3
15 16
16 15
99 88

```

### 输出

```
545732279

```



---

---
title: "Modulo Sum"
layout: "post"
diff: 提高+/省选-
pid: CF577B
tag: ['数学', '背包 DP', '前缀和']
---

# Modulo Sum

## 题目描述

# 题面描述

给出 $1$ 个长度为 $n$ 的序列，以及 $1$ 个正整数 $m$。问这个原序列中是否存在非空子序列，使其元素之和能被 $m$ 整除。

## 输入格式

第 $1$ 行，有 $2$ 个正整数，分别为原序列的长度 $n$ 和 除数 $m$。
（数据范围：$1 \leqslant n \leqslant 10^{6}$，$2 \leqslant m \leqslant 10^{3}$）
第 $2$ 行，有 $n$ 个自然数，表示该原序列的元素 $a_i$。
（数据范围：$0 \leqslant a_i \leqslant 10^{9}$）

## 输出格式

仅 $1$ 行，如果存在符合条件的子序列，输出 **YES**，否则输出 **NO**。

# 样例解释

- 第 $1$ 组样例的解释：
存在符合条件的子序列 $\{2,3\}$，其元素之和为 $2 + 3 = 5$，$5$ 可以被 $5$ 整除。
- 第 $2$ 组样例的解释：
由于原序列中只有 $1$ 个元素，因此它只有 $1$ 个子序列 $\{5\}$，但显然 $5$ 不可以被 $6$ 整除。
- 第 $3$ 组样例的解释：
存在符合条件的子序列 $\{3,3\}$，其元素之和为 $3 + 3 = 6$，$6$ 可以被 $6$ 整除。
- 第 $4$ 组样例的解释：
选择整个原序列作为子序列，其元素之和为 $5 + 5 + 5 + 5 + 5 + 5 = 30$，$30$ 可以被 $6$ 整除。

Translated by Sooke

## 样例 #1

### 输入

```
3 5
1 2 3

```

### 输出

```
YES

```

## 样例 #2

### 输入

```
1 6
5

```

### 输出

```
NO

```

## 样例 #3

### 输入

```
4 6
3 1 1 3

```

### 输出

```
YES

```

## 样例 #4

### 输入

```
6 6
5 5 5 5 5 5

```

### 输出

```
YES

```



---

---
title: "Sum of Remainders"
layout: "post"
diff: 提高+/省选-
pid: CF616E
tag: ['数学']
---

# Sum of Remainders

## 题目描述

计算以下式子的和：$n \bmod 1 + n \bmod 2 + n \bmod 3 + \dots + n \bmod m$。由于结果可能很大，你需要输出其对 $10^9+7$ 取模的结果。

## 输入格式

一行两个整数 $n,m(1 \leq n,m \leq 10^{13})$。

## 输出格式

输出整数 $s$，表示结果对 $10^9+7$ 取模的结果。

## 样例 #1

### 输入

```
3 4

```

### 输出

```
4

```

## 样例 #2

### 输入

```
4 4

```

### 输出

```
1

```

## 样例 #3

### 输入

```
1 1

```

### 输出

```
0

```



---

---
title: "Area of a Star"
layout: "post"
diff: 提高+/省选-
pid: CF630P
tag: ['数学']
---

# Area of a Star

## 题目描述

It was decided in IT City to distinguish successes of local IT companies by awards in the form of stars covered with gold from one side. To order the stars it is necessary to estimate order cost that depends on the area of gold-plating. Write a program that can calculate the area of a star.

A "star" figure having $ n>=5 $ corners where $ n $ is a prime number is constructed the following way. On the circle of radius $ r $ $ n $ points are selected so that the distances between the adjacent ones are equal. Then every point is connected by a segment with two maximally distant points. All areas bounded by the segments parts are the figure parts.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF630P/39542693730deb3e42477c452be9d403bea1f94e.png)

## 输入格式

The only line of the input contains two integers $ n $ ( $ 5<=n&lt;10^{9} $ , $ n $ is prime) and $ r $ ( $ 1<=r<=10^{9} $ ) — the number of the star corners and the radius of the circumcircle correspondingly.

## 输出格式

Output one number — the star area. The relative error of your answer should not be greater than $ 10^{-7} $ .

## 样例 #1

### 输入

```
7 10

```

### 输出

```
108.395919545675
```



---

---
title: "PolandBall and Polygon"
layout: "post"
diff: 提高+/省选-
pid: CF755D
tag: ['数学', '线段树', '树状数组']
---

# PolandBall and Polygon

## 题目描述

PolandBall has such a convex polygon with $ n $ veritces that no three of its diagonals intersect at the same point. PolandBall decided to improve it and draw some red segments.

He chose a number $ k $ such that $ gcd(n,k)=1 $ . Vertices of the polygon are numbered from $ 1 $ to $ n $ in a clockwise way. PolandBall repeats the following process $ n $ times, starting from the vertex $ 1 $ :

Assume you've ended last operation in vertex $ x $ (consider $ x=1 $ if it is the first operation). Draw a new segment from vertex $ x $ to $ k $ -th next vertex in clockwise direction. This is a vertex $ x+k $ or $ x+k-n $ depending on which of these is a valid index of polygon's vertex.

Your task is to calculate number of polygon's sections after each drawing. A section is a clear area inside the polygon bounded with drawn diagonals or the polygon's sides.

## 输入格式

There are only two numbers in the input: $ n $ and $ k $ ( $ 5<=n<=10^{6} $ , $ 2<=k<=n-2 $ , $ gcd(n,k)=1 $ ).

## 输出格式

You should print $ n $ values separated by spaces. The $ i $ -th value should represent number of polygon's sections after drawing first $ i $ lines.

## 说明/提示

The greatest common divisor (gcd) of two integers $ a $ and $ b $ is the largest positive integer that divides both $ a $ and $ b $ without a remainder.

For the first sample testcase, you should output "2 3 5 8 11". Pictures below correspond to situations after drawing lines.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF755D/4990bd3c0c7dd5836fdcc579f970dcdca8dbd872.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF755D/6451ef95db9646f275ba3ec79da2a8d5b0b028d0.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF755D/da900464c60a214ba6c5242ba8fc65122871a490.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF755D/a8b3c0780f20737fed12f744f83c0f1eab3d538f.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF755D/c214010a205eb51e891b2376aacedcb09475410e.png)![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF755D/ac2e2680dc9611afb331663a01c918e0c001e832.png)

## 样例 #1

### 输入

```
5 2

```

### 输出

```
2 3 5 8 11 
```

## 样例 #2

### 输入

```
10 3

```

### 输出

```
2 3 4 6 9 12 16 21 26 31 
```



---

---
title: "Square Subsets"
layout: "post"
diff: 提高+/省选-
pid: CF895C
tag: ['数学', '状态合并', '线性基', '位运算']
---

# Square Subsets

## 题目描述

Petya was late for the lesson too. The teacher gave him an additional task. For some array $ a $ Petya should find the number of different ways to select non-empty subset of elements from it in such a way that their product is equal to a square of some integer.

Two ways are considered different if sets of indexes of elements chosen by these ways are different.

Since the answer can be very large, you should find the answer modulo $ 10^{9}+7 $ .

## 输入格式

First line contains one integer $ n $ ( $ 1<=n<=10^{5} $ ) — the number of elements in the array.

Second line contains $ n $ integers $ a_{i} $ ( $ 1<=a_{i}<=70 $ ) — the elements of the array.

## 输出格式

Print one integer — the number of different ways to choose some elements so that their product is a square of a certain integer modulo $ 10^{9}+7 $ .

## 说明/提示

In first sample product of elements chosen by any way is $ 1 $ and $ 1=1^{2} $ . So the answer is $ 2^{4}-1=15 $ .

In second sample there are six different ways to choose elements so that their product is $ 4 $ , and only one way so that their product is $ 16 $ . So the answer is $ 6+1=7 $ .

## 样例 #1

### 输入

```
4
1 1 1 1

```

### 输出

```
15

```

## 样例 #2

### 输入

```
4
2 2 2 2

```

### 输出

```
7

```

## 样例 #3

### 输入

```
5
1 2 4 5 8

```

### 输出

```
7

```



---

---
title: "Unusual Sequences"
layout: "post"
diff: 提高+/省选-
pid: CF900D
tag: ['数论', '莫比乌斯反演', '组合数学', '容斥原理']
---

# Unusual Sequences

## 题目描述

Count the number of distinct sequences $ a_{1},a_{2},...,a_{n} $ ( $ 1<=a_{i} $ ) consisting of positive integers such that $ gcd(a_{1},a_{2},...,a_{n})=x $ and ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF900D/b6b0405f12ef386aeb195f818cd0534bcf4623e0.png). As this number could be large, print the answer modulo $ 10^{9}+7 $ .

 $ gcd $ here means the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).

## 输入格式

The only line contains two positive integers $ x $ and $ y $ ( $ 1<=x,y<=10^{9} $ ).

## 输出格式

Print the number of such sequences modulo $ 10^{9}+7 $ .

## 说明/提示

There are three suitable sequences in the first test: $ (3,3,3) $ , $ (3,6) $ , $ (6,3) $ .

There are no suitable sequences in the second test.

## 样例 #1

### 输入

```
3 9

```

### 输出

```
3

```

## 样例 #2

### 输入

```
5 8

```

### 输出

```
0

```



---

---
title: "Perfect Groups"
layout: "post"
diff: 提高+/省选-
pid: CF980D
tag: ['数学', '素数判断,质数,筛法', '概率论']
---

# Perfect Groups

## 题目描述

SaMer has written the greatest test case of all time for one of his problems. For a given array of integers, the problem asks to find the minimum number of groups the array can be divided into, such that the product of any pair of integers in the same group is a perfect square.

Each integer must be in exactly one group. However, integers in a group do not necessarily have to be contiguous in the array.

SaMer wishes to create more cases from the test case he already has. His test case has an array $ A $ of $ n $ integers, and he needs to find the number of contiguous subarrays of $ A $ that have an answer to the problem equal to $ k $ for each integer $ k $ between $ 1 $ and $ n $ (inclusive).

## 输入格式

The first line of input contains a single integer $ n $ ( $ 1 \leq n \leq 5000 $ ), the size of the array.

The second line contains $ n $ integers $ a_1 $ , $ a_2 $ , $ \dots $ , $ a_n $ ( $ -10^8 \leq a_i \leq 10^8 $ ), the values of the array.

## 输出格式

Output $ n $ space-separated integers, the $ k $ -th integer should be the number of contiguous subarrays of $ A $ that have an answer to the problem equal to $ k $ .

## 样例 #1

### 输入

```
2
5 5

```

### 输出

```
3 0

```

## 样例 #2

### 输入

```
5
5 -4 2 1 8

```

### 输出

```
5 5 3 2 0

```

## 样例 #3

### 输入

```
1
0

```

### 输出

```
1

```



---

---
title: "Sand Fortress"
layout: "post"
diff: 提高+/省选-
pid: CF985D
tag: ['数学', '二分', '枚举']
---

# Sand Fortress

## 题目描述

You are going to the beach with the idea to build the greatest sand castle ever in your head! The beach is not as three-dimensional as you could have imagined, it can be decribed as a line of spots to pile up sand pillars. Spots are numbered $ 1 $ through infinity from left to right.

Obviously, there is not enough sand on the beach, so you brought $ n $ packs of sand with you. Let height $ h_{i} $ of the sand pillar on some spot $ i $ be the number of sand packs you spent on it. You can't split a sand pack to multiple pillars, all the sand from it should go to a single one. There is a fence of height equal to the height of pillar with $ H $ sand packs to the left of the first spot and you should prevent sand from going over it.

Finally you ended up with the following conditions to building the castle:

- $ h_{1}<=H $ : no sand from the leftmost spot should go over the fence;
- For any ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF985D/77d67b6184b30d84bfc3e3e2794dc8de9b20fcf2.png) $ |h_{i}-h_{i+1}|<=1 $ : large difference in heights of two neighboring pillars can lead sand to fall down from the higher one to the lower, you really don't want this to happen;
- ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF985D/7c65b11667de38fcb78de5945051b7b0879e1abf.png): you want to spend all the sand you brought with you.

As you have infinite spots to build, it is always possible to come up with some valid castle structure. Though you want the castle to be as compact as possible.

Your task is to calculate the minimum number of spots you can occupy so that all the aforementioned conditions hold.

## 输入格式

The only line contains two integer numbers $ n $ and $ H $ ( $ 1<=n,H<=10^{18} $ ) — the number of sand packs you have and the height of the fence, respectively.

## 输出格式

Print the minimum number of spots you can occupy so the all the castle building conditions hold.

## 说明/提示

Here are the heights of some valid castles:

- $ n=5,H=2,[2,2,1,0,...],[2,1,1,1,0,...],[1,0,1,2,1,0,...] $
- $ n=6,H=8,[3,2,1,0,...],[2,2,1,1,0,...],[0,1,0,1,2,1,1,0...] $ (this one has $ 5 $ spots occupied)

The first list for both cases is the optimal answer, $ 3 $ spots are occupied in them.

And here are some invalid ones:

- $ n=5,H=2,[3,2,0,...],[2,3,0,...],[1,0,2,2,...] $
- $ n=6,H=8,[2,2,2,0,...],[6,0,...],[1,4,1,0...],[2,2,1,0,...] $

## 样例 #1

### 输入

```
5 2

```

### 输出

```
3

```

## 样例 #2

### 输入

```
6 8

```

### 输出

```
3

```



---


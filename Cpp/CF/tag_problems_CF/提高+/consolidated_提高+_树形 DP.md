---
title: "Tree Array"
layout: "post"
diff: 提高+/省选-
pid: CF1540B
tag: ['树形 DP', '组合数学', '概率论']
---

# Tree Array

## 题目描述

You are given a tree consisting of $ n $ nodes. You generate an array from the tree by marking nodes one by one.

Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree.

After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node.

It can be shown that the process marks all nodes in the tree.

The final array $ a $ is the list of the nodes' labels in order of the time each node was marked.

Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.

The number of inversions in an array $ a $ is the number of pairs of indices $ (i, j) $ such that $ i < j $ and $ a_i > a_j $ . For example, the array $ [4, 1, 3, 2] $ contains $ 4 $ inversions: $ (1, 2) $ , $ (1, 3) $ , $ (1, 4) $ , $ (3, 4) $ .

## 输入格式

The first line contains a single integer $ n $ ( $ 2 \le n \le 200 $ ) — the number of nodes in the tree.

The next $ n - 1 $ lines each contains two integers $ x $ and $ y $ ( $ 1 \le x, y \le n $ ; $ x \neq y $ ), denoting an edge between node $ x $ and $ y $ .

It's guaranteed that the given edges form a tree.

## 输出格式

Output the expected number of inversions in the generated array modulo $ 10^9+7 $ .

Formally, let $ M = 10^9+7 $ . It can be shown that the answer can be expressed as an irreducible fraction $ \frac{p}{q} $ , where $ p $ and $ q $ are integers and $ q \not \equiv 0 \pmod{M} $ . Output the integer equal to $ p \cdot q^{-1} \bmod M $ . In other words, output such an integer $ x $ that $ 0 \le x < M $ and $ x \cdot q \equiv p \pmod{M} $ .

## 说明/提示

This is the tree from the first sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/3833e6cdc8f432e8774aa8c02d9352118566a812.png)For the first sample, the arrays are almost fixed. If node $ 2 $ is chosen initially, then the only possible array is $ [2, 1, 3] $ ( $ 1 $ inversion). If node $ 3 $ is chosen initially, then the only possible array is $ [3, 1, 2] $ ( $ 2 $ inversions). If node $ 1 $ is chosen initially, the arrays $ [1, 2, 3] $ ( $ 0 $ inversions) and $ [1, 3, 2] $ ( $ 1 $ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $ \frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6} $ .

 $ 166666669 \cdot 6 = 7 \pmod {10^9 + 7} $ , so the answer is $ 166666669 $ .

This is the tree from the second sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/7f613b365926417ec34142a093ccc13b3b572f4f.png)This is the tree from the third sample:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1540B/4cf8ac5fc765cc7cdc6657a332a13e66dcba8fef.png)

## 样例 #1

### 输入

```
3
1 2
1 3
```

### 输出

```
166666669
```

## 样例 #2

### 输入

```
6
2 1
2 3
6 1
1 4
2 5
```

### 输出

```
500000009
```

## 样例 #3

### 输入

```
5
1 2
1 3
1 4
2 5
```

### 输出

```
500000007
```



---

---
title: "Labyrinth"
layout: "post"
diff: 提高+/省选-
pid: CF1578L
tag: ['Kruskal 重构树', '树形 DP']
---

# Labyrinth

## 题目描述

In a dream, Lucy found herself in a labyrinth. This labyrinth consists of $ n $ rooms, connected by $ m $ passages ( $ i $ -th passage is $ w_i $ cm wide). Each passage can be traversed in both directions. It is guaranteed that it is possible to get from any room to any other room. But this is not an ordinary labyrinth — each room in this labyrinth contains a magic candy. When Lucy eats this magic candy, she is getting wider. Specifically, if she eats candy from room $ i $ she becomes wider by $ c_i $ cm. Note that she is not obliged to eat candy the first time she visits a particular room, but she can eat each candy only once.

Unfortunately, passages in this labyrinth are pretty narrow, so after eating some candy, Lucy can get too wide and will not be able to traverse them — her width should not be greater than the width of the corresponding passage.

Lucy starts her journey in a room number $ 1 $ . She wants to eat all the candies. After that, she will just wake up, so she does not have to be able to return to the room $ 1 $ . She realizes that with her current width, she may not be able to do so, so she plans a workout before embarking on her journey. Lucy wants to know if it is possible to start with some positive width and still eat all the candies. If yes, then what is the maximal starting width with which it is possible.

## 输入格式

The first line contains two integers, $ n $ and $ m $ ( $ 2 \le n \le 10^5; n - 1 \le m \le 10^5 $ ) — the number of rooms and the number of passages.

The second line contains $ n $ integers — $ c_i $ ( $ 1 \le c_i \le 10^9 $ ).

Next $ m $ lines contain three integers each — $ a_i $ , $ b_i $ and $ w_i $ ( $ 1 \le a_i, b_i \le n; a_i \ne b_i; 1 \le w_i \le 10^9 $ ) describing passage that connects rooms $ a_i $ and $ b_i $ and is $ w_i $ cm wide. It is guaranteed that the resulting labyrinth is connected and there is at most one passage between any pair of rooms.

## 输出格式

If it is possible to eat all the candies, output the maximal possible starting width, otherwise output $ -1 $ .

## 样例 #1

### 输入

```
3 3
1 2 3
1 2 4
1 3 4
2 3 6
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2 1
1 1
1 2 1
```

### 输出

```
-1
```



---

---
title: "Weight the Tree"
layout: "post"
diff: 提高+/省选-
pid: CF1646D
tag: ['树形 DP']
---

# Weight the Tree

## 题目描述

You are given a tree of $ n $ vertices numbered from $ 1 $ to $ n $ . A tree is a connected undirected graph without cycles.

For each $ i=1,2, \ldots, n $ , let $ w_i $ be the weight of the $ i $ -th vertex. A vertex is called good if its weight is equal to the sum of the weights of all its neighbors.

Initially, the weights of all nodes are unassigned. Assign positive integer weights to each vertex of the tree, such that the number of good vertices in the tree is maximized. If there are multiple ways to do it, you have to find one that minimizes the sum of weights of all vertices in the tree.

## 输入格式

The first line contains one integer $ n $ ( $ 2\le n\le 2\cdot 10^5 $ ) — the number of vertices in the tree.

Then, $ n−1 $ lines follow. Each of them contains two integers $ u $ and $ v $ ( $ 1\le u,v\le n $ ) denoting an edge between vertices $ u $ and $ v $ . It is guaranteed that the edges form a tree.

## 输出格式

In the first line print two integers — the maximum number of good vertices and the minimum possible sum of weights for that maximum.

In the second line print $ n $ integers $ w_1, w_2, \ldots, w_n $ ( $ 1\le w_i\le 10^9 $ ) — the corresponding weight assigned to each vertex. It can be proven that there exists an optimal solution satisfying these constraints.

If there are multiple optimal solutions, you may print any.

## 说明/提示

This is the tree for the first test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1646D/c1443959610684ba1c023451af2be26a243d7782.png) In this case, if you assign a weight of $ 1 $ to each vertex, then the good vertices (which are painted black) are $ 1 $ , $ 3 $ and $ 4 $ . It impossible to assign weights so that all vertices are good vertices. The minimum sum of weights in this case is $ 1+1+1+1=4 $ , and it is impossible to have a lower sum because the weights have to be positive integers.This is the tree for the second test case:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1646D/5f2b683a0e657b99ca0eb99ee84a2529445c05d6.png) In this case, if you assign a weight of $ 1 $ to each vertex, then the good vertices (which are painted black) are $ 2 $ and $ 3 $ . It can be proven that this is an optimal assignment.

## 样例 #1

### 输入

```
4
1 2
2 3
2 4
```

### 输出

```
3 4
1 1 1 1
```

## 样例 #2

### 输入

```
3
1 2
1 3
```

### 输出

```
2 3
1 1 1
```

## 样例 #3

### 输入

```
2
1 2
```

### 输出

```
2 2
1 1
```

## 样例 #4

### 输入

```
9
3 4
7 6
2 1
8 3
5 6
1 8
8 6
9 6
```

### 输出

```
6 11
1 1 1 1 1 1 1 3 1
```



---

---
title: "K-Set Tree"
layout: "post"
diff: 提高+/省选-
pid: CF1691F
tag: ['树形 DP']
---

# K-Set Tree

## 题目描述

You are given a tree $ G $ with $ n $ vertices and an integer $ k $ . The vertices of the tree are numbered from $ 1 $ to $ n $ .

For a vertex $ r $ and a subset $ S $ of vertices of $ G $ , such that $ |S| = k $ , we define $ f(r, S) $ as the size of the smallest rooted subtree containing all vertices in $ S $ when the tree is rooted at $ r $ . A set of vertices $ T $ is called a rooted subtree, if all the vertices in $ T $ are connected, and for each vertex in $ T $ , all its descendants belong to $ T $ .

You need to calculate the sum of $ f(r, S) $ over all possible distinct combinations of vertices $ r $ and subsets $ S $ , where $ |S| = k $ . Formally, compute the following: $ $$$\sum_{r \in V} \sum_{S \subseteq V, |S| = k} f(r, S), $ $  where  $ V $  is the set of vertices in  $ G $ .</p><p>Output the answer modulo  $ 10^9 + 7$$$.

## 输入格式

The first line contains two integers $ n $ and $ k $ ( $ 3 \le n \le 2 \cdot 10^5 $ , $ 1 \le k \le n $ ).

Each of the following $ n - 1 $ lines contains two integers $ x $ and $ y $ ( $ 1 \le x, y \le n $ ), denoting an edge between vertex $ x $ and $ y $ .

It is guaranteed that the given edges form a tree.

## 输出格式

Print the answer modulo $ 10^9 + 7 $ .

## 说明/提示

The tree in the second example is given below:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1691F/e82a7a29dc0a63112d5ed3b2013f71742d57079e.png)We have $ 21 $ subsets of size $ 2 $ in the given tree. Hence, $ $$$S \in \left\{\{1, 2\}, \{1, 3\}, \{1, 4\}, \{1, 5\}, \{1, 6\}, \{1, 7\}, \{2, 3\}, \{2, 4\}, \{2, 5\}, \{2, 6\}, \{2, 7\}, \{3, 4\}, \{3, 5\}, \{3, 6\}, \{3, 7\}, \{4, 5\}, \{4, 6\}, \{4, 7\}, \{5, 6\}, \{5, 7\}, \{6, 7\} \right\}. $ $  And since we have  $ 7 $  vertices,  $ 1 \\le r \\le 7 $ . We need to find the sum of  $ f(r, S) $  over all possible pairs of  $ r $  and  $ S $ . </p><p>Below we have listed the value of  $ f(r, S) $  for some combinations of  $ r $  and  $ S $ .</p><ul> <li>  $ r = 1 $ ,  $ S = \\{3, 7\\} $ . The value of  $ f(r, S) $  is  $ 5 $  and the corresponding subtree is  $ \\{2, 3, 4, 6, 7\\} $ . </li><li>  $ r = 1 $ ,  $ S = \\{5, 4\\} $ . The value of  $ f(r, S) $  is  $ 7 $  and the corresponding subtree is  $ \\{1, 2, 3, 4, 5, 6, 7\\} $ . </li><li>  $ r = 1 $ ,  $ S = \\{4, 6\\} $ . The value of  $ f(r, S) $  is  $ 3 $  and the corresponding subtree is  $ \\{4, 6, 7\\}$$$.

## 样例 #1

### 输入

```
3 2
1 2
1 3
```

### 输出

```
25
```

## 样例 #2

### 输入

```
7 2
1 2
2 3
2 4
1 5
4 6
4 7
```

### 输出

```
849
```



---

---
title: "Yet Another Array Counting Problem"
layout: "post"
diff: 提高+/省选-
pid: CF1748E
tag: ['动态规划 DP', '树形 DP', '笛卡尔树']
---

# Yet Another Array Counting Problem

## 题目描述

对于长度为 $n$ 的序列 $x$，定义其在子段 $[l;r]$ 的“最左端最大值位置”为最小的满足 $l\leq i\leq r$ 且 $x_i=\max_{j=l}^rx_j$ 的整数 $i$。  
给定整数 $n,m$ 和长度为 $n$ 的序列 $a$，你需要求出满足下列要求的序列 $b$ 的数量：

- 序列 $b$ 长度为 $n$，且对任意整数 $i(1\leq i\leq n)$ 都有 $1\leq b_i\leq m$ 成立。
- 对任意整数 $l,r(1\leq l\leq r\leq n)$，总有 $a,b$ 在子段 $[l;r]$ 的“最左端最大值位置”相同。

答案对 $10^9+7$ 取模。  
每个测试点包含多组数据。

## 输入格式

第一行输入一个整数 $t(1\leq t\leq10^3)$ 表示数据组数，接下来对于每组数据：  
第一行输入两个整数 $n,m(2\leq n,m\leq2\times10^5;\sum n\times m\leq10^6)$。  
接下来输入一行 $n$ 个整数表示序列 $a(1\leq a_i\leq m)$。

## 输出格式

对于每组数据：  
输出满足要求的序列 $b$ 的数量对 $10^9+7$ 取模后的值。

### 样例解释

- 对于第一组数据：
	- 下面是所有 $8$ 个满足要求的序列 $b$：  
    $[1,2,1],[1,2,2],[1,3,1],[1,3,2],[1,3,3],[2,3,1],[2,3,2],[2,3,3]$。
- 对于第二组数据：
	- 下面是所有 $5$ 个满足要求的序列 $b$：  
    $[1,1,1,1],[2,1,1,1],[2,2,1,1],[2,2,2,1],[2,2,2,2]$。

## 样例 #1

### 输入

```
4
3 3
1 3 2
4 2
2 2 2 2
6 9
6 9 6 9 6 9
9 100
10 40 20 20 100 60 80 60 60
```

### 输出

```
8
5
11880
351025663
```



---

---
title: "Two Chess Pieces"
layout: "post"
diff: 提高+/省选-
pid: CF1774E
tag: ['动态规划 DP', '树形 DP']
---

# Two Chess Pieces

## 题目描述

# Two Chess Pieces


Cirno\_9baka 有一棵包含 $n$ 个节点的树。他愿意把它与你分享，这意味着你可以对它进行一些操作。  

最初，树的 $1$ 号节点上有两个棋子。对每个操作，您可以选择任意一个棋子，并将其移动到相邻节点。你需要确保两个棋子之间的距离不会超过 $d$。

给你两个序列，分别表示两个棋子需要经过的节点（可以以**任何顺序**经过）。最终，它们必须回到根节点。作为一个好奇的男孩，Cirno\_9baka 想知道最少操作次数。

## 输入格式

第一行包含两个整数 $n$ 和 $d$（$2\le d\le n\le 2\cdot 10^5$）。
以下 $n-1$ 行的第 $i$ 行包含两个整数 $ u_i, v_i $ $ (1 \le u_i, v_i \le n) $，表示节点 $ u_i, v_i $ 之间的边。
保证这些边形成一棵树。
下一行包含一个整数 $m_1$（$1\le m_1\le n$）和 $m_1$ 个整数 $a_1，a_2，\ldots，a_{m_1}$（$1\le a_i\le n$，所有$a_i$都是不同的）- 第一个棋子需要经过的节点序列。
第二行包含一个整数$m_2$（$1\le m_2\le n$）和 $m_2$ 个整数 $b_1，b_2，\ldots，b_{m_2}$（$1\le b_i\le n$，所有$b_i$都是不同的）-第二棋子需要经过的节点序列。

## 输出格式

输出一个整数 - 最小操作次数。

## 样例 #1

### 输入

```
4 2
1 2
1 3
2 4
1 3
1 4
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4 2
1 2
2 3
3 4
4 1 2 3 4
1 1
```

### 输出

```
8
```



---

---
title: "Xorcerer's Stones"
layout: "post"
diff: 提高+/省选-
pid: CF1779F
tag: ['背包 DP', '树形 DP']
---

# Xorcerer's Stones

## 题目描述

Misha had been banned from playing chess for good since he was accused of cheating with an engine. Therefore, he retired and decided to become a xorcerer.

One day, while taking a walk in a park, Misha came across a rooted tree with nodes numbered from $ 1 $ to $ n $ . The root of the tree is node $ 1 $ .

For each $ 1\le i\le n $ , node $ i $ contains $ a_i $ stones in it. Misha has recently learned a new spell in his xorcery class and wants to test it out. A spell consists of:

- Choose some node $ i $ ( $ 1 \leq i \leq n $ ).
- Calculate the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) $ x $ of all $ a_j $ such that node $ j $ is in the subtree of $ i $ ( $ i $ belongs to its own subtree).
- Set $ a_j $ equal to $ x $ for all nodes $ j $ in the subtree of $ i $ .

Misha can perform at most $ 2n $ spells and he wants to remove all stones from the tree. More formally, he wants $ a_i=0 $ to hold for each $ 1\leq i \leq n $ . Can you help him perform the spells?

A tree with $ n $ nodes is a connected acyclic graph which contains $ n-1 $ edges. The subtree of node $ i $ is the set of all nodes $ j $ such that $ i $ lies on the simple path from $ 1 $ (the root) to $ j $ . We consider $ i $ to be contained in its own subtree.

## 输入格式

The first line contains a single integer $ n $ ( $ 2 \leq n \leq 2\cdot 10^5 $ ) — the size of the tree

The second line contains an array of integers $ a_1,a_2,\ldots, a_n $ ( $ 0 \leq a_i \leq 31 $ ), describing the number of stones in each node initially.

The third line contains an array of integers $ p_2,p_3,\ldots, p_n $ ( $ 1 \leq p_i \leq i-1 $ ), where $ p_i $ means that there is an edge connecting $ p_i $ and $ i $ .

## 输出格式

If there is not a valid sequence of spells, output $ -1 $ .

Otherwise, output a single integer $ q $ ( $ 0 \leq q \leq 2n $ ) in the first line — the number of performed spells.

In the second line output a sequence of integers $ v_1,v_2,\ldots,v_q $ ( $ 1 \leq v_i \leq n $ ) — the $ i $ -th spell will be performed on the subtree of node $ v_i $ . Please note that order matters.

If multiple solutions exist, output any. You don't have to minimize the number of operations.

## 说明/提示

Please refer to the following pictures for an explanation of the third test. Only the first $ 4 $ spells are shown since the last $ 2 $ do nothing. The first picture represents the tree initially with the number of stones for each node written above it in green. Changes applied by the current spell are highlighted in red.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1779F/87049d0f1cff376d7b36c99b33f175c4877519fa.png)

## 样例 #1

### 输入

```
2
13 13
1
```

### 输出

```
1
1
```

## 样例 #2

### 输入

```
7
5 2 8 3 4 1 31
1 1 2 2 3 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
9
3 31 1 2 7 30 7 3 1
1 1 1 2 5 5 3 4
```

### 输出

```
6
3 2 3 1 2 2
```



---

---
title: "Game on Tree (Hard)"
layout: "post"
diff: 提高+/省选-
pid: CF1970C3
tag: ['博弈论', '树形 DP']
---

# Game on Tree (Hard)

## 题目描述

This is the hard version of the problem. The only difference in this version is the constraint on $ t $ .

Ron and Hermione are playing a game on a tree of $ n $ nodes that are initially inactive. The game consists of $ t $ rounds, each of which starts with a stone on exactly one node, which is considered as activated. A move consists of picking an inactive neighbor of the node with a stone on it and moving the stone there (thus activating this neighbor). Ron makes the first move, after which he alternates with Hermione until no valid move is available. The player that cannot make a move loses the round. If both players play optimally, who wins each round of this game?

Note that all the rounds are played with the same tree; only the starting node changes. Moreover, after each round, all active nodes are considered inactive again.

## 输入格式

The first line contains integers $ n $ ( $ 2 \leq n \leq 2\times 10^5 $ ), $ t $ ( $ 1 \leq t \leq n $ ), the number of nodes in the tree and the number of rounds, respectively.

The next $ n-1 $ lines contain two integers $ 1 \leq u, v \leq n $ each, corresponding to an edge of the tree.

The next line contains $ t $ integers $ 1 \leq u_1 , \dots , u_t \leq n $ , corresponding to the node where the stone is initially put.

## 输出格式

The output consists of $ t $ lines, each line being either "Ron" or "Hermione".

## 样例 #1

### 输入

```
5 2
1 2
1 3
3 4
3 5
1 2
```

### 输出

```
Ron
Ron
```

## 样例 #2

### 输入

```
6 3
1 2
2 3
1 4
4 5
4 6
1 4 6
```

### 输出

```
Hermione
Ron
Hermione
```



---

---
title: "Min-Fund Prison (Medium)"
layout: "post"
diff: 提高+/省选-
pid: CF1970G2
tag: ['树形 DP']
---

# Min-Fund Prison (Medium)

## 题目描述

现给出一张由 $n$ 个点 $m$ 条边构成的无向图，其 $m$ 条边为 $(u_i, v_i)$ ( $1\leq i\leq m$ )，表示 $u_i,v_i$ 相连。图中不存在重边，也没有自环。

你可以以 $c$ 的成本在任意两个点 $x, y$ 之间连一条边。这个操作可以进行任意次，设你操作了 $k$ 次。要求操作结束后图是连通的。

在连边操作之后，你必须删去一条割边，使得剩下的图恰由 $2$ 个连通块组成。设两个连通块的大小为 $x,y$ ，请问 $x^2+y^2+kc$ 的最小值为何？

## 输入格式

第一行输入样例个数 $t$ ( $1\leq t\leq 300$ ) 。接下来输入 $t$ 个样例，每个样例形式如下——

每个样例的第一行包含三个整数 $n, m, c$ ( $2\leq n\leq 300, 1\leq m\leq 300, 1\leq c\leq 10^9$ )，表示点数、边数和加边操作的成本。

接下来 $m$ 行，每一行输入两个整数 $u, v$ ( $1\leq u,v\leq n,u\neq v$ )，表示 $u,v$ 之间有一条边。

保证对于所有输入的样例，满足 $\sum n\leq 300,\sum m\leq 300$ 。

## 输出格式

如果能够使得最后结果为两个连通块，输出 $x^2+y^2+kc$ 的最小值；否则，输出 $-1$ 。

## 样例 #1

### 输入

```
4
4 6 5
4 3
2 3
2 4
1 2
4 1
3 1
6 6 2
1 4
2 5
3 6
1 5
3 5
6 5
6 5 7
1 4
2 5
3 6
3 5
6 5
7 5 4
1 4
3 6
3 5
6 5
2 7
```

### 输出

```
-1
20
25
33
```



---

---
title: "Shuffle"
layout: "post"
diff: 提高+/省选-
pid: CF1984E
tag: ['树形 DP']
---

# Shuffle

## 题目描述

Two hungry red pandas, Oscar and Lura, have a tree $ T $ with $ n $ nodes. They are willing to perform the following shuffle procedure on the whole tree $ T $ exactly once. With this shuffle procedure, they will create a new tree out of the nodes of the old tree.

1. Choose any node $ V $ from the original tree $ T $ . Create a new tree $ T_2 $ , with $ V $ as the root.
2. Remove $ V $ from $ T $ , such that the original tree is split into one or more subtrees (or zero subtrees, if $ V $ is the only node in $ T $ ).
3. Shuffle each subtree with the same procedure (again choosing any node as the root), then connect all shuffled subtrees' roots back to $ V $ to finish constructing $ T_2 $ .

After this, Oscar and Lura are left with a new tree $ T_2 $ . They can only eat leaves and are very hungry, so please find the maximum number of leaves over all trees that can be created in exactly one shuffle.

Note that leaves are all nodes with degree $ 1 $ . Thus, the root may be considered as a leaf if it has only one child.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The first line of every test case contains a single integer $ n $ ( $ 2 \leq n \leq 2 \cdot 10^5 $ ) — the number of nodes within the original tree $ T $ .

The next $ n - 1 $ lines each contain two integers $ u $ and $ v $ ( $ 1 \leq u, v \leq n $ ) — an edge within the original tree $ T $ . The given edges form a tree.

The sum of $ n $ over all test cases does not exceed $ 3 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the maximum number of leaves achievable with exactly one shuffle procedure on the whole tree.

## 说明/提示

In the first test case, it can be shown that the maximum number of leaves is $ 4 $ . To accomplish this, we can start our shuffle with selecting node $ 3 $ as the new root.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1984E/0496f1e53b8faef700719d0f92212c9f9e0075c9.png)  Next, we are left only with one subtree, in which we can select node $ 2 $ to be the new root of that subtree.  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1984E/a280b18a5bea58b0f12cdd08ee4e52dbe699c78a.png)  This will force all $ 3 $ remaining nodes to be leaves, and once we connect them back to our new root, the shuffled subtree looks like this:  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1984E/7cf63ffdc63a80cf27ff8fce3a8da6cd1e9078f0.png)  We connect the shuffled subtree back to our new root of our new tree. Our final tree has four leaves (including the root), and looks like this:  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1984E/4a077e6e7f7254d7c89391723da6791d33896856.png)In our second test case, we have a line of five nodes. It can be shown that the maximum number of leaves after one shuffle is $ 3 $ . We can start off with node $ 2 $ , which forces node $ 1 $ to become a leaf. Then, if we select node $ 4 $ on the right side, we will also have nodes $ 3 $ and $ 5 $ as leaves.

The third test case is a star graph with six nodes. The number of leaves cannot increase, thus our answer will be $ 5 $ (if we start the shuffling with the original root node).

## 样例 #1

### 输入

```
4
5
1 2
1 3
2 4
2 5
5
1 2
2 3
3 4
4 5
6
1 2
1 3
1 4
1 5
1 6
10
9 3
8 1
10 6
8 5
7 8
4 6
1 3
10 1
2 7
```

### 输出

```
4
3
5
6
```



---

---
title: "Deterministic Heap (Easy Version)"
layout: "post"
diff: 提高+/省选-
pid: CF2001E1
tag: ['树形 DP']
---

# Deterministic Heap (Easy Version)

## 题目描述

This is the easy version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on $ n $ and $ t $ . You can make hacks only if both versions of the problem are solved.

Consider a perfect binary tree with size $ 2^n - 1 $ , with nodes numbered from $ 1 $ to $ 2^n-1 $ and rooted at $ 1 $ . For each vertex $ v $ ( $ 1 \le v \le 2^{n - 1} - 1 $ ), vertex $ 2v $ is its left child and vertex $ 2v + 1 $ is its right child. Each node $ v $ also has a value $ a_v $ assigned to it.

Define the operation $ \mathrm{pop} $ as follows:

1. initialize variable $ v $ as $ 1 $ ;
2. repeat the following process until vertex $ v $ is a leaf (i.e. until $ 2^{n - 1} \le v \le 2^n - 1 $ ); 
  1. among the children of $ v $ , choose the one with the larger value on it and denote such vertex as $ x $ ; if the values on them are equal (i.e. $ a_{2v} = a_{2v + 1} $ ), you can choose any of them;
  2. assign $ a_x $ to $ a_v $ (i.e. $ a_v := a_x $ );
  3. assign $ x $ to $ v $ (i.e. $ v := x $ );
3. assign $ -1 $ to $ a_v $ (i.e. $ a_v := -1 $ ).

Then we say the $ \mathrm{pop} $ operation is deterministic if there is a unique way to do such operation. In other words, $ a_{2v} \neq a_{2v + 1} $ would hold whenever choosing between them.

A binary tree is called a max-heap if for every vertex $ v $ ( $ 1 \le v \le 2^{n - 1} - 1 $ ), both $ a_v \ge a_{2v} $ and $ a_v \ge a_{2v + 1} $ hold.

A max-heap is deterministic if the $ \mathrm{pop} $ operation is deterministic to the heap when we do it for the first time.

Initially, $ a_v := 0 $ for every vertex $ v $ ( $ 1 \le v \le 2^n - 1 $ ), and your goal is to count the number of different deterministic max-heaps produced by applying the following operation $ \mathrm{add} $ exactly $ k $ times:

- Choose an integer $ v $ ( $ 1 \le v \le 2^n - 1 $ ) and, for every vertex $ x $ on the path between $ 1 $ and $ v $ , add $ 1 $ to $ a_x $ .

Two heaps are considered different if there is a node which has different values in the heaps.

Since the answer might be large, print it modulo $ p $ .

## 输入格式

Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 500 $ ). The description of the test cases follows.

The first line of each test case contains three integers $ n, k, p $ ( $ 1 \le n, k \le 500 $ , $ 10^8 \le p \le 10^9 $ , $ p $ is a prime).

It is guaranteed that the sum of $ n $ and the sum of $ k $ over all test cases does not exceed $ 500 $ .

## 输出格式

For each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation $ \mathrm{add} $ exactly $ k $ times, modulo $ p $ .

## 说明/提示

For the first testcase, there is only one way to generate $ a $ , and such sequence is a deterministic max-heap, so the answer is $ 1 $ .

For the second testcase, if we choose $ v = 1 $ and do the operation, we would have $ a = [1, 0, 0] $ , and since $ a_2 = a_3 $ , we can choose either of them when doing the first $ \mathrm{pop} $ operation, so such heap is not a deterministic max-heap.

And if we choose $ v = 2 $ , we would have $ a = [1, 1, 0] $ , during the first $ \mathrm{pop} $ , the following would happen:

- initialize $ v $ as $ 1 $
- since $ a_{2v} > a_{2v + 1} $ , choose $ 2v $ as $ x $ , then $ x = 2 $
- assign $ a_x $ to $ a_v $ , then $ a = [1, 1, 0] $
- assign $ x $ to $ v $ , then $ v = 2 $
- since $ v $ is a leaf, assign $ -1 $ to $ a_v $ , then $ a = [1, -1, 0] $

Since the first $ \mathrm{pop} $ operation is deterministic, this is a deterministic max-heap. Also, if we choose $ v = 3 $ , $ a $ would be a deterministic max-heap, so the answer is $ 2 $ .

## 样例 #1

### 输入

```
7
1 13 998244353
2 1 998244353
3 2 998244853
3 3 998244353
3 4 100000037
4 2 100000039
4 3 100000037
```

### 输出

```
1
2
12
52
124
32
304
```

## 样例 #2

### 输入

```
1
500 500 100000007
```

### 输出

```
76297230
```

## 样例 #3

### 输入

```
6
87 63 100000037
77 77 100000039
100 200 998244353
200 100 998244353
32 59 998244853
1 1 998244353
```

### 输出

```
26831232
94573603
37147649
847564946
727060898
1
```



---

---
title: "Alice's Adventures in the Rabbit Hole"
layout: "post"
diff: 提高+/省选-
pid: CF2028E
tag: ['数学', '树形 DP', '概率论']
---

# Alice's Adventures in the Rabbit Hole

## 题目描述

爱丽丝在兔子洞的底部！兔子洞可以建模为一棵树 $^{\text{∗}}$  ，在顶点 $1$ 有一个出口，而爱丽丝从某个顶点 $v$ 开始。她想要逃出这个洞，但不幸的是，红心女王下令处决她。

每分钟都会抛一次公平的硬币。如果硬币正面朝上，爱丽丝可以移动到她当前位置的一个相邻顶点，否则，红心女王可以将爱丽丝拉到女王选择的一个相邻顶点。如果爱丽丝最终出现在树的任何非根叶子 $^{\text{†}}$ 上，爱丽丝就输了。

假设他们都以最佳方式移动，计算爱丽丝从每个起始顶点 $1\le v\le n$ 成功逃脱的概率。由于这些概率可能非常小，因此输出它们对 $998\,244\,353$ 的取模。

形式上，设 $M = 998\,244\,353$ 。可以证明，确切的答案可以表示为一个不可约分的分数 $\frac{p}{q}$ ，其中 $p$ 和 $q$ 是整数且 $q \not \equiv 0 \pmod{M}$。输出等于 $p \cdot q^{-1} \bmod M$ 的整数。换句话说，输出这样一个整数 $x$，使得 $0 \le x < M$ 和 $x \cdot q \equiv p \pmod{M}$ 

---
$^{\text{∗}}$
 一棵树是一个连通的简单图，具有 $n$ 个顶点和 $n-1$ 条边。

$^{\text{†}} $
 一个叶子是一个仅与一条边相连的顶点。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^4$）。测试用例的描述如下。

每个测试用例的第一行包含一个整数 $n$（$2\le n\le 2\cdot 10^5$）——树中的顶点数量。

接下来的 $i$ 行中的第 $n - 1$ 行包含两个整数 $x_i$ 和 $y_i$ （$1 \le x_i, y_i \le n$ 和 $x_i \neq y_i$）——树的边。可以保证给定的边形成一棵树。

可以保证所有测试用例的 $n$ 之和不超过 $2\cdot 10^5$ 。

## 输出格式

对于每个测试用例，输出 $n$ 个整数在一行上——爱丽丝从顶点 $1, 2, \ldots, n$ 开始逃脱的概率。由于这些概率可能非常小，因此输出它们对$998\,244\,353$ 的取模。

## 说明/提示

对于第一个测试用例：

1.根据定义，爱丽丝从根节点（顶点 $1$）逃脱的概率为 $1$。\
2.爱丽丝从顶点 $4$ 和 $5$ 立即输掉，因为它们是叶子。\
3.从另外两个顶点，爱丽丝以概率 $\frac 12$ 逃脱，因为女王会将她拉到叶子。

## 样例 #1

### 输入

```
2
5
1 2
1 3
2 4
3 5
9
1 2
2 3
4 5
5 6
7 8
8 9
2 4
5 7
```

### 输出

```
1 499122177 499122177 0 0 
1 499122177 0 332748118 166374059 0 443664157 720954255 0
```



---

---
title: "Tree Operations"
layout: "post"
diff: 提高+/省选-
pid: CF2035F
tag: ['树形 DP']
---

# Tree Operations

## 题目描述

这确实反映了我们的社会。

有一天，一只乌龟给了你一棵树，其中 $n$ 个节点扎根于节点 $x$ 。每个节点有一个初始非负值； $i$ \第一个节点的起始值为 $a_i$ 。

要使所有节点的值都等于 $0$ 。为此，您将在树上执行一系列操作，其中每个操作将在某个节点上执行。定义节点 $u$ 上的操作，在 $u$ 的子树 $^{\text{∗}}$ 中选择一个节点，并将其值递增或递减 $1$ 。在节点上执行操作的顺序如下：

—对于 $1 \le i \le n$ ， $i$ \第1次操作将在节点 $i$ 上执行。
—对于 $i &gt; n$ ，第 $i$ 次操作将与操作 $i - n$ 在同一节点上执行。

更正式地说，第 $i$ 次操作将在第 $(((i - 1) \bmod n) + 1)$ 次节点上执行。 $^{\text{†}}$

注意，不能跳过操作；也就是说，如果不先执行 $1, 2, \ldots, i - 1$ 操作，就不能执行 $i$ 第1次操作。

假设您选择了最优的操作，找到在使所有节点的值等于 $0$ 之前必须执行的最小操作数。如果经过有限次运算，不可能使所有节点的值都等于 $0$ ，则输出 $-1$ 。

$^{\text{∗}}$ 节点 $u$ 的子树是 $u$ 位于从该节点到根节点的最短路径上的节点集合，包括 $u$ 本身。

$^{\text{†}}$ 这里， $a \bmod b$ 表示 $a$ 除以 $b$ 的余数。

## 输入格式

第一行包含单个整数 $t$ （ $1\le t\le 100$ ）—测试用例的数量。

每个测试用例的第一行包含两个整数 $n$ 和 $x$ （ $1 \le n \le 2000$ , $1 \le x \le n$ ）—节点数和树的根。

每个测试用例的第二行包含 $n$ 个整数 $a_1, a_2, \ldots, a_n$ （ $0 \le a_i \le 10^9$ ）——每个节点的起始值。

每个测试用例的下一行 $n - 1$ 包含两个整数 $u$ 和 $v$ ( $1 \le u, v \le n$ , $u \neq v$ )，表示从 $u$ 到 $v$ 的无向边。它保证给定的边构成一棵树。

保证所有测试用例 $n$ 的和不超过 $2000$ 。

## 输出格式

对于每个测试用例，输出一个整数，表示生成所有节点 $0$ 所需的最小操作量。如果不可能使所有节点都为 $0$ ，则输出 $-1$ 。

## 说明/提示

在第一个测试用例中，您可以执行以下有效的操作顺序：

—对于操作“ $1$ ”，减少节点“ $1$ ”的值。这是有效的，因为 $(((1 - 1) \bmod n) + 1) = 1$ ，节点 $1$ 在节点 $1$ 的子树中。
—对于操作 $2$ ，减少节点 $2$ 的值。这是有效的，因为 $(((2 - 1) \bmod n) + 1) = 2$ ，节点 $2$ 在节点 $2$ 的子树中。
—对于操作 $3$ ，减少节点 $2$ 的值。这是有效的，因为 $(((3 - 1) \bmod n) + 1) = 1$ ，节点 $2$ 在节点 $1$ 的子树中。

翻译者[wjbbssb250](https://www.luogu.com.cn/user/778527)

## 样例 #1

### 输入

```
5
2 1
1 2
1 2
3 2
2 1 3
2 1
3 2
4 1
1 1 0 1
1 2
2 3
1 4
12 6
14 4 5 6 12 9 5 11 6 2 1 12
3 9
10 6
6 12
4 3
3 1
5 11
9 7
5 6
1 8
2 8
5 1
1 1
0
```

### 输出

```
3
6
5
145
0
```



---

---
title: "Control of Randomness"
layout: "post"
diff: 提高+/省选-
pid: CF2040E
tag: ['树形 DP', '概率论']
---

# Control of Randomness

## 题目描述

给定一棵树，树上有 $ n $ 个顶点。

我们在某个顶点 $ v \ne 1 $ 放置一个机器人，最初拥有 $ p $ 枚硬币。以下是机器人的移动规则：

- 当 $ i $ 为奇数时，机器人会向顶点 $ 1 $ 的方向移动到相邻的节点。
- 当 $ i $ 为偶数时，如果你愿意支付一枚硬币并且还有剩余的硬币，则机器人会向顶点 $ 1 $ 的方向移动到相邻的节点；否则，机器人将随机选择一个相邻的节点移动。

当机器人到达顶点 $ 1 $ 时，过程终止。记 $ f(v, p) $ 为通过最佳策略使用硬币时，使得上述过程的期望步数最小值。

你的任务是解决 $ q $ 个查询。每个查询包含一对 $(v_i, p_i)$，你需要计算 $ f(v_i, p_i) $ 模 $ 998\,244\,353 $ 的值。

具体来说，令 $ M = 998\,244\,353 $。结果可以表示为一个不可约分数 $ \frac{p}{q} $，其中 $ p $ 和 $ q $ 是整数且 $ q \not\equiv 0 \pmod{M} $。你需要输出 $ p \cdot q^{-1} \bmod M $。换句话说，输出满足 $ 0 \le x < M $ 且 $ x \cdot q \equiv p \pmod{M} $ 的整数 $ x $。

## 输入格式

输入包含多个测试用例。第一行为测试用例的数量 $ t $ （$ 1 \le t \le 10^3 $）。

对于每个测试用例，第一行包含两个整数 $ n $ 和 $ q $（$ 2 \le n \le 2000 $，$ 1 \le q \le 2000 $），分别表示树的顶点数和查询数量。

接下来的 $ n - 1 $ 行每行描述一条树的边，包含两个整数 $ u_i $ 和 $ v_i $ （$ 1 \le u_i, v_i \le n $，$ u_i \neq v_i $），表示节点 $ u_i $ 和 $ v_i $ 之间有一条边。

接下来的 $ q $ 行中每行包含两个整数 $ v_i $ 和 $ p_i $（$ 2 \le v_i \le n $，$ 0 \le p_i \le n $），表示每个查询的节点和初始硬币数。

保证输入的边构成一棵树，并且所有测试用例的 $ n $ 之和不超过 $ 2000 $，$ q $ 之和不超过 $ 2000 $。

## 输出格式

对于每个测试用例，输出 $ q $ 个整数，表示每个查询 $ f(v_i, p_i) $ 模 $ 998\,244\,353 $ 的结果。

形式上，令 $ M = 998\,244\,353 $。可以证明答案可以表示为不可约分数 $ \frac{p}{q} $，其中 $ p $ 和 $ q $ 是整数且 $ q \not\equiv 0 \pmod{M} $。输出满足 $ 0 \le x < M $ 且 $ x \cdot q \equiv p \pmod{M} $ 的整数 $ x $。

## 说明/提示

在第一个测试用例中，树的结构如下：

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040E/6e37a094615504d3867ace023f49408cee6e1144.png)

第一个查询中，期望值为 $ 1 $，因为机器人从顶点 $ 2 $ 出发，一步就到达了顶点 $ 1 $，过程结束。

第二个查询中的期望步数计算如下（$ x $ 为步数）：

- $ P(x < 2) = 0 $，因为距离顶点 $ 1 $ 是 $ 2 $，机器人无法在更少的步数内到达。
- $ P(x = 2) = \frac{1}{3} $，因为只有一种步骤序列使 $ x = 2 $。即 $ 3 \rightarrow_{1} 2 \rightarrow_{0.33} 1 $，概率为 $ 1 \cdot \frac{1}{3} $。
- $ P(x \bmod 2 = 1) = 0 $，因为机器人只能通过偶数步数到达顶点 $ 1 $。
- $ P(x = 4) = \frac{2}{9} $：可能路径为 $ 3 \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.33} 1 $。
- $ P(x = 6) = \frac{4}{27} $：可能路径为 $ 3 \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.67} [3, 4] \rightarrow_{1} 2 \rightarrow_{0.33} 1 $。
- 一般情况下，$ P(x = i \cdot 2) = \frac{2^{i - 1}}{3^i} $。

因此，$ f(v, p) = \sum_{i=1}^{\infty}{i \cdot 2 \cdot \frac{2^{i - 1}}{3^i}} = 6 $。

第二个测试用例中，树的结构如下：

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2040E/817926230fce12f251ecac195b4fa36da450f14f.png)


 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
4 4
1 2
2 3
2 4
2 0
3 0
4 0
3 1
12 10
1 2
2 3
2 4
1 5
5 6
6 7
6 8
6 9
8 10
10 11
10 12
6 0
9 0
10 0
11 0
3 1
7 1
10 1
12 1
12 2
11 12
```

### 输出

```
1
6
6
2
4
9
8
15
2
3
6
9
5
5
```



---

---
title: "Kevin and Math Class"
layout: "post"
diff: 提高+/省选-
pid: CF2048F
tag: ['动态规划 DP', '树形 DP', '笛卡尔树']
---

# Kevin and Math Class

## 题目描述

Kevin 是来自 Eversleeping Town 的一名学生，他正在参加一门数学课，老师正在给他出一些除法练习题。

在黑板上，有两行正整数，每行包含 $n$ 个数字。第一行是 $a_1, a_2, \ldots, a_n$，第二行是 $b_1, b_2, \ldots, b_n$。

对于每个除法练习题，Kevin 可以选择任何一个区间 $[l, r]$，并在 $b_l, b_{l+1}, \ldots, b_r$ 中找到最小的值 $x$。然后他将修改 $l \leq i \leq r$ 范围内的每个 $a_i$，使得每个 $a_i$ 被 $x$ 除后的结果向上取整。

更正式地，他选择两个整数 $1 \leq l \leq r \leq n$，设 $x = \min_{l \leq i \leq r} b_i$，然后将所有 $l \leq i \leq r$ 范围内的 $a_i$ 修改为 $ \lceil \frac{a_i}{x} \rceil$。

Kevin 只有当所有 $a_i$ 都变为 1 时，才能离开教室回家。他非常渴望回家，想知道实现这一目标所需的最小除法练习次数。

## 输入格式

每个测试案例包含多个测试用例。第一行是测试用例的数量 $t$（$1 \le t \le 10^4$）。

每个测试用例的第一行包含一个整数 $n$（$1 \le n \le 2 \cdot 10^5$），表示数列 $a$ 和 $b$ 的长度。

接下来的一行是 $n$ 个整数 $a_1, a_2, \ldots, a_n$，表示黑板上的第一行数字。

接下来的一行是 $n$ 个整数 $b_1, b_2, \ldots, b_n$，表示黑板上的第二行数字。

保证所有测试用例中 $n$ 的总和不超过 $2 \cdot 10^5$。

## 输出格式

对于每个测试用例，输出一个整数 —— 达成目标所需的最小除法练习次数。

## 说明/提示

对于第一个测试用例:  
$[{\color{red}{5,4}}, 2] \xrightarrow[\min(b_1, b_2) = 3] {\text{操作区间}[1, 2]} [{\color{red}{2, 2, 2}}] \xrightarrow[\min(b_1, b_2, b_3) = 2]{\text{操作区间}[1, 3]} [1, 1, 1]$

对于第二个测试用例:  
$[{\color{red}{3, 6, 1}}, 3, 2] \xrightarrow[\min(b_1, b_2, b_3) = 3]{\text{操作区间}[1, 3]} [1, {\color{red}{2, 1, 3}}, 2] \xrightarrow[\min(b_2, b_3, b_4) = 2]{\text{操作区间}[2, 4]} [1, 1, 1, {\color{red}{2, 2}}] \xrightarrow[\min(b_4, b_5) = 2]{\text{操作区间}[4, 5]} [1, 1, 1, 1, 1]$

translation from [Yorg](https://www.luogu.com.cn/user/617130)

## 样例 #1

### 输入

```
3
3
5 4 2
6 3 2
5
3 6 1 3 2
3 5 3 2 2
6
8 3 3 7 5 8
3 2 3 4 2 3
```

### 输出

```
2
3
3
```



---


---
title: "Magical Array"
layout: "post"
diff: 普及+/提高
pid: CF1704D
tag: ['哈希 hashing', '构造']
---

# Magical Array

## 题目描述

Eric has an array $ b $ of length $ m $ , then he generates $ n $ additional arrays $ c_1, c_2, \dots, c_n $ , each of length $ m $ , from the array $ b $ , by the following way:

Initially, $ c_i = b $ for every $ 1 \le i \le n $ . Eric secretly chooses an integer $ k $ $ (1 \le k \le n) $ and chooses $ c_k $ to be the special array.

There are two operations that Eric can perform on an array $ c_t $ :

- Operation 1: Choose two integers $ i $ and $ j $ ( $ 2 \leq i < j \leq m-1 $ ), subtract $ 1 $ from both $ c_t[i] $ and $ c_t[j] $ , and add $ 1 $ to both $ c_t[i-1] $ and $ c_t[j+1] $ . That operation can only be used on a non-special array, that is when $ t \neq k $ .;
- Operation 2: Choose two integers $ i $ and $ j $ ( $ 2 \leq i < j \leq m-2 $ ), subtract $ 1 $ from both $ c_t[i] $ and $ c_t[j] $ , and add $ 1 $ to both $ c_t[i-1] $ and $ c_t[j+2] $ . That operation can only be used on a special array, that is when $ t = k $ .Note that Eric can't perform an operation if any element of the array will become less than $ 0 $ after that operation.

Now, Eric does the following:

- For every non-special array $ c_i $ ( $ i \neq k $ ), Eric uses only operation 1 on it at least once.
- For the special array $ c_k $ , Eric uses only operation 2 on it at least once.

Lastly, Eric discards the array $ b $ .

For given arrays $ c_1, c_2, \dots, c_n $ , your task is to find out the special array, i.e. the value $ k $ . Also, you need to find the number of times of operation $ 2 $ was used on it.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. Description of test cases follows.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 3 \leq n \leq 10^5 $ , $ 7 \leq m \leq 3 \cdot 10^5 $ ) — the number of arrays given to you, and the length of each array.

The next $ n $ lines contains $ m $ integers each, $ c_{i,1}, c_{i,2}, \dots , c_{i,m} $ .

It is guaranteed that each element of the discarded array $ b $ is in the range $ [0,10^6] $ , and therefore $ 0 \leq c_{i,j} \leq 3 \cdot 10^{11} $ for all possible pairs of $ (i,j) $ .

It is guaranteed that the sum of $ n \cdot m $ over all test cases does not exceed $ 10^6 $ .

It is guaranteed that the input is generated according to the procedure above.

## 输出格式

For each test case, output one line containing two integers — the index of the special array, and the number of times that Operation 2 was performed on it. It can be shown that under the constraints given in the problem, this value is unique and won't exceed $ 10^{18} $ , so you can represent it as a $ 64 $ -bit integer. It can also be shown that the index of the special array is uniquely determined.

In this problem, hacks are disabled.

## 说明/提示

In the first test case, the secret array $ b $ is $ [0, 1, 1, 1, 1, 1, 1, 1, 0] $ . Array $ c_1 $ and array $ c_2 $ are generated by using operation 1. Array $ c_3 $ is generated by using operation 2.

For Array $ c_1 $ ,you can choose $ i=4 $ and $ j=5 $ perform Operation 1 one time to generate it. For Array $ c_2 $ , you can choose $ i=6 $ and $ j=7 $ perform Operation 1 one time to generate it. For Array $ c_3 $ ,you can choose $ i=4 $ and $ j=5 $ perform Operation 2 one time to generate it.

In the second test case, the secret array $ b $ is $ [20, 20, 20, 20, 20, 20, 20] $ . You can also find that array $ c_1 $ and array $ c_2 $ are generated by using Operation 1. Array $ c_3 $ is generated by using Operation 2.

In the third test case, the secret array $ b $ is $ [20, 20, 20, 20, 20, 20, 20, 20, 20] $ . You can also find that array $ c_1 $ and array $ c_2 $ are generated by using Operation 1. Array $ c_3 $ is generated by using Operation 2.

## 样例 #1

### 输入

```
7
3 9
0 1 2 0 0 2 1 1 0
0 1 1 1 2 0 0 2 0
0 1 2 0 0 1 2 1 0
3 7
25 15 20 15 25 20 20
26 14 20 14 26 20 20
25 15 20 15 20 20 25
3 9
25 15 20 15 25 20 20 20 20
26 14 20 14 26 20 20 20 20
25 15 20 15 25 15 20 20 25
3 11
25 15 20 15 25 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20
25 15 20 15 25 20 15 20 20 20 25
3 13
25 15 20 15 25 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 15 20 20 20 20 25
3 15
25 15 20 15 25 20 20 20 20 20 20 20 20 20 20
26 14 20 14 26 20 20 20 20 20 20 20 20 20 20
25 15 20 15 25 20 20 20 15 20 20 20 20 20 25
3 9
909459 479492 676924 224197 162866 164495 193268 742456 728277
948845 455424 731850 327890 304150 237351 251763 225845 798316
975446 401170 792914 272263 300770 242037 236619 334316 725899
```

### 输出

```
3 1
3 10
3 15
3 20
3 25
3 30
1 1378716
```



---

---
title: "Division + LCP (easy version)"
layout: "post"
diff: 普及+/提高
pid: CF1968G1
tag: ['二分', '哈希 hashing']
---

# Division + LCP (easy version)

## 题目描述

This is the easy version of the problem. In this version $ l=r $ .

You are given a string $ s $ . For a fixed $ k $ , consider a division of $ s $ into exactly $ k $ continuous substrings $ w_1,\dots,w_k $ . Let $ f_k $ be the maximal possible $ LCP(w_1,\dots,w_k) $ among all divisions.

 $ LCP(w_1,\dots,w_m) $ is the length of the Longest Common Prefix of the strings $ w_1,\dots,w_m $ .

For example, if $ s=abababcab $ and $ k=4 $ , a possible division is $ \color{red}{ab}\color{blue}{ab}\color{orange}{abc}\color{green}{ab} $ . The $ LCP(\color{red}{ab},\color{blue}{ab},\color{orange}{abc},\color{green}{ab}) $ is $ 2 $ , since $ ab $ is the Longest Common Prefix of those four strings. Note that each substring consists of a continuous segment of characters and each character belongs to exactly one substring.

Your task is to find $ f_l,f_{l+1},\dots,f_r $ . In this version $ l=r $ .

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.

The first line of each test case contains two integers $ n $ , $ l $ , $ r $ ( $ 1 \le l = r \le n \le 2 \cdot 10^5 $ ) — the length of the string and the given range.

The second line of each test case contains string $ s $ of length $ n $ , all characters are lowercase English letters.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .

## 输出格式

For each test case, output $ r-l+1 $ values: $ f_l,\dots,f_r $ .

## 说明/提示

In the first sample $ n=k $ , so the only division of $ aba $ is $ \color{red}a\color{blue}b\color{orange}a $ . The answer is zero, because those strings do not have a common prefix.

In the second sample, the only division is $ \color{red}a\color{blue}a\color{orange}a $ . Their longest common prefix is one.

## 样例 #1

### 输入

```
7
3 3 3
aba
3 3 3
aaa
7 2 2
abacaba
9 4 4
abababcab
10 1 1
codeforces
9 3 3
abafababa
5 3 3
zpozp
```

### 输出

```
0
1
3
2
10
2
0
```



---

---
title: "Fixing a Binary String"
layout: "post"
diff: 普及+/提高
pid: CF1979D
tag: ['贪心', '哈希 hashing']
---

# Fixing a Binary String

## 题目描述

You are given a binary string $ s $ of length $ n $ , consisting of zeros and ones. You can perform the following operation exactly once:

1. Choose an integer $ p $ ( $ 1 \le p \le n $ ).
2. Reverse the substring $ s_1 s_2 \ldots s_p $ . After this step, the string $ s_1 s_2 \ldots s_n $ will become $ s_p s_{p-1} \ldots s_1 s_{p+1} s_{p+2} \ldots s_n $ .
3. Then, perform a cyclic shift of the string $ s $ to the left $ p $ times. After this step, the initial string $ s_1s_2 \ldots s_n $ will become $ s_{p+1}s_{p+2} \ldots s_n s_p s_{p-1} \ldots s_1 $ .

For example, if you apply the operation to the string 110001100110 with $ p=3 $ , after the second step, the string will become 011001100110, and after the third step, it will become 001100110011.

A string $ s $ is called  $ k $ -proper if two conditions are met:

- $ s_1=s_2=\ldots=s_k $ ;
- $ s_{i+k} \neq s_i $ for any $ i $ ( $ 1 \le i \le n - k $ ).

For example, with $ k=3 $ , the strings 000, 111000111, and 111000 are $ k $ -proper, while the strings 000000, 001100, and 1110000 are not.

You are given an integer $ k $ , which is a divisor of $ n $ . Find an integer $ p $ ( $ 1 \le p \le n $ ) such that after performing the operation, the string $ s $ becomes $ k $ -proper, or determine that it is impossible. Note that if the string is initially $ k $ -proper, you still need to apply exactly one operation to it.

## 输入格式

Each test consists of multiple test cases. The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k \le n $ , $ 2 \le n \le 10^5 $ ) — the length of the string $ s $ and the value of $ k $ . It is guaranteed that $ k $ is a divisor of $ n $ .

The second line of each test case contains a binary string $ s $ of length $ n $ , consisting of the characters 0 and 1.

It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the value of $ p $ to make the string $ k $ -proper, or $ -1 $ if it is impossible.

If there are multiple solutions, output any of them.

## 说明/提示

In the first test case, if you apply the operation with $ p=3 $ , after the second step of the operation, the string becomes 11100001, and after the third step, it becomes 00001111. This string is $ 4 $ -proper.

In the second test case, it can be shown that there is no operation after which the string becomes $ 2 $ -proper.

In the third test case, if you apply the operation with $ p=7 $ , after the second step of the operation, the string becomes 100011100011, and after the third step, it becomes 000111000111. This string is $ 3 $ -proper.

In the fourth test case, after the operation with any $ p $ , the string becomes $ 5 $ -proper.

## 样例 #1

### 输入

```
7
8 4
11100001
4 2
1110
12 3
111000100011
5 5
00000
6 1
101001
8 4
01110001
12 2
110001100110
```

### 输出

```
3
-1
7
5
4
-1
3
```



---

---
title: "Permutation of Rows and Columns"
layout: "post"
diff: 普及+/提高
pid: CF1980E
tag: ['哈希 hashing']
---

# Permutation of Rows and Columns

## 题目描述

You have been given a matrix $ a $ of size $ n $ by $ m $ , containing a permutation of integers from $ 1 $ to $ n \cdot m $ .

A permutation of $ n $ integers is an array containing all numbers from $ 1 $ to $ n $ exactly once. For example, the arrays $ [1] $ , $ [2, 1, 3] $ , $ [5, 4, 3, 2, 1] $ are permutations, while the arrays $ [1, 1] $ , $ [100] $ , $ [1, 2, 4, 5] $ are not.

A matrix contains a permutation if, when all its elements are written out, the resulting array is a permutation. Matrices $ [[1, 2], [3, 4]] $ , $ [[1]] $ , $ [[1, 5, 3], [2, 6, 4]] $ contain permutations, while matrices $ [[2]] $ , $ [[1, 1], [2, 2]] $ , $ [[1, 2], [100, 200]] $ do not.

You can perform one of the following two actions in one operation:

- choose columns $ c $ and $ d $ ( $ 1 \le c, d \le m $ , $ c \ne d $ ) and swap these columns;
- choose rows $ c $ and $ d $ ( $ 1 \le c, d \le n $ , $ c \ne d $ ) and swap these rows.

You can perform any number of operations.

You are given the original matrix $ a $ and the matrix $ b $ . Your task is to determine whether it is possible to transform matrix $ a $ into matrix $ b $ using the given operations.

## 输入格式

The first line contains an integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The descriptions of the test cases follow.

The first line of each test case description contains $ 2 $ integers $ n $ and $ m $ ( $ 1 \le n, m \le n \cdot m \le 2 \cdot 10^5 $ ) — the sizes of the matrix.

The next $ n $ lines contain $ m $ integers $ a_{ij} $ each ( $ 1 \le a_{ij} \le n \cdot m $ ). It is guaranteed that matrix $ a $ is a permutation.

The next $ n $ lines contain $ m $ integers $ b_{ij} $ each ( $ 1 \le b_{ij} \le n \cdot m $ ). It is guaranteed that matrix $ b $ is a permutation.

It is guaranteed that the sum of the values $ n \cdot m $ for all test cases does not exceed $ 2 \cdot 10^5 $ .

## 输出格式

For each test case, output "YES" if the second matrix can be obtained from the first, and "NO" otherwise.

You can output each letter in any case (lowercase or uppercase). For example, the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive answer.

## 说明/提示

In the second example, the original matrix looks like this:

 $  \begin{pmatrix} 1 & 2 \\ 3 & 4 \end{pmatrix}  $

By swapping rows $ 1 $ and $ 2 $ , it becomes:

 $  \begin{pmatrix} 3 & 4 \\ 1 & 2 \end{pmatrix}  $

By swapping columns $ 1 $ and $ 2 $ , it becomes equal to matrix $ b $ :

 $  \begin{pmatrix} 4 & 3 \\ 2 & 1 \end{pmatrix}  $

## 样例 #1

### 输入

```
7
1 1
1
1
2 2
1 2
3 4
4 3
2 1
2 2
1 2
3 4
4 3
1 2
3 4
1 5 9 6
12 10 4 8
7 11 3 2
1 5 9 6
12 10 4 8
7 11 3 2
3 3
1 5 9
6 4 2
3 8 7
9 5 1
2 4 6
7 8 3
2 3
1 2 6
5 4 3
6 1 2
3 4 5
1 5
5 1 2 3 4
4 2 5 1 3
```

### 输出

```
YES
YES
NO
YES
YES
NO
YES
```



---

---
title: ""a" String Problem"
layout: "post"
diff: 普及+/提高
pid: CF1984D
tag: ['数论', '哈希 hashing']
---

# "a" String Problem

## 题目描述

You are given a string $ s $ consisting of lowercase Latin characters. Count the number of nonempty strings $ t \neq $ " $ \texttt{a} $ " such that it is possible to partition $ ^{\dagger} $ $ s $ into some substrings satisfying the following conditions:

- each substring either equals $ t $ or " $ \texttt{a} $ ", and
- at least one substring equals $ t $ .

 $ ^{\dagger} $ A partition of a string $ s $ is an ordered sequence of some $ k $ strings $ t_1, t_2, \ldots, t_k $ (called substrings) such that $ t_1 + t_2 + \ldots + t_k = s $ , where $ + $ represents the concatenation operation.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases.

The only line of each test case contains a string $ s $ consisting of lowercase Latin characters ( $ 2 \leq |s| \leq 2 \cdot 10^5 $ ).

The sum of $ |s| $ over all test cases does not exceed $ 3 \cdot 10^5 $ .

## 输出格式

For each test case, output a single integer — the number of nonempty strings $ t \neq $ " $ \texttt{a} $ " that satisfy all constraints.

## 说明/提示

In the first test case, $ t $ can be " $ \texttt{aa} $ ", " $ \texttt{aaa} $ ", " $ \texttt{aaaa} $ ", or the full string.

In the second test case, $ t $ can be " $ \texttt{b} $ ", " $ \texttt{bab} $ ", " $ \texttt{ba} $ ", or the full string.

In the third test case, the only such $ t $ is the full string.

## 样例 #1

### 输入

```
8
aaaaa
baba
cabacb
aaabaaa
bitset
ab
abbaaaabbb
yearnineteeneightyfour
```

### 输出

```
4
4
1
16
1
2
3
1
```



---

---
title: "Good Substrings"
layout: "post"
diff: 普及+/提高
pid: CF316G1
tag: ['哈希 hashing']
---

# Good Substrings

## 题目描述

Smart Beaver recently got interested in a new word game. The point is as follows: count the number of distinct good substrings of some string $ s $ . To determine if a string is good or not the game uses rules. Overall there are $ n $ rules. Each rule is described by a group of three $ (p,l,r) $ , where $ p $ is a string and $ l $ and $ r $ $ (l<=r) $ are integers. We’ll say that string $ t $ complies with rule $ (p,l,r) $ , if the number of occurrences of string $ t $ in string $ p $ lies between $ l $ and $ r $ , inclusive. For example, string "ab", complies with rules ("ab", $ 1 $ , $ 2 $ ) and ("aab", $ 0 $ , $ 1 $ ), but does not comply with rules ("cd", $ 1 $ , $ 2 $ ) and ("abab", $ 0 $ , $ 1 $ ).

A substring $ s[l...\ r] $ $ (1<=l<=r<=|s|) $ of string $ s=s_{1}s_{2}...\ s_{|s|} $ ( $ |s| $ is a length of $ s $ ) is string $ s_{l}s_{l+1}...\ s_{r} $ .

Consider a number of occurrences  of string $ t $ in string $ p $ as a number of pairs of integers $ l,r $ $ (1<=l<=r<=|p|) $ such that $ p[l...\ r]=t $ .

We’ll say that string $ t $ is good if it complies with all $ n $ rules. Smart Beaver asks you to help him to write a program that can calculate the number of distinct good substrings of string $ s $ . Two substrings $ s[x...\ y] $ and $ s[z...\ w] $ are cosidered to be distinct iff $ s[x...\ y]≠s[z...\ w] $ .

## 输入格式

The first line contains string $ s $ . The second line contains integer $ n $ . Next $ n $ lines contain the rules, one per line. Each of these lines contains a string and two integers $ p_{i},l_{i},r_{i} $ , separated by single spaces ( $ 0<=l_{i}<=r_{i}<=|p_{i}| $ ). It is guaranteed that all the given strings are non-empty and only contain lowercase English letters.

The input limits for scoring 30 points are (subproblem G1):

- $ 0<=n<=10 $ .
- The length of string $ s $ and the maximum length of string $ p $ is $ <=200 $ .

The input limits for scoring 70 points are (subproblems G1+G2):

- $ 0<=n<=10 $ .
- The length of string $ s $ and the maximum length of string $ p $ is $ <=2000 $ .

The input limits for scoring 100 points are (subproblems G1+G2+G3):

- $ 0<=n<=10 $ .
- The length of string $ s $ and the maximum length of string $ p $ is $ <=50000 $ .

## 输出格式

Print a single integer — the number of good substrings of string $ s $ .

## 说明/提示

There are three good substrings in the first sample test: «aab», «ab» and «b».

In the second test only substrings «e» and «t» are good.

## 样例 #1

### 输入

```
aaab
2
aa 0 0
aab 1 1

```

### 输出

```
3

```

## 样例 #2

### 输入

```
ltntlnen
3
n 0 0
ttlneenl 1 4
lelllt 1 1

```

### 输出

```
2

```

## 样例 #3

### 输入

```
a
0

```

### 输出

```
1

```



---

---
title: "Palindrome Degree"
layout: "post"
diff: 普及+/提高
pid: CF7D
tag: ['字符串', '哈希 hashing', '构造']
---

# Palindrome Degree

## 题目描述

String $ s $ of length $ n $ is called $ k $ -palindrome, if it is a palindrome itself, and its prefix and suffix of length ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF7D/f337f976991ac53405b164907ebe1f51ebb0830e.png) are $ (k-1) $ -palindromes. By definition, any string (even empty) is 0-palindrome.

Let's call the palindrome degree of string $ s $ such a maximum number $ k $ , for which $ s $ is $ k $ -palindrome. For example, "abaaba" has degree equals to $ 3 $ .

You are given a string. Your task is to find the sum of the palindrome degrees of all its prefixes.

## 输入格式

The first line of the input data contains a non-empty string, consisting of Latin letters and digits. The length of the string does not exceed $ 5·10^{6} $ . The string is case-sensitive.

## 输出格式

Output the only number — the sum of the polindrome degrees of all the string's prefixes.

## 样例 #1

### 输入

```
a2A

```

### 输出

```
1
```

## 样例 #2

### 输入

```
abacaba

```

### 输出

```
6
```



---

---
title: "Divide by three, multiply by two"
layout: "post"
diff: 普及+/提高
pid: CF977D
tag: ['搜索', '拓扑排序', '哈希 hashing']
---

# Divide by three, multiply by two

## 题目描述

有一个长度为 $n$ 的数列 $a_i$，要求你将这个数列重排成一个排列 $p_i$，使得对于任意的 $p_i(1 \le i < n)$：



- $p_i \times 2 = p_{i+1}$，或者

- 当 $p_i$ 可以被 $3$ 整除时，$p_i \div 3 = p_{i+1}$。



保证答案存在。

## 输入格式

输入包含两行。



第一行一个整数 $n(2 \le n \le 100)$，表示数列中的元素个数。  

第二行包含 $n$ 个整数 $a_1, a_2, \dots, a_n (1 \le a_i \le 10^{18})$，描述这个数列。

## 输出格式

输出应包含 $n$ 个整数 $p_1, p_2, \dots, p_n$，表示你的答案。

## 说明/提示

在第一个样例中，一种可能的合法排列为 $[9,3,6,12,4,8]$。

## 样例 #1

### 输入

```
6
4 8 6 3 12 9

```

### 输出

```
9 3 6 12 4 8 

```

## 样例 #2

### 输入

```
4
42 28 84 126

```

### 输出

```
126 42 84 28 

```

## 样例 #3

### 输入

```
2
1000000000000000000 3000000000000000000

```

### 输出

```
3000000000000000000 1000000000000000000 

```



---


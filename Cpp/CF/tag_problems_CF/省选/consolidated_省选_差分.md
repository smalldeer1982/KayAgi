---
title: "Fibonacci Additions"
layout: "post"
diff: 省选/NOI-
pid: CF1634F
tag: ['差分']
---

# Fibonacci Additions

## 题目描述

对于一个数组 $X$，有如下操作：对于区间 $[l,r]$，给 $X_l$ 加上 $F_1$，给 $X_{l+1}$ 加上 $F_2$，以此类推，并且给 $X_r$ 加上 $F_{r-l+1}$。然后将区间 $[l,r]$ 内每个数对 $MOD$ 取模。$F$ 数组是这样一个数组：$F_1=1$，$F_2=1$，当 $i>2$ 时 $F_i=F_{i-1}+F_{i-2}$。

已知两个长度相同的数组 $A$，$B$，给出若干次操作，每次操作后你需要求出取模过后的数组 $A$，$B$ 是否相等。

## 输入格式

第一行包含三个整数 $n$，$q$，$MOD$，分别表示该数组数字的个数、操作的总个数和模数。

第二行包含 $A$ 数组的 $n$ 个数。

第三行包含 $B$ 数组的 $n$ 个数。

接下来 $q$ 行，每行包含一个字符 $c$，两个数字 $l$，$r$。如果 $c$ 是`A`，表示在 $A$ 数组上操作。如果 $c$ 是`B`，表示在 $B$ 数组上操作。

## 输出格式

共有 $q$ 行，每次操作后，如果取模过后的数组 $A$，$B$ 相同，则输出一行 `YES`，否则输出一行 `NO`。

## 样例 #1

### 输入

```
3 5 3
2 2 1
0 0 0
A 1 3
A 1 3
B 1 1
B 2 2
A 3 3
```

### 输出

```
YES
NO
NO
NO
YES
```

## 样例 #2

### 输入

```
5 3 10
2 5 0 3 5
3 5 8 2 5
B 2 3
B 3 4
A 1 2
```

### 输出

```
NO
NO
YES
```



---

---
title: "Lenient Vertex Cover"
layout: "post"
diff: 省选/NOI-
pid: CF1680F
tag: ['图论', '二分图', '差分']
---

# Lenient Vertex Cover

## 题目描述

You are given a simple connected undirected graph, consisting of $ n $ vertices and $ m $ edges. The vertices are numbered from $ 1 $ to $ n $ .

A vertex cover of a graph is a set of vertices such that each edge has at least one of its endpoints in the set.

Let's call a lenient vertex cover such a vertex cover that at most one edge in it has both endpoints in the set.

Find a lenient vertex cover of a graph or report that there is none. If there are multiple answers, then print any of them.

## 输入格式

The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.

The first line of each testcase contains two integers $ n $ and $ m $ ( $ 2 \le n \le 10^6 $ ; $ n - 1 \le m \le \min(10^6, \frac{n \cdot (n - 1)}{2}) $ ) — the number of vertices and the number of edges of the graph.

Each of the next $ m $ lines contains two integers $ v $ and $ u $ ( $ 1 \le v, u \le n $ ; $ v \neq u $ ) — the descriptions of the edges.

For each testcase, the graph is connected and doesn't have multiple edges. The sum of $ n $ over all testcases doesn't exceed $ 10^6 $ . The sum of $ m $ over all testcases doesn't exceed $ 10^6 $ .

## 输出格式

For each testcase, the first line should contain YES if a lenient vertex cover exists, and NO otherwise. If it exists, the second line should contain a binary string $ s $ of length $ n $ , where $ s_i = 1 $ means that vertex $ i $ is in the vertex cover, and $ s_i = 0 $ means that vertex $ i $ isn't.

If there are multiple answers, then print any of them.

## 说明/提示

Here are the graphs from the first example. The vertices in the lenient vertex covers are marked red.

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1680F/04fc7cc460e4db0f5f28c20a639501c9ca608abf.png)

## 样例 #1

### 输入

```
4
6 5
1 3
2 4
3 4
3 5
4 6
4 6
1 2
2 3
3 4
1 4
1 3
2 4
8 11
1 3
2 4
3 5
4 6
5 7
6 8
1 2
3 4
5 6
7 8
7 2
4 5
1 2
2 3
3 4
1 3
2 4
```

### 输出

```
YES
001100
NO
YES
01100110
YES
0110
```

## 样例 #2

### 输入

```
1
10 15
9 4
3 4
6 4
1 2
8 2
8 3
7 2
9 5
7 8
5 10
1 4
2 10
5 3
5 7
2 9
```

### 输出

```
YES
0101100100
```

## 样例 #3

### 输入

```
1
10 19
7 9
5 3
3 4
1 6
9 4
1 4
10 5
7 1
9 2
8 3
7 3
10 9
2 10
9 8
3 2
1 5
10 7
9 5
1 2
```

### 输出

```
YES
1010000011
```



---

---
title: "Palisection"
layout: "post"
diff: 省选/NOI-
pid: CF17E
tag: ['字符串', '前缀和', '差分']
---

# Palisection

## 题目描述

给定一个长度为n的小写字母串。问你有多少对相交的回文子 串（包含也算相交） 。

## 输入格式

第一行是字符串长度n(1<=n<=2*10^6)，第二行字符串

## 输出格式

相交的回文子串个数%51123987

Translated by liyifeng

## 样例 #1

### 输入

```
4
babb

```

### 输出

```
6

```

## 样例 #2

### 输入

```
2
aa

```

### 输出

```
2

```



---

---
title: "Bottle Arrangement"
layout: "post"
diff: 省选/NOI-
pid: CF2041J
tag: ['动态规划 DP', '分治', '扫描线', '差分']
---

# Bottle Arrangement

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF2041J/a93240ff9d94fb996cc13c493b1008f9c0801598.png) Image generated by ChatGPT 4o.Mayaw works in a renowned Epah (aboriginal Taiwanese millet wine; Epah is the Pangcah term for aboriginal Taiwanese millet wine, named in the language of the Pangcah people, the largest Indigenous group in Taiwan) bar in the Fata'an Village. To showcase the depth of its collections, the bar has a two-row wine rack where each row can fit exactly $ n $ bottles. There are already $ n $ bottles placed on the back row of the rack, where the $ i $ -th bottle from left has height $ a_i $ . The owner of the bar has another $ n $ bottles with distinct heights $ b_1, \ldots, b_n $ that he would like Mayaw to put on the first row. To ensure that all bottles on the rack are visible, the owner requires that each bottle on the back row should not be blocked by the one put in front of it. That is, if a bottle of height $ h $ is put on the $ i $ -th spot (from left) in the first row, then $ h $ must be less than $ a_i $ . However, not all such arrangements are good for the owner. To pay tributes to the Maxi Mountain nearby, he additionally demands that the bottles in the front row should display a mountain-like shape. In particular, the heights of the bottles, when listing from left to right, should form a sequence that is first (non-strictly) increasing and then (non-strictly) decreasing.

Unfortunately, sometimes it is impossible to achieve owner's requirements. That is why Mayaw is also allowed to slightly reduce a bottle's height by removing its cap that has a height of $ 1 $ . In other words, after the removal of the cap, the height of the bottle decreases by exactly $ 1 $ . Of course, exposing the Epah inside the bottle to the open air is detrimental to its quality, and therefore it is desirable to remove as few bottle caps as possible.

Can you help Mayaw determine the minimum number of caps needed to be removed so that he can arrange the bottles in a way that satisfies the owner's requirements? Note that the positions of the bottles in the back row are fixed and Mayaw is not allowed to modify them.

## 输入格式

The first line contains an integer $ n $ which represents the number of bottles in each row. The second line contains $ n $ integers $ a_1, \ldots, a_n $ , the height of the bottles in the back row. The third line contains $ n $ distinct integers $ b_1, \ldots, b_n $ , the height of the bottles in the front row.

- $ 1 \leq n \leq 5 \times 10^5 $
- $ 1 \leq a_i, b_i \leq 10^9 $
- All $ b_i $ 's are distinct.

## 输出格式

Output the minimum number of bottle caps needed to be removed so that Mayaw can arrange the bottles in the desired way. If it is impossible to achieve that (regardless of the number of caps removed), output -1 instead.

## 样例 #1

### 输入

```
5
2 4 6 5 4
1 2 3 4 5
```

### 输出

```
0
```

## 样例 #2

### 输入

```
5
2 3 6 5 4
1 2 3 4 5
```

### 输出

```
0
```

## 样例 #3

### 输入

```
5
6 2 6 6 6
1 2 3 4 5
```

### 输出

```
1
```

## 样例 #4

### 输入

```
5
7 2 7 7 7
1 3 4 5 6
```

### 输出

```
-1
```

## 样例 #5

### 输入

```
10
18 20 16 18 16 10 13 6 4 10
19 10 9 15 4 16 6 12 3 17
```

### 输出

```
4
```



---

---
title: "Serval and Colorful Array (Hard Version)"
layout: "post"
diff: 省选/NOI-
pid: CF2085F2
tag: ['贪心', '枚举', '差分']
---

# Serval and Colorful Array (Hard Version)

## 题目描述

这是该问题的困难版本。两个版本的区别在于此版本中 $n \leq 4 \cdot 10^5$。仅当您解决了该问题的所有版本时才能进行 hack。

Serval 有一个魔法数 $k$（$k \geq 2$）。我们称数组 $r$ 为 colorful 当且仅当：
- $r$ 的长度为 $k$，且
- $1$ 到 $k$ 之间的每个整数在 $r$ 中恰好出现一次。

给定一个由 $n$ 个介于 $1$ 到 $k$ 的整数组成的数组 $a$。保证 $1$ 到 $k$ 之间的每个整数在 $a$ 中至少出现一次。您可以对 $a$ 执行以下操作：
- 选择一个下标 $i$（$1 \leq i < n$），然后交换 $a_i$ 和 $a_{i+1}$。

求使得 $a$ 中至少存在一个 colorful 子数组$^{\text{∗}}$所需的最小操作次数。可以证明在题目约束下这总是可行的。

$^{\text{∗}}$数组 $b$ 是数组 $a$ 的子数组，当且仅当 $b$ 可以通过从 $a$ 的开头和结尾删除若干（可能为零或全部）元素得到。

## 输入格式

每个测试包含多个测试用例。第一行输入测试用例数 $t$（$1 \le t \le 1000$）。接下来描述每个测试用例。

每个测试用例的第一行包含两个整数 $n$ 和 $k$（$2 \leq k \leq n \leq 4 \cdot 10^5$）——数组 $a$ 的长度和 Serval 的魔法数。

第二行包含 $n$ 个整数 $a_1, a_2, \ldots, a_n$（$1 \leq a_i \leq k$）——数组 $a$ 的元素。保证 $1$ 到 $k$ 之间的每个整数在 $a$ 中至少出现一次。

保证所有测试用例的 $n$ 之和不超过 $4 \cdot 10^5$。

## 输出格式

对于每个测试用例，输出一个整数 —— 使得 $a$ 中至少存在一个 colorful 子数组所需的最小操作次数。

## 说明/提示

第一个测试案例中，由于子数组 $[a_1, a_2] = [1, 2]$ 和 $[a_2, a_3] = [2, 1]$ 已经是 colorful 的，因此无需执行任何操作。答案为 $0$。

第二个测试案例中，我们可以交换 $a_1$ 和 $a_2$ 得到 $[1, \underline{2, 1, 3}, 1, 1, 2]$，其中包含一个 colorful 子数组 $[a_2, a_3, a_4] = [2, 1, 3]$。由于原数组初始时没有 colorful 子数组，因此答案为 $1$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
3 2
1 2 1
7 3
2 1 1 3 1 1 2
6 3
1 1 2 2 2 3
6 3
1 2 2 2 2 3
10 5
5 1 3 1 1 2 2 4 1 3
9 4
1 2 3 3 3 3 3 2 4
```

### 输出

```
0
1
2
3
4
5
```



---

---
title: "Password"
layout: "post"
diff: 省选/NOI-
pid: CF79D
tag: ['状态合并', '最短路', '差分']
---

# Password

## 题目描述

Finally Fox Ciel arrived in front of her castle!

She have to type a password to enter her castle. An input device attached to her castle is a bit unusual.

The input device is a $ 1×n $ rectangle divided into $ n $ square panels. They are numbered $ 1 $ to $ n $ from left to right. Each panel has a state either ON or OFF. Initially all panels are in the OFF state. She can enter her castle if and only if $ x_{1} $ -th, $ x_{2} $ -th, $ ... $ , $ x_{k} $ -th panels are in the ON state and other panels are in the OFF state.

She is given an array $ a_{1} $ , $ ... $ , $ a_{l} $ . In each move, she can perform the following operation: choose an index $ i $ ( $ 1<=i<=l $ ), choose consecutive $ a_{i} $ panels, and flip the states of those panels (i.e. ON $ → $ OFF, OFF $ → $ ON).

Unfortunately she forgets how to type the password with only above operations. Determine the minimal number of operations required to enter her castle.

## 输入格式

The first line contains three integers $ n $ , $ k $ and $ l $ ( $ 1<=n<=10000,1<=k<=10,1<=l<=100 $ ), separated by single spaces.

The second line contains $ k $ integers $ x_{1} $ , ..., $ x_{k} $ ( $ 1<=x_{1}&lt;x_{2}&lt;...&lt;x_{k}<=n $ ), separated by single spaces.

The third line contains $ l $ integers $ a_{1} $ , ..., $ a_{l} $ ( $ 1<=a_{i}<=n $ ), separated by single spaces. It is possible that some elements of the array $ a_{i} $ are equal value.

## 输出格式

Print the minimal number of moves required to type the password. If it's impossible, print -1.

## 说明/提示

One possible way to type the password in the first example is following: In the first move, choose 1st, 2nd, 3rd panels and flip those panels. In the second move, choose 5th, 6th, 7th, 8th, 9th panels and flip those panels.

## 样例 #1

### 输入

```
10 8 2
1 2 3 5 6 7 8 9
3 5

```

### 输出

```
2

```

## 样例 #2

### 输入

```
3 2 1
1 2
3

```

### 输出

```
-1

```



---

---
title: "Coprime Arrays"
layout: "post"
diff: 省选/NOI-
pid: CF915G
tag: ['数学', '前缀和', '差分']
---

# Coprime Arrays

## 题目描述

#### 题意：

我们称一个大小为 $n$ 的数组 $a$ 互质，当且仅当 $gcd(a_1,a_2,\cdots,a_n)=1$，$gcd$ 是最大公约数的意思。

给定 $n,k$，对于每个 $i$ $(1\le i\le k)$，你都需要确定这样的数组的个数——长度为 $n$ 的互质数组 $a$ ，满足对每个 $j$ $(1\le j\le n)$，都有 $1\le a_j\le i$。

答案可能非常大，请对 $10^9+7$ 取模。

## 输入格式

只有一行，两个数 $n,k$ $(1\le n,k\le 2\cdot10^6)$，分别表示数组的大小和数组元素大小的上限。

## 输出格式

为了降低输出的时间，你需要对输出进行如下处理：

把 $i$ 的答案（对 $10^9+7$ 取模后）记作 $b_i$。你需要输出 $\sum_{i=1}^{k} (b_i\oplus i)$，再对 $10^9+7$ 取模。

这里 $\oplus$ 表示按位异或，在 c++ 和 Java 中写作 ```^```，在 Pascal 中写作 ```xor```。

## 说明/提示

因为互质数组的数量比较多，我们只列出不互质的：

当 $i=1$ 时，唯一的数组就是互质的，$b_1=1$。

当 $i=2$ 时，数组 $[2,2,2]$ 不是互质的，$b_2=7$。

当 $i=3$ 时，数组 $[2,2,2],[3,3,3]$ 不是互质的，$b_3=25$。

当 $i=4$ 时，数组 $[2,2,2],[3,3,3],[2,2,4],[2,4,2],[2,4,4],[4,2,2],[4,2,4],[4,4,2],[4,4,4]$ 不是互质的，$b_4=55$。

Translated by 小粉兔

## 样例 #1

### 输入

```
3 4

```

### 输出

```
82

```

## 样例 #2

### 输入

```
2000000 8

```

### 输出

```
339310063

```



---

---
title: "Simple Cycles Edges"
layout: "post"
diff: 省选/NOI-
pid: CF962F
tag: ['搜索', '枚举', '差分']
---

# Simple Cycles Edges

## 题目描述

You are given an undirected graph, consisting of $ n $ vertices and $ m $ edges. The graph does not necessarily connected. Guaranteed, that the graph does not contain multiple edges (more than one edges between a pair of vertices) or loops (edges from a vertex to itself).

A cycle in a graph is called a simple, if it contains each own vertex exactly once. So simple cycle doesn't allow to visit a vertex more than once in a cycle.

Determine the edges, which belong to exactly on one simple cycle.

## 输入格式

The first line contain two integers $ n $ and $ m $ $ (1 \le n \le 100\,000 $ , $ 0 \le m \le \min(n \cdot (n - 1) / 2, 100\,000)) $ — the number of vertices and the number of edges.

Each of the following $ m $ lines contain two integers $ u $ and $ v $ ( $ 1 \le u, v \le n $ , $ u \neq v $ ) — the description of the edges.

## 输出格式

In the first line print the number of edges, which belong to exactly one simple cycle.

In the second line print the indices of edges, which belong to exactly one simple cycle, in increasing order. The edges are numbered from one in the same order as they are given in the input.

## 样例 #1

### 输入

```
3 3
1 2
2 3
3 1

```

### 输出

```
3
1 2 3 

```

## 样例 #2

### 输入

```
6 7
2 3
3 4
4 2
1 2
1 5
5 6
6 1

```

### 输出

```
6
1 2 3 5 6 7 

```

## 样例 #3

### 输入

```
5 6
1 2
2 3
2 4
4 3
2 5
5 3

```

### 输出

```
0


```



---


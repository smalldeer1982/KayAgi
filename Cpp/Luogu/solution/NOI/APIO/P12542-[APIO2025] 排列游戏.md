# [APIO2025] 排列游戏

## 题目背景

请注意：本题只支持 C++ 语言提交；你不需要也不应该实现 `main` 函数；你需要在程序开头添加如下内容：

```cpp
#include <vector>

int Alice(int m, int e, std::vector<int> u, std::vector<int> v, int n, std::vector<int> p);

int Bob(std::vector<int> t);
```

## 题目描述

Alice 和 Bob 是童年时代的朋友，他们喜欢玩智力游戏。今天，他们在玩一个关于图的新游戏。

游戏中包含一个连通图，具有 $m$ 个顶点，编号为 $0$ 到 $m-1$，以及 $e$ 条边，编号为 $0$ 到 $e-1$。第 $i$ 条边连接顶点 $u[i]$ 和 $v[i]$。

游戏中还包含一个长度为 $n$ 的排列 $p[0], p[1], \ldots, p[n-1]$，其中 $m \leq n$。排列是一个数组，其中从 $0$ 到 $n-1$ 的每个数字以某种顺序仅出现一次。排列 $p$ 的分数是满足 $p[i] = i$ 的下标 $i$ 的数量。

游戏最多持续 $10^{100}$ 个回合。在每个回合中，都会发生以下情况：

1. 如果 Alice 决定结束游戏，游戏终止。
2. 否则，Alice 选择一组两两不同的下标 $t[0], t[1], \ldots, t[m-1]$，满足 $0 \leq t[i] < n$。请注意，游戏不要求 $t[0] < t[1] < \ldots < t[m-1]$。
3. Bob 选择一个图中边的下标 $0 \leq j < e$，并交换 $p[t[u[j]]]$ 和 $p[t[v[j]]]$。

Alice 希望能最大化排列的最终分数而 Bob 希望最小化排列的最终分数。

你的任务是帮助 Alice，与由评测程序模拟的 Bob 进行游戏。

定义一局游戏的“最优分数”为当 Alice 和 Bob 都采用最优策略进行游戏时最终得到的排列的分数。

你需要求出本局游戏的最优分数，然后与 Bob 进行游戏，且需要在若干轮后至少达到最优分数。

请注意：你实现的 Alice 的策略应当是普适性的，能够处理 Bob 可能采用的各种策略，即使 Bob 采用的策略可能并非最优。

### 实现细节

你要实现以下函数：

```cpp
int Alice(int m, int e, std::vector<int> u, std::vector<int> v, int n, std::vector<int> p)
```

- `m`: 图中顶点个数。
- `e`: 图中边的数量。
- `u` 和 `v`: 长度为 `e` 的数组，描述图中的边。
- `n`: 排列的长度。
- `p`: 长度为 `n` 的数组，描述排列。

该函数恰好被调用一次。
该函数应该返回一个整数，即游戏的最后分数，假设 Alice 和 Bob 都以最优策略玩游戏。

在该函数中，你可以调用以下函数：

```cpp
int Bob(std::vector<int> t)
```

- `t`: 长度为 $m$ 的数组，包含一组两两不同的下标，满足 $0 \leq t[i] < n$ 且对于任意 $i \neq j$ 均有 $t[i] \neq t[j]$。
- 该函数返回一个整数 $j$，满足 $0 \leq j < e$。
- 该函数可以被调用多次。

## 说明/提示

### 例子

考虑以下调用：

```cpp
Alice(5, 6, [4, 0, 3, 1, 4, 2], [2, 2, 0, 2, 0, 3], 10, [8, 2, 7, 6, 1, 5, 0, 9, 3, 4])
```

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/lo1c6nt9.png)

$p$ 的初值为 $[8, 2, 7, 6, 1, 5, 0, 9, 3, 4]$。

给定以上约束条件，我们可以证明排列的最优分数为 1。

假设，Alice 做了以下 4 次操作：

| 给 Bob 的参数 $t$ | Bob 返回的值 | $p$ 对应的下标 | Bob 交换后的 $p$ |
|------------------|-------------|----------------|------------------|
| [3, 1, 5, 2, 0]  | 5           | 5, 2           | [8, 2, 5, 6, 1, 7, 0, 9, 3, 4] |
| [9, 3, 7, 2, 1]  | 0           | 1, 7           | [8, 9, 5, 6, 1, 7, 0, 2, 3, 4] |
| [5, 6, 7, 8, 9]  | 1           | 5, 7           | [8, 9, 5, 6, 1, 2, 0, 7, 3, 4] |
| [7, 5, 2, 3, 6]  | 3           | 5, 2           | [8, 9, 2, 6, 1, 5, 0, 7, 3, 4] |

注意 Alice 和 Bob 所做的操作不一定是最优的。上面显示的操作纯粹是为了演示。另外，注意到 Alice 实际上可以在一开始就结束游戏，因为最开始的排列分数已经达到了最优分数 1。

在 Alice 做了上述所有操作后，排列的实际分数为 $3$（$p[2] = 2$, $p[5] = 5$, $p[7] = 7$）。

函数 `Alice()` 最后返回值为 1，即排列的最优分数。

请注意，即使 Alice 通过与 Bob 玩游戏获得了分数 3，但如果函数 `Alice()` 的返回值是 3 而不是 1，你将获得 0 分。

### 约束条件

- $2 \leq m \leq 400$
- $m - 1 \leq e \leq 400$
- $0 \leq u[i], v[i] < m$
- $m \leq n \leq 400$
- $0 \leq p[i] < n$

图是连通的，并且没有自环和重边。
$p$ 是一个排列，即对任意 $i \neq j$, $p[i] \neq p[j]$。

### 子任务

1. (6 分) $m = 2$
2. (6 分) $e > m$
3. (10 分) $e = m - 1$
4. (24 分) $e = m = 3$
5. (24 分) $e = m = 4$
6. (30 分) $e = m$

对于每个子任务，你可以获得部分分数。设 $r$ 是 $\frac{k}{n}$ 在某个子任务的所有测试用例中的最大比值，其中 $k$ 是回合数（即对 `Bob()` 的调用次数）。那么，你在该子任务的得分为该子任务的满分乘以以下数字：

| 条件         | 乘数                  |
|--------------|-----------------------|
| $12 \leq r$  | 0                     |
| $3 < r < 12$ | $1 - \log_{10}(r - 2)$ |
| $r \leq 3$   | 1                     |

特别地，如果在 $3n$ 个回合内解决问题，则该子任务将获得满分。使用超过 $12n$ 个回合将导致该子任务获得 0 分（显示为 output isn't correct）。

### 评测程序示例

评测程序示例按以下格式读取输入：

- 第 1 行: $m\,e$
- 第 $2 + i$ 行 $(0 \leq i \leq e - 1)$: $u[i]\, v[i]$
- 第 $2 + e$ 行: $n$
- 第 $3 + e$ 行: $p[0]\, p[1]\, \ldots\, p[n - 1]$

评测程序示例按以下格式打印你的答案：

- 第 1 行: 最后排列 $p$
- 第 2 行: `Alice()` 的返回值
- 第 3 行: 最后排列的实际得分
- 第 4 行: 回合数

# 题解

## 作者：liuzhangfeiabc (赞：20)

题目大意：给定一个长为 $n$ 的排列和一张 $m$ 个点 $e$ 条边的简单连通图。每次你可以在图上每个点设置一个 $0\sim n-1$、两两不同的权值发给交互库，交互库会从图中选择一条边，然后取出两个端点上的权值，作为排列的两个下标并进行交换。你可以随时停止游戏。

你要先求出：在两人的最优策略下，最终排列有多少个数归位（即 $p[i]=i$），你要让这个值最大化，交互库要让它最小化；并跟交互库玩这个游戏，在 $3n$ 次操作内至少达到这个最优解。

数据范围：$m\le n\le 400$。

**Warning：本题思维复杂性较高，阅读本题解之前请确保你处于大脑清醒的状态。**

先看一些简单的 Case:

### $m=2$

相当于你可以每次直接交换排列的两个位置，那么就非常简单了：你只需要贪心地每次把一个数归位，至多 $n-1$ 次操作就可以让整个排列全部归位。

### $e>m$

这是本题的第一个重要的观察：为什么 $e>m$ 这个看起来很复杂的情况会放在第二个子任务而且只有 $6$ 分？

答：此时你无能为力，初始排列直接就是最优解。

为什么？我们直接证明一个更强的结论：只要图中有 $\ge 3$ 度的点，你就没有任何办法了。

考虑图中一个点 $x$ 被设置为权值 $t[x]$，如果选择的一条边与 $x$ 相连，什么情况下会对答案产生正的贡献？只有两种情况：将 $t[x]$ 这个数从别的位置交换回来；或者将 $p[t[x]]$ 这个数交换到了它正确的位置上去。

由于图中所有的点权是两两不同的，因此上述两种情况在一个点 $x$ 处都至多只有一条边满足。换句话说对于任意点而言，其相连的边中至多只有两条会让答案增加。

因此，如果图中存在 $\ge 3$ 度的点，交互库就一定能选择其一条邻边，使得操作之后答案严格不增。因此你的一切努力都是徒劳的。

那么问题来了：一张简单连通图没有 $\ge 3$ 度的点，有哪几种可能呢？只有两种可能：链或环。

此外，容易看出当未归位的点数不超过 $m-1$ 时，也无法更进一步了，因为将已经归位的点加入图中是没有意义的。这作为平凡的情形，后文中将不再讨论。

### $e=m-1$

链的情况，我们开始进行一些真正接近题目本质的分析。

对于任意排列 $p$ 而言，可以建一张 $n$ 个点的图，从每个点 $i$ 向 $p[i]$ 连边，那么得到的一定形如若干个环。其中大小为 $1$ 的环表示已经归位的点，我们不去管它；考虑其它的环我们怎么处理。

假设我们交换了两个位置 $(i,j)$，实际上就是在图中交换了这两个点的出边，对环结构的影响如下：

- 如果 $i,j$ 原本不在同一个环上，这次交换会将两个环直接合并；
- 如果 $i,j$ 原本在同一个环上，假设环大小为 $p$，两点在环上的距离为 $q$，则这次交换会将环拆分为两个环，大小分别为 $q$ 和 $p-q$。
- 特别地，交换同一个环上相邻的两个位置会增加一个归位的点（因为多了一个大小为 $1$ 的环）。

![](https://cdn.luogu.com.cn/upload/image_hosting/u2fo8ozd.png)

然后我们有如下几种操作：

- “强制归位”：对于一个大小 $\ge m$ 的环，只需要顺次选择环上 $m$ 个相邻的点，交互库就必然要选择两个相邻点交换使得多一个点归位；
- “强制合并”：对于两个大小加起来 $\ge m$ 的环，可以在一个环上顺次选一些相邻的点，再在另一个环上顺次选一些相邻的点，这样交互库就要么选择一个环上的相邻两个点（这会让一个点归位）要么选择两个环上的点（这会合并这两个环）。这一操作也可以推广到多个环上，只要这些环大小之和 $\ge m$，就逼迫交互库选择其中相邻两个环进行合并。

![](https://cdn.luogu.com.cn/upload/image_hosting/41vlemv6.png)

基于这两种操作我们可以轻松解决链的情况：只需要先将所有环全都合并起来，再每次强制归位一个点，就能操作到仅剩 $m-1$ 个点未归位。

### $e=m$

接下来是环的情况，在展开更详细的分类讨论之前，首先要说明环相对于链的一些不同之处。

- 对于“强制合并”影响不大，只不过在多个环时让交互库多了一种将首尾两个环合并的选择；
- 然而对于“强制归位”的影响是关键的，因为这相当于在链的情形中增加了允许交互库选择链的首尾两个点，这会导致环断成两段而不是恰好拆出一个点。因此如果你还想达到强制归位的效果，就只能在大小**恰好等于** $m$ 的环上执行。
- 那么遇到更大的环该怎么办？为此我们必须开发出一种“强制拆分”操作：对于某个你想要的拆分距离 $d$，如果我们能在当前这个环上选取一系列点，使得（包括首尾在内，下同）相邻两个点的距离要么是 $1$ 要么是 $d$，那么交互库为了不增加归位的点数就必须选择两个间距为 $d$ 的点。如下图就是 $d=2$ 的情形，分为 $m$ 是偶数/奇数两种情形，对应的选取序列分别为 $0, 2, 4, \dots, m-2, m-1, m-3, \dots, 1$ 和 $0, 2, 4, \dots, m-1, m-2, m-4, \dots,1$。需要注意的是，这样的操作并不是我们随心所欲的，需要根据 $m,d$ 和具体的环大小构造方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/dglwd56b.png)

再讨论一些比较平凡的界：

- 对于剩余点数小于 $m$ 的情形，显然没法继续操作了；
- 对于剩余点数恰为 $m$ 的情形，可以将所有环合并成一个之后归位一次，得到剩余 $m-1$ 个点即为最优；
- 对于剩余点数恰为 $m+1$ 的情形，也没法更进一步了，因为想要更进一步就必须先搞出大小为 $m$ 的环，但若果真如此那么剩下一个点已经自动归位了，于是就矛盾了。

那么问题来了：当剩余点数更多时，是否总能操作到只剩 $m+1$ 个点？我们需要进一步分类讨论。

### $e=m=\texttt{奇数}$

先看 $m$ 是奇数的情形。基于上面的“强制拆分”操作，我们知道一个大小为 $m+2, m+4, \dots$ 的环总能通过每次拆下两个点最终达到 $m$，从而可以进行一次归位。也就是说任何大小至少为 $m$ 的奇环都能带来 $1$ 的贡献。

那么偶环呢？很遗憾，对于偶环我们又无能为力了。具体而言，考虑当前排列里的奇环总数（包括大小为 $1$ 的奇环），我们可以说明这个数量是无法增加的。

证明很简单：如果想使得奇环的数量增加，唯有将一个偶环拆分成两个奇环。然而如果我们将偶环进行间隔二染色，再选出 $m$ 个点填入图中时，你会发现一定有相邻两个点是同色的。于是交互库只要选这两个点，就会将原先的偶环断成两个偶环。

基于上述分析，当前排列中奇环的数量就成了答案的上界。对于 $m=3$ 的情形，我们可以直接对所有的奇环每次进行 $-2$ 操作，直到变成 $3$ 之后进行一次归位，就达到了这一最优解。

然而，当 $m$ 是更大的奇数时，可能面临这样的问题：有一系列小于 $m$ 的奇环，我们不能直接对其进行归位操作，只能先与其他环合并；然而合并两个奇环的操作是我们必须尽量避免的，因为这会使得答案上界 $-2$。

所以我们可以优先取出一个最大的奇环，首先考虑将其与所有的偶环合并，直到大小不小于 $m$ 为止；若合并上所有偶环之后大小仍然小于 $m$，我们就不得不从大到小选取若干个奇环进行合并，直到合并出不小于 $m$ 的奇环为止。

注意到一旦合并出了第一个不小于 $m$ 的奇环，后续就不再需要进行两个奇环之间的合并了，因为对其进行拆分和归位操作之后会得到大小为 $m-1$ 的偶环，在操作其他奇环时可以先将其与这个 $m-1$ 合并，以得到足够大的奇环执行后续操作；操作最终又会得到一个 $m-1$ ，循环使用。

于是我们就完成了 $m$ 为奇数的情形，注意到操作次数显然是够用的。

### $e=m=4$

来到了 $m$ 是偶数的情形，为了更加清晰，我们先看一下 $m=4$ 的简单情形。

此时的理论上限是剩余 $5$ 个点，这是可以达到的，接下来将给出一系列操作：

- 对于 $4$ 元环可以归位一个点；
- 对于 $\ge 6$ 的环，可以从中拆下来一个 $4$ 元环，选取点的序列为 $0, 1, 5, 4$；
- 对于 $5$ 元环，不能直接进行操作，必须先与任意一个环合并；
- 对于两个 $2$，可以合并成一个 $4$；
- 对于两个 $3$，可以合并成一个 $6$；
- 尽量不要合并 $2$ 和 $3$，因为得到 $5$ 是不优的。

请注意上面的第二个操作，它可以扩展为一般的偶数 $m$：对于任意 $\ge {3m \over 2}$ 的环而言，都可以拆出一个 $m$，选取点的序列为 $0, 1, 2, \dots, {m \over 2} - 1, {3m \over 2} - 1, {3m \over 2} - 2, \dots, m$。如下图分别为 $m=4, 6$ 的情形。

![](https://cdn.luogu.com.cn/upload/image_hosting/ntax6v97.png)

容易看出，只要按照上述操作序列依次执行，除合并 $2$ 和 $3$ 外，每 $3$ 步之内一定能进行一次归位操作（可以自行验证）。因此只要我们不去合并 $2$ 和 $3$（这在剩余点数多于 $5$ 时总是可以的），就能一直操作下去直到只剩 $5$ 个点为止，操作次数也是够用的。

### $e=m=\texttt{偶数}$

终于到了最复杂的情形，我们首先要看一下 $m$ 是一般的偶数相比 $m=4$ 时有哪些变化：最重要的变化是“强制拆分一个 $m$”只能适用于 $\ge {3m \over 2}$ 的环（至少我并没有想到直接的适用于更小的环的拆分方案），因此我们需要重新设计将大小在 $m+2 \sim {3m \over 2}-1$ 之间的环拆分成 $m$ 的方案。

- 对于大小为 $m+2,m+4, \dots$ 的环，仍然可以每次拆分一个 $2$ 出来，直到变成 $m$；
- 对于大小为 $m+3,m+5, \dots$ 的环，每次拆一个 $2$ 只能最终达到 $m+3$，再拆成 $m+1$ 是没有意义的。因此我们必须要设计从 $m+3$ 直接拆出一个 $3$ 的策略。

具体方法是对 $m$ 按照 $\mod 6$ 分类讨论：

- $m \mod 6=0: 0, 1, 2, 5, 8, \dots, m-1, m-2, m-3, m-6, m-5, m-8, m-9, \dots, 4, 3$；
- $m \mod 6=2: 0, 1, 4, 7, \dots, m-1, m-2, m-3, m-6, m-5, m-8, \dots, 2, 3$；
- $m \mod 6=4: 0, 3, 6, \dots, m-1, m-2, m-3, m-6, m-5, m-8, \dots, 2, 1$。

分类讨论看着很繁琐，其实本质都是同一种方案：先 $3$ 个 $3$ 个往前跳，再按照 $-1, -3, +1, -3, \dots$的模式往回跳。下图中展示了 $m=6,8,10$ 的情形。另外，这种拆出 $3$ 个点的构造对于更大的环而言也是适用的。

![](https://cdn.luogu.com.cn/upload/image_hosting/w7lob9zd.png)

再加上对小环的合并操作，我们便可以达到剩余 $m+1$ 的最优解。但操作次数是否满足要求？

容易想到的操作序列如下：

- 如果存在一个 $m$，就进行一次归位；
- 如果有两个环大小之和为 $m$，合并之；
- 如果最大环 $\ge {3m \over 2}$，拆出一个 $m$；
- 如果最大环 $\ge m+2$ 但 $< {3m \over 2}$，拆出一个 $2$ 或 $3$；
- 如果最大的环 $=m+1$，就将其随便合并一个环（例如次大环）；
- 如果最大的环 $<m$，就从大到小开始合并；例外是如果它与次大环加起来等于 $m+1$，就去考虑合并更小的环，除非别无选择。

然而，这样实际上并不能达到 $3n$ 的操作次数限制！考虑当前剩余的一系列环为 $m-1, 2, 2, \dots, 2$，将执行如下一系列操作：

- 将 $m-1$ 和 $2$ 合并为 $m+1$；
- 将 $m+1$ 和 $2$ 合并为 $m+3$；
- 将 $m+3$ 拆分为 $m$ 和 $3$；
- 对 $m$ 执行一次归位变为 $m-1$；
- 将 $m-1$ 和 $3$ 合并为 $m+2$；
- 将 $m+2$ 拆分为 $m$ 和 $2$；
- 对 $m$ 执行一次归位变为 $m-1$。

总共使用 $7$ 次操作进行了两次归位，除了 $2$ 环少了一个外其他均不变，可知这样总的操作次数将达到 $3.5n$ 级别。

怎么办？容易发现这一操作序列即使处理 $m=4$ 也是不行的，需要回看当时是怎样避开这一问题的：现在相当于每次将 $3$ 和 $2$ 合并，然而这是我们不希望的，而当时是通过将两个 $2$ 合并来避免了这一点。

这启发我们如果场上有 $m-2$，就可以将其与 $2$ 合并从而直接得到 $m$。然而 $m-1$ 是容易得到的（$m$ 进行归位一次之后就天然得到 $m-1$），但 $m-2$ 却并不容易得到。

再回看 $m=4$ 的情形，发现可以通过操作制造 $2$：将两个 $3$ 合并得到 $6$，再将 $6$ 拆分成 $4$ 和 $2$。

因此，对于更大的 $m$，如果场上有两个 $m-1$，就可以先合并得到 $2m-2$，再通过一次拆分得到 $m$ 和 $m-2$。这也正是这道题的最后一个关键处。而两个 $m-1$ 怎么得到？当然是从最初的一系列小环合并而来（或从更大的环上拆下来）。

总结上述的全过程，可以得到如下操作流程：

- 如果有 $m$，归位之；
- 如果有两个环大小之和为 $m$，合并之；
- 如果最大环 $\ge {3m \over 2}$，拆出一个 $m$；
- 如果最大环 $\ge m+2$ 但 $< {3m \over 2}$，拆出一个 $2$ 或 $3$；
- 如果最大环 $=m+1$，随便找一个环（如次大环）合并；
- 如果最大环 $=m-1$ 且次大环 $=m-1$，合并二者；
- 如果最大环 $=m-1$ 且次大环 $=m-2$，找出第三大环：如果为 $2$，则与 $m-2$ 合并（避免与 $m-1$ 合并得到 $m+1$），否则与 $m-1$ 合并；
- 如果最大环 $=m-1$ 且次大环 $<m-2$，就从次大环开始顺次合并（除非次大环与所有更小的环加起来已经不到 $m$ 了，就将最大环与次大环合并）；
- 如果最大环 $<m-1$，就从最大环开始顺次合并。

分析总的操作次数：

我们要用 $3n$ 步归位不超过 $n-m$ 个点，因此除了 “每 $3$ 步归位一个点”以外，还有 $3m$ 步的冗余。

首先是最开始要合并出两个 $m-1$，即使最初所有的环全是 $2$，这一步的额外开销不会超过 $m$；

其次进行主操作流程，直至剩余 $2m$ 个点以前一直能维持“（均摊下来）每 $3$ 步归位一个点”：只需额外分析当 $m-1$ 合并上一个不太大的环导致要进行一系列拆 $2, 3$ 的操作，注意到这每一个 $2$ 或 $3$ 都能在后续步骤中省下来一步（例如 $m-2$ 和 $2$ 仅需两步就能归位一个点；$m-1, m-2, 3$ 可以通过 $5$ 步归位两个点），因此之前拆出来的操作都能被均摊掉；

最后是剩余 $2m$ 个点之后，必须回滚到之前的操作流程。采用回先前 $3.5$ 步归位一个点的流程，加上可能有额外的 $m \over 2$ 步拆分 $2, 3$ 的操作，总的额外开销不超过 $m$。

综上，在“每 $3$ 步归位一个点”以外，总的额外开销不会超过 $2m$，于是本题终于彻底做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int Bob(std::vector<int> t);
int m,e,n,nwas,cnt;
vector<int> u,v,p;
vector<int> vis,deg;
vector<vector<int>> cycles;
vector<int> cyc_id, cyc_size, cyc_pos; // 一个点所在的环编号、大小以及它在环上的位置
vector<int> cyc_list,cyc_odd,cyc_even; // 按从大到小的顺序排序后的所有环，后面两个是所有的奇环和偶环
vector<int> dfn,map_g; // dfn是图上节点编号的映射,map_g是dfn的逆
vector<vector<int>> edges; // 图上的边
vector<int> oper,oper_tmp; // 操作序列
void get_cycle(){ // 生成排列里所有的环
    cycles.clear();
    cyc_list.clear();
    cyc_odd.clear();
    cyc_even.clear();
    nwas = 0;
    memset(vis.data(),0,sizeof(int) * n);
    for(int i = 0;i < n;++i) if(!vis[i]){
        if(i == p[i]){ // 把已经归位的去掉
            ++nwas;
            continue;
        }
        vector<int> q; q.clear(); q.push_back(i); vis[i] = 1;
        for(int j = p[i];!vis[j];j = p[j]){
            q.push_back(j); vis[j] = 1;
        }
        int cycle_id = cycles.size(); // 当前环的编号
        cyc_list.push_back(cycle_id);
        for(int j = 0;j < q.size();++j){
            cyc_id[q[j]] = cycle_id; // 所在环编号
            cyc_size[q[j]] = q.size(); // 所在环大小
            cyc_pos[q[j]] = j; // 所在环上的位置
        }
        cycles.push_back(q);
    }
    // 按环长排序
    sort(cyc_list.begin(),cyc_list.end(),[=](int x,int y){return cycles[x].size() > cycles[y].size();}); 
    // 将环按奇偶分类
    for(int i = 0;i < cyc_list.size();++i){
        int x = cyc_list[i];
        if(cycles[x].size() % 2) cyc_odd.push_back(x);
        else cyc_even.push_back(x);
    }
}
int nwdfn;
void dfs(int x){
    map_g[x] = nwdfn;
    dfn[nwdfn] = x;
    ++nwdfn;
    for(int i = 0;i < edges[x].size();++i){
        int y = edges[x][i];
        if(map_g[y] != -1) continue;
        dfs(y);
    }
}
bool chk_deg(){
    oper.resize(m); memset(oper.data(),0,sizeof(int) * m);
    oper_tmp.resize(m); memset(oper_tmp.data(),0,sizeof(int) * m);
    deg.resize(m); memset(deg.data(),0,sizeof(int) * m);
    edges.resize(m);
    for(int i = 0;i < m;++i) edges[i].clear();
    for(int i = 0;i < e;++i){
        ++deg[u[i]];
        ++deg[v[i]];
        edges[u[i]].push_back(v[i]);
        edges[v[i]].push_back(u[i]);
    }
    for(int i = 0;i < m;++i) if(deg[i] >= 3) return 0;
    // 求出图上点编号的映射关系
    map_g.resize(m); memset(map_g.data(),-1,sizeof(int) * m);
    dfn.resize(m); memset(dfn.data(),-1,sizeof(int) * m);
    nwdfn = 0;
    if(e == m - 1){ // 链的情况，要从1度点开始dfs
        for(int i = 0;i < m;++i) if(deg[i] == 1){
            dfs(i);break;
        }
    }
    else dfs(0);
    return 1;
}

int get_ans(){
    get_cycle();
    int ans = nwas;
    if(!chk_deg()) return ans; // 有3度及以上的点就GG了
    if(m == 2) return n; // 2个点
    if(ans > n - m) return ans; // ans已经很大了
    if(e == m - 1) return n - m + 1; // 链
    if(ans == n - m) return n - m + 1; // 剩下刚好m个点没归位
    if(m % 2 == 0) return n - m - 1; // 如果是偶数，则一定能剩下m+1个点
    int nwsz = 0;
    for(int i = 0;i < cycles.size();++i){
        if(cycles[i].size() % 2 == 0) nwsz += cycles[i].size(); // 累加上所有偶环的大小
        else ++ans; // 一个奇环意味着答案能+1
    }
        
    // 要从大到小检查这些奇环，直到能合并出来一个>=m的为止
    bool fg = 0;
    for(int i = 0;i < cyc_odd.size() && nwsz < m;++i){
        int x = cyc_odd[i];
        if(fg){ // 这个奇环已经要被合并了
            nwsz += cycles[x].size();
            fg = 0;
        }
        else if(cycles[x].size() + nwsz < m){ // 要付出2的代价合并两个奇环
            ans -= 2;
            nwsz += cycles[x].size();
            fg = 1;
        }
        else break;
    }
    return ans;
}
inline void add_node(int &nw, int x){oper[dfn[nw++]] = x;} // 注意要套一层dfn
inline void add_node_cyc(int &nw, int x,int j){
    add_node(nw,cycles[x][j]);
}
void get_m(int x){ // 从第x个环上切下长为m的一段来
    // 0 1 2 ... m/2-1 3m/2-1 3m/2-2 ... m+1 m
    int nw = 0;
    for(int i = 0;i < m / 2;++i) add_node_cyc(nw,x,i);
    for(int i = m / 2 - 1;i >= 0;--i) add_node_cyc(nw,x,i + m);
}
void get_3(int x){ // 从第x个环上切下长为3的一段来
    int j;
    int nw = 0;
    for(j = 0;(m - j) % 3 != 1;++j){ // 前面%3多出来的部分
        add_node_cyc(nw,x,j);
    }
    for(;j < m;j += 3){ // 间隔3个往前调
        add_node_cyc(nw,x,j);
    }
    int fg = -1;
    for(j = m - 2;j > 0;j -= 3 + fg){ // 从m-2开始，按照-1 -3 +1 -3 -1...的模式往回跳
        add_node_cyc(nw,x,j);
        add_node_cyc(nw,x,j + fg);
        fg *= -1;
    }
}
void get_2(int x){ // 从第x个环上切下长为2的一段来
    int nw = 0;
    // 1 3 5 ... m-1 m-2 m-4 ... 2 0
    // 正着走，间隔2个放一个
    for(int j = 1;j < m;j += 2){
        add_node_cyc(nw,x,j);
    }
    // 倒着走，间隔2个放一个
    for(int j = m - 2;j >= 0;j -= 2){
        add_node_cyc(nw,x,j);
    }
}
void gen_merge2(int x,int y){ // 合并两个环，大小之和至少是m
    int nw = 0;
    for(int j = 0;nw + 1 < m && j < cycles[x].size();++j){ // 第一个环最多放m-1个点
        add_node_cyc(nw,x,j);
    }
    for(int j = 0;nw < m && j < cycles[y].size();++j){
        add_node_cyc(nw,y,j);
    }
}
void run(){ // 生成下一个操作序列，存在oper里
    if(m == 2){ // 把第一个i!=p[i]的强制归位
        for(int i = 0;i < n;++i) if(p[i] != i){
            oper[0] = i;
            oper[1] = p[i];
            return;
        }
    }

    if(e == m - 1 || nwas == n - m){
        // 如果是链，或者剩余未归位的总点数恰好等于m，可以直接这么干
        int nw = 0;
        // 从大到小遍历所有的环，把点顺次加进操作序列
        for(int i = 0;nw < m && i < cyc_list.size();++i){
            int x = cyc_list[i];
            for(int j = 0;nw < m && j < cycles[x].size();++j){
                add_node_cyc(nw,x,j);
            }
        }
        return;
    }

    int xx = -1;
    for(int i = 0;i < cycles.size();++i) if(cycles[i].size() == m){
        xx = i;break; // 找到了一个大小为m的环
    }
    if(xx != -1){ // 如果存在一个环刚好大小为m，就可以拆出来一个点
        int nw = 0;
        for(int j = 0;j < cycles[xx].size();++j){
            add_node_cyc(nw,xx,j);
        }
        return;
    }

    if(m % 2 == 1){ // 奇环
        // 由于还能继续操作，一定还有奇环
        int x = cyc_odd[0];
        int nw = 0;
        if(cycles[x].size() > m){ // 第一个奇环足够大
            // 0 2 4 ... m-1 m-2 m-4 ... 3 1
            // 正着走，间隔2个放一个
            for(int j = 0;j < m;j += 2){
                add_node_cyc(nw,x,j);
            }
            // 倒着走，间隔2个放一个
            for(int j = m - 2;j > 0;j -= 2){
                add_node_cyc(nw,x,j);
            }
            return;    
        }
        if(cycles[x].size() == m){ // 第一个奇环刚好是m，就强制拆出来一个点
            for(int j = 0;j < cycles[x].size();++j){
                add_node_cyc(nw,x,j);
            }
            return;
        }

        // 第一个环不够大
        // 先把第一个环全都加进去
        for(int j = 0;nw < m && j < cycles[x].size();++j){
            add_node_cyc(nw,x,j);
        }
        // 然后把偶环加进去
        for(int i = 0;nw < m && i < cyc_even.size();++i){
            int x = cyc_even[i];
            for(int j = 0;nw < m && j < cycles[x].size();++j){
                add_node_cyc(nw,x,j);
            }
        }
        // 最后再加入其余的奇环
        for(int i = 1;nw < m && i < cyc_odd.size();++i){
            int x = cyc_odd[i];
            for(int j = 0;nw < m && j < cycles[x].size();++j){
                add_node_cyc(nw,x,j);
            }
        }
    }

    else{ // 偶环
        int x = cyc_list[0];
        int nw = 0;
        vector<int> sz;sz.resize(m);memset(sz.data(),-1,sizeof(int) * m);
        for(int i = 0;i < cycles.size();++i) if(cycles[i].size() < m){
            int nwsz = cycles[i].size();
            if(sz[m - nwsz] != -1){ // 这两个环的大小之和刚好是m，合并之
                int y = sz[m - nwsz];
                gen_merge2(i,y);
                return;
            }
            sz[nwsz] = i;
        }

        if(cycles[x].size() == m - 1){ // 第一个环是m-1，特殊情况
            int y = cyc_list[1];
            if(cycles[y].size() == m - 1){ // 第二个环也是m-1，那么把他俩合并
                gen_merge2(x,y);
                return;
            }
            int tot_nxt = 0;
            for(int j = 1;j < cyc_list.size();++j) 
                tot_nxt += cycles[cyc_list[j]].size();
            if(tot_nxt >= m){
                int z = cyc_list[2];
                if(cycles[y].size() + cycles[z].size() == m + 1){ // 这种情况让z和x合并
                    gen_merge2(x,y);
                }
                else{
                    // 把剩下的都合并到y上
                    for(int j = 1;nw < m && j < cyc_list.size();++j){
                        int w = cyc_list[j];
                        for(int k = 0;k < cycles[w].size() && nw < m;++k){
                            add_node_cyc(nw,w,k);
                        }
                    }
                }
                return;
            }
            // tot_nxt<m的情况不归这里考虑，回归到普通情形    
        }
        
        if(cycles[x].size() < m){ // 第一个环不够大
            // 从大到小遍历所有的环，把点顺次加进操作序列
            for(int i = 0;nw < m && i < cyc_list.size();++i){
                int x = cyc_list[i];
                for(int j = 0;nw < m && j < cycles[x].size();++j){
                    add_node_cyc(nw,x,j);
                }
            }
            return;
        }
        if(cycles[x].size() == m + 1){ // 第一个环刚好是m+1，消除不了，要融合进去下一个环
            int y = cyc_list[1];
            gen_merge2(x,y);
            return;
        }
        if(cycles[x].size() >= 3 * m / 2){ // 第一个环特别大，允许拆出一个m
            get_m(x);
            return;
        }
        if(cycles[x].size() != m + 2 && cycles[x].size() != m + 4){ // 精细构造拆出一个3
            // update：每次拆下来两个点会有问题，因为每次干掉一个点之后剩下的是m-1，就意味着还需要合并两个2才行
            // 所以这里尽可能用了每次拆下来3个点的操作
            get_3(x);
            return;
        }
        // 第一个环足够大而且不是m+3，可以每次拆下来两个点
        get_2(x);
    }
}
int Alice(int _m, int _e, std::vector<int> _u, std::vector<int> _v, int _n, std::vector<int> _p){
    m = _m, e = _e, n = _n;
    u = _u, v = _v, p = _p;
    vis.resize(n); memset(vis.data(),0,sizeof(int) * n);
    cyc_id.resize(n); memset(cyc_id.data(),0,sizeof(int) * n);
    cyc_size.resize(n); memset(cyc_size.data(),0,sizeof(int) * n);
    cyc_pos.resize(n); memset(cyc_pos.data(),0,sizeof(int) * n);
    int final_ans = get_ans();
    cnt = 0;
    while(nwas < final_ans){
        ++cnt;
        run();
        int res = Bob(oper);
        swap(p[oper[u[res]]], p[oper[v[res]]]);
        get_cycle(); // 重新生成环
    }
    return final_ans;
}
```

---

## 作者：Mr_罗 (赞：3)

让我们来复盘一下张老师起飞一个小时起飞了些什么东西。

## 题意

给定一个排列 $\{p_i\}_{i=0}^{n-1}$ 和一张 $m$ 个点 $e$ 条边的连通图，你每次给每个点 $u$ 赋一个 $a_u\in[0,n-1]$ 的权值使得它们两两不同，交互库会在图上选一条边 $(u,v)$ 然后交换 $p_{a_u},p_{a_v}$ 。你的目标是让 $p_i=i$ 的位置尽可能多，交互库会尽可能阻止你，求出最坏情况下你的最优答案并且在 $3n$ 轮之内和一个可能会贩糖的交互库玩出来大于等于这个答案的结局。$n,m,e\le 400$ 。

## 前置

先连边 $(i,p_i)$ ，这样就变成了要找尽可能多的自环。我们称这个图为排列图，易知它是由若干环构成的，下文默认环指排列图中的环，会用环的大小指代一个环。

在排列图上不在同一个环内的两个元素如果被选出来了，那么这两个环就会被拼起来，否则会割开。特别地，如果选到相邻两个点则会让自环数加一，称这种操作叫「归位」。

下面默认交互库不会贩糖。

对于求出来的最优答案，如果初始值更优就直接返回就好了。

## 观察

**命题** 假如存在 $u$ 满足它的度数大于 $2$ ，那么交互库总存在一种策略使得答案不会变大。

**证明** 在排列图中一个点的度数至多为二，即最多两种情况会让答案增加，但是交互库可以选择 $u$ 的第三条边从而让答案不增。$\square$

于是只要考虑所有点度数 $\le 2$ 的情况就好了。由于原图连通，所以只要考虑原图是链还是环就好了。

## 链

首先，我们有两种操作：

1. 在排列图中选一个大小大于等于 $m$ 的环的一个连续段，这样交互库就不得不让答案加一，同时环的大小减一。
2. 在排列图中选若干环的一个连续段（即在每个环上拆一截下来拼在一起丢到链上），这样交互库一定会选择两个属于不同环的点把它们拼起来，否则答案就会加一。

显然你把一个大环掰成两半不会很优，于是对着上面直接贪就好了。

![](https://pic1.imgdb.cn/item/682a8db658cb8da5c8fb89d4.png)

## 环

考虑能不能沿用链的做法：操作二照样会将两个环拼起来（只不过可能把首尾那两个环拼起来，这不重要），但是操作一可以选择你拆出来那一段的端点，这样就只能拆下来一个大小为 $m-1$ 的环了。

这样要想让答案加一，必须给交互库一个大小恰好为 $m$ 的环。

只有拼环和归位操作限制显然有点太大了，不妨根据题目给的部分分考虑。

### $\boldsymbol{m=3}$

我们有两种操作：

1. 选择 $k\ge 3$ 的环一个连续段，得到 $2$ 和 $k-2$（当 $k=3$ 时就是归位）。
2. 选择若干个环拼起来。

注意到操作一会拆掉一个 $2$ ，所以只有初始大小是 $\ge 3$ 的奇数的环才可能贡献归位，因此最终答案就是奇环的个数。

### $\boldsymbol{2\nmid m}$

接着上面考虑，如果每次直接拆 $m-1$ 看起来不太优，想办法每次拆 $2$ 出来，这是简单的：

```
0 2 4 ... m-1 m-2 m-4 ... 1
```

我们没办法剥掉一个奇环，可以通过二染色证明，所以奇环永远不会增加。

考虑到奇环是消耗品，因此我们可以编一个看着很对的策略：

1. 选择 $m$ 归位，得到 $m-1$ 。
2. 选择 $k>m,2\nmid k$ ，得到 $2,k-2$ 。
3. 选择 $2\nmid k$ ，拼一个偶环上去。
4. 选择最大的两个 $2\nmid k_1,2\nmid k_2$ 合并得到一个偶环。

按顺序执行，每次遇到一个可以执行的操作就执行然后从头再看。

### $\boldsymbol{m=4}$

首先继续考虑剥掉 $2$ ，这也是简单的：

```
0 2 3 ... m-2 m-1 m-3 ... 1
```

注意到没办法让 $m+1$ 贡献，于是想办法剥掉 $3$ 以达到答案上界 $n-m-1$ ，发现这是可以达到的：

![](https://pic1.imgdb.cn/item/682ab1d358cb8da5c8fbc17a.jpg)

考察什么时候答案可以是 $n-m+1$ ：最后一步必须恰好剩一个 $m$ ，因此必须初始恰好有 $n-m$ 个对的元素。

然后就可以编操作了：

算了直接看偶数吧。

### $\boldsymbol{2\mid m}$

首先可以类似奇数编一串思路，然后发现会被
```
m-1 2 2 ... 2
```
卡成 $3.5n$ ，于是分讨一下最大环是 $m-1$ 的情况并且加一点优化之后就做完了。

![](https://pic1.imgdb.cn/item/682d17e958cb8da5c8ffc8a0.png)

现在去赤石吧。

## 代码

下面是可以过国际数据的代码，会被国内数据卡，等我改完会丢上来：

```cpp
#include <bits/stdc++.h>
// #include <bits/extc++.h>
using namespace std;

#define ll long long
#define ul unsigned ll
#define LL __int128_t
#define UL __uint128_t
#define db double
#define DB long db
#define pii pair<int, int>
#define fi first
#define se second
#define mkpr make_pair
#define vi vector<int>
#define vmi vector<mint>
#define vii vector<pii>
#define rsz resize
#define ep emplace
#define pb pop_back
#define eb emplace_back
#define all(c) (c).begin(), (c).end()
#define disc(c) (sort(all(c)), (c).rsz(unique(all(c)) - (c).begin()))
#define ers(S, x) ((S).erase((S).find(x)))
#define bit(k) (1u << (k))
#define Bit(k) (1ull << (k))
#define BIT(k) ((UL)1 << (k))
#define lowbit(x) ((x) & -(x))
#define bin(s, k) ((s) >> (k) & 1)
#define lg2(x) (31 - __builtin_clz(x))
#define LG2(x) (63 - __builtin_clzll(x))
#define highbit(x) bit(lg2(x))
#define highbitll(x) Bit(LG2(x))
#define popcnt(x) __builtin_popcount(x)
#define popcntll(x) __builtin_popcountll(x)
#define mem(a, x) memset(a, x, sizeof(a))
#define req(i, l, r) for (int i(l), i##End(r); i < i##End; i = -~i)
#define qer(i, r, l) for (int i(r), i##End(l); i > i##End; i = ~-i)
#define rep(i, l, r) for (int i(l), i##End(r); i <= i##End; i = -~i)
#define per(i, r, l) for (int i(r), i##End(l); i >= i##End; i = ~-i)

// #define FILERR

#ifdef JYR
#include "debug.h"
#define errm(x, ...) fprintf(stderr, x, ##__VA_ARGS__)
#define errs(x, ...) errm(x "\n", ##__VA_ARGS__)
#else
#define dbg(...) (__VA_ARGS__)
#define dbgArr(...) (__VA_ARGS__)
#define errm(x, ...) (x, ##__VA_ARGS__)
#define errs(x, ...) (x, ##__VA_ARGS__)
#endif

#define __

template<typename T, typename U> void chkmx(T &_a, U _b) { if (_a < _b) _a = _b; }
template<typename T, typename U> void chkmn(T &_a, U _b) { if (_b < _a) _a = _b; }
template<typename T, typename U> T OxO(T _a, U _b) { return _a >= _b ? -1 : _a; }

// #define MC

#define N 405
#define mod 998244353
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f

int Bob(vi);

int n, m;
vi p, U, V;
vi G[N], H[N], L[N];
bool vs[N];
vi ve, vc;
int d[N];

void dfs1(int u) {
    vs[u] = 1, ve.eb(u);
    for (auto v : G[u]) if (!vs[v]) dfs1(v);
}

void dfs2(int u) {
    vs[u] = 1, ve.eb(u);
    for (auto v : H[u]) if (!vs[v]) dfs2(v);
}

int calc() {
    int x = 0;
    req(i, 0, n) x += i == p[i];
    return x;
}

void X(vi vt) {
    int t = Bob(vt);
    swap(p[vt[U[t]]], p[vt[V[t]]]);
}

namespace T0 {
    int Alice() {
        req(i, 0, n) if (i != p[i]) {
            int j = i + 1; while (i != p[j]) j++;
            Bob(vi{i, j}), swap(p[i], p[j]);
        } return n;
    }
}

namespace T1 {
    int Alice() {
        req(i, 0, m) vs[i] = 0;
        int rt = 0;
        while (d[rt] > 1) rt++;
        ve.clear(), dfs1(rt);
        int x = n - m + 1; vi ev = ve;
        while (calc() < x) {
            vi vp, vq(m);
            req(i, 0, n) H[i].clear(), vs[i] = i == p[i];
            req(i, 0, n) H[i].eb(p[i]);
            req(i, 0, n) if (!vs[i]) {
                ve.clear(), dfs2(i);
                for (auto x : ve) {
                    if (vp.size() >= m) break;
                    vp.eb(x);
                } if (vp.size() >= m) break;
            } if (vp.size() < m) break;
            req(i, 0, m) vq[ev[i]] = vp[i]; X(vq);
        } return calc();
    }
}

namespace T2 {
    int smartBob() {
        vi q = p, vt; int su = 0, ans = 0;
        req(i, 0, n) H[i].clear(), ans += vs[i] = i == p[i];
        req(i, 0, n) H[i].eb(p[i]);
        req(i, 0, n) if (!vs[i]) {
            ve.clear(), dfs2(i);
            int x = ve.size();
            if (x & 1) vt.eb(x);
            else su += x;
        } if (ans >= n - m + 1) return ans;
        sort(all(vt), greater<int>());
        if (!vt.empty()) {
            while (vt[0] + su < m) {
                int t = 0, s = 0;
                while ((s += vt[t]) < m) t++;
                su += vt[t - 1] + vt[t];
                req(i, t + 1, vt.size()) vt[i - 2] = vt[i];
                vt.pb(), vt.pb();
            } ans += vt.size();
        } return ans;
    }
    
    int Alice() {
        req(i, 0, m) vs[i] = 0;
        ve.clear(), dfs1(1);
        vi ev = ve;
        int x = smartBob();
        while (calc() < x) {
            vi vp, vq(m), vt[2];
            req(i, 0, n) H[i].clear(), L[i].clear(), vs[i] = i == p[i];
            req(i, 0, n) H[i].eb(p[i]);
            req(i, 0, n) if (!vs[i]) {
                ve.clear(), dfs2(i), L[i] = ve;
                int x = ve.size();
                if (x == m) { vp = ve; goto odd; }
                vt[x & 1].eb(i);
            }
            sort(all(vt[1]), [](int i, int j) {
                return L[i].size() > L[j].size(); });
            if ((ve = L[vt[1][0]]).size() > m) {
                for (int i = 0; i < m; i += 2) vp.eb(ve[i]);
                for (int i = m - 2; i > 0; i -= 2) vp.eb(ve[i]);
                goto odd;
            }
            for (auto x : ve) vp.eb(x);
            for (auto i : vt[0]) for (auto x : L[i]) vp.eb(x);
            if (vp.size() < m) {
                int t = 1, s = vp.size();
                while ((s += L[vt[1][t]].size()) < m) t++;
                while (t > 0) for (auto x : L[vt[1][t--]]) vp.eb(x);
            }
            odd: req(i, 0, m) vq[ev[i]] = vp[i]; X(vq);
        } return x;
    }
}

namespace T3 {
    int Alice() {
        req(i, 0, m) vs[i] = 0;
        ve.clear(), dfs1(1);
        vi ev = ve;
        int x = n - m - 1;
        if (calc() == n - m) x += 2;
        if (calc() >= x) return calc();
        while (calc() < x) {
            vi vp, vq(m), vt;
            req(i, 0, n) H[i].clear(), L[i].clear(), vs[i] = i == p[i];
            req(i, 0, n) H[i].eb(p[i]);
            req(i, 0, n) if (!vs[i]) {
                ve.clear(), dfs2(i), L[i] = ve;
                int x = ve.size();
                if (x == m) { vp = ve; goto even; }
                vt.eb(i);
            }
            if (vt.size() == 1 && L[vt[0]].size() == m + 1) break;
            sort(all(vt), [](int i, int j) {
                return L[i].size() > L[j].size(); });
            req(i, 0, vt.size()) req(j, 0, i)
                if (L[vt[i]].size() + L[vt[j]].size() == m) {
                    for (auto x : L[vt[i]]) vp.eb(x);
                    for (auto x : L[vt[j]]) vp.eb(x);
                    goto even;
                }
            if ((ve = L[vt[0]]).size() >= m + (m >> 1)) {
                req(i, 0, m >> 1) vp.eb(ve[i]);
                req(i, 0, m >> 1) vp.eb(ve[m + (m >> 1) - 1 - i]);
                goto even;
            }
            if (ve.size() >= m + 2) {
                if (ve.size() == m + 2 || ve.size() == m + 4) {
                    for (int i = 0; i < m; i += 2) vp.eb(ve[i]);
                    for (int i = m - 1; i > 0; i -= 2) vp.eb(ve[i]);
                    goto even;
                }
                if (m % 6 == 0) {
                    vi vc{0, 1};
                    for (int i = 2; i < m; i += 3) vc.eb(i);
                    for (int i = m - 2, j = 1; i > 2; i -= 3, j ^= 1) {
                        if (j) vc.eb(i), vc.eb(i - 1);
                        else vc.eb(i - 1), vc.eb(i);
                    } for (auto i : vc) vp.eb(ve[i]);
                    goto even;
                }
                if (m % 6 == 2) {
                    vi vc{0};
                    for (int i = 1; i < m; i += 3) vc.eb(i);
                    for (int i = m - 2, j = 1; i > 2; i -= 3, j ^= 1) {
                        if (j) vc.eb(i), vc.eb(i - 1);
                        else vc.eb(i - 1), vc.eb(i);
                    } for (auto i : vc) vp.eb(ve[i]);
                    goto even;
                }
                if (m % 6 == 4) {
                    vi vc;
                    for (int i = 0; i < m; i += 3) vc.eb(i);
                    for (int i = m - 2, j = 1; i > 0; i -= 3, j ^= 1) {
                        if (j) vc.eb(i), vc.eb(i - 1);
                        else vc.eb(i - 1), vc.eb(i);
                    } for (auto i : vc) vp.eb(ve[i]);
                    goto even;
                }
            }
            if (ve.size() == m + 1) {
                (vp = ve).rsz(m - 1), vp.eb(L[vt[1]][0]);
                goto even;
            }
            if (ve.size() == m - 1) {
                vi vc = L[vt[1]];
                if (vc.size() == m - 1) {
                    (vp = ve).eb(vc[0]);
                    goto even;
                }
                if (vt.size() > 2 && vc.size() == m - 2) {
                    vi vo = L[vt[2]];
                    if (vo.size() == 2) {
                        (vp = vc).eb(vo[0]), vp.eb(vo[1]);
                        goto even;
                    }
                    (vp = ve).eb(vo[0]);
                    goto even;
                }
            }
            for (auto i : vt) for (auto x : L[i]) vp.eb(x);
            even: req(i, 0, m) vq[ev[i]] = vp[i]; X(vq);
        } return x;
    }
}

int Alice(int _m, int e, vi u, vi v, int _n, vi _p) {
    m = _m, n = _n, p = _p, mem(d, 0), U = u, V = v;
    if (m == 2) return T0::Alice();
    req(i, 0, e) d[u[i]]++, d[v[i]]++;
    if (*max_element(d, d + m) > 2) return calc();
    req(i, 0, m) G[i].clear();
    req(i, 0, e) G[u[i]].eb(v[i]), G[v[i]].eb(u[i]);
    if (m > e) return T1::Alice();
    if (m & 1) return T2::Alice();
    return T3::Alice();
}
```

---

## 作者：denominator (赞：2)

> [原题](https://www.luogu.com.cn/problem/P12542)
>
> - **这是一道交互题**。
> - 给定**连通图** $G$，边数为 $m$，点数为 $e$，每次给 $G$ 上的点 $u$ 赋予长为 $n$ 的一个排列 $p$ 的一个下标 $t_u$。
> - 交互库会选取 $G$ 的一条边 $(u,v)$，并交换 $p_{t_u}$ 与 $p_{t_v}$。
> - 交互库让 $p_i=i$ 的 $i$ 数量尽量少，选手让它尽量多，假设交互库采取最优策略时，这一数量为 $S$，求出 $S$，并且在不超过 $3n$ 次操作内使得这一数量大于等于 $S$。
> - $1\leq n,m,e\leq400$。

除了一群大粪讨之外，想通了真的很妙！当然是对 @[liuzhangfeiabc](/user/45775) 题解的自己的解释。

顺着 subtask 一个一个来。

## Part \#1 $\bm{m=2}$

就是排序……这个应该都会吧……

**以下代码的标号均从 $\bm 1$ 开始**。

```cpp
namespace mis2 {
	int q[N];
	int main () {
		for (int i = 1; i <= n; i++) {
			q[p[i]] = i;
		}
		for (int i = 1; i <= n; i++) {
			if (i != p[i]) {
				int pos = q[i];
				swap (q[i], q[p[i]]);
				swap (p[i], p[pos]);
				Bob ({i - 1, pos - 1});
			}
		}
		return n;
	}
}
```

## Part \#2 $\bm{e>m}$

止步于此……看 tj 才发现，无论怎样操作，只要图中有三度及以上的点，都是不行的……

![](https://cdn.luogu.com.cn/upload/image_hosting/psrdqcsc.png)

不妨某三度点的被标号为 $u$（即其 $t$ 值），旁边三个点的标号是 $v_1,v_2,v_3$。

考虑怎么样 grader 才可能归位一个数：

- 要么是 $v_i=p_u$，交换 $u$ 与 $v_i$ 之间的边可以；
- 要么是 $u=p_{v_j}$，交换 $u$ 与 $v_j$ 之间的边可以。

可以发现，至少有一个 $k$ 同时不满足两个限制，交互库选择交换 $u$ 与 $v_k$ 之间的边，可以阻止答案的增加。

于是我们也完成了。

```cpp
namespace egtm {
	int main () {
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			ans += (i == p[i]);
		}
		return ans;
	}
}
```

最后我们只有两种情况：链与环。为了后面的判断，先判断图里有没有度数为 $3$ 即以上的点，如果是链，返回其一端。

```cpp
namespace gc {
	int deg[N];
	int main () {
		fill (deg + 1, deg + m + 1, 0);
		for (int i = 1; i <= e; i++) {
			deg[u[i]]++, deg[v[i]]++;
		}
		int cnt = 0, r = 0;
		for (int i = 1; i <= m; i++) {
			if (deg[i] > 2) {
				return -1; // 有度数为 3 即以上的点
			}
			if (deg[i] == 1) {
				r = i;
				cnt++;
			}
		}
		if (cnt > 2) {
			return -1;
		}
		return r; // 如果为链，返回一端；如果为环，返回 0
	}
}
```

## Part \#3 $\bm{e=m-1}$（链）

我们不妨认为这条链为 $1,2,\cdots,m$，为此应该先做一些预处理，因为和主体关系不大就直接放码了。

```cpp
namespace expand { // 把链拉出来，存入 gl 数组中
	// 你说得对，但是国际区数据全是 0 - 1 - 2 - ... - m-1
	// 环全是 0 - 1 - 2 - ... - m-1 - 0
	int h[N], c;
	struct node {
		int nxt, to;
	} a[N << 1];
	void main (int x) { // x 为 gc 返回的链的一端（如果是环，则 x=1）
		c = 0;
		fill (h + 1, h + m + 1, 0);
		for (int i = 1; i <= e; i++) {
			a[++c].nxt = h[u[i]];
			a[c].to = v[i];
			h[u[i]] = c;
			a[++c].nxt = h[v[i]];
			a[c].to = u[i];
			h[v[i]] = c;
		}
		gl[1] = x, gl[2] = a[h[x]].to;
		for (int i = 2; i < m; i++) {
			for (int j = h[gl[i]]; j != 0; j = a[j].nxt) {
				int v = a[j].to;
				if (v == gl[i - 1]) {
					continue;
				}
				gl[i + 1] = v;
				break;
			}
		}
	}
}
int ret[N];
bool chk[N];
void report () { // 将 1,2,⋯,n 的顺序转化为图上的顺序告诉 grader，同时调整 p
	vector <int> r (m);
	fill (chk + 1, chk + n + 1, false);
	for (int i = 1; i <= m; i++) {
		r[gl[i] - 1] = ret[i] - 1;
		chk[ret[i]] = true;
	}
	int x = Bob (r) + 1;
	swap (p[r[u[x] - 1] + 1], p[r[v[x] - 1] + 1]);
}
```

对于排列有一个众所周知的性质，即 $i\to p_i$ 连边后，形成了若干个环，这是一个较好的可视化方法，把这些环也拉下来。

```cpp
namespace gen_cycles {
	bool vis[N];
	void main () {
		gp[0][0] = 0;
		fill (vis + 1, vis + n + 1, false);
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) {
				int& len = gp[++gp[0][0]][0];
				int id = gp[0][0];
				len = 0;
				int j = i;
				while (!vis[j]) {
					vis[j] = true;
					gp[id][++len] = j;
					j = p[j];
				}
			}
		}
	}
}
```

假如我们现在遇到了一个最聪明的 grader，他会尽量避免让 $p_i=i$，根据在 Part \#2 部分的讨论，若真的要达成这一目标，不得不让 $p_{t_i}=t_{i+1}$ 对 $i=1,2,\cdots,n-1$ 均成立。

（当然也可以 $p_{t_{i+1}}=t_i$，不过本质相同就不提了）

![](https://cdn.luogu.com.cn/upload/image_hosting/41ka8uzs.png)

（上面是一个环，但是为了可视化简便画成了链。红色为这一次构造的顺序。非常抱歉，箭头忘标了）

在可视化意义下，这一操作将大小为 $s$（$\geq m$）的环拆成了大小为 $s-1$ 和 $1$（即自环）的两个环。但是对于小环，我们彻底无能为力了吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/scvgii8u.png)

如果两个点 $u,v$ 位于不同环上，交换 $p_u,p_v$（蓝边变为红边），两个小环就被合并为一个大环了！

此时的一个 trivial 的想法是：交替选择两个环上的结点。但是也有可能遇到小环很小、大环很大的情况。不过很开心的是，如果是在环上选择相邻节点是没有影响的，所以当两环的大小之和超过 $m$ 时，可以这么选，总是对的：

![](https://cdn.luogu.com.cn/upload/image_hosting/29juc5mz.png)

（*当然，上面的图并不需要合并，需要把左边的大环拆掉，这只是一个示例*）

这么选，grader 要么会自动归位，要么会将两个环合并。

当然，考虑大小之和没有超过 $m$ 呢？只需要将每个环都选择一段连续的区间，使得总长大于等于 $m$ 即可。

分析答案：最后最多剩下 $m-1$ 个点未归位，当然一开始如果就达成了就不用做了（虽然这一点国际区和中国区数据都没卡）。

分析操作次数：最保守估计，非自环的环最多 $n/2$ 个，合并 $n/2$ 次，然后拆单点 $n$ 次，一共 $3n/2$ 次，稳过。

代码也很简单。

```cpp
namespace chain {
	int main () {
		int retans = max (n - m + 1, egtm::main ());
		while (true) {
			gen_cycles::main (); // 每次排列重新生成环就可以了
			int tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[i][0] == 1) {
					tot++;
				}
			}
			if (tot >= retans) { // 判断达到目标
				break;
			}
			tot = 0;
			// 把非自环合并起来，当然同时做到了拆出自环，所以特别简单
			// 什么？你说顺序问题？不存在的
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[i][0] != 1) {
					for (int j = 1; j <= gp[i][0]; j++) {
						ret[++tot] = gp[i][j];
						if (tot == m) {
							break;
						}
					}
					if (tot == m) {
						break;
					}
				}
			}
			report ();
		}
		return retans;
	}
}
```

## Part \#4 $\bm{e=m}$（环）

如果对于合并来说，如果 grader 选择了新的这条虚线边，并没有问题：最后还是把这两个环合并了。

![](https://cdn.luogu.com.cn/upload/image_hosting/ok0jwbrf.png)

但是如果我们要断出自环，再按照上面的做法，交互库选择虚线，就直接把长为 $m-1$ 的一段断出来了！除非……你这个环的大小就是 $m$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9j6hqkgc.png)

不过我们确实发现了一些有用的事：但凡我的这一操作序列中，相邻两个在环上距离相差 $1$ 或 $d$，就绝对可以把长为 $d$ 的一段断出来！

下面我 ~~懒得画图了~~ 认为不画图更具象，我们如此编号，实在想象不出来的画自己看张老师的图！

![](https://cdn.luogu.com.cn/upload/image_hosting/6pcwu1ra.png)

其中，假设 $1$ 号节点作为本次构造的环上一点。

（注意，张老师是 0-indexed，我是 1-indexed）

先手搓一个 $d=2$ 的断法。举一些简单的例子：

- $m=3$：$1\ 3\ 2$；
- $m=4$：$1\ 3\ 4\ 2$；
- $m=5$：$1\ 3\ 5\ 4\ 2$；
- ……

好像有想法！先顺序排列所有奇数，再倒序排列所有偶数，就是一个满足要求的方案！

然后手搓 $d=3$：显然发现，$2\nmid m$ 时已经构造不出来了。这是因为每次跳的步长是奇数，但是总共跳奇数次，显然到达不了原点 $1$——除非这是个奇环。

我们发现，$m$ 为奇数和偶数好像表现出了不同的情形，这自然引导着我们把情况分为奇数和偶数两种。

### Part \#4.1 $\bm{2\nmid m}$

按照 subtask 的引导，先来做 $m=3$ 的部分。我们可以进行的操作是：

1. 若环长为 $3$，分离出一个自环；
2. 若环长 $k$ 大于等于 $4$，分离成长度为 $2$ 和 $k-2$ 的两部分；
3. 合并两个或多个环长和大于等于 $3$ 的环。

直观的想法是：所有的奇环统统使用 2 操作变为环长为 $3$ 的环，而环长为 $3$ 的环又使用 1 操作产生一个自环，这样每个奇环产生一个自环，产率有点低啊？但是对于分离出这些长度为 $2$ 的环，我们好像真没法干啥了，原因和上面 $d=3$ 的做法不可行的原因是一致的。

推广到所有奇数 $m$，奇环可以和偶环合并，这样可以形成大奇环，但是值得注意的是，如果偶环用完之后，奇环的大小还是没有超过 $m$ 怎么办呢？那就不得不让奇环之间相互合并了。

三个奇环可以合并为一个大奇环，但是同时造成奇环数减少了 $2$，使得答案减少了 $2$。为了避免这种情况的发生，贪心地从大到小合并奇环即可。

当然，我们不需要把所有奇环都变成长度 $\geq m$ 的：合成了一个，别的就可以捡漏了（可以捡一个大小为 $m-1$ 的偶环直接合法）。

分析操作次数：最保守估计，假设有 $k$ 个奇环，有 $\dfrac{n-3k}2$ 个偶环，那么需要合并 $k+\dfrac{n-3k}2=\dfrac{n-k}2$ 次，拆分不会超过 $n/2+k$ 次，总共 $n+k/2<3n/2$ 次。

代码：（什么？这部分的代码长？先翻后面偶数部分吧）

```cpp
namespace misodd {
	int siz[N], q[N];
	int main () {
		siz[0] = 0; // 奇环的数量
		gen_cycles::main ();
		int retans = 0, tmp = 0;
		for (int i = 1; i <= gp[0][0]; i++) {
			if (gp[i][0] & 1) {
				siz[++siz[0]] = gp[i][0];
				retans++;
			} else {
				tmp += gp[i][0]; // 偶环的长度和
			}
		}
		sort (siz + 1, siz + siz[0] + 1);
		reverse (siz + 1, siz + siz[0] + 1);
		if (siz[1] != 1) {
			siz[1] += tmp;
			for (int i = 2; i <= siz[0] + 1; i++) { // 拼尽量少的奇环
				if (siz[1] >= m && (siz[1] & 1)) {
					break;
				}
				siz[1] += siz[i];
				retans--;
			}
		}
		while (true) {
			gen_cycles::main ();
			int tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[i][0] == 1) {
					tot++;
				}
			}
			if (tot >= retans) {
				break;
			}
			int id = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				q[i] = i;
				if ((gp[i][0] & 1) && (id == 0 || gp[i][0] > gp[id][0]) && gp[i][0] != 1) {
					id = i;
				}
			}
			sort (q + 1, q + gp[0][0] + 1, [&] (int x, int y) -> bool {
				if (x == id || y == id) {
					return x == id;
				} else if ((gp[x][0] ^ gp[y][0]) & 1) {
					return gp[y][0] & 1;
				} else {
					return gp[x][0] > gp[y][0];
				}
			}); // 将环按以下顺序排序：最大奇环，从大到小的偶环，从大到小的奇环
			if (gp[id][0] <= m) { // 合并环：包括奇环与偶环，同时把拆成单点包含在内了
				tot = 0;
				for (int i = 1; i <= gp[0][0]; i++) {
					for (int j = 1; j <= gp[q[i]][0]; j++) {
						ret[++tot] = gp[q[i]][j];
						if (tot == m) {
							break;
						}
					}
					if (tot == m) {
						break;
					}
				}
				report ();
			} else if (gp[id][0] > m) { // 拆分环
				tot = 0;
				for (int i = 1; i <= m; i += 2) {
					ret[++tot] = gp[id][i];
				}
				for (int i = m - 1; i >= 2; i -= 2) {
					ret[++tot] = gp[id][i];
				}
				report ();
			}
		}
		return retans;
	}
}
```

### Part \#4.2 $\bm{2\mid m}$

有个很快乐的事情，那就是我们可以从大小至少为 $3m/2$ 的环上切下一个长度为 $m$ 的环（即 $d=m$）！构造方案是：

$$1\quad2\quad\cdots\quad\dfrac m2\quad\dfrac{3m}2\quad\dfrac{3m}2-1\quad\cdots\quad m+1$$

但是可以证明这个构造就已经是最紧的，不可能做到比 $3m/2$ 的大小更小的了，证明不难。

还是先通过 $m=4$ 找找规律。我们发现，环的大小超过 $6$ 我们是喜欢的，如果还剩下不少于 $5$ 个的话，大小为 $2$ 和 $3$ 的环是一定可以合并为大小为 $4$ 或 $6$ 的环。如果处理大小为 $5$ 的环还有别的环，将它与这些环中的一个合并。这样子，我们可以最后剩下不超过 $5$ 个数。

现在要推广到所有偶数 $m$ 了，但是这个 $m=4$ 的规律好像毫无推广性啊？/hanx

但是这给我们的启示是：应当规避环大小为 $m+1$ 的情况，以及，当然的，答案的下界是 $n-m-1$。

既然在 $m$ 为奇数时我们构造 $d=3$ 失败了，那我们不妨在偶数处一试！

这个构造还是先向前再回来，但是向前时先补全步数到 $3$ 的倍数在跨 $3$ 的大步走，回来时交替用 $-1,-3,+1,-3$ 的变化值，以填充中间没有使用的内容，容易发现最后一步是合理的。

如果以上看不懂（`1` 为待处理环的编号）：

```cpp
for (int i = 1; i <= 2 - (m / 2) % 3; i++) {
	ret[++tot] = gp[1][i];
}
for (int i = 3 - (m / 2) % 3; i <= m; i += 3) {
	ret[++tot] = gp[1][i];
}
int st = 3, dir[4] = {-1, -3, 1, -3};
for (int i = m - 1; tot < m; i += dir[st]) {
	ret[++tot] = gp[1][i];
	(st += 1) %= 4;
}
```

需要尝试 $d\geq 4$ 时怎么操作吗？这些就可以通过 $d=2$ 和 $d=3$ 组合而来，所以如果真的无法优化了再来尝试普遍性。而且这个也很难，不是吗？

有了这一个操作，如果是一个中等的环，不少于 $m+2$ 并且严格少于 $3m/2$，那可以通过 $d=2$ 与 $d=3$ 的操作将其减到 $m$，并且躲过 $m+1$。

给不明事理的人讲解一下为什么 $m+1$ 不能拆：后面可能会合并，又变回了 $m+1$，导致反复横跳。这也是需要在思考与写代码时注意的一点。

可惜这个步数分析下来是 $7n/2$，差了一点！

在长为 $m$ 的环中拆下一个自环，自然形成了 $m-1$，但是 $m-1$ 与 $2$ 的结合形成的 $m+1$ 是浪费步数的主要原因！相比之下，$m-2$ 就更少，所以 $m-2$ 应该成为重点。

$m-2$ 如何形成？两个 $m-1$ 结合，分离出 $m$，自然得到了。最后的步骤是（按次序）：

1. 在长为 $m$ 的环中拆下一个自环；
2. 合并两个总长为 $m$ 的环；
3. 如果最大环 $>m$，按以上规则尝试拆下自环（尽量拆 $3$，防止变成 $m-1$）；
4. 如果最大环为 $m-1$：
    - 如果次大环为 $m-1$，合并；
    - 否则直接从次大环开始合并，如果不够 $m$，考虑从最大环开始合并（尽量保住 $m-1$）。
5. 如果最大环为 $m-2$，直接从大到小合并即可。

最后步骤均摊分析是 $3n$ 的。

```cpp
namespace miseven {
	int q[N];
	int main () {
		int tmp = egtm::main ();
		int retans = max (tmp, n - m - 1);
		if (tmp == n - m) {
			retans = n - m + 1;
		}
		while (true) {
			gen_cycles::main ();
			int tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				q[i] = i;
				if (gp[i][0] == 1) {
					tot++;
				}
			}
			if (tot >= retans) {
				break;
			}
			sort (q + 1, q + gp[0][0] + 1, [&] (int x, int y) -> bool { return gp[x][0] > gp[y][0]; });
			bool flag = false;
			int x = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[q[i]][0] == 1) {
					break;
				}
			}
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[q[i]][0] == m) {
					for (int j = 1; j <= m; j++) {
						ret[j] = gp[q[i]][j];
					}
					report ();
					flag = true;
					break;
				} else if (gp[q[i]][0] < m) {
					x = i;
					break;
				}
			}
			if (flag) {
				continue;
			}
			if (x != 0) { // 尺取法寻找和为 m 的两个环
				int r = gp[0][0];
				for (int i = x; i < r; i++) {
					while (r > i && gp[q[i]][0] + gp[q[r]][0] < m) {
						r--;
					}
					while (r > i && gp[q[i]][0] + gp[q[r]][0] == m) {
						if (gp[q[r]][0] != 1) {
							for (int j = 1; j <= gp[q[i]][0]; j++) {
								ret[j] = gp[q[i]][j];
							}
							for (int j = 1; j <= gp[q[r]][0]; j++) {
								ret[gp[q[i]][0] + j] = gp[q[r]][j];
							}
							report ();
							flag = true;
							break;
						}
						r--;
					}
					if (flag) {
						break;
					}
				}
			}
			if (flag) {
				continue;
			}
			if (gp[q[1]][0] >= m * 3 / 2) { // 拆 m
				for (int i = 1; i <= m / 2; i++) {
					ret[i] = gp[q[1]][i];
				}
				for (int i = 1; i <= m / 2; i++) {
					ret[i + m / 2] = gp[q[1]][m * 3 / 2 - i + 1];
				}
				report ();
				continue;
			} else if (gp[q[1]][0] >= m + 2) {
				if (gp[q[1]][0] == m + 2 || gp[q[1]][0] == m + 4) { // 拆 2
					tot = 0;
					for (int i = 1; i <= m; i += 2) {
						ret[++tot] = gp[q[1]][i];
					}
					for (int i = m; i >= 1; i -= 2) {
						ret[++tot] = gp[q[1]][i];
					}
					report ();
					continue;
				} else { // 拆 3
					tot = 0;
					for (int i = 1; i <= 2 - (m / 2) % 3; i++) {
						ret[++tot] = gp[q[1]][i];
					}
					for (int i = 3 - (m / 2) % 3; i <= m; i += 3) {
						ret[++tot] = gp[q[1]][i];
					}
					int st = 3, dir[4] = {-1, -3, 1, -3};
					for (int i = m - 1; tot < m; i += dir[st]) {
						ret[++tot] = gp[q[1]][i];
						(st += 1) %= 4;
					}
					report ();
					continue;
				}
			} else if (gp[q[1]][0] == m + 1 || gp[q[1]][0] == m - 1 && gp[q[2]][0] == m - 1) { // 合并前两个环
				for (int i = 1; i <= m - 1; i++) {
					ret[i] = gp[q[1]][i];
				}
				ret[m] = gp[q[2]][1];
				report ();
				continue;
			}
			int u = 1; // u 为 1 则从最大开始，u 为 2 则从次大开始
			if (gp[q[1]][0] == m - 1) {
				tot = 0;
				for (int i = 2; i <= gp[0][0]; i++) {
					if (gp[q[i]][0] == 1) {
						break;
					}
					tot += gp[q[i]][0];
				}
				if (tot >= m) {
					u = 2;
				}
			}
			tot = 0;
			for (int i = u; i <= gp[0][0]; i++) {
				for (int j = 1; j <= gp[q[i]][0]; j++) {
					ret[++tot] = gp[q[i]][j];
					if (tot == m) {
						break;
					}
				}
				if (tot == m) {
					break;
				}
			}
			report ();
		}
		return retans;
	}
}
```

## Part \#5 完整代码

最后献上纯享版无注释可以过中国区数据代码，总长略小于 8k，这个代码写完就很爽（放讨论区被交了多次已经无所谓了）：

```cpp
#include <bits/stdc++.h>
// #include "permgame.h"
using namespace std;
int Bob (vector <int>);
const int N = 410;
int n, m, e, u[N], v[N], p[N], gl[N], gp[N][N];
int opcnt;
namespace mis2 {
	int q[N];
	int main () {
		for (int i = 1; i <= n; i++) {
			q[p[i]] = i;
		}
		for (int i = 1; i <= n; i++) {
			if (i != p[i]) {
				int pos = q[i];
				swap (q[i], q[p[i]]);
				swap (p[i], p[pos]);
				Bob ({i - 1, pos - 1});
			}
		}
		return n;
	}
}
namespace gc {
	int deg[N];
	int main () {
		fill (deg + 1, deg + m + 1, 0);
		for (int i = 1; i <= e; i++) {
			deg[u[i]]++, deg[v[i]]++;
		}
		int cnt = 0, r = 0;
		for (int i = 1; i <= m; i++) {
			if (deg[i] > 2) {
				return -1;
			}
			if (deg[i] == 1) {
				r = i;
				cnt++;
			}
		}
		if (cnt > 2) {
			return -1;
		}
		return r;
	}
}
namespace egtm {
	int main () {
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			ans += (i == p[i]);
		}
		return ans;
	}
}
namespace expand {
	int h[N], c;
	struct node {
		int nxt, to;
	} a[N << 1];
	void main (int x) {
		c = 0;
		fill (h + 1, h + m + 1, 0);
		for (int i = 1; i <= e; i++) {
			a[++c].nxt = h[u[i]];
			a[c].to = v[i];
			h[u[i]] = c;
			a[++c].nxt = h[v[i]];
			a[c].to = u[i];
			h[v[i]] = c;
		}
		gl[1] = x, gl[2] = a[h[x]].to;
		for (int i = 2; i < m; i++) {
			for (int j = h[gl[i]]; j != 0; j = a[j].nxt) {
				int v = a[j].to;
				if (v == gl[i - 1]) {
					continue;
				}
				gl[i + 1] = v;
				break;
			}
		}
	}
}
namespace gen_cycles {
	bool vis[N];
	void main () {
		gp[0][0] = 0;
		fill (vis + 1, vis + n + 1, false);
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) {
				int& len = gp[++gp[0][0]][0];
				int id = gp[0][0];
				len = 0;
				int j = i;
				while (!vis[j]) {
					vis[j] = true;
					gp[id][++len] = j;
					j = p[j];
				}
			}
		}
	}
}
int ret[N];
bool chk[N];
void report () {
	vector <int> r (m);
	fill (chk + 1, chk + n + 1, false);
	for (int i = 1; i <= m; i++) {
		r[gl[i] - 1] = ret[i] - 1;
		chk[ret[i]] = true;
	}
	int x = Bob (r) + 1;
	swap (p[r[u[x] - 1] + 1], p[r[v[x] - 1] + 1]);
}
namespace chain {
	int main () {
		int retans = max (n - m + 1, egtm::main ());
		while (true) {
			gen_cycles::main ();
			int tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[i][0] == 1) {
					tot++;
				}
			}
			if (tot >= retans) {
				break;
			}
			tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[i][0] != 1) {
					for (int j = 1; j <= gp[i][0]; j++) {
						ret[++tot] = gp[i][j];
						if (tot == m) {
							break;
						}
					}
					if (tot == m) {
						break;
					}
				}
			}
			report ();
		}
		return retans;
	}
}
namespace misodd {
	int siz[N], q[N];
	int main () {
		siz[0] = 0;
		gen_cycles::main ();
		int retans = 0, tmp = 0;
		for (int i = 1; i <= gp[0][0]; i++) {
			if (gp[i][0] & 1) {
				siz[++siz[0]] = gp[i][0];
				retans++;
			} else {
				tmp += gp[i][0];
			}
		}
		sort (siz + 1, siz + siz[0] + 1);
		reverse (siz + 1, siz + siz[0] + 1);
		if (siz[1] != 1) {
			siz[1] += tmp;
			for (int i = 2; i <= siz[0] + 1; i++) {
				if (siz[1] >= m && (siz[1] & 1)) {
					break;
				}
				siz[1] += siz[i];
				retans--;
			}
		}
		while (true) {
			gen_cycles::main ();
			int tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[i][0] == 1) {
					tot++;
				}
			}
			if (tot >= retans) {
				break;
			}
			int id = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				q[i] = i;
				if ((gp[i][0] & 1) && (id == 0 || gp[i][0] > gp[id][0]) && gp[i][0] != 1) {
					id = i;
				}
			}
			sort (q + 1, q + gp[0][0] + 1, [&] (int x, int y) -> bool {
				if (x == id || y == id) {
					return x == id;
				} else if ((gp[x][0] ^ gp[y][0]) & 1) {
					return gp[y][0] & 1;
				} else {
					return gp[x][0] > gp[y][0];
				}
			});
			if (gp[id][0] <= m) {
				tot = 0;
				for (int i = 1; i <= gp[0][0]; i++) {
					for (int j = 1; j <= gp[q[i]][0]; j++) {
						ret[++tot] = gp[q[i]][j];
						if (tot == m) {
							break;
						}
					}
					if (tot == m) {
						break;
					}
				}
				report ();
			} else if (gp[id][0] > m) {
				tot = 0;
				for (int i = 1; i <= m; i += 2) {
					ret[++tot] = gp[id][i];
				}
				for (int i = m - 1; i >= 2; i -= 2) {
					ret[++tot] = gp[id][i];
				}
				report ();
			}
		}
		return retans;
	}
}
namespace miseven {
	int q[N];
	int main () {
		int tmp = egtm::main ();
		int retans = max (tmp, n - m - 1);
		if (tmp == n - m) {
			retans = n - m + 1;
		}
		while (true) {
			gen_cycles::main ();
			int tot = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				q[i] = i;
				if (gp[i][0] == 1) {
					tot++;
				}
			}
			if (tot >= retans) {
				break;
			}
			sort (q + 1, q + gp[0][0] + 1, [&] (int x, int y) -> bool { return gp[x][0] > gp[y][0]; });
			bool flag = false;
			int x = 0;
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[q[i]][0] == 1) {
					break;
				}
			}
			for (int i = 1; i <= gp[0][0]; i++) {
				if (gp[q[i]][0] == m) {
					for (int j = 1; j <= m; j++) {
						ret[j] = gp[q[i]][j];
					}
					report ();
					flag = true;
					break;
				} else if (gp[q[i]][0] < m) {
					x = i;
					break;
				}
			}
			if (flag) {
				continue;
			}
			if (x != 0) {
				int r = gp[0][0];
				for (int i = x; i < r; i++) {
					while (r > i && gp[q[i]][0] + gp[q[r]][0] < m) {
						r--;
					}
					while (r > i && gp[q[i]][0] + gp[q[r]][0] == m) {
						if (gp[q[r]][0] != 1) {
							for (int j = 1; j <= gp[q[i]][0]; j++) {
								ret[j] = gp[q[i]][j];
							}
							for (int j = 1; j <= gp[q[r]][0]; j++) {
								ret[gp[q[i]][0] + j] = gp[q[r]][j];
							}
							report ();
							flag = true;
							break;
						}
						r--;
					}
					if (flag) {
						break;
					}
				}
			}
			if (flag) {
				continue;
			}
			if (gp[q[1]][0] >= m * 3 / 2) {
				for (int i = 1; i <= m / 2; i++) {
					ret[i] = gp[q[1]][i];
				}
				for (int i = 1; i <= m / 2; i++) {
					ret[i + m / 2] = gp[q[1]][m * 3 / 2 - i + 1];
				}
				report ();
				continue;
			} else if (gp[q[1]][0] >= m + 2) {
				if (gp[q[1]][0] == m + 2 || gp[q[1]][0] == m + 4) {
					tot = 0;
					for (int i = 1; i <= m; i += 2) {
						ret[++tot] = gp[q[1]][i];
					}
					for (int i = m; i >= 1; i -= 2) {
						ret[++tot] = gp[q[1]][i];
					}
					report ();
					continue;
				} else {
					tot = 0;
					for (int i = 1; i <= 2 - (m / 2) % 3; i++) {
						ret[++tot] = gp[q[1]][i];
					}
					for (int i = 3 - (m / 2) % 3; i <= m; i += 3) {
						ret[++tot] = gp[q[1]][i];
					}
					int st = 3, dir[4] = {-1, -3, 1, -3};
					for (int i = m - 1; tot < m; i += dir[st]) {
						ret[++tot] = gp[q[1]][i];
						(st += 1) %= 4;
					}
					report ();
					continue;
				}
			} else if (gp[q[1]][0] == m + 1 || gp[q[1]][0] == m - 1 && gp[q[2]][0] == m - 1) {
				for (int i = 1; i <= m - 1; i++) {
					ret[i] = gp[q[1]][i];
				}
				ret[m] = gp[q[2]][1];
				report ();
				continue;
			}
			int u = 1;
			if (gp[q[1]][0] == m - 1) {
				tot = 0;
				for (int i = 2; i <= gp[0][0]; i++) {
					if (gp[q[i]][0] == 1) {
						break;
					}
					tot += gp[q[i]][0];
				}
				if (tot >= m) {
					u = 2;
				}
			}
			tot = 0;
			for (int i = u; i <= gp[0][0]; i++) {
				for (int j = 1; j <= gp[q[i]][0]; j++) {
					ret[++tot] = gp[q[i]][j];
					if (tot == m) {
						break;
					}
				}
				if (tot == m) {
					break;
				}
			}
			report ();
		}
		return retans;
	}
}
int Alice (int m_, int e_, vector <int> u_, vector <int> v_, int n_, vector <int> p_) {
	opcnt = 0;
	n = n_, m = m_, e = e_;
	for (int i = 0; i < e; i++) {
		u[i + 1] = u_[i] + 1;
		v[i + 1] = v_[i] + 1;
	}
	for (int i = 0; i < n; i++) {
		p[i + 1] = p_[i] + 1;
	}
	if (m == 2) {
		return mis2::main ();
	}
	int x = gc::main ();
	if (x == -1) {
		return egtm::main ();
	}
	expand::main (x == 0? 1: x);
	if (x != 0) {
		return chain::main ();
	}
	if (m % 2 == 1) {
		return misodd::main ();
	} else {
		return miseven::main ();
	}
	return -1;
}
```

最后的最后，来一些 debug tips：

1. 分区块写，不要一次性写完调试，很痛苦的；
2. 建议下载 APIO 的最终 grader 与数据调试，不然数据真的不够。（grader 里的交互库策略 1 最强，0 反而不是很强）
3. 实在不行可以挂拍子。

完结！

---


# [APIO2012] 苦无

## 题目描述

苦无(Kunai)是一种忍者使用的形状像刀的武器，忍者通过投掷苦无攻击对 手。 现在有 $N$ 名忍者聚集在一块 $H$ 行 $W$ 列的棋盘式的广场上。每个忍者都站在 其所在方块的中心处，任何两个忍者都不在同一个方块上。每个忍者都拿着一个 苦无，面朝上、下、左、右四个方向中的一个方向站着。在时刻 $0$，所有忍者同 时向其所朝向的方向投掷苦无。

每个苦无将会一直保持其初始的方向，并以单位速度飞行。如果某个时刻一 个位置上多于一个的苦无，它们将会相撞并且消失。苦无特别小，可以看成质点。 同时，由于忍者的移动速度特别快，他们不会被苦无击中。

在下面的例子中，我们用箭头来表示苦无，而箭头的方向即为苦无的方向。 在这些图中，所有的苦无都会相撞后消失。

  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) 

在下面的图中，两个粗线箭头表示的苦无不会相撞。其中在第二个和第三个 图中，其中一个粗线表示的苦无会与细线表示的苦无相撞后消失，因此不会撞上 另一个粗线表示的苦无。

  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) 

你的任务是计算经过足够长的时间之后，在这个 $W × H$ 的广场中有多少格 子被苦无经过。


## 说明/提示

对于全部数据，忍者数 $1 ≤ N ≤ 10^5$，列数 $1 ≤ W ≤ 10^9$，行数 $1 ≤ H ≤ 10^9$；
坐标范围 $1 ≤ X_i ≤ W$，$1 ≤ Y_i ≤ H$。

 
- 在 $10\%$ 的数据中，$N ≤ 1000$, $W ≤ 1000$, $H ≤ 1000$。
- 在 $40\%$ 的数据中，$N ≤ 1000$。


## 样例 #1

### 输入

```
5 4 
5 
3 3 2 
3 2 0 
4 2 2 
5 4 1 
1 1 3 ```

### 输出

```
11```

# 题解

## 作者：JoshAlMan (赞：16)

这题网上貌似还没有完整的题解呢，我来口胡一下~

# Description

$W \times H$ 的二维坐标系，$W, H \le 10^9$

给 $n (n \le 10^5)$  个点 $(x, y)$，每个点有个方向，每 $1$ 时刻箭头朝其位置移动一个单位，如果点相遇就会消失。问点经过轨迹的格子并。

# Solution

### 整体框架分析

如果我们能快速确定每个苦无运动的轨迹（最终在何时刻消失），之后的问题是矩形面积并，用扫描线 $O(n \log n)$ 解决。

首先我们可以发现，如果不考虑苦无的消失，两个苦无相撞的充要条件即在一条横线、竖线或斜线（呈 $45°$ 角）上，然后满足一些方向限制，比如，左右相撞的苦无 $i, j$ 要满足在同一条横线 $X_i = Y_i$，然后 $Y_i < Y_j, D_i = 0, D_j = 2$。

令我们比较困扰的事，可能两个苦无满足上述条件，但在此之前其中有苦无已经消失了，所以这次相遇就失败了。

我们可以按照时间顺序处理，每次把冲突时间最短的若干苦无都拿出来然后让他们消失，如果我们遇到的相遇事件中又苦无已经消失了，就跳过。

### 快速维护 & 算出最短相撞的苦无

由于每个点分别在一条横线、竖线、斜线上，所以我们可以把每条这样的线及方向当成一个集合，每个点至多在四个集合中。

然后我们现在的问题就变成了：一个数轴上，每个位置可能有两种种类的点 （$0, 1$），然后要求最近匹配的 $01$ 点对（方向不能反），还要支持删除点。

如果我们考虑每个点匹配的最优点，我们是可以通过 $\text{set}$ 在 $\log$ 时间算出前驱后继，但删除一个点的时候，可能有多个点的最有匹配是他，要修改多个点，这样就挂了。不妨考虑双向匹配，我们维护 $x, y$ 互相都作为对方的最优匹配这样的点对，这样是对的，因为单向匹配总能找到更优的双向匹配。所以在删除的一个点的时候，如果他在双向匹配里，让他的匹配点找新的匹配，即可。

这样时间复杂度就是 $O(n \log n)$

接下来的工作就是把双向匹配放进一个堆里，每次把所有时间最短的点拿出来删除就行。

### 一些细节

1. 关于横竖直线，距离为奇数点的相撞时间问题。比如相邻的两个 → ←，如果右箭头上方有一个下箭头（如题面右下角的图），那个箭头不会相撞，说明相撞时间 $> 1$，但如果相撞时间又得 $ < 2$，否则会和左箭头相撞，因此这种的相撞时间应该是 $1.5$。我是把时间整体 $\times 2$，这样就可以没有小数。
2. 一定要每次把所有同一时间的点一块删除，不然可能会存在同一时间，但后者认为前者已经消失的恐怖方法。

### 时间复杂度

$O(n \log n)$

### Code

感觉自己确实写的很麻烦，其实独自开个结构体维护那个数轴可能会更简单一点。

```cpp
#include <iostream>
#include <cstdio>
#include <set>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

typedef long long LL;

const int N = 100005, INF = 2e9;

int W, H, n, X[N], Y[N], D[N], L[N][4], f[N], m, a[N << 1], len, d[4][N], tot[4];
int nxt[4][4], pre[4][4], match[N][4], val[N][4], stk[N], top;
LL ans;
bool st[N], re[N];

struct O {
	int v, x, y;
	bool operator < (const O &b) const { return v > b.v; }
};

struct Node{
	int x, id;
	bool operator < (const Node &b) const { return x < b.x; }
};

typedef set<Node>::iterator SIT;

set<Node> s[4][N][4];
// 第一维：横 / 竖 / 左下 - 右上 / 左上 / 右下; 第二维：离散后线编号; 第三维：存储的方向值
priority_queue<O> q;

int inline get(int x, int o) { return lower_bound(d[o] + 1, d[o] + 1 + tot[o], x) - d[o]; }

void inline find(int c, int i) {
	match[i][c] = 0;
	int x = L[i][c], k = c == 0 ? Y[i] : X[i];
	if (nxt[c][D[i]] != -1) {
		int cq = nxt[c][D[i]];
		SIT it = s[c][x][cq].lower_bound( (Node) { k, 0 } );
		if (it != s[c][x][cq].end()) {
			int j = it -> id, w = (it -> x - k + 1) * 2;
			if (c < 2) w = w / 2 + 1; 
			if (!match[j][c] || w < val[j][c]) {
				match[i][c] = j, match[j][c]  = i, val[i][c] = val[j][c] = w;
				q.push((O){ val[i][c], i, j });
			}
		}
	} 
	if (pre[c][D[i]] != -1) {
		int cq = pre[c][D[i]];
		SIT it = s[c][x][cq].lower_bound( (Node) { k, 0 } );
		if (it != s[c][x][cq].begin()) {
			--it; int j = it -> id, w = (k - it -> x + 1) * 2;
			if (c < 2) w = w / 2 + 1; 
			if (!match[j][c] || w < val[j][c]) {
				match[i][c] = j, match[j][c]  = i, val[i][c] = val[j][c] = w;
				q.push((O){ val[i][c], i, j });
			}
		}
	}
}

void inline insert(int c, int i) {
	int x = L[i][c], k = c == 0 ? Y[i] : X[i];
	s[c][x][D[i]].insert((Node) { k, i } );
	find(c, i);
}

void inline init() {
	memset(nxt, -1, sizeof nxt);
	memset(pre, -1, sizeof pre);
	nxt[0][0] = 2, pre[0][2] = 0, nxt[1][3] = 1, pre[1][1] = 3;
	pre[2][0] = 3, nxt[2][3] = 0, pre[2][1] = 2, nxt[2][2] = 1;
	nxt[3][0] = 1, pre[3][1] = 0, nxt[3][3] = 2, pre[3][2] = 3;
	for (int i = 1; i <= n; i++) {
		d[0][++tot[0]] = X[i], d[1][++tot[1]] = Y[i];
		d[2][++tot[2]] = X[i] + Y[i], d[3][++tot[3]] = X[i] - Y[i];
	}
	for (int i = 0; i < 4; i++) {
		sort(d[i] + 1, d[i] + 1 + tot[i]);
		tot[i] = unique(d[i] + 1, d[i] + 1 + tot[i]) - d[i] - 1;
	}
	for (int i = 1; i <= n; i++) {
		L[i][0] = get(X[i], 0), L[i][1] = get(Y[i], 1);
		L[i][2] = get(X[i] + Y[i], 2), L[i][3] = get(X[i] - Y[i], 3);
		for (int j = 0; j < 4; j++) insert(j, i);
	}
}

void inline del(int i) {
	if (re[i]) return;
	re[i] = true;
	for (int c = 0; c < 4; c++) {
		int x = L[i][c], k = c == 0 ? Y[i] : X[i];
		s[c][x][D[i]].erase((Node) { k, i } );
		if (match[i][c]) find(max(nxt[c][D[i]], pre[c][D[i]]), match[i][c]);
	}
}

void inline clear() { while (!q.empty() && (st[q.top().x] || st[q.top().y])) q.pop(); }

void inline work() {
	while (!q.empty()) {
		clear();
		if (q.empty()) break;
		int v = q.top().v;
		while (1) {
			clear();
			if (q.empty() || q.top().v != v) break;
			O u = q.top(); 
			f[u.x] = f[u.y] = v >> 1, del(u.x), del(u.y);
			stk[++top] = u.x, stk[++top] = u.y; q.pop();
		}
		while (top) st[stk[top--]] = true;
	}
}

struct E{
	int x, l, r, c;
	bool operator < (const E &b) const { return x < b.x; }
} e[N << 1];

void inline add(int x1, int y1, int x2, int y2) {
	e[++m] = (E) { x1, y1, y2 + 1, 1 };
	e[++m] = (E) { x2 + 1, y1, y2 + 1, -1 };
	a[++len] = y2 + 1, a[++len] = y1;
}

int inline getY(int y) {
	return lower_bound(a + 1, a + 1 + len, y) - a;
}

struct T{
	int len, cnt;
} t[N * 8];

void inline pushup(int p, int l, int r) {
	t[p].len = t[p].cnt ? a[r + 1] - a[l] : t[p << 1].len + t[p << 1 | 1].len;
}

void change(int p, int l, int r, int x, int y, int k) {
	if (x <= l && r <= y) {
		t[p].cnt += k;
		if (l == r) t[p].len = t[p].cnt ? a[r + 1] - a[r] : 0;
		else pushup(p, l, r); 
		return;
	}
	int mid = (l + r) >> 1;
	if (x <= mid) change(p << 1, l, mid, x, y, k);
	if (mid < y) change(p << 1 | 1, mid + 1, r, x, y, k);
	pushup(p, l, r);
}

void inline fill() {
	for (int i = 1; i <= n; i++) {
		if (D[i] == 0) add(X[i], Y[i], X[i], Y[i] + f[i] - 1);
		else if (D[i] == 1)  add(X[i] - f[i] + 1, Y[i], X[i], Y[i]);
		else if (D[i] == 2) add(X[i], Y[i] - f[i] + 1, X[i], Y[i]);
		else add(X[i], Y[i], X[i] + f[i] - 1, Y[i]);
	}
	sort(e + 1, e + 1 + m);
	sort(a + 1, a + 1 + len);
	len = unique(a + 1, a + 1 + len) - a - 1;
	for (int i = 1; i <= m; i++) {
		change(1, 1, len, getY(e[i].l), getY(e[i].r) - 1, e[i].c);
		if (i != m && e[i].x != e[i + 1].x)
		 	ans += (e[i + 1].x - e[i].x) * (LL)t[1].len;
	}
}

int main() {
	scanf("%d%d%d", &W, &H, &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d%d", Y + i, X + i, D + i);
		if (D[i] == 0) f[i] = W - Y[i] + 1;
		else if (D[i] == 1) f[i] = X[i];
		else if (D[i] == 2) f[i] = Y[i];
		else f[i] = H - X[i] + 1;
	}
	init(); 
	work();
	fill();
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：csyakuoi (赞：7)

~~这种题口胡一下，并且谴责一下出题人就好了，千万别像我一样头铁去写7个k。~~

这篇题解就讲一下大致思路，具体细节太多，就不一一阐述了，~~希望管理员看在没有题解的份上通过~~。

考虑算出每一个苦无经过的格子，最后矩形面积并。

只要求出每一个苦无和哪一个苦无相撞，就容易求出它经过的格子。

苦无相撞无非就六种情况，分方向讨论，然后维护每一条平行于坐标轴的直线，以及与坐标轴成45度角的直线（两个苦无会相撞仅当它们初始的$x,y,x+y,x-y$中至少有一个相同）。

具体来说，按照直线的位置为第一关键字，在直线上的位置为第二关键字将点排序，建线段树，线段树上维护区间内距离最近的一对苦无，以及向两个方向移动的苦无中最靠左/靠右的，这个信息可以合并。

每次取出最早相撞的苦无，并将它们从线段树中删除，注意多个苦无同时相撞的情况。

对于删除，找到对应的线段树，把对应节点信息清空即可。

代码太丑就不贴了，需要的私信我。

---

## 作者：by_chance (赞：3)

题意：$W \times H$ 的表格中，有 $n$ 个质点从某方格中心同时开始运动。没有两个质点初始时在同一方格中。所有质点以同样的速度做直线运动，方向为上、下、左、右之一。如果两个或多个质点在同一时刻位于同一位置，则这些质点相撞并消失。求被质点经过的格子数。

这里每个质点用三个参数 $x$，$y$，$d$ 来描述，表示其开始运动的位置是从左往右的 $x$ 列、从上往下的第 $y$ 行的方格的中心。运动的方向由 $d$ 表示，分别为： 

- $d = 0$，表示向右；
- $d = 1$，表示向上；
- $d = 2$，表示向左；
- $d = 3$，表示向下。

$1 \le n \le 10^5$，$1 \le w \le 10^9$，$1 \le h \le 10^9$；$1 \le x \le W$，$1 \le y \le H$，$0 \le d \le 3$。

------------

只用求出每个质点的运动路程，然后看作宽为 $1$ 的矩形做扫描线即可。

求运动路程，就只需要求相撞的情况。相撞质点的方向有 $6$ 种可能，如同一行，左边的向右，右边的向左；再如同一条左上—右下对角线，左边的向下，右边的向左；等等。具体的可以看代码。

在每一种可能中，最先相撞的一定是两个相邻的点。一旦遇到两个相撞，就要删去这两个点，考虑新产生的相邻对，于是使用链表。

按照 $6$ 种情形，$4$ 个方向排序，排序后构建链表。然后将所有相撞按时间放入一个堆中，每次取出某个时刻所有的相撞，判断是否存在（可能已经撞过）。如果是存在的相撞，就更新链表和堆。

细节：
1. 排序的时候要先按照方向分开。
2. 可以假设质点每秒运动半个方格边长，这样所有的时间都是整数。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5,INF=1<<30;
int n,W,H,X[N<<1];ll ans;
struct P{int no,x,y,d,nxt[6],lst[6],t,ex;}a[N];
int fir[]={0,3,0,3,0,1},sec[]={2,1,1,2,3,2},dx[]={1,0,-1,0},dy[]={0,-1,0,1};
bool cmp(P a,P b){return a.no<b.no;}
bool cmp1(P a,P b){
	if((a.d==0||a.d==2)&&(b.d==1||b.d==3))return true;
	if((b.d==0||b.d==2)&&(a.d==1||a.d==3))return false;
	return a.y!=b.y?a.y<b.y:a.x<b.x;
}
bool cmp2(P a,P b){
	if((a.d==1||a.d==3)&&(b.d==0||b.d==2))return true;
	if((b.d==1||b.d==3)&&(a.d==0||a.d==2))return false;
	return a.x!=b.x?a.x<b.x:a.y<b.y;
}
bool cmp3(P a,P b){
	if((a.d==0||a.d==1)&&(b.d==2||b.d==3))return true;
	if((b.d==0||b.d==1)&&(a.d==2||a.d==3))return false;
	return a.x-a.y!=b.x-b.y?a.x-a.y<b.x-b.y:a.x<b.x;
}
bool cmp4(P a,P b){
	if((a.d==0||a.d==3)&&(b.d==1||b.d==2))return true;
	if((b.d==0||b.d==3)&&(a.d==1||a.d==2))return false;
	return a.x+a.y!=b.x+b.y?a.x+a.y<b.x+b.y:a.x<b.x;
}
struct hit{int t,p,q;};
bool operator <(const hit &a,const hit &b){return a.t>b.t;}
priority_queue<hit> Q;
struct ScanLine{
	ll l,r,h;int op;
	bool operator <(const ScanLine &b){
		return h<b.h;
	}
}line[N<<1];
struct SegmentTree{
	int ls[N<<3],rs[N<<3],sum[N<<3];ll len[N<<3];
	#define lc p<<1
	#define rc p<<1|1
	void push_up(int p){
		if(sum[p])len[p]=X[rs[p]+1]-X[ls[p]];
		else len[p]=len[lc]+len[rc];
	}
	void build(int p,int l,int r){
		ls[p]=l;rs[p]=r;len[p]=sum[p]=0;
		if(l==r)return;
		build(lc,l,l+r>>1);
		build(rc,(l+r>>1)+1,r);
	}
	void modify(int p,int L,int R,int c){
		if(X[rs[p]+1]<=L||R<=X[ls[p]])return;
		if(L<=X[ls[p]]&&X[rs[p]+1]<=R){sum[p]+=c;push_up(p);return;}
		modify(lc,L,R,c);modify(rc,L,R,c);
		push_up(p);
	}
}seg;
int main(){
	scanf("%d%d%d",&W,&H,&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].d);
		a[i].ex=1;a[i].no=i;
		for(int k=0;k<6;k++)a[i].nxt[k]=a[i].lst[k]=-1;
		switch(a[i].d){
			case 0:a[i].t=2*(W-a[i].x);break;
			case 1:a[i].t=2*(a[i].y-1);break;
			case 2:a[i].t=2*(a[i].x-1);break;
			case 3:a[i].t=2*(H-a[i].y);break;
		}
	}
	a[n+1].d=2;a[0].d=0;
	sort(a+1,a+n+1,cmp1);
	for(int i=1;i<n;i++){
		if(a[i].d==1||a[i].d==3)break;
		if(a[i].y==a[i+1].y)a[i].nxt[0]=a[i+1].no,a[i+1].lst[0]=a[i].no;
	}
	sort(a+1,a+n+1,cmp2);
	for(int i=1;i<n;i++){
		if(a[i].d==0||a[i].d==2)break;
		if(a[i].x==a[i+1].x)a[i].nxt[1]=a[i+1].no,a[i+1].lst[1]=a[i].no;
	}
	sort(a+1,a+n+1,cmp3);
	for(int i=0,op=2;i<n;i++){
		if((a[i].d==0||a[i].d==1)&&(a[i+1].d==2||a[i+1].d==3)){op=3;continue;}
		if(i!=0&&a[i].x-a[i].y==a[i+1].x-a[i+1].y)
			a[i].nxt[op]=a[i+1].no,a[i+1].lst[op]=a[i].no;
	}
	sort(a+1,a+n+1,cmp4);
	for(int i=0,op=4;i<n;i++){
		if((a[i].d==0||a[i].d==3)&&(a[i+1].d==1||a[i+1].d==2)){op=5;continue;}
		if(i!=0&&a[i].x+a[i].y==a[i+1].x+a[i+1].y)
			a[i].nxt[op]=a[i+1].no,a[i+1].lst[op]=a[i].no;
	}
	sort(a+1,a+n+1,cmp);
	for(int k=0;k<6;k++)
		for(int i=1;i<=n;i++)
			if(a[i].nxt[k]!=-1&&a[i].d==fir[k]&&a[a[i].nxt[k]].d==sec[k])
				Q.push({abs(a[i].x-a[a[i].nxt[k]].x)+abs(a[i].y-a[a[i].nxt[k]].y),i,a[i].nxt[k]});
	while(!Q.empty()){
		int t0=Q.top().t;
		while(!Q.empty()&&Q.top().t==t0){
			hit tmp=Q.top();int i=tmp.p,j=tmp.q;Q.pop();
			if(!a[i].ex&&a[i].t!=t0||!a[j].ex&&a[j].t!=t0)continue;
			if(a[i].ex){
				for(int k=0;k<6;k++){
					int LS=a[i].lst[k],NX=a[i].nxt[k];
					if(LS!=-1)a[LS].nxt[k]=NX;
					if(NX!=-1)a[NX].lst[k]=LS;
					if(LS!=-1&&NX!=-1&&a[LS].d==fir[k]&&a[NX].d==sec[k])
						Q.push({abs(a[LS].x-a[NX].x)+abs(a[LS].y-a[NX].y),LS,NX});
				}
			}
			if(a[j].ex){
				for(int k=0;k<6;k++){
					int LS=a[j].lst[k],NX=a[j].nxt[k];
					if(LS!=-1)a[LS].nxt[k]=NX;
					if(NX!=-1)a[NX].lst[k]=LS;
					if(LS!=-1&&NX!=-1&&a[LS].d==fir[k]&&a[NX].d==sec[k])
						Q.push({abs(a[LS].x-a[NX].x)+abs(a[LS].y-a[NX].y),LS,NX});
				}
			}
			a[i].t=a[j].t=t0;a[i].ex=a[j].ex=0;
		}
	}
	for(int i=1;i<=n;i++){
		int dist=a[i].t,X1,Y1,X2,Y2;
		if(dist%2==0)dist/=2;
		switch(a[i].d){
			case 0:{X1=a[i].x;X2=a[i].x+dist+1;Y1=a[i].y;Y2=a[i].y+1;break;}
			case 1:{X1=a[i].x;X2=a[i].x+1;Y1=a[i].y-dist;Y2=a[i].y+1;break;}
			case 2:{X1=a[i].x-dist;X2=a[i].x+1;Y1=a[i].y;Y2=a[i].y+1;break;}
			case 3:{X1=a[i].x;X2=a[i].x+1;Y1=a[i].y;Y2=a[i].y+dist+1;break;}
		}
		X[2*i-1]=X1;X[2*i]=X2;
		line[2*i-1]={X1,X2,Y1,1};line[2*i]={X1,X2,Y2,-1};
	}
	sort(line+1,line+2*n+1);
	sort(X+1,X+2*n+1);
	int tot=unique(X+1,X+2*n+1)-X-1;
	seg.build(1,1,tot-1);
	for(int i=1;i<2*n;i++){
		seg.modify(1,line[i].l,line[i].r,line[i].op);
		ans+=seg.len[1]*(line[i+1].h-line[i].h);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


# [APIO2017] 斑斓之地

## 题目背景

本题原为交互题，这里采用传统题形式进行评测。

## 题目描述

在很久以前的黄金时代，澳大利亚的土地是矩形的，它可以被划分成 $R$ 行 $C$ 列的网格状，行的编号从北到南依次为 $1$ 到 $R$ ，列的编号从西到东依次为 $1$ 到 $C$，$(r,c)$ 表示第 $r$ 行第 $c$ 列的土地。一天，伟大的彩虹蛇从 $(s_r,s_c)$ 出发在澳大利亚的土地上移动，彩虹蛇连续进行了 $M$ 次移动，每次它会向正北 (`N`)、正南 (`S`)、正东 (`E`) 或正西 (`W`) 方向移动一格，其经过的所有的格子（包括起点和终点）都会变成河流。保证在任一时刻，彩虹蛇都不会离开这片 $R$ 行 $C$ 列的矩形土地。

数百万年之后，你想购买一块矩形区域纪念伟大的彩虹蛇。你想给所购买矩形区域内每一块不是河流的格子都染上颜色，要求相邻的格子颜色必须相同，两个格子相邻当且仅当两个格子有一条公共边，你所购买区域之外的格子无须染色。

现在给出彩虹蛇 $M$ 次移动的方向，你有 $Q$ 个购买矩形区域的方案，问每个方案最多能够将土地染上多少种不同的颜色。

## 说明/提示

### 样例解释

样例对应下图，其中蓝色代表河流。

![](https://cdn.luogu.com.cn/upload/image_hosting/1mhty5m8.png)

### 数据范围

对于所有测试数据，$0\le M\le 10^5$，并且 $R,C,Q\ge 1$，对于每个购买矩形土地的方案，都有 $1 \le a_r \le b_r \le R, 1 \le a_c \le b_c \le C$。

详细子任务分值及附加条件如下表。

|子任务编号|分值|$R$|$C$|$Q$|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$11$|$R\le 50$|$C\le 50$|$Q\le 1000$|
|$2$|$12$|$R=2$|$C\le 2\times 10^5$|$Q\le 10^5$|
|$3$|$24$|$R\le 2\times 10^5$|$C\le 2\times 10^5$|$Q=1$|
|$4$|$27$|$R\le 1000$|$C\le 1000$|$Q\le 10^5$|
|$5$|$26$|$R\le 2\times 10^5$|$C\le 2\times 10^5$|$Q\le 10^5$|


## 样例 #1

### 输入

```
6 4 9 4
3 3
NWESSWEWS
2 3 2 3
3 2 4 4
5 3 6 4
1 2 5 3```

### 输出

```
0
2
1
3```

# 题解

## 作者：周子衡 (赞：16)

对于每两块相邻的可用土地（不被蛇占据的土地，下称**白点**，反之为黑点）之间连一条边，形成图 $G$，显然题意就是求 $G$ 在横坐标 $[a_r,b_r]$，纵坐标 $[a_c,b_c]$ 范围内的连通块个数。

显然 $G$ 是一个平面图。根据平面图的欧拉公式，对于**连通**平面图 $G$，有 $|V|-|E|+|F|=1$，其中 $|V|,|E|,|F|$ 分别表示 $G$ 的点数、边数、划分平面数。进而推知：对于任意平面图 $G$，$|V|-|E|+|F|=G$ 的连通块数。考虑快速计算 $|V|,|E|,|F|$ 的值。

显然 $|V|,|E|$ 都很好计算：以 $|V|$ 为例，相当于计算 $[a_r,b_r][a_c,b_c]$ 内的白点个数，而白点个数较大，反面考虑，转化为计算该区域内黑点个数——由于黑点总数为 $O(m)$ 的，转化为简单二维数点问题，主席树即可解决。$|E|$ 包含两部分边：横边和竖边，分开考虑，每部分也是一个二维数点问题，亦可同上解决。

对于 $|F|$，原图的平面可能由两部分组成：一是若干 $1\times 1$ 的小正方形，这一部分相当于求四个点都是白点的数量，套用二维数点即可；另外要特别注意，如果矩形范围将蛇的范围完全包住并留有外隙，则 $|F|$ 额外加 $1$——令黑点的 $r,c$ 最大最小值为 $maxr,minr,maxc,minc$，则上述条件等价于 $a_r<minr$ 且 $b_r>maxr$ 且 $a_c<minc$ 且 $b_c>minc$。具体原理留给读者思考。

综上，我们得到了一个时间、空间复杂度均为 $O((r+c+m)\log c)$ 的做法，可以通过此题。**特别提醒：**特判 $m=0$，即 $S$ 为空的情况。

代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>

using namespace std;

int r=0,c=0,m=0,Q=0;

struct point
{
	int x,y;point(int xx=0,int yy=0):x(xx),y(yy){}
};bool operator<(point a,point b){if(a.x!=b.x)return a.x<b.x;return a.y<b.y;}
bool operator==(point a,point b){return a.x==b.x&&a.y==b.y;}

vector<point> q[4];
void add_point(int x,int y)
{
	for(int i=0;i<4;i++)q[i].push_back(point(x,y));
	if(x<r){q[1].push_back(point(x+1,y)),q[3].push_back(point(x+1,y));}
	if(y<c){q[2].push_back(point(x,y+1)),q[3].push_back(point(x,y+1));}
	if(x<r&&y<c){q[3].push_back(point(x+1,y+1));}
}

struct PresidentTree
{
	struct nd
	{
		int lc,rc,sum;
	}t[7000000];int used;
	void build(int l,int r,int &k)
	{
		if(!k)k=++used;t[k].sum=0;if(l==r)return;
		int mid=(l+r)>>1;build(l,mid,t[k].lc),build(mid+1,r,t[k].rc);
	}
	int add(int pos,int val,int l,int r,int k)
	{
		int p=++used;t[p]=t[k];
		if(l==r){t[p].sum+=val;return p;}
		int mid=(l+r)>>1;if(pos<=mid){t[p].lc=add(pos,val,l,mid,t[k].lc);}else t[p].rc=add(pos,val,mid+1,r,t[k].rc);
		t[p].sum=t[t[p].lc].sum+t[t[p].rc].sum;return p;
	}
	int sum(int x,int y,int l,int r,int k)
	{
		if(l>y||r<x)return 0;
		if(x<=l&&r<=y)return t[k].sum;
		int mid=(l+r)>>1;return sum(x,y,l,mid,t[k].lc)+sum(x,y,mid+1,r,t[k].rc);
	}
}T[4];int rt[4][500000];

char S[500000];

int sum(int i,int ar,int ac,int br,int bc)
{
	if(ar>br||ac>bc)return 0;
	return T[i].sum(ac,bc,1,c,rt[i][br])-T[i].sum(ac,bc,1,c,rt[i][ar-1]);
}

int main()
{
	scanf("%d%d%d%d",&r,&c,&m,&Q);
	int sr=0,sc=0;scanf("%d%d",&sr,&sc);add_point(sr,sc);
	if(m)scanf("%s",S+1);
	int minr=sr,maxr=sr,minc=sc,maxc=sc;
	for(int i=1;i<=m;i++)
	{
		if(S[i]=='N')sr--;if(S[i]=='S')sr++;if(S[i]=='W')sc--;if(S[i]=='E')sc++;
		minr=min(minr,sr),maxr=max(maxr,sr),minc=min(minc,sc),maxc=max(maxc,sc);
		add_point(sr,sc);
	}
	//puts("");
	for(int i=0;i<4;i++)
	{
		sort(q[i].begin(),q[i].end());
		
		vector<point>::iterator new_end=unique(q[i].begin(),q[i].end());
		q[i].erase(new_end,q[i].end());
		//for(int j=0;j<q[i].size();j++)printf("%d %d\n",q[i][j].x,q[i][j].y);
		T[i].build(1,c,rt[i][0]);
		for(int j=1,p=-1;j<=r;j++)
		{
			rt[i][j]=rt[i][j-1];
			while(p+1<q[i].size()&&q[i][p+1].x==j)
			{
				p++;
				rt[i][j]=T[i].add(q[i][p].y,1,1,c,rt[i][j]);
			}
		}
		//puts("");
	}
	
	while(Q--)
	{
		int ar=0,ac=0,br=0,bc=0;scanf("%d%d%d%d",&ar,&ac,&br,&bc);long long R=br-ar+1,C=bc-ac+1;
		long long ans1=R*C-sum(0,ar,ac,br,bc);
		long long ans2=(R-1)*C-sum(1,ar+1,ac,br,bc);
		long long ans3=R*(C-1)-sum(2,ar,ac+1,br,bc);
		long long ans4=(R-1)*(C-1)-sum(3,ar+1,ac+1,br,bc);
		if(ar<minr&&br>maxr&&ac<minc&&bc>maxc)ans4++;
		//printf("%lld %lld %lld %lld\n",ans1,ans2,ans3,ans4);
		printf("%lld\n",ans1-ans2-ans3+ans4);
	}
	return 0;
}
```

---

## 作者：Hagasei (赞：7)

不是哥们这题评黑的？

数连通块数量自然转化平面图欧拉定理 $V-E+F=C+1$。这里把所有非河流格子定为点，邻接格子间连边。

数点数，直接二维数点；数边数，分别数横边和竖边；数面数，每个 $2\times2$ 的小正方形贡献一面，分是否完全包含那个『洞』再贡献 $2$ 或 $1$ 面。

想一想这个东西具体怎么实现，假如我们从上往下扫描线，已知了该行有哪些位置没有点，那么剩下的就是若干段区间，在线段树里区间加即可解决贡献 $1,2$（令 $i$ 的 $2$ 贡献是 $i$ 到 $i-1$ 的边数，$[l+1,r]$ 区间加即可）。

同理，$3,4$ 的贡献是将这行与上行取交集后的两组区间加。取交集的过程也是容易实现的，只需将两行没点的位置合并重新排序从左到右枚一遍即可。

由于只有 $m$ 个位置没有点，所以划分出的区间数是 $\Theta(m+R)$ 的，线段树域为 $C$，总复杂度不超过 $O((R+m)\log C+m\log m+C)$。

为啥这几篇题解都费力容斥到数黑点？正难则反，难吗？

为啥我要写这么细？只需要一个欧拉公式就好了吧。感觉我好像在写蓝题题解。

```cpp
vector<int> riv[MAXN];
int dx[]={-1,1,0,0};
int dy[]={0,0,1,-1};
int wei[]={1,-1,-1,1};
char tra[128];
// 注意运算过程会爆 int。
ll ans[MAXN];
struct NODE{int l,r,f,i,p;};
vector<NODE> sq[MAXN];
inline void spfor(int lx,int rx,int ly,int ry,int p,int i){
    if(lx>rx||ly>ry) return ;
    sq[rx].push_back({ly,ry,1,i,p});
    sq[lx-1].push_back({ly,ry,-1,i,p});
}
int main(){
    int R,M,Q;
    qr(R,C,M,Q);
    int x,y;
    qr(x,y);
    riv[x].push_back(y);
    tra['N']=0;
    tra['S']=1;
    tra['E']=2;
    tra['W']=3;
    int mxx=x,mnx=x,mxy=y,mny=y;
    for(int i=1;i<=M;++i){
        char o;
        qr(o);
        int d=tra[o];
        x+=dx[d];
        y+=dy[d];
        riv[x].push_back(y);
        mxx=max(mxx,x);
        mnx=min(mnx,x);
        mxy=max(mxy,y);
        mny=min(mny,y);
    }
    for(int i=1;i<=Q;++i){
        int lx,ly,rx,ry;
        qr(lx,ly,rx,ry);
        // 这里 0/1/2/3 分别对应上面的 1/3/2/4。
        spfor(lx,rx,ly,ry,0,i);
        spfor(lx+1,rx,ly,ry,1,i);
        spfor(lx,rx,ly+1,ry,2,i);
        spfor(lx+1,rx,ly+1,ry,3,i);
        // 讲道理这里可以直接特判 ans=1 不存询问的。因为他都完全包含洞了那就是一整个连通块了。
        ans[i]+=(mxx<rx)&&(mnx>lx)&&(mxy<ry)&&(mny>ly);
    }
    for(int i:{0,1,2,3}) T[i].build(1,1,C);
    for(int d=1;d<=R;++d){
        sort(riv[d].begin(),riv[d].end());
        riv[d].push_back(C+1);
        int las=1;
        for(int&h:riv[d]){
            // add 里判了 l>r，所以直接这么写了。
            T[0].add(las,h-1,1);
            T[2].add(las+1,h-1,1);
            las=h+1;
            riv[d-1].push_back(h);
        }
        sort(riv[d-1].begin(),riv[d-1].end());
        las=1;
        if(d!=1){
            for(int&h:riv[d-1]){
                T[1].add(las,h-1,1);
                T[3].add(las+1,h-1,1);
                las=h+1;
            }
        }
        for(auto&q:sq[d]){
            ans[q.i]+=q.f*wei[q.p]*T[q.p].ask(q.l,q.r);
        }
    }
    for(int i=1;i<=Q;++i) printf("%lld\n",ans[i]);
}
```

---

## 作者：littlez_meow (赞：1)

竟然是平面图欧拉公式题。

[题目指路](https://www.luogu.com.cn/problem/P3776)。

### 题意

给定一个 $R\times C$ 的白色网格。有一条长度为 $M+1$ 以 $(s_r,s_c)$ 为起点的路径，上面所有点被染成黑色。$Q$ 次询问一个矩形中有多少白色格子的四联通连通块。

### 思路

对每个格子建点，相邻白色格子连边，每次询问就是问一个矩形中图论意义上的连通块。

显然建出的图是网格图的子图，是平面图，考虑欧拉公式。

**【欧拉公式】** $|V|-|E|+|R|=p+1$，其中 $|V|$ 为点集大小，$|E|$ 为边集大小，$|R|$ 为划分出的区域数，$p$ 为连通块数。在 $R$ 不考虑整个平面对该图划分出区域的补集，即只考虑图内部时，上式需改写为 $|V|-|E|+|R|=p$。

也就是说，我们要快速求出 $|V|,|E|,|R|$。

$|V|$ 是好求的，为总点数减去黑格子对应点数。而黑格子在矩形中的点数用二维数点就可以了。

$|E|$ 只有两种，横着的和竖着的。分开统计，为总边数减至少有一端点为黑格子的边数。把这种边对应到左边或上面的那个点统计，注意右边界或下边界要减一。

$|R|$ 在考虑平面的补集情况下有些难算，我们应只考虑图内部。只有 $2\times2$ 的白格子构成的正方形才会有 $1$ 的贡献，故答案为总正方形数减去 存在黑点的 $2\times2$ 正方形数。我们把贡献放在右上角统计，注意边界。此外，当矩形完全包含路径时，这条路径也是一个划分出的区域，要 $+1$。

时间复杂度在于二维数点 $O(M\log M)$，认为 $M,R,C$ 同阶。

注意一个黑格子最多会造成 $4$ 个点的贡献，空间记得开至少 $4$ 倍。

重振我树状数组二维数点荣光！

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
const int MAXN=100002;
int r,c,m,q;
int sr,sc;
int l=200001,rr=0,u=200001,d=0;
pair<int,int>pos[4][MAXN<<2];
struct Query{
	int x,y;
	int id;
	short posi;
	bool operator<(const Query&qwq)const{
		return x==qwq.x?id<qwq.id:x<qwq.x;
	}
};
Query ask[4][MAXN<<3];
int cnt[4];
struct BIT{
	int val[MAXN<<1];
	#define lowbit(i) (i&(-i))
	inline void add(int x){
		for(;x<=c;x+=lowbit(x)) ++val[x];
		return;
	}
	inline int query(int x){
		int res(0);
		for(;x;x-=lowbit(x)) res+=val[x];
		return res;
	}
};
BIT s[4];
int ans[4][MAXN],ql[MAXN],qr[MAXN],qu[MAXN],qd[MAXN];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>r>>c>>m>>q>>sr>>sc;
	F(i,1,m+1){
		l=min(l,sc);
		rr=max(rr,sc);
		u=min(u,sr);
		d=max(d,sr);
		pos[0][++cnt[0]]={sr,sc};
		sc>1&&(pos[1][++cnt[1]]={sr,sc-1},1);
		pos[1][++cnt[1]]={sr,sc};
		sr>1&&(pos[2][++cnt[2]]={sr-1,sc},1);
		pos[2][++cnt[2]]={sr,sc};
		sr>1&&sc>1&&(pos[3][++cnt[3]]={sr-1,sc-1},1);
		sc>1&&(pos[3][++cnt[3]]={sr,sc-1},1);
		sr>1&&(pos[3][++cnt[3]]={sr-1,sc},1);
		pos[3][++cnt[3]]={sr,sc};
		if(i==m+1) break;
		char ch;
		cin>>ch;
		switch(ch){
			case 'N':{
				--sr;
				break;
			}
			case 'S':{
				++sr;
				break;
			}
			case 'W':{
				--sc;
				break;
			}
			case 'E':{
				++sc;
				break;
			}
		}
	}
	F(i,0,3){
		sort(pos[i]+1,pos[i]+cnt[i]+1);
		cnt[i]=unique(pos[i]+1,pos[i]+cnt[i]+1)-pos[i]-1;
		F(j,1,cnt[i]) ask[i][j]={pos[i][j].first,pos[i][j].second,0,0};
	}
	F(i,1,q){
		int lx,ly,rx,ry;
		cin>>lx>>ly>>rx>>ry;
		ql[i]=ly,qr[i]=ry,qu[i]=lx,qd[i]=rx;
		ask[0][++cnt[0]]={rx,ry,i,1};
		ask[0][++cnt[0]]={lx-1,ry,i,-1};
		ask[0][++cnt[0]]={rx,ly-1,i,-1};
		ask[0][++cnt[0]]={lx-1,ly-1,i,1};
		ask[1][++cnt[1]]={rx,ry-1,i,1};
		ask[1][++cnt[1]]={lx-1,ry-1,i,-1};
		ask[1][++cnt[1]]={rx,ly-1,i,-1};
		ask[1][++cnt[1]]={lx-1,ly-1,i,1};
		ask[2][++cnt[2]]={rx-1,ry,i,1};
		ask[2][++cnt[2]]={lx-1,ry,i,-1};
		ask[2][++cnt[2]]={rx-1,ly-1,i,-1};
		ask[2][++cnt[2]]={lx-1,ly-1,i,1};
		ask[3][++cnt[3]]={rx-1,ry-1,i,1};
		ask[3][++cnt[3]]={lx-1,ry-1,i,-1};
		ask[3][++cnt[3]]={rx-1,ly-1,i,-1};
		ask[3][++cnt[3]]={lx-1,ly-1,i,1};
	}
	F(i,0,3) sort(ask[i]+1,ask[i]+cnt[i]+1);
	F(i,0,3){
		F(j,1,cnt[i]){
			if(!ask[i][j].id) s[i].add(ask[i][j].y);
			else ans[i][ask[i][j].id]+=ask[i][j].posi==-1?-s[i].query(ask[i][j].y):s[i].query(ask[i][j].y);
		} 
	}
	F(i,1,q){
		ll res(0);
		res+=(qr[i]-ql[i]+1)*1ll*(qd[i]-qu[i]+1)-ans[0][i];
		res-=(qr[i]-ql[i])*1ll*(qd[i]-qu[i]+1)-ans[1][i];
		res-=(qd[i]-qu[i])*1ll*(qr[i]-ql[i]+1)-ans[2][i];
		res+=(qr[i]-ql[i])*1ll*(qd[i]-qu[i])-ans[3][i];
		if(ql[i]<l&&qr[i]>rr&&qu[i]<u&&qd[i]>d) ++res;
		cout<<res<<"\n";
	}
	return 0;
} 
```

---

## 作者：Arghariza (赞：1)

<https://www.cnblogs.com/Ender32k/p/17714330.html>

回忆平面图欧拉公式。

$$V-E+F=C+1$$

$V$ 为点数，$E$ 为边数，$F$ 为面数，$C$ 为连通块数。

以下称河流为黑块，土地为白块。将白块看成点，四联通的白块之间连边，不难发现矩阵查询即询问导出子图的连通块数。考虑平面图欧拉公式，那么只需要求出导出子图的点数、面数以及边数即可。

点数是好求的，只需要查询矩阵内有多少白块即可。

边数也是好求的，考虑白块上下连边或者左右连边两种情况，容斥一下，只需要考虑相邻两块中存在黑块的情况。把上下相邻两个块的贡献标在上面的块，把左右相邻的两个块的贡献标在左边的块，就不会算重了。

同样，面数也是好求的。$4$ 个白块组成 $2\times 2$ 的子矩形时才会多产生一个面。同样容斥，把 $2\times 2$ 矩形中黑块的贡献放在左上角，还有一种情况就是矩形区域包含了黑块路径，这个特判以下即可。

然后答案就好求了，变成二维数点，主席树即可。复杂度 $O(n\log n)$。

```cpp
// Problem: P3776 [APIO2017] 斑斓之地
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3776
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define ll long long
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    // #if ONLINE_JUDGE
    // #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    // #else
    #define gh() getchar()
    // #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(ll x) {
        if (x < 0) x = ~(x - 1), putchar('-');
        if (x > 9) wr(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace vbzIO;

const int N = 2e5 + 200;
const int M = 50;

int r, c, m, q, sx, sy;
int lx, rx, ly, ry;
vector<int> p[N][4];
char s[N];

struct SEG {
	int tot, rt[N];
	struct seg { int vl, lc, rc; seg () { vl = lc = rc = 0; } } tr[N << 5];
	SEG () { tot = 0; }
	#define ls tr[x].lc
	#define rs tr[x].rc
	#define mid ((l + r) >> 1)
	void upd(int l, int r, int p, int y, int &x) {
		tr[x = ++tot] = tr[y], tr[x].vl++;
		if (l == r) return;
		if (p <= mid) upd(l, mid, p, tr[y].lc, ls);
		else upd(mid + 1, r, p, tr[y].rc, rs);
	}
	int qry(int l, int r, int s, int t, int x) {
		if (!x) return 0;
		if (s <= l && r <= t) return tr[x].vl;
		if (s > mid) return qry(mid + 1, r, s, t, rs);
		else if (t <= mid) return qry(l, mid, s, t, ls);
		else return qry(l, mid, s, t, ls) + qry(mid + 1, r, s, t, rs);
	}
} t[4];

void ins(int x, int y) {
	lx = min(lx, x), ly = min(ly, y), rx = max(rx, x), ry = max(ry, y);
	p[x][0].pb(y), p[x - 1][1].pb(y), p[x][1].pb(y), p[x][2].pb(y - 1), p[x][2].pb(y);
	p[x - 1][3].pb(y - 1), p[x - 1][3].pb(y), p[x][3].pb(y - 1), p[x][3].pb(y);
}

int qry(int op, int xa, int ya, int xb, int yb) {
	return t[op].qry(0, c, ya, yb, t[op].rt[xb]) - t[op].qry(0, c, ya, yb, t[op].rt[xa - 1]);
}

signed main() {
	r = rd(), c = rd(), m = rd(), q = rd(), sx = rd(), sy = rd();
	if (m) scanf("%s", s + 1);
	lx = rx = sx, ly = ry = sy, ins(sx, sy);
	for (int i = 1; i <= m; i++) {
		if (s[i] == 'N') sx--;
		else if (s[i] == 'S') sx++;
		else if (s[i] == 'W') sy--;
		else sy++;
		ins(sx, sy);
	}
	for (int i = 1; i <= r; i++) {
		for (int j = 0; j < 4; j++) {
			sort(p[i][j].begin(), p[i][j].end());
			p[i][j].erase(unique(p[i][j].begin(), p[i][j].end()), p[i][j].end());
			t[j].rt[i] = t[j].rt[i - 1];
			for (int k : p[i][j]) t[j].upd(0, c, k, t[j].rt[i], t[j].rt[i]);
		}
	}
	while (q--) {
		int xa = rd(), ya = rd(), xb = rd(), yb = rd();
		ll w1, w2, w3;
		w1 = w2 = w3 = 0;
		w1 = 1ll * (xb - xa + 1) * (yb - ya + 1) - qry(0, xa, ya, xb, yb);
		if (xa != xb) w2 += 1ll * (xb - xa) * (yb - ya + 1) - qry(1, xa, ya, xb - 1, yb);
		if (ya != yb) w2 += 1ll * (xb - xa + 1) * (yb - ya) - qry(2, xa, ya, xb, yb - 1);
		if (xa != xb && ya != yb) w3 = 1ll * (xb - xa) * (yb - ya) - qry(3, xa, ya, xb - 1, yb - 1);
		if (xa < lx && rx < xb && ya < ly && ry < yb) w3++;
		wr(w1 - w2 + w3), pc('\n');
	}
	return 0;
}
```

---

## 作者：LingHusama (赞：0)

## APIO 斑斓之地题解
### 前言：
这一道题目涉及到的算法主要是主席树，思想主要是平面图（欧拉定理）以及简单的容斥原理。如果您想要真正掌握这道题所涉及的知识点，请您先去了解这个定理以及明晰主席树的代码打法。
### 正文：
注明：为了表示方便，我们把蛇蛇经过的点叫做黑点吧。不经过的肯定就叫白点啦。
1. 首先直接看题面，我们进行题目翻译，发现是求一个矩形内的联通快个数。当发现两个**关键要素**：格子图与框选矩形、查找联通块时，这道题十有八九和欧拉定理脱不了关系。（这也是非常值得积累的一种思路）。

2. 接着我们就从欧拉定理的角度来思考下这道题。对于**联通的图**而言，始终存在着 $V-E+F=1$ 这个公式，其中 $V$ 是点数量 $E$ 是边数量 $F$ 是划分出的面的数量。这和联通块有什么关系呢？注意**联通**这两个字，那么对于任意一个图，我们可以看成很多个联通的图的组合，于是就有了 $V-E+F=R$，其中 $R$ 表示联通块个数。

3. （如果您明白怎么建立图，可以跳过这一步）有的读者可能看不懂这个图该怎么建立，而这也是很重要的一个知识点（一种思路）。因为我要求解联通块的数量，而显然的是，我们想要的是白色联通块，所以求解的点、边都应该是白色联通块内的，这个边应该是白色和白色相连接的边。

4. 容斥求解：当我们明白要找一个矩形内两边都为白色点的边、白色点的数量、白色点构成的面时，我们会发现，数量有点多，暴力找的话会寄。所以我们考虑利用容斥。举个例子，我们求解白点的时候可以通过寻找黑点然后再用所有的减去白点得到答案。求解白边的时候用总共的边减去所有任意一端为黑点的边即可。求解联通块其实就是寻找四白点情况。

5. 主席树解决二维数点问题：其实上面的求解就是四类二维数点问题，这里拿找边来说明。边的话，我们要分成两类（横着的和竖着的）来进行容斥，这里再拿横边举例子，为了把边看成点，我要把两个连续的点压缩成一个点，最后矩形也相应地压缩就好了。但是我们不能乱压缩，你可以想想一个十字形，都往中心去压缩肯定不行的。至于怎么用主席树解决二维数点，我专门写了个[博客](https://www.cnblogs.com/linghusama/p/17809130.html)可以去看看思路，实在不行下面有代码。

### 注意事项：
本题目有多点注意事项：

1. 数组大小要开够。
2. 联通块求解时要分析清楚最后是否要多一（完全将蛇蛇覆盖但是有空隙）。
3. 有可能存在字符串为空的情况，这时候注意输入可能会导致错位。

### 代码实现：
本人调了四个小时。

不知道为什么注释变成乱码了……（但是懒得改了，思路很清晰了）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int val;
	int ls;
	int rs;
}tree[5][8000006];
int cnt[5];
int roots[5][8000006];
void pushup(int id,int rt){
	tree[id][rt].val=tree[id][tree[id][rt].ls].val+tree[id][tree[id][rt].rs].val;
}
void build(int id,int rt,int L,int R){
	int mid=(L+R)>>1;
	if(L==R){
		tree[id][rt].val=0;
		return ;
	}
	tree[id][rt].ls=++cnt[id];
	tree[id][rt].rs=++cnt[id];
	build(id,tree[id][rt].ls,L,mid);
	build(id,tree[id][rt].rs,mid+1,R);
}
int newnode(int id,int root){
	int u=++cnt[id];
	tree[id][u]=tree[id][root];
	return u;
}
int add(int id,int root,int newrt,int pos,int v,int le,int ri){
	if(newrt==root){
		newrt=newnode(id,root);
		 
	}
	int mid=(le+ri)>>1;
	if(le==ri){
		tree[id][newrt].val+=v;
		return newrt;
	}
	if(pos<=mid){
		tree[id][newrt].ls=add(id,tree[id][root].ls,tree[id][newrt].ls,pos,v,le,mid);
	}
	else{
		tree[id][newrt].rs=add(id,tree[id][root].rs,tree[id][newrt].rs,pos,v,mid+1,ri);
	}
	pushup(id,newrt);
	return newrt;
	
}
int query(int id,int rt,int L,int R,int le,int ri){
	int mid=(le+ri)>>1;
	if(le>=L&&ri<=R){
		return tree[id][rt].val;
	}
	if(le>R||ri<L){
		return 0;
	}
	int ret=0;
	ret+=query(id,tree[id][rt].ls,L,R,le,mid);
	ret+=query(id,tree[id][rt].rs,L,R,mid+1,ri);
	return ret;
}
struct nod{
	int x;
	int y;
	bool operator ==(const nod a)const{
		return a.x==x&&a.y==y;
	}
}dot[5][8000006]; 
bool cmp(nod x,nod y){
	if(x.x!=y.x)return x.x<y.x;
	else return x.y<y.y; 
}
int sum[5];
int n,m,len,qq;
void adddot(int x,int y){
	for(int i=1;i<=4;i++){
		sum[i]++;
		dot[i][sum[i]].x=x;
		dot[i][sum[i]].y=y;
	}
	if(x<n){
		sum[2]++;
		dot[2][sum[2]].x=x+1;
		dot[2][sum[2]].y=y;
		sum[4]++;
		dot[4][sum[4]].x=x+1;
		dot[4][sum[4]].y=y;
	}
	if(y<m){
		sum[3]++;
		dot[3][sum[3]].x=x;
		dot[3][sum[3]].y=y+1;
		sum[4]++;
		dot[4][sum[4]].x=x;
		dot[4][sum[4]].y=y+1;
	}
	if(x<n&&y<m){
		sum[4]++;
		dot[4][sum[4]].x=x+1;
		dot[4][sum[4]].y=y+1;
	}
}
int getsum(int id,int n1,int m1,int n2,int m2){
	if(n1>n2||m1>m2){
		return 0;
	}
	int x1=query(id,roots[id][n2],m1,m2,1,m);
	int x2=query(id,roots[id][n1-1],m1,m2,1,m);
//	cout<<id<<" "<<x1<<" "<<x2<<endl;
	return x1-x2;
}
signed main(){
	ios::sync_with_stdio(false);
	roots[1][0]=1;
	roots[2][0]=1;
	roots[3][0]=1;
	roots[4][0]=1;//ËÄ¸öÖ÷Ï¯Ê÷ 
	cnt[1]=cnt[2]=cnt[3]=cnt[4]=1;
	cin >>n >>m >>len >>qq;
	
	build(1,roots[1][0],1,m);
	build(2,roots[2][0],1,m);
	build(3,roots[3][0],1,m);
	build(4,roots[4][0],1,m);
	int sn,sm;
	cin >> sn>>sm;
	adddot(sn,sm);
	string s;
	if(len)
		cin >> s;
	s=" "+s;
	int maxn=sn;
	int minn=sn;
	int maxm=sm;
	int minm=sm;
	for(int i=1;i<=len;i++){
		if(s[i]=='N'){
			sn--;
		} 
		if(s[i]=='S'){
			sn++;
		} 
		if(s[i]=='E'){//->
			sm++;
		} 
		if(s[i]=='W'){//<-
			sm--;
		} 
		adddot(sn,sm);
		maxn=max(maxn,sn);
		minn=min(minn,sn);
		maxm=max(maxm,sm);
		minm=min(minm,sm);
	}
//	cout<<"TT"<<sum[2]<<endl;

//	
	for(int k=1;k<=4;k++){

		sort(dot[k]+1,dot[k]+1+sum[k],cmp);
		sum[k]=unique(dot[k]+1,dot[k]+1+sum[k])-dot[k]-1;	
//		for(int i=1;i<=sum[2];i++){
//			cout<<"TEST2:  "<<dot[2][i].x<<" "<<dot[2][i].y<<endl;
//		}
//		cout<<endl;
		int nowh=0;
		for(int i=1;i<=sum[k];i++){
			int t=dot[k][i].y;
			if(!roots[k][dot[k][i].x]){
				for(int j=nowh+1;j<=dot[k][i].x-1;j++){//ÖÐ¼äÃ»ÓÃµÄµÄ¸´ÖÆ¹ýÀ´ 
					roots[k][j]=roots[k][j-1];
				}
				nowh=dot[k][i].x;
				roots[k][dot[k][i].x]=add(k,roots[k][dot[k][i].x-1],roots[k][dot[k][i].x-1],dot[k][i].y,1,1,m);
			}
			else{		
				add(k,roots[k][dot[k][i].x-1],roots[k][dot[k][i].x],dot[k][i].y,1,1,m);
			}
		}
		for(int j=nowh+1;j<=n;j++){//ÖÐ¼äÃ»ÓÃµÄµÄ¸´ÖÆ¹ýÀ´ 
			roots[k][j]=roots[k][j-1];
		}	
	}
//	cout<<qq<<endl;
//	for(int i=1;i<=4;i++){
//		for(int j=1;j<=sum[i];j++){
//			if(dot[i][j].x==dot[i][j-1].x){
//				continue;
//			}
//			cout<<roots[i][dot[i][j].x]<<" ";
//		}
//		cout<<endl;
//	}
	while(qq--){
		int n1,m1,n2,m2;
		cin >>n1>>m1>>n2>>m2;
		int N=(n2-n1+1);
		int M=(m2-m1+1);
//		cout<<fir<<endl; 
		int ans1=N*M-getsum(1,n1,m1,n2,m2);//ÕâÀï¼ÆËãµÄÊÇ¿òÑ¡ÄÚÈÝÖÐÍÁµØµãµÄ¸öÊý 
		
		int ans2=(N-1)*M-getsum(2,n1+1,m1,n2,m2);
		int ans3=N*(M-1)-getsum(3,n1,m1+1,n2,m2);
		int ans4=(N-1)*(M-1)- getsum(4,n1+1,m1+1,n2,m2);
		if(n1<minn&&n2>maxn&&m1<minm&&m2>maxm)ans4++;
//		cout<<"TEST"<<ans1<<" "<<ans2<<" "<<ans3<<" "<<ans4<<endl;
		cout<<ans1-ans2-ans3+ans4<<endl;
		
	}
	
	
	
}
```



---


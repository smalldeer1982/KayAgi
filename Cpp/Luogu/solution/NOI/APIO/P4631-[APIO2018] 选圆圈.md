# [APIO2018] 选圆圈

## 题目描述

在平面上，有 $n$ 个圆，记为 $c_1, c_2,...,c_n$ 。我们尝试对这些圆运行这个算法：

1. 找到这些圆中半径最大的。如果有多个半径最大的圆，选择编号最小的。记为 $c_i$。
2. 删除 $c_i$ 及与其有交集的所有圆。两个圆有交集当且仅当平面上存在一个点，这个点同时在这两个圆的圆周上或圆内。（原文直译：如果平面上存在一个点被这两个圆所包含，我们称这两个圆有交集。一个点被一个圆包含，当且仅当它位于圆内或圆周上。）
3. 重复上面两个步骤直到所有的圆都被删除。

![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)

当 $c_i$ 被删除时，若循环中第 $1$ 步选择的圆是 $c_j$，我们说 $c_i$ 被 $c_j$ 删除。对于每个圆，求出它是被哪一个圆删除的。

## 说明/提示

**提示**

题目描述中的图片对应了样例一中的情形。

**子任务（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

- Subtask 1(points: $7$): $n \leq 5000$
- Subtask 2(points: $12$): $n \leq 3 × 10^5$，对于所有的圆 $y_i = 0$
- Subtask 3(points: $15$): $n \leq 3 × 10^5$，每个圆最多和一个其他圆有交集
- Subtask 4(points: $23$): $n \leq 3 × 10^5$，所有的圆半径相同
- Subtask 5(points: $30$): $n \leq 10^5$
- Subtask 6(points: $13$): $n \leq 3 × 10^5$

所有数据均满足：$-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$。

## 样例 #1

### 输入

```
11
9 9 2
13 2 1
11 8 2
3 3 2
3 12 1
12 14 1
9 8 5
2 8 2
5 2 1
14 4 2
14 14 1
```

### 输出

```
7 2 7 4 5 6 7 7 4 7 6```

# 题解

## 作者：Lice (赞：61)

> Update on 2020.10.8：添加了一些参考链接。

希望看到这一篇帮忙顶一下，不然真就全网人类智慧 kdt 泛滥了。。。

有两个 **复杂度正确** 的解法哦！

代码详见 https://www.luogu.com.cn/paste/tlbnzyno

### Description

给定平面上的 $n$ 个圆，用三个参数 $(x, y, R)$ 表示圆心坐标和半径。

每次选取最大的一个尚未被删除的圆删除，并同时删除所有与其相切或相交的圆。

最后输出每个圆分别是被那个圆所删除的。

### Hint

- $1\le n\le 3\times 10^5$
- $0\le |x|, |y|, R \le 10^9$

### Solution 1

后来在 Codeforces 上找到的官方题解 [Link here](http://codeforces.com/blog/entry/59650)。如果对题解中某些说明无法理解可以参考上述内容。做法参考：[Link here](https://www.cnblogs.com/clrs97/p/10340285.html#4662153)。

有一个非常简单的 $O(n^2)$ 暴力，由于每次都要扫一遍所有圆所以复杂度爆炸。

我们尝试剪枝，缩小枚举的范围。

若当前最大圆的半径为 $R$，那么我们做一个分块操作：将整个平面 **划分为一个个方格**，方格的边长为 $2R$，刚好“框住”这个最大圆。

对于当前这个圆，我们只要搜索 **其所在格子及其相邻的** 即可（两个格子相邻定义为所在行的距离不超过 1，且列距离也不超过 1，换言之，一个格子所有相邻的就是周围一圈 8 个）。显然这样是不会漏记的，因为所有圆的半径都不超过方格大小，那么一定不会出现两个圆相交或相切，但却不在相邻两个方格内。

但我们总不能每次都搜怎么大的格子，最大圆的大小如果非常大而其他圆又很小的话这个剪枝没有丝毫用处。因此我们引入一个 **重构机制**：设现在考虑到的圆的半径为 $R^\prime$，原来方格大小为 $L$。若 $R^\prime < L$，那么 **重构整个方格**，并以 $2R^\prime$ 作为新的方格大小 $L$。

重构的复杂度会不会有问题？观察到，当半径不足方格大小的一半时才会重构，重构之后如果又来一次那又得一半。于是整个算法不会有超过 $O(\log R)$ 次重构，而一次重构的复杂度可以达到 $O(n\log n)$（排序时重构，搜索时二分），所以总共最多也就两只 $\log$，不会有问题。

可以证明每个圆被检查的次数为常数。因为对于一个圆，一个方格中不会有太多的大小相似的大圆对它进行检查，这些大圆会在之前就会被互相消除掉。

总复杂度为 $O(n\log n\log R)$。

但其实重构是可以做到一次 $O(n)$ 的，这样复杂度就是优秀的 $O(n(\log n+\log R))$。具体可以参考上述链接。

### Solution 2

*虽然也是有理有据的 $\log^2$ 但跑的真的很慢。* 做法参考：[Link here](https://www.cnblogs.com/ywwyww/p/9083228.html)。

对于一个圆 $(x, y, R)$，考虑如何得到比它大的与之相交或相切，并且 **不是因为其他圆而被带走的圆**。

这些圆之间 **不可能又有公共部分**，否则它们之间会互相消除。

有一个比较显然的东西：这些圆一定在矩形 $(x-R, y-R) \sim (x + R, y + R)$ 的 **边框** 上。不会出现在内部是因为这些圆是比当前圆大的。

对于 $x$ 方向，我们维护一下前面的扫描线，那么前面每个圆会有 $x+R, x-R$ 两条。然后向后做，每次加入是将 $y$ 方向的两条扫描线加进去，查询是查询 $y$ 方向的 **前驱后继** 即可。这个用平衡树（```set```）显然可以搞。

然而发现这样只是求出一个圆的答案。现实相当于要多组询问，那么我们 **CDQ 分治**！

首先肯定是按 $R$ 排序。然后先递归左侧，处理完左侧大的对右侧小的影响，然后递归右侧。如果是递归到重点 $l=r$ 的话，发现这里还没有删除那就自己删掉，**标记一下这个不是被带走的**。

主要怎么做左侧对右侧的影响。首先对于左边的，我们取出所有 **不是被带走的** 圆的扫描线，作为“修改”；右侧则取出全部，作为“查询”。修改部分，形如 $x-R$ 的是“插入”，$x+R$ 是“删除”，分别表示加入可能的答案和移除这个已经没有的答案。查询部分显然两边都是要查询的。

最后得到了一堆扫描线，然后按坐标大小的顺序去做。插入时将这个圆的 $y$ 坐标插入，删除时也将这个圆的 $y$ 坐标删除。查询就是 $y$ 坐标的前驱后继即可。注意答案对编号取 min。

这样的复杂度是 $O(n\log^2 n)$ 的，~~然而被随机选择 KDT 吊起来打 QAQ~~

### Solution 3

既然是“二维平面”，那么可以 **KDT** 暴力搞。

首先一个圆心为 $(x, y)$，半径为 $R$ 的圆，我们可以粗略地认为是一个矩形区域 $(x-R, y-R)\sim (x+R, y+R)$。

那么考虑用 KDT 维护这些矩形。对于一个圆，搜索可能与之有交集的区域即可。

但这样复杂度是 $O(\text{玄学})$ 而且可能被卡。

于是发扬人类智慧，将所有的点 **随机旋转** 一个角度。于是就可以过 LOJ 数据了。

不过 Luogu 不需要旋转 qwq。

思维难度、代码难度和速度全方位碾压 Sol 1 & 2。

### Code

https://www.luogu.com.cn/paste/tlbnzyno

---

## 作者：ysner (赞：15)

题目太火，正解无从想象，准备暴力骗分。

什么东西能够快速维护平面上的东西？
二维树状数组、二维线段树？蒟蒻不会。。。
于是就只剩$kd-tree$了。

$kd-tree$本质上就是一个经过优化的暴力（优化在缩小搜索范围，只对近邻进行搜索），是靠剪枝吃饭的。

我们可以用它维护每个圆在$x,y$轴的范围，即$[x-r,x+r],[y-r,y+r]$。

这样相当于维护一个矩形，但是并不会漏掉答案，并且维护起来很方便。

于是建完树后，从前往后对每个圆通过$kd-tree$暴力统计答案即可。

然而这样只有$42pts$，我们需要更多剪枝。

可以注意到，如果搜到一个圆，在当前统计答案的圆的（矩形）范围之外，这个圆显然不会对答案有贡献，可以跳过。

于是就可以通过洛谷数据了？然而$loj$上跑不过最后一档。

把每个点转一个角度应该可以过。

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define re register
#define il inline
#define ll long long
#define db double
#define ls t[k].l
#define rs t[k].r
#define eps 1e-6
#define pf(x) ((db)(1.0)*(x)*(x))
#define max(a,b) (((a)>(b)?(a):(b)))
#define min(a,b) (((a)<(b)?(a):(b)))
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=3e5+100;
int now,n,rt,ans[N];
struct dat
{
  int d[2],r,id;
  bool operator < (const dat &o) const {return d[now]<o.d[now];}
}a[N];
struct node
{
  dat a;
  int l,r,mn[2],mx[2];
}t[N];
il int gi()
{
   re int x=0,t=1;
   re char ch=getchar();
   while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
   if(ch=='-') t=-1,ch=getchar();
   while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
   return x*t;
}
il void cmax(re int &x,re int y){x=max(x,y);}
il void cmin(re int &x,re int y){x=min(x,y);}
il bool cmp(dat x,dat y){return (x.r==y.r)?(x.id<y.id):(x.r>y.r);}
struct kd_tree
{
  il void upd(re int k,re int p)
  {
    cmin(t[k].mn[0],t[p].mn[0]);cmax(t[k].mx[0],t[p].mx[0]);
    cmin(t[k].mn[1],t[p].mn[1]);cmax(t[k].mx[1],t[p].mx[1]);
  }
  il void pushup(re int k)
  {
        re int x=t[k].a.d[0],y=t[k].a.d[1],r=t[k].a.r;
    t[k].mn[0]=x-r;t[k].mx[0]=x+r;
    t[k].mn[1]=y-r;t[k].mx[1]=y+r;
    if(ls) upd(k,ls);if(rs) upd(k,rs);
  }
  il void Build(re int &k,re int l,re int r,re int tag)
  {
    re int mid=l+r>>1;now=tag;
    nth_element(a+l,a+mid,a+r+1);k=mid;
    t[k].a=a[mid];
    if(l<mid) Build(ls,l,mid-1,tag^1);else ls=0;
    if(mid<r) Build(rs,mid+1,r,tag^1);else rs=0;
    pushup(k);
  }
  il int check(re int k,re dat A)
  {
    re int x=A.d[0],y=A.d[1],r=A.r+t[k].a.r,xx=t[k].a.d[0],yy=t[k].a.d[1];
    return pf(1ll*x-xx)+pf(1ll*y-yy)-eps<=pf(r);
  }
  il int far(re int k,re dat A)
  {
    re int x=A.d[0],y=A.d[1],r=A.r;
    if(x+r<t[k].mn[0]) return 1;
    if(y+r<t[k].mn[1]) return 1;
    if(x-r>t[k].mx[0]) return 1;
    if(y-r>t[k].mx[1]) return 1;
    return 0;
  }
  il void Query(re int k,re dat A)
  {
    if(far(k,A)) return;
    if(!ans[t[k].a.id]&&check(k,A)) ans[t[k].a.id]=A.id;
    if(ls) Query(ls,A);if(rs) Query(rs,A);
  }
}kd;
int main()
{
  n=gi();
  fp(i,1,n)
    {
      a[i].d[0]=gi();a[i].d[1]=gi();a[i].r=gi();a[i].id=i;
    }
  kd.Build(rt,1,n,0);
  sort(a+1,a+1+n,cmp);
  fp(i,1,n) if(!ans[a[i].id]) kd.Query(rt,a[i]);
  fp(i,1,n) printf("%d ",ans[i]);puts("");
  return 0;
}
```

---

## 作者：D0000 (赞：9)

看一眼题目，$O(n^2)$ 的做法很好想，那么离数据要求的 $3\times10^5$ 不远了，于是我想了以下~~几~~ 2 种优化方法：
# 1.怎么找半径最大值？
圆圈大小不会变的，也不会有新的来（只会删除），就先按半径排一遍序，再插入一个链表。

那么半径最大的就是链表的第一个元素。

排序：$O(n\log n)$。

建链表：$O(n)$。

删除/找第一个：$O(1)$。

# 2.真的每一个圆圈都需要判断吗？
$O(n^2)$ 的做法特别搞笑，一个在 $(-10^9,-10^9)$ 的圆圈会和 $(10^9,10^9)$ 的圆圈判断。

也就是说，完全不可能的就不需要判断了。

那如何知道是不是完全不可能的呢？

1. ~~旋转一个角度~~（我是绝对不会用无法证明正确性的方法的）

1. ~~高级数据结构~~（我是绝对不会的）

那么想了整整 $10^6$ms，想出了一个既正确，又简单，甚至时间复杂度严格控制在了 $O(n\sqrt n)$ 内。

好的，那么本篇题解正式开始：

# x 轴排序
很容易想到，由于一个圆 $D$ 把另一个圆 $Z$ 删除，需要它们有交集，则它们的距离 $d$ **必小于它们的半径和** $r_D+r_Z$，又因为 $r_D\ge r_Z$，所以 $d< r_D+r_Z\le 2r_D$。

换句话说，一个圆能删得的园离它小于它的半径两倍。

有什么用？

若 $|x_D-x_Z|\ge2r_D$ 则 $Z$ 一定不能被 $D$ 删除。

所以先按 $x$ 轴排序，每次二分找 $x$ 轴最小和最大可以把哪些删掉，然后就只用循环判断这些圆就行了。

然后？完了！完了？就能 AC 了！

是的，这样就能在最慢 453ms 过了！

但是分析一下，最坏时间复杂度还是 $O(n^2)$，比如所有点 $x$ 轴都一样就寄掉了。

# y 轴排序
一样的，所有点 $y$ 轴一样就寄掉。
# 都排序
是的，既排 $x$ 轴，也排 $y$ 轴，选少的一个循环判断。

这样最坏就是一个正方形矩阵，每个都是 $\sqrt n$，时间复杂度就是 $O(n\sqrt n)$。

但不知为何最慢的变成了 675ms。

具体细节可以看代码：
# 代码
```cpp
#include<cstdio>
#include<algorithm>
#include<math.h>
int n;
struct node{
	int x,y,r,golian,ans;
	bool b;
}a[300005];
int qq[300005],q2[300005];
bool cmp(int x,int y){
	if(a[x].r==a[y].r)return x<y;
	return a[x].r>a[y].r;
}
bool dmy(int x,int y){
	return a[x].x<a[y].x;
}
bool dhx(int x,int y){
	return a[x].y<a[y].y;
}
struct lian{
	int next,xx,last;
}ll[300005];
void del(int id){
	ll[ll[id].last].next=ll[id].next;
	ll[ll[id].next].last=ll[id].last;
}
bool pd(int aa,int bb){
	return sqrt((0ll+a[aa].x-a[bb].x)*(0ll+a[aa].x-a[bb].x)+(0ll+a[aa].y-a[bb].y)*(0ll+a[aa].y-a[bb].y))<=1.0*(0ll+a[aa].r+a[bb].r);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].r);
		qq[i]=i;q2[i]=i;
	}
	std::sort(qq+1,qq+n+1,cmp);//第一次半径大小排序
	ll[0].next=1;
	for(int i=1;i<=n;i++)ll[i].next=i+1,ll[i].xx=qq[i],a[qq[i]].golian=i,ll[i].last=i-1;//插入链表 
	std::sort(qq+1,qq+n+1,dmy);//第二次按x坐标排序，由于第一次的已经插入链表了，直接覆盖掉 
	std::sort(q2+1,q2+n+1,dhx);//第三次次按y坐标排序
	while(ll[0].next!=n+1){
		int cc=ll[ll[0].next].xx;
		del(a[cc].golian);
		a[cc].b=1;
		a[cc].ans=cc;
		int lt=1,rt=n,mt,lx,rx,ly=0,ry;
		while(lt<=rt){
			mt=(lt+rt)>>1;
			if(a[qq[mt]].x<a[cc].x-2*a[cc].r)lt=mt+1;
			else rt=mt-1,lx=mt;
		}
		lt=1,rt=n;
		while(lt<=rt){
			mt=(lt+rt)>>1;
			if(a[qq[mt]].x>a[cc].x+2*a[cc].r)rt=mt-1;
			else lt=mt+1,rx=mt;
		}
		lt=1,rt=n;
		while(lt<=rt){
			mt=(lt+rt)>>1;
			if(a[q2[mt]].y<0ll+a[cc].y-2*a[cc].r)lt=mt+1;
			else rt=mt-1,ly=mt;
		}
		lt=1,rt=n;
		while(lt<=rt){
			mt=(lt+rt)>>1;
			if(a[q2[mt]].y>0ll+a[cc].y+2*a[cc].r)rt=mt-1;
			else lt=mt+1,ry=mt;
		}
		if(rx-lx+1<=ry-ly+1){
				for(int i=lx;i<=rx;i++)if(!a[qq[i]].b&&pd(qq[i],cc)){
				del(a[qq[i]].golian);
				a[qq[i]].b=1;
				a[qq[i]].ans=cc;
			}
		}
		else for(int i=ly;i<=ry;i++)if(!a[q2[i]].b&&pd(q2[i],cc)){
			del(a[q2[i]].golian);
			a[q2[i]].b=1;
			a[q2[i]].ans=cc;
		}
	}
	for(int i=1;i<=n;i++)printf("%d ",a[i].ans);
}
```
# 后记
这是我 A 的第一道黑题（虽然感觉马上要掉蓝了）。

---

## 作者：critnos (赞：8)

神奇剪枝。

把每个圆的最左和最右取出来作为两个点，即 $x_i-r_i$ 和 $x_i+r_i$，怼到数组里排序。每次删除的时候求出当前的圆的这两个点作为 $L,R$。每次要删除的圆的两个点至少有一个在区间 $[L,R]$ 中。

然后每次在排序的数组里二分出区间暴力扫就可以了。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int x[300005],y[300005],r[300005],del[300005];
inline int read()
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
pair<int,int> a[300005];
bool cmp(pair<int,int> x,pair<int,int> y)
{
	if(x.first==y.first) return x.second<y.second;
	return x.first>y.first;
}
inline ll _(ll x)
{
	return x*x;
} 
bool cd(int wx,int wy)
{
	return _(r[wx]+r[wy])>=_(x[wx]-x[wy])+_(y[wx]-y[wy]);
}
pair<int,int> t[600005];
bool v[600005];
int cnt;
void erase(int l,int r,int b)
{
	for(int i=lower_bound(t+1,t+1+cnt,make_pair(l,0))-t;i<=cnt&&t[i].first<=r;i++)
	{
		if(v[i]) continue;
		if(cd(b,t[i].second)||del[t[i].second]) v[i]=1;
		if(cd(b,t[i].second)&&!del[t[i].second]) del[t[i].second]=b;
	}	
}
int main()
{
	int n=read(),i,mn,w,b;
	for(i=1;i<=n;i++)
	{
		x[i]=read(),y[i]=read(),r[i]=read(),a[i]=make_pair(r[i],i);
		t[++cnt]={x[i]-r[i],i};
		t[++cnt]={x[i]+r[i],i};
	}
	sort(a+1,a+1+n,cmp);
	sort(t+1,t+1+cnt);
	for(i=1;i<=n;i++)
	{
		b=a[i].second;
		if(del[b]) continue;
		erase(x[b]-r[b],x[b]+r[b],b);
	}
	for(i=1;i<=n;i++)
		printf("%d ",del[i]);
}
```


---

## 作者：Leianha (赞：2)

## KDtree

[博客阅读](https://www.cnblogs.com/wljss/p/12627526.html)

考虑和一个圆有交集的圆，是平面上的一块区域，所以我们考虑用 $KDtree$ 维护。

两个圆相交的条件 $\displaystyle (X_i-X_j)^2+(Y_i-Y_j)^2 \leqslant (R_i+R_j)^2$

考虑怎么剪枝，直接维护 $X,Y,R$ 的话不好维护。我们知道圆 $i$ 和圆 $j$ 有交集的话肯定会和框住圆 $j$ 的最小的正方形有交集。

所以我们维护 $KDtree$ 一个子树里所有圆对应的正方形 $X,Y$ 的最值来剪枝即可。

$yuan$ 里的 $l,r$ :对应的正方形的左下角和右上角的坐标。

$shu$ 里的 $l,r$ :子树里正方形 $x,y$ 坐标的最小值和最大值。

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#define int long long
#define lson tr[k].ls
#define rson tr[k].rs
using namespace std;
int n, nowk, cnt, root;
const int N = 300010;
int s[N], ans[N];
struct dian {int x, y;};
struct yuan {int x, y, R, id; dian l, r;} cir[N];
struct shu {int ls, rs, id; dian l, r;} tr[N];
int my1(yuan a, yuan b) {return a.R == b.R ? a.id<b.id: a.R>b.R;}
int my2(int a, int b) {return nowk ? cir[a].x < cir[b].x : cir[a].y < cir[b].y;}
void pushup(int k)
{
	tr[k].l = cir[tr[k].id].l; tr[k].r = cir[tr[k].id].r;
	if (lson)tr[k].l.x = min(tr[k].l.x, tr[lson].l.x), tr[k].l.y = min(tr[k].l.y, tr[lson].l.y), tr[k].r.x = max(tr[k].r.x, tr[lson].r.x), tr[k].r.y = max(tr[k].r.y, tr[lson].r.y);
	if (rson)tr[k].l.x = min(tr[k].l.x, tr[rson].l.x), tr[k].l.y = min(tr[k].l.y, tr[rson].l.y), tr[k].r.x = max(tr[k].r.x, tr[rson].r.x), tr[k].r.y = max(tr[k].r.y, tr[rson].r.y);
}
void build(int &k, int l, int r, int now)
{
	if (l > r)return;
	int mid = (l + r) >> 1;
	nowk = now; nth_element(s + l, s + mid, s + r + 1, my2);
	k = ++cnt; tr[k].id = s[mid];
	build(lson, l, mid - 1, now ^ 1); build(rson, mid + 1, r, now ^ 1);
	pushup(k);
}
int p2(int x) {return x * x;}
int jiao(int i, int j) {return p2(cir[i].x - cir[j].x) + p2(cir[i].y - cir[j].y) <= p2(cir[i].R + cir[j].R);}
void change(int k, int id)
{
	if (!k)return;
	if (cir[id].r.x < tr[k].l.x || tr[k].r.x < cir[id].l.x || cir[id].r.y < tr[k].l.y || tr[k].r.y < cir[id].l.y)return;
	if (!ans[cir[tr[k].id].id] && jiao(tr[k].id, id))ans[cir[tr[k].id].id] = cir[id].id;
	if (lson)change(lson, id); if (rson)change(rson, id);
}
signed main()
{
	cin >> n;
	for (int i = 1; i <= n; ++i)
	{
		scanf("%lld%lld%lld", &cir[i].x, &cir[i].y, &cir[i].R);
		cir[i].l.x = cir[i].x - cir[i].R; cir[i].l.y = cir[i].y - cir[i].R; cir[i].r.x = cir[i].x + cir[i].R; cir[i].r.y = cir[i].y + cir[i].R;
		cir[i].id = i; s[i] = i;
	}
	sort(cir + 1, cir + 1 + n, my1); build(root, 1, n, 0);
	for (int i = 1; i <= n; ++i)
		if (!ans[cir[i].id])change(root, i);
	for (int i = 1; i <= n; ++i)printf("%lld ", ans[i]);
	return 0;
}
``` 

然而 $uoj$ 和 $loj$ 上有 $hack$ 数据，我们只要充分发挥人类智慧旋转一下坐标系就行了。记得开 $long \space double$.[代码在这](http://uoj.ac/submission/390647)

---

## 作者：OldDriverTree (赞：0)

感觉这个题很妙啊。

这篇题解主要讲解 $O(n\log R)$ 的做法。

# Solution

直接按照题意模拟是 $O(n^2)$ 的，考虑优化，假设当前最大的圆半径为 $R$，那么我们把整个平面以 $2R$ 为边长划分多个格子，那么如果两个圆相交，他们的圆心距离一定不超过 $2R$，所以我们只需要处理圆心在周围 $9$ 个格子中的圆。每次如果当前处理的圆半径小于 $\dfrac R2$，就把 $R$ 设为当前圆的半径进行重构，这样只会重构 $O(\log R)$ 次。

然后分析一下时间复杂度：在划分的边长为 $2R$ 时，我们会处理所有半径大于等于 $\dfrac R2$ 的圆，而对于一个格子，只有 $O(1)$ 个圆会被自己删掉，所以一个圆在一次划分中只会被检查 $O(1)$ 次，因此总时间复杂度可以做到 $O(n\log R)$（需要精细实现）。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDriverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
//using mint=modint998244353;
const int N=3e5+1;
map<P,vector<int> > a;
int n,x[N],y[N],r[N],p[N];
int now,ans[N];

struct custom_hash
{
    static uint64_t splitmix64(uint64_t x) {
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
        x=(x^(x>>27) )*0x94d049bb133111eb;
        return x^(x>>31);
    }
    size_t operator() (uint64_t x) const {
        static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x+FIXED_RANDOM);
    }
};
int read() {
    int x=0; bool _=true; char c=0;
    while (!isdigit(c) ) _&=(c!='-'),c=getchar();
    while (isdigit(c) ) x=x*10+(c&15),c=getchar();
    return _?x:-x;
}
bool check(int p,int q) {
    return (x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q])<=(r[p]+r[q])*(r[p]+r[q]);
}
main()
{
    n=read(); for (int i=1;i<=n;i++) x[i]=read(),y[i]=read(),r[i]=read(),p[i]=i;
    sort(p+1,p+n+1,[&](int x,int y){ return r[x]^r[y]?r[x]>r[y]:x<y; });
    for (int _=1;_<=n;_++)
    {
        int pos=p[_];
        if (ans[pos]) continue;
        if (!now||r[pos]*2<now/2) {
            now=r[pos]*2,a.clear();
            for (int i=1;i<=n;i++) if (!ans[i])
            a[{x[i]/now,y[i]/now}].push_back(i);
        }
        int px=x[pos]/now,py=y[pos]/now;
        for (int p=px-1;p<px+2;p++)
            for (int q=py-1;q<py+2;q++)
                if (a.find({p,q})!=a.end() ) {
                    vector<int> awa;
                    for (int x:a[{p,q}])
                    if (check(x,pos) ) ans[x]=pos;
                    else awa.push_back(x); a[{p,q}]=awa;
                }
    }
    for (int i=1;i<=n;i++)
    printf("%lld ",ans[i]);
    return 0;
}
```

---

## 作者：zesqwq (赞：0)

# P4631 [APIO2018] 选圆圈 题解

[题目传送门](https://www.luogu.com.cn/problem/P4631)

看到题目，是平面上的操作。我们会什么数据结构呢？

二维线段树？它显然不能维护与圆形有关的操作。

于是我们使用 $\text{K-D Tree}$ 来维护这个东西。

与一般 $\text{K-D Tree}$ 不同的是，一个子树所对应的矩形，并不是包含所有圆心的矩形，而是包含所有圆的矩形。

然后我们如何使用这个 $\text{K-D Tree}$ 如何剪枝？

首先想到的肯定是包含关系，即如果你要查询的圆包含当前整个子树，直接将子树便利然后删光。但是我们发现这东西一点用都没有，因为你一起删也是删，一个个删也是删，根本无法优化。

然后我们就想到了判断两个圆是否相交的公式 $(r_1 + r_2)^2 \ge (x_2-x_1) ^2+(y_2-y_1)^2$，我们发现这个公式的含义实际上是判断两点间距离和半径的关系。于是我们可以使用你要查询的圆的圆心到其子树所对应矩形的距离剪枝。

然后就可以 $\text{AC}$ 了。

$\text{Code}$

```cpp
#include <bits/stdc++.h>
#define lc(x) (w[x].ls)
#define rc(x) (w[x].rs)
using namespace std;
const double alpha = 0.7;
constexpr int N = 3e5 + 10;
struct Point {
    long long x, y, r;
    int ls, rs, siz, delsiz, id, bedel, d, maxpos;
    long long L, R, U, D;
    inline void read() { scanf("%lld %lld %lld", &x, &y, &r); }
    inline bool operator>(const Point &b) const { return r != b.r ? r > b.r : id < b.id; }
} w[N];
int g[N], total, n, delby[N];
inline double sqr(double x) { return x * x; }
inline long long sqr(long long x) { return x * x; }
inline long long sqr(int x) { return 1ll * x * x; }
inline bool bad(int x) { return (w[x].siz - w[x].delsiz) <= w[x].siz * alpha || (alpha * w[x].siz <= max(w[lc(x)].siz, w[rc(x)].siz)); }
inline bool cmp1(int x, int y) { return w[x].x < w[y].x; }
inline bool cmp2(int x, int y) { return w[x].y < w[y].y; }
void print(int u) {
    if (!u) return;
    print(lc(u));
    if (!w[u].bedel) g[++total] = u;
    print(rc(u));
}
inline void delNode(int &u) { w[u] = {}, u = 0; }
inline void pushup(int &u) {
    w[u].siz = w[lc(u)].siz + w[rc(u)].siz + 1;
    w[u].delsiz = w[lc(u)].delsiz + w[rc(u)].delsiz + w[u].bedel;
    if (w[u].delsiz == w[u].siz) {
        delNode(u);
        return;
    }
    if (!w[u].bedel) {
        w[u].maxpos = u;
        w[u].L = w[u].x - w[u].r, w[u].R = w[u].x + w[u].r;
        w[u].D = w[u].y - w[u].r, w[u].U = w[u].y + w[u].r;
    } else {
        w[u].maxpos = 0;
        w[u].L = w[u].D = 1000000000000000000ll;
        w[u].R = w[u].U = -1000000000000000000ll;
    }
    if (lc(u)) {
        w[u].L = min(w[u].L, w[lc(u)].L), w[u].R = max(w[u].R, w[lc(u)].R);
        w[u].D = min(w[u].D, w[lc(u)].D), w[u].U = max(w[u].U, w[lc(u)].U);
        if (w[w[lc(u)].maxpos] > w[w[u].maxpos]) w[u].maxpos = w[lc(u)].maxpos;
    }
    if (rc(u)) {
        w[u].L = min(w[u].L, w[rc(u)].L), w[u].R = max(w[u].R, w[rc(u)].R);
        w[u].D = min(w[u].D, w[rc(u)].D), w[u].U = max(w[u].U, w[rc(u)].U);
        if (w[w[rc(u)].maxpos] > w[w[u].maxpos]) w[u].maxpos = w[rc(u)].maxpos;
    }
}
int build(int l, int r) {
    if (l > r) return 0;
    int mid = l + r >> 1;
    double av1 = 0, av2 = 0, va1 = 0, va2 = 0;
    for (int i = l; i <= r; i++) av1 += w[g[i]].x, av2 += w[g[i]].y;
    av1 /= r - l + 1, av2 /= r - l + 1;
    for (int i = l; i <= r; i++) va1 += sqr(w[g[i]].x - av1), va2 += sqr(w[g[i]].y - av2);
    if (va1 > va2)
        nth_element(g + l, g + mid, g + r + 1, cmp1), w[g[mid]].d = 1;
    else
        nth_element(g + l, g + mid, g + r + 1, cmp2), w[g[mid]].d = 2;
    lc(g[mid]) = build(l, mid - 1), rc(g[mid]) = build(mid + 1, r);
    pushup(g[mid]);
    return g[mid];
}
inline void rebuild(int &u) { total = 0, print(u), u = build(1, total); }
inline bool meet(const Point &a, const Point &b) { return sqr(a.r + b.r) >= sqr(a.x - b.x) + sqr(a.y - b.y); }
inline long long dis(const Point &a, const Point &b) { return sqr(a.x - b.x) + sqr(a.y - b.y); }
inline long long f(int u, const Point &b) {
    long long ret = 0;
    if (w[u].L > b.x) ret += sqr(w[u].L - b.x);
    if (b.x > w[u].R) ret += sqr(b.x - w[u].R);
    if (w[u].D > b.y) ret += sqr(w[u].D - b.y);
    if (b.y > w[u].U) ret += sqr(b.y - w[u].U);
    return ret;
}
void del(int &u, Point x) {
    if (!u) return;
    if (f(u, x) > sqr(x.r)) return;
    if (!w[u].bedel && meet(w[u], x)) w[u].bedel = 1, delby[w[u].id] = x.id;
    del(lc(u), x), del(rc(u), x);
    pushup(u);
    if (!u) return;
    if (bad(u)) rebuild(u);
}
int rt;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) w[i].read(), g[i] = i, w[i].id = i;
    rt = build(1, n);
    while (rt) del(rt, w[w[rt].maxpos]);
    for (int i = 1; i <= n; i++) printf("%d ", delby[i]);
    return 0;
}
```

---

## 作者：Treaker (赞：0)

我们暴力的思想肯定是，枚举一个当前没有被删除的最大的圆，来操作。这样是$O(n^2)$

那么考虑优化枚举，我们可以把圆按照半径从大到小来排序。那就就从前往后枚举即可。

再考虑怎么删除过程。我们可以用KD-Tree来优化。就是，我们把圆想象成一个矩形，那么如果这两个矩形都没有交集的话，圆也肯定没有交集。所以，我们可以得到一个估价函数。那么通过了这个估价函数之后，我们就可以直接判断两个圆是否相交了。

具体细节可以看代码：

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
namespace IO
{
	char buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];
	#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)
	#define gt() getchar()
	inline int read()
	{
		int x = 0 , f = 1; char ch = gt();
		while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = gt();}
		while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}
		return x * f;
	}
	template <class T> inline void write(T x)
	{
		if(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');
		if(x < 0) *f3 ++ = '-' , x = ~x + 1;
		char *top = sta;
		while(x) *top ++ = x % 10 + 48 , x /= 10;
		while(top != sta) *f3 ++ = *-- top;
		*f3 ++ = ' ';
	}
	inline void put(std::string s)
	{
		int len = s.length();
		for(int i = 0;i < len;i ++) *f3 ++ = s[i];
		*f3 ++ = ' ';
	}
	inline void endline() { *f3 ++ = '\n';}
	#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)
	template <class T> inline T abs(T a) { return a < 0 ? -a : a;}
	template <class T> inline T max(T a,T b) { return a > b ? a : b;}
	template <class T> inline T min(T a,T b) { return a < b ? a : b;}
	template <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}
}
using namespace IO;
const int N = 3e5 + 5;
const long double eps = 1e-5 , Cos = cos(2.33) , Sin = sin(2.33);
int n , d;
int ans[N];
struct point 
{
	long double x[2] , r; int id;
} p[N];
inline bool operator < (const point &a,const point &b) { return a.x[d] < b.x[d];}
inline bool cmp(const point &a,const point &b) { return a.r == b.r ? a.id < b.id : a.r > b.r;}
inline long double sqr(long double x) { return x * x;}
namespace SMT
{
	struct node
	{
		node *ls , *rs; long double maxn[2] , minn[2]; point tr;
		node(point tr = p[0]) : tr(tr) { ls = rs = NULL; memset(maxn,0,sizeof maxn); memset(minn,0,sizeof minn);}
		inline void up()
		{
			for(int i = 0;i <= 1;i ++)
			{
				maxn[i] = tr.x[i] + tr.r; minn[i] = tr.x[i] - tr.r;
				if(ls) maxn[i] = max(maxn[i],ls -> maxn[i]) , minn[i] = min(minn[i],ls -> minn[i]);
				if(rs) maxn[i] = max(maxn[i],rs -> maxn[i]) , minn[i] = min(minn[i],rs -> minn[i]);
			}
		}
		inline bool check1(point k)
		{
			if(k.x[0] + k.r < minn[0] + eps) return 1;
			if(k.x[0] - k.r > maxn[0] - eps) return 1;
			if(k.x[1] + k.r < minn[1] + eps) return 1;
			if(k.x[1] - k.r > maxn[1] - eps) return 1;
			return 0;
		}
		inline bool check2(point k)
		{
			return sqr(tr.r + k.r) + eps >= sqr(tr.x[0] - k.x[0]) + sqr(tr.x[1] - k.x[1]);
		}
	} *root , pool[N] , *tail = pool;
	void build(node *&o,int l,int r,int op)
	{
		if(l > r) return; int mid = (l + r) >> 1;
		d = op; std::nth_element(p + l,p + mid,p + r + 1);
		o = new (tail ++) node(p[mid]);
		build(o -> ls,l,mid - 1,op ^ 1); build(o -> rs,mid + 1,r,op ^ 1);
		o -> up();
	}
	void query(node *o,point k)
	{
		if(o -> check1(k)) return ;
		if(!ans[o -> tr.id] && o -> check2(k)) ans[o -> tr.id] = k.id;
		if(o -> ls) query(o -> ls,k);
		if(o -> rs) query(o -> rs,k);
	}
}
using namespace SMT;
int main()
{
	n = read();
	for(int i = 1;i <= n;i ++)
	{
		long double x = read() , y = read(); 
		p[i].x[0] = x * Cos - y * Sin; p[i].x[1] = x * Sin + y * Cos; p[i].r = read() , p[i].id = i;
	} 
	build(root,1,n,0);
	std::sort(p + 1,p + 1 + n,cmp);
	for(int i = 1;i <= n;i ++) if(!ans[p[i].id]) query(root,p[i]);
	for(int i = 1;i <= n;i ++) printf("%d ",ans[i]);
	return 0;
}
```


---


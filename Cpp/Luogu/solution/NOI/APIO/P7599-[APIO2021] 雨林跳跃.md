# [APIO2021] 雨林跳跃

## 题目背景

本题只支持 C++ 提交，不支持 C++14 (GCC 9)，提交时不需要包含 jumps.h 头文件，只需要将附件中的 jumps.h 中的内容粘贴到代码的开头即可。

由于洛谷的测试点限制，本题只能评测其中的 100 组数据。

## 题目描述

在苏门答腊岛的热带雨林中，有 $N$ 棵树排成一排，从左到右依次用 $0$ 到 $N-1$ 进行编号，其中 $i$ 号树的高度为 $H[i]$，且所有树的高度**互不相同**。

Pak Dengklek 正在训练一只猩猩，让她能够从一棵树上跳到另一棵树上。对于一次跳跃，猩猩可以从一棵树，向左或向右跳到比当前这棵树高的第一棵树上。形式化地，如果猩猩当前在 $x$ 号树，那么当且仅当满足下列条件之一时，她能够跳到 $y$ 号树上：

- $y$ 是满足 $H[z]>H[x]$ 的所有 $z$ 中比 $x$ 小的最大非负整数；或者：
- $y$ 是满足 $H[z]>H[x]$ 的所有 $z$ 中比 $x$ 大的最小非负整数。

Pak Dengklek 有 $Q$ 个跳跃计划，每个计划用四个整数 $A$，$B$，$C$ 和 $D$（$A \le B<C \le D$）来描述。对于每个计划，Pak Dengklek 想知道猩猩是否能够从某棵树 $s$（$A \le s \le B$）出发，经过若干次跳跃，到达某棵树 $e$（$C \le e \le D$）。若该计划可行，Pak Dengklek 还想知道可行方案中猩猩需要的最少跳跃次数。

你需要实现下列函数：

`void init(int N, int[] H)`

- $N$：树的数量。
- $H$：大小为 $N$ 的数组，$H[i]$ 表示 $i$ 号树的高度。
- 该函数在第一次 `minimum_jumps` 的调用前，将会被调用恰好一次。

`int minimum_jumps(int A, int B, int C, int D)`

- $A,B$：可以用作起点的树的编号范围。
- $C,D$：可以用作终点的树的编号范围。
- 该函数需要返回可行方案中猩猩需要的最少跳跃次数，或者返回 $-1$ 表示该计划不可行。
- 该函数将被调用恰好 $Q$ 次。

## 说明/提示

**【样例解释】**

考虑如下调用： 

`init(7, [3, 2, 1, 6, 4, 5, 7])`

在初始化完成后，考虑如下调用：

`minimum_jumps(4, 4, 6, 6)`

该计划意味着猩猩必须从 $4$ 号树（高度为 $4$）出发，并到达 $6$ 号树（高度为 $7$）。

一种跳跃次数最少的可行方案为：先跳到 $3$ 号树（高度为 $6$），再跳到 $6$ 号树。

另一种方案为：先跳到 $5$ 号树（高度为 $5$），再跳到 $6$ 号树。

因此，`minimum_jumps` 应该返回 $2$。

考虑另一个调用：

`minimum_jumps(1, 3, 5, 6)`

该计划意味着猩猩必须从 $1$ 号树（高度为 $2$），$2$ 号树（高度为 $1$），或 $3$ 号树（高度为 $6$）之一出发，并最终到达 $5$ 号树（高度为 $5$）或者 $6$ 号树（高度为 $7$）。

唯一一种跳跃次数最少的可行方案为：从 $3$ 号树出发，直接跳到 $6$ 号树。

因此，`minimum_jumps` 应该返回 $1$。

考虑另一个调用：

`minimum jumps(0, 1, 2, 2)`

该计划意味着猩猩必须从 $0$ 号树（高度为 $3$）或者 $1$ 号树（高度为 $2$）出发，并最终到达 $2$ 号树（高度为 $1$）。

由于 $2$ 号树是高度最低的树，所以无法从其他树上跳到 $2$ 号树。

因此，`minimum_jumps` 应该返回 $-1$。

**【数据范围】**

- $2 \le N \le 2 \times {10}^5$。
- $1 \le Q \le {10}^5$。
- $1 \le H[i] \le N$（$0 \le i \le N - 1$）。
- $H[i]\ne H[j]$（$0 \le i<j \le N - 1$）。
- $0 \le A \le B<C \le D \le N - 1$。

**【子任务】**

1. （4 分）：$H[i]=i+1$（$0 \le i \le N-1$）。
2. （8 分）：$N,Q \le 200$。
3. （13 分）：$N,Q \le 2000$。
4. （12 分）：$Q \le 5$。
5. （23 分）：$A=B$，$C=D$。
6. （21 分）：$C=D$。
7. （19 分）：无附加限制。

## 样例 #1

### 输入

```
7 3
3 2 1 6 4 5 7
4 4 6 6
1 3 5 6
0 1 2 2
```

### 输出

```
2
1
-1
```

# 题解

## 作者：Qiiiiiii_ (赞：22)


​		(下文中 $\max[s,t]$ 表示区间 $[s,t]$ 中最大值，出于方便，$A/B/C/D$ 可能表示端点或者点值，请根据语境判断 )

​		对于每个点左右可跳到的点直接二分+$ST$ 表求区间最值可以做到 $O(n\log n)$ ，当然，你也可以用线段树上二分完成此部分，时间复杂度依旧是 $O(n\log n)$ 。接下来跟着数据思考即可。

​		先抛开最优解要求，我们思考如何构造一组合法解。取出 $[A,B]$ 的右端点 $B$ ，然后一直往右边跳，如果能到达 $[C,D]$ 即有解。该策略在 $\max [B,C-1] < \max[C,D]$ 时一定可行。反之，在不满足上述条件的情况， $[A,B]$  之间任意一个值跳的时候都会被 $[B,C-1]$ 中某一个值给挡住，或者直接越过 $[C,D]$ 这个区间。

​		那么，有解的充要条件就是 $\max[B,C-1]<\max[C,D]$ 。

​		根据上述策略构造出的解不一定是最优的，我们来思考如何优化我们的策略。我们优先考虑 $A=B,C=D$ 的情况 。我们从 $A$ 起跳的时候，跳到的任何一个柱子都不能高于 $C$ ，否则就会导致无法到达 $C$ 。在保证每次跳的柱子不超过 $C$ 的情况下，我们优先跳更高的那个柱子(由于更高的柱子接下来可以跳跃的位置包含较低的柱子，这显然不会使答案变劣)。当我们无法跳更高的柱子的时候，我们就可以一心一意地往右跳(这个情况的决策已经非常单一了)。

​		我们将每个点可以跳到的更高的柱子视为其父亲，上述策略第一步就相当于树上倍增。而第二步则是序列上倍增。用两个倍增数组即可实现。这一步的时间复杂度是 $O(q\log n)$ 。

​		接下来，我们将问题扩展到 $A\neq B$ 的情况。根据贪心思想容易想到，我们只需要 $\max [A,B]$ 。但这个值并不一定对，因为可能 $\max[A,B]>C$ ，这就会导致我们无法达到目标位置。所以，在贪心之前，我们得先保证所选起点合法，其次才是贪心取最大值。由于要往右跳，所以合法区间一定是原区间的一段后缀。对于一段区间 $[X,B]$ ，若 $\max[X,B]<C$ ，那么这段区间一定全部合法。二分找出最长后缀，然后在这个后缀中取最大值即可。这一步是在线段树上二分，所以时间复杂度依旧是 $O(q\log n)$ 。(考场上，在预处理阶段，由于我懒得写 $ST$ 表求区间最值反而用线段树上二分写了这一部分，为了防止我调用混淆，我就没写线段树上二分，直接朴素的二分+线段树，时间复杂度是 $O(q\log^2 n)$ ，本题时限开得很大，所以我就很放心的牺牲了一点时间复杂度 )

​		最后，我们只需要将问题扩展到 $C\neq D$ 的情况。这个时候，我们发现有效的值似乎也只有 $\max [C,D]$ 。但如果我们拿这个最大值套用上述的策略又会出现一个小问题：可能我已经能跳到了 $[C,D]$ 之间，但我却一直盯着最大值，这样会导致答案变劣。这里就不得不修正决策中第一次在树上倍增中所选定的筏值：这里更准确来说不是 $\max[C,D]$，而是 $\max[B,C-1]$ 。当我们即将越过这个筏值的时候也就表明我们将获得答案(在 $C=D$ 的情况下，这个筏值和 $C$ 几乎等价)。

​		综合上面所有的写法即可拿到满分，总时间复杂度 $O(p\log n)$，给出的代码的时间复杂度是 $O(p\log^2n)$ (少写了一个线段树上二分)。

​		(赛时调试了不少时间，代码写得很丑，读起来可能很痛苦，而且该写法时间复杂度不是很优秀，~~由于评测机的关心，我直到出成绩之前都不知道自己过了~~ )



```cpp
#include<bits/stdc++.h>
#define ll long long
#define FOR(i,a,b) for(int i=(a),i##i=(b);i<=i##i;++i)
#define ROF(i,a,b) for(int i=(a),i##i=(b);i>=i##i;--i)
using namespace std;
const int N=2e5+10;
typedef vector<int> VT;
void init(int N, std::vector<int> H);
int minimum_jumps(int A, int B, int C, int D);
int n,tzb[N],mx[N<<2],inf;
VT h;
#define ls (rt<<1)
#define rs (rt<<1|1)
void build(int rt,int l,int r){
	if(l==r) return mx[rt]=h[l],void();
	int mid=(l+r)>>1;
	build(ls,l,mid),build(rs,mid+1,r);
	mx[rt]=max(mx[ls],mx[rs]);
}
int ask_max(int rt,int l,int r,int L,int R){
	if(L>R) return 0;
	if(L<=l&&r<=R) return mx[rt];
	int mid=(l+r)>>1,as=0;
	if(L<=mid) as=max(as,ask_max(ls,l,mid,L,R));
	if(R>mid) as=max(as,ask_max(rs,mid+1,r,L,R));
	return as;
}
int res;
void dfs_nxt(int rt,int l,int r,int k){
	if(mx[rt]<=k) return ;
	if(l==r) return res=l,void();
	int mid=(l+r)>>1;
	if(mx[ls]>k) dfs_nxt(ls,l,mid,k);
	else dfs_nxt(rs,mid+1,r,k);
	return ;
}
void ask_nxt(int rt,int l,int r,int L,int R,int k){
	if(L>R) return ;
	if(L<=l&&r<=R) return dfs_nxt(rt,l,r,k);
	int mid=(l+r)>>1;
	if(L<=mid) ask_nxt(ls,l,mid,L,R,k); 
	if(R>mid&&res==inf) ask_nxt(rs,mid+1,r,L,R,k); 
	return ;
}
void dfs_pre(int rt,int l,int r,int k){
	if(mx[rt]<=k) return ;
	if(l==r) return res=l,void();
	int mid=(l+r)>>1;
	if(mx[rs]>k) dfs_pre(rs,mid+1,r,k);
	else dfs_pre(ls,l,mid,k);
	return ;
}
void ask_pre(int rt,int l,int r,int L,int R,int k){
	if(L>R) return ;
	if(L<=l&&r<=R) return dfs_pre(rt,l,r,k);
	int mid=(l+r)>>1;
	if(R>mid) ask_pre(rs,mid+1,r,L,R,k); 
	if(L<=mid&&res==inf) ask_pre(ls,l,mid,L,R,k); 
	return ;	
}
int fa[21][N],nx[21][N],tp2[N],dep[N],dep2[N],root;
VT tr[N],ed[N];
void dfs(int u){
	dep[u]=dep[fa[0][u]]+1;
	int z=tr[u].size(),v=0;
	FOR(i,0,z-1){
		v=tr[u][i];
		dfs(v);
	}
	return ;
} 
void dfs2(int u){
	dep2[u]=dep2[nx[0][u]]+1;
	int z=ed[u].size(),v=0;
	FOR(i,0,z-1){
		v=ed[u][i];
		dfs2(v);
	}
	return ;
} 
void init(int nn,VT hh){
	n=nn-1,h=hh,inf=n+2;
	h.push_back(0),h.push_back(0),h.push_back(0);
	FOR(i,0,n) tzb[h[i]]=i,fa[0][i]=-1,nx[0][i]=i;
	build(1,0,n);
	FOR(i,0,n){
		int f1=0,f2=0;
		res=inf,ask_pre(1,0,n,0,i-1,h[i]),f1=res;
		res=inf,ask_nxt(1,0,n,i+1,n,h[i]),f2=res;
		if(h[f1]>h[f2]) fa[0][i]=f1,tr[f1].push_back(i);
		else fa[0][i]=f2,tr[f2].push_back(i);
		if(f1==inf&&f2==inf) fa[0][i]=i;
		if(f2!=inf) nx[0][i]=f2,ed[f2].push_back(i);
	}
	FOR(i,0,n) if(fa[0][i]==i) root=i;
	FOR(i,0,n) if(nx[0][i]==i) dfs2(i);
	dfs(root);
	FOR(k,1,18) FOR(i,0,n) fa[k][i]=fa[k-1][fa[k-1][i]],nx[k][i]=nx[k-1][nx[k-1][i]];
	return ;
}
int ans;
void cal(int u,int C,int w1,int w2){
	int v=u;
	ROF(k,18,0) if(h[fa[k][v]]<=w1) v=fa[k][v];
	if(nx[0][v]<C&&h[fa[0][v]]<=w2) v=fa[0][v];
	ans=dep[u]-dep[v];
	if(v>=C) return ;
	u=v;
	ROF(k,18,0) if(nx[k][v]<C) v=nx[k][v];
	v=nx[0][v];
	ans+=dep2[u]-dep2[v];
	return ;
}
int minimum_jumps(int A, int B, int C, int D) {
	int mx1=ask_max(1,0,n,B,C-1),mx2=ask_max(1,0,n,C,D);
  	if(mx1>mx2) return -1;
	int l=A,r=B,mid=0,as=inf;
	while(l<=r){
		mid=(l+r)>>1;
		if(ask_max(1,0,n,mid,B)<mx2) r=mid-1,A=mid;
		else l=mid+1;
	}
	int us=ask_max(1,0,n,A,B),nw=tzb[us];
	cal(nw,C,mx1,mx2),as=ans;
	return as;
}
//7 3
//1 2 6 3 4 5 7
//3 3 6 6
//1 3 5 6
//0 1 2 2

//7 3
//3 2 1 6 4 5 7
//4 4 6 6
//1 3 5 6
//0 1 2 2

```



---

## 作者：Miko35 (赞：18)

### 题意

给你一个长度为 $n$ 的排列，一次跳跃可以跳到当前位置前或后面第一个比他大的数，$q$ 次询问从 $[a,b]$ 任意一点出发跳到 $[c,d]$ 任意一点的最小步数。（$n,q \leq 2\times 10^5$, $a<b \leq c<d$）

### 题解

先判断有没有解，我一定要经过 $[b,c-1]$ 这个区间，经过之后我一定 $\ge \max(b,c-1)$。我记 $X=\max(b,c-1),Y=\max(c,d)$，那最好的情况就是从 $b$ 开始往右一直跳，所以 $X>Y$ 就寄了。

不妨把问题看做：你一次可以往左或右跳一步，并且比当前位置矮的柱子都消失。这样不难理解两个结论：

- 起点是 $[a,b]$ 中最大值；
- 每次一定跳左右两边更高的一个。

**注意以上两句话成立的条件都是有解。** 当我们在左边跳到已经 $\in [X,Y)$ 的时候，就可以一步飞到 $[c,d]$ 里面去，就是说我要算跳多少步才能比 $X$ 更高，在此过程中上面两句话显然都是成立的。

那么策略就清晰了，假设两边更高的高度为 $h$：

- $h \leq X$ 则直接跳到 $h$；
- $h \in [X,Y)$，则立刻花 $1$（$h$ 的位置在 $[c,d]$ 中）或 $2$（先跳到 $h$ 再一步到 $[c,d]$）步做完；
- $h \ge Y$，此时 $h$ 一定是左边那个，则此后只能一直往右直到跳进 $[c,d]$。

上述过程可以倍增处理，时空复杂度均为 $O((n+q)\log n)$。

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a,i##i=b;i<=i##i;++i)
#define ROF(i,a,b) for(int i=a,i##i=b;i>=i##i;--i)
using namespace std;
const int N=3e5+7;
int n,a[N],st[19][N],S[19][N],q[N],h,X,Y,to[19][N],rs;
inline int Max(int x,int y){return a[x]<a[y]?y:x;}
int qry(int l,int r){
	int k=__lg(r-l+1);
	return Max(st[k][l],st[k][r-(1<<k)+1]);
}
void init(int M,vector<int>H){
	FOR(i,1,n=M)a[st[0][i]=i]=H[i-1];
	FOR(i,1,n){
		while(h&&a[q[h]]<a[i])S[0][q[h--]]=i;
		q[++h]=i;
	}
	h=0;
	ROF(i,n,1){
		while(h&&a[q[h]]<a[i])to[0][q[h--]]=i;
		q[++h]=i;
	}
	FOR(i,0,n)to[0][i]=Max(to[0][i],S[0][i]);
	FOR(w,1,18)FOR(i,0,n-(1<<w)+1){
		st[w][i]=Max(st[w-1][i],st[w-1][i+(1<<(w-1))]);
		S[w][i]=S[w-1][S[w-1][i]],to[w][i]=to[w-1][to[w-1][i]];
	}
}
int minimum_jumps(int x,int y,int l,int r){
	X=a[qry(++y,l++)],Y=a[qry(l,++r)],rs=0,++x;
	if(X>Y)return -1;
	int p=y;
	ROF(i,18,0)if((h=p-(1<<i))>=x&&a[st[i][h]]<Y)p=h;
	x=qry(p,y);
	ROF(i,18,0)if(a[h=to[i][x]]<X&&h)x=h,rs+=(1<<i);
	if(S[0][x]>=l)return rs+1;
	if(a[to[0][x]]<Y)return rs+2;
	ROF(i,18,0)if((h=S[i][x])<l&&h)x=h,rs+=(1<<i);
	return rs+1;
}
```


---

## 作者：Gary88 (赞：10)

 考试时拿了 81pts ，考后我口胡了一个做法，自己觉得没什么问题，不知道对不对，希望各位大佬轻踩。

------------
首先思考给定两个点作为起点和终点如何判断是否有解及最优解。

判断是否有解，因为 $A \le B < C \le D $ ，所以我们在这里只讨论 $x<y$ ，从 $x$ 走到 $y$ 的情况。

易证可行当且仅当 $[x,y)$ 中的所有点高度都小于 $y$ 的高度。

证明：如果满足此条件，则不停向右走一定能走到，如果不满足此条件，不存在一种方法绕过那个比 $y$ 高的点，且无法从这个点向下走到达 $y$ ， QED 。

接下来思考确定有解后有什么办法求最优解，~~暴力！！！~~
我们很难找到一种 $O(1)$ 的做法（~~至少我没找到~~)，而暴力又不太现实，我们把目光放到 $O(\log n)$ 上，想到向上跳的最小次数，我们自然而然地想到~~线段树~~倍增，但是我们不能简单的往一个方向倍增，于是我们想到每次在左右能跳的树中跳更高的那一个，但是这样可能跳得过高，所以我们要找到再跳一次更高点以后就会超过 $y$ 的那个点，我们从这里开始一直向右跳，而不是跳左右更高点，这两个倍增可以用单调栈维护。

如果暴力枚举左右端点判断能拿到 $35pts$ 的好成绩（算第一个点），我们考虑优化，假设我们现在已经确定了右端点，我们找到它左边第一个高于它的位置 $k$ ，分类讨论，如果 $k\ge B$ 说明无解，否则最优的左端点一定是 $[\max(k+1,A),B]$ 中的最高点，这是符合直觉的，这样我们的复杂度就变成了 $O(q(D-C+1)\log n)$ ，能过除了最后一个点以外的所有点，这也是考试时我拿到的 81pts 。



------------
#### ~~从这里开始就是我口胡的内容了~~。UPD:已经A了

我们先找到 $[C.D]$ 中最小的有解的点，这可以通过找到 $[B,C)$ 中的最大值 $MIN$ ，再找到 $[C,D]$ 中最小的大于 $MIN$ 的数就可以了，这可以用~~树套树~~ ~~主席树~~ 预处理过的右侧第一个大于x的点解决，然后我们找到以这个点作为右端点的最优解。

然后是重点：若最小的可行右端点为 $y$ ，我们找到它左边第一个大于它的位置 $k$ ，再找到 $k$ 右边第一个大于$k$的位置 $s$ ， $s$ 就是除了 $y$ 以外的唯一可能最优右端点位置。

证明：

我们思考不经过 $k$ 的情况下， $y$ 一定是最优解，因为我们知道 $(k,y)$ 中的所有数都小于 $y$ 且小于 $k$ ，那么在不经过 $y$ 和 $k$ 的情况下，是不可能跳到大于 $y$ 的位置的，如果经过 $y$ ，那么在 $y$ 停止一定更优。


------------
UPD:一位同学提醒我少讨论了一种情况，在这里加上，如果 $k>A$ ，那么如果存在 $[A,k)$ 中的点能够到达 $[C,D]$ ，那么它到达的点一定高于 $k$ ，否则不满足我之前说的有解条件，那么我们现在知道 $(k,y)$ 中所有数都低于 $k$ ，且 $[C,D]$ 中存在一个点高于 $k$ ，那么一定存在一个点可以从 $k$ 一次跳过去，因为 $C<D$ ， $1$ 可以被证明是答案的下界，所以一定存在一个从 $k$ 出发的最优解，且它到达的就是 $s$


------------

接着考虑经过 $k$ 的情况，首先 $s$ 一定大于 $y$ ，那么如果 $s>D$ ，则说明 $[C,D]$ 中所有数都小于 $k$ 位置的数， $k$ 一定无法到达 $[C,D]$ 中的点，如果 $s\le D$ ，那么从 $k$ 一次就能到达 $s$ ，一定不会存在更优的跳法了，所以最优解的右端点只可能在 $y$ 或 $s$ ，QED。

这样，我们只要再 $O(\log n)$ 查询一次就可以了，时间复杂度 $O(q\log n)$。


------------
UPD(2021/5/27):有数据了，我写了一下，成功A掉，附上AC代码
```cpp
#include <bits/stdc++.h>
#define fir(i,a,b,...) for (int i = (a), ##__VA_ARGS__; i <= (b); ++i)
#define firr(i,a,b,...) for (int i = (a), ##__VA_ARGS__; i >= (b); --i)
template<class T1, class T2> T1& cmax (T1& a, const T2& b) {return a < b ? a = b : a;}
template<class T1, class T2> T1& cmin (T1& a, const T2& b) {return a > b ? a = b : a;}
using namespace std;
const int MAXN = 2e5 + 5;
const int LOGN = 20;
struct Stk {
    int a[MAXN], tp;
    void push (int x) {a[++tp] = x;}
    void pop () {a[tp--];}
    int top (int x = 0) {return a[tp - x];}
    void clear () {a[tp = 0] = 0;}
};
Stk s;
int n;
int h[MAXN];
namespace t {
    int lg[MAXN], mn[LOGN][MAXN], mx[LOGN][MAXN];
    int lower (int x, int y) {return h[x] < h[y] ? x : y;}
    int upper (int x, int y) {return h[x] > h[y] ? x : y;}
    void build () {
        lg[0] = -1;
        fir (i, 1, n) lg[i] = lg[i >> 1] + 1, mn[0][i] = mx[0][i] = i;
        fir (i, 1, 18) fir (j, 1, n - (1 << i) + 1)
            mn[i][j] = lower (mn[i - 1][j], mn[i - 1][j + (1 << (i - 1))]),
            mx[i][j] = upper (mx[i - 1][j], mx[i - 1][j + (1 << (i - 1))]);
    }
    int qrymn (int l, int r) {
        if (l > r) return 0;
        int k = lg[r - l + 1];
        return lower (mn[k][l], mn[k][r - (1 << k) + 1]);
    }
    int qrymx (int l, int r) {
        if (l > r) return n + 1;
        int k = lg[r - l + 1];
        return upper (mx[k][l], mx[k][r - (1 << k) + 1]);
    }
}
int lt[MAXN], rt[MAXN];
int fh[LOGN][MAXN];
int fr[LOGN][MAXN];
int calc (int x, int y) {
    int ans = 0;
    firr (i, 18, 0)
        if (h[fh[i][x]] <= h[y])
            x = fh[i][x], ans += 1 << i;
    firr (i, 18, 0)
        if (h[fr[i][x]] <= h[y])
            x = fr[i][x], ans += 1 << i;
    return ans;
}
void init (int N, vector<int> H) {
    n = N;
    h[0] = INT_MAX;
    fir (i, 1, n) h[i] = H[i - 1];
    t::build ();
    s.clear ();
    fir (i, 1, n) {
        while (h[s.top ()] < h[i]) s.pop ();
        fh[0][i] = lt[i] = s.top ();
        s.push (i);
    }
    s.clear ();
    firr (i, n, 1) {
        while (h[s.top ()] < h[i]) s.pop ();
        fr[0][i] = rt[i] = s.top ();
        if (rt[i] != 0 && (fh[0][i] == 0 || h[rt[i]] > h[fh[0][i]])) fh[0][i] = rt[i];
        s.push (i);
    }
    fir (i, 1, 18)
        fir (j, 1, n) {
            fh[i][j] = fh[i - 1][fh[i - 1][j]];
            fr[i][j] = fr[i - 1][fr[i - 1][j]];
        }
    fir (i, 1, n)if(!rt[i])rt[i]=n+1;
}
int minimum_jumps (int a, int b, int c, int d) {
    ++a, ++b, ++c, ++d;
    int MIN=t::qrymx(b,c-1);
    int y=rt[MIN];
    if(y>d)return -1;
    int p = lt[y]+1;
    p = max (p, a);
    p = t::qrymx (p, b);
    int ans = calc (p, y);
    if(!lt[y])return ans;
    y=rt[lt[y]];
    if(y<=d)
	{
		p = lt[y]+1;
    	p = max (p, a);
    	p = t::qrymx (p, b);
		cmin(ans,calc (p, y));
	}
    return ans;
}
```


---

## 作者：FjswYuzu (赞：8)

P7599 APIO2021 雨林跳跃。

首先考虑 $A=B,C=D$ 的情况。在这个条件下，我们的起点和终点都是确定的。猜测剩下的工作是寻找正确的起点和终点，暂先不管。

先考虑无解情况，给出结论：如果区间 $[B,C-1]$ 内的最大值大于区间 $[C,D]$ 内的最大值，无解。

因为 $B < C$，显然从 $[A,B]$ 的任意位置出发，我们都会经过 $[B,C-1]$ 内的最大值。因为我们只能从低往高跳，因此不能够跳到 $[C,D]$。

求区间最大值可以用 st 表解决，找到一个值所在位置可以用一个数组存下。

考虑优化跳跃过程。处理这种问题一般用倍增。注意到我们还可以往前面跳，由于知道答案的粗略上界和下界（分别为 $H_C-H_A$ 和 $1$，在这种情况下比较显然），我们希望在不超过 $H_C$ 的情况下跳得越高越好，这样就能减少步数；在跳到如果继续跳最高点会超过 $H_C$ 的点的时候，我们就必须只往右边跳。发现只往右边跳是一个显然的倍增过程，第一个采用倍增解决的正确性也不难证明（假设往左跳更高，往右跳能跳到的最高的位置先往左跳也一定能跳到或者比这个位置更高，步数更少）。

于是预处理两个倍增数组，$fa_{x,i}$ 表示从点 $i$ 开始，尽量往两边中跟高的点跳 $2^i$ 次跳到的位置，$nxt_{x,i}$ 表示从点 $i$ 开始，往右边跳 $2^i$ 次跳到的位置。处理这个问题只用倍增跳就好了。

求这个东西可以用单调栈求在 $i$ 左边或者右边第一个比 $H_i$ 大的数的位置，这个时候求出了 $nxt_{i,0}$，然后对于两个比较一下就处理了 $fa_{i,0}$。

再考虑 $A \leq B$ 的情况。在保证有解的情况下选择越高的点越优秀。于是找到一个位置 $E$，使得区间 $[E,B]$ 的最大值小于区间 $[C,D]$ 内的最大值，并且区间 $[E-1,B]$ 的最大值大于区间 $[C,D]$ 内的最大值（注意还要满足 $A \leq E \leq B$）。那么从 $[E,B]$ 中的最大值所在位置开始跳即可，这个 Subtask 剩下的工作和上一个是一样的。

最后需要做的是 $A \leq B < C \leq D$ 的一般情况。先查询区间 $[B,C-1]$ 内的最大值及其所在位置 $p$，再在 $[C,D]$ 中第一个大于 $H_p$ 的位置 $x$。找到在 $x$ 前面的第一个比它大的位置 $y$，最后找到第一个在 $y$ 后面的大于 $H_y$ 的位置 $z$。找到 $[B,C]$ 中最大的可以跳到 $[C,D]$ 的位置 $a$。那么答案只存在于 $a$ 作为起点，$x$ 或 $z$ 作为终点两种情况之一（$z$ 可能大于 $D$，这种情况判判就行）。

考虑证明：

- 如果没有经过 $y$：
  - $A \leq y \leq B$：从 $y$ 开始，要么一步跳进 $[C,D]$ 中的 $z$，要么 $y$ 及其之前的位置不能作为起点（因为无解），这个时候根据上两个 Subtask 的分析，有从 $p$ 到 $x$ 最优的结论；   
  - $y < A$：根据上两个 Subtask 的分析，有从 $p$ 到 $x$ 最优的结论；   
  - $B < y$：如果存在，显然不满足有解。
- 如果经过了 $y$：
  - $C \leq z \leq D$：可以一步从 $y$ 跳进 $z$；   
  - 从 $y$ 不能够到达 $[C,D]$，要从 $x$ 跳到 $p$。
  
综上，答案只存在于 $a$ 作为起点，$x$ 或 $z$ 作为终点两种情况之一。

代码实现用的是 LOJ 下发文件自带的 `stub.cpp`。

```cpp
#include"jumps.h"
#include<bits/stdc++.h>
using namespace std;
int n,h[200005],st[200005],stk[200005],top,lgs[200005],fa[200005][19],nxt[200005][19],pre[200005],suf[200005],mx[200005][19];
int getMax(int l,int r)
{
	int k=lgs[r-l+1];
	return max(mx[l][k],mx[r-(1<<k)+1][k]);
}
int getMaxPos(int l,int r){return st[getMax(l,r)];}
int calc(int x,int y)
{
	int ans=0;
	for(int i=18;~i;--i)	if(h[fa[x][i]]<=h[y])	x=fa[x][i],ans+=(1<<i);
	for(int i=18;~i;--i)	if(h[nxt[x][i]]<=h[y])	x=nxt[x][i],ans+=(1<<i);
	return ans;
}
void init(int N,vector<int> H)
{
	n=N;
	for(int i=0;i<n;++i)	h[i+1]=H[i];
	for(int i=1;i<=n;++i)	st[h[i]]=i;
	st[n+1]=0;
	h[0]=n+1;
	for(int i=1;i<=n;++i)
	{
		while(top && h[stk[top]]<h[i])	--top;
		if(!top)	pre[i]=0;
		else	pre[i]=stk[top];
		fa[i][0]=pre[i];
		stk[++top]=i;
	}
	top=0;
	for(int i=n;i;--i)
	{
		while(top && h[stk[top]]<h[i])	--top;
		if(!top)	suf[i]=0;
		else	suf[i]=stk[top];
		if(suf[i] && (!fa[i][0] || h[fa[i][0]]<h[suf[i]]))	fa[i][0]=suf[i];
		nxt[i][0]=suf[i];
		stk[++top]=i;
	}
	for(int j=1;j<=18;++j)	for(int i=1;i<=n;++i)	fa[i][j]=fa[fa[i][j-1]][j-1],nxt[i][j]=nxt[nxt[i][j-1]][j-1];
	for(int i=1;i<=n;++i)	suf[i]=(!suf[i]?n+1:suf[i]);
	for(int i=2;i<=n;++i)	lgs[i]=lgs[i>>1]+1;
	for(int i=1;i<=n;++i)	mx[i][0]=h[i];
	for(int j=1;j<=18;++j)	for(int i=1;i+(1<<j)-1<=n;++i)	mx[i][j]=max(mx[i][j-1],mx[i+(1<<(j-1))][j-1]);
}
int minimum_jumps(int A,int B,int C,int D)
{
	++A,++B,++C,++D;
	if(getMax(B,C-1)>getMax(C,D))	return -1;
	int pos=getMaxPos(B,C-1);
	int byd=suf[pos];
	int p=getMaxPos(max(pre[byd]+1,A),B);
	int st1=calc(p,byd);
	if(!pre[byd])	return st1;
	byd=suf[pre[pos]];
	if(byd>D)	return st1;
	else
	{
		p=getMaxPos(max(pre[byd]+1,A),B);
		return min(st1,calc(p,byd));
	}
}
int main() {
  int N, Q;
  assert(2 == scanf("%d %d", &N, &Q));
  std::vector<int> H(N);
  for (int i = 0; i < N; ++i) {
    assert(1 == scanf("%d", &H[i]));
  }
  init(N, H);

  for (int i = 0; i < Q; ++i) {
    int A, B, C, D;
    assert(4 == scanf("%d %d %d %d", &A, &B, &C, &D));
    printf("%d\n", minimum_jumps(A, B, C, D));
  }
  return 0;
}
```

---

## 作者：AK_Dream (赞：5)

### 题解
考虑找到 $(B,C)$ 区间内的最高树 $M$ 和 $[C,D]$ 中的最高树 $N$

![](https://cdn.luogu.com.cn/upload/image_hosting/fr0r91vm.png)

那么最后一步跳跃一定是从某棵满足 {$H_M \le H_T \le H_N$} 且 {$(T,M)$ 中没有比 $T$ 更高的树} 的树 $T$ 跳进 $[C,D]$ 区间中

我们把所有这样的树 $T$ 叫做"准终点"

所以原问题的目标就等价于用最少的步数跳到一个准终点上 然后再跳一步进入 $[C,D]$

#### 从 $[A,B]$ 中的哪棵树开始？

如果 $[A,B]$ 中存在一个准终点，那么显然可以直接从那棵树出发，只需一步即可完成

否则，最优方案应该从 $[A,B]$ 中满足 {$(P,M)$ 中没有比 $P$ 更高的树} 的树中最高的那棵 $P$ 开始 下面给出证明

![](https://cdn.luogu.com.cn/upload/image_hosting/a6sw78eq.png)

如图，$R$ 是 $P$ 向左跳一次到的那棵树，$Q$ 是向右跳一次到的那棵树

由于上文假设 $[A,B]$ 中没有合法的准终点 ，所以树 $R$ 比 树 $N$ 更高，所以向右跳一次一定会到达 $D$ 右边，因此 $[A,R]$ 区间的树都不能作为起点

对于 $(R,P)$ 区间的树，它们的高度全部小于 $H[P]$。如果想要跳出 $(R,P)$ 区间，不论怎么跳都会到达 $R,P$ 其中一棵树，一定没有从 $P$ 开始优

对于 $(P,Q)$ 区间的树同理，一定会跳到 $P,Q$ 其中一棵树，然而 $P$ 只需一步就能跳到 $Q$ ，所以一定没有 $P$ 优秀

所以从 $P$ 出发一定最优，QED

#### 如何找到最优出发点？
从第 $B$ 棵树开始，倍增地向左跳，跳到最左边的一棵在 $A$ 之前并且高度小于树 $N$ 的树，它就是最优出发点

如果它是准终点，那么只需一步，否则需要多步

#### 从 $P$ 出发怎么跳最优？
对于一棵树，可以向左跳或者向右跳，我们把跳到左右中较高的一棵树称作跳高边，反之叫跳低边 

有如下跳的策略：

+ 如果当前树既可以向左跳又可以向右跳，并且向左右跳到的树高度都小于树 $M$ ，那么优先跳高边(我们希望用尽量少的步数使当前高度增加)
+ 如果某时刻跳高边会使得跳到的树高度大于等于树 $M$ ，那么验证一下跳高边到的那棵树是否是一个准终点，如果是那么就直接跳到它
+ 否则就总是向右跳，跳到一个准终点为止(如果跳不到说明无解)

容易发现这就是最优策略

实现时先从最优出发点出发，倍增跳高边跳到最高的一棵高度小于树 $M$ 的为止 假设是树 $X$

检查从 $X$ 跳高边到的那棵树是不是准终点

如果不是，那就从 $X$ 出发倍增向右跳跳到最高的一棵高度小于树 $M$ 的为止，然后检查它向右跳一步是不是准终点

所有的步骤都可以使用ST表或者倍增实现，所以总时间复杂度是 $O((n+q)\log n)$

赛时没想到，只拿了81pts。。。

### 代码
```cpp
#include <bits/stdc++.h>
#define N 200005
using namespace std;

int n, a[N], stk[N], top;
int st[N][21], L[N][21], R[N][21], Big[N][21], lg2[N];

void init(int nn, vector<int> h);
int minimum_jumps(int A, int B, int C, int D);

void init(int nn, vector<int> h) {
	n = nn; a[0] = 0x3f3f3f3f;
	for (int i = 1; i <= n; i++) a[i] = h[i-1];
	for (int i = 1; i <= n; i++) {
		while (top && a[stk[top]] < a[i]) R[stk[top--]][0] = i;
		L[i][0] = stk[top]; stk[++top] = i;
	}
	for (int i = 1; i <= n; i++) {
		if (L[i][0] && R[i][0]) {
			if (a[L[i][0]] > a[R[i][0]]) Big[i][0] = L[i][0];
			else Big[i][0] = R[i][0];
		}
		st[i][0] = i; 
	}
	for (int l = 1; (1<<l) <= n; l++) {
		for (int i = 1; i <= n; i++) {
			L[i][l] = L[L[i][l-1]][l-1];
			R[i][l] = R[R[i][l-1]][l-1];
			Big[i][l] = Big[Big[i][l-1]][l-1];
			if (i+(1<<l)-1 <= n) {
				int p = st[i][l-1], q = st[i+(1<<(l-1))][l-1];
				st[i][l] = (a[p]>a[q])?p:q;
			}
		}
	}
	lg2[0] = -1;
	for (int i = 1; i <= n; i++) lg2[i] = lg2[i>>1] + 1;
}

inline int qmax(int l, int r) {
	int k = lg2[r-l+1], p = st[l][k], q = st[r-(1<<k)+1][k];
	return (a[p]>a[q])?p:q;
}

int minimum_jumps(int A, int B, int C, int D) {
	++A; ++B; ++C; ++D;
	int Mn = (B<C-1)?a[qmax(B+1, C-1)]:0, Mx = a[qmax(C, D)];
	if (Mn <= a[B] && a[B] <= Mx) return 1;
	int P = B, ans = 0;
	for (int i = 20; ~i; i--) {
		if (L[P][i] >= A && a[L[P][i]] < Mx) 
			P = L[P][i];
	}
	if (Mn <= a[P] && a[P] <= Mx) return 1;
	for (int i = 20; ~i; i--) {
		if (a[Big[P][i]] < Mn) 
			ans += (1<<i), P = Big[P][i];
	}
	if (Mn <= a[Big[P][0]] && a[Big[P][0]] <= Mx) return ans+2;
	for (int i = 20; ~i; i--) {
		if (a[R[P][i]] < Mn) 
			ans += (1<<i), P = R[P][i];
	}
	if (Mn <= a[R[P][0]] && a[R[P][0]] <= Mx) return ans+2;
	return -1;
}
```

---

## 作者：ღꦿ࿐ (赞：4)

### 0.闲话

做不会的题，要么自己想，要么问一个人，不要同时问几个做法不同的人 / 看几篇做法不同的题解，这些可以等你 AC 后再看，效率会高很多。

总之还是感谢 L7_56 大佬讲解 %% ，虽然没听懂，但是自己磨出来了。

很多题解是 APIO 刚完的时候写的，故讲解不太仔细，在这里补充一下。

### 1.题目相关

简化题意：

一排树，高度互不相同，每次跳跃会跳到左边第一个比它高的点，或右边第一个比它高的点，多次询问从 $[A,B]$ 中任意点到 $[C,D]$ 中任意点的最少步数，强制在线。

数据范围：

$n,q \leq 2\times 10^5 $

原题:

[lougu P7599](https://www.luogu.com.cn/problem/P7599)

### 2.约定与记号

本文对树的编号从1开始，在开始和结尾放两棵无限高的树不影响答案。

$H_i$ 表示 $i$ 的高度 ， $L_i$ 表示 $i$ 左边第一个比它高的点 ， $R_i$ 表示 $i$ 右边第一个比它高的点 。

约定 $max[A,B]$ 本文中表示 $\max_{i\in[A,B]}H_i$ ， $min[A,B]$ 本文中表示 $\min_{i\in[A,B]}H_i$ 

特别地， $L_0=R_0=0\ ,\ L_{n+1}=R_{n+1}=n+1\ ,\ H_0=N_{n+1}= +\infty$

---

### 3.算法，思维过程



首先有 $O(nq)$ $\text{BFS}$ ，与正解没啥关系，故不讨论。

#### 1.$\text{A=B,C=D}$

观察特殊数据，考虑对于 $A=B,C=D$ 的特殊数据，思考如何处理。

首先，有解的充要条件是 $ max[A,C-1] \leq H_C$  ， 若不满足，一定会经过  高度为 $max[A,C-1]$ 的这个点 且无法到达 $C$  , 否则一直向右跳则有解。

若有目前在 点 $i (i\leq C)$ , $H_{L_i} \leq H_C, H_{R_i}\leq H_C$ ， 则跳到  $Li,Ri$ 中高度更高的点不会更劣。

证明是显然的 ， 较低者能跳到的两个边界其中之一是较高者，另一边是 $p$  , 较高者的两个边界之一为 $p$ ，另一边界显然不会更小。

所以一定是会从起点开始，不断向 $Li,Ri$ 中高度更高的点跳跃，直到两者中较高者高度大于等于终点高度。

接下来的最优决策就是一直向右跳，

若 $R_i$ 大于等于终点高度，又因为有解的条件，此时 $R_i$ 显然是终点

若 $L_i$ 大于等于终点高度（此时显然是大于） ， 那么就显然一直向右跳，一定也是满足在不超过终点的高度跳尽可能高。

使用两次倍增 （一次跳尽可能高的点 ， 一次跳尽可能右的点 ） 即可解决 。 

即 $Rt[i][x]$ 表示从 $i$ 向右开始跳 $2^x$ 步  ,  $Up[i][x]$ 表示从 $i$ 向尽可能高跳 $2^x$ 步  ， 然后常规倍增。


---

#### 2.$\text{C=D}$

先只考虑有解的情况，即 $ max[B,C-1] \leq max[C,D]$

接下来考虑起点的选择 ， 令 $[B,C)$ 中最大值的位置为 $p$ ，若 $p=B$ 则可以从 $p$ 一步走过去 , 否咋选择一个满足 $1$ 中的条件的一个最高的点 $x$ 作为起点，由于前部分是尽可能向上走，同 $1$ 中的证明，选择高的很明显不劣。

这个点就是 $[max\{Lp+1,A\} , B]$ 中的最大值 ， 因为有解且 $[Lp+1,p]$ 中的点都是符合条件的。

---
#### 3.一般情况

一个特殊的值是 $[B,C-1]$ 中的最大值所在点p ， 分两种情况进行考虑 ， 经过它，不经过。

##### 3.1 经过它

选择 $[max\{Lp+1,A\} , B]$ 中的最大值走过去，同 2 即可 ， 走到 $p$ 后一步即可走到。

##### 3.2 不经过它

不经过 $p$ 那么就一定经过 $p$ 左边的某个比它大的点 ， 这种情况必须满足 $R_{L_p} \in[C,D]$  ， 显然 $R_{L_p}\geq C$  。

反证：若 $R_{L_p} >D$ ， 因为不经过 p ， 显然是从 $p$ 左边的某个比 $p$ 大的点走过去 ， 此时 $L_p$ 是不能到达 $[C,D]$ 的 ， $L_p$ 左边的低于 $L_p$ 的要么经过 $L_p$ ， 要么只会走到高于 $L_p$ 的点 $q$ ， $R_q \geq R_{L_p} > D$ 所以一定满足条件。

若不满足条件，则必须经过 $p$

若 $L_p\in[A,B]$ 则可以一步走到 $R_{L_p}$

否则选取 $[A,B]$ 中的最大值向 $L_p$ 跳即可，然后一步跳到终点区间。

常规倍增(同 1 )即可，见配图。

---

配图：

无解

![](https://cdn.luogu.com.cn/upload/image_hosting/hl3xk22y.png)

1 这种经过 $L_p$ 的路径不行。

2 这种高于 $L_p$ 的点的 $R$ 不会更靠左。

两种路径

![](https://cdn.luogu.com.cn/upload/image_hosting/3sp3oqk9.png)

1 经过 $p$  
2 不经过 $p$


使用倍增进行“跳”， ST 表进行 RMQ 查询 ， 时空复杂度 $O(n \log n)$ 。

---

### 4.代码实现

关键部分

```

/*分情况，特判*/

int minimum_jumps(int A, int B, int C, int D) {
    A++,B++,C++,D++;
    if(mx(B,C-1).first>mx(C,D).first) return -1;
    /*判掉无解*/
    auto mx1 = mx(B,C-1);
    if(mx1.second == B) return 1 ;
    int p = mx1.second , Lp = l[p] ,res = 1e9 + 100 ;
    /*过p*/
    int st = mx(max(A,Lp + 1) , B).second ; 
    res = min(res , calc1(st , p) + 1);
    /*到 R[l[p]]*/
    if(r[Lp]>=C&&r[Lp]<=D) {
        if(Lp>=A) res = min(res , 1);
        else res = min(res , calc2(mx(A,B).second,Lp) + 1) ; 
    }
    if(res >= 50000000) return -1;
    return res; 
}

/*两个倍增*/
int calc1(int st,int ed) {
    int ret = 0 ; 
    if(mx(st,ed-1).first > h[ed]) return 110000000 ;
    for(int i = Lg - 1 ; i >= 0 ; -- i) {
        if(h[Up[i][st]]>h[ed]) continue;
        st = Up[i][st] , ret += (1 << i) ;
    }
    debug(st) ; 
    for(int i = Lg - 1 ; i >= 0; -- i) {
        if(Rt[i][st] <= ed && Rt[i][st]) st = Rt[i][st] , ret += (1<<i);
    }
    if(st == ed)return ret;
    return 110000000;
}
int calc2 (int st,int ed) {
    int ret = 0 ;
    if(mx(ed+1,st).first > h[ed]) return 110000000 ;
    for(int i = Lg - 1 ; i >= 0 ; -- i) {
        if(h[Up[i][st]]>h[ed]) continue;
        st = Up[i][st] , ret += (1 << i) ;
    }
    for(int i = Lg - 1 ; i >= 0 ; -- i) {
        if(Lf[i][st] >= ed && Lf[i][st]) st = Lf[i][st] , ret += (1<<i) ; 
    }
    if(st == ed)return ret;
    return 110000000;
}


```

完整代码

[ -传送门- ](https://www.luogu.com.cn/paste/9g5vfuz2)





---

## 作者：WeLikeStudying (赞：3)

- 水题不会做，怎么办？

**题意**
- [题目链接](https://uoj.ac/problem/652)。
- 有一个无向图，每个点有一个权值。
- 每个点只会向编号比它小，且权值比它大的最大编号节点，和编号比它大，且权值比它大的最小编号节点各连权值为 $1$ 的有向边。
- 求编号在一个区间点到编号在另一个区间的点的所有可能点对中的最短路长度的最小值，如果无法到达，返回 $-1$。
- 注意：所有树的高度形成一个排列，这或许很重要。
- 数列长度不大于 $2\times 10^5$，询问次数不大于 $10^5$。

**分析**
- 看到数据范围让我想到根号做法，不知道现不现实（upd：不现实）。
- 该题的交互形式已经暗含强制在线，所以或许是分块（flag）（upd：flag 倒下了）。
- 首先我们有一个基于宽搜的 $O(nq)$ 的暴力，可以拿到 $33$ 分，[代码](https://www.luogu.com.cn/paste/3tn20rgk)，但是后面的特殊性质或许是一个提示。
- 没有样例，把它用作对拍其实不错。
- 首先这个图的特殊性质肯定是我们要研究的对象，但是到底有什么性质呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/okdncjsv.png)
- 怎么说呢，你看到这个难道不觉得它很像一棵二叉树吗（当然一开始我觉得它更像一棵仙人掌）（我居然一度认为它的对偶图很像一棵二叉树，并且由此想到了平面图最短路转对偶图最小割 qwq）。
- 具体是什么呢？简单来说，我们称完美区间是外面的数不能到达里面的区间，那么整个区间是完美区间。
- 不仅如此，把这个区间的最大数提出来后，分成的两个区间也是完美区间，而且这两个完美区间的数一定可以跑到这个最大数上。
- 简单来说，建出原序列的笛卡尔树，若两个区间内的数没有祖先关系，那么就不可达，清晰而明确，看来它就是这题的题眼了。
![](https://cdn.luogu.com.cn/upload/image_hosting/5ajh0u3i.png)
- 我们首先研究另一条边的去向，从图中也可以看出，另一条边连向它的父亲第一次转向的地方。
- 接下来我们先从一个点对入手吧，我们首先是可达性条件：在笛卡尔树上是祖孙关系。
- 然后跑上去就是跳祖边了，这是很容易的：看看另一条边的深度吧，如果跑到的深度低于它那贪心地跳，否则就只能沿着暴力跑，非常自然，维护两种边的倍增数组，我们可以在 $O(\log n)$ 的时间内处理点对询问，而且这并不是下确界，如果正解真的是分块的话是可以平衡的。
- 然后接下来的话是多对一，你问我为什么不是一对多？~~当然是发挥了部分分的提示作用了~~。
- 可达性判定？由于该图的可达性就是笛卡尔内向树的可达性，所以可达性直接使用区间与点最相近的那个点即可（类似地，区间与区间只需要它最近的两个点即可）。
- 但是路程呢？如果它也能快速求解就方便了，但是它目前有一个直观的 $O(\sqrt{n\log n})$ 的方法，不必细说。
- 我们考虑最优判定点（我姑且先假设是右边，左边是堆成的）它到根的路径是什么状况呢？（下面的图不是特别严格，具体来说所有线段都应该向上覆盖而向下的部分不覆盖）
![](https://cdn.luogu.com.cn/upload/image_hosting/qybzp13d.png)
- 我们极度简化了问题（显然其它情况一定不在被选之列，容易证明这里不详细展开），但是这个如何快速求解呢？
- 首先我们倍增的时候是先跳非树边而且而且我们也只需要考虑单链末尾有没有在指定区间内的，这个满足单调性可以二分，然后，哈哈，我们不就转化成了点对问题了吗？我们用 $O(\log n)$ 的复杂度解决了多对一的问题。
- 然后接下来我们显然可以在 $O(\sqrt{n\log  n})$ 的时间复杂度内解决多对多的情况，但你真的愿意止步于此？
- 判定性问题咱们已经研究过了，接下来咱们考虑的问题显然就是这两个相应的内部点对到根的路径了！
![](https://cdn.luogu.com.cn/upload/image_hosting/h8vs22be.png)
- 然后这个怎么弄呢：如果 $\text{LCA}$ 上方转折仍然红蓝交错的情况，那么直接输出 $1$ 显然。
- 否则 $\text{LCA}$ 要么是红要么是蓝（否则无解），在下面找最近的一个凑过来就好了，十分方便。
- 最终，俺们的时间复杂度是 $O((n+q)\log n)$，各位一定要小心，这题的题目数据范围十分误导人，我差点就以为它只能搞根号做法。
- 代码实现可能较为复杂（指作者连倍增都不会打的现状），口胡并不是终点，[代码](https://www.luogu.com.cn/paste/7ytwgsyg)。
- 实现细节比较多，列举其中三个：非树边并不是那么容易操作，建议保留左右两个指针；善用 $\text{LCA}$ 或 $\text{RMQ}$；最高的左点只有一个，但是最近的右点可能有两个，想明白这一点，不要漏。

---

## 作者：_sst_ (赞：1)

首先，考虑 $A=B,C=D$ 的简单情形。

每个点可以跳到左右两边第一个更高的点，这意味着每个点通过跳跃到达的点都是比这个点更高的点。

设我们要从 $u$ 跳到 $v$，一个直观的想法是以 $u$ 起点做类似最短路的 $\rm DP$，但是这个 $\rm DP$ 是比较暴力的，并不容易优化。

关于跳跃，还有很多优美的性质，我们可以尝试贪心地去考虑。

我们的目标是从 $u\to v$，也就是高度要从 $h_u\to h_v$，那每次跳跃的高度增量更大，就可以更快地升高高度，达到 $h_v$。

于是我们就得到了一个结论：在保证高度不超过 $h_v$ 的情况下，我们尽量每次都选择跳跃到高度更大的点。

这个结论比较适合感性理解，因为在不超过 $h_v$ 的基础上，高度越高，我们还需要跳的步数就越少。

一个可能的反例想法是，有时向右跳可能更优。但是我们发现，向右跳虽然能更接近 $v$，但是向右跳之后也需要进行若干次高度的爬升才能到 $v$，而向左跳的能跳到高度更高的地方，此时再向右跳所需要的爬升次数必然减少，一定不劣。

为了快速维护这一过程，我们可以使用倍增，记录点 $u$ 跳跃到更高节点 $2^i$ 次后到达点 $jp_{u,i}$。

当我们发现往更高节点再跳跃时，高度已经超过了 $h_v$，此时只需要一直往右跳到 $h_v$ 即可，这也可以用倍增维护。如果 $[u,v]$ 有高度超过 $h_v$ 的点，则 $u$ 一定不能跳到 $v$。

现在我们来解决 $C=D$ 的问题。

此时起点可以在 $[A,B]$ 中任选，由我们上面的贪心，容易分析出，肯定选择尽量高的点更好。

但是注意，当 $[A,C]$ 中有超过 $h_v$ 的点，就会出现不合法的情况。所以我们要在保证 $[u,C]$ 中点都不超过 $h_v$ 的同时，找到最大 $h_u$。

这样合法的 $u$ 是一段区间，我们可以用线段树上二分来求出区间的左端点。

现在我们来解决 $A=B$ 的问题。

此时，我们需要跳到 $[C,D]$ 中的任意一点，并且尝试后可以发现，对于任何直接选择 $v$ 的做法都是错误的。

如果我们跳到 $[C,D]$ 中 $h$ 小的点 $v_0$，有可能出现一个 $u$ 左边的节点 $x$，$h_x>h_{v_0}>h_u$，而存在一个 $[C,D]$ 中的点 $h_{v_1}>h_x$，此时跳到 $h_{v_1}$ 只需要 $2$ 步，且可以构造出方案使跳到 $h_{v_0}$ 需要至少 $3$ 步。

如果跳到 $[C,D]$ 中 $h$ 大的点，反例显然，让 $u$ 能直接跳到 $[C,D]$ 中某个 $h$ 较小的节点即可。

所以我们发现，我们不能直接选择 $h_v$ 更大的或更小的，而是要选择一个大小刚好的点。

此时有一个关键想法，我们如果要跳到 $[C,D]$ 中的点，所在的点的高度不能小于 $[u,C-1]$ 中最高的高度。这样我们再往右边跳一步就能跳到 $[C,D]$ 之间，否则一定会被 $[u,C-1]$ 中最高的点拦住。

由这个想法，记 $[u,C-1]$ 中最高高度为 $mx$，我们每次跳更高的点，跳到一个最高的不超过 $mx$ 的点。

此时再往更高的点跳一步，一定就超过了 $mx$，但是我们还需要看这个点是否超过 $[C,D]$ 中的最大值 $mx2$，如果超过，就只能倍增往右跳，否则先跳一步到这个点，再往右跳一步即可。

现在，考虑回原问题。

只需要在 $A=B$ 的基础上，起点找到高度最大，但满足 $[u,C-1]<mx2$ 的点 $u$。

记得判无解，找不到合法的起点 $u$ 就是无解的。

总时间复杂度为 $O(n\log_2 n)$，$n,q$ 同阶。

不过常数很大，因为在瓶颈处有很多算法，如线段树二分、$\rm ST$ 表求最大高度、倍增等。

代码如下，写得不太好。

```cpp
#include<bits/stdc++.h>
#define ls (u<<1)
#define rs (ls|1)
using namespace std;
const int N=2e5+5,LN=22;
int n;
int h[N];
int t[N];
int lowbit(int x){return x&-x;}
void Change(int x,int y)
{
	while(x<N)
	{
		t[x]=max(t[x],y);
		x+=lowbit(x);
	}
}
int Query(int x)
{
	int ans=0;
	while(x)
	{
		ans=max(ans,t[x]);
		x-=lowbit(x); 
	}
	return ans;
}
struct Sgt{int maxi;}t2[N*4];
void pushup(int u){t2[u].maxi=max(t2[ls].maxi,t2[rs].maxi);}
void Build(int u,int l,int r)
{
	if(l==r)
	{
		t2[u].maxi=h[l];
		return ;
	}
	int mid=(l+r)>>1;
	Build(ls,l,mid);
	Build(rs,mid+1,r);
	pushup(u);
}
int ans;
bool Query(int u,int l,int r,int ql,int qr,int x)
{
	int mid=(l+r)>>1;
	if(ql<=l&&r<=qr)
	{
		if(t2[u].maxi>=x)
		{
			if(l==r)return true;
			if(t2[rs].maxi>=x)Query(rs,mid+1,r,ql,qr,x);
			else ans=max(ans,t2[rs].maxi),Query(ls,l,mid,ql,qr,x);
			return true;
		}
		else
		{
			ans=max(ans,t2[u].maxi);
			return false;
		}
	}
	if(ql>mid)return Query(rs,mid+1,r,ql,qr,x);
	else if(qr<=mid)return Query(ls,l,mid,ql,qr,x);
	else
	{
		bool f=Query(rs,mid+1,r,ql,qr,x);
		if(!f)f=Query(ls,l,mid,ql,qr,x);
		return f;
	}
}

int l[N],r[N];
int fp[N];
int jp[N][LN];
int ST[N][LN];
int jpr[N][LN];
void init(int N, std::vector<int> H)
{
	n=N;
	for(int i=0;i<n;i++)h[i+1]=H[i];
	for(int i=n;i>=1;i--)
	{
		ST[i][0]=h[i];
		for(int j=1;j<=20;j++)ST[i][j]=max(ST[i][j-1],ST[min(n,i+(1<<(j-1)))][j-1]); 
	}
	for(int i=1;i<=n;i++)
	{
		l[i]=Query(n-h[i]+1);
		Change(n-h[i]+1,i);
	}
	for(int i=1;i<=n;i++)t[i]=0;
	for(int i=n;i>=1;i--)
	{
		r[i]=n+1-Query(n-h[i]+1);
		Change(n-h[i]+1,n-i+1);
	}
	for(int i=1;i<=n;i++)fp[h[i]]=i;
	for(int i=0;i<=20;i++)jp[n+1][i]=jpr[n+1][i]=n+1;
	h[n+1]=n+1;
	h[0]=n+1;
	for(int i=n;i>=1;i--)
	{
		int u=fp[i];
		jp[u][0]=((h[l[u]]>h[r[u]])?l[u]:r[u]);
		for(int j=1;j<=20;j++)jp[u][j]=jp[jp[u][j-1]][j-1];
		jpr[u][0]=r[u];
		for(int j=1;j<=20;j++)jpr[u][j]=jpr[jpr[u][j-1]][j-1];
	}
	Build(1,1,n);
}
int minimum_jumps(int A, int B, int C, int D)
{
	int a=A+1,b=B+1,c=C+1,d=D+1;
	int len=(int)log2(d-c+1);
	int mx=max(ST[c][len],ST[d-(1<<len)+1][len]);
	int mx2=0;
	ans=0;
	Query(1,1,n,a,b,mx);
	mx2=ans;
	if(!mx2)return -1;
	int u=fp[mx2];
	int len2=(int)log2(c-u);
	int mx3=max(ST[u][len2],ST[c-(1<<len2)][len2]);
	for(int i=u;i<c;i++)mx3=max(mx3,h[i]);
	if(mx3>mx)return -1;
	int ans=0;
	for(int i=20;i>=0;i--)
		if(h[jp[u][i]]<=mx3)u=jp[u][i],ans+=(1<<i);
	if(h[u]>=mx3)ans++;
	else if(h[jp[u][0]]>mx)
	{
		for(int i=20;i>=0;i--)
			if(jpr[u][i]<c)u=jpr[u][i],ans+=(1<<i);
		if(u<c)ans++;
	}
	else ans+=2;
	return ans;
}
```

---

## 作者：_Cheems (赞：0)

题意：给出高度数组 $h_1\dots h_n$ 为一个排列，每次在 $x$ 时可以向左或向右跳到第一个 $h_y>h_x$ 的 $y$ 上。$q$ 次询问，每次给出 $A,B,C,D$，求起点在 $[A,B]$、终点在 $[C,D]$ 的最少跳跃次数，或报告无解。$n\le 2\times 10^5,q\le 10^5$。

先从有无解下手，发现 $\max[B,C)$ 是一定逃不掉的，所以假如 $\max[B,C)>\max[C,D]$ 一定无解，反之只需从 $B$ 开始一直向右跳就行了。所以充要条件就是 $\max[B,C)<\max[C,D]$。

考虑固定起终点 $s,t$ 怎么最小化步数（设有解）。考虑向左向右的两个决策，发现在两个高度都 $\le h_t$ 时跳向较高者更优。反证，在第一次高度越过较高者时直接调整即可，如下图。当高度越过 $h_t$ 这个阈值时，发现越界者一定是左边的（不然无解），一直往右跳即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/5r97ucsg.png)

先来处理起点，贪心地想应当选较高者出发，前提是合法。结合前面的判定方法，合法区间是 $[A,B]$ 一段后缀，可以二分找到。证明的话也是反证，和前面差不多。

最后是终点，只需将之前求最小值那个做法改一下，把阈值设为 $\max[B,C)$，因为它必然被越过。然后直接向右跳，肯定是优的。

注意一下细节，就是处理完在阈值内倍增跳后，此时假如可以跳到的较高者低于 $\max[C,D]$，肯定跳更优。但是注意假如我已经在 $\max[B,C)$ 上了就不用跳了。

复杂度 $O(q\log n)$。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define chkmx(a, b) (h[a] > h[b] ? (a) : (b))
#define pir pair<int, int>
const int NN = 2e5 + 5;
int n, T, h[NN], mx, stk[NN], stt, ls[NN], rs[NN], fa[NN][20], rr[NN][20], st[NN][20], lg[NN];
int A, B, C, D;
vector<int> sn[NN];

inline void INIT(){
    for(int i = 2; i < NN; ++i) lg[i] = lg[i >> 1] + 1; 
    stt = 0;
    for(int i = 1; i <= n; ++i){
        while(stt && h[stk[stt]] < h[i]) --stt;
        ls[i] = stk[stt], stk[++stt] = i;
    }
    stt = 0;
    for(int i = n; i; --i){
        while(stt && h[stk[stt]] < h[i]) --stt;
        rs[i] = rr[i][0] = stk[stt], stk[++stt] = i;
        for(int j = 1; j < 20; ++j) rr[i][j] = rr[rr[i][j - 1]][j - 1];
    }
    for(int j = 0; j < 20; ++j)
        for(int i = 1; i + (1 << j) - 1 <= n; ++i){
            if(!j) st[i][j] = i;
            else st[i][j] = chkmx(st[i][j - 1], st[i + (1 << j - 1)][j - 1]); 
        }
}
inline int getmx(int l, int r){
    int len = lg[r - l + 1];
    return chkmx(st[l][len], st[r - (1 << len) + 1][len]);
}
inline void dfs(int u){
    for(int i = 1; i < 20; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for(auto v : sn[u]) fa[v][0] = u, dfs(v);
}
inline int jp(int &x, int lim){
    int cnt = 0;
    for(int i = 19; ~i; --i)
        if(fa[x][i] && h[fa[x][i]] <= lim) cnt += (1 << i), x = fa[x][i];
    return cnt;
}
inline int jp2(int &x, int lim){
    int cnt = 0;
    for(int i = 19; ~i; --i)
        if(rr[x][i] && rr[x][i] < lim) cnt += (1 << i), x = rr[x][i];
    return cnt;
}
int minimum_jumps(int A, int B, int C, int D) {
    ++A, ++B, ++C, ++D;
    int ans = 0;
    if(h[getmx(B, C - 1)] > h[getmx(C, D)]) return -1;
    int L = A - 1, R = B, mid, x;
    while(L + 1 < R){
        mid = (L + R) >> 1;
        if(h[getmx(mid, C - 1)] < h[getmx(C, D)]) R = mid;
        else L = mid;
    } 
    x = getmx(R, B);

    int mxx = getmx(x, C - 1);
    ans += jp(x, h[mxx] - 1);
    if(x != mxx && h[fa[x][0]] < h[getmx(C, D)]) x = fa[x][0], ++ans;
    ans += jp2(x, C) + 1;
    return ans;
}
void init(int N, std::vector<int> H) {
    n = N;
    for(int i = 1; i <= n; ++i) h[i] = H[i - 1], chkmx(mx, i);
    INIT();
    for(int i = 1; i <= n; ++i) sn[chkmx(ls[i], rs[i])].push_back(i); 
    dfs(mx);
}
```

---

## 作者：raincity (赞：0)

考虑刻画题目所给的两种操作。建大根笛卡尔树，则点 $u$ 可以跳到自己的父亲 $fa_u$，或者自己父链上第一个「变向」的点 $jp_u$（若 $u$ 是父亲的左儿子，则可以跳到父链上第一个是父亲的右儿子的点的父亲，反之亦然）。

因此，当 $A = B$，$C = D$ 时，有解当且仅当 $C$ 是 $A$ 的祖先。求答案可以优先跳 $jp$，再跳 $fa$，跳 $jp$ 的部分可以倍增，拿深度判一下有没有跳过头，跳 $fa$ 的部分操作次数就等于深度差。时间复杂度 $O((N + Q) \log N)$。

考虑 $C = D$ 的情况。显然，若 $u$ 是 $v$ 的后代，$v$ 是 $C$ 的后代，则从 $u$ 跳到 $C$ 的操作次数一定不小于从 $v$ 跳到 $C$ 的操作次数。因此，把 $[A, B]$ 与 $C$ 的子树取交，有解当且仅当交不为空。若有解，则从区间最大值开始跳即可。求区间最大值可以用 ST 表。时间复杂度 $O((N + Q) \log N)$。

考虑一般情况。先考虑判定无解。设 $H_k = \max(H_C, \dots, H_D)$，则 $k$ 一定是笛卡尔树上 $C, \dots, D$ 的最近公共祖先，因此，把 $[A, B]$ 与 $k$ 的子树取交，有解当且仅当交不为空。

若有解，考虑如何求答案。显然，最后一步是向右跳，且最后一步之前都应该优先把当前点的权值变大。因此从 $[A, B]$ 的最大值开始跳，在不离开 $k$ 的子树的前提下，优先跳 $jp$，再跳 $fa$。如果向右跳可以一步跳到 $[C, D]$，则直接返回。这个过程同样可以用倍增优化，时间复杂度 $O((N + Q) \log N)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define per(i, l, r) for (int i = (r); i >= (l); --i)
#define all(x, l, r) &(x)[l], &(x)[r] + 1
#define len(x) int((x).size())

using ll = long long;
using db = long double;
using str = string;

template <typename T>
inline bool ckmin(T& x, const T& y) {
  return y < x && (x = y, true);
}

template <typename T>
inline bool ckmax(T& x, const T& y) {
  return x < y && (x = y, true);
}

inline int p2(int n) { return 1 << n; }
inline int msk2(int n) { return p2(n) - 1; }

inline int msb(int n) { return n == 0 ? -1 : 31 ^ __builtin_clz(n); }
inline int bits(int n) { return 1 + msb(n - 1); }

constexpr int N = 2e5 + 5, D = 18, inf = 1e9;

int n, top;
array<int, N> h, st, fa, dep;
array<array<int, 2>, N> ch, seg;
array<array<int, N>, D> jp, far, anc, mx;

inline bool which(int x) { return x == ch[fa[x]][1]; }

int right(int x) { return fa[x] > x ? fa[x] : jp[0][x]; }

void dfs(int u, int p) {
  fa[u] = p, dep[u] = dep[p] + 1;
  jp[0][u] = which(u) == which(p) ? jp[0][p] : fa[p];
  anc[0][u] = far[0][u] = right(u);
  rep (d, 0, D - 2) {
    jp[d + 1][u] = jp[d][jp[d][u]];
    far[d + 1][u] = max(far[d][u], far[d][jp[d][u]]);
    anc[d + 1][u] = anc[d][anc[d][u]];
  }
  rep (i, 0, 1) {
    int v = ch[u][i];
    if (v)
      dfs(v, u), seg[u][i] = seg[v][i];
    else
      seg[u][i] = u;
  }
}

inline bool cmp(int x, int y) { return h[x] < h[y]; }

void preproc() {
  rep (i, 1, n) {
    int old = top;
    while (top && h[i] > h[st[top]]) --top;
    if (old > top) ch[i][0] = st[top + 1];
    if (top) ch[st[top]][1] = i;
    st[++top] = i;
  }
  dfs(st[1], 0);
  iota(all(mx[0], 1, n), 1);
  rep (d, 0, D)
    rep (i, 1, n - p2(d + 1) + 1)
      mx[d + 1][i] = max(mx[d][i], mx[d][i + p2(d)], cmp);
}

int qmx(int l, int r) {
  int d = msb(r - l + 1);
  return max(mx[d][l], mx[d][r - p2(d) + 1], cmp);
}

void init(int n_, vector<int> h_) {
  n = n_, copy_n(&h_[0], n, &h[1]);
  preproc();
}

int minimum_jumps(int a, int b, int c, int d) {
  ++a, ++b, ++c, ++d;
  int y = qmx(c, d);
  ckmax(a, seg[y][0]), ckmin(b, seg[y][1]);
  if (a > b) return -1;
  int x = qmx(a, b), ans = 0;
  per (d, 0, D - 1) {
    if (dep[jp[d][x]] >= dep[y] && far[d][x] < c) x = jp[d][x], ans += 1 << d;
  }
  per (d, 0, D - 1) {
    if (anc[d][x] && anc[d][x] < c) x = anc[d][x], ans += 1 << d;
  }
  return ans + 1;
}
```

---

## 作者：Leasier (赞：0)

### Subtask 5：$a = b, c = d$
此时起点和终点都已经确定。下面设 $l_i$ 表示 $i$ 左边第一个高于 $h_i$ 的位置。

先考虑怎么判无解。我们显然可以从 $b$ 开始向右一步一步走，最终到达 $c$，如果这个没法走就一定没法走。

注意到在这种情况下我们一定会经过 $[b, c)$ 中的最大值 $p$，则可以走到 $c$ 的条件为 $h_c > h_p$，因为此时 $(p, c)$ 中一定不存在任何比 $p$ 高的树。

在有解的情况下，为了让步数最少，我们事实上可能不会一直向右走，比如下面这种情况（起点为 $1$，终点为 $6$）：
```
4 1 2 3 5 6
```
此时走 $1 \to 4 \to 5 \to 6$ 优于走 $1 \to 2 \to 3 \to 5 \to 6$。

也就是说，如果走后高度仍小于 $h_p$，我们就会尽量用少的步数往两边较高的一方走。若再往左走高度就大于 $h_p$ 了，我们就会向右走直到到达 $p$，最后一步跳到 $h_c$ 即可。

但事实上我们并不一定会经过 $p$，比如下面这种情况（起点为 $1$，终点为 $5$）：
```
4 1 2 3 5
```
此时走 $1 \to 4 \to 5$ 优于走 $1 \to 2 \to 3 \to 5$。

但向左走得太远显然是不优的，注意到事实上一个较优的解只可能在 $l_p$ 处产生，因为：

- 如果选了一个左边满足 $h_q < h_{l_p}$ 的 $q$，则 $q < l_p$，你从那里向右走时一定会经过 $l_p$，至少多出一步。
- 如果选了一个左边满足 $h_q > h_{l_p}$ 的 $q$，则 $q < l_p$，你向左走到那里时一定会经过 $l_p$，至少多出一步。

于是这种情况可以总结为：当 $h_{l_p} < h_c$，我们还可以从 $b$ 开始尽量向高处走到 $l_p$，再一步走到 $c$。

向左向右走一步到达的位置可以单调栈预处理，上面走的过程可以直接倍增。时间复杂度为 $O((n + q) \log n)$。
### Subtask 6：$c = d$
现在的问题在于选择起点。

首先来讨论一下经过 $p$ 的情况，设这个位置为 $q$，则需要满足 $q \in [\max(l_p + 1, a), b]$，因为如果 $q \leq l_p$ 就一定会经过 $l_p$，进而不能经过 $p$。

那在这个范围内我们会怎么选择 $q$ 呢？显然会选择最大值所在位置。设 $q_0$ 为该位置，如果选了一个 $h_q < h_{q_0}$：

- 如果 $q < q_0$，则从 $q$ 出发一定会经过 $q_0$，至少多出一步。
- 如果 $q > q_0$，设两者路线在 $r > b$ 处会合，则 $q \to r$ 中间经过的点数 $\geq 0$，$q_0 \to r$ 中间经过的点数 $= 0$，选 $q_0$ 不劣。

接下来讨论不经过 $p$ 的情况。

当 $l_p < h_c, l_p \in [a, b]$，直接选 $l_p$ 作为起点即可一步到达。

否则，我们需要在 $[a, b]$ 中选一个点 $q$，从 $q$ 跳到 $l_p$，再一步跳到 $c$。

跟上面类似，我们也一定会选最大值所在位置。这里不再证明。

同样倍增即可。时间复杂度为 $O((n + q) \log n)$。
### Subtask 7：无特殊限制
事实上我们并不关心 $[c, d]$ 中到底有哪些高度，我们只关心从 $p, l_p$ 出发是否可以一步跳进 $[c, d]$。

设 $[c, d]$ 中最大值所在位置为 $q$。当 $h_q > h_p$ 则从 $p$ 可以一步跳进去——尽管可能终点并不位于 $q$——否则一定跳不进去，$l_p$ 同理。

时间复杂度为 $O((n + q) \log n)$。

~~但是为什么要开 $n \leq 2 \times 10^5, q \leq 10^5$ 和 $3$ 秒时限呢？是为了放根号算法过吗？~~

代码：
```cpp
#include <stack>
#include <vector>
#include <cmath>

#include "jumps.h"

using namespace std;

int m;
int st[200007][27], l[200007], r[200007][27], up[200007][27];
stack<int> s;
vector<int> h;

inline int mymax(int a, int b){
	if (a == 0 || b == 0) return a + b;
	return h[a] > h[b] ? a : b;
}

void init(int n, vector<int> h){
	m = log2(n);
	h.insert(h.begin(), 0x7fffffff);
	::h = h;
	for (register int i = 1; i <= n; i++){
		st[i][0] = i;
	}
	for (register int i = 1; i <= m; i++){
		int id = i - 1, t1 = n - (1 << i) + 1, t2 = 1 << id;
		for (register int j = 1; j <= t1; j++){
			st[j][i] = mymax(st[j][id], st[j + t2][id]);
		}
	}
	for (register int i = 1; i <= n; i++){
		while (!s.empty() && h[i] > h[s.top()]) s.pop();
		if (!s.empty()) l[i] = s.top();
		s.push(i);
	}
	while (!s.empty()) s.pop();
	for (register int i = n; i >= 1; i--){
		while (!s.empty() && h[i] > h[s.top()]) s.pop();
		if (!s.empty()) r[i][0] = s.top();
		s.push(i);
	}
	for (register int i = 1; i <= n; i++){
		up[i][0] = mymax(l[i], r[i][0]);
	}
	for (register int i = 1; i <= m; i++){
		int id = i - 1;
		for (register int j = 1; j <= n; j++){
			r[j][i] = r[r[j][id]][id];
			up[j][i] = up[up[j][id]][id];
		}
	}
}

inline int get_max_pos(int l, int r){
	int t = log2(r - l + 1);
	return mymax(st[l][t], st[r - (1 << t) + 1][t]);
}

int minimum_jumps(int a, int b, int c, int d){
	int max_pos, max_val;
	a++;
	b++;
	c++;
	d++;
	max_pos = get_max_pos(b, c - 1);
	max_val = h[get_max_pos(c, d)];
	if (h[max_pos] > max_val) return -1;
	int cur = get_max_pos(max(l[max_pos] + 1, a), b), ans1 = 1, ans2;
	for (register int i = m; i >= 0; i--){
		if (h[up[cur][i]] < h[max_pos]){
			cur = up[cur][i];
			ans1 += 1 << i;
		}
	}
	for (register int i = m; i >= 0; i--){
		if (h[r[cur][i]] <= h[max_pos]){
			cur = r[cur][i];
			ans1 += 1 << i;
		}
	}
	if (h[l[max_pos]] > max_val){
		ans2 = 0x7fffffff;
	} else if (l[max_pos] >= a){
		ans2 = 1;
	} else {
		cur = get_max_pos(a, b);
		ans2 = 2;
		for (register int i = m; i >= 0; i--){
			if (h[up[cur][i]] < h[l[max_pos]]){
				cur = up[cur][i];
				ans2 += 1 << i;
			}
		}
	}
	return min(ans1, ans2);
}
```

---

## 作者：Mine_King (赞：0)

## Problem

[APIO2021 雨林跳跃](https://www.luogu.com.cn/problem/P7599)

**题目大意：**

有一个长度为 $n$ 的序列 $h$，每次可以从一个位置跳到它左边或右边第一个大于它的位置。$q$ 次询问，每次询问 $A, B, C, D (A \le B < C \le D)$，要求在 $[A, B]$ 中找一个点 $s$，在 $[C, D]$ 中找一个点 $e$，从 $s$ 跳到 $e$，使得跳跃次数最少，输出次数或报告无解。

## Solution

提供一种笛卡尔树的做法。

先建出笛卡尔树，观察发现一段区间在笛卡尔树上一定存在一个最高点，使得这个区间都在该最高点的子树内。因此 check 是否有解就是找到 $[C, D]$ 的最大值，然后看 $B$ 是否在子树内。

我们取出子树内 $[A, B]$ 区间内的点，称之为起始点，称 $[C, D]$ 中的点为目标点，大胆猜想最优解一定是起始点中的最高点跳到目标点最高点所在的连通块中。

考虑证明这个，如果是某个起始点（记为 $s'$）跳到不在目标点最高点连通块的点（记为 $e'$），说明 $[B + 1, C - 1]$ 中所有数都小于 $s'$，此时一定可以从起始点的最高点一步跳到目标点最高点所在的连通块中，矛盾。

然后剩下来的就是暴力在树上跳了，先跳祖先，再跳父亲，用倍增维护，本质与其他题解相同，这里不再赘述。

## Code

```cpp
// 長い夜の終わりを信じながら
// Think twice, code once.
#include "jumps.h"
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eputchar(c) putc(c, stderr)
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define eputs(str) fputs(str, stderr), putc('\n', stderr)
using namespace std;

int l[200005], r[200005], lg[200005], mx[200005][18], f[200005][18], g[200005][18];

int query(int l, int r) {
	int k = lg[r - l + 1];
	return max(mx[l][k], mx[r - (1 << k) + 1][k]);
}
int getmx(int l, int r) {
	int val = query(l, r);
	int le = l, ri = r;
	while (le < ri) {
		int mid = (le + ri) / 2;
		if (query(l, mid) == val) ri = mid;
		else le = mid + 1;
	}
	return ri;
}

void init(int n, vector<int> h) {
	reverse(h.begin(), h.end());
	h.push_back(0);
	reverse(h.begin(), h.end());
	lg[0] = -1;
	for (int i = 1; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i++) mx[i][0] = h[i];
	for (int i = 1; i < 18; i++)
		for (int j = 1; j + (1 << i) - 1 <= n; j++)
			mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);
	vector<int> stk;
	for (int i = 1; i <= n; i++) {
		while (!stk.empty() && h[stk.back()] < h[i]) stk.pop_back();
		if (!stk.empty()) l[i] = stk.back();
		stk.push_back(i);
	}
	vector<int>().swap(stk);
	for (int i = n; i >= 1; i--) {
		while (!stk.empty() && h[stk.back()] < h[i]) stk.pop_back();
		if (!stk.empty()) r[i] = stk.back();
		stk.push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		if (h[l[i]] >= h[r[i]]) f[i][0] = l[i];
		else f[i][0] = r[i];
		g[i][0] = r[i];
		// eprintf("%d\n", f[i][0]);
	}
	for (int i = 1; i < 18; i++)
		for (int j = 1; j <= n; j++)
			f[j][i] = f[f[j][i - 1]][i - 1], g[j][i] = g[g[j][i - 1]][i - 1];
	return ;
}

int minimum_jumps(int sl, int sr, int el, int er) {
	sl++, sr++, el++, er++;
	int rt = getmx(el, er);
	if (sr <= l[rt]) return -1;
	int st = getmx(max(sl, l[rt] + 1), sr);
	// eprintf("%d %d %d\n", rt, l[rt], r[rt]);
	// eprintf("%d\n", query(sr + 1, el - 1));
	int ans = 0, limit = query(sr, el - 1);
	for (int i = 17; i >= 0; i--)
		if (f[st][i] && mx[f[st][i]][0] <= limit) {
			st = f[st][i];
			ans += 1 << i;
		}
	if (g[st][0] < el && f[st][0] && mx[f[st][0]][0] <= mx[rt][0]) st = f[st][0], ans++;
	// eprintf("%d %d\n", st, ans);
	if (el <= st && st <= er) return ans;
	for (int i = 17; i >= 0; i--)
		if (l[rt] < g[st][i] && g[st][i] < el) {
			st = g[st][i];
			ans += 1 << i;
		}
	return ans + 1;
}

```

---


# [APIO2022] 火星

## 题目背景

本题只支持 C++ 提交，提交时不需要包含 `mars.h` 头文件，只需要将附件中的 `mars.h` 中的内容粘贴到代码的开头即可。

请使用 C++14、C++17 等语言，**而不是 C++14 (GCC 9)**，因为一些未知原因这个语言下 SPJ 会 CE。

**【注】：洛谷暂不支持题面中所说的评测方式，我实现了一个洛谷支持的简易版本的交互库，但不能对传递数据进行有效限制，请各位自觉。**



## 题目描述

你们晓得，法老们是最先去过外太空的人。他们发射过首次登陆行星图特摩斯一世（Thutmus I，现在一般叫它火星）的飞船。行星的表面可以建模成由方形单元构成的 $(2n + 1) \times (2n + 1)$ 网格，其中每个单元中或者为陆地、或者为水域。对于第 $i$ 行第 $j$ 列（$0 \le i, j \le 2 \cdot n$）的单元，如果单元中为陆地，则其状态表示为 $s[i][j] = \texttt{1}$；如果单元中为水域，则表示为 $s[i][j] = \texttt{0}$。

如果在两个陆地单元之间存在某条仅由陆地单元构成的路径，而且路径中每两个连续的前后单元都有公共边，则称这两个陆地单元是连通的。行星上的岛屿被定义为两两连通的陆地单元的极大集合。

飞船的任务是统计该行星上岛屿的数量。然而，考虑到飞船的上古电脑，这事儿并不容易。电脑的内存储器 $h$ 以一个 $(2n + 1) \times (2n + 1)$ 的二维数组的形式存储数据，且数组的每个位置上可以保存长度为 $100$ 的字符串，串中的每个字母为 $\texttt{0}$（ASCII 码 $48$）或 $\texttt{1}$（ASCII 码 $49$）。初始时，存储器的每个位置的第 $0$ 位记录的是上述网格中每个单元的状态，即 $h[i][j][0] = s[i][j]$（对所有 $0 \le i, j \le 2 \cdot n$）。$h$ 中的其他位在初始时都被置为 $\texttt{0}$（ASCII 码 $48$）。

在处理存储器中的数据时，电脑只能访问存储器中的 $3 \times 3$ 区块，并且改写该区块左上角位置的值。说得更正式一点，电脑可以访问 $h[i \dots i + 2][j \dots j + 2]$（$0 \le i, j \le 2 \cdot (n - 1)$）中的值，并且改写 $h[i][j]$ 中的值。在
下文中，该过程被叫做**处理单元** $(i, j)$。

为了解决电脑能力的局限，法老们搞出了下面的套路：

- 电脑可以分成 $n$ 个阶段来操作存储器。
- 在阶段 $k$（$0 \le k \le n - 1$），令 $m = 2 \cdot (n - k - 1)$， 电脑将对所有的 $0 \le i, j \le m$，按照 $i$ 的升序以及每个 $i$ 上 $j$ 的升序，处理单元 $(i, j)$。换句话说，电脑将按照如下顺序处理这些单元：$(0, 0), (0, 1),\cdots , (0, m), (1, 0), (1, 1),\cdots , (1, m),\cdots , (m, 0), (m, 1),\cdots , (m, m)$。
- 在最后一个阶段（$k = n - 1$），电脑仅处理单元 $(0, 0)$。该阶段结束后，写入到 $h[0][0]$ 的值应该等于行星上的岛屿数量，而且该值应以字符串的形式表示成二进制，其中最低有效位对应于字符串的首字符。

下图给出了电脑操作某个 $5 \times 5$（$n = 2$）存储器的方式。蓝色单元表示该单元正在被改写，而着色的单元则表示被处理的子数组。

在阶段 $0$，电脑将以如下顺序处理下面的子数组：

![](https://cdn.luogu.com.cn/upload/image_hosting/m33yffaa.png)

在阶段 $1$，电脑将仅处理一个子数组：

![](https://cdn.luogu.com.cn/upload/image_hosting/inav002a.png)

你的任务是给出一个方法，让电脑能在给定的操作方式下，统计出行星图特摩斯一世上的岛屿数量。

## 实现细节

你需要实现下面的函数：

```cpp
string process(string[][] a, int i, int j, int k, int n)
```

- $a$：一个 $3 \times 3$ 数组，表示正在被处理的子数组。特别说明，有 $a = h[i \dots i + 2][j \dots j + 2]$，这里 $a$ 中的每个元素均为长度恰好为 $100$ 的字符串，而且串中的字符为 $\texttt{0}$（ASCII 码 $48$）或 $\texttt{1}$（ASCII 码 $49$）。
- $i, j$：电脑当前正在处理的单元的行号和列号。
- $k$：当前阶段的序号。
- $n$：阶段总数，同时也是行星表面的大小，此时行星表面包含 $(2n + 1) \times (2n + 1)$ 个单元。
- 该函数应返回一个长度为 $100$ 的二进制表示字符串。返回值将保存在电脑存储器中的 $h[i][j]$ 处。
- $k = n - 1$ 时，是该函数的最后一次调用。在此次调用中，函数应以字符串的形式返回行星上的岛屿数量的二进制表示，其最低有效位对应下标 $0$ 处的字符（二进制字符串的首字符），次低有效位对应下标 $1$ 处的字符，以此类推。
- 该函数必须独立于任何的静态或全局变量，且其返回值应仅依赖于传递给该函数的参数。

每个测试用例包括 $T$ 个独立的场景（也就是说，不同的行星表面情形）。你的函数在每个场景上的行为，必须与这些场景的顺序无关，因为对同一场景的 `process` 函数调用可能不是连续发生的。但是，可以确保对每个场景，会按照题面所描述的顺序来调用函数 `process`。

此外，对每个测试用例，你的程序可能会同时运行多个实例。内存限制和 CPU 用时限制将施加在所有这些实例的总和上。任何故意在这些实例之间偷偷传递数据的行为，都将被认定为作弊，选手可能会因此被取消比赛资格。

**【注】：洛谷暂不支持这种评测方式，我实现了一个洛谷支持的简易版本的交互库，但不能对传递数据进行有效限制，请各位自觉。**

特别说明，在调用函数 `process` 时保存在静态或全局变量中的信息，不保证在下次调用时可以读出。

## 说明/提示

## 例子

### 例 $1$

考虑 $n=1$ 的样例，其中 $s$ 如下所示：

```text
'1' '0' '0'
'1' '1' '0'
'0' '0' '1'
```

在本例中，行星表面包括 $3 \times 3$ 个单元，其中有 $2$ 个岛屿。对函数 `process` 的调用至多只有 $1$ 个阶段。

在阶段 $0$，评测程序将调用函数 `process` 恰好一次：

```cpp
process([["100","000","000"],["100","100","000"],["000","000","100"]],0,0,0,1)
```

注意这里仅展示了 $h$ 中每个元素的前 $3$ 位。

该函数应返回 $\texttt{0100}\dots$（省略的位全部为零），这里二进制的 $\dots 0010$ 等于十进制的 $2$。注意，这里省略了 $96$ 个零并用 $\dots$ 来代替。

### 例 $2$

考虑 $n=2$ 的样例，其中 $s$ 如下所示：

```text
'1' '1' '0' '1' '1'
'1' '1' '0' '0' '0'
'1' '0' '1' '1' '1'
'0' '1' '0' '0' '0'
'0' '1' '1' '1' '1'
```

在本例中，行星表面包括 $5 \times 5$ 个单元，其中有 $4$ 个岛屿。对函数 `process` 的调用至多只有 $2$ 个阶段。

在阶段 $0$，评测程序将调用函数 `process` 恰好一次：

```cpp
process([["100","100","000"],["100","100","000"],["100","000","100"]],0,0,0,2)
process([["100","000","100"],["100","000","000"],["000","100","100"]],0,1,0,2)
process([["000","100","100"],["000","000","000"],["100","100","100"]],0,2,0,2)
process([["100","100","000"],["100","000","100"],["000","100","000"]],1,0,0,2)
process([["100","000","000"],["000","100","100"],["100","000","000"]],1,1,0,2)
process([["000","000","000"],["100","100","100"],["000","000","000"]],1,2,0,2)
process([["100","000","100"],["000","100","000"],["000","100","100"]],2,0,0,2)
process([["000","100","100"],["100","000","000"],["100","100","100"]],2,1,0,2)
process([["100","100","100"],["000","000","000"],["100","100","100"]],2,2,0,2)
```

假定上面调用得到的返回值分别为 $\texttt{011},\texttt{000},\texttt{000},\texttt{111},\texttt{111},\texttt{011},\texttt{110},\texttt{010},\texttt{111}$，被省略的位均为零。因此，在阶段 $0$ 结束后，$h$ 将保存有如下的值：

```text
"011", "000", "000", "100", "100"
"111", "111", "011", "000", "000"
"110", "010", "111", "100", "100"
"000", "100", "000", "000", "000"
"000", "100", "100", "100", "100"
```

在阶段 $1$，评测程序将调用函数 `process` 一次：

```cpp
process([["011","000","000"],["111","111","011"],["110","010","111"]],0,0,1,2)
```

最后，本次函数调用应返回 $\texttt{0010000}\dots$（被省略的位均为零），这里二进制的 $\dots 0000100$ 等于十进制的 $4$。注意这里省略了 $93$ 个零并用 $\dots$ 来代替。

## 约束条件

- $1\le T\le 10$。
- $1\le n\le 20$。
- $s[i][j]$ 为 $\texttt{0}$（ASCII 码 $48$）或 $\texttt{1}$（ASCII 码 $49$）（对所有 $0\le i,j\le 2\cdot n$）。
- $h[i][j]$ 的长度恰好为 $100$（对所有 $0\le i,j\le 2\cdot n$）。
- $h[i][j]$ 中的每个字符均为 $\texttt{0}$（ASCII 码 $48$）或 $\texttt{1}$（ASCII 码 $49$）（对所有 $0\le i,j\le 2\cdot n$）。

对函数 `process` 的每次调用，都有：

- $0\le k\le n-1$。
- $0\le i,j\le 2\cdot (n-k-1)$。

## 子任务

1. （$6$ 分）$n\le 2$。
2. （$8$ 分）$n\le 4$。
3. （$7$ 分）$n\le 6$。
4. （$8$ 分）$n\le 8$。
5. （$7$ 分）$n\le 10$。
6. （$8$ 分）$n\le 12$。
7. （$10$ 分）$n\le 14$。
8. （$24$ 分）$n\le 16$。
9. （$11$ 分）$n\le 18$。
10. （$11$ 分）$n\le 20$。

## 样例 #1

### 输入

```
1
1
1 0 0
1 1 0
0 0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
1
2
1 1 0 1 1
1 1 0 0 0
1 0 1 1 1
0 1 0 0 0
0 1 1 1 1```

### 输出

```
4```

# 题解

## 作者：dengyaotriangle (赞：11)

注意若两块东西合并，那么我们只需要知道他们合并的边界上所有东西的联通情况，和它们各自的连通块个数，就可以算出总连通块个数，考虑一种进行合并的方式。

考虑除了最后一轮，每轮结束后，称当前范围为下一轮能看到的存储器，这一定是一个左上角的正方形。

我们让这些存储器存储这些信息：

- 对于不在当前范围的右边界或下边界的存储器，存储初始信息（该位置是否是水域）。
- 对于在当前范围的右边界但不是右下角的存储器，存储它以及它右边所有格子以及它下面一个格子及其右边所有格子是否是水域的信息。
- 对于在当前范围的下边界但不是右下角的存储器，对称的，存储它以及它下边所有格子以及它右面一个格子及其下边所有格子是否是水域的信息。
- 对于右下角的存储器，存储它右下角所有格子构成的正方形，上边界和左边界上所有格子中的所有陆地的格子之间的联通情况。以及连通块数量。

例如，$n=3$，第二轮结束后，当前范围是框住的正方形，其中白色格子就存储初始信息。

![](https://cdn.luogu.com.cn/upload/image_hosting/huji5w3d.png)

黄色格子则存储其以及其旁边一行或列的信息，例如这个黄色格子存储了它以及所有橙色格子是否是水域。

![](https://cdn.luogu.com.cn/upload/image_hosting/nljz5phj.png)

绿色格子则存储所有绿、浅绿、蓝色的格子中的连通块数，以及绿色和浅绿色格子中所有陆地的联通情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/hlgtp241.png)

注意这些信息求出来之后，下一轮的信息依照这些储存单元的信息也是显然可以求出来的：白色和黄色格子的信息显然是能直接求的。而至于连通块的信息，通过黄色格子可以知道除了右下角矩形内所有位置是陆地还是水域，而右下角矩形的边界上所有陆地的联通情况已知，那么显然是可以求出连通块数，以及新的矩形边界上的联通情况。

所以只要我们能够把这些信息塞到 $100$ bits 的限制里，就可以在最后一轮计算出答案。

注意不在边界的格子显然没有问题，剩下的不是右下角的格子直接把需要记录的最多 $4n-2\leq 78\leq 100$ 个格子的信息存进去就好。

剩下的就是右下角怎么编码，首先连通块数量最多 $((2n+1)^2+1)/2<2^{10}$ 个，需要 $10$ bits 编码。需要在 $90$ bits 以内编码其右下角正方形的上边界和左边界上，所有陆地之间的联通情况。

考虑把其上边界和左边界以某一个方向看成一个序列，首先这个序列上连续一段陆地一定是联通的，我们可以考虑这些陆地的连续段。然后段之间，注意网格图是平面图，如果我们把这些连续段按顺序排成一排，然后若有两个段连通，且它们中间没有其它段与他们连通，那么就连一条边。那么形成的图不会有交叉，也就是可以用括号序列来表示。

也就是说，每个连续段对应若干个（可能是 $0$ 个）括号，然后形成的括号序列所有相匹配的括号的两段是连通的。

例如上面的例子，边界上连续段是这三个，两边的连续段连通但不与中间的联通，对应的括号序列是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxiff72g.png)

再例如，若有些连续段的连通情况用红色格子表示，那么对应的括号串是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/quxdh7op.png)

注意每一个连续段可能会对应 空括号串、`(`、`)`、`)(` 四种括号串，只需要 $2$ bits 就可以编码。而上左边界长度最多 $4n-3$，那么陆地有最多 $(4n-3+1)/2=2n-1$ 段，那么这最多需要 $2(2n-1)=4n-2\leq78$ bits 表示，加上连通块数的 $10$ bits，还剩下 $12$ bits，绰绰有余。~~如果用到括号序列必定合法的性质甚至能再刨掉几个bits。~~

实际实现非常好写，只需要一个并查集维护一下，然后用栈来解码括号序列就好了。

（代码里为了方便，实际上连通块数减去了和边界相连的）

```code
#include<bits/stdc++.h>
#include"mars.h"
using namespace std;
//dengyaotriangle!

string process(vector<vector<string>> a,int i,int j,int k,int n){
    if(i==2*(n-k-1)&&j==2*(n-k-1)){
        int len=k*2+3;
        vector<vector<char> > mp(len,vector<char>(len,0));
        vector<int> fa(len*len);
        iota(fa.begin(),fa.end(),0);
        function<int(int)> grt=[&](int u){return fa[u]==u?u:fa[u]=grt(fa[u]);};
        auto tr=[&](int i,int j){return i*len+j;};
        int ans=0;
        auto tm=[&](int i,int j){
            i=grt(i),j=grt(j);
            if(i!=j)fa[i]=j,ans--;
        };
        if(k==0){
            for(int i=0;i<3;i++)for(int j=0;j<3;j++)mp[i][j]=a[i][j][0]-'0';
        }else{
            for(int i=0;i<2;i++)for(int j=0;j<2;j++)mp[i][j]=a[i][j][0]-'0';
            for(int t=0;t<2;t++){
                for(int i=1,j=2,s=0;j<len;j+=i==0,i^=1,s++){
                    mp[i+t][j]=a[t][2][s]-'0';
                }
            }
            for(int t=0;t<2;t++){
                for(int j=1,i=2,s=0;i<len;i+=j==0,j^=1,s++){
                    mp[i][j+t]=a[2][t][s]-'0';
                }
            }
            for(int i=99;i>=88;i--)ans=ans*2+a[2][2][i]-'0';
        }
        for(int i=0;i<len;i++)for(int j=0;j<len;j++)ans+=mp[i][j];//,cerr<<int(mp[i][j])<<" \n"[j==len-1];
        for(int i=0;i<len;i++)for(int j=0;j<len;j++){
            if(mp[i][j]){
                if(i+1<len&&mp[i+1][j]){
                    tm(tr(i,j),tr(i+1,j));
                }
                if(j+1<len&&mp[i][j+1]){
                    tm(tr(i,j),tr(i,j+1));
                }
            }
        }
        if(k){//decode!
            int rp=-1;
            int z=0;
            stack<int> stk;
            for(int i=2,j=len-1;i<=len;i+=j==2,j-=j>2){
                if(i==len||!mp[i][j]){
                    if(rp!=-1){
                        if(a[2][2][z]=='1'){// ) ?
                            int u=stk.top();stk.pop();
                            tm(u,rp);
                        }
                        if(a[2][2][z+1]=='1'){// ( ?
                            stk.push(rp);
                        }
                        z+=2;
                    }
                    rp=-1;
                }else rp=tr(i,j);
            }
        }
        if(k==n-1){//ret
            string x;
            for(int i=0;i<100;i++,ans/=2)x+=ans%2+'0';
            return x;
        }else{//encode!
            string ret;
            int rp=-1;
            vector<int> vec;
            for(int i=0,j=len-1;i<=len;i+=!j,j-=!!j){
                if(i==len||!mp[i][j]){
                    if(rp!=-1){
                        vec.push_back(rp);
                    }
                    rp=-1;
                }else rp=tr(i,j);
            }
            for(int i=0;i<vec.size();i++){
                string u="00";
                for(int j=0;j<i;j++){
                    if(grt(vec[i])==grt(vec[j]))u[0]='1';
                }
                for(int j=i+1;j<vec.size();j++){
                    if(grt(vec[i])==grt(vec[j]))u[1]='1';
                }
                ans-=u[0]=='0';
                ret+=u;
            }
            while(ret.size()<88)ret+='0';
            for(int i=88;i<100;i++,ans/=2)ret+=ans%2+'0';
            return ret;
        }
    }else if(i==2*(n-k-1)){
        string ret=a[2][0];
        if(k==0)ret=a[2][1][0]+ret;
        ret=a[0][1][0]+(a[0][0][0]+(a[1][1][0]+(a[1][0][0]+ret)));
        while(ret.size()>100)ret.pop_back();
        return ret;
    }else if(j==2*(n-k-1)){
        string ret=a[0][2];
        if(k==0)ret=a[1][2][0]+ret;
        ret=a[1][0][0]+(a[0][0][0]+(a[1][1][0]+(a[0][1][0]+ret)));
        while(ret.size()>100)ret.pop_back();
        return ret;
    }else return a[0][0];
}

```

---

## 作者：YLWang (赞：5)

写个嘴巴 sol。如果哥哥们发现有问题麻烦和我说一下。

场上写了 450 行没有写完，也没有意愿接着调了。

首先我们观察题面性质。每个位置给了高达 100 bit 的空间。

于是对于所有 $2n+1 \le 10$，我们可以直接把整张图状压下来然后去算答案。这个是平凡的且能获得 14 分。

同时我们发现我们容易在前几轮状压下每个位置及其右下 $9 \times 9$ 的状态。然后通过一些**小小**的讨论把他们放到最左上角，在最后一次询问中得到至多 $27 \times 27$ 的区域。可以获得 44 分。

然后你把他再稍事讨论可以压 $10\times 10 $ 获得 54 分。

接下来说正解。不妨假设 $n=20$。

发现压整张图不靠谱，我们来压边界情况。


![](https://cdn.luogu.com.cn/upload/image_hosting/c5dmfej0.png)

在最后只剩 $5\times 5$ 的时候，我将格子分为以下 2 类：

- 图中标了 O(1) 的格子。则表示其为至少一边长为 $2\times n-39$，此处即 1 的长方形。

- 其余格子。为 $10\times 10$。

那么我希望在第二类区域中压下如下信息:

- 该区域的红边上的 01 情况。40bits。

- 该区域的红边上 1 的连通性。因为我们记录了 01 情况，而且连续的 1 一定在一起，我们直接给每个 01 assign 一个 id 就好了。至多是 20 个连通块（两两差一个），很可惜每个需要 5 位。一共是 100 bits。

- 该区域的**除去边缘**的答案，需要 8bits。


这样在最后一轮我们就可以用并查集求出答案。可是问题在于位数不够了！

让我们理性分析。发现第一类点只要至多 $10$ bits 便可压下来，在混。显然我们是不能让他们划水的，否则肯定没有前途。 

于是，我们将蓝边 01 压进 1，棕边 01 压给 2，以此类推。

5 可以存一些第一类格子的信息。

那么我们只要在每个剩余格子中存下对应区域的 2 3 类信息。一共需要 108 bits。怎么办呢？

我们钦点第一个连通块编号是 0，随后一直填 0 直到第一个和其不连通的首个 1 的位置填一个 1。至少两个本应 5bit 的数分别用 1bit 表示，刚好节约了 8bit 腾给答案！

感觉还是很精妙的。


![](https://cdn.luogu.com.cn/upload/image_hosting/wadb2vcn.png)


---

## 作者：OUYE2020 (赞：1)

容易发现这个操作相当于每次把地图的行列缩小两格，然后你需要把一些有用的信息保留在剩下的格子里，使得最后能够得到连通块个数。

每次操作的位置和轮数是已知的，但是我们只能把信息存到矩阵中，这是一道很有水平的通信题。

首先可以想到一种思路，就是用当前矩阵的右下角 $(m,m)$ 记录矩阵 $(m,m)\sim(n,n)$ 的信息，右下边界上的点记录一行或一列的信息：
![在这里插入图片描述](https://img-blog.csdnimg.cn/6ab8f14ae18642ed9ee6ac07b5e81432.png)
然后每一轮我们只需要关注边界上的信息的转移，其它地方保持原数据不变，这样就能使处理的次数降维，为信息转移的部分留下足够暴力的实现可能。

首先右下边界上的信息是很好维护的，由于每个位置可记录 100bit 信息，而矩阵边长最多 41，可以直接记录一行或一列的 01 串。

重点是这个矩形内信息的维护。首先直接把整个 01 矩阵信息记录下来是不现实的，只能得很少的分。由于我们最终目的是得到连通块个数，所以可以想到类似插头 DP 的处理方法：记录矩阵内连通块个数，并记录边界线上的连通状况，然后就可以往左上添行或列转移。

连通块个数很少，所以硬塞进字符串中某个位置即可；困难的是边界线的连通状况，我们无法直接记录下包含 01 串以及连通性的所有信息。插头DP中根据状态数少的性质使用了重标号，但是这里显然没有留给我们充足的重标号时间，况且状态数还非常多。

我们只能用一种可以直接读取的压缩方式存下这个信息。

注意到除了 $(m,m)$ 这个点，其它位置存的信息都好少哦。即便是右下边界，也只使用了一半空间，还可以压榨。我们不妨让其它位置分担一下储存信息的任务：右下边界上的点额外储存一行或一列的 01 串信息。正好 $(m-1,m)$ 处和 $(m,m-1)$ 处能够收集到矩形边界线的 01 串信息，那么就可以通过这两个点的信息还原边界线的01串。

剩下需要存进 $(m,m)$ 的信息就只剩连通性了。插头 DP 里的一类经典结论，即边界线上连通的集合只会包含不会相交，就有点类似括号序列。
我们单独考虑边界线上的每一个 1 的连续段，它可能处于一个连通块的开头、中间、结尾，也可能单独为一个连通块，总情况数少于 $4^{cnt}$（$cnt$ 表示连续段个数）。

把这些信息存下来过后，我们发现可以用类似括号匹配的方法，用栈来唯一地还原出每个连通块。什么情况下入栈出栈，什么时候与前面连通块连通，稍微想一下细节就能实现。
即使是长度 $2n$ 的边界线，1的连续段个数也是不超过 $n$ 的，所以 100bit 完全存的下来。

从复杂度大概是 $O(n^3)\sim O(n^4)$ 吧，每个位置用得最多的也才不到 90bit，感觉限制给得挺松的。

# 代码
```cpp
#incluve "mars.h" //JZM yyds!!
using namespace std;
using lll = __int128;
const lll E=1;
const int MAXN=114514;
lll getlll(const string&s){
	lll res=0;
	for(int i=0;i<100;i++)res^=(E*(s[i]^48)<<i);
	return res;
}
string getstr(const lll&a){
	string s="";
	for(int i=0;i<100;i++)s+=char(((a>>i)&1)^48);
	return s;
}

int fa[MAXN],id[233][233],sk[MAXN],cnt[MAXN],lk;
bool s[233][233],d[MAXN];
int finds(int x){	//用并查集处理稍微方便一点
	return !fa[x]?x:(fa[x]=finds(fa[x]));
}
bool unions(int u,int v){
	u=finds(u),v=finds(v);
	if(u^v)return fa[v]=u,1;
	return 0;
}


string process(vector <vector<string> > a, int i, int j, int k, int n)
{
	int m=((n-k-1)<<1),le=3+(k<<1);
	if(i<m&&j<m)return a[0][0];
	if(i<m){
		if(!k){
			string s(100,'0');
			s[0]=a[0][0][0],s[1]=a[0][1][0],s[2]=a[0][2][0];
			s[3]=a[1][0][0],s[4]=a[1][1][0],s[5]=a[1][2][0];
			return s;
		}
		lll x=getlll(a[0][2]),y=x>>(le-2);
		x&=(E<<(le-2))-1;
		x=(x<<1|(a[0][1][0]^48)),x=(x<<1|(a[0][0][0]^48));
		y=(y<<1|(a[1][1][0]^48)),y=(y<<1|(a[1][0][0]^48));
		return getstr(x^(y<<le));
	}if(j<m){
		if(!k){
			string s(100,'0');
			s[0]=a[0][0][0],s[1]=a[1][0][0],s[2]=a[2][0][0];
			s[3]=a[0][1][0],s[4]=a[1][1][0],s[5]=a[2][1][0];
			return s;
		}
		lll x=getlll(a[2][0]),y=x>>(le-2);
		x&=(E<<(le-2))-1;
		x=(x<<1|(a[1][0][0]^48)),x=(x<<1|(a[0][0][0]^48));
		y=(y<<1|(a[1][1][0]^48)),y=(y<<1|(a[0][1][0]^48));
		return getstr(x^(y<<le));
	}
	lll f=getlll(a[2][2]);
	int sum=f&65535,lm=(le<<1)-5,IN=0;
	f>>=16;							//这里直接给了16位存连通块数，豪吧
	lll ln1=getlll(a[2][1])>>(le-2),ln2=getlll(a[1][2])>>(le-2);
	for(int i=0;i<2;i++)for(int j=0;j<2;j++)s[i][j]=(a[i][j][0]^48);
	for(int i=0;i<le-2;i++)s[2+i][2]=((ln1>>i)&1);
	for(int i=0;i<le-2;i++)s[2+i][1]=(a[2][1][i]^48);
	for(int i=0;i<le-2;i++)s[2+i][0]=(a[2][0][i]^48);
	for(int i=0;i<le-2;i++)s[2][2+i]=((ln2>>i)&1);
	for(int i=0;i<le-2;i++)s[1][2+i]=(a[1][2][i]^48);
	for(int i=0;i<le-2;i++)s[0][2+i]=(a[0][2][i]^48);
	if(!k){
		for(int i=0;i<3;i++)for(int j=0;j<3;j++)s[i][j]=(a[i][j][0]^48);
		sum=s[2][2],f=3;
	}
	for(int i=0;i<le;i++)
		for(int j=0;j<le;j++){
			if(i>2&&j>2)break;
			id[i][j]=++IN,d[IN]=s[i][j],fa[IN]=0;
		}
	vector<int>b;
	for(int i=le-1;i>1;i--)b.push_back(id[i][2]);
	for(int i=3;i<le;i++)b.push_back(id[2][i]);
	lk=0;
	for(int i=0,j;i<lm;i=j+1){
		int x=b[i];
		if(!d[x]){j=i;continue;}
		for(j=i;j<lm-1&&d[b[j+1]];j++)unions(b[j],b[j+1]);
		int ty=f&3;f>>=2;
		if(ty==0)sk[++lk]=x;
		else if(ty==1)unions(sk[lk],x);
		else if(ty==2)unions(sk[lk],x),lk--;
	}
	for(int i=0;i<le;i++)
		for(int j=0;j<le;j++){
			if(i>1&&j>1)break;
			sum+=s[i][j];
		}
	for(int i=0;i<le-1;i++)
		for(int j=0;j<le;j++){
			if(i>1&&j>1)break;
			if(s[i][j]&&s[i+1][j])sum-=unions(id[i][j],id[i+1][j]);
		}
	for(int i=0;i<le;i++)
		for(int j=0;j<le-1;j++){
			if(i>1&&j>1)break;
			if(s[i][j]&&s[i][j+1])sum-=unions(id[i][j],id[i][j+1]);
		}
	b.clear();
	for(int i=le-1;i>=0;i--)b.push_back(id[i][0]);
	for(int i=1;i<le;i++)b.push_back(id[0][i]);
	lm=b.size();
	for(int i=0;i<=IN;i++)cnt[i]=0;
	for(int x:b)cnt[finds(x)]++;
	lk=0,f=0;lll mi=1;
	for(int i=0,j;i<lm;i=j+1){
		int x=b[i];
		if(!d[x]){j=i;continue;}
		for(j=i;j<lm-1&&d[b[j+1]];j++);
		if(!lk||finds(sk[lk])!=finds(x)){
			sk[++lk]=x,cnt[finds(x)]-=j-i+1;
			if(!cnt[finds(x)])f+=mi*3,lk--;
		}else{
			cnt[finds(x)]-=j-i+1,f+=mi;
			if(!cnt[finds(x)])f+=mi,lk--;
		}mi<<=2;
	}
	return k==n-1?getstr(sum):getstr(f<<16|sum);
}
```

---


# [APIO2022] 游戏

## 题目背景

本题只支持 C++ 提交，提交时不需要包含 `game.h` 头文件，只需要将附件中的 `game.h` 中的内容粘贴到代码的开头即可。

## 题目描述

法老们发现了标号从 $0$ 到 $n - 1$ 的 $n$ 个星球，并且在它们之间建立了一个**单向传输系统**。在这个传输系统中，每个传送器连接一个起始星球和一个目的星球。当游客从一个起始星球使用传送器，就可以到达对应的目的星球。需要注意的是，起始星球和目的星球有可能是同一个星球。我们使用 $(u, v)$ 表示一个起始于星球 $u$ 到达星球 $v$ 的传送器。

为了促进传输系统的广泛使用，法老们设计了一个供游客们在乘坐传送系统时可以进行的游戏。一名游客可以从任一星球出发。标号 $0, 1,\dots , k - 1$（$k \le n$）的星球被称为**特殊星球**。当游客每次进入一个特殊星球，就可以获得一枚邮票。

目前，对于每个星球 $i$（$0 \le i \le k - 2$），都建立了一个传送器 $(i, i + 1)$。这 $k - 1$ 个传送器叫做**起始传送器**。

传送器随着时间不断建立。随着传送器的建立，一名游客也许有可能获得无穷多枚邮票。准确来说，这种情况会在存在一个满足如下条件的星球序列 $w[0], w[1],\dots , w[t]$ 时发生：

- $1 \le t$。
- $0 \le w[0] \le k - 1$。
- $w[t] = w[0]$。
- 对于每个星球 $i$（$0 \le i \le t - 1$），存在一个传送器 $(w[i], w[i + 1])$。

注意一名游客能够使用起始传送器和任何一个目前已经建立的传送器。

你的任务是，帮助法老验证在每次加入新的传送器后，一位游客是否能够拿到无穷多枚邮票。

## 实现细节

你需要实现下述函数：

```cpp
init(int n, int k)
```

- $n$：星球数量。
- $k$：特殊星球数量。
- 这个函数只会被调用一次，早于任何一次 `add_teleporter` 调用。

```cpp
int add_teleporter(int u, int v)
```

- $u$ 和 $v$：被加入传送器的起始和目的星球。
- 这个函数至多被调用 $m$ 次（$m$ 的取值范围参阅“约束条件”部分的内容）。
- 如果当传送器 $(u, v)$ 被加入后游客能够获得无穷多枚邮票，函数需要返回 $1$。否则，这个函数应该返回 $0$。
- 一旦函数返回了 $1$，你的程序将会被终止。

## 说明/提示

## 例子

### 例 $1$

考虑下面的函数调用：

```cpp
init(6, 3)
```

在这个例子里，有 $6$ 个星球和 $3$ 个特殊星球，标号为 $0,1,2$ 的星球是特殊星球。起始传送器是 $(0,1)$ 和 $(1,2)$。

假设评测程序执行下述调用：

- (0) `add_teleporter(3, 4)`：应该返回 $0$。
- (1) `add_teleporter(5, 0)`：应该返回 $0$。
- (2) `add_teleporter(4, 5)`：应该返回 $0$。
- (3) `add_teleporter(5, 3)`：应该返回 $0$。
- (4) `add_teleporter(1, 4)`：在这种情况下，是可能获得无穷多枚邮票的。例如，游客可以从星球 $0$ 出发，按照 $1, 4, 5, 0, 1, 4, 5, 0,\dots$ 这个顺序进行。因此，函数需要返回 $1$，进一步你的程序会被终止。

下图对于这个例子进行了说明。特殊星球和起始传送器都使用粗体字表示。通过 `add_teleporter` 加入的传送器，按照顺序被标记为 $0$ 到 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/q80oy4px.png)

### 例 $2$

考虑下面的函数调用：

```cpp
init(4, 2)
```

在这个例子里，有 $4$ 个星球和 $2$ 个特殊星球。标号为 $0$ 和 $1$ 星球是特殊星球。起始传送器是 $(0, 1)$。

假设评测程序执行下述调用：

- `add_teleporter(1, 1)`：当加入传送器 $(1, 1)$ 后，我们就能够获得无穷多枚邮票。例如，游客从星球 $1$ 出发，可以使用传送器 $(1, 1)$ 到达星球 $1$ 无限次。因此，函数需要返回 $1$，然后你的程序被终止。

附件包里还包含了另一个样例输入输出。

## 约束条件

- $1\le n\le 3\times 10^5$；
- $1\le m\le 5\times 10^5$；
- $1\le k\le n$。

对于每次调用 `add_teleporter` 函数：

- $0\le u\le n-1$ 和 $0\le v\le n-1$；
- 在传送器 $(u,v)$ 加入之前，不会有从星球 $u$ 到星球 $v$ 的传送器。

## 子任务

1. （$2$ 分）$n=k$，$n\le 100$，$m\le 300$；
2. （$10$ 分）$n\le 100$，$m\le 300$。
3. （$18$ 分）$n\le 10^3$，$m\le 5\times 10^3$。
4. （$30$ 分）$n\le 3\times 10^4$，$m\le 5\times 10^4$，$k\le 10^3$。
5. （$40$ 分）没有额外的约束条件。

## 样例 #1

### 输入

```
6 5 3
3 4
5 0
4 5
5 3
1 4```

### 输出

```
4```

## 样例 #2

### 输入

```
4 1 2
1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
4 3 2
1 3
2 0
3 2```

### 输出

```
2```

# 题解

## 作者：psoet (赞：17)

#### $O((n + m)k)$

$[0, k-1]$ 的链是很特殊的，应该想到要从它身上下手。

一个点能够到达的链上部分是一个后缀，能到达一个点的链上部分是一个前缀，分别记作 $suf_u$ 和 $pre_u$ ，如果没法到链/没法从链到达则分别记为 $k$ 和 $-1$ 。

那么对于一个不是特殊点的 $u$ ，存在一个过 $u$ 和特殊点的环当且仅当 $pre_u \geq suf_u$ 。注意特别处理链上“回边”的情况。

我们可以在加边的时候同时维护 $pre$ 和 $suf$ ，暴力搜，每次只更新需要更新的点。这样复杂度是 $O((n+m)k)$ 。

#### $O((n + m) \log k)$

（下面内容主要参考自 dengyaotriangle 在LOJ上的提交记录）

维护 $pre$ 和 $suf$ 的全部变化显然是做不下去的。

但是注意：对 $pre$ 和 $suf$ 的修改并不需要一步到位。我们只需把它修改到某个是否有环一目了然的状态即可。

我们对 $[-1,k]$ 建一棵线段树。在还没找到环的时候， $[pre_u,suf_u]$ 构成一些区间。

一开始，所有的特殊点区间都对应叶子，所有的非特殊点区间都对应根节点。

我们声称：每个区间都只需调整到线段树的某个节点。

假设当前连了一条边 $u \rightarrow v$ 。首先特判掉 $u$ 和 $v$ 均是特殊点的情况。

线段树的两个区间只有三种位置关系：相离、包含和重合（我们单独考虑重合）。

下面的推导中，我们只用承认两个基本事实：
1. 只要可以判断是否有环，我们就不用进行下一步的调整。
2. 如果 $u \rightarrow v$ 没有在 $u$ 和 $v$ 的区间上带来改变，我们可以直接返回。

##### Case 1 $u$ 和 $v$ 的区间相离

分为两种情况：

假如 $u$ 的区间在 $v$ 的区间左边，一定不会有环出现，可以直接返回。

否则 $u$ 的区间在 $v$ 的区间右边，我们找到了一个环。

##### Case 2 $u$ 和 $v$ 的区间重合

这种情况不会带来环，我们可以直接返回。

当然，这里假设了 $u$ 和 $v$ 的当前区间不是叶子，否则在上一层我们就返回了。

##### Case 3 $u$ 和 $v$ 的区间相互包含

**如果 $v$ 的区间在 $u$ 的左儿子内：**

![](https://cdn.luogu.com.cn/upload/image_hosting/5ucj2thn.png)

此时 $u$ 的区间会被改成图中的样子，但我们只需把 $u$ 变成其节点的左儿子，然后递归下去。

**如果 $u$ 的区间在 $v$ 的右儿子内：**

![](https://cdn.luogu.com.cn/upload/image_hosting/kf4yldgz.png)

此时 $v$ 的区间会被改成图中的样子，但我们只需把 $v$ 变成其节点的右儿子，然后递归下去。

注意可能产生长度为 1 的区间，需要直接返回。

如果不进行这两步调整，我们就无法在这一步以及以后的过程中判断是否有环，所以它们是必要的。

其它两种情况，可以证明都不会产生环。比如，

![](https://cdn.luogu.com.cn/upload/image_hosting/hv31s0ot.png)

这种情况下一定不会产生环，只需考虑和 $mid_u$ 、$mid_u + 1$ 的连通情况即可。

于是复杂度 $O((n+m) \log k)$ 。

代码：

```cpp
#include <bits/stdc++.h>

#include "game.h"

#define For(i, a, b) for (int i = a, i##end = b; i <= i##end; ++i)
#define rFor(i, b, a) for (int i = b, i##end = a; i >= i##end; --i)

const int kN = 3e5 + 5;

int n, k, lb[kN], rb[kN];
std::vector<int> G[kN][2];

void init(int _n, int _k) {
	n = _n, k = _k;
	std::fill(lb, lb + n, -1);
	std::fill(rb, rb + n, k);
	For(i, 0, k - 1) {
		lb[i] = rb[i] = i;
	}
}

bool add(int, int);

bool add(int u) {
	for (int v : G[u][0]) if (add(u, v)) return true;
	for (int v : G[u][1]) if (add(v, u)) return true;
	return false;
}

bool add(int u, int v) {
	if (u < k && v < k) return u >= v;
	if (rb[u] < lb[v]) return false;
	if (lb[u] > rb[v]) return true;
	if (lb[u] == lb[v] && rb[u] == rb[v]) return false;
	int midu = (lb[u] + rb[u]) >> 1, midv = (lb[v] + rb[v]) >> 1;
	if (lb[v] >= lb[u] && rb[v] <= midu) {
		rb[u] = midu;
		return lb[u] == rb[u] || add(u);
	}
	if (rb[u] <= rb[v] && lb[u] > midv) {
		lb[v] = midv + 1;
		return lb[v] == rb[v] || add(v);
	}
	return false;
}

int add_teleporter(int u, int v) {
	G[u][0].push_back(v), G[v][1].push_back(u);
	return add(u, v);
}

```

---

根据[WeLikeStudying的题解](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/apio2022-t2-post)，应该存在一种跟二进制分组有关的做法。

这是比较自然的：这个问题很容易用离线分治解决，而二进制分组的名头就在于它可以在线地解决一类 cdq 分治能够解决的问题。

但以前见过的例子都是可以分体贡献的，这个好像不太一样。而且我没看懂他写的东西/kk。并不知道二进制分组怎么扩展到更一般的问题。

---

## 作者：RiverHamster (赞：15)

做法来自 [水军带你飞](https://www.luogu.com.cn/user/50558)，不太清楚怎么想到的（可能是比大小转 01？），这里只描述做法。

注意到关键点是一条链，拓扑序已知，所以可以对于非关键点，设 $s_u$ 表示可达 $u$ 的最大标号关键点，$t_u$ 表示 $u$ 可达的最小标号关键点。每次暴力 DFS 维护 $s, t$，一旦存在 $s_u \ge t_u$ （称 $u$ 不合法）说明出现环。

维护 $s, t$ 的过程难以直接优化，考虑对于值域建分治树，根节点是 $[-1, k]$，每个节点均分成两个子节点。将 $[s_u, t_u]$ 视为区间，并记录包含 $[s_u, t_u]$ 的极小节点 $p_u$。我们只维护 $p_u$ 的变化，这样若 $p_u$ 为叶子说明出现不合法情况。

注意到区间有性质：（$u, v$ 可达指 $u$ 可达 $v$ 或 $v$ 可达 $u$）

- 若有边 $u \to v$，则 $s_u \le s_v, t_u \le t_v$。

如果 $u, v$ 的区间不交，则 $u, v$ 的区间缩小不会互相影响，否则 $u, v$ 一定有祖先-后代关系。

1. 如果 $p_u = p_v$，则若 $p_u$ 不变，则 $p_v$ 一定不变。
2. 否则不妨假设 $v$ 可达 $u$，且 $u$ 不可达 $v$，$v$ 在 $u$ 的左子树中：若 $u$ 会更新 $v$，则 $t_u$ 必定小于等于分治区间的中点 $mid$，（因为 $t_v \le mid$），因此 $p_u$ 变化是 $u$ 更新 $v$ 的必要条件。其他情况是类似的。

因此我们只需在 $p_u$ 变化时暴力扫描 $u$ 的邻边更新，并递归地处理其他点 $p$ 被更新的情况即可。

我们没有处理同层点之间的更新，但如果 $u$ 的层数变化（假设是因为 $t_u$ 变化），则可能影响 $s_u$ 的点 $v$ 层数也会变化（因为必有 $p_u = p_v$，否则与上述第二条矛盾），从而也会遍历邻边，则此时 $s_u$ 同样可以被正确更新。

因为每个点 $p_u$ 只会变化 $\log k$ 次，而每次会遍历 $u$ 的邻边，所以时间复杂度 $\mathcal O(m \log k)$。

---

## 作者：Alex_Wei (赞：13)

#### [P8375 [APIO2022] 游戏](https://www.luogu.com.cn/problem/P8375)

堪称神题。

注意到如果形成环，则环上的点和主链 $0\to 1\to\cdots \to k - 1$ 的交是一段子链 $L\to L + 1 \to \cdots \to R$，且 $R\rightsquigarrow L$。

考虑环上的一条边 $i\to i + 1$，若子链包含该边，说明 $[i + 1, k)$ 可达 $[1, i]$。

接下来是一步非常厉害的操作。我们维护两个点集：可达 $[1, i]$ 的点集 $S_1$ 和 $[i + 1, k)$ 可达的点集 $S_2$。这样，**如果最终子链不包含 $i\to i + 1$，则环上的所有点一定同时属于 $S_1$ 或同时属于 $S_2$**。否则：

- 若环上有同时属于 $S_1$ 和 $S_2$ 的点，显然存在经过 $i\to i + 1$ 的环。
- 若环上有属于 $S_1$ 的点和属于 $S_2$ 的点，通过调整法总可以得到经过 $i\to i + 1$ 的环。
- 根据 $S_1$ 和 $S_2$ 的定义，不存在不属于 $S_1$ 且不属于 $S_2$ 的点。

设一个点的状态为 $0$（不属于 $S_1$ 和 $S_2$），$1$（属于 $S_1$）或 $2$（属于 $S_2$），那么根据上述性质，**只有当一条边的两端状态均为 $1$ 或均为 $2$ 时，才需要递归进入对应子区间**。又因为 $S_1$ 和 $S_2$ 不交（有交就游戏结束了），这启发我们采用分治：对每个区间 $I = [l, r]$，维护图 $G_I$ 表示可能对点的状态产生影响的边。将 $u\to v$ 加入 $G_I$ 时：

- 若 $u$ 的状态为 $2$ 且 $v$ 的状态为 $1$，则游戏结束。
- 否则，若 $u$ 的状态为 $2$，则从 $v$ 开始在图上 DFS，遇到状态为 $2$ 的点则返回，那么只会遇到状态为 $0$ 的点（如果遇到状态为 $1$ 的点，则 $v$ 的状态为 $1$，矛盾），将其状态改为 $2$。并将遍历到的所有边从 $G_I$ 中删除（没有用了，不会再改变点的状态，即两端状态相同）下放至左子区间，即 $G_{[l, mid]}$。同时将 $u\to v$ 下放至 $G_{[l, mid]}$（两端均为 $2$）。
- 类似地，若 $v$ 的状态为 $1$，则从 $u$ 开始在 **反图** 上 DFS，遇到状态为 $1$ 的点则返回，遇到状态为 $0$ 的点将其状态改为 $1$，并将遍历到的所有边从 $G_I$ 中删除，下放至右子区间 $G_{(mid, r]}$。同时将 $u\to v$ 下放至 $G_{(mid, r]}$（两端均为 $1$）。

正确性很好理解：根据之前的性质，对于一条边，只有其两端状态相同时，它才可能出现在子链不包含 $mid\to mid + 1$ 的环上，即递归至对应子区间。

很明显地，一个点在同一层只会在一个区间的 $G$ 内：它在父区间的状态决定了它递归进哪个子区间。同理，一条边在一层最多出现一次，且任意时刻只会出现在一个区间：**只有它对父区间的点的状态不会再产生影响的时候，才会被下放至子区间**。

梳理一下整道题的核心思路：考虑假设环经过 $i\to i + 1$，那我们只关心一个点能否到达 $[1, i]$，以及是否由 $[i + 1, k)$ 可达。我们发现，如果一条边还有可能对点的状态产生影响，就一定不会出现在不经过 $i\to i + 1$ 的环上。若不会对点的状态产生影响，那么它两侧的点要么均可达 $[1, i]$，要么均由 $[i + 1, k]$ 可达。基于此，容易设计类线段树的分治算法。

还有一个小问题：如果环和主链无交边怎么办？考虑将所有边的 $u$ 加 $1$，若 $v \geq k$ 则 $v$ 加 $1$，并认为主链为 $0\to 1\to \cdots \to k$，则原图所有以关键点（编号小于 $k$ 的点）开头，以关键点结尾且中间不经过关键元素的路径的开头编号均增加 $1$，因此原图的符合要求的环在变换后的图上和主链有交。

实现是简单的：记录 $st_{d, i}$ 表示 $i$ 在第 $d$ 层的状态，用邻接链表存图（每个点在一层只会有一个 $head$）。时空复杂度均为 $\mathcal{O}(m\log n)$。[代码](https://uoj.ac/submission/619912)。

尝试进一步简化算法：直接维护原图和反图。DFS 到点 $u$ 说明它的所有不小于 $d$ 层的状态均不为 $0$。此时对于原图或反图的出边 $u\to v$，若 $v$ 在某个小于 $d$ 层的状态和 $u$ 不同，说明该边还未被下放至当前区间，直接跳过。对所有 $st_{*, i}$ 压位即可快速判断。这样，空间复杂度优化至 $\mathcal{O}(m)$。[代码](https://uoj.ac/submission/619911)。

仔细思考可知 $st_{*, i}$ 等价描述了每个点当前落在了线段树上的哪个区间。这样就会发现上述做法和其它题解的做法是本质相同的。

---

## 作者：是青白呀 (赞：4)

这里主要对线段树结构的做法进行详细解释。

首先，动态判环是不容易做的，考虑定义一个可以简单判断是否有环的判据。我们设 $le_i$ 表示可以到达点 $i$ 的编号最大的特殊点，$ri_i$ 表示点 $i$ 可以到达的编号最小的特殊点，若没有相应的点，则设 $le_i=0$，$ri_i=k+1$。则有环满足条件的充要条件是存在 $i$ 使得 $ri_i\leq le_i$。于是每次 bfs 更新，可以做到 $O(k(n+m))$。

对于一个图的结构，想要用某种方法动态维护每个点的准确的 $ri_i$ 和 $le_i$ 是不容易的，于是我们考虑适当放缩条件。不难发现在初始时，对于一个特殊点 $i$，有 $le_i=ri_i$，否则有 $le_i=0$，$ri_i=k+1$，两两相互包含或重合。

我们选用线段树的结构来表示每一个点对应的区间 $[le_i,ri_i]$。具体地，我们对 $0\sim k+1$ 的序列开一棵线段树，对每个点 $i$，找到一个线段树上的节点 $[l_i,r_i]$，使得 $l_i\leq le_i$，$r_i\geq ri_i$ 且 $r_i-l_i$ 最小。则有满足条件的环的充要条件变为存在一个非特殊点 $x$，其在线段树上对应的节点是叶子结点。由于节点之间两两包含或不交，且线段树自带 $\log$ 的特性，更新变得容易了许多。

下面对于连边 $(u,v)$ 的具体情况讨论更新方式。

1. 特判掉 $u$ 和 $v$ 均为特殊点的情况。

2. 若 $u$ 和 $v$ 不交，则此时两个点的实际区间也不交。若 $u$ 完全在左侧，则没有任何更新，否则直接成环。

3. 若 $u$ 包含（但不等于） $v$：此时 $u$ 和 $v$ 的实际区间有可能相交。若两者的实际区间不相交，仍然是 $u$ 在右侧时可成环；下面先讨论两者实际区间相交（不包含）的情形。

   - 若 $le_u<le_v$，则没有任何更新
   - 否则 $u$ 和 $v$ 的区间都更新为 $[le_u,ri_v]$。

   再考虑两者实际区间相包含的情况。

   - 若 $u$ 包含 $v$，则 $ri_u\leftarrow ri_v$。
   - 否则 $le_v\leftarrow le_u$。

   此时，可以开始讨论线段树上如何更新。

   - 若 $u$ 在 $v$ 的左儿子下方，此时一定有 $ri_v>mid\geq ri_u$。无论是完全不交（$u$ 在 $v$ 左侧）、相交（$le_u<le_v$）还是 $v$ 包含 $u$，都不更新线段树上的区间。
   - 若 $u$ 在 $v$ 的右儿子下方，此时一定有 $le_v\leq mid<le_u$。无论是完全不交、相交、还是包含，都至少有 $le_v\leftarrow le_u$ 一个更新，也即 $v$ 要更新到 $v$ 的右儿子处再继续考虑。
   - 若 $v$ 在 $u$ 的左儿子下方，此时一定有 $ri_u>mid\geq ri_v$。也即至少有 $ri_u\leftarrow ri_v$ 一个更新，所以 $u$ 要更新到其左儿子处再继续考虑。
   - 若 $v$ 在 $u$ 的右儿子下方，此时一定有 $le_u\leq mid<le_v$。无论是完全不交、相交、还是包含，都不更新线段树上的区间。

4. 若 $u$ 和 $v$ 两个点在线段树上的对应区间相同，则无论 $le$ 和 $ri$ 互相怎么赋值，都仍然会跨过 $mid$，不需要更新。

需要注意的是，若一个点的区间有更新，那么所有和它有连边的点都需要考虑是否会更新。

依照上文模拟即可。由于线段树深度限制，时间复杂度为 $O((n+m)\log k)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define pb push_back
using namespace std;
typedef long long ll;
const int maxN=3e5+5,maxM=5e5+5,mo=998244353,inf=1e9+7,bs=19491001;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,k;
int le[maxN],ri[maxN];
vector<int>ein[maxN],eot[maxN];
void init(int N, int K) {
	n=N,k=K;
	rep(i,1,n){
		if(i<=k)le[i]=ri[i]=i;
		else le[i]=0,ri[i]=k+1;
	}
}
int solve(int u,int v){
	if(u>k&&le[u]==ri[u])return 1;
	if(v>k&&le[v]==ri[v])return 1;
	if(le[u]>=ri[v])return 1;
    if(le[v]>=ri[u])return 0;
    if(le[u]==le[v]&&ri[u]==ri[v])return 0;
	int midu=(le[u]+ri[u])>>1,midv=(le[v]+ri[v])>>1;
	if(le[u]>midv&&ri[u]<=ri[v]){
		le[v]=midv+1;
		int ok=0;
		for(auto i:ein[v])
		    ok|=solve(i,v);
		for(auto i:eot[v])
		    ok|=solve(v,i);
		return ok;
	}
	if(ri[v]<=midu&&le[v]>=le[u]){
		ri[u]=midu;
		int ok=0;
		for(auto i:ein[u])
		    ok|=solve(i,u);
		for(auto i:eot[u])
		    ok|=solve(u,i);
		return ok;
	}
	return 0;
}
int add_teleporter(int u, int v) {
	u++,v++;
	ein[v].push_back(u),eot[u].push_back(v);
	if(u<=k&&v<=k)return (u>=v);
    if(le[u]>=ri[v])return 1;
    if(le[v]>=ri[u])return 0;
    if(le[u]==le[v]&&ri[u]==ri[v])return 0;
    return solve(u,v);
}
```

---

## 作者：luogubot (赞：4)

一张 $n$ 个点的有向图，点从 $0\sim n-1$ 编号，初始对于 $0\leq i\leq k-2$，有边 $i\to i+1$，前 $k$ 个点称为关键点。$m$ 次操作在图中加入一条有向边，你需要回答加入之后图中是否存在包含至少一个关键点的环，强制在线。

子任务：$n\leq 3\times 10^4$，$m\leq 5\times 10^4$，$k\leq 10^3$。

$n\leq 3\times 10^5$，$m\leq 3\times 10^5$，$1\leq k\leq n$。2s。

1. 关注这条链的特殊性：动态判图中是否存在环是困难的。是困难的。是困难的。

   对于每个点 $u$，$u$ 能到这条链上的一个后缀，设后缀起点为 $R_u$；这条链上的一个前缀能到 $u$，设前缀终点为 $L_u$。则如果出现了 $L_u\ge R_u$，那么存在环 $u\to R_u\to L_u\to u$。注意到 $L,R$ 的值域是 $O(k)$ 的，于是暴力维护这个过程，势能分析是 $O((n+m)k)$ 的（每个点只会在被更新时遍历，每条边只会在某个端点被更新时遍历）。

2. 直观想法是减少关键点的数量，所以可以考虑对关键点分块，如果只维护 $L,R$ 所在的块，那么相当于只有 $O(\sqrt k)$ 个关键点，根据上面的势能分析，复杂度是 $O((n+m)\sqrt k)$ 的；但是当 $L,R$ 在同一个块时，我们需要知道其具体节点编号以判断是否有环。这个可以当 $x,y$ 中的某一个从不在同一块到在同一块时，暴力地搜索有用的点。例如 $x$ 的区间是 $[S,R]$，$y$ 的区间是 $[L,S]$ 时，会被合并成 $[S,S]$，那么从 $y$ 出发，在原图上搜索：如果是 $[L',S]$ 的区间则继续搜；如果是 $[S,S]$ 的区间那么已经有具体编号了，可以直接继承，不用继续搜。搜到的点都会被更新成在同一块内的情况，也就是这部分均摊到每个点上也是 $O(1)$ 的。反图上同理。这样对于在同一块内的情况我们也暴力更新，这部分也是 $O((n+m)\sqrt k)$ 的。

3. 如何再拓展呢？上面的做法让我们更加关心区间 $[L_u,R_u]$ 信息。不妨讨论一下区间之间的关系，发现产生环的情况的必要条件是两区间无交，有交时虽然产生一些更新，但是不会直接导致环的产生。所以我们需要一个能够判断区间是否不交，维护有交时更新的结构。一个想法是，肯定不能维护完整的 $L,R$ 的值的信息，突破口在于查询只需要判断区间是否一定不交。这样就能产生一个分治结构：把区间放在第一个跨过中点的分治区间，也只记录其对应的分治区间端点 $p_u=[l_u,r_u]$，那么对于边 $x\to y$，产生环的情况即为 $r_y\leq l_x$，否则如果 $p_x$ 在 $p_y$ 的右子树，那么 $p_y$ 会向右分治区间至少走一步；如果 $p_y$ 在 $p_x$ 的左子树，$p_x$ 会向左分治区间至少走一步。由于“走一步”这样的更新次数是 $O(n\log k)$ 的，所以可以暴力每次只走一步。至此可以看作是只有 $O(\log k)$ 次更新的原问题，势能分析自然是 $O((n+m)\log k)$ 的。
4. 有了正解再回首观察直接的分块做法，本质就是层数比较少，或者说儿子数比较多的分治，“确定具体编号”这一步实际上是在找它应该被挪向哪一个儿子，但由于没有比较明显的分治结构，找起来反而是比正解更麻烦的。于是两个做法本质上是相通的。
5. 整体的思考流程是 $k$ 比较小引出势能分析的 $O((n+m)k)$ 做法，再为了减少关键点引出分块的 $O((n+m)\sqrt k)$ 做法，最后重点关注区间信息，讨论需要支持什么操作，导出分治结构引出正解。

[code](https://www.luogu.com.cn/paste/cv48uqwe)



---

## 作者：Leasier (赞：3)

~~感觉这道题好抽象啊。~~

下文默认标号从 $1$ 开始。

首先有一个简单的 $O(m(n + m))$ 暴力：

- 考虑维护 $l_i$ 表示从 $i$ 出发所能到达的最左侧点（不包括一开始的 $i$ 自己）。
- 每次从 $v$ 开始在反图上 bfs 更新所有 $l_i$。
- 若某次更新完成后存在某个 $1 \leq i \leq k$ 使得 $l_i \leq i$，则我们可以先从 $i$ 走到 $l_i$，再沿着那条链走到 $i$，此时返回 $1$；否则返回 $0$。

~~令人 /jy 的是这玩意可以通过前四个 Subtask！！！~~

上面这个东西看上去不是很好优化，考虑换一种形式来表示这个环：

- 考虑维护 $l_i, r_i$ 表示最大 $l_i$、最小 $r_i$ 使得 $l_i, r_i \in [1, k]$ 且存在一条 $r_i \to i \to l_i$ 的路径。设 $l_i$ 不存在时为 $0$，$r_i$ 不存在时为 $k + 1$，则一开始这些 $[l_i, r_i]$ 两两包含。
- 当我们加边 $u \to v$，则每次令 $l_v \leftarrow \max(l_v, l_u), r_u \leftarrow \min(r_u, r_v)$，于是每次更新后 $[l_i, r_i]$ 两两包含或不交。
- 若某次更新完成后存在某个 $1 \leq i \leq n$ 使得 $l_i \leq r_i$，则成环，此时返回 $1$；否则返回 $0$。
- 由于 $l_i, r_i$ 只会变化 $O(k)$ 次，直接 bfs 更新即可做到 $O(k(n + m))$。

**注意到当 $k$ 很小时，这一算法会跑得很快。**

**又注意到我们其实更加关心相对的大小关系，考虑分治，此时我们在分治树上的每一层就只需要考虑两个区间的关系（也就是说在某种程度上可以近似为一个 $k = 2$ 的问题）及更新后对周围边的影响了**。

设 $S[l, r]$ 表示 $[0, k + 1]$ 的分治树上极小的包含 $[l, r]$ 的区间。

现在来具体地讨论一下加边 $u \to v$ 的情况：

- 当某次 $l_u \geq r_v$，已成环。
- 当 $S[l_v, r_v] \subseteq \operatorname{lson}(S[l_u, r_u])$，令 $S[l_u, r_u] \leftarrow \operatorname{lson}(S[l_u, r_u])$ 并去尝试更新与 $u$ 有关的其他边即可。
- 当 $S[l_u, r_u] \subseteq \operatorname{rson}(S[l_v, r_v])$，令 $S[l_v, r_v] \leftarrow \operatorname{rson}(S[l_v, r_v])$ 并去尝试更新与 $v$ 有关的其他边即可。
- 否则不可能出现环。

于是维护所有 $S[l_i, r_i]$ 的端点即可。由于每次在分治树上递归都会使得某个点的 $|S[l_i, r_i]|$ 减小一半，则时间复杂度为 $O((n + m) \log k)$。

代码：
```cpp
#include "game.h"

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct {
	int cnt = 0;
	int head[300007];
	Edge edge[800007];
	
	inline void add_edge(int start, int end){
		cnt++;
		edge[cnt].nxt = head[start];
		head[start] = cnt;
		edge[cnt].end = end;
	}
} Graph;

int n, k;
Graph g1, g2;
int l[300007], r[300007];

bool update(int u, int v);

void init(int n, int k){
	int ki = k + 1;
	for (int i = 1; i <= k; i++){
		int ii = i + 1;
		l[i] = r[i] = i;
		if (i < k){
			g1.add_edge(i, ii);
			g2.add_edge(ii, i);
		}
	}
	for (int i = k + 1; i <= n; i++){
		l[i] = 0;
		r[i] = ki;
	}
}

bool dfs(int u){
	for (int i = g1.head[u]; i != 0; i = g1.edge[i].nxt){
		if (update(u, g1.edge[i].end)) return true;
	}
	for (int i = g2.head[u]; i != 0; i = g2.edge[i].nxt){
		if (update(g2.edge[i].end, u)) return true;
	}
	return false;
}

bool update(int u, int v){
	if (l[u] >= r[v]) return true;
	int mid1 = (l[u] + r[u]) >> 1;
	if (r[v] <= mid1){
		r[u] = mid1;
		return dfs(u);
	}
	int mid2 = (l[v] + r[v]) >> 1;
	if (l[u] > mid2){
		l[v] = mid2 + 1;
		return dfs(v);
	}
	return false;
}

int add_teleporter(int u, int v){
	u++;
	v++;
	g1.add_edge(u, v);
	g2.add_edge(v, u);
	return update(u, v) ? 1 : 0;
}
```

---

## 作者：DengDuck (赞：2)

这道题还是很巧妙的。

首先无限邮票相当于走环，也就是说，我们需要判断是否存在一条覆盖有至少一个特殊点的环。

注意到有 $k$ 个特殊点，而且其编号恰好是连续的 $[0,k-1]$，也就是说，编号小的特殊点一定可以到编号大的特殊点。

那么，我们可以想出这样一个思路：

- 记录编号最大的能到达点 $i$ 的特殊点 $l_i$，不存在设为 $-1$。
- 记录编号最小的 $i$ 能到达的特殊点 $r_i$，不存在设为 $k$。

注意到当 $r_i\leq l_i$ 时，有路径 $i\to r_i\to l_i\to i$，此时可取无限邮票。

初始化实现如下：

```cpp
for(int i=0;i<=n-1;i++)
{
	l[i]=-1,r[i]=k;
}
for(int i=0;i<=k-1;i++)
{
	l[i]=r[i]=i;
}
```

我们考虑维护 $l_i$ 和 $r_i$，时间复杂度为 $O(nk)$ 级别的。

接下来我们考虑将 $[l_i,r_i]$ 看作线段，对于每次的加边 $(x,y)$，考虑以下情况：

- $x$ 与 $y$ 都是特殊点，如果 $y\leq x$ 那么有环，否则无影响。
- 区间 $x$ 在区间 $y$ 左侧，无影响。
- 区间 $x$ 在区间 $y$ 右侧，可形成需要的环。
- 区间 $x$ 与区间 $y$ 重合，无影响。

这是几种基础情况，判断代码如下:

```cpp
if(x<k&&y<k)return x>=y;
if(r[x]<l[y])return 0;
if(l[x]>r[y])return 1;
if(l[x]==l[y]&&r[x]==r[y])return 0;
```

诶？剩下情况都是包含的，可是产生环的情况的必要条件是两区间无交，也就是情况三。

那么对于包含的区间，我们可以更新它们的 $l_i$ 和 $r_i$，这个过程递归加上二分维护。

具体地，如果区间 $y$ 被区间 $x$ 包含，且区间 $y$ 恰好在 $x$ 的左半部分，则可以让 $x$ 变成其左半部分，向下递归。

如果区间 $x$ 被区间 $y$ 包含，且区间 $x$ 恰好在 $y$ 的右半部分，则可以让 $y$ 变成其右半部分，向下递归。

同时我们可以尝试更新其他的区间，看看它们会不会产生环。

其他情况都不会产生环。

时间复杂度是 $O(n\log k)$ 级别的。

需要注意交互题的格式与传参问题，这点困扰了我很久。

特别鸣谢 psoet 大佬，我看他的题解才写出来。

```cpp
#include<bits/stdc++.h> 
#define LL int
using namespace std;
const int N=3e5+5;
LL n,k,l[N],r[N];
vector<int>a[N],b[N];
void init(int N,int K)
{	
	n=N,k=K;//注意这里的传参，要附值到全局变量上
	for(int i=0;i<=n-1;i++)
	{
		l[i]=-1,r[i]=k;
	}
	for(int i=0;i<=k-1;i++)
	{
		l[i]=r[i]=i;
	}

}
bool work(LL,LL);
bool add(LL x)//对于某个点重新更新相连的点
{
	for(LL i:a[x])
	{
		if(work(x,i))return 1;
	}
	for(LL i:b[x])
	{
		if(work(i,x))return 1;
	}	
	return 0;
}
bool work(LL x,LL y)//对于某条边更新
{
	if(x<k&&y<k)
	{
		return x>=y;
	}
	if(r[x]<l[y])return 0;
	if(l[x]>r[y])return 1;
	if(l[x]==l[y]&&r[x]==r[y])return 0;
	LL midx=(l[x]+r[x])>>1,midy=(l[y]+r[y])>>1;
	if (l[y] >= l[x] && r[y] <= midx) {
		r[x] = midx;
		return l[x] == r[x] || add(x);
	}
	if (r[x] <= r[y] && l[x] > midy) {
		l[y] = midy + 1;
		return l[y] == r[y] || add(y);
	}
	return 0;
}

int add_teleporter(int x,int y)
{
	a[x].push_back(y),b[y].push_back(x);
	return work(x,y);
}
```

---

## 作者：_Cheems (赞：1)

题意：$n$ 个点的图，$0\dots k-1$ 是特殊点。初始时只有一条 $\forall i<k-1,i\to i+1$ 的链，接下来逐步加入 $m$ 条有向边，每次判断是否存在一个环，满足环上存在特殊点。$k\le n\le 3\times 10^5,m\le 5\times 10^5$。

每次找环是困难的，考虑**利用初始链的性质，得到一种便于判定的方法**。容易发现，在初始链上，可以到达 $u$ 的点（前驱）构成一段前缀，$u$ 可以到达的点（后继）构成一段后缀。

所以记 $pre_i,suf_i$ 为在 $0\dots k-1$ 的范围内的前缀、后缀，初始时非特殊点 $pre_i=-1,suf_i=k$，特殊点 $pre_i=suf_i=i$。

对于不含非特殊点的环，只需判定是否存在一条两端为特殊点且往回走的边即可（而不往回走又没有意义，所以接下来忽略两端为特殊点的边）；否则，有环当且仅当存在非特殊点满足 $pre_i\ge suf_i$。

直接暴力维护 $pre,suf$ 可以做到 $O((n+m)k)$。

准确维护的方法貌似只有暴力，所以破产了。那么考虑**放宽限制，但保证正确性**。具体来说，将 $[pre_i,suf_i]$ 视为一个区间，然后对 $-1\dots k$ 建线段树，将 $[pre_i,suf_i]$ 下放到线段树节点上。我们声称，将 $[pre_i,suf_i]$ 视为线段树上的区间，不会影响正确性。

还有一个好处，非特殊点若到达叶子节点就说明有环，所以保证了时间复杂度。

接下来考虑怎么维护线段树。首先我们声称：经过修改，若线段树区间未发生变化，则不会产生环，也就是将线段树区间视为实际区间不影响正确性。

分讨：

* 若 $x,y$ 的线段树区间相同：并无影响。
* 若 $x,y$ 的线段树区间相离：若 $x$ 区间在 $y$ 区间左边，区间不变直接忽略；若 $x$ 在 $y$ 右边，则会产生一个环，包含 $[suf_y,pre_x]$ 中的特殊点。
* 若 $x,y$ 的线段树区间包含：根据 $x,y$ 的祖先后代关系、在左右哪个儿子子树进行分讨，发现只有两种情况线段树区间发生变动。以 $y$ 在 $x$ 的左儿子子树为例，那么影响是 $suf_x=suf_y$，我们先把 $x$ 下放到左儿子继续递归即可。$x$ 在 $y$ 的右儿子同理。
* 此外，若线段树区间发生变化，则应当更新所有与它相连的边。

关于正确性：是否可能存在一条边 $u\to v$，满足 $u$ 在 $v$ 的右儿子子树，一开始不会产生环，但后来 $v$ 区间缩小，导致虽然它们的线段树区间没变，可是实际区间 $u$ 与 $v$ 相离且 $u$ 在右边，然后产生环？并不会，因为一开始处理这条边时就已经搞好了会判出环。其它情况同理。

复杂度均摊 $O((n+m)\log k)$。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 5;
int n, m, k, l[N], r[N];
vector<int> to[N], to2[N];

void init(int nn, int kk) {
    n = nn, k = kk;
    for(int i = 0; i < k; ++i) l[i] = r[i] = i;
    for(int i = k; i < n; ++i) l[i] = -1, r[i] = k; 
}
inline bool upd_edge(int x, int y);
inline bool upd_node(int x){
    for(auto y : to[x])
        if(upd_edge(x, y)) return true;
    for(auto y : to2[x])
        if(upd_edge(y, x)) return true;
    return false; 
}
inline bool upd_edge(int x, int y){
    if(x < k && y < k) return x >= y;
    if(r[x] < l[y]) return false;
    if(r[y] < l[x]) return true;
    if(l[x] == l[y] && r[x] == r[y]) return false;
    int midx = (l[x] + r[x]) >> 1, midy = (l[y] + r[y]) >> 1;
    if(r[y] <= midx){
        r[x] = midx;
        if(l[x] == r[x]) return true;
        return upd_node(x); 
    }
    if(l[x] > midy){
        l[y] = midy + 1;
        if(l[y] == r[y]) return true;
        return upd_node(y);
    }
    return false;
}
int add_teleporter(int u, int v) {
    to[u].push_back(v), to2[v].push_back(u);
    return upd_edge(u, v);
}
inline void print(){
    for(int i = 0; i < n; ++i) cout << l[i] << ' ' << r[i] << endl;
    cout << endl;
}
```

---

## 作者：zhenjianuo2025 (赞：1)

## $\mathcal{O}(nk)$ 

注意到这条链的特殊性，对每个点维护 $l_u,r_u$，表示能到达 $u$ 的特殊点中编号最大的点和 $u$ 能到达的特殊点中编号最小的点，若 $l_u\ge r_u$，此时出现了环。

对于一次修改暴力枚举 $u$ 可达的点和可达 $u$ 的点，更新 $l,r$，不能更新立即退出。均摊分析可得，这样做的复杂度是 $\mathcal{O}(nk)$ 的。

## $\mathcal{O}(n\sqrt{k})$

注意到只需要判断 $l\ge r$ 的特殊性，其实我们并不需要实时更新 $l,r$，可以仅在必要时更新。

仍然沿用上面的做法，将特殊点分块，维护暴力做法 $l,r$ 所在块的编号，不能更新则退出。

若 $l,r$ 在同一块中，维护真实的 $l,r$ 编号，暴力更新其他点。

复杂度 $\mathcal{O}(n\sqrt{k})$。

## $\mathcal{O}(n\log{k})$

考虑将 $l,r$，看作一个区间，挂在线段树分治结构上，满足 $l\le \text{mid}<r$，只维护 $l,r$ 所在线段树区间的左右端点。

此时分类讨论相邻点 $u\to v$ 间的贡献。

- $u,v$ 在线段树上同点，此时没有任何贡献，直接返回。
- $u,v$ 线段无交，$u,v$ 有贡献当且仅当 $u$ 在 $v$ 右边，并且此时出现了环。
- $u$ 包含 $v$，此时若 $v$ 在 $u$ 右子树内，$u$ 在线段树上对应的区间也会相应地到达右子树内，递归维护；否则 $v$ 在 $u$ 左子树内，没有贡献。
- $v$ 包含 $u$ 类似讨论即可。


复杂度 $\mathcal{O}(n\log{k})$。

---

## 作者：xfrvq (赞：0)

设 $n,m$ 同阶。$i$ 的前驱为 $[0,k)$ 中能到达 $i$ 的点，后继为 $[0,k)$ 中 $i$ 能到达的点。

全由 $[0,k)$ 点组成的环很好做，判断是否有 $v\lt u\lt k$ 的边即可。

**算法一**：维护 $L_i$ 代表最大前驱，$R_i$ 代表最小后继，如果 $\exist i\notin[0,k),L_i\ge R_i$ 即找到包含 $i$ 的环。

+ 初始化：$L_i=R_i=i(i\lt k),L_i=-1,R_i=k(i\ge k)$。
+ 加边 $(u\to v)$：设 *更新边 $(x\to y)$*：$R_x\gets\min(R_y),L_y\gets\max(L_x)$。从 $u,v$ 开始**在弱联通块上 dfs**，依次 *更新* 每条边。

暴搜 $O(n^2)$。考虑剪枝，能更新 $L,R$ 时才搜下去，复杂度 $O(nk)$（势能分析，$L,R$ 值域为 $k$）。

**算法二**：将 $[0,k)$ 分块，按照 $L,R$ 所在块进行更新，势能即值域 $\sqrt k$。

如果 $bl_{L_i}=bl_{R_i}$，对于 $bl_{L_j}=bl_{R_j}=bl_{L_i}=bl_{R_i}$ 的边 $(i\to j)$ 改用实际值更新。这部分每个点势能也是 $\sqrt k$。复杂度 $O(n\sqrt k)$。

**算法三**：对 $[-1,k]$ 建线段树，维护 $P_i$ 为：在线段树上最小的包含 $[L_i,R_i]$ 节点。$P_i$ 不断向儿子走，到叶子时出现环。 

现在考虑*更新边 $(u\to v)$*：如果 $P_u$ 改变，则先让它向儿子走一步，接着更新所有 $u$ 邻边（包括 $(u,v)$，处理要走多步的情况），$P_v$ 同理。无法更新 $P$ 或产生环则退出。

+ $P_u,P_v$ 区间相离：
  + $u$ 区间在 $v$ 区间左边：无法更新 $P$。
  + $u$ 区间在 $v$ 区间右边：已经产生环。
+ $P_u=P_v$：无法更新 $P$。
+ $P_u,P_v$ 区间包含：
  + $P_v$ 在 $P_u$ 左子树内：此时 $R_u\gets R_v$，用 $P_u$ 向左儿子走一步，接着 *更新* $u$ 所有邻边。
  + $P_u$ 在 $P_v$ 右子树内：此时 $L_v\gets L_u$，用 $P_v$ 向右儿子走一步，接着 *更新* $v$​ 所有邻边。
  + 其余情况：无法更新 $P$。

势能为线段树深度 $\log k$，总复杂度 $O(n\log k)$。

---


# [NERC 2019] Help BerLine

## 题目描述

很快，新的手机服务提供商 **BerLine** 将在 Berland 开始运营！

客户服务的启动计划沿着首都的主街进行。已经有 $n$ 个基站安装完毕，它们沿着主街从左到右依次排列，编号从 $1$ 到 $n$。

目前，所有这些基站都处于关闭状态。它们将按照某个排列 $p = [p_1, p_2, \dots, p_n]$（$1 \le p_i \le n$）依次开启，每天开启一个基站，其中 $p_i$ 表示第 $i$ 天开启的基站编号。因此，开启所有基站需要 $n$ 天时间。

每个基站都有一个工作频率 $f_i$ —— 这是一个介于 $1$ 到 $24$ 之间的整数。

对于基站的工作频率有一个重要要求：考虑任意时刻，对于任何手机用户，如果查看其手机信号覆盖范围内所有已开启的基站，那么在这些基站中至少有一个的工作频率在该组基站中是唯一的。由于手机的信号强度和用户位置事先未知，这意味着对于任何非空的已开启基站子段，其中至少有一个基站的工作频率在该子段中是唯一的。

例如，假设 $n = 7$，所有基站都已开启，且其频率为 $f = [1, 2, 1, 3, 1, 2, 1]$。对于任意子段，该子段内都存在一个频率唯一的基站。但如果 $f = [1, 2, 1, 2, 3, 2, 1]$，则子段 $[1, 2, 1, 2]$（从第 $1$ 个到第 $4$ 个基站）中没有频率是唯一的。

你的任务是为每个基站分配一个 $1$ 到 $24$ 之间的频率，使得在任意时刻（按照给定排列 $p$ 开启基站的过程中）都满足上述频率要求。

## 说明/提示

在第一个测试用例中，$n = 3$，$p = [1, 3, 2]$。可以给基站分配频率 $[1, 3, 2]$。

- 第 1 天：只有基站 $1$ 开启，其频率为 $1$。
- 第 2 天：基站 $1$ 和 $3$ 开启，频率为 $[1, 2]$。
- 第 3 天：所有基站开启，频率为 $[1, 3, 2]$（沿街道方向排列）。

在每一天，任何非空的已开启基站子段中都有一个频率唯一的基站。可以证明，在这个测试用例中必须使用三个不同的频率。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
3
1 3 2
3
1 2 3
1
1
10
6 10 4 2 7 9 5 8 3 1
10
2 4 6 9 1 8 10 5 3 7```

### 输出

```
1 3 2
10 20 10
1
2 3 4 5 3 1 3 5 4 2
1 2 3 4 5 6 7 8 9 10```

# 题解

## 作者：cwfxlh (赞：0)

## [P12941 [NERC 2019] Help BerLine](https://www.luogu.com.cn/problem/P12941)     

我的智商好低啊 😭。    

实际上这个 24 的范围略微有一点误导性，我们先尝试猜测，$n$ 最大能取的范围和值域是指数关系。       

考虑每次用掉一种颜色，然后递归解决问题。对于子问题而言，默认其能给出一个合法解，剩下的问题就是要选出新颜色的位置了。     

这个位置需要满足在所有时间都不会有位置相邻，并且如果满足了这个限制，那么把两部分合并起来一定还是合法解。在所有时间都不会有位置相邻，意味着对于任意两个相邻的选中位置 $i,j$，一定存在一个 $u$ 满足 $t_u<\max(t_i,t_j)$，其中 $t_i$ 表示第 $i$ 个基站被激活的时间。    

如果按 $t$ 从大往小选中位置，那么选中了一个位置之后，在剩余没选中且 $t$ 更小的位置中，它的前驱与后继不能选了。如果这样贪心选，选中一个位置就会删去两个位置，于是一次至少能选出来 $\frac{n}{3}$ 个位置，那么问题就解决了。     

代码：    

```cpp
#include<bits/stdc++.h>
using namespace std;
int testnum,n,p[9003],ans[9003],mk[9003];
set<int>R;
void sol(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>p[i];
	for(int i=1;i<=n;i++)ans[i]=0;
	for(int i=1;i<=24;i++){
		R.clear();
		for(int j=1;j<=n;j++)if(ans[j]==0)R.insert(j);
		for(int j=1;j<=n;j++)mk[j]=(ans[j]==0);
		for(int j=n;j;j--){
			if(ans[p[j]]!=0)continue;
			if(mk[p[j]]==0)R.erase(p[j]);
			else{
				ans[p[j]]=i;
				R.erase(p[j]);
				auto u=R.lower_bound(p[j]);
				if(u!=R.end())mk[(*u)]=0;
				if(u!=R.begin()){
					u--;
					mk[(*u)]=0;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)cout<<ans[i]<<' ';
	cout<<'\n';
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>testnum;
	while(testnum--)sol();
	return 0;
}
```

---


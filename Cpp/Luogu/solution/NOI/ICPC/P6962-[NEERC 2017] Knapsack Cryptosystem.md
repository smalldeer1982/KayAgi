# [NEERC 2017] Knapsack Cryptosystem

## 题目描述

Merkle-Hellman 背包密码系统是由 Ralph Merkle 和 Martin Hellman 于 1978 年发明的最早的公钥密码系统之一。以下是其描述：

Alice 选择 $n$ 个正整数 ${a_{1}, . . . , a_{n}}$，使得每个 $a_{i} > \sum^{i-1}_{j=1}a_{j}$，一个大于所有 $a_{i}$ 之和的正整数 $q$，以及一个与 $q$ 互质的正整数 $r$。这 $n + 2$ 个整数是 Alice 的私钥。

然后 Alice 计算 $b_i = (a_{i} \cdot r)$ mod $q$。这 $n$ 个整数是 Alice 的公钥。

知道她的公钥后，Bob 可以向 Alice 传输一个 $n$ 位的消息。为此，他计算 $s$，即在消息中第 $i$ 位为 1 的位置上对应的 $b_{i}$ 的和。这个值 $s$ 是加密后的消息。

注意，窃听者 Eve 知道加密消息和公钥，必须解决一个（可能很难的）背包问题实例才能找到原始消息。同时，在收到 $s$ 后，Alice 可以在线性时间内计算出原始消息；我们将其留给你作为练习。

在这个问题中，你需要处理 Merkle-Hellman 背包密码系统的实现，其中 Alice 选择了 $q = 2^{64}$，出于显而易见的性能原因，并公布了此信息。由于每个人都知道她的 $q$，她要求 Bob 发送给她取模 $2^{64}$ 的计算值 $s$ 以简化通信。

你需要破解这个实现。给定公钥和一个加密消息，恢复原始消息。

## 说明/提示

时间限制：3 秒，内存限制：512 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
5
10
20
50
140
420
440
```

### 输出

```
01001
```

# 题解

## 作者：oisdoaiu (赞：9)

# 题意

给 $n$ 个物品，每个物品只有 $1$ 个，体积为 $b_i $，求取出物品总体积为 $s$ 的方案。(模 $2^{64}$，保证有且仅有一个解)

$b_i$ 的生成方式为：随机一个长度为 $n$ 的 $a_i$ 序列，满足对于任意 $k$ 都有：
$$(\sum_{i=1}^{k-1}a_i)< a_k\quad \text{性质1}$$ 
$$\sum a_i< 2^{64}\quad\text{性质2}$$
再随机一个 $r$，$r<2^{64}$ 且 $r$ 和 $2^{64}$ 互质。然后 $b_i\equiv a_i\cdot r\ (mod\ 2^{64})$ 。

$n\leq64$

# Case 1

显然这一个超大背包问题，那么我们学过一个经典的折半的解决方法，复杂度$O(2^{\frac n2})$，可以解决 $n\leq46$ 的部分。

简单讲一下，就是暴力枚举前一半的所有选择方案，用一个数据结构把所有 $(S,sum)$ 存下来，然后再枚举后一半的所有选择方案，看是否存在对应的前一半的选择方案。

```cpp
inline void Solve(){
    int mid = n>>1, tp = 1<<mid;
    for(register int s=0; s<tp; s++){
        ull sum=0;
        for(register int i=1; i<=mid; i++) if((s>>i-1)&1) sum += b[i];
        insert(sum,s);
    }
    tp = 1<<(n-mid);
    for(register int s=0; s<tp; s++){
        ull sum=0;
        for(register int i=1; i<=n-mid; i++) if((s>>i-1)&1) sum += b[mid+i];
        int ps = find(S-sum);
        if(ps!=-1){
            for(register int i=1; i<=mid; i++) if((ps>>i-1)&1) putchar('1'); else putchar('0');
            for(register int i=1; i<=n-mid; i++) if((s>>i-1)&1) putchar('1'); else putchar('0');
            puts("");
            return;
        }
    }
}
```

# Case 2

考虑 $n\in(46,64]$ 的部分。

注意一下 $b_i$ 的生成方式，如果我们知道了 $r$，那么就可以求出 $a_i$ 和对应的 $s'$。根据 $a_i$ 的性质，可以直接贪心求出答案。

```cpp
for(register int i=n; i; i--) 
	if(S>=a[i]) S -= a[i], ans[i] = '1';
	else ans[i] = '0';
```

*首先根据**性质2**，是不用考虑取模的。其次，从大到小考虑时，如果 $S\geq a_k$ 而不选 $a_k$，根据**性质1**，就算后面全部选也凑不齐 $a_k$，更别说凑齐 $S$ 了。*

那么核心问题转为了如何求 $r$。

根据**性质1**可以推出 $a_1<\frac{2^{64}}{2^n}$，于是得到了 $a_1$ 的范围，$mx=\frac{2^{64}}{2^n}$。又因为 $r$ 是一个奇数，所以 $a_1$ 末尾 $0$ 的个数一定和 $b_1$ 末尾 $0$ 的个数一样，设为 $cnt$，那么可能的 $a_i$ 就只有 $\frac{2^{64}}{2^{n-cnt-1}}$个，大概是 $2^{18}$ 级别。

于是想到枚举 $a_1$，然后求出 $r^{-1}$。也就是求 $a_1\equiv r^{-1}\cdot b_1\ (mod\ 2^{64})$，先同除 $2^{cnt}$，得到 $a'\equiv r^{-1}\cdot b'\ (mod\ 2^{64-cnt})$，此时因为 $b'$ 是奇数与 $2^{64-cnt}$ 互质，所以可以直接用快速幂求出 $b'^{-1}$ 。

```cpp
ull tp=1ull<<(64-n-cnt-1);
for(register ull i=0; i<tp; i++){
    ull a1 = (((i<<1)|1)<<cnt);
    ull r = (a1>>cnt)*ksm(tmp,(1ull<<(64-cnt-1))-1); 
    if(cnt) r = r&((1ull<<64-cnt)-1);
}
```

但是这样求出的是模 $2^{64-cnt}$ 意义下的 $r^{-1}$，无法求出真正的 $r^{-1}$ 的开头 $cnt$ 位，所以还要 $2^{cnt}$ 枚举一下。

```cpp
ull tp1=1ull<<cnt;
for(register ull j=0; j<tp1; j++){
    ull true_r = r|(j<<63-cnt+1);
    check(true_r);
}
```
# 杂项

[代码](https://www.luogu.com.cn/paste/i9xg6mru)

~~出密码学的都是毒瘤~~

快速幂部分可以直接使用自然溢出快速幂，因为 $a\mod b=(a\mod kb)\mod b$

关于复杂度，设两个 $Case$ 分界点为 $k$，那么复杂度分别为 $O(2^{\frac k2})$ 和 $O(2^{n-k})$，所以理论上 $k=\frac23\cdot64$ 时取到最优复杂度。

---

## 作者：syf2008 (赞：2)

### $1.n\le20$

暴力 dfs。  
复杂度 $O(2^n)$。

### $2.n\le40$   

显然过不去,考虑 $\verb!meet-in-the-middle!$。  
把整个密码串分为 $2$ 段。
前半段搜完扔到哈希表里，后半段搜索搜完后去哈希表中合并答案。  
复杂度 $O(2^\frac{n}{2})$。

Code:
```
namespace sub1
{
	unordered_map<ull,int>mp;
	int c[66],len;
	ull temp,hh,sum;
	int hf1,hf2;
	void main()
	{
		hf1=n/2,hf2=n-hf1;
		for(int i=0;i<(1<<hf1);i++)
		{
			sum=0;
			for(int j=0;j<hf1;j++)
			if(i>>j&1)sum+=b[j+1];
			mp[sum]=i+1;
		}
		for(int i=0;i<(1<<hf2);i++)
		{
			sum=0;
			for(int j=0;j<hf2;j++)
			if(i>>j&1)sum+=b[hf1+j+1];
			hh=s-sum;
			if(mp[hh])
			{
				mp[hh]--;
				temp=mp[hh];while(temp)c[++len]=temp&1,temp>>=1;
				len=hf1;
				temp=i;while(temp)c[++len]=temp&1,temp>>=1;
				for(int i=1;i<=n;i++)cout<<c[i];
				return;
			}
		}
	}
}
```

### $3.r\le10^6$

考虑 $r$ 不大，题目又说 $r,q$ 互质，直接枚举 $r$，然后求个逆元，从 $b$ 数组倒推回 $a$，然后 check。 

证明:

因 $s\equiv \sum_{i=1}^{n}[x_i=1]\cdot b_i\pmod q$。  
则 $s\cdot r^{-1}\equiv \sum_{i=1}^{n}[x_i=1]\cdot b_i\cdot r^{-1}\pmod q$。  
即 $s\cdot r^{-1}\equiv \sum_{i=1}^{n}[x_i=1]\cdot a_i\pmod q$。

根据 $a_i>\sum\limits_{j=1}\limits^{i-1} {a_j}$ 可知，对于任意 $s,r$, $a$ 的解唯一。  

~~原因显然。~~

将还原出的合法的 $a$ 对 $s \cdot r^{-1}$ 进行从大到小能减就减的贪心。


复杂度 $O(r\times (n+\log q))$。   

### $4.b$ 为奇数 
当 $b$ 是奇数时，$a_1$ 是奇数。   
证明：  
若 $a$ 为偶数，无论 $r$ 取奇还是偶，$b$ 不可能为奇数。

考虑枚举 $a_1$。

又因为 $a_i>\sum\limits_{j=1}\limits^{i-1} {a_j}, q > \sum_{i=1}^{n}a_i$，
所以 $0 \le a_1 \le 2^{65-n}$。  
再和第 $2$ 档双向搜索进行数据分治。


### $5.正解$
这一档考虑解从 $r$ 出发：
因为 $r,q$ 互质，所以 $r$ 必然是奇数。

设 $a_1=a'\cdot 2^x$，那么 $b_1$ 也能被拆成 $b_1=b' \cdot 2^x$。

因为要拆光，所以 $a'$ 和 $b'$ 都是奇数。

**感性证明：**  
把 $a_1$ 拆成 $a'\cdot 2^x$ 这种形式， $x$ 相当于 $a$ 在二进制位下末尾 $0$ 的个数。  
因为 $r$ 是奇数，所以 $r \cdot a_1$ 不会为 $a_1$ 在末尾增加新的 $0$ 的个数。

因为 $a_i\equiv b_i \cdot r^{-1}\pmod{2^{64}}$。  
先转化为 $a_1\equiv b_1 \cdot r^{-1}\pmod{2^{64}}$。   
根据上面的推论拆成：$a'\cdot 2^x \equiv b'\cdot 2^x \cdot r^{-1}\pmod{2^{64}}$。  
可得：$a'\equiv b' \cdot r^{-1}\pmod{2^{64-x}}$。  
最终得到 $r^{-1} \equiv a' \cdot b'^{-1} \pmod{2^{64-x}}$。

但这样求出的是模 $2^{64-x}$ 意义下的 $r^{-1}$，所以还缺最高的 $x$ 位，所以要对这 $x$ 位枚举，因为你并不知道他们是什么（


折半的复杂度为 $O(2^\frac{n}{2})$，正解的复杂度为 $O(n \times 2^{64-n})$，所以对数据进行分治。

理论上 $k=\frac{2}{3} \times 64\approx 43$ 时最优。

[提交记录](https://www.luogu.com.cn/record/102070974)

后续：  
其实 $a_1$ 的上界不用管，因为数据保证有解，而且数据分治过后其实上界不会太大。所以可以开 $2^{63}-1$（

---

## 作者：Petit_Souris (赞：1)

非常好题目，但是我调了半个多小时，发现自己好像特别不会调代码，咋回事。

首先 $n$ 较小的时候，显然可以折半搜索，做到 $\mathcal O(2^{n/2}\mathrm{poly}(n))$。

而 $n$ 比较大的时候，肯定就得利用题目中的数据生成特性了。

我们可以先考虑 $r=1$ 的时候怎么处理。由于每个数都比前面的数之和更大，所以我们可以倒着贪心。如果当前位可以选但是没选的话，后面的全选也凑不满了。所以正确的策略一定是能选则选。

那么我们把目标换成求出 $r$。

先考虑哪些 $r$ 可能合法。首先需要满足 $b_1\equiv r\cdot a_1 \pmod {2^{64}}$，这时候由于 $r$ 是奇数，所以 $b_1$ 和 $a_1$ 的 $2$ 因子个数应当相同。

我们设 $b_1=2^k\cdot B,a_1=2^k\cdot A$，其中 $A,B$ 均为奇数。方程变成 $B\equiv r\cdot A \pmod {2^{64-k}}$。

如果 $A$ 确定了，那么 $r$ 在 $\bmod\ 2^{64-k}$ 意义下就有唯一解 $r_0$ 了。

我们发现 $n$ 比较大实际上是有好处的：我们可以保证 $a_1\le 2^{65-n}$，那么 $A\le 2^{65-n-k}$。这个范围已经相当紧了，考虑直接枚举 $A$ 并解出 $r_0$ 了。

接下来发现 $r_0$ 确定后 $r$ 的取值也不多了，因为 $r=r_0+t\cdot 2^{64-k}$，所以只有 $2^k$ 种取值。那么我们可以发现 $r$ 至多只有 $2^{65-n}$ 个。枚举之后判定是容易的，和 $r=1$ 一样做就行了。

因此最终复杂度是 $\mathcal O(2^{n/3}\mathrm{poly}(n))$。

---

## 作者：_jimmywang_ (赞：1)

超绝值域分治。

考虑 $n\le 42$ 时，我们可以暴力 meet-in-the-middle，把 $n$ 个数分成个数尽量相等的两堆，每堆里枚举子集，把该子集中数的和记录在一个哈希表中。然后枚举第一堆的哈希表里的值 $x$，查询第二堆的哈希表中是否存在 $s-x$。若存在则输出。复杂度 $O(2^{\frac{n}{2}})$（使用 `unordered_map`，近似 $O(1)$）。

若 $n>42$，则根据题面中给定的 $\{a\}$ 的生成方式，不难得出结论：$a_1\le 2^{64-n}\le 2^{64-43}=2^{21}$。那么我们枚举真正的 $a_1$ 的复杂度是可以接受的。枚举 $a_1$ 后就能得到一系列可能的 $r$ 使得 $a_1\times r \equiv b_1 \pmod {2^{64}}$。因为保证 $r$ 和 $2^{64}$ 互质，意味着 $r$ 存在逆元，确定 $r$ 后就能还原出整个 $\{a\}$。此时判定一下还原后的序列是否合法即可。若合法且存在解就输出（由于 $a$ 的某一项必然大于前面的项的和，易证若有解必为唯一解，构造方式是从大往小贪心，如果能减就减）。

现在的问题在于求出一个 $a_1$ 对应的 $r$（们）。我们有式子：

$$a_1\times r \equiv b_1 \pmod {2^{64}}$$

设 $b_1=2^k\times p$，其中 $p$ 是奇数，那么此式等价于：

$$\dfrac{a_1}{2^k}\times r \equiv p \pmod {2^{64-k}}$$

这个式子告诉我们， $2^k\mid a_1$。因此合法的 $a_1=x\times2^k,x\in[1,2^{64-n-k}]$，只有 $2^{64-n-k}$ 种。

由于我们想要从 $\{b\}$ 还原出 $\{a\}$，所以其实我们**只关心 $r$ 的逆元** $r^{-1}$ 的值。将上式变形：

$$\dfrac{a_1}{2^k}\equiv p \times r^{-1}\pmod {2^{64-k}}$$
$$r^{-1}\equiv \dfrac{a_1}{2^k} \times p^{-1}\pmod {2^{64-k}}$$

其中，$p$ 由 $b_1$ 确定，即是一个确切值；同时 $p$ 一定是奇数，因此 $p^{-1}$ 一定存在且固定。 

因此只要确定了 $a_1$，就确定了 $r^{-1} \bmod {2^{64-k}}=\dfrac{a_1}{2^k} \times p^{-1}$。也即，$r^{-1}=y\times 2^{64-k}+\dfrac{a_1}{2^k} \times p^{-1}, y\in [0,2^{k})$。

因此对于一个 $a_1$，合法的 $r$ 的数量是 $2^k$ 种。整体上合法的 $(a_1,r)$ 数对就只有 $2^{64-n-k}\times 2^k=2^{64-n}$ 种情况。每种情况在得到 $r^{-1}$ 后的判定是 $O(n)$ 的，因此总复杂度为 $O(n\times2^{64-n})$。

在 $42<n\le 64$ 时，这个值在 $n=43$ 时取极大值 $43\times 2^{21}=90177536$，是 $9\times 10^7$ 的量级，常数较小的实现方式可以轻松通过。

---


# [IOI 2024] 消息篡改者

## 题目背景

不要 $\texttt{\#include "message.h"}$。

请使用 C++ 20 提交，并在文件头粘贴如下的内容：

```cpp
#include <vector>

std::vector<bool> send_packet(std::vector<bool>);
void send_message(std::vector<bool>, std::vector<bool>);
std::vector<bool> receive_message(std::vector<std::vector<bool>>);
```

## 题目描述

## 任务描述

Aisha 和 Basma 是两位互相通信的朋友。Aisha 有一条消息 $M$ 想要发给 Basma，该消息是由 $S$ 个比特（即若干 0 或 1）组成的序列。Aisha 通过发送**数据包**来跟 Basma 通信。一个数据包是由 $31$ 个比特组成的序列，对应的位置从 $0$ 到 $30$ 编号。Aisha 想向 Basma 发送消息 $M$ 时，会发送若干数据包。

然而第三个人 Cleopatra 在破坏 Aisha 和 Basma 之间的通信，能够**篡改**发送的数据包。在每个数据包中，Cleopatra 可以修改恰好 $15$ 个位置的比特。具体来说，给定长度为 $31$ 的数组 $C$，其中每个元素为 $0$ 或 $1$，含义如下：

* $C[i] = 1$ 表示位置为 $i$ 的比特可以被 Cleopatra 修改。我们称此类位置是被 Cleopatra **控制**的。
* $C[i] = 0$ 表示位置为 $i$ 的比特不能被 Cleopatra 修改。

数组 $C$ 恰好包含 $15$ 个 $1$ 和 $16$ 个 $0$。当发送消息 $M$ 时，Cleopatra 控制的位置集合对于所有数据包都是相同的。Aisha 清楚地知道哪 $15$ 个位置被 Cleopatra 控制。Basma 只知道有 $15$ 个位置被 Cleopatra 控制，但不知道是哪些位置。

令 $A$ 为 Aisha 决定要发送的数据包（称之为**原始数据包**）。令 $B$ 为 Basma 收到的数据包（称之为**篡改数据包**）。对每个在 $0 \leq i < 31$ 的 $i$ 都有：

* 如果 Cleopatra 不能控制位置为 $i$ 的比特（$C[i]=0$），那么 Basma 将能收到 Aisha 发送的第 $i$ 个比特（$B[i]=A[i]$），
* 否则，如果 Cleopatra 控制了位置为 $i$ 的比特（$C[i]=1$），那么 $B[i]$ 的值由 Cleopatra 决定。

每个数据包发送后，Aisha 会立刻知道被篡改后的数据包内容。

当 Aisha 发送完所有数据包后，Basma **按照发送顺序**接收到所有被篡改的数据包，她必须重建原始消息 $M$。

你的任务是制定并实现某种策略，使得 Aisha 给 Basma 发送消息 $M$ 时，Basma 能够从篡改数据包中恢复 $M$。具体来说，你要实现两个函数，第一个函数进行 Aisha 的动作：给定消息 $M$ 和数组 $C$，给 Basma 发送若干数据包来传输消息。第二个函数进行 Basma 的动作：给定若干篡改数据包，恢复原始消息 $M$。

## 实现细节

你要实现的第一个函数是：

```
void send_message(std::vector<bool> M, std::vector<bool> C)
```

* $M$：长度为 $S$ 的数组，描述 Aisha 想要发给 Basma 的消息。
* $C$：长度为 $31$ 的数组，标记 Cleopatra 控制的数据包中的位置。
* 每个测试用例中，该函数**最多**可被调用**2100次**。

该函数调用以下函数来发送数据包：

```
std::vector<bool> send_packet(std::vector<bool> A)
```

* $A$：原始数据包（长度为 $31$ 的数组），表示 Aisha 发送的比特。
* 此函数返回篡改数据包 $B$，表示 Basma 接收到的比特。
* 此函数在 `send_message` 的一次调用过程中最多被调用 $100$ 次。

你要实现的第二个函数是：

```
std::vector<bool> receive_message(std::vector<std::vector<bool>> R)
```

* $R$：描述若干篡改数据包的数组。这些数据包源自 Aisha 在一次 `send_message` 调用时发送的若干数据包，且按照 Aisha 的发送顺序排列。$R$ 的每个元素是长度为 $31$ 的数组，表示一个篡改数据包。
* 该函数应返回包含 $S$ 个比特的数组，且与原始消息 $M$ 相同。
* 每个测试用例中，该函数可能被调用**多次**。对于每次 `send_message` 的调用，对应地该函数要有**恰好一次**调用。函数 `receive_message` 的**调用顺序**不必与对应的 `send_message` 调用顺序一致。

注意在评测系统中，`send_message` 和 `receive_message` 两个函数是在**不同的程序**中来调用的。

## 说明/提示

## 约束条件

* $1 \leq S \leq 1024$
* $C$ 恰好有 $31$ 个元素，且其中 $16$ 个为 $0$，$15$ 个为 $1$。

## 子任务与评分

如果在任意的测试用例中，函数 ``send_packet`` 的调用不符合上述规则，或者某个函数 `receive_message` 的调用的返回值不正确，你的解答在该测试用例上得 $0$ 分。

否则，令 $Q$ 为所有测试用例中，每次 `send_message` 调用时调用函数 `send_packet` 的次数的最大值。令 $X$ 等于：

- $1$，如果 $Q \leq 66$
- $0.95 ^ {Q - 66}$，如果 $66 < Q \leq 100$
- $0$，如果 $100 < Q$

那么，得分将由以下式子计算获得：

| 子任务 |     分数     | 额外的约束条件       |
| :----: | :----------: | -------------------- |
|   1    | $10 \cdot X$ | $S \leq 64$          |
|   2    | $90 \cdot X$ | 没有额外的约束条件。 |

注意在某些测试用例中，评测程序的行为是**自适应的**。这意味着 `send_packet` 的返回值可能取决于它的输入参数和以前调用该函数的返回值。

## 例子

考虑以下调用。

```
send_message([0, 1, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
```

Aisha 试图发给 Basma 的消息是 $[0, 1, 1, 0]$。数据包的第 $0$ 至第 $15$ 个比特不能被 Cleopatra 修改，而第 $16$ 至第 $30$ 个比特可以被 Cleopatra 修改。

为便于解释这个例子，我们假设 Cleopatra 的行为是确定性的：她交替地用 $0$ 和 $1$ 填充所控制的比特，也就是她把她控制的第一个位置赋 $0$（例子中的第 $16$ 位），把她控制的第二个位置赋 $1$（第 $17$ 位），把她控制的第三个位置赋 $0$（第 $18$ 位），以此类推。

Aisha 可以做出的一种决定是在一个数据包中发送原始消息中的两个比特，例如她是这样做的：通过她控制的前 $8$ 个位置来发送第一个比特，通过她控制的接下来 $8$ 个位置来发送第二个比特。

于是 Aisha 发送以下数据包：

```
send_packet([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```

由于 Cleopatra 可以更改最后 $15$ 个比特，所以 Aisha 决定随意设置它们，因为它们可能会被覆盖。使用前面假定的 Cleopatra 的策略，该函数返回：

$[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$。

Aisha 决定在第二个数据包中发送 $M$ 的最后两个比特，与之前类似：

```
send_packet([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```

根据假定的 Cleopatra 的策略，该函数返回：

$[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$。

Aisha 还可以发送更多的数据包，但她没有这样做。

然后评测程序进行以下函数调用：

```
receive_message([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
                  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                 [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]])
```

Basma 按照如下方式恢复消息 $M$。她从每个数据包中提取出第一个连续出现两次的比特，以及最后一个连续出现两次的比特。也就是说，她从第一个数据包提取出两个比特 $[0, 1]$ ，从第二个数据包中提取出两个比特 $[1, 0]$。把它们放在一起，她恢复了消息 $[0, 1, 1, 0]$，这是对 `receive_message` 调用的正确返回值。

可以证明，在假设的 Cleopatra 的策略下，对于长度为 $4$ 的消息，不管 $C$ 的值是多少，Basma 这样做能够正确恢复 $M$。然而，一般情况下这并不正确。

## 评测程序示例

评测程序示例不具备自适应性，Cleopatra 的行为是确定性的，她交替地用 $0$ 和 $1$ 来填充她控制的比特，就像她在例子中所做的那样。

输入格式：**输入第一行包含一个整数 $T$，指定测试用例的数量。**接下来有 $T$ 组测试用例，每组测试用例都按以下格式描述：

```
S
M[0]  M[1]  ...  M[S-1]
C[0]  C[1]  ...  C[30]
```

输出格式：评测程序示例按照输入的顺序，用以下格式输出 $T$ 组测试用例的结果：

```
K L
D[0]  D[1]  ...  D[L-1]
```

这里， $K$ 是 `send_packet` 的调用次数，$D$ 是 `receive_message` 返回的消息，$L$ 是它的长度。

# 题解

## 作者：Petit_Souris (赞：44)

现有公开的做法，好像都本质相同啊——又能有几种做法呢？有将近一半的位置会被修改，我们甚至不知道 Cleopatra 对它们做了什么——

哦不对，其实我们知道 Cleopatra 做了什么。没错，`send_packet` 函数是有返回值的。

来一个依赖返回值的，极其高手的做法。感谢 lmh 老师和 dx 老师的讨论和指导 /qq

坐稳了！

-------

下面称不会被 Cleopatra 修改的位是好的（记为 $1$），会被修改的位是坏的（记为 $0$），将位置 $i$ 的状态记为 $C_i$。注意这里数字记号和题面是反的，~~如果你绕不过来就别看了反正也没啥好看的。~~

将一个数据包的长度记为 $N$，它等于 $31$。

由于信息长度不固定，我们先补一个 $1$，再补一串 $0$，直到长度 $=1025$。显然这样可以区分长度，最后把多出来的部分删了就行。而满足 $C_i=1$ 的位总共可以传输 $1056$ 个位，还剩下 $31$ 个。

我们的思路是这样的：

1. 确定一个好的位；

2. 利用这个位置找到所有好的位；

3. 用找到的好位传送信息。

**整个通信的过程看似是离线的，但是我们一定要摆脱离线的思维定势。因为我们有获得返回值的能力，所以我们可以得知 Basma 具体收到了什么，进而改变发送的内容，也就是将离线强制转为在线。**

在一次发送信息的过程中，可以让一个位 $u$ 记录位置 $v$ 的类型——令 $A_u=C_v$ 即可。如果 $u$ 是好的，那么结果一定真实；否则，结果可能被 Cleopatra 篡改。称其为一次询问。如果 $C_u=1$ 则为有效询问，否则为无效询问。

由于 $1$ 是绝对众数，我们考虑摩尔投票。具体而言，维护一个栈，按顺序扫描每个位 $i$：

- 如果栈为空，直接加入 $i$；
- 否则，在下一个发送的数据包中，让栈顶位置 $t$ 记录 $i$ 的类型。
  - 如果在 Cleopatra 修改过后这一位是 $0$，那么 $C_i=0$ 和 $C_t=0$ 至少有一个成立。此时弹出栈顶元素 $t$。
  - 否则，将 $i$ 加入栈。

显然最后栈中 $1$ 比 $0$ 更多，而且不可能出现连续的 $10$。证明是简单的：如果出现 $C_u=1$ 之后紧跟 $C_v=0$，那么在处理 $v$ 的时候应该将它们一起弹出去。所以最后栈顶一定是一个好位置。

这个过程是可以实现的原因是，我们每次得到了返回值。所以说 A 可以预测到 B 的行为，而 B 只需要顺着既定流程走就行了，并不会改变历史。

现在有一个问题——一次询问就会消耗一个二进制位，而这样做完之后最坏情况下已经进行了 $30$ 次询问，如何用剩下的询问确定所有好的的位置呢？

首先可以观察到，无效询问不会占用信息量，因为这个位本来就传不了信息。

现在忘掉之前的栈，考虑如下问题：我们已经进行了多次询问，它们的结果全部已知；我们还知道一个 $C_i=1$ 的 $i$；接下来需要用更多的询问确定所有 $C_i$，但是有效询问至多只能有 $31$ 个，而且总的询问次数 $\le 66$。

对操作建树，如果 $u$ 查询 $v$，就从 $u$ 向 $v$ 连一条有向边，连成一条森林，显然这个森林当中所有节点满足 $fa_i<i$（除非 $i$ 为树根）。

设已经确定的那个好位为 $s$。我们每次找到编号最小的 $p$，满足 $p$ 还未确定。通过一次询问 $(u=s,v=p)$ 来判断 $p$ 的实际好坏。若 $p$ 是一个好位置，那么因为 $p$ 说真话，所以 $p$ 的所有儿子都可以根据刚刚的询问直接确定。这样的关系可以递归下去，因此可以一次性填好所有能确定的位置，再重复这个过程，直到所有位置都被确定为止。

考虑每个有效询问，发现它恰好确定了一个点的状态。并且每个节点只会被一个有效询问更新——首先在维护栈的过程中，每个节点最多被询问一次；而如果这个询问有效，那么遍历到它之前它的父亲一定已经被确定了，这样它也会被确定下来，就不会被多次访问了。

这样询问的总数 $\le 2N$，其中有效询问至多只有 $N$ 次。

因此我们在 $66$ 包内解决了这个问题！！！！！！！！！！

```cpp
#include"message.h"
#include<bits/stdc++.h>
using namespace std;
void send_message(vector<bool> M,vector<bool> C){
	for (int i=0;i<31;++i) C[i]=!C[i];
	M.emplace_back(1);
	while(M.size()<66*16) M.emplace_back(0);
	int pos_M=0,cnt=0,bad=0;
	vector<bool> A(31);
	vector<int> vis(31),fa(31,-1),stk;
	for (int i=0;i<31;++i){
		if (stk.empty()){stk.push_back(i);continue;}
		else{
			A[stk.back()]=C[i];
			bad+=C[stk.back()];
			fa[i]=stk.back();
			for (int j=0;j<31;++j) if (C[j]&&(j!=stk.back())) A[j]=M[pos_M++];
			auto vec=send_packet(A);
			++cnt;
			if (vec[stk.back()]==0){
				stk.pop_back();
			}
			else stk.emplace_back(i);
		}
	}
	assert(stk.size());
	int lst=stk.back();vis[lst]=1;
	for (++cnt;cnt<=66;++cnt){
		int p=-1;
		for (int i=0;i<31;++i) if (!vis[i]){p=i;break;}
		if (p!=-1) A[lst]=C[p],++bad;
		for (int i=0;i<31;++i) if (C[i]&&(i!=lst||p==-1)) A[i]=M[pos_M++];
		send_packet(A);
		if (p==-1) continue;
		vis[p]=1;
		for (int i=p+1;i<31;++i) if (fa[i]!=-1&&C[fa[i]]&&vis[fa[i]]) vis[i]=1;
	}
	assert(pos_M>=1025);
}
vector<bool> receive_message(vector<vector<bool> > R){
	vector<bool> ans;
	vector<int> ok[66],vis(31),qry(31),C(31),stk,fa(31,-1);
	for (int i=0;i<66;++i) ok[i].resize(31);
	int L=0,bad=0;
	for (int i=0;i<31;++i){
		if (stk.empty()){stk.push_back(i);continue;}
		else{
			int x=stk.back();fa[i]=x;
			int k=qry[i]=R[L][x];ok[L++][x]=1;++bad;
			if (k) stk.emplace_back(i);
			else{
				stk.pop_back();
			}
		}
	}
	assert(stk.size());
	int lst=stk.back();C[lst]=vis[lst]=1;
	for (;L<66;++L){
		int p=-1;
		for (int i=0;i<31;++i) if (!vis[i]){p=i;break;}
		if (p==-1) break;
		int k=R[L][lst];ok[L][lst]=1;++bad;
		C[p]=k;vis[p]=1;
		if (k) for (int i=p+1;i<31;++i) if (vis[i]==0&&fa[i]!=-1&&C[fa[i]]){
			vis[i]=1;C[i]=qry[i];
		}
	}
	for (int i=0;i<66;++i) for (int j=0;j<31;++j) if (ok[i][j]==0&&C[j]) ans.emplace_back(R[i][j]);
	assert(ans.size()>=1025);
	while(ans.back()==0) ans.pop_back();ans.pop_back();
	return ans;
}
```

---

## 作者：Linge_Zzzz (赞：26)

作为一个人我们该如何想到正解？？？

本题解讲了很多部分分做法。若想直接看正解可直接翻到最下面查看。

# 10 pts

考虑如何发送准确无误的信息。

注意到有 $16$ 个位不会被篡改，那么只要把这 $16$ 个位全填上你想发送的数，那么不论 C 怎么修改剩下的 $15$ 位，发送过去消息的众数一定是你想发送的数。

用这种策略发送 $S$ 次即可获得 $10$ 分的好成绩。

# 30 pts

考虑到如果我们知道哪些位不会被捣乱，那么我们只需要最多 $64$ 次满载荷的发送即可发送全部消息。

还有一个问题需要解决，如果我们不能保证正好在最后一条消息的结尾发送完 $M$，那么我们不知道应该从哪结束。

解决方法是，把最后空的位设为 $M$ 最后一位取反后的二进制位，这样我们接收完所有消息只需要删掉最后相同连续的一段即可。注意如果恰好发送完则需要再发一整段空的消息。

我们不妨用上面那种暴力策略发送 $31$ 次，把 $X$ 发送过去，然后使用 $64$ 次满载和发送，即可获得 $30$ 分的好成绩。

# 乱搞（50 pts）

考虑在发送 $X$ 的过程中我们当前已知 $a$ 位是永远不会被捣乱的，则我们可以一次发送 $i$ 位而不是一位一位地用暴力策略发送。

这样在最坏情况下大约是 $20+64$ 次通信，可以获得 $45$ 分的好成绩。

考虑使用一次暴力发送来决定是从左边开始发送还是右边开始发送，那么最坏情况大约是 $17+64$ 次通信，可以获得 $51$ 分的好成绩。

# 83 pts

考虑到这样的关键一点：

若先找到一个永远不会被捣乱的位，那么就可以使用这一个位通信 $31$ 次来发送  $X$，让剩下 $15$ 个不会被捣乱的位先发送着 $M$。

因为我们可以把未了解 $X$ 全貌时的消息存下来，等知道 $X$ 全貌了之后再用以前的消息来获得先发送的 $M$。

那么如何找到一个 $X_i=0$ 的位呢？

不妨钦定发送第一个 $X_i=0$ 的位置。考虑到一共有 $31$ 个位，其中有 $16$ 个位为 $0$，所以第一个 $0$ 的位置最大在 $16$（前 $15$ 个都是 $1$），这 $16$ 种情况我们可以映射到区间 $[0,15]$ 中，以此来实现 $4$ 次暴力发送来找到第一个 $0$ 的位置。

知道了第一个 $0$ 的位置，那就只需要 $29$ 次发送即可获得 $X$，因为已经知道的算一个，通过数量关系推出来的还可以算一个！！

总结一下，首先需要 $4$ 次暴力发送来找到第一个 $0$ 的位置，然后发送 $29$ 次把整个 $X$ 发送过去的同时，发送 $15\times 29$ 个 $M$ 中的位，最后再用 $\lceil \frac{1024-15\times 29}{16}\rceil=37$ 次发送来发送剩下的所有消息。总共 $70$ 次，可以获得 $83$ 分的好成绩！！！

# 87 pts

注意到 $66$ 次即可获得满分的好成绩，但是 $66$ 次最多发送 $1024+32$ 位的有用信息，这就说明最多使用两次暴力发送。

于是可以想到，把 $31$ 个位划分成 $4$ 个子区间，长度分别是 $8,8,8,7$，由鸽笼原理可知一定存在一个区间使得其 $0$ 的个数要大于 $1$ 的个数。

先用 $2$ 次暴力发送来找到这个区间，然后用这个区间来发送这个区间第一个 $0$ 的位置，剩下区间用来先发送着消息 $M$。

然后又知道这个区间第一个 $0$ 的位置最大是 $4$，所以能用 $2$ 次发送来获得这个区间里第一个 $0$ 的位置！！！

梳理一下，我们先用 $2$ 次暴力发送来找到一个区间使得其 $0$ 的个数大于 $1$ 的个数。然后用 $2$ 次发送来找到这个区间里第一个 $0$ 的位置，同时用剩下最少 $11$ 个 $0$ 发送 $2\times 11$ 个 $M$ 中的位。再然后用 $29$ 次发送来发送 $X$，同时发送 $29\times 15$ 个 $M$ 中的位。最后用 $\lceil \frac{1024-15\times 29-11\times 2}{16}\rceil=36$ 次发送来发送整个 $M$。

一共需要 $69$ 次发送，可以获得 $87$ 分的好成绩。

# 90 pts

上面的方法最重要的启发是，可以只用一个区间来使用众数暴力发送，其他的位先发送着 $M$。

然后又知道，把这 $31$ 个位等分成几段，必定存在一段使得其中 $0$ 的数量大于 $1$ 的数量。

所以，可以采用如下策略：

- 把这 $31$ 个位分成 $16$ 个区间（如图所示，这是一个类线段树结构，让前 $30$ 个每两个成一个区间，第 $31$ 个自己成一个区间）。

![](https://cdn.luogu.com.cn/upload/image_hosting/lfuzh70b.png)

- 这其中必定有一个区间其 $0$ 的个数大于 $1$ 的个数。

- 于是使用 $4$ 次发送，区间内的数的众数表示每次往左还是往右走来找到最底下这一层的区间，剩下的用来发送 $M$。

- 所以最多会浪费掉 $16+9+5+3=33$ 个位，能获得 $90$ 分的好成绩。

# 100 pts

震撼。跟上面的做法一点关系都没有。

界是 $66$，这个界**太紧了**。考虑怎么使用 $31$ 位发送 $X$。

观察到一次消息有 $31$ 个位，而有 $16$ 个位是不会被篡改的。虽然之前挖掘了这个绝对众数的性质，但还是不够彻底。

之前的想法还是太局限了，考虑把每一列看成一个消息。设每个可用位到下一个可用位的循环距离为 $d$，则我们在这一位的前 $d-1$ 次发送 $0$，第 $d$ 次发送 $1$，之后照常传递数据。

这样，每一位都会有一个出边，画到图上就是一个内向基环树森林。根据可用位发送的出边一定构成一个大小为 $16$ 的环，而剩下 $15$ 个点再怎么乱连也不可能连出另外一个大小为 $16$ 的环，所以只用了 $31$ 位就发送了 $X$。

太厉害了。

---

## 作者：_lmh_ (赞：20)

题目要求我们传输 $1024$ 比特的信息——这太不牛了，毕竟官方做法连 `send_packet` 的返回值都没用到对吧，所以我们不妨加强到 $1025$ 比特。

请先阅读 [Petit_Souris 的题解](https://www.luogu.com.cn/article/7l0a3lud)。

我们发现一件事：该做法依次确定了每个位置的值，而不是和官方做法一样做一步转化然后建图，因此只要有了前 $30$ 个 $C$ 那么最后一个也就知道了。

因此把最后一个拿出来单独考虑，前面的部分用原来的做法做。

唯一的问题是前面 $30$ 个数可能消完，栈里面没有东西，但此时多出来那个节点的 $C$ 必须是 $1$，还是找到了一个好的节点，所以没有问题。

```cpp
#include"message.h"
#include<bits/stdc++.h>
using namespace std;
void send_message(vector<bool> M,vector<bool> C){
	for (int i=0;i<31;++i) C[i]=!C[i];
//	for (int i=0;i<31;++i) cout<<C[i];cout<<endl;
	M.emplace_back(1);
	while(M.size()<66*16) M.emplace_back(0);
	int pos_M=0,cnt=0,bad=0;
	vector<bool> A(31);
	vector<int> vis(31),fa(31,-1),stk;
	for (int i=0;i<30;++i){
		if (stk.empty()){stk.push_back(i);continue;}
		else{
			A[stk.back()]=C[i];
			bad+=C[stk.back()];
			fa[i]=stk.back();
			for (int j=0;j<31;++j) if (C[j]&&(j!=stk.back())) A[j]=M[pos_M++];
			auto vec=send_packet(A);
			++cnt;
			if (vec[stk.back()]==0){
				stk.pop_back();
			}
			else stk.emplace_back(i);
		}
	}
	int lst=30;
	if (stk.size()) lst=stk.back();
	vis[lst]=vis[30]=1;
//	for (auto x:stk) cout<<x<<' ';cout<<endl;
	for (++cnt;cnt<=66;++cnt){
		int p=-1;
		for (int i=0;i<30;++i) if (!vis[i]){p=i;break;}
//		cout<<"try "<<p<<endl;
		if (p!=-1) A[lst]=C[p],++bad;
		for (int i=0;i<31;++i) if (C[i]&&(i!=lst||p==-1)) A[i]=M[pos_M++];
		send_packet(A);
		if (p==-1) continue;
		vis[p]=1;
		for (int i=p+1;i<31;++i) if (fa[i]!=-1&&C[fa[i]]&&vis[fa[i]]) vis[i]=1;
	}
	assert(pos_M>=1026);
}
vector<bool> receive_message(vector<vector<bool> > R){
	vector<bool> ans;
	vector<int> ok[66],vis(31),qry(31),C(31),stk,fa(31,-1);
	for (int i=0;i<66;++i) ok[i].resize(31);
	int L=0,bad=0;
	for (int i=0;i<30;++i){
		if (stk.empty()){stk.push_back(i);continue;}
		else{
			int x=stk.back();fa[i]=x;
			int k=qry[i]=R[L][x];ok[L++][x]=1;++bad;
			if (k) stk.emplace_back(i);
			else{
				stk.pop_back();
			}
		}
	}
	int lst=30;
	if (stk.size()) lst=stk.back();
	C[lst]=vis[lst]=1;
//	for (auto x:stk) cout<<x<<' ';cout<<endl;
//	for (int i=0;i<30;++i) cout<<fa[i]<<' ';cout<<endl;
	for (;L<66;++L){
		int p=-1;
		for (int i=0;i<30;++i) if (!vis[i]){p=i;break;}
		if (p==-1) break;
//		cout<<"try "<<p<<endl;
		int k=R[L][lst];ok[L][lst]=1;++bad;
		C[p]=k;vis[p]=1;
		for (int i=p+1;i<31;++i) if (vis[i]==0&&fa[i]!=-1&&C[fa[i]]){
			vis[i]=1;C[i]=qry[i];
		}
	}
	if (vis[30]==0){
		C[30]=16;
		for (int i=0;i<30;++i) C[30]-=C[i];
	}
	for (int i=0;i<66;++i) for (int j=0;j<31;++j) if (ok[i][j]==0&&C[j]) ans.emplace_back(R[i][j]);
//	for (int i=0;i<31;++i) cout<<C[i];cout<<endl;
	assert(ans.size()>=1026);
	while(ans.back()==0) ans.pop_back();ans.pop_back();
	return ans;
}
```

---

## 作者：yyyyxh (赞：18)

vp 时我的做法到极限只有 87.16 分，感觉这个题的正解非常人能及啊。这里讲一下关于这个题的一些想法。

首先考虑单次 `send_packet` 能传递的信息量，发现你在完全不知道 $C$ 数组的情况下，信息被扰动了近乎一半的 bit，所以你基本上难以传递很多信息。一个简单的思路就是只传一个 bit，那么把所有的位置成这个 bit 的值，众数就是你传递出来的信息了。

所以说，你不能依靠单次 `send_packet` 传递足够的信息。这道题的解题关键就在于对于所有的 `send_packet` 被扰动的位是同样的且是已知的。成功把 $C$ 数组告诉 Basma 后，剩余的没有被控制的 bit 你就可以随便用了。所以我们所有做法出发的基本点就在于如何先把 $C$ 数组传过去。

题目要求我们传一个不定长的至多为 1024 位的信息。不定长实际上就是让我们传递 $\sum_{i=1}^{1024} 2^i$ 共 1025 个 bit 的信息。每次 `send_packet` 只有没有被控制的 16 个位是有效的。1025 个 bit 至少要用 65 次传输。

我们先考虑用众数法强硬地传递 $C$ 数组。$C$ 数组共 $31\choose 16$ 种可能，需要用 29 个 bit，所以你需要调用 65+29 次 `send_packet`，这个算法只能拿 30 来分。

如果我们能提前“解锁”一些 bit 直接拿来传 $C$ 效率会大大提高。所以我们考虑直接先把第一个没有被控制的 bit 传输过去。由于第一个解锁的 bit 一定在前 16 位，所以这个信息是 4 个 bit，用众数法传 4 个 bit 过去后再传 $C$，需要调用 65+1+4 次 `send_packet`，能拿 83.3 分。

考虑硬凹这个做法，你发现你传输过去的 packet 个数也是一种信息，分别传 0/1/2/3 个，能区分 $\sum_{i=0}^3 2^i=15$ 种第一位。但是还差了一种情况怎么办？考虑当没被控制第一位在第 16 位时，$C$ 就是一段前缀的 1，那么此时你就可以不传 $C$ 了。vp 时止步于此，获得 87.16 分。

正解十分人类智慧，考虑到你只能用 $66\times 16-1025=31$ 个 bit 来传输。所以你考虑求出每个没被控制位置循环往后走多少位能到下一个没被控制的位置 $x_i$。$x_i$ 的和将正好等于 31。

对于每个没被控制的 bit $i$，将前 $x_i-1$ 次 `send_packet` 操作的第 $i$ 位置 0，第 $x_i$ 次置 1。这样 Basma 通过第一次等于 1 的位置可以得到每一个位置的 $x_i$。

将所有的 $i\to (i+x_i)\bmod 31$ 连边，没被控制的位置形成了一个长度为 16 的大环。类似众数法的思想，我们容易发现长度为 16 的大环是唯一的，所以我们就成功的只用 31 个 bit 传输了 $C$ 数组。

---

## 作者：tiger2005 (赞：10)

首先考虑如何处理字符串长度不一的情况。考虑到待传输信息的长度 $0 \leq S \leq 1024$，我们显然无法在不添加长度的情况下传输包括长度在内的信息。那么我们考虑在信息的后面加入形如 $\texttt{011111...}$ 形式的字符串，将其补全为长度为 $1025$ 的字符串，那么在 B 解密后，只需要找到 $\texttt{0}$ 最后一次出现的位置，并将其后所有信息抛弃即可。

我们此时需要稳定传输长度为 $1025$ 的字符串，而根据题目要求，我们剩余的可操控信息为 $66 \times 16 - 1025 = 31$ 个，恰好等于每次传输的位数。考虑如下构造：

> 对于每个不被操控的位置 $i$，找到下一个不被操控的位置 $j$，其中最后一个位置的下一个位置为第一个位置。随后计算距离 $d = (j - i) \bmod 31$，对于 $i$ 位置传输的信息流，前 $d-1$ 次传输的信息都是 $\texttt{0}$，第 $d$ 次传输的信息是 $\texttt{1}$，剩余的次数可以填充待传输的信息。

在这个构造下，每个好的位置用于传输距离的位信息个数和恰为 $31$ 个，符合前面对信息的要求。

随后考虑在 B 的视角下如何算出好的位置. 对于所有位置 $i$，B 找到 $i$ 位置传输的信息流中第一次出现 $1$ 的轮数，设为 $d_i$。对于好的位置而言，位置 $(i + d_i) \bmod 31$ 对应的就是下一个好的位置，而对于其他位置而言则完全随机。

我们在一个包含 $31$ 个点的图中，对每个 $i$ 向 $(i + d_i) \bmod 31$ 连接一条有向边。考虑到每个点只有一条出边，那么整张图最终形成内向基环森林。其中，好的位置必然是首尾相接的，那么其形成了大小为 $16$ 的环。其他 $15$ 条边无法影响这个环的形态，而且就算是一起形成了另一个环，大小的最大值也只是 $15$，无法超过好的位置形成的环大小。

那么我们只需要在这个基环森林上找到最大的环，即可读出所有好的位置，也就可以进一步去掉用于表示距离的冗余位，通过规定的读取顺序读出原信息，解出初始的待传输信息。

```cpp
#include <vector>
#include <algorithm>
 
std::vector<bool> send_packet(std::vector<bool> A);
 
void send_message(std::vector<bool> M, std::vector<bool> C) {
  int len = M.size();
  M.resize(1025, false);
  for (int i = len + 1; i < 1025; i ++)
    M[i] = true;
  std::vector<std::vector<bool>> occupied(66, std::vector<bool>(31, false));
  std::vector<std::vector<bool>> transfer = occupied;
  for (int i = 0; i < 31; i ++) if (!C[i]) {
    int pos = (i + 1) % 31, x = 1;
    while (C[pos])
      pos = (pos + 1) % 31, ++ x;
    for (int j = 0; j < x; j ++)
      occupied[j][i] = true, transfer[j][i] = j == x - 1;
  }
  int cur = 0;
  for (int i = 0; i < 31; i ++) if (!C[i])
    for (int j = 0; j < 66; j ++) if (!occupied[j][i])
      transfer[j][i] = M[cur ++];
  for (auto packet: transfer)
    send_packet(packet);
}
 
std::vector<bool> receive_message(std::vector<std::vector<bool>> R) {
  std::vector<int> toward(31);
  std::vector<bool> C(31, true);
  for (int i = 0; i < 31; i ++)
    for (int j = 0; j < 31; j ++) if (R[j][i]) {
      toward[i] = (i + j + 1) % 31;
      break;
    }
  {
    std::vector<int> path, cycle;
    std::vector<bool> vis(31);
    for (int i = 0; i < 31; i ++) if (!vis[i]) {
      path.clear();
      int pos = i;
      while (!vis[pos]) {
        vis[pos] = true;
        path.push_back(pos);
        pos = toward[pos];
      }
      auto ptr = std::find(path.begin(), path.end(), pos);
      if (path.end() - ptr == 16) {
        for (int t = 0; t < 16; t ++)
          cycle.push_back(*(ptr ++));
      }
    }
    for (auto ele: cycle)
      C[ele] = false;
  }
  std::vector<std::vector<bool>> occupied(66, std::vector<bool>(31, false));
  for (int i = 0; i < 31; i ++) if (!C[i]) {
    int pos = (i + 1) % 31, x = 1;
    while (C[pos])
      pos = (pos + 1) % 31, ++ x;
    for (int j = 0; j < x; j ++)
      occupied[j][i] = true;
  }
  std::vector<bool> info(1025);
  int cur = 0;
  for (int i = 0; i < 31; i ++) if (!C[i])
    for (int j = 0; j < 66; j ++) if (!occupied[j][i])
      info[cur ++] = R[j][i];
  int len = 1024;
  while (info[len])
    len --;
  info.resize(len);
  return info;
}
```

---

## 作者：Phartial (赞：7)

How zak's mind works?

每个包中我们最多传 $16$ 个 bit 的信息，于是总共只能传 $66 \times 16=1056$ 个 bit。信息本身需要 $1025$ 个 bit（因为长度不固定，所以要额外多发一个 bit），那么我们就要用剩下的 $31$ 个 bit 把 $C$ 发给 Basma。

仔细阅读题面，你会发现有几个重要的信息还没用上：每个包中我们控制的 bit 比 Cleopatra 控制的 bit 多一位，且**发给 Basma 的包是有序的**。

前者引导我们尝试找到某种类似众数的性质，比如我们可以用一个包传一个 bit：只需要将整个包赋值为这个 bit，则 Cleopatra 无论如何也改变不了这个包的众数，也即我们要传过去的 bit。

后者引导我们尝试利用时间轴发送更多的信息，比如我们可以通过前几个包为 0 而某一个包为 1 的方式在一个位置上传递一个数，而我们需要这些数组成的结构有某种类似众数的性质，从而无法被 Cleopatra 扰乱。

这时可能需要一些灵光一闪：对每个我们控制的 bit，我们可以传过去**它到下一个我们控制的 bit 的距离**（循环意义下），由于距离和为 $31$，我们的确只需要 $31$ 个 bit 就能把这些数传过去。

那它有没有众数性质？Basma 收到消息并还原每个位置上的值，并向对应点连边，则连出来的图是一个内向基环树森林，而我们控制的位给出了其中的一个长度为 $16$ 的环，这不可能被 Cleopatra 扰乱。于是我们成功的使用 $31$ 个 bit 告诉了 Basma 我们控制的位有哪些，剩下的 $1025$ 个 bit 就可以用来传信息了。

[code](https://qoj.ac/submission/604329).

---

## 作者：PTqwq (赞：2)

这题，太厉害了。

首先考虑有 $16$ 个位是不会被篡改的，那也就是说我们如果在这 $16$ 位都填同一个数，那无论剩下的位怎么改，我们都可以通过求绝对众数算出来就可以求出这个数，这样我们就做到了发一个包传送 $1$-bit。

直接在 $M$ 后面加一个 $0$，不足 $1025$ 位的地方用 $1$ 补齐。这样我们只需要先取有效的 $1025$ 个 bit 之后去掉最后一个 $0$ 及其后面的所有东西即可。

直接暴力传送我们可以做到 $95$ 次。

但是这样一次只传 $1$-bit 太浪费了，我们考虑先挖掘一个安全的位，设为 $p$，然后我们用这个位传送 $C$ 数组，剩下的安全的位先传送 $M$ 的内容，这样差不多可以做到 $70$ 次，也就是发现 $0 \sim 15$ 一定有一个位是安全的，用传送众数的方法只需要 $4$ 次就可以把这个安全的位传送过去，本质上就是一边传 $C$ 一边传 $M$，等 $C$ 传送了也就揭开了 $M$ 的神秘面纱。

但是发现这个还是过不了，稍微计算一下我们只能传送 $66 \times 16 = 1056$ 个有效的位，去掉传送 $M$ 必须要用的 $1025$ 位那么只剩下 $1056 - 1025 = 31$ 位，这正好是 $C$ 的长度，我们设 $d(i)$ 表示 $i$ 再往后循环走几步（$\bmod 31$）才可以碰到下一个安全的位，这样一定会成一个长度为 $16$ 的环，我们只需要让第 $1 \sim d(i) - 1$ 个包的第 $i$ 位都是 0，第 $d(i)$ 个包的第 $i$ 位是 1 就可以传送 $d$ 数组了，你发现 $\sum d = 31$（安全位的 $d$），我们就正好传送了所有信息。

为什么这个做法对呢？其实就是你剩下的点再怎么成环也成不了长度 $\geq 16$ 的环，而且这也是一个长度等于 $16$ 的定环，所以即使篡改我们也可以还原这个长度为 $16$ 的环，至此这个题被解决。

是不是很牛！！！

```cpp
#include "message.h"
#include <bits/stdc++.h>

using namespace std;

void send_message(vector<bool> M, vector<bool> C) {
    vector<bool> a(31);
    vector<vector<bool>> b(66);
    for (int i = 0; i < 31; ++ i) a[i] = false;
    for (int i = 0; i < 66; ++ i) b[i] = a;
    vector<pair<int, int>> st;
    for (int i = 0; i < 31; ++ i) {
        if (!C[i]) {
            int nxt = 0;
            for (int j = 1; j <= 31; ++ j) {
                if (!C[(i + j) % 31]) {
                    nxt = j;
                    break;
                }
            }
            for (int k = 1; k < nxt; ++ k) b[k - 1][i] = false;
            b[nxt - 1][i] = true;
            for (int k = nxt; k < 66; ++ k) st.push_back(make_pair(k, i));
        }
    }
    int siz = M.size(); M.push_back(false); siz ++;
    while (siz < 1025) M.push_back(true), siz ++;
    for (int i = 0; i < 1025; ++ i) b[st[i].first][st[i].second] = M[i];
    for (int i = 0; i < 66; ++ i) send_packet(b[i]);
}

vector<bool> receive_message(vector<vector<bool>> R) {
    vector<int> nxt(31), dsu(31), fir(31);
    for (auto& x : nxt) x = 0;
    for (auto& x : fir) x = 0;
    iota(dsu.begin(), dsu.end(), 0);
    auto findFa = [&](auto self, int x) -> int {
        if (dsu[x] == x) return x;
        else {
            dsu[x] = self(self, dsu[x]);
            return dsu[x];
        }
    };
    auto link = [&](int u, int v) -> void {
        u = findFa(findFa, u);
        v = findFa(findFa, v);
        if (u != v) {
            dsu[u] = v;
        }
    };
    int p = -1;
    vector<int> vc;
    for (int i = 0; i < 31; ++ i) {
        int d = -1;
        for (int j = 0; j < 66; ++ j) {
            if (R[j][i]) {
                d = j + 1;
                fir[i] = j + 1;
                break;
            }
        }
        nxt[i] = (i + d + 31) % 31;
        if (findFa(findFa, i) == findFa(findFa, nxt[i])) {
            vc.push_back(i);
        }
        link(i, nxt[i]);
    }
    vector<int> siz(31);
    for (auto& x : siz) x = 0;
    for (int i = 0; i < 31; ++ i) siz[findFa(findFa, i)] ++;
    for (auto x : vc) {
        if (siz[findFa(findFa, x)] >= 16) {
            p = x;
            break;
        } 
    }
    vector<int> pos;
    for (int i = 0; i < 16; ++ i) {
        pos.push_back(p); p = nxt[p];
    }
    sort(pos.begin(), pos.end());
    vector<pair<int, int>> st;
    for (auto i : pos) {
        for (int k = fir[i]; k < 66; ++ k) st.push_back(make_pair(k, i));
    }
    vector<bool> ans;
    for (int i = 0; i < 1025; ++ i) ans.push_back(R[st[i].first][st[i].second]);
    while (!ans.empty() && ans.back() == 1) ans.pop_back();
    ans.pop_back();
    return ans;
}
```

---


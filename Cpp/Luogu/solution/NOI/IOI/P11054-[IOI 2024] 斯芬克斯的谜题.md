# [IOI 2024] 斯芬克斯的谜题

## 题目背景

请在提交时不要引用 `sphinx.h`，并在代码开头加入如下内容：

```cpp
#include <vector>
int perform_experiment(std::vector<int> E);
```

请勿用 C++14 (GCC 9) 提交。

## 题目描述

斯芬克斯为你准备了一个谜题。给定 $N$ 个顶点的图，顶点从 $0$ 到 $N-1$ 编号。图中有 $M$ 条边，从 $0$ 到 $M-1$ 编号。每条边连接两个不同的顶点，且边是双向的。具体来说，对从 $0$ 到 $M-1$ 的每个 $j$，边 $j$ 连接顶点 $X[j]$ 和 $Y[j]$。任意两个顶点之间最多有一条边。若两个顶点被一条边连接，则它们是**相邻的**。

对顶点序列 $v_0, v_1, \ldots, v_k$（对 $k \ge 0$），若每两个连续顶点 $v_l$ 和 $v_{l+1}$（对所有满足 $0 \le l \lt k$ 的 $l$）是相邻的，则称其为一条**路径**。路径 $v_0, v_1, \ldots, v_k$ **连接**顶点 $v_0$ 和 $v_k$。在给定的图中，每对顶点被某条路径连接。

现在有 $N + 1$ 种颜色，从 $0$ 到 $N$ 编号。其中，颜色 $N$ 是特殊的，称为**斯芬克斯之色**。一开始每个顶点都有一种颜色，顶点 $i$（$0 \le i \lt N$）的颜色是 $C[i]$。多个顶点可以是同一种颜色的，有的颜色可能没有对应的顶点，且不会有顶点的颜色是斯芬克斯之色。也就是说，$0 \le C[i] \lt N$（$0 \le i \lt N$）。

若一条路径 $v_0, v_1, \ldots, v_k$（对 $k \ge 0$）上的所有顶点都是相同颜色的，则称其是**单色**的。也就是说，满足 $C[v_l] = C[v_{l+1}]$（对所有满足 $0 \le l \lt k$ 的 $l$）。此外，两个顶点 $p$ 和 $q$（$0 \le p \lt N$，$0 \le q \lt N$）在同一个**单色分支**中，当且仅当它们被某条单色路径连接。

你知道图中顶点和边的关系，但是你不知道每个顶点的颜色。你希望通过**重新着色实验**来弄清楚顶点的颜色。

在一次重新着色实验中，你可以对任意多的顶点进行重新着色。具体来说，在一次重新着色实验中，你先给出一个长度为 $N$ 的数组 $E$，对每个 $i$（$0 \le i \lt N$），$E[i]$ 的值在 $-1$ 和 $N$ 之间（**包括** $-1$ 和 $N$）。重新着色后，每个顶点 $i$ 的颜色变成了 $S[i]$，其中 $S[i]$ 的值：
* 若 $E[i] = -1$，则是 $C[i]$，也就是重新着色前顶点 $i$ 的颜色；
* 否则，是 $E[i]$。

注意：你可以在重新着色的过程中使用斯芬克斯之色。

在将每个顶点 $i$ 的颜色设为 $S[i]$（$0 \le i \lt N$）之后，斯芬克斯会宣布图中单色分支的数量。新的着色情况仅在本次重新着色实验中有效，因此**当本次实验结束后，所有顶点的颜色会恢复成最初的情况**。

你的任务是至多通过 $2\,750$ 次重新着色实验来确定图中顶点的颜色。如果正确给出了每对相邻顶点是否具有相同颜色，那么也会获得部分分数。

### 实现细节

你要实现以下函数。

```
std::vector<int> find_colours(int N,
    std::vector<int> X, std::vector<int> Y)
```

* $N$：图中顶点的数量。
* $X$，$Y$：两个长度为 $M$ 的数组，描述图中的边。
* 该函数应该返回一个长度为 $N$ 的数组 $G$，表示图中顶点的颜色。
* 对每个测试用例，该函数恰好被调用一次。

以上函数可以通过调用下面的函数来进行重新着色实验：

```
int perform_experiment(std::vector<int> E)
```

* $E$：长度为 $N$ 的数组，指定顶点重新着色的方式。
* 该函数返回根据 $E$ 所给出的方式进行重新着色后单色分支的数量。
* 该函数至多只能调用 $2\,750$ 次。

评测程序**不是自适应的**。也就是说，顶点的颜色在调用 `find_colours` 之前就已经固定下来了。

## 说明/提示

考虑以下函数调用。

```
find_colours(4, [0, 1, 0, 0], [1, 2, 2, 3])
```

在这个例子中，假设顶点的（隐藏的）颜色是 $C = [2, 0, 0, 0]$，如下图所示。顶点的颜色同时也用数字标注在顶点右上角的标签里。

![](https://cdn.luogu.com.cn/upload/image_hosting/ih99ftw2.png "230")

假设该函数以下列方式调用 `perform_experiment`。

```
perform_experiment([-1, -1, -1, -1])
```

这次调用没有重新着色任何顶点，因此所有顶点都保持它们原来的颜色。

顶点 $1$ 和顶点 $2$ 都是颜色 $0$ 的。因此路径 $1, 2$ 是单色路径，从而顶点 $1$ 和顶点 $2$ 在同一个单色分支中。

顶点 $1$ 和顶点 $3$ 都是颜色 $0$ 的。但是由于不存在连接它们的单色路径，因此它们在不同的单色分支中。

总共有 $3$ 个单色分支，分别是顶点集合 $\{0\}$、$\{1, 2\}$ 和 $\{3\}$。因此，本次函数调用返回 $3$。

再假设该函数以下列方式调用 `perform_experiment`。

```
perform_experiment([0, -1, -1, -1])
```

这次调用只把顶点 $0$ 重新着色成颜色 $0$，结果如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/n0qub0o1.png "230")

此时所有顶点都属于同一个单色分支，因此本次函数调用返回 $1$。由此可以推断顶点 $1$、$2$ 和 $3$ 都是颜色 $0$ 的。

假设该函数还以下列方式调用 `perform_experiment`。

```
perform_experiment([-1, -1, -1, 2])
```

这次调用把顶点 $3$ 重新着色成颜色 $2$，结果如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/ds6xl13a.png "230")

这时有 $2$ 个单色分支，分别是顶点集合 $\{0, 3\}$ 和 $\{1, 2\}$，因此本次函数调用返回 $2$。由此可以推断顶点 $0$ 是颜色 $2$ 的。

然后函数 `find_colours` 返回数组 $[2, 0, 0, 0]$。由于 $C = [2, 0, 0, 0]$，因此可以获得满分。

此外，也还有多种返回值，例如 $[1, 2, 2, 2]$ 或 $[1, 2, 2, 3]$，可以获得 $50\%$ 的分数。

### 约束条件

* $2 \le N \le 250$
* $N - 1 \le M \le \frac{N \cdot (N - 1)}{2}$
* 对所有满足 $0 \le j \lt M$ 的 $j$，都有 $0 \le X[j] \lt Y[j] \lt N$。
* 对所有满足 $0 \le j \lt k \lt M$ 的 $j$ 和 $k$，都有 $X[j] \neq X[k]$ 或 $Y[j] \neq Y[k]$。
* 每对顶点被某条路径连接。
* 对所有满足 $0 \le i \lt N$ 的 $i$，都有 $0 \le C[i] \lt N$。

| 子任务 | 分数  | 额外的约束条件 |
| :-----: | :----: | ---------------------- |
| 1       | $3$    | $N = 2$|
| 2       | $7$    | $N \le 50$|
| 3       | $33$   | 给定的图是一条路径：$M = N - 1$，且顶点 $j$ 和 $j+1$ 是相邻的（$0 \leq j < M$）。 |
| 4       | $21$   | 给定的图是完全图：$M = \frac{N \cdot (N - 1)}{2}$，且任意两个顶点是相邻的。 |
| 5       | $36$   | 没有额外的约束条件。 |

在每个子任务中，如果你的程序正确给出了每对相邻顶点是否具有相同颜色，那么也会获得部分分数。

更准确地说，如果在所有测试用例中 `find_colours` 返回的数组 $G$ 与数组 $C$ 完全一样（也就是对所有满足 $0 \le i \lt N$ 的 $i$，都有 $G[i] = C[i]$），你会获得该子任务的全部分数。否则，如果在某个子任务的所有测试样例中满足下列条件，你会获得该子任务 $50\%$ 的分数：

* 对所有满足 $0 \le i \lt N$ 的 $i$，都有 $0 \le G[i] \lt N$；
* 对所有满足 $0 \le j \lt M$ 的 $j$，都有：
  * $G[X[j]] = G[Y[j]]$ 当且仅当 $C[X[j]] = C[Y[j]]$。

## 样例 #1

### 输入

```
4 4
2 0 0 0
0 1
1 2
0 2
0 3```

### 输出

```
4 3
2 0 0 0
```

# 题解

## 作者：zjy2008 (赞：9)

人类智慧题喵。

先考虑 $50$ 分怎么做，按 $1\cdots N$ 的顺序依次加入点，若没有被加入就把颜色记为 $N$ 。先假设这个点 $u$ 新构成了一个颜色连通块，可以通过已知信息推导出查询应该有的连通块数。若符合期望，直接退出，开始加入下一个点。否则在 $1\cdots u-1$ 中二分第一个和它形成同一连通块的点，将这 $2$ 个联通块合并后回到第一步。

分析一下操作次数，记最终连通块数为 $C$。每次合并 $2$ 个连通块需要 $\log N$ 次查询。一个点加入完成后需要 $1$ 次查询，共有 $(N-C)\log N+N$ 次查询。

如果最后只剩下了 $1$ 个连通块，这是平凡的。

考虑把整个连通块视为一个点，建成点数为 $C$ 的新图，随便搜出一棵生成树并黑白染色。先枚举颜色 $c$，把白色点都赋为 $c$，黑色点保持原状。假设所有黑色点的颜色都不为 $c$，可以推导出应该有的连通块数。若查询符合期望，直接退出，枚举下一个颜色。否则二分所有白点中第一个和 $c$ 颜色相同的。

显然你需要交换黑白，再做一次，故操作数是 $C\log N+2N$ 的。

总操作数为 $N\log N+3N$，可以获得满分。

---

## 作者：tiger2005 (赞：7)

感谢 @[dead_X](/user/111055) 在思考过程中提供的一些帮助。

---

我们不妨从 Subtask 3 入手。我们首先分析每次询问的性质，考虑到连通块这一结构，能够得到接下来的用途：

> Usage 1：选择原图的一个点独立集 $S$，在询问中保持它们的颜色不变，而其他点统一染为某个颜色 $c$。我们在钦定独立集中没有一个点的颜色是 $c$ 的前提下算出连通块个数，那么如果询问后连通块个数不匹配，就说明集合 $S$ 中至少有一个点的颜色是 $c$。
>
> 假设我们选择了 $x$ 个点，根据独立集的性质，这 $x$ 个点各自形成一个同色连通块。对于其他的点，我们求出这些点在原图上构成的连通块数 $y$。那么此时，连通块个数匹配当且仅当询问的返回值为 $x + y$。

这一个用途可以很自然的带入到链情形中。具体的，考虑链上最容易找到的两个独立集：下标为奇数的点形成的集合，以及下标为偶数的点形成的集合。我们将集合写作序列，尝试通过二分找到第一个颜色等于 $c$ 的点，这个操作即可通过 Usage 1 做到。随后，将这个点丢弃，并继续二分接下来一个颜色为 $c$ 的点。在每次二分之前，需要提前跑一次对全序列的 Usage 1，保证本次二分是有效的。

接下来分析这个方案用到的询问数。对每个独立集的序列，需要进行若干次二分试探，其中 $n$ 次是失败的，而对于每个点，都对应了一次成功的试探，以及后面的二分流程。那么，假设当前的颜色种类为 $N$，而点的个数为 $C$，则所需的询问数存在一个上界 $2N + \sum_{i=1}^{C} (\lceil \log i \rceil + 1)$。这里需要注意的是，每次二分成功后，序列的长度都会减少 1，对应的二分次数也可能会减少。

这个思想可以很自然的套用到任何一个二分图上，对应的询问数也是类似的。

接下来考虑如何实现任意图的问题。我们不能对任意的图进行黑白染色，所以我们需要尝试找到黑白染色的方案，并在这个方案下套用二分图的做法。我们接下来介绍一个比较重要的性质。

下面，为了区分黑白染色和题目给出的每个点颜色，我们称黑白染色的结果为“黑类”和“白类”，而维持原题目对颜色的描述。

> 性质：假如我们已经知道某条边 $(x, y)$ 连接的两个点 $x$ 和 $y$ 颜色不同，那么我们可以将这两个点同时归为黑类或者白类，而对于一个分类方案，唯一的需求是每个点都需要和一个不同类的点相邻。我们将会证明，必然可以找到一个符合这个性质的分类方案。
>
> 具体的，对于两个同类相邻点没有被同时选择的情况，我们是可以正常处理的。我们只需要讨论两个同类相邻点被同时选择的情况。Usage 1 的本质是检查是否存在一个颜色为 $c$ 且被选中的点和一个未被选中的点相邻，所以我们在这里强调每个点都需要和一个不同类的点相邻。
>
> 考虑此时 Usage 1 的工作机制是否正常。由于同时被选择的两个相邻同类点本身的颜色就是不同的，那么即使选出的 $x$ 个同类点之间可能连边，但是它们形成的同色连通块必然还是 $x$ 个（和独立集的情况相同）。这个道理对交互库的返回值也是类似的。经过简单的分析就可以得到结论：Usage 1 的判断不会因此产生影响。

既然我们需要保证一条边连接的两个点颜色不同，那么不妨先将原图的所有同色连通块缩成一个单点，那么在缩点后的新图上，根据性质，一个分类方案只需要满足“每个点都需要和一个不同类的点相邻”。为了做到这一点，只需要找到新图的任意一棵生成树，在这棵树上黑白染色即可。

接下来的问题是找到原图中的所有同色连通块，并将其缩点。这个问题实际上就是本题的 50% 部分分。

我们此时不妨对每个点求出与其颜色相同的相邻点，据此即可通过并查集缩点。接下来给出询问的另一个用途。

> Usage 2：对于某个点 $x$，以及和它相邻的若干个点形成的集合 $S$（这个集合不需要是和 $x$  相邻的所有点），为了检测这个集合中是否存在和 $x$ 同样颜色的点，我们可以进行两次询问：
> 
> 询问 1：令 $S$ 中的所有点颜色不变，其余所有点颜色均变为 $N$，求出此时的同色连通块数量 $x$；
>
> 询问 2：在询问 1 的基础上，令 $x$ 点的颜色不变，求出此时的同色连通块数量 $y$。
>
> 那么，如果 $S$ 中不存在和 $x$ 颜色相同的点，那么 $x$ 本身形成一个同色连通块，也就是 $y = x + 1$；否则，$x$ 必然会和加入至少一个同色相邻点的连通块中，也就是 $y \leq x$。据此进行判断即可。

Usage 2 同样可以进行二分，但是每次操作需要两次询问，预计开销将会到达 $2 N \log N$，显然无法通过此题。考虑如何减少一个询问。

注意到一个事实：对于每条边连接的两个点，只需要在某个点计算颜色是否相同即可。这启发我们钦定每个点的计算顺序，进一步得到接下来的增量算法：

> 首先，随便找一个点，将其放在某个不断扩大的图中，下面称其为增量图。另外，对增量图的每个同色连通块，实时维护一个互不相同的编号。接下来，不断进行下面的操作，直到每个点都被加入到增量图中：
>
> 选择一个没有被加入增量图的点 $x$，并尝试将其加入到增量图中。此时，找到在原图中和 $x$ 相邻，且加入到增量图中的点，并将这些点所在的同色连通块的编号提出。接下来，考虑从 $x$ 和其中哪些连通块存在同样的颜色，并将它们合并起来（如果没有同色连通块，新开一个编号即可）。每条边连接的两个点的同色情况将会在较晚加入增量图的点中统计，故最终形成的同色连通块和原图的同色连通块一致。
>
> 在增量图上，Usage 2 的第一步可以直接通过同色联通块的编号算出，故可以省去第一个询问。

我们尝试估计出上面的方案所需的询问次数。首先，假设连通块在第 $i$ 个点加入时的颜色数为 $c_{i}$，且假设 $c_1 = 0, c_{n+1} = C$。那么此时有 $c_{i+1} \leq c_i + 1$，自然可以得到 $c_{i} \leq i - 1$。对于每个点而言，其每次会进行一次失败的二分试探，而对于每次成功试探，将会进行一次完整的二分，那么贡献的询问次数的上界就是 $1 + \sum_{l = c_{i+1}}^{c_i} (\lceil \log l \rceil + 1)$，在这个点和每个同色连通块都相邻时取得上界。进行求和后，总共所需的询问次数不会超过：（令 $P_i = \sum_{l=1}^{i} (\lceil \log l \rceil + 1)$）

$$
\begin{aligned}
&\sum_{i=1}^{N} [1 + \sum_{l = c_{i+1}}^{c_i} (\lceil \log l \rceil + 1)]\\
\leq \ & \sum_{i=1}^{N} [1 + \sum_{l = c_{i+1} + 1}^{c_i + 1} (\lceil \log l \rceil + 1)]\\
=\ & N + \sum_{i=1}^{N} P_{c_i + 1} - P_{c_{i+1}}\\
=\ & N - P_{C} + P_{c_0} + \sum_{i=1}^{N} P_{c_i+1} - P_{c_{i}}\\
=\ & N - P_{C} + \sum_{i=1}^{N} (\lceil \log (c_{i} + 1) \rceil + 1)\\
\leq\ & N - P_{C} + \sum_{i=1}^{N} (\lceil \log i \rceil + 1)\\
=\ & N + \sum_{i=C+1}^{N} (\lceil \log i \rceil + 1)
\end{aligned}
$$

我们就得到了前半部分操作数的一个上界。而在得到 $C$ 个同色连通块后，我们进行缩点并通过二分图的方案求解，此时将会带来额外的 $2N + \sum_{i=1}^{C} (\lceil \log i \rceil + 1)$ 个操作。那么可以得到操作数的总上界为：

$$
\begin{aligned}
&N + \sum_{i=C+1}^{N} (\lceil \log i \rceil + 1) + 2N + \sum_{i=1}^{C} (\lceil \log i \rceil + 1)\\
=\ & 3 N + \sum_{i=1}^{N} (\lceil \log i \rceil + 1)\\
\leq\ & 3 N + N \lceil \log N \rceil
\end{aligned}
$$

在 $N = 250$ 时，这个上界恰好为 $2750$，可以通过。事实上，真实的上界在 $N = 250$ 时等于 $2745$。

实现时注意所有颜色相同的 corner case。

```cpp
#include <vector>
#include <numeric>
#include <cassert>
#include <algorithm>
using namespace std;
 
int perform_experiment(vector<int> E);
 
vector<int> g[250], ng[250];
int P[250], Q[250], c, n;
int fa[250];
 
int getf(int x) {
  return x == fa[x] ? x : fa[x] = getf(fa[x]);
}
 
// count all components with sphinx's color
int sphinx_components(const vector<int> &Q) {
  int res = 0;
  iota(fa, fa + n, 0);
  for (int i = 0; i < n; i ++) if (Q[i] == n) {
    ++ res;
    for (auto j: g[i]) if (Q[i] == Q[j]) {
      int u = getf(i), v = getf(j);
      if (u != v)
        -- res, fa[u] = v;
    }
  }
  return res;
}
 
// assume that all groups of -1 are different from their sublings
// count components other than -1
int assume_components(const vector<int> &Q) {
  int res = n - count(Q.begin(), Q.end(), -1);
  iota(fa, fa + n, 0);
  for (int i = 0; i < n; i ++) if (Q[i] != -1)
    for (auto j: g[i]) if (Q[i] == Q[j]) {
      int u = getf(i), v = getf(j);
      if (u != v)
        -- res, fa[u] = v;
    }
  return res;
}
 
bool check_ng(const vector<int> &v, int l, int r, int col) {
  vector<int> query(n);
  vector<bool> app(c);
  for (int i = l; i <= r; i ++)
    app[v[i]] = true;
  for (int i = 0; i < n; i ++)
    query[i] = (app[P[i]] ? -1 : col);
  return perform_experiment(query) != assume_components(query) + (r - l + 1);
}
 
vector<int> find_colours(int N, vector<int> X, vector<int> Y) {
  int m = X.size(); n = N;
  for (int i = 0; i < m; i ++) {
    int x = X[i], y = Y[i];
    g[x].push_back(y);
    g[y].push_back(x);
  }
  iota(P, P + n, 0);
  fill(Q, Q + n, -1);
  // coloring
  for (int x = 0; x < n; x ++) {
    vector<int> adj_colors;
    for (auto v: g[x])
      if (v < x)
        adj_colors.push_back(P[v]);
    sort(adj_colors.begin(), adj_colors.end());
    adj_colors.erase(unique(adj_colors.begin(), adj_colors.end()), adj_colors.end());
    int L = 0, m = adj_colors.size();
 
    auto check = [&] (int l, int r) {
      vector<bool> app(n);
      for (int i = l; i <= r; i ++)
        app[adj_colors[i]] = true;
      vector<int> query(n, n);
      query[x] = -1;
      for (int i = 0; i < n; i ++) if (P[i] != -1 && app[P[i]])
        query[i] = -1;
      return sphinx_components(query) + (r - l + 1) + 1 != perform_experiment(query);
    };
 
    while (L < m && check(L, m - 1)) {
      int l = L, r = m - 1, rl = m - 1;
      while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(L, mid))
          rl = mid, r = mid - 1;
        else
          l = mid + 1;
      }
      for (int i = 0; i < n; i ++) if (P[i] == adj_colors[rl])
        P[i] = x;
      L = rl + 1;
    }
  }
  // renumber colors
  {
    vector<int> G;
    for (int i = 0; i < n; i ++)
      G.push_back(P[i]);
    sort(G.begin(), G.end());
    G.erase(unique(G.begin(), G.end()), G.end());
    c = G.size();
    for (int i = 0; i < n; i ++)
      P[i] = lower_bound(G.begin(), G.end(), P[i]) - G.begin();
  }
  // all with same color
  if (c == 1) {
    for (int i = 0; i < n; i ++) {
      vector<int> query(n, -1);
      query[0] = i;
      if (perform_experiment(query) == 1)
        return vector<int>(n, i);
    }
    assert(false);
  }
  for (int i = 0; i < n; i ++)
    for (auto j: g[i])
      ng[P[i]].push_back(P[j]), ng[P[j]].push_back(P[i]);
  vector<int> black, white;
  vector<bool> vis(n);
  auto dfs = [&] (auto self, int x, int col) -> void {
    (col ? black : white).push_back(x);
    vis[x] = true;
    for (auto y: ng[x]) if (!vis[y])
      self(self, y, !col);
  };
  dfs(dfs, 0, 0);
  for (auto v: {black, white}) {
    for (int i = 0; i < n; i ++) {
      int L = 0;
      vector<int> new_v;
      for (auto e: v) if (Q[e] == -1)
        new_v.push_back(e);
      swap(v, new_v);
      int m = v.size();
      while (L < m && check_ng(v, L, m - 1, i)) {
        int l = L, r = m - 1, rl = m - 1;
        while (l <= r) {
          int mid = (l + r) >> 1;
          if (check_ng(v, L, mid, i))
            rl = mid, r = mid - 1;
          else
            l = mid + 1;
        }
        Q[v[rl]] = i;
        L = rl + 1;
      }
    }
  }
  vector<int> ans(n);
  for (int i = 0; i < n; i ++)
    ans[i] = Q[P[i]];
  return ans;
}
```

---

## 作者：luqyou (赞：6)

# 前言

纪念第一个自己做出来的黑。

想了一个多星期的晚自习啊啊啊啊啊啊啊。

# 思路

我们先从图的特殊性质入手。

## 链

确定相邻点的颜色是否相同是简单的，接下来考虑如何确定每个点的颜色。

我们对于奇偶下标讨论。对于一个下标同奇偶的点集，我们可以枚举每一种颜色。记当前枚举的颜色为 $i$，则我们可以在点集内二分，每次二分一个下标最大的点满足其颜色为 $i$。设我们 check 的区间为 $[l,r]$，则可以将 $[l,r]$ 内的点全部保持不变，$[l,r]$ 外的点染成 $N$，然后与上面一样，计算应有的连通块数并对比。

这样，确定每个点颜色的询问次数上界大约是 $3N \log N$，已经超出了 $2750$ 的限制，所以需要考虑优化。

我们发现若一个颜色没有在点集内出现，则上述算法还是需要 $\log N$ 次询问来确定，实际上我们可以在每次枚举颜色最初就通过一次额外的询问确定点集内是否出现某种颜色，这样询问次数就降低到了 $2N + N \log N$。

## 完全图

现在我们需要考虑如何确定相邻节点的颜色是否相同。

容易想到对于每一个节点 $i$，判断是否存在 $j<i$ 满足 $C_j = C_i$。所以我们可以在 $[0,i)$ 上二分编号最大的与 $i$ 颜色相同的点。假设当前 check 区间为 $[l,r]$，我们将 $[l,r]$ 内与 $i$ 的颜色保持不变，其余全部染成 $N$，然后计算若 $[l,r]$ 内不存在一个点使得该点与 $i$ 颜色相同应有的连通块数目。根据完全图的性质，若 $[l,r]$ 内存在一个点与 $i$ 颜色相同，则必定有实际连通块数目与期望连通块数目不等，这样我们直接记录其与哪个节点颜色相同即可。

仍然考虑链做法的优化，在每次加入一个点时先用一次额外的询问确定是否存在于 $i$ 颜色相同的点，则询问上界为 $N + (N-K) \log N$，其中 $K$ 为相同颜色连通块的数目。

此时你发现完全图没有良好的性质去确定具体的颜色，所以我们猜测其确定具体颜色的做法与一般图做法相同。

## 一般图

现在我们考虑将上述两个特殊图的做法扩展到一般图。

首先我们来解决 $50\%$ 部分分的做法，即扩展完全图。

完全图的做法看起来很完美，但实际上如果你直接写会得到这样的高分：

![](https://cdn.luogu.com.cn/upload/image_hosting/yzltd5ir.png)

哪里有问题呢？

注意到完全图可以直接在其前面的地方二分是因为完全图任意两点均有直接连边，但对于一般图，则可能出现下面这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/34zitxw9.png)

此时我们如果按编号加入节点，且 $2,3$ 颜色相同，则可能出现你认为 $3,4$ 同色，但 $2,4$ 不同色的情况。所以我们将算法改为：我们在**邻居**上多次二分（因为只有两点有直接连边才能够通过连通块数量是否变化判断颜色是否相同），每次二分出一个编号最大的与 $i$ 相同颜色的节点，并且使用一个并查集维护颜色相同的联通分量。

但是你发现这样理论上来说询问次数貌似不太对，因为你可能对于已经在同一个联通分量中的点二分多次。所以我们改为，同一个联通分量中的点只加入一个，并且每次二分开始时检查是否还有节点能够被加入。这样同一个连通块内的点只会被合并一次，所以询问次数仍为 $N + (N-K) \log N$。

该部分代码如下：

```cpp
struct Dsu{
	int f[maxn];
	void init(int n){
		for(int i=0;i<n;i++) f[i]=i;
	}
	int find(int x){
		if(x!=f[x]) f[x]=find(f[x]);
		return f[x];
	}
	void merge(int u,int v){
		int fu=find(u),fv=find(v);
		if(fu!=fv) f[fu]=fv;
	}
}d;
int getp(vector<int> col){//该函数实现了一个在所有点颜色均确定情况下的 perform_experiment 函数，这样就不需要花费询问次数
	int sum=0,n=col.size();
	for(int i=0;i<n;i++) vis[i]=0;
	for(int i=0;i<n;i++){
		if(vis[i]) continue;
		queue<int> q;
		q.push(i),sum++;
		while(q.size()){
			int u=q.front();
			q.pop();
			for(int v:g[u]){
				if(!vis[v]&&col[v]==col[i]){
					vis[v]=1,q.push(v);
				}
			}
		}
	}
	return sum;
}
void add(int u){//加入点 u
	vector<int> vec,tmp,p;
	vec.resize(n),tmp.resize(n);
	umap<int,int> mp;
	for(int v:g[u]) if(v<u&&!mp[d.find(v)]) p.pb(v),mp[d.find(v)]=1;
	int now=p.size()-1,sz=now+1;
	while(now>=0){
		int res=-1,l=0,r=now;
		for(int i=0;i<n;i++) vec[i]=n;
		for(int i=l;i<=r;i++) vec[p[i]]=-1;
		vec[u]=-1;
		for(int i=0;i<n;i++) tmp[i]=n;
		for(int i=l;i<=r;i++) tmp[p[i]]=d.find(p[i]);
		tmp[u]=d.find(u);
		if(perform_experiment(vec)==getp(tmp)) return ; 
		while(l<=r){
			int mid=(l+r)>>1;
			for(int j=0;j<n;j++) vec[j]=n;
			for(int j=mid;j<sz;j++) vec[p[j]]=-1;
			vec[u]=-1;
			for(int j=0;j<n;j++) tmp[j]=n;
			for(int j=mid;j<sz;j++) tmp[p[j]]=d.find(p[j]);
			tmp[u]=d.find(u);
			if(perform_experiment(vec)!=getp(tmp)) res=mid,l=mid+1;
			else r=mid-1;
		}
		if(res>=0) d.merge(u,p[res]);
		now=res-1;
	}
}
```

接下来扩展链的做法来确定每个点的具体颜色。

思考为什么这个做法在链上能够成立：本质上是因为选出的点集是一个独立集，这样能够保证连通块数目的变化是因为有与非点集内的点颜色相同导致的；同时集合内每个点都至少有一个邻居它是非集合内的点，这样可以保证只要有集合内的点是我们钦定的颜色，就一定会导致连通块数目变化。

我们观察可得，只要点集内相邻的点颜色不同，则连通块数目的变化也一定是由于与非点集内的点连通导致的。这样我们便可以得出一个更强的结论：

对于一个点集 $S$，若对于所有 $u \in S,v \in , (u,v) \in E$ 满足 $C_u \neq C_v$ 且对于所有 $u \in S$，都至少存在一个 $v$ 满足 $v \not \in S,(u,v) \in E$ 则点集 $S$ 内的所有点的具体颜色都可以套用上述链的做法。

于是尝试思考：什么样的图满足这样的性质？

首先我们需要满足点集内相邻的点颜色不相同，而我们在第一步已经使用并查集维护了颜色相同的联通分量，所以此时可以直接对相同颜色的联通分量缩点。

然后不难想到，我们只需要找到一个点集与原图相同的二分图子图即可。二分图中最容易找的自然是树，所以我们可以随意找出原图的一棵生成树进行黑白染色，此时黑点点集与白点点集均满足可套用链做法的集合性质。

所以我们成功的把链的做法扩展到一般图，询问次数为 $2N + K \log N$。

该部分代码如下；

```cpp
void getcol(vector<int> p){//确定一个满足上述性质的点集 p 内的点的具体颜色
	vector<int> tmp,tmp2;
	tmp.resize(n),tmp2.resize(n);
	int dcnt=0,cc=0;
	for(int i=0;i<n;i++){
		dcnt=0;
		cc++;
		vector<int> pvis,q;
		for(int x:p) if(flg[x]==-1) q.pb(x);
		pvis.resize(n);
		int sz=q.size(),now=sz-1;
		while(now>=0){
			int l=0,r=now,res=-1;
			for(int j=0;j<cnt;j++) vis[j]=0;
			for(int j=l;j<=r;j++) vis[q[j]]=1;
			for(int j=0;j<n;j++) tmp[j]=(vis[id[j]]?-1:i);
			for(int j=0;j<n;j++) tmp2[j]=(vis[id[j]]?id[j]:n);
			int num=perform_experiment(tmp);
			if(num==getp(tmp2)) break;
			while(l<=r){
				dcnt=0;
				int mid=(l+r)>>1;
				for(int j=0;j<cnt;j++) pvis[j]=0;
				for(int j=0;j<n;j++) tmp[j]=i;
				for(int j=mid;j<=now;j++) pvis[q[j]]=1;
				for(int j=0;j<n;j++) if(pvis[id[j]]) tmp[j]=-1;
				int num=perform_experiment(tmp);
				for(int j=0;j<n;j++) tmp[j]=(pvis[id[j]]?id[j]:n);
				if(num==getp(tmp)) r=mid-1;
				else res=mid,l=mid+1;
			}
			if(res>=0){
				for(int j=0;j<n;j++) if(id[j]==q[res]) ans[j]=i;
				flg[q[res]]=0;
			} 
			now=res-1;
		}
	}
}
```

上述两个步骤的总询问次数为 $(N + (N-K) \log N) + (2N + K \log N) = 3N + N \log N$。当 $N = 250$ 这个值就是 $3 \times 250 + 250 \times 8 = 2750$。

# Code

这代码真是一坨大的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fi first
#define sc second
#define pii pair<int,int>
#define pdd pair<double,double>
#define pb push_back
#define umap unordered_map
#define mset multiset
#define pq priority_queue
#define ull unsigned long long
#define i128 __int128
#define ld long double
#define fixs fixed<<setprecision
const int maxn=250+10;
struct Dsu{
	int f[maxn];
	void init(int n){
		for(int i=0;i<n;i++) f[i]=i;
	}
	int find(int x){
		if(x!=f[x]) f[x]=find(f[x]);
		return f[x];
	}
	void merge(int u,int v){
		int fu=find(u),fv=find(v);
		if(fu!=fv) f[fu]=fv;
	}
}d;
int n,m,vis[maxn],c[maxn],cnt,qcnt,flg[maxn];
vector<int> g[maxn],gx[maxn],id,p,ans;
int perform_experiment(vector<int> col);
int getp(vector<int> col){//该函数实现了一个在所有点颜色均确定情况下的 perform_experiment 函数，这样就不需要花费询问次数
	int sum=0,n=col.size();
	for(int i=0;i<n;i++) vis[i]=0;
	for(int i=0;i<n;i++){
		if(vis[i]) continue;
		queue<int> q;
		q.push(i),sum++;
		while(q.size()){
			int u=q.front();
			q.pop();
			for(int v:g[u]){
				if(!vis[v]&&col[v]==col[i]){
					vis[v]=1,q.push(v);
				}
			}
		}
	}
	return sum;
}
void dfs(int u){//对原图的一棵生成树进行黑白染色
	for(int v:gx[u]){
		if(c[v]==-1){
			c[v]=c[u]^1;
			dfs(v);
		}
	}
}
void add(int u){//加入点 u
	vector<int> vec,tmp,p;
	vec.resize(n),tmp.resize(n);
	umap<int,int> mp;
	for(int v:g[u]) if(v<u&&!mp[d.find(v)]) p.pb(v),mp[d.find(v)]=1;
	int now=p.size()-1,sz=now+1;
	while(now>=0){
		int res=-1,l=0,r=now;
		for(int i=0;i<n;i++) vec[i]=n;
		for(int i=l;i<=r;i++) vec[p[i]]=-1;
		vec[u]=-1;
		for(int i=0;i<n;i++) tmp[i]=n;
		for(int i=l;i<=r;i++) tmp[p[i]]=d.find(p[i]);
		tmp[u]=d.find(u);
		if(perform_experiment(vec)==getp(tmp)) return ; 
		while(l<=r){
			int mid=(l+r)>>1;
			for(int j=0;j<n;j++) vec[j]=n;
			for(int j=mid;j<sz;j++) vec[p[j]]=-1;
			vec[u]=-1;
			for(int j=0;j<n;j++) tmp[j]=n;
			for(int j=mid;j<sz;j++) tmp[p[j]]=d.find(p[j]);
			tmp[u]=d.find(u);
			if(perform_experiment(vec)!=getp(tmp)) res=mid,l=mid+1;
			else r=mid-1;
		}
		if(res>=0) d.merge(u,p[res]);
		now=res-1;
	}
}
void getcol(vector<int> p){//确定一个满足上述性质的点集 p 内的点的具体颜色
	vector<int> tmp,tmp2;
	tmp.resize(n),tmp2.resize(n);
	int dcnt=0,cc=0;
	for(int i=0;i<n;i++){
		dcnt=0;
		cc++;
		vector<int> pvis,q;
		for(int x:p) if(flg[x]==-1) q.pb(x);
		pvis.resize(n);
		int sz=q.size(),now=sz-1;
		while(now>=0){
			int l=0,r=now,res=-1;
			for(int j=0;j<cnt;j++) vis[j]=0;
			for(int j=l;j<=r;j++) vis[q[j]]=1;
			for(int j=0;j<n;j++) tmp[j]=(vis[id[j]]?-1:i);
			for(int j=0;j<n;j++) tmp2[j]=(vis[id[j]]?id[j]:n);
			int num=perform_experiment(tmp);
			if(num==getp(tmp2)) break;
			while(l<=r){
				dcnt=0;
				int mid=(l+r)>>1;
				for(int j=0;j<cnt;j++) pvis[j]=0;
				for(int j=0;j<n;j++) tmp[j]=i;
				for(int j=mid;j<=now;j++) pvis[q[j]]=1;
				for(int j=0;j<n;j++) if(pvis[id[j]]) tmp[j]=-1;
				int num=perform_experiment(tmp);
				for(int j=0;j<n;j++) tmp[j]=(pvis[id[j]]?id[j]:n);
				if(num==getp(tmp)) r=mid-1;
				else res=mid,l=mid+1;
			}
			if(res>=0){
				for(int j=0;j<n;j++) if(id[j]==q[res]) ans[j]=i;
				flg[q[res]]=0;
			} 
			now=res-1;
		}
	}
}
vector<int> find_colours(int N,vector<int> u,vector<int> v){
	n=N,m=u.size(),d.init(n),id.resize(n),ans.resize(n);
	for(int i=0;i<m;i++) g[u[i]].pb(v[i]),g[v[i]].pb(u[i]);
	for(int i=1;i<n;i++) add(i);
	for(int i=0;i<n;i++) id[i]=d.find(i);
	vector<int> num=id;
	sort(num.begin(),num.end()),num.erase(unique(num.begin(),num.end()),num.end());
	for(int &x:id) x=lower_bound(num.begin(),num.end(),x)-num.begin();
	cnt=*max_element(id.begin(),id.end())+1;
	if(cnt==1){
		vector<int> tmp; 
		tmp.resize(n);
		for(int i=0;i<n;i++) tmp[i]=-1; 
		for(int i=0;i<n;i++){
			tmp[0]=i;
			if(perform_experiment(tmp)==1){
				for(int j=0;j<n;j++) ans[j]=i;
			}
		}
		return ans;
	}
	for(int i=0;i<n;i++){
		c[i]=flg[i]=-1;
		for(int j:g[i]){
			if(id[i]!=id[j]) gx[id[i]].pb(id[j]);
		}
	}
	c[0]=0,dfs(0);
	vector<int> vec[2];
	for(int i=0;i<cnt;i++) vec[c[i]].pb(i);
	getcol(vec[0]),getcol(vec[1]); 
	return ans;
}
```

---

## 作者：Larunatrecy (赞：5)

首先考虑 $50$ 分的做法，也就是我们只需要划分出每个极大的同色连通块。

增量法，每次加一个点 $x$，然后把没有加入的点以及与 $x$ 不相邻的点都设为 $n$，其余的设为 $-1$。

这样如果这些点里没有和 $x$ 颜色相同的，我们可以求出一个答案 $t$，如果实际询问的结果和 $t$ 不同我们就可以知道这些点里有和 $x$ 颜色相同的。

将该过程改成二分就可以找到所有和 $x$ 相邻的同色点。

这样因为每找到一个就至少合并一个连通块，因此如果最终连通块数是 $C$ 那么需要的次数就是 $N+(N-C)\log N$。

现在我们划分出了所有极大同色连通块，考虑把每个块缩成一个点，这样形成了一个相邻点的颜色不同的图。

接着考虑链怎么做，枚举颜色 $c$，把所有奇数位置改称 $c$，这样就可以判断偶数位置有没有 $c$，同样的改成二分就可以求出所有为 $c$ 的偶数位置，然后反过来也做一遍就能求出奇数位置。

如果不是链，容易想到选取一个极大独立集都染成 $c$就行了，正确性就是因为每个不在独立集中的点都至少与一个在独立集中的点相连，反过来也成立，同时因为每条边连的点颜色不同，所以可以直接算出来有多少个不同的连通块，如果与返回的结果不符合就说明这些点里有至少一个颜色为 $c$ 的，同样的改成二分就行。

那么这一部分的询问次数是 $C\log N+2N$。

故最后的询问次数为 $N\log N+3N$，可以通过。
```cpp
#include<bits/stdc++.h>
using namespace std;

int perform_experiment(vector<int> E);
int n;
const int N = 255;
vector<int> G[N];
int ans[N],used[N];
void make(int x,int y)
{
    for(int i=0;i<n;i++)
    if(ans[i]==x)ans[i]=y;
}
int fa[N];
int get(int x)
{
    if(x==fa[x])return x;
    return fa[x]=get(fa[x]);
}
int calculate(vector<int> a)
{
    for(int i=0;i<n;i++)fa[i]=i;
    int ret=n;
    for(int i=0;i<n;i++)
    for(int j:G[i])
    if(get(i)!=get(j)&&a[i]==a[j])
    {
        fa[get(i)]=get(j);
        ret--;
    }
    return ret;
}
int ask(vector<int> a)
{
    return perform_experiment(a);
}
int hb[N];
vector<int> E[N];
int idx=0;
vector<int> S[N];
int bel[N];
mt19937_64 rnd(time(0));
vector<int> find_colours(int _n,vector<int> X,vector<int> Y)
{
    n=_n;
    int m=(int)X.size();
    for(int i=0;i<m;i++)
    {
        int u=X[i],v=Y[i];
        G[u].push_back(v);
        G[v].push_back(u);
    }
    vector<int> col;
    col.resize(n);
    for(int i=0;i<n;i++)col[i]=n,ans[i]=-1;
    col[0]=-1;ans[0]=0;
    int cur=0;
    for(int x=1;x<n;x++)
    {
        //cout<<x<<'='<<x<<endl;
        col[x]=-1;
        int t=ask(col);
        ans[x]=++cur;
        vector<int> tmp;
        tmp.resize(n);
        for(int i=0;i<n;i++)
        {
            if(i<=x)tmp[i]=ans[i];
            else tmp[i]=n;
        }
       // cout<<t<<endl;
       // cout<<calculate(tmp)<<endl;
        if(t==calculate(tmp))continue;
        //cout<<x<<endl;
        vector<int> seq;
        for(int i=0;i<n;i++)used[i]=0;
        for(int y:G[x])
        {
            if(y<x&&!used[ans[y]])
            seq.push_back(y),used[ans[y]]=1;
        }
        shuffle(seq.begin(),seq.end(),rnd);
        int p=0;
        bool flag=1;
        //cout<<seq.size()<<endl;
        //for(int u:seq)cout<<':'<<u<<endl;
        auto check = [&](int l,int r)
        {
            vector<int> qry;
            qry.resize(n);
            for(int i=0;i<n;i++)qry[i]=n;
            for(int j=l;j<=r;j++)qry[seq[j]]=ans[seq[j]];
            qry[x]=ans[x];
            int A=calculate(qry);
            for(int i=0;i<n;i++)qry[i]=n;
            for(int j=l;j<=r;j++)qry[seq[j]]=-1;
            qry[x]=-1;
            int B=ask(qry);
            if(A!=B)return 1;
            return 0;
        };
        while(1)
        {
            int l=p,r=(int)seq.size()-1,mid=0,pos=0;
            while(l<=r)
            {
                mid=(l+r)>>1;
                if(check(p,mid)==1)
                {
                    pos=mid;
                    r=mid-1;
                }
                else l=mid+1;
            }
            make(ans[seq[pos]],ans[x]);
            p=pos+1;
            if(p<(int)seq.size()&&check(p,(int)seq.size()-1));
            else break;
        }
    }
    bool flag=1;
    for(int i=1;i<n;i++)if(ans[i]!=ans[0])flag=0;
    vector<int> ret;
    for(int i=0;i<n;i++)ret.push_back(ans[i]);
    if(flag)
    {
        for(int i=1;i<n;i++)ret[i]=-1;
        for(int c=0;c<n;c++)
        {
            ret[0]=c;
            if(ask(ret)==1)
            {
                for(int i=0;i<n;i++)ret[i]=c;
                return ret;
            }
        }
    }
    for(int i=0;i<n;i++)fa[i]=i;
    for(int i=0;i<m;i++)
    {
        int x=X[i],y=Y[i];
        if(ret[x]==ret[y]&&get(x)!=get(y))
        fa[get(y)]=get(x);
    }
    for(int i=0;i<n;i++)if(get(i)==i)bel[i]=idx++;
    for(int i=0;i<n;i++)S[bel[get(i)]].push_back(i);
    for(int i=0;i<m;i++)
    {
        if(get(X[i])!=get(Y[i]))
        {
            int x=bel[get(X[i])];
            int y=bel[get(Y[i])];
            E[x].push_back(y);
            E[y].push_back(x);
        }
    }
    for(int i=0;i<idx;i++)
    {
        hb[i]=1;
        for(int j:E[i])
        if(hb[j]==1)
        {
            hb[i]=0;
            break;
        }
    }
    vector<int> fnl;
    fnl.resize(n);
    for(int i=0;i<n;i++)fnl[i]=-1;
    //cout<<hb[bel[0]]<<endl;
    for(int t=0;t<=1;t++)
    {
        for(int c=0;c<n;c++)
        {
            auto extend = [&](vector<int> ori)
            {
                vector<int> tmp;
                tmp.resize(n);
                for(int i=0;i<idx;i++)
                for(int j:S[i])tmp[j]=ori[i];
                return tmp;
            };
            auto stan = [&](vector<int> test)
            {
                int col=0;
                for(int i=0;i<idx;i++)if(test[i]==1)
                {
                    test[i]=col++;
                }
                else test[i]=n;
                return calculate(extend(test));
            };
            vector<int> seq;
            for(int i=0;i<idx;i++)
            if(hb[i]==1&&fnl[S[i][0]]==-1)seq.push_back(i);
            int p=0;
            shuffle(seq.begin(),seq.end(),rnd);
            auto check = [&](int l,int r)
            {
                vector<int> tes,ins;
                ins.resize(idx);
                tes.resize(idx);
                for(int i=0;i<idx;i++)ins[i]=0;
                for(int i=l;i<=r;i++)ins[seq[i]]=1;
                for(int i=0;i<idx;i++)tes[i]=c;
                for(int i=l;i<=r;i++)tes[seq[i]]=-1;
                return ask(extend(tes))!=stan(ins);
            };
            while(p<(int)seq.size())
            {
                int l=p,r=(int)seq.size()-1;
                if(check(l,r)==0)break;
                int pos=0;
                while(l<=r)
                {
                    int mid=(l+r)>>1;
                    if(check(p,mid)==1)
                    {
                        pos=mid;
                        r=mid-1;
                    }
                    else l=mid+1;
                }
                for(int u:S[seq[pos]])
                fnl[u]=c;
                //cout<<u<<':'<<c<<endl;
                p=pos+1;
            }
        }
        for(int i=0;i<idx;i++)hb[i]^=1;
    }
    return fnl;
}

```

---

## 作者：Petit_Souris (赞：2)

其实思路挺自然的，好像自己已经想出大半了。但是感觉 IOI 5h 不够用啊。

首先考虑获得 50 分。很容易想到增量式构造，一个一个确定点的颜色。

先找到一个点的排列，使得每个点都和前面的至少一个点连边。接下来去看 $i$ 和前面哪些点颜色相同，可以考虑二分，二分一个前缀，只保留这些点以及 $i$ 的颜色，剩下全部染成 $N$。这样如果颜色互不相同，正确的连通块数量应当是唯一的，可以直接判断。二分到一个之后再找下一段。

直接做是 $N\log N$ 次询问，不过可以在开始前判断一次，这样是 $(N-C)\log N + N$ 次。

接下来考虑 100 分。我们可以在前一部分的基础上构造。先把所有相邻同色点缩起来，现在认为相邻点颜色不同。

如果只剩下一个点，那么这个点的颜色容易 $N$ 次问出，是平凡的。

否则，我们考虑找到原图的一个极大独立集 $S$。这样 $S$ 中每个点至少和一个 $U-S$ 中的点连边，反之同理。

这样我们可以枚举颜色 $c$ 并找到所有颜色为 $c$ 的点。考虑把所有 $S$ 中的点染成 $c$，这样就可以判断 $U-S$ 中是否有颜色为 $c$ 了。同理做一遍二分，然后交换 $S, U-S$ 再做一遍。

次数为 $C\log N + 2N$，因此总次数 $N\log N + 3N$，可以通过。

```cpp
#include "sphinx.h"
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<ll, ll>
#define rep(i, a, b) for(ll i = (a); i <= (b); ++i)
#define per(i, a, b) for(ll i = (a); i >= (b); --i)
#define pb push_back
const int maxN = 259;
Ve<int> to[maxN], ord;
int _N, _M, dfn[maxN], bin[maxN], Z;
void dfs(int x) {
    dfn[x] = ord.size(), ord.pb(x);
    for(int y : to[x]) {
        if(~dfn[y]) continue;
        dfs(y);
    }
}
int calc(Ve<int> X) {
    Ve<int> vec(_N, _N);
    for(int x : X) vec[x] = -1;
    return perform_experiment(vec);
}
bool used[maxN], vis[maxN];
void dfs2(int x) {
    vis[x] = 1;
    for(int y : to[x]) {
        if(!vis[y] && !used[y]) dfs2(y);
    }
}
void dfs4(int x) {
    vis[x] = 1;
    for(int y : to[x]) {
        if(!vis[y] && used[y]) dfs4(y);
    }
}
Ve<int> tvec[maxN], es[maxN];
int col[maxN];
Ve<int> find_colours(int N, Ve<int> X, Ve<int> Y) {
    _N = N, _M = X.size();
    Ve<int> ans(N, -1), rans(N, -1);
    rep(i, 0, _M - 1) to[X[i]].pb(Y[i]), to[Y[i]].pb(X[i]);
    memset(dfn, -1, sizeof(dfn));
    dfs(0);
    assert((int)ord.size() == N);
    rep(i, 0, N - 1) {
        int u = ord[i];
        Ve<int> go;
        memset(bin, 0, sizeof(bin));
        for(int v : to[u]) {
            if(dfn[v] < i && !bin[ans[v]]) go.pb(v), bin[ans[v]] = 1;
        }
        ans[u] = i;
        if(go.empty()) continue;
        int lst = -1;
        while(lst < (int)go.size() - 1) {
            int l = lst + 1, r = (int)go.size() - 1, pos = go.size();
            Ve<int> pt;
            memset(used, 0, sizeof(used));
            memset(vis, 0, sizeof(vis));
            rep(j, lst + 1, r) pt.pb(go[j]), used[go[j]] = 1;
            pt.pb(u), used[u] = 1;
            int ret = calc(pt), _G = 0;
            rep(j, 0, N - 1) {
                if(!used[j] && !vis[j]) ++_G, dfs2(j);
            }
            ret -= _G;
            if(ret == r - lst + 1) break;
            while(l <= r) {
                int mid = (l + r) >> 1;
                Ve<int> pt;
                memset(used, 0, sizeof(used));
                memset(vis, 0, sizeof(vis));
                rep(j, lst + 1, mid) pt.pb(go[j]), used[go[j]] = 1;
                pt.pb(u), used[u] = 1;
                int ret = calc(pt);
                _G = 0;
                rep(j, 0, N - 1) {
                    if(!used[j] && !vis[j]) ++_G, dfs2(j);
                }
                ret -= _G;
                if(ret == mid - lst + 1) l = mid + 1;
                else pos = mid, r = mid - 1;
            }
            Ve<int> vec;
            rep(j, 0, i - 1) {
                if(ans[ord[j]] == ans[go[pos]]) vec.pb(ord[j]);
            }
            for(int x : vec) ans[x] = i;
            lst = pos;
        }
    }
    Ve<int> tmp;
    rep(i, 0, N - 1) tmp.pb(ans[i]);
    sort(tmp.begin(), tmp.end());
    tmp.resize(unique(tmp.begin(), tmp.end()) - tmp.begin());
    Z = tmp.size();
    rep(i, 0, N - 1) ans[i] = lower_bound(tmp.begin(), tmp.end(), ans[i]) - tmp.begin();
    if(Z == 1) {
        rep(i, 0, N - 1) {
            Ve<int> ask(N, -1);
            ask[0] = i;
            if(perform_experiment(ask) == 1) {
                rep(j, 0, N - 1) rans[j] = i;
                return rans;
            }
        }
        assert(0);
    }
    rep(i, 0, N - 1) tvec[ans[i]].pb(i);
    rep(i, 0, _M - 1) {
        if(ans[X[i]] == ans[Y[i]]) continue;
        es[ans[X[i]]].pb(ans[Y[i]]), es[ans[Y[i]]].pb(ans[X[i]]);
    }
    memset(col, 0, sizeof(col));
    rep(i, 0, Z - 1) {
        bool flag = 1;
        for(int j : es[i]) {
            if(col[j]) flag = 0;
        }
        if(flag) col[i] = 1;
    }
    Ve<int> vp[2], ers[2];
    rep(i, 0, Z - 1) vp[col[i]].pb(i);
    rep(i, 0, N - 1) {
        rep(O, 0, 1) {
            Ve<int> era;
            int lst = -1;
            while(lst < (int)vp[O].size() - 1) {
                Ve<int> ask(N, -1);
                memset(used, 0, sizeof(used));
                memset(vis, 0, sizeof(vis));
                for(int j : vp[!O]) {
                    for(int x : tvec[j]) ask[x] = i, used[x] = 1;
                }
                for(int j : ers[!O]) {
                    for(int x : tvec[j]) ask[x] = i, used[x] = 1;
                }
                rep(j, 0, lst) {
                    for(int x : tvec[vp[O][j]]) ask[x] = N;
                }
                for(int j : ers[O]) {
                    for(int x : tvec[j]) ask[x] = N;
                }
                int G = perform_experiment(ask), _G = (int)vp[O].size() - lst - 1;
                rep(j, 0, N - 1) {
                    if(used[j] && !vis[j]) ++_G, dfs4(j);
                }
                memset(used, 0, sizeof(used));
                rep(j, 0, lst) {
                    for(int x : tvec[vp[O][j]]) used[x] = 1;
                }
                for(int j : ers[O]) {
                    for(int x : tvec[j]) used[x] = 1;
                }
                rep(j, 0, N - 1) {
                    if(used[j] && !vis[j]) ++_G, dfs4(j);
                }
                if(G == _G) break;
                int l = lst + 1, r = (int)vp[O].size() - 1, pos = (int)vp[O].size();
                while(l <= r) {
                    int mid = (l + r) >> 1;
                    Ve<int> ask(N, -1);
                    memset(used, 0, sizeof(used));
                    memset(vis, 0, sizeof(vis));
                    for(int j : vp[!O]) {
                        for(int x : tvec[j]) ask[x] = i, used[x] = 1;
                    }
                    for(int j : ers[!O]) {
                        for(int x : tvec[j]) ask[x] = i, used[x] = 1;
                    }
                    rep(j, 0, lst) {
                        for(int x : tvec[vp[O][j]]) ask[x] = N;
                    }
                    rep(j, mid + 1, (int)vp[O].size() - 1) {
                        for(int x : tvec[vp[O][j]]) ask[x] = N;
                    }
                    for(int j : ers[O]) {
                        for(int x : tvec[j]) ask[x] = N;
                    }
                    int G = perform_experiment(ask), _G = mid - lst;
                    rep(j, 0, N - 1) {
                        if(used[j] && !vis[j]) ++_G, dfs4(j);
                    }
                    memset(used, 0, sizeof(used));
                    rep(j, 0, lst) {
                        for(int x : tvec[vp[O][j]]) used[x] = 1;
                    }
                    rep(j, mid + 1, (int)vp[O].size() - 1) {
                        for(int x : tvec[vp[O][j]]) used[x] = 1;
                    }
                    for(int j : ers[O]) {
                        for(int x : tvec[j]) used[x] = 1;
                    }
                    rep(j, 0, N - 1) {
                        if(used[j] && !vis[j]) ++_G, dfs4(j);
                    }
                    if(G != _G) pos = mid, r = mid - 1;
                    else l = mid + 1;
                }
                for(int x : tvec[vp[O][pos]]) rans[x] = i;
                era.pb(vp[O][pos]);
                lst = pos;
            }
            for(int x : era) vp[O].erase(find(vp[O].begin(), vp[O].end(), x)), ers[O].pb(x);
        }
    }
    return rans;
}
```

---

## 作者：PTqwq (赞：0)

自己做只会 $47.5$，感觉这题正解没有消息篡改者难但还是没有想到。

与正解无关的部分分做法在此就不赘述了。

首先考虑 $50\%$ 怎么做，考虑一个增量构造的方法，如果我们已经确定的 $1 \sim u$ 的导出子图的颜色相等关系，那么考虑加入点 $u + 1$，可以考虑二分出 $1 \sim u$ 中第一个和 $u + 1$ 有连边并且颜色相等的点（这个的原理是如果没有点和 $u + 1$ 有边相连且颜色相等那么强制 $u + 1$ 形成一个 单色分支，这样以来返回值就会达到最大，每次只需要判断一下 单色分支 的数量是否符合我们的预期即可，可以区分两种情况，而剩下我们不想考虑的点直接染成 $N$ 即可），如果没有二分出来，那么 $1 \sim u + 1$ 已经构造完毕，否则我们就让 $u + 1$ 和二分出的点 $v$ 连边（形成一个连通块），然后继续二分。**注意每次二分前要判断一下全局是否有点满足条件，如果没有，就不用二分浪费 $\log N$ 次询问了！**

设最终连出了 $x$ 个连通块，那么精确的询问次数就是 $(N - x) \log N + N$ 的，接下来我们考虑怎么确定每个连通块的颜色。

这里我们考虑建出一棵连通块缩点后的生成树，将其黑白染色，容易发现黑点之间和白点之间如果有连边那么不可能有颜色相等的情况，所以我们排除了颜色之间的干扰，接下来我们要确定白点之间所有颜色为 $c$ 的点，可以考虑将黑点全部染成 $c$，这样每个白点一定和一个颜色为 $c$ 的黑点相连（这就是为什么要用生成树的结构！），然后二分出还没有确定颜色的白点中编号最小的且颜色为 $c$ 的白点，这个判定可以用 $50$ 分的做法的思想来做。

注意 $x = 1$ 要特判。

分析一下次数：因为对于黑白点都要做一遍，并且每种颜色也有一次总的判定所以次数是 $x \log N + 2N$ 的，总次数是 $N \log N + 3N \approx 2750$，可以通过。

```cpp
#include "sphinx.h"
#include <bits/stdc++.h>

using namespace std;

int perform_experiment(vector<int> E);

vector<int> find_colours(int N, vector<int> X, vector<int> Y) {
    vector<pair<int, int>> st;
    int M = X.size();
    for (int i = 0; i < M; ++ i) st.push_back(make_pair(X[i], Y[i]));
    
    vector<int> dsu(N);
    iota(dsu.begin(), dsu.end(), 0);
    auto findFa = [&](auto&& self, int u) -> int {
        if (dsu[u] == u) {
            return u;
        } else {
            dsu[u] = self(self, dsu[u]);
            return dsu[u];
        }
    };
    auto LinkEdge = [&](int u, int v) -> void {
        u = findFa(findFa, u);
        v = findFa(findFa, v);
        if (u != v) {
            dsu[u] = v;
        }
    };

    vector<int> dsu2(N);
    iota(dsu2.begin(), dsu2.end(), 0);
    auto findFa2 = [&](auto&& self, int u) -> int {
        if (dsu2[u] == u) {
            return u;
        } else {
            dsu2[u] = self(self, dsu2[u]);
            return dsu2[u];
        }
    };
    auto LinkEdge2 = [&](int u, int v) -> void {
        u = findFa2(findFa2, u);
        v = findFa2(findFa2, v);
        if (u != v) {
            dsu2[u] = v;
        }
    };

    auto query = [&](vector<int> ord) -> int {
        iota(dsu2.begin(), dsu2.end(), 0);
        for (auto [U, V] : st) {
            if (ord[U] == ord[V]) {
                LinkEdge2(U, V);
            }
        }
        int cnt = 0;
        for (int i = 0; i < N; ++ i) {
            if (findFa2(findFa2, i) == i) {
                cnt ++;
            }
        }
        return cnt;
    };

    vector<int> ans(N);
    iota(dsu.begin(), dsu.end(), 0);
    int tot = 0;
    for (int i = 0; i < N; ++ i) {
        vector<int> que(N);
        int upp = 0;
        while (upp < i) {
            vector<int> vc;
            for (int j = upp; j < i; ++ j) {
                if (findFa(findFa, j) != findFa(findFa, i)) {
                    vc.push_back(j);
                }
            }
            if (vc.empty()) break;
            int L = 0, R = int(vc.size()) - 1, pos = i;
            tot ++;
            vector<int> ans2(N);
            for (int j = 0; j < N; ++ j) {
                if (findFa(findFa, j) == findFa(findFa, i) || (upp <= j && j <= vc[R])) {
                    que[j] = -1;
                    ans2[j] = (findFa(findFa, j) == findFa(findFa, i) ? N : findFa(findFa, j));
                } else {
                    que[j] = N;
                    ans2[j] = -1;
                }
            }
            if (perform_experiment(que) == query(ans2)) {
                break;
            }
            while (L <= R) {
                int mid = (L + R) / 2;
                for (int j = 0; j < N; ++ j) {
                    if (findFa(findFa, j) == findFa(findFa, i) || (upp <= j && j <= vc[mid])) {
                        que[j] = -1;
                        ans2[j] = (findFa(findFa, j) == findFa(findFa, i) ? N : findFa(findFa, j));
                    } else {
                        que[j] = N;
                        ans2[j] = -1;
                    }
                }
                if (perform_experiment(que) != query(ans2)) {
                    pos = vc[mid];
                    R = mid - 1;
                } else {
                    L = mid + 1;
                }
            }
            if (pos == i) break;
            LinkEdge(i, pos);
            upp = pos + 1;
        }
    }

    bool only = true;
    for (int i = 1; i < N; ++ i) {
        only &= (findFa(findFa, 0) == findFa(findFa, i));
    }
    if (only) {
        int ansC = -1;
        for (int C = 0; C < N; ++ C) {
            vector<int> que(N);
            que[0] = -1;
            for (int x = 1; x < N; ++ x) {
                que[x] = C;
            }
            if (perform_experiment(que) == 1) {
                ansC = C;
                break;
            }
        }
        for (auto& x : ans) x = ansC;

        return ans;
    }

    vector<int> mp(N);
    vector<int> bipartite(N);
    for (auto& x : mp) x = -1;
    for (auto& x : bipartite) x = -1;
    vector<vector<int>> vertex(N);
    for (auto& x : vertex) x.clear();
    for (int i = 0; i < N; ++ i) vertex[findFa(findFa, i)].push_back(i);
    iota(dsu2.begin(), dsu2.end(), 0);
    for (auto [U, V] : st) {
        int X_ = findFa(findFa, U);
        int Y_ = findFa(findFa, V);
        if (findFa2(findFa2, X_) != findFa2(findFa2, Y_)) {
            if (bipartite[X_] == -1 && bipartite[Y_] == -1) {
                bipartite[X_] = 0;
                bipartite[Y_] = 1;
            } else if (bipartite[X_] == -1) {
                bipartite[X_] = 1 - bipartite[Y_];
            } else if (bipartite[Y_] == -1) {
                bipartite[Y_] = 1 - bipartite[X_];
            } else if (bipartite[X_] == bipartite[Y_]) {
                for (int i = 0; i < N; ++ i) {
                    if (findFa2(findFa2, i) == findFa2(findFa2, X_)) {
                        bipartite[i] ^= 1;
                    }
                }
            }
            LinkEdge2(X_, Y_);
        }
    }

    for (int curX = 0; curX < 2; ++ curX) {
        for (int C = 0; C < N; ++ C) {
            vector<int> que(N);
            vector<int> ans2(N);
            for (auto& x : ans2) x = -1;
            for (auto& x : que) x = -1;
            vector<int> vc, vc2;
            for (int i = 0; i < N; ++ i) {
                if (bipartite[i] == 1 - curX) {
                    for (auto u : vertex[i]) {
                        que[u] = C;
                    }
                } else if (bipartite[i] == curX) {
                    if (!vertex[i].empty()) {
                        if (mp[vertex[i][0]] == -1) {
                            vc.push_back(i);
                        } else {
                            vc2.push_back(i);
                        }
                    }
                }
            }
            if (!vc.empty()) {
                sort(vc.begin(), vc.end());

                int upp = 0;
                while (upp < int(vc.size())) {
                    auto check = [&](int x) -> bool {
                        for (int i = 0; i < int(vc.size()); ++ i) {
                            if (upp <= i && i <= x) {
                                for (auto u : vertex[vc[i]]) {
                                    que[u] = -1;
                                    ans2[u] = findFa(findFa, u);
                                }
                            } else {
                                for (auto u : vertex[vc[i]]) {
                                    que[u] = N;
                                    ans2[u] = N;
                                }
                            }
                        }
                        for (auto x : vc2) {
                            for (auto u : vertex[x]) {
                                que[u] = N;
                                ans2[u] = N;
                            }
                        }
                        if (perform_experiment(que) != query(ans2)) {
                            return true;
                        } else {
                            return false;
                        }
                    };

                    int L = upp, R = int(vc.size()) - 1, pos = int(vc.size());
                    if (!check(R)) break;
                    while (L <= R) {
                        int mid = (L + R) / 2;
                        if (check(mid)) {
                            pos = mid;
                            R = mid - 1;
                        } else {
                            L = mid + 1;
                        }
                    }
                    for (auto u : vertex[vc[pos]]) {
                        mp[findFa(findFa, u)] = C;
                    }
                    upp = pos + 1;
                }
            }
        }
    }

    for (int i = 0; i < N; ++ i) {
        ans[i] = mp[findFa(findFa, i)];
    }

    return ans;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P11054)

**题目大意**

> 给定一张 $n$ 个点 $m$ 条边的无向图，交互器中每个点有一个 $[0,n)$ 的颜色。
>
> 每次交互时，你可以把若干个点染成 $[0,n]$ 中的任意颜色，交互器会告诉你新图中的同色连通块数量。
>
> 请在 $2750$ 次交互之内确定每个点的颜色。
>
> 数据范围：$n\le 250$。

**思路分析**

先从链入手。

将所有奇数下标的点全部染成某种颜色 $c$，如果此时得到的连通块数 $<n$，说明下标为偶数的点中有颜色为 $c$ 的，否则说明没有。

以此为依据二分，可以求出每个颜色为 $c$ 的点，对每种颜色进行此过程即可还原下标为偶数的点，对于下标为奇数的点也做一遍即可求解，操作次数 $2n+n\log n$。

然后考虑推广，我们可以对链上所有下标为计数的点一次性检验，那么在图上我们可以对一个独立集状物一次性检验。

具体来说，选定一个独立集 $S$，将 $\overline S$ 中的点染成 $c$，如果返回值小于 $|S|$ 加上 $\overline{S}$ 导出子图的连通块数，那么说明 $S$ 中存在颜色 $c$，可以 $n+|S|\log n$ 还原。

考虑进一步优化，观察我们用到了独立集的什么性质。

首先要求 $S$ 内部的连通块数量为 $S$，也即 $S$ 中没有同色点相连，那么我们可以将同色且相邻的点缩成一个连通块。

其次要求每个 $S$ 中的点都至少和一个 $\overline S$ 中的点相连，这样才能在一个点颜色为 $c$ 的时候减少连通块数量。

这是容易的，取出一棵生成树并黑白染色得到两个集合分别作为 $S$ 求解即可。

最终我们只要求出每个同色连通块即可，也就是本题 $50\%$ 分数的子任务。

这个不难，考虑增量法构造，依次加入每个点 $u$ 并求出已加入的点中哪些与其同色。

将 $u$ 的邻域和 $u$ 自己保留原先颜色，其他点染颜色 $n$，设保留原颜色的点集是 $V$ 那么 $u$ 的邻域中有与 $u$ 同色的点当且仅当实际同色连通块数小于 $|V|$ 加 $\overline V$ 导出子图中的连通块数量。

注意到每次二分实际上都减少了一个点（和其他点并成同色连通块，或确定一个连通块的颜色），那么我们在 $3n+n\log n$ 次询问内解决了此问题。

实际上由于元素数的不断减少，询问次数不超过 $3n+\sum_{i=1}^n\log_2i$，可以通过。

注意特判全部点颜色相同的 Corner Case。

时间复杂度 $\mathcal O(n^2\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
int perform_experiment(vector<int>E);
const int MAXN=255;
vector <int> G[MAXN],E[MAXN],R[MAXN];
int n;
struct DSU {
	int dsu[MAXN];
	void init() { iota(dsu,dsu+n,0); }
	int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
	bool merge(int x,int y) {
		x=find(x),y=find(y),dsu[x]=y;
		return x^y;
	}
}	F,T;
int count(const vector<int>&V) {
	static bitset<MAXN> inq;
	inq.reset(),T.init();
	for(int i:V) inq.set(i);
	int s=V.size();
	for(int i:V) for(int j:G[i]) if(inq[j]) s-=T.merge(i,j);
	return s;
}
int col[MAXN];
void solve(vector<int> S) {
	for(int c=0;c<n;++c) {
		vector <int> X;
		while(S.size()) {
			auto chk=[&](int k) {
				vector <int> q(n,c),r;
				for(int i=0;i<=k;++i) for(int u:R[S[i]]) q[u]=-1;
				for(int i=0;i<n;++i) if(~q[i]) r.push_back(i);
				int z=perform_experiment(q);
				return z<count(r)+k+1;
			};
			int l=0,r=S.size()-2,x=S.size()-1;
			if(!chk(x)) {
				X.insert(X.end(),S.begin(),S.end());
				break;
			}
			while(l<=r) {
				int mid=(l+r)>>1;
				if(chk(mid)) x=mid,r=mid-1;
				else l=mid+1;
			}
			col[S[x]]=c;
			X.insert(X.end(),S.begin(),S.begin()+x);
			S.erase(S.begin(),S.begin()+x+1);
		}
		S.swap(X);
	}
}
vector<int> find_colours(int N,vector<int>X,vector<int>Y) {
	n=N,F.init();
	for(int i=0;i<(int)X.size();++i) G[X[i]].push_back(Y[i]),G[Y[i]].push_back(X[i]);
	for(int u=0;u<n;++u) {
		static bitset <MAXN> vis;
		vis.reset();
		vector <int> Ne,C;
		for(int v:G[u]) if(v<u&&!vis[F.find(v)]) {
			Ne.push_back(F.find(v)),vis.set(F.find(v));
		}
		while(Ne.size()) {
			auto chk=[&](int k) { //qry Ne[0,k]
				vector <int> q(n,n),r;
				vis.reset(),q[u]=-1;
				for(int i=0;i<=k;++i) vis.set(Ne[i]);
				for(int i=0;i<u;++i) if(vis[F.find(i)]) q[i]=-1;
				for(int i=0;i<n;++i) if(~q[i]) r.push_back(i);
				int z=perform_experiment(q);
				return count(r)+k+2>z;
			};
			int l=0,r=Ne.size()-2,x=Ne.size()-1;
			if(!chk(x)) break;
			while(l<=r) {
				int mid=(l+r)>>1;
				if(chk(mid)) x=mid,r=mid-1;
				else l=mid+1;
			}
			C.push_back(Ne[x]);
			Ne.erase(Ne.begin(),Ne.begin()+x+1);
		}
		for(int v:C) F.merge(u,v);
	}
	vector <int> bl(n);
	for(int i=0;i<n;++i) R[bl[i]=F.find(i)].push_back(i);
	F.init();
	for(int i=0;i<n;++i) for(int j:G[i]) if(F.merge(bl[i],bl[j])) {
		E[bl[i]].push_back(bl[j]),E[bl[j]].push_back(bl[i]);
	}
	vector <int> S[2];
	function<void(int,int,int)> dfs=[&](int u,int fz,int c) {
		S[c].push_back(u);
		for(int v:E[u]) if(v^fz) dfs(v,u,c^1);
	};
	dfs(bl[0],-1,0);
	if(S[1].empty()) {
		vector <int> q(n,-1);
		for(q[0]=0;q[0]<n;++q[0]) if(perform_experiment(q)==1) {
			return vector<int>(n,q[0]);
		}
	}
	solve(S[0]),solve(S[1]);
	vector <int> cols(n);
	for(int i=0;i<n;++i) cols[i]=col[bl[i]];
	return cols;
}
```

---


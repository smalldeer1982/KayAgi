# [IOI 2025] 恐龙大迁徙（migrations）

## 题目描述

自然历史博物馆正在研究玻利维亚恐龙的迁徙模式。古生物学家在 $N$ 个不同的遗址中发现了恐龙脚印化石，按年代由远及近的顺序从 $0$ 到 $N - 1$ 编号：遗址 $0$ 包含年代最远的脚印化石，遗址 $N - 1$ 包含年代最近的脚印化石。

对于每个遗址（除遗址 $0$ 之外），恐龙会从某个特定的、年代更远的遗址迁徙过来。对每个满足 $1 \leq i \leq N - 1$ 的遗址 $i$，存在恰好一个年代更远的遗址 $P[i]$（$P[i] < i$）使得一些恐龙直接从遗址 $P[i]$ 迁徙到遗址 $i$。
一个年代更远的遗址可能是多个年代更近的遗址的迁徙源头。

古生物学家将每一次迁徙建模为遗址 $i$ 和 $P[i]$ 之间的**无向连接**。注意，对任意两个不同的遗址 $x$ 和 $y$，都可以从 $x$ 沿一系列连接到达 $y$。遗址 $x$ 和 $y$ 之间的**距离**定义为从 $x$ 到 $y$ 所需的最少连接数。

下图展示了一个遗址数目 $N=5$ 的例子，其中 $P[1]=0$、$P[2]=1$、$P[3]=2$、以及 $P[4]=2$。例如，遗址 $3$ 可以通过 $2$ 个连接到达遗址 $4$，因此它们之间的距离为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/g4mdke4x.png)

博物馆的目标是确定具有最大可能距离的一对遗址。

注意，这样的一对遗址未必唯一：例如，在上述例子中，两对遗址 $(0,3)$ 和 $(0,4)$ 都具有最大距离 $3$。在这样的情况下，任何一对具有最大距离的遗址都被视为有效。

最初，$P[i]$ 的值是**未知**的。博物馆派出一支研究团队按顺序访问遗址 $1, 2, \ldots, N-1$。在到达每个遗址 $i$（$1 \leq i \leq N-1$）时，研究团队执行以下两个操作：
* 确定 $P[i]$ 的值，即遗址 $i$ 的迁徙来源。
* 根据此前收集的信息决定是否在该遗址发送**一条**消息给博物馆。

消息通过昂贵的卫星通信系统进行传输，每条消息必须是一个 $1$ 到 $20\,000$ 之间的整数。
此外，研究团队最多只能发送 **$50$ 条消息**。

你的任务是实现一个策略包含：
* 研究团队选择消息发送的遗址和每条消息的值。
* 博物馆仅根据从各遗址收到的消息以及这些消息是从哪些遗址发送的来确定一对距离最远的遗址。

通过卫星发送大的数值的成本很高。你的得分取决于发送的最大数值以及传输的消息总数。

### 实现细节

你需要实现两个函数；一个给研究团队，另一个给博物馆。

你需要为**研究团队**实现的函数是：
```
int send_message(int N, int i, int Pi)
```

* $N$: 遗址的数量。
* $i$: 团队当前所在的遗址编号。
* $Pi$: $P[i]$ 的值。
*  对每个测试用例，该函数按照 $i = 1, 2, ... , N-1$ 的顺序被调用 $N-1$ 次。

该函数应返回 $S[i]$，表示研究团队在遗址 $i$ 执行的操作：
* $S[i] = 0$: 研究团队决定不从遗址 $i$ 发送消息。
* $1 \leq S[i] \leq 20\,000$: 研究团队从遗址 $i$ 发送消息 $S[i]$。

你需要为**博物馆**实现的函数是：
```
std::pair<int,int> longest_path(std::vector<int> S)
```

* $S$: 长度为 $N$ 的数组，满足：
    * $S[0] = 0$。
    * 对每个满足 $1 \leq i \leq N-1$ 的 $i$，都有 $S[i]$ 是 `send_message(N, i, Pi)` 的返回值。
* 对每个测试用例，该函数恰好被调用一次。

该函数应返回一对距离最大的遗址 $(U, V)$。 

在实际评测中，调用以上函数的程序将**恰好**运行**两次**。
* 在程序第一次运行过程中：
    * `send_message` 将恰好被调用 $N - 1$ 次.
    * **你的程序可以在连续调用中存储和保留信息。**
    * 返回值（数组$S$）将被保存在评测系统中。
    * 在一些情况下，评测程序的行为是**适应性的**。这意味着在 `send_message` 的调用中 $P[i]$ 的值可能取决于研究团队在此前调用中执行的操作。 
* 在程序第二次运行过程中：
    * `longest_path` 将会恰好被调用一次。在第一次运行中仅有的对 `longest_path` 可用的信息是数组 $S$。

## 说明/提示

### 例子

设 $N = 10\,000$。考虑 $P[1] = 0$, $P[2] = 1$, $P[3] = 2$, $P[4] = 2$ 以及对于 $i > 4$ 的所有 $i$，有 $P[i] = 1$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0636ikup.png)

假设研究团队的策略是当遗址 $(U, V)$ 之间的距离变为最大距离时发送消息 $10 \cdot V + U$，作为调用 `send_message` 的结果。

初始时，拥有最大距离的遗址 $(U, V) = (0, 0)$。
考虑以下在程序第一次运行时的函数调用：

| 函数调用              | $(U, V)$ | 返回值（$S[i]$） |
|:----------------------------|:--------:|:------------:|
| `send_message(10000, 1, 0)` | $(0,1)$  | $10$ |
| `send_message(10000, 2, 1)` | $(0,2)$  | $20$ |
| `send_message(10000, 3, 2)` | $(0,3)$  | $30$ |
| `send_message(10000, 4, 2)` | $(0,3)$  | $0$  |

注意，在剩余的调用中 $P[i]$ 的值是 $1$。这意味着遗址之间的最大距离不会再发生改变，因此团队也就不会再发送任何消息。

然后在程序第二次运行时，将会产生以下调用：
```
longest_path([0, 10, 20, 30, 0, ...])
```

博物馆读取研究团队发送的最后一条消息 $S[3] = 30$，由此推导出 $(0, 3)$ 是拥有最大距离的一对遗址。因此该函数调用返回 $(0, 3)$。

注意，这种方法并不能保证博物馆总能正确找到距离最大的那对遗址。

### 约束条件

* $N = 10\,000$
* 对每个满足 $1 \leq i \leq N-1$ 的 $i$，都有 $0 \leq P[i] < i$。

### 子任务与评分规则

| 子任务 | 得分 | 额外的约束条件     |
|:-------:|:-----:| -------------------------- |
| 1       | $30$  | 遗址 $0$ 和另外某个遗址在所有遗址之间的距离最大。 |
| 2       | $70$  |没有额外的约束条件。 |

设 $Z$ 为数组 $S$ 中出现的最大值，$M$ 为研究团队所发送的消息数量。

在任一测试用例中，如果发生以下至少一种情况，则你在该测试用例的解答将获得 $0$ 分（在 CMS 中报告为 `Output isn't correct`）：
* 至少一个 $S$ 中的元素不合法。
* $Z > 20\,000$ 或 $M > 50$。
* `longest_path` 函数调用的返回值不正确。

除此之外，对于子任务 1，你的得分将按以下规则计算：

|            范围         | 得分  |
|:----------------------------:|:------:|
| $9\,998 \leq Z \leq 20\,000$ | $10$   |
| $102 \leq Z \leq 9 997$      | $16$   |
| $5 \leq Z \leq 101$          | $23$   |
| $Z \leq 4$                   | $30$   |

对于子任务 2，你的得分将按以下规则计算：

| 范围                          | 得分                                         |
|:----------------------------------:|:---------------------------------------------:|
| $5 \leq Z \leq 20\,000$  且 $M \leq 50$ | $35 - 25 \log_{4000}\left(\frac{Z}{5}\right)$ |
| $Z \leq 4$ 且 $32 \leq M \leq 50$ | $40$                                          |
| $Z \leq 4$ 且 $9 \leq M \leq 31$        | $70 - 30 \log_{4}\left(\frac{M}{8}\right)$    |
| $Z \leq 4$ 且 $M \leq 8$          | $70$                                          |

# 题解

## 作者：stardust_Ray (赞：5)

这里讲述一下个人想出来的部分分和从 QOJ 提交中学到的正解做法。

## $30$ 分做法

如果不需要在线的返回，最暴力的就是拆成 $5$ 进制返回。

如果是在线的，考虑最后 $\log n$ 个点，如果它替换掉了答案那么返回一个特殊值（这里取 $4$），然后对于不是的情况我们就返回原来的答案的 $4$ 进制即可。

## $65$ 分做法

考虑如果原来树的直径是 $(u, v)$ 新加入一个点 $i$ 之后直径只有 $3$ 种可能性 $(u, i), (v, i), (u, v)$。那么我们考虑在最后 $2\log n$ 个点返回，每个点需要返回的值有这个点发生了那种变化和原来的 $u$ 或者 $v$ 的二进制表示，也就是返回值有 $2\times3 = 6$ 种可能性，做到 $Z \le 5$。

## $86.4$ 分做法

我们还是考虑我们需要返回 $u, v$ 的变化，但是对于相邻 $4$ 个对于 $u$ 的变化只有 $5$ 种可能性，对于 $v$ 的变化只有 $5$ 种可能性，也就是我们只需要 $2$ 位（？）来传递变化的情况，剩下两位可以用来传递信息。更加具体地，我们令这样的连续 $4$ 个值 $(a, b, c, d)$ 是一块，其中 $a$ 来传递 $u$ 在 $5$ 进制下的表示，$b$ 来传递 $v$ 在 $5$ 进制下的表示，$c$ 来传递这个块前三位和前一个块第四位对 $u$ 的修改，$d$ 来传递这个块 $4$ 个位对 $v$ 的修改。然后我们发现最后一个块的第四位如果修改了 $u$ 那么无法记录，需要再拿出一个点特判，此时最后一个点的情况有：

1. 不变。
2. 前一个点改 $u$，这个点改 $v$。
3. 前一个点改 $u$。
4. 这个点改 $u$。
5. 这个点改 $v$。

然后我们发现只有 $5$ 种情况，于是可以正常返回。前面由于是 $5$ 进制只有 $6$ 个块，当前一个块的 $c$ 有值的时候之后的块都不需要 $a$ 了，于是事实上总共只有 $2 \times 7 + 1 = 15$ 个位置有值。

## $100$ 分做法

这个我肯定是不会做的，是看 QOJ 上大神的代码看来的。

我们考虑维护当前的 $u$ 的可行集合 $A$ 和 $v$ 的可行集合 $B$，然后考虑用连续的 $x$ 个位置中放入 $1$ 个返回位置来把 $A$ 的大小和 $B$ 的大小除掉 $\sqrt{4x + 1}$，再加上 $x$。这个是因为我们这样放置总共有 $4x + 1$ 种放置方案，需要对应把 $A$ 平均切成 $t$ 块和 $B$ 的切块后 $u$ 和 $v$ 所属的块的标号，这个很显然是有 $t^2$ 种的，所以我们可以除掉 $\sqrt{4x + 1}$，但是这 $x$ 个还都会放进 $A$ 和 $B$ 里，所以要加上 $x$。但是对于第一次我们可以钦定 $u$ 和 $v$ 的大小关系，方案就只有 $\frac{t(t + 1)}2$ 种，可以除得更多。

这样的话我们发现，假如每次的 $x$ 分别等于 $\{140, 20, 6, 2, 2\}$，那么每次就可以除掉 $\{33, 9, 5, 3, 3\}$，这个是因为：

- $\frac{33 \times 34}2 = 561 = 140 \times 4 + 1$。
- $9^2 = 81 = 20 \times 4 + 1$。
- $5^2 = 25 = 6 \times 4 + 1$。
- $3^2 = 2 \times 4 + 1$。

然后经过这样的减少我们可以发现对于初始的前 $9830$ 个左右，到最后我们 $A$ 和 $B$ 的大小只有 $5$。

我们考虑用最后 $O(1)$ 位来处理这个东西，由于 $M \le 8$ 所以我们尽可能只用 $3$ 位。也就是最开始的大小是 $9827$ 然后到 $9996$ 结束之后 $A$ 和 $B$ 的大小是 $5$？但显然地，在处理每一次划分的时候我们可以先把这个段（这里的段的意思是上文的连续的 $x$ 个位置）的开头也扔进 $A$ 和 $B$ 中一起做除法，这样算出来到 $9996$ 结束的时候 $A$ 和 $B$ 的大小上限是 $4$。

然后考虑最后 $3$ 个怎么单独处理。

对于 $i = 9997$，接收到的是相当于是一张 $4 \times 4$ 的二分图，然后还有一个特殊点连接这张二分图上的所有点，总共 $24$ 条边，我们按照左部，右部，特殊的顺序标号为 $0 \sim 8$，也就是我们要对这 $24$ 条边划分成 $5$ 个图，每个图 $5$ 条边，那么每个图可以只有 $4$ 个点？（这是不行的，因为如果只有 $4$ 个点在三度点中必然有一个点是特殊点，然后边就会大量重复，无法划分。）也就是每个子图需要有 $5$ 个点。

然后我们让这 $5$ 个点的图尽可能工整便于后面的优化。我们考虑生成出的图可以看成 $2 \times 3$ 的二分图上缺一条边，然后发现这个划分是可行的，如下：
$$
\{(0, 4), (0, 5), (0, 6), (1, 4), (1, 5)\} \\
\{(1, 7), (1, 8), (1, 6), (0, 7), (0, 8)\} \\
\{(2, 8), (2, 4), (2, 5), (3, 8), (3, 4)\} \\
\{(6, 2), (6, 3), (6, 8), (7, 2), (7, 3)\} \\
\{(8, 4), (8, 5), (8, 7), (3, 4), (3, 5)\} \\
$$
对于 $i = 9998$，那么当前的边集可以看成 $\{(0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 5), (2, 5), (3, 5), (4, 5)\}$ 共 $10$ 条边。其中 $0,1$ 标号是 $9997$ 中得到的图的左部，$2, 3, 4$ 是右部，$5$ 是 $9998$ 号点，然后划分成 $5$ 个 $(0, 1), (0, 2)$ 形式很显然是容易的，直接按照列出的顺序两两划分即可。然后到 $9999$ 就是 $3$ 个点 $5$ 条边选一条边，这个更简单了，直接返回对应边的标号即可。

还原直接反过来跑一遍上述问题即可。

---


# [IOI 2025] 神话三峰（triples）（Part 2）

## 题目背景


本题目前可以评测子问题 2。可在 [P13536](https://www.luogu.com.cn/problem/P13536) 评测子问题 1。

## 题目描述


东科迪勒拉山脉是安第斯山脉跨越玻利维亚的部分。它由连续的 $N$ 座山峰组成，从 $0$ 到 $N - 1$编号。山峰 $i$（$0 \leq i < N$）的**高度** $H[i]$  是 $1$ 到 $N - 1$ 之间的整数。

对任意两座山峰 $i$ 和 $j$（其中 $0 \le i < j < N$），它们的**距离**定义为 $d(i, j) = j - i$。根据古老的印加传说，三座山峰是**神话**三峰的条件是：它们的高度与两两之间的距离在**忽略顺序**后**匹配**。

形式化地， $(i, j, k)$ 是神话三峰的条件为：
* $0 \leq i < j < k < N$，
* 山峰高度 $(H[i], H[j], H[k])$ 与两两之间的距离 $(d(i,j), d(i,k), d(j,k))$ 在忽略顺序后匹配。例如，对山峰 $0, 1, 2$，其两两之间的距离是 $(1, 2, 1)$，所以山峰高度 $(H[0],H[1],H[2]) = (1,1,2)$， $(H[0],H[1],H[2]) = (1,2,1)$ 和 $(H[0],H[1],H[2]) = (2,1,1)$ 都匹配，但山峰高度 $(1,2,2)$ 则不匹配。

该问题分为两个部分，分别对应**子问题一**或者**子问题二**。你可以按任意顺序解决这些子问题。特别地，你**无需**先完成子问题一再尝试子问题二。

### 子问题一

给定山脉的描述，你的任务是计算神话三峰的数量。

#### 实现细节

你要实现以下函数：

```
long long count_triples(std::vector<int> H)
``` 

* $H$: 长度为 $N$ 的数组，表示每座山峰的高度。
* 对每个测试用例，该函数恰好被调用一次。

该函数返回一个整数 $T$，表示山脉中神话三峰的数量。

### 子问题二

你的任务是构造包含尽量多神话三峰的山脉。该子问题包含 $6$ 个有**部分得分**的**提交答案**的子任务。

对每个子任务，你将获得两个正整数 $M$ 和 $K$，需要构造一个**最多包含** $M$ 座山峰的山脉。如果你的答案中包含**至少** $K$ 个神话三峰，你将获得该子任务的满分。否则，你的得分将与你的答案中所包含的神话三峰的数量成正比。

注意，你的答案必须是一个有效的山脉。具体来说，假设你的答案包含 $N$ 座山峰（$N$ 必须满足 $3 \leq N \leq M$）。那么，山峰 $i$ 的高度 $H[i]$（$0 \leq i < N$）必须是一个 $1$ 到 $N - 1$ 之间的整数。

#### 实现细节

有两种提交解答的方法，你可以为每个子任务选择其中一种：
* **输出文件**
* **函数调用**

通过**输出文件**提交解答时，请创建并提交一个格式如下的文本文件：
```
N
H[0] H[1] ... H[N-1]
```

通过**函数调用**提交解答时，你需要实现以下函数。

```
std::vector<int> construct_range(int M, int K)
```

* $M$: 最多允许的山峰数量。
* $K$: 期望的神话三峰数量。
* 对每个测试用例，该函数恰好被调用一次。

该函数应返回一个长度为 $N$ 的数组 $H$，表示每座山峰的高度。


## 说明/提示


### 子问题 1 例子

考虑以下调用。

```
count_triples([4, 1, 4, 3, 2, 6, 1])
```

该山脉中包含 $3$ 个神话三峰：

* 对 $(i,j,k)=(1,3,4)$，高度 $(1,3,2)$ 与两两之间的距离 $(2,3,1)$ 匹配。
* 对 $(i,j,k)=(2,3,6)$，高度 $(4,3,1)$ 与两两之间的距离 $(1,4,3)$ 匹配。
* 对 $(i,j,k)=(3,4,6)$，高度 $(3,2,1)$ 与两两之间的距离 $(1,3,2)$ 匹配。

因此，该函数应该返回 $3$。

注意，$(0, 2, 4)$ 不构成神话三峰，因为其高度 $(4,4,2)$ 与两两之间的距离 $(2,4,2)$ 并不匹配。

### 子问题 1 数据范围

- $3 \leq N \leq 200\,000$。
- 对每个满足 $0 \le i < N$ 的 $i$，都有 $1 \leq H[i] \leq N-1$。

### 子任务与得分规则

子问题一总共 $70$ 分。

| 子任务 | 分数 | 额外的约束条件 |
| :-----: | :----: | ---------------------- |
| 1       | $8$    | $N \leq 100$
| 2       | $6$    | 对每个满足 $0 \leq i < N$ 的 $i$，都有 $H[i] \leq 10$。
| 3       | $10$   | $N \leq 2000$
| 4       | $11$   | 山峰的高度是单调不下降的。  也就是说，对每个满足 $1 \leq i < N$ 的 $i$ 都有 $H[i - 1] \leq H[i]$。
| 5       | $16$   | $N \leq 50\,000$
| 6       | $19$   | 没有额外的约束条件。

子问题二总共 $30$ 分。
每个子任务的 $M$ 和 $K$ 值是固定的，如下表所示：


| 子任务 | 分数 | $M$        | $K$             |
| :-----: | :---: | :--------: | :-------------: |
| 7       | $5$   | $20$       | $30$
| 8       | $5$   | $500$      | $2000$
| 9       | $5$   | $5000$     | $50\,000$
| 10      | $5$   | $30\,000$  | $700\,000$
| 11      | $5$   | $100\,000$ | $2\,000\,000$
| 12      | $5$   | $200\,000$ | $12\,000\,000$

对每个子任务，如果你的答案不构成有效的山脉，你的得分将为 $0$（在 CMS 中被报告为 `Output isn't correct`）。否则，设 $T$ 表示答案中的神话三峰数量。
则你在该子任务中的得分为：
$$5 \cdot \min\left(1,\frac{T}{K}\right)$$

## 样例 #1

### 输入

```
1
7
4 1 4 3 2 6 1```

### 输出

```
3```

# 题解

## 作者：Mirasycle (赞：4)

[前情提要](https://www.luogu.com.cn/article/5a5c2f3e)

在 Part 1 中，我们将匹配根据 $h$ 的关系分成了六种类型。其中有五种都是很好做的，第六种可以通过三元环计数来完成。

观察匹配形式，其实我们应该去尽可能构造第六种。因为前五种之所以简单是它们可以一推二，也就是三元组中确定了某一个可以推导到另一个，这是我们很不希望了，这意味着三元组的变化很小基本很固定，难以让其数量增多。

故应该从第六种入手，这个变化多。我们应该让三元环个数尽可能多。有一个很基础的想法就是我们用很少的点，然后造一堆连在它们之间的边，这样子三元组的个数就会很多。首先应该注意到点的个数不能太少，因为通过两个点之间的信息解二元一次方程可以唯一确定一组 $(i,h_i)$，也就是说不能有重边。

自己做这题的时候就止步于此，因为我觉得自己造点很考验技术，随机造点又不太靠谱的样子。于是就瞎输出了一些很小的序列的组合获得了 $78 \rm pts$。后来看了别人的代码，发现这种思路确实可行，而且正是随机！

具体来说我们随机取一些 $[0,M]$ 之间的偶数（不要太多，防止点很多导致边比较分散，但也不能太少不然的话就无法填充 $h$ 数组了），取偶数的目的是为了解方程一定有解。然后在选择偶数中枚举所有数对，通过解方程确实 $(i,h_i)$。肯定有一些 $h_i$ 到最后也没有被覆盖，我们就统一赋值为 $1$。

使用在 Part 1 中写的计数函数进行计算，多次随机，取最大的一次输出即可。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=4e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int h[maxn],from[maxn],deg[maxn],n; 
int p[maxn],rk[maxn],vis[maxn]; map<int,int> id;
vector<int> G[maxn],L[maxn],R[maxn]; 
pair<int,int> E[maxn];
bool cmp(int x,int y){ return deg[x]<deg[y]||(deg[x]==deg[y]&&x<y); }
ll count_triples(vi H){
	n=H.size(); ll ans=0;
	for(int i=1;i<=n;i++) h[i]=H[i-1];
	//(i,j,k)
	//Hi=max{Hi,Hj,Hk}
	for(int i=1;i<=n;i++){
		int k=i+h[i];
		if(k>n) continue;
		int j=i+h[k];
		if(j<k&&j+h[j]==k) ans++;
		if(k-h[k]!=j){
			j=k-h[k];
			if(i<j&&j-h[j]==i) ans++;
		}
	}
	//Hk=max{Hi,Hj,Hk}
	for(int k=1;k<=n;k++){
		int i=k-h[k];
		if(i<1) continue;
		int j=i+h[i];
		if(j<k&&j+h[j]==k) ans++;
		if(k-h[i]!=j){
			j=k-h[i];
			if(i<j&&j-h[j]==i) ans++;
		}
	}
	//Hj=max{Hi,Hj,Hk}
	for(int i=1;i<=n;i++){
		if(i+h[i]<=n) L[i+h[i]].pb(i);
		if(i-h[i]>=1) R[i-h[i]].pb(i);
	}
	for(int i=1;i<=n;i++){
		for(auto u:R[i]) vis[u]=1;
		for(auto u:L[i])
			if(u+h[i]<=n&&vis[u+h[i]]&&h[u+h[i]]!=h[u]) ans++;
		for(auto u:R[i]) vis[u]=0;
	}
	int tot=0;
	for(int i=1;i<=n;i++){
		int h1=i+h[i];
		int h2=i-h[i];
		if(id.find(h1)==id.end()) id[h1]=++tot;
		if(id.find(h2)==id.end()) id[h2]=++tot;
		h1=id[h1]; h2=id[h2];
		E[i]=mp(h1,h2); deg[h1]++; deg[h2]++;
	}
	for(int i=1;i<=tot;i++) p[i]=i;
	sort(p+1,p+1+tot,cmp);
	for(int i=1;i<=tot;i++) rk[p[i]]=i;
	for(int i=1;i<=n;i++){
		int u=E[i].fi,v=E[i].se;
		if(rk[u]<rk[v]) G[u].pb(v);
		else G[v].pb(u);
	}
	for(int u=1;u<=tot;u++){
		for(auto v:G[u]) from[v]=u;
		for(auto v:G[u])
			for(auto w:G[v])
				if(from[w]==u) ans++;
	}
	for(int i=1;i<=n;i++) L[i].clear(),R[i].clear(); 
	for(int i=1;i<=tot;i++){
		G[i].clear(); deg[i]=0;
	} id.clear();
	return ans;
}
vi ans; int m;
void add(int x,int y){
	if(x<y) swap(x,y);
	int i=(x+y)/2,j=(x-y)/2;
	if(!ans[i]) ans[i]=j;
}
vi construct_range(int M,int K){
	ans.resize(M); int lim=2700,seed=330;
	double st=clock(); vi res; ll cur=0;
	while((clock()-st)/CLOCKS_PER_SEC<=1.8){
		mt19937 rnd(seed); vi vec;
		for(auto &z:ans) z=0;
		for(int i=0;i<=M;i+=2) vec.pb(i);
		shuffle(vec.begin(),vec.end(),rnd);
		if(vec.size()>lim) vec.resize(lim);
		for(int i=0;i<vec.size();i++)
			for(int j=0;j<i;j++) add(vec[i],vec[j]);
		for(auto &z:ans) 
			if(!z) z=1;
		int z=count_triples(ans);
		if(count_triples(ans)>cur){
			cur=z; res=ans;
		} seed++;
	}
	return res;
}
```

---

## 作者：cmk666 (赞：2)

[上文](/article/o71xym40)。

显然我们只关心最复杂的那种 case，也就是三元环的 case，因为只有这种才能产生 $O(n\sqrt n)$ 的答案。

本质上，相当于要找一个 $n$ 条边的图，满足每条边的顶点编号之和都是 $[0,2(n-1)]$ 间的两两不同的偶数，使三元环尽可能多。最好是让点集尽可能少，让图趋于完全图。

一种简单的构造是，钦定用到的点编号都是非负偶数。考虑如下的贪心：

- 初始时只有一个点 $0$。
- 每次选一个能使得边增加的最多的点编号加入，并加入这些边。
- 重复直到无法加入为止。

这样的构造较为优秀，在 $n=2\times10^5$ 时可以构造 $K>1.5\times10^7$。不过 $n$ 较小时表现较差。具体的，该做法无法通过子任务 $7$，需要乱搞一下。

---

## 作者：_lmh_ (赞：2)

首先要统计 $(i,j,k)$ 的数量。

枚举 $i$。如果 $a_i=j-i$ 或者 $a_i=k-i$ 是简单的——可以确定三元组中第二个数，那么第三个数只有 $O(1)$ 种可能，逐个判断即可。

否则，$a_i=k-j$。

令 $b_i=i-a_i$。分类讨论 $a_j$ 与 $a_k$ 的大小关系，可以得到：$b_j=b_k=i$ 或者 $b_j=i-a_i,b_k=i+a_i$。

用 `bitset` 直接维护每个 $b$ 的出现位置，求交即可，时空复杂度均为 $O(\frac{n^2}{w})$。

但是空间会爆，需要优化。

具体地，把 $b_i$ 按照大小分类，$>B$ 的用 `bitset` 维护，$\le B$ 的直接用 `vector` 维护，暴力枚举。

取 $B=\frac{n}{w}$，时间复杂度不变，空间复杂度降为 $O(n)$。为了减小常数，$B$ 可以开小一些。

然后就到了第二问，构造方案。

$n=20$ 和 $n=500$ 没啥好说的，直接用模拟退火之类的技巧搜索即可——实际上这个答案的界非常松，每次只保留更优解（卡在局部最优解的时候手动回退一下版本）就可以搜出来。

首先我们注意到，满足 $a_i$ 和 $j-i,k-i$ 匹配的东西是 $O(n)$ 的，满足 $b_j=b_k=i$ 的三元组也是 $O(n)$ 的（每个 $b$ 只会被算到一次）。

而题目要求我们构造的 $k$ 比它们能凑出来的三元组数量大一个数量级——考虑到所有构造方案都必定带一个小常数，这个量级接近 $O(n\sqrt n)$。

现在有 $b_j=i-a_i,b_k=i+a_i$。首先选一些根据 $b$ 划分的等价类，往每个等价类里面塞一大堆东西；然后对于所有的 $b_i,b_j(2\mid i+j,i<j)$，令 $a_\frac{i+j}{2}=\frac{j-i}{2}$（如果出现冲突，则任选一个值）。

这里每个 $b$ 平均要被覆盖根号次，考虑设置一个阈值 $B=O(\sqrt n)$，选择 $2x$ 与 $2Bx(0\le x<B)$ 作为 $b$ 的集合，这样每个 $b$ 都被覆盖了 $B+O(1)$ 次。

当然还有 $k-j=a_i$ 的限制。前面对 $a_i$ 进行了特殊的赋值，因此这个条件可以转化为 $j+a_j=k+a_k$。

现在考虑如下策略：每次选择一个起点 $p$，对于所有可能的 $b$，尝试在 $p+b$ 的位置放置 $p-b$（如果出现冲突或者越界就不放置），直到把所有位置放满。

把位置 $p$ 映射到 $([\frac{p}{B}],p\bmod B)$ 上，发现放置一组点相当于覆盖一个 L 形的区域。

一个简单的策略是，将平面划分成若干个 $B\times B$ 的块，每块再次划分成 $B$ 个 L 形区域——此时这一块的贡献约为 $\frac{B^3}{3}$。

粗略估计划分成的块数为 $\frac{n}{B^2}-1$，可以枚举 $B$ 求出一个优秀的块长——然后手动精细调整。

满分需要继续优化：在预处理部分，对于 $b_i,b_j(2\mid i+j,i<j)$，我们令 $a_\frac{i+j}{2}=\frac{j-i}{2}$——这一步不用做完，可以有一个后缀的 $a$ 没有被预处理。它们并不会被统计到太多次，因此没有太大的损失。

考虑这 $B$ 个 L 形区域，发现有 $B-1$ 个仍然有扩展空间——只要把划分成的块从 $B\times B$ 改为 $B\times (B+1)$（或者更大）即可。

具体的实现可以参考代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=200007,B=500;
ll n,m,q,a[N],ans,id[N*3],cnt[N],bid[N],sum[N];
vector<int> vec[N];
bitset<N> bs[B];
mt19937 rng(20120712);
void mysort(ll& x,ll& y,ll& z){
	if (x>y) swap(x,y);
	if (y>z) swap(y,z);
	if (x>y) swap(x,y);
}
bool OK(ll x,ll y,ll z){
	if (z>n||z<=0) return 0;
	ll A[3]={abs(x-y),abs(y-z),abs(x-z)},B[3]={a[x],a[y],a[z]};
	mysort(A[0],A[1],A[2]);mysort(B[0],B[1],B[2]);
	return A[0]==B[0]&&A[1]==B[1]&&A[2]==B[2];
}
ll query(ll u,ll v,ll k){
	static bool ok[N];
	ll ans=0;
	if (cnt[u]<B&&cnt[v]<B){
		for (auto x:vec[v]) ok[x]=1;
		for (auto x:vec[u]) if (x+k<=n) ans+=ok[x+k];
		for (auto x:vec[v]) ok[x]=0;
		return ans;
	}
	if (cnt[u]<B){
		v=bid[v];
		for (auto x:vec[u]) if (x+k<=n) ans+=bs[v][x+k];
		return ans;
	}
	if (cnt[v]<B){
		u=bid[u];
		for (auto x:vec[v]) if (x-k>=0) ans+=bs[u][x-k];
		return ans;
	}
	return (bs[bid[u]]&(bs[bid[v]]>>k)).count();
}
ll count_triples(vector<int> H){
	n=H.size();
	for (int i=1;i<=n;++i) a[i]=H[i-1];
	
//	for (int i=1;i<=n;++i) for (int j=i+1;j<=n;++j) for (int k=j+1;k<=n;++k) if (OK(i,j,k)){
//		++sum[i];++sum[j];++sum[k];
//		++ans;
//	}
	
	for (int i=n;i;--i){
		//count
		int x=id[i+N],y,k=a[i];
		if (cnt[x]>=2) ans+=query(x,x,k);
		x=id[i-k+N];y=id[i+k+N];
		if (cnt[x]&&cnt[y]) ans+=query(x,y,k);
		//insert
		k=i-a[i]+N;
		if (!id[k]) id[k]=++m;
		k=id[k];
		vec[k].emplace_back(i);
		if ((++cnt[k])==B){
			bid[k]=++q;
			for (auto x:vec[k]) bs[q][x]=1;
		}
		if (cnt[k]>B) bs[bid[k]][i]=1;
//		cout<<ans<<endl;
	}
	for (int i=1;i<=n;++i){
		int j=i+a[i];
		if (j>n) continue;
		if (a[j]<a[i]) ans+=OK(i,j,j-a[j]);
		if (a[j]!=a[i]) ans+=OK(i,j,j+a[j]);
		if (a[j]!=2*a[i]&&a[j]*2!=a[i]) ans+=OK(i,j,i+a[j]);
	}
	return ans;
}
vector<int> construct_range(int M,int K){
	n=M;
	vector<int> vec,L,R;
	int B;
	if (n==20){
		vector<int> vec={3,1,2,1,4,3,6,5,6,7,2,3,4,1,2,1,8,1,6,5};
		return vec;
	}
	if (n==500){
		vector<int> vec={1,12,1,2,1,2,1,4,3,2,11,10,9,8,7,2,5,4,1,11,1,22,21,20,19,18,17,16,15,14,13,12,11,32,31,30,29,28,27,26,25,24,23,22,43,42,41,40,39,38,37,36,35,34,11,54,53,52,51,50,49,48,47,46,45,22,65,64,63,62,61,60,59,58,57,56,55,76,111,74,73,72,71,70,69,68,67,22,87,86,85,84,83,82,81,80,79,78,11,98,97,96,95,94,93,92,91,90,89,22,109,108,107,106,105,104,103,102,101,100,11,118,121,116,119,114,125,70,127,110,125,44,143,122,141,178,139,138,137,136,135,134,33,132,131,130,129,128,127,150,149,148,147,22,145,144,143,142,141,116,139,162,161,160,33,158,157,156,155,154,105,128,151,174,173,172,171,170,169,168,167,94,117,140,163,186,11,184,183,182,181,180,83,106,129,152,175,22,197,196,195,194,193,72,95,118,141,164,11,210,209,208,207,206,61,84,107,130,153,1,199,222,221,211,219,50,73,96,119,142,165,188,211,234,233,232,39,62,85,108,131,154,177,200,223,246,245,28,51,74,97,120,143,166,189,212,235,18,259,258,257,256,255,254,253,252,251,250,249,248,271,270,269,268,267,11,265,264,263,262,237,260,283,282,281,280,279,12,277,276,275,226,249,272,295,294,293,292,291,11,289,288,215,238,261,284,307,306,305,304,303,12,301,204,227,250,273,296,319,318,317,316,315,24,193,216,239,262,285,308,331,330,329,328,327,12,205,228,251,274,297,320,343,342,341,340,171,24,217,240,263,286,309,332,355,354,353,160,183,12,229,252,275,298,321,344,367,366,149,172,195,48,241,264,287,310,333,356,139,380,379,378,377,376,375,374,373,372,371,370,369,392,391,390,389,388,121,386,385,384,383,358,381,404,403,402,401,400,133,398,397,396,347,370,393,416,415,414,413,412,121,410,409,336,359,382,405,428,427,426,425,424,109,422,325,348,371,394,417,440,439,438,437,436,97,314,337,360,383,406,429,452,451,450,449,448,133,326,349,372,395,418,441,464,463,462,461,292,121,338,361,384,407,430,453,476,475,474,281,304,109,350,373,396,419,442,465,488,487,270,293,316,145,362,385,408,431,454,477,260};
		return vec;
	}
	if (n==5000) B=41;
	if (n==30000) B=100;
	if (n==100000) B=150;
	if (n==200000) B=258;
//	cin>>B;
	for (int i=0;i<B;++i) L.emplace_back(i);
	for (int i=1;i<B;++i) R.emplace_back(i*B);
	for (auto x:L) for (auto y:L) if (x!=y){
		if (!a[x+y]) a[x+y]=abs(y-x);
		else a[x+y]=min(a[x+y],(ll)abs(y-x));
	}
//	for (auto x:R) for (auto y:R) a[x+y]=y-x;
	for (auto x:L) for (auto y:R) a[x+y]=y-x;
//	if (n==5000) for (int i=2;i<B;i+=2) a[i]=B+1;
	int d=B*B+2800,lim=R.back()-3400;
	if (n==5000) d=B*B+3,lim=R.back()-1;
	if (n==30000) d=B*B+B,lim=R.back()-B-1;
	for (int i=lim+1;i<=n;++i) a[i]=0;
	vector<int> owo;
	for (int i=lim+1;i<=n;i+=d) owo.emplace_back(i);
	reverse(owo.begin(),owo.end());
	for (auto i:owo){
		for (int j=0;j<B;++j){
			int x=i+j*(B+1);
			for (auto d:L) if (x+d>0&&x+d<=n&&a[x+d]==0) a[x+d]=x-d;
			for (auto d:R) if (x+d>0&&x+d<=n&&a[x+d]==0) a[x+d]=x-d;
		}
	}
	for (int i=1;i<=n;++i) vec.emplace_back(min(max(a[i],1ll),n-1));
	return vec;
}
```

---


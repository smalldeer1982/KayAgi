# [IOI 2019] 景点划分

## 题目背景

# 滥用本题评测将封号

注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。

## 题目描述

巴库有 $n$ 处景点，从 $0$ 到 $n-1$ 编号。另外还有 $m$ 条双向道路，从 $0$ 到 $m-1$ 编号。每条道路连接两个不同的景点。经由这些道路，可以在任意两处景点之间往来。

Fatima 打算在三天之内参观完所有这些景点。她已经决定要在第一天参观 $a$ 处景点，第二天参观 $b$ 处景点，第三天参观 $c$ 处景点。因此，她要将 $n$ 处景点划分为三个集合 $A$、$B$ 和 $C$，其规模分别为 $a$、$b$ 和 $c$。每处景点恰好属于其中一个集合，因此有 $a+b+c=n$。

Fatima 想要找到这样的景点划分 $A$、$B$ 和 $C$，使得这三个集合中的至少两个是联通的。一个景点集合 $S$ 被称为是联通的，如果能够经由这些道路在 $S$ 中的任意两处景点之间往来，且不需要经过不在 $S$ 中的景点。如果满足上述要求，则景点的一个划分 $A$、$B$ 和 $C$ 被称为是合法的。

请帮助 Fatima 找到一个合法的景点划分 （给定 $a$、$b$ 和 $c$），或者判断合法的划分不存在。如果存在多个合法的划分，你可以给出其中的任何一个。

**实现细节**

你需要实现下述函数：
`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`
- $n$：景点的数量。
- $a$、$b$ 和 $c$：集合$A$、$B$ 和 $C$ 的期望规模。
- $p$ 和 $q$：长度为 $m$ 的数组，包含道路的端点。对每个 $i$ （$ 0 \le i \le m-1 $），$p[i]$ 和 $q[i]$ 是由道路 $i$ 连接的两处景点。
- 该函数需要返回一个长度为 $n$ 的数组。记该数组为 $s$。如果不存在合法的划分，$s$ 应当包含 $n$ 个零。否则，对于 $0 \le i \le n-1$，$s[i]$ 应为 $1$、$2$ 或 $3$ 中的一个。以分别表示景点 $i$ 被归到集合 $A$、$B$ 或 $C$


## 说明/提示

**样例说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)

一个可能解为 $[1,1,3,1,2,2,3,1,3]$。这个解刻画了这样的划分：$A=\{0,1,3,7\}$，$B=\{4,5\}$，$C=\{2,6,8\}$。集合 $A$ 和 $B$ 是联通的。

**数据范围**

对于 $100\%$ 的数据，
- $3 \le n \le 10^5$。
- $2 \le m \le 2 \times 10^5$。
- $1 \le a,b,c \le n$。
- $a+b+c=n$。
- 每一对景点之间至多有一条道路。
- 经由这些道路，可以在任何两处景点之间往来。
- 对于 $0 \le i \le m-1$，有 $0 \le p[i],q[i] \le n-1$ 和 $p[i] ≠ q[i] $。

**子任务**
1. （$7$ 分） 每处景点至多可做两条道路的端点。
2. （$11$ 分） $a=1$
3. （$22$ 分） $m=n-1$
4. （$24$ 分） $n \le 2500$，$m \le 5000$。
5. （$36$ 分） 没有任何附加限制。

## 样例 #1

### 输入

```
9 10
4 2 3
0 1
0 2
0 3
0 4
0 6
0 8
1 7
3 7
4 5
5 6
```

### 输出

```
1 1 3 1 2 2 3 1 3
```

# 题解

## 作者：liangbowen (赞：36)

[problem](https://www.luogu.com.cn/problem/P5811) & [blog](https://www.cnblogs.com/liangbowen/p/17549437.html)。

题解代码都长得离谱，2k 代码了解一下！

~~如果我码风比较压行还可以 2k 以内，但是很不幸我是空格 + 大括号换行流~~。

---

不妨设 $a \le b \le c$，如果能使 $C$ 联通，那么从中取出一个 $A$ 或 $B$ 的连通块也是平凡的，所以只考虑 $A,B$。

考虑树的情况。要找到一条边 $(u,v)$ 满足 $u$ 那边的子树的 $siz\ge a$，$v$ 那边的子树的 $siz \ge b$。

容易发现 $a\le b\le \dfrac n2$，联想到重心，它的性质是 $\forall siz\le \dfrac n2$，所以只需要枚举与重心相连的边，如果能找到一个子树把 $A$ 塞进去，那么 $n-siz>n-\dfrac n2>\dfrac n2$，很容易就能把 $B$ 塞进去。找不到就是无解。

回到简单图。上面的 Special Task 提示我们建 $\text{DFS}$ 树，并找到它的重心。下文令 $siz_i$ 表示重心相邻的那些点的子树。

如果 $\exists siz_i \ge a$，直接按照树的方法构造即可。否则，考虑第一个子树，有一些其他的子树会与它相连。如果这些相连的子树都算上了，还是没法干掉 $A$，那么必须动用两次重心了，无解。

令 $S$ 表示干掉 $A$ 需要用到的点集。可以认为这个过程是一个一个看子树，当 $\sum\limits_S siz_i$ 成功干掉 $A$，立刻终止。由于 $\forall siz_i < a$，故 $\sum\limits_S siz_i < 2a$。继续化简，$n=a+b+c>2a+b>\sum\limits_S siz_i +b$，所以 $b<n-\sum\limits_S siz_i$，也就是说必定可以干掉 $B$。

输出即可。注意调换了 $a,b,c$ 满足 $a\le b\le c$ 后，输出也要调整一下。

[代码](https://www.luogu.com.cn/paste/n55892rk)，时间复杂度 $O(n+m)$。


---

## 作者：Sweetlemon (赞：25)

## 奇妙的构造——IOI 2019 Day 1 T2 Split

### 题意

[题目链接](https://www.luogu.com.cn/problem/P5811)

将一个简单无向连通图分为大小分别为 $a,b,c$ 的三个集合，使得这三个集合中至少有两个是连通子图。

### 从部分分开始

首先考虑树的情况的部分分。我们只需要在树上找两个大小分别为 $a,b$ 的无交连通块即可。因为我们可以随便从连通块上删掉叶子节点，所以小的连通块总是更容易找到，于是我们可以设 $a\le b\le c$。

而找到了连通块后，我们可以往连通块上加节点，使得不属于 $A,B$ 两个点集的点进入这两个集合中的一个，最终使得 $A\cap B=\varnothing,A\cup B=G$。因此我们只需要把树划分成不相交的两个连通块，且这两部分的大小分别不小于 $a,b$ 即可。

考虑这两部分中不包含根的一部分，这一部分一定是以这个连通块的 LCA 为根的一棵子树（否则这个子树上不属于这个连通块的点无法与另一个连通块相连）。因此只需要在树上找到一棵大小在 $[a,n-b]$ 或 $[b,n-a]$ 内的子树即可。如果找不到这样的子树，就说明没有方案。找到了这棵子树，就从它和它的父亲开始分别向两边 dfs，染满 $a$ 个（或 $b$ 个）点后，剩下的点就染 $3$ 即可。

### 走向正解

现在考虑一般图的情况怎么做。选好连通块后，我们可以把无用的边删掉，形成一棵生成树；因此只要我们通过适当的方法造一棵生成树即可。

那么我们应该怎么选取这棵生成树呢？我们可以以 dfs 树为蓝本，通过调整得到这棵生成树。

先发掘 $a\le b\le c$ 中包含的信息。因为 $a+b+c=n$，因此 $a\le \frac{n}{3}$，$b\le \frac{n}{2}$，$c\ge \frac{n}{3}$（这些都可以用反证法证明）。我们只需要有一棵子树的大小在 $[a,n-b]$ 或 $[b,n-a]$ 内即可，由上面的范围可以推出 $n-b\ge b$，因此这两个区间中间没有空隙，它们的并是 $[a,n-a]$。而根据 $a$ 的范围，我们知道 $\left[\frac{n}{3},\frac{2n}{3}\right] \subseteq [a,n-a]$，可以看到这个范围其实是挺大的。

再看看我们“调整生成树”到底是什么样的过程。dfs 树上只有返祖边而没有横叉边，如果我们要“启用”一条返祖边，就必须“禁用”一条树边。这个过程中，禁用掉树边的父端节点子树的大小会减小，因此这可以看作是“剥离”一棵子树的方法。

那么我们想要把哪棵子树调整成合法呢？如果 dfs 树上本来就存在这样的子树，那么可以直接得解；如果目前不存在，我们可以选择“最深”且大小不小于 $n-a$ 的子树。什么叫“最深”呢？也就是，这个节点的子树不小于 $n-a$，但它所有子节点的子树都小于 $n-a$（根据“原来不存在这样的子树”知，如果小于 $n-a$ 那就一定小于 $a$）。

事实上，这样的节点存在且唯一。存在性很容易理解，毕竟根节点的子树大小为 $n$，肯定不小于 $n-a$。

唯一性呢？考虑反证法。如果存在两棵子树 $u,v$ 均满足条件，若 $u,v$ 没有祖先关系（这意味着这两棵子树无交），那么这两棵子树的大小之和不小于 $2(n-a)\ge \frac{4n}{3}$，矛盾；若 $u,v$ 有祖先关系，设 $u$ 是 $v$ 的祖先，考虑 $v$ 所在的 $u$ 的儿子 $x$（即考虑 $u$ 的那一个使得 $x$ 是 $v$ 父亲的儿子 $x$），有 $x$ 的子树的大小不小于 $v$ 的，这样也就不小于 $n-a$，于是 $u$ 有一个大小不小于 $n-a$ 的儿子，矛盾。

这样，我们就证明了这样的节点存在且唯一，可以用 dfs 找到这个节点，记为 $g$（记为 $g$ 是因为它有些类似重心）。而且，联系上面“唯一性”的证明，所有大小不小于 $n-a$ 的子树的根节点都是 $g$ 或 $g$ 的祖先。

$g$ 肯定比它的祖先更容易通过剥离子树而变为合法，因此我们只考虑处理 $g$。

把所有非树边（也就是返祖边）按照两端点分为三类：都在 $g$ 子树（包括 $g$）内、都在 $g$ 子树外或一端为 $g$ 而另一端在 $g$ 子树外、一端在 $g$ 子树内（且不为 $g$）而另一端在 $g$ 子树外。前两类的启用都对 $g$ 子树的大小没有影响，因此我们只能利用第三类边。

设一条“第三类边”的两端点为 $u,v$，其中 $u$ 是 $g$ 的祖先，$v$ 在 $g$ 子树内且不为 $g$。设 $v$ 所在的 $g$ 的儿子为 $x$，即 $x$ 是 $v$ 的祖先（包括 $v$）、$g$ 的儿子，那么我们只要把 $g-x$ 边禁用（变为非树边），再把 $u-v$ 边启用（变为树边），就剥离了 $x$ 子树，$g$ 子树的大小减小。由于 $x$ 子树的大小不超过 $a$，因此剥离 $x$ 子树后 $g$ 子树的大小不小于 $n-a-a=n-2a\ge n-\frac{2n}{3}=\frac{n}{3}\ge a$，也就是剥离 $x$ 子树后 $g$ 子树要么落入合法区间 $[a,n-a]$，要么仍大于 $n-a$。

因此，我们只要不断剥离这样的子树，直到 $g$ 子树的大小落入合法区间，那么就找到方案；如果剥离了所有可能的子树都不能让 $g$ 子树合法，那么就无解。

实现时，我们依次遍历 $g$ 的儿子 $x$，看 $x$ 子树内有没有能跳出 $g$ 子树的非树边，如果有就剥离 $x$，剥离后看 $g$ 子树的大小是否已经合法，合法就跳出循环。循环结束后，看 $g$ 子树的大小是否合法，如果合法则按树的部分分方法（只走树边遍历这个图）输出答案，否则输出无解。

这题全程只用到 dfs，复杂度只有 $\mathrm{O}(n)$，但构造非常巧妙，思维难度极大，需要仔细思考。

### 致谢

本文的方法基本来自王修涵在 WC 2020 上 Opencup 趣(duliu)题选讲的内容，本人进行了一些解释，在此表示感谢！

### 程序实现

给出我极长的代码，跑得似乎挺快的。

```cpp
//IOI 2019 D1T2
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <cstring>
#include <vector>
#define MAXIOLG 25
#define MOD 998244353
#define INF 19260817
#define MD(x) (((x)>=MOD)?((x)-=MOD):(0))
#define LOWBIT(x) ((x)&(-(x)))
#define FILENAME(x) \
freopen(x".in","r",stdin); \
freopen(x".out","w",stdout);
#define MAXN 100005
#define MAXM 400005
using namespace std;

typedef long long ll;
typedef long double ld;
typedef ll io_t;

io_t shin[MAXIOLG];
io_t seto(void); //快读
void ayano(io_t x,char spliter='\n'); //快写

typedef pair<int,int> pii;
pii cap_raw[4]; //存储原来的 a,b,c

int n,cap[4],point_g;
int ok_p=0,ok_q=0;
int visited[MAXN],sz[MAXN],depth[MAXN],par[MAXN];
int g[MAXM];
int fst[MAXN],nxt[MAXM],edges=1;
//edge_prop 为边的属性
//0 - 未定义,  1 - 父亲连向孩子的树边,  2 - 孩子连向父亲的树边,  3 - 非树边
int edge_prop[MAXM];
int anss[MAXN];

int dfs1(int x,int pa);
void dfs2(int x,int pa,int col);
void dfs3(int x,int pa);
void dfs4(int x,int pa,int col);
int dfs5(int x);
void addedge(int u,int v);

int main(void){
    int m;
    n=seto(),m=seto();
    cap_raw[1]=make_pair(seto(),1),
    cap_raw[2]=make_pair(seto(),2),
    cap_raw[3]=make_pair(seto(),3);
    sort(cap_raw+1,cap_raw+3+1); //a<=b<=c
    cap[1]=cap_raw[1].first,cap[2]=cap_raw[2].first,cap[3]=cap_raw[3].first;
    for (int i=1;i<=m;i++){
        int u,v;
        u=seto()+1,v=seto()+1;
        addedge(u,v),addedge(v,u);
    }
    if (m==n-1){
        //树的部分分
        dfs1(1,0);
        //没有找到合法子树
        if (!ok_p){
            for (int i=1;i<=n;i++)
                ayano(0,' ');
            putchar('\n');
            return 0;
        }
        //从合法子树两端开始染色
        dfs2(ok_p,ok_q,1),dfs2(ok_q,ok_p,2);
        for (int i=1;i<=n;i++)
            ayano(cap_raw[anss[i]].second,' ');
        putchar('\n');
        return 0;
    }
    //一般情况
    dfs3(1,0);
    if (ok_p){
        //dfs 树上直接可以找到合法的子树
        dfs4(ok_p,ok_q,1),dfs4(ok_q,ok_p,2);
        for (int i=1;i<=n;i++)
            ayano(cap_raw[anss[i]].second,' ');
        putchar('\n');
        return 0;
    }
    for (int ei=fst[point_g];ei;ei=nxt[ei]){
        if (edge_prop[ei]==1 && dfs5(g[ei])){
            //枚举 g 的儿子，看能否剥离
            sz[point_g]-=sz[g[ei]]; //更新子树大小
            edge_prop[ei]=edge_prop[ei^1]=3; //树边调整为非树边
            if (sz[point_g]<=n-cap[1])
                break;
        }
    }
    if (sz[point_g]>n-cap[1]){
        //不合法
        for (int i=1;i<=n;i++)
            ayano(0,' ');
        putchar('\n');
        return 0;
    }
    if (sz[point_g]<=n-cap[2]){
        //size(g)<=n-b, 染成 1（a 对应的颜色）
        ok_p=point_g,ok_q=par[point_g];
    }
    else {
        //染成 2（b 对应的颜色）
        ok_p=par[point_g],ok_q=point_g;
    }
    dfs4(ok_p,ok_q,1),dfs4(ok_q,ok_p,2);
    for (int i=1;i<=n;i++)
        ayano(cap_raw[anss[i]].second,' ');
    putchar('\n');
    return 0;
}
//树的部分分，计算 size
int dfs1(int x,int pa){
    int tsz=1;
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (v==pa)
            continue;
        tsz+=dfs1(v,x);
    }
    if (tsz>=cap[1] && tsz<=n-cap[2])
        ok_p=x,ok_q=pa;
    if (tsz>=cap[2] && tsz<=n-cap[1])
        ok_p=pa,ok_q=x;
    return tsz;
}
//树的部分分，染色
void dfs2(int x,int pa,int col){
    if (!cap[col])
        col=3; //如果染够了 a/b 个点，下面的点就染 3（c 对应的颜色）
    anss[x]=col,cap[col]--;
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (v==pa)
            continue;
        dfs2(v,x,col);
    }
}
//制造 dfs 树
void dfs3(int x,int pa){
    visited[x]=1;
    sz[x]=1,depth[x]=depth[pa]+1,par[x]=pa;
    int cond_1=1; //是否所有儿子的大小都小于 n-a
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (v==pa){
            edge_prop[ei]=2;
            continue;
        }
        if (visited[v]){
            edge_prop[ei]=3;
            continue;
        }
        edge_prop[ei]=1;
        dfs3(v,x);
        sz[x]+=sz[v];
        (sz[v]>n-cap[1])?(cond_1=0):(0);
    }
    if (sz[x]>=cap[1] && sz[x]<=n-cap[2])
        ok_p=x,ok_q=pa;
    if (sz[x]>=cap[2] && sz[x]<=n-cap[1])
        ok_p=pa,ok_q=x;
    if (cond_1 && sz[x]>n-cap[1])
        point_g=x;
}
//走树边染色
void dfs4(int x,int pa,int col){
    if (!cap[col])
        col=3;
    anss[x]=col,cap[col]--;
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (v==pa || edge_prop[ei]>2 || anss[g[ei]])
            continue;
        dfs4(v,x,col);
    }
}
//寻找合法非树边
int dfs5(int x){
    int x_hs=0; //x 所连合法非树边编号
    for (int ei=fst[x];ei;ei=nxt[ei]){
        if (depth[g[ei]]<depth[point_g]){
            x_hs=ei;
            break;
        }
    }
    if (x_hs){
        edge_prop[x_hs]=2,edge_prop[x_hs^1]=1; //将非树边调整为树边
        return 1;
    }
    for (int ei=fst[x];ei;ei=nxt[ei])
        if (edge_prop[ei]==1)
            if (dfs5(g[ei]))
                return 1;
    return 0;
}

void addedge(int u,int v){
    edges++;
    g[edges]=v;
    nxt[edges]=fst[u],fst[u]=edges;
}

//快读
io_t seto(void){
    io_t x=0;
    int symbol=0;
    char ch=getchar();
    while (!isdigit(ch))
        ((ch=='-')?(symbol=1):(0)),ch=getchar();
    while (isdigit(ch))
        x=x*10+(ch-'0'),ch=getchar();
    return (symbol)?(-x):(x);
}
//快写
void ayano(io_t x,char spliter){
    if (!x){
        putchar('0'),putchar(spliter);
        return;
    }
    if (x<0)
        putchar('-'),x=-x;
    int ren=0;
    while (x){
        io_t d=x/10;
        shin[ren++]=x-d*10;
        x=d;
    }
    while (ren--)
        putchar(shin[ren]+'0');
    putchar(spliter);
}
```

---

## 作者：xyz32768 (赞：15)

- 不妨假设 $a\le b\le c$，注意到我们一定能够从连通块中不断删点得到更小的连通块，故可以钦定大小为 $a$ 和 $b$ 的点集是连通的

- 又由于大小分别为 $a$ 和 $b$ 的两个连通块确定了之后，我们必然能让这两个连通块不断扩展使这两个点集包含所有 $n$ 个点，所以问题转化成把原图划分成两个连通块，一个大小至少 $a$，一个大小至少 $b$

- 换句话说，这两个连通块中选出任意一个，必须满足其大小在 $[a,n-b]$ 内或 $[b,n-a]$ 内。若其中一个连通块满足条件则合法，其中一个连通块不满足条件则不合法

- 先跑一遍 DFS 树，枚举树上每条边，如果这条边分割出的连通块满足条件则直接输出答案

- 否则考虑 DFS 树的重心。注意到重心的每个子树大小都不在 $[a,n-b]$ 内（否则前面已经被判定为合法），而由于 $a+b+c=n$ 且 $a\le b\le c$，故 $b\le\frac n2$，由重心的性质（每棵子树大小都不超过 $\frac n2$）得到重心每个子树的大小都 $<a$

- 考虑重心的每个子树。如果一个子树内没有连向重心祖先（不包括重心本身）的返祖边，则这个子树必然和重心属于同一个连通块（否则必然无法让这棵子树所在连通块大小 $\ge a$）

- 把所有这样的子树和重心合成一个连通块，如果这个连通块的大小大于 $n-a$ 则无解

- 否则构造一个初始解，重心的子树放在 $B$ 集合，其余部分放在 $A$ 集合

- 显然，重心的子树大小是超过 $n-a$ 的（因为重心上面的那一坨大小 $<a$）

- 依次把重心的所有有连向重心祖先返祖边的子树移到 $A$ 集合内，直到 $B$ 集合的大小 $\le n-a$ 为止

- 如何证明这样得到的 $B$ 集合大小 $\ge b$？

- 证明：每次从 $B$ 集合里删掉的子树大小一定 $<a$，而区间 $[b,n-a]$ 的大小为 $c+1$，由 $a\le c$ 得到 $a$ 必然小于区间 $[b,n-a]$ 的大小，也就是说在 $B$ 集合大小 $>n-a$ 的情况下，一次无论删掉哪个子树都不会让 $B$ 集合大小变得 $<b$，得证

- $O(n+m)$

## Code
```cpp
#include <bits/stdc++.h>

template <class T>
inline void read(T &res)
{
	res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	if (bo) res = ~res + 1;
}

template <class T>
inline T Max(const T &a, const T &b) {return a > b ? a : b;}

template <class T>
inline T Min(const T &a, const T &b) {return a < b ? a : b;}

const int N = 1e5 + 5, M = 4e5 + 5;

int n, m, a, b, c, ecnt, nxt[M], adj[N], sze[N], maxs[N], go[M], tr[4],
dep[N], ans[N], G = 1;
bool vis[N], ind[N];

std::vector<int> son[N];

void add_edge(int u, int v)
{
	nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
	nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
}

void dfs(int u)
{
	vis[u] = 1; sze[u] = 1;
	for (int e = adj[u], v; e; e = nxt[e])
		if (!vis[v = go[e]])
		{
			dep[v] = dep[u] + 1; dfs(v); sze[u] += sze[v];
			maxs[u] = Max(maxs[u], sze[v]);
			son[u].push_back(v);
		}
}

int calc(int u)
{
	int res = n + 1;
	for (int e = adj[u], v = go[e]; e; e = nxt[e], v = go[e])
		res = Min(res, dep[v]);
	for (int i = 0; i < son[u].size(); i++)
		res = Min(res, calc(son[u][i]));
	return res;
}

void setr(int u, int c)
{
	ans[u] = c;
	for (int i = 0; i < son[u].size(); i++)
		setr(son[u][i], c);
}

void other(int c)
{
	for (int u = 1; u <= n; u++) if (!ans[u]) ans[u] = c;
}

void fake(int u, int s)
{
	vis[u] = 1; sze[u] = 1;
	for (int e = adj[u], v; e; e = nxt[e])
		if (!vis[v = go[e]] && ans[u] == ans[v])
		{
			fake(v, s); sze[u] += sze[v];
			if (s <= sze[v]) return;
			s -= sze[v];
		}
	if (s) ans[u] = 3;
}

void output(int ca, int cb)
{
	memset(vis, 0, sizeof(vis));
	for (int u = 1; u <= n; u++)
		if (ans[u] == 1) {fake(u, ca - a); break;}
	for (int u = 1; u <= n; u++)
		if (ans[u] == 2) {fake(u, cb - b); break;}
	for (int u = 1; u <= n; u++) printf("%d ", tr[ans[u]]);
	puts(""); exit(0);
}

int main()
{
	int x, y;
	read(n); read(m); read(a); read(b); read(c);
	tr[1] = 1; tr[2] = 2; tr[3] = 3;
	if (a > b) std::swap(a, b), std::swap(tr[1], tr[2]);
	if (a > c) std::swap(a, c), std::swap(tr[1], tr[3]);
	if (b > c) std::swap(b, c), std::swap(tr[2], tr[3]);
	while (m--) read(x), read(y), add_edge(x + 1, y + 1);
	dfs(dep[1] = 1);
	for (int u = 2; u <= n; u++)
	{
		if (a <= sze[u] && sze[u] <= n - b)
			setr(u, 1), other(2), output(sze[u], n - sze[u]);
		if (b <= sze[u] && sze[u] <= n - a)
			setr(u, 2), other(1), output(n - sze[u], sze[u]);
	}
	for (int u = 2; u <= n; u++)
		if (Max(maxs[u], n - sze[u]) < Max(maxs[G], n - sze[G]))
			G = u;
	int sum = 1;
	for (int i = 0; i < son[G].size(); i++)
		if (ind[i] = calc(son[G][i]) >= dep[G]) sum += sze[son[G][i]];
	if (sum > n - a) output(0, 0);
	setr(G, 2); other(1); sum = sze[G];
	for (int i = 0; i < son[G].size(); i++)
		if (!ind[i] && sum > n - a) sum -= sze[son[G][i]], setr(son[G][i], 1);
	return output(n - sum, sum), 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：10)

题解区都挺长的，来一发短一点的。

为了方便先强制 $A\le B\le C$，那么我们肯定使 $A,B$ 两块连通即可，原因是如果能选出 $C$，删掉部分节点就可以变成 $A/B$。

先考虑图是树的情况，有一种 naive 的办法是枚举每条边判断一边 $size_x\ge A$，另一边 $size_y\ge B$，但并不方便扩展到图上。

另一种便于扩展的方法就是取树的重心，注意以下的 $size$ 指一个连通块的大小，因为重心父亲以上的不是子树而是连通块，**这只是为了叙述的严谨~~和方便~~**~~，实际上树上连通块还是树~~。

如果有某个连通块 $size_x\ge A$，**一定可以构造**，否则**必定无解**，为了~~看起来短~~行文方便把证明放在了最后。

考虑扩展到图上，先求出 DFS 树并取重心，不一样的是这里还有非树边。

众所周知的是 DFS 树上的非树边只有返祖边（不知道请重学 DFS 树），那么可能造成的影响只会是重心某些子树和重心的父亲以上的连通块连通了。

那么我们直接将那些子树挂在父亲连通块上即可，即把子树的 $size$ 加给父亲连通块的 $size$，结论同上，即有 $size_x\ge A$，**一定可以构造**，否则**必定无解**，为了~~看起来短~~行文方便也把证明放在了最后。

[代码](https://www.luogu.com.cn/paste/67w1u7a1)

------------

一些其实很显然的证明：（如果您意会到了可以不看我冗长的证明）

- 树部分：

  首先证明反面必定无解，由重心划分出来的每个连通块都有 $size_x<A$，所以它们本身不能构成合法的 $A$ 连通块。
  
  那么为了构成 $A$，我们只能选择重心以及一些子树，但这样剩下的子树都被重心划分开来，并且 $size_x<A\le B$，故无法构成合法的 $B$ 连通块。
  
  再证明正面有解：先选了一个不包含重心的连通块，有 $size_x$ 个点，剩下了 $n-size_x$ 个点。
  
  由于重心的性质，$size_x\le \frac{n}{2}$，那么$n-size_x\ge \frac{n}{2}$，由于 $A+B+C=n,A\le B\le C$，故 $n=A+B+C\ge B+C\ge 2B$，即证。
  
- 图部分：

  考虑与树不同的部分，首先反面无解的证明不变，而正面有解有所变化。
  
  如果本来就有连通块 $size_x\ge A$ 证明同上，否则一定是由于父亲连通块合并了子树变大导致其 $size'\ge A$。
  
  考虑最后一次合并一定有 $size'=size_x'+size_y< 2A$，那么这个剩下的连通块还有 $n-size'>n-2A=A+B+C-A-A\ge B$ ，即剩下的连通块大小是有 $B$ 的，即证。

---

## 作者：Rainbow_qwq (赞：8)

双极定向做法（

假设 $a\le b\le c$，我们想找到大小为 $a,b$ 的连通块，染为两种颜色。

容易发现，至多有一个点双有两种颜色。建立圆方树，枚举一个方点，钦定这个点双中可能有两种颜色。

假设以方点为根，得到若干个子树。分类讨论：

- 若最大的子树大小 $>n-a$，则此方点无解。
- 若最大的子树大小 $\ge b$，则在该子树中选一个 $b$ 连通块，其余选一个 $a$ 连通块，构造完毕。
- 否则所有子树大小 $<b$。对所有圆点做双极定向，按照定向的顺序排序，取一个前缀作为 $a$，一个后缀作为 $b$，由于双极定向的性质，前后缀各自连通。

一个个加入前缀的子树，某次加入子树从 $<a$ 变成 $\ge a$ 的时候，这一个前缀一定 $<a+b$。

则剩余后缀的大小 $>n-a-b=c\ge b$。

对于前后缀各自取 $a,b$ 大小连通块，构造完毕。

---

## 作者：zac2010 (赞：7)

不妨设 $a\leq b\leq c$，则此时让集合 $A,B$ 联通的限制一定是最松的。于是我们的任务就是找出两个大小分别为 $a,b$ 的连通块。

* 需要知道的一点：假设我们找到了一个大于目标大小的连通块，构造时只需要一个一个地把叶子剥掉直至大小合法就行了。

先考虑原图是树的情况。由于 $b\leq c$，故满足 $b\leq\lfloor \frac{n}{2}\rfloor$。也就是说，我们要找到最大的一条边，使得它两侧的点尽量均匀分布。考虑把重心提为根，对于所有重心的所有子树中大小最大的一颗，判断它的大小是否 $\geq a$，假若是，必定有解；否则无解。

* 证明。

  有解：大小大于 $a$ 的一颗子树可以通过剥叶子得到大小得到 $A$。根据树的重心性质其余部分大小 $\geq\lfloor \frac{n}{2}\rfloor$，而 $b\leq\lfloor \frac{n}{2}\rfloor$，必定也可以通过剥叶子得到 $B$。

  无解：考虑一颗子树还没法得到 $a$，要让连通块扩大，就必须包含重心，那其余的所有子树就不连通了。而 $B$ 又不可能只在一颗子树中取，所以无解。

接下来回归一般图的情况。我们任取一颗 $\text{DFS}$ 树（此时重心不一定为根结点），继续考虑重心 $u$ 的子树。我们钦定 $u$ 上方的子树为 $T$，$u$ 下方的子树为 $S_1,S_2,S_3,...,S_l$，假若 $\max(|S_1|,|S_2|,|S_3|,...,|S_l|)\geq a$，则按照前面所述的剥叶子方法求解（$|S|$ 表示子树 $S$ 的结点个数）。

对于剩下的情况，继续判断：如果 $S_i$ 中与 $T$ 中有连边的子树与 $T$ 的大小和 $<a$，则必定无解。

否则，只需要逐个往 $A$ 中加入和 $T$ 相连的连通块，直到大小 $\geq a$。因为所有 $Si$ 都小于 $a$，所以剩下的连通块大小一定 $\geq n-2a\geq b$，从中剥叶子选出 $B$ 集合即可。

* 对于“ $S_i$ 中与 $T$ 中有连边的子树与 $T$ 的大小和 $<a$”必定无解的证明：为什么大小和 $<a$ 无解。考虑 $T$ 以及与它有连边的所有 $S_i$，它们靠剥叶子得到 $A$ 显然都不可能，故而必须要包含重心；而这样一来，剩余的 $S_j$ 就不连通了，再加上所有 $|S_j|<a$，故而不合法。
* 为什么 $n-2a\geq b$。根据题目条件，$n-a-c=b$，而 $a<c$，故而成立。

---

## 作者：duyi (赞：4)

**洛谷的 markdown 版本太低，造成了严重的格式问题，请务必前往我的博客查看**：[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/14364145.html#loj3176-%E3%80%8Cioi2019%E3%80%8D%E6%99%AF%E7%82%B9%E5%88%92%E5%88%86)


# LOJ3176 「IOI2019」景点划分

[题目链接](https://loj.ac/p/3176)

---

对三个点集的大小，不妨设 $a\leq b\leq c$。

称一个“连通”的节点集合为“连通块”（关于“连通”的定义可以见题面）。那么问题相当于，在图上找出两个连通块，使得它们交为空，且大小分别为 $a, b$ 或 $a, c$ 或 $b, c$。

对于任意点数 $ > 1$ 的连通块，我们总是可以删去一个节点，使得剩下的节点仍然连通。也就是说，我们总是可以把大的连通块变小。因此，如果存在一种方案，划分出了大小为 $a$ 和 $c$ 的连通块，那么也必存在方案能划分出大小为 $a$ 和 $b$ 的连通块。$b, c$ 同理。于是我们只需要考虑，如何划分出两个大小分别为 $a, b$ 的连通块即可。

考虑图是一棵树的情况。显然，此时有解的充分必要条件是：存在一条边，使得边两侧的子树大小分别不小于 $a$ 和 $b$。可以枚举每条边并判断。

虽然树上的问题已经解决了，但为了给一般图上的做法做铺垫，我们进一步挖掘此时的性质。给出树的**重心**的定义及其基本性质：

> $\mathrm{son}_r(u)$ 表示以 $r$ 为根时 $u$ 的儿子的集合。定义 $\mathrm{size}_r(u)$ 表示以 $r$ 为根时，$u$ 的子树大小。定义 $f(u) = \max_{v\in\mathrm{son}_u(u)}\{\mathrm{size}_u(v)\}$，即以 $u$ 为根时，$u$ 的最大的儿子子树的大小。取 $f(u)$ 最大的节点 $u$，即为树的重心。如有多个（最多只有两个），可取任意一个。
>
> 性质：如果 $u$ 是树的重心，那么 $\forall v \in\mathrm{son}_u(u)$，$\mathrm{size}_u(v)\leq \lfloor\frac{n}{2}\rfloor$。

考虑树的重心 $c$。发现有解的充分必要条件是，以 $c$ 为根时，存在一个 $c$ 的儿子子树大小 $\geq a$。也就是说：只需要枚举和 $c$ 相连的边即可！

> **证明**：
>
> 充分性：因为 $b\leq c$ 且 $b + c = n - a \leq n$，所以 $b\leq \lfloor\frac{n}{2}\rfloor$。又因为重心的所有儿子子树大小 $\leq \lfloor\frac{n}{2}\rfloor$，所以删去那个大小 $\geq a$ 的儿子子树后，剩余部分的大小 $\geq n - \lfloor\frac{n}{2}\rfloor \geq b$。
>
> 必要性：如果所有子树的大小都 $< a$，意味着任意一个大小为 $a$ 的连通块和大小为 $b$ 的连通块，都必须包含重心。所以无法满足两连通块交为空这一条件，故无解。

回到一般图上的情况。建出 $\text{DFS}$ 树。找到 $\text{DFS}$ 树的重心 $c$。记 $\text{DFS}$ 树上 $c$ 上方的部分（除 $c$ 子树外的部分）为 $T$，$c$ 的儿子子树分别为：$S_1, S_2, \dots, S_k$。考虑几种情况：

- 如果 $T$ 或某个 $S_i$ 的大小 $\geq a$，那么和树的情况是一样的，可以构造出解。
- 如果 $T$ 和所有 $S_i$ 的大小都 $< a$。就需要考虑无向图 $\text{DFS}$ 树的性质：不存在横叉边。所以不同的 $S_i$ 之间是没有连边的。同时，可能有一些 $S_i$ 会与 $T$ 相连。
  - 如果所有与 $T$ 相连的 $S_i$ 加上 $T$ 的大小之和 $< a$，那么一定无解：因为任意一个大小为 $a$ 的连通块和大小为 $b$ 的连通块，都必须包含重心，所以无法满足两连通块交为空这一条件。
  - 否则考虑一个点集 $X$，初始时为空。先把 $T$ 加入 $X$。然后依次把和 $T$ 相连的 $S_i$ 加入 $X$（可以以任意顺序），直到 $X$ 的大小不小于 $a$ 为止。因为所有 $S_i$ 大小都 $< a$，所以最终 $X$ 的大小一定 $< 2a$。又因为 $2a + b\leq a + b + c = n$，所以在删除 $X$ 后，剩余节点数量 $\geq n - 2a\geq b$。此时，我们一定能在 $X$ 里构造出连通块 $A$，在剩余节点里构造出连通块 $B$。做法比较简单：
    - 先将 $T$ 加入 $A$，然后在 $X$ 中的每个 $S_i$ 里，找一个与 $T$ 相连的点加入 $A$（记为这个点为 $u_i$）。把所有 $u_i$ 加入后，如果大小还是不够，再将每个 $S_i$ 里的其他点加入，为了保证联通，可以从每个 $u_i$ 开始，在子树里 $\text{DFS}$。
    - 对于 $B$，先将重心 $c$ 加入 $B$，然后把不在 $X$ 里的子树依次加入即可。同样，为了保证联通，可以从子树的根开始 $\text{DFS}$。

综上所述，我们证明了一种情况的无解性，并对除此之外的情况给出了构造方案。

时间复杂度 $\mathcal{O}(n + m)$。

[参考代码-在LOJ查看](https://loj.ac/s/1076479)

---

**总结**：

从图是一棵树的特殊情况入手思考，发现和**重心**相关的性质。然后把思路迁移到 $\text{DFS}$ 树中。在本题里，重心的性质带来的好处是：如果一个子树大小 $\geq a$，那么另一侧一定能构造出 $b$。然后只需要思考所有子树都 $< a$ 的情况即可。

**归类**：DFS树。

**难度**：难。



---

## 作者：teylnol_evteyl (赞：3)

看大佬们都是 $O(n)$ 的构造，我太菜了，想不出这样解法，用一些随机化乱搞过去。

首先，不妨 $a<b<c$，构造大小为 $a$ 和 $b$ 的连通点集，因为如果存在一个大小为 $c$ 的连通点集，一定可以在里面找一个大小为 $a$ 和 $b$ 的，也就是说，更小的连通点集更容易构造。

来看一棵树的情况。如果存在一个子树，大小为 $x$，如果满足 $x\ge a$ 且 $n-x\ge b$，则可以在 $x$ 的子树中找个大小为 $a$ 的连通点集，在 $x$ 的子树外面找一个大小为 $b$ 的连通点集；$x\ge b,n-x\ge a$ 同理。

找一棵生成树，可以想象用一种随机化的方法。对边随机打乱，加入生成树中，跑一遍构造。多随机几次生成树。

但显然，如果存在一个点度数接近 $n$，则这种方法的生成树中这个点的度数也会很大，导致很难找到答案。

有三种解决方法：

- 在刚才的解法中，规定有这个点的边最后加入生成树。
- 固定两个点，对这两个点分别随机扩展一个连通点集。
- 在上面的解法中，把其中一个点设为度数最大的点。

于是可以通过洛谷和 LOJ 的数据了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 4e5 + 5;

int n, m, a, b, c, p1, p2, p3, deg[N], t;
struct edge{
	int u, v;
}e[N];
int pe[N];
int la[N], ne[N], en[N], idx;
int size[N], fa[N], res[N];
mt19937 mrand(time(0));

inline void add(int a, int b)
{
	ne[ ++ idx] = la[a];
	la[a] = idx;
	en[idx] = b;
}
inline int gfa(int i) {return i == pe[i] ? i : pe[i] = gfa(pe[i]);}
inline void kruskal()
{
	shuffle(e + 1, e + m + 1, mrand);
	for(int i = 1; i <= n; i ++ ) pe[i] = i, la[i] = fa[i] = 0;
	idx = 0;
	int p = mrand() & 1;
	if(p)
	{
		for(int i = 1; i <= m; i ++ )
		{
			int x = gfa(e[i].u), y = gfa(e[i].v);
			if(x != y)
			{
				pe[x] = y;
				add(e[i].u, e[i].v), add(e[i].v, e[i].u);
			}
		}
	}
	else
	{
		for(int i = 1; i <= m; i ++ )
		{
			if(deg[e[i].u] + deg[e[i].v] >= n / 3) continue ;
			int x = gfa(e[i].u), y = gfa(e[i].v);
			if(x != y)
			{
				pe[x] = y;
				add(e[i].u, e[i].v), add(e[i].v, e[i].u);
			}
		}
		for(int i = 1; i <= m; i ++ )
		{
			if(deg[e[i].u] + deg[e[i].v] < n / 3) continue ;
			int x = gfa(e[i].u), y = gfa(e[i].v);
			if(x != y)
			{
				pe[x] = y;
				add(e[i].u, e[i].v), add(e[i].v, e[i].u);
			}
		}
	}
}

inline void dfs1(int u)
{
	size[u] = 1;
	for(int i = la[u]; i; i = ne[i])
	{
		int v = en[i];
		if(v != fa[u])
		{
			fa[v] = u;
			dfs1(v);
			size[u] += size[v];
		}
	}
}
inline void dfs2(int u, int fa, int &cnt, int t)
{
	res[u] = t;
	cnt -- ;
	for(int i = la[u]; i && cnt; i = ne[i])
	{	
		int v = en[i];
		if(!res[v] && v != fa) dfs2(v, u, cnt, t);
	}
}

bool check()
{
	kruskal(), dfs1(1);
	for(int i = 1; i <= n; i ++ )
	{
		if(size[i] >= a && n - size[i] >= b)
		{
			dfs2(i, fa[i], a, p1), dfs2(fa[i], i, b, p2);
			for(int i = 1; i <= n; i ++ ) if(!res[i]) res[i] = p3, c -- ;
			return 1;
		}
		if(size[i] >= b && n - size[i] >= a)
		{
			dfs2(i, fa[i], b, p2), dfs2(fa[i], i, a, p1);
			for(int i = 1; i <= n; i ++ ) if(!res[i]) res[i] = p3;
			return 1;
		}
	}
	return 0;
}

inline bool check1()
{
	shuffle(e + 1, e + m + 1, mrand);
	for(int i = 1; i <= m; i ++ ) add(e[i].u, e[i].v), add(e[i].v, e[i].u);
	int x = mrand() % n + 1, y = mrand() % (n - 1) + 1;
	if(x == y) y ++ ;
	if(mrand() & 7) y = t;
	if(x == y) y ++ ;
	res[x] = p1, res[y] = p2;
	int ca = a, cb = b;
	dfs2(x, 0, ca, p1), dfs2(y, 0, cb, p2);
	if(!ca && !cb)
	{
		for(int i = 1; i <= n; i ++ ) if(!res[i]) res[i] = p3;
		return 1;
	}
	for(int i = 1; i <= n; i ++ ) la[i] = res[i] = 0, idx = 0;
	return 0;
}

int main()
{
	scanf("%d%d%d%d%d", &n, &m, &a, &b, &c);
	p1 = 1, p2 = 2, p3 = 3;
	if(a > c) swap(a, c), swap(p1, p3);
	if(b > c) swap(b, c), swap(p2, p3);
	
	for(int i = 1; i <= m; i ++ ) scanf("%d%d", &e[i].u, &e[i].v), e[i].u ++ , e[i].v ++ , deg[e[i].u] ++ , deg[e[i].v] ++ ;
	for(int i = 1; i <= n; i ++ ) if(deg[i] > deg[t]) t = i;
	int k = 300000 / m;
	for(int i = 1; i <= k; i ++ ) if(check()) break ;
	if(!res[1])
	{
		memset(la, 0, sizeof la), idx = 0;
		for(int i = 1; i <= k; i ++ ) if(check1()) break ;
	}
	for(int i = 1; i <= n; i ++ ) printf("%d ", res[i]);
	return 0;
}
```

---

## 作者：Sol1 (赞：2)

不难发现可以通过 BFS 从一个大小为 $S$ 的连通块里面提取出一个大小为 $S'\leq S$ 的连通块。于是让 $A,B,C$ 里面最大的集合不连通的方案是最容易构造的。

所以假设 $a\leq b\leq c$，则原题相当于要求我们将原图里面所有点划分成两个点集 $V_1,V_2$，使得 $V_1,V_2$ 的生成子图均连通，并且 $|V_1|\geq a,|V_2|\geq b$ 或者 $|V_1|\geq b,|V_2|\geq a$。

由于 $|V_1|+|V_2|=n$，所以最后一个条件等价于 $a\leq |V_1|\leq n-b$ 或 $b\leq |V_1|\leq n-a$。又注意到 $b\leq c<n-b$，所以该条件等价于 $a\leq |V_1|\leq n-a$。

考虑建出原图的圆方树。那么此时，任意一个节点的子树里面所有的圆点构成的点集一定是连通的，且任意一个节点的子树外面所有的圆点构成的点集也是连通的。

所以如果能找到一个子树，满足其中圆点的个数在 $[a,n-a]$ 内，那么就做完了。

如果不能找到，也就是任意子树中圆点的个数 $<a$ 或 $>n-a$，则圆方树上存在一个点，以这个点为根时，它的所有子树中圆点的个数都 $<a$。

如果这个点是一个圆点，那么说明原图中存在一个点，删去这个点以后图分为若干个大小 $<a$ 的连通块。这显然是无解情况：选一个大小 $\geq a$ 的连通块就一定会选到这个割点，然后就一定无法选一个大小 $\geq b\geq a$ 的连通块。

如果这个点是一个方点，那么让圆方树以该点为根，设其所有孩子分别为 $u_1,u_2,\cdots,u_k$，其子树里面圆点的个数分别为 $w_{u_1},w_{u_2},\cdots,w_{u_k}$。

由于 $u_1,u_2,\cdots,u_k$ 构成一个点双连通分量，所以我们可以在它们之间建出一棵 DFS 树。如果这棵树上存在一个子树满足子树里面所有点的 $w$ 的和在 $[a,n-a]$ 内，那么就找到了一个合法的划分。

如果仍不存在，则相当于存在一个 $x$，满足 $u_x$ 的子树里面的 $w$ 的和 $>n-a$ 但是 $u_x$ 的所有孩子的子树里面的 $w$ 的和 $<a$。

但是现在我们有两个很好的性质：

- 树是一棵 DFS 树，所以所有非树边都是返祖边。
- 原图点双连通，所以移除 $u_x$ 以后图连通。

也就是说，对于任意一个 $u_x$ 的孩子 $v$，都存在一条非树边 $e$ 连接它的子树里面和 $u_x$ 的子树外面。而如果我们将树边 $(u_x,v)$ 从树里面删掉，将 $e$ 加入树，则 $v$ 的子树将会移动到 $u_x$ 的子树外面。

所以我们的算法流程就是找到 $u_x$，并不断将 $u_x$ 的孩子的子树移出，直到 $u_x$ 的子树里面 $w$ 的和在 $[a,n-a]$ 内。

注意到 $a\leq \dfrac{1}{3}n< \dfrac{2}{3}n\leq n-a$，所以每次移出一个子树，$u_x$ 的子树里面 $w$ 的和减少的量 $<\dfrac{1}{3}n$，因此它不能直接从一个 $>\dfrac{2}{3}n$ 的值减少到一个 $<\dfrac{1}{3}n$ 的值，所以一定会有一个时刻落在 $[a,n-a]$ 里面。

这样这道题就做完了，复杂度 $O(n+m)$。

```cpp
const int N = 0xAE3803 - 0xAA5100;

vector <int> g[N], tr[N], st[N];
int n, m, dfn[N], low[N], _time, stk[N], stktop, nds, siz[N], col[N], ncnt[4], nidx[4], fa[N], ans[N], ctr;
int w[N], wsm[N], vis[N], dvp;
queue <int> que;

inline void Read() {
    n = qread(); m = qread();
    for (int i = 1;i <= 3;i++) ncnt[nidx[i] = i] = qread();
    for (int i = 1;i <= m;i++) {
        int u = qread() + 1, v = qread() + 1;
        g[u].push_back(v); g[v].push_back(u);
    }
}

inline void Tarjan(int u, int fa) {
	dfn[u] = low[u] = ++_time;
	stk[++stktop] = u;
	for (int v : g[u]) {
		if (!dfn[v]) {
			Tarjan(v, u);
			low[u] = min(low[u], low[v]);
			if (low[v] >= dfn[u]) {
				nds++;
				for (;;) {
					int x = stk[stktop];
					stktop--;
					tr[nds].push_back(x);
					tr[x].push_back(nds);
					//cout << x << "<->" << nds << endl;
					if (x == v) break;
				}
				tr[u].push_back(nds);
				tr[nds].push_back(u);
				//cout << u << "<->" << nds << endl;
			}
		} else if (v != fa) low[u] = min(low[u], dfn[v]);
	}
}

inline void Dfs1(int u) {
    int mxsz = 0;
    siz[u] = (u <= n);
    for (int v : tr[u]) {
        if (v != fa[u]) {
            fa[v] = u;
            Dfs1(v);
            siz[u] += siz[v];
            mxsz = max(mxsz, siz[v]);
        }
    }
    mxsz = max(mxsz, n - siz[u]);
    if (mxsz <= n / 2) ctr = u;
}

inline void Dfs2(int u, int fa, int c) {
    col[u] = c;
    for (int v : tr[u]) {
        if (v != fa) Dfs2(v, u, c);
    }
}

inline void Prefix() {
    nds = n;
    Tarjan(1, -1);
    sort(nidx + 1, nidx + 4, [&](const int &x, const int &y) {
        return ncnt[x] < ncnt[y];
    });
}

inline void Dfs3(int u) {
    vis[u] = 2;
    for (int v : g[u]) {
        if (vis[v] == 1) {
            st[u].push_back(v);
            Dfs3(v);
        }
    }
}

inline void Dfs4(int u) {
    wsm[u] = w[u];
    for (int v : st[u]) {
        Dfs4(v); wsm[u] += wsm[v];
    }
}

inline void Dfs5(int u, int c) {
    col[u] = c;
    for (int v : st[u]) Dfs5(v, c);
}

inline void Divide() {
    Dfs1(1);
    for (int i = 1;i <= nds;i++) {
        if (siz[i] >= ncnt[nidx[1]] && n - siz[i] >= ncnt[nidx[2]]) {
            for (int j = 1;j <= n;j++) col[j] = nidx[2];
            Dfs2(i, fa[i], nidx[1]);
            return;
        }
        if (siz[i] >= ncnt[nidx[2]] && n - siz[i] >= ncnt[nidx[1]]) {
            for (int j = 1;j <= n;j++) col[j] = nidx[1];
            Dfs2(i, fa[i], nidx[2]);
            return;
        }
    }
    if (ctr <= n) return;
    for (int v : tr[ctr]) {
        if (v == fa[ctr]) w[v] = n - siz[ctr];
        else w[v] = siz[v];
        vis[v] = 1;
    }
    Dfs3(fa[ctr]); Dfs4(fa[ctr]);
    bool flg = 0;
    for (int v : tr[ctr]) {
        if (wsm[v] >= ncnt[nidx[1]] && n - wsm[v] >= ncnt[nidx[2]]) {
            for (int v : tr[ctr]) col[v] = nidx[2];
            Dfs5(v, nidx[1]);
            flg = 1;
            break;
        }
        if (wsm[v] >= ncnt[nidx[2]] && n - wsm[v] >= ncnt[nidx[1]]) {
            for (int v : tr[ctr]) col[v] = nidx[1];
            Dfs5(v, nidx[2]);
            flg = 1;
            break;
        }
    }
    if (!flg) {
        for (int u : tr[ctr]) {
            int mxs = 0;
            for (int v : st[u]) mxs = max(mxs, wsm[v]);
            if (mxs < ncnt[nidx[1]] && n - wsm[u] < ncnt[nidx[1]]) {
                int ndc = st[u].size();
                int cur = n - wsm[u];
                for (int i = 0;i < ndc;i++) {
                    cur += wsm[st[u][i]];
                    if (cur >= ncnt[nidx[1]] && n - cur >= ncnt[nidx[2]]) {
                        for (int v : tr[ctr]) col[v] = nidx[1];
                        col[u] = nidx[2];
                        for (int j = i + 1;j < ndc;j++) Dfs5(st[u][j], nidx[2]);
                        goto done;
                    }
                    if (cur >= ncnt[nidx[2]] && n - cur >= ncnt[nidx[1]]) {
                        for (int v : tr[ctr]) col[v] = nidx[2];
                        col[u] = nidx[1];
                        for (int j = i + 1;j < ndc;j++) Dfs5(st[u][j], nidx[1]);
                        goto done;
                    }
                }
            }
        }
        done:;
    }
    for (int v : tr[ctr]) Dfs2(v, ctr, col[v]);
}

inline void Bfs(int cid) {
    while (!que.empty()) que.pop();
    for (int i = 1;i <= n;i++) {
        if (col[i] == cid) {
            que.push(i);
            ans[i] = cid;
            break;
        }
    }
    int tot = 1;
    if (ncnt[cid] == 1) return;
    for (;;) {
        int u = que.front();
        que.pop();
        for (int v : g[u]) {
            if (col[v] == col[u] && ans[v] == nidx[3]) {
                ans[v] = cid;
                tot++;
                que.push(v);
                if (tot == ncnt[cid]) return;
            }
        }
    }
}

inline void Solve() {
    if (col[1] == 0) {
        for (int i = 1;i <= n;i++) cout << 0 << " ";
        cout << endl;
        return;
    }
    for (int i = 1;i <= n;i++) ans[i] = nidx[3];
    Bfs(nidx[1]); Bfs(nidx[2]);
    for (int i = 1;i <= n;i++) cout << ans[i] << " ";
    cout << endl;
}
```










---

## 作者：Mirasycle (赞：1)

不妨设 $a\le b\le c$。由于我们可以从大联通块中不断删叶子节点得到小联通块，所以我们发现小联通块是更好构造的，于是我们就是要找到两个大小分别为 $a$ 和 $b$ 的联通块。把剩下点分配给 $c$ 即可。

我们需要尽可能均匀分配，所以联想到重心。对于树，我们找到重心，如果重心的一个最大子树 $\ge a$，就有解。否则无解。因为重心的任意一个子树大小都是 $\le \dfrac{n}{2}$。而 $a\le b\le c$ 保证了 $b\le \dfrac{n}{2}$，所以如果能找到这么一个子树，那么剩下点给 $b$ 用一定合法。反之如果找不到的话，那么 $a$ 就必须占据重心位置，而 $b$ 只能选择重心的某个子树，由于 $\rm {maxsize} < a\le b$，所以矛盾了。

对于非树，我们先找到一个 dfs 树，找到 dfs 树的重心，如果能找到一个子树大小 $\ge a$ 还是可以同理构造。否则我们可以利用返祖边，首先添加 $u$ 上方子树，不断添加 $u$ 下方的与 $u$ 上方子树有连边的子树，直到大小 $\ge a$，由于之前的 $\rm {maxsize}<a$，所以当前联通块大小 $<2a$，$n-2a\ge b$，故一定合法。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int dfn[maxn],low[maxn],Fa[maxn],n,m,a,b,c;
int sz[maxn],ans[maxn],id,tot=0,type=0;
vector<int> G[maxn],E[maxn],A,B,C; bool f1=0,f2=0,f3=0;
void dfs(int u,int fa){
	sz[u]=1; Fa[u]=fa; int S=0;
	dfn[u]=low[u]=++tot;
	for(auto v:G[u]){
		if(dfn[v]){ cmin(low[u],dfn[v]); continue; } 
		dfs(v,u); sz[u]+=sz[v]; E[u].pb(v);
		cmax(S,sz[v]); cmin(low[u],low[v]);
	}
//	cout<<u<<" "<<sz[u]<<endl;
	cmax(S,n-sz[u]); if(S<=n/2) id=u;
}
void dfs(int u,int ban,vector<int>& S,int up){
	if(S.size()==up||u==ban||ans[u]) return ;
	S.pb(u);
	for(auto v:E[u]) dfs(v,ban,S,up); 
}
void build(){
	for(auto u:A) ans[u]=1;
	if(type==1) dfs(1,0,B,b);
	else dfs(id,0,B,b);
	for(auto u:B) ans[u]=2; 
	for(int i=1;i<=n;i++)
		if(!ans[i]) C.pb(i);
	if(f3) swap(A,B); if(f2) swap(B,C); if(f1) swap(A,B);
	for(auto u:A) ans[u]=1; for(auto u:B) ans[u]=2; for(auto u:C) ans[u]=3;
	for(int i=1;i<=n;i++) cout<<ans[i]<<" "; exit(0);
}
int main(){
//	freopen("t.in","r",stdin);
//	freopen("t.out","w",stdout);
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m>>a>>b>>c;
	if(a>b) swap(a,b),f1=1; if(b>c) swap(b,c),f2=1; if(a>b) swap(a,b),f3=1;
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v; u++; v++;
		G[u].pb(v); G[v].pb(u);
	}
	dfs(1,0); bool flag=0;
	for(auto u:E[id]){
		if(u==Fa[id]) continue;
		if(sz[u]>=a){
			dfs(u,0,A,a);
			flag=1; break;
		}
	}
	if(flag) type=1,build();
	if(id==1){ for(int i=1;i<=n;i++) cout<<0<<" "; return 0; }
	dfs(1,id,A,a);
	if(A.size()>=a) type=2,build();
	for(auto u:E[id]){
		if(low[u]>=dfn[id]||u==Fa[id]) continue;
		dfs(u,0,A,a);
		if(A.size()>=a) break;
	}
	if(A.size()>=a) type=2,build();
	for(int i=1;i<=n;i++) cout<<0<<" ";
	return 0;
}
```

---

## 作者：LimpidSlirm (赞：1)

## 题意 

给定一个连通图，构造一个方案将其划分成 $A,B,C$ 三个部分，大小分别为 $a,b,c$，要求至少有两个部分为原图的联通子图。

## Solution

先考虑如果是一颗树怎么做。不妨设 $a\le b\le c$，这样就只需要考虑 $a,b$，剩下的部分置成 $c$ 即可。容易发现 $a\le b\le \frac{n}{2}$，故考虑以重心为根节点，如果最大的子树大小大于等于 $a$ 且小于 $n-b$ 则直接把它弄成 $A$，然后暴力去跑一个大小为 $b$ 的集合就可以了。如果最大的子树大小小于 $a$ 的话就必然无解，直接特判掉。

对于图而言，可以先缩点，然后在 deg 上面考虑，转化上面的树上问题。然后发现实在太难写了，一大堆分讨以及乱七八糟的特殊情况。考虑把图变成 dfs 树，这样每个子树就是单独的连通块，似乎很好处理，于是很开心的写掉了。提交然后 subtask 4 和 subtask 5 一片红，一看全是合法方案误判成 `No Solution` 了。细细思考后发现有一种情况没有考虑，即如果重心的子树有到重心的祖先的返祖边，那么这种情况可以把该子树和祖先的那个子树合并成一个连通块，让它们都是 $A$ 类节点，而我没有考虑到这点直接判无解了，加个分类讨论就好了。

关于正确性：显然地如果有一颗子树有到重心的祖先节点有返祖边，那么直接把这个子树丢到 $A$ 集合中，令所有有 $A$ 类节点的子树大小总和为 $\Sigma size_i$，那么显然的有 $a\le \Sigma size_i \lt 2\times a$。又有 $n=a+b+c \ge 2\times a+b$，故剩下的节点数必然大于等于 $b$。

时间复杂度为 $\mathcal{O}(n)$，跑得飞快。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,flag=1;
	char ch=getchar();
	while(!isalnum(ch)) (ch=='-')?flag=-1:1,ch=getchar();
	while(isalnum(ch)) res=res*10+ch-'0',ch=getchar();
	return res*flag;
}
struct edge
{
	int to,nxt;
};
int n,m,tot=1,root,son,las;
int a,b,c;
int id[]={0,1,2,3};
int ans[100010];
int head[100010],size[100010];
bool vis[100010],used[400010],flag[100010];
struct edge ed[400010];
void init(int &a,int &b,int &c)
{
	if(a>b) swap(a,b),swap(id[1],id[2]);
	if(a>c) swap(a,c),swap(id[1],id[3]);
	if(b>c) swap(b,c),swap(id[2],id[3]);
	return ;
}
void add_edge(int fr,int to)
{
	ed[++tot]=(edge){to,head[fr]};
	head[fr]=tot;
	return ;
}
void dfs(int fr,int fa,int &num,int opt,bool type)
{
	if(num==0)
		return ;
	ans[fr]=opt;
	num--;
	for(int i=head[fr];i!=0;i=ed[i].nxt)
	{
		int to=ed[i].to;
		if(to==fa||ans[to]!=0)
			continue;
		if(type==false&&used[i]!=true)
			continue;
		if(type==true&&to==root)
			continue;
		dfs(to,fr,num,opt,type);
	}
	return ;
}
void build(int fr,int fa)
{
	size[fr]=1;
	vis[fr]=true;
	int tmp=0;
	for(int i=head[fr];i!=0;i=ed[i].nxt)
	{
		int to=ed[i].to;
		if(vis[to]==true)
			continue;
		used[i]=used[i^1]=true;
		build(to,fr);
		size[fr]+=size[to];
		if(size[tmp]<size[to])
			tmp=to;
	}
	if(std::max(size[tmp],n-size[fr])<=n/2)
	{
		root=fr,las=fa;
		son=tmp;
	}
	return ;
}
int main(int argc,const char *argv[])
{
	n=read(),m=read();
	a=read(),b=read(),c=read();
	init(a,b,c);
	for(int i=1;i<=m;i++)
	{
		int fr=read()+1,to=read()+1;
		add_edge(fr,to);
		add_edge(to,fr);
	}
	build(1,0);
	if(std::max(size[son],n-size[root])<a)
	{
		dfs(las,root,a,id[1],true);
		dfs(root,0,b,id[2],false);
	}
	else
	{
		if(size[son]<n-size[root])
			son=las;
		dfs(son,root,a,id[1],false);
		dfs(root,0,b,id[2],false);
	}
	for(int i=1;i<=n;i++)
	{
		if(a==0&&ans[i]==0)
			ans[i]=id[3];
		else if(a!=0)
			ans[i]=0;
	}
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：fengwu (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5811)

[博客食用更佳](https://www.cnblogs.com/hzoi-fengwu/p/15090008.html)
# Solution

这个题对我来说可以算是超出了我的能力范围

被学长拿来教我做构造，~~构造题真简单，构造题真是人，构造题真能手切。。。~~

首先对于本题，必须要知道 dfs 树这东西，就是在一个图中得到一个树，

简单来说就是吧所有的边分成树边和非树边，所有的 $n-1$ 个树边会把所有点连接成一颗树。

这个在实现上就是一个 dfs 就好了。

这里有一个小小的性质，在一个 dfs 树中，所有的非树边一定不是横叉边。

意思就是所有的边连接的两个点一定是祖先后代关系。

那么这个题就可以做了。

你会发现这 $a$ , $b$ , $c$ 并没有特殊的要求，所以我们选择这其中较小的那两个一定是优的。

所以我们直接扔掉最大的那个，这时候你会发现。

为了保证我们很顺利的找到答案，我们必须要找到树的重心，

因为在重心两侧，子树的大小一定小于等于 $\frac{n}{2}$ ,而 $a$，$b$ 的大小又小于等于 $\frac{n}{3}$。

这样的话，我们只要保存这个重心，我们可以任意连接子树，从而一定可以满足 $a$ , $b$ 的其中一个。

而剩下的子树中的节点数又一定大于 $a$ ，这样为我们找到答案提供了很大的方便。

那么我们一定先满足 $b$ ，因为我们要是想凑出 $a$ 来一定是比 $b$ 更容易，那么我们接下来的重点就是要找 $a$ 。

首先我们看 $m=n-1$ 的情况,这样的话本来就是一棵树，直接找到重心，判断是不是有子树的大小大于 $a$ ，如果有 ，那么就有解，没有的话，就无解呗。

因为你没有别的边可以连接另外的子树，所以你当前的子树就你你可以找到的所有可以作为 $a$ 的联通块。

而b可以通过重心连接，不需要考虑。

那么这时候你会发现，如果是图的话，那就可以有别的边来连接？？虽然不可以连接在 dfs 树上的子树，

但是别忘了，在 dfs 树上，它的祖先也是他的子树，所以我们只要不断的去连接和它祖先有连边的子树，并且将大小加和。

如果能够得到一个大小为 $a$ 的联通块，那就有解，当然这时候你并没有选重心， $b$ 仍然是合法的。

我们来看这里的重心有什么用，这个重心首先保证了你有一堆大小 $\le\frac{n}{2}$ 的子树。

这样的话，你一定可以凑出一个 $b$ 来，而重心又在一定程度上帮你将整张图分为两部分。

一个是那一堆子树，一个是祖先那边的节点，这就是构造的意义所在。

>构造你想要的条件来解决一般问题。

还有一些要注意的情况，

有可能在图中，你并不能找到合法的反祖边，但是呢，有一颗子树的大小是合法的，

这个时候就要向树的做法一样了，我要去判断一下每一颗子树的大小。

还有输出的时候，千万不要找到一颗子树就开始从他的根节点遍历。

因为你是从有和祖先连边的那个点出发才可以联通的啊，要从他开始。

我的代码中 imp 这个数组就是干这个活的。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define re register int
const int N = 1e5 + 5;
const int M = 2e5 + 5;
int n, m;
pair<int, int> a[4];
int fr[M * 2], to[M * 2], nxt[M * 2], head[N], rp = 1;
void add_edg(int x, int y) {
    to[++rp] = y;
    fr[rp] = x;
    nxt[rp] = head[x];
    head[x] = rp;
}
int fa[N], dep[N], siz[N], rt, mn = 0x3f3f3f3f;
bool vis[N], pd[M * 2];
void dfs(int x) {
    vis[x] = true;
    siz[x] = 1;
    int mx = 0;

    for (re i = head[x]; i; i = nxt[i]) {
        int y = to[i];

        if (vis[y])
            continue;

        fa[y] = x;
        pd[i] = pd[i ^ 1] = true;
        dep[y] = dep[x] + 1;
        dfs(y);
        siz[x] += siz[y];

        if (siz[y] > mx)
            mx = siz[y];
    }

    if (n - siz[x] > mx)
        mx = n - siz[x];

    if (mx < mn)
        mn = mx, rt = x;
}
int imp[N], bl[N], sz[N];
void change(int x, int b) {
    bl[x] = b;
    sz[b]++;

    for (re i = head[x]; i; i = nxt[i]) {
        int y = to[i];

        if (dep[y] != dep[x] + 1)
            continue;

        change(y, b);
    }
}
int ji[N], cnt;
int ans[N];
void biao1(int x) {
    if (cnt == a[1].first)
        return ;

    ans[x] = a[1].second;
    cnt++;

    for (re i = head[x]; i; i = nxt[i]) {
        int y = to[i];

        if (y == rt || dep[y] != dep[x] + 1)
            continue;

        biao1(y);
    }
}
void biao2(int x, int f) {
    if (cnt == a[1].first || ans[x])
        return ;

    ans[x] = a[1].second;
    cnt++;

    for (re i = head[x]; i; i = nxt[i]) {
        int y = to[i];

        if (bl[y] != f || ans[y])
            continue;

        biao2(y, f);
    }
}
void biao3(int x) {
    if (cnt == a[2].first)
        return ;

    ans[x] = a[2].second;
    cnt++;

    for (re i = head[x]; i; i = nxt[i]) {
        int y = to[i];

        if (dep[y] != dep[x] + 1)
            continue;

        biao3(y);
    }
}
signed main() {
    scanf("%d%d", &n, &m);
    scanf("%d%d%d", &a[1].first, &a[2].first, &a[3].first);
    a[1].second = 1;
    a[2].second = 2;
    a[3].second = 3;
    sort(a + 1, a + 4);

    for (re i = 1, x, y; i <= m; i++) {
        scanf("%d%d", &x, &y);
        x++;
        y++;
        add_edg(x, y);
        add_edg(y, x);
    }

    dfs(1);
    siz[0] = n - 1;

    for (re i = head[rt]; i; i = nxt[i]) {
        int y = to[i];

        if (y == fa[rt] || dep[y] != dep[rt] + 1)
            continue;

        change(y, y);
        siz[0] -= sz[y];
    }

    for (re i = 2; i <= rp; i += 2) {
        if (pd[i])
            continue;

        if (siz[0] >= a[1].first)
            break;

        int u = fr[i], v = to[i];

        if (bl[u] && bl[v])
            continue;

        if (!bl[u] && !bl[v])
            continue;

        if (bl[u] && !ji[bl[u]] && (v != rt || siz[0] == 0)) {
            ji[bl[u]] = 1;
            imp[bl[u]] = u;
            siz[0] += sz[bl[u]];
        }

        if (bl[v] && !ji[bl[v]] && (u != rt || siz[0] == 0)) {
            ji[bl[v]] = 1;
            imp[bl[v]] = v;
            siz[0] += sz[bl[v]];
        }
    }

    int flag = 0;

    if (siz[0] < a[1].first) {
        for (re i = head[rt]; i; i = nxt[i]) {
            int y = to[i];

            if (dep[y] != dep[rt] + 1)
                continue;

            if (siz[y] >= a[1].first) {
                siz[0] = siz[y];
                ji[y] = 1;
                imp[y] = y;
                flag = 1;
                break;
            }
        }
    }

    if (siz[0] >= a[1].first) {
        cnt = 0;

        if ((rt != 1 && !flag))
            biao1(1);

        for (re i = head[rt]; i; i = nxt[i]) {
            int y = to[i];

            if (!ji[y] || dep[y] != dep[rt] + 1)
                continue;

            if (cnt >= a[1].first)
                break;

            biao2(imp[y], y); //cout<<siz[y]<<endl;
        }

        cnt = 1;
        ans[rt] = a[2].second;

        for (re i = head[rt]; i; i = nxt[i]) {
            int y = to[i];

            if (ji[y] || dep[y] != dep[rt] + 1)
                continue;

            if (cnt >= a[2].first)
                break;

            biao3(y);
        }
    }

    for (re i = 1; i <= n; i++) {
        if (siz[0] >= a[1].first && !ans[i])
            ans[i] = a[3].second;

        printf("%d ", ans[i]);
    }

}
```

---

## 作者：modfish_ (赞：0)

给大家带来超长代码。

## 思路
不知道为什么，反正看到这题我马上想到了圆方树，所以我就往圆方树上使劲想，这也就导致了长达 6.96k 的代码。

以下钦定 $a\le b\le c$。

让我们来思考问题的本质：你需要将原图划分为**两个**连通块，使得其中一个大小大于等于 $a$，另一个大小大于等于 $b$。

为什么是两个呢？如果你划出了很多个，把多的并到一起，一定可以只剩下两个。

设其中一个的大小为 $x$，那么应有 $x\ge a,n-x\ge b$，或者 $x\ge b,n-x\ge a$，并起来是 $a\le x\le b+c$，所以只要找到一个大小介于 $a$ 和 $b+c$ 之间的连通块，**并使其补集连通**，就可以了。

找到划分方案后在图上随便染一染就完了。下面我们来讨论如何找划分方案。

首先如果你能在圆方树上找到一个大小（只算圆点）大于等于 $a$ 且小于等于 $b+c$ 的子树，那就已经结束了。

否则，可以发现：一定存在一个点，它的所有子树大小都比 $a$ 小。

---
#### 证明
假定这样的子树不存在，那么因为不存在大小介于 $a$ 和 $b+c$ 之间的子树，所以每个点都有一个子树大小大于 $b+c$，而 $b+c>\lfloor\frac{n}{2}\rfloor$，说明这棵树没有重心，显然不可能。

---

如果这个点是圆点，那么无解。

---
#### 证明
可以发现，除了这个点之外，所有点都有一个大于 $b+c$ 的子树，所以两个连通块的分界点不可能在这些点上（否则必有一个大小大于 $b+c$）。

所以，只有可能分界点在这个圆点上，然而无论圆点属于哪个连通块，都会导致另一个连通块大小小于 $a$，不符要求，所以无解。

---

如果这个点是方点，那么我们把这个点双连通分量单独拿出来，跑一棵 DFS 生成树，在树上做一遍类似的判断（此时每个点带权，权值为圆方树上的子树大小），如果有一个子树大小介于 $a$ 和 $b+c$ 之间，那么结束。

否则，仍然必定有一个点 $x$，它的每一个子树大小都比 $a$ 小。我们希望把它的子树和它本身划分成为两部分，使得两部分大小都介于 $a$ 和 $b+c$ 之间。

先不论方法，划分完后这两部分是否可以各自连通呢？答案是肯定的。考虑 $x$ 在生成树上的父亲所在的子树，它和 $x$ 的每一个子树都必有连边（因为这是一个点双连通分量，所以不存在割点），那么和 $x$ 的父亲划在一起的子树必定联通，剩下的子树，只要和 $x$ 在同一个连通块内就可以了。

接下来是方法：先把 $x$ 的父亲的子树大小减去 $x$ 的权值，然后把 $x$ 的所有邻居按子树大小从大到小排序。维护两个集合，每次拿出一个子树，放在大小较小的集合那边，最后把 $x$ 放在 $x$ 的父亲的对面。

可以证明，最后两个集合的大小（不计入 $x$）都在 $a-v$ 与 $b+c-v$ 之间（$v$ 为 $x$ 的权值）。

---
#### 正确性证明
$x$ 的权值为 $v$，则所有子树大小权值和为 $n-2v$（因为 $x$ 的父亲已减去 $v$）

假设某次放完后，有一个集合的大小大于 $b+c-v$，则此时另一个集合大小必定小于 $a-v$ 且不等于 $0$。因为每次都往较小集合放，所以这一次加入的值必定大于 $b+c-a$，然而 $b+c-a\ge a+a-a=a$，即这一次放入的数不小于 $a$，矛盾。

因此，最终的两个集合的大小都在 $a-v$ 与 $b+c-v$ 之间。

---

所以把按照上面的做就可以了，时间复杂度 $O(n)$。

## 代码


```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5 + 5;

vector<int> G[maxn], T[maxn << 1], T2[maxn];

int n, a[4], od[4];
int dfn[maxn], low[maxn], dnt = 0, tot = 0;
int st[maxn], tp = 0;
void Tarjan(int x){
    dfn[x] = low[x] = ++ dnt, st[++ tp] = x;
    for(int i = 0; i < G[x].size(); i ++){
        int j = G[x][i];
        if(dfn[j]) low[x] = min(low[x], dfn[j]);
        else{
            Tarjan(j);
            low[x] = min(low[x], low[j]);
            if(low[j] == dfn[x]){
                tot ++;
                while(tp && st[tp] != j) T[st[tp]].push_back(tot), T[tot].push_back(st[tp]), tp --;
                T[j].push_back(tot), T[tot].push_back(j), tp --;
                T[x].push_back(tot), T[tot].push_back(x);
            }
        }
    }
}
int siz1[maxn << 1], fa1[maxn << 1], c[maxn], tag[maxn];
int dfs1(int x, int f, int &r){
    siz1[x] = x <= n, fa1[x] = f;
    int ms = 0;
    for(int i = 0; i < T[x].size(); i ++){
        int j = T[x][i];
        if(j == f) continue;
        int res = dfs1(j, x, r);
        if(res) return res;
        siz1[x] += siz1[j];
        if(siz1[j] >= a[1] && siz1[j] <= a[2] + a[3]){
            r = j;
            return 1;
        }
        ms = max(ms, siz1[j]);
    }
    if(n - siz1[x] >= a[1] && n - siz1[x] <= a[2] + a[3]){
        r = x;
        return 2;
    }
    ms = max(ms, n - siz1[x]);
    if(ms < a[1]){
        r = x, siz1[f] = n - siz1[x];
        return 3;
    }
    return 0;
}
void color(int x, int &rst, int col){
    if(!rst) return;
    if(x <= n && rst) c[x] = col, rst --;
    for(int i = 0; i < G[x].size(); i ++){
        int j = G[x][i];
        if(c[j]) continue;
        color(j, rst, col);
    }
}
void color2(int x, int f, int &rst, int col){
    for(int i = 0; i < T[x].size(); i ++){
        int j = T[x][i];
        if(j == f) continue;
        if(x <= n) color2(j, x, rst, col);
        else{
            color(j, rst, col);
            break;
        }
    }
}
void color1(int x, int y, int &rstx, int colx, int &rsty, int coly){
    if(x <= n && rstx) c[x] = colx, rstx --;
    if(y <= n && rsty) c[y] = coly, rsty --;
    color2(x, y, rstx, colx), color2(y, x, rsty, coly);
}
void color3(int x, int f, int &rst, int col, int r){
    if(rst) c[x] = col, rst --, color2(x, r, rst, col);
    for(int i = 0; i < T2[x].size(); i ++){
        int j = T2[x][i];
        if(j == f) continue;
        color3(j, x, rst, col, r);
    }
}
int vis[maxn], siz2[maxn], fa2[maxn];
void build(int x, int f){
    vis[x] = 1;
    siz2[x] = siz1[x], fa2[x] = f;
    for(int i = 0; i < G[x].size(); i ++){
        int j = G[x][i];
        if(vis[j] || !tag[j]) continue;
        T2[x].push_back(j), T2[j].push_back(x);
        build(j, x);
        siz2[x] += siz2[j];
    }
}
int dfs2(int x, int f, int &s){
    int ms = 0;
    for(int i = 0; i < T2[x].size(); i ++){
        int j = T2[x][i];
        if(j == f) continue;
        int res = dfs2(j, x, s);
        if(res) return res;
        if(siz2[j] >= a[1] && siz2[j] <= a[2] + a[3]){
            s = j;
            return 1;
        }
        ms = max(ms, siz2[j]);
    }
    if(n - siz2[x] >= a[1] && n - siz2[x] <= a[2] + a[3]){
        s = x;
        return 2;
    }
    ms = max(ms, n - siz2[x]);
    if(ms < a[1]){
        s = x, siz2[f] = n - siz2[x] - siz1[x];
        return 3;
    }
    return 0;
}
pair<int, int> ps[maxn];
int s1[maxn], sn1 = 0, s2[maxn], sn2 = 0;
int pt = 0;

int main(){
    int m;
    scanf("%d %d %d %d %d", &n, &m, &a[1], &a[2], &a[3]);
    if(a[1] <= a[2] && a[2] <= a[3]) od[1] = 1, od[2] = 2, od[3] = 3;
    else if(a[1] <= a[3] && a[3] <= a[2]) od[1] = 1, od[2] = 3, od[3] = 2;
    else if(a[2] <= a[1] && a[1] <= a[3]) od[1] = 2, od[2] = 1, od[3] = 3;
    else if(a[2] <= a[3] && a[3] <= a[1]) od[1] = 2, od[2] = 3, od[3] = 1;
    else if(a[3] <= a[1] && a[1] <= a[2]) od[1] = 3, od[2] = 1, od[3] = 2;
    else od[1] = 3, od[2] = 2, od[3] = 1;
    sort(a + 1, a + 4);
    tot = n;
    for(int i = 1; i <= m; i ++){
        int u, v;
        scanf("%d %d", &u, &v);
        u ++, v ++;
        G[u].push_back(v), G[v].push_back(u);
    }
    Tarjan(1);
    int r = 0;
    int res = dfs1(1, 0, r);
    if(res < 3){
        if(res == 1){
            if(siz1[r] <= a[1] + a[3]) color1(r, fa1[r], a[1], od[1], a[2], od[2]);
            else color1(r, fa1[r], a[2], od[2], a[1], od[1]);
        }else{
            if(n - siz1[r] <= a[1] + a[3]) color1(fa1[r], r, a[1], od[1], a[2], od[2]);
            else color1(fa1[r], r, a[2], od[2], a[1], od[1]);
        }
        for(int i = 1; i <= n; i ++){
            if(c[i] == 0) c[i] = od[3];
            printf("%d ", c[i]);
        }
        printf("\n");
        return 0;
    }
    if(r <= n){
        for(int i = 1; i <= n; i ++) printf("0 ");
        printf("\n");
        return 0;
    }
    int rt = 0;
    for(int i = 0; i < T[r].size(); i ++) tag[T[r][i]] = 1, rt = T[r][i];
    build(rt, 0);
    int s = 0;
    res = dfs2(rt, 0, s);
    if(res < 3){
        if(res == 1){
            if(siz2[s] <= a[1] + a[3]) color3(s, fa2[s], a[1], od[1], r), color3(fa2[s], s, a[2], od[2], r);
            else color3(s, fa2[s], a[2], od[2], r), color3(fa2[s], s, a[1], od[1], r);
        }else{
            if(n - siz2[s] <= a[1] + a[3]) color3(fa2[s], s, a[1], od[1], r), color3(s, fa2[s], a[2], od[2], r);
            else color3(fa2[s], s, a[2], od[2], r), color3(s, fa2[s], a[1], od[1], r);
        }
    }else{
        for(int i = 0; i < T2[s].size(); i ++){
            int j = T2[s][i];
            ps[++ pt] = make_pair(-siz2[j], j);
        }
        int x1 = 0, x2 = 0;
        sort(ps + 1, ps + pt + 1);
        int where_s = 0;
        for(int i = pt; i >= 1; i --){
            if(x1 <= x2){
                x1 -= ps[i].first;
                if(ps[i].second == fa2[s]) where_s = 2;
                else s1[++ sn1] = ps[i].second;
            }else{
                x2 -= ps[i].first;
                if(ps[i].second == fa2[s]) where_s = 1;
                else s2[++ sn2] = ps[i].second;
            }
        }
        x1 += siz1[s], x2 += siz1[s];
        if(x1 <= a[1] + a[3]){
            if(where_s == 1) a[1] --, c[s] = od[1], color2(s, r, a[1], od[1]);
            else color3(fa2[s], s, a[1], od[1], r);
            for(int i = 1; i <= sn1; i ++) color3(s1[i], s, a[1], od[1], r);
            if(where_s == 2) a[2] --, c[s] = od[2], color2(s, r, a[2], od[2]);
            else color3(fa2[s], s, a[2], od[2], r);
            for(int i = 1; i <= sn2; i ++) color3(s2[i], s, a[2], od[2], r);
        }else{
            if(where_s == 1) a[2] --, c[s] = od[2], color2(s, r, a[2], od[2]);
            else color3(fa2[s], s, a[2], od[2], r);
            for(int i = 1; i <= sn1; i ++) color3(s1[i], s, a[2], od[2], r);
            if(where_s == 2) a[1] --, c[s] = od[1], color2(s, r, a[1], od[1]);
            else color3(fa2[s], s, a[1], od[1], r);
            for(int i = 1; i <= sn2; i ++) color3(s2[i], s, a[1], od[1], r);
        }
    }
    for(int i = 1; i <= n; i ++){
        if(c[i] == 0) c[i] = od[3];
        printf("%d ", c[i]);
    }
    printf("\n");
    return 0;
}
```

---

## 作者：Zelotz (赞：0)

[P5811](https://www.luogu.com.cn/problem/P5811)

**Hint**. 不妨设 $a\le b\le c$，你觉得哪个部分不必要是连通块。先思考树上的情况。

首先注意到我们一定能够从连通块中不断删点得到更小的连通块，染出两个大小为 $a,b$ 的连通块显然是更简单的。所以问题转化成把原图划分成两个连通块，一个大小至少 $a$，一个大小至少 $b$。

先考虑树上的情况，显然枚举每一条树边，并判断两端大小是否满足即可。

转到图上，可以先跑一边 DFS 树，转为树上的情况，若存在一条树边满足则直接输出答案。

否则，考虑重心的每个子树。注意到 $b\le \dfrac{n}{2}$，而重心具有 $\forall siz \le \dfrac{n}{2}$ 的性质，如果重心的一个子树 $siz \ge a$，则 $n-siz\ge \dfrac{n}{2} \ge b$，一定在前面已经被判定为合法。所以，重心连接的所有子树一定 $siz < a$。

如果一个子树内没有连向重心祖先的返祖边，则这个子树必然和重心属于同一个连通块（否则无法让这棵子树所在连通块大小 $\ge a​$）。

把所有这样的子树和重心合成一个连通块，如果这个连通块的大小大于 $n-a$ 则无解。

否则构造一个初始解，重心的子树放在 $B$ 集合，其余部分放在 $A$ 集合。

显然 $|B|>n-a,|A|<a$。依次把 $B$ 集合中，所有有连向重心祖先返祖边的子树移到 $A$ 集合中，直到 $|A|\ge a$ （等价于 $|B| \le n - a$）为止。此时 $|A|\ge a,|B|\le n-a$ ，现在只需满足 $|B|\ge b$ 即可。

可以证明这样的到的 $|B|\ge b$。注意到 $B$ 集合中子树大小都 $<a$，对于 $|B|$ 从 $>n-a$ 变为 $\le n-a$ 的一次变换，变换后的 $|B| > n-a-a>n-a-b=c\ge b$ 。得证。

在实现时可以用 $low$ 数组判断返祖边，注意输出时根据调换的 $a,b,c​$ 调整输出。

```
const int N = 3e5 + 5;
int n, m, A, B, C, rt, idx, sz[N], mx[N], ans[N], pa[N], low[N], dfn[N];
bool vis[N];
vector <int> E[N], G[N];
void dfstree(int x) {
    dfn[x] = low[x] = ++idx; 
    for (int v : G[x]) {
        if (vis[v]) {
            low[x] = min(low[x], dfn[v]);
            continue;
        }
        vis[v] = 1;
        E[x].push_back(v), E[v].push_back(x);
        pa[v] = x;
        dfstree(v);
        low[x] = min(low[x], low[v]);
    }
}
void init(int x, int fa) {
    sz[x] = 1; 
    for (int v : E[x]) {
        if (v == fa) continue;
        init(v, x);
        sz[x] += sz[v];
        mx[x] = max(mx[x], sz[v]);
    }
    mx[x] = max(mx[x], n - sz[x]);
    if (!rt || mx[x] < mx[rt]) rt = x;
}
void color(int x, int fa, int col, int &siz) {
    if (!siz || vis[x]) return ; 
    vis[x] = 1;
    ans[x] = col, --siz;
    for (int v : E[x]) {
        if (v == fa) continue;
        color(v, x, col, siz);
    }
}
vector <int> son1, son2;
int id[4];
void print() {
    R(i, 1, n) printf("%d ", id[ans[i]]);
    exit(0);
}
signed main() {
    read(n, m, A, B, C);
    if (A <= B && B <= C) id[1] = 1, id[2] = 2, id[3] = 3;
    else if (A <= C && C <= B) id[1] = 1, id[2] = 3, id[3] = 2;
    else if (B <= A && A <= C) id[1] = 2, id[2] = 1, id[3] = 3;
    else if (B <= C && C <= A) id[1] = 2, id[2] = 3, id[3] = 1;
    else if (C <= A && A <= B) id[1] = 3, id[2] = 1, id[3] = 2;
    else id[1] = 3, id[2] = 2, id[3] = 1;
    if (B > C) swap(B, C);
    if (A > B) {
        swap(A, B);
        if (B > C) swap(B, C);
    }
    R(i, 1, m) {
        int u, v; read(u, v); ++u, ++v;
        G[u].push_back(v), G[v].push_back(u);
    }
    vis[1] = 1;
    dfstree(1); 
    memset(vis, 0, sizeof vis); R(i, 1, n) ans[i] = 3;
    init(1, 0); 
    R(i, 1, n) {
        if (sz[i] >= A && (n - sz[i]) >= B) color(i, pa[i], 1, A), color(pa[i], 0, 2, B), print();
        else if ((n - sz[i]) >= A && sz[i] >= B) color(i, pa[i], 2, B), color(pa[i], 0, 1, A), print();
    }
    for (int v : E[rt]) {
        if (v == pa[rt]) continue;
        if (low[v] < dfn[rt]) son1.push_back(v);
        else son2.push_back(v);
    }
    int sum = 1;
    for (int v : son2) sum += sz[v];
    if (sum > n - A) {
        R(i, 1, n) printf("%d ", 0);
        return 0;
    }
    int oa = A;
    color(pa[rt], rt, 1, A); 
    sum = sz[rt];
    for (int v : son1) {
        sum -= sz[v];
        color(v, rt, 1, A);
        if (sum <= n - oa) break;
    }
    color(rt, pa[rt], 2, B);
    print();
    return 0;
}
```

---

## 作者：happybob (赞：0)

不妨令 $a\leq b\leq c$。如果题目输入的不满足则可以交换。我们只考虑构造两个大小分别为 $a$ 和 $b$ 的连通块。其他点全都在 $C$ 中。考虑如果选的大小不是 $a$ 和 $b$ 连通块，比如选的是 $a$ 和 $c$，那么可以把 $C$ 中某些点删掉并不影响连通性，使得这个连通块大小为 $b$。 

先考虑原图是一棵树的时候怎么办？不妨枚举每一条边，设两边子树大小分别为 $x,y(x \leq y)$。若 $x \geq a$ 且 $y \geq b$，则显然可以在两侧选连通块。

然而注意到这个事情不优美，不容易拓展到图上，我们考虑是否需要对每条边都这样考虑。事实上，我们找到树的重心，考虑将树视为以重心为根的树。考虑重心的某个儿子，如果子树大小 $\geq a$，则一定有解。否则无解。

证明：

先证明充分性，即如果存在子树大小 $\geq a$，必然有解。我们只需要在这个子树中选 $a$ 个点即可。考虑还剩多少点。除了这个子树，还剩 $n-sz_u$ 个点。由于我选的是重心，$sz_u \leq \dfrac{n}{2}$，故 $n-sz_u \geq \dfrac{n}{2}$。由于 $a+b+c=n$ 且 $a\leq b\leq c$。必然有 $b \leq \dfrac{n}{2}$。所以通过重心和其他子树一定能构造出这样的连通块。

接着证明如果不存在这样的子树则无解。如果不存在这样的子树，那么对于 $a$ 这个连通块而言，必然是经过重心以及大于等于 $2$ 个子树所形成的。那么对于 $b$ 而言只能选重心的某个子树。但是如果能选出这样的子树，由于 $b \geq a$，必然也能选出对于 $a$ 也成立的子树。故矛盾。

于是树上问题就处理完了。

考虑图上问题。我们想让图和树有联系，必然是求出图的一棵 DFS 生成树，找出重心。如果重心有一个儿子子树大小 $\geq a$，就直接做完了。但是如果不存在这样的子树，我们注意到图上还有一些非树边，这些边可能会影响答案。此时不一定是无解了。

考虑 DFS 生成树的根为 $1$，选出的重心为 $u$。不妨令 $u \neq 1$。考虑到这是 DFS 生成树，非树边必然是返祖边，于是集合 $A$ 必然是 $u$ 子树外的所有点和 $u$ 的某些儿子的子树中的若干个点。不包含 $u$。我们枚举 $u$ 所有儿子，判断这个子树是否有返祖边能回去，如果有就累加子树大小。如果子树大小 $\geq a$ 就有解，否则无解。

证明：

考虑最终累加的子树大小必然是 $<2a$ 的，因为最后一步累加的 $<a$，之前的也 $<a$。此时图上至少还有 $n-2a$ 个点。同时又有 $a+b+c=n$，故图上还有 $a+b+c-2a=b+c-a$ 个点。由于 $c \geq a$，必然有 $b+c-a \geq b$，于是我们必然可以选出这个大小为 $b$ 的集合。

于是整个题就做完了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <cassert>
#include <queue>
#include <vector>
using namespace std;

const int N = 2e5 + 5;

int n, m;
vector<int> G[N];
int A, B, C, rA, rB, rC;

int sz[N], fa[N];
int ans[N];
bool vis[N];
vector<int> NG[N];
int wc;
pair<int, int> a[5];
int id[N], idx, ra[N];

void dfs(int u, int f)
{
	id[u] = ++idx;
	ra[idx] = u;
	fa[u] = f;
	vis[u] = 1;
	int maxn = 0;
	sz[u] = 1;
	for (auto& j : G[u])
	{
		if (vis[j]) continue;
		NG[u].emplace_back(j);
		NG[j].emplace_back(u);
		dfs(j, u);
		sz[u] += sz[j];
		maxn = max(maxn, sz[j]);
	}
	maxn = max(maxn, n - sz[u]);
	if (maxn <= (n / 2)) wc = u;
}

int cnt = 0;

void Get_A(int u, int fa)
{
	ans[u] = a[1].second;
	cnt++;
	if (cnt == A) return;
	for (auto& j : NG[u])
	{
		if (j == fa) continue;
		Get_A(j, u);
		if (cnt == A) return;
	}
}

void Get_B(int u, int fa)
{
	if (ans[u]) return;
	ans[u] = a[2].second;
	cnt++;
	if (cnt == B) return;
	for (auto& j : NG[u])
	{
		if (j != fa)
		{
			Get_B(j, u);
			if (cnt == B) return;
		}
	}
}

class Union_Find
{
public:
	int fa[N];
	void Init()
	{
		for (int i = 0; i < N; i++) fa[i] = i;
	}
	int find(int u)
	{
		return (fa[u] == u ? u : fa[u] = find(fa[u]));
	}
	void merge(int u, int v)
	{
		fa[find(u)] = find(v);
	}
}uf;

bool flag[N];
int sflag[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m >> A >> B >> C;
	rA = A, rB = B, rC = C;
	a[1] = make_pair(A, 1);
	a[2] = make_pair(B, 2);
	a[3] = make_pair(C, 3);
	sort(a + 1, a + 4);
	A = a[1].first, B = a[2].first, C = a[3].first;
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		cin >> u >> v;
		u++, v++;
		G[u].emplace_back(v);
		G[v].emplace_back(u);
	}
	dfs(1, 0);
	for (auto& j : NG[wc])
	{
		int szs = 0;
		if (j == fa[wc])
		{
			szs = n - sz[wc];
		}
		else szs = sz[j];
		if (szs >= A)
		{
			Get_A(j, wc);
			cnt = 0;
			Get_B(wc, 0);
			for (int i = 1; i <= n; i++)
			{
				if (!ans[i]) ans[i] = a[3].second;
			}
			for (int i = 1; i <= n; i++) cout << ans[i] << " ";
			cout << "\n";
			return 0;
		}
	}
	int faf = fa[wc];
	do
	{
		flag[faf] = 1;
		faf = fa[faf];
	} while (faf);
	int szs = n - sz[wc];
	vector<int> v;
	for (auto& j : NG[wc])
	{
		if (j == fa[wc]) continue;
		bool fg = 0;
		for (int k = id[j]; k < id[j] + sz[j]; k++)
		{
			for (auto& p : G[ra[k]])
			{
				if (flag[p]) fg = 1;
			}
		}
		if (!fg) continue;
		szs += sz[j];
		v.emplace_back(j);
		if (szs >= A)
		{
			Get_A(fa[wc], wc);
			for (auto& k : v)
			{
				Get_A(k, wc);
			}
			cnt = 0;
			Get_B(wc, 0);
			for (int i = 1; i <= n; i++)
			{
				if (!ans[i]) ans[i] = a[3].second;
			}
			for (int i = 1; i <= n; i++) cout << ans[i] << " ";
			cout << "\n";
			return 0;
		}
	}
	for (int i = 1; i <= n; i++) cout << "0 ";
	cout << "\n";
	return 0;
}
```


---

## 作者：NBest (赞：0)

原题链接:[P5811 [IOI2019] 景点划分](https://www.luogu.com.cn/problem/P5811)
## 题意
给定一张 $n$ 个点 $m$ 条边的无向连通图，以及三个整数 $a, b, c$，满足 $a + b + c = n$。你需要将 $n$ 个顶点分成三个集合 $A, B, C$，大小分别为 $a, b, c$，使得其中的至少两个集合是连通的(集合中的任意两个点能只经过该集合内的点互相到达)。

## 思路
其实就是找到两个联通块满足一个 $\ge a$，另外一个 $\ge b$，多余的都扔到 $C$ 里面去，我们让小的成为联通，最大的 $C$ 不保证联通肯定不劣，那么就可以设 $a\le b\le c$，我们保证 $A,B$ 联通即可。

那如何在取出一个联通块之后不影响剩下部分的联通性呢？没头绪，让我们看看部分分。

考虑原图是一个树的情况，我们发现，我们任意去掉一个子树，子树本身联通，剩下的部分肯定也联通，那么因为 $a\le b$，我们得令剩下的部分不下于子树，这个时候想到重心。重心的最大子树（包括父亲子树）的大小 $\le \dfrac{n}{2}$，剩下的部分一定可以满足 $b$ 的限制，那我们只需要在子树中找一个 $\ge a$ 的子树即可，如果找不到，剩下的点构成的次大子树肯定都是小于 $a$ 的，那就无解。

推广到图呢？此时我们也不管那么多先跑出一棵 dfs 树，如果此时树的重心的最大子树仍然 $\ge a$，那用同样的方法分就好了。

如果不是呢？很套路地想到 dfs 树的性质，非树边只有返祖边。

这个性质有什么用呢？我们假设重心为 $G$，重心的子树分成父亲子树（理解为除掉这个子树后父亲为根的子树）和普通子树。

我们发现普通子树中的点的非树边要么连向内部，要么连向 $G$，要么连向父亲子树。连向内部的边无用，连向 $G$ 的不能取，因为 $G$ 连接的更大的剩余部分是留给 $B$ 的，那我们是不是可以考虑把一些普通子树与父亲子树合并使得其**恰好** $\sum size\ge a$。

每次合并前的两棵子树（合并了的子树也算进去）必然 $< a$，那么合并之后 $\sum size < 2a$，那么剩余联通部分的大小 $>n-2a$，而 $b=n-a-c<n-2a$，所以这样合并我们就得到了我们想要的一个 $\ge a$ 和一个 $\ge b$ 的联通块了，满足题意。那如果全部合并完了也不能使 $\sum size \ge a$ 的话，我们把合并了的子树看成原来与树一样的子树，还是不存在次大子树 $\ge a$ 的点，那么就无解了。

这题不需要什么很复杂的算法，只需要一直深搜就行了。

具体细节和实现可以参考代码，我这个代码确实可能比较冗长了，如果大家觉得麻烦可以去看别的巨佬的简洁一点的代码。
### $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100005;
int read(){
    int x=0,f=1;char c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}
int n,m,sizA,sizB,sizC,A=1,B=2,C=3,tota,totb;
int siz[N],dep[N],G,SIZ[N],hs[N],fa[N];
//子树大小,深度,重心位置，重心大小，重儿子，父亲。
vector<int>f[N];
int ans[N];//染色后的答案
bool isF[N],is_sub[N];//是不是父亲树部分/子树部分
void dfs(int x){//算重心，以及处理诸如dep之类的父子信息
    dep[x]=dep[fa[x]]+1;
    siz[x]=1;
    for(int y:f[x]){
        if(dep[y])continue;//遍历过就继续
        fa[y]=x;
        dfs(y);
        siz[x]+=siz[y];
        if(siz[hs[x]]<siz[y])hs[x]=y;//记录重儿子
    }
    SIZ[x]=max(siz[hs[x]],n-siz[x]);//算最大子树
    if(SIZ[x]<SIZ[G])G=x;//最大子树最小的就是重心
}
inline bool condition(int k,int x,int y){//不同情况的染色需要满足的条件
    //将这个点在dfs树上的子树部分染色:
    if(k==0)return dep[y]==dep[x]+1;//不是儿子就不行
    //将这个点在 dfs树上的父亲树部分染色:
    if(k==1)return isF[y];//不在子树就不行
    //随意染色，能染则染:
    if(k==2)return 1;//记录过就不行，其他都行
    //用于只能在指定子树和非子树染色:
    if(k==3)return (is_sub[y]||isF[y]);//没有记录过并且在指定子树上
}
void paint(int x,int c,int k){//因为不同地方的染色方法就差一个条件，所以整合了一下
    if(c==A&&tota>=sizA)return;//k 表示不同情况的染色
    if(c==B&&totb>=sizB)return;
    if(c==A)tota++;
    else totb++;
    ans[x]=c;
    for(int y:f[x])
        if(!ans[y]&&condition(k,x,y))paint(y,c,k);
    return;
}
bool dfs2(int x){//判断这个子树能不能返祖到非子树上去与非子树结合
    for(int y:f[x]){
        if(isF[y])return 1;//如果可以返祖到父亲树则可以联通
        if(dep[y]!=dep[x]+1)continue;
        if(dfs2(y))return 1;//如果下面有回到父亲树的返祖边也能联通
    }
    return 0;//都不行就不行
}
void dfs3(int x,bool w){//把不在G以及其子树的部分得到（父亲树的部分）
    isF[x]=w;
    for(int y:f[x]){
        if(dep[y]!=dep[x]+1)continue;//直接遍历儿子（没有重边和横叉边，保证是儿子）
        if(y==G)dfs3(y,0);
        else dfs3(y,w);
    }
}
void dfs4(int x){//可联通子树染色
    is_sub[x]=1;//是不是可联通子树的节点
    for(int y:f[x]){
        if(dep[y]!=dep[x]+1)continue;
        dfs4(y);
    }
}
int main(){
    n=read(),m=read(),sizA=read(),sizB=read(),sizC=read();
    if(sizA>sizB)swap(A,B),swap(sizA,sizB);//从小到大排序
    if(sizA>sizC)swap(A,C),swap(sizA,sizC);
    if(sizB>sizC)swap(B,C),swap(sizB,sizC);
    for(int i=1;i<=m;i++){
        int u=read()+1,v=read()+1;//下面都是从 1 开始，这样比较方便
        f[u].push_back(v),f[v].push_back(u);
    }
    SIZ[0]=n;
    dfs(1);
    dfs3(1,(G!=1));//注意根节点不能是重心
    if(SIZ[G]>=sizA){//如果有子树大于A
        if(SIZ[G]==siz[hs[G]])//如果是子树之一就往下染色
            paint(hs[G],A,0);
        else paint(fa[G],A,1);//往上染色
        paint(G,B,2);
        for(int i=1;i<=n;i++)
            printf("%d ",ans[i]?ans[i]:C);
        return 0;
    }
    int sum=n-siz[G];
    for(int y:f[G]){
        if(dep[y]!=dep[G]+1)continue;//不是相邻的不行，不然同一棵子树内的点可能算了多次
        if(dfs2(y))sum+=siz[y],dfs4(y);//标记为可联通子树
        if(sum>=sizA)break;
    }
    if(sum>=sizA){
        paint(fa[G],A,3);//标记了的点都能染
        paint(G,B,2);//让重心出发的随便染色
        for(int i=1;i<=n;i++)
            printf("%d ",ans[i]?ans[i]:C);
    }else{
        for(int i=1;i<=n;i++)
            printf("0 ");
    }
    return 0;
}
```

---


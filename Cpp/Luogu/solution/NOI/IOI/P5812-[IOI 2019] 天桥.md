# [IOI 2019] 天桥

## 题目背景

# 滥用本题评测将封号

注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。

## 题目描述

Kenan 为沿着巴库大街某一侧的建筑和天桥绘制了一张规划图。规划图中有 $n$ 栋建筑，从 $0$ 到 $n-1$ 编号。还有 $m$ 座天桥，从 $0$ 到 $m-1$ 编号。这张规划图绘制在一张二维平面上，其中建筑和天桥分别是垂直和水平的线段。

第 $i$（$0 \le i \le n-1$） 栋建筑的底部坐落在坐标 （$x[i],0$） 上，建筑的高度为 $h[i]$。因此，它对应一条连接点 （$x[i],0$） 和 （$x[i],h[i]$） 的线段。

第 $j$（$0 \le j \le m-1$） 座天桥的两端分别在第 $l[j]$ 栋建筑和第 $r[j]$ 栋建筑上，并具有正的 $y$ 坐标 $y[j]$。因此，它对应一条连接点 （$x[l[j]],y[j]$） 和 （$x[r[j]],y[j]$） 的线段。

称某座天桥和某栋建筑相交，如果它们有某个公共的点。因此，一座天桥在它的两个端点处与两栋建筑相交，同时还可能在中间和其他建筑相交。

Kenan 想要找出从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径长度，或者确认这样的路径不存在。在这里行人只能沿着建筑和天桥行走，并且不允许在地面上行走，也就是说不允许沿着 $y$ 坐标为 $0$ 的水平线行走。

行人能够在任意交点从某座天桥走进某栋建筑，或者从某栋建筑走上某座天桥。如果两座天桥的端点之一在同一点上，行人也可以从其中一座天桥走上另一座天桥。

你的任务是帮助 Kenan 回答他的问题。

**实现细节**

你需要实现下列函数。
`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`

- $x$ 和 $h$：长度为 $n$ 的整数数组。
- $l$、$r$ 和 $y$：长度为 $m$ 的整数数组。
- $s$ 和 $g$：两个整数。
- 如果从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径存在，则该函数应该返回最短路径的长度。否则，该函数应该返回`-1`。

## 说明/提示

**样例说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)

**限制条件**

- $1 \le n,m \le 10^5$。
- $0 \le x[0] < x[1] < \cdots < x[n-1] \le 10^9$。
- $1 \le h[i] \le 10^9$（对于所有 $0 \le i \le n-1$）。
- $0 \le l[j] \le r[j] \le n-1$（对于所有 $0 \le j \le m-1$）。
- $1 \le y[j] \le \min(h[l[j]],h[r[j]])$（对于所有 $0 \le j \le m-1$）。
- $0 \le s,g \le n-1$。
- $s ≠ g$。
- 除在端点处外，任意两座天桥不会有其他公共的点。

**子任务**

1. （$10$ 分）$n,m \le 50$。
2. （$14$ 分）每座天桥最多与 $10$ 栋建筑相交。
3. （$15$ 分）$s=0$，$g=n-1$，且所有建筑的高度相等。
4. （$18$ 分）$s=0$，$g=n-1$。
5. （$43$ 分）没有任何附加限制。

## 样例 #1

### 输入

```
7 7
0 8
3 7
5 9
7 7
10 6
12 6
14 9
0 1 1
0 2 6
0 6 8
2 3 1
2 6 7
3 4 2
4 6 5
1 5```

### 输出

```
27
```

# 题解

## 作者：chen_03 (赞：6)

吐槽：我在网上能找到的所有题解，要么对关键性质的阐述过于简洁，让我这个低水平选手看得云里雾里；要么推广关键性质时的说明过少，或是给出了对想出正解毫无帮助的部分分性质，让题解有失严谨性与逻辑性。

题目想让我们找一条最短路径。虽然这张图是平面图，但最短路径不免错综复杂，所以我们先确定基本思路：建图跑 Dijkstra 最短路。

原图的点数可以达到 $\mathcal{O}(nm)$ 级别，直接跑肯定是不行的，我们考虑**简化**这张图。

我们先考虑一种特殊情况：不存在一座天桥 $[l_i,r_i]$，满足 $l_i<s<r_i$ 或 $l_i<g<r_i$（注意全部是严格小于）。也就是说，任意一座天桥的横坐标范围既不 “横跨” 起点（的横坐标），也不 “横跨” 终点（的横坐标）。

在这种情况下，我们有一个**关键性质**：

> **性质**　存在一条最优路径，满足：若我们自下而上地进入一座天桥，或自上而下地离开一座天桥，那么进入点（或离开点）一定是这座天桥的某个端点。

> **注 1**　“进入” 表示我们之前不在这座天桥上，现在在这座天桥上；“离开” 表示我们之前在这座天桥上，现在不在这座天桥上。不在这座天桥上时，我们可能在某栋建筑上上下移动，也可能在另一座天桥上左右移动。  
> **注 2**　“自下而上地进入” 表示我们进入这座天桥之前，我们在某栋建筑上向上移动；“自上而下地离开” 表示我们离开这座天桥之后，我们在某栋建筑上向下移动。  
> **注 3**　进入点与离开点都一定在某栋建筑上。

> **注 4**　即使路径与这座天桥只有一个交点（公共点），我们也认为这条路径 “进入” 与 “离开” 了这座天桥各一次。

我们先证明其中一种情况。假设现在有一条**最优**路径，它自下而上地进入了一座天桥 $[l_i,r_i]$。天桥 $i$ 满足 $s\le l_i$（这里是小于等于，也就是天桥 $i$ 位于起点右方），且进入点不是天桥 $i$ 的端点。

有三种情况：进入天桥 $i$ 之后，离开天桥 $i$ 之前，我们

1. 向左移动了一段距离（图 $1$）；
2. 向右移动了一段距离（图 $2$）；
3. 没有左右移动（图 $3$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/bq6codcu.png)

以图 $1$ 的情况为例。如图，$S$ 为起点，$AB$ 为进入天桥 $i$ 前向上移动的那一段，$BC$ 为在天桥 $i$ 上的移动，$D$ 为天桥 $i$ 的右端点。$B$ 不是天桥 $i$ 的端点，$C$ 不一定是天桥 $i$ 的端点。明确 $x_S\le x_C$，$AB>0$，$BC>0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/53how3i0.png)

若路径 $S\rightarrow A$ 经过了点 $C$ 所在的建筑 $X$，不妨设 $S\rightarrow A$ 最后一次位于建筑 $X$ 上时在点 $E$ 上，则 $E\rightarrow C$ 的长度严格小于 $E\rightarrow A\rightarrow B\rightarrow C$ 的长度（因为 $BC>0$），替换一下一定更优。这与 “这条路径是最优路径” 矛盾。

那么 $S\rightarrow A$ 没有经过建筑 $X$。设 $S\rightarrow A$ **最后一次**位于横坐标 $x_C$ 上时在点 $F$ 上，那么 $F\rightarrow A$ 的过程中**横坐标始终 $\ge x_C$**。

若 $F\rightarrow A$ 经过了线段 $CD$，不妨设 $F\rightarrow A$ 最后一次位于线段 $CD$ 上时在点 $G$ 上，由 $AB>0$ 得 $G\rightarrow B$ 的长度严格小于 $G\rightarrow A\rightarrow B$ 的长度，同样推出矛盾。

那么 $F\rightarrow A$ 经过了线段 $CD$ 的延长线。设点 $M$ 为点 $D$ 所在的建筑的底端，由前文可得 $F\rightarrow A$ 经过了线段 $DM$。

设 $F\rightarrow A$ 最后一次位于线段 $DM$ 上时在点 $H$ 上，那么 $H\rightarrow D\rightarrow B$ 的长度小于等于 $H\rightarrow A\rightarrow B$ 的长度，要么推出矛盾，要么可以把 $H\rightarrow A\rightarrow B$ 调整为 $H\rightarrow D\rightarrow B$ 而总长度不变。

我们发现 $D$ 是天桥 $i$ 的端点。也就是说，我们可以把路径调整为：自下而上地从天桥 $i$ 的端点 $D$ 进入天桥 $i$。

对于图 $2,3$ 的情况，证明与此类似。图 $2$ 可以调整为从端点 $D$ 进入天桥 $i$，图 $3$ 可以调整为从端点 $D$ 或端点 $E$ 进入天桥 $i$。

> **UPD**　这里我想复杂了。考虑天桥与它两端点所在的建筑构成了 “冂” 形，而起点没有被 “冂” 形包住，所以路径必然经过了 “冂” 形，只要讨论路径最后一次位于 “冂” 形上时在三条线段中的哪一条上即可。  
两种证法本质相同，但这种显然更简洁。

同理，若天桥 $i$ 满足 $r_i\le s$（即天桥 $i$ 位于起点左方），也可以类似地调整。对于 “自上而下地离开” 的情况，讨论天桥 $i$ 与终点 $g$ 的位置关系，用对称的方法证明即可。

到这里我们已经证明了，对于一座**特定的**天桥 $i$，我们可以把路径调整为（对天桥 $i$ 而言）满足**关键性质**的状态。考虑对于一条最优路径不断地（每次选择一座天桥）进行这样的调整，若调整能在有限次内结束则性质得证。

由前文的证明可得，一次调整的过程一定形如下图：若对于天桥 $i$ 进行调整，我们只会改变高度不高于天桥 $i$ 的一段路径。所以我们每次选择最高的不合法的天桥调整即可，这样每座天桥最多被调整一次。于是性质得证。

![](https://cdn.luogu.com.cn/upload/image_hosting/v2e5wffx.png)

上文中我们讨论的都是 “不存在一座天桥 $[l_i,r_i]$ 满足 $l_i<s<r_i$ 或 $l_i<g<r_i$” 的情况。对于一般情况，我们尝试进行一些调整，使之符合条件。

若天桥 $i$ 满足 $l_i<s<r_i$，我们找到与天桥 $i$ 有交的：横坐标最大的满足 $X\le s$ 的建筑 $X$，和横坐标最小的满足 $s\le Y$ 的建筑 $Y$。我们把天桥 $[l_i,r_i]$ 拆成三段：$[l_i,X]$，$[Y,r_i]$，$[X,Y]$。前两段都没有 “横跨” 起点 $s$；对于第三段，可以发现它只与建筑 $X,Y$ 有交，也就是只能通过两个端点进入与离开这座天桥，所以它不可能产生违背**关键性质**的情况。

对于 $l_i<g<r_i$ 的情况，可以类似地进行拆分。不断地进行这样的拆分即可，天桥的总数仍为 $\mathcal{O}(m)$ 级别。

有了这个**关键性质**，我们就可以对原图进行简化了。假设我们从天桥 $i$ 出发向下走到天桥 $j$（没有拐弯，下同），或从天桥 $j$ 出发向上走到天桥 $i$，不难发现，这一过程中经过的所有位于某座天桥上的点，除天桥 $j$ 上的那个点以外，都一定是某座天桥的端点。因此除起点和终点外，我们**只需保留所有天桥的端点，以及每个端点下方第一个位于某座天桥上的点即可**。

这样点数和边数都被缩减到了 $\mathcal{O}(m)$ 级别。时间复杂度一个 $\log$。

如果要问这个**关键性质**是怎么想到的，按我的理解，大概是对着 $s=0$，$g=n-1$ 的部分分画画图找找规律，再推广到一般情况吧。

代码写得很丑，仅供参考。

```cpp
#include <bits/stdc++.h>
#define eb emplace_back
#define ls u<<1
#define rs u<<1|1
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
int n,m,M,S,G,t=1,L,R,x[100005],h[100005],p[100005];
int l[100005],r[100005],y[100005],z[100005];
int ti[400005],a[200015],b[200015],cnt,bg,ed,tot;
vector<pii> vec[100005],e[1200005];
set<int> s;
set<int>::iterator it;
map<int,int> mp[100005];
priority_queue<pli,vector<pli>,greater<pli> > q;
ll dis[1200005];
inline pii calc(int x,pii u,vector<pii> &V){
	it=s.lower_bound(x),R=*it;
	L=*(R^x?--it:it);
	V.eb(pii(u.fi,L)),V.eb(pii(R,u.se));
	u.fi=L,u.se=R;
	return u;
}
void cover(int u,int l,int r,int x,int y,int z){
	if(x<=l && r<=y)return ti[u]=z,void();
	int mid=(l+r)>>1;
	if(x<=mid)cover(ls,l,mid,x,y,z);
	if(y>mid)cover(rs,mid+1,r,x,y,z);
}
int que(int u,int l,int r,int x){
	if(l==r)return ti[u];
	int mid=(l+r)>>1;
	if(x<=mid)return max(ti[u],que(ls,l,mid,x));
	return max(ti[u],que(rs,mid+1,r,x));
}
inline int id(int x,int y){
	if(mp[y].count(x))return mp[y][x];
	return mp[y][x]=++tot;
}
inline void ins(int u,int v,int w){
	e[u].eb(pii(v,w));
	e[v].eb(pii(u,w));
}
inline void work(int k){
	cnt=0;
	for(auto u:vec[k])
		a[++cnt]=u.fi,a[++cnt]=u.se;
	sort(a+1,a+1+cnt);
	cnt=unique(a+1,a+1+cnt)-a-1;
	for(int i=1,u,v;i<=cnt;++i){
		u=id(a[i],k);
		if((v=que(1,1,n,a[i]))==-1)continue;
		ins(u,id(a[i],v),z[k]-z[v]);
	}
	for(auto u:vec[k])
		cover(1,1,n,u.fi,u.se,k);
}
inline void work2(int k){
	cnt=0,t=1;
	for(auto u:mp[k])
		a[++cnt]=u.fi,b[cnt]=u.se;
	sort(vec[k].begin(),vec[k].end());
	for(auto u:vec[k]){
		while(t<=cnt && a[t]<u.fi)++t;
		while(t<cnt && a[t+1]<=u.se)
			ins(b[t],b[t+1],x[a[t+1]]-x[a[t]]),++t;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d%d",x+i,h+i);
		s.insert(i),p[i]=i;
	}
	sort(p+1,p+1+n,[](int X,int Y){
		return h[X]<h[Y];
	});
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",l+i,r+i,y+i);
		++l[i],++r[i],z[i]=y[i];
	}
	sort(z+1,z+1+m);
	M=unique(z+1,z+1+m)-z-1;
	for(int i=1;i<=m;++i){
		y[i]=lower_bound(z+1,z+1+M,y[i])-z;
		vec[y[i]].eb(l[i],r[i]);
	}
	scanf("%d%d",&S,&G),++S,++G;
	if(S>G)swap(S,G);
	for(int i=1;i<=n*4;++i)ti[i]=-1;
	bg=id(S,0),cover(1,1,n,S,S,0);
	ed=id(G,0),cover(1,1,n,G,G,0);
	for(int k=1;k<=M;++k){
		while(t<=n && h[p[t]]<z[k])s.erase(p[t++]);
		for(int i=0;i<(int)vec[k].size();++i){
			pii u=vec[k][i];
			if(u.fi<S && S<u.se)
				vec[k][i]=calc(S,u,vec[k]);
			else if(u.fi<G && G<u.se)
				vec[k][i]=calc(G,u,vec[k]);
		}
		work(k);
	}
	for(int i=1;i<=M;++i)work2(i);
	for(int i=1;i<=tot;++i)dis[i]=2e18;
	dis[bg]=0,q.push(pli(0,bg));
	while(!q.empty()){
		pli t=q.top();q.pop();
		int u=t.se;
		if(dis[u]<t.fi)continue;
		dis[u]=t.fi;
		for(auto v:e[u]){
			if(dis[v.fi]<=dis[u]+v.se)continue;
			dis[v.fi]=dis[u]+v.se;
			q.push(pli(dis[v.fi],v.fi));
		}
	}
	printf("%lld\n",dis[ed]<1e18?dis[ed]:-1);
	return 0;
}
```


---

## 作者：xtx1092515503 (赞：4)

部分分很有启示性。

首先，这一看就应该是一个**最短路**问题，因为我们也没有很好的方法去处理这种路径左右大幅度抽搐的东西，最好的办法便是建出图来然后跑最短路。

首先考虑$n,m\leq50$的暴力分。它给我们的启示便是找出所有天桥与楼房的交点，然后建图跑Dijkstra。明显这个交点数是$O(nm)$级别的，可以通过这档，以及下面的“与十栋建筑相交”的部分分。

然后是$S$在最左边，$T$在最右边的部分分。显然，在这档部分分中，最优路径**不会有折返**——

考虑常见的折返它应该长这样（蓝线）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hanmf3ng.png)

但是我们发现向向红楼房的拐弯实际上是可以避免的——因为绿楼房实际上是与下面天桥相交的（虚线部分），因此直接就从绿楼房上去了。

因此我们就知道了最优路径一定是一路向右的。通过这个，我们还可以证出一个更强的性质：你登上一座天桥，从左端起点上去一定不会更劣。

我们考虑这样一个例子（棕色为路径）：

![](https://cdn.luogu.com.cn/upload/image_hosting/l2bwte9m.png)

在这张图中，棕色路径并没有从黄天桥开始的地方就上去——但是一开始就上去明显是可以的，并且我们观察一下就会发现一开始就上去的路径长度**必定不劣于**磨蹭一会在上去的路径长度——毕竟你多磨蹭一会，就有可能经历更多的上上下下，而直接上去必然不会经历任何上上下下。

因此我们便可以只保留所有天桥的起点终点（我们称之为**关键点**），以及所有关键点所在的建筑**再往下的一个交点**。这个交点是为了方便上桥而必须设立的。

具体做法可以用```set```或```map```啥的维护现在仍未结束的天桥，按照$x$坐标递增的顺序枚举楼房，进行建图。建完跑Dijkstra即可。

~~这些全部写完，你就可以在IOI2019中捞到57分了，惊不惊喜，开不开心~~

100分实际上就是刚才的特例的推广——

我们考虑一条从$s$到$t$的天桥，如果起点是$S$，终点是$T$的话，它们会有什么互动——

1. $[s,t]\subseteq[S,T]$，同上面特例无区别。

2. $[S,T]\subseteq[s,t]$。显然这时候有可能折返，但是凭直觉发现折返不可能折的太远，最多折到第一个可以上去的点就上去了，而这个点是可以预处理出来的。显然$S$方向与$T$方向各最多只有一个，于是我们把它在可以上去的点折为三截即可。

这个可以看图理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/sd4thhuf.png)

折为三截之后，就还像上一问一样建图跑即可。

时间复杂度$O(n\log n)$。假如你像我一样用了布满整个程序的STL（```set```、```map```、```vector```、```priority_queue```我都用了）的话，是很容易TLE的。交的时候随手开了O2，不开不知道能不能过（大概不行

代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
#define DIS(x) sort(x.begin(),x.end()),x.resize(unique(x.begin(),x.end())-x.begin())
typedef long long ll;
const int N=4001000;
int n,m,S,T,tot,ord[N];
pii p[N];//buildings
struct walk{
	int l,r,h;
	friend bool operator<(const walk &x,const walk &y){
		return x.h>y.h;
	}
	walk(){}
	walk(int A,int B,int C){l=A,r=B,h=C;}
}w[N];
bool cmp(const int&x,const int&y){
	return p[x].second>p[y].second;
}
set<int>s;
vector<int>st[N],ed[N],rel[N];
int sum[N];
//--------------Dijkstra--------------
int head[N],cnt;
ll dis[N];
struct node{
	int to,next,val;
}edge[N];
void ae(int u,int v,int w){
//	printf("%d %d %d\n",u,v,w);
	edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
	edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=w,head[v]=cnt++;
}
priority_queue<pair<ll,int> >q;
bool vis[N];
ll Dijkstra(){
	q.push(make_pair(0ll,S)),memset(dis,0x3f,sizeof(dis)),dis[S]=0;
	while(!q.empty()){
		int x=q.top().second;q.pop();
		if(vis[x])continue;vis[x]=true;
		for(int i=head[x];i!=-1;i=edge[i].next)if(dis[edge[i].to]>dis[x]+edge[i].val)dis[edge[i].to]=dis[x]+edge[i].val,q.push(make_pair(-dis[edge[i].to],edge[i].to));
	}
	return dis[T]==0x3f3f3f3f3f3f3f3f?-1:dis[T];
}
map<int,int>mp;
int main(){
	scanf("%d%d",&n,&m),tot=m,memset(head,-1,sizeof(head));
	for(int i=1;i<=n;i++)scanf("%d%d",&p[i].first,&p[i].second),ord[i]=i;
	for(int i=1;i<=m;i++)scanf("%d%d%d",&w[i].l,&w[i].r,&w[i].h),w[i].l++,w[i].r++;
	sort(w+1,w+m+1),sort(ord+1,ord+n+1,cmp);
	scanf("%d%d",&S,&T),S++,T++;
	if(S>T)swap(S,T);
	for(int i=1,j=1;i<=m;i++){
		while(j<=n&&p[ord[j]].second>=w[i].h)s.insert(ord[j++]);
		vector<int>v={w[i].l,w[i].r};
		if(w[i].l<S&&w[i].r>S){
			auto it=s.lower_bound(S);
			int B=*it,A=*--it;
			if(B<=min(T,w[i].r))v.push_back(B);
			else if(A>=w[i].l)v.push_back(A);
		}
		if(w[i].l<T&&w[i].r>T){
			auto it=s.upper_bound(T);
			int B=*it,A=*--it;
			if(A>=max(S,w[i].l))v.push_back(A);
			else if(B<=w[i].r)v.push_back(B);
		}
		DIS(v);
		w[i]=walk(v[0],v[1],w[i].h);
		for(int k=2;k<v.size();k++)w[++tot]=walk(v[k-1],v[k],w[i].h);
	}
	s.clear(),s.insert(0);
	for(int i=1;i<=tot;i++)st[w[i].l].push_back(w[i].h),ed[w[i].r].push_back(w[i].h);
//	for(int i=1;i<=tot;i++)printf("[%d,%d]:%d\n",w[i].l-1,w[i].r-1,w[i].h);
	for(int i=1;i<=n;i++){
		for(auto j:ed[i])s.erase(j);
//		printf("%d:::::\n",i);
//		for(auto j:s)printf("%d ",j);puts("");
		vector<int>v;
		v.push_back(0);
		for(auto j:st[i])v.push_back(j);
		for(auto j:ed[i])v.push_back(j);
		DIS(v);
		rel[i]=v;
		for(int j=1;j<v.size();j++)rel[i].push_back(*--s.lower_bound(v[j]));
		DIS(rel[i]);
//		for(auto j:rel[i])printf("%d ",j);puts("");
		for(int j=1;j<rel[i].size();j++)ae(sum[i]+j+1,sum[i]+j,rel[i][j]-rel[i][j-1]);
		sum[i+1]=sum[i]+rel[i].size();
		for(int j=0;j<rel[i].size();j++){
			if(mp.find(rel[i][j])==mp.end())continue;
			int U=mp[rel[i][j]],V=i;
			int A=sum[U]+lower_bound(rel[U].begin(),rel[U].end(),rel[i][j])-rel[U].begin()+1;
			int B=sum[V]+j+1;
			ae(A,B,p[V].first-p[U].first);
			mp[rel[i][j]]=i;
		}
		for(auto j:ed[i])mp.erase(j);
		for(auto j:st[i])s.insert(j),mp[j]=i;
	}
	S=sum[S]+1,T=sum[T]+1;
	printf("%lld\n",Dijkstra());
	return 0;
}
```


---


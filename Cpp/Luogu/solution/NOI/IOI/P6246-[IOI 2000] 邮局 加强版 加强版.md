# [IOI 2000] 邮局 加强版 加强版

## 题目背景

> 看到你时总是感觉清风徐徐,
>
> 本以为和你相识不会是偶遇,
>
> 奈何你犹如过客、化作秋雨,  
>
> 只是经过我生命的一瓢柳絮,
>
> 从不会真正有童话似的结局.
>
> 我静静地写尽这些躁言丑句,
> 
> 本以为可以稍稍地缓解抑郁.
>
> 却是徒增一场悲伤的脑补剧.
>
> 你问我为什么说这么多?
>
> 因为这题是加强版的 [IOI2000]邮局.

## 题目描述

高速公路旁边有 $n$ 个村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。两个位置之间的距离是其整数坐标差的绝对值。

现在要建立  $m$ 个邮局，邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。

你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。

## 说明/提示

#### 数据规模与约定

本题共五个测试点，各测试点信息如下：

| 测试点编号 | $n = $ | $a_i \leq $ |
| :----------: | :-------: | :----: |
| 1 | $50000$ | $6 \times 10^4$ |
| 2 | $150000$ | $2 \times 10^5$ |
| 3 | $299998$ | $5 \times 10^5$ |
| 4 | $499998$ | $10^6$ |
| 5 | $499999$ | $2\times 10^6$ |

对于全部的测试点，保证 $1 \leq m \leq n \leq 5 \times 10^5$，$0 \leq a_i \leq 2\times 10^6$，且 $a_i$ 的值在对应范围内均匀随机。

保证最终答案不超过 $10^9$。


## 样例 #1

### 输入

```
5 2
0 1 2 3 4```

### 输出

```
3```

# 题解

## 作者：KobeBeanBryantCox (赞：46)

# P6246 [IOI2000] 邮局 加强版 加强版 题解

----------------------------

update on 2025-08-09：修正了错误的代码。之前错误的原因包括但不限于二分队列的边界问题。

感谢[这个](https://www.luogu.com.cn/discuss/1057344)、[这个](https://www.luogu.com.cn/ticket/LKQC301978)、[这个](https://www.luogu.com.cn/discuss/1114079)对本题解的贡献。~~本来还想改一下图的（感觉字太丑了）但是有点懒。~~

[题目传送门](https://www.luogu.com.cn/problem/P6246)。

~~我这个题做了 5 个小时 15 分钟，其中 4 小时 30 分钟理解做法，45 分钟敲代码。~~

~~我是不是好菜啊啊啊。。。~~

------------------------------

## 题意

~~题意不方便表述，还是直接去看原题的题目描述吧。。。~~

---------------------------

## 解法

wqs 二分 + 二分队列。

### 一

考虑暴力的 DP 转移，$f_{i,j}$ 表示前 $i$ 个村庄建立 $j$ 个邮局的最小距离和。

$$f_{i,j}=\min_{1\leq k\leq i}\{{f_{k-1,j-1}+w_{k,i}\}}$$

答案则是 $f_{n,m}$。

其中 $w$ 满足四边形不等式，所以 $f$ 具有凸性。

记 $K_{i,j}=\arg\min_{1\leq k\leq i}\{{f_{k-1,j-1}+w_{k,i}\}}$（$\arg$ 表示最优决策点。）

感性理解发现题目具有决策单调性，即 $K_{i-1,j}\leq K_{i,j}\leq K_{i,j+1}$。

只利用 $K_{i-1,j}\leq K_{i,j}$ 可以分治优化决策单调性，复杂度 $O(nm\log n)$。

同时利用两个条件，调整 DP 顺序（即四边形不等式优化），可以做到 $O(n(n+m))$ 的 DP。

但是优化还不够。

设 $g_i$ 表示 $n$ 个村庄放 $i$ 个邮局的最小距离和。注意到 $g$ 是凸函数。直接计算 $g_m$ 复杂度过高。

考虑构造一个新函数 $g'$，先算出 $g'_m$，再算 $g_m$。

考虑构造如下的新问题：

> $n$ 个村庄放若干个邮局（不限制个数），但每个放邮局会增加 $t$ 的代价。最小化总代价加距离和。

这个问题是可以 $O(n)$ DP 求解的，并且它计算的是 $\min_i\{g_i+ti\}$。

那只要让 $\min_i\{g_i+ti\}=g_m+tm$，就可以求出 $g_m$。

注意到 $g_i+ti$ 也是凸的（证明后面会讲），所以 $t$ 越大，最小值横坐标越小。

故满足单调性，考虑二分 $t$。

以上是 wqs 二分的证明及过程，下面讲讲构造的新问题的解法。

### 二

>  $n$ 个村庄放若干个邮局（不限制个数），但每个放邮局会增加 $t$ 的代价。最小化总代价加距离和。

考虑前 $i$ 个村庄：$f_i=\min_{1\leq k\leq i}\{f_{k-1}+w_{w,i}+t\}$。

其中 $w$ 可以 $O(1)$ 计算（计算方法后面会将）。

记 $K_i=\arg\min_{i\leq k\leq i}\{f_{k-1}+w_{w,i}+t\}$，那么有 $K_{i-1}\leq K_i$。

考虑维护一个集合 $I_k=\{i\in[1,n]:K_i=k\}$ 表示最优决策点为 $k$ 的 $i$。因为题目具有决策单调性，所以这个集合一定是一个区间。

不妨把这个区间记做 $[L_k,R_k]$。

对于已经算出来的 $f_k$，如果已知 $[L_k,R_k]$，那么可以对于 $i\in[L_k,R_k]$ 在 $O(1)$ 时间内算出 $f_i$。而已知 $R_k$，可以二分算出 $R_{k+1}$。只需要找到 $i>R_k$，且 $k+2$ 比 $k+1$ 更优的那个点即可。

~~**上面那句话（指的是从 “ 不妨 ” 开始到这里）没看懂怎么办？没关系，往下看。（看懂的大佬可以直接跳到代码。）**~~

具体化地，根据决策单调性的性质，有 $\forall i<j,R_i\leq L_j$，换句话说，存在一个点 $pos$ 为 $i<j$ 的最优决策点的划分点。

考虑使用一个队列维护 $(i,L_i,R_i)$ 三元组，记为 $qk,ql,qr$。

转移到 $i$ 时，弹出队头直到 $i\in[ql_{head},qr_{head}]$，此时队头是 $i$ 的最优决策，直接转移。

考虑更新队列，如果整个最优决策区间都比 $i$ 要劣，即从 $i$ 转移到 $ql_{tail}$ 优于从 $qk_{tail}$ 转移到 $ql_{tail}$，一直弹出队尾直到不符合条件。

画个图（右边是 $tail$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/4jcok6s7.png)

现在删去了队尾完全无用的转移点，考虑有一个转移区间有些有用有些没用，即 $\exists pos\in[ql_{tail}+1,qr_{tail}]$，满足对于 $pos$ 之前的转移用原来的 $qk_{tail}$ 更优，之后的转移用 $i$ 更优。

显然这样的 $pos$ 满足单调性，故可以二分找到。找到后把区间剖开，加入新元素即可。

画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/15fo9pqf.png)

~~别说我字丑，电脑写字不方便，不知道为什么不能输入字只能写。~~

复杂度：wqs 二分 + 二分队列，一共是 $O(n\log V\log n)$。

-----------------------

## 补充

### 一、关于 $g_i+ti$ 也是凸的的证明

由于 $g_i$ 是凸的~~（这个显而易见吧，不懂的看其他题解）~~，那么有 $g_i-g_{i-1}\leq g_{i+1}-g_i$

$\Rightarrow g_i-g_{i-1}+t\leq g_{i+1}-g_i+t$

$\Rightarrow (g_i+ti)-(g_{i-1}+(i-1)t)\leq (g_{i+1}+(i+1)t)-(g_i+ti)$

故 $g_i+ti$ 也是凸的。

### 二、关于 $w$ 的 $O(1)$ 计算

显然在这段区间的中位数处放邮局使得总距离最短。

令 $x=\lfloor\frac{l+r}{2}\rfloor$。

则左半部分对 $w$ 的贡献为 $a[x]-a[l]+a[x]-a[l+1]+\dots+a[x]-a[x-1]=a[x]\times(x-l)-\sum_{i=l}^{x-1}a[i]$。

其中，$a$ 是原数组。

求和部分用前缀和预处理一下，右半部分同理可得。

所以 $w_{i,j}=a[x]\times(x-l)-(s[x-1]-s[l-1])+a[x]*(r-x)-(s[r]-s[x])$。

其中，$s$ 是前缀和数组。

### 三、wqs 二分整数而不是实数的证明

其实可以二分实数，不过有可能 TLE。

我们知道，答案 $f_i$ 是整数，那么 $f_i-f_{i-1}$ 也是整数。

即 $\LARGE\frac{f_i-f_{i-1}}{i-(i-1)}$是整数，即斜率是整数。

我们 wqs 二分的就是斜率，因此本题可以二分整数。对于答案是实数的，可能要使用实数域的二分，同时要控制二分次数，不要 TLE。

----------------------

## AC 代码

```cpp
// update on 2025-08-09 修改了代码
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long // 十年 oi 一场空，不开 long long 一场空！
int in()
{
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=5e5+10;
int n,m;
int a[N];
int sum[N]; // 前缀和数组
struct node{int k,l,r;}; // 用于队列
deque<node>q; // 要开双向队列
int w(int l,int r) // O(1) 计算 w
{
	int md=(l+r)>>1;
	int d1=(md-l)*a[md],d2=(r-md)*a[md];
	int s1=sum[md-1]-sum[l-1],s2=sum[r]-sum[md];
	return d1-s1+s2-d2;
}
int f[N],h[N]; // f 是最优距离加代价，h 是放的邮局的个数
bool check(int i,int j,int k){return f[i]+w(i+1,k)<=f[j]+w(j+1,k);} // 比较是否更优的函数
int ff(int t)
{
	while(!q.empty())q.pop_front();
	q.push_back((node){0,1,n}),f[0]=0;
	for(int i=1;i<=n;i++)
	{
		while(!q.empty()&&q.front().r<i)q.pop_front(); // 找到 i 的最优决策
		int j=q.front().k;
		f[i]=f[j]+w(j+1,i)+t,h[i]=h[j]+1;
		while(!q.empty()&&check(i,q.back().k,q.back().l))q.pop_back(); // 删掉完全无用的区间
		if(q.empty()){q.push_back((node){i,1,n});continue;}
		int l=q.back().l,r=n,ans=n+1;
		while(l<=r) // 二分查找 pos
		{
			int mid=(l+r)>>1;
			if(check(q.back().k,i,mid))ans=mid,l=mid+1;
			else r=mid-1;
		}
		if(ans<n)q.back().r=ans,q.push_back((node){i,ans+1,n}); // 剖开区间插入 i
	}
	return h[n];
}
int two(int l,int r) // wqs 二分
{
	int res=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(ff(mid)<=m)res=mid,r=mid-1;
		else l=mid+1;
	}
	ff(res);
	return f[n]-res*m;
}
signed main()
{
	n=in(),m=in();
	for(int i=1;i<=n;i++)a[i]=in(),sum[i]=sum[i-1]+a[i];
	out(two(0,1e12)); // 这个值域我也搞不清楚到底要开多大
	return 0;
}
```

-------------------------------

## 后记

1. > 十年 oi 一场空，不开 long long 一场空！

2. 如果有讲述不清楚的，欢迎提问；如果有讲述错误的，欢迎提出修正。

3. 能不能顺手点个赞评论一下，关注一下 QWQ

---

## 作者：皎月半洒花 (赞：35)

出了题没多少人做，还不小心卡了神 `iostream` 的 `cdq`，这就很尴尬/kk

______


这个东西，考虑朴素的dp，就显然是 $f_{i,j}$ 记一下，然后放 $k\to i$ 的中点就好了。这样复杂度是 $n^2k$ 的。

然后编一下发现有决策单调性，就可以 $O(nk\log n)$ 其二分+单调栈，甚至直接用二维决策单调性做到 $O(nk)$ 了。

然而并不可以过233

考虑去优化一下上面那种解法，发现 $k$ 这个限制可以通过wqs二分给消掉，就变成了如果建一次邮局需要额外支付 $mid$ 的代价，但是不限制建的次数时的最短距离和。这个东西就变成了一个1D/1D的 $dp$ ，并且也具有决策单调性。这一部分就可以继续单调栈+二分做到 $n\log V\log n$ 。

不过写了写发现似乎二分的常数还是很小的，$n=5\times 10^5$ 也只需要谷 $2.7s$ 、uoj $2s$ 左右。

```cpp
int tp ;
ll res ;
ll f[N] ;
ll sum[N] ;
int lrg[N] ;
int cnt[N] ;
int stk[N] ;
int base[N] ;
int n, m, k ;

using IPT::qr;
using IPT::qra;
using IPT::qrs;
using IPT::qrdb;
using OPT::qw;
using OPT::qwa;
using OPT::qws;

il ll calc(int l, int r){
    ll h = (l + r + 1) / 2 ;
    ll ret = sum[r] - sum[h] ;
    ll d1 = 1ll * (h - l) * base[h] ;
    ll d2 = 1ll * (r - h) * base[h] ;
    return ret - d2 + d1 - sum[h] + sum[l] ;
}
il ll trans(ll p, ll x){
    return f[p] + calc(p, x) ;
}
bool check(ll x){
    stk[tp = 0] = 0 ; 
    int h = 0 ; lrg[0] = 1 ;
    for (int i = 1 ; i <= n ; ++ i){
        while (h < tp && lrg[h] < i)
            ++ h ; if (lrg[h] > i) -- h ;
        f[i] = trans(stk[h], i) + x, cnt[i] = cnt[stk[h]] + 1 ;
        while (tp && trans(stk[tp], lrg[tp]) >= trans(i, lrg[tp]))
            stk[tp] = 0, lrg[tp] = n + 1, -- tp ;
        int l = lrg[tp], r = n, mid, ans = n + 1 ;
        while (l <= r){
            int mid = (l + r) >> 1 ;
            if (trans(stk[tp], mid) >= trans(i, mid))
                ans = mid, r = mid - 1 ; else l = mid + 1 ;
        }
        if (ans <= n) stk[++ tp] = i, lrg[tp] = ans ;
    }
    res = f[n] - x * m ; return (bool)(cnt[n] < m) ;
}
int main(){
    qr(n) ; qr(m) ;
    for (int i = 1 ; i <= n ; ++ i)
        qr(base[i]), sum[i] = sum[i - 1] + (ll)base[i] ;  
    ll l = 0, r = 1e9, mid, ans ; 
    lrg[0] = 1 ; sum[n + 1] = sum[n] ; 
    while (l <= r){
        mid = (l + r) >> 1 ;
        if (check(mid)) r = mid - 1 ; 
        else ans = mid, l = mid + 1 ;
    }
    check(ans) ; qw(res) ; return 0 ;
}
```

#

---

## 作者：gxy001 (赞：17)

本文为 $O(n\log V)$ 的 wqs 二分+斜率优化做法。

下面这段**仅用于**凸性的证明，与做法**无关**：

>设 $w(l,r)$ 表示在 $\lfloor\frac{l+r}{2}\rfloor$ 处建立邮局，$l$ 到 $r$ 的村庄全部去往该邮局的距离之和，则有 dp 式子：
>$$
>f_{i,j}=\min_{0\le t<i}\{f_{t,j-1}+w(t+1,i)\}
>$$
>由于 $w(l,r)$ 满足四边形不等式，则 $ans_m=f_{n,m}$ 是关于 $m$ 的凸函数，这一经典结论的证明参见[此处](https://www.cnblogs.com/Itst/p/12805678.html)。

进行 wqs 二分，消去 $m$ 的限制，二分的斜率为 $K$。

关于 $K$ 的二分范围，这个凸包是单调减的下凸壳，考虑 $0\ge ansK=ans_{m+1}-ans_m\ge ans_{n}-ans_m=-ans_m$，由题目的保证知道 $ans_m\le 10^9$，所以二分范围取 $[-10^9,0]$ 即可。

设 $f_i$ 为已经考虑完了前 $i$ 个村庄的最小代价（$s$ 为 $a$ 的前缀和），我们有：
$$
f_i=\min_{1\le j\le i}\{(s_i-s_j)-(i-j)a_j+\min_{0\le k<j}\{(j-k)a_j-(s_j-s_k)+f_k\}\}-K
$$
令 $g_j=\min_{0\le k<j}\{(j-k)a_j-(s_j-s_k)+f_k\}$，$g$ 可以用斜率优化得到。

$f_i=\min_{1\le j\le i}\{(s_i-s_j)-(i-j)a_j+g_j\}-K$，$f$ 可以用斜率优化得到。

都是经典的斜率优化形式，具体做法就不加赘述了。

另外，提醒一下 wqs 二分时记得处理斜率相同的段。

```cpp
#include<iostream>
using std::cin,std::cout;
int n,m;
long long a[500010],s[500010],f[500010],g[500010],cntf[500010],cntg[500010];
int check(long long K){
	auto x1=[](int x){return x;};
	auto y1=[](int x){return s[x]+f[x];};
	auto x2=[](int x){return a[x];};
	auto y2=[](int x){return -s[x]+x*a[x]+g[x];};
	f[0]=0,cntf[0]=0;
	static int q1[500010];
	int *hd1=q1,*tl1=q1;
	*tl1++=0;
	static int q2[500010];
	int *hd2=q2,*tl2=q2;
	for(int i=1;i<=n;i++){
		while(tl1-hd1>1){
			if(std::pair(y1(*hd1)-a[i]*x1(*hd1),cntf[*hd1])<std::pair(y1(hd1[1])-a[i]*x1(hd1[1]),cntf[hd1[1]])) break;
			else ++hd1;
		}
		cntg[i]=cntf[*hd1];
		g[i]=i*a[i]-s[i]+y1(*hd1)-a[i]*x1(*hd1);
		while(tl2-hd2>1){
			if(std::pair((y2(i)-y2(tl2[-1]))*(x2(tl2[-1])-x2(tl2[-2])),cntg[i])>std::pair((y2(tl2[-1])-y2(tl2[-2]))*(x2(i)-x2(tl2[-1])),cntg[tl2[-1]])) break;
			else --tl2;
		}
		*tl2++=i;
		while(tl2-hd2>1){
			if(std::pair(y2(*hd2)-i*x2(*hd2),cntg[*hd2])<std::pair(y2(hd2[1])-i*x2(hd2[1]),cntg[hd2[1]])) break;
			else ++hd2;
		}
		cntf[i]=cntg[*hd2]+1;
		f[i]=-K+s[i]+y2(*hd2)-i*x2(*hd2);
		while(tl1-hd1>1){
			if(std::pair((y1(i)-y1(tl1[-1]))*(x1(tl1[-1])-x1(tl1[-2])),cntf[i])>std::pair((y1(tl1[-1])-y1(tl1[-2]))*(x1(i)-x1(tl1[-1])),cntf[tl1[-1]])) break;
			else --tl1;
		}
		*tl1++=i;
	}
	return cntf[n];
}
int main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i],s[i]=a[i]+s[i-1];
	int l=-1e9,r=0;
	long long ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)<=m) l=mid+1,ans=mid;
		else r=mid-1;
	}
	check(ans);
	cout<<f[n]+m*ans<<'\n';
	return 0;
}
```

---

## 作者：tylon2006 (赞：14)

比较显然的 wqs 二分套二分队列

凸性感受可能是某种异能，我是菜鸡，我没有。

关于决策单调性学习强推 cmd 的 [DP的决策单调性优化总结](https://www.luogu.com.cn/blog/command-block/dp-di-jue-ce-dan-diao-xing-you-hua-zong-jie)

环上的 $n\log S$ 魔法实在看不懂(

---

### solution

首先要分 k 段，这是一个 2D 问题。

这个问题是具有决策单调性的（见P4767）。

由此就可以得到结论：答案具有上凸性。

设 $f(k)$ 为分 k 段的 dp 值，即有 $f(k)$ 和 $f'(k)$ 均单调不增。

---
### proof
关于 $f(k)$ 单调不增可以利用归纳法简单证明。

明显有 $0=w(x,x)+w(x+1,x+1)\leq w(x,x+1)$。

设 $a<b<c<d$。

假设已知 $w(b,c)+w(c+1,d)\leq w(b,d)$......①

欲证 $w(a,c)+w(c+1,d)\leq w(a,d)$......②

由四边形不等式 $w(a,c)+w(b,d)\leq w(a,d)+w(b,c)$，

代入 ① 得 $w(a,c)+w(b,c)+w(c+1,d)\leq w(a,c)+w(b,d)\leq w(a,d)+w(b,c)$

整理得 $w(a,c)+w(c+1,d)\leq w(a,d)$，即 ② 式。


显然对于任意 k 段的方案，我们总能把其中一段切成两段使得答案不增。

关于凸性，Itst爷的证明已经非常好了，不再妄言。

丢个链接：[（翻译）浅谈满足四边形不等式的序列划分问题的答案凸性](https://www.cnblogs.com/Itst/p/12805678.html)

---

根据此性质，我们可以通过给每一段加权，二分权来找到恰好分 k 段的答案。
此时问题转化为 $dp[i]=dp[j]+w(j,i)$ 的 1D 问题。

因为有决策单调性，可以使用二分队列解决。

---

#### 二分队列：

因为决策单调，必然可以找到两个决策点的贡献区间**分界**，这个可以二分解决。

则我们可以用单调队列维护已有决策点的**位置**与**贡献区间**。

1.计算答案时不断移除已经贡献不到的队头。

2.插入时比较 i 和队尾谁先干掉次队尾，若 **i 与次队尾**分界比**队尾与次队尾**分界更小，那么队尾一定没有贡献。不断 pop 掉分界比 i 后的队尾再插入 i 即可。

---

### code

记得 wqs 二分值域开大点。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct data{
	int x,k;
	data(int u=0,int v=0){
		x=u,k=v;
	}
}q[500010];
ll dp[500010];
int s[500010];
int a[500010];
ll pr[500010];
int n,m,hd,tl;
ll calc(int l,int r){
	int pos=(l+r+1)>>1;
	return (pr[r]-pr[pos])-a[pos]*1ll*(r-pos)+a[pos]*1ll*(pos-l)-(pr[pos]-pr[l]);
}
int find(int i,int j){
	int l=j,r=n+1;
	while(l<r-1){
		int mid=(l+r)>>1; 
		if(dp[i]+calc(i,mid)<dp[j]+calc(j,mid)) l=mid;
		else r=mid;
	}
	return r;
}
bool check(int mid){
	hd=1,tl=0;
	q[++tl]=data(0,n+1);
	for(int i=1;i<=n;i++){
		while(hd<tl&&q[hd].k<=i) hd++;
		dp[i]=dp[q[hd].x]+calc(q[hd].x,i)+mid;
		s[i]=s[q[hd].x]+1;
		while(hd<tl&&find(q[tl].x,i)<=q[tl-1].k) tl--;
		q[tl].k=find(q[tl].x,i);
		q[++tl]=data(i,n+1);
	}
	return s[n]>=m;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	pr[i]=pr[i-1]+a[i];
	ll l=0,r=5e11;
	while(l<r-1){
		int mid=(l+r)>>1;
		if(check(mid)) l=mid;
		else r=mid;
	}
	check(l);
	printf("%lld",dp[n]-m*l);
}
```
## end？
由此见得，包含单调似乎没有用处。仅有包含单调不能说明任何问题。

例如 $w(l,r)=\log\sum_{i=l}^ra[i]$，看起来非常包含单调，但它并不能说明是否函数有凸性，甚至不能说明分越多段越优，比如 $\log2+\log4=\log8>\log(2+4)=\log6$。

反而可以看到，决定此性质的是 $w(l,r)$ 决策单调性。

---

## 作者：JohnJoeZhu (赞：14)

~~既然没有几篇题解~~

[题面自读](https://www.luogu.com.cn/problem/P6246)

[弱化版](https://www.luogu.com.cn/problem/P4767)

建议先完成弱化版，

于是我们就从弱化版开始推导过来吧。

### 弱化版

$$ 1 \leq P \leq 300,P \leq V \leq 3000 $$

我们可以考虑处理啥子啊？

显然是$O(V^2)$乱搞啊！

所以肯定就可以预处理一个区间的最小答案（肯定要先排序啦）。

所以这是一个初一难度的简单结论：取中位数最优。

那就考虑一个dp：

$f[i][j]$表示覆盖前$i$个村庄，已经放置$j$个邮局，的最小花费。

$cal(i,j)$表示从第$i$到第$j$个村庄放一个邮局的最小花费。

$f[i][j]=min_{k<i}f[k][j-1]+cal(k+1,i)$

答案在$f[V][P]$。

$O(V^2P)$，考虑优化。

首先排除斜率优化，然而单调队列也十分不可做（限于$\text{cal}$的问题）。

那么我们就研究一下$\text{cal}$有什么东西可以提供给我们处理。

所以我们就大胆猜测，~~不用证明~~，大力打表！

然后发现$\text{cal}$满足四边形不等式。

四边形不等式[右转大佬链接](https://www.cnblogs.com/Xing-Ling/p/11317315.html)

猜想的主要依据是：两大~~主流~~优化已被排除，仅剩决策单调性比较可能实现，故先考虑$\text{cal}$的四边形不等式的性质。

本人太菜也不会证明，[请看大佬证明](https://www.luogu.com.cn/blog/LiberShip/ioi2000-you-ju)

于是有

对于$a<b$，我们有$cal(a,b+1)+cal(a+1,b) ≥cal(a,b) +cal(a+1,b+1)$

然后就有

对于$a≤b≤c≤d$，我们有$cal(a,d)+cal(b,c)≥cal(a,c)+cal(b,d)$

所以推到（记$f[i][j]$的决策点为$p[i][j]$

$p[i][j-1]≤p[i][j]≤p[i+1][j]$

然后弱化版就解决了。

时间复杂度$O(VP)$

~~但是说了这么多，跟强化版好像还差很远。~~

### 强化版

$$ 1 \leq m \leq n \leq 5 \times 10^5 $$

然后弱化的$O(nm)$直接裂开。

首先$\text{cal}$没办法预处理了，只能够用前缀和，可以做到$O(1)$

可是题目还有什么可以优化的？

于是我们就要请出wqs二分。

蒟蒻推销：[右转](https://www.luogu.com.cn/blog/JohnJoeZHU/wqs-er-fen)

显然我们邮局选越多越好。

所以肯定是要$m$个全选。

那么考虑**恰好**选$m$个的答案。

看见恰好，直接上wqs二分。

时间复杂度降到$O(nlogM)$($M$为值域）。

但是弱化版的dp好像不能完全契合wqs二分中的需求啊。

所以我们考虑将寻找决策点，转化为寻找该决策点可以转移到的目标点。

那么记录每个可以转移的点的转移范围即可。

如何记录？

我们可以考虑将所有满足要求的点塞进一个队列/栈里，每次从最右边取出可行的点。（因为越靠右越优，注意我们不需要考虑邮局个数的限制）

进行转移后，我们再将队尾的更劣的元素弹出。

也就是，如果从当前位置$i$转移到队尾位置$j$的转移范围$[l,r]$，都有$i$优于$j$，$j$就被单调队列了。

如果从当前位置$i$转移到队尾位置$j$的转移范围$[l,r]$，都有$i$劣于$j$，$i$就被大佬击败了。

但是，也有可能$i$将$[l,r]$，~~分区占领~~，我们还要找到其断点。

既然我们已经知道，转移范围连续，那么我们就可以用二分来寻找断点。

时间复杂度变成$O(n*logn*logM)$

具体还可以看代码实现

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
const int N=5e5+5;
int n,m,a[N],f[N],sum[N],sa[N];
int cal(int i,int j)//计算不能n^2预处理，但是用前缀和可以做到O(1)
{
	int mid=(i+j)/2;
    return (2*mid-i-j)*a[mid]-sa[mid]+sa[i-1]+sa[j]-sa[mid-1];
 } 
struct node{
	int pos,l,r;//转移的点，转移的范围
};
deque<node>q;
int F(int i,int j){return f[j]+cal(j+1,i);}//求转移后的值
bool pd(int l,int r1,int r2){return F(l,r1)==F(l,r2)?sum[r1]<=sum[r2]:F(l,r1)<F(l,r2);}//比较从r1,r2分别转移到l，谁更优（r1更优返回1）
int dp(int V)
{
	while(!q.empty()) q.pop_back();
	f[0]=0;sum[0]=0;
	q.push_back((node){0,1,n});
	for(int i=1;i<=n;i++)
	{
		while(q.front().r==i-1) q.pop_front();//无法转移 
		int j=q.front().pos;
		f[i]=F(i,j)-V;//V是wqs二分出来的值
		sum[i]=sum[j]+1;//统计邮局个数
		j=n+1;//寻找转移区间最左段（最右都是r）
		while(!q.empty()&&pd(q.back().l,i,q.back().pos)) j=q.back().l,q.pop_back();//j被单调队列了
		if(q.empty()){q.push_back((node){i,i+1,n});continue;}
		if(pd(q.back().r,q.back().pos,i)&&j<=n)//i被大佬打败了
		{
			q.push_back((node){i,j,n});
			continue;
		}
        	//剩下是瓜分统治范围
		int l=q.back().l,r=q.back().r,mid;
		while(l<=r)
		{
			mid=l+r>>1;
			if(pd(mid,i,q.back().pos)) j=mid,r=mid-1;
			else l=mid+1;
		}
		q.back().r=j-1;
		q.push_back((node){i,j,n});
	}
	return sum[n]<=m;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),sa[i]=sa[i-1]+a[i];
	sort(a+1,a+1+n);
	int ans,l=-5e11,r=5e11,mid;//二分值域往死里开
	while(l<=r)
	{
		mid=l+r>>1;
//		printf("%lld %lld\n",l,r);
		if(dp(mid)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	dp(ans);
	printf("%lld\n",f[n]+ans*m);
	return 0;
}
```

---

## 作者：juju527 (赞：11)

非常清新的凸优化dp入门题

### 前置知识
**凸优化**

顾名思义，该优化作用于凸函数上

凸优化的题目中，往往存在**恰好**选 $k$ 个的限制

我们通常能得到一个高维的转移方程

我们能通过凸优化将用于满足**恰好**限制的这一维度去掉，时间复杂度相当于以 $O(log k)$ 替换掉了 $O(k)$

#### 具体思路

以 $f_{i,j}=\min f_{k,j-1}+w(k,j)$ ,即本题转移方程为例

通过严格证明~~(打表)~~，我们能发现这是一个凸函数

对于我们最后要求的 $f_{n,k}$ ，我们记函数 $F_n(x)=f_{n,x}$

不妨设 $F_n(x)$ 为凸函数

对于每一个 $x$ 显然存在某条切线 $y=kx+b$ 

使得斜率为 $k$ 的直线经过函数上任意一点纵截距均小于在 $x$ 处的截距

又 $b=F_n(x)-kx$

我们可以通过dp时第二维每增加1就给值减k，将第二维的限制消除

由于 $k$ 的值域范围较大，可以采用二分

#### 实现细节

由于题目中的转移方程性质可能不那么优美，函数并非为严格凸函数

存在三点共线的情况，此时若我们需要的第二维位置在这条多点共线的线上，我们取不出我们要的k

考虑实现时多加一个值相同时第二维尽量小的限制

二分结束拿最近的k再做一边dp即可

### $\texttt{Solution}$
回到本题，我们已经可以通过二分套一维dp解决这个问题

一维dp，即不考虑第二维的限制，$f_i=\min f_j+w(j+1,i)-k$

显然，我们能很轻松的证明该转移方程有决策单调性

记 $f_i$ 的最优决策点为 $p_i< i-1$

采用反证法，若 $p_i<p_{i-1}$

$f_{p_{i-1}}+w(p_{i-1}+1,i-1)\leq f_{p_i}+w(p_i+1,i-1)$ (1)

$f_{p_{i-1}}+w(p_{i-1}+1,i)\geq f_{p_i}+w(p_i+1,i)$ (2)

由于 $w(p_{i-1}+1,i)-w(p_{i-1}+1,i-1)<w(p_i+1,i)-w(p_i+1,i-1)$(3)

将(3)与(1)相加可得

$f_{p_{i-1}}+w(p_{i-1}+1,i)< f_{p_i}+w(p_i+1,i)$

与(2)矛盾，故 $p_i\geq p_{i-1}$

我们能通过队列优化与二分在 $O(nlogn)$ 的复杂度内完成该一维dp

总复杂度 $O(nlogWlogn)$，$W$ 为值域

[代码](https://www.luogu.com.cn/paste/2rjzfegr)

---

## 作者：_AyachiNene (赞：7)

# 思路：
首先容易发现是个分段 dp，一段中的点一定是在中点修一个邮局。

设 $f_{i,j}$ 表示以 $i$ 结尾，分了 $j$ 段的答案，转移显然：$f_{i,j}=\min\{f_{k,j-1}+cost_{k+1,i}\}$。

首先容易发现想到的一个猜想是这个东西有决策单调性，先感性理解一下，一段越长答案就更劣。通过~~打表证明~~或者四边形不等式都可以证明。用分治可以做到 $O(nk\log n)$。

然后发现没有什么优化空间，瓶颈在于有个段数的限制，状态数太多。由于分的段很多，想到可能是 wqs 二分，~~打表~~发现确有凸性。然后段数的限制就被消掉了，变成了一维的 dp，所以分治要换成二分队列，dp 一次就是 $O(n\log n)$。最后时间复杂度 $O(n\log n \log V)$，$V$ 是斜率的值域。

需要注意的是 wqs 二分的一些取等的条件，同时这题可能有斜率相同的点，要判一下，取分的段更多的，但代码中没判也过了。

# Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){char ch=getch();while(ch<'a'||ch>'z')ch=getch();while(ch>='a'&&ch<='z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n,m;
int a[500005];
int sum[500005];
int f[500005],g[500005];
inline int calc(int j,int i)
{
	int p=i+j+1>>1;
	return f[j]+sum[i]-sum[p]-a[p]*(i-p)+a[p]*(p-j)-sum[p]+sum[j];
}
struct node{int r,p;}q[500005];
int l,r;
inline int find(int x,int y) //x±ÈyÓÅµÄµÚÒ»¸öÎ»ÖÃ 
{
	if(calc(x,n)>=calc(y,n)) return n+1;
	int l=x+1,r=n,res=n+1;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(calc(x,mid)<=calc(y,mid)) r=mid-1,res=mid;
		else l=mid+1;
	}
	return res;
}
inline void dp(int x)
{
	l=1,r=0;
	memset(f,0x3f,sizeof f);memset(g,0,sizeof g);
	f[0]=0;q[++r].p=0;q[r].r=n;
	for(int i=1;i<=n;i++)
	{
		while(l<r&&q[l].r<=i) ++l;
		f[i]=calc(q[l].p,i)+x,g[i]=g[q[l].p]+1;
		while(l<r&&q[r-1].r>=find(i,q[r].p)) --r;
		q[r].r=find(i,q[r].p);q[++r].p=i;
	}
}
signed main()
{
//	freopen("P6246_1.in","r",stdin);
//	freopen(".out","w",stdout);
	read(n,m);
	for(int i=1;i<=n;i++) read(a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
	int l=0,r=1e9,ans;
	while(l<=r)
	{
		int mid=l+r>>1;
		dp(mid);
		if(g[n]>=m) ans=f[n]-mid*m,l=mid+1;
		else r=mid-1;
	}
	write(ans);
	flush();
	return 0;
}
```

---

## 作者：R_shuffle (赞：5)

萌新刚学会决策单调性和 wqs 二分，发篇题解纪念一下。

---------

### 1. 决策单调性
通常情况下，我们说的决策单调性是指这样一件事情：假设我们有一个状态转移方程是
$$
f_i=\max_{j=1}^{i-1}(f_j+w(j,i))
$$
不妨设对于一个下标 $i$，最大的 $f_j+w(j,i)$ 所对应的 $j$ 为 $p_i$ ，那么决策单调性就是说 $p_i$ 这个序列是单调的。这样的话，我们不妨反过来，对于每一个下标 $j$，我们知道它能转移到的状态对应的下标一定是一个区间 $[l_j,r_j]$。而且若 $j_1>j_2$，有 $l_{j_1}>r_{j_2}$。所以通常我们处理这个东西是用二分队列，由于第一个状态是可以直接得到的，我们就可以知道当前的第一个状态是能转移到 $[2,n]$ 的，所以第二个状态一定是由第一个状态或者空状态得到的，得到第二个状态后，由决策单调性，我们知道第一个状态能转移到的区间的一个后缀上，用第二个状态转移是比用第一个状态转移更优，所以我们不妨对这个区间二分，就可以得到当前第二个状态能转移到的区间。以此类推，就是二分队列了。
### 2. wqs 二分
wqs 二分通常是用来解决这样一个问题的：在限制次数的情况下求最优解。考虑去掉次数的限制，那么可以得到若干个二元组 $(i,f(i))$，表示限制次数为 $i$ 的情况下答案为 $f(i)$，同时由于次数限制，通常的 dp 会再加入一维来表示次数，考虑为什么要加入这一维，显然是因为我们如果不限制次数的话次数可能就会在多于给定的次数或者少于给定的次数完成。

wqs 二分的主要思想就是通过给价值函数加上一个次数相关的函数，使得在给定的次数时取到最优解。那么为了让这个次数相关的函数在转移的时候能够不用记录次数，所以通常会用一次函数，这样直接在转移的时候加上一个特定值即可，而不需要知道具体经过了多少次。但是我们发现如果用一次函数的话就具有局限性，就是上面的二元组 $(i,f(i))$ 视作关于 $i$ 的函数，那么这个函数具有凸性。道理很简单，如果具有凸性，那么在一次函数的斜率单调变化的时候，最优解的次数也是单调变化的。所以实际上 wqs 二分就相当于通过让次数也成为贡献的一部分来保证次数是题目要求的。
### 3. 关于本题
本题要求我们选择 $m$ 个点，使 $n$ 个点到这 $m$ 个点的最小距离之和最小。显然最优解是全选，而且点多都能保证不劣于点少的情况。同时考虑凸性，不妨设选择 $i$ 个点的最优解为 $f(i)$，那么要证明 $f(i)-f(i-1)$ 是单调的。本题我们可以猜到应该是 $f(i)-f(i-1)$ 单调递减，证明可以看 P4767。同时可以打表发现具有决策单调性，这个比较显然，考虑决策点离下一个决策点太远，我们显然是可以把决策点往下一个决策点移动一点，这样更优。所以就可以 wqs 二分套上二分队列。

```cpp
/*胡金梁*/
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
#define int long long
inline int read()
{
	int f=1,re=0;
	char ch=getchar();
	while(!isdigit(ch)){ if(ch=='-') f=-1; ch=getchar();}
	while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^'0'),ch=getchar();
	return re*f;
}
const int N=5e5+5;
int n,m,a[N],sum[N],f[N],g[N];
struct node
{
	int k,l,r;
}q[N];
int calc(int l,int r)
{
	int mid=(l+r)>>1;
	return (sum[r]-sum[mid])-a[mid]*(r-mid)+a[mid]*(mid-l)-(sum[mid-1]-sum[l-1]);
}
bool check(int i,int j,int k)
{
	return f[i]+calc(i+1,k)<=f[j]+calc(j+1,k);
}
bool check(int x)
{
	int head=1,tail=0;
	q[++tail]={0,1,n};
	for(int i=1;i<=n;i++)
	{
		while(head<tail&&q[head].r<i) head++;
		q[head].l=i;
		int j=q[head].k;
		f[i]=f[j]+calc(j+1,i)+x;
		g[i]=g[j]+1;
		while(head<tail&&check(i,q[tail].k,q[tail].l)) tail--;
		int l=q[tail].l,r=n,ans=n+1;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(q[tail].k,i,mid)) ans=mid,l=mid+1;
			else r=mid-1;
		}
		if(ans<n) q[tail].r=ans,q[++tail]={i,ans+1,n};
	}
	return g[n]<=m;
}
signed main()
{
#if __MY_TEST__
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];
	int l=0,r=1e15,ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	check(ans);
	cout<<f[n]-ans*m<<endl;
}

```

---

## 作者：OldDriverTree (赞：5)

这篇题解主要讲解 wqs 二分 + 斜率优化 DP 的做法。

# Solution

首先有一个暴力的 DP 是设 $f_{x,y}$ 表示前 $x$ 个村庄，设置了 $y$ 个邮局的答案，令 $w(l,r)$ 为设置一个邮局，到 $[l,r]$ 中的村庄距离总和的最小值，不难发现设置在中位数的位置最优，状态转移方程就为 $f_{x,y}=\min\limits_{i=0}^{x-1} f_{i,y-1}+w(i+1,x)$，但是直接做时间复杂度显然爆炸，考虑优化。

首先可以证明 $w(l,r)$ 满足四边形不等式，这里就不证了，可以去看看其他题解，所以 $f_{x,y}$ 关于 $y$ 是凸的，因此可以 wqs 二分。现在的状态就是设 $f_x$ 表示前 $x$ 个村庄的答案，假设当前二分的值为 $val$，状态转移方程就为 $f_x=\min\limits_{y=0}^{x-1} f_y+w(y+1,x)+val$。这个东西不难用决策单调性的二分单调队列做法做到总时间复杂度 $O(n\log n\log V)$，已经能过了，但是这并不优雅，继续优化。

如果我们让 $w(l,r)$ 带着中位数考虑的话，继续优化是比较困难的，因此我们可以考虑 $w(l,r)$ 枚举邮局的位置并取 min 的形式，那么现在的转移方程就为 $f_x=\min\limits_{y=0}^{x-1}\{f_y+\min\limits_{i=y+1}^x \{a_i(2i-x-y)+s_x+s_y-2s_i\}+val\}$，我们可以把第二个 min 里的东西拆成两部分，一部分是 $(y,i]$ 区间的花费，一部分是 $(i,x]$ 区间的花费，两部分基本上是无关的，因此我们可以考虑再设一个 $g_x$ 表示考虑前 $x$ 个邮局，$x$ 为它所在区间的邮局的答案，新的状态转移方程就为 $g_x=\min\limits_{y=0}^{x-1} f_y+a_x(x-y)-(s_x-s_y)$，$f_x=\min\limits_{y=1}^x g_y+(s_x-s_y)-a_y(x-y)+val$，不难用斜率优化做到 $O(n)$。

总时间复杂度就为 $O(n\log V)$。

在没卡常的情况下，拿到了你谷最优解（在不考虑两个面向数据编程的人的情况下）。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
//using mint=modint998244353;
const int N=5e5;
int n,m,a[N],s[N]; P f[N],g[N];
struct node { int x,y,z; }q[N],Q[N];

struct custom_hash
{
	static uint64_t splitmix64(uint64_t x) {
		x+=0x9e3779b97f4a7c15;
		x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
		x=(x^(x>>27) )*0x94d049bb133111eb;
		return x^(x>>31);
	}
	size_t operator() (uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x+FIXED_RANDOM);
	}
};
int read() {
	int x=0; bool _=true; char c=0;
	while (!isdigit(c) ) _&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=x*10+(c&15),c=getchar();
	return _?x:-x;
}
bool check(int x)
{
	int h=0,t=0,H=0,T=-1; q[0]={0,0,0};
	for (int i=1;i<=n;i++) {
		while (h<t&&(q[h+1].y-q[h].y<a[i]*(q[h+1].x-q[h].x)||q[h+1].y-q[h].y==a[i]*(q[h+1].x-q[h].x)&&q[h].z<=q[h+1].z) ) h++;
		g[i]={q[h].y-a[i]*q[h].x+i*a[i]-s[i],q[h].z}; node p={a[i],g[i].first-s[i]+i*a[i],g[i].second};
		while (H<T&&( (Q[T].y-Q[T-1].y)*(p.x-Q[T].x)>(p.y-Q[T].y)*(Q[T].x-Q[T-1].x)||(Q[T].y-Q[T-1].y)*(p.x-Q[T].x)==(p.y-Q[T].y)*(Q[T].x-Q[T-1].x)&&Q[T].z<=p.z) ) T--; Q[++T]=p;
		while (H<T&&(Q[H+1].y-Q[H].y<i*(Q[H+1].x-Q[H].x)||Q[H+1].y-Q[H].y==i*(Q[H+1].x-Q[H].x)&&Q[H].z<=Q[H+1].z) ) H++;
		f[i]={Q[H].y-i*Q[H].x+s[i]+x,Q[H].z+1},p={i,f[i].first+s[i],f[i].second};
		while (h<t&&( (q[t].y-q[t-1].y)*(p.x-q[t].x)>(p.y-q[t].y)*(q[t].x-q[t-1].x)||(q[t].y-q[t-1].y)*(p.x-q[t].x)==(p.y-q[t].y)*(q[t].x-q[t-1].x)&&q[t].z<=p.z) ) t--; q[++t]=p;
	}
	return f[n].second>=m;
}
main() {
	n=read(),m=read(); for (int i=1;i<=n;i++) s[i]=s[i-1]+(a[i]=read() );
	int l=0,r=2e6; while (l<=r) check(mid)?l=mid+1:r=mid-1;
	return check(r),!printf("%lld",f[n].first-r*m);
}
```

---

## 作者：Reunite (赞：4)

~~原来还有这好东西？~~

update on 2024-4-24 修改了一处描述错误。

## 一
---

先列出朴素的转移：

$$f_{i,j}=\min \limits_{0\le k\le i-1} f_{k,j-1}+calc(k+1,i)$$

其中，$calc(l,r)$ 表示把 $[l,r]$ 这一段用一个邮局的代价，由绝对值相关结论可知，把邮局设在中位数处最优，这部分可以预处理前缀和 $O(1)$ 解决。

这个东西是有下凸性的，证明可以见 [P4767 [IOI2000] 邮局](https://www.luogu.com.cn/problem/solution/P4767)。

考虑用 wqs 二分消去 $m$ 段的限制。此后每选一段都需要加上一个附加权值 $w$。现在只需考虑如下方程：

$$f_i=\min \limits_{0\le j\le i-1}f_j+calc(j+1,i)$$

暴力做是 $n^2$ 的，可以发现上式又是满足决策单调性的，因为段越长越不优。直接记录转移点是不行的，因为不知道哪一个点会取到最优。现引入**二分队列科技**。

---
## 二
---

决策单调性的另一种表达形式为，对于每一个点 $i$，都有其最优决策区间 $[l_i,r_i]$（允许为空），表示在此区间内，$i$ 都是最优的决策点。那么根据决策单调性的性质，必有 $\forall i <j,r_i\le l_j$，也就是说，存在确定的点 $pos$，使其为 $i<j$ 的最优决策区间的划分点。

考虑使用一个队列来维护上述 $(i,l_i,r_i)$ 三元组，记为 $qk,ql,qr$。

转移到 $i$ 时，弹队首，直到 $i \in [ql_{head},qr_{head}]$，此时的队首即为 $i$ 的最优决策，直接转移。

接下来考虑更新队列，首先 $ql_{head}\leftarrow i$，根据定义，一个点完全无用了，当且仅当整个最优决策区间都比 $i$ 要劣，进一步地，由于决策单调性，只需要判断 $ql$ 是否更劣即可，所以只要 $i \rightarrow ql_{tail}$ 优于 $qk_{tail} \rightarrow ql_{tail}$ ，弹队尾。

上一次操作中，我们去掉了队尾完全无用的转移点，但可能队尾元素不是完全无用，即存在 $pos \in [ql_{tail}+1,qr_{tail}]$，使得对于 $pos$ 之前的队尾转移点更优，但是之后的 $i$ 这个新转移点更优，而这是可以二分的，因此叫做二分队列。二分找到 $pos$ 后，把队尾的最优决策区间剖开，加入新元素即可。

复杂度的话，wqs 二分，队列中二分，$O(n\log_2V\log_2n)$。



```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;

int n,m;
int a[500005];
int s[500005];
int f[500005];
int g[500005];
struct node{int k,l,r;};
node q[500005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline int calc(int l,int r){
	int pos=(l+r)>>1;
	return (s[r]-s[pos])-a[pos]*(r-pos)+a[pos]*(pos-l)-(s[pos-1]-s[l-1]);
}

inline bool check(int i,int j,int k){return f[i]+calc(i+1,k)<=f[j]+calc(j+1,k);}

inline bool check(int mid){
	int head=1,tail=0;
	q[++tail]={0,1,n};
	for(int i=1;i<=n;i++){
		while(head<tail&&q[head].r<i) head++;
		q[head].l=i;
		int j=q[head].k;
		f[i]=f[j]+calc(j+1,i)+mid;
		g[i]=g[j]+1;
		while(head<tail&&check(i,q[tail].k,q[tail].l)) tail--;
		int l=q[tail].l,r=n,mid,pos=n+1;
		while(l<=r){
			mid=(l+r)>>1;
			if(check(q[tail].k,i,mid)) pos=mid,l=mid+1;
			else r=mid-1;
		}
		if(pos<n) q[tail].r=pos,q[++tail]={i,pos+1,n};
	}

	return g[n]<=m;
}

signed main(){
	in(n),in(m);
	for(int i=1;i<=n;i++) in(a[i]),s[i]=s[i-1]+a[i];
	int l=0,r=1000000000,mid,x=0;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) x=mid,r=mid-1;
		else l=mid+1;
	}
	check(x);
	printf("%lld\n",f[n]-x*m);

	return 0;
}
```

---

## 作者：SFlyer (赞：2)

### P10967

设在 $1\sim i$ 装了 $j$ 个邮局的答案 $f_{i,j}$：$f_{i,j}=\min\{f_{k,j-1}+w_{k+1,i}\}$，其中 $w_{l,r}$ 为 $l\sim r$ 有一个邮局的最小距离。

- $w_{l,r}$ 怎么求？在中位点装邮局。那么有 $w_{l,r}=w_{l,r-1}+x_j-x_{[(i+j)/2]}$。其中 $x$ 是村庄位置。进一步有 $\mathcal{O}(1)$ 算法，$m=[(l+r)/2],w_{l,r}=x_{m}\times (2m-l-r-1)+sum_{l+1}+sum_r-2sum_m$。所以这个不是复杂度瓶颈。

得到了一个 $\mathcal{O}(v^2p)$ 的算法。

### P4767

$f_{i,j}=\min\{f_{k,j-1}+w_{k+1,i}\}$ 这个方程内，状态较难优化，所以尝试优化转移。

证：$w_{l,r}$ 符合 $Q.I.$。

$w_{i,j}+w_{i',j'}\le \sum_{l=i}^j |d_l-d_z|+\sum_{l=i'}^{j'}|d_l-d_y|$。

$\le \sum_{l=i}^j |d_l-d_z|+\sum_{l=i'}^{j'}|d_l-d_y|+\sum_{l=j+1}^{j'}|d_l-d_z|-\sum_{l=j+1}^{j'}|d_l-d_y|$。

$=\sum_{l=i}^{j'}|d_l-d_z|+\sum_{l=i'}^j |d_l-d_y|=w(i,j')+w(i',j)$。

令 $m_{i,j}$ 为 $f_{i,j}$ 最小决策点。

引理 $1$：$m_{i+1,j}\ge m_{i,j}$。

引理 $2$：$m_{i,j-1}\le m_{i,j}$。

计算 $m_{i,j-1}\le k\le m_{i+1,j}$。从小到大枚举 $j$，从大到小枚举 $i$ 即可。

时间复杂度 $\mathcal{O}(pv)$。

### P6246

尝试优化状态！这个“邮局数量”状态让人联想起 [wqs 二分](https://www.luogu.com.cn/article/knpufhxe)。

或者感性理解：如果每建立一个邮局有一个附加的费用，费用越高你想要建立的邮局数量就会减少。所以是一个上凸包。

二分 $mid$ 费用，就变成了：$f_{i}=\min\{f_{k}+w_{k+1,i}+mid\}$。这个是 1D-1D dp 方程。

$f(i)=\min_{0\le j<i} f(j)+w(j,i)$。（注意是 $\min$！）组数没有限制的分组问题。

定理：若 $w$ 符合 $Q.I.$，当 $d\ge c$ 时，$f(d)$ 的最优决策点 $\ge f(c)$ 最优决策点。

因此：对于每个已经计算出来的 $f_i$，去寻找它能更新的状态有哪些。在栈顶的决策起始位置判断起始位置是否决策 $i$ 更优。如果是，则退栈，继续执行，否则，二分决策位置。

最终代码：

```c++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int N = 5e5+5;

struct node {
	ll l,r,x;
} stk[N];

ll n,m,a[N],sum[N],dp[N],top,cnt[N];

ll w(ll l,ll r){
	ll mid=(l+r+1)/2;
	return a[mid]*(mid+mid-l-r)+sum[l]+sum[r]-sum[mid]*2; 
}

int ff(int i){
	int l=stk[top].l-1,r=stk[top].r+1;
	while (l+1<r){
		int mid=l+r>>1;
		if (dp[i]+w(i,mid)<=dp[stk[top].x]+w(stk[top].x,mid)){
			r=mid;
		}
		else{
			l=mid;
		}
	}
	return r;
}

bool chk(ll x){
	top=1;
	stk[1]={1,n,0};
	for (int i=1,cur=1; i<=n; i++){
		dp[i]=dp[stk[cur].x]+w(stk[cur].x,i)+x;
		cnt[i]=cnt[stk[cur].x]+1;
		while (i<stk[top].l && dp[i]+w(i,stk[top].l)<=dp[stk[top].x]+w(stk[top].x,stk[top].l)){
			top--;
		}
		int pos=ff(i);
		stk[top].r=pos-1;
		if (pos<=n){
			stk[++top]={pos,n,i};
		}
		if (i==stk[cur].r){
			cur++;
		}
	}
	return cnt[n]>=m;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin>>n>>m;
	for (int i=1; i<=n; i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}
	ll l=-1,r=1e9;
	r++;
	while (l+1<r){
		ll mid=l+r>>1;
		if (chk(mid)){
			l=mid;
		}
		else{
			r=mid;
		}
	}
	chk(l);
	cout<<dp[n]-l*m<<"\n";
	return 0;
}
```

---

## 作者：aaaaaaaawsl (赞：2)

推荐预先食用：[P4767 [IOI2000] 邮局](https://www.luogu.com.cn/problem/P4767)。

前置知识：wqs 二分，推销本人的[博客](https://www.luogu.com.cn/blog/aaaaaaaawsl/solution-cf1279f)。

那么本题，用四边形不等式优化的做法是 $O(nm)$ 的，面对 $n, m$ 都 $5 \times 
10^5$ 的数据显然过不去，考虑换种优化。

考虑朴素 DP：设 $f_{i,k}$ 为考虑到第 $i$ 位，分了 $k$ 段的答案。

下面观察题面，明显的有必须要建立 $m$ 个邮站，这符合 wqs 二分处理的问题的恰好选择 $m$ 件物品的特性（详情见博客）。所以尝试使用 wqs 二分优化掉第二维。

决策单调性由普通版本的四边形不等式的推导过程可以轻松得出，这里感性理解下凸性：

对于 $f_k$ 表示分 $k$ 段的最优价值，我们总可以取出某一段，将他再分成两段，使得 $f_{k - 1} \le f_{k}$ 分段优化的价值和段内村庄数正相关，随着分段的增多，段内的村庄数下降，优化的价值下降，所以函数成上凸。

对此，可以二分斜率，$O(n)$ DP 维护即可。时间复杂度 $O(n\log m)$。

对于每一次 DP 中，由于决策单调性，用一个队列维护决策点，如果该决策点的管辖范围小于当前枚举的点，就从队首弹出，如果队尾决策点被次队尾决策点和当前决策点的范围覆盖，那么从队尾弹出。

下面是实现的一些细节。

- 要尤其注意二分的写法，因为本题可能存在共线情况，由于函数单调不增，所以二分尽可能选右侧的点。以及二分边界等等（在二分上错了十几版）。

- 预处理前缀和以做到 $O(1)$ 求出两个点之间放一个邮局的最优价值。

- 注意边界和判断条件中的等号是否添加。

-----

### Code

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long

using namespace std;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch > '9' || ch < '0'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

const int N = 5e5 + 10;

int n, m, ans;
int a[N], sum[N];
struct node{
	int pos, r;
}q[N];
struct Node{
	int val, x;
}f[N];

int calc(int l, int r){
	l += 1;
	int mid = (l + r) >> 1;
	int ans = 1ll * (sum[r] - sum[mid]) - (1ll * a[mid] * (r - mid)) + (1ll * a[mid] * (mid - l)) - (sum[mid - 1] - sum[l - 1]);
	return ans;
}

int find(int i, int j){
	int l = j, r = n + 1;
	while(l < r - 1){
		int mid = (l + r) >> 1;
		if(f[i].val + calc(i, mid) < f[j].val + calc(j, mid)) l = mid; 
		else r = mid;
	}
	return r;
}

//int find(int i, int j){
//	int l = j, r = n + 1, p;
//	while(l <= r){
//		int mid = (l + r) >> 1;
//		if(f[i].val + calc(i, mid) < f[j].val + calc(j, mid)) l = mid + 1, p = mid; 
//		else r = mid - 1;
//	}
//	return p;
//}

//int find(int i, int j){
//	int l = j, r = n + 1, mid;
//	while(l < r){
//		mid = (l + r + 1) >> 1;
//		if(f[i].val + calc(i, mid) <= f[j].val + calc(j, mid)) l = mid; 
//		else r = mid - 1;
//	}
//	return mid;
//}

int check(int mid){
	int hh = 1, tt = 0;
	q[++ tt].pos = 0; q[tt].r = n + 1;
	for(int i = 1; i <= n; ++ i){
		while(hh < tt && q[hh].r <= i) hh ++;
		f[i].val = f[q[hh].pos].val + calc(q[hh].pos, i) - mid;
		f[i].x = f[q[hh].pos].x + 1;
		while(hh < tt && find(q[tt].pos, i) <= q[tt - 1].r) tt --;
		q[tt].r = find(q[tt].pos, i);
		q[++ tt].r = n + 1; q[tt].pos = i;
	}
	return f[n].x;
}


signed main(){
	n = read(); m = read();
	for(int i = 1; i <= n; ++ i) a[i] = read();
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; ++ i)sum[i] = sum[i - 1] + a[i];
	int l = -5e11, r = 0, p;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(check(mid) <= m) l = mid + 1;
		else r = mid - 1, p = mid;
	}
	check(p);
	printf("%lld", f[n].val + p * m);
	return 0;
}

```

---

## 作者：_Ch1F4N_ (赞：1)

首先存在一个 $O(n \times m \times \text{poly}(n))$ 的做法，考虑到放置邮局后，一个邮局肯定会贡献到一个区间的村庄，计算一个邮局会贡献到哪是困难的，但是我们不妨直接去划分区间，因为对于一个区间而言计算最优的邮局放哪是简单的，具体而言是一个若干绝对值函数和的 $\min$，取零点中位数即可。考虑 dp，然后这个 dp 具有决策单调性可以用你喜欢的方法处理。

现在考虑原问题，我们引出 wqs 二分以消去必须划分为 $m$ 段的限制，具体而言，由于最优答案关于 $m$ 凸，我们不妨给每选一段附上一个额外代价，这个时候 dp 转移变为了 $dp_i = \min_{j}(dp_j+w(j+1,i)+K)$ 这里 $K$ 是我们的额外代价，考虑记录 $p_i$ 表示 $i$ 的一种最优决策是被划分为了多少段，二分这个 $K$，通过 $p_n$ 与 $m$ 的关系决定要调大还是调小 $K$，最后得到的 $K$ 所求得的决策 $p_n$ 虽然不一定等于 $m$，但所一定与 $m$ 在同一条直线上，所以 $dp_n - K \times m$ 即为答案。

check 中的 dp 也具有决策单调性，二分队列优化即可做到 $O(n \log n \log V)$。


```cpp
//dp[i][j]=\min(dp[k][j-1]+w(k+1,i))
//w(l,r)=\sum_{i=l}^r |a_i-a_{(l+r)/2}|
//dp[i]=\min(dp[j]+w(j+1,i))
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 5e5+114;
const double eps = 1e-9;
int a[maxn],pre[maxn],n,m;
struct node{
    int l,r,p;
    node(int L=0,int R=0,int P=0){
        l=L,r=R,p=P;
    }
}q[maxn];
int l,r;
double K;
double w(int L,int R){
    double res1=pre[(L+R)/2]-pre[L-1],res2=pre[R]-pre[(L+R)/2];
    return (a[(L+R)/2]*((L+R)/2-L+1)-res1+res2-a[(L+R)/2]*(R-(L+R)/2))+K;
}
const int inf = 1e18;
double dp[maxn],p[maxn];//dp seqs
double trans(int i,int j){
    if(i>=j) return inf;
    return dp[i]+w(i+1,j);
}
void work(){
    l=1,r=0;
    q[++r]=node(1,n,0);
    for(int i=1;i<=n;i++){
        while(q[l].r<i&&l<=r) l++;
        p[i]=p[q[l].p]+1;
        dp[i]=trans(q[l].p,i);
        while(l<=r&&trans(i,q[r].l)<=trans(q[r].p,q[r].l)) r--;
        if(l<=r){
            if(trans(i,n)>trans(q[r].p,n)) continue;
            int lt=q[r].l,rt=q[r].r+1;
            while(lt+1<rt){
                int mid=(lt+rt)>>1;
                if(trans(q[r].p,mid)<trans(i,mid)) lt=mid;
                else rt=mid;
            }
            q[r].r=lt;
            q[++r]=node(lt+1,n,i);
        }else{
            q[++r]=node(i+1,n,i);
        }
    }    
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++) pre[i]=pre[i-1]+a[i];
    double L=0,R=1e9;
    while(L+eps<R){
        K=(L+R)/2;
        work();
        if(p[n]<m) R=K;
        else L=K;
    }
    cout<<(int)(dp[n]-K*m+0.5);
    return 0;
}
```

---


# [IOI 2020] 植物比较

## 题目背景

**这是一道交互题**。

本题仅支持 C++ 系列语言，提交时不需要包含 `plant.h` 头文件。

## 题目描述

植物学家 Hazel 参观过新加坡植物园的一个特别展览。在这次展览中，有 $n$ 棵 **高度互不相同** 的植物，它们排成了一个圆。这些植物按顺时针方向从 $0$ 到 $n-1$ 编号，植物 $n-1 $ 与植物 $0$ 是相邻的。

对于每棵植物 $i\ (0 \le i \le n-1$)，Hazel 将它与顺时针方向的后 $k-1$ 棵植物进行比较，记录下数值 $r[i]$ 以表示这 $k-1$ 棵植物中有多少棵的高度大于植物 $i$。因此，每个 $r[i]$ 的数值是由某段连续 $k$ 棵植物的相对高度决定的。

例如，假设 $n=5$，$k=3$，$i=3$。植物 $3$ 顺时针方向的后 $k-1=2$ 棵植物是植物 $4$ 和植物 $0$。如果植物 $4$ 比植物 $3$ 高，且植物 $0$ 比植物 $3$ 矮，那么 Hazel 将会记录 $r[3]=1$。

你可以假设 Hazel 记录的数值 $r[i]$ 都是正确的。也就是说，这些植物至少存在一组互不相同的高度符合 Hazel 所记录的数值。

本题要求你比较 $q$ 对植物的高度。由于你没有机会参观这次展览，你仅有的信息来源是 Hazel 的笔记本，其中记录了 $k$ 和序列 $r[0],\ldots, r[n-1]$ 的值。

对于每对需要比较的植物 $x$ 和 $y$（$x$ 和 $y$ 不同），判定它们符合以下哪种情况：

- 植物 $x$ 一定比植物 $y$ 高：对于任意一组符合数组 $r$ 且互不相同的高度 $h[0],\ldots h[n-1]$，都有 $h[x] > h[y]$。
- 植物 $x$ 一定比植物 $y$ 矮：对于任意一组符合数组 $r$ 且互不相同的高度 $h[0],\ldots h[n-1]$，都有 $h[x]<h[y]$。
- 该比较没有定论：以上两种情况都不成立。

#### 实现细节

要求你实现以下函数：
```cpp
void init(int k, std::vector<int> r)
```
- $k$：决定每个 $r[i]$ 数值的连续植物的棵数。
- $r$：一个大小为 $n$ 的数组，其中 $r[i]$ 是植物 $i$ 顺时针方向的后 $k-1$ 棵植物中比它高的棵数。
- 该函数恰好被调用一次，且在对 `compare_plants` 的任何调用前。
```cpp
int compare_plants(int x, int y)
```
- $x,y$ ：待比较的植物的编号。
- 该函数应该返回：
	- $1$，如果植物 $x$ 一定比植物 $y$ 高，
	- $-1$，如果植物 $x$ 一定比植物 $y$ 矮，
	- $0$，如果该比较没有定论。
- 该函数恰好被调用 $q$ 次。

## 说明/提示

#### 样例说明

#### 例 1

考虑以下调用：
```cpp
init(3, [0, 1, 1, 2])
```
假设评测程序调用了 `compare_plants(0, 2)`。由 $r[0]=0$ 可以推断植物 $2$ 不比植物 $0$ 高，因此该调用应该返回 $1$。

假设评测程序接下来调用了 `compare_plants(1, 2)`。由于对每组符合以上条件的植物高度，都有植物 $1$ 比物 $2$ 矮，因此该调用应该返回 $-1$。

#### 例 2

考虑以下调用：
```cpp
init(2, [0, 1, 0, 1])
```
假设评测程序调用了 `compare_plants(0, 3)`。由 $r[3]=1$ 可以推断植物 $0$ 比植物 $3$ 高，因此该调用应该返回 $1$。

假设评测程序接下来调用了 `compare_plants(1, 3)`。两组高度 $[3,1,4,2]$ 和 $[3,2,4,1]$ 都符合 Hazel 的观测记录，由于在第一种情况中植物 $1$ 比植物 $3$ 矮，而在第二种情况中它比植物 $3$ 高，因此该调用应该返回 $0$。

#### 约束条件

- $2\le k\le n\le 200\ 000$
- $1\le q\le 200\ 000$
- $0 \le r[i]\le k-1$（对所有 $0 \le i \le n-1$）
- $0\le x<y\le n-1$
- 存在一组或多组 **互不相同的高度** 符合数组 $r$ 记录的情况

#### 子任务

1. （5 分）$k=2$
2. （14 分）$n \le 5000,2 \cdot k > n$
3. （13 分）$2 \cdot k > n$
4. （17 分）每次 `compare_plants` 调用的正确答案是 $1$ 或 $-1$
5. （11 分）$n\le 300, q\le \frac{n\cdot (n-1)}{2}$
6. （15 分）每次调用 `compare_plants` 时有 $x=0$
7. （25 分）没有附加约束条件

#### 评测程序示例

评测程序示例以如下格式读取输⼊数据：

第 $1$ 行：$n\ k\ q$     
第 $2$ 行：$r[0]\ r[1]\ \cdots\ r[n-1]$        
第 $3+i\ (0\le i\le q-1)$ 行：$x\ y$，表⽰第 $i$ 次调用 `compare_plants` 时的参数

评测程序示例以如下格式打印你的答案：

第 $1+i\ (0\le i\le q-1)$ 行：第 $i$ 次调用 `compare_plants` 的返回值

# 题解

## 作者：s_r_f (赞：12)

安利：[IOI2020题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ioi2020-ti-xie) [IOI2020题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13697373.html)

---

[题目链接-LOJ](https://loj.ac/problem/3364) [题目链接-洛谷](https://www.luogu.com.cn/problem/P6829)

首先我们考虑构造出一个符合题意的数列。

每次选择一个 前面 $k-1$ 个位置上都是 $0$ 或者已经选过，并且当前位置为 $0$ 的位置，然后把它的值置为这个序列的最大值。不难发现这样做一定能构造出一个符合要求的排列。

这个构造的过程可以用线段树+set优化到 $\Theta(n\log n)$

不难发现，一个排列符合条件相当于它的每连续 $k$ 位的相对大小关系和我们构造出来的排列相同。

那么，不难证明在 $2k>n$ 的时候只有唯一的一个排列，所以不判 $0$ 直接比较可以获得子任务 $2/3/4$ 的分数。

现在排列不唯一怎么办？

考虑对于每个点，求出它往左/右 $k$ 个位置中，比他小的最大的数字的位置，分别记为 $pre_i$ 和 $nxt_i$ ，然后对 $pre/nxt$ 做一个倍增。

对于每组询问，假定我们构造的排列 $A$ 满足 $A_x>A_y$ 。

我们从 $x$ 开始，通过 $nxt$ 和 $pre$ 往左右跳，保证跳的时候仍然满足当前位置的值 $>A_y$ . 如果跳到的区间包含了 $y$ ，那么就输出 $1$ ，否则不能确定，输出 $0$ .

$A_x<A_y$ 的情况类似。

$\Theta((n+q)\log n)$

code(LOJ上通过) : 
```cpp
#include "plants.h"
#define LL long long
#include <bits/stdc++.h>
using namespace std; 
const int N = 200005; 
int n,k,R[N];
struct Tree2{
	#define lc o<<1
	#define rc o<<1|1
	int now[N],node[N],mxi[N<<2];
	inline int Mx(int x,int y){ return now[x] > now[y] ? x : y; }
	inline void up(int o){ mxi[o] = Mx(mxi[lc],mxi[rc]); }
	inline void Build(int o,int l,int r){
		if (l == r){ node[l] = o,mxi[o] = l; return; }
		int mid = l+r>>1; Build(lc,l,mid),Build(rc,mid+1,r),up(o);
	}
	inline void init(){ memset(now,0,n+1<<2),Build(1,1,n); }
	inline void modif(int x,int v){ if (x < 1 || x > n) return; static int o; mxi[node[x]] = x; o = node[x] >> 1,now[x] = v; while (o) up(o),o>>=1; }
	inline int get(){ static int ret; return (now[ret = mxi[1]] >= k) ? (modif(ret,0),ret) : 0; }
	
	int ll,rr,qans;
	inline void init2(){ memset(now,0,n+1<<2),memset(mxi,0,n*4+1<<2); now[0] = -1; }
	inline void Ask(int o,int l,int r){
		if (ll <= l && rr >= r){ qans = Mx(qans,mxi[o]); return; }
		int mid = l+r>>1; if (ll <= mid) Ask(lc,l,mid); if (rr > mid) Ask(rc,mid+1,r);
	}
	inline int query(int l,int r){ qans = 0,ll = max(1,l),rr = min(n,r); if (ll <= rr) Ask(1,1,n); return qans; }
	#undef lc
	#undef rc
}T2;
set<int>S; bool in[N];
typedef set<int>::iterator IT;
inline void recalc(int x){
	static IT it;
	if (in[x]){
		it = S.find(x);
		if (it == S.begin()){ it = S.end(),--it; if (*it == x) T2.modif(x,n); else T2.modif(x,x+n-*it); }
		else --it,T2.modif(x,x-*it);
	}
	else T2.modif(x,0);
}
inline void Ins(int x){
	static IT it; in[x] = 1;
	it = S.insert(x).first,++it; if (it == S.end()) it = S.begin();
	recalc(x),recalc(*it);
}
inline void Del(int x){
	static IT it; static int v; in[x] = 0;
	it = S.find(x),++it; if (it == S.end()) it = S.begin(); v = *it;
	S.erase(S.find(x)); recalc(v),recalc(x);
}
struct Tree1{
	#define lc o<<1
	#define rc o<<1|1
	int tag[N<<2],mn[N<<2];
	inline void up(int o){ mn[o] = min(mn[lc],mn[rc]); }
	inline void Tag(int o,int v){ mn[o] += v,tag[o] += v; }
	inline void down(int o){ if (tag[o]) Tag(lc,tag[o]),Tag(rc,tag[o]),tag[o] = 0; }
	inline void Build(int o,int l,int r){
		if (l == r){ mn[o] = R[l]; return; }
		int mid = l+r>>1; Build(lc,l,mid),Build(rc,mid+1,r),up(o);
	}
	int ll,rr;
	inline void Add(int o,int l,int r){
		if (ll <= l && rr >= r){ Tag(o,-1); return; }
		down(o); int mid = l+r>>1; if (ll <= mid) Add(lc,l,mid); if (rr > mid) Add(rc,mid+1,r); up(o); 
	}
	inline void Maintain(int o,int l,int r){
		if (mn[o] > 0) return; if (l == r){ mn[o] = 19260817,Ins(l); return; }
		down(o); int mid = l+r>>1; Maintain(lc,l,mid),Maintain(rc,mid+1,r),up(o);
	}
	inline void init(){ Build(1,1,n); }
	inline void maintain(){ Maintain(1,1,n); }
	inline void add(int l,int r){ ll = l,rr = r; if (ll <= rr) Add(1,1,n); }
	#undef lc
	#undef rc
}T1;
int a[N],b[N],La[N][20],Ne[N][20],Ld[N][20],Nd[N][20],L;
inline void MAIN(){
	T2.init(),T1.init(),T1.maintain();
	int i,j,x,p,now = n;
	while (now){
		x = T2.get(); a[x] = now; --now; Del(x);
		if (x >= k) T1.add(x-k+1,x); else T1.add(1,x),T1.add(n-(k-x)+1,n);
		T1.maintain();
	}
	for (i = 1; i <= n; ++i) b[a[i]] = i;
	T2.init2();
	for (i = 1; i <= n; ++i){
		p = b[i];
		La[p][0] = T2.query(p-k+1,p-1); if (La[p][0]) Ld[p][0] = p - La[p][0];
		Ne[p][0] = T2.query(p+1,p+k-1); if (Ne[p][0]) Nd[p][0] = Ne[p][0] - p;
		if (p-k+1 < 1){
			x = T2.query(p-k+1+n,n);
			if (a[x] > a[La[p][0]]) La[p][0] = x,Ld[p][0] = p + n - x;
		}
		if (p+k-1 > n){
			x = T2.query(1,p+k-1-n);
			if (a[x] > a[Ne[p][0]]) Ne[p][0] = x,Nd[p][0] = x + n - p;
		}
		T2.modif(p,i);
	}
	L = 1;
	while ((1<<L) < n) ++L; 
	for (j = 1; j <= L; ++j)
	for (i = 1; i <= n; ++i){
		if (p = La[i][j-1]){
			La[i][j] = La[p][j-1];
			Ld[i][j] = min(n,Ld[i][j-1] + Ld[p][j-1]);
		}
		if (p = Ne[i][j-1]){
			Ne[i][j] = Ne[p][j-1];
			Nd[i][j] = min(n,Nd[i][j-1] + Nd[p][j-1]);
		}
	}
}

void init(int K,vector<int> R){
	k = K,n = R.size();
	for (int i = 1; i <= n; ++i) ::R[i] = R[i-1];
	MAIN();
}
inline bool checkbig(int x,int y){
	int i,xx = x,di = y-x,s;
	for (s = 0,i = L; i >= 0; --i) if (a[Ne[x][i]] >= a[y]) s += Nd[x][i],x = Ne[x][i];
	if (s >= di) return 1;
	for (s = 0,x = xx,i = L; i >= 0; --i) if (a[La[x][i]] >= a[y]) s += Ld[x][i],x = La[x][i];
	if (s >= n-di) return 1;
	return 0;
}
inline bool checksmall(int x,int y){
	int i,yy = y,di = y-x,s;
	for (s = 0,i = L; i >= 0; --i) if (a[La[y][i]] >= a[x]) s += Ld[y][i],y = La[y][i];
	if (s >= di) return 1;
	for (y = yy,s = 0,i = L; i >= 0; --i) if (a[Ne[y][i]] >= a[x]) s += Nd[y][i],y = Ne[y][i];
	if (s >= n-di) return 1;
	return 0;
}
int compare_plants(int x,int y){
	++x,++y;
	if (a[x] > a[y]) return checkbig(x,y) ? 1 : 0;
	return checksmall(x,y) ? -1 : 0;
}
```

---

## 作者：璀璨星空1 (赞：4)

蒟蒻以前听 **正入IOI**（懂得都懂）的网课，讲这个题，当时完全听不懂，然后昨天一时兴起，就做了这个题，一下午想了 3h，觉得这一路思考的过程是很值得写一写的，于是就写了这篇题解.

大致的思维历程是按照子任务的顺序进行的.

- 子任务 1（保证 $k=2$）：

考虑此时的 $r_i$，本质上相当于我们知道相邻的两项植物之间的高度大小关系.

手玩样例，猜想如果 $x$ 和 $y$ 之间有一条大于号组成的链，或者小于号组成的链，那就能够比较出 $x$ 和 $y$ 之间的大小关系；否则，二者的大小关系就不能够确定.

考虑到该子任务的分值仅有 5 分，可以认为该猜想是正确的；证明留待以后说明.

- 子任务 2（保证 $n\leq5\times10^3$ 且 $2k>n$）：

咳咳，因为个人习惯，以下叙述中所有的编号都从 $1$ 开始，到 $n$ 结束.

如果我们再特殊化这个条件，变为 $k=n$，那么相当于每个植物都和所有其他的植物作过比较了，这时，例如说对于 $r_i=0$，那么 $i$ 的高度就是 $n$；对于 $r_i=1$，那么 $i$ 的高度就是 $n-1$，以此类推.

那么当 $k$ 稍微更小一点的时候，有什么样类似的好的性质呢？

对于任意两个植物，$u$ 和 $v$，要么 $u$ 的 $k-1$ 个后继中包含了 $v$，要么 $v$ 的 $k-1$ 个后继中包含了 $u$，当然也有可能互相包含.

遇到这种还原排列的问题，可以考虑最值；设 $i$ 这株植物的高度为 $n$，那么显然有 $r_i=0$，而且由于对于任意一株其他植物，二者都能相互够到，所以如果还存在其他的植物 $j$，满足 $r_j=0$，那么就说明，$j$ 一定是 $i$ 的 $k-1$ 个后继之一（以下简称后继集），而且一定不是 $i$ 的 $k-1$ 个前驱之一（以下简称前驱集）.

我们找到一株植物 $u$，满足 $u$ 的 $k-1$ 个前驱中，没有任何一个植物的 $r$ 值为 $0$，那么，这样的植物就是唯一的，所以说，我们能够确定下来，$h_u=n$，其中 $h$ 表示植物的高度.

在确定下来 $h_u=n$ 之后，将 $u$ 的 $k-1$ 个前驱的 $r$ 值都 $-1$，然后将 $u$ 这个植物从环上删掉；这样，就递归到了 $n-1$ 的情况，继续去找 $h=n-1$ 的植物.

如此递归下去，最终我们能够唯一确定出所有植物的高度，继而也就不难回答询问了.

顺便提一嘴：这道题在 IOI 当场的平均分只有 14.54，所以如果能独立实现到这里，就已经超过平均分了哦 qwq.

- 子任务 3（保证 $2k>n$）：

在刚才的递归过程中，每步朴素地遍历环去找 $k-1$ 个前驱中没有 $r=0$ 的植物的植物，时间复杂度是 $\mathcal{O}(n^2)$ 的，考虑使用数据结构优化这个过程.

不难发现，其实我们每次只要找一个，$r=0$ 的前驱离 ta 最远的植物就可以了，因为一定存在唯一的一株植物，所以一定是前驱最远的那株植物.

上面那句话的意思是这样的：需要维护一个集合 $S$，$S$ 中包含有所有(目前) $r_i=0$ 的植物 $i$，并且还维护了所有这样的植物，在 $S$ 中的最近前驱，和 ta 之间的距离.

支持的操作有三种：加入一株 $r_i=0$ 的植物，删除一株 $r_i=0$ 的植物，取出最近前驱最远的那株植物的位置.

通过断环成链，断成一条长度为 $3n$ 的链，再维护一个辅助集合，每次插入/删除，就将 $u-n,u,u+n$ 三个点一起插入/删除辅助集合，这两个集合都可以直接应用 $\texttt{STL Set}$，很方便地维护在环上的前驱/后继的位置.

需要特判目前 $S$ 为 $\varnothing$ 的情况；这样，剩下的问题就是，如何找到(目前) $r_i=0$ 的新植物.

本质上来说，我们需要维护一个序列，支持单点修改、区间 $-1$、查找任意一个 $0$ 的位置.

显然，使用线段树，维护区间最小值、最靠左的区间最小值位置，可以符合上述的需求.

这样，通过多个 log 数据结构的配合，可以在 $\mathcal{O}(n\log n)$ 的时间内，唯一确定出所有植物的高度.

- 子任务 4（保证每次 ```compare_plants``` 调用的正确答案是 $\pm1$）.

每次调用的正确答案是 $\pm1$，这一点其实并没有保证任何排列的特殊性质，只是说明了回答询问的时候，有些情况是不需要考虑的而已.

那么，忽略掉什么样的情况，对于我们解题而言是有帮助的？

比如说我们能够判断出 $+1$ 是不可能的，说明答案是 $-1$，但这样是没有用的，因为即使没有这条性质，我们也能够这样去判断；所以好用的应该是这样的表述：如果 $+1$ 是有可能的，说明答案是 $+1$.

什么叫做 $+1$ 是有可能的，也就是说，对于询问调用到的一对 $(x,y)$，如果存在一种可能的排列，使得 $x>y$，那么就说明在所有可能的排列中都有 $x>y$，正确答案也就是 $+1$.

沿袭子任务 3 的思想，考虑在 $2k\leq n$ 的情况下，能够仍能够快速构造出一组合法的高度序列.

我们在子任务 3 中，构造合法的高度序列，是如何应用 $2k>n$ 的性质的；就在于说，例如我们想要确定哪个 $h_i=n$，我们知道按照前驱去找 $0$，找一个 $k-1$ 个前驱中，每个前驱要么非 $0$，要么已经被删掉的植物，这种植物一定是唯一的，进而符合这种条件的植物，一定有 $h_i=n$.

那么在 $2k\leq n$ 的时候，符合 $r_i=0$、且 $k-1$ 个前驱中，每个前驱要么非 $0$，要么已经被删掉，这些条件都符合的植物，不一定是唯一的，这时我们还如何恰当地选择这些植物之一，让这株植物的 $h_i=n$，使得在之后的构造中不出现矛盾呢？

考虑这样的想法：既然不唯一，那么就随便选择一个.

算法实现上，我们直接无视掉是否 $2k\leq n$，沿袭子任务 3 中的构造方法去构造，并据此回答所有的询问；考虑为什么这样的做法是正确的.

对于任意两个植物 $u$ 和 $v$，在构造的过程中，ta 们都分别经历以下三个阶段：第一个阶段，$u$ 在线段树中被确立为 $r_u=0$、并且因此被加入集合中维护；第二个阶段，$u$ 因为不符合前驱的条件，在集合中等待；第三个阶段，$u$ 被从集合中去除，确立 $h_u$ 为目前剩下的高度中的最大值.

故而，$h_u>h_v$ 当且仅当，$u$ 进入第三个阶段的时间，早于 $v$ 进入第三个阶段的时间.

是什么影响着 $u$ 进入第三个阶段的时间？如果说，$v$ 的进入第三个阶段，改变了 $u$ 的 $r$ 值，显然 $h_u>h_v$ 是不可能做到的，类似地，如果说，$v$ 的进入第二个阶段，成为了阻碍 $u$ 的，$u$ 的 $k-1$ 个前驱之一，那么 $h_u>h_v$，就也是不可能做到的.

不难发现，上述的过程中要求 $u,v$ 之间存在前驱、后继的关系，而且，囊括了一切当 $u,v$ 之间存在前驱、后继的关系时，$h_u>h_v$ 的条件，和 $h_u<h_v$ 的条件.

故而，我们会发现，只要我们构造出了一个合法的高度序列，那么对于任何两个相距不超过 $k-1$ 个植物的植物，ta 们之间的大小关系，和我们构造出的序列中，ta 们之间的大小关系是一致的.

进一步地，一个高度排列是合法的，当且仅当该排列中，任何两个相距不超过 $k-1$ 的元素，之间的大小关系，与我们构造出的排列是一致的.

同样，容易说明，我们直接沿袭子任务 3 中的构造方法，一定能够构造出一个合法的高度排列，这里我们选择任意一个，直接选择了集合中，前驱与其距离最长的那一个.

上述证明过程和结论可能有些难以理解，但是对之后子任务的解法是很有帮助的.

- 子任务 5（保证 $n\leq300$）：

考虑子任务 4 中得到的结论，也即，一个高度排列是合法的，当且仅当该排列中，任何两个相距不超过 $k-1$ 的元素，之间的大小关系，与我们构造出的排列是一致的.

如此，我们先构造出一个合法的排列，之后对于每对距离不超过 $k-1$ 的元素对 $(u,v)$，按照 $h_u$ 和 $h_v$ 之间的大小关系连有向边，用 Floyd 算法，求出这张图的传递闭包，即可比较 $h_x$ 和 $h_y$ 之间的大小关系，包括能否确定 ta 们之间的大小关系.

- 子任务 6（每次调用 ```compare_plants``` 时有 $x=0$）：

沿袭刚才的思路，考虑去掉显式建图的过程，直接比较 $h_x$ 和 $h_y$ 之间的大小关系.

为什么必然有 $h_x>h_y$，就是因为存在一条路径 $x\to z_1\to z_2\to\dots\to z_t\to y$，使得每两个相邻的植物之间，都有一条大于号边；这样在传递闭包上，就能够说明 $x\to y$ 有一条大于号链.

不妨设 $x>y$，那么任意 $z_i$，都有 $z_i\in(x,y)\cap\Z$，且 $z_{i-1}>z_i>z_{i+1}$；考虑如果我们要在图上连两条边，一条 $a\to b$，一条 $b\to c$，并且呢，$a$ 和 $c$ 之间的距离也不超过 $k-1$，那么我们可以考虑，省去 $a\to b$ 这条边，和 $b\to c$ 这条边，只连 $a\to c$ 这条边.

这要求我们，如果说存在 $x\to a$ 这一条大于号链，还存在 $a\to c$ 这一条大于号边，并且 $b$ 这个点在 $a$ 和 $c$ 中间，满足 $h_a>h_b$，那么我们其实就可以直接判断出，$h_a>h_x$.

我们发现，这样的判断与 $h_b$ 和 $h_c$ 之间的大小关系是无关的，因此，其实对于 $a$ 点来说，只有一条边是实际上有必要连的，就是将 $a$ 和 ta 的 $k-1$ 个后继中，最靠右的、满足 $h_a>h_b$ 的点 $b$ 之间，连一条大于号边 $a\to b$，就可以了.

考虑对每个植物 $i$，都向它的 $k-1$ 个后继中，最靠右的，满足 $h_i>h_j$ 的点 $j$ 间，连一条大于号边，同理连小于号边，同理靠左也要连，然后遍历两遍序列，即可求出 $1$ 和所有其他植物之间的大小关系.

- 子任务 7（没有附加约束条件）：

仍像子任务 6 那样连边，然后对边作倍增，倍增的过程中保持 $h_x\geq h_y$，如果跳过了 $y$，就说明大于是必然的，答案就是 $+1$，否则答案就是 $0$；小于、向左是同理的.

如此，我们就完整地解决了 P6829 [IOI2020]植物比较，个人认为这道题的部分分，给的是非常之有启发性的，能够一步步引导人走向完整的做法，而且在想不出做法的情况下，也能得到一部分分数.

代码由于太丑，而且线段树是递归实现，常数太大，就不放了.

---

## 作者：tommy0221 (赞：3)

[P6829 [IOI2020]植物比较](https://www.luogu.com.cn/problem/P6829)。

[可能更好的阅读体验](https://www.cnblogs.com/zzctommy/p/14373480.html)

听WC2021的时候听到了这道题，然后就来做了。

大概思路就是处理出一个类似拓扑序的东西。如果一个数后面比它大的数都已经扩展过了，那么就扩展它。

每次取出一个 $0$ 扩展，用线段树维护区间减（有多个 $0$ 取哪个并不那么容易解决，后面会讲）。

这样可以保证下标差 $<k$ 的两个数可以通过比较拓扑序大小来比较大小，即拓扑序小的更大。

所以，如果两个数大小关系确定，那么就比较拓扑序（后文写作 $tpn$）。否则返回 $0$ 。

考虑如何判断能否判定大小关系。

不妨 $tpn_a<tpn_b$ ，那么从 $a$ 开始，不断往更大的 $tpn$ 跳，同时维持大小的确定性，如果能跳到 $b$ ，那么就可以判定大小关系。

维持大小确定性只需要不断往下标差 $<k$ 的区域跳即可。

可以处理出每个数往左 $k$ 个数中 $tpn$ 最小的比 $a$ 拓扑序大的点，跳到不能跳为止，显然倍增优化一下。往右也要扩展一次。

这个可以按照 $tpn$ 从大到小加入位置，用线段树维护区间最小值解决。

如果两次至少有一次区域包含了 $b$ 那么就可以确定大小关系。

然而在实现的时候我遇上的最大的问题是在预处理拓扑序。

如果出现多个 $0$ ，该取哪个？

直接取下标最小的必然是错的。

考虑如下数据： $\rm{r=[1,0,1,0,0],k=3}$ 。

一开始应该找的拓扑序最小的点不应该是 $2$ 。因为 $r_5$ 后面三个数，也就是 $[r_5,r_1,r_2]$ ，没有大于 $r_5$ 的，说明 $r_1<r_5$。

同理，如果找 $5$ ，发现 $r_4$ 后面三个数中间没有大于 $r_4$ 的，所以 $r_4>r_5$ 。

问题应该很明确了：先找到一个 $0$ ，如果它左边 $k$ 个之内有 $0$，那么优先取左边的那个。

剩下就全是实现的问题了。

考虑多开一颗线段树维护所有 $0$ 的位置，对于每一个区间维护：最靠左的 $0$ ，最靠右的 $0$ ，区间相邻的 $0$ 的最大距离。

同时在原来维护区间减的线段树维护区间最靠前的 $0$ 的位置，区间最小值。

处理的拓扑序的时候，先在原来的线段树查询出最靠左的 $0$ 的位置。

如果它可以扩展到 $n$ （从环的另一端绕），那么再在第二颗线段树上二分端点最靠左的合法后缀，这样子就能找到我们需要的位置了！

复杂度 $O(n\log n)$ 。

[code](https://uoj.ac/submission/453350)。

---

## 作者：tzc_wk (赞：2)

比较有意思的一道题，花费了不少时间想出来一个基于拓扑排序的做法，但是不会证明正确性。看了题解以后才恍然大悟。

先从部分分入手思考问题。$k=2$ 的部分分的做法很 easy，而且看上去没啥启发性，因此我们先思考一下 $2k>n$ 的部分分怎么做。考虑一个特殊点：$p_i=n$ 的位置 $i$，那么容易发现这个位置满足 $r_i=0$，并且它前面 $k-1$ 个位置的 $r_j\ne 0$。**同时我们还可以证明，这样的位置其实是唯一的！**，这是因为如果存在另一个 $r_j=0$，那么必然有 $(i-j)\bmod n\ge k$，而由于 $2k>n$，所以 $i$ 必然在 $j$ 的前 $k-1$ 个元素中，这样 $j$ 就不满足“前 $k-1$ 个元素的 $r_i$ 非零的限制”。这样一来就好办了，找到符合**“$r_i=0$，且 $i$ 前 $k-1$ 个位置的 $r$ 均非零”**的 $i$，在上面填上 $n$，然后把前面 $k-1$ 个位置的 $r$ 都减去 $1$ 以后继续处理剩余部分。这样得到的排列是唯一的，直接处理即可。

接下来考虑 $2k\le n$ 的部分。先考虑构造出一个合法的排列。按照传统艺能，还是找到符合“$r_i=0$，且 $i$ 前 $k-1$ 个位置的 $r$ 均非零”的 $i$，在上面填上 $n$，然后把前面 $k-1$ 个位置的 $r$ 都减去 $1$ 以后继续处理剩余部分。但是棘手的地方在于，这样的 $i$ 不唯一。怎么办呢？其实方法很简单，**随便选一个符合条件的就行了**。比较感性的证明是，你发现不管我每次选啥，都不改变**任意相邻 $k$ 个元素的相对大小关系**。这样对应的 $r_i$ 也不变。

这样如果告诉你每次答案都是 $\pm 1$，问题就很简单了。任选一个符合条件的排列然后比较 $a_x,a_y$ 大小即可。接下来考虑怎么处理 $0$ 的情况。既然你限制的是任意相邻 $k$ 个数的相对大小关系，那我就对于任意相差不超过 $k-1$ 且 $a_x>a_y$ 的 $x,y$ 连条边，然后假设判断出来的 $a_x>a_y$，我就看看图上是否存在 $x\to y$ 的路径就行了。但是用传递闭包朴素实现是 $O(n^3)$ 的。怎么优化呢？**类似于找一个代表元的思想**，我们对于一个元素 $x$，分别向顺时针和逆时针方向找到 $a_y$ 最大的 $a_y<a_x$ 的 $y$，然后连边 $x\to y$，然后你发现一个性质：**如果我能从 $x$ 沿着顺时针方向跳到 $y$，那么对于 $x,y$ 中间任何一个 $a_z<a_x$ 的 $z$，我在原图上都能从 $x$ 到 $z$“**，充分性显然，必要性可以反证法说明，大概就如果到不了，那么必然中间卡在某一个位置走不出去了，这样就无法延伸到更远的位置。

这样一来问题就容易很多了，先求出一个合法排列，然后回答询问时候假设 $a_x>a_y$，那么我们向左向右从 $x$ 开始倍增，看能否覆盖 $y$，如果能就是 $\pm 1$，不能就是 $0$。求出合法排列可以用线段树维护 $r_i$ 和前 $k-1$ 个元素里有多少 $r_i=0$ 的位置，这样总复杂度是单 log。

太晚了，代码今早起来一定补上。

upd：鸽完了。

```cpp
const int MAXN=2e5;
const int LOG_N=20;
const int INF=0x3f3f3f3f;
int n,m,c[MAXN+5],cnt[MAXN+5],p[MAXN*3+5];
namespace S1{
	struct node{int l,r,val,cnt,ok,lz_val,lz_cnt;}s[MAXN*4+5];
	void pushup(int k){
		s[k].val=min(s[k<<1].val,s[k<<1|1].val);
		s[k].cnt=min(s[k<<1].cnt,s[k<<1|1].cnt);
		s[k].ok=min(s[k<<1].ok,s[k<<1|1].ok);
	} 
	void build(int k,int l,int r){
		s[k].l=l;s[k].r=r;s[k].ok=INF;if(l==r)return s[k].val=c[l],void();
		int mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);
		s[k].val=min(s[k<<1].val,s[k<<1|1].val);
	}
	void tag(int k,int v1,int v2){
		s[k].val+=v1;s[k].cnt+=v2;s[k].ok+=v2;
		s[k].lz_val+=v1;s[k].lz_cnt+=v2;
	}
	void pushdown(int k){
		if(s[k].lz_val||s[k].lz_cnt){
			tag(k<<1,s[k].lz_val,s[k].lz_cnt);
			tag(k<<1|1,s[k].lz_val,s[k].lz_cnt);
			s[k].lz_val=s[k].lz_cnt=0;
		}
	}
	void modify_val(int k,int l,int r,int v){
		if(l<=s[k].l&&s[k].r<=r)return tag(k,v,0),void();
		pushdown(k);int mid=s[k].l+s[k].r>>1;
		if(r<=mid)modify_val(k<<1,l,r,v);
		else if(l>mid)modify_val(k<<1|1,l,r,v);
		else modify_val(k<<1,l,mid,v),modify_val(k<<1|1,mid+1,r,v);
		pushup(k);
	}
	void modify_cnt(int k,int l,int r,int v){
		if(l<=s[k].l&&s[k].r<=r)return tag(k,0,v),void();
		pushdown(k);int mid=s[k].l+s[k].r>>1;
		if(r<=mid)modify_cnt(k<<1,l,r,v);
		else if(l>mid)modify_cnt(k<<1|1,l,r,v);
		else modify_cnt(k<<1,l,mid,v),modify_cnt(k<<1|1,mid+1,r,v);
		pushup(k);
	}
	void banpos(int k,int p){
		if(s[k].l==s[k].r)return s[k].ok=INF,void();
		pushdown(k);int mid=s[k].l+s[k].r>>1;
		if(p<=mid)banpos(k<<1,p);else banpos(k<<1|1,p);
		pushup(k);
	}
	vector<int>vec;
	void setok(int k,int l,int r){
		if(s[k].val)return;
		if(s[k].l==s[k].r)return s[k].ok=s[k].cnt,vec.pb(s[k].l),void();
		pushdown(k);int mid=s[k].l+s[k].r>>1;
		if(r<=mid)setok(k<<1,l,r);
		else if(l>mid)setok(k<<1|1,l,r);
		else setok(k<<1,l,mid),setok(k<<1|1,mid+1,r);
		pushup(k);
	}
	int findpos(int k){
		if(s[k].l==s[k].r)return s[k].l;pushdown(k);
		if(!s[k<<1].ok)return findpos(k<<1);
		else return findpos(k<<1|1);
	}
}
void addcnt(int pos,int coef){
	int L=(pos+1)%n,R=(pos+m-1)%n;
	if(L<=R)S1::modify_cnt(1,L,R,coef);
	else S1::modify_cnt(1,L,n-1,coef),S1::modify_cnt(1,0,R,coef);
}
int pos[MAXN+5],toL[MAXN*3+5][LOG_N+2],toR[MAXN*3+5][LOG_N+2];
namespace S2{
	struct node{int l,r,mx;}s[MAXN*4+5];
	void build(int k,int l,int r){
		s[k].l=l;s[k].r=r;s[k].mx=-1;if(l==r)return;
		int mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);
	}
	void modify(int k,int p,int x){
		if(s[k].l==s[k].r)return s[k].mx=x,void();
		int mid=s[k].l+s[k].r>>1;
		if(p<=mid)modify(k<<1,p,x);else modify(k<<1|1,p,x);
		s[k].mx=max(s[k<<1].mx,s[k<<1|1].mx);
	}
	int query(int k,int l,int r){
		if(l<=s[k].l&&s[k].r<=r)return s[k].mx;
		int mid=s[k].l+s[k].r>>1;
		if(r<=mid)return query(k<<1,l,r);
		else if(l>mid)return query(k<<1|1,l,r);
		else return max(query(k<<1,l,mid),query(k<<1|1,mid+1,r));
	}
}
void init(int K,vector<int>R){
	n=R.size();m=K;
	for(int i=0;i<n;i++)c[i]=R[i];
	S1::build(1,0,n-1);S1::setok(1,0,n-1);for(int x:S1::vec)addcnt(x,1);
	for(int i=n;i;i--){
		int pos=S1::findpos(1);p[pos]=i;addcnt(pos,-1);
		S1::modify_val(1,pos,pos,INF);S1::banpos(1,pos);
		int L=(pos-m+1+n)%n,R=(pos-1+n)%n;
		S1::vec.clear();
		if(L<=R){S1::modify_val(1,L,R,-1);S1::setok(1,L,R);}
		else{
			S1::modify_val(1,L,n-1,-1);S1::setok(1,L,n-1);
			S1::modify_val(1,0,R,-1);S1::setok(1,0,R);
		}
		for(int x:S1::vec)addcnt(x,1);
	}
	for(int i=0;i<n;i++)pos[p[i]]=i;
	S2::build(1,0,n-1);
	for(int i=0;i<3*n;i++)toL[i][0]=toR[i][0]=-2;
	for(int i=1;i<=n;i++){
		int ps=pos[i],v;
		int L=(ps+1)%n,R=(ps+m-1)%n;
		if(L<=R)v=S2::query(1,L,R);
		else v=max(S2::query(1,L,n-1),S2::query(1,0,R));
		if(v!=-1){
			v=pos[v];
			if(v>ps)toR[ps][0]=v,toR[ps+n][0]=v+n,toR[ps+2*n][0]=v+2*n;
			else toR[ps][0]=v+n,toR[ps+n][0]=v+2*n,toR[ps+2*n][0]=3*n;
		}
		L=(ps-m+1+n)%n;R=(ps-1+n)%n;
		if(L<=R)v=S2::query(1,L,R);
		else v=max(S2::query(1,L,n-1),S2::query(1,0,R));
		if(v!=-1){
			v=pos[v];
			if(v<ps)toL[ps][0]=v,toL[ps+n][0]=v+n,toL[ps+2*n][0]=v+2*n;
			else toL[ps+2*n][0]=v+n,toL[ps+n][0]=v,toL[ps][0]=-1;
		}
		S2::modify(1,ps,i);
	}
	for(int i=0;i<n;i++)p[i+n]=p[i+2*n]=p[i];
	for(int i=0;i<3*n;i++)if(toR[i][0]==-2)toR[i][0]=i;
	for(int i=0;i<3*n;i++)if(toL[i][0]==-2)toL[i][0]=i;
	for(int i=1;i<=LOG_N;i++)for(int j=0;j<3*n;j++){
		toL[j][i]=(toL[j][i-1]==-1)?-1:toL[toL[j][i-1]][i-1];
		toR[j][i]=(toR[j][i-1]==3*n)?(3*n):toR[toR[j][i-1]][i-1];
	}
}
bool checkL(int x,int y){
	for(int i=LOG_N;~i;i--){
		if(toL[x][i]!=-1&&p[toL[x][i]]>=p[y])x=toL[x][i];
		if(x<=y)return 1;
	}return 0;
}
bool checkR(int x,int y){
	for(int i=LOG_N;~i;i--){
		if(toR[x][i]!=3*n&&p[toR[x][i]]>=p[y])x=toR[x][i];
		if(x>=y)return 1;
	}return 0;
}
int compare_plants(int x,int y){
	int rv=1;if(x>y)swap(x,y),rv=-1;
	if(p[x]<p[y])return (checkL(y+n,x+n)||checkR(y,x+n))?(-rv):0;
	else return (checkR(x+n,y+n)||checkL(x+2*n,y+n))?rv:0;
}
#ifdef LOCAL
int main(){
	int n,k,qu;scanf("%d%d%d",&n,&k,&qu);vector<int>r;
	for(int i=0,x;i<n;i++)scanf("%d",&x),r.pb(x);
	init(k,r);
	while(qu--){
		int x,y;scanf("%d%d",&x,&y);
		printf("%d\n",compare_plants(x,y));
	}
	return 0;
}
#endif
/*
4 3 2
0 1 1 2
0 2
1 2
*/
/*
4 2 2
0 1 0 1
0 3
1 3
*/
```



---


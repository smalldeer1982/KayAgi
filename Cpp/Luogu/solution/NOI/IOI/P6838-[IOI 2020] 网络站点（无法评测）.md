# [IOI 2020] 网络站点（无法评测）

## 题目描述

新加坡的互联网主干网由 $n$ 个网络站点组成，这些站点分配了从 $0$ 到 $n-1$ 的 **序号**。互联网中还有 $n-1$ 条双向链路，它们从 $0$ 到 $n-2$ 编号。每条链路连接两个不同的站点。被一条链路连接着的两个站点互相称作对方的邻居。

一个由互不相同的站点所组成的站点序列 $a_0,a_1,\ldots,a_p$ 被称作一条从站点 $x$ 到站点 $y$ 的路径，当且仅当 $a_0=x$，$a_p=y$，并且序列中每两个连续的站点都是邻居。保证从任意站点 $x$ 到任意其他站点 $y$ **有且仅有** 一条路径。

任意站点 $x$ 可以生成一个数据包，并把它发送给任意其他站点 $y$，站点 $y$ 称作这个数据包的 **目的站点**。数据包需要按下述规则在站点 $x$ 到站点 $y$ 的唯一路径上进行路由。假设数据包当前发送到了站点 $z$，其中 $y$ 是数据包的目的站点且 $z \ne y$，则站点 $z$ 会：

1. 执行 **路由函数**，找到 $z$ 到 $y$ 的唯⼀路径中 $z$ 的邻居。然后
2. 将数据包转发给这个邻居。

然而，站点有存储内存限制，可能无法存下路由函数中需要使用的完整的主干网链路列表。

你的任务是实现主干网的路由机制，它由两个函数组成。

- 第一个函数的输入参数为 $n$、主干网链路的列表和一个整数 $k \ge n-1$。该函数需要为每个站点分配一个独一无二的 **编号**，其大小在 $0$ 到 $k$ 之间（包括 $0$ 和 $k$）。
- 第二个函数是路由函数，它在站点编号分配好后部署到所有站点上。它的输入参数如下：
	- $s$，数据包当前所处的站点的 **编号**，
	- $t$，数据包的目的站点的 **编号** $(t \ne s)$，
	- $c$，表示 $s$ 的所有邻居站点的 **编号** 的列表。

该函数应该返回一个 $s$ 的邻居的 **编号**，表示数据包需要转发到的下个站点。

在每个子任务中，你的得分取决于所有站点被分配到的编号的最大值（通常来说，编号最大值越小越好）。

#### 实现细节

你需要实现下列函数：

```cpp
int[] label(int n, int k, int[] u, int[] v)
```

- $n$: 主干网中站点的数量。
- $k$: 可用的编号的最大值。
- $u$ 和 $v$: 大小为 $n-1$ 的数组，表示链路。对每个 $i(0 \le i \le n-2)$，链路 $i$ 连接着序号为 $u[i]$ 和 $v[i]$ 的站点。
- 该函数应该返回一个大小为 $n$ 的数组 $L$。对每个 $i(0 \le i \le n-1)$，$L[i]$ 表示序号为 $i$ 的站点所分配到的编号。数组 $L$ 中的所有元素必须互不相同并且大小在 $0$ 到 $k$ 之间。

```cpp
int find_next_station(int s, int t, int[] c)
```

- $s$: 数据包当前所在站点的编号。
- $t$: 数据包目的站点的编号。
- $c$: 一个数组，包含 $s$ 的所有邻居的编号。数组 $c$ 按照元素大小升序排列。
- 该函数应该返回一个 $s$ 的邻居的编号，表示数据包需要转发到的下个站点。

每个测试用例包含一个或多个独立的场景（也就是不同的主干网描述）。 对于一个包含 $r$ 个场景的测试用例，调用上述函数的评测程序会按下列步骤运行恰好两次。

程序第一次运行期间：

- `label` 函数被调用 $r$ 次。
- 返回的编号将被评测系统保存。
- 并且 `find_next_station` 不会被调用。

程序第二次运行期间：

- `find_next_station` 会被调用若干次。对于每次调用，评测程序会选择任意某个场景，该场景中的 `label` 函数所返回的编号方式将用于本次 `find_next_station` 调用。
- `label` 不会被调用。
- 特别地，在评测程序第一次运行期间，保存在静态或全局变量中的信息将无法在 `find_next_station` 函数中使用。

## 说明/提示

#### 样例说明

#### 例 1

考虑下列调用：

```cpp
label(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])
```

共有 $5$ 个站点和 $4$ 条链路，链路对应的站点序号对分别为 $(0,1)$, $(1,2)$, $(1,3)$ 和 $(2,4)$。编号的大小范围为 $0$ 到 $k=10$。

为了返回下列编号方案：

|序号|编号|
|:-:|:-:|
|$0$| $6$|
|$1$| $2$|
|$2$|$9$|
|$3$ |$3$|
|$4$ |$7$|

函数 `label` 应该返回 $[6,2,9,3,7]$。下图中的数字表示站点的序号（左图）与分配到的编号（右图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/xpq3km1p.png)

假设编号按照上图所示进行分配，考虑下列的调用：

```cpp
find_next_station(9, 6, [2, 7])
```

它表示数据包当前所处的站点编号为 $9$，其目的站点的编号为 $6$。从当前站点到目的站点的路径上，站点编号依次为 $[9,2,6]$。因此，函数应该返回 $2$，表示数据包应该转发给编号为 $2$ 的站点（其序号为 $1$）。

考虑另一个可能的调用：

```cpp
find_next_station(2, 3, [3, 6, 9])
  ```
该函数应该返回 $3$，因为目的站点（编号 $3$）是当前站点（编号 $2$）的邻居，因此目的站点直接接收到了数据包。

#### 约束条件

- $1 \le r \le 10$

对于 `label` 的每次调用：

- $2 \le n \le 1000$
- $k \ge n-1$
- $0 \le u[i],v[i] \le n-1$（对于所有 $0 \le i \le n-2$）

对于 `find_next_station` 的每次调用，其输入参数来自于任意选择的某次之前对 `label` 的调用。考虑它所产生的编号，

- $s$ 和 $t$ 是两个不同站点的编号。
- $c$ 是编号为 $s$ 的站点的所有邻居的编号的序列，升序排列。

对于每个测试用例，所有场景加到⼀起，传递给函数  `find_next_station` 的所有数组 $c$ 的总长度不超过 $10^5$。

#### 子任务

1. （5 分）$k=1000$，不会出现拥有多于 $2$ 个邻居的站点。
2. （8 分）$k=1000$，链路 $i$ 连接站点 $i+1$ 和 $\lfloor\frac{i}{2}\rfloor$。
3. （16 分）$k=10^6$，最多一个站点拥有多于 $2$ 个的邻居。
4. （10 分）$n \le 6$，$k \le 10^9$
5. （61 分）$k \le 10^9$

在子任务 5 中，你可以获得部分分。 令 $m$ 为所有场景中 `label` 返回的最大编号。 对于这个子任务，你的得分将根据下表计算得到：

|最大编号|得分|
|:-:|:-:|
|$m \ge 10^9$|$0$|
|$2000 \le m < 10^9$|$50 \cdot \log_{5 \cdot10^5}(\frac{10^9}{m})$|
|$1000 < m < 5000$|$50$|
|$m \le 1000$|$61$|

#### 评测程序示例

评测程序示例以如下格式读取输入数据：

第 $1$ 行：$r$

接下来是 $r$ 块内容，每块描述了一个单独的场景，格式如下：

第 $1$ 行：$n\ k$        
第 $2+i(0 \le i \le n-2)$ 行：$u[i]\ v[i]$         
第 $1+n$ 行：$q$，`find_next_station` 的调用次数    
第 $2+n+j(0 \le j \le q-1)$ 行：$z[j]\ y[j]\ w[j]$，第 $j$ 次调用 `find_next_station` 时所涉及的站点的 **序号**。此时，数据包在站点 $z[j]$，目的站点为 $y[j]$，应该要转发给站点 $w[j]$。

评测程序示例以如下格式打印你的结果：

第 $1$ 行：$m$

接下来是 $r$ 块内容，分别对应输入中的场景。每块的格式如下：

第 $1+j(0 \le j \le q-1)$ 行：站点的 **序号**，它所对应的 **编号** 是第 $j$ 次调用 `find_next_station` 时返回的结果。

注意：评测程序示例每次执行时会同时调用 `label` 和 `find_next_station`。

# 题解

## 作者：lory1608 (赞：12)

这道题比较奇怪，他会运行两次你的程序。

#### 题意简述

给你一棵树，然后你需要给他重新标号，每次询问会给出一个你报好过的树上的起点$s$和终点$t$，以及起点的所有邻居，你需要返回$s\to t$的路径上的下一点是什么。

**注意：你的主函数中不能存任何有用信息。**

### 题解

你需要对所有点进行标号，那么我们考虑从一个跟开始，然后将其标为1000,然后对于每个点，如果他在奇数层，那么我们就先进行标号然后再向下给他的儿子标号，如果是偶数层，哦们先对他的儿子标号然后再给他标号。

这样对于每次询问。

- 起点为根，我们很轻易的知道从$t$在哪一个子树当中。
- 如果他在奇数层（**此时邻居所有值都比他大**），第一个子树中的点的编号为$s+1\to num[son_{v_1}]$,第二个子树的点的编号为$num[son_{1}]+1\to num[son_{2}]$,$\cdots$,最后一个子树$m$的编号为$num_{son_{m-1}}+1\to num_{son_{m}}$。
- 如果他在偶数层（**此时邻居所有值都比他小**），第一个子树中的点的编号为$num[son_{v_1}]\to num[son_{v_2}]-1$,第二个子树的点的编号为$num[son_{v_2}]\to num[son_{v_3}]-1$,$\cdots$,最后一个子树$m$的编号为$num_{son_{m}}\to s-1$。

这样就可以$O(n^2)$的通过这一题了。

**确实一一道大思维题。**

```cpp
#include "stations.h"
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define REP(u) for(int i=p[u];i!=-1;i=e[i].nxt)
#define ll long long
#define PII pair<int,int>
using namespace std;
const int maxn=1005;
vector<int>e[maxn];
vector<int>ans;
int cnt=-1;
inline void dfs(int u,int fa,int dep)
{
	if(dep%2==1)ans[u]=++cnt;
	for(int i=0;i<=(int)(e[u].size())-1;++i)
	{
		int v=e[u][i];
		if(v!=fa)
		{
			dfs(v,u,dep+1);
		}
	}
	if(dep%2==0)ans[u]=++cnt;
}

std::vector<int> label(int n, int k, std::vector<int> u, std::vector<int> v) {
	ans.clear();
	FOR(i,0,n-1)ans.push_back(0); 
	FOR(i,0,n-1)e[i].clear();
	cnt=-1;
	FOR(i,0,n-2)
	{
		e[u[i]].push_back(v[i]);
		e[v[i]].push_back(u[i]);
	}
	dfs(0,0,0);
	ans[0]=1000;
	return ans;
}

int find_next_station(int s, int t, std::vector<int> c) {
	if((int)c.size()==1)return c[0];
	else
	{
		if(s==1000)
		{
			FOR(i,0,(int)(c.size())-2)
			{
				if(t>=c[i]&&t<c[i+1])return c[i];
			}
			return c[(int)c.size()-1];
		}
		else
		{
			if(s>c[(int)c.size()-1])///max
			{
				FOR(i,1,(int)(c.size())-2)
				{
					if(t>=c[i]&&t<c[i+1])return c[i];
				}
				if(t>=c[(int)c.size()-1]&&t<s)return c[(int)c.size()-1];
				else return c[0];
			}
			else///min
			{
				if(t>s&&t<=c[0])return c[0];
				FOR(i,1,(int)(c.size())-2)
				{
					if(t>c[i-1]&&t<=c[i])return c[i];
				}
				return c[(int)c.size()-1];
			}
		}
	}
}


```



---

## 作者：cyc001 (赞：4)

~~你谷什么时候才能修好通信题评测啊。~~

### 题意简述

这是一道通信题。

给定一棵 $n$ 个点的节点的树，每个点有在 $0 \sim k-1$ 的 **互不相同的序号**，你需要实现一下两个功能：

1. 给树的每个节点赋一个 **互不相同的非负整数编号** ，要求任意编号均 $< k$。
2. 给定编号 $u$ 和 $v$，以及和 $u$ 有边相连的点的编号集合，问 $u$ 到 $v$ 的路径上与 $u$ 的邻域的编号集合。

对于 $100$ 分做法，$2 \le n \le k \le 10^3$。

### Solution

考虑一个简化版的问题：假如我们令序号为 $0$ 的点为根，令 $u$ 为 $v$ 的祖先节点，怎么做。

我们可以考虑按照 dfn 序给树标号。

询问就很好处理了，直接找到 $\le v$ 的最小邻域编号即可。

现在我们没有这个性质了，但是我们发现按照 dfn 标号时父亲的是好找的，于是我们的问题转化为了如何去判断 $v$ 是否在 $u$ 的子树里，剩下的处理很简单：如果不在就往父亲走，否则转化为简化版问题。

如果 $k$ 的限制比较松（$10^6$），则这个问题是好做的。

令 $\text{mx}(u)$ 表示 $u$ 子树内的最大 dfn，我们将每个点的标号设为 $\text{dfn}(u) \times 10^3+\text{mx}(u)$，这样判断是否在子树内是好做的。

然后我们发现这样做很唐，因为我们根本没有用到当前节点的信息。不难发现奇数层储存 $\text{mx}(u)$，偶数层储存 $\text{dfn}(u)$ 是可以还原出信息的。

但是这样并没有保证互不相同，但总数已经是 $O(n)$ 的了，剩下的处理也很简单。

完结撒花 QwQ。

### Code

[QOJ AC 记录](https://qoj.ac/submission/982675)

```cpp
#include"stations.h"
#include<bits/stdc++.h>
#define cir(i,a,b) for(int i=a;i<b;++i)
using namespace std;

class encode_function{
private:
    class tree{
    private:
        vector<vector<int>> gr;
        vector<int> id;
        auto dfs(int u,auto&cdfn,int utype=true,int f=-1)->void{
            if(utype) id[u]=++cdfn;
            for(auto&i:gr[u]) if(i!=f) dfs(i,cdfn,utype^1,u);
            if(!utype) id[u]=++cdfn;
        }
    public:
        auto link(int u,int v){
            gr[u].emplace_back(v);
            gr[v].emplace_back(u);
        }
        auto encode(){
            auto cdfn=-1;
            dfs(0,cdfn);
            return id;
        }
        tree(int _n):gr(_n),id(_n){}
    };
public:
    static auto encode(vector<int> u,vector<int> v){
        const auto n=(int)(u.size())+1;
        tree gr(n);
        cir(i,0,n-1) gr.link(u[i],v[i]);
        return gr.encode();
    }
};

class decode_function{
private:
    enum node_type{uODD,uEVEN};
    static auto get_type(int u,vector<int> v){
        for(auto&x:v) if(u<x) return uEVEN;
        return uODD;
    }
    static auto noderange(int u,vector<int> v){
        const auto utype=get_type(u,v);
        if(utype==uEVEN){
            const auto l=u;
            v.erase(ranges::max_element(v));
            const auto r=v.empty()?l:*ranges::max_element(v);
            return pair(l,r);
        }else{
            const auto r=u;
            v.erase(ranges::min_element(v));
            const auto l=v.empty()?r:*ranges::min_element(v);
            return pair(l,r);
        }
    }
    static auto father(int u,vector<int> v){
        const auto utype=get_type(u,v);
        return utype==uEVEN?*ranges::max_element(v):*ranges::min_element(v);
    }
    static auto child(int u,int t,vector<int> v){
        const auto utype=get_type(u,v);
        if(utype==uEVEN){
            v.emplace_back(u);
            ranges::sort(v);
            for(auto i=(int)(v.size())-1;i;--i) if(v[i-1]<t){
                return v[i];
            }
            return u;
        }else{
            v.emplace_back(u);
            ranges::sort(v);
            cir(i,0,(int)(v.size())-1) if(v[i+1]>t) return v[i];
            return u;
        }
    }
public:
    static auto decode(int u,int t,vector<int> v){
        const auto[l,r]=noderange(u,v);
        if(t>l-1&&t-1<r) return child(u,t,v);
        return father(u,v);
    }
};

vector<int> label(int,int,vector<int> u,vector<int> v){
    return encode_function::encode(u,v);
}

int find_next_station(int u,int t,vector<int> v){
    return decode_function::decode(u,t,v);
}

```

### 后记

这题为啥有黑来着。

---


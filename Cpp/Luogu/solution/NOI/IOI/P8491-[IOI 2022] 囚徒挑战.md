# [IOI 2022] 囚徒挑战

## 题目背景

# 滥用评测资源者封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

原题时间限制 1s，为了节约评测资源，时间限制修改为 0.5s

## 题目描述

一个监狱里关着 $500$ 名囚徒。
有一天，监狱长给了他们一个重获自由的机会。
他把装钱的两个袋子 A 和 B 放在一个房间里。
每个袋子装有若干枚硬币，数量的范围在 $1$ 到 $N$ 之间（包含 $1$ 和 $N$）。
两个袋子里硬币的数量**不同**。
监狱长给囚徒们提出了挑战，目标是指出硬币数量较少的那个袋子。

房间里除了袋子还有一块白板。
任意时刻白板上写着一个数，一开始写的是 $0$。

监狱长让囚徒一个接一个地进入房间。
每个进入房间的囚徒不知道他之前进入过房间的囚徒有多少人，也不知道是哪些人。
每次一个囚徒进入房间时，他看一眼白板上目前写的这个数。
看完之后，他必须在袋子 A 和 B 之间做出选择。
接着，他**检查**自己选的那个袋子，知道了里面有多少枚硬币。
然后，这名囚徒必须选择做以下两种**行动**之一：

* 将白板上的数改写成一个非负整数，并离开房间。
注意他可以改变成新的数，也可以保留当前的数。
然后挑战继续进行（除非所有 $500$ 名囚徒都已经进过房间）。
* 指出硬币数量较少的那个袋子。这会立即结束挑战。

对于已经进过房间的囚徒，监狱长不会让他再次进入房间。

如果某个囚徒正确地指出硬币较少的袋子，则囚徒们获得挑战的胜利。
如果指出的袋子不正确，或者所有 $500$ 人进过房间之后还没有人尝试指出硬币较少的袋子，则囚徒们失败。

挑战开始之前，囚徒们集合在监狱大厅商量应对挑战的共同**策略**，分以下三个步骤：
* 他们挑选一个非负整数 $x$，作为他们可能会写在白板上的最大的数。
* 他们决定对任意一个数 $i$ ($0 \le i \le x$)，如果某个囚徒进入房间后看到白板上写着数 $i$，那么他应该去检查哪个袋子。
* 他们决定当某个囚徒得知选中的袋子里的硬币数量后要采取的行动。具体来说，对任意写在白板上的数 $i$ ($0 \le i \le x$) 和检查选中的袋子里的硬币数量 $j$ ($1 \le j \le N$)，他们要决定做出以下两种行动之一：
  - 白板上应该要写一个 $0$ 到 $x$ 之间（包含 $0$ 和 $x$）的什么数；
  - 指出哪个袋子是硬币较少的。

如果赢得挑战，监狱长会在囚徒们继续服刑 $x$ 天后释放他们。

你的任务是提出能够确保囚徒们赢得挑战的策略（不管袋子 A 和 B 中的硬币数量是多少）。
你的得分取决于 $x$ 的值（详见子任务一节）。

## 说明/提示

### 约束条件

- $2 \leq N \leq 5000$。

### 子任务

1. （5 分）$N \le 500$，$x$ 的值不能超过 $500$。
1. （5 分）$N \le 500$，$x$ 的值不能超过 $70$。
1. （90分）$x$ 的值不能超过 $60$。

对于任何测试用例，如果 `devise_strategy` 返回的数组是不合法的，则你在该子任务上的得分为 $0$。

子任务 3 有部分分。
令 $m$ 为该子任务中所有测试用例返回数组对应的 $x$ 的最大值，你的得分将根据下表计算：

| 条件 | 得分 |
| :-: | :-: |
| $40 \leq m \leq 60$ | $20$ |
| $26 \leq m \leq 39$ | $25 + 1.5 \times (40 − m)$ |
| $m = 25$ | $50$ |
| $m = 24$ | $55$ |
| $m = 23$ | $62$ |
| $m = 22$ | $70$ |
| $m = 21$ | $80$ |
| $m \leq 20$ | $90$ |

### 评测程序示例

评测程序示例按以下格式读取输入：

* 第 $1$ 行：$N$
* 第 $2 + k$ 行 ($0 \le k$)：$A_k \; B_k$
* 最后一行：$-1$

除第一行和最后一行外，每行表示一个场景。
将第 $2 + k$ 行对应的场景称为场景 $k$。
场景 $k$ 中，袋子 A 装有 $A[k]$ 枚硬币，袋子 B 装有 $B[k]$ 枚硬币。

评测程序示例首先调用 `devise_strategy(N)`。
$x$ 的值是返回数组的长度减一。
如果评测程序示例检测到 `devise_strategy` 返回的数组不符合实现细节中描述的约束，它会打印如下错误信息并退出：

* `s is an empty array`：$s$ 是空的数组（表示不合法的策略）。
* `s[i] contains incorrect length`：存在一个下标 $i$ ($0 \le i \le x$) 满足 $s_i$ 的长度不是 $N + 1$。
* `First element of s[i] is non-binary`：存在一个下标 $i$ ($0 \le i \le x$) 满足 $s_{i,0}$ 既不是 $0$，也不是$1$。
* `s[i][j] contains incorrect value`：存在下标 $i, j$ ($0 \le i \le x, 1 \le j \le N$) 满足 $s_{i, j}$ 的值不在 $-2$ 和 $x$ 之间。

否则，评测程序示例产生两项输出内容。

首先，评测程序示例以如下格式打印你的策略的输出：

* 第 $1 + k$ 行 ($0 \le k$)：场景 $k$ 下你的策略的输出。
如果用该策略导致某个囚徒指出袋子 A 是硬币较少的，则输出字符 `A`。
如果用该策略导致某个囚徒指出袋子 B 是硬币较少的，则输出字符 `B`。
如果用该策略后没有囚徒指出哪个袋子的硬币较少，则输出字符 `X`。

其次，评测程序示例以如下格式在当前目录下写一个文件 `log.txt`：

* 第 $1 + k$ 行 ($0 \le k$)：$w_{k,0} \; w_{k,1} \; \ldots$

第 $1 + k$ 行的序列对应于场景 $k$，描述了写在白板上的数。
具体来说，$w[k][l]$ 是第 $l + 1$ 个囚徒进入房间后写的数。

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `int` | `int64`     | `int[]`            |
| ------- | ----- | ----------- | ------------------ |
| `void ` | `int` | `long long` | `std::vector<int>` |

| `int[][]`                       | 数组 `a` 的长度 |
| ------------------------------- | ------------------- |
| `std::vector<std::vector<int>>` | `a.size()`          |


# 题解

## 作者：断清秋 (赞：12)

[题目传送门](https://loj.ac/p/3831)

题意自己看。

考虑最小化 $m$ 的值，如果 $m=n$ 就有很显然的做法，直接随便问一个袋子把那个袋子的数写黑板上就行了，可以获得 $5pts$。

然后考虑一点比较聪明的策略，比较两个数大小没必要枚举，可以比较每一位的值就行，每次写一个数的最高位，比另一个数的相应位置即可。这样你需要记录黑板上的数是哪一位上的。假如你存的是一个 $b$ 进制数，那当前位取值就是 $[0,b)$，那这个跟 $n \times m$ 矩阵中的点 $(i,j)$ 一维映射成 $(i-1) \times m+j$ 是一样的。但是考虑最后一位为 $0$ 的情况，你需要跟初始状态为 $0$ 作区分，因此你只需要额外 $+1$，所以在第 $i$ 位的原数上加个 $(i-1) \times b+1$ 即可。

然后你考虑一共有 $\left\lceil\log_b n\right\rceil$ 位，每一位最大值为 $b-1$，所以 $m$ 的最大值为 $b(\left\lceil\log_b n\right\rceil-1)+1+b-1$，即 $m=b\left\lceil\log_b n\right\rceil$。

当 $n=5000$ 时，取 $b=3$ 得到最优解，此时 $m=24$。

然后考虑 $[1,m]$ 每个值都对应一次比较，那么减少需要比较的情况就相当于减少 $m$。发现 $A \neq B$，所以无论如何它们比较到最后一位时不会相等。而最后一位只有 $0,1,2$ 三种可能性，查询到最大值 $2$ 和最小值 $0$ 时都可以直接看，只有看到 $1$ 时需要再比较一次，那么也就是有两种情况不需要比较，于是可以做到 $m=22$。

但是会发现 $m=22$ 已经是这个做法瓶颈了，考虑一些新做法。

想象一棵搜索树，可以想到进制位这种做法类似链式结构，宽度不大而深度很深，考虑把这棵树改成类似线段树的形式，以宽度换深度。

那么不难想到类似线段树的结构，判断每个决策点可能属于哪个区间，每次递归下去，最后找到单点。

然后你惊喜地发现这个东西很有优化前途，因为每次递归到一个区间 $[l,r]$，都可以运用之前的优化去掉最大值最小值，使需要比较的区间变为 $[l+1,r-1]$，于是每次区间长度 $-2$。

然后这个东西显然全用 $3$ 进制就不是很优秀了，考虑 $2$  和 $3$ 混合使用，然后你可以递推一下每一层比较用哪个底数比较好，其中一种比较优秀的方式是 $2,3,3,3,3,3,3$，然后这样就能做到 $m=20$。

这个东西实现很麻烦，需要微调底数位置，然后可以通过递归或者倍增实现。以下给出一份递归实现的代码。

代码：

```cpp
#include<bits/stdc++.h>
#include"prison.h"
#define ll long long
#define back return
#define ri int
using namespace std;
vector<vector<int>> s;
void work(int p,int d,int id,int pl,int pr,int l,int r)
{
	int now=3*(d-1)+id;
	for(ri i=pl;i<=pr;i++)
		s[p][i]=now;
	for(ri i=l;i<=pl;i++)
		s[now][i]=-s[now][0]-1;
	for(ri i=pr;i<=r;i++)
		s[now][i]=s[now][0]-2;
	pl++,pr--;
	if(pl>pr)
		back ;
	if(pr-pl<=1)
	{
		work(now,d+1,1,pl,pr,pl-1,pr+1);
		back ;
	}
	if(pr-pl<=3)
	{
		int mid=(pl+pr)/2;
		work(now,d+1,1,pl,mid,pl-1,pr+1);
		work(now,d+1,2,mid+1,pr,pl-1,pr+1);
		back ;
	}
	int mid1=(pl*2+pr)/3,mid2=(pl+pr*2)/3;
	work(now,d+1,1,pl,mid1,pl-1,pr+1);
	work(now,d+1,2,mid1+1,mid2,pl-1,pr+1);
	work(now,d+1,3,mid2+1,pr,pl-1,pr+1);
}
vector<vector<int>> devise_strategy(int n)
{
	for(ri i=0;i<=20;i++)
		s.push_back(vector<int>(n+1,0));
	s[0][0]=s[4][0]=s[5][0]=s[6][0]=s[10][0]=s[11][0]=s[12][0]=s[16][0]=s[17][0]=s[18][0]=1;
	work(0,0,3,1,n,1,n);
	back s;	
}
```

---

## 作者：KaisuoShutong (赞：7)

P8491 [IOI2022] 囚徒挑战 题解。

首先发现要比较大小。加之本题非常小的上界限制，确定了按位比较的基本思路。所以一个粗估的做法是：

> 假设 $b$ 进制，则每次用一个二元组 $(x,y)$ 表示当前在比较第 $x$ 位，A 的第 $x$ 位为 $y$（$y=b$ 表示尚未询问），每次一个人进来，如果 $y=b$ 就翻 A 袋子更新 $y$，否则翻 B 袋子作比较，如果相同就更一个 $(x-1,b)$，否则返回答案。
> 

把二元组映射成一个数即可。这样可以做到 $\lceil\log_bn\rceil\times (b+1)$ 的上限，毛估估一下取到 $b=3$，上限 $32$。

优化点显然在于那个 $y=b$ 太浪费了。考虑每次交替记下 A、B 袋子，每次比完不取 $(x-1,b)$ 而是取记下 $x-1$ 位的比较数。这样可以把 $b+1$ 砍成 $b$，上限 $24$。

这样过程里的每一步基本都必要了。实在要说就是 $A\neq B$ 让最后一步放 $0/2$ 的情况直接能返回，进而做到上限 $22$。

---

观察样例发现 $n=3$ 的情况只需要 $1$ 就可以了。？

发现优化的点在于问出 $1$ 或者 $n$ 就直接判定结果了。

进一步 $n=4$ 也只需要 $1$。这个干的事情和 $24\to 22$ 的过程其实是相似的！

那考虑每一步按位操作是不是都能砍掉左右两边？

这样我们搞出一个迫真按位，即不按照位来，而是记录可能的值域区间，每次砍成三块，不断缩小。

但这样的操作虽然让每层都缩小了 $2$，但体现在实际上还是只能做到上限 $21$。

这时的步骤大概是：$5000\to 1666\to 555\to\cdots\to 20\to 6\to 2$，考虑操作一下让 $6$ 以下只需要 $2$ 步。可以发现从中砍成两块就行。（或者按照一个更普适的说法，在这层取 $b=2$）

这样就在上限 $20$ 内解决了本题。没啥放代码的必要性吧。

---

## 作者：Mortidesperatslav (赞：4)

这题还是比较困难的，其他几篇题解讲的稍微有点简单，我开始一直没看懂，直到参考[这篇题解](https://www.luogu.com.cn/article/8ulkia0a)的代码写了一遍才理解。所以代码结构会比较相似。本题解的目的主要是给其余题解略加增补。

首先，对于 $x \leq N$ 的做法应该是比较容易的，第一个囚犯先把第一个袋子的金币数量写上去，然后第二个囚犯上去就好了。

考虑优化，把状态压缩了，记录每一位和当前比较到第几位，三进制和二进制混用。

然后我们可以发现，由于每个囚犯的操作仅仅取决于黑板上写的数，如果两个囚犯写了同一个数，意味着成环了，会永远循环下去，这是不可取的。

于是最多 $x$ 个囚犯进行操作，也就是我们要用不超过 $20$ 个囚犯。

然后重点讲讲实现（因为这个并不是很好实现）。

维护两段区间 $[L,R]$ 和 $[l,r]$，记录当前状态从 $u$ 转移过来，第 $x$ 个袋子当前位上的值为 $k$。定义 $[L,R]$ 表示当前状态已经确定了第 $x$ 个袋子金币数在 $[L,R]$ 范围内，$[l,r]$ 表示另一个袋子金币数在 $[l,r]$ 范围内。

那么，对于 $[l,L]$ 和 $[R,r]$，可以直接返回，剩余部分递归处理即可。

特别地，当 $R-L$ 较小时，我们贪心选取其余进制。

下面是奶猫可可爱爱的代码喵：

```cpp
#include <bits/stdc++.h>
using namespace std;
vector< vector<int> > vec;
const int base = 3;
void solve(int u, int op, int dep, int l, int r, int L, int R){
    for (int i = L; i <= R; i++)//转移过来，记录
        vec[u][i] = base * (dep - 1) + op;
    for (int i = l; i <= L; i++){//[l,L]直接比较出来
        if (vec[base * (dep - 1) + op][0] == 0){
            vec[base * (dep - 1) + op][i] = -1;
        }else{
            vec[base * (dep - 1) + op][i] = -2;
        }
    }
    for (int i = R; i <= r; i++){//[R,r]直接比较出来
        if (vec[base * (dep - 1) + op][0] == 0){
            vec[base * (dep - 1) + op][i] = -2;
        }else{
            vec[base * (dep - 1) + op][i] = -1;
        }
    }
    L++, R--;
    if (L > R)//处理完了
        return;
    if (R <= L + 1)//直接往下递归一层
        solve(base * (dep - 1) + op, 1, dep + 1, L - 1, R + 1, L, R);
    else if (R <= L + 3){//用二进制
        int mid = (L + R) >> 1;
        solve(base * (dep - 1) + op, 1, dep + 1, L - 1, R + 1, L, mid);
        solve(base * (dep - 1) + op, 2, dep + 1, L - 1, R + 1, mid + 1, R);
    } else{//用三进制
        int mid1 = ((L << 1) + R) / 3, mid2 = (L + (R << 1)) / 3;
        solve(base * (dep - 1) + op, 1, dep + 1, L - 1, R + 1, L, mid1);
        solve(base * (dep - 1) + op, 2, dep + 1, L - 1, R + 1, mid1 + 1, mid2);
        solve(base * (dep - 1) + op, 3, dep + 1, L - 1, R + 1, mid2 + 1, R);
    }
}
vector< vector<int> > devise_strategy(int N){
    for (int i = 0; i <= 20; i++)
        vec.push_back(vector<int>(N + 1, 0));
    for (int i = 4; i <= 20; i += 6)
        for (int j = i; j <= i + 2; j++)
            vec[j][0] = 1;
    vec[0][0] = 1;
    solve(0, base, 0, 1, N, 1, N);
    return vec;
}
```

---

## 作者：dead_X (赞：4)

IOI 特有乱搞题，被 \_ZMF\_ 薄纱了，我完全不会。

首先你会发现 $500$ 个人就是搞笑的，事实上只有 $x$ 个人会参与决策。

然后考虑一个 $\log n$ 级别的做法，就是一位一位比，每次传要查看的位数，和另一个数在这一位的值，假设底数为 $b$，$x$ 的最小值为 $b\lceil\log_bn\rceil$，显然 $b$ 趋近 $e$ 的时候是最优的。

在 $b=2$ 的时候我们需要 $26$ 次，$b=3$ 的时候[需要 $24$ 次](https://oj.uz/submission/657161)，好像拉了点。

然后你发现其实如果 $n$ 很小很小，最后几位其实有点浪费，比如 $n=2$ 的时候你只要看看第一个数是几就做完了，完全没必要再去看第二个数。更一般地，如果某个数取到了当前可能的上界和下界，因为两个数不同，我们就可以立刻回答。

所以 $\lceil\log_b n\rceil$ 其实可以换成更小的值：$F(x)=F(\lceil\frac{n-2}{3}\rceil)$，[只需要 $21$ 次](https://oj.uz/submission/657167)。

最后你发现当区间大小为 $4$ 的时候用 $b=2$ 更优，现在[只需要 $20$ 次](https://oj.uz/submission/657169)了，可以通过。

---

## 作者：Purslane (赞：3)

# Preface

如果这题在去年的专题中出现，我就会知道构造题可以打表，我就能做出百万富翁，我就能高一进集训队，我现在就不用努力了。

可是没有如果，不要为过去的事情玉玉了，毕竟还有一次机会。最后 $50$ 天，一定要加油啊。

# Solution

很神秘的题目。

按照今天早上上课的说法，这道题让我们构造一个比较 $a$ 和 $b$ 大小的自动机。

有一个非常朴素的想法：从高往低按位比较。

第一个人把 $a$ 的最高位通过某种方式记录到黑板上。第二个人通过黑板上的数据**判断出这是 $a$ 的最高位并将其解码**，然后读取 $b$ 的最高位。如果能比出大小，就直接返回；否则，将 $b$ 的次高位记到黑板上，留给第三个人解码，依此类推。

思路 $1$：按照二进制。设 $V = \lceil \log_2 N \rceil$，则我们容易给出 $x=2V$ 的构造：当黑板上记录了 $x_0$ 的时候，表示的是二进制从高往低第 $\lfloor \frac{x_0+1}{2} \rfloor$ 位，值是 $x_0 \bmod 2$。如果是奇数位，那么表示的是 $a$，否则表示的是 $b$。完成了 $x=26$。

思路 $2$：根据经典结论，如果若干个数和为定值，那么将其拆成若干个 $3$ 乘起来最大。也就是说，我们使用三进制，这样完成了 $x=24$。

这两个看起来都挺人类的。有没有更牛的做法呢？

有的兄弟，有的！

思路 $3$：我们知道 $1 \le n \le 5000$。所以一个人读取到 $1$ 或者 $5000$ 了，就可以直接返回。

也就是说！设 $f_x$ 为 $x$ 最大能表示多少数，则有：

$$
f_x = \max_{1 \le y \le x} yf_{x-y}+2
$$

其中 $f_0=0$。发现 $f_{20}$ 恰好大于等于 $5000$！

给出构造：`3 3 3 3 3 2 2 1`，`5588 1862 620 206 68 22 10 4`。

总结一下，这道题有一点“通信题”的特征（本质还是构造策略）。先设计一个朴素的算法，然后观察有没有可以优化掉的 corner case，就可以带来可观的优化。

代码有一点小细节吧。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
vector<int> bs={3,3,3,3,3,2,2,1,0};
vector<int> mul={5588,1862,620,206,68,22,10,4,2};
int calc_rnk(int p,int x) {
	ffor(i,0,p-1) {
		if(x==mul[i]-1||x==0) return 0;
		x--;
		x%=mul[i+1];
	}
	return x;
}
vector<vector<int>> devise_strategy(int N) {
	vector<int> tmp;
	vector<vector<int>> ans;
	tmp.resize(N+1);
	ffor(i,0,20) ans.push_back(tmp);
	ffor(i,0,N-1) {
		if(i==0) ans[0][i+1]=-1;
		else if(i==5587) ans[0][i+1]=-2;
		else ans[0][i+1]=((i-1)/1862)%3+1;
	}
	ffor(i,0,7) {
		int l=1,r=0;
		ffor(j,0,i-1) l+=bs[j];
		r=l+bs[i]-1;
		ffor(t,l,r) {
			ans[t][0]=((i^1)&1);
			ffor(j,0,N-1) {
				int col=calc_rnk(i,j);
				if(col==-1) ans[t][j+1]=-1;
				if(col==0) {
					if(ans[t][0]==0) ans[t][j+1]=-1;
					else ans[t][j+1]=-2;	
				}
				else if(col==mul[i]-1) {
					if(ans[t][0]==0) ans[t][j+1]=-2;
					else ans[t][j+1]=-1;	
				}
				else {
					int p=((col-1)/mul[i+1])%bs[i];	
					if(p!=t-l) {
						if(p<t-l) {
							if(ans[t][0]==0) ans[t][j+1]=-1;
							else ans[t][j+1]=-2;
						}
						else {
							if(ans[t][0]==0) ans[t][j+1]=-2;
							else ans[t][j+1]=-1;	
						}
					}
					else {
						int col=calc_rnk(i+1,j);
						if(col==0) {
							if(ans[t][0]==0) ans[t][j+1]=-1;
							else ans[t][j+1]=-2;
						}
						else if(col==mul[i+1]-1) {
							if(ans[t][0]==0) ans[t][j+1]=-2;
							else ans[t][j+1]=-1;
						}
						else ans[t][j+1]=((col-1)/mul[i+2])%bs[i+1]+r+1;
					}
				}
			}
		}
	}
	return ans;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P8491)

**题目大意**

> 给定两个 $[1,n]$ 中的正整数 $a,b$（$a\ne b$），以及变量 $x$，初始 $x=0$。
>
> 构造一个程序，每次输入 $x$，然后查询 $a$ 或 $b$ 中的一个，再修改 $x$，最终得到 $a,b$ 的大小关系。
>
> 要求过程中的 $x\in[0,20]$。
>
> 数据范围：$n\le 5000$。

**思路分析**

首先可以想到逐位比较，$x$ 上存储当前要比较二进制第几位，以及 $a$ 的这一位是多少，或者还没有查询 $a$。

状态数 $3\lceil \log_2n\rceil=39$，如果改成三进制做到 $4\lceil\log_3n\rceil=32$。

需要进一步优化，尝试优化掉未查询 $a$ 的状态，这是可以做到的，即先查询 $a$ 的最高位，然后查询 $b$，比较最高位，并且直接记录 $b$ 的次高位，再比较 $a$ 的次高位。

此时轮流询问 $a,b$，状态数 $3\lceil \log_2n\rceil =24$。

继续优化，如果比较到最低位，且有有一个数最低位 $0/2$，那么根据 $a\ne b$ 直接知道答案。

类似拓展，我们维护这两个数可能的范围 $[l,r]$，如果查询得到的数直接为 $l$ 或 $r$，则可以直接返回答案。

那么 $f_n=f_{(n-2)/3}+3$，可以做到 $21$ 个状态。

进一步不需要每次都三进制，直接 dp 转移，枚举每次询问的进制，$f_k=\max f_{k-i}\times i+2$，可以算出 $f_{20}\ge n$。

一种可能的方法是只在最后一层用二进制，其他时候用三进制。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "prison.h"
using namespace std;
vector<vector<int>> a;
int o(int d,int c) { return d?(d-1)*3+c+1:0; }
void cdq(int d,int c,int l,int r,int L,int R) {
    auto &b=a[o(d,c)];
    for(int i=L;i<=l;++i) b[i]=-1-b[0];
    for(int i=r;i<=R;++i) b[i]=-2+b[0];
    ++l,--r; if(l>r) return ;
    if(l==r) return b[l]=o(d+1,0),cdq(d+1,0,l,r,l-1,r+1);
    if(r-l+1<=4) {
        int mid=(l+r)>>1;
        for(int i=l;i<=r;++i) b[i]=o(d+1,i>mid);
        cdq(d+1,0,l,mid,l-1,r+1);
        cdq(d+1,1,mid+1,r,l-1,r+1);
        return ;
    }
    int k=r-l+1,x=l+k/3,y=x+(k+2)/3;
    for(int i=l;i<=r;++i) b[i]=o(d+1,(i>=y)+(i>=x));
    cdq(d+1,0,l,x-1,l-1,r+1);
    cdq(d+1,1,x,y-1,l-1,r+1);
    cdq(d+1,2,y,r,l-1,r+1);
}
vector<vector<int>> devise_strategy(int n) {
    a=vector<vector<int>>(21,vector<int>(n+1));
    for(int i:{0,4,5,6,10,11,12,16,17,18}) a[i][0]=1;
    cdq(0,0,1,n,1,n);
    return a;
}
```

---

## 作者：AllenJYL (赞：1)

### **第一部分：$N,x\le500$**

注意到，两个袋子中都一定存在至少一枚硬币。如果囚犯将某一个袋子中 **硬币的数量** 写在白板上，那么后面进房间的囚犯会看到白板上的数不为 $0$。根据此，制定如下策略：

- 情形一：某一个囚犯进入房间，若白板上的数为 $0$，则他可以知道在他之前没有任何袋子被检查。他需要检查袋子 A，并将其中硬币的数量写在白板上。
- 情形二：某一个囚犯进入房间，若白板上的数不为 $0$，则他可以知道在他之前有囚犯将袋子 A 检查了。他需要检查袋子 B，并通过白板上的数得知袋子 A 中硬币的数量，并宣布答案。

值得一提的是，情形一只会在第一个进入房间的囚犯上发生，情形二只会在第二个进入房间的囚犯上发生。这意味着在这个子任务，只需要前两个囚犯即可完成题目要求。

期望得分 $5$ 分。

### **第二部分：$x\le52$**

可以发现，在第一部分中，我们浪费了剩下的所有囚犯。为了物尽其用，同时由于 $x$ 阈值的缩小，可以考虑按照每一位比较硬币数量。具体而言，按照每一个二进制位。从高到低比较时，如果两个数某一位上不同，则可以立即宣布答案。

这样，我们将比较的任务均摊到了更多囚犯上，也就是说更多的囚犯在任务中起到了作用。

沿用第一部分的策略，只不过，一个囚犯不用把他所检查的袋子中硬币的数量写到白板上。他只需要告诉后来的囚犯如下信息以助于后来的囚犯分析局面：
- 他此时决定检查哪一个袋子；
- 他此时决定比较硬币数量二进制值的第几位（从高到低）；
- 他此时得知的硬币数量二进制值该位具体是 $0/1$。

一个囚犯同样需要具备：看到白板上的信息可以解密出上一个囚犯正在干什么，并且做出对应的回答：
- 假设上一个囚犯正在检查袋子 $k$ 的第 $i$ 位，当前囚犯检查另一个袋子 $j$；
- 若袋子 $j$ 第 $i$ 位与白板上获得的袋子 $k$ 第 $i$ 位的值不同，则宣布答案；
- 否则，根据袋子 $j$ 中硬币的数量得知第 $i+1$ 位的值，并向下一位囚犯宣布：
    - 他此时决定检查袋子 $j$；
    - 他此时决定比较硬币数量二进制值的第 $i+1$ 位；
    - 他此时得知的硬币数量二进制值第 $i+1$ 位具体是 $0/1$。
- 此时，我们称**此囚犯检查了袋子 $j$ 的第 $i+1$ 位**。显然，每一位只会有一个囚犯检查，在这个案例中，**第 $i$ 位由上一个囚犯检查**，检查了袋子 $k$。

由于 $N\le5000$，二进制位数至多为 $13$，如上策略需要将信息压缩至一个数中，分析可得不同局面数量至多为 $2\times2\times13=52$。

期望得分 $30$ 分。

### **第三部分：$x\le26$**

研究第二部分的策略，可以发现如下事实：如果一个囚犯正在检查袋子 A 的第 $i$ 位，则：

- 检查第 $i+1$ 位的囚犯一定在检查袋子 B；
- 检查第 $i+2$ 位的囚犯一定在检查袋子 A；
- 检查第 $i+3$ 位的囚犯一定在检查袋子 B；
- 检查第 $i+4$ 位的囚犯一定在检查袋子 A；
- 以此类推。

这样，如果囚犯们事先知道检查第一位囚犯一定会检查袋子 A（或者袋子 B，在这里只要保证他们知道一个确定的袋子）的第 $0$ 位，那么他们在进入房间时自然熟知检查第 $i$ 位的上一个囚犯正在检查哪个袋子，他们自己就可以检查另一个袋子。

分析可得不同局面数量至多为 $2\times13=26$。

期望得分 $56$ 分。

### **第四部分：$x\le24$**

继续优化策略，考虑研究最后一位。

如果某囚犯开始检查某袋子硬币数的最后一位，那么他能得知：两个袋子硬币的数量在前面所有位上的值均相等。这是因为如果前面某一位上的值不等（$0/1$ 各一个），那么检查前面位的囚犯就会在那时候宣布答案并结束任务，不可能轮到这位囚犯。

同时，根据题意，两个袋子中硬币数不相等，那么这位囚犯：
- 如果检查出某袋子硬币数最后一位为 $1$，那么他没有必要再向下一位囚犯宣布信息了，这是因为他一定可以通过上述两个性质得知另一个袋子硬币数最后一位为 $0$，他可以直接宣布答案；
- 如果检查出某袋子硬币数最后一位为 $0$，那么他也没有必要再向下一位囚犯宣布信息，这是因为他一定可以得知另一个袋子硬币数最后一位为 $1$，同样可以直接宣布答案。

分析可得不同局面数量至多为 $2\times12=24$。

期望得分 $65$ 分。

### **第五部分：$x\le22$**

在解决这一部分之前，我们需要引入一个新的概念：**掌管区间**。

> 在第四部分的策略中，即将检查最后一位的囚犯可以知道两个袋子硬币数量的最后一位一定为 $0$ 和 $1$ 两者各出现一次。由于两个袋子硬币数量在前面所有位上的值均相等，可以考虑将两个袋子硬币数量描述为 $\delta_0+0,\delta_0+1$，其中 $\delta_0$ 表示最后一位前面的所有位所代表的十进制下的值。
>
> 同理，即将检查倒数第二位的囚犯可以知道两个袋子硬币数量的最后两位一定为 $00,01,10,11$ 中的两个。这也可以改写为 $\delta_1+0,\delta_1+1,\delta_1+2,\delta_1+3$，其中 $\delta_1$ 表示倒数第二位前面的所有位所代表的十进制下的值。
>
> 这样，每一个囚犯都能知道两个袋子的硬币数量的值域为 $[\delta+l,\delta+r]$（且为整数）。在上述策略下：
>- 对于检查最后一位的囚犯，$\delta=\delta_0,l=0,r=1$；
>- 对于检查倒数第二位的囚犯，$\delta=\delta_1,l=0,r=3$；
>- 以此类推。
>
> 我们称这个值域区间为一个囚犯的 **掌管区间**。
>
> 值得一提的是，仅仅根据白板上的信息，囚犯无法知道 $\delta_?$ 的准确值，但是他们可以且只需要知道 $l,r$ 的值，这足够让他们分析出他们需要的内容了。更好的是，他们也能知道上一个囚犯掌管区间的 $l,r$ 值，这可以通过推理得到。

回到策略的优化。可以发现想要继续优化下去很难，我们不能再拘泥于二进制了。考虑多种进制共同使用，此时每一 “位” 不再是一个固定进制下的了。那么，具体用哪种进制呢？

可以借助 dp 告诉我们答案。设计 dp 状态 $f_i$ 表示不同局面数量为 $i$ 时，第一位进入房间的囚犯的掌管区间的最大长度。转移考虑枚举第一位囚犯使用哪一个进制，我们设为 $j$ 进制。那么得到 $f_i=\max_{j=1}^i(j\times f_{i-j})$，这代表着 $j$ 进制下每一个值都能将局面导向一个长度为 $f_{i-j}$ 的掌管区间。

初值 $f_0=2$，表示一个知道掌管区间为 $[\delta+0,\delta+1]$ 的囚犯一定可以通过第四部分的策略不需要任何局面就可以宣布答案。

得到 $f_{22}>5000$。转移时记录此时使用哪一个进制最优，顺着转移出来的结果计算即可。

期望得分 $80$ 分。

### **第六部分：$x\le20$**

优化 dp 转移时的策略。我们可以发现第四部分的策略似乎可以沿用到所有数位上。具体地，对于一个囚犯检查第 $i$ 位，掌管区间为 $[\delta+l,\delta+r]$，如果他检查某个袋子硬币的数量满足其第 $i$ 至最后一位的值的十进制表示为 $l$，那么他就能知道此时袋子中的硬币数量为 $\delta+l$。由于两个袋子硬币的数量一定不同，那么可以得知另一个袋子中硬币数量的值域为 $[\delta+l+1,\delta+r]$，也就有了大小关系。他可以直接宣布答案。

同理，如果他检查某个袋子硬币的数量满足其第 $i$ 至最后一位的值的十进制表示为 $r$，那么也同样可以宣布答案。对于检查第 $i+1$ 位的囚犯也是一样，他知道当前囚犯的掌管区间。如果在比较第 $i$ 位时就已经遇到了上述局面，那么和当前囚犯一样，他也可以直接宣布答案。

也就是说，只有在两个袋子中硬币数量的值域为 $[\delta+l+1,\delta+r-1]$ 时，才能继续考虑下一位。那么，改写转移方程为 $f_i=\max_{j=1}^i(j\times f_{i-j}+2)$，新增的 $2$ 即为掌管区间的两端特殊情况。

得到 $f_{20}>5000$。

期望得分 $100$ 分。

---


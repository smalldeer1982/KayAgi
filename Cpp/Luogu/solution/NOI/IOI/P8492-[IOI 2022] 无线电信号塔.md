# [IOI 2022] 无线电信号塔

## 题目背景

# 滥用评测资源者封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

由于本题数据点过多，结合洛谷评测技术实现情况，本题将以 ACM mode 进行评分。

## 题目描述

雅加达有 $N$ 个无线电信号塔。这些信号塔排布成一条直线，并且从左到右依次编号为从 $0$ 到 $N - 1$。
对于每个满足 $0 \le i \le N - 1$ 的 $i$，信号塔 $i$ 的高度为 $H_i$ 米。
所有塔的高度都是**不同的**。

对于某个为正数的信号干扰参数 $\delta$，一对信号塔 $i$ 和 $j$ ($0 \le i \lt j \le N - 1$) 之间能够互相通信，当且仅当存在一个中间信号塔 $k$ 满足如下条件：

* 塔 $i$ 在塔 $k$ 的左边，并且塔 $j$ 在塔 $k$ 的右边，即 $i \lt k \lt j$；
* 塔 $i$ 和塔 $j$ 的高度都至多为 $H[k] - \delta$ 米。

Pak Dengklek 想租一些信号塔来组建他的新无线电网络。
你的任务是回答 Pak Dengklek 提出的 $Q$ 个询问。这些询问的形式如下：
给定参数 $L, R$ 和 $D$ ($0 \le L \le R \le N - 1$ 且 $D > 0$)，在满足下述所有条件时，Pak Dengklek 最多能够租多少个信号塔：

 * Pak Dengklek 只能租编号在 $L$ 和 $R$ 之间的信号塔（包括 $L$和 $R$）；
 * 信号干扰参数 $\delta$ 的值为 $D$；
 * Pak Dengklek 租的信号塔两两之间必须能够进行通信。

注意，无论中间信号塔 $k$ 是否被租，两个已租的信号塔都可以借助信号塔 $k$ 进行通信。

## 说明/提示

### 约束条件

* $1 \le N \le 100\;000$
* $1 \le Q \le 100\;000$
* $1 \le H_i \le 10^9$ (对于所有满足 $0 \le i \le N - 1$ 的 $i$ )
* $H_i \ne H_j$ (对于所有满足 $0 \le i \lt j \le N - 1$  的 $i$ 和 $j$ )
* $0 \le L \le R \le N - 1$
* $1 \le D \le 10^9$

### 子任务

1. (4 分) 存在一个满足下述所有条件的信号塔 $k$ ($0 \le k \le N - 1$) 
   * 对于 $0 \le i \le k - 1$ 的每个 $i$：$H_i \lt H_{i + 1}$ 
   * 对于 $k \le i \le N - 2$ 的每个 $i$：$H_i \gt H_{i + 1}$ 
2. (11 分) $Q = 1$，$N \le 2000$
3. (12 分) $Q = 1$
4. (14 分) $D = 1$
5. (17 分) $L = 0$，$R = N - 1$
6. (19 分)  $D$ 的值在 `max_towers` 的所有调用中都是相同的
7. (23 分) 没有额外的限制

### 评测程序示例

评测程序示例读取如下格式的输入：

* 第 $1$ 行：$N \; Q$
* 第 $2$ 行：$H_{0} \; H_{1} \; \ldots \; H_{N - 1}$
* 第 $3 + j$ 行（$0 \le j \le Q - 1$）：$L \; R \; D$（对应第 $j$ 次询问）

评测程序示例按照如下的格式打印你的答案：

* 第 $1 + j$ 行（$0 \le j \le Q - 1$）：`max_towers` 对第 $j$ 次询问的返回值

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `int` | `int64`     | `int[]`            |
| ------- | ----- | ----------- | ------------------ |
| `void ` | `int` | `long long` | `std::vector<int>` |

| `int[][]`                       | 数组 `a` 的长度 |
| ------------------------------- | ------------------- |
| `std::vector<std::vector<int>>` | `a.size()`          |


# 题解

## 作者：Kubic (赞：12)

一个不太一样的做法，想的时候一直以为是 $2\log$，写的时候发现实际上很容易 $1\log$。

首先考虑 $l=1,r=n$ 怎么做。

可以发现两两可以匹配等价于任意相邻两个可以匹配。

于是考虑对于每个 $i$ 求出 $L_i,R_i$ 分别表示 $i$ 左右两边第一个 $\ge a_i+d$ 的位置。把它看成数轴上的区间 $(L_i,R_i)$。一组方案合法当且仅当选出的所有 $i$ 所对应的线段两两不交。

此时有一个非常关键的 observation：这些线段相互之间的关系只有包含和相离。

证明只需反证即可，这里不再赘述。

对于一个线段，如果它包含其它线段，那么选择它肯定不优。称一个线段为“好线段”当且仅当它不包含其它线段。显然我们一定可以选择所有的“好线段”，而这就是我们的最优策略。

此时问题就变为了统计“好线段”的个数。

通过分析可以得到，对于一个 $i$，$(L_i,R_i)$ 是一条好线段等价于 $\forall j\in(L_i,R_i),a_i<a_j$。

我们可以对于每个 $i$ 求出左右两边第一个比它小的位置，进一步可以求出最大的 $d$ 使得 $(L_i,R_i)$ 是一个“好线段”，设这个值为 $w_i$。我们的问题就转化为了求出区间中有多少个 $\ge d$ 的 $w_i$。直接上主席树即可。

吗？

我们会发现可能会有一个 $i$，满足 $(L_i,R_i)$ 中存在 $<a_i$ 的值，但是这个值在询问的区间外。这种情况下 $i$ 实际上是可以选的，但是我们会认为它不能选，导致算出的答案偏小。

一种无脑的解决方案是直接上三维数点干掉这个情况，时空复杂度都是 $O(n\log ^2n)$，不知道能不能过。

可以观察到，左右两个边界处各有至多一个 $i$ 被我们漏掉了，考虑如何找到左边界处的 $i$，右边界处的可以类似处理。

分析 $i$ 的性质：

- $i$ 一定是一个 $[l,r]$ 的前缀最小值。

- $i$ 一定满足 $L_i<l$，而对于所有 $[l,r]$ 的前缀最小值而言，满足 $L_i<l$ 的 $i$ 一定是一段前缀。

- $i$ 一定是这段前缀中的最后一个。

上面的三条性质的证明都比较容易，这里不再赘述。

有了这些性质，我们可以直接在 $[l,r]$ 的所有前缀最小值构成的序列上二分找到唯一可能合法的 $i$，再判断其是否合法即可。

前缀最小值序列可以用可持久化数据结构维护，也可以建成一棵树形结构并把二分改为倍增。

至此，我们在 $O((n+m)\log n)$ 的时间复杂度内解决了这道题。

参考代码：

```cpp
#include "towers.h"
#include <bits/stdc++.h>
using namespace std;
#define mid ((l+r)/2)
#define clz __builtin_clz
const int N=100005,M=4000005,up=1e9;
int n,a[N],st[N],w[N],w1[N],w2[N],fa1[17][N],fa2[17][N],mx[17][N];
int cntS,rt[N];struct Seg {int vl,ch[2];}sg[M];
int qMx(int l,int r)
{
	if(l>r) return 0;int t=31-clz(r-l+1);
	return max(mx[t][l],mx[t][r-(1<<t)+1]);
}
void upd(int p,int &p1,int l,int r,int x)
{
	sg[p1=++cntS]=sg[p];++sg[p1].vl;if(l==r) return;
	if(x<=mid) upd(sg[p].ch[0],sg[p1].ch[0],l,mid,x);
	else upd(sg[p].ch[1],sg[p1].ch[1],mid+1,r,x);
}
int qSm(int p,int l,int r,int qL,int qR)
{
	if(!p || qL>qR) return 0;
	if(l>=qL && r<=qR) return sg[p].vl;int res=0;
	if(qL<=mid) res=qSm(sg[p].ch[0],l,mid,qL,qR);
	if(qR>mid) res+=qSm(sg[p].ch[1],mid+1,r,qL,qR);return res;
}
void init(int n1,vector<int> a1)
{
	n=n1;for(int i=1;i<=n;++i) a[i]=mx[0][i]=a1[i-1];
	for(int i=1;i<=n;++i)
	{
		while(st[0] && a[i]<a[st[st[0]]]) --st[0];
		fa1[0][i]=st[0]?st[st[0]]:0;st[++st[0]]=i;
		for(int j=1;j<=16;++j) fa1[j][i]=fa1[j-1][fa1[j-1][i]];
	}st[0]=0;for(int i=0;i<=16;++i) fa2[i][n+1]=n+1;
	for(int i=n;i;--i)
	{
		while(st[0] && a[i]<a[st[st[0]]]) --st[0];
		fa2[0][i]=st[0]?st[st[0]]:n+1;st[++st[0]]=i;
		for(int j=1;j<=16;++j) fa2[j][i]=fa2[j-1][fa2[j-1][i]];
	}
	for(int i=1;i<=16;++i) for(int j=1;j+(1<<i)-1<=n;++j)
		mx[i][j]=max(mx[i-1][j],mx[i-1][j+(1<<i-1)]);
	for(int i=1;i<=n;++i)
	{
		w1[i]=qMx(fa1[0][i]+1,i-1)-a[i];
		w2[i]=qMx(i+1,fa2[0][i]-1)-a[i];w[i]=min(w1[i],w2[i]);
		if(w[i]>0) upd(rt[i-1],rt[i],1,up,w[i]);else rt[i]=rt[i-1];
	}
}
bool chk(int x,int l,int r,int d)
{
	if(x<l || x>r || w[x]>=d) return 0;
	if(w1[x]<d && fa1[0][x]>=l) return 0;
	if(w2[x]<d && fa2[0][x]<=r) return 0;return 1;
}
int max_towers(int l,int r,int d)
{
	int t,t1=++r,t2=++l,res;
	res=qSm(rt[r],1,up,d,up)-qSm(rt[l-1],1,up,d,up);
	for(int i=16;i>=0;--i)
	{t=fa1[i][t1];if(t>=l && qMx(t+1,r)<a[t]+d) t1=t;}
	for(int i=16;i>=0;--i)
	{t=fa2[i][t2];if(t<=r && qMx(l,t-1)<a[t]+d) t2=t;}
	return res+chk(t1,l,r,d)+(t1!=t2 && chk(t2,l,r,d));
}
```

---

## 作者：1kri (赞：5)

假设只有一组询问：

考虑枚举每一个点作为“山峰”，将它左右所有与其高度差至少为 $D$ 的点两两连一条线段，则答案等价于最多能选择出的满足任两条线段交不超过 $1$ 的线段个数加 $1$。首先最优选取方式一定是任两条相邻线段的交都为 $1$，然后考虑在我们的选择中，若某相邻两条无交，则一定可以通过调整变成交为 $1$。

这样直接模拟就是 $O(n)$ 的，倍增一下就可以处理 $D$ 全相等，多组询问的情况。

---

有两个性质：

1. 不存在交大于 $1$ 且不相互包含的线段。
2. 不存在高度大的点所代表的线段包含高度小的点所代表的线段。

这两个性质容易画图证明。

---

然后我们考虑一个点代表的线段什么时候会被选。

我们找到它左右两边第一个高于它的点，不难发现它能被选当且仅当它连出的最短线段不经过高于它的点。这样我们就可以通过区间最值简单计算出它可以被选的 $D$ 的最大值。

那么我们就可以通过按 $D$ 值从大到小建出主席树算出某个 $D$ 值下区间合法“山峰”数。

最后一个问题，就是“山峰”在区间内，不代表线段在区间内。但是满足这个条件的一定只能是最左或最右的“山峰”，我们主席树二分找到这两个点特判一下就可以了。

---

时间复杂度：$O((n+q) \log n)$ 。


---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P8492)

**题目大意**

> 给定 $a_1\sim a_n$，保证两两不同，$(i,j)$ 有边当且仅当存在 $i<k<j$ 使得 $\max(a_i,a_j)\le a_k-d$。
>
> $q$ 次询问 $ql,qr,d$，求 $[ql,qr]$ 范围内的最大团。
>
> 数据范围：$n,q\le 10^5$。

**思路分析**

可以发现一个点集为团当且仅当相邻点之间有边。

然后考虑如何检验两个点之间有边，设 $[l_i,r_i]$ 表示 $i$ 左右两侧第一个 $\ge a_i+d$ 的点。

那么两个点有边当且仅当 $[l_i+1,r_i-1],[l_j+1,r_j-1]$ 无交。

因此求解原问题变成计算最大不相交线段数。

但这仍然不好做，注意到任意两个线段要么相交要么包含。

否则 $l_i\le l_j\le r_i\le r_j$，则 $a_i+d> a_{l_j}\ge  a_j+d$ 且 $a_i+d\le a_{r_i}<a_j+d$，因此矛盾。

删掉所有包含其他线段的线段，剩余的本质不同线段数就是答案。

那么考虑什么样的线段不包含其他线段，可以发现 $a_i=\min a[l_i,r_i]$ 时其他的线段不可能被该线段包含，且每个线段恰在最小值处计数。

从全局询问开始，那么对于每个 $i$，其有贡献的时刻一定是 $d$ 的前缀。

具体来说，只要考虑所有 $\ge a_i$ 的点构成的连续段 $[L_i,R_i]$，则 $d\le \min(\max a[L_i,i],\max a[i,R_i])-a_i$ 时有贡献。

套上区间询问变成二维数点，主席树维护。

但对于区间询问，如果 $L_i<ql$ 时，$l_i$ 可以 $<L_i$，只要 $a_i$ 是 $[\max(l_i,ql),\min(r_i,qr)]$ 范围内的最小值即可。

那么对于这样的点，推一些性质：$a_i=\min a[ql,i]$，因此考虑 $a[ql,n]$ 的所有后缀最小值。

另一个条件是 $\max a[ql,i]<a_i+d$，显然满足这个条件的后缀最小值是一段前缀。

并且对于一个满足条件的 $a_i$，他后面的后缀最小值一定不满足 $\max a[ql,i]<a_i+d$。

所以只求出最后一个满足该条件的后缀最小值并判断即可，把后缀最小值单调栈建树，树上倍增即可维护。

时间复杂度 $\mathcal O((n+q)\log V)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "towers.h"
using namespace std;
const int MAXN=1e5+5,V=1e9;
int n,a[MAXN],lf[MAXN][20],rf[MAXN][20],stk[MAXN],st[MAXN][20];
int bit(int x) { return 1<<x; }
int qmx(int l,int r) {
    int k=__lg(r-l+1);
    return max(st[l][k],st[r-bit(k)+1][k]);
}
struct SegmentTree {
    int ct[MAXN*32],ls[MAXN*32],rs[MAXN*32],tot;
    void ins(int u,int l,int r,int q,int &p) {
        ct[p=++tot]=ct[q]+1;
        if(l==r) return ;
        int mid=(l+r)>>1;
        if(u<=mid) ins(u,l,mid,ls[q],ls[p]),rs[p]=rs[q];
        else ins(u,mid+1,r,rs[q],rs[p]),ls[p]=ls[q];
    }
    int qry(int ul,int ur,int l,int r,int p) {
        if(ul<=l&&r<=ur) return ct[p];
        int mid=(l+r)>>1,s=0;
        if(ul<=mid) s+=qry(ul,ur,l,mid,ls[p]);
        if(mid<ur) s+=qry(ul,ur,mid+1,r,rs[p]);
        return s;
    }
}   T;
int wl[MAXN],wr[MAXN],w[MAXN],rt[MAXN];
void init(int N,vector<int>H) {
    n=N;
    for(int i=1;i<=n;++i) st[i][0]=a[i]=H[i-1];
    int tp=0;
    for(int i=1;i<=n;++i) {
        while(tp&&a[stk[tp]]>a[i]) rf[stk[tp--]][0]=i;
        lf[i][0]=stk[tp],stk[++tp]=i;
    }
    while(tp) rf[stk[tp--]][0]=n+1;
    rf[n+1][0]=n+1;
    for(int k=1;k<20;++k) for(int i=0;i<=n+1;++i) {
        lf[i][k]=lf[lf[i][k-1]][k-1],rf[i][k]=rf[rf[i][k-1]][k-1];
    }
    for(int k=1;k<20;++k) for(int i=1;i+bit(k)-1<=n;++i) {
        st[i][k]=max(st[i][k-1],st[i+bit(k-1)][k-1]);
    }
    for(int i=1;i<=n;++i) {
        wl[i]=qmx(lf[i][0]+1,i)-a[i],wr[i]=qmx(i,rf[i][0]-1)-a[i];
        w[i]=min(wl[i],wr[i]),T.ins(w[i],0,V,rt[i-1],rt[i]);
    }
}
int max_towers(int l,int r,int d) {
    ++l,++r;
    int ans=T.qry(d,V,0,V,rt[r])-T.qry(d,V,0,V,rt[l-1]),u=l,v=r;
    for(int k=19;~k;--k) {
        if(rf[u][k]<=r&&a[rf[u][k]]+d>qmx(l,rf[u][k])) u=rf[u][k];
        if(lf[v][k]>=l&&a[lf[v][k]]+d>qmx(lf[v][k],r)) v=lf[v][k];
    }
    auto chk=[&](int x) {
        return w[x]<d&&(wl[x]>=d||lf[x][0]<l)&&(wr[x]>=d||rf[x][0]>r);
    };
    ans+=chk(u)+(u!=v&&chk(v));
    return ans;
}
```

---

## 作者：modfish_ (赞：0)

写了得有四五天，终于还是写出来了……

## 原始思路
显然，两两能够通信，等价于任意相邻两座信号塔可以通信。

不难想到：维护 $s_i$ 表示 $i$ 如果被选中，那么它左边相邻的信号塔编号的最大值为 $s_i-1$；$t_i$ 则表示它右边相邻的信号塔编号的最小值为 $t_i+1$。可以发现，$s_i$ 即为 $i$ 左边第一个大于等于 $H_i+\delta$ 的位置，而 $t_i$ 即为 $i$ 右边第一个大于等于 $H_i+\delta$ 的位置。

不难想到一个经典的技巧：如果区间 $[s_i,t_i]$ 两两要么不交，要么包含，那么它们可以建成一棵树。实际上，虽然它并不严格满足以上条件，但两个没有包含关系的区间的交不超过 $1$。

---

#### 证明
假定存在区间 $[s_i,t_i],[s_j,t_j]$ 满足 $0\le s_i\le s_j<t_i\le t_j\le n-1$，也就是它们的交大于 $1$ 且不包含。

这说明 $H_i+\delta>H_{s_j}$，然而 $H_j+\delta\le H_{s_j}$，所以 $H_i>H_j$。

又有 $H_i+\delta\le H_{t_j}$，然而 $H_j+\delta>H_{t_j}$，所以 $H_i<H_j$。

矛盾，所以假设不成立。

---

于是，每个区间向最小的（有多个的话，再取 $H_i$ 最小的）、包含它的区间连边。这样将形成一棵树，不难发现，我们所需要做的就是在这棵树上，编号在 $[L,R]$ 之间的所有点中，选出最多的、互相没有祖先关系的点。

毫无疑问，直接维护这棵树是困难的，不过我还是想出了一种 $O((n+q)\log^2 n)$ 的方法，因为太过恶心所以就不提了。

## 稍有改进的思路
现在让我们考虑：假定已经建出了这棵树，如何统计答案？

可以发现，我们只要选出编号在 $[L,R]$ 中的所有的点 $i$，满足 $i$ 的子树内没有除它以外的、编号在 $[L,R]$ 之间的点。

处理出 $i$ 的子树内，编号小于 $i$ 的点的最大编号 $x_i$（没有的话记做 $-\infty$），编号大于 $i$ 的点的最小编号 $y_i$（没有的话记做 $\infty$），那么 $i$ 能够产生贡献当且仅当：$x_i<L\le i\le R<y_i$。

考虑容斥。记 $A$ 表示满足 $x_i<L$ 且 $R<y_i$ 的 $i$ 的数量，$B$ 表示满足 $x_i<L$ 且 $R<i$ 的 $i$ 的数量，$C$ 表示满足 $i<L$ 且 $R<y_i$ 的 $i$ 的数量，那么答案即为 $A-B-C$。

以上的二维偏序问题可以用两层线段树做到 $O((n+q)\log^2 n)$。具体地，在平面上插入 $3n$ 个点，即 $(x_i+1,y_i-1),(x_i+1,i-1),(i+1,y_i-1)$，第一种点的点权设为 $1$，后两种点的点权设为 $-1$，每次只要查询平面上 $x\le L,y\ge R$ 的所有点的点权和即可。

问题在于如何处理 $x_i$ 与 $y_i$。不难发现：

记 $l_i$ 表示 $i$ 左边第一个小于 $H_i$ 的位置，$r_i$ 表示 $i$ 右边第一个小于 $H_i$ 的位置。那么：

$$x_i=\begin{cases}l_i, & s_i< l_i\\ -\infty, & s_i> l_i\end{cases}$$

$$y_i=\begin{cases}r_i, & t_i> r_i\\ \infty, & t_i< r_i\end{cases}$$

（没有写等于时的情况是因为很明显 $s_i\ne l_i,t_i\ne r_i$）

所以，对于每一个 $i$，它的 $x_i,y_i$ 随着 $\delta$ 增长，至多各变化一次。故至多只有 $2n$ 个有效的 $\delta$，处理出这些 $\delta$ 时，上文所述的那个平面中的所有点即可。使用可持久化线段树即可。

以上做法的时间复杂度为 $O((n+q)\log^2 n)$，有些数据可以跑到高达 4s，所以并不能通过此题。

## 最终思路
以上做法的复杂度瓶颈在于在线的二维数点。

注意到我们实际上忽略了这个问题的一大条件：$x_i$ 只可能是 $l_i$，$y_i$ 只可能是 $r_i$。

提到 $l_i$ 和 $r_i$，不难想到一个东西：笛卡尔树。我们所求的这个问题，在笛卡尔树上是否有一些特殊的性质呢？

事实上是有的。注意到：限制 $l_i<L\le i$，等价于 $L$ 必定要在笛卡尔树上 $i$ 的左子树中（或者 $i$）；限制 $i\le R<r_i$，等价于 $R$ 必定要在笛卡尔树上 $i$ 的右子树中（或者 $i$）。

记 $a_i$ 表示最小的 $D$ 满足 $\delta=D$ 时，$s_i<l_i$；$b_i$ 表示最小的 $D$ 满足 $\delta=D$ 时，$t_i>r_i$。

问题转化为：求区间 $[L,R]$ 中 $i$ 的个数，满足：

- 若 $\delta\ge a_i$，则 $L$ 必须在 $i$ 的左子树内。
- 若 $\delta\ge b_i$，则 $R$ 必须在 $i$ 的右子树内。

当 $\delta\ge a_i$ 时，称 $i$ 的左子树限制被激活；当 $\delta\ge b_i$ 时，称 $i$ 的右子树限制被激活。考虑 $\delta$ 确定时，如何计算 $i$ 的数量。

首先：若 $i$ 的左、右子树限制均未被激活，那么它一定可以被记入答案。维护 $sum1(l,r)$ 表示 $[l,r]$ 中这样的 $i$ 的数量。

记 $L,R$ 的最近公共祖先为 $u$。若 $i$ 在 $L$ 到 $u$ 的链上（不包括 $L,u$），那么 $i$ 的左子树限制可以被满足；若 $i$ 在 $R$ 到 $u$ 的链上（不包括 $R,u$），那么 $i$ 的右子树限制可以被满足。

为避免重复计算，我们不妨只统计：$L$ 到 $u$ 的树链上的点 $k$，满足：$k$ 的左儿子也在树链上，$k$ 的左子树限制被激活，且右子树限制未被激活。

为了更方便地统计，将点权下放至边上。若 $i$ 的左子树限制被激活且右子树未被激活，记其左儿子到它的边的权值为 $1$；若 $i$ 的右子树限制被激活且左子树未被激活，记其右儿子到它的边的权值为 $1$。统计时，仅需统计 $L$ 到 $lc_u$ 的所有左边（即连接父亲与左儿子的边）的边权和，以及 $R$ 到 $rc_u$ 的所有右边（定义类似左边）的边权和。记 $sum2(x,y)$ 表示 $x$ 到 $y$ 链上左边的权值和，$sum3(x,y)$ 表示 $x$ 到 $y$ 链上右边的权值和，差分维护即可。

此时已计入的答案为 $sum1(L,R)+sum2(L,lc_u)+sum3(R,rc_u)$，最后剩下 $L,R,u$，分别计数即可。

同样地，有效的 $\delta$ 只有至多 $2n$ 个，使用可持久化线段树维护每个版本的信息（即 $sum1(l,r),sum2(x,y),sum3(x,y)$）即可。时间复杂度为 $O((n+q)\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#include "towers.h"

using namespace std;

const int maxn = 1e5 + 5;

int n, h[maxn];

namespace seg{
int lc[maxn * 40], rc[maxn * 40], suml[maxn * 40], sumr[maxn * 40], sum[maxn * 40], tot = 0;
inline void build(int &x, int l, int r){
    x = ++ tot;
    if(l == r){
        sum[x] = 1;
        return;
    }
    int mid = l + r >> 1;
    build(lc[x], l, mid), build(rc[x], mid + 1, r);
    sum[x] = sum[lc[x]] + sum[rc[x]];
}
inline void update(int &x, int pr, int l, int r, int id, int kl, int kr, int km){
    if(id > n) return;
    if(!x || x == pr) x = ++ tot, lc[x] = lc[pr], rc[x] = rc[pr], suml[x] = suml[pr], sumr[x] = sumr[pr], sum[x] = sum[pr];
    suml[x] += kl, sumr[x] += kr, sum[x] += km;
    if(l == r) return;
    int mid = l + r >> 1;
    if(id <= mid) update(lc[x], lc[pr], l, mid, id, kl, kr, km);
    else update(rc[x], rc[pr], mid + 1, r, id, kl, kr, km);
}
inline int query(int x, int l, int r, int ql, int qr, int op){
    if(ql <= l && r <= qr){
        if(op == 0) return sum[x];
        else if(op == 1) return suml[x];
        else return sumr[x];
    }
    int mid = l + r >> 1, res = 0;
    if(ql <= mid) res += query(lc[x], l, mid, ql, qr, op);
    if(qr > mid) res += query(rc[x], mid + 1, r, ql, qr, op);
    return res;
}}

int stp[maxn], mx[maxn], tp = 0, ls[maxn], rs[maxn];
int st[maxn][25], lg[maxn];
int lc[maxn], rc[maxn], lim[maxn], rim[maxn];
inline int get(int l, int r){
    int g = lg[r - l + 1];
    if(h[st[l][g]] < h[st[r - (1 << g) + 1][g]]) return st[l][g];
    else return st[r - (1 << g) + 1][g];
}
inline void build(){
    tp = 0;
    for(int i = 1; i <= n; ++ i){
        int p = 0;
        while(tp && h[stp[tp]] > h[i]) p = stp[tp], tp --;
        rc[stp[tp]] = i, lc[i] = p;
        stp[++ tp] = i;
    }
}
int rt[maxn], vw[maxn], vnt = 0;

pair<int, int> ps[maxn << 1];

void init(int N, vector<int> H){
    n = N;
    for(int i = 1; i <= n; ++ i){
        h[i] = H[i - 1];
        st[i][0] = i;
        if(i > 1) lg[i] = lg[i >> 1] + 1;
        lim[i] = rim[i] = 1e9 + 100;
    }
    seg::build(rt[0], 1, n);
    for(int j = 1; j <= lg[n]; ++ j){
        for(int i = 1; i + (1 << j) - 1 <= n; ++ i){
            if(h[st[i][j - 1]] < h[st[i + (1 << j - 1)][j - 1]]) st[i][j] = st[i][j - 1];
            else st[i][j] = st[i + (1 << j - 1)][j - 1];
        }
    }
    build();
    tp = 0, stp[++ tp] = 0, h[0] = -1, mx[1] = 1e9 + 100;
    for(int i = 1; i <= n; ++ i){
        while(tp && h[i] < h[stp[tp]]) mx[tp - 1] = max(mx[tp - 1], mx[tp]), tp --;
        ps[i] = make_pair(max(mx[tp], h[i]) + 1 - h[i], -i), ls[i] = stp[tp], stp[++ tp] = i, mx[tp] = h[i];
    }
    tp = 0, stp[++ tp] = n + 1, h[n + 1] = -1;
    for(int i = n; i >= 1; i --){
        while(tp && h[i] < h[stp[tp]]) mx[tp - 1] = max(mx[tp - 1], mx[tp]), tp --;
        ps[i + n] = make_pair(max(mx[tp], h[i]) + 1 - h[i], i), rs[i] = stp[tp], stp[++ tp] = i, mx[tp] = h[i];
    }
    sort(ps + 1, ps + n * 2 + 1);
    for(int i = 1; i <= n << 1; ++ i){
        int x = ps[i].second, w = ps[i].first;
        if(w > 1e9) break;
        if(w != ps[i - 1].first) vw[++ vnt] = w;
        int vp = vnt ? rt[vnt - 1] : 0;
        if(x < 0){
            x = -x;
            if(rim[x] > 1e9) seg::update(rt[vnt], vp, 1, n, ls[x] + 1, 1, 0, 0), seg::update(rt[vnt], vp, 1, n, x, -1, 0, -1);
            else seg::update(rt[vnt], vp, 1, n, rs[x] - 1, 0, -1, 0), seg::update(rt[vnt], vp, 1, n, x, 0, 1, 0);
            lim[x] = vnt;
        }else{
            if(lim[x] > 1e9) seg::update(rt[vnt], vp, 1, n, rs[x] - 1, 0, 1, 0), seg::update(rt[vnt], vp, 1, n, x, 0, -1, -1);
            else seg::update(rt[vnt], vp, 1, n, ls[x] + 1, -1, 0, 0), seg::update(rt[vnt], vp, 1, n, x, 1, 0, 0);
            rim[x] = vnt;
        }
    }
    vw[++ vnt] = 1e9 + 100;
}
int max_towers(int L, int R, int D){
    L ++, R ++;
    int v = upper_bound(vw, vw + vnt + 1, D) - vw - 1;
    int lca = get(L, R), ans = seg::query(rt[v], 1, n, L, R, 0);
    if(L != lca){
        ans += seg::query(rt[v], 1, n, 1, L, 1) - seg::query(rt[v], 1, n, 1, lc[lca], 1);
        if(rim[L] > v && lim[L] <= v) ans ++;
    }
    if(R != lca){
        ans += seg::query(rt[v], 1, n, R, n, 2) - seg::query(rt[v], 1, n, rc[lca], n, 2);
        if(lim[R] > v && rim[R] <= v) ans ++;
    }
    if(lim[lca] <= v || rim[lca] <= v) ans ++;
    return ans;
}
```

---

## 作者：MurataHimeko (赞：0)

先观察到两两之间合法即相邻之间合法。

考虑最暴力的做法。

在一次询问中，对于每个 $i$ 分别求出左侧和右侧第一个 $\geq a_i + d$ 的位置，设为 $l,r$，然后相当于要求选出的位置的 $[l+1, r-1]$ 不交，线段树可以简单维护。复杂度为 $O(qn\log n)$。

考虑贪心。

设 $f_i$ 表示以 $i$ 结尾，从 $l$ 开始至多选几个位置。

对于 $i<j$，如果 $f_i=f_j$，那么保留高度更小的肯定不劣。如果 $a_i<a_j$，显然；否则在 $[i+1,j-1]$ 中不存在 $\geq a_i+d$ 的位置，那么在之后 $i$ 仍然不可能优于 $j$。

并且，如果 $i<j, a_i>a_j$，则一定有 $f_j\geq f_i$。所以可以简单模拟，做到 $O(qn)$。

不妨将 $l=0$ 且 $d$ 固定时保留下来的位置称为“关键点”，那么当 $d$ 增大时，相邻的关键点会发生合并，并保留 $a$ 较小的一个。用可持久化线段树记录这个过程。对于一个询问回答区间内有几个关键点即可。

关键点的本质其实就是在 $f$ 相同的点里，$a$ 最小的位置。

但是需要注意的是，关键点只是最优选点，并非唯一选点。所以在左右边界处都可能会少算 $1$ 的答案。

不妨只考虑左边界，右边界同理。

求出 $l$ 之前的第一个关键点 $x$，以及 $l$ 之后的第一个关键点 $y$，我们要考察的是在 $[l, y-1]$ 中是否存在能跟 $y$ 匹配的点 $z$。那么 $z$ 肯定不能跟 $x$ 匹配，不然 $z$ 也会成为关键点。

因为只判断是否存在，所以 $a_z$ 一定是 $[l,y-1]$ 的前缀最小值。同时 $a_x$ 小于所有 $a_z$。

把前缀最小值都拉出来，那么能跟 $x$ 匹配的一定是一段后缀。可以通过倍增找到最后一个不能跟 $x$ 匹配的 $z$，因为在 $z$ 之前不存在 $\geq a_z+d$ 的数，所以 $z$ 是唯一一个可能跟 $y$ 匹配的位置，简单 check 即可。

事实上这个过程跟 $x$ 没有任何关系。所以压根就不用找 $x$。

可能不存在 $y$，不过这时候只需要将左右边界处找到的两个位置 check 一下，问题不大。

综上，可以做到 $O((n+q)\log n)$。

代码：

```cpp
#include <bits/stdc++.h> 
#define rep(i, f, t) for(int i(f); i <= t; ++i)
#define re(i, t) for(int i(1); i <= t; ++i)
#define per(i, t, f) for(int i(t); i >= f; --i)
#define pe(i, t) for(int i(t); i >= 1; --i) 
#define nx(i, u) for(int i(head[u]); i; i = e[i].nxt)
typedef long long ll; 
using namespace std;
typedef pair <int, int> pii;
#define pb push_back
#define fi first
#define se second
#define ix(l, r) ((l + r) | (l != r)) 
// #define ls (ix(l, mid))
// #define rs (ix(mid + 1, r))
#define mp(i, j) (make_pair(i, j))
#define inf (int)(1e9+7)
#define INF 0x3f3f3f3f3f3f3f3f

const int N = 1e5 + 5;
int a[N], n;
int base[N], len;
set<int>s;
int st[20][N], lg[N];
int ask (int l, int r) {
	if(l > r) return -inf;
	int len = lg[r - l + 1];
	return max(st[len][l], st[len][r-(1<<len)+1]);
}

int rt[N];
int ls[N*32], rs[N*32], siz[N*32], tnt;
struct node {
	int w, x, y;
	bool operator < (const node &rhs) const {
		return w > rhs.w;
	}
};
priority_queue<node>q;

void upd (int &now, int lst, int l, int r, int p, int w) {
	now = ++tnt;
	ls[now] = ls[lst], rs[now] = rs[lst], siz[now] = siz[lst] + w;
	if(l == r) return ;
	int mid = (l + r) >> 1;
	if(p <= mid) upd(ls[now], ls[lst], l, mid, p, w);
	else upd(rs[now], rs[lst], mid + 1, r, p, w);
}

int query (int now, int l, int r, int dl, int dr) {
	if(dl <= l && r <= dr) return siz[now];
	int mid = (l + r) >> 1;
	int res =0;
	if(dl <= mid) res = query(ls[now], l, mid, dl, dr);
	if(dr > mid) res += query(rs[now], mid + 1, r, dl, dr);
	return res;
}

int query_st (int now, int l, int r, int dl, int dr) {
	if(!siz[now] || r < dl || dr < l) return 0;
	if(l == r) return l;
	int mid = (l + r) >> 1;
	int res = query_st(ls[now], l, mid, dl, dr);
	if(!res) res = query_st(rs[now], mid + 1, r, dl, dr);
	return res;
}

int query_ed (int now, int l, int r, int dl, int dr) {
	if(!siz[now] || r < dl || dr < l) return 0;
	if(l == r) return l;
	int mid = (l + r) >> 1;
	int res = query_ed(rs[now], mid + 1, r, dl, dr);
	if(!res) res = query_ed(ls[now], l, mid, dl, dr);
	return res;
}

bool vis[N];
int fa1[20][N], fa2[20][N];
int sta[N], top;

void init (int _n, vector<int>A) {
	n = _n;
	re(i, n) st[0][i] = a[i] = A[i-1];
	re(j, 17) {
		re(i, n - (1 << j) + 1) {
			st[j][i] = max(st[j-1][i], st[j-1][i+(1<<(j-1))]);
		}
	}
	top = 0;
	re(i, n) fa1[0][i] = fa2[0][i] = i;
	pe(i, n) {
		while(top && a[sta[top]] > a[i]) --top;
		fa1[1][i] = sta[top];
		sta[++top] = i;
	}
	top = 0;
	re(i ,n) {
		while(top && a[sta[top]] > a[i]) --top;
		fa2[1][i] = sta[top];
		sta[++top] = i;
	}
	rep(j, 2, 17) {
		re(i, n) {
			fa1[j][i] = fa1[j-1][fa1[j-1][i]];
			fa2[j][i] = fa2[j-1][fa2[j-1][i]];
		}
	}
	lg[0] = -1;
	re(i, n) lg[i] = lg[i>>1] + 1;
	a[0] = inf;
	base[len = 1] = 1;
	int lst = 0;
	re(i, n) {
		if(a[i] < a[i-1] && a[i] < a[i+1]) {
			s.insert(i);
			vis[i] = 1;
			upd(rt[1], rt[1], 1, n, i, 1);
			if(lst) {
				int w = ask(lst + 1, i - 1) - max(a[i], a[lst]) + 1;
				q.push((node){w, lst, i});
			}	
			lst = i;
		}
	}
	while(!q.empty()) {
		node u = q.top();
		q.pop();
		int x = u.x, y = u.y;
		if(!vis[x] || !vis[y]) continue;
		int lst = len;
		if(u.w != base[len]) base[++len] = u.w;
		if(a[x] > a[y]) swap(x, y);
		upd(rt[len], rt[lst], 1, n, y, -1);
		s.erase(y);
		vis[y] = 0;  
		auto it = s.upper_bound(x), it2 = s.lower_bound(x);
		if(it != s.end()) {
			q.push((node){ask(x, *it) - max(a[x], a[*it]) + 1, x, *it});
		} 
		if(it2 != s.begin()) {
			--it2;
			q.push((node){ask(*it2, x) - max(a[x], a[*it2]) + 1, *it2, x});
		}
	}
	base[++len] = inf;
}

int max_towers (int l, int r, int d) {
	++l, ++r;
	int pos = upper_bound(base + 1, base + len + 1, d) - base - 1;
	int ans = query(rt[pos], 1, n, l, r);
	int now = l;
	per(i, 16, 0) {
		int v = fa1[i][now];
		if(v) {
			if(ask(l, v-1) - d < a[v]) {
				now = v;
			}
		}
	}
	int al = now; 
	now = r;
	per(i, 16, 0) {
		int v = fa2[i][now];
		if(v) {
			if(ask(v+1, r) - d < a[v]) {
				now = v;
			}
		}
	}
	int ar = now; 
	if(ans) {
		int L = query_st(rt[pos], 1, n, l, r), R = query_ed(rt[pos], 1, n, l, r);
		if(ask(al+1, L-1) - d >= max(a[L], a[al])) ++ans;
		if(ask(R+1, ar-1) - d >= max(a[R], a[ar])) ++ans;
	}
	else {
		if(ask(al+1, ar-1) - d >= max(a[al], a[ar])) ans = 2;
		else ans = 1;
	}
	return ans;
}
```


---

## 作者：Purslane (赞：0)

# Solution

这道题还是挺简单的，理一下思路。

发现有一个 $17$ 分的 Sub 是所有 $D$ 都相同，思考一下这个怎么做。

对于每个位置，记 $L_i$ 为其左边第一个 $\ge a_i + d$ 的位置，$R_i$ 同理。

结论 $1$：考虑在数轴上描出所有的 $(L_i,R_i)$（作为线段）。则他们要么互相包含，要么无交。正确性是显然的。

结论 $2$：如果 $i$ 的线段包含了 $j$ 的线段，那么显然不合法。正确性也是显然的。

结论 $3$：如果 $i$ 的线段和 $j$ 的线段无交，那么 $(i,j)$ 显然合法。正确性还是显然的。

那么问题就是：有若干线段，你要求出其最大的一个子集，使得两两无交。

建出线段包含关系的树之后发现：我们选的线段一定是叶子结点，也就是极小的线段。

那么什么样的线段是极小的呢？定义位置 $i$ 小于位置 $j$，当且仅当 $(a_i,i) < (a_j,j)$（二元组双关键字排序）。

很容易知道哪些位置所在线段是极小的——一个位置所在线段是极小的，当且仅当该区间内（$L_i < j < R_i$ ）没有比 $i$ 小的位置。

所以我们可以直接用前缀和算出查询区间里有几个位置是极小的……吗？

注意到比较靠边界的位置，在原序列中是不合法的，但是边界帮他把比他小的位置剔除出去了，这个位置就变得合法了。

不过这些位置显然只有 $O(1)$ 个（$\le 2$，分别在左右两个边界取到），我们可以尝试算出来。

以左端点为例。我们想找到一个 $\ge l$ 的位置 $i$，满足，他在只保留 $p \ge L$ 的数的时候是极小的。（为什么不删掉 $p >R$ 的数？因为如果只有删了这些数 $i$ 才是极小的，很容易发现答案是 $1$，这是容易特判的）

显然 $R_i$ 不变，所以我们选的实际上是 $R_i$ 最小的数。显然在 $R_i$ 最小的若干个 $i$ 中，必有一个合法。

假设左端点算出来 $i_1$，右端点算出来 $i_2$。我们算出 $(R_{i_1},L_{i_2})$ 中有多少个位置对应的线段是极小的即可。

------

现在处理 $D$ 不唯一的情况。显然一个位置 $i$ 是合法的，会对应 $D$ 的一段前缀。（$D$ 越小，$[L_i,R_i]$ 越小，越不容易包含更小的数。）

所以我们可以用主席树处理给定 $D$ 一个区间内合法位置的个数。

而怎么找到上文的 $R_{i_1}$ 和 $L_{i_2}$ 呢？以 $R_{i_1}$ 为例，他就是最小的 $p$，满足 $\exists l \le i < j \le p$ 使得 $a_j - a_i \ge D$。

这个很容易线段树上二分维护（维护区间内 $a_j - a_i$ 的最大、小值，$a$ 的最大、小值）。

那么本题就完结撒花了。

总结一下，本题是一个挺符合 CNOI 风格的简单题。你需要在特定部分分下先分析基本的结构，然后将最优化问题直接转变为计数问题，最后发现过程可以数据结构加速。一步步推很容易做出来。

```cpp
#include<bits/stdc++.h>
#include "towers.h"
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,q,a[MAXN];
struct INFO {int amx,amn,dmx,dmn;}t[MAXN<<2];
inline INFO operator +(const INFO A,const INFO B) {return {max(A.amx,B.amx),min(A.amn,B.amn),max(max(A.dmx,B.dmx),B.amx-A.amn),min(min(A.dmn,B.dmn),B.amn-A.amx)};}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void build(int k,int l,int r) {
	if(l==r) return t[k]={a[l],a[l],0,0},void();
	build(lson,l,mid),build(rson,mid+1,r);
	return t[k]=t[lson]+t[rson],void();	
}

INFO qlst[MAXN<<2];
int X[MAXN<<2],Y[MAXN<<2];
inline INFO query(const int k,const int l,const int r,const int x,const int y) {
	if(x<=l&&r<=y) return t[k];
	if(x==X[k]&&y==Y[k]) return qlst[k];
	X[k]=x,Y[k]=y;
	if(y<=mid) return qlst[k]=query(lson,l,mid,x,y);
	if(x>mid) return qlst[k]=query(rson,mid+1,r,x,y);
	return qlst[k]=query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);	
}
int L[MAXN],R[MAXN],D[MAXN],lsh[MAXN],tot;
vector<int> upd[MAXN];
namespace SGT {
	//可持久化
	struct Node {int ls,rs,sum;}t[MAXN*50];
	int rt[MAXN],tot;
	inline int copy(const int u) {return t[++tot]=t[u],tot;}
	inline void update(int &u,const int l,const int r,const int pos,const int v) {
		u=copy(u),t[u].sum++;
		if(l==r) return ;
		if(pos<=mid) update(t[u].ls,l,mid,pos,v);
		else update(t[u].rs,mid+1,r,pos,v);
		return ;
	}
	inline int query(const int u,const int l,const int r,const int x,const int y) {
		if(x>y) return 0;
		if(x<=l&&r<=y) return t[u].sum;
		if(y<=mid) return query(t[u].ls,l,mid,x,y);
		if(x>mid) return query(t[u].rs,mid+1,r,x,y);
		return query(t[u].ls,l,mid,x,y)+query(t[u].rs,mid+1,r,x,y);	
	}
};
void init(int N,vector<int> H) {
	memset(X,-1,sizeof(X)),memset(Y,-1,sizeof(Y));
	n=N;
	ffor(i,1,n) a[i]=H[i-1];
	a[0]=a[n+1]=2e9;
	build(1,0,n+1);
	stack<int> st;
	ffor(i,1,n) {
		while(!st.empty()&&a[i]<a[st.top()]) st.pop();
		if(!st.empty()) L[i]=st.top();
		st.push(i);
	}
	while(!st.empty()) st.pop();
	roff(i,n,1) {
		while(!st.empty()&&a[i]<=a[st.top()]) st.pop();
		if(!st.empty()) R[i]=st.top();
		else R[i]=n+1;
		st.push(i);	
	}
	ffor(i,1,n) {
		int dmx=INT_MAX;
		dmx=min(dmx,query(1,0,n+1,L[i],i).amx-a[i]);
		dmx=min(dmx,query(1,0,n+1,i,R[i]).amx-a[i]);
		D[i]=dmx,lsh[++tot]=D[i];
	}
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	ffor(i,1,n) D[i]=lower_bound(lsh+1,lsh+tot+1,D[i])-lsh,upd[D[i]].push_back(i);
	roff(i,tot,1) {
		SGT::rt[i]=SGT::rt[i+1];
		for(auto id:upd[i]) SGT::update(SGT::rt[i],1,n,id,1);	
	}
	return ;
}
INFO tmp[MAXN<<2];
inline int bfind1(const int k,const int l,const int r,const int lim,INFO os,const int d) {
	if(r<lim) return -1;
	tmp[k]=query(k,l,r,max(l,lim),r);
	if((os+tmp[k]).dmx<d) return -1;
	if(l==r) return l;
	int tans=bfind1(lson,l,mid,lim,os,d);
	if(tans!=-1) return tans;
	if(max(l,lim)<=mid) os=os+tmp[lson];
	return bfind1(rson,mid+1,r,lim,os,d);
}
inline int bfind2(const int k,const int l,const int r,const int lim,INFO os,const int d) {
	if(l>lim) return -1;
	tmp[k]=query(k,l,r,l,min(r,lim));
	if((tmp[k]+os).dmn>-d) return -1;
	if(l==r) return l;
	int tans=bfind2(rson,mid+1,r,lim,os,d);
	if(tans!=-1) return tans;
	if(mid+1<=min(r,lim)) os=tmp[rson]+os;
	return bfind2(lson,l,mid,lim,os,d);
}
int max_towers(int l,int r,int d) {
	l++,r++;
	auto info=query(1,0,n+1,l,r);
	if(info.dmx<d||info.dmn>-d) return 1;
	int p1=bfind1(1,0,n+1,l,{-0x3f3f3f3f,0x3f3f3f3f,-0x3f3f3f3f,0x3f3f3f3f},d),p2=bfind2(1,0,n+1,r,{-0x3f3f3f3f,0x3f3f3f3f,-0x3f3f3f3f,0x3f3f3f3f},d);
	d=lower_bound(lsh+1,lsh+tot+1,d)-lsh;
	if(p1>p2) return 1;
	return 2+SGT::query(SGT::rt[d],1,n,p1,p2);
}
```

---


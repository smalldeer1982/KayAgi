# [IOI 2021] 钥匙

## 题目背景

# 滥用本题评测将被封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

## 题目描述

建筑师 Timothy 设计了一个新的密室逃脱游戏。

这个游戏里有 $n$ 个房间，房间从 $0$ 到 $n - 1$ 编号。最开始的时候，每个房间里都恰好有一把钥匙。每把钥匙都有一个类型，钥匙的类型是一个 $0$ 到 $n - 1$ 区间内的整数。第 $i$ 个房间里的钥匙类型是 $r[i]$。注意多个房间里可能会包含相同类型的钥匙，即$r[i]$ 的值不一定是两两不同的。 

游戏里还有 $m$ 条**双向**的通道，通道从 $0$ 到 $m - 1$ 编号。第 $j$ 条通道连接了一对编号不同的房间 $u[j]$ 和 $v[j]$。同一对房间之间可能存在多条通道。

参与游戏的玩家需要收集钥匙和在不同的房间之间通过通道进行移动。 当玩家使用通道 $j$ 从房间 $u[j]$ 移动到 $v[j]$ ，或者反过来从 $v[j]$ 移动到 $u[j]$ 时，我们说玩家**通过**了通道 $j$。 只有当玩家收集到类型为 $c[j]$ 的钥匙时，玩家才可以通过通道 $j$。 

在游戏的任意时刻，玩家可以在某个房间 $x$ 里执行以下两种操作： 

- 收集房间 $x$ 里面的钥匙，钥匙的类型是 $r[x]$（除⾮对应类型的钥匙已经被收集过）。
- 通过通道 $j$，需要满足 $u[j] = x$ 或 $v[j] = x$，且玩家已经获得 $c[j]$ 类型的钥匙。 

注意玩家收集过的钥匙可以一直使用，**永远不会被丢弃**。 

最初玩家会在某个房间 $s$ **开始**游戏，不带任何钥匙。 如果玩家从房间 $s$ 开始，通过一系列上述描述的两种操作，能够到达房间 $t$，那么称房间 $t$ 是**从房间 $s$ 开始可以到达的**。 

对于每一个房间 $i ~ ( 0 \le i \le n − 1)$，定义从房间 $i$ 出发能够到达的房间数为 $p[i]$。Timothy 想要知道满⾜ $p[i]$ 值最小的下标 $i$ 的集合。

## 说明/提示

**样例解释**

对于例 $1$，考虑以下调用：

```cpp
find_reachable([0, 1, 1, 2],
[0, 0, 1, 1, 3], [1, 2, 2, 3, 1], [0, 0, 1, 0, 2])
```

如果玩家从房间 $0$ 开始游戏，可以执⾏以下的操作序列：

| 当前房间 | 操作 |
| :----------: | :----------: |
| $0$ | 收集钥匙类型 $0$ |
| $0$ | 通过通道 $0$ 到房间 $1$ |
| $1$ | 收集钥匙类型 $1$ |
| $1$ | 通过通道 $2$ 到房间 $2$ |
| $2$ | 通过通道 $2$ 到房间 $1$ |
| $1$ | 通过通道 $3$ 到房间 $3$ |

因此从房间 $0$ 出发可以到达房间 $3$。 类似地，我们可以构造出操作序列表明所有 $4$ 个房间都是从房间 $0$ 出发可达的，所以 $p[0] = 4$。 下表展⽰了从各个房间出发可以到达的房间集合：

| 开始房间 $i$ | 可以到达的房间 | $p[i]$ |
| :----------: | :------------: | :----: |
|     $0$      | $[0, 1, 2, 3]$ |  $4$   |
|     $1$      |    $[1, 2]$    |  $2$   |
|     $2$      |    $[1, 2]$    |  $2$   |
|     $3$      |  $[1, 2, 3]$   |  $3$   |

所有房间中 $p[i]$ 的最小值是 $2$，这可以在 $i = 1$ 或 $i = 2$ 处取得。所以这次函数调⽤的返回值是 $[0, 1, 1, 0]$。

对于例 $2$：所有房间中 $p[i]$ 的最小值是 $2$，这可以在 $i \in \{1, 2, 4, 6\}$ 处取得。所以这次函数调⽤的返回值是
$[0, 1, 1, 0, 1, 0, 1]$。

对于例 $3$：所有房间中 $p[i]$ 的最小值是 $1$，这可以在 $i = 2$ 处取得。所以这次函数调⽤的返回值是 $[0, 0, 1]$。

**约束条件**

- $2 \leq n \leq 3 \times 10 ^ 5$
- $1 \leq m \leq 3 \times 10 ^ 5$
- $0 \leq r[i] \leq n - 1$ （对于所有的 $0 \leq i \leq n - 1$）
- $0 \leq u[j], v[j] \leq n - 1$ 且 $u[j] \neq v[j]$ （对于所有的 $0 \leq j \leq m - 1$）
- $0 \leq c[j] \leq n - 1$（对于所有的 $0 \leq j \leq m - 1$）

**子任务**

1. （$9$ 分） $c[j] = 0$（对于所有的 $0 \leq j \leq m − 1$）且 $n, m \leq 200$  
2. （$11$ 分） $n, m \leq 20$
3. （$17$ 分） $n, m \leq 2000$ 
4. （$30$ 分） $c[j] \leq 29$（对于所有的 $0 \leq j \leq m − 1$）且 $r[i] \leq 29$（对于所有的 $0 \leq i \leq n − 1$） 
5. （$33$ 分）没有额外的约束条件。

**样例评分程序**

评测程序⽰例以如下格式读取输⼊数据：

- 第 $1$ ⾏：$n ~ m$
- 第 $2$ ⾏： $r[0] ~ r[1] ~ \cdots ~ r[n − 1]$
- 第 $3 + j$ ⾏ $( 0 \leq j \leq m − 1)$： $u[j] ~ v[j] ~ c[j]$

样例评分程序按照以下格式打印 `find_reachable` 函数的返回值：

第 $1$ ⾏： $s[0] ~ s[1] \cdots ~ s[n − 1]$

## 样例 #1

### 输入

```
4 5
0 1 1 2
0 1 0
0 2 0
1 2 1
1 3 0
3 1 2
```

### 输出

```
0 1 1 0
```

## 样例 #2

### 输入

```
7 10
0 1 1 2 2 1 2
0 1 0
0 2 0
1 2 1
1 3 0
2 3 0
3 4 1
3 5 2
4 5 0
4 6 2
5 6 1
```

### 输出

```
0 1 1 0 1 0 1
```

## 样例 #3

### 输入

```
3 1
0 0 0
0 1 0
```

### 输出

```
0 0 1
```

# 题解

## 作者：myyes (赞：17)

摘自我的博客文章：[钥匙题专项训练](https://www.luogu.com.cn/blog/666666new/keys-tm)。

### 闲话

这个 IOI 的题啊出的是相当的不规范，弄个这个交互题的格式，麻烦得很。建议这个 IOI 比赛的出题人整成从文件里面读数据！哪有这样子交题连个 `main` 函数都没得的咩？现在外国的这些小伙子些净整些洋歪歪的，简直把我整腾了！

### 题意

一个经典的钥匙-锁模型。有一个 $n$ 个点 $m$ 条双向边的迷宫。每条边上有某种颜色的锁，每个点上有某种颜色的钥匙。一种颜色的钥匙开一种颜色的锁。如果一个师傅从点 $i$ 开始在迷宫里头转圈圈，进到一个房子就把钥匙串起撇到皮带上面，皮带上要有对应颜色的钥匙才能开锁走过一条边，设师傅以 $i$ 为起点开始能转到的点数是 $p_i$，要求出 $p_i$ 最小的那些 $i$ 的集合。

### 题解

我们可以发现，因为是要找 $p_i$ 最少的那些，所以如果 $x$ 能转到 $y$，$y$ 可以转到的点 $x$ 肯定也可以先转到 $y$ 再转到，那么 $p_y$ 肯定不得超过 $p_x$ 三，如果反过来 $y$ 转不到 $x$ 那 $x$ 肯定没用了，此时 $p_x$ 肯定严格比 $p_y$ 大。那把这个每个点能到的拿个并查集缩一下。对每个并查集里面的集合，我们从这个根节点，也就是被所有点能到达的这个点开始 BFS 坐板凳，找到能到达的另一个集合合并起来。这个过程是啥子复杂度的捏？其实跟 Boruvka 算法的思想是差不多的。因为我们每次会找到一个集合跟他合并，那集合的数量每次砍半，因此这个过程只需要进行 $\mathcal O(\log n)$ 轮。每轮我们坐板凳的复杂度是 $\mathcal O(n)$ 的，因此总复杂度就是一个 $\mathcal O(n\log n)$ 了得咩。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
vector<pair<int,int>>e[300010];
vector<int>res,ans,col[300010],pw,t;
int n,m,R[300010],vis[300010],in[300010],q[300010],mn=1e9,fin[300010],f[300010];
int find(int x)
{return x==f[x]?x:f[x]=find(f[x]);
}
void bfs(int s){
 bool flag=1;
  queue<int>q;
q.push(s);
t.push_back(s);
 while(!q.empty())
  {
  int x=q.front();
   q.pop();
   if(find(x)!=s){
 flag=0;
  f[s]=find(x);
 vis[find(x)]=1;
  break;}
    if(vis[x])continue;
 vis[x]=1;
  ans.push_back(x);
  if(!in[R[x]])
{
 in[R[x]]=1;
  for(int i:col[R[x]])
  q.push(i),t.push_back(i);}
 for(pair<int,int>i:e[x])
  {
   int v=i.first,w=i.second;
 if(in[w])
  q.push(v),t.push_back(v);else
   col[w].push_back(v),pw.push_back(w);
   }
    }
 if(flag)
   {fin[s]=1;
 if(ans.size()<mn)
  {
  mn=ans.size();
    res=ans;}
else if(ans.size()==mn)for(int i:ans)res.push_back(i);
}for(int i:pw)
 col[i].clear();
   for(int i:t){
  in[R[i]]=0;}
 pw.clear();
 t.clear();
  ans.clear();}
  vector<int>find_reachable(vector<int>r,vector<int>u,vector<int>v,vector<int>c)
{n=r.size(),m=u.size();
 for(int i=1;i<=n;++i)
   R[i]=r[i-1]+1,f[i]=i;
for(int i=0,x,y,w;i<m;++i)
 {x=u[i]+1,y=v[i]+1,w=c[i]+1;
 e[x].push_back(mp(y,w));
  e[y].push_back(mp(x,w));
}
  while(1)
   {
 bool flag=1;for(int i=1;i<=n;++i)vis[i]=0;
  for(int i=1;i<=n;++i)
 if(find(i)==i&&!fin[i]&&!vis[i])
  bfs(i),flag=0;
if(flag)break;}
 vector<int>mea(n);
for(int i:res)  mea[i-1]=1;
  return mea;
   }
```

---

## 作者：ღꦿ࿐ (赞：14)

很奇怪的题，好像见过类似的套路但完全想不到。和同学讨论了好久……

---

考虑直接求出每个点能到达的形状显然是不太能低于 $O(nm)$ 的，这个询问的信息一定有所隐含。


将原图的互相到达关系形容为一个有向图，那么可以到达点数最少的集合一定是将这个有向图强连通分量缩点后，某些出度为 $0$ 的强连通分量中的点。

称这个有向图中的强连通的子图为强连通集合，即某个集合使得里面的点可以两两通过拿某些钥匙互相到达的一个集合。

统计**能够到达点数最少的位置集合**，考虑能够到达点数最少的位置，如果某个强连通的集合 $S$ 可以到达强连通的集合 $T$，那么我们没有必要统计 $S$，只用统计 $T$ 所在的强连通集合，如下：

- 如果 $T$ 不能够到达 $S$，那么 $T$ 能够到达的点的个数严格小于 $S$，不用考虑 $T$。
- 如果 $T$ 能够到达 $S$，那么 $T$ 和 $S$ 在同一个强连通集合中。

所以我们考虑维护可能成为答案的强连通集合，然后对这些集合进行扩展，如果一个集合 $S$ 能够到达另一个集合 $T$，那么我们便将这个 $S$ 设为“可以到达 $T$”的集合，然后不再统计它，到达关系可以用并查集完成传递。

每次选择一个**目前不能到达其它集合**的集合，判断它是否到达一个**不连向自己的集合**，如果能到达 $T$，将它设为能到达 $T$的集合。如果不能到达，那么所在集合就被封闭住了，不能再往外走，我们统计这个集合的大小即可（它是强连通的，因为所统计的其它集合都属于能连向自己的集合）。过程 BFS 一遍，到达第一个不在同一个集合里的点停下来，复杂度就是正确的。

其实抽象一点我们干的事情的本质是这样的：


- 同样将到达关系建出一个有向图，我们要求出所有缩点后出度为 $0$ 的强连通分量。

- 维护一个有向森林，边从叶子指向根，用这个有向森林来维护不完全的可达关系，因为我们只关心根，不关心其它点。

- 每次拓展拿森林的根试图向外拓展：寻找一个能够连接到的，和自己不在同一棵树里的点。

- 如果拓展成功，那么连接这个点和它能够到达的另一个森林，我们不在乎这些点和连向的森林的其它点的连通性，只在乎这些点都可以到达连向的森林的根。

- 如果根拓展失败，那么根一定对应着一个没有出度的强连通分量：它能到达，的点全部能够到达它，找出这个强连通分量。

- 使用类似 Boruvka 的每层拓展一次的方法（被拓展到的集合的大小改变了，为保证复杂度我们在本轮不再拓展），需要拓展的点数每次拓展后至少减半：要么不再需要拓展，要么被一个拓展的点连接到，要么拓展成功，后两种会使得这个森林增加至少点数一半的边数，所以复杂度是 $O((n+m)\log n)$ 的。

- 这样做一定是正确的，因为最后任何一个没有出度的强连通分量一定存在一个代表的根，我们一定会在统计这个根对应的强连通分量处统计到，如果存在多余一个根对应着这个强连通分量，那么就代表森林的根之间还可以相互到达，还需要拓展。


简单，可读的代码：


```cpp
#define rep(i,x,y) for(int i=x;i<y;++i)
using pi = pair<int,int> ;
using vi = vector<int> ;
int n , m , mp = 1e9; 
bool flg ;
vector < pi > ed[N] ; 
vi fa , r , u , v , c , wait[N] , ans , res , vis , closed; 
vector < bool > key; 
int find(int x) {
    while(x != fa[x]) x = fa[x] = fa[fa[x]] ;
    return x; 
}
void bfs (int s) {
    res.clear( ) ; 
    vi vis_key , vis_edg ; queue<int> q; 
    q.emplace(s) ;
    bool flag = 1;
    while(q.size( )) {
        auto u = q.front( ) ; q.pop( ) ;
        if(find(u) != s) {
            fa[s] = find(u) ;
            vis[find(u)] = 1;
            flag = 0 ;
            break;
        }
        if(vis[u]) continue;    vis[u] = 1; 
        res.emplace_back(u) ;
        for(int v:wait[r[u]]) q.emplace(v) ; wait[r[u]].clear( ) ;
        key[r[u]] = 1 , vis_key.emplace_back(r[u]) ;
        for(auto[v,w]:ed[u]) {
            if(key[w]) q.emplace(v) ; 
            else {
               if(wait[w].empty( )) vis_edg.emplace_back(w);
                wait[w].emplace_back(v);
            }
        }
    }   
    for(int k:vis_key) key[k] = 0 ;
    for(int w:vis_edg) wait[w].clear( ) ;
    if(flag) {
        if((int) res.size( ) == mp) for(int e:res) ans.emplace_back(e) ;
        if((int) res.size( ) < mp) ans = res , mp = res.size( ) ;
        closed[find(s)] = 1; 
        for(int p:res) vis[p] = 0 ;
    }
}
vi find_reachable(vi _r, vi _u,vi _v, vi _c) {
    r = _r , u = _u , v = _v , c = _c ;
    n = r.size( ) , m = u.size( ) ;
    vi ret(n , 0) ;
    fa.resize(n);iota(All(fa) , 0) ;
    closed.resize(n , 0) ; 
    key.resize(n) ;
    rep(i,0,m) {
        ed[u[i]].emplace_back(v[i] , c[i]) ;
        ed[v[i]].emplace_back(u[i] , c[i]) ;
    }
    while(1) {
        bool expand = 0 ;   
        vis.clear( ) , vis.resize(n , 0) ;
        rep(i,0,n) {
            if(!vis[i] && find(i) == i && !closed[i]) bfs(i) , expand = 1; 
        }
        if(!expand) break; 
    }
    for(int v:ans) ret[v] = 1 ;
    return ret ;
}

```

---

## 作者：Rainbow_qwq (赞：11)

在做过 [JOI Open 2019 的某题](https://loj.ac/p/3155) 后感觉这题能套同样的做法。

对于每个点我们是可以 $O(n+m)$ bfs 求出答案的。

考虑直接套病毒实验的做法。一开始把每个点染不同的颜色，下面把同颜色的点称作一个连通块。

并查集维护若干连通块，连通块只保留一个所有点能到它的点（代码中的并查集的根），也就是连通块中能到达的点数量最少的点。（其他的点不用管，因为只要求达到点数最小的）

然后每次从保留的点开始 bfs 找。

bfs 到不同连通块的就合并两个连通块并返回，当前连通块的那个点可以直接废了，保留那个不同连通块的点就行了。

不能到不同连通块就说明这个点能到的位置已经确定，以后可以不再 bfs 这个连通块，并更新答案即可。

每轮会连通块数量至少除以 $2$，这样只会经过 $\log$ 轮 bfs，复杂度为 1log。

然后就做完了，十分好写（

可以配合[代码](https://uoj.ac/submission/515792)理解。

---

## 作者：Felix72 (赞：4)

# 简介

这篇题解没用 bfs，而是回归了有向图 dfs 的本质，用魔改 tarjan 解决。（然而代价是码量很大）

# 分析

这个题问的比较奇怪，只需要知道可达性最弱的点集。稍加分析后发现，如果把原问题转化成有向图，那么出度为零的强连通分量才有可能成为答案，而答案就是大小最小的几个强连通分量。

因为钥匙模型的加入，一条边可能暂时不可通过，而拿到钥匙后可以通过。这个特点使得传统的图论算法无法很好的解决。我们想想，是什么能边搜索，边合并信息，同时是针对强连通分量的呢？没错，是 tarjan。

# 思路

对每个点开一个结构体，里面用 set 存三样东西：钥匙，用手头的钥匙就能走的边，暂时走不了但是以后也许能走的边。再对每个点建立并查集，方便之后缩点。

接着对每个点开始 tarjan。这就要分几步走：

## 预处理

和普通 tarjan 一样，设置好 $dfn_i$ 和 $low_i$，把节点入栈，打上访问标记。

## 遍历相连的边

由于是用的 set 并且后面涉及到合并，我们遍历一条边就直接删掉它，保证复杂度。同时因为要合并，不能一直用当前节点，应该用当前节点在并查集中的根节点，代表这个大连通块。

对于找到的一个相邻点，有几种情况：

### 已经被访问，是返祖边

如正常 tarjan 一样更新 $low_i$ 即可。

### 已经被访问，是横叉边

那么当前这个连通块必定不是最终答案了，打标记记录一下。

### 未被访问

先更新 $low_i$ 的值。

有操作的部分来了：如果此时 $dfn_i$ 和 $low_i$ 相等（此时 $i$ 是所处节点（连通块）），且栈顶不是 $i$ 所处连通块，证明自己还没有找到返祖边，但是儿子找到自己这里来了，这就需要合并了。

合并分这几步：

#### 清除当前节点访问标记

因为一会后当前节点和别人一合并，并查集里根节点都不见得是自己了，所以先删去，一会给新的根打标记。

#### 把栈中节点的访问标记清除

如同普通 tarjan。

#### 观察大小

暴力合并肯定行不通，我们看看哪个连通块的边数、钥匙数之和比较小，做到启发式合并。

#### 合并可走的边

直接清空一个 set，合并到另一个 set 里。

#### 合并钥匙

可能出现一把钥匙被合并过去，开了那边的某些边上的锁的情况，set 上二分查找一下（钥匙类型作为关键字）有没有这种边，有的话给它换到可走集合。

#### 合并暂时不可走的边

可能出现一条边被合并过去，正好被那边的钥匙开了的情况。处理方法类似上面。

#### 更新并查集的根

全部合并完之后，再把当前并查集的根（代表当前连通块）的访问标记打上。

## 收尾

如果此时 $dfn_i$ 仍然和 $low_i$ 相等，那么它还在栈里面，记得把它弹出并清除标记。

对于可能成为答案的强连通块，我们统计它的大小。

---

tarjan 结束之后，所有的点取所在连通块大小最小的那些即可。

# 代码

跟上面思路顺序一致。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>
#define lowbit(x) (x & (-x))
using namespace std;

const int N = 300010;

int n, m;
vector < int > ans;
struct edge
{
	int col, to;
	bool operator < (const edge &w) const
	{if(col == w.col) return to < w.to; return col < w.col;}
	bool operator > (const edge &w) const
	{if(col == w.col) return to > w.to; return col > w.col;}
};
struct Vertex
{
	int siz;
	set < int > hve;
	set < edge > con, go;
	inline void get_key(int x)
	{
		if(hve.find(x) == hve.end())
		{
			hve.insert(x);
			++siz;
		}
	}
	inline void get_edge(edge x)
	{
		if(con.find(x) == con.end())
		{
			con.insert(x);
			++siz;
		}
	}
	inline void get_go(edge x)
	{
		if(go.find(x) == go.end())
		{
			go.insert(x);
			++siz;
		}
	}
}; Vertex s[N];
struct DSU
{
	int prt[N], sz[N];
	inline int find(int x)
	{
		if(prt[x] == x) return x;
		prt[x] = find(prt[x]);
		return prt[x];
	}
}; DSU dsu;
int dfn[N], low[N], sign, sta[N], top; bool vis[N], ban[N];
int minn = 1e9, fin[N];
inline void tarjan(int now)
{
	dfn[now] = low[now] = ++sign;
	sta[++top] = now; vis[now] = true;
	while(s[dsu.find(now)].go.size())
	{
		edge tr = (*s[dsu.find(now)].go.begin());
		s[dsu.find(now)].go.erase(s[dsu.find(now)].go.begin());
		int to = dsu.find(tr.to);
		if(dfn[to])
		{
			if(vis[to]) low[dsu.find(now)] = min(low[dsu.find(now)], dfn[to]);
			else
			{
				ban[dsu.find(now)] = true;
			}
		}
		else
		{
			tarjan(to);
			if(dfn[dsu.find(to)] == low[dsu.find(to)]) ban[dsu.find(now)] = true;
			low[dsu.find(now)] = min(low[dsu.find(now)], low[dsu.find(to)]);
			if(dfn[dsu.find(now)] == low[dsu.find(now)])
			{
				vis[now] = false;
				while(dsu.find(sta[top]) != dsu.find(now))
				{
					int x = dsu.find(sta[top]), y = dsu.find(now);
					--top;
					if(x == y) continue;
					vis[x] = false;
					if(s[x].siz > s[y].siz) swap(x, y);
					ban[y] |= ban[x];
					dfn[y] = min(dfn[y], dfn[x]);
					low[y] = min(low[y], low[x]);
					dsu.prt[x] = y, dsu.sz[y] += dsu.sz[x]; dsu.sz[x] = 0;
					while(s[x].go.size())
					{
						edge cur = (*s[x].go.begin());
						s[x].go.erase(s[x].go.begin());
						s[y].get_go(cur);
					}
					while(s[x].hve.size())
					{
						int cur = (*s[x].hve.begin());
						s[x].hve.erase(s[x].hve.begin());
						s[y].get_key(cur);
						while(s[y].con.size())
						{
							auto p = s[y].con.lower_bound({cur, 0});
							if(p == s[y].con.end()) break;
							edge rec = (*p);
							if(rec.col == cur)
							{
								s[y].go.insert(rec);
								s[y].con.erase(p);
							}
							else break;
						}
					}
					while(s[x].con.size())
					{
						edge cur = (*s[x].con.begin());
						s[x].con.erase(s[x].con.begin());
						bool flag = false;
						if(s[y].hve.size())
						{
							auto p = s[y].hve.lower_bound(cur.col);
							if(p != s[y].hve.end() && (*p) == cur.col)
								flag = true;
						}
						if(flag) s[y].get_go(cur);
						else s[y].get_edge(cur);
					}
				}
				vis[dsu.find(now)] = true;
				sta[top] = dsu.find(now);
			}
		}
	}
	if(dfn[dsu.find(now)] == low[dsu.find(now)]) --top, vis[dsu.find(now)] = false;
	if(ban[dsu.find(now)]) fin[dsu.find(now)] = 1e9;
	else fin[dsu.find(now)] = dsu.sz[dsu.find(now)];
}

vector < int > find_reachable(vector < int > r, vector < int > u, vector < int > v, vector < int > c)
{
	n = r.size(); m = u.size();
	for(int i = 1; i <= n; ++i)
	{
		++r[i - 1];
		dsu.prt[i] = i; dsu.sz[i] = 1;
		s[i].get_key(r[i - 1]);
	}
	for(int i = 1; i <= m; ++i)
	{
		++u[i - 1]; ++v[i - 1]; ++c[i - 1];
		if(c[i - 1] == r[u[i - 1] - 1])
			s[u[i - 1]].get_go({c[i - 1], v[i - 1]});
		else s[u[i - 1]].get_edge({c[i - 1], v[i - 1]});
		if(c[i - 1] == r[v[i - 1] - 1])
			s[v[i - 1]].get_go({c[i - 1], u[i - 1]});
		else s[v[i - 1]].get_edge({c[i - 1], u[i - 1]});
	}
	for(int i = 1; i <= n; ++i)
		if(!dfn[i])
			tarjan(i);
	for(int i = 1; i <= n; ++i)
		minn = min(minn, fin[dsu.find(i)]);
	for(int i = 1; i <= n; ++i)
	{
		if(fin[dsu.find(i)] == minn) ans.push_back(1);
		else ans.push_back(0);
	}
	return ans;
}
/*

*/
```

---

## 作者：Mirasycle (赞：1)

直接对于每个点做是 $O(n(n+m))$ 的。但是本题不要求我们求出所有可达性，只要求我们求出可达点最少的出发点，所以我们考虑一些合并的操作。具体来说，如果存在 $u\to v$，那么其实 $u$ 就没有用了（$u$ 肯定不优于 $v$），我们就可以将 $u,v$ 合并。进行若干这种操作之后会形成若干联通块，考虑在合并上述 $(u,v)$ 的时候，在并查集内部用 $fa_i\gets v$，这样子对于联通块的根节点，我们必然保存的是这个联通块内可达点最少的点。

每次只从联通块内的这个根节点向外扩展，然后合并联通块（如果一个联通块找不到其他联通块了，我们就在以后不对于它进行操作了），可以做到类似于 Boruvka 的时间复杂度。最终对于每个联通块都有一个可能成为答案的点，这个点在这个联通块之内的肯定是最优的，已知联通块的根节点 $c$，对于联通块内的任意一个点 $u$，必然可以从 $u$ 到达 $c$，如果 $u$ 也可以到达 $c$，那么说明 $u$ 和 $c$ 等价，这个时候 $u$ 和 $c$ 都是这个联通块的最优点。在全局取最优的一些点即可。

时间复杂度 $O((n+m)\log n)$。


```cpp
#include<bits/stdc++.h>
#include "keys.h"
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=3e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int n,m,num,a[maxn],b[maxn],vis[maxn],vis2[maxn]; queue<int> q;
vector<pair<int,int> > G[maxn];
vi ans,A,vec,cur,col[maxn];
struct DSU{
	int fa[maxn];
	void init(){ for(int i=1;i<=n;i++) fa[i]=i; }
	int find(int u){ return fa[u]==u?u:fa[u]=find(fa[u]); }
	void merge(int u,int v){ fa[u]=find(v); vis[find(v)]=1; }
}dsu;
void init(){
	while(q.size()) q.pop();
	for(auto z:vec) col[z].clear(),b[z]=0;
	cur.clear(); vec.clear();
}
void modify(){
	if(cur.size()<num) ans=cur,num=cur.size();
	else if(cur.size()==num) for(auto u:cur) ans.pb(u);
}
void bfs(int s){
	q.push(s); 
	while(q.size()){
		int u=q.front(); q.pop();
		if(dsu.find(u)!=s){ dsu.merge(s,u); return ; }
		if(vis[u]) continue; 
		vis[u]=1; cur.pb(u);
		if(!b[a[u]]){
			b[a[u]]=1; vec.pb(a[u]);
			for(auto v:col[a[u]]) q.push(v);
		}
		for(auto z:G[u]){
			int v=z.fi,w=z.se;
			if(b[w]) q.push(v);
			else col[w].pb(v),vec.pb(w);
		}
	}
	vis2[s]=1; modify();
}
vi find_reachable(vi R,vi U,vi V,vi C){
	n=R.size(); m=U.size(); dsu.init(); num=n+1;
	for(int i=1;i<=n;i++) a[i]=R[i-1]+1;
	for(int i=1;i<=m;i++){
		int u=U[i-1]+1,v=V[i-1]+1,w=C[i-1]+1;
		G[u].pb(v,w); G[v].pb(u,w);
	}
	while(1){
		bool flag=0; memset(vis,0,sizeof(vis));
		for(int i=1;i<=n;i++){
			if(dsu.find(i)!=i||vis[i]||vis2[i]) continue;
			init(); bfs(i); flag=1;
		}
		if(!flag) break;
	}
	A.clear(); A.resize(n,0); 
	for(auto u:ans) A[u-1]=1;
	return A;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P8519)

**题目大意**

> 给定 $n$ 个点 $m$ 条边的无向图，点和边都有颜色，一条边可以经过当且仅当已经访问过某个和该边同色的点，求从哪些点出发能到达的点数最少。
>
> 数据范围：$n,m\le 3\times 10^5$。

**思路分析**

如果 $u$ 出发能到 $v$ 就连边 $u\to v$，注意到 $u\to v,v\to w$ 都存在则 $u\to w$ 显然存在。

因此我们相当于求有向图上哪些点后继数量最少，缩点后只要考虑所有出度 $=0$ 的强连通分量。

因此如果有边 $u\to v$，则 $u$ 的答案大于等于 $v$ 的答案。

进一步可以考虑任取一个极大的内向树生成森林，答案只可能是所有根节点所在的强连通分量，并且只要求出每个根节点的后继即可。

那么类似 Boruvka，每次给每个连通块的根找一条出边，此时每条边至多访问一次，且连通块数量减半。

时间复杂度 $\mathcal O(m\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h> 
#include "keys.h"
using namespace std;
const int MAXN=3e5+5;
struct Edge { int v,w; };
vector <Edge> G[MAXN];
int st[MAXN],dsu[MAXN];
bool vis[MAXN],inq[MAXN];
vector <int> id[MAXN];
int find(int x) { return dsu[x]^x?dsu[x]=find(dsu[x]):x; }
vector<int> find_reachable(vector<int>a,vector<int>U,vector<int>V,vector<int>c) {
    int n=a.size(); iota(dsu,dsu+n,0);
    for(int i=0;i<(int)c.size();++i) G[U[i]].push_back({V[i],c[i]}),G[V[i]].push_back({U[i],c[i]});
    int ans=n+1; vector <int> res,z(n);
    while(true) {
        vector <array<int,2>> E;
        for(int o=0;o<n;++o) if(dsu[o]==o) {
            int tp=0; st[++tp]=o,inq[a[o]]=true,vis[o]=true;
            for(int i=1;i<=tp;++i) {
                int x=st[i];
                function<bool(int)> add=[&](int v) {
                    if(dsu[v]!=dsu[o]) return E.push_back({dsu[o],dsu[v]}),true;
                    if(!vis[v]) {
                        st[++tp]=v,vis[v]=true;
                        if(!inq[a[v]]) {
                            inq[a[v]]=true;
                            for(int u:id[a[v]]) if(add(u)) return true;
                            id[a[v]].clear();
                        }
                    }
                    return false;
                };
                for(auto e:G[x]) {
                    if(inq[e.w]) {
                        if(add(e.v)) goto fi;
                    } else id[e.w].push_back(e.v);
                }
            }
            if(tp<ans) ans=tp,res.clear();
            if(ans==tp) for(int i=1;i<=tp;++i) res.push_back(st[i]);
            fi:;
            for(int i=1;i<=tp;++i) {
                vis[st[i]]=inq[a[st[i]]]=false;
                for(auto e:G[st[i]]) id[e.w].clear();
            }
        }
        if(E.empty()) break;
        for(auto e:E) dsu[find(e[0])]=find(e[1]);
        for(int i=0;i<n;++i) dsu[i]=find(i);
    }
    for(int i:res) z[i]=true;
    return z;
}
```

---

## 作者：Purslane (赞：1)

# Solution

显然 $p$ 不能全部求出来。为什么？令 $r_i=c_j =1$，那么问题不弱于 DAG 可达性问题，而后者不能在低于 $O(nm)$ 的时间复杂度内求出。

考虑按照可达性连边，缩点，得到一个 DAG。我们需要求出它的所有零出度 SCC。

考虑一个算法流程：维护所有可能是零出度点的节点。每次选出一个点暴力扩展，如果访问到一个能到达另一个零度点的点，就将这个点挂到另一个零度点上。使用并查集维护这个过程。

类似 B 型 MST 算法，我们跑 $O(\log n)$ 轮。每一轮我们要保证访问到的边集互不相交。可以这么实现：每次取出一个可能的点，跑一遍。如果不能访问到另一个点，我们将这个点暂时删掉（因为它以后不能和别人合并）；否则，我们合并了两个连通块，暂时把他们都删掉即可。（注意连通块的定义是：能到达同一个点的点的集合）

显然同一个 SCC 中只会有一个点保留。

所以我们以 $O(m)$ 的代价跑完了一轮，使得连通块个数减半，最后以 $O(m \log m)$ 的代价使得系统到达稳态。

到达稳态之后，对每个可能成为答案的点再跑一遍，就可以确定每个 SCC 中的点。

复杂度 $O(m \log m)$，代码也不难写。

这道题就是经典的“每个可能的连通块选一个代表元”。尝试在代表元之间进行操作。

```cpp
#include<bits/stdc++.h>
#include "keys.h"
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3e5+10;
int n,m,fa[MAXN],vis[MAXN],col[MAXN];
vector<pair<int,int>> G[MAXN];
vector<int> usd;
int find(int k) {
	return (fa[k]==k)?k:(fa[k]=find(fa[k]));	
}

int hc[MAXN];
vector<int> wt[MAXN];
vector<int> find_reachable(vector<int> R,vector<int> U,vector<int> V,vector<int> C) {
	n=R.size(),m=U.size();
	ffor(i,1,n) col[i]=R[i-1]+1;
	ffor(i,1,m) {
		int u=U[i-1]+1,v=V[i-1]+1,c=C[i-1]+1;
		G[u].push_back({v,c}),G[v].push_back({u,c});	
	}
	ffor(i,1,n) fa[i]=i;
	set<int> al;
	ffor(i,1,n) al.insert(i);
	while(!al.empty()) {
		set<int> tmp=al;
		while(!tmp.empty()) {
			int u=*tmp.begin();
			tmp.erase(u),usd.clear();
			queue<int> q;
			q.push(u),vis[u]=1,usd.push_back(u);
			int mzx=-1;
			while(!q.empty()) {
				int u=q.front();
				q.pop();
				if(!hc[col[u]]) {
					hc[col[u]]=1;
					for(auto v:wt[col[u]]) if(!vis[v]) {	
						if(find(u)!=find(v)) {mzx=find(v);break ;}	
						q.push(v),vis[v]=1,usd.push_back(v);
					}
				}
				for(auto pr:G[u]) {
					int v=pr.first,c=pr.second;
					if(vis[v]) continue ;
					if(hc[c]) {
						if(find(u)!=find(v)) {mzx=find(v);break ;}
						q.push(v),vis[v]=1,usd.push_back(v);
					}
					else wt[c].push_back(v);
				}
			}
			if(mzx!=-1) {
				fa[u]=mzx;
				if(tmp.find(mzx)!=tmp.end()) tmp.erase(mzx);
			}
			al.erase(u);
			for(auto id:usd) {
				vis[id]=0,hc[col[id]]=0;
				for(auto pr:G[id]) wt[pr.second].clear();	
			}
			usd.clear();
		}
	}
	vector<vector<int>> vc;
	int mn=n+1;
	ffor(i,1,n) if(find(i)==i) {
		int u=i;
		queue<int> q;
		q.push(u),vis[u]=1,usd.push_back(u);
		int mzx=-1;
		while(!q.empty()) {
			int u=q.front();
			q.pop();
			if(!hc[col[u]]) {
				hc[col[u]]=1;
				for(auto v:wt[col[u]]) if(!vis[v]) q.push(v),vis[v]=1,usd.push_back(v);
			}
			for(auto pr:G[u]) {
				int v=pr.first,c=pr.second;
				if(vis[v]) continue ;
				if(hc[c]) q.push(v),vis[v]=1,usd.push_back(v);
				else wt[c].push_back(v);
			}
		}
		for(auto id:usd) {
			vis[id]=0,hc[col[id]]=0;
			for(auto pr:G[id]) wt[pr.second].clear();	
		}
		vc.push_back(usd),mn=min(mn,(int)usd.size());
		usd.clear();
	}
	vector<int> ans;
	ans.resize(n);
	for(auto pr:vc) if(pr.size()==mn) for(auto id:pr) ans[id-1]=1;
	return ans;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

### Preface

和 P11394 几乎一样。

## Solution

这个东西看起来就很适合连成有向图！具体的的，我们连边 $u\to v$ 当且仅当如果我们访问到了 $u$，那么 $v$ 也会被访问，所求即为缩点后的 DAG 上大小最小的叶子和它们的大小和。 

那我们考虑一个事实：如果 $u\leadsto v$  且 $v\not\leadsto u$，那么 $v$ 就似了。

我们考虑维护这个 DAG 的内向生成森林，那么答案只能出现在每个根所在的 SCC 中，暴力统计复杂度就是对的。

有规律的图的生成森林可以考虑 Boruvka，我们每次对于一棵树的根在其所在的连通块中 dfs 一次，并合并。这件事至多发生 $\log n$ 轮，复杂度也就是 $O(n\log n)$ 的。

---

## 作者：MEKHANE (赞：1)

直接对于每个 $i$ 求出答案复杂度是 $\mathcal O(n(n+m))$ 的，无法优化，这启发我们寻找这种结构（钥匙和锁）的性质。

如果 $u$ 经过若干次扩展能到 $v$，连 $u \rightarrow v$。由于是单向边，性质并不是很足。所以考虑强连通分量转化为 DAG 增强性质。不难发现全局最小值一定在度数为 $0$ 的强连通分量上面，此时该分量上所有点答案均相等。

考虑怎么在不知道完整图的前提下求出度数为 $0$ 的强连通分量。注意到实际上判断一个强连通分量是否度数为 $0$ **仅需保留一条出边**即可，这样我们可以将"必须遍历完"转化为"遍历到不在强连通分量内"即可，而且我们之后不用处理该强连通分量。

以上是对于我们将强连通分量看成一个点的视察，那么强连通分量内的处理是什么样的呢？

不难发现所有的点等价（答案、可达性），所以我们随便选一个点即可代表该强连通分量。考虑将两个东西合并，经过一定的思考，可以发现我们直接每次将新遍历到的点当作代表点即可。

这样我们可以通过至多遍历**内部**的复杂度找到一个**外部**的点并连接，如果无法连接则可以统计答案（从代表点开始遍历），这非常像 Boruvka（通过**内部**的遍历，结合数据结构等找到**外部**最小），所以我们参考 Boruvka 的做法做即可，复杂度 $\mathcal O((n+m) \log n)$。

一些代码细节：注意我们如果合并了两个连通块，则新的连通块在该轮不能进行遍历，否则复杂度不对。

```cpp
#include<bits/stdc++.h>
#define vi vector<int>
#define pb push_back
#define rep(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
const int N=3e5+5;
int n,m,min1,cx[N],ky[N],bj[N],vis[N],xl[N],anc[N];
vi dans,R,jh[N];
vector<pair<int,int>> v[N];
int find1(int x){return anc[x]==x?x:anc[x]=find1(anc[x]);}
int bfs(int x){
    int pd=1,tot=0; vi res;
    queue<int> que; que.push(x);
    while(!que.empty()){
        int dq=que.front(); que.pop();
        if(find1(dq)!=x){anc[x]=find1(dq),vis[find1(dq)]=1,pd=0; break;}
        if(vis[dq]) continue; vis[dq]=1,res.pb(dq);
        for(auto [d1,d2]:v[dq]){
            if(!cx[d2]) xl[++tot]=d2,cx[d2]=1;
            if(ky[d2]) que.push(d1); else jh[d2].pb(d1);
        }
        if(!cx[R[dq]]) xl[++tot]=R[dq],cx[R[dq]]=1;
        for(auto d1:jh[R[dq]]) que.push(d1); ky[R[dq]]=1,jh[R[dq]].clear();
    }
    rep(i,1,tot) ky[xl[i]]=cx[xl[i]]=0,jh[xl[i]].clear();
    if(pd){
        bj[x]=1; int jg=res.size();
        if(jg<min1) min1=jg,dans=res;
        else if(jg==min1) for(auto dq:res) dans.pb(dq);
        return 0;
    }return 1;
}
vi find_reachable(vi r,vi u,vi vv,vi c){
    n=r.size(),m=u.size(),R=r;
    rep(i,0,m-1) v[u[i]].pb({vv[i],c[i]}),v[vv[i]].pb({u[i],c[i]});
    rep(i,0,n-1) anc[i]=i;
    min1=1e9;
    while(1){
        int pd=0;
        rep(i,0,n-1) vis[i]=0;
        rep(i,0,n-1) if(find1(i)==i&&!bj[i]&&!vis[i]) pd|=bfs(i);
        if(!pd) break;
    }vi ans; ans.resize(n);
    for(auto dq:dans) ans[dq]=1;
    return ans;
}
```

---

## 作者：b6e0_ (赞：0)

提供一种不同的思路。

首先我们会 $\mathcal O(n+m)$ bfs 求出一个点可以到达的所有点。

接下来一个想法就是以每个点为起点跑一遍 bfs，$\mathcal O(n(n+m))$。

发现题目只需要我们求出 $p_i$ 最小的位置。可达性显然是可传递的，所以若 $p_i$ 最小，设 $i$ 能到达的点集为 $S$，那么 $S$ 中的点是两两可达的。若我们已知 $x$ 可达 $y$，那么 $p_x\ge p_y$，我们可以不用从 $x$ 开始跑 bfs。

考虑利用这个性质优化算法。给每个点定义一个“属于”标记 $f_x$，初始 $f_x=x$。让 $n$ 个点**同时**开始 bfs，维护每个点可以到达的点集 $S_i$。在以 $x$ 为起点的 bfs 扩展一个点 $y$ 的时候，若 $f_y\ne x$，那么立刻停止 $x$ 的 bfs，并将所有等于 $x$ 的 $f_i$ 都改为 $f_y$（用并查集维护）。

发现这个过程类似于将 $S_x$ 合并到 $S_{f_y}$ 上（但不是真的合并），考虑用启发式合并保证复杂度。记 $d_x$ 为 $x$ 的度数，bfs 扩展一个点 $y$ 的时间复杂度是 $\mathcal O(d_y)$，于是对于所有 bfs，设起点为 $i$，维护 $s_i=\sum_{x\in S_i}d_x$，每次选 $s_i$ 最小的 bfs 进行扩展，即可保证每个点只被扩展 $\mathcal O(\log m)$ 次。

总时间复杂度 $\mathcal O(m\log m)$，实现不当可能会被卡常。

[代码](https://loj.ac/s/2308182)

---


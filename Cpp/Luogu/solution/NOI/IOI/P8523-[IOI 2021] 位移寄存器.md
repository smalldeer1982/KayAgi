# [IOI 2021] 位移寄存器

## 题目背景

**滥用本题评测将被封号**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

你的代码需要在开头添加以下代码：

```cpp
#include<vector>
void append_move(int t, int y);
void append_store(int t, std::vector<bool> v);
void append_and(int t, int x, int y);
void append_or(int t, int x, int y);
void append_xor(int t, int x, int y);
void append_not(int t, int x);
void append_left(int t, int x, int p);
void append_right(int t, int x, int p);
void append_add(int t, int x, int y);
void append_print(int t);
```

## 题目描述

工程师 Christopher 在开发一款新的计算机处理器。

这个处理器可以访问 $m$ 个不同的 $b$ 位存储单元（本题中 $m = 100$ 且 $b = 2000$）。它们被称作寄存器，编号从 $0 $ 到 $m - 1$。我们把这些寄存器记为 $r[0], r[1], \ldots , r[m - 1]$。每个寄存器都是 $b$ 个比特的数组，这些比特从 $0$（最右的比特）到 $b - 1$（最左的比特）编号。对所有的 $i$（$0 \le i \le m - 1$）和 $j$（$0 \le j \le b - 1$），我们将寄存器 $i$ 的第 $j$ 个比特记为 $r[i][j]$。

对所有的比特序列 $d_0, d_1, \ldots , d_{l - 1}$（具有某个长度 $l$），该序列的整数值等于 $2^0 \cdot d_0 + 2^1 \cdot d_1 + \cdots + 2^{l - 1} \cdot d_{l - 1}$。我们说存储在某个寄存器中的整数值就是寄存器中比特序列的整数值，也就是说，该整数值为 $2^0 \cdot r[i][0] + 2^1 \cdot r[i][1] + \cdots + 2^{b - 1} \cdot r[i][b - 1]$。

该处理器有 $9$ 种类型的指令，可以用来修改寄存器中的比特。每条指令操作一个或多个寄存器，并将其输出存储到其中的一个寄存器。下面我们用 $x := y$ 表示一个修改 $x$ 的值并将其变成 $y$ 的操作。每种类型的指令所做的操作描述如下：

$\operatorname{\mathit{move}}(t, y)$：将寄存器 $y$ 中的比特数组拷贝到寄存器 $t$。对所有的 $j$（$0 \le j \le b - 1$），设置 $r[t][j] := r[y][j]$。

$\operatorname{\mathit{store}}(t, v)$：设置寄存器 t 等于 $v$，这里 $v$ 是某个 $b$ 个比特的数组。对于所有的 $j$（$0 \le j \le b - 1$），设置 $r[t][j] := v[j]$。

$\operatorname{\mathit{and}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位与，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \le j \le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 同时为 $1$ 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。

$\operatorname{\mathit{or}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位或，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \le j \le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 至少有一个为 1 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。

$\operatorname{\mathit{xor}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位异或，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \le j \le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 恰好有一个为 1 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。

$\operatorname{\mathit{not}}(t, x)$：取寄存器 $x$ 的按位非，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \le j \le b - 1$），设置 $r[t][j] := 1 - r[x][j]$。

$\operatorname{\mathit{left}}(t, x, p)$：左移寄存器 $x$ 中的所有比特 $p$ 位，并将结果存到寄存器 $t$ 中。将寄存器 $x$ 中的比特左移 $p$ 位的结果，是一个包含 $b$ 个比特的数组 $v$。对于所有的 $j$（$0 \le j \le b - 1$），如果 $j \ge p$ 则 $v[j] = r[x][j - p]$，否则 $v[j] = 0$。对所有的 $j$（$0 \le j \le b - 1$），设置 $r[t][j] := v[j]$。

$\operatorname{\mathit{right}}(t, x, p)$：右移寄存器 $x$ 中的所有比特 $p$ 位，并将结果存到寄存器 $t$ 中。将寄存器 $x$ 中的比特右移 $p$ 位的结果，是一个包含 $b$ 个比特的数组 $v$。对于所有的 $j$（$0 \le j \le b - 1$），如果 $j \le b - 1 - p$ 则 $v[j] = r[x][j + p]$，否则 $v[j] = 0$。对所有的 $j$（$0 \le j \le b - 1$），设置 $r[t][j] := v[j]$。

$\operatorname{\mathit{add}}(t, x, y)$：将寄存器 $x$ 和 $y$ 中的整数值加起来，并将结果存到寄存器 $t$ 中。加法是在模 $2^b$ 下做的。正式一些来说，设 $X$ 是操作前存在寄存器 $x$ 中的整数值，而 $Y$ 是操作前存在寄存器 $y$ 中的整数值。设 $T$ 为操作后存在寄存器 $t$ 中的整数值。如果 $X + Y < 2^b$，设置 $t$ 中的比特使得 $T = X + Y$。否则，设置 $t$ 中的比特使得 $T = X + Y - 2^b$。

Christopher 希望你用这个新处理器解决两种任务。任务的类型用整数 $s$ 来表示。对所有类型的任务，你需要创建一个程序，其为上文所定义的指令构成的序列。

程序的输入包括 $n$ 个整数 $a[0], a[1], \ldots , a[n - 1]$，而每个整数都有 $k$ 个比特，也就是说，$a[i] < 2^k$（$0 \le i \le n - 1$）。在程序执行前，输入的所有的数都依次存储在寄存器 $0$ 中，使得对所有的 $i$（$0 \le i \le n - 1$），$k$ 比特序列 $r[0][i \cdot k], r[0][i \cdot k + 1], \ldots , r[0][(i + 1) \cdot k - 1]$ 的整数值等于 $a[i]$。注意 $n \cdot k \le b$。寄存器 $0$ 中所有其他的比特（其下标在 $n \cdot k$ 和 $b - 1$ 之间，包括 $n \cdot k$ 和 $b - 1$），以及其他所有寄存器中的所有比特，都初始化为 $0$。

执行某个程序就是按序执行其所包含的指令。在最后一条指令执行完毕后，程序的输出将根据寄存器 $0$ 中比特最终的值计算出来。具体来说，输出是 $n$ 个整数 $c[0], c[1], \ldots , c[n - 1]$ 的序列，这里对所有 $i$（$0 \le i \le n - 1$）来说，$c[i]$ 都是寄存器 $0$ 中比特 $i \cdot k$ 到 $(i + 1) \cdot k - 1$ 所构成的序列的整数值。注意，在程序运行结束后，寄存器 $0$ 中其余的比特（下标不小于 $n \cdot k$），以及其他寄存器中的所有比特，可能是任意值。

第一个任务（$s = 0$）是要找出输入整数 $a[0], a[1], \ldots , a[n - 1]$ 中的最小值。 具体来说，$c[0]$ 必须是 $a[0], a[1], \ldots , a[n - 1]$ 中的最小值。$c[1], c[2], \ldots , c[n - 1]$ 的值可以是任意的。

第二个任务（$s = 1$）是要将输入整数 $a[0], a[1], \ldots , a[n - 1]$ 进行非降序排序。具体来说，对于所有的 $i$（$0 \le i \le n - 1$），$c[i]$ 应当等于 $a[0], a[1], \ldots , a[n - 1]$ 中第 $1 + i$ 小的整数（也就是说，$c[0]$ 是输入整数中的最小整数）。

请帮 Christopher 写一下解决这些任务的程序。每个程序至多只能包含 $q$ 条指令。

## 说明/提示

对于所有数据：

- $m = 100$
- $b = 2000$
- $0 \le s \le 1$
- $2 \le n \le 100$
- $1 \le k \le 10$
- $q \le 4000$
- $0 \le a[i] \le 2^k - 1$（对于所有 $0 \le i \le n - 1$）

子任务|	分值|	特殊限制
:-:|:-:|:-:
$1$	|$10$|	$s = 0$，$n = 2$，$k \le 2$，$q = 1000$
$2$|	$11$|	$s = 0$，$n = 2$，$k \le 2$，$q = 20$
$3$	|$12$	|$s = 0$，$q = 4000$
$4$	|$25$|	$s = 0$，$q = 150$
$5$	|$13$	|$s = 1$，$n \le 10$，$q = 4000$
$6$	|$29$|	$s = 1$，$q=4000$

感谢 @[Bingxiu](https://www.luogu.com.cn/user/676498) 提供交互库。附件中的交互库可用于本地测试，与实际评测用的交互库有所不同。

## 样例 #1

### 输入

```
0 2 1 1000
0 0
0 1
1 0
1 1
-1```

### 输出

```
move 1 0
right 1 1 1
and 0 0 1
0
0
0
1```

## 样例 #2

### 输入

```
1 2 1 1000
0 0
0 1
1 0
1 1
-1
```

### 输出

```
move 1 0
right 1 1 1
and 2 0 1
or 3 0 1
left 3 3 1
or 0 2 3
0 0
0 1
0 1
1 1
```

# 题解

## 作者：wangbinfeng (赞：5)

[![](https://img.shields.io/badge/题目-P10052【IOI2021】位移寄存器-green)
![](https://img.shields.io/badge/难度-NOI/NOI+/CTSC-black)
![](https://img.shields.io/badge/考点-二进制、数学-yellow)
![](https://img.shields.io/badge/题型-交互题-red)](由于出题人私自乱改题号，本题解不设置传送门)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

------------
## $\texttt{Part\;1.\;supplementary\;description:}$
> 搬题人漏搬了题面中的好多内容，先放一个[官方中文 PDF 文件](https://ioi.te.lv/locations/ioi21/contest/day2/Registers/zh_CN.pdf)。具体地，在官方文件中有**样例解释**和**输入输出格式**的内容，以及**重点词加粗**。

## $\texttt{Part\;2.\;brief\;description\;of\;the\;topic:}$ 
> 输入数组 $a$ 存在寄存器 $0$ 中，可以用 $\texttt{MOVE(=),SROTE(=),AND(\&),OR(|),XOR(\textasciicircum),NOT(\textasciitilde),LEFT(<<),RIGHT(>>),ADD(+)}$ 共 $9$ 种指令。求 $\begin{cases}最小值 && \text{if} && s=0  \\排序 &&\text{if}&& s=1\end{cases}$。

## $\texttt{Part\;3.\;explanation\;of\;ideas:}$ 
>### $\texttt{Case\;1.\;Subject\;1\textasciitilde4(s=0):}$   
>> 先写一个 ADD 操作的二进制单位实现：$\begin{matrix}
   \qquad\;\;\; a \\+\qquad b \\ \hline
   \;\;\;\;c_1\;\;\;c_2
\end{matrix}$，显然，$c_1\gets a\texttt{\;AND\;}b,c_2\gets a\texttt{\;XOR\;}b$。   
然后考虑给定三个寄存器，暂且记作 $r_a,r_b,r_c$，其中 $r_a,r_b$ 已知，求 $r_c\gets\begin{cases}r_a && \text{if} && r_a=r_b  \\0 &&\text{if}&& r_a\neq r_b \end{cases}$。考虑取一个新的寄存器 $r_d\gets r_a\texttt{\;AND\;}r_b$，显然，$\begin{cases}r_a=r_b && \text{if} && r_d=0  \\r_a\neq r_b &&\text{if}&& r_d\neq0\end{cases}$。然后 $\underbrace{r_d\gets r_d<<1,r_d\gets r_d<<1,...,r_d\gets r_d<<1}_{2^k\text{\;times}},$ $\underbrace{r_d\gets r_d>>1,r_d\gets r_d>>1,...,r_d\gets r_d>>1}_{2^{k}\;\text{times}}$（结束后 $k$ 的最低 $2^k$ 位均为 $\begin{cases}0 && \text{if} && r_a=r_b  \\1 &&\text{if}&& r_a\neq r_b \end{cases}$）。此时，$r_c\gets(\texttt{\;NOT\;}r_d)\texttt{\;AND\;}r_a$。 对于 $\texttt{Subject\;1}$ $n,k\le2$，直接对 $16$ 种情况编码即可。   
考虑如何比较 $r_0$ 和 $r_1$ 的大小，$r_1=r_0\texttt{\;AND\;}k, r_2\gets\texttt{\;NOT\;}r_1,r_3\gets r_0\texttt{\;ADD\;}r_2$，$r_{3,k}$ 的值即 $r_0$ 和 $r_1$ 的大小关系。重复执行 $\lceil \log_2 n\rceil$ 次即可，询问次数为 $12\lceil \log_2 n\rceil+4$。

>### $\texttt{Case\;2.\;Subject\;5\textasciitilde6(s=1):}$   
>> 考虑冒泡排序，可通过 $\texttt{Subject\;5}$。回归冒泡排序的本质，要将 $a_1,a_2,a_3,...a_n$ 进行非降序排序排序，可以将其修改为 $\min(a_1,a_2),\max(a_1,a_2),\min(a_3,a_4),\max(a_3,a_4),...,\min(a_{n-1},a_n),\max(a_{n-1},a_n)$，再进行奇偶反转校验（如 $\max(a_1,a_2),\min(a_3,a_4)$ 修改为 $\min(a_3,a_4),\max(a_1,a_2)$），重复 $n$ 次即可，询问次数为 $19n+6$。

## $\texttt{Part\;4.\;code:}$
 ```cpp
#include<bits/stdc++.h>
#ifdef ONLINE_JUDGE
void append_move(int t, int y);
void append_store(int t, std::vector<bool> v);
void append_and(int t, int x, int y);
void append_or(int t, int x, int y);
void append_xor(int t, int x, int y);
void append_not(int t, int x);
void append_left(int t, int x, int p);
void append_right(int t, int x, int p);
void append_add(int t, int x, int y);
void append_print(int t);
#else 
#include"registers.h"
#endif
const int m=100,b=2000;
void construct_min(const int n,const int k){
	std::vector<bool>v(b,0);
	const int fill_up=m-1,mask_ones=m-2,low_one=m-3;
    for(int i=0;i<b;i++)if(i%(2*k)==0)v[i]=1;
    append_store(low_one,v),v.assign(v.size(),0);
    for(int i=0;i<b;i++)if((i/k)%2==0)v[i]=1;
    append_store(mask_ones,v),v.assign(v.size(),0);
    for(int i=n*k;i<b;i++)v[i]=1;//将寄存器0中不属于a的部分全部置1 
    append_store(fill_up,v);
    append_or(0,0,fill_up);
    for(int T=ceil(log2(n)),a=k;T--;a*=2)
        append_right(1,0,a),
        append_not(3,1),
        append_and(3,3,mask_ones),
        append_and(0,0,mask_ones),
        append_add(2,0,3),
        append_right(2,2,k),
        append_and(2,2,low_one),
        append_add(2,2,mask_ones),
        append_and(4,2,0),
        append_not(5,2),
        append_and(5,1,5),
        append_or(0,4,5);
}
void construct_sort(const int n,const int k){
	std::vector<bool>v(b,0);
	const int fill_up=m-1,mask_ones=m-2,low_one=m-3;
    for(int i=0;i<b;i++)if(i%(2*k)==0)v[i]=1;
    append_store(low_one,v),v.assign(v.size(),0);
    for(int i=0;i<b;i++)if((i/k)%2==0)v[i]=1;
    append_store(mask_ones,v),v.assign(v.size(),0);
    for(int i=n*k;i<b;i++)v[i]=1;//将寄存器0中不属于a的部分全部置1 
    append_store(fill_up,v);
    append_or(0,0,fill_up);
    for(int T=0;T<n;T++) {
        if(T%2)append_left(1,0,k);else append_right(1,0,k);
        append_not(5,1);
        append_and(5,5,mask_ones);
        append_and(0,0,mask_ones);
        append_add(2,0,5);
        append_right(2,2,k);
        append_and(2,2,low_one);
        append_add(2,2,mask_ones);
        append_not(4,2);
        append_and(3,2,0);
        append_and(5,1,4);
        append_or(7,3,5);
        append_and(7,7,mask_ones);
        append_and(3,2,1);
        append_and(5,4,0);
        append_or(6,3,5);
        append_and(6,6,mask_ones);
        if(T%2)append_right(7,7,k);else append_left(6,6,k);//注意这里奇偶移位的寄存器不同 
        append_or(0,6,7);
    }
    append_not(fill_up,fill_up);
    append_and(0,0,fill_up);
}
void (*fun[2])(const int,const int)={construct_min,construct_sort};
void construct_instructions(int s,int n,int k,int){fun[s](n,k);}
```

## $\texttt{Part\;5.\;express\;gratitude:}$ 
> 感谢[ luogu 网站](https://www.luogu.com.cn/)提供平台支持，感谢 IOI 官方组织比赛，感谢 Maxim Akhmedov 出这么好的题 ~~，感谢搬题人私自乱改题号还忘记改附件名称（只是调侃，不喜私信或评论即删）~~。

## $\texttt{Part\;6.\;appendix:}$     
> - 小提示：本地用 DEV 做本题时记得建项目哦（因为跨文件了）。   

>（以下为题外话，可跳过）   
在机房推了 5 个小时公式，用了三四面黑板，不得不说 IOI 出的题真不错（没有算法难度，全是数学和位运算的难点）。公式显然不是自己推出来的，感谢[官方题解](https://ioi.te.lv/locations/ioi21/contest/day2/Registers/registers-CMS.zip)。话说这么多位运算的题是咋想到的。这种题建议还是自己得手推几遍的。   
交互题真的会上瘾。我做这道题就因为做 IOI2021Day2T1 上瘾了，那道题比较简单，可以一做。  
字数有点多，$\KaTeX$ 打的快吐了，如有手误欢迎评论。   
超多 $\KaTeX$，在博客编辑区无法显示，但是博客页面和其他编辑区、显示区均正常。烦请题解志愿者注意一下，$\KaTeX$ 真的真的没炸！（逃了）   
如果题解区显示炸了欢迎前往博客查看哦。   
【UPD.2024/3/1】由于本题解提交时间恰逢过年管理放假，从写完初稿到被打回已经过去整 15 天，如有错误见谅，烦请评论区回复。

---

## 作者：zjy2008 (赞：2)

来补好题选讲。

先把 $n$ 补成 $2$ 的幂次比较好写。

### Task 1

考虑怎么计算出 $2$ 个数的 $\min$。发现如果 $x\le y$，那么 $x+2^k-y-1$ 的第 $k$ 位一定是 $0$，否则是 $1$，那么我们直接奇偶位分开。计算 $x+2^k-y-1$ 再 $\rm{and} (2^k)$ 即可。$-y-1$ 其实就是 $\rm{not}(y)$，只需要考虑计算机如何计算补码即可。接下来我们要把 $0,1$ 变成 $0,-1$。这就是取负号，直接实现补码即可。最后如果是 $0$，放入 $x$，否则放入 $y$，是简单的。

次数 $O(\log n)$，作者实现 $121$ 次。

### Task 2

又看见造计算机题在排序了，[旷野大计算](https://www.luogu.com.cn/problem/P1737) 告诉我们，可以使用双调排序来解决这类问题。根据 **Task 1** 的做法，只要先在每个数前面插入一个 $0$，我们就可以在 $O(1)$ 次操作内求出对位 $\min$。对于插入 $0$ 和 reverse 操作，我们都可以直接使用分治在 $O(\log n)$ 次操作内解决。

次数 $O(\log^2 n)$，作者实现 $668$ 次。

[代码](https://qoj.ac/submission/1069363)。

---

## 作者：unk_03 (赞：2)

蒟蒻的第一篇题解，写的不好的地方请指出。
### 题意
有 $9$ 种操作，利用这 $9$ 种操作实现数组取最小值和数组排序。
#### 数组取最小值
首先考虑如何比较 $2$ 个整数大小，我们可以想到将 $2$ 个整数相减，将结果与 $0$ 比较，对于有符号整数，只要看最高位是否为 $1$ 即可判断 $2$ 个整数大小。

但是题目给出的整数并没有给我们留出符号位，这种情况下无法直接使用上述方法，我们有 $2$ 个选择：

+ 将每个整数上移一位，人为制造符号位。

+ 将最高位单独拎出来比较，再将各整数的最高位设为0后使用上述方法，然后将二者比较结果合并。

对于第一种选择，仅将整数移位后放回，其操作次数就不少于 $2n$，故不考虑这种方法。

对于第二种选择，我们考虑整数 $a$ 大于整数 $b$ 需要满足的条件。

+ $a$ 的最高位大于 $b$ 的最高位。

+ $a$ 的最高位等于 $b$ 的最高位，且 $a$ 后面的值大于 $b$ 后面的值。

反之，则 $b$ 大于等于 $a$。

至于整数减法，只要将 $b$ 取反加 $1$ 后相加，由于我们只需要知道 $2$ 个整数比较结果，可以省去加 $1$ 操作，可以证明这不影响结果的正确性。

整体流程如下：

1. 将 $r_0$ 位移 $n$ 个整数大小存入另一个寄存器，记为 $r1$。

2. 对 $r_0$,$r1$ 取异或存入另一个寄存器，记为 $ff$ （这一步判断最高位是否相等）。

3. 将 $r_0$,$r1$ 的最高位清 $0$ 后相减，结果存入 $mf$。

4. 对 $ff$,$r1$ 取与，存入 $zf$（这一步判断第一个条件）。

5. 对 $ff$ 取非，对取非后的结果和 $mf$ 取与，结果与 $zf$ 先前的结果取或（这一步判断第二个条件，$zf$ 存储的结果为 $r_0$,$r1$ 的最大值，不用对 $zf$ 取非，原因下面会有）。

6. 由于 $zf$ 除最高位以外的值未定义，为方便后续操作，将其他位的值清 $0$。

7. 将 $zf$ 其他位的值设置为与最高位相同的值，这可以通过位移后取或实现，此步需要 $2 \times \lceil \log_2{k} \rceil$ 次操作。

8. 我们记 $r_0$ 和 $r_1$ 较小值编号为 $A$，对于最终结果，一个很容易想到的表达式为
    $$
    (A \land r_1) \lor (\neg A \land r_0)
    $$
    但这样一次需要 $4$ 条指令，算上之前的操作，$1$ 次流程总共最多需要 $24$ 条指令，会超出题目限制。可以对此表达式进行转换，转换后可以得到
    $$
    r_1 \oplus (\neg A \land (r_0 \oplus r_1))
    $$
    其中 $r_0 \oplus r_1$ 的结果已经存储在 $ff$ 寄存器内，可以直接使用，而此表达式需要的是较大值编号，所以我们之前 $zf$ 的运算结果不用取非。将这一步得到的运算结果存回 $r_0$，即完成 $1$ 次流程。

由于这样一次可以对多组整数进行操作，这一流程只要执行 $\lceil \log_2{n} \rceil$ 次，算上清 $0$ 寄存器初始化，总共需要 $(13 + 2 \times \lceil \log_2{k} \rceil) \times \lceil \log_2{n} \rceil + 2$ 条指令，可以通过。
#### 数组排序
在计算较小值的同时可以顺便计算较大值，并将二者一起赋给 $r_0$ ，由于一次可以对多组整数进行操作，我们考虑使用冒泡排序，奇偶交替置换元素，可以证明，这样最多只需要执行 $n$ 次流程，总共需要 $(20 + 2 \times \lceil \log_2{k} \rceil) \times n + 4$ 条指令。

AC 代码

```cpp
#include<vector>
#include<memory.h>
using namespace std;
void append_move(int t, int y);
void append_store(int t, std::vector<bool> v);
void append_and(int t, int x, int y);
void append_or(int t, int x, int y);
void append_xor(int t, int x, int y);
void append_not(int t, int x);
void append_left(int t, int x, int p);
void append_right(int t, int x, int p);
void append_add(int t, int x, int y);
void append_print(int t,int x);
#define mov append_store
#define tand append_and
#define tor append_or
#define txor append_xor
#define rev append_not
#define shl append_left
#define shr append_right
#define add append_add
#define r0 0
#define r1 1
#define set0 2
#define set1 3
#define ff 4
#define nff 12
#define zf 5
#define r0s 6
#define r1s 7
#define mf 8
#define tmp 9
#define tbig 10
#define tsm 11
#define s10 13
#define s11 14
#define s01 15
#define s0h 16
bool bs[2000];
void getres(int i, int k)
{
    shr(r1, r0, k * i);
    txor(ff, r0, r1);
    tand(zf, ff, r1);
    rev(nff, ff);
    tand(r0s, set0, r0);
    tand(r1s, r1, set0);
    rev(r1s, r1s);
    add(mf, r0s, r1s);
    tand(mf, nff, mf);
    tor(zf, zf, mf);
    tand(zf, set1, zf);
    for (int sh = 1, sk = k; sk > 1; sk -= sh, sh = min(sh * 2, sk - 1))
    {
        shr(tmp, zf, sh);
        tor(zf, tmp, zf);
    }
    tand(tmp, zf, ff);
}
void construct_instructions(int s, int n, int k, int q)
{
    vector<bool> s0(2000);
    for (int i = 0; i < n; i++)s0[i * k + k - 1] = 1;
    mov(set1, s0);
    rev(set0, set1);
    if (s == 0)
    {
        for (int i = 1; n > 1; n -= i, i = min(i * 2, n - 1))
        {
            getres(i, k);
            txor(r0, tmp, r1);
        }
    }
    else
    {
        for (int i = 0; i < 2000; i += k)memset(bs + i, i / k % 2 == 1, min(k, 2000 - i));
        vector<bool>ni(bs, bs + 2000), bs2(2000), bs3(2000);
        for (int i = 0; i < k; i++)bs2[i] = 1;
        for (int i = n * k - k; i < n * k; i++)bs3[i] = 1;
        mov(s01, bs2);
        mov(s10, ni);
        rev(s11, s10);
        mov(s0h, bs3);
        for (int i = 0; i < n; i++)
        {
            getres(1, k);
            txor(tbig, tmp, r0);
            txor(tsm, tmp, r1);
            tand(tbig, tbig, i % 2 ? s10 : s11);
            tand(tsm, tsm, i % 2 ? s10 : s11);
            if (i % 2)
            {
                tand(tmp, r0, s01);
                tor(tsm, tsm, tmp);
                if (n % 2 == 0)
                {
                    tand(tmp, r0, s0h);
                    tor(tsm, tsm, tmp);
                }
            }
            else if (n % 2)
            {
                tand(tmp, r0, s0h);
                tor(tsm, tsm, tmp);
            }
            shl(tbig, tbig, k);
            tor(r0, tbig, tsm);
        }
    }
}
//idea&code:unk_03, cute:H_LP
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P8523)

**题目大意**

> 给定 $100$ 个 $2000$ 位二进制变量，每次操作可以是赋值、拷贝、左移、右移、取与、取或、取异或、取反、加法，构造一个程序完成如下任务：
>
> - $150$ 次操作内，求出 $n$ 个 $k$ 位二进制数的最小值。
> - $4000$ 次操作内，给 $n$ 个 $k$ 位二进制数排序。
>
> 输入输出格式：所有数依次存储在 $0$ 号变量的 $[0,k),[k,2k),[2k,3k),\dots $ 位。
>
> 数据范围：$n\le 100,k\le 10$。

**思路分析**

在没有判断语句的时候很难比较两个数的大小。

一种想法是加上符号位，然后比较 $a+b$ 的大小，即 $a+(2^{k+1}-1-b)\bmod 2^{k+1}$ 的 $2^k$ 位为 $0$ 说明 $a>b$，否则 $a\le b$。

然后与上 $2^{k}$，得到 $s_k$ 就是 $[a\le b]$，那么 $s$ 或上 $s$ 左移 $1,2,4,8$ 位，则 $s=[a\le b]\times(2^{k+1}-1)$。

因此 $\min(a,b)=b\oplus (s\operatorname{AND} (a\oplus b))$。

回到原问题，由于所有的位是连续给出，因此没有放符号位的空间。

我们可以特判第 $k$ 位的大小关系，然后把第 $k$ 位当符号位，比较前 $2^{k-1}$ 位的结果。

那么真正的 $s$ 就是 $s'\operatorname{AND}(\mathrm{NOT}(a\oplus b))$ 再或上 $(a\oplus b)\operatorname{OR} b$ 的第 $k$ 位。

注意到 $b$ 为 $a$ 左移 $k$ 的时候可以一次性让每个 $a_i\gets \min(a_i,a_{i+1})$，然后 $b$ 取 $a$ 左移 $2k$，$a_i\gets \min(a_i,a_{i+1},a_{i+2},a_{i+3})$，只要进行 $\lceil \log_2n\rceil$ 轮就能得到答案。

注意这里 $s_k\to s$ 的过程中不能左移 $1,2,4,8$ 位，否则可能影响到前一个 $s$。

并且前一个 $a+(2^k-1-b)$ 可能对下一个有进位，但 $a\gets a+1$ 后 $s_k$ 变化当且仅当 $a=b$，那么这种情况 $s_k\in\{0,1\}$ 都等价。

可以构造 $(13+2\lceil\log_2k\rceil)\lceil\log_2n\rceil+2\le 149$ 次操作的方案。

然后是第二问，可以根据 $s$ 求出 $\min(a_i,a_{i+1}),\max(a_i,a_{i+1})$，然后奇偶排序即可。

即第 $t$ 轮对 $i\bmod 2=t\bmod 2$ 的点冒泡排序，这样至多 $n$ 次就能还原。

操作次数不超过 $(22+2\lceil\log_2k\rceil)n+6\le 3006$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "registers.h"
using namespace std;
namespace luotianyi {
const int M=100,B=2000,hi1=99,hi0=98;
int n,k;
const int a=0,b=1,XOR=2,SGN=3,ta=4,tb=5,DIF=6,NXOR=7,tmp=8;
void cmp(int d) {
    append_right(b,a,d*k);
    append_xor(XOR,a,b);
    append_and(SGN,XOR,b);
    append_and(ta,a,hi0);
    append_and(tb,b,hi0);
    append_not(tb,tb);
    append_add(DIF,ta,tb);
    append_not(NXOR,XOR);
    append_and(DIF,DIF,NXOR);
    append_or(SGN,SGN,DIF);
    append_and(SGN,SGN,hi1);
    for(int i=1;i<k;i*=2) {
        append_right(tmp,SGN,min(i,k-i));
        append_or(SGN,SGN,tmp);
    }
}
const int odd=97,even=96,mn=9,mx=10,lef=95,rit=94;
void solve(int s,int N,int K,int q) {
    n=N,k=K; vector <bool> o1(B);
    for(int i=0;i<n;++i) o1[i*k+k-1]=1;
    append_store(hi1,o1);
    for(int i=0;i<n*k;++i) o1[i]=o1[i]^1;
    append_store(hi0,o1);
    if(s==0) {
        for(int i=1;i<n;i*=2) {
            cmp(min(i,n-i));
            append_and(XOR,XOR,SGN);
            append_xor(a,b,XOR);
        }
    } else {
        vector<bool> o2(B),o3(B),o4(B);
        for(int i=0;i<n*k;++i) o2[i]=(i/k)%2;
        for(int i=0;i<k;++i) o3[i]=o4[i+(n-1)*k]=1;
        append_store(odd,o2);
        for(int i=0;i<n*k;++i) o2[i]=o2[i]^1;
        append_store(even,o2);
        append_store(lef,o3);
        append_store(rit,o4);
        for(int i=0;i<n;++i) {
            cmp(1);
            const int a=0,b=1,mn=9,mx=10;
            append_and(XOR,XOR,SGN);
            append_xor(mx,a,XOR);
            append_xor(mn,b,XOR);
            append_and(mx,mx,(i&1)?odd:even);
            append_and(mn,mn,(i&1)?odd:even);
            if(i&1) {
                append_and(tmp,a,lef);
                append_or(mn,mn,tmp);
            }
            if((n-i)&1) {
                append_and(tmp,a,rit);
                append_or(mn,mn,tmp);
            }
            append_left(mx,mx,k);
            append_or(a,mn,mx);
        }
    }
}
}
void construct_instructions(int s,int n,int k,int q) {
    return luotianyi::solve(s,n,k,q);
}
```

---


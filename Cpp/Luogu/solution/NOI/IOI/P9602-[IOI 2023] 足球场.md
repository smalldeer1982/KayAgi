# [IOI 2023] 足球场

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。

## 题目描述

Debrecen 市有一片正方形的森林名叫 Nagyerdő，可以看作是 $N \times N$ 的方格。
方格的行由北向南从 $0$ 到 $N - 1$ 编号，列由西向东从 $0$ 到 $N - 1$ 编号。
方格中第 $r$ 行第 $c$ 列的格子被称为单元格 $(r, c)$。

森林里的每个单元格要么是**空**的，要么是**有树**的。
森林里至少有一个空单元格。

DVSC 是这个城市最著名的体育俱乐部，目前正计划在森林里修建一座新的足球场。
大小为 $s$ 的球场（这里 $s \ge 1$）是 $s$ 个**互不相同的空**单元格 $(r_0, c_0), \ldots, (r_{s - 1}, c_{s - 1})$ 的集合。
形式化地说，这意味着：

- 对于从 $0$ 到 $s - 1$（包含两端）的每个 $i$，单元格 $(r_i, c_i)$ 是空的；
- 对于满足 $0 \le i \lt j \lt s$ 的每组 $i$ 和 $j$，$r_i \neq r_j$ 和 $c_i \neq c_j$ 二者中至少有一个成立。

踢球时足球在球场的单元格之间传递。
**直传**是以下两种动作之一：

* 球场包含第 $r$ 行中单元格 $(r,a)$ 和 $(r,b)$ 之间的**全部**单元格，球从单元格 $(r,a)$ 传递到单元格 $(r,b)$（$0 \le r,a,b \lt N, a \ne b$）。包含关系的形式化定义为：
  - 若 $a \lt b$，则球场应包含满足 $a \le k \le b$ 的每个单元格 $(r,k)$；
  - 若 $a \gt b$，则球场应包含满足 $b \le k \le a$ 的每个单元格 $(r,k)$。
* 球场包含第 $c$ 列中单元格 $(a,c)$ 和 $(b,c)$ 之间的**全部**单元格，球从单元格 $(a,c)$ 传递到单元格 $(b,c)$（$0 \le c,a,b \lt N, a \ne b$）。包含关系的形式化定义为：
  - 若 $a \lt b$，则球场应包含满足 $a \le k \le b$ 的每个单元格 $(k, c)$；
  - 若 $a \gt b$，则球场应包含满足 $b \le k \le a$ 的每个单元格 $(k, c)$。

如果可以通过至多 $2$ 次直传将球从球场的任意单元格传递到另外的任意单元格，那么称这样的球场是**规则**的。
注意，任何大小为 $1$ 的球场都是规则的。

例如，考虑一片大小为 $N = 5$ 的森林，其中单元格 $(1,0)$ 和 $(4,2)$ 有树，其余单元格均为空。
下图显示了三个可能的球场。有树的单元格用深色表示，组成球场的单元格划有斜线。

![](https://cdn.luogu.com.cn/upload/image_hosting/rhrk04xf.png)

左边的球场是规则的。然而，中间的球场不是规则的，原因是把球从单元格 $(4,1)$ 传递到单元格 $(4,3)$ 至少需要 $3$ 次直传。右边的球场也不是规则的，原因是无法通过直传将球从单元格 $(3,0)$ 传递到单元格 $(1,3)$。

体育俱乐部希望建造尽可能大的规则球场。
你的任务是找出最大的 $s$ 值，使得森林里可以建造大小为 $s$ 的规则球场。

## 说明/提示

## 约束条件

* $1 \le N \le  2\,000$
* $0 \le F[i][j] \le 1$（对满足 $0 \le i \lt N$ 且 $0 \le j \lt N$ 的所有 $i$ 和 $j$）
* 森林里至少存在一个空单元格。也就是说，对于某组满足 $0 \le i \lt N$ 且 $0 \le j \lt N$ 的 $i$ 和 $j$，有 $F[i][j] = 0$。

## 子任务

1. （6 分）至多只有一个单元格有树。
2. （8 分）$N \le 3$
3. （22 分）$N \le 7$ 
4. （18 分）$N \le 30$ 
5. （16 分）$N \le 500$
6. （30 分）没有额外的约束条件。

在每个子任务中，如果你的程序能够正确判定**全部**空单元格组成的集合能否构成一个规则球场，那么你将在该子任务获得 25% 的部分分。

更准确地讲，对于所有空单元格组成的集合是一个规则球场的测试用例，你的解答的得分情况如下：

* 如果返回正确答案（也就是所有空单元格的数量），则得满分；
* 否则得 0 分。

对于所有空单元格组成的集合**不是**一个规则球场的测试用例，你的解答的得分情况如下：

* 如果返回正确答案，则得满分；
* 如果返回所有空单元格的数量，则得 0 分；
* 如果返回其他值，则得 25% 的分数。

每个子任务的得分是这个子任务中所有测试用例得分的最低值。

## 评测程序示例

评测程序示例按以下格式读取输入：

* 第 $1$ 行：$N$
* 第 $2 + i$ 行（$0 \le i \lt N$）：$F[i][0] \; F[i][1] \; \ldots \; F[i][N - 1]$

评测程序示例按以下格式打印你的答案：

* 第 $1$ 行：函数 `biggest_stadium` 的返回值

# 题解

## 作者：Lynkcat (赞：17)

这个题很有趣啊，感觉自己想出来这个题的过程非常有趣。

让我们先来编一个合法条件，一种简洁的刻画方式是：若干个长度区间不断扩张宽度区间不断缩短的矩阵的并。

因此尝试利用这个结构来进行 dp，一个直观的想法是我们枚举最长的那个矩形覆盖了哪一列，然后在这一列上对行区间进行 dp。具体是 $dp_{l,r}$ 表示当前矩形行区间为 $[l,r]$ 然后继续选择矩形的最大答案，显然列区间一定是能取满就取满。

设 $(L,R)$ 为列区间，转移显然是从第 $L$ 或 $R$ 列上限制住 $[l,r]$ 的那些 $1$ 的空隙里面转移过来，一种方便的写法是发现第 $l$ 行和第 $r$ 行不会同时被空隙包含，所以直接考虑把这一行去掉的贡献即可，即 $dp_{l,r}=\max(dp_{l+1,r},dp_{l,r-1})+R-L-1$。

这个做法是 $O(n^3)$ 的，配合上特判只能通过 $77.5$ 分。

实际上上面这个做法有很多可以优化的地方。首先我们考虑如何抛开枚举哪一列这个步骤来刻画状态中的所谓“空隙”。直接用行区间 $l,r$ 刻画显然会有重复。但是如果我们用 $l-1$ 行上的某一个 $1$ 的位置与 $r$ 来刻画这个空隙，就不会有重复了，并且状态数仍然是 $O(n^2)$ 的，因为要保证这个 $1$ 下面一直到第 $r$ 行都没有别的 $1$。

也就是说，我们可以直接用矩阵上的一个位置来表示一个空隙。我们将空隙而接下来转移也很简单，跟上面一样，每次要么 $r$ 这一行不被包含在下一个空隙里直接算贡献，要么就转移到左边或右边最下面的一个空隙中即可。

对于每个空隙求列区间 $(L,R)$ 以及整个 dp，都可以在 $O(n^2)$ 的时间内完成。代码实现非常之简洁啊！这个题真是太美了。

```c++
#include "soccer.h"
#include<bits/stdc++.h>
#define poly vector<int>
#define IOS ios::sync_with_stdio(false)
#define ll long long
#define mp make_pair
#define mt make_tuple
#define pa pair < int,int >
#define fi first
#define se second
#define inf 1e18
#define mod 998244353
// #define int ll
#define N 2005
using namespace std;
namespace 
{
    int dp[N][N];
    int pos[N][N];
    int L[N][N],R[N][N];
}
int biggest_stadium(int n, std::vector<std::vector<int>> aa)
{
    int ans=0;
    vector<vector<pa>>tong(n+1,vector<pa>());
    for (int j=1;j<=n;j++)
    {
        for (int i=1;i<=n;i++)
        {
            dp[i][j]=0;
            if(aa[i-1][j-1]) pos[i][j]=i;
            else pos[i][j]=pos[i-1][j];
            tong[i-pos[i][j]].push_back(mp(i,j));
        }
    }
    for (int i=1;i<=n;i++)
    {
        L[i][0]=0;
        for (int j=1;j<=n;j++)
            if (aa[i-1][j-2]) L[i][j]=j-1;else L[i][j]=L[i][j-1];
        R[i][n+1]=n+1;
        for (int j=n;j>=1;j--)
            if (aa[i-1][j]) R[i][j]=j+1;else R[i][j]=R[i][j+1];
    }
    for (int d=1;d<=n;d++)
    {
        for (auto [i,j]:tong[d])
        {
            if (pos[i][j]!=i-1)
            {
                R[i][j]=min(R[i][j],R[i-1][j]);
                L[i][j]=max(L[i][j],L[i-1][j]);
            }
            dp[i][j]=dp[i-1][j]+R[i][j]-L[i][j]-1;
            if (L[i][j]>0)
            {
                int len=pos[i][L[i][j]]-pos[i][j];
                dp[i][j]=max(dp[i][j],dp[i][L[i][j]]+len*(R[i][j]-L[i][j]-1));
            }
            if (R[i][j]<=n)
            {
                int len=pos[i][R[i][j]]-pos[i][j];
                dp[i][j]=max(dp[i][j],dp[i][R[i][j]]+len*(R[i][j]-L[i][j]-1));
            }
            ans=max(ans,dp[i][j]);
        }
    }
    return ans;
}
```

---

## 作者：XiaoQuQu (赞：8)

首先考虑一个足球场长啥样才是合法的。发现一个点能只拐弯一次到达另一个点，可以分为两种情况：先左右走，再上下走 或 先上下走，后左右走。无论哪种情况，都要求我们走一步使得和目标点一个轴相同，再走一步使得另一个轴也相同，所以加入把每一行选择的格子看成一个区间（因为如果不连续显然是不合法的），我们选择的这些区间一定是互相包含的关系，且必须是一个凸的图形（即不能有工字形）。

然后我们考虑一个 $O(n^3)$ 的做法，设 $f(l,r,x)$ 表示考虑第 $[l,r]$ 行，选择的区间一定包含第 $x$ 列的最大足球场大小（如下图就是一个 $l=1,r=3,x=1$ 时的例子）。

![](https://img.zshfoj.com/ff43738d0fb17897ad364589a049864bf8f265c3f48dbea04ca055b4a3c04907.png) 

考虑转移。我们对于每个状态 $(l,r,x)$ 维护一个列区间 $[L,R]$，代表我们选择的区间需要为 $[L,R]$ 的子区间，然后从 $(l+1,r,x)$ 与 $(l,r-1,x)$ 转移即可，这个部分是简单的。

但是我们会发现，这样的状态数是 $O(n^3)$ 的，无法通过这道题。但是我们发现许多状态显然是无用的，如下图。

![](https://img.zshfoj.com/bd6ff443e511f70fa3e1b7e89b433e145815af452538c23fa4fd458b362a97c8.png)

假设我们当前在蓝色状态（即 $(3,3,x)$ 状态），我们发现我们当前的状态一定不能成为答案，因为我们可以没有任何花费的（也就是在保持我们需要选择的区间 $[L,R]$ 不变的情况下）扩展到红色状态+蓝色状态（即 $(2,3,x)$ 状态）。

所以我们发现，我们可以固定 $r$，有用的整数对 $(l,x)$ 不超过 $O(n)$ 个（对于每一个 $x$，我们显然会将 $l$ 扩展到第 $x$ 列上最靠下的一个障碍），所以我们只需要 $(r,x)$ 就可以唯一确定一个状态，这样我们的总状态数就降到了 $O(n^2)$。

考虑在这种情况下我们怎么进行转移，我们会发现，对于一个状态 $(r,x)$，我们要么就是从 $(r-1,x)$ 增加第 $r$ 转移来，此时对答案的贡献就是当前这一行能够选择的最大区间长度（即区间 $[\max(L(r,x),L(r-1,x)),\min(R(r,x),R(r-1,x))]$，其中 $L(r,x)$ 表示状态 $(r,x)$ 能选择的最左边的列，$R(r,x)$ 以及下文的 $U(r,x)$ （即向上）同理）。要么就是令第 $r$ 行为最宽的一行，此时答案为 $f(r,L(r-1,x))+(U(r,L(r-1,x))-U(r,x)) \times (\min(R(r,x),R(r-1,x))-\max(L(r,x),L(r-1,x)))$。

最终我们会发现，所有信息的维护都可以在 $O(1)$ 内完成，时间复杂度 $O(n^2)$，可以通过本题。

```cpp
const int MAXN = 2005;
int n, f[MAXN][MAXN], L[MAXN][MAXN], R[MAXN][MAXN], U[MAXN][MAXN], ll[MAXN][MAXN];
vector<pair<int, int>> dp[MAXN];

signed biggest_stadium(signed _, vector<vector<signed>> ___) {
	n = _;
	vector<vector<int>> a(n + 3, vector<int>(n + 3));
	for (int i = n; i >= 1; --i) {
		for (int j = n; j >= 1; --j) {
			a[i][j] = ___[i - 1][j - 1];
		}
	}
	for (int i = 1; i <= n; ++i)
		a[i][0] = a[i][n + 1] = a[0][i] = a[n + 1][i] = 1;
	for (int i = 0; i <= n + 1; ++i) {
		for (int j = 0; j <= n + 1; ++j) {
			if (a[i][j]) U[i][j] = i, L[i][j] = j;
			else U[i][j] = U[i - 1][j], L[i][j] = L[i][j - 1];
		}
	}
	for (int i = 0; i <= n + 1; ++i) {
		for (int j = n + 1; j >= 0; --j) {
			if (a[i][j]) R[i][j] = j;
			else R[i][j] = R[i][j + 1];
		}
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			if (a[i][j]) continue;
			dp[i - U[i][j]].push_back({i, j});
			ll[i][j] = i - U[i][j];
		}
	}
	int ans = 0;
	for (int len = 1; len <= n; ++len) {
		for (auto __ : dp[len]) {
			int r = __.first, x = __.second;
			if (a[r - 1][x]) {
				f[r][x] = R[r][x] - L[r][x] - 1;
				ans = max(ans, f[r][x]);
				continue;
			}
			f[r][x] = f[r - 1][x] +
				(min(R[r - 1][x], R[r][x]) - max(L[r - 1][x], L[r][x]) - 1);
			if (L[r - 1][x] > L[r][x]) {
				const auto upd = f[r][L[r - 1][x]] + 
					(U[r][L[r - 1][x]] - U[r][x]) * 
					(min(R[r - 1][x], R[r][x]) - L[r - 1][x] - 1);
				f[r][x] = max(f[r][x], upd);
			}
			if (R[r - 1][x] < R[r][x]) {
				const auto upd = f[r][R[r - 1][x]] +
					(U[r][R[r - 1][x]] - U[r][x]) *
					(R[r - 1][x] - max(L[r - 1][x], L[r][x]) - 1);
				f[r][x] = max(f[r][x], upd);
			}
			R[r][x] = min(R[r - 1][x], R[r][x]);
			L[r][x] = max(L[r - 1][x], L[r][x]);
			ans = max(ans, f[r][x]);
		}
	}
	return ans;
}
```



---

## 作者：OptimisticForever (赞：6)

考虑最后图形的性质，一定是类似一个菱形，而且限制更紧。

把每一行的区间取出来，按长度排序，必须满足大的包含小的，否则不合法。

由此，考虑 dp，设 $f_{u,d,l,r}$ 表示目前填了 $[u,d]$ 行，其中，限制最紧的区间为 $[l,r]$。

每次可以从 $(u+1,d),(u,d-1)$ 转移过来。

容易发现，当我们确定了一个列 $x$，满足 $l\leq x\leq r$。即保证我们填的位置一定包含 $x$，则可知，$l,r$ 的选择一定是满足条件中最大的那个。

所以，更改状态 $f_{u,d,x}$ 表示目前填了 $[u,d]$ 行，其中，一定包括 $x$ 这一列。由 $u,d,x$，我们可以算出目前的限制 $l,r$，所以可以直接转移，时间复杂度 $O(n^3)$。

接下来就很神奇了，观察到，对于一个 $d$ 和 $x$，其只对应唯一一个 $u$，为有效状态。这个 $u$ 很好算出来，就是 $(d,x)$ 这个位置向上的第一个障碍的下面一个格子。

于是，我们对应每个 $(d,x)$ 维护 $f_{d,x}$，类似上面的定义。

然后再维护 $L_{d,x},R_{d,x}$ 分别表示目前的 $l,r$ 限制。

转移有三种：

- 第一种就是直接从 $f_{d-1,x}$ 转移过来，需要满足上面这个位置不是障碍。

- 第二种我们考虑把 $f_{d,L_{d-1,x}}$ 转移过来，具体的，如下图：
 
  ![](https://cdn.luogu.com.cn/upload/image_hosting/pcj4h2pz.png)

  其中红色的列表示 $x$，橙色的列表示 $L_{d-1,x}$，那么 $f_{d,L_{d-1,x}}$ 表示蓝色框框，那么转移的贡献就是绿色框框。

- 第三种与第二种类似，就是从 $f_{d,R_{d-1,x}}$ 转移过来，贡献类似。

总时间复杂度 $O(n^2)$。

---

## 作者：tribool4_in (赞：6)

极妙的优化。

首先规则的球场一定形如若干个横向区间不断缩小、竖向区间不断扩张的矩形并。

设一些辅助数组，$lp_{i,j}$ 表示 $(i,j)$ 左侧第一个障碍位置，$rp_{i,j}$ 和 $up_{i,j}$ 同理。

然后容易设出 $dp_{i,j,x}$ 表示当前行区间为 $[i,j]$（仅包含第 $i$ 行到第 $j$ 行之间的位置），钦定包含第 $x$ 列的所有位置（用于限制）。转移是容易的，分别记录范围内最窄的左右位置 $l$ 和 $r$。转移过程形如从中间最宽的一行逐渐向上下两侧扩展，横向区间 $[l,r]$ 不断缩小。

考虑优化，发现对于一个状态 $dp_{i,j,x}$，如果 $(i-1,x)$ 没有障碍，则其一定不是最优的。因此对于一对 $(j,x)$ 可能为答案的 $i$ 只有该位置向上的连续最后一个空格，即 $i=up_{j,x}-1$。于是大胆地考虑砍掉第一维，直接对于 $dp_{j,x}$ 转移。

于是得出第一种转移：$dp_{j,x}=dp_{j-1,x}+(\min_k(rp_{k,x})-\max_k(lp_{k,x})-1)$，其中后半部分在转移过程中容易动态维护。

发现这样如果直接按照之前的转移，会出现问题。考虑由 $j-1$ 转移到 $j$，由于 $[i,j-1]$ 这些行的轮廓甚至可能是凸的，我们只能记录这些范围的最窄宽度（$\min_k(rp_{k,x})-\max_k(lp_{k,x})-1$），而难以得出当前行哪些范围是合法的。不妨先考虑左侧（右侧同理），如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1x23luhd.png)

由于 $\max(lp_2)=1$，在 $dp_{3,x(x\ge 2)}$ 中红色格子不会被计算，但是包含红色格子显然更优。

此时考虑如何加入红色格子，可以发现在 $dp_{3,1}$ 中包含了红色格子。形式化的，对于 $dp_{j,x}$ 发现位于 $(j,\max(lp_x))$ 及其左侧的格子可能不会被计入，但在 $dp_{j,\max(lp_x)}$ 中有包含。于是考虑第二种转移，取 $dp_{j,\max(lp_x)}$ 进行转移。考虑 $dp_{j,\max(lp_x)}$ 包含的范围：

![](https://cdn.luogu.com.cn/upload/image_hosting/g20hn5dv.png)

此时发现上边的紫色不会被包含（因为 $up_{3,1}=0$）。然而由于此时 $\max(lp_2)$ 已经是最紧的了，$dp_{3,x(x\ge 2)}$ 与 $dp_{3,1}$ 所差的范围一定是一个矩形。形式化的，$dp_{j,x}$ 与 $dp_{j,\max(lp_x)}$ 相差的矩形面积为 $(up_{j,\max(lp_x)}-up_{j,x})(\min(rp_x)-\max(lp_x)-1)$（后半部分即最窄宽度）。

于是得出第二种转移：$dp_{j,x}=dp_{j,\max_k(lp_{k,x})}+(up_{j,\max(lp_x)}-up_{j,x})(\min_k(rp_{k,x})-\max_k(lp_{k,x})-1)$。右侧同理。

至于 $(j,\max(lp_x))$ 左侧的格子怎么处理？可以发现，这些格子会在 $dp_{j,\max(lp_x)}$ 进行第二种时被处理。于是做完了。

另外还有转移的拓扑序。考虑令一个状态的 $len=j-up_{j,x}$（即其行区间），容易发现所有转移均为从 $len$ 小的转移到 $len$ 大的状态。于是按照 $len$ 为拓扑序即可。

```cpp
// #include "soccer.h"
#include <bits/stdc++.h>
using namespace std;
const int N = 2e3 + 10;
int n, a[N][N], lp[N][N], rp[N][N], up[N][N];
int dp[N][N];
vector<pair<int, int>> sta[N];

int biggest_stadium(int N, vector<vector<int>> F) {
    n = N;
    fill(&a[0][0], &a[n + 2][0], 1);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) a[i][j] = F[i - 1][j - 1];
    for (int i = 0; i <= n + 1; i++) {
        for (int j = 0; j <= n + 1; j++) {
            if (a[i][j]) lp[i][j] = j, up[i][j] = i;
            else lp[i][j] = lp[i][j - 1], up[i][j] = up[i - 1][j];
        }
        for (int j = n + 1; j >= 0; j--) {
            if (a[i][j]) rp[i][j] = j;
            else rp[i][j] = rp[i][j + 1];
        }
        for (int j = 1; j <= n; j++) {
            if (a[i][j]) continue;
            sta[i - up[i][j]].emplace_back(i, j);
        }
    }

    int lslakioi = 0;
    for (int len = 1; len <= n; len++) {
        for (auto [i, j] : sta[len]) {
            if (a[i - 1][j]) {
                dp[i][j] = rp[i][j] - lp[i][j] - 1;
            } else {
                lp[i][j] = max(lp[i][j], lp[i - 1][j]), rp[i][j] = min(rp[i][j], rp[i - 1][j]);
                dp[i][j] = dp[i - 1][j] + (rp[i][j] - lp[i][j] - 1);
                int vl = dp[i][lp[i - 1][j]] + (up[i][lp[i - 1][j]] - up[i][j]) * (rp[i][j] - lp[i][j] - 1);
                int vr = dp[i][rp[i - 1][j]] + (up[i][rp[i - 1][j]] - up[i][j]) * (rp[i][j] - lp[i][j] - 1);
                dp[i][j] = max(dp[i][j], max(vl, vr));
            }
            lslakioi = max(lslakioi, dp[i][j]);
        }
    }
    return lslakioi;
}
```

---

## 作者：pikiuk (赞：4)

考虑描述一种合法方案，一种显然的描述是：

- 足球场构成的轮廓线必须是封闭且是凸的。
- 每行选出格子构成一个区间，且任意两行选出的区间必须是包含关系。

显然，这个条件的形式并不简洁，我们考虑这么分析：

![Snipaste_2023-09-21_11-20-24.png](https://img.macesuted.moe/696d81cf11f366d9e92d7ef5ae63243a/f09466557684d.png)

例如这是一个合法的方案，那么我们可以把他看成红色矩形和绿色矩形面积的并。也就是我们最开始有一个矩形，然后他的宽度不断缩小，长度不断增加，变化过程中的所有矩形面积并起来就是一个足球场的合法方案。

由此，我们不难设计如下状态：记 $f(l,r,x)$ 表示现在的矩形所处的行区间是 $[x,y]$，他的左边界在列 $x$ 上。注意到左边界一旦确定，右边界一定越远越好，因此状态是唯一的，视实现可以做到 $\mathcal{O}(n^3\log n)$ 或者 $\mathcal{O}(n^3)$。

考虑直接分析整个轮廓线，同时维护长度最小高度最高的矩形（即覆盖行区间最多的矩形，例如上图的红色矩形）。注意到我们可以用轮廓线最下面的行的某个点来描述唯一的轮廓线，记当前点为 $(x,y)$，对应轮廓线面积为 $f(x,y)$，最内层矩形的左右边界为 $L(x,y)$ 和 $R(x,y)$，轮廓线上边界（也是最内层矩形的上边界）为 $U(x,y)$，$U(x,y)$ 一定是 $x$ 一直向上走所能走到的最远点位置。

考察转移，$(x,y)$ 应从 $(x-1,y)$ 转移而来，分析几种情况：

- 特殊情况：$(x-1,y)$ 是树，那么直接把这行尽可能取满。

- 内层矩形的左端点小于这个点向右所能到达的最远位置（如上图第 $1$ 行到第 $2$ 行的转移）：
  - ![Snipaste_2023-09-21_11-35-43.png](https://img.macesuted.moe/4bc00b3b03fe01cdb6a3ef5abb9a241c/78bdec083731e.png)
  - 我们可以把他看作红色格子（$(x,L(x-1,y))$）的答案加上绿色区域的面积。
- 内层矩形的左端点大于这个点向右能达到的最远距离（如上图第 $2$ 到第 $3$ 行的转移）：直接加上这一行的贡献，并更新对应的内层矩形即可。
- 右端点的讨论和左端点是对称的，可以自行分析。

注意到我们按 $U(x,y)-y$ 的顺序转移就可以维护上述过程，因此我们在 $\mathcal{O}(n^2)$ 的时间复杂度内解决了本题。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 2e3 + 7;

int U[N][N], L[N][N], R[N][N], f[N][N], a[N][N], n, ans; vector<pair<int, int> > vec[N];

int biggest_stadium(int Num, std::vector<std::vector<int>> F) {
    n = Num; 
    for (int i = 1; i <= n; i ++) {
    	for (int j = 1; j <= n; j ++) {
    		a[i][j] = F[i - 1][j - 1];
		}
	}
	for (int i = 0; i <= n + 1; i ++) 
		a[0][i] = a[i][0] = a[n + 1][i] = a[i][n + 1] = 1;
	for (int j = 1; j <= n; j ++) {
		for (int i = 0; i <= n; i ++) {
			if (a[i][j]) U[i][j] = i;
			else U[i][j] = U[i - 1][j];
		}
	}
	for (int i = 1; i <= n; i ++) {
		for (int j = 0; j <= n; j ++) {
			if (a[i][j]) L[i][j] = j;
			else L[i][j] = L[i][j - 1];
		}
		for (int j = n + 1; j; j --) {
			if (a[i][j]) R[i][j] = j;
			else R[i][j] = R[i][j + 1];
		}
	}
	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= n; j ++) {
			vec[i - U[i][j]].emplace_back (i, j);
		}
	}
	for (int id = 1; id <= n; id ++) {
		for (auto [x, y] : vec[id]) {
			if (U[x][y] == x - 1) {
				f[x][y] = R[x][y] - L[x][y] - 1;
				ans = max (ans, f[x][y]);
				continue;
			}
			int nL = max (L[x][y], L[x - 1][y]);
			int nR = min (R[x][y], R[x - 1][y]);
			f[x][y] = max (f[x][y], f[x - 1][y] + nR - nL - 1);
			if (nL > L[x][y]) {
				f[x][y] = max (f[x][y], f[x][nL] + (U[x][nL] - U[x][y]) * (nR - nL - 1));
			}
			if (nR < R[x][y]) {
				f[x][y] = max (f[x][y], f[x][nR] + (U[x][nR] - U[x][y]) * (nR - nL - 1));
			}
			L[x][y] = nL; R[x][y] = nR;
			ans = max (ans, f[x][y]);
		}
	}
	return ans;
} 
```



---

## 作者：Petit_Souris (赞：2)

最后一步很妙，难题。不过前 77.5 分还是能自己做的。

观察到合法的条件是，区间从大到小排了之后相邻的都满足包含关系，并且整个形状是凸的。

那么有个容易的 $\mathcal O(n^3)$ 做法：枚举一列 $y$ 使得每行选到的部分都包含 $y$。那么可以做一个简单的区间 dp：设 $dp_{l,r}$ 为 $[l, r]$ 行的答案，那么转移就是看向上还是向下，能选到的最大列区间就是看左边右边顶到哪里（包括已经覆盖的部分的障碍），所以是个前缀 $\min$ 状物，预处理一下就好了。拼上判定就有 77.5 分。

最后优化到 $\mathcal O(n^2)$ 非常牛。我们首先需要观察到有用的三元组 $(l, r, y)$ 只有 $\mathcal O(n^2)$ 个。因为在固定了 $r, y$ 之后，$l$ 只会取极长的那个。因此可以把状态压掉一位，变成 $dp_{r,y}$。

但是这样可能会损失转移的性质，不过我们还是来试试看。首先可以 $r$ 这样单走，也就是找到左右端点，相当于在求 $[l,r]$ 的前缀 $\min , \max$。

但是我们发现漏了一些东西。我们前面 dp 成立的原因是可以在 $l$ 较松的时候先把大区间取进来，而新的状态损失了这种性质。但是我们可以通过强行转移 $y$ 来实现这一点。

具体来说，看 $(r,y)$ 顶到的左右的障碍物，我们只需要考察 $(r, pre)$ 和 $(r,nxt)$ 这两个状态就行了，因为这两个状态已经到达了最松的情况，低下一个大的矩形都是能取到的。因此直接转移就行了，复杂度 $\mathcal O(n^2)$。

```cpp
#include "soccer.h"
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<ll, ll>
#define rep(i, a, b) for(int i = (a); i <= (b); ++i)
#define per(i, a, b) for(int i = (a); i >= (b); --i)
#define pb push_back
const int maxN = 2009;
int dp[maxN][maxN], pre[maxN][maxN], nxt[maxN][maxN];
int up[maxN][maxN];
int maxpre[maxN][maxN], minnxt[maxN][maxN];
Ve<pii> bin[maxN];
bool a[maxN][maxN];
int biggest_stadium(int N, Ve<Ve<int> > F) {
    rep(i, 0, N + 1) {
        rep(j, 0, N + 1) a[i][j] = 1;
    }
    rep(i, 1, N) {
        rep(j, 1, N) a[i][j] = F[i - 1][j - 1];
    }
    rep(i, 0, N + 1) {
        rep(j, 0, N + 1) {
            if(a[i][j]) up[i][j] = i;
            else up[i][j] = up[i - 1][j];
            if(a[i][j]) pre[i][j] = j;
            else pre[i][j] = pre[i][j - 1];
        }
        per(j, N + 1, 0) {
            if(a[i][j]) nxt[i][j] = j;
            else nxt[i][j] = nxt[i][j + 1];
        }
        rep(j, 0, N + 1) {
            maxpre[i][j] = pre[i][j], minnxt[i][j] = nxt[i][j];
            if(!a[i][j]) bin[i - up[i][j]].pb({i, j});
        }
    }
    int ans = 0;
    rep(rd, 0, N + 1) {
        for(auto [i, j] : bin[rd]) {
            if(a[i - 1][j]) {
                dp[i][j] = nxt[i][j] - pre[i][j] - 1;
                ans = max(ans, dp[i][j]);
                continue;
            }
            maxpre[i][j] = max(maxpre[i][j], maxpre[i - 1][j]);
            minnxt[i][j] = min(minnxt[i][j], minnxt[i - 1][j]);
            dp[i][j] = dp[i - 1][j] + minnxt[i][j] - maxpre[i][j] - 1;
            dp[i][j] = max(dp[i][j], dp[i][maxpre[i - 1][j]] + (minnxt[i][j] - maxpre[i][j] - 1) * (up[i][maxpre[i - 1][j]] - up[i][j]));
            dp[i][j] = max(dp[i][j], dp[i][minnxt[i - 1][j]] + (minnxt[i][j] - maxpre[i][j] - 1) * (up[i][minnxt[i - 1][j]] - up[i][j]));
            ans = max(ans, dp[i][j]);
        }
    }
    return ans;
}
```

---

## 作者：xieziheng (赞：2)

事实证明，这道题确实可以直接随机化过。

首先显然足球场是连通的，且任意一行一列都是连续的。

我开始以为只要球场是凸的就行，后来发现所有区间还都要互相有包含关系。好像这也是显然的。

然后可以非常暴力的 dp：记 $f_{l,r,i,j}$，表示在行 $[l,r]$ 间，列区间为 $[i,j]$ 的面积最大值。转移就是让行扩张，列缩减，转移到 $f_{l-1,r,x,y},f_{l,r+1,x,y}$，$[x,y] \in [i,j]$。这样可以保证每次新增的两端区间都是原来区间的子区间。而且区间长度是单峰的。

但是这是 $\mathcal{O}(n^6)$ 的，太慢了。

注意到行区间固定时列一定是极大的，所以可以去掉一维。可以直接枚举一定过的列，然后设 $f_{l,r}$ 表示行区间为 $[l,r]$ 时的最大面积，可以预处理出此时最大的列区间。

这是 $\mathcal{O}(n^3)$ 的。

然后注意到最大的区间大概在 $\frac n 2$ 附近。

为了防止数据卡可以设定枚举的前 $100$ 列在 $\frac n 2$ 附近，之后的在其余列中随机，多交几遍就过了。

```cpp
#include <bits/stdc++.h>
#define il inline
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
il void cmin(int &x,int y){x=x<y?x:y;}
il void cmax(int &x,int y){x=x>y?x:y;}
const int N=2005,inf=1e9;
int a[N][N],l[N][N],r[N][N],u[N][N],f[N][N],ans,p[N];
int biggest_stadium(int n,vector<vector<int> > F){
    int x,y,z;
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) a[i+1][j+1]=F[i][j];
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j) l[i][j]=(a[i][j]?j:l[i][j-1]);
        r[i][n+1]=n+1;
        for(int j=n;j;--j) r[i][j]=(a[i][j]?j:r[i][j+1]);
    }
    for(int j=1;j<=n;++j) for(int i=1;i<=n;++i) u[i][j]=(a[i][j]?i:u[i-1][j]);
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if(!a[i][j]) cmax(ans,max(j-l[i][j],i-u[i][j]));
    x=y=(n+1)>>1,p[1]=x;
    for(int i=2;i<=n;++i){
        if((i&1) && x>1) --x,p[i]=x;
        else if(!(i&1) && y<n) ++y,p[i]=y;
        else{
            if(x>1) p[i]=--x;
            else p[i]=++y;
        }
    }
    mt19937_64 rnd(time(0));
    if(n>100) shuffle(p+101,p+1+n,rnd);
    for(int tt=1,t;tt<=n;++tt){
        t=p[tt];
        for(int i=1;i<=n;++i){
            if(!a[i][t]) f[i][i]=r[i][t]-l[i][t]-1;
            else f[i][i]=0;
        }
        for(int i=n-1;i;--i){
            if(a[i][t]) continue;
            x=l[i][t]+1,y=r[i][t]-1;
            for(int j=i+1;j<=n;++j){
                cmax(x,l[j][t]+1),cmin(y,r[j][t]-1);
                if(x<=y) f[i][j]=max(f[i+1][j],f[i][j-1])+y-x+1,cmax(ans,f[i][j]);
                else break;
            }
        }
        if(clock()>=3470000) return ans;
    }
    return ans;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P9602)

**题目大意**

> 给定 $n\times n$ 矩阵，有些位置不能选择，选出最大的子集，使得任意两个格子可以通过 $\le 1$ 次转弯互相到达。
>
> 数据范围：$n\le 2000$。

**思路分析**

观察一下可能的点集，容易发现任意两行都有包含关系，并且每行的大小是单峰的。

那么我们可以用 $f_{l,r,u,d}$ 表示 $[l,r]$ 行，最窄的一行为 $[u,d]$。

转移时加入 $l-1/r+1$ 行，转移到 $[u,d]$ 范围内某个连续的可选择的区间。

注意到 $[u,d]$ 可以用任意 $x\in [u,d]$ 描述，此时的 $[u,d]$ 就是 $[l,r]$ 的每一行中 $x$ 所在连续段的交。

进一步可以把 $l$ 也优化掉，即有意义的 $l$ 一定是 $(r,x)$ 所在的列连续段的首行。

枚举 $(r,x)$，算出 $[u,d]$，如果向下转移，直接从 $f_{r-1,x}+d-u+1$ 转移。

如果向上转移，那么 $[u,d]$ 在第 $l$ 行，那么找到一个包含 $[u,d]$ 的状态，那么就是从 $f_{r,u-1}$ 或 $f_{r,d+1}$ 转移，算出哪些行的宽度为 $[u,d]$ 并转移即可。

预处理每个 $(r,x)$ 对应的 $r-l$，按此排序处理所有状态即可。

时间复杂度 $\mathcal O(n^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "soccer.h"
using namespace std;
const int MAXN=2005;
int L[MAXN][MAXN],R[MAXN][MAXN],h[MAXN][MAXN],f[MAXN][MAXN];
vector <array<int,2>> o[MAXN];
int biggest_stadium(int n,vector<vector<int>>a) {
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=n;++j) {
			if(a[i-1][j-1]) h[i][j]=i,L[i][j]=R[i][j]=j;
			else h[i][j]=h[i-1][j],L[i][j]=L[i][j-1],o[i-h[i][j]].push_back({i,j});
		}
		R[i][n+1]=n+1;
		for(int j=n;j;--j) if(!R[i][j]) R[i][j]=R[i][j+1];
	}
	int ans=0;
	for(int e=1;e<=n;++e) for(auto u:o[e]) {
		int i=u[0],j=u[1];
		if(e>1) L[i][j]=max(L[i-1][j],L[i][j]),R[i][j]=min(R[i-1][j],R[i][j]);
		int d=R[i][j]-L[i][j]-1;
		f[i][j]=f[i-1][j]+d;
		if(L[i][j]>=1) f[i][j]=max(f[i][j],f[i][L[i][j]]+d*(h[i][L[i][j]]-h[i][j]));
		if(R[i][j]<=n) f[i][j]=max(f[i][j],f[i][R[i][j]]+d*(h[i][R[i][j]]-h[i][j]));
		ans=max(ans,f[i][j]);
	}
	return ans;
}
```

---

## 作者：Purslane (赞：0)

# Solution

首先找一个场地合法的充要条件。直接给出结论：

场地合法，当且仅当每一行和每一列都是连续的，且任意两行或任意两列选的点构成的集合有包含关系。

考虑找出最长的列。列显然会往上下扩展直到碰到了顶点。

这时候显然贪心将这一列往左右扩展最优。

这样我们得到了一个矩形。这时候就可以缩短上下边界，然后继续往左右扩展。我们在 DP 状态中记录这个矩形，对应的值为将这个矩形缩短后进行扩展，最多还能得到多少个格子。

这样状态数都能高达 $O(n^4)$，更不用说转移了。

首先是对状态进行限制。发现这个矩形的四个端点外一定紧邻这障碍点。下面证明：这样的矩形个数为 $O(n^2)$。

考虑钦定左边界，和右边界外紧邻的某一个点。发现确定这两个信息之后，上下边界是唯一的。而 $\rm (left \ boundary,right\ point)$ 对应的二元组只有 $O(n^2)$ 个，所以状态数为 $O(n^2)$。

在证明的过程中，你发现——并不需要四个方向都紧邻障碍点。只需要保证三个边紧邻障碍点即可！

考虑转移。由于上下界是自动确定的，我们只需要考虑让左边界向左移动，或者右边界向右移动。

向左移动是简单的，直接让左边界减一即可。（每个位置的前驱状态只有 $O(1)$ 个）

向右移动：注意到最优状态下，往右延伸一列，这一列并不能向上或者向下扩展。那么上下边界一定要么和原来的边界相同，要么被这一列的两个障碍限制住。两者的总方案数依然为 $O(n^2)$。

回顾这道题，其优化方法本质上很简单：只在有用的 DP 状态处计算答案。并且适当放宽一些性质（保证状态数仍然不多），使得转移变得更加容易。

代码：

```cpp
#include<bits/stdc++.h>
#include "soccer.h"
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2000+10;
int n,tot,len[MAXN*MAXN],px[MAXN*MAXN],py[MAXN*MAXN];

int shang[MAXN][MAXN],xia[MAXN][MAXN],dp[MAXN*MAXN],id[MAXN][MAXN],up[MAXN][MAXN],xp[MAXN][MAXN],rp[MAXN][MAXN],f[MAXN][MAXN]; 
int usuf[MAXN][MAXN],dsuf[MAXN][MAXN];

pair<int,int> rpre[MAXN][MAXN],rsuf[MAXN][MAXN];
int solve(void) {
	roff(i,n,1) roff(j,n,1) 
		if(f[i][j]) rp[i][j]=j;
		else rp[i][j]=rp[i][j+1];	
	ffor(i,1,n) ffor(j,1,n) 
		if(f[i][j]) shang[i][j]=i;
		else shang[i][j]=shang[i-1][j];	
	roff(i,n,1) ffor(j,1,n) 
		if(f[i][j]) xia[i][j]=i;
		else xia[i][j]=xia[i+1][j];	
	roff(i,n,1) ffor(j,1,n) 
		if(f[i][j]) rsuf[i][j]={n+1,i};
		else rsuf[i][j]=min(rsuf[i+1][j],{rp[i][j],i});	
	ffor(i,1,n) ffor(j,1,n) 
		if(f[i][j]) rpre[i][j]={n+1,i};
		else rpre[i][j]=min(rpre[i-1][j],{rp[i][j],i});
	ffor(i,1,n) roff(j,n,1) 
		if(f[i][j]) up[i][j]=1;
		else up[i][j]=max(shang[i][j]+1,up[i][j+1]);
	roff(i,n,1) roff(j,n,1) 
		if(f[i][j]) xp[i][j]=n+1;
		else xp[i][j]=min(xia[i][j]-1,xp[i][j+1]);
	int ans=0;
	vector<int> pos;
	ffor(i,1,n) ffor(j,1,n) if(!f[i][j]) {
		int shang_bd=up[i][j],xia_bd=xp[i][j];
		int nj=rp[i][j],ni=shang[i-1][nj];
		if(ni<shang_bd) ++tot,len[tot]=nj-j+1,px[tot]=i,py[tot]=j,id[i][j]=tot;
		else id[i][j]=id[ni][j];
	}
	ffor(i,1,tot) pos.push_back(i);
	sort(pos.begin(),pos.end(),[&](int x,int y) {return len[x]>len[y];});
	for(auto rid:pos) {
		int x=px[rid],y=py[rid],shang_bd=up[x][y],xia_bd=xp[x][y],r=rp[x][y];
		vector<int> pos;
		pos.push_back(x);
		int tmp=xia[x+1][r];
		while(tmp<=xia_bd) pos.push_back(tmp),tmp=xia[tmp+1][r];
		if(pos[0]!=shang_bd) {
			int ni=rsuf[shang_bd][r].second;
			int nj=rp[ni][y],nshang=up[ni][y],nxia=xp[ni][y];
			dp[rid]=max(dp[rid],dp[id[ni][y]]+(nxia-nshang+1)*(nj-r));
		}
		if(pos[pos.size()-1]!=xia_bd) {
			int ni=rpre[xia_bd][r].second;
			int nj=rp[ni][y],nshang=up[ni][y],nxia=xp[ni][y];
			dp[rid]=max(dp[rid],dp[id[ni][y]]+(nxia-nshang+1)*(nj-r));
		}
		ffor(i,1,(int)pos.size()-1) if(pos[i]!=pos[i-1]+1) {
			int ni=rpre[pos[i]-1][r].second;	
			int nj=rp[ni][y],nshang=up[ni][y],nxia=xp[ni][y];
			dp[rid]=max(dp[rid],dp[id[ni][y]]+(nxia-nshang+1)*(nj-r));
		}
		if(!f[x][y+1]) dp[id[x][y+1]]=max(dp[id[x][y+1]],dp[rid]+xia_bd-shang_bd+1);
		ans=max(ans,dp[rid]+(r-y)*(xia_bd-shang_bd+1));
	}
	return ans;
}
int biggest_stadium(int N,vector<vector<int>> F) {
	n=N+2;
	ffor(i,1,n) ffor(j,1,n) {
		if(i==1||j==1||i==n||j==n) f[i][j]=1;
		else f[i][j]=F[i-2][j-2];
	}
	return solve();
}
```

---

## 作者：Leasier (赞：0)

考虑一种方案合法的条件：只有一个连通块且其是凸的，或者说其由若干行区间缩小的同时列区间增长的矩形取并所得。

我们首先有一个~~惊为天人的~~ $O(n^6)$ dp：

- 设 $dp_{l_1, r_1, l_2, r_2}$ 表示到目前为止行区间为 $[l_1, r_1]$、列区间为 $[l_2, r_2]$ 时连通块大小最大值。
- 枚举 $[l_1', r_1'] \subset [l_1, r_1]$ 和 $[l_2, r_2] \subset [l_2', r_2']$ 转移即可。

考虑首先来减少状态。手模几组样例可以注意到**选择合法的情况下尽可能大**的 $r_2$ 一定不劣，又想到我们没有必要**枚举子区间**。于是可以优化到 $O(n^3)$：

- 改设 $dp_{l_1, r_1, l_2} = (r_2, size)$ 表示最大的 $r_2$ 和最大的连通块大小。
- 只枚举 $[l_1', r_1'] = [l_1, r_1 - 1], [l_1 + 1, r_1]$ 和 $l_2' = l_2 + 1$ 转移即可。

至此转移变为 $O(1)$，考虑优化状态。

把左端点限制死了不便优化，考虑改设 $dp_{l_1, r_1, p} = (l_2, r_2, size)$ 表示钦定 $p \in [l_2, r_2]$ 时最小的 $l_2$、最大的 $r_2$ 和最大的连通块大小。暴力转移是类似的。

注意到若 $r_1, p$ 固定，我们一定会将 $l_1$ **尽可能多地减小**，使得期待的矩形 $[l_1, r_1], [l_2, r_2]$ 仍然合法。

于是考虑改设 $dp_{r_1, p} = (l_1, l_2, r_2, size)$（含义与前文类似，略去），至此状态减为 $O(n^2)$，考虑如何转移。

下设 $L_{i, j}$ 表示 $(i, j)$ 左侧首个有障碍的列号，$R_{i, j}$ 表示 $(i, j)$ 右侧首个有障碍的列号，$up_{i, j}$ 表示 $(i, j)$ 上方首个有障碍的行号。

一种简单的转移是在 $dp_{r_1 - 1, p}$ 的基础上加一列，此时转移为 $dp_{r_1, p} \leftarrow \max(dp_{r_1, p}, dp_{r_1 - 1, p} + len)$，其中 $len = \min(R_{i, j} - R_{i - 1, j}) - \max(L_{i, j} - L_{i - 1, j}) - 1$。

另一种转移是我们令 $r_1$ 为凸连通块中最宽的一行：

- 当 $L_{r_1, p} < L_{r_1 - 1, p}$，有转移 $dp_{r_1, p} \leftarrow \max(dp_{r_1, p}, dp_{r_1, L_{r_1 - 1, p}} + len (up_{r_1, L_{r_1 - 1, p}} - up_{r_1, p}))$。
- $R_{r_1, p} > R_{r_1 - 1, p}$ 的转移是对称的。

按 $i - up_{i, j}$ 的顺序转移即可。时间复杂度为 $O(n^2)$。

通过上面对转移的讨论，可以发现我们其实并不需要真的记录 $l_1, l_2, r_2$。

代码：
```cpp
#include <vector>

using namespace std;

int f[2007][2007], l[2007][2007], r[2007][2007], up[2007][2007], dp[2007][2007];
vector<pair<int, int> > v[2007];

int biggest_stadium(int n, vector<vector<int> > F){
	int ni = n + 1, ans = 0;
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			f[i][j] = F[i - 1][j - 1];
		}
	}
	for (int i = 1; i <= n; i++){
		f[0][i] = f[i][0] = f[i][ni] = 1;
	}
	for (int i = 1; i <= n; i++){
		l[0][i] = r[0][i] = i;
	}
	for (int i = 1; i <= n; i++){
		l[i][0] = 0;
		for (int j = 1; j <= n; j++){
			if (f[i][j] == 1){
				l[i][j] = j;
			} else {
				l[i][j] = l[i][j - 1];
			}
		}
		r[i][ni] = ni;
		for (int j = n; j >= 1; j--){
			if (f[i][j] == 1){
				r[i][j] = j;
			} else {
				r[i][j] = r[i][j + 1];
			}
		}
	}
	for (int i = 1; i <= n; i++){
		up[0][i] = 0;
	}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			if (f[i][j] == 1){
				up[i][j] = i;
			} else {
				up[i][j] = up[i - 1][j];
			}
		}
	}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			if (f[i][j] == 0) v[i - up[i][j]].push_back(make_pair(i, j));
		}
	}
	for (int i = 1; i <= n; i++){
		int size = v[i].size();
		for (int j = 0; j < size; j++){
			int x = v[i][j].first, y = v[i][j].second;
			if (i == 1){
				dp[x][y] = r[x][y] - l[x][y] - 1;
			} else {
				int len = min(r[x][y], r[x - 1][y]) - max(l[x][y], l[x - 1][y]) - 1;
				dp[x][y] = dp[x - 1][y] + len;
				if (l[x][y] < l[x - 1][y]){
					l[x][y] = l[x - 1][y];
					dp[x][y] = max(dp[x][y], dp[x][l[x - 1][y]] + len * (up[x][l[x - 1][y]] - up[x][y]));
				}
				if (r[x][y] > r[x - 1][y]){
					r[x][y] = r[x - 1][y];
					dp[x][y] = max(dp[x][y], dp[x][r[x - 1][y]] + len * (up[x][r[x - 1][y]] - up[x][y]));
				}
			}
		}
	}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			if (f[i][j] == 0) ans = max(ans, dp[i][j]);
		}
	}
    return ans;
}
```

---


# 『SpOI - R1』我看到了，谢谢你们

## 题目描述

**本题包含多组测试。**

**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**

有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。

令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。

得票数量**严格**超过总票数一半的人可以当选总统。

初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：

1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。
2. 进行一次**对 $v$ 揽票**操作：
	- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。
	- $\forall j\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。
3. 等待下一个时刻。

每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。

你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。

票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。

每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。

在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。

可以证明一定存在这样的人。

本题**强制在线**。

## 说明/提示

#### 样例 #1 解释

对于第一组数据：

考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。

干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。

第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。

干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。

对于第三组数据，去掉强制在线后的修改操作为：

- $o=2,p=3,x=5$；
- $o=1,p=5,x=100$；
- $o=1,p=5,x=1$；
- $o=2,p=1,x=-8$；
- $o=2,p=5,x=0$；
- $o=1,p=2,x=4$。

### 数据范围

**请注意常数因子对程序效率的影响。**

**本题开启子任务捆绑与子任务依赖。**

对于 $100\%$ 的数据，$1\leq T\leq 2000$，$1\leq n\leq 10^5$，$0\leq q\leq 10^5$，$0\leq type\leq 1$，且在任何时候都保证 $1\leq a_i\leq 2\times 10^9$，$|w_i|\leq 2\times 10^9$。

保证字符串中只含有小写字母。

对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\leq p\leq n$。在 $o=1$ 时，$1\leq x\leq 2\times 10^9$；$o=2$ 时，$0\leq |x|\leq 2\times 10^9$。

特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。

| Subtask | $T\leq$ | $n,q\leq$ | $a_i,\lvert w_i\rvert \leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |
| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |
| 3 | $3$ | $10^5$ | $2\times 10^9$ | $A$ | $15$ | 无 |
| 4 | $3$ | $10^5$ | $2\times 10^9$ | $B$ | $5$ | 无 |
| 5 | $3$ | $10^5$ | $2\times 10^9$ | $C$ | $15$ | 无 |
| 6 | $3$ | $10^5$ | $2\times 10^9$ | $D$ | $20$ | 无 |
| 7 | $3$ | $10^5$ | $2\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |

特殊性质 $A$：保证 $o\neq 2$。

特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。

特殊性质 $C$：字符串中只含有 $\texttt{a}$。

特殊性质 $D$：保证 $type=0$。

## 样例 #1

### 输入

```
3
2 1 0
aa
6 1
2 -1
3 2
1 0 2
19 0 0
happythbirthdayshun
1000000000 8
1000000000 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 1
1 0
1 0
5 6 1
acbac
1 3
2 4
1 -5
3 6
2 -3
3 1
11 10 12
9 13 108
8 12 8
10 9 0
6 1 4
4 7 1```

### 输出

```
1
0
17
9
8
-9
8
-4
-5
-5```

# 题解

## 作者：Shunpower (赞：5)

出题人题解。

大型套皮诈骗题。~~其实字符串的皮是方便给一些抽象的部分分~~

观察到和一个前缀的所有 border 相关，考虑建立 fail 树。对 $nxt_i\to i$ 连有向边得到一棵以 $0$ 为根的外向树。那么操作二就可以转化为：

- 花费 $w_i$ 选中一个人 $v$，需要满足 $v$ 在 $i$ 子树内。
- 若 $j$ 在 $v$ 子树内且 $j$ **未被控制**，则 $j$ 变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。

接下来需要注意到的是总统是可能不止一位的，因为交叉票可以分裂。但是我们只需要让我们选中的人成为其中一位就行了。

考虑干涉完之后剩下的人会干什么。可以发现，由于所有人都不希望别人成为总统，且都绝顶聪明，那么在所有“不希望别人好”的决策下，最后这些人都一定会做二操作或者把全部票投给自己，总之你一开始找的 $x$ 根本得不到任何票。所以为了让 $x$ 成为总统，必须一来就锁定胜局，否则总统就会是其他人或者没有总统。

所以拆掉这个“博弈”皮，可以发现本质上就是要找一个人 $x$，满足他进行一次选择之后一定可以得到**严格**超过总票数一半的票。

考虑找的 $x$ 的票数。如果就他一个人都能占完所有票数的一半以上，那么考虑使用 $w_i$ 的花费让他自己投自己就行了。

否则就要在它子树内拿一个子子树，把那里面的票全部收集起来，然后占到所有票数的一半以上。注意此时 $x$ 的票可能并没有给自己。

考虑这样一个办法：我们把每个人的 $a_i$ 票展开成 $a_i$ 个 $1$，然后按照 fail 树上的 DFS 序进行展开，那么此时任何一个子树，如果包含严格大于一半的票数，就必然需要取到中间或中间两边的 $1$，因为子树在 DFS 序上是连续的，不取到，就一定不包含超过一半的票数。

使用线段树上二分就能在对 $a$ 带修的同时快速找出这一个或两个 $1$，并反推包含它们的那一个或两个点。如果需要同时包含两个点，我们可以取出它们的 LCA 看成是包含一个点（只需要包含 LCA）。

现在确定了关键点，那么我们所选的子子树就必须包含关键点，并且子树内要包含超过一半的票数。那么我们从关键点向上倍增到子树内包含一半以上票数的深度最低点，让这个点变成新的关键点。

那么子子树的根就一定是关键点的祖先或者本身。

所以问题转化为：已知关键点 $u$，求 $0\to u$ 的链上所有点 $v$，$v$ 子树 $w$ 和（这是 $v$ 子树的贡献）加上 $0\to v$ 最小 $w$ 的和的最小值（这是被找的人 $x$ 的贡献，显然 $x$ 的花费应当是 $0\to v$ 上的最小值最好）。

我们考虑一个树剖做法：

在线段树每个点上维护这三个值：该点的子树内 $w$ 和（下文称作 $v_1$ 变量），该点 $0$ 到自己的链上 $w$ 的最小值（下文称作 $v_2$ 变量），前两者的和（下文称作 $s$ 变量）。然后在表示区间的节点上维护三个东西的最小值。

每次修改一个点的 $w$ 时（注意修改单调不递增），对于它的所有祖先和自己而言，相当于给 $v_1$ 进行一个区间减（树剖后）。那么在线段树区间上，$s$ 也肯定都会相应地区间减。

而对于它的所有后代和自己（也就是自己的子树内）而言，相当于给 $v_2$ 进行一个区间 $\min$，那么我们可以直接在区间上进行区间 $\min$，然后修改掉两者的和即可。

然而这个做法直接写还不太对，问题出在区间 $\min$ 上。当 $v_2$ `pushup` 时，可能会出现不能享受到这个最小值的点享受到这个最小值了。所以线段树上任何一个区间的 $s$ 都必须来自于 `pushup`，不能用该区间上的 $v_1+v_2$ 重算，这就让我们很难受。

所以我们考虑如何能不维护线段树节点上的 $v_2$，但是维护 $s$。考虑对 $v_1$ 的区间减是可以直接维护的，主要问题就是对 $v_2$ 的区间 $\min$。我们注意到，由于修改单调不递增，所以每次修改都是一部分 $v_2$ 较大的会被推平，一部分 $v_2$ 较小的不变，$v_1$ 始终不变。

对于 $v_2$ 较大的部分，它们的 $v_2$ 最后都会变成一样的，那么对 $s$ 做贡献的就只有 $v_1$ 最小的那个数。

对于 $v_2$ 较小的部分，它们的 $s$ 不会变，并且如果把 $v_2$ 换成现在这个数答案会变大。换句话说，这一部分就贡献原 $s$。

那么我们容易考虑一个不合法不优。还是在线段树区间上维护最小 $v_1$ 和最小 $s$，假设将 $v_2$ 和 $x$ 取 $\min$，我们直接操作 $s\gets \min(s,v_1+x)$ 就是对的。

考虑分类讨论 $s$ 最小值和 $v_1$ 最小值所在的位置的 $v_2$ 与 $x$ 的大小关系可以发现确实做到不合法贡献不优了：

- 若最小 $s$ 所在位置的 $v_2\geq x$：
	- 若最小 $v_1$ 所在位置的 $v_2\geq x$，那么 $v_2\geq x$ 部分的贡献就是最小 $v_1$（$v_2$ 全部相同了），最小 $s$ 变为 $x+v_1$。易证明 $x+v_1$ 肯定小于等于原最小 $s$。 
   - 若最小 $v_1$ 所在位置的 $v_2<x$，那么整个 $v_2\geq x$ 部分的 $v_2$ 无论新旧都比那个位置的 $v_2$ 大，$v_1$ 也肯定比那个位置大。从而原来的最小 $s$ 一定在 $v_2<x$ 的部分。这与假设矛盾，所以不存在这种情况。
- 若最小 $s$ 所在位置的 $v_2<x$：
	- 若最小 $v_1$ 所在位置的 $v_2\geq x$，那么 $v_2\geq x$ 部分新的最小 $s$ 本来就是 $x+v_1$，$v_2<x$ 部分新的最小 $s$ 本来就是原来的最小 $s$，直接两者取 $\min$ 得到整个东西新的最小 $s$ 完全合理。
	- 若最小 $v_1$ 所在位置的 $v_2<x$，那么整个 $v_2\geq x$ 部分的 $v_2$ 无论新旧都比那个位置的 $v_2$ 大，$v_1$ 也肯定比那个位置大。从而原来的最小 $s$ 和现在的最小 $s$ 都一定在 $v_2<x$ 的部分，且 $v_1+x$ 一定不比原来的最小 $s$ 小。又由于 $v_2<x$ 的部分 $s$ 没有变化，所以最小 $s$ 仍然是原来的最小 $s$，并且直接取 $\min$ 没有问题。
    
结论得证。我们直接在线段树上维护区间最小 $v_1$，区间最小 $s$ 和区间推平标记即可。

容易做到单组数据复杂度 $\mathcal O(q\log ^2n)$，就是略微有点难写。下面是长达 8.5K 的 std：

```cpp
#include <bits/stdc++.h>
#define ET return 0
#define fi first
#define se second
#define mp make_pair
#define pb emplace_back
#define ll long long
#define ull unsigned long long
#define inf INT_MAX
#define uinf INT_MIN
#define pii pair<int,int>
#define pll pair<ll,ll>
#define debug puts("--------Chery AK IOI--------");
#define Yes cout<<"Yes"<<endl;
#define No cout<<"No"<<endl;
#define pt puts("")
#define fr1(i,a,b) for(int i=a;i<=b;i++)
#define fr2(i,a,b) for(int i=a;i>=b;i--)
#define fv(i,p) for(int i=0;i<p.size();i++)
#define ld long double
#define il inline
#define ptc putchar
// #define int ll
using namespace std;
const int N=1e5+10;
namespace Shun{
    int lowbit(int x){
        return x&-x;
    }
    template <typename T>
    inline void read(T &x){
       T s=0,w=1;
       char ch=getchar();
       while(ch<'0'||ch>'9'){
            if(ch=='-'){
                w=-1;
            }
            ch=getchar();
        }
       while(ch>='0'&&ch<='9'){
            s=s*10+ch-'0';
            ch=getchar();
       }
       x=s*w;
    }
    template <typename T>
    inline void write(T x){
        if(x<0){
            putchar('-');
            x=-x;
        }
        if(x>9){
            write(x/10);
        }
        putchar(x%10+'0');
    }
}
using namespace Shun;
int n,q;
char s[N];
int a[N],w[N];
ll sw[N];
ll minw[N];
int kmp[N];
int dfn[N],bac[N];
ll val[N];
int top[N],dep[N],siz[N],hson[N];//heavy-light link
int ft[N][20];
vector <int> p[N];
int tot;
ll all;
ll lst;
void dfs1(int x,int fa){
    minw[x]=min(minw[fa],(ll)w[x]);
    ft[x][0]=fa;
    siz[x]=1;
    dep[x]=dep[fa]+1;
    sw[x]=w[x];
    int idx=0;
    for(auto y:p[x]){
        if(y==fa) continue;
        dfs1(y,x);
        siz[x]+=siz[y];
        if(siz[y]>siz[idx]) idx=y;
        sw[x]+=sw[y];
    }
    hson[x]=idx;
}
void dfs2(int x,int tp,int fa){
    tot++;
    val[tot]=w[x];
    dfn[x]=tot,bac[tot]=x;
    top[x]=tp;
    if(hson[x]) dfs2(hson[x],tp,x);
    for(auto y:p[x]){
        if(y==fa||y==hson[x]) continue;
        dfs2(y,y,x);
    }
}
#define mid (l+r>>1)
struct sgtfora{
    ll sum[N<<2];
    il void pushup(int p){
        sum[p]=sum[p<<1]+sum[p<<1|1];
    }
    il void build(int p,int l,int r){
        if(l==r) return sum[p]=a[bac[l]],void();
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
        pushup(p);
    }
    il void insert(int p,int l,int r,int d,ll x){
        if(l==r) return sum[p]=x,void();
        if(d<=mid) insert(p<<1,l,mid,d,x);
        else insert(p<<1|1,mid+1,r,d,x);
        pushup(p);    
    }
    il int binary(int p,int l,int r,ll d){
        // cout<<p<<" "<<l<<" "<<r<<" "<<d<<" "<<sum[p]<<endl;
        if(l==r) return l;
        if(d<=sum[p<<1]) return binary(p<<1,l,mid,d);
        else return binary(p<<1|1,mid+1,r,d-sum[p<<1]);
    }
    il ll query(int p,int l,int r,int ml,int mr){
        // cout<<p<<" "<<l<<" "<<r<<" "<<ml<<" "<<mr<<endl;
        // system("pause");
        if(ml<=l&&r<=mr) return sum[p];
        ll ans=0;
        if(ml<=mid) ans+=query(p<<1,l,mid,ml,mr);
        if(mid<mr) ans+=query(p<<1|1,mid+1,r,ml,mr);
        return ans;
    }
} TA;
struct sgtforw{
    ll minn[N<<2],sumw[N<<2],sum[N<<2];
    ll lzy[N<<2][2];
    il void pushup(int p){
        // minn[p]=min(minn[p<<1],minn[p<<1|1]);
        sumw[p]=min(sumw[p<<1],sumw[p<<1|1]);
        sum[p]=min(sum[p<<1],sum[p<<1|1]);
    }
    il void pushdown(int p){
        if(lzy[p][0]){
            sumw[p<<1]-=lzy[p][0];
            sumw[p<<1|1]-=lzy[p][0];
            sum[p<<1]-=lzy[p][0];
            sum[p<<1|1]-=lzy[p][0];
            lzy[p<<1][0]+=lzy[p][0];
            lzy[p<<1|1][0]+=lzy[p][0];
            lzy[p][0]=0;
        }
        if(lzy[p][1]!=8e18){
            // minn[p<<1]=min(minn[p<<1],lzy[p][1]);
            // minn[p<<1|1]=min(minn[p<<1|1],lzy[p][1]);
            sum[p<<1]=min(sum[p<<1],sumw[p<<1]+lzy[p][1]);
            sum[p<<1|1]=min(sum[p<<1|1],sumw[p<<1|1]+lzy[p][1]);
            lzy[p<<1][1]=min(lzy[p<<1][1],lzy[p][1]);
            lzy[p<<1|1][1]=min(lzy[p<<1|1][1],lzy[p][1]);
            lzy[p][1]=8e18;
        }
    }
    il void build(int p,int l,int r){
        lzy[p][0]=0;
        lzy[p][1]=8e18;
        if(l==r){
            minn[p]=minw[bac[l]],sumw[p]=sw[bac[l]];
            sum[p]=minn[p]+sumw[p];
            // cout<<l<<":"<<sum[p]<<endl;
            return;
        }
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
        pushup(p);
    }
    il void modify(int p,int l,int r,int ml,int mr,int op,ll x){
        if(ml<=l&&r<=mr){
            if(op) sum[p]=min(sum[p],x+sumw[p]),lzy[p][1]=min(lzy[p][1],x);
            else sumw[p]+=x,sum[p]+=x,lzy[p][0]-=x;
            return;
        }
        pushdown(p);
        if(ml<=mid) modify(p<<1,l,mid,ml,mr,op,x);
        if(mid<mr) modify(p<<1|1,mid+1,r,ml,mr,op,x);
        pushup(p);
    }
    il ll query(int p,int l,int r,int ml,int mr){
        // cout<<l<<" "<<r<<":"<<sumw[p]<<" "<<minn[p]<<" "<<sum[p]<<endl;
        if(ml<=l&&r<=mr) return sum[p];
        ll ans=8e18;
        pushdown(p);
        if(ml<=mid) ans=min(ans,query(p<<1,l,mid,ml,mr));
        if(mid<mr) ans=min(ans,query(p<<1|1,mid+1,r,ml,mr));
        return ans;
    }
} TW;//维护(每个点的子树w和+根到自己的最小w)的最小值
#undef mid
int LCA(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    int k=dep[u]-dep[v];
    fr2(i,17,0){
        if(k>=(1<<i)) u=ft[u][i],k-=(1<<i);
    }
    if(u==v) return u;
    fr2(i,17,0){
        if(ft[u][i]!=ft[v][i]) u=ft[u][i],v=ft[v][i];
    }
    return ft[u][0];
}
void solve(){
    int st=-1;
    ll ans=8e18;
    all=TA.sum[1];
    if(all&1) st=bac[TA.binary(1,1,n,(all+1)/2)];
    else{
        int u=bac[TA.binary(1,1,n,all/2)];
        int v=bac[TA.binary(1,1,n,(all+1)/2)];
        st=LCA(u,v);
    }
    // st=v;
    // cout<<"!"<<all<<" "<<st<<endl;
    if(TA.query(1,1,n,dfn[st],dfn[st])>all/2) ans=w[st];
    // cout<<"???"<<endl;
    if(TA.query(1,1,n,dfn[st],dfn[st]+siz[st]-1)<=all/2){
        fr2(i,17,0){
            int ff=ft[st][i];
            // cout<<ff<<" "<<TA.query(1,1,n,dfn[ff],dfn[ff]+siz[ff]-1)<<endl;
            if(TA.query(1,1,n,dfn[ff],dfn[ff]+siz[ff]-1)<=all/2) st=ff;
        }
        st=ft[st][0];
    }
    // cout<<st<<" "<<dep[st]<<endl;
    ans=min(ans,TW.query(1,1,n,dfn[1],dfn[1]));
    while(st!=1){
        // cout<<st<<" "<<top[st]<<":"<<endl;
        ans=min(ans,TW.query(1,1,n,dfn[top[st]],dfn[st]));
        st=ft[top[st]][0];
    }
    cout<<ans<<'\n';
    lst=abs(ans);
}
void solvepertc(){
    bool type;
    cin>>n>>q>>type;
    fr1(i,1,n+1) p[i].clear();
    fr1(i,1,n+1) hson[i]=0;
    tot=0;
    s[n+1]=0;
    fr1(i,1,n) cin>>s[i];
    fr1(i,0,n) cin>>a[i+1]>>w[i+1];
    int j=0;
    fr1(i,2,n){
        while(j&&s[i]!=s[j+1]) j=kmp[j];
        if(s[i]==s[j+1]) j++;
        kmp[i]=j;
    }
    fr1(i,1,n) p[kmp[i]+1].pb(i+1);
    n++;//in [1,n+1]
    minw[1]=2e9;
    dfs1(1,1);
    dfs2(1,1,1);
    // fr1(i,1,n) cout<<dfn[i]<<' ';
    // cout<<'\n';
    fr1(j,1,17){
        fr1(i,1,n) ft[i][j]=ft[ft[i][j-1]][j-1];
    }
    TA.build(1,1,n);
    TW.build(1,1,n);
    solve();
    while(q--){
        ll op,p,x;
        cin>>op>>p>>x;
        op^=(type?lst:0);
        p^=(type?lst:0);
        ll nx=abs(x);
        nx^=(type?lst:0);
        nx*=(x>0?1ll:-1ll);
        x=nx;
        // cout<<op<<' '<<p<<' '<<x<<endl;
        // assert(op==1||op==2);
        // assert(p>=0&&p<=n);
        // assert(x>=-1000000000&&x<=1000000000);
        p++;
        if(op==1) TA.insert(1,1,n,dfn[p],x);
        else{
            // assert(w[p]>=x);
            TW.modify(1,1,n,dfn[p],dfn[p]+siz[p]-1,1,x);
            ll cgd=x-w[p];
            w[p]=x;
            // cout<<"!"<<cgd<<endl;
            if(p==1) TW.modify(1,1,n,dfn[1],dfn[1],0,cgd);
            while(p!=1){
                TW.modify(1,1,n,dfn[top[p]],dfn[p],0,cgd);
                if(top[p]!=1&&ft[top[p]][0]==1) TW.modify(1,1,n,dfn[1],dfn[1],0,cgd);
                p=ft[top[p]][0];
            }
        }
        solve();
    }
}
int main(){
    ios::sync_with_stdio(false);
    int tc;
    cin>>tc;
    while(tc--) solvepertc();
    ET;
}
//ALL FOR Zhang Junhao.
```

验题人也写了 5.24K。

------------

关于第六档的不强制在线：我们在验题过程中在这部分得到了一个基于操作分块的单组数据时间复杂度为 $\mathcal O(n^{\frac{4}{3}}\log^\frac{2}{3}n)$ 的算法，所以有了这个。

---

## 作者：是青白呀 (赞：4)

>青山是不会老的。

首先对原串建立失配树，根节点应当为空串。

对于一个人 $x$，若要确保他能够当总统，那么必须要控制拥有票数半数以上的人。$x$ 能控制的人显然是他的子树内的任意一个子子树，因此我们不妨找到树上 $a$ 的带权重心 $c$，可行的 $x$ 只有 $0$ 到 $c$ 的链上的所有点。

考虑如何维护带修带权重心。这是一个经典 trick：我们将每个点复制出权值那么多个，并拍到 dfs 序上去。由于该题中要求带权重心对应子树的权值和必须要严格大于总权值的一半，因此其子树在 dfs 序上的对应区间一定经过这个 dfs 序的中点。我们找到 dfs 序上 $\lceil \frac{\sum a_i}2\rceil$ 处的点 $p$，则带权重心 $c$ 一定是 $p$ 的首个子树对应区间长度大于等于  $\lceil \frac{\sum a_i}2\rceil$ 的祖先，使用倍增即可找到。用线段树二分的方式维护 $a$ 即可。

找到 $c$ 后，问题变为找一个 $0\to c$ 上的点 $x$，以及一个 $x\to c$ 上的点 $y$，最小化 $w_x+\sum_{v\in\operatorname{subtree}_y}w_v$ 的值。不妨将答案记录在点 $y$ 上。考虑在线段树上维护每个点子树的 $w$ 和 $sum$、以及该点作为 $y$ 时的答案 $ans$。一个点 $u$ 被改小时，会更新 $0\to u$ 上的子树和，同时给 $u$ 子树中的每个点提供了一个 $x$ 的可能更优的选择。因此对于链上的情况，我们树剖直接修改 $sum$ 和 $ans$；对于 $u$ 子树内的点，我们令 $ans=\min(ans,sum+w_u)$ 即可。这个东西同样可以打 tag 维护。

倍增和树剖的复杂度都是两个 $\log$，因此最终总复杂度为 $O((n+q)\log^2 n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define int long long
#define lowbit(i) i&-i
#define double long double
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=1e5+20,S=(1<<20)+5,mo1=1e9+9,base1=19491001,mo2=998244353,base2=19260817,inf=(ll)1e18+7;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int T;
int n,q,tp,a[N],w[N];
string s;
int kmp[N];
vector<int>e[N];
int fa[N][20],dep[N],topp[N],dfn[N],cntp,sz[N],hson[N],nw[N];
void dfs1(int x){
	dep[x]=dep[fa[x][0]]+1,sz[x]=1,hson[x]=0;
	rep(i,1,17)
	    fa[x][i]=fa[fa[x][i-1]][i-1];
	for(auto j:e[x]){
		dfs1(j);
		if(!hson[x]||sz[hson[x]]<sz[j])hson[x]=j;
		sz[x]+=sz[j]; 
	}
}
void dfs2(int x,int toppos){
	topp[x]=toppos,dfn[x]=++cntp,nw[cntp]=x;
	if(hson[x])dfs2(hson[x],toppos);
	for(auto j:e[x]){
		if(j==hson[x])continue;
		dfs2(j,j);
	}
}
struct seg1{//单点修改，线段树上二分. 
	int t[4*N],maxn[4*N],maxp[4*N];
	void pushup(int x){
		t[x]=t[ls(x)]+t[rs(x)];
		if(maxn[ls(x)]>maxn[rs(x)])maxn[x]=maxn[ls(x)],maxp[x]=maxp[ls(x)];
		else maxn[x]=maxn[rs(x)],maxp[x]=maxp[rs(x)];
	}
	void build(int x,int le,int ri){
		if(le==ri){
			t[x]=a[nw[le]],maxn[x]=t[x],maxp[x]=le;
			return;
	    }
	    int mid=(le+ri)>>1;
	    build(ls(x),le,mid),build(rs(x),mid+1,ri);
	    pushup(x);
	}
	void modify(int x,int le,int ri,int p,int v){
		if(le==ri){
			t[x]=maxn[x]=v;
			return;
		}
		int mid=(le+ri)>>1;
		if(p<=mid)modify(ls(x),le,mid,p,v);
		else modify(rs(x),mid+1,ri,p,v);
		pushup(x);
	}
	int query(int x,int le,int ri,int v){
		if(le==ri)return le;
		int mid=(le+ri)>>1;
		if(t[ls(x)]<v)return query(rs(x),mid+1,ri,v-t[ls(x)]);
		else return query(ls(x),le,mid,v);
	}
	int querysum(int x,int le,int ri,int ql,int qr){
		if(ql<=le&&qr>=ri)return t[x];
		int mid=(le+ri)>>1,res=0;
		if(ql<=mid)res+=querysum(ls(x),le,mid,ql,qr);
		if(qr>mid)res+=querysum(rs(x),mid+1,ri,ql,qr);
		return res;
    } 
}T1;
struct seg2{//区间加减，区间取min
	int sum[4*N],ans[4*N],dectag[4*N],mintag[4*N];
	void pushup(int x){
		sum[x]=min(sum[ls(x)],sum[rs(x)]);
	    ans[x]=min(ans[ls(x)],ans[rs(x)]);
    }
    void pushdown(int x){
    	sum[ls(x)]+=dectag[x],sum[rs(x)]+=dectag[x],ans[ls(x)]+=dectag[x],ans[rs(x)]+=dectag[x];
		dectag[ls(x)]+=dectag[x],dectag[rs(x)]+=dectag[x];
    	dectag[x]=0;
    	mintag[ls(x)]=min(mintag[ls(x)],mintag[x]),mintag[rs(x)]=min(mintag[rs(x)],mintag[x]);
    	ans[ls(x)]=min(ans[ls(x)],sum[ls(x)]+mintag[ls(x)]),ans[rs(x)]=min(ans[rs(x)],sum[rs(x)]+mintag[rs(x)]);
    }
    void build(int x,int le,int ri){
    	sum[x]=0,ans[x]=inf,mintag[x]=inf,dectag[x]=0;
    	if(le==ri)return;
    	int mid=(le+ri)>>1;
    	build(ls(x),le,mid),build(rs(x),mid+1,ri); 
    }
    void add(int x,int le,int ri,int ql,int qr,int v){
    	if(ql<=le&&qr>=ri){
    		sum[x]+=v,ans[x]+=v,dectag[x]+=v;
    		return;
    	}
    	pushdown(x);
    	int mid=(le+ri)>>1;
    	if(ql<=mid)add(ls(x),le,mid,ql,qr,v);
    	if(qr>mid)add(rs(x),mid+1,ri,ql,qr,v);
    	pushup(x);
    }
    void modify(int x,int le,int ri,int ql,int qr,int v){
    	if(ql<=le&&qr>=ri){
    		ans[x]=min(ans[x],sum[x]+v);
    		mintag[x]=min(mintag[x],v);
    		return;
    	}
    	pushdown(x);
    	int mid=(le+ri)>>1;
    	if(ql<=mid)modify(ls(x),le,mid,ql,qr,v);
    	if(qr>mid)modify(rs(x),mid+1,ri,ql,qr,v);
    	pushup(x);
    }
    int query(int x,int le,int ri,int ql,int qr){
    	if(ql<=le&&qr>=ri){
    		return ans[x];
    	}
    	pushdown(x);
    	int mid=(le+ri)>>1,res=inf;
    	if(ql<=mid)res=min(res,query(ls(x),le,mid,ql,qr));
		if(qr>mid)res=min(res,query(rs(x),mid+1,ri,ql,qr));
		pushup(x);
		return res; 
    }
}T2;
void addroad(int x,int v){
	while(x>=0){
		T2.add(1,1,n+1,dfn[topp[x]],dfn[x],v);
		x=fa[topp[x]][0];
	}
}
int getans(){
	int res=inf;
	int nsum=T1.t[1],targ=T1.query(1,1,n+1,(nsum+1)/2);
	if(T1.maxn[1]>nsum/2)res=w[nw[T1.maxp[1]]];
	targ=nw[targ];
	repp(i,17,0){
		int nxtp=fa[targ][i];
		if(nxtp>=0&&T1.querysum(1,1,n+1,dfn[nxtp],dfn[nxtp]+sz[nxtp]-1)<=nsum/2)targ=nxtp;
	}
	if(T1.querysum(1,1,n+1,dfn[targ],dfn[targ]+sz[targ]-1)<=nsum/2)targ=fa[targ][0];
	while(targ>=0){
		res=min(res,T2.query(1,1,n+1,dfn[topp[targ]],dfn[targ]));
		targ=fa[topp[targ]][0];
	}
	return res;
}
void solve(){
	read(n),read(q),read(tp);
	cin>>s;
	rep(i,0,n)
	    e[i].clear();
	for(int i=1,j=0;i<n;i++){
		while(j&&s[i]!=s[j])
		    j=kmp[j-1];
		if(s[i]==s[j])j++;
		kmp[i]=j;
	}
	rep(i,0,n)
	    read(a[i]),read(w[i]); 
	fa[0][0]=-1,cntp=0;
	rep(i,1,n)
		fa[i][0]=kmp[i-1],e[kmp[i-1]].push_back(i);
	dfs1(0),dfs2(0,0);
	T1.build(1,1,n+1),T2.build(1,1,n+1);
	rep(i,0,n){//初始化 T2. 
		addroad(i,w[i]);
		T2.modify(1,1,n+1,dfn[i],dfn[i]+sz[i]-1,w[i]);
	}
	
	int lans=getans();
	printf("%lld\n",lans),lans=abs(lans);
	while(q--){
		int op,p,v;
		read(op),read(p),read(v);
		op^=(lans*tp),p^=(lans*tp);
		if(v<=0)v=(-v)^(lans*tp),v*=-1;
		else v^=lans*tp;
		if(op==1)T1.modify(1,1,n+1,dfn[p],v);
	    if(op==2)addroad(p,v-w[p]),T2.modify(1,1,n+1,dfn[p],dfn[p]+sz[p]-1,v),w[p]=v;
	    lans=getans();
	    printf("%lld\n",lans),lans=abs(lans);
	}
}
signed main(){
	read(T);
	while(T--)
	    solve();
	return 0;
}
```

---


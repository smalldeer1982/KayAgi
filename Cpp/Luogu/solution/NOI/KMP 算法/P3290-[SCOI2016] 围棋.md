# [SCOI2016] 围棋

## 题目描述

近日，谷歌研发的围棋 AI——AlphaGo 以 $4:1$ 的比分战胜了曾经的世界冠军李世石，这是人工智能领域的又一里程碑。

与传统的搜索式 AI 不同，AlphaGo 使用了最近十分流行的卷积神经网络模型。在卷积神经网络模型中，棋盘上每一块特定大小的区域都被当做一个窗口。例如棋盘的大小为 $5\times 6$，窗口大小为 $2\times 4$，那么棋盘中共有 $12$ 个窗口。此外，模型中预先设定了一些模板，模板的大小与窗口的大小是一样的。

下图展现了一个 $5\times 6$ 的棋盘和两个 $2\times 4$ 的模板：

![](https://i.loli.net/2020/03/05/24yfVvrmNScWF5g.jpg)

对于一个模板，只要棋盘中有某个窗口与其完全匹配，我们称这个模板是被激活的，否则称这个模板没有被激活。

例如图中第一个模板就是被激活的，而第二个模板就是没有被激活的。我们要研究的问题是：对于给定的模板，有多少个棋盘可以激活它。

为了简化问题，我们抛开所有围棋的基本规则，只考虑一个 $n\times m$ 的棋盘，每个位置只能是黑子、白子或无子三种情况，换句话说，这样的棋盘共有 $3^{n\times m}$ 种。此外，我们会给出 $q$ 个 $2\times c$ 的模板。

我们希望知道，对于每个模板，有多少种棋盘可以激活它。强调：模板一定是两行的。


## 说明/提示

对于所有测试点：$1\leq n\leq 100$，$1\leq m\leq 12$，$1\leq c\leq 6$，$1\leq q\leq 5$。

| 测试点编号 | 约定 |
| :----------: | :----------: |
| $1$ | $n=3$，$m=4$，$c=2$ |
| $2$ | $n=4$，$m=4$，$c=3$ |
| $3$ | $n=2$，$m=9$，$c=6$ |
| $4$ | $n=2$，$m=12$，$c=3$ |
| $5$ | $n=2$，$m=12$，$c=5$ |
| $6$ | $n=10$，$m=8$，$c=3$ |
| $7$ | $n=10$，$m=10$，$c=5$ |
| $8$ | $n=100$，$m=10$，$c=5$ |
| $9$ | $n=100$，$m=12$，$c=5$ |
| $10$ | $n=100$，$m=12$，$c=6$ |

## 样例 #1

### 输入

```
3 1 1 2
B
W
B
B```

### 输出

```
6
5```

# 题解

## 作者：hsfzLZH1 (赞：9)

题目大意：有一个行列的棋盘，每个格子上有三种可能的情况：落白子($W$)，落黑子($B$)和无子($X$)。所有可能的棋盘状态共有$3^{n\times m}$种。有$Q$次询问，每次询问给出一个$2$行$c$列的矩阵，问有多少种棋盘，使得其至少有一个子矩阵与该矩阵完全相同。

利用补集转化的思想，把问题转换为求没有任何一个子矩阵满足匹配条件的棋盘的种数$ans$。最后的答案即为$3^{n\times m}-ans$。
使用轮廓线$DP$解决这个问题。设$f_{x,y,k,i,j}$表示当前考虑到第$x$行第$y$列，上面的轮廓线状态为$i$，矩阵第一行匹配的位置为$j$，第二行匹配位置为的方案总数$k$。（轮廓线状态表示当前点能否匹配到模板串第一行的末尾，也就是和下图红色区域的匹配状态）

![](https://cdn.luogu.com.cn/upload/pic/28726.png)

$x$和$y$这两维可以不存，滚动。对于所有$x$和$y$，初始状态为$f_{x,y,0,0,0}=1$。计算到新的一行时，所有上一行的$f_{x-1,y,i,j,k}$都要转移到$f_{x,y,0,0,0}$。
利用$KMP$进行转移。预处理出询问矩阵两行的失配函数，记为$nxt_{0,x}$和$nxt_{1,x}$。同时预处理出模式串位置$x$对应的文本串位置上的值是$v$的话的失配函数，记为$t_{0,x,v}$和$t_{1,x,v}$。转移的过程中，当$i$和$j$达到$c$时，很显然存在这样的匹配，应该删掉这种情况，此时值应设为$0$；其他时候，将$i$或$j$沿着失配边向前跳一下。

时间复杂度为$O(nm\times 2^m \times c^2)$。

代码展示：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int mod=1000000007;
const int maxn=7;
const int maxv=1<<12;
int n,m,c,Q,maxx,a1[maxn],a2[maxn],nxt1[maxn],nxt2[maxn],t1[maxn][3],t2[maxn][3],f[2][maxv][maxn][maxn],cur,ans;
char s1[maxn],s2[maxn];
inline int getid(char x)
{
	if(x=='W')return 0;
	if(x=='B')return 1;
	if(x=='X')return 2;
}
int powmod(int a,int k)
{
	ll ret=1,x=a;
	while(k)
	{
		if(k&1)ret=ret*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return (int)ret;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&c,&Q);
	maxx=1<<(m-c+1);
	while(Q--)
	{
		scanf("%s%s",s1+1,s2+1);
		for(int i=1;i<=c;i++)a1[i]=getid(s1[i]),a2[i]=getid(s2[i]);
		for(int i=2,j=0;i<=c;i++)
		{
			while(j&&a1[j+1]!=a1[i])j=nxt1[j];
			if(a1[j+1]==a1[i])j++;
			nxt1[i]=j;
		}
		for(int i=2,j=0;i<=c;i++)
		{
			while(j&&a2[j+1]!=a2[i])j=nxt2[j];
			if(a2[j+1]==a2[i])j++;
			nxt2[i]=j;	
		}
		for(int i=0;i<c;i++)for(int j=0,k=i;j<3;j++,k=i)
		{
			while(k&&a1[k+1]!=j)k=nxt1[k];
			if(a1[k+1]==j)k++;
			t1[i][j]=k;
		}
		for(int i=0;i<c;i++)for(int j=0,k=i;j<3;j++,k=i)
		{
			while(k&&a2[k+1]!=j)k=nxt2[k];
			if(a2[k+1]==j)k++;
			t2[i][j]=k;
		}
		memset(f[0],0,sizeof f[0]);
		f[0][0][0][0]=1;cur=1;
		for(int i=1;i<=n;i++)
		{
			memset(f[cur],0,sizeof f[cur]);
			for(int j=0;j<maxx;j++)for(int a=0;a<c;a++)
			for(int b=0;b<c;b++)f[cur][j][0][0]+=f[1-cur][j][a][b],f[cur][j][0][0]%=mod;
			cur=1-cur;
			for(int j=1;j<=m;j++)
			{
				memset(f[cur],0,sizeof f[cur]);
				for(int k=0;k<maxx;k++)for(int a=0;a<c;a++)
				for(int b=0;b<c;b++)if(f[1-cur][k][a][b])
				for(int col=0;col<3;col++)
				{
					int pa=t1[a][col],pb=t2[b][col],S=k;
					if(j>=c)if((S>>j-c)&1)S^=1<<j-c;
					if(pa==c){S^=1<<j-c;pa=nxt1[c];}
					if(pb==c){if((k>>j-c)&1)continue;pb=nxt2[c];}
					f[cur][S][pa][pb]+=f[1-cur][k][a][b];
					f[cur][S][pa][pb]%=mod;
				}
				cur=1-cur;
			}
		}
		ans=powmod(3,n*m);
		for(int i=0;i<maxx;i++)for(int j=0;j<c;j++)for(int k=0;k<c;k++)
		ans=(ans-f[1-cur][i][j][k]%mod+mod)%mod;
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：TwoJie (赞：7)

#### [围棋](https://www.luogu.com.cn/problem/P3290) 

状压DP好题。

容易想到 $n=2$ 的做法，用 $f_{i,j,k}$ 表示dp到第 $i$ 列，现在匹配到了 $j$ ，之前一共匹配了 $k$ 个。然后转移利用KMP就挺显然的，勉强能过。

~~但是想到这个部分就想不动了~~ 

首先发现 **至少匹配一次** 的这个条件很麻烦，考虑反着来：用总方案数-一次都不匹配的方案数。

数据这么小，考虑轮廓线状压DP，但是要状压什么呢，这是一个难点。

考虑当前位置所在行作为第二行，那么你就要判断当前行能否匹配完模板串，那么你就需要记录dp到这个位置匹配第二行匹配到了哪里。

那你怎么知道上一行匹配到了哪里呢？这里就可以考虑轮廓线那个东西了，状态 $S$ 如果当前位为1，表示上一行可以匹配完模板串的第一行，0则表示不能。

拿考虑当前位怎么更新这个状态 $S$ ，和上面那个匹配第二行的要求很形似对吧，那么我们就可以和上面匹配第二行一样的做法存一个匹配到了哪里。

至此，我们已经可以转移了，状态 $dp_{flag,S,i,j}$ 表示状压的状态为 $S$ ，当前位置匹配第一行匹配到了 $i$ ，第二行匹配到了 $j$ 。$flag$ 那一维就是滚动数组。

然后转移的时候注意一下dp到每一行最后一个位置的时候要把 $i,j$ 直接搞为0，因为下一个地方就是下一行，也就没法继承上面匹配的情况了。

上代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=20,S=(1<<12)+10,mod=1e9+7;
const char alp[5]="WBX";
int n,m,c,Q;
char s[2][N];
int dp[2][S][N][N],q[2][S*N*N][3];
int nxt[2][N];
void pre(){
	for(int t = 0; t < 2; t++){
		int j = 0;
		for(int i = 1; i < c; i++){
			while(j != 0 && s[t][i + 1] != s[t][j + 1]) j = nxt[t][j];
			if(s[t][i + 1] == s[t][j + 1]) j++;
			nxt[t][i + 1] = j;
		}
	}
}
int pos[2][N][3];
int query(int op,int x,int y){
	if (pos[op][x][y]!=-1) return pos[op][x][y];
	int now=x;
	while (now && s[op][now+1]!=alp[y]) now=nxt[op][now];
	if (s[op][now+1]==alp[y]) now++;
	return pos[op][x][y]=now;
}
int qpow(int a,int b){
	int res=1;
	for (;b;b>>=1){
		if (b&1) res=res*a%mod;
		a=a*a%mod;
	}
	return res;
}
void clear(){
	memset(nxt,0,sizeof(nxt));
	memset(dp,-1,sizeof(dp));
	memset(pos,-1,sizeof(pos));
	memset(q,0,sizeof(q));
}
signed main(){
	scanf("%lld%lld%lld%lld",&n,&m,&c,&Q);
	while (Q--){ 
		scanf("%s",s[0]+1);
		scanf("%s",s[1]+1);
		clear();
		pre();
		int last=1,now=0,flag=1;
		dp[0][0][0][0]=1;
		for (int i=1;i<=n;i++)
			for (int j=1;j<=m;j++){
				flag^=1;
				now=0;
				int nxt=flag^1;
				for (int u=1;u<=last;u++){
					int s=q[flag][u][0],p1=q[flag][u][1],p2=q[flag][u][2];
					for (int t=0;t<3;t++){
						int nx=query(0,p1,t),ny=query(1,p2,t),ns=s&(~(1<<(j-1)));
						if (s&(1<<(j-1)) && ny==c) continue;
						if (nx==c) ns|=(1<<(j-1));
						if (j==m) nx=ny=0;
						if (dp[nxt][ns][nx][ny]==-1){
							q[nxt][++now][0]=ns;
							q[nxt][now][1]=nx;
							q[nxt][now][2]=ny;
							dp[nxt][ns][nx][ny]=dp[flag][s][p1][p2];
						}else dp[nxt][ns][nx][ny]+=dp[flag][s][p1][p2];
						dp[nxt][ns][nx][ny]%=mod;
					}
					dp[flag][s][p1][p2]=-1;
				}
				last=now;
			}
		int ans=qpow(3,n*m);
		flag^=1;
		for (int i=1;i<=last;i++){
			ans-=dp[flag][q[flag][i][0]][q[flag][i][1]][q[flag][i][2]];
			ans%=mod;
		}
		ans=(ans%mod+mod)%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Caro23333 (赞：7)

**听说latex挂了，但是自己博客里看起来没有任何问题，请问能告知一下是哪里吗？**

从来没学过轮廓线dp，所以是假做法教学现场。

实际上感觉出题人设置了 $q=5$ 就是为了卡掉我类似的做法，但是在计算机性能日益发展的今天，他失败了）

本做法 Luogu 开O2可以过，LOJ 可以过（4s时限），Luogu 不开O2 70~80分。

第一步是容斥，即计算所有位置都不能匹配的方案数，最后用 $3^{nm}$ 减去即可。

有一个平凡的状压dp：考虑 $f_{i,S}$ 为放置了前 $i$ 行，第 $i$ 行的状态为 $S$ 时，满足条件的方案数。这里$S\in [0,3^m)$。 然后会发现因为朴素的转移是 $O(m3^m)$ 的，导致总复杂度太高，所以要考虑降低转移的复杂度。

思考一下，发现 $f_{i,S}$ 是否能转移到 $f_{i+1,T}$ 和 $i$ 的取值没有任何关系，而只和 $S$ 与 $T$ 组成的两行是否包含给定的模型有关。再具体一点，我们考虑用给定模型的第一行去匹配 $S$ ，得到一个出现位置集合 $P_S$， 用给定模型的第二行去匹配 $T$ ，得到一个出现位置集合 $P'_T$ ，那么 $f_{i,S}$ 可以转移到 $f_{i+1,T}$ 当且仅当 $P_S\cap P_T = \varnothing$ 。

是不是呼之欲出了？

首先对于每种状态 $S$ ， 预处理出 $P_S$ 和 $P'_S$ ， 并且设 $g_{
i,T} = \sum\limits_{P_S=T} f_{i,S}$ 和 $h_{i,T} = \sum\limits_{S\subset T} g_{i,S}$。那么就有：

$$f_{i,S} = \sum_{P_T\cap P_S=\varnothing} f_{i-1,T} = \sum_{T\subset \overline{P_S}} g_{i-1,T} = h_{i-1,\overline{P_S}}$$

对于某一行而言，所有的 $g_{i,S}$ 可以在 $O(3^m)$ 时间内得到，而 $h_{i,S}$ 则可以通过高维前缀和或者 FMT 在 $O(m2^m)$ 时间内得到，所以从第 $i$ 行转移到第 $i+1$ 行的复杂度降为 $O(3^m)$。

总复杂度 $O(qn3^m)$ ，经过一定常数优化可以在 Luogu(O2) 和 LOJ 通过。

#### 滚去学轮廓线dp了）

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <ctime> 
#define mod 1000000007

using namespace std;
typedef long long ll;
const int MAXN = 600005, MAXS = 4105;
int n,m,c,q;
int num[2][MAXN],pw[MAXN];
int f[2][MAXN],g[MAXS];
char str[2][10],tmp[MAXN][15];
inline void generalInit()
{
	pw[0] = 1;
	for(int i = 1; i<=m; i++)
		pw[i] = pw[i-1]*3;	
	for(int i = 0; i<pw[m]; i++)
	{
		int x = i;
		for(int j = 0; j<m; j++)
		{
			if(x%3==0)
				tmp[i][j+1] = 'W';
			else if(x%3==1)
				tmp[i][j+1] = 'B';
			else if(x%3==2)
				tmp[i][j+1] = 'X';
			x /= 3;
		}
	} 
}
inline void init()
{
	memset(f,0,sizeof(f));
	memset(num,0,sizeof(num));
	for(int i = 0; i<pw[m]; i++)
		for(int j = 1; j<=m-c+1; j++)
		{
			bool flag0 = true, flag1 = true;
			for(int k = j; k<=j+c-1; k++)
			{
				flag0 &= str[0][k-j+1]==tmp[i][k];
				flag1 &= str[1][k-j+1]==tmp[i][k];
			}
			if(flag0)
				num[0][i] |= 1<<(j-1);
			if(flag1)
				num[1][i] |= 1<<(j-1);
		}
}
inline ll qpow(ll a, int b)
{
	ll res = 1;
	for(; b; a = a*a%mod, b >>= 1)
		if(b&1)
			 res = res*a%mod;
	return res;	
}
inline int modadd(int x)
	{ return x>=mod?x-mod:x; }
inline void solve()
{
	init();
	for(int i = 0; i<pw[m]; i++)
		f[1][i] = 1;
	for(int i = 1; i<n; i++)
	{
		int t = i&1;
		memset(g,0,sizeof(g));
		for(int j = 0; j<pw[m]; j++)
			g[num[0][j]] = modadd(g[num[0][j]]+f[t][j]);
		for(int j = 1; j<=m-c+1; j++)
			for(int k = 0; k<1<<(m-c+1); k++)
				if(k&(1<<(j-1)))
					g[k] = modadd(g[k]+g[k^(1<<(j-1))]);
		for(int j = 0; j<pw[m]; j++)
			f[t^1][j] = g[((1<<(m-c+1))-1)^num[1][j]];
	}
	ll ans = qpow(3,n*m);
	for(int i = 0; i<pw[m]; i++)
		ans = modadd(ans-f[n&1][i]+mod);
	cout << ans << endl;
}

int main()
{
	cin >> n >> m >> c >> q;
	generalInit();
	while(q--)
	{
		cin >> str[0]+1 >> str[1]+1;
		solve();
	}
	return 0;
}

```


---

## 作者：LCuter (赞：6)

首先肯定是容斥，考虑计算一个棋盘怎么也没法匹配模板的情况。

然后不会了，瞄了一眼题解，轮廓线 DP……然后又不会了……然后又会了……

首先模板只有两行，这是好的，于是状态只和当前行及上一行有关，考虑轮廓线。

再仔细观察，我们发现棋盘当前行怎么填只和上一行是否匹配有关。

对于轮廓线上的格子，我们并不在意它填的具体是什么，我们只需要知道它是否可以和模板匹配就行了，所以一个位置是 $1$ 当且仅当棋盘中以它为末尾的一个串可以和模板第一行匹配。注意这里即使是当前行的轮廓线，也是和模板第一行匹配。

设 $F_{i,j,S,a,b}$ 表示当前正在填第 $i$ 行第 $j$ 列，轮廓线状态为 $S$，当前行已经匹配到了模板第一行的第 $a$ 位，当前行已经匹配到了模板第二行的第 $b$ 位。

首先填初值 $F_{1,1,0,0,0}=1$。

接着考虑如何将 $F_{i,j,S,a,b}$ 转移至 $F_{i,j+1}$。

分析填上一个数会对 $S,a,b$ 产生什么影响，如果填对了数（特别地如果 $a$ 或 $b$ 等于 $c$ 了，那么它填什么数都是错的），那么它会加一，否则应该不停跳 border，直到下一位可以匹配填的下个数，这部分可以 KMP 求。至于 $S$，看看 $a$ 是否会变为 $c$ 就可以了。

当然如果 $S$ 中表示 $j$ 的那一位为 $1$，且 $b$ 将变成 $c$，那么这时是无法转移的。

最后要求的是 $\sum_SF_{n+1,1,S,0,0}$。

跳 border 的过程可以预处理出来。

具体实现中，由于前 $c-1$ 列肯定无法匹配，所以 $S$ 实际上是整体右移使得第 $0$ 位表示的是第 $c$ 列。

滚动数组优化一下空间就好了。

时间复杂度 $O(nm2^{m-c+1}c^2)$，空间复杂度 $O(2^{m-c+1}c^2)$。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
inline void read(int &x){
    static char c;
    while(!isdigit(c=getchar())); x=c^48;
    while(isdigit(c=getchar()))x=(x*10)+(c^48);
}
inline void read(ll &x){
    static char c;
    while(!isdigit(c=getchar())); x=c^48;
    while(isdigit(c=getchar()))x=(x*10)+(c^48);
}

const int Mod=1e9+7;
void Add(int &x,int y){(x+=y)>=Mod?x-=Mod:x;}
int Pow(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=1ll*res*a%Mod;
        a=1ll*a*a%Mod,b>>=1;
    }
    return res;
}

int n,m,c,q,All;
char st[2][15];
int str[2][15],Bord[2][15],nxt[2][15][3];

void Init(){
    for(int B:{0,1}) scanf("%s",st[B]+1);
    #define TRANS(i,j) str[i][j]=(st[i][j]=='X'?2:(st[i][j]=='B'))
    for(int i=1;i<=c;++i)
        for(int B:{0,1}) TRANS(B,i);
    #undef TRANS
    for(int B:{0,1}){
        str[B][0]=str[B][c+1]=-1;
        for(int i=2;i<=c;++i){
            int now=Bord[B][i-1];
            while(now&&str[B][i]!=str[B][now+1]) now=Bord[B][now];
            if(str[B][i]==str[B][now+1]) ++now;
            Bord[B][i]=now;
        }
        for(int i=0;i<=c;++i)
            for(int ch:{0,1,2}){
                int now=i;
                while(now&&str[B][now+1]!=ch) now=Bord[B][now];
                if(str[B][now+1]==ch) ++now;
                nxt[B][i][ch]=now;
            }
    }
}

int DP[2][1030][15][15];

void Solve(){
    Init();
    int _S=(1<<(m-c+1));
    int now=0;
    memset(DP,0,sizeof DP);
    DP[0][0][0][0]=1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
            memset(DP[now^1],0,sizeof DP[now^1]);
            #define FOR \
                for(int S=0;S<_S;++S)\
                for(int a=0;a<=c;++a)\
                for(int b=0;b<=c;++b)\
                for(int ch:{0,1,2})
            FOR{
                int _nxtS,_nxta=nxt[0][a][ch],_nxtb=nxt[1][b][ch];
                if(j<c) _nxtS=S;
                else{
                    _nxtS=S|(1<<(j-c));
                    if(_nxta^c)  _nxtS^=1<<(j-c);
                }
                if(_nxtb==c&&(S&(1<<(j-c)))) continue;
                if(j==m) Add(DP[now^1][_nxtS][0][0],DP[now][S][a][b]);
                else Add(DP[now^1][_nxtS][_nxta][_nxtb],DP[now][S][a][b]);
            }
            now^=1;
            #undef FOR
        }
    int Ans=0;
    for(int S=0;S<_S;++S) Add(Ans,DP[now][S][0][0]);
    Ans=(All-Ans+Mod)%Mod;
    printf("%d\n",Ans);
}

void Work(){
    read(n),read(m),read(c),read(q);
    All=Pow(3,n*m);
    while(q--) Solve();
}

int main(){Work();}
```



---

## 作者：_Sein (赞：4)

这道题挺有意思的，~~导致我甚至一度看不懂题意~~

看了网上仅有的两篇题解(而我都看得不太懂

都发现了文上歪歪扭扭的“轮廓线DP“字样，看了许久，才从字里行缝中看见惊人的二字”不会“

于是恶补了一下轮廓线DP，正常的状态压缩是行行之间，或者是列列之间进行状态的枚举、转移。

而轮廓线DP，可以说是格子到格子，也就是轮廓的改变，放张图自己感受一下。

![无标题.jpg][1]


  [1]: http://lb2003.top/usr/uploads/2020/03/505523913.jpg

比如之前状态就是$s$，所有的红色格子，现在从$(i,j-1)$到了$(i,j)$，也就是状态$t$，把$(i-1,j)$的红色格子替换成了$(i,j)$的绿色格子。

轮廓线DP的大致意思就是这样。

## 回归正题

题意描述:对于每一询问，给你一个两行的模式串，问有多少种方法可以把这两个模式串塞入($n,m$)大小的地图。

如果正向求的话，需要枚举塞一个，还是很多个，相当不好处理。

不妨用总方案$3^{nm}$减去不合法方案数。

但正常的状态压缩DP，复杂度过高，不适宜套在此处。

若当前填到$(i,j)$，自然可以想到这是第一行，还是第二行模式串。

那么会有一个状态记录当前填到$(i,j)$(匹配的最后一个字符一定是$col_{(i,j)}$)，已经匹配到第一行模式串第$x$位，第二行模式串第$y$位，($tips:$这里的第一行，第二行，不是同一个模式串哦)。

若扩展到$(i,j+1)$，那么要继承最优匹配位置，可以用$kmp$求得$tx,ty$。

那怎么样判断当前方案是否合法？

这就要借助轮廓了，若当前状态$s$，记录以当前行$i$为第一行模式串，以$j$作为第一行模式串的结尾，是否完美匹配，若是则这一位为$1$，否则这一位为$0$。

还是用回上面的图，

![无标题.jpg][1]


  [1]: http://lb2003.top/usr/uploads/2020/03/505523913.jpg

观察发现，要由$s$到$t$，仅需改变$(i-1,j)$到$(i,j)$这一位的状态，因此$t$的大部分状态都可以继承$s$。根据这个是否可以搞出一些事情？

比如$ty==c$，并且$(i-1,j)$这一个位置(也就是$s$的$j-c$位为$1$)恰好也是匹配的，那不就成了合法方案了吗？

因此这样的状态可以弃之不要。

进入到下一行的时候，根据定义需要重置$x,y$。

之后就是常规操作啦！

## 总结流程

定义状态$f_{i,j,s,x,y}$表示当前填到$(i,j)$，轮廓$s$表示模式串第一行在相应位置是否匹配，$x$表示第一行模式串匹配到哪了，$y$表示第二行模式串匹配到哪了的**不合法**方案数。

通过枚举颜色$col_{i,j+1}$，$kmp$跳最优进行转移。

不要忘了进到下一行重置$x,y$。

这道题在轮廓线DP算简单的？

我还是太菜了。

代码是借鉴了别人的，所以雷同不要介意。


```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
#define eps 1e-8
using namespace std;
const int mod=1e9+7;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int nxt1[12],nxt2[12],d1[12],d2[12];char s1[12],s2[12];
int f[2][1<<12][7][7],n,m,c,q;
void add(int &x,int y){x+=y;if(x>=mod)x-=mod;}
void mul(int &x,int y){x=1ll*x*y%mod;}
void init(char *s,int *d,int *nxt)
{
	for(int i=1;i<=c;i++)d[i]=(s[i]=='W'?2:(s[i]=='B'));
	for(int j=0,i=2;i<=c;i++)
	{
		while(j&&d[j+1]!=d[i])j=nxt[j];
		if(d[j+1]==d[i])++j;nxt[i]=j;
	}
}
int get(int p,int col,int *d,int *nxt)
{
	while(p&&d[p+1]!=col)p=nxt[p];
	if(d[p+1]==col)++p;return p;
}
int main()
{
	qr(n),qr(m),qr(c),qr(q);
	while(q--)
	{
		memset(d1,-1,sizeof(d1));memset(nxt1,0,sizeof(nxt1));
		memset(d2,-1,sizeof(d2));memset(nxt2,0,sizeof(nxt2));
		scanf("%s",s1+1);init(s1,d1,nxt1);
		scanf("%s",s2+1);init(s2,d2,nxt2);
		int sum=1,ans=0,now=0,tx,ty,t,l=m-c+1;
		memset(f,0,sizeof(f));f[now][0][0][0]=1;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				memset(f[now^1],0,sizeof f[now^1]);
				for(int s=0;s<1<<l;s++)
					for(int x=0;x<=c;x++)
						for(int y=0;y<=c;y++)	
							if(f[now][s][x][y])
								for(int col=0;col<3;col++)
								{
									int tx=get(x,col,d1,nxt1);
									int ty=get(y,col,d2,nxt2);
									if(j>=c)
									{
										t=s&(~(1<<j-c));
										t|=(tx==c)<<j-c;
									}
									else t=s;
									if(j>=c&&(s>>j-c&1)&&ty==c)continue;
									add(f[now^1][t][tx][ty],f[now][s][x][y]);
								}
				now^=1;mul(sum,3);
			}
			for(int s=0;s<1<<l;s++)
				for(int x=0;x<=c;x++)
					for(int y=0;y<=c;y++)
						if(x||y)add(f[now][s][0][0],f[now][s][x][y]),f[now][s][x][y]=0;
		}
		for(int s=0;s<1<<l;s++)
			add(ans,f[now][s][0][0]);
		add(sum,mod-ans);
		qw(sum);puts("");
	}
	return 0;
}
```










---

## 作者：forest114514 (赞：0)

### P3290 [SCOI2016] 围棋

首先不大的列数和 $2$ 行的模版想到了轮廓线 DP，加上 SCOI 喜欢这个玩意就更加坚定了我们的想法。对于每个模版串肯定单独询问，接着发现如果对合法作为状态的话要加一维判断有点烦，所以考虑计数有多少不合法的。

考虑 $n=2$，相当于枚举当前两行的棋盘看匹不匹配，设 $f_{i,j}$ 表示前 $i$ 列，末尾匹配到模版第 $j$ 列没有匹配的方案数，转移就是枚举一列两个的状态，用 KMP 进行转移，可以预处理 KMP 自动机。

一般的情况，设 $f_{i,j,S,k}$ 表示考虑到 $i$ 行 $j$ 列，轮廓状态为 $S$，匹配到了第 $k$ 列且没有匹配方案的方案数，状态是 $O(nm3^mc)$ 的，一个小优化是你都知道匹配了几位，这几位的状态没必要压缩，然后就变成了 $O(\sum \limits_{i=0}^{c-1}nm3^{m-i})=O(nm3^m)$。

好像优化到头了？不过还是要进一步简化状态才行，首先我们看着 $3^m$ 的状压非常不爽，考虑一下怎么优化？

首先从匹配的角度出发，考虑一下哪些信息是有用的？首先轮廓线状压的状态分为两个部分：给下一行转移的，在这一行要准备考虑的，然后本质上其实还是记录上一行要转移的，所以考虑上一行的状态怎么优化。

考虑到 $i$ 行 $j$ 列的时候我们其实并不关系 $i-1$ 行的格子是什么状态，在 $i$ 行 $j$ 列只关心上一行以 $j$ 结尾长 $c$ 的串能不能匹配模版串的第一行，所以轮廓线的状态就是以每个点结尾的串能不能匹配模板的第一行，这样就是 $01$ 状压了，为了更新新一行的轮廓现在要记录两行分别匹配到了哪里，可以先预处理两行的 KMP 自动机。

设 $f_{i,j,S,a,b}$ 表示考虑到 $i$ 行 $j$ 列，轮廓状态为 $S$，两行分别匹配到了 $a,b$ 列，没有完整匹配的方案数，现在状态是 $O(nm2^mc^2)$ 的，然后有一个显然的优化就是 $1\sim c-1$ 列肯定不合法，所以最后的时间就是 $O(nmq2^{m-c+1}c^2)$。

code：

```cpp
void solve(){
	memset(trans,0,sizeof trans),memset(f,0,sizeof f);
	memset(fail,0,sizeof fail),memset(tmp,0,sizeof tmp);
	rep(t,0,1){
		cin>>s[t],s[t]=' '+s[t];
		rep(i,1,c){
			if(s[t][i]=='W') s[t][i]='1';
			if(s[t][i]=='B') s[t][i]='2';
			if(s[t][i]=='X') s[t][i]='0';
		}
		int k=0;fail[t][0]=fail[t][1]=0;
		rep(i,2,c){
			while(k&&s[t][k+1]!=s[t][i]) k=fail[t][k];
			fail[t][i]=(s[t][k+1]==s[t][i])?++k:0;
		}
		trans[t][0][s[t][1]-'0']=1;
		rep(i,1,c-1){
			rep(j,0,2) trans[t][i][j]=(s[t][i+1]-'0'==j)?i+1:trans[t][fail[t][i]][j];
		}
		rep(j,0,2) trans[t][c][j]=trans[t][fail[t][c]][j];
	}
	int res=ksm(3,n*m);
	f[0][0][0]=1;
	rep(i,1,n){
		rep(j,1,m){
			rep(T,0,(1<<(m-c+1))-1){
				int S=T<<(c-1);
				rep(a,0,min(c,j)) rep(b,0,min(c,j)){
					if(!f[T][a][b]) continue;
					rep(t,0,2){
						int ta=trans[0][a][t],tb=trans[1][b][t];
						if(tb==c&&((S>>(j-1))&1)) continue;
						int mp=(S&(S^(1<<(j-1))));
						if(ta==c) mp|=(1<<(j-1));
						_add(tmp[mp>>(c-1)][ta][tb],f[T][a][b]);
					}
				}
			}
			if(j<m) swap(tmp,f),memset(tmp,0,sizeof tmp);
			else{
				memset(f,0,sizeof f);
				rep(T,0,(1<<(m-c+1))-1) rep(a,0,c) rep(b,0,c) _add(f[T][0][0],tmp[T][a][b]);
				memset(tmp,0,sizeof tmp);
			}
		}
	}
	rep(T,0,(1<<(m-c+1))-1) _add(res,mod-f[T][0][0]);
	write(res,'\n');
}
```

---


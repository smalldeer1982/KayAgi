# [WC2016] 论战捆竹竿

## 题目描述

是一个美好的下午，小 W 和小 C 在竹林里切磋捆竹竿的技艺。

竹林里有无数根完全一样的短竹子，每一根竹子由 $n$ 节组成。

这些竹子比较特别，每一节都被染上了颜色。可能的颜色一共 26 种，分别用小写英文字母 $\underline{a}$ 到 $\underline{z}$ 表示。也就是说，如果把竹子的底端到顶端的颜色按顺序写出来可以排成一个由小写英文字母组成的字符串。

小 W 和小 C 都是捆竹竿的高手，他们知道怎样才能把零散的短竹子捆成一整根长竹竿。 初始时你拿着一根短竹子作为当前的竹竿。 每次你可以选择一根短竹子，短竹子底端若干节（可以是 $0$ 节）与竹竿的最上面若干节对应地一节一节捆起来，而短竹子前面剩下的节伸出去，这样就得到了一根更长的竹竿。注意，竹子的底端是靠近根部的那一端，不可以颠倒。

小 W 对竹竿的审美要求很高， 他捆竹竿时有一个癖好： 如果两根竹子的某两节被捆在了一起，那么它们的颜色必须相同。

我们假设一根短竹子从底端到顶端每节的颜色为 $\underline{aba}$。

那么两根竹子可以首尾捆在一起，可以得到一根颜色为 $\underline{abaaba}$ 的竹竿；也可以将第一根顶端的一节 $\underline{a}$ 与第二根底端的一节 $\underline{a}$ 捆在一起，得到一根颜色为$\underline{ababa}$ 的竹竿； 还可以直接将每一节都对应起来，捆成一根颜色为 $\underline{aba}$ 的竹竿。

假设我们在颜色为 $\underline{ababa}$ 的竹竿顶端再捆一根竹子，则可以捆成 $\underline{ababaaba}$，$\underline{abababa}$ 和 $\underline{ababa}$ 三种不同的情况。

但是小 C 在这个问题上有不同的看法，他认为小 W 捆不出很多种长度不同的竹竿。小 W 非常不服，于是他找到了你——现在请你求出在竹竿长度不超过 $w$ 的情况下， 小 W 可以捆出多少种长度不同的竹竿。 其中， 竹竿的长度指从底端到顶端的竹子的节的个数。

注意：如果 $w < n$，则没有合法的长度，此时答案为 $0$。


## 说明/提示

【样例解释$1$】

可以捆成长度不超过 $11$ 的竹竿有 $6$ 种不同的情况：

```
bbab
bbabbab
bbabbbab
bbabbabbab
bbabbabbbab
bbabbbabbab
```

后两种竹竿长度相同，因此不同长度的竹竿共有 $5$ 种。长度分别为： $4$， $7$，$8$， $10$， $11$。

【数据规模和约定】

对于所有的测试数据，保证所有的字符串均由小写字母构成。

各测试点满足以下约定：

![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)


## 样例 #1

### 输入

```
1
4 11
bbab```

### 输出

```
5```

## 样例 #2

### 输入

```
2
44 1000
baaaaaabaabbaaabbbbabbbaaabbbababaaabaaabaaa
41 1000
abaabbabaaabaabbbbbbbbbbbababbbbaaabaabbb```

### 输出

```
195
24```

# 题解

## 作者：_sys (赞：36)

本题需要我们了解一个关于 border 的性质。

***
**定理：** 

一个字符串的所有 border 排序后，至少存在一种将序列划分为若干子序列的方案，使得所有子序列均为等差数列，且子序列的个数为 $O(\log|s|)$。

**证明：** 

一个显然的结论：$s[0..k - 1]$ 为 $s$ 的 border $\rightleftharpoons$ $|s| - k$ 为 $s$ 的周期。

另一个显然的结论：若 $p$ , $q$ 为 $s$ 的周期，则 $\gcd(p, q)$ 也为 $s$ 的周期。

以上两个结论可以套定义得到。

考虑两个 $|s|$ 的 border : $A$，$B$，其中 $B$ 为最长的 border ( $s$ 本身除外)，$|A| \geq \frac{|s|}{2}$ 。

令 $p=|s| - |A|$，$q=|s| - |B|$。

若这样的两个 $border$ 存在，则 $p$ , $q$ , $\gcd(p,q)$ 均为 $s$ 的周期，所以 $s[0..|s| - \gcd(p, q)]$ 为 $s$ 的 border，又因为 $B$ 为最长的 border，所以 $\gcd(p,q)$ = $q$。

因此 $q|p$ 。又因为 $k \times q$ 也是 $|s|$ 的周期，所以 $s[0..|s| - k \times q - 1]$ 都是 $s$ 的 border。因此**所有长度大于等于字符串一半的 border 构成一个等差数列**。 


考虑两个 $|s|$ 的 border : $A$，$B$ ($|A| < |B|$)。

则 $A$ 也为 $B$ 的 border。

所以我们可以把 border 分成两个集合：第一个集合的 border 长度大于等于 $\frac{|s|}{2}$，第二部分为其他。第一部分构成了一个等差数列，第二部分所有字符串为其中最长的字符串的 border，可以递归处理，至多 $\log |s|$ 层。定理得证。

***
得到了这个定理，我们回到题目。

我们可以将题意转化为：$\sum_{i=1}^{cnt}a_ix_i$ 在 $[0,w-n]$ 中能取到的值的个数，其中 $cnt$ 为 $|s|$ 的周期个数，$a$ 为周期长度。

由此我们想到了**同余最短路**。

注意，$\min\{a_i\}*cnt$ 是 $O(n^2)$ 的，构造方法为 $aaa\ldots aabaaa\ldots aa$ 。其中 $b$ 处在字符串较中间的位置。

但是由于 border 拥有特殊的性质，我们可以进行优化。

我们把不同的等差数列分开处理。

首先，对于一个等差数列 $x,x + d,x + 2d, \ldots x + l\times d$，我们在$\mod x$ 下跑同余最短路。其中对于 $0 \leq y  < x$ 的 $y$ 向 $ (y + d) \mod x$ 连边，会形成 $\gcd(x, d)$ 个环。每个环可以分开处理。

但我们此时发现，把等差数列分开处理的坏处就是此时没有源点，如果用环上任何一点去优化另外一点，需要 $\Omega(n^2)$ ，这样复杂度很劣。

但是我们又可以发现，环中 $dis$ 最小的一点是绝不会被更新的，且相邻两点之间权值相同，都为 $d$。这两条性质，可以让我们从 $dis$ 最小点出发，使用单调队列计算。

我们在单调队列里放入离现在处理点距离小于等于 $l$ 的点，以 $dis_i - pos_i * d$ 作为比较方式（因为环上 $a$ 点到 $b$ 点的代价是 $-pos_a * d + pos_b * d$)。这样我们就能处理环上的转移。

还有一个问题，是 $dis$ 数组在不同模数之间的转换。若原先的模数为 $las$，现在的模数为 $now$，很显然 $dis_i$ 可以更新 $dis'_{dis_i \mod now}$。但 $dis_i$ 的含义是 $dis_i + k * las$ ($k \geq 0$) 可以被访问。所以我们在$\mod now$ 意义下再用 $x$ 更新$(x + las)\mod now$ 跑一边同余最短路即可。

注意到这个过程类似于单个等差数列的处理过程。同样可以把环分开处理。不过由于没有 $l$ 的限制，不需要用到单调队列。

时间复杂度：$O(Tn\log n)$ 。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int Maxn = 500005;
int now, ct, fail[Maxn], Q[2 * Maxn], seq[Maxn], border[Maxn], pos[Maxn];
long long f[Maxn], res[Maxn], sta[Maxn], ans, w;
string str;
void get_fail(void)
{
	int siz = str.size();
	fail[0] = fail[1] = 0;
	for (int i = 1; i < siz; i++)
	{
		int tmp = fail[i];
		while (tmp && str[tmp] != str[i]) tmp = fail[tmp];
		fail[i + 1] = str[tmp] == str[i] ? tmp + 1 : 0;
	}
	int now = fail[siz];
	while (now)
	{
		border[++ct] = siz - now;
		now = fail[now];
	}
	border[++ct] = siz;
}
void change_mod(int mod)
{
	int cnt = __gcd(mod, now);
	for (int i = 0; i < now; i++)
		res[i] = f[i];
	for (int i = 0; i < mod; i++)
		f[i] = 0x3f3f3f3f3f3f3f3fLL;
	for (int i = 0, tmp; i < now; i++)
		tmp = res[i] % mod, f[tmp] = min(f[tmp], res[i]);
	for (int i = 0; i < cnt; i++)
	{
		int top = 0;
		Q[++top] = i;
		int tmp = (i + now) % mod;
		while (tmp != Q[1])
			Q[++top] = tmp, tmp = (tmp + now) % mod;
		for (int j = top + 1; j <= 2 * top; j++)
			Q[j] = Q[j - top];
		top <<= 1;
		for (int j = 2; j <= top; j++)
			f[Q[j]] = min(f[Q[j]], f[Q[j - 1]] + now);
	}
	now = mod;
}
void work(int first, int diff, int siz)
{
	int cnt = __gcd(diff, first);
	change_mod(first);
	if (diff < 0) return ;
	for (int i = 0; i < cnt; i++)
	{
		int top = 0;
		Q[++top] = i;
		int tmp = (i + diff) % first;
		while (tmp != Q[1])
			Q[++top] = tmp, tmp = (tmp + diff) % first;
		int mini_pos = 1;
		for (int j = 1; j <= top; j++)
			if (f[Q[j]] < f[Q[mini_pos]]) mini_pos = j;
		int tmp_cnt = 0;
		for (int j = mini_pos; j <= top; j++)
			seq[++tmp_cnt] = Q[j];
		for (int j = 1; j < mini_pos; j++)
			seq[++tmp_cnt] = Q[j];
		int head = 1, tail = 1;
		pos[1] = 1, sta[1] = f[seq[1]] - diff;
		for (int j = 2; j <= top; j++)
		{
			while (head <= tail && pos[head] + siz < j) head++;
			if (head <= tail) f[seq[j]] = min(f[seq[j]], sta[head] + j * (long long) diff + first);
			while (head <= tail && sta[tail] >= f[seq[j]] - j * (long long) diff) tail--;
			sta[++tail] = f[seq[j]] - j * (long long) diff, pos[tail] = j;
		}
	}
}
int T, n;
int main()
{
	scanf("%d", &T);
	while (T--)
	{
		ans = ct = 0;
		scanf("%d%lld", &n, &w), w -= n;
		memset(f, 0x3f, sizeof(long long[n]));
		f[0] = 0;
		now = n;
		cin >> str;
		get_fail();
		for (int i = 1, j = 1; i <= ct; i = j)
		{
			while (border[j + 1] - border[j] == border[i + 1] - border[i]) j++;
			work(border[i], border[i + 1] - border[i], j - i - 1);
		}
		for (int i = 0; i < now; i++)
			if (f[i] <= w) ans += (w - f[i]) / now + 1;
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：PhantasmDragon (赞：19)

神仙题 QAQ

先给个定义:

一个字符串的 $border$ : 如果一个正整数 $len$ 对于字符串 $S$ 来说满足 $S_{1} \dots S_{len} = S_{|S|-len+1} \dots S_{|S|}$  且 $len \leq |S|$,则称 $len$ 为 $S$ 的一个 $border$. 如 $3$ 就是 $ababa$ 的一个 $border$. 显然一个字符串可能有多个 $border$

在本题中,显然我们可以选择 $S$ 的一个 $border$ $len$ ,把前面串结尾的 $len$ 个字符和这次开头的 $len$ 个字符融合起来,这样整个串的长度就增加了 $n-len+1$.

那就把题目转化为了一个容量为 $w$ 背包问题, 问能放出多少种总重量不大于 $w$ 的长度.

那么暴力哈希求 $border$, 裸跑同余 BFS, 就有暴力分了. 

啥?你不知道什么是同余 BFS? 可以去看一下洛谷这道题: 跳楼机 再来做这道题qwq

然后就有一个很神仙的结论: 把 $border$ 集合中的所有元素排序, 最少可以被划分成的 **等差数列** 个数不会超过 $\log |S|$ 个.

证明请看官方题解, 我太菜了,不会证.

划分等差数列的意思嘛,举个栗子: $2,3,5,7,9,13,14$ 最少可以被分成三个等差数列.

那么现在就只用考虑如何用一个等差数列来转移以及不同等差数列的合并.

假设有一个首项为 $x$ , 公差为 $d$ , 项数为 $L$ 的一个等差数列. 设一个状态 $f_i$ 表示到达在模 $x$ 意义下为 $i$ 的点所需要的最短路程. 

因为是在模 $x$ 的意义下,所以我们所有的元素都可以被等价地看成是 $0, d,2*d,3*d \dots (L-1)*d$ . 相当于一次可以跳 $d$ 的倍数次,且一次跳的路程不能超过 $(L-1)*d$.

那么在模 $x$ 意义下, 能跳 $d$ 的倍数长度, 很自然就会形成 $\gcd(x,d)$ 个环.  每个环相互不影响,所以分开dp. 每个环中最小的元素肯定不再会被更新,所以就从每个环中最小的那个元素开始 dp, 因为每次不能跳超过 $d$ 的 $L-1$ 倍次,所以单调队列一下就好了.

这样我们就做完了每个等差数列的转移. 但是还需要把每次算出来的 $f$ 数组合并起来. 但是每个 $f$ 的剩余系 $x$ 并不一样, 这就涉及到了一个模 $pre$ 意义下的 $f$ 数组如何转变为模 $now$ 意义下的 $f$.

我们把新的 $f$ 看成 $g$ ,那么我们会有这样一个式子:

$$g_i=\min_{f_j\%now=i} f_j$$ 

为啥? 我们在原来的剩余系 $pre$ 中最少走 $f_i$ 就可以到达 $i$, 在新的剩余系中, 走的这 $f_i$ 步并没有改变, 但是因为模数变成了 $now$, 到达的终点不再是 $i$, 而是 $f_i\%now$. 所以这个值应该被加到 $g_{f_i\%now}$ 上面去.

但是原来在模 $pre$ 意义下, 长度为 $pre$ 的转移并没有被考虑到,所以我们要对新得到的 $g$ 数组上进行一次长度为 $pre$ 的转移才能得到正确的 $g$.

~~别人大佬的博客上并没有讲为啥可以这样转移,以上纯属个人yy,如果有错,欢迎指出qwq~~

那么这样就在 $O(n\log n)$ 的复杂度内通过了此题

------

贴上代码:

```
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define int long long
#define ll long long
#define maxn 1000005
using namespace std;
ll Seed=998244353ll;
ll Ha[maxn],pw[maxn];
char s[maxn];
int n,W,Bo[maxn],f[maxn],pre[maxn],now;
void GetBorder()
{
    Bo[0]=0;
    for(int i=1;i<=n;i++)
        Ha[i]=Ha[i-1]+pw[i]*s[i];
    for(int i=1;i<n;i++)
        if(Ha[i]*pw[n-i]==Ha[n]-Ha[n-i]) Bo[++Bo[0]]=i;
    for(int i=1;i<=Bo[0];i++) Bo[i]=n-Bo[i];
    reverse(Bo+1,Bo+Bo[0]+1);
}
int seq[maxn];
void ChangeMod(int x)
{
    int D=__gcd(x,now),top=0;
    for(int i=0;i<now;i++) pre[i]=f[i];
    for(int i=0;i<x;i++) f[i]=1e18;
    for(int i=0,tmp;i<now;i++)
        tmp=pre[i]%x,f[tmp]=min(f[tmp],pre[i]);
    for(int i=0;i<D;i++)
    {
        top=0,seq[++top]=i;
        int tmp=(i+now)%x;
        while(tmp!=seq[1])
            seq[++top]=tmp,tmp=(tmp+now)%x; 
        for(int j=1;j<=top;j++)
            seq[j+top]=seq[j];
        top<<=1;
        for(int j=2;j<=top;j++)
            f[seq[j]]=min(f[seq[j]],f[seq[j-1]]+now);
    }
    now=x;
}
int dq[maxn],w[maxn];
void Solve(int x0,int d,int len)
{
    int D=__gcd(x0,d),top,l,r,N=0;
    static int Q[maxn];
    ChangeMod(x0);
    if(d<0) return;
    for(int i=0;i<D;i++)
    {
        N=0,top=0,Q[++top]=i;
        int tmp=(i+d)%x0;
        while(tmp!=Q[1])
            Q[++top]=tmp,tmp=(tmp+d)%x0;
        int st=1;
        for(int i=1;i<=top;i++) if(f[Q[i]]<f[Q[st]]) st=i;
        for(int i=st;i<=top;i++) seq[++N]=Q[i];
        for(int i=1;i<st;i++) seq[++N]=Q[i];
        l=1,r=1,dq[1]=1,w[1]=f[seq[1]]-d;
        for(int pt=2;pt<=top;pt++)
        {
            while(l<=r&&dq[l]+len<pt) l++;
            if(l<=r) f[seq[pt]]=min(f[seq[pt]],w[l]+pt*d+x0);
            while(l<=r&&w[r]>=f[seq[pt]]-pt*d) r--;
            w[++r]=f[seq[pt]]-pt*d,dq[r]=pt;
        }
    }
}
int T=0;
signed main()
{
    scanf("%lld",&T),pw[0]=1;
    for(int i=1;i<maxn;i++) pw[i]=pw[i-1]*Seed;
    while(T--)
    {
    	memset(Bo,0,sizeof(Bo));
        scanf("%lld%lld%s",&n,&W,s+1),W-=n;
        GetBorder(),now=n;
        for(int i=1;i<now;i++) f[i]=1e18; f[0]=0;
        for(int i=1,j=1;i<=Bo[0];i=j)
        {
            while(Bo[i+1]-Bo[i]==Bo[j+1]-Bo[j]) j++;
            Solve(Bo[i],Bo[i+1]-Bo[i],j-i-1);
        }
        int ans=0;
        for(int i=0;i<now;i++)
            if(W-f[i]>=0) ans+=(W-f[i])/now+1;
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：T_Q_X (赞：12)

- [uoj](https://uoj.ac/problem/172)

- [洛谷](https://www.luogu.com.cn/problem/P4156)

- [可能更好的体验](https://www.cnblogs.com/tqxboomzero/p/14686995.html)

## Description

给定字符串 $S$，你可以执行一种操作，将 $S$ 拼接到当前字符串后，可以重叠，但重叠的位置必须对位相等，要求最终字符串长度不超过 $m$，现在请你计算最终得到字符串的所有可能长度数量。$|S|\le 5\times 10^5,m\le 10^{18}$

## Solution

首先重叠的部分一定是 $s$ 的一个 $border$，因此每次操作就等于是给原串增加 $|s|-$ 原串的一个 $border$ 的长度。先 $kmp$ 求出所有的 $|s|-border$ 长度，设为 $\{x_i\}$，那么问题转化为求解 $\sum_{i=1}^{sum}a_ix_i$ 在 $[0,m-|s|]$ 范围内能取到多少个不同的值。

容易看出，这是同余最短路的形式，用同余最短路解决这样的问题，就是将 $x$ 从小到大排序，以 $x_1$ 作为模数，对 $0\sim x_1-1$分别建点，对 $\forall i\in [2,sum],j\in [0,x_1-1]$ ，从 $j$ 向 $(x_i+j)\bmod x_1$ 建一条边权为 $x_i$ 的边，然后跑最短路，$dis_i$ 就表示用 $x_2\dots x_{sum}$ 能表示出的最小的 $\bmod x_1=i$ 的数，那么$\le dis_i$ 的所有 $\bmod x_1=i$ 的数都能被表示出来，就可以求出答案了。

暴力做同余最短路，复杂度是 $\mathcal O(n^2\log n)$，考虑优化。

首先引入字符串的一个重要性质：**对于任意一个字符串，它的 $border$ 长度一定会构成 $\mathcal O(\log n)$个等差数列。**

由于博主太菜，在此就不给出证明了。

现在我们假设 $\{x_i\}$ 是一个首项为 $x$ ，公差为 $d$ ，长度为 $len$ 的等差数列，考虑求出其答案。

按同余最短路的方式建边，最终一定会连出 $\gcd(d,x)$ 个环，每个环互相独立。对于任意一个环，环上 $dis$ 最小的点一定不会被其他点松弛，因此以它作为起点，依次考虑环上每个点，会松弛到它的点与它的距离应当不超过 $len-1$，因此如果点 $j$ 比点 $i$ 距离接下来的点更近，且 $dis_j>dis_i+w(i,j)$，那么 $i$ 的松弛一定劣于 $j$，可以弹出 $j$，因此可以使用单调队列维护，至此我们就完成了 $\mathcal O(n)$ 求出这种情况下的答案。

回到原问题，现在我们能够完成每个等差数列内部的转移了，还有考虑前后两个等差数列的组合，设前一个的首项为 $u$，后一个的首项为 $v$，现在要从 $\bmod u$ 的答案转移到 $\bmod v$ 的答案上，首先可以将 $dis_x$ 转移到新的 $dis_{dis_x\bmod v}$ 上，但同时我们还要考虑长为 $u$ 的转移，我们可以将其看作首项为 $0$，公差为 $u$，长度为 $1$ 的等差数列，用上面的方法完成即可。

总复杂度 $\mathcal O(n \log n)$

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e6+10;
int n,fail[N];
char s[N];
int stk[N],top;
inline void getborder(){
	fail[1]=0;
	for(int i=2;i<=n;++i){
		for(int j=fail[i-1];;j=fail[j]){
			if(s[j+1]==s[i]&&j+1!=i){fail[i]=j+1;break;}
			if(j==0){fail[i]=0;break;}
		}
	}
	int now=fail[n];top=0;
	while(now){
		stk[++top]=n-now;
		now=fail[now];
	}stk[++top]=n;
}

ll m,dp[N],tmp[N],q[N][2];
int l,r;
inline void trans(int mod,int x,int del,int mxtrans){
	int g=__gcd(del,mod);
	for(int T=0;T<g;++T){
		ll mn=m+1,pos=-1;int cnt=0;
		for(int j=T;;){
			if(j==T) if((++cnt)>1) break;
			if(dp[j]<mn) mn=dp[j],pos=j;
			j+=del;while(j>=mod) j-=mod;
		}
		cnt=0;
		if(pos==-1) continue;
		if(mxtrans==1){
			for(int i=1,j=(pos+del)%mod,last=pos;j!=pos;++i){
				dp[j]=min(dp[j],dp[last]+del+x);
				last=j;j+=del;while(j>=mod) j-=mod;
			}
			continue;
		}
		l=1;r=0;
		q[++r][0]=0;q[r][1]=mn;
		for(int i=1,j=(pos+del)%mod;j!=pos;++i){
			while(l<=r&&i-q[l][0]>mxtrans) ++l;
			dp[j]=min(dp[j],q[l][1]+1ll*(i-q[l][0])*del+x);
			while(l<=r&&q[r][1]+1ll*(i-q[r][0])*del>dp[j]) --r;
			q[++r][0]=i;q[r][1]=dp[j];
			j+=del;while(j>=mod) j-=mod;
		}
	}
}
int main(){
	int tt;scanf("%d",&tt);
	while(tt--){
		scanf("%d%lld",&n,&m);
		scanf("%s",s+1);
		getborder();
		for(int j=0;j<stk[1];++j) dp[j]=m+1;
		dp[n%stk[1]]=n;
		int res=1;
		ll ans=0;
		for(int i=1,j=0;i<top;i=j+1){
			int del=stk[i+1]-stk[i];j=i+1;
			while(j<=top&&stk[j]-stk[j-1]==del) ++j;--j;
			if(j>i) trans(stk[i],stk[i],del,j-i),res=i;
			if(j<top){
				for(int k=0;k<stk[j+1];++k) tmp[k]=m+1;
				for(int k=0;k<stk[i];++k){
					ll x=dp[k]%stk[j+1];
					tmp[x]=min(tmp[x],dp[k]);
				}
				memcpy(dp,tmp,sizeof(ll)*(stk[j+1]));
				trans(stk[j+1],0,stk[i],1);res=j+1;
			}
		}
		for(int i=0;i<stk[res];++i)
			if(dp[i]<=m) ans+=(m-dp[i])/stk[res]+1;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Schi2oid (赞：9)


若字符串 $s$ 的某个非空真前缀 $s[1…i]$ 恰是该字符串的后缀，则称 $i$ 是 $s$ 的一个公共前后缀，即一个 Border。

若字符串 $s$ 满足 $\forall i\le |S|-t,s[i+t]=s[i]$，则称正整数 $t$ 是字符串 $s$ 的一个周期。

**定理 0**：若 $i$ 是 $s$ 的一个 Border，则 $|S|-i$ 是 $s$ 的一个周期。

**证明**：由于 $i$ 是 $s$ 的一个 Border，得到 $\forall p\le i,s[p+|S|-i]=s[p]$。稍作变形可得 $\forall p\le |S|-(|S|-i),s[p+(|S|-i)]=s[p]$，符合周期定义，得证。

**定理 1（弱周期定理，Weak Periodicity Lemma，WPL）**：若 $p,q$ 都是字符串 $s$ 的周期，且 $p+q\le |S|$，则 $(p,q)$ 也是字符串 $s$ 的一个周期。

**证明**：不妨设 $p>q$。设 $d=p-q$，试说明 $d$ 也是字符串 $s$ 的一个周期。

- $i\le|S|-p$：根据周期定义，我们有 $\forall i\le |S|-p,i+p-q\le|S|-q, s[i]=s[i+p]=s[i+p-q]$。对条件稍作整理可得，$\forall i\le |S|-p,s[i]=s[i+d]$。
- $i>|S|-p$：由于 $p+q\le|S|$，所以$i-q\ge 1$，故 $\forall i-q\le |S|-q,[i-q]=s[i]$。注意到条件显然成立。又因为 $\forall i-q\le |S|-p,s[i-q]=s[i-q+p]$，所以得到 $\forall i\le |S|-d,s[i]=s[i+d]$。

证毕。

还有强周期定理：若 $p,q$ 都是字符串 $s$ 的周期，且 $p+q-(p,q)\le |S|$，则 $(p,q)$ 也是字符串 $s$ 的一个周期。笔者不会证明。一般来说用不到。

**推论**：将上述前缀 $p$ 和前缀 $q$ 复制无限多次，形成的字符串是相同的。

**证明**：gcd 性质易证。

**定理 2**：对于所有 $s$ 的 $\ge \lfloor\frac{|S|}{2}\rfloor$ 的 Border，它们与 $|S|$ 共同构成一个等差数列。

**证明**：考虑两个 Border $|S|-p,|S|-q\ge \lfloor\frac{|S|}{2}\rfloor$。则 $p+q\le|S|$。设 $|S|-p$ 是最大的 Border。根据**定理 0**，我们可以得到 $s$ 的两个周期 $p,q$。由**定理 1**，得到 $(p,q)$ 也是一个周期。又因为 $p$ 是最大的 Border，故 $(p,q)=p$，即 $q$ 是 $p$ 的倍数。同时，周期的整数倍也一定都是周期，所以我们得到所有的 $p$ 的倍数都是周期。因此，一个满足条件的 $q$ 是周期等价于它是 $p$ 的倍数。所以所有的满足条件的 Border 恰构成一个公差为 $p$ 的等差数列，证毕。

**定理 3**：将所有 Border 按其二进制最高位进行分段，每一段内的 Border 都构成一个等差数列。

**证明**：设 $[2^i,2^{i+1})$ 中最大的 Border 为 $p$。那么段内的其余 Border 都是 $s[1…p]$ 的 Border，且其长度 $\ge\lfloor\frac{p}{2}\rfloor $。根据**定理 2**，它们是一个等差数列。证毕。

因此，我们可以将 $s$ 的所有 Border 排序后划分为 $\lceil\log_2{|S|}\rceil$ 个在值域上不交的等差数列。

例题：[[WC2016] 论战捆竹竿](https://www.luogu.com.cn/problem/P4156)

题意：给定一个串 $s$，求其 Border 集合进行线性组合能够得到多少个 $\le w-|S|$ 的值。$|S|\le5\times 10^5,w\le 10^{18}$。

题解：对于若干种值线性组合相关问题，一般考虑同余最短路。具体来说，我们直接在模最小数 $mn$ 意义下进行同余最短路，这样求出每个点的 $dis_i$ 就代表 $dis_i+k\cdot mn$ 都是可以拼出来的。但是，直接跑同余最短路一定是行不通的，复杂度无法低于 $O(n^2)$。（关于 $O(n^2)$ 的此类同余最短路做法，详见[魏老师的博客](https://www.luogu.com.cn/blog/AlexWei/tong-yu-zui-duan-lu-de-zhuan-quan-ji-qiao)）考虑 Border 带给我们的特殊性质：可以划分为  $\lceil\log_2{|S|}\rceil$ 个在值域上不交的等差数列。

考虑对于一个等差数列，应该如何跑同余最短路。设此等差数列为 $\{x_i\}$，其中 $x_i=x_1+(i-1)d$，项数为 $L$。那么，根据这一等差数列连出的边应该构成 $\gcd(x_1,d)$ 个互不相关的子图，每个子图包含一个环（从某一个点 $i$ 出发不断 $+d$ 直到返回 $i$ 途经的所有点）。对于每一个子图，其边形如从每个点出发，依次连向在环上排在其后的第 $[1,L-1]$ 个点。同时，注意到环上最短路最小的结点一定不不会更新。因此，我们直接在这个位置断开。又由于子图形成区间更新的特性，直接使用单调队列维护其前面 $[1,L-1]$ 个点中 $dis_j-jd$ 最小的点即可。这样的单次复杂度就是 $O(n)$ 的。

尝试将不同等差数列跑出的结果进行合并。注意到最大的问题在于模数会发生改变。设之前的模数为 $pre$，新的模数为 $now$。首先，我们先来分析一次同余最短路跑出的结果到底是什么意思。对于一个 $dis_i$，其含义为所有的 $dis_i+k\cdot pre(k\ge 0)$ 都是可以被表示出来的。那么我们可以首先表示 $dis_i$ 是可以表示出来的，然后再通过每个点 $i$ 连向 $i+pre$ 的方式来表示 $dis_i+k\cdot pre$ 是可以被表示出来的。具体来说，首先先令$dis_i$ 更新 $dis’_{dis_i \ \bmod \ now}$，然后再连边 $i\rightarrow (i+pre)\bmod now$，按照上面的方式更新即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int INF=1e18;
char s[500005];
int nxt[500005];
int lg[1000005];
int dis[500005],tmp[500005];
vector<int>border[25];
void kmp(int n){
	for(int i=2;i<=n;i++){
		int p=nxt[i-1];
		while(p&&s[p+1]!=s[i]) p=nxt[p];
		if(s[p+1]==s[i]) p++;
		nxt[i]=p;
	}
	int x=nxt[n];
	while(x){
		border[lg[x]].push_back(n-x);
		x=nxt[x];
	}
	border[0].push_back(n);
}
int pos[500005];
int q[500005],ft=1,ed=0;
void upd(int bg,int x1,int d,int L,int m){
	int now=(bg+d)%m,mn=dis[bg],mnpos=bg;
	while(now!=bg){
		if(dis[now]<mn) mn=dis[now],mnpos=now;
		now=(now+d)%m;
	}
	int len=1;
	now=mnpos;
	pos[1]=now;
	now=(now+d)%m;
	while(now!=pos[1]){
		pos[++len]=now;
		now=(now+d)%m;
	}
	ft=1,ed=0;
	q[++ed]=1;
	for(int i=2;i<=len;i++){
		while(ed>=ft&&q[ft]<=i-L) ft++;
		if(ed>=ft) dis[pos[i]]=min(dis[pos[i]],dis[pos[q[ft]]]+d*(i-q[ft])+x1);
		while(ed>=ft&&dis[pos[i]]+i*d<=dis[pos[q[ed]]]+q[ed]*d) ed--;
		q[++ed]=i;
	}
}
void tyzdl(int x1,int d,int L,int p){
	int g=__gcd(p,d);
	for(int i=0;i<g;i++) upd(i,x1,d,L,p);
}
signed main(){
	lg[1]=0;
	for(int i=2;i<=1000000;i++) lg[i]=lg[i>>1]+1;
	int t,n,w;
	cin>>t;
	while(t--){
		cin>>n>>w;
		w-=n;
		scanf("%s",s+1);
		if(w<0){
			puts("0");
			continue;
		}
		for(int i=0;i<=20;i++) border[i].clear();
		for(int i=0;i<=n;i++) dis[i]=INF;
		dis[0]=0;
		kmp(n);
		int pre=-1;
		for(int i=0;i<=20;i++){
			if(border[i].size()){
				int now=border[i][0];
				if(pre!=-1){
					for(int i=0;i<=n;i++) tmp[i]=INF;
					for(int i=0;i<pre;i++){
						int ok=dis[i]%now;
						tmp[ok]=min(tmp[ok],dis[i]);
					}
					swap(tmp,dis);
					tyzdl(0,pre,2,now);
				}
				pre=now;
				if(border[i].size()>1) tyzdl(border[i][0],border[i][1]-border[i][0],border[i].size(),now);
			}
		}
		int ans=0;
		for(int i=0;i<pre;i++) if(dis[i]<=w) ans+=(w-dis[i])/pre+1;
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：CXY07 (赞：6)

> 题目链接：[P4156 [WC2016]论战捆竹竿](https://www.luogu.com.cn/problem/P4156)

> **本题解同步发布于 [My Blog](http://www.cxy07.blog/index.php/archives/118/)**

题意：

> 给定长度为 $n$ 的字符串 $S$，现有一个空串 $T$，每次可将 $S$ 去掉一个 $\text{border}$ 后接在 $T$ 上。问 $T$ 的长度可以是 $[n,w]$ 中的多少个数。

> $1\le n\le 5\times 10^5,1\le w\le 10^{18}$。

每次去掉一个 $\text{border}$ 加入，等价于加入一个 $\text{period}$。设 $S$ 的 $\text{period}$ 长度构成集合 $X$，取出 $X$ 中一个元素 $x$。

借用同余最短路的思想，设 $\text{mindis}_i$ 表示 $\bmod\ x=i$ 的所有长度中，能被 $X$ 中元素所拼出的最小长度。则能够被拼出的，长度 $\bmod\ x=i$ 的串长为 $\text{mindis}_i+k\times x$。可以通过该数组快速求出答案。

则现在需要做的是加速同余最短路的过程，快速求出 $\text{mindis}_i$。

考虑以下结论：

> 一个字符串 $S$ 的 $\text{border}$ 长度构成 $\mathcal{O}(\log n)$ 个等差数列。

而 $\text{period}$ 对应 $\text{border}$，所以也是等差数列。这启发我们将一个等差数列中的 $\text{border}$ 放在一起考虑。

对于一个等差数列 $a,a+b,a+2b\cdots a+kb$，若当前已经得到之前的等差数列所求出的，$\bmod\ a$ 意义下的 $\text{mindis}_i$，考虑如何快速用一个等差数列更新该数组。

在 $\bmod\ a$ 意义下，公差为 $b$ 的等差数列将所有 $[0,a-1]$ 中的元素划分为 $\gcd(a,b)$ 个等价类，每个等价类互不干扰。

对于一个等价类，找出其中 $\text{mindis}$ 值最小的位置 $p$，显然在这轮更新中，$\text{mindis}_p$ 不改变。则从 $p$ 开始，每次考虑使用等差数列中一个元素来更新后面的元素。

具体来说，对于一个下标为 $q$ 的位置，若 $q-p\le k$，则可以使用 $\text{mindis}_p+(q-p)\times b$ 来更新 $\text{mindis}_q$。（此处将在 $\bmod\ a$ 意义下的环展开，并认为 $p$ 是其中第一个元素，则 $q>p$）

这显然可以使用单调队列来实现。 

还剩下一个问题，求解完当前等差数列后，如何跳转到下一个等差数列？对于一个首项为 $a_1$ 的等差数列，求解完后 $\text{mindis}$ 是在 $\bmod\ a_1$ 的意义下，而下一个首项为 $a_2$ 的等差数列中需在 $\bmod\ a_2$ 意义下进行。

首先，可以使用 $\text{mindis}_x$ 转移到 $\text{mindis'}_{\text{mindis}_x\bmod a_2}$，同时，还需要考虑每一个长度为 $a_1$ 的转移，即 $\text{mindis}_x+k\times a_1$ 也可能更新 $\text{mindis'}$。这和上面是类似的问题，但是由于没有项数限制，所以甚至不用单调队列，记一个前缀 $\min$ 即可。

时间复杂度 $\mathcal{O}(T\times n\log n)$。

```cpp
//Code By CXY07
#include<bits/stdc++.h>
using namespace std;

//#define FILE
#define int long long
#define file(FILENAME) freopen(FILENAME".in", "r", stdin), freopen(FILENAME".out", "w", stdout)
#define randint(l, r) (rand() % ((r) - (l) + 1) + (l))
#define LINE() cout << "LINE = " << __LINE__ << endl
#define debug(x) cout << #x << " = " << x << endl
#define abs(x) ((x) < 0 ? (-(x)) : (x))
#define min(a, b) (a < b ? a : b)
#define inv(x) qpow((x), mod - 2)
#define lowbit(x) ((x) & (-(x)))
#define ull unsigned long long
#define pii pair<int, int>
#define LL long long
#define mp make_pair
#define pb push_back
#define scd second
#define vec vector
#define fst first
#define endl '\n'

const int MAXN = 5e5 + 10;
const int INF = 1.1e18;
const double PI = acos(-1);
const double eps = 1e-6;
//const int mod = 1e9 + 7;
//const int mod = 998244353;
//const int G = 3;
//const int base = 131;

int T, n, w, mod, Ans;
int fail[MAXN], period[MAXN], cnt;
int dis[MAXN];
char s[MAXN];

template<typename T> inline bool read(T &a) {
	a = 0; char c = getchar(); int f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {a = a * 10 + (c ^ 48); c = getchar();}
	a *= f;
	return 1;
}

template<typename A, typename ...B>
inline bool read(A &x, B &...y) {return read(x) && read(y...);}

int Gcd(int x, int y) {
	if(!y) return x;
	return Gcd(y, x % y);
}

void clear() {
	memset(dis, 0x3f, sizeof dis);
	memset(fail, 0, sizeof fail);
}

void GetPeriod() {
	fail[1] = 0, fail[0] = -1, cnt = 0;
	for(int i = 2, j; i <= n; ++i) {
		j = fail[i - 1];
		while((~j) && s[j + 1] != s[i]) j = fail[j];
		fail[i] = ++j;
	}
	for(int i = fail[n]; ~i; i = fail[i]) period[++cnt] = n - i;
} 

void _run(int p, int gap, int c) { // i % mod == p, mod...mod + gap * c
	static int t[MAXN], m, pos; m = 0, pos = -1;
	static int q[MAXN], head, tail; head = 1, tail = 0;
	for(int i = p; ;) {
		if(pos == -1 || dis[i] < dis[pos]) pos = i;
		i = (i + gap) % mod; if(i == p) break;
	}
	for(int i = pos; ;) {
		t[++m] = i; i = (i + gap) % mod;
		if(i == pos) break;
	} assert(m == mod / Gcd(gap, mod));
	q[++tail] = 1;
	for(int i = 2; i <= m; ++i) {
		while(head <= tail && i - q[head] > c) head++;
		if(head <= tail && i - q[head] <= c) dis[t[i]] = min(dis[t[i]], dis[t[q[head]]] + (i - q[head]) * gap + mod);
		while(head <= tail && dis[t[i]] - i * gap < dis[t[q[tail]]] - q[tail] * gap) tail--;
		q[++tail] = i;
	}
}

void run(int gap, int c) { // mod...mod + gap * c
	int lim = Gcd(gap, mod);
	for(int i = 0; i < lim; ++i) _run(i, gap, c);
}

void trans(int _new) { // mod -> _new
	static int _d[MAXN]; memset(_d, 0x3f, sizeof _d);
	static int t[MAXN], m;
	int lim = Gcd(mod, _new);
	for(int i = 0; i < mod; ++i) _d[dis[i] % _new] = min(_d[dis[i] % _new], dis[i]);
	for(int p = 0, pos, mn; p < lim; ++p) {
		pos = -1, m = 0, mn = INF;
		for(int i = p; ;) {
			if(pos == -1 || _d[i] < _d[pos]) pos = i;
			i = (i + mod) % _new; if(i == p) break;
		}
		for(int i = pos; ;) {
			t[++m] = i;
			i = (i + mod) % _new; if(i == pos) break;
		} assert(m == _new / lim);
		for(int i = 1; i <= m; ++i) {
			_d[t[i]] = min(_d[t[i]], mn + i * mod);
			mn = min(mn, _d[t[i]] - i * mod);
		}
	}
	mod = _new;
	memcpy(dis, _d, sizeof dis);
}

void calc() {
	int L = 1, R; mod = period[L];
	while(L < cnt) {
		R = L + 1;
		while(R + 1 <= cnt && period[R + 1] - period[R] == period[R] - period[R - 1]) R++;
		run(period[L + 1] - period[L], R - L);
		L = R + 1; if(L <= cnt) trans(period[L]);
	}
}

void solve() {
	Ans = 0;
	clear(); read(n), read(w), scanf("%s", s + 1); w -= n;
	GetPeriod(); dis[0] = 0; calc();
	for(int i = 0; i < mod; ++i)
		if(dis[i] <= w) Ans = Ans + (w - dis[i]) / mod + 1;
	printf("%lld\n", Ans);
}

signed main () {
#ifdef FILE
	freopen("P4156.in", "r", stdin);
	freopen("P4156.out", "w", stdout);
#endif
	read(T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：whiteqwq (赞：5)

看到初二的学弟已经开始卷这些了，非常恐怖。这就是我校初二真实实力吗？

[P4156 [WC2016]论战捆竹竿](https://www.luogu.com.cn/problem/P4156)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1813266)

## 题意

给定一个长度为 $n$ 的字符串 $S$，一开始有一个空串，每次可以将一个新的 $S$ 去掉一个 Border 后拼上去，求长度区间 $[n,w]$ 内有多少长度可以被拼出来。（$1\leqslant n\leqslant 5\times 10^5,1\leqslant 10^{18}$）

## 分析

妙妙题。

那么我们用 kmp 求出所有 Border，那么就可以得到所有周期 $c_{1\cdots k}$，我们的问题转化为求 $\sum_{i=1}^k a_ic_i$ 在区间 $[0,n-w]$ 中可以有多少取值。

我们考虑随便取一个不小于所有 $c_i$ 的模数 $mod$，对于所有 $i\in[0,mod-1]$，求出最小的 $k$ 使得 $k\equiv i\pmod{mod}$，然后就可以直接算了。

这明显是同余最短路模型，我们如果直接取所有 $c_i$ 的最大值为模数，让所有点 $x$ 都连若干条边到 $x+c_1,x+c_2,\cdots,x+c_k$ 跑一遍最短路复杂度就是 $O(n^2)$，有暴力分。

我们肯定不会把所有边建出来，于是我们考虑另一种暴力，对于每个 $c_i$ 单独将它的边更新，每次继承上一次的最短路数组。

但是如何更新仍然是问题，不难发现对于串长 $len$ 最短路图可以分成 $\gcd(n,len)$ 个部分，每个部分之间没有边相连，且每个部分事实上就是从每个位置开始每次向后走 $len$ 步的所有点，那么我们就可以把整个图变成若干个部分，每个部分从最小的位置一步步更新到后面直到重合就好了，但这样仍然是 $O(n^2)$ 的。

事实上，一个简单的结论可以大大降低复杂度：一个字符串所有的 Border 排序后，长度会形成 $O(\log n)$ 个等差数列。

这启发我们将等差数列放在一起跑最短路，具体地，我们发现对于一个首项为 $len$，公差为 $dif$，项数为 $tot$ 的等差数列，我们并不好处理首项，于是可以直接把首项当成一个公差为 $len$，项数为 $1$ 的等差数列的公差处理。

此时不难发现忽略了首项长度后，一个长度为 $tot$ 的等差数列就是向前连 $tot$ 条边，这个东西可以直接单调队列维护。

代码也很好写，时间复杂度：$O(Tn\log n)$。

## 代码

```
#include<stdio.h>
#include<iostream>
using namespace std;
const int maxn=500005;
int T,n,cs,pos;
int p[maxn],c[maxn];
long long w,ans;
long long dis[maxn],tmp[maxn];
pair<int,long long>q[maxn];
string s; 
int gcd(int a,int b){
	return b==0? a:gcd(b,a%b);
}
void getborder(){
	cs=0,p[0]=0;
	for(int i=1;i<n;i++){
		int j=p[i-1];
		while(j&&s[i]!=s[j])
			j=p[j-1];
		if(s[i]==s[j])
			j++;
		p[i]=j;
	}
	for(int i=p[n-1];i;i=p[i-1])
		c[++cs]=n-i;
	c[++cs]=n;
}
void getdis(int newpos,int len,int dif,int tot){
	int mod=c[newpos],g=gcd(dif,mod);
	for(int i=0;i<g;i++){
		int st=i;
		for(int j=(i+dif)%mod;j!=i;j=(j+dif)%mod)
			if(dis[j]<dis[st])
				st=j;
		int l=1,r=0;
		q[++r]=make_pair(0,dis[st]);
		for(int j=(st+dif)%mod,k=1;j!=st;j=(j+dif)%mod,k++){
			while(l<=r&&k-q[l].first>tot)
				l++;
			dis[j]=min(dis[j],q[l].second+1ll*(k-q[l].first)*dif+len);
			while(l<=r&&q[r].second+1ll*(k-q[r].first)*dif>=dis[j])
				r--;
			q[++r]=make_pair(k,dis[j]);
		}
	}
	pos=newpos;
}
void solve(){
	for(int i=0;i<c[1];i++)
		dis[i]=w+1;
	pos=1,dis[n%c[1]]=n;
	int l=1,r;
	while(l<cs){
		for(r=l+1;r<=cs&&c[r]-c[r-1]==c[l+1]-c[l];r++);
		r--;
		if(l<r)
			getdis(l,c[l],c[l+1]-c[l],r-l);
		if(r+1<=cs){
			for(int i=0;i<c[r+1];i++)
				tmp[i]=w+1;
			for(int i=0;i<c[l];i++)
				tmp[dis[i]%c[r+1]]=min(tmp[dis[i]%c[r+1]],dis[i]);
			for(int i=0;i<c[r+1];i++)
				dis[i]=tmp[i];
			getdis(r+1,0,c[l],1);
		}
		l=r+1;
	}
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%lld",&n,&w),cin>>s;
		getborder(),solve();
		ans=0;
		for(int i=0;i<c[pos];i++)
			if(dis[i]<=w)
				ans+=(w-dis[i])/c[pos]+1;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：i207M (赞：5)

不知道为啥BZOJ过了，~~UOJ被Hack了~~（知道哪错了，不能跑$\log$次Dijkstra，还要加上取模优化），~~洛谷必须特判小数据才能A...~~（我是洛谷最优解哦）

之前做过同余类最短路用单调队列优化的题，也知道border形成了log个等差数列，就是太菜了没想出来这道题。zz错误调了一下午...

首先这道题的$O(n^2)$暴力很好想：我们就暴力跑同余类最短路。

然后我们要挖掘border的性质——**border形成了log个等差数列！** 证明的话画图就明白了，在每次等差数列切换的时候长度至少$\times 2$

我们考虑一组等差数列，形成的出边形如$x,x+d,...,x+(len-1)\times d$。诶，你发现这个转移是类似“区间最小值”的转移，或者说类似多重背包的转移。我们注意到这形成了了$\gcd(d,md)$个环，环之间独立。环内部，最小的点不会被其他点更新，那么我们以它为起点，通过单调队列求最短路即可。

如何从$\bmod~p_1$剩余系转到$\bmod~p_2$剩余系呢？我们先把记录的$p_1$个信息转到$p_2$上，然后从一个点出发可以任意$+p_1$，所以我们再跑一遍同余类最短路，这次不需要维护单调队列了，只需要维护前缀最小值就行。

```cpp
#define N 500005
#define pli pair<LL,int>
const LL llinf=0x3f3f3f3f3f3f3f3f;
LL d[N];
int n;
LL h;
char s[N];
int nx[N],e[N],cnte;
int md;
il int fit(const int x) {return x>=md?x-md:x;}
LL solve()
{
	if(h<n) return 0;
	for(ri i=2,j=0; i<=n; ++i)
	{
		while(j!=-1&&s[j+1]!=s[i]) j=nx[j];
		nx[i]=++j;
	}
	if(!nx[n]) return h/n;
	e[cnte=1]=nx[n];
	while(e[cnte]) e[cnte+1]=nx[e[cnte]],++cnte;
	for(ri i=1; i<=cnte; ++i) e[i]=n-e[i];
	mem(d,0x3f); d[n%e[1]]=n;
	int premd=0;
	for(ri l=1; l<=cnte; ++l)
	{
		md=e[l];
		if(premd)
		{
			static LL d2[N];
			memcpy(d2,d,sizeof(LL)*premd);
			memset(d,0x3f,sizeof(LL)*md);
			for(ri i=0; i<premd; ++i) if(d2[i]<llinf) ckmin(d[d2[i]%md],d2[i]);
			int g=__gcd(premd,md);
			for(ri r=0; r<g; ++r)
			{
				LL mn=d[r]; int mnk=r;
				for(ri p=fit(r+g); p!=r; p=fit(p+g))
					if(ckmin(mn,d[p])) mnk=p;
				for(ri p=fit(mnk+premd),i=1; p!=mnk; p=fit(p+premd),++i)
				{
					ckmin(d[p],mn+(LL)i*premd);
					ckmin(mn,d[p]-(LL)i*premd);
				}
			}
		}
		if(l==cnte) {premd=md; break;}
		int r=l+1,c=e[r]-e[l],g=__gcd(c,md);
		while(r<n&&e[r+1]-e[r]==c) ++r;
		int len=r-l;
		for(r=0; r<g; ++r)
		{
			LL mn=d[r]; int mnk=r;
			for(ri p=fit(r+g); p!=r; p=fit(p+g))
				if(ckmin(mn,d[p])) mnk=p;
			static pli q[N]; int hd,tl;
			q[hd=tl=1]=mp(mn,0);
			for(ri p=fit(mnk+c),i=1; p!=mnk; p=fit(p+c),++i)
			{
				while(hd<=tl&&q[hd].se<i-len) ++hd;
				ckmin(d[p],q[hd].fi+md+(LL)i*c);
				while(hd<=tl&&q[tl].fi>=d[p]-(LL)i*c) --tl;
				q[++tl]=mp(d[p]-(LL)i*c,i);
			}
		}
		l+=len,premd=md;
	}
	LL ans=0;
	for(ri i=0; i<premd; ++i)
		if(d[i]<=h) ans+=1+(h-d[i])/premd;
	return ans;
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	int T; in(T);
	nx[0]=-1;
	while(T--)
	{
		in(n,h);
		scanf("%s",s+1);
		out(solve());
	}
	return 0;
}
```

---

## 作者：clamee (赞：3)


题目：

> 竹林里有无数根完全一样的短竹子,每一根竹子由 n 节组成,每一节都被染上了颜色,竹子不可以颠倒。
> 每次你可以选择一根短竹子,短竹子底端若干节(可以是 0节)与竹竿的最上面若干节对应地一节一节捆起来,而短竹子前面剩下的节伸出去,这样就得到了一根更长的竹竿。小 W 对竹竿的审美要求很高,他捆竹竿时有一个癖好:如果两根竹子的某两节被捆在了一起,那么它们的颜色必须相同。现在请你求出在竹竿长度超过 w 的情况下,小 W 可以捆出多少种长度不同的竹竿。其中,竹竿的长度指从底端到顶端的
> 竹子的节的个数。
> $n \le 5 \cdot 10^5 ,w \le 10^{18}$。

众所周知 $border$ 有一个性质：

字符串  $S$ 的所有 border 可以被划分成不超过 $\log_2|S|$ 段，每一段的长度是等差数列。

假设现在有 $k$ 个等差数列。

不妨，先考虑其中的一个：$x_1,x_1+d_1,x_1+2d_1,\cdots,x_1+len*d_1$。

考虑求出在 $\bmod x_1$ 意义下的同余最短路。其实可以发现，所有的转移会将序列分为 $\gcd(x_1,d_1)$ 个环。从环上 $dis$ 最小的点开始转移即可。

考虑现在新加入了：$x_2,x_2+d_2,x_2+2d_2,\cdots,x_2+len*d_2$。

那么现在的模数要切换到 $x_2$。可以发现首先有  $dis'_{dis_i \bmod x2}=dis_i$ 但这样转移是会漏情况的，因为还有 $dis_i+k*x_1$ 的转移。这样直接再在 $\bmod x_2$ 意义下跑一遍同余最短路就行了。

之后继续像之前那样考虑 $\bmod x_2$ 意义下的同余最短路即可。

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define rg register
#define int long long
il int read()
{
	int k=1,re=0;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
il void write(int x)
{
	if(x<0)return putchar('-'),write(-x),void();
	if(x<=9)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}
int n,T,W,nxt[500005],f[500005],las;
char s[500005];
int b[500005],lb;
const int M=998244353;
void getb()
{
	int k=0;
	for(rg int i=2;i<=n;i++)
	{
		while(k&&s[i]!=s[k+1])k=nxt[k];
		nxt[i]=(s[i]==s[k+1])?++k:0;
	}
	while(k)
	{
		b[++lb]=n-k;
		k=nxt[k];
	}
}
int gcd(int u,int v)
{
	if(!v)return u;
	return gcd(v,u%v);
}
int st[1000005],ls,p[500005],Q[500005],lq,w[500005],tl,hd,pos[500005];
void tomod(int x)
{
	int g=gcd(x,las);
	for(rg int i=0;i<las;i++)
		p[i]=f[i];
	for(rg int i=0;i<x;i++)
		f[i]=0x3f3f3f3f3f3f3f3f;
	for(rg int i=0;i<las;i++)
		f[p[i]%x]=min(p[i],f[p[i]%x]);
	for(rg int i=0;i<g;i++)
	{
		ls=0;st[++ls]=i;int now=(i+las)%x;
		while(st[1]!=now)
		{
			st[++ls]=now;
			now=(now+las)%x;
		}
		for(rg int j=1;j<=ls;j++)
		{
			st[ls+j]=st[j];
		}
		ls<<=1;
		for(rg int j=2;j<=ls;j++)
			f[st[j]]=min(f[st[j-1]]+las,f[st[j]]);
	}
	las=x;
}
void sol(int x,int sz,int d)
{
	int g=gcd(x,d);
	tomod(x);
	
	if(d<0)return;
	for(rg int i=0;i<g;i++)
	{
		ls=lq=0;Q[++lq]=i;int now=(i+d)%x,tt=1;
		while(Q[1]!=now)
		{
			if(f[Q[tt]]>f[now])tt=lq+1;
			Q[++lq]=now;now=(now+d)%x;
		}
		for(rg int j=tt;j<=lq;j++)
			st[++ls]=Q[j];
		for(rg int j=1;j<tt;j++)
			st[++ls]=Q[j];
		hd=tl=0;
		w[0]=f[st[1]]-d;pos[0]=1;
		for(rg int j=2;j<=ls;j++)
		{
			while(hd<=tl&&pos[hd]<j-sz)hd++;
			if(hd<=tl)f[st[j]]=min(f[st[j]],w[hd]+j*d+x);
			while(hd<=tl&&w[tl]>f[st[j]]-j*d)tl--;
			w[++tl]=f[st[j]]-j*d;pos[tl]=j;
		}
	}
}
signed main()
{
	T=read();
	while(T--)
	{
		n=read();W=read()-n;
		scanf("%s",s+1);lb=0;
		getb();memset(f,0x3f,sizeof(f));memset(nxt,0,sizeof(nxt));las=n;
		f[0]=0;b[lb+1]=0;
		for(rg int i=1,j=1;i<=lb;i=j)
		{
			while(b[i+1]-b[i]==b[j+1]-b[j])j++;
			sol(b[i],j-i-1,b[i+1]-b[i]);
		}
		int ans=0;
		for(rg int i=0;i<las;i++)
		{
			if(f[i]<=W)
				ans+=(W-f[i])/las+1;
		}
		write(ans);puts("");
	}
}
```



---

## 作者：云浅知处 (赞：2)

考虑找到字符串的所有周期，设他们是 $a_1,\cdots,a_k$，那么相当于要求出在区间 $[0,w-n]$ 中有多少种 $\sum a_ix_i$。

这是同余最短路的经典问题，但直接做复杂度至少为 $O(n^2)$，无法通过。

注意到一个字符串的所有周期可以被划分为 $O(\log n)$ 段等差数列，因此 $a$ 同样也可以被划分为 $O(\log n)$ 段等差数列。

我们考虑对每个等差数列，依次计算他对最短路的贡献。

设这个等差数列形如 $b_k=a+kd,k=0,1,\cdots,r$，我们在 $\bmod a$ 意义下做同余最短路。那么这样以来，每个点 $u$ 就会向 $(u+kd)\bmod a,k=0,1,\cdots, r$。这样会形成 $\gcd(d,a)$ 个环，我们可以对每个环分别考虑。设环长为 $L=\frac{a}{\gcd(a,d)}$。

考虑环上当前 $\text{dis}$ 值最小的点 $p$，注意到**不可能出现跨过 $p$ 的松弛操作**（否则以 $p$ 为起点进行松弛一定更优）。因此我们可以从点 $p$ 处断开整个环，并忽略原图中所有跨过 $p$ 的边。这样原图就变成了有向无环图，且每个点会向他之后的 $r$ 个点连边，从 $i$ 向 $j$ 连的边的边权为 $a+(j-i)\times d$。

因此，我们相当于要对每个 $u$，算出 $x=u-1,\cdots,u-r$ 中最小的 $f_x+(u-x)\times d+a$（其中 $f_x$ 表示 $x$ 点的最短路），发现只需要用单调队列维护 $f_x-x\times d+a$ 的最小值即可。这样对一个等差数列计算贡献的时间为 $O(n)$。

考虑怎么从一个等差数列转换到另一个等差数列上。设两个等差数列分别形如 $a_1+kd_1$ 与 $a_2+kd_2$，相当于我们要通过「走到 $\bmod a_1=i$ 的点所需的最小代价 $f_i$（$0\le i<a_1$）」来求出另一边当模数为 $a_2$ 时的答案 $g_i$。我们注意到，只要用 $f_i+k\times a_1$ 去更新所有的 $g[(f_i+k\times a_1)\bmod a_2]$，就能求出正确的 $g$。类似地，我们只需要分割成 $\gcd(a_1,a_2)$ 个环，在每个环中从最小值开始，维护前缀最小值从前往后更新即可。

对于一组数据，时间复杂度为 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>

#define ll long long

using namespace std;

inline ll read(){
	ll x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int N=5e5+5;
int A,D,M,n,mod;
char s[N];
ll f[N],W;
bool isborder[N];

void Assert(bool c,int L=0){if(!c){cout<<"Assertion Failed at "<<L<<endl;exit(0);}}

int getmod(int l,int r){
	A=-1;
	for(int i=r;i>=l;i--)if(isborder[i]){A=i;break;}
	if(A==-1)return -1;
	D=-1;
	for(int i=A-1;i>=l;i--)if(isborder[i]){D=A-i;break;}
	if(D==-1)return 0;
	for(int i=l;i<=r;i++)if(isborder[i]){M=(A-i)/D;break;}
	for(int i=l;i<=r;i++)if(isborder[i])Assert(i%D==A%D&&(A-i)/D<=M,1);
	return 1;
}

int C,L;
int gcd(int x,int y){return y?gcd(y,x%y):x;}

ll g[N],h[N<<1];
deque<int>q;

void cmin(ll &x,ll v){x=min(x,v);}
bool chk(int i,int j){// i > j ?
	return g[i]-1ll*i*D<g[j]-1ll*j*D;
}
void solvecirc(){
	int minpos=1;
	for(int i=1;i<=L;i++)if(g[i]<g[minpos])minpos=i;
	for(int i=1;i<=L;i++)h[i]=h[i+L]=g[i];
	for(int i=minpos;i<=minpos+L-1;i++)g[i-minpos+1]=h[i];
	while(q.size())q.pop_front();q.push_front(1);
	for(int i=2;i<=L;i++){
		while(q.size()&&q.back()<i-M)q.pop_back();
		int j=q.back();cmin(g[i],g[j]+1ll*(i-j)*D+A);
		while(q.size()&&chk(i,q.front()))q.pop_front();q.push_front(i);
	}
	for(int i=minpos;i<=minpos+L-1;i++)h[i]=g[i-minpos+1];
	for(int i=1;i<=L;i++)g[i]=min(h[i],h[i+L]);
}
void calcmod(){
	C=gcd(A,D),L=A/C;
	for(int i=0;i<C;i++){
		int p=i;
		for(int j=1;j<=L;j++)g[j]=f[p],p=(p+D)%A;
		solvecirc();
		for(int j=1;j<=L;j++)f[p]=g[j],p=(p+D)%A;
	}
}

const ll INF=1e18+1;
void cmod(int now){
	for(int i=0;i<now;i++)g[i]=INF;C=gcd(now,mod),L=now/C,A=0,M=L-1,D=mod;
	for(int i=0;i<mod;i++)h[i]=f[i],f[i]=INF;
	for(int i=0;i<mod;i++)cmin(f[h[i]%now],h[i]);
	for(int i=0;i<C;i++){
		int p=i;
		for(int j=1;j<=L;j++)g[j]=f[p],p=(p+D)%now;
		solvecirc();
		for(int j=1;j<=L;j++)f[p]=g[j],p=(p+D)%now;
	}
	mod=now;
}

ll getans(){
	ll res=0;
	for(int i=0;i<mod;i++){
		ll x=(ll)(f[i]/mod),y=(ll)(W/mod-(W%mod<i));
		if(x<=y)res+=y-x+1;
	}
	return res;
}

int fail[N];

void work(int l,int r){
	int f=getmod(l,r);
	if(f==-1)return ;
	A=n-A;
	int tA=A,tD=D,tM=M;
	cmod(A);
	if(f==0)return ;
	A=tA,D=tD,M=tM;
	calcmod();
}

void solve(){
	n=read(),W=read()-n;
	for(int i=1;i<=n;i++){
		char c=getchar();while(c<'a'||c>'z')c=getchar();
		s[i]=c;
	}
	for(int i=0;i<N;i++)f[i]=g[i]=h[i]=h[i+N]=INF,fail[i]=0,isborder[i]=0;
	mod=A=D=M=C=L=0;
	for(int i=2,j=0;i<=n;i++){
		while(j&&s[j+1]!=s[i])j=fail[j];
		if(s[j+1]==s[i])j++;fail[i]=j;
	}
	int p=n;while(p)isborder[p]=1,p=fail[p];
	mod=n;f[0]=0;
	for(int i=0;(1<<i)<n;i++)work(1<<i,min(n-1,1<<(i+1)));
	cout<<getans()<<endl;
}

signed main(void){

#ifdef YUNQIAN
	freopen("123.in","r",stdin);
	freopen("123.ans","w",stdout);
#endif

	int tt=read();while(tt--)solve();

	return 0;
}
```

---

## 作者：KafuuChinocpp (赞：2)

## 前置知识

1.一个字符串的所有 border 排序后，一定存在一种划分子序列的方案使得其被划分为 $O(logn)$ 个等差数列。

在证明之前我们需要知道几个关于 border 和周期的性质：

性质一：如果 $s$ 存在一个长度为 $x$ 的 border ，那么 $s$ 存在一个长度为 $|s|-x$ 的周期。（由定义可得）

性质二：如果 $s$ 存在两个周期 $x,y$ ，并且 $x+y\le |s|$ ，那么 $s$ 一定存在一个周期为 $\gcd(x,y)$ 。

证明：

不妨设 $x<y$ ，由周期的定义我们有 $s_i=s_{i+x}=s_{i+y}$ ，则 $s_{i}=s_{i+y-x}(x+1\le i\le |s|-y+x)$ ，由于 $x+y\le |s|$ ，因此 $x\le \lfloor\tfrac{|s|}{2}\rfloor$ ，那么 $i$ 的范围一定包括了 $[\lfloor\tfrac{|s|}{2}\rfloor,|s|-y+x]$ ，如果我们再用 $s_i=s_{i-x}=s_{i-y}$ 进行一次推导然后和上述范围合并，可以发现 $i$ 的范围一定可以覆盖整个字符串，相对的 $x+y>|s|$ 时可能无法覆盖整个字符串，这样我们证明了 $y-x$ 也是字符串的一个周期。

我们令 $y-x$ 作为新的 $y$ ，容易发现此时仍然满足 $x+y\le |s|$ ，如果继续递归处理，可以发现这是一个更相减损术求解 gcd 的过程，不难发现 $\gcd(x,y)$ 也是 $s$ 的一个周期。

假设当前字符串 $s$ 存在两个 border 分别为 $x,y$ ，满足 $x,y\ge \tfrac{|s|}{2}$ 并且 $y$ 为 $s$ 最大的 border ，设 $p=|s|-x,q=|s|-y$ ，显然 $p+q\le |s|$ ，那么有 $\gcd(p,q)$ 为 $s$ 的一个周期，由于 $\gcd(p,q)\le q$ 并且 $q$ 为最小的周期，因此 $\gcd(p,q)=q$。

由于 $k\times q$ 也是 $s$ 的周期，并且 $q|p$ ，可以发现所有长度小于等于 $\tfrac{|s|}{2}$ 的周期构成一个等差数列，也就是说所有长度大于等于 $\tfrac{|s|}{2}$ 的 border 构成一个等差数列。

容易发现排序后的 border 可以划分为 $O(logn)$ 个等差数列。

2.同余最短路（P3403 跳楼机）

题目大意：设 $p=k_1x+k_2y+k_3z(k_1,k_2,k_3\ge 0)$ ，求解小于等于 $lim$ 的 $p$ 的个数。

设 $f_i$ 表示 $k_1=0$ 时，最小的可以被表示的 $mod\ x=i$ 的数，显然有转移：

$$
f_{i}+y\to f_{(i+y)mod\ x}\\
f_{i}+z\to f_{(i+z)mod\ x}
$$

可以发现这是一个最短路的形式，可以用 Dijikstra 进行转移。

容易发现答案为 $\sum_{i=0}^{x-1}\lfloor\tfrac{lim-f_i}{x}\rfloor+1$ 。

## 题解

我们令 $w=w-|s|$ ，设 $x$ 为 $s$ 的所有周期，设 $p=\sum k_ix_i$，那么我们需要求解 $p\le w$ 时 $p$ 的数目。

首先有一个暴力的同余最短路的思路，可以 $O(n^2logn)$ 解决。

考虑利用字符串周期的性质，我们将 $x$ 进行分组，每一个组中的 $x_i$ 构成一个等差数列，设 $first$ 为等差数列的首项， $diff$ 为公差， $len$ 为项数个数 $-1$ ，考虑将同余最短路中的模数设为 $first$ ，考虑求解这个组中的 $f$ 值。

容易发现对于一个等差数列 $first+k\times diff$ ，在 $mod\ first$ 时进行连边，会形成 $\gcd(diff,first)$ 个环，每一个环之间互不影响，可以将环单独拿出进行转移，对于一个环，由于 $f$ 值最小的地方一定不会被更新，因此我们从这个地方将环断开，并将环上的点依次放进一个数组 $pos$ 中，对于 $pos_i$ 和 $pos_j$ ，可以发现当 $i-j\le len$ 时 $pos_j$ 可以对 $pos_i$ 产生贡献，贡献为 $f_{pos_j}+first+diff\times (i-j)$ ，显然可以拆成 $f_{pos_j}-j\times diff+first+i\times diff$ ，将 $f_{pos_j}-j\times diff$ 用单调队列进行维护即可。

然后考虑两个等差数列的合并，对于两个模数 $now\_mod,mod$ ，当前 $f$ 的模数为 $now\_mod$ ，我们需要将模数变为 $mod$ ，首先将 $f$ 复制到 $tmp$ 数组中，那么显然有转移：

$$
tmp_i\to f_{tmp_i \% mod}
$$

由于在计算等差数列时模数为 $now\_mod$ ，改变模数后我们需要考虑 $now\_mod$ 边所造成的贡献，仍然将这些边组成的 $\gcd(now\_mod,mod)$ 个环单独拿出来，可以将环断开形成的链倍长后直接转移。

## code

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int max1 = 5e5;
int T, n;
long long w, ans;
char s[max1 + 5];
int pi[max1 + 5], border[max1 + 1], cnt;
int now_mod;
long long f[max1 + 5], tmp[max1 + 5];
long long q[max1 + 5];
int pos[max1 * 2 + 5], head, tail;
int seq[max1 + 5], top;
inline int Gcd ( int a, int b )
{
    int t;
    while ( b ) { t = a; a = b; b = t % b; }
    return a;
}
inline void KMP ()
{
    pi[1] = 0;
    for ( int i = 2, j = 0; i <= n; i ++ )
    {
        while ( j && s[i] != s[j + 1] ) j = pi[j];
        if ( s[i] == s[j + 1] ) ++j;
        pi[i] = j;
    }
    int now = pi[n];
    cnt = 0;
    while ( now )
    {
        border[++cnt] = n - now;
        now = pi[now];
    }
    border[++cnt] = n;
    return;
}
inline void Change_Mod ( int mod )
{
    memcpy(tmp, f, sizeof(long long) * ( now_mod + 2 ));
    memset(f, 0x3f, sizeof(long long) * ( mod + 2 ));
    for ( int i = 0; i < now_mod; i ++ ) f[tmp[i] % mod] = min(f[tmp[i] % mod], tmp[i]);
    int p = Gcd(now_mod, mod);
    for ( int i = 0; i < p; i ++ )
    {
        top = 0;
        pos[++top] = i;
        int x = ( i + now_mod ) % mod;
        while ( x != pos[1] ) pos[++top] = x, x = ( x + now_mod ) % mod;
        for ( int j = top + 1; j <= top * 2; j ++ ) pos[j] = pos[j - top];
        top = top << 1;
        for ( int j = 2; j <= top; j ++ ) f[pos[j]] = min(f[pos[j]], f[pos[j - 1]] + now_mod);
    }
    now_mod = mod;
    return;
}
inline void Solve ( int first, int diff, int len )
{
    int p = Gcd(first, diff);
    Change_Mod(first);
    if ( diff < 0 ) return;
    for ( int i = 0; i < p; i ++ )
    {
        top = 0;
        pos[++top] = i;
        int x = ( i + diff ) % first;
        while ( x != pos[1] ) pos[++top] = x, x = ( x + diff ) % first;
        int min_pos = 1;
        for ( int j = 1; j <= top; j ++ ) if ( f[pos[j]] < f[pos[min_pos]] ) min_pos = j;
        for ( int j = min_pos; j <= top; j ++ ) seq[j - min_pos + 1] = pos[j];
        for ( int j = 1; j < min_pos; j ++ ) seq[j + top - min_pos + 1] = pos[j];
        head = tail = 1, pos[1] = 1, q[1] = f[seq[1]] - diff;
        for ( int j = 2; j <= top; j ++ )
        {
            while ( head <= tail && pos[head] + len < j ) ++head;
            if ( head <= tail ) f[seq[j]] = min(f[seq[j]], q[head] + 1ll * j * diff + first);
            while ( head <= tail && q[tail] >= f[seq[j]] - 1ll * j * diff ) --tail;
            q[++tail] = f[seq[j]] - 1ll * j * diff, pos[tail] = j;
        }
    }
    return;
}
inline void Work ()
{
    scanf("%d%lld%s", &n, &w, s + 1);
    if ( w < n ) { printf("0\n"); return; }
    w = w - n;
    KMP();
    now_mod = n;
    memset(f, 0x3f, sizeof(long long) * ( now_mod + 2 ));
    f[0] = 0;
    border[cnt + 1] = 0;
    for ( int i = 1, j = 1; i <= cnt; i = j )
    {
        while ( border[i + 1] - border[i] == border[j + 1] - border[j] ) ++j;
        Solve(border[i], border[i + 1] - border[i], j - i - 1);
    }
    ans = 0;
    for ( int i = 0; i < now_mod; i ++ ) if ( f[i] <= w ) ans += ( w - f[i] ) / now_mod + 1;
    printf("%lld\n", ans);
    return;
}
int main ()
{
    scanf("%d", &T);
    while ( T -- ) Work();
    return 0;
}
```

---

## 作者：eastcloud (赞：0)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17272391.html)

## 题意描述

给定一个字符串 $s$，你初始拥有一个空串 $t$，每次可以选择这个字符串的一个 Border，去掉它后接在 $t$ 的后面，操作后 $s$ 不变，给出一个上限 $w$，求出在 $[1,w]$ 中有多少长度可以被拼出。

## 题目分析

首先可以看出，抛开字符串，把每个可以拼上去的长度筛选出来，问题就转化为有 $k$ 个不同的数，通过加法操作可以表示出范围内的多少个数，这显然是一个同余最短路的问题。

模仿通常同余最短路的操作，从每个点延伸 $k$ 条边后跑一边最短路即可，但是这样只能得到 30 分，原因在于边数过大。

我们考虑优化，既然边这么多，能不能去掉一些没有用的部分，反过来考虑字符串 Border 的一些性质，注意到周期好像是个很有用的部分，能把冗余部分压缩，我们试图从这方面考虑。

对于周期和 Border，我们有一个很显然的性质：每个长度大于  $\frac{|s|}{2}$ 的 Border 剩下那部分如果长度是 $|s|$ 的因子，那么它是原字符串的一个周期，而任意一个周期与一个最短周期，记为 $p$，$q$（$p>q$），$\gcd(p,q)$ 也是原字符串的一个周期。

因为 $p$ 和 $q$ 的最大公因数也是一个周期，而 $\gcd(p,q)\leq\min(p,q)$，从上述定义可以看出 $q=\gcd(p,q)$，因此 $q|p$，当 $p$ 所对应的 Border 取最小的时，即 $p$ 最大，我们就可以发现 $q$ 复制后只要不超过 $p$，一定对应一个 Border，**而这些 Border 刚好组成一个等差数列**。

因为所有的周期都能由最小周期组成，所以所有大于 $\frac{|s|}{2}$ 的 Border 都构成一个等差数列，而把小于的最大的 Border 提出来变成一个新字符串继续递归，可以得到最多不超过 $\log(n)$ 条等差数列。

这个性质很有用，我们可以把每条数列单独拉出来跑同余最短路，优化边数即可达到目的。

## 具体实现

把最小的当成模数，每个点就只有一条出边，整个图总共会形成  $\gcd(a,d)$ 个简单环（$a$ 为 最小值，$d$，为公差）。

接着把环分离，从最小值开始转圈跑最短路，最后跑下一条等差数列的时候改变一下模数即可（如果从小到大跑只用把每个最小值所在位置，改成模新模数的位置，并查看前面会不会对后面增加的同余类产生影响即可）。

一共有 $\log(n)$ 条数列，每条数列跑最短路复杂度为 $O(n)$，整体时间为 $ O(n \log n)$。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
#include<cstring>
#include<queue>
#define N 500005
using namespace std;
typedef unsigned long long ll;
ll cnt,bor[N<<3],nex[N<<3];
ll res[N<<3];
ll dis[N<<3],lim;
struct Node{
	ll num,val;
};
ll top,Q[N<<3],q2[N<<3];
char s[N];
ll gcd(ll x,ll y){
	if(!y) return x;
	else return gcd(y,x%y);
}
void get_border(ll n){
	ll ans=0;
	for(ll i=2;i<=n;i++){
		while(ans && s[ans+1]!=s[i]) ans=nex[ans];
		if(s[ans+1]==s[i]) ans++;
		nex[i]=ans;
	}
	
	while(ans){bor[++cnt]=n-ans;ans=nex[ans];}
	
	bor[++cnt]=n;
}
void rfs(ll len){
	ll siz=gcd(lim,len);
	for(ll i=0;i<lim;i++)res[i]=dis[i];
	for(ll i=0;i<len;i++)dis[i]=0x7f7f7f7f7f7f7f7f;
	for(ll i=0;i<lim;i++){
		ll tmp=res[i]%len;
		dis[tmp]=min(dis[tmp],res[i]);
	}
	for(ll i=0;i<siz;i++){
		top=0;Q[++top]=i;ll tmp=(i+lim)%len;
		while(tmp!=i){Q[++top]=tmp;tmp=(tmp+lim)%len;}
		for(ll j=top+1;j<=top*2;j++) Q[j]=Q[j-top];
		for(ll j=2;j<=(top<<1);j++) dis[Q[j]]=min(dis[Q[j]],dis[Q[j-1]]+lim);
	}
	lim=len;
	
}
void update(ll a,ll d,ll num){
	if(d<0) return;
	ll siz=gcd(lim,d);
	for(ll i=0;i<siz;i++){
		top=0;ll tmp=(i+d)%lim;Q[++top]=i;
		while(tmp!=i){Q[++top]=tmp;tmp=(tmp+d)%lim;}
		tmp=1;
		for(ll j=2;j<=top;j++) if(dis[Q[j]]<dis[Q[tmp]]) tmp=j;
		for(ll j=1;j<=top;j++) res[j]=Q[j];
		for(ll j=tmp;j<=top;j++) Q[j-tmp+1]=res[j];
		for(ll j=1;j<tmp;j++) {Q[j+(top-tmp+1)]=res[j];}
		ll head=1,tail=1;q2[1]=1;
		for(ll j=2;j<=top;j++){
			
			while(head<=tail && j-q2[head]>num) head++;
			
			dis[Q[j]]=min(dis[Q[j]],dis[Q[q2[head]]]+a+d*(j-q2[head]));
			
			while(tail>=head && dis[Q[q2[tail]]]+d*(j-q2[head])>dis[Q[j]]) tail--;
			q2[++tail]=j;
			
		}
	}
}
ll solve(ll n,ll w){
	ll L=1;
	while(L<=cnt){
		ll R=L;
		while(bor[R+1]-bor[R]==bor[L+1]-bor[L]) R++;
		rfs(bor[L]);
		if(R>cnt) {L=R;continue;}
		update(bor[L],(L==R?0:bor[L+1]-bor[L]),R-L);
		L=R;
	}
	ll ans=0;
	for(ll i=0;i<lim;i++){
		if(dis[i]>w) continue;
		ans+=(w-dis[i])/lim+1;
	}
	return ans;
}
int main(){
	ll t;
	cin>>t;
	while(t--){
		ll n,w;
		cin>>n>>w>>(s+1);if(w<n){cout<<0<<endl;continue;}cnt=0;w-=n;
		lim=n;dis[0]=0;
		get_border(n);
		cout<<solve(n,w)<<endl;
		for(ll i=0;i<n;i++) dis[i]=0x7f7f7f7f7f7f7f7f;
	}
}
```




---

## 作者：chenzida (赞：0)

这题太难了，看题解看了我一下午。。。

首先看到字符串前后缀匹配，肯定能想到 $\text{kmp}$，我们那么答案就是所有 $[0,w-n]$ 的数切可以被 $\sum_{i=1}^k t_i\times x_i$，其中一个数 $\in [1,n]$ 在 $t_i$ 中的条件是 $i$ 是题目中给的字符串的周期。如果暴力同余最短路的话最坏是 $n^2$ 的。

所以我们考虑优化，用一个定理，也就是对于一个字符串所有周期的，可以分成 $\log$ 级别份，其中每一份都是连续的且是等差的，这个证明其他题解讲的很详细了，我主要说之后的做法。

也就是说，对于一个等差数列我们要更新 $dis$ 数组，假设这个等差数列的公差是 $d$，那么我们假设连 $x\rightarrow (x+d)$，并且如果大于 $mod$ 就取模（其实是 (x+d)%mod，但是 $\LaTeX$ 打不出来），那么一定会形成 $\gcd(mod,d)$ 个环，我们对于每个环分别处理。

那么对于一个环，我们要怎么处理呢？首先我们发现这些环是两两互不干扰的，所以我们的更新是在一条链上的（我们将环从 $dis$ 值最小的那个点断开，因为没有其他点能更新那个 $dis$ 最小的那个点）然后我们就不再是最短路了，而是转化成了一个序列上的 $dp$，发现有一个长度为 $l$ 的限制（$l$ 表示那个等差数列最大项是 $x+l\times d$），所以考虑单调队列优化。

然后还有一个问题就是它的模数是会改变的。很明显可以用 $dis_i$ 更新 $Dis_{i\ mod\ new}$，其中 $mod$ 代表 %，而 $new$ 表示新的模数。然后发现还可以继续更新，所以可以直接再跑一遍同余最短路。注意由于这回没有 $l$ 的限制了，可以不用单调队列了，直接复制一遍然后跑就好了。

最后总结一下，我们的计算等差的函数分为 $4$ 部分，分别是更换模数，找到最小点，拆环变序列，单调队列 $dp$。

代码如下：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int NR=1e6+10;
const int INF=0x3f3f3f3f3f3f3f3fll;
void Min(int& x,int y){x=min(x,y);}
void Max(int& x,int y){x=max(x,y);}
int n,w;
char a[NR];
int pi[NR];
int gcd(int a,int b){
	return !b?a:gcd(b,a%b);
}
int getnxt(int x,char ch){
	if(a[x+1]==ch)return x+1;
	return x?getnxt(pi[x],ch):0;
}
int dis[NR];
int num[NR],tot;
int now,res[NR];
int q[NR],all,Q[NR];
void Init()
{
	memset(num,0,sizeof(num));tot=0;
	memset(res,0,sizeof(res));
	memset(q,0,sizeof(q));
	memset(Q,0,sizeof(Q));
	memset(pi,0,sizeof(pi));
}
void tomod(int x)
{
	int cnt=gcd(x,now);
	for(int i=0;i<now;i++)res[i]=dis[i];
	for(int i=0;i<x;i++)dis[i]=INF;
	for(int i=0;i<now;i++)
	{
		int tmp=res[i]%x;
		Min(dis[tmp],res[i]);
	}
	for(int t=0;t<cnt;t++)
	{
		all=0;q[++all]=t;int tmp=(t+now)%x;
		while(tmp!=t){q[++all]=tmp;tmp=(tmp+now)%x;}
		for(int i=1;i<=all;i++)q[i+all]=q[i];
		for(int i=2;i<=all*2;i++)Min(dis[q[i]],dis[q[i-1]]+now);
	}now=x;
}
struct Nd{int id,x;};
Nd Md(int id,int x){Nd tmp;tmp.id=id,tmp.x=x;return tmp;}
void doit(int fir,int siz,int d)
{
	int cnt=gcd(d,fir);tomod(fir);if(d<0)return;
	for(int t=0;t<cnt;t++)
	{
		all=0;q[++all]=t;int tmp=(t+d)%fir,pos=1,all2=all;
		while(tmp!=t){q[++all]=tmp;tmp=(tmp+d)%fir;}all2=all;
		for(int i=2;i<=all;i++)if(dis[q[i]]<dis[q[pos]])pos=i;
		all=0;for(int i=pos;i<=all2;i++)Q[++all]=q[i];
		for(int i=1;i<=pos-1;i++)Q[++all]=q[i];
		deque<Nd>p;p.push_front(Md(1,dis[Q[1]]-d));
		for(int i=2;i<=all;i++)
		{
			while(!p.empty()&&p.front().id<i-siz)p.pop_front();
			if(!p.empty())Min(dis[Q[i]],p.front().x+i*d+fir);
			while(!p.empty()&&p.back().x>=dis[Q[i]]-i*d)p.pop_back();
			p.push_back(Md(i,dis[Q[i]]-i*d));
		}
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
signed main()
{
	int T=read();
	while(T--)
	{
		n=read(),w=read();scanf("%s",a+1);now=n;w-=n;
		memset(dis,0x3f,sizeof(dis));dis[0]=0;Init();
		for(int i=2;i<=n;i++)pi[i]=getnxt(pi[i-1],a[i]);
		int j=pi[n];while(j)num[++tot]=n-j,j=pi[j];j=1;num[++tot]=n;
		for(int i=1;i<=tot;i=j)
		{
			while(num[i+1]-num[i]==num[j+1]-num[j])j++;
			doit(num[i],j-i-1,num[i+1]-num[i]);
		}int ans=0;
		for(int i=0;i<now;i++)if(dis[i]<=w)
			ans+=(w-dis[i])/now+1;
		printf("%lld\n",ans);
	}
	return 0;
}

---


# 【XR-4】混乱度

## 题目描述

小 X 有 $n$ 种颜色的球，其中第 $i$ 种颜色的球共有 $a_i$ 个，同色的球无法区分。定义第 $l \sim r$ 种颜色的混乱度 $f(l, r)$ 为：将第 $l \sim r$ 种颜色的所有球排成一排，总共的方案数对 $p$ 取模后的值。小 X 想请你帮忙计算下列式子的值：

$$ \sum_{l=1}^n \sum_{r=l}^n f(l, r) $$

## 说明/提示

【样例 1 说明】

$$f(1,1) = 1 \bmod 2 = 1$$

$$f(1,2) = 3 \bmod 2 = 1$$

$$f(2,2) = 1 \bmod 2 = 1$$

$$ \sum_{l=1}^n \sum_{r=l}^n f(l, r)  = 3$$

---

**本题采用捆绑测试。**

- Subtask 1（31 points）：$1 \le n \le 5 \times 10^5$，$a_i$ 在 $[0, 10^5]$ 内均匀随机，时限 $1.5 \text{ s}$。
- Subtask 2（32 points）：$1 \le n \le 5 \times 10^4$，时限 $5 \text{ s}$。
- Subtask 3（37 points）：无特殊限制，时限 $2.5 \text{ s}$。

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^5$，$0 \le a_i \le 10^{18}$，$p \in \{2,3,5,7\}$。

## 样例 #1

### 输入

```
2 2
1 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4 7
1 2 8 9
```

### 输出

```
28
```

## 样例 #3

### 输入

```
15 5
1 5 26 1 0 5 0 6 7 51 1 5 26 1 0
```

### 输出

```
124
```

# 题解

## 作者：Rainy_chen (赞：91)

### 题面
给出$n$种颜色的球，每种颜色的球没有区别，定义$f(l,r)$为颜色为$l$到$r$的所有球的不同排列数，求$\sum_{l=1}^n\sum_{r=1}^n(f(l,r)\mod p)$。

$n\le5\times10^5,0\le a_i\le10^{18},p\in\{2,3,5,7\}$
### 吐槽
考场上想出了题解的第一步，果然我已经从「完全没有计数基础」进化到了「有一定组合数学基础」了吗233。  

然后感谢XR团队提供的优质题目/亲亲。
### 题解
我们考虑$f(l,r)$该怎么计算，实际上应该是一个$\binom{\sum_{i=l}^ra_i}{a_l}\times f(l+1,r)$，理解方式大概就是在长度为$\sum_{i=l^r}a_i$的序列中选出$a_i$个位置设置成颜色$l$，然后剩下的位置的方案数恰好就是$f(l+1,r)$。从同样的角度理解你还可以发现$f(l,r)=\binom{\sum_{i=l}^ra_i}{a_r}\times f(l,r-1)$。  
当然，对于$f(l,l)$，其值为1。

我们令$S(l,r)$表示$\sum_{i=l}^ra_i$，之后我们展开$f(l,r)$，应该可以得到
$$ f(l,r) = \prod_{i=l}^r\binom{S(i,r)}{a_i}= \prod_{i=l}^r\binom{S(i,r)}{S(i+1,r)}$$

*以上是题解的第一步*

之后我们考虑Lucas定理，Lucas定理一般表示为$\binom nm\mod p=\binom{n/p}{m/p}\binom{n\mod p}{m\mod p}\mod p$，其中，$a/b$表示$\left\lfloor\frac ab\right\rfloor$。  

实际上如果我们将$n,m$看做两个$p$进制数$\overline{n_a..n_2n_1n_0},\overline{m_b..m_2m_1m_0}$的话，$\binom nm\mod p$就是$\prod_{i=0}^{max(a,b)}\binom{n_i}{m_i}\mod p$。

有一个并不显然的结论，若$\binom {n+m}m\mod p$为$0$，那么这代表着在$p$进制下计算$n+m$时有一位发生了进位。  

一个比较感性的理解方式是若$\binom{n+m}m\mod p=0$，那么$n+m$的$p$进制上必然有一位是小于$m$的$p$进制上的这一位的，而发生这个情况的唯一可能性是这一位加了一个数产生了进位。  

或许你还会考虑到这一位可能被其他位置的进位所影响，所以我们这里找的是产生进位的最低位，如果存在进位则必然存在这一位，并且无论如何这一位都不会被其他位影响。

然后我们发现$f(l,r)\mod p=0$的条件就是$\sum_{i=l}^ra_i$在$p$进制下运算时出现了进位。  
更优秀的性质是如果$f(l,r)\mod p=0$，那么$f(l-1,r)=f(l,r+1)=0$,因为这两者都可以从$f(l,r)$通过乘法计算而来。这意味着是否进位是满足单调性的。

于是我们得出了解法1，对每个点$r$求出最小的$l$使得$f(l,r)$不产生进位，之后暴力计算$\sum_{i=l}^rf(i,r)$。  

第一部分的测试点中期望的不产生进位的区间个数是$\theta(n)$个左右，具体证明可以参考XR题解，这里不再赘述。

对于第二部分的测试点，$a_i$不再随机，这意味着可能会被人为构造出大量的$0$来使解法1的区间个数以及区间长度大量增长，这时复杂度完全取决于出题人是否良心。  

于是你可以考虑消除$0$对于答案的影响，容易发现若$a_l=0$则$f(l,r)=\binom{S(l,r)}{0}f(l+1,r)=f(l+1,r)$，于是将所有0缩起来，只记录0出现的数量，之后在新的不包含0的序列上再沿用解法1即可。  

至于说在不包含0的序列上用解法1的时间复杂度，容易发现区间长度不会超过$(p-1)\lceil log_pa_i\rceil$，主要每一个数至少在一位上至少为1，然后最多可以有$(p-1)\lceil log_pa_i\rceil$个1，只要再出现一个数就会产生进位。  

于是最坏复杂度是$O(nplog_p^2a_i)$。

正解与第二部分的算法是十分相似的，在第二部分中计算组合数时使用了lucas定理，而lucas定理的本质是将数转化为$p$进制数后逐位计算。  

所以我们可以在进行解法2之前先将每一个$a_i$拆分成$p$进制数。 然后进行解法2的扫描时，把$p$进制的每一位的值储存下来，对于扫到的数$a_i$，将其拆分后的$p$进制数在其几个非$0$位上将储存的值更新掉。  

$p$很小，所以完全可以$p^2$预处理出所有$\binom ij\mod p(i,j<p)$的结果。 那么每一次更新时只需要$O(1)$的复杂度，而很显然最多只会更新$(p-1)\lceil log_pa_i\rceil$次（参考解法2复杂度分析），那么此时就有了一个复杂度为$O(nplog_pa_i)$的优秀算法了。

*代码细节好难考虑。。。*

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long int_t;

char getch(){
    static char buf[100000],*s,*t;
    return (s == t) && (t = (s = buf) + fread(buf,1,100000,stdin)), s == t ? EOF : *s++;
}

#ifdef local
#define getch getchar
#endif

int_t read(){
    int_t x = 0,w = 1;char ch = 0;
    for(;!isdigit(ch);ch = getch()) if(ch == '-') w = -1;
    for(;isdigit(ch);ch = getch()) x = x * 10 + ch - '0';
    return x * w;
}

struct shu{
    int_t w;
    vector<pair<int_t,int_t>> cf;
    void chaifen(int_t w,int_t p) { 
        this -> w = w;
        int_t tmp = 0;
        while(w) {
            if(w % p) cf.push_back(make_pair(tmp,w % p));
            ++tmp; w/=p;
        }
    }
}shus[500010];

int_t ans = 0;
int_t C[10][10],pre[500010];
// 预处理出的组合数以及每一个数开始的最靠左的连续的0位置

void init(int_t n,int_t p){
    for(int_t i=0;i<p;i++)
        for(int_t j=C[i][0]=1;j<=i;j++)
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % p;
    pre[1] = 1;
    for(int_t i=2;i<=n;i++) if(!shus[i].w) pre[i] = shus[i-1].w ? i : pre[i-1];
}

int_t fpow(int_t a,int_t b,int_t p){
    int_t res = 1;
    for(;b;b>>=1,a=a*a%p) if(b & 1) res = res * a % p;
    return res;
}

int_t inv(int_t x,int_t p){
    return fpow(x,p-2,p);
}

int_t a[70]; // 按位拆分后的S(i,r)

void work(int_t r,int_t p){
    int_t tmp = 1,ttmp = 1;
    memset(a,0,sizeof a);
    for(auto x : shus[r].cf) a[x.first] = x.second;
    while(r){
        ans += tmp;
        // 这里tmp是f(r-1,R), R为传入的参数r的复制
        --r;
        if(r < 1) break;
        if(shus[r].w == 0){
            ans += (r - pre[r] + 1) * tmp;
            r = pre[r] - 1;
        }
        ttmp = 1;
        for(auto x : shus[r].cf){
            int_t pos = x.first,w = x.second;
            if(a[pos] + w >= p) {ttmp = 0; break;}
            ttmp = ttmp * C[a[pos] + w][a[pos]];
            a[pos] += w; 
        }
        // 这里ttmp是计算的组合数
        if(!ttmp) break;
        tmp = tmp * ttmp % p;
    }
}

int main(){
    int_t n = read(),p = read();
    for(int_t i=1;i<=n;i++) 
        shus[i].chaifen(read(),p);
    init(n,p);
    for(int_t i=1;i<=n;i++) work(i,p);
    cout<<ans;
}
```

---

## 作者：StudyingFather (赞：9)

神仙数数题。

## 一些前置知识

### 多重集的排列数（多重组合数）

本题实际上让我们求的是若干**多重组合数**的和。

对于一个多重集 $S$，我们设其包含的元素个数为 $n$，且其中有 $a_i$ 个元素的值为 $x_i$，则该多重集的全排列数为：

$$
\binom{n}{a_1,a_2,\ldots,a_m}=\frac{n!}{\prod_{i=1}^m a_i!}
$$

考虑组合意义，$n$ 个元素的全排列数为 $n!$，而考虑每个相同的元素，对于所有为 $x_i$ 的元素，其全排列数为 $a_i!$，因为相同元素的排列宏观上只视为一种排列，因此将相同元素的全排列数除掉即可。

进一步地，我们发现多重组合数可以拆分：

$$
\binom{n}{a_1,a_2,\ldots,a_m}=\binom{n-a_m}{a_1,a_2,\ldots,a_{m-1}}\binom{n}{a_m}
$$

证明仍然考虑其组合意义：我们现在已经确定了前 $m-1$ 种元素的多重集排列，现在需要将第 $m$ 种元素插入。

总共有 $n$ 个位置，其中 $a_m$ 个位置供第 $m$ 种元素插入，从而第 $m$ 种元素有 $\binom{n}{a_m}$ 种插入方式，接下来再将剩下的空位，填入前 $m-1$ 种元素的多重集排列即可。

利用这个性质可以将多重组合数拆分成若干组合数的乘积。

### 卢卡斯定理

我们将 $n$ 和 $m$（$n \geq m$）拆分为 $p$ 进制数（要求 $p$ 为质数），设拆分后的结果为：$n=\overline{n_0n_1\ldots n_x}$，$m=\overline{n_0n_1\ldots n_x}$（这里为了方便起见高位自动补零），则有：

$$
\binom{n}{m} \equiv \prod_{i=0}^x \binom{n_i}{m_i} \pmod p
$$

进一步地，我们可以得到一个推论：

若 $\binom{n+m}{m} \equiv 0 \pmod p$，则 $n+m$ 在 $p$ 进制下发生了进位。

原因很简单，若 $n+m$ 在 $p$ 进制下发生了进位，则发生进位的位上的数一定小于 $m$ 在该位上的数，根据组合数定义和卢卡斯定理，就可以证明上面的推论。

现在进入正题。

## Subtask 1

我们枚举左端点 $l$，逐步向右推进右端点 $r$，在这个过程中根据卢卡斯定理计算多重组合数，累加答案即可。

当出现多重组合数值为零的情况时，继续向右推进不会对答案产生贡献，直接停下来即可。

我们可以证明，在**数据随机**的情况下，多重组合数不为零的区间只有 $O(n)$ 个。从而时间复杂度可以做到 $O(n \log_p w)$。

下面是证明：

我们在 $[0,p)$ 的范围内随机两个数 $x,y$，则 $x+y \leq p$ 的概率约为 $\dfrac{1}{2}$。

上面这个结论的证明可以通过几何概型来解释。我们在平面直角坐标系中画一个以 $(0,0)$ 为左下角，$(p-1,p-1)$ 为右上角的正方形，再画一条 $x+y=p$ 的直线，则我们取的点需要为正方形内或正方形上的整点，且必须在给定直线下方。

（事实上，画个图后会发现，这个概率比 $\dfrac{1}{2}$ 略大（$p$ 较小的时候这一近似误差会更大些），不过这并不影响我们结论的证明）

这是一个位的情况，对于多个位，我们需要将各位概率相乘。在值域为 $[0,w]$ 的情况下，一共有 $\left \lceil \log_p w \right \rceil$ 位，从而不进位的概率约为 $\dfrac{1}{2}^{\left \lceil \log_p w \right \rceil}$。

（$p$ 较小的时候单个位上不发生进位的概率会比近似值更大，但与此同时位数也会增加，因此最终结果出入不算太大）

在给定的数据范围内，稍微计算一下就会发现这个概率是非常小的。随着区间长度增加，这个概率会以指数级的趋势进一步减小。

## Subtask 3

数据不随机的时候，会存在下面两种问题：

1. 当 $a_i=0$ 时，此时多重组合数的值不变，但是上面的做法仍然会将 $a_i$ 加入集合中重新计算多重组合数。
2. 即使 $a_i \neq 0$，$a_i$ 在 $p$ 进制下仍然有一些位的值为零。而我们每次计算多重组合数时，都要重新按照卢卡斯定理将所有位的值累加一次，重复计算的部分很多。

对于第一种情况，我们只需在累加答案后，直接把这个数跳过去即可，不用再重新计算。

（事实上其实不必就第一种情况进行特别判断，详见下面的优化）

对于第二种情况，考虑只保留 $a_i$ 中不为零的位，并只在这些位上进行更新。

这样我们就把时间复杂度优化到了 $O(np \log_p w)$，可以通过本题。

为什么是这个时间复杂度？

因为保留下来的每个位的值至少为 $1$，而当一个位的值大于等于 $p$ 时就会终止计算。因此对于一个 $l$，我们最多更新 $(p-1)\left \lceil \log_p w \right \rceil$ 次答案。而每次更新的时间复杂度为 $O(1)$，从而得到 $O(np \log_p w)$ 的时间复杂度。

如果每次更新都根据卢卡斯定理重新计算多重组合数，因为更新一次的时间复杂度为 $O(\left \lceil \log_p w \right \rceil)$，总时间复杂度就达到了 $O(np \log_p^2 w)$。这种做法明显劣于上面的正解，只能通过前两个子任务。

```cpp
// Problem: P5598 【XR-4】混乱度
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5598
// Memory Limit: 500 MB
// Time Limit: 1500 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef pair<int,int> pii;
long long a[500005];
int c[15][15],nv[65];
vector<pii> v[500005];
int main()
{
 ios::sync_with_stdio(false);
 int n,p;
 cin>>n>>p;
 for(int i=1;i<=n;i++)
  cin>>a[i];
 for(int i=0;i<p;i++)
  c[i][0]=1;
 for(int i=1;i<p;i++)
  for(int j=1;j<=i;j++)
   c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
 for(int i=1;i<=n;i++)
 {
  int cnt=0;
  long long x0=a[i];
  while(x0)
  {
   int x=x0%p;
   x0/=p,cnt++;
   if(x)v[i].emplace_back(x,cnt);
  }
 }
 long long ans=0;
 for(int l=1;l<=n;l++)
 {
  int res=1;
  ans++;
  memset(nv,0,sizeof(nv));
  for(auto i:v[l])
   nv[i.second]=i.first;
  for(int r=l+1;r<=n;r++)
  {
   for(auto i:v[r])
   {
    nv[i.second]+=i.first;
    if(nv[i.second]>=p)
    {
     res=0;
     break;
    }
    res=res*c[nv[i.second]][i.first]%p;
   }
   if(!res)break;
   ans+=res;
  }
 }
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：s_r_f (赞：4)

## 没分的暴力

考虑一个区间的$ans$怎么计算$:$

对这个区间求一个前缀和 $ pre[i] $ $ , $ 然后前缀和数组相邻两项之间求一个组合数并求出它们的乘积 $,$ 
即 $ \large\Pi $ $ C(pre[i],pre[i-1]) .$

由于模数很小$,$我们考虑使用$lucas$定理来实现它$.$

那么我们暴力枚举每个区间求$f(l,r)$ ~~这好蠢啊~~ 就可以写出一个$O(n^3 * lucas)$的暴力了

## 有分的暴力(Subtask1)

观察式子可以发现$f(l,l) = 1,$ 

而且对于所有的 $r>l,f(l,r)$ 是 $f(l,r-1)$ 乘上一个组合数。

那么如果有一个$f(l,r_1) = 0,$ 所有 $>r_1$ 的 $r_2$ 都满足 $f(l,r_2) = 0$

所以我们暴力枚举左端点$,$然后枚举右端点并计算组合数$,$直到$ans = 0$即可直接退出$.$

复杂度$O(n*lucas*k)$,其中$lucas$为计算组合数的复杂度,
$k$是$r-l$在随机数据下的期望长度。

可以过$subtask1.$

## 优秀的暴力(Subtask1,2)

从$subtask2$开始$,$数据就不随机了$.$

我们来分析一下$lucas$定理的性质$:$

$C(n,m)$ $mod$ $p$ $=$ $C$ ($n$ $mod$ $p,$ $m$ $mod$  $p$ ) 

那么我们把$n$和$m$都写成$p$进制$,$我们要求的实际上是 
$ \large\Pi $ $C(n_{pos},m_{pos})$，其中$n_{pos}$是指$n$在$p$进制下第$pos$位的数值$.$

如果考虑计算的过程可以发现**当且仅当前缀和的某一位发生了一次进位时$,$组合数为$0$**

所以我们发现了一个~~惊天大秘密~~$,$如果出题人不放$0$的话,我们最多只需要让前缀和加到进位就可以停了！！！

那么出题人放$0$怎么办呢……

因为$0$对答案的影响很好统计$,$我们就直接记录一个$nxt[i]$表示$i$的下一个非零位置是什么$,$如果在枚举$r$的过程中找到了$0,$就统计完$[i,nxt[i])$对答案的贡献之后直接跳到$nxt[i]$即可$.$

然后再用$lucas$计算组合数即可……

### 复杂度分析

对于每个$i$最多只会有$O(log_p(1e18)*p)$ 个位置对答案有贡献

计算组合数的复杂度为$O(log_p(1e18))$

所以复杂度为$O(nplog^2_p(1e18))$只能过$subtask2,$不能过$subtask3.$~~如果有人卡过了就当我没说~~

## 进一步优化(subtask1,2,3)

每次都调用$lucas$太亏了……

考虑到每次答案变化只有可能是$:$

前缀和的$p$进制表示下某一位的值发生变化使得对应的组合数发生变化$.$

那么我们可以记录下每个数在$p$进制下分解出的每一个非零位以及这个非零位对应的数值$,$然后在枚举$r$更新前缀和时直接维护前缀和$p$进制下的每一位$,$顺便维护一下答案即可$.$

现在复杂度就变成了$O(nplog_p(1e18))$了$,$因为前缀和$p$进制下每一位最多只会被增加$p$次$,$而每一次增加的复杂度为$O(1)$

然后就能过$subtask3$了……

上代码……

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
    static LL x; x = 0; static char c; c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
    return x;
}
const int N = 500050; int P;
LL a[N],sum;
int C[10][10],pos[N*60],val[N*60];
int n,nxt[N],l[N],r[N],nv[65],ans;
int main(){
	int i,j,k; LL v; int now,dpt;
	n = read(),P = read();
	for (i = 1; i <= n; ++i) a[i] = read();
	for (i = 0; i <= P; ++i) for (j = 0; j <= P; ++j){ if (i<j) C[i][j] = 0; else if (!j) C[i][0] = 1; else C[i][j] = (C[i-1][j-1]+C[i-1][j])%P; }
	nxt[n] = n+1;
	for (i = n-1; i ; --i) nxt[i] = a[i+1] ? i+1 : nxt[i+1];
	for (now = 0,i = 1; i <= n; ++i) if (a[i]){
		l[i] = now+1,r[i] = now,v = a[i],dpt = -1;
		while (v){ now = v%P,v/=P,++dpt; if (now) ++r[i],pos[r[i]] = dpt,val[r[i]] = now; }
		now = r[i];
	}
	for (i = 1; i <= n; ++i){
		ans = 1,memset(nv,0,sizeof(nv));
		if (a[i]) for (j = l[i]; j <= r[i]; ++j) nv[pos[j]] = val[j];
		sum += ans,k = i+1;
		while (k <= n){
			if (!a[k]){ sum += ans * (nxt[k]-k),k = nxt[k]; continue; }
			for (j = l[k]; j <= r[k]; ++j){
				nv[pos[j]] += val[j];
				if (nv[pos[j]]>=P) {ans = 0; break; }
				ans = ans * C[nv[pos[j]]][val[j]] % P;
			}
			if (!ans) break; sum += ans,++k;
		}
	}
	cout << sum << endl;
    return 0;
}
```

---

## 作者：small_john (赞：2)

## 思路

神仙计数题。

首先易推得 $f(l,r)=\prod\limits_{i=l}^{r}\binom{\sum\limits_{j=i}^{r}a_j}{a_i}$。

注意到 $p$ 很小且是一个质数，所以考虑使用 Lucas 定理去求组合数。

而 Lucas 定理的本质其实是将组合数的上下两项再 $p$ 进制下的每一位的组合数乘起来。

发现组合数是一个 $\binom{n+m}{n}$ 的形式，有经典结论：$p$ 为质数时，$\binom{n+m}{n}\equiv0\pmod p$ 当且仅当 $n+m$ 在 $p$ 进制下产生了进位。

> 证明：根据 Lucas 定理，$\binom{n+m}{n}\equiv0\pmod p$ 时 $n+m$ 在 $p$ 进制表示下一定存在一位比 $n$ 对应的那一位小，而满足这个的条件就是 $n+m$ 在 $p$ 进制下产生了进位。

那么对于每个右端点 $r$，$f(l,r)$ 有值的 $l$ 一定是一个以 $r$ 为右端点的区间。

我们猜测这个区间一定不会太长，考虑鸽巢定理，每一位最多被加 $p-1$ 次，一共有 $\log_pV$（$V$ 是值域）位。除去 $a$ 中的零就最多扩展 $O(p\log_pV)$ 次。

扩展左端点时我们如果暴力计算组合数时间复杂度就是 $O(n\log_p^2V)$ 的，还是过不了。

考虑优化。我们发现由于没有进位，$\sum\limits_{j=i}^{r}a_j$ 这一项中所有位的更新次数是 $O(p\log_pV)$ 的。下面 $a_{i}$ 这一项可以变成 $\sum\limits_{j=i+1}^{r}a_j$，和上面那一项是同理的。每存在一位被更新就重新计算这一位对组合数的贡献。

最后的时间复杂度就是 $O(np\log_pV)$ 的，可以通过。

## 代码

实现的常数有点大，仅供参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5+5;
int n,mod,cnt,a[N];
inline int qpow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1) res = res*x%mod;
		y>>=1;
		x = x*x%mod; 
	}
	return res;
}
vector<pair<int,int>> vec[N];
int va[65],vb[65],c[65][65],inv[65][65],res,now;
inline bool add(auto &a,auto &vec)
{
	for(auto _:vec)
	{
		int x = _.first,y = _.second;
		if((a[x]+y)>=mod) return 0;
		res = res*inv[va[x]][vb[x]]%mod;
		a[x]+=y;
		res = res*c[va[x]][vb[x]]%mod;
	}
	return 1;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>mod;
	int mx = 0;
	for(int i = 1;i<=n;i++)
	{
		long long x;
		cin>>x;
		if(x==0) a[cnt+1]++;//记得缩掉 0 
		else
		{
			cnt++;
			int tmp = 0;
			while(x)
			{
				tmp++;
				if(x%mod!=0) vec[cnt].push_back({tmp,x%mod});
				x/=mod;
			}
			mx = max(mx,tmp);
		}
	}
	c[0][0] = 1;
	for(int i = 1;i<=mod;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<=i;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	for(int i = 0;i<=mod;i++)
		for(int j = 0;j<=i;j++)
			inv[i][j] = qpow(c[i][j],mod-2);
	long long ans = 0;
	for(int i = 1;i<=cnt;i++)
	{
		for(int j = 1;j<=mx;j++)
			va[j] = vb[j] = 0;
		res = now = 1;
		int mul = (a[i+1]+1);
		for(int j = i;j;j--)
		{
			bool fl = add(va,vec[j]);
			if(!fl) break;
			if(j<i) add(vb,vec[j+1]);
			now = now*res%mod;
			ans+=1ll*now*(a[j]+1)*mul;
		}
	}
	for(int i = 1;i<=cnt+1;i++)
		ans+=a[i]*(a[i]+1)/2;
	cout<<ans;
	return 0;
}
```

---

## 作者：Fairy_Tale (赞：2)

首先我们可以通过组合数学的知识推出  
$f(l,l)=1, f(l,r)=f(l,r-1)C_{\sum_{i=l}^{r}a_{i}}^{a_{r}}(l<r)$  
因为考虑到模数$p$非常的小，又是质数，我们很自然的想到可以用$Lucas$定理去快速计算后面的那个组合数来递推求解   
但是即使能够我们也不能暴力的去求解每一个$f(l,r)$，因为复杂度太大了     
不过我们可以发现如果$f(l,r)=0$,那么$f(l,r+1)=0$  
那么对于每一个$l$,我们只需要计算到最大的一个$r$,满足$f(l,r) != 0$即可  
那么这个$r$有多大呢  
这等价于找到第一个$r$，使得$C_{\sum_{i=l}^{r}a_{i}}^{a_{r}}\% p=0$  
设$n = \sum_{i=l}^{r-1}a_{i}, m = a_{r},l=n+m$   
我们现在要判断$C_{l}^{m} \% p$是否等于$0$  
把$n,m,l$写成$p$进制形式  
$n=n_{0}n_{1}n_{2}...$  
$m=m_{0}m_{1}m_{2}...$   
$l=l_{0}l_{1}l_{2}...$   
套用$Lucas$定理，有  
$C_{l}^{m} \% p = C_{l_{0}}^{m_{0}}C_{l_{1}}^{m_{1}}C_{l_{2}}^{m_{2}}... \%p$  
如果$C_{l}^{m} \% p = 0$,即是存在一个$i$，使得$C_{l_{i}}^{m_{i}}\%p=0$,也就是说满足$l_{i}<m_{i}$  
假设$n+m=l$这个加法不存在进位  
一定满足$l_{i}=n_{i}+m_{i}$，即$l_{i} \geq m_{i}$  
也就是说$n+m=l$这个加法在$p$进制下存在进位操作,才会使$C_{l}^{m} \% p = 0$  

现在我们回到这道题，推广一下，可以得到    
如果$\sum_{i=l}^{r}a_{i}$在$p$进制下存在进位,那么$f(l,r)$一定等于$0$  
假设所有$a_{i}>0$，$r$最大只能达到$plog_{p}1e18$  
算下来每个$l$,我们只需要递推不到$150$次，就会得到$f(l,r)=0$  
考虑到序列$a$中可能出现连续的$0$，而加$0$是肯定不会进位的，我们可以把多个连续的$0$合并成一个$0$，这样可以保证每个$l$递推不到$300$次   
如果我们可以快速实现最开始的递推式，就可以暴力计算答案了   

现在的问题是怎么快速计算$C_{\sum_{i=l}^{r}a_{i}}^{a_{r}}\% p=0$   
如果直接上标准的$Lucas$太慢了   
我的做法是递归的时候把$C_{n}^{m}=C_{n/p}^{m/p}C_{n\%p}^{m\%p}$替换成$C_{n}^{m}=C_{n/p^{k}}^{m/p^{k}}C_{n\%p^{k}}^{m\%p^{k}}$,选一个合适的$k$值，  
然后$C_{n\%p^{k}}^{m\%p^{k}}$的值直接预处理（这个应该很好证明）   
不过由于中间涉及了较多的取模和除法操作，并不能通过所有的点   
但是发现$p=2$的时候，取模和除法可以用位运算代替，那么$p!=2$的时候是不是也可以呢  
于是我把$a_{i}$写成$p^{k}$进制并用两个$long long$来存，每一位都占一定的$bit$,这样加法的时候进位不会相互干扰，做除法取模运算也可以用位运算代替   
```cpp
#include<bits/stdc++.h>
#define fi first
#define se second

using namespace std;
typedef long long LL;
typedef pair<int,int> P;

const int mod = 1e9 + 7;
const int maxn = 5e5 + 5;
const int N = 15;
const int W = (1 << 15) - 1;

LL a[maxn], a1[maxn], a2[maxn];
int t[maxn];
int cc[7005][7005], p, pt;

int C(LL n, LL m) {
    int res = 1;
    for(int i = 0;i < 3; ++i) {
        res *= cc[n & W][m & W];
        n >>= N;
        m >>= N;
    }
    return res;
}

void split(LL x, LL &u, LL &v) {
    for(int i = 0;i < 3; ++i) {
        u = (u << N) | (x % pt);
        x /= pt;
    }
    for(int i = 0;i < 3; ++i) {
        v = (v << N) | (x % pt);
        x /= pt;
    }
}

int main(){
    int n, m = 0;
    LL x, ans = 0;
    scanf("%d%d", &n, &p);
    if(p == 2) pt = 2048;
    else if(p == 3) pt = 2187;
    else if(p == 5) pt = 3125;
    else pt = 2401;
    cc[0][0] = 1;
    for(int i = 1;i < pt * 2; ++i) {
        cc[i][0] = 1;
        for(int j = 1;j <= i; ++j) {
            cc[i][j] = cc[i - 1][j] + cc[i - 1][j - 1];
            if(cc[i][j] >= p) cc[i][j] -= p;
        }
    }
    for(int i = 0;i < n; ++i) {
        scanf("%lld", &x);
        if(!x && m && !a[m]) t[m]++;
        else {
            a[++m] = x;
            t[m]++;
        }
    }

    for(int i = 1;i <= m; ++i) split(a[i], a1[i], a2[i]);
    for(int l = 1;l <= m; ++l) {
        ans += t[l] * (t[l] + 1LL) / 2;
        int r = l;
        LL s1 = a1[l], s2 = a2[l], val = 1;
        while(++r <= m) {
            s1 += a1[r];
            s2 += a2[r];
            val = C(s1, a1[r]) * C(s2, a2[r]) * val % p;
            if(!val) break;
            else ans += val * t[l] * t[r];
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```




---

## 作者：creation_hy (赞：1)

# 前言

为啥这题暴力一分都没有啊，~~哼哼哼啊啊啊啊啊~~

~~我能说我这题一共读错题意了三次吗~~

虽然是黑题，但是其实并不难。

# 思路

## 暴力：

把 $f(l,r)$ 拆分成每种颜色的球考虑。

放置第 $i$ 种球的时候，还剩下 $\displaystyle\sum_{j=i}^r a_j$ 个位置（前面的放过了），要放 $a_i$ 个球，所以第 $i$ 种颜色的球放置的方案数应该是 $C_{\sum_{j=i}^r a_j}^{a_i}$。

设 $S(l,r)$ 表示 $\displaystyle\sum_{i=l}^r a_i$，这个东西可以用前缀和优化，降到 $O(1)$。

（$pre[]$ 表示前缀和数组）

最终答案即为：

$\displaystyle\sum_{l=1}^n\sum_{r=l}^n\prod_{i=l}^r C_{pre[r]-pre[i-1]}^{a_i}$

数太大了（$pre$ 能达到 $5\times10^{23}$），怎么办？用 Lucas 定理就好了啊。

Lucas 定理：

$C_x^y\bmod p=C_{x\bmod p}^{y\bmod p}\times C_{\frac{x}{p}}^{\frac{y}{p}}$

时间复杂度：$O(p\ \log_p\ x)$

于是，暴力部分就完成了，总时间复杂度：$O(n^3\ p\ \log_p\ a_i)$

交了一发。

然后就是你在前言看到的东西了，[直接爆零](https://www.luogu.com.cn/record/97799454)。

~~虽然但是，这也太惨了吧~~

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
typedef long long ll;
int n, p;
ll a[N], C[15][15];
__int128 pre[N];
inline int lucas(__int128 x, __int128 y)
{
    if (x < y)
        return 0;
    if (x < p)
        return C[x][y];
    return lucas(x % p, y % p) * lucas(x / p, y / p) % p;
}
inline int f(int l, int r)
{
    int res = 1;
    for (int i = l; i < r; i++)
        res = res * lucas(pre[r] - pre[i - 1], a[i]) % p;
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> p;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        pre[i] = pre[i - 1] + a[i];
    }
    C[0][0] = 1;
    for (int i = 1; i <= 10; i++)
    {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;
    }
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            ans += f(i, j);
    cout << ans;
    return 0;
}
```

## 正解

发现一个问题：

大部分时间都用在重新算 $res$ 上了。

为什么要重新算？不能直接加吗？当然不能，因为 $r$ 变了之后，组合数的 $x$ 都不一样。

但是，这玩意最好能优化掉，不然还是会炸（

考虑一个拆分：

$C_n^{a_1,a_2,...,a_m}=C_{n-a_m}^{a_1,a_2,...,a_{m-1}}\times C_n^{a_m}$

理解起来不难，就是把 $m-1$ 挑出去再算的方案数，乘上加入 $m$ 的方案数。

$r$ 虽然变了，但是可以从 $r-1$ 直接推过来了！

于是，恭喜你优化掉一个 $n$，时间复杂度变为 $O(n^2\ p\ \log_p\ a_i)$ 了。

接下来讲具体怎么实现。

先把 Lucas 定理变成递推版，不然不好搞（很显然和之前的是一样的）：

设 $x,y$ 分别为原来的数在 $p$ 进制下的数组。

$C_x^y\bmod p=\displaystyle\prod_{i=1}^{size}C_{x_i}^{y_i}\bmod p$

$x,y$ 具体实现的话可以用一个 `vector` 存，开一个 `pair<int, int>`，一个存这个数是 $p$ 进制下第几位，一个存这个数是多少。

接下来直接递推就行了。

不过，到这里你会发现时间复杂度还是不是很对，$n$ 可是百万级啊（

一个优化：
如果当前结果为 $0$，很显然，$r$ 再怎么往后推，也一直都会是 $0$。

另一个优化：在计算 $x,y$ 在 $p$ 进制下的数的时候，只需要保留不为 $0$ 的位即可。

还有一个优化：如果 $x$ 在加的过程中进位了（即某位大于 $p$），那么结果一定为 $0$，因此一旦 $x$ 进位，直接返回 $0$。

证明：如果进位了，$x_i+y_i-p$ 明显会小于 $y_i$（因为 $x_i<p$）。而组合数下面比上面还大，当然得 $0$。

优化后的时间复杂度：$O(n\ p\ \log_p\ a_i)$

# AC 代码：

内含注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
typedef long long ll;
typedef pair<int, int> pii;
int n, p, num[65]; // 1e18
ll a[N], C[15][15], ans;
vector<pii> vec[N];
inline int lucas(int x, int y)
{
    if (x < y)
        return 0;
    if (x < p)
        return C[x][y];
    return lucas(x % p, y % p) * lucas(x / p, y / p) % p;
}
inline void solve(int i)
{
    int res = 1;
    memset(num, 0, sizeof(num));
    for (pii t : vec[i])
        num[t.second] = t.first; // init num (i in base p)
    for (int j = i + 1; j <= n; j++)
    {
        for (pii t : vec[j])
        {
            num[t.second] += t.first;
            if (num[t.second] >= p) // carried
                return;
            res = res * C[num[t.second]][t.first] % p;
        }
        if (!res) // then it will always = 0
            return;
        ans += res;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> p;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    C[0][0] = 1;
    for (int i = 1; i <= 10; i++)
    {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;
    }
    for (int i = 1; i <= n; i++) // to base p
    {
        int cnt = 0;
        ll x = a[i];
        while (x)
        {
            cnt++;
            if (x % p)
                vec[i].emplace_back(make_pair(x % p, cnt));
            x /= p;
        }
    }
    for (int i = 1; i <= n; i++)
        ans++, solve(i);
    cout << ans;
    return 0;
}
```

---


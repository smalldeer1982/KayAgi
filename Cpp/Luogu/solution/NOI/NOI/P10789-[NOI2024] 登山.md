# [NOI2024] 登山

## 题目描述

“为什么要攀登？因为山就在那里。”

慕士塔格山上有 $n$ 处点位，点从 $1$ 到 $n$ 编号，$1$ 号点位为山顶。这 $n$ 个点位构成一棵有根树的结构，其中 $1$ 号点位为根，对于 $2\leq i\leq n$，$i$ 号点位的父亲结点为 $p_i$ 号点位。

记 $d_i$ 为 $i$ 号点位到山顶所需经过的边数。形式化地说，$d_1=0$，对于 $2\leq i\leq n$，$d_i=d_{p_i}+1$。

定义一条**登山路径**为从 $2\sim n$ 号点位中的某一个开始，经过若干次**移动**后**到达山顶**的方案。

定义一次从 $i(2\leq i\leq n)$ 号点位出发的**移动**为以下两种方式之一：
1. 冲刺：在给定的冲刺范围 $[l_i,r_i]$ 内，选择一个正整数 $k$ 满足 $l_i\leq k\leq r_i$，向山顶移动 $k$ 步，即移动至 $i$ 号点位在有根树上的 $k$ 级父亲处。保证 $1\leq l_i\leq r_i\leq d_i$。
2. 休息：由于慕士塔格山地形陡峭，休息时会滑落到某一个儿子结点处。形式化地说，选择一个满足 $p_j=i$ 的 $j$，移动至到 $j$ 号点位。特别地，若 $i$ 号点位为有根树的叶子结点，则不存在满足 $p_j=i$ 的 $j$，因此此时不能选择休息。

定义一条**登山路径**对应的**登山序列**为初始点位以及每次移动到的点位所构成的序列。形式化地说，一条从 $x$ 号点位开始的**登山路径**对应的****登山序列****是一个点序列 $a_1=x,a_2,\dots,a_m=1$ 满足对于 $1\leq i<m$，$a_{i+1}$ 是 $a_i$ 的 $k(l_{a_i}\leq k\leq r_{a_i})$ 级祖先或 $p_{a_{i+1}}=a_i$。

为了保证每次冲刺都能更接近山顶，一条**合法的登山路径**需要满足：对于初始点位或某次移动到的点位 $i$，以后冲刺到的点位 $j$ 都必须满足 $d_j<d_i-h_i$，其中 $h_i$ 是一个给定的参数，保证 $0\leq h_i<d_i$。形式化地说，一条**合法的登山路径**对应的**登山序列** $a_1,a_2,\dots,a_m$ 需要满足：对于所有 $1\leq i<j\leq m$，若 $p_{a_j} \neq a_{j-1}$，则 $d_{a_j}<d_{a_i}-h_{a_i}$。

对于 $2\sim n$ 号所有点位，求从这些点位开始的**合法的登山路径**条数。两条**登山路径**不同当且仅当其对应的**登山序列**不同。由于答案可能较大，你只需要求出答案对 $998\,244\,353$ 取模后的结果。

## 说明/提示

**【样例 1 解释】**

样例 $1$ 共包含三组测试数据。

对于第一组测试数据，慕士塔格山的点位结构如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/8e2srlpm.png)

在该测试数据中，$d_1=0$，$d_2=1$，$d_3=d_4=2$，$d_5=3$。

从 $4$ 开始的合法的登山路径共有以下 $2$ 条：
1. 直接选择冲刺到 $4$ 的 $2$ 级父亲，也就是 $1$，到达山顶，对应的登山序列为 $[4,1]$。
2. 先休息滑落到 $5$，然后从 $5$ 冲刺到它的 $3$ 级父亲，到达山顶。对应的登山序列为 $[4,5,1]$。

从 $5$ 开始的合法的登山路径共有以下 $4$ 条：
1. 直接选择冲刺到 $5$ 的 $3$ 级父亲，也就是 $1$，到达山顶。对应的登山序列为 $[5,1]$。
2. 先冲刺到 $5$ 的 $2$ 级父亲，也就是 $2$；然后再从 $2$ 冲刺到它的 $1$ 级父亲，到达山顶。对应的登山序列为 $[5,2,1]$。
3. 先冲刺到 $5$ 的 $2$ 级父亲，也就是 $2$；然后在 $2$ 处休息，滑落到 $4$；接着从 $4$ 冲刺到它的 $2$ 级父亲，到达山顶。对应的登山序列为 $[5,2,4,1]$。
4. 先冲刺到 $5$ 的 $2$ 级父亲，也就是 $2$；然后在 $2$ 处休息，滑落到 $4$；继续休息，滑落到 $5$；接着从 $5$ 再次冲刺到它的 $3$ 级父亲，到达山顶。对应的登山序列为 $[5,2,4,5,1]$。

**【数据范围】**

对于所有测试数据保证：$1\leq t\leq 4$，$2\leq n\leq 10^5$。

对于任意的 $2\leq i\leq n$，保证：$1\leq p_i<i$，$1\leq l_i\leq r_i\leq d_i$，$0\leq h_i<d_i$。

::cute-table{tuack}

| 测试点编号 | $n\leq$ | 是否有 $l_i=r_i$ | 是否有 $h_i=0$ | 是否有 $p_i=i-1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $6$ | 否 | 否 | 否 |
| $2,3$ | $300$ | ^ | ^ | ^ |
| $4,5$ | $5000$ | ^ | ^ | ^ |
| $6$ | $10^5$ | 是 | 是 | 是 |
| $7$ | ^ | ^ | ^ | 否 |
| $8$ | ^ | ^ | 否 | 是 |
| $9$ | ^ | ^ | ^ | 否 |
| $10$ | ^ | 否 | 是 | 是 |
| $11,12$ | ^ | ^ | ^ | 否 |
| $13$ | ^ | ^ | 否 | 是 |
| $14\sim 20$ | ^ | ^ | ^ | 否 |


## 样例 #1

### 输入

```
0
3
5
1 1 1 0
2 1 1 0
2 1 2 1
4 2 3 0
6
1 1 1 0
2 1 2 0
3 1 3 2
4 1 4 1
5 1 5 3
6
1 1 1 0
2 1 2 0
2 1 2 0
3 1 2 0
3 2 3 2```

### 输出

```
3 3 2 4
5 9 3 21 6
4 10 5 14 1```

## 样例 #2

### 输入

```
见 mountain2.in/ans
这个样例满足测试点 2,3 的约束条件```

### 输出

```
```

## 样例 #3

### 输入

```
见 mountain3.in/ans
这个样例满足测试点 9 的约束条件```

### 输出

```
```

## 样例 #4

### 输入

```
见 mountain4.in/ans
这个样例满足测试点 11,12 的约束条件```

### 输出

```
```

## 样例 #5

### 输入

```
见 mountain5.in/ans
这个样例满足测试点 13 的约束条件```

### 输出

```
```

# 题解

## 作者：Larunatrecy (赞：67)

考场做法，写加调两个小时，应该算比较简单的做法。

我们先令 $l_i,r_i$ 表示可以冲刺到的点的深度范围，$lim_i=d_i-h_i-1$。

我们发现因为 $h_i\geq 0$，所以每次向上冲刺之后新的限制一定是当前点的 $lim_i$，那么就设 $dp_i$ 表示当前在节点 $i$，走到 $1$ 的方案数，那么一定是先向下滑到子树内某个节点 $j$，然后再跳到 $i$ 的某个祖先    $k$，那么 $k$ 应当满足：

- 设 $v_{i\to j}$ 为 $i\to j$ 路径上 $lim$ 的最小值，那么 $d_k\in [l_j,\min(r_j,v_{i\to j})]$。

枚举 $i$，枚举 $j$，用一个数组 $s$ 维护当前祖先链上 $dp$ 值的前缀和，即可做到 $O(n^2)$。

然后考虑一下 $l_i=r_i$ 的部分分，对于一个 $j$，满足 $r_j\leq v_{i,j}$ 的 $i$ 是祖先链上一段后缀，可以倍增出来，然后在求出来 $d_k=l_j$ 的点的 $dp$ 值后，对这段后缀做一个链加，可以求 `dfs` 序后树状数组维护，复杂度 $O(n\log n)$。

然后拓展到 $l_i\neq r_i$，依旧考虑对于一个 $j$，当 $i$ 再往上走的时候，$v_{i,j}$ 会改变的点实际就是所有后缀最小值的位置。

我们可以把贡献拆成 $s_{\min(r_j,v_{i\to j})}-s_{l_j-1}$，然后在求出来 $s_x$ 的时候考虑所有 $l_j-1=x$ 或者 $\min (r_j,v_{i,j})=x$ 的 $j$。

$s_{l_j-1}$ 的处理就是 $l_i=r_i$ 的部分，对于另一部分我们考虑对于一个 $j$，一定是先取一段 $r_j$，然后取到某个 $lim_u=v_{i,j}$ 的 $lim_u$，我们令 $u$ 为这些点里深度最大的（也就是严格的后缀最小值），那么我们枚举 $u$，发现此时 $i,j$ 独立，可以倍增求出 $w_u$ 表示上述的 $j$ 的个数，可以贡献到的 $i$ 也是一段祖先，依旧是一个链加。

$w_u$ 的求法：

对于每个 $i$，求出 $f_i$ 表示 $i$ 到根路径上第一个 $lim_j<lim_i$ 的 $i$，然后 $f_i$ 构成了一棵树，那么可以贡献到的 $w_u$ 构成了这棵新树上的一段祖先链，差分即可。


综上，我们只需用倍增和树状数组就在 $O(n\log n )$ 复杂度解决了这个题。

---

## 作者：Harry27182 (赞：51)

## 前言

谨以本文纪念这道把我送进集训队的题目和我考场上为之作出的奋斗。

## 题解

首先可以分析出来每次冲刺之后的节点深度是比上一次冲刺之后的节点深度浅的，所以可以按照这样的顺序 dp。所以每次的流程就是先休息落到子树内一个位置，然后冲刺到一个深度更浅的位置。

考虑对这个过程进行 dp，设 $f_x$ 表示从 $x$ 出发走到根节点的方案数。那么最普通的转移就是 $f_x=\sum_{y\in \text{link}(x)}\sum_{v\in \text{subtree}(x)}[\min_{p\in \text{link}(x,v)}dep_p-h_p\geq dep_y][dep_y\in [dep_p-r_p,dep_p-l_p]]f_y$。暴力实现这个即可做到 $O(n^3)$，稍加优化即可做到 $O(n^2)$。

考虑使用数据结构维护这些东西，首先在全局上考虑，每个 $v$ 能够转移到的是一段 $dep$ 区间，所以在全局上用一棵线段树维护，需要支持单点 $a$ 修改，区间 $b$ 加，查询区间 $a\times b$ 和。前者是修改从根到链上的 $f$ 值，后者在于处理 $v$ 的贡献变化。

对于 $f$ 值的修改显然在 dfs 的过程中只会发生 $O(n)$ 次。考虑如何处理 $v$ 的贡献变化。首先从 $u$ dfs 到儿子 $v$ 的时候，对于除了 $v$ 以外的其他儿子贡献是需要删掉的，这里如果暴力处理的话复杂度显然不对，所以需要使用启发式分裂。每次启发式分裂的时候丢掉所有轻儿子的贡献，轻儿子里面每个节点造成贡献的区间是可以简单通过一遍 dfs 求出的，这部分的操作次数是 $O(n\log n)$。

对于每次由根走向重儿子的时候，重儿子内部节点的贡献区间也会发生变化，具体来说是某些点失去了子树根节点的限制之后贡献到的区间会变大，在 dp 过程中是很难维护这个变大的过程的，所以需要先 dfs 一遍，从下到上预处理出来每个点到重儿子过程中重儿子节点的贡献区间变化。

预处理的过程中，用 set 启发式合并维护所有节点对应的贡献区间左端点。每个节点的限制是把右端点对一个数 $x$ 取 $\min$，这个可以用线段树维护每个贡献区间右端点的位置有多少个点贡献到这里。每个节点为根维护一个这种线段树，然后线段树合并上来。由于每一次操作都会删掉一个不同的右端点，也就是减少一个贡献区间的右端点种类来进行 $1$ 的操作。所以这部分总的势能是 $O(n)$ 的，也就是为 dp 贡献的修改次数是 $O(n)$ 的。同时再把左端点已经比 $x$ 大的区间拿出来，由于每个区间只会以这种形式贡献一次，所以这部分的修改次数也是 $O(n)$ 的。

预处理出来这些修改操作存下来，然后 dp 的时候用线段树维护即可。总的复杂度就是 $O(n\log^2 n)$，可以通过本题。

## 后记

这道题是决定我的 OI 生涯的一道题，我在有限的比赛时间里选择了去冲这题正解，并且在最后 1h 内调出来，看到了 selfeval 的 Right Output! 100pts。我十分感谢考场上的自己做出的这个决定。

> 为什么要攀登？因为山就在那里。

---

## 作者：ty_mxzhn (赞：19)

免责声明：场外选手纯凑热闹。我只是一个 CSP-S 2= 的准退役选手别骂我呜呜呜，从描述就可以看出作者可能会讲的比较初等，请见谅。

“为什么要攀登？因为山就在那里。”

下文定义 $\displaystyle s_i = d_i - h_i - 1,p_{i,j}=\min_{k \in \mathrm{path}_{i,j}}s_k$。

设 $f_i$ 为点 $i$ 到山顶的方案数。简单分析一下，可以发现肯定是先向下走一段距离到一个点 $j$，再突然跳到一个 $j$ 的祖先（由题目的另一个描述可以知道这同样是 $i$ 的祖先）$k$ 上。一路上经过了 $i$ 到 $j$ 路径上的所有点还有 $k$ 点。有图为证：

![](https://cdn.luogu.com.cn/upload/image_hosting/kk6k3keu.png)

我们为了求出 $f_i$，需要用 $f_k$ 贡献。仔细读题后发现，$k$ 的两个条件都比较强，一个是 $d_j-r_j \leq d_k \le d_j-l_j$，另一个是 $d_k \leq p_{i,j}$。

但是我们发现这两个条件都和 $j$ 有关，而且根据一大堆题目的经验，我们从 $j$ 点开始考虑。

计算出每一个点到根节点的 $f$ 的总和 $g$。因为 $k$ 是 $i$ 的祖先上的一个区间，所以采用前缀和，要加在 $f_i$ 上的答案变为 $g_{\min(d_j-l_j,p_{i,j})}-g_{d_j-r_j-1}$。

分类讨论点 $i$ 的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/qzuoel2y.png)

如图，红点是不能被算入贡献（$p_{i,j}<d_j-r_j$）的，黄点是 $p_{i,j} < d_j-l_j$ 的。绿点是 $p_{i,j} \ge d_j -l_j$ 的。可以发现红黄绿三种点一定是如图排列的。

$-g_{d_j-r_j-1}$ 的贡献，用倍增找到黄绿点以后可以直接链加上去。下文考虑 $g_{\min(d_j-l_j,p_{i,j})}$。

绿点很好处理，用倍增找到以后可以直接链加上去。

黄点比较难。考虑**枚举**从 $j$ 到 $i$，前缀最小值的位置（如果有多个请取深度最大的那个）$x$，请观察以下的图片（由一条链沿着叶子到根的方向拍下来）。

![](https://cdn.luogu.com.cn/upload/image_hosting/r52n7qza.png)

其中，$j$ 会一直到一个比当前这个前缀最小值更小的位置（但是，不能越过绿点的界线，也就是 $d_j-l_j > h_x$）。$i$ 点同理。所以，我们可以随便用数据结构维护 $j$ 的个数，然后直接链加到每个 $i$ 上。

这里有许多的链加操作，事实上不需要树链剖分，只需要差分一下然后查询的时候查子树和就可以了。用 dfs 序，写一个树状数组即可。

另外有一个细节就是因为我们不能等枚举到 $j$ 了才做这些操作（因为 $i$ 是 $j$ 的祖先）。所以我们要把 $j$ 的每一个限制（$d_j-r_j,d_j-l_j$）给离线，然后当 $k$ 的数据算出时立马贡献。当然，前缀最小值 $x$ 同理。

总结：很厉害，学到了很多。

但是作者太菜了，而且怕给其他人带来不便，所以不放代码了。

本题解参考了[其他题解](https://www.luogu.com.cn/article/givn512y)，主要用于自己总结用，并且另外补充了一下图解。

---

## 作者：唐一文 (赞：15)

目前题解区里还没人和我做法一样，，？

考场做法，只用到了倍增和线段树，感觉挺好写。考场上从开题到过题只用了 2h。

**最底下有省流版（？）。**

以下是我考场里比较详细的思路，所以比较长。

先考虑如何 $O(n^2)$ 做，然后再想优化。

容易先想到一个状态数是 $O(n^2)$ 的 DP，即记录起点，并将向上跳多少的限制记在状态里。这个 DP 的转移顺序看起来比较的混乱。那么我们再观察一下这个转移的过程。

记一个节点 $x$ 的限制为至少跳到深度为 $v_x$ 的祖先，$v_x=d_x-(h_x+1)$。我们改 $l_x$ 与 $r_x$ 的定义为能跳到的祖先深度区间。

假如说我现在以节点 $x$ 作为起点，首先有个限制 $lim=v_x$，然后接下来走一步会有两种选择：

1. 向上跳到祖先 $p$，那么限制会变为 $lim=\min(lim,v_p)$，容易发现一定会是 $lim=v_p$。
2. 向下走到一个儿子 $y$，那么限制会变为 $lim=\min(lim,v_y)$。

在第一种情况里，限制只跟 $v_p$ 有关。因此可以看作以节点 $p$ 作为起点。那么此时就变成了一个相同的子问题。

在第二种情况里，若 $lim$ 不变，那么限制还是 $v_x$；若 $lim$ 发生了改变，那么限制就只跟 $v_y$ 有关了。假如说 $lim$ 发生了改变，那么就又可以将 $y$ 作为一个新的起点。

那么此时我们就有了一个状态数 $O(n)$ 的 DP：$f(x)$ 表示以 $x$ 作为起点的方案数。

由上述分析我们容易知道转移的顺序：因为 $lim$ 是越来越小的，所以我们按 $v_x$ 从小到大求出每个 $f(x)$ 即可。

那么我们也容易得知求 $f(x)$ 的一个暴力转移：

从 $x$ 开始向子树内 BFS，会遇到两种点。
1. 如果碰到了已经求过 DP 值的节点，那么这个节点的限制一定比 $x$ 严格，直接用这个节点的 DP 值更新 $f(x)$。
2. 若 BFS 到的当前节点还没有求出 DP 值，那么计算从这个节点向上跳的方案数（即将其可以向上跳到的节点与 $x$ 的限制求交得到的所有节点的 DP 值之和），然后继续向下 BFS。

这个 DP 暴力转移是 $O(n^2)$ 的，瓶颈在于上述 BFS 的过程。

对于 1 类点来说，我们希望找到从 $x$ 向下 BFS 第一次碰到的所有限制严于 $x$ 的所有节点的 DP 值。

对于 2 类点来说，我们希望把 $x$ 子树中比 $x$ 限制更严的点的子树删掉，剩下的点就是 2. 中的情况。

此时我不知道从何处下手了，接着想到了一个不知道能不能继续做的做法：求了根号次 DP 值就重构？但是这个对我来说太难往下继续思考了。

于是我先看了部分分：树为一条链。

这种情况下，对于 $x$ 来说，向它子树内 BFS 时碰到的 1 类点只有一个，2 类点形成了一段区间。我们记 $nxt_x$ 代表 $x$ 子树内的 1 类点（即 $[x+1,n]$ 中第一个限制严于 $x$ 的点）。

那么 $f(x)$ 就很好求了（注意 $l_x,r_x$ 的含义与原题中的含义不同，在题解一开始的时候讲过）：

$$f(x)=f(nxt_x)+\sum_{x<y<nxt_x}\sum_{l_y\leq i\leq \min(r_y,v_x)}f(i)$$

其中 $\sum f(i)$ 可以用前缀和表示，记 $s(x)$ 为 $f$ 的前缀和，那么

$$f(x)=f(nxt_x)+\sum_{x<y<nxt_x}s(\min(r_y,v_x))-s(l_y-1)$$

其中 $-s(l_y-1)$ 与 $x$ 无关，可以直接预处理，$s(\min(r_y,v_x))$ 也可以根据 $r_y$ 与 $v_x$ 的大小关系来分类讨论，从而去掉 $\min$。

总结一下，我们得出了树为一条链的做法：从前往后扫描，碰到 $l_y-1$ 的时候将 $-s(l_y-1)$ 的贡献放在 $y$ 上，碰到 $r_y$ 的时候将 $s(r_y)$ 的贡献放在 $y$ 上。碰到 $v_x$ 的时候求 $f(x)$ 的值，我们需要求出 $(x,nxt_x)$ 中的贡献之和，以及有多少个 $y$ 假了 $-s(l_y-1)$ 的贡献但是没有加 $s(r_y)$ 的贡献：这些 $y$ 都对 $x$ 产生了 $s(v_x)$ 的贡献。

这个统计 2 类点对 $x$ 造成贡献的方法可以很容易地拓展到树上。那么我们又回到了一个问题上：我们如何删掉一个子树？

此时我想到了一个做法：用 $u(x)=0/1$ 代表 $x$ 有没有被删除。求出一个点 $x$ 的 DP 值时，将 $x$ 子树里的点的 $u$ 值全都改为 $1$。

这显然是个错的做法：我们 DFS 到 $x$ 子树里的时候可是要用到这个子树里的点啊，怎么能删掉呢？可是我们 DFS 到 $x$ 子树时，直接遍历 $x$ 子树将 $u$ 值全都变为 $0$ 也是不对的，因为 $x$ 子树里可能已经有要删掉的子树了。

那么我们可以更改 $u(x)$ 的定义，将**有没有被删除**改成**被删除了几次**。这时候豁然开朗了：我惊奇地发现，$x$ 子树里的 $u$ 值，它们都 $\ge u(x)$，并且 $x$ 子树里的 2 类点，它们的 $u$ 值都等于 $u(x)$！

（这个东西证明很简单，但是我考场上没有思考正确性我就不写了）

那么我们利用 DFS 序将子树变成区间，记录一个 `pair`，表示区间中 $u$ 的最小值，以及 $u$ 等于最小值的那些点的信息就能求出所有 2 类点的贡献了！

1 类点的贡献也迎刃而解了：在打删除标记的时候不将子树的根打标记，然后维护 $u$ 最小值的 DP 值之和即可。（2 类点的 DP 值都为 $0$ 所以 2 类点不会造成影响）

## 省流

记 $f(x)$ 为从 $x$ 开始走的答案。假如走到某个点，限制突然改变了那么就可以直接用这个点的 $f$ 值用来更新 $f(x)$。

向上跳肯定会改变限制，那么考虑朝子树里走的情况：

1. 朝子树里走到一个改变限制的点，需要求出这些点的 $f$ 之和。
2. 走到一个不改变限制的点，然后向上跳。

第二种情况是跳到一条祖先后代链，假如说找到了这些点就可以用前缀和解决。

那么我们来找这些点。我们求出一个点的 $f$ 就对其子树里的所有点打上一个删除标记。记 $u(x)$ 表示 $x$ 被删除了几次。那么求 $f(x)$ 时，所有 $u$ 值等于 $u(x)$ 的那些点都是第二种情况里的点。通过 DFS 序将子树变成区间，用线段树维护 `pair` 的方法维护区间内 $u$ 最小值的信息即可。

第一种情况就是打删除标记时不将根打标记即可。复杂度 $O(n\log n)$。

代码只拍了照片，而且写的比较丑陋（有一些毫无意义/意义不明的代码片段），如果某天我想写了就重写一份吧（

洛谷图床不知道为啥传不上来，图片放[博客园](https://www.cnblogs.com/tevenqwq/gallery/2416944.html)里了。

~~这篇题解是不是也可以放博客园里（~~[放了](https://www.cnblogs.com/tevenqwq/p/18368230)

---

## 作者：C1942huangjiaxu (赞：11)

考场上想的做法，感觉和讲评的做法比较像。

可以发现每次冲刺后到达的节点深度是递减的，并且 $h$ 的限制恰好是当前节点的限制，等价于从当前节点出发。

于是就可以直接 $DP$ 了，$f_i$ 表示从 $i$ 节点出发到达 $1$ 节点的方案数。

转移枚举子树内的节点 $u$，然后枚举可以冲刺到的节点 $v$，从 $f_v$ 贡献到 $f_i$。

可以 dfs 子树求出每个祖先 $v$ 对 $i$ 的贡献系数，时间复杂度 $O(n^3)$，~~可能可以过 n=5000 的数据~~，容易优化到 $O(n^2)$。

注意到容易从下到上线段树合并求出每个节点的系数，但是 DP 转移又要求我们从上到下。

这里我的解决办法是，考虑像[ [十二省联考 2019] 希望](https://www.luogu.com.cn/problem/P5291)这题一样，回退数据结构，把线段树合并的过程直接存下来，然后 DP 时再回退回去。

细节有点多，然后因为求答案时要 pushup，所以要把修改时所有访问到的节点记录下来，而不是只记录修改的节点。

时空复杂度 $O(n\log n)$，常数非常大。

参考代码（没怎么卡常的版本，qoj 要跑 1.6 s）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,P=998244353,M=N*60;
int tid,T,n,p[N],l[N],r[N],h[N],w[N],ans,f[N],dp[N],rp[N];
int rt[N],ls[M],rs[M],cv[M],sum[M],va[M],cnt,tp;
bool vis[M],dl[M];
vector<int>e[N];
struct rb{
	int ty,x,y;
}st[M<<2];
inline int md(int x){
	return x>=P?x-P:x;
}
inline void Add(int &x,int y){
	if((x+=y)>=P)x-=P;
}
inline void chg(int k,int v){
	st[++tp]=rb{1,k,cv[k]};
	cv[k]=v,dl[k]=false;;
}
inline void mer(int x,int y){
	st[++tp]=rb{2,x,y};
	chg(x,cv[x]+cv[y]);
}
inline void mdf(int k,int x,int y){
	cv[k]=x,va[k]=y,vis[k]=false;
}
inline void pushup(int k){
	sum[k]=(sum[ls[k]]+sum[rs[k]]+1ll*va[k]*cv[k])%P;
}
void modify(int &k,int l,int r,int x,int y){
	if(!k)k=++cnt;
	if(x<=l&&r<=y)return chg(k,cv[k]+1);
	chg(k,cv[k]);
	int mid=l+r>>1;
	if(x<=mid)modify(ls[k],l,mid,x,y);
	if(y>mid)modify(rs[k],mid+1,r,x,y);
}
int merge(int x,int y,int l,int r){
	if(!x||!y)return x|y;
	if(l==r){
		mer(x,y);
		return x;
	}
	int mid=l+r>>1;
	mer(x,y);
	ls[x]=merge(ls[x],ls[y],l,mid);
	rs[x]=merge(rs[x],rs[y],mid+1,r);
	return x;
}
void clear(int &k,int l,int r,int p){
	if(!k||dl[k])return;
	if(l>=p){
		chg(k,0);
		if(l==r)return;
		int mid=l+r>>1;
		clear(ls[k],l,mid,p);
		clear(rs[k],mid+1,r,p);
		dl[k]=true;
		return;
	}
	int mid=l+r>>1;
	if(!ls[k])ls[k]=++cnt;
	if(p>mid&&!rs[k])rs[k]=++cnt;
	chg(ls[k],cv[ls[k]]+cv[k]);
	if(p>mid)chg(rs[k],cv[rs[k]]+cv[k]);
	chg(k,0);
	clear(rs[k],mid+1,r,p);
	if(p<=mid)clear(ls[k],l,mid,p);
}
void ins(int k,int l,int r,int x,int v){
	if(!k)return;
	mdf(k,cv[k],md(va[k]+v));
	if(l==r)return;
	int mid=l+r>>1;
	if(x<=mid)ins(ls[k],l,mid,x,v);
	else ins(rs[k],mid+1,r,x,v);
}
void restore(int o){
	while(tp>o){
		int x=st[tp].x,y=st[tp].y;
		if(st[tp].ty==2)mdf(y,cv[y],va[x]);
		else mdf(x,y,va[x]);
		--tp;
	}
}
void dfs1(int x){
	for(auto v:e[x])dfs1(v);
	rp[x]=tp;
	for(auto v:e[x])rt[x]=merge(rt[x],rt[v],0,n-1);
	modify(rt[x],0,n-1,dp[x]-r[x],dp[x]-l[x]);
	clear(rt[x],0,n-1,dp[x]-h[x]);
}
void dfs3(int x){
	if(!x||vis[x])return;
	vis[x]=true;
	dfs3(ls[x]),dfs3(rs[x]);
	pushup(x);
}
void dfs2(int x){
	if(x==1)f[x]=1;
	else dfs3(rt[x]),f[x]=sum[rt[x]];
	ins(rt[x],0,n-1,dp[x],f[x]);
	restore(rp[x]);
	reverse(e[x].begin(),e[x].end());
	for(auto v:e[x])dfs2(v);
}
void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)e[i].clear(),rt[i]=0;
	for(int i=1;i<=cnt;++i)ls[i]=rs[i]=cv[i]=va[i]=sum[i]=vis[i]=dl[i]=0;
	cnt=tp=0;
	for(int i=2;i<=n;++i){
		scanf("%d%d%d%d",&p[i],&l[i],&r[i],&h[i]);
		e[p[i]].push_back(i);
		dp[i]=dp[p[i]]+1;
	}
	dfs1(1);
	dfs2(1);
	for(int i=2;i<=n;++i)printf("%d%c",f[i]," \n"[i==n]);
}
int main(){
	scanf("%d%d",&tid,&T);
	while(T--)solve();
	return 0;
}
```

---

## 作者：forest114514 (赞：11)

upd：晚上突然想到某一步分析错了，修改了一下。


场外弱鸡选手 VP 的时候成功口胡出了这道题，却因为代码能力太差了成功编程半小时，调试一上午……

本题个人认为部分分设置是非常好的！本蒟蒻也是在部分分的启发下才能很快想出正解做法，所以本题解也侧重于讲述如何从部分分入手一步步想到正解。

- **最暴力的部分**

  注意到我们行动的阶段是首先从一个点 $u$ 的子树某一个点出发冲刺到 $u$ 的一个祖先处，然后变成了一个子问题，因为每次冲刺到的点深度单减，所以可以 DP。

  设 $f_{u}$ 为 $u$ 出发走到 $1$ 的方案数，每次枚举从子树哪个点出发，走到哪个祖先即可，则有：
  $$
  f_{u}=\sum\limits_{v\in subtree_{u}}\sum\limits_{p\in ancestor_{u}}[dep_{p}\in [dep_{v}-r_{v},dep_{v}-l_{u}]\land dep_{p}<\min \limits_{i\in path(u,v)}(dep_{i}-h_{i})] f_{p}
  $$
  直接是 $O(n^3)$ 的，发现每个 $v\in subtree_{u}$ 的能走到的 $p$ 是一条链，差分一下求链上前缀和就能做到 $O(n^2)$（~~此时发现 $l_i=r_i$ 的性质似乎没有什么意义？~~）。

  现在直接对着这个式子优化不容易，我们先想想特殊性质，这个策略在赛场上也是正确的。

- **树是一条链**

  这是最简单的部分，因为从序列问题的难度一般比树上问题低得多。

  假设我们已经求出了 $f_{i}$ 的答案，我们能不能快速求出 $f_{i+1}$ 的答案呢？

  考虑 $f_{i}$ 的答案有两部分：$i$ 出发的部分和 $[i+1,n]$ 出发的部分；$f_{i+1}$ 的答案只有 $[i+1,n]$ 出发的部分，所有部分都是若干前缀和查询。

  但是 $f_{i}$ 和 $f_{i+1}$ 对于 $[i+1,n]$ 出发的部分有一点不一样，前者的 $\min \limits_{j\in path(u,v)}(dep_{j}-h_{j})$ 会有 $dep_{i}-h_{i}$ 的限制，所以考虑加上这个限制之后的变化，其实把某一些 $>dep_{i}-h_{i}-1$ 的查询变成了 $dep_{i}-h_{i}-1$。

  其实我们可以暴力统计，因为对查询的取 $\min$ 后每次只会新增 $O(1)$ 个本质不同的深度，而每个深度只会被删除一次，所以均摊是 $O(n)$ 的，那直接用一个能统计有序二元组，删除一段值域区间时间复杂度为 $O(\text{点数})$ 的数据结构就行了，可以用堆或平衡树，简单起见用 std::map 即可，时间复杂度 $O(n\log n)$。

- **$h_{i}=0$**

  这样其实每个子树出发时 $\min \limits_{j\in path(u,v)}(dep_{j}-h_{j})$ 的限制就是 $dep_{p}<dep_{u}$，此时 $h$ 的限制几乎没有作用了。

  首先类比链的做法，已知 $u$ 递推其所有儿子的答案，但是 $u$ 会有其所有儿子的贡献，不好直接递推，但我们可以考虑树上启发式合并，可以直接暴力计算 $u$ 所有轻子树的 $f$ 值和贡献，最后用 $f_{u}$ 减去 $u$ 的贡献和 $u$ 所有轻子树的贡献就得到了重子树的贡献，考虑 $h_{i}=0$ 的时候每次对 $dep_u-1$ 取 $\min$ 只会有 $dep_{son_{u}}-1$ 的询问发生变化，所以变化时严格 $O(n)$ 的，可以借鉴链性质的部分维护重子树的变化量，只是在原做法上套了一个 dsu on tree，此时时间是 $O(n\log ^2n) $ 的，如果 std::map 换成平衡树+finger search 能做到 $O(n\log n)$。

- **正解**

  其实 $h_i=0$ 的部分和 $h_i\geq 0$ 差了一个性质就是每次重儿子对 $dep_{i}-h_{i}-1$ 取 $\min$ 时变化的点只有严格 $O(1)$ 的，而借用链部分的均摊 $O(n)$ 的做法似乎难以说明树上能均摊 $O(n)$ 次改变，但其实是可以的。

  考虑我们只用记录重儿子在对 $dep_{u}-h_{u}-1$ 取 $\min$ 时候的有哪些点被修改了，而借用重链剖分的理论其实就是我们对一条重链做了链部分类似的操作，考虑每次修改类似于区间推平，然后加 $O(1)$ 个点，所以一条重链均摊下来修改操作有 $O(\text{链长})$ 次，所以树上的操作均摊还是 $O(n)$ 次删除，可以记录下来。

  如果像我一样偷懒写 std::map 暴力修改+暴力启发式合并的话时间是 $O(n\log ^2 n)$ 的，空间的话是 $O(n)$ 的，只不过在 std::map 的加持下还是有 40MB 的空间。

  这个做法常数很小，在我 `#define int long long` 这个常数炸弹的加持下最慢点也才 280ms。

至于 $l=r$ 的部分因为我做的时候还没看就想到正解就没写了……

[因为一直调不出来导致十分难看的代码](https://qoj.ac/submission/490549)

---

## 作者：Alan_Zhao (赞：8)

## 题解

这是另一种比较好写的做法，只需要树剖。

首先考虑朴素的 DP，设 $f_u$ 表示从 $u$ 移动到点 $1$ 的方案数，记 $\mathrm{sub}_u$ 表示 $u$ 子树内的点，$\mathrm{anc}_u$ 表示 $u$ 的所有祖先，有

$$
f_u=\sum_{v\in \mathrm{sub}_u} \sum_{x\in \mathrm{anc}_u} \left[d_x<\min_{y\in \mathrm{path}_{u,v}} (d_y-h_y)\right] \left[d_x\in [d_v-r_v,d_v-l_v]\right] f_x.
$$

其中 $v$ 枚举的是滑落到了哪个点，$x$ 枚举的是最后一次冲刺到了哪个点。如果固定 $v$，那么能转移到的 $x$ 是 $u$ 的祖先里深度在一个区间内的所有点。

困难之处在于，我们需要知道 $u$ 的所有祖先的 $f_v$ 才能算出 $f_u$，所以不能直接线段树合并维护子树内所有 $v$ 的值。

考虑树剖，按照 DFS 序对每条重链算出 $f_u$。对于重链上每个点 $u$，我们需要维护出 $\mathrm{sub}_u$ 中所有点对应的深度区间，也就是 $[d_v-r_v,\min(d_v-l_v,\min_{y\in \mathrm{path}_{u,v}} (d_y-h_y-1))]$。

在重链上从上往下维护这个是不好做的，但我们可以先从下往上做，然后再一步步地撤销。具体地，先从下往上枚举重链上的每个点 $u$，将 $u$ 的所有轻子树内的点加入到数据结构中（这里可以将一个区间 $[l,r]$ 拆成在 $r$ 处贡献 $1$，在 $l-1$ 处贡献 $-1$ 的两个单点），然后再把数据结构内的所有点的下标对 $d_u-h_u$ 取 $\min$，而取 $\min$ 也可以拆成均摊 $O(1)$ 个单点修改。

在撤销过程中，我们还需要询问数据结构中所有点对应的下标 $k$ 的 $\sum_{v\in \mathrm{anc}_u\land d_v\le k} f_v$ 之和。注意到刚才的修改只有单点修改，所以这也是容易维护的。

在这个过程中，数据结构需要支持的操作只有单点修改和查询最大的贡献非零的位置，所以直接用 map 维护即可。

因为所有轻子树大小之和是 $O(n\log n)$ 的，所以我们总共会在 map 中插入 $O(n\log n)$ 个点，总的时间复杂度是 $O(n\log^2 n)$。跑得很快。

## 代码

拿不到。

---

## 作者：qiuzx (赞：7)

考虑对每次冲刺的位置进行 dp，注意到一次冲刺之后所有的限制仅和这个点及之后走的点有关，所以可以记 $f_i$ 表示从 $i$ 出发走到根的方案数。考虑转移，枚举下滑到的点 $u$，则 $u$ 在 $i$ 的子树中，且这一路经过 $i\to u$ 的所有点，就要求下一次冲刺到的点深度 $<\min d_j-h_j$（其中 $j$ 在 $i\to u$ 的路径上）。那么下一次可以冲刺到的点就是 $u$ 的祖先中深度位于一段区间内的点，容易做到 $O(n^2)$。

由于我们转移的顺序是从上往下，所以假如我们能够对每个 $u$ 实时地维护它所有能够转移到的区间的 dp 值之和，那么一次转移就是一个子树求和，是容易的。现在的问题相当于是在树上按照编号顺序依次删除点，对每个仍然没有被删除的点，其现在能被贡献到的点的深度区间是 $[l_i,\min(r_i,v_i)]$，其中 $v_i$ 为 $i$ 到所在连通块的根的路径上的 $d-h$ 的最小值再 $-1$，我们需要动态维护这个深度中点的 dp 值之和（显然这个区间内点的所有 dp 值都是已经被求出的）。

当我们删除一个点的时候（它一定是根），会使得其子树内的所有 $v_i$ 增加一定的值，但具体变成多少与哪个点是有关的，所以暴力修改不可行。然而注意到如果我们不是删除一个点，而是添加一个根，那么相当于子树内的所有 $v_i$ 和同一个值取 $\min$，这个就是比较好维护的。

具体来说，若两个点在某一次取 $\min$ 的时候值都产生了变化，那么它们之后任意时刻 $\min(r_i,v_i)$ 都是相等的，于是可以将这两个点合并起来。这样从下往上倒着添加所有点，使用启发式合并即可求出每次修改的时候合并了哪些点，以及它们的值分别是从哪个值变过来的。不过在启发式合并的时候，我们只能从较小的集合并入较大的集合，这意味着对于较大集合的修改，我们不能对每个点都储存一遍。因此我们只能对这个较大的集合打一个整体的标记，然后考虑怎么做整体修改。

在从上往下 dp 的时候，一开始所有点都被合并在一个点上，我们对于每个等价类选任意一个点作为代表元，将这个等价类中所有点能够转移到的位置的 dp 值之和维护在这个点上。在每个点处先更新它的 dp 值，这个就是子树中所有点维护的值之和。注意显然不会出现两个不在同一连通块内的点被合并在一个等价类中，所以取任意一个点作为代表元就是对的。然后去删除这个点，首先使用之前处理的合并操作结果，将每个较小的点分裂出去，并直接暴力更新其能转移到的 dp 值之和，这个可以通过倍增求出。最后需要处理最大等价类的整体修改，注意到由于我们只关心其 dp 值之和，而其中每个点都是将右端点从某个 $r$ 变成 $r'$，所以只需要维护当前等价类的大小即可完成修改。这样就做完了，时间复杂度 $O(n\log^2n)$，空间复杂度 $O(n\log n)$。

需要注意的是当更新出了 $r_i<l_i$ 的情形时，需要在那个点上打一个标记，在统计大小的时候不能将它计入。

---

## 作者：strcmp (赞：6)

> 揺れるキャンドル必死こいて守ってでも
> 
> その震えた脚で立ってたいんでしょう
>
> 踏み外したら最後一直線　奈落の環状線
>
> そろそろもう良いかい　時間だぜ
>
> 「本物はどっちでしょう」

---

怎么交题解的时候忘记看上面有没有写完了/lh

---

省流：

先写出 dp 式子，是 $f_u \leftarrow [d_x \in [l_v,\,\min(r_v,\,u \to v)]]f_x,\,x \in \text{anc}(u) \wedge v \in \text{subtree}(u)$ 的形式。

注意到向上合并过程中 $R$ 等价类的改变次数是 $\Theta(n)$ 级别的。

然后 dsu on tree 从下到向上合并出区间系数的改变量。

再 dfs 一遍，用 $f_u$ 减去重链的改变量对 $f$ 的贡献，暴力统计轻子树的贡献递推出重儿子的 $f$ 值。

---

符号规定：$d$ 是深度，$\text{subtree}$ 是子树，$\text{anc}$ 是祖先。

显然考虑树形 dp。

一个想法是枚举 $u$ 开始滑落到子树内结点 $v$ 处，然后枚举休息完后冲刺到的结点 $x$ 是哪个。

首先代换 $l_v \leftarrow d_v - r_v$，$r_v$ 同理。

有转移：

$$
l_v \le d_x \le \min(r_v,\,\min\limits_{u \to v} \{d - h - 1\}) \quad : \quad f_{u} \leftarrow \sum f_{x} \\v \in \text{subtree}(u),\,x \in \text{anc}(u)
$$

容易维护祖先 $x$ 到 $u$ 的前缀和做到 $\Theta(n^2)$。

因为 $\min \{ d - h \}$ 是单调的，$d - h,\,l_v,\,r_v$ 是固定的，$d_x$ 的限制还是跟 $f$ 无关的区间，非常的优美。这个形式看起来极其可优化。

你发现 $u$ 向下的过程，是比较难搞 $\min d - h$ 这个东西的，因为路径在不断变短，对 $\min$ 这种没有可减性的运算是很难维护的。

那不妨我们先子树到根向上求一遍系数，再根向子树向下搞 dp 之类的。

---

怎么向上求系数？

一般来说树上维护类似东西。我们有两类思考方向，一个是线段树合并，或者考虑链分治点分治等。

线段树合并？我们发现很不方便，因为线段树合并整个确实是一个从下到上的过程。固然是可以求出来系数的，但从下到上有一个问题就是我们难以得知 $f_{\text{anc}(u)}$ 的值，进而也很难算出来 $f_u$ 是什么（当然是能解决这个问题的，就是 article/mp4di8ev 这篇说的方法，栈记录回滚线段树合并）。

那不妨去考虑重链上的东西。重链有很多很好的性质，比如：轻子树的总大小和是 $\Theta(n \log n)$ 级别的，这也是树上启发式合并的复杂度保证。而且重链的链结构让我们可以相当方便的在上面插入和回滚。

---

先规范描述一下我们要求的东西：

维护：

$$
\begin{aligned}
& g_{k} \leftarrow \sum_{d_x = k} f_{x} \qquad x \in \text{anc}(u)\\ 
& f_u \leftarrow \sum_{L_v \le k \le R_v} \limits{g_{k}} \qquad v \in \text{subtree}(u)\\
\end{aligned}
$$

当 $u \to fa$ 时：

$$
R_v \leftarrow \min(R_v,\,d_{fa} - h_{fa} - 1) \qquad v \in \text{subtree}(u) \\
$$

同时插入 $fa$，初值 $L_{fa} = l_{fa},\,R_{fa} = r_{fa}$。

乍一眼会修改很多不可避免的点导致复杂度爆炸，冷静思考**一次上升会修改哪些点。**

我们显然只关心 $R_v$ 相等的那些东西（$g_{R_v}$），如果它们最后都变成一样的，那完事大吉，以后修改把它们全部整体修改就行了。我们称 $R_v$ 相同的 $v \in \text{subtree}(u)$ 为 $R_v$ 等价类。 

转过弯来了吗？我们发现 $d_{fa} - h_{fa} - 1$ 对每个点来说都是固定的，而且会把大于 $d_{fa} - h_{fa} - 1$ 的都覆盖成 $d_{fa} - h_{fa} - 1$。如果能以 $\Theta(kp(n))$ 的复杂度暴力修改 $k$ 个 $R_v$ 不同的等价类，那么这 $k$ 个 $R_v$ 等价类就会合并成一个 $R_v$ 等价类，总均摊复杂度 $\Theta(np(n))$！

如果整棵树是一条链，直接开个 map 就做完了。

你发现这样还是有跟线段树合并类似的问题，也就是不知道 $f_x$ 的值算不了贡献。

但是也有很大的优势，链结构让我们能够方便的上下回滚，那如果我们先链底向上算出系数，然后链顶向下算出来 $f$ 的值就可以了。

那不妨去想想树上启发式合并——dsu on tree。

先根据上面的讨论，利用 dsu on tree 一遍 dfs 计算出系数，这里可以考虑使用 `std::map` 维护（或者随便一棵平衡树都行，如果用 Splay 因为 Finger Search 可以优化到单 $\log$），然后考虑根据系数怎么 dp。

记住 dsu on tree 的本质是树上静态重链分治。

那不妨我们直接记录哪些地方被修改了，顺着重链回滚下去。因为我们已经提前在重链上计算好了系数因此是比较简单的。对于轻链直接暴力算贡献，然后用 $f_u$ 减去轻链贡献再加上重链被修改的变化量，就是重儿子的 $f$ 值。本质上是按顺序做了一次链分治。

于是有了一个 $\Theta(n \log^2 n)$ 的做法，本题时空宽裕容易通过。瓶颈在对于红黑树的启发式合并上，如果使用 Splay 启发式合并可以做到 $\Theta(n \log n)$。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
using namespace std;
typedef long long int ll;
using pii = pair<int, int>;
constexpr int maxn = 2e5 + 10, mod = 998244353; 
struct edge { int to, nxt; } nd[maxn << 1]; int h[maxn], cnt = 0, T, n;
inline void add(int u, int v) { nd[cnt].nxt = h[u], nd[cnt].to = v, h[u] = cnt++; }
int lv[maxn], rv[maxn], siz[maxn], son[maxn], H[maxn], d[maxn], fa[maxn], lim[maxn], st[maxn], t = 0; ll f[maxn], c[maxn], sum[maxn]; vector<pii> e[maxn];
void dfs1(int u) {
	siz[u] = 1, son[u] = 0;
	for (int i = h[u]; ~i; i = nd[i].nxt) {
		int v = nd[i].to; 
		dfs1(v), siz[u] += siz[v]; 
		if (siz[son[u]] < siz[v]) son[u] = v;
	}
}
map<int, int>s[maxn]; 
using iter = map<int, int>::iterator;
void dfs2(int u, int t) {
	if (!son[u]) return ++s[t][rv[u]], --s[t][lv[u] - 1], void();
	dfs2(son[u], t); 
	while (s[t].size()) { 
		iter it = prev(s[t].end()); 
		if (it->X > lim[u]) e[son[u]].pb(*it), c[son[u]] += it->Y, s[t].erase(prev(s[t].end()));
		else break;  
	}
	if (c[son[u]]) s[t][lim[u]] += c[son[u]];
	if (u != 1) ++s[t][rv[u]], --s[t][lv[u] - 1];
	for (int i = h[u]; ~i; i = nd[i].nxt) {
		int v = nd[i].to;
		if (v == son[u]) continue; dfs2(v, v);
		for (pii x : s[v]) s[t][min(x.X, lim[u])] += x.Y;
		s[v].clear();
	}
}
void cc(int u, int rt, int x, int o) {
	if (x >= lv[u])	f[rt] = (f[rt] + (sum[st[min(rv[u], x)]] - sum[st[lv[u] - 1]]) % mod * o % mod + mod) % mod;
	for (int i = h[u]; ~i; i = nd[i].nxt) cc(nd[i].to, rt, min(x, lim[nd[i].to]), o);
}
void solve(int u) {
	if (!son[u]) return; f[son[u]] = f[st[++t] = u];
	for (int i = h[u]; ~i; i = nd[i].nxt) {
		int v = nd[i].to; if (v == son[u]) continue;
		cc(v, v, lim[v], 1), cc(v, son[u], min(lim[u], lim[v]), mod - 1), sum[v] = (sum[u] + f[v]) % mod, solve(v);
	}
	f[son[u]] = (f[son[u]] - sum[st[rv[u]]] + sum[st[lv[u] - 1]] + mod - sum[st[lim[u]]] * c[son[u]] % mod + mod) % mod;
	for (pii x : e[son[u]]) f[son[u]] = (f[son[u]] + sum[st[x.X]] * x.Y % mod) % mod;
	sum[son[u]] = (sum[u] + f[son[u]]) % mod, solve(son[u]), --t;
}
int main() {
	scanf("%*d%d", &T);
	while (T--) {
		memset(h, -1, sizeof(h)); scanf("%d", &n); int x; d[1] = 1;
		rep(i, 2, n) scanf("%d%d%d%d", &fa[i], &lv[i], &rv[i], &H[i]), d[i] = d[fa[i]] + 1, x = lv[i], lv[i] = d[i] - rv[i], rv[i] = max(min(d[i] - x, lim[i] = d[i] - H[i] - 1), lv[i] - 1), add(fa[i], i);
		f[1] = sum[1] = 1; dfs1(1); dfs2(1, 1); st[++t] = 1;
		for (int i = h[1]; ~i; i = nd[i].nxt) {
			int v = nd[i].to;
			cc(v, v, lim[v], 1);
			sum[v] = f[v] + 1, solve(v);
		}
		rep(i, 2, n) printf("%lld ", (f[i] % mod + mod) % mod), f[i] = sum[i] = c[i] = 0, e[i].clear(), s[i].clear(); cnt = t = 0; puts("");
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：5)

**本题解使用主席树和树链剖分解决。**

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18382999)

### 思路：

我们可以对于每个 $i$ 找到它能跳到的最远的点和最近的点，倍增求一下 $k$ 级祖先即可，令 $[l_i,r_i]$ 新表示 $i$ 能跳到其祖先中深度在 $[l_i,r_i]$ 内的点；同时令 $lim_i = d_i - h_i-1$ 表示 $i$ 至少要跳到 $lim_i$ 的深度。

考虑动态规划算法，令 $dp_i$ 表示从 $i$ 出发到山顶的合法登山序列个数。

那么相当于先从 $i$ 滑落到 $j$，然后再从 $j$ 冲刺到 $k$，再加上 $dp_k$ 的方案数。

则状态转移方程为：

$$dp_i = \sum_{j 在 i 子树内} \sum_{k 为 i 的祖先} (d_k \in [l_j,\min(W(i,j),r_j)]) dp_k$$

其中 $W(i,j)$ 表示 $i \to j$ 路径上 $lim_k$ 的最小值，因为每次冲刺到达的深度必须小于所有经过的点的 $lim_k$。

朴素实现是 $O(N^3)$ 的，考虑优化；注意到 $k$ 是 $i$ 的祖先中一段深度连续的点，则我们可以做一个深度的 $dp_i$ 的前缀和，差分即可，时间复杂度优化至 $O(N^2)$，可以得到 25pts。


#### $O(N^2)$ Code：

```cpp
namespace Sub1{
    ll L,R,x,a,b;
    ll s[N],dp[N],dep[N];
    void dfs1(ll u){
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            dep[v]=dep[u]+1;
            dfs1(v);
        }
    }
    ll get(ll l,ll r){
        if(!l)
          return s[r];
        return (s[r]-s[l-1]+mod)%mod;
    }
    void dfs3(ll u,ll Min,ll from){
        L=l[u],R=min(r[u],Min);
        if(L<=R)
          dp[from]=(dp[from]+get(L,R))%mod;
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            dfs3(v,min(Min,h[v]),from);
        }
    }
    void dfs2(ll u){
        if(dep[u])
          s[dep[u]]=(s[dep[u]-1]+dp[u])%mod;
        else
          s[dep[u]]=dp[u];
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            dfs3(v,h[v],v);
            dfs2(v);
        }
    }
    void solve(){
        Read();
        dfs1(1);
        dp[1]=1;
        For(i,2,n){
            dp[i]=0;
            x=i;
            h[i]=dep[i]-h[i]-1;
            while(r[i]){
                x=fa[x];
                l[i]--,r[i]--;
                if(!l[i])
                  b=x;
                if(!r[i])
                  a=x;  
            }
            l[i]=dep[a],r[i]=dep[b];
        }
        dfs2(1);
        For(i,2,n){
            write(dp[i]);
            putchar(' ');
        }
        putchar('\n');
    }
    void work(){
        while(T--)
          solve();
    }
};
```

设 $u^k$ 表示 $u$ 的 $k$ 级祖先，

现在考虑 $l_j=r_j$ 的特殊性质，注意到对于 $i$ 子树内的点 $j$，它最多只会对 $dp_i$ 造成 $dp_{j^{l_j}}$ 的贡献，注意到当 $W(i,j) < r_j$ 时是没有贡献的。

则我们考虑枚举 $j$，且注意到随着 $i$ 的深度的变小 $W(i,j)$ 也会变小，考虑求出 $g_j$ 表示深度最小的使得 $W(g_j,j) \ge r_j$ 的点，直接倍增求即可。

那么对于 $j \to g_j$ 路径上的 $i$ 点，是可以由 $i$ 下滑到 $j$ 后冲刺到 $j^{l_j}$ 的，那么对于 $j \to g_j$ 路径上的 $dp_i$ 的值都会增加 $dp_{j^{l_j}}$。

按照 $j^{l_j}$ 的深度从小到大依次处理即可。

需要维护路径加，单点查，可以直接树剖与树状数组或线段树，时间复杂度为 $O(N \log^2 N)$，这样我们就拿到了 45pts。

#### $O(N \log^2 N)$ 的特殊性质 Code：

```cpp
class Tree{
public:
    ll cnt=0;
    ll p[N],t[N],z[N],d[N],fa[N];
    struct Node{
        ll l,r;
        ll data;
        ll tag;
    }X[N<<2];
	void dfs1(ll u,ll f){
		p[u]=1;
		for(auto v:E[u]){
			if(v==f)
			  continue;
			d[v]=d[u]+1;
			fa[v]=u;
			dfs1(v,u);
			p[u]+=p[v];
			if(p[v]>p[z[u]])
			  z[u]=v;
		}
	}
	void dfs2(ll u,ll k){
        dfn[u]=++cnt;
		t[u]=k;
		if(!z[u])
		  return ;
		dfs2(z[u],k);
		for(auto v:E[u]){
			if(v==fa[u]||v==z[u])
			  continue;
			dfs2(v,v);
		}
	}
    void build(ll k,ll l,ll r){
        X[k].l=l,X[k].r=r;
        X[k].data=X[k].tag=0;
        if(l==r)
          return ;
        ll mid=(l+r)>>1;
        build(k<<1,l,mid);
        build(k<<1|1,mid+1,r);
    }
    void add(ll k,ll v){
        X[k].data=Add(X[k].data,v);
        X[k].tag=Add(X[k].tag,v);
    }
    void push_down(ll k){
        if(X[k].tag){
            add(k<<1,X[k].tag);
            add(k<<1|1,X[k].tag);
            X[k].tag=0;
        }
    }
    void update(ll k,ll l,ll r,ll v){
        if(X[k].l==l&&r==X[k].r){
            add(k,v);
            return ;
        }
        push_down(k);
        ll mid=(X[k].l+X[k].r)>>1;
        if(r<=mid)
          update(k<<1,l,r,v);
        else if(l>mid)
          update(k<<1|1,l,r,v);
        else{
            update(k<<1,l,mid,v);
            update(k<<1|1,mid+1,r,v);
        }
    }
    ll query(ll k,ll i){
        if(X[k].l==i&&i==X[k].r)
          return X[k].data;
        push_down(k);
        ll mid=(X[k].l+X[k].r)>>1;
        if(i<=mid)
          return query(k<<1,i);
        else
          return query(k<<1|1,i);
    }
    void update(ll u,ll v,ll h){
        while(t[u]!=t[v]){
            if(d[t[u]]<d[t[v]])
              swap(u,v);
            update(1,dfn[t[u]],dfn[u],h);
            u=fa[t[u]];
        }
        if(d[u]>d[v])
          swap(u,v);
        update(1,dfn[u],dfn[v],h);
    }
	void init(){
        For(i,1,n)
          z[i]=0;
        cnt=0;
		dfs1(1,1);
		dfs2(1,1);
        build(1,1,n);
	}
}Tr;
namespace Sub2{
    ll x,cnt;
    ll g[N],dep[N],Fa[N][M],F[N][M];
    vector<pi> G[N];
    void dfs1(ll u){
        For(j,1,M-1)
          Fa[u][j]=Fa[Fa[u][j-1]][j-1];
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            dep[v]=dep[u]+1;
            Fa[v][0]=u;
            dfs1(v);
        }
    }
    ll get_fa(ll u,ll k){
        if(!k)
          return u;
        _For(j,0,M-1){
            if(k>=(1ll<<j)){
                k-=(1ll<<j);
                u=Fa[u][j];
            }
        }
        return u;
    }
    void dfs2(ll u){
        For(j,1,M-1)
          F[u][j]=min(F[u][j-1],F[Fa[u][j-1]][j-1]);
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            F[v][0]=h[v];
            dfs2(v);
        }
    }
    void solve(){
        cnt=0;
        Read();
        Tr.init();
        For(j,0,M-1)
          Fa[1][j]=1;
        dfs1(1);
        For(i,0,n-1)
          G[i].clear();
        For(i,2,n){
            x=get_fa(i,l[i]);
            l[i]=r[i]=dep[x];
            h[i]=dep[i]-h[i]-1;
            G[l[i]].push_back({i,x});
        }
        For(j,0,M-1)
          F[1][j]=INF;
        dfs2(1);
        For(i,2,n){
            x=i;
            _For(j,0,M-1)
              if(r[i]<=F[x][j])
                x=Fa[x][j];
            g[i]=dep[x]+1;
            if(g[i]<=dep[i])
              g[i]=get_fa(i,dep[i]-g[i]);
            else
              g[i]=-1;
        }
        Tr.update(1,1,1);
        For(i,0,n-1){
            if(G[i].empty())
              continue;
            for(auto t:G[i]){
                ll v=t.fi;
                if(g[v]==-1)
                  continue;
                Tr.update(v,g[v],Tr.query(1,dfn[t.se]));
            }
        }
        For(i,2,n){
            write(Tr.query(1,dfn[i]));
            putchar(' ');
        }
        putchar('\n');
    }
    void work(){
        while(T--)
          solve();
    }
};
```

现在考虑根据 $l_j=r_j$ 的思路，求 $l_j \ne r_j$ 的情况。

还是一样，枚举 $j$，则对于一个 $i$ 会增加 $s_{\min(r_j,W(i,j))}-s_{l_j-1}$ 的贡献，其中 $s_u$ 在 $j$ 的祖先链上，表示深度为 $1 \sim u$ 的点的 $dp$ 值。

考虑分开计算，发现对于 $-s_{l_j-1}$ 的部分，就是 $l_j=r_j$ 的情况，倍增求出深度最小的点 $i$ 使得 $W(i,j) \ge l_j$，然后对于 $i \to j$ 路径上的点都增加 $-s_{l_j-1}$ 的贡献。

现在是如何处理 $s_{\min(r_j,W(i,j))}$ 的部分，注意到肯定还是先取一段 $r_j$，同样枚举 $j$，倍增找到深度最小的满足 $W(i,j) > r_j$（注意是 $>$） 的 $i$，则对于 $j \to i$ 路径上的 $dp$ 值，都要增加 $s_{r_j}$。

然后考虑处理 $s_{W(i,j)}$ 的情况，考虑枚举 $u$，使得 $lim_u$ 是 $i \to j$ 的严格后缀最小值（即最小值中深度最深的那个点），注意到我们只需要求出 $u$ 子树内有多少个 $j$ 满足 $u \to j$ 的路径中没有小于等于 $lim_u$ 的 $lim_k$，且 $lim_u \in [l_j,r_j]$。

只要求出了这样的 $j$ 的个数 $sum$，则可以倍增求出深度最小的 $i$ 使得 $W(i,u) = lim_u$，那么直接对于 $i \to u$ 的路径上的点，都会增加 $s_{lim_u} \times sum$ 的贡献。

注意到这样操作会有先后顺序的问题，考虑再求出 $s_x$ 时，才考虑 $l_j-1=x$ 和 $r_j = x$ 和 $lim_u=x$ 的贡献。

#### 该部分暴力 Code：

```cpp
namespace Sub3{
	ll Min,sum,x,a,b,c,t;
	ll dep[N],dp[N],g1[N],g2[N],g3[N];
	ll Fa[N][M];
	vector<pi> E1[N],E2[N],E3[N];
    void dfs(ll u){
        For(j,1,M-1)
          Fa[u][j]=Fa[Fa[u][j-1]][j-1];
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            Fa[v][0]=u;
            dep[v]=dep[u]+1;
            dfs(v);
        }
    }
    ll get_fa(ll u,ll k){
        if(!k)
          return u;
        _For(j,0,M-1){
            if(k>=(1ll<<j)){
                k-=(1ll<<j);
                u=Fa[u][j];
            }
        }
        return u;
    }
    ll get_sum(ll u){
    	ll ans=0;
    	while(u){
    		ans=Add(ans,dp[u]);
    		u=fa[u];
		}
		return ans;
	}
	void dfs2(ll u,ll k){
		if(h[u]<=h[k]&&u!=k)
		  return ;
		if(l[u]<=h[k]&&h[k]<=r[u])
		  sum++;
		for(auto v:E[u]){
			if(v==fa[u])
			  continue;
			dfs2(v,k); 
		}
	}
	void solve(){
		Read();
		dfs(1);
		dp[1]=1;
		For(i,0,n-1){
			E1[i].clear();
			E2[i].clear();
			E3[i].clear();
		}
        For(i,2,n){
            dp[i]=0;
            x=i;
            t=h[i]+1;
            h[i]=dep[i]-h[i]-1;
            while(l[i]>=1||r[i]>=1||t>=1){
                x=fa[x];
                l[i]--,r[i]--,t--;
                if(!l[i])
                  b=x;
                if(!r[i])
                  a=x;  
                if(!t)
                  c=x;
            }
            l[i]=dep[a],r[i]=dep[b];
            if(l[i])
              E1[l[i]-1].push_back({i,fa[a]});
            E2[r[i]].push_back({i,b});
            E3[h[i]].push_back({i,c});
        }
        //cerr<<'\n';
        For(i,2,n){
        	if(l[i]){
	        	Min=INF;
	        	x=i,a=-1;
	        	while(fa[x]!=1){
	        		Min=min(Min,h[x]);
	        		if(Min<l[i])
	        		  break;
	        		a=x;
	        		x=fa[x];
				}
				g1[i]=a;        		
			}
			else
			  g1[i]=-1;
			
			Min=INF;
			x=i,a=-1;
			while(fa[x]!=1){
				Min=min(Min,h[x]);
				if(Min<=r[i])
				  break;
				a=x;
				x=fa[x];
			}
			g2[i]=a;
			
			x=i;
			while(fa[x]!=1){
				if(h[fa[x]]<h[i])
				  break;
				x=fa[x];
			}
			g3[i]=x;
			
			//cerr<<i<<':'<<g1[i]<<','<<g2[i]<<','<<g3[i]<<'\n';
		}
		//cerr<<'\n';
		For(i,0,n-1){
			for(auto t:E1[i]){
				x=t.fi,a=get_sum(t.se),b=g1[x];
				if(b==-1)
				  continue;
				//cerr<<"("<<x<<"->"<<b<<")-"<<a<<'\n';
				while(x!=fa[b]){
					dp[x]=(dp[x]-a+mod)%mod;
					x=fa[x];
				}
			}
			for(auto t:E2[i]){
				x=t.fi,a=get_sum(t.se),b=g2[x];
				if(b==-1)
				  continue;
				//cerr<<"("<<x<<"->"<<b<<")+"<<a<<'\n';
				while(x!=fa[b]){
					dp[x]=Add(dp[x],a);
					x=fa[x];
				}
			}
			for(auto t:E3[i]){
				x=t.fi,a=get_sum(t.se),b=g3[x];
				if(b==-1)
				  continue;
				sum=0;
				dfs2(x,x);
				//cerr<<"("<<x<<"->"<<b<<")+"<<sum<<'*'<<a<<'\n';
				while(x!=fa[b]){
					dp[x]=(dp[x]+sum*a%mod)%mod;
					x=fa[x];
				}
			}
		}
		For(i,2,n){
			write(dp[i]);
			putchar(' ');
		}
		putchar('\n');
	}
	void work(){
		while(T--)
		  solve();
	}
};
```

这样的话操作都是一些基本操作，链加，链查，倍增优化等，唯一需要注意的是查询 **$u$ 子树内有多少个 $j$ 满足 $u \to j$ 的路径中没有小于等于 $lim_u$ 的 $lim_k$，且 $lim_u \in [l_j,r_j]$**。

考虑对于 $i$ 找到 $i \to 1$ 的路径上第一个满足 $lim_j < lim_i$ 的 $j$，那么令 $Fa_i = j$。

根据这个 $Fa$，建出边为 $i \to Fa_i$ 的新树，那么上述询问就变为了在求新树中 $u$ 子树内的点 $j$ 满足 $lim_u \in [l_j,r_j]$ 的个数，证明显然，不再阐述。

那么可以每次将 $[l_j,r_j]$ 范围内的 $sum_i$ 增加 $1$，那么满足条件的数的数量就是 $sum_{lim_u}$。

考虑对于新树求出 dfn 序，则 $u$ 子树内的点可以算作一段区间 $[L,R]$，然后建出前缀主席树即可快速求 $lim_u$ 被区间包含的个数（因为要区间加，可以直接标记永久化）。

也可以使用 dsu on tree 做，但是本人**太菜**不会。

总时间复杂度为 $O(N \log^2 N)$。

**注意主席树的空间要开 $50$ 倍。**

### 完整代码；

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const ll N=1e5+10,M=20,mod=998244353,INF=1e9;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int T,n;
int root[N],fa[N],l[N],r[N],h[N],id[N],_id[N],dfn[N];
vector<int> E[N],G[N];
inline void add(int u,int v){
    E[u].push_back(v);
    E[v].push_back(u);
}
inline void ADD(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
inline void Read(){
    n=read();
    For(i,1,n){
    	E[i].clear();
    	G[i].clear();
	}
    For(i,2,n){
        fa[i]=read(),l[i]=read(),r[i]=read(),h[i]=read();
        add(fa[i],i);
    }
}
class Tree{
public:
    int cnt=0;
    int p[N],t[N],z[N],d[N],fa[N];
    struct Node{
        int l,r,len;
        ll data;
        ll tag;
    }X[N<<2];
	inline void dfs1(int u,int f){
		p[u]=1;
		for(auto v:E[u]){
			if(v==f)
			  continue;
			d[v]=d[u]+1;
			fa[v]=u;
			dfs1(v,u);
			p[u]+=p[v];
			if(p[v]>p[z[u]])
			  z[u]=v;
		}
	}
	inline void dfs2(int u,int k){
        dfn[u]=++cnt;
		t[u]=k;
		if(!z[u])
		  return ;
		dfs2(z[u],k);
		for(auto v:E[u]){
			if(v==fa[u]||v==z[u])
			  continue;
			dfs2(v,v);
		}
	}
    inline void build(int k,int l,int r){
        X[k].len=r-l+1;
		X[k].l=l,X[k].r=r;
        X[k].data=X[k].tag=0;
        if(l==r)
          return ;
        int mid=(l+r)>>1;
        build(k<<1,l,mid);
        build(k<<1|1,mid+1,r);
    }
    inline void pushup(int k){
    	X[k].data=Add(X[k<<1].data,X[k<<1|1].data);
	}
    inline void add(int k,int v){
        X[k].data=(X[k].data+1ll*X[k].len*v%mod)%mod;
        X[k].tag=Add(X[k].tag,v);
    }
    inline void push_down(int k){
        if(X[k].tag){
            add(k<<1,X[k].tag);
            add(k<<1|1,X[k].tag);
            X[k].tag=0;
        }
    }
    inline void update(int k,int l,int r,int v){
        if(X[k].l==l&&r==X[k].r){
            add(k,v);
            return ;
        }
        push_down(k);
        int mid=(X[k].l+X[k].r)>>1;
        if(r<=mid)
          update(k<<1,l,r,v);
        else if(l>mid)
          update(k<<1|1,l,r,v);
        else{
            update(k<<1,l,mid,v);
            update(k<<1|1,mid+1,r,v);
        }
        pushup(k);
    }
    inline int query(int k,int l,int r){
    	if(X[k].l==l&&r==X[k].r)
    	  return X[k].data;
    	push_down(k);
    	ll mid=(X[k].l+X[k].r)>>1;
    	if(r<=mid)
    	  return query(k<<1,l,r);
    	else if(l>mid)
    	  return query(k<<1|1,l,r);
    	else
    	  return (query(k<<1,l,mid)+query(k<<1|1,mid+1,r))%mod;
	}
    inline int query(int k,int i){
        if(X[k].l==i&&i==X[k].r)
          return X[k].data;
        push_down(k);
        ll mid=(X[k].l+X[k].r)>>1;
        if(i<=mid)
          return query(k<<1,i);
        else
          return query(k<<1|1,i);
    }
    inline void update(int u,int v,int h){
        while(t[u]!=t[v]){
            if(d[t[u]]<d[t[v]])
              swap(u,v);
            update(1,dfn[t[u]],dfn[u],h);
            u=fa[t[u]];
        }
        if(d[u]>d[v])
          swap(u,v);
        update(1,dfn[u],dfn[v],h);
    }
    inline int ask(int u,int v){
    	int ans=0;
    	while(t[u]!=t[v]){
    		if(d[t[u]]<d[t[v]])
    		  swap(u,v);
    		ans=(ans+query(1,dfn[t[u]],dfn[u]))%mod;
    		u=fa[t[u]];
		}
		if(d[u]>d[v])
		  swap(u,v);
		ans=(ans+query(1,dfn[u],dfn[v]))%mod;
		return ans;
	}
	inline void init(){
        For(i,1,n)
          z[i]=0;
        cnt=0;
		dfs1(1,1);
		dfs2(1,1);
        build(1,1,n);
	}
}Tr;
namespace Seg{
	int siz[N];
	int cnt,s;
	struct Node{
		int L,R;
		int tag;
	}X[N*50];
	inline void dfs(int u,int fa){
		id[u]=++s;
		_id[s]=u;
		siz[u]=1;
		for(auto v:G[u]){
			if(v==fa)
			  continue;
			dfs(v,u);
			siz[u]+=siz[v];
		}
	}
	inline void tidy(){
		For(i,1,cnt)
		  X[i]={0,0,0};
		s=cnt=0;
		dfs(1,1);
	}
	inline void build(int &k,int l,int r){
		if(!k)
		  k=++cnt;
		X[k].tag=0;
		if(l==r)
		  return ;
		int mid=(l+r)>>1;
		build(X[k].L,l,mid);
		build(X[k].R,mid+1,r);
	}
	inline void update(int &k,int l,int r,int L,int R,int v){
		X[++cnt]=X[k];
		k=cnt;
		if(l==L&&r==R){
			X[k].tag=Add(X[k].tag,v);
			return ;
		}
		ll mid=(l+r)>>1;
		if(R<=mid)
		  update(X[k].L,l,mid,L,R,v);
		else if(L>mid)
		  update(X[k].R,mid+1,r,L,R,v);
		else{
			update(X[k].L,l,mid,L,mid,v);
			update(X[k].R,mid+1,r,mid+1,R,v);
		}
	}	
	inline void Ask(int k,int l,int r,int i,int &ans){
		ans=Add(ans,X[k].tag);
		if(l==i&&i==r)
		  return ;
		int mid=(l+r)>>1;
		if(i<=mid)
		  Ask(X[k].L,l,mid,i,ans);
		else
		  Ask(X[k].R,mid+1,r,i,ans);
	}
	inline int Ask(int u){
		int X=0,Y=0;
		Ask(root[id[u]+siz[u]-1],0,n,h[u],X);
		Ask(root[id[u]-1],0,n,h[u],Y);
		return (X-Y+mod)%mod;
	}
};
namespace Std{
	int Min,sum,x,a,b,c,t;
	int dep[N],g1[N],g2[N],g3[N];
	int Fa[N][M],F[N][M];
	vector<pi> E1[N],E2[N],E3[N];
    inline void dfs(int u){
        For(j,1,M-1)
          Fa[u][j]=Fa[Fa[u][j-1]][j-1];
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            Fa[v][0]=u;
            dep[v]=dep[u]+1;
            dfs(v);
        }
    }
    inline int get_fa(int u,int k){
        if(!k)
          return u;
        _For(j,0,M-1){
            if(k>=(1ll<<j)){
                k-=(1ll<<j);
                u=Fa[u][j];
            }
        }
        return u;
    }
	inline void dfs1(int u){
		For(i,1,M-1)
		  F[u][i]=min(F[u][i-1],F[Fa[u][i-1]][i-1]);
		for(auto v:E[u]){
			if(v==fa[u])
			  continue;
			F[v][0]=h[v];
			dfs1(v);
		}
	}
	inline void solve(){
		Read();
        For(j,0,M-1)
          Fa[1][j]=1;
		dfs(1);
		For(i,1,n)
		  root[i]=0;
		For(i,0,n-1){
			E1[i].clear();
			E2[i].clear();
			E3[i].clear();
		}
        For(i,2,n){
        	a=get_fa(i,r[i]),b=get_fa(i,l[i]),c=get_fa(i,h[i]+1);
			h[i]=dep[i]-h[i]-1;
            l[i]=dep[a],r[i]=dep[b];
            if(l[i])
              E1[l[i]-1].push_back({i,fa[a]});
            E2[r[i]].push_back({i,b});
            E3[h[i]].push_back({i,c});
        }
        For(j,0,M-1)
          F[1][j]=INF;
        dfs1(1);
        For(i,2,n){
        	if(l[i]){
        		x=i;
        		_For(j,0,M-1)
        		  if(F[x][j]>=l[i])
        			x=Fa[x][j];
        		if(x==i)
        		  g1[i]=-1;
        		else
        		  g1[i]=get_fa(i,dep[i]-dep[x]-1);    		
			}
			else
			  g1[i]=-1;
			x=i;
			_For(j,0,M-1)
			  if(F[x][j]>r[i])
			    x=Fa[x][j];
			if(x==i)
			  g2[i]=-1;
			else
			  g2[i]=get_fa(i,dep[i]-dep[x]-1);
			Min=INF,x=i;
			_For(j,0,M-1)
			  if(F[x][j]>=h[i])
				x=Fa[x][j];
			ADD(i,x);
			if(x==i)
			  g3[i]=-1;
			else
			  g3[i]=get_fa(i,dep[i]-dep[x]-1); 
		}
		Tr.init();
		Tr.update(1,1,1);
		Seg::tidy();
		Seg::build(root[1],0,n);
		For(i,2,n){
			root[i]=root[i-1];
			Seg::update(root[i],0,n,l[_id[i]],r[_id[i]],1);
			a=0;
			Seg::Ask(root[i],0,n,0,a);
		}
		For(i,0,n-1){
			for(auto t:E1[i]){
				x=t.fi,b=g1[x];
				if(b==-1)
				  continue;
				a=Tr.ask(1,t.se);
				Tr.update(x,b,mod-a);
			}
			for(auto t:E2[i]){
				x=t.fi,b=g2[x];
				if(b==-1)
				  continue;
				a=Tr.ask(1,t.se);
				Tr.update(x,b,a);
			}
			for(auto t:E3[i]){
				x=t.fi,b=g3[x];
				if(b==-1)
				  continue;
				a=Tr.ask(1,t.se);
				sum=Seg::Ask(x);
				Tr.update(x,b,1ll*sum*a%mod);
			}
		}
		For(i,2,n){
			write(Tr.query(1,dfn[i]));
			putchar(' ');
		}
		putchar('\n');
	}
	inline void work(){
		while(T--)
		  solve();
	}
};
int main(){
	//open("A.in","A.out");
    read(),T=read();
    Std::work();
    return 0;
}
```

---

## 作者：IdnadRev (赞：5)

考场做法。

容易发现 $h_i$ 的条件只需限制相邻两次冲刺，我们尝试得到一个 $O(n^2)$ 的 dp：从上到下考虑每一层 $i$，并实时维护每个点下一次冲刺到达的层小于等于 $i$ 的登山方案数，可以通过扫一遍，再在树上做子树和来转移（这里需要忽略掉所有 $d_j-h_j<i$ 的位置）。

从 $h_i=0$ 的部分分入手，可以发现一个点被忽略掉的时候已经不会对我们仍需求出的 dp 值产生任何影响，因此我们子树和可以看作无限制。那么一轮转移形如：枚举每个深度为 $i$ 的点 $j$，将 $j$ 的子树内每个点加上“该点子树内有多少个可以一步跳到 $j$”倍的 $f_j$。

限制下一步能跳到深度为 $i$ 的点可以通过扫描线处理，枚举深度的同时在 $d_j-r_j$ 处加入 $j$，在 $d_j-l_j+1$ 处删除 $j$，那么 $f_j$ 乘上的系数就是子树内被加入的点数，容易通过树链剖分+线段树来维护每个点的 dp 值（我们只需维护区间系数更新与区间带系数的加法）。

对于一般的情况，每个点会在 $d_j-h_j+1$ 处被禁止通行，假设其在树上的父边断去，树上每个节点会形成若干互不影响的连通块，上面所说的系数只能在连通块中造成贡献。考察删去一条边 $(p_j,j)$ 的影响，事实上是将 $p_j$ 到对应根结点链上每个点的系数减去“断去这条边后，$j$ 所在连通块有贡献的点数”。计算点数可以倒序并查集合并直接计算，而其造成的影响也无非是一个链的系数加。

于是我们用树剖与并查集解决了本题，复杂度 $O(n\log^2 n)$，瓶颈在于树剖。

---

## 作者：_ANIG_ (赞：3)

[传送门](https://www.luogu.com.cn/problem/P10789)

首先状态是简单的：$f_x$ 表示从 $x$ 出发到达山顶的方案数。

在题目的限制下显然是无后效性的。

做一个树上前缀和，设 $y$ 到 $x$ 路径上 $d-h$ 的最小值为 $k$，则贡献是形如 $g_{\min\{r_y,k\}}-g_{l_y}$ 的式子。

可以发现，从下往上做是相对容易的。

考虑从下往上做，再从上往下撤销。

当前 dfs 到一个位置，用并查集维护其子树内的点到这个点路径上 $d-h$ 的最值。

具体地，$y$ 到当前根的最值在 $y$ 所在的集合的代表元处取到。

倍增预处理一个点上面第一个 $d-h$ 小于这个点的位置，直接合并即可。

可以给每个点开个 vector，存储的信息形如 $l_i,r_i,k_i$，表示这个点的 dp 值等于 $\sum k_i(g_{r_i}-g_{l_i-1})$，这样方便直接撤销。

启发式合并即可做到 $O(n\log n)$。

还要特殊处理 $l>r$ 的情况，对每个点倍增找到贡献为 $0$ 的位置，直接打个 tag 即可。

总复杂度 $O(n\log n)$，数据结构仅需要用到并查集。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5,mods=998244353;
int op,t,n,nw,fa[N],l[N],dy[N],r[N],mk[N],sm[N],sz[N],h[N],ff[N],d[N],f[N],dp[N],f1[N][20],f2[N][20];
vector<int>p[N],g[N],q[N],jl[N];
struct node{
	int l,r,op;
};
vector<node>fs[N];
int fd(int x){
	if(x==ff[x])return x;
	return ff[x]=fd(ff[x]);
}
void dfs(int x){
	for(int i=1;i<=18;i++){
		f1[x][i]=f1[f1[x][i-1]][i-1];
		f2[x][i]=min(f2[x][i-1],f2[f1[x][i-1]][i-1]);
	}
	h[x]=d[x]-h[x]-1;
	l[x]=d[x]-l[x];
	r[x]=d[x]-r[x];
	swap(l[x],r[x]);
	int y=x;
	for(int i=18;i>=0;i--)if(f2[y][i]>=h[x])y=f1[y][i];
	g[fa[y]].push_back(x);
	y=x;
	for(int i=18;i>=0;i--)if(f2[y][i]>=l[x])y=f1[y][i];
	if(h[x]>=l[x])jl[fa[y]].push_back(x);
	else jl[x].push_back(x);
	y=x;
	for(int i=18;i>=0;i--)if(f2[y][i]>=r[x])y=f1[y][i];
	if(h[x]>=r[x])q[fa[y]].push_back(x);
	else q[x].push_back(x);
	for(auto c:p[x]){
		d[c]=d[x]+1;
		f1[c][0]=x;
		f2[c][0]=h[x];
		dfs(c);
	}
}
void init(int x){
	for(auto c:p[x])init(c);
	sort(p[x].begin(),p[x].end(),[&](int a,int b){
	    return fs[a].size()>fs[b].size();
	});
	if(p[x].size())swap(fs[x],fs[p[x][0]]);
	for(int i=1;i<p[x].size();i++){
		int c=p[x][i];
		for(auto d:fs[c])fs[x].push_back(d),sm[x]++;
	}
	fs[x].push_back({l[x],r[x],1});
	sm[x]++;
	for(auto c:q[x]){
		fs[x].push_back({l[c],r[c],-1});
		fs[x].push_back({l[c],h[x],1});
		dy[c]=x;
		sz[x]++;
		sm[x]+=2;
	}
	for(auto c:jl[x]){
		fs[x].push_back({l[c],h[fd(dy[c])],-1});
		sz[fd(dy[c])]--;
		sm[x]++;
	}
	for(auto c:g[x]){
		fs[x].push_back({h[x]+1,h[c],-sz[c]});
		sz[x]+=sz[c];
		ff[c]=x;
		sm[x]++;
	}
}
int gets(int l,int r){
	if(l>nw)return 0;
	if(l>r)return 0;
	return dp[min(r,nw)]-dp[l-1];
}
void solve(int x,int res){
	if(mk[x])for(auto c:fs[x])res+=gets(c.l,c.r)*c.op,res%=mods;
	if(x!=1)f[x]=res;
	dp[d[x]]=(dp[d[x]-1]+f[x])%mods;
	nw=d[x];
	while(sm[x]--){
		auto c=fs[x].back();
		fs[x].pop_back();
		res-=gets(c.l,c.r)*c.op;
		res%=mods;
	}
    if(p[x].size()){
    	swap(fs[x],fs[p[x][0]]);
    	solve(p[x][0],res);
    	for(int i=1;i<p[x].size();i++){
    		int c=p[x][i];
    		mk[c]=1;
    		nw=d[x];
    		solve(c,0);
    	}
    }
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>op>>t;
	while(t--){
		memset(f,0,sizeof(f));
		memset(f1,0,sizeof(f1));
		memset(f2,0x3f,sizeof(f2));
		cin>>n;	
		for(int i=1;i<=n;i++)ff[i]=i,mk[i]=0,sm[i]=0,sz[i]=0,p[i].clear(),g[i].clear(),fs[i].clear(),q[i].clear(),jl[i].clear();
		for(int i=2;i<=n;i++){
			cin>>fa[i]>>l[i]>>r[i]>>h[i];
			p[fa[i]].push_back(i);
		}
		d[1]=1;
		dfs(1);
		init(1);
		f[1]=1;
		solve(1,0);
		for(int i=2;i<=n;i++)cout<<(f[i]%mods+mods)%mods<<" ";
		cout<<"\n";
	}
}
```

---

## 作者：_Ch1F4N_ (赞：2)

首先刻画一下冲刺过程。

不难发现可以划分为若干段的冲刺——掉落——冲刺。

不妨每一段用一个三元组 $(v,u,w)$ 表示，也就是描述的是从 $v$ 滑落到 $u$ 再冲刺到 $w$ 的过程。由于 $w$ 肯定比 $v$ 要高，所以这个转移是没有环的。

于是考虑设计状态 $dp_u$ 表示 $u$ 冲刺到 $1$ 的方案数，我们考虑去刷表，也就是考虑 $dp_u$ 贡献到 $u$ 子树内状态的过程。

首先约定一些记号：点 $u$ 可以冲刺到的点的深度区间是 $[l_u,r_u]$，经过一个点后再冲刺的深度限制是 $[1,lim_u]$，$to_u(k)$ 表示 $u$ 深度为 $k$ 的祖先，$val(u,v) = \min_{l \in path(u,v)} lim_l$,$pre_u = \sum_{l \in path(1,u)} dp_l$。

考虑枚举三元组中的 $u$。假若可以进行 $dp_v \gets dp_v + dp_w$ 的贡献，那么 $dep_w \in [l_u,min(r_u,val(u,v))]$，当然这里 $val(u,v) \geq l_u$ 才可以贡献，考虑讨论 $r_u$ 与 $val(u,v)$ 的大小关系。

# $r_u < val(u,v)$

建立出根到 $u$ 路径上所有点以 $lim$ 为权值构成的单调栈，则可以二分确定出满足 $r_u < val(u,v)$ 的 $v$ 构成了一条链，这些 $v$ 的贡献条件是 $dep_w \in [l_u,r_u]$，也就是对于这些 $v$ 要进行 $dp_v \gets dp_v + \sum_{dep_w \in [l_u,r_u]} dp_w$，前缀和后变为 $dp_v \gets dp_v + pre_{to_u(r_u)} - pre_{to_u(l_u-1)}$，由于 $lim_v \geq val(u,v) >  r_u$，所以处理 $v$ 时 $to_u(r_u),to_v(l_u-1)$ 一定已经处理好，故将链加挂在其上即可。

# $r_u \geq val(u,v)$

依然可以二分确定出满足 $r_u \geq val(u,v)$ 且 $l_u \leq val(u,v)$ 的 $v$ 构成一条链，对于这些 $v$ 的贡献条件是 $dep_w \in [l_u,val(u,v)]$，也就是要进行 $dp_v \gets dp_v + pre_{to_u(val(u,v))} - pre_{to_u(l_u-1)}$，对于 $- pre_{to_u(l_u-1)}$ 的部分，由于 $lim_v \geq val(u,v) \geq l_u$，依然可以挂在 $to_u(l_u-1)$ 上处理，现在我们只考虑 $dp_v \gets dp_v + pre_{to_u(val(u,v))}$ 怎么做。

你发现，对于单调栈上两个相邻的节点之间的链，他们的 $val(u,v)$ 是相同的，因此他们的 $dp$ 增量相同，于是你考虑对于这样的每一段维护被执行了多少次 $dp_v \gets dp_v + pre_{to_u(val(u,v))}$ 的操作，并在这个段被弹出时转变为挂到 $to_u(val(u,v))$ 上的链加（对于单调栈上的一段，只要其存在，那么 $val(u,v)$ 就实际上与 $u$ 没关系，或者说，假若其的值为 $k$，那么这一段只在 $val(u,v) = k$ 的 $u$ 处才存在），每次被加的段是栈中一个段区间，因此是好维护的。

但是树上对到根的链做单调栈是 $O(n^2)$ 的，但是我们可以用一个平衡树来快速维护弹栈加栈甚至是栈上区间加的过程，前面的链加差分后用树状数组维护即可，因此总的时间复杂度是 $O(n \log n)$ 的，空间 $O(n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int maxn = 1e5+114;
int fa[maxn],l[maxn],r[maxn],h[maxn];
int dep[maxn];
int dp[maxn],pre[maxn];
int lim[maxn],n;
vector<int> kfa;
int to(int k){
    return kfa[k];
}
vector<int> E[maxn];
vector< pair<int,pair<int,int> > > add[maxn];
int tr[maxn];
int L[maxn],R[maxn],dfncnt;
int g[maxn];
void listadd(int u,int v,int c){
    int x=L[v];
    while(x<=n) tr[x]=(tr[x]+c)%mod,x+=x&(-x);
    u=fa[u];
    if(u==0) return ;
    x=L[u];
    while(x<=n) tr[x]=(tr[x]+mod-c)%mod,x+=x&(-x);
    return ;
}
int listask(int u){
    int res=0;
    int x=R[u];
    while(x>0) res=(res+tr[x])%mod,x-=x&(-x);
    x=L[u]-1;
    while(x>0) res=(res+mod-tr[x])%mod,x-=x&(-x);
    return res;
}
mt19937 rd(time(0));
struct node{
	int val;
	int tag;
	int sum;
	int sz;
	int ls,rs;
	int rk;
	node(){
		sum=val=tag=ls=rs=0;
		rk=rd();
		sz=1;
	} 
}trp[maxn];
void pushup(int cur){
	if(cur==0) return ;
	trp[cur].sum=(1ll*trp[trp[cur].ls].sum+trp[trp[cur].rs].sum+trp[cur].val)%mod;
	trp[cur].sz=trp[trp[cur].ls].sz+trp[trp[cur].rs].sz+1;
}
void pushdown(int cur){
	if(trp[cur].tag==0) return ;
	if(trp[cur].ls!=0) trp[trp[cur].ls].tag=(trp[trp[cur].ls].tag+trp[cur].tag)%mod,trp[trp[cur].ls].sum=(trp[trp[cur].ls].sum+1ll*trp[cur].tag*trp[trp[cur].ls].sz%mod)%mod,trp[trp[cur].ls].val=(trp[trp[cur].ls].val+trp[cur].tag)%mod;
	if(trp[cur].rs!=0) trp[trp[cur].rs].tag=(trp[trp[cur].rs].tag+trp[cur].tag)%mod,trp[trp[cur].rs].sum=(trp[trp[cur].rs].sum+1ll*trp[cur].tag*trp[trp[cur].rs].sz%mod)%mod,trp[trp[cur].rs].val=(trp[trp[cur].rs].val+trp[cur].tag)%mod;
	trp[cur].tag=0;
	return ;
}
int merge(int u,int v){
	if(u==0||v==0) return u+v;
	pushdown(u),pushdown(v);
	if(trp[u].rk>trp[v].rk){
		trp[u].rs=merge(trp[u].rs,v);
		pushup(u);
		return u;
	}else{
		trp[v].ls=merge(u,trp[v].ls);
		pushup(v);
		return v;
	}
	return 0;
}
void split(int cur,int &l,int &r,int x){
	if(cur==0){
		l=r=0;
		return ;
	}
	pushdown(cur);
	if(lim[cur]<=x){
		l=cur;
		split(trp[l].rs,trp[l].rs,r,x);
		pushup(l);
	}else{
		r=cur;
		split(trp[r].ls,l,trp[r].ls,x);
		pushup(r);
	}
	return ;
}
void spldep(int cur,int &l,int &r,int x){
	if(cur==0){
		l=r=0;
		return ;
	}
	pushdown(cur);
	if(dep[cur]<=x){
		l=cur;
		spldep(trp[l].rs,trp[l].rs,r,x);
		pushup(l);
	}else{
		r=cur;
		spldep(trp[r].ls,l,trp[r].ls,x);
		pushup(r);
	}
	return ;
}
int submax(int cur){
	while(trp[cur].rs!=0){
		pushdown(cur);
		cur=trp[cur].rs;
	}
	return cur;
}
int submin(int cur){
	while(trp[cur].ls!=0){
		pushdown(cur);
		cur=trp[cur].ls;
	}
	return cur;
}
void delmax(int &cur){
	pushdown(cur);
	if(trp[cur].rs==0){
		cur=trp[cur].ls;
		return ;
	}
	delmax(trp[cur].rs);
	pushup(cur);
	return ;
}
int root;
void dfs(int u){
    L[u]=++dfncnt;
    kfa.push_back(u);
    int x=0,y=0,del=0;
    split(root,x,y,lim[u]);
    root=x;
    del=y;
    trp[u]=node();
    root=merge(root,u);
    if(u!=1){
        if(lim[submax(root)]>r[u]){
            int lt=0,rt=0;
            split(root,lt,rt,r[u]);
            int tp=to(dep[submax(lt)]+1);
            root=merge(lt,rt);
            add[to(l[u]-1)].push_back(make_pair(mod-1,make_pair(tp,u)));
            add[to(r[u])].push_back(make_pair(1,make_pair(tp,u)));
        }
        if(lim[submax(root)]>=l[u]){
            int lt=0,rt=0;
            split(root,lt,rt,l[u]-1);
            int Lt=submin(rt);
            int tp=to(dep[submax(lt)]+1);
            root=merge(lt,rt);
            lt=0,rt=0;
            split(root,lt,rt,r[u]);
            int bk=submax(lt);
            int Rt=bk;
            root=merge(lt,rt);
            if(dep[bk]>=dep[tp]){
                add[to(l[u]-1)].push_back(make_pair(mod-1,make_pair(tp,bk)));
                int x=0,y=0,z=0;
                spldep(root,x,y,dep[Lt]-1);
                spldep(y,y,z,dep[Rt]);
                trp[y].tag=(trp[y].tag+1)%mod;
                trp[y].val=(trp[y].val+1)%mod;
                trp[y].sum=(trp[y].sum+trp[y].sz)%mod;
                root=merge(x,merge(y,z));
            }
        }
    }
    for(int v:E[u]) dfs(v);
    if(u!=1){
        int x=0,y=0;
        spldep(root,x,y,dep[u]-1);
        int k=trp[y].sum;
        root=x;
        int tp=to(dep[submax(root)]+1);
        add[to(lim[u])].push_back(make_pair(k,make_pair(tp,u)));
    }else delmax(root);
    root=merge(root,del);
    kfa.pop_back();
    R[u]=dfncnt;
}
void DP(int u){
    dp[u]=(dp[u]+listask(u))%mod;
    pre[u]=(pre[fa[u]]+dp[u])%mod;
    for(pair<int,pair<int,int> > now:add[u]){
        listadd(now.second.first,now.second.second,1ll*now.first*pre[u]%mod);
    }
    for(int v:E[u]) DP(v);
}
void work(){
    cin>>n;
    kfa.clear();
    dfncnt=0;
    for(int i=0;i<=n;i++) add[i].clear(),E[i].clear(),g[i]=dp[i]=pre[i]=tr[i]=0,trp[i]=node();
    root=0;
    dep[1]=1;
    dp[1]=1;
    for(int i=2;i<=n;i++){
        cin>>fa[i]>>r[i]>>l[i]>>h[i];
        dep[i]=dep[fa[i]]+1;
        l[i]=dep[i]-l[i];
        r[i]=dep[i]-r[i];
        lim[i]=dep[i]-h[i]-1;
        E[fa[i]].push_back(i);
    }
    kfa.push_back(0);
    dfs(1);
    DP(1);
    kfa.clear();
    for(int i=2;i<=n;i++) cout<<dp[i]<<' ';
    cout<<'\n';
    return ;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int c,t;
    cin>>c>>t;
    while(t--) work();
    return 0;
}
```

---

## 作者：nullqtr_pwp (赞：2)

显然要考虑 dp，最终需要求出的是 $f_i$ 表示 $i\to 1$ 的方案数，初始有 $f_1=1$。方便起见，令 $h_u$ 的值表示 $d_u-h'_u-1$，$h'$ 是题面中读入的原始值。转移只需要考虑对第一次向上冲刺的位置进行转移，枚举 $u$ 子树中的点 $v$ 表示向下 $u$ 休息到了 $v$，枚举 $u$ 的祖先之一 $i$，如果满足 $d_v-d_i\in[l_v,r_v]$ 且 $d_i\leq \min_{j\in\text{path}(u,v)}h_j$ 就需要有 $f_i$ 转移到 $f_u$，不难通过枚举 $v$ 并处理前缀和做到 $\mathcal O(n^2)$。

可以感受到，正解是几乎在线的数据结构优化问题，问题在于维护出所有 $f_i$ 的系数 $coef_i$ 使得 $f_u=\sum coef_if_i$。其中 $coef_i$ 的意义就表示 $u$ 子树有多少个 $v$ 使得 $f_i\to f_u$ 的转移是合法的。那么子树中 $l_v,r_v$ 就相当于链 $+1$，但是 $h$ 让问题复杂了起来。为了去掉与区间 $[l,r]$ 的交集，我们尝试将更新改为对于 $r_v+1$ 以上的 $coef$ 进行 $-1$，对于 $l_v$ 以上的进行 $+1$；$h$ 的限制对两个操作独立，分别是 $+1$ 和 $-1$。具体的，我们考虑 $u\to1$ 的链，从前往后是深度为 $0,1,\cdots,d_u$ 的点，构成一个长度为 $d_u+1$ 的序列 $s$，$s$ 序列的每个元素是 $h_i$，由不同的 $R\in\text{anc}(u)$ 表示当前考虑到 $f_R$，就会有不同的区间的 $coef$ 被重置为 $0$。先考虑这个序列 $s$，一个结论是我们只会关心所有的后缀最小值位置集合 $P$，当找到 $R$ 时，我们只关心 $R$ 在这个序列中向后大于等于它的首个 $P$ 中的元素，因此我们可以构造一个重构树，$u$ 的父亲 $up_u$ 表示 $u$ 的祖先中最深的 $v$ 使得 $h_v<h_u$，显然这相当于跳了若干级祖先，重构树上的边代表着原树的一条直链，更新理应是链加。对于这两个限制可以分开考虑，不妨看到 $[0,p]$ 的操作 $+1$，那么对于某个 $u$ 其造成的就是 $[h_{\text{next}_u}+1,p]$。所以我们可以找到 $P$ 中首个 $h<p$ 的位置打上 $[h+1,p]$ 的标记，后续的 $\min$ 更新操作就与 $p$ 无关了，给 $h$ 打一个 tag 然后在重构树 dfs 时累加一下这个标记即可。后续的颜色视为 $P$ 上那个点的即可。

现在的操作 $(x,y,w)$ 就是形如维护祖先序列中的 $w\sum_{x\leq i\leq y}f_i$，可以使用差分的思想，差分成 $x-1$ 处以及 $y$ 处对于树上前缀和的修改，系数分别为 $-w,w$。这个操作赋上颜色 $u$ 表示这是休息点为 $u$ 的贡献，每次 $f$ 只需要询问所有子树中颜色的 $f$ 之和。树状数组维护，时间复杂度 $\mathcal O(n\log n)$。

[自认为实现较为优美的代码](https://loj.ac/s/2203509)。

---


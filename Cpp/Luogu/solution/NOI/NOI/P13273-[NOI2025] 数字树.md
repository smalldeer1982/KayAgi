# [NOI2025] 数字树

## 题目描述

给定一棵 $4n - 1$ 个结点的二叉树，其中每个非叶结点都有 **恰好** 两个子结点。非叶结点编号为 $1$ 到 $2n - 1$，叶子结点编号为 $2n$ 到 $4n - 1$。初始时，每个叶子结点上都没有数字。

定义一个 DFS 序是 **优美的**，当且仅当按该 DFS 序将 **所有标有数字的叶子结点** 上的数字拼成一个序列时，该序列可以通过若干次 **消除相邻相同数字** 的方式得到空序列。例如，在下图中，若叶子结点 $4, 6$ 上标有数字 $1$，叶子结点 $5, 7$ 上标有数字 $2$，则按 DFS 序 $[1, 4, 2, 7, 3, 5, 6]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 2, 1]$，可以通过消除相邻的 $2$ 的方式得到 $[1, 1]$，再通过消除相邻的 $1$ 的方式得到空序列，因此该 DFS 序是优美的；而按 DFS 序 $[1, 4, 2, 3, 5, 6, 7]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 1, 2]$，无法通过若干次消除相邻相同数字的方式得到空序列，因此该 DFS 序不是优美的。

![](https://cdn.luogu.com.cn/upload/image_hosting/p4thcg8c.png)

给定 $n$ 次操作，第 $i$ ($1 \leq i \leq n$) 次操作会选择两个 **没有数字** 的叶子结点，然后将这两个结点标上数字 $i$。**保证在每次操作后，存在至少一个优美的 DFS 序**。你需要求出每次操作后的优美的 DFS 序的数量。由于答案可能较大，你只需要求出答案对 $1,000,000,007$ 取模后的结果。

## 说明/提示

### 样例 1 解释

该样例即【题目描述】中所示的例子。
- 第一次操作后，叶子结点 $4$ 和 $6$ 上标有数字 $1$，叶子结点 $5$ 和 $7$ 上没有数字，因此按任意 DFS 序拼成的序列均为 $[1, 1]$，即所有的 $2^3 = 8$ 个 DFS 序都是优美的。
- 第二次操作后，叶子结点 $4 \sim 7$ 上分别标有数字 $1, 2, 1, 2$，因此共有 $4$ 个优美的 DFS 序，分别为 $[1, 4, 2, 3, 6, 5, 7], [1, 4, 2, 7, 3, 5, 6], [1, 2, 3, 6, 5, 7, 4], [1, 2, 7, 3, 5, 6, 4]$。

### 样例 3

见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。

该样例满足测试点 $6 \sim 10$ 的约束条件。

### 样例 4

见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。

该样例满足测试点 $11, 12$ 的约束条件。

### 样例 5

见选手目录下的 `tree/tree5.in` 与 `tree/tree5.ans`。

该样例满足测试点 $17 \sim 20$ 的约束条件。

### 样例 6

见选手目录下的 `tree/tree6.in` 与 `tree/tree6.ans`。

该样例满足测试点 $24, 25$ 的约束条件。

### 数据范围

对于所有测试数据，保证：
- $1 \leq n \leq 2 \times 10^5$；
- 对于所有 $1 \leq i \leq 2n - 1$，均有 $i < l_i, r_i \leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同；
- 对于所有 $1 \leq i \leq n$，均有 $2n \leq a_i, b_i \leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同；
- 在每次操作后，存在至少一个优美的 DFS 序。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:----------:|:--------:|:--------:|
| $1, 2$       | $10$       | 无       |
| $3 \sim 5$      | $10^2$   | A        |
| $6 \sim 10$     | ^   | 无       |
| $11, 12$     | $10^3$   | A        |
| $13, 14$     | ^   | 无       |
| $15, 16$     | $5 \times 10^4$ | AB      |
| $17 \sim 20$    | ^ | B       |
| $21, 22$     | ^ | 无       |
| $23$         | $2 \times 10^5$ | A       |
| $24, 25$     | ^ | 无       |

特殊性质 A：保证每次操作选择的两个叶子结点位于结点 1 的不同子树内。

特殊性质 B：保证存在非负整数 $m$ 满足 $n = 2^m$，且对于所有 $1 \leq i \leq 2n - 1$，均有 $l_i = 2i, r_i = 2i + 1$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13081)。

## 样例 #1

### 输入

```
0
2
4 2
3 7
5 6
4 6
5 7```

### 输出

```
8
4

```

## 样例 #2

### 输入

```
0
6
2 3
4 21
22 23
5 11
6 8
7 9
12 13
10 18
14 15
16 17
19 20
12 13
14 15
16 19
17 18
20 21
22 23```

### 输出

```
2048
2048
2048
1024
512
512```

# 题解

## 作者：IvanZhang2009 (赞：13)

神题。

先给出一个**正解无关**的平方暴力。

考虑如何刻画一个 dfs 序。实际上就是每个非叶子节点选一下先走左边还是右边。所以说总共的 dfs 序个数是 $2^{2n-1}$。

考虑一个得到序列是可消除的的充要条件：对于任意两种颜色 $a$ 和 $b$，它们的出现都不是 $a,b,a,b$ 这样交错的。我们可以直接枚举两种颜色，然后讨论一下它们的位置关系。

这里从合并的角度理解。由于给定了四个叶子节点，相当于每次选两个合并成一个。如果两个同色的先合起来了，那就没啥意义，一定合法。所以考虑第一步是把一对 $a,b$ 合起来了。有以下两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/j8scbcvr.png)

（图糙勿喷）。

第一种相当于 A 性质。可以发现考虑两个偏下的 lca，如果第一个先往左，则第二个必须先往右；第一个先往右，则第二个必须先往左。反之亦然。可以理解为这两个 lca 的往下遍历的顺序是“绑定”的。

第二种也可以考虑两个偏下的 lca。下面的 $b$ 一定不能插在两个 $a$ 中间，所以两个偏下的 lca 中“偏上的那个先往右”和“偏下的那个先往左”是充要的。也就是说这两个 lca 的往下遍历顺序也是“绑定”的。

于是可以想到把两种情况中两个绑定的节点连一条边。由于保证了有解，我们可以在任意一种合法的条件下调整：两个有边相连的点的往下遍历顺序必须同时翻转。这相当于每个连通块可以选择是否翻转。维护一下连通块个数即可，使用并查集。每次询问的时候枚举新颜色和一个老颜色之间的限制即可。时间复杂度 $O(n^2)$。

由于这个有影响的点对都是新加入的一对点的祖先，所以对于 B 性质我们直接枚举这两个祖先检查即可，使用哈希表，时间复杂度 $O(n\log^2n)$，可能需要一定卡常。

可以**在完全没有正解观察的情况下**获得 $80$ 分。

正解需要观察到性质：记一个子树的权值为**子树内恰出现一次的颜色的集合**。记 $c$ 为本质不同的大小至少是 $2$ 的这种集合的个数，则答案为 $2^{2n-1-c}$。

具体地，仍然考虑在合法解上调整。称两个子树在同一个等价类当且仅当两个子树的权值相同。即 $c$ 为等价类个数。对于每个出现了两种只有一次出现的颜色的等价类，我们声称**每个等价类必须有偶数个被翻转方向**。首先所有同等价类的子树的根必须在同一条路径上，而且集合内的颜色都是跨过这些根的。翻转一个这样的点就会导致至少两个点顺序反过来。那么翻转奇数个点一定会让某一侧反过来，另一侧不变，就出现矛盾。具体地，可以画一些 A 性质的图理解一下。而注意到 $\sum_{i=0}^n[2\mid i]\binom ni=2^{n-1}(n\ge 1)$，也就是说每个等价类会把总方案数除以 $2$。所以你把初始的答案除以 $2^c$ 就是答案。

现在问题就是：每次给你两个点，把路径上除了 lca 的点的集合内都加入这种新颜色，然后求每次加入颜色后的足够大的等价类个数。

天才地考虑每个点正解用 01 串来表示这个集合。第 $i$ 次操作即把路径上除了 lca 的点的 01 串的第 $i$ 为改成 $1$。这样前 $i$ 次操作后就相当于每个点的 01 串的长度为 $i$ 的前缀。

这样的去重问题我们考虑按字典序排序。假设我们可以把所有的这样的串按照字典序排序，这样重复的部分就只要考虑相邻两个串的 lcp。具体地，对于第 $j$ 个串，我们只从 $j$ 和 $j-1$ 两个串的 lcp 长度的下一次操作开始考虑。这里顺便也要求一下每个串的第二个 $1$ 的出现位置。

维护 01 串并比较字典序就是经典的线段树合并问题了。考虑线段树维护每个区间的 $1$ 位置的哈希值（直接使用随机赋权 xor hash！！！）以及前两个 $1$ 的位置。然后比较两个串的字典序可以使用线段树二分，比较左子树的哈希值是否相同即可；求 lcp 也可以用同样的方法。这样 `cmp` 的复杂度是 $O(\log n)$，加上排序，时间复杂度 $O(n\log^2n)$，跑得飞快。

可以通过一层一层比较做到 $O(n\log n)$，具体就是把左边哈希值相同的放一起。据说跑的没 $O(n\log^2n)$ 快，所以懒得写了。

```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define int long long
#define REP(i,a,n) for(int i=a;i<(int)(n);++i)
#define pb push_back
#define all(v) v.begin(),v.end()
#define pii pair<int,int>
#define cntbit(x) __builtin_popcount(x)
using namespace std;
int qpow(int x,int y){
	int res=1;
	while(y)res=y&1? res*x%MOD:res,x=x*x%MOD,y>>=1;
	return res;
}
int ID;
int n;
int L[400005],R[400005];
int ls[32000005],rs[32000005];
int fa[800005];
int dep[800005];
int cnt[800005];
int dfn[800005],dtot;
int st[20][800005];
void dfs(int x){
	st[0][dfn[x]=dtot++]=fa[x];
	if(x<2*n-1)dfs(L[x]),dfs(R[x]);
}
int getmax(int x,int y){return dep[x]<dep[y]? x:y;}
int getlca(int x,int y){
	if(x==y)return x;
	if((x=dfn[x])>(y=dfn[y]))swap(x,y);
	int s=__lg(y-(++x)+1);
	return getmax(st[s][x],st[s][y-(1<<s)+1]);
}
vector<int>add[800005],del[800005];
int colval[800005];
mt19937 sd(random_device{}());
uniform_int_distribution<int>rd(64,(1ull<<63)-1);
struct node{
	int h;//哈希值
	int p1,p2;
	node operator +(node a){
		if(p1==n){
			a.h^=h;
			return a;
		}else if(p2!=n)return {h^a.h,p1,p2};
		else return {h^a.h,p1,a.p1};
	}
}seg[32000005];
int tot;
int merge(int l,int r,int p1,int p2){
	if(!p2)swap(p1,p2);
	if(!p1)return p2;
	int p=tot++;
	if(l==r){
		seg[p].h=seg[p1].h^seg[p2].h;
		seg[p].p1=seg[p].p2=n;
		if(seg[p1].p1!=n)seg[p].p1=seg[p1].p1;
		if(seg[p2].p1!=n)seg[p].p1=seg[p2].p1;
		return p;
	}
	int m=(l+r)>>1;
	ls[p]=merge(l,m,ls[p1],ls[p2]);
	rs[p]=merge(m+1,r,rs[p1],rs[p2]);
	seg[p]=seg[ls[p]]+seg[rs[p]];
	return p;
}
int update(int pos,int l,int r,int p1,int op){
	int p=tot++;
	if(l==r){
		if(op==1)seg[p]={colval[l],l,n};
		else seg[p]={0,n,n};
		return p;
	}
	ls[p]=ls[p1];rs[p]=rs[p1];
	int m=(l+r)>>1;
	if(m>=pos)ls[p]=update(pos,l,m,ls[p],op);
	else rs[p]=update(pos,m+1,r,rs[p],op);
	seg[p]=seg[ls[p]]+seg[rs[p]];
	return p;
}
int rt[800005];
void dfs2(int x){
	if(x>=2*n-1)return;
	dfs2(L[x]);dfs2(R[x]);
	rt[x]=merge(0,n-1,rt[L[x]],rt[R[x]]);
	for(auto i:add[x])rt[x]=update(i,0,n-1,rt[x],1);
	for(auto i:del[x])rt[x]=update(i,0,n-1,rt[x],0);
}
bool cmp(int l,int r,int p1,int p2){
	if(!p1)return 1;else if(!p2)return 0;
	if(l==r)return seg[p1].h<seg[p2].h;
	int m=(l+r)>>1;
	if(seg[ls[p1]].h==seg[ls[p2]].h)return cmp(m+1,r,rs[p1],rs[p2]);
	else return cmp(l,m,ls[p1],ls[p2]);
}
bool Cmp(int x,int y){if(seg[rt[x]].h==seg[rt[y]].h)return x<y;else return cmp(0,n-1,rt[x],rt[y]);}
int lcp(int l,int r,int p1,int p2){
	if(!p1&&!p2)return r-l+1;
	else if(!p1)return seg[p2].p1-l;
	else if(!p2)return seg[p1].p1-l;
	else if(seg[p1].h==seg[p2].h)return r-l+1;
	else if(l==r)return 0;
	int m=(l+r)>>1;
	if(seg[ls[p1]].h==seg[ls[p2]].h)return m-l+1+lcp(m+1,r,rs[p1],rs[p2]);
	else return lcp(l,m,ls[p1],ls[p2]);
}
void Main() {
	cin>>ID>>n;
	REP(i,0,2*n-1)cin>>L[i]>>R[i],--L[i],--R[i],fa[L[i]]=fa[R[i]]=i;
	dep[0]=0;
	REP(i,1,n*4-1)dep[i]=dep[fa[i]]+1;
	dfs(0);
	REP(j,0,__lg(4*n-2)){
		REP(i,1,4*n-(1<<(j+1)))st[j+1][i]=getmax(st[j][i],st[j][i+(1<<j)]);
	}
	REP(i,0,n){
		int x,y;
		cin>>x>>y;
		--x,--y;
		int lca=getlca(x,y);
		add[fa[x]].pb(i);add[fa[y]].pb(i);del[lca].pb(i);
		colval[i]=rd(sd);
	}
	tot=1;seg[0]={0,n,n};
	dfs2(0);
	vector<int>a(2*n-1,0);iota(all(a),0);
	sort(all(a),Cmp);
	vector<int>b=a;
	REP(i,0,a.size())b[i]=seg[rt[a[i]]].p2;
	REP(i,1,a.size())b[i]=max(b[i],lcp(0,n-1,rt[a[i]],rt[a[i-1]]));
	vector<int>res(n+1,0);
	REP(i,0,a.size())++res[b[i]];
	REP(i,1,n)res[i]+=res[i-1];
	REP(i,0,n)cout<<qpow(2,2*n-1-res[i])<<'\n';
}
signed main(){
	int tc=1;
	while(tc--)Main();
	return 0;
}
```

---

## 作者：masterhuang (赞：5)

**NOI 2025 折戟沉沙！**

[或许更好的阅读体验](https://www.cnblogs.com/HaHeHyt/p/18992982)

给定一棵 $4n - 1$ 个节点的 **二叉树**，其中每个非叶节点都有 **恰好** 两个子节点。

非叶节点编号为 $1\sim 2n - 1$，叶子节点编号为 $2n\sim 4n - 1$。

初始时，每个叶子节点上都没有数字。

定义一个 **DFS** 序是优美的，当且仅当按该 **DFS** 序将所有 **标有数字的叶子节点** 上的数字拼成一个序列时，可以通过若干次 **消除相邻相同数字** 的方式删空。

给定 $n$ 次操作，第 $i$ 操作会选择两个 **没有数字** 的叶子节点 $a_i,b_i$，然后将这两个节点标上数字 $i$。

- **保证在每次操作后，存在至少一个优美的 DFS 序**。

你需要求出每次操作后的优美的 **DFS** 序的数量，对 $10^9+7$ 取模。

$1\le n\le 2\times 10^5$​

- **部分分（特殊性质）**：保证 $a_i,b_i$ 位于根节点 $1$ 的不同子树中。

- **提示：观察发现大样例中所有答案中的数都形如 $2^k$，其中 $k\le 2n-1$。**

---

下面结论来自国家集训队 **rk.9 hhoppitree**，太大神。

最开头给出结论：

> 定义一个点的**权值**为：子树内**恰好出现过一次**的数形成的**集合**。
>
> 设 $C_i$ 表示第 $i$​ 次所有**本质不同的权值个数**。
>
> 则第 $i$ 次答案为 $2^{2n+i-C_i}$。

如果**懒**得看证明可以直接跳到最后看如何维护。


---

不同 **DFS** 序能通过翻转 $2n-1$ 个子树中的某些一一对应，下面考虑翻转子树。

根据提示，容易往某些方面想：比如找到一些相**对独立的子树翻转的限制**，那么答案就是 $2^{\text{限制个数}}$。

经典套路：由于**保证存在优美的 DFS 序**，我们不妨设最开始的树的 **DFS** 序是满足条件的，然后去挖性质。

否则容易交换一些左右儿子调整成这样。

---

先考虑**特殊性质**。最终答案能删空的串一定形如：$\color{pink}{14322341}$​ 这样。

- 子树等价于某个 **DFS** 序区间，拍平后性质更多，后面都用区间去叙述。

因为所有的点对都是**经过根**的，所以翻转了一段 **DFS** 序区间，就需要对应地翻转右边**内容**完全一样的区间！

- 其中**内容**定义为区间**恰好出现过一次**的数形成的集合。

由于所有区间的**内容**形成了若干**等价类**，因此上述限制等价于：**每个等价类**必须恰好选择**偶数**个区间翻转。

- 简单点说等价类：就是相同权值的点在一个等价类内。

---

但是这东西有点小问题：翻转集合大小 $\le 1$ 的区间没有意义，重写得严谨些：

上述限制等价于：**每个内容里 $>1$​ 个元素的等价类**必须恰好选择**偶数**个区间翻转。

> 我们发现大小为 $0$ 的等价类共 $1$ 个，第 $i$ 次会有 $i$ 个大小为 $1$​ 的等价类个数。
>
> 总共有 $2n-1$ 个非叶子可以翻转。

于是设 $C_i$ 表示第 $i$ 次所有子树的形成的**等价类个数**。

由于每个**必须恰好选择偶数个区间翻转**的限制会使得方案数 $/2$，于是第 $i$​ 次答案为：
$$
2^{2n-1-(C_i-i-1)}=2^{2n+i-C_i}
$$

---

如果没有特殊性质是否也一样呢？

考虑根的两个子树，它们中有一些跨越根的和完全在内部的数字对。

对于任何一个点的子树，分析时只保留恰出现一次的数字，而忽略其它的。

如果只有跨过根的数字，和特殊性质的分析完全一致。

一个子树如果既包含跨越根的数字，又**打乱了**一些完全在内部的数字对，就一定要翻转偶数次。

> 这个结论可以反证：找到最上面的翻转了奇数次的子树，没有其它子树能**救**它，就一定不合法。

我们保留了只有完全在内部的数字对的情况，因此可以递归进根的两个子树各自分析。

于是我们证明了这个结论**仍然成立！**


---

于是我们只需要求等价类个数：$C_1,C_2,\cdots ,C_n$​​。

> 本题后半部分和 [qoj 5425——Proposition Composition](https://qoj.ac/problem/5425) 有点类似。

转换下参考对象，对每个数 $i$ 刻画其在哪些子树出现过。

于是对 $1\sim 4n-1$ 中的每个节点 $i$ 记录字符串 $s_i$，其中 $s_{i,j}=1$ 表示 $i$ 子树内 $j$ 是否恰好出现一次​​。

字符串数组 $s$ 是容易线段树合并维护的，合并的时候做个 $\text{xor}$。

不难发现 $x$ 和 $y$ 位置等价的时刻是 $[1,\text{lcp}(s_x,x_y)]$ 这个区间​。

然后类似 **SA** 中 **height** 数组那类做法，我们**排序**所有 $s$，排序成 $S$​。

求出相邻两两的 $d_x=\text{lcp}(S_x,S_{x+1})$，容易发现第 $i$ 次**等价类个数**就是 $d_x<i$ 的个数再 $+1$​，随便前缀和一下。

>  为啥**等价类个数**是这个呢？大概就是排序后能表示所有**大小相邻**的**不等价类**，再 $+1$ 就是**等价类个数**。

`xor hash` 维护等价类，排序和 $\text{lcp}$​ 直接线段树二分即可，记得开 `unsigned long long`。

时间复杂度 $\mathcal{O}(n\log^2 n)$，空间 $\mathcal{O}(n\log n)$。常数不要太大都足以通过。

---

官方题解说了个不一定跑得过 $\log^2$ 的单 $\log$，讲一下。

注意到瓶颈在于最后的字典序排序，考虑优化。

**发现只需将线段树合并中所有的 $\mathcal{O}(n \log n)$ 个节点排序即可！**

以每个节点的左右儿子的字典序为第 $1,2$ 关键字，进行基数排序即可。

为了方便实现，把线段树长度补成 $2$ 的次幂，从线段树的叶子（区间长度为 $1$）开始做，每次给一层排序。

时空复杂度均为 $\mathcal{O}(n \log n)$​，足以通过。

~~其实感觉也没有特别难写，不过我不写~~

> 个人感觉有点像后缀平衡树，或者 [P6272 没有人的算术](https://www.luogu.com.cn/problem/P6272)？但是貌似没几个和我一样想的。

---

官方题解一个很唐的地方，是没有发现第 $i$ 次**恰好有 $i$ 个**大小为 $1$ 的等价类。

我这样能**直接算等价类个数**，最后 $-i$​ 即可，比官方做法好写一万倍。

- 官方题解是真的算了大小 $>1$ 的等价类个数，还要线段树多维护好多东西。

虽然归并排序 `stable_sort` 的**比较次数** $<$ 快速排序 `sort` 的**比较次数**，但是实际上 `sort` 跑得更快？有点神秘。

下面是 $\log^2$ 实现，**代码非常非常短，跑挺快的**：

```cpp
// 洛谷 P13273
// https://www.luogu.com.cn/problem/P13273
#include<bits/stdc++.h>
#define LL long long
#define u64 unsigned long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
mt19937_64 rnd(time(0));
const int N=8e5+5,M=4e7+5,mod=1e9+7;
int n,m,K,tt,p2[N],rt[N],p[N],s[N];
array<int,2>so[N];
inline int md(int x){return x>=mod?x-mod:x;}
struct node{int ls,rs;u64 x;}a[M];
#define ls(w) a[w].ls
#define rs(w) a[w].rs
inline void pu(int w){a[w].x=a[ls(w)].x^a[rs(w)].x;}
void upd(int &w,int p,u64 x,int l=1,int r=n)
{
	if(!w) w=++tt;a[w].x^=x;
	if(l==r) return;int m=(l+r)>>1;
	p<=m?upd(ls(w),p,x,l,m):upd(rs(w),p,x,m+1,r);
}
int mg(int x,int y,int l=1,int r=n)
{
	if(!x||!y) return x|y;int z=++tt;
	if(l==r) return a[z].x=a[x].x^a[y].x,z;
	int m=(l+r)>>1;
	return a[z].x=a[ls(z)=mg(ls(x),ls(y),l,m)].x^
		   		  a[rs(z)=mg(rs(x),rs(y),m+1,r)].x,z;
}
bool cmp(int x,int y,int l=1,int r=n)
{
	if(!x) return 1;if(!y) return 0;
	if(l==r) return a[x].x<a[y].x;int m=(l+r)>>1;
	if(a[ls(x)].x==a[ls(y)].x) return cmp(rs(x),rs(y),m+1,r);
	return cmp(ls(x),ls(y),l,m);
}
int lcp(int x,int y,int l=1,int r=n)
{
	if(a[x].x==a[y].x) return r-l+1;
	if(l==r) return 0;int m=(l+r)>>1;
	if(a[ls(x)].x==a[ls(y)].x) return m-l+1+lcp(rs(x),rs(y),m+1,r);
	return lcp(ls(x),ls(y),l,m);
}
void dfs(int x){
	auto [u,v]=so[x];
	if(x<m) dfs(u),dfs(v),rt[x]=mg(rt[u],rt[v]);
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n>>n;
	m=2*n;K=4*n-1;for(int i=*p2=1;i<=m;i++) p2[i]=md(p2[i-1]<<1);
	for(int i=1,x,y;i<m;i++) cin>>x>>y,so[i]={x,y};u64 z;
	for(int i=1,x,y;i<=n;i++)
		cin>>x>>y,z=rnd(),upd(rt[x],i,z),upd(rt[y],i,z);
	dfs(1);for(int i=1;i<=K;i++) p[i]=rt[i];
	sort(p+1,p+1+K,[&](int x,int y){return cmp(x,y);});
	for(int i=1;i<K;i++) s[lcp(p[i],p[i+1])]++;
	for(int i=1;i<=n;i++) s[i]+=s[i-1];
	for(int i=1;i<=n;i++) cout<<p2[m+i-s[i-1]-1]<<"\n";
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：2)

场外的 fw。

推导出结论的角度比较感性/youl。结论看上去不太人类，但是如果从递归子问题的角度来一步步分析，还是可以看出来的。

### 基础观察

令 $m$ 表示当前已经插入的叶子对数。

观察答案形态，形如 $2^k$，这启发我们找一些自由元，可以直接确定唯一解。先考虑 $m=n$ 的做法，否则对于 $m<n$，我们可以对于 $2m$ 个叶子建立虚树，只有在虚树**点**上的是关键的，否则可以自由选取（非关键点，另一侧都是空的），而虚树的大小一定是 $4m-1$，这就归约到 $m=n$ 上。

首先考虑特殊性质 $\text{A}$。我们怎么找自由元呢？从下往上非常不好做，因此考虑从根开始同时递归两边，**从上往下找自由元。**

### 特殊性质 AB


注意到特殊性质 $\text{AB}$，手玩一下发现包含根左半边的可以任意选，唯一对应右半边的方案，因此此时答案为 $2^n$，考虑这是为什么：我们在从上往下递归时，根一定是任意选是否翻转，这样你向左有一个颜色集合 $S_1$，右边有一个 $S_2$。现在到了 $l_{root},r_{root}$ 上，你再考虑这两个的儿子的集合 $L_1,L_2,R_1,R_2$，由于他保证了有解，因此必然有 $L_1\subseteq R_2,R_1\subseteq L_2$（或者下标对调一下）。满二叉树的结构保证了这两个集合取等，因此可以继续向下递归这个过程。$m=n$ 的答案就是 $2^m$，再将非虚树点部分考虑，得到答案是 $2^{m+2n-2m}=2^{2n-m}$。

### 特殊性质 A

但是正常特殊性质可能不取等，此时你到这一步可以决定 $l_{root},r_{root}$ 这一对是否翻转，答案乘以 $2$。不妨设他是选左边的，不影响。你考虑 $L_1,R_1$ 的话，$L_1$ 必然完全掉入 $R_1$ 其中一个子树或者完全包含了一个，如果是前者，就要将 $R_1$ 这个子树剩余的部分拉出来和 $L_2-R_2$ 的相匹配，状态其实是一个连通块，然后接着递归。

换一个角度，考虑一个节点什么时候可以成为自由点。整理一下判定，事实上我们是在把等待配对的集合对从上往下不停做划分，由于保证有解，集合对怎么划分是确定的，只有包含，那么直到这对集合与对应子树的状态完全相同，就可以单独往下构成子问题。也就是说，一对子树 $u,v$ 成为一个“子问题”当且仅当 $S(u)=S(v)$，其中 $S(u)$ 表示 $u$ 子树内的颜色集合。

因此对于特殊性质 $\text{A}$ 的 $m=n$，最终结论是：令 $S(u)$ 表示 $u$ 子树内颜色集合，考虑有一共 $c$ 对满足 $u\ne v,S(u)=S(v)$ 且 $u,v$ 并非叶子，答案就是 $2^{c+1}$，$+1$ 是因为要考虑根。再把不在虚树上的 $2(n-m)$ 个点加上来，得到答案是 $2^{c+1+2n-2m}$。

### 无特殊性质的平方做法

在特殊性质 $\text{A}$ 中，我们重点关注了“子树内出现颜色集合”。

先考虑下传的集合，只有跨越根的路径。那么在后续过程中，还会加入一些完全在其中一侧的颜色。对于完全在子树中，跨越当前根的颜色，他就类似于性质 $\text{A}$ 中全局的根节点一样，它们的限制会在进一步递归中发挥作用，不影响当前子树内正在下传集合与别的子树的相关性，因此我们猜测：我们需要关心的是：“子树内**出现一次**的颜色集合”。

但与性质 $\text{A}$ 不同的是，导出同一个集合的子树可能有很多（在特殊性质 $\text{A}$ 中，每个等价类的大小上限是 $2$）。我们声称，对于同一个等价类会贡献 $2^{size-1}$。就是说考虑把最深的之外的所有同等价类任意翻转，此时子树这些出现一次的内最终相对关系确定，最后一个点是否翻转也是确定的。把那个式子改成 $2^{size}\times 2^{-1}$，因此我们关心等价类个数。对这堆东西简化一下，虚树实际上非常愚蠢，因为他就不改变颜色集合，但是给答案 $\times2$。容易得到**最终结论**：令 $S(u)$ 表示 $u$ 子树中只出现一次的颜色集合，本质不同的 $S(u)$ 有 $cnt$ 个时，最终答案是 $2^{2n-cnt+m}$。

别急，看完 A 性质是啥之后这个结论好像也不难猜到。

### 数据结构优化

问题化简为：给定一棵树，$n$ 次操作，对于两段直链（对于 $\text{lca}$ 就消除了）加入同一个数，询问此时本质不同的集合个数。


这不是我们 [Proposition Composition](https://qoj.ac/problem/5425) 吗？

启发式分裂集合加树剖维护祖先的前驱之类的，时间复杂度 $\mathcal O(n\log^3n)$，难写难调还慢。

官方题解非常厉害，这个做法事实上也是 Kubic 在 NOIWC2025 中《思维型题目选讲》讲的 [Proposition Composition](https://qoj.ac/problem/5425) 做法。

令 $a_{i,j}=[i\in \text{path}(j)]$，也就是说 $a_i$ 是一个 $01$ 串。其中 $\text{path}(j)$ 指的是 $(a_j,b_j)$ 路径上除了 $\text{lca}$ 的所有点构成的集合，即含有颜色 $j$ 的点集。则 $i$ 与 $j$ 在 $t$ 时刻属于同一等价类当且仅当 $t≤\text{lcp}(a_i,a_j)$。

由后缀数组的相关结论，我们可以对所有字符串排序，转化为排名上所有相邻 $\text{lcp}$ 的区间最小值。因此将所有 $a_1,\cdots,a_{4n-1}$ 按照字典序排序得到 $b$，同时将过程倒置变为合并等价类，在 $\text{lcp}(b_i,b_{i+1})$ 时刻将 $b_i,b_{i+1}$ 合并即可。问题转化为求 $b$。

那么就需要进行 $\mathcal O(n\log n)$ 次字典序比较，此时需要求两个串的 $\text{lcp}$。这个问题很经典，维护哈希值，二分找到第一个不同的位置。如果二分主席树那么就是 $\mathcal O(\log^2n)$ 的，考虑做到 $\mathcal O(\log n)$ 比较：直接交换两维，在树上进行线段树合并就好了。这样只需要直接在可持久化线段树的两棵树上同时进行二分。时间复杂度 $\mathcal O(n\log^2n)$。实现上可以使用 xor-hash，这样直接做树上可持久化线段树合并就是对的。


### 参考代码

比较短，2.07KB 就写完了。

``` cpp
void update(int &o,int l,int r,int pos,ull val){
	t[o=++tot]=val;
	if(l==r)return;
	int mid=(l+r)>>1;
	(pos<=mid)?update(ls[o],l,mid,pos,val):update(rs[o],mid+1,r,pos,val);
}
int merge(int x,int y){
	if(!x||!y)return x^y;
	int o=++tot;
	ls[o]=merge(ls[x],ls[y]),rs[o]=merge(rs[x],rs[y]),t[o]=t[ls[o]]^t[rs[o]];
	return o;
}
void solve(){
	pw[0]=1;
	F(i,1,maxn-3)pw[i]=add(pw[i-1],pw[i-1]);
	cin>>n,N=(n<<2)-1;
	F(i,1,(n<<1)-1)cin>>lc[i]>>rc[i],fa[lc[i]]=fa[rc[i]]=i;
	F(i,1,n)cin>>qx[i]>>qy[i],pos[qx[i]]=pos[qy[i]]=i,qwq[i]=eng();
	F(u,(n<<1),N)update(rt[u],1,n,pos[u],qwq[pos[u]]);
	dF(u,(n<<1)-1,1)rt[u]=merge(rt[lc[u]],rt[rc[u]]);
	vector<int>perm;
	F(i,1,N)perm.push_back(i);
	auto qry=[&](int x,int y){
		int l=1,r=n;
		while(l<r){
			int mid=(l+r)>>1;
			if(t[ls[x]]==t[ls[y]])l=mid+1,x=rs[x],y=rs[y];
			else r=mid,x=ls[x],y=ls[y];
		}
		return t[x]==t[y]?n+1:(t[x]==0?-l:l);
	};
	sort(all(perm),[&](int x,int y)->bool{
		if(t[rt[x]]==t[rt[y]])return x<y;
		if(min(x,y)>=(n<<1))return pos[x]==pos[y]?x<y:pos[x]>pos[y];
		const int res=qry(rt[x],rt[y]);
		if(res<0)return 1;
		return (res==n+1)?x<y:0;
	});
	F(i,0,N-2)++diff[abs(qry(rt[perm[i]],rt[perm[i+1]]))-1];
	dF(i,n-1,1)diff[i]+=diff[i+1];
	F(i,1,n)cout<<pw[(n<<1)+i-(N-diff[i])]<<'\n';
}
```

---

## 作者：Felix72 (赞：2)

从部分分开始思考。这道题的限制较多，考虑用 Hall 定理的思维方式，用很多必要条件凑出一个充要条件。

我们定义**绑定**表示两个节点对答案贡献的关系。若我们说 $(u, v)$ 绑定，则表示当 $u$ 的决策（先走哪个子树）确定时，$v$ 的决策唯一确定；当 $v$ 的决策（先走哪个子树）确定时，$u$ 的决策也唯一确定。

可以想出一个基本的必要条件如下：若存在节点 $u, v$ 以及数字 $a, b$，满足 $a, b$ 分别在 $u, v$ 的不同子树内刚好出现一次，则 $(u, v)$ 是**绑定**的。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7iaufcip.png)

不失一般性地，设 $u$ 先访问，$v$ 后访问。若 $u$ 选择先获得蓝色，则 $v$ 需要在获得红色之后获得蓝色。其他情况类似。则我们可知 $u$ 和 $v$ 一起对答案只有 $2$ 倍的贡献。

这个绑定关系的定义决定了其传递性。题目保证有解，则我们不难理解这最多 $O(n ^ 2)$ 个必要的绑定关系如果都被满足，则当前解一定合法。可以用并查集维护绑定关系，获得 $56 \text{pts}$。

从这个角度考虑最多只能止步 $O(n^2\alpha(n))$ 或者 $O(n^2)$，考虑对这个条件改变一点刻画方式，使得其能被数据结构优化。

假设已经加入 $i$ 种颜色，我们声称答案是 $2^{2n - w_i + i}$，其中设节点 $u$ 子树中包含的恰好出现一次的数字集合是 $s(u)$，$w$ 表示不同的 $s$ 的个数。

理解一下这个条件和之前条件的关系：从下到上考虑，每当新出现一个 $s$，说明左右子树都包含某些数字，并出现了合并，此时这个节点是两种不同数字的 $\text{LCA}$，其一定和另一个节点绑定，则去掉该节点的贡献即可。换句话说，我们可以感性理解为一个新的 $s$ 和两个绑定连通块被联通是等价的。$+i$ 则是因为要去掉 $|s(u)| = 1$ 的集合，显然他们有一个空子树，是不影响答案的。

使用线段树维护异或哈希表示每个点的 $s$。考虑用字符串表示 $s$，串的第 $i$ 位是 $1$ 表示 $s$ 包含数字 $i$。容易写出如下线段树满足：

- 可以单点修改，在 $i$ 位置表示加入数字 $i$；
- 可以查询一个区间的异或和，表示一个串子串的哈希值；
- 可以可持久化合并。

在树上做可持久化线段树合并，这样我们维护出了每个串的哈希值，对他们从小到大排序，并求出相邻串的 $\text{LCP}$，则加入每个数字 $i$ 后不同的前缀 $[1, i]$ 有多少个就可以直接得到了。

```cpp
 /* NE_Cat 4.3 */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 800010, mod = 1e9 + 7;
typedef unsigned long long ull;
int ID, n, ls[N], rs[N], pw[N]; vector < int > tr[N];

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
int rt[N], idx;
struct SGT
{
	int ls, rs; ull tag;
	#define ls(x) tree[x].ls
	#define rs(x) tree[x].rs
	#define tag(x) tree[x].tag
} tree[N * 40];
inline void pushup(int now) {tag(now) = (tag(ls(now)) ^ tag(rs(now)));}
inline void insert(int &now, int l, int r, int pos, ull num)
{
	if(!now) now = ++idx;
	if(l == r) {tag(now) ^= num; return ;}
	int mid = (l + r) >> 1;
	if(pos <= mid) insert(ls(now), l, mid, pos, num);
	else insert(rs(now), mid + 1, r, pos, num);
	pushup(now);
}
inline int merge(int nx, int ny, int l, int r)
{
	if(!nx || !ny) return nx + ny;
	int now = ++idx; tag(now) = (tag(nx) ^ tag(ny));
	if(l == r) return now; int mid = (l + r) >> 1;
	ls(now) = merge(ls(nx), ls(ny), l, mid);
	rs(now) = merge(rs(nx), rs(ny), mid + 1, r);
	return now;
}
inline int compare(int nx, int ny, int l, int r)
{
	if(tag(nx) == tag(ny)) return r;
	if(l == r) return 0;
	int mid = (l + r) >> 1;
	int ln = compare(ls(nx), ls(ny), l, mid);
	if(ln == mid)
	{
		int cur = compare(rs(nx), rs(ny), mid + 1, r);
		if(cur != 0) return cur; return mid;
	}
	return ln;
}
inline ull query(int now, int l, int r, int L, int R)
{
	if(L <= l && r <= R) return tag(now);
	int mid = (l + r) >> 1;
	if(R <= mid) return query(ls(now), l, mid, L, R);
	else if(mid < L) return query(rs(now), mid + 1, r, L, R);
	else return (query(ls(now), l, mid, L, R) ^ query(rs(now), mid + 1, r, L, R));
}
inline bool check(int now, int p) {return (query(rt[now], 1, n, p, p) != 0);}
inline int lcp(int x, int y) {return compare(rt[x], rt[y], 1, n);}

inline bool get(int nx, int ny, int l, int r)
{
	if(l == r)
	{
		if(tag(nx) == tag(ny)) return false;
		return (tag(nx) == 0);
	}
	int mid = (l + r) >> 1;
	if(tag(ls(nx)) == tag(ls(ny))) return get(rs(nx), rs(ny), mid + 1, r);
	else return get(ls(nx), ls(ny), l, mid);
}
inline bool cmp(int x, int y) {return get(rt[x], rt[y], 1, n);}
int id[N * 2], w[N];

inline void work(int pos)
{
	for(int to : tr[pos])
	{
		work(to);
		rt[pos] = merge(rt[pos], rt[to], 1, n);
	}
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> ID >> n;
	pw[0] = 1; for(int i = 1; i <= 4 * n; ++i) pw[i] = pw[i - 1] * 2 % mod;
	for(int i = 1; i <= 2 * n - 1; ++i)
	{
		cin >> ls[i] >> rs[i];
		tr[i].push_back(ls[i]);
		tr[i].push_back(rs[i]);
	}
	for(int i = 1; i <= n; ++i)
	{
		int x, y; cin >> x >> y;
		ull cur = rnd();
		insert(rt[x], 1, n, i, cur);
		insert(rt[y], 1, n, i, cur);
	}
	work(1);
	for(int i = 1; i <= 4 * n - 1; ++i) id[i] = i;
	sort(id + 1, id + (4 * n - 1) + 1, cmp);
	for(int i = 1; i < 4 * n - 1; ++i) ++w[lcp(id[i], id[i + 1]) + 1];
	w[0] = 1;
	for(int i = 1; i <= n; ++i) w[i] += w[i - 1];
	for(int i = 1; i <= n; ++i) cout << pw[2 * n - 1 - w[i] + (i + 1)] << '\n';
	return 0;
}
/*

*/
```

---

## 作者：lsj2009 (赞：1)

默认树的先序遍历是优美的。将 dfs 序改为：对于每个节点可以选择是否翻转其左右儿子（称为翻转一个节点），最终得到的树的先序遍历。dfs 序总数为 $2^{2n-1}$ 次。

提出很强势的结论：

- 记子树 $u$ 的权值是所有在 $u$ 子树内出现恰好一次的颜色构成的集合。

- 我们称对于 $u$ 子树的翻转操作是同时翻转所有 $u$ 子树内的点，对于 dfs 序列的影响实际上就是 reverse 了一整个子树对应的区间。显然所有子树是否翻转与所有点是否翻转的方案是构成双射的，故可转为考虑前者。

- 将权值相同的子树划分进同一等价类，则翻转方案合法的充要条件是，对于所有权值大小 $\ge 2$ 对应的等价类中，恰有偶数个子树被翻转。

证明：

- 实际上只需要说明所有 A 性质树满足条件（我们称一个树是 A 性质的，当且仅当对于任意颜色，其对应的两个节点分居根两侧）；否则找到极小的 A 性质子树，该子树必须满足其自身可以完全消去，从而可以删掉该子树归纳证明。

- 对于 A 性质树，每一等价类最多包含两棵子树（认为所有叶子都被激活，否则取出虚树再压缩掉链即可），则我们仅需要说明：
  
  - 大小为 $1$ 的等价类必不可以进行翻转子树操作。
  
  - 大小为 $2$ 的等价类可以同时翻转两棵子树。
  
  依据翻转子树实际上是 reverse 颜色序列，讨论一下是简单的。

则大小为 $m$ 等价类对于答案贡献为 $\sum\limits_{0\le i\le m,i\equiv0\pmod{2}} \binom{m}{i}=\frac{(1+1)^m+(1-1)^m}{2}=2^{m-1}$，即每一等价类令答案折半；故仅需统计所有权值大小 $\ge 2$ 对于的等价类个数 $c_i$，答案即为 $2^{2n-1-c_i}$。对于每一节点存储长为 $n$ 的 $01$ 串记录每个颜色是否恰好出现一次，则 $c_i$ 即为：将所有串截取前 $i$ 位情况下本质不同的串个数，再去除掉 popcount $\le 1$ 的串个数，即 $i+1$。

逆时间轴考虑问题，先可持久化线段树合并获取所有完整的 $01$ 串，维护哈希值（xor hash）进行排序，随 $i$ 减小不相同的串可能变为相同：排序后 $s_{k-1},s_k$ 串将在 $i\le \operatorname{lcp}(s_{k-1},s_k)$ 时相同。

复杂度 $\mathcal{O}(n\log^2{n})$。

```cpp
#include<bits/stdc++.h>
// #define int long long
// #pragma GCC optimize(3,"Ofast","inline")
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ll long long
#define bint __int128
#define ull unsigned long long
#define uint unsigned int
#define ld double
#define PII pair<int,int>
#define umap unordered_map
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
#define pcnt(x) __builtin_popcount(x)
#define lg(x) (31-__builtin_clz(x))
using namespace std;
void file_IO() {
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
}
bool M1;
const int INF=0x3f3f3f3f;
const ll INFLL=0x3f3f3f3f3f3f3f3f;
const ld eps=1e-9;
template<int p>
struct mint {
	int x;
	mint() {
		x=0;
	}
	mint(int _x) {
		x=_x;
	}
	friend mint operator + (mint a,mint b) {
		return a.x+b.x>=p? a.x+b.x-p:a.x+b.x;
	}
	friend mint operator - (mint a,mint b)  {
		return a.x<b.x? a.x-b.x+p:a.x-b.x;
	}
	friend mint operator * (mint a,mint b) {
		return 1ll*a.x*b.x%p;
	}
	friend mint operator ^ (mint a,ll b) {
		mint res=1,base=a;
		while(b) {
			if(b&1)
				res*=base;
			base*=base; b>>=1;
		}
		return res;
	}
	friend mint operator ~ (mint a) {
		return a^(p-2);
	}
	friend mint operator / (mint a,mint b) {
		return a*(~b);
	}
	friend mint & operator += (mint& a,mint b) {
		return a=a+b;
	}
	friend mint & operator -= (mint& a,mint b) {
		return a=a-b;
	}
	friend mint & operator *= (mint& a,mint b) {
		return a=a*b;
	}
	friend mint & operator /= (mint& a,mint b) {
		return a=a/b;
	}
	friend mint operator ++ (mint& a) {
		return a+=1;
	}
	friend mint operator -- (mint& a) {
		return a-=1;
	}
};
const int MOD=1e9+7;
#define mint mint<MOD>
const int N=1e6+5;
const ull base=1145141;
ull pw[N];
void init(int n=1e6) {
	pw[0]=1;
	rep(i,1,n)
		pw[i]=pw[i-1]*base;
}
struct SGT {
	static const int M=2e7+5;
	struct node {
		int lson,rson;
		ull val;
	}; node tree[M];
	#define ls(k) tree[k].lson
	#define rs(k) tree[k].rson
	int p;
	int new_node() {
		return ++p;
	}
	void push_up(int k) {
		tree[k].val=tree[ls(k)].val^tree[rs(k)].val;
	}
	void update(int &k,int l,int r,int qx) {
		if(!k)
			k=new_node();
		if(l==r) {
			tree[k].val^=pw[l];
			return;
		}
		int mid=(l+r)>>1;
		if(qx<=mid)
			update(ls(k),l,mid,qx);
		else
			update(rs(k),mid+1,r,qx);
		push_up(k);
	}
	int merge(int u,int v,int l,int r) {
		if(!u||!v)
			return u|v;
		if(l==r) {
			int k=new_node();
			tree[k].val=tree[u].val^tree[v].val;
			return k;
		}
		int k=new_node(),mid=(l+r)>>1;
		ls(k)=merge(ls(u),ls(v),l,mid);
		rs(k)=merge(rs(u),rs(v),mid+1,r);
		push_up(k);
		return k;
	}
	bool cmp(int u,int v,int l,int r) {
		if(l==r)
			return tree[u].val<tree[v].val;
		int mid=(l+r)>>1;
		if(tree[ls(u)].val!=tree[ls(v)].val)
			return cmp(ls(u),ls(v),l,mid);
		else
			return cmp(rs(u),rs(v),mid+1,r);
	}
	int lcp(int u,int v,int l,int r) {
		if(l==r)
			return tree[u].val==tree[v].val? l:l-1;
		int mid=(l+r)>>1;
		if(tree[ls(u)].val!=tree[ls(v)].val)
			return lcp(ls(u),ls(v),l,mid);
		else
			return lcp(rs(u),rs(v),mid+1,r);
	}
	void print(int k,int l,int r) {
		if(l==r) {
			debug("%d",tree[k].val? 1:0);
			return;
		}
		int mid=(l+r)>>1;
		print(ls(k),l,mid);
		print(rs(k),mid+1,r);
	}
	#undef ls
	#undef rs
}; SGT T;
int ls[N],rs[N],a[N],rt[N],cnt[N],n,_;
void dfs(int u) {
	if(u>=(n<<1)) {
		T.update(rt[u],1,n,a[u]);
		return;
	}
	dfs(ls[u]);
	dfs(rs[u]);
	rt[u]=T.merge(rt[ls[u]],rt[rs[u]],1,n);
}
void solve() {
	scanf("%d%d",&_,&n);
	rep(i,1,(n<<1)-1)
		scanf("%d%d",&ls[i],&rs[i]);
	rep(i,1,n) {
		int u,v;
		scanf("%d%d",&u,&v);
		a[u]=a[v]=i;
	}
	dfs(1);
	// rep(i,1,(n<<2)-1)
	// 	T.print(rt[i],1,n),debug("\n");
	sort(rt+1,rt+(n<<2),[](const int &x,const int &y) {
		return T.cmp(x,y,1,n);
	});
	// debug("-------------\n");
	// rep(i,1,(n<<2)-1)
	// 	T.print(rt[i],1,n),debug("\n");
	cnt[n]=(n<<2)-1;
	rep(i,2,(n<<2)-1) {
		int x=T.lcp(rt[i-1],rt[i],1,n);
		// debug("lcp (%d,%d) = %d\n",i,i-1,x);
		--cnt[x];
	}
	per(i,n-1,1)
		cnt[i]+=cnt[i+1];
	rep(i,1,n)
		printf("%d\n",(mint(2)^((n<<1)-1-(cnt[i]-i-1))).x);
}
bool M2;
// g++ tree.cpp -std=c++14 -Wall -O2 -o tree
signed main() {
	// file_IO();
	int testcase=1;
	init();
	// scanf("%d",&testcase);
	while(testcase--)
		solve();
	debug("used time = %dms\n",(signed)(1000*clock()/CLOCKS_PER_SEC));
	debug("used memory = %dMB\n",(signed)((&M1-&M2)/1024/1024));
	return 0;
}
```

---


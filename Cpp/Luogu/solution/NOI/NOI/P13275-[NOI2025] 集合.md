# [NOI2025] 集合

## 题目背景

set.cpp / 2 s / 512 MiB

## 题目描述

小 X 有 $2^n$ 个数，编号为 $0$ 到 $2^n - 1$，第 $i$ ($0 \leq i < 2^n$) 个数为 $a_i$。

对于 $S \subseteq \{0, 1, \ldots, 2^n - 1\}$，定义 $f(S)$ 为集合 $S$ 中 **所有数的二进制按位与**。特别地，若 $S$ 为空集，则 $f(S) = 2^n - 1$。

定义两个 $\{0, 1, \ldots, 2^n - 1\}$ 的子集 $P, Q$（可以为空）构成的有序对 $(P, Q)$ 是 **特别的** 当且仅当 $P \cap Q = \varnothing$ 且 $f(P) = f(Q)$。定义有序对 $(P, Q)$ 的 **权值** 为 **编号** 包含在 $P \cup Q$ 内的所有数的乘积，即 $\prod_{i \in P \cup Q} a_i$。特别地，若 $P \cup Q = \varnothing$，则有序对 $(P, Q)$ 的权值为 $1$。

小 X 想要知道所有特别的有序对的权值之和，请你帮助他求出这个值。由于答案可能较大，你只需要求出答案对 $998,244,353$ 取模后的结果。


## 说明/提示

**【样例 2】**

见选手目录下的 `set/set2.in` 与 `set/set2.ans`。

该样例满足测试点 2 的约束条件。

**【样例 3】**

见选手目录下的 `set/set3.in` 与 `set/set3.ans`。

该样例满足测试点 3 的约束条件。

**【样例 4】**

见选手目录下的 `set/set4.in` 与 `set/set4.ans`。

该样例满足测试点 9 的约束条件。

**【数据范围】**

对于所有测试数据，保证：
- $1 \leq t \leq 3$;
- $2 \leq n \leq 20$;
- 对于所有 $0 \leq i < 2^n$，均有 $0 \leq a_i < 998,244,353$。

::cute-table{tuack}

|  测试点编号  | $n \leq$ | 特殊性质 |
| :----------: | :------: | :------: |
|     $1$      |   $4$    |    B     |
|     $2$      |   ^    |    无    |
|     $3$      |   $8$    |    B     |
|     $4$      |   ^    |    无    |
|     $5$      |   $10$   |    B     |
|     $6$      |   ^   |    无    |
|    $7, 8$    |   $12$   |    B     |
|     $9$      |   ^   |    无    |
| $10 \sim 12$ |   $16$   |    B     |
|   $13, 14$   |   ^   |    无    |
|   $15, 16$   |   $20$   |    AB    |
|   $17, 18$   |   ^   |    A     |
| $19 \sim 21$ |   ^   |    B     |
| $22 \sim 25$ |   ^   |    无    |

特殊性质 A: 保证至多存在 24 个 $i$ 满足 $a_i \neq 0$。

特殊性质 B: 保证对于所有 $0 \leq i < 2^n$，均有 $a_i \neq 998,244,352$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13083)。

## 样例 #1

### 输入

```
0 2
2
1 2 3 4
3
1 1 1 1 1 1 1 1```

### 输出

```
117
2091```

# 题解

## 作者：cyffff (赞：21)

[$\text{Link}$](https://www.luogu.com.cn/problem/P13275)
## 前言
[感谢本题为我的 OI 生涯画上一个完美的句号，谨以此纪念场上为之奋斗的两个半小时](https://www.luogu.com.cn/article/dwcn28bs)。

本题解的解法将会比较暴力。

## 题意
给定长为 $2^n$ 的序列 $a_{0\sim2^n-1}$，定义 $f(S)$ 为集合 $S$ 中所有数的二进制按位与。对于所有 $\{0, 1, \ldots, 2^n - 1\}$ 的不交子集对 $P,Q$ 满足 $f(P)=f(Q)$，计算 $\prod_{i \in P \cup Q} a_i$ 之和。对 $998244353$ 取模。

$n\le 20$，$T\le 3$。
## 思路

直接写一个容斥可以做到 $O(8^n)$ 至 $O(7^n)$，可以获得 $16$ 分，但没什么前途。

考虑直接看作二元集合幂级数，即

$$\prod_S\left(x^Uy^U+x^Sy^Ua_S+x^Uy^Sa_S\right)$$

其中 $U$ 表示全集，乘法为集合幂级数 $\text{and}$ 卷积，其 FWT 与 IFWT 分别为高维后缀和以及高维后缀差分。

维护 FWT 结果，每次乘入一项只会更新 $x,y$ 的此项中至少有一个是 $S$ 子集的元素，最终 IFWT 回去后求解所有 $[x^Sy^S]$ 项的系数之和，暴力做即为 $O(6^n)$，可以获得 $24$ 分。

瓶颈为乘入一项时枚举子集，要想求答案的 FWT 数组的 $[x^Ay^B]$ 项系数，不妨考虑每个 $S$ 对其的贡献。记 $f_S,g_S$ 分别为：

$$f_S=\prod_{S\sube T}(a_T+1)$$
$$g_S=\prod_{S\sube T}\dfrac{2a_T+1}{(a_T+1)^2}$$

那么答案的 FWT 数组的 $[x^Ay^B]$ 项系数即为 $f_Sf_Tg_{S\cup T}$，做到 $O(4^nn)$。注意处理 $a_S\equiv -1$，不妨将每个数记作 $v\cdot z^k$，其中 $z=0$。

最后做 IFWT 很没必要，反向推出 FWT 数组的 $[x^Ay^B]$ 项对答案的贡献系数为 $(-1)^{|A|+|B|}2^{|A\cap B|}$，即可做到 $O(4^n)$，获得 $36$ 分。

明显可以发现这是 $\text{or}$ 卷积的形式，拆一下 $|A\cap B|$ 即可通过 B 性质获得 $68$ 分。问题在于此时涉及了加减法，每个值变为了多项式。注意到最终的运算肯定不会涉及 $z$ 的负次幂，即每个多项式只有最低次项有可能有用，故直接维护最低次项的值即可。

时间复杂度 $O(2^nn)$，可以通过。

代码之后再补。

> 为什么要攀登？因为山就在那里。

---

## 作者：cancan123456 (赞：16)

![](https://cdn.luogu.com.cn/upload/image_hosting/zhk0n76b.png)

首先是一个暴力 DP，$f_{i,j,k}$ 表示考虑了 $a_0\sim a_{i-1}$，当前 $f(P)=j,f(Q)=k$ 时权值之和，然后转移 $\begin{cases}f_{i,j,k}a_i\to f_{i+1,j\cap i,k}\\f_{i,j,k}a_i\to f_{i+1,j,k\cap i}\\f_{i,j,k}\to f_{i+1,j,k}\end{cases}$，好像可以用集合幂级数科技做，但是我们不会，怎么办？

想想这种转移规整的 DP 都是怎么做的，把一维改成卷积？激进一点，两维地位是对称的，都改成卷积！枚举 $S,T$ 钦定 $f(P)\supseteq S,f(Q)\supseteq T$，然后假设我们算出来这种情况权值和是 $q_{S,T}$，怎么算答案？

容斥系数，我们可以写个高斯消元然后瞪眼法硬瞪系数，比如说，对 $n=4$ 的系数

```plain
 1 -1 -1  1 -1  1  1 -1 -1  1  1 -1  1 -1 -1  1 
-1  2  1 -2  1 -2 -1  2  1 -2 -1  2 -1  2  1 -2
-1  1  2 -2  1 -1 -2  2  1 -1 -2  2 -1  1  2 -2 
 1 -2 -2  4 -1  2  2 -4 -1  2  2 -4  1 -2 -2  4
-1  1  1 -1  2 -2 -2  2  1 -1 -1  1 -2  2  2 -2 
 1 -2 -1  2 -2  4  2 -4 -1  2  1 -2  2 -4 -2  4
 1 -1 -2  2 -2  2  4 -4 -1  1  2 -2  2 -2 -4  4
-1  2  2 -4  2 -4 -4  8  1 -2 -2  4 -2  4  4 -8 
-1  1  1 -1  1 -1 -1  1  2 -2 -2  2 -2  2  2 -2 
 1 -2 -1  2 -1  2  1 -2 -2  4  2 -4  2 -4 -2  4 
 1 -1 -2  2 -1  1  2 -2 -2  2  4 -4  2 -2 -4  4
-1  2  2 -4  1 -2 -2  4  2 -4 -4  8 -2  4  4 -8 
 1 -1 -1  1 -2  2  2 -2 -2  2  2 -2  4 -4 -4  4 
-1  2  1 -2  2 -4 -2  4  2 -4 -2  4 -4  8  4 -8 
-1  1  2 -2  2 -2 -4  4  2 -2 -4  4 -4  4  8 -8
 1 -2 -2  4 -2  4  4 -8 -2  4  4 -8  4 -8 -8 16
```

进行瞪眼法，先看正负号，第一行，很熟悉啊！Thue-Morse 序列，即 $(-1)^{|S|}$，然后往下看，每一行要么是 $(-1)^{|S|}$ 要么是 $(-1)^{|S|+1}$，然后正负号切换是 $T$ 上的 Thue-Morse 序列！正负号是 $(-1)^{|S|+|T|}$！

然后看绝对值，绝对值都是 $2$ 的幂，观察前 $4$ 行，一眼就能瞪出，第二行是奇偶性检测，第三行是检测倒数第二位的，第四行是二和三乘起来，这就是 $2^{|S\cap T|}$！所以容斥系数 $2^{|S\cap T|}(-1)^{|S|+|T|}$。

然后怎么求 $q_{S,T}$，对每个 $i$ 分类讨论：

$$q_{S,T}=\prod_{i\supseteq S\land i\nsupseteq T}(a_i+1)\prod_{i\nsupseteq S\land i\supseteq T}(a_i+1)\prod_{i\supseteq S\land i\supseteq T}(2a_i+1)$$

这咋做，写成这个形式试试

$$q_{S,T}=\prod_{i\supseteq S}(a_i+1)\prod_{i\supseteq T}(a_i+1)\prod_{i\supseteq S\cup T}\frac{2a_i+1}{(a_i+1)^2}$$

令 $f_S'=\prod_{i\supseteq S}(a_i+1),g_S'=\prod_{i\supseteq S}\dfrac{2a_i+1}{(a_i+1)^2}$，那么 $q_{S,T}=f_S'f_T'g_{S\cup T}'$，答案即为 $\sum_{S,T}2^{|S\cap T|}(-1)^{|S|+|T|}f_S'f_T'g_{S\cup T}'$，这个式子里又是 $S\cup T$ 又是 $S\cap T$ 很难办啊，联想到容斥原理

$$|S\cap T|+|S\cup T|=|S|+|T|$$

把答案写成 $\sum_{S,T}(-2)^{|S|}(-2)^{|T|}2^{-|S\cup T|}f_S'f_T'g_{S\cup T}'$，令 $f_S=(-2)^{|S|}f_S',g_S=2^{-|S|}g_S'$，答案写成 $\sum_{S,T}f_Sf_Tg_{S\cup T}$，这就很好求了，先算 $f$ 和 $f$ 的[或卷积](https://www.luogu.com.cn/problem/P4717)然后和 $g$ 求内积即可。然后 $f,g$ 后缀和直接秒。

时间复杂度 $O(\sum n2^n)$，可以通过……怎么只过了 B 性质的包？

哦对 $a_i+1=0$ 时我们的逆元会爆掉，那么常见 trick 对吧，我们存数的时候存 $a\times0^b$，然后加法的时候让 $b$ 小的压过 $b$ 大的就行了。

时间复杂度 $O(\sum n2^n)$，可以通过此题。

用于打表容斥系数的代码。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
const int k = 4, n = 1 << (2 * k);
int zip(int S, int T) {
    return (S << k) | T;
}
ll qpow(ll a, ll b) {
    ll ans = 1;
    while (b > 0) {
        if (b % 2 == 1) {
            (ans *= a) %= mod;
        }
        (a *= a) %= mod;
        b /= 2;
    }
    return ans;
}
ll inv(ll x) {
    return qpow(x, mod - 2);
}
ll M[n][n + 1];
void normalize(ll & x) {
    if (x > mod / 2) {
        x -= mod;
    }
}
int flag(int x) {
    return x % 2 == 1 ? -1 : 1;
}
int main() {
    for (int S = 0; S < (1 << k); S++) {
        M[zip(S, S)][n] = 1;
    }
    for (int S = 0; S < (1 << k); S++) {
        for (int T = 0; T < (1 << k); T++) {
            for (int A = 0; A < (1 << k); A++) {
                for (int B = 0; B < (1 << k); B++) {
                    if ((S & A) == S && (T & B) == T) {
                        M[zip(A, B)][zip(S, T)] = 1;
                    }
                }
            }
        }
    }
    for (int i = 0; i < n; i++) {
        int r = -1;
        for (int j = i; j < n; j++) {
            if (M[j][i] != 0) {
                r = j;
            }
        }
        if (r == -1) {
            printf("oh, no!\n");
            return 0;
        }
        swap(M[r], M[i]);
        ll mul = inv(M[i][i]);
        for (int j = 0; j <= n; j++) {
            (M[i][j] *= mul) %= mod;
        }
        for (int j = 0; j < n; j++) {
            if (i == j) {
                continue;
            }
            ll val = M[j][i];
            for (int k = 0; k <= n; k++) {
                (M[j][k] += mod - M[i][k] * val % mod) %= mod;
            }
        }
    }
    for (int S = 0; S < (1 << k); S++) {
        for (int T = 0; T < (1 << k); T++) {
            normalize(M[zip(S, T)][n]);
            printf("%2lld ", M[zip(S, T)][n]);
        }
        printf("\n");
    }
    return 0;
}
```

只能过 B 性质的代码

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
const int N = 20;
int n;
ll a[1 << N];
ll qpow(ll a, ll b) {
	if (a < 0) {
		a += mod;
	}
	if (b < 0) {
		b += mod - 1;
	}
    ll ans = 1;
    while (b > 0) {
        if (b % 2 == 1) {
            (ans *= a) %= mod;
        }
        (a *= a) %= mod;
        b /= 2;
    }
    return ans;
}
ll inv(ll x) {
    return qpow(x, mod - 2);
}
ll f[1 << N], g[1 << N], h[1 << N];
int main() {
	// freopen("in.txt", "r", stdin);
	int t;
	scanf("%*d %d", &t);
	for (; t != 0; t--) {
		scanf("%d", &n);
		for (int i = 0; i < (1 << n); i++) {
			scanf("%lld", &a[i]);
			f[i] = (a[i] + 1) % mod;
			g[i] = (2 * a[i] + 1) * inv(a[i] + 1) % mod * inv(a[i] + 1) % mod;
		}
		for (int i = 0; i < n; i++) {
			for (int S = 0; S < (1 << n); S++) {
				if (((S >> i) & 1) == 0) {
					(f[S] *= f[S | (1 << i)]) %= mod;
					(g[S] *= g[S | (1 << i)]) %= mod;
				}
			}
		}
		for (int S = 0; S < (1 << n); S++) {
			(f[S] *= qpow(-2, __builtin_popcount(S))) %= mod;
			(g[S] *= qpow(2, -__builtin_popcount(S))) %= mod;
		}
		for (int i = 0; i < n; i++) {
			for (int S = 0; S < (1 << n); S++) {
				if (((S >> i) & 1) == 0) {
					(f[S | (1 << i)] += f[S]) %= mod;
				}
			}
		}
		for (int S = 0; S < (1 << n); S++) {
			h[S] = f[S] * f[S] % mod;
		}
		for (int i = 0; i < n; i++) {
			for (int S = 0; S < (1 << n); S++) {
				if (((S >> i) & 1) == 0) {
					(h[S | (1 << i)] += mod - h[S]) %= mod;
				}
			}
		}
		ll ans = 0;
		for (int S = 0; S < (1 << n); S++) {
			(ans += h[S] * g[S]) %= mod;
		}
		printf("%lld\n", (ans + mod) % mod);
	}
	return 0;
}
```

可通过此题的代码。

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
const int N = 20;
struct Milthm {
	ll a, b;
	Milthm() {
	}
	Milthm(ll x) {
		x %= mod;
		if (x > 0) {
			a = x;
			b = 0;
		} else {
			a = 1;
			b = 1;
		}
	}
	Milthm(ll a_, ll b_) {
		a = a_;
		b = b_;
	}
	ll real_val() {
		return b == 0 ? a : 0;
	}
};
Milthm operator + (const Milthm & a, const Milthm & b) {
	if (a.b < b.b) {
		return a;
	}
	if (a.b > b.b) {
		return b;
	}
	ll x = (a.a + b.a) % mod;
	if (x == 0) {
		return Milthm(1, a.b + 1);
	} else {
		return Milthm(x, a.b);
	}
}
Milthm & operator += (Milthm & a, const Milthm & b) {
	return a = a + b;
}
Milthm operator - (const Milthm & a) {
	return Milthm(mod - a.a, a.b);
}
Milthm & operator -= (Milthm & a, const Milthm & b) {
	return a += -b;
}
Milthm operator * (const Milthm & a, const Milthm & b) {
	return Milthm(a.a * b.a % mod, a.b + b.b);
}
Milthm & operator *= (Milthm & a, const Milthm & b) {
	return a = a * b;
}
int n;
ll a[1 << N];
ll qpow(ll a, ll b) {
	if (a < 0) {
		a += mod;
	}
	if (b < 0) {
		b += mod - 1;
	}
    ll ans = 1;
    while (b > 0) {
        if (b % 2 == 1) {
            (ans *= a) %= mod;
        }
        (a *= a) %= mod;
        b /= 2;
    }
    return ans;
}
Milthm inv(Milthm x) {
    return Milthm(qpow(x.a, mod - 2), -x.b);
}
int read() {
	int x = 0, ch;
	do {
		ch = getchar();
	} while ('0' > ch);
	do {
		x = x * 10 + ch - 48;
		ch = getchar();
	} while ('0' <= ch);
	return x;
}
Milthm f[1 << N], g[1 << N], h[1 << N];
int main() {
	// freopen("in.txt", "r", stdin);
	read();
	int t = read();
	for (; t != 0; t--) {
		n = read();
		for (int i = 0; i < (1 << n); i++) {
			a[i] = read();
			f[i] = Milthm(a[i] + 1);
			g[i] = Milthm(2 * a[i] + 1) * inv(a[i] + 1) * inv(a[i] + 1);
		}
		for (int i = 0; i < n; i++) {
			for (int S = 0; S < (1 << n); S++) {
				if (((S >> i) & 1) == 0) {
					f[S] *= f[S | (1 << i)];
					g[S] *= g[S | (1 << i)];
				}
			}
		}
		for (int S = 0; S < (1 << n); S++) {
			f[S] *= qpow(-2, __builtin_popcount(S));
			g[S] *= qpow(2, -__builtin_popcount(S));
		}
		for (int i = 0; i < n; i++) {
			for (int S = 0; S < (1 << n); S++) {
				if (((S >> i) & 1) == 0) {
					f[S | (1 << i)] += f[S];
				}
			}
		}
		for (int S = 0; S < (1 << n); S++) {
			h[S] = f[S] * f[S];
		}
		for (int i = 0; i < n; i++) {
			for (int S = 0; S < (1 << n); S++) {
				if (((S >> i) & 1) == 0) {
					h[S | (1 << i)] -= h[S];
				}
			}
		}
		Milthm ans = 0;
		for (int S = 0; S < (1 << n); S++) {
			ans += h[S] * g[S];
		}
		printf("%lld\n", ans.real_val());
	}
	return 0;
}
```

---

## 作者：lsj2009 (赞：15)

写出答案式子：

$$
\sum\limits_P \sum\limits_Q [f(P)=f(Q)][P\cap Q=\emptyset]\prod\limits_{i\in P\cup Q} a_i
$$

对 $[f(P)=f(Q)]$ 限制进行容斥：即对于每一位 $x$ 应有 $[x\in f(P)]=[x\in f(Q)]$ 成立，记 $P_x=[x\in f(P)],Q_x=[x\in f(Q)]$，

则：

$$
\begin{aligned}
[f(P)=f(Q)] & = \prod\limits_{0\le i<n} [P_i=Q_i]\\
& = \prod\limits_{0\le i<n} ((P_i\wedge Q_i)+(\neg P_i\wedge\neg Q_i))\\
& = \prod\limits_{0\le i<n} (1-(\neg P_i\wedge Q_i)-(P_i\wedge\neg Q_i))\\
& = \prod\limits_{0\le i<n} (1-(Q_i-P_i\wedge Q_i)-(P_i-P_i\wedge Q_i))\\
& = \prod\limits_{0\le i<n} (2P_i\wedge Q_i-P_i-Q_i+1)\\
& = \sum\limits_{A\subseteq f(P)\cap f(Q)}\sum\limits_{B\subseteq f(P),A\cap B=\emptyset}
\sum\limits_{C\subseteq f(Q),A\cap C=\emptyset,B\cap C=\emptyset} 2^{|A|}(-1)^{|B|+|C|}\\
& = \sum\limits_{S\subseteq f(P)} \sum\limits_{T\subseteq f(Q)} 2^{|S\cap T|}(-1)^{(|S|-|S\cap T|)+(|T|-|S\cap T|)}\\
& = \sum\limits_{S\subseteq f(P)} \sum\limits_{T\subseteq f(Q)} 2^{|S\cap T|}(-1)^{|S|+|T|}
\end{aligned}
$$

其中倒数第二步为枚举 $S=B\cup A,T=C\cup A$。从而答案为：

$$
\begin{aligned}
& \sum\limits_P\sum\limits_Q[P\cap Q=\emptyset]\sum\limits_{S\subseteq f(P)}\sum\limits_{T\subseteq f(Q)}(-1)^{|S|+|T|}2^{||S\cap T|}\prod\limits_{i\in P\cup Q} a_i\\
= & \sum\limits_S\sum\limits_T(-1)^{|S|+|T|}2^{|S\cap T|}\sum\limits_{S\subseteq f(P)}\sum\limits_{T\subseteq f(Q)}[P\cap Q=\emptyset]\prod\limits_{i\in P\cup Q} a_i
\end{aligned}
$$

考察 $P,Q$ 可以取到的集合：$P,Q$ 分别为所有是 $S,T$ 超集的数构成集合（分别记为 $A_S,A_T$）的子集；枚举 $R=P\cup Q\subseteq A_S\cup A_T$，则对于 $i\in R$，若 $i\in A_S\cap A_T$ 则可将 $i$ 任意分配 $P/Q$ 否则 $i$ 属于 $P/Q$ 是确定的，即答案为：

$$
\begin{aligned}
& \sum\limits_S\sum\limits_T(-1)^{|S|+|T|}2^{|S\cap T|}
\sum\limits_{R\subseteq A_S\cup A_T}\prod\limits_{i\in R} (1+[i\in A_S\cap A_T])a_i\\
= & \sum\limits_S\sum\limits_T(-1)^{|S|+|T|}2^{|S\cap T|}
\left(\sum\limits_{R_1\subseteq A_S\cap A_T} \prod\limits_{i\in R_1} 2a_i\right)
\left(\sum\limits_{R_2\subseteq A_S\cup A_T\setminus(A_S\cap A_T)} \prod\limits_{i\in R_2} a_i\right)\\
= & \sum\limits_S\sum\limits_T(-1)^{|S|+|T|}2^{|S\cap T|}
\left(\prod\limits_{i\subseteq A_S\cap A_T} (2a_i+1)\right)
\left(\prod\limits_{i\subseteq A_S\cup A_T\setminus(A_S\cap A_T)} (a_i+1)\right)
\end{aligned}
$$

令 $f_S=\prod\limits_{S\subseteq T} (a_T+1),g_S=\prod\limits_{S\subseteq T} (2a_T+1)$，则答案为：

$$
\sum\limits_S\sum\limits_T(-1)^{|S|+|T|}2^{|S\cap T|}f_Sf_T\frac{g_{S\cup T}}{(f_{S\cup T})^2}
$$

$f_S$ 和 $g_S$ 均可以高维后缀积计算，复杂度 $\mathcal{O}(n2^n)$，则此时暴力算上面的式子就可以得到一个 $\mathcal{O}(4^n)$ 的做法；然而存在问题：会出现 $/0$ 的情况。处理很简单：记录 $f_S,g_S=a\cdot0^k$ 即可，乘除均有良定义。

注意到 $|S\cap T|+|S\cup T|=|S|+|T|$，将答案按 $S/T/S\cup T$ 整理得：

$$
\sum\limits_S\sum\limits_T\left((-2)^{|S|}f_S\right)\left((-2)^{|T|}f_T\right)\frac{g_{S\cup T}}{(f_{S\cup T})^22^{|S\cup T|}}
$$

令 $\hat{f}_S=(-2)^{|S|}f_S$，得 $h=\hat{f}\times \hat{f}$，则答案为：（此处乘法是 or 卷积）

$$
\sum\limits_S h_S\frac{g_S}{f_S^22^{|S|}}
$$

复杂度 $\mathcal{O}(n2^n)$。

仍然存在问题：$\hat{f}$ 与 $f$ 一样是 $a\cdot 0^k$ 形式保存，而 $a_1\cdot 0^{k_1}$ 和 $a_2\cdot 0^{k_2}$ 加减法若 $k_1\ne k_2$ 是没有良定义的（除非维护关于 $0$ 的多项式），但是发现最终非最低位在除以 $f_S^2$ 后 $0$ 的次数必然 $>0$，从而可以直接舍去，即保留 $0$ 次数较低的项即可。

---

## 作者：流水行船CCD (赞：11)

还是很好的一道数数题。

因为洛谷和博客园的公式中的汉字渲染都不是很美观，直接挂图片了：

## 思路

![](https://cdn.luogu.com.cn/upload/image_hosting/9lt6wf39.png)

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define clr(name, n) memset(name, 0, (n + 1) * sizeof(name[0]))
#define mem(name, v, n) memset(name, v, (n + 1) * sizeof(name[0]))
#define ld cin
#define jyt cout
// #define int long long
constexpr int N = (1 << 20) + 7;
constexpr int P = 998244353;
namespace JoKing {
    struct poly {
        ll A, B;
        poly() {A = B = 0;}
        poly(ll X, ll Y) {A = X, B = Y;}
        inline poly lxl() {return poly(P - A, B);}
        friend poly operator + (poly X, poly Y) {return X.B == Y.B ? poly((X.A + Y.A + P) % P, X.B) : (X.B < Y.B ? X : Y);}
        friend poly operator - (poly X, poly Y) {return X.B == Y.B ? poly((X.A - Y.A + P) % P, X.B) : (X.B < Y.B ? X : Y.lxl());}
        friend poly operator * (poly X, poly Y) {return poly(X.A * Y.A % P, X.B + Y.B);}
    };
    inline long long qpow(long long x, long long y) {long long R = 1; for (; y; (x *= x) %= P, y >>= 1ll) if (y & 1ll) (R *= x) %= P; return R;}
    int n, m, a[N]; poly alpha[N], beta[N];
    inline void FWT(poly* a, ll op) {
        for (int len = 2, half = 1; len <= m; len <<= 1, half <<= 1)
            for (int l = 0; l < m; l += len)
                for (int k = 0; k < half; ++k)
                    a[l + half + k] = op ? a[l + half + k] + a[l + k] : a[l + half + k] - a[l + k];
    }
    signed main() { ll Ans = 0;
        ld >> n, m = (1 << n);
        REP(i, 0, m - 1) ld >> a[i];
        REP(i, 0, m - 1) alpha[i] = (a[i] == 998244352 ? poly(1, 1) : poly(a[i] + 1, 0));
        REP(i, 0, m - 1) {
            if (a[i] == 998244352) beta[i] = poly((a[i] * 2 + 1) % P, -2);
            else if (a[i] == 499122176) beta[i] = poly(qpow(a[i] + 1, P - 2) * qpow(a[i] + 1, P - 2) % P, 1);
            else beta[i] = poly(qpow(a[i] + 1, P - 2) * qpow(a[i] + 1, P - 2) % P * (a[i] * 2 + 1) % P, 0);
        }
        REP(j, 0, n - 1) PER(i, m - 1, 0) if (!(i & (1 << j))) alpha[i] = alpha[i] * alpha[i | (1 << j)];
        REP(j, 0, n - 1) PER(i, m - 1, 0)  if (!(i & (1 << j))) beta[i] = beta[i] * beta[i | (1 << j)];
        REP(i, 0, m - 1) (alpha[i].A *= qpow(P - 2, __builtin_popcount(i))) %= P, (beta[i].A *= qpow(qpow(2, __builtin_popcount(i)), P - 2)) %= P;
        FWT(alpha, 1); REP(i, 0, m - 1) alpha[i] = alpha[i] * alpha[i]; FWT(alpha, 0);
        REP(i, 0, m - 1) beta[i] = beta[i] * alpha[i], (Ans += !beta[i].B ? beta[i].A : 0ll) %= P;
        jyt << Ans << '\n';
        return 0;
    }
}
signed main() {
#ifdef WYY
    freopen("files/code.in", "r", stdin);
    freopen("files/code.out", "w", stdout);
    freopen("files/code.err", "w", stderr);
#endif
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int Opt = 0, T = 0; ld >> Opt >> T;
    while (T--) JoKing::main();
    return 0;
}
``

---

## 作者：WorldMachine (赞：10)

好难啊。

设 $N=\bigcup\limits_{i=0}^{n-1}\{i\}$，$\text{val}(S)=\prod\limits_{i\in S}a_i$，由于 $P\cap Q=\varnothing$，故 $\text{val}(P\cup Q)=\text{val}(P)\text{val}(Q)$。先把贡献拆到每个 $f(P)$ 上：
$$
\begin{aligned}
\text{answer}&=\sum_{S\subseteq N}\sum_{\substack{P\subseteq2^N\\f(P)=S}}\sum_{\substack{Q\subseteq2^N\\f(Q)=S\\P\cap Q=\varnothing}}\text{val}(P\cup Q)\\
&=\sum_{S\subseteq N}\sum_{\substack{P\subseteq2^N\\f(P)=S}}\text{val}(P)\sum_{\substack{Q\subseteq2^N\\f(Q)=S\\P\cap Q=\varnothing}}\text{val}(Q)
\end{aligned}
$$
元素的交集恰好为 $S$ 不太好做，为了方便写成 FWT 需要的形式，考虑使用超集反演：
$$
\sum_{\substack{P\subseteq2^N\\f(P)=S}}\text{val}(P)=\sum_{S\subseteq T\subseteq N}(-1)^{|T|-|S|}\sum_{\substack{P\subseteq 2^N\\T\subseteq f(P)}}\text{val}(P)
$$
代入原式：
$$
\begin{aligned}
\text{answer}&=\sum_{S\subseteq N}\sum_{S\subseteq T_P\subseteq N}(-1)^{|T_P|-|S|}\sum_{\substack{P\subseteq 2^N\\T_P\subseteq f(P)}}\text{val}(P)\sum_{S\subseteq T_Q\subseteq N}(-1)^{|T_Q|-|S|}\sum_{\substack{Q\subseteq 2^N\\T_Q\subseteq f(Q)\\P\cap Q=\varnothing}}\text{val}(Q)
\end{aligned}
$$
发现两个 $(-1)^{|S|}$ 抵消掉了，剩下的就是 $(-1)^{|T_P|+|T_Q|}$。然后交换求和符号，改为最外层枚举 $T_P,T_Q$：
$$
\begin{aligned}
\text{answer}&=\sum_{T_P,T_Q\subseteq N}(-1)^{|T_P|+|T_Q|}\sum_{S\subseteq T_P\cap T_Q}\sum_{\substack{P\subseteq 2^N\\T_P\subseteq f(P)}}\text{val}(P)\sum_{\substack{Q\subseteq 2^N\\T_Q\subseteq f(Q)\\P\cap Q=\varnothing}}\text{val}(Q)
\end{aligned}
$$
这时候 $S$ 就被架空了，直接就是 $2^{|T_P\cap T_Q|}$，现在柿子变成了这样：
$$
\begin{aligned}
\text{answer}&=\sum_{T_P,T_Q\subseteq N}(-1)^{|T_P|+|T_Q|}2^{|T_P\cap T_Q|}\sum_{\substack{P\subseteq 2^N\\T_P\subseteq f(P)}}\text{val}(P)\sum_{\substack{Q\subseteq 2^N\\T_Q\subseteq f(Q)\\P\cap Q=\varnothing}}\text{val}(Q)
\end{aligned}
$$
考虑后面那一坨东西是在干什么，设 $F_P$ 为 $T_P$ 的所有父集构成的集合，同样定义 $F_Q$。那么原求和条件就变成了 $P\subseteq F_P$ 和 $Q\subseteq F_Q$。

考虑每个 $R\subseteq N$ 对答案的贡献。可以发现若 $R\in F_P\cap F_Q$，则 $R$ 可以选择在 $P$ 或 $Q$ 中，也可以不选，故贡献为 $2a_R+1$；否则若 $R\in F_P\Delta F_Q$（$\Delta$ 表示集合对称差），可以选择在 $P$ 或 $Q$ 的其中之一，也可以不选，故贡献为 $a_R+1$；否则不能在 $P$ 或 $Q$ 中，没有贡献（贡献为 $1$）。

因此原式化为：
$$
\begin{aligned}
\text{answer}&=\sum_{T_P,T_Q\subseteq N}(-1)^{|T_P|+|T_Q|}2^{|T_P\cap T_Q|}\prod_{R\in F_P\cap F_Q}(2a_R+1)\prod_{R\in F_P\Delta F_Q}(a_R+1)
\end{aligned}
$$
不妨设 $A_S=\prod\limits_{S\subseteq T}(2a_T+1)$，$B_S=\prod\limits_{S\subseteq T}(a_T+1)$，考虑用 $A,B$ 来表示后面这一坨东西，把对称差拆开来，由于 $F_P\cap F_Q$ 就是 $T_P\cup T_Q$ 的全体父集，可以发现其实就是 $\dfrac{A_{T_P\cup T_Q}B_{T_P}B_{T_Q}}{B^2_{T_P\cup T_Q}}$。

进一步地，观察所求式的结构，不难想到设 $C_S=\dfrac{A_S}{2^{|S|}B^2_S}$，$D_S=(-1)^{|S|}2^{|S|}B_S$，原式化为：
$$
\begin{aligned}
\text{answer}&=\sum_{T_P,T_Q\subseteq N}C_{T_P\cup T_Q}D_{T_P}D_{T_Q}\\
&=\sum_{T\subseteq N}C_T\sum_{T_P\cup T_Q=T}D_{T_P}D_{T_Q}
\end{aligned}
$$
这是一个 OR 卷积的形式，直接上 FWT 即可。

但这样做有一个问题：分母上出现了 $B$，而 $B$ 的定义中出现了 $a_R+1$，当 $a_R=998244352$ 时会出现除数为 $0$ 的情况，但此时答案又是存在的。

因此需要记录每个数乘/除了多少个 $0$，即以 $x\times 0^z$ 的形式记录，并定义其运算，最后得到 $0^0$ 的部分的和就是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define gc getchar_unlocked()
il int rd() { int x = 0; char c = 0; while (c < '0' || c > '9') c = gc; while (c >= '0' && c <= '9') x = x * 10 - '0' + c, c = gc; return x; }
typedef long long ll;
const int N = 1 << 20 | 5, p = 998244353, inv2 = p + 1 >> 1;
int task_id, T, ppc[N], invpw2[21], _n, n, a[N];
int qpow(int a, int b) { int c = 1; while (b) { if (b & 1) c = (ll)c * a % p; a = (ll)a * a % p, b >>= 1; } return c; }
struct num { int x, z; num(int a = 0) { if (a) x = a, z = 0; else x = 1, z = 1;  } num(int x, int z): x(x), z(z) {} } A[N], B[N], invB[N], C[N], D[N], E[N];
il num operator+(num a, num b) { return a.z == b.z ? num((a.x + b.x) % p, a.z) : (a.z < b.z ? a : b); }
il num operator-(num a, num b) { return a.z == b.z ? num((a.x - b.x + p) % p, a.z) : (a.z < b.z ? a : num((p - b.x) % p, b.z)); }
il num operator*(num a, num b) { return num((ll)a.x * b.x % p, a.z + b.z); }
il num inv(num a) { return num(qpow(a.x, p - 2), -a.z); }
il num operator/(num a, num b) { return a * inv(b); }
void sufmul(num a[]) {
	for (int i = 0; i < _n; i++) {
		for (int j = 0; j < n; j++) if (!(j >> i & 1)) a[j] = a[j] * a[j ^ 1 << i];
	}
}
void FWT(num a[]) {
	for (int i = 0; i < _n; i++) {
		for (int j = 0; j < n; j++) if (j >> i & 1) a[j] = a[j] + a[j ^ 1 << i];
	}
}
void iFWT(num a[]) {
	for (int i = _n - 1; ~i; i--) {
		for (int j = 0; j < n; j++) if (j >> i & 1) a[j] = a[j] - a[j ^ 1 << i];
	}
}
void solve() {
	_n = rd(), n = 1 << _n;
	for (int i = 0; i < n; i++) a[i] = rd(), A[i] = num((a[i] << 1 | 1) % p), B[i] = num((a[i] + 1) % p);
	sufmul(A), sufmul(B);
	for (int i = 0; i < n; i++) invB[i] = inv(B[i]);
	for (int i = 0; i < n; i++) C[i] = A[i] * invB[i] * invB[i] * invpw2[ppc[i]];
	for (int i = 0; i < n; i++) D[i] = B[i] * (1 << ppc[i]) * (ppc[i] & 1 ? p - 1 : 1);
	FWT(D);
	for (int i = 0; i < n; i++) E[i] = D[i] * D[i];
	iFWT(E);
	int ans = 0;
	for (int i = 0; i < n; i++) {
		num x = C[i] * E[i];
		if (!x.z) ans = (ans + x.x) % p;
	}
	cout << ans << '\n';
}
int main() {
	// freopen("set.in", "r", stdin), freopen("set.out", "w", stdout);
	for (int i = 1; i < N; i++) ppc[i] = ppc[i ^ (i & -i)] + 1;
	invpw2[0] = 1; for (int i = 1; i <= 20; i++) invpw2[i] = (ll)invpw2[i - 1] * inv2 % p;
	task_id = rd(), T = rd(); while (T--) solve();
}
```

---

## 作者：Petit_Souris (赞：9)

场上约 1h 通过此题，退役之战的高光时刻。一直训练的计数水平确实在这题上表现出来了，只可惜这 day 2 没有给我乘胜追击的机会，翻盘失败。

考虑枚举 $S$，计算 $f(P) = f(Q) = S$ 的方案数。直观的想法是进行容斥：枚举集合 $U\supseteq S, V \supseteq S$，钦定 $f(P)$ 中所有在 $U$ 中的位为 $1$，$f(Q)$ 中所有在 $V$ 中的位为 $1$。

这样一个 $(U, V)$ 对 $S$ 的贡献系数为 $(-1)^{\mathrm{pop(U) + pop(V) - 2pop(S)}}$。$(U, V)$ 的方案数容易计算：考虑所有的 $i$，如果 $i$ 同时是 $U, V$ 的超集，那么方案数为 $1 + 2a_i$；如果是 $U, V$ 其中一个的超集，方案数为 $1 + a_i$；否则方案数为 $1$。把所有 $i$ 的方案数乘起来即可。

这样已经可以做到 $\mathcal O(8 ^ n)$ 了。

优化的想法很自然：考虑交换枚举顺序，先枚举 $U, V$，这时候可能产生贡献的 $S$ 必须是 $U\ \mathrm{and}\ V$ 的子集。现在和 $S$ 有关的只有容斥系数，这个数只和 $\mathrm{pop}(U\ \mathrm{and}\ V)$ 有关。

求 $(U, V)$ 的方案数可以通过研究性质 B 想到一个方法：记 $f_S$ 表示 $S$ 所有超集的 $(1 + a_i)$ 的乘积，$g_S$ 表示 $S$ 所有超集的 $(1 + 2a_i)$ 的乘积。显然权值为 $\frac{f_Uf_V}{g_{U \ \mathrm{or}\ V}}$。因此容易优化到 $\mathcal O(4 ^ n)$。进一步地，$\mathrm{pop}(U\ \mathrm{and}\ V) = \mathrm{pop}(U) + \mathrm{pop}(V) - \mathrm{pop}(U \ \mathrm{or} \ V)$，因此容易用 or - FWT 优化至 $\mathcal O(2 ^ nn)$。

最后需要考虑一下 $a_i = 998244352$ 如何处理。考虑扩域，对每个值记录二元组 $(k, v)$ 表示乘上了 $k$ 个 $0$，显然对于每个 $S$ 只有最小的 $k$ 有效。容易发现 FWT 可以进行，因为具有可加性。而 IFWT 需要减法，看似会出现问题，但是实际上容易分析出正确性，因为如果 $(k_1, v_1)$ 减 $(k_2, v_2)$ 时，一定有 $k_2 \ge k_1$，且 $k_2>k_1$ 时不产生贡献。因此正确性得证，问题在 $\mathcal O(2 ^nn)$ 时间复杂度内完美解决。

复现的代码：

```cpp
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define ALL(v) (v).begin(), (v).end()
#define pii pair<ll, ll>
#define rep(i, a, b) for(ll i = (a); i <= (b); ++i)
#define per(i, a, b) for(ll i = (a); i >= (b); --i)
#define pb push_back
bool Mbe;
ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
void write(ll x) {
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
const ll Mod = 998244353;
ll n, a[(1 << 20) + 9];
ll pw(ll x, ll p) {
    ll res = 1;
    while(p) {
        if(p & 1) res = res * x % Mod;
        x = x * x % Mod, p >>= 1;
    }
    return res;
}
ll Add(ll x, ll y) {
    return ((x += y) >= Mod) ? (x - Mod) : (x);
}
ll Sub(ll x, ll y) {
    return ((x -= y) < 0) ? (x + Mod) : (x);
}
pii operator + (const pii &a, const pii &b) {
    if(a.first ^ b.first) return min(a, b);
    return {a.first, Add(a.second, b.second)};
}
pii operator - (const pii &a, const pii &b) {
    if(a.first ^ b.first) return a;
    return {a.first, Sub(a.second, b.second)};
}
pii operator * (const pii &a, const pii &b) {
    return {a.first + b.first, a.second * b.second % Mod};
}
pii f[(1 << 20) + 5], g[(1 << 20) + 5];
ll pw2[25], ipw2[25];
void FWT(pii *f) {
    for(ll i = 1; i < (1 << n); i <<= 1) {
        for(ll j = 0; j < (1 << n); j += (i << 1)) {
            rep(k, 0, i - 1) f[j + k + i] = f[j + k + i] + f[j + k];
        }
    }
}
void IFWT(pii *f) {
    for(ll i = 1; i < (1 << n); i <<= 1) {
        for(ll j = 0; j < (1 << n); j += (i << 1)) {
            rep(k, 0, i - 1) f[j + k + i] = f[j + k + i] - f[j + k];
        }
    }
}
ll pc(ll n) {
    return __builtin_popcount(n);
}
void solve() {
    n = read();
    rep(i, 0, (1 << n) - 1) a[i] = read();
    rep(i, 0, (1 << n) - 1) {
        if(a[i] != Mod - 1) {
            f[i] = {0, (1 + a[i]) % Mod};
            g[i] = {0, (1 + a[i] + a[i]) % Mod * pw((1 + a[i]) * (1 + a[i]) % Mod, Mod - 2) % Mod};
        }
        else {
            f[i] = {1, 1};
            g[i] = {2, Mod - 1};
        }
    }
    for(ll i = 1; i < (1 << n); i <<= 1) {
        for(ll j = 0; j < (1 << n); j += (i << 1)) {
            rep(k, 0, i - 1) {
                f[j + k] = f[j + k] * f[j + k + i];
                g[j + k] = g[j + k] * g[j + k + i];
            }
        }
    }
    rep(i, 0, (1 << n) - 1) {
        if(pc(i) & 1) f[i].second = Mod - f[i].second;
        f[i].second = f[i].second * pw2[pc(i)] % Mod;
    }
    FWT(f);
    rep(i, 0, (1 << n) - 1) f[i] = f[i] * f[i];
    IFWT(f);
    ll ans = 0;
    rep(i, 0, (1 << n) - 1) {
        if(f[i].first ^ g[i].first) continue;
        ans = (ans + f[i].second * g[i].second % Mod * ipw2[pc(i)]) % Mod;
    }
    write(ans), putchar('\n');
}
bool Med;
int main() {
    cerr << fabs(&Med - &Mbe) / 1048576.0 << "MB\n";
    ll T = read(); T = read();
    pw2[0] = 1;
    rep(i, 1, 22) pw2[i] = pw2[i - 1] * 2 % Mod;
    rep(i, 0, 22) ipw2[i] = pw(pw2[i], Mod - 2);
    while(T--) solve();
    cerr << "\n" << clock() * 1.0 / CLOCKS_PER_SEC * 1000 << "ms\n";
    return 0;
}
```

---

## 作者：luanyanjia (赞：8)

我虽然没能场切此题，但是也获得了很高的分数，算是拯救了我整个 Day 2 了。

首先有 $O(8^n)$ 的 DP。设 $f_{i,j,k}$，表示前 $i$ 个数的情况确定了，使得 $f(P) = j$，$f(Q) = k$ 的方案数。有如下转移：

$$ f_{i,j,k} \times a_i \rightarrow f_{i+1,j \cap (i+1),k}$$
$$ f_{i,j,k} \times a_i \rightarrow f_{i+1,j,k \cap (i+1)}$$
$$ f_{i,j,k} \rightarrow f_{i+1,j,k}$$

到此为止就可以集合幂级数暴做了。

每次转移就是 $\operatorname{and}$ 卷积。考虑 FMT 之后的 $[x^j y^k]$。每次相当于点乘 FMT 后的 $x^i + y^i + 1$。也就是乘上 $a_i \times ([j \subseteq i] + [k \subseteq i]) + 1$。这样下来我们可以轻松算出一个 $[x^j y^k]$ 处的值 $g_{j,k}$。

设：

$$ ss_i = \prod\limits_{i \subseteq j} (2a_j + 1),s_i = \prod\limits_{i \subseteq j} (a_j + 1)$$

那么有：

$$ g_{j,k} = \dfrac{s_j s_k ss_{j \cup k}}{s_{j \cup k} ^ 2} $$

意思就是同时是 $j,k$ 超集的需要乘 $2a_i + 1$，只是一个的超集的要乘 $a_i + 1$。

可能会除以 $0$，只需要记录 $c_i$ 表示 $i$ 超集中 $0$ 因子的数量，然后判断是否有 $c_j = c_k = c_{j \cup k}$ 即可。

至此我们可以 $O(2^n n)$ 预处理，$O(1)$ 查询 $g_{j,k}$ 一个位置的值。全部查一遍再 IFMT 回来需要 $O(4^n n)$ 的复杂度。可以获得 $36$ 分。

我们发现最后其实只用了 $f_{i,i}$ 的值，考虑把 IFMT 拆开式子：

$$
\begin{align*}
f_{i,i} & = \sum\limits_{i \subseteq j,i \subseteq k} (-1)^{\left|j-i\right| + \left|k-i\right|}g_{j,k}  \\

& = \sum\limits_{i \subseteq j,i \subseteq k}(-1)^{\left|j\right|+\left|k\right|}g_{j,k} 
\end{align*}
$$

这相当于对于 $g_{j,k}$，有 $2^{\left|{j \cap k}\right|}$ 个 $i$ 统计到了他。因此答案就是：

$$
\begin{align*}
ans & = \sum\limits_{j,k} (-1)^{\left|j\right|+\left|k\right|}2^{\left|{j \cap k}\right|}g_{j,k}\\
& = \sum\limits_{j,k} (-2)^{\left|j\right|+\left|k\right|}2^{- \left|{j \cup k}\right|} \dfrac{s_j s_k ss_{j \cup k}}{s_{j \cup k} ^ 2}
\end{align*}
$$


注意这里用到了 $\left|j\cap k\right| = \left|j\right| + \left|k\right| - \left|j \cup k\right|$。

这已经变成了或卷积的形式！不考虑 $a_i = mod - 1$ 的情况，可以直接做到 $O(2^n n)$，拼上暴力获得 $68$ 分。

我赛时的想法就止步于此。$a_i = mod - 1$ 时我们该怎么办呢？

一个想法是根据上面暴力的结论，只有 $c_i$ 相同的才能互相转移，因此按照 $c_i$ 分类分别跑 FMT。但是这个复杂度是错的。A 性质也只能过一个点。

但是 $c_i$ 还有一个性质就是如果 $i \subseteq j$，那么 $c_i > c_j$，而 FWT 时我们只会和自己的子集进行运算。所以 $i$ 存在一个子集 $j$ 满足 $c_j > c_i$ 时 $j$ 的子集 $k$ 也一定满足 $c_k > c_i$ 所以 $j$ 的一切信息对于 $i$ 就没用了。因此我们只需要在 $c_j = c_i$ 的时候才转移即可。类似于其他题解说的只保留低次项。

可以获得 $100$ 分。

$68$ 代码加上一行就可以过。生气了。

### 代码

```cpp
inline void Add(int &a,int b){(a+=b)>=mod?a-=mod:1;}
inline void FWT(int *a,int n,int x){
	for(int t=2,k=1;t<=n;t<<=1,k<<=1)
		for(int i=0;i<n;i+=t)
			for(int j=0;j<k;j++){
                if(c[i+j]==c[i+j+k])Add(a[i+j+k],1ll*a[i+j]*x%mod);
            }
}
inline void Solve(){
    rd(n);
    V=(1<<n);
    for(int i=0;i<V;i++)rd(a[i]);
    for(int i=0;i<V;i++){
        s[i]=a[i]+1;c[i]=0;
        ss[i]=(2*a[i]+1)%mod;
        if(a[i]==mod-1)s[i]=c[i]=1;
    }
    for(int t=0;t<n;t++){
        for(int i=0;i<V;i++){
            if(!(i>>t&1)){
                s[i]=1ll*s[i]*s[i^(1<<t)]%mod;
                ss[i]=1ll*ss[i]*ss[i^(1<<t)]%mod;
                c[i]+=c[i^(1<<t)];
            }
        }
    }
    for(int i=0;i<V;i++)ss[i]=1ll*ss[i]*KSM(s[i],(mod-2)*2)%mod;
    for(int i=0;i<V;i++)f[i]=1ll*s[i]*KSM(mod-2,__builtin_popcount(i))%mod;
    FWT(f,V,1);
    for(int i=0;i<V;i++)f[i]=1ll*f[i]*f[i]%mod;
    FWT(f,V,mod-1);
    int res=0;
    for(int i=0;i<V;i++){
        Add(res,1ll*f[i]*ss[i]%mod*KSM((mod+1)/2,__builtin_popcount(i))%mod);
    }
    printf("%d\n",res);
}
```

---

## 作者：watermoon (赞：6)

退役好久没做题所以也没更新. 最近放假在家摆烂摸鱼, 刷 b 站看到某位主播 vp 今年 NOI, 发现还有这种魔怔数数题, 就来做着玩玩. 训 AtCoder 取模计数题的人会有好报的. 😊

给定正整数 $n$ 和序列 $a_0,\ldots,a_{2^n-1}\in\mathbb F_p$, 对 $S\subseteq [0,2^n)\cap\mathbb Z$ 定义 $\mathrm{And}(S)$ 是 $S$ 中所有数的按位与, 要求:
$$\sum_{S,T\subseteq[0,2^n)}\mathbf 1\{S\cap T=\varnothing\}\cdot\mathbf 1\{\mathrm{And}(S)=\mathrm{And}(T)\}\prod_{i\in S\cup T}a_i.$$
数据范围: $n\le 20$ 且 $p=998\,244\,353$, 其中部分测试点满足 $a_i\ne -1$.

考虑对 $\mathbf 1\{\mathrm{And}(S)=\mathrm{And}(T)\}$ 容斥: 枚举 $x,y\in[0,2^n)$, 设 $S_x$ 表示包含 $x$ 的数的集合, 条件 $x\subseteq\mathrm{And}(S)$ 且 $y\subseteq\mathrm{And}(T)$ 等价于 $S\subseteq S_x$ 且 $T\subseteq S_y$, 又因为
$$\mathbf 1\{\mathrm{And}(S)=\mathrm{And}(T)\}=\sum_{x\subseteq\mathrm{And}(S)}\sum_{y\subseteq\mathrm{And}(T)}(-1)^{\mathrm{pc}(x)+\mathrm{pc}(y)}\cdot 2^{\mathrm{pc}(x\&y)},$$
代回原式即得容斥系数是 $(-1)^{\mathrm{pc}(x)+\mathrm{pc}(y)}\cdot 2^{\mathrm{pc}(x\&y)}$, 贡献是 $\sum_{S\subseteq S_x}\sum_{T\subseteq S_y}\mathbf 1\{S\cap T=\varnothing\}\prod_{i\in S\cup T}a_i$.

> 这里 $\mathrm{pc}(x)$ 表示 $x$ 的二进制表示中 1 的数量. 容斥系数怎么算的? 将条件表示为每个二进制位的 "相等" 条件相乘, 权值 $((1,0),(0,1))$ 作差分得到 $((1,-1),(-1,2))$, 按分配律全部展开就好啦.

贡献式里每个元素的方案独立: $S_x\cap S_y=S_{x|y}$ 的元素可以放入 $S$ 或 $T$ 或不放, 方案数为 $1+2a_i$; 其他 $(S_x\cup S_y)\setminus S_{x|y}$ 的元素则是 $1+a_i$.

又因为 $\mathrm{pc}(x|y)=\mathrm{pc}(x)+\mathrm{pc}(y)-\mathrm{pc}(x\&y)$, 我们将其化为 OR 卷积的形式: 设 $s_x:=\prod_{i\supseteq x}(1+a_i)$, $t_x:=\prod_{i\supseteq x}\frac{1+2a_i}{(1+a_i)^2}$, 答案是 $(-2)^{\mathrm{pc}(x)}s_x$ 卷积自己, 逐项乘上 $2^{-\mathrm{pc}(x)}t_x$ 再求和.

如果有 $a_i=-1$ 咋办呢? 我们要把 $s_x$ 和 $s_y$ 中属于 $t_{x|y}$ 的 0 因子剔除. 考虑 FMT 的过程, 什么情况下 $s_xs_y$ 的卷积项会贡献到 $z$ 的位置? 只有 $z$ 包含 $x$ 和 $y$ 的情况. 此时 $t_z$ 的分母必定整除 $s_xs_y$, 即求和的每一项都被 $t_z$ 的分母整除. 所以只需要维护 0 次数最低的一项, 就算有 $a+(-a)$ 相消也不用关心更高次项的系数, 肯定是用不到的.

随便看了一下其他题解, 感觉这部分讲得比较模糊, 所以在这里也传了一份.

总结一下, 用后缀和/积计算 $s_x$ 和 $t_x$ 的 0 次数和系数, 再跑一个 OR 卷积就完成了, 时间复杂度 $O(n2^n)$.

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pc __builtin_popcount
typedef std::pair<int, int> PII; // coefficient and degree of 0
typedef long long LL;

const int mod = 998244353;
int qmo(int x) { return x + (x >> 31 & mod); }
int ksm(int a, int b) {
  int res = 1;
  for (; b; b >>= 1, a = (LL)a * a % mod)
    if (b & 1) res = (LL)res * a % mod;
  return res;
}

PII operator + (const PII &a, const PII &b) {
  if (a.se == b.se) return PII(qmo(a.fi + b.fi - mod), a.se);
  return a.se < b.se ? a : b;
}
PII operator += (PII &a, const PII &b) { a = a + b; return a; }

PII operator - (const PII &a) { return PII(qmo(-a.fi), a.se); }
PII operator - (const PII &a, const PII &b) { return a + (-b); }
PII operator -= (PII &a, const PII &b) { a = a - b; return a; }

PII operator * (const PII &a, int b) {
  if (b == 0) return PII(a.fi, a.se + 1);
  return PII((LL)a.fi * b % mod, a.se);
}
PII operator *= (PII &a, int b) { a = a * b; return a; }

PII operator * (const PII &a, const PII &b) {
  return PII((LL)a.fi * b.fi % mod, a.se + b.se);
}
PII operator *= (PII &a, const PII &b) { a = a * b; return a; }

void solve() {
  int n; std::cin >> n;
  std::vector<int> pwn2(n+1), pwi2(n+1); // power of -2 and 1/2
  pwn2[0] = pwi2[0] = 1;
  for (int i = 1; i <= n; ++i) {
    pwn2[i] = pwn2[i-1] * (mod - 2ll) % mod;
    pwi2[i] = (pwi2[i-1] + (pwi2[i-1] & 1) * mod) / 2;
  }

  int N = 1 << n; std::vector<PII> s(N), t(N);
  for (int i = 0, x; i < N; ++i) {
    std::cin >> x;
    if (x == mod - 1) {
      s[i] = PII(1, 1);
      t[i] = PII(mod - 1, -2);
    } else {
      s[i] = PII(1 + x, 0);
      t[i] = PII((1 + 2ll * x) * ksm(1 + x, mod - 3) % mod, 0);
    }
  }

  for (int i = 0; i < n; ++i)
    for (int j = 0; j < N; ++j)
      if (!(j & (1 << i))) {
        s[j] *= s[j ^ (1 << i)];
        t[j] *= t[j ^ (1 << i)];
      }

  for (int i = 0; i < N; ++i) {
    s[i] *= pwn2[pc(i)];
    t[i] *= pwi2[pc(i)];
  }

  for (int i = 0; i < n; ++i)
    for (int j = 0; j < N; ++j)
      if (j & (1 << i)) s[j] += s[j ^ (1 << i)];
  for (int i = 0; i < N; ++i) s[i] *= s[i];
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < N; ++j)
      if (j & (1 << i)) s[j] -= s[j ^ (1 << i)];

  int ans = 0;
  for (int i = 0; i < N; ++i) {
    PII cur = s[i] * t[i]; assert(cur.se >= 0);
    if (cur.se == 0) ans = qmo(ans + cur.fi - mod);
  }
  printf("%d\n", ans);
}

int main() {
  int _, t;
  std::ios::sync_with_stdio(false);
  std::cin >> _ >> t;
  while (t --) { solve(); }
}
```

---

## 作者：masterhuang (赞：6)

**NOI 2025 折戟沉沙！**

给定 $n,a_0,a_1,\cdots,a_{2^n-1}$，定义数的 $\sube$ 表示二进制属于，集合的属于记号保持原意。

定义全集 $U=\{0,1,\cdots,2^n-1\},\forall S\sube U$ 定义 $f(S)=\mathop{\text{AND}}\limits_{x\in S}\,x$，特别的 $f(\varnothing)=2^n-1$​。

定义 $\pi(S)=\prod\limits_{x\in S}a_x,\pi(\varnothing)=1$。

$$
ans=\sum\limits_{S,T\sube U,S\cap T=\varnothing}[f(S)=f(T)]\pi(S\cup T)
$$

对 $p=998244353$ 取模，$2\le n\le 20,a_i\in [0,p)$。

**部分分**：保证 $a_i\ne p-1$。

---

**本题做法来自国家集训队 rk.9 hhoppitree，太大神！**

思考：考虑 $f$ 的相等肯定是无法刻画的，我们容易刻画的是 $x\sube f(S)\Leftrightarrow S\sube S_x$，其中超集 $S_x=\{y:x\sube y\}$。

于是有经典容斥：$[P=Q]=\sum\limits_{A\sube P,B\sube Q} (-1)^{|A|+|B|}2^{|A\cap B|}$。

带入：

$$
ans=\sum_{A,B}(-1)^{|A|+|B|}2^{|A\cap B|}\sum\limits_{S\sube S_A,T\sube S_B} [S\cap T=\varnothing]\pi(S\cup T)
$$

枚举 $C=A\cap B$：

$$
ans=\sum_{A,B,C\ 两两不交}(-1)^{|A|+|B|}2^{|C|}\sum\limits_{S\sube S_{A\cup C},T\sube S_{B\cup C}} [S\cap T=\varnothing]\pi(S\cup T)
$$

处理 $\sum\limits_{S\sube S_{A\cup C},T\sube S_{B\cup C}} [S\cap T=\varnothing]\pi(S\cup T)$ 这个东西的常见手段是：

对 $S_{A\cup C}\cup S_{B\cup C}$ 中的每个元素单独考虑放在 $S$ 还是 $T$ 还是丢弃。

定义 $L=A\cup B\cup C,D=S_{A\cup C}-S_L,E=S_{B\cup C}-S_L$。

- $i\in L$ 能放在 $S,T$ 或不放

- $i\in D$ 能放在 $S$ 或不放

- $i\in E$ 能放在 $T$ 或不放

于是这部分答案为：

$$
\begin{aligned}\prod\limits_{i\in D}(1+a_i)\prod\limits_{i\in E}(1+a_i)\prod\limits_{i\in L}(1+2a_i)&=\prod\limits_{i\in S_{A\cup C}}(1+a_i)\prod\limits_{i\in S_{B\cup C}}(1+a_i)\prod\limits_{i\in S_L}\dfrac{1+2a_i}{(1+a_i)^2}\\&=f(A\cup C)f(B\cup C)g(A\cup B\cup C)\end{aligned}
$$

---

$$
ans=\sum_{A,B,C\ 两两不交}(-1)^{|A|+|B|}2^{|C|}f(A\cup C)f(B\cup C)g(A\cup B\cup C)
$$

做点小变换 $(-1)^{|A|+|B|}=(-1)^{|A\cup C|}\cdot(-1)^{|B\cup C|},2^{|C|}=2^{|A\cup C|+|B\cup C|-|A\cup B\cup C|}$ 后有：

$$
ans=\sum_{A,B,C\ 两两不交}f(A\cup C)f(B\cup C)g(A\cup B\cup C)
\\
f(A)=(-2)^{|A|}\prod\limits_{x\in S_A}(1+a_x)
\\
g(A)=2^{-|A|}\prod\limits_{x\in S_A}\dfrac{1+2a_x}{(1+a_x)^2}
$$

注意到 $A\cup B\cup C=(A\cup C)\cup (B\cup C)$，就是一个**或卷积**的形式，有：

$$
ans=\sum\limits_{R}g(R)\sum\limits_{P\mid Q=R}f(P)f(Q)
$$

若没有 $a_i=p-1$ 则 $f,g$ 直接预处理，复杂度 $\mathcal{O}(n2^n)$。

---

若存在 $a_i=p-1$，我们如下变换：$(1+a_i)\to x,\dfrac{1+2a_i}{(1+a_i)^2}\to\dfrac{2x-1}{x^2}$，其中 $x \to 0$。

注意到经典结论，$\lim\limits_{x\to 0}\frac{f(x)}{g(x)}$ 是两个多项式最低次项的比值。

于是我们在**或卷积**的时候顺便记录 $x$ 项造成的多项式分数的最低次项，合并直接合并即可。

由于只需要最低次，合并是 $\mathcal{O}(1)$ 的，复杂度 $\mathcal{O}(n2^n)$。

**代码很短。**

```cpp
// 洛谷 P13275
// https://www.luogu.com.cn/problem/P13275
#include<bits/stdc++.h>
#define LL long long
#define P pair<int,int>
#define fi first
#define se second
#define pc __builtin_popcount
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
inline int rd()
{
	int x=0;char c=getchar();
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar()) x=x*10+c-'0';
	return x;
}
const int N=1<<20|5,mod=998244353,I2=(mod+1)>>1,_2=mod-2;
int C,n,m,a[N],p[23],q[23],ans;P f[N],g[N];
inline void ad(int &x,int y){x+=y;(x>=mod)&&(x-=mod);}
inline int ksm(int x,int p=mod-2){int s=1;for(;p;(p&1)&&(s=1ll*s*x%mod),x=1ll*x*x%mod,p>>=1);return s;}
inline P R(P A){return {A.fi,mod-A.se};}
inline void operator+=(P &A,P B){
	if(A>B) swap(A,B);
	if(A.fi==B.fi) ad(A.se,B.se);
}
inline void operator*=(P &A,P B){A={A.fi+B.fi,1ll*A.se*B.se%mod};}
inline void operator*=(P &A,int t){A={A.fi,1ll*A.se*t%mod};}
int main()
{
	C=rd(),C=rd();
	for(int i=*p=*q=1;i<=20;i++) p[i]=1ll*I2*p[i-1]%mod,q[i]=1ll*_2*q[i-1]%mod;
	while(C--)
	{
		n=rd();m=1<<n;ans=0;
		for(int i=0;i<m;i++) a[i]=rd();
		for(int i=0,x;i<m;i++)
		{
			if(a[i]==mod-1) f[i]={1,1},g[i]={-2,mod-1};
			else f[i]={0,x=1+a[i]},x=ksm(x),g[i]={0,(1+2ll*a[i])*x%mod*x%mod};
		}
		for(int i=0;i<n;i++) for(int j=0;j<m;j++) if(j>>i&1)
			f[j^(1<<i)]*=f[j],g[j^(1<<i)]*=g[j];
		for(int i=0;i<m;i++) f[i]*=q[pc(i)],g[i]*=p[pc(i)];
		for(int i=0;i<n;i++) for(int j=0;j<m;j++)
			if(j>>i&1) f[j]+=f[j^(1<<i)];
		for(int i=0;i<m;i++) f[i]*=f[i];
		for(int i=0;i<n;i++) for(int j=0;j<m;j++)
			if(j>>i&1) f[j]+=R(f[j^(1<<i)]);
		for(int i=0;i<m;i++)
		{
			f[i]*=g[i];
			if(!f[i].fi) ad(ans,f[i].se);
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：diqiuyi (赞：6)

场切了，纪念一下。

设 $f_{x,y}=\sum_{x\subseteq S,y\subseteq T,S\cap T=\empty} g_{s,t}$。容斥一下发现答案是 $\sum_{x,y}f_{x,y}(-1)^{\operatorname{popcnt}(x)+\operatorname{popcnt}(y)}2^{\operatorname{popcnt}(x\cap y)}$。

考虑特殊性质 B，记 $b_x$ 表示 $\prod_{x\subseteq i} (a_i+1)$，$c_x=\prod_{x\subseteq i} (2a_i+1)$，那么 $f_{x,y}=b_xb_yc_{x\cup y}/b_{x\cup y}^2$。这样可以简单 $O(4^n)$。

但是注意到 $\operatorname{popcnt}(x\cap y)=\operatorname{popcnt}(x)+\operatorname{popcnt}(y)-\operatorname{popcnt}(x\cup y)$，所以可以枚举 $x\cup y$，然后只要对每个 $S$ 求出 $\sum_{x\cup y=S} (-2)^{\operatorname{popcnt}(x)}b_x(-2)^{\operatorname{popcnt}(y)}b_y$，这个东西只需要先求出 $(\sum_{x\subseteq S} (-2)^{\operatorname{popcnt}(x)}b_x)^2$ 再高维差分一下即可。$O(2^nn)$，52pts。

然后考虑没有 B 性质怎么做。记 $cnt_x=\sum_{x\subseteq i}[a_i=-1]$，只有 $cnt_x=cnt_S$ 的 $x$ 可以对 $S$ 产生贡献。那么我们把 $b_x$ 的定义改成 $\prod_{x\subseteq i} [a_i\neq-1](a_i+1)$，然后前缀和以及差分的时候只更新 $cnt$ 相同的那些就对了。时间复杂度为 $O(2^nn)$。

代码没有。

---

## 作者：Erine (赞：5)

去不了 NOI 选手。

看不懂 B 性质咋办，那得推式子才知道。枚举 $f(P)=f(Q)=S$，并容斥钦定其满足条件。即

$$\sum_{S}\sum_{S\subseteq T_1}\sum_{S\subseteq T_2}(-1)^{|T1|-|S|}(-1)^{|T2|-|S|}\prod_{P}(1+a_P[T_1\subseteq P]+a_P[T_2\subseteq P])$$

进行一个式子的推。不妨枚举 $T1\cup T2=T$，即

$$
\begin{aligned}
&\sum_{S}\sum_{S\subseteq T}\sum_{S\subseteq T_1}\sum_{S\subseteq T_2}(-1)^{|T1|+|T2|}\prod_{T_1\subseteq P}(1+a_P)\prod_{T_2\subseteq P}(1+a_P)\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\left[T_1\cup T_2=T\right] \\
=&\sum_{S}\sum_{S\subseteq T}\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\sum_{S\subseteq T_1}\sum_{S\subseteq T_2}(-1)^{|T1|+|T2|}\prod_{T_1\subseteq P}(1+a_P)\prod_{T_2\subseteq P}(1+a_P)\left[T_1\cup T_2=T\right]
\end{aligned}
$$

然后这个时候就初见端倪，因为分母上出现了 $a+1$，这下看懂了.png。不急，我们先做 B 性质。不妨设 $w_S=(-1)^{|S|}\prod_{S\subseteq T}(1+a_T)$，这个可以高维后缀积做出来。

$$
\begin{aligned}
=&\sum_{S}\sum_{S\subseteq T}\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\sum_{S\subseteq T_1}\sum_{S\subseteq T_2}w_{T_1}w_{T_2}\left[T_1\cup T_2=T\right]
\end{aligned}
$$

然后这个时候我们已经愉快地做到了 $\Theta(3^nn)$，不过给的分非常少，因为还依赖 B 性质。考虑交换 $S,T$ 求和顺序。

$$
\begin{aligned}
=&\sum_{T}\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\sum_{S\subseteq T}\sum_{S\subseteq T_1}\sum_{S\subseteq T_2}w_{T_1}w_{T_2}\left[T_1\cup T_2=T\right]
\end{aligned}
$$

考察任意一对 $T_1,T_2$ 会对什么产生贡献。很显然它会对 $2^{|T_1\cap T_2|}$ 个 $S$ 产生贡献。所以没有必要枚举 $S$。

$$
\begin{aligned}
=&\sum_{T}\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\sum_{T_1}\sum_{T_2}w_{T_1}w_{T_2}2^{|T_1\cap T_2|}\left[T_1\cup T_2=T\right]
\end{aligned}
$$

然而很天才的事情是 $|T_1\cap T_2|+|T_1\cup T_2|=|T_1|+|T_2|$，所以我们发现 $|T_1\cap T_2|=|T_1|+|T_2|-|T_1\cup T_2|=|T_1|+|T_2|-|T|$。于是

$$
\begin{aligned}
=&\sum_{T}\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\sum_{T_1}\sum_{T_2}w_{T_1}w_{T_2}2^{|T_1|+|T_2|-|T|}\left[T_1\cup T_2=T\right] \\
=&\sum_{T}2^{-|T|}\left(\prod_{T\subseteq P} \dfrac{(1+2a_P)}{(1+a_P)^2}\right)\left(\sum_{T_1}\sum_{T_2}w_{T_1}2^{|T_1|}w_{T_2}2^{|T_2|}\left[T_1\cup T_2=T\right]\right)
\end{aligned}
$$

对，但是现在我们发现后半部分是没有任何限制的或运算卷积，可以 $\Theta(n2^n)$ 做一下。前半部分也是高维后缀积。所以现在整个 B 性质全部可以通过，拼上暴力可以获得 $56\sim 68$ 分。

那咋办。感觉上你要做到这个避免除以 $0$ 的唯一方法就是记有几个 $0$ 在因子里：换种说法，我要表达的意思是，把 $0$ 看做一个元 $x$ 这样。然后我们要做的就是求一个 $\lim\limits_{x\to 0} \dfrac{F(x)}{G(x)}$。因为 $G$ 此时是一个单项式，不妨考查 $F(x)$ 的最低次项。如果 $F$ 的最低次项 $> G$ 的，则答案为 $0$；否则答案为 $F$ 与 $G$ 最低次项系数的比。

我们可以证明 $F$ 的最低次项不会 $<G$ 即极限无意义，因为 $w_T$ 的次数在每一维上都是不增的，所以取 $T_1=T_2=T$ 时带来的次数最小，发现此时其次数也已经 $=\deg G$。

所以对做法进行改编：我们维护每个点的最低次项次数，FMT 时是极好合并的。

复杂度 $\Theta(n2^n)$，可以通过。

```cpp
void solve() {
	n = read(), U = (1 << n) - 1;
	ipw[0] = 1; rep(i, 1, n) ipw[i] = ipw[i - 1] * inv2 % mod;
	rep(i, 0, (1 << n) - 1) a[i] = read();
	rep(i, 0, (1 << n) - 1) {
		g[i] = (a[i] * 2 + 1) % mod;
		if (a[i] == mod - 1) f[i] = {1, 1};
		else f[i] = {(a[i] + 1) % mod, 0};
	}
	rep(i, 0, n - 1) per(S, (1 << n) - 1, 0) if (!(S >> i & 1)) f[S] = f[S] * f[S ^ (1 << i)];
	rep(i, 0, n - 1) per(S, (1 << n) - 1, 0) if (!(S >> i & 1)) g[S] = g[S] * g[S ^ (1 << i)] % mod;
	rep(i, 0, (1 << n) - 1) b[i] = (__builtin_popcount(i) & 1 ? mod - 1 : 1) * (1 << __builtin_popcount(i)) % mod * f[i];
	rep(i, 0, n - 1) rep(S, 0, (1 << n) - 1) if (S >> i & 1) b[S] += b[S ^ (1 << i)];
	rep(S, 0, (1 << n) - 1) b[S] = b[S] * b[S];
	per(i, n - 1, 0) per(S, (1 << n) - 1, 0) if (S >> i & 1) b[S] -= b[S ^ (1 << i)];
	int ans = 0;
	rep(S, 0, (1 << n) - 1) ans += b[S].fs * power(f[S].fs * f[S].fs % mod, mod - 2) % mod * g[S] % mod * ipw[__builtin_popcount(S)] % mod;
	write(ans % mod), pc('\n');
}
```

---

## 作者：xuanxuan001 (赞：5)

明明出到我擅长的点了，明明有机会的，但还是没抓住，只能 XCPC 再见了。

#define 按住 钦定

这题有两个主要的限制，一个是 $f(P) = f(Q)$，一个是 $P \cap Q = \emptyset$，这种东西显然要容斥，考虑容斥哪个条件。

$P \cap Q = \emptyset$ 这个东西看似枚举交集的子集进行容斥很好搞，但你会发现这玩意有 $2^n$ 个元素，状态数高达 $2^{2^n}$，所以对着这玩意容斥显然并不明智，因此考虑前一个。

那么想想 $f(P) \ne f(Q)$ 意味着什么，是不是说存在一个元素 $x$，使得 $x \in P \vee x \notin Q$ 或者反之，那么大胆地考虑一个极为复杂的容斥：直接枚举两个不交集合 $X,T$，并按住 $X \subseteq f(P),X \cap f(Q) = \emptyset,Y \cap f(P) = \emptyset,Y \subseteq f(Q)$，那么容斥系数为 $(-1)^{|X| + |Y|}$。

发现 $X \subseteq f(P)$ 这种条件是容易的，它等价于按住了 $P$ 中的所有元素都在二进制位上包含 $S$，但 $X \cap f(Q) = \emptyset$ 这种并不容易，因此考虑进一步容斥，继续枚举 $A \subseteq X,B \subseteq Y$ 并按住 $A \subseteq X \cap F(Q),B \subseteq Y \cap F(P)$，没错，就是这么疯狂，现在的容斥系数为 $(-1)^{|X| + |Y| + |A| + |B|}$。

那么不难发现由于枚举 $A,B$ 的时候已经有 $A \subseteq X,B \subseteq Y$ 了，所以其实只需要按住 $A \subseteq F(Q),B \subseteq F(P)$，那么与前面按住的东西合并一下，现在的限制就是：

$X \cup B \subseteq F(P),Y \cup A \subseteq F(Q)$

那么这个限制极其优美，令 $S = X \cup B,T = Y \cup A$，考虑这个时候的方案数怎么求，考虑对于每个元素 $x$：

- 如果有 $S \cup T \subseteq x$，那么 $x$ 可以放在 $P$ 中或 $Q$ 中或都不放，贡献为 $2a_x + 1$。
- 否则，如果有 $S \subseteq x$，那么 $x$ 可以放在 $P$ 中或都不放，贡献为 $a_x + 1$。
- $T \subseteq x$ 类似，贡献为 $a_x + 1$。
- 否则，没有贡献。

使用高维后缀积可以容易对每个数 $R$ 求出所有 $R \subseteq x$ 的 $a_x + 1$ 的积。设 $A_R$ 为 $a_x + 1$ 的积，$C_R$ 为 $2a_x + 1$ 的积。那么不难发现前面的讨论第一类贡献就是 $C_{S \cup T}$，第二类是 $\dfrac {A_S}{A_{S \cup T}}$，第三类是 $\dfrac {A_S}{A_{S \cup T}}$，乘起来就是答案。

发现有很多 B 性质，A 性质一看就和正解没啥关系，所以解法大概分成两部分，先做出 B 性质，再考虑 B 性质怎么推广到正解。

B 性质就是 $A$ 数组里没有 $0$，因此前面的除法可以直接逆元，令 $B_R = \dfrac {C_R}{A_R^2}$，并直接枚举 $S,T$ 再考虑 $X,Y,A,B$ 的方案数（好像重名了，但集合和数组应该不难区分），那么有 $A \cup B = S \cap T,A \cap B = \emptyset$，确定了 $A,B$ 之后应该不难唯一确定 $X,Y$ 了，不再赘述。

因此最终答案为 $\sum\limits_S \sum\limits_T A_SA_TB_{S \cup T}2^{|S \cap T|}(-1)^{|S| + |T|}$，最后一个就是划分 $S \cap T$ 为两个集合 $A,B$ 的方案数。

然后发现同时需要考虑交的信息和并的信息很烦，那么这个交的信息很特殊，可以转换成并（这里直接认为 $A_R$ 乘上了 $(-1)^{|R|}$，下同）：

$$
A_SA_TB_{S \cup T}2^{|S \cap T|}\\
=A_SA_TB_{S \cup T}2^{|S| + |T| - |S \cup T|}\\
=(2^{|S|}A_S)(2^{|T|}A_T)(2^{- |S \cup T|}B_{S \cup T})\\
$$

以这两个乘上了 $2$ 的幂次的东西作为新的数组即可，可以对每个 $x$ 求出 $\sum\limits_{S \cup T = x} A_SA_T$，这个是经典的 FWT，然后就能计算了。

我赛时被某个 AGC 的题误导了，把前面的式子转换成再枚举一个集合 $k \subseteq S \cap T$，然后就需要枚举 $k$ 再对补集做 FWT，就是 $O(3^n)$ 复杂度，只能拿 $56$ 分，sb 设定。

B 性质到正解是~~我认为~~较容易的。记录 $A$ 数组中被乘了多少次 $0$，也就是如果这个位置的 $a_i + 1 = 0$ 就记为 $1$ 并给计数器加一，然后高维后缀积的时候把这玩意也跟着加上，设这个的数量数组为 $D_R$，$R$ 就沿用前面的了，然后用没有 $0$ 的 $A$ 计算 $B$。

那么现在回顾 $O(4^n)$ 的枚举，应该变成$\sum\limits_S \sum\limits_T A_SA_TB_{S \cup T}2^{|S \cap T|}(-1)^{|S| + |T|}[D_S = D_{S \cup T}][D_T = D_{S \cup T}]$。

那么考虑加上 $D$ 的限制后是什么情况，现在需要对每个 $x$ 求出 $\sum\limits_{S \cup T = x} A_SA_T[D_S = D_x][D_T = D_x]$，这是个并不经典的 FWT，但是由于 $D$ 做了高维后缀和，所以它单调，那么考虑 FWT 变换的时候其实是个高维前缀和，我们可以在做```A[j|(1<<i)]+=A[j]```的时候判一下如果 $D_{j + 2^i} \ne D_j$ 就不做这步操作，这样就只有 $D$ 相同的被做了高维前缀和。这部分需要读者自行理解一下其中的原理，应该可以对每一维度归纳证明正确性，但感性理解一下也是可以的。

那么用这个改装了的 FWT 去做就对了。

代码其实有，场外写了，但不贴了，没啥必要。

---

## 作者：IvanZhang2009 (赞：5)

赛时完全不知道怎么做，把三方暴力 dp 的 $O(8^n)$ 卡过了 $n\le 10$ 带多测，然后最后一个小时才看出来有用的容斥，喜提没做完。

考虑这个特殊性质 B，大概就是让你把系数凑成 $a_i+1$ 状物。但是完全不知道怎么凑啊？它看上去就像是一个选一个或者不选的组合意义。

考虑随机找个方向容斥。第一个想法是对着 $P\cap Q$ 容斥，但是我场上浪费了两个小时毫无进展。

记 $f(P)$ 为 $P$ 中元素与和，$w(P)$ 为 $P$ 中元素 $a_i$ 乘积。对于整数 $x\in[0,2^n)$，记 $x_i$ 为 $\lfloor\frac{x}{2^i}\rfloor\bmod 2$，即二进制下第 $i$ 位。

考虑尝试对着 $f(P)=f(Q)$ 容斥。一个无敌的想法是考虑 $A=f(P)-f(Q),B=f(Q)-f(P)$（这里的减法视作集合减法，即 $S-T$ 中存在元素 $x$ 当且仅当 $S$ 中存在 $T$ 中不存在，此处即 $A$ 表示 $f(P)_i=1,f(Q)_i=0$ 的 $i$ 的集合，$B$ 同理）。

我们直接容斥 $A$ 和 $B$！枚举 $A,B$，容斥系数 $(-1)^{\mid A\mid+\mid B\mid}$，表示对于 $A$ 中的位，要求 $P$ 所有数在这一位不含 $0$，$Q$ 至少存在一个这一位是 $0$ 的；对于 $B$ 中的位，要求 $Q$ 所有数在这一位不含 $0$，$P$ 至少存在一个这一位是 $0$ 的。

考虑对于“至少存在一个”继续容斥。枚举 $C\subset A,D\subset B$ 表示容斥：对于 $C$ 中的位，$Q$ 这一位不含 $0$（本来是 $A$ 中的位 $Q$ 这一位得存在一个 $0$，枚举子集钦定不成立的容斥）；对于 $D$ 中的位，$P$ 这一位不含 $0$。容斥系数 $(-1)^{\mid C\mid+\mid D\mid}$。这里的限制变成对于 $A\cup D$ 的位，$P$ 这一位没 $0$；$B\cup C$ 的位，$Q$ 这一位没 $0$。

写出来相当于：

$$
\sum_{C\subset A,D\subset B,A\cap B=\empty}\sum_{(A\cup D)\in f(P)}\sum_{(B\cup C)\in f(Q)}[P\cap Q=\empty]w(P)w(Q)
$$

这里 $a\in b$ 表示二进制下 $a$ 是 $b$ 的子集。

假设你以及枚举了 $A,B,C,D$，考虑一个数 $i$ 可以放在哪里（三种选择，放 $P$，放 $Q$，都不放）。如果 $(A\cup D\cup B\cup C)\in i$，则显然贡献是 $2a_i+1$；如果上述不满足，且满足 $(A\cup D)\in i$ 或 $(B\cup C)\in i$，则贡献是 $a_i+1$；否则贡献是 $1$。

这里“如果上述不满足”的限制比较唐。在性质 B 中 $a_i\neq -1$，也就是说 $a_i+1$ 存在逆元。记 $g(s)$ 表示 $\prod_{s\in i}(a_i+1)$，$h(s)$ 表示 $\prod_{s\in i}\frac{2a_i+1}{a_i+1}$，则贡献可以写为 $h(A\cup B\cup C\cup D)g(A\cup D)g(B\cup C)$。

预处理 $g,h$ 可以简单高维后缀积，$O(2^nn)$。然后暴力做是枚举 $A,B,C,D$，这里分析一下每一位是 $1$ 的可能是：$A,AC,B,BD,\empty$，所以复杂度是 $O(5^n)$。

考虑优化也很容易，如果先枚举 $A,B$，则 $C,D$ 是独立的，复杂度 $O(4^n)$。

如果先枚举 $A,D$，然后高维前缀和预处理对于每一组 $(A,B)$ 的 $D$ 的贡献和，则复杂度 $O(3^nn)$。考场上止步于此了，啊啊啊。

注意到人类智慧。我们的贡献只和 $A\cup D$ 和 $B\cup C$ 有关。如果枚举这两个，那唯一的问题就是如何处理 $A\cap B=\empty$？可以发现 $A\cap B$ 的部分一定属于 $(A\cup D)\cap(B\cup C)$。而这里的每一位都可以划给 $AD$ 和 $BC$，所以竟然直接乘上一个 $2^{\mid (A\cup D)\cap(B\cup C)\mid}$ 就好了！！！

记 $s=A\cup D,t=B\cup C$。重写一下式子：

$$
\sum_{s,t}(-2)^{\mid s\mid+\mid t\mid}2^{-|S\cup T|}g(s)g(t)h(s\cup t)
$$

注意到 $s,t$ 独立，我们直接做或卷积，所以做到了 $O(2^nn)$。

但是这里 $h$ 的定义有逆元，但是逆元不一定存在，只能通过性质 B。那咋办。

其实很好做，我们用 $a\times M^b$ 的形式存储一个数，其中 $M$ 是模数。注意到我们只需要做加减乘除。加法的时候令 $b$ 为两个里的小的那个，乘除的时候把 $a$ 乘起来，$b$ 加起来就好了。

这种题代码都很好写。

```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define int long long
#define REP(i,a,n) for(int i=a;i<(int)(n);++i)
#define pb push_back
#define all(v) v.begin(),v.end()
#define pii pair<int,int>
#define cntbit(x) __builtin_popcount(x)
using namespace std;
int qpow(int x,int y){
	int res=1;
	while(y)res=y&1? res*x%MOD:res,x=x*x%MOD,y>>=1;
	return res;
}
int ID;
struct number{
	int x;
	int c;
	void operator =(int y){
		if(y%MOD==0)x=1,c=1;
		else x=y,c=0;
	}
	void operator *=(number a){
		(x*=a.x)%=MOD;
		(c+=a.c)%=MOD;
	}
	void operator *=(int a){
		(x*=a)%=MOD;
	}
	void operator +=(number a){
		int r=min(c,a.c);
		x=((c==r)*x+(a.c==r)*a.x)%MOD,c=r;
	}
	void operator -=(number a){
		int r=min(c,a.c);
		x=((c==r)*x-(a.c==r)*a.x)%MOD,c=r;
	}
};
int n;
int a[1100000];
number f[1100000],g[1100000];
void Main() {
	cin>>n;
	REP(i,0,(1<<n))cin>>a[i];
	REP(i,0,(1<<n))f[i]=a[i]+1;
	REP(i,0,n){
		for(int j=(1<<n)-1;j>=0;--j)if(!((j>>i)&1)){
			f[j]*=f[j|(1<<i)];
		}
	}
	REP(i,0,(1<<n))f[i]*=qpow(-2,cntbit(i));
	REP(j,0,n){
		REP(i,0,(1<<n))if((i>>j)&1){
			f[i]+=f[i^(1<<j)];
		}
	}
	REP(i,0,(1<<n)){
		f[i]*=f[i];
	}
	REP(j,0,n){
		for(int i=(1<<n)-1;i>=0;--i)if((i>>j)&1){
			f[i]-=f[i^(1<<j)];
		}
	}
	REP(i,0,(1<<n)){
		if(a[i]==MOD-1){
			g[i]={a[i],-2};
		}else g[i]=(a[i]*2+1)*qpow(a[i]+1,(MOD-2)*2)%MOD;
	}
	REP(i,0,n){
		for(int j=(1<<n)-1;j>=0;--j)if(!((j>>i)&1)){
			g[j]*=g[j|(1<<i)];
		}
	}
	int ans=0;
	REP(i,0,(1<<n)){
		f[i]*=g[i];
		if(f[i].c)continue;
		int co=qpow((MOD+1)/2,cntbit(i))*f[i].x;
		(ans+=co)%=MOD;
	}
	(ans+=MOD)%=MOD;
	cout<<ans<<'\n';
}
signed main(){
	int tc;
	cin>>ID>>tc;
	while(tc--)Main();
	return 0;
}
```

---

## 作者：yanzihe (赞：5)

数学分析好题，这道题拯救了我的 NOI。

写一下赛时做法。

## B 性质
把二进制数视作集合，设 $U=\{1, 2, \dots, n\}, S=\mathcal{P}(U)$（$U$ 的幂集）。

定义 $v(P)=\prod_{x\in P}a_x$

首先枚举 $J\subseteq U$，然后计算 $f(P_1)=f(P_2)=J$ 的有序对的贡献，即 
$$\sum_{J\subseteq U}\sum_{P_1\subseteq S, f(P_1)=J}v(P_1)\sum_{P_2\subseteq S, f(P_2)=J, P_1\cap P_2=\varnothing}v(P_2)$$

熟知**困难计数题优先考虑容斥**，注意到 
$$\sum_{P\subseteq S, f(P)=J}v(P)=\sum_{J\subseteq T\subseteq U}(-1)^{|T|-|J|}\sum_{P\subseteq S, T\subseteq f(P)}v(P)$$

所以原式等于 
$$\sum_{T_1, T_2\subseteq U}(-1)^{|T_1|+|T_2|}\sum_{J\subseteq (T_1\cap T_2)}\sum_{T_1\subseteq f(P_1), T_2\subseteq f(P_2), P_1\cap P_2=\varnothing}v(P_1)v(P_2)$$

发现枚举 $J$ 可以替换为 $2^{|T_1\cap T_2|}$，即
$$\sum_{T_1, T_2\subseteq U}(-1)^{|T_1|+|T_2|}2^{|T_1\cap T_2|}\sum_{T_1\subseteq f(P_1), T_2\subseteq f(P_2), P_1\cap P_2=\varnothing}v(P_1)v(P_2)  \tag{1}$$

设 $A=\{X|X\subseteq U, T_1\subseteq X\}, B=\{X|X\subseteq U, T_2\subseteq X\}$。那么 $(1)$ 式右侧和号下的条件 $T_1\subseteq f(P_1), T_2\subseteq f(P_2)$ 等价于 $P_1\subseteq A, P_2\subseteq B$。

$(1)$ 等于

$$\sum_{T_1, T_2\subseteq U}(-1)^{|T_1|+|T_2|}2^{|T_1\cap T_2|}\sum_{P_1\subseteq A, P_2\subseteq B, P_1\cap P_2=\varnothing}\prod_{X\in P_1\cup P_2}a_X=\sum_{T_1, T_2\subseteq U}(-1)^{|T_1|+|T_2|}2^{|T_1\cap T_2|}\prod_{X\in (A\cap B)}(2a_X+1)\prod_{X\in (A\cup B)/(A\cap B)}(a_X+1)$$

第二个等号的原理：考虑把所有括号展开，对于 $X\in(A\cap B)$每一项都要从 $2a_X$ 和 $1$ 中选择一个，选择 $1$ 表示 $X$ 既不在 $P_1$ 中也不在 $P_2$ 中，选择 $2a_X$ 表示在其中一个。（乘以 $2$ 是因为有在 $P_1$ 中和在 $P_2$ 中两种可能）

而对于 $X\in (A\cup B)/(A\cap B)$，选择 $1$ 表示 $X$ 不在 $P_1, P_2$ 中，否则表示在其中。这里不乘以二是因为 $X\notin (A\cap B)$，只能放在其中一个里。

那么只需要预处理 $G(T)=\prod_{T\subseteq X}(2a_X+1), K(T)=\prod_{T\subseteq X}(a_X+1)$（显然它们能在 $O(n2^n)$ 内预处理出），答案就是

$$\sum_{T_1, T_2\subseteq U}(-1)^{|T_1|+|T_2|}2^{|T_1\cap T_2|}G(T_1\cup T_2)\times\dfrac{K(T_1)K(T_2)}{K(T_1\cup T_2)^2}$$

为了进一步地简化式子，另设 $L(T)=\dfrac{G(T)}{K(T)^22^{|T|}}，W(T)=K(T)(-2)^{|T|}$，原式等于
$$\sum_{T_1, T_2\subseteq U}W(T_1)W(T_2)L(T_1\cup T_2)=\sum_{T\subseteq U}L(T)\sum_{T_1\cup T_2=T}W(T_1)W(T_2)$$

这是一个卷积的形式，使用 FWT 直接 $O(n2^n)$ 计算。

## 正解
设使用之前的算法算出的答案为 $ans(a_0, a_1\dots, a_U)$（注意他是一个 $2^n$ 元的函数）。

考虑它在 $a_X=998244352$ 时遇到了问题，因为可能出现乘以 $0$ 再除以 $0$ 的情况。



为了解决这个问题，注意 $\lim_{\epsilon\to 0^+}ans(a_0+\epsilon, a_1+\epsilon, \dots, a_U+\epsilon)$ 就是正确的答案（注意所有 $a_X$ 都加上 $\epsilon$ 后，就不会出现除以 $0$ 的情况，只会出现除以 $\epsilon$ 的情况）。

一个想法是直接把 $\epsilon$ 带进去 $ans$ 的表达式中计算，这样原本的每一个数都是一个关于 $\epsilon$ 的洛朗级数，但是洛朗级数的乘除法很慢。

因此，我们的办法是任何时候只保留洛朗级数的最低项，这样复杂度不变，并且算出来的极限值是正确的。

**证明**：设想有一个洛朗级数$3\epsilon^4+2\epsilon^2$，如果舍弃了 $3\epsilon^4$ 对答案产生的影响，那么说明这个多项式一定会除以$(\text{常数}\times\epsilon^4)$ 后贡献到答案上，但这意味着 $2\epsilon^2$ 变成了 $\text{常数}\times \dfrac{1}{\epsilon^2}$，这意味着极限发散！原极限显然是存在的，这不可能。

在具体计算时，如果是加法，并且最低次项次数相同则系数相加，否则只保留低次项。如果是乘/除法，直接让最低次项做乘/除法。

那么通过这个方法算出来的 $ans(a_0+\epsilon, a_1+\epsilon, \dots, a_U+\epsilon)$，它的常数项就是答案。（带 $\epsilon$ 的项都趋于 $0$，可不计）

---

## 作者：SDSXC (赞：4)

赛后认真想一想发现真不算难，可惜赛时 T1 调了好久没时间做此题了，希望明年不要再发生这种事情了，简单记录一下做法。

首先我们统计 $f(P)=X$ 的比较难做，考虑统计 $f(P)\supseteq X$ 的然后容斥。

考虑 $f(P)\supseteq X,f(Q)\supseteq Y$ 的权值和，若 $S\supseteq X$ 但 $S\nsupseteq Y$，那么 $a_S$ 可以不选，可以放 $P$ 中，给答案乘上 $(1+a_S)$，反过来同理，若 $S\supseteq X$ 且 $S\supseteq Y$，贡献 $(1+2a_S)$。所以 $f(P)\supseteq X,f(Q)\supseteq Y$ 的权值和 $w_{X,Y}=\prod\limits_{S\supseteq X}(1+a_S)\prod\limits_{S\supseteq Y}(1+a_S)\prod\limits_{S\supseteq X,S\supseteq Y}\frac{1+2a_S}{(1+a_S)^2}$。

我们记 $F(X)=\prod\limits_{S\supseteq X}(1+a_S),G(X)=\prod\limits_{S\supseteq X}\frac{1+2a_S}{(1+a_S)^2}$，那么 $w_{X,Y}=F(X)F(Y)G(X\cup Y)$。

这个东西直接暴力算然后跑高维后缀差分就可以轻松做到$O(4^n)$。当然你还需要处理 $a_S=-1$ 的情况，这个最后讲。

然后我们接着推式子，假设 $H(S)$ 表示 $f(P)=f(Q)=S$ 的权值和。那么我们不难发现 $w(X,Y)$ 对满足 $S\subseteq X,S\subseteq Y$ 的 $H(S)$ 有 $(-1)^{|X-S|+|Y-S|}=(-1)^{|X|+|Y|-2|S|}=(-1)^{|X|+|Y|}$。而共有 $2^{|X\cap Y|}$ 个 $H(S)$ 被贡献到了，所以对答案的贡献为 $(-1)^{|X|+|Y|}2^{|X\cap Y|}=(-1)^{|X|+|Y|}2^{|X|+|Y|-|X\cup Y|}=(-2)^{|X|}(-2)^{|Y|}(\frac{1}{2})^{|X\cup Y|}$。

令 $A(X)=(-2)^{|X|}F(X),B(X)=(\frac{1}{2})^{|X|}G(X)$。

那么答案就等于 $\sum\limits_{X,Y}A(X)A(Y)B(X\cup Y)$。

然后跑一个高维前缀积即可求出 $F,G$，然后简单求出 $A,B$。再简单 FWT 求出 $\sum\limits_{X\cup Y=S}A(X)A(Y)$，然后把每一项乘上 $B(S)$ 再加起来就做完了。

最后讲一下 $a_S=-1$ 的处理方法，也非常简单，我们参考求模 $2^{64}$ 意义下组合数的做法，我们把每一个数写成 $x\times p^y$ 的形式，乘除法是容易的，加减法同阶直接加减直接，否则舍去高次项因为你显然不会出现 $\frac{1}{p}$ 这种东西。

代码很好写
```cpp
#include<bits/stdc++.h>
#define p 998244353ll
#define ll long long
#define N 1049000
using namespace std;
ll qpow(ll x,ll y){
	if(!y) return 1ll;
	ll tmp=qpow(x,y>>1);
	if(y&1) return tmp*tmp%p*x%p;
	else return tmp*tmp%p;
}
struct num{
	ll x,y;
	num operator+(num b){
		if(y==b.y){
			if((x+b.x)%p) return num{(x+b.x)%p,y};
			else return num{(x+b.x)/p,y+1};
		}
		else if(y<b.y) return num{x,y};
		else return b;
	}
	num operator-(num b){
		if(y==b.y){
			if((x-b.x)%p) return num{(x-b.x+p)%p,y};
			else return num{((x-b.x)/p+p)%p,y+1};
		}
		else if(y<b.y) return num{x,y};
		else return num{p-b.x,b.y};
	}
	num operator*(num b){
		return num{x*b.x%p,y+b.y};
	}
	num operator/(num b){
		return num{x*qpow(b.x,p-2)%p,y-b.y};
	}
};
num f[N],g[N],a[N];
int n;
constexpr num _1=num{1,0},_2=num{2,0};
void solve(){
	cin>>n;
	for(int i=0;i<(1<<n);i++)cin>>a[i].x,a[i].y=0;
	for(int i=0;i<(1<<n);i++)f[i]=a[i]+_1,g[i]=a[i]*_2+_1;
	for(int i=1;i<(1<<n);i<<=1){
		for(int j=0;j<(1<<n);j++){
			if(!(j&i))f[j]=f[j]*f[j^i],g[j]=g[j]*g[j^i];
		}
	}
	for(int i=0;i<(1<<n);i++){
		num t={1<<__builtin_popcount(i),0};
		g[i]=g[i]/(f[i]*f[i]*t);
		f[i]=f[i]*t;
		if(__builtin_popcount(i)&1)f[i]={p-f[i].x,f[i].y};
	}
	for(int i=1;i<(1<<n);i<<=1){
		for(int j=0;j<(1<<n);j++){
			if(j&i)f[j]=f[j]+f[j^i];
		}
	}
	for(int i=0;i<(1<<n);i++)f[i]=f[i]*f[i];
	for(int i=1;i<(1<<n);i<<=1){
		for(int j=0;j<(1<<n);j++){
			if(j&i)f[j]=f[j]-f[j^i];
		}
	}
	for(int i=0;i<(1<<n);i++)f[i]=f[i]*g[i];
	ll ans=0;
	for(int i=0;i<(1<<n);i++)if(!f[i].y)ans+=f[i].x;
	cout<<ans%p<<"\n";
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int C,T;cin>>C>>T;while(T--)solve();
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：4)

场上不会这个题导致 day2 整个完蛋了。

关注一下 $f(P),f(Q)$ 的限制，你发现我们如果不去枚举 $P,Q$ 的话连计算 $f(P)=s$ 的 $P$ 数量都很难，所以考虑容斥，不难发现很容易对 $s \subseteq f(P)$ 的 $P$ 计算权值和，再进一步地，考虑对 $a \subseteq f(P),b \subseteq f(Q)$ 并且 $P \cap Q = \varnothing$ 的所有 $P,Q$ 计算方案权值和，考察每个元素到底是选入 $P$ 选入 $Q$ 还是都不选，不难发现贡献就是 $\prod_{a \subseteq s \nsubseteq (a \cup b)} (a_s+1) \times \prod_{b \subseteq s \nsubseteq (a \cup b)} (a_s+1) \prod_{(a \cup b) \subseteq s} (2 \times a_s+1)$，如果先不考虑 $a_i = -1$ 的情形，那么直接令 $f_{s} = \prod_{s \subseteq t} (a_t+1),g_{s} = \prod_{s \subseteq t} (2 \times a_t +1)$，那么贡献就是 $f(a) \times f(b) \times \frac{1}{f(a \cup b)^2} \times g(a \cup b)$。

接下来先考虑一个 $4^n$ 左右的暴力，令 $F(a,b)$ 表示 $a \subseteq f(P),b \subseteq f(Q)$ 并且 $P \cap Q = \varnothing$ 的所有 $P,Q$ 计算方案权值和，$G(a,b)$ 表示 $a = f(P),b = f(Q)$ 并且 $P \cap Q = \varnothing$ 的所有 $P,Q$ 计算方案权值和，显然有 $F(a,b)$ 是 $G(a,b)$ 的高维后缀和，容易通过高维后缀差分求出所有 $G$ 后对所有 $G(S,S)$ 求和。

考虑用式子把上面的暴力描述出来，$G$ 的表示方法可以考虑子集反演，也就是 $G(a,b) = \sum_{a \subseteq A,b \subseteq B} (-1)^{|A|-|a|+|B|-|b|} F(A,B)$。

所以答案式子是 $\sum_{S \subseteq \{1,2,3,\dots n\}} \sum_{S \subseteq A,S \subseteq B} (-1)^{|A|+|B|} F(A,B)$。

发现 $S$ 的枚举用处已经不大了，交换求和顺序容易得到 $\sum_{A \subseteq \{1,2,3,\dots n\},B \subseteq \{1,2,3,\dots n\}} (-1)^{|A|+|B|} 2^{|A \cap B|} F(A,B)$。

我们希望将 $A,B$ 的枚举拆开，发现难点在于 $F(A,B)$ 里面有个关于 $A \cup B$ 的项，于是考虑枚举 $A \cup B$ 然后统计多少组 $A,B$ 能贡献上去，这是一个或卷积，容易通过高维前缀和与高维前缀差分处理出来，$2^{|A \cap B|}$ 的处理考虑把 $|A \cap B|$ 转写为 $|A|+|B|-|A \cup B|$ 即可。

现在考虑如果存在 $a_i = -1$ 咋办。

考虑把 $0$ 因子数量记下来，我们转变 $f$ 的定义为所有 $a_i+1 \neq 0$ 的 $a_i+1$ 之积，并记录 $c$ 表示 $a_i+1$ 中 $0$ 的数量，你发现如果 $c(a)=c(b)=c(a \cup b)$ 那么按照新的 $f$ 原来的式子计算答案就是对的，否则没有贡献。

考虑把或卷积的过程改一下使得能处理新的问题，新的问题形如：$C_{s} = \sum_{a \cup b = s,c(a)=c(b)=c(s)} dp_a \times dp_b$。

类似或卷积的处理过程，考虑先对每个 $S$ 求出 $\sum_{a \subseteq S,c(a)=c(S)} dp_a$，这个东西的求法考虑改一下高维前缀和：因为 $c$ 的值随着下标所对应的集合加入元素而渐渐减小，所以每次将要从 $S$ 贡献到 $S \cup v$ 的时候如果 $c(S) \neq c(S \cup v)$ 就不去贡献即可，将求出来的数组每一项平方之后，相当于对每个 $S$ 求出了 $\sum_{a \subseteq S,c(a)=c(S),b \subseteq S,c(b)=c(S),a \cup b \subseteq S} dp_a \times dp_b$，从这个出发求解 $C$ 还是考虑一样的思路，改一下高维前缀差分：你发现将 $C$ 数组做前面处理 $\sum_{a \subseteq S,c(a)=c(S)} dp_a$ 时做的更改后的高维前缀和就可以得到我们已经求出的 $\sum_{a \subseteq S,c(a)=c(S),b \subseteq S,c(b)=c(S),a \cup b \subseteq S} dp_a \times dp_b$（由于 $c$ 数组的性质，$c(a),c(b) \geq c(a \cup b) \geq c(S)$，所以 $c(a)=c(b)=c(S)$ 就代表 $c(a)=c(b)=c(a \cup b)$），所以将这个已经求出的数组倒过来做前面的操作即可得到 $C$（由于这个操作是线性变换所以是可以转置的）。

综上我们在 $O(n 2^n)$ 的时间复杂度内解决了这个问题。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxv = 1<<20;
const int mod = 998244353;
int n;
int popc[maxv];
int a[maxv];
int v1[maxv],c1[maxv],v2[maxv];
int inv1[maxv];
int qpow(int a,int b){
    if(b==0) return 1;
    if(b==1) return a;
    int res=qpow(a,b/2);
    res=res*res%mod;
    if(b&1) res=res*a%mod;
    return res;
}
int pre[maxv];
int _pow[maxv],inv[maxv];
void work(){
    cin>>n;
    for(int i=0;i<(1<<n);i++) cin>>a[i],v1[i]=((a[i]+1)%mod==0?1:(a[i]+1)%mod),c1[i]=((a[i]+1)%mod==0),v2[i]=(2*a[i]+1)%mod;
    for(int i=0;i<n;i++){
        for(int v=0;v<(1<<n);v++){
            if((1<<i)&v){
                v1[v-(1<<i)]=v1[v-(1<<i)]*v1[v]%mod;
                c1[v-(1<<i)]+=c1[v];
                v2[v-(1<<i)]=v2[v-(1<<i)]*v2[v]%mod;
            }
        }
    }
    for(int v=0;v<(1<<n);v++) inv1[v]=qpow(v1[v],mod-2);
    for(int v=0;v<(1<<n);v++) pre[v]=v1[v]*(popc[v]&1?mod-1:1)%mod*_pow[popc[v]]%mod;
    for(int i=0;i<n;i++){
        for(int v=0;v<(1<<n);v++){
            if((1<<i)&v){
                if(c1[v-(1<<i)]==c1[v]) pre[v]=(pre[v]+pre[v-(1<<i)])%mod;
            }
        }
    }
    for(int v=0;v<(1<<n);v++) pre[v]=pre[v]*pre[v]%mod;
    for(int i=0;i<n;i++){
        for(int v=0;v<(1<<n);v++){
            if((1<<i)&v){
                if(c1[v-(1<<i)]==c1[v]) pre[v]=(pre[v]+mod-pre[v-(1<<i)])%mod;
            }
        }
    }
    int ans=0;
    for(int v=0;v<(1<<n);v++){
        ans=(ans+pre[v]*inv1[v]%mod*inv1[v]%mod*v2[v]%mod*inv[popc[v]]%mod)%mod;
    }
    cout<<ans<<"\n";
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    _pow[0]=inv[0]=1;
    for(int i=1;i<maxv;i++) popc[i]=popc[i>>1]+(i&1),_pow[i]=_pow[i-1]*2%mod,inv[i]=inv[i-1]*((mod+1)/2)%mod;
    int id,t;
    cin>>id>>t;
    while(t--) work();
    return 0;
}
```

---

## 作者：伊地知虹夏 (赞：3)

> 省选考了两次集合幂级数，noi 总不能再考了吧。

哎我草这个题怎么这么牛。

下文中将下标也视为一个 $[n]$ 的子集。

考虑 $f(P) = f(Q)$ 的限制是我们从未见过的，尝试容斥掉这个限制。

$$\begin{align*} 
[P = Q] &= \prod_{i=1}^{n} [P_i = Q_i] \\ 
        &= \prod_{i=1}^{n} (2(P_i \operatorname{and} Q_i) - P_i - Q_i + 1)\\
        &= \sum_{S \subseteq P} \sum_{T \subseteq Q} 2^{|S \cap T|}(-1)^{|S|-|S\cap T|}(-1)^{|T|-|S\cap T|}\\
        &= \sum_{S \subseteq P} \sum_{T \subseteq Q} 2^{|S \cap T|}(-1)^{|S|+|T|}\\
\end{align*}$$

后面那个式子有很显然的组合意义（拆括号不难看出）。

那么答案是：（记 $w(P) = \prod_{i \in P} a_i$）

$$\begin{align*} 
&\sum_{P \cap Q = \varnothing}w(P)w(Q)\sum_{S\subseteq f(P), T\subseteq f(Q)} 2 ^ {|S\cap T|}(-1)^{|S|+|T|}
\\
&= \sum_{S,T} 2 ^ {|S\cap T|}(-1)^{|S|+|T|}\sum_{S\subseteq f(P), T\subseteq f(Q)} w(P) w(Q)
\\ 
&= \sum_{S,T} 2 ^ {|S\cap T|}(-1)^{|S|+|T|} \prod_{S \subseteq X, T \subsetneq X} (a_X + 1)
\prod_{S \subsetneq X, T \subseteq X} (a_X + 1)
\prod_{S \subseteq X, T \subseteq X} (2a_X + 1) 
\\
&= \sum_{S,T} (-2)^{|S|}(-2)^{|T|}2^{-|S\cup T|}\prod_{S \subseteq X} (a_X + 1)
\prod_{T \subseteq X} (a_X + 1)
\prod_{S \cup T \subseteq X} \dfrac{2a_X + 1}{(a_X + 1) ^ 2} 
\end{align*}$$

记 $f(S) = (-2)^{|S|} \prod\limits_{S \subseteq X} (a_X + 1)$，$g(S) = 2^{-|S|}\prod\limits_{S \subseteq X} \dfrac{2a_X + 1}{(a_X + 1) ^ 2}$。

那么答案就化简为 $A = \sum\limits_{S,T} f_Sf_Tg_{S\cup T}$。

$f,g$ 可以用高维后缀积求出，而 $A = (f\times f) \cdot g$（$\times$ 表示或卷积，$\cdot$ 表示向量点乘），也可以用一次或卷积求出，时间复杂度 $\mathcal O(n2^n)$。

但是当 $a_X=998,244,352$ 时，$a_X + 1$ 不存在逆元。此时我们将一个数看成一个多项式 $x\times 998,244,353^k$，乘法除法正常做，加减法时只保留 $k$ 较小的那个就是对的。

理清楚思路后代码非常好写，代码：
```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for (int i = l; i <= r; i ++)
#define rrp(i,l,r) for (int i = l; i >= r; i --)
using namespace std;
typedef long long LL;
const int N = (1 << 20) + 5, mod = 998244353;
const int i2 = (mod + 1) / 2;

int n, U, a[N], ipw[N], pw[N], cnt[N];

inline int pls(int x, int y) { unsigned t = x + y; return min(t, t - mod); }

int Inv(int x) { return x == 1 ? 1 : 1LL * (mod - mod / x) * Inv(mod % x) % mod; }

struct mint {
  int x; LL k;
  mint (int _x = 0, LL _k = 0) : x(_x), k(_k) {}
  mint operator+(const mint &o) const {
    if (o.k > k) return *this;
    if (k > o.k) return o;
    return {pls(x, o.x), k};
  }
  mint operator-(const mint &o) const {
    if (o.k > k) return *this;
    if (k > o.k) return {(o.x > 0) * mod - o.x, o.k};
    return {pls(x, mod - o.x), k};
  }
  mint operator*(const mint &o) const {
    return {1LL * x * o.x % mod, k + o.k};
  }
  mint operator/(const mint &o) const {
    return {1LL * x * Inv(o.x) % mod, k - o.k};
  }
  friend void operator*=(mint &p, const mint &q) { p = p * q; }
};

mint f[N], g[N];

void fwt(mint *f, int t) {
  mint o = mint(t < 0 ? mod - 1 : 1);
  rep (i, 0, n-1) rep (j, 0, U) if (j >> i & 1)
    f[j] = f[j] + o * f[j ^ (1 << i)];
}

void fakemain() {
  cin >> n, U = (1 << n) - 1;
  rep (i, 0, U) cin >> a[i];
  ipw[0] = pw[0] = 1;
  rep (i, 0, U) {
    pw[i + 1] = (LL)(mod - 2) * pw[i] % mod;
    ipw[i + 1] = (LL)i2 * ipw[i] % mod;
  }
  rep (i, 0, U) {
    mint b;
    if (a[i] < mod - 1) b = a[i] + 1;
    else b = {1, 1};
    f[i] = b, g[i] = ((mint)a[i] + b) / b / b;
  }
  rep (i, 0, n-1) rep (j, 0, U) if (~j >> i & 1)
    f[j] *= f[j | (1 << i)], g[j] *= g[j | (1 << i)];
  rep (i, 0, U) {
    cnt[i] = cnt[i >> 1] + (i & 1);
    f[i] *= mint(pw[cnt[i]]);
    g[i] *= mint(ipw[cnt[i]]);
  }
  fwt(f, 1);
  rep (i, 0, U) f[i] = f[i] * f[i];
  fwt(f, -1);
  mint ans;
  rep (i, 0, U) ans = ans + f[i] * g[i];
  cout << ans.x << '\n';
  assert(ans.k == 0);
}

signed main() {
  cin.tie(0)->ios::sync_with_stdio(0);
  int O, T = 1;
  cin >> O >> T;
  while (T --) fakemain();
  cerr << 1. * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```

---

## 作者：xiezheyuan (赞：2)

场外选手强做一波。

## 简要题意

给定 $n$ 和一个长度为 $2^n$ 的序列 $a$，定义 $U=[0,2^n)\cap\mathbb{Z}$，计算：

$$
\sum_{\substack{P\subseteq U,Q\subseteq U\\P\cap Q=\varnothing}} \left[\bigwedge_{k\in P} k=\bigwedge_{k\in Q}k\right]\prod_{k\in P\cup Q} a_k
$$

答案对 $p=998,244,353$ 取模。

$T$ 组数据。$1\leq T\leq 3,2\leq n\leq 20,0\leq a_i<p$。

## 思路

### 记号约定

- $\land,\lor$ 分别表示按位与、或运算。
- $S\sqsubseteq T$，当且仅当 $S\land T=S$。

下面的过程为了避免引起混乱，将**区分**集合运算与关系 $\cup,\cap,\subseteq$ 和 bitmask 的运算与关系 $\land,\lor,\sqsubseteq$，不过 $|x|$ 将同时表示集合 $x$ 的大小和 bitmask $x$ 的 popcount。

### Part 1

刻画两个集合的按位 and 相等极其困难，不妨容斥，不妨设：

$$
\begin{aligned}
&F(S,T)=\sum_{\substack{P\subseteq U,Q\subseteq U\\P\cap Q=\varnothing}} \left[\bigwedge_{k\in P} k=S,\bigwedge_{k\in Q}k=T\right]\prod_{k\in P\cup Q} a_k\\
&G(S,T)=\sum_{\substack{P\subseteq U,Q\subseteq U\\P\cap Q=\varnothing}} \left[S\sqsubseteq  \left(\bigwedge_{k\in P} k\right),T\sqsubseteq\left(\bigwedge_{k\in Q}k\right)\right]\prod_{k\in P\cup Q} a_k\\
&H(S,T)=\sum_{\substack{P\subseteq U,Q\subseteq U\\P\cap Q=\varnothing}} \left[\left(\bigwedge_{k\in P} k\right)=S,T\sqsubseteq\left(\bigwedge_{k\in Q}k\right)\right]\prod_{k\in P\cup Q} a_k
\end{aligned}
$$

那么利用超集 / 子集反演，可以得到：

$$
\begin{aligned}
&G(S,T)=\sum_{S\sqsubseteq P}H(P,T)\implies H(S,T)=\sum_{S\sqsubseteq P} (-1)^{|P|-|S|} G(P,T)\\
&H(S,T)=\sum_{T\sqsubseteq Q} F(S,Q)\implies F(S,T)=\sum_{T\sqsubseteq Q} (-1)^{|Q|-|T|} H(S,Q)\\
&\implies F(S,T)=\sum_{S\sqsubseteq P}\sum_{T\sqsubseteq Q} (-1)^{|P|+|Q|-|S|-|T|} G(P,Q)\\
&\implies F(S,S)=\sum_{S\sqsubseteq P}\sum_{S\sqsubseteq Q} (-1)^{|P|+|Q|} G(P,Q)
\end{aligned}
$$

答案就是：
$$
\sum_{S=0}^{2^n-1}F(S,S)=\sum_{S=0}^{2^n-1}\sum_{S\sqsubseteq P}\sum_{S\sqsubseteq Q}(-1)^{|P|+|Q|} G(P,Q)=\sum_{P=0}^{2^n-1}\sum_{Q=0}^{2^n-1} (-1)^{|P|+|Q|} 2^{|P\land Q|} G(P,Q)
$$

### Part 2

考察 $G(S,T)$，设 $\tau(S)=\{x\mid S\sqsubseteq x,x\in U\}$ 也就是位运算意义下的“超集”集合。

那么对于 $\tau(A)\cap \tau(B)=\tau(A\lor B)$ 集合的数，既可以放在 $P$，也可以放在 $Q$（但是为了维持不交性质，不能两个都不放），其余的只能放到对应的集合中去。因此可以立即写出式子：
$$
G(S,T)=\prod_{k\in \tau(S)}(1+a_k)\cdot \prod_{k\in \tau(T)}(1+a_k)\cdot \prod_{k\in\tau(S\lor T)} \frac{1+2a_k}{(1+a_k)^2}
$$
换元 $f(S)=\prod_{k\in S}(1+a_k),g(S)=\prod_{k\in S} \frac{1+2a_k}{(1+a_k)^2}$，那么可以将答案化简：
$$
\begin{aligned}
&\sum_{P=0}^{2^n-1}\sum_{Q=0}^{2^n-1} (-1)^{|P|+|Q|} 2^{|S\land T|} G(P,Q)\\
&=\sum_{S=0}^{2^n-1}\sum_{T=0}^{2^n-1} (-1)^{|S|+|T|}2^{|S\land T|}f(\tau(S))f(\tau(T))g(\tau(S\lor T))
\end{aligned}
$$
注意到 $|S\land T|+|S\lor T|=|S|+|T|$，因此得到：
$$
\begin{aligned}
&\sum_{S=0}^{2^n-1}\sum_{T=0}^{2^n-1}(-1)^{|S|+|T|}2^{|S|+|T|-|S\lor T|}f(\tau(S))f(\tau(T))g(\tau(S\lor T))\\
=&\sum_{A=0}^{2^n-1}2^{-|A|}g(\tau(A))\sum_{S\lor T=A} (-2)^{|S|}f(\tau(S))\cdot (-2)^{|T|}f(\tau(T))
\end{aligned}
$$
对于 $f\circ \tau,g\circ \tau$，可以看成高维后缀积，利用 Sum over Subsets DP $O(n2^n)$ 计算出来，而原式可以看成一个 OR 卷积的形式，使用 FMT 做即可，时间复杂度也是 $O(n 2^n)$，故总时间复杂度 $O(Tn 2^n)$。

### Part 3

你以为你就做完了吗？不！由于不保证 $a_i\neq p-1$，所以 $g(S)$ 可能无意义。这时不妨将所有 $f(S)$ 中的 $0$ 和 $g(S)$ 除数中的 $0$ 换成一个变量 $x$，这样就变成了一个多项式，照常做高维后缀积以及 FMT，那么我们最终会归约到下面的一个问题：
$$
\lim_{x\to 0} \frac{F(x)}{G(x)}
$$
其中 $F(x),G(x)$ 是多项式函数。在本题中 $F(x)$ 的最低次项一定比 $G(x)$ 的高或相等（如果更低就极限不存在了，而在本题中极限是存在的），那么设 $G(x)$ 的最低次项为 $p$，则可以做 $p$ 次 L'Hospital 法则，得到：
$$
\lim_{x\to 0} \frac{F(x)}{G(x)}=\lim_{x\to 0} \frac{F^{(p)} (x)}{G^{(p)} (x)}=\lim_{x\to 0} \frac{F^{(p)}(x)}{p!\cdot [x^p]G(x)}
$$
若 $F(x)$ 的最低次项 $>p$，那么 $\lim_{x\to 0} F^{(p)}(x)=0$，原式 $=0$，否则原式 $=\frac{[x^p] F(x)}{[x^p] G(x)}$。因此实际上我们不需要计算出整个多项式，只需要记录多项式的最低次项即可，这样时间复杂度不变。

## 代码

```cpp
#include <bits/stdc++.h>
#define popcnt __builtin_popcount
using std::cin, std::cout;

constexpr int mod = 998244353, inv2 = (mod + 1) >> 1;
int A(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int S(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int M(int x, int y){ return 1ll * x * y % mod; }
int P(int x, int y){ int ans = 1; for(;y;x=M(x,x),y>>=1) if(y & 1) ans = M(ans, x); return ans; }
int I(int x){ return P(x, mod - 2); }
template<class T> int Fit(T x){ return (x % mod + mod) % mod; }

namespace solution{
    const int N = 25, N_ = (1 << 20) + 5;
    int n, a[N_];
    struct ZP {
        int val, deg;
        ZP(int v = 0, int d = 0) : val(v), deg(d) {}
        ZP operator-() const { return {S(0, val), deg}; }
        ZP operator+(const ZP& rhs) const {
            ZP res = deg < rhs.deg ? *this : rhs;
            if(deg == rhs.deg) res.val = A(val, rhs.val);
            return res;
        }
        ZP operator*(const ZP& rhs) const { return {M(val, rhs.val), deg + rhs.deg}; }
    } f[N_], g[N_];
    void solve(){
        cin >> n;
        for(int i=0;i<(1<<n);i++){
            cin >> a[i];
            if(a[i] != mod - 1){
                int p = a[i] + 1, pi = I(p);
                f[i] = {p, 0}, g[i] = {M(A(p, a[i]), M(pi, pi)), 0};
            }
            else f[i] = {1, 1}, g[i] = {mod - 1, -2};
        }
        for(int i=1;i<(1<<n);i<<=1){
            for(int j=0;j<(1<<n);j++) if(j & i) f[j ^ i] = f[j ^ i] * f[j], g[j ^ i] = g[j ^ i] * g[j];
        }
        for(int i=0;i<(1<<n);i++) f[i] = f[i] * ZP(P(mod - 2, popcnt(i))), g[i] = g[i] * ZP(P(inv2, popcnt(i)));
        for(int i=1;i<(1<<n);i<<=1){
            for(int j=0;j<(1<<n);j++) if(j & i) f[j] = f[j] + f[j ^ i];
        }
        for(int i=0;i<(1<<n);i++) f[i] = f[i] * f[i];
        for(int i=1;i<(1<<n);i<<=1){
            for(int j=0;j<(1<<n);j++) if(j & i) f[j] = f[j] + (-f[j ^ i]);
        }
        int ans = 0;
        for(int i=0;i<(1<<n);i++) if(f[i].deg == -g[i].deg) ans = A(ans, M(f[i].val, g[i].val));
        cout << ans << '\n';
    }
    void clear(){}
}

signed main(){
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int c, T; cin >> c >> T;
    while(T--) solution::solve(), solution::clear();
    return 0;
}

// [P_13275_NOI_2025_集合.cpp] Think twice, code once.
// Written by xiezheyuan
```

---

## 作者：Southern_Dynasty (赞：2)

考虑容斥。我们钦定 $f(P)\subseteq x,f(Q)\subseteq y$，设这种情况下的权值和为 $w_{x,y}$，则其对答案的贡献系数为：

$$
\sum_{i\subseteq x \ \text{and} \ y}(-1)^{|x|-|i|+|y|-|i|}
$$

$$
=2^{|x \ \text{and} \  y|}(-1)^{|x|+|y|}
$$

因此只需要快速计算 $w_{x,y}$。其可以写成：

$$
\prod_{x\subseteq i,y \not\subseteq i}(a_i+1)\prod_{x\not\subseteq i,y \subseteq i}(a_i+1)\prod_{x\subseteq i,y \subseteq i}(2a_i+1)
$$

$$
=\prod_{x\subseteq i}(a_i+1)\prod_{y\subseteq i}(a_i+1)\prod_{x \ \text{or} \ y\subseteq i}\frac{2a_i+1}{(a_i+1)^2}
$$

设前者为 $f_x$，后者为 $g_x$，则可以高维前缀和 $O(n2^n)$ 维护之。而对于贡献系数，我们有 $|x \ \text{and} \ y|=|x|+|y|-|x\ \text{or} \ y|$，故可以将系数放进 $f,g$ 中。故我们只需要求出 $\sum_{x,y}f_xf_yg_{x\ \text{or} \ y}$。即只需要做一遍 $f*f$ 的 OR 卷积即可。

发现 $a_i=-1$ 的时候乘积会出现 $0$，如果不会处理就只能获得 $68$ 分。但是注意到，在 FMT 的过程中，我们需要求出子集内所有 $f$ 的和。而对于这些 $f$ 显然只有 $0$ 的个数**最少**者可能有用，因此就可以维护了。复杂度 $O(n2^n)$，可以获得 $100$ 分。

---

## 作者：RainWetPeopleStart (赞：0)

场外选手，这个题只会 $O(8^n)$。

先考虑一个朴素 DP，$dp_{i,j,k}$ 表示考虑到第 $i$ 个数，$f(P)=j,f(Q)=k$ 的答案，转移枚举当前元素在哪个集合，这样就可以做到 $O(8^n)$。

发现直接优化很不可做，考虑把后两位压成集合幂级数，用 $[x^jy^k]F(i)$ 表示 $dp_{i,j,k}$。（这里把 $f(P),f(Q)$ 当作集合）

根据题解，我们继续往下做。

下文用集合的形式表示 $a$ 的下标，并记 $U=\{1,2,\dots ,n\},2^U=\{S|S\subseteq U\}$。

发现上文的转移是 and 卷积的形式，用 and 卷积表示 $F(2^n-1)$，即 $\prod\limits_{S\in 2^U}(a_Sx^S+a_Sy^S+1)$。（这里乘法是 and 卷积）

对于 and 卷积而言，考虑 FMT，这里的 FMT 就相当于对 $x,y$ 同时做高维后缀和。

因为初始只有 $x^Uy^U$ 次项是 $1$，所以做完 FMT 后点值的每一项都是 $1$。

由此，最后点值的 $x^Sy^T$ 次项应为 $\prod\limits_{P\in 2^U}(a_P([S\subseteq P]+[T\subseteq P])+1)$。

发现里面的式子同时和 $S,T$ 有关，考虑拆贡献，对 $a_P$ 的系数分类讨论，发现 $a_P$ 系数为 $1$ 时恰成立一个不好刻画。

考虑容斥，以 $[S\subseteq P][T\nsubseteq P]$ 为例，可以把 $T$ 的限制拆掉，变为 $[S\subseteq P](1-[T\subseteq P])$，即 $[S\subseteq P]-[(S \cup T)\subseteq P]$。

发现右边的东西就是 $a_P$ 的系数为 $2$ 的充要条件，然后就能做了。

具体的，先考虑 $a_P$ 系数为 $1$ 的贡献，由上文，这一部分的贡献是 $\dfrac{\prod\limits_{S\subseteq P}(a_P+1)\prod\limits_{T\subseteq P}(a_P+1)}{\prod\limits_{(S\cup T)\subseteq P}(a_P+1)^2}$。

然后是 $a_P$ 系数为 $2$，即 $\prod\limits_{(S\cup T)\subseteq P}(2a_P+1)$。

整理一下，记 $A_S=\prod\limits_{S\subseteq P}\dfrac{2a_P+1}{(a_P+1)^2},B_S=\prod\limits_{S\subseteq P}(a_P+1)$，则最后 $x^Sy^T$ 项的点值为 $B_SB_TA_{S\cup T}$。

再考虑点值是如何贡献到答案的，发现做完 IFMT 后只有形如 $x^Sy^S$ 的项能贡献到答案。

这启示我们考虑点值的 $x^{T1}y^{T2}$ 次项对 $x^Sy^S$ 的贡献系数，因为在 IFMT 时，$|T1|,|T2|$ 每变化 $1$ 就要乘上 $-1$ 的系数，所以贡献系数为 $[S\subseteq T1][S\subseteq T2](-1)^{|T1|-|S|+|T2|-|S|}=[S\subseteq(T1\cap T2)](-1)^{|T1|+|T2|}$。

因为 $(-1)^{|T1|+|T2|}$ 与 $S$ 无关，固定 $T1,T2$，满足条件的 $S$ 只有 $2^{|T1\cap T2|}$ 个，所以点值的 $x^Sy^T$ 项对答案的贡献为 $B_SB_TA_{S\cup T}2^{|S\cap T|}(-1)^{|S|+|T|}$。

然后拆成只与 $S,T,S\cup T$ 有关的项，即 $B_SB_TA_{S\cup T}\dfrac{2^{|S|}2^{|T|}}{2^{|S \cup T|}}(-1)^{|S|}(-1)^{|T|}$。

接下来问题就相当于计算 $\sum\limits_{S\in 2^U}\sum\limits_{T\in 2^U}B_SB_TA_{S\cup T}\dfrac{2^{|S|}2^{|T|}}{2^{|S \cup T|}}(-1)^{|S|}(-1)^{|T|}$。

枚举 $S\cup T$，原式变为 $\sum\limits_{S\cup T=P}\dfrac{A_P}{2^{|P|}}(\sum\limits_S(-1)^{|S|}2^{|S|}B_S(-1)^{|T|}2^{|T|}B_T)$。

只需要对右边做或卷积即可。

对于 $a_P=998244352$，我们维护出现了几个 $a_P+1=998244353$，即用 $a\times 998244353^b$ 来表示一个数。

求答案时只需判断 $b=0$，因为我们可以说明此时 $b\ge 0$，因此做加减法时只保留 $b$ 绝对值最小的即可。

总复杂度 $O(n2^n)$。

---

## 作者：_lmh_ (赞：0)

本文中将下标的每一个二进制位取反，将按位与运算改成按位或运算——容易发现这和原问题等价。同时，不再区分二进制数和集合。

首先考虑 B 性质怎么做。显然答案为

$$\sum_{s=0}^{2^n-1}([x^sy^s]\prod_{i=0}^{2^n-1}(1+a_ix^i+a_iy^i))$$

其中 $x,y$ 两维均为 or 卷积。

令 $F=\prod_{i=0}^{2^n-1}(1+a_ix^i+a_iy^i)$。

先对 $(1+a_ix^i+a_iy^i)$ 进行 FWT，得到 $\sum_{u=0}^{2^n-1}\sum_{v=0}^{2^n-1}(1+[i\subseteq u]a_i+[i\subseteq v]a_i)x^uy^v$。之后按位乘起来，得到

$$[x^uy^v]FWT(F)=\prod_{i=0}^{2^n-1}(1+[i\subseteq u]a_i+[i\subseteq v]a_i)$$

令 $f_s=\prod_{i\subseteq s}(1+a_i),g_s=\prod_{i\subseteq s}(1+2a_i)$，则

$$[x^uy^v]FWT(F)=f_uf_v\frac{g_{u\cap v}}{f_{u\cap v}^2}$$

则答案等于

$$\sum_{s=0}^{2^n-1}\sum_{u,v\subseteq s}(-1)^{2|s|-|u|-|v|}f_uf_v\frac{g_{u\cap v}}{f_{u\cap v}^2}$$

将 $(-1)^{2|s|-|u|-|v|}=(-1)^{|u|+|v|}$ 拆到 $f$ 里面，同时将 $g_u$ 除以 $f_u^2$，则答案等于

$$\sum_{s=0}^{2^n-1}\sum_{u,v\subseteq s}f_uf_vg_{u\cap v}=\sum_{u,v}f_uf_vg_{u\cap v}2^{n-|u\cup v|}$$

将 $2^{n-|u\cup v|}$ 拆成 $2^{-u}2^{-v}2^{n+|u\cap v|}$（这是最难的一步），则原式只和 $u,v,u\cap v$ 有关，可以直接 FWT 做。

没有特殊性质的时候，$f$ 的逆元可能不存在。此时考虑扩域，将 $f$ 表示为 $f'\cdot MOD^{f^\star}$，FWT 时只转移 $f^\star$ 相同的位置，就是对的——如果一个位置和另一个位置的 $f^\star$ 相同，那么转移路径上每个位置的 $f^\star$ 都相同。

---


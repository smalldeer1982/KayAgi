# [NOI2016] 循环之美

## 题目描述

牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 $k$ 进制下，一个数的小数部分是纯循环的，那么它就是美的。现在，牛牛想知道：对于已知的十进制数 $n$ 和 $m$，在 $k$ 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 $\frac xy$ 表示,其中 $1≤x≤n,1≤y≤m$，且 $x,y$ 是整数。一个数是纯循环的，当且仅当其可以写成以下形式：

$$a.\dot{c_1} c_2 c_3 \dots c_{p - 1} \dot{c_p}$$

其中，$a$ 是一个整数，$p≥1$；对于 $1≤i≤p$，$c_i$ 是 $k$ 进制下的一位数字。

例如，在十进制下，$0.45454545……=0.\dot {4} \dot {5}$ 是纯循环的，它可以用 $\frac {5}{11}$、$\frac{10}{22}$ 等分数表示；在十进制下，$0.1666666……=0.1\dot6$ 则不是纯循环的，它可以用 $\frac 16$ 等分数表示。需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 $0$ 的循环或是 $k-1$ 的循环；而一个小数部分非 $0$ 的有限小数不是纯循环的。

## 说明/提示

### 样例解释

满足条件的数分别是：

$\frac 11=1.0000\ldots$

$\frac 13=0.3333\ldots$

$\frac 21=2.0000\ldots$

$\frac 23=0.6666\ldots$

$\frac 11$ 和 $\frac 22$ 虽然都是纯循环小数，但因为它们相等，因此只计数一次；同样，$\frac 13$ 和 $\frac 26$ 也只计数一次。

### 数据范围

对于所有的测试点，保证 $1\leq n\leq 10^9$，$1\leq m \leq 10^9$，$2\leq k \leq 2\times 10^3 $。

对于每个测试点，有以下约束（其中留空的表示没有特殊的约束）：

::cute-table{tuack}

| 测试点编号 |         $n$         |     $m$     |     $k$     |
| :--------: | :-----------------: | :---------: | :---------: |
|    $1$     |      $\leq 10$      |  $\leq 20$  |    $=2$     |
|    $2$     |     $\leq 100$      | $\leq 10^4$ |    ^     |
|    $3$     |     $\leq 10^3$     |             |    ^     |
|    $4$     |     $\leq 10^4$     |             |    ^     |
|    $5$     |      $\leq 10$      |  $\leq 20$  |    $=3$     |
|    $6$     |     $\leq 100$      | $\leq 10^4$ |    ^     |
|    $7$     |     $\leq 10^3$     |             |    ^     |
|    $8$     |     $\leq 10^4$     |             |    ^     |
|    $9$     |      $\leq 10$      |  $\leq 20$  | $\leq 100$  |
|    $10$    |     $\leq 100$      | $\leq 10^4$ | ^  |
|    $11$    |     $\leq 10^3$     |             | $\leq 10^3$ |
|    $12$    |     $\leq 10^4$     |             |             |
|    $13$    |     $\leq 10^5$     | $\leq 10^8$ | $\leq 100$  |
|    $14$    | $\leq 2\times 10^5$ |             | $\leq 10^3$ |
|    $15$    | $\leq 5\times10^5$  |             |             |
|    $16$    |     $\leq 10^6$     | $\leq 10^8$ | $\leq 100$  |
|    $17$    | $\leq 2\times 10^6$ |             | $\leq 10^3$ |
|    $18$    | $\leq 5\times 10^6$ |             |             |
|    $19$    |     $\leq 10^7$     | $\leq 10^8$ |    $100$    |
|    $20$    | $\leq 2\times10^7$  |             | $\leq 10^3$ |
|    $21$    | ^  |             |             |
|    $22$    |     $\leq 10^8$     | $\leq 10^8$ |             |
|    $23$    |     ^     | ^ |             |
|  $24,25$   |                     |             |             |

 
### 提示

这部分将提供一个将分数化为对应的小数的方法，如果你已经熟悉这个方法，你不必阅读本提示。

分数可以通过除法，用分子除以分母化为对应的小数。有些分数在除法过程中无法除尽,这样的分数在不断进行的除法过程中余数一定会重复出现。从商数的个位所对应的余数起，设第一次重复出现的余数前两次出现的位置所对应的商数位分别是小数点后第 $a$ 位和小数点后第 $b$ 位（特殊地：如果其中一个对应的商数位是个位，则认为 $a=0$；不妨设 $a<b$），则其循环部分可以用小数点后第 $a+1$ 位到小数点后第 $b$ 位的循环来表示。

例如：在十进制下，将 $\frac 5{11}$ 转化为小数时，个位开始的商数依次为 $4,5,4,\ldots$，对应的余数分别为 $6,5,6,\ldots$。余数第一次重复出现的位置是个位和小数点后第 $2$ 位,那么 $a=0,b=2$。

$a=0,b=2$ 即其循环部分可以用小数点第 $1$ 位到第 $3$ 位来表示。表示为：$\frac 5{11}=0.45454545\ldots=0.\dot4\dot5$。

在十进制下，将 $\frac 16$ 转化为小数时,个位开始的商数依次为 $1,6,6,\ldots$，对应的余数分别为 $4,4,4,\ldots$。余数第一次重复出现的位置是小数点后第 $1$ 位和小数点后第 $2$ 位,即其循环部分可以用小数点后第 $2$ 位来表示。表示为：$\frac 16=0.1666……=0.1\dot6$。

需要注意的是：商数重复出现并不代表进入了循环节。

## 样例 #1

### 输入

```
2 6 10```

### 输出

```
4```

# 题解

## 作者：Kelin (赞：116)

题意:求$\sum_{x=1}^n\sum_{y=1}^m\frac{x}{y}$在$k$进制下能表示成循环节从第一位小数开始的无限循环小数或整数的最简分数个数


假设$\frac{x}{y}$的循环节长度为$l$


$\Rightarrow [\frac{xk^l}{y}]=[\frac{x}{y}]$


这里中括号表示其小数部分,意思就是把小数点往后挪$l$位,小数部分还是相同


比如$1.123123\ldots$小数点往后挪3位变成$1123.123\ldots$


参照10进制下小数点往后挪$l$位就是乘以$10^l$


那么$k$进制下小数点往后挪$l$位就是乘以$k^l$


$\Rightarrow \frac{xk^l}{y}-\lfloor\frac{xk^l}{y}\rfloor=\frac{x}{y}-\lfloor\frac{x}{y}\rfloor$


$\Rightarrow xk^l-\lfloor\frac{xk^l}{y}\rfloor*y=x-\lfloor\frac{x}{y}\rfloor*y$


$\Rightarrow xk^l\equiv x\mod y$


题目要求最简分数,所以$(x,y)=1$


$\Rightarrow k^l\equiv1\mod y$


$\Rightarrow (k,y)=1$


$\Rightarrow Ans=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$


那么接下来就有两条路可以走了


## 一:考虑处理$[(i,j)=1]$

(有公式恐惧症下转法二)


$\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$


$=\sum_{j=1}^m[(j,k)=1]\sum_{i=1}^n[(i,j)=1]$


$=\sum_{j=1}^m[(j,k)=1]\sum_{i=1}^n\sum_{d|(i,j)}\mu(d)$


$=\sum_{j=1}^m[(j,k)=1]\sum_{i=1}^n\sum_{d|i,d|j}\mu(d)$

$=\sum_{j=1}^m[(j,k)=1]\sum_{d|j}^n\mu(d)\frac{n}{d}$


$=\sum_{d=1}^n\mu(d)\frac{n}{d}\sum_{j=1}^m[d|j][(j,k)=1]$


$=\sum_{d=1}^n\mu(d)\frac{n}{d}\sum_{jd=1}^m[d|jd][(jd,k)=1]$


$j$用$jd$替换一下来减少限制(下同)


$=\sum_{d=1}^n\mu(d)\frac{n}{d}\sum_{j=1}^{\frac{m}{d}}[(jd,k)=1]$


$=\sum_{d=1}^n\mu(d)[(d,k)=1]\frac{n}{d}\sum_{j=1}^{\frac{m}{d}}[(j,k)=1]$


 
考虑$f(n)=\sum_{i=1}^n[(i,k)=1]=\frac{n}{k}\phi(k)+f(n\mod k)$


暴力$O(k\log k)\gcd$算一下$f(1)\ldots f(k)$


接下来貌似又有两条路可以走了


#### ①:考虑化简式子


考虑$g(n,k)=\sum_{d=1}^n\mu(d)[(d,k)=1]$


$=\sum_{d=1}^n\mu(d)\sum_{p|(d,k)}\mu(p)$


$=\sum_{d=1}^n\mu(d)\sum_{p|d,p|k}\mu(p)$

$=\sum_{d=1}^n\sum_{p|d}\mu(d)\sum_{p|k}\mu(p)$

$=\sum_{p|k}\mu(p)\sum_{dp=1}^n\sum_{p|dp}\mu(dp)$

$=\sum_{p|k}\mu(p)\sum_{d=1}^{\frac{n}{p}}\mu(dp)$


如果$(d,p)\neq1$,那么$\mu(dp)=0$


$=\sum_{p|k}\mu(p)\sum_{d=1}^{\frac{n}{p}}\mu(dp)[(d,p)=1]$


$=\sum_{p|k}\mu(p)\sum_{d=1}^{\frac{n}{p}}\mu(d)\mu(p)[(d,p)=1]$


$=\sum_{p|k}\mu(p)^2\sum_{d=1}^{\frac{n}{p}}\mu(d)[(d,p)=1]$


$=\sum_{p|k}\mu(p)^2g(\frac{n}{p},p)$


边界$g(0,k)=0$


$g(n,1)=\sum_{d=1}^n\mu(d)$直接杜教筛


复杂度是$O$(($k$的质因子个数)$\sqrt n+n^{\frac{2}{3}}$)

```c++
#include<map>
#include<cmath>
#include<cstdio>
#include<algorithm>
#define fp(i,a,b) for(int i=a,I=b;i<=I;++i)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
const int N=7e5+5,E=2e6+5;
typedef int arr[N];typedef long long ll;
struct Am{int nx,x,w;}e1[E];
struct Ans{int nx,n,m,k;ll w;}e2[E];
int n,m,k,M,c1,c2,K[2000],f1[E],f2[E];arr is,pr,mu,Smu;
int Sm(int x){
    if(x<=M)return Smu[x];
    int u=(x+2017)%E;
    for(int i=f1[u];i;i=e1[i].nx)if(e1[i].x==x)return e1[i].w;
    e1[++c1]=Am{f1[u],x,1};f1[u]=c1;
    int&w=e1[c1].w,i=2,j=sqrt(x);
    for(;i<=j;++i)w-=Sm(x/i);
    for(;i<=x;i=j+1)j=x/(x/i),w-=(j-i+1)*Sm(x/i);
    return w;
}
ll sol(int n,int m,int k){
    if(!n||!m)return 0;
    int u=(2017ll*n+m+k)%E;
    for(int i=f2[u];i;i=e2[i].nx)if(e2[i].n==n&&e2[i].m==m&&e2[i].k==k)return e2[i].w;
    e2[++c2]=Ans{f2[u],n,m,k,0};f2[u]=c2;ll&w=e2[c2].w;
    if(k==1){
        if(n>m)swap(n,m);
        int i=1,j=sqrt(n),s,t=0,x,y;
        for(;i<=j;++i,t=s)s=Sm(i),w+=1ll*(n/i)*(m/i)*(s-t);
        for(;i<=n;i=j+1,t=s)x=n/i,y=m/i,j=min(n/x,m/y),s=Sm(j),w+=1ll*x*y*(s-t);
        u=(2017ll*m+n+k)%E;e2[++c2]=Ans{f2[u],m,n,k,w};f2[u]=c2;
    }else for(int i=1;i<=K[0]&&K[i]<=k;++i)
            if(k%K[i]==0&&mu[K[i]])
                w+=sol(m/K[i],n,K[i])*mu[K[i]];
    return w;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d%d",&n,&m,&k);
    M=min(N-5,max(k,min(n,m)));Smu[1]=mu[1]=1;
    fp(i,2,M){
        if(!is[i])pr[++pr[0]]=i,mu[i]=-1;
        for(int j=1,x;j<=pr[0]&&(x=i*pr[j])<=M;++j){
            is[x]=1;if(i%pr[j])mu[x]=-mu[i];else break; 
        }Smu[i]=Smu[i-1]+mu[i];
    }
    fp(i,1,k)if(k%i==0)K[++K[0]]=i;
    printf("%lld",sol(n,m,k));
return 0;
}
```
 
#### ②:考虑分析式子


我们可以把$k$表示成$p^aq$,假设$p$是$k$最小的质因子


对于1到$k$中每一个数可以预处理出他的$p,q$


$g(n,k)=\sum_{d=1}^n\mu(d)[(d,k)=1]=\sum_{d=1}^n\mu(d)[(d,p)=1][(d,q)=1]$


当$(d,q)=1$时只有$(d,p)=1,(d,p)=p$两种情况


所以我们可以转化为求满足$(d,q)=1$的$\mu(d)$减去$(d,q)=1$中满足$(d,p)=p$的$\mu(d)$


即$g(n,k)=\sum_{d=1}^n\mu(d)[(d,q)=1]-\sum_{d=1}^n\mu(d)[(d,q)=1][(d,p)=p]$


$=g(n,q)-\sum_{dp=1}^n\mu(dp)[(dp,q)=1][(dp,p)=p]$


$=g(n,q)-\sum_{d=1}^{\frac{n}{p}}\mu(dp)[(d,q)=1]$


当$(d,p)\neq1$时$\mu(dp)=0$,所以$d$要满足$(d,p)=1$


$=g(n,q)-\sum_{d=1}^{\frac{n}{p}}\mu(dp)[(d,p)=1][(d,q)=1]$


$=g(n,q)-\sum_{d=1}^{\frac{n}{p}}\mu(d)\mu(p)[(d,k)=1]$


$=g(n,q)-\mu(p)\sum_{d=1}^{\frac{n}{p}}\mu(d)[(d,k)=1]$


$=g(n,q)+g(\frac{n}{p},k)$


边界和复杂度是同上
```c++
#include<cmath>
#include<cstdio>
#include<algorithm>
#define fp(i,a,b) for(int i=a,I=b;i<=I;++i)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
const int N=1e6+5,E=2.2*N;
typedef int arr[N];
struct eg{int nx,n,k,w;}e[E];
int n,m,k,M,ce,fi[E],p[2001],q[2001];arr is,pr,mu,Smu,f;
int g(int n,int k){
    if(!n||(n<=M&&k==1))return Smu[n];
    int x=(1LL*n*2017+k)%E;
    for(int i=fi[x];i;i=e[i].nx)if(e[i].n==n&&e[i].k==k)return e[i].w;
    e[++ce]=eg{fi[x],n,k,0};fi[x]=ce;int&w=e[ce].w;
    if(k==1){
        w=1;int i=2,j=sqrt(n),x;
        for(;i<=j;++i)w-=g(n/i,1);
        for(;i<=n;i=j+1)x=n/i,j=n/x,w-=(j-i+1)*g(x,1);
    }else w=g(n,q[k])+g(n/p[k],k);
    return w;
}
int gcd(int a,int b){return!b?a:gcd(b,a%b);}
inline int Sf(int x){return x/k*f[k]+f[x%k];}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d%d",&n,&m,&k);
    M=min(N-5,min(n,m));Smu[1]=mu[1]=1;
    fp(i,2,M){
        if(!is[i])pr[++pr[0]]=i,mu[i]=-1;
        for(int j=1,x;j<=pr[0]&&(x=i*pr[j])<=M;++j){
            is[x]=1;if(i%pr[j])mu[x]=-mu[i];else break;
        }Smu[i]=Smu[i-1]+mu[i];
    }
    fp(i,1,k)f[i]=f[i-1]+(gcd(i,k)==1);
    fp(i,2,k){
        for(int j=2;;++j)if(i%j==0&&!is[j]){p[i]=j;break;}
        for(q[i]=i;q[i]%p[i]==0;)q[i]/=p[i];
    }
    int i=1,j=sqrt(min(n,m)),x,y,s,t=0;long long w=0;
    for(;i<=j;++i,t=s)s=g(i,k),w+=1ll*(n/i)*Sf(m/i)*(s-t);
    for(;i<=min(n,m);i=j+1,t=s)x=n/i,y=m/i,j=min(n/x,m/y),
        s=g(j,k),w+=1ll*x*Sf(y)*(s-t);
    printf("%lld",w);
return 0;
}
```

 
## 二:考虑处理$[(j,k)=1]$


令$f(n,m,k)=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$


$=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1]\sum_{d|(j,k)}\mu(d) $


$=\sum_{i=1}^n\sum_{jd=1}^m[(i,jd)=1]\sum_{d|jd,d|k}\mu(d) $

$=\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^{\frac{m}{d}}[(i,jd)=1]$


$=\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^{\frac{m}{d}}[(i,j)=1][(i,d)=1]$


$=\sum_{d|k}\mu(d)f(\frac{m}{d},n,d)$


边界$f(0,m,k)=f(n,0,k)=0$


然后$k=1$就是简单处理一下$\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1]=\sum_{d=1}^n\mu(d)\frac{n}{d}\frac{m}{d}$就$ok$了


复杂度是$O(\log n\log m\sqrt n+n^{\frac{2}{3}})$

```c++
#include<map>
#include<cmath>
#include<cstdio>
#include<algorithm>
#define fp(i,a,b) for(int i=a,I=b;i<=I;++i)
#define fd(i,a,b) for(int i=a,I=b;i>=I;--i)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
const int N=1e7+5;
typedef int arr[N];
typedef long long ll;
struct da{int n,m,k;inline bool operator<(const da&b)const{return n==b.n?(m==b.m?k<b.k:m<b.m):n<b.n;}};
int n,m,k,M,K[2000];arr is,pr,mu,Smu;map<int,int>Am;map<da,ll>Ans;
int Sm(int x){
    if(x<=M)return Smu[x];
    if(Am[x])return Am[x];
    int w=1,i=2,j=sqrt(x);
    for(;i<=j;++i)w-=Sm(x/i);
    for(;i<=x;i=j+1)j=x/(x/i),w-=(j-i+1)*Sm(x/i);
    return Am[x]=w;
}
ll sol(int n,int m,int k){
    if(!n||!m)return 0;
    da now=da{n,m,k};
    if(Ans[now])return Ans[now];ll w=0;
    if(k==1){
        if(n>m)swap(n,m);
        int i=1,j=sqrt(n),s,t=0,x,y;
        for(;i<=j;++i,t=s)s=Sm(i),w+=1ll*(n/i)*(m/i)*(s-t);
        for(;i<=n;i=j+1,t=s)x=n/i,y=m/i,j=min(n/x,m/y),s=Sm(j),w+=1ll*x*y*(s-t);
        Ans[da{m,n,k}]=w;
    }else for(int i=1;i<=K[0]&&K[i]<=k;++i)
            if(k%K[i]==0&&mu[K[i]])
                w+=sol(m/K[i],n,K[i])*mu[K[i]];
    return Ans[now]=w;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d%d",&n,&m,&k);
    M=min((int)1e7,max(k,min(n,m)));mu[1]=1;
    fp(i,2,M){
        if(!is[i])pr[++pr[0]]=i,mu[i]=-1;
        for(int j=1,x;j<=pr[0]&&(x=i*pr[j])<=M;++j){
            is[x]=1;
            if(i%pr[j])mu[x]=-mu[i];
            else{mu[x]=0;break;}
        }
    }fp(i,1,M)Smu[i]=Smu[i-1]+mu[i];
    fp(i,1,k)if(k%i==0)K[++K[0]]=i;
    printf("%lld",sol(n,m,k));
return 0;
}
```

如果是考场我还是会选择法二的


---

## 作者：MKCCT (赞：50)

upd：一个更简单的做法。

相等的纯循环小数只算一次，即对于一个分数 $\frac{x}{y}$ 只在 $x\perp y$ 时统计。

如果一个 $k$ 进制最简分数 $\frac{x}{y}$ 是纯循环小数，设其循环节长度为 $l$，必然有 
$$\left\{\frac{xk^l}{y}\right\}=\left\{\frac{x}{y}\right\}$$
其中 $\{x\}$ 表示取 $x$ 的小数部分。即
$$\begin{aligned}\frac{xk^l}{y}-\left\lfloor\frac{xk^l}{y}\right\rfloor&=\frac{x}{y}-\left\lfloor\frac{x}{y}\right\rfloor \\ xk^l-y\left\lfloor\frac{xk^l}{y}\right\rfloor&=x-y\left\lfloor\frac{x}{y}\right\rfloor \\ xk^l&\equiv x\pmod y \\ k^l &\equiv 1\pmod y \end{aligned}$$

这推出 $k\perp y$。

于是答案为
$$\sum_{i=1}^n\sum_{j=1}^m [i\perp j][k\perp j]$$
接下来是传统艺能
$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^m [i\perp j][k\perp j]&=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j}\mu(d)[k\perp j] \\ &=\sum_{d=1}^{\min(n,m)} \mu(d)\sum_{i=1}^{\lfloor n/d \rfloor}\sum_{j=1}^{\lfloor m/d \rfloor}[jd\perp k] \\ &=\sum_{d=1}^{\min(n,m)} \mu(d)\left\lfloor \frac{n}{d}\right\rfloor\sum_{j=1}^{\lfloor m/d \rfloor}[j\perp k][d\perp k] \\ &=\sum_{d=1}^{\min(n,m)} \mu(d)[d\perp k]\left\lfloor \frac{n}{d}\right\rfloor\sum_{j=1}^{\lfloor m/d \rfloor}[j\perp k]\end{aligned}$$

考虑后面的那个和式怎么求，不妨设 $g(n)=\sum\limits_{i=1}^n[i\perp k]$，容易发现当 $i>k$ 时根据 $\gcd(i,k)=\gcd(i+k,k)$，答案呈现一个长为 $k$ 的循环，换句话说，就是
$$g(n)=\left\lfloor\frac{n}{k}\right\rfloor\varphi(k)+g(n\bmod k)$$
这一部分可以做到 $O(k)-O(1)$。

代回原式
$$\sum_{d=1}^{\min(n,m)} \left\lfloor \frac{n}{d}\right\rfloor g\left(\left\lfloor \frac{m}{d} \right\rfloor\right)\mu(d)[d\perp k]$$

前面两项可以整除分块，矛盾转移为求后面两项的前缀和，不妨设 $f(n)=\sum\limits_{i=1}^n\mu(i)[i\perp k]$，继续干苦力活
$$\begin{aligned} f(n)&=\sum_{i=1}^n\mu(i)[i\perp k] \\ &=\sum_{i=1}^n[i\perp k]f\left(\left\lfloor \frac{n}{i} \right\rfloor\right)-\sum_{i=2}^n[i\perp k]f\left(\left\lfloor \frac{n}{i} \right\rfloor\right)\end{aligned}$$

考虑前一个怎么求
$$\begin{aligned}\sum_{i=1}^n[i\perp k]f\left(\left\lfloor \frac{n}{i} \right\rfloor\right)&=\sum_{i=1}^n[i\perp k]\sum_{j=1}^{\lfloor n/i\rfloor}[j\perp k]\mu(j) \\ &=\sum_{i=1}^n\sum_{j=1}^{\lfloor n/i\rfloor}[ij\perp k]\mu(j)\end{aligned}$$

换一种写法，枚举 $ij$
$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^{\lfloor n/i\rfloor}[ij\perp k]\mu(j)&= \sum_{i=1}^n\sum_{d|i}[i\perp k]\mu(d) \\ &=\sum_{i=1}^n[i\perp k][i=1] \\ &=1\end{aligned}$$

最终有
$$f(n)=1-\sum_{i=2}^n[i\perp k]f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$$
这个式子就是一个杜教筛的形式，而 $[i\perp k]$ 的前缀和我们已经求出来了，就是 $g$。

时间复杂度大概是 $O(n^{\frac{2}{3}}+k)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=2005,M=1e6+5;
int n,m,k,mu[M],p[M],v[M],g[N],f[M];
ll ans; map<int,int> ro;

inline int G(int x) {return x/k*g[k]+g[x%k];}

void init()
{
	for(int i=1;i<=k;++i) g[i]=g[i-1]+(__gcd(i,k)==1);
	mu[1]=f[1]=1;
	for(int i=2;i<=M-5;++i)
	{
		if(!v[i]) p[++p[0]]=i,mu[i]=-1;
		for(int j=1;j<=p[0]&&i*p[j]<=M-5;++j)
		{
			v[i*p[j]]=1;
			if(i%p[j]==0) break;
			mu[i*p[j]]=-mu[i];
		}
		f[i]=f[i-1]+mu[i]*(G(i)-G(i-1));
	}
}

int F(int x)
{
	if(x<=M-5) return f[x];
	if(ro.find(x)!=ro.end()) return ro[x];
	int res=1;
	for(int l=2,r;l<=x;l=r+1)
		r=x/(x/l),res-=F(x/l)*(G(r)-G(l-1));
	return ro[x]=res;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k),init();
	for(int l=1,r;l<=min(n,m);l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		ans+=1LL*(n/l)*G(m/l)*(F(r)-F(l-1));
	}
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：yybyyb (赞：41)

##题解

到底在求什么呢。。。

首先不管他$K$进制的问题啦，真是烦死啦


所以，相当于有一个分数$\frac{i}{j}$

因为值要不相等

所以有$i \perp j$，也就是$gcd(i,j)=1$


现在考虑$K$进制

先从熟悉的$10$进制入手

如果一个最简分数是纯循环小数

我们知道，他的分母里面不含$2,5$

而且，巧极了$10=2*5$

于是乎，$YY$一下

如果$K$进制中一个分数是纯循环小数

那么分母与$K$互质

[证明戳这里(orz LCF 学长)](https://www.cnblogs.com/lcf-2000/p/6250330.html)


所以，问题就变成啦


$$\sum_{i=1}^n\sum_{j=1}^m[i \perp j][j \perp k]$$

也就是

$$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)==1][gcd(j,k)==1]$$

换个顺序算

$$\sum_{i=1}^n\sum_{j=1}^m[gcd(j,k)==1][gcd(i,j)==1]$$

$$\sum_{j=1}^m[gcd(j,k)==1]\sum_{i=1}^n[gcd(i,j)==1]$$


$$\sum_{j=1}^m[gcd(j,k)==1]\sum_{i=1}^n\sum_{d|i,d|j}\mu(d)$$
把$d$提出来

$$\sum_{d=1}^n\mu(d)\sum_{d|i}^n\sum_{d|j}^m[gcd(j,k)==1]$$
$$\sum_{d=1}^n[d \perp k ]\mu(d)\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(j,k)==1]$$

$$\sum_{d=1}^n[d \perp k ]\mu(d)[\frac{n}{d}]\sum_{j=1}^{m/d}[gcd(j,k)==1]$$



现在相当于要求两个东西的前缀和：

$$f(x)=\sum_{i=1}^x[gcd(i,k)=1]$$

$$S(x)=\sum_{i=1}^x[i \perp k]\mu(i)$$


先看$f(x)$

$x$相当于被分为了若干个大小为$k$的段

若在第一段中，$a \perp k$

则 $(a+nk) \perp k$

同样的，最后一段可能不满，所以可以单独拎出来考虑

所以，我们可以推出：

$$f(x)=[\frac{x}{k}]f(k)+f(x\%k)$$

$k<=2000$

所以预处理出$k$以内的值，就可以直接算了


---

现在的问题在于第二个$S(x)$

$$S(x,k)=\sum_{i=1}^x[i \perp k]\mu(i) $$

$$=\sum_{i=1}^x\mu(i)[gcd(i,k)==1]$$

$$=\sum_{i=1}^x\mu(i)\sum_{d|gcd(i,k)}\mu(d)$$

$$=\sum_{i=1}^x\mu(i)\sum_{d|i,d|k}\mu(d)$$
$$=\sum_{d|k}\mu(d)\sum_{d|i}\mu(i)$$
$$=\sum_{d|k}\mu(d)\sum_{i=1}^{x/d}\mu(id)$$

如果$gcd(i,d)\neq1$，那么

$\mu(id)=0$，对答案不会产生任何影响

$$=\sum_{d|k}\mu(d)\sum_{i=1,i \perp d}^{x/d}\mu(i)\mu(d)$$

$$=\sum_{d|k}\mu(d)^2\sum_{i=1,i \perp d}^{x/d}\mu(i)$$


$$=\sum_{d|k}\mu(d)^2\sum_{i=1}^{x/d}[i \perp d]\mu(i)$$

$$=\sum_{d|k}\mu(d)^2S([\frac{x}{d}],d)$$

这样子当$k=1$发现没法递归啦？？？

不记得[这道题目里面](http://www.cnblogs.com/cjyyb/p/8295896.html)推出来的$\mu$的前缀和是啥了？？

所以杜教筛一发呀


---

现在，要求的答案就是：

$$\sum_{d=1}^n[d \perp k ]\mu(d)[\frac{n}{d}]\sum_{j=1}^{m/d}[gcd(j,k)==1]$$


后面的$\sum_j$我们已经可以$O(1)$求啦

前面的利用记忆化也可以很开心的求了

复杂度？？

我也不知道。。

反正能过就行啦

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 10000000
#define ll long long
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int n,K,N,m;
bool pp[5000];
int F[5000];
bool zs[MAX+10];
int tot,pri[MAX],mu[MAX],smu[MAX];
map<pair<int,int>,int> M;
void pre()
{
    for(int i=1;i<=K;++i)pp[i]=__gcd(i,K)==1;
    for(int i=1;i<=K;++i)F[i]=F[i-1]+pp[i];
    zs[1]=true;mu[1]=1;
    for(int i=2;i<=N;++i)
    {
        if(!zs[i])pri[++tot]=i,mu[i]=-1;
        for(int j=1;j<=tot&&i*pri[j]<=N;++j)
        {
            zs[i*pri[j]]=true;
            if(i%pri[j])mu[i*pri[j]]=-mu[i];
            else break;
        }
    }
    for(int i=1;i<=N;++i)smu[i]=smu[i-1]+mu[i];
}
int SF(int x){return (x/K)*F[K]+F[x%K];}
int SS(int x,int k)
{
    if((k==1&&x<=N)||(!x))return smu[x];
    if(M[make_pair(x,k)])return M[make_pair(x,k)];
    int ret=0;
    if(k==1)
    {
        ret=1;
        for(int i=2,j;i<=x;i=j+1)
        {
            j=x/(x/i);
            ret-=(j-i+1)*SS(x/i,1);
        }
    }
    else
    {
        for(int i=1;i*i<=k;++i)
            if(k%i==0)
            {
                if(mu[i])ret+=SS(x/i,i);
                if(i*i!=k&&mu[k/i])
                    ret+=SS(x/(k/i),k/i);
            }
    }
    return M[make_pair(x,k)]=ret;
}
int main()
{
    n=read();m=read();K=read();
    N=MAX;pre();
    ll ans=0,lt=0,nw=0;
    for(int i=1,j;i<=min(n,m);i=j+1)
    {
        j=min(n/(n/i),m/(m/i));
        nw=SS(j,K);
        ans+=1ll*(nw-lt)*(n/i)*SF(m/i);
        lt=nw;
    }
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：_LHF_ (赞：33)

这是一道一题多解的题。

为了防止算重，我们可以只计算最简分数的贡献。根据小奥学习的知识，如果 $x/y$ 是最简分数当且仅当 $x\perp y$。（这里的 $\perp$ 是互质的意思）

然后考虑到是 $k$ 进制下纯循环小数，所以一定有 $y\perp k$。

于是题目就变成了求
$$\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]$$
下面给出一大波解法：
## 法一：
$$\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]$$
$$=\sum_{d=1}^n\mu(d)\sum_{i=1}^\frac{n}{d}\sum_{j=1}^\frac{m}{d}[jd\perp k]$$
为了方便，这里的分数默认向下取整。
$$=\sum_{d=1}^n\mu(d)\frac{n}{d}[d\perp k]\sum_{j=1}^\frac{m}{d}[j\perp k]$$
设 $g(x)=\sum_{i=1}^x[i\perp k]$，那么显然，$g(x)=g(x\mod k)+\frac{x}{k}\varphi(k)$

这一坨可以快速算出，那么原式
$$=\sum_{d=1}^n\mu(d)\frac{n}{d}[d\perp k]g(\frac{m}{d})$$
再设$f(n,k)=\sum_{i=1}^n\mu(i)[i\perp k]$，那么原式
$$=\sum_{l,r}(f(r,k)-f(l-1,k))\frac{n}{d}g(\frac{m}{d})$$
其中 $l,r$ 是数论分块的每个区间。

现在考虑如何计算$f$

$$f(n,k)=\sum_{i=1}^n\mu(i)[i\perp k]$$
$$=\sum_{d|k}\mu(d)\sum_{i=1}^\frac{n}{d}\mu(id)$$
由 $\mu(ab)=\mu(a)\mu(b)[a\perp b]$ 得：
$$=\sum_{d|k}\mu^2(d)\sum_{i=1}^\frac{n}{d}\mu(i)[i\perp d]$$
$$=\sum_{d|k}\mu^2(d)f(\frac{n}{d},d)$$
边界用杜教筛算一算即可。
## 法二：
考虑法一的 $f(n,k)$ 有没有什么更好的计算方法。

设 $p$ 是 $k$ 的一个质因子，我们可以发现，我们其实并不关注 $k$ 中每一个质因子出现的个数，我们只关注其是否出现，那么我们先把 $k$ 中的每个超过一次的质因子变成一次，然后根据容斥可得：
$$f(n,k)=\sum_{i=1}^n\mu(i)[i\perp k/p]-\sum_{i=1}^n\mu(i)[i\perp k/p][p|i]$$
$$=f(n,k/p)-\sum_{i=1}^\frac{n}{p}\mu(ip)[ip\perp k/p]$$
显然 $\mu(p)=-1$，还是按照刚才的套路：
$$=f(n,k/p)+\sum_{i=1}^\frac{n}{p}\mu(i)[i\perp k/p][i\perp p]$$
$$=f(n,k/p)+f(\frac{n}{p},k)$$
## 法三：
我们发现法一和法二都需要多次计算 $f$，能不能减少一点呢？

当然能，首先回到法一的某一步，得到原式
$$=\sum_{d=1}^n\mu(d)\frac{n}{d}[d\perp k]g(\frac{m}{d})$$
盯着这货看，发现好像有什么东西……

我们设 $\displaystyle F(x,k)=\sum_{d=1}^\frac{n}{x}\mu(d)\frac{n}{xd}[d\perp k]g(\frac{m}{xd})$
那么答案就是 $F(1,k)$

$$F(x,k)=\sum_{d=1}^\frac{n}{x}\mu(d)\frac{n}{xd}\sum_{a|d,a|x}\mu(a)g(\frac{m}{xd})$$
$$=\sum_{a|x}\mu(a)\sum_{d=1}^\frac{n}{ax}\frac{n}{axd}\mu(ad)g(\frac{m}{axd})$$
$$=\sum_{a|x}\mu^2(a)\sum_{d=1}^\frac{n}{ax}\frac{n}{axd}\mu(d)[a\perp d]g(\frac{m}{axd})$$
$$=\sum_{a=1}^x\mu^2(a)F(ax,a)$$
边界为 $a=1$ 或者 $x>\min(n,m)$，杜教筛随便搞搞就可以了。
## 法四：
来自一位大佬的神仙做法
还是考虑计算 $f(n,k)$ ，不过这次我们设的是一元函数，即 $f(n)=\sum_{i=1}^n\mu(i)[i\perp k]$，开始搞事情。

$$f(n)=\sum_{i=1}^n[i\perp k]f(\frac{n}{i})-\sum_{i=2}^n[i\perp k]f(\frac{n}{i})$$
考虑如何计算 $\sum_{i=1}^n[i\perp k]f(\frac{n}{i})$

$$=\sum_{i=1}^nf(\frac{n}{i})=\sum_{i=1}^n[i\perp k]\sum_{j=1}^\frac{n}{i}[j\perp k]\mu(j)$$
$$=\sum_{i=1}^nf(\frac{n}{i})=\sum_{i=1}^n\sum_{j=1}^\frac{n}{i}[ij\perp k]\mu(j)$$
$$\sum_{T=1}^n[T\perp k]\sum_{d|T}\mu(d)$$
显然，后面那一坨只有在 $T=1$ 时值为 $1$，其他时候值为 $0$，于是就变成了
$$f(n)=1-\sum_{i=2}^n[i\perp k]f(\frac{n}{i})$$
注意到后面那一坨跟 $g$ 有关，可以快速算出，于是杜教筛即可。
## 法五：
刚才我们一直在 $[i\perp j]$ 上下功夫，我们能不能在 $[j\perp k]$ 上下功夫呢？当然可以，于是原式
$$=\sum_{i=1}^n\sum_{j=1}^m[i\perp j]\sum_{d|k,d|j}\mu(d)$$
$$=\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^\frac{m}{d}[i\perp jd]$$
$$=\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^\frac{m}{d}[i\perp j][i\perp d]$$
咦，好像……

我们设 $\displaystyle S(n,m,k)=\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]$

那么就有
$$S(n,m,k)=\sum_{d|k}\mu(d)S(\frac{m}{d},n,d)$$
递归计算即可。
## 法六：
刚才我们一直都只反演了一个，能不能同时反演两个呢？显然是可以的。

式子比较板，且和第一种相似，过程较长，留给读者自行思考。

---

~~（如果你还有什么新方法可以来告诉本蒟蒻哦）~~

update 2021.7.15 纠正了 
tommy0103 提出的一个错误

update 4.6 修改了一处小错误（话说竟然没有人发现）

---

## 作者：feecle6418 (赞：25)

最无脑、最快的做法。

![](https://cdn.luogu.com.cn/upload/image_hosting/66tex4c7.png)

把 $[(i,j)=1]$ 换成枚举 $p|i,p|j$ 求和 $\mu(p)$，这时 $(j,k)=1$ 就等价于 $(p,k)=1$ 且 $(j/p,k)=1$，因此有 
$$
\sum_{i\le n,j\le m}[(i,j)=1][(j,k)=1]
\\
=\sum_{p}\mu(p)[(p,k)=1]\times \lfloor\frac np\rfloor\times S(\lfloor \frac mp\rfloor)
$$
其中 $S(x)=\sum_{i\le x}[(i,k)=1]$。$S(x)$ 就是 $x/k$ 个 $\varphi(k)$ 加上 $S(x\bmod k)$，可以 $O(1)$ 算出。

现在注意到 $f(x)=\mu(x)\cdot [(x,k)=1]$ 是积性函数，所以可以用 min_25 筛求其在所有点值处的前缀和。

注意筛法的第二步不用枚举质数幂次，所以两部分复杂度都是 $O(n^{3/4}/\log n)$。（不加下面的优化此时已经可以在 uoj 得到最优解了。）

还有一个优化是怎么得到 整除分块值 -> 数组下标 的映射，暴力写法是每次都二分查找，但可以 $O(1)$，这个看代码吧。

最后，使用浮点数乘法代替部分除法。

加入优化后，时间约为原 uoj 最优解的 $1/3$、洛谷公开的最优解的一半。

（由于洛谷最优解时间比我这个还小，而且不公开代码，无法确认是否是面向数据编程，故忽略。）

在所有作者能找到的公开代码 OJ，都是最优解。

---

## 作者：小粉兔 (赞：21)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/NOI2016D1T3.html](https://www.cnblogs.com/PinkRabbit/p/NOI2016D1T3.html)。

两个月之前做的，还是有必要补一下博客。

### 题意简述：

求分子为不超过 $n$ 的正整数，分母为不超过 $m$ 的正整数的所有互不相等的分数中，有多少在 $k$ 进制下的纯循环小数。

### 题解：

设分子为 $x$，分母为 $y$。

首先，因为要求的是互不相等的分数，取最简分数，即 $x\perp y$。

其次，要求是纯循环小数，考虑竖式除法的过程，可以发现 $\displaystyle\frac{x}{y}$ 在 $k$ 进制下纯循环相当于存在正整数 $l$ 使得 $x\equiv x\cdot k^l\pmod{y}$。

由于 $x\perp y$，两边约去 $x$ 得到 $k^l\equiv 1\pmod{y}$，显然当 $k$ 属于 $y$ 的缩系中时可能成立，即 $y\perp k$。

综上，答案为 $\displaystyle\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]$。

为了方便，以下用 $a\div b$ 表示 $\displaystyle\left\lfloor\frac{a}{b}\right\rfloor$。答案为：

$$\begin{aligned}\mathbf{Ans}&=\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]\\&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d|i,d|j}\mu(d)[j\perp k]\\&=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{i=1}^{n\div d}\sum_{j=1}^{m\div d}[jd\perp k]\\&=\sum_{d=1}^{\min(n,m)}\mu(d)(n\div d)\sum_{j=1}^{m\div d}[j\perp k][d\perp k]\\&=\sum_{d=1}^{\min(n,m)}\mu(d)[d\perp k](n\div d)S_{[x\perp k]}(m\div d)\end{aligned}$$

其中 $S_{f}(n)$ 表示 $\displaystyle\sum_{i=1}^{n}f(i)$。  
$S_{[x\perp k]}(n)=(n\div k)\varphi(k)+S_{[x\perp k]}(n\bmod k)$ 可以 $\mathcal{O}(k)$ 预处理，$\mathcal{O}(1)$ 回答询问。

对外层 $n\div d$ 和 $m\div d$ 进行整除分块，问题转化为计算 $\displaystyle\sum_{i=1}^{n}\mu(i)[i\perp k]$。

设 $\displaystyle S(n,k)=\sum_{i=1}^{n}\mu(i)[i\perp k]$，则有：

$$\begin{aligned}S(n,k)&=\sum_{i=1}^{n}\mu(i)[i\perp k]\\&=\sum_{i=1}^{n}\mu(i)\sum_{d|i,d|k}\mu(d)\\&=\sum_{d|k}\mu(d)\sum_{i=1}^{n\div d}\mu(id)\\&=\sum_{d|k}\mu(d)\sum_{i=1}^{n\div d}\mu(i)\mu(d)[i\perp d]\\&=\sum_{d|k}\mu^2(d)\sum_{i=1}^{n\div d}\mu(i)[i\perp d]\\&=\sum_{d|k}\mu^2(d)S(n\div d,d)\end{aligned}$$

递归，记忆化搜索即可。边界：$S(0,k)=0$ 和 $\displaystyle S(n,1)=\sum_{i=1}^{n}\mu(i)$ 使用杜教筛计算。

复杂度大约为 $\mathcal{O}\left(n^{2/3}+\sigma_0(k)\sqrt{n}+k\right)$。

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>

typedef long long LL;
const int MK = 2005;
const int S = 31622;
const int MN23 = 1000005;
const int MP = 78505;
const int MD = 25;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

bool ip[MN23];
int p[MP], pc;
int mu[MN23], Smu[MN23];

inline void Init(int N) {
	mu[1] = 1;
	for (int i = 2; i <= N; ++i) {
		if (!ip[i]) p[++pc] = i, mu[i] = -1;
		for (int j = 1; j <= pc && p[j] * i <= N; ++j) {
			ip[p[j] * i] = 1;
			if (i % p[j]) mu[p[j] * i] = -mu[i];
			else break;
		}
	}
	for (int i = 1; i <= N; ++i) Smu[i] = Smu[i - 1] + mu[i];
}

int N, M, K, N23;
int A[MK], Vl[MD], cd;

std::map<int, LL> mp[MD];

LL Sum(int N, int K) {
	if (!N) return 0;
	if (K == 1 && N <= N23) return Smu[N];
	if (mp[K].count(N)) return mp[K][N];
	if (K > 1) {
		LL Ans = 0;
		for (int j = 1; j <= K; ++j)
			if (Vl[K] % Vl[j] == 0 && mu[Vl[j]])
				Ans += Sum(N / Vl[j], j);
		return mp[K][N] = Ans;
	}
	LL Ans = 1;
	for (int i = 2, j; i <= N; i = j + 1) {
		j = N / (N / i);
		Ans -= (j - i + 1) * Sum(N / i, 1);
	}
	return mp[1][N] = Ans;
}

LL Ans;

int main() {
	scanf("%d%d%d", &N, &M, &K);
	for (int i = 1; i <= K; ++i) A[i] = A[i - 1] + (gcd(i, K) == 1);
	Init(N23 = std::max((int)pow(N, 2./3), K));
	for (int i = 1; i <= K; ++i) if (K % i == 0 && (mu[i] || i == K)) Vl[++cd] = i;
	for (int i = 1, kN, kM, j; i <= N && i <= M; i = j + 1) {
		kN = N / i, kM = M / i;
		j = std::min(N / kN, M / kM);
		Ans = Ans + kN * ((LL)kM / K * A[K] + A[kM % K]) * (Sum(j, cd) - Sum(i - 1, cd));
	}
	printf("%lld\n", Ans);
	return 0;
}
```

---

## 作者：Fading (赞：13)

这个写的比较详细，所以看不懂其他神仙题解的可以看我的

看了题解才知道莫比乌斯函数有这么一个nb的性质……

我还是太$naive$了

然后自己瞎搞……

这题目太神仙了！

原式等价于求

$$\sum_{i=1}^n\sum_{j=1}^m[gcd(j,k)==1][gcd(j,i)==1]$$

~~这个很好想的，找找规律就好了呀~~精髓在推导里

然后上套路

由于是$\sum\sum ab$形式的，不好看也不好拆，所以


$$\Leftrightarrow \sum_{j=1}^m\sum_{i=1}^n[gcd(j,k)==1][gcd(j,i)==1]$$

提一下

$$\Leftrightarrow \sum_{j=1}^m[gcd(j,k)==1]\sum_{i=1}^n[gcd(j,i)==1]$$

左边$k$是个定值，恶心，所以看右边：

$$\sum_{i=1}^n[gcd(j,i)==1]$$

太明显了

$$=\sum_{i=1}^n\sum_{x|i,x|j}\mu(x)$$

$$\text{设}n>m$$

$$∴\Leftrightarrow \sum_{i=1}^n\sum_{x=1}^{n}\mu(x)[x|i,x|j]$$

$$\Leftrightarrow \sum_{x=1}^{n}\mu(x)\sum_{i=1}^n[x|i,x|j]$$

然后和左边合并一下

$$\sum_{j=1}^m[gcd(j,k)==1]\sum_{j=1}^m[gcd(j,i)==1]$$

$$\Leftrightarrow \sum_{j=1}^m[gcd(j,k)==1]\sum_{x=1}^{n}\mu(x)\sum_{i=1}^n[x|i,x|j]$$

$$\Leftrightarrow \sum_{x=1}^{n}\mu(x)\sum_{i=1}^n\sum_{j=1}^m[gcd(j,k)==1][x|i,x|j]$$

上套路，$\text{设}i=ix,j=jx$

$$∴\Leftrightarrow \sum_{x=1}^{n}\mu(x)\sum_{i=1}^{\frac nx}\sum_{j=1}^{\frac mx}[gcd(jx,k)==1]$$

右边$[gcd(ix,k)==1]\Leftrightarrow [gcd(j,k)==1][gcd(x,k)==1]$

$$∴\Leftrightarrow \sum_{x=1}^{n}[gcd(x,k)==1]\mu(x)\sum_{i=1}^{\frac nx}\sum_{j=1}^{\frac mx}[gcd(j,k)==1]$$

$i$是无关紧要的，扔了

$$∴\Leftrightarrow \sum_{x=1}^{n}\lfloor{\frac nx}\rfloor[gcd(x,k)==1]\cdot\mu(x)\sum_{j=1}^{\frac mx}[gcd(j,k)==1]$$

然后？就不会了。。。。。。

$[gcd(j,k)==1]$

想到了什么？

欧拉函数$\varphi$

~~所以关键时刻$\varphi$还是碾压一切的~~

根据欧拉函数的性质

$$\varphi(k)=\sum_{i=1}^k[gcd(i,k)==1]$$

由于$gcd(i,k)=gcd(i+k,k)$

所以可以把$n$切成一些长度为$n$的段，每一段互质的个数就是$\varphi(k)$

设
$$f(i)=\sum_{j=1}^{i}[gcd(j,k)==1]$$

$$∴f(i)=(\varphi(k)\times \lfloor\frac ik\rfloor)+f(i\ mod\ k)$$

暴力求出$1$~$k-1$的$f$值就可以$O(1)$求$f(i)$了。

其实$\varphi(k)$就是$f(k)$

$∴\Leftrightarrow \sum_{x=1}^{n}\lfloor{\frac nx}\rfloor f(\lfloor\frac mx\rfloor)\cdot[gcd(x,k)==1]\mu(x)$

这时候我们发现可以二维整除分块了

前面这两个东西可以$O(1)$求，这时候只需要求后面的两个东西的前缀和就好了

我们设

$$\lambda(i)=\sum_{j=1}^{i}[gcd(j,k)==1]\mu(j)$$

又是套路

$$=\sum_{j=1}^{i}\sum_{y|j,y|k}\mu(y)\mu(j)$$

$$\Leftrightarrow \sum_{j=1}^{i}\sum_{y=1}^{k}\mu(y)[y|j,y|k]\mu(j)$$

$$\Leftrightarrow \sum_{y=1}^{k}\sum_{j=1}^{i}\mu(y)[y|j,y|k]\mu(j)$$

$\text{设}j=jy$

$$∴\ =\sum_{y=1}^{k}\sum_{j=1}^{\frac iy}\mu(y)[y|k]\mu(yj)$$

$$\Leftrightarrow \sum_{y=1}^{k}\mu(y)\sum_{j=1}^{\frac iy}[y|k]\mu(yj)$$

## 此处非常神仙：

根据[莫比乌斯函数的定义](https://baike.baidu.com/item/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/2567473)，

$\texttt{复习：}$

$\texttt{当}\ n\ \texttt{存在平方因子时}\ μ(n)=0$

$\texttt{当}\ n\ \texttt{是素数或奇数个不同素数之积时}\ μ(n)=-1$

$\texttt{当}\ n\ \texttt{是偶数个不同素数之积时}\ μ(n)=1$

$-----------------------$

$\mu(yj)!=0$必有$[gcd(y,j)==1]!!!!!!$

所以$[gcd(y,j)!=1]$的话对答案就没有贡献了

因此可以乘上$[gcd(y,j)==1]$

$$∴\Leftrightarrow \sum_{y=1}^{k}\mu(y)\sum_{j=1}^{\frac iy}[y|k]\mu(yj)[gcd(y,j)==1]$$

由于莫比乌斯函数是[积性函数](https://baike.baidu.com/item/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/8354949?fr=aladdin)

所以此时可以把$\mu(yj)$给拆成$\mu(y)\times\mu(j)$

$$∴\Leftrightarrow \sum_{y=1}^{k}\mu^2(y)\sum_{j=1}^{\frac iy}[y|k]\mu(j)[gcd(y,j)==1]$$

$k$太小了，所以可以暴力枚举因数。$[y|k]$提到前面

$$\Leftrightarrow \sum_{y|k}^{k}\mu^2(y)\ \ \sum_{j=1}^{\frac iy}\mu(j)[gcd(y,j)==1]$$

等等我们求的是什么？

是$\lambda(i)=\sum_{j=1}^{i}[gcd(j,k)==1]\mu(j)$

后面的东西好像就是$\lambda(\frac iy)!!$

不不不，$k$变成$j$了

所以我们改一下定义设$\lambda(i,k)=\sum_{j=1}^{i}[gcd(j,k)==1]\mu(j)$

所以就会出现$\lambda(i,k)=\sum_{y|k}^{k}\mu^2(y)\lambda(\frac iy,y)!!!$

这好像就可以递归计算了qwq

所以利用记忆化搜索完成递归，就好了吗？

递归边界是$\lambda(i,1)!$

这是什么？

$$\lambda(i,1)=\sum_{j=1}^{i}[gcd(j,1)==1]\mu(j)=\sum_{j=1}^{i}\mu(j)$$

就是莫比乌斯函数的前缀和啦！

用可爱的[杜教筛](https://www.luogu.org/problemnew/show/P4213)就可以了！！！

我们于是就知道了$\lambda$

重新看一下二维整除分块的那个形式

$$∴\Leftrightarrow \sum_{x=1}^{n}\lfloor{\frac nx}\rfloor f(\lfloor\frac mx\rfloor)\cdot[gcd(x,k)==1]\mu(x)$$

前面这两个东西是相同的提到前面去

后面这个东西我们需要前缀和

这就是$\lambda(x,k)$

所以这道题目就好了。

整除分块部分：
```
for (int l=1,r;l<=min(n,m);l=r+1){
    r=min(n/(n/l),m/(m/l));//二维
    ans+=(long long)*(lambda(r,k)-lambda(l-1,k)/*前缀和*/)*(n/l)*F(m/l)/*f函数*/;
}
```

完整代码：
```
#include<bits/stdc++.h>
#define ll long long
#define maxn 1000000
using namespace std;
int vis[2000001],cnt,p[2000001];
ll mu[2000001],n,m,k,smu[2000001],f[20001];
map<ll,ll> dlm;
map<pair<ll,ll>,ll> ANS;
void get(int n){//欧拉筛
    mu[1]=1;
    for (register int i=2;i<=n;i++){
        if (!vis[i]){
            p[++cnt]=i;mu[i]=-1;
        }
        for (int j=1;i*p[j]<=n&&j<=cnt;j++){
            vis[i*p[j]]=1;
            if (i%p[j]==0) break;
            mu[i*p[j]]=-mu[i];
        }
    }
    for (register int i=1;i<=n;i++){
        smu[i]=mu[i]+smu[i-1];
    }
}
ll gcd(ll a,ll b){
    if (b==0) return a;
    return gcd(b,a%b);
}
ll mus(ll n){//杜教筛
    if (n<=maxn) return smu[n];
    if (dlm[n]) return dlm[n];
    ll ans=1;
    for (register ll l=2,r;l<=n;l=r+1){
        r=n/(n/l);
        ans-=1LL*(r-l+1)*mus(n/l);
    }
    return dlm[n]=ans;
}
inline void f_init(int k){//暴力枚举计算数组f
     for (int i=1;i<=k;i++){
         f[i]=f[i-1];
         if (gcd(i,k)==1) f[i]++;
     }
}
inline ll F(ll x){
    return f[k]*(x/k)+f[x%k];
}
ll lambda(ll x,ll k){
    if (x==0) return 0;
    if (x==1) return 1;
    if (k==1) return mus(x);
    if (ANS[make_pair(x,k)]) return ANS[make_pair(x,k)];//用map和pair记忆化搜索
    ll ans=0;
    for (ll i=1;i*i<=k;i++){
        if (k%i) continue;
        if (1LL*i*i==k){
            ans+=1LL*lambda(x/i,i)*mu[i]*mu[i];
        }else{
            ans+=1LL*lambda(x/(k/i),k/i)*mu[k/i]*mu[k/i]+lambda(x/i,i)*mu[i]*mu[i];//递归
        }
    }
    return ANS[make_pair(x,k)]=ans;
}
int main(){
    cin>>n>>m>>k;
    get(maxn);
    f_init(k);
    ll Ans=0;
    for (ll l=1,r;l<=min(n,m);l=r+1){
        r=min(n/(n/l),m/(m/l));
        Ans+=1LL*(lambda(r,k)-lambda(l-1,k))*(n/l)*F(m/l);
    }
    cout<<Ans<<endl;
}
```

然后你发现，你
# TLE了

所以你需要卡常

有$1$个卡常的空间：

递归算$\lambda$的地方,如果$\mu[i]=0$就不需要递归了

然后就愉快的$A$了此题

卡常后的求$\lambda$
```
ll lambda(ll x,ll k){
    if (x==0) return 0;
    if (x==1) return 1;
    if (k==1) return mus(x);
    if (ANS[make_pair(x,k)]) return ANS[make_pair(x,k)];
    ll ans=0;
    for (ll i=1;i*i<=k;i++){
        if (k%i) continue;
        if (1LL*i*i==k){
            ans+=1LL*lambda(x/i,i)*mu[i]*mu[i];
        }else{
            if (mu[k/i]) ans+=1LL*lambda(x/(k/i),k/i)*mu[k/i]*mu[k/i];
            if (mu[i]) ans+=1LL*lambda(x/i,i)*mu[i]*mu[i];
        }
    }
    return ANS[make_pair(x,k)]=ans;
}
```

---

## 作者：FZzzz (赞：5)

大概比较无脑的做法？~~其实还是嫖的。~~

题目就是让我们求
$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\gcd(i,j)=1][\gcd(j,k)=1]$$
把 $[\gcd(j,k)=1]$ 用莫比乌斯函数处理，得到
$$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\gcd(i,j)=1]\sum\limits_{d|j,d|k}\mu(d)$$
提到前面去
$$=\sum\limits_{d|k}\mu(d)\sum\limits_{i=1}^n\sum\limits_{j=1}^{\lfloor\frac md\rfloor}[\gcd(i,dj)=1]$$
似乎有点眼熟？继续变形一下：
$$=\sum\limits_{d|k}\mu(d)\sum\limits_{i=1}^n\sum\limits_{j=1}^{\lfloor\frac md\rfloor}[\gcd(i,j)=1][\gcd(i,d)=1]$$
这个时候你大概就看出来了，后面这个东西的形式与一开始的式子是一模一样的。我们设答案等于 $f(n,m,k)$，则有
$$f(n,m,k)=\sum\limits_{d|k}\mu(d)f(\lfloor\frac md\rfloor,n,d)$$
杜教筛 $\mu$，递归下去算即可。经过类似于杜教筛（？）的一些分析可以得到复杂度是 $O(n^{\frac23})$（？）。

然后直接写的话会被卡成 $92$。有一个优化是 $\mu(d)=0$ 的时候就不用递归下去了，就过了。
```cpp
#include<algorithm>
#include<unordered_map>
#include<vector>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int mm=1e6;
int mf[mm];
vector<int> p;
typedef long long ll;
ll mu[mm],s[mm];
vector<int> fac;
unordered_map<int,ll> dp;
ll sum(int n){
	if(n<mm) return s[n];
	if(dp.count(n)) return dp[n];
	ll res=1;
	int l=2;
	while(l<=n){
		int r=n/(n/l);
		res-=sum(n/l)*(r-l+1);
		l=r+1;
	}
	return dp[n]=res;
}
ll f(int n,int m,int k){
	if(!n||!m) return 0;
	if(k==1){
		int l=1;
		ll ans=0;
		while(l<=min(n,m)){
			int r=min(n/(n/l),m/(m/l));
			ans+=(sum(r)-sum(l-1))*(n/l)*(m/l);
			l=r+1;
		}
		return ans;
	}
	ll ans=0;
	for(int i=0;i<(int)fac.size();i++)
		if(k%fac[i]==0&&mu[fac[i]])
			ans+=mu[fac[i]]*f(m/fac[i],n,fac[i]);
	return ans;
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	for(int i=2;i<mm;i++){
		if(!mf[i]) p.push_back(i);
		for(int j=0;j<(int)p.size()&&i*p[j]<mm;j++){
			mf[i*p[j]]=p[j];
			if(i%p[j]==0) break;
		}
	}
	mu[1]=1;
	for(int i=2;i<mm;i++)
		if(!mf[i]) mu[i]=-1;
		else{
			if(i/mf[i]%mf[i]==0) mu[i]=0;
			else mu[i]=mu[mf[i]]*mu[i/mf[i]];
		}
	for(int i=1;i<mm;i++) s[i]=s[i-1]+mu[i];
	int n,m,k;
	n=readint();
	m=readint();
	k=readint();
	for(int i=1;i*i<=k;i++) if(k%i==0){
		fac.push_back(i);
		if(i*i!=k) fac.push_back(k/i);
	}
	printf("%lld\n",f(n,m,k));
	return 0;
}
```

---

## 作者：柳苏明 (赞：5)

[~~获得更差的阅读体验~~](https://ignotusjee.github.io/post/luo-gu-1587-noi2016xun-huan-zhi-mei-ti-jie/)

# 题意：

给定$n,m,k$,求对于$1\le x \le n,1\le y\le m$，$\frac{x}{y}$满足数值上互不相等且在$k$进制下为纯循环小数的个数。

从小数部分第一位开始的循环小数，称为纯循环小数。特别地，整数为纯循环小数。

# 解法：



要满足数值上互不相等，只需统计最简分数，即$x\perp y$即可。

接下来要判定纯循环小数。

* 引理：$\frac{x}{y},(x\perp y)$在$k$进制下是循环小数当且仅当$y\perp k$

证明：

设$\frac{x}{y}$为纯循环最简小数，在$k$进制下其循环节长为$l$。

由纯循环小数定义可知$\frac{x}{y}k^l-\frac{x}{y}=\frac{x}{y}\left(k^l-1\right)\in Z$（$Z$为整数集）。

又$x\perp y$，则$y|\left(k^l-1\right)$。

接下来反证。假设$y\not\perp k$。因为有$k^l \not\perp \left(k^l-1\right)$，即$k\not\perp \left(k^l-1\right)$，可推出$y\not \perp \left(k^l-1\right)$，与上文结论矛盾。

证毕。

于是，问题转化为了求$\sum_{x=1}^n\sum_{y=1}^m\left[x\perp y\right]\left[y\perp k\right]$。

反演并改变枚举顺序可得
$$
\sum_{x=1}^n\sum_{y=1}^m\left[x\perp y\right]\left[y\perp k\right]
$$
$$
=\sum_{x=1}^n\sum_{y=1}^m\left[y\perp k\right]\sum_{d|x,d|y}\mu(d)
$$
$$
=\sum_{d=1}^{min(n,m)}\mu(d)\left[d\perp k\right]\lfloor\frac{n}{d}\rfloor\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\left[y\perp k\right]
$$

设$f\left(n,k\right)=\sum_{i=1}^n\left[i\perp k\right],g\left(n,k\right)=\sum_{i-1}^n\mu(i)\left[i\perp k\right]$，则$\sum_{x=1}^n\sum_{y=1}^m\left[x\perp y\right]\left[y\perp k\right]=\sum_{d=1}^{min(n,m)}\mu(d)\left[d\perp k\right]\lfloor\frac{n}{d}\rfloor f\left(\lfloor\frac{m}{d}\rfloor,k\right)$

因为素因子的次数与其他数与它是否互质无关,不妨设$k$无完全平方因子（若有将其除掉）。设$p$为$k$的一个质因子，则对于$f$有
$$
f(n,1)=\sum_{i=1}^n1=n,
$$
$$
f(n,k)=\sum_{i=1}^n\left[i\perp k\right]=\sum_{i=1}^n\left[i\perp \frac{k}{p}\right]-\sum_{i=1}^n\left[i\perp \frac{k}{p}\right]\left[p|i\right]
$$
$$
=f\left(i,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\left[ip\perp \frac{k}{p}\right]=f\left(i,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\left[i\perp \frac{k}{p}\right]
$$
$$=f\left(i,\frac{k}{p}\right)-f\left(\lfloor\frac{n}{p}\rfloor,\frac{k}{p}\right),\qquad \left(p|k,p\in P\right)
$$

对于$g$有：

$$
g\left(n,1\right)=\sum_{i=1}^n\mu(i),
$$
$$
g\left(n,k\right)=\sum_{i=1}^n\mu(i)\left[i\perp k\right]=\sum_{i=1}^n\mu(i)\left[i\perp \frac{k}{p}\right]-\sum_{i=1}^n\mu(i)\left[i\perp \frac{k}{p}\right]\left[p|i\right]
$$
$$
=g\left(n,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(ip)\left[ip\perp \frac{k}{p}\right]
$$
$$
=g\left(n,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(i)\mu(p)\left[i\perp p\right]\left[i\perp \frac{k}{p}\right]
$$
$$
=g\left(n,\frac{k}{p}\right)-\mu(p)\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(i)\left[i\perp k\right]
$$
$$
=g\left(n,\frac{k}{p}\right)+g\left(\lfloor\frac{n}{p}\rfloor,k\right)\qquad \left(p|k,p\in P\right)
$$
$$
\left(\quad \mu(p)=-1 \quad \right)
$$

以上$P$为质数集，利用了莫比乌斯函数的性质$\mu(ab)=\mu(a)\mu(b)\left[a\perp b\right]$

于是，对于$k=1$的情况，$f$可$O(1)$求解，$g$使用杜教筛即可。

对于$k>1$的情况，递归求解即可。

最后数论分块即可求解。递归部分时间复杂度$O\left(\sqrt n\frac{logk}{loglogk}\right)$，杜教筛部分时间复杂度$O(n^{\frac{2}{3}})$。

思路来自于11Dimensions。

# 代码：

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <unordered_map>
#define R register int
using std::unordered_map;

namespace quick {
#define tp template<typename Type>
	namespace in {
		inline char getc() {
			static char buf[1<<21],*p1=buf,*p2=buf;
			return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
		}
		inline int read(char *s) {
			*s=getc();
			while(isspace(*s)) {*s=getc();if(*s==EOF) return 0;}
			while(!isspace(*s)&&*s!=EOF) {s++;*s=getc();}
			*s='\0'; return 1;
		}
		tp inline int read(Type &x) {
			x=0;bool k=false;char c=getc();
			while(!isdigit(c)) {k|=(c=='-');c=getc();if(c==EOF) return 0;}
			while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getc();}
			x*=(k?-1:1); return 1;
		}
		template <typename Type,typename... Args>
		inline int read(Type &t,Args &...args) {
			int res=0;
			res+=read(t);res+=read(args...);
			return res;
		}
	}
	using in::read;
	namespace out {
		char buf[1<<21];int p1=-1;const int p2=(1<<21)-1;
		inline void flush() {
			fwrite(buf,1,p1+1,stdout);
			p1=-1;
		}
		inline void putc(const char &c) {
			if(p1==p2) flush();
			buf[++p1]=c;
		}
		inline void write(char *s) {
			while(*s!='\0') putc(*s),s++;
		}
		inline void write(const char *s) {
			while(*s!='\0') putc(*s),s++;
		}
		tp inline void write(Type x) {
			static char buf[30];int p=-1;
			if(x<0) {putc('-');x=-x;}
			if(x==0) putc('0');
			else for(;x;x/=10) buf[++p]=x%10+48;
			for(;p!=-1;p--) putc(buf[p]);
		}
		inline void write(const char &c) {putc(c);}
		template <typename Type,typename... Args>
		inline void write(Type t,Args ...args) {
			write(t);write(args...);
		}
	}
	using out::write;
	using out::flush;
	tp inline Type max(const Type &a,const Type &b) {
		if(a<b) return b;
		return a;
	}
	tp inline Type min(const Type &a,const Type &b) {
		if(a<b) return a;
		return b;
	}
	tp inline void swap(Type &a,Type &b) {
		a^=b^=a^=b;
	}
	tp inline Type abs(const Type &a) {
		return a>=0?a:-a;
	}
#undef tp
}
using namespace quick;

typedef long long ll;
const int maxn=1e6+20,limit=1e6,inf=0x3f3f3f3f;
int n,m,k;

int mu[maxn];//g的第一维
int prime[maxn],cnt,pk[maxn],tot;
void Init(int &k) {
	static char not_prime[maxn];
	mu[1]=1;
	for(R i(2);i<=limit;i++) {
		if(~not_prime[i]) prime[cnt++]=i,mu[i]=-1;
		for(R j(0);j<cnt&&prime[j]<=limit/i;j++) {
			not_prime[i*prime[j]]=0xff;
			if(i%prime[j]==0) break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(R i(1);i<=limit;i++) mu[i]+=mu[i-1];
	for(R i(0);i<cnt&&prime[i]<=k;i++) {
		while(k%(prime[i]*prime[i])==0) k/=prime[i];
		if(k%prime[i]==0) pk[tot++]=prime[i];
	}
}
#define f1(i) i
#define g1(i) mu[i]
unordered_map<int,ll> G1;
ll GetG1(const int &n) {
	if(n<=limit) return g1(n);
	if(G1[n]) return G1[n];
	ll ans=1;
	for(R i(2),j;i<=n;i=j+1) {
		j=n/(n/i);
		ans-=(ll)(j-i+1)*GetG1(n/i);
	}
	return G1[n]=ans;
}

unordered_map <int,unordered_map <int,ll> > F,G;
ll f(const int &n,const int &k,const int &now=0) {
	if(!n) return 0;
	if(k==1) return ll(f1(n));
	if(F[n][k]) return F[n][k];
	return F[n][k]=f(n,k/pk[now],now+1)-f(n/pk[now],k/pk[now],now+1);
}

ll g(const int &n,const int &k,const int &now=0) {
	if(!n) return 0;
	if(k==1) return GetG1(n);
	if(G[n][k]) return G[n][k];
	return G[n][k]=g(n,k/pk[now],now+1)+g(n/pk[now],k,now);
}

int main(void) {
#ifndef ONLINE_JUDGE
	freopen("bea.in","r",stdin);
#endif
	read(n,m,k);
	Init(k);
	ll ans=0;
	for(R i(1),j;i<=n&&i<=m;i=j+1) {
		j=min(n/(n/i),m/(m/i));
		ans+=(ll)(g(j,k)-g(i-1,k))*(n/i)*f(m/i,k);
	}
	write(ans,'\n');
	flush();
	return 0;
}

```


~~注意n和m不要交换，我就是因为这个调了一上午~~

~~话说你谷latex怎么不支持换行啊~~

---

## 作者：Paranoid丶离殇 (赞：4)

### P1587 [NOI2016]循环之美

题目大意：

​	给定n，m，k。求$K$进制下既约分数$\frac{x}{y}(1\leq x\leq n, 1\leq y\leq m)$且为纯循环小数的个数。

题解：

首先是判断分数$\displaystyle \frac{x}{y}$是否为纯循环小数的方法，

根据**打表**可以得到结论：

​	$K$进制下，$\displaystyle \frac{x}{y}$为纯循环小数当且仅当$y$与$k$互质。

证明：

$K$进制下，$\displaystyle \frac{x}{y}$为纯循环小数，则有
$$
x*k^l\equiv x(mod\ y)(l \neq 0)
$$
两边同除$x$.
$$
k^l\equiv1(mod\ y)
$$
得$k, y$互质。

证毕。

题目转化为求
$$
\displaystyle \sum_{x=1}^{n} \displaystyle \sum_{y=1}^{m}[gcd(x, y)==1][gcd(y, k)==1]
$$

$$
\displaystyle \sum_{x=1}^{n} \displaystyle \sum_{y=1}^{m}[gcd(y, k)==1][gcd(x, y)==1]
$$



更换枚举顺序
$$
\displaystyle \sum_{y=1}^{m}[gcd(y, k)==1]\displaystyle \sum_{x=1}^{n} [gcd(x, y)==1]
$$
莫比乌斯反演得
$$
\displaystyle \sum_{y=1}^{m}[gcd(y, k)==1]\displaystyle \sum_{x=1}^{n} \displaystyle \sum_{d|gcd(x, y)}\mu(d)
$$
枚举约数$d$得
$$
\displaystyle \sum_{d=1}^{n}\mu(d) \displaystyle \sum_{d|x}^{n} \displaystyle \sum_{d|y}^{m}[gcd(y,k)==1]
$$

$$
\displaystyle \sum_{d=1}^{n}[gcd(d,k)==1]\mu(d) \displaystyle \sum_{x=1}^{\displaystyle \displaystyle \lfloor\frac{n}{d}\displaystyle \rfloor} \displaystyle \sum_{y=1}^{\displaystyle \displaystyle \lfloor \frac{m}{d}\displaystyle \rfloor}[gcd(y,k)==1]
$$

$$
\displaystyle \sum_{d=1}^{n}[gcd(d,k)==1]\mu(d) \displaystyle \displaystyle \lfloor \frac{n}{d} \displaystyle \rfloor \displaystyle \sum_{y=1}^{\displaystyle \displaystyle \lfloor \frac{m}{d}\displaystyle \rfloor}[gcd(y,k)==1]
$$

令$f(x)=\displaystyle \sum_{i=1}^{x}[gcd(i,k)==1],s(x,k)=\displaystyle \sum_{i=1}^{x}[gcd(i,k)==1]\mu(i)$.

考虑求$f(x)$，若$i$与$k$互质，则有$i+k$与$k$互质。

所以
$
f(x)=\lfloor \frac{x}{k}\displaystyle \rfloor f(k) + f(x
$
%
$
k)
$

预处理$f(x)$满足$1\leq x\leq k$的$f(x)$,剩下的递归处理即可。

考虑求$s(x, k)$.
$$
s(x,k)=\sum_{i=1}^{x}[gcd(i,k)==1]\mu(i)
$$
$$
=\sum_{i=1}^{x}\mu(i)[gcd(i,k)==1]
$$
$$
=\sum_{i=1}^{x}\mu(i)\sum_{d|gcd(i,k)}\mu(d)
$$
$$
=\sum_{i=1}^{x}\mu(i)\sum_{d|i,d|k}\mu(d)
$$
$$
=\sum_{d|k}\mu(d)\sum_{d|i}\mu(i)
$$
$$
=\sum_{d|k}\mu(d)\sum_{i=1}^{\lfloor\frac{x}{d}\rfloor}\mu(i*d)
$$
若$gcd(i,d)\neq 1$时，$\mu(i*d)=0$，对答案没有贡献.

由积性函数的性质$f(ab)=f(a)*f(b)$得
$$
=\sum_{d|k}\mu(d)\sum_{i=1}^{\lfloor \frac{x}{d}\rfloor}[gcd(i,d)==1]\mu(i)\mu(d)
$$
$$
=\sum_{d|k}\mu(d)^2\sum_{i=1}^{\lfloor \frac{x}{d}\rfloor}[gcd(i,d)==1]\mu(i)
$$
$$
=\sum_{d|k}\mu(d)^2\sum_{i=1}^{\lfloor \frac{x}{d}\rfloor}[gcd(i,d)==1]\mu(i)
$$
$$
=\sum_{d|k}\mu(d)^2*s(\lfloor \frac{x}{d}\rfloor,d)
$$
递归处理即可。

但当$k=1$时，$s(x,k)$的值无法通过递归得出。

考虑$k=1$的情况，
$$
s(x,1)=\sum_{i=1}^{x}[gcd(i,1)==1]\mu(i)
$$
$$
=\sum_{i=1}^{x}\mu(i)
$$
由于$1\leq x\leq 1e8$，杜教筛求前缀和即可。

题目中所求的
$$
ans=\displaystyle \sum_{d=1}^{n}[gcd(d,k)==1]\mu(d) \displaystyle \displaystyle \lfloor \frac{n}{d} \displaystyle \rfloor \displaystyle \sum_{y=1}^{\displaystyle \displaystyle \lfloor \frac{m}{d}\displaystyle \rfloor}[gcd(y,k)==1]
$$
整除分块处理。

code：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <map>
#include <algorithm>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int read() {
	int x = 0, f = 1; char ch;
	while(! isdigit(ch = getchar())) (ch == '-') && (f = -f);
	for(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));
	return x * f;
}
map <pair <int, int>, int> mp;
int n, m, K, ans;
int tot, gcd_k[N], f[N], mu[N], Smu[N], vis[N], pri[N];
void init() {
	for(int i = 1; i <= K; ++ i) gcd_k[i] = __gcd(i, K) == 1;
	for(int i = 1; i <= K; ++ i) f[i] = f[i - 1] + gcd_k[i];
	mu[1] = 1;
	for(int i = 2; i < N; ++ i) {
		if(! vis[i]) pri[++ tot] = i, mu[i] = -1;
		for(int j = 1; j <= tot && i * pri[j] < N; ++ j) {
			vis[i * pri[j]] = 1;
			if(i % pri[j] == 0) break;
			mu[i * pri[j]] = - mu[i];
		}
	}
	for(int i = 1; i < N; ++ i) Smu[i] = Smu[i - 1] + mu[i];
}
int Sf(int x) {
	return (x / K) * f[K] + f[x % K];
}
int Ss(int x, int k){
	if((k == 1 && x <= N) || x == 0) return Smu[x];
	if(mp[make_pair(x, k)]) return mp[make_pair(x, k)];
	int res = 0;
	if(k == 1) {
		res = 1;
		for(int i = 2, j; i <= x; i = j + 1) {
			j = x / (x / i);
			res -= (j - i + 1) * Ss(x / i, k);
		}
	}
	else {
		for(int i = 1; i * i <= k; ++ i) {
			if(k % i) continue;
			if(mu[i]) res += Ss(x / i, i);
			if(i * i != k && mu[k / i]) {
				res += Ss(x / (k / i), k / i);
			}
		}
	}
	return mp[make_pair(x, k)] = res;
}
signed main() {
	n = read(); m = read(); K = read();
	init();
	for(int i = 1, j, nw = 0, lst = 0; i <= min(n, m); i = j + 1) {
		j = min(n / (n / i), m / (m / i));
		nw = Ss(j, K);
		ans = ans + (nw - lst) * (n / i) * Sf(m / i);
		lst = nw;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：爱迪生 (赞：2)

$\frac{x}{y}$在$k$进制下是纯循环小数$\Leftarrow\! =\! \Rightarrow \exists \ t $ 使得 $ y|k^t\!-\!1 $

若$gcd(y,k)!=1$则$y\nmid k^t\!-\!1$

若$gcd(y,k)=1$则由欧拉定理知:$y\mid k^{φ(y)}\!-\!1$

所以$\frac{x}{y}$在$k$进制下是纯循环小数$\Leftarrow\! =\! \Rightarrow gcd(y,k)\!=\!1$

又因为值相等算一个所以只需看$gcd(x,y)=1$的情况

$\Rightarrow Ans=\sum\limits_{i=1}^n \sum\limits_{j=1}^m I[gcd(i,j)=1]\! * \!I[gcd(j,k)=1]$

记$f(d)=\sum\limits_{i=1}^n \sum\limits_{j=1}^m I[gcd(i,j)=d]\! * \!I[gcd(j,k)=1]$

则$\begin{aligned}F(d)&=\sum\limits_{d|i} f(i)\\&=\sum\limits_{d|i}\sum\limits_{i=1}^n \sum\limits_{j=1}^m I[gcd(i,j)=d]\! * \!I[gcd(j,k)=1]\\&=\sum\limits_{d|i,d|j}\sum\limits_{i=1}^n \sum\limits_{j=1}^m I[gcd(j,k)=1]\\&=\sum\limits_{i=1}^{[\frac{n}{d}]} \sum\limits_{j=1}^{[\frac{m}{d}]} I[gcd(j*d,k)=1]\end{aligned}$

记$\delta(x)=I[gcd(x,k)=1]$

则$\delta(x)$为积性函数

$\begin{aligned}F(d)&=\sum\limits_{i=1}^{[\frac{n}{d}]} \sum\limits_{j=1}^{[\frac{m}{d}]} \delta(j*d)\\&=\sum\limits_{i=1}^{[\frac{n}{d}]} \sum\limits_{j=1}^{[\frac{m}{d}]} \delta(j)* \delta(d)\\&=\delta(d)\!* \![\frac{n}{d}]\!* \! \sum\limits_{j=1}^{[\frac{m}{d}]} \delta(j)\end{aligned}$

记$g(n)=\sum\limits_{j=1}^{n} \delta(j)$

$F(d)=\delta(d)\!* \![\frac{n}{d}]\!* \! g(n)$

由莫比乌斯反演得:

$f(1)=\sum\limits_{i=1}^{min(n,m)}\mu(i)* \delta(i)* [\frac{n}{i}]* g([\frac{m}{i}])$

因为$g(x+k)=g(x)+g(k)$

所以$g(x)=[\frac{x}{k}]* g[k]+g[x\%k]$

求$g$只需预处理出$g(1),g(2),\cdots,g(k)$

综上g搞定。

接下来只需要求$\mu(i)* \delta(i)$的前缀和即可。

记$S(n)=\sum\limits_{i=1}^{n} \mu(i)* \delta(i)$

$\begin{aligned}\quad&\sum\limits_{i=1}^{n}\delta(i)* S([\frac{n}{i}])\\=&\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{[\frac{n}{i}]} \delta(i)* \mu(j)* \delta(j) \quad \text{ 取d为i * j}\downarrow\\=&\sum \limits_{d=1}^{n}\sum\limits_{i|d}\delta(i)* \mu(\frac{d}{i})* \delta(\frac{d}{i})\\=&\sum \limits_{d=1}^{n}(\sum\limits_{i|d}\mu(\frac{d}{i}))* \delta(d)\\=&\delta(1)\\=&1\end{aligned}$

$\therefore S(n)=1-\sum\limits_{i=2}^{n} \delta(i)* S([\frac{n}{i}])$

$S([\frac{n}{i}])$可以分块做

所以只需求$\delta(i)$的前缀和

咦？我们发现$\delta(i)$的前缀和不就是$g(i)$吗？

我们之前已经算过了。

## 至此分析结束

上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 8000000
using namespace std;
ll n,m,k,p[N],mo[N],g[N],s[N];
bool used[N];
map<ll,ll>f;
ll gcd(ll x,ll y)
{
    return y?gcd(y,x%y):x;
}
ll gg(ll x)
{
    return x/k*g[k]+g[x%k];
}
void euler()
{
    for(int i=1;i<=k;i++)
        g[i]=g[i-1]+(gcd(i,k)==1);
    mo[1]=1;
    for(ll i=2;i<N;i++)
    {
        if(used[i]==0)
        {
            p[++p[0]]=i;
            mo[i]=-1;
            used[i]=1;
        }
        for(int j=1;j<=p[0];j++)
        {
            if(i*p[j]>=N)
                break;
            used[i*p[j]]=1;
            if(i%p[j]==0)
            {
                mo[i*p[j]]=0;
                break;
            }
            mo[i*p[j]]=-mo[i];
        }
    }
    for(ll i=1;i<N;i++)
        s[i]=s[i-1]+mo[i]*(gg(i)-gg(i-1));
}
ll ask(ll x)
{
    if(x<N)
        return s[x];
    if(f[x]!=0)
        return f[x];
    ll ans=1;
    for(ll i=2,j;i<=x;i=j+1)
    {
        j=x/(x/i);
        ans-=ask(x/i)*(gg(j)-gg(i-1));
    }
    f[x]=ans;
    return ans;
}
int main()
{
    scanf("%lld%lld%lld",&n,&m,&k);
    euler();
    ll ans=0;
    for(ll i=1,j;i<=min(n,m);i=j+1)
    {
        j=min(n/(n/i),m/(m/i));
        ans+=gg(m/i)*(n/i)*(ask(j)-ask(i-1));
    }
    printf("%lld",ans);

    return 0;
}
```

---

## 作者：shadowice1984 (赞：2)

~~不知道为什么脑子抽筋了想用迭代法写这题，然后就把自己写死了~~

### 前置芝士：杜教筛/洲阁筛

蛤?不会杜教筛？可以出门左转你站膜板区去学习一下

不过可能你学的是递归版的杜教筛常数会大一点，这篇题解会介绍一下如何用迭代法写杜教筛

### 前置芝士：莫比乌斯反演

为了做这道题我们可能需要一些比较初级的反演技巧和交换求和号的技巧，比如我们应该知道这些结论都是对的

这篇题解当中我们将会用$\epsilon(i,j)$表示$gcd(i,j)==1$这个式子

$$\lfloor \frac{n}{d} \rfloor$$

$$\sum_{i=1}^{n}g(i)\sum_{d|n}f(d)=\sum_{d=1}^{n}f(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}g(id)$$

$$epsilon(i,j)=\sum_{d|i,d|j}\mu(d)$$

$$\epsilon(dt,j)=\epsilon(d,j)\epsilon(t,j)$$

$$\mu(dt)=\mu(d)\mu(t)\epsilon(d,t)$$

解释一下第3个式子利用了$\mu$是一个积性函数的性质，如果$d,t$不互质的话$\mu$就是0否则就是二者相乘

并且你还需要知道对于一个$n$来讲，$\lfloor \frac{n}{d} \rfloor$恰好有$2\sqrt{n}$中取值，并且对于后$\sqrt{n}$取值来讲，如果他们的值是x，那么$\lfloor \frac{n}{x} \rfloor$的值互不相同这个结论,当然您可能也需要知道什么叫数论分块(就是如何枚举$\lfloor \frac{n}{d} \rfloor$的取值的一种技巧)

如果您碰巧不会很懂上面的芝士可以去写几道莫比乌斯反演然后来看这题

## 本题题解

首先我们需要通过题面得出答案事实上等于这个神奇的式子

$$\sum_{i=1}^{n}\sum_{j=1}^{m}\epsilon(i,j)\epsilon(j,k)$$

为什么呢？

首先$epsilon(i,j)$这个限制条件是比较好理解的，但是为什么第二个限制条件是对的呢？也就是说我们的分母仅仅和k互质就能推出这个东西是一个纯循环的小数了

首先我们不难理解如果$\frac{1}{y}$是一个纯循环的小数，那么$\frac{x}{y}$也会是一个纯循环的小数，具体证明的话就是两个纯循环小数相加还是纯循环小数，所以一个分数是不是纯循环小数看起来仅仅和分母有关

那么我们假设这个纯循环小数的循环节长度为$l$我们可以用错位相减法得到下面的式子

$$\frac{k^l}{y}-\lfloor \frac{k^l}{y} \rfloor=\frac{1}{y}$$

也就是这个小数向右挪了$l$位之后的小数部分依然和原来一样

那么把等式两边同时乘y可以得到

$$k^l-\lfloor \frac{k^l}{y} \rfloor y=1$$

这个东西好像就是取余的定义式子吧？让我们把式子写成这样

$$ k^l \equiv 1 \mod y$$

根据欧拉定理我们可以知道当$k,y$互质的时候我们就存在这样的$l$否则不存在

所以我们证明了一个分数是纯循环的当且仅当它的分母和进制互质

所以答案自然就是上面提到的式子了

$$\sum_{i=1}^{n}\sum_{j=1}^{m}\epsilon(i,j)\epsilon(j,k)$$

我们发现$\epsilon(j,k)$这个东西相当的不好搞定，因此让我们先不着急展开这个式子,而是把$\epsilon(i,j)$用$\mu$展开

$$\sum_{j=1}^{m}\epsilon(j,k)\sum_{i=1}^{n}\sum_{d|i,d|j}\mu(d)$$

交换一下求和号可以得到

$$\sum_{j=1}^{m}\epsilon(j,k)\sum_{d|j}\mu(d)\lfloor \frac{n}{d} \rfloor$$

然后我们继续交换求和号可以得到

$$\sum_{d=1}^{n}\mu(d)\lfloor \frac{n}{d} \rfloor\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}\epsilon(jd,k)$$

看起来可以用刚才的结论了，让我们把$\epsilon(jd,k)$拆开

$$\sum_{d=1}^{n}\mu(d)\lfloor \frac{n}{d} \rfloor\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}\epsilon(j,k) \epsilon(d,k)$$

然后似乎可以把$\epsilon(d,k)$提到前面去

$$\sum_{d=1}^{n}\mu(d)\epsilon(d,k)\lfloor \frac{n}{d} \rfloor\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}\epsilon(j,k)$$

我们发现函数

$$f(n)=\sum_{i=1}^{n}\epsilon(i,k)=\sum_{i=1}^{n}\epsilon(i\%k,k)=\lfloor \frac{n}{k} \rfloor f(k)+f(n\%k)$$

似乎是可以在暴力预处理前$k$项之后快速计算的

那么我们的式子就变成了

$$\sum_{d=1}^{n}\mu(d)\epsilon(d,k)\lfloor \frac{n}{d} \rfloor f(\lfloor \frac{m}{d} \rfloor)$$

看起来我们似乎可以对$\lfloor \frac{n}{d} \rfloor,\lfloor \frac{m}{d} \rfloor$的值进行数论分块了，当然前提是我们需要求出这个东西的前缀和

$$f(d)=\mu(d)\epsilon(d,k)$$

怎么做呢?

我们设$S(n)$表示下面的式子，然后接下来我们需要对$\lfloor \frac{n}{d} \rfloor$和$\lfloor \frac{m}{d} \rfloor$这两个式子的一共$2\sqrt{n}+2\sqrt{m}$可能的取值处理出对应的$S$函数值

$$S(n)=\sum_{i=1}^{n}\mu(d)\epsilon(d,k)$$

此时让我们用$\mu$把$\epsilon$展开

$$S(n)=\sum_{i=1}^{n}\mu(d)\sum_{T|d,T|k}\mu(T)$$

交换一下求和号可以得到

$$S(n)=\sum_{T|k}\mu(T)\sum_{d=1}^{\lfloor \frac{n}{T} \rfloor}\mu(dT)$$

根据刚才的结论我们可以得到

$$S(n)=\sum_{T|k}\mu(T)\sum_{d=1}^{\lfloor \frac{n}{T} \rfloor}\mu(d)\mu(T)\epsilon(d,T)$$

把$\mu(T)$提出来可以得到

$$S(n)=\sum_{T|k}\mu^2(T)\sum_{d=1}^{\lfloor \frac{n}{T} \rfloor}\mu(d)\epsilon(d,T)$$

看起来我们似乎得到了一个可以不断递归的式子？

我们重新更改一下我们需要求的数的定义，设$G(n,k)$表示

$$\sum_{d=1}^{n}\mu(d)\epsilon(d,k)$$

则我们可以列出递归式

$$G(n,k)=\sum_{T|k}\mu^2(T)G(\lfloor \frac{n}{d} \rfloor,T)$$

那么我们打一下表会发现$2000$以内一个数的约数个数最大不超过$40$个

所以看起来我们可以暴力递归下去算咯？

慢着，似乎我们还没有处理边界条件是什么……

$$G(n,1)=\sum_{d=1}^{n}\mu(d),S(n)=G(n,k)$$

蛤？$\mu$函数的前缀和？直接杜教筛就行了

### trick:迭代版杜教筛

众所周知杜教筛其实是一种记忆化搜索的技术

假设我们令$S(n)$表示这个式子

$$S(n)=\sum_{d=1}^{n}\mu(d)$$

那么我们可以得到

$$\sum_{i=1}^{n}\epsilon(i)=\sum_{i=1}^{n}\sum_{d|i}\mu(\frac{i}{d})=\sum_{d=1}^{n}\sum_{T=1}^{\lfloor \frac{n}{d} \rfloor}\mu(T)$$

也就是说

$$1=\sum_{i=1}^{n}S(\lfloor \frac{n}{d} \rfloor)$$

稍微整理一下式子就是

$$S(n)=1-\sum_{i=2}^{n}S(\lfloor \frac{n}{d} \rfloor)$$

那么我们发现这东西其实就是一个dp式子啊

所以作为一个dp来讲我们当然可以递推的实现它咯

不过问题来了，直接dp的话我们似乎开不下那么大的数组，怎么办呢？

根据$\lfloor \frac{n}{d} \rfloor$的一个性质是对于后$\sqrt{n}$种值,$n$除他们的取值各不相同，因此我们可以将他们的值存储在下标为$\frac{n}{x}$的位置上

然后我们从**小到大**对于每一个$\lfloor \frac{n}{d} \rfloor$的取值大力dp一下就搞定了，当然不要忘记线性筛出来前$n^{0.67}$部分的点值，否则我们的复杂度将会退化到$O(n^{0.75})$

这个迭代写法也证明了为什么杜教筛复杂度计算的时候只需展开一层，因为每条转移的边只会被访问一次,后面的部分不是什么高阶无穷小而就是0，~~恩，就是这么暴力~~

同理我们也可以用这个trick去解决一下处理$G$函数的问题，我们把k的约数之间的转移边建出来之后大力dp也可以做到迭代计算了

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;const int N=45;const int P=5*1e4+10;const int L=3*1e6+10;const int K=2010;
typedef long long ll;
int zhi[L];bool book[L];int ct;int sum[L];int n;int m;int k;
inline int gcd(int a,int b){if(a<b)swap(a,b);while(b){int c=a%b;a=b;b=c;}return a;}
struct arr//加了科技的数组
{
    ll v1[P];ll v2[P];int mx;int lim;
    inline ll& operator[](const int& x){return (x<=lim)?v1[x]:v2[mx/x];}
}dp1[N],gn,dp2[N],gm;ll f[K];int hd;
int v[K];int x[K];int al[N];int nu[K];int val[N];int q[P<<1];int tot;
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline void sev(int n,arr& dp)//迭代版杜教筛
{
    tot=0;for(int i=1,r,t;i<=n;i=r+1)t=n/i,q[++tot]=t,r=n/t;
    for(int i=tot;i>=1;i--)
    {
        int t=q[i];if(t<=L-10){dp[t]=sum[t];continue;}ll ret=1;
        for(int j=2,pr;j<=t;j=pr+1)
            pr=(t/(t/j)),ret-=(ll)(pr-j+1)*dp[t/j];dp[t]=ret;
    }
}
inline void dypr(int n,arr* dp)//迭代版dp
{
    tot=0;for(int i=1,r,t;i<=n;i=r+1)t=n/i,q[++tot]=t,r=n/t;
    for(int i=2;i<=hd;i++)
        for(int j=al[i];j;j=x[j])
        {int lc=v[j];int dv=val[lc];for(int k=tot;k>=1;k--)dp[i][q[k]]+=dp[lc][q[k]/dv];}
}inline ll getf(ll x){return (x/k)*f[k]+f[x%k];}
int main()
{
    sum[1]=1;
    for(int i=2;i<=L-10;i++)
    {
        if(book[i]==false){zhi[++ct]=i;sum[i]=-1;}
        for(int j=1;j<=ct&&i*zhi[j]<=L-10;j++)
        {
            book[i*zhi[j]]=true;
            if(i%zhi[j]==0)sum[i*zhi[j]]=0;else sum[i*zhi[j]]=-sum[i];
        }
    }scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)if(k%i==0&&sum[i]!=0)nu[i]=++hd,val[hd]=i;
    for(int i=1;i<=L-10;i++)sum[i]+=sum[i-1];
    for(int i=k;i>=1;i--)
        if(nu[i])for(int j=i;j<=k;j+=i)if(nu[j])add(nu[j],nu[i]);
    for(int i=1;i<=hd;i++)dp1[i].mx=n,dp1[i].lim=sqrt(n);
    for(int i=1;i<=hd;i++)dp2[i].mx=m,dp2[i].lim=sqrt(m);
    sev(n,dp1[1]);dypr(n,dp1);gn=dp1[hd];
    sev(m,dp2[1]);dypr(m,dp2);gm=dp2[hd];
    for(int i=1;i<=k;i++)f[i]=f[i-1]+(gcd(k,i)==1);ll ans=0;
    for(int i=1,r,tp=1;i<=min(n,m);i=r+1)//大力数论分块就行了
    {
        int t1=n/i;int t2=m/i;int v1=n/t1;int v2=m/t2;
        if(v1<v2)ans+=(ll)t1*getf(t2)*(gn[v1]-((tp)?gn[i-1]:gm[i-1])),tp=1,r=v1;
        else ans+=(ll)t1*getf(t2)*(gm[v2]-((tp)?gn[i-1]:gm[i-1])),tp=0,r=v2;
    }printf("%lld\n",ans);return 0;//拜拜程序~
}
```







---

## 作者：chenxia25 (赞：2)

提供一种较简洁的做法。

根据小学奥数，$\dfrac xy$ 符合要求当且仅当 $x\perp y,y\perp k$。
$$
ans=\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp K]
$$
该提前的贡献都提前了：
$$
ans=\sum_{i=1}^m[i\perp K]\sum_{j=1}^n[i\perp j]
$$
两个互质，都可以莫反展开。但是对这种一看就不是套路的莫反题，还是小心为妙，直接莽会死的。考虑先把后面的展开（事实上通往了正确的道路）。
$$
\begin{aligned}ans&=\sum_{i=1}^m[i\perp K]\sum_{k\mid i}\mu(k)\!\left\lfloor\dfrac nk\right\rfloor\\&=\sum_k\mu(k)\!\left\lfloor\dfrac nk\right\rfloor\![k\perp K]\sum_{i=1}^{\left\lfloor\frac mk\right\rfloor}[i\perp K]\end{aligned}
$$
到这里已经可以做了。考虑对 $k$ 整除分块，那么最后一个 $\sum$ 就是关于 $K$ 的互质函数的前缀和，是有周期性的，预处理前 $k$ 项即可 $\mathrm O(1)$ 回答前缀和。现在要求的是 $\mu$ 乘以互质函数的前缀和。幸运的是，互质函数是完全积性的（那为什么你一开始不 $[i\perp j][i\perp K]=[i\perp jK]$ 呢？因为一般函数里套乘积的式子都很不好搞。。。gcd 可以枚举然后莫反，乘积呢？），于是 $(\mu\times P)*P=\epsilon$（其中 $P$ 是互质函数）即可杜教筛（对 $n,m$ 各算一遍）。复杂度 $\mathrm O\!\left(n^{\frac 23}+K\log K\right)$。

---

## 作者：封禁用户 (赞：1)

在[我的 $\rm csdn$ 博客](https://blog.csdn.net/qq_42101694/article/details/113575751)上也可以看到。~~不过 csdn 的博客排版感觉正在变丑~~。

# 题目
求 $p/q(1\le p\le n,\;1\le q\le m,\;\gcd(p,q)=1)$ 转化成 $k$ 进制小数后是纯循环小数的数量。比如 $10$ 进制下 ${1\over 3}=0.\overset{.}{3}$ 是，而 ${1\over 6}=0.1\overset{.}{6}$ 则不是。

# 思路
~~众所周知~~，只要是 ${x\over k^L-1}$ 就会循环，无论 $x$ 是何值。并且循环节一定是 $x\bmod(k^L-1)$ 的模样。这是容易证明的。

$$\begin{aligned}
ans&=\sum_{i=1}^{n}\sum_{j=1}^{m}\left[\exists L,\exists x,\;\frac{i}{j}=\frac{x}{k^L-1}\right]\big[\gcd(i,j)=1\big]\\
&=\sum_{i=1}^{n}\sum_{j=1}^{m}\left[\exists L,\;j|(k^L-1)\right]\big[\gcd(i,j)=1\big]
\end{aligned}$$

设 $f(j)=\sum_{i=1}^{n}\big[\gcd(i,j)=1\big],\;g(j)=\big[\exists L,\;j|(k^L-1)\big]$ ，那么

$$
ans=\sum_{j=1}^{m}f(j)g(j)
$$

我们不难发现 $d|x$ 则 $(k^d-1)|(k^x-1)$ 这个重要结论。证明可以利用因式定理，或者用神奇的

$$\begin{aligned}
\gcd(k^a-1,k^b-1)&=\gcd(k^a-1,k^b-k^a)\\
&=\gcd\big[k^a-1,k^a(k^{b-a}-1)\big]\\
&=\gcd(k^a-1,k^{b-a}-1)\\
&=k^{\gcd(a,b)}-1
\end{aligned}$$

来很容易地说明。

而 $\gcd(a,b)=1$ 时，$g(ab)=g(a)g(b)$ 。证明：如果 $g(a)=g(b)=1$ ，那么取 $L_{ab}=L_a\times L_b$ 即可；如果 $g(a)$ 或 $g(b)=0$ ，那么 $k^L-1$ 连 $a$ 或 $b$ 的倍数都得不到，谈何 $ab$ 的倍数呢？

于是考虑 $g(p)(p\in\Bbb{PRIME})$ 的值。只要 $k$ 不是 $p$ 的倍数，就一定有 $k^{\varphi(p)}-1\equiv 0\pmod{p}$ ，故 $g(p)=\big[\gcd(k,p)=1\big]$ 。

进一步，$k^{\varphi(p^2)}-1\equiv 0\pmod{p^2}$ ，只要 $k$ 不是 $p$ 的倍数。那么我们写出

$$
g(p^x)=[\gcd(k,p)=1]
$$

再利用 $g$ 是积性的，我们得到
$$
g(x)=[\gcd(k,x)=1]
$$

顺带提一句，这里 $g$ 还是一个 **完全积性** 函数呢……

那么 $f(j)$ 怎么算捏？试一试：

$$\begin{aligned}
f(j)&=\sum_{i=1}^{n}\big[\gcd(i,j)=1\big]\\
&=\sum_{i=1}^{n}\sum_{p|i,p|j}\mu(p)\\
&=\sum_{p|j}\mu(p)\left\lfloor{n\over p}\right\rfloor
\end{aligned}$$

所以我们重写一下开头的式子
$$
\begin{aligned}
ans&=\sum_{j=1}^{m}\sum_{p|j}\mu(p)\left\lfloor{n\over p}\right\rfloor g(j)\\
&=\sum_{p=1}^{m}\left\lfloor{n\over p}\right\rfloor\mu(p)\sum_{p|j,\;j\le m}g(j)\\
&=\sum_{p=1}^{m}\left\lfloor{n\over p}\right\rfloor \mu(p)g(p)\sum_{i=1}^{\lfloor m/p\rfloor}g(i)
\end{aligned}
$$

多数题解都讲到了这里。然后他们会讲，怎么把 $\mu(p)g(p)$ 拿去递推求前缀和。但是我是一个只喜欢暴力的人，不怕代码又臭又长，只怕一行又一行等号开头！

整除分块，对 $\mu(p)g(p)$ 和 $g(p)$ 用 $\tt min\_25$ 求前缀和即可。

具体怎么求呢？用 $f(x)=1$ 先去拟合一波，然后手动把 $g(p)=0$ 的 $p$ 给挖掉（这样的 $p$ 是很少的嘛）。

当然，~~看了看洛谷题解~~，你会发现 $g(x)$ 的前缀和可以更好求。令 $G(x)=\sum_{i=1}^{x}g(i)$ 则

$$G(x)=\left\lfloor{x\over k}\right\rfloor G(k)+G(x\bmod k)$$

我们可以 $\mathcal O(k\log k)$ 暴力求出 $G(x)(0\le x\le k)$ ，而后可以直接算。

# 代码
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long int_;
inline int readint(){
	int a = 0; char c = getchar(), f = 1;
	for(; c<'0'||c>'9'; c=getchar())
		if(c == '-') f = -f;
	for(; '0'<=c&&c<='9'; c=getchar())
		a = (a<<3)+(a<<1)+(c^48);
	return a*f;
}

const int MaxN = 80005;
bool isPrime[MaxN];
vector< int > primes;
int smu[MaxN]; // prefix sum of mu
vector< int > sumf; // real F = mu*g
void sieve(int k){
	memset(isPrime+2,1,MaxN-2);
	smu[1] = 1; // just don't forget it
	sumf.push_back(0); // to be bottom
	for(int i=2,len=0; i<MaxN; ++i){
		if(isPrime[i]){
			primes.push_back(i), ++ len;
			if(k%i == 0) // g(i) = 0
				sumf.push_back(0);
			else sumf.push_back(-1);
		}
		for(int j=0; j<len&&primes[j]<=(MaxN-1)/i; ++j){
			isPrime[i*primes[j]] = false;
			if(i%primes[j] == 0) break;
		}
	}
	for(int i=2,len=primes.size(); i<=len; ++i)
		sumf[i] += sumf[i-1];
}

struct MIN_25{
	int haxi[2][MaxN], w[MaxN];
# define index_(x) (((x) >= MaxN) ? haxi[1][n/(x)] : haxi[0][x])
	int g[MaxN]; // F = mu*g begin with F = 1
	void min_25(int n,int k){
		int id = 0; // allocate index
		for(int i=1; i<=n; i=n/(n/i)+1){
			index_(n/i) = ++ id;
			g[id] = (w[id] = n/i)-1;
		}
		/* Sieve number of primes */ ;
		for(int j=0; primes[j]<=n/primes[j]; ++j)
			for(int i=1; i<=id; ++i){
				if(primes[j] > w[i]/primes[j])
					break; // p_j <= sqrt(w)
				g[i] -= (g[index_(w[i]/primes[j])]-j);
			}
		/* Remove special primes */ ;
		for(int i=id,j=0,x=0; i; --i){
			for(; primes[j]<=k; ++j){
				if(primes[j] > w[i]) break;
				x += !(k%primes[j]); // calc
			}
			g[i] -= x; // remove them
		}
		# define FF(x) ((k%(x)) ? -1 : 0)
		/* Get all ans */ ;
		for(int i=1; i<=id; ++i)
			g[i] = -g[i]; // mu(p)*g(p) = -1
		int j = primes.size();
		for(--j; ~j; --j){ // from big to small
			if(primes[j] > n/primes[j])
				continue; // p_j <= sqrt(n)
			for(int i=1; i<=id; ++i){
				if(primes[j] > w[i]/primes[j])
					break; // good cut branch
				g[i] += FF(primes[j])*(
					g[index_(w[i]/primes[j])]
					- sumf[j+1]); // JiXing
			}
		}
	}
};
MIN_25 fn, fm;

# define sumG(x) (((x)/k)*sxy[k]+sxy[(x)%k])
int sxy[MaxN];
int main(){
	int n = readint(), m = readint();
	int k = readint();
	for(int i=1; i<=k; ++i){
		sxy[i] = sxy[i-1]; // prefix sum
		if(__gcd(i,k) == 1) // coprime
			++ sxy[i]; // add one
	}
	sieve(k); fn.min_25(n,k);
	fm.min_25(m,k);
	int lst = 0, now; int_ ans = 0, fk;
	for(int l=1,r; l<=m&&l<=n; l=r+1){
		r = min(n/(n/l),m/(m/l));
		fk = 1ll*sumG(m/l)*(n/l);
		if(r == n/(n/l)) if(r >= MaxN)
			now = fn.g[fn.haxi[1][n/r]];
			else now = fn.g[fn.haxi[0][r]];
		else if(r >= MaxN)
			now = fm.g[fm.haxi[1][m/r]];
		else now = fm.g[fm.haxi[0][r]];
		ans += fk*(now+1-lst);
		lst = now+1; // mu(1)*g(1) = 1
	}
	printf("%lld\n",ans);
	return 0;
}
```

# 后记
没想到 $\mathcal O({n^{3/4}\over \ln n})$ 跑了最优解？

$\tt 2021/2/3\;11:45$ 最优解留念 :)

顺便吐槽一下，$\rm csdn$ 是支持使用 `\exist` 的，而某谷只支持 `\exists` ，~~搞得我还查了一下某谷里怎么打存在符号~~。


---

## 作者：Vocalise (赞：1)

这里大概有一个和大家不一样的做法，夏令营讲到的。

非常有趣且奇妙的一道题。

还是从头开始讲。

$\dfrac xy$ 只计算一次，我们只统计 $x\perp y$ 的就好。垂直符号表示互质，后面还会用到。

同时有分母 $y\perp k$，参见其他人的证明。求：

$$\sum_{x=1}^n\sum_{y=1}^m[x\perp y][y\perp k]$$

我们首先莫比乌斯反演推导一下。

$$\begin{aligned}
&\ \ \ \ \sum_{x=1}^n\sum_{y=1}^m[x\perp y][y\perp k] \\
&=\sum_{x=1}^n\sum_{y=1}^m\sum_{d|x,d|y}\mu(d)[y\perp k] 
=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor\frac nd\rfloor\sum_{y=1}^{m/d}[dy\perp k] \\
&=\sum_{d=1}^{\min(n,m)}\lfloor\frac nd\rfloor\mu(d)[d\perp k]\sum_{y=1}^{m/d}[y\perp k] 
\end{aligned}$$

其中 $[dy\perp k]$ 可以分解为 $[d\perp k][y\perp k]$。

设

$$f(n)=\sum_{i=1}^n[i\perp k]$$

原式为

$$\sum_{d=1}^{\min(n,m)}\lfloor\frac nd\rfloor f(\lfloor\frac md\rfloor)\mu(d)[d\perp k]$$

显然可以二维的整除分块；然后我们需要求出 $f(n)$ 的单点值和 $\mu(d)[d\perp k]$ 的前缀和。

---

考虑 $k$ 的范围非常小，把 $n$ 按照一段长 $k$ 分段，容易得到：

$$\begin{aligned}
f(n)&=\lfloor\frac nk\rfloor\sum_{i=1}^k[i\perp k]+\sum_{i=1}^{n\bmod k}[i\perp k]\\
&=\lfloor\frac nk\rfloor f(k) +f(n\bmod k)
\end{aligned}$$

于是甚至不用线性筛 $\varphi$，暴力求 $f(n)$ 到 $k$ 即可。

发现直到这里做法都完全一样。

---

设有

$$g(n,k)=\sum_{i=1}^n\mu(i)[i\perp k] $$

一种方法是考虑直接莫反。

$$\begin{aligned}
g(n,k)&=\sum_{i=1}^n\mu(i)\sum_{d|i,d|k}\mu(d) 
=\sum_{d|k}\mu(d)\sum_{d|i}\mu(i) \\
&=\sum_{d|k}\mu(d)\sum_{i=1}^{n/d}\mu(id)
\end{aligned}$$

接下来有性质：$\mu(xy)=\mu(x)\mu(y)[x\perp y]$，正确性显然。

$$\begin{aligned}
g(n,k)&=\sum_{d|k}\mu(d)\sum_{i=1}^{n/d}\mu(i)\mu(d)[i\perp d]
=\sum_{d|k}\mu^2(d)\sum_{i=1}^{n/d}\mu(i)[i\perp d] \\
&=\sum_{d|k}\mu^2(d)g(\lfloor\frac nd\rfloor,d)
\end{aligned}$$

枚举因子递归下去。

另一种方法中，考虑 $k$ 中的质因子，发现我们只关心是否有这个因子，而不考虑它的次数。

于是得到新做法：从 $k$ 中取出质因子递归。

$p$ 是 $k$ 中某一个质因子。

$$\begin{aligned}
g(n,k)&=\sum_{i=1}^n\mu(i)[i\perp k] \\
&=\sum_{i=1}^n\mu(i)[i\perp\frac kp]-\sum_{i=1}^n\mu(i)[i\perp\frac kp][p|i]
\end{aligned}$$

因为 $p\not\perp i$ 等价于 $p|i$，减去这部分不合法的。

$$\begin{aligned}
g(n,k)&=g(n,\frac kp)-\sum_{i=1}^{n/p}\mu(ip)[ip\perp\frac kp] \\
&=g(n,\frac kp)-\sum_{i=1}^{n/p}\mu(i)\mu(p)[i\perp p][i\perp\frac kp] \\
&=g(n,\frac kp)-\mu(p)\sum_{i=1}^{n/p}\mu(i)[i\perp k] \\
&=g(n,\frac kp)+g(\lfloor\frac np\rfloor,k)
\end{aligned}$$

其中用到了 $\mu(p)=(-1)^1=-1$。

于是在开始可以将 $k$ 中质因子去重，并记录其质因子。递归中标记剩下哪些即可，同样用二维的 `unordered_map` 去重。

边界也容易处理，为 $g(0,k)=1$，及 $g(n,1)=\sum_{i=1}^n\mu(i)$，杜教筛莫比乌斯函数前缀即可。

---

时间复杂度分析：

处理 $f(n)$ 复杂度 $O(k\log k)$；

杜教筛 $\mu(n)$ 前缀复杂度 $O(n^{\frac 23})$；

递归求 $g(n,k)$ 中，第一维状态有 $O(\sqrt n)$ 个，第二维有 $k$ 的素因子个数，粗略估计有 $O(\dfrac{\log k}{\log\log k})$ 个。大概比 $d(k)$ 的做法更优？

最后的整除分块是 $O(\sqrt n)$ 的。

于是总时间大约是 $O(k\log k+n^{\frac 23}+\sqrt n\dfrac{\log k}{\log\log k})$ 的。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <unordered_map>

typedef long long ll;
const int V = 1000000001;
const int S = 1000001;
const int K = 2001;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
    return x * f;
}

int gcd(int a,int b) {
	int t;
	while(b) { t = a, a = b, b = t % b; }
	return a;
}

int n, m, k;
int df[S],p[S],tt,mu[S];

void Seive() {
    mu[1] = 1;
    for(int i = 2;i < S;i++) {
        if(!df[i]) p[++tt] = i, mu[i] = -1;
        for(int j = 1;j <= tt && i * p[j] < S;j++) {
            int t = i * p[j]; df[t] = 1;
            if(i % p[j]) mu[t] = -mu[i];
			else mu[t] = 0;
        }
    }
    for(int i = 1;i < S;i++) mu[i] += mu[i - 1];
    return;
}

ll f[K];
ll F(int n) { return f[k] * (n / k) + f[n % k]; }

std::unordered_map <ll,int> Mu;
int Mobius(ll n) {
    if(n < S) return mu[n];
    else if(Mu.count(n)) return Mu[n];
    int ans = 1;
    for(int i = 2;i <= n;i++) {
        int j = n / (n / i);
        ans -= (j - i + 1) * Mobius(n / i);
        i = j;
    }
    return Mu[n] = ans;
}

std::unordered_map <ll,std::unordered_map <ll,ll> > g;
int pk[S],tot;
ll G(ll n,ll k,int now) {
    if(!n) return 0; if(k == 1) return Mobius(n);
    if(g[n].count(k)) return g[n][k];
    return g[n][k] = G(n,k / pk[now],now + 1) + G(n / pk[now],k,now);
}

int main() {
    Seive();
    n = read(), m = read(), k = read();
    for(int i = 1;i <= tt && p[i] <= k;i++) {
        while(!(k % (p[i] * p[i]))) k /= p[i];
        if(!(k % p[i])) pk[++tot] = p[i];
    }
	for(int i = 1;i <= k;i++) {
		if(gcd(i,k) == 1) f[i] = 1;
		f[i] += f[i - 1];
	}
	ll ans = 0;
	for(ll i = 1;i <= n && i <= m;i++) {
		ll j = std::min(n / (n / i),m / (m / i));
		// std::printf("%lld %lld %lld\n",n / i,F(m / i),G(j,k,1));
		ans += (n / i) * F(m / i) * (G(j,k,1) - G(i - 1,k,1));
		i = j;
	}
	std::printf("%lld\n",ans);
    return 0;
}

```
感谢神 @11Dimensions 的思路。

---

## 作者：TopCarry (赞：1)

&emsp;&emsp;首先根据定义，可以推出当且仅当存在$x*k^l \equiv x*k(mod$ $y)$的时候分数是个纯循环的

&emsp;&emsp;那么就有存在$k^{l-1} \equiv1(mod y)$

&emsp;&emsp;于是就有$gcd(k,y)=1$,又因为要最简分数，又有$gcd(x,y)=1$

&emsp;&emsp;于是答案就是
$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=1][gcd(j,k)=1]$$

&emsp;&emsp;考虑把$i$提到后面，就是
$$\sum_{j=1}^{m}[gcd(j,k)=1]\sum_{i=1}^{n}[gcd(i,j)=1]$$

&emsp;&emsp;对后面这个$\sum_{i=1}^{n}[gcd(i,j)=1]$莫反一发：

$$f(x)=\sum_{i=1}^{n}[gcd(i,j)=x]$$

$$g(x)=\sum_{x|d}f(d)=\sum_{i=1}^{n}[x|i][x|j]$$

$$f(x)=\sum_{x|d}\mu(\frac{d}{x})g(d)$$

$$f(1)=\sum_{i=1}^{n}\mu(i)\sum_{d=1}^{n}[i|d][i|j]=\sum_{i=1}^{n}\mu(i)\lfloor\frac{n}{i}\rfloor[i|j]$$

&emsp;&emsp;那么原式就是
$$\sum_{j=1}^{m}[gcd(j,k)=1]\sum_{i=1}^{n}\mu(i)\lfloor\frac{n}{i}\rfloor[i|j]$$

&emsp;&emsp;修改枚举$j$是$i$的多少倍。

$$\sum_{i=1}^{n}\mu(i)\lfloor\frac{n}{i}\rfloor\sum_{j=1}^{\lfloor\frac{m}{i}\rfloor}[gcd(ij,k)=1]$$

&emsp;&emsp;把$gcd$拆出来

$$\sum_{i=1}^{n}\mu(i)\lfloor\frac{n}{i}\rfloor[gcd(i,k)=1]\sum_{j=1}^{\lfloor\frac{m}{i}\rfloor}[gcd(j,k)=1]$$

&emsp;&emsp;令$f(x)=\sum_{i=1}^{x}[gcd(i,k)=1]$

&emsp;&emsp;因为$gcd(a,b)=gcd(a$ $mod$ $b,b)$,所以每$k$个$[gcd(i,k)=1]$的值是一样的，也就是说$f(x)=\lfloor\frac{x}{k}\rfloor f(k)+f(x$ $mod$ $k)$,只要暴力处理$k$以内的$O(1)$求$f$了，而$k<=2000$,所以显然可以接受。

&emsp;&emsp;那么原式就是

$$\sum_{i=1}^{n}\mu(i)\lfloor\frac{n}{i}\rfloor[gcd(i,k)=1]f(\lfloor\frac{m}{i}\rfloor)$$

&emsp;&emsp;再设$g(x)=\sum_{i=1}^{x}\mu(i)[gcd(i,k)=1]$

$$\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor g(\lfloor\frac{n}{i}\rfloor)f(\lfloor\frac{m}{i}\rfloor)$$

&emsp;&emsp;这里只要$O(n)$处理$g(x)$,然后数论分块就可以拿$84pts$了，这应该是考场上能搞到的分数。

&emsp;&emsp;然后考虑怎么快速处理$g(x)$:

$$[gcd(i,k)=1]=\sum_{d|gcd(i,k)}\mu(d)=\sum_{d|i,d|k}\mu(d)$$

$$g(x)=\sum_{i=1}^{x}\mu(i)\sum_{d|i,d|k}\mu(d)$$

&emsp;&emsp;$ps$:推到这里我$sb$了一下，想着直接把$\mu(i)$和$\mu(d)$乘起来，忘了$\mu$只是积性而不是完全积性。

&emsp;&emsp;那么更改枚举项为$d$,并枚举$i$是$d$的几倍，从而抹掉$d|k$和$d|i$的限制:

$$g(x)=\sum_{d|k}\mu(d)\sum_{i=1}^{x/d}\mu(id)$$

&emsp;&emsp;这里是最妙的一步，根据莫比乌斯函数的定义，只有$gcd(i,d)=1$的时候$\mu(id)!=0$,那么可以往后扔一个$[gcd(i,d)=1]$:

$$g(x)=\sum_{d|k}\mu(d)\sum_{i=1}^{x/d}\mu(id)[gcd(i,d)=1]$$

&emsp;&emsp;之前说了，之前不能拆或者乘，是因为$\mu$不是完全积性的，只有互质才能操作，而现在$gcd(i,d)=1$,我们就可以把$d$扔到前面去：

$$g(x)=\sum_{d|k}\mu^2(d)\sum_{i=1}^{x/d}\mu(i)[gcd(i,d)=1]$$

&emsp;&emsp;我们把$g(x)$最初的式子提出来：

$$g(x)=\sum_{i=1}^{x}\mu(i)[gcd(i,k)=1]$$

&emsp;&emsp;在看下现在后面这一块：

$$\sum_{i=1}^{x/d}\mu(i)[gcd(i,d)=1]$$

&emsp;&emsp;唯一不同的是$x$变成了$x/d$，$k$变成了$d$，于是我们定义：

$$g(x,k)=\sum_{i=1}^{x}\mu(i)[gcd(i,k)=1]$$

&emsp;&emsp;就有：

$$g(x,k)=\sum_{d|k}\mu^2(d)g(x/d,d)$$

&emsp;&emsp;边界是什么呢，盯着这个最初的式子：

$$g(x,k)=\sum_{i=1}^{x}\mu(i)[gcd(i,k)=1]$$

&emsp;&emsp;当$x=0$,无法递归，$g(x,k)=0$;

&emsp;&emsp;当$x=1$,可以递归成$x=0$，也可以看出$g(1,k)=\mu(1)=1$

&emsp;&emsp;当$k=1$,无法递归，$g(x,k)=\sum_{i=1}^{x}\mu(i)$,但是这个$x$可以很大，我们杜教筛这个前缀和。

&emsp;&emsp;但是我还不会证明暴力枚举$k$的约数递归算$g(x)$复杂度为什么是对的，即便它记忆化了(然而它就是对的)。

&emsp;&emsp;$trick:$算$g(x,k)$的时候如果$\mu(d)=0$就不要递归了，不然会$T$掉。

&emsp;&emsp;$ps:$记忆化二元组$g(x,k)$的时候记得开$pair$，$struct$似乎对不上$map$红黑树的接口。


---

## 作者：AzusaCat (赞：0)

求 $k$ 进制下可以表示为纯循环小数（认为整数也是）的既约分数 $\dfrac{i}{j}$，且 $1\leqslant i\leqslant n$，$1\leqslant j\leqslant m$ 的个数。$n,m\leqslant 10^9$，$k\leqslant 2000$。

经过尝试可以发现，既约分数 $\dfrac{i}{j}$ 在 $k$ 进制下是纯循环的当且仅当 $\gcd(j,k)=1$（证明可以见其它题解）。

所以，我们只需要求
$$
\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\gcd(i,j)=1][\gcd(j,k)=1]
$$
因为要既约分数，所以要保证 $\gcd(i,j)=1$。

因为两个 $\gcd$ 都与 $j$ 有关，我们考虑把 $j$ 提到外面
$$
ans=\sum\limits_{j=1}^m[\gcd(j,k)=1]\sum\limits_{i=1}^n[\gcd(i,j)=1]
$$
然后我们对后面来一次莫比乌斯反演
$$
\begin{aligned}
ans&=\sum\limits_{j=1}^m[\gcd(j,k)=1]\sum\limits_{i=1}^n\sum\limits_{d\mid i,d\mid j}\mu(d)\\
&=\sum\limits_{j=1}^m[\gcd(j,k)=1]\sum\limits_{d\mid j}\lfloor\frac{n}{d}\rfloor\mu(d)
\end{aligned}
$$
然后我们把 $d$ 提到前面去
$$
ans=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor\mu(d)\sum\limits_{d\mid j,j\leqslant m}[\gcd(j,k)=1]
$$
我们发现，$j$ 可以表示为 $xd$，那么 $\gcd(j,k)=1$ 等价于 $\gcd(x,k)=1$ 且 $\gcd(d,k)=1$ ，于是我们有
$$
ans=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor\mu(d)[\gcd(d,k)=1]\sum\limits_{x=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(x,k)=1]
$$
然后我们观察第二个求和号，如果我们设 $f(z)=\sum\limits_{i=1}^z[\gcd(i,z)=1]$，那么后面的就是 $ f(\lfloor\dfrac{m}{d}\rfloor)$。

我们考虑是否能够快速计算 $f$，根据辗转相除（减）法的原理，我们有 $\gcd(x,k)=\gcd(x+k,k)$，所以我们有
$$
f(z)=\lfloor \frac{z}{k}\rfloor f(k)+f(z\bmod k)
$$
即我们按照每个数模 $k$ 的余数将其分为若干等价类。这样我们只需要预处理 $f(1)\dots f(k)$ 就可以在 $O(1)$ 时间内计算 $f(z)$。

那么有
$$
ans=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor f(\lfloor\frac{m}{d}\rfloor)\mu(d)[\gcd(d,k)=1]
$$
我们发现，如果我们可以快速计算 $\mu(d)[\gcd(d,k)=1]$ 的前缀和，我们就可以通过整除分块计算答案，那么问题就转化为了快速计算 $\mu(d)[\gcd(d,k)=1]$ 的前缀和。

我们设 $g(z)=\sum\limits_{d=1}^z\mu(d)[\gcd(d,k)=1]$，那么我们再来一次莫比乌斯反演：
$$
\begin{aligned}
g(z)&=\sum\limits_{d=1}^z\mu(d)\sum\limits_{t\mid d,t\mid k}\mu(t)\\
&=\sum\limits_{t\mid k}\mu(t)\sum\limits_{t\mid d,d\leqslant z}\mu(d)\\
&=\sum\limits_{t\mid k}\mu(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(dt)\\
\end{aligned}
$$
我们发现，如果 $\gcd(d,t)\not= 1$，那么 $dt$ 一定含有平方因子（$\gcd(d,t)^2$），所以这时 $\mu(dt)=0$，由于我们只在乎和，所以我们可以只对 $\mu(dt)\not=0$，即 $\gcd(d,t)=1$ 的情况计算。那么有：
$$
g(z)=\sum\limits_{t\mid k}\mu(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(dt)[\gcd(d,t)=1]
$$
这样由于我们强制令 $d,t$ 互质，我们就可以把 $\mu(dt)$ 拆成 $\mu(d)\mu(t)$：
$$
\begin{aligned}
g(z)&=\sum\limits_{t\mid k}\mu(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(d)\mu(t)[\gcd(d,t)=1]\\
&=\sum\limits_{t\mid k}\mu^2(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(d)[\gcd(d,t)=1]
\end{aligned}
$$
我们发现第二个求和号后面的东西和 $g$ 很像，不过是 $[\gcd(d,t)=1]$ 而不是 $[\gcd(d,k)=1]$，为此我们扩展一下 $g$ 的定义，设 $g(z,c)=\sum\limits_{i=1}^z\mu(i)[\gcd(i,c)=1]$，那么
$$
g(z,c)=\sum\limits_{t\mid c}\mu^2(t)g(\lfloor\frac{z}{t}\rfloor,t)
$$
边界条件为 $c=1$，此时就是莫比乌斯函数的前缀和，可以杜教筛求解。注意计算时要记忆化，复杂度据说是 $O(n^{\frac{2}{3}}+\sigma_0(k)\sqrt n)$ 的，不会证。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int const N=1000005;
int k,p[N+5],mu[N+5],smu[N+5],cnt,F[2005];
bool flag[N+5];
vector<int>v[2005];
int gcd(int x,int y){return y?gcd(y,x%y):x;}
map<pair<int,int>,int>mp;
map<int,int>mp2;
int s(int n)
{
    if(n<=N)return smu[n];
    if(mp2.find(n)!=mp2.end())return mp2[n];
    int ans=1;
    for(int l=2,r;l<=n;l=r+1)
        r=(n/(n/l)),ans-=(r-l+1)*s(n/l);
    return mp2[n]=ans;
}
int f(int n){return (n/k)*F[k]+F[n%k];}
int g(int z,int c)
{
    if(c==1)return s(z);
    if(!z)return 0;
    if(mp.find(make_pair(z,c))!=mp.end())return mp[make_pair(z,c)];
    int ans=0;
    for(auto i:v[c])
        if(mu[i])ans+=g(z/i,i);
    return mp[make_pair(z,c)]=ans;
}
int main()
{
    mu[1]=1;
    for(int i=2;i<=N;i++)
    {
        if(!flag[i]){p[++cnt]=i;mu[i]=-1;}
        for(int j=1;j<=cnt&&i*p[j]<=N;j++)
        {
            flag[i*p[j]]=1;
            if(!(i%p[j])){mu[i*p[j]]=0;break;}
            mu[i*p[j]]=-mu[i];
        }
    }
    for(int i=1;i<=N;i++)smu[i]=smu[i-1]+mu[i];
    int n,m;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)F[i]=F[i-1]+(gcd(k,i)==1);
    for(int i=1;i<=k;i++)
        for(int j=i;j<=k;j+=i)
            v[j].push_back(i);
    long long ans=0;
    for(int l=1,r;l<=min(n,m);l=r+1)
    {
        r=min(n/(n/l),m/(m/l));
        ans+=1ll*(n/l)*f(m/l)*(g(r,k)-g(l-1,k));
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：zzw4257 (赞：0)

求$\frac{x}{y}(1\le x\le n,1\le y\le m)$在$k$进制下为纯循环小数**值**的个数
一个分数在k进制为纯循环小数当且仅当$\exists t$使得$y|k^t-1$                 
可以感性理解为试除余数循环过程
同时我们用最小表示法:只求既约分数
分类讨论一下可知一个分数在k进制为纯循环小数当且仅当$(y,k)=1$
问题转为
$$\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$$

$84~pts'$(前情化简:很基础,只有法五不需要)

$$
\begin{aligned}Ans
&=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]
\\&=\sum_{j=1}^m[(j,k)=1]\sum_{i=1}^n[(i,j)=1]
\\&=\sum_{j=1}^m[(j,k)=1]\sum_{d\mid j}\mu(d)\lfloor\frac{n}{d}\rfloor
\\&=\sum_{d=1}^n\left \lfloor \frac{n}{d} \right \rfloor\mu(d)\sum_{d|j}^m[(j,k)=1]
\\&=\sum_{d=1}^n\left \lfloor \frac{n}{d} \right \rfloor\mu(d)\sum_{i=1}^{\left \lfloor \frac{m}{d} \right \rfloor}[(id,k)=1]
\\&=\sum_{d=1}^n\left \lfloor \frac{n}{d} \right \rfloor (\sum_{i=1}^{\lfloor \frac{m}{d} \rfloor}[(i,k)=1])\mu(d)[(d,k)=1]\end{aligned}
$$


设$f(n)=\sum_{i=1}^n[(i,k)=1]$
则$Ans=\sum_{d=1}^n\left \lfloor \frac{n}{d} \right \rfloor f(\lfloor \frac{m}{d} \rfloor)\mu(d)[(d,k)=1]$
感性理解一下互质是有循环节的
$f(n)=\lfloor\frac{n}{k}\rfloor f(k) + f(n~mod~k)$与处理后可以$O(1)$求

$100~pts'$(法一)

设$S(n,k)=\sum_{i=1}^n[(i,k)=1]\mu(i)$
$\begin{aligned}S(n,k)
&=\sum\limits_{i=1}^n\mu(i)\sum\limits_{d|i,d|k}\mu(d)
\\&=\sum\limits_{d|k}\mu(d)\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(id)
\\&=\sum\limits_{d|k}\mu^2(d)\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}[(i,d)=1]\mu(i)
\\&=\sum\limits_{d|k}\mu^2(d)S(\lfloor\frac{n}{d}\rfloor,d)
\end{aligned}
$
递归边界为$k=1$是直接求$\mu$的前缀和

$100~pts'$(法二)

考虑筛去互质的数的过程可以看做是每一个质因子独立进行的

设$S_i(n)=\sum_{j=1}^n\mu(j)[\forall x\in[1,i],P_x^{[k]}\nmid j]$

考虑$i$变化的减少量

$S_i(n)=S_{i-1}(n)-\mu(P_i^{[k]})S_{i-1}(\lfloor\frac{n}{P_i^{[k]}}\rfloor)$

这个方法用到了后面$\mathtt{min\_25}$筛的一些分类思想

$100~pts'$(法三)

(最慢的方法)

设$f(n)=\displaystyle{\sum_{i=1}^n[(i,k=1)]\mu(i)}$
考虑直接杜教筛这♂意儿
配什么呢
大家自己尝试，答案在下面
$g(n)=[(n,k)=1]$
$(f*g)(n)=\sum_{d|n}[(d,k)=1][(\frac{n}{d},k)=1]\mu(d)$
$=[(n,k)=1]\sum_{d|n}\mu(d)=\iota(n)$

$100~pts'$(法四)

设$p$是$k$随便一个素因子(可以取$P_1^{[k]}$)$,k=p^x q$
$g(n,k)=\sum_{i=1}^n\mu(i)[(i,p)=1][(i,q)=1]$
当$(i,q)=1$则$(i,p)=1$或$p$
$g(n,k)=\sum_{i=1}^n\mu(i)[(i,q)=1]-\sum_{i=1}^n\mu(i)[(i,q)=1][p\mid i]$
$=g(n,q)-\sum_{d=1}^{\lfloor\frac{n}{p}\rfloor}\mu(ip)[(i,q)=1]$
$=g(n,q)+\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(i)[(i,k)=1]$
$=g(n,q)+g(\lfloor\frac{n}{p}\rfloor,k)$

$100~pts'$(法五)

令$S(n,m,k)=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$
$=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1]\sum_{d|j,d|k}\mu(d)$
$=\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[(i,j)=1][(i,d)=1]$
$=\sum_{d|k}\mu(d)S(\lfloor\frac{m}{d}\rfloor,n,d)$

对$k=1$就是简单数论分块一下


#### 本题小结

这是我们处理一个互质整除类函数复合的几个角度

- 看是不是积性函数或者有特殊性质能筛
- 能否从微观(质因数)层面容斥函数，形成递推式
- 想方设法把捆绑在一起的扯开
- 暴力展开

---

## 作者：chihik (赞：0)

类比十进制下的纯循环小数，$k$ 进制下的纯循环小数满足最简分数分母与 $k$ 互质。

而题目要求相同数值只计数一次，所以只需要考虑最简分数的情况。

那么答案为：

$$\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$$

$$\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1]\sum_{d|{(j,k)}}\mu(d)$$

$$\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[(i,jd)=1]$$

$$\sum_{d|k}\mu(d)\sum_{i=1}^n\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[(i,j)=1][(i,d)=1]$$

$$\sum_{d|k}\mu(d)\sum_{i=1}^{\lfloor \frac{m}{d} \rfloor}\sum_{j=1}^n[(i,j)=1][(j,d)=1]$$

后面的求和跟原来的形式相同 ， 令 $f(n,m,k)=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1][(j,k)=1]$

那么：

$$f(n,m,k)=\sum_{d|k}f(\lfloor \frac{m}{d} \rfloor , n ,d)$$

$n=0$ 或 $m=0$ 时 $f(n,m,k)=0$。

$k=1$ 时 $f(n,m,k)=\sum_{i=1}^n\sum_{j=1}^m [(i,j)=1]=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor\frac{n}{d}\rfloor\rfloor\frac{m}{d}\lfloor$

```cpp
#include <map>
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long

const int MAXN = 1e6;
int n , m , k;

int num , prime[ MAXN + 5 ] , mu[ MAXN + 5 ] , summ[ MAXN + 5 ];
bool vis[ MAXN + 5 ];
void sieve( ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) { prime[ ++ num ] = i; mu[ i ] = -1; }
		for( int j = 1 ; j <= num && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
	for( int i = 1 ; i <= MAXN ; i ++ ) summ[ i ] = summ[ i - 1 ] + mu[ i ];
}

map< int , int > Mapm;
int Summu( int n ) {
	if( n <= MAXN ) return summ[ n ];
	if( Mapm[ n ] ) return Mapm[ n ];
	int Ans = 1;
	for( int l = 2 , r ; l <= n ; l = r + 1 ) {
		r = n / ( n / l );
		Ans -= ( r - l + 1 ) * Summu( n / l ); 
	}
	return Mapm[ n ] = Ans;
}

LL f( int n , int m , int k ) {
	if( !n || !m ) return 0;
	if( k == 1 ) {
		long long Ans = 0;
		for( int l = 1 , r ; l <= min( n , m ) ; l = r + 1 ) {
			r = min( n / ( n / l ) , m / ( m / l ) );
			Ans += 1ll * ( Summu( r ) - Summu( l - 1 ) ) * ( n / l ) * ( m / l );
		}
		return Ans;
	}
	long long Ans = 0;
	for( int d = 1 ; d <= k ; d ++ )
		if( k % d == 0 && mu[ d ] ) Ans += mu[ d ] * f( m / d , n , d );
	return Ans;
}

int main( ) {
	sieve( );
	scanf("%d %d %d",&n,&m,&k);
	printf("%lld\n", f( n , m , k ) );
	return 0;
} 
```


---

## 作者：huangzirui (赞：0)

题意：

求有多少个不同的 $\dfrac{x}{y}$ 的取值在 $k$ 进制下是纯循环小数。

其中 $1\leq x \leq n\ ,\ 1\leq y \leq m$

纯循环小数 即一个数可以被表示成形如
$a.\dot{c_1}c_2...\dot{c_k}$
的形式。

$n,m \leq 10^9\ \ \ 2 \leq k\leq 2\times10^3$

鸣谢： [Kelin](https://www.luogu.com.cn/user/20156) 的题解让我学会了此题。

---
本文需要用到的某些特殊符号

$\perp$ 互质 $\ \ \ *$ Dirichlet 卷积 $\ \ \ \epsilon$ 单位根 $\ \ \ (a,b)$  $a$ 和 $b$ 的最大公约数

---
下文中的 $n$ 均小于等于 $m$ 。

性质：

**若 $\dfrac{x}{y}$ 在 $k$ 进制下是纯循环小数当且仅当 $y \perp k$**

那么题目要求的就是：

$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[i\perp j][j\perp k]$$

由 $[i \perp j] \Leftrightarrow [(i,j)=1]$

$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[(i,j)=1][(j,k)=1]$$

然后拆一下式子，不妨先考虑 $[i\perp j]$ ，由 $\epsilon = \mu * 1$ :

$$\sum\limits_{i=1}^n\sum_{j=1}^m\sum\limits_{d|(i,j)}\mu(d)\ [(j,k)=1]$$

考虑把 $[(j,k)=1]$ 挪到前面：

$$\sum\limits_{j=1}^m[(j,k)=1]\sum_{i=1}^n\sum\limits_{d|(i,j)}\mu(d)$$

（后面这一段很套路）

由 $\text{gcd}$ 的性质：

$$\sum\limits_{j=1}^m[(j,k)=1]\sum_{i=1}^n\sum\limits_{d|i,j}\mu(d)$$

先枚举 $d$ ：

$$\sum\limits_{j=1}^m[(j,k)=1]\sum_{d | j\ ,\ d\leq n}\sum\limits_{i=1}^{\left\lfloor{\frac{n}{d}}\right\rfloor}\mu(d)$$

$$\sum\limits_{j=1}^m[(j,k)=1]\sum_{d | j\ ,\ d\leq n}\left\lfloor{\frac{n}{d}}\right\rfloor\mu(d)$$

再把 $d$ 挪到前面来：

$$\sum\limits_{d=1}^{n}\left\lfloor{\frac{n}{d}}\right\rfloor\mu(d)\sum_{j=1}^{m}[d|j]\ [(j,k)=1]$$

然后你发现这里有点不太好搞了。

考虑消掉 $[d|j]$ 这个限制。

把 $j$ 换成 $dj$ ：

$$\sum\limits_{d=1}^{n}\left\lfloor{\frac{n}{d}}\right\rfloor\mu(d)\sum_{j=1}^{\left\lfloor{\frac{m}{d}}\right\rfloor}\ [(dj,k)=1]$$

你考虑把 $[(dj,k=1)]$ 拆成 $[(d,k)=1]$ 和 $[(j,k)=1]$ ：

$$\sum\limits_{d=1}^{n}\left\lfloor{\frac{n}{d}}\right\rfloor\mu(d) [(d,k)=1] \sum_{j=1}^{\left\lfloor{\frac{m}{d}}\right\rfloor}\ [(j,k)=1]$$

然后后面这一段 $\sum_{j=1}^{\left\lfloor{\frac{m}{d}}\right\rfloor}\ [(j,k)=1]$ 可以先预处理出值。

设 $F(x) = \sum\limits_{i=1}^x[(i,k)=1]$

有 $F(x) = \left\lfloor{\frac{x}{k}}\right\rfloor\varphi(k)+F(x\mod k)\ \ \ \ \ \ (x > k)$

对于 $x\leq k$ 可以暴力算。

然后我们就解决了 $\sum_{j=1}^{\left\lfloor{\frac{m}{d}}\right\rfloor}\ [(j,k)=1]$ 部分。

现在考虑

$$\sum\limits_{d=1}^{n}\left\lfloor{\frac{n}{d}}\right\rfloor\mu(d) [(d,k)=1] $$

由于 $\sum\limits_{d=1}^{n}\left\lfloor{\frac{n}{d}}\right\rfloor$ 可以直接数论分块，只需要求 $\sum\limits_{d=1}^{n}\mu(d) [(d,k)=1]$ 的前缀和即可。

转化一下：

$$\sum\limits_{d=1}^{n}\mu(d) \sum_{p|(d,k)}\mu(p) $$

$$\sum\limits_{d=1}^{n}\mu(d) \sum_{p|d,k}\mu(p) $$

$$\sum\limits_{d=1}^{n}\sum_{p|d}\mu(d) \sum_{p|k}\mu(p) $$

再把 $\sum_{p|k}\mu(p)$ 挪到前面：

$$\sum_{p|k}\mu(p)\sum\limits_{d=1}^{n}\sum_{p|d}\mu(d) $$

把 $d$ 换成 $dp$ 消掉 $\sum_{p|d}$

$$\sum_{p|k}\mu(p)\sum\limits_{d=1}^{\left\lfloor{\frac{n}{p}}\right\rfloor}\mu(dp) $$

由于 $\mu$ 的性质，若 $(d,p)\not = 1$ 则 $\mu(dp)=0$

$$\sum_{p|k}\mu(p)\sum\limits_{d=1}^{\left\lfloor{\frac{n}{p}}\right\rfloor}\mu(dp)[d \perp p] $$

拆一下 $\mu(dp)$

$$\sum_{p|k}\mu(p)\sum\limits_{d=1}^{\left\lfloor{\frac{n}{p}}\right\rfloor}\mu(p)\mu(d)[d \perp p] $$

$$\sum_{p|k}\mu(p)^2\sum\limits_{d=1}^{\left\lfloor{\frac{n}{p}}\right\rfloor}\mu(d)[d \perp p] $$

后面的这个式子 $\sum\limits_{d=1}^{\left\lfloor{\frac{n}{p}}\right\rfloor}\mu(d)[d \perp p] $ 和一开始的 $\sum\limits_{d=1}^{n}\mu(d) [d\perp k]$ 形式其实是一样的。

设 $g(a,b) = \sum\limits_{d=1}^a\mu(d)[d \perp b]$

有： 

$$g(a,b)=\sum_{p|b}\mu(p)^2g(\left\lfloor{\frac{a}{p}}\right\rfloor,p)$$

考虑边界条件。

显然 $g(0,x) = 0$

对于 $g(x,1) = \sum\limits_{d=1}^x\mu(d)[d\perp 1]=\sum\limits_{d=1}^x\mu(d)$

可以利用杜教筛解决。

~~这道题太毒瘤了~~

细节很多，而且需要卡常。

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	char c=getchar();ll x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=5000000;
int i,j,k,n,m;
int prime[N],phi[N],is_prime[N],mu[N],Mu[N],num,F[N];
int gcd(int x,int y){return y==0?x:gcd(y,x%y);}
void init(){
	mu[1]=1;
	for(int i=2;i<N;i++)is_prime[i]=1;
	for(int i=2;i<N;i++){
		if(is_prime[i])prime[++num]=i,mu[i]=-1;
		for(int j=1;j<=num&&i*prime[j]<N;j++){
			is_prime[i*prime[j]]=0;
			if(i%prime[j]==0)break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i=1;i<N;i++)Mu[i]=Mu[i-1]+mu[i];
	for(int i=1;i<=k;i++)F[i]=F[i-1]+(gcd(i,k)==1);
}
ll get_F(int x){
	return ((ll)x/k)*F[k]+F[x%k];
}
map<int,int>MU;
int get_Mu(int x){
	if(x<N)return Mu[x];
	if(MU[x])return MU[x];
	int ans=1;
	for(int l=2,r=0;l<=x;l=r+1){
		r=x/(x/l);
		ans-=1ll*(r-l+1)*get_Mu(x/l);
	}return MU[x]=ans;
}
map<pair<int,int>,ll>mapG;
ll G(int a,int b){
	if(a==0)return 0;
	if(a==1)return 1ll;
	if(b==1)return get_Mu(a);
	if(mapG[make_pair(a,b)])return mapG[make_pair(a,b)];
	ll ans=0;
	for(int i=1;i*i<=b;i++)
		if(b%i==0){
			if(i*i==b){if(mu[i])ans+=mu[i]*mu[i]*G(a/i,i);}
			else{
				if(mu[i])ans+=mu[i]*mu[i]*G(a/i,i);
				if(mu[b/i])ans+=mu[b/i]*mu[b/i]*G(a/(b/i),b/i);
			}
		}
	return mapG[make_pair(a,b)]=ans;
}
ll ans=0;
int main(){
	cin>>n>>m>>k;
	init();
	for(int l=1,r=0;l<=min(n,m);l=r+1){
		r=min(n/(n/l),m/(m/l));
		ll Sum=G(r,k)-G(l-1,k),F=get_F(m/l);
		if(Sum!=0)ans+=(ll)(n/l)*F*Sum;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：LCuter (赞：0)

## [NOI2016]循环之美 题解

##### $\text{Description}$

给定 $n,m,k$，求有多少个 $(x,y)$ 满足 $1\le x\le n,1\le y\le m$，且 $\frac{x}{y}$ 在 $k$ 进制下为纯循环小数，特别地，整数也算纯循环小数。同一个数值的 $\frac{x}{y}$ 只算一次。

##### $\text{Solution}$

首先，为了限定同一个数值，我们可以认为 $x\perp y$。接着我们考虑什么情况下会是纯循环小数。在十进制下的既约分数中，若分母包含 $2$ 或 $5$，那么这个分数要么是有限小数，要么是前面有一段非循环节的循环小数。推广一下，我们只需令分母与 $k$ 互质即可，这里就不证明了。

那么我们可以得到我们要求的式子：

$\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]$

我们对 $[i\perp j]$ 进行反演：

$\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j}\mu(d)[j\perp k]$

套路地枚举 $d$，那么 $i,j$ 变为 $d$ 的倍数：

$\sum_{d=1}^{\min(n,m)}\mu(d)[d\perp k]\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[j\perp k]$

发现和 $i$  无关，把它变成：

$\sum_{d=1}^{\min(n,m)}\mu(d)[d\perp k]\lfloor\frac{n}{d}\rfloor\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[j\perp k]$

我们记 $f(n,k)=\sum_{d=1}^n\mu(d)[d\perp k],g(n,k)=\sum_{j=1}^ n[j\perp k]$。

原式化为：

$\sum_{d=1}^{\min(n,m)}\mu(d)[d\perp k]\lfloor\frac{n}{d}\rfloor g(\lfloor\frac{m}d\rfloor,k)$

那么只需计算出 $f$ 与 $g$ 在数论分块中需要计算的点处的取值，就可以用数论分块解决。

我们先计算 $g$，考虑将互质写成这样的形式 $\sum_{j=1}^n[\gcd(j,k)=1]$。我们有一个 $\gcd$ 的性质：$\gcd(a,b)=\gcd(a\bmod b,b)$。上式实际上可以变成若干相同段，我们可以得到一个式子：

$g(n,k)=\lfloor\frac{n}{k}\rfloor g(k,k)+g(n\bmod k,k)$

注意到 $k\le 2000$，那么预处理 $g(1,k) $ 到 $ g(k,k)$ 的值即可，这部分的时间复杂度是 $O(k\log k)$ 的，之后每次询问都是 $O(1)$。

现在来计算 $f$ 。我们有：

$\sum_{i=1}^n\mu(i)[i\perp k]$

对后面应用莫比乌斯反演：

$\sum_{i=1}^n\mu(i)\sum_{d|i,d|k}\mu(d)$

枚举 $d$，有：

$\sum_{d|k}\mu(d)\sum_{d|i}\mu(i)$

进行变量替换，将原先的 $i$ 变为 $\frac{i}{d}$，有：

$\sum_{d|k}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(id)$

我们有 $\mu(ab)=\mu(a)\mu(b)[a\perp b]$。当 $a\perp b$ 时，由于 $\mu$ 是积性函数，所以满足。当 $\gcd(a,b)\neq 1$ 时，说明 $a$ 与 $b$ 有相同的质因子，那么两者相乘就会产生指数大于 $1$ 的质因子，此时 $\mu(ab)=0$，也满足。我们可以对上式进行这样的变换：

$\sum_{d|k}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)\mu(d)[i\perp d]$

然后很明显地可以把 $\mu(d)$ 提出去：

$\sum_{d|k}\mu(d)^2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)[i\perp d]$

发现后面的部分就是 $f(\lfloor\frac{n}{d}\rfloor,d)$，代入：

$f(n,k)=\sum_{d|k}\mu(d)^2f(\lfloor\frac{n}{d}\rfloor,d)$

当 $k>1$ 时，我们递归地去求解，注意到我们都是求形似 $\lfloor\frac{n}{i}\rfloor$ 处的式子，那么记忆化只需用类似杜教筛的记忆方式即可。

当 $k=1$ 时，有：

$f(n,1)=\sum_{i=1}^n\mu(i)$

杜教筛就可以解决。

于是原式就可以应用数论分块求解。

##### $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
#define LL long long
#define MAXN 2000005
#define Up 2000000
using namespace std;
inline LL Min(LL a,LL b){return a<b?a:b;}
inline LL read(){
    REG LL x(0);
    REG char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x*10)+(c^48),c=getchar();
    return x;
}

LL n,m,k;

int Prime[MAXN],vis[MAXN],Mu[MAXN],MuSum[MAXN],cnt,g[2005];

LL gcd(LL a,LL b){return b?gcd(b,a%b):a;}

inline void MakeSum(){
    Mu[1]=1;
    for(REG int i=2;i<=Up;++i){
        if(!vis[i]) Prime[++cnt]=i,Mu[i]=-1;
        for(REG int j=1;j<=cnt&&i*Prime[j]<=Up;++j){
            vis[i*Prime[j]]=1;
            if(!(i%Prime[j])) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for(REG int i=1;i<=Up;++i) MuSum[i]=MuSum[i-1]+Mu[i];

    for(REG int i=1;i<=k;++i)
        if(gcd(i,k)==1) g[i]=g[i-1]+1;
        else g[i]=g[i-1];
}

map<LL,LL> MemMu;

LL SumMu(LL x){
    if(x<=Up) return MuSum[x];
    if(MemMu[x]) return MemMu[x];
    LL res=0,l=2,r=0;
    for(;l<=x;l=r+1)
        r=x/(x/l),res+=(r-l+1)*SumMu(x/l);
    return MemMu[x]=1ll-res;
}

map< pair<LL,LL> ,LL> MemF;

LL SumF(LL x,LL k){
    if(x<=1) return x;
    if(k==1) return SumMu(x);
    if(MemF[make_pair(x,k)]) return MemF[make_pair(x,k)];
    LL res=0;
    for(REG LL i=1;i*i<=k;++i){
        if((k%i)) continue;
        if(i*i==k) res+=1ll*Mu[i]*Mu[i]*SumF(x/i,i);
        else res+=1ll*Mu[i]*Mu[i]*(Mu[i]?SumF(x/i,i):0)+1ll*Mu[k/i]*Mu[k/i]*(Mu[k/i]?SumF(x/(k/i),k/i):0);
    }
    return MemF[make_pair(x,k)]=res;
}

LL G(LL x,LL k){return x/k*g[k]+g[x%k];}

LL Divide(LL x,LL y,LL k){
    LL res=0,l=1,r=0;
    for(;l<=Min(x,y);l=r+1)
        r=Min(x/(x/l),y/(y/l)),res+=(x/l)*G(y/l,k)*(SumF(r,k)-SumF(l-1,k));
    return res;
}

void Work(){
    n=read(),m=read(),k=read();
    MakeSum();
    printf("%lld\n",Divide(n,m,k));
}

int main(){Work();}
```



---

## 作者：不存在之人 (赞：0)

## 推导1

首先有一个神奇的结论，$x/y$（$x$，$y$互质）在$k$进制下为纯循环小数当且仅当$y$与$k$互质，理由如下

当$x/y$纯循环，最短循环节长度为$L$，那么第二个循环节开头数字是$x*(k^L)%y$的结果，第一个循环节开头是$x%y$的结果

因此有$x*(k^L)=x(mod$ $y)$

因为$x$与$y$互质，可以消去$x$，得$k^L=1(mod$ $y)$

容易得出$(k,y)=1$

## 推导2

（莫比乌斯反演）
![](https://i.loli.net/2019/01/01/5c2b6be8a8fd4.png)
最后一步中把$y/d$当做一个变量，可以看做是$t=y/d$，枚举$t=1~m/d$

按$n/d$和$m/d$可以将$d$分成$O(sqrt(n))$块

## 推导3

设![](https://i.loli.net/2019/01/01/5c2b6be90d5ee.jpg)

当使$n/d=a,m/d=b$的最大$d$为$q$，最小$d$为$p$//就是说分块出来是$p$到$q$

要向答案累加$a*[S(q)-S(p-1)]*T(b)$

$S(x)$和$T(x)$要通过递归求得

设k=p1^a1×p2^a2×...×pn^an

设$s(i,x)$为小于等于$x$的，与$k$的前$i$种质因子的乘积互质的自然数的$μ$函数的和

$t(i,x)$为小于等于$x$的，与$k$的前$i$种质因子的乘积互质的自然数的个数

于是$S(x)=s(n,x)$  $T(x)=t(n,x)$//这里$n$是$k$的质因子种数

递推方法$s(i,x)=s(i-1,x)-μ(pi)s(i,[xpi])$

即减去与$k$的$gcd$为$pi$的幂的自然数的$μ$函数值之和

其中如果$gcd$的$pi$指数大于等于$2$，那么对应的数的$μ$函数为$0$

所以对函数的和有贡献的数只有除以一个$pi$以后与$pi$互质的，故由积性函数性质，可以由除$pi$以后的$μ$直接乘上$pi$的$μ$值（显然是$-1$）

所以化简一下其实是$s(i,x)=s(i-1,x)+s(i,[xpi])$

类比但是更简单的，$t$的递推式
$t(i,x)=t(i-1,x)-t(i-1,[xpi])$

其中$t(i-1,x)$是不考虑$i$及后面的质因子的互质数个数，$t(i-1,[xpi])$是$1$到$x$中与前$i$种质因子乘积的$gcd$仅为$pi$的数的个数

对于求过的$s$和$t$函数，建议$map$一下，否则可能会超时

递归底层$i=0$，$t(0,x)=x$，$s$需要求$μ$的前缀和

$n<=1e9$还挺大的，但是恰好有个东西叫杜教筛，专门求积性函数的前缀和，效率n^(2/3)，完结撒花
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
#define long long long
#define to i*prime[j]
#define maxn 1000005
using namespace std;
long n,m,k;
int p;
int miu[maxn],prime[maxn],sum[maxn],k_prf[10];
bool sift[maxn];
map<int,int> mp;
map<int,int> ms[10];
map<int,int> mt[10];
void init()
{
	miu[1]=sum[1]=1;
	for(int i=2;i<maxn;i++)
	{
		if(!sift[i])
		{
			prime[++p]=i;
			miu[i]=-1;
		}
		sum[i]=sum[i-1]+miu[i];
		for(int j=1;j<=p&&to<maxn;j++)
		{
			sift[to]=true;
			if(i%prime[j]==0) 
			{
				miu[to]=0;
				break;
			}
			else miu[to]=-miu[i];
		}
	}
}
int sum_miu(int x)
{
	if(x<maxn) return sum[x];
	if(mp.count(x)) return mp[x];
	int ans=1;
	for(int i=2,p;p<x;i=p+1)
	{
		p=x/(x/i);
		ans-=sum_miu(x/i)*(p-i+1);
	}
	return mp[x]=ans;
}
long S(int x,int r)
{
	if(!x) return sum_miu(r);
	if(r<=1) return r;
	if(ms[x].count(r)) return ms[x][r];
	return ms[x][r]=S(x-1,r)+S(x,r/k_prf[x]);
}
int T(int x,int r)
{
	if(!x) return r;
	if(r<=1) return r;
	if(mt[x].count(r)) return mt[x][r];
	return mt[x][r]=T(x-1,r)-T(x-1,r/k_prf[x]);
}
int main()
{
 	init();
 	scanf("%lld%lld%lld",&n,&m,&k);
 	int kk=k;
 	p=0;
 	for(int i=1;kk>1;i++)
 	{
 		if(kk%prime[i]==0) 
 		{
 			k_prf[++p]=prime[i];
 			while(kk%prime[i]==0) 
 				kk/=prime[i];
		}
	 }
	long ans=0ll;
	for(int i=1,t;i<=n&&i<=m;i=t+1)
	{
		t=min(m/(m/i),n/(n/i));
		ans+=(n/i)*(S(p,t)-S(p,i-1))*T(p,m/i);
	}
	printf("%lld",ans);
}
```

---


# [NOI2016] 国王饮水记

## 题目描述

跳蚤国有 $n$ 个城市，伟大的跳蚤国王居住在跳蚤国首都中，即 $1$ 号城市中。

跳蚤国最大的问题就是饮水问题，由于首都中居住的跳蚤实在太多，跳蚤国王又体恤地将分配给他的水也给跳蚤国居民饮用，这导致跳蚤国王也经常喝不上水。

于是，跳蚤国在每个城市都修建了一个圆柱形水箱，这些水箱完全相同且足够高。一个雨天后，第 $i$ 个城市收集到了高度为 $h_i$ 的水。由于地理和天气因素的影响，任何两个不同城市收集到的水高度互不相同。

跳蚤国王也请来蚂蚁工匠帮忙，建立了一个庞大的地下连通系统。跳蚤国王每次使用地下连通系统时，可以指定任意多的城市，将这些城市的水箱用地下连通系统连接起来足够长的时间之后，再将地下连通系统关闭。由连通器原理，这些城市的水箱中的水在这次操作后会到达同一高度，并且这一高度等于指定的各水箱高度的平均值。

由于地下连通系统的复杂性，跳蚤国王至多只能使用 $k$ 次地下连通系统。

跳蚤国王请你告诉他，首都 $1$ 号城市水箱中的水位最高能有多高？

## 说明/提示

### 样例解释 1

由于至多使用一次地下连通系统，有以下五种方案：
 
1. 不使用地下连通系统：此时 $1$ 号城市的水箱水位为 $1$。 
2. 使用一次连通系统，连通 $1$、$2$ 号：此时 $1$ 号城市的水箱水位为 $5/2$。 
3. 使用一次连通系统，连通 $1$、$3$ 号：此时 $1$ 号城市的水箱水位为 $2$。 
4. 使用一次连通系统，连通 $2$、$3$ 号：此时 $1$ 号城市的水箱水位为 $1$。 
5. 使用一次连通系统，连通 $1$、$2$、$3$ 号：此时 $1$ 号城市的水箱水位为 $8/3$。

### 样例解释 2

此时最优方案为使用两次连通系统，第一次连通 $1,3$ 号，第二次连通 $1,2$ 号。

### 样例 3

详见附加文件。

### 提示

为保证答案精度，我们一般需要尽可能地在运算过程中保留超过 $p$ 位小数。我们可以证明，在各个子任务的参考算法中都能保证，在任何时候始终保留 $\frac{6}{5}p$ 位小数时，对任何输入得到的输出，与参考答案的绝对误差都小于 $10^{-p}$。

为了方便选手处理高精度小数，我们提供了定点高精度小数类。选手可以根据自己的需要参考与使用该类，也可以不使用该类。其具体的使用方法请参考下发的文档 `decimal.pdf`（见附件）。

### 数据范围

::cute-table{tuack}

| 测试点编号 | $n$ | $k$ | $p$ |
|:-:|:-:|:-:|:-:|
| 1 | $\le 2$ | $\le 5$ | $=5$ |
| $2$ | $\le 4$ | ^ | ^ |
| $3$ | ^ | ^ | ^ |
| 4 | $\le 10$ | $=1$ | ^ |
| $5$ | ^ | $=10^9$ | ^ |
| $6$ | ^ | $\le 10$ | ^ |
| $7$ | ^ | ^ | ^ |
| $8$ | $\le 100$ | $=1$ | ^ |
| $9$ | ^ | $=10^9$ | $=40$ |
| $10$ | ^ | $\le 10^9$ | ^ |
| $11$ | ^ | ^ | ^ |
| $12$ | ^ | ^ | ^ |
| $13$ | $\le 250$ | ^ | $=100$ |
| $14$ | $\le 500$ | ^ | $=200$ |
| $15$ | $\le 700$ | ^ | $=300$ |
| $16$ | ^ | ^ | ^ |
| $17$ | ^ | ^ | ^ |
| $18$ | $\le 2500$ | ^ | $=1000$ |
| $19$ | $\le 4000$ | ^ | $=1500$ |
| $20$ | $\le 8000$ | ^ | $=3000$ |

## 样例 #1

### 输入

```
3 1 3
1 4 3```

### 输出

```
2.666667```

## 样例 #2

### 输入

```
3 2 3
1 4 3```

### 输出

```
3.000000```

# 题解

## 作者：yybyyb (赞：45)

洛谷的$Markdown$换行什么的很迷啊，如果看得不舒服直接到[我的博客](https://www.cnblogs.com/cjyyb/p/9302223.html)
去看吧。。。。

首先肯定是找性质。
明确一点，**比$h_1$小的没有任何意义**。
所以我们按照$h$排序，那么$h_1$就是当前$1$号位置的水量。
假设我们使用的次数不受到任何限制，我们思考怎么样才是最优。
首先每次只**和一个合并一定比和多个合并更优**。
假设有三个位置$h_1\lt h_2\lt h_3$
那么如果直接合并，答案是$(h_1+h_2+h_3)/3$
如果每次合并一个，答案是$((h_1+h_2)/2+h_3)/2=(h_1+h_2)/4+h_3/2$
显然后者更优。
同理，通过后面那个式子，我们发现先和$h_2$合并比先和$h_3$合并更优。
所以，在合并次数不受到限制的时候，我们显然是**从小往大，依次合并**。

当次数不够的时候，我们肯定不能只合并一个位置，显然合并所有位置还是更优的。
那么，既然不能够一个个合并，所以只能够把若干次合并放在一起做。
因为每次和后面的若干个做完合并之后，这些一起合并的位置就可以直接丢掉了，
再因为从小往大合并更优，假设$h_i$已经有序，那么每次一定是和一段合并。
所以设$f[i][j]$表示前面$i$个位置合并了$j$次的最优值。
那么考虑转移$f[i][j]=max((f[k][j-1]+\sum_{x\in[k+1,i]}h_x)/(i-k+1)$
这样的复杂度$O(n^2k)$，$k$是可以合并的次数。
把式子重写，$\sum$写成前缀和的形式，暂时忽略后面的枚举次数
$f[i]=(f[k]+s[i]-s[k])/(i-k+1)$
这个式子很像斜率：
$(s[i]-(s[k]-f[k]))/(i-(k-1))$
相当于把前面所有已知状态看成一个点$(k-1,s[k]-f[k])$
那么找到当前点$(i,s[i])$到这个点的斜率，使其斜率最大，可以**斜率优化解决**。
这样可以在**凸包上三分计算**，时间复杂度$O(nklog_3n)$
因为给定的高精小数库还有一个$O(p)$的复杂度，所以整个的复杂度是$O(nkplogn)$
同时还发现具有**决策单调性**，所以可以做到$O(nkp)$
决策单调性的证明大概是这样的，假设当位置是$(i,s[i])$
最优转移是$(x1,y1)$，存在一个不优的转移$(x2,y2)$，
根据题目条件，有$i>x1>x2,s[i]>y1>y2,s[i]>i,y1>x1,y2>x2$
一下个位置至少是$(i+1,s[i]+i)$，然后把斜率的式子写一写发现$(x1,y1)$仍然更优。

现在可以做到$O(nkp)$，但是这样的复杂度远远不够。
继续挖掘性质。
发现有一个条件我们还没有怎么使用，即所有$h_i$互不相等。
那么我们可以得到一个条件：**每次转移的区间长度不会大于上一次转移的区间长度。**
感性的证明就是越往后走高度越大，显然拿更少的位置来平分会更优。
或者可以假设一下区间的长度，然后计算一下结果就好了。
或者假如后面那个区间长度大于前面这个区间，那么把后面那个区间的最前面那个位置分给前面这一段一定更优。
还有一个奇怪的条件：**长度大于$1$的区间个数不会超过$O(log\frac{nh}{\Delta})$，其中$\Delta=min(h_i-h_{i-1})$**
证明？~~我不会我不会~~，[可以参考这里的证明](https://wenku.baidu.com/view/7842de6784868762cbaed52e.html?pn=51)

那么这样子，只需要$dp$大概$14$层就好啦。（参考征途或者序列分割之类的题目）

[完整的代码戳这里](https://paste.ubuntu.com/p/WTfX3d3Qb3/)

以下是阉割版本。~~毕竟放个700行的代码翻都翻不完~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int MAX=8080;
Decimal ans;
int n,K,p,h[MAX],zy[MAX][15],s[MAX],tot;
int Q[MAX],H,T;
double f[MAX][15];
struct Node{double x,y;}q[MAX];
double Slope(Node a,Node b){return (a.y-b.y)/(a.x-b.x);}
Decimal Calc(int i,int j)
{
	if(!j)return h[1];
	return (Calc(zy[i][j],j-1)+s[i]-s[zy[i][j]])/(i-zy[i][j]+1);
}
int main()
{
	n=read();K=read();p=read();h[tot=1]=read();
	for(int i=2;i<=n;++i)
	{
		h[i]=read();
		if(h[i]>h[1])h[++tot]=h[i];
	}
	n=tot;sort(&h[1],&h[n+1]);
	for(int i=1;i<=n;++i)s[i]=s[i-1]+h[i];
	K=min(K,n);
	for(int i=1;i<=n;++i)f[i][0]=h[1];
	int lim=min(K,14);
	for(int j=1;j<=lim;++j)
	{
		Q[H=T=1]=1;
		for(int i=1;i<=n;++i)q[i]=(Node){i-1,s[i]-f[i][j-1]};
		for(int i=2;i<=n;++i)
		{
			Node u=(Node){i,s[i]};
			while(H<T&&Slope(u,q[Q[H]])<Slope(u,q[Q[H+1]]))++H;
			zy[i][j]=Q[H];f[i][j]=(s[i]-s[Q[H]]+f[Q[H]][j-1])/(i-Q[H]+1);
			while(H<T&&Slope(q[Q[T]],q[Q[T-1]])>Slope(q[Q[T]],q[i]))--T;
			Q[++T]=i;
		}
	}
	int m=n-K+lim,pos;double mx=0;
	for(int j=0;j<=lim;++j)
		if(f[m][j]>mx)mx=f[m][j],pos=j;
	ans=Calc(m,pos);
	for(int i=m+1;i<=n;++i)ans=(ans+h[i])/2;
	cout<<ans.to_string(p<<1)<<endl;
	return 0;
}
```

---

## 作者：wind_seeker (赞：25)

蒟蒻的第一篇黑题题解，求过。 

[题目链接](https://www.luogu.com.cn/problem/P1721)

## 题意描述
这道题用简洁的话来说，就是：  

给你 $n$ 个数字，你可以让取其中任意若干个数字，每次操作，都会使所有取的数字变为取的数字的平均数，并且你最多只能进行 $k$ 次操作，你要在这经过最多 $k$ 次操作后使得给你的第一个数字变得最大。输出保留 $p$ 位的第一个数字的最后状态。


------------


## 贪心策略（非正解，有助后面做题）
我们暂且不研究这道题的正解是什么，我们先看看怎么样贪心能够使得第一个数字变得最大。

- 首先，比第一个数字小的我们一定不需要，它们会使第一个数字变得更低。

- 第二，我们需要知道求平均数的顺序，我们设三个水量，$h1,h2,h3(h1 <h2<h3)$。现在我们通过比较不同的顺序，看如何让 $h1$ 变得最大。

![](https://cdn.luogu.com.cn/upload/image_hosting/7um8vcns.png)

如图所示，已经是所有的顺序了：

-  $h1,h2,h3$ 同时求平均数。
![](https://cdn.luogu.com.cn/upload/image_hosting/vkkkelg5.png)
-  $h1$ 先和 $h3$ 求平均数，然后和 $h2$ 求平均数。
![](https://cdn.luogu.com.cn/upload/image_hosting/s0mzuu70.png)
-  $h1$ 先和 $h2$ 求平均数，然后和 $h3$ 求平均数。
![](https://cdn.luogu.com.cn/upload/image_hosting/5lu2iy1y.png)

~~其实从图中就可以看出来，第三种方案最优。~~  


------------

我们再用数学的方法来比较这三个方案的优劣性。

- 第一种方案：$h1=(h1+h2+h3)/3$。

- 第二种方案：$h1=((h1+h3)/2+h2)/2=(h1+h3)/4+h2/2$。

- 第三种方案：$h1=((h1+h2)/2+h3)/2=(h1+h2)/4+h3/2$。

我们通过相减比较 $h1$ 最后的大小：

- 第一种方案减去第三种方案：  
$$(h1+h2+h3)/3-(h1+h2)/4-h3/2$$
$$\Longrightarrow (h1+h2)/3-(h1+h2)/4+h3/3-h3/2$$
$$\Longrightarrow (4 \times h1+4 \times h2-3 \times h1-3 \times h2+4 \times h3-6 \times h3)/12$$
$$\Longrightarrow (h1+h2-2 \times h3)/12$$
$$\Longrightarrow ans<0$$  

**第三种方案晋级。**

- 第二种方案减去第三种方案： 
$$(h1+h3)/4+h2/2-(h1+h2)/4-h3/2$$
$$\Longrightarrow h1/4-h1/4+h2/2-h2/4+h3/4-h3/2$$
$$\Longrightarrow (h2-h3)/2-(h2-h3)/4$$
$$\Longrightarrow ans<0$$

**第三种方案胜出。**


------------


### 总结策略

- **只考虑比第一个数大的数。**

- **在一般情况下，一个一个操作(可能会超过 $k$ 次，所以是在一般情况下)。** 

- **在一个一个操作时,从小到大操作。** 


------------

## 斜率优化dp(正解)

由于可进行的操作次数是一定的，所以我们最后要解决的就是该在那一段区间进行操作。

首先将大于第一个数的数记录下来，排序并求出前缀和。

然后设计dp转移方程：

 $sum_i$ 为前 $i$ 个数的前缀和(操作是赋值为平均数，并不会改变总数值，所以  $sum_i$ 一直适用)。  
 $f_{i,j}$ 表示前面 $i$ 个数操作了 $j$ 次时第一个数的最大值。  
 
得转移方程： 
$$f_{i,j}=\max((f_{p,j-1}+sum_i-sum_{p-1})/(i-p+1))$$


------------

### code
```cpp
for(int j=1;j<=k;j++)
	for(int i=1;i<=n;i++)
		for(int p=1;p<i;p++)
			f[i][j]=max(f[i][j],(f[p][j-1]+sum[i]-sum[p-1])/(i-p+1));
```


------------

但是这样的话，转移的时间复杂度为 $O(n^2kp)$，( $n$ 是数字个数，$k$  是操作次数，$p$ 为保留的精度）。  
所以光是dp是不行的,我们要考虑优化dp。


------------

我们观察这个状态转移方程：
$$(f_{p,j-1}+sum_i-sum_{p-1})/(i-p+1)$$
$$\Longrightarrow (sum_i-(sum_{p-1}+f_{p,j-1}))/(i-(p-1))$$  
由于 $i$ 和 $j$ 是循环中给出的，所以我们将 $i$ 和 $j$ 提出：
$$\Longrightarrow (sum_{p-1}-f_p)/(p-1)$$
经过前后对比，我们发现，设当前点为 $(i,sum_i)$，转移点为 $(p-1,sum_{p-1}-f_p)$，其实就是斜率公式。
用斜率优化dp，还有很重要的条件是要有单调性。如图，这道题目的单调性也十分的明显，由于 $1\le h_i \le 10^5$，也就意味着前缀和是单调上升的。


------------

![](https://cdn.luogu.com.cn/upload/image_hosting/v6z06njn.png)
图画的不好，谅解。
那么我们要维护的就是图中的这一个凸包。 

接下来我们考虑弹出队列的数会不会对后面的操作有影响：  
![](https://cdn.luogu.com.cn/upload/image_hosting/q8u8gjtw.png)


设当前位置为 $i$，对于 $i$，我们设 $k_2$ 优于 $k_1$，在这个情况下，我们可以得出：
$$(f_{k_1,j-1}+sum_i-sum_{k_1-1})/(i-k_1+1)<(f_{k_2,j-1}+sum_i-sum_{k_2-1})/(i-k_2+1)$$  
如果将 $i+1$ 带入,结果为：
$$(f_{k_1,j-1}+sum_{i+1}-sum_{k_1-1})/(i+1-k_1+1)<(f_{k_2,j-1}+sum_{i+1}-sum_{k_2-1})/(i+1-k_2+1)$$    
比较两个式子，我们会发现，在 $i+1$ 的情况下，如同 $i$ 的情况相同， 原本优于 $k_1$ 的 $k_2$ 依然会比 $k_2$ 更优，所以弹掉 $k_1$ 并不会影响后面的操作。


------------

### code
```cpp
for(int j=1;j<=k;j++)
{
	int head=tail=1;
	q[tail]=(node){1,sum[1]};
	for(int i=2;i<=n;i++)
	{
		node x=(node){i,sum[i]};
		while(head<tail&&slope(x,q[head])<slope(x,q[head+1]))head++;
		f[i][j]=(f[q[head]][j-1]+sum[i]-sum[q[head]-1])/(i-q[head]+1);
		while(head<tail&&slope(q[tail],q[tail-1])>slope(q[tail],i)) tail--;
		q[++tail]=i;
	}
}
```

---

此时我们已经将时间复杂度调小至 $O(nkp)$。  
$n\le 8000\ \ k\le10^9\ \ p\le 3000$。  
显然，我们还是不能过这道题目。  
于是我们再次重审题目，看一下还有什么条件我们并没有用到。  
想了很久，但并没有想到，于是我参考了[巨佬ljh2000的博客](https://www.cnblogs.com/ljh2000-jump/p/6376109.html)，终于发现了：**$h_i$ 互不相同。**   
但是我依旧没有找到它的作用，于是我又一次参考了[巨佬ljh2000的博客](https://www.cnblogs.com/ljh2000-jump/p/6376109.html)，里面有两条十分重要的性质：

- **每一次操作的区间长度一定不比上一次操作的区间长度长。**  

- **在所有水量高度互不相同的情况下，长度大于 $1$ 的区间仅有 $O(\log{ \frac{nh}{H}})$ 个，其中 $H=\min(h_i-h_{i-1})$。**

首先我们证明第一个，十分简单。我们的目标是将 $h_1$ 变得最大，而我们在一开始的时候对 $h_i$ 进行了排序，所以越往后面, $h_i$ 越大，越大的饼自然越要少与人分享，所以我们就会得出第一个结论。

至于第二个结论，我们只好根据众多大佬的指引，来到[这里](https://wenku.baidu.com/view/7842de6784868762cbaed52e.html)，深造一番。

~~很好，没有任何的作用。~~ 看来只能等待某位大佬的指点，或者等本蒟蒻再深造几年再回答这个问题吧。

**蒟蒻拙见，大佬勿喷。**


---

## 作者：Soulist (赞：24)

~~**如何不写斜优/决策单调性，用暴力通过此题。。（大雾）**~~

首先我们只需要考虑 $h_i>h_1$ 的点。

然后考虑 $K$ 足够大的点，我们手玩一段时间，发现将这些剩余点保留下来并排序，最优决策一定是将他们依次和 $1$ 联通。

比如样例中的 $1,3,4$，假设可以操作 $2$ 次及以上，那么最优决策一定是依次连接 $1,3$ 得到 $2$，然后连接 $2,4$ 得到 $3$

对于 $K$ 并非足够大的点，先将剩余点从小到大排序，不难发现每次的连通操作必然是将 $1$ 和一段区间 $[l,r]$ 联通，同时不存在一个点被连两次（显然不优）

感性上理解大概可以通过调整法，知道这个性质之后我们可以写一个 Dp 了：（方便起见，下文的 $h$ 数组是仅保留大于 $h_1$ 的元素且已经排好序，下标从 $2$ 开始的数组，而 $S$ 为其前缀和）

设 $f_{i,j}$ 表示考虑到 $[2,i]$，操作了 $j$ 次的最优解，那么转移形如 $f_{i,j}=(f_{k,j-1}+S_i-S_k)/(i-k+1)$

然而要进行高精度小数运算，我们得到了一个 $\mathcal O(n^2Kp)$ 的做法，非常幸运的是他可以过 $n\le 100$ 的测试点。

然后我们将最优决策打个表，会发现大概是这样的例子（以样例 $3$ 为例）

```
[100, 100]
[99, 99]
[98, 98]
...
[65, 66]
[62, 64]
[50, 61]
```

然后发现好像长度不是 $1$ 的区间非常少？而且决策应该是从某个位置开始的后缀，都会被选中。

我们大胆猜测长度不为 $1$ 的区间只有 $\log$ 个（实际上是调参之后知道的），于是 Dp 的第二个维度可以降低成 $\log$，便得到了一个 $\mathcal O(n^2\log np)$ 的做法。（大概是预处理 Dp 数组，然后枚举之前用了多少次，然后剩余部分一直除以 $2$）


然后造一点随机数据，继续打表，然后发现最大的区间的长度也很小？

于是转移的时候 $k$ 的枚举量不需要到 $[1,i]$，只需要到 $[i-c,i]$ 即可，$c$ 为一个常数。

于是得到了一个 $\mathcal O(n\log n\times c\cdot p)$ 的做法。

然后我们发现，之所以需要高精度小数，是因为我们经常除以 $x$，而且除以次数高达 $K$ 次，然而如果只考虑预处理部分的 $O(n\log n\times c)$ 的 Dp，我们发现我们只会除以 $\log$ 次，换而言之没有必要用高精度小数。。。

于是这个部分用 long double 把答案存下来来比较（当然误差很大但是不影响），然后我们将决策点记录下来，最后还原答案的时候通过高精度实现即可。

最终复杂度是 $\mathcal O(n\log n\times p+n\log n\times c)$，跑得非常快，我的 $c$ 设的是 $100$，是可以通过的。

$Code:$

```cpp

const int N = 8000 + 5 ; 
int Sum[N], n, p, K, H[N], st[N], top ; 
Decimal h[N], ans ; 
void solve1() {
	ans = H[1] ; Decimal iv = 2.0 ; 
	rep( i, 1, top ) h[i] = st[i] ;
	rep( i, 1, top ) ans = ( ans + h[i] ), ans /= 2 ; 
	cout << ans.to_string((int)(p * 6)/5) << endl ;  
}
long double Dp[N][20] ; int zy[N][20] ; 
Decimal Take( int x, int y ) {
	if(!y) return H[1] ; 
	int u = zy[x][y], s = Sum[x] - Sum[u], fm = x - u + 1 ; 
	return ( s + Take(zy[x][y], y - 1) ) / fm ; 
}
void solve3() {
	rep( i, 1, top ) h[i] = st[i], Sum[i] = Sum[i - 1] + st[i] ; 
	Dp[0][0] = H[1] ;
	int mimi = 15 ; 
	for( re int i = 1; i <= min( top, top - K + 50 ); ++ i ) {
		for( re int j = 0; j <= min( i, mimi ); ++ j ) {
			Dp[i][j] = Dp[i - 1][j] ; 
			for( re int k = max(i - 200, 0); k < i; ++ k ) {
				long double S = Sum[i] - Sum[k] ; int fm = i - k + 1 ; 
				if(j) {
					long double s = (Dp[k][j - 1] + S) / fm ;
					if( s > Dp[i][j] ) Dp[i][j] = s, zy[i][j] = k ;
				}
			}
		}
	}
	int ta = 0 ; 
	for( re int j = 0; j <= min(top, mimi); ++ j ) {
		Decimal S = Take( top - K + j, j ) ; 
		int be = top - K + j + 1 ; 
		for( re int i = be; i <= top; ++ i ) S = (S + h[i]) / 2 ;
		if( S > ans ) ans = S, ta = j ; 
	}
	cout << ans.to_string((int)(p * 6)/5) << endl ;  
}
signed main() {
	n = gi(), K = gi(), p = gi() ; 
	rep( i, 1, n ) H[i] = gi() ;
	rep( i, 1, n ) if( H[i] > H[1] ) st[++ top] = H[i] ; 
	sort( st + 1, st + top + 1 ) ; 
	if( K >= top ) solve1() ; 
	else solve3() ; 
	return 0 ; 
}
```



---

## 作者：litble (赞：24)

[个人博客](https://blog.csdn.net/litble/article/details/89712096)

[mina酱的博客](https://www.mina.moe/archives/12219)

# 题目分析
**性质**：

1. 所有积水高度小于等于1号点的点可以直接丢掉。
    所以，将留下来的水的高度都改成其原本的高度-1号点高度，最后答案再加上1号点的高度。
2. 假如被要求进行两次合并，有两杯水$h _ 1<h _ 2$，则一定先合并低的，再合并高的。
   证明：先合并低的：$\frac{1}{2}(\frac{1}{2} h _ 1+ h _ 2)=\frac{1}{4} h _ 1+\frac{1}{2} h _ 2$，先合并高的：$\frac{1}{2} h _ 1 + \frac{1}{4} h _ 2$。
3. 若有一部分水合并了，一部分没有，那么被合并的水一定是最高的几杯。

将所有留下来的水从低到高排序，设$h _ i$表示第$i$杯水的高度，$s _ i$表示前$i$杯水的高度前缀和。

合并操作一定是堆在最后面的一段一段的区间，从前往后合并。

设$f(i,j)$表示前$j$杯水合并了$i$次。

$f(i,j)=max(\frac{f(i-1,k)+s _ j-s _ k}{j-k+1})$

观察这个式子，发现是点$(k-1,s _ k - f(i-1,k))$和点$(j, s _ j)$构成的直线的斜率。

用单调队列维护点$(k-1,s _ k - f(i-1,k))$构成的下凸壳。因为点$(j, s _ j)$的y坐标随x坐标递增，所以找最优决策时，将队首一段不会构成最优决策的点的弹出，队首就是最优决策。

# 代码
那个600多行的高精度小数类就直接删掉了……只要记得将开头的`const int PREC=`后面的数字改为3000以上即可。

将每一步的决策用short记录下来，然后用高精度小数类再算一次答案。

```cpp
using namespace std;
#define RI register int
typedef long double db;
typedef long long LL;
const int N=8005;
Decimal ans;
int orzyyb,n,K,P,kpos;db kans;
int h[N],qid[N];LL s[N];short las[N][N];db f[2][N];
struct point{db x,y;}que[N];
point operator - (point A,point B) {return (point){A.x-B.x,A.y-B.y};}
db operator * (point A,point B) {return A.x*B.y-B.x*A.y;}

Decimal getans(int x,int y) {
	if(x==0) return 0;
	return (getans(x-1,las[x][y])+s[y]-s[las[x][y]])/(y-las[x][y]+1);
}

int main() {
	scanf("%d%d%d",&orzyyb,&K,&P);
	scanf("%d",&h[0]);
	for(RI i=1;i<orzyyb;++i) {
		int x;scanf("%d",&x);
		if(x>h[0]) h[++n]=x-h[0];
	}
	sort(h+1,h+1+n);
	for(RI i=1;i<=n;++i) s[i]=s[i-1]+h[i];
	if(K>n) K=n;
	for(RI i=1,t=1;i<=K;++i,t^=1) {
		int he=1,ta=1;
		que[1]=(point){(db)i-2,(db)s[i-1]-f[t^1][i-1]},qid[1]=i-1;
		for(RI j=i;j<=n;++j) {
			point P=(point){(db)j,(db)s[j]};
			while(he<ta&&(P-que[he+1])*(P-que[he])<0) ++he;
			las[i][j]=qid[he],f[t][j]=(db)(P.y-que[he].y)/(db)(P.x-que[he].x);
			P=(point){(db)j-1,(db)s[j]-f[t^1][j]};
			while(he<ta&&(que[ta]-que[ta-1])*(P-que[ta-1])<0) --ta;
			++ta,que[ta]=P,qid[ta]=j;
		}
		if(f[t][n]>=kans) kans=f[t][n],kpos=i;
	}
	ans=getans(kpos,n)+h[0];
	cout<<ans.to_string(P<<1)<<endl;
	return 0;
}
```

---

## 作者：Schi2oid (赞：20)

# P1721 [NOI2016] 国王饮水记 题解

*2025/5/17 upd：修正了一些无关紧要的引理的叙述和证明。因为我回来读了一遍发现没读懂。

## 题意简述

给定 $n$ 个城市，第 $i$ 个城市收集到了高度为 $h_i$ 的水，要求通过使用 $k$ 次地下连通系统，每次使用可以使若干个城市的水箱相连通，然后使它们的水位变为它们的平均值。要求求出 $k$ 次操作后， $1$ 号城市水箱中的水位的最大值。

## 策略选择及最优性证明

**引理0**：我们一定不会对初始水位不高于 $1$ 号的水箱操作。

**证明**：显然。

下文中所有 $k$ 都为输入的 $k$ 与 $n$ 取 $\text{min}$ 后的结果。

**引理1.1**：每次操作一定是将 $1$ 与其他某些水箱连通。

**证明**：若某一次操作将某不含 $1$ 的水箱集合 $S$ 连通，用**调整法**证明其不优。我们取消这一次操作，在之后的操作中，设所选择的水箱集合为 $T$，若 $S\cap T\not =\varnothing$，设 $S\cap T=S’$，则将 $T$ 中在 $S'$ 内的水箱替换为 $S$ 中当前水位前 $|S'|$ 高的水箱，容易直观理解其不劣。换句话说就是，连通 $S$ 使得 $S$ 中原本高水位的水箱失去了优势，原本低水位的水箱本就可以避免使用，因此这样的操作是不优的。证毕。

**引理1.2**：操作与操作之间选择的除 $1$ 之外的水箱一定不会有重叠。

**证明**：操作过的水箱与 $1$ 水位相同，由**引理0**，可直接弃用，证毕。

**引理1.3**：每个除 $1$ 之外的水箱都被恰好选择一次。

**证明**：若某水箱没有被选择过，直接在最开始将该水箱合并进 $1$，此时可选水箱集合不变而初始水位升高，因此一定不劣，证毕。

**引理2**：对于初始水位高于 $1$ 号的所有水箱，我们应将它们按照初始水位从小到大排序，之后按照序号从小到大进行操作，每次操作选取一段连续的区间合并到 $1$，且全部 $k$ 次操作恰好将 $2\sim n$ 号水箱从小到大、不重不漏地覆盖。

**证明**：对于相邻两次操作，不妨设前一次操作选择的是 $k_1$ 个水箱，它们的值分别为 $a_1,a_2,…,a_{k_1}$；后一次操作选择的是 $k_2$ 个水箱，它们的值分别为 $b_1,b_2,…,b_{k_2}$。分别记上述两个集合为 $A$ 和 $B$。设操作前 $1$ 号水箱的水位为 $x$，经过这两次操作后，$1$ 号水箱的水位会变成：
$$
f_1=\frac{x+\sum_{i=1}^{k_1}a_i+(k_1+1)\sum_{i=1}^{k_2}b_i}{(k_1+1)(k_2+1)}
$$

不难发现，式中 $b_i$ 的权重为 $k_1+1$，$a_i$ 的权重为 $1$，而 $k_1+1>1$。设 $C=A\cup B$，将 $B$ 换为 $C$ 中前 $|B|$ 大的元素，$A$ 换为 $C$ 中后 $|A|$ 大的元素，由排序不等式，这样的调整一定不劣。证毕。

根据**引理2**，我们可以先将水箱按照初始水位高度从小到大排序，再进行dp，如下是一个显然的dp转移方程：
$$
dp_{i,j}=\max\{dp_{i-1,j},\frac{dp_{k,j-1}+sum_i-sum_k}{i-k+1}\}
$$
状态 $dp_{i,j}$ 代表前 $i$ 个水箱中已经操作过 $j$ 次后 $1$ 号水箱中的最高水位，$sum_p$ 代表前 $p$ 个水箱初始水位的前缀和。注意到转移可以压掉一维，忽略掉 $dp_{i-1,j}$ 一项（过程中直接继承即可），方程转化成：
$$
dp_{i}=\max\{\frac{dp_{k}+sum_i-sum_k}{i-k+1}\}
$$
至此，我们就找到了 $O(n^2k)$ 的初步算法。（关于为什么复杂度里面没有 $p$，我们可以在 $dp$ 时存一下是从哪个状态转移过来的，过程中不必使用高精类，最后时再进行一遍深搜统计最终答案就好了。）

## 算法优化

#### 基本尝试

然后应该做什么呢？

观察转移方程，经过初步尝试后，可以发现这个式子难以进行常规的斜率优化，甚至可以说是不可能，因为交叉相乘后出现了类似于 $k_2dp_{k_1}$ 的二次项。~~@OvO_Zuo ：不然你猜它为什么是黑的~~ 那么，我们就需要**另辟蹊径**。

#### 另类斜率优化

注意到转移方程中的式子其实本身就是一个斜率式子。设两个点 $(i,sum_i)$ 和 $(k-1,sum_k-dp_k)$。原式恰为第二个点关于第一个点的斜率。接下来，让我们分析这种特殊的斜率的性质。首先注意到原式一定是正的，即斜率一定是正的；另外，$i$ 一定比 $k-1$ 要大。同时，$i$ 和 $sum_i$ 都是单调递增的。

设三个决策点为 $k_1$，$k_2$，$k_3$，且它们大小递增，$k_1k_2$ 的斜率大于 $k_2k_3$ 的斜率。

![](https://s1.ax1x.com/2022/07/23/jXKuvt.png)

那么，考虑上图的情况，如果 $(i,sum_i)$ 位于如图所示绿色线以上的部分，有 $k_3$ 优于 $k_2$；而对于如图所示红色线以下的部分，有 $k_1$ 优于 $k_2$。因此，$k_2$ 在任意的情况下都不是最优点，可以直接舍去。对于其他非上图情况也都可以通过类似的分析发现，只要满足 $k_1k_2$ 的斜率大于 $k_2k_3$ 的斜率，那么 $k_2$ 在任意的情况下都不是最优点。

![image-20220722154911568](https://s1.ax1x.com/2022/07/23/jXKMKP.png)

而对于相反的情况，即 $k_1k_2$ 的斜率小于 $k_2k_3$ 的斜率，注意到红色部分和绿色部分的中间会有间隙，这意味着 $k_2$ 并不一定不是最优解，此时 $k_2$ 需要保留。

那么，哪个决策点是最优的呢？

![image-20220722164119240](https://s1.ax1x.com/2022/07/23/jXKQDf.png)

对于一个决策点而言，如果它右侧线段的延长线在 $i$ 之上，那么它会优于它右侧的下一个决策点；否则它右侧的下一个决策点优于它。考虑上图，我们找到第一个决策点使得它右侧的线段延长线在 $i$ 点之上，即其右侧线段斜率大于其与 $i$ 点连线的斜率，那么这个点就是最优决策点。如上图中的 $k_2$。这是因为 $k_2$ 比左侧所有点都要优，也比右侧所有点都要优。

至此，我们已经可以发现：这与**常规斜率优化**完全类似。维护一个下凸壳即可，二分进行决策选取，时间复杂度成功优化至 $O(n\log nk)$ 。

但是显然还是过不去。能否砍掉二分复杂度？

#### 终极优化

~~接下来是神的领域~~

**引理3**：对于决策点 $k_1,k_2$，如果满足 $k_1<k_2$ ，且 $k_1$ 在某一次的转移中较劣，在之后的转移中一定也都是较劣的。

**证明**：设在转移至 $i$ 的情况下，$k_2$ 比 $k_1$ 优。接下来，让我们来讨论转移至 $i+1$ 的情况。根据我们设出的条件，有以下结论：
$$
\frac{dp_{k_1}+sum_i-sum_{k_1} }{i-k_1+1}<\frac{dp_{k_2}+sum_i-sum_k}{i-k_2 +1}
$$
设左边为 $F$ ，右边为 $G$，条件相当于给出 $F<G$。考虑转移至 $i+1$ 的情况，即我们需要证明：
$$
\frac{FA+C }{A+1}<\frac{GB+C }{B+1}
$$
其中 $A=i-k_1+1,B=i-k_2+1,C=h_{i+1},A>B$。又因为操作顺序是从小到大，所以一定有 $C>G>F$ 。至此，只需证：
$$
(G-F)AB+C(A-B)+GB-FA>0
$$
注意到：
$$
C(A-B)+GB-FA>C(A-B)+F(B-A)=(C-F)(A-B)>0,(G-F)AB>0
$$
所以原式得证，证毕。

根据**引理3**，由于队首的元素都满足**引理3**，所以我们可以每次转移答案时将较劣的决策点从队首弹出，保证每一个决策点都最多入队出队各一次。至此，复杂度成功优化至 $O(nk)$，完结撒花。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define LD long double
int n;
LD h1,sum[8005],h[8005],dp[2][8005];
short from[8005][8005];//存是从哪里转移过来
bitset<8005>jump[8005];//表示转移到当前状态是否进行了一次操作
int cnt=0;
int q[10000005],l=25001,r=25000;//手写队列比较方便
bool check(int k,int kn,int o,int i){
	if(l==r) return true;
	LD x1=k-1,y1=sum[k]-dp[o][k],x2=kn-1,y2=sum[kn]-dp[o][kn],x3=i,y3=sum[i];
	return ((y2-y1)/(x2-x1))>((y3-y1)/(x3-x1));
}
Decimal dfs(int x,int k){
	Decimal ret=0;
	if(k==0) return (Decimal)(double)h1;
	if(jump[x][k]) return (dfs(from[x][k],k-1)+(Decimal)(double)(sum[x]-sum[from[x][k]]))/(x-from[x][k]+1);
	else return dfs(from[x][k],k);
}
int main(){
	int k,p;
	LD tmp;
	cin>>n>>k>>p;
	scanf("%Lf",&h1);
	for(int i=1;i<n;i++){
		scanf("%Lf",&tmp);
		if(tmp>h1) h[++cnt]=tmp;
	}
	n=cnt;
	k=min(k,n);
	sort(h+1,h+1+n);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+h[i];
	for(int i=0;i<=n;i++) dp[0][i]=h1;
	for(int j=1;j<=k;j++){
		l=r;
		q[l]=0;
		int dif=j&1,lst=1-dif;
		for(int i=1;i<=n;i++){
			while(l<r){
				if(check(q[l],q[l+1],lst,i)) break;
				else l++;
			}
			dp[dif][i]=max(dp[dif][i-1],(dp[lst][q[l]]+sum[i]-sum[q[l]])/(i-q[l]+1));
			if(dp[dif][i-1]>(dp[lst][q[l]]+sum[i]-sum[q[l]])/(i-q[l]+1)) from[i][j]=i-1,jump[i][j]=0;
			else from[i][j]=q[l],jump[i][j]=1;
			while(l<r){
				LD x1=q[r-1]-1,y1=sum[q[r-1]]-dp[lst][q[r-1]],x2=q[r]-1,y2=sum[q[r]]-dp[lst][q[r]],x3=i-1,y3=sum[i]-dp[lst][i];
				if(((y2-y1)/(x2-x1))>=((y3-y1)/(x3-x1))) r--;
				else break;
			}
			q[++r]=i;
		}
	}
	Decimal ans=dfs(n,k);
	cout << ans.to_string(p*6/5) << "\n";
	return 0;
} 
```

---

## 作者：ethan_zhou (赞：6)

[博客阅读效果更佳](https://blog-e.tk/2022/02/13/%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0/)

## 题意

有一个长度为 $n$ 的数组 $H$（元素互不相同），你可以进行 $m$ 次操作，每次取若干元素，把他们都赋值为他们的平均值。求 $H_1$ 最终最大能达到多少，要求计算过程中保留到小数点后 $p$ 位。

## 简单观察

贪心一下，大概就能感受出来最优解的搞法：

- 将 $H_{[2,n]}$ 排序，选一个后缀，并划分为 $m$ 个区间。
- 把 $H_1$ 从小到大依次和这些区间内的数联通。

**这个感觉是对的，但是严格证明需要以下结论：**

- 小于等于 $H_1$ 的数没用（显然）
- 假如每次操作都包含 $H_1$，每个数不会选两次（操作过之后就小于等于 $H_1$ 了）
- 存在一个最优方案，每次操作都包含 $H_1$

> **（借鉴 @lim 的证法）：**
>
> 考虑最优方案中，最后一次不包含 $H_1$ 的操作，不妨设操作的集合为 $S$，会发现：$S$ 中的数，之后最多会再被操作一次（之后的操作都包含 $H_1$，由上一个引理可得）。
>
> 可以发现，假如不进行这次操作，并把 $S$ 中之后还被操作过的数，从小到大排序之后，替换到上述方案中的位置里，可以得到不劣的答案。

- 相邻两次操作，所选的（除了 $H_1$ 之外的）数，值域不相交（如有相交，改成不相交更优）
- 相邻两次操作，先进行所选的（除了 $H_1$ 之外的）数，较小的操作。（否则交换更优）
- 将 $H_{[2,n]}$ 排序，每次操作都是一个区间（如果选的数不连续，可以把第一个数到最后一个数中间所有数都选了（由上上个引理，这些数不可能被别的操作用过），不劣）
- $m\ge n$ 的情况与 $m=n-1$ 相同

## 暴力做法

把小于 $H_1$ 的东西扔掉，将 $H$ 从小到大排序，记 $sH$ 为 $H$ 的前缀和。

$dp(i,j)$ 表示搞完前 $i$ 次操作，并规定 $j$ 之前的东西都不能再操作了，此时 $H_1$ 的最大值。转移显然：

$$
dp(i,j)=\max_{k<j}(\frac{dp(i-1,k)+sH_j-sH_k}{j-k+1})
$$

复杂度 $O(n^3p)$，可得 65 分~~可以跑路了~~。

## 转移优化

仔细观察转移方程，感觉和一般的斜率优化不太一样，倒是有点 0/1 分数规划的感觉。因此，我们可以考虑二分一个 $x$，看看需要满足什么条件：

$$
\begin{aligned}
\max_{k<j}(\frac{dp(i-1,k)+sH_j-sH_k}{j-k+1})&\ge x\cr
\max_{k<j}(kx+dp(i-1,k) - sH_k) &\ge (j + 1)x - sH_j
\end{aligned}
$$

移项之后发现左侧是若干关于 $k$ 的一次函数取 max，也就是一个下凸的玩意，右侧是关于 $j$ 的一次函数。我们要找到一个最大的符合条件的 $x$，就是要找到右侧函数和左侧凸包的交点。
![凸包示意图](https://pic.imgdb.cn/item/620a1f7a2ab3f51d91aeb27f.jpg)
并且我们发现，这些一次函数虽然截距是小数，但是斜率是整数。因此我们可以轻松算出两个函数的交点，不需要高精度除高精度。

### 带 log 做法

于是现在我们可以用一个 `queue` 维护凸包（斜率是单调增的），然后每次查询，二分出凸包和直线的交点在凸包的哪一段上。复杂度 $O(n^2 p\log n)$，并没有太多分。

### 去掉 log

显然，$dp(i,j)>dp(i,j-1)$。也就是说，每一次转移，函数与凸包的交点都往右移动。所以我们只需要用一个 `deque` 维护凸包，在队尾加直线，在队首查询，如果交点超出队首直线的管辖范围，就 `pop_front`。

复杂度 $O(n^2p)$。

---

听说有一个瞎搞做法可以拿分：在前文的基础上，dp 过程只用 `double` 计算，记录转移点，然后最后用高精度还原答案，复杂度 $O(n(n+p))$，但是应该是可以卡的。

## 状态优化

根据讲题 ppt，还有个奇妙性质，就是长度不为 1 的区间只有 $O(\log nh)$ 个。因此，数组的第一维只用开到 $\log nh$，经过实测，开到 5 就能过，$O(np\log nh)$。

此时，因为 dp 中除法的次数很少，所以用前文的瞎搞做法也是正确的，复杂度 $O(n(\log nh+p))$。

但是我不会证这个性质，看[讲题 ppt](https://wenku.baidu.com/view/7842de6784868762cbaed52e.html)，总觉得出题人的证明也不太靠谱。比如这页的不等式放缩：

![有问题的证明](https://pic.imgdb.cn/item/620a2c172ab3f51d91bdf7de.jpg)

按我的理解，这个不等式应该放缩出来 $l\ge$ 什么东西的。

如果哪位知道这个咋证明，或者我理解错了，还请指出。

## 代码

$O(np\log nh)$ 做法，省略高精度库。

```cpp
#define fi first
#define se second
using namespace std;
using pd = pair<Decimal, int>;
const char nl = '\n';
const int MXN = 8005, LG = 5;
pd q[MXN];
int qr, ql;
int n, k, mnk, lim, p, tmp, h0, h[MXN];
Decimal dp[LG + 1][MXN];

Decimal intersec(pd &x, pd &y) { return (x.fi - y.fi) / (y.se - x.se); }
Decimal cal(pd &f, Decimal &x) { return f.fi + f.se * x; }

ostream &operator<<(ostream &x, const Decimal &y) { return x << y.to_string(p + 1); }

int main() {
    /* freopen("P1721.in", "r", stdin); */
    /* freopen("P1721.out", "w", stdout); */
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> k >> p >> h0;
    for (int i = 2, x; i <= n; i++) {
        cin >> x;
        if (x > h0) h[++tmp] = x;
    }

    k = min(k, n = tmp);
    mnk = min(k, LG);
    lim = n - k + mnk;

    sort(h + 1, h + 1 + n);
    partial_sum(h + 1, h + 1 + n, h + 1);
    fill(dp[0], dp[0] + 1 + n, h0);
    for (int i = 1; i <= mnk; i++) {
#define func(x) {dp[i - 1][x] - h[x], x}
        q[qr = ql = 1] = func(0);
        for (int j = 1; j <= n; j++) {
            pd quef = {-h[j], j + 1};
            while (qr > ql && intersec(q[ql], quef) <= intersec(q[ql + 1], quef)) ++ql;
            dp[i][j] = intersec(q[ql], quef);

            pd modf = func(j);
            while (qr > ql && intersec(q[qr - 1], modf) >= intersec(q[qr], modf)) --qr;
            q[++qr] = modf;
        }
    }
    Decimal res = dp[mnk][lim];
    for (int i = lim + 1; i <= n; i++) res = (res + h[i] - h[i - 1]) / 2;
    cout << res << nl;
    return 0;
}
```



---

## 作者：littlez_meow (赞：5)

### 题意

给定一个序列 $h_1\sim h_n$，你可以进行至多 $k$ 次操作，每次操作可以选择若干个数 $h_{i_1}\sim h_{i_t}$，对于所有 $j$ 执行 $h_{i_j}\leftarrow\dfrac{\sum\limits_{p=1}^t h_{i_p}}{t}$，即把所有选出的数赋值为选出数的平均值。求若干次操作后 $h_1$ 的最大值。和正确答案的绝对误差需小于 $10^{-p}$。

### 思路

称一次操作为“合成”。

首先可以观察出一下两条性质：

1. 所有小于等于 $h_1$ 的数都是无用的。

2. 分开合成比一起合成更优。

性质一显然。

对于性质二，假设现在 $h_1$ 要与 $a,b(h_1<a\le b)$ 合成。若先 $a$ 再 $b$，结果为 $0.25h_1+0.25a+0.5b$；若先 $b$ 再 $a$，结果为 $0.25h_1+0.25b+0.5a$；若 $a,b$ 一起，结果为 $\dfrac 1 3(h_1+a+b)$。前两者利用排序不等式显然第一种更优。第三种和第一种作差得到 $\dfrac 1{12}(h_1+a)-\dfrac 1 6b<\dfrac 1{12}(a+a)-\dfrac 1 6a=0$，因此还是第一种更优。对于合成更多数的情况同理。得证。

立即得到两个推论：

1. 每个数最多只会被合成一次。

2. 从小往大合成更优。

推论一是因为一个数合成一次之后就会等于 $h_1$ 就无用了。

推论二可以通过性质二的证明得到。

但我们还是得不出合成的策略。还需要继续观察，得到性质三：

3. 必然存在一种策略，每一次合成均包含 $h_1$。

参见性质二的证明，我们可以得到，如果参与某两次和 $h_1$ 合成的数和一定，差越大，结果越不劣。如果有一次不包含 $h_1$ 的操作，它会使得这些数和不变，但是差值更小了。这是不优的。

根据推论二，我们在 $k\ge n$ 的情况下，可以让 $h_1$ 从小到大依次合成得到最优解。下文 $k\leftarrow\min\{n,k\}$。

现在，我们就可以得出策略了：先去除不比 $h_1$ 大的数，将 $h_2\sim h_n$ 排序，每次将 $h_1$ 和一段区间合成。下面的 $h$ 为排序后的。

典型的序列分段型 dp。

设 $dp(i,j)$ 表示在第 $i$ 个分一段，一共分了 $j$ 段的 $h_1$ 最大值。边界 $dp(1,0)=0$，其它为正无穷。设 $s_i=\sum\limits_{j=2}^i h_i$ 转移如下：

$$dp(i,j)=\max\limits_{t=1}^{i-1}\{\dfrac{dp(t,j-1)+s_i-s_t}{i-t+1}\}$$

这个式子很像斜率。但能不能用一般的斜率优化呢？

不行。一般的斜率优化是 $(i,f(i))$ 和 $(j,f(j))$ 之间的斜率，一般这个 $f$ 里面还带有 $dp$。但是，这里的斜率是 $(i,s_i)$ 和 $(t-1,s_t-dp(t,j-1))$ 之间的，$f$ 不相同。

不过，我们发现对于点 $(i,s_i)$，我们的最佳决策肯定是 $(t-1,s_t-dp(t,j-1))$ 中斜率最大的点，而这个点必然在下凸壳上。显然，这是单峰的，可以凸包上二分实现。

这个复杂度是 $O(n^2p\log n)$ 的，即便不带那个 $p$ 也跑不过去。

如果可以去掉二分就好了。

发现每个询问的点是越来越往右上走的（横坐标加 $1$，纵坐标加横坐标），且凸包的最下面的点也在往右移。感性理解，斜率的函数的峰也在右移，也就是具有决策单调性。

然后用单调队列维护凸包，每次弹出非最优解的点。

现在的时间复杂度是 $O(n^2p)$。

题解的其他方法我不会证。给出一个人类智慧的解决方式。

题目中有 $10^{-5}$ 的部分分，这说明用 `double` 存精度是够的（虽然可能会被卡）。用 `double` 求最佳决策点，再用高精度小数转移就可以了。

当然，`double` 的精度可能还是有点问题，所有原本写小于的地方都要改成小于等于（毕竟不劣）。

时间复杂度 $O(np+n^2)$。

为了方便滚动数组，代码中交换了 $dp(i,j)$ 的两维。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
using namespace std;
namespace LongLongDouble{
} 
const int MAXN=8001;
int n,k,p,h[MAXN],s[MAXN];
double dp[2][MAXN];
short trans[MAXN][MAXN];
struct Vec{
	double x,y;
	Vec(const double&a=0,const double&b=0):x(a),y(b){}
	Vec operator+(const Vec&qwq)const{
		return Vec(x+qwq.x,y+qwq.y); 
	}
	Vec operator-(const Vec&qwq)const{
		return Vec(x-qwq.x,y-qwq.y); 
	}
	double operator*(const Vec&qwq)const{
		return x*qwq.y-y*qwq.x;
	}
	bool operator<(const Vec&qwq)const{
		return x<qwq.x;
	}
};
inline double slope(Vec x,Vec y){
	return (x.y-y.y)/(x.x-y.x);
}
double mx=0;
int mxk;
using namespace LongLongDouble;
inline Decimal getans(int kk,int nn){
	if(kk==0) return h[1];
	int pos=trans[kk][nn];
	return (pos==-1?getans(kk,nn-1):(getans(kk-1,pos)+s[nn]-s[pos])/(nn-pos+1));
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k>>p;
	F(i,1,n) cin>>h[i];
	sort(h+2,h+n+1,greater<int>());
	while(h[n]<=h[1]) --n;
	k=min(n-1,k);
	sort(h+2,h+n+1);
	F(i,1,n) dp[0][i]=h[1],s[i]=s[i-1]+h[i];
	F(i,1,k){
		int now(i&1),lst(now^1);
		deque<Vec>q;
		q.push_back({i-1,s[i]-dp[lst][i]});
		F(j,i+1,n){
			Vec qwq(j,s[j]);
			while(q.size()>1&&slope(q[0],qwq)<slope(q[1],qwq)) q.pop_front();
			if(dp[now][j-1]<slope(q[0],qwq)) dp[now][j]=slope(q[0],qwq),trans[i][j]=q[0].x+1;
			else dp[now][j]=dp[now][j-1],trans[i][j]=-1;
			qwq={j-1.0,s[j]-dp[lst][j]};
			while(q.size()>1&&(q.back()-q[q.size()-2])*(qwq-q[q.size()-2])<=0) q.pop_back();
			q.push_back(qwq);
		}
		mx<=dp[now][n]&&(mx=dp[now][n],mxk=i);
	}
	cout<<getans(mxk,n).to_string(min(p*2,3900));
	return 0;
}
```

完结撒花 qwq~

---

## 作者：Unnamed114514 (赞：5)

Substack 是按照我自己的思路来的，原题并没有，所以数据范围在下面标注了。

### Substak 1

$$k=10^9$$

显然对于 $h_t<\le h_1$， $t$ 是无用的。所以先整理一下序列，令 $tot$ 为现在的总长。

我们假设现在有 $3$ 个高度 $h_1,h_2,h_3$，不妨令 $h_1<h_2<h_3$。对于 $2$ 次的情况，有如下几种选择：

1. $1$ 先与 $2$ 求平均，再与 $3$ 求平均：

$$h_1\gets \dfrac{\frac{h_1+h_2}{2}+h_3}{2}=\dfrac{h_1}{4}+\dfrac{h_2}{4}+\dfrac{h_3}{2}$$

2. $1$ 直接与 $2,3$ 一起求平均，剩下一次摆烂：

$$h_1\gets \dfrac{h_1+h_2+h_3}{3}=\dfrac{h_1}{3}+\dfrac{h_2}{3}+\dfrac{h_3}{3}$$

3. $3$ 与 $2$ 求平均，$1$ 再与平均求平均：

$$h_1\gets\dfrac{h_1+\frac{h_2+h_3}{2}}{2}=\dfrac{h_1}{2}+\dfrac{h_2}{4}+\dfrac{h_3}{4}$$

4. $1$ 与 $3$ 求平均，再与 $2$ 求平均

$$h_1\gets\dfrac{\frac{h_1+h_3}{2}+h_2}{2}=\dfrac{h_1}{4}+\dfrac{h_2}{2}+\dfrac{h_3}{4}$$

使用作差与放缩，可以发现方案 $1$ 是最优的。同时，使用数学归纳法可以得到：

**引理 $1$：在次数允许时，从小到大一个一个合并是最优的。**

容易发现：在 $k=10^9$ 的数据点中，$k\ge tot$ 是显然的。

时间复杂度 $O(np)$，期望得分 $10+$，实际得分 $36$。

### Substack 2

$n\le 100,k\le 10$

引理 $1$ 启发我们对 $h$ 进行排序，由于平均值要求和，所以想到前缀和。

如果直接暴力枚举决策区间，那么时间复杂度是 $O(n\times n^n)$ 的，显然不行。由引理 $1$，从小到大合并更优，同时每次操作都得和 $h_1$ 求平均。同时考虑到如果两个决策区间中间还有元素，那么我们可以将左边的区间右移，那么，长度不变，总和变大，肯定更优，所以决策区间是连续的。于是，我们想到一个 $O(n^2k)$ 的 dp：

令 $dp_{i,j}$ 表示已经合并到了第 $i$ 个，并且合并了 $j$ 次的最大高度，那么我们可以枚举上一次的决策点 $p$，有：

$$dp_{i,j}=\max\limits_{p=1}^{i-1}\dfrac{dp_{p,j}+s_i-s_p}{i-p+1}$$

由于此时有 $k\le n$，那么则时间复杂度约为 $O(n^3)$。为什么不带 $p$？因为我们转移只需要知道大小关系，所以可以直接 `long double` 存储，然后记录一下决策点，最后输出即可。

期望得分 $45+$，实际得分 $85$。

### Substack 3

$$n\le 8000,k\le 10^9$$

首先，在允许范围内随机造几组数据，可以发现，大部分决策区间长度都为 $1$。

于是，我们大胆猜测，长度不为 $1$ 的决策区间比较少。通过 [bdfs](https://max.book118.com/html/2019/1011/8075031075002054.shtm) 得到实际上长度不为 $1$ 的区间只有 $O(\dfrac{nh}{\Delta})$ 个。其中 $\Delta=\min\{h_i-h_{i-1}\}$，此时，$\Delta$ 是可以取 $1$ 的。我们可以转换一下状态的定义，记录 $dp_{i,j}$ 的时候只考虑长度不为 $1$ 的区间。有因为，如果前面的决策区间长度比后面的决策区间短，那么后面的决策点移到前面去显然更优，所以我们发现，长度为 $1$ 的区间都在最后，可以在 $dp$ 处理完之后处理。

由于 $\Delta$ 最小取到 $1$，那么一共就是 $O(\log nh)$ 次操作，最后总共的时间复杂度就是 $O(n^2\log nh)$，算出来大概在 $9.6\times 10^8$ 左右，凭借洛谷的评测机和 2s 的时限轻松跑过，根本没必要优化。 

高精度小数类给它省了，记得改 `PREC`。

[完整代码看这里](https://www.luogu.com.cn/record/99683213)

```cpp
#include<bits/stdc++.h>
using namespace std;
long double f[8005][20]; 
int n,k,p,tot,s[8005],h[8005],pre[8005][20];
Decimal ask(int a,int b){
	if(!b)
		return h[1];
	int p=pre[a][b];
	if(p==-1)
		return ask(a-1,b);
	return (ask(p,b-1)+s[a]-s[p])/(a-p+1);
}
Decimal ans;
int main(){
	ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>k>>p;
	for(int i=1;i<=n;++i){
		cin>>h[i];
		if(h[i]>=h[1]) h[++tot]=h[i];
	}
	sort(h+1,h+tot+1);
	ans=h[1];
	if(tot<=k) for(int i=1;i<=tot;++i) ans=(ans+h[i])/2;
	else{
		for(int i=1;i<=tot;++i) s[i]=s[i-1]+h[i];
		for(int i=1;i<=tot;++i) f[i][0]=h[1];
		int up=min(k,15);
		for(int i=1;i<=tot;++i)
			for(int j=1;j<=min(i,up);++j){
				f[i][j]=f[i-1][j],pre[i][j]=-1;
				for(int p=1;p<i;++p){
					long double dp=(f[p][j-1]+s[i]-s[p])/(i-p+1);
					if(dp>f[i][j]) f[i][j]=dp,pre[i][j]=p;
				}
			}
		for(int i=0;i<=min(tot,up);++i){
			Decimal s=ask(tot-k+i,i);
			int bef=tot-k+i+1;
			for(int j=bef;j<=tot;++j) s=(s+h[j])/2;
			if(s>ans) ans=s;
		}
	}
	cout<<ans.to_string(p<<1)<<endl;
	return 0;
} 
```

---

## 作者：zhiyin123 (赞：3)

# P1721 [NOI2016] 国王饮水记 题解
## 简要题意
给定 $n$ 个数，从 $h_1$ 到 $h_n$，每次操作都可以选择其中任意个数，将它们变成平均值，求出 $k$ 次操作后，第一个数的最大值。
## 各种结论
容易发现，小于 $h_1$ 的 $h$ 都可以忽略，因为它们对结果没有贡献；并且，城市的编号也是无关紧要的，可以直接从小到大排序。

其次，如果一个城市已经和一号城市相连过了，那么它就可以被忽略了，因为它的高度已经不大于一号城市的了。所以，当 $k$ 大于 $n-1$ 时，我们可以直接认为 $k=n-1$。

之后，先连接高度更大的城市是不优的，模拟一下或者搜索就能发现，~~感觉证明也不难~~。

所以，我们就得出了一个策略，先将城市高度从小到大排序，每次从小到大选择一段连续的城市（容易发现，不连续的一段城市一定不优，因为可以舍弃更小的几个城市而使用中间更大的城市，这种做法一定更优），将其与一号城市连接。

## 暴力 dp
首先，我们不妨认为 $h$ 是从小到大有序的，一号城市仍处在原位；不妨再设前缀和数组 $S_i$，表示：
$$S_i=\sum_{i=1}^ih_i$$

之后，再用 $f_{k,i}$ 表示：假设将第 $i+1$ 到第 $n$ 号城市去除，经过 $k$ 次操作后，一号城市能达到的最大高度。

所以，我们可以枚举 $j$，表示**上一次**操作的**右端点**；再枚举一个 $l$，表示**这一次**操作的**左端点**，就有 dp 方程：
$$f_{k,i}=
\max_{1\leq j<l\leq i}\frac{f_{k-1,j}+S_{i}-S_{l-1}}{i-l+2}$$

这样，如果直接暴力计算，不考虑计算高精度小数的复杂度，复杂度是 $O(n^4)$。
## 稍加优化
容易发现，当 $k$ 不变，$i$ 变化时，$f_{k,i}$ 是单调递增的，所以当我们确定 $l$ 后，可以直接令 $j=l-1$，这样，原式可以简化为：
$$f_{k,i}=
\max_{1<l\leq i}\frac{f_{k-1,l-1}+S_{i}-S_{l-1}}{i-l+2}$$

观察这个式子，发现它和两点确定的直线斜率公式非常想，即：
$$k=\frac{y_2-y_1}{x_2-x_1}$$

所以，我们不妨将 dp 式再次变换：
$$f_{k,i}=
\max_{1<l\leq i}\frac{S_{i}-(S_{l-1}-f_{k-1,l-1})}{(i+2)-l}$$

这样，$f_{k,i}$ 就变成了点 $(i+2,S_i)$ 和点 $(l,S_{l-1}-f_{k-1,l-1})$ 确定的直线的斜率，我们就可以在转移的同时将点 $(l,S_{l-1}-f_{k-1,l-1})$ 插入到一个单调栈中，并维护下凸包，然后计算 dp 值时在单调栈内二分即可。

由此，不算高精度小数的复杂度，就是 $O(n^2\log n)$ 的，感觉很能通过，但是乘上 $p$ 后却有点吃不消。

## 处理高精度小数

考虑到题目中说 $h_i$ 互不相等，并且 $1\leq h_i\leq 10^5$，并且 $n$ 非常小，所以如果我们单纯的只想找到最优策略，根本不需要在 dp 时精确到小数点后 $p$ 位；实际上，直接使用 `double` 就没有太大的误差了。

所以，我们可以先找到最优策略，然后将它记录下来，最后用高精度计算答案，计算精确答案的时间复杂度为 $O(np)$，可以接受。

不过，令人遗憾的是，如果 dp 不滚动数组，那么空间复杂度就是 $O(n^2)$，而题目只给了 250MB，如果用 `int` 硬存 dp 转移方向，空间就不太够。

题解中还有其他做法，就是用 `short` 存 dp 转移方向，稍微卡一下空间，就可以过。但是这是有局限性的，因为这题本来开 250MB ，显然就是为了卡空间，说不定之后什么类似的题只开 50MB ，这种用 `short` 卡常的做法就不太管用了，不如优化一下空间复杂度。

不妨考虑求解精确答案的过程，首先，我们在 dp 时就要记录每个状态是从哪里转移过来的，dp 完成后，在进行一个类似“回溯”的过程，从 dp 的终点回溯到起点，并记录实际上选择的是哪些城市段，最后算答案。

考虑到直接从终点回溯到起点，需要耗费大量空间记录转移方向，不如将二维的 dp 数组按照 $k$ 分块，设块长为 $B$，那么我们只需要在 dp 时只将 $k \operatorname{mod}B= 1$ 的 dp 值记录下来，其他的都不记录，这样，每个块内的 dp 值只需要记录 $1$ 个，这样 dp 的空间复杂度就降到了 $O(B+\frac{n}{B})$。

再考虑回溯的时候怎么办。当我们回溯到 $k_1\operatorname{mod}B=1$ 的状态时，就无法直接继续回溯了，但可以从 $k$ 值为 $k_1-B$ 的地方重新 dp 过来，因为第 $k$ 层的 dp 只和 $k-1$ 层有关，而 $k_1-B$ 的 dp 值被记录了，所以可以这么做。之后，再回溯到 $k_1-1$ 层后，就可以直接释放之前回溯过的层的空间了。这样，回溯的空间复杂度也是 $O(B+\frac{n}{B})$。

这样，取 $B=\sqrt n$ 后，空间复杂度就降到了 $O(n\sqrt n)$，就能过掉本题了。

至于如何分配、释放空间，我的实现方式为——使用数组 `*f[k]` 记录 $k$ 层的 dp 值，当某一层需要分配或释放空间时，直接用 `new` 和 `delete`；不过，用 `std::vector` 也可以实现此功能。

最后，总时间复杂度为 $O(n^2\log n)$，空间复杂度为 $O(n\sqrt n)$（认为 $n,p,k$ 都同阶）。

## 后记
其他题解中有的用了一个结论：划分的长度大于一的城市段不会太多，只有 log 个。可是，这个结论据说不太好证，所以本题解的方法可能还是有些价值的。

## 代码
因为有 `Decimal` 库，非常长，所以我就删掉了 `Decimal` 库。实际上，我将它放在命名空间 `given::` 里面了。

```cpp
#include<cstdlib>
#include<cstring>
#include<string>
#include<iostream>
#include<iomanip>
#include<algorithm>
using namespace std;
template<typename Tp>
bool tomax(Tp& x,Tp y){//如果 y 比 x 大，则更新 x 为 y，并返回 true ,否则返回 false
    return x<y?(x=y,true):false;
}
template<typename Tp>
bool tomin(Tp& x,Tp y){//如果 y 比 x 小，则更新 x 为 y，并返回 true ,否则返回 false
    return x>y?(x=y,true):false;
}
namespace given{/*这里就是出题人给的 Decimal 库*/}
using given::Decimal;
constexpr int MAXN=8e3,MAXP=3e3;
int N=0,K=0,P=0;
struct ci_t{//城市类，分别记录城市的编号和高度
    int id,h;
    bool operator<(const ci_t& o)const{
        return h<o.h;
    }
}ci[MAXN+5];
int abeg=0;//记录一号城市排序后的位置
int S[MAXN+5]={};//记录排序后城市的前缀和
struct p_t{//点类
    double x,y;
    double slo(const p_t& o)const{//计算斜率
        return (y-o.y)/(x-o.x);
    }
};
struct no_t{int id; p_t p;}no[MAXN+5]; int ncnt=0;//单调栈
void ins(const no_t& v){//单调栈插入
    while(ncnt>1&&no[ncnt-1].p.slo(no[ncnt].p)
                    >=no[ncnt].p.slo(v.p))
            --ncnt;
    no[++ncnt]=v;
    return ;
}
no_t quer(const p_t& po){//单调栈查询
    int l=1,r=ncnt;
    while(l<r){
        int mid=(l+r)>>1;
        if(no[mid].p.slo(no[mid+1].p)>=no[mid].p.slo(po)) r=mid;
        else l=mid+1;
    }
    return no[l];
}
struct z_t{int id; double v;} *f[MAXN+5]={};//dp 数组，id 表示转移方向，v 表示 dp 值
void cre(int kl,int kr){//分配空间
    for(int k=kl;k<=kr;k++){
    //    cerr<<"create at "<<k<<endl;
        f[k]=new z_t[N+5];
    }
    return ;
}
void del(int kl,int kr){//释放空间
    for(int k=kl;k<=kr;k++){
        delete[] f[k];
        f[k]=nullptr;
    }
    return ;
}
void dp(int kl,int kr){
    for(int k=kl;k<=kr;k++){
        f[k][abeg]={abeg,f[k-1][abeg].v};
        ncnt=0;
        for(int i=abeg+1;i<=N;i++){
            ins({i,{i,S[i-1]-f[k-1][i-1].v}});
            p_t tp{i+2,S[i]};
            auto rec=quer(tp);
            f[k][i]={rec.id,rec.p.slo(tp)};
        }
    }
    return ;
}
int mem[MAXN+5]={};//记录实际选择的城市段左端点
void bac(int kl,int kr){
    for(int k=kr;k>=kl;k--){
        if(mem[k+1]==0) break;
        mem[k]=f[k][mem[k+1]-1].id;
    }
    return ;
}
Decimal ans;
void calc(){//计算精确答案
    ans=S[abeg];
    for(int k=1;k<=K;k++){
        if(mem[k]==0) continue;
        int l=mem[k],r=mem[k+1]-1;
        Decimal tmp(S[r]-S[l-1]);
        tmp+=ans;
        tmp/=r-l+2;
        ans=tmp;
     //   cerr<<"after "<<k<<"  ans: "<<ans.to_string(10)<<endl;
    }
    return ;
}
void input(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>N>>K>>P; tomin(K,N-1);
    for(int i=1;i<=N;i++){
        ci[i].id=i;
        cin>>ci[i].h;
    }
    sort(ci+1,ci+N+1);//按高度排序
    for(int i=1;i<=N;i++){//找到一号城市的位置
        if(ci[i].id==1){
            abeg=i;
            break;
        }
    }
    S[abeg]=ci[abeg].h;
    for(int i=abeg+1;i<=N;i++)//计算前缀和
        S[i]=S[i-1]+ci[i].h;
    return ;
}
struct fw_t{int l,r;}fw[MAXN+5]; int fcnt=0;//记录每个块的范围
int main(){
    input();
    constexpr int B=90;
    fw[++fcnt]={1,min(B,K)};
    while(1){
        if(fw[fcnt].r==K) break;
        ++fcnt;
        fw[fcnt]={fw[fcnt-1].r+1,min(fw[fcnt-1].r+B,K)};
    }
    cre(0,0);
    for(int i=abeg;i<=N;i++) f[0][i]={0,S[abeg]};
    for(int i=1;i<=fcnt;i++){// dp
        cre(fw[i].l,fw[i].r);
        dp(fw[i].l,fw[i].r);
        del(fw[i].l,fw[i].r-1);
    }
    mem[K+1]=N+1;
    for(int i=fcnt;i>=1;i--){// 回溯
        cre(fw[i].l,fw[i].r-1);
        dp(fw[i].l,fw[i].r-1);
        bac(fw[i].l,fw[i].r);
        del(fw[i].l,fw[i].r);
    }
    calc();
    cout<<ans.to_string(7*P/5)<<endl;
    return 0;
}
```

---

## 作者：永无岛 (赞：2)

## 前言
在本题[官方题解 PPT](https://wenku.baidu.com/view/7842de6784868762cbaed52e.html?_wkts_=1718549312599&bdQuery=NOI2016%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0) 中提出了定理 $10$（也就是不少题解在最后一步优化提到的“长度大于 $1$ 的段只有不超过 $O(\log \frac{nh}{\Delta})$”），PPT 中并没有给出详细的推导过程，目前全网也没有看到除了官方题解 PPT 和个人在 [mina](https://www.mina.moe/archives/13239) 上发的博客之外的证明。现在把个人的详细推导补充迁移到这里来。


注：下面的本人的证明只证明了大于 $1$ 的段数不超过 $O(\log \frac{nh}{\Delta})$，常数上较 PPT 略劣。

## 证明
$\Delta$ 的定义和官方题解相同。

假设我们的最优解有 $l$ 段长度大于 $1$，这些段的长度记为 $L_{i}$，每段水位的平均值记为 $a_i$，我们考虑每一个城市的水位的贡献，用这些贡献拼出最后的高度。
最优解的最终高度（称其为 $A$）：
$$
A=\frac{\frac{\frac{\frac{\frac{x+L_{1}a_{1}}{L_{1}+1}+L_{2}a_{2}}{L_{2}+1}...+L_{l}a_{l}}{L_{l}+1}+h_{1}}{2}+h_{2}}{2}....
$$
按照 PPT 所说替换之后的最终高度（称其为 $B$）：
$$
B=\frac{\frac{\frac{\frac{x+L_{2}a_{2}}{L_{2}+1}...+L_{l}a_{l}-a_{l+1}}{L_{l}}+a_{l+1}}{2}+h_{1}}{2}....
$$
根据我们的假设，$A>B$。因为显然对于后面若干个长度为一的操作区间，对于答案的贡献是一样的，所以我们要比较的实际上就是：
$$A=\frac{\frac{\frac{x+L_{1}a_{1}}{L_{1}+1}+L_{2}a_{2}}{L_{2}+1}...+L_{l}a_{l}}{L_{l}+1}
$$
和：
$$
B=\frac{\frac{\frac{x+L_{2}a_{2}}{L_{2}+1}...+L_{l}a_{l}-a_{l+1}}{L_{l}}+a_{l+1}}{2}
$$
写成和式的形式：
$$
A=\frac{x}{\Pi_{i=1}^{l}(L_{i}+1)}+\sum_{i=1}^{l}\frac{L_{i}a_{i}}{\Pi_{j=i}^{j<=l}{(L_{j}+1})}
$$
$$
B=(L_{1}+1)\frac{x}{\Pi_{i=1}^{l}(L_{i}+1)\frac{2L_{l}}{L_{l}+1}}+\sum_{i=1}^{l}\frac{L_{i}a_{i}}{\Pi_{j=i}^{j<=l}(L_{j}+1)\frac{2L_{l}}{L_{l}+1}}+a_{l+1}\frac{L_{l}-1}{2L_{l}}
$$

由 $A>B$ 得：(下面是移项并整理的结果)

$$
\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}\geq(\frac{(L_{l}+1)(L_{1}+1)}{2L_{l}}-1)\frac{x}{\Pi_{i=1}^{l}(L_{i}+1)}+\frac{1-L_{l}}{2L_{l}}\sum_{i=1}^{l}\frac{L_{i}a_{i}}{\Pi_{j=i}^{j<=l}{(L_{j}+1})}+a_{l+1}\frac{L_{l}-1}{2L_{l}}
$$
最前面一项不好处理，直接甩掉。（当然最前面一项大于 $0$，可以轻松地证明，这里不赘述）

$$
\begin{aligned}\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}&\geq\frac{1-L_{l}}{2L_{l}}\sum_{i=1}^{l}\frac{L_{i}a_{i}}{\Pi_{j=i}^{j<=l}{(L_{j}+1})}+a_{l+1}\frac{L_{l}-1}{2L_{l}}

\\
\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}&\geq\frac{L_{l}-1}{2L_{l}}(a_{l}-\sum_{i=1}^{l}\frac{L_{i}a_{i}}{\Pi_{j=i}^{j<=l}{(L_{j}+1})})
\end{aligned}
$$
把 $a_{l}$ 放缩成 $a_{l-1}+\Delta$，拿出 $a_{l-1}$ 这一项，整理化简:
$$
\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}\geq\frac{L_{l}-1}{2L_{l}}(\frac{1}{L_{l}+1}a_{l}-\sum_{i=1}^{l-1}\frac{L_{i}a_{i}}{\Pi_{j=i}^{j<=l}{(L_{j}+1})})+\frac{L_{l}-1}{2L_{l}}\Delta
$$
继续放缩，拿，一直拿完所有的，化简可得：
$$
\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}\geq\frac{L_{l}-1}{2L_{l}}(\frac{a_{1}}{\Pi_{i=1}^{l}{(L_{i}+1})})+\frac{L_{l}-1}{2L_{l}}\Delta
$$

甩掉第一项（影响不大）：
$$
\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}\geq\frac{L_{l}-1}{2L_{l}}\Delta
$$

从这个式子推到卡住 $l$ 的界的过程，注意 $\forall L_{i}\geq2$ 即可：

$$
\frac{L_{1}a_{1}}{3^{l}}\geq\frac{L_{1}a_{1}}{\Pi_{i=1}^{l}(L_{i}+1)}\geq\frac{L_{l}-1}{2L_{l}}\Delta\geq\frac{1}{4}\Delta   
$$

$$
\begin{aligned}
{3^{l}}&\leq\frac{4L_{1}a_{1}}{\Delta}   \\

l&\leq\log \frac{4L_{1}a_{1}}{\Delta}  
\end{aligned}
$$

这个和 PPT 里面只是一个 $\log_{3}4$ 的差距（约等于 $1.262$）。

---

## 作者：wangyibo201026 (赞：1)

## Solution

半结论半思维。

结论：

1. 初始水位小于 $h_1$ 的就是废物。

绝对是不优的，这是显然的。

2. 每次操作必然和 $h_1$ 有关

可以手完肯定是不优的。

比如说有 $h_i$ 和 $h_j$，考虑两种情况的贡献。

- $h_i$ 和 $h_j$ 操作，然后再和 $h_1$ 操作。

- $h_i$ 和 $h_1$ 操作，$h_j$ 和 $h_1$ 操作。

后 $1$ 的值对应为：

- $\frac{h_1 + \frac{h_i + h_j}{2}}{2}$ = $\frac{h_1}{2} + \frac{h_i}{4} + \frac{h_j}{4}$。

- $\frac{\frac{h_1 + h_i}{2} + h_j}{2}$ = $\frac{h_1}{4} + \frac{h_i}{4} + \frac{h_j}{2}$。

又由于结论 $1$，所以 $h_j > h_1$，所以第二种方案更优。

3. 如果 $n \le k$，那么把所有大于 $h_1$ 的依次与 $h_1$ 操作即可。（即城市数越少越好）

这个也是显然的吧，好似几个人分饼，要平均分，肯定是人越少越好是吧。

4. 除了 $h_1$，其他城市最多操作一次

因为操作完之后就 $\le h_1$，就没用了。

5. 要从小到大连

这个可以像上面那样推。

6. 由 $5$ 得，我们可以排序，每次选择的都是一段区间

由 $5$ 可得出这个结论。

7. 每次选择的区间都和上一个区间接触

注意，这里并不是说所有城市必须选。显然,否则平均值会一下大，一下小。

8. 每次选择区间长度单调不增

城市越少贡献越大，但是要满足平均值上升，可以发现两者之间并不冲突。

然后就可以 DP 了，设 $f_{i, j}$ 为前 $i$ 个城市操作完之后花费了 $j$ 次操作代价的最大高度，那么直接枚举一个中间点 $l$，新的连通中连接 $l + 1 \sim i$。

$$f_{i, j} = \frac{f_{l, j - 1} + (sum_i - sum_l)}{i - l + 1}$$

都能懂吧（$sum$ 为前缀和）。

发现这个东西依靠结论 $8$ 是有单调性的。具体来说，因为结论 $8$ 可以推出 $f_{i, j} > f_{i - 1, j}$，所以就可以推出单调性了。

然后就可以斜率优化了。

如果 $k > n$ 就把 $n$ 设为 $k$。

然后你的复杂度为 $O(nkp)$（万恶的高精度小数类）。

想要 AC 必须用到一个性质：

9. 因为 $h_i$ 互不相同，所以最多只有 $O(\log_2 \frac{nh}{\min(h_i - h_{i - 1})})$ 个大于 $1$ 的区间，很玄乎，反正这个值等于 $14$ 就对了。然后剩下单独处理就完了。

此时我们单独处理长度为 $1$ 的区间就完了。这样就变成 $O(tkp)$ 的复杂度了，$t$ 是个 $14$ 常数。

如果题解有问题，欢迎指正。

---


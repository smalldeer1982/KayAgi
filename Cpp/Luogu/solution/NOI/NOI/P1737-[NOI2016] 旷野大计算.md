# [NOI2016] 旷野大计算

## 题目背景

**提示：若是使用“提交代码”的方式进行提交，在评测时会给程序输入一个数字（1, 2, 3, ..., 10）表示测试点编号，请在程序中直接输出对应测试点的答案。**


## 题目描述

随着人类计算机技术的发展，计算机的能力不断提升，让跳蚤国王非常羡慕。

终于有一天，跳蚤国王发布政令：大力发展跳蚤国的计算机产业！然而，跳蚤国尚未进行工业革命，无法制造出电子计算机所需的元器件。但是跳蚤国王想出了一个绝妙的想法：把每只跳蚤作为一个计算节点，每只跳蚤只完成一个特定的小任务。

跳蚤国王带领 $n$ 只跳蚤来到了一片旷野上，把跳蚤作为计算节点在旷野上排列好，并编号为 $1$ 到 $n$。每个计算节点会把某几个（也有可能是 $0$ 个）计算节点的结果作为输入，计算得到输出。除此之外，跳蚤国王还有一个巨型的终端，可以从终端输入和输出数据，这台终端和所有计算节点组成了一台计算机。

记第 $t$ 个计算节点的输出为 $x_t$，该节点的操作可分为以下几种类型：

::cute-table{tuack}

| 名称 | 操作符（类型） | 操作数 | 计算结果 |
|-|-|-|-|
| 输入节点 | `I` | 无 | 从终端读入一个实数作为 $x_t$ |
| 输出节点 | `O` | $i$ | $x_t = x_i$，并将 $x_t$ 输出到终端 |
| 加法节点 | `+` | $i,j$ | $x_t = x_i+x_j$ |
| 偏移节点 | `C` | $i,c$ | $x_t=x_i+c$ |
| 取反节点 | `-` | $i$ | $x_t=-x_i$ |
| 左移节点 | `<` | $i,k$ | $x_t=x_i\cdot 2^k$ |
| 右移节点 | `>` | $i,k$ | $x_t=x_i\cdot 2^{-k}$ |
| S 型节点 | `S` | $i$ | $x_t=s(x_i)$ |
| 比较节点 | `P` | $i,j$ | $x_t=\begin{cases}-1 &x_i<x_j\\ 0 &x_i=x_j\\1 &x_i>x_j\\\end{cases}$|
| Max 节点 | `M` | $i,j$ | $x_t=\begin{cases}x_i &x_i>x_j\\x_j &x_i \leq x_j\end{cases}$ |
| 乘法节点 | `*` | $i,j$ | $x_t=x_i \cdot x_j$ | 

其中，$s(x)$ 的定义如下：（$e$ 为自然常数,其值约为 $2.718281828459045\ldots$）

$$s\left ( x \right )=\frac{1}{1+e^{-x}}$$

$s(x)$ 的函数图像如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/fnscfgzu.png)

上述表格中的操作数 $i,j$ 均要小于当前节点的编号 $t$，这样随着跳蚤国王的一声令下，跳蚤就可以按编号从小到大的顺序，依次获得输入然后计算输出。每个跳蚤的计算能力都是有限的，他们仅可以精确到十进制小数点后 $90$ 位，超过的部分将会被四舍五入。同理，上述表格中的操作数 $c$ 的小数部分也不能超过 $90$ 位。另外，左移节点和右移节点中的操作数 $k$ 必须是非负整数，且不能超过 $10^4$。

把跳蚤排列好后，野心勃勃的跳蚤国王决心测试一下这台由跳蚤组成的计算机的计算能力，于是蝈蝈大臣给跳蚤国王献上了十个计算任务。完成每个计算任务均需要从终端获取输入，进行中间计算，再用输出节点将结果输出。具体任务说明如下：

::cute-table{tuack}

| 编号 | 输入 | 输入限制 | 输出 |
|-|-|-|-|
| $1$ | $a,b$ | $\lvert a \rvert, \lvert b \rvert \le 10^9$，小数部分不超过 $9$ 位 | $-2a-2b$ |
| $2$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\dfrac{1}{1+e^{17a}}$ |
| $3$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\begin{cases}-1 & a \lt 0 \\ 0 & a = 0 \\ 1 & a \gt 0\end{cases}$ |
| $4$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\lvert a \rvert$，即 $a$ 的绝对值 |
| $5$ | $a_1, \dots, a_{32}$ | $a_1, \dots, a_{32} \in \{0, 1\}$ | 把 $a_1, \dots, a_{32}$ 从左到右看成一个二进制整数，高位在左低位在右，输出该整数的值 |
| $6$ | $a$ | $0 \le a \lt 2^{32}$，$a$ 为整数 | 输出 $32$ 个整数，从高位到低位输出 $a$ 的二进制表示（不足 $32$ 位的在高位补 $0$） |
| $7$ | $a,b$ | $0 \le a, b \lt 2^{32}$，$a,b$ 均为整数 | $a, b$ 按位异或的结果 |
| $8$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\dfrac{a}{10}$ |
| $9$ | $a_1, \dots, a_{16}$ | $\lvert a_1 \rvert, \dots, \lvert a_{16} \rvert \le 10^9$，小数部分不超过 $9$ 位 | 输出 $16$ 个实数，表示 $a_1, \dots, a_{16}$ 从小到大排序后的结果 |
| $10$ | $a,b,m$ | $0 \le a, b \lt 2^{32}$，$1 \le m \lt 2^{32}$，$a,b,m$ 均为整数 | $a \cdot b$ 除以 $m$ 的余数 | 

跳蚤国王发现自己没有足够的能力设计这样的计算机。于是他找到了来参加 NOI 的你。请你依次设计每个计算节点的类型及操作数，完成蝈蝈大臣给的这 10 个计算任务，且要求使用的计算节点数尽量少。

## 说明/提示

该样例输出为第一个计算任务一个可能的构造。共用了 $10$ 个计算节点，可获得 $3$ 分。

我们提供了十个评分文件 `nodes1.ans` $\sim$ `nodes10.ans`，分别对应每个计算任务。

每个评分文件共 $10$ 行，第 $i$ 行一个评分参数 $w_i$，具体意义将在下面给出。

本题中，每个测试点单独进行评分，每个测试点 $10$ 分。

如果选手的输出格式不合法或者参数不符合题目约定,则得 $0$ 分。

否则，按照以下规则判定选手的输出是否正确：

- 首先测评器会生成若干组输入数据，并将输入数据代入你构造的计算机。
- 如果在代入某一组输入数据时：你构造的计算机的计算过程中，某个计算节点的计算结果的绝对值超过 $10^{1000}$，则得 $0$ 分；
- 你构造的计算机的输出中的某个值与预期的输出值相差超过 $10^{-9}$，则认为你的输出不正确，得 $0$ 分。
- 否则，我们认为你的计算机能完成给定的计算任务，并按照以下规则得分。

对于每个测试点，我们设置了 $10$ 个评分参数 $w_1$,$w_2$,$w_3$,…,$w_9$,$w_{10}$。

假设共使用了 $n$ 个计算节点,你的分数将会由下表给出：

::cute-table{tuack}

 | 得分 | 条件 | 得分 | 条件 |
| :----------: | :----------: | :----------: | :----------: |
| 10 | $n≤w_{10}$ | 5 | $n≤w_5$ |
| 9 | $n≤w_9$ | 4 | $n≤w_4$ |
| 8 | $n≤w_8$ | 3 | $n≤w_3$ |
| 7 | $n≤w_7$ | 2 | $n≤w_2$ |
| 6 | $n≤w_6$ | 1 | $n≤w_1$ |

若不符合表中所有条件，得 $0$ 分；若符合表中的多个条件，则取分数最高的。

除此之外，使用**比较节点、Max 节点和乘法节点**的代价是极为**昂贵**的。因此，这三种节点**每使用一种**，就会从你这个测试点的得分中**倒扣 $4$ 分**。

注意这里是按使用节点的**种类数**计算扣分，**与使用次数无关**。例如多次使用比较节点，只会扣除 $4$ 分；又如同时使用了比较节点和乘法节点，**即使各只使用了一次，也会扣除 $8$ 分**。

一个测试点至多被扣到 $0$ 分，即使分数不够扣除，也不会出现负数。

## 样例 #1

### 输入

```
1```

### 输出

```
I
+ 1 1
- 2
I
+ 4 4
- 5
+ 3 6
- 7
- 8
O 9
```

# 题解

## 作者：紫钦 (赞：375)

题目链接：[P1737 [NOI2016]旷野大计算](https://www.luogu.com.cn/problem/P1737)。

题目大意：只允许使用加、取反（添负号）、偏移（加减一个常数）、左右移位（乘或除以 $2$ 的非负整数次幂）和神奇的 $S(x)$ 函数来进行编程，~~造一台计算机~~，**构造一个计算网络**，完成 $10$ 项指定的计算任务。要求计算次数尽可能少。

其中 $S(x)$ 函数为 ${\large\frac{1}{1+e^{-x}}}$ ，是一个非线性的函数。

> $S(x)$ 函数全名是 $\text{Sigmoid}$ 函数，又称 “$S$ 型生长曲线” 。
>
> $y=S(x)$ 的图像：
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/t9az0ugn.png)

还有三个功能强大但是使用了会扣分的计算节点：比较节点、取两数最大值节点、乘法节点。

是一道提交答案题。

[题目补充](https://www.luogu.com.cn/discuss/show/41511)。

[checker下载](http://uoj.ac/download.php?type=problem&id=224)。

# 解法：构造答案

具体解法在各个 $\text{task}$ 中介绍。

本题主要就是 $10$ 个计算网络的构造。

核心思想就是：利用好 $S(x)$ 的选择性。用 $S(x)$ 来实现比较大小、取 $0$ 取 $1$ ，制造分段函数，是这道题的关键所在。

必要的地方加一些小优化，以减少计算节点数。

本题解对解题过程中所用到的所有参数进行了我自认为比较详细地分析，希望这些分析能帮到阅读本题解的你。

# $\text{task1}$

## 要求

输入：$a,b$ 。

输入限制：$|a|,|b|\leqslant10^9$ ，小数部分不超过 $9$ 位。

输出：$-2a-2b$ 。

满分行数：$6$ 行。

## 解决方法

送分点。

一般来说，我们都会想到提取公因数 $-2$ 来减少运算次数。

一般来说，我们也都会想到用左移 $1$ 位来计算乘 $2$ 这个操作。

## 输出代码

```cpp
if(n==1) { // 6行。 
	printf("I\n");
	printf("I\n");
	printf("+ 1 2\n");
	printf("< 3 1\n");
	printf("- 4\n");
	printf("O 5");
}
```

# $\text{task2}$

## 要求

输入：$a$ 。

输入限制：$|a|\leqslant10^9$ ，小数部分不超过 $9$ 位。

输出：${\large\frac1{1+e^{17a}}}$ 。

满分行数：$6$ 行。

## 解决方法

也是送分点。

观察输出的这个表达式的样子，显然这个点是要用 $S(x)$ 函数的。

然后，注意到 $17a=16a+a=2^4a+a$ ，所以我们可以用位移和加法来解决乘法了。

最后还得小心，$S(x)={\large\frac1{1+e^{-x}}}$ ，还得将 $17a$ 取反后使用 $S$ 函数。

## 输出代码

```cpp
if(n==2) { // 6行。 
	printf("I\n");
	printf("< 1 4\n");
	printf("+ 1 2\n");
	printf("- 3\n");
	printf("S 4\n");
	printf("O 5");
}
```
# $\text{task3}$

## 要求

输入：$a$ 。

输入限制：$|a|\leqslant10^9$ ，小数部分不超过 $9$ 位。

输出：$\text{sign}(a)=\begin{cases}-1,a<0\\\ \ \ 0,a=0\\\ \ \ 1,a>0\end{cases}$ 。

满分行数：$6$ 行。

## 解决方法

不是送分了。开始有难度了。

没有除法，所以 ${\large\frac a{|a|}}$ 泡汤了。况且求 $|a|$ 是下一个 $\text{task}$ 的任务，所以按道理说应该并不容易求。

使用比较语句的话，直接与 $0$ 做比较，输出比较的值即可。可得 $6$ 分。

> 可以用 $a\times2^{-1000}$ 来造 $0$ 。之后就可以用比较节点比较 $a$ 和 $0$ 的大小。

但是如何使用基本操作来搞出答案呢？

**我们是该想想怎么用 $S$ 函数了。**

### 回顾题目

> 其实，我们在读题面过程中，会发现计算过程中数据精度特别高：小数点后 $90$ 位，整数部分绝对值不超过 $10^{1000}$。

> 而最终 ```Special Judge``` 判定结果时，只要与标准答案的结果相差小于 $10^{-9}$ 即可。

> **为什么给如此大的精度**？尤其是整数部分，为何那么大？小数部分似乎也精确得过分了，这又是为什么？

> 而且，为什么 $S$ 函数一定要用 ${\large\frac 1{1+e^{-x}}}$ ？它有什么**特殊之处**吗？

> 观察发现，除了第二个测试点需要直接使用了 $S(x)$ 来求出 ${\large\frac1{1+e^{17a}}}$ **精确值**之外，其余九个测试点表面上似乎都没有涉及到 $S(x)$ 的使用。

> 出题人如果只是为了送分的话，为什么还要搞这么一个函数出来呢？**这个函数真的没有其他作用了吗？**

>仔细想想，我们察觉到，好像确实没有哪个测试点需要使用 $S(x)$ 的精确值了。**所以，$S(x)$ 的价值，难道是体现在其近似值上面了吗？**

> 种种不同寻常的地方提醒着我们，这道题必然要涉及到**极限**的问题，即我们要通过某些操作，爆掉 $90$ 位小数的精度，以此模拟取极限的过程。**而 $S$ 函数的特殊之处就在于，它在正负无穷大处都有极限，分别为 $1$ 和 $0$ ，而 $y=S(x)$ 图像上有唯一一个横纵坐标都是有理数的点 $(0,{\large\frac12})$ ，这也是 $S(x)$ 的性质。进一步的， $S(x)+S(-x)=1$ ，同样是一条性质。**

> 这就启示我们结合 $\lim\limits_{x\to+\infty}S(x)=1$ ， $\lim\limits_{x\to-\infty}S(x)=0$ ，和 $S(0)={\large\frac12}$ 这三条性质，来完成题目。

> $S(x)$ 的两个极限： $1$ 和 $0$ ，恰好对应了“真”和“假”两种状态。这个性质，某种意义上而言，是实现“比较”操作的方法，能够用来判别正负。

> **所以 $S$ 函数与极限结合，应该是这道题考察的重点之一。**

### 怎么利用 $S$ 函数呢？

既然要考虑极限，我们很容易想到，将 $S$ 函数乘 $2$ ，再减去 $1$，所得恰好是个在 $+\infty,-\infty$ 处极限分别为 $+1,-1$ 的函数（即 ${\large\frac2{1+e^{-x}}}-1$）。而且在 $x=0$ 处，取值也恰好为 $0$ 。

这么看来，我们应该构造对了。

### 那么如何取极限？

简单，左移个百来位就可以变得很大了，只要 $e^{-x}$ 爆了 $90$ 位小数的精度，就能认为 $S(x)$ 与 $\pm1$ 精确相等了。

大概多少位比较合适呢？

+ $+\infty$ 处的极限：

  由 ${\large\frac1{1+e^{-x}}}<1-5\times10^{-91}$ ，

  得 $e^{-x}<{\large\frac1{1-5\times10^{-91}}}-1$，

  因为，当 $|x|<1$ 时，根据等比数列求和公式和极限理论，有 ${\large\frac1{1-x}}=1+x+x^2+x^3+\cdots=\sum\limits_{i=0}^{\infty}x^i>1+x$ 。这是因为 $x^2$ 必然是正数，而且比 $x^3$ 大，同理 $x^4$ 是正数，比 $x^5$ 大，以此类推，可知 ${\large\frac1{1-x}}>1+x$ 成立。

  所以 ${\large\frac1{1-5\times10^{-91}}}-1>5\times10^{-91}$ ，

  那么，只需要 $e^{-x}<5\times10^{-91}$ 即可。

  得 $-x<\ln(5\times10^{-91})=\ln5-91\ln10$ ，

  于是 $x>91\ln10-\ln5\approx207.926$ ，

  而 $a$ 最小是 $10^{-9}$ ，只需解 $2^k\times10^{-9}>208$ ，解得 $k$ 即可。

  那么，$k>\log_2(208\times10^9)\approx37.598$ 。
  
  所以 $k\geqslant38$ 。

+ $-\infty$ 处的极限：

  由 ${\large\frac2{1+e^{-x}}}<5\times10^{-91}$ ，

  得 $e^{-x}>4\times10^{90}-1$ ， $-x>\ln(4\times10^{90}-1)$ ，只需 $-x>\ln(4\times10^{90})$ ，

  于是 $x<-90\ln10-\ln4\approx-208.619$ ， $k>\log_2(212\times10^9)\approx37.625$ 。

所以，左移 $38$ 位即可。

+ 为什么不用偏移来制造无穷大呢？

  因为偏移无法保持正负。
  
+ 位移有上限，需解方程 $2^k\times10^{9}<10^{1000}$ ，也就是 $k<991\log_210\approx3292.031$。所以 $k=38$ 没问题的。

## 输出代码

```cpp
if(n==3) { // 6行。 
	printf("I\n");
	printf("< 1 38\n");
	printf("S 2\n");
	printf("< 3 1\n");
	printf("C 4 -1\n");
	printf("O 5");
}
```

# $\text{task4}$

## 要求

输入：$a$ 。

输入限制：$|a|\leqslant10^9$ ，小数部分不超过 $9$ 位。

输出：$|a|$ ，即 $a$ 的绝对值。

满分行数：$14$ 行。

## 解决方法

$PS.a$ 乘 $sign(a)$ 是一种解决方法，可得 $6$ 分。

我的思路和第三个点的差不多。

首先我想到，$y=|x|$ 的图像关于 $y$ 轴对称，是个偶函数，而 $S(x)+S(-x)=1$ 告诉我们，$S(x)$ 图像关于 $(0,{\large\frac12})$ 对称。所以，怎么用 $S(x)$ 搞出一个偶函数来？

$S(x)$ 在正负无穷处函数变化率**都**趋于零，这启示我们使用导数。

经过验算，我发现，$S'(x)={\large\frac{e^{-x}}{(1+e^{-x})^2}}$ 是个偶函数，且 $\lim\limits_{x\to\infty}S'(x)=0$ ， $S(0)={\large\frac14}$ 。

虽然这个导数同 $|x|$ 一样，是个偶函数；但是 $|x|$ 在 $x$ 趋于无穷时是无穷，而 $S'(x)$ 在 $x$ 趋于无穷时却趋于 $0$ 。更糟的是，在 $x=0$ 的两侧，$|x|$ 的表达式可写成不一样的形式，即 $|x|=\begin{cases}\ \ \ x,x>0\\\ \ \ 0,x=0\\-x,x<0\end{cases}$ ，而 $S'(x)$ 不能。

所以这样看来， $S'(x)$ 并不能很好的模拟 $|x|$ 函数。即使能够用 $S'(x)$ 构造，怕也免不了一些乘法或者比较的操作。

虽然用 $S'(x)$ 直接构造 $|x|$ 的思路失败了，但引入 $S'(x)$ 来辅助解题确实是一个良好的尝试。

况且，**难道仅凭这一次尝试，就能断言 $S'(x)$ 毫无作用了吗？**

事实上导数真的很有用。

我们用不了 $S'(x)$ 的全部，我们只考虑 $S'(x)$ 在一点处的取值。

在解决第三个点时，我们使用了 $S(x)$ 的两个极限，那么做这个点时，不妨再考虑考虑，能不能使用 $S(0)={\large\frac12}$ 这个性质。

由 $S'(0)={\large\frac14}$ ，我们很容易写出 $S(x)$ 在 $x=0$ 处的切线：$y={\large\frac14}x+{\large\frac12}$ 。

由切线的意义可知，$y=S(x)$ 在 $x=0$ 附近与 $y={\large\frac14}x+{\large\frac12}$ 拟合得很好，

这样，我们就得到了一个关于 $x$ 的一次函数，且这个函数减去 ${\large\frac12}$ 再乘 $4$ 就能得到 $x$ 。

> **我们实际上得到的是一个从 $S(x)$ 得到 $x$ 的办法，这个办法很重要。**
>
> 其重要性在于，我们可以将获得 $x$ 的操作拆解为 $x\to S(x)\to x$ 两个步骤，从而向这两个步骤中添加进一些我们想要的条件。
>
> 简言之，这个办法给了我们操作的空间，使得我们有了构造分段函数的可能。更本质的，使得我们有了构造条件语句的可能。

所以在这个测试点中，我们要从 $S({\large\frac x{+\infty}})$ 着手构造 $|x|$ （$S({\large\frac x{+\infty}})$ 这种写法不规范，但有助于理解）。

现在，再来考虑，如何将 $x$ 的正负区分开来。我们只有找到区分正负的办法，才可能构造出函数来模拟正负有别的 $|x|$ 函数。

区分正负的办法上面已经提到了，就是 $S(x)$ 在正负无穷大处的两个极限，分别为 $0,1$ 。

那么 $S(-x)$ 的极限就分别为 $1,0$ 。

我们要想办法让这两个截然不同的极限对我们构造的函数产生影响，使得我们构造的函数在 $x$ 正负符号不同时具有显著的差别。

设这个影响为 $t$ ，把这个影响加到 ${\large\frac {-x}{+\infty}}$ 上去（这就是对我们构造的函数产生影响的操作过程）。现在考虑 $S({\large\frac{-x}{+\infty}}+t)$ 。

我们需要让这个影响在 $x>0$ 时为无穷小（即：几乎没什么影响），在 $x<0$ 时足够大，大到能显著影响 $S({\large\frac{-x}{+\infty}}+t)$ 的值。

所谓显著影响 $S({\large\frac{-x}{+\infty}}+t)$ 的值，无非就是把 $S({\large\frac{-x}{+\infty}})$ 的值从 ${\large\frac12}$ 附近变成 $1$ ，就是说 $S({\large\frac{-x}{+\infty}}+t)\to1$ 。而减去 ${\large\frac12}$ 再乘 $4$ 后，这个影响作用的结果就变成了“使 $0$ 变成 $2$ ”。

这说明 $t$ 应该是个由 $1$ 搞出来的无穷大。比方说 $1\times2^{64}$ （这里未必就是 $64$ 这个数，还可以更大，而且这里的 $1$ 不是确切的数字 $1$ ，它只是表示一个趋近于 $1$ 但永远不等于 $1$ 的变量）。

我们把这个大小为 $2$ 的影响稍微调整一下，通过位移**调整到**和原来的影响 $t$ 大小相当的地步。这样，我们就可以通过减去 $t$ 来消除多余的影响，来构造出一个在 $x<0$ 时取 $0$ ，$x>0$ 时取 $x$ 的函数。

即 $\begin{cases}0,x<0\\x,x>0\end{cases}$ 。

这下就好办了。让这个函数乘 $2$ ，再减去 $x$ ，就得到 $|x|$ 啦！

上面的思考太抽象了，我们来重新整理一下思路：

+ 首先，计算 $t=S(-x\times2^{q})\times2^{p}=\begin{cases}0\ \ ,x>0\\2^p,x<0\end{cases}$ ，

  $PS.$ 这是 $y=S(x\times2^{41})\times2^{178}$ 的图像：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/4judcfh2.png)
  
  这里就要求 $S(-x\times2^q)$ 能够与 $0$ 或 $1$ 近似相等，
  
  + 于是令 $x=-10^{-9}$ ，
    
    只需有 ${\large\frac1{1+e^{-2^q10^{-9}}}}>1-10^{-90}$ ，
    
    利用上面的近似公式，可知 $1-e^{-2^q10^{-9}}<{\large\frac1{1+e^{-2^q10^{-9}}}}$ ，
    
    只需要 $1-e^{-2^q10^{-9}}>1-10^{-90}$ ，
    
    即 $2^q10^{-9}>90\ln10$ ，
    
    即 $q>\log_2(9\times10^{10}\ln10)\approx37.59$ ，
    
    所以 $q\geqslant38$ 。
  
  + 再令 $x=10^{-9}$ ，
    
    只需有 ${\large\frac1{1+e^{2^q10^{-9}}}}<10^{-90}$ ，
    
    即 $e^{2^q10^{-9}}>10^{90}-1$ ，
    
    只需 $e^{2^q10^{-9}}>10^{90}$ ，
    
    即 $2^q10^{-9}>90\ln10$ ，与上种情况同解，
    
    所以 $q\geqslant38$ 。
  
  这样，在跳蚤看来，$S(-x\times2^q)$ 与 $0$ 或 $1$ 是精确相等的。
  
  $PS.$ 这是 $y=S(x\times2^{41})$ 的图像：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/nbm41bur.png)

+ 然后，计算 $S({\large\frac{-x}{2^{k}}}+t)=\begin{cases}{\large\frac14}{\large\frac{-x}{2^{k}}}+{\large\frac12},x>0\\\\1\ \ \ \ \ \ \ \ \ \ \ \ \ ,x<0\end{cases}$ ，

***

  **声明：为了方便书写，以下所有表达式 $x$ 均表示取反后的 $x$ ，但表达式中表示条件的 $x$ 仍然为未取反的 $x$ 。**
  
  **声明：为了方便书写，以下所有表达式 $x$ 均表示取反后的 $x$ ，但表达式中表示条件的 $x$ 仍然为未取反的 $x$ 。**
  
  **声明：为了方便书写，以下所有表达式 $x$ 均表示取反后的 $x$ ，但表达式中表示条件的 $x$ 仍然为未取反的 $x$ 。**
  
***

  + 这里要求 $x>0$ 时， $({\large\frac14}{\large\frac x{2^{k}}}+{\large\frac12})-S({\large\frac x{2^{k}}})<10^{-90}$ ，不妨取 $x=10^9$ ，即 ${\large\frac{10^9}{4\times2^k}+{\large\frac12}-{\large\frac1{1+e^{-2^{-k}10^9}}}}<10^{-90}$
    
    为了方便书写，设 ${\large\frac{10^9}{2^k}}=t$ ，
    
    则上式为 ${\large\frac{t}{4}}+{\large\frac12}-{\large\frac1{1+e^{-t}}}<10^{-90}$
    
    即 ${\large\frac{t}{4}}-{\large\frac{1-e^{-t}}{2(1+e^{-t})}}<10^{-90}$ ，
    
    即 ${\large\frac{t}{2}}-{\large\frac{e^{t}-1}{e^{t}+1}}<2\times10^{-90}$ ，
    
    因为 $t>0$ 时， ${\large\frac{e^{t}-1}{e^{t}+1}}>{\large\frac{t}{e^t+1}}$ ，
    
    > 这里用到了不等式 $e^t>t+1$ ，该不等式可用导数的相关知识来证明。
    
    所以只需 ${\large\frac{t}{2}}-{\large\frac{t}{e^t+1}}<2\times10^{-90}$ ，
    
    即 $t{\large\frac{e^t-1}{2(e^t+1)}}<2\times10^{-90}$ ，
    
    因为 $t>0$ 时， ${\large\frac{1}{(e^t+1)}}<{\large\frac{1}{2}}$ ，
    
    所以只需 ${\large\frac{t(e^t-1)}{4}}<2\times10^{-90}$ ，即 $t(e^t-1)<8\times10^{-90}$ ，
    
    还是利用 $e^t>t+1$ ，欲使上式成立，至少需要满足 $(e^t-1)^2<8\times10^{-90}$ ，
    
    解得 $t<\ln(2\sqrt2\times10^{-45}+1)$ ，
    
    （其实只是个必要条件）
    
    把 $t={\large\frac{10^9}{2^k}}$ 代入，得 ${\large\frac{10^9}{2^k}}<\ln(2\sqrt2\times10^{-45}+1)$ ，
    
    即 $2^{k}>{\large\frac{10^9}{\ln(2\sqrt2\times10^{-45}+1)}}$ ，
    
    即 $k>9\log_210-\log_2(\ln(2\sqrt2\times10^{-45}+1))\approx177.884$ ，
    
    所以 $k\geqslant178$ 。
    
    当然 $k$ 不能取太大，否则会造成 ${\large\frac{x}{2^k}}$ 的精度下降，只需 $10^{-9}>2^k\times10^{-90}$ ，解得 $k\leqslant269$ 。
    
    而且，我所采用的放缩方式，其放缩幅度还是很大的，所以 $178$ 的下界很松。但上界 $269$ 是严格的。
  
  + 这里还要求 $x<0$ 时， ${\large\frac1{1+e^{-2^p}}}>1-10^{-90}$ ，
    
    只需 $1-e^{-2^p}>1-10^{-90}$ ，
    
    即 $p>\log_2(90\ln10)\approx7.695$ ，
    
    至于 ${\large\frac{x}{2^k}}$ ，它很小，只要 $2^p$ 够大，它对 $2^p$ 的影响就不足以改变 $S({\large\frac x{2^{k}}}+t)$ 的值。
    
    所以 $p\geqslant8$ 。
  
  + 其实没必要要求计算所得的数在 $90$ 位小数内精确相等，只要保证计算结果的 $9$ 位小数是正确的，就能解决这个问题。
    
    而我保证了 $90$ 位小数范围内精确相等，也是为了避免之后左移操作造成极大的误差。所以也不无道理。
  
    不过我的推理过程中有一些放缩幅度是较大的，并不能恰好取到阈值。而且我分析的时候并没有考虑小数点 $90$ 位后是四舍五入的。所以我的取值基本上能做到功过相抵。当然你想要考虑四舍五入也可以，这个的证明就要靠读者自己发挥啦，可以参考上面的过程。
    
    我写这么一大篇数学推理就是为了告诉读者这些参数该如何取。每个参数都是有理论依据的，而不是随便取一些足够大或足够小的数就行。即便随便取参数会更快，但我更推荐从数学上得到验证。

+ 接着，减去二分之一 $S({\large\frac x{2^{k}}}+t)-{\large\frac12}=\begin{cases}{\large\frac14}{\large\frac x{2^{k}}},x>0\\\\{\large\frac12}\ \ \ \ \ ,x<0\end{cases}$ ，

+ 再然后，乘 $2^{k+2}$ ，得 $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+2}=\begin{cases}x\ \ \ \ \ ,x>0\\2^{k+1},x<0\end{cases}$ ，

+ 接着，减去 $t$ 的影响，得 $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+2}-t=\begin{cases}x\ \ \ \ \ \ \ \ \ \ \ ,x>0\\2^{k+1}-t,x<0\end{cases}$

  我们要求 $2^{k+1}-t=0$ ，而 $t=2^p,(x<0)$ ，所以得到等式  $k+1=p$ 。
  
  所以，$(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+2}-t=\begin{cases}x,x>0\\0,x<0\end{cases}$ ，
  
  取 $q=41,k=178,p=180$ ，得到的图像大致为（这里 $p=k+2$ 的原因见下文分析 ）：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/cv7hgj3k.png)

+ 乘 $2$ 再减去 $x$ ，得：

  $((S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+2}-t)\times2-x=\begin{cases}x\ \ \ ,x>0\\-x,x<0\end{cases}$ 。

+ 减少计算节点，把 $2$ 乘到里面去，得：
  
  $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+3}-t\times2-x=\begin{cases}x\ \ \ ,x>0\\-x,x<0\end{cases}$
  
+ 不妨把 $p$ 再取大一点，使 $t$ 不用乘 $2$ ，
  
  所以取 $p=k+2$ 。式子就变成了：
  
  $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+3}-t-x=\begin{cases}x\ \ \ ,x>0\\-x,x<0\end{cases}$

得到 $|x|$ 啦。

这里面还有一个小问题，那就是 $t$ 在负数和零处的取值是不同的，具体而言 $t=S(-x\times2^{q})\times2^{p}\approx\begin{cases}2^{p}\ \ \ ,x<0\\2^{p-1},x=0\\0\ \ \ \ \ \ ,x>0\end{cases}$ ，这样的话，在 $x=0$ 处计算得到 $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+3}$ 后，消除 $t$ 的影响时，需要减去 $2t$ 才行。

但若是特判零的话，势必要增加很多节点，相当麻烦。

我们想到 $|x|=\begin{cases}x\ \ \ ,x\geqslant0\\-x,x<0\end{cases}$ ，所以我们能不能把 $x=0$ 和 $x>0$ 合并到一起运算呢（或者和 $x<0$ 合并到一起运算）？

可以的。

那么，怎么合并呢？

由于 $x$ 小数部分不超过 $9$ 位，所以给 $x$ 加上一个很小的常数 $\varepsilon=10^{-10}$ 即可。这样，当 $x\neq0$ 时， $x$ 原本的符号不改变；$x=0$ 时，$x$ 变成了正数 $10^{-10}$。

相应的我们需要调整一下参数，

此时需要满足 $q>\log_2(9\times10^{11}\ln10)\approx40.914$ ，

所以 $q\geqslant41$ 。

$k,p$ 不用改变。

> $PS.$
> 
> $2^{41.000}=2,199,023,255,552$ ，
>
> $2^{40.914}\approx2,071,768,581,099.5056016$ 。
>
> 差距还是蛮大的。

我们不妨取 $q=41,k=178,p=180$ 。

这样一写，发现至少要 $15$ 行，究其原因，是我们需要对 $x,t$ 各做一次取反。所以考虑不对 $x,t$ 取反，而对 $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+3}$ 取反的写法。

***

**声明到此结束。**

***

令 $t=S({\large\frac{x+\varepsilon}{2^q}})\times2^p=\begin{cases}2^p,x\geqslant0\\0\ \ ,x<0\end{cases}$ ，我们容易得到，答案就是：

$-(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+3}+t+x=\begin{cases}x\ \ \ ,x\geqslant0\\-x,x<0\end{cases}$ ，

这样就只需要取一次反，恰好 $14$ 行。

## 输出代码

$6$ 分代码，使用乘法节点：

```cpp
if(n==4) { // 6分代码。
	printf("I\n");
	printf("< 1 38\n");
	printf("S 2\n");
	printf("< 3 1\n");
	printf("C 4 -1\n");
	printf("* 1 5\n");
	printf("O 6");
}
```

$9$ 分代码，$15$ 行：

```cpp
if(n==4) { // 15行。
	printf("I\n");
	printf("C 1 0.0000000001\n");
	printf("- 2\n");
	printf("< 3 41\n");
	printf("S 4\n");
	printf("< 5 180\n");
	printf("> 1 178\n");
	printf("+ 7 6\n");
	printf("S 8\n");
	printf("C 9 -0.5\n");
	printf("< 10 181\n");
	printf("- 6\n");
	printf("+ 12 11\n");
	printf("+ 13 3\n");
	printf("O 14");
}
```

以及满分代码，$14$ 行：

```cpp
if(n==4) { // 14行。 
	printf("I\n");
	printf("C 1 0.0000000001\n");
	printf("< 2 41\n");
	printf("S 3\n");
	printf("< 4 180\n");
	printf("> 1 178\n");
	printf("+ 6 5\n");
	printf("S 7\n");
	printf("C 8 -0.5\n");
	printf("< 9 181\n");
	printf("- 10\n");
	printf("+ 11 5\n");
	printf("+ 12 1\n");
	printf("O 13");
}
```

# $\text{task5}$

## 要求

输入：$a_1,a_2,\cdots,a_{32}$

输入限制：$a_1,a_2,\cdots,a_{32}\in\{0,1\}$ 。

输出：把 $a_1,a_2,\cdots,a_{32}$ 从左到右看成一个二进制整数，高位在左，低位在右，输出该整数的值。

满分行数：$95$ 行。

## 解决方法

终于，

熬过上题后，

再一次遇到送分点。

按照位数加权再相加即可。

只要弄对行数，就没有任何问题。

显然没有更优解。因为没有能合并的项。

秦九韶算法可减少乘法次数，但现在是做位移。

## 输出代码

```cpp
if(n==5) { // 95行。 
	for(int i=1;i<=32;++i) printf("I\n");
	for(int i=1;i<=31;++i) printf("< %d %d\n",i,32-i);
	printf("+ 63 32\n");
	for(int i=64;i<=93;++i) printf("+ %d %d\n",i,i-31);
	printf("O 94");
}
```

# $\text{task6}$

## 要求

输入：$a$ 。

输入限制：$0\leqslant|a|<2^{32}$ ，$a$ 为整数。

输出：输出 $32$ 个整数，从高位到低位输出 $a$ 的二进制表示（不足 $32$ 位的在高位补 $0$）。

满分行数：$190$ 行。

## 解决方法

输出的是 $a$ 的二进制表示，肯定只包含 $0$ 和 $1$ 。

可以想到，这题又要用 $S(x)$ 函数来搞出 $0$ 和 $1$ 。

用 $S(x)$ 获得 $0$ 和 $1$ 要求自变量 $x$ 有正负两种取值，所以我们构造这个正负的取值。

考虑 $a$ 的 $2$ 进制的最高位，即第 $31$ 位，很显然，若这一位为 $1$ ，则 $a\geqslant2^{31}$ ；若这一位为 $0$ ，则 $a<2^{31}$ ，于是我们减去 $2^{31}$ 就能搞出正负不同的取值了。

同样的，我们需要加上 $10^{-10}$ 来保证 $S(x)$ 不会恰好取到 ${\large\frac12}$ 。

**由此我们发现，$S(x)$ 函数能够用来比较变量和某个常数之间的大小关系。**

我们至少需要将减去 $2^{31}$ 后的数左移 $41$ 位以爆掉精度。这是 $\text{task4}$ 中计算过的。

所以我们计算最高位时就输出 $S((a-2^{31})\times2^{41})$ ，即 $S(a\times2^{41}-2^{72})$ 。

我们得到 $0$ 或 $1$ 后，把它左移恰当位数后再从原数中减去，得到 $a'$ ，就可以继续对下一位搞出正负两种取值了。第二高位答案就是 $S((a'-2^{30})\times2^{41})=S(a'\times2^{41}-2^{71})$ 。

诶？还是乘 $41$ 哎！

于是我们发觉，可以一开始就将 $a$ 左移 $41$ 位，以减少计算节点数。

但这样搞就需要我们计算出 $2^{42}$ 到 $2^{72}$ 这 $31$ 个幂次方了。计算这些幂次方可以用高精（三个 $long\ long$ 拼起来就足够了），可以用 ```pow``` 函数，也可以用计算器来手动模拟压位高精。

当然最靠谱的方法就是用题目提供的 ```checker``` 来计算。写好计算节点，输入 $1$ ，让 ```checker``` 自己跑出来 $2^{42}$ 到 $2^{72}$ 。省时省力。

总之是可以预处理的。

***

总体思路大概就是这样了。

然后发现，我们可以把“加上 $10^{-10}$” 这个操作放到一开始，这样就不必每次循环都多使用一个计算节点了。

计算一下节点的总数，循环里至少需要 “$C,S,O,-,<,+$” 六个节点，把最后一位拿出来直接处理的话，就只需要 $31$ 次循环。

满分行数是 $190$ ，恰好是 $31\times6+4$ ，所以每次循环用 $6$ 个节点应该确实是正确的。

但我们实际操作一下就会发现，按照以上所说的做法，需要写 $191$ 行，能拿 $9$ 分。

说明有一行可以被优化掉。

仔细想想，发现我们可以把“加上 $10^{-10}$” 这个操作放到 $C$ 操作里，每次减去的不要刚好是 $2$ 的幂次，而是 $2$ 的幂次减去 $10^{-10}\times2^{41}\approx219.902\approx220$ ，这样就能减少最开始的偏移节点，从而将计算节点数减少到 $190$ 。

为什么是 $2$ 的幂次减去 $220$ 而不是加上 $220$ 呢？

因为减去 $2$ 的幂次后等于零意味着这一位本来是 $1$ ，所以我们应该让这一位经过 $220$ 调整完后是个正数。所以应该是 $2$ 的幂次减去 $220$ 。

于是我们把偏移的参数调整一下，通通减去 $220$ 即可。

现在是 $190$ 行。

## 输出代码

$9$ 分代码，$191$ 行：

```cpp
if(n==6) { // 191行。 
	char s[32][25]={					"\0",
							 "4398046511104", // 2^42
							 "8796093022208", // 2^43
							"17592186044416", // 2^44
							"35184372088832", // 2^45
							"70368744177664", // 2^46
						   "140737488355328", // 2^47
						   "281474976710656", // 2^48
						   "562949953421312", // 2^49
						  "1125899906842624", // 2^50
						  "2251799813685248", // 2^51
						  "4503599627370469", // 2^52
						  "9007199254740992", // 2^53
						 "18014398509481984", // 2^54
						 "36028797018963968", // 2^55
						 "72057594037927936", // 2^56
						"144115188075855872", // 2^57
						"288230376151711744", // 2^58
						"576460752303423488", // 2^59
					   "1152921504606846976", // 2^60
					   "2305843009213693952", // 2^61
					   "4611686018427387904", // 2^62
					   "9223372036854775808", // 2^63
					  "18446744073709551616", // 2^64
					  "36893488147419103232", // 2^65
					  "73786976294838206464", // 2^66
					 "147573952589676412928", // 2^67
					 "295147905179352825856", // 2^68
					 "590295810358705651712", // 2^69
					"1180591620717411303424", // 2^70
					"2361183241434822606848", // 2^71
					"4722366482869645213696", // 2^72
					};
	printf("I\n");
	printf("C 1 0.0000000001\n");
	printf("< 2 41\n");
	for(int i=4,j=31;j>=1;--j,i+=6) {
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("O %d\n",i+1);
		printf("- %d\n",i+2);
		printf("< %d %d\n",i+3,41+j);
		printf("+ %d %d\n",i+4,i-1); 
	}
	printf("> 189 41\n");
	printf("O 190");
}
```

满分，$190$ 行：

```cpp
if(n==6) { // 190行。 
	char s[32][25]={					"\0",
							 "4398046510884", // 2^42-220
							 "8796093021988", // 2^43-220
							"17592186044196", // 2^44-220
							"35184372088612", // 2^45-220
							"70368744177444", // 2^46-220
						   "140737488355108", // 2^47-220
						   "281474976710436", // 2^48-220
						   "562949953421092", // 2^49-220
						  "1125899906842404", // 2^50-220
						  "2251799813685028", // 2^51-220
						  "4503599627370249", // 2^52-220
						  "9007199254740772", // 2^53-220
						 "18014398509481764", // 2^54-220
						 "36028797018963748", // 2^55-220
						 "72057594037927716", // 2^56-220
						"144115188075855652", // 2^57-220
						"288230376151711524", // 2^58-220
						"576460752303423268", // 2^59-220
					   "1152921504606846756", // 2^60-220
					   "2305843009213693732", // 2^61-220
					   "4611686018427387684", // 2^62-220
					   "9223372036854775588", // 2^63-220
					  "18446744073709551396", // 2^64-220
					  "36893488147419103012", // 2^65-220
					  "73786976294838206244", // 2^66-220
					 "147573952589676412708", // 2^67-220
					 "295147905179352825636", // 2^68-220
					 "590295810358705651492", // 2^69-220
					"1180591620717411303204", // 2^70-220
					"2361183241434822606628", // 2^71-220
					"4722366482869645213476", // 2^72-220
					};
	printf("I\n");
	printf("< 1 41\n");
	for(int i=3,j=31;j>=1;--j,i+=6) {
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("O %d\n",i+1);
		printf("- %d\n",i+2);
		printf("< %d %d\n",i+3,41+j);
		printf("+ %d %d\n",i+4,i-1); 
	}
	printf("> 188 41\n");
	printf("O 189");
}
```

# $\text{task7}$

## 要求

输入：$a,b$ 。

输入限制：$0\leqslant a,b<2^{32}$ ， $a,b$ 均为整数。

输出：$a,b$ 按位异或后的结果。

满分行数：$605$ 行。

## 解决方法

因为是按位异或，所以必然需要把每一位都先取出来。这就用到 $\text{task6}$ 的代码了。

而按位异或完得到的 $32$ 位二进制数还需要转化成十进制数才能输出，所以这又用到 $\text{task5}$ 的代码了。

这就已经用掉大约 $2\times5\times31+62=372$ 个计算节点，满分是 $605$ 个计算节点，所以我们大约需要用 $7$ 个计算节点来完成每一位上的异或操作。

异或还是涉及到 $0$ 和 $1$ 的运算，我们当然离不开 $S(x)$ 函数啦。

+ 自然是要先来研究一下异或操作，看看能不能找到规律。

  我们知道：

  $0\oplus0=0$ ，

  $0\oplus1=1$ ，

  $1\oplus0=1$ ，

  $1\oplus1=0$ ，

***

+ 考虑做差。

  做个差的话， $1\oplus1=0$ 和 $0\oplus0=0$ 都能正确计算，但 $0\oplus1=1\oplus0=1$ 可能会算出 $1,-1$ 两个值。

  怎么把 $-1$ 搞成 $1$ 呢？

  取绝对值就好啦。

  取绝对值需要 $12$ 个节点，每一位都这样搞，写得再优美也大概需要 $700+$ 个计算节点。能拿到 $8$ 分。

  做差死了吗？

  还没，还能抢救一下。

  换个思路。我们换个思路，看看还能怎么把 $-1$ 搞成 $1$ 。

  设 $t$ 为做差得到的值，即 $t=\begin{cases}-1,0\oplus1\\\ \ \ 0,0\oplus0\ or\ 1\oplus1\\\ \ \ 1,1\oplus0\end{cases}$ ，

  首先，怎么把 $-1$ 和 $0,1$ 区分开呢？

  简单，加个 $0.5$ 再左移 $41$ 位，再放到 $S(x)$ 里算一下，就得到 $u=\begin{cases}0,0\oplus1\\1,0\oplus0\ or\ 1\oplus1\\1,1\oplus0\end{cases}$ ，

  怎么用 $u$ 和 $t$ 搞出异或呢？

  我们发现 $(1-u)\times2+t=\begin{cases}1,0\oplus1\\0,0\oplus0\ or\ 1\oplus1\\1,1\oplus0\end{cases}$ 。

  得到异或啦。

  但这个方法运算过程较麻烦，我们试试将 $t$ 减去 $0.5$ 再左移 $41$ 位，放到 $S(x)$ 里算一下，看看能不能得到更简单的式子。

  可以得到 $u'=\begin{cases}0,0\oplus1\\0,0\oplus0\ or\ 1\oplus1\\1,1\oplus0\end{cases}$ ，

  进一步的， $2u'-t=\begin{cases}1,0\oplus1\\0,0\oplus0\ or\ 1\oplus1\\1,1\oplus0\end{cases}$ ，

  它显然比上一种方式用的节点少。

  于是我们不由得想到，能不能用加法类似实现异或呢？

  减法毕竟是“取反+加法”的，计算节点个数严格大于加法，所以如果加法能实现这个操作，就没必要做差了。

  幸运的是，加法确实可以。

  于是做差真的死了。

***

+ 考虑做和。
  
  做和的话，$0\oplus1=1\oplus0=1$ 都能正确计算，但是 $0+0=0,1+1=2$ ，又产生了分歧。

  怎么处理分歧呢？

  + 首先有一个思路：

    考虑到我们的 $S(x)$ 函数现在能比较变量和一个常数的大小关系了，

    所以想办法找到一些能用的大小关系，使得 $0$ 和 $2$ 在这些大小关系上表现一致，而 $1$ 却不一致。这样就能区分出 $1$ 和 $0,2$ 了。

    设 $t=\begin{cases}0,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\2,1\oplus1\end{cases}$ ，

    我们找两个常数：$0.5,1.5$ ，$0$ 比他俩都小，$2$ 比他俩都大，$1$ 在他俩中间。

    分别减去 $0.5$ 和 $1.5$ ，再左移 $41$ 位，再放到 $S(x)$ 里算一下，我们看看结果：

    设 $f_1=S((t-0.5)\times2^{41})=\begin{cases}S(-0.5\times2^{41}) ,0\oplus0\\S(\ \ \ 0.5\times2^{41}),1\oplus0\ or\ 0\oplus1\\S(\ \ \ 1.5\times2^{41}),1\oplus1\end{cases}$ ，

    再设 $f_2=S((t-1.5)\times2^{41})=\begin{cases}S(-1.5\times2^{41}) ,0\oplus0\\S(-0.5\times2^{41}),1\oplus0\ or\ 0\oplus1\\S(\ \ \ 1.5\times2^{41}),1\oplus1\end{cases}$ ，

    于是 $f_1=\begin{cases}0 ,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\1,1\oplus1\end{cases}$ ， $f_2=\begin{cases}0 ,0\oplus0\\0,1\oplus0\ or\ 0\oplus1\\1,1\oplus1\end{cases}$ ，

    于是 $f_1-f_2=\begin{cases}0 ,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\0,1\oplus1\end{cases}$ ，

    这样我们就做出异或了。

    我开开心心地一写，发现 $663$ 行，能拿 $9$ 分。

    $663$ 和 $605$ 应该相差 $2$ 个计算节点（指 $32$ 位每一位计算时相差 $2$ 个），这意味着是我们的算法出了问题。当前算法即便优化应该也不至于优化掉两个计算节点。

  ***

  换种思路，按照刚刚减法的那个套路来。
  
  还是 $t=\begin{cases}0,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\2,1\oplus1\end{cases}$ ，我们想办法把 $2$ 和 $0,1$ 区分开，
  
  方法就是减去 $1.5$ 再左移 $41$ 位，再放到 $S(x)$ 里算一下，得到 $u=\begin{cases}0,0\oplus0\\0,1\oplus0\ or\ 0\oplus1\\1,1\oplus1\end{cases}$ ，
  
  观察发现， $t-2u=\begin{cases}0,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\0,1\oplus1\end{cases}$ ；
  
  一样的，若将 $t$ 减去 $0.5$ 再左移、再 $S(x)$ ，得到 $u'=\begin{cases}0,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\1,1\oplus1\end{cases}$ ，
  
  用 $2u'-t=\begin{cases}0,0\oplus0\\1,1\oplus0\ or\ 0\oplus1\\0,1\oplus1\end{cases}$ ，也能用同样多的计算节点得到异或的结果。
  
  这种方法比上述 $663$ 行的方法至少少用一个位移节点、一个 $S$ 节点，所以应该是正解了。
  
  实测 $603$ 行，可过。

***
  
+ 考虑优化。
  
  注意到最终输出的结果是个十进制数，而不是二进制数。我们将 $a,b$ 转化为二进制、做完异或后又转回十进制的过程，是否可以进一步优化呢？
  
  我们知道，其实异或这个操作就是加法的底层实现。
  
  不信你看，就单独的一位二进制位而言，加法有如下规律：
  
  + $0+0=0$ ，
  
  + $1+0=1$ ，
  
  + $0+1=1$ ，
  
  + $1+1=0$ ，
  
  可以看出，就单独的一位而言，加法和异或会得到相同的结果。
  
  但不同的是，在加法中 $1+1$ 会产生进位信号（可以用“与”操作判断是否进位），这个进位信号会被传递给更高一位，从而影响更高一位的值。
  
  **所以，如果我们把这个进位信号对更高位的影响消去，就可以把加法操作变成异或操作了。**
  
  换句话说，**在二进制下考虑，异或就是不进位的加法。**
  
  ***
  
  那我们怎么消除进位的影响呢？
  
  先把 $a,b$ 加到一起，
  
  然后还是把每一位都取出来，按位相加。在按位相加的过程中判断进位。
  
  > 如果某一位上加起来结果等于 $2$ ，则意味着这一位会向高位进位，而等于 $0$ 或 $1$ 则意味着不会进位。
  
  于是，我们用上文提到的“减去 $1.5$ 再左移 $41$ 位，再放到 $S(x)$ 里算一下”来将“进位”与“不进位”区分开来，得到 $u=\begin{cases}0,0\oplus0\\0,1\oplus0\ or\ 0\oplus1\\1,1\oplus1\end{cases}$ ，即 $u=\begin{cases}0,\ \ \ \text{no carry}\\1,\ \ \ \text{carry}\end{cases}$ ，
  
  若将二进制位从低位到高位编号为 $0$ 到 $31$ ，则易知第 $i$ 位产生的进位会给第 $i+1$ 位加上 $1$，所以我们可以通过从 $a+b$ 中减去 $1\times2^{i+1}$ 来消去这个进位的影响。
  
  第 $i$ 位如果不产生进位，那么减去 $0\times2^{i+1}$ 也不会有什么问题。
  
  于是我们可以对上述 $603$ 行代码进行进一步优化了。至少能省去将二进制转化为十进制所用的若干节点。
  
  于是我写了一下，$542$ 行。
  
  将二进制下最低位单独处理，可以再节省 $3$ 个节点。具体而言：
  
  + 取出 $a,b$ 二进制位时，不将最低位右移 $41$ 位还原，而是将其直接减去 $1.5\times2^{41}$ ，再放到 $S(x)$ 里面进行计算。
  
  于是得到了 $539$ 行的计算机。

## 输出代码

$9$ 分，$663$ 行：

```cpp
if(n==7) { // 663行。 
	char s[32][25]={					"\0",
							 "4398046510884", // 2^42-220
							 "8796093021988", // 2^43-220
							"17592186044196", // 2^44-220
							"35184372088612", // 2^45-220
							"70368744177444", // 2^46-220
						   "140737488355108", // 2^47-220
						   "281474976710436", // 2^48-220
						   "562949953421092", // 2^49-220
						  "1125899906842404", // 2^50-220
						  "2251799813685028", // 2^51-220
						  "4503599627370249", // 2^52-220
						  "9007199254740772", // 2^53-220
						 "18014398509481764", // 2^54-220
						 "36028797018963748", // 2^55-220
						 "72057594037927716", // 2^56-220
						"144115188075855652", // 2^57-220
						"288230376151711524", // 2^58-220
						"576460752303423268", // 2^59-220
					   "1152921504606846756", // 2^60-220
					   "2305843009213693732", // 2^61-220
					   "4611686018427387684", // 2^62-220
					   "9223372036854775588", // 2^63-220
					  "18446744073709551396", // 2^64-220
					  "36893488147419103012", // 2^65-220
					  "73786976294838206244", // 2^66-220
					 "147573952589676412708", // 2^67-220
					 "295147905179352825636", // 2^68-220
					 "590295810358705651492", // 2^69-220
					"1180591620717411303204", // 2^70-220
					"2361183241434822606628", // 2^71-220
					"4722366482869645213476", // 2^72-220
					};
	char s15[]="3298534883328",s05[]="1099511627776";
	printf("I\n");
	printf("I\n");
	printf("< 1 41\n");
	printf("< 2 41\n");
	for(int i=5,j=31;j>=1;--j,i+=19) {
		printf("C %d -%s\n",i-2,s[j]); 	// i
		printf("C %d -%s\n",i-1,s[j]); 	// i+1
		printf("S %d\n",i);				// i+2
		printf("S %d\n",i+1);			// i+3
		printf("+ %d %d\n",i+2,i+3);	// i+4
		printf("C %d -0.5\n",i+4); 		// i+5
		printf("C %d -1.5\n",i+4);		// i+6
		printf("< %d 41\n",i+5);		// i+7
		printf("< %d 41\n",i+6);		// i+8
		printf("S %d\n",i+7);			// i+9
		printf("S %d\n",i+8); 			// i+10
		printf("- %d\n",i+10);			// i+11
		printf("+ %d %d\n",i+11,i+9);	// i+12
		printf("- %d\n",i+2);			// i+13
		printf("- %d\n",i+3);			// i+14
		printf("< %d %d\n",i+13,41+j); 	// i+15
		printf("< %d %d\n",i+14,41+j);	// i+16
		printf("+ %d %d\n",i+15,i-2);	// i+17
		printf("+ %d %d\n",i+16,i-1);	// i+18
	}
	printf("+ 592 593\n");				// 594
	printf("C 594 -%s\n",s05);
	printf("C 594 -%s\n",s15);
	printf("S 595\n");
	printf("S 596\n");
	printf("- 598\n");
	printf("+ 599 597\n");				// 600
	for(int i=17,j=31;j>=1;--j,i+=19) printf("< %d %d\n",i,j); // 601~631
	for(int i=601,j=631;i<=630;++j,++i) printf("+ %d %d\n",i,j); // 632~661
	printf("+ 661 600\n");
	printf("O 662");
}
```

满分，$603$ 行：

```cpp
if(n==7) { // 603行。 
	char s[32][25]={					"\0",
							 "4398046510884", // 2^42-220
							 "8796093021988", // 2^43-220
							"17592186044196", // 2^44-220
							"35184372088612", // 2^45-220
							"70368744177444", // 2^46-220
						   "140737488355108", // 2^47-220
						   "281474976710436", // 2^48-220
						   "562949953421092", // 2^49-220
						  "1125899906842404", // 2^50-220
						  "2251799813685028", // 2^51-220
						  "4503599627370249", // 2^52-220
						  "9007199254740772", // 2^53-220
						 "18014398509481764", // 2^54-220
						 "36028797018963748", // 2^55-220
						 "72057594037927716", // 2^56-220
						"144115188075855652", // 2^57-220
						"288230376151711524", // 2^58-220
						"576460752303423268", // 2^59-220
					   "1152921504606846756", // 2^60-220
					   "2305843009213693732", // 2^61-220
					   "4611686018427387684", // 2^62-220
					   "9223372036854775588", // 2^63-220
					  "18446744073709551396", // 2^64-220
					  "36893488147419103012", // 2^65-220
					  "73786976294838206244", // 2^66-220
					 "147573952589676412708", // 2^67-220
					 "295147905179352825636", // 2^68-220
					 "590295810358705651492", // 2^69-220
					"1180591620717411303204", // 2^70-220
					"2361183241434822606628", // 2^71-220
					"4722366482869645213476", // 2^72-220
					};
	printf("I\n");						// 1。 
	printf("I\n");						// 2。 
	printf("< 1 41\n");					// 3。 
	for(int i=4,j=31;j>=1;--j,i+=5) {	// 4~158。 
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("- %d\n",i+1);
		printf("< %d %d\n",i+2,41+j);
		printf("+ %d %d\n",i+3,i-1);
	}
	printf("> 158 41\n");				// 159。 
	printf("< 2 41\n");					// 160。 
	for(int i=161,j=31;j>=1;--j,i+=5) { // 161~315。 
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("- %d\n",i+1);
		printf("< %d %d\n",i+2,41+j);
		printf("+ %d %d\n",i+3,i-1);
	}
	printf("> 315 41\n");				// 316。
	for(int i=5,j=1;j<=31;++j,i+=5) {	// 317~347。 
		printf("+ %d %d\n",i,i+157);
	} 
	printf("+ 159 316\n");				// 348。 
	for(int i=317,j=1;j<=32;++j,++i) {	// 349~380。 
		printf("C %d -1.5\n",i);
	}
	for(int i=349,j=1;j<=32;++j,++i) {	// 381~412。 
		printf("< %d 41\n",i);
	}
	for(int i=381,j=1;j<=32;++j,++i) {	// 413~444。 
		printf("S %d\n",i);
	}
	for(int i=413,j=1;j<=32;++j,++i) {	// 445~476。 
		printf("< %d 1\n",i);
	}
	for(int i=445,j=1;j<=32;++j,++i) {	// 477~508。 
		printf("- %d\n",i);
	}
	for(int i=477,j=1;j<=32;++j,++i) {	// 509~540。 
		printf("+ %d %d\n",i,i-160);
	}
	for(int i=509,j=31;j>=1;--j,++i) {	// 541~571。 
		printf("< %d %d\n",i,j);
	}
	for(int i=540,j=1;j<=31;++j,++i) {	// 572~602。 
		printf("+ %d %d\n",i,i+31);
	}
	printf("O 602\n"); 
}
```

满分，$542$ 行：

```cpp
if(n==7) { // 542行。  
	char s[32][25]={					"\0",
							 "4398046510884", // 2^42-220
							 "8796093021988", // 2^43-220
							"17592186044196", // 2^44-220
							"35184372088612", // 2^45-220
							"70368744177444", // 2^46-220
						   "140737488355108", // 2^47-220
						   "281474976710436", // 2^48-220
						   "562949953421092", // 2^49-220
						  "1125899906842404", // 2^50-220
						  "2251799813685028", // 2^51-220
						  "4503599627370249", // 2^52-220
						  "9007199254740772", // 2^53-220
						 "18014398509481764", // 2^54-220
						 "36028797018963748", // 2^55-220
						 "72057594037927716", // 2^56-220
						"144115188075855652", // 2^57-220
						"288230376151711524", // 2^58-220
						"576460752303423268", // 2^59-220
					   "1152921504606846756", // 2^60-220
					   "2305843009213693732", // 2^61-220
					   "4611686018427387684", // 2^62-220
					   "9223372036854775588", // 2^63-220
					  "18446744073709551396", // 2^64-220
					  "36893488147419103012", // 2^65-220
					  "73786976294838206244", // 2^66-220
					 "147573952589676412708", // 2^67-220
					 "295147905179352825636", // 2^68-220
					 "590295810358705651492", // 2^69-220
					"1180591620717411303204", // 2^70-220
					"2361183241434822606628", // 2^71-220
					"4722366482869645213476", // 2^72-220
					};
	printf("I\n");						// 1。 
	printf("I\n");						// 2。 
	printf("+ 1 2\n");					// 3。 
	printf("< 1 41\n");					// 4。 
	for(int i=5,j=31;j>=1;--j,i+=5) {	// 5~159。 
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("- %d\n",i+1);
		printf("< %d %d\n",i+2,41+j);
		printf("+ %d %d\n",i+3,i-1);
	}
	printf("> 159 41\n");				// 160。 
	printf("< 2 41\n");					// 161。 
	for(int i=162,j=31;j>=1;--j,i+=5) { // 162~316。 
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("- %d\n",i+1);
		printf("< %d %d\n",i+2,41+j);
		printf("+ %d %d\n",i+3,i-1);
	}
	printf("> 316 41\n");				// 317。
	for(int i=6,j=1;j<=31;++j,i+=5) {	// 318~348。 
		printf("+ %d %d\n",i,i+157);
	} 
	printf("+ 160 317\n");				// 349。 
	for(int i=318,j=1;j<=32;++j,++i) {	// 350~381。 
		printf("C %d -1.5\n",i);
	}
	for(int i=350,j=1;j<=32;++j,++i) {	// 382~413。 
		printf("< %d 41\n",i);
	}
	for(int i=382,j=1;j<=32;++j,++i) {	// 414~445。 
		printf("S %d\n",i);
	}
	for(int i=414,j=32;j>=1;--j,++i) {	// 446~477。 
		printf("< %d %d\n",i,j);
	}
	for(int i=446,j=1;j<=32;++j,++i) {	// 478~509。 
		printf("- %d\n",i);
	}
	printf("+ 478 3\n");				// 510。 
	for(int i=479,j=1;j<=31;++j,++i) {	// 511~541。 
		printf("+ %d %d\n",i,i+31);
	}
	printf("O 541");
}
```

满分，$539$ 行：

```cpp
if(n==7) { // 539行。 // (a+b)-sum{(a[i]+b[i]==2)<<i+1} 能省掉二进制转十进制的节点。 
	char s[32][25]={					"\0",
							 "4398046510884", // 2^42-220
							 "8796093021988", // 2^43-220
							"17592186044196", // 2^44-220
							"35184372088612", // 2^45-220
							"70368744177444", // 2^46-220
						   "140737488355108", // 2^47-220
						   "281474976710436", // 2^48-220
						   "562949953421092", // 2^49-220
						  "1125899906842404", // 2^50-220
						  "2251799813685028", // 2^51-220
						  "4503599627370249", // 2^52-220
						  "9007199254740772", // 2^53-220
						 "18014398509481764", // 2^54-220
						 "36028797018963748", // 2^55-220
						 "72057594037927716", // 2^56-220
						"144115188075855652", // 2^57-220
						"288230376151711524", // 2^58-220
						"576460752303423268", // 2^59-220
					   "1152921504606846756", // 2^60-220
					   "2305843009213693732", // 2^61-220
					   "4611686018427387684", // 2^62-220
					   "9223372036854775588", // 2^63-220
					  "18446744073709551396", // 2^64-220
					  "36893488147419103012", // 2^65-220
					  "73786976294838206244", // 2^66-220
					 "147573952589676412708", // 2^67-220
					 "295147905179352825636", // 2^68-220
					 "590295810358705651492", // 2^69-220
					"1180591620717411303204", // 2^70-220
					"2361183241434822606628", // 2^71-220
					"4722366482869645213476", // 2^72-220
					};
	char s15[]={"3298534883328"};
	printf("I\n");						// 1。 
	printf("I\n");						// 2。 
	printf("+ 1 2\n");					// 3。 
	printf("< 1 41\n");					// 4。 
	for(int i=5,j=31;j>=1;--j,i+=5) {	// 5~159。 
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("- %d\n",i+1);
		printf("< %d %d\n",i+2,41+j);
		printf("+ %d %d\n",i+3,i-1);
	}
	printf("< 2 41\n");					// 160。 
	for(int i=161,j=31;j>=1;--j,i+=5) { // 161~315。 
		printf("C %d -%s\n",i-1,s[j]);
		printf("S %d\n",i);
		printf("- %d\n",i+1);
		printf("< %d %d\n",i+2,41+j);
		printf("+ %d %d\n",i+3,i-1);
	}
	for(int i=6,j=1;j<=31;++j,i+=5) {	// 316~346。 
		printf("+ %d %d\n",i,i+156);
	}
	printf("+ 159 315\n");				// 347。 
	for(int i=316,j=1;j<=31;++j,++i) {	// 348~378。 
		printf("C %d -1.5\n",i);
	}
	for(int i=348,j=1;j<=31;++j,++i) {	// 379~409。 
		printf("< %d 41\n",i);
	}
	printf("C 347 -%s\n",s15);			// 410。 
	for(int i=379,j=1;j<=32;++j,++i) {	// 411~442。 
		printf("S %d\n",i);
	}
	for(int i=411,j=32;j>=1;--j,++i) {	// 443~474。 
		printf("< %d %d\n",i,j);
	}
	for(int i=443,j=1;j<=32;++j,++i) {	// 475~505。 
		printf("- %d\n",i);
	}
	printf("+ 475 3\n");				// 506。 
	for(int i=476,j=1;j<=31;++j,++i) {	// 507~538。 
		printf("+ %d %d\n",i,i+31);
	}
	printf("O 538");
}
```

# $\text{task8}$

## 要求

输入：$a$ 。

输入限制：$|a|\leqslant10^9$ ，小数部分不超过 $9$ 位。

输出：${\large\frac a{10}}$ 。

满分行数：$7$ 行。

## 解决方法

与二进制无关了，所以用不到 $S(x)$ 的选择性了。

通过 ```node8.ans``` ，我们知道，满分计算机是 $7$ 个计算节点！

这说明我们需要用一些奇技淫巧了。

+ 能不能二分答案呢？

  因为乘 $10$ 的操作还是好做的，所以对 $[0,{\large\frac a8}]$ 进行二分，检验二分值的 $10$ 倍是否等于 $a$ ，用 $S(x)$ 函数来作比较，并完成二分区间的更新。

  理论上可行，但二分至误差不超过 $10^{-9}$ 是真的困难，可以预见，我们的计算节点数会多到爆炸。还不如直接用乘法节点赚个实惠。

+ 能不能用多次右移再相加来模拟乘 $0.1$ 的操作呢？
  
  也可以，但仍然不是正解。
  
  $0.1=2^{-4}+2^{-5}+2^{-8}+2^{-9}+2^{-12}+2^{-13}+2^{-16}+2^{-17}+2^{-20}+\cdots$
  
  而 $2^{-4}+2^{-5}+2^{-8}+2^{-9}+2^{-12}+2^{-13}+2^{-16}+2^{-17}+2^{-20}=0.09999942779541015625$ ，
  
  只需要加足够多的项就能使得答案在精度范围内准确了。
  
  据说能拿 $7$ 到 $8$ 分。

***
 
下面讲正解。

我们考虑如何正确使用 $S(x)$ 函数来完成除以 $10$ 的操作。

回想我们完成 $\text{task4}$ 时对 $S(x)$ 导数的思考，以及我们使用 $S(x)$ 在 $x=0$ 处的切线来获取一条近似直线的操作，

那么我们是否可以找到 $S(x)$ 上一条斜率为 ${\large\frac1{10}}$ 的切线呢？

我们知道， $S'(x)={\large\frac{e^{-x}}{(1+e^{-x})^2}}\in(0,{\large\frac14}]$ ，且 $S'(x)$ 是 $R$ 上的连续函数、偶函数，

所以 $\exists\ \xi\in(0,+\infty)$ ， 使得 $S'(\xi)={\large\frac1{10}}$ ，

我们可以写出 $S(x)$ 在这点的切线方程，为 $y=S'(\xi)(x-\xi)+S(\xi)$ ，

即 $y={\large\frac1{10}}(x-\xi)+S(\xi)$ 。

由切线的意义知，当 $x$ 与 $\xi$ 非常接近时，$S(x)$ 近似等于 $S'(\xi)(x-\xi)+S(\xi)={\large\frac1{10}}(x-\xi)+S(\xi)$ ，

所以我们将输入的 $a$ 右移 $k$ 位（造一个微小量），再加上 $\xi$ ，就构造出了一个与 $\xi$ 非常接近的值，并计算 $S({\large\frac{a}{2^k}}+\xi)$ 的值，

因为 ${\large\frac{a}{2^k}}$ 很小，所以 $S({\large\frac{a}{2^k}}+\xi)$ 近似等于 ${\large\frac1{10}}({\large\frac{a}{2^k}}+\xi-\xi)+S(\xi)={\large\frac1{10}}{\large\frac{a}{2^k}}+S(\xi)$ ，

于是 $(S({\large\frac{a}{2^k}}+\xi)-S(\xi))\times2^{k}$ 近似等于 ${\large\frac a{10}}$ 。

好了，现在唯一的问题就是， $\xi$ 等于多少？

解方程 $S'(\xi)={\large\frac{e^{-\xi}}{(1+e^{-\xi})^2}}={\large\frac1{10}}$ ，

得： $10e^{-\xi}=(1+e^{-\xi})^2$ ，

得： $e^{-2\xi}-8e^{-\xi}+1=0$ ，

使用求根公式得： $e^{-\xi}=4\pm\sqrt{15}$ ，

钦定 $\xi>0$ ，所以 $0<e^{-\xi}<1$ ，所以舍去 $4+\sqrt{15}$ ，得：$e^{-\xi}=4-\sqrt{15}$ ，

于是 $\xi=-\ln(4-\sqrt{15})=\ln(4+\sqrt{15})$ ，

于是 $S(\xi)={\large\frac1{1+e^{-\xi}}}={\large\frac1{5-\sqrt{15}}}={\large\frac{5+\sqrt{15}}{10}}$ ，

好了，现在该如何计算出这两个玩意儿？

因为我们最后会乘个 $2^k$ ，所以这两个玩意儿的精度必须极其高才行。

那么先算 $k$ ：

+ 令 $x={\large\frac{a}{2^k}}$ ，

  解 ${\large\frac1{10}}x+S(\xi)-S(x+\xi)<10^{-90}$ ，

  即 ${\large\frac1{10}}x+{\large\frac1{1+e^{-\xi}}}-{\large\frac1{1+e^{-(x+\xi)}}}<10^{-90}$ ，
  
  即 ${\large\frac1{10}}x-{\large\frac{e^{-\xi}-e^{-(x+\xi)}}{(1+e^{-(x+\xi)})(1+e^{-\xi})}}<10^{-90}$ ，
  
  即 ${\large\frac1{10}}x-{\large\frac{e^{x}-1}{(e^{(x+\xi)}+1)(1+e^{-\xi})}}<10^{-90}$ ，
  
  因为 $x>0$ 时，${\large\frac{e^{x}-1}{(e^{(x+\xi)}+1)(1+e^{-\xi})}}>{\large\frac{x}{(e^{x+\xi}+1)(1+e^{-\xi})}}$ ，
  
  所以只需 ${\large\frac1{10}}x-{\large\frac{x}{(e^{(x+\xi)}+1)(1+e^{-\xi})}}<10^{-90}$ ，
  
  即 $x{\large\frac{(e^{(x+\xi)}+1)(1+e^{-\xi})-10}{10(e^{(x+\xi)}+1)(1+e^{-\xi})}}<10^{-90}$ ，
  
  注意到 $(e^{\xi}+1)(1+e^{-\xi})=4+\sqrt{15}+4-\sqrt{15}+2=10$ ，
  
  所以将上式中的 $e^{(x+\xi)}$ 强行拆开，得：$x{\large\frac{(e^{(x+\xi)}+1)(1+e^{-\xi})-10}{10(e^{(x+\xi)}+1)(1+e^{-\xi})}}=x{\large\frac{(e^x-1)(e^{\xi}+1)}{10((e^x-1)(e^{\xi}+1)+10)}}<10^{-90}$
  
  $x>0$ 时，仍然使用 $e^x>x+1>1$ ，将分母中的 $e^{x}$ 放缩为 $1$ ，将分子中的 $x$ 放缩为 $e^x-1$ ，
  
  所以只需 ${\large\frac{(e^x-1)^2(e^{\xi}+1)}{100}}<10^{-90}$ ，
  
  即 $x<\ln(\sqrt{(5-\sqrt{15})\times10^{-89}}+1)$ ，
  
  把 $x={\large\frac{a}{2^k}}$ 代入得：${\large\frac{a}{2^k}}<\ln(\sqrt{(5-\sqrt{15})\times10^{-89}}+1)$
  
  取 $a=10^9$ ，得 $k>9\log_210-\log_2(\ln(\sqrt{(5-\sqrt{15})\times10^{-89}}+1))\approx177.637$
  
  故只需 $k\geqslant178$ 。
  
  同样的，$k$ 不能太大，同 $\text{task4}$ ，需有 $k\leqslant269$ 。
  
  同样的，$178$ 这个下界很松。实测取到 $86$ 都没问题。
  
+ 再来计算：

  $\xi=-\ln(4-\sqrt{15})=\ln(4+\sqrt{15})$ ，

  $S(\xi)={\large\frac1{1+e^{-\xi}}}={\large\frac1{5-\sqrt{15}}}={\large\frac{5+\sqrt{15}}{10}}$ ，
  
  怎么算呢？
  
  用电脑的计算器计算 $\xi=\ln(4+\sqrt{15})$ ，然后把计算所得的数放到 ```checker``` 里面算出一个 $S(\xi)$ 。
  
  > 不要忘了，你的 ```checker``` 是可以运行你所构造的计算机的。
  
  我用电脑的计算器算得 $\xi=$```2.0634370688955605467272811726201``` ，
  
  用 ```checker``` 算得 $S(\xi)=$```0.887298334620741688517926539978236773937633025540819832675154107295416657242528255923059519``` ，
  
  实测这两个参数可以过。
  
  使用强大的计算器算得 $\xi$ 和 $S(\xi)$ 小数点后 $90$ 位（括号里为第 $91$ 位）得： 
  
  ```2.063437068895560546727281172620131871456591449883392499836032692765902842847409911780353006(4)```
  
  ```0.887298334620741688517926539978239961083292170529159082658757376611348309193697903351928737(6)```
  
  $PS.$ 可以看到，还是有一定的误差的。
  
  这是 $y=(S({\large\frac{x}{2^{178}}}+\xi)-S(\xi))\times2^{178}$ 的图像：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/5gxmnl2j.png)
  
于是这个测试点可以过了。

## 输出代码

$6$ 分，使用乘法节点：

```cpp
if(n==8) { // 6 分代码，使用乘法节点。
	printf("I\n");
	printf("> 1 233\n");	// 造零。 
	printf("C 2 0.1\n");	// 造0.1。
	printf("* 1 3\n");
	printf("O 4");
}
```

满分，$7$ 行：

```cpp
if(n==8) { // 7 行。 
	printf("I\n");
	//printf("C 2 2.063437068895560546727281172620131871456591449883392499836032692765902842847409911780353006\n");
	printf("> 1 178\n");
	printf("C 2 2.0634370688955605467272811726201\n"); //  计算器答案。 
	printf("S 3\n");
	//printf("C 4 -0.887298334620741688517926539978239961083292170529159082658757376611348309193697903351928738\n");
	printf("C 4 -0.887298334620741688517926539978236773937633025540819832675154107295416657242528255923059519\n");
	printf("< 5 178\n");
	printf("O 6");
}
```

# $\text{task9}$

## 要求

输入：$a_1,\cdots,a_{16}$ 。

输入限制：$|a_1|,\cdots,|a_{16}|\leqslant10^9$ ，小数部分不超过 $9$ 位。

输出：输出 $16$ 个实数，表示 $a_1,\cdots,a_{16}$ 从小到大排序后的结果。

满分行数：$3000$ 。

## 解决方法

计算节点太单一了，所以有些操作很难实现。

很多高效的排序方法都不能用了，只能使用冒泡排序、选择排序这些基本的算法。

一步一步来考虑。

+ 不管是用什么排序，一个绕不开的操作就是交换两个数。

  嗯，怎么交换两个数呢？

  ~~```a^=b^=a^=b```~~ 。

  （异或需要 $539$ 行，可见在这道题里面位运算可并不快）

  我们有加法和减法，所以用这个来实现交换。考虑到每个计算节点只能被赋值一次，我们写出如下代码：

  ```cpp
  u=a+b;
  p=u-b;
  q=u-p;
  ```

  最终 $p$ 即为交换后的 $b$ ，$q$ 即为交换后的 $a$ 。

  > ——为什么不直接 ```p=a;q=b;``` 来完成交换呢？
  >
  > ——因为我们需要同时考虑不交换的情况，故我们的交换操做略微修改后应能够兼容不交换的情况。而直接使用赋值来进行交换会使得我们失去在交换中操作空间，也就没有修改的余地了。

  现在考虑不交换的情况，首先我们需要把不交换的操作也写成上面那种形式，并且最好有很多地方与上文完全相同，便于我们构造计算网络。思索一番，我们得到：

  ```cpp
  u=a+b;
  p=u-a;
  q=u-p;
  ```

  两种写法仅在 ```p=u-?``` 处有差别。交换则减 $b$ ，不交换则减 $a$ 。

  我们钦定，若 $a>b$ ，则交换；否则不交换。

  于是，我们把交换和不交换两种写法合到一起，得到这样的代码：

  ```cpp
  u=a+b;
  p=u-min(a,b);
  q=u-p;
  ```

  现在问题在于如何计算 $\min(a,b)$ 。

  $\min(a,b)$ 计算的返回值是 $a$ 或者 $b$ ，而不是 $0$ 或者 $1$ 。

  什么样的操作能返回自变量本身呢？

  记不记得我在上文讲 $\text{task4}$ 时曾说过：

  > **我们实际上得到的是一个从 $S(x)$ 得到 $x$ 的办法，这个办法很重要。**

  就在 $\text{task4}$ 中，我们构造了若干以零为分界点的分段函数。其中一个分段函数（就是 $\text{task4}$ 的答案）为：

  $-(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+3}+t+x=\begin{cases}x\ \ \ ,x\geqslant0\\-x,x<0\end{cases}$ ，

  往回退几步，有这样一个分段函数：

  $(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+2}-t=\begin{cases}0,x\geqslant0\\x,x<0\end{cases}$ ，

  其中 $t=S({\large\frac{x+\varepsilon}{2^q}})\times2^p=\begin{cases}2^p,x\geqslant0\\0\ \ ,x<0\end{cases}$ ，

  此时的参数为 $q=41,k=178,p=179$ ，**注意此处 $p$ 取值并非 $\text{task4}$ 中最后 $p$ 的取值 $180$ ，而且 $S({\large\frac x{2^{k}}}+t)-{\large\frac12}$ 后面乘的并非 $2^{k+3}$ 。**

  而容易发现， $\min(x,0)=\begin{cases}0,x\geqslant0\\x,x<0\end{cases}$ ，所以我们有了一个可以和 $0$ 取 $\min$ 的函数，即 $\min(x,0)=(S({\large\frac x{2^{k}}}+t)-{\large\frac12})\times2^{k+2}-t$ 。

  将 ```p=u-min(a,b)``` 改写为 ```p=(u-b)-min(a-b,b-b)``` ，即 ```p=a-min(a-b,0)``` 的形式。这个形式就可以用上面得到的 $\min(x,0)$ 来解决了。
  
  于是交换的操作完成了，还顺便解决了比大小操作。
  
+ 解决了交换和比较大小的操作后，我们只需要再选择一种排序方式就能完成任务了。
  
  冒泡排序当然可以（而且还很优美），在这里我试着写了一下 $\text{Bitonic Sort}$ （双调排序）。
  
  双调排序是一个非常适合于 $\text{GPU}$ 编程的排序算法，只需要比较器就可以完成全部的排序工作。
  
  不过它只能对 $2$ 的幂次个数据进行排序，好在此测试点恰好有 $16$ 个数据。
  
  关于双调排序，此处就不赘述了；
  
  我会尽快在我的博客 [双调排序](https://www.luogu.com.cn/blog/user37839/shuang-diao-pai-xu) 中具体介绍它（该博客现在处于待填坑隐藏状态，什么时候它不再是隐藏文章了，就说明我填坑完毕了。能力有限，实在抱歉 $\cdots\cdots$）。
  
  双调排序体现在代码中的 ```for``` 循环中，不会双调排序的话，这几个 ```for``` 看起来会很费解。。。

## 输出代码

满分，$1392$ 行：

```cpp
if(n==9) { // 1392 行。 
	const int N=16; // 数据总数。 
	int pos[17],row=0,a,b; // 16个数据当前的位置，当前输出行数。两个临时节点。 
	for(int i=1;i<=N;++i) printf("I\n"),pos[i]=i,++row;
	for(int i=1,i2=2;i2<=N;++i,i2<<=1) {
		for(int j=1,j2=i2-1;j2>=1;++j,j2-=2) {
			for(int k=j;k<=N;k+=i2) {	// 每次交换 17 行。 
				a=k;b=k+j2;
				++row;	printf("+ %d %d\n",pos[a],pos[b]);				// u=a+b;
				++row;	printf("- %d\n",pos[b]);						// -b;
				++row;	printf("+ %d %d\n",pos[a],row-1);				// x=a+-b;
				++row;	printf("C %d 0.0000000001\n",row-1);			// x+eps;
				++row;	printf("< %d 41\n",row-1);						// (x+eps)<<41;
				++row;	printf("S %d\n",row-1);							// S((x+eps)<<41);
				++row;	printf("< %d 179\n",row-1);						// t=S((x+eps)<<41)<<179;
				++row;	printf("> %d 178\n",row-5);						// x>>178;
				++row;	printf("+ %d %d\n",row-1,row-2);				// (x>>178)+t;
				++row;	printf("S %d\n",row-1);							// S((x>>178)+t);
				++row;	printf("C %d -0.5\n",row-1);					// S(...)-0.5;
				++row;	printf("< %d 180\n",row-1);						// (S(...)-0.5)<<180;
				++row;	printf("- %d\n",row-1);							// -(S(...)-0.5)<<180;
				++row;	printf("+ %d %d\n",row-7,row-1); 				// -min=t-(S(...)-0.5)<<180;
				++row;	printf("+ %d %d\n",pos[a],row-1);	pos[b]=row;	// p=a-min; b'=p;
				++row;	printf("- %d\n",row-1);							// -p;
				++row;	printf("+ %d %d\n",row-16,row-1);	pos[a]=row;	// q=u+-p; 	a'=q;
			}
		}
		for(int j=(i2>>2);j>=1;j>>=1) {
			for(int k=1;k<=j;++k) {
				for(int l=k;l<=N;l+=(j<<1)) {
					a=l;b=l+j;
					++row;	printf("+ %d %d\n",pos[a],pos[b]);				// u=a+b;
					++row;	printf("- %d\n",pos[b]);						// -b;
					++row;	printf("+ %d %d\n",pos[a],row-1);				// x=a+-b;
					++row;	printf("C %d 0.0000000001\n",row-1);			// x+eps;
					++row;	printf("< %d 41\n",row-1);						// (x+eps)<<41;
					++row;	printf("S %d\n",row-1);							// S((x+eps)<<41);
					++row;	printf("< %d 179\n",row-1);						// t=S((x+eps)<<41)<<179;
					++row;	printf("> %d 178\n",row-5);						// x>>178;
					++row;	printf("+ %d %d\n",row-1,row-2);				// (x>>178)+t;
					++row;	printf("S %d\n",row-1);							// S((x>>178)+t);
					++row;	printf("C %d -0.5\n",row-1);					// S(...)-0.5;
					++row;	printf("< %d 180\n",row-1);						// (S(...)-0.5)<<180;
					++row;	printf("- %d\n",row-1);							// -(S(...)-0.5)<<180;
					++row;	printf("+ %d %d\n",row-7,row-1); 				// -min=t-(S(...)-0.5)<<180;
					++row;	printf("+ %d %d\n",pos[a],row-1);	pos[b]=row;	// p=a-min; b'=p;
					++row;	printf("- %d\n",row-1);							// -p;
					++row;	printf("+ %d %d\n",row-16,row-1);	pos[a]=row;	// q=u+-p; 	a'=q;
				}
			}
		}
	}
	for(int i=1;i<=N;++i) printf("O %d\n",pos[i]);
}
```

# $\text{task10}$

## 要求

输入：$a,b,m$ 。

输入限制：$0\leqslant a,b<2^{32}$ ， $1\leqslant m<2^{32}$ ， $a,b,m$ 均为整数。

输出：$a\times b$ 除以 $m$ 的余数。

满分行数：$2000$ 行。

## 解决方法

首先，这个式子没有化简的余地。

> 使用 $a\times b\mod m=((a\mod m)\times(b\mod m))\mod m$ 更不行，虽然每次取余所需的计算节点个数少了，但总的取余次数多了。

看来不管怎么搞，我们都避不开乘法操作。

那就先来讲讲怎么实现乘法。

+ 一个比较容易想到的做法就是使用快速乘，将 $b$ 拆分为二进制，将 $a$ 按 $b$ 不同二进制位上的 $0$ 或 $1$ 相应地做位移后再加起来。
  
  举个栗子，$b=5=2^2+2^0$ ，则 $a\times b=a\times2^2+a\times2^0$ 。
  
  二进制拆分参见 $\text{task6}$ ，将 $a$ 对应做位移再相加参见 $\text{task5}$ ，有前面的铺垫，这个点的乘法应该怎么计算还是蛮容易想到的。
  
+ 一个不太容易想到的做法是泰勒展开。
  
  先普及一下泰勒公式：
  
  > 如果函数 $f(x)$ 在 $x=x_0$ 的某个邻域内有 $n$ 阶导数，且在 $x=x_0$ 处有 $n+1$ 阶导数，则对该邻域内的任意一点 $x$ 处，有
  >
  > $f(x)=f(x_0)+f'(x_0)(x-x_0)+{\large\frac{f''(x_0)}{2!}}(x-x_0)^2+\cdots+{\large\frac{f^{(n)}(x_0)}{n!}}(x-x_0)^n+o((x-x_0)^n)$ ，
  > 
  > $f^{(n)}(x_0)$ 为 $f(x)$ 在 $x_0$ 处的 $n$ 阶导数。
  >
  > $o((x-x_0)^{n})$ 表示一个函数，它的表达式我们写不出来，我们只知道它是 $(x-x_0)^n$ 的高阶无穷小。什么意思呢？就是当 $x-x_0$ 无限接近于 $0$ 时，此时的 $(x-x_0)^n$ 是非常非常小的一个数，非常接近于 $0$ ，而 $o((x-x_0)^n)$ 是个比 $(x-x_0)^n$ 还要小很多的数，更接近于 $0$ ——尽管我们并不知道 $o((x-x_0)^n)$ 的具体表达式是什么。
  >
  > > 不要和我较真说 $o((x-x_0)^n)$ 就等于 $f(x)-(f(x_0)+f'(x_0)(x-x_0)+{\large\frac{f''(x_0)}{2!}}(x-x_0)^2+\cdots+{\large\frac{f^{(n)}(x_0)}{n!}}(x-x_0)^n)$ ，
  > >
  > > 这样写出来的 $o((x-x_0)^n)$ 没有实际意义，并不能清楚地表达 $o((x-x_0)^n)$ 的性质。
  >
  > 上面那个**等式**就是 $f(x)$ 的 $n$ 阶泰勒公式，我们一般也将之称为“泰勒展开”。
  
  ### 为什么想到要使用泰勒公式？
  
  核心思想还是想办法利用 $S(x)$ 函数构造乘法。在我们只能做加加减减的情况下，怎么才能快速构造出 $a\times b$ 这样的二次的表达式呢？
  
  这就想到泰勒公式了，因为泰勒公式能将一个函数强行拆成若干多项式以及一个表达式未知但却很小的 $o((x-x_0)^n)$ 的和，所以能够搞出次数为二次的项。有了二次的项，我们的加加减减就能更方便地构造 $a\times b$ 了（之所以认为加加减减不方便，是因为常数次的加加减减不会提高变量的次数，譬如 $a$ 乘任意一个（与 $a$ 无关的）常数都不会变成 $a^2$）。
  
  ***
  
  ### 那么该怎么用泰勒公式呢？
  
  先将 $S(x)$ 用泰勒公式展开两阶看看。
  
  根据求导的法则，我们得： 
  
  $S'(x)={\large\frac{e^{-x}}{(1+e^{-x})^2}}=S(x)(1-S(x))$ ，
  
  $S''(x)={\large\frac{e^{-x}(e^{-x}-1)}{(1+e^{-x})^3}}$ ，
  
  则 $S(x)$ 在某点 $x_0$ 处的 $2$ 阶泰勒公式为： 
  
  $S(x)=S(x_0)+S'(x_0)(x-x_0)+{\large\frac{S''(x_0)}{2!}}(x-x_0)^2+o((x-x_0)^2)$ ，
  
  即 $S(x)={\large\frac{1}{1+e^{-x_0}}}+{\large\frac{e^{-x_0}}{(1+e^{-x_0})^2}}(x-x_0)+{\large\frac{e^{-x_0}(e^{-x_0}-1)}{2(1+e^{-x_0})^3}}(x-x_0)^2+o((x-x_0)^2)$ ，
  
  换元，用 $x+x_0$ 代替 $x$，得 $S(x+x_0)={\large\frac{1}{1+e^{-x_0}}}+{\large\frac{e^{-x_0}}{(1+e^{-x_0})^2}}x+{\large\frac{e^{-x_0}(e^{-x_0}-1)}{2(1+e^{-x_0})^3}}x^2+o(x^2)$ ，
  
  我们取一个比较好的 $x_0$ ，使得上式变得优美一些。
  
  比如说取 $x_0=-\ln3$ ，
  
  那么上式变成：$S(x-\ln3)={\large\frac{1}{4}}+{\large\frac{3}{16}}x+{\large\frac{3}{64}}x^2+o(x^2)$ ，
  
  > ——为什么选 $-\ln3$ ？
  >
  > > 首先可以看到，分母全部变成 $2$ 的倍数了，方便我们用位移来计算除法。
  > >
  > > 当然 $-\ln7$ 什么的也可以，但是写起代码来会麻烦一些。因为 $3=1+2$ 而 $7=1+2+4$ ，会至少多一次位移和一次加法。
  > >
  > > $+\ln3$ 也行，做法基本一致。
  
  根据上文所说的关于 $o()$ 函数的含义，我们知道，当 $x$ 非常小、非常接近于 $0$ 时 ， $o(x^2)$ 也非常接近 $0$ ，且比 $x^2$ 更接近 $0$ 。也就是说，$x$ 趋近于 $0$ 时，$S(x)$ 和 ${\large\frac{1}{4}}+{\large\frac{3}{16}}x+{\large\frac{3}{64}}x^2$ 几乎相等。
  
  则我们用 $S(x)$ 减去 ${\large\frac{1}{4}}+{\large\frac{3}{16}}x$ 再乘 ${\large\frac{64}{3}}$ 就可以近似得到 $x^2$ 。
  
  按照这个操作，我们可以获得 $a^2,b^2,(a+b)^2$ ，则根据 $a\times b={\large\frac12}((a+b)^2-a^2-b^2)$ 就能构造出 $a\times b$ 了。
  
  ***
  
  好我们还需要解决除以 $3$ 的问题。
  
  由于 $S'(x)\leqslant{\large\frac13}$ ，所以我们改为除以 $6$ 再乘 $2$ 。
  
  解方程 $S'(\xi)={\large\frac16}$ 得 $\xi=\ln(2+\sqrt3),S(\xi)={\large\frac{3+\sqrt3}{6}}$ ，
  
  使用电脑的计算器算得 $\xi=$ ```1.316957896924816708625046347308``` ，
  
  再用 ```checker``` 算得 $S(\xi)=$ ```0.788675134594812882254574390250983987152637213723810691381222453707336011601878062966598728```  ，
  
  但很遗憾，这样算得的 $\xi$ 和 $S(\xi)$ 精度太低了，在后面的运算过程中小数点后 $9$ 位以内会出现较大误差，所以使用 ```checker``` 的方法宣告 $gg$ 。
  
  使用强大的计算器算得 $\xi$ 和 $S(\xi)$ 分别如下：
  
  ```1.316957896924816708625046347307968444026981971467516479768472256920460185416443976074219013(4)```
  
  ```0.788675134594812882254574390250978727823800875635063438009301163241988836151466672846857697(7)```
  
  我们只能用这两个数了。
  
  ***
  
  类似 $\text{task8}$ ，我们用除以 $2^{k}$ 来造极小量，
  
  > **这里不能直接用 $k=178$ ，也不能随便设个差不多的数。就因为这一个参数没有设置准确，我调参调了一天，一直 $WA$ 到自闭才找到问题所在。**
  >
  > **实测这里的 $k$ 取值范围极其窄。所以务必认真对待以下分析。**
  
  因为 $S'''(x)={\large\frac{e^{-x}(e^{-2x}-4e^{-x}+1)}{(1+e^{-x})^4}}$ ，

  所以 $S(x)$ 在 $x_0$ 处的 $3$ 阶泰勒公式为：

  $S(x)=S(x_0)+S'(x_0)(x-x_0)+{\large\frac{S''(x_0)}{2!}}(x-x_0)^2+{\large\frac{S'''(x_0)}{3!}}(x-x_0)^3+o((x-x_0)^3)$

  $\ \ \ \ \ \ \ \ \ ={\large\frac{1}{1+e^{-x_0}}}+{\large\frac{e^{-x_0}}{(1+e^{-x_0})^2}}(x-x_0)+{\large\frac{e^{-x_0}(e^{-x_0}-1)}{2(1+e^{-x_0})^3}}(x-x_0)^2+{\large\frac{e^{-x_0}(e^{-2x_0}-4e^{-x_0}+1)}{6(1+e^{-x_0})^4}}(x-x_0)^3+o((x-x_0)^3)$ ，

  用 $x+x_0$ 替换 $x$ ，上式即为：

  $S(x+x_0)={\large\frac{1}{1+e^{-x_0}}}+{\large\frac{e^{-x_0}}{(1+e^{-x_0})^2}}x+{\large\frac{e^{-x_0}(e^{-x_0}-1)}{2(1+e^{-x_0})^3}}x^2+{\large\frac{e^{-x_0}(e^{-2x_0}-4e^{-x_0}+1)}{(1+e^{-x_0})^4}}x^3+o(x^3)$ ，

  取 $x_0=-\ln3$ 得 $S(x)$ 在 $-\ln3$ 处的 $3$ 阶泰勒公式为：

  $S(x-\ln3)={\large\frac{1}{4}}+{\large\frac{3}{16}}x+{\large\frac{3}{64}}x^2-{\large\frac{1}{256}}x^3+o(x^3)$ ，

  其中 $\lim\limits_{x\to0}o(x^3)=0$ ，甚至 $\lim\limits_{x\to0}{\large\frac{o(x^3)}{x^3}}=0$ 。

  （第二个式子是 $o(x^3)$ 的定义，在此不详述。第二个式子真正能说明 $o(x^3)$ 比 $x^3$ 还小得多，因为 $o(x^3)$ 除以了一个非常小的数 $x^3$ 之后，极限仍然是 $0$ ）

  取 $x=$ 微小量 ${\large\frac{a}{2^k}}$ ，可取足够大的 $k$ 使 $x$ 非常接近 $0$ 。现在来求 $k$ 的取值范围：

  欲使 $S(x-\ln3)={\large\frac{1}{4}}+{\large\frac{3}{16}}x+{\large\frac{3}{64}}x^2$ 近似相等，需要有 $|-{\large\frac{1}{256}}x^3+o(x^3)|<5\times10^{-91}$ 。

  因为 $o(x^3)$ 真的很小，我们将之忽略，所以只需 ${\large\frac{1}{256}}x^3<5\times10^{-91}$ ，即 ${\large\frac{1}{256}}({\large\frac{a}{2^k}})^3<5\times10^{-91}$ ，

  $a<2^{32}$ ，故只需 ${\large\frac{1}{256}}({\large\frac{2^{32}}{2^k}})^3<5\times10^{-91}$ ，

  整理得 $k>{\large\frac{89}3}+30\log_210\approx129.325$ ，

  所以 $k>130$ 。

  另一方面，${\large\frac{3}{64}}({\large\frac{a}{2^k}})^2$ 的精度不能丢失，故要求 ${\large\frac{3}{64}}({\large\frac{a}{2^k}})^2>10^{-90}$ ，

  取 $a=1$ ，只需 ${\large\frac{3}{2^{2k+6}}}>10^{-90}$ ，

  整理得 $k<45\log_210+{\large\frac12}\log_23-3\approx147.279$ ，

  所以 $k\leqslant147$ 。

  然而实测 $k$ 的取值范围为 $[124,131]$ ，个人猜测可能有几点原因：

  1. 上述分析有 $\text{bug}$ ，比如即便 ${\large\frac{1}{256}}({\large\frac{2^{32}}{2^k}})^3<5\times10^{-91}$ 成立，第 $91$ 位仍可能产生不该有的进位。再如保证了 ${\large\frac{3}{64}}({\large\frac{a}{2^k}})^2>10^{-90}$ ，也不能保证其小数点后最后一位精度不会丢失。

  2. $\ln3,\xi$ 和 $S(\xi)$ 本身只能保留 $90$ 位，在乘 $2$ 的幂次时造成误差。
  
  3. $S(x)$ 函数含超越数 $e$ ，本身很容易产生误差。

  最终我取了 $k=130$ 。
  
  ***
  
  可以得出：${\large\frac16}x=(S({\large\frac{x}{2^{130}}}+\xi)-S(\xi))\times2^{130}$ ，

  于是 ${\large\frac{64}3}x=(S({\large\frac{x}{2^{130}}}+\xi)-S(\xi))\times2^{137}$ 。

  而 ${\large\frac3{16}}x={\large\frac1{16}}x+{\large\frac18}x$ ，两次位移和一次加法可解决。
  
  这样，我们就可以计算出 $x^2$ 了。
  
  这是 $y=(S({\large\frac{x}{2^{130}}}+\xi)-S(\xi))\times2^{130}$ 的图像：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/37o4bi1k.png)
  
  ***
  
  ### 梳理一下思路：

  令 $t_1=S({\large\frac{a}{2^{130}}}-\ln3)-{\large\frac14}-({\large\frac1{16}}{\large\frac{a}{2^{130}}}+{\large\frac18}{\large\frac{a}{2^{130}}})$ ，则 $({\large\frac{a}{2^{130}}})^2={\large\frac{64}3}t_1=(S(t_1+\xi)-S(\xi))\times2^7$ ；
  
  > 这里大家可能会有个疑惑：为什么 $t_1$ 没有除以 $2^{130}$ 就直接放到 $S(x)$ 函数里计算了呢？
  >
  > 其实 $t_1={\large\frac{3}{64}}({\large\frac{a}{2^{130}}})^2+o(({\large\frac{a}{2^{130}}})^2)\approx{\large\frac{3}{64}}({\large\frac{a}{2^{130}}})^2$ ，
  >
  > 可见 $t_1$ 仍然是微小量。所以不需要再除以 $2^{130}$ 了。 
  
  $({\large\frac{b}{2^{130}}})^2,({\large\frac{a}{2^{130}}}+{\large\frac{b}{2^{130}}})^2$ 同理 。最后再乘上 $2^{260}$ 就能还原回 $a^2,b^2,(a+b)^2$ 了。

  为了减少计算节点，我们将 $S(t_1+\xi),S(t_2+\xi),S(t_3+\xi)$ 都计算出来后，先按照 $((a+b)^2-a^2-b^2)$ 做差，即 $S(t_3+\xi)-S(t_1+\xi)-S(t_2+\xi)$ ，再加上 $S(\xi)$ ，最后乘上 $2^{266}$ ，就可以得到 $a\times b$ 啦。
  
  再加一些优化，计算节点数还可以变得更少。具体做法就留给读者自己思索咯。

  可是 $\ln3$ 怎么算？
  
  这个我真的不知道该如何利用 ```checker``` 来计算了。。。

  使用强大的计算器算得：

  $\ln3=$ ```1.098612288668109691395245236922525704647490557822749451734694333637494293218608966873615754(8)```

至此，我们用比快速乘更少的节点（ $35$ 个）计算出了 $a\times b$ 。

***

下面讲如何完成取余操作。

+ 取余操作，可以等效为若干次减法操作。
  
  设 $a\times b=p\times m+r$ ，其中 $0\leqslant r<m$ ，
  
  那么，一个显然的做法就是：
  
  > 我们枚举这个 $p$ ，如果 $a\times b$ 比当前枚举到的 $p\times m$ 大，则继续往大枚举；否则往小枚举。
  
  这样搞的计算节点数当然会多到爆炸啦。
  
  由于 $a\times b<2^{64}$ ，
  
  所以考虑直接将 $p$ 二进制拆分，即 $p=p_0\times2^0+p_1\times2^1+\cdots+p_{63}\times2^{63}$ ，其中 $p_i\in\{0,1\},i\in[0,63]$ 。
  
  然后从高位到低位枚举 $p_i$ ，当前 $ab$ 比 $m\times2^{i}$ 大，则将 $m\times2^i$ 从 $ab$ 中减去。直到 $i=0$ ，操作完成后即得 $r$ ，即余数。
  
  为了减少计算节点数，我们先将 $ab$ 取反，变成 $-ab$ ，然后每次加上 $m\times2^i$ ，最后把得到的 $-r$ 取反即得 $r$ 。这样我们在计算 $ab$ 时的方式也要相应的调整，变为 ${\large\frac12}(a^2+b^2-(a+b)^2)$ ，同时调整一些细节即可。
  
  至于如何调整，留给读者自己思考完成吧。
  
  那么具体如何比较大小呢？
  
  考虑对于 $M=m\times2^i$ ，如何正确执行 $\begin{cases}-ab+M\ ,-ab+M\leqslant0\\-ab\ \ \ \ \ \ \ \ \ \ ,-ab+M>0\end{cases}$ 呢？

  首先我们可以得到一个函数 $p=\begin{cases}0,\ -ab+M<0\\1,\ -ab+M>0\end{cases}$ ，

  这样的话， $p=0$ 就代表要让 $-ab$ 加上 $M$ ，$p=1$ 代表不加上 $M$ 。

  由于 $-ab+M$ 一定是整数，且 $-ab+M=0$ 时也应该执行加上 $M$ 的操作，所以我们将 $-ab$ 提前减去 $0.1$ ，从而使得我们的 $p$ 能够处理 $-ab+M=0$ 的情形。

  则此时 $p=\begin{cases}0,\ -ab+M\leqslant0\\1,\ -ab+M>0\end{cases}$ ，

  我们想要的是 $\begin{cases}-ab+M\ ,-ab+M\leqslant0\\-ab\ \ \ \ \ \ \ \ \ \ ,-ab+M>0\end{cases}$ ，利用 $p$ 可以将之改写为 $-ab+(1-p)\times M$ ，

  考虑到 $1-p$ 只有 $0,1$ 两种取值，所以我们只需要构造 $(1-p)M=\begin{cases}M\ ,p=0\\0\ \ \ ,p=1\end{cases}$ ，

  这个形式的函数我们在 $\text{task4}$ 中讲过，以下再简述一番。

  将 $M$ 拆为 $(S({\large\frac{M}{2^{178}}})-0.5)\times2^{180}$ ，考虑在这个过程中加入 $p$ 的影响。

  构造 $t=p\times2^{179}=\begin{cases}0\ \ \ \ \ ,p=0\\2^{179}\ ,p=1\end{cases}$ ，作为 $p$ 的影响。

  将 $t$ 加入上述过程中，即 $(S({\large\frac{M}{2^{178}}}+t)-0.5)\times2^{180}=\begin{cases}M\ \ \ ,p=0\\2^{179}\ ,p=1\end{cases}$ ，

  减去 $t$ ，消除多余影响，得 $(S({\large\frac{M}{2^{178}}}+t)-0.5)\times2^{180}-t=\begin{cases}M\ ,p=0\\0\ \ \ ,p=1\end{cases}$ ，

  于是做完了。
  
  共 $807$ 行，比官方题解的 $819$ 行略少。
  
  开心。

## 输出代码

满分，$807$ 行：

```cpp
if(n==10) { // 807 行。
	const int W=130;
	char ln3[]={"1.098612288668109691395245236922525704647490557822749451734694333637494293218608966873615755"};
	
	//  1.316957896924816708625046347307968444026981971467516479768472256920460185416443976074219013
	// -0.25
	// =1.066957896924816708625046347307968444026981971467516479768472256920460185416443976074219013
	char xi []={"1.066957896924816708625046347307968444026981971467516479768472256920460185416443976074219013"};
	
	//  0.78867513459481288225457439025097872782380087563506343800930116324198883615146667 2846857698
	// +0.00000000000000000000000000000000000000000000000000000000000000000000000000000000 0843375836  // 0.1>>266;
	// =0.78867513459481288225457439025097872782380087563506343800930116324198883615146667 3690233534
	char Sxi[]={"0.788675134594812882254574390250978727823800875635063438009301163241988836151466673690233534"};
	printf("I\n");						
	printf("I\n");
	printf("I\n");
	printf("> 1 %d\n",W);
	printf("> 2 %d\n",W);				// 5。 
	printf("+ 4 5\n");
	printf("C 4 -%s\n",ln3);			
	printf("C 5 -%s\n",ln3);			
	printf("C 6 -%s\n",ln3);			
	printf("S 7\n");					// 10。 
	printf("S 8\n");
	printf("S 9\n");
	printf("> 4 4\n"); 					
	printf("> 4 3\n");
	printf("> 5 4\n"); 					// 15。 
	printf("> 5 3\n");
	printf("+ 13 14\n");
	printf("+ 15 16\n");
	printf("- 17\n");
	printf("- 18\n");					// 20。 
	printf("+ 19 20\n");
	printf("+ 10 19\n");
	printf("+ 11 20\n");
	printf("+ 12 21\n");
	printf("C 22 %s\n",xi);				// 25。 
	printf("C 23 %s\n",xi);
	printf("C 24 %s\n",xi);
	printf("S 25\n");
	printf("S 26\n");
	printf("S 27\n");					// 30
	printf("+ 28 29\n");
	printf("- 30\n");
	printf("+ 31 32\n");
	printf("C 33 -%s\n",Sxi);
	printf("< 34 %d\n",W*2+6+41);		// 35。 // 提前左移 41 位，加上本来应该左移的 266 位。 
	for(int i=36,j=63;j>=0;--j,i+=12) {
		printf("< 3 %d\n",41+j);		// M=m<<i;
		printf("+ %d %d\n",i,i-1);		// -ab+M;
		printf("S %d\n",i+1);			// p=S((-ab+M)<<41);
		printf("< %d 179\n",i+2);		// t=p<<179;
		printf("> %d 178\n",i);			// M>>178;
		printf("+ %d %d\n",i+4,i+3);
		printf("S %d\n",i+5);
		printf("C %d -0.5\n",i+6);
		printf("< %d %d\n",i+7,180);
		printf("- %d\n",i+3);			// -t;
		printf("+ %d %d\n",i+9,i+8);
		printf("+ %d %d\n",i+10,i-1);	// -ab+M or -ab+0;
	}
	printf("> 803 41\n");
	printf("C 804 0.100000000064\n");	// 因为 0.1>>266 时产生了一些精度误差，所以在这个地方往回补一补精度。 
	printf("- 805\n");
	printf("O 806");
}

```

# 结语

+ 本篇题解作为旷野大计算的题解，思路清晰，解法自然，逻辑严谨，你可以利用这篇题解，为自己的解题之旅进行热身。

  苯蒟蒻相信，这篇优美的题解，可以给拼搏于获奖的逐梦之路上的你，提供一个有力的援助。
  
  ~~不好意思走错片场了。~~
  
+ 整体代码就不往上放了，这里是 [评测记录](https://www.luogu.com.cn/record/29131210)。
  
+ 利用好 $S(x)$ 函数。该函数是本题的灵魂。~~这话说着容易做起来难。~~ 极限是本题的经脉，使灵魂有了承载。二者结合，我认为是本题最重要的思想。

  利用连续函数构造分段函数，是二者结合的具体体现。

+ 注意计算节点的优化，有些可以特殊处理的就拿出来单独处理。单独处理往往能减少计算节点个数。
  
+ 我尽可能减少计算节点，并成功把 $\text{task7,task10}$ 的计算节点数压到了官方题解以下。
  
  ~~可把我牛逼坏了。~~

+ 关于 $\text{task4,task8}$ 中将函数视作直线的误差分析，同样可使用 $\text{task10}$ 中泰勒展开的方式来做。

+ **定义结构体、使用函数来输出、重载运算符，从而将自己的代码让程序自动按执行顺序翻译成题目所给的计算节点的形式。这样的操作更有利于调试和编程，也方便理解，而且可移植性非常强。若按照我的写法，修改代码的时候，很多表示计算节点编号的参数都需要重新计算。输出调试的时候麻烦更甚！**
  
  **虽然我这种最底层编写方式能带给我些许减少计算节点的可能，但就题论题，我减少掉的那几个计算节点其实无关紧要。**
  
  **所以最好不要参照我的这种写法，参照 ```ljc1301``` $\text{dalao}$ 的题解或者 ```da32s1da``` $\text{dalao}$ 所给出的官方题解都可以。**
  
  **官方题解的代码写法真的让在下甘拜下风，比我的不知高明了多少，太方便了！**
  
+ 双调排序积极填坑中。
  
+ 本题真的是在造一台计算机。也可视作使用一种较低级语言进行编程。

+ 本题的 ```checker``` 可以留下来，我觉得蛮有用的。

+ 本题解 $\text{posted on \color{red}01\color{black}:\color{red}23\color{black}:\color{red}4\color{balck}8}$ ！
  
  很遗憾秒数没有卡准。
  
+ 终于做完了这道题，总体来说还是很有成就感的。
  
  为了写这篇题解，放弃期末复习，我也是很有胆魄了（捂脸）。
  
  我已经尽可能减少错别字了，期望能带给读者最好的阅读体验。
  
  这篇题解基本上真实地还原了我的思考历程，~~当然省略了我看题解的过程~~，可以算是事无巨细，为的是能够带给前来查阅题解的人一些思路，也为了将尽可能严谨的分析贡献出来，更为了将我对这道题更本质的思考展现给大家，希望能给大家一些题目以外的启迪。
  
  诚挚感谢您的阅读，希望我的题解能帮到您。祝 $AC$ 愉快。

---

## 作者：da32s1da (赞：42)

**做~~水~~题能极大提高模拟能力------by da32s1da**

**官方题解**在最后，本蒟蒻的题解太弱了，这道题怼了一个周，在机房偷偷摸摸打的，，最近才找到官方题解，就补充一下。

------------

测试点**1**：送分题

读入两个数后一起处理。
```
puts("I");
puts("I");
puts("+ 1 2");
puts("< 3 1");
puts("- 4");
puts("O 5");
```

------------

测试点**2**:送分题

注意到**17=$2^4$+1**,又**$\tfrac{1}{1+e^{17a}}=\tfrac{1}{1+e^{-(-17a)}}= s\left(-17a\right)$**，于是迎刃而解。
```
puts("I");
puts("< 1 4");
puts("+ 1 2");
puts("- 3");
puts("S 4");
puts("O 5");
```

------------

测试点**3**:有**一**点难度

不用扣分节点的话，似乎很难搞。但再读一遍题后发现，出题人为何要给$s(x)$的**图像**？**精度**有什么作用？

显然，若数很大

$s(x>0)=0.999999……=1$

$s(x<0)=0.000000……=0$

$s(0)=0.5$
```
puts("I");
puts("< 1 100");
puts("S 2");
puts("C 3 -0.5");
puts("< 4 1");
puts("O 5");
```

------------

测试点**4**:有**两**点难度

我们发现$|x|$比较小时，$\frac{s(x)-s(0)}{x}=s'(0)=\frac{1}{4}$，故$s(x)≈\frac{x}{4}+0.5$。**嘿嘿嘿……**

将其**减去0.5**后**左移3位**再**取反**，可得到**-2x**，这样**负数**就解决了。

注：以下为叙述方便，位移位数用**∞**表示，具体**~~自己推算或看代码~~**

但是正数怎么办呢？考虑利用$x=x+0$的性质。**点3**中的函数可以利用一下！我们令**t=s(x<<∞)<<∞**后，带入**s(x>>∞+t)**，易知$x>0$时，为1。重复上面的操作，得到**-0.5<<∞**，在加上$t$即可。而**x=0**时，加一个很小的数，防止出现误差。
```
puts("I");
puts("C 1 0.000000000000000000000000000001");
puts("< 2 200");
puts("S 3");
puts("< 4 200");
puts("> 1 198");
puts("+ 5 6");
puts("S 7");
puts("C 8 -0.5");
puts("< 9 201");
puts("- 10");
puts("+ 11 1");
puts("+ 12 5");
puts("O 13");
```

------------

测试点**5**:送分题

模拟即可，注意不要将最后一个$*2^0$。
```
for(int i=1;i<=32;i++) puts("I");
for(int i=1;i<=31;i++) printf("< %d %d\n",i,32-i);
puts("+ 32 33");
for(int i=1;i<=30;i++) printf("+ %d %d\n",63+i,33+i);
puts("O 94");
```

------------

测试点**6**:有**三**点难度

我们利用点3发现的规律。从**31**向**0**搜，若$x≥(1<<i)$，则第$i$位为1，否则为0。

发现当$i==0$时，可直接求出最后一位无需循环。

可是会**WA**，为什么呢？

因为若直接与**(1<<i)**相减，如果是**0**，那么**S(0)=$\frac{1}{2}$**，之后计算会出现误差，所以我们对**(1<<i)**处理一下，比如将几位**置为0**，就不会出现误差了。

还要注意一点，我们读入数据后马上**左移**，原因是防止循环中**C**后左移，浪费次数。

```
puts("I");
puts("< 1 500");
for(int i=31;i>=1;i--){
	stringstream s;
	s.precision(0);
	s<<fixed<<pow(2.0L,500+i);
	int p=(32-i)*6-4;
	string ss=s.str();ss[75]=ss[76]=ss[77]='0';
	printf("C %d -%s\n",p,ss.c_str());
	printf("S %d\n",p+1);
	printf("O %d\n",p+2);
	printf("- %d\n",p+2);
	printf("< %d %d\n",p+4,500+i);
	printf("+ %d %d\n",p,p+5);
}
puts("> 188 500");
puts("O 189");
```

------------

测试点**7**:有**四**点难度

首先我们像**点6**一样找出每一位的二进制，然后处理异或，最后加起来即可。

但是怎么处理异或呢？注意到

$0$ $xor$ $0$ $=$ $0$，即两数和为**0**，异或为**0**。

$0$ $xor$ $1$ $=$ $1$，即两数和为**1**，异或为**1**。

$1$ $xor$ $0$ $=$ $1$，即两数和为**1**，异或为**1**。

$1$ $xor$ $1$ $=$ $0$，即两数和为**2**，异或为**0**。

发现两数和为**0**或**1**时，异或值为本身，而和为**2**时，异或值为**0**。

所以可用**S()**来处理。将和减去**1.5**后左移求**S()**，和为**2**时**S()**为**1**，否则为**0**。然后我们将其**乘2取负**，与和**相加**，就得到异或值了！

同样，最后一位单独处理。
```
puts("I");
puts("I");
puts("< 1 500");
puts("< 2 500");
for(int i=31;i>=1;i--){
	stringstream s;
	s.precision(0);
	s<<fixed<<pow(2.0L,500+i);
	string ss=s.str();ss[75]=ss[76]=ss[77]='0';
	int p=(32-i)*18-14;
	printf("C %d -%s\n",i==31?3:p-13,ss.c_str());
	printf("S %d\n",p+1);
	printf("- %d\n",p+2);
	printf("< %d %d\n",p+3,500+i);
	printf("+ %d %d\n",i==31?3:p-13,p+4);
	printf("C %d -%s\n",i==31?4:p-8,ss.c_str());
	printf("S %d\n",p+6);
	printf("- %d\n",p+7);
	printf("< %d %d\n",p+8,500+i);
	printf("+ %d %d\n",i==31?4:p-8,p+9);
	printf("+ %d %d\n",p+2,p+7);
	printf("C %d -1.5\n",p+11);
	printf("< %d %d\n",p+12,500);
	printf("S %d\n",p+13);
	printf("+ %d %d\n",p+14,p+14);
	printf("- %d\n",p+15);
	printf("+ %d %d\n",p+11,p+16);
	printf("< %d %d\n",p+17,i);
}
puts("> 549 500");
puts("> 554 500");
puts("+ 563 564");
puts("C 565 -1.5");
puts("< 566 500");
puts("S 567");
puts("+ 568 568");
puts("- 569");
puts("+ 570 565");
for(int i=1;i<=31;i++) printf("+ %d %d\n",570+i,i*18+4);
puts("O 602");
```

------------

测试点**8**:有**五**点难度

看起来毫无头绪。。但是我们可以利用**S()**函数的性质来做！
```
puts("I");
puts("> 1 96");
puts("C 2 -0.962423650119206894995517826848736846270368668771321039322036337680327735216443548824018858");
puts("S 3");
puts("C 4 -0.276393202250021030359082633126872376455938164038847427572910275458947907436219510058558559");
puts("< 5 95");
puts("O 6");
```

------------

测试点**9**:有**四**点难度

使用冒泡排序即可。我们令

$u=x+y$

$x=x-min(x-y,0)$

$y=u-x$

此时$x>y$，于是就解决了。**min(x-y,0)**可参考**点4**，注意最后**倒序输出**，因为我这是**由大到小**排序。
```
int node[17],p=16;
for(int i=1;i<=16;i++) puts("I"),node[i]=i;
for(int i=1;i<=15;i++)
for(int j=i+1;j<=16;j++){
	printf("+ %d %d\n",node[i],node[j]);
	printf("- %d\n",node[j]);
	printf("+ %d %d\n",node[i],p+2);
	printf("C %d 0.000000000000000000000000000001\n",p+3);
	printf("< %d 200\n",p+4);
	printf("S %d\n",p+5);
	printf("< %d 200\n",p+6);
	printf("> %d 199\n",p+3);
	printf("+ %d %d\n",p+7,p+8);
	printf("S %d\n",p+9);
	printf("< %d 1\n",p+10);
	printf("- %d\n",p+6);
	printf("+ %d %d\n",p+11,p+12);
	printf("C %d -1\n",p+13);
	printf("< %d 200\n",p+14);
	printf("- %d\n",p+15);
	printf("+ %d %d\n",node[i],p+16),node[i]=p+17;
	printf("- %d\n",node[i]);
	printf("+ %d %d\n",p+1,p+18),node[j]=p+19;
	p+=19;
}
for(int i=16;i>=1;i--)
printf("O %d\n",node[i]);
```

------------

测试点**10**:有**五**点难度

这里我采用的是朴素的做法。~~如果你想用康托展开，我也不拦着~~

读入$a,b,c$，把第二个数字$b$化为二进制，然后如果从低位到高位的第$k$位是**1**，加上$a*2^{k-1}$。这样就得到了**a×b**。

加上**0.5**后，对于取模，我们枚举$(c*2^i)<a*b$，减去。最后减去**0.5**输出即可。

如果该位为**0**，不用处理，如果是**1**，才操作。看起来不太好实现……

我在这里利用了**点4**的操作。将其减去**1**，这样不操作为**-1**，操作为**0**。然后**左移**加上**a>>180**，取**S**。此时

$0:$ $0$ 

$1:$ $a>>182+0.5$

然后**乘2**减去**对应二进制**，**左移**，就达到了目的。
```
puts("I");
puts("I");
puts("I");
puts("> 1 180");
puts("< 2 180");
for(int i=31;i>=1;i--){
	stringstream s;
	s.precision(0);
	s<<fixed<<pow(2.0L,180+i);
	string ss=s.str();ss[25]=ss[26]=ss[27]='0';
	int p=(32-i)*12-7;
	printf("C %d -%s\n",i==31?5:p-7,ss.c_str());
	printf("S %d\n",p+1);
	printf("- %d\n",p+2);
	printf("< %d %d\n",p+3,180+i);
	printf("+ %d %d\n",i==31?5:p-7,p+4);
	printf("C %d -1\n",p+2);
	printf("< %d 180\n",p+6);
	printf("+ %d %d\n",p+7,4);
	printf("S %d\n",p+8);
	printf("< %d 1\n",p+9);
	printf("+ %d %d\n",p+10,p+3);
	printf("< %d %d\n",p+11,i+181);
}
puts("> 370 180");
puts("C 378 -1");
puts("< 379 180");
puts("+ 380 4");
puts("S 381");
puts("< 382 1");
puts("- 378");
puts("+ 383 384");
puts("< 385 181");
for(int i=1;i<=31;i++) printf("+ %d %d\n",385+i,i*12+5);
puts("> 3 200");
puts("C 417 0.5");
for(int i=63;i>=0;i--){
	int p=(63-i)*15+419;
	printf("< 3 %d\n",i);
	printf("- %d\n",p+1);
	printf("+ %d %d\n",p,p+2);
	printf("< %d 500\n",p+3);
	printf("S %d\n",p+4);
	printf("C %d -1\n",p+5);
	printf("< %d 500\n",p+6);
	printf("+ %d 418\n",p+7);
	printf("S %d\n",p+8);
	printf("< %d 1\n",p+9);
	printf("- %d\n",p+5);
	printf("+ %d %d\n",p+10,p+11);
	printf("< %d %d\n",p+12,i+201);
	printf("- %d\n",p+13);
	printf("+ %d %d\n",p,p+14);
}
puts("C 1379 -0.5");
puts("O 1380");
```

------------

小结1：本题主要考验**脑洞**，(⊙o⊙)…

小结2：**S()非常重要！！！**

小结3：各测试点满分**最少节点数(min)**、**本题解节点数(node)**及**扣分情况(f+score)**

测试点7没见过539的，不确定。测试点9比官方2072少，有截图。

| 节点 | min | node| f10 | f9 | f8 | f7 | f6 | f5 | f4 | f3 | f2 | f1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 6 | 6 | 6 | 6 | 6 | 7 | 7 | 8 | 8 | 10 | 5000 | 10000 |
| 2 | 6 | 6 | 6 | 6 | 6 | 7 | 7 | 10 | 50 | 100 | 5000 | 10000 |
| 3 | 6 | 6 | 6 | 7 | 8 | 100 | 5000 | 6000 | 7000 | 8000 | 9000 | 10000 |
| 4 | 14 | 14 | 14 | 15 | 20 | 100 | 5000 | 6000 | 7000 | 8000 | 9000 | 10000 |
| 5 | 95 | 95 | 95 | 95 | 95 | 95 | 96 | 97 | 98 | 100 | 5000 | 10000 |
| 6 | 190 | 190 | 190 | 200 | 300 | 400 | 5000 | 6000 | 7000 | 8000 | 9000 | 10000 |
| 7 | 603 | 603 | 605 | 700 | 800 | 1000 | 5000 | 6000 | 7000 | 8000 | 9000 | 10000 |
| 8 | 7 | 7 | 7 | 100 | 1000 | 4000 | 5000 | 6000 | 7000 | 8000 | 9000 | 10000 |
| 9 | 1392 | 2312 | 3000 | 3500 | 4000 | 5000 | 5500 | 6000 | 7000 | 8000 | 9000 | 10000 |
| 10 | 819 | 1381 | 2000 | 2500 | 3000 | 4000 | 5000 | 6000 | 7000 | 8000 | 9000 | 10000 |

![](https://cdn.luogu.com.cn/upload/pic/18573.png)

小结4：**官方题解**，其中第10点的**fastmodmul**是**康托展开**。
```
#include <iostream>
#include <iomanip>
#include <vector>
#include <cassert>
#include <cstdio>
using namespace std;

typedef long long int64;

int n = 0;

int opadd(int i, int j)
{
    printf("+ %d %d\n", i, j);
    return ++n;
}
int opneg(int i)
{
    printf("- %d\n", i);
    return ++n;
}
int opaddc(int i, string c)
{
    printf("C %d %s\n", i, c.c_str());
    return ++n;
}
int opshl(int i, int k)
{
    printf("< %d %d\n", i, k);
    return ++n;
}
int opshr(int i, int k)
{
    printf("> %d %d\n", i, k);
    return ++n;
}
int opsig(int i)
{
    printf("S %d\n", i);
    return ++n;
}

int n_in = 0;
int opin()
{
    printf("I\n");
    return ++n;
}
int opout(int i)
{
    printf("O %d\n", i);
    return ++n;
}

struct xvar
{
    int id;

    xvar() {}
    xvar(const int &_id)
        : id(_id) {}

    friend inline xvar operator+(const xvar &lhs, const string &rhs)
    {
        return opaddc(lhs.id, rhs);
    }
    friend inline xvar operator+(const xvar &lhs, const xvar &rhs)
    {
        return opadd(lhs.id, rhs.id);
    }
    friend inline xvar operator<<(const xvar &lhs, const int &rhs)
    {
        return opshl(lhs.id, rhs);
    }
    friend inline xvar operator>>(const xvar &lhs, const int &rhs)
    {
        return opshr(lhs.id, rhs);
    }
    inline xvar operator-() const
    {
        return opneg(id);
    }
};

inline xvar sig(xvar x)
{
    return opsig(x.id);
}
inline xvar opout(xvar x)
{
    opout(x.id);
    return x;
}

inline string zeros(int n)
{
    string s;
    for (int i = 1; i <= n; i++)
        s += '0';
    return s;
}
inline string nines(int n)
{
    string s;
    for (int i = 1; i <= n; i++)
        s += '9';
    return s;
}

xvar psgn(xvar x)
{
    return sig(x << 500);
}
xvar ge0(xvar x)
{
    return psgn(x + ("0." + zeros(29) + "1"));
}
xvar ge1(xvar x)
{
    return psgn(x + ("-0." + nines(30)));
}
xvar gt1(xvar x)
{
    return psgn(x + ("-1." + zeros(29) + "1"));
}

xvar ncondx(xvar p, xvar x)
{
    const int VL = 150;
    p = p << (VL + 1);
    xvar y = sig((x >> VL) + p);
    return ((y + "-0.5") << (VL + 2)) + (-p);
}
xvar condx(xvar p, xvar x)
{
    return ncondx(-p + "1", x);
}
xvar minx0(xvar x)
{
    return ncondx(ge0(x), x);
}
xvar abs(xvar x)
{
    const int VL = 150;
    xvar p = ge0(x) << (VL + 2);
    xvar y = sig((x >> VL) + p);
    return x + ((-y + "0.5") << (VL + 3)) + p;
}

xvar land(xvar x, xvar y)
{
    return gt1(x + y);
}
xvar lor(xvar x, xvar y)
{
    return ge1(x + y);
}

xvar bits_to_x(xvar *bits)
{
    xvar x = bits[0];
    for (int i = 1; i < 32; i++)
        x = (x << 1) + bits[i];
    return x;
}
void x_to_bits(xvar x, xvar *bits)
{
    x = x << 500;

    long long t = 702955280397374434ll;
    char ts[100];
    for (int i = 31; i >= 1; i--)
    {
        sprintf(ts, "-%lld", t);
        bits[i] = sig(x + (ts + zeros(142)));
        x = x + -(bits[i] << (500 + i));
        t /= 2;
    }
    bits[0] = x >> 500;
}

xvar sqr(xvar x)
{
    const int UL = 130;
    xvar dx = x >> UL;
    xvar y = sig(dx + "-1.098612288668109691395245236922525704647490557822749451734694333637494293218608966873615754");
    y = y + -((dx >> 4) + (dx >> 3));

    //   1.31695789692481670862504634730796844402698197146751647976847225692046018541644397607421903
    // - 0.25
    // = 1.06695789692481670862504634730796844402698197146751647976847225692046018541644397607421903

    return (sig(y + "1.06695789692481670862504634730796844402698197146751647976847225692046018541644397607421903") + "-0.788675134594812882254574390250978727823800875635063438009301163241988836151466672846857700") << (UL * 2 + 7);
}

void solve1()
{
    xvar x1 = opin();
    xvar x2 = opin();
    opout(-((x1 + x2) << 1));
}
void solve2()
{
    xvar x = opin();
    opout(sig(-(x + (x << 4))));
}
void solve3()
{
    opout((psgn(opin()) << 1) + "-1");
}
void solve4()
{
    xvar x = opin();
    opout(abs(x));
}
void solve5()
{
    static xvar bits[32];
    for (int i = 0; i < 32; i++)
        bits[i] = opin();
    opout(bits_to_x(bits));
}
void solve6()
{
    xvar x = opin();
    static xvar bits[32];
    x_to_bits(x, bits);
    for (int i = 31; i >= 0; i--)
        opout(bits[i]);
}
void solve7()
{
    xvar x = opin();
    xvar y = opin();
    xvar xbits[32], ybits[32];
    x_to_bits(x, xbits);
    x_to_bits(y, ybits);

    xvar zbits[32];
    for (int i = 0; i < 32; i++)
    {
        xvar s = xbits[i] + ybits[i];
        zbits[31 - i] = s + -(psgn(s + "-1.5") << 1);
    }
    opout(bits_to_x(zbits));
}
void solve8()
{
    xvar x = opin();
    string alpha = "2.06343706889556054705";
    string sigalpha = "0.887298334620741688550198422716226773933599412474263948504833186119911079463425709202638465";
    opout((sig((x >> 200) + alpha) + ("-" + sigalpha)) << 200);
}

void solve9()
{
    xvar x[17];
    for (int i = 1; i <= 16; i++)
        x[i] = opin();
    for (int i = 1; i <= 16; i++)
        for (int j = i + 1; j <= 16; j++)
        {
            xvar s = x[i] + x[j];
            x[i] = x[i] + minx0(-x[i] + x[j]);
            x[j] = s + -x[i];
        }
    for (int i = 1; i <= 16; i++)
        opout(x[i]);
}

xvar modadd(xvar a, xvar b, xvar ma, xvar negm)
{
    xvar s = a + b;
    return s + ncondx(psgn(-s + ma), negm);
}
xvar modmul(xvar a, xvar b, xvar m, xvar negm)
{
    xvar ta[32];
    xvar tb[32];
    x_to_bits(a, ta);
    x_to_bits(b, tb);

    xvar zero = a >> 1000;
    xvar ma = m + "-0.1";
    a = ta[31];
    a = a + ncondx(psgn(-a + ma), negm);
    for (int i = 30; i >= 0; i--)
    {
        a = a + a + ta[i];
        a = a + ncondx(psgn(-a + ma), negm);
    }

    xvar res = zero;
    res = condx(tb[0], a);
    res = res + ncondx(psgn(-res + ma), negm);

    a = a + a;
    a = a + ncondx(psgn(-a + ma), negm);
    for (int i = 1; i < 32; i++)
    {
        res = res + condx(tb[i], a);
        res = res + ncondx(psgn(-res + ma), negm);

        if (i < 31)
        {
            a = a + a;
            a = a + ncondx(psgn(-a + ma), negm);
        }
    }
    return res;
}

xvar fastmodmul(xvar a, xvar b, xvar m)
{
    xvar ab = sqr(a + b);
    ab = ab + -sqr(a);
    ab = ab + -sqr(b);
    ab = ab + "0.2";
    ab = -ab;
    ab = ab << 149;
    for (int i = 63; i >= 0; i--)
    {
        const int VL = 300;

        xvar mi = m << (150 + i);
        xvar p = sig(mi + ab) << (VL + 1);
        xvar y = sig((mi >> VL) + p);
        ab = ab + ((y + "-0.5") << (VL + 2)) + -p;
    }
    ab = ab >> 150;
    ab = -ab + "-0.1";
    return ab;
}

void solve10()
{
    xvar a = opin(), b = opin(), m = opin();
    //opout(modmul(a, b, m, -m));
    opout(fastmodmul(a, b, m));
}

int main(int argc, char **argv)
{
    freopen("nodes1.out", "w", stdout);
    n = 0, solve1();
    freopen("nodes2.out", "w", stdout);
    n = 0, solve2();
    freopen("nodes3.out", "w", stdout);
    n = 0, solve3();
    freopen("nodes4.out", "w", stdout);
    n = 0, solve4();
    freopen("nodes5.out", "w", stdout);
    n = 0, solve5();
    freopen("nodes6.out", "w", stdout);
    n = 0, solve6();
    freopen("nodes7.out", "w", stdout);
    n = 0, solve7();
    freopen("nodes8.out", "w", stdout);
    n = 0, solve8();
    freopen("nodes9.out", "w", stdout);
    n = 0, solve9();
    freopen("nodes10.out", "w", stdout);
    n = 0, solve10();

    return 0;
}
```

---

## 作者：ljc1301 (赞：32)

这是一个通过后能有很大成就感的题（至少我这么认为，我参考了很多题解才做出来）。

本文的代码（我自认为）比较容易理解，我写了个结构体，也重载了操作符，这个模板放在文章末尾。**下文中所有代码均写在这个模板的后面。**

#### 本文（我自认为）最大的亮点：详细说明了任务8中参数的计算过程。

#### 若有觉得我说的有问题、您不理解，或者有建议或意见，或有些地方我没找到好的证明、解释等，您找到了，欢迎在评论区提出。

下面开始讲正题。

**提示：下面公式中，左移、右移的优先级更高。**

## 任务1

注意到$-2a-2b=-2(a+b)$，这就简单了。代码：
```cpp
out(-(in()+in())<<1);
```
（是不是很简洁）

共用6个节点。

## 任务2

注意到$s(x)=\frac{1}{1+e^{-x}}$，那么$\frac{1}{1+e^{17a}}=s(-17a)$

考虑17a怎么算。一个直观的方法就是加17次，可节点太多。注意到$17=2^4+1$，那这个问题还是好解决的，$17a=(a<<4)+a$。代码：
```cpp
node x=in();
out(s(-(x+(x<<4))));
```
共用6个节点。

## 任务3

这个任务似乎不用扣分节点很难做，因为都是一些基本的运算。如果您这么想，可能忽略了两个东西。

1. 你构造的计算机的输出中的某个值与预期的输出值相差超过$10^{-9}$（似乎这没啥用……）
2. 

![](https://cdn.luogu.com.cn/upload/pic/2394.png)

$s(x)$的图像！注意到

当$x \to +\infty$，$s(x) \to 1$

当$x=0$，$s(x)=1/2$

当$x \to -\infty$，$s(x) \to 0$

所以可以考虑给$a$乘上一个大常数（如$2^{500}$），那$2 \cdot s(a)-1$会很接近答案。问题解决了！代码：
```cpp
out((s(in()<<500)<<1)+"-1");
```
共用6个节点。

## 任务4

感觉还是不太好做，但感觉$s$特别有用，它能在不同范围得到不同的结果，不过此话怎讲？

考虑$s(x)$在$x$接近0的取值。注意到导数的定义：

$s'(x_0)=\lim_{x \to x_0} \frac{s(x)-s(x_0)}{x-x_0}$

那么有$s(x)\approx s(x_0)+(x-x_0)s'(x_0)$

求一下$s'(x)$

$\mathrm{d}s(x)=\mathrm{d} (1/(1+e^{-x}))$

$=-1/\left(1+e^{-x}\right)^2\mathrm{d}(1+e^{-x})$

$=-e^{-x}/\left(1+e^{-x}\right)^2\mathrm{d}(-x)$

$=e^{-x}/\left(1+e^{-x}\right)^2\mathrm{d}x$

$\therefore s'(x)=\frac{\mathrm{d}}{\mathrm{d}x}s(x)=e^{-x}/\left(1+e^{-x}\right)^2$

$\therefore\ $当$x$接近0时，$s(x)\approx s(0)+x\cdot s'(0)=\frac{1}{2}+\frac{1}{4}x$

此时$s$可以当作一次函数来用！直接强行构造……

$\because\ $当$a\geqslant0$时，$\left|a\right|=a$；当$a<0$时，$\left|a\right|=a-2a$

考虑$a\geqslant0$时把$a$干掉，比如设$p=s((a+10^{-30})<<500)<<152$（加了一个很小的数避免在$a=0$时产生误差），这时就可以再设$y=s(a>>150+p)$，此时，当$a\geqslant0$时，$y=1$；当$a<0$时，$y=a>>152+1/2$，答案也可以构造了。$\left|a\right|=a+(-(y-1/2)<<153)+p$，是不是很神奇！请您自己验证它的正确性。

代码：
```cpp
node a=in(),p,y;
p=s((a+"0.000000000000000000000000000001")<<500)<<152;
y=s(p+(a>>150));
out(a+(-(y+"-0.5")<<153)+p);
```
共用14个节点。

## 任务5

前面似乎有些难，说个简单的。这个测试点直接加乘即可，注意不要进行没用的操作（比如把最后一位左移0位）。代码：
```cpp
node x[32],ans;
int i;
for(i=31;i;i--)
    x[i]=in()<<i;
ans=in();
for(i=31;i;i--)
    ans=ans+x[i];
out(ans);
```
共用95个节点。

## 任务6

先写个伪代码。（接下来直接用我原先的代码了，可能变量名有些不一样）

这里用x代替a
```cpp
x=in();
for(i=31;i>=0;i--)
{
    if(x>=(1<<i)) b[i]=1;
    else b[i]=0;
    out(b[i]);
    x=x+(-(b[i]<<i));
}
```
主要难的地方在于有分支，但根据前面的经验，这个还是好做的，$b[i]=s((x-(1<<i)+eps)<<500)$注意要卡常，比如将$x<<500$代替$x$（注意$(-(1<<i)+eps)<<500=-(1<<(i+500)-eps<<500)$要直接算），最后b[0]就是剩下的x>>500。代码：
```cpp
node x=in()<<500;
int i,len;
char str[1000];
for(i=31;i;i--)
{
    str[0]='\0'; len=sprintf(str,"-%.0Lf",powl(2,i+500)); // 提示：计算2的幂用浮点数精度不会低
    str[len-1]='0'; str[len-2]='0'; str[len-3]='0';
    str[len-4]='0'; str[len-5]='0'; str[len-6]='0';
    // 提示：减eps就直接把后几位设成0即可
    x=x+(-out(s(x+str))<<(500+i));
}
out(x>>500);
```
共用190个节点。

## 任务7

把前两个任务结合，再考虑每一个二进制位如何处理。设两位的数字为a和b。则

$a\ \mathrm{xor}\ b=a+b-2\cdot[a+b>1.5]$

有没有感觉很像套路？就直接算$s((a+b-1.5)<<500)$即可。代码：
```cpp
int i,len;
char str[1000];
node a[32],b[32],c[32],x;
for(i=31,x=in()<<500;i;i--)
{
    str[0]='\0'; len=sprintf(str,"-%.0Lf",powl(2,i+500));
    str[len-1]='0'; str[len-2]='0'; str[len-3]='0';
    str[len-4]='0'; str[len-5]='0'; str[len-6]='0';
    x=x+(-(a[i]=s(x+str))<<(500+i));
}
a[0]=x>>500;
for(i=31,x=in()<<500;i;i--)
{
    str[0]='\0'; len=sprintf(str,"-%.0Lf",powl(2,i+500));
    str[len-1]='0'; str[len-2]='0'; str[len-3]='0';
    str[len-4]='0'; str[len-5]='0'; str[len-6]='0';
    x=x+(-(b[i]=s(x+str))<<(500+i));
}
b[0]=x>>500;
for(i=31;i>=0;i--)
{
    x=a[i]+b[i];
    c[i]=x+-(s((x+"-1.5")<<500)<<1);
}
for(i=31;i;i--)
    c[0]=c[0]+(c[i]<<i);
out(c[0]);
```
共用603个节点。

## 任务8

还是看$s$。我们已经知道$s$可以当一个一次函数，只要算出斜率为0.1的点，或者精度高些，取斜率为0.2的点，结果再除2。设解出来$s'(x_0)=0.2$，那么答案就是$(s((in()>>96)+x_0)-s(x_0))<<95$

现在思考如何求$x_0$。我们前面已经算出$s'(x)=e^{-x}/\left(1+e^{-x}\right)^2$，设$t=e^{-x_0}$，那么有

$t/(1+t)^2=1/5$

$5t=(1+t)^2$

$t^2-3t+1=0$

$t_{1,2}=\frac{3\pm\sqrt{5}}{2}$

取一个解，比如$t=\frac{3+\sqrt{5}}{2}$

那么$s(x_0)=1/(1+e^{-x})=1/(1+t)=1/(1+(3+\sqrt{5})/2)$，分母有理化得$s(x_0)=(5-\sqrt{5})/10$

那$x_0$怎么求？理论上直接求$-\ln t$即可，但我不会算$\ln$……不过直接二分答案，就把问题转换成求$e^x$了。考虑泰勒展开：

$e^x=1+x+x^2/2!+x^3/3!+...$

还有个问题，高精度小数怎么求？人生苦短，我用python！但小数怎么办？考虑乘上一个base（我取的是$10^{200}$）。代码（注意，我用的是python 2.x，没有python或是3.x的就直接用Luogu IDE的python2即可）：
```python
def exp(x):
    res=base
    t=x
    for i in range(2,100):
        res+=t
        t=t*x//i//base
        if not t: break
    return res

base=10**200 #这是10^200
l,r=base*2,base*3
while l<r: # 二分根号5
    mid=(l+r)//2
    if mid*mid<5*base*base:
        l=mid+1
    else: r=mid
sqrt5=l
l,r=-base,0
# 下面是我原先的代码，懒得改了，因为乘一下就知道-ln(t_0)=ln(t_1)，所以我直接求(3-根号5)/2了
while l<r:
    mid=(l+r)//2
    if exp(mid)<(3*base-sqrt5)//2:
        l=mid+1
    else: r=mid
print l # x0
print (5*base-sqrt5)//10 # s(x0)
```
求出来后就差不多了。代码：
```cpp
out((s((in()>>96)+"-0.962423650119206894995517826848736846270368668771321039322036337680327735216443548824018858")+"-0.276393202250021030359082633126872376455938164038847427572910275458947907436219510058558559")<<95);
// 第一个数是x0，第二个数是-s(x0)，取前90位。
```
共用7个节点。

## 任务9

考虑冒泡排序，可以这样写（其中min表示和0取min）：
```cpp
for(i=1;i<16;i++)
    for(j=0;j+i<16;j++)
    {
        x=a[j]+a[j+1];
        a[j]=a[j]+min(a[j+1]+-a[j]); // 取a[j]和a[j+1]的min
        a[j+1]=x+-a[j];
    }
```
这min怎么实现呢？可以用任务4的思路。p和y的定义类似，$p=s((a+10^{-30})<<500)<<151$，$y=s(a>>150+p)$，答案为$((y-1/2)<<152)-p$，请您自己验证它的正确性。min的实现：
```cpp
inline node min(const node &x)
{
    node p,y;
    p=s((x+"0.000000000000000000000000000001")<<500)<<151;
    y=s(p+(x>>150));
    return ((y+"-0.5")<<152)+-p;
}
```
共用2072个节点。

其实还可以bitonic sort（不过我没找到关于Batcher定理的证明，我自己还没想出怎么证，找到的欢迎在评论区跟我说一声），这里简单介绍一下，如果有说的不明白的可以自己在网上找。

定义：一个序列$a_1,a_2,\cdots,a_n$是双调序列(Bitonic Sequence)，当且仅当序列能够循环移位满足，存在一个$k(1\leqslant k\leqslant n)$, 使得$a_1\leqslant a_2 \leqslant \cdots\leqslant a_{k-1} \leqslant a_k \geqslant a_{k+1} \geqslant\cdots\geqslant a_{n-1} \geqslant a_n$成立。

Batcher定理：将任意一个长为2n的双调序列A从中间切成两半，分成等长的两个序列X和Y，然后X和Y相同位置的元素xi与yi比较，小的放到Min序列，大的放到Max序列。由此得到的Max序列和Min序列也是双调序列，且Min序列的每个元素小于或等于Max序列的每个元素。

根据这个定理，我们可以把一个序列写变成双调序列，然后按照这个定理的内容，将长度为2n双调序列$a_1,a_2,\cdots,a_{2n}$，比较$a_i$与$a_{i+n}$，然后把较小的放到$a_i$，把较大的数放到$a_{i+n}$，这样$a_1,a_2,\cdots,a_n$是一个双调序列，$a_{n+1},a_{n+2},\cdots,a_{2n}$也是一个双调序列，就可以继续对这两个双调序列进行排序。

怎么把一个序列写变成双调序列呢？把前一段按升序排序，后一段按降序排序即可（降序的时候把较大的放到$a_i$，把较小的数放到$a_{i+n}$）。

这个排序的时间复杂度：

把双调序列排序的时间复杂度可以表示为$T(n)=2T(\frac{n}{2})+O(n)$，$T(1)=1$，求得$T(n)=O(n\log n)$

把序列排序的时间复杂度可以表示为$T(n)=2T(\frac{n}{2})+O(n\log n)$（其中$O(n\log n)$是把双调序列排序的时间复杂度），求得$T(n)=O(n\log^2 n)$

代码：
```cpp
// min的定义同上
void merge(node *a,int mid,bool flag)
{
    if(!mid) return;
    int i;
    node t;
    for(i=0;i<mid;i++)
        if(flag)
        {
            t=a[i]+a[i|mid];
            a[i|mid]=a[i|mid]+min(a[i]+-a[i|mid]);
            a[i]=t+-a[i|mid];
        }
        else
        {
            t=a[i]+a[i|mid];
            a[i]=a[i|mid]+min(a[i]+-a[i|mid]);
            a[i|mid]=t+-a[i];
        }
    merge(a,mid>>1,flag);
    merge(a+mid,mid>>1,flag);
}
void bitonic_sort(node *a,int mid,bool flag)
{
    if(!mid) return;
    bitonic_sort(a,mid>>1,0);
    bitonic_sort(a+mid,mid>>1,1);
    merge(a,mid,flag);
}

node a[16];
int i;
for(i=0;i<16;i++)
    a[i]=in();
bitonic_sort(a,8,0);
for(i=0;i<16;i++)
    out(a[i]);
```
共用1392个节点。

## 任务10

正解的二项式展开完全看不懂……

先处理乘。打一个快速乘即可。然后倍增做取余，$ans=ans+(-[m<<i<=ans]\cdot(m<<i))$，$[m<<i<=ans]=s((ans-m<<i+0.5)<<500)$。

还剩下一个问题，怎么算a乘b（其中a=0或1）？还是按那个思路，$p=(a-1)<<151$，$y=s(p+b>>150)$，$a\cdot b=((y-1/2)<<152)-p$，请您自己验证它的正确性。代码：

```cpp
inline node operator *(const node &a,const node &b) // a = 0 or 1
{
    node p,y;
    p=(a+"-1")<<151;
    y=s(p+(b>>150));
    return ((y+"-0.5")<<152)+-p;
}

node x=in()<<500,a[32],m,ans,t;
int i,len;
char str[1000];
for(i=31;i;i--)
{
    str[0]='\0'; len=sprintf(str,"-%.0Lf",powl(2,i+500));
    str[len-1]='0'; str[len-2]='0'; str[len-3]='0';
    str[len-4]='0'; str[len-5]='0'; str[len-6]='0';
    x=x+(-(a[i]=(s(x+str)))<<(500+i));
}
a[0]=x>>500;
x=in(); m=in();
ans=a[0]*x;
for(i=1;i<32;i++)
    ans=ans+a[i]*(x<<i);
for(i=63;i>=0;i--)
{
    if(i) t=-(m<<i);
    else t=-m;
    ans=ans+(s((ans+t+"0.5")<<500)*t);
}
out(ans);
```
共用1534个节点。

## 模板

（包含了所有不扣分节点，不要骂我不直接用int，我觉得这样直观）
```cpp
int tot=0;
struct node
{
    int num;
    node() { num=-1; }
    node(int num):num(num) {}
};
inline node in() //输入节点
{
    printf("I\n");
    return node(++tot);
}
inline node out(const node &no) //输出节点
{
    printf("O %d\n",no.num);
    return node(++tot);
}
inline node operator +(const node &a,const node &b) // 加法节点
{
    printf("+ %d %d\n",a.num,b.num);
    return node(++tot);
}
inline node operator +(const node &a,const char *s) // 偏移节点
{
    printf("C %d %s\n",a.num,s);
    return node(++tot);
}
inline node operator -(const node &a) // 取反节点
{
    printf("- %d\n",a.num);
    return node(++tot);
}
inline node operator <<(const node &a,const int &k) // 左移节点
{
    printf("< %d %d\n",a.num,k);
    return node(++tot);
}
inline node operator >>(const node &a,const int &k) // 右移节点
{
    printf("> %d %d\n",a.num,k);
    return node(++tot);
}
inline node s(const node &a) // S型节点
{
    printf("S %d\n",a.num);
    return node(++tot);
}
```

---

## 作者：litble (赞：22)

# 前言

**litble可爱吗？**([可爱](https://blog.csdn.net/litble/article/details/80522567)/[不可爱](http://www.k-xzy.xyz/archives/5538))

皮一下我很开心，不过上面两个链接其实是我两个写blog的地方，造数据的代码和数据什么的可以去那里查看，这里就不放代码和具体数据，只讲思路咯。

# test3

可以利用一下精度的性质。

我们可以将这个a乘以一个很大很大的数，这样，如果它是0，那么S一下的结果就是0.5，如果它大于0，那么S一下就是1，如果小于0就是0.

然后脑补一下怎么把这三个结果处理成-1,0,1的形式就成了。

# test4

MAYA这是人做的点吗？Orz VFK太强啦！

考虑利用一下求导的基本手法（虽然咸鱼不会求导），得知当x的绝对值非常小时，s(x)可以近似看作$\frac{x}{4}+0.5$。

假定这个性质在这个test里面是会被用到的，人类的第六感告诉我们，负数要用这个性质的可能性更大。所以我们先尝试构造一个数$p$，使得当x为正的时候，$p$非常大（因为这个非常大一般构造为$2^{k_1}$的形式，所以我们姑且认为此时$p=2^{k_1}$）。而x为负的时候，$p=0$。

然后我们令$y=s(\frac{x}{2^{k_2}}+p)$，这样当x为正的时候，$y=1$，否则$x=0.5+\frac{x}{2^{k_2+2}}$。

这有什么好处呢？$(0.5-y)*2^{k_2+3}=-2x$，于是我们就把负数这部分搞完了。

而如果x是正数的话，这样操作以后的结果就是：$-2^{k_2+2}$，我们就要试图把这个东西搞掉。

想起有一个数在x为负数时是0而在x是正数时不是，那就是$p$，所以我们加上一个p要使得$-2^{k_2-2}=0$。

那么使得$k_1=k_2+2$即可。

至于$p$怎么构造呢，VFK给出的代码已经说了：

```cpp
In(x);
p=S((x+1e-30)<<500)<<152;//加上1e-30是为了处理0
y=S((x>>150)+p);
r=x+((-y+0.5)<<153)+p;
Out(r);
```

# test5

比较简单，直接模拟就好。注意不要进行无效操作（比如将$a_{32}$左移0位啦）

# test6
思路：每次计算一下$S((x-2^{k})*2^{500})$，就可以获得0和1。

但是每次都左移500位非常浪费节点，可以一开始将x左移500位，然后每次用高精度算出$2^{500+k}$。

这样我们每次求一位，要C一次，S一次,O一次。然后继续变形x，减去其最高位，假设这一位是t（t=0或1),那就是要左移一次t,一次t，x再加上一次-t，一共要进行6次操作。

注意到最后一位可以直接将x右移500位变回来然后输出，就可以节约一点点操作，正好190个节点。

**但是这样写了会WA**，因为如果某一次$x==2^{k}$，那么就算乘极大数最后结果也是0，$S(0)=0.5$。

所以我们要把$2^{k}$稍微弄小一点点，这样如果$x==2^{k}$算出来就是1了。

# test7
思路：首先使用上面那种方法，将两个数的二进制转化出来。由于不用输出，所以一共消耗316个节点，剩余平均每次异或可以使用9个节点。

观察什么叫做异或，发现当这两位加起来为1的时候，结果为1。加起来为2或者为0，结果都是0.设这个和为y.

那么怎么把这个2搞成0呢？显然我们是要利用2比较大这个性质，让某一个东西去减去y.

那么就是用S构造一个当输入1和2的时候输出1，否则输出0的东西。

也就是求一下$S((y-0.5)\times 2^{500}) \times 2-y$。

数一下发现正好是9次操作，由于左移0位没有意义之类的，我们还可以节约几次操作呢。

# test8
呃，根据求导的特性，当x很小的时候，拟合一种斜率，使得$\frac{S(x)-S(0)}{x}=0.1$，就可以很方便地解决该题。

那么我们把x除以一个很大的数，然后再加上一个数k，现在我们求使得$\frac{S(k)-S(0)}{k}=0.1$成立的k，就可以近似算出$0.1k+0.1 \times \frac{x}{2^{d}}$了。

如何求这个k呢？考虑利用checker三分法求解。

虽然这样理论可行，但是我太菜了愣是搞了一个小时没搞出来。

# test9

使用冒泡排序。

比较两个数a,b，使小的在前，大的在后，出题人已经构造了一种方法：

```cpp
t=a+b;
a=min(b-a,0)+a;
b=t-a;
```

然后这个`min(x,0)`的做法可以参照第4个测试点：

```cpp
p=S((x+1e-30)<<500)<<152;
y=S((x>>150)+p);
r=(((y-0.5)<<153)-p)>>1;
```

# test10
考虑用一个类似于快速幂的“快速乘”来实现。

那么首先把b转化为2进制，然后如果这一位是1，就加上$a \times 2^k$。
考虑用一个类似于test4的方法来实现这个功能。

设bk为b的第k位，先算出`y=S((bk-1)<<500)+(a>>150));`，如果bk=0，则y=0,否则$y=\frac{a}{2^{152}}+\frac{1}{2}$。

然后算`r=(y*2-bk)<<151`，这样如果bk=0就是0，否则就是a，就可以很方便地计算了。

至于取模，可以利用test3的那个函数，$a-m*2^k$大于0时等于1，否则等于0.然后等于1时减$m*2^k$，否则减0，利用以上操作实现。

# 总结

~~哈哈哈哈我没疯放开我我怎么可能做一道旷野造计算机就疯了呢哈哈哈哈~~

真爱生命，远离旷野大计算。



---

## 作者：littlez_meow (赞：6)

我的一次伟大的尝试。

有一说一，这道题和游戏《[A=B](https://www.bilibili.com/video/BV11T4y1Z73m)》好像。

[题目指路](https://www.luogu.com.cn/problem/P1737)

## 前言

让我们看看有哪些可用操作吧！

对三个扣分节点不予理睬，除了正常的输入输出、变量和常量加法、变量取反、乘或除以 $2$ 的幂，还有一个我们不常见的东西—— 函数 $s(x)$。

既然题面都给了我们 $s(x)$ 的图像，不如来研究一下它的性质。依照宇宙惯例，各位 dalao 可以跳过。

$$s(x)=\dfrac 1{1-e^{-x}}$$

![s(x)](https://cdn.luogu.com.cn/upload/image_hosting/f8ukode7.png)

【性质 1】
$s(x)$ 过点 $(0,\frac 1 2)$

证明：当 $x=0$ 时，$y=\frac 1 2$。

证毕

【性质 2】
$s(x)+s(-x)=1$

证明：$s(x)+s(-x)=\dfrac 1{1-e^{-x}}+\dfrac 1{1-e^x}=\dfrac{1-e^{-x}+1-e^{-x}}{1-e^{-x}-e^x+1}=1$

证毕

【性质 3】
$\lim\limits_{x\to\infty}s(x)=1,\lim\limits_{x\to-\infty}s(x)=0$

证明：$\lim\limits_{x\to\infty}s(x)=\frac{1}{1-0}=1$

$\lim\limits_{x\to-\infty}s(x)=\lim\limits_{x\to-\infty}\frac 1 x=0$

证毕

事实上，函数 $s(x)$ 被称为 Sigmoid 函数。因为它的值域为 $[0,1]$，且拥有性质 3，让它在神经网络中广泛运用。

最后碎碎念一下，题目里的输入有个小陷阱，只有 $i,j$ 是前面的节点计算出的值，$x,k$ 是常数可以直接带数进去。

下面，进入正题。

## task 1
### 概况
输入：$a,b$

输出：$-2a-2b$

难度：受精卵

### 分析

$-2a-2b=-2(a+b)=-(a+b)\times2^1$

两行输入，一行加法，一行左移，一行取反，一行输出

### 代码
共 $6$ 行
```cpp
printf("I\n");
printf("I\n");
printf("+ 1 2\n");
printf("< 3 1\n");
printf("- 4\n");
printf("O 5\n");
```
## task 2
### 概况
输入：$a$

输出：$\dfrac 1{1+e^{17a}}$

难度：满月
### 分析

一看这个式子，很像 $s(x)$ 的式子。

这辈子不可能用乘法的，但怎么求 $17a$ 呢？

$17a=16a+a=a\times 2^4+a$

所以 $\dfrac 1{1+e^{17a}}=s(-(a\times 2^4+a))$

一行输入，一行左移，一行加法，一行取反，一行 $s(x)$，一行输出。
### 代码
共 $6$ 行
```cpp
printf("I\n");
printf("< 1 4\n");
printf("+ 1 2\n");
printf("- 3\n");
printf("S 4\n");
printf("O 5\n");
```
## task 3
### 概况
输入：$a$

输出：$\left\{\begin{array}{ll}
-1 & a<0 \\
0 & a=0 \\
1 & a>0
\end{array}\right.$

难度：幼升小
### 分析
突然就难起来了。

虽然那个比较函数很诱人，但用一个四分没了。

回想上一题，那个函数 $s(x)$ 只在那里有用，其它地方都用不上，好可怜。

……吗？

你看它的数据范围，整数部分一千位，小数部分九十位，谁没事会想写高精度呢？就连 spj 都只精确到小数点后九位。

再想想实数乘法法则，任何一个数乘以一个很大的正数，绝对值变得很大，符号不变。这个很大的整数很容易通过左移得到。

换句话说，我们要构造一个函数 $f_3(x)$，满足：

1. $\lim\limits_{x\to \infty} f_3(x)=1$

2. $\lim\limits_{x\to -\infty} f_3(x)=-1$

3. $f_3(0)=0$

数感好的同学已经发现，$f(x)=2s(x)-1$，满足题意！

接下来就要决定那个非常非常大的正数取 $2$ 的多少次方了。

列出不等式

$\left\{\begin{array}{ll}
\dfrac 1{1+e^{x_1}}\ge 1-5\times 10^{-91} \\
\dfrac 1{1+e^{x_2}}\le 4\times 10^{-91} \\
|x_1|\le 10^{1000} \\
|x_2|\le 10^{1000}
\end{array}\right.$

其中，$x_1=10^{-9}\times 2^k,x_2=-10^{-9}\times 2^k$，以及 $k$ 为正整数。

借助某些工具，解得 $k\ge 38$。

当然，考试的时候可没有工具解。可以拿 python 跑二分。不过更好的方案是带一个较大的数进 $k$，比如 $100$。

综上，$f_3(x)=\dfrac 2{1+e^{-a\times 2^{100}}}-1$

顺带一提，$f(x)$ 的图像长这样：

![task3](https://cdn.luogu.com.cn/upload/image_hosting/q9efl62k.png)

一行输入，一行左移，一行 $s(x)$，一行左移，一行偏移，一行输出。
### 代码
共 $6$ 行
```cpp
printf("I\n");
printf("< 1 100\n");
printf("S 2\n");
printf("< 3 1\n");
printf("C 4 -1\n");
printf("O 5\n");
```
## task 4
### 概况
输入：$a$

输出：$|a|$

难度：小学奥数
### 分析
上面那一问的结果乘以 $a$，就是这一问的结果。但是我说过乘法节点这辈子不会用的。

让我们试图模仿一下。

$|x|=\left\{\begin{array}{ll}
-x & x<0\\
0 & x=0\\
x & x>0
\end{array}\right.$

直接求肯定不现实，我们考虑把它写成 $x$ 加一个数的形式，就变成

$|x|=\left\{\begin{array}{ll}
x-2x & x<0\\
x+0 & x\ge 0
\end{array}\right.$

也就是说，我们要求 $f_4(x)=\left\{\begin{array}{ll}
-2x & x<0\\
0 & x\ge 0
\end{array}\right.$

回头看看 $s(x)$ 的图像，发现 $x$ 在 $0$ 附近很像一个一次函数。求个导会得出 $x=0$ 处的切线解析式为 $y=\frac 1 4 x+\frac 1 2$。

至于如何缩小，我们可以使用 $\lim\limits_{y\to\infty}s(\frac x y)$，其中 $y=2^q$。

接下来，我们就需要把正负分开。上一问中，我们使用了 $s(x)$ 的极限，这一问仍然考虑使用。

我们需要使用偏移，使结果对于自变量正负显著不同。

这个偏移肯定要用到 $s(x)$。

你看那个系数 $2$ 和拟合一次函数的系数 $\frac 1 4$，一切都在告诉我们，用左右位移的指数差来构造。

这个偏移要在大于 $0$ 时很大，在小于 $0$ 时很小。好像 $h=s(x\times 2^p)\times 2^q$ 正好是！

$h=\left\{\begin{array}{ll}
0 & x<0\\
2^p & x\ge 0
\end{array}\right.$

加在 $s(x\times 2^{-q})$ 上，有

$s(x\times 2^{-q}+h)=\left\{\begin{array}{ll}
s(x\times 2^{-q}) & x<0\\
1 & x\ge 0
\end{array}\right.$

再看导数拟合的一次函数，$s(x\times 2^{-q})=\frac 1 4 x\times2^{-q}+\frac 1 2$，也就是 $x\times 2^{-(q+2)}+0.5$。

在 $x<0$ 时，$f_4(x)$ 似乎就是上面那玩意减 $0.5$ 乘 $2^{q+3}$ 再取反的结果。拿 $x>0$ 验证一下。

当 $x>0$ 时，减 $0.5$ 乘 $2^{q+3}$ 再取反的结果为 $-2^{q+2}$，和要求不一样，怎么办？用偏移？

我们现在还拥有一个正负敏感的变量——$h$！只要取 $p=q+2$，再给上式加 $p$，完美解决！但是，$0$ 呢？

由于 $0$ 和正数处理方法一样，可以把 $x$ 加上一个 spj 和输入精度以外、计算过程精度以内的数，也就是 $10^{-10}$，但为了保险，建议更小一些，比如 $10^{-20}$。

范围懒得算了，想算自己算吧，我就取 $250$ 了。不放图了，画的时候电脑炸了。

### 代码
共 $14$ 行
```cpp
printf("I\n");
printf("C 1 0.00000000000000000001\n");
printf("< 2 250\n");
printf("S 3\n");
printf("< 4 250\n");
printf("> 1 248\n");
printf("+ 6 5\n");
printf("S 7\n");
printf("C 8 -0.5\n");
printf("< 9 251\n");
printf("- 10\n");
printf("+ 11 5\n");
printf("+ 12 1\n");
printf("O 13\n");
```

## task 5
### 概况
输入：$a_1,a_2,\cdots,a_{32}$ 

输出：把 $a_1,a_2,\cdots,a_{32}$ 从左到右看成一个二进制整数，高位在左，低位在右，输出该整数的值。

难度：小升初

### 分析
众所周知，小升初试题难度比小学奥数简单。

很简单，每个数按权值位移最后相加就完了。

但是，请不要为了循环美观去乘 $2^0$，会浪费一行。

输入三十二行，左移三十一行，相加三十一行，输出一行。

### 代码
共 $95$ 行

对了，下文所有代码中 ```F(i,a,b) R(i,a,b)``` 分别指 ```for(int i=a;i<=b;++i) for(int i=a;i>=b;--i)```。

```cpp
F(i,1,32) printf("I\n");
F(i,1,31) printf("< %d %d\n",i,32-i);
printf("+ 63 32\n");
F(i,1,30) printf("+ %d %d\n",63+i,32+i);
printf("O 94\n");
```

## task 6
### 概况
输入：$a$

输出：$32$ 个整数，从高位到低位输出 $a$ 的二进制表示（不足 $32$ 位的在高位补 $0$）

难度：中考

### 分析
难度又加回来了，但也没 task 4 难。

二进制下的数 $a$ 有个神奇的性质，若它至多有 $t$ 位，则第 $t$ 位为 $[a\ge2^t]$（方括号表示成立为 $1$，不成立为 $0$）。

然后，我们让 $a'=a-2^t\times[a\ge2^t]$，那么 $a'$ 就是一个至多 $t-1$ 位的数，可以重复上面操作。

问题就回到了比较大小。看看第三个点，不正是比较大小的问题吗？把 $a$ 乘上 $2^{50}$，用 $s(x)$ 就行。

再看每次用 $s(x)$ 的位移，用分配律可以提出来，直接在开始时位移 $a$ 就可以了。

然后是和 task 4 一样严峻的问题，如果相等减出 $0$ 来，那值就成 $0.5$ 了，误差不是一点半点。一样，偏移个 $10^{-10}$。

等等，你看循环里那么多偏移，为什么偏偏要专门在开头时浪费一行偏呢？我们每次偏移少偏一点，同样可以解决问题。因此，把偏移少偏个 $2^{50}\times 10^{-10}\approx 112590$。

最后，因为是正整数，最低位不用比，直接就是。

三十一次比较，每次六行，输入一行，左右偏移各一行，输出一行

解决！

### 代码
共 $190$ 行
```cpp
printf("I\n");
printf("< 1 50\n");
for(int i(3),j(31);j;--j,i+=6){
	char str[1001];
	sprintf(str,"%Lf",pow((long double)2.0,50+j)-112590);
	printf("C %d -%s\n",i-1,str);
	printf("S %d\n",i);
	printf("O %d\n",i+1);
	printf("- %d\n",i+2);
	printf("< %d %d\n",i+3,50+j);
	printf("+ %d %d\n",i+4,i-1); 
}
printf("> 188 50\n");
printf("O 189\n");
```

## task 7
### 概况
输入：$a,b$

输出：$a,b$ 按位异或的结果（下记为 $\operatorname{xor}$）

难度：高中

### 分析
task 5 和 task 6 的综合运用！

首先用 task 6 的代码转二进制，异或后再用 task 5 的代码转回来。

也就是说，目前首要目标为解决函数 $f_7(x,y)$，其中

$\forall x,y\in\{0,1\},f_7(x,y)=\left\{\begin{array}{ll}
0 & x=y\\
1 & x\neq y
\end{array}\right.$

我相信你们老师或教练都讲过，异或是二进制下的不进位加法，不信你看：

$0\operatorname{xor}0=0+0=0$

$0\operatorname{xor}1=1\operatorname{xor}0=0+1=1$

$1\operatorname{xor}1=(1+1)\bmod 2=0$

自然而然想到加法。

但是，加法在 $f_7(0,1)$ 或 $f_7(1,0)$ 没问题，但对于 $f_7(0,0)$ 和 $f_7(1,1)$ 就完了，一个是 $0$ 一个是 $2$。

结合 task 4 的经验，我们给 $x+y$ 减一个数，得到 $f_7(x,y)$。

让我们记这个数为 $f_7'(x,y)$，则有

$f_7'(x,y)=\left\{\begin{array}{ll}
0 & x+y=0\\
0 & x+y=1\\
2 & x+y=2
\end{array}\right.$

你看那个 $2$，是不是很不顺眼，把它除掉，只剩 $0$ 和 $1$，函数 $s(x)$ 又出来了。

再仔细看看，$f_7'=2[x+y>1.5]$！（$1.5$ 可以是 $1$ 到 $2$ 间的任何一个数，为了方便取的。）

就是用 $s(x)$ 实现比较！

解决！……了吗？

回到我刚才说的，异或是二进制下的不进位加法。这说明我们把二进制变回十进制时，可以优化。

但上面那种方法足以得到满分，这个优化留给读者思考。~~（其实是懒）~~

### 代码
共 $603$ 行
```cpp
printf("I\n");
printf("I\n");
printf("< 1 50\n");
for(int i(4),j(31);j;--j,i+=5){
	char str[1001];
	sprintf(str,"%Lf",pow((long double)2.0,50+j)-112590);
	printf("C %d -%s\n",i-1,str);
	printf("S %d\n",i);
	printf("- %d\n",i+1);
	printf("< %d %d\n",i+2,50+j);
	printf("+ %d %d\n",i+3,i-1); 
}
printf("> 158 50\n");
printf("< 2 50\n");
for(int i(161),j(31);j;--j,i+=5){
	char str[1001];
	sprintf(str,"%Lf",pow((long double)2.0,50+j)-112590);
	printf("C %d -%s\n",i-1,str);
	printf("S %d\n",i);
	printf("- %d\n",i+1);
	printf("< %d %d\n",i+2,50+j);
	printf("+ %d %d\n",i+3,i-1); 
}
printf("> 315 50\n");
for(int i(5),j(1);j<=31;++j,i+=5) printf("+ %d %d\n",i,i+157);
printf("+ 159 316\n");
for(int i(317),j(349);i<=348;j+=6,++i){
	printf("C %d -1.5\n",i);
	printf("< %d 50\n",j);
	printf("S %d\n",j+1);
	printf("< %d 1\n",j+2);
	printf("- %d\n",j+3);
	printf("+ %d %d\n",j+4,i);
}
for(int i(355),j(31);j>=1;--j,i+=6) printf("< %d %d\n",i,j);
for(int i(540),j(1);j<=31;++j,++i) printf("+ %d %d\n",i,i+31);
printf("O 602\n");
```

## task 8
### 概况
输入：$a$

输出：$\dfrac a{10}$ 

难度：高中竞赛

### 分析
哎呀，终于不是二进制了。

看看输出，是一个关于 $a$ 的正比例函数。

结合 task 4 肯定又要用到导数。我们要求出 $s(x)$ 斜率为 $0.1$ 的切线的切点坐标。

先来求个导，有

$s'(x)=\dfrac{e^{-x}}{(1+e^{-x})^2}$

这玩意是个连续函数，且最大值为 $0.25$，最小值无限接近 $0$。根据介值定理，方程 $s'(x)=0.1$ 有解。

设这个解为 $x_0$。写出 $x=x_0$ 处的切线，根据点斜式，有 $y=s'(x_0)(x-x_0)+s(x_0)=0.1(x-x_0)+s(x_0)$。

我们肯定可以继续用先缩小再放大的策略，即

$\dfrac a{10}=0.1a+s(x_0)-s(x_0)$

$=\dfrac{0.1a+s(x_0)-s(x_0)}{2^k}\times 2^k$

$=(s(\dfrac a{2^k}+x_0)-s(x_0))\times 2^k$

那么最后就是求解 $x_0$。

眼睛看上去，$s'(x)$ 应该是偶函数，也就是说有两个解。为了方便，不妨令 $x_0>0$。

至于求解，八仙过海各显神通，checker、牛顿迭代、二分、计算器均可。

我用的计算器。化简式子得到 $x_0=\ln(\sqrt{15}+4)\approx 2.0634370688955605467272811726201$。

再用 checker 求得 $s(x_0)$。（太长了，见代码）

至于 $k$ 就取 task 4 的 $250$。不知道为什么，我的计算器在 $k>50$ 时会崩掉，就不放图了。

### 代码
共 $7$ 行
```cpp
printf("I\n");
printf("> 1 250\n");
printf("C 2 2.063437068895560546727281172620\n");
printf("S 3\n");
printf("C 4 -0.887298334620741688517926539978236773937633025540819832675154107295416657242528255923059519\n");
printf("< 5 250\n");
printf("O 6\n");
```
## task 9
### 概况
输入：$a_1,a_2,\cdots,a_{16}$

输出：$a_1,a_2,\cdots,a_{16}$ 升序排序后的结果

难度：高考

### 分析
其实也没那么难，综合性强而已。

排序无论如何都绕不开一个操作：比较并交换。

至于交换，由于每个节点只能被赋值一次，后面只能调用。因此，我们要用一个尽量不用中间变量的方法。

你看那个异或，$603$ 行，不崩才怪。又因为肯定不会溢出，我们用加减法实现。

结合大小关系，我们可以得出下面这段交换代码：

```cpp
h=a0+b0;
a1=h-min(a0,b0);
b1=h-a1;
```

也就是说，问题转化为实现 $\min(a,b)$ 函数。它不同于 task 3，返回值为 $a$ 或 $b$，而非 $1$ 或 $-1$。

这似乎不是很好实现。让我们改写一下上面那段代码：

```cpp
h=a0+b0;
a1=a0-min(a0-b0,0);
b1=h-a1;
```
为什么要改写成这种 $\min(t,0)$ 的形式呢？回看 task 4，我们正好有 $\min(t,0)=-0.5f_4(t)$。

那这不就解决了吗？

题目给的操作不适合复杂的排序。让我们寻找原始的排序：冒泡排序。

最后模拟就完了。注意，常用的冒泡代码是倒着的，需要倒序输出。同样，因为节点的变化难以预测，可以用数组来记录节点号。

当然，你要用其他排序我也支持，但我不想再去思考其他怎么写，就用冒泡了。（甚至我觉得冒泡都不好写，看着题解调的。感谢 @da32s1da [题解](https://www.luogu.com.cn/blog/da32s1da/wu-p1737-post)的代码。）

### 代码
共 $2312$ 行
```cpp
short line[17]={};
F(i,1,16) printf("I\n"),line[i]=i;
for(int i(1),j(16);i<=15;++i) for(int k(i+1);k<=16;++k,j+=19){
	printf("- %d\n",line[k]);
	printf("+ %d %d\n",line[i],line[k]);
	printf("+ %d %d\n",line[i],j+1);
	printf("C %d 0.00000000000000000001\n",j+3);
	printf("< %d 250\n",j+4);
	printf("S %d\n",j+5);
	printf("< %d 250\n",j+6);
	printf("> %d 249\n",j+3);
	printf("+ %d %d\n",j+7,j+8);
	printf("S %d\n",j+9);
	printf("< %d 1\n",j+10);
	printf("- %d\n",j+6);
	printf("+ %d %d\n",j+11,j+12);
	printf("C %d -1\n",j+13);
	printf("< %d 250\n",j+14);
	printf("- %d\n",j+15);
	printf("+ %d %d\n",line[i],j+16),line[i]=j+17;
	printf("- %d\n",line[i]);
	printf("+ %d %d\n",j+2,j+18),line[k]=j+19;
}
R(i,16,1) printf("O %d\n",line[i]);
```

## task 10
### 概况
输入：$a,b,m$

输出：$ab\bmod m$

难度：大学

### 分析
~~大学比高考要更摆烂些。~~

好像绕不开乘法了呢，又不能用乘法节点，怎么办？

回到乘法在小学中的定义，乘法是连加的简记。

一个一个加肯定不行，$b$ 个节点不是闹着玩的。

在历年来的 NOI 中，考察过这样的一个知识点——龟速乘。它适用于两数相乘取模但会溢出的情况。思想与快速幂类似，二进制拆分，按权相乘，最后相加。

例如：$3\times 5\bmod 2=3\times(2^2+2^0)\bmod 2$

$=3\times 2^2\bmod 2+3\times 2^0\bmod 2$

$=12\bmod 2+3\bmod 2=0+1=1$

不过这里一千位，肯定不会溢出，因此取模放在最后进行，先着重处理乘法。

在二进制拆分后，根据二进制该位是 $0$ 或 $1$ 进行位移。现在问题就是计算 $x\times y$，其中 $x\in\{0,1\}$。

写成分段函数，有 $x\times y=\left\{\begin{array}{ll}
0 & x=0\\
y & x=1
\end{array}\right.$

这玩意是不是除了范围又很像 $f_4(x)$？把 $x$ 偏移 $-0.5$，就又可以用 $-0.5f_4(x)$ 计算了。~~所以说小学奥数是世界的尽头。~~

那么就剩取模了。取模可以用减法实现，但一个个减又太浪费了。这时就可以再用二进制。

$ab<2^{64}$，那就模仿 task 6，从 $2^{63}$ 开始枚举指数到 $2^0$，每次看能不能减 $m\times 2^i$。

为了减少取反次数，先取反 $ab$，每次加，最后再取反回来，就解决了。

听说还可以用泰勒展开或康托展开，但对于像我一样的初中蒟蒻，龟速乘无疑是最佳方式。~~（虽然我会泰勒展开）~~

但是实现的时候，我带的 $250$ 莫名奇妙用不了了，改成了 @da32s1da [题解](https://www.luogu.com.cn/blog/da32s1da/wu-p1737-post)中的 $180$，许多细节也要微调，请自行查看代码。

至此，本题完结！

### 代码
共 $1381$ 行

```cpp
printf("I\n");
printf("I\n");
printf("I\n");
printf("> 1 180\n");
printf("< 2 180\n");
for(int i(5),j(31);j;--j,i+=12){
	char str[1001];
	sprintf(str,"%Lf",pow((long double)2.0,18
	str[25]=str[26]=str[27]='0';
	printf("C %d -%s\n",j==31?5:i-7,str);
	printf("S %d\n",i+1);
	printf("- %d\n",i+2);
	printf("< %d %d\n",i+3,180+j);
	printf("+ %d %d\n",i+4,j==31?5:i-7);
	printf("C %d -1\n",i+2);
	printf("< %d 250\n",i+6);
	printf("+ %d %d\n",4,i+7);
	printf("S %d\n",i+8);
	printf("< %d 1\n",i+9);
	printf("+ %d %d\n",i+10,i+3);
	printf("< %d %d\n",i+11,181+j);
}
printf("> 370 180\n");
printf("C 378 -1\n");
printf("< 379 180\n");
printf("+ 4 380\n");
printf("S 381\n");
printf("< 382 1\n");
printf("- 378\n");
printf("+ 384 383\n");
printf("< 385 181\n");
for(int i(17),j(1);j<=31;++j,i+=12) printf("+
printf("> 3 200\n");
printf("C 417 0.5\n");
for(int j(63),i(419);j>=0;--j,i+=15){
	printf("< 3 %d\n",j);
	printf("- %d\n",i+1);
	printf("+ %d %d\n",i+2,i);
	printf("< %d 500\n",i+3);
	printf("S %d\n",i+4);
	printf("C %d -1\n",i+5);
	printf("< %d 500\n",i+6);
	printf("+ %d 418\n",i+7);
	printf("S %d\n",i+8);
	printf("< %d 1\n",i+9);
	printf("- %d\n",i+5);
	printf("+ %d %d\n",i+11,i+10);
	printf("< %d %d\n",i+12,j+201);
	printf("- %d\n",i+13);
	printf("+ %d %d\n",i+14,i);
}
printf("C 1379 -0.5\n");
printf("O 1380\n");
```

## 后记

这篇跨越了一个月的题解终于完成了！

主要的运用是 $s(x)$ 的极限。

不得不说是真的容易崩，还是感谢前面几位 dalao 的题解和代码，不然我也搞不出来。

完整代码不放了，自己动手拼一拼。代码是真的难调，参数是真的难选。

原题解不是太长，就是太短，才有了这篇不长不短的题解。

完结撒花 awa~

---

## 作者：Phartial (赞：4)

牛逼逼题。

## Subtask 1

有手就行。

```cpp
void Subtask1() {
  E x, y;
  cin >> x >> y;
  cout << -((x + y) << 1);
}
```

## Subtask 2

同上。

```cpp
void Subtask2() {
  E x;
  cin >> x;
  cout << S(-(x + (x << 4)));
}
```

## Subtask 3

不是有手就行了。

读一遍题面，可以发现两句很重要的话：

> 每个跳蚤的计算能力都是有限的，他们仅可以精确到十进制小数点后 $90$ 位，超过的部分将会被四舍五入。同理，上述表格中的操作数 $c$ 的小数部分也不能超过 $90$ 位。
>  
> 如果在代入某一组输入数据时：你构造的计算机的计算过程中，某个计算节点的计算结果的绝对值超过 $10^{1000}$，则得 $0$ 分；

给了这么高的精度，spj 限制却只有 $10^{-9}$，肯定要干一些奇奇怪怪的事情把精度炸掉。

考虑 $S(x)$ 的图像：

![](https://cdn.luogu.com.cn/upload/pic/2394.png)

可以发现，这个函数在左右两端都存在极限，换句话说，$\displaystyle\lim_{x\to\infty}S(x)=1$，$\displaystyle\lim_{x\to-\infty}S(x)=0$，且 $S(0)=\dfrac{1}{2}$。

不难想到，我们可以通过左移一个较大的数使得 $S(x)$ 爆掉精度（类似取极限），从而得到一个分段函数：

$$
S(x\cdot2^k)=
\begin{cases}
1 & x>0\\
\frac{1}{2} & x=0\\
0 & x<0
\end{cases}
$$

此函数非常重要，可以给它单独提出来，即 $P(x)=S(x\cdot2^k)$。

将这个函数乘二再减一就是 Subtask3 的答案了。

```cpp
E P(E x) {  // <0: 0, =0: 1/2, >0: 1
  return S(x << 150);
}
E Sign(E x) {
  return (P(x) << 1) + "-1";
}
void Subtask3() {
  E x;
  cin >> x;
  cout << Sign(x);
}
```

## Subtask 4

有点难度。

考虑 $S'(x)$，经过一些计算可以得到它的解析式为 $\dfrac{e^x}{(e^x+1)^2}$，值域为 $[0,\dfrac{1}{4}]$，而且有 $S'(0)=\dfrac{1}{4}$。

通过一些数学知识，我们能够知道直线 $\dfrac{1}{2}+\dfrac{1}{4}x$ 能够在 $0$ 附近较好的拟合 $S(x)$。

所以我们可以把 $x$ 右移一个较大的数让他变成无穷小，再把它丢进 $S(x)$ 里面，得到：

$$
\lim_{k\to\infty}S(\frac{x}{2^k})=\frac{1}{2}+\frac{x}{2^{k+2}}
$$

把它减去 $\dfrac{1}{2}$ 再加上 $2^{k+2}$，我们就由 $S(\dfrac{x}{2^k})$ 求出了 $x$ 的值。

但是这不是一个分段函数，我们希望它的值能在 $x>0$ 和 $x<0$ 的时候能有显著不同。

哪里有一个这样的数呢？

你猜猜为啥我要在上面说 $P(x)$ 很重要。

把 $P(x)$ 左移一个较大的数，得到：

$$
P(x)\cdot2^k=\begin{cases}
  2^k & x>0\\
  2^{k-1} & x=0\\
  0 & x<0
\end{cases}
$$

把这个数加到 $S(x)$ 的参数里面，得到：

$$
S(\frac{x}{2^k}+P(x)\cdot2^p)=\begin{cases}
  1 & x\geq0\\
  \dfrac{1}{2}+\dfrac{x}{2^{k+2}} & x<0
\end{cases}
$$

减去 $\dfrac{1}{2}$ 再乘上 $2^{k+2}$，我们有：

$$
2^{k+2}(S(\frac{x}{2^k}+P(x)\cdot2^p)-\frac{1}{2})=\begin{cases}
  2^{k+1} & x\geq0\\
  x & x<0
\end{cases}
$$

这时需要开一点脑洞，把这个式子再减去一个 $P(x)\cdot2^{k+1}$，我们得到：

$$
2^{k+2}(S(\frac{x}{2^k}+P(x)\cdot2^p)-\frac{1}{2})-P(x)\cdot2^{k+1}=\begin{cases}
  0 & x>0\\
  2^k & x=0\\
  x & x<0
\end{cases}
$$

但是 $x=0$ 又出来了，这让我们很不爽，怎么办呢？

> 每个跳蚤的计算能力都是有限的，他们仅可以精确到十进制小数点后 $90$ 位，超过的部分将会被四舍五入。同理，上述表格中的操作数 $c$ 的小数部分也不能超过 $90$ 位。

我们直接把 $x$ 加上一个 SPJ 精度外的 $\epsilon$，使得它不会取到 $0$ 就行了。

最后得到的是一个 $\min(x,0)$，乘二后被 $x$ 减一下就是 $|x|$ 了。

具体实现中可以取 $p=k+1$，这样就可以省去一次位移了。

需要一定的常数优化。

```cpp
const string kEps = "0." + string(20, '0') + "1";
E Min0(E x) {  // min(x, 0)
  E p = P(x + kEps) << 151;
  E y = S((x >> 150) + p);
  return ((y + "-0.5") << 152) - p;
}
E Abs(E x) {
  E p = P(x + kEps) << 152;
  E y = S((x >> 150) + p);
  return x - ((y + "-0.5") << 153) + p;
}
void Subtask4() {
  E x;
  cin >> x;
  cout << Abs(x);
}
```

## Subtask 5

在领略了一番极限之美后，终于又来了一道送分题。

直接秦九韶即可，注意避免不必要的位移。

```cpp
void Subtask5() {
  E s;
  cin >> s;
  for (int i = 0; i < 31; ++i) {
    E x;
    cin >> x;
    s = (s << 1) + x;
  }
  cout << s;
}
```

## Subtask 6

对于某一位 $i$，我们本质上需要实现一个比较运算符来比较 $2^i$ 和 $a$。

我们又可以用到万能的 $P(x)$。

直接代入 $P(a-2^i+\epsilon)$，我们就求出了 $a$ 和 $2^i$ 的大小关系。

把这一位左移后从 $a$ 中减去即可。

注意避免不必要的位移。

常数优化：我们可以打表出 $2^k(-2^i+\epsilon)$，同时在最开始把 $a$ 左移 $k$ 位。这样可以在每一位上省去一次位移和一次加法。注意在最后要把 $a$ 右移回来。

```cpp
string kP[32] = {
    // (-2^i+1e-10)*2^50
    "",
    "-2251799813572658.0093157376",
    "-4503599627257906.0093157376",
    "-9007199254628402.0093157376",
    "-18014398509369394.0093157376",
    "-36028797018851378.0093157376",
    "-72057594037815346.0093157376",
    "-144115188075743282.0093157376",
    "-288230376151599154.0093157376",
    "-576460752303310898.0093157376",
    "-1152921504606734386.0093157376",
    "-2305843009213581362.0093157376",
    "-4611686018427275314.0093157376",
    "-9223372036854663218.0093157376",
    "-18446744073709439026.0093157376",
    "-36893488147418990642.0093157376",
    "-73786976294838093874.0093157376",
    "-147573952589676300338.0093157376",
    "-295147905179352713266.0093157376",
    "-590295810358705539122.0093157376",
    "-1180591620717411190834.0093157376",
    "-2361183241434822494258.0093157376",
    "-4722366482869645101106.0093157376",
    "-9444732965739290314802.0093157376",
    "-18889465931478580742194.0093157376",
    "-37778931862957161596978.0093157376",
    "-75557863725914323306546.0093157376",
    "-151115727451828646725682.0093157376",
    "-302231454903657293563954.0093157376",
    "-604462909807314587240498.0093157376",
    "-1208925819614629174593586.0093157376",
    "-2417851639229258349299762.0093157376",
};
void Subtask6() {
  E x;
  cin >> x;
  x = x << 50;
  for (int i = 31; i > 0; --i) {
    E v = S(x + kP[i]);
    cout << v;
    x = x - (v << i + 50);
  }
  cout << (x >> 50);
}
```

## Subtask 7

主要思路：异或是二进制里不进位的加法。

所以可以先把 $a$ 和 $b$ 加在一起，然后一位位看哪里是不需要进位的，减掉就行。

考虑怎么求出某一位有没有进位。

对于第 $i$ 位而言，我们把 $a_i$（表示 $a$ 二进制表示下的第 $i$ 位）和 $b_i$（同 $a_i$）加在一起，如果为 $2$ 就说明有一次进位。

直接判断这一位和 $1.5$ 的大小关系即可。具体判断方法在 Subtask 6 里讲了。

注意由于本题的大小比较不可能出现相等的情况，所以不需要加 $\epsilon$。

```cpp
E operator^(E x, E y) {
  E s = x + y;
  x = x << 50, y = y << 50;
  for (int i = 31; i > 0; --i) {
    E vx = S(x + kP[i]), vy = S(y + kP[i]);
    s = s - (P(vx + vy + "-1.5") << i + 1);
    x = x - (vx << i + 50), y = y - (vy << i + 50);
  }
  s = s - (P(x + y + "-1.5") << 1);
  return s;
}
void Subtask7() {
  E x, y;
  cin >> x >> y;
  cout << (x ^ y);
}
```

## Subtask 8

变成连续的了，用不到 $P(x)$ 了。

参考 Subtask 4，由于 $S'(x)\in[0,\dfrac{1}{4}]$，由~~直觉~~一些数学知识可知，必然存在一个 $x$ 使得 $S'(x)=\dfrac{1}{10}$，设这个点为 $\zeta$。

那么我们知道直线 $S'(\zeta)(x-\zeta)+S(\zeta)$ 在 $\zeta$ 附近是能够较好的拟合 $S(x)$ 的。

考虑把 $a$ 右移若干位，让它变成一个很小的数，再加上 $\zeta$，由于这个数很接近 $\zeta$，所以我们可以认为 $S(\dfrac{a}{2^k}+\zeta)=\dfrac{a}{10\cdot 2^k}+S(\zeta)$，把它减去 $S(\zeta)$ 后再左移回来就行。

那么问题就只剩怎么求 $\zeta$ 了。

考虑推式子：

$$
\frac{e^x}{(e^x+1)^2}=\frac{1}{10}
$$

设 $t=e^x$。

$$
\frac{t}{t^2+2t+1}=\frac{1}{10}\\
t^2+2t+1=10t\\
t^2-8t+1=0
$$

使用求根公式，得：

$$
t=4\pm\sqrt{15}
$$

随便取一个解，得：

$$
t=4+\sqrt{15}\\
\zeta=x=\ln(4+\sqrt{15})
$$

使用 [wolframalpha](https://www.wolframalpha.com/input?i2d=true&i=ln%5C%2840%294%2Bsqrt%5C%2840%2915%5C%2841%29%5C%2841%29) 可以得到：

$$
\zeta=2.0634370688955605467272811726201318714565914498833924998360326927...
$$

且

$$
S(\zeta)=0.8872983346207416885179265399782399610832921705291590826587573766...
$$

当然用 python+checker 也是可以的。

```cpp
void Subtask8() {
  string kV = "2.0634370688955605467272811726201318714565914498833924998360326927";
  string kS = "-0.8872983346207416885179265399782399610832921705291590826587573766";
  E x;
  cin >> x;
  cout << ((S((x >> 150) + kV) + kS) << 150);
}
```

## Subtask 9

排序本身的算法可以使用冒泡排序、插入排序、双调排序等，重点在于怎么实现比较器。

考虑一种比较独特的方法：

```cpp
v = a + b
b = v - b
a = v - b
```

这种方法的优点就是很好改造，如果我们不想要交换，就可以这么写：

```cpp
v = a + b
b = v - a
a = v - b
```

具体的，我们规定，如果 $a<b$ 就不交换，否则交换。那么代码就会长这样：

```cpp
v = a + b
b = v - min(a, b)
a = v - b
```

而我们在 Subtask 4 中弄出来了个 $\min(x,0)$，那么我们就可以通过这种方式把 $\min(a,b)$ 弄出来：

```cpp
min(a, b) = min(a - b, 0) + b
```

嵌入到代码中，可以得到：

```cpp
v = a + b
b = a - min(a - b, 0)
a = v - b
```

没了。

双调排序的教程可以看巨佬紫钦的[博客](https://www.luogu.com.cn/blog/user37839/shuang-diao-pai-xu)。

```cpp
void Cmp(E &x, E &y) {
  E v = x + y;
  y = x - Min0(x - y), x = v - y;
}
void Subtask9() {
  E a[16];
  for (int i = 0; i < 16; ++i) {
    cin >> a[i];
  }
  // 双调排序
  for (int i = 2; i <= 16; i <<= 1) {
    for (int j = 0; j < 16; ++j) {
      if (j < (j ^ (i - 1))) {
        Cmp(a[j], a[j ^ (i - 1)]);
      }
    }
    for (int j = i >> 2; j; j >>= 1) {
      for (int k = 0; k < 16; ++k) {
        if (k < (k ^ j)) {
          Cmp(a[k], a[k ^ j]);
        }
      }
    }
  }
  for (int i = 0; i < 16; ++i) {
    cout << a[i];
  }
}
```

## Subtask 10

首先乘法和取模我们是绕不开了。考虑怎么实现这两玩意。

### 乘法

考虑使用快速幂的思想，把 $b$ 按二进制拆位，那么我们就只要实现一个数和一个只可能为 $0$ 或 $1$ 的数的乘法了。不妨设前一个数为 $x$，后一个数为 $y$。

首先把 $y$ 减一造出正负的不同。按套路把这个数左移成能显著影响 $S(x)$ 的无穷大后加到 $\dfrac{x}{2^k}$ 上，此时这个函数就变成了一个分段函数：

$$
S(\frac{x}{2^k}+(y-1)\cdot2^p)=
\begin{cases}
  0 & y=0\\
  \dfrac{1}{2}+\dfrac{x}{2^{k+2}} & y=1
\end{cases}
$$

减去 $\dfrac{1}{2}$，乘上 $2^{k+2}$，不妨设 $p=k+1$，此时可以直接减去 $(y-1)\cdot2^p$ 来把 $y=0$ 时多算的部分减掉。我们就求出了 $x\cdot y$。

### 取模

考虑倍增。

由于 $a,b<2^{32}$，所以结果不会超过 $2^{64}$，从高到低枚举每一位，看当前乘积和 $m\cdot 2^i$ 的大小关系即可。

注意不必要的位移。

```cpp
E Mul0(E x, E y) {  // y=0/1
  E p = (y + "-1") << 151;
  E v = S((x >> 150) + p);
  return ((v + "-0.5") << 152) - p;
}
E operator*(E x, E y) {
  E s = x >> 1000;
  y = y << 50;
  for (int i = 31; i > 0; --i) {
    E v = S(y + kP[i]);
    s = s + Mul0(x << i, v);
    y = y - (v << i + 50);
  }
  s = s + Mul0(x, y >> 50);
  return s;
}
E operator%(E x, E m) {
  for (int i = 63; i > 0; --i) {
    x = x - Mul0(m << i, S((x - (m << i) + kEps) << 500));
  }
  x = x - Mul0(m, S((x - m + kEps) << 500));
  return x;
}
void Subtask10() {
  E a, b, m;
  cin >> a >> b >> m;
  cout << a * b % m;
}
```

全部代码见[这里](https://www.luogu.com.cn/paste/gtme8rls)。


---

## 作者：iterator_traits (赞：4)

题目链接：[P1737 旷野大计算](https://www.luogu.com.cn/problem/P1737)

### 题意简述

使用若干个计算能力强大的跳蚤节点——变量相加、加上常数、取相反数、位移运算、有趣的S函数——来完成几个计算任务。

给定了每个节点的计算精度：小数点后90位。

每个“计算机”的总节点数小于某个值，才能获得满分。

鉴于本题的特殊性，让我们一个一个点来分析吧！

------------


### #1 -2a-2b

此题属于热身题，要求在6行之内 完成。

我们对目标表达式做如下变形：

$-2a-2b=-2(a+b)$

不难构造出如下满分答案：

```
I
I
+ 1 2
< 3 1
- 4
O 5
```

------------


### #2 形如S的函数

这一小题也是热身题，可能是用来让我们熟悉S函数的吧。

比较目标函数和S函数，我们发现只要构造出 $-17a$ 即可，再经过一些变形：

$-17a=-(17a)=-(16a+a)$

不难构造出如下满分答案：

```
I
< 1 4
+ 1 2
- 3
S 4
O 5
```

------------


### #3 符号函数

从这一小题开始有趣起来了。

我们的程序必须能够区分负数、0、正数这三种情况。经过观察，我们发现S函数有如下性质：

$\lim_{n\to+\infty}S(n)=1$

$S(0)=\frac{1}{2}$

$\lim_{n\to-\infty}S(n)=0$

跳蚤的计算能力虽然强大，也是有限制的（90位小数），我们可不可以制造一个“无穷大”的数 $x$,使得跳蚤认为 $S(x)=1$ 或 $S(x)=0$ 呢？

------------

以 $x<0$ 的情况为例，分析如下：

$S(x)=\frac{1}{1+e^{-x}}<10^{-90}$

$\therefore{1+e^{-x}>10^{90}}$

$\therefore{x<-\ln{(10^{90}-1)}\approx-207.2}$

------------

只要 $x<-207.2$ ，跳蚤就会认为 $S(x)=0$

同理，只要 $x>207.2$ ,跳蚤就会认为 $S(x)=1$

我们只要先用位移运算把输入的 $a$ 扩大，使它绝对值大于207.2，就可以完成对正数、0和负数的区分。

输入值绝对值最小为 $10^{-90}$ ，敲一下计算可得至少要乘以 $2^{38}$ 才能使绝对值大于207.2.

先给出这一部分的“跳蚤语言”实现：

```
I
< 1 38
S 2   // Line 3
```

设上述S节点产生的值为 $x$ ，目标函数为 $y$, 不难发现 $y=2x-1$.尝试一下，发现这样刚好可以压线通过此点：

```
S 2   // Line 3
< 3 1
C 4 -1
O 5
```

### #4 绝对值

先给出最简单粗暴的做法：因为

$|x|=\operatorname{sgn}(x) \times x$

所以可以构造出如下6分解：

```I
< 1 38
S 2
< 3 1
C 4 -1
* 4 1
O 6
```


------------


接下来我们来考虑正解。**此方法在本题解会多次用到！**

对 $S(x)$ 在 $x=0$ 附近作泰勒展开（也可以理解为切线放缩），我们得到在0附近，

$S(x)\approx\frac{x}{4}+\frac{1}{2}$

我们再来脑洞大开一下：先把输入数 $a$ 除以一个很大的数，再减去符号函数乘以另一个很大的数，我们应该可以让负数和正数得到不同的答案。（感觉说的不太清楚，但这个脑洞实在太大了）

那么0怎么处理呢？我们考虑到 $|x|$ 的表达式中，0既可以在正数的情况中一并考虑，也可以在负数的情况中一并考虑，所以我们只要把输入值加上一个小于 $10^{-9}$ 的数，就可以把0也考虑进来了。

也就是说，我们实现了函数 $f(x)$：

- 若 $x \ge 0$，$f(x)=x$
- 若 $x<0$，$f(x)=0$

感觉也描述不清楚，不如直接上构造，每一步得到的数会在注释中写出：

```
1 I   // x x  (分别对应负数、非负数）
2 C 1 0.0000000001   //  -  + 
3 < 2 45   //  -  +, 而且绝对值都大于207.2
4 S 3     // 0  1
5 < 4 172  // 0 2^172
6 C 5 -5986310706507378352962293074805895248510699696029696 //-2^172 0
7 > 1 170  // 2^-170 * x
8 + 6 7   // -2^172  x/(2^170)
9 S 8    // 0   0.5+x/(2^172)
10 < 9 173  // 0  2^172+2x
11 + 1 5   // x  x+2^172
12 - 11    // -x  -x-2^172
13 + 10 12  // -x  x
14 O 13
```

在第5步中，我们把符号函数位移得很大。然后先把输入值缩小（第7步），再和上面的扩大版符号函数相加，接着代入S函数，就可以区分正数和负数。

为了压缩步数，我们把第5步的结果重复利用（在第11步中又可以用来把 $\frac{1}{2} \times 2^{173}$ 减掉），这个方法在后面也将用到。

------------


### #5 二进制转十进制

这个小问并不难，把输入值依次位移，相加即得到答案。

值得注意的一点是“个位”是不需要位移的——直接把输入值拿来用就行了。

附上输出的代码：

```cpp
void task5() {
    for (int i = 1; i <= 32; i++)
        std::cout << "I\n";
    for (int i = 1; i <= 31; i++)
        std::cout << "< " << i << ' ' << (32 - i) << '\n';
    std::cout << "+ 32 33\n";
    for (int i = 34; i <= 63; i++)
        std::cout << "+ " << i << ' ' << (i + 30) << '\n';
    std::cout << "O 94\n";
}
```

------------


### #6 十进制转二进制

观察发现，最高位上的数字就是$a-2^{j}+0.5$ 的符号函数，其中 $2^{j}$ 是最高位的权重。

但这样做需要反复扩大 $a-2^{j}+0.5$ ，非常浪费步数。我们可以想到，完全可以在一开始就把 $a$ 左移，这样就可以减少很多步左移运算。

至少应该左移多少位呢？ $|a-2^{j}+0.5| \ge 0.5$，而 $S(x)$ 可以当做符号函数要求 $|x|>207.2$ ,所以位移位数至少为 $\left\lceil\log{\frac{207.2}{0.5}}\right\rceil=9$ .

这样每次 $2^{j}$ 里面的 $j$ 也要加9. 为了进一步压缩步数，我们可以在输出的时候就把 $-2^{j}+2^{8}$ 算好（别忘了开`long long`）。

由于上述算法只适用于求最高位，还要把最高位减掉。

```cpp
void task6() {
    std::cout << "I\n< 1 9\n";  // 先左移以节省步数
    for (int i = 1; i <= 31; i++) {
        std::cout << "C " << (i * 6 - 4) << ' ' << (256LL - (1LL << (41 - i))) << '\n'
            << "S " << (i * 6 - 3) << '\n'  // 当前位上的数字
            << "O " << (i * 6 - 2) << '\n'
            << "- " << (i * 6 - 1) << '\n'  // 这3步用于减掉最高位
            << "< " << i * 6 << ' ' << (41 - i) << '\n'
            << "+ " << (i * 6 - 4) << ' ' << (i * 6 + 1) << '\n';
    }
    std::cout << "> 188 9\nO 189\n";
}
```

------------


### #7 异或

有了第6小问的铺垫，计算二进制表示中每位上的数应该不成问题。但是怎么实现按位异或呢？

我们设两个位上的数分别为 $a$ 和 $b$. 异或又称无进位加法，这启发我们用两者之和来判断。接下来我们分类讨论：

- 若 $a+b=2$, 应该设法凑出一个 $-2$ 与它相加。
- 若 $a+b=0$ 或 $a+b=1$ , 应该设法凑出一个 $0$ 来和它相加。

0和1都比2小，于是又到了愉快的符号函数双倍经验时间：

$a \operatorname{xor} b=(a+b)-2\operatorname{sgn}(a+b-1.5)$

在跳蚤计算机中，

$a \operatorname{xor} b=(a+b)+(-2 \times S(2^{10} \times(a+b-1.5)))$

这样就解决了一个位的异或的问题。

接下来只要把这几位左移相应的权重，然后再相加即可。

贴出本小问的输出代码：（603行）

```cpp
void task7() {
    // 这部分思路和第6题相同。
    std::cout << "I\nI\n< 1 9\n< 2 9\n";
    for (int i = 1; i <= 31; i++) {
        std::cout << "C " << (i * 17 - 14) << ' ' << (256LL - (1LL << (41 - i))) << '\n'
            << "C " << (i * 17 - 13) << ' ' << (256LL - (1LL << (41 - i)))
            << "\nS " << (i * 17 - 12)
            << "\nS " << (i * 17 - 11)
            // 从这里开始是上面所说的求异或的方法
            << "\n+ " << (i * 17 - 10) << ' ' << (i * 17 - 9)
            << "\nC " << (i * 17 - 8) << " -1.5"
            << "\n< " << (i * 17 - 7) << " 10"
            << "\nS " << (i * 17 - 6)
            << "\n< " << (i * 17 - 5) << " 1"
            << "\n- " << (i * 17 - 4)
            << "\n+ " << (i * 17 - 8) << ' ' << (i * 17 - 3)
            // 到这里已经求好了异或，把最高位减掉，以便进行下一步计算
            << "\n- " << (i * 17 - 10)
            << "\n- " << (i * 17 - 9)
            << "\n< " << (i * 17 - 1) << ' ' << (41 - i)
            << "\n< " << (i * 17) << ' ' << (41 - i)
            << "\n+ " << (i * 17 - 14) << ' ' << (i * 17 + 1)
            << "\n+ " << (i * 17 - 13) << ' ' << (i * 17 + 2) << '\n';
    }
    // 最后一位不需要用符号函数，只要右移9位就行了
    std::cout << "> 530 9\n> 531 9\n+ 532 533\nC 534 -1.5\n< 535 10\nS 536\n< 537 1\n- 538\n+ 534 539\n";
    // 按权重位移。
    for (int i = 1; i <= 31; i++)
        std::cout << "< " << (17 * i - 2) << ' ' << (32 - i) << '\n';
    // 把各个位上的数加起来
    std::cout << "+ 540 541\n";
    for (int i = 542; i <= 571; i++)
        std::cout << "+ " << i << ' ' << (i + 30) << '\n';
    std::cout << "O 602\n";
}
```

------------


### #8 除以10

这题要求在6步之内解决。让我们先来试试能不能用小数的二进制表示做。

$\frac{1}{10}=(\frac{1}{2^{4}}+\frac{1}{2^{5}})(1+\frac{1}{2^{4}}+\frac{1}{2^{8}}+...)$

要想达到相对误差小于 $10^{-18}$, 6步是远远不够的。

回想一下第4题是我们曾利用了  $S'(0)=\frac{1}{4}$ 的特殊性质。我们能不能在S的图象上找到一个点 $(x_0,S(x_0))$ ，使切线斜率为 $\frac{1}{10}$ 呢？

------------

已知 $S(x)=\frac{1}{1+e^{-x}}$

求导得 $S'(x_0)=\frac{e^{-x_0}}{(1+e^{-x_0})^{2}}=\frac{1}{10}$

作变量代换 $t=e^{-x_0}$ ,

$\frac{t}{(1+t)^{2}}=\frac{1}{10}$

解得 $t=4\pm\sqrt{15}$

任取 $t=4-\sqrt{15}$ ,则 $x_0=-\ln{t}=\ln(4+\sqrt{15})$


------------


把 $S(x)$ 在 $x_0$ 附近泰勒展开，

$ S(x+x_0)=S(x_0)+\frac{1}{10}x+O(x^{2}) $

变形得到

$ \frac{1}{10}x=S(x+x_0)-S(x_0) $

上述分析要求 $x$ 比较小，所以我们先把输入值右移若干位，然后除以10，最后再左移回来就行了。应该右移多少位呢？尝试可知，150是可以的。

我们用本题的checker计算 $x_0$ 和 $S(x_0)$ ，就可以写出如下的答案：

```
I
> 1 150
C 2 2.0634370688955605467272811726201
S 3
C 4 -0.887298334620741688517926539978236773937633025540819832675154107295416657242528255923059519
< 5 150
O 6
```

------------


### #9 排序

排序能用什么算法呢？是归并吗？是快排吗？（~~连数组下标都不能实现在想啥呢~~）

我想了想，还是冒泡排序比较有前途。

大小比较可以用减法+符号函数解决，那么问题的关键，就变成了如何根据这个0或1的结果把较大值和较小值储存到新的节点中。

这个问题可以用绝对值的思路来解决。在第4问已经实现了 $f(a,b)$ ，使得：

- 若 $a \ge b, f(a,b)=a-b$
- 若 $a<b, f(a, b)=0$

那么 $\operatorname{max}\{a,b\}=b+f(a,b),\quad\operatorname{min}\{a,b\}=a-f(a,b)$

剩余的就是一些实现细节的问题了，我的实现如下（1952行）：

```cpp
struct Task9 {
    int pos[17];
    int curr;

    // 向stdout输出一个节点，同时返回它的编号
    int write(char type, int i) {
        std::cout << type << ' ' << i << '\n';
        return ++curr;
    }

    int write(char type, int i, std::string_view j) {
        std::cout << type << ' ' << i << ' ' << j << '\n';
        return ++curr;
    }

    int write(char type, int i, int j) {
        std::cout << type << ' ' << i << ' ' << j << '\n';
        return ++curr;
    }

    // 将a,b中较大的数所在节点放在b中，较小的放在a中
    void exchange(int& a, int& b) {
        const int negb = write('-', b);
        // a - b
        const int diff = write('+', a, negb);
        // 0 for a < b, 1 for a>=b
        const int c1 = write('S', write('<', write('C', diff, "0.0000000001"), 45));
        // -2^172 for a < b, 0 for a >= b
        const int c2 = write('C', write('<', c1, 171), "-2993155353253689176481146537402947624255349848014848");
        // -2^172 for a < b, 0.5 + 2^(-172) * (a-b) for a >= b
        const int c3 = write('+', c2, write('>', diff, 170));
        // 0 for a < b, 2^171 + (a-b) for a>= b
        const int c4 = write('<', write('S', c3), 172);
        // 0 for a < b, a - b ifor a >= b
        const int c5 = write('+', write('-', c1 + 1), c4);
        const int bigger = write('+', c5, b);
        const int smaller = write('+', a, write('-', c5));
        b = bigger;
        a = smaller;
    }

    void input() {
        for (int i = 1; i <= 16; i++)
            std::cout << "I\n";
        curr = 16;
        std::iota(pos + 1, pos + 17, 1);
    }

    void operator () () {
        input();
        // 冒泡排序
        for (int i = 1; i <= 15; i++) {
            for (int j = 1; i + j <= 16; j++) {
                exchange(pos[j], pos[j + 1]);
            }
        }
        // 输出答案
        for (int i = 1; i <= 16; i++)
            write('O', pos[i]);
    }
};
```

------------


### #10 乘法取余

乘法节点要扣分，那只好自己动手，丰衣足食了。

在第6问中我们已经实现过把一个整数拆成二进制表示。能不能实现类似下面的乘法方法呢？（位移运算是为了方便理解，并不规范）

$ 19x=(2^{4}+2^{1}+2^{0})x=(x<<4)\space+(x<<1)\space+x $

只要把 $a$ 拆成二进制表示，再设法根据每位上是0还是1来决定是否加上 $b \times 2^{j}$ 。这里我们用的方法和第4问的方法基本一样，不同之处在于符号函数的参数和第二次S函数调用的参数是不一样的。

感觉多说也无益，不如来看看这一部分的实现方法：

```cpp
struct Task10 {
    // Indices of the components of a * b is put here.
    std::array<int, 32> compos;
    // Number of lines printed
    int curr;
    // The position of a * 512 with its most significant bit gradually removed
    int a9pos;
    // Where b and -m is.
    int bpos, negmpos;
    // Where the product is.
    int prodpos;

    // Writes a node, returns its index.
    int write(char type, int i) {
        std::cout << type << ' ' << i << '\n';
        return ++curr;
    }

    int write(char type, int i, std::string_view j) {
        std::cout << type << ' ' << i << ' ' << j << '\n';
        return ++curr;
    }

    int write(char type, int i, int j) {
        std::cout << type << ' ' << i << ' ' << j << '\n';
        return ++curr;
    }

    int write(char type, int i, long long j) {
        std::cout << type << ' ' << i << ' ' << j << '\n';
        return ++curr;
    }

    // Bit of significance 2^y
    void make_component(int y) {
        // The bit extracted from a.
        const int abit = [y, this]{
            if (y)
                return write('S', write('C', a9pos, 256LL - (1LL << (y + 9))));
            else
                return write('>', a9pos, 9);
        }();
        // 0 if 0, 2^131 if 1
        const int c1 = write('<', abit, 131);
        // -2^131 if 0, 0 if 1
        const int c2 = write('C', c1, "-2722258935367507707706996859454145691648");
        // b^(y-130)，这是个压缩步数的操作
        const int c3 = write('>', bpos, 130 - y);
        // -2^131 if 0, b*2^(y-130) if 1
        const int c4 = write('+', c2, c3);
        // 0 if 0, 0.5+ b*2^(y-132) if 1
        const int c5 = write('S', c4);
        // 0 if 0, 2^131 + b*2^y if 1
        const int c6 = write('<', c5, 132);
        // 0 if 0, -2^131 if 1
        const int c7 = write('-', c1);
        // 0 if 0, b*2^y if 1
        compos[y] = write('+', c6, c7);
        // Take the bit away from a, only necessary for y >= 0
        if (y) {
            const int c8 = write('-', abit);
            const int c9 = write('<', c8, 9 + y);
            a9pos = write('+', a9pos, c9);
        }
    }
    
    // Not complete!
```

接下来，我们只要把a的每一位的贡献加起来就得到了 $a \times b$。

```cpp
    // Put all the components together, returns the index.
    void sum_comp() {
        // The "previous" answer
        int prev = compos[0];
        for (int i = 1; i < 32; i++)
            prev = write('+', prev, compos[i]);
        // prodpos指向ab所在位置。
        prodpos = prev;
    }
```

可是连乘法节点都没有，我们要怎么计算余数呢？只要反复地减 $m$，直到再减要小于0了为止，就得到了余数。但是在最坏情况下，需要进行 $2^{32} \times 2^{32}\div1=2^{64}$ 次计算，肯定打不下。

于是我们利用倍增的思想， $a \times b \div m$ 的商的最大值小于 $2^{64}$，所以我们用 $2^{63}m, 2^{62}m, 2^{61}m, ..., m$ 依次试减，就可以得到余数。

我们再一次利用第4问的方法，构造一个分段函数实现“试减”。

```cpp
    // Attempt the subtraction.
    void subtract(int y) {
        // 经过取反、位移操作的-m*2^y
        const int sm = [y, this]{ return y ? write('<', negmpos, y) : negmpos; }();
        // ab - (m * 2^y) (设为x)
        const int c3 = write('+', prodpos, sm);
        // <0 if x<0, >0 if x >= 0
        const int c4 = write('C', c3, "0.5");
        // -inf if x < 0, +inf if x >= 0
        const int c5 = write('<', c4, 15);
        // 0 if x < 0, 1 if x >= 0
        const int c6 = write('S', c5);
        // 0 if x < 0, 2^131 if x >= 0
        const int c7 = write('<', c6, 131);
        // -2^131 if x < 0, 0 if x >= 0
        const int c8 = write('C', c7, "-2722258935367507707706996859454145691648");
        // -m*2^(y-130)
        const int c9 = write('>', sm, 130);
        // -2^131 if x < 0, -m*2^(y-130) if x >= 0
        const int c10 = write('+', c8, c9);
        // 0 if x<0, 0.5-m*2^(y-132) if x >= 0
        const int c11 = write('S', c10);
        // 0 if x<0, 2^131-m*2^y if x >= 0
        const int c12 = write('<', c11, 132);
        // 0 if x < 0, -2^131 if x >= 0
        const int c13 = write('-', c7);
        // 0 if x < 0, -m*2^y if x >= 0
        const int c14 = write('+', c12, c13);
        // ab if x < 0, ab-m*2^y if x >= 0
        // 直接更新ab
        prodpos = write('+', prodpos, c14);
    }
```

最后写好输入输出，把这几个操作组织一下就好了，总计1344行。

```cpp
    void operator () () {
        std::cout << "I\n< 1 9\nI\nI\n- 4\n";
        a9pos = 2;
        bpos = 3;
        negmpos = curr = 5;
        for (int i = 31; i >= 0; i--)
            make_component(i);
        // Index of the product
        sum_comp();
        for (int i = 63; i >= 0; i--)
            subtract(i);
        write('O', curr);
    }
};
```

至此，本题做完了。我认为本题最精彩的地方在于：

- 用爆精度的方法把 $S(x)$ 当符号函数用。
- 符号函数位移扩大之后，再和另外一个小量相加，实现正负分段函数。
- 巧妙选择上一问的扩大倍数，压缩步数。

还请各位巨佬指正。


---

## 作者：可爱的小棉羊 (赞：3)

**Update on 2024-2-23/17:10 修改了部分笔误**

**Update on 2024-2-28/15:58 Latex修复**

------------


题目链接：[P1737 [NOI2016] 旷野大计算](https://www.luogu.com.cn/problem/P1737)

题目大意：用取反，位移，等操作，以及非常玄学的 $S$ 函数来完成一些任务，~~为什么不用冯诺依曼的存储程序思想，差评！~~ 

其中 $S(x)$ 函数为 $\frac{1}{1+e^{-x}}$，我们要充分利用它的一些性质。

还有三个非常好用但要扣分的节点：比较节点、MAX 节点、乘法节点。

### Task 1

输入：$a,b$

输入限制：$\lvert a \rvert, \lvert b \rvert \le 10^9$，小数部分不超过 $9$ 位。

输出：$-2a-2b$

满分行数：$6$ 行

难度：送分

------------

显然我们要对样例优化，我们可以可以将两个数的取反和乘 $2$，放在一起，这样就刚好 $6$ 行。

代码如下：

```

I
I
+ 1 2
< 3 1
- 4
O 5
```

### Task 2

输入：$a$

输入限制：$\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位。

输出：$\dfrac{1}{1+e^{17a}}$

满分行数：$6$ 行

难度：送分

------------

注意到 $17=2^4+1$，我们可以用位移做优化，要记得取反，代码如下：

```
I
< 1 4
+ 1 2
- 3
S 4
O 5
```

### Task 3

输入：$a$

输入限制：$\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位。

输出：$\begin{cases}-1 & a \lt 0 \\ 0 & a = 0 \\ 1 & a \gt 0\end{cases}$

满分行数：$6$ 行

难度：大众

------------

我们连 `if`，`else` 都没有，肯定不能用正常方式构造了。

首先我们可以用比较节点，与 $0$ 比较得 $6$ 分。

 > #### 如何造 $0$?
 >
 > 可以用 $a-a$ 然后比较大小。

别急，我们阅读阅读题面：

> 每个跳蚤的计算能力都是有限的，他们仅可以精确到十进制小数点后 $90$ 位，超过的部分将会被四舍五入。同理，上述表格中的操作数 $c$ 的小数部分也不能超过 $90$ 位。另外，左移节点和右移节点中的操作数 $k$ 必须是非负整数，且不能超过 $10^4$。

但是：
> 你构造的计算机的输出中的某个值与预期的输出值相差超过 $10^{-9}$，则认为你的输出不正确，得 $0$ 分。

为啥精确了 $90$ 位，SPJ 却只判 $10^{-9}$ 的误差呢？

~~当然是因为跳蚤国王只看前 $9$ 位啦！~~

而且为什么大部分测试点，都没有体现精确度这个东西，而且从表面上看 $S$ 函数除了 $\text{Task 2}$ 上有用外好像并没有大用。

要是出题人真的想没事找事的话为啥不是 $S(x)=ax^2+bx+c$ 呢？

为啥不是 $114514^x$ 呢？

为啥不是 $\varphi(x)$ 呢？

这时我们需要关注 $S$ 函数了。

$S$ 函数具有两个极限：

$$
\lim_{x \to \infty} S(x)=1
$$

$$
\lim_{x \to -\infty} S(x)=0
$$

有没有一种可能我们可以通过 $S$ 函数的极限来取分段函数。

什么意思呢？

举个栗子（也就是这个点）：我们把 $a$ 放大无穷大倍（这里当然只用刚好取足够大。），丢进 $S$ 函数 里，那我们是不是得到了一个分段函数：


$$
S(x \times \infty )= \begin{cases} 1 & x > 0 \\ 
\frac{1}{2}  & x = 0 \\ 
0 & x < 0 \end{cases}
$$

当然我们这里的 $\infty$ 可以用位移解决，这里我们需要乘上足够大的数，来接近于 $0$ 或 $1$。

然后我们把这个函数乘上 $2$ 再减去 $1$，就得到了我们想要的了。

```
I
< 1 50
S 2
< 3 1
C 4 -1
O 5
```

### Task 4

输入：$a$

输入限制：$\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位。

输出：$\lvert a \rvert$

满分行数：$14$ 行

难度：较难

------------

看得出来从这个点开始，做法就越来越复杂了。

我们知道 $a$ 的绝对值是一个分段函数：

$$
\lvert a \rvert=\begin{cases} -a & a<0 \\0 & a=0\\a & a>0
\end{cases}
$$

那我们肯定要用和 $\text{Task 3}$ 差不多的方法来进行构造。

可问题来了，我们 $S$ 函数的极限 $0 \text{，} 1$ 与$-a \text{，} a$ 没有半毛钱关系，就算做也免不了乘法或取大小呀！

那怎么办呢？

是时候运用一下导数了。

> #### 什么是导数？
> 导数是对一个函数某一处的增长率，我们可以简单地认为这是函数的增长速度，从几何意义上来讲它的含义是函数图像上某一点的切线的斜率。

> 一般来讲我们会把 $f(x)$ 的导数记为 ${f}'(x)$

> $${f}'(x)=\lim_{\Delta x \to 0}\frac{f(x+\Delta x)-f(x)}{\Delta x}$$

我们可以算出 ${S}'(x)=\frac{e^{-x}}{(1+e^{-x})^2}$，在 $0$ 处取值 $\frac{1}{4}$。

这时我们可以轻易得写出一条 $S$ 函数在 $(0,\frac{1}{2})$ 处的一条切线：$y=\frac{1}{4}x+\frac{1}{2}$

---

声明：为表示方便，下称这条切线为 $f(x)$。

---

如果我们的 $a$ 越接近 $0$ 那么 $S(a)$ 就会越接近 $f(a)$。

而我们如果得知某一处 $f(x)$ 的值，我们就可以得出 $x$ 的值。

我们就可以从 $S(x) \to x$。

这样我们就可以在将 $x$ 丢进 $S(x)$ 后再将 $x$ 还原出来。

------------

但我们还需要分段。

运用 $\text{Task 3}$ 的方法，我们把 $T(x)=S(x \times 2^q)$ 加进 $S$ 里：

$$
S(\frac{x}{2^k}+T(x)\times2^p)=\begin{cases}1&x>0\\\frac{x}{4\times 2^k}+\frac{1}{2}& x<0\end{cases}
$$

>解释：如果 $x>0$ 那么 $T(x)\times2^p$ 的贡献就为极大值,得到 $S$ 的极限。

> 如果 $x<0$ 那么 $T(x)\times2^p$ 的贡献为 $0$，剩下的 $\frac{x}{2^k}$ 由于非常接近 $0$ 而非常接近 $f(x)$。

都让 $x$ 出现在了分段函数的解析式上了，肯定会简单不少：

接着我们减去 $\frac{1}{2}$ 然后乘上 $4 \times 2^k=2^{k+2}$：

$$
2^{k+2}(S(\frac{x}{2^k}+T(x)\times2^p)-\frac{1}{2})=\begin{cases}2^{k+1}&x>0\\x& x<0\end{cases}
$$

可是那个 $2^{k+1}$ 好丑啊！可减掉会把 $x$ 一起减掉的。

那我们可以减去 $T(x)\times2^p$ 那么：

$$
2^{k+2}(S(\frac{x}{2^k}+T(x)\times2^p)-\frac{1}{2})-T(x)\times2^p=\begin{cases}2^{k+1}-T(x)\times2^p&x>0\\x& x<0\end{cases}
$$

我们不妨令 $p=k+1$ 这样我们就得到了一个函数（下文称 $M(x)$）使得：

$$
M(x)=\begin{cases}
0 & x>0\\
x &x<0
\end{cases}
$$

我们把它乘上 $-2$ 在加上 $x$ 这样不就得到了：

$$
-2M(x)+x=\begin{cases}x & x>0\\
-x & x<0\end{cases}
$$

好耶！

还有个小问题：

$$
T(x)\times2^p= \begin{cases}
2^p &x>0\\
2^{p-1} &x=0\\
0 & x<0 \end{cases}
$$

如果 $x$ 等于 $0$ 时减去 $T(x)\times2^p$ 就少减了。

我们可以对 $x$ 加上一个很小的数如 $10^{-10}$ 这样就可以把 $0$ 当正数处理当然减去也行。

可这样就 $15$ 行了。

我们把 $-2M(x)+x$ 展开：

$$
-2(2^{k+2}(S(\frac{1}{x^k}+T(x)\times2^p)-\frac{1}{2})-T(x)\times2^p)+x=
-2^{k+3}(S(\frac{1}{x^k}+T(x)\times2^p)-\frac{1}{2})+2T(x)\times2^p+x
$$

我们可以让 $p=k+2$ 这样就可以少一个乘 $2$。

答案就是：

$$
T(x)=S((x+10^{-10})\times2^q)
$$

$$
-2^{k+3}(S(\frac{1}{x^k}+T(x)\times2^p)-\frac{1}{2})+T(x)\times2^p+x
$$

代码如下（$k,q,p$ 取的值是紫钦大佬的，下面大部分都是这样，膜拜！）

```
I
C 1 0.0000000001
< 2 41
S 3
< 4 180
> 1 178
+ 6 5
S 7
C 8 -0.5
< 9 181
- 10
+ 11 5
+ 12 1
O 13
```

### Task 5

输入：$a_1, \dots, a_{32}$

输入限制：$a_1, \dots, a_{32} \in \{0, 1\}$

输出：把 $a_1, \dots, a_{32}$ 从左到右看成一个二进制整数，高位在左低位在右，输出该整数的值。

满分行数：$95$ 行

难度：送分

------------

又是一道送分点，每一位都向都左移一下，加一起就行。只要别干移 $0$ 位这种无意义的事就行。

代码如下：
```cpp
for(int i=1;i<=32;++i) printf("I\n");
for(int i=1;i<=31;++i) printf("< %d %d\n",i,32-i);
printf("+ 63 32\n");
for(int i=33;i<=63;++i) printf("+ %d %d\n",i,i+31);
printf("O 94");
```

### Task 6

输入：$a$

输入限制：$0 \le a \lt 2^{32}$，$a$ 为整数。

输出：输出 $32$ 个整数，从高位到低位输出 $a$ 的二进制表示（不足 $32$ 位的在高位补 $0$）。

满分行数：$190$ 行

难度：大众
 
------------

 又搞 $0$ 和 $1$ 自然而然想到 $S$ 函数。
 
 我们如何判断呢？
 
 我们可以用和手动计算差不多的方法来算，但还得倒序，很难受，下面说一种从高位到低位取的方法。
 
 我们先取最高位：
 
 先将 $a$ 减去 $2^{31}$，如果这一位为 $1$，这时应该为正数，否则为负数，判正负，这不就是 $\text{Task 3}$ 吗？这里左移 $41$ 位，丢进 $S$ 里，得 $S(2^{41}(a-2^{31}))=S(2^{41}a-2^{72})$，然后我们输出结果，当然还有可能遇到 $S(0)=\frac{1}{2}$ 的情况，我们要加上$10^{-10}$，根据跑出来的 $S$ 减去这一位。
 
 当然我们发现左移$41$位，可以提前做，但我们要提前跑出 $2^{42}$ 到 $2^{72}$ 的值，用 checker 跑，也可以 Python，还可以用 `__int128`。
 
 当然加上$10^{-10}$也可以提前做。
 
对于最后一位，我们只需右移 $41$ 位就求了出来。

细细一算，取一位需要 $6$ 行，而刚好 $190=31 \times 6+4$

------------

但我们刚刚的方法却多了一行。

我们需要优化循环外的一行，我们可以把加上$10^{-10}$优化掉。

对于每次减去第一个减去 $2$ 的幂的操作，我们少减去 $10^{-10}\times 2^{41}\approx 220$ 这样就优化掉了一行。

因为当为 $0$ 的时候，我们应该是判定这一位为 $1$，所以该减去 $220$。

代码如下：
```cpp
printf("I\n");
printf("< 1 41\n");
for(int i=31,row=3;i>=1;i--,row+=6){
	printf("C %d -",row-1);
	cout<<str[i]<<endl;
	printf("S %d\n",row);
	printf("O %d\n",row+1);
	printf("- %d\n",row+1);
	printf("< %d %d\n",row+3,i+41);
	printf("+ %d %d\n",row-1,row+4);
}
printf("> 188 41\n");
printf("O 189\n"); 
```

这里的 `str[i]` 就不公开了，因为 $2^{42}$ 到 $2^{72}$ 的数太多了。

### Task 7

输入：$a,b$

输入限制：$0 \le a, b \lt 2^{32}$，$a,b$ 均为整数。

输出：$a \oplus b$

满分行数：$605$ 行

难度：较难

------------
 
 首先我们知道，我们得对 $a,b$ 转换二进制，结果还得转换回去，实际做异或的行数只有 $226$ 行。差不多一个位的异或用 $7$ 行。
 
我们先看异或的运算规则：

$$
a \oplus b= \begin{cases}
0 &0\oplus 0, 1\oplus 1\\
1 &0\oplus 1, 1\oplus 0
\end{cases}
$$

我们的一个位，只有 $7$ 行，我们应该如何构造呢？

我们可以先对 $a,b$ 相加：

$$
a + b= \begin{cases}
0 &0\oplus 0\\
1 &0\oplus 1, 1\oplus 0\\
2 &1\oplus 1
\end{cases}
$$

~~你家异或长这样啊？！~~

别急我们可以对我们可以用 $S$ 函数，来判断大小，具体操作如下：

$$
S(2^p(a + b-0.5))= \begin{cases}
0 &0\oplus 0\\
1 &0\oplus 1, 1\oplus 0\\
1 &1\oplus 1
\end{cases}
$$

$$
S(2^p(a + b-1.5))= \begin{cases}
0 &0\oplus 0\\
0 &0\oplus 1, 1\oplus 0\\
1 &1\oplus 1
\end{cases}
$$

我们惊奇的发现我们把上面两个式子相减不就得到了吗？

但我们又发现这样写要 $8$ 行。

------------

我们可以只用上面的一个式子：

$$
a+b-2S(2^p(a+b-1.5))=\begin{cases}
0 &0\oplus 0\\
1 &0\oplus 1, 1\oplus 0\\
0 &1\oplus 1
\end{cases}
$$

就只要 $7$ 行啦！还剩 $2$ 行，估计是因为出题人怕我们不会减去 $220$ 这个优化方式吧！~~（出题人人还怪好的嘞！）~~

代码太长了我给出异或的部分：

```cpp
for(int i=?,j=1;j<=32;j++,i+=?)printf("+ %d %d\n",i,i+?);
for(int i=?,j=1;j<=32;j++,i++)printf("C %d -1.5\n",i);
for(int i=?,j=1;j<=32;j++,i++)printf("< %d 41\n",i);
for(int i=?,j=1;j<=32;i++,j++)printf("S %d\n",i);
for(int i=?,j=1;j<=32;j++,i++)printf("< %d 1\n",i);
for(int i=?,j=1;j<=32;j++,i++)printf("- %d\n",i);
for(int i=?,j=1;j<=32;j++,i++)printf("+ %d %d\n",i,i-?);
```

这里的参数需和你的代码匹配。

### Task 8

输入：$a$

输入限制：$\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位。

输出：$\dfrac{a}{10}$

满分行数：$7$ 行

难度：奇门淫技

------------

~~可以用乘法节点，得 $6$ 分。~~

我们知道：

$$
\frac{1}{10}=2^{-4}+2^{-5}+2^{-8}+2^{-9}+......
$$

只要加足够多就可以接近答案了，但 $7$ 个节点完全不够用。

------------

这时我们要用 $\text{Task 4}$ 的方法了。

还记得那条切线 $y=\frac{1}{4}x+\frac{1}{2}$ 吗？

我们也可以找到一个数 $\gamma$ 使得 ${S}'(\gamma)=\frac{1}{10}$。

$$\frac{e^{-x}}{(1+e^{-x})^2}=\frac{1}{10}$$

不妨令 $e^{-x}=\beta$

$$\frac{\beta}{(1+\beta)^2}=\frac{1}{10}$$

解得 $\beta=4 \pm \sqrt{15}$

我们用 $4- \sqrt{15}$ 吧。

所以 $\gamma=-\ln{(4-\sqrt{15})}=\ln(4+\sqrt{15})$

算出来之后，我们可以写出一条在此处的切线：$y=\frac{1}{10}(x-\gamma)+S(\gamma)$

我们知道当 $x$ 非常接近 $\gamma$ 时，$S(x)$ 将非常接近这条切线。

那么我们不妨求出 $S(\frac{x}{2^k}+\gamma)$ 由于 $\frac{x}{2^k}$ 很小，那么我们可以认为 $S(\frac{x}{2^k}+\gamma)=\frac{1}{10}(\frac{x}{2^k}+\gamma-\gamma)+S(\gamma)=\frac{1}{10\times2^k}x+S(\gamma)$

那么我们减去 $S(\gamma)$ 再乘上 $2^k$ 就得到了 $\frac{1}{10}$。

答案就是 $(S(\frac{x}{2^k}+\gamma)-S(\gamma))\times 2^k$

用计算器计算出 $\gamma=$ `2.0634370688955605467272811726201`。

再用 checker 算出 $S(\gamma)=$ `0.887298334620741688517926539978236773937633025540819832675154107295416657242528255923059519`。

代码如下：
```
I
> 1 178
C 2 2.0634370688955605467272811726201
S 3
C 4 -0.887298334620741688517926539978236773937633025540819832675154107295416657242528255923059519
< 5 178
O 6
```

### Task 9


输入：$a_1, \dots, a_{16}$

输入限制：$\lvert a_1 \rvert, \dots, \lvert a_{16} \rvert \le 10^9$，小数部分不超过 $9$ 位。

输出：输出 $16$ 个实数，表示 $a_1, \dots, a_{16}$ 从小到大排序后的结果。

满分行数：$3000$ 行

难度：最难

------------

首先这些计算节点太单一了，比汇编还要单一，我们也只能用冒泡排序等简单的排序了。

我们如何对两个数交换呢？

```
w=a+b
p=w-a
q=w-p
```

假如我们不要交换呢？

```
w=a+b
p=w-b
q=w-p
```

那假如我说 若 $a<b$ 就交换否则就不交换呢？


```
w=a+b
p=w-min(a,b)=a+b-(min(a-b,0)+b)=a-min(a-b,0)
q=w-p
```

为啥要写成这样的样子呢？

我们是不是在 $\text{Task 4}$ 得到过：

$$
M(x)=\begin{cases}
0 & x>0\\
x &x<0
\end{cases}=\min(0,x)
$$

这不刚好吗？

用一个数组来记录每个变量的位置，然后倒序输出即可。

代码如下：

```cpp
int pos[20]={},row=16;
for(int i=1;i<=16;i++)pos[i]=i;
for(int i=1;i<=16;i++)printf("I\n");
for(int i=1;i<=16;i++){
	for(int j=1;j+i<=16;j++){
		printf("+ %d %d\n",pos[j],pos[j+1]);
		printf("- %d\n",pos[j+1]);
		printf("+ %d %d\n",pos[j],row+2);
		printf("C %d 0.00000000001\n",row+3);
		printf("< %d 41\n",row+4);
		printf("S %d\n",row+5);
		printf("< %d 179\n",row+6);
		printf("> %d 178\n",row+3);
		printf("+ %d %d\n",row+7,row+8);
		printf("S %d\n",row+9);//10
		printf("C %d -0.5\n",row+10);
		printf("< %d 180\n",row+11);
		printf("- %d\n",row+7);
		printf("+ %d %d\n",row+12,row+13);
		printf("- %d\n",row+14);
		printf("+ %d %d\n",pos[j],row+15);
		pos[j]=row+16;
		printf("- %d\n",row+16);
		printf("+ %d %d\n",row+1,row+17);
		pos[j+1]=row+18;
		row+=18; 
	}
}
for(int i=16;i>=1;i--)printf("O %d\n",pos[i]);
```

### Task 10

输入：$a,b,m$

输入限制：$0 \le a, b \lt 2^{32}$，$1 \le m \lt 2^{32}$，$a,b,m$ 均为整数。

输出：$ a \times b $ 除以 $m$ 的余数。

满分行数：$2000$ 行

难度：较难

------------

#### 先讲乘法：

显然有了前面的铺垫我们可以用二进制拆分的形式来计算。
 
我们可以将 $b$ 的第 $i$ 位和 $2^ia$ 相乘。

现在问题变成构造函数：

$$
a \times b=\begin{cases} 0 & b=0\\ a & b=1 \end{cases}
$$

这和 $\text{Task 4}$ 差不多。

我们可以用和 $\text{Task 4}$ 差不多的方法：

$$
S(\frac{x}{2^k}+2^p(b-1))=\begin{cases}0 &b=0\\ \frac{1}{2^{k+2}}x+\frac{1}{2}& b=1\end{cases}
$$

一样令 $p=k+1$ 得：

$$
2^{k+2}(S(\frac{x}{2^k}+2^p(b-1))-\frac{1}{2})-2^p(b-1)=\begin{cases}0 &b=0\\ x& b=1\end{cases}
$$

现在就解决啦！

#### 接着是取模：

我们可以用做减法我们不妨将 $2^0m,2^1m,.....2^{63}m$ 算出来，再从高往低地去减，就得到了答案。

代码如下：

```cpp
printf("I\nI\nI\n");
printf("< 2 41\n");
for(int i=31,j=5;i>=1;i--,j+=14){
	if(i==31)printf("C %d -",j-1);
	else printf("C %d -",j-10);
	cout<<str[i]<<endl;
	printf("S %d\n",j);
	printf("- %d\n",j+1);
	printf("< %d %d\n",j+2,i+41);
	if(i==31)printf("+ %d %d\n",j-1,j+3);
	else printf("+ %d %d\n",j-10,j+3);
	printf("C %d -1\n",j+1);
	printf("< %d 151\n",j+5);
	printf("> 1 %d\n",150-i);
	printf("+ %d %d\n",j+7,j+6);
	printf("S %d\n",j+8);
	printf("C %d -0.5\n",j+9);
	printf("< %d 152\n",j+10);
	printf("- %d\n",j+6);
	printf("+ %d %d\n",j+12,j+11);
}
printf("> 429 41\n");
printf("C 439 -1\n");
printf("< 440 151\n");
printf("> 1 150\n");
printf("+ 442 441\n");
printf("S 443\n");
printf("C 444 -0.5\n");
printf("< 445 152\n");
printf("- 441\n");
printf("+ 446 447\n");
printf("+ 18 448\n");
for(int i=1,j=32,k=449;i<=30;i++,j+=14,k+=1)printf("+ %d %d\n",j,k);
printf("C 479 0.00000000001\n");
	for(int i=64,j=481;i>=0;i--,j+=15){
	printf("< 3 %d\n",i);
	printf("- %d\n",j);
	printf("+ %d %d\n",j+1,j-1);
	printf("< %d 41\n",j+2);
	printf("S %d\n",j+3);
	printf("C %d -1\n",j+4);
	printf("< %d 151\n",j+5);
	printf("> %d 150\n",j+1);
	printf("+ %d %d\n",j+7,j+6);
	printf("S %d\n",j+8);
	printf("C %d -0.5\n",j+9);
   printf("< %d 152\n",j+10);
	printf("- %d\n",j+6);//12
	printf("+ %d %d\n",j+12,j+11);
	printf("+ %d %d\n",j+13,j-1);
}
printf("O 1455\n");
```

## 总结

1. $S$ 函数很重要。

1. 细心！细心！ 细心！

1. 脑洞！脑洞！脑洞！

---


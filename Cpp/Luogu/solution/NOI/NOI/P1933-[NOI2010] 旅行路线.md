# [NOI2010] 旅行路线

## 题目描述

2010 年，世博会在中国上海举办，吸引了数以千万计的中外游客前来参观。暑假期间小 Z 也来到了上海世博园， 她对世博园的拥挤早有所闻，对有的展馆甚至要排上好几个小时的队才能进入也做好了充分准备，但为了使得自己的世博之旅更加顺利舒畅，小 Z 决定在游玩之前先制定一份详细的旅行路线。

小 Z 搜集到了世博园的地图，她发现从整体上看世博园是一块非常狭长的区域，而每一个展馆占用了其中一个几乎相同大小的方块。因此可以将整个园区看成一个 $n \times m$ 的矩阵（$n \leq 3$），其中每一个格子为一个主题展馆。

由于不同展馆受到的关注度会有一些差别，因此排队时间的长短也不尽相同。小 Z 根据统计信息给每一个展馆 $(x, y)$ 标记了 $T_{x,y} = 0$ 或 $1$，如果 $T_{x,y} = 1$，表示这个展馆非常热门，需要排很长时间的队；如果 $T_{x,y} = 0$，表示这个展馆相对比较普通，几乎不需要排队即可进入参观。小 Z 希望能够制定一份合理的路线，使得能交替参观热门馆和普通馆，既不会因为总是参观热门馆而长时间在排队，也不会因为总是参观普通馆而使得游览过于平淡。同时，小 Z 办事很讲究效率，她希望在游遍所有展馆的同时，又不会走冤枉路浪费体力。因此她希望旅行路线满足以下几个限制：

1. 在参观完位于 $(x, y)$ 的展馆后，下一个参观的是一个相邻的且未被参观过的展馆 $(x^\prime, y^\prime)$，即 $|x-x^\prime|+|y-y^\prime|=1$；
2. 路线的起点位于整个矩阵的边界上，即 $x = 1$ 或 $x = n$ 或 $y = 1$ 或 $y = m$；

她制定了一个长度为 $n \times m$ 的 01 序列 $L$，她希望第 $i$ 个参观的展馆 $(x,y)$ 满足 $T_{x,y}=L_i$。

小 Z 想知道有多少条不同的旅行路线能够满足她的要求。由于最终的结果可能很大，小 Z 只想知道可行的旅行路线总数 $\bmod\space 11\,192\,869$ 的值。


## 说明/提示

【样例说明】

这四条可行的旅行路线分别为：

$$
\begin{aligned}
(1,1) \to (1,2) \to (2,2) \to (2,1)\\
(1,1) \to (2,1) \to (2,2) \to (1,2)\\
(2,2) \to (1,2) \to (1,1) \to (2,1)\\
(2,2) \to (2,1) \to (1,1) \to (1,2)
\end{aligned}
$$

【数据规模和约定】

- 对于 $10\%$ 的数据：$n=1$；
- 对于 $30\%$ 的数据：$n=2$；
- 对于 $60\%$ 的数据：$n=3$，其中 $20\%$ 的数据 $T_{i,j}$ 全为 $0$；
- 对于 $100\%$ 的数据：$m \leq 50$，$L_i,T_{i,j} = 0$ 或 $1$。

## 样例 #1

### 输入

```
2 2
1 0
0 1
1 0 1 0```

### 输出

```
4
```

# 题解

## 作者：ren482933891 (赞：53)

先吐槽一下

我做这一题的时候，还只做过一道插头dp的模板题。然而我仍然看出了这是一道插头dp，但之后就不会做了。于是我上网搜题解。结果

**一篇题解都搜不到**

没有办法，只能自己动手，丰衣足食

于是我用一个下午复习插头dp，做了两道典型例题，然后第二天上午用半天时间A掉了这道目前通过数6的题目（还有两个是输出答案的）。然后激动之余专门开通了洛谷博客写本题题解

事实上，找到性质之后这题也是比较套路的那种插头dp了

下面开始说正话

## 状态记录
题意可以转化为在方格图上填 $1...n\times m$ 这些数，使其连成一条路径，并且1必须填在边缘的方案数，考虑如何记录状态才能转移

显然，需要知道轮廓线上的n+1个插头的状态，还要知道轮廓线上填的数是什么（才知道现在该填什么），然后这样仍然无法转移，还需要知道到目前为止哪些数已经填过了。总共需要记录这三个东西。

然而由于多了后面那个150位的二进制位来表示每一个数填没填，这些状态无法压到一个int或long long里，而且显然这个状态有点多，跟暴力没什么区别了。

所以需要一个重要的性质
> 如果两个状态轮廓线上的插头完全相同，轮廓线上填的数也完全相同，那么他们已经填过的数的集合也是相同的

也就是说只要前两个东西就可以区分状态了

这个性质大概可以理解为，轮廓线已经完全确定了，又要保证是一条路径，那么两边该填哪些数其实也确定了。（反正我没有举出来反例，就认为他是对的了）

那么就可以记录状态了。

定义3种插头，0表示无插头（不向后延伸），1表示向递减的数延伸，2表示向递增的数延伸

我们需要n个150以内的数，每个数可以用8个二进制位记录

我们需要n+1个0/1/2的数，每个数可以用2个二进制位记录

正好可以压在一个32位整形里

然后就可以每次解码编码，存在哈希表里了，用比较套路的方法

每个状态还要开一个150位的bitset，表示每个数是否填过，为了后面可以转移，已经说过，每个状态只会有一个bitset

## 转移
一般插头dp转移都要大力讨论，此题也不例外
但本题的讨论过于繁琐，很容易重复或遗留因此可以换一种方法

先大概考虑一下当前可以填哪些数，记录在一个数组里，去重

然后一一考虑，判断是否合法。判断合法这个过程相对简单，大力continue就可以了，想到一个条件就continue一下

考虑完填那个数，之后考虑新的插头长什么样。同样还是枚举所有可能的插头，然后大力continue

这部分我为了避免没有考虑的情况，写的比较冗杂，应该有很多条件都是可以精简的。但如果不考虑代码的精致程度的话，只要无脑判断所有非法情况就可以了

如果当前插头也合法，那么转移即可

因此实际上还是很套路的。。。

下面是代码，可读性应该还是很高的

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5, maxm = 55, maxl = 155, mod = 11192869, mo = 500000;
typedef long long ll;
typedef unsigned int uint;
int a[maxn][maxm], L[maxl];
int n, m, pos[maxn], plug[maxn], head[2][500010], tot[2], cur, pre, chc[maxl], ans;
struct State{
	bitset<maxl> used;
	uint stt;
	int val, nxt;
	State() { val = nxt = stt = 0; used.reset(); }
}ptr[2][1001000];
void hah(uint stt, int val, bitset<maxl> &used) {
	int x = stt % mo;
	for(int i = head[cur][x]; i; i = ptr[cur][i].nxt) if(ptr[cur][i].stt == stt) {
		ptr[cur][i].val = (ptr[cur][i].val + val) % mod; return;
	}
	ptr[cur][++tot[cur]].stt = stt;
	ptr[cur][tot[cur]].val = val;
	ptr[cur][tot[cur]].used = used;
	ptr[cur][tot[cur]].nxt = head[cur][x];
	head[cur][x] = tot[cur];
}
uint encode() {
	uint stt = 0;
	for(int i = 1; i <= n; i++) stt = (stt << 8) + pos[i];
	for(int i = 0; i <= n; i++) stt = (stt << 2) + plug[i];
	return stt;
}
void decode(uint stt) {
	for(int i = n; i >= 0; i--) plug[i] = stt & 3, stt >>= 2;
	for(int i = n; i; i--) pos[i] = stt & 255, stt >>= 8; 
}
void solve() {
	bitset<maxl> used;
	used.reset();
	cur = 0; pre = 1; hah(0, 1, used);
	for(int j = 1; j <= m; j++) {
		// 新的一行要把plug整体右移
		for(int t = 1; t <= tot[cur]; t++) {
			decode(ptr[cur][t].stt);
			for(int i = n - 1; i >= 0; i--) plug[i + 1] = plug[i]; 
			plug[0] = 0;
			ptr[cur][t].stt = encode();
		}
		for(int i = 1; i <= n; i++) {
			swap(cur, pre); tot[cur] = 0;
			memset(head[cur], 0, sizeof(head[cur]));
			for(int t = 1; t <= tot[pre]; t++) {
				uint stt = ptr[pre][t].stt; 
				int val = ptr[pre][t].val;
				used = ptr[pre][t].used;
				decode(stt);
				int r = plug[i - 1], d = plug[i];
				int cnt = 0;
				if(!r && !d) for(int i = 1; i <= n * m; i++) chc[++cnt] = i;
				else {
					if(r == 1) chc[++cnt] = pos[i-1] - 1;
					else if(r == 2) chc[++cnt] = pos[i-1] + 1;
					if(d == 1) chc[++cnt] = pos[i] - 1;
					else if(d == 2) chc[++cnt] = pos[i] + 1;
				}
				// 当前位置可能会填哪些数
				sort(chc + 1, chc + 1 + cnt);
				cnt = unique(chc + 1, chc + 1 + cnt) - chc - 1;
				for(int hh = 1; hh <= cnt; hh++) {
					int x = chc[hh]; // 枚举当前位置填的数，判断是否合法
					if(a[i][j] != L[x]) continue; if(used[x]) continue;
					if(r == 1 && x != pos[i - 1] - 1) continue;
					if(r == 2 && x != pos[i - 1] + 1) continue;
					if(d == 1 && x != pos[i] - 1) continue;
					if(d == 2 && x != pos[i] + 1) continue;
					if(x == 1 && i > 1 && i < n && j > 1 && j < m) continue;
					if(i == n && j == m) ans = (ans + val) % mod;
					used[x] = 1; int od = pos[i]; pos[i] = x;
					// cout << x << endl;
					for(int npr = 0; npr <= 2; npr++) 
						for(int npd = 0; npd <= 2; npd++) {
							// 枚举新的插头，判断是否合法，这部分我写的比较冗杂，或许可以精简一下
							int pnum = (r > 0) + (d > 0) + (npr > 0) + (npd > 0);
							if(x != 1 && x != n * m && pnum != 2) continue;
							if((x == 1 || x == n * m) && pnum != 1) continue;
							if(npr == npd && npr) continue;
							if(j == m && npr) continue; if(i == n && npd) continue;
							if((npr == 1 || npd == 1) && used[x - 1]) continue;
							if((npr == 2 || npd == 2) && used[x + 1]) continue;
							if(npr == 1 && a[i][j+1] != L[x - 1]) continue;
							if(npr == 2 && a[i][j+1] != L[x + 1]) continue;
							if(npd == 1 && a[i+1][j] != L[x - 1]) continue;
							if(npd == 2 && a[i+1][j] != L[x + 1]) continue;
							// 当前转移合法，更新下一位置的状态和dp值
							plug[i - 1] = npr; plug[i] = npd;
							hah(encode(), val, used);
							plug[i - 1] = r; plug[i] = d;
						}
					used[x] = 0; pos[i] = od;
				}
			}
		}
	}
}
int main() {
	// printf("%lf\n", (double)(&b2-&b1)/1024/1024);
	// freopen("trip.in", "r", stdin);
	// freopen("trip.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) scanf("%d", &a[i][j]);
	for(int i = 1; i <= n * m; i++) scanf("%d", &L[i]);
	L[0] = L[n * m + 1] = 521;
	for(int i = 0; i <= m + 1; i++) a[0][i] = a[n + 1][i] = 233;
	for(int i = 1; i <= n; i++) a[i][0] = a[i][m + 1] = 233;
	solve();
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：青君 (赞：39)

 _Update 2020.9.17:  修改了一处表述错误（2个字）。 _  

标签：插头DP。
## 简化题意
给你一个 $n*m$ 的 01 表格。你要找到一条哈密顿路径（经过所有点恰好一次），满足：1) 起点在表格边缘；2）路径上的值连接起来恰好等于一个给定的 01 序列。求方案数。  
$n\le 3,m\le 50$。

## 题目分析&状态设计
大家都能看出来是个插头DP吧？  

但是好像找不着状态。这时最好观察一下我们计数对象的特征。

来个 $3*5$ 的：

![](https://cdn.luogu.com.cn/upload/image_hosting/kg1zair6.png)

我们用 $[1,n*m]$ 内的数字给路径标号。

![](https://cdn.luogu.com.cn/upload/image_hosting/my1xkaif.png)

发现相邻数字间只有 $3$ 种关系：
1. 不连缀。
2. 连缀且递增。
3. 连缀且递减。   

可以把它们定义为 $3$ 种插头：  
1. 空插头（记作 0）。
2. 递增插头（记作 1）。
3. 递减插头（记作 2）。

继续观察，显然地：
1. `1` 恰有一个 1插头。
2. `n*m` 恰有一个 2插头。
3. 其他数字恰有一个 1插头 和一个 2插头。

现在插头的转移已经可以确定了。  

要保证不填重复的数字，我们还得知道一条轮廓线上方已经填过哪些数字，对于每个轮廓线开一个bitset？是否会存在轮廓线相同但已填数字集合不同的情况呢？答案是不会。举个例子~~感性~~理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ra4xt3qr.png)

观察这条轮廓线（橙色粗线），线上有连通块 `3-4` 和 `11`。轮廓线上方的数字要么与 `3-4` 以 1插头 联通，要么 与 `11` 以 2插头 联通。因此可以**唯一确定**上方的数字集合为 $[1,2]\cup[12,15]$。

## DP转移
有经验的选手应该是不需要这部分的。但是为了方便大家调试，我在此写一下插头DP时的分类讨论。 

设 $ct_0$ 为左插头，$ct_1$ 为上插头，$nm_0$ 为左边格子填的数字，$nm_1$ 为上边格子填的数字。  

1. $!ct_0$ && $!ct_1$  
如果填 `1`，插入一个向下或向右的 1插头。  
如果填 `n*m`，插入一个向下或向右的 2插头。  
其它数字，插入一个 1插头 和一个 2插头，其中一个向下一个向右。
2. $ct_0$ && $ct_1$   
这时必须满足 $ct_0+ct_1=3$ 且 $|nm_0-nm_1|=2$ 才能转移，且只能填  `(nm_0+nm_1)/2` ，无插头。
3. $ct_0$ && $!ct_1$  
（1） $ct_0=1$。只能填 `nm_0+1`，如果 $nm_0+1\neq n*m$，插入一个向下或向右的 1插头；否则，无插头。  
（2） $ct_0=2$。只能填 `nm_0-1`，如果 $nm_0-1\neq 1$，插入一个向下或向右的 2插头；否则，无插头。
4. $ct_1$ && $!ct_0$   
与 3. 一模一样。

**上面这些算特殊规则，还有通用规则：**
1. 已经填过的数字不能再填。
2. 下边没有格子时不能插下插头，右边没有格子时不能插右插头。
3. 必须满足一开始给出的 01 序列的限制。
4. 如果要填 `1`，还需检查是否在边缘。

## 代码实现
轮廓线上最多 $n+1=4$ 个插头，每个插头需要 $2$ 位存插头类型 + $8$ 位存填的数字，共计 $40$ 位（实际上一条轮廓线上最多 $3$ 个数字， $32$ 位就够了，但我比较懒），使用  `ungsigned long long` 记录状态。不用 `long long` 的理由是可能左移时炸出负数。我以前写插头DP时从没遇到这种情况，害我调了好久。以后记住吧。  

其实这题在插头DP中还算简单的，核心代码很短。
```cpp
#include<bits/stdc++.h>
#define mk make_pair
#define pk push_back 
using namespace std;
typedef unsigned long long LL;
typedef pair<int,int> pi;
template<class T> bool cmax(T &x,T y){return y>x?x=y,1:0;}
template<class T> bool cmin(T &x,T y){return y<x?x=y,1:0;}
const int N=3,M=50,mod=11192869,P=133333,H=1e6;
int n,m,lst,cur,ans,a[N+1][M+1],b[N*M],tot[2],head[P],nxt[H],v[2][H];
LL q[2][H];
bitset<N*M> c[2][H];
void hsh(LL sta,int val,bitset<N*M> &c){
	int key=sta%P;
	for(int i=head[key];i;i=nxt[i])if(q[cur][i]==sta)
		return (v[cur][i]+=val)%=mod,void();
	int nw=++tot[cur];
	nxt[nw]=head[key];
	head[key]=nw;
	q[cur][nw]=sta;
	v[cur][nw]=val;
	::c[cur][nw]=c;
} 
void insert(int a,int b,int t,int i,int j,bitset<N*M> &c,LL &nw,int bs[2][2],int &val){
	if(c.test(t)) return ;
	if(a&&i==m) return ;
	if(b&&j==n) return ;
	if(!t&&!(i==1||i==m||j==1||j==n)) return ;
	if(::b[t]!=::a[n-j+1][i]) return ;
	if(i+j==n+m) return (ans+=val)%=mod,void();
	c.set(t);
	hsh(nw|1ll*(a)<<bs[0][0]|1ll*(b)<<bs[1][0]|1ll*(t)<<bs[0][1]|1ll*(t)<<bs[1][1],val,c);
	c.reset(t);
}
void dp(){
	cur=0,lst=1;
	bitset<N*M> st;
	hsh(0,1,st);//初值 
	for(int i=1;i<=m;++i){
		for(int j=1;j<=tot[cur];++j) q[cur][j]<<=10;//一定要用unsigned long long，不然这里会炸出负数 
		for(int j=1;j<=n;++j){
			swap(cur,lst);
			memset(head,0,sizeof head);tot[cur]=0;
			for(int t=1;t<=tot[lst];++t){
				LL &sta=q[lst][t];int &val=v[lst][t];
				bitset<N*M> &c=::c[lst][t];
				int bs[2][2]={(j-1)*10,(j-1)*10+2,j*10,j*10+2};
				int ct[2]={sta>>bs[0][0]&3,sta>>bs[1][0]&3};//0：空插头，1：递增，2：递减 
				int nm[2]={sta>>bs[0][1]&255,sta>>bs[1][1]&255};//数字：[0,n*m-1] 
				LL nw=sta-(1ll*ct[0]<<bs[0][0])-(1ll*ct[1]<<bs[1][0])-(1ll*nm[0]<<bs[0][1])-(1ll*nm[1]<<bs[1][1]);
				#define ins(a,b,t) insert(a,b,t,i,j,c,nw,bs,val) //a:下插头，b:右插头，t:数字 
				
				if(!ct[0]&&!ct[1]){
					ins(1,0,0),ins(0,1,0);
					ins(2,0,n*m-1),ins(0,2,n*m-1);	
					for(int k=1;k<n*m-1;++k) 
						ins(1,2,k),ins(2,1,k);
				}
				else if(ct[0]&&ct[1]){
					if(ct[0]+ct[1]==3&&abs(nm[0]-nm[1])==2) 
						ins(0,0,(nm[0]+nm[1])>>1);
				}
				else{
					int k=ct[0]?0:1;
					if(ct[k]==1){
						if(nm[k]+1==n*m-1) ins(0,0,nm[k]+1);
						else ins(1,0,nm[k]+1),ins(0,1,nm[k]+1);
					}
					if(ct[k]==2){
						if(nm[k]-1==0) ins(0,0,nm[k]-1);
						else ins(2,0,nm[k]-1),ins(0,2,nm[k]-1);
					}
				}
			}
		} 
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j) cin>>a[i][j];
	for(int i=0;i<n*m;++i) cin>>b[i];
	dp();
	cout<<ans<<endl;
	return 0;
}
```


---


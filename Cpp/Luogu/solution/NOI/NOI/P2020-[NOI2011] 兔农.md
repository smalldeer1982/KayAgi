# [NOI2011] 兔农

## 题目描述

农夫栋栋近年收入不景气，正在他发愁如何能多赚点钱时，他听到隔壁的小朋友在讨论兔子繁殖的问题。

问题是这样的：第一个月初有一对刚出生的小兔子，经过两个月长大后，这对兔子从第三个月开始，每个月初生一对小兔子。新出生的小兔子生长两个月后又能每个月生出一对小兔子。问第 $n$ 个月有多少只兔子？

聪明的你可能已经发现，第 $n$ 个月的兔子数正好是第 $n$ 个 Fibonacci（斐波那契）数。栋栋不懂什么是 Fibonacci 数，但他也发现了规律：第 $i+2$ 个月的兔子数等于第 $i$ 个月的兔子数加上第 $i+1$ 个月的兔子数。前几个月的兔子数依次为：

$$1,1,2,3,5,8,13,21,34,\ldots$$

栋栋发现越到后面兔子数增长的越快，期待养兔子一定能赚大钱，于是栋栋在第一个月初买了一对小兔子开始饲养。

每天，栋栋都要给兔子们喂食，兔子们吃食时非常特别，总是每 $k$ 对兔子围成一圈，最后剩下的不足 $k$ 对的围成一圈，由于兔子特别害怕孤独，从第三个月开始，如果吃食时围成某一个圈的只有一对兔子，这对兔子就会很快死掉。

我们假设死去的总是刚出生的兔子，那么每个月的兔子数仍然是可以计算的。例如，当 $k=7$ 时，前几个月的兔子数依次为：

$$1,1,2,3,5,7,12,19,31,49,80,\ldots$$

给定 $n$，你能帮助栋栋计算第 $n$ 个月他有多少对兔子么？由于答案可能非常大，你只需要告诉栋栋第 $n$ 个月的兔子对数除 $p$ 的余数即可。


## 说明/提示

|测试点编号|$n$|$k,p$|
|:-:|:-:|:-:|
|$1\sim 10$|$1\leq n\leq 50$|$2\leq k,p\leq1000$|
|$11$|$1\leq n\leq 80$|$2\leq k,p\leq 10^4$|
|$12,13$|$1\leq n\leq 1000$|$2\leq k,p\leq 10^4$|
|$14,15$|$1\leq n\leq 10^6$|$2\leq k,p\leq 10^6$|
|$16,17$|$1\leq n\leq 10^{18}$|$2\leq k,p\leq1000$|
|$18\sim 20$|$1\leq n\leq 10^{18}$|$2\leq k\leq 10^6$，$2\leq p\leq 10^9$|

对于 $100\%$ 的数据，$1\leq n\leq 10^{18}$，$2\leq k\leq 10^6$，$2\leq p\leq 10^9$。


## 样例 #1

### 输入

```
6 7 100```

### 输出

```
7```

## 样例 #2

### 输入

```
7 7 5```

### 输出

```
2```

# 题解

## 作者：TimWYZ (赞：16)

### I 题意

给定整数 $n, k, P$ 

对于数组 $F$ 有：  

$F_1 = F_2 = 1$  

$F_{i (i \ge 3)} = \begin{cases} 
	F_{i-1} + F_{i-2},     & (F_{i-1} + F_{i-2})\mod k \neq 1 \cr 
    F_{i-1} + F_{i-2} - 1, & (F_{i-1} + F_{i-2})\mod k = 1 \cr 
	\end{cases}$
    
求 $F_n \mod P$

### II 规律

假设 $ k = 7$ . 我们写出 $F$ 数组的前 $30$ 项在模 $k$ 意义下的值，每当出现 $-1$，就换行。

```
1 1 2 3 5 0
5 5 3 0
3 3 6 2 0
2 2 4 6 3 2 5 0 5 5 3 0
3 3 6 2 0
2 2 4 6 3 2 5 0 5 5 3 0
3 3 6 2 0
2 ...
```

可以发现，

```
3 3 6 2 0
2 2 4 6 3 2 5 0 5 5 3 0
```

就是一个循环节。在这个循环节当中，有几个性质  
1. 对于循环节中的每一段，假设开头的数为 $x$ ，那么数列为 $x, x, 2x, 3x, 5x, 8x ...$ ，也是一个斐波那契数列。当遇到数列中某一项 $\mod k = 1$ 时，数列结束  
2. 从 1 可以得出，只要给定了数列开始的数，我们就能得知整个数列。
3. 一个段开始的数是上一个段的倒数第二个数。

通过这几个规律，我们就能搭建起这道题完整的解题框架了。

### III 做法

既然有了循环节，我们就能通过循环节以及矩阵快速幂，快速算出 $F_n\mod P$。那么一个问题就是，如何寻求循环节？

在上面的规律中，我们发现，如果一个段开头是 $x$，长度为 $len$，普通的斐波那契数列的第 $i$ 项为 $fib_i$ ，那么这个段末尾的数（也就是要$-1$）的数就是 $x * fib_{len}$。我们要让它 $x * fib_{len}\mod K = 1$。看着是不是很眼熟？对，它就是乘法逆元。

因此，如果我们知道了 $x$，就能快速算出 $fib_{len}$，反之如果知道了 $fib_{len}$，也能快速算出 $x$。在这里我选择通过枚举 $fib_{len}$ 计算 $x$。枚举斐波那契数列的每一项 $fib_{i}$，通过 $exGCD$ 算出它的逆元 $inv$，对 $k$ 取模得到 $x$，我们就能得出以 $x$ 开头的段的长度为 $i$。

然后从 $1$ 开始，每次计算以这个数为第一个数的段的末尾数，判断其之前是否出现过。如果出现，那么找到循环节；如果没出现，再将其作为段的开始迭代，直到找到循环节为止。

​	**特殊情况** 

​		如果 $a, b$ 不互质，那么 $a$ 就没有 $\mod b$ 意义下的逆元。在这道题目中，我们也没法保证每个 $x$ 都有 $\mod k$ 意义下的逆元。如果没有，那么情况将会如何呢？

​		我们设 $k = 10$ （非质数），并写出它的前 $30$ 项。

	1 1 2 3 5 8 3 0
	3 3 6 9 5 4 9 3 2 5 7 2 9 0
	9 9 8 7 5 2 7 9 6 5 0
	5 5 0 5 5 0 5 5 0 5 5 0 5 5 0 5 5 		

​		可以看出，在最末一行陷入了死循环，没有循环节。对于这种情况，我们要特殊判断，特殊处理。

得出每段长度 $len$ 后，我们就可以着手推每个循环节的转移矩阵了。

对于一个行向量 $mat_{i}$ 代表数列的第 $i$ 项：
$$
\left[ 
  \begin{matrix}
     F_{i} & F_{i - 1} & 1
    \end{matrix}
\right]
$$
定义转移矩阵 $tr1$:
$$
\left[ 
  \begin{matrix}
     1 & 1 & 0 \\
     1 & 0 & 0 \\
     0 & 0 & 1 \\
    \end{matrix}
\right]
$$
当需要 $-1$ 时，定义转移矩阵 $tr2$:
$$
\left[ 
  \begin{matrix}
     1 & 1 & 0 \\
     1 & 0 & 0 \\
     -1 & 0 & 1 \\
    \end{matrix}
\right]
$$
那么，如果一个段的初始状态为 $mat$，长度为 $len$，那么它的结束状态就是 $mat * tr1 ^ {len - 1} * tr2$。
通过这一规律，我们就能算出每个循环节的总转移矩阵，然后计算出 $F_n \mod P$

**注意：矩阵乘法全部是在 $\mod P$ 意义下进行的。**

另外一些细节详见代码。

```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;

typedef long long ll;
const int KR = 1e6 + 10, SZ = 3;

ll n, k, P;
ll kcnt = 0;
ll f[6 * KR], len[KR], seq[KR], vis[KR]; 
// f[i] 代表斐波那契第 i 位，len[i] 代表以 i 为开头的段的长度，seq 中存储所有段的开头，vis[i] 记录 i 作为开头的位置。
bool flag;

ll GCD(ll a, ll b) { // 由于还要判断是否存在逆元（互质），因此还需要一个朴素的GCD。
	if (!b) return a;
	return GCD(b, a % b);
}

void exGCD(ll a, ll b, ll &x, ll &y) {
	if (!b) {
		x = 1, y = 0;
		return;
	}
	exGCD(b, a % b, x, y);
	ll t = x;
	x = y;
	y = t - a / b * y;
}

ll getInv(ll a, ll P) {
	if (GCD(a, P) != 1) return -1; // 不互质，无逆元。
	ll x, y;
	exGCD(a, P, x, y);
	return (x % P + P) % P;
}

struct Matrix {
	ll o[SZ + 1][SZ + 1];

	Matrix() {
		memset(o, 0, sizeof(o));
	}

	Matrix operator * (const Matrix &x) const {
		Matrix ret;
		for (int i = 1; i <= SZ; i++)
			for (int j = 1; j <= SZ; j++)
				for (int k = 1; k <= SZ; k++)
					ret.o[i][j] = (ret.o[i][j] + o[i][k] * x.o[k][j] + P) % P;
		return ret;
	}
} mat, tr1, tr2, tr;

Matrix quickPower(Matrix a, ll b) {
	Matrix ret;
	for (int i = 1; i <= SZ; i++) ret.o[i][i] = 1;

	while (b) {
		if (b & 1) ret = ret * a;
		a = a * a;
		b >>= 1;
	}
	return ret;
}

int main()
{
	freopen("luogu.in", "r", stdin);
	freopen("luogu.out", "w", stdout);

	scanf("%lld%lld%lld", &n, &k, &P);

	if (n == 1 || n == 2) {
		printf("1\n");
		return 0;
	}

	memset(len, 999999, sizeof(len));
	f[1] = f[2] = 1;

	for (ll i = 3; ; i++) {
		f[i] = (f[i - 1] + f[i - 2]) % k;
		if (f[i] % k == 1 && len[1] > 1e18) len[1] = i; // 需要特殊计算 1 开头的长度
		if (f[i] == 1 && f[i - 1] == 1) break;

		ll inv = getInv(f[i], k);
		if (inv != -1) len[inv % k] = min(len[inv % k], i);
	}

	ll now = 1, tot = 0;
	while (1) {
		seq[++kcnt] = now;
		vis[now] = kcnt;
		if (len[now] > 1e18) { // 如果没有逆元
			for (int i = 1; i < kcnt; i++) tot += len[seq[i]]; // 计算之前段的总长
			flag = 1;
			break;
		}

		now = (now * f[len[now] - 1]) % k;
		if (vis[now]) { // 这个数之前出现过，发现循环节
			for (int i = 1; i < vis[now]; i++) tot += len[seq[i]]; // 计算循环节之前段的总长
			break;
		}
	}

	mat.o[1][1] = mat.o[1][3] = 1;
	tr1.o[1][1] = tr1.o[1][2] = tr1.o[2][1] = tr1.o[3][3] = 1;
	tr2.o[1][1] = tr2.o[1][2] = tr2.o[2][1] = tr2.o[3][3] = 1;
	tr2.o[3][1] = -1;

	if (n <= tot) { // 要特别判断如果 n 在无逆元序列 / 循环节之前的情况（两个样例都是这种情况），暴力一段一段算
		len[1]--; // 初始已经算出了 F[1]，因此第一段的长度要 -1 ，n 随之也 -1
		n--;
		for (int i = 1; i < vis[now]; i++) {
			if (n >= len[seq[i]]) { // 假设 n 还够完整的一段，直接矩阵快速幂
				mat = mat * quickPower(tr1, len[seq[i]] - 1) * tr2; 
				n -= len[seq[i]];
			} else { // 否则暴力乘
				mat = mat * quickPower(tr1, n);
				printf("%lld\n", mat.o[1][1]);
				return 0;
			}
		}
	} else {
		len[1]--;
		n -= tot;

		for (int i = 1; i < vis[now]; i++) mat = mat * quickPower(tr1, len[seq[i]] - 1) * tr2; // 此处要计算出进入循环节前的状态

		if (flag) { // 无逆元情况，直接用 tr1 快速幂
			mat = mat * quickPower(tr1, n);
			printf("%lld\n", mat.o[1][1]);
		} else {
			ll loopLen = 0;
			for (ll i = 1; i <= SZ; i++) tr.o[i][i] = 1;
			for (ll i = vis[now]; i <= kcnt; i++) { // 否则计算循环节的总转移矩阵 tr
				tr = tr * quickPower(tr1, len[seq[i]] - 1) * tr2;
				loopLen += len[seq[i]];
			}
			ll tmp = n / loopLen; // 算一下 n 中有几个完整的循环节
			mat = mat * quickPower(tr, tmp);
			n = n - loopLen * tmp; // 剩下的部分暴力算
			
			for (ll i = vis[now]; i <= kcnt; i++) {
				if (n >= len[seq[i]]) { // 假设 n 还够完整的一段，直接矩阵快速幂
					mat = mat * quickPower(tr1, len[seq[i]] - 1) * tr2;
					n -= len[seq[i]];
				} else { // 否则暴力乘
					mat = mat * quickPower(tr1, n);
					printf("%lld\n", mat.o[1][1]);
					return 0;
				}
			}
		}

	}

	return 0; 
}
```

---

## 作者：zqy1018 (赞：11)

貌似没有人发题解？我贡献一发

（本题解参考了jcvb和vfleaking两位大佬的题解）

题目肯定是和斐波那契数列有关，但有关在哪里呢？

由于有取模，所以我们看看有没有什么和循环有关的性质。

我们设fib[i]为斐波那契数列的第i项，而设F[i]为该数列的第i项。

把k=7作为例子，观察F[i]对k取模的序列：

1,1,2,3,5,0,

5,5,3,0,

3,3,6,2,0,

2,2,4,6,3,2,5,0,5,5,3,0, （之所以这一段前面的0不算是一段的结尾，是因为这个0不是由于减了一个1而产生的）

3,3,6,2,0,...

设fib[0]=0，则可以发现：

1.每一段的开头两个数都是相同的两个数，并且正好就是前面那一个段的最后一个非0数。

同时只有除k和0以外的k-1种数，所以最多在不超过k段的情况下就会出现循环。

（假设这个循环是存在的话。）

2.对于某一段而言，这一段都相当于一段小的斐波那契数列。

比如说某一段的开头是x，那么这一段就是

x,x,2x,3x,5x,8x,...

换言之，这一段的第i个数就是fib[i]\*x。

如果这一段有长度，那么设长度是Len，则x\*fib[Len] mod k==1.

这个时候就是我们要减掉1的时候。

 
有了以上的推导，我们不难得出具体算法：

1.根据x\*fib[Len] mod k==1求出fib[Len]

2.反推出Len

3.求出下一段的开头，也就是x\*fib[Len-1]，转回1

 
第一步里头，不难发现fib[Len]就是x-1(mod k)，所以如果逆元都不存在的话这就成了裸题。

否则，用extgcd算出逆元。

第二步，预处理出对于每个i，fib[Len]==i的最小Len。如果是不存在，那么也变成了矩阵乘法裸题。

但是可能这个Len很大啊？

有2个方法：1.估计一下fib mod k的循环节长度，直接算

2.数学证明

vfk大佬的博客上有证明，我不会证，只知道了结论：fib mod k的循环节是以0,1,1位开头的，且长度不超过6k。

就直接算了。

第三步，由于直接模拟可能超时，所以要用矩阵快速幂。


在完成了以上几步之后就是喜闻乐见的分类讨论了。。。

本题矩阵乘法要用2个矩阵，一个计算fib的矩阵和一个令fib[n]减1的矩阵，这两个都不难写，可以自己手算实现。

代码为了表达的详细写的很长，要看的话请移步[此处](http://leanote.com/blog/post/5955dff6ab64414a81000b71)。

（顺便推销了博客）


---

## 作者：Space_Gold_Trash (赞：7)

很有趣的一道题

看到这种求数列的题就感觉是矩阵快速幂

接近于求个斐波拉契数列

但是中间会有转移方程不同的地方

很烦

那么我们就可以想到通过要减一的地方分段矩阵快速幂,那就可以解决这一个问题

很显然,斐波拉契在$mod\space p$下是会有循环节的

那么就可以通过找到循环节然后进行分段了

但是我们还有一个性质

如果$fib_{i-1}+fib_{i-2}\equiv 1\pmod k$

那么$fib_i=fib_{i-1}+fib_{i-2}-1$

否则$fib_i=fib_{i-1}+fib_{i-2}$

那么我们可以发现一个有趣的性质

如果满足$fib_{i-1}+fib_{i-2}\equiv 1\pmod k$

那么$fib_i\equiv 0 \pmod k$

而且$fib_{i+1}=fib_{i+2}$

那么我们把$fib_i\equiv 0\pmod k$的数拿来分段

我们可以发现每一段的数都是数列普通斐波拉契与一个数的乘积

那么我们关键便是找出这个数字

我们发现他满足同余方程$x*fib_j \equiv1 \pmod{k}$

那么我们只要预处理出所有的$fib_j$的逆元即可

然后通过矩阵快速幂分段搞即可,矩阵也很好推

```
#include<bits/stdc++.h>
#define re return
#define ll long long
#define N 2000011
using namespace std;
ll n,k,p;
struct Jack{
	ll f[4][4];
	Jack(){memset(f,0,sizeof(f));}
	inline Jack operator *(const Jack &b)const{
		Jack ans;
		int i,j,k;
		for(k=1;k<=3;++k)
		for(i=1;i<=3;++i)
		for(j=1;j<=3;++j)
		ans.f[i][j]=((ans.f[i][j]+f[i][k]*b.f[k][j]%p)%p+p)%p;
		re ans;
	}
	inline void one( ){
		int i,j;
		for(i=1;i<=3;++i)f[i][i]=1;
	}
	inline void pre_one( ){
		f[1][1]=f[1][2]=f[2][1]=f[3][3]=1;
	}
	inline void pre_two( ){
		pre_one( );
		f[3][1]=-1;
	}
	inline void pre_three( ){
		f[3][1]=f[3][3]=1;
	}
};
inline Jack qui(Jack a,ll b){
	Jack ans;
	ans.one( );
	while(!!b){
		if(b&1)ans=ans*a;
		a=a*a,b>>=1;
	}
	re ans;
}
inline void exgcd(ll a,ll b,ll &x,ll &y,ll &d){
	if(!b){d=a,x=1,y=0;return;}
	exgcd(b,a%b,y,x,d);
	y-=a/b*x;
}
inline ll getinv(ll a,ll p){
	ll x,y,d;
	exgcd(a,p,x,y,d);
	if(d!=1)re -1;
	re (x%p+p)%p;
}
ll f[N],len[N],tot,q[N],vis[N];
int main( ){
	scanf("%lld%lld%lld",&n,&k,&p);
	int i;
	f[1]=f[2]=1;
	if(n<=2){puts("1");re 0;}
	for(i=3;i<=2e6;++i){
		f[i]=(f[i-1]+f[i-2])%k;
		if(f[i]==1&&!len[1])len[1]=i;
		ll inv(getinv(f[i],k));
		if(inv!=-1&&!len[inv])len[inv]=i;
	}
	ll now(1),t(0),l;
	int flag(0);
	while(1){
		l=len[now];
		q[++tot]=now,vis[now]=tot;
		if(!l){
			for(i=1;i<tot;++i)t+=len[q[i]];
			flag=1;
			break;
		}
		now=(now*f[l-1])%k;
		if(!!vis[now]){
			for(i=1;i<vis[now];++i)t+=len[q[i]];
			break;
		}
	}
	Jack a,tr1,tr2;
	tr1.pre_one( ),tr2.pre_two( ),a.pre_three( );
	if(n<=t){
		--len[1],--n;
		for(i=1;i<vis[now];++i)
		if(n>=len[q[i]]){
			a=a*qui(tr1,len[q[i]]-1)*tr2;
			n-=len[q[i]];
		}else{
			printf("%lld\n",(a*qui(tr1,n)).f[3][1]);
			re 0;
		}
	}else{
		--len[1];
		n-=t;
		for(i=1;i<vis[now];++i)a=a*qui(tr1,len[q[i]]-1)*tr2;
		if(!!flag){
			printf("%lld\n",(a*qui(tr1,n)).f[3][1]);
			re 0;
		}else{
			ll size(0);
			Jack tr;
			tr.one( );
			for(i=vis[now];i<=tot;++i){
				tr=tr*qui(tr1,len[q[i]]-1)*tr2;
				size+=len[q[i]];
			}
			a=a*qui(tr,n/size);
			n=n%size;
			for(i=vis[now];i<=tot;++i)
			if(n>=len[q[i]]){
				a=a*qui(tr1,len[q[i]]-1)*tr2;
				n-=len[q[i]];
			}else{
				
				printf("%lld\n",(a*qui(tr1,n)).f[3][1]);
				re 0;
			}
		}
	}
//	puts("WORK");
}
```

---

## 作者：Wilderness_ (赞：4)

## 题意
给定 $n,p,k$ 以及函数
$$f(i)=\begin{cases}1\ ,\ i\le 2\\f(i-1)+f(i-2)\ ,\ f(i-1)+f(i-2)\bmod k\ne 1\\f(i-1)+f(i-2)-1\ ,\ f(i-1)+f(i-2)\bmod k=1\end{cases}$$
求 $f(n)\bmod p$ 的值。

## 思路
### subtask 1：
我们按题意模拟，直接求斐波那契数列之后判断是否取模 $k$ 后等于 $1$，若等于，则在取模 $m$ 后 $-1$。

结果光荣得了 $75$ 分。$O(n^2)$ 的算法应需优化，想到矩阵快速幂。结果使用矩阵快速幂不考虑其他，直接在每次乘完后判断是否 $\bmod k$ 为 $1$，然后只拿了 $55$ 分，分析后发现取模 $m$ 后有可能使原取模 $k$ 时等于 $1$ 的值不满足取模 $k$ 时不等于 $1$。试推另一种解法。

### subtask 2：
我们先以第一组样例为例子模拟：
```
1,1,2,3,5,7,12,19,31,49,80,129......
```
然后以每次减一的那个值为分界线隔开，得到：
```
1,1,2,3,5,7(8-1)
12,19,31,49(50-1)
80,129,209,338,546(547-1)
885,1432,1770,3202,4972,8174,13146,21320,34466,55786,90251(90252-1)
......
```
我们对于每一组对 $7$ 进行取模处理，可得：
```
1 1 2 3 5 0(1)
5 5 3 0(1)
3 3 6 2 0(1)
2 2 4 6 3 2 5 0 5 5 3 0(1)
......
```
看到 `5 5 3 0` 开始重复，我们猜想除前两组外，每两组为一个循环（其实第二组也可以看作是一个循环被截开）。

根据计算，我们可以发现与猜想完全符合（也就是 $k=7$ 时，
```
3 3 6 2 0(1)
2 2 4 6 3 2 5 0 5 5 3 0(1)
```
为一个循环节。

我们不难发现循环节内 $3+3\equiv 6\pmod 7,\ 3+6\equiv 2\pmod 7$，也就是每一个循环节内部在出现一个数取模 $7$ 等于 $1$ 之前也都是一个斐波那契数列。比如 `3 3 6 2 0(1)` 和 `2 2 4 6 3 2 5 0 5 5 3 0(1)` 各为一个斐波那契数列。

总结一下，一个循环节内部有如下性质：
1. 以取模 $k$ 等于 $1$ 的数切割循环节，每一个小段都是斐波那契数列，即令第一项为 $x$，则数列形为 $x,x,2x,3x,5x,8x,\cdots$。
2. 对于不为第一小段的数列，第一项为上一小段的倒数第二位（即取模 $k$ 等于 $1$ 的数前一位）。

### subtask 3：
既然得出了循环节，我们又可以通过矩阵快速幂求斐波那契数列，快速计算 $f(n)\bmod p$，这道题目就结束了。

~~此题解结~~。

等等，我们好像还不知道循环节怎么求，总不可能对于每一个数字打表找一遍吧，可是 $2\le k\le 10^6$ 的数据范围，肯定行不通。

我们再根据上述的样例找找规律。不难发现，如果一个小段数列首项是 $x$，数列长度为 $l$，斐波那契数列的第 $i$ 项为 $F(i)$，那么这个段最后一位（也就是会被 $-1$ 的那个数）就是 $x\times F(l)$。我们要让这个数，也就是 $x\times F(l)\equiv 1\pmod k$，学习过乘法逆元的都知道这是什么。

所以，我们只要知道了数列首项 $x$，就能计算出 $F(l)$，从而推出 $l$ 的值，反之亦然。由于 $F(i)$ 的每一项我们都可以直接求得，然而 $x$ 我们未知，我们便可以通过枚举 $F(l)$ 的值来反推出 $x$。

求逆元的方法不多说，使用 $exgcd$ 求即可（线性推或许空间不太够）。求出逆元 $inv$ 之后对 $k$ 取模就得到了 $x$ 的值，同时就把 $x$ 和数列长度 $l$ 一一对应起来了。

然后我们从 $1$ 开始枚举，计算当它为 $x$ 时的末项数字并观察是否出现过。若出现过，那么循环节便找到了；若没出现过那么将计算得到的末项数字继续计算以其为首项的末项数字并查找是否出现，直至找到循环节。

找到循环节之后，我们可以先对进入循环节前的部分暴力用矩阵快速幂一段一段处理，然后对于整段的循环节矩阵快速幂，再对构不成整段循环节的部分直接乘（有一种分块后处理整块和散块的感觉）。

至于矩阵快速幂的转移矩阵，我们分成在小段末尾的和不在小段末尾的：
1. 不在小段末尾时，

$\begin{bmatrix}f(i),\ f(i-1),\ 1\end{bmatrix}=\begin{bmatrix}1,\ 1,\ 0\\1,\ 0,\ 0\\0,\ 0,\ 1\\\end{bmatrix}\times \begin{bmatrix}f(i-1),\ f(i-2),\ 1\end{bmatrix}$，

所以转移矩阵 $base1=\begin{bmatrix}1,\ 1,\ 0\\1,\ 0,\ 0\\0,\ 0,\ 1\\\end{bmatrix}$

2. 在小段末尾时，因为要 $-1$，所以

$\begin{bmatrix}f(i),\ f(i-1),\ 1\end{bmatrix}=\begin{bmatrix}1,\ 1,\ 0\\1,\ 0,\ 0\\-1,\ 0,\ 1\\\end{bmatrix}\times \begin{bmatrix}f(i-1),\ f(i-2),\ 1\end{bmatrix}$，

所以转移矩阵 $base2=\begin{bmatrix}1,\ 1,\ 0\\1,\ 0,\ 0\\-1,\ 0,\ 1\\\end{bmatrix}$。

### subtask extra：
我们再考虑另一种情况：如果 $k$ 与 $x,F(l)$ 其一不互质，则 $x$（或 $F(l)$）没有在 $\bmod k$ 意义下的逆元。

例如 $k=4$ 时，我们模拟计算出前几项：
```
1,1,2,3,4(5-1)
7,11,18,28(29-1)
46,74,120,194......
```
进行取模 $k$ 操作后如下：
```
1,1,2,3,0(1-1)
3,3,2,0(1-1)
2,2,0,2,2,0,2,2,0,2,2,0......
```
容易发现，`2,2,0` 出现后陷入了死循环。对于这种情况，自然需要特殊处理，先推出进入死循环前的部分暴力用矩阵快速幂一段一段处理，然后直接用 $base1$ 矩阵快速幂暴力求。

## Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define setm(x) x.a[1][1]=1,x.a[2][2]=1,x.a[3][3]=1
#define muld(x,y) x=x*y;
#define M 11451411
ll n,k,p,len[M],f[M],hd[M],vis[M];
using namespace std;
ll read()
{
	ll x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
void print(ll x)
{
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
struct Matrix
{
    ll a[4][4];
    Matrix(){memset(a,0,sizeof a);}
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        for(int i=1;i<=3;i++)
            for(int j=1;j<=3;j++)
                for(int k=1;k<=3;k++)
                	res.a[i][j]=((res.a[i][j]+a[i][k]*b.a[k][j])+p)%p;
        return res;
    }
}ans,base1,base2;
ll gcd(ll a,ll b)
{
	if(!b)return a;
	return gcd(b,a%b);
}
void exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b)
	{
		x=1,y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	ll t=x;
	x=y;
	y=t-a/b*y;
}
ll getInv(ll a,ll t)
{
	if(gcd(a,t)!=1)return -1;
	ll x,y;
	exgcd(a,t,x,y);
	return (x%t+t)%t;
}
ll plen(ll lim)
{
	ll res=0;
	for(int i=1;i<lim;i++) res+=len[hd[i]];
	return res;
}
void init()
{
	memset(len,M,sizeof(len));
	f[1]=1;f[2]=1;
    base1.a[1][1]=1;base1.a[1][2]=1;
	base1.a[2][1]=1;base1.a[3][3]=1;
	base2.a[1][1]=1;base2.a[1][2]=1;
	base2.a[2][1]=1;base2.a[3][3]=1;
	base2.a[3][1]=-1;
    ans.a[1][1]=1;ans.a[1][3]=1;
}
Matrix qpow(ll x,Matrix base)
{
	Matrix res;
	setm(res);
    while(x)
    {
        if(x&1)res=res*base;
        base=base*base;
        x>>=1;
    }
    return res;
}

int main()
{
	n=read(),k=read(),p=read();
    if(n==1||n==2)
    {
    	printf("1");
    	return 0;
	}
    init();
    for(ll i=3;;i++) 
	{
		f[i]=(f[i-1]+f[i-2])%k;
		if(f[i]%k==1&&len[1]>(M*114))len[1]=i;
		if(f[i]==1&&f[i-1]==1)break;
		ll inv=getInv(f[i],k);
		if(inv!=-1)len[inv%k]=min(len[inv%k],i);
	}
    ll now=1,tot=0,kcnt=0;
	bool fg=0;
	while(true)//求循环节（即判是否有逆元） 
	{
		hd[++kcnt]=now;
		vis[now]=kcnt;
		if(len[now]>=(M*114))//无逆元 
		{
			tot+=plen(kcnt);//计算死循环前的长度 
			fg=1;
			break;
		}
		now=(now*f[len[now]-1])%k;
		if(vis[now])//发现循环节 
		{
			tot+=plen(vis[now]);//计算循环节前的长度 
			break;
		}
	}
	len[1]--;
	if(n<=tot)
	{
		n--;
		for(int i=1;i<vis[now];i++)
		{
			if(n>=len[hd[i]])
			{
				muld(ans,qpow(len[hd[i]]-1,base1)*base2);
				n-=len[hd[i]];
			}
			else
			{
				muld(ans,qpow(n,base1));
				print(ans.a[1][1]);
				return 0;
			}
		}
	}
	else
	{
		n-=tot;
		for(int i=1;i<vis[now];i++)muld(ans,qpow(len[hd[i]]-1,base1)*base2);
		if(fg)//无逆元 
		{
			muld(ans,qpow(n,base1));
			print(ans.a[1][1]);
			return 0;
		}
		else//有逆元 
		{
			ll slen=0;
			Matrix tmp;
			setm(tmp);
			for(ll i=vis[now];i<=kcnt;i++)
			{
				muld(tmp,qpow(len[hd[i]]-1,base1)*base2);
				slen+=len[hd[i]];
			}
			muld(ans,qpow(n/slen,tmp));
			n%=slen;
			for(ll i=vis[now];i<=kcnt;i++)
			{
				if(n>=len[hd[i]])
				{
					muld(ans,qpow(len[hd[i]]-1,base1)*base2);
					n-=len[hd[i]];
				}
				else
				{
					muld(ans,qpow(n,base1));
					print(ans.a[1][1]);
					return 0;
				}
			}
		}
	}
	//注意，不可忘记矩阵快速幂之前清空 ans.a 数组。 
	return 0;
}
```

---

## 作者：schtonn (赞：4)


### 1.题意

首先理解一下题意：

$$F_i=\left\{
\begin{array}{lr}
F_{i-1}+F_{i-2}& F_{i-1}+F_{i-2}\not\equiv1\pmod k\\
F_{i-1}+F_{i-2}-1& F_{i-1}+F_{i-2}\equiv1\pmod k\\
\end{array}
\right.
$$

给定 $n$，$k$，$p$，求 $F(n)\bmod p$。

可以看出，它是一个略加修改的斐波那契数列，我们显然会想到使用矩阵快速幂，然而由于它会在不可预知的地方进行减一，简单地套用矩阵快速幂就无法达成目标。

### 2.规律

遇到这种问题，可以先手推一下规律。

由于一个具有斐波那契数列性质地数列可以完全由一个二元组 $(a,b)$ 固定，我们可以用一个二元组来表示当前状态。

例如从 $(1,1)$ 开始，$k=7$。

$$(1,1)-(1,2)-(2,3)-(3,5)-(5,1\rightarrow0)-(0,5)-(5,5)-\cdots$$

又如从 $(2,2)$ 开始：

$$\begin{array}{lr}(2,2)-(2,4)-(4,6)-(6,3)-(3,2)-(2,5)-(5,0)-(0,5)-\\(5,5)-(5,3)-(3,1\rightarrow0)-(0,3)-(3,3)-\cdots\end{array}$$

可以得知，如果某个状态进入了 $(b,1)$，它就会被减一成为 $(b,0)$，接下来成为 $(0,b)-(b,b)$，这样我们就可以以 $(a,a)$ 为节点，从某个 $(a,a)$ 用简单矩阵快速幂推到下一个 $(b,1)$，然后减一并继续推进到 $(b,b)$，循环完成整个过程。

放上一个 $k=7$ 时的完整图表：

```
(1,1)-(1,2)-(2,3)-(3,5)-(5,1);
(2,2)-(2,4)-(4,6)-(6,3)-(3,2)-(2,5)-(5,0)-(5,5)-(5,3)-(3,1);
(3,3)-(3,6)-(6,2)-(2,1);
(4,4)-(4,1);
(5,5)-(5,3)-(3,1);
(6,6)-(6,5)-(5,4)-(4,2)-(2,6)-(6,1);
```

注意到它没有那么友好，可能出现自环，两条路径的交集等情况，特别需要注意死循环，编写部分分代码时需要小心。

### 3.$k^2$ 算法
令 $(i,i)$ 经过 $e_i$ 步到达 $(g_i,1)$，可以在 $O(k^2)$ 的时间内维护 $e_i$ 和 $g_i$。

还是以 $k=7$ 为例：

$$e:4,10,3,1,2,5$$
$$g:5,3,2,4,3,6$$

即 $(1,1)$ 经过 $4$ 步到达 $(5,1)$，$(2,2)$ 经过 $10$ 步到达 $(3,1)$，etc.

求出这个之后我们就可以用矩阵快速幂来解决 $(a,a)$ 到 $(b,b)$ 的跳跃了。

这里面还有一些实现细节需要说明一下。由于原来斐波那契数列的递推矩阵实际上是做不到减一的，不过精通矩阵运算的人们都知道，我们只需要加一个常数项，然后稍微修改一下递推矩阵就好了。

原来的矩阵是这样的：

$$
\left[\begin{array}{lr}F_{n+1}\\F_n\end{array}\right]=
\left[\begin{array}{lr}1&1\\1&0\end{array}\right]\times
\left[\begin{array}{lr}F_n\\F_{n-1}\end{array}\right]
$$

现在正常递推改成了这样：
$$
\left[\begin{array}{lr}F_{n+1}\\F_n\\1\end{array}\right]=
\left[\begin{array}{lr}1&1&0\\1&0&0\\0&0&1\end{array}\right]\times
\left[\begin{array}{lr}F_n\\F_{n-1}\\1\end{array}\right]
$$

如果我们想减一，就可以这样：
$$
\left[\begin{array}{lr}F_n-1\\F_{n-1}\\1\end{array}\right]=
\left[\begin{array}{lr}1&0&-1\\0&1&0\\0&0&1\end{array}\right]\times
\left[\begin{array}{lr}F_n\\F_{n-1}\\1\end{array}\right]
$$

如果想推一步的同时减一，就是这样：
$$
\left[\begin{array}{lr}F_{n+1}-1\\F_n\\1\end{array}\right]=
\left[\begin{array}{lr}1&1&-1\\1&0&0\\0&0&1\end{array}\right]\times
\left[\begin{array}{lr}F_n\\F_{n-1}\\1\end{array}\right]
$$

将正常递推的那个矩阵设为 $A$，推一步同时加一的矩阵设为 $B$，最终的算式就是这样：

$$\cdots BA^{e_{g_1}-1}A^2BA^{e_1-1}
\left[\begin{array}{lr}F_2\\F_1\\1\end{array}\right]$$

然后为了符号方便，我们记 $F_0=0$，$F_{-1}=1$，就可以将递推式写为：

$$\cdots BA^{e_{g_1}+1}BA^{e_1+1}\left[\begin{array}{lr}F_0\\F_{-1}\\1\end{array}\right]$$

这样，$O(k^2)$ 算法就妥妥地实现了。

### 4.$k\log k$ 算法

原来求 $e$ 和 $g$ 地算法其实有很大的提升空间，如果你进行了深入的调试就会发现，对于大点的数据，它有 90% 以上的 $(a,a)$ 都陷入了死循环，这说明我们做了大量无用的计算，何不换个角度想想？

如果我们不用二元组，而用正常方式，把斐波那契数列取模 $k$，不管题目中的减一，写出来看看有什么发现？

```
1 1 2 3 5 1 6 0 6 6 5 4 2 6 1 0 1 1
```

发现它在这里进入了循环。

那么我们把数列乘上某个系数，并继续对 $k$ 取模，只写到第一次出现1的地方，再列出来看看有什么发现？

```
1 1 2 3 5 1 6 0 6 6 5 4 2 6 1 0 1 1
2 2 4 6 3 2 5 0 5 5 3 1
3 3 2 6 1
4 4 1
5 5 3 1
6 6 5 4 2 6 1
```

这跟前面的二元组好像没什么区别，但是如果仔细观察，其实每一行的值都是它所对应的真正的数列值，乘上这行的系数，再取模k，也就是那个列最上面的数乘那行最左边的数。

如果我们对第一行的每个数求逆元，求得的就正是它所对应的 $1$ 的位置所在的行数！

这时我们只需要用扩展欧几里得再 $O(k\log k)$ 的时间内求逆元，就可以随之求出所有 $e$ 和 $g$ 的值！

当然，这只是第一部分，求出 $e,g$ 后要需要做一些优化，因为对于矩阵的跳跃，如果 $n$ 足够大，很有可能会进入一个循环，这时记录下一整个循环的递推矩阵之乘积 $C$，然后再套用一次矩阵快速幂，可以省去大量时间，具体实现细节都在代码里了、

### 5.代码
```cpp
#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
const ll N=1000010;
ll m,n,k,p;
struct matrix{
    ll v[5][5];
    ll x,y;
}f,A,B,I,ans;
ll e[N],g[N],inv[N],vis[N];
void exgcd(ll a,ll b,ll& d,ll& x,ll& y){//这些是求逆元
    if(!b){
        d=a;
        x=1;y=0;
        return;
    }
    exgcd(b,a%b,d,y,x);
    y-=x*(a/b);
}
ll getinv(ll a){
    ll d,x,y;
    exgcd(a,k,d,x,y);
    return d==1?(x+k)%k:-1;
}
ostream&operator<<(ostream&ous,matrix a){//矩阵运算
    for(ll i=0;i<a.x;i++){
        for(ll j=0;j<a.y;j++){
            ous<<a.v[i][j]<<' ';
        }
        ous<<endl;
    }
    return ous;
}
matrix operator+(matrix a,matrix b){
    matrix c;
    if(a.x!=b.x||a.y!=b.y)return c;
    ll x=a.x,y=a.y;
    c.x=x;
    c.y=y;
    for(ll i=0;i<x;i++){
        for(ll j=0;j<y;j++){
            c.v[i][j]=(a.v[i][j]+b.v[i][j])%p;
        }
    }
    return c;
}
matrix operator*(matrix a,matrix b){
    matrix c;
    if(a.y!=b.x)return c;
    ll x=a.x,y=b.y,z=a.y;
    c.x=x;
    c.y=y;
    for(ll i=0;i<x;i++){
        for(ll j=0;j<y;j++){
            c.v[i][j]=0;
            for(ll k=0;k<z;k++){
                c.v[i][j]=(c.v[i][j]+a.v[i][k]*b.v[k][j])%p;
            }
        }
    }
    return c;
}
matrix operator^(matrix a,ll b){//我把快速幂也重载了
    matrix c=I;
    while(b){
        if(b&1)c=c*a;
        a=a*a;
        b>>=1;
    }
    return c;
}
void init(){
    A.x=A.y=B.x=B.y=3;
    I.x=I.y=3;
    f.x=3;f.y=1;
    f.v[1][0]=f.v[2][0]=1;
    A.v[0][0]=A.v[0][1]=A.v[1][0]=A.v[2][2]=1;
    B.v[0][0]=B.v[0][1]=B.v[1][0]=B.v[2][2]=1;
    B.v[0][2]=-1;
    I.v[0][0]=I.v[1][1]=I.v[2][2]=1;
}
int main(){
    // freopen("rabbit.in","r",stdin);
    // freopen("rabbit.out","w",stdout);
    init();
    cin>>n>>k>>p;
    int a=1,b=2;
    memset(e,-1,sizeof(e));
    for(int i=1;i<=k*k;i++){//先预处理e和g
        if(a==1&&b==1)break;
        if(!inv[b])inv[b]=getinv(b);
        if(inv[b]==-1){
            swap(a,b);
            b=(a+b)%k;
            continue;
        }
        if(e[inv[b]]==-1){
            e[inv[b]]=i;
            g[inv[b]]=a*inv[b]%k;
        }
        swap(a,b);
        b=(a+b)%k;
    }
    ll flag=0;
    ll cur=1,ptr=0;
    while(true){//沿着路线走一走，碰到循环就退出
        if(vis[cur]){
            flag=cur;
            break;
        }
        vis[cur]=1;
        if(ptr+e[cur]+1>n||e[cur]==-1){
            f=(A^(n-ptr))*f;
            break;
        }
        f=(A^(e[cur]+1))*f;
        ptr+=e[cur]+1;
        if(ptr>=n)break;
        f=B*f;
        ptr++;
        cur=g[cur];
        if(ptr>=n)break;
    }
    matrix C;
    ll siz;
    if(flag){//如果在循环里，那就求一下C
        siz=e[flag]+2;
        C=B*(A^(e[flag]+1));
        for(ll i=g[flag];i!=flag;i=g[i]){
            C=B*(A^(e[i]+1))*C;
            siz+=e[i]+2;
        }
        f=(C^((n-ptr)/siz))*f;//这一行做了大部分运算
        if((n-ptr)%siz){//还有剩下的部分，那就接着算完
            ptr=n-((n-ptr)%siz);
            while(true){
                if(ptr+e[cur]+1>n){
                    f=(A^(n-ptr))*f;
                    break;
                }
                f=(A^(e[cur]+1))*f;
                ptr+=e[cur]+1;
                if(ptr>=n)break;
                f=B*f;
                ptr++;
                cur=g[cur];
                if(ptr>=n)break;
            }
        }
    } 
    cout<<(f.v[0][0]+p)%p<<endl;//完结
    return 0;
}
```

---

## 作者：wlzhouzhuan (赞：4)

$75$ 分是送的..直接用 $f[i]$ 表示在模 $k$ 下兔子对数， $g[i]$ 表示在模 $p$ 下兔子对数即可。

这样复杂度是 $O(n)$ 的，看着斐波那契我们很有矩阵快速幂的冲动，但这个一下减 $1$ 一下不减真是很头疼。

记录 $fib[i]$ 模 $k$ 的表，每到减 $1$ 换行：

```
1, 1, 2, 3, 5, 0,
5, 5, 3, 0,
3, 3, 6, 2, 0,
2, 2, 4, 6, 3, 2, 5, 0, 5, 5, 3, 0, 
3, 3, 6, 2, 0 ...
```

我们发现：

- 每一段的开头两个数相同，且等于上一段的最后一个非 $0$ 数
- 在不超过 $k$ 段就会出现循环节
- 对于每一段，均为 $x, x, 2x, 3x, 5x, 8x, ...$ ，即第 $i$ 个数为 $fib[i]\times x$

因此判断一个段的结束，即找到最小的 $len$ 满足 $fib[len]\times x \equiv 1(mod\ k)$

所以 $fib[len] \equiv x^{-1} (mod\ k)$ ，如果不存在逆元那么这一段永不结束，直接上矩阵快速幂即可。

否则用 $exgcd$ 求出 $fib[len]$ 。

接下来，注意到 $k\le 10^6$ ，所以我们可以预处理所有的 $i$ ，求最小的 $len$ 满足 $fib[len]\equiv i(mod\ k)$

有一个结论： $fib[i]\ mod\ k$ 的循环节是以 $0,1,1$ 开头的，且长度不超过 $6k$ 。

所以不必担心 $len$ 过大的情况，直接暴力枚举 $1-6k$ 的所有 $fib$ 数即可。

最后，梳理一下思路：

先预处理，再计算段的循环节，算出这些段对应的矩阵乘积，然后矩阵快速幂即可。

![orz.png](https://i.loli.net/2020/07/08/NR8yO3LtMH59TU7.png)

两个单位矩阵我记为 $one,two$ ，$ans$ 矩阵初始为 $fib[0],fib[-1],1$ ，即 $0,-1,1$ ，这样方便处理。

细节较多，实现难度有点大..

复杂度 $O(27klogk)$ ，跑不满。

代码：(自认为写的超级优美)

```cpp
// Author: wlzhouzhuan
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ull unsigned long long
#define rint register int
#define rep(i, l, r) for (rint i = l; i <= r; i++)
#define per(i, l, r) for (rint i = l; i >= r; i--)
#define mset(s, _) memset(s, _, sizeof(s))
#define pb push_back
#define pii pair <int, int>
#define mp(a, b) make_pair(a, b)
#define debug(x) cerr << #x << " = " << x << '\n';
#define pll pair <ll, ll>
#define fir first
#define sec second

inline int read() {
  int x = 0, neg = 1; char op = getchar();
  while (!isdigit(op)) { if (op == '-') neg = -1; op = getchar(); }
  while (isdigit(op)) { x = 10 * x + op - '0'; op = getchar(); }
  return neg * x;
}
inline void print(int x) {
  if (x < 0) { putchar('-'); x = -x; }
  if (x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}

const int N = 6000005;
const int inf = 1e9;

ll n, k, p, x, y;

struct MAT {
  int n, m;
  ll v[3][3];
  MAT (int _n = 0, int _m = 0) {
    n = _n, m = _m;
    mset(v, 0);
  }
} ans(3, 1), one(3, 3), two(3, 3);

MAT operator * (MAT a, MAT b) {
  MAT ans(a.n, b.m);
  for (rint i = 0; i < a.n; i++) {
    for (rint j = 0; j < b.m; j++) {
      for (rint k = 0; k < a.m; k++) {
        ans.v[i][j] = (ans.v[i][j] + a.v[i][k] * b.v[k][j]) % p;
      }
    }
  }
  return ans;
}
MAT operator ^ (MAT a, ll b) {
  MAT ans(a.n, a.m);
  for (rint i = 0; i < a.n; i++) ans.v[i][i] = 1;
  while (b > 0) {
    if (b & 1) ans = ans * a;
    a = a * a;
    b >>= 1;
  }  
  return ans;
}

ll gcd(ll a, ll b) {
  return b ? gcd(b, a % b) : a;
}
void exgcd(ll a, ll b, ll &x, ll &y) {
  if (!b) {
    x = 1, y = 0;
    return ;
  }
  exgcd(b, a % b, y, x);
  y -= (a / b) * x;
}

ll fib[N], minn[N], len[N];
int head[N], tot, tag;
ll cur;

void init() {
  for (rint i = 0; i <= k; i++) minn[i] = inf;
  fib[1] = 1, fib[2] = 1;
  for (rint i = 3; i <= 6 * k; i++) {
    fib[i] = (fib[i - 1] + fib[i - 2]) % k;
    if (minn[fib[i]] == inf)
      minn[fib[i]] = i;
  }
  
  cur = 1;
  while (!head[cur]) {
    head[cur] = ++tot;
    if (gcd(cur, k) != 1) {
      //printf("gcd not 1!\n"); 
      tag = 1;
      break;
    }
    exgcd(cur, k, x, y);
    //printf("cur = %lld, k = %lld, x = %lld, y = %lld\n", cur, k, x, y);
    x = (x % k + k) % k;
    if (minn[x] == inf) {
      //printf("minn inf!\n"); 
      tag = 1;
      break;
    }
    len[tot] = minn[x];
    //printf("tot = %d, len[%d] = %d\n", tot, tot, len[tot]);
    cur = fib[minn[x] - 1] * cur % k;
  }
}

int main() {
  scanf("%lld%lld%lld", &n, &k, &p);
  
  // 特判 
  if (n == 1) {
    printf("%lld\n", 1ll);
    exit(0);
  }
  if (n == 2) {
    printf("%lld\n", 1ll);
    exit(0);
  }

  init();
  ans.v[1][0] = ans.v[2][0] = 1;
  one.v[0][0] = one.v[0][1] = one.v[1][0] = one.v[2][2] = 1;
  two.v[0][0] = two.v[0][1] = two.v[1][0] = two.v[2][2] = 1;
  two.v[0][2] = -1;
  
  //cerr << "tag = " << tag << '\n';
  
  if (tag == 1) { // 不存在逆元 或 不存在 fib[x] = i 
    for (rint i = 1; i <= tot - 1; i++) {
      if (n <= len[i]) {
        if (n < len[i]) {
          ans = (one ^ n) * ans;
        } else { // n = len[i]
          ans = (one ^ (n - 1)) * ans;
          ans = two * ans;
        }
        n = 0;
        break;
      }
      n -= len[i];
      ans = (one ^ (len[i] - 1)) * ans;
      ans = two * ans;
    }
    if (n > 0) {
      ans = (one ^ n) * ans;
    }
  } else { // 存在循环节 
    int start = head[cur]; // 从第start段到第tot段形成循环 
    for (rint i = 1; i < start; i++) {
      if (n <= len[i]) {
        if (n < len[i]) {
          ans = (one ^ n) * ans;
        } else {
          ans = (one ^ (n - 1)) * ans;
          ans = two * ans;
        }
        n = 0;
        break;
      }  
      n -= len[i];
      ans = (one ^ (len[i] - 1)) * ans;
      ans = two * ans;
    }
    ll totlen = 0; // 循环节总长度 
    MAT all(3, 3);
    all.v[0][0] = all.v[1][1] = all.v[2][2] = 1;
    for (rint i = start; i <= tot; i++) {
      totlen += len[i];
      all = (one ^ (len[i] - 1)) * all;
      all = two * all;
    } 
    if (n / totlen >= 1) {
      ans = (all ^ (n / totlen)) * ans;
      n %= totlen;
    }
    if (n) {
      for (rint i = start; i <= tot; i++) {
        if (n <= len[i]) {
          if (n < len[i]) {
            ans = (one ^ n) * ans;
          } else {
            ans = (one ^ (n - 1)) * ans;
            ans = two * ans;
          }
          n = 0;
          break;
        }
        n -= len[i];
        ans = (one ^ (len[i] - 1)) * ans;
        ans = two * ans;
      }
    }
  }
  ans.v[0][0] = (ans.v[0][0] % p + p) % p;
  printf("%lld\n", ans.v[0][0]);
  return 0;
} 
```

---


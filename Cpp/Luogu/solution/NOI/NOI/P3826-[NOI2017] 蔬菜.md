# [NOI2017] 蔬菜

## 题目描述

小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。

在蔬菜仓库中，共存放有 $n$ 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。

在计算销售蔬菜的收益时，每销售一个单位第 $i$ 种蔬菜，就可以获得 $a_i$ 的收益。

特别地，由于政策鼓励商家进行多样化销售，第一次销售第 $i$ 种蔬菜时，还会额外得到 $s_i$ 的额外收益。

在经营开始时，第 $i$ 种蔬菜的库存为 $c_i$ 个单位。

然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已 经计算出了每个单位蔬菜变质的时间：对于第 $i$ 种蔬菜，存在保鲜值 $x_i$，每天结束时会 有 $x_i$ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化）

形式化地：对于所有的满足条件 $d\times x_i \leq c_i$ 的正整数 $d$ ，有 $x_i$ 个单位的蔬菜将在 第 $d$ 天结束时变质。

特别地，若 $(d - 1)\times x_i \leq c_i < d\times x_i$ ，则有 $c_i - (d - 1)\times x_i$ 单位的蔬菜将在第 $d$ 天结束时变质。

注意，当 $x_i = 0$ 时，意味着这种蔬菜不会变质。

同时，每天销售的蔬菜，总量也是有限的，最多不能超过 $m$ 个单位。

现在，小 N 有 $k$ 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 $p_j$，如果需要销售 $p_j$ 天，最多能获得多少收益？

## 说明/提示

### 样例解释

共有两种蔬菜：

销售第 $1$ 种蔬菜时，每销售一单位可以获得的收益为 $3$，第一次销售这种蔬菜时，额外可以获得的收益为 $3$。这种蔬菜共有 $3$ 个单位，均会在第一天结束时变质。

销售第 $2$ 种蔬菜时，每销售一单位可以获得的收益为 $2$，第一次销售这种蔬菜时，额外可以获得的收益为 $5$。这种蔬菜共有 $8$ 个单位，其中，有 $3$ 单位在第一天结束时变质，$3$ 单位在第二天结束时变质，$2$ 单位在第三天结束时变质。

在只销售 $1$ 天时，应当销售 $2$ 单位的第一种蔬菜和 $1$ 单位的第二种蔬菜。

在这种情况下：销售第一种蔬菜的收益为 $2 \times 3 + 3$；销售第二种蔬菜的收益为 $1 \times 2 + 5$；总共获得的收益为 $(2 \times 3 + 3) + (1 \times 2 + 5) = 16$。

在只销售 $3$ 天时，第一天应当销售 $3$ 单位的第一种蔬菜，第二天应当销售 $3$ 单位的第二种蔬菜（此时选择在第二天结束时会变质的 $3$ 个单位出售），第三天销售 $2$ 单位的第二种蔬菜。

在这种情况下：销售第一种蔬菜的收益为 $3 \times 3 + 3$；销售第二种蔬菜的收益为 $(3 + 2) \times 2 + 5$；总共获得的收益为 $(3 \times 3 + 3) + [(3 + 2) \times 2 + 5] = 27$。

### 数据范围

| 测试点编号 |    $n$     |   $m$    |   $p_j$    | 特性 $1$ |    特性 $2$    |
| :--------: | :--------: | :------: | :--------: | :------: | :------------: |
|    $1$     |  $\le 2$   | $\le 10$ | $\le 10^3$ |    无    |       无       |
|    $2$     |  $\le 3$   | $\le 10$ | $\le 10^3$ |    无    |       无       |
|    $3$     |  $\le 4$   | $\le 10$ | $\le 10^3$ |    无    |       无       |
|    $4$     | $\le 10^3$ | $\le 10$ |  $\le 2$   |    无    |       无       |
|    $5$     | $\le 10^3$ | $\le 10$ |  $\le 3$   |    无    |       无       |
|    $6$     | $\le 10^3$ | $\le 10$ |  $\le 4$   |    无    |       无       |
|    $7$     |  $\le 4$   | $\le 1$  |  $\le 4$   |    无    |       无       |
|    $8$     |  $\le 6$   | $\le 2$  |  $\le 6$   |    无    |       无       |
|    $9$     |  $\le 8$   | $\le 1$  |  $\le 8$   |    无    |       无       |
|    $10$    |  $\le 10$  | $\le 2$  |  $\le 10$  |    无    |       无       |
|    $11$    |  $\le 20$  | $\le 3$  |  $\le 20$  |    无    |       无       |
|    $12$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    有    | 无 |
|    $13$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    无    |       有       |
|    $14$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    无    | 无 |
|    $15$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    无    | 无 |
|    $16$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    有    | 有 |
|    $17$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    有    | 无 |
|    $18$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    无    |       有       |
|    $19$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    无    | 无 |
|    $20$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    无    | 无 |
|    $21$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    有    | 有 |
|    $22$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    有    |       无       |
|    $23$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    无    |       有       |
|    $24$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    无    |       无       |
|    $25$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    无    |       无       |

特性 $1$：所有的 $s_i$ 均为 $0$；

特性 $2$：所有的 $x_i$ 均为 $0$。

对于所有的测试数据，均保证 $k$ 组询问中的 $p_j$ 互不相同。

对于所有的测试数据，均保证 $0<a_i,c_i\le 10^9$，$0\le s_i,x_i\le 10^9$。


## 样例 #1

### 输入

```
2 3 2
3 3 3 3
2 5 8 3
1
3
```

### 输出

```
16
27
```

# 题解

## 作者：shadowice1984 (赞：66)

……网上的贪心题解太神啦……

并查集的做法实在是太精妙了……，这里说一个不是那么难想,也不那么难理解的做法，不需要并查集

## 本题题解

首先直接做的话根本无从下手，所以我们考虑一波奇怪的操作……比如时光倒流

现在我们反转这p天的流程，可以认为是某些菜会在某些时间突然出现，之后每一天都会运过来$x_{i}$单位的这种菜，这样就不需要考虑蔬菜会坏掉的问题了

我们发现无论我们怎么卖菜，都不会影响我们运菜的情况，不会存在我把贵的菜留着以后卖的情况，因为现在什么时候卖是一样的，但是后边可能会有更好的菜运过来，不如为将来腾出空间，所以现在各步的决策完全无关……，因此可以直接贪心，在每一天选择最贵的前m种菜卖掉，然后处理一下第一次卖菜的时候的额外收益即可

然后现在这个问题就变成了NOIP级别的大模拟题了，基本思路就是开一个堆然后乱七八糟维护一堆东西就够了

但是注意到k最大是$10^5$的量级,(因为每次询问互不相同)，我们考虑到这样做可能会华丽的T飞掉，因此我们需要考虑这个多组询问是否可以递推，即是否可以由p的答案递推到p-1的答案，答案是肯定的，我们当然可以递推了

由于我们前p天中的任意一个决策都可以在前p-1天做出的，而且我们发现卖菜的收益和时间无关，即我除了第一次卖菜之外，什么时候卖都是一样的，因此我们事实上会发现p和p-1的唯一区别就在于我们少卖了m个单位的菜

因此我们只需要挑出m个收益最小的菜然后扔掉不要就行了，这样就可以从p递推到p-1了……

为了体现题目的在线性，我直接打了一个p从1到1e5的表，然后每次处理询问的时候直接查表即可
_____________

上面说的只是一个大致的思路，真正写起来的话这道题会有一堆细节需要注意的地方

真正写起来你会发现这个东西其实并没有想像的那么好写，所以我们大致描述一下算法流程

1.生成p=1e5的解

1.1 每一天开一个vector暴力存储这一天会有什么蔬菜出现，我们认为$x_{i}=0$的菜全部在n=1e5的天出现，注意这里要用上取整计算天数

1.2从第1e5天从后向前扫，开一个堆存储蔬菜，每经过一天把这个vector里的所有菜按照$a_{i}+s_{i}$push到堆里

1.2.1，令lim=m，重复以下过程直到lim=0

1.2.2 从堆中拿出权值最大的菜，判断这种菜有没有被卖出过(这个可以开一个bool数组),如果卖出过的话计算这一天这种菜还有多少=$c_{i}-(day-1)x_{i}$-这种菜已经卖出的数量，然后和lim取个min去减，同时更新一下卖出的数量，然后把这个菜插入到一个队列里装着备用

1.2.2如果没有卖过，那么我们只卖一个，获得这$a_{i}+s_{i}$的权值，然后给堆里重新插入一个$a_{i}$的权值

1.2.3把刚才备用队列里的元素重新插回队列里，如果这种菜被卖光了就不必插入了

这样我们就生成了一个p=1e5的解，递推p-1的流程和刚才的类似，只是注意我们在扔菜的时候先扔到1，然后重新插一个权值为$a_{i}+s_{i}$的点到小根堆里去来处理放弃$S_{i}$的情况，然后我们就有了一张答案表，就可以$O(1)$的处理每个询问了~

算法复杂度$O(pmlog(n))$随机数据下m极有可能跑不满……具体细节的话看代码吧……

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=1e5+10;typedef long long ll;
int n;int m;int k;ll a[N];ll s[N];ll x[N];ll c[N];ll ans[N];
struct data
{
	ll v;int pos;
	friend bool operator <(data a,data b){return a.v<b.v;}
};priority_queue <data> pq;
struct nod
{
	ll v;int pos;
	friend bool operator <(nod a,nod b){return a.v>b.v;}
};priority_queue <nod> hp;
queue <int> us;int p=1e5;ll tot;
vector <int> app[N];bool used[N];ll sd[N];
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++){scanf("%d%d%d%d",&a[i],&s[i],&c[i],&x[i]);}
	for(int i=1;i<=n;i++)//处理每天出现的菜 
	{
		if(x[i]==0){app[p].push_back(i);}
		else {app[min((ll)p,(c[i]+x[i]-1)/x[i])].push_back(i);}
	}
	for(int i=p;i>=1;i--)
	{
		for(int j=0;j<app[i].size();j++)pq.push((data){a[app[i][j]]+s[app[i][j]],app[i][j]});
		if(pq.empty()){continue;}//先插入所有可能的菜 
		for(ll lim=m;lim&&!pq.empty();pq.pop())
		{
			data now=pq.top();//取出堆头 
			if(used[now.pos]==false)//获得si 
			{
				used[now.pos]=true;ans[p]+=now.v;sd[now.pos]++;lim--;
				if(c[now.pos]!=1){pq.push((data){a[now.pos],now.pos});}//重新插回去 
			}
			else //贪心的多取 
			{
				ll rem=c[now.pos]-sd[now.pos]-(i-1)*x[now.pos];//剩余的 
				ll del=min(rem,lim);ans[p]+=del*now.v;sd[now.pos]+=del;lim-=del;
				if(sd[now.pos]!=c[now.pos]){us.push(now.pos);}//放到回收的队列里 
			}
		}
		for(;!us.empty();us.pop()){int nw=us.front();pq.push((data){a[nw],nw});}//重新插回去 
	}
	for(int i=1;i<=n;i++)//递推ans 
	{
		if(sd[i]==1){hp.push((nod){s[i]+a[i],i});}//特判si 
		else if(sd[i]!=0){hp.push((nod){a[i],i});}tot+=sd[i];//统计下现在卖了多少菜 
	}
	for(int i=p-1;i>=1;i--)
	{
		ans[i]=ans[i+1];if(tot<=m*i){continue;}//如果还是可以卖一样的菜就不扔菜 
		for(ll lim=tot-m*i;lim&&!hp.empty();)//否则扔代价和最小的菜 
		{
			nod now=hp.top();hp.pop();//取出堆头 
			if(sd[now.pos]!=1)//扔掉非si部分 
			{
				ll del=min(sd[now.pos]-1,lim);
				sd[now.pos]-=del;lim-=del;ans[i]-=del*now.v;
				if(sd[now.pos]==1){hp.push((nod){a[now.pos]+s[now.pos],now.pos});}
				else {hp.push((nod){a[now.pos],now.pos});}//判一下是不是需要插回去 
			}
			else {lim--;sd[now.pos]--;ans[i]-=now.v;}//扔掉si部分 
		}tot=m*i;//更改tot 
	}
	for(int i=1,t;i<=k;i++){scanf("%d",&t);printf("%lld\n",ans[t]);}//查表出答案 
	return 0;//拜拜程序~ 
}

```






---

## 作者：command_block (赞：49)

更严谨的正确性分析。

更自然的非启发式思路。（然而也有点难想）

更强的扩展性。（然而也没做过几个题）

~~更多的草稿纸。~~

**广告** ： [模拟费用流小记](https://www.luogu.com.cn/blog/command-block/mu-ni-fei-yong-liu-xiao-ji) （建议阅读）

------------

**题意** : 有 $n$ 种蔬菜，第 $i$ 种蔬菜单价是 $a_i$，初始时数量为 $c_i$，若不出售，每天有 $x_i$ 份会变质。初次出售第 $i$ 种蔬菜可以获得 $s_i$ 的奖励。

每天可以卖掉 $m$ 个未变质的蔬菜。有 $k$ 个询问，每次问在 $1\sim p$ 天出售蔬菜能够获得的最大收益。
 
------------

首先解释一下题意。

**同种蔬菜中**，每棵蔬菜都有自己独立的变质时间，在不出售的情况下，效果是每天有 $x_i$ 份会变质。但可以出售这些较快变质的菜，保留那些较慢变质的菜。

- **正确理解** : 每天会有 $3$ 棵菜变质，则变质时间为 $\{1,1,1,2,2,2,3,3,3...\}$。若第一天卖掉了两棵 $[1]$ ，则只有一棵 $[1]$ 会变质。

- **错误理解** : 无论怎么卖，剩余的该种蔬菜都会变质 $3$ 个。

也可以理解为，将蔬菜再按照过期时间分类为不同类别的菜。

------------

- $\small\blacksquare$ **费用流模型**

考虑**时间倒流**，问题变为 : 每天都会加入一些菜（原来会变质的菜），菜可以无限期保存，但每天最多出售 $m$ 个菜，问最大总收益。

为第 $t$ 天的第 $i$ 种蔬菜建立点 $(t,i)$。建边 $S\rightarrow (t,i)$ ，边权为 $a_i$，容量为当天加入的蔬菜数目。

连边 $(t,i)\rightarrow (t+1,i)$ ，容量不限，表示可以将蔬菜留到下一天。

为第 $t$ 天建立一个点表示出售，记为 $[t]$ 。建边 $[t]\rightarrow T$ ，容量为 $m$。

建边 $(t,i)\rightarrow[t]$ ，容量不限。

在菜 $i$ **第一次出现**的时间，从 $S\rightarrow (t,i)$ 中分出一个流量（特殊菜），边权改为 $a_i+s_i$ ，表示出售奖励。

（不难发现，任意一种没有卖掉“特殊菜”情况都可以转化为卖掉“特殊菜”的情况而增加收益，算法一定不会错过奖励）

然后求解最大费用任意流。

- $\small\blacksquare$ **模拟费用流** : 获得性质 & 贪心算法

首先观察建图 :

![](https://cdn.luogu.com.cn/upload/image_hosting/cyjctszl.png)

只有源边有权值，其余边的权值均为 $0$。

考虑使用 “**增量-最大费用任意流**” 模型。

时间倒流后，原来限制只能在前 $1\sim p$ 天（一个前缀）出售，现在变为在一个前缀不能出售，之后才能出售。

**从后向前**依次加入每一天的出售点（这样才能符合原来的时间顺序），观察会新形成怎样的“源汇路”或“环” :

![](https://cdn.luogu.com.cn/upload/image_hosting/a9qvsm06.png)

图 $\rm I$ : 未加入出售点时的图。此时图中即没有源汇路也没有环，无需处理。

图 $\rm II$ : 红色部分为新加入的点和边，边的方向是给定的。黑色部分为之前的点和边，边的方向并不确定。

图 $\rm III$ : 三种新的源汇路。具体意义无需关心。

图 $\rm IV$ : 一种新的环。和上一题类似，该方案不如单走一个源汇路，可以排除。

图 $\rm V$ : 一种新的环。注意到不和 S 相连的边均无权，故该环不可能是负环，可以排除。

综上，可能的更新操作中，**所有 S 的出边不会退流**。

因此，我们的决策实际上是非常简单的。形式化地，在**未经时光倒流的原问题**中，前 $p$ 天售卖蔬菜的最优方案，是在前 $p-1$ 售卖蔬菜的最优方案的超集。

有了这个性质，考虑先求出前 $p$ 天的最优方案，然后推出 $1\sim p-1$ 天的方案。

若前 $p$ 天的最优方案为蔬菜集合 $S$ ，则 $S$ 中的所有蔬菜的过期日期都 $\geq p$。

对于第 $p'$ 天，只需保留其中最贵的 $p'*m$ （可能不足）棵，不难发现这是合法的，且是所有合法子集中最优的。

那么将 $S$ 排序就容易得到最终答案。

至于如何求出前 $p$ 天的最优方案，则需设计另一种模拟费用流。

现在已经没有时序的限制，我们可以按照任意顺序处理费用流图。

![](https://cdn.luogu.com.cn/upload/image_hosting/95eilgnl.png)

（我们将思路回到时光倒流后的形式）

图 $\rm I$ : 红色部分为新加入的点和边，黑色部分为之前的点和边。

图 $\rm II$ : 一种可能的源汇路，对应将今天加入的菜直接卖掉。

图 $\rm III$ : 一种可能的源汇路，对应将之前存下的菜卖掉。

图 $\rm IV,V$ : 两种环。和上文类似，可以排除。

在同一种菜中，出售那颗的获益都是一样的，故使用堆维护各种菜即可。当售空时，则从堆中取出。

当加入菜时，若原来这种菜售空，则将其加入堆。这需要维护售空且有持续输入的菜的集合。

（还有一点关于 $s$ 的小细节，不难处理）

复杂度 $O(nm\log n)$。

```cpp
#include<algorithm>
#include<cstdio>
#include<queue>
#define pb push_back
#define Pr pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define ll long long
#define MaxN 100500
using namespace std;
int a[MaxN],s[MaxN],tot[MaxN],d[MaxN],c[MaxN];
int n,lim,m,t[MaxN],tim;
ll ans[MaxN*10];
vector<int> g[MaxN];
int st[MaxN],tn;
priority_queue<Pr> q;
int main()
{
  scanf("%d%d%d",&n,&lim,&m);
  for (int i=1;i<=n;i++)
    scanf("%d%d%d%d",&a[i],&s[i],&tot[i],&d[i]);
  for (int i=1;i<=m;i++){
    scanf("%d",&t[i]);
    tim=max(tim,t[i]);
  }
  for (int i=1;i<=n;i++)
    if (!d[i])g[tim].pb(i);
    else g[min((tot[i]+d[i]-1)/d[i],tim)].pb(i);
  for (int t=tim;t;t--){
    for (int i=0;i<g[t].size();i++)
      st[++tn]=g[t][i];
    for (int i=1;i<=tn;i++){
      int k=st[i];
      q.push(mp(!c[k] ? a[k]+s[k] : a[k],k));
    }tn=0;
    int cnt=lim;
    while(cnt){
      if (q.empty())break;
      int i=q.top().sec;
      if (!c[i]){
        c[i]=1;cnt--;
        q.pop();
        if (tot[i]-d[i]*(t-1)>1)q.push(mp(a[i],i));
        else if (d[i])st[++tn]=i;
      }else {
        int cnt2=min(tot[i]-d[i]*(t-1)-c[i],cnt);
        c[i]+=cnt2;cnt-=cnt2;
        if (tot[i]-d[i]*(t-1)==c[i])
          {q.pop();if (d[i])st[++tn]=i;}
      }
    }
  }
  tn=0;
  for (int i=1;i<=n;i++){
    if (c[i])ans[++tn]=a[i]+s[i];
    for (int j=2;j<=c[i];j++)ans[++tn]=a[i];
  }sort(ans+1,ans+tn+1);reverse(ans+1,ans+tn+1);
  for (int i=1;i<=tn;i++)ans[i]+=ans[i-1];
  for (int i=1;i<=m;i++)
    printf("%lld\n",ans[min(tn,t[i]*lim)]);
  return 0;
}
```

---

## 作者：7KByte (赞：16)

这题可以有更简单的建模。

先构造费用流，对于每一天建一个点，第 $i$ 天记为点 $i$，下文为方便表述，记 $(u,v,c,w)$ 表示从点 $u$ 连向 $v$ 容量为 $c$，费用为 $w$ 的边。

每天卖出 $m$ 颗菜，连边 $(S,i,m,0)$。对于每种蔬菜，第 $i$ 天有 $x$ 颗坏掉，就连边 $(i,T,x,a_i)$。第 $i$ 天可以卖出在 $\ge i$ 天坏掉的菜，连边 $(i,i+1, \inf, 0)$。

直接跑最大费用最大流即可求出答案。

同时我们观察这张图，发现它非常优美，除了源点和汇点，其它的点刚好排成一排，并且有边 $(i,i+1,inf,0)$，从源点出发的边，或出发到汇点的边都不可能被退流，所以唯一可能退流的只有 $(i,i+1)$ 之间的边。

这样已经可以简单维护了，我们直接用线段树维护 $(i,i+1)$ 之间的反向边容量即可（支持区间加，区间求最小值）。需要注意的是对于 $s_i$ 的条件，我们只用将第 $i$ 种蔬菜最后一颗坏掉的菜的价格加上 $s_i$ 即可。从前往后枚举每一天，并按价格从大到小依次考虑每种蔬菜。对于蔬菜理论可以直接双指针维护，代码为方便直接写了堆。

复杂度 $\mathcal{O}(nm\log n)$，瓶颈在于线段树。

```cpp
#define N 100005
int n, m, k, t, u[N], s[N], c[N], b[N], v[N], p[N]; LL ed[N];
priority_queue<Pr>q;
struct node{int l, r, val, tag;}a[N << 2];
const int inf = 0x7fffffff;
#define L a[x].l
#define R a[x].r
#define ls (x << 1)
#define rs (ls | 1)
#define S a[x].val
#define T a[x].tag
void build(int x,int l,int r){
	L = l, R = r;
	if(l == r)return;
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
}
inline void pushup(int x,int w){T += w, S += w;}
inline void down(int x){if(T)pushup(ls, T), pushup(rs, T), T = 0;}
void ins(int x,int l,int r,int w){
	if(L >= l && R <= r)pushup(x, w);
	else{
		down(x); int mid = (L + R) >> 1;
		if(mid >= l)ins(ls, l, r, w);
		if(mid < r)ins(rs, l, r, w);
		S = min(a[ls].val, a[rs].val);
	}
}
int ask(int x,int l,int r){
	if(L >= l && R <= r)return S;
	down(x); int mid = (L + R) >> 1, mn = inf;
	if(mid >= l)cmn(mn, ask(ls, l, r));
	if(mid < r)cmn(mn, ask(rs, l, r));
	return mn;
}
inline int day(int id){
	if(b[id] == 0)return k;
	return (c[id] - v[id]) / b[id] + 1;
}
int main(){
	read(n, m, t);
	rp(i, n){
		read(u[i], s[i], c[i], b[i]), v[i] = 1;
		q.push({s[i] + u[i], i});
	}
	rp(i, t)read(p[i]), cmx(k, p[i]);
	build(1, 1, k);
	rp(i, k){
		int res = m;
		while(res--){
			while(!q.empty()){
				Pr cur = q.top(); q.pop();
				int id = cur.se, d = day(id);
				if(d >= i){
					ed[i] += cur.fi, ++v[id];
					if(v[id] <= c[id])q.push({u[id], id});
					if(d > i)ins(1, i, d - 1, 1);
					break;
				}
				else{
					int w = ask(1, d, i - 1);
					if(w){
						ed[i] += cur.fi, ++v[id];
						if(v[id] <= c[id])q.push({u[id], id});
						ins(1, d, i - 1, -1);
						break;
					}
				}
			}
			if(q.empty())break;
		}
		ed[i] += ed[i - 1];
	}
	rp(i, t)printf("%lld\n", ed[p[i]]);
	return 0;
}
```


---

## 作者：Tyher (赞：14)

~~咳了一下午加一晚上~~
 
- 不得不说这个真的是个神仙题……。
- 先膜[yyb的题解](https://www.cnblogs.com/cjyyb/p/9743710.html)，写的太好了。
- 首先反过来看，把蔬菜过期变成蔬菜一点点跑回来。
- 这样的话，我们可以从最后一天往前推，因为最后一天有什么蔬菜是固定的，所以我们可以知道最后一天要卖什么。
- 我们只要记录蔬菜最后一次变质完成在什么位置就可以了。
- 然后再考虑上一天……再上一天……。
- 首先我们考虑一个支持快速插入，查询最大值，删除的数据结构。选择**大根堆**。
- 然后每次把当天出现的蔬菜放进大根堆，这个时候的排序的权值是$a_i+s_i$。
- 接下来分析当天取$m$个最大的蔬菜。
- 首先取出价值最大的蔬菜。
- 然后考虑他是第一次被卖还是第二次被卖：
- 如果是第一次，我们就**只卖一个**，因为有可能是因为第一次的优惠$s_i$导致了他的权值比较大，如果我们把这个蔬菜都卖了，显然就不优秀。
- 如果不是第一次，我们就能卖全卖了。
- 为什么现在能卖就卖是对的？
#### 简单证明一下：
- 必要性显然。
- 充分性：因为我们是倒着推的，就不存在现在卖掉，然后以后就卖不掉的情况，所以这个决策是不具有后效性的，现在卖掉是最优的。
### 注意
- 这个时候会有这样一个问题，就是这个蔬菜，现在虽然卖不**完**。
- 注意，不是卖不了，卖是可以卖，只是超过了$m$的限制，或者变质的部分没有完全回来，这里的卖不完是指没有卖完$c_i$的总容量，但是在当天来看是卖完了。
- 这个时候我们如果把他从堆里面删掉没问题，但是在第二天我们又要重新考虑他，因为第二天这个蔬菜又会有新的$x_i$回来。
- 解决办法就是开一个回收栈，每次删除即入栈，最后在把栈里面的东西重新加入堆里面。
### 前方高能！
- 我一开始做的时候，就做到这里打止了，因为我一开始觉得，上面的过程是从后往前推的过程，那么之前的答案就已经算出来了。
- 然而这样是不对的。
- 因为上面算出来的答案，是基于$M$天为终点的答案，也就是说你有一些很贵重的蔬菜是在后面卖掉的。
- 然后我们就像快速从$M$天的答案合法推到$M-1$天的答案。
- 显然，我们就是要快速删除最小的$m$个蔬菜所产生的贡献。
- 和上面的方法一样，我们可以先知道自己已经卖了多少蔬菜。
- 然后对于卖掉的每一种蔬菜，如果只卖掉了一次，就把$a_i+s_i$丢到小根堆里面去，否则把$a_i$丢到小根堆里面去。
- 然后对于每一天，看现在卖掉的蔬菜有没有超过$i*m$。
- 如果有，那么就删掉一些蔬菜。
- 每次取贡献最小的蔬菜，如果他只有一个，就彻底删掉。
- 否则就删到不能删，注意，这个时候要剩下一个，因为最后一个的贡献不是$a_i$了，而是$s_i+a_i$了。因为当前的最后一个，是实际上的第一个（我们是倒着考虑的），所以再把$s_i+a_i$丢到堆里面去。
- 这样贪心就可以得到每一天的答案了。
#### 简单证明一下这个贪心的正确性：
- 虽然我们考虑前面计算答案的时候，前面的答案中间，有一部分的蔬菜是在后面被卖掉的。
- 但是考虑这个过程，总共卖掉的东西是恒定的，如果一个蔬菜可以在后面被卖掉，那么他一定也可以在前面被卖掉。
- 为什么呢？因为前面我们是从后往前考虑的，考虑到了一个蔬菜出现的时间（也就是变质的时间），所以在计算答案的时候后面贡献的蔬菜，也可以在前面被贡献。

- 最后引用[yyb](https://www.luogu.org/space/show?uid=21283)的话：

> 是不是觉得其实这就是一个模拟费用流的过程啊，倒推回去就是一个退流的过程，正推的贪心，显然每天只有那么几条路径，用堆维护等价于跑费用流，忽然感觉很妙啊。


- 代码和前面一篇题解的思路差不多
- 也和$yyb$的差不多~~简直一模一样~~
- ~~毕竟我看他的才会做的啊~~


```
#include<bits/stdc++.h>
#define R register int
#define ll long long 
using namespace std;
const int N=200001;
const int M=1e5;
int n,m,q,a[N],s[N],c[N],x[N],vis[N];
int us[N],tp,sum;
ll ans[N];
struct ip{int v,id;}STK[N];
priority_queue<ip>Q;
vector<int>app[N];
int operator < (ip x,ip y){return x.v<y.v;}
int gi(){
    R x=0,k=1;char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')k=-1,c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*k;
}
int main(){
    freopen("s.in","r",stdin);
	n=gi(),m=gi(),q=gi();
	for(R i=1;i<=n;++i)
		a[i]=gi(),s[i]=gi(),c[i]=gi(),x[i]=gi();
	for(R i=1;i<=n;++i){
		if(!x[i])app[M].push_back(i);
		else app[min(M,(c[i]+x[i]-1)/x[i])].push_back(i);
	}
	for(R i=M;i>=1;--i){
		for(R j=0,lim=app[i].size();j<lim;++j)
			Q.push((ip){a[app[i][j]]+s[app[i][j]],app[i][j]});
		if(Q.empty())continue;
		for(R j=m;j&&(!Q.empty());){
			ip u=Q.top();Q.pop();
			if(!vis[u.id]){
				vis[u.id]=1,ans[M]+=u.v,us[u.id]++,--j;
				if(c[u.id]>1)Q.push((ip){a[u.id],u.id});
			}
			else{
				R res=min(j,c[u.id]-us[u.id]-(i-1)*x[u.id]);
				ans[M]+=1ll*res*u.v,us[u.id]+=res,j-=res;
				if(us[u.id]!=c[u.id])STK[++tp]=(ip){a[u.id],u.id};
			}
		}
		while(tp)Q.push(STK[tp--]);
	}
	while(!Q.empty())Q.pop();
	for(R i=1;i<=n;++i)sum+=us[i];
	for(R i=1;i<=n;++i)
		if(us[i]==1)Q.push((ip){-s[i]-a[i],i});
		else if(us[i])Q.push((ip){-a[i],i});
	for(R i=M-1;i>=1;--i){
		ans[i]=ans[i+1];
		while(sum>i*m&&!Q.empty()){
			ip u=Q.top();Q.pop(),u.v*=-1;
			if(us[u.id]>1){
				R res=min(sum-i*m,us[u.id]-1);
				us[u.id]-=res,sum-=res,ans[i]-=res*u.v;
				if(us[u.id]==1)Q.push((ip){-a[u.id]-s[u.id],u.id});
				else Q.push((ip){-a[u.id],u.id});
			}
			else --sum,--us[u.id],ans[i]-=u.v;
		}
	}
	while(q--)printf("%lld\n",ans[gi()]);
    return 0;
}

```


---

## 作者：yellow_bored (赞：11)

### [蔬菜](https://www.luogu.com.cn/problem/P3826)
### [蔬菜的弱弱弱化版](https://www.luogu.com.cn/problem/UVA1316)
## 我们先从简单的入手
先看弱化版     
我们可以贪心，先按价值排序，~~显然~~已经排好序的每一商品在它过期前一天卖可以使收益最大，这时问题就出现了，如果两个商品在同一天过期怎么办。    
继续按贪心策略，当这一天已经卖出了东西，那么就将这一天指向前最近的没有出售商品的一天，这时我们就可以想到    
### ~~病茶几~~    **并查集**      
那么这道弱化版就~~显然~~了     
## 我们回到这道题
依旧是这个贪心思路，但是多了很多细节。
#### 首先    
每天有一个不定的售卖上限m，可以考虑每次只出售一份，这样方便了其他细节的处理。    
#### 然后   
 多了一个奖励s,可以先将s加上，然后在它被第一次卖出后将此种商品减去s，这时商品的价值发生了变化，仅仅排序是不够的了，所以我们需要**优先队列**，每一次取队头（价值最高的商品），如果买完之后库存仍然有剩余，就将剩下的压回队里。   
#### 接着
蔬菜每一天都会腐烂一些，但仍然可以按贪心策略来，因为每一次只出售一份，所以找到它腐烂完的前一天（注意蔬菜库存会发生变化）售卖；如果这一天到达了售卖上线，仍然用**并查集**维护，指向前一天。
#### 最后
多次询问。可以发现，虽然问的是售卖前p天的最大利润，然而天数是与售卖总量正相关的，所以可以不管天数，只看售卖总量，这样可以保证贪心的正确性
 。   
 #### 最后的最后
 请注意数据范围，开**long long** ，~~不然貌似只有四分，不要问我怎么知道。~~
 ##### 代码有注释，请放心食用
 ```
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
priority_queue<pair<int,int> > q;
int fa[1000100],con[1000001];
int a[1000100],s[1000100],c[1000010],x[1000010];
long long ans[1000001];
int find(int x)
{
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
int main()
{
	int n,m,k; 
	scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;++i)
    {
      scanf("%d%d%d%d",&a[i],&s[i],&c[i],&x[i]);
      q.push(make_pair(a[i]+s[i],i));
      //先把带奖励的（第一次售卖）加进队； 
	}
	for(int i=1;i<=100000;++i)
	  fa[i]=i,con[i]=m;
	  //预处理； 
	int cnt=0;
	while(!q.empty())
	{
		int day;
		int val=q.top().first,id=q.top().second;
		q.pop();
		if(x[id]==0) day=find(100000);
		//如果不会变质，根据贪心，我们尽量最后买 
		else day=find(min(100000,(c[id]-1)/x[id]+1));
		if(!day) continue;
		//如果一直指向了第零天，就代表无法出售了 
		c[id]--;
		//蔬菜库存-- ； 
		con[day]++; 
		//这一天售卖量++； 
		cnt++;
		//售出总数++； 
		if(con[day]==m) fa[day]=find(day-1);
		//如果这一天出售了M ，那么就指向前一天 
		if(c[id]) q.push(make_pair(a[id],id));
		//这一天卖的是id号蔬菜， 如果还有库存重新放回去 
		ans[cnt]=ans[cnt-1]+val; 
	}
	while(k--)
    {
    	int p;
    	scanf("%d",&p);
    	printf("%lld\n",ans[min(cnt,p*m)]);
	}
    return 0;
}

```


---

## 作者：b6e0_ (赞：6)

为什么感觉大家都做复杂了。

首先对于额外收益，转化为 $1$ 个 $a_i+s_i$ 的蔬菜和 $c_i-1$ 个 $a_i$ 的蔬菜。

根据变质的过程，显然后面的天受到的限制总是比前面的天要多，这是关键性质。

对于一次询问 $p_j$，题目的意思是 $p_j$ 天、每天最多 $m$ 个，根据性质我们可以转化为 $+\infty$ 天、每天最多 $m$ 个、一共最多 $p_jm$ 个。于是所有询问的天数都相同，不同的仅是最多卖出的蔬菜数量。考虑对于 $k=1$ 到 $\max\{p_j\}\cdot m$ 求出最多卖 $k$ 个蔬菜的最大价值。

考虑贪心地按价值从大往小卖，并且每次在合法的最晚的时间卖。由于我们仅仅需要决定的是对于所有 $i,j$，第 $i$ 天卖的第 $j$ 个蔬菜是谁（记为 $f_{i,j}$，或没卖，记为 $f_{i,j}=0$），如果当前剩余的价值最大的蔬菜 $x$ 可以在第 $i$ 天第 $j$ 个被卖出去而没有卖，那么考虑最后的方案中，若 $f_{i,j}\ne0$ 则把它换成 $x$，否则令 $f_{i,j}=x$ 并随便放弃一个价值比 $x$ 小的蔬菜，方案仍然合法且价值不减少。

一个简化是，不妨设仅有 $\max\{p_j\}$ 天而不是 $+\infty$ 天，显然不影响答案。于是把蔬菜排序，对于同种蔬菜按过期时间从晚到早选取，用序列并查集维护在某天前的最晚的还能卖的天，贪心选取即可。

因为仅有序列并查集，时间复杂度可以做到 $\mathcal O(n\log n+\max\{p_j\}\cdot m)$。代码，目前是最快解：

```cpp
constexpr int MD=100000,MN=MD+5,MF=MD*10;
int n,m,q,id[MF+5],N,p[MN*2],a[MN],d[MN],e[MN],F,fa[MN];
long long C,ans[MN],w0[MN],w1[MN];
int get(int x)
{
	if(fa[x]==x)
		return x;
	return fa[x]=get(fa[x]);
}
inline void dec(int i)
{
	e[i]--;
	if(!e[i])
		fa[i]=i-1;
}
inline bool FL(int i,long long w)
{
	if(!a[i])
		return 0;
	int j=get(d[i]?min(MD,(a[i]-1)/d[i]+1):MD);
	if(!j)
		return 0;
	dec(j);
	F++,C+=w;
	ans[id[F]]=C;
	a[i]--;
	return 1;
}
int main()
{
	n=read(),m=read(),q=read();
	for(int i=1;i<=n;i++)
	{
		w0[i]=read(),w1[i]=read(),a[i]=read(),d[i]=read();
		if(a[i])
			p[++N]=i*2,p[++N]=i*2+1;
	}
	for(int i=1;i<=q;i++)
		id[read()*m]=i;
	sort(p+1,p+N+1,[](int x,int y){
		return w0[x/2]+(x&1)*w1[x/2]>w0[y/2]+(y&1)*w1[y/2];
	});
	for(int i=0;i<=MD;i++)
	{
		fa[i]=i;
		e[i]=m;
	}
	for(int I=1;I<=N&&F<MF;I++)
	{
		int i=p[I]/2;
		if(p[I]&1)
			FL(i,w0[i]+w1[i]);
		else
			while(F<MF&&FL(i,w0[i]));
	}
	for(F++;F<=MF;F++)
		ans[id[F]]=C;
	for(int i=1;i<=q;i++)
		write(ans[i]);
	return 0;
}
```

---

## 作者：Leasier (赞：5)

蔬菜越来越多，我该怎么办？蔬菜越来越多，我该怎么办？蔬菜越来越多，我该怎么办？蔬菜越来越多，我该怎么办？蔬菜越来越多，我该怎么办？

- 与 [P8170 [eJOI2021] Waterfront](https://www.luogu.com.cn/problem/P8170) 有异曲同工之妙。

------------

首先考虑一次询问怎么做。与 P8170 相反，我们有一个贪心策略：

- 每次选出当前能选的最贵的菜，取最后一天使得我们可以在这天卖这种菜，并在这天卖掉。

维护这个东西可以考虑优先队列 + 并查集，时间复杂度为 $O(n + \sum(pm))$。

考虑优化。这里我们有一个神秘的想法：

- 不妨将 $p$ 天转化为 $pm$ 次卖菜机会。
- 考虑维护 $N = 10^5$ 时优先队列按贡献从大到小取到的每个卖菜机会。
- $p$ 天的答案为前 $pm$ 次机会的前缀和。

想到以后正确性不难证明。时间复杂度为 $O(n + Nm \log N + k)$。

代码：
```cpp
#include <iostream>
#include <queue>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct Node_tag {
	int cnt;
	int full;
	int delta;
	int val;
	Node_tag(){}
	Node_tag(int cnt_, int full_, int delta_, int val_){
		cnt = cnt_;
		full = full_;
		delta = delta_;
		val = val_;
	}
} Node;

const int N = 1e5, M = 1e6 + 7;
int root[N + 7], cnt[N + 7];
ll ans[M];
priority_queue<Node> q;

bool operator <(const Node a, const Node b){
	return a.val < b.val;
}

inline void init(int m){
	for (register int i = 1; i <= N; i++){
		root[i] = i;
		cnt[i] = m;
	}
}

int get_root(int x){
	if (root[x] == x) return x;
	return root[x] = get_root(root[x]);
}

inline void merge(int x, int y){
	int x_root = get_root(x), y_root = get_root(y);
	if (x_root != y_root) root[x_root] = y_root;
}

int main(){
	int n, m, k, pos = 0;
	scanf("%d %d %d", &n, &m, &k);
	init(m);
	for (register int i = 1; i <= n; i++){
		int a, s, c, x;
		scanf("%d %d %d %d", &a, &s, &c, &x);
		q.push(Node(1, c, x, a + s));
		if (c > 1) q.push(Node(c - 1, c - 1, x, a));
	}
	while (!q.empty()){
		int day;
		Node cur = q.top();
		q.pop();
		if (cur.delta == 0){
			day = N;
		} else {
			day = min((cur.full - 1) / cur.delta + 1, N);
		}
		day = get_root(day);
		if (day == 0) continue;
		if (--cnt[day] == 0) merge(day, day - 1);
		if (cur.cnt > 1) q.push(Node(cur.cnt - 1, cur.full - 1, cur.delta, cur.val));
		pos++;
		ans[pos] = ans[pos - 1] + cur.val;
	}
	for (register int i = 1; i <= k; i++){
		int p;
		scanf("%d", &p);
		cout << ans[min(p * m, pos)] << endl;
	}
	return 0;
}
```

---

## 作者：Karry5307 (赞：5)

### 题意

好繁琐啊，自己去看。

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13736538.html)

让我过吧 >_<

这题好神啊，口胡都没口胡出来，还是看着 yyb 的题解写出来的。

首先我不会费用流。

众所周知这个蔬菜变质的问题很烦对吧，我们不如时间倒流一下，求出最后一天能卖多少钱，然后每一天给你进一些蔬菜再推出每一天的答案。

考虑贪心。假设所有蔬菜不会变质，那么一定是卖那些贵的。所以说对于每一天来说贵的一定不会比便宜的卖的晚。

有了这个结论之后，我们能从第 $p$ 天的答案推到第 $p-1$ 天的答案。因为第 $p$ 天能卖的蔬菜第 $p-1$ 天也能卖，具体来说就是把利润最小的 $m$ 个蔬菜扔掉换成别的就好了。

所以说，关于最后一天的处理，我们可以拿个堆把所有能卖的蔬菜维护一下，然后时间倒流来暴力模拟，每一天会加进来一些蔬菜，然后贪心取一下就好了。

从 $p$ 天推到 $p-1$ 天也是可以用一个堆来维护的，维护方法也是差不太多的，只要注意一下第一次卖有额外的收益就好了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
struct Item{
	ll val,id;
	inline const bool operator <(const Item &rhs)const
	{
		return this->val<rhs.val;
	}
};
Item it;
ll n,m,qcnt,r=1e5,rr,tp,sm;
ll u[MAXN],s[MAXN],c[MAXN],x[MAXN],used[MAXN],vis[MAXN];
li res[MAXN];
Item st[MAXN];
vector<ll>v[MAXN];
priority_queue<Item>q;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read(),m=read(),qcnt=read();
	for(register int i=1;i<=n;i++)
	{
		u[i]=read(),s[i]=read(),c[i]=read(),x[i]=read();
		v[x[i]?min(r,(c[i]+x[i]-1)/x[i]):r].push_back(i);
	}
	for(register int i=r;i;i--)
	{
		for(register int j:v[i])
		{
			q.push((Item){u[j]+s[j],j});
		}
		if(q.empty())
		{
			continue;
		}
		for(register int j=m;j&&!q.empty();)
		{
			it=q.top(),q.pop();
			if(!vis[it.id])
			{
				vis[it.id]=1,res[r]+=it.val,used[it.id]++,j--;
				c[it.id]>1?q.push((Item){u[it.id],it.id}):(void)1;
			}
			else
			{
				rr=min(j,c[it.id]-used[it.id]-(i-1)*x[it.id]);
				res[r]+=(li)rr*it.val,used[it.id]+=rr,j-=rr;
				if(used[it.id]!=c[it.id])
				{
					st[++tp]=(Item){u[it.id],it.id};
				}
			}
		}
		while(tp)
		{
			q.push(st[tp--]);
		}
	}
	while(!q.empty())
	{
		q.pop();
	}
	for(register int i=1;i<=n;i++)
	{
		sm+=used[i];
	}
	for(register int i=1;i<=n;i++)
	{
		if(used[i]==1)
		{
			q.push((Item){-s[i]-u[i],i});
		}
		if(used[i]>1)
		{
			q.push((Item){-u[i],i});
		}
	}
	for(register int i=r-1;i;i--)
	{
		res[i]=res[i+1];
		while(sm>i*m&&!q.empty())
		{
			it=q.top(),q.pop(),it.val=-it.val;	
			if(used[it.id]>1)
			{
				rr=min(sm-i*m,used[it.id]-1);
				used[it.id]-=rr,sm-=rr,res[i]-=(li)rr*it.val;
				if(used[it.id]==1)
				{
					q.push((Item){-u[it.id]-s[it.id],it.id});
				}
				else
				{
					q.push((Item){-u[it.id],it.id});
				}
			}
			else
			{
				sm--,used[it.id]--,res[i]-=it.val;	
			}
		} 
	}
	for(register int i=0;i<qcnt;i++)
	{
		printf("%lld\n",res[read()]);
	}
}
```

---

## 作者：JiaY19 (赞：4)

神仙贪心题，我这种蒟蒻只能写一篇题解来 $\text{orz}$ 。

### 思路

很容易发现，我们做这道题时，正着去递推贪心及其困难。

尤其还有一些过期等限制，解决起来及其复杂。

那么我们就能有一个小小的思路：**时光倒流**。

我们从反着来递推贪心。

可以发现，过期这个限制就变成了出现。

是不是瞬间就简单多了。

### 实现步骤

首先有一个大致的步骤：

1. 算出第十万天的答案。

2. 不断往前递推，算出前面所有的贡献，列出答案表。

3. 最后 $O(1)$ 查询答案。

我们可以从 $p=10^5$ 开始从后往前推。

首先要记录每个时刻出现那些菜，可以用 $\text{vector}$。

我们考虑将每一个时刻选的的菜用优先队列来维护。

一开始从 $\text{vector}$ 加入的菜的值是 $a_i+s_i$。

因为它是第一次出现。

然后，在循环过程中，每次拿出堆顶最大的值。

我们同样还要记录这个菜有没有被选过。

如果拿出的菜没有被选过，就可以直接把这**一个**记录答案，剩下的**直接**以 $a_i$ 为权值插入优先队列。

如果拿出的菜被选过了，就能取多少取多少。

注意上述过程的答案全部都是给第十万天加的贡献。

递推非常简单。

每次删掉贡献最少的菜就可以了。

### Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 100010;

int n , m , k , a[maxn] , s[maxn] , c[maxn] , x[maxn] , ans[maxn];
int p = 100000 , now , sum[maxn] , used[maxn];

queue<pair<int , int> > r;
vector<int> l[maxn];
priority_queue< pair<int , int> > q;
priority_queue< pair<int , int> , vector<pair<int , int> > , greater< pair<int , int> > > q2;

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

signed main()
{
    // freopen("1.in" , "r" , stdin);
    // freopen("1.out" , "w" , stdout);
    n = read() , m = read() , k = read();
    for(int i = 1;i <= n;i++)
    {
        a[i] = read() , s[i] = read() , c[i] = read() , x[i] = read();
        if(x[i] == 0) l[p].push_back(i);
        else l[min(p , (c[i] + x[i] - 1) / x[i])].push_back(i);
    }
    for(int i = p;i >= 1;i--)
    {
        for(auto j : l[i]) q.push(make_pair(a[j] + s[j] , j));
        if(q.empty()) continue;
        for(int tim = m;tim >= 1 && q.empty() == 0;q.pop())
        {
            int top = q.top().second;
            // cout << top << " " << tim << " " << used[top] << " " << a[top] << " " << s[top] << " " << i << " " << ans[p] << endl;
            if(used[top] == 0)
            {
                tim--;
                ans[p] += (a[top] + s[top]) , sum[top]++ , used[top] = 1;
                if(sum[top] != c[top]) q.push(make_pair(a[top] , top));
            }
            else
            {
                int last = c[top] - (i - 1) * x[top] - sum[top];
                int del = min(last , tim);
                ans[p] += del * a[top] , sum[top] += del , tim -= del;
                if(sum[top] != c[top]) r.push(make_pair(a[top] , top));
            }
        }
        while(!r.empty()) q.push(r.front()) , r.pop();
    }
    for(int i = 1;i <= n;i++)
    {
        now += sum[i];
        if(sum[i] == 1) q2.push(make_pair(a[i] + s[i] , i));
        else if(sum[i] > 1) q2.push(make_pair(a[i] , i));
    }
    for(int i = p - 1;i >= 1;i--)
    {
        ans[i] = ans[i + 1];
        int can_del = now - i * m;
        while(can_del > 0)
        {
            int top = q2.top().second; q2.pop();
            if(sum[top] == 1)
            {
                ans[i] -= (a[top] + s[top]);
                can_del-- , now--;
            }
            else
            {
                int del = min(can_del , sum[top] - 1);
                ans[i] -= a[top] * del;
                can_del -= del , sum[top] -= del , now -= del;
                if(sum[top] > 1) q2.push(make_pair(a[top] , top));
                else if(sum[top] == 1) q2.push(make_pair(a[top] + s[top] , top));
            }
        }
    }
    for(int i = 1;i <= k;i++)
    {
        int x = read();
        cout << ans[x] << endl;
    }
    return 0;
}

```

---

## 作者：AC_Evil (赞：4)

# Problem

你有 $n$ 种疏巨，每销售一个单位第 $i$ 种疏巨，获利 $a_i$ 元。第一次销售额外获利 $s_i$ 元。开始时有 $c_i$ 单位，每天会变质 $x_i$ 份。每天你最多可以销售 $m$ 单位疏巨。

$k$ 组询问，每次询问销售 $p$ 天，获利最大值。

# Sol

$\rm orz~\mathtt{\color{black}S\color{red}yksykCCC}$

首先第一下很容易会想贪心：每天选择剩余获利最多的疏巨销售，这样子貌似很优秀。但反例也不难举出来：两种疏巨，一种收益很低，但变质很快；一种收益很高，但不会变质（或变质很慢），询问的天数很长，这样我们肯定先选变质快的，再慢慢悠悠地选择不变变质的，这样在总量上会变多。

顺着这个角度思考，发现如果天数短的话肯定优先选择收益高的疏巨（因为肯定销售不完）。

我们会发现：对于一种疏巨，满足销量的前提下，尽可能迟地销售，这样就可以为其它需要早早销售的疏巨腾出空间。

假设第 $i$ 种疏巨在销售 $d_i$ 份时，能够允许的时间为 $t_i$，可以得到两个方程

$$
\begin{cases}
\begin{aligned}
t_i\ge\lceil\frac{d_i}{m}\rceil
\end{aligned}\\
x_i(t_i-1)+d_i\le c_i
\end{cases}
$$

解得

$$\lceil\frac{d_i}m\rceil\le t_i\le\lfloor\frac{c_i-d_i}{x_i}\rfloor+1$$

我们希望其能尽可能迟地销售，则需要取一个 $T_i=t_{i,\max}=\lfloor\frac{c_i-d_i}{x_i}\rfloor+1$，同时要满足 $T_i\ge\lceil\frac{d_i}m\rceil$。

这样转化以后我们会得到一组 $(d_i,T_i)$ 的值。分析一组取值合法的条件，我们按照 $T$ 从大到小排序，假设排序后变成 $(d_{p_1},T_{p_1}),(d_{p_2},T_{p_2}),\cdots$，按照这样的顺序依次选，直接描述就是 **必须任意时刻下都能合法地选够 $m$ 份疏巨**，使用数学语言描述就是

$$\forall i>0,\sum_{k=1}^{i-1}d_{p_k}\ge m(p-T_{p_i})$$

（大白话就是前面的所有 $d$ 够塞满后 $p-T$ 天的销量）

下面考虑多销售一份疏巨时会发生什么变化。某一种疏巨的 $d$ 会增加，$T$ 可能会减小，如果没减小，式子仍然成立，无事发生；如果减小，只会影响其中的一个不等式（右端 $+m$），但也有可能使得排名发生改变，总结下来就是某一项右边 $+m$，某个前缀的所有不等式组，左边项 $+1$。但不可能一个不等式 $+m$，一个不等式 $+1$。

维护这样的东西即可，每次选择能贪到的最大权来贪一贪就行了。证明感性理解？（反正可以建费用流模型，贪心不会错，~~好吧其实我不会证~~）。

注意要先做 $p$ 最大的情况，然后再退回来做（每次把不好的疏巨丢了），要不然 $p$ 增加的时候不等式不满足条件了。仔细思考使用堆维护，复杂度 $\mathcal O(\max p_i\times m\log n)$，详细一点就是按照 $\max_p$ 从后往前扫一遍，能贪就贪。

~~代码咕咕咕啦~~

---

## 作者：SSL_wj (赞：2)

## Part.0 写在前面
本篇题解不会以模拟费用流的形式讲解贪心的思考过程。
## Part.1 题意
没什么好说的，注意一下题意中的过期是**卖掉了的不会上新**然后过期。

举个例子：

$c_i=5,x_i=2$，那么如果第一天卖了一个，那么第一天就只过期一个，如果卖了三个，那么第一天不过期，第二天过期一个。
## Part.2 部分分
直接费用流，做法参考其他题解。
## Part.3 贪心
我们采取一种特殊的方法：发现 $m\leq10$，不难猜到这是突破点，**把每天拆成多个卖菜位**！

那么接下来有一个贪心策略：每次选出当前能选的最贵的菜，并挑**最后一个空位**放进去，如果没有空位则跳过。

考虑证明其正确性，菜的尝试顺序一定最优，但是直接利用空位构造出一个方案，会出现一个问题：我们在预处理中填到了一个很靠后的位置，然后实际上并不能用这个位置。但是在**每递推一个卖菜位时，最多只会添加一个菜，因此卖菜位一定不小于卖的菜，那么不能用的位置一定可以向前移动到合法位置**，答案不变。

维护最后一个空位可以使用并查集，每次填上一个位置就将这个位置合并进前一个位置即可，即 `fa[x]=find(x-1)`。

这样我们就做掉了这道神仙贪心。

代码太丑不放了，有需要可以找我要。

---

## 作者：zhouxianzhuo (赞：1)

注意到 $n\times m$ 不大，所以其实可以把 $1$ 天拆成 $m$ 天，每天只能卖 $1$ 个单位的蔬菜，从而解除每天销售量的限制。而变质就相当于是对每 $x_i$ 个单位的蔬菜卖出的时间限制。

然后对于每种蔬菜，都可以拆出一种价值为 $a_i+s_i$，库存为 $1$ 个单位的新蔬菜，由于新蔬菜的价值比原蔬菜大，其它限制相同，所以不可能卖了原蔬菜而不卖新蔬菜，从而可以消除额外收益的影响。


考虑先计算最后一天的收益，根据贪心，我们将所有蔬菜按价值从大到小排序，并将蔬菜尽量晚的卖出去，也就是我们需要找到蔬菜限制内最晚的空闲时间将其卖出，这部分可以用并查集维护，只需令被占用的位置指向空位。

对于其它时间的答案，只需将天数从大到小扫描，每次找出已卖掉的价值最小的蔬菜并将其取消卖出，由于空位会被当前最晚卖出的蔬菜填补，所以不影响正确性。

代码如下，具体看注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct vegetable{
	int v,c,x,l;
	//分别表示 价值、库存、变质周期、期限（对于无变质周期的蔬菜而言） 
};
bool cp(vegetable x,vegetable y){
	return x.v>y.v;
}
const int lim=1e5;
int n,m,q,fa[1000010];
long long ans[100010];
vector<vegetable> vg;
priority_queue<int> h;
int find(int x){
	if(fa[x]==x)return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
void add(int x,int v){
	fa[x]=find(x-1);
	ans[lim]+=v;
	h.push(-v);
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++)
	{
		int a,s,c,x;
		scanf("%d%d%d%d",&a,&s,&c,&x);
		if(x==0)
		{
			if(s>=1)
			{
				vg.push_back((vegetable){a+s,1,0,lim*m});
				c-=1;
				//拆出额外收益 
			}
			if(c>=1)vg.push_back((vegetable){a,c,0,lim*m});
		}
		else
		{
			if(s>=1)
			{
				vg.push_back((vegetable){a+s,1,0,((c-1)/x+1)*m});
				c-=1;
				//拆出额外收益 
			}
			if(c>=1)
			{
				vg.push_back((vegetable){a,c/x*x,x,0});
				if(c%x!=0)vg.push_back((vegetable){a,c%x,0,(c/x+1)*m});
				//拆出不是整段的蔬菜 
			}
		}
	}
	for(int i=1;i<=lim*m;i++)
		fa[i]=i;
	sort(vg.begin(),vg.end(),cp);
	for(vegetable vgt:vg)
	{
		int v=vgt.v,c=vgt.c,x=vgt.x,l=vgt.l;
		if(x==0)
		{
			while(c>=1)
			{
				int tx=find(l);
				if(tx==0)break;
				add(tx,v);
				c-=1;
			}
		}
		else
		{
			for(int i=c/x;i>=1;i--)
			{
				//枚举同一周期的蔬菜段 
				bool tf=false;
				for(int j=1;j<=x;j++)
				{
					//枚举每段蔬菜的数量 
					int tx=find(i*m);
					if(tx==0)
					{
						tf=true;
						break;
					}
					add(tx,v);
				}
				if(tf)break;
			}
		}
	}
	for(int i=lim-1;i>=1;i--)
	{
		ans[i]=ans[i+1];
		for(int j=1;j<=m&&h.size()>i*m;j++)
		{
			ans[i]+=h.top();
			h.pop();
		}
	}
	//计算其它时间的答案 
	while(q--)
	{
		int k;
		scanf("%d",&k);
		printf("%lld\n",ans[k]);
	}
	return 0;
}
```

---

## 作者：Sol1 (赞：1)

本质是 P2949 的加强版（

个人感觉下面这个做法比并查集的 nb 做法好想很多（

deadline 形式的限制明示时光倒流，变成每一个时刻某一种菜多出若干单位。

然后对于第一次销售某一种类型加 $s$ 元钱的条件，就直接拆成两种菜，第一种的收益是 $a_i+s_i$，个数是 $1$，不增加；第二种收益是 $a_i$，最终个数是 $c_i-1$，每一单位时间增加 $x_i$ 个。

然后暴力模拟加菜的过程就可以做到 $O(nmkp\log n)$，可以过掉 $1\sim 15$，得到 $60$ 分。

考虑优化这一过程，每次只在优先队列中插入一个点代表一种菜每单位时间增加 $x$ 个。在每一天的 $m$ 次销售中，每一次销售取出收益最大者卖掉 $1$ 单位，如果卖光了，那么分类讨论：

- 如果这一类不会增加，则删除之。
- 如果这一类会增加，从队列中弹出，用一个临时 vector 保存。

如果还没卖光，那么就插回队列。

一天的销售之后把 vector 中所有元素插回优先队列即可。

可以发现此时每一天初始的队列中都不会有当前库存为 $0$ 的蔬菜出现，于是就可以 $O(p\log n)$ 求一个询问的答案了。总复杂度 $O(kmp\log n)$，可以过掉 $80$ 分。

然后考虑逆推，先求出 $p=10^5$ 的答案。

现在假设我们已经知道了 $p=x$ 的销售方案，考虑求出 $p=x-1$ 的销售方案。

显然最后一天的不能再卖了，对每一单位考虑把它扔到前面卖。如果前面还有空位，就直接放过去，没有损失；否则如果没有空位，则考虑前面销售的收益最小的一单位，如果它的收益小于当前的这一单位，那么放弃收益最小的这一单位，改作销售当前单位；否则就放弃当前单位。

用一个 set 维护销售集合，于是复杂度就可以做到 $O(mp\log n)$，事实上很难卡满，所以就可以过了。

```cpp
const int N = 100005;
int a[N], s[N], c[N], x[N], n, m, k, q[N], dead[N], vidx[N], res[N];
vector <int> sellout[N];

struct Node {
	int cost, k, b, addt;
	Node() {}
	Node(int cost, int k, int b, int addt) : cost(cost), k(k), b(b), addt(addt) {}
	bool operator < (const Node& b) const {
		return cost < b.cost;
	}
};
priority_queue <Node> que;
vector <Node> tmp;
multiset <pair <int, pair <int, int> > > st;

inline bool cmp(int i, int j) {
	return dead[i] > dead[j];
}

inline void Read() {
	n = qread(); m = qread(); k = qread();
	for (int i = 1;i <= n;i++) {
		a[i] = qread(); s[i] = qread(); c[i] = qread(); x[i] = qread();
		if (!x[i]) dead[i] = 1e9;
		else dead[i] = (c[i] + x[i] - 1) / x[i];
		//printf("i=%d dead=%d\n", i, dead[i]);
		vidx[i] = i;
	}
}

inline long long Brute(int mxt) {
	while (!que.empty()) que.pop();
	int cur = 1;
	long long ans = 0;
	for (int t = mxt;t >= 1;t--) {
		while (dead[vidx[cur]] >= t) {
			//printf("add %d %d %d\n", vidx[cur], a[vidx[cur]], s[vidx[cur]]);
			que.push(Node(s[vidx[cur]] + a[vidx[cur]], 0, 1, 0));
			que.push(Node(a[vidx[cur]], x[vidx[cur]], c[vidx[cur]] - 1, 0));
			cur++;
		}
		//printf("day %d\n", t);
		for (int i = 1;i <= m;i++) {
			if (que.empty()) {
				st.insert(make_pair(0, make_pair(t, i - 1)));
				sellout[t].push_back(0);
				continue;
			}
			Node cur = que.top();
			if (cur.b - (t - 1) * cur.k == 0) {
				que.pop();
				if (cur.k) tmp.push_back(cur);
				i--;
				continue;
			}
			//printf("sell %d %d\n", cur.cost, cur.b - (t - 1) * cur.k);
			ans += cur.cost;
			sellout[t].push_back(cur.cost);
			st.insert(make_pair(cur.cost, make_pair(t, i - 1)));
			cur.b--;
			que.pop();
			if (cur.b - (t - 1) * cur.k == 0) {
				if (cur.k) tmp.push_back(cur);
			} else {
				que.push(cur);
			}
		}
		for (int i = 0;i < tmp.size();i++) que.push(tmp[i]);
		tmp.clear();
	}
	return ans;
}

inline void Solve() {
	res[100000] = Brute(100000);
	for (int i = 100000;i >= 2;i--) {
		res[i - 1] = res[i];
		for (int j = 0;j < sellout[i].size();j++) st.erase(st.find(make_pair(sellout[i][j], make_pair(i, j))));
		for (int j = 0;j < sellout[i].size();j++) {
			if (st.begin()->first < sellout[i][j]) {
				res[i - 1] -= st.begin()->first;
				int x = st.begin()->second.first, y = st.begin()->second.second;
				sellout[x][y] = sellout[i][j];
				st.erase(st.begin());
				st.insert(make_pair(sellout[x][y], make_pair(x, y)));
			} else {
				res[i - 1] -= sellout[i][j];
			}
		}
	}
	while (k--) printf("%lld\n", res[qread()]);
}
```

---

## 作者：Basori_Tiara (赞：1)

这个题考虑首先蔬菜会坏掉很难搞，有的时候可能今天委屈委屈拿差点但是马上坏掉的菜，明天拿好点但是可以保存一段时间的菜会拿到更高的价值啊，比如说样例。

所以我们时光倒流变成进货，进货就好做多了。

考虑假设现在问你的是时间 $p_i$，那么从这个时间开始倒流就是每天进的菜里面拿 $m$ 个最厉害的卖，这样肯定是对的，因为你考虑菜只要来了后面都会有并且一直不会坏，每次只拿进的是因为如果可能拿剩余一定是之前余下来的，也就是进货卖不完，如果拿不了那就更没有问题了。

这样可以 $O(qp\log m)$，显然还是太慢了，但是我们真的有必要这么做吗。

我们可以从 $p=\inf$ 开始往前推进，每次卖菜，我们可以拿到 $ans_{\inf}$ 表示现在有无穷多的时间的时候能卖出多少菜。

而 $ans_{\inf-1}$ 是不是可以从 $ans_{\inf}$ 推过来呢？答案是肯定的。

因为第 $\inf$ 时刻卖掉的菜是不是第 $\inf-1$ 时刻之前也可以卖掉，我们丢掉了这个时刻只是丢掉了若干个菜位，实际上能用的蔬菜是一点没减少的，这些菜位我们完全可以直接献祭掉几个最垃圾的蔬菜，把剩下的留下来作为答案保留。

然后你这样推出所有时刻的答案就好了。

时间复杂度 $O(nm\log m+P\log n)$，其中 $P=\max p_i$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k;
struct node{
   int val,weight,num,need;
}A[100005];
struct point{
   int val,id;
   bool tag;
   bool friend operator < (const point &a,const point &b){
      return a.val<b.val||a.val==b.val&&a.tag<b.tag;
   }
};
int cnt;
int ans[100005];
int used[100005];
priority_queue<point> q;
priority_queue<int> dinner;
int all;
bool vis[100005];
const int lim=100000;
vector<int> neg[100005];
signed main(){
   scanf("%lld%lld%lld",&n,&m,&k);
   for(int i=1;i<=n;i++){
      scanf("%lld%lld%lld%lld",&A[i].val,&A[i].weight,&A[i].num,&A[i].need);
      if(A[i].need==0){
         neg[lim].push_back(i);
      }
      else{
         neg[(A[i].num+A[i].need-1)/A[i].need].push_back(i);
      }
   }
   int all=0;
   for(int i=lim;i>=1;i--){
      for(int j=0;j<neg[i].size();j++){
         q.push(point{A[neg[i][j]].val+A[neg[i][j]].weight,neg[i][j],true});
         q.push(point{A[neg[i][j]].val,neg[i][j],false});
      }
      int num=m;
      vector<int> done;
      int pos=0;
      while(num&&!q.empty()){
         point t=q.top();
         q.pop();
         int can=A[t.id].num-(i-1)*A[t.id].need-used[t.id];
         if(t.tag){
            used[t.id]++;
            num--;
            all+=t.val;
            dinner.push(-t.val);
            continue;
         }
         int F=min(num,can);
         used[t.id]+=F;
         all+=F*t.val;
         num-=F;
         done.push_back(t.id);
         for(int k=1;k<=F;k++){
            dinner.push(-t.val);
         }
      }
      for(int j=0;j<done.size();j++){
         if(A[done[j]].num-(i-2)*A[done[j]].need-used[done[j]]>0){
            q.push(point{A[done[j]].val,done[j],false});
         }
      }
   }
   ans[lim]=all;
   for(int i=lim-1;i>=1;i--){
      while(dinner.size()>i*m){
         int tmp=-dinner.top();
         dinner.pop();
         all-=tmp;
      }
      ans[i]=all;
   }
   while(k--){
      int x;
      scanf("%lld",&x);
      printf("%lld\n",ans[x]);
   }
   return 0;
}
```

---

## 作者：45dino (赞：1)

为了方便下文的描述，令 $S_p$ 表示当询问天数为 $p$ 时，卖出了哪些蔬菜，$S'_p(i)$ 表示当询问天数为 $p$ 时，第 $i$ 天卖出了哪些蔬菜。

一开始的发现：$S_{p-1}\subseteq S_p$。

这说明可以预处理出卖出蔬菜的**顺序**。（其实不然）

用一个堆维护。每次检查一下当前这个蔬菜是否过期。

> 假如价值高的蔬菜保质期较长怎么办？

这种情况下会出现对于某一个 $i<p$, $S'_{p-1}(i)\neq S'_p(i)$，但巧妙的是，$S_{p-1}\subseteq S_p$ 仍然成立。

题目只要求输出利润，不在乎具体方案，因此可以预处理出一个序列，使得每个询问对应的价值都是该序列的一个前缀。

显然值越大的越应该放在前面，因此还是用堆维护，还是检查一下当前该蔬菜是否过期。

为了避免把价值高，保质期长的蔬菜分配在前面的情况，应该把每个蔬菜尽量往后放。

具体来说，如果当前的蔬菜是第 $i$ 类，先求出这个蔬菜最远能放在第 $day$ 天，假如这一天卖出的蔬菜已经有 $m$ 个，就尝试把该蔬菜放到第 $day-1$ 天，如果仍然不行，就放到第 $day-2$ 天 $\dots$ 如果变成第 $0$ 天，说明这个蔬菜不会被加入序列。由于在此之前加入序列的蔬菜价值都不小于它，因此这样贪心是不劣的。

可以用并查集优化上述过程。

每次询问相当于求序列前 $m\times p$ 个值的和。

时间复杂度：$O(k\log k)$ 其中 $k=n\times m$。

代码不超过 $1.5$ K。

---


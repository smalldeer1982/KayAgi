# [NOI2008] 奥运物流

## 题目描述

2008 北京奥运会即将开幕，举国上下都在为这一盛事做好准备。为了高效率、 成功地举办奥运会，对物流系统进行规划是必不可少的。

物流系统由若干物流基站组成，以 $1$ 到 $n$ 进行编号。每个物流基站 $i$ 都有且仅有一个后继基站 $S_i$，而可以有多个前驱基站。基站 $i$ 中需要继续运输的物资都将被运往后继基站 $S_i$，显然一个物流基站的后继基站不能是其本身。编号为 $1$ 的 物流基站称为控制基站，从任何物流基站都可将物资运往控制基站。注意控制基站也有后继基站，以便在需要时进行物资的流通。在物流系统中，高可靠性与低成本是主要设计目的。对于基站 $i$，我们定义其“可靠性” $R(i)$ 如下： 
设物流基站 $i$ 有 $w$ 个前驱基站 $P_1,P_2,\cdots,P_w$，即这些基站以 $i$ 为后继基站，则基 站 $i$ 的可靠性 $R(i)$ 满足下式： 
$$R(i)=C_i+k \sum_{j=1}^{w}R(P_j).$$

其中 $C_i$ 和 $k$ 都是常实数且恒为正，且有 $k$ 小于 $1$。

整个系统的可靠性与控制基站的可靠性正相关，我们的目标是通过修改物流系统，即更改某些基站的后继基站，使得控制基站的可靠性 $R(1)$ 尽量大。但由于经费限制，最多只能修改 $m$ 个基站的后继基站，并且，控制基站的后继基站不可被修改。因而我们所面临的问题就是，如何修改不超过 $m$ 个基站的后继，使得控制基站的可靠性 $R(1)$ 最大化。


## 说明/提示

【样例说明】 
原有物流系统如左图所示，$4$ 个物流基站的可靠性依次为 $22.8571,21.4286,25.7143,10$。

最优方案为将 $2$ 号基站的后继基站改为 $1$ 号。

此时 $4$ 个基站的可靠性依次为 $30,25,15,10$。
本题的数据，具有如下分布： 

测试数据编号| $n$ | $m$
:-:|:-:|:-:
$1$|$\leq6$| $\leq6$
$2$|$\leq12$|$\leq12$
$3$|$\leq60$|$0$
$4$|$\leq60$|$1$
$5$|$\leq 60$|$N-2$
$6,7,8,9,10$|$\leq60$|$\leq60$

 对于所有的数据，满足 $m \leq n \leq 60$，$C_i \leq 10^6$，$0.3 \leq k < 1$，请使用双精度实数，无需考虑由此带来的误差。

## 样例 #1

### 输入

```
4 1 0.5  
2 3 1 3 
10.0 10.0 10.0 10.0```

### 输出

```
30.00 
```

# 题解

## 作者：Slr神龙人 (赞：16)

暴力搞一下，核心思想是dp和倍增，随便搞一搞就好了，那年记得我发挥不咋地，好像400多不到500
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include <cstring>
using namespace std;
const int Mx = 80;
double f[Mx][Mx][Mx],g[Mx][Mx][Mx];
double C[Mx],F[Mx],K[Mx],ans;
int n,m,fa[Mx];
void Dp(int x,int dep)
{
    for(int v=2;v<=n;v++) if(fa[v]==x) Dp(v,dep+1);
    for(int d=min(2,dep);d<=dep;d++)//不修改后继
    {
        memset(F,0,sizeof(F));
        for(int v=2;v<=n;v++)//多重背包优化
            if(fa[v]==x)
                for(int j=m;j>=0;j--)
                    for (int k=j;k>=0;k--)
                        F[j]=max(F[j],F[k]+g[v][j-k][d]);
        for(int j=0;j<=m;j++) f[x][j][d]=F[j]+C[x]*K[d];
    }
    if(dep>1)//将其后继结点修改为1
    {
        memset(F,0,sizeof(F));
        for(int v=2;v<=n;v++)
            if(fa[v]==x)
                for(int j=m;j>=0;j--)
                    for(int k=j;k>=0;k--)
                        F[j]=max(F[j],F[k]+g[v][j-k][1]);
        for(int j=1;j<=m;j++) f[x][j][1]=F[j-1]+C[x]*K[1];
    }
    for(int j=0;j<=m;j++)
        for(int d=0;d<dep;d++)
            g[x][j][d]=max(f[x][j][d+1],f[x][j][1]);
}

int main()
{
    cin>>n>>m>>K[1];
    K[0]=1; for (int i=2;i<=n;i++) K[i]=K[i-1]*K[1];
    for(int i=1;i<=n;i++)
    {
        int x;scanf("%d",&x);
        fa[i]=x;
    }
    for(int i=1;i<=n;i++) cin>>C[i];
    for(int now=fa[1],len=2;now!=1;now=fa[now],len++)//枚举环长 
    {
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        int tmp=fa[now]; double sum=0; fa[now]=1;//断环 
        for(int v=2;v<=n;v++) if(fa[v]==1) Dp(v,1);
        memset(F,0,sizeof(F));
        for(int v=2;v<=n;v++)//因为1的儿子未修改，所以用f而不是g更新F
            if(fa[v]==1)
                for(int j=m;j>=0;j--)
                    for(int k=j;k>=0;k--)
                        F[j]=max(F[j],F[k]+f[v][j-k][1]);
        for(int j=0;j<m;j++) sum=max(sum,F[j]);
        if(tmp==1) sum=max(sum,F[m]);//若now的fa为1，则断环未修改
        ans=max(ans,(sum+C[1])/(1-K[len]));//更新答案 
        fa[now]=tmp;//还原父结点
    }
    printf("%.2lf\n",ans);
    return 0;
}
```

---

## 作者：Little_Jian (赞：15)

[个人博客链接](http://www.chenhowe.me/?p=3008)

### 思路：
　　单独考虑每个点对答案的贡献，设 $d_i$ 表示 $i$ 到 $1$ 的距离，那么它产生的贡献就是 $k^{d_i}C_i$ 再加上环对答案的影响，所以 $R(1) = \frac{\sum_{i=1}^n k^{d_i}C_i}{1-k^{len}},len$ 为环长。
　　这样的话，不难发现每次修改肯定是把一个点连到 $1$ 的下面。
　　设 $dp[o][m][d]$ 表示在 $o$ 子树内当 $o$ 的深度为 $d$ 还有 $m$ 次修改机会时的最大可靠值。在树上的修改就是一个类似背包的 $\text{dp}$ 复杂度 $O(n^4)$。
　　但是如果对环做修改就会影响下面的分母。所以还要再枚举环长，每次重新 $\text{dp}$，所以复杂度就是 $O(n^5)$ 的。

### 代码：
``` cpp
#include <bits/stdc++.h>
#define File(_) freopen(#_ ".in", "r", stdin), freopen(#_ ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
#define mset(a, b) memset(a, b, sizeof a)
#define rep(i, a, b) for(int i(a), i##_END_(b); i <= i##_END_; i++) 
#define drep(i, a, b) for(int i(a), i##_END_(b); i >= i##_END_; i--)
using namespace std;
template<class T> inline bool tomax(T &a, T b) {return a < b ? a = b, 1 : 0;}
template<class T> inline bool tomin(T &a, T b) {return b < a ? a = b, 1 : 0;}
typedef long long ll;
typedef double db;

const int N = 65;

template<int N, int M, class T> struct Link {
#define erep(k, G, o) for(int k(G.HEAD[o]); k; k = G.NXT[k])
    int HEAD[N], NXT[M], tot; T W[M];
    void clear() {mset(HEAD, 0); tot = 0;}
    void add(int x, T w) {NXT[++tot] = HEAD[x]; W[HEAD[x] = tot] = w;}
    T& operator[] (int k) {return W[k];}
};
Link<N, N * 2, int> G;

int s[N];
db c[N], k;

db dp[N][N][N], tmp[N][N];
db pw[N];
void dfs(int o, int m, int dep) {
    rep(i, 0, m) rep(d, 0, dep) dp[o][i][d] = c[o] * pw[d];
    erep(k, G, o) {
        int v = G[k];
        dfs(v, m, dep + 1);
        mset(tmp, 0);
        rep(i, 0, m) rep(j, 0, m - i) rep(d, 0, dep) {
            tomax(tmp[i + j][d], dp[o][i][d] + dp[v][j][d + 1]);
            if(j > 0) tomax(tmp[i + j][d], dp[o][i][d] + dp[v][j - 1][1]);
        }
        rep(i, 0, m) rep(d, 0, dep) dp[o][i][d] = tmp[i][d];
    }
}
db calc(int m) {
    dfs(1, m, 0);
    return dp[1][m][0];
}

int main() {
    File(trans);
    int n, m;
    scanf("%d%d%lf", &n, &m, &k);
    pw[0] = 1.0; rep(i, 1, n) pw[i] = pw[i - 1] * k;
    rep(i, 1, n) scanf("%d", &s[i]);
    rep(i, 1, n) scanf("%lf", &c[i]);
    db ans = 0;
    for(int d = 2, p = s[1]; p != 1; d++, p = s[p]) {
        G.clear();
        int t = s[p]; s[p] = 1;
        rep(i, 2, n) G.add(s[i], i);
        tomax(ans, calc(m - (t != s[p])) / (1 - pw[d]));
        s[p] = t;
    }
    printf("%.2lf\n", ans);
    return 0;
}
```

---

## 作者：Aly_ (赞：13)

#### **分析**

​	先考虑怎么算 $R(i)$。

​	考虑一个简单情况：$n$ 个点组成一个环，$1,2,\cdots n$ 顺次连边。列方程组
$$
\{R(i)=C_i+k*R(i\%n+1)\qquad(i\in\{1,2,\cdots,n\})
$$
​	手动消元，每一行对着最后一行消，解得
$$
R(1)=\frac{\sum_i(C_ik^{i-1})}{1-k^n}
$$
​	另一种情况，如果 $n$ 个点组成了一棵内向树，易得
$$
R(1)=\sum_iC_ik^{depth(i)}
$$
​	其中 $depth$ 表示深度，$depth(1)=0$。

​	总和上面两点就能得到一般情况下
$$
R(1)=\frac{\sum_iC_ik^{dis(i\rightarrow 1)}}{1-k^L}
$$
​	$L$ 为环长。

#### **求解**

​	既然一个点的贡献只与其到 $1$ 经过的边数有关，可以直接无视从 $1$ 出发的边，以 $1$ 为根建内向树。考虑修改后继节点的过程，容易发现最优情况一定是把它的后继节点直接修改成 $1$。先不考虑环的问题，假设我们选择了 $p_1,\cdots,p_m$ 作为 $1$ 的儿子，设对于点 $x$，
$$
S(x)=C_x+\sum_{fa_i=x}kS(i)
$$
​	则待求 $R(1)$ 可表示为
$$
S(1)+k\sum_{p_i}(1-k^{dis(p_i\rightarrow up_i)})S(p_i)
$$
​	其中 $up_i$ 表示 $p_i$ 祖先中深度最大的被选中的点，即，向上跳跳到的第一个被选中点（若没有则看做 $1$）。

​	有一个树形 DP 的形式了。

​	再考虑环。容易发现原来环上的点变为一条树上到根路径。把一些点父亲修改后，环长必然缩小，并且一定是原来路径的一条前缀（从下往上），末端的点为这条路径上深度最大的选中点。

​	设 $DP[i][j][k][l]$ 表示：当前处理 $i$ 子树内答案，上面最近的被选中点到 $i$ 的距离为 $j$，子树内选了 $k$ 个，原来环对应路径上的点选的最大深度为 $l$。

​	转移枚举 $i$ 选不选，从第二维 $j+1$ 或 $0$ 转移上来，第三维和卷积，第四维 max 卷积。

​	加入一些优化后可过本题。因为树上背包的优化有时会降复杂度，所以本算法复杂度玄学。（不高于 $n^5$ 级别）

​	细节很有点多...?

```
#include<bits/stdc++.h>
#define int long long
#define N 60
#define inf 999999999999
using namespace std;
int n,m,nxt[N+1],lp[N+1],fl[N+1],dpt[N+1],dpt1,mdpt,sz[N+1];
double K,dp[N+1][N+1][N+1][N+1],g[N+1][N+1],pk[N+1],s[N+1],c[N+1],ans,f1[N+1][N+1];
vector<int>ve[N+1];
void putin(){
	cin>>n>>m>>K;
	for(int i=1;i<=n;i++){
		cin>>nxt[i];
		if(i!=1)ve[nxt[i]].push_back(i);
	}
	for(int i=1;i<=n;i++)cin>>c[i];
}
void ttree(int x,int ndpt){
	dpt[x]=ndpt,sz[x]=1;if(nxt[1]==x)dpt1=ndpt;mdpt=max(mdpt,ndpt);
	for(int i=0;i<ve[x].size();i++){
		int ni=ve[x][i];
		if(ni!=1)ttree(ni,ndpt+1),sz[x]+=sz[ni];
	}
}
void ycl(){
	int np=1;
	do{lp[np]=1,np=nxt[np];}while(np!=1);
	pk[0]=1;for(int i=1;i<=n;i++)pk[i]=pk[i-1]*K;
	for(int i=1;i<=n;i++)for(int j=0;j<=n;j++)for(int k=0;k<=n;k++)for(int l=0;l<=n;l++)dp[i][j][k][l]=-inf;
	for(int i=1;i<=n;i++)for(int j=0;j<=n;j++)dp[i][j][0][0]=0;
	for(int k=0;k<=n;k++)for(int l=0;l<=n;l++)if(k+l)f1[k][l]=-inf;
}
void dfs0(int x,int ndpt){
	s[x]=c[x],dpt[x]=ndpt;if(nxt[1]==x)dpt1=ndpt;
	for(int i=0;i<ve[x].size();i++){
		int ni=ve[x][i];
		if(ni!=1)dfs0(ni,ndpt+1),s[x]+=s[ni]*K;
	}
	for(int i=0;i<ve[x].size();i++){
		int ni=ve[x][i];
		for(int j=0;j<=ndpt;j++){
			for(int k=0;k<=n;k++)for(int l=0;l<=n;l++)g[k][l]=dp[x][j][k][l],dp[x][j][k][l]=-inf;
			for(int k=sz[x];k>=0;k--){
				for(int l=mdpt;l>=0;l--){
					if(g[k][l]<0||(l<dpt[x]&&l))continue;
					for(int p=min(sz[x]-k,sz[ni]);p>=0;p--){
						for(int q=mdpt;q>=0;q--){
							if(q<dpt[ni]&&q)continue;
							dp[x][j][k+p][max(l,q)]=max(dp[x][j][k+p][max(l,q)],g[k][l]+dp[ni][j+1][p][q]);
							if(p>=1)dp[x][j][k+p][max(l,(lp[ni]?max(dpt[ni],q):q))]=max(dp[x][j][k+p][max(l,(lp[ni]?max(dpt[ni],q):q))],g[k][l]+dp[ni][0][p-1][q]+(1-pk[j+1])*s[ni]);
						}
					}
				}
			}
		}
	}
}
signed main(){
	putin();
	ttree(1,0);
	ycl();
	dfs0(1,0);
	for(int i=0;i<ve[1].size();i++){
		int ni=ve[1][i];
		for(int k=0;k<=n;k++)for(int l=0;l<=n;l++)g[k][l]=f1[k][l],f1[k][l]=-inf;
		for(int k=sz[1];k>=0;k--){
			for(int l=mdpt;l>=0;l--){
				for(int p=sz[1]-k;p>=0;p--){
					for(int q=mdpt;q>=0;q--){
						if(p>=1)f1[k+p][max(l,(lp[ni]?max(dpt[ni],q):q))]=max(f1[k+p][max(l,(lp[ni]?max(dpt[ni],q):q))],g[k][l]+dp[ni][0][p-1][q]+(1-K)*s[ni]);
					}
				}
			}
		}
	}
	for(int i=0;i<=m+ve[1].size();i++){
		for(int j=0;j<=dpt1;j++){
			ans=max(ans,(K*(s[1]+f1[i][j])+(1-K)*c[1])/(1-pk[dpt1-j+2]));
		}
	}
	printf("%.2f\n",ans);
	return 0;
}
```



---

## 作者：Leo235 (赞：4)

- # [NOI2008] 奥运物流 解题报告

  ### 前言

  本文是本人在看论文时自己的一些理解和笔记，部分细节可以阅读论文以更进一步理解，论文链接附在文末。

  ### 题目分析

  $P_i$ 表示该点的前驱节点，贡献为
  $$
  R(i) = C_i + k \sum_{j = 1}^{w} R(P_j)
  $$
  所有基站构成了一个树形结构，由于所有点都可以到 $1$ 号点，所以每棵树的根又连在一个环上，最终构成一棵**基环树**（如图 1.1）。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/1qtrfwtk.png)

  ​																图 1.1

  那么我们可以从**两个角度**入手：树的情况、环的情况。

  ### 思路

  #### 分类讨论

  1. 树上的情况，我们看点 $i$ 到点 $1$ 的贡献。我们可以列出如下方程：
     $$
     \begin{cases}
     R(1) = C_1 + k \sum_{j = 1}^{w} R(P_j) = C_1 + k(R(P_2) + R(P_3) + R(P_4) + \dots) \\
     R(2) = C_2 + k \sum_{j = 1}^{w} R(P_j) = C_2 + k(R(P_{a_1}) + R(P_{a_2}) + R(P_{a_3}) + \dots) \\
     \dots
     \end{cases}
     $$
     让我们浅解一下，举几个例子进行手动求解，不难发现$^{[1]}$此方程的解 $R(1)$ 为
     $$
     R(1) = \sum_{i = 1} k^{\operatorname{dis}(i, 1)} \cdot C_i
     $$
     其中，$\operatorname{dis}(i, 1)$ 表示点 $i$ 到点 $1$ 的距离。

  2. 环上的情况，假设环的大小记为 $l$，那么最终的贡献为
     $$
     R(1) = \frac{\sum_{i = 1} k^{\operatorname{dis}(i, 1)} \cdot C_i}{1 - k^l}
     $$

  #### 构造求解

  考虑枚举环的大小，那么 $1 - k^l$ 在每次循环中为定值，于是仅需考虑如何让分子更大。

  如何实现改变环的大小？可以通过修改环上某个点的后继来实现（图 2.1，将图 1.1 中 $5 \to 4$ 的边改为 $5 \to 1$，使环的大小减一）。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/i5zlc2kc.png)

  ​																图 2.1

  此时，我们发现一种情况，以 $i$ 为根树上的一个点 $j$，若已经连向了 $1$ 号点，那么修改 $i$ 的后继就不会对 $j$ 产生影响，此时贡献无法统一更新，即出现了**先前的决策会对后续决策产生影响**的情况。于是，我们转而考虑如何均摊这种影响。

  首先，来看如何构造基本的 $dp$ 式：构造 $dp[i][j]$ 表示以 $i$ 为根节点的子树上，使用了 $j$ 次修改后的答案。

  通过画图发现：某个点的贡献改变取决于**离它最近的被修改的祖先**，所以不妨新增一个状态表示这个信息，得到 $dp[i][j][d]$ 表示以 $i$ 为根的子树中，修改 $j$ 次，且点 $i$ 到 $1$ 的距离为 $d$ 的最大答案。

  现在我们来推导状态转移方程。

  引入辅助数组 $g[i][j][d]$，记录贡献，有 $g[i][j][d] = \max\{ dp[i][j][1], dp[i][j][d+1] \}$，同时规定 $s_1, s_2, \dots, s_t$ 为 $i$ 的 $t$ 个儿子。

  由此，我们可以推导$^{[2]}$：

  1. 当 $i$ 不修改后继时，
     $$
     dp[i][j][d] = \max \left\{ g[s_1][j_1][d] + g[s_2][j_2][d] + \dots + g[s_t][j_t][d] \right\} + C[i] \cdot k^d, \quad \left(\sum_{a = 1}^{t} j_a = j\right)
     $$
     此处可进行优化，对 $\max$ 再进行 $DP$。

  2. 当 $i$ 修改后继时，
     $$
     dp[i][j][1] = \max \left\{ g[s_1][j_1][1] + g[s_2][j_2][1] + \dots + g[s_t][j_t][1] \right\} + C[i] \cdot k, \quad \left(\sum_{a = 1}^{t} j_a = j - 1\right)
     $$

  3. 环上的情况，已经在 $DP$ 过程中进行枚举，故答案为
     $$
     \max \left\{ dp[u_1][j_1][0] + dp[u_2][j_2][1] + \dots + dp[u_{l}][j_{l}][l-1] \right\}, \quad \sum j_i = m
     $$
     其中，$u_i$ 为环上的点。这里同样可以优化。

  于是，我们就在理论层面推完了本题，但实现上仍存在许多小细节， 建议同学们自己推一下。

  #### 注释

  [1]：让我们举个例子，当 $n$ 个点构成一条链时，有
  $$
  \begin{aligned}
  R(1) &= C_1 + k \sum R(P_j) \\
       &= C_1 + k (C_2 + k R(3)) \\
       &= C_1 + k C_2 + k^2 R(3) \\
       &= C_1 + k C_2 + k^2 C_3 + k R(4) \\
       &= \dots
  \end{aligned}
  $$
  整理发现
  $$
  R(1) = \sum k^{i-1} C_i
  $$
  再来看，当构成的树为 $Edge = \{ \{1, 2\}, \{1, 3\}, \{2, 3\}, \{2, 6\}, \{4, 5\} \}$，模拟一下，有
  $$
  R(5) = C_5, \quad R(6) = C_6, \quad R(3) = C_3
  $$

  $$
  \begin{aligned}
  R(2) &= C_2 + k (R(4) + R(6)) \\
       &= C_2 + k C_4 + k^2 C_5 + k C_6
  \end{aligned}
  $$

  $$
  \begin{aligned}
  R(1) &= C_1 + k (R(2) + R(3)) \\
       &= C_1 + k C_2 + k^2 C_4 + k^3 C_5 + k^2 C_6 + k C_3
  \end{aligned}
  $$

  观察一下，不难发现文中的结论。

  [2]：参考文献：徐源盛，[《对一类动态规划问题的研究》](https://github.com/OI-wiki/libs/tree/master/%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2009%E8%AE%BA%E6%96%87%E9%9B%86/8.%E5%BE%90%E6%BA%90%E7%9B%9B%E3%80%8A%E5%AF%B9%E4%B8%80%E7%B1%BB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E3%80%8B)，要打开可能要想点办法。

---


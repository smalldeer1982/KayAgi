# [NOI2005] 月下柠檬树

## 题目描述

李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。

李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？

李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。

李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\mathrm{alpha}$。

![](https://cdn.luogu.com.cn/upload/pic/13770.png)

为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。

## 说明/提示

对于 $10 \%$ 的数据，$n \leq 1$；

对于 $30 \%$ 的数据，$n \leq 2$；

对于 $60 \%$ 的数据，$n \leq 20$；

对于 $100 \%$ 的数据，$1 \leq n \leq 500$，$0.3 < \mathrm{alpha} < \frac{\pi}{2}$，$0 < h_i \leq 100$，$0 < r_i \leq 100$。

## 样例 #1

### 输入

```
2  0.7853981633 
10.0  10.00  10.00 
4.00  5.00```

### 输出

```
171.97```

# 题解

## 作者：SuperJvRuo (赞：44)

蒟蒻写了一上午才把这题写明白T_T，这篇题解是给刚接触计算几何、simpson公式的同学们看的，有基础请看其他dalao题解。

## 题意

求一棵由圆台、圆锥组成的树在平行光下的投影。

## 分析

![](https://cdn.luogu.com.cn/upload/pic/15148.png )

圆台投在地上形成圆和梯形；圆锥投在地上形成圆和三角形。圆投在地上，得到一个与原来等大的圆，梯形和三角形的高变为原来的$\frac{1}{tan(\alpha)}$，像这样(图片由Windows10自带的画图3D制作)：

![](https://cdn.luogu.com.cn/upload/pic/15147.png )

如果树更复杂一点，可能是这样（下图来自CSDN）

![](https://cdn.luogu.com.cn/upload/pic/15149.png )

我们要求的就是这样的面积并。

咋求啊？

## Section 1：~~Simple~~ Simpson公式

自适应Simpson公式(adaptive Simpson's rule)是一种像二分法、三分法一样的数值方法。我们先来看Simpson公式：

$$\int ^b_a f(x)dx=(b-a)\frac{f(a)+4f(\frac{a+b}{2})+f(b)}{6}$$

就这么搞？这公式准确吗？

当然……不准确了。但是把整个函数分成若干段，分开计算Simpson，分段越多，越接近准确值，但计算量也就越大。我们可以这样搞：取$[a,b]$的中点$c$，当$|S(a,c)+S(c,b)-S(a,b)|<EPS$时返回结果，否则递归下去，像这样：
```
#define EPS 1e-7

double F(double x)
{
	//do something
}

//三点Simpson法，这里要求F是一个全局函数
double simpson(double a, double b)
{
	double c = a + (b - a) / 2.0;
    return (b - a) * (F(a) + 4.0 * F(c) + F(b)) / 6.0;
}

//自适应Simpson公式
double asr(double a, double b, double ans)
{
	double c = a + (b - a) / 2.0;
    double left = simpson(a, c), right = simpson(c, b);
    if(fabs(left + right - ans) < EPS)
    	return left + right;
    else
    	return asr(a, c, left) + asr(c, b, right);
}

int main()
{
	printf("%lf", asr(simpson(l, r, simpson(l, r))));
    return 0;
}
```
这就很~~Simple~~Simpson了是不是？

## Section 2：计算几何——求公切线

我们发现，圆形和梯形是这样合并的：

![](https://cdn.luogu.com.cn/upload/pic/15162.png )

梯形的两腰正是两个圆的公切线。本题需要公切线的左右两端的横坐标（即把这一段视为函数后的定义域），斜率，和纵截距。

![](https://cdn.luogu.com.cn/upload/pic/15169.png )

如图，$x$轴是影子的对称轴，$\bigodot A$与$\bigodot C$的公切线之一是直线$BG$，过点$G$、点$B$分别作$x$轴的垂线。四边形$BJCG$是矩形。原点$O$是柠檬树的树根（在屏幕外面）。

由圆台高度和$\alpha$的余切值，我们可以求出线段$OC,OA$的长度，即可得$AC=OA-OC$。

由两个圆的半径可得$AJ=CG-AB$。

显然，$sin\angle CGK=sin\angle ACJ=\frac{AJ}{AC}$，$CK=sin\angle CGK \cdot CG$，$OK=OC+CK$，$OK$的值即为定义域的左端。我们也可以以相同方法求出$\bigodot A$切点的横坐标，即定义域右端。

然后我们就可以通过勾股定理求出$GK$的长，进而得到$G$的坐标，对$B$进行相同处理后，确定了公切线上的两点，我们就可以得到公切线的斜率与纵截距，求出公切线的解析式。

至此，这道题的所有难点都已经攻破，上代码！
```
#include<cstdio>
#include<cmath>
#define EPS 1e-7

double alpha;
int n;
struct circle
{
	double x, r;
	//x为投影圆心到树根的距离，r为半径 
}p[1000];

struct tan_line
{
	double k, b, left, right;
	//f(x)=kx+b,x∈[left,right]
}q[1000];

double Gougu(double a, double b)//a是斜边 
{
	return sqrt(a*a - b * b);
}

void get_tan(int x, int y)
{
	if (fabs(p[x].r - p[y].r)<EPS)//实数比较记得带上EPS 
	{
		q[x].left = p[x].x;
		q[x].right = p[y].x;
		q[x].k = 0; q[x].b = p[x].r;
		return;
	}
	double dx = p[y].x - p[x].x, dr = fabs(p[x].r - p[y].r);
	//dx即图中的AC，dr即图中的AJ 
	double ly, ry;
	if (p[x].r>p[y].r)
	{
		q[x].left = p[x].x + p[x].r*dr / dx;//公切线左端 
		q[x].right = p[y].x + (q[x].left - p[x].x)*p[y].r / p[x].r;//公切线右端 
		ly = Gougu(p[x].r, q[x].left - p[x].x);//勾股定理求F(left)
		ry = Gougu(p[y].r, q[x].right - p[y].x);//勾股定理求F(right) 
		q[x].k = (ly - ry) / (q[x].left - q[x].right);//求斜率 
		q[x].b = ly - q[x].left*q[x].k;//求纵截距 
	}
	else//另一种情况，同理 
	{
		q[x].right = p[y].x - p[y].r*dr / dx;
		q[x].left = p[x].x - (p[y].x - q[x].right)*p[x].r / p[y].r;
		ly = Gougu(p[x].r, q[x].left - p[x].x);
		ry = Gougu(p[y].r, q[x].right - p[y].x);
		q[x].k = (ly - ry) / (q[x].left - q[x].right);
		q[x].b = ly - q[x].left*q[x].k;
	}
}

double F(double x)
{
	double ans = 0.0;
	for (int i = 1; i <= n; ++i)
	{
		if (x<p[i].x + p[i].r&&x>p[i].x - p[i].r)//x在这一段内 
		{
			//迭代答案 
			ans = ans>Gougu(p[i].r, x - p[i].x) ? ans : Gougu(p[i].r, x - p[i].x);
		}
	}
	for (int i = 1; i <= n; ++i)
	{
		if (x >= q[i].left&&x <= q[i].right)//x在这一段内 
		{
			//迭代答案 
			ans = ans>q[i].k*x + q[i].b ? ans : q[i].k*x + q[i].b;
		}
	}
	return ans;
}

//三点Simpson法 
double simpson(double a, double b)
{
	double c = a + (b - a) / 2.0;
	return (b - a) * (F(a) + 4.0 * F(c) + F(b)) / 6.0;
}

//自适应Simpson公式 
double asr(double a, double b, double ans)
{
	double c = a + (b - a) / 2.0;
	double left = simpson(a, c), right = simpson(c, b);
	if (fabs(left + right - ans) < EPS)
	{
		return left + right;
	}
	else
	{
		return asr(a, c, left) + asr(c, b, right);
	}
}

int main()
{
	scanf("%d %lf", &n, &alpha);
	alpha = 1.0 / tan(alpha);//我们只会用到cot(alpha) 
	scanf("%lf", &p[1].x);
	p[1].x *= alpha;
	for (int i = 2; i <= n + 1; ++i)
	{
		scanf("%lf", &p[i].x);
		p[i].x *= alpha;
		p[i].x += p[i - 1].x;
	}
	for (int i = 1; i <= n; ++i)
		scanf("%lf", &p[i].r);
	++n;
	p[n].r = 0.0;//树顶是圆锥 
	for (int i = 1; i <= n - 1; ++i)
	{
		get_tan(i, i + 1);//求i与i+1间的切线 
	}

	//迭代整个影子的最低点和最高点 
	double ll = p[1].x - p[1].r, rr = p[n].x;
	for (int i = 1; i <= n; ++i)
	{
		rr = rr>(p[i].x + p[i].r) ? rr : (p[i].x + p[i].r);
		ll = ll<(p[i].x - p[i].r) ? ll : (p[i].x - p[i].r);
	}
	printf("%.2lf\n", 2.0*asr(ll, rr, simpson(ll, rr)));
	//我们只算了影子的一半，所以还要乘2 
	return 0;
}
```

---

## 作者：littlez_meow (赞：15)

# 几何萌新也能看懂的题解TwT
太阴间了，我的devc++崩了3次。

本题解含有较详细证明，除积分部分初中数学水平就能懂。

我们的口号是：~~没有蛀牙~~人能做的绝不留给计算机，人难做的全部丢给计算机。

[题目指路](https://www.luogu.com.cn/problem/P4207)

## step 1:投影形状
让我们分析一下投影的形状。

![圆锥的投影](https://cdn.luogu.com.cn/upload/image_hosting/zqcm8hie.png)

可以看见，投影由圆和圆的切线两部分组成。

推广到圆台，圆锥可看作顶面是半径为0的圆的圆台，圆的切线变为两圆的公切线。

因此，我们要求的就是若干个圆和相邻两个圆公切线与x轴围成的图形。

## step 2:建系
以树根为原点，月光方向到平面上的射影为x轴正方向，建立平面直角坐标系。

下面我们要求各个圆的圆心坐标。
具体地说，其纵坐标均为0，只用求横坐标。

如图，已知$AB//CD,AC=h,∠ABO=\alpha$，求$BD$。
![圆心坐标](https://cdn.luogu.com.cn/upload/image_hosting/9sesx86c.png)

解:作$AE//BD$交CD于E

$\because AB//CD$

$\therefore$四边形$ABDE$为平行四边形，$∠ABO=∠CDO=∠AEC=\alpha$

$\therefore AE=BD$

在$RT\triangle CAE$中，$AE=\cot(\alpha)AC=\cot(\alpha)h$

$\therefore BD=\cot(\alpha)h$

因此，每个圆的横坐标就都求出来了，该圆高度乘$\cot(\alpha)$

## step 3:公切线

由于形状关于x轴对称，我们只用考虑上面一半。

如图，已知$A(a,0),B(b,0),\odot A$半径为$r_1,\odot B$半径为$r_2$,求公切线切点坐标

![公切线](https://cdn.luogu.com.cn/upload/image_hosting/t5vp0old.png)

解:作CF$\perp$AB于F,DE$\perp$AB于E,连接AC,BD
作AG$\perp$BD交BD于G

$\therefore$四边形ACDG是矩形

$\therefore∠AFC=∠CAG=∠BDE=90$°

$\therefore∠ABG+∠BAG=∠CAF+∠BAG=90$°

$\therefore∠ABG=∠CAF$

$\therefore\triangle ACF\sim\triangle BAG\ $(AA)

同理可得$\triangle BDE\sim\triangle BAG$

$\therefore\frac{AC}{AB}=\frac{AF}{BG},\frac{BD}{AB}=\frac{BE}{BG}$

依题意得，x轴上方两半圆解析式分别为
$y=\sqrt{r_1^2-(x-a)^2},y=\sqrt{r_2^2-(x-b)^2}$

设公切点C,D的坐标分别为$(u,\sqrt{r_1^2-(u-a)^2}),(v,\sqrt{r_2^2-(v-b)^2})$

$\therefore F(u,0),E(v,0)$

$\therefore \left\{\begin{matrix} \frac{r_1}{b-a}=\frac{x-a}{r_1-r_2}
 \\ \frac{r_2}{b-a}=\frac{y-b}{r_1-r_2}
\end{matrix}\right.$

解之即可。

设$CD:y=kx+b$

$\therefore \left\{\begin{matrix} \sqrt{r_1^2-(u-a)^2}=ku+b
 \\ \sqrt{r_2^2-(v-a)^2}=kv+b
\end{matrix}\right.$

即可得公切线解析式

在面积计算过程中中，我们用不到两个公切点之外的部分，因此不妨将$[u,v]$作为它的定义域。

另外，上面仅仅是$r_1>r_2$的部分，$r_1<r_2$时两者相减的顺序会改变，$r_1=r_2$时分母会变成0，在实现时注意分类讨论。

## step 4:面积
我们要求$f(x)$与x轴围成的面积，其中$f(x)$是所有圆和公切线的在x处实数范围内的最大值。显然，$f(x)$是一个非常复杂的分段函数，正如我们的口号，考虑让计算机解决。

我们枚举每个圆和公切线，x在定义域内的最大值就是$f(x)$的值。

既然是求于坐标轴围成的面积，那不难想到积分。问题是，怎么让计算机求积分？

## step 5:自适应辛普森法求定积分

既然原函数不好求，我们可以把它近似成一个好求的函数。一次函数精度太低，三次以上函数计算次数多，因此我们选用二次函数。

求证(三点辛普森公式):$\int_{a}^{b} f(x)dx\approx\frac{b-a}{6}(f(a)+f(b)+4f(\frac{a+b}{2}))$

证明:设$f(x)\approx Ax^2+Bx+C$

$\therefore \int_a^b f(x)\approx\int_a^b (Ax^2+Bx+C)dx$

$=(\frac A 3 x^3+\frac B 2 x^2+Cx)|_a^b$

$=\frac A 3 b^3+\frac B 2 b^2+Cb-\frac A 3 a^3-\frac B 2 a^2-Ca$

$=\frac A 3 (b-a)(a^2+ab+b^2)+\frac B 2 (b-a)(b+a)+C(b-a)$

$=(b-a)(\frac A 3 (a^2+ab+b^2)+\frac B 2 (b+a)+C)$

$=\frac {b-a} 6 (2Aa^2+2Aab+2Ab^2+3Ba+3Bb+6C)$

$=\frac {b-a} 6 (Aa^2+Ba+C+Ab^2+Bb+C+A(a^2+2ab+b^2)+2B(a+b)+4C)$

$\approx\frac {b-a} 6 (f(a)+f(b)+4(A(\frac {a+b} 2)^2+B(\frac {a+b} 2)+C))$

$=\frac {b-a} 6 (f(a)+f(b)+4f(\frac {a+b} 2))$

$\therefore \int_{a}^{b} f(x)dx\approx\frac{b-a}{6}(f(a)+f(b)+4f(\frac{a+b}{2}))$

证毕

根据$\int_a^bf(x)dx=\int_a^cf(x)dx+\int_c^bf(x)dx,$我们可以把区间拆成若干小段，再进行计算。

但是，面对随机数据，我们不能定下一个区间长度来保证精度。因此，我们把这件事交给电脑。在求解难以求解的方程时，我们通过二分高效求出了满足精度范围的解。我们可以借用这种思想，利用二分既保证速度又保证精度地求出积分值。

记$g(a,b)=\int_a^bf(x)dx,s(a,b)=\frac{b-a}{6}(f(a)+f(b)+4f(\frac{a+b}{2}))$

那么，$g(a,b)\approx\begin{cases}
  &s(a,b) \text{ if } s(a,\frac {a+b} 2)+s(\frac {a+b} 2,b)-s(a,b)<\varepsilon \\
  &g(a,\frac {a+b} 2)+g(\frac {a+b} 2,b) \text{ otherwise } 
\end{cases}$
其中$\varepsilon$是精度

这就是所谓的“自适应”，即在误差大时多分一点，误差小时少分一点。

至此，注意细节方面，即可通过本题。

## step 6:附上代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a);i<=b;++i)
#define R(i,a,b) for(int i(a);i>=b;--i)
#define _ 0
#define mp make_pair
#define fir first
#define sec second
const double EPS=1e-8;
using namespace std;
int n,cnt;
double alpha;
pair<double,double>circle[502];
pair<pair<double,double>,pair<double,double> >line[501];
inline double func(double x){
	double ans=0.0;
	F(i,1,n) if(x>=circle[i].fir-circle[i].sec&&x<=circle[i].fir+circle[i].sec){
		ans=max(ans,sqrt(circle[i].sec*circle[i].sec-(x-circle[i].fir)*(x-circle[i].fir)));
	}
	F(i,1,cnt) if(x>=line[i].sec.fir&&x<=line[i].sec.sec){
		ans=max(ans,line[i].fir.fir*x+line[i].fir.sec);
	}
	return ans;
}
inline double simpson(double x,double y){
	return (y-x)*(func(x)+func(y)+4*func((x+y)/2))/6;
}
inline double calc(double x,double y,double range){
	double mid=(x+y)/2;
	double rangel=simpson(x,mid),ranger=simpson(mid,y);
	double t=rangel+ranger-range;
	if(fabs(t)<=15*EPS) return rangel+ranger+t/15;
	return calc(x,mid,rangel)+calc(mid,y,ranger);
}
inline void common_tan(pair<double,double>a,pair<double,double>b){
	if(fabs(a.sec-b.sec)<=EPS){
		line[++cnt].fir=mp(0,a.sec);
		line[cnt].sec=mp(a.fir,b.fir);
		return;
	}
	if(a.sec>b.sec){
		line[++cnt].sec.fir=a.fir+a.sec*(a.sec-b.sec)/(b.fir-a.fir);
		line[cnt].sec.sec=b.fir+(line[cnt].sec.fir-a.fir)*b.sec/a.sec;
		line[cnt].fir.fir=sqrt(a.sec*a.sec-(a.fir-line[cnt].sec.fir)*(a.fir-line[cnt].sec.fir));
		line[cnt].fir.fir-=sqrt(b.sec*b.sec-(b.fir-line[cnt].sec.sec)*(b.fir-line[cnt].sec.sec));
		line[cnt].fir.fir/=line[cnt].sec.fir-line[cnt].sec.sec;
		line[cnt].fir.sec=sqrt(a.sec*a.sec-(a.fir-line[cnt].sec.fir)*(a.fir-line[cnt].sec.fir))-line[cnt].sec.fir*line[cnt].fir.fir;
	}else{
		line[++cnt].sec.sec=b.fir-b.sec*(b.sec-a.sec)/(b.fir-a.fir);
		line[cnt].sec.fir=a.fir-(b.fir-line[cnt].sec.sec)*a.sec/b.sec;
		line[cnt].fir.fir=sqrt(a.sec*a.sec-(a.fir-line[cnt].sec.fir)*(a.fir-line[cnt].sec.fir));
		line[cnt].fir.fir-=sqrt(b.sec*b.sec-(b.fir-line[cnt].sec.sec)*(b.fir-line[cnt].sec.sec));
		line[cnt].fir.fir/=line[cnt].sec.fir-line[cnt].sec.sec;
		line[cnt].fir.sec=sqrt(a.sec*a.sec-(a.fir-line[cnt].sec.fir)*(a.fir-line[cnt].sec.fir))-line[cnt].sec.fir*line[cnt].fir.fir;
	}
	return;
}
int main(){
//	freopen("lemon.in","r",stdin);
//	freopen("lemon.out","w",stdout);
	scanf("%d%lf",&n,&alpha);
	alpha=1.0/tan(alpha);
	circle[0].fir=0;
	F(i,1,n+1){
		scanf("%lf",&circle[i].fir);
		circle[i].fir=circle[i-1].fir+circle[i].fir*alpha;
	}
	F(i,1,n) scanf("%lf",&circle[i].sec);
	circle[++n].sec=0;
	double l(circle[1].fir-circle[1].sec),r(circle[n].fir);
	F(i,1,n){
		r=(r>circle[i].fir+circle[i].sec?r:circle[i].fir+circle[i].sec);
		l=(l<circle[i].fir-circle[i].sec?l:circle[i].fir-circle[i].sec);
	}
	F(i,1,n-1) common_tan(circle[i],circle[i+1]);
	printf("%.2lf",2*calc(l,r,simpson(l,r)));
	return ~~(0^_^0);//卖个萌OwO
}
```
第一次交题解，不喜勿喷awa~

---

## 作者：iuyi (赞：15)

我来发一篇不用辛普森的题解。

首先用三角函数计算树上的圆在地上投影的位置。

相邻的圆的之间部分可以看成将一个圆一边等比缩放一边平移到另一个圆的位置所形成的路径。

等价于两个圆的外公切线中间的部分。

由于投影一定是对称的，所以我们只算一半。

需要算的是一些半圆和一些线段向x轴围成的面积的并。

（我就不放图了，其他题解里有）

对于单个半圆或线段，计算面积是很容易的。

所以考虑对整个阴影部分进行分割。

对于某个x，如果有两条半圆或线段在这里有交点，就把区间从这里分开。

对于一个最终区间的答案，只需要计算所有半圆和线段在这段区间的面积然后取最大值就可以了。

思路很简单，~~但是我调了很久。~~

复杂度$O(n*m*k)$其中n是圆的个数，m是分割点的个数（期望$O(n)$最坏$O(n^2)$），k是计算反三角函数的复杂度。

相比辛普森的优点：精度更高，不依赖h和r的范围。

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef complex<double> cp;
const double eps = 1e-6;
// sup 表示非法值 
const double sup = -2333;

int n;
double apa;
// h 表示圆心坐标
double h[505];
// r 表示线段
double r[505];
// q[i] 表示第 i 个圆和第 i+1 个圆的切线的两点式 
pair<cp,cp> q[505];

// 点积 
double dj(cp x, cp y)
{
	return x.real()*y.real()+x.imag()*y.imag();
}
// 叉积 
double cj(cp x, cp y)
{
	return x.real()*y.imag()-x.imag()*y.real();
}
// 计算两向量夹角正弦 
double sin(cp x, cp y)
{
	return cj(x,y) / abs(x) / abs(y);
}

// 计算两圆交点 
double j1(int i, int j)
{
	if(h[i]-r[i] < h[j]-r[j] && h[j]-r[j] < h[i]+r[i] && h[i]+r[i] < h[j]+r[j])
	{
		return h[i] - ((r[j]*r[j]-r[i]*r[i])/(h[j]-h[i])-(h[j]-h[i]))/2;
	}
	return sup;
}
// 计算两线段交点 
double j2(int i, int j)
{
	if(fabs((q[i].second.imag()-q[i].first.imag())*(q[j].second.real()-q[j].first.real())
		  - (q[j].second.imag()-q[j].first.imag())*(q[i].second.real()-q[i].first.real())) < eps)
	{
		return sup;
	}
	double x = abs(q[i].first-q[j].first) / sin(q[j].second-q[j].first,q[i].second-q[i].first)
		* sin(q[i].first-q[j].first,q[j].second-q[j].first);
	x = q[i].first.real() + (q[i].second.real()-q[i].first.real()) * x / abs(q[i].second-q[i].first);
	if(max(q[i].first.real(),q[j].first.real()) <= x && x <= min(q[i].second.real(),q[j].second.real()))
	{
		return x;
	}
	return sup;
}
// 计算第 i 个圆和第 j 条线段的交点，可以证明交点只有一个 
double j3(int i, int j)
{
	double l = abs(cp(h[i],0)-q[j].first)*sin(cp(h[i],0)-q[j].first,q[j].second-q[j].first);
	if(l >= r[i])
	{
		return sup;
	}
	double md = q[j].first.real() + (q[j].second.real()-q[j].first.real()) * sqrt(norm(cp(h[i],0)-q[j].first)-l*l)
//	这个地方一定要判夹角是否大于90度 
	 / abs(q[j].second-q[j].first) * (dj(cp(h[i],0)-q[j].first,q[j].second-q[j].first)>0 ? 1:-1);
	double xn = (q[j].second.real()-q[j].first.real()) * sqrt(r[i]*r[i]-l*l) / abs(q[j].second-q[j].first);
	if(q[j].first.real() < md-xn && md-xn < q[j].second.real())
	{
		return md - xn;
	}
	if(q[j].first.real() < md+xn && md+xn < q[j].second.real())
	{
		return md + xn;
	}
	return sup;
}

// 计算第 i 个圆在 x1 x2 区间的面积 
double f1(int i, double x1, double x2)
{
	x1 = max(x1,h[i]-r[i]);
	x2 = min(x2,h[i]+r[i]);
	if(x1 >= x2)
	{
		return 0;
	}
//	下面的限制范围很重要，不然会由浮点数误差产生 acos(1.000001) 的情况 
	double t1 = acos(max((double)-1,min((double)1,(x1-h[i])/r[i])));
	double t2 = acos(max((double)-1,min((double)1,(x2-h[i])/r[i])));
	double ret = r[i] * r[i] * (t1-t2) / 2;
	ret += (x2-h[i]) * sqrt(max((double)0,r[i]*r[i]-(x2-h[i])*(x2-h[i]))) / 2;
	ret -= (x1-h[i]) * sqrt(max((double)0,r[i]*r[i]-(x1-h[i])*(x1-h[i]))) / 2;
	return ret;
}
// 计算第 i 条线段在 x1 x2 区间的面积 
double f2(int i, double x1, double x2)
{
	x1 = max(x1,q[i].first.real());
	x2 = min(x2,q[i].second.real());
	if(x1 >= x2)
	{
		return 0;
	}
	double md = (x1+x2) / 2;
	md = q[i].first.imag() + (q[i].second.imag()-q[i].first.imag())
	 * (md-q[i].first.real()) / (q[i].second.real()-q[i].first.real());
	return md*(x2-x1);
}

// x 表示分割点 
double x[505*505*3];
int tp = 0;
double ans;

signed main()
{
	cin >> n >> apa;
	apa = 1 / tan(apa);
	for(int i = 0; i <= n; i++)
	{
		cin >> h[i+1];
		h[i+1] = h[i] + h[i+1]*apa;
	}
	x[0] = -sup;
	x[1] = sup;
	for(int i = 1; i <= n; i++)
	{
		cin >> r[i];
//		下面两行是为了确定整个区间的最左端和最右端 
		x[0] = min(x[0],h[i]-r[i]);
		x[1] = max(x[1],h[i]+r[i]);
	}
	x[1] = max(x[1],h[n+1]);
	tp = 2;
	for(int i = 1; i <= n; i++)
	{
		if(h[i]+r[i] >= h[i+1]+r[i+1] || h[i]-r[i] >= h[i+1]-r[i+1])
		{
			continue;
		}
//		计算第 i 个圆与第 i+1 个圆的公切线 
		if(r[i] == r[i+1])
		{
			q[i].first.real(h[i]);
			q[i].first.imag(r[i]);
			q[i].second.real(h[i+1]);
			q[i].second.imag(r[i+1]);
		}
		else if(r[i+1] == 0)
		{
			q[i].first.real(h[i]+r[i]*r[i]/(h[i+1]-h[i]));
			q[i].first.imag(sqrt(r[i]*r[i]-(r[i]*r[i]/(h[i+1]-h[i]))*(r[i]*r[i]/(h[i+1]-h[i]))));
			q[i].second.real(h[i+1]);
			q[i].second.imag(0);
		}
		else 
		{
			double l2 = r[i+1] * (h[i+1]-h[i]) / (r[i]-r[i+1]);
			q[i].first.real(h[i]+r[i]*r[i+1]/l2);
			q[i].first.imag(sqrt(r[i]*r[i]-(r[i]*r[i+1]/l2)*(r[i]*r[i+1]/l2)));
			q[i].second.real(h[i+1]+r[i+1]*r[i+1]/l2);
			q[i].second.imag(sqrt(r[i+1]*r[i+1]-(r[i+1]*r[i+1]/l2)*(r[i+1]*r[i+1]/l2)));
		}
		x[tp] = q[i].first.real();
		tp++;
		x[tp] = q[i].second.real();
		tp++;
	}
//	计算圆与圆，线段与线段的交点 
	for(int i = 1; i <= n; i++)
	{
		for(int j = i+1; j <= n; j++)
		{
			double t = j1(i,j);
			if(t != sup)
			{
				x[tp] = t;
				tp++;
			}
			t = j2(i,j);
			if(t != sup)
			{
				x[tp] = t;
				tp++;
			}
		}
	}
//	计算圆与线段的交点 
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			if(i != j+1 && i != j)
			{
				double t = j3(i,j);
				if(t != sup)
				{
					x[tp] = t;
					tp++;
				}
			}
		}
	}
	sort(x,x+tp);
	ans = 0;
	for(int i = 1; i < tp; i++)
	{
		double mx = 0;
//		计算区间的面积 
		for(int j = 1; j <= n; j++)
		{
			mx = max(mx,f1(j,x[i-1],x[i]));
			mx = max(mx,f2(j,x[i-1],x[i]));
		}
		ans += mx;
	}
//	最终答案要 *2 
	printf("%.2lf\n",ans*2);
	return 0;
}
```


---

## 作者：CmsMartin (赞：8)

阅读本题解前，您需要掌握三角函数的有关知识

~~本文中有大篇幅的数学公式，如有头晕，目眩，癫痫等不适症状，请立即停止阅读本文并及时就医~~

## 前置前置芝士 微积分

微积分的基本定理：

假设 $F'(x) = f(x)$ ,那么有：

$$\int_a^b f(x) dx = F(b)- F(a)$$

(假设 $a < b$)

因为指数函数的微分公式  $f(x) = x ^ n \Rightarrow f'(x) = nx^{n-1}$

所以，显然 

$$\int_a^b (Ax^2+Bx+C)dx$$
$$ = \int_a^b (\frac{Ax^3}{3} + \frac{Bx^2}{2} + \frac{Cx}{1})$$
$$= \frac{Ab^3}{3} - \frac{Aa^3}{3} + \frac{Bb ^2}{2} - \frac{Ba ^ 2}{2} + Cb - Ca$$

## 前置芝士 Simpson 公式

我看到题解中没有一篇认真讲过辛普森公式，于是就来水一篇题解。

### 基本思想

**将函数近似看做二次函数**

~~由于这个原因，这个公式及其的简单且不精确。~~

### 公式推导

$$\int_a^b f(x) dx$$

上方是最最基础的微积分求面积的公式；

刚刚的思想中讲到了思路是将 $f(x)$ 看做 $ax^2 + bx + c$ ,于是有:

$$= \int_a^b (Ax^2+Bx+C)dx$$
$$ \approx \int_a^b (\frac{Ax^2}{3} + \frac{Bx}{2} + \frac{C}{1})$$
$$= \frac{Ab^3}{3} - \frac{Aa^3}{3} + \frac{Bb ^2}{2} - \frac{Ba ^ 2}{2} + Cb - Ca$$
$$= \frac{2Ab^3 - 2Aa^3 + 3Bb^2 - 3Ba^2 + 6b - 6CaC}{6}$$
$$= \frac{2A(a^3 - b^3) +3B(b^2 - a^2) + 6C(b-a)}{6}$$
$$= \frac{2A(b-a)(a^2 + b^2 + ab) + 3B(a + b)(b-a) + 6C(b-a)}{6}$$
$$= \frac{(b-a)(2Aa^2 + 2Ab^2 + 2Aab + 3Ba + 3Bb + 6C)}{6}$$
$$= (b-a)\frac{(Aa^2 + Ba + C) + (Ab^2 + Bb + C) + (Aa^2 + Ab^2 + 2Ba + 2Bb + 2Aab + 4C)}{6}$$
$$= (b-a)\frac{f(a) + f(b) + 4(\frac{Aa^2}{4} + \frac{Ab^2}{4} + \frac{Ba}{2} + \frac{Bb}{2} + \frac{2Aab}{4} + C)}{6}$$
$$= (b-a)\frac{f(a) + f(b) + 4(\frac{Aa^2 + Aab}{4} + \frac{Ab^2 + Aab}{4} + \frac{Ba + Bb}{2} + C)}{6}$$
$$= (b-a)\frac{f(a) + f(b) + 4(A\frac{a(a + b)}{4} + A\frac{b(a + b)}{4} + B\frac{a +b}{2} + C)}{6}$$
$$= (b-a)\frac{f(a) + f(b) + 4(A\frac{(a + b) ^ 2}{4} + B\frac{a +b}{2} + C)}{6}$$
$$= (b-a)\frac{f(a) + f(b) + 4f(\frac{a + b}{2})}{6}$$
所以，我们得到：
$$\int_a^b f(x) dx \approx (b-a)\frac{f(a) + f(b) + 4f(\frac{a + b}{2})}{6}$$

### 处理精度问题

**为了控制精度，以及不必要的问题，保留两位小数时 eps 一般取 $10^{-6} \sim 10^{-8}$。**

有了 Simpson 公式，一个自然的想法是把积分区间拆成多个小区间后求和。

但是分成区间的个数和长度因积分区间和精度要求甚至被积函数而异。

换句话说，分的区间数太少不满足精度要求，太多了会 TLE 。

「自适应」就是求积分时能够自动控制切割的区间大小和长度，使精度能满足要求。

具体地： `solve(l , r)` 表示求 $\int_r^l f(x)dx$
1. 取 `mid = l+r >> 1`;
2. 用 Simpson 公式近似计算 $f(x)$ 在区间 $[l,mid]$ 和区间 $[mid,r]$ 内的积分，分别为 $l_s$ 和 $r_s$ ，及 $[l,r]$ 的近似积分 $sum$ ;
3. 如果 $l_s + r_s$ 与 $sum$ 的误差允许(即在 eps 之内)，则返回 $sum$ ;
4. 否则递归 `solve(l , mid)` 和 `solve(mid , r)` ，返回这两个递归计算结果的和;

摘自 [这篇博文](https://blog.csdn.net/xyz32768/article/details/81392369)。

### 代码

```cpp
double Function (double x) {
	//Your Function!
}

double Solve (double l , double r) {
	double mid = (l + r) / 2;
	return (Function(l) + Function(r) + Function(mid) * 4) * (r - l) / 6;
}

double Simpson (double l , double r , double eps , double res) {
        double mid = (l + r) / 2;
        double x1 = Solve(l , mid) , x2 = Solve(mid , r);
        if(abs(x1 + x2 - res) <= 15 * eps) return x1 + x2 + (x1 + x2 - res) / 15;
        else return Simpson(l , mid , eps / 2 , x1) + Simpson(mid , r , eps / 2 , x2);
}
```

## 思路

对于一个圆，投影下去还是一个圆；

定义树的轴在投影平面上经过的点为原点，定一个正方向，建立平面直角坐标系，
能发现，对于一个半径为 $r$，高度为 $h$ 的圆，投影到平面上是圆心坐标为 $(\cot(α)h,0)$，半径为 $r$ 的圆；

想象有一个水平的平面，竖直向上移，可以把树切出一堆圆，对于这些圆，把它们投影求个并就是答案；

对于每个圆台，它一堆圆的并就是先求上下两个面的圆的投影，再对投影求外公切线，围成的图形；

这个图形挺特殊，所以可以对不规则的函数下方面积考虑使用自适应 Simpson；

然后，这道题目就做完了。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-6;

const int N = 510;

struct Point {
	double x , y;
}S[N] , E[N] , A[N] , B[N];

double Alpha;
int n;
double h;

double sqr (double x) {
	return x * x;
}

void Cal (Point &s , Point &e , Point a , Point b) {
	if(abs(a.y - b.y) < eps) return s = a , e = b , void();
	double k = (b.y - a.y) / (b.x - a.x);
	s.x = a.x - k * a.y;
	s.y = sqrt(sqr(a.y) - sqr(a.x - s.x));
	e.x = b.x - k * b.y;
	e.y = sqrt(sqr(b.y) - sqr(b.x - e.x));
}

double Function (double x) {
	double y = 0;
	for (int i = 1; i <= n + 1; i++) {
		if(abs(x - A[i].x) <= A[i].y) {
			y = max(y , sqrt(sqr(A[i].y) - sqr(x - A[i].x)));
		}
	}
	for (int i = 1; i <= n; i++) {
		if(A[i + 1].x - A[i].x - abs(A[i].y - A[i + 1].y) > eps && S[i].x <= x && x <= E[i].x) {
			y = max(y , S[i].y + (x - S[i].x) * (E[i].y - S[i].y) / (E[i].x - S[i].x));
		}
	}
	return y;
}

double Solve (double l , double r) {
	double mid = (l + r) / 2;
	return (Function(l) + Function(r) + Function(mid) * 4) * (r - l) / 6;
}

double Simpson (double l , double r) {
	double mid = (l + r) / 2;
	double x1 = Solve(l , mid) , x2 = Solve(mid , r) , x3 = Solve(l , r);
	if(abs(x1 + x2 - x3) < eps) return x1 + x2;
	else return Simpson(l , mid) + Simpson(mid , r);
}

int main() {
	cin >> n >> Alpha;
	Alpha = 1 / tan(Alpha);
	
	for (int i = 1; i <= n + 1; i++) {
		cin >> A[i].x;
		h += A[i].x;
		A[i].x = h * Alpha;
	}
	
	for (int i = 1; i <= n; i++) {
		cin >> A[i].y;
	}
	
	A[n + 1].y = A[n + 2].y = 0;
	
	double l , r;
	
	l = A[1].x;
	r = A[n + 1].x;
	
	for (int i = 1; i <= n; i++) {
		l = min(l , A[i].x - A[i].y);
		r = max(r , A[i].x + A[i].y);
		if (A[i + 1].x - A[i].x - abs(A[i + 1].y - A[i].y) > eps) {
			Cal(S[i] , E[i] , A[i] , A[i + 1]);
		}
	}
	
	printf("%.2lf\n" ,2 * Simpson(l , r));
	
	return 0;
}
```

然后，你就会发现一件很有趣的事情：

![](https://cdn.luogu.com.cn/upload/image_hosting/jqt7q8na.png)












---

## 作者：Karnage (赞：6)

[我的博客](https://zhxry.github.io/2019/10/10/NOI2005-%E6%9C%88%E4%B8%8B%E6%9F%A0%E6%AA%AC%E6%A0%91/)

## Description

李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。


李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的 影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？

李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠 檬树的形状了解得非常清楚，而且想好了简化的方法。

李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,…,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面 重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,…,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,…,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $alpha$。

![uInxQf.png](https://s2.ax1x.com/2019/10/09/uInxQf.png)

为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。

## Solution

自适应辛普森

乍一看十分麻烦。。。

由于是平行光，投影一下就变成了下图。

首先，第一个 $h_0$ 可以直接忽略（题目说了忽略树干影子）。其次，圆的半径不会改变，只有高度与圆台投影形成的梯形尺寸需要注意（最后一个圆锥也可看成圆台，三角形看成梯形）。

只要我们得出了各个圆以及梯形的坐标与大小，不必考虑重合与否，直接套上辛普森，问题便迎刃而解。

![](https://s2.ax1x.com/2019/10/09/uIlzVO.png)

我们发现，高度为 $H$ 的物体的长度会变为$H \cdot \displaystyle \frac 1 {tan \ \alpha}$，这可以帮助我们确定横坐标。

比较麻烦的是梯形。我们需要知道它的左右端点以及上下底长。它的腰是由相邻两圆的公切线构成的（知道即可，我们并不需要储存这两条线），两底则可以由左右端点距圆心距离和半径通过勾股定理得出。因此我们先要得出左右端点的位置。

观察下图，发现这两个端点离圆心很近，我们将 $AE,CH$ 分别相连，分别过$E,H$ 向 $x$ 轴作垂线，过$A$ 点向$CH$ 作垂线，应用简单的相似三角形知识即可求出左右端点的坐标。这里图就不给出了。

![a](https://s2.ax1x.com/2019/10/13/uvV8mR.png)

至此，我们已经得出了所有圆和梯形的位置与大小。套上辛普森板子即可。

还有，在计算 $F$ 值时梯形可能会麻烦些，但是这只是初中几何题，这里不再赘述。

## Code

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
#define LL long long
#define sqr(x) ((x) * (x))

const double eps = 1e-8, pi = acos(-1);

inline int Sgn(double x) {
	return x < -eps ? -1 : x > eps;
}

struct Circle {
	double x, y, r;
	Circle() {}
	Circle(double _x, double _y, double _r) : x(_x), y(_y), r(_r) {}
};

struct Trape {
	double l, r, al, ar;
	Trape() {}
	Trape(double _l, double _r, double _al, double _ar) : l(_l), r(_r), al(_al), ar(_ar) {}
};

const int N = 1e3;
int n;
double Alpha, L, R, h[N + 5], r[N + 5];
Circle a[N + 5];
Trape t[N + 5];

inline double F(double pos) {
	double res = 0;
	for (int i = 1; i <= n; ++i)
		if (Sgn(a[i].r - fabs(pos - a[i].x)) > 0) {
			double tmp = sqrt(sqr(a[i].r) - sqr(fabs(pos - a[i].x)));
			res = std::max(res, tmp * 2);
		}
	for (int i = 1; i <= n; ++i) {
		if (Sgn(pos - t[i].l) > 0 && Sgn(t[i].r - pos) > 0) {
			double d = pos - t[i].l, len = t[i].r - t[i].l;
			double Len = len * t[i].al / (t[i].al - t[i].ar);
			double tmp = (Len - d) / Len * t[i].al;
			res = std::max(res, tmp * 2);
		}
	}
	return res;
}

inline double calc(double l, double r) {
	return (r - l) * (F(l) + F(r) + 4 * F((l + r) / 2)) / 6;
}

double Simpson(double l, double r, double Eps, double ans) {
	double Mid = (l + r) / 2, SL = calc(l, Mid), SR = calc(Mid, r);
	if (fabs(SL + SR - ans) <= Eps * 15) return SL + SR + (SL + SR - ans) / 15;
	return Simpson(l, Mid, Eps / 2, SL) + Simpson(Mid, r, Eps / 2, SR);
}

int main() {
	scanf("%d%lf", &n, &Alpha);
	for (int i = 0; i <= n; ++i) scanf("%lf", &h[i]);
	for (int i = 1; i <= n; ++i) scanf("%lf", &r[i]);
	double H = 0, Tan = 1.0 / tan(Alpha), L = 0, R = 0;
	for (int i = 1; i <= n; ++i) {
		a[i] = Circle(Tan * H, 0, r[i]);
		double len = Tan * h[i], ll = (r[i + 1] - r[i]) * r[i] / len, rr = (r[i + 1] - r[i]) * r[i + 1] / len;
		t[i] = Trape(Tan * H - ll, Tan * (H + h[i]) - rr, sqrt(sqr(r[i]) - sqr(ll)), sqrt(sqr(r[i + 1]) - sqr(rr)));
		H += h[i];
		L = std::min(L, a[i].x - a[i].r);
		R = std::max(R, a[i].x + a[i].r);
	}
	R = std::max(R, Tan * H);
	printf("%.2lf\n", Simpson(L, R, 5e-4, calc(L, R)));
	return 0;
}
```



---

## 作者：_Arahc_ (赞：3)


阴间计算几何题。

## 题意

>  一棵合法的柠檬树如图，其中除最顶层外，每一层都是一个圆台，最顶层是一个圆锥：
>
> ![柠檬树](https://s2.ax1x.com/2019/10/09/uInxQf.png)
>
> 给定 $h_i,r_i,\alpha$，求其在月光下投影的面积，保留两位小数。
>
> $n\leqslant 500,0.3<\alpha<\frac{2}{\pi}$。


## 题解

### 单独的圆锥

这同时也是 subtask1 这个部分分的条件。考虑一个圆锥的投影：

![EZ](https://pic.imgdb.cn/item/62025ae42ab3f51d9129539c.png)

根据投影知识，不难得到，$AJ=\frac{AD}{\tan\alpha}$。

我们可以直接得到 $J$ 的坐标，投影的面积可以用 $\triangle JKM$ 的面积和扇形 $KCG$ 的面积的和的两倍表示。所以唯一的问题就是：已知 $J,C$ 坐标，$\odot C$ 的半径，求 $S_{\triangle JKC},\angle KCG$。因为 $JC,r$ 已知，不难得到 $\angle KCJ$ 和它的三角函数，进而解决问题，不多赘述。

### 单独的圆台

考虑单独的一个圆台怎么做（geogebra 画不出圆台，只能用两个圆简陋表示一下）：

![HD](https://pic.imgdb.cn/item/62025ae72ab3f51d91295707.png)

显然，$E,F$ 坐标都能求出来，且 $\odot E$ 的半径 $r_1$，$\odot F$ 的半径 $r_2$ 都知道。为了方便，画出俯视图：

![HD-sol](https://pic.imgdb.cn/item/62025aea2ab3f51d91295a07.png)

设两条外公切线交于点 $A$。有：
$$
\sin\angle EAK=\frac{FG}{AF}=\frac{EK}{AF+EF}
$$
$FG,EK,EF$ 为已知，可以解出 $AF$ 的值，然后 $A$ 的坐标和 $\angle EAK$ 的三角函数就出来了，于是能求出公切线的解析式，于是 $G,K$ 坐标都可以求出来了。

还是只考虑它的一半，不难发现就是直角梯形 $GKEF$ 的面积加上两个扇形。都可以由已知量简单推导得到。

### 我们联合！

考虑这两个东西加在一起会产生什么效应：

![IN](https://pic.imgdb.cn/item/62025aed2ab3f51d91295d85.png)

题目瞬间感觉毒瘤了不少。我们还是只考虑一半的情况，发现这个东西是可以分割的，于是作这些切点关于 $y$ 轴的垂线：

![IN-sol](https://pic.imgdb.cn/item/62025b0b2ab3f51d91297932.png)

至于梯形部分，和上面圆台的解决方法是一样的。唯一的三角形和圆锥的解决方法类似。因此重点考虑“斜边”是一段弧的东西。即图中类似于封闭图形 $DHUN$ 的部分。

#### 法一

![IN-sol-way1](https://pic.imgdb.cn/item/620262d22ab3f51d91312c8a.png)

所求面积为：
$$
S_{\text{扇形} FAC}-S_{\triangle AEC}-S_{\text{扇形} FAB}+S_{\triangle ADB}
$$
$C$ 在 $A$ 下方时同理。

#### 法二

这才是我真正想写的做法。

因为圆一定在 $y$ 轴上，所以圆的解析式为 $r^2=x^2+(y-a)^2$。

为了方便我们把 $x,y$ 反过来，让它落在 $x$ 轴上，解析式变为 $r^2=(x-a)^2+y^2$。先考虑 $a=0$ 的情况，后续再把 $x$ 用 $x-a$ 代进去。
$$
y=\sqrt{r^2-x^2}
$$
求它的一个不定积分：
$$
\int \sqrt{r^2-x^2}\, {\rm d}x
$$
我们知道 $-r\leqslant x\leqslant r$，所以 $x$ 可以表示为 $r\sin\varphi$ 的形式：
$$
\int \sqrt{r^2-r^2\sin^2\varphi} \, {\rm d}r\sin\varphi
$$
然后我们发现根号里面的东西就是 $r^2\cos^2\varphi$：
$$
\int r\cos\varphi \, {\rm d}r\sin\varphi = \int r^2\cos\varphi(\sin\varphi)'\, {\rm d}\varphi
$$
$(\sin x)'=\cos x$，$r$ 为常数，可以提出来
$$
r^2\int \cos^2 \varphi \, {\rm d}\varphi
$$
诱导公式变一下，再提一波常数：
$$
\frac{r^2}{2}\int 1+\cos 2\varphi \, {\rm d}\varphi
$$
和的积分等于积分的和，考虑第二项怎么积分，看成 $f(x)=\cos x,g(x)=2x$ 的复合函数即可：
$$
\frac{r^2}{2}(\varphi+\frac{\sin 2\varphi}{2})
$$
然后把 $x$ 代回去，二倍角公式展开三角函数，$\varphi=\arcsin \frac{x}{r}$：
$$
\frac{r^2}{2}\left(\arcsin \frac{x}{r}+\frac{x}{r}\times\sqrt{1-\frac{x^2}{r^2}}\right)
$$
然后化简一下就可以了：
$$
\frac{r^2}{2}\arcsin \frac{x}{r} + \frac{x\sqrt{r^2-x^2}}{2}
$$
记得把 $x-a$（$a$ 为圆心横坐标）代到 $x$ 中而不是直接用 $x$：
$$
\frac{r^2}{2}\arcsin\frac{x-a}{r}+\frac{(x-a)\sqrt{r^2-(x-a)^2}}{2}
$$
于是求那个东西的面积的时候，假设弧的端点横坐标分别为 $x_1,x_2$，将其分别代入然后减一下即可。

#### 细节

这一段我一直没有讨论全，看了 [iuyi](https://www.luogu.com.cn/user/120033) 大佬的题解后豁然开朗%%%。

一些细节问题不拿出来单独讨论会直接出错，例如两个圆之间没有公切线（包含关系）的情况：

![AT](https://pic.imgdb.cn/item/62026b7c2ab3f51d9139d4c0.png)

针对这个图，我们添加一个判断：

1. 把最上面和最下面的点也视为分段点。
2. 如果一个段内同时有多个圆弧或线段，取它们面积的最大值为这一段的面积。

但是我们又发现上面的图有些极端，不一定存在一个大圆包含了所有其它的圆，也不一定是圆心坐标大的点包含圆心坐标小的点。最为保险的还是添加两条：

3. 圆和圆、线段之间的交点、线段和线段的交点，也记作分段的点。

4. 如果一个圆包含下一个圆（按圆心坐标大小枚举时），不要计算公切线。

圆和圆的交点、线段和线段的交点比较简单，圆和线段的交点直接联立解析式都能做。

还有就是注意精度误差产生的问题，有些地方不加限制条件会爆 WA（特别是代码中用注释提到的那一段）。

于是这个题就做出来了，剩下的都交给代码实现了 qwq。

## 代码

有借鉴于 @[iuyi](https://www.luogu.com.cn/user/120033) 的题解代码，仅供参考。

```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
const int max_n=502;
const double inf=1000000000.0;

inline double Rt(double a,double b,double c){
    if(b==inf) swap(a,b);
    if(c==inf)
        return sqrt(a*a+b*b);
    return sqrt(c*c-b*b);
}

int n,cnt;
double alpha,h[max_n],r[max_n];
double dn[max_n],up[max_n];

struct dot{
    double x,y;
}p[max_n*max_n*10];

inline dot maked(double a,double b){
    dot res;
    res.x=a,res.y=b;
    return res;
}

double sep[max_n*max_n];

inline void Circ_Circ(){ // 圆和圆的交点
    for(register int i=1;i<=n;++i)
        for(register int j=i+1;j<=n;++j)
            if(dn[i]<dn[j] && up[i]>dn[j] && up[i]<up[j])
                sep[++cnt]=h[i]-((r[j]*r[j]-r[i]*r[i])/(h[j]-h[i])-h[j]+h[i])/2;
}

struct line{
    dot a,b;
    inline bool valid(){
        if(a.x==inf || a.y==inf) return 0;
        if(b.x==inf || b.y==inf) return 0;
        return 1;
    }
    inline double slope(){
        if(a.x==b.x) return inf;
        return (a.y-b.y)/(a.x-b.x);
    }
}l[max_n];

inline line makel(dot a,dot b){
    line res;
    res.a=a,res.b=b;
    return res;
}

inline void Line_Line(){ // 线段和线段的交点，联立解析式
    for(register int i=1;i<=n;++i)
        for(register int j=i+1;j<=n;++j)
            if(l[i].valid() && l[j].valid()){
                double k1=l[i].slope(),k2=l[j].slope();
                if(k1==inf || k2==inf || k1==k2)
                    continue;
                double b1=l[i].a.y-k1*l[i].a.x,b2=l[j].a.y-k2*l[j].a.x;
                double X=(b2-b1)/(k1-k2);
                if(X>=l[i].a.x && X<=l[i].b.x && X>=l[j].a.x && X<=l[j].b.x)
                    sep[++cnt]=X;
            }
}

inline void Circ_Line(){ // 圆和线段的交点，联立解析式
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=n;++j)
            if(j!=i && j!=i-1 && l[j].valid()){
                double k=l[j].slope(),b=l[j].a.y-k*l[j].a.x;
                double A=k*k+1,B=2*k*b-2*h[i],C=b*b+h[i]*h[i]-r[i]*r[i],delta=B*B-4*A*C;
                if(delta<0)
                    continue;
                double x1=(-B+sqrt(delta))/(A*2),x2=(-B-sqrt(delta))/(A*2);
                if(x1>=l[j].a.x && x1<=l[j].b.x)
                    sep[++cnt]=x1;
                if(x2>=l[j].a.x && x2<=l[j].b.x)
                    sep[++cnt]=x2;
            }
}

double ans=0;

inline double S_Line(double x1,double x2,int i){ // 线段在区间内的面积
    x1=max(x1,l[i].a.x),
    x2=min(x2,l[i].b.x);
    if(x1>=x2)
        return 0;
    double k=l[i].slope(),b=l[i].a.y-k*l[i].a.x;
    if(k==inf)
        return 0;
    return (k*x1+b+k*x2+b)*(x2-x1)/2;
}

inline double Calc(double x,double a,double r){ // 积分
    x-=a;
    return r*r/2*asin(max((double)-1,min((double)1,x/r)))+x*sqrt(max((double)0,r*r-x*x))/2;
    // 如果没有限制条件会因为精度误差 WA
}

inline double S_Circ(double x1,double x2,int i){ // 圆在区间内的面积
    x1=max(x1,dn[i]),
    x2=min(x2,up[i]);
    if(x1>=x2)
        return 0;
    return Calc(x2,h[i],r[i])-Calc(x1,h[i],r[i]);
}

signed main(){
//  freopen(".in","r",stdin),
//  freopen(".out","w",stdout);
    scanf("%d%Lf",&n,&alpha);
    alpha=1.0/tan(alpha);
    for(register int i=1;i<=n+1;++i){
        scanf("%Lf",&h[i]);
        h[i]=h[i]*alpha+h[i-1];
    }
    sep[++cnt]=inf,
    sep[++cnt]=-inf;
    for(register int i=1;i<=n+1;++i){
        if(i<=n)
            scanf("%Lf",&r[i]);
        dn[i]=h[i]-r[i],
        up[i]=h[i]+r[i];
        sep[1]=min(sep[1],dn[i]),
        sep[2]=max(sep[2],up[i]);
    }
    Circ_Circ();
    for(register int i=1;i<=n;++i){ // 求出所有公切线
        if(up[i]>=up[i+1] || dn[i]>=dn[i+1]){
            l[i]=makel(maked(inf,inf),maked(inf,inf));
            continue;
        }
        if(r[i]==r[i+1]){
            sep[++cnt]=h[i],
            sep[++cnt]=h[i+1];
            l[i]=makel(maked(h[i],r[i]),maked(h[i+1],r[i+1]));
        }
        else if(r[i+1]==0){
            double delta=r[i]*r[i]/(h[i+1]-h[i]);
            sep[++cnt]=h[i]+delta,
            sep[++cnt]=h[i+1];
            l[i]=makel(maked(h[i]+delta,Rt(delta,inf,r[i])),maked(h[i+1],0));
        }
        else{
            double AF=r[i+1]*(h[i+1]-h[i])/(r[i]-r[i+1]);
            double Gx=h[i+1]+r[i+1]*r[i+1]/AF,Kx=h[i]+r[i]*r[i+1]/AF;
            sep[++cnt]=Kx,
            sep[++cnt]=Gx;
            l[i]=makel(maked(Kx,Rt(r[i]*r[i+1]/AF,inf,r[i])),maked(Gx,Rt(r[i+1]*r[i+1]/AF,inf,r[i+1])));
        }
    }
    Line_Line(),
    Circ_Line();
    sort(sep+1,sep+1+cnt),
    cnt=unique(sep+1,sep+1+cnt)-sep-1;
    for(register int i=1;i<cnt;++i) if(sep[i]!=sep[i+1]){
        double mx=0;
        for(register int j=1;j<=n;++j){
            mx=max(mx,S_Line(sep[i],sep[i+1],j)),
            mx=max(mx,S_Circ(sep[i],sep[i+1],j));
        }
        ans+=mx;
    }
    printf("%.2Lf",ans*2);
    return 0;
}
```



---

## 作者：Others (赞：2)

蒟蒻硬肝了两天才肝懂这道题，我太难了~~~
# 题目大意
求几个在竖直方向连续的圆台和圆锥在仰角为 $\alpha$ 光线照射下，水平地面上的影子的面积。
# 分析
**1.**

由于这个影子可能很奇怪(复杂)，所以考虑积分，即 $Simpson$ 积分法，这里就不展开了。

---
**2.**

首先求出投影下来要变化的量，思考一下，可以发现只有 $h$ 的值投影下来发生了变化，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/9e83nm5z.png)

导一下角，用三角函数即可求出投影下来的长度。

---
**3.**

考虑一下圆台的阴影怎么求。因为圆台的两个圆与地面平行(都为水平)，所以它们会在地上投影出两个一模一样的圆，圆心的间距 $l=$ 圆台的高度 $*\cot\alpha$ ，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/8q5jz1sr.png)

因为我们要求积分，所以得先求解析式，才能套板板，于是得用初中知识--相似

![](https://cdn.luogu.com.cn/upload/image_hosting/zx02p69a.png)

核心推导都在图里，其它的边可以用比例和勾股定理求出，求得 $C$ , $D$ 点坐标，最后求出解析式，保存一下。

---
**4.**

若两个大圆中间夹着一个小圆，它们的公切线就会相交，需要在求积分的时候注意一下，取最大值。

若两个小圆中间夹着一个大圆，它们的公切线中间就会出现一段圆弧，需要在求积分的时候用勾股定理计算。

若一个大圆包着一个小圆，也是求最大值。

注意最顶上的圆锥可以视为一个圆面的半径为 $0$ 的圆台。

# Code
```cpp
#include <bits/stdc++.h>
#define jd 1e-7
#define D double
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define fr(x,y,p) for(int x=y;p;++x)
#define rf(x,y,p) for(int x=y;p;--x)
#define abs(x)(x>0?x:-(x))//这里的-(x)要打括号！！！
using namespace std;
struct cir{
	D x,r;
}a[505];
struct cut_line{//cir[i]->cir[i+1]切线 
	D k,b,l,r;
}p[505];
int n;
D alpha;
void calc_cut_line(int x,int y){
	if(abs(a[x].r-a[y].r)<=jd){
		p[x].k=0,p[x].b=a[x].r,p[x].l=a[y].x,p[x].r=a[y].x;
		return;
	}
	if(a[x].r>a[y].r){
		D ac=a[y].x-a[x].x,aj=a[x].r-a[y].r,S_ckh=aj/ac,ch=a[x].r*S_ckh,ag=a[y].r*S_ckh,kh=sqrt(a[x].r*a[x].r-ch*ch),lg=sqrt(a[y].r*a[y].r-ag*ag);//推导过程 
		p[x].k=(lg-kh)/(ac-ch+ag),p[x].b=lg-(a[y].x+ag)*p[x].k,p[x].l=a[x].x+ch,p[x].r=a[y].x+ag;
	}else{
		D ac=a[y].x-a[x].x,aj=a[y].r-a[x].r,S_ckh=aj/ac,ch=a[y].r*S_ckh,ag=a[x].r*S_ckh,kh=sqrt(a[y].r*a[y].r-ch*ch),lg=sqrt(a[x].r*a[x].r-ag*ag);//推导过程 
		p[x].k=(kh-lg)/(ac-ch+ag),p[x].b=lg-(a[x].x-ag)*p[x].k,p[x].l=a[x].x-ag,p[x].r=a[y].x-ch;
	}
}
D f(D x){
	D ans=0;//求已知的对应点y的最大值 
	fr(i,1,i<=n){//与圆的交点 
		if(x>a[i].x-a[i].r&&x<a[i].x+a[i].r)//取不取等看心情 
		ans=max(ans,sqrt(a[i].r*a[i].r-(a[i].x-x)*(a[i].x-x)));
	}
	fr(i,1,i<n){
		if(x>=p[i].l&&x<=p[i].r)
		ans=max(ans,p[i].k*x+p[i].b);
	}
	return ans;
}
D Simpson(D l,D r){
	return (r-l)*(f(r)+f(l)+f((r+l)/2)*4)/6;
}
D jf(D l,D r,D sum){
	D mid=(l+r)/2,le=Simpson(l,mid),ri=Simpson(mid,r);
	if(abs(le+ri-sum)<=jd) return le+ri;
	else return jf(l,mid,le)+jf(mid,r,ri);
}
int main() {
	scanf("%d %lf",&n,&alpha);
	alpha=1/tan(alpha),a[++n].r=0;
	fr(i,1,i<=n){
		scanf("%lf",&a[i].x);
		a[i].x*=alpha;
		if(i>0) a[i].x+=a[i-1].x;
	}
	fr(i,1,i<n) scanf("%lf",&a[i].r);
	fr(i,1,i<n) calc_cut_line(i,i+1);
	D l,r;
	fr(i,1,i<=n) l=min(l,a[i].x-a[i].r),r=max(r,a[i].x+a[i].r);
	printf("%.2lf",2*jf(l,r,Simpson(l,r))); 
	return 0;
}
```






---

## 作者：不存在之人 (赞：2)

自适应辛普森积分

总体思想就是先用一个二次函数拟合曲线然后利用二次函数积分来计算 

然后就一直细分下去直到左右两块分开积分 与整块积分的误差小于eps就可以了
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const
 int MAXN=550;
const
 double eps=1e-6;
int n; 
struct Point
{double x,y;}P[MAXN];

struct Circle
{Point o;double r;}C[MAXN];

struct Line
{
    Point x,y;
    double k,b;
    inline void Bg()
    {
        k=(y.y-x.y)/(y.x-x.x);
        b=y.y-k*y.x;
    }
    inline double D(double x)
    {return k*x+b;}

}L[MAXN];
int Con=0;
#define abs(a) ((a)<0?(-(a)):(a))
inline double D(double x)
{
    double d,ans=0;
    for(int i=1;i<=n;i++)
    {
        d=abs(x-C[i].o.x);
        if(d-C[i].r>-eps)
            continue;
        ans=max(ans,2*sqrt(C[i].r*C[i].r-d*d));
    }
    for(int i=1;i<=Con;i++)
        if(x>=L[i].x.x&&x<=L[i].y.x)
            ans=max(ans,2*L[i].D(x));
    return ans;
}
#define Calc(a,b,c,d) (((b)+4*(c)+(d))*(a)/6)
double Simpson(double L,double M,double R,double fL,double fM,double fR,double sqr)
{
    double Mid1=(L+M)/2,Mid2=(M+R)/2,D1=D(Mid1),D2=D(Mid2),Area1=Calc(M-L,fL,D1,fM),Area2=Calc(R-M,fM,D2,fR);
    if(abs(Area1+Area2-sqr)<eps) return Area1+Area2;
    return Simpson(L,Mid1,M,fL,D1,fM,Area1)+Simpson(M,Mid2,R,fM,D2,fR,Area2);
}

int main()
{
    double Min=1<<29,Max=-Min,d,h,Ang,Sin,Cos;
    scanf("%d%lf",&n,&Ang);
    n++;
    for(int i=1;i<=n;i++) 
        scanf("%lf",&h),C[i].o.y=0,C[i].o.x=h/tan(Ang)+C[i-1].o.x;
    for(int i=1;i<n;i++)scanf("%lf",&C[i].r);
    for(int i=1;i<=n;i++)
        Min=min(Min,C[i].o.x-C[i].r),Max=max(Max,C[i].o.x+C[i].r);
    for(int i=1;i<n;i++)
    {
        d=C[i+1].o.x-C[i].o.x;
        if(d-abs(C[i+1].r-C[i].r)<-eps)continue;
        Sin=(C[i].r-C[i+1].r)/d,Cos=sqrt(1-Sin*Sin);
        L[++Con]=(Line){(Point){C[i].o.x+C[i].r*Sin,C[i].r*Cos},(Point){C[i+1].o.x+C[i+1].r*Sin,C[i+1].r*Cos}};
        L[Con].Bg();
    }
    double L=Min,R=Max;
    double M=(L+R)/2;
    double fL=D(L),fM=D(M),fR=D(R);
    printf("%.2lf\n",Simpson(L,M,R,fL,fM,fR,Calc(R-L,fL,fM,fR)));
    return 0;
}
```

---

## 作者：__er (赞：1)

![](https://s2.ax1x.com/2019/10/09/uInxQf.png)

把柠檬树切开，每一层都是一个圆台，顶层除外，顶层是圆锥，**忽略树干产生的影子**。

简单画个圆锥（Geogebra 不会画圆台），可以发现，影子是由圆和相邻的两个圆的公切线与 $x$ 轴围成的图形的面积，对于每个圆，忽略其 $y$ 坐标，只看 $x$ 坐标，对于任意的一个圆，$x$ 坐标为 $\tan \alpha$ 。

此图形关于 $x$ 轴对称，考虑砍掉一半，只看上面，求完之后乘 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lpp8qpoj.png)

设 $A(a,0),C(b,0)$（点标的有点乱），由两组相似可得两个半圆形的解析式：

$$y_1=\sqrt{r^2_1-(x-a)^2},y_2=\sqrt{r^2_2-(x-b)^2}$$

设 $B(u,\sqrt{r^2_1-(u-a)^2}),D(v,\sqrt{r^2_2-(v-b)^2})$，由此可得 $G(u,0),E(v,0)$。

进一步求解公切线解析式：

$$\left\{\begin{array}{l}
\sqrt{r_{1}^{2}-(u-a)^{2}}=k u+b \\
\sqrt{r_{2}^{2}-(v-a)^{2}}=k v+b
\end{array}\right.$$

此时条件为 $r_1>r_2$，剩余情况以此类推。

求 $x$ 轴围成图形的面积，想到积分，定积分想到辛普森法：

辛普森法的核心思想就是把函数 $f$ 近似地看成**二次函数**，于是给出辛普森公式的推导：

由于把 $f$ 近似地看成二次函数，所以，对于二次函数 $f(x)=ax^2+bx+c$，求积分可得：

$$\displaystyle F(x)=\int^x_0 f(x)\mathrm{d}x=\dfrac{a}{3}x^3+\dfrac{b}{2}x^2+cx+k$$

其中 $k$ 为一个常数，那么：

$$\begin{aligned}
\int_{l}^{r} f(x) \mathrm{d} x & =F(r)-F(l) \\
& =\frac{a}{3}\left(r^{3}-l^{3}\right)+\frac{b}{2}\left(r^{2}-l^{2}\right)+c(r-l) \\
& =(r-l)\left(\frac{a}{3}\left(l^{2}+r^{2}+l r\right)+\frac{b}{2}(l+r)+c\right) \\
& =\frac{r-l}{6}\left(2 a l^{2}+2 a r^{2}+2 a l r+3 b l+3 b r+6 c\right) \\
& =\frac{r-l}{6}\left(\left(a l^{2}+b l+c\right)+\left(a r^{2}+b r+c\right)+4\left(a\left(\frac{l+r}{2}\right)^{2}+b\left(\frac{l+r}{2}\right)+c\right)\right) \\
& =\frac{r-l}{6}\left(f(l)+f(r)+4 f\left(\frac{l+r}{2}\right)\right)
\end{aligned}$$

稍微改写下形式就得到了辛普森公式：

$$\int_{l}^{r} f(x) \mathrm{d} x=\dfrac{r-l\left(f(l)+f(r)+4 f\left(\frac{l+r}{2}\right)\right)}{6}$$

1.  辛普森法

有一自然数 $n$，将区间 $[l,r]$ 分成等长的 $2n$ 个区间，计算每个小区间的积分值，求和可得总积分

对于 $[x_{2i},x_{2i-2}]$ 的一段区间，选定三个点 $\left( x_{2i-2},x_{2i-1},x_{2i} \right)$，构成抛物线，得到函数 $f^{'}(x)$，于是，原来计算么个小区间的积分值就可以转化为求二次函数 $f^{'}(x)$ 的值，而 $f^{'}(x)$ 可以用辛普森公式近似计算。

代码实现很简单，就不再赘述了。

2.  自适应辛普森法

从上文可知，结果的精度取决于 $n$ 的取值，所以，如果一段积分已经很接近二次函数了，误差值在接受范围内，就可以不用往下继续分段了。

可以对于一段积分先代入辛普森公式求值，然后再将这段积分平分成两段继续求积分，如果差值小于要求的精度 $eps$ 就直接返回。

扔个板子：

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-6;
double a, b, c, d, l, r;
double f(double x) {
	
}
double simpson(double l, double r) {
	double mid = (l + r) / 2.0;
	return (f(l) + 4.0 * f(mid) + f(r)) * (r - l) / 6.0;
}
double asr(double l, double r, double eps, double ans) {
	double mid = (l + r) / 2.0, l_ = simpson(l, mid), r_ = simpson(mid, r);
	if (fabs(l_ + r_ - ans) <= 15.0 * eps) return l_ + r_ + (l_ + r_ - ans) / 15.0;
	return asr(l, mid, eps / 2.0, l_) + asr(mid, r, eps / 2.0, r_);
}
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> a >> b >> c >> d >> l >> r;
	cout << fixed << setprecision(6) << asr(l, r, eps, simpson(l, r));
	return 0;
}
```

现在只需要实现 $\tan$ 和 $f(x)$ 即可了；

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, cnt;
double aph;
const double eps = 1e-8;
pair<double, double> cir[502];
pair<pair<double, double>, pair<double, double>> al[501];
double f(double x) {
	double ans = 0.0;
	for (int i = 1; i <= n; i++) if (x >= cir[i].first - cir[i].second && x <= cir[i].first + cir[i].second) ans = max(ans, sqrt(cir[i].second * cir[i].second - (x - cir[i].first) * (x - cir[i].first)));
	for (int i = 1; i <= cnt; i++) if (x >= al[i].second.first && x <= al[i].second.second) ans = max(ans, al[i].first.first * x + al[i].first.second);
	return ans;
}
double sim(double x, double y) {
	return (y - x) * (f(x) + f(y) + 4 * f((x + y) / 2)) / 6;
}
double asr(double l, double r, double ans) {
	double mid = (l + r) / 2.0, l_ = sim(l, mid), r_ = sim(mid, r);
	if (fabs(l_ + r_ - ans) <= 15.0 * eps) return l_ + r_ + (l_ + r_ - ans) / 15.0;
	return asr(l, mid, l_) + asr(mid, r, r_);
}
void Tan(pair<double, double> a, pair<double, double> b) {
	if (fabs(a.second - b.second) <= eps) {
		al[++cnt].first = make_pair(0, a.second);
		al[cnt].second = make_pair(a.first, b.first);
		return;
	}
	if (a.second > b.second) {
		al[++cnt].second.first = a.first + a.second * (a.second - b.second) / (b.first - a.first);
		al[cnt].second.second = b.first + (al[cnt].second.first - a.first) * b.second / a.second;
		al[cnt].first.first = sqrt(a.second * a.second - (a.first - al[cnt].second.first) * (a.first - al[cnt].second.first));
		al[cnt].first.first -= sqrt(b.second * b.second - (b.first - al[cnt].second.second) * (b.first - al[cnt].second.second));
		al[cnt].first.first /= al[cnt].second.first - al[cnt].second.second;
		al[cnt].first.second = sqrt(a.second * a.second - (a.first - al[cnt].second.first) * (a.first - al[cnt].second.first)) - al[cnt].second.first * al[cnt].first.first;
	} else {
		al[++cnt].second.second = b.first - b.second * (b.second - a.second) / (b.first - a.first);
		al[cnt].second.first = a.first - (b.first - al[cnt].second.second) * a.second / b.second;
		al[cnt].first.first = sqrt(a.second * a.second - (a.first - al[cnt].second.first) * (a.first - al[cnt].second.first));
		al[cnt].first.first -= sqrt(b.second * b.second - (b.first - al[cnt].second.second) * (b.first - al[cnt].second.second));
		al[cnt].first.first /= al[cnt].second.first - al[cnt].second.second;
		al[cnt].first.second = sqrt(a.second * a.second - (a.first - al[cnt].second.first) * (a.first - al[cnt].second.first)) - al[cnt].second.first * al[cnt].first.first;
	}
	return;
}
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> aph;
	aph = 1.0 / tan(aph), cir[0].first = 0;
	for (int i = 1; i <= n + 1; i++) cin >> cir[i].first, cir[i].first = cir[i - 1].first + cir[i].first * aph;
	for (int i = 1; i <= n; i++) cin >> cir[i].second;
	cir[++n].second = 0;
	double l (cir[1].first - cir[1].second), r (cir[n].first);
	for (int i = 1; i <= n; i++)r = (r > cir[i].first + cir[i].second ? r : cir[i].first + cir[i].second), l = (l < cir[i].first - cir[i].second ? l : cir[i].first - cir[i].second);
	for (int i = 1; i < n; i++) Tan(cir[i], cir[i + 1]);
	return cout << fixed << setprecision(2) << 2 * asr(l, r, sim(l, r)), 0;
}

```







---

## 作者：Great_Influence (赞：1)

辛普森积分模板题。

画图可以发现，题目需要求一些圆和梯形（相邻圆的切线与垂线构成）的面积并，可以采用辛普森积分来计算答案。时间复杂度O(玄学)。

注意eps的选取可以影响答案的精确度。虽然该题只要求保留2位小数，但是eps最好选取1e-6至1e-8，以免答案精确度或者时间复杂度导致答案错误。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x)
{
	T s=0,f=1;char k=getchar();
	while(!isdigit(k)&&(k^'-'))k=getchar();
	if(!isdigit(k)){f=-1;k=getchar();}
	while(isdigit(k)){s=s*10+(k^48);k=getchar();}
	x=s*f;
}
void file()
{
	#ifndef ONLINE_JUDGE
		freopen("test.in","r",stdin);
		freopen("test.out","w",stdout);
	#endif
}
const int MAXN=1017;
static struct circle
{
	double x,R;
}p[MAXN];
static struct line
{
	double k,b,l,r;
}q[MAXN];
static int n;
static double ang;
#define sq(a) ((a)*(a))
inline void calc(int x,int y)
{
	if(p[x].R==p[y].R)
	{
		q[x].l=p[x].x;
		q[x].r=p[y].x;
		q[x].k=0;q[x].b=p[x].R;
		return;
	}
	double dx=p[y].x-p[x].x,dr=fabs(p[x].R-p[y].R);
	double ly,ry;
	if(p[x].R>p[y].R)
	{
		q[x].l=p[x].x+p[x].R*dr/dx;
		q[x].r=p[y].x+(q[x].l-p[x].x)*p[y].R/p[x].R;
		ly=sqrt(sq(p[x].R)-sq(q[x].l-p[x].x));
		ry=sqrt(sq(p[y].R)-sq(q[x].r-p[y].x));
		q[x].k=(ly-ry)/(q[x].l-q[x].r);
		q[x].b=ly-q[x].l*q[x].k;
	}
	else
	{
		q[x].r=p[y].x-p[y].R*dr/dx;
		q[x].l=p[x].x-(p[y].x-q[x].r)*p[x].R/p[y].R;
		ly=sqrt(sq(p[x].R)-sq(q[x].l-p[x].x));
		ry=sqrt(sq(p[y].R)-sq(q[x].r-p[y].x));
		q[x].k=(ly-ry)/(q[x].l-q[x].r);
		q[x].b=ly-q[x].l*q[x].k;
	}
}
inline void init()
{
	read(n);scanf("%lf",&ang);
	ang=1.0/tan(ang);
	scanf("%lf",&p[1].x);
	p[1].x*=ang;
	Rep(i,2,n+1)
		scanf("%lf",&p[i].x),p[i].x*=ang
		,p[i].x+=p[i-1].x;
	Rep(i,1,n)scanf("%lf",&p[i].R);
	++n;p[n].R=0.0;
	Rep(i,1,n-1)calc(i,i+1);
}
const double eps=0.00000001;
#define Chkmax(a,b) a=a>(b)?a:(b)
inline double f(double x)
{
	static double ans;ans=0.0;
	Rep(i,1,n)
		if(x<p[i].x+p[i].R&&x>p[i].x-p[i].R)
		Chkmax(ans,sqrt(sq(p[i].R)-sq(x-p[i].x)));
	Rep(i,1,n)if(x>=q[i].l&&x<=q[i].r)
		Chkmax(ans,q[i].k*x+q[i].b);
	return ans;
}
inline double g(double l,double r)
{
	static double mid;mid=(l+r)/2.0;
	return (f(l)+f(r)+4.0*f(mid))*(r-l)/6.0;
}
double simpson(double l,double r,double ans)
{
	double mid=(l+r)/2.0
		,lans=g(l,mid),rans=g(mid,r);
	if(fabs(ans-lans-rans)<=eps)return lans+rans;
	return simpson(l,mid,lans)
		+simpson(mid,r,rans);
}
#define Chkmin(a,b) a=a<(b)?a:(b)
inline void solve()
{
	double ll=p[1].x-p[1].R,rr=p[n].x;
	Rep(i,1,n)
	{
		Chkmax(rr,p[i].x+p[i].R);
		Chkmin(ll,p[i].x-p[i].R);
	}
	printf("%.2lf\n",2.0*simpson(ll,rr,g(ll,rr)));
}
int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---


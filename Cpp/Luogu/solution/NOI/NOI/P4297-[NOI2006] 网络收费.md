# [NOI2006] 网络收费

## 题目背景

noi2006 day1t1

## 题目描述

网络已经成为当今世界不可或缺的一部分。每天都有数以亿计的人使用网络进行学习、科研、娱乐等活动。然而，不可忽视的一点就是网络本身有着庞大的运行费用。所以，向使用网络的人进行适当的收费是必须的，也是合理的。

MY 市 NS 中学就有着这样一个教育网络。网络中的用户一共有 $2^N$ 个，编号依次为 $1,2,3,\cdots,2^N$。这些用户之间是用路由点和网线组成的。用户、路由点与网线共同构成一个满二叉树结构。树中的每一个叶子结点都是一个用户，每一个非叶子结点（灰色）都是一个路由点，而每一条边都是一条网线（见下图，用户结点中的数字为其编号）。

![](https://cdn.luogu.com.cn/upload/pic/12807.png)

MY 网络公司的网络收费方式比较奇特，称为“配对收费”。即对于每两个用户 $i,j$ $(1\leq i<j\leq 2^N)$ 进行收费。由于用户可以自行选择两种付费方式 A、B 中的一种，所以网络公司向学校收取的费用与每一位用户的付费方式有关。该费用等于每两位不同用户配对产生费用之和。

为了描述方便，首先定义这棵网络树上的一些概念：

- 祖先：根结点没有祖先，非根结点的祖先包括它的父亲以及它的父亲的祖先；
- 管辖叶结点：叶结点本身不管辖任何叶结点，非叶结点管辖它的左儿子所管辖的叶结点与它的右儿子所管辖的叶结点；
- 距离：在树上连接两个点之间的用边最少的路径所含的边数。

对于任两个用户 $i,j$ $(1\leq i<j\leq2^N)$，首先在树上找到与它们距离最近的公共祖先：路由点 $P$，然后观察 $P$ 所管辖的叶结点（即用户）中选择付费方式 A 与 B 的人数，分别记为 $n_A$ 与 $n_B$，接着按照网络管理条例第 X 章第 Y 条第 Z 款进行收费（如下表），其中 $F_{i,j}$ 为 $i$ 和 $j$ 之间的流量，且为已知量。

![](https://cdn.luogu.com.cn/upload/pic/12809.png)

由于最终所付费用与付费方式有关，所以 NS 中学的用户希望能够自行改变自己的付费方式以减少总付费。然而，由于网络公司已经将每个用户注册时所选择的付费方式记录在案，所以对于用户 $i$，如果他/她想改变付费方式（由 A 改为 B 或由 B 改为 A），就必须支付 $C_i$ 元给网络公司以修改档案（修改付费方式记录）。

现在的问题是，给定每个用户注册时所选择的付费方式以及 $C_i$，试求这些用户应该如何选择自己的付费方式以使得 NS 中学支付给网络公司的总费用最少（更改付费方式费用 + 配对收费的费用）。

## 说明/提示

【样例说明】

将 $1$ 号用户的付费方式由 B 改为 A，NS 中学支付给网络公司的费用达到最小。

【数据范围】

$40\%$ 的数据中 $N\leq4$；

$80\%$ 的数据中 $N\leq7$；

$100\%$ 的数据中 $N\leq10,0\leq F_{i,j}\leq500,0\leq C_i\leq500000$。

## 样例 #1

### 输入

```
2
1 0 1 0
2 2 10 9
10 1 2
2 1
3```

### 输出

```
8```

# 题解

## 作者：leozhang (赞：24)


这是一道...卡了我一个月的树形dp...

我真是太弱了...

其实仔细想想，这题的核心思路并不是特别复杂，但是的确存在不小的难度

作为一个看过全网基本所有题解+标程才弄明白这题到底怎么回事的蒟蒻，我努力把所有东西揉到一起让各位看官一眼看懂...

首先我们简化一下题意：给定一棵满二叉树，每个叶节点有一个状态（0,1），任选两个叶节点，如果这两个叶节点状态相同但他们的LCA所管辖的子树中的与他们状态相同的叶节点个数较少（少于1/2），则会产生2f的代价，如果状态不同，则产生f的代价，如果状态相同且LCA管辖子树中与他们状态相同叶节点个数较多，则不产生代价，现在每个节点可以变更状态，但变更状态也有自己的代价，求最小总代价

那么..怎么搞？

首先，有一个很重要的思想：点对之间的问题是难以快速解决的！

很简单，因为如果我们按点对统计贡献，那么在枚举到每个叶节点都需要考虑其他所有叶节点，这样是不利于我们处理问题的

所以我们第一步要考虑的是把点对的贡献压到一个点上

很幸运，题目给出了这样的方式：

注意题目中“产生2f的代价”“产生f的代价”这两句话！

那么如果我们同样给所有非叶节点一个状态（0,1），代表这个节点管辖的子树中叶节点状态为0的多还是状态为1的多，那么我们显然可以看到：如果一个叶节点和这个根节点的状态相同，那么这个叶节点不会产生贡献，反之会产生一个f的贡献！

证明：分类讨论：

①：假设两个节点与根节点状态都相同，那么这两个节点都不产生贡献，满足题意

②：假设两个节点与根节点状态都不同，那么这两个节点都产生一个f的贡献，满足题意

③：如果有一个点与根节点状态相同，那么这两个节点只产生一个f的贡献，同样满足题意

因此我们这样处理点对是正确的

总结：在处理点对时，我们要把一个点对的贡献压到一个点上，同时给所有非叶节点一个状态，这样就能满足题意了

接下来就可以进行树形dp了

记状态dp[i][j]表示当前位于树上的第i个节点，其子树的叶节点中状态为0的点的个数为j时所需的最小代价

（这里对题意有一个小提示：当两种状态的叶节点数量相等时，认为状态为0的叶节点个数多）

如果这个节点不是叶节点，那么显然，这个节点会有两种可能的状态：

①：这个节点状态为1，认为对应的情况为子树中状态为0的节点偏多，那么可以转移的dp部分是叶节点个数/2-叶节点个数

②：这个节点状态为0，认为对应的情况为子树中状态为1的节点偏多，那么可以转移的dp部分是0-叶节点个数/2-1

那么我们分两类dfs处理，对每类情况分别合并即可

如果这个节点是叶节点，那么我们反过来枚举他上面一条链的情况，然后统计代价即可，一定注意dp的第二维代表状态为0的节点的数目！

在统计代价的时候，我们还涉及一个小问题，就是如果每次找到根节点时都枚举所有点计算代价，时间承受不了，所以我们对代价求前缀和，然后用类似倍增的方法计算总代价即可。

当然，我们不可能一直枚举上面一条链的情况，所以我们直接把这条链的状态状压，传进dfs里即可，这样也就不涉及网上大部分题解都涉及到的压缩空间的问题了。

提示：这是一棵满二叉树，所以可以用类似线段树的方式去遍历。

这样这道题就结束了

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define rt1 rt<<1
#define rt2 (rt<<1)|1
using namespace std;
int dp[(1<<11)+5][(1<<11)+5];
int v[(1<<11)+5][(1<<11)+5];
int cv[(1<<11)+5];
int ori[(1<<11)+5];
int temp[(1<<11)+5];
int lq[20],rq[20];
int n;
void dfs(int rt,int l,int r,int sit,int dep)
{
    if(l==r)
    {
        dep--;
        dp[rt][0]=dp[rt][1]=0;
        if(ori[l])
        {
            dp[rt][1]=cv[l];
        }else
        {
            dp[rt][0]=cv[l];
        }
        for(int i=1;i<=dep;i++)
        {
            int mid=(lq[i]+rq[i])>>1;
            if((sit&(1<<(dep-i))))
            {
                if(l<=mid)
                {
                    dp[rt][0]+=v[l][rq[i]]-v[l][mid];
                }else
                {
                    dp[rt][0]+=v[l][mid]-v[l][lq[i]-1];
                }
            }else
            {
                if(l<=mid)
                {
                    dp[rt][1]+=v[l][rq[i]]-v[l][mid];
                }else
                {
                    dp[rt][1]+=v[l][mid]-v[l][lq[i]-1];
                }
            }
        }
        return;
    }
    int mid=(l+r)>>1;
    int len=r-l+1;
    lq[dep]=l;
    rq[dep]=r;
    dfs(rt1,l,mid,(sit<<1),dep+1);
    dfs(rt2,mid+1,r,(sit<<1),dep+1);
    memset(temp,0x3f,sizeof(temp));
    for(int i=0;i<=len/2-1;i++)
    {
        for(int j=0;j<=i;j++)
        {
            temp[i]=min(temp[i],dp[rt1][j]+dp[rt2][i-j]);
        }
    }
    for(int i=0;i<=len/2-1;i++)
    {
        dp[rt][i]=temp[i];
    }
    dfs(rt1,l,mid,(sit<<1)|1,dep+1);
    dfs(rt2,mid+1,r,(sit<<1)|1,dep+1);
    memset(temp,0x3f,sizeof(temp));
    for(int i=len/2;i<=len;i++)
    {
        for(int j=0;j<=i;j++)
        {
            temp[i]=min(temp[i],dp[rt1][j]+dp[rt2][i-j]);
        }
    }
    for(int i=len/2;i<=len;i++)
    {
        dp[rt][i]=temp[i];
    }
}
int main()
{
    scanf("%d",&n);
    n=(1<<n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&ori[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&cv[i]);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            scanf("%d",&v[i][j]);
            v[j][i]=v[i][j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            v[i][j]=v[i][j-1]+v[i][j];
        }
    }
    memset(dp,0x3f,sizeof(dp));
    dfs(1,1,n,0,1);
    int ans=2147483647;
    for(int i=0;i<=n;i++)
    {
        ans=min(ans,dp[1][i]);
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：伟大的王夫子 (赞：7)

本题说难不难，说易不易，妙就妙在贡献之间的转化。

首先，基本上很难从点对之间的贡献入手来解决本题，需将点对之间的贡献转化到其 LCA 上。显然，题目中给出的系数是特意构造好，比较有规律的系数。不妨设 $nA < nB$ 与 $A$ 状态为 0，那么对于一个点对的贡献，我们可以从两个点的位置分别进行考虑。设一个点对 $(x, y)$，其最近公共祖先为 $z$，那么先从 $x$ 考虑，如果 $x$ 与 $z$ 的状态相同，那么贡献的系数会加一。我们再从 $y$ 进行考虑，过程类似，即可算出正确答案。具体的，遍历到一个叶子结点时，我们枚举其所有的祖先 $p$。若 $x$ 与 $y$ 的 LCA 为 $p$，那么 $y$ 必定在 $p$ 的另一个子节点的子树中。可以直接前缀和累加贡献。

这时，虽然贡献转化到了祖先上，但是我们仍然无法很方便的进行树形 DP。有一种方法是枚举祖先的 0/1 状态，并且在 DP 时对 A 和 B 的数量进行控制。

如果还有不懂的，可以直接看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int S = (1 << 10) + 5;
int n, a[S], F[S][S], L[S << 1], R[S << 1], tot_dfn, dp[S << 1][S];
bool b[S], vis[S];//0 nA < nB 1 nA >= nB
//0 A 1 B
void prework(int x, int d) {
	L[x] = tot_dfn + 1;
	if (d == n + 1) {
		R[x] = ++tot_dfn;
		return;
	}
	prework(x << 1, d + 1);
	prework(x << 1 | 1, d + 1);
	R[x] = tot_dfn;
}
void dfs(int x, int d) {
	for (int i = 0; i <= (1 << (n - d + 1)); ++i) dp[x][i] = 0x3f3f3f3f;
	if (d == n + 1) {
		dp[x][0] = dp[x][1] = 0;
		int xx = x - (1 << n) + 1;
		for (int p = (x >> 1); p; p >>= 1) {
			int v = 0;
			if (L[p << 1] <= L[x] && L[x] <= R[p << 1]) v = F[xx][R[p << 1 | 1]] - F[xx][L[p << 1 | 1] - 1];
			else v = F[xx][R[p << 1]] - F[xx][L[p << 1] - 1];
			if (vis[p] == 0) dp[x][0] += v;
			else dp[x][1] += v;
		}
		dp[x][b[xx] ^ 1] += a[xx];
		return;
	}
	vis[x] = 0;// nA < nB
	dfs(x << 1, d + 1);
	dfs(x << 1 | 1, d + 1);
	for (int i = 0; i <= (1 << (n - d)); ++i)
		for (int j = 0; j <= (1 << (n - d)); ++j)
			if (i + j > (1 << (n - d))) dp[x][i + j] = min(dp[x][i + j], dp[x << 1][i] + dp[x << 1 | 1][j]);
	vis[x] = 1;
	dfs(x << 1, d + 1);
	dfs(x << 1 | 1, d + 1);
	for (int i = 0; i <= (1 << (n - d)); ++i)
		for (int j = 0; j <= (1 << (n - d)); ++j)
			if (i + j <= (1 << (n - d))) dp[x][i + j] = min(dp[x][i + j], dp[x << 1][i] + dp[x << 1 | 1][j]);
}
int main() {
	cin >> n;
	for (int i = 1; i <= (1 << n); ++i) scanf("%d", b + i);
	for (int i = 1; i <= (1 << n); ++i) scanf("%d", a + i);
	for (int i = 1; i <= (1 << n); ++i)
		for (int j = 1; j <= (1 << n) - i; ++j) scanf("%d", F[i] + i + j);
	for (int i = 1; i <= (1 << n); ++i)
		for (int j = 1; j <= i; ++j) F[i][j] = F[j][i];
	for (int i = 1; i <= (1 << n); ++i)
		for (int j = 1; j <= (1 << n); ++j) F[i][j] += F[i][j - 1];
	prework(1, 1);
	dfs(1, 1);
	int ans = 0x3f3f3f3f;
	for (int i = 0; i <= (1 << n); ++i) ans = min(ans, dp[1][i]);
	cout << ans;
}
```

---

## 作者：GoldenPotato137 (赞：7)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/luogu-p4297-noi2006%E7%BD%91%E7%BB%9C%E6%94%B6%E8%B4%B9/)

---
# Solution
这题喵啊。

.

首先，我们会发现统计两个点互相的贡献是一个极其困难的问题。

但是，仔细观察那张收费表格后会发现，我们可以重新定义一下这个收费：**我们假
设路由器节点的颜色为叶子中数目较多的颜色，当一个叶子结点颜色与路由器节点颜色相同的时候不收钱，否则收一份钱。**我们可以惊讶的发现，这样做之后我们的新收费做法就与原来题目要求的重合了，而且**贡献由点对转到了点上**。

接下来，我们就可以统计每个叶子节点对每个路由器产生的贡献了。**我们设$F[i][j]$表示第$i$个叶子节点在LCA为$j$情况下产生的贡献**。这个非常好搞，我们只需要枚举点对+计算LCA即可，复杂度$O(n^2logn)$

.

我们会发现一个问题，一个叶子节点的贡献值与它到根路径上所有的路由器的颜色息息相关。因此，我们传统的基于子树的树形DP做法已经行不通了，我们现在需要一个基于某个点到根路径的DP做法。

考虑：**设$f[i][j][k]$表示目前填到了第$i$个点，它到根的路径一路上的颜色为$j$(状压形式表现),它的孩子(叶子节点)要填$k$个颜色B。**

转移非常简单，对于路由器节点，我们只需要像背包一样枚举左右孩子分别分配多少个颜色B即可；对于叶子节点，我们只需要直接一路算上去它的贡献即可。

但是我们会发现一个问题，这样子我们直接设的空间复杂度是$O(2^{3n})$的，并开不下。

我们观察后发现，对于任何一个节点，假设它的深度为$k$,那么，它的叶子节点最多有$2^{(n-k)}$个，它到父亲的距离的情况最多有$2^k$种。**因此，我们发现这两位的状态可以直接压在一起（即放到一起存储，需要时再分开），空间复杂度就可以优化至$O(2^{2n})$**,可以通过这一题。

.

时间复杂度$O(2^{2n}\cdot n)$

就酱，这题就被我们切掉啦=￣ω￣=

---
# Code
**数据生成器**

[在这里](https://www.goldenpotato.cn/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/luogu-p4297-noi2006%E7%BD%91%E7%BB%9C%E6%94%B6%E8%B4%B9/)

**正解**
```cpp
//Luogu P4297 [NOI2006]网络收费
//Mar,28th,2019
//树形DP+状压DP妙题
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=2100;
const long long inf=0x3f3f3f3f3f3f3f3fll;
int n,m,a[N],c[N],w[N][N];
long long F[N][N],depth[N],fa[N][21];//F[i][j]:i在LCA=j的时候的贡献
void dfs(int now)
{
	for(int i=1;i<=20;i++)
		fa[now][i]=fa[fa[now][i-1]][i-1];
	if(now<(1<<n))
	{
		fa[now*2][0]=now,depth[now*2]=depth[now]+1,dfs(now*2);
		fa[now*2+1][0]=now,depth[now*2+1]=depth[now]+1,dfs(now*2+1);
	}
}
int LCA(int x,int y)
{
	if(depth[y]>depth[x]) swap(x,y);
	for(int i=20;i>=0;i--)
		if(depth[x]-(1<<i)>=depth[y])
			x=fa[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
long long f[N][N*2];
long long dfs2(int now,int K)
{
	if(f[now][K]!=0) return f[now][K];
	int c_now=0,cnt_B=K/(1<<depth[now]),cnt_A=(1<<(n-depth[now]))-cnt_B;
	if(cnt_B<0 or cnt_A<0) return f[now][K]=inf;
	if(cnt_B>cnt_A) c_now=1;
	if(now>=(1<<n))
	{
		int tmp=K%(1<<depth[now]),t_now=now/2;
		for(;t_now>0;t_now/=2,tmp/=2)
			f[now][K]+=(c_now!=(tmp%2))*F[now][t_now];
		f[now][K]+=c[now]*(a[now]!=c_now);
		return f[now][K];
	}
	long long t_ans=inf;
	for(int i=0;i<=cnt_B;i++)
	{
		long long L=dfs2(now*2,((K%(1<<depth[now]))<<1)+c_now+i*(1<<depth[now*2]));
		long long R=dfs2(now*2+1,((K%(1<<depth[now]))<<1)+c_now+(cnt_B-i)*(1<<depth[now*2+1]));
		t_ans=min(t_ans,L+R);
	}
	return f[now][K]=t_ans;
}
int main()
{
	n=read();
	m=(1<<(n+1))-1;
	for(int i=(1<<n);i<=m;i++)
		a[i]=read();
	for(int i=(1<<n);i<=m;i++)
		c[i]=read();
	for(int i=(1<<n);i<=m;i++)
		for(int j=i+1;j<=m;j++)
			w[i][j]=w[j][i]=read();
	
	dfs(1);
	for(int i=(1<<n);i<=m;i++)
		for(int j=i+1;j<=m;j++)
			F[i][LCA(i,j)]+=w[i][j],
			F[j][LCA(i,j)]+=w[i][j];
	
	long long ans=inf;
	for(int i=0;i<=(1<<n);i++)
		ans=min(ans,dfs2(1,i));
	
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：Tgotp (赞：7)

观察到层数最多只有10，那么状压层数，

发现对于第i层，若是设为na <nb，那么在子树遍历的时候，以当前层为lca的点为a时能产生价值，反之同理。

令f[i][j]表示第i个点，下面有j个a点，以及记录当前层包含区间[L,R]，那么对于na < nb时只能更新[L,mid]反之只能更新[mid+1,R]

考虑到叶子节点的时候，因为已经考虑了其祖先状态，那么一层层分别考虑贡献即可。

c++代码如下：
```cpp


#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x ;i <= y; ++ i)
#define repd(i,x,y) for(register int i = x ;i >= y; -- i)
using namespace std;
typedef long long ll;
template<typename T>inline bool chkmin(T&x,T y) { return x > y ? x = y,1 : 0; }
template<typename T>inline bool chkmax(T&x,T y) { return x < y ? x = y,1 : 0; }
template<typename T>inline void read(T&x)
{
	char c;int sign = 1;x = 0;
	do { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

const int N = 1e3 + 30;
int f[N<<1][N],g[N][N],a[N],c[N];
int L[20],R[20],tmp[N],n;

void dfs(int id,int l,int r,int s,int deep)
{
	if(l == r)
	{
		-- deep;
		f[id][0] = (f[id][1] = 0);
		if(!a[l]) f[id][0] = c[l];
		else f[id][1] = c[l];
		rep(i,1,deep)
		{
			int mid = L[i] + R[i] >> 1;
			if((s&(1<<deep-i)))
			{
				if(l <= mid) f[id][1] += g[l][R[i]] - g[l][mid];
				else f[id][1] += g[l][mid] - g[l][L[i]-1];
			}
			else
			{
				if(l <= mid) f[id][0] += g[l][R[i]] - g[l][mid];
				else f[id][0] += g[l][mid] - g[l][L[i]-1];
			}
		}
		return;
	}
	int mid = l + r >> 1,num = r - l + 1;
	L[deep] = l;R[deep] = r;
	dfs(id<<1,l,mid,s<<1|1,deep + 1);
	dfs(id<<1|1,mid+1,r,s<<1|1,deep + 1);
	memset(tmp,0x3f,sizeof tmp);
	rep(i,0,num/2-1) rep(j,0,i)
		tmp[i] = min(tmp[i],f[id<<1][j] + f[id<<1|1][i-j]);
	rep(i,0,num/2-1) f[id][i] = tmp[i];
	dfs(id<<1,l,mid,s<<1,deep + 1);
	dfs(id<<1|1,mid+1,r,s<<1,deep + 1);
	memset(tmp,0x3f,sizeof tmp);
	rep(i,num/2,num) rep(j,0,i)
		tmp[i] = min(tmp[i],f[id<<1][j] + f[id<<1|1][i-j]);
	rep(i,num/2,num) f[id][i] = tmp[i];
}

int main()
{
	memset(f,0x3f,sizeof f);
	read(n);
	n = 1 << n;
	rep(i,1,n) read(a[i]);
	rep(i,1,n) read(c[i]);
	rep(i,1,n)
		rep(j,i + 1,n)
			read(g[i][j]),g[j][i] = g[i][j];
	rep(i,1,n)
		rep(j,1,n)
			g[i][j] = g[i][j - 1] + g[i][j];
	dfs(1,1,n,0,1);
	int ans = INT_MAX;
	rep(i,0,n) chkmin(ans,f[1][i]);
	cout << ans <<endl;
	return 0;
}
```
[noi2006:网络收费](http://tgotp.science/1495-noi2006%E7%BD%91%E7%BB%9C%E6%94%B6%E8%B4%B9/)

---

## 作者：AzusaCat (赞：4)

神仙题Orz

一开始以为是个最小割结果发现不太可做，这题的压缩祖先状态的方法真的神。

我们发现**点对**的贡献不是很好计算，所以我们考虑计算**点**的贡献。我们发现本质上付费系数只与 $i$ 和 $j$ **分别**与lca的关系有关，也就是这条链的贡献可以转化为两个点对lca的贡献，即链的贡献与 $i$ 和 $j$ 的关系无关。具体贡献看下面。

首先，我们计算一个数组 $s[i][j]$，它的值为 $\sum\limits_{k,lca(i,k)=j}F_{i,k}$ （$i$ 是叶子），我们可以通过枚举点对求出这个数组。那么某一种方案的费用我们就可以用 $s$ 的和来表示。我们现在给非叶子节点也定义状态：对于这个节点的子树，当 $n_A\geqslant n_B$  时为状态A，当 $n_A<n_B$ 时为状态 B。那么我们观察收费表可知，当 $i$ 和 $j$ 状态不同（$i$ 是叶子，$j$ 是 $i$ 的祖先）时，$s[i][j]$ 的贡献系数为 $1$，状态相同时为 $0$。举个例子，如果现在 $n_A<n_B$ 而且 $i$ 选择的付费方式为 $A$ ，那么 $s[i][j]$ 对答案造成的贡献就是 $s[i][j]$ ，如果是 $B$ ，那么贡献就是 $0$。如果我们知道了所有点的状态，对每个点和它的所有祖先都这么算一遍，我们就会不重不漏地计算出所有链的贡献（贡献系数为2就是在两个端点处都计算了一次）。

但是如果你直接暴力枚举状态和最朴素的暴力没有区别，我们这么计算贡献是为了方便dp。我们设 $f[i][j][k]$ 为当前dfs到节点 $i$ ，它的子树内共有 $j$ 个选了 $B$ 的叶子节点，它到根节点路径上每个点的状态为 $k$ 。那么当我们dfs到叶子节点时，所有祖先的状态都已知，我们把 $\sum s[i][t]$ 按照贡献系数加入到 $f$ 中，对于非叶子节点，我们只需要枚举左子树内有多少个 $B$ 来更新就好了。就是要注意如果你枚举这个点哪种方案多的时候要保证 $B$ 的个数合法。

这样的话有一个问题：我们开不下数组！所以我们直接在dfs的时候把状态记下来，也就不用开第三维了，也就是我们现在dfs到了一个非叶子节点，我们先把状态设为0，然后dfs子树，更新对应的值，再把状态设为1再dfs一遍子树，给个伪代码：

```
function dfs(x,l,r)
    if l==r
        calculate f[x][0] and f[x][1]
        return
    now[x]=0
    dfs(lson[x])
    dfs(rson[x])
    calculate f[x][0]->f[x][(r-l+1)/2]
    now[x]=1
    mid=(l+r)/2
    dfs(lson[x],l,mid)
    dfs(rson[x],mid+1,r)
    calculate f[x][(r-l+1)/2+1]->f[x][r-l+1]
    return
```

这样的话复杂度为 $T(n)=4T(\frac{n}{2})+\Theta(n^2)$ ，根据主定理知 $T(n)=\Theta(n^2\log n)$  ，用这道题里的 $n$ 也就是 $\Theta(n2^{2n})$ 。

感觉讲的不是很清楚（我语文不好），大家有问题的话看下代码或者留个言，代码还是很好写的就50多行。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int c[2100],t[2100],s[2100][2100],f[2100][2100];
int lca(int x,int y)
{
    while(x!=y)x>>=1,y>>=1;
    return x;
}
void dfs(int l,int r,int x,int now,int dep)//0->0多  1->1多
{
    if(l==r)
    {
        if(t[x]==0)f[x][0]=0,f[x][1]=c[x];//f[x][k] k个1
        else f[x][1]=0,f[x][0]=c[x];
        for(int i=0,j=x>>1;i<dep;i++,j>>=1)
            if(now&(1<<i))f[x][0]+=s[x][j];
            else f[x][1]+=s[x][j];
        return;
    }
    int mid=(l+r)>>1,sum=r-l+1;
    dfs(l,mid,x*2,now*2,dep+1);
    dfs(mid+1,r,x*2+1,now*2,dep+1);// 0 多
    for(int i=0;i<=sum/2;i++)
    {
        f[x][i]=1e9;
        for(int j=0;j<=i;j++)
            f[x][i]=min(f[x][i],f[x*2][j]+f[x*2+1][i-j]);
    }
    dfs(l,mid,x*2,now*2+1,dep+1);
    dfs(mid+1,r,x*2+1,now*2+1,dep+1);// 1 多
    for(int i=sum/2+1;i<=sum;i++)
    {
        f[x][i]=1e9;
        for(int j=0;j<=sum/2;j++)
            if(i-j<=sum/2)f[x][i]=min(f[x][i],f[x*2][j]+f[x*2+1][i-j]);
    }
}
int main()
{
    int n,m,x;
    scanf("%d",&n);
    m=1<<n;
    for(int i=m;i<2*m;i++)scanf("%d",&t[i]);
    for(int i=m;i<2*m;i++)scanf("%d",&c[i]);
    for(int i=m;i<2*m;i++)
        for(int j=i+1;j<2*m;j++)
        {
            scanf("%d",&x);
            int g=lca(i,j);
            s[i][g]+=x,s[j][g]+=x;
        }
    dfs(1,m,1,0,0);
    int ans=1e9;
    for(int i=0;i<=m;i++)ans=min(ans,f[1][i]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：uniqueharry (赞：3)

## [网络收费](https://www.luogu.com.cn/problem/P4297)

发现题目中的贡献方式是以点对给出的，点对这个东西非常恶心，我们尝试把贡献放到点对中单独的点上。

我们尝试把每个非叶节点也分为 A,B 两种节点，如果非叶节点 $u$ 管辖的叶节点中 A 节点的个数  $n_A$ $\ge$ B 节点的个数 $n_B$，则把该非叶节点令为 A 节点，否则令为 B 节点。此时再看题目给出的计算贡献表格，发现对于叶节点 $i,j$，若 $LCA(i,j) = P$，若 $i$ 与 $P$ 异色则贡献一个 $F(i,j) $，若 $j$ 与 $P$ 异色则再贡献一个 $F(i,j)$，则叶节点 $i$ 对于其祖先 $P$ 的贡献 $f_{i,P}$ 即：

$f_{i,P} = \sum F_{i,j} (LCA(i,j) = P \land \text{i,P异色})$。

这个时候考虑 dp 来计算最小贡献，第一个问题不是设计状态，而是 dp 的顺序。

第一时间想到把叶子序列拿出来一个一个考虑要不要反色，显然不行。因为具有后效性，某个叶子对它的某个祖先的贡献可能受到后面叶子是否反色的影响。

果然还是得靠着这个树的结构去 dp，想到用 $dp_{u,i}$ 表示 $u$ 点子树内有 $i$ 个 A 号点的最小代价，开始想到这个的时候很兴奋，因为这样轻松地确定了 $u$ 点的颜色。但是当时思考的时候仍限于一般树形 dp 的套路，想的是 $u$ 点的答案通过 $u$ 点的左右子树的答案之和再加上 $u$ 的贡献。但是从非叶节点是很难计算贡献的，因为没走到树的底端时是没办法知道叶子的颜色的。所以仍然只能在叶子处计算答案。

那么我们汇总一下信息：

1.贡献只能在叶子处计算。

2.非叶节点的颜色可以通过 dp 的第二维确定。

3.叶子节点计算答案时所需要的信息只是它的祖先 $P$ 的颜色和它是否相同，与另一个叶子节点 $j$ 的颜色没有关系。

4.树的层数最多区区 $n$ 层，而 $n \le 10$。

正解呼之欲出。

在 dfs 的时候用一个二进制数记录根到当前点路径上的点的颜色状态，就可以在叶子节点处完美计算出 $dp_{u,0}$ 和 $dp_{u,1}$，几乎已经做完了。

但是这个 dfs 和以往有所不同，因为 dfs 的时候记录的信息随着 dp 的第二维变化，就会想到要不要在循环的过程中递归调用 dfs，但是这样血炸。仔细一想唯一可能发生变化的也就只有最右链的颜色状态，而且也就两种情况，可以只 dfs 两次。

dp 的部分相对容易，$dp_{u,i} = \min\{dp_{lc(u),j} + dp_{rc(u),i - j}\}$

需要注意的是枚举 $j$ 之前要先把 $dp_{u,i}$ 重置为初始值，因为需要保证 $dp_{lc(u),j}$  和 $dp_{rc(u),i - j}$ 都是在这次的颜色状态下计算出来的值，不能受到之前状态的影响。

---

## 作者：Shikita (赞：3)

# 这是蒟蒻我A的第一道黑题，于是发个题解纪念一下

首先声明，在下思路来源于[zhangyu大佬](https://www.cnblogs.com/CQzhangyu/p/7813248.html)，如果觉得在下的代码过于垃圾，可以移步大佬的博客，虽然这位大佬思路很好但是看代码还是比较费劲（至少对于我这个蒟蒻来说）

如果觉得这个题目过于思路纠缠不清，可以先去了解一下[这题](https://www.luogu.org/problemnew/show/P3262)
（这题也有蒟蒻我的题解哦，希望大家资瓷资瓷哈）
毕竟那题的思路和本题大致相同（这是蒟蒻本人看法），我相信如果做完那题可能对于这题比较有帮助

## 算法详解
本题用到的算法主要有：LCA（树上最近公共祖先），状态压缩DP，

树形DP（在对子树的操作时就是这个思路，不断向上传递结果，虽然也不算是一格严格的树形DP吧）

### 思路（~~摘抄~~于zhangyu大佬）

题解：先观察表格，发现当nA<nB时，我们可以将选A看成系数为1，选B看成系数为0，这样就可以将点对的贡献拆开来考虑。为此我们预处理cost[i][j]，表示i与所有和i的lca深度为j的点构成的点对费用之和，这样我们就相当于将花费都放到了叶子节点处。

但是我们需要知道每个点是nA<nB还是nA>=nB才能确定叶子节点的费用，但由于是完全二叉树，所以我们可以枚举每个节点是nA<nB还是nA>=nB，然后就能确定叶子节点的取A或B的费用，接着用f[x][y]表示x子树中有y个B，其余都是A的最小费用，那么从将一个非叶子节点的两个儿子的DP值进行背包合并便得到了该点的DP值。由于我们已经钦定了该点是nA<nB或是nA>=nB，所以我们在DP时将不合法的状态去掉即可。


我相信大佬的思路也应该便于理解吧，那么接下来是代码详解阶段

```
//Shikita
#include<bits/stdc++.h>
using namespace std;
const int maxn=2050;
typedef long long ll;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
int n=read();
ll ans=1ll<<60;
int a[maxn],vis[20];
ll cost[maxn][12],f[maxn][maxn],C[maxn][2];
inline void init()
{
	for(int i=0;i<=(1<<n)-1;i++)  a[i]=read();
    for(int i=0;i<=(1<<n)-1;i++)  
    C[i][a[i]]=0,C[i][a[i]^1]=read();
}
inline int lca(int a,int b)
{
    for(int i=n-1;i>=0;i--)  if((a>>i)!=(b>>i))  return n-i-1;
}//树上LCA
inline void get_lenth()
{
	for(int i=0;i<=(1<<n)-1;i++)  
	for(int j=i+1;j<=(1<<n)-1;j++)
    {
       int  root=lca(i,j),v=read();
       cost[i][root]+=v,cost[j][root]+=v;
    }
}
//这里要先预处理叶子节点和子树的关系，优先计算出花费会节省一大部分时间
inline void print()
{
	for(int i=0;i<=(1<<n);i++) ans=min(ans,f[1][i]); 
    printf("%lld",ans);
}//由于计算的是以X为根，所以输出就是以1为根啦
void dfs(int x,int step)//核心代码（其实和战争调度差不多）
{
    if(step==n)//如果已经走到了最后
    {
        f[x][0]=C[x-(1<<n)][0];
        f[x][1]=C[x-(1<<n)][1];
        for(int i=0;i<step;i++) 
        f[x][vis[i]^1]+=cost[x-(1<<n)][i];
        return ;
    }
    vis[step]=0;
    memset(f[x],0x3f,sizeof(f[x]));
    //初始化，对了这里大佬的代码是这样的
    //memset(f[x],0x3f,sizeof(f[x][0])*(B[n-dep]+1));
    //好像机房的都不是很了解，希望看懂了的大佬告诉蒟蒻我啊
    dfs(x<<1,step+1),dfs(x<<1|1,step+1);
    for(int i=0;i<=(1<<(n-step-1));i++)   
	for(int j=0;i+j<=(1<<(n-step-1));j++) 
	f[x][i+j]=min(f[x][i+j],f[x<<1][i]+f[x<<1|1][j]);
    vis[step]=1;
    dfs(x<<1,step+1),dfs(x<<1|1,step+1);
    for(int i=1;i<=(1<<(n-step-1));i++)   
	for(int j=(1<<(n-step-1))+1-i;j<=(1<<(n-step-1));j++)  
	f[x][i+j]=min(f[x][i+j],f[x<<1][i]+f[x<<1|1][j]);
    //接下来就是分别对子树的遍历，也就是一个子树的小型背包的合并吧
    //
}
int main()
{
    init();
    get_lenth();
    dfs(1,0);
    print();
    return 0;
}
```

对于本人来说还是喜欢压行的，但是好像在编辑的时候发现这样会超出编辑框，于是代码就越发显得丑陋，希望大家海涵哦

如果在下对于大佬的思路及其代码实现有什么误解的话，望大家包含并且斧正，希望大家NOIP2018 RP++！

谢谢观看

---

## 作者：Louis_1346 (赞：2)

### 思路

首先，我们非叶节点把 $0$ 多或者 $1$ 多看成一种状态。同时一个叶节点选 $0$ 选 $1$ 也看成一种状态，两者状态相同当且仅当其数值相同，否则状态不同。

首先，如果是两个叶子节点的权值是不好处理的，于是我们把两个叶子节点的权值拆成一个叶子节点对某一个 $lca$ 的贡献。

具体来说，如果叶子节点和一个非叶子节点的状态不同，那么就会使得 $k$ 多一，增加是这个节点到另一个非叶节点子树的全部叶子节点的权值。

一个叶子和其所有父亲节点状态不同，那么就会产生一定的费用。那么如果提前将其所有的父亲节点的状态提前预处理出来，那么这个节点的贡献就可以全部求出来了。

既然我们需要知道状态才能知道权值，那么我们不妨在设计 dp 的时候，在转移时同时枚举非叶子节点状态，然后再转移。

首先，有 $dp_{x,i}$ 表示 $x$ 节点，然后选了 $i$ 个 $0$ 号节点。那么转移就是。

$$
dp_{x,i} = \min_j dp_{ls_x,j}+dp_{rs_x,i-j}
$$

但是明显的，$i < \frac{sz_x}{2}$ 和 $i \ge \frac{sz_x}{2}$ 明显是不同的权值，于是我们需要分别枚举并且重新计算其子结构，意思就是说：第一种状态第一种转移，第二种状态第二种转移。


### code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long


const int maxn=4e3+10;

int res[maxn][maxn];

int dp[maxn][maxn];

pair<int,int> st[maxn];
int top;
int arr[maxn],c[maxn][2]; 
int get_da(int id,int l,int r){
	return res[id][r]-res[id][l-1];
} 
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)


void push_up(int x,int l,int r,int len){
	for(int i=0;i<=len;i++){
		for(int j=0;j<=len;j++){
			if(i+j>=l&&i+j<=r) dp[x][i+j]=min(dp[x][i+j],dp[ls(x)][i]+dp[rs(x)][j]);
		}
	}
}
void dfs(int x,int l,int r,int s,int de){
	int len=r-l+1;
	fill(dp[x],dp[x]+len+2,0x3f3f3f3f3f3f3f3f);
	if(l==r){
		dp[x][0]=c[l][0],dp[x][1]=c[l][1];
		for(int i=0;i<de;i++){
			int mid=(st[i].first+st[i].second)/2;
			if((s>>i)&1){
				if(l<=mid) dp[x][1]+=get_da(l,mid+1,st[i].second);
				else dp[x][1]+=get_da(l,st[i].first,mid);
			}else{
				if(l<=mid) dp[x][0]+=get_da(l,mid+1,st[i].second);
				else dp[x][0]+=get_da(l,st[i].first,mid); 
			}
		}
		return;
	} 
	st[de]=make_pair(l,r);
	int mid=(l+r)>>1;
	dfs(ls(x),l,mid,s^(1<<de),de+1);
	dfs(rs(x),mid+1,r,s^(1<<de),de+1);
	push_up(x,0,len/2-1,len/2);
	dfs(ls(x),l,mid,s,de+1);
	dfs(rs(x),mid+1,r,s,de+1);
	push_up(x,len/2,len,len/2);
}
signed main(){
	int n;
	scanf("%lld",&n);
	n=(1<<n);
	int a;
	for(int i=1;i<=n;i++){
		scanf("%lld",&arr[i]); 
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&a);
		c[i][arr[i]^1]=0,c[i][arr[i]]=a;
	}
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			scanf("%lld",&a);
			res[i][j]=res[j][i]=a;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) res[i][j]+=res[i][j-1];
	}
	dfs(1,1,n,0,0);
	int mn=0x3f3f3f3f3f3f3f3f;
	for(int i=0;i<=n;i++){
		mn=min(mn,dp[1][i]);
	}
	printf("%lld",mn);
	return 0;
}
```

---

## 作者：_lbw_ (赞：2)

萌萌 dp 题。

容易设出 $f_{i,n_a,n_b}$ 表示 $i$ 子树内，$na$ 个 $a$，$nb$ 个 $b$ 的方案，转移为 $f_{ls,ln_a,ln_b}+f_{rs,rn_a,rn_b}+w_i\to f_{i,ln_a+rn_a,ln_b+rn_b}$ 

考虑计算 $w_i$ ， 容易发现它只跟 $n_a,n_b$ 子树内的点色有关，于是将贡献拆到叶子节点上。

于是转移方程便变为了 $f_{ls,ln_a,ln_b}+f_{rs,rn_a,rn_b}\to f_{i,n_a=ln_a+rn_a,n_b=ln_b+rn_b}$  并且在递归计算时根据 $n_a<n_b$ 和 $n_a\geq n_b$ 分别计算。

于是 dp 部分结束，这样好像容易爆炸，考虑优化

首先发现 $n_b$ 其实不用记录，因为 $n_a+n_b=siz_i$

然后发现时间复杂度为 $T(n)=\mathcal{O}(n^2)+4T(\dfrac{n}{2})=\mathcal{O}(n^2)+4\mathcal{O}(\frac{n^2}4)+16\mathcal{O}(\frac{n^2}{16})+\dots=\mathcal{O}({n^2\log n})$

```cpp
const int maxn = 3e3+5;
IV cmin(ll&x,ll val){x>val?x=val,0:0;}
ll n,dp[maxn][maxn],F[maxn][maxn],A[maxn],C[2][maxn],S;bool vis[maxn];
I lca(ll x,ll y){D(i,n-1,0)if((x>>i)^(y>>i))return n-i-1;while(1)puts("???");return 0;}
#define ls (o<<1)
#define rs (o<<1|1)
IV dfs(ll o,ll dep,ll l,ll r){
	if(dep==n){
		dp[o][0]=C[0][o-S];dp[o][1]=C[1][o-S];
		F(i,0,dep-1)dp[o][vis[i]]+=F[o-S][i];return;
	}mem(dp[o],0x3f);ll mid=l+r>>1;vis[dep]=1;
	dfs(ls,dep+1,l,mid);dfs(rs,dep+1,mid+1,r);
	F(i,0,r-l+1)F(j,0,r-l+1-i)if(i+j<=r-l+1-i-j&&i<=mid-l+1&&j<=r-mid)cmin(dp[o][i+j],dp[ls][i]+dp[rs][j]);
	vis[dep]=0;dfs(ls,dep+1,l,mid);dfs(rs,dep+1,mid+1,r);
	F(i,0,r-l+1)F(j,0,r-l+1-i)if(i+j>r-l+1-i-j&&i<=mid-l+1&&j<=r-mid)cmin(dp[o][i+j],dp[ls][i]+dp[rs][j]);
}
int main(){
	n=read();S=1<<n;F(i,0,S-1)A[i]=read();
	F(i,0,S-1)C[A[i]^1][i]=read(),C[A[i]][i]=0;
	F(i,0,S-1)F(j,i+1,S-1){ll x=read();F[i][lca(i,j)]+=x;F[j][lca(i,j)]+=x;}
	dfs(1,0,1,S);ll ans=1e18;F(i,0,S)ans=min(ans,dp[1][i]);return cout<<ans,0;
}
```


---

## 作者：echo6342 (赞：2)

这么长的题目告诉我们一定要学好政治。


听上去好像费用流，然而……


收费方式看上去很复杂，实际上没有想象中那么复杂但是也很复杂，可以看成A少就收所有的A，B少就收所有的B。这样用前缀和就能解决收费的问题了。


根据N<10大概猜到应该是状压dp，进而猜出dp(x,y,z)表示到第x个点，有y个A（或y个B），且祖先的取舍方案为z的收费情况。


那么问题就来了：用dp[x][y][z]表示的话，空间总共要占(2^10)^3!这样空间肯定会出问题。能不能将其中两维合成一维呢？


经过一番不对劲的思考，发现每往下走一层，z就会增加一位，而y的最大值会减少一半。把这两维放在同一维似乎不错。


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstdlib>
#define maxm 5050
#define maxk 2050
using namespace std;
int dp[maxk][maxm],n,m,c[maxk],f[maxk][maxk];
int li[maxk],ri[maxk], ab[maxk];
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(isdigit(ch)==0 && ch!='-')ch=getchar();
    if(ch=='-')f=-1;
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int solve(int x,int y,int z,int l,int r,int lim)
{
    li[x]=l,ri[x]=r;
    int xi=x,xj=(z<<(lim+1))|y;
    if(dp[xi][xj]!=-1)
    {
        return dp[xi][xj];
    }
    if(x>=m)
    {
        int tab,now=x-m+1,sum=c[now]*(ab[now]!=y),lu,ru;
        for(int lstu=x,u=x>>1;u;lstu=u,u>>=1)
        {
            tab=z&1;
            z>>=1;
            lu=(lstu!=(u<<1))?li[u]:((li[u]+ri[u])>>1)+1;
            ru=(lstu!=(u<<1))?((li[u]+ri[u])>>1):ri[u];
            sum+=(f[now][ru]-f[now][lu-1])*(tab!=y);
        }
        dp[xi][xj]=sum;
        return sum;
    }
    else
    {
        int tmp=(z<<1)|(y>(1<<lim)-y),res=0x7fffffff,mi=(l+r)>>1,siz=1<<(lim-1);
        if(siz>y)siz=y;
        for(int p=y-siz;p<=siz;p++)
        {
            int t=solve(x<<1,p,tmp,l,mi,lim-1)+solve((x<<1)+1,y-p,tmp,mi+1,r,lim-1);
            res=min(res,t);
        }
        dp[xi][xj]=res;
        return res;
    }
}
int main()
{
    //cout<<"Boy_next_door is playing game."<<endl;
    n=read();
    m=1<<n;
    for(int i=1;i<=m;i++)
        ab[i]=read();
    for(int i=1;i<=m;i++)
        c[i]=read();
    for(int i=1;i<=m;i++)
        for(int j=i+1;j<=m;j++)
        {
            f[i][j]=read();
            f[j][i]=f[i][j];
        }
    memset(dp,-1,sizeof(dp));
    for(int i=1;i<=m;i++)
        for(int j=1;j<=m;j++)
            f[i][j]=f[i][j-1]+f[i][j];
    int ans=0x7fffffff;
    for(int i=0;i<=m;i++)
    {
        int tmp1=solve(1,i,0,1,m,n);
        ans=min(ans,tmp1);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4297)

#### 先观察题目性质
题目中有一张表。

这张表看起来十分玄学。如果真的分 $8$ 类讨论，这题的信息会显得很复杂，长得就不正经。这肯定不是出题人想让我们看到的样子。所以我们要进行观察，找到它比较简单的形式。

首先，我们发现，在 $A$ 和 $B$ 反过来之后，结果基本上是一样的，所以这个结论肯定比较对称。我们可以发现：如果定义 $A$ 和 $B$ 中比较少的那种（若相同则取 $B$）为“弱势群体”，那么 $A$ 和 $B$ 之间的付费系数就是其中“弱势群体”的数量。更简单一点说，只有某个范围内的“弱势群体”，才要对这个范围内的人付钱。

而这个范围是什么呢？我们发现每个非叶子节点的子树对应的都是一个长度为 $2^p$ 的区间，可以分为左右两个区间。左区间中的“弱势群体”要对右区间内的人付钱，右区间内的“弱势群体”要对左区间内的人付钱。

所以对于每个人 $u$，枚举 $u$ 的所有祖先，并且统计每个祖先对应的子树中的“弱势群体”，就可以计算出他的花费。我们因此知道：一个人的花费只与他自己的状态，以及他祖先的状态有关。

#### 单个元素贡献计算方法
对于单个元素，如果你知道了它的付费方式以及它祖先中的“弱势群体”，就可以计算出它对答案的贡献。这方面的计算方法比较多，估计大多数人都能独立想出一种，这里简略介绍一下我用的方法：

枚举它的每一个祖先（从根开始向下），倍增地维护一个 `pos` 变量，其中后面若干位为连续的 $0$。然后，根据这个元素位置 $i$，计算出 `(i-1)&(1<<k)`，即 $i$ 在长度为 `1<<k` 的区间中处于左边还是右边，然后维护前缀和，对于两种情况加上 $S_{pos+2k}-S_{pos+k}$ 和 $S_{pos+k}-S_{pos}$。具体见代码。

### 重点部分：优化枚举，是为 dp
我们知道，“枚举”这个思路肯定是行不通的。所以我们要尽量把枚举优化掉，例如使用dp。

>注：下面说的“节点”即树上的节点，“元素”特指用户，即叶节点

#### dp 的状态设计
我们会发现，对于树上的每个节点，我们要计算“弱势群体”，所以我们要知道这个子树中的 $A$ 或者 $B$ 元素的数量。另外，我们既然要知道每个叶子节点祖先的信息来计算这个节点的贡献，我们也要维护每个节点的祖先的“弱势群体”。

所以，我们可以用 $3$ 个维度表示一个状态：

+ 节点编号 $u$
+ 节点中 $A$（或 $B$）元素的个数 $c$
+ 节点每个祖先“弱势群体” $b$

其中，$b$ 可以用一个二进制整数状压表示。

#### dp 的转移
这个不用多说了吧…… 枚举左子树 $A$ 的数量 $i$，然后直接把左右子树的结果加起来取 $\min$ 即可。方程：
$$
dp_{u,c,b}=\min\{dp_{2u,i,2b+f},dp_{2u+1c-i,2b+f}\}
$$
其中 $f$ 是目前节点的“弱势群体”，取 $0$ 或 $1$（$0$ 和 $1$ 代表 $A$ 还是 $B$ 随意），可以由 $c$ 和区间长度计算出。

另外注意取值范围，如果 $c$ 比区间长度还大，那就是非法状态，直接判掉。

#### dp 的时间复杂度
我们知道，dp 的复杂度是状态的复杂度乘上转移的复杂度。所以我们从这个方面来分析这个 dp 的复杂度。

首先，这是一棵满二叉树，所以有 $O(n)$ 层，$O(2^n)$ 个节点，第 $i$ 层（根为 $0$）的节点有 $2^i$ 个，每个节点代表一个长度为 $2^{n-i}$ 的区间，每个元素的 $c$ 有 $O(2^{n-i})$ 种取值，$b$ 有 $2^i$ 种取值，即每个节点有 $O(2^n)$ 种状态。

考察转移，我们发现对于每一个状态的转移时间复杂度为 $O(c)$，可近似认为是长度。所以这个转移比较复杂，不同的节点转移复杂度不同。但是同一层节点转移复杂度相同。考察每一层，转移复杂度都是 $O(2^i \times 2^{n-i} \times 2^i)=O(4^n)$，其中左边第一项为这一层节点个数，第二项为转移复杂度，第三项为每个节点状态个数。三者相乘就是该层复杂度。又由于有 $O(n)$ 层，故复杂度为 $O(n \times 4^n)$。

#### dp 的空间复杂度
在传统的 dp 中，由于有 $3$ 维，所以我们用一个 $3$ 维数组来储存 dp 值。但是考虑这里的每一维，$u$ 取值范围为 $O(2^n)$，$b$ 和 $c$ 的取值上界都是 $O(2^n)$，所以总空间复杂度为 $O(8^n)$。这会 MLE。

但是我们发现，状态只有 $O(4^n)$ 种。事实上我们浪费了很多空间。我们可以采用以下策略：

1. 顶着巨大的常数，用 vector 储存 dp 数组。
2. 成为指针大佬，new 一个 dp 数组出来。
3. 用 map（可能会 TLE）或 Hash 表存 dp 值。
4. 观察到 $b$ 和 $c$ 的取值范围积固定，可以压在一起取新的一维。

这里推荐比较优的方法 4。

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1030;

int m,n,A[M],C[M];
int F[M][M],S[M][M];//S：前缀和数组

long long dp[M<<1][M<<1];
long long dfs(int L,int R,int A_cnt,int Ewraw,int u,int dep) {
//区间左端点，右端点，A个数，祖先状态，u编号，深度
	if(R-L+1 < A_cnt)return 1e18;
	long long &ret=dp[u][A_cnt<<dep|Ewraw];//压维
	if(ret != -1)return ret;//记忆化
	if(L == R) {//叶子结点特判，然后结束
		ret=0;
		int pos=0;
		for(int i=m-1; i>=0; i--) {//枚举每个祖先
			int k=1<<i,g=Ewraw & k;
			if((A_cnt<<i) != g) {//如果需要付钱
				if((L-1) & k)ret += S[L][pos+k] - S[L][pos];//在左边，对右边付钱
				else ret += S[L][pos+2*k] - S[L][pos+k];//在右边，对左边付钱
			}
			if((L-1) & k)pos+=k;//“倍增地”维护pos
		}
		if(A[L] == A_cnt)ret += C[L];//更改所需花费
		return ret;
	}
	int B_cnt=R-L+1-A_cnt,ew=(Ewraw<<1)|(A_cnt >= B_cnt),mid=(L+R)>>1;
	ret=1e18;
	for(int i=0; i<=A_cnt; i++)
		ret=min(ret,dfs(L,mid,i,ew,u<<1,dep+1)+dfs(mid+1,R,A_cnt-i,ew,u<<1|1,dep+1));//简单的转移
	return ret;
}

int main() {
	scanf("%d",&m);
	n=1<<m;
	for(int i=1; i<=n; i++)scanf("%d",&A[i]);
	for(int i=1; i<=n; i++)scanf("%d",&C[i]);
	for(int i=1; i<=n; i++)
		for(int j=i+1; j<=n; j++)
			scanf("%d",&F[i][j]),F[j][i]=F[i][j];
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			S[i][j]=S[i][j-1]+F[i][j];//预处理前缀和
	memset(dp,-1,sizeof(dp));
	long long ans=1e18;
	for(int i=0; i<=n; i++)ans=min(ans,dfs(1,n,i,0,1,0));
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：MutU (赞：1)

### [原题传送门](https://www.luogu.com.cn/problem/P4297)

题面给出的贡献计算方式过于复杂，显然一对对枚举点对不可行。

我们可以归纳这样一条性质：**若一个非叶子结点管辖的叶子结点中收费类型 A 多，则所有以这个点为 LCA 的叶子结点对中，每个收费类型为 B 的点都会产生一次贡献**，反之亦然。

并且每个叶子结点的祖先只可能出现在一条长度不超过 $n$ 的链上。对于某个叶子结点 $x$ 的某个祖先 $a$，满足 $lca_{x,y}=a$ 的其它叶子结点 $y$ 一定是连续的一段（可以画图理解一下）。于是，我们可以用前缀和很快地求出这一段合法结点到结点 $x$ 的流量之和。

考虑使用树形 dp 求解。设计状态 $f_{x,i}$ 表示若结点 $x$ 管辖的叶子结点中恰好存在 $i$ 个收费类型 A 的叶子结点所需要支付的最小金额。由于是满二叉树，所以可以采用类似线段树的遍历方法和递推方式。

我们可以认为每个非叶子结点都有一个 $0$ 或 $1$ 的状态，表示这个结点所管辖的叶子结点中哪一种收费方式多。由于每个叶子结点的贡献只与其上面的一条链相关，所以可以在遍历的过程中记录每个结点的状态。这条链很短，因此记录是很简单的。

这样这道题就结束了，细节见代码。


```cpp
//第一道黑题祭！！！！！！！ 
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 11;
const int maxn = (1<<N) + 10;
const int INF = 1e17;
bool op[maxn];
int n,dp[maxn][maxn],L[N+10],R[N+10],f[maxn][maxn],c[maxn],ans=INF;
inline void push_up(int x,int l,int r){ //向上传递状态 
	int lson=x*2,rson=x*2+1;
	for(int i=l;i<=r;i++){
		dp[x][i]=INF;
		for(int j=0;j<=i;j++){
			dp[x][i]=min(dp[x][i],dp[lson][j]+dp[rson][i-j]);
		}
	}
	return;
}
//类似线段树的遍历方式 
inline void dfs(int l,int r,int x,int bit/*采用状压的方式*/,int dep){
	if(l==r){
		dp[x][1]=dp[x][0]=0;
		if(op[l]) dp[x][1]=c[l];
		else dp[x][0]=c[l];
		for(int i=1;i<dep;i++){
			int mid=L[i]+R[i]>>1;
			if((bit>>(dep-1-i)) & 1){ 
				if(l<=mid) dp[x][0]+=f[l][R[i]]-f[l][mid];
				else dp[x][0]+=f[l][mid]-f[l][L[i]-1];
			}else{
				if(l<=mid) dp[x][1]+=f[l][R[i]]-f[l][mid];
				else dp[x][1]+=f[l][mid]-f[l][L[i]-1];
			}
		}
		return;
	}
	L[dep]=l,R[dep]=r;
	int mid=(l+r)>>1,lson=x*2,rson=x*2+1,len=r-l+1;
	//枚举当前结点的状态 
	dfs(l,mid,lson,(bit<<1),dep+1);
	dfs(mid+1,r,rson,(bit<<1),dep+1);
	push_up(x,0,len/2-1);
	dfs(l,mid,lson,(bit<<1)|1,dep+1);
	dfs(mid+1,r,rson,(bit<<1)|1,dep+1);
	push_up(x,len/2,len);
}
inline void init(){
	for(int i=1;i<maxn;i++)for(int j=0;j<maxn;j++)dp[i][j]=INF;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n;
	n=(1<<n);
	for(int i=1;i<=n;i++) cin>>op[i];
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			cin>>f[i][j];
			f[j][i]=f[i][j];
		}
		for(int j=1;j<=n;j++) f[i][j]+=f[i][j-1]; //前缀和 
	}
	init();
	dfs(1,n,1,0,1);
	for(int i=0;i<=n;i++) ans=min(ans,dp[1][i]);
	cout<<ans;
	return 0;
}
//第一道黑题祭！！！！！！！ 
```

---

## 作者：zeroy0410 (赞：1)

#### 题目

网络已经成为当今世界不可或缺的一部分。每天都有数以亿计的人使用网络进行学习、科研、娱乐等活动。然而，不可忽视的一点就是网络本身有着庞大的运行费用。所以，向使用网络的人进行适当的收费是必须的，也是合理的。MY 市NS中学就有着这样一个教育网络。网络中的用户一共有$2N$个，编号依次为$1,2,3,?,2N$。这些用户之间是用路由点和网线组成的。用户、路由点与网线共同构成一个满二叉树结构。树中的每一个叶子结点都是一个用户，每一个非叶子结点（灰色）都是一个路由点，而每一条边都是一条网线（见下图，用户结点中的数字为其编号）。

#### 思路

首先将贡献分开来看，先考虑$nA<nB$的情况。在这种情况下，如果选$A$对系数的贡献就是1，选$B$就是0。另一种情况反之。这样就把点对的信息压缩到了一个叶子结点上。

用$C[f][i]$表示$i$这个结点变成$f$所需要的代价。（$f$为0表示选$A$，$f$为1表示选$B$）

用$F[i][dep]$表示$i$这个结点参与的点对中$lca$的深度为$dep$的方案数。

$dp[i][j]$表示$i$这棵子树，有$j$个点选了$B$类的花费值。



考虑边界情况：初始的$dp[x][f]$=转变的花费(C)+当前$x$结点与其他点组成点对的花费。

现在还剩一个细节：当前点究竟是$nA<nB$还是$nA>=nB$。

这时就应该“钦定”当前结点的状态，强行决定这个点是哪种情况，然后再把不合法的情况判掉就行了。

具体到dp框架中就是，开一个$vis$数组，用于记录当前结点究竟属于上面的哪一种情况。

$vis[dep]=1$表示当前子树情况为前者，反之为后者。

那么当处理到了叶子结点的时候，就可以根据vis数组来判断$F$数组应该加到哪一边了。

#### 代码

```cpp
#include<bits/stdc++.h>
#define M 3005
#define LL long long
#define YDAK 0 
using namespace std;
int A[M],n;
LL C[2][M],F[M][15],dp[M][M];
bool vis[M];
int lca(int a,int b){//lca的深度 
	for(int i=n-1;i>=0;i--)
		if((a>>i)!=(b>>i))return n-i-1;
	return YDAK;//不加会吃警告 
}
void dfs(int x,int dep,int l,int r){
	if(dep==n){
		dp[x][0]=C[0][x-(1<<n)];
		dp[x][1]=C[1][x-(1<<n)];
		for(int i=0;i<dep;i++)
			dp[x][vis[i]]+=F[x-(1<<n)][i];
		return;
	}
	memset(dp[x],0x3f,sizeof(dp[x]));
	int mid=(l+r)>>1;
	vis[dep]=1;
	dfs(x<<1,dep+1,l,mid);dfs(x<<1|1,dep+1,mid+1,r);
	for(int i=0;i<=r-l+1;i++)
		for(int j=0;i+j<=r-l+1;j++)
			if(i+j<=r-l+1-i-j&&i<=mid-l+1&&j<=r-mid)dp[x][i+j]=min(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);	
	vis[dep]=0;
	dfs(x<<1,dep+1,l,mid);dfs(x<<1|1,dep+1,mid+1,r);
	for(int i=0;i<=r-l+1;i++)
		for(int j=0;i+j<=r-l+1;j++)
			if(i+j>r-l+1-i-j&&i<=mid-l+1&&j<=r-mid)dp[x][i+j]=min(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
}
int main(){
	cin>>n;
	for(int i=0;i<=(1<<n)-1;i++)scanf("%d",&A[i]);
	for(int i=0;i<=(1<<n)-1;i++)scanf("%lld",&C[A[i]^1][i]),C[A[i]][i]=0;
	for(int i=0,v;i<=(1<<n)-1;i++){
		for(int j=i+1;j<=(1<<n)-1;j++){
			scanf("%d",&v);
			F[i][lca(i,j)]+=v;
			F[j][lca(i,j)]+=v;
		}
	}
	dfs(1,0,1,(1<<n));
	LL ans=1e18;
	for(int i=0;i<=(1<<n);i++)ans=min(ans,dp[1][i]); 
	printf("%lld\n",ans); 
	return 0;
}
```










---

## 作者：yzq_yzq (赞：0)

挺神奇的题，努力理清一下思路。

观察一下贡献的形式，令 $s_{u,i}$ 为 $\sum\limits_{lca(i,j)=u} f_{i,j}$ ，称 $nA_u\ge nB_u$ 为 $u$ 点的方式为 A，否则为 B。

不难发现 $s_{u,i}$ 对于答案有贡献只有 $i$ 用户的方式跟点 $u$ 的方式不同。

考虑直接树上 dp，但是发现并不好做，因为我们无法确定每个点上的方案是 A 还是 B。

注意题目是个完全二叉树保证了树高，那么假如我们在 dp 点 $u$ ，不难发现只有 $1$ 到 $u$ 的路径上的点是未确定方案且转移时需要的，于是我们可以枚一下路径上点的方案。

接着定义 $dp_{u,i,S}$ 为 $u$ 点子树中选 $i$ 个 B，路径方案钦定为 $S$ 的最小费用，在转移时限定一下 $i$ 与 $len-i$ 的大小关系来保证 $u$ 点的方案与 $S$ 相符，其中 $len$ 为 $u$ 子树中有多少个用户。

注意到 $S$ 这一维与转移基本是无关的，直接递归的时候枚举就行了，递归的复杂度 $T(n)=4T(\frac n 2)+n^2$，$T(n)=n^2\log n$。带入原题的 $n$ ，总复杂度是 $n2^{2n}$ 的。

有不懂的可以看代码，代码写的很简明：

```cpp
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = (x); i <= (y); ++i)
#define drep(i, x, y) for (int i = (x); i >= (y); --i)
#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;
template <typename T> inline void cmin(T &x, T y) { if(x > y) x = y; }
int main() {
	fastio; int n, m; cin >> n, m = 1 << n;
	vector<int> a(m); for(int &x : a) cin >> x;
	vector<int> c(m); for(int &x : c) cin >> x;
	vector<vector<int> > s(m * 2 + 1, vector<int>(m * 2 + 1)), dp = s;
	const auto lca = [&](int x, int y) { while(x != y) x >>= 1, y >>= 1; return x; };
	rep(i, 0, m - 1) {
		rep(j, i + 1, m - 1) {
			int x; cin >> x;
			int u = lca(i + m, j + m);
			s[u][i] += x, s[u][j] += x;
		}
	}
	function<void(int, int, int, int)> dfs = [&](int p, int l, int r, int S) -> void {
		if(l == r) {
			dp[p][a[l]] = 0, dp[p][a[l] ^ 1] = c[l];
			rep(i, 1, n) dp[p][(S >> i - 1 & 1 ? 0 : 1)] += s[p >> i][l]; return;
		} int mid = (l + r) >> 1, len = r - l + 1; len >>= 1;
		const auto DFS = [&](int o) { int X = (S << 1) | o; dfs(p << 1, l, mid, X), dfs(p << 1 | 1, mid + 1, r, X); };
		const auto DP = [&](int x) { dp[p][x] = 1e9; rep(i, 0, min(x, len)) if(x - i <= len) cmin(dp[p][x], dp[p << 1][i] + dp[p << 1 | 1][x - i]); };
		DFS(0); rep(i, 0, len) DP(i); DFS(1); rep(i, len + 1, (len << 1)) DP(i);
	};
	dfs(1, 0, m - 1, 0); int res = 1e9;
	rep(i, 0, m) cmin(res, dp[1][i]);
	return cout << res << '\n', 0;
}
```

---

## 作者：Gold_Dino (赞：0)

首先观察表格，发现一个点的收费只和它的收费方式以及它每个祖先 $nA$ 与 $nB$ 的大小有关

具体的，叶子节点 $u$ 在祖先 $f$ 收费，必定有 $u$ 用 $A$ 收费且 $nA_f<nB_f$，或 $u$ 用 $B$ 收费且 $nA_f\ge nB_f$

因为整棵树深度是 $\Theta(n)$ 的，状压到根路径上每个点 $nA$ 与 $nB$ 大小关系，还要记录子树中选择 $A$ 的个数，决策左子树选了多少 $A$

用 $f_{u,s,a}$ 表示节点 $u$，祖先状态 $s$，子树中有 $a$ 个 $A$

令 $ns$ 表示在原先集合 $s$ 上增加 $u$ 点 $nA$ 和 $nB$ 的大小关系

$$f_{u,s,a}=\min_{i=0}^{a}f_{ls,ns,i}f_{rs,ns,a-i}$$
对于叶子节点，枚举它每个祖先处理边界

由于对于每个点，合法的 $(s,a)$ 个数是 $\Theta(2^n)$ 的，故时间为 $\Theta(4^n)$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ris(i,a,b) for(int i=a;i<=b;++i)
#define dro(i,a,b) for(int i=a;i>=b;--i)
#define ckmin(a,b) (a=min(a,b))
const int N=4107;
int n,C[1035],F[1035][1035],A[1035];
int dp[2059][N],ans=INT_MAX;
bool vis[2059][N];int dis[2059][15];
#define ls (v<<1)
#define rs (v<<1|1)
#define mid ((l+r)>>1)
int f(int v,int s,int a,int l,int r,int d){
    if(a>r-l+1) return -1;
    int id=s*(r-l+2)+a;
    if(vis[v][id]) return dp[v][id];
    vis[v][id]=1;
    dp[v][id]=-1;
    if(l==r){
        dp[v][id]=(a!=A[l])*C[l];
        int t=v;
        dro(i,n-1,0){
            t>>=1;
            int x=(s>>i)&1;
            dp[v][id]+=(a!=x)*dis[v][n-i-1];
        }
        return dp[v][id];
    }
    int ns=s|((int)(a>=r-l+1-a)<<(d-1));
    ris(i,0,a){
        int tls=f(ls,ns,i,l,mid,d+1),trs=f(rs,ns,a-i,mid+1,r,d+1);
        if(tls!=-1&&trs!=-1)
            if(tls+trs<dp[v][id]||dp[v][id]==-1)
                dp[v][id]=tls+trs;
    }
    return dp[v][id];
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    cin>>n;
    ris(i,1,1<<n) cin>>A[i],A[i]=!A[i];
    ris(i,1,1<<n) cin>>C[i];
    ris(i,1,1<<n)
        ris(j,1,(1<<n)-i){
            int u=i+(1<<n)-1,v=j+(1<<n)-1+i,cnt=0;
            cin>>F[i][j];
            int x=u>>1,y=v>>1;
            while(x!=y) x>>=1,y>>=1,cnt++;
            dis[u][cnt]+=F[i][j],dis[v][cnt]+=F[i][j];
        }
    ris(i,0,1<<n){
        int t=f(1,0,i,1,1<<n,1);
        if(t!=-1) ckmin(ans,t);
    }
    printf("%lld",ans);
    return 0;
}

```


---

## 作者：7KByte (赞：0)

DP 神题。

首先观察表格，发现异色的点对无论如何都会产生 $f$ 的贡献，同色的点对当且仅当该颜色不是它们 $\rm LCA$ 管辖子树中出现次数最多的颜色时，才会产生 $2f$ 的贡献。

由于贡献只有 $0,f,2f$ 的区别，所以我们不难想到，如果我们固定一个路由器的颜色为 $c$，那么对于子树中所有叶子，如果颜色和 $c$ 相同，则不产生贡献，否则产生 $\frac{size}{2}\times f$ 的贡献，其中 $size$ 为子树中的叶子总数。

所以一个叶子的贡献只与它到根路径上所有点的颜色有关，路由器的颜色指子树中出现次数最多的颜色。

试着动态规划，设计状态 $f[i][j]$ 表示子树 $i$ 中有 $j$ 个 $1$ 的最优值，但是这玩意转移后根本不优，因为子树中某个点可能当前没有贡献，但是在某个祖先节点产生大量贡献。并且我们不知道这 $j$ 个节点的流量之和。

做到这里就自闭了，翻了下题解发现做法太妙了。

传统的树形 DP 都是以子树为状态，本题是完全二叉树，所以深度很小，所以我们可以对当前节点到根的路径进行状态压缩。定义 $f[i][j][k]$ 表示节点 $i$ 的子树中，选了 $j$ 个 $1$，且 $i$ 到根节点的状态为 $k$ 的最优值。

我们发现深度每增加 $1$ ，$k$ 的规模 $\times 2$，而 $j$ 的规模 $/2$，所以 $j \times k$ 的规模始终是 $\mathcal{O}(N)$ 级别的。所以直接 DP 时间复杂度是 $\mathcal{O}(N^2\log N)$ 的，空间是 $\mathcal{O}(N^3)$ ，将 $j$ 和 $k$ 压缩到一起空间就 $\mathcal{O}(N^2)$ 了，可以通过本题。

还有更好写的方法，直接将 $k$ 作为参数在递归时传递即可，这样也可以保证不重复计算，时间复杂度时 $\mathcal{O}(N^2\log N)$，空间复杂度 $\mathcal{O}(N^2)$ 。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 1030
using namespace std;
int n,c[N],w[N],u[N],f[N << 1][N],s[N][N];
#define ls (x<<1)
#define rs (ls|1)
void solve(int x,int l,int r,int dep,int S){
	if(l == r){
		f[x][u[l]] = 0;
		f[x][u[l] ^ 1] = c[l];
		int L = l,R = r,len = 1,y = x;
		rep(i, 0, dep - 1){
			int op = 1 ^ (1 & S);
			if(y & 1)f[x][op] += s[l][L - 1] - s[l][L - len - 1], L -= len;
			else f[x][op] += s[l][R + len] - s[l][R], R += len;
			len <<= 1, y >>= 1;S >>= 1;
		}
		return ;
	}
	int mid = (l + r) >> 1,len = r - mid;
	rep(i, 0, r - l + 1)f[x][i] = 0x3f3f3f3f;
	solve(ls, l, mid, dep + 1 , S << 1);
	solve(rs, mid + 1, r, dep + 1, S << 1);
	rep(p, 0, len)rep(q, 0, len - p)
		f[x][p + q] = min(f[x][p + q], f[ls][p] + f[rs][q]);
	solve(ls, l, mid, dep + 1 , 1 + (S << 1));
	solve(rs, mid + 1, r, dep + 1, 1 + (S << 1));
	rep(p, 0, len)rep(q, len + 1 - p, len)
		f[x][p + q] = min(f[x][p + q], f[ls][p] + f[rs][q]);
}
int main(){
	scanf("%d",&n);
	n = 1 << n;
	rep(i, 1, n)scanf("%d",&u[i]);
	rep(i, 1, n)scanf("%d",&c[i]);
	rep(i, 1, n)rep(j, i + 1, n){
		int x;scanf("%d",&x);
		s[i][j] += x;s[j][i] += x;
	}
	rep(i, 1, n)rep(j, 1, n)s[i][j] += s[i][j - 1];
	solve(1, 1, n, 0, 0);
	int mn = 0x7fffffff;
	rep(i, 0, n)mn = min(mn, f[1][i]);
	printf("%d\n",mn);return 0;
}
```

---


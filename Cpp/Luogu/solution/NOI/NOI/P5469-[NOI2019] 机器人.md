# [NOI2019] 机器人

## 题目背景

时限 3 秒，内存 512MB

## 题目描述

小 R 喜欢研究机器人。

最近，小 R 新研制出了两种机器人，分别是 `P` 型机器人和 `Q` 型机器人。现在他要测试这两种机器人的移动能力，测试在从左到右排成一排的 $n$ 个柱子上进行，柱子用$1 - n$ 依次编号，$i$ 号柱子的高度为一个正整数 $h_i$。机器人**只能在相邻柱子间移动**，即：若机器人当前在 $i$ 号柱子上，它只能尝试移动到 $i - 1$ 号和 $i + 1$ 号柱子上。

每次测试，小 R 会选取一个起点 $s$，并将两种机器人均放置在 $s$ 号柱子上。随后它们会按自己的规则移动。

`P` 型机器人会一直**向左**移动，但它**无法**移动到比起点 $s$ **更高**的柱子上。更具体地，`P` 型机器人在 $l (l \leq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：

- $l = 1$ 或 $h_{l-1} > h_s$。

- 对于满足 $l \leq j \leq s$ 的 $j$，有 $h_j \leq h_s$。

`Q` 型机器人会一直**向右**移动，但它**只能**移动到比起点 $s$ **更低**的柱子上。更具体地，`Q` 型机器人在 $r (r \geq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：

- $r = n$ 或 $h_{r+1} \geq h_s$。

- 对于满足 $s < j \leq r$ 的 $j$，有 $h_j < h_s$。

现在，小 R 可以设置每根柱子的高度，$i$ 号柱子可选择的高度范围为 $[A_i, B_i]$，即$A_i \leq h_i \leq B_i$。小 R 希望**无论**测试的起点 $s$ 选在哪里，两种机器人移动过的柱子数量的差的绝对值都**小于等于**$2$。他想知道有多少种柱子高度的设置方案满足要求，小 R 认为两种方案不同当且仅当存在一个 $k$，使得两种方案中 $k$ 号柱子的高度不同。请你告诉他满足要求的方案数模 $10^9 + 7$ 后的结果。

## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件的 `robot/robot2.in` 与 `robot/robot2.ans`。

#### 样例 3

见附加文件的 `robot/robot3.in` 与 `robot/robot3.ans`。

#### 样例 4

见附加文件的 `robot/robot4.in` 与 `robot/robot4.ans`。

### 样例 1 解释

柱子高度共两种情况：

- 高度为：`3 2 3 2 3`。此时若起点设置在 $5$，`P` 型机器人将停在 $1$ 号柱子，共移动$4$ 个柱子。`Q` 型机器人停在 $5$ 号柱子，共移动 $0$ 个柱子，不符合条件。

- 高度为：`3 2 4 2 3`。此时无论起点选在哪，都满足条件，具体见下表：

::cute-table{tuack}

| 起点编号 | P 型机器人 | Q 型机器人 |
| :----------: | :----------: | :----------: |
| $1$ | 停在 $1$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $1$ 个 |
| $2$ | 停在 $2$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $0$ 个 |
| $3$ | 停在 $1$ 号柱子，移动过 $2$ 个 |停在 $5$ 号柱子，移动过 $2$ 个  |
| $4$ | 停在 $4$ 号柱子，移动过 $0$ 个 | 停在 $4$ 号柱子，移动过 $0$ 个 |
| $5$ |停在 $4$ 号柱子，移动过 $1$ 个  | 停在 $5$ 号柱子，移动过 $0$ 个 |

### 数据范围

对于所有测试数据：$1 \leq n \leq 300$ , $1 \leq A_i \leq B_i \leq 10^9$。

每个测试点的具体限制见下表：

::cute-table{tuack}

| 测试点编号 | $n\le$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1,2$ | $7$ | $A_i=B_i,B_i\le 7$ |
| $3,4$ | $7$ | $B_i\le 7$ |
| $5,6,7$ | $50$ | $B_i\le 100$ |
| $8,9,10$ | $300$ | $B_i\le 10^4$ |
| $11,12$ | $50$ | $A_i=1,B_i=10^9$ |
| $13,14,15$ | $50$ | 无 |
| $16,17$ | $150$ | ^ |
| $18,19$ | $200$ | ^ |
| $20$ | $300$ | ^ |

## 样例 #1

### 输入

```
5
3 3
3 3
3 4
2 2
3 3```

### 输出

```
1```

# 题解

## 作者：E_huan (赞：24)

这题耗费我一个下午加半个晚上加小半个早上，作此题解以记之。

如果有什么写错的地方还请神犇们不吝赐教，拜谢！


## 拉格朗日插值优化 DP

#### 朴素 DP + 前缀和优化

本身 DP 就比较巧妙，枚举最大值的位置进行区间 DP，利用了最大值左边的区间和最大值右边的区间互不影响的性质（如果有多个最大值就选取最右边的，这样就保证了其左右两段一定互不干涉）。加上前缀和优化可以达到 $O(n^3w)$。状态表示：$f[l][r][k]$ 表示在区间 $[l,r]$ 中，最大值与下限的差不超过 $k$ 的方案数。转移就是枚举最大值的位置。转移方程：$f[l][r][k]= \sum \limits_{l \le i \le r} {f[l][i-1][k] \times f[i+1][r][k-1]}$。解释一下为什么是 $f[i+1][r][k-1]$，因为 DP 中的“最大值”就是最靠右的最大值，所以整区间最大值右边的区间的最大值一定比整区间最大值 $k$ 小（而左区间的最大值可以为 $k$)。


#### 利用有效段较少进行优化

原本 $O(n^3w)$ 中有 $O(n^2)$ 是枚举区间，但其实合法的区间数很少。可以预处理合法区间数进行 DP，记合法区间数为 $m$，打表发现 $m$ 其实最多也就 $2500$ 左右。状态表示：$f[i][k]$ 表示第 $i$ 个合法段，最大值和下限的差值不超过 $k$ 的方案数。对于所有区间按照长度排序，使长度单调不减，保证所有区间的子区间都在其之前被求出结果。转移方程变为：$f[id[l][r]][k]= \sum \limits_{l \le i \le r且左右区间均合法} {f[id[[l][i-1]][k] \times f[id[i+1][r]][k-1]}$。时间复杂度 $O(nmw)$。但是这个 DP 的复杂度仍然不可接受，原因在于需要在值域范围枚举，而本题值域 $w$ 很大。

#### 拉格朗日插值优化

仍然是状态表示：$f[i][k]$ 表示第 $i$ 个合法段，最大值和下限的差值不超过 $k$ 的方案数。我们发现函数 $f[i]$ 为关于 $k$ 的 $n$ 次多项式（长度为 $1$ 的区间的 $f[i][k]$ 是关于 $k$ 的一次式，再根据转移方程，$f[i][k]$ 这个关于 $k$ 的函数的次数就是区间 $i$ 的长度，最长的区间长度也就是 $n$ 了），可以先求出 $n+1$ 项的值，再用拉格朗日插值求出其它位置的值。由于下标是连续的，拉格朗日插值可以做到 $O(n)$（简单的说：原本的 $x_i$ 是连续的（就是 $[1,n+1]$），带入 $x=len$ 后仍然是连续的数。公式 $ \sum\limits_{1 \le i \le n}{y_i \times \prod\limits_{1 \le j \le n}^{j \neq i}{\frac{x-x_j}{x_i-x_j}}}$ 的右半部分（即 $\prod\limits_{1 \le j \le n}^{j \neq i}{\frac{x-x_j}{x_i-x_j}}$）的分子分母其实都是一段连乘积挖去一个数，也可以理解成两端连乘积相乘，那么就可以通过预处理前后缀积来实现 $O(1)$ 求乘积，$O(n)$ 求 $n$ 个乘积式的和，具体实现见代码）。

如果区间长度超过 $n+1$，就先将前 $n+1$ 项 DP 求出，后面部分插值求，否则直接 DP 求。

（注：这里提到的“段”指的是将所有上下界排序之后，相邻两个值之间的段。且上下界在读入的时候已经转化成左闭右开的形式，保证了每个连续段 DP 的正确性。记区间长度 $r-l$ 为 $len$。 ）
第 $i$ 段的答案理论上应该是 $f[i][len]$，当长度超过 $n+1$ 的时候就是这个函数在 $x=len$ 的时候的值。
每次把答案存在 $f[i][0]$ 里，因为这一段所有合法的情况不会影响下一段的求解，根据乘法原理，答案就是每段（“段”是指值域段，不是区间）结果相乘，这里直接用前一段结果作为后一段的起点，实际上就是乘法原理。（也就是说，在第 $i$ 段 DP 结束之后，$f[i][0]$ 存的是前 $i$ 段答案之积）。
最终答案就是 $f[id[1][n]][0]$ 啦。时间复杂度 $O(n^2m)$。

#### 代码实现（一些注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int res=0; bool f=0;
    char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) res=res*10+(ch^'0'),ch=getchar();
    return f?-res:res;
}
const int N=605,mod=1000000007;
struct node{
    int l,r;
    bool operator<(const node &t)const{return r-l<t.r-t.l;}
}p[3030];
int n,tot,id[N][N],a[N],b[N];
int fac[N],inv[N];
inline int qmi(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%mod;
        x=1ll*x*x%mod;
        y>>=1;
    }
    return res;
}
void init(int n)//预处理阶乘和逆元
{
    fac[0]=inv[0]=1;
    for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=qmi(fac[n],mod-2);
    for(int i=n-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
}
inline void add(int &x,int y)
{
    x+=y;
    if(x>=mod) x-=mod;
}
void dfs(int l,int r)//预处理合法区间
{
    if(id[l][r]||l>r) return;
    id[l][r]=++tot;
    p[tot]={l,r};
    for(int i=l;i<=r;i++)//枚举分界线   
        if(abs((i-l)-(r-i))<=2)
            dfs(l,i-1),dfs(i+1,r);
}
int num[N],cnt;
void read_and_change()
{
    for(int i=1;i<=n;i++)
    {
        num[++cnt]=a[i]=read();
        num[++cnt]=b[i]=read()+1;//左闭右开 后面方便
    }
    sort(num+1,num+cnt+1);
    cnt=unique(num+1,num+cnt+1)-num-1;
    for(int i=1;i<=n;i++)
    {
        a[i]=lower_bound(num+1,num+cnt+1,a[i])-num;
        b[i]=lower_bound(num+1,num+cnt+1,b[i])-num;
    }
}
int f[3030][N],pre[N],suf[N];
inline void lag(int l,int r,int len)
{
    if(len<=n+1) 
    {
        for(int i=1;i<=tot;i++) f[i][0]=f[i][len];
        return;
    }
    for(int i=1;i<=tot;i++) f[i][0]=0;
    pre[0]=suf[n+2]=1;//pre、suf就是把带入len之后的式子的分子前后缀前
    for(int i=1;i<=n+1;i++) pre[i]=1ll*pre[i-1]*((len-i+mod)%mod)%mod;
    for(int i=n+1;i>=1;i--) suf[i]=1ll*suf[i+1]*((len-i+mod)%mod)%mod;
    for(int i=1;i<=n+1;i++)
    {
        int val=1ll*pre[i-1]*suf[i+1]%mod/*分子*/*inv[n+1-i]%mod*inv[i-1]%mod/*分母*/*(((n+1-i)&1)?mod-1:1)%mod/*分母的符号*/;
        for(int j=1;j<=tot;j++)
            add(f[j][0],1ll*val*f[j][i]%mod);
    }
}
int main()
{
    n=read();
    init(n+5);
    dfs(1,n); sort(p+1,p+tot+1);
    read_and_change();//读入并离散化
    for(int i=0;i<=n+1;i++) f[0][i]=1;
    for(int t=1;t<cnt;t++)
    {
        int len=min(n+1,num[t+1]-num[t]);
        for(int i=1;i<=tot;i++)
        {
            int l=p[i].l,r=p[i].r;
            for(int j=l;j<=r;j++)
                if(abs((j-l)-(r-j))<=2&&t>=a[j]&&t<b[j])
                    for(int k=1;k<=len;k++)
                        add(f[id[l][r]][k],1ll*f[id[l][j-1]][k]*f[id[j+1][r]][k-1]%mod);
                        //最初的DP中的“最大值”就是最靠右的最大值，所以右区间的最大值一定比k小(j位置是k)
            for(int k=1;k<=len;k++) 
                add(f[id[l][r]][k],f[id[l][r]][k-1]);//前缀和优化
        }
        lag(num[t],num[t+1],num[t+1]-num[t]);
        for(int i=1;i<=tot;i++)
            for(int j=1;j<=len;j++)
                f[i][j]=0;
    }
    printf("%d\n",f[id[1][n]][0]);
    return 0;
}
```

---

## 作者：suncongbo (赞：18)

既然这题没题解那我就发一个吧，讲得不清楚请见谅

膜拜当场A掉的巨佬(我是NOI Cu滚粗狗)

欢迎移步https://www.cnblogs.com/suncongbo/p/11217236.html

首先我们考虑，一个序列位置最右边的最大值可以走遍整个序列，并且其余任何点都不能跨过这个位置。

所以我们可以区间dp, $dp[l][r][x]$表示区间$[l,r]$最大值不超过$x$的方案数，枚举最大值点$mid$及其值$k$, $dp[l][r][x]=\sum_{mid}\sum_{k}dp[l][mid-1][k]\times dp[mid+1][r][k-1]$, 也可以设$dp[l][r][x]$表示区间$[l,r]$的最大值恰好为$x$的方案数，枚举最大值点$mid$则有$dp[l][r][x]=\sum_{mid}\sum_{k\le x}dp[l][mid-1][k]\sum_{k<x}dp[mid+1][r][k]$.

可获得$35$分，当然如果你有梦想数组开大点卡卡常就有$50$分了。（然而我在考场上没梦想$35$分滚粗了）

然后正解的话，恰好为$x$那种状态比较好。

首先离散化，那么我们发现当$k$在每一段区间内时，转移是类似的。

一个结论是，当$k$在某一段区间内时$dp[l][r][k]$是关于$k$的不超过$(r-l)$次多项式。

证明: 首先$l=r$时显然是$0$次多项式，当$l<r$时，我们枚举$mid$然后左边有一个$mid-1-l$次多项式右边有一个$r-mid-1$次多项式，又因为转移要对左右两边多项式做前缀和再相乘(这个具体见下一段)，所以次数要$+1$($k$次多项式的前缀和是$(k+1)$次多项式)，所以总次数为$(mid-1-l+1)+(r-mid-1+1)=r-l$.

这里解释一下如何转移: $dp[l][r][x]$, 左右两边分开考虑，考虑现在枚举的$k$, 假设$k$在$x$区间前面的区间里，那么这个值与$x$区间内的自变量无关了，变成了“常数”(因为这个区间所包含的数无论如何都比自变量小)，而这个“常数”的值就是$dp[l][r][k']$ ($k'$为$k$所在的区间)这个多项式在每个$k'$区间内的点的点值之和，把这个值加到$dp[l][r][x]$多项式的常数项里。

假设$k$在$x$区间里，那么新的多项式直接就等于这个多项式在区间内的小于等于自变量的前缀和(如果现在枚举的是左边)，或者多项式在区间内小于自变量的前缀和(如果现在枚举的是右边)。

于是记忆化搜索一波，使用多项式前缀和进行转移，这样枚举$mid$之后复杂度为多项式次数的平方。

多项式前缀和需要预处理$s_k(x)=\sum^{x}_{i=0}x^k$, 这是一个$(k+1)$次多项式，所以Lagrange插值求出来系数。据说有其他的搞法，但是我只能想到这一种。

裸做$80$分起步(我裸做了一波得了$85$)

剪枝优化可获得$100$分。

好难写啊，我好菜啊……

### 代码
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<vector>
#include<algorithm>
#define llong long long
using namespace std;

const int P = 1e9+7;
const int N = 301;

llong quickpow(llong x,llong y)
{
	llong cur = x,ret = 1ll;
	for(int i=0; y; i++)
	{
		if(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}
		cur = cur*cur%P;
	}
	return ret;
}
llong mulinv(llong x) {return quickpow(x,P-2);}

llong aux[N+4],aux2[N+4];
struct Polynomial
{
	vector<llong> a; int n;
	Polynomial() {}
	Polynomial(int _n) {n = _n; for(int i=0; i<=n; i++) a.push_back(0ll);}
	void clear() {n = 0; a.clear(); a.push_back(0ll);}
	void output() {printf("deg%d, ",n); for(int i=0; i<=n; i++) printf("%lld ",a[i]); puts("");}
	Polynomial operator +(Polynomial &arg) const
	{
		Polynomial ret(max(n,arg.n));
		for(int i=0; i<=min(n,arg.n); i++)
		{
			ret.a[i] = (a[i]+arg.a[i])%P;
		}
		for(int i=min(n,arg.n)+1; i<=n; i++) ret.a[i] = a[i];
		for(int i=min(n,arg.n)+1; i<=arg.n; i++) ret.a[i] = arg.a[i];
		return ret;
	}
	Polynomial operator -(Polynomial &arg) const
	{
		Polynomial ret(max(n,arg.n));
		for(int i=0; i<=min(n,arg.n); i++)
		{
			ret.a[i] = (a[i]-arg.a[i]+P)%P;
		}
		for(int i=min(n,arg.n)+1; i<=n; i++) ret.a[i] = a[i];
		for(int i=min(n,arg.n)+1; i<=arg.n; i++) ret.a[i] = P-arg.a[i];
		return ret;
	}
	Polynomial operator *(Polynomial &arg) const
	{
		Polynomial ret(n+arg.n);
		for(int i=0; i<=n; i++)
		{
			for(int j=0; j<=arg.n; j++)
			{
				ret.a[i+j] = (ret.a[i+j]+a[i]*arg.a[j])%P;
			}
		}
		return ret;
	}
	llong calc(llong x)
	{
		llong ret = 0ll;
		for(int i=n; i>=0; i--)
		{
			ret = (ret*x+a[i])%P;
		}
		return ret;
	}
	void interpoly(int _n,llong ax[],llong ay[])
	{
		n = _n; for(int i=0; i<=n; i++) a.push_back(0ll);
		for(int i=0; i<=n+1; i++) aux[i] = 0ll;
		aux[0] = 1ll;
		for(int i=0; i<=n; i++)
		{
			for(int j=i+1; j>0; j--)
			{
				aux[j] = (aux[j-1]-aux[j]*ax[i]%P+P)%P;
			}
			aux[0] = P-aux[0]*ax[i]%P;
		}
		for(int i=0; i<=n; i++)
		{
			llong tmp = 1ll;
			for(int j=0; j<=n; j++)
			{
				if(i==j) continue;
				tmp = tmp*(ax[i]-ax[j]+P)%P;
			}
			llong coe = mulinv(tmp);
			for(int j=n+1; j>=0; j--) {aux2[j] = aux[j];}
			for(int j=n; j>=0; j--)
			{
				a[j] = (a[j]+aux2[j+1]*coe%P*ay[i])%P;
				aux2[j] = (aux2[j]+ax[i]*aux2[j+1])%P;
			}
		}
	}
};
Polynomial tmp1,tmp2,tmp3;
Polynomial dp[2661][(N<<1)+3],sdp[2661][(N<<1)+3];
llong lval[2661][(N<<1)+3],rval[2661][(N<<1)+3];
int dpid[N+4][N+4];
Polynomial spw[N+4];
struct Interval
{
	llong lb,rb; //[1,2n]
} a[N+3];
vector<llong> disc;
llong spwx[N+3],spwy[N+3];
int mx[N+3][N+3];
int n,nsta;
llong ans;

int getid(llong x) {return lower_bound(disc.begin(),disc.end(),x)-disc.begin();} //no +1

Polynomial prefixsum(Polynomial poly)
{
	Polynomial ret(poly.n+1);
	for(int i=0; i<=poly.n; i++)
	{
		for(int j=0; j<=i+1; j++)
		{
			ret.a[j] = (ret.a[j]+poly.a[i]*spw[i].a[j])%P;
		}
	}
	return ret;
}

void dfs(int l,int r,int x)
{
	Polynomial tmp1,tmp2,tmp3;
	if(dpid[l][r] && dp[dpid[l][r]][x].a.size()>0) {return;}
	if(!dpid[l][r]) {nsta++; dpid[l][r] = nsta;}
	if(l==r)
	{
		if(!dpid[l][r]) {nsta++; dpid[l][r] = nsta;}
		dp[dpid[l][r]][x] = Polynomial(0); dp[dpid[l][r]][x].a[0] = (x>=a[l].lb&&x<=a[l].rb) ? 1ll : 0ll;
		sdp[dpid[l][r]][x] = prefixsum(dp[dpid[l][r]][x]);
		lval[dpid[l][r]][x] = sdp[dpid[l][r]][x].calc(disc[x-1]);
		rval[dpid[l][r]][x] = sdp[dpid[l][r]][x].calc(disc[x]);
		return;
	}
	dp[dpid[l][r]][x].clear(); sdp[dpid[l][r]][x].clear();
	if(mx[l][r]>x) return;
	for(int lenl=(r-l+1)>>1; lenl<=(r-l+1)+1-((r-l+1)>>1); lenl++)
	{
		int mid = l+lenl-1;
		if(!(x>=a[mid].lb && x<=a[mid].rb)) {continue;} //注意此处要特判
		tmp1.clear(); tmp2.clear();
		if(mid>l)
		{
			for(int k=1; k<=x; k++)
			{
				dfs(l,mid-1,k);
				if(k<x)
				{
					tmp1.a[0] = (tmp1.a[0]+rval[dpid[l][mid-1]][k]-lval[dpid[l][mid-1]][k]+P)%P;
				}
				else
				{
					tmp1 = tmp1+sdp[dpid[l][mid-1]][k];
					tmp1.a[0] = (tmp1.a[0]-lval[dpid[l][mid-1]][k]+P)%P;
				}
			}
		}
		else
		{
			tmp1 = Polynomial(0); tmp1.a[0] = 1ll;
		}
		if(mid<r)
		{
			for(int k=0; k<=x; k++)
			{
				dfs(mid+1,r,k);
				if(k<x)
				{
					tmp2.a[0] = (tmp2.a[0]+rval[dpid[mid+1][r]][k]-lval[dpid[mid+1][r]][k]+P)%P;
				}
				else
				{
					tmp2 = tmp2+sdp[dpid[mid+1][r]][k];
					tmp2 = tmp2-dp[dpid[mid+1][r]][k];
					tmp2.a[0] = (tmp2.a[0]-lval[dpid[mid+1][r]][k]+P)%P;
				}
			}
		}
		else
		{
			tmp2 = Polynomial(0); tmp2.a[0] = 1ll;
		}
		tmp3 = tmp1*tmp2;
		dp[dpid[l][r]][x] = dp[dpid[l][r]][x]+tmp3;
	}
	sdp[dpid[l][r]][x] = prefixsum(dp[dpid[l][r]][x]);
	lval[dpid[l][r]][x] = sdp[dpid[l][r]][x].calc(disc[x-1]);
	rval[dpid[l][r]][x] = sdp[dpid[l][r]][x].calc(disc[x]);
}

int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {scanf("%lld%lld",&a[i].lb,&a[i].rb); disc.push_back(a[i].lb-1); disc.push_back(a[i].rb);}
	for(int i=0; i<=n; i++)
	{
		spwx[0] = 0ll; spwy[0] = 0ll;
		for(int j=1; j<=i+1; j++)
		{
			spwx[j] = j;
			spwy[j] = (spwy[j-1]+quickpow(j,i))%P;
		}
		spw[i].interpoly(i+1,spwx,spwy);
	}
	sort(disc.begin(),disc.end()); disc.erase(unique(disc.begin(),disc.end()),disc.end());
	for(int i=1; i<=n; i++) {a[i].lb = getid(a[i].lb); a[i].rb = getid(a[i].rb);}
	nsta = 1; for(int i=0; i<disc.size(); i++)
	{
		dp[1][i] = Polynomial(0); dp[1][i].a[0] = 1ll;
		sdp[1][i] = prefixsum(dp[1][i]);
		lval[1][i] = sdp[1][i].calc(disc[i-1]);
		rval[1][i] = sdp[1][i].calc(disc[i]);
	}
	for(int i=1; i<=n; i++)
	{
		mx[i][i] = a[i].lb;
		for(int j=i+1; j<=n; j++)
		{
			mx[i][j] = max(mx[i][j-1],(int)a[j].lb);
		}
	}
	ans = 0ll;
	for(int i=1; i<disc.size(); i++)
	{
		dfs(1,n,i);
		ans = (ans+sdp[dpid[1][n]][i].calc(disc[i])-sdp[dpid[1][n]][i].calc(disc[i-1])+P)%P;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Soulist (赞：15)

这是一个复杂度应该是假的的做法，跑得极其吃力...不过出题人没有认真的去卡？

我们先观察这个机器人的移动规则，发现最大值几乎是可以遍历整个区间的。事实上，最右边的最大值确实可以遍历整个区间的，同时其余最大值均不可以。

这个最大值会将区间划分为两边，两边都是子问题，所以我们可以考虑用区间 dp 来计算答案。

设 $f_{l,r,k}$ 表示区间 $[l,r]$ 的最大值为 $k$ 的方案数，转移枚举偏中间的一个点满足往左和往右的差值不超过 $2$，则有 $f_{l,r,k}=(\sum_{u\le k}f_{l,mid-1,u})\times (\sum_{u<k}f_{mid+1,r,u})$

看着复杂度非常的 $\mathcal O(n^2w)$，然而写个记忆化搜索会发现由于题目性质有效的区间数仅为 $2100$ 左右，所以大概可以当作 $\mathcal O(2000w)$。

值域很大肯定不好处理，将每个 $[A_i,B_i]$ 拆成 $[l,r),[r,r')...$ 这样的区间处理，同一段区间内的转移相似，在 $l=r$ 时均有 $f_{l,r,k}=1$，每次转移将跨段的区间视为常数，如果将同段的 $f_{l,r,x}$ 视为关于 $x$ 的多项式，那么同段的转移是一个计算前缀和并将点值分开乘起来的过程，容易发现区间 $f_{l,r}$ 的次幂不超过 $r-l$

然后我们可以考虑大暴力，对于离散化得到的 $2n$ 个区间，都拿出来跑一边 dp，对于每个区间 $[l,r]$ 直接维护 $n$ 个 dp 值作为点值，转移结束后直接用点值做前缀和，由于区间总数为 $2000$，这一部分的运算效率大概是 $\mathcal O(2000n)$，需要计算 $2n$ 次，复杂度大概是 $\mathcal O(K\cdot n^2),K=4000$

然后有点信仰，在值域较小的时候跑暴力，你就能获得 $95$ 的高分。

然后直接维护 $n$ 个点值实在是太暴力了，仍然是题目性质，大部分的区间其实长度都很小，我们考虑利用一下区间 $[l,r]$ 是关于区间的 $r-l$ 次幂的多项式这个性质。

考虑对区间 $[l,r]$ 维护 $r-l$ 个点值，但是转移需要更多的点值，这不好处理（当然可以直接暴力插值）

一个更方便的做法是，对于区间 $[l,r]$ 我们考虑维护一个次幂为 $r-l$ 的下降幂多项式，但是转移的时候如果使用暴力卷积感觉上~~就很难写~~很慢，所以在进行转移的时候我们使用点值来处理即可。

这意味着我们需要这个区间的 $2(r-l)$ 个点值，下降幂多项式转点值是非常方便的，我们直接乘以 $e^x$ 然后乘一下阶乘即可，还原也非常简单。这一部分对于每个区间暴力做的复杂度是 $\mathcal O(|\rm len|^2)$，总体复杂度是 $\mathcal O(\sum |\rm len|^2)$

实际上搜出来的 $\sum \rm |len|^2$ 是 $\rm 50W$ 左右，所以有点信仰，卡一下常数（主要是在占复杂度转点值和点值转系数时减少取模次数），然后在评测机好一点的时候大胆的提交，就可以过了。

复杂度是 $\mathcal O(n\sum |\rm len|^2)$ 的。

当然，在区间长度较小的时候通过下降幂来通过较少的点值计算系数然后得到更多的点值是比较优的，不过当 $\rm len>\sqrt{n}$ 时这个就不是非常必要了，可以考虑设置一个阈值比如 $30\sim 50$，当长度大于它的时候就直接算出 $n$ 个点值，之后就不需要做 dft 和 idft 了。

不过没有这样剪枝也过了？...

$Code:$

```cpp
//代码有亿点丑
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define pb push_back
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 300 + 5 ; 
const int V = 1500 + 5 ; 
const int P = 1e9 + 7 ; 
int n, D, dx, top, m, fac[V], inv[V], finv[V], A[N], B[N], K[V], st[V], vis[N][N] ; 
int cnt, op, Dp[2205][V], Id[N][N] ;
long long ffS, iv[V] ; 
struct node {
	int x, y ; 
} qwq[V] ;
vector<int> dp[2005] ; 
int abc( int x ) {
	return ( x > 0 ) ? x : -x ; 
}
void inc( int &x, int y ) {
	( ( x += y ) >= P ) && ( x -= P ) ; 
}
int fpow( int x, int k ) {
	int ans = 1, base = x ; 
	while(k) {
		if( k & 1 ) ans = 1ll * ans * base % P ; 
		base = 1ll * base * base % P, k >>= 1 ; 
	} return ans ; 
}
int Lag( int u, int x, int tp ) {
	int fp = 1, ans = 0 ; 
	for( re int i = 0; i < tp; ++ i ) {
		ans = ( ans + 1ll * fp * dp[u][i] % P ) % P,
		fp = 1ll * fp * ( x - i ) % P ; 
	} return ans ; 
}
int ffp[V], Ex[V], cnt ; 
inline void dft( int u ) {
	int l = dp[u].size(), le = l + 6 ;
	for( re int i = 0; i < l + le; ++ i )
	for( re int j = 0; j <= i && j < l; ++ j ) {
		Ex[i] += dp[u][j] * inv[i - j] % P, ++ cnt ; 
	}
	dp[u].resize(l + l + 5) ;
	for( re int i = 0; i < dp[u].size(); ++ i ) dp[u][i] = Ex[i] % P * fac[i] % P ;
	for( re int i = 0; i < l + le; ++ i ) Ex[i] = 0 ; 
} 
inline void idft( int u ) {
	int l = dp[u].size() ; 
	for( re int i = 0; i < l; ++ i ) dp[u][i] = dp[u][i] * inv[i] % P ; 
	for( re int i = 0; i < l; ++ i )
	for( re int j = 0; j <= i; ++ j ) 
		inc( Ex[i], dp[u][j] * finv[i - j] % P ), ++ cnt ; 
	for( re int i = 0; i < l; ++ i ) dp[u][i] = Ex[i] ;
	for( re int i = 0; i < l; ++ i ) Ex[i] = 0 ; 
}
void dfs( int l, int r, int L, int R ) {
	if( l > r || vis[l][r] == op ) return ;
	int ft = R - L + 1 ;
	vis[l][r] = op ; int u = Id[l][r] ; 
	int lx = max( l, ( r + l - 2 ) / 2 ), rx = min( r, ( r + l + 2 ) / 2 ) ; 
	dp[u].clear() ; 
	if( l == r ) {
		dp[u].pb(Dp[u][op - 1]) ; int ff = 0 ; 
		if( A[l] <= L && R <= B[l] ) dp[u].pb(1), ++ ff ; 
		Dp[u][op] = Lag(u, ft, ff + 1 ), dft(u) ; 
		dp[u].resize(2 * (r - l) + 4) ; 
		return ; 
	}
	dp[u].resize(r - l + 3) ; 
	for( re int i = lx; i <= rx; ++ i ) {
		int ll = i - l, rr = r - i ;
		if( abc(rr - ll) > 2 ) continue ;
		dfs( l, i - 1, L, R ), dfs( i + 1, r, L, R ) ; 
		if( A[i] > L || B[i] < R ) continue ;
		if( i == l ) 
			for( re int j = 1; j <= r - l + 2; ++ j ) 
				inc( dp[u][j], dp[Id[i + 1][r]][j - 1] ) ; 
		else if( i == r ) 
			for( re int j = 1; j <= r - l + 2; ++ j ) 
				inc( dp[u][j], dp[Id[l][i - 1]][j] ) ; 
		else 
			for( re int j = 1; j <= r - l + 2; ++ j )
				inc( dp[u][j], 1ll * dp[Id[l][i - 1]][j] * dp[Id[i + 1][r]][j - 1] % P ) ; 
	}
	for( re int i = 1; i <= r - l + 2; ++ i ) inc( dp[u][i], dp[u][i - 1] ) ; 
	for( re int i = 0; i <= r - l + 2; ++ i ) inc( dp[u][i], Dp[u][op - 1] ) ; 
	dp[u].resize(r - l + 2), idft(u) ; 
	Dp[u][op] = Lag(u, ft, r - l + 2), dft(u) ; 
	dp[u].resize(2 * (r - l) + 4) ; 
}
void Dfs( int l, int r ) {
	if( l > r || Id[l][r] ) return ;
	Id[l][r] = ++ cnt ; if( l == r ) return ; 
	int lx = max( l, ( r + l - 2 ) / 2 ), rx = min( r, ( r + l + 2 ) / 2 ) ;
	for( re int i = lx; i <= rx; ++ i ) {
		int ll = i - l, rr = r - i ;
		if( abc(rr - ll) > 2 ) continue ;
		Dfs( l, i - 1 ) ; Dfs( i + 1, r ) ; 
	}
}
signed main()
{
	n = gi(), D = n + 50 ; fac[0] = inv[0] = iv[0] = 1 ; 
	rep( i, 1, n ) A[i] = gi(), B[i] = gi(), K[++ top] = A[i], K[++ top] = B[i] + 1 ; 
	rep( i, 1, D ) fac[i] = 1ll * fac[i - 1] * i % P, inv[i] = fpow( fac[i], P - 2 ) ; 
	rep( i, 1, D ) iv[i] = fpow( i, P - 2 ) ; 
	rep( i, 0, D ) finv[i] = (i & 1) ? P - inv[i] : inv[i] ; 
	sort( K + 1, K + top + 1 ) ; 
	m = top, top = 0 ; 
	rep( i, 1, m ) if( K[i] != K[i - 1] ) st[++ top] = K[i] ; 
	Dfs( 1, n ) ;
	for( re int i = 2; i <= top; ++ i )
		op = i, dx = min( D, st[i] - st[i - 1] ), dfs( 1, n, st[i - 1], st[i] - 1 ) ;
	printf("%lld\n", Dp[Id[1][n]][op] % P ) ; 
	cerr << cnt << endl ; 
	return 0 ;
}
```






---

## 作者：Vision271 (赞：10)

#### 本篇题解没有直接给出正解思路，而是一步步按部分分走向正解。不喜欢这种方式的，建议移步其他题解。

### 解析
#### 0.题意分析
* 乍一看也没什么，但若以普遍理性而论，我们可以假设存在一个全局最高点。

* 如果最高点有多个，我们取最靠右的一个（因为向左右限制不同）。

* 能够看出，这个最高点（称为 $mid$，下同）可以走到 $1/n$，且其左右两边的区间互相走不到。

* 稍微手推一下可以发现，分奇偶讨论之后合法的 $mid$ 不超过 $3$ 个，而且在区间的中位数左右。

* 我会分治！区间 $[l,r]$ 合法=有合法 $mid$ +左区间合法+右区间合法。

* 联系一下数据范围。~~我会爆搜！~~

#### 1.dp 设计
* 令 $\mathit{dp}_ {l,r,mx}$ 表示区间 $[l,r]$ 的最大值**不超过** $mx$ 的总方案数，定义 $M=\max_{i=1}^nB_i$，则所求答案即为 $\mathit{dp}_ {1,n,M}$。

* 推一下转移式。$\mathit{dp}_ {l,r,mx}=\dots$ 额好像很难推，我们用一个辅助状态来推一下试试。

* 定义 $\mathit{tp}_ {l,r,mx}$ 为区间 $[l,r]$ 的最大值**恰好**为 $mx$ 的方案数。

* 那么对于一个 $\mathit{tp}_ {l,r,mx}$，感性理解一下，它的方案数应当等于每种拆分（每种 $mid$，注意此时的 $a_{mid}=mx$）下左右两遍区间的合法方案数乘积。

* 形式化如下：
$$\mathit{tp}_ {l,r,mx}=\sum\limits_{mid\in[l,r]\ that\ \operatorname{abs}((mid-l)-(r-mid))\leqslant 2} (\sum\limits_{i=1}^{mx} \mathit{tp}_ {l,mid-1,i}) \times (\sum\limits_{i=1}^{mx-1} \mathit{tp}_ {mid+1,r,i})\quad (1)$$

* 稍微观察实际意义，可以发现上式等价于
$$\mathit{tp}_ {l,r,mx}=\sum\limits_{mid} \mathit{dp}_ {l,mid-1,mx} \times \mathit{dp}_ {mid+1,r,mx-1}\quad (2)$$

* 尝试把式左化成 $\mathit{dp}_ {l,r,mx}$：
$$\mathit{dp}_ {l,r,mx}=\sum\limits_{i=1}^{mx} \sum\limits_{mid}(\mathit{dp}_ {l,mid-1,i} \times \mathit{dp}_ {mid+1,r,i-1)}\quad (3)$$

* 把两个 $\sum$ 换位：
$$\mathit{dp}_ {l,r,mx}=\sum\limits_{mid}\sum\limits_{i=1}^{\min(mx,B_{mid})}(\mathit{dp}_ {l,mid-1,i}\times \mathit{dp}_ {mid+1,r,i-1)}\quad (4)$$

* 好像我们走远了。$(4)$ 式看起来并不好转移，$(3)$ 式也一样（固然可以前缀和优化，但我倾向于下面这种方式）。

* 从定义出发：$\mathit{dp}_ {l,r,mx}= \sum\limits_{i=1}^{mx} \mathit{tp}_ {l,r,i}$。

* 我们用方便转移的 $(2)$ 式来转移罢。按区间转移，转移完毕后进行前缀和。

* 现在回过头来考虑我们的初始化问题。

* 对于 $l=r$ 的区间，显然 $\mathit{tp}_ {l,r,A_i\sim B_i}=1$，转化成 $dp$ 不难。

* 实际写的时候会发现，对于非常短的区间（如 $len=2,3$），它的 $mid$ 可能是它某一侧的端点，导致它拆出了 $l>r$ 的区间（称为虚区间，下同）。

* 这种情况下，其实另一侧的区间的方案数就是这种拆分对整体的总方案数的贡献。所以虚区间的 $\mathit{tp}_ {l,r,0\sim M}=1$。注意，是从 $0$ 开始，因为可能有区间最大值为 $1$ 然后 $mid$ 在右端点的情况，这可能是合法的。

* 复杂度：状态数 $n^2$（按区间来转移），单次转移 $O(M)$，共计 $O(n^2M)$。

* 对于 $50$ 分部分的数据 $\approx9\times 10^8$，不太能接受。考虑一下上面说的 $mid$ 选择很有限的限制，容易看出区间其实很稀疏。记搜实现或预处理出所有区间，记区间数为 $m$，打表可得 $m\leqslant 2518$，$O(mM)$ 完全能过。

#### 2.dp 优化
* 好像转移式本身已经到极限了，我们也使用了正确的 dp 实现方式。下一步优化在哪里？

* 观察到这里有 10 分的数据中 $A_i,B_i$ 完全一样，同时 $1\times 10^9$ 的范围算是让我们死了继续暴力 dp $mx$ 这一维的心。

* 考虑把 $\mathit{dp}_ {1,n,M}$ 的转移式展开，我们知道展开后形式完全一样（因为各个点 $B_i$ 都一样，枚举的范围没有区别）。做过【APIO2016】划艇的同学应该看到这个数据就想到正解了。

* 大胆猜测，这是个 $n$ 次左右的多项式！我们可以暴力 dp 出 $mx=1\sim n+(\approx10)$ 项，然后拉格朗日插值法！

* 思路一下就打开了啊朋友们。

* 考虑存下所有的“dp 转移变化点”。容易看出这些点应该是 $A_i$ 和 $B_i+1$，排序并去重（该数组记为 $key$）之后我们就得到了一系列左闭右开区间 $[key_i,key_{i+1})$，区间内部的转移逻辑是完全一样的！

* 考虑模仿【NOI2020】美食家（因为我其实没打过划艇），连续段加速，断点暴力 dp！

* 算一下复杂度。大概 $2n$ 段，dp 部分每段大约 $O(mn)$，拉插每段要插 $n$ 次，单次 $n^2$，总计 $O(n^2\times (m+n^2))$，完全没救。

* 我会优化！参考 CF622F The Sum of the k-th Powers，拉插在对应的 $x_i$ 取值连续时分母为阶乘，分子可做前后缀积。

* 而我们 dp 的那段刚好是连续的！乱搞把分母的逆元预处理出来，我们就可以 $O(n)$ 插值了。

* $O(n^2\times (m+n))$，大约 $2\times 10^8$。等等，$2\times 10^8$？

* 对于本做法，本题**非常卡常！** 据说（小小声）正解的前缀和部分要用下降幂，可惜这是 NOI+ 考点…额好吧就是我不会…

* 卡常技巧：
	* 保证拉插不带对分母求逆元的 $\log$。
    
	* $usek=n+1$。（我不会证这是 $n$ 次多项式，请移步其他题解）
    
   * 拆 `%mod`，尽量少取模。
   
   * 对区间长度是否需要插分类讨论。

### 示范代码

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
#define b_s basic_string
#define For(i,a,b) for(re int i=(a);i<=(b);++i)
#define foR(i,a,b) for(re int i=(a);i>=(b);--i)
#define uint unsigned int
#define ll long long
#define ull unsigned long long
using namespace std;
il void rd(int &x){
	x=0;bool f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=0;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	x=f?x:-x;
	return;
}

const int maxn=307,maxm=2608;//maxm是最大区间数
const ll mod=1e9+7;
int n;
int A[307],B[307];

il ll qpow(ll x,ll t){
	int ret=1;
	while(t){
		if(t&1) ret=ret*x%mod;
		x=x*x%mod;
		t>>=1;
	}
	return ret;
}
il int inv(int x){return qpow(x,mod-2);}

int id[maxn][maxn],toti;//0就是区间不存在 
il bool ok(int l,int mid,int r){return abs((mid-l)-(r-mid))<=2;}
il void sinte(int l,int r){//本函数是用于区间初始化的递归函数。 
	if(id[l][r]) return;
	id[l][r]=++toti;
	if(l>=r) return;
	For(mid,l,r)
		if(ok(l,mid,r))
			sinte(l,mid-1),sinte(mid+1,r);
}

int key[607],totk;
ll invfact[307];
int usek;
il void init(){//本函数负责读入，并参与到区间初始化和拉插初始化中。
	rd(n); usek=n+1;
	For(i,1,n){
		rd(A[i],B[i]);
		key[++totk]=A[i],key[++totk]=B[i]+1;//A[i]是到这里就变，B[i]是下一个才变。我们希望key里面存的每一个都是变的点，这样一来我们就可以取出左闭右开区间。 
	}
	sort(key+1,key+1+totk);
	totk=unique(key+1,key+1+totk)-key-1;//去重后结果。 
	
	sinte(1,n);
	
	invfact[0]=1;
	For(i,1,usek) invfact[i]=invfact[i-1]*inv(i)%mod;
}

int L,R,S,N;//当前考虑的闭区间的左右端点，该区间长度，计划中要dp出的长度 
ll dp[maxn][maxm]; bitset<maxm> vis;//该区间是否在本轮dp中访问过 
//dp[mx][now]表示第now个区间的最大值不超过mx的方案数。定义tp[mx][now]表示恰好为的方案数。
//对于非初始区间(r>l): 
//因为我们在dfs内实际上是逐个区间转移，我们可以先这样转移：dp(实为tp)[mx][now]=∑mid [ (∑i=0~mx tp[i][left])*(∑i=0~mx-1 tp[i][right]) ]=∑mid (dp[mx][left]*dp[mx-1][right]) 
//然后我们对dp前缀和，因为dp[mx][now]=∑i=1~mx tp[i][now]。不用关心i=0，因为对于非初始区间那里一定是0(A[i]>=1)(更实质地，只有虚区间会用到那个) 
il void dfs(int l,int r){
	re int now=id[l][r]; if(vis[now]) return; vis[now]=1;
	if(l>r){
		For(i,0,N) 
			dp[i][now]=1; 
		return;
	}
	if(l==r){
		if(A[l]<=L && R<=B[l])
			For(i,1,N) 
				dp[i][now]=1;
	}
	if(l<r){
		For(mid,l,r)
			if(ok(l,mid,r)){
				dfs(l,mid-1); dfs(mid+1,r);
				if(A[mid]<=L && R<=B[mid])
					For(i,1,N) 
						dp[i][now]=(dp[i][now] + dp[i][id[l][mid-1]] * dp[i-1][id[mid+1][r]]) % mod;
			}
	}
	For(i,1,N){
		dp[i][now]=dp[i-1][now]+dp[i][now];
		if(dp[i][now]>=mod) dp[i][now]-=mod;
	}
	return;
}

ll son[maxn],sonqian[maxn],sonhou[maxn];
ll mu[maxn],invmu[maxn];
il void work(){
	for(re int i=1;i<totk;++i){
		L=key[i],R=key[i+1]-1,S=R-L+1;
		if(S<=usek){
			N=S;
			dfs(1,n);
			For(i,1,toti) dp[0][i]=dp[N][i];//每次都把上一段的结果放在0处，此时的1就代表L，相当于平移了整个dp数组 
		}
		else{
			N=usek;
			dfs(1,n);
			//首先我们处理分子 son 及其前后缀积。  拉插的代入值 x 应当为区间末端 R 。 
			sonqian[0]=sonhou[usek+1]=1; 
			For(j,1,usek){//因为这里1代表L，所以rj(j为1~usek的任意值)=j+L-1
				son[j]=S-j;//实际的式子是son[j]=R-rj=R-L+1-j=S-j，由else知S>usek>=j，所以不用判负，而且 R<=1e9 ，所以也不用模 
				sonqian[j]=sonqian[j-1]*son[j]%mod;
			}
			foR(j,usek,1) sonhou[j]=sonhou[j+1]*son[j]%mod;
			
			//然后我们来处理分母
			For(i,1,usek){
				if(((usek-i)&1)==0) invmu[i]=invfact[i-1]*invfact[usek-i]%mod;
				else invmu[i]=mod-invfact[i-1]*invfact[usek-i]%mod;
			} 
			
			for(re int i=1;i<=usek;++i){
				ll fenzi=sonqian[i-1]*sonhou[i+1]%mod;
				ll xishu=fenzi*invmu[i]%mod;
				For(now,1,toti)//暂时放在这里
					dp[N+1][now]=(dp[N+1][now]+xishu*dp[i][now])%mod;
			}

			For(now,1,toti) dp[0][now]=dp[N+1][now],dp[N+1][now]=0;
		}
		vis.reset();
		For(i,1,N)
			For(j,1,toti)
				dp[i][j]=0;//清空dp。
	}
}

int main(){
	init();
	work();
	wt(dp[0][1]);
	return 0;
}
```

---

## 作者：FunnyCreatress (赞：7)

首先我们发现，一个方案是可行的当且仅当以下条件成立：

- 全局最后一个最高点距离中点的距离不超过 $1$。
- 该点左边和右边的区间都可行。

因此，我们找到了一个很简单的 DP 式子：
$$f_{l,r,x}=\left\{\begin{array}{l}[a_{m-1}\le x\le b_{m-1}]\sum_{i=1}^xf_{l,m-2,i}\sum_{i=1}^{x-1}f_{m,r,i}+[a_{m}\le x\le b_{m}]\sum_{i=1}^xf_{l,m-1,i}\sum_{i=1}^{x-1}f_{m+1,r,i}+[a_{m+1}\le x\le b_{m+1}]\sum_{i=1}^xf_{l,m,i}\sum_{i=1}^{x-1}f_{m+2,r,i},&len\%2=1\\ [a_{m}\le x\le b_{m}]\sum_{i=1}^xf_{l,m-1,i}\sum_{i=1}^{x-1}f_{m+1,r,i}+[a_{m+1}\le x\le b_{m+1}]\sum_{i=1}^xf_{l,m,i}\sum_{i=1}^{x-1}f_{m+2,r,i},&len\%2=0\end{array}\right.$$

其中 $m=\lfloor\frac{l+r}2\rfloor,len=r-l+1$

~~啊啊啊公式太长了，看不清的话可以看博客~~

最后只要统计 $\sum_if_{1,n,i}$ 即可，复杂度 $O(AM)$ ($M$ 是有效的区间数，大约是 $n\log n$ 的样子，不过不会证)。

然后考虑优化这个暴力 DP。注意到每个区间的 $f_{l,r,x}$ 是关于 $x$ 的一个分段多项式函数，且次数不超过 $r-l+2$，段数不超过 $2(r-l+1)$，所以可以直接用这个优化。

对一个多项式需要维护的操作有：相加，相乘，保留一段区间的定义，向右平移一单位，做前缀和。连 FFT 啥的都不需要，暴力就可以过。关于这个前缀和操作，有个经典结论就是自然数的 $k$ 次方和可以表示为一个 $k+1$ 次的多项式，预处理系数即可。复杂度不会分析，应该不会超过 $O(n^3\log n)$，可以通过

码量略大，注意细节，否则可能会T。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=305,P=1e9+7,INF=1e9+500;
int n,a[N],b[N],bn[N<<1][N<<1],fact[N],invf[N],invp[N];bool vst[N][N];
struct polyn{
	int m,l,r;vector<int> a;
	void init(int len){
		for(int i=0;i<a.size();i++)a[i]=0;
		for(int i=a.size();i<len;i++)a.push_back(0);
		m=len;
	}
	polyn fix(int nl,int nr){polyn res;res.init(m);res.l=nl,res.r=nr;for(int i=0;i<m;i++)res.a[i]=a[i];return res;}
	polyn operator*(polyn f){
		polyn res;res.init(m+f.m-1);res.l=max(l,f.l),res.r=min(r,f.r);
		for(int i=0;i<m;i++)
			for(int j=0;j<f.m;j++)
				res.a[i+j]=(res.a[i+j]+1ll*a[i]*f.a[j])%P;
		return res;
	}
	polyn operator+(polyn f){
		polyn res;res.init(max(m,f.m));res.l=max(l,f.l),res.r=min(r,f.r);
		for(int i=0;i<m;i++)res.a[i]=a[i];
		for(int i=0;i<f.m;i++){res.a[i]+=f.a[i];if(res.a[i]>=P)res.a[i]-=P;}
		return res;
	}
	polyn prefsum(){
		polyn res;res.init(m+1);res.l=l,res.r=r;
		for(int i=0;i<m;i++)
			for(int j=0;j<=i+1;j++)res.a[j]=(res.a[j]+1ll*a[i]*bn[i][j])%P;
		int fl=0;
		for(int i=m;i>=0;i--)fl=(1ll*fl*(l-1)+res.a[i])%P;
		res.a[0]=(res.a[0]+P-fl)%P;
		return res;
	}
	int sum(int x){int fr=0;for(int i=m-1;i>=0;i--)fr=(1ll*fr*x+a[i])%P;return fr;}
	polyn trans(){
		polyn res;res.init(m);res.l=l+1,res.r=min(r+1,INF);
		for(int i=0;i<m;i++)
			for(int j=0;j<=i;j++)res.a[j]=(res.a[j]+1ll*(i-j&1?P-a[i]:a[i])*fact[i]%P*invf[j]%P*invf[i-j])%P;
		return res;
	}
};
struct polyset{
	int cnt;vector<polyn> v;
	polyset operator+(polyset f){
		polyset res;res.cnt=0;
		for(int i=0,j=0;i<cnt;i++){
			while(j<f.cnt&&f.v[j].r<=v[i].r)res.v.push_back(f.v[j]+v[i]),res.cnt++,j++;
			if(j<f.cnt&&f.v[j].l<=v[i].r)res.v.push_back(f.v[j]+v[i]),res.cnt++;
		}
		return res;
	}
	polyset operator*(polyset f){
		polyset res;res.cnt=0;
		for(int i=0,j=0;i<cnt;i++){
			while(j<f.cnt&&f.v[j].r<=v[i].r)res.v.push_back(f.v[j]*v[i]),res.cnt++,j++;
			if(j<f.cnt&&f.v[j].l<=v[i].r)res.v.push_back(f.v[j]*v[i]),res.cnt++;
		}
		return res;
	}
	polyset trans(){
		polyset res;res.cnt=1;polyn p0;p0.init(0);p0.l=p0.r=0;
		res.v.push_back(p0);
		for(int i=0;i<cnt;i++)res.v.push_back(v[i].trans()),res.cnt++;
		return res;
	}
	polyset fix(int l,int r){
		polyset res;res.cnt=2;polyn p0;p0.init(0);p0.l=0,p0.r=l-1;
		res.v.push_back(p0);
		for(int i=0;i<cnt;i++)if(v[i].l<=r&&v[i].r>=l)
			res.v.push_back(v[i].fix(max(l,v[i].l),min(r,v[i].r))),res.cnt++;
		p0.l=r+1,p0.r=INF;res.v.push_back(p0);
		return res;
	}
	polyset prefsum(){
		polyset res;res.cnt=0;int tmp=0;
		for(int i=0;i<cnt;i++){
			res.v.push_back(v[i].prefsum()),res.cnt++;
			res.v[res.cnt-1].a[0]=(res.v[res.cnt-1].a[0]+tmp)%P,tmp=res.v[res.cnt-1].sum(v[i].r);
		}
		return res;
	}
	int sum(){return v[cnt-1].sum(INF);}
} f[N][N],g[N][N];
void dp(int l,int r){
	if(vst[l][r])return;
	vst[l][r]=1;
	if(r==l-1){
		polyn p0;p0.init(1);p0.a[0]=1,p0.l=0,p0.r=INF;
		f[l][r].v.push_back(p0),g[l][r].v.push_back(p0);f[l][r].cnt=g[l][r].cnt=1;
		return;
	}
	if(r==l){
		polyn p0;p0.init(0);p0.l=0,p0.r=a[l]-1;f[l][r].v.push_back(p0);f[l][r].cnt=3;
		p0.init(2);p0.a[0]=(P+1-a[l])%P,p0.a[1]=1,p0.l=a[l],p0.r=b[l];f[l][r].v.push_back(p0);
		p0.init(1);p0.a[0]=b[l]-a[l]+1,p0.a[1]=0,p0.l=b[l]+1,p0.r=INF;f[l][r].v.push_back(p0);
		g[l][r]=f[l][r].trans();
		return;
	}
	int mid=l+r>>1;
	if(r-l+1&1){
		dp(l,mid-2),dp(mid,r),dp(l,mid-1),dp(mid+1,r),dp(l,mid),dp(mid+2,r);
		f[l][r]=((f[l][mid-2]*g[mid][r]).fix(a[mid-1],b[mid-1])
				+(f[l][mid-1]*g[mid+1][r]).fix(a[mid],b[mid])
				+(f[l][mid]*g[mid+2][r]).fix(a[mid+1],b[mid+1])).prefsum();
		g[l][r]=f[l][r].trans();
		return;
	}
	dp(l,mid-1),dp(mid+1,r),dp(l,mid),dp(mid+2,r);
	f[l][r]=((f[l][mid-1]*g[mid+1][r]).fix(a[mid],b[mid])
			+(f[l][mid]*g[mid+2][r]).fix(a[mid+1],b[mid+1])).prefsum();
	g[l][r]=f[l][r].trans();
}
int main(){
	invp[1]=invf[0]=invf[1]=fact[0]=fact[1]=1;
	for(int i=2;i<N;i++)fact[i]=1ll*fact[i-1]*i%P,invp[i]=1ll*(P-P/i)*invp[P%i]%P,invf[i]=1ll*invf[i-1]*invp[i]%P;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
	for(int k=0;k<601;k++)
		for(int j=k;j>=0;j--){
			int tmp=1ll*fact[k]*invf[j]%P*invf[k-j]%P;
			for(int i=j+2;i<=k+1;i++)tmp=(tmp-1ll*bn[k][i]*fact[i]%P*invf[j]%P*invf[i-j]%P+P)%P;
			bn[k][j+1]=1ll*invp[j+1]*tmp%P;
		}
	dp(1,n);
	printf("%d\n",f[1][n].sum());
	return 0;
}
```

---

## 作者：tzc_wk (赞：6)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P5469)

神仙题，放在 D1T2 可能略难了一点（

首先显然对于 P 型机器人而言，将它放在 $i$ 之后它会走到左边第一个严格 $>a_i$ 的位置，对于 Q 型机器人而言，将它放在 $i$ 之后它会走到右边第一个 $\ge a_i$ 的位置，为了避免分类讨论我们可以假定 $a_0=a_{n+1}=\infty$。看到这个状态我们可以设计出一个区间 $dp$，$dp_{l,r,x}$ 表示 $[l,r]$ 中的柱子最大值为 $x$，并且有 $a_{l-1}>x,a_{r+1}\ge x$ 的方案数，再设 $sum_{l,r,x}$ 表示 $dp_{l,r,x}$ 的前缀和，那么我们显然可以枚举**最靠后的最大值**的位置 $t$，那么对于放在 $t$ 的 P 型机器人，显然它会走到 $l-1$，Q 型机器人会走到 $r+1$，因此 $dp_{l,r,x}$ 可以从 $t$ 转移的充要条件是 $|(t-l)-(r-t)|\le 2$ 且 $x\in[a_l,a_r]$，因此转移是常数级别的，这样暴力做是 $\mathcal O(n^2A)$ 的，其中 $A=\max\{b_i\}$，可以拿到 $35$ 分的好成绩，不过注意到对于一个区间而言，它只可能从靠中间的位置转移过来，也就是说很多 DP 状态是转移不到 $dp_{1,n,*}$ 的，打个表可以发现有用的区间最多 $2518$ 个，因此写个记搜，再卡卡常即可拿到 $50$ 分。

接下来思考正解，注意到有一档部分分是 $A_i=1,B_i=10^9$，~~咱们不妨来当回心理学家（大雾）~~，思索一下，这档部分分有啥用？$A_i=1,B_i=10^9$ 意味着所有 $10^9$ 以内的正整数都可以成为柱子的高度，也就是说 $x\in[a_l,a_r]$ 这个条件就没有用了，因此我们只用关心 $|(t-l)-(r-t)|\le 2$ 这个条件即可。接下来再思索一下，$B_i$ 这么大，出题人会让我们干嘛？显然对于 $l=r$ 时，$dp_{l,r,x}=1,sum_{l,r,x}=x$，而对于 $r-l=1$ 的情况，$dp_{l,r,x}$ 会从 $sum_{l,l,x}$ 或 $sum_{r,r,x}$ 转移过来，因此 $dp_{l,r,x}$ 可以写成 $kx$ 的形式，$sum_{l,r,x}$ 也就可以写成 $Ax^2+Bx$ 的形式……对！多项式！通过上面的观察可以发现，$dp_{l,r,x}$ 是关于 $x$ 的 $r-l$ 次多项式，$sum_{l,r,x}$ 是关于 $x$ 的 $r-l+1$ 次多项式，证明可以归纳。我们可以求出 $sum_{l,r,x}$ 的任意 $r-l$ 个点值，然后把这个多项式插出来即可通过 $11,12$ 这两个测试点，由于点值连续，插值可以线性。

考虑满分做法，既然有了 $A_i,B_i$ 的限制，并且它们范围这么大，那肯定要离散化咯，我们按照[这题](https://www.cnblogs.com/ET2006/p/luogu-P3643.html)的套路将每个区间看作一个左开右闭的区间 $[A_i,B'_i)$，其中显然 $B'_i=B_i+1$，然后离散化。这样一来一个数 $i$ 就可以代表一个左开右闭的区间 $[C_i,C_{i+1})$。按照之前的思路我们猜想在每个这样左开右闭的区间中，$dp_{l,r,x}$ 是关于 $x$ 的 $r-l$ 次多项式，$sum_{l,r,x}$ 是关于 $x$ 的 $r-l+1$ 次多项式，事实上这个猜想也是正确的，读者自证不难。因此考虑从小到大枚举每个区间，然后对每个 $l,r$，求出该区间中最小的 $\min(C_{i+1}-C_i,n+1)$ 个数的点值即可，具体实现就每次枚举一个 $C_i$ 就开个数组 `sum[l][r][x]` 表示上文中所说的 $sum_{l,r,C_i+x-1}$，`dp[l][r][x]` 表示上文中所说的 $dp_{l,r,C_i+x-1}$，按照上面的套路转移 `dp[l][r][x]` 即可，求完所有区间的 `dp` 后对每个区间进行一遍插值，求出 $sum_{l,r,x}$，在 $C_{i+1}-1$ 处的点值，然后把它存入新的 `sum[l][r][0]` 即可，正确性显然，复杂度 $\mathcal O(2518n^2)$，轻微卡常（不过对于我这个卡常菜鸡来说就得交 $114514191981019260817998244353$ 发咯），得用一些卡常技巧，这里稍微介绍一下我的卡常技巧：

- 对区间 $[l,r]$ 进行插值的时候，可以只用前 $r-l+1$ 个点值插值，不用插 $n+1$ 个点值。
- 可以特判掉 $C_{i+1}-C_i\le n$ 的情况，这样 $C_{i+1}-1$ 处的点值我们在 DP 的时候已经求出来了
- 插值不必按部就班地求出前缀后缀积，由于我们已经特判掉了 $C_{i+1}-C_i\le n$ 的情况，因此一定有 $C_i+j-1\ne C_{i+1},j\in[1,n+1]$，此时只要预处理一遍每个 $C_{i}+j-1$ 的逆元然后那全部 $C_i+j-1$ 的乘积乘上对应的逆元即可。

```cpp
const int MAXN=300;
const int MOD=1e9+7;
const int MAXS=2520;
void add(int &x,int y){((x+=y)>=MOD)&&(x-=MOD);}
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,a[MAXN+5],b[MAXN+5],key[MAXN*2+5],uni[MAXN*2+5],num=0;
int id[MAXN+5][MAXN+5],itvl_n=0;pii itvls[MAXS+5];
void find_itvl(int l,int r){
	if(id[l][r]) return;id[l][r]=++itvl_n;
	itvls[itvl_n]=mp(l,r);if(l>r) return;
	for(int i=l;i<=r;i++) if(abs((i-l)-(r-i))<=2)
		find_itvl(l,i-1),find_itvl(i+1,r);
}
int dp[MAXS+5][MAXN+5];bool vis[MAXN+5][MAXN+5];
void work(int l,int r,int len,int itv){
	if(l>r){
		for(int i=0;i<=len;i++) dp[id[l][r]][i]=1;
		return;
	} if(vis[l][r]) return;vis[l][r]=1;
	for(int i=1;i<=len;i++) dp[id[l][r]][i]=0;
	for(int x=l;x<=r;x++) if(abs((x-l)-(r-x))<=2) if(a[x]<=itv&&itv<b[x]){
		work(l,x-1,len,itv);work(x+1,r,len,itv);
		for(int i=1;i<=len;i++){
			dp[id[l][r]][i]=(dp[id[l][r]][i]+1ll*
			dp[id[l][x-1]][i]*dp[id[x+1][r]][i-1])%MOD;
		}
	}
	for(int k=1;k<=len;k++) add(dp[id[l][r]][k],dp[id[l][r]][k-1]);
}
int iv[MAXN+5],ifac[MAXN+5];
void init_fac(int n){
	for(int i=(ifac[0]=ifac[1]=1)+1;i<=n;i++) ifac[i]=1ll*ifac[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=n;i++) ifac[i]=1ll*ifac[i-1]*ifac[i]%MOD;
}
void getval(int l,int r){
	if(r-l+1<=n+1){
		for(int i=1;i<=itvl_n;i++) dp[i][0]=dp[i][r-l+1];
		return;
	} for(int i=1;i<=n+1;i++) iv[i]=qpow(r-(l+i-1),MOD-2);
	for(int i=1;i<=itvl_n;i++){
		if(itvls[i].fi>itvls[i].se) continue;
		int len=itvls[i].se-itvls[i].fi+1,tot=1;
		for(int j=1;j<=len+1;j++) tot=1ll*tot*(r-(l+j-1))%MOD;
		dp[i][0]=0;
		for(int j=1;j<=len+1;j++){
			int mul=1ll*ifac[j-1]*ifac[len+1-j]%MOD*tot%MOD*iv[j]%MOD;
			if((len+1-j)&1) mul=MOD-mul;
			dp[i][0]=(dp[i][0]+1ll*mul*dp[i][j])%MOD;
		}
	}
}
int main(){
//	freopen("robot.in","r",stdin);
//	freopen("robot.out","w",stdout);
	scanf("%d",&n);init_fac(n+3);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);++b[i];
		key[i*2-1]=a[i];key[i*2]=b[i];
	} sort(key+1,key+(n<<1)+1);
	for(int i=1;i<=n<<1;i++) if(key[i]^key[i-1])
		uni[++num]=key[i];
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(uni+1,uni+num+1,a[i])-uni;
		b[i]=lower_bound(uni+1,uni+num+1,b[i])-uni;
	} find_itvl(1,n);
	for(int i=1;i<num;i++){
//		printf("%d %d\n",uni[i],uni[i+1]-1);
		memset(vis,0,sizeof(vis));
		for(int l=1;l<=n;l++) for(int r=l-1;r<=n;r++)
			if(id[l][r]) work(l,r,min(uni[i+1]-uni[i],n+1),i);
		getval(uni[i],uni[i+1]-1);
//		for(int j=1;j<=itvl_n;j++) printf("%d %d %d\n",i,j,dp[j][0]);
	} printf("%d\n",dp[id[1][n]][0]);
	return 0;
}
```

---

## 作者：lottle1212__ (赞：3)

# [[NOI2019] 机器人](https://www.luogu.com.cn/problem/P5469)

观察到任意方案中，所有位置能走到的区间都是包含或不相交的区间，而反过来看，每个区间中最大值中最靠右者，可以走到区间中所有的位置，考虑区间 DP。设 $dp_{l, r, h}$ 表示在 $[l, r]$ 中，最高的位置的高度不超过 $h$ 的方案数，则有转移 $dp_{l, r, h}=dp_{l, r, h-1}+\sum_{i\in[l, r], |(i-l)-(r-i)|\leq2, a_i\leq h\leq b_i}dp_{l, i-1, h}\times dp_{i+1, r, h}$，表示的是枚举出发点 $i$，其能走到的位置左右两边距离不超过 $2$，且这个位置可以被设为 $h$，令这个位置上的高度为 $h$，则方案数为左边最高高度不超过 $h$，右边小于 $h$ 的方案数相乘。而最高为 $h$ 的加上最高不超过 $h-1$ 的，即不超过 $h$ 的方案数。

这样子是 $O(n^2V)$ 的。由于最后只需要知道 $dp_{1, n, V}$ 的值，则会对最终区间 $[1, n]$ 产生贡献的区间 $[l, r]$ 的个数会比 $O(n^2)$ 小很多。则可以先预处理出这些区间。打表得知，实际有用的区间个数不到 $3000$，设个数为 $w$，则只需要处理这 $w$ 个区间即可。时间复杂度 $O(wV)$。

既然 $V$ 这么大，就可以去考虑离散化它。离散化后的 $V$ 被分成了 $O(n)$ 个区间。此时，把高度在一个区间内的情况一起考虑，会发现转移中 $a_i\leq h\leq b_i$ 的条件对于每一个位置是固定的，不随在此区间内的 $h$ 变化而变化。纵观每一个位置 $i$，其每一个 $h$ 的转移都是一样的，这时就可以大胆地猜测，一个长度为 $n$ 的区间的答案是一个与 $h$ 有关的 $n$ 次多项式。这个可以使用数学归纳法证明。首先长度为 $1$ 的区间，其方案数是随 $h$ 的增加线性递增的，然后是长度为 $k$ 的区间，设转移时左右区间的长度分别为 $x, y(x+y=k-1)$，则左边是一个 $x$ 次多项式，右边是一个 $y$ 次多项式，转移时是将其相乘，此时为 $x+y=k-1$ 次，求和操作算作一次，为 $k$ 次，则证明了长度为 $k$ 的区间是与 $h$ 有关的 $k$ 次多项式。

那么对于任意的 $h$，只需要求出这个 $n$ 次多项式，就可以直接带入求值。使用拉格朗日插值法，先求出高度为 $[1, n+1]$ 的答案，最后代入 $h$ 即可，这一部分的复杂度是 $O(n)$ 的。

则最终的做法即在高度区间长度不超过 $n+1$ 时暴力计算，超过时先计算出 $[1, n+1]$ 时的值，再代入整个区间的长度，求出答案，做下一个高度区间时将前一个区间的答案视作 $0$（因为比所有下一个区间的高度都低），一层层做下去即可。时间复杂度 $O(n^2w)$。

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <bitset>
#include <math.h>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#define fst first
#define scd second
#define db double
#define ll long long
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector <int>
#define pii pair <int, int>
#define sz(x) ((int)x.size())
#define ms(f, x) memset(f, x, sizeof(f))
#define L(i, j, k) for (int i=(j); i<=(k); ++i)
#define R(i, j, k) for (int i=(j); i>=(k); --i)
#define ACN(i, H_u) for (int i=H_u; i; i=E[i].nxt)
using namespace std;
template <typename INT> void rd(INT &res) {
	res=0; bool f=false; char ch=getchar();
	while (ch<'0'||ch>'9') f|=ch=='-', ch=getchar();
	while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^48), ch=getchar();
	res=(f?-res:res);
}
template <typename INT, typename...Args>
void rd(INT &x, Args &...y) { rd(x), rd(y...); }
//dfs
const int mod=1e9+7; 
const int maxn=300, maxm=3000;
const int N=maxn+10, M=maxm+10;
int fac[N], inv[N], d[N<<1], a[N], b[N], f[M][N], id[N][N], idx, n, dcnt, pre[N], suf[N];
//wmr
int mods(int x) { return x<0?x+mod:x; }
int moda(int x) { return x>=mod?x-mod:x; }
struct node {
	int l, r;
	node(int _l, int _r) { l=_l, r=_r; }
	node() {}
	bool operator < (const node &k) const { return r-l<k.r-k.l; }
} p[M];
int quick_power(int x, int y) {
	int res=1;
	while (y) {
		if (y&1) res=(ll)res*x%mod;
		x=(ll)x*x%mod, y>>=1;
	}
	return res; 
}
//incra
void dfs(int l, int r) {
	if (l>r||id[l][r]) return;
	p[id[l][r]=++idx]=node(l, r);
	if (l==r) return;
	L(i, l, r) if (abs(i-l-r+i)<=2) dfs(l, i-1), dfs(i+1, r);
}
void lag(int rh) {
	pre[0]=1; L(i, 1, n+1) pre[i]=(ll)pre[i-1]*(rh-i)%mod;
	suf[n+2]=1; R(i, n+1, 1) suf[i]=(ll)suf[i+1]*(rh-i)%mod;
	L(i, 1, idx) f[i][0]=0;
	L(i, 1, n+1) {
		int v=(ll)pre[i-1]*suf[i+1]%mod*inv[i-1]%mod*inv[n+1-i]%mod*(((n+1-i)&1)?mod-1:1)%mod;
		L(j, 1, idx) f[j][0]=((ll)v*f[j][i]+f[j][0])%mod;
	}
}
//lottle
signed main() {
//	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	fac[0]=1; L(i, 1, maxn) fac[i]=(ll)fac[i-1]*i%mod;
	inv[maxn]=quick_power(fac[maxn], mod-2); R(i, maxn-1, 0) inv[i]=(ll)inv[i+1]*(i+1)%mod;
	rd(n);
	L(i, 1, n) rd(a[i], b[i]), d[++dcnt]=a[i], d[++dcnt]=++b[i]; //左闭右开
	sort(d+1, d+dcnt+1); dcnt=unique(d+1, d+dcnt+1)-d-1;
	L(i, 1, n) a[i]=lower_bound(d+1, d+dcnt+1, a[i])-d, b[i]=lower_bound(d+1, d+dcnt+1, b[i])-d;
	dfs(1, n); sort(p+1, p+idx+1);
	L(i, 0, n+1) f[0][i]=1;
	L(i, 1, dcnt-1) {
		int hn=min(n+1, d[i+1]-d[i]);
		L(j, 1, idx) {
			int l=p[j].l, r=p[j].r;
			L(k, l, r) if (abs(k-l-r+k)<=2&&a[k]<=i&&i<b[k])
			L(h, 1, hn) f[id[l][r]][h]=((ll)f[id[l][k-1]][h]*f[id[k+1][r]][h-1]+f[id[l][r]][h])%mod;
			L(h, 1, hn) f[id[l][r]][h]=moda(f[id[l][r]][h]+f[id[l][r]][h-1]);
		}
		int rh=d[i+1]-d[i];
		if (rh<=n+1) L(j, 1, idx) f[j][0]=f[j][hn];
		else lag(rh);
		L(j, 1, idx) fill(f[j]+1, f[j]+hn+1, 0);
	}
	printf("%d\n", f[id[1][n]][0]);
	return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：3)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18141405)

[P5469 [NOI2019] 机器人](https://www.luogu.com.cn/problem/P5469)

首先考虑如何比较简单的进行判定合法。每一次执行一个找最大值的过程（如果有多个最大值则取最右侧的），然后从这个位置把序列劈成两半，递归判定。

因为最大值的位置能走到序列的最左侧和最右侧，所以要求最大值的位置 $|((n-p)-(p-1))|\leq 2$。

所以考虑区间 DP，设 $f_{i,j,k}$ 表示区间 $[i,j]$ 中最大值为 $k$ 的方案数。转移比较简单：

$$
f_{i,j,k}=\sum_{p\;\text{is}\;\text{valid}}\sum_{x\leq k}f_{i,p-1,x}\sum_{y<k}f_{p+1,j,y}
$$

可以前缀和优化到 $\mathcal O(n^2)$。同时由于 $p$ 特殊的位置限制，所以可以把所有会访问到的区间搜出来，发现最多 $2000+$ 个区间，这样就有了 $50$ 分。

考虑进行优化。先观察上面方程的初值：

$$
\begin{aligned}
f_{i,i+1,x}&=1\\
f_{i,i,x}&=\max(0,\min(x,r_i)-l_i+1)
\end{aligned}
$$

如果把 $\max$ 和 $\min$ 拆开，会得到分段的一次或零次关于 $x$ 的函数。所以每一个 $f_{i,j}$ 都是一个关于 $k$ 的不超过 $n$ 次的多项式（因为最多就是 $n$ 个一次函数相乘）。

拆开 $\max$ 和 $\min$ 之后有若干个值域的连续段。在连续段 $k\in[L,R]$ 内部，$f_{i,j}$ 关于 $k$ 的多项式相同。所以对于每个 $f_{i,j}$ 都会得到 $\mathcal O(n)$ 个分段函数。

上面的暴力 DP 瓶颈在于 $k$ 可能非常大，但是我们知道在同一连续段下它次数是 $\mathcal O(n)$ 的。而对于两个相邻的连续段 $[L,x]$ 和 $[x+1,R]$，后一个连续段只会用到前一个连续段 $k=x$ 处的 DP 值。（算 $k=x+1$ 的时候会用到）

所以对于每个连续段 $[L,R]$，可以先暴力算出前 $n+1$ 个点值（这在算 $k=L$ 时会用到 $L-1$ 处的点值），然后用拉格朗日插值求出其在 $x$ 处的点值。这样下一个区间需要用的信息就处理好了，可以继续处理下一段。

所以思路就比较明朗了：从小到大枚举连续段，然后暴力算出所有 $f_{i,j}$ 的前 $n+1$ 个点值，然后用拉插算出连续段最后一个数的点值，然后去算下一个连续段。DP 的总复杂度是 $\mathcal O(mn^2)$，其中 $m$ 为状态数，$2500$ 左右。

对于拉插，观察公式：

$$
F(x_0)=\sum_{i=1}^{n+1}y_i\prod_{j\not=i}\frac{x_0-x_j}{x_i-x_j}
$$

可以先 $\mathcal O(n\log n)$ 或者 $\mathcal O(n)$ 预处理后面的 $\text{prod}$，这样对于每个状态算的时候就是 $\mathcal O(n)$，所以这部分的总复杂度也是 $\mathcal O(mn^2)$。注意卡常。

一个小细节是可以把求出来 $R$ 的点值放到 DP 数组 $k=0$ 的位置，方便下一次暴力 DP 使用。代码目前（2024/4/17）是 ~~优势非常小的~~ 最优解。

```cpp
int cnt=1,n,len,inv2[610],inv[610],v[310],a[310],b[310],f[2710][320],g[2710],L[2710],R[2710],id[310][310],numa[610];
queue<pii> q;
vector<pii> ve;
void dfs(int l,int r)
{
	if(l>r)return;
	if(l==r)return id[l][r]=l,void();
	if(id[l][r])return;
	id[l][r]=++cnt,ve.eb(mp(l,r));
	for(int i=l;i<=r;++i)if(abs(2*i-l-r)<=2)dfs(l,i-1),dfs(i+1,r);
}
inline bool cmp(pii p1,pii p2){return p1.se-p1.fi>p2.se-p2.fi;}
inline void calc(int l,int r)
{
	for(int i=1;i<=n;++i)
	{
		for(int j=l;j<=r;++j)
		f[i][j-l+1]=min(b[i]-a[i]+1,max(0,j-a[i]+1));
	}
	for(int i=cnt;i>n;--i)
	{
		for(int j=1;j<=r-l+1;++j)f[i][j]=0;
		if((R[i]-L[i]+1)&1)
		{
			int mid=(L[i]+R[i]-2)/2;
			for(int j=max(1,a[mid]-l+1);j<=min(b[mid]-l+1,r-l+1);++j)
			Madd(f[i][j],Cmul(f[id[L[i]][mid-1]][j],f[id[mid+1][R[i]]][j-1]));
			++mid;
			for(int j=max(1,a[mid]-l+1);j<=min(b[mid]-l+1,r-l+1);++j)
			Madd(f[i][j],Cmul(f[id[L[i]][mid-1]][j],f[id[mid+1][R[i]]][j-1]));
			++mid;
			for(int j=max(1,a[mid]-l+1);j<=min(b[mid]-l+1,r-l+1);++j)
			Madd(f[i][j],Cmul(f[id[L[i]][mid-1]][j],f[id[mid+1][R[i]]][j-1]));
		}
		else
		{
			int mid=(L[i]+R[i]-1)/2;
			for(int j=max(1,a[mid]-l+1);j<=min(b[mid]-l+1,r-l+1);++j)
			Madd(f[i][j],Cmul(f[id[L[i]][mid-1]][j],f[id[mid+1][R[i]]][j-1]));
			++mid;
			for(int j=max(1,a[mid]-l+1);j<=min(b[mid]-l+1,r-l+1);++j)
			Madd(f[i][j],Cmul(f[id[L[i]][mid-1]][j],f[id[mid+1][R[i]]][j-1]));
		}
		for(int j=1;j<=r-l+1;++j)Madd(f[i][j],f[i][j-1]);
	}
	for(int i=1;i<=cnt;++i)f[i][0]=f[i][r-l+1];
}
inline void mian()
{
	read(n),dfs(1,n),sort(ve.begin(),ve.end(),cmp),cnt=n,inv[0]=1;
	for(int i=1;i<=600;++i)inv[i]=Cmul(inv[i-1],i);
	inv[600]=power(inv[600],MOD-2);
	for(int i=599;i>=1;--i)inv[i]=Cmul(inv[i+1],i+1);
	for(auto p:ve)id[p.fi][p.se]=++cnt,L[cnt]=p.fi,R[cnt]=p.se;
	for(int i=0;i<=310;++i)f[0][i]=1;
	memcpy(inv2,inv,sizeof(inv));
	for(int i=1;i<=600;++i)if(i&1)inv2[i]=Cdel(0,inv2[i]);
	for(int i=1;i<=n;++i)read(a[i],b[i]),numa[++len]=a[i],numa[++len]=b[i]+1;
	sort(numa+1,numa+1+len),len=unique(numa+1,numa+1+len)-numa-1;
	int lim=n+1;
	for(int k=1;k<len;++k)
	{
		if(numa[k+1]-numa[k]<=lim){calc(numa[k],numa[k+1]-1);continue;}
		calc(numa[k],numa[k]+lim-1);
		for(int i=1;i<=n;++i)f[i][0]=min(b[i]-a[i]+1,max(0,numa[k+1]-a[i]));
		int all=1;
		for(int j=1;j<=lim;++j)Mmul(all,numa[k+1]-numa[k]-j);
		for(int j=1;j<=lim;++j)v[j]=Cmul(all,inv2[n+1-j],inv[j-1],power(numa[k+1]-numa[k]-j,MOD-2));
		for(int i=n+1;i<=cnt;++i)
		{
			int s=0;
			for(int j=1;j<=lim;++j)
			Madd(s,Cmul(v[j],f[i][j]));
			f[i][0]=s;
		}
	}
	write(f[n+1][0]);
}
```

---

## 作者：nullqtr_pwp (赞：3)

这题怎么和 [[统一省选 2022] 填树](https://loj.ac/p/3701) 一模一样啊。


注意到**每个**位置都要保证往左移动和往右移动的距离相差 $\le 2$，这是一个很强的限制条件。但是这个条件是限制不住最大值的，也就是说最大值一定运动到边界。所以可以考虑一个 DP，求解 $f_{l,r,k}$ 表示 $[l,r]$ 内的最大值恰好为 $k$ 的合法方案数。那么 $k$ 的位置需要满足其在中点或者中点偏移 $1$，需要分讨区间长度奇偶。

然后这个爆搜会枚举 $k$ 的位置是 $p$，注意到如果有多个最大值，我们只关心最左边的那个，那么此时会调用 $f_{l,p-1,i}\times f_{p+1,r,j},i<k,j\le k$。（需要特别关心区间的开闭问题，因为区间的数可以重复）

可以用前缀和优化。状态改成 $[l,r]$ 内的最大值 $\leq k$ 的合法方案数。然后讨论最大值恰好为 $k$ 的方案数，再与前面的做前缀和。

观察到一个细节，如果写成爆搜的形式，整个 DP 涉及到的区间应该不会太多，因为每次的断点 $p$ 是中点。和 dp 套 dp 的状态数差不多，**不要脑测。** 写个爆搜发现 $n=300$ 时仅会涉及到 $m=2047$ 个区间。

因此直接 dp 的复杂度是 $O(nmA)$，因为存储最大值，也就是值域会耗费很多的时空。

注意到这种偏序关系我们只关心**相对大小。** 考虑用类似 [[统一省选 2022] 填树](https://loj.ac/p/3701) 的套路分段求解，就是说把所有 $a_i,b_i$ 离散化，改成左闭右开区间。我们关心 $f_{1,n,k}$ 落在其中哪一段中，也就是可以算出来 $k$ 关于 $a_i,b_i$ 的偏序关系。

注意到将 $f_{i,i,j}$ 写成一次函数时，会往上递归 $n$ 次，每次都会升一次。那么 $f_{l,r,k}$ 其实是一个关于 $k$ 的 $n$ 次多项式。对于不同的偏序关系，会得到完全不用的 $n$ 次多项式。因此需要分段求解，DP 中的 $k$ 改写成，是本段的第 $k$ 个数，再用一个辅助数组 $dp_{l,r}$ 表示 $[l,r]$ 的最大值在之前的段中的方案数。

注意到，因为是最大值 $\le k$，我们只关心 $k$ 处的点值。可以拉格朗日插值求解，求出前 $n+1$ 个点值，然后 $O(n)$ 计算 $k$ 的点值即可。（注意到 $x_i$ 值是连续的，因此可以预处理前后缀，然后把正常的 $O(n^2)$ 优化到 $O(n)$ 的复杂度）

时间复杂度 $O(mn^2)$。注意每次跑拉插的前后缀积必须要预处理，否则会被卡常，这是因为取模常数巨大，几乎可以视为 $40$ 次加减法运算。

[提交记录](https://loj.ac/s/2004299)

---

## 作者：Terry2022 (赞：2)

upd 2023/7/14:时间复杂度有误。

这是一个复杂度较劣常数较小且容易想到的容斥做法，不需要拉格朗日插
值。

**题意**：

对于一个序列 $\{a\}$，如果满足 $\forall i\in[1,n]$，向左扩展长度与向右扩展长度差的绝对值 $\le 2$，则这个序列是好序列；向左扩张定义为左侧第一个大于 $a_i$ 的数到 $i$ 的距离，向右扩展定义为右侧第一个大于等于 $a_i$ 的数到 $i$ 的距离；给定 $\forall i\in[1,n]$，$a_i$ 的范围 $[l_i,r_i]$，求好序列的数量，答案对 $10^9+7$ 取模。

$n\le 300,1\le l_i\le r_i\le 10^9$

**思路**：

下面按照部分分的顺序叙述思路。

首先考虑 $n\le 50,r_i\le 100$ 的情况：

观察好序列的性质，由于要找到大于（等于）$a_i$ 的数，所以不妨找两个极端情况：最小值与最大值；最小值一定满足条件，而对于最右的最大值，它一定向左/右扩展一定能扩展整个序列，所以这个位置只有 $O(1)$ 个，同时左右侧的点一定无法扩展到这个点，问题划分为子问题，所以可以考虑区间dp。

设 $f_{l,r,x}$ 表示区间 $[l,r]$，要求最大值 $\le x$，转移为：$f_{l,r,x}=\sum_{p}[|r-p+1-(p-l+1)|\le 2]f_{l,p-1,x}f_{p+1,r,x-1}$，由于 $p$ 只有 $O(1)$ 个，所以时间复杂度为 $O(n^2V)$。

由于 $p$ 的数量有限，记忆化搜索出有用状态，记有用状态为 $st_i$，有 $m$ 个，$m$ 在 $n=299$ 处取到最大值 $2541$，所以时间复杂度优化为 $O(mV)$。

再考虑 $l_i=1,r_i=10^9$ 的情况：

由于对于每一个数都可以填 $[1,10^9]$ 里的数，实际只会填 $n$ 个位置，所以不妨钦定使用了 $k$ 个数，也就是将 $[l_i,r_i]$ 设为 $[1,k]$，重新跑一次dp，求出最大值 $\le k$ 的方案数 $f_k$，注意这个求出的是钦定 $k$，可能没有填满，所以使用容斥求出恰好使用 $k$ 个数的方案数 $g_{k}$，$g_{k}=f_{k}-\sum_{j=0}^{k-1}\binom{k}{j}g_{j}$，可以在 $O(len^2)$ 的时间内求出有 $len$ 个数的方案数。

最后考虑 $n\le 300,1\le l_i\le r_i\le 10^9$ 的情况：

考虑沿用 $l_i=1,r_i=10^9$ 的容斥做法，这个做法时间复杂度与值域无关；根据 $l_i,r_i$ 的限制可以将值域拆为 $2n$ 段，每一段内部等价 $l_i=1,r_i=10^9$ 的情况，即包含这个值域区间的 $i$ 可以随意选择值。

对于每一个值域区间，设 $f_{i,j}$ 表示合法区间 $i$，满足最大值 $\le j$ 的方案数；对于 $\le len_i$ 的部分可以直接暴力转移，对于 $>len_i$ 的部分，通过 $O(len^2)$ 的做法求出这个值域区间内的答案。

值域区间之间的转移即为将第 $i$ 个值域区间的 $f_{i,x}$ 值赋给第 $i+1$ 个值域区间的 $f_{i,0}$，表示 $<l_i$ 的方案数。

对于暴力求解前 $len$ 个值，时间复杂度上界为 $O(mn^2)$；对于容斥求解 $>len$ 项的 $f$ 值，总的时间复杂度为 $O(n\sum len^2)$，可以使用二项式反演+MTT优化至 $O(n\sum len\log len)$，但是没有必要，常数很小，而且也卡不到上界，所以只要简单卡一下上界即可通过，甚至比拉格朗日插值做法更快。

实际数据测试可以发现，暴力求前 $len$ 项 $O(mn^2)$ 所花时间远远多余容斥所花时间 $O(n\sum len^2)$。

**代码**：

以下代码最慢点在洛谷上 $800ms$，经过简单循环展开可以达到 $700ms$。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cassert>
const int Q=305;
const int P=3005;
const int INF=(1<<30);
const int mod=1e9+7;
typedef long long ll;
#define rg register int
#define cint const register int
//char ibuf[1<<21],*IP1=ibuf,*IP2=ibuf;
//#define gc() (__builtin_expect(IP1==IP2,0)&&(IP2=(IP1=ibuf)+fread(ibuf,1,1<<21,stdin),__builtin_expect(IP1==IP2,0))?EOF:*IP1++)
#define gc getchar
#define pc putchar
inline bool ig(const char c){return c>=48&&c<=57;}
inline void read(rg&oi){char c;rg f=1,res=0;while(c=gc(),(!ig(c))&&c^'-');c^'-'?res=(c^48):f=-1;while(c=gc(),ig(c))res=res*10+(c^48);oi=f*res;}
inline void print(rg oi){char io[23];rg l=0;if(oi<0)pc('-'),oi=~oi+1;do io[++l]=(oi%10+48);while(oi/=10);for(;l;--l)pc(io[l]);}
inline void write(cint oi,const char c){print(oi);pc(c);}char _ST_;
inline int inc(cint x,cint y){return x+y<mod?x+y:x+y-mod;}
inline int dec(cint x,cint y){return x>=y?x-y:x-y+mod;}
inline int mul(cint x,cint y){return 1ll*x*y%mod;}
inline void Inc(rg&x,cint y){((x+=y)>=mod)&&(x-=mod);}
inline void Dec(rg&x,cint y){((x-=y)<0)&&(x+=mod);}
inline void Mul(rg&x,cint y){x=1ll*x*y%mod;}
inline int pow(rg x,rg y){rg res=1;for(;y;y>>=1,Mul(x,x))(y&1)&&(Mul(res,x),1);return res;}
inline int Inv(cint x){return pow(x,mod-2);}
inline void Max(rg&x,cint y){(x<y)&&(x=y);}
inline void Min(rg&x,cint y){(x>y)&&(x=y);}
int n,lim,lp[Q],rp[Q],b[Q<<1],m,C[Q][Q],iv[Q];
int f[P][Q],id[Q][Q],N,sl[P][3],sr[P][3],pt[P][3],l[P],r[P],sz[P];int pn[P];
inline int dfs(cint l,cint r){
	if(l>r)return 0;if(id[l][r])return id[l][r];
	cint x=++N;id[l][r]=x;sz[x]=r-l+1;::l[x]=l;::r[x]=r;rg p;cint len=r-l+1,mid=l+r>>1;
	p=mid;if(p>=l&&p<=r)pt[x][0]=p,sl[x][0]=dfs(l,p-1),sr[x][0]=dfs(p+1,r);
	p=mid+1;if(p>=l&&p<=r)pt[x][1]=p,sl[x][1]=dfs(l,p-1),sr[x][1]=dfs(p+1,r);if(!(len&1))return x;
	p=mid-1;if(p>=l&&p<=r)pt[x][2]=p,sl[x][2]=dfs(l,p-1),sr[x][2]=dfs(p+1,r);return x;
}
int bm[Q],g[P],cn[P];
inline void calc(cint x){
	if(x<=lim){for(rg i=1;i<=N;++i)f[i][0]=f[i][x];return;}
	bm[0]=1;for(rg i=1;i<=n;++i)Mul(bm[i]=bm[i-1],mul(x+1-i,iv[i]));
	for(rg i=1;i<=N;++i){
		rg s=0;for(rg j=0;j<=cn[i];++j){
			rg v=0;for(rg k=0;k<=j;++k)((j-k)&1)?(Dec(v,mul(f[i][k],C[j][k])),1):
			(v=(v+1ll*f[i][k]*C[j][k])%mod);Inc(s,mul(v,bm[j]));
		}
		f[i][0]=s;
	}
}
char _ED_;int main(){
	fprintf(stderr,"memory:%llu MB\n",(&_ST_-&_ED_)>>20);
	read(n);for(rg i=1;i<=n;++i)read(lp[i]),read(rp[i]),++rp[i];
	for(rg i=1;i<=n;++i)b[++m]=lp[i],b[++m]=rp[i];
	std::sort(b+1,b+1+m);m=std::unique(b+1,b+1+m)-b-1;
	for(rg i=1;i<=n;++i)lp[i]=std::lower_bound(b+1,b+1+m,lp[i])-b,
	rp[i]=std::lower_bound(b+1,b+1+m,rp[i])-b;
	iv[1]=1;for(rg i=2;i<=n;++i)Mul(iv[i]=iv[mod%i],mod-mod/i);
	dfs(1,n);for(rg i=0;i<=n;++i)C[i][0]=1;
	for(rg i=1;i<=n;++i)for(rg j=1;j<=i;++j)Inc(C[i][j]=C[i-1][j-1],C[i-1][j]);
	for(rg i=0;i<=n+1;++i)f[0][i]=1;for(rg i=1;i<=N;++i)pn[i]=i;
	std::sort(pn+1,pn+1+N,[](cint x,cint y){return sz[x]<sz[y];});
	for(rg v=1;v<m;++v){
		lim=0;for(rg _=1;_<=N;++_){cn[_]=0;for(rg j=l[_];j<=r[_];++j)
		if(lp[j]<=v&&rp[j]>v)++cn[_];Max(lim,cn[_]);}Min(lim,b[v+1]-b[v]);
		for(rg _=1;_<=N;++_){
			cint i=pn[_];bool fl=0;for(rg j=0;j<3;++j){
				cint p=pt[i][j],L=sl[i][j],R=sr[i][j];if(!p||lp[p]>v||rp[p]<=v)continue;
				fl=1;for(rg k=1;k<=lim;++k)f[i][k]=(f[i][k]+1ll*f[L][k]*f[R][k-1])%mod;
			}
			if(fl)for(rg k=1;k<=lim;++k)Inc(f[i][k],f[i][k-1]);
			else{for(rg k=1;k<=lim;++k)f[i][k]=f[i][0];}
			cn[_]=0;for(rg j=l[_];j<=r[_];++j)if(lp[j]<=v&&rp[j]>v)++cn[_];
		}
		calc(b[v+1]-b[v]);for(rg i=1;i<=N;++i)memset(f[i]+1,0,lim*4);
	}
	write(f[1][0],'\n');
	return 0;
}
```



---

## 作者：Purslane (赞：1)

# Solution

暴力做法，我~~懒得~~不太会分析复杂度，不过能过就行。（打表发现运算量 $10^8$ 量级，也就是 $O(n^3 \log n)$ 左右）

考虑先刻画整个区间的笛卡尔树的结构，然后在上面 DP。

根据题目，我们需要限制相同的数靠左的优先级更高。

设 $dp_{i,j,s}$ 为，考虑了 $[i,j]$ 的笛卡尔树，最大值为 $s$。

我们先选取一个 $i \le k \le j$ 使得 $|2k-i-j| \le 2$，它可能作为笛卡尔树的根。那么很容易写出转移：

$$
dp_{i,j,s} = \sum_{k} [a_k \le s \le b_k](\sum_{v \le s} dp_{i,k-1,v})(\sum_{v<s} dp_{k+1,r,s})
$$

注意两边限制并不相同。

看起来直接做复杂度是 $O(n^2 V)$。但是实际上通过打表发现，符合条件的 $(i,j)$（可能有用的）并不多，大概是 $O(n \log n)$ 的（我没有证明啊，打表出来 $n=300$ 的时候是 $2200$ 左右）。

所以实际上能过 $50$ 分。然后那 $10$ 分的包也是随便拼，这样获得了 $60$ 分。

很可惜那一天的 T3 并不太可做，所以你不能这样就跑路了，需要搞个做法出来。

你手搓一下 $l$ 和 $r$ 比较小的情况，发现可以把 $dp$ 数组分成若干段，每一段都是一个关于 $s$ 的多项式。而这件事情归纳易证。

那么考虑所有函数的断点可能是哪些。$v$ 是 $(i,j)$ 的断点，也就这几种情况：

1. 某个 $a_k$ 或者 $b_k+1$；
2. $v$ 是 $(i,k-1)$ 的断点；
3. $v-1$ 是 $(k+1,r)$ 的断点。

所以一定是区间中的某个 $a$ 或 $b+1$，加上一个量。而我们容易证明偏移量是 $O(\log n)$ 量级的（本题中实测 $\log (r-l+1)$ 可以过）。

而使用数学归纳法可以证明，dp 数组的次数最多为 $r-l$。所以我们可以维护 $[a_i,a_i+r-l+1+\log_2 (r-l+1)]$ 和 $[b_i+1,b_i+r-l+2+\log_2 (r-l+1)]$ 的点值。

这样每次会做 $O((r-l+1)^2)$ 次插值，每次插值精细实现是 $O(r-l+1)$。那么总复杂度就是

$$
\sum_{(l,r) \text{ is legal}} (r-l+1)^3
$$

这个东西看起来是 $O(n^5)$ 的，哎但是实测是 $O(n^3 \log n)$ 量级。我也不想去证明。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=300+10,MOD=1e9+7;
int n,a[MAXN],b[MAXN],frac[MAXN],inv[MAXN];
struct Mod {
    ll m,p;
    void init(const int pp) {m=((__int128)1<<64)/pp;p=pp;}
    inline ll operator ()(const ll x) {return x-((__int128(x)*m)>>64)*p;}
}node;
inline int qpow(ll base,int p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=node(ans*base);
		base=node(base*base),p>>=1;
	}
	return ans;
}
int V[MAXN],X[MAXN],Pre[MAXN],Suf[MAXN];
int lag(int n,int x) { //n=deg+1
	Pre[0]=Suf[n+1]=1;
	ffor(i,1,n) Pre[i]=node(1ll*Pre[i-1]*(x-X[i]));
	roff(i,n,1) Suf[i]=node(1ll*Suf[i+1]*(x-X[i]));
	__int128 ans=0;
	ffor(i,1,n) {
		int mul=node(node(1ll*Pre[i-1]*Suf[i+1])*V[i]);
		int div=node(1ll*inv[i-1]*inv[n-i]);
		if((n-i)&1) div=MOD-div;
		ans+=1ll*mul*div;
	}
	return ans%MOD;
}
vector<pair<int,int>> dp[MAXN*MAXN],pre[MAXN*MAXN];
int tot,gid[MAXN][MAXN];
void solve(int l,int r) {
	if(gid[l][r]||l>r) return ;
	gid[l][r]=++tot;
	int u=gid[l][r];
	vector<int> pos;
	int LIM=r-l+1+__lg(r-l+1);
	ffor(i,l,r) ffor(j,0,LIM) pos.push_back(a[i]+j),pos.push_back(b[i]+j+1);
	sort(pos.begin(),pos.end()),pos.erase(unique(pos.begin(),pos.end()),pos.end());
	for(auto id:pos) {
		dp[u].push_back({0,id});
		pre[u].push_back({0,id});
	}
	ffor(i,l,r) if(abs((i-l)-(r-i))<=2) {
		solve(l,i-1),solve(i+1,r);
		int p1=gid[l][i-1],p2=gid[i+1][r];
		int t1=-1,t2=-1;
		ffor(j,0,dp[u].size()-1) {
			int x=dp[u][j].second;
			while(t1+1<pre[p1].size()&&pre[p1][t1+1].second<=x) ++t1;
			while(t2+1<pre[p2].size()&&pre[p2][t2+1].second<x) ++t2;
			int mul1=0,mul2=0;
			if(t1!=-1) {
				if(pre[p1][t1].second==x) mul1=pre[p1][t1].first;
				else {
					int t=i-l+1;
					ffor(j,1,t) X[j]=pre[p1][t1-t+j].second,V[j]=pre[p1][t1-t+j].first;
					mul1=lag(t,x);
				}
			}
			else if(l>i-1) mul1=1;
			--x;
			if(t2!=-1) {
				if(pre[p2][t2].second==x) mul2=pre[p2][t2].first;
				else {
					int t=r-i+1;
					ffor(j,1,t) X[j]=pre[p2][t2-t+j].second,V[j]=pre[p2][t2-t+j].first;
					mul2=lag(t,x);
				}
			}
			else if(i+1>r) mul2=1;
			++x;
			if(a[i]<=x&&x<=b[i]) dp[u][j].first=node(dp[u][j].first+1ll*mul1*mul2);
		}
	}
	pre[u][0].first=dp[u][0].first;
	ffor(i,1,pre[u].size()-1) {
		if(pre[u][i].second==pre[u][i-1].second+1) {
			pre[u][i].first=node(pre[u][i-1].first+dp[u][i].first);
		}
		else {
			int t=r-l+2;
			ffor(j,1,t) X[j]=pre[u][i-t+j-1].second,V[j]=pre[u][i-t+j-1].first;
			pre[u][i].first=node(lag(t,pre[u][i].second-1)+dp[u][i].first);
		}
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n,node.init(MOD),frac[0]=1;
	ffor(i,1,n) cin>>a[i]>>b[i];
	ffor(i,1,n+1) frac[i]=node(1ll*frac[i-1]*i);
	
	inv[n+1]=qpow(frac[n+1],MOD-2);
	roff(i,n,0) inv[i]=node(1ll*inv[i+1]*(i+1));
	solve(1,n);
	int v=gid[1][n];
	cout<<(pre[v][pre[v].size()-1].first%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：翼德天尊 (赞：1)

先想方案合法条件。

**分析显著性质。** 不难发现根据题目设置，**一个区间真正的最大值实际上是最大值中最靠右的那个**。最大值的意义是，在这个区间中，只有从最大值走，才能走完这个区间，从其它地方走，一定会被最大值所拦截。于是最大值就将整个区间分割成了两个独立的部分——考虑区间 dp。

设 $dp_{l,r,k}$ 表示区间 $[l,r]$ 中最大值为 $k$ 的方案数，由于只要求最大值不超过，所以不妨前缀和优化，设 $dp_{l,r,k}$ 表示区间 $[l,r]$ 中最大值不超过 $k$ 的方案数，则有转移方程：
$$
dp_{l,r,k}=\sum_{l\le p\le r} dp_{l,p-1,k-1}\times dp_{p+1,r,k}
$$
时间复杂度 $O(n^3w)$.

**状态数优化。** **以后 dp 类题目都可以想想能不能这样优化的（**，我们发现对于一个区间，它只会从较为中间的 $p$ 进行转移，即许多子区间最后一定是不会被转移到 $[1,n]$ 的，于是我们可以进行一个打表，发现合法区间数在 $m=2500$ 左右（$n=299$ 时可以取到 $2541$），可以记忆化搜索找出所有这样的区间并编号，按照区间长度排序，然后新设 $dp_{i,k}$ 表示第 $i$ 个区间最大值不超过 $k$ 时的方案数，时间复杂度 $O(mw)$，发现 $w$ 是大大的瓶颈。

值域太大，快用插值！

**拉格朗日插值优化。** 我们由衷地希望这个 dp 方程是个关于值域的多项式，不然方程内带值域没法做了啊。然后看看转移方程，欸确实，长度为 $x$ 的区间方案数确实是一个 $x$ 次的多项式（乘积项长度之和为 $len-1$，求和升一次，刚好为 $len$）。又因为每个柱子存在值域区间，所以不妨将所有柱子的值域区间整合到一块，分段进行 dp+拉插，注意 $a,b$ 需要写成 $[a,b+1)$ 这样左闭右开的形式，分段时才可以左闭右开的分段。对于每一段，位于值域区间的柱子直接 dp，不位于的方案数直接为 $0$，每段 dp 时间复杂度为 $O(nm)$，对每个柱子拉插做到 $O(nm)$，一共 $O(n)$ 段，时间复杂度即为 $O(n^2m)$。

**关于卡常优化。** 每段算完后，一遍拉插即可，而不是傻乎乎地拉插 $n$ 次，会优化很大的常数；除此之外就是一些关于加法取模的优化，就不细说了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=305;
const int M=3005;
const int mod=1e9+7;
int n,a[N],b[N],id[N][N],dtot,dp[M][N],lsh[N<<1],ltot,c[N],jc[N],inv[N],fy[N],qz[N],hz[N];
struct node{
    int l,r;
}d[M];
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while (ch>'9'||ch<'0') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
inline int bmod(int x){
    return (x>=mod)?x-mod:x;
}
void dfs(int l,int r){
    if (l>r||id[l][r]) return;
    id[l][r]=++dtot,d[dtot].l=l,d[dtot].r=r;
    int len=r-l+1,p=l+r>>1;
    if (len&1){
        dfs(l,p-2),dfs(l,p-1),dfs(l,p);
        dfs(p,r),dfs(p+1,r),dfs(p+2,r);
    }else{
        dfs(l,p-1),dfs(l,p);
        dfs(p+1,r),dfs(p+2,r);
    }
}
inline int ksm(int x,int k){
    int ans=1;
    while (k){
        if (k&1) ans=1ll*ans*x%mod;
        x=1ll*x*x%mod;
        k>>=1;
    }
    return ans;
}
inline bool cmp(node x,node y){
    return (x.r-x.l)<(y.r-y.l);
}
inline void Lg(int len,int k){
    qz[0]=hz[len+1]=1;
    for (int i=1;i<=len;i++) qz[i]=1ll*qz[i-1]*(k-i)%mod;
    for (int i=len;i>=1;i--) hz[i]=1ll*hz[i+1]*(k-i)%mod;
    for (int i=1;i<=len;i++){
        c[i]=1ll*qz[i-1]*hz[i+1]%mod*fy[len-i]%mod*inv[i-1]%mod*inv[len-i]%mod;
    }
}
inline void init(int V){
    jc[0]=inv[0]=fy[0]=1;
    for (int i=1;i<=V;i++) jc[i]=1ll*jc[i-1]*i%mod;
    inv[V]=ksm(jc[V],mod-2);
    for (int i=V-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
    for (int i=1;i<=V;i++) fy[i]=bmod(-fy[i-1]+mod);
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    // freopen("out.out","w",stdout);
#endif
    // freopen("robot.in","r",stdin);
    // freopen("robot.out","w",stdout);
    // double t=clock();
    n=read();
    init(n+2);
    for (int i=1;i<=n;i++) lsh[++ltot]=a[i]=read(),lsh[++ltot]=b[i]=read()+1;
    sort(lsh+1,lsh+1+ltot);
    ltot=unique(lsh+1,lsh+1+ltot)-lsh-1;
    for (int i=1;i<=n;i++) a[i]=lower_bound(lsh+1,lsh+1+ltot,a[i])-lsh,b[i]=lower_bound(lsh+1,lsh+1+ltot,b[i])-lsh;
    // puts("ok");
    dfs(1,n);
    sort(d+1,d+1+dtot,cmp);
    for (int i=1;i<=dtot;i++) id[d[i].l][d[i].r]=i;
    // for (int i=0;i<=n+1;i++) dp[0][i]=1;
    for (int i=1;i<ltot;i++){
        int len=lsh[i+1]-lsh[i];
        if (len>n+1) len=n+1;
        for (int j=1;j<=dtot;j++){
            if (d[j].l==d[j].r){
                if (a[d[j].l]<=i&&i<b[d[j].l]) 
                    for (int k=1;k<=len;k++) dp[j][k]=1;
            }else{
                int len2=d[j].r-d[j].l+1,s=d[j].l+d[j].r>>1;
                if (len2&1){
                    if (a[s-1]<=i&&i<b[s-1]) 
                        if (s-2>=d[j].l)
                            for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+1ll*dp[id[d[j].l][s-2]][k]*dp[id[s][d[j].r]][k-1]%mod);
                    if (a[s]<=i&&i<b[s]) 
                        if (s-1>=d[j].l&&s+1<=d[j].r) 
                            for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+1ll*dp[id[d[j].l][s-1]][k]*dp[id[s+1][d[j].r]][k-1]%mod);
                    if (a[s+1]<=i&&i<b[s+1])
                        if (s+2<=d[j].r) 
                            for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+1ll*dp[id[d[j].l][s]][k]*dp[id[s+2][d[j].r]][k-1]%mod);
                }else{
                    if (a[s]<=i&&i<b[s]) 
                        if (s-1>=d[j].l) 
                            for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+1ll*dp[id[d[j].l][s-1]][k]*dp[id[s+1][d[j].r]][k-1]%mod);
                    if (a[s+1]<=i&&i<b[s+1]) 
                        if (s+2<=d[j].r) 
                            for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+1ll*dp[id[d[j].l][s]][k]*dp[id[s+2][d[j].r]][k-1]%mod);
                }
                if (len2<=3&&a[d[j].r]<=i&&i<b[d[j].r]) 
                    for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+dp[id[d[j].l][d[j].r-1]][k]);
                if (len2<=3&&a[d[j].l]<=i&&i<b[d[j].l]) 
                    for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+dp[id[d[j].l+1][d[j].r]][k-1]);
            }
            // for (int s=d[j].l;s<=d[j].r;s++)
            //     for (int k=1;k<=len;k++)
            //         if (abs(s-d[j].l-(d[j].r-s))<=2&&a[s]<=i&&i<b[s]) dp[j][k]=bmod(dp[j][k]+1ll*dp[id[d[j].l][s-1]][k]*dp[id[s+1][d[j].r]][k-1]%mod);
            for (int k=1;k<=len;k++) dp[j][k]=bmod(dp[j][k]+dp[j][k-1]);
        }
        // cout<<"--"<<i<<"--:"<<"\n";
        if (lsh[i+1]-lsh[i]==len){
            // cout<<lsh[i]<<" "<<lsh[i+1]<<" "<<len<<'\n';
            // puts("left");
            for (int j=1;j<=dtot;j++) dp[j][0]=dp[j][len];///cout<<d[j].l<<" "<<d[j].r<<" "<<dp[j][0]<<"\n";
        }else{
            // puts("right");
            // for (int j=1;j<=dtot;j++){
            Lg(n+1,lsh[i+1]-lsh[i]);//,cout<<d[j].l<<" "<<d[j].r<<" "<<dp[j][0]<<"\n";
            for (int j=1;j<=dtot;j++){
                dp[j][0]=0;
                for (int k=1;k<=len;k++) dp[j][0]=bmod(dp[j][0]+1ll*c[k]*dp[j][k]%mod);
            }
            // }
        }// puts("");
        for (int j=1;j<=dtot;j++)
            for (int k=1;k<=len;k++)
                dp[j][k]=0;
    }
    // cout<<(clock()-t)/CLOCKS_PER_SEC<<"\n";
    cout<<dp[id[1][n]][0]<<"\n";
    return 0;
}
```

---

## 作者：RainWetPeopleStart (赞：0)

## 朴素 DP

考虑从最大值入手，设最大值的位置为 $p$，有多个则取最大的。

则此时 $p$ 左边和 $p$ 右边互不影响，变成了两个子问题，可以依此做 DP。

记 $f_{l,r,v}$ 表示考虑到区间 $[l,r]$，最大值是 $v$ 的方案数，有转移 $f_{l,r,v}=\sum\limits_{l\le k\le r}[|(k-l)-(r-k)|\le 2](\sum\limits_{a\le v}f_{l,k-1,a})(\sum\limits_{a< v}f_{k+1,r,a})$。

初值 $f_{a,a-1,0}=1$，对 $x\in [A_a,B_a]$ 有 $f_{a,a,x}=1$。

考虑用前缀和的形式表示出 $f$，即 $f_{l,r,v}$ 表示考虑到区间 $[l,r]$，最大值不超过 $v$ 的方案数，转移变为 $f_{l,r,v}=f_{l,r,v-1}+\sum\limits_{l\le k\le r}[|(k-l)-(r-k)|\le 2]f_{l,k-1,v}f_{k+1,r,v-1}$。

此时答案为 $f_{1,n}$。

## 优化

发现有很多的 $[l,r]$ 无法转移到 $[1,n]$，具体的，通过记搜，有效的 $[l,r]$ 只有 $2500$ 个左右，记作 $S$。

这样复杂度是 $O(SnV)$ 的。

## 特殊性质

此时，DP 状态肯定不能和 $V$ 挂钩，考虑用函数的形式表示出 $f_{l,r,*}$，此时转移等价于 $f_{l,r}(x)=\sum\limits_{l\le k\le r}[|(k-l)-(r-k)|\le 2]f_{l,k-1}(x)f_{k+1,r}(x-1)$，然后做一遍前缀和即可。

不难发现此时 $f_{l,r}(x)$ 是 $r-l+1$ 次多项式，维护 $n+1$ 个点值即可。

复杂度 $O(Sn)$。

## 正解

考虑离散化，分成 $O(n)$ 个值域连续段，每一段内跑上文的插值优化 DP。

再考虑值域连续段的合并，设当前考虑连续段 $[L,R]$，一个思路就是维护 $g_{l,r}$ 表示当前的方案数，可以把 $f_{l,r}(0)$ 设为 $g_{l,r}$，这样就成功的处理了跨连续段的转移。最后在插值求出 $g$ 即可。

通过预处理实现 $O(n)$ 插值，复杂度 $O(Sn^2)$，可以通过。


```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define mk make_pair
using namespace std;
const int N=330,mod=1e9+7;
void Add(int &a,int b){a+=b;if(a>=mod) a-=mod;}
int qp(int a,int b){
    int x=1;
    while(b){
        if(b&1) x=1ll*x*a%mod;
        b>>=1;a=1ll*a*a%mod;
    }return x;
}
int ps[N],ng[N],pr[N],sf[N];
int lag(int x,int *arr,int n){
    int ans=0;
    pr[0]=(mod+x)%mod,sf[n]=(mod+x-n)%mod;
    for(int i=1;i<=n;i++) pr[i]=1ll*pr[i-1]*(mod+x-i)%mod;
    for(int i=n-1;i>=0;i--) sf[i]=1ll*sf[i+1]*(mod+x-i)%mod;
    for(int i=0;i<=n;i++){
        int now=arr[i];
        now=1ll*now*ps[i-0]%mod*ng[n-i]%mod;
        if(i!=0) now=1ll*now*pr[i-1]%mod;
        if(i!=n) now=1ll*now*sf[i+1]%mod;
        Add(ans,now);
    }return ans;
}
int n,A[N],B[N];
const int MS=N*12;
int to[N][N];
int f[MS][N],g[MS],len[MS];
int tot=0;
struct edge{int pl,pr,ps;};
vector<int> E[MS];
void bd(int l,int r){
    if(to[l][r]) return ;
    to[l][r]=++tot;len[tot]=r-l+1;
    for(int i=l;i<=r;i++){
        if(abs((i-l)-(r-i))>2) continue;
        bd(l,i-1);bd(i+1,r);
        E[to[l][r]].push_back(i);
    }
}
int L,R,LM;
bool vis[MS];
void init(){
    ps[0]=1;ng[0]=1;
    for(int i=1;i<=n;i++){
        ps[i]=1ll*ps[i-1]*qp(i,mod-2)%mod;
        ng[i]=1ll*ng[i-1]*qp(mod-i,mod-2)%mod;
    }
    memset(f,0,sizeof(f));
    memset(vis,0,sizeof(vis));
    LM=n;
    for(int i=1;i<=n;i++){
        int s=to[i][i];
        if(!s) continue;
        f[s][0]=g[s];
        int o=(A[i]<=L)&&(R<=B[i]);
        for(int j=1;j<=LM;j++)
            f[s][j]=(f[s][j-1]+o)%mod;
        vis[s]=1;
    }
    for(int i=1;i<=n+1;i++){
        int s=to[i][i-1];
        if(!s) continue;
        for(int j=0;j<=LM;j++)
            f[s][j]=1;
        vis[s]=1;
    }
}
void DP(int l,int r){
    int s=to[l][r];
    if(vis[s]) return ;
    for(auto ed:E[s]){
        int ls=to[l][ed-1],rs=to[ed+1][r];
        DP(l,ed-1);DP(ed+1,r);
        if(L<A[ed]||B[ed]<R) continue;
        for(int i=1;i<=LM;i++){
            Add(f[s][i],1ll*f[ls][i]*f[rs][i-1]%mod);
        }
    }
    for(int i=1;i<=LM;i++) Add(f[s][i],f[s][i-1]);
    for(int i=0;i<=LM;i++) Add(f[s][i],g[s]);
    //cout<<l<<' '<<r<<' '<<g[s]<<' '<<f[s][0]<<' '<<f[s][1]<<endl;
    vis[s]=1;
}
int tv[N<<1];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>A[i]>>B[i];
    }bd(1,n);
    map<int,int> mp;
    for(int i=1;i<=n;i++)
        mp[A[i]]=1,mp[B[i]+1]=1;
    int cnt=0;
    for(auto &ed:mp) ed.se=++cnt,tv[cnt]=ed.fi;
    for(int i=1;i<cnt;i++){
        L=tv[i],R=tv[i+1]-1;
        init();DP(1,n);
        for(int j=1;j<=tot;j++)
            g[j]=lag(R-L+1,f[j],len[j]);
    }cout<<g[to[1][n]]<<endl;
    return 0;
}
```

---


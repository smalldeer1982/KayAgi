# [NOI2019] 序列

## 题目描述

给定两个长度为 $n$ 的正整数序列 $\{a_i\}$ 与 $\{b_i\}$，序列的下标为 $1, 2, \cdots , n$。现在你需要分别对两个序列各指定**恰好** $K$ 个下标，要求**至少**有 $L$ 个下标在两个序列中都被指定，使得这 $2K$ 个下标在序列中对应的元素的总和**最大**。

形式化地说，你需要确定两个长度为 $K$ 的序列 $\{c_i\}, \{d_i\}$，其中
$1 \leq c_1 < c_2 < \cdots < c_K \leq n , 1 \leq d_1 < d_2 < \cdots < d_K \leq n$

并要求 $\left \lvert \{c_1, c_2, \cdots , c_K\} \cap \{d_1, d_2, · · · , d_K\} \right \rvert \geq L$

目标是最大化 $\sum^{K}_{i=1} a_{c_i} +\sum^{K}_{i=1} b_{d_i}$

## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。

#### 样例 3

见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。

### 样例 1 解释

第一组数据选择的下标为：$\{c_i\} = \{1\} , \{d_i\} = \{1\}$。

第二组数据选择的下标为：$\{c_i\} = \{1, 3\} , \{d_i\} = \{2, 3\}$

第三组数据选择的下标为：$\{c_i\} = \{3, 4\} , \{d_i\} = \{3, 5\}$。

第四组数据选择的下标为：$\{c_i\} = \{2, 3, 4, 6\} , \{d_i\} = \{2, 3, 4, 6\}$。

第五组数据选择的下标为：$\{c_i\} = \{2, 3, 4, 5, 6\} , \{d_i\} = \{1, 2, 3, 4, 6\}$。

### 数据范围

对于所有测试点：$T \leq 10 , 1 \leq \sum n \leq 10^6, 1 \leq L \leq K \leq n \leq 2 \times 10^5, 1 \leq a_i, b_i \leq 10^9$。

::cute-table{tuack}

| 测试点编号 | $n\le$ | $\sum n \le$ |
| :----------: | :----------: | :----------: |
| $1\sim3$ | $10$ | $3\times 10^5$ |
| $4\sim5$ | $18$ | ^ |
| $6\sim7$ | $30$ | ^ |
| $8\sim10$ | $150$ | ^ |
| $11\sim16$ | $2\times 10^3$ | ^ |
| $17\sim21$ | $2\times 10^5$ | ^ |
| $22\sim25$ | ^ | $10^6$ |

## 样例 #1

### 输入

```
5
1 1 1
7
7
3 2 1
4 1 2
1 4 2
5 2 1
4 5 5 8 4
2 1 7 2 7
6 4 1
1 5 8 3 2 4
2 6 9 3 1 7
7 5 4
1 6 6 6 5 9 1
9 5 3 9 1 4 2```

### 输出

```
14
12
27
45
62
```

# 题解

## 作者：s_r_f (赞：117)

同步赛当场降智了，认为贪心是假的。。。。然后。。。。就写了个暴力。。。。

开题一看，这不是~~模拟~~费用流吗？

然而这个费用流并不显然。。。。所以我当时~~放弃了T3部分分~~没想~~到~~。

当然也希望这个题解能让大家懂得**什么是真正的模拟费用流**啦

# Part1:费用流

大概是这么一张图……

![](https://cdn.luogu.com.cn/upload/pic/64127.png)

正确性嘛……就是如果选下标不同的一对数的话必须走$C -> D$ 这条路径

那么就保证了下标不同的数的对数会$<= K - L$,那么相同的就至少有$L$对了。

然后你按上述方法建图，写个费用流就可以拿到$n = 150$或者$n = 2000$的分了。

# Part2:贪心(模拟费用流)

考虑一点一点的增加流量。

如果弧$CD$没有流满，我们就流弧$CD$，因为它的选择最“自由”，得到的答案也最优。

怎么流最优呢？当然是**当前没有被选中的数中，A/B各取一个max**

当然**如果我们选的数中有下标相等的，就不用占据弧CD的流量了**，这个需要注意。

在弧$CD$流满之后，我们考虑增加其他弧的流量，也就是要组成**新的一对下标相等的数**

首先我们可以直接**找一个AB都没被选过的下标，选出一个$A_i+B_i$ 最大的**，反映到图上就是把 $S->A_i ->B_i ->T$ 流一遍

我们还可以给一个已经选中的$A$找一个$B$和它配对，然后你会发现这会使得$C$少一点流量，所以我们要给$C$一点流量，不然就不满足流量平衡了

所以我们还得再找一个**最大的没选过的**$A$……

同样的我也可以给一个**没配过对的**$B$配对，再补一个最大的$B$上去……

反映到图上，就是把一条$A_i->C$的流量撤回，改为从$A_i->B_i->T$

然后换一个$A_j$补上，流一下$S - >A_j - >C$这条边。

**过程中如果发现弧CD可以不流满，比如上述配对的过程中如果配出了两对的话，我们就在剩下的A和B中分别选取一个最大值，保证CD流满。**

这个就是一些人的贪心……在此处orz@_rqy提供的贪心思路……

不过我把它用费用流的角度解释的话……它就是模拟费用流呀！

所以这个贪心（模拟费用流）是正确的！

# Part3：代码

然后我们发现我们只要求一个最大值……用堆维护就可以了……

(代码行数有点多，勿喷)

代码里有详细注释~~~

```cpp

// F1,F2表示可以用来做配对操作的堆，H1，H2表示A、B两个数组中剩余的数
// H3存的是A、B都没选的那些i(也是堆)
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
    static int x; x = 0; static char c; c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
    return x;
}
inline void write(LL x){ if (x > 9) write(x/10); putchar(x%10+'0'); }
inline void writeln(LL x){ write(x),putchar('\n'); }

const int N = 1000050;
LL ans;
int T,n,L,K,a[N],b[N],s[N]; // 0 -> () 1 -> (a) 2 -> (b) 3 -> (ab)

int id[N];
inline bool cmpa(int x,int y){ return a[x] > a[y]; }
inline bool cmpb(int x,int y){ return b[x] > b[y]; }
inline void work(int m){
	ans = 0;
	static int i; 
	for (i = 1; i <= n; ++i) id[i] = i;
	sort(id+1,id+n+1,cmpa); for (i = 1; i <= m; ++i) ++s[id[i]],ans += a[id[i]];
	sort(id+1,id+n+1,cmpb); for (i = 1; i <= m; ++i) s[id[i]] += 2,ans += b[id[i]];
}

struct NodeA{ int id; bool operator < (const NodeA x) const{ return a[id] < a[x.id]; } }tmp1;
struct NodeB{ int id; bool operator < (const NodeB x) const{ return b[id] < b[x.id]; } }tmp2;
struct NodeAB{ int id; bool operator < (const NodeAB x) const{ return a[id] + b[id] < a[x.id] + b[x.id]; } }tmp3;
priority_queue<NodeA>H1,F1;
priority_queue<NodeB>H2,F2;
priority_queue<NodeAB>H3;

int main(){
	LL v1,v2,v3,vmx;
	int i,j,now,c1,c2;
	T = read();
	while (T--){
		n = read(),K = read(),L = read();
		for (i = 1; i <= n; ++i) a[i] = read();
		for (i = 1; i <= n; ++i) b[i] = read(),s[i] = 0;
		work(K-L); //实际操作中我并没有选择流满CD，只是先流K-L
		
		while (!H1.empty()) H1.pop();
		while (!F1.empty()) F1.pop();
		while (!H2.empty()) H2.pop();
		while (!F2.empty()) F2.pop();
		while (!H3.empty()) H3.pop();
		now = 0;
		for (i = 1; i <= n; ++i){
			if (!s[i]){
				tmp1.id = i,H1.push(tmp1);
				tmp2.id = i,H2.push(tmp2);
				tmp3.id = i,H3.push(tmp3);
			}
			else if (s[i] == 1) tmp2.id = i,H2.push(tmp2),F2.push(tmp2);
			else if (s[i] == 2) tmp1.id = i,H1.push(tmp1),F1.push(tmp1);
			else ++now;
        //A、B都选了的，我会计到now中去，now表示CD弧剩余的流量。
		}
		
		while (L--){ //每次增加一点流量
			while (!H1.empty() && (s[H1.top().id] & 1)) H1.pop();
			while (!F1.empty() && (s[F1.top().id] ^ 2)) F1.pop();
			while (!H2.empty() && (s[H2.top().id] & 2)) H2.pop();
			while (!F2.empty() && (s[F2.top().id] ^ 1)) F2.pop();
			while (!H3.empty() && s[H3.top().id]) H3.pop();
			
			if (now){ //如果CD弧有流量，就选两个最大值
				--now;
				i = H1.top().id,j = H2.top().id;
				ans += a[i] + b[j];
				s[i] |= 1,s[j] |= 2;
				if (s[i] ^ 3) tmp2.id = i,F2.push(tmp2);
				if (s[j] ^ 3) tmp1.id = j,F1.push(tmp1); 
				
				if (i == j) ++now;
				else{
					if (s[i] == 3) ++now; 
					if (s[j] == 3) ++now; 
				}
				continue;
			}
			
			v1 = v2 = v3 = c1 = c2 = 0;
			if (!F2.empty()){ //给B配对
				i = H1.top().id,j = F2.top().id; v1 = a[i] + b[j]; c1 = s[i] != 2 ? 1 : 0;
			}
			if (!F1.empty()){ //给A配对
				i = F1.top().id,j = H2.top().id; v2 = a[i] + b[j]; c2 = s[j] != 3 ? 1 : 0;
			}
			if (!H3.empty()){ i = H3.top().id,v3 = a[i] + b[i]; } //选一对A+B
			vmx = max(v1,max(v2,v3));
			ans += vmx;
			
			
			if (v1 == v2 && v1 == vmx){ 
         //解释一下这个判断：
         //因为在费用相同时，给CD弧增加空余的流量是比较优的
         //所以我还比较了c1和c2(优先给CD弧增加空余流量)
				if (c1 >= c2){
					i = H1.top().id,j = F2.top().id;
					s[i] |= 1,s[j] |= 2;
					if (s[i] ^ 3) tmp2.id = i,F2.push(tmp2); else ++now;
				}
				else{
					i = F1.top().id,j = H2.top().id;
					s[i] |= 1,s[j] |= 2;
					if (s[j] ^ 3) tmp1.id = j,F1.push(tmp1); else ++now;					
				}
				continue;
			}
			if (v1 == vmx){
				i = H1.top().id,j = F2.top().id;
				s[i] |= 1,s[j] |= 2;
				if (s[i] ^ 3) tmp2.id = i,F2.push(tmp2); else ++now;
				continue;
			}
			if (v2 == vmx){
				i = F1.top().id,j = H2.top().id;
				s[i] |= 1,s[j] |= 2;
				if (s[j] ^ 3) tmp1.id = j,F1.push(tmp1); else ++now;
				continue;
			}
			if (v3 == vmx) {i = H3.top().id,H3.pop(),s[i] = 3; continue;}
		}
		
		writeln(ans);
	}
    return 0;
}
```

$Upd:$ 对不起了管理员……不会写题解改了好多次……麻烦审题解的管理员了qwq……

---

## 作者：command_block (赞：63)

更严谨的正确性分析。

更自然的非启发式思路。

更强的扩展性。

**广告** ： 

- [模拟费用流小记](https://www.luogu.com.cn/blog/command-block/mu-ni-fei-yong-liu-xiao-ji) （建议阅读）

- [NOI2019 简要题解](https://www.luogu.com.cn/blog/command-block/noi2019-jian-yao-ti-xie)

------------

**题意** : 给定两个长度为 $n$ 的正整数序列 $\{a_i\}$ 与 $\{b_i\}$。
  
分别对两个序列各指定**恰好** $K$ 个下标，要求**至少**有 $L$ 个下标在两个序列中都被指定，使得这 $2K$ 个下标在序列中对应的元素的总和**最大**。

多组数据， $T\leq 10,n\leq 2\times 10^5,\sum n\leq 10^6$。

------------

- **费用流模型**

至少有 $L$ 个下标相同，即至多有 $K-L$ 个下标不同。

- 对每个 $i$ :

  连边 $S\rightarrow a_i$ ，容量为 $1$ ，边权为 $a_i$。
  
  连边 $b_i\rightarrow T$ ，容量为 $1$ ，边权为 $b_i$。
  
  连边 $a_i\rightarrow b_i$ ，无权，表示选择一对相同的下标。
  
新建点 $U,V$ ，连边 $U\rightarrow V$ ，无权，容量为 $K-L$ （称为自由流量），表示不同的下标。

对每个 $i$ ，连边 $a_i\rightarrow U,\ V\rightarrow b_i$。

限制流量为 $K$ ，求解最大费用最大流即可。

直接跑费用流可以获得 $40\sim 64$ 分。

------------

- **模拟费用流**

首先观察建图 :

![](https://cdn.luogu.com.cn/upload/image_hosting/5863chlh.png)

除了和 $S,T$ 直接相连的边以外，其他边的边权均为 $0$。

考虑直接模拟 EK 算法的过程。

所有和 $S,T$ 直接相连的边不会退流（可以忽略反向边），而中间的边可能因为退流而发生方向的改变（添加）。

考虑所有可能的增广路形态，以及它们的实际意义。

由于同一个点至多经过一次，增广路形态不会很多。

![](https://cdn.luogu.com.cn/upload/image_hosting/xe956808.png)

其中红色为增广路。

![](https://cdn.luogu.com.cn/upload/image_hosting/o0hmwgac.png)

其中红色为新选择的点，黑色为已选的点。绿色边为原来的配对，红色边为新的配对。

具体方案如下。记这一轮选择一对 $(a_i,b_j)$。

- ① : $i=j$。

- ② : $i\neq j$ ，消耗一单位自由流量。

- ③ : 将 $a_i$ 与 $b_i$ （必须已选）配对，将 $b_j$ 与 $a_j$ （必须已选） 配对。增加一单位自由流量。

- ④ ：将 $a_i$ 与 $b_i$ （必须已选）配对，将 $b_j$ 与原来与 $b_i$ 配对的 $a_k$ 配对。

- ⑤ ：将 $b_i$ 与 $a_i$ （必须已选）配对，将 $a_j$ 与原来与 $a_i$ 配对的 $b_k$ 配对。

单观察图的话，还可能有下面的这种增广路 ：

![](https://cdn.luogu.com.cn/upload/image_hosting/tgoycu71.png)

（此时 $u,v$ 都被经过了，故不可能有更复杂的增广路）

考虑这类增广路的实际意义，如右图。其中绿色是原来的连接情况，红色是后来的连接情况。

然而，总是存在更优的连接方式（如蓝色），故这类增广路不优。

我们用堆维护上述五种转移。

两侧分别用两个堆 $q_a,q_b$ 维护未选的数的 $\max$。

用堆 $q$ 维护未选的数的 $a_i+b_i$ 的 $\max$。

再用两个堆 $q_a',q_b'$ 维护“本侧未选中，但另一侧选中”的数的 $\max$。

记 $q,q_a,q_b,q_a',q_b'$ 堆顶为 $s,a,b,a',b'$。（若不存在则为 $-\infty$）

- ① ： $s$。

- ② ： $a+b$。当有自由流量时才生效。

- ③ ： $a'+b'$。自由流量加一。

- ④ ： $a'+b$。

- ⑤ ： $a+b'$。

五种方案取 $\max$ 即可。

复杂度为 $O(n\log n)$。

理清思路后代码非常好写。

```cpp
#include<algorithm>
#include<cstdio>
#include<queue>
#define Pr pair<int,int>
#define fir first
#define sec second
#define mp make_pair
#define ll long long
#define MaxN 200500
using namespace std;
const int INF=1000000000;
priority_queue<Pr> q,qa,qb,qa2,qb2;
int n,k,l,a[MaxN],b[MaxN];
bool visa[MaxN],visb[MaxN];
void seta(int p)
{visa[p]=1;if (!visb[p])qb2.push(mp(b[p],p));}
void setb(int p)
{visb[p]=1;if (!visa[p])qa2.push(mp(a[p],p));}
void solve()
{
  scanf("%d%d%d",&n,&k,&l);l=k-l;
  for (int i=1;i<=n;i++)scanf("%d",&a[i]);
  for (int i=1;i<=n;i++)scanf("%d",&b[i]);
  for (int i=1;i<=n;i++){
    visa[i]=visb[i]=0;
    q.push(mp(a[i]+b[i],i));
    qa.push(mp(a[i],i));
    qb.push(mp(b[i],i));
  }
  q.push(mp(-INF,0));
  qa.push(mp(-INF,0));qb.push(mp(-INF,0));
  qa2.push(mp(-INF,0));qb2.push(mp(-INF,0));
  ll ans=0;
  for (int i=1;i<=k;i++){
    while(visa[q.top().sec]||visb[q.top().sec])q.pop();
    while(visa[qa.top().sec])qa.pop();
    while(visb[qb.top().sec])qb.pop();
    while(visa[qa2.top().sec])qa2.pop();
    while(visb[qb2.top().sec])qb2.pop();
    Pr now=q.top(),nowa=qa.top(),nowb=qb.top();
    int op=1,mx=now.fir;
    Pr nowa2=qa2.top(),nowb2=qb2.top();
    if (mx<nowa2.fir+nowb2.fir){
      mx=nowa2.fir+nowb2.fir;
      op=3;
    }
    if (mx<nowa2.fir+nowb.fir){
      mx=nowa2.fir+nowb.fir;
      op=4;
    }
    if (mx<nowa.fir+nowb2.fir){
      mx=nowa.fir+nowb2.fir;
      op=5;
    }
    if (nowa.sec!=nowb.sec&&l)
      if (mx<nowa.fir+nowb.fir){
        mx=nowa.fir+nowb.fir;
        op=2;
      }
    ans+=mx;
    if (op==1){seta(now.sec);setb(now.sec);}
    if (op==2){seta(nowa.sec);setb(nowb.sec);l--;}
    if (op==3){seta(nowa2.sec);setb(nowb2.sec);l++;}
    if (op==4){seta(nowa2.sec);setb(nowb.sec);}
    if (op==5){seta(nowa.sec);setb(nowb2.sec);}
  }
  printf("%lld\n",ans);
  while(!q.empty())q.pop();
  while(!qa.empty())qa.pop();while(!qb.empty())qb.pop();
  while(!qa2.empty())qa2.pop();while(!qb2.empty())qb2.pop();
}
int main()
{
  freopen("sequence3.in","r",stdin);
  int T;scanf("%d",&T);
  while(T--)solve();
  return 0;
}
```

---

## 作者：seajupiter (赞：63)

论在看不懂题解的时候如何化悲愤为力量……

**本篇题解会尽可能细致具体地解释思路和写法，并顺带提一下我自己调试过程发现的一些代码细节，希望能帮到大家。**（希望亲爱的管理员通过一下哈）

**算法：贪心模拟费用流**

# 费用流做法

这个题的费用流做法已经有两篇题解都讲到了，最关键的思路点就在于把 **“必须至少有 $L$ 对下标相同”** 这个条件转化成 **“最多有 $K-L$ 对下标不相同”**。这应该也是本题最关键的突破点了。想到了这一点，相信能去参加NOI的选手们都不难想到建图变成类似于二分图的匹配模型，然后用费用流解决。

然而很显然时间复杂度过高，你的费用流是不大可能跑过所有数据的。实际上普通的spfa求最短路的MCMF算法就可以轻松拿到64分（~~当然如果你在luogu评测机上跑就别想了QAQ~~）。所以这道题的部分分给的还是挺友善的了。

LOJ 64分代码（如果你去LOJ提交要记得加上文件输入输出哦）：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll; 

template<typename T> inline void read(T &x){
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}

const int MAXN=2e5+5;
int T, n, m1, m2;
ll a[MAXN], b[MAXN];

namespace NF{
	const int N=4e3+5, V=N<<1, E=V*20;
	int s, t, head[V], e, to[E], fl[E], dis[E], nxt[E];
	int flow[E], pv[V], pe[V];
	ll d[E], MC, MF;
	
	inline void init(int _s, int _t){
		e=1;
		s=_s, t=_t;
		memset(head, 0, sizeof(head));
	}
	
	inline void add_path(int u, int v, int w, ll c){
		to[++e]=v, fl[e]=w, dis[e]=c;
		nxt[e]=head[u], head[u]=e;
	}
	
	inline void add_edge(int u, int v, int w, ll c){
		add_path(u, v, w, c);
		add_path(v, u, 0, -c);
	}
	
	inline bool spfa(){
		static bool inq[N];
		static queue<int> q;
		memset(d, 0x3f, sizeof(d));
		d[s]=pv[s]=pv[t]=0;
		flow[s]=0x3f3f3f3f;
		q.push(s);
		inq[s]=true;
		while(!q.empty()){
			int u=q.front(); q.pop(), inq[u]=false;
			for(int i=head[u]; i; i=nxt[i]) if(fl[i]){
				int v=to[i], w=fl[i], c=dis[i];
				if(d[v]>d[u]+c){
					d[v]=d[u]+c;
					flow[v]=min(flow[u], w);
					pv[v]=u, pe[v]=i;
					if(!inq[v]){
						q.push(v);
						inq[v]=true;
					}
				}
			}
		}
		return pv[t];
	}
	
	inline ll MCMF(){
		MF=MC=0;
		while(spfa()){
			int tmp=flow[t];
			MF+=tmp;
			MC+=1ll*tmp*d[t];
			for(int u=t; pv[u]; u=pv[u]){
				int i=pe[u];
				fl[i]-=tmp;
				fl[i^1]+=tmp;
			}
		}
		return MC;
	}
}

namespace bruteforce{
	int main(){
		int s=n*2+1, t=n*2+2, _s=n*2+3, p1=n*2+4, p2=n*2+5;
		NF::init(s, t);
		NF::add_edge(s, _s, m1, 0);
		NF::add_edge(p1, p2, m1-m2, 0);
		for(int i=1; i<=n; ++i){
			NF::add_edge(_s, i, 1, -a[i]);
			NF::add_edge(i, p1, 1, 0);
			NF::add_edge(i+n, t, 1, -b[i]);
			NF::add_edge(p2, i+n, 1, 0);
			NF::add_edge(i, i+n, 1, 0);
		}
		printf("%lld\n", -NF::MCMF());
		return 0;
	}
}

int main(){
//	freopen("sequence.in", "r", stdin);
//	freopen("sequence.out", "w", stdout);
	read(T);
	while(T--){
		read(n);read(m1);read(m2);
		for(int i=1; i<=n; ++i)
			read(a[i]);
		for(int i=1; i<=n; ++i)
			read(b[i]);
		if(n<=2000) bruteforce::main();
	}
	return 0;
}
```


# 贪心模拟费用流

如何提高费用流效率？我们有个叫“模拟费用流”的东西。说白了，我对模拟费用流的理解就是，在特殊条件允许下，**用贪心来取代spfa找最短路，用各种手段（代价取反、分类讨论等等）来模拟退流过程**。

那么来看一下这道题如何模拟费用流。

- 首先，不难得出，**“自由流”也就是随意配对的方案一定不会比其他方案更劣**，那么我们在能流自由流的时候就流自由流。

如何模拟流自由流？显然在还未被配对的 $a$ 和 $b$ 里头各选一个最大值就好了。

但是，如果选出来的 $a_i$ 和 $b_j$ 满足 $i=j$ 的话，根据上面的自由流最优定理，这时候换成流“限制流”，而把这个自由流的机会留给后面，一定不会更劣。

- 第二，考虑流“限制流”，也就是选取最大的一对下标相等的 $a_i$ 和 $b_i$。

如何模拟？显然在 $a_i$ 和 $b_i$ 均还未被配对的下标 $i$ 中选择一个  $a_i+b_i$ 最大的就可以了。

请注意，下面的两种方式涉及到**模拟退流**了！

- 第三，**选择一个 $a_i$ 已被配对，而 $b_i$ 还未被配对的下标 $i$ ，带上一个 $a_k$ 还未被配对的下标 $k$ 。** （认真理解）

此步非常关键，让我们好好分析一下究竟发生了什么。

画个图就很清晰了。最开始是这样的：

![1](https://cdn.luogu.com.cn/upload/image_hosting/ue55md72.png)

然而之后变成了这样：

![2](https://cdn.luogu.com.cn/upload/image_hosting/a0rbl2lw.png)

那么分析易得，这一次转变的结果是增加了一对下标相同的匹配，而对答案的贡献为 $a_k+b_i$ ，那么根据“贪心”的原则，我们只需要分别找到最大的 $a_k$ 和 $b_i$ 即可。

- 第四，也就是情况三的对偶情况，**选择一个 $b_j$ 已被配对，而 $a_j$ 还未被配对的下标 $j$ ，带上一个 $b_k$ 还未被配对的下标 $k$ 。**

同样还是给个图方便理解。先是这样：

![3](https://cdn.luogu.com.cn/upload/image_hosting/7nunwm1e.png)

变成了这样：

![4](https://cdn.luogu.com.cn/upload/image_hosting/6eooptmy.png)

同情况三，这一次转变的结果也是增加了一对下标相同的匹配，而对答案的贡献为 $a_j+b_k$ ，那么根据“贪心”的原则，我们只需要分别找到最大的 $a_j$ 和 $b_k$ 即可。

这个时候，我们也就考虑周全了实际费用中的几种流情况，模拟出了“退流”过程，达到了不断“优化调整匹配”的目的，故正确性得到保证，可以开始写了。

然而我认为这道题的难度还不少在实现上（~~否则进不了NOI~~），让我们一起仔细想一想怎么实现上述算法。

- 有频繁地根据值来选下标的操作，于是可以用stl优先队列模拟此操作，具体地就是

```cpp
priority_queue< pair<int, int> >  
```

pair第一维存权值，第二维存下标。

- 情况一，需要知道未被匹配的最大的 $a$ 和 $b$ 及其下标，于是我们令堆 A0 ，B0 分别存还未被配对的 $a$ 和 $b$ 。

- 情况二，需要知道未被配对的最大的 $a_i+b_i$ ，于是我们令堆 AB 存未被配对的 $a_i+b_i$

- 情况三和四，我们还需要知道“$b_i/a_i$ 已经被配对而 $a_i/b_i$ 还未被配对且 $a_i/b_i$ 最大的下标 $i$”，于是我们分别用堆 A1, B1 来存上述两种情况

综上，时间复杂度优化到了 $O(n\log n)$

好，这时候我就兴冲冲地打完了代码，一次过了~~出题人拿脚出的~~样例，然后提交……啊，只有4 pts ？？！？

这太戏剧性了，但是不要慌，我们可以对拍，我就把我写的费用流拿来对拍，经过半个下午+一个晚上的艰苦奋斗，终于把这份漏洞百出的代码调 AC 了。于是下面讲几个实现的细节。

- 我们中间会涉及到一些元素被配对，那么他们就应该从他们所在的堆中删除，这个时候可以用一个数组打标记，惰性删除。

- **注意，这一点非常重要！**

我们会发现有时候出现这种情况：

![5](https://cdn.luogu.com.cn/upload/image_hosting/9ksggcr0.png)

显然这样改一下会更优，腾出一个自由流：

![6](https://cdn.luogu.com.cn/upload/image_hosting/shxragtp.png)

**这种调整不会改变当前的答案，也不会改变元素在堆中的分布情况，只会还一个一个自由流。**

我们把这个操作叫做“adjust”，在代码中就是这个函数。

我们发现这个操作不光需要知道哪些点被配对了，还要知道每个配对的点匹配的是哪个点。于是，我们把上一点说到的打标记用来惰性删除的数组改成一个 int 型的匹配数组就可以了，那么注意在其他的操作中都要对这个数组小心地进行维护，而不是像以前一样只简单的打个标记就行。

在考虑什么时候要 adjust ，很显然，这个操作针对的是被自由匹配的点，那么我们只需要在每出现自由流的时候做这个操作就行了。观察之前画的图，发现情况一直接流自由流和情况三和四会改变原来的自由流，在这几个情况处理后对相应的下标 adjust 一下就好了。

- 关于维护自由流流量：

因为我们操作时有一个**优先流自由流**的决策 所以要开一个变量 Free 来记录**当前还有多少个自由流可以流**。

1. 每次情况一流一个自由流的时候，判断如果两边选的是不相等的下标就要把 Free 减一。

2. 每次 adjust 时候，注意 Free **至少会+1**，如果 $j=k$ ，就还要再 +1。

3. 但是，情况三和四，也要注意！分别对应之前讲这两种情况的情景图，当 $j=k$ 或 $i=k$ 的时候，运气非常好地把自由流消掉了，Free也要+1。

好啦，其他就没什么难点了，把代码放出来，里头有很多注释，这也应该是比较好懂的一份代码了。

```cpp
#include <bits/stdc++.h>
#define mkp make_pair
#define ft first
#define sd second
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef priority_queue< pair<int, int> > heap;

template<class T> inline void read(T& x){
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}

const int N=2e5+5;

int T, n, K, L, a[N], b[N], Free, now, type;
ll ans;
heap A0, A1, B0, B1, AB;
//A0, B0: 没被选的的a,b
//A1, B1: 已经被选了对应的b/a但自己没被选的a/b
//AB: a,b都没被选的组合
int mcha[N], mchb[N];
//mcha[i]: a[i]匹配的b[j]的下标j
//mchb[i]: b[i]匹配的a[j]的下标j

inline void del_AB(){//同时根据a，b的匹配情况来删除堆AB中的元素 
	while(!AB.empty()){
		int i=AB.top().sd;
		if(mcha[i]||mchb[i]) AB.pop();
		else break;
	}
}
inline void del_A(heap& A){//根据a的匹配情况来删除堆A0或A1中的元素 
	while(!A.empty()){
		int i=A.top().sd;
		if(mcha[i]) A.pop();
		else break;
	}
}
inline void del_B(heap& B){//根据b的匹配情况来删除堆B0或B1中的元素 
	while(!B.empty()){
		int i=B.top().sd;
		if(mchb[i]) B.pop();
		else break; 
	}
}

inline void adjust(int i){//核心：调整操作 
	if(!mcha[i]||!mchb[i]||mcha[i]==i) return;
	int j=mcha[i], k=mchb[i];
	mcha[i]=mchb[i]=i, ++Free;//腾出自由流 
	mcha[k]=j, mchb[j]=k;
	if(k==j) ++Free;
}
inline void free_match(){//自由配对
	del_A(A0), del_B(B0);
	int i=A0.top().sd, j=B0.top().sd;
	ans+=1ll*(a[i]+b[j]);
	mcha[i]=j, mchb[j]=i;
	if(i!=j){
		--Free;//消耗自由流 
		if(!mcha[j]) A1.push(mkp(a[j], j));
		if(!mchb[i]) B1.push(mkp(b[i], i));
	}
	adjust(i), adjust(j);//记得做调整 
}
inline void work1(){//选一对a[i]+b[i]
	del_AB();
	if(!AB.empty()){
		int i=AB.top().sd;
		if(a[i]+b[i]>now){
			now=a[i]+b[i];
			type=1;
		}
	}
}
inline void work2(){//a[i]+b[j] -> a[i]+b[i], a[k]+b[j]
	del_B(B1), del_A(A0);
	if(B1.empty()) return;
	int i=B1.top().sd, k=A0.top().sd;
	if(a[k]+b[i]>now){
		now=a[k]+b[i];
		type=2;
	}
}
inline void work3(){//a[i]+b[j] -> a[j]+b[j], a[i]+b[k]
	del_A(A1), del_B(B0);
	if(A1.empty()) return;
	int j=A1.top().sd, k=B0.top().sd;
	if(a[j]+b[k]>now){
		now=a[j]+b[k];
		type=3;
	}
}
inline void update1(){//选择了情况一后的更新操作 
	int i=AB.top().sd;
	mcha[i]=mchb[i]=i;
}
inline void update2(){//选择了情况二后的更新操作 
	int i=B1.top().sd, k=A0.top().sd, j=mcha[i];
	mcha[i]=mchb[i]=i;
	mcha[k]=j, mchb[j]=k;
	if(j==k) ++Free;//腾出自由流 
	if(!mchb[k]) B1.push(mkp(b[k], k));
	adjust(j), adjust(k); 
}
inline void update3(){//选择了情况三后的更新操作 
	int j=A1.top().sd, k=B0.top().sd, i=mchb[j];
	mcha[j]=mchb[j]=j;
	mcha[i]=k, mchb[k]=i;
	if(i==k) ++Free;
	if(!mcha[k]) A1.push(mkp(a[k], k));
	adjust(i), adjust(k);
}

inline void cls(){//多测清空 
	ans=0;
	while(!A0.empty()) A0.pop();
	while(!A1.empty()) A1.pop();
	while(!B0.empty()) B0.pop();
	while(!B1.empty()) B1.pop();
	while(!AB.empty()) AB.pop();
	memset(mcha, 0, sizeof(mcha));
	memset(mchb, 0, sizeof(mchb));
}

int main(){
//	freopen("sequence.in", "r", stdin);
//	freopen("sequence.out", "w", stdout);

	read(T);
	while(T--){

		cls();

		read(n);read(K);read(L);
		for(int i=1; i<=n; ++i)
			read(a[i]);
		for(int i=1; i<=n; ++i)
			read(b[i]);
		
		Free=K-L;//初始化自由流数量 
		for(int i=1; i<=n; ++i){
			A0.push(mkp(a[i], i));
			B0.push(mkp(b[i], i));
			AB.push(mkp(a[i]+b[i], i));
		}
		
		while(K--){
			if(Free){//优先自由配对
				free_match();
				continue;
			}
			now=0, type=0;
			work1();//选一对a[i]+b[i]
			work2();//a[i]+b[j] -> a[i]+b[i], a[k]+b[j]
			work3();//a[i]+b[j] -> a[j]+b[j], a[i]+b[k]
			ans+=1ll*now;
			if(type==1) update1();
			else if(type==2) update2();
			else update3();
		}
		
		printf("%lld\n", ans);

	}

	return 0;
}
```

# 后记

这是我NOI2019的题目中AC的第四道题，虽然在NOI里不能算难题，可能大佬们写起来觉得挺轻松（所以大佬的题解语言简洁代码灵动，蒟蒻看不懂QAQ），但是还是挺有感触的。有时候你一味想着看题解却可能一无所获（逃）。所以写了这篇比较完整而细致的题解，希望能帮到大家。然而如果看了这篇题解你还是没有懂（~~应该不会吧啊？~~），那你不妨想：

**有时困境不会对你的垂首乞怜心生恻隐，只会因你的迎难而上肃然起敬。**

好啦，这篇题解到此结束了，来了就点个赞（~~或者踩一脚~~）再走呗。

由于这是我自己胡搞出来的解法，如果您还有什么疑问或是建议，欢迎到评论区留言，我会尽力回复；如果您发现了我的漏洞，也欢迎到评论区指出或 hack ，我会认真改正！















---

## 作者：w4p3r (赞：53)

感觉这题跟CF436E差不多 ~~（甚至更简单）~~

### 一丶思路

首先有一种比较笨比的贪心，就是直接把$a$数组和$b$数组的最大的$K$个选出来，但是这样并不能满足有$L$个下标相同的条件。

按照反悔贪心的套路，考虑构造几种替换方案，使得**每次交集+1，并且能够覆盖所有可能的情况**，仔细思考有这么几种情况：

1.将一个选了$b$但没选$a$的位置$x$将$a$选上，并找到一个没选$b$但选了$a$的位置$y$将$a$退掉。这样的代价是$a_x-a_y$。

2.将一个选了$a$但没选$b$的位置$x$将$b$选上，并找到一个没选$a$但选了$b$的位置$y$将$b$退掉。这样的代价是$b_x-b_y$。


3.找到一个选了$a$但没选$b$的位置$x$，一个选了$b$但没选$a$的位置$y$，以及$a,b$都没选的位置$z$，将$x,y$选的都退掉，并将$z$的$a,b$都选上。这样的代价是$a_z+b_z-a_x-b_y$

4.找到一个选了$a$但没选$b$的位置$x$，一个选了$b$但没选$a$的位置$y$，以及$a,b$都选了的位置$z$，将$z$的$a,b$都退掉，并选上$x$的$b$，$y$的$a$。这样的代价是$b_x+a_y-(a_z+b_z)$。


对于这几种情况分别维护优先队列即可。注意在写的时候建议不要在改变状态时pop，而是在取出极值时将不合法情况pop掉。

具体维护可以看代码。

### 二丶代码

```cpp
//W4P3R
#include<bits/stdc++.h>
#define inf 1e18
#define eps 1e-6
#define mp make_pair
#define pb push_back
#define re register ll
#define fr first
#define sd second
#define pa pair<ll,ll>
#define FOR(i,a,b) for(re i=a;i<=b;i++)
#define REP(i,a,b) for(re i=a;i>=b;i--)
#define lowbit(x) (x&(-x))
#define Z(x) (x>=mod?x-mod:x)
#define N 200010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
priority_queue<pa,vector<pa>,less<pa> >q1,q2,q3,q4,q5,q6,q7;
/*
q1:只选了b的x的a[x]
q2:只选了a的x的-a[x]
q3:只选了a的x的b[x]
q4:只选了b的x的-b[x]
q5:a,b都没选的x的a[x]+b[x]
q6:a,b都选了的x的-(a[x]+b[x])
*/
ll n,k,l;
ll a[N],b[N],ans[N];
//ans数组：0表示a,b都没选，1表示a没选b选了,2表示a选了b没选，3表示a,b都选了
pa p[N];
inline void add(ll x,ll op)
{
	if(op==0){q5.push(mp(a[x]+b[x],x));}
	if(op==1){q1.push(mp(a[x],x));q4.push(mp(-b[x],x));}
	if(op==2){q2.push(mp(-a[x],x));q3.push(mp(b[x],x));}
	if(op==3){q6.push(mp(-a[x]-b[x],x));}
}
int main()
{
	//ios::sync_with_stdio(false);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ll w4p3r=read();
	while(w4p3r--)
	{
		n=read(),k=read(),l=read();
		while(!q1.empty())q1.pop();
		while(!q2.empty())q2.pop();
		while(!q3.empty())q3.pop();
		while(!q4.empty())q4.pop();
		while(!q5.empty())q5.pop();
		while(!q6.empty())q6.pop();
		q1.push(mp(-inf,0));q2.push(mp(-inf,0));q3.push(mp(-inf,0));q4.push(mp(-inf,0));q5.push(mp(-inf,0));q6.push(mp(-inf,0));
		FOR(i,1,n)a[i]=read();
		FOR(i,1,n)b[i]=read();
		FOR(i,1,n)ans[i]=0;ll answer=0;
		FOR(i,1,n)p[i]=mp(a[i],i);
		sort(p+1,p+n+1);reverse(p+1,p+n+1);
		FOR(i,1,k){answer+=p[i].fr;ans[p[i].sd]|=2;}
		FOR(i,1,n)p[i]=mp(b[i],i);
		sort(p+1,p+n+1);reverse(p+1,p+n+1);
		FOR(i,1,k){answer+=p[i].fr;ans[p[i].sd]|=1;}
		FOR(i,1,n)add(i,ans[i]);
		FOR(i,1,n)l-=(ans[i]==3);l=max(l,0LL);
		//cout<<"WTF:"<<answer<<" "<<l<<endl;
		while(l--)
		{
			while(!q1.empty()){ll x=q1.top().sd;if(!x||ans[x]==1)break;q1.pop();}
			while(!q2.empty()){ll x=q2.top().sd;if(!x||ans[x]==2)break;q2.pop();}
			while(!q3.empty()){ll x=q3.top().sd;if(!x||ans[x]==2)break;q3.pop();}
			while(!q4.empty()){ll x=q4.top().sd;if(!x||ans[x]==1)break;q4.pop();}
			while(!q5.empty()){ll x=q5.top().sd;if(!x||ans[x]==0)break;q5.pop();}
			while(!q6.empty()){ll x=q6.top().sd;if(!x||ans[x]==3)break;q6.pop();}
			ll v1=q1.top().fr,v2=q2.top().fr,v3=q3.top().fr,v4=q4.top().fr,v5=q5.top().fr,v6=q6.top().fr;
			ll t1=v1+v2,t2=v3+v4,t3=v5+v2+v4,t4=v1+v3+v6;
			ll maxn=-inf;
			if(t1>maxn)maxn=t1;if(t2>maxn)maxn=t2;if(t3>maxn)maxn=t3;if(t4>maxn)maxn=t4;
			if(t1==maxn)
			{
				ll x=q1.top().sd,y=q2.top().sd;
				ans[x]=3,ans[y]=0;answer+=a[x]-a[y];
				add(x,ans[x]);add(y,ans[y]);
			}//情况1
			else if(t2==maxn)
			{
				ll x=q3.top().sd,y=q4.top().sd;
				ans[x]=3,ans[y]=0;answer+=b[x]-b[y];
				add(x,ans[x]);add(y,ans[y]);
			}//情况2
			else if(t3==maxn)
			{
				ll x=q5.top().sd,y=q2.top().sd,z=q4.top().sd;
				ans[x]=3;ans[y]=0;ans[z]=0;answer+=a[x]+b[x]-a[y]-b[z];
				add(x,ans[x]);add(y,ans[y]);add(z,ans[z]);
			}//情况3
			else
			{
				ll x=q1.top().sd,y=q3.top().sd,z=q6.top().sd;
				ans[x]=3,ans[y]=3;ans[z]=0;answer+=a[x]+b[y]-(a[z]+b[z]);
				add(x,ans[x]);add(y,ans[y]);add(z,ans[z]);
			}//情况4
		}
		printf("%lld\n",answer);
	}
	return 0;
}
//gl
```

**如果你觉得这篇题解对你有帮助，那你可以点个赞支持我一下qwq。如果你对题解有任何问题/认为我的题解有任何问题，可以私信/在评论区发出来，当然如果你对我的题解有任何意见/建议也欢迎指出。我会尽我全力把我题解写到最好的qwq**

---

## 作者：Krimson (赞：17)

~~不知道我是不是第一个用wqs二分过这题的人~~    
  
考虑如果没有 $k$ 这个限制该怎么做。  
如果现在 $a,b$ 中都有正有负，那么有以下四类：  
1. $a_i\geq 0,b_i\geq 0$  
这种情况下肯定都选，匹配的位数 $+1$  
2. $a_i\geq 0,b_i < 0$  
$a_i$ 是肯定选择的，那么现在有一种选择是选 $b_i$ 使匹配的位数 $+1$  
3. $a_i< 0,b_i \geq 0$  
同2  
4. $a_i< 0,b_i < 0$    
那么有一种选择是选 $a_i+b_i$ 使匹配的位数 $+1$  

对得到的所有选择方案排序，使得至少有 $L$ 位匹配上，复杂度$O(n \log n)$  


令 $f_{i,j}$ 表示在选恰好 $i$ 个 $a$，恰好 $j$ 个 $b$ 的满足 $L$ 限制的最大选择方案，~~感性理解~~ 不难发现在 $i$ 确定的情况下 $f_{i,j}$ 的图像关于 $j$ 是一个上凸函数。   
同理在 $j$ 确定的情况下 $i$ 也满足这个性质。  
那么~~按照套路~~可以先去二分 $i$ 的斜率,再去二分 $j$ 的斜率，使得 $i=1,j=1$。  
复杂度$O(n\log n \log^2 V)$，显然过不了，只能拿到 $64$ 分~~不过代码很好写，考场上性价比很高~~    
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define ri register int
#define ll long long
#define ui unsigned int
il ll read(){
    bool f=true;ll x=0;
    register char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=false;ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    if(f) return x;
    return ~(--x);
}
il int read(char *s){
    int len=0;
    register char ch=getchar();
    while(ch==' '||ch=='\n') ch=getchar();
    while(ch!=' '&&ch!='\n'&&ch!=EOF) s[++len]=ch,ch=getchar();
    return len;
}
il void write(const ll &x){if(x>9) write(x/10);putchar(x%10+'0');}
il void print(const ll &x) {x<0?putchar('-'),write(~(x-1)):write(x);putchar('\n');}
il ll max(const ll &a,const ll &b){return a>b?a:b;}
il ll min(const ll &a,const ll &b){return a<b?a:b;}
const int MAXN=2e5+7;
struct node
{
    ll x,y;
}a[MAXN];
int n,k,L;
ll ma,mb,cnta,cntb,tot;
int mark[MAXN];
#define pll pair<ll,ll> 
#define fir first
#define sec second
pll vec[MAXN];
ll top;
bool checkb(){
    ll cnt=0;tot=cnta=cntb=top=0;
    for(ri i=1;i<=n;++i){
        if(a[i].x+ma>=0&&a[i].y+mb>=0) ++cnt,tot+=a[i].x+a[i].y+ma+mb,cnta++,cntb++;
        else if(a[i].x+ma>0) cnta++,tot+=a[i].x+ma,vec[++top]=(pll){a[i].y+mb,1};
        else if(a[i].y+mb>0) cntb++,tot+=a[i].y+mb,vec[++top]=(pll){a[i].x+ma,2};
        else vec[++top]=(pll){a[i].x+ma+a[i].y+mb,3};
    }
    sort(vec+1,vec+top+1);
    for(ri i=top;i&&cnt<L;--i){
        tot+=vec[i].fir;
        if(vec[i].sec&1) ++cntb;
        if(vec[i].sec&2) ++cnta;
        ++cnt;
    }
    return cntb<=k;
}
bool checka(){
    ll sav=0;
    ll l=-mx,r=-mn;
    while(l<=r){
        mb=(l+r)>>1;
        if(checkb()){
            l=mb+1;
            sav=mb;
        }
        else r=mb-1;
    }
    mb=sav;
    checkb();
    return cnta<=k;
}
ll mn=1e18,mx;
int main(){
    // freopen("sequence3.in","r",stdin);
    // freopen("1.out","w",stdout);
    for(ri T=read();T;--T){
        mn=1e18,mx=0;
        n=read(),k=read(),L=read();
        for(ri i=1;i<=n;++i) a[i].x=read(),mn=min(a[i].x,mn),mx=max(a[i].x,mx);
        for(ri i=1;i<=n;++i) a[i].y=read(),mn=min(a[i].y,mn),mx=max(a[i].y,mx);
        ll l=-mx,r=-mn,ans=0;
        while(l<=r){
            ma=(l+r)>>1;
            if(checka()){
                l=ma+1;
                ans=tot-ma*k-mb*k;
            }
            else r=ma-1;
        }
        print(ans);
    }
    return 0;
}
```


解题思路到次为止，剩下的是卡常技巧。

------------

### 1.指针优化寻址  
例如这样一份代码：  
```cpp
for(int i=1;i<=n;++i){
	a[i]++;                      
}
```
可以用指针的形式对其进行优化。  

```cpp
for(int i=1,*p=&a[i];i<=n;++i,++p){
	(*p)++;                      
}
```  
在有大量枚举操作的时候这种方式的优化很大。  
### 2.提早结束二分  
如果在二分的过程当中已经使得当前的次数恰好为 $K$ 了，那么可以直接break，这是个效果很好的优化

### 3.减少二分范围  
不一定非要把二分的范围开成$[0,1e9]$，可以记录一下整个序列的最大值和最小值，把范围缩小成 $[min,max]$。    

### 4.减少二分次数  
第一个二分的次数显然已经没什么办法优化了，那么考虑优化第二个二分  
~~不难发现~~ $f_{i,j}$ 有一个显然却难以发现的性质，随着 $i$ 的斜率的递增，$j$ 的斜率是递减的。  
~~感性理解一下，这里空白太小，我写不下~~  
那么每完成一次 $j$ 的二分，都可以根据反馈的结果来缩小二分 $j$ 的斜率的范围。  
具体实现如下：  
```cpp
bool checka(node p){
    int l=p.x,r=p.y,sav=0;
    while(l<=r){
        mb=(l+r)>>1;
        if(checkb()){
            l=mb+1;
            sav=mb;
            if(cntb==k) break;
        }
        else r=mb-1;
    }
    mb=sav;
    checkb();
    return cnta<=k;
}  
.
.
.
node now=(node){-mx,-mn};
while(l<=r){
    ma=(l+r)>>1;
    if(checka(now)){
        l=ma+1;
        ans=tot-1ll*ma*k-1ll*mb*k;
        now.x=mb-10;
        if(cnta==k)break;
    }
    else r=ma-1,now.y=mb+10;
}
```  
不知道这样之后这两个二分的复杂度变成了多少，但是实测快了将进 $6$ 倍左右，大概是变成了$O(\log V \log \log V)$ 的样子？  

### 5.松式基排  
在经过上面四重优化之后，依旧卡在 $84$ 分，第 $22$ 个点本地要跑 $5s$   
实际上，还有一个重要的复杂度瓶颈没有优化过：排序的$n\log n$  
说到排序优化，那就不得不提到**松式基排**了，可惜我并不会这个，于是在**神Dpair**的帮助下，从他那里得到了一个板子，又快了大概 $4$ 倍，成功松过  

```cpp

namespace DPair{
    int cnt1[256], cnt2[256], cnt3[256], cnt4[256];
    pll temp[MAXN];
    inline void RadixSort(pll a[], int l, int r){
        memset(cnt1, 0, sizeof(cnt1));
        memset(cnt2, 0, sizeof(cnt2));
        memset(cnt3, 0, sizeof(cnt3));
        memset(cnt4, 0, sizeof(cnt4));
        for (int i = l;i <= r;++ i){
            ++ cnt1[a[i].fir & 255];
            ++ cnt2[a[i].fir >> 8 & 255];
            ++ cnt3[a[i].fir >> 16 & 255];
            ++ cnt4[a[i].fir >> 24 & 255];
        }
        for (int i = 1;i <= 255;++ i){
            cnt1[i] += cnt1[i - 1];
            cnt2[i] += cnt2[i - 1];
            cnt3[i] += cnt3[i - 1];
            cnt4[i] += cnt4[i - 1];
        }
        for (int i = r;i >= l;-- i) temp[cnt1[a[i].fir & 255] --] = a[i];
        for (int i = r;i >= l;-- i) a[cnt2[temp[i].fir >> 8 & 255] --] = temp[i];
        for (int i = r;i >= l;-- i) temp[cnt3[a[i].fir >> 16 & 255] --] = a[i];
        for (int i = r;i >= l;-- i) a[cnt4[temp[i].fir >> 24 & 255] --] = temp[i];
    }
}

```

最后的复杂度大概就变成了一个$O(n \log_{256}n \log V \log \log V)$的东西，还是比较勉强地跑过去了~~喜题第二劣解~~

_Code_  
------------  
```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define ri register int
#define ll long long
#define ui unsigned int
il ll read(){
    bool f=true;ll x=0;
    register char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=false;ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    if(f) return x;
    return ~(--x);
}
il int read(char *s){
    int len=0;
    register char ch=getchar();
    while(ch==' '||ch=='\n') ch=getchar();
    while(ch!=' '&&ch!='\n'&&ch!=EOF) s[++len]=ch,ch=getchar();
    return len;
}
il void write(const ll &x){if(x>9) write(x/10);putchar(x%10+'0');}
il void print(const ll &x) {x<0?putchar('-'),write(~(x-1)):write(x);putchar('\n');}
il ll max(const ll &a,const ll &b){return a>b?a:b;}
il ll min(const ll &a,const ll &b){return a<b?a:b;}
const int MAXN=2e5+7;
struct node
{
    int x,y;
    bool operator <(const node &p)const{
        return x==p.x?y>p.y:x>p.x;
    }
}a[MAXN];
int n,k,L;
int ma,mb,cnta,cntb,top;
ll tot;
int mark[MAXN];
struct pll
{
    int fir,sec;
};
pll vec[MAXN];
ll rmn=1e18;
namespace DPair{
    int cnt1[256], cnt2[256], cnt3[256], cnt4[256];
    pll temp[MAXN];
    inline void RadixSort(pll a[], int l, int r){
        memset(cnt1, 0, sizeof(cnt1));
        memset(cnt2, 0, sizeof(cnt2));
        memset(cnt3, 0, sizeof(cnt3));
        memset(cnt4, 0, sizeof(cnt4));
        for (int i = l;i <= r;++ i){
            ++ cnt1[a[i].fir & 255];
            ++ cnt2[a[i].fir >> 8 & 255];
            ++ cnt3[a[i].fir >> 16 & 255];
            ++ cnt4[a[i].fir >> 24 & 255];
        }
        for (int i = 1;i <= 255;++ i){
            cnt1[i] += cnt1[i - 1];
            cnt2[i] += cnt2[i - 1];
            cnt3[i] += cnt3[i - 1];
            cnt4[i] += cnt4[i - 1];
        }
        for (int i = r;i >= l;-- i) temp[cnt1[a[i].fir & 255] --] = a[i];
        for (int i = r;i >= l;-- i) a[cnt2[temp[i].fir >> 8 & 255] --] = temp[i];
        for (int i = r;i >= l;-- i) temp[cnt3[a[i].fir >> 16 & 255] --] = a[i];
        for (int i = r;i >= l;-- i) a[cnt4[temp[i].fir >> 24 & 255] --] = temp[i];
    }
}


bool checkb(){
    int cnt=0;tot=cnta=cntb=top=0;
    node *p=&a[1];
    for(ri i=1;i<=n;++i,++p){
        if(p->x+ma>=0&&p->y+mb>=0) ++cnt,tot+=p->x+p->y+ma+mb,cnta++,cntb++;
        else if(p->x+ma>0){
            cnta++,tot+=p->x+ma;
            if(p->y+mb<rmn){
                if(cnt+top<L) vec[++top]=(pll){p->y+mb,1};
                rmn=p->y+mb;
            }
            else vec[++top]=(pll){p->y+mb,1};
        }
        else if(p->y+mb>0){
            cntb++,tot+=p->y+mb;
            if(p->x+ma<rmn){
                if(cnt+top<L) vec[++top]=(pll){p->x+ma,2};
                rmn=p->x+ma;
            }
            else vec[++top]=(pll){p->x+ma,2};
        }
        else{
            if(p->x+ma+p->y+mb<rmn){
                if(cnt+top<L) vec[++top]=(pll){p->x+ma+p->y+mb,3};
                rmn=p->x+ma+p->y+mb;
            }
            else vec[++top]=(pll){p->x+ma+p->y+mb,3};
        }
    }
    if(cnt<L){ 
        DPair :: RadixSort(vec, 1,top);
        for(ri i=top;i&&cnt<L;--i){
            tot+=vec[i].fir;
            if(vec[i].sec&1) ++cntb;
            if(vec[i].sec&2) ++cnta;
            ++cnt;
        }
    }
    return cntb<=k;
}
int mn=1e9,mx;
bool checka(node p){
    int l=p.x,r=p.y,sav=0;
    while(l<=r){
        mb=(l+r)>>1;
        if(checkb()){
            l=mb+1;
            sav=mb;
            if(cntb==k) break;
        }
        else r=mb-1;
    }
    mb=sav;
    checkb();
    return cnta<=k;
}
int main(){
    // freopen("P5470_22.in","r",stdin);
    // freopen("1.out","w",stdout);
    for(ri T=read();T;--T){
        mn=1e9,mx=0;
        n=read(),k=read(),L=read();
        for(ri i=1;i<=n;++i) a[i].x=read(),mn=min(a[i].x,mn),mx=max(a[i].x,mx);
        for(ri i=1;i<=n;++i) a[i].y=read(),mn=min(a[i].y,mn),mx=max(a[i].y,mx);
        sort(a+1,a+n+1);
        int l=-mx,r=-mn;
        ll ans=0;
        node now=(node){-mx,-mn};
        while(l<=r){
            ma=(l+r)>>1;
            if(checka(now)){
                l=ma+1;
                ans=tot-1ll*ma*k-1ll*mb*k;
                now.x=mb-10;
                if(cnta==k)break;
            }
            else r=ma-1,now.y=mb+10;
        }
        print(ans);
    }
    return 0;
}
```


---

## 作者：lndjy (赞：15)

首先，假设 $l$ 个公共部分已经确定了，显然直接选 $k-l$ 个最大的就是最优的。

那么我们把 $k$ 个都先按照大的选，然后通过反悔贪心，每一步让公共部分多一个，直到变成 $l$ 个，这样就是最优的。

考虑几种操作能让公共部分多一个。

1. 找一个选了的 $a_i$，和一个选了的 $b_j$，然后用 $b_i$ 代替 $b_j$，代价是 $b_i-b_j$。
2. 找一个选了的 $b_i$，和一个选了的 $a_j$，然后用 $a_i$ 代替 $a_j$，代价是 $a_i-a_j$。
3. 找一个选了的 $a_i$ 和 $b_j$，再找一个没选的位置 $k$，选 $a_k$ 和 $b_k$ 代替 $a_i$ 和 $b_j$，代价是 $a_k+b_k-a_i-b_j$。
4. 找一个选了的 $a_i$ 和 $b_j$，再找一个都选的位置 $k$，选 $a_j$ 和 $b_i$ 代替 $a_k$ 和 $b_k$，代价是 $a_j+b_i-a_k-b_k$。

拆一下上面的式子，用 $6$ 个堆维护 $a_i,-a_i,b_i,-b_i,a_i+b_i,-a_i-b_i$。~~比 CF436E 还恶心。~~

[反悔贪心练习题单qwq](https://www.luogu.com.cn/training/8793)

~~又臭又长的~~代码（附带第一个测试点数据）

```cpp
#include<iostream>
#include<cstdio> 
#include<queue>
#include<algorithm>
#include<cstring>
#define int long long
using namespace std;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
const int N=2e5+5;
struct node
{
	int id,num;
	node(int x=0,int y=0)
	{
		id=x;
		num=y;
	}
	bool operator <(const node &p)
	const{
		return num>p.num;
	}
	bool operator >(const node &p)
	const{
		return num<p.num;
	}
}a[N],b[N];
bool cmp(node x,node y)
{
	return x.id<y.id;
}
int n,l,K,op[N];
priority_queue<node,vector<node>,greater<node> > q1,q2,q3,q4,q5,q6;
int ans;
void clear()
{
	while(!q1.empty()) q1.pop();
	while(!q2.empty()) q2.pop();
	while(!q3.empty()) q3.pop();
	while(!q4.empty()) q4.pop();
	while(!q5.empty()) q5.pop();
	while(!q6.empty()) q6.pop();
	memset(op,0,sizeof op);
	ans=0;
}
void solve()
{
	n=read();K=read();l=read();
	for(int i=1;i<=n;i++)
	a[i].num=read(),a[i].id=i;
	for(int i=1;i<=n;i++)
	b[i].num=read(),b[i].id=i;
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	for(int i=1;i<=K;i++)
	ans+=a[i].num,op[a[i].id]++;
	for(int i=1;i<=K;i++)
	ans+=b[i].num,op[b[i].id]+=2;
	int cnt=0;
	for(int i=1;i<=n;i++)
	if(op[i]==3) cnt++;
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+n+1,cmp);	
	for(int i=1;i<=n;i++)
	{
		q1.push(node(i,a[i].num));
		q2.push(node(i,-a[i].num));
		q3.push(node(i,b[i].num));
		q4.push(node(i,-b[i].num));
		q5.push(node(i,a[i].num+b[i].num));
		q6.push(node(i,-a[i].num-b[i].num));
	}
//	for(int i=1;i<=n;i++)
//	cout<<op[i];
//	cout<<endl;
	for(int zwz=1;zwz<=l-cnt;zwz++)
	{
	//	cout<<zwz<<endl;
		int now=-1e15,opt=0,i=0,j=0,k=0;
	//	cout<<q3.size()<<endl;
		while(!q3.empty()&&op[q3.top().id]!=1) q3.pop();
		while(!q4.empty()&&op[q4.top().id]!=2) q4.pop();
		if(!q3.empty()&&!q4.empty())
		{
			int sum=b[q3.top().id].num-b[q4.top().id].num;
			if(sum>now)
			{
				now=sum;
				i=q3.top().id;
				j=q4.top().id;
				opt=1;
			}
		}
		while(!q1.empty()&&op[q1.top().id]!=2) q1.pop();
		while(!q2.empty()&&op[q2.top().id]!=1) q2.pop();
		if(!q1.empty()&&!q2.empty())
		{
			int sum=a[q1.top().id].num-a[q2.top().id].num;
			if(sum>now)
			{
				now=sum;
				i=q1.top().id;
				j=q2.top().id;
				opt=2;
			}
		}
	//	cout<<zwz<<endl;
		while(!q5.empty()&&op[q5.top().id]!=0) q5.pop();
		while(!q2.empty()&&op[q2.top().id]!=1) q2.pop();
		while(!q4.empty()&&op[q4.top().id]!=2) q4.pop();
		if(!q5.empty()&&!q4.empty()&&!q2.empty())
		{
			int sum=a[q5.top().id].num+b[q5.top().id].num-a[q2.top().id].num-b[q4.top().id].num;
			if(sum>now)
			{
				now=sum;
				i=q2.top().id;
				j=q4.top().id;
				k=q5.top().id;
				opt=3;
			}
		}
	//	cout<<zwz<<endl;
		while(!q6.empty()&&op[q6.top().id]!=3) q6.pop();
		while(!q1.empty()&&op[q1.top().id]!=2) q1.pop();
		while(!q3.empty()&&op[q3.top().id]!=1) q3.pop();
		if(!q6.empty()&&!q3.empty()&&!q1.empty())
		{
			int sum=a[q1.top().id].num+b[q3.top().id].num-a[q6.top().id].num-b[q6.top().id].num;
			if(sum>now)
			{
				now=sum;
				i=q3.top().id;
				j=q1.top().id;
				k=q6.top().id;
				opt=4;
			}
		}
	//	cout<<zwz<<endl;
		ans+=now;
	//	cout<<now<<" "<<opt<<endl;
	//	cout<<i<<" "<<j<<" "<<k<<endl;
		if(opt==1)
		{
			op[i]=3;
			op[j]=0;
			//cout<<q3.size()<<endl;
			q3.pop();q4.pop();
		//	cout<<q3.size()<<endl;
			q6.push(node(i,-a[i].num-b[i].num));
			q5.push(node(j,a[j].num+b[j].num));
		}
		else if(opt==2)
		{
			op[i]=3;
			op[j]=0;
			q1.pop();q2.pop();
			q6.push(node(i,-a[i].num-b[i].num));
			q5.push(node(j,a[j].num+b[j].num));			
		}
		else if(opt==3)
		{
			op[k]=3;
			op[i]=op[j]=0;
			q2.pop();q4.pop();q5.pop();
			q6.push(node(k,-a[k].num-b[k].num));
			q5.push(node(i,a[i].num+b[i].num));
			q5.push(node(j,a[j].num+b[j].num));
		}
		else
		{
			op[k]=0;
			op[i]=op[j]=3;
			q1.pop();q3.pop();q6.pop();
			q6.push(node(i,-a[i].num-b[i].num));
			q6.push(node(j,-a[j].num-b[j].num));
			q5.push(node(k,a[k].num+b[k].num));
		}
	//	cout<<q3.size()<<endl;
	//	system("pause");
	}
	cout<<ans<<endl;
}
signed main()
{
	int T=read();
	while(T--)
	{
		clear();
		solve();
	}
 	return 0;
}
/*
10
5 2 1
965603156 594151484 137421888 511721918 163053182
239833925 530765178 939584446 407283748 456390712
6 3 1
563597651 744310197 650756091 459159791 905965537 501095539
436402349 255689803 349243909 650771685 210810349 498904461
5 2 1
22583989 839924760 708231676 112954530 76654839
903218601 411750909 214760058 460569766 162867801
3 1 1
152517359 551481336 649305529
141934634 773929513 350494617
6 3 1
464020128 779739924 684448073 705217786 801717091 157102288
568955227 245753356 441864136 294782214 313154002 935222153
1 1 1
699242980
459838444
7 4 1
887100126 373954728 331917628 425297229 570948801 702368573 545916379
143951398 675892241 674371136 619857308 429051199 297631427 454083621
5 2 2
40869605 220229669 66179050 924234004 522215952
547926918 283456228 534215193 131503240 145556018
3 1 1
746003558 889997254 514823835
318446236 133597131 526467792
4 2 2
946692615 576958060 193743104 148410523
939939583 524058103 475154057 418784570

*/
/*
3030104264
3799951880
2863125946
1325410849
4211946604
1159081424
5130538185
1723509214
1064449794
2987648361
*/
```


---

## 作者：StudyingFather (赞：10)

是 myy 的题 orz

算是一道对前置知识要求不算高，主要考验思维以及建模能力的好题。

## 费用流

稍加思考后我们建立了一个这样的模型：

![](https://cdn.luogu.com.cn/upload/image_hosting/knocjpbv.png)

注：我们记 $(x,y)$ 表示这是一条流量为 $x$，费用为 $y$ 的边，特别地，没有标记边权的边全部默认为 $(1,0)$。

这个图的含义比较显然。

1. 如果我们选择了流 $a_i \to b_i$ 的边，则表示同时选 $a_i$ 和 $b_i$ 这样一组下标相等的数。
2. 如果我们选择了流 $a_p \to b_p$ 的边（下文我们称这样的流为「自由流」），则代表我们选了两个下标不同的数。由流量限制可知我们最多选 $k-l$ 对这样的数，刚好符合题目要求。

我们的目标是求出其流量不超过 $k$ 的前提下的最大费用。

时间复杂度：$O(k \times \operatorname{SSSP}(n))$（$\operatorname{SSSP}(n)$ 代表求有 $n$ 个点的稀疏图（即 $n$ 与 $m$ 同阶）的单源最短路的时间复杂度），期望得分 $64$ pts。

## 费用流 Ex（模拟费用流）

上面这个做法效率不佳的原因，主要是在找增广路上。

注意到 EK 算法的实质是找图中从 $s$ 到 $t$ 的最短（长）路，如果我们能用数据结构（例如二叉堆）来维护这个信息，每次找增广路的时间就可以做到 $O(\log n)$。

这就是**模拟费用流**的思想。即我们通过二叉堆这样的数据结构更高效地找到增广路，相较于用最短路算法找增广路效率高了不少。

现在我们来理理思路。一条增广路可能是怎样的呢？

1. 自由流；
2. 直接找一对下标相同且均没有被选择的数字；
3. 给 $a$ 数组中已经选择但尚未配对的数进行一次配对；
4. 给 $b$ 数组中已经选择但尚未配对的数进行一次配对；

一个显然的事实是：**自由流在四种决策中一定是最优的**。因此我们在条件允许的情况下先考虑自由流。

自由流流满了怎么办？考虑剩下三种决策。

对于第二种决策，我们显然挑 $a_i+b_i$ 最大的。

对于第三种决策，反映在图上的实质是：我们将 $a_i \to a_p$ 的流撤销，改为流 $a_i \to b_i \to t$。这样会使得 $a_p$ 的入流量少一，因此我们还要再流 $a_j \to a_p$ 以满足流量平衡。

上面两个步骤是独立的，因此最明智的做法是挑 $a$ 数组中已经选择但尚未配对的数字中，相应的 $b$ 最大的数进行配对，随后再挑一个最大的，之前未被选的 $a_j$ 加入答案。

决策四与决策三同理。这里不再赘述。

我们发现我们只需维护最大值，因此用堆来维护我们所需的信息即可。

到这里就完了？事实上，在增广的过程中，我们可能遇到这些细节问题：

1. 自由流刚好选了下标相同的两个数。这时候视为作决策二即可（流 $a_i \to b_i$），将自由流的流量留给后面的数字。并且，如果后来的自由流刚好能使得一些数配对，我们也该将自由流的流量及时释放。
2. 注意到决策二**一定**不会释放自由流，因此出于让自由流最大化利用的目的，我们先考虑决策三和决策四。
3. 决策三和决策四的增广路均为最优？还是出于让自由流最大化利用的目的，选择能释放出自由流的决策。

这样我们就将本题的时间复杂度优化到了 $O(n \log n)$。

更多细节可以看我代码里的注释。

```cpp
// Problem : P5470 [NOI2019]序列
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P5470
// Memory Limit : 500 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
struct node {
  int id, x;
  bool operator<(const node& a) const { return x < a.x; }
};
priority_queue<node> q1, q2;  //维护尚未选择的数字
priority_queue<node> q3;      //维护尚未选择的对
priority_queue<node> q4, q5;  //维护待配对的数
//注意代码中用了懒惰删除，一个数字如果不符合条件不会被立刻从堆中删除，而是在其被取出堆时再进行删除
int a[200005], b[200005];
int vis1[200005], vis2[200005];
int main() {
  ios::sync_with_stdio(false);
  int T;
  cin >> T;
  while (T--) {
    memset(vis1, 0, sizeof(vis1));
    memset(vis2, 0, sizeof(vis2));
    while (!q1.empty()) q1.pop();
    while (!q2.empty()) q2.pop();
    while (!q3.empty()) q3.pop();
    while (!q4.empty()) q4.pop();
    while (!q5.empty()) q5.pop();
    int n, k, l;
    long long ans = 0;
    cin >> n >> k >> l;
    for (int i = 1; i <= n; i++) {
      cin >> a[i];
      q1.push({i, a[i]});
    }
    for (int i = 1; i <= n; i++) {
      cin >> b[i];
      q2.push({i, b[i]});
    }
    int cnt = 0, rem = k - l;
    for (int i = 1; i <= n; i++) q3.push({i, a[i] + b[i]});

    while (cnt < k) {
      //自由流一定最优，因此先考虑自由流
      if (rem) {
        while (vis1[q1.top().id])  //懒惰删除
          q1.pop();
        while (vis2[q2.top().id]) q2.pop();
        int u = q1.top().id, v = q2.top().id;
        ans += a[u] + b[v];
        vis1[u] = vis2[v] = 1;
        cnt++;
        if (u != v) {
          rem--;
          rem += (vis1[u] && vis2[u]) + (vis1[v] && vis2[v]);
          //释放自由流的流量
        }
        if (!vis2[u])  //加入待配对列表
          q4.push({u, b[u]});
        if (!vis1[v]) q5.push({v, a[v]});
        q1.pop(), q2.pop();
        continue;
      }

      //直接加一对
      int num1 = 0, id1 = 0;
      while (!q3.empty()) {
        int id = q3.top().id, x = q3.top().x;
        if (vis1[id] || vis2[id])  //还是懒惰删除
          q3.pop();
        else {
          num1 = x, id1 = id;
          break;
        }
      }

      //给 a 数组中的数配对
      int num2 = 0, id2a = 0, id2b = 0;
      while (!q4.empty() && vis2[q4.top().id]) q4.pop();
      if (!q4.empty()) id2b = q4.top().id, num2 += q4.top().x;
      while (vis1[q1.top().id]) q1.pop();
      id2a = q1.top().id, num2 += q1.top().x;

      //给 b 数组中的数配对
      int num3 = 0, id3a = 0, id3b = 0;
      while (!q5.empty() && vis1[q5.top().id]) q5.pop();
      if (!q5.empty()) id3a = q5.top().id, num3 += q5.top().x;
      while (vis2[q2.top().id]) q2.pop();
      id3b = q2.top().id, num3 += q2.top().x;

      int maxa = max(num1, max(num2, num3));
      ans += maxa;
      if (num2 == num3 && maxa == num2) {
        if (vis2[id2a])  //考虑优先释放自由流
        {
          rem++;
          vis1[id2a] = 1, q1.pop();
          vis2[id2b] = 1, q4.pop();
        } else if (vis1[id3b]) {
          rem++;
          vis2[id3b] = 1, q2.pop();
          vis1[id3a] = 1, q5.pop();
        } else {
          vis1[id2a] = 1, q1.pop();
          vis2[id2b] = 1, q4.pop();
          q4.push({id2a, b[id2a]});
        }
      } else if (maxa == num2) {
        vis1[id2a] = 1, q1.pop();
        vis2[id2b] = 1, q4.pop();
        if (vis2[id2a])
          rem++;  //释放自由流
        else
          q4.push({id2a, b[id2a]});  //记得维护待配对数列表
      } else if (maxa == num3) {
        vis2[id3b] = 1, q2.pop();
        vis1[id3a] = 1, q5.pop();
        if (vis1[id3b])
          rem++;
        else
          q5.push({id3b, a[id3b]});
      } else if (maxa == num1) {
        vis1[id1] = vis2[id1] = 1;
        q3.pop();
      }
      cnt++;
    }
    cout << ans << endl;
  }
  return 0;
}
```

---

## 作者：yzhang (赞：7)

[原题传送门](https://www.luogu.org/problemnew/solution/P5468)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11200711.html)

同步赛上我一开始想了个看似正确却漏洞百出的贪心：按$a_i+b_i$的和从大向小贪心

随便想想发现是假的，然后就写了个28pts的暴力dp

杜神后半程说这题就是个贪心，但我没时间写了 ~~（实际是没想明白）~~

我们来说这道题的正解：

我们先珂以满足和最大，再满足并集大小大于等于$l$。所以我们先将$a$序列和$b$序列排序，取出两个序列的前$k$大

如果并集大小大于等于$l$就直接统计答案

否则我们要凑满$l$个都包含的，在凑的过程中动态更新答案

我们在两个序列中都选中前$k-l$个不含有并集的数，并加入答案中，易知这些数一定含在答案中（这个珂以在草稿纸上推一推）。接下来考虑如何凑并集元素，一次凑一组：

1.两个都没被选中的情况下的最大值，并将它们选中

2.一个被选中的情况下的最大值。假设$a[rk[i]]$选中了，但$b[rk[i]]$没选中，我们就要找到一个最小的j使得$a[rk[j]]$没被选中，我们就珂以选中$b[rk[i]$和$a[rk[j]]$，使得a中不成对的还是$k-l$个。a,b反之亦然

我们求出1、2两种情况贡献最大值并更新选中状态（都用堆维护，具体细节见代码），重复$l$次即可求出答案

注意：两次2也许就会将两个都没选中的变成都选中，所以**要及时舍掉不合法的**

```cpp
#include <bits/stdc++.h>
#define N 200005
#define ll long long
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int T,n,k,l,a[N],b[N],ar[N],br[N],va[N],vb[N],vis[N];
ll ans;
inline bool cmpa(register int x,register int y)
{
    return a[x]>a[y];
}
inline bool cmpb(register int x,register int y)
{
    return b[x]>b[y];
}
struct node{
    int pos,val;
    inline bool operator < (const node &it) const {
        return val<it.val;
    }
};
inline bool chkmax(register int &a,register int b)
{
    return a<b?a=b,1:0;
}
int main()
{
    T=read();
    while(T--)
    {
        n=read(),k=read(),l=read();
        for(register int i=1;i<=n;++i)
            a[i]=read(),ar[i]=i,va[i]=vb[i]=vis[i]=0;
        for(register int i=1;i<=n;++i)
            b[i]=read(),br[i]=i;
        sort(ar+1,ar+1+n,cmpa);
        sort(br+1,br+1+n,cmpb);
        for(register int i=1;i<=k;++i)
            va[ar[i]]=1,vb[br[i]]=1;
        ans=0;
        priority_queue<int> pa,pb;
        priority_queue<node> qa,qb;
        for(register int i=1;i<=n;++i)
            if(va[i]&&vb[i])
                qb.push((node){i,a[i]+b[i]}),vis[i]=1;
        if(qb.size()>=l)
        {
            for(register int i=1;i<=n;++i)
            {
                if(va[i])
                    ans+=a[i];
                if(vb[i])
                    ans+=b[i];
            }
        }
        else
        {
            for(register int i=1,tot=0;i<=k;++i)
                if(!vb[ar[i]])
                {
                    if(tot<k-l)
                        ans+=a[ar[i]],vis[ar[i]]=1,pa.push(b[ar[i]]);
                    else
                        qa.push((node){ar[i],a[ar[i]]+b[ar[i]]});
                    ++tot;
                }
            for(register int i=1,tot=0;i<=n;++i)
                if(!va[br[i]])
                {
                    if(tot<k-l)
                        ans+=b[br[i]],vis[br[i]]=1,pb.push(a[br[i]]);
                    else
                        qb.push((node){br[i],a[br[i]]+b[br[i]]});
                    ++tot;
                }
            int af=1,bf=1;
            while(l--)
            {
                while(af<=k&&vis[ar[af]])
                    ++af;
                while(bf<=k&&vis[br[bf]])
                    ++bf;
                while(!qa.empty()&&vis[qa.top().pos]&&!(va[qa.top().pos]&&vb[qa.top().pos]))
                    qa.pop();
                while(!qb.empty()&&vis[qb.top().pos]&&!(va[qb.top().pos]&&vb[qb.top().pos]))
                    qb.pop();
                int maxx=0,typ=-1;
                if(!qa.empty())
                    maxx=qa.top().val,typ=0;
                if(!qb.empty()&&chkmax(maxx,qb.top().val))
                    typ=1;
                if(!pa.empty()&&af<=k&&chkmax(maxx,pa.top()+a[ar[af]]))
                    typ=2;
                if(!pb.empty()&&bf<=k&&chkmax(maxx,pb.top()+b[br[bf]]))
                    typ=3;
                ans+=maxx;
                if(typ==0)
                    vis[qa.top().pos]=1,qa.pop();
                else if(typ==1)
                    vis[qb.top().pos]=1,qb.pop();
                else if(typ==2)
                    vis[ar[af]]=1,pa.pop(),pa.push(b[ar[af]]);
                else
                    vis[br[bf]]=1,pb.pop(),pb.push(a[br[bf]]);
            }
        }
        write(ans),puts("");
    }
    return 0;
}
```




---

## 作者：itisover (赞：6)

这里使用一种反悔贪心做法。

**题外话：**

鉴于没有人对反悔贪心具体代码实现过多介绍，导致我这个代码能力低下的垃圾 OIer 十分困扰，所以这里根据代码来讲讲反悔贪心在这题的具体实现。

**大概思路：**

首先我们就硬贪，$a,b$ 两个序列中分别选出 $K$ 个最大的。

接着我们考虑每次取增量尽可能大（最优）的那种操作来反悔，使得每次操作后都能使当前同时出现在两个序列中的点数多一。

反悔操作分为以下四种：（窝语文太菜直接蒯了）

+ 找一个选了的 $a_i$，和一个选了的 $b_j$，然后用 $b_i$ 代替 $b_j$，增量是 $b_i-b_j$。 （代码中操作3）

+ 找一个选了的 $b_i$，和一个选了的 $a_j$，然后用 $a_i$ 代替 $a_j$，增量是 $a_i-a_j$。 （代码中操作2）

+ 找一个选了的 $a_i$ 和 $b_j$，再找一个没选的位置 $k$，选 $a_k$ 和 $b_k$ 代替 $a_i$ 和 $b_j$，增量是 $a_k+b_k-a_i-b_j$。 （代码中操作4）

+ 找一个选了的 $a_i$ 和 $b_j$，再找一个都选的位置 $k$，选 $a_j$ 和 $b_i$ 代替 $a_k$ 和 $b_k$，增量是 $a_j+b_i-a_k-b_k$。 （代码中操作1）

所以我们开 $6$ 个堆分别维护：$-ai-bi$，$-ai$，$bi$，$ai$，$-bi$，$ai+bi$ 即可算出增量，进行反悔操作。

**类似神题：**[CF436E](https://www.luogu.com.cn/problem/CF436E) 

代码中对于一些坑点和具体实现步骤都有应该大概可能比较详细的标注。（蒯的lsy神仙的）


```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int ans=0,f=0;char ch=getchar();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	return f?-ans:ans;
}
const int N=1e6+5;
const long long INF=1e18;
struct zfz{
	int id,val;
	bool operator <(const zfz x)const{return val<x.val;}
};
int topop[N];//表示堆中，在原序列编号为i的元素的a,b选择状态 
struct lsyOrz{ 
	int op;
	priority_queue<zfz> q;
	void upd(){while(!q.empty()&&topop[q.top().id]!=op) q.pop();}
	bool empty(){upd();return q.empty();}
	zfz top(){upd();return q.top();}
	void push(zfz x){q.push(x);}
	void clear(){while(!q.empty())q.pop();}
}q1,q2,q3,q4,q5,q6;
//q1: -ai-bi; q2: -ai; q3: bi; q4: ai; q5: -bi; q6: ai+bi; 
int T;
int n,K,L;
int a[N],b[N];
int pa[N],pb[N];//排序数组 
int visa[N],visb[N];
bool cmp1(int x,int y){return a[x]<a[y];}
bool cmp2(int x,int y){return b[x]<b[y];}
void push0(int x){//设为a,b都不选
	topop[x]=0;q6.push((zfz){x,a[x]+b[x]});
}
void push1(int x){//设为a,b都选 
	topop[x]=3;q1.push((zfz){x,-a[x]-b[x]});
}
signed main(){
	for(T=read();T;--T){
		long long ans=0;
		q1.op=3,q2.op=q3.op=2,q4.op=q5.op=1,q6.op=0;
		q1.clear();q2.clear();q3.clear();q4.clear();q5.clear();q6.clear();
		memset(visa,0,sizeof(visa)),memset(visb,0,sizeof(visb));
		n=read(),K=read(),L=read();
		for(int i=1;i<=n;++i) a[i]=read(),pa[i]=i;
		for(int i=1;i<=n;++i) b[i]=read(),pb[i]=i;
		sort(pa+1,pa+1+n,cmp1);//排个序，选前K大的 
		sort(pb+1,pb+1+n,cmp2);
		//注意排序有个坑点，如果你从大到小排序取前K个的话，
		//当有多个值相同且都符合前K大，你可能会选择编号不同但本质（值）相同的点，
		//原本可以满足同时在a,b两个序列里的点就会被拆散，样例中的第三个点就完美的hack掉了这种做法 
		//从小到大取后K个就不会，对于满足前K大的取值，你都会选尽可能靠后的点（sort特性）
		for(int i=n-K+1;i<=n;++i) visa[pa[i]]=visb[pb[i]]=1; 
		int tot=0;//记录都选了几个，方便反悔用
		for(int i=1;i<=n;++i){//先贪心选K个，能选就选，并把元素放进堆里方便反悔 
			if(visa[i]) ans+=a[i];
			if(visb[i]) ans+=b[i];
			topop[i]=visa[i]<<1|visb[i];//状压a，b的选择情况 
			if(topop[i]==3) q1.push((zfz){i,-a[i]-b[i]}),tot++;//都选
			else if(topop[i]==2) q2.push((zfz){i,-a[i]}),q3.push((zfz){i,b[i]});//只选a 
			else if(topop[i]==1) q4.push((zfz){i,a[i]}),q5.push((zfz){i,-b[i]});//只选b 
			else q6.push((zfz){i,a[i]+b[i]});//都不选 
		}
		while(tot<L){//如果没有选够L个在两个序列中都被指定的，就继续选 
			long long Max=-INF,tmp;//Max维护增量，贪心使增量尽可能大 
			int opt=-1,t,a,b;//opt选择的反悔操作，t,a,b反悔的位置 
			if(!q1.empty()&&(tmp=q1.top().val+q3.top().val+q4.top().val)>Max) Max=tmp,t=q1.top().id,a=q3.top().id,b=q4.top().id,opt=1;//上述1操作 
			if((tmp=q2.top().val+q4.top().val)>Max) Max=tmp,a=q2.top().id,b=q4.top().id,opt=2;//上述2操作
			if((tmp=q5.top().val+q3.top().val)>Max) Max=tmp,a=q5.top().id,b=q3.top().id,opt=3;//上述3操作
			if(!q6.empty()&&(tmp=q2.top().val+q5.top().val+q6.top().val)>Max) Max=tmp,t=q6.top().id,a=q2.top().id,b=q5.top().id,opt=4;//上述4操作
			if(opt==1) push0(t),push1(a),push1(b);
			else if(opt==2||opt==3) push0(a),push1(b);
			else push1(t),push0(a),push0(b);
			tot++;
			ans+=Max;
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```


---

## 作者：AzusaCat (赞：4)

给定两个长为 $n$ 的正整数序列 $\{a_n\},\{b_n\}$，现在让你在每个序列中都选 $k$ 个下标，并且在两个序列中都被选中的下标个数不少于 $L$，最大化选中的下标对应的数之和。$n\leqslant 2\times 10^5$。



我们认为一次操作为各选中 $a$ 和 $b$ 中的一个未被选中的下标。我们发现两个序列中都被选中的下标个数不少于 $L$，等价于最多 $k-L$ 次操作选中的下标不同。这样我们可以建出一个费用流模型：

![](https://cdn.luogu.com.cn/upload/image_hosting/87lx0o3h.png)

括号里的是边权，第一个数是流量大小，第二个数是费用，同类边只标注了一次边权，这样 $s$ 到 $t$ 的流量恰好为 $k$ 时的费用就是答案。这个算法的正确性比较显然，只有通过红色边才能增广出 $a$ 与 $b$ 下标不同的情况，而最多只能进行 $k-L$ 次这样的增广，而且我们每一次单路增广增加的流量一定为 1。

如果直接写一个 SPFA 费用流，这样的复杂度为 $O(nmk)$，实际跑不满似乎可以拿到 64 分。



然后是重头戏模拟费用流部分。首先我们定义红边的剩余流量为自由流的大小。很显然，如果自由流有剩余，那么一次增广通过红边增广的权值一定最大，因为它可以覆盖任何匹配。

我们考虑增广的情况：

1. 通过 $C,D$ 增广了一条 $a$ 和 $b$ 的下标不同的情况。（如果增广了下标相同的点我们可以归为第二种情况，也就是不要白消耗自由流了），这等价于匹配了一对下标不同的数。

2. 直接走一条 $s\rightarrow a_i\rightarrow b_i\rightarrow t$ 的增广路，这等价于匹配了一对下标相同的数。

3. 考虑退流，走了一条 $s\rightarrow a_i\rightarrow C\rightarrow a_j\rightarrow b_j\rightarrow t$ 的增广路，设原来和 $a_j$ 匹配的为 $b_k$，那么这等价于把原来的 $a_j-b_k$ 这个匹配取消，然后新添加 $a_j-b_j$ 和 $a_i-b_k$ 两对匹配。这样会使匹配数量增加 1，自由流数量不变或 $+1$（具体情况见后面）。

4. 类似情况 3，走一条 $s\rightarrow a_j\rightarrow b_j\rightarrow D\rightarrow b_i\rightarrow t$ 的增广路，这等价于把 $a_k-b_j$ 这个匹配取消，新增 $a_j-b_j$ 和 $a_k-b_i$ 两对匹配。

这样，我们开一个变量 `left` 记录自由流的大小，如果还有自由流，我们优先用自由流，因为一定不劣。否则，我们选择剩下几种方案中权值最高的那个。

实现上，我们需要开 5 个堆，分别维护未匹配的 $a_i/b_i$ 的值，未匹配的 $a_i+b_i$ 的值，匹配过但是没有固定（指这个点不通过红色边增广，显然，如果一个点通过了蓝色边增广，那么它的匹配一定不会变）的 $a_i/b_i$ 所对应的 $b_i/a_i$ 的值。然后有一些操作会导致自由流变多，下面列出来：

下面认为橙色为现在匹配的两个点：

![情况1](https://cdn.luogu.com.cn/upload/image_hosting/5ds07mj5.png)

![情况2](https://cdn.luogu.com.cn/upload/image_hosting/f6g71siu.png)

如果是类型 1，那么自由流额外 +1（我们认为只要出现一次类型 1，自由流都减小 1，也就是说这样等价于自由流大小最终没有变化），要不然就是类型 3 或 4，这种情况自由流不变。

![情况3](https://cdn.luogu.com.cn/upload/image_hosting/be1tyw9o.png)

![情况4](https://cdn.luogu.com.cn/upload/image_hosting/59xw38y0.png)

这两种情况（本质上是一种，即现在匹配的两个点在另外一个序列中都被匹配过了）出现在类型 1 时，自由流额外 +2；出现在类型 3 或 4 时，自由流额外 +1。

至于如何判断，我们开两个数组记录每个数是否被增广过，同时这个作为懒惰删除的标记，如果不明白代码不是很长可以看代码。

由于我们每一次的操作都等价于在费用流图中的增广，且每次都是最长路，所以这个算法是正确的。

```cpp
#include<bits/stdc++.h>
#define mp make_pair
using namespace std;
namespace input
{
    const int InputBufferSize=(1<<25)+5;
    char buffer[InputBufferSize],*s,*eof;
    inline void init()
    {
        assert(stdin!=NULL);
        s=buffer;
        eof=s+fread(buffer,1,InputBufferSize,stdin);
    }
    inline bool read(int &x)
    {
        x=0;
        int flag=1;
        while(!isdigit(*s)&&*s!='-')s++;
        if(eof<=s)return false;
        if(*s=='-')flag=-1,s++;
        while(isdigit(*s))x=x*10+*s++-'0';
        x*=flag;
        return true;
    }
}
using namespace input;
typedef long long ll;
typedef pair<int,int> pii;
priority_queue<pii>q1,q2,q3,q4,q5;
int a[200005],b[200005];
bool visited[200005],visited2[200005];
int main()
{
    init();
    int _;
    read(_);
    while(_--)
    {
        a[0]=b[0]=-1e9;
        while(!q1.empty())q1.pop();
        while(!q2.empty())q2.pop();
        while(!q3.empty())q3.pop();
        while(!q4.empty())q4.pop();
        while(!q5.empty())q5.pop();
        int n,k,l,left;
        ll ans=0;
        read(n),read(k),read(l);
        left=k-l;
        for(int i=1;i<=n;i++)read(a[i]),q1.push(mp(a[i],i)),visited[i]=visited2[i]=0;
        for(int i=1;i<=n;i++)read(b[i]),q2.push(mp(b[i],i)),q3.push(mp(a[i]+b[i],i));
        while(k--)
        {
            if(left)//类型 1
            {
                while(visited[q1.top().second])q1.pop();
                while(visited2[q2.top().second])q2.pop();
                int x=q1.top().second,y=q2.top().second;
                q1.pop(),q2.pop();
                ans+=a[x]+b[y];
                if(x!=y)
                {
                    left--,left+=visited2[x]+visited[y];
                    if(!visited2[x])q5.push(mp(b[x],x));
                    else q4.pop();
                    if(!visited[y])q4.push(mp(a[y],y));
                    else q5.pop();
                }
                visited[x]=visited2[y]=1;
            }
            else
            {
                while(visited[q1.top().second])q1.pop();
                while(visited2[q2.top().second])q2.pop();
                while(visited[q3.top().second]||visited2[q3.top().second])q3.pop();
                int r=q3.top().second,s1=q4.empty()?0:q4.top().second,s2=q2.top().second,t1=q5.empty()?0:q5.top().second,t2=q1.top().second;
                if(a[r]+b[r]>=a[s1]+b[s2]&&a[r]+b[r]>=b[t1]+a[t2])//类型2
                {
                    visited[r]=visited2[r]=1;
                    ans+=a[r]+b[r];
                }
                else if(a[s1]+b[s2]>=b[t1]+a[t2])//类型3
                {
                    ans+=a[s1]+b[s2];
                    visited[s1]=visited2[s2]=1;
                    q2.pop(),q4.pop();
                    if(visited[s2])left++,q5.pop();
                    else q4.push(mp(a[s2],s2));
                }
                else//类型4
                {
                    ans+=b[t1]+a[t2];
                    visited2[t1]=visited[t2]=1;
                    q1.pop(),q5.pop();
                    if(visited2[t2])left++,q4.pop();
                    else q5.push(mp(b[t2],t2));
                }
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```



---

## 作者：FutaRimeWoawaSete (赞：2)

先把网络流建出来：

- 记四元组 $(u,v,w,ww)$ 代表网络流上 $u$ 向 $v$ 容量为 $w$ 权值为 $ww$ 的边；记 $id_{x,0/1}$ 代表 $a,b$ 中第 $x$ 个数在网络流上的位置；

- 连 $(S,ss,K,0)$ 限制总流量；连 $(ss,id_{i,0},1,a_i),(id_{i,1},T,1,b_i)$ 代表一次对位置的选择；连 $(id_{i,0},id_{i,1},1,0)$ 代表一次有交的匹配。

- 建立虚点 $m,M$ 连 $(m,M,K - L,0)$ 代表选择非交匹配，连 $(id_{i,0},m,1,0),(M,id_{i,1},1,0)$。

发现这本质上也是个匹配模型，注意这个想法在后面的模拟费用流中有用。

考虑 $n$ 很大，凭感觉就是模拟费用流，那自然反悔贪心。

根据套路，我们先模拟 EK，每次找一条增广路，然后构造反悔；反悔的时候需要确定一个变量 $x$ 使得每次流经增广路后 $x$ 只会 $+1$ 一直达到上界为止。

回归此题，我们不难想到先暴力在 $a,b$ 里面选 $K$ 个出来然后若没达到 $L$ 的要求就每次找一条**在网络流上必经过 $(m,M)$ 边的增广路**去反悔，即每次必须使得有交匹配的个数 $+1$ 且总的最大流量不变。满足需要的反悔贪心模型。

你可以理解成未满足 $L$ 的条件下，我们将 $m \rightarrow M$ 的边反向了变成 $M \rightarrow m$ 了（本质上是流多了）且对于该边的流量限制是上下界，而其它边的流量合法时残余网络上的最大流最大费用问题。

- 记二分图左侧点表示 $a$ 数组的点，右侧点表示 $b$ 数组的点；

- 左侧点有一个点形成非交匹配，找到与它匹配的右侧节点，设左右两点的位置为 $a,b$，则反悔路径为 $id_{b,1} \rightarrow M \rightarrow m \rightarrow id_{a,0} \rightarrow id_{a,1}$ 形成一次有交匹配；

- 右侧点有一个点形成非交匹配，找到与它匹配的左侧节点，设左右两点的位置为 $a,b$，则反悔路径为 $id_{b,1} \rightarrow M \rightarrow m \rightarrow id_{a,0} \rightarrow id_{a,1}$ 形成一次有交匹配；

- 存在一个非交匹配，设左右两点为 $a,b$，寻找一个满足存在 $S \rightarrow ss \rightarrow id_{x,0} \rightarrow id_{x,1} \rightarrow T$ 的节点 $x$，则反悔路径为 $id_{b,1} \rightarrow M \rightarrow m \rightarrow id_{a,0} \rightarrow ss \rightarrow id_{x,0} \rightarrow id_{x,1} \rightarrow T$；

- 还有一个比较复杂的推流：找到一个有交匹配，类似上一种情况先把这个有交匹配退回到 $ss$ 然后做一次情况 $1/2$ 的反悔再找到一个没有有交的匹配从 $ss$ 把退回去的有交匹配分配给该有交匹配。

转化成正常的反悔操作：

- 找到一个只选了 $a$ 数组没选 $b$ 数组的位置和只选了 $b$ 数组没选 $a$ 数组的位置，记为 $A,B$，反悔 $B$ 的选择让 $A$ 形成有交匹配；

- 找到一个只选了 $a$ 数组没选 $b$ 数组的位置和只选了 $b$ 数组没选 $a$ 数组的位置，记为 $A,B$，反悔 $A$ 的选择让 $B$ 形成有交匹配；

- 找到一个只选了 $a$ 数组没选 $b$ 数组的位置和只选了 $b$ 数组没选 $a$ 数组的位置，以及一个 $a$ 数组和 $b$ 数组都没选的位置，记为 $A,B,C$ 反悔 $A,B$ 的选择让 $C$ 形成有交匹配；

- 找到一个只选了 $a$ 数组没选 $b$ 数组的位置和只选了 $b$ 数组没选 $a$ 数组的位置，以及一个 $a$ 数组和 $b$ 数组都选了的位置，记为 $A,B,C$ 反悔 $C$ 的选择让 $A,B$ 形成有交匹配。

用堆维护上述操作，时间复杂度 $O(n \log n)$。

```cpp
/*
考虑暴力建图费用流。
由于总流量是确定的，所以可以直接拆上下界变成最大费用最大流 
S -> i , i' -> T , 
i -> O(K - L) , O -> i'
考虑怎么模拟费用流，肯定要反悔贪心的。
考虑分析手段，可不可以直接暴力反悔
是可以的。直接模拟所有的回退和选择操作就可以了。 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e5 + 5 , Inf = 2e9 + 1;
#define ll long long
#define mk(x , y) make_pair(x , y)
#define pll pair<ll,ll> 
#define fr first
#define sc second
int n,K,L,a[Len],b[Len],flag[Len];
priority_queue<pll,vector<pll>,less<pll> > Q[6];
int p[Len],psy[15];
ll mx[15];
//只 b +a 0
//只 b -b 1
//只 a +b 2
//只 a -a 3
//a,b none (a + b) 4
//a,b both -(a + b) 5
//压位，0 表示都没选，1 表示 a，2 表示 b，3 表示 a,b 
/*四种情况：
有a无b+无a有b -> 有 a,b 
无a有b+有a无b -> 有 a,b
反悔一个两个都没有的，从有a无b+无a有b中抽出来
反悔一个两个没有的，从有a无b+无a有b中抽出来
*/
inline void push(int x)
{
	int op = flag[x];
	if(!op){Q[4].push(mk(a[x] + b[x] , x));}
	else if(op == 1){Q[2].push(mk(b[x] , x)) , Q[3].push(mk(-a[x] , x));}
	else if(op == 2){Q[0].push(mk(a[x] , x)) , Q[1].push(mk(-b[x] , x));}
	else Q[5].push(mk(-(a[x] + b[x]) , x));
}
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline bool cmp1(int x,int y){return a[x] > a[y];}
inline bool cmp2(int x,int y){return b[x] > b[y];}
int main()
{
	psy[0] = psy[1] = 2 , psy[2] = psy[3] = 1 , psy[4] = 0 , psy[5] = 3;
	int T;T = read();
	while(T --)
	{
		n = read() , K = read() , L = read();ll as = 0;for(int i = 0 ; i < 6 ; i ++){while(!Q[i].empty()) Q[i].pop();Q[i].push(mk(-Inf , 0));}
		for(int i = 1 ; i <= n ; i ++) flag[i] = 0 , a[i] = read() , p[i] = i;for(int i = 1 ; i <= n ; i ++) b[i] = read(); 
		sort(p + 1 , p + 1 + n , cmp1);for(int i = 1 ; i <= K ; i ++) as += a[p[i]] , flag[p[i]] |= 1;
		sort(p + 1 , p + 1 + n , cmp2);for(int i = 1 ; i <= K ; i ++) as += b[p[i]] , flag[p[i]] |= 2;
		for(int i = 1 ; i <= n ; i ++) L -= (flag[i] == 3) , push(i);
		while(L > 0)
		{
			for(int i = 0 ; i < 6 ; i ++)
			{
				while(!Q[i].empty() && flag[Q[i].top().sc] != psy[i]) Q[i].pop();
				mx[i] = Q[i].top().fr;
			}
			ll V[5],mxn;
			V[1] = mx[0] + mx[3] , V[2] = mx[1] + mx[2] , V[3] = mx[4] + mx[3] + mx[1] , V[4] = mx[0] + mx[2] + mx[5];
			mxn = V[1];
			for(int i = 2 ; i <= 4 ; i ++) mxn = max(mxn , V[i]);
			as += mxn;
			if(mxn == V[1]){int x = Q[0].top().sc , y = Q[3].top().sc;flag[x] = 3 , flag[y] = 0;push(x) , push(y);}
			else if(mxn == V[2]){int x = Q[1].top().sc , y = Q[2].top().sc;flag[x] = 0 , flag[y] = 3;push(x) , push(y);}
			else if(mxn == V[3]){int x = Q[4].top().sc , y = Q[3].top().sc , z = Q[1].top().sc;flag[x] = 3 , flag[y] = flag[z] = 0;push(x) , push(y) , push(z);}
			else{int x = Q[0].top().sc , y = Q[2].top().sc , z = Q[5].top().sc;flag[x] = flag[y] = 3 , flag[z] = 0;push(x) , push(y) , push(z);}
			L --;
		}
		printf("%lld\n",as);
	}
	return 0;
}
```

---

## 作者：JiaY19 (赞：2)

[CF436E Cardboard Box](https://www.luogu.com.cn/problem/CF436E)的升级版。

直接上来搞六个堆的反悔贪心。

### 思路

首先按照贪心的思路，将两个序列中最大 $k$ 个直接选。

如果其中相同的小于 $l$，我们考虑进行反悔贪心。

我们设当前序列相同的个数为 $res$。

我们每一回合都要让 $res+1$。

应该有四种情况：

1. 选择一个之前选了 $b$ 没选 $a$ 的位置，将 $a$ 选上，再丢掉一个只选了 $a$ 的位置上的 $a$。

1. 选择一个之前选了 $a$ 没选 $b$ 的位置，将 $b$ 选上，再丢掉一个只选了 $b$ 的位置上的 $b$。

1. 选择一个之前选了 $b$ 没选 $a$ 的位置，和一个之前选了 $a$ 没选 $b$ 的位置，将 $a,b$ 选上，再丢掉一个选了 $a,b$ 的位置上的 $a,b$。

1. 选择一个什么都没选位置上的 $a,b$，将他们选上，再选择一个之前选了 $b$ 没选 $a$ 的位置，和一个之前选了 $a$ 没选 $b$ 的位置，将 $a,b$ 丢掉。

列成式子就是：

* $a_{max}-a_{min}$
* $b_{max}-b_{min}$
* $(a+b)_{max}-a_min-b_min$
* $a_{max}+b_{max}-(a+b)_{min}$

然后就可以开六个堆来维护这些式子。

最后，就是板子了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
    int s = 0 , f = 1; char ch;
    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;
    while(isdigit(ch)) s = s * 10 + ch - '0' , ch = getchar();
    return s * f;
}

const int maxn = 200010;

int t , n , k , l , vis[maxn] , a[maxn] , b[maxn];

struct edge
{
	int id , num;
}al[maxn] , bl[maxn];

inline bool cmp(edge x , edge y)
{
	return x.num > y.num;
}

struct qwq
{
	int sum , id;
	inline bool operator<(const qwq &tmp) const
	{
		return sum < tmp.sum;
	}
	
	inline bool operator>(const qwq &tmp) const
	{
		return sum > tmp.sum;
	}
};

priority_queue<qwq , vector<qwq> , less<qwq> > q1 , q2 , q6;
priority_queue<qwq , vector<qwq> , greater<qwq> > q3 , q4 , q5;

/*
q1 -> a_i          q2 -> b_i
q3 -> a_i          q4 -> b_i
q5 -> a_i + b_i    q6 -> a_i + b_i
*/

inline void solve(int i)
{
	if(vis[i] == 0) q6.push({a[i] + b[i] , i});
	if(vis[i] == 1) q2.push({b[i] , i}) , q3.push({a[i] , i});
	if(vis[i] == 2) q1.push({a[i] , i}) , q4.push({b[i] , i});
	if(vis[i] == 3) q5.push({a[i] + b[i] , i});
}

inline void init()
{
	memset(vis , 0 , sizeof(vis));
	while(q1.empty() == 0) q1.pop();
	while(q2.empty() == 0) q2.pop();
	while(q3.empty() == 0) q3.pop();
	while(q4.empty() == 0) q4.pop();
	while(q5.empty() == 0) q5.pop();
	while(q6.empty() == 0) q6.pop();
}

signed main()
{
	t = read();
	while(t--)
	{
		init();
		long long sum = 0 , res = 0;
		//sum当前和,res当前匹配数量. 
		n = read() , k = read() , l = read();
		for(int i = 1;i <= n;i++) a[i] = read() , al[i] = {i , a[i]};
		for(int i = 1;i <= n;i++) b[i] = read() , bl[i] = {i , b[i]};
		sort(al + 1 , al + n + 1 , cmp);
		sort(bl + 1 , bl + n + 1 , cmp);
		for(int i = 1;i <= k;i++)
			sum += al[i].num , vis[al[i].id] = (vis[al[i].id] > 0 ? 3 : 1),
			sum += bl[i].num , vis[bl[i].id] = (vis[bl[i].id] > 0 ? 3 : 2);
		//vis_i == 1 只选 a_i
		//vis_i == 2 只选 b_i
		//vis_i == 3 都选了. 
		for(int i = 1;i <= n;i++)
			res += (vis[i] == 3);
		for(int i = 1;i <= n;i++) solve(i);
		while(res < l)
		{
			long long lsum = -10000000000 , casel = 0;
			
			while(q1.empty() == 0 && vis[q1.top().id] != 2) q1.pop();
			while(q2.empty() == 0 && vis[q2.top().id] != 1) q2.pop();
			while(q3.empty() == 0 && vis[q3.top().id] != 1) q3.pop();
			while(q4.empty() == 0 && vis[q4.top().id] != 2) q4.pop();
			while(q5.empty() == 0 && vis[q5.top().id] != 3) q5.pop();
			while(q6.empty() == 0 && vis[q6.top().id] != 0) q6.pop();
			
			if(q1.empty() == 0 && q3.empty() == 0)
			{
				if(lsum < q1.top().sum - q3.top().sum)
					lsum = q1.top().sum - q3.top().sum , casel = 1;
			}
			
			if(q2.empty() == 0 && q4.empty() == 0)
			{
				if(lsum < q2.top().sum - q4.top().sum)
					lsum = q2.top().sum - q4.top().sum , casel = 2;
			}
			
			if(q1.empty() == 0 && q2.empty() == 0 && q5.empty() == 0)
			{
				if(lsum < q1.top().sum + q2.top().sum - q5.top().sum)
					lsum = q1.top().sum + q2.top().sum - q5.top().sum , casel = 3;
			}
			
			if(q3.empty() == 0 && q4.empty() == 0 && q6.empty() == 0)
			{
				if(lsum < q6.top().sum - q3.top().sum - q4.top().sum)
					lsum = q6.top().sum - q3.top().sum - q4.top().sum , casel = 4;
			}
			
			if(casel == 1)
				vis[q1.top().id] = 3 , vis[q3.top().id] = 0,
				solve(q1.top().id) , solve(q3.top().id),
				q1.pop() , q3.pop();
				
			if(casel == 2)
				vis[q2.top().id] = 3 , vis[q4.top().id] = 0,
				solve(q2.top().id) , solve(q4.top().id),
				q2.pop() , q4.pop();
				
			if(casel == 3)
				vis[q1.top().id] = 3 , vis[q2.top().id] = 3 , vis[q5.top().id] = 0,
				solve(q1.top().id) , solve(q2.top().id) , solve(q5.top().id),
				q1.pop() , q2.pop() , q5.pop();
				
			if(casel == 4)
				vis[q3.top().id] = 0 , vis[q4.top().id] = 0 , vis[q6.top().id] = 3,
				solve(q3.top().id) , solve(q4.top().id) , solve(q6.top().id),
				q3.pop() , q4.pop() , q6.pop();
			
			sum += lsum , res++;
		}
		cout << sum << endl;
	}
    return 0;
}
```

---

## 作者：tzc_wk (赞：0)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P5470)

好几天没写题解了，写篇题解意思一下（大雾

考虑反悔贪心，首先我们考虑取出 $a,b$ 序列中最大的 $k$ 个数，但这样并不一定满足交集 $\ge L$ 的限制，因此我们需要调整，我们假设 $L-$ $a,b$ 序列中最大的 $k$ 个数的交集为 $L'$，如果 $L'\le 0$ 那不用调整直接输出即可。否则我们考虑每次调整部分 $a_i,b_i$ 的取值使得 $a,b$ 的交集加 $1$，不难发现每次调整可能有以下可能：

1. 选择两个下标 $x,y$，满足选择了 $a_x$ 没选 $b_x$，以及选择了 $b_y$ 没选 $a_y$，将 $a_x$ 改为 $a_y$，答案增加 $a_y-a_x$
2. 选择两个下标 $x,y$，满足选择了 $b_x$ 没选 $a_x$，以及选择了 $a_y$ 没选 $b_y$，将 $b_x$ 改为 $b_y$，答案增加 $b_y-b_x$
3. 选择三个下标 $x,y,z$，满足选择了 $a_x$ 没选 $b_x$，选择了 $b_y$ 没选 $a_y$，$a_z,b_z$ 都没选，将 $a_x$ 改为 $a_z$，$b_y$ 改为 $a_z$，答案增加 $(a_z+b_z)-a_x-b_y$
4. 选择三个下标 $x,y,z$，满足选择了 $a_x$ 没选 $b_x$，选择了 $b_y$ 没选 $a_y$，$a_z,b_z$ 都被选择了，将 $a_z$ 改为 $a_y$，$b_z$ 改为 $b_x$，答案增加 $a_y+b_x-(a_z+b_z)$

思路理到这里，聪明的读者一定能够发现，接下来的步骤与[此题](https://www.cnblogs.com/ET2006/p/Codeforces-436E.html)第二个解法大同小异了，我们记 $st_i$ 表示下标为 $i$ 的位置被选择的情况，$st_i=0$ 表示 $a_i,b_i$ 都没选，$st_i=1$ 表示 $a_i$ 被选 $b_i$ 没选，$st_i=2$ 表示 $b_i$ 被选 $a_i$ 没选，$st_i=3$ 表示 $a_i,b_i$ 都被选。

那么考虑维护六个大根堆：

- $q_1=\{a_i|st_i=2\}$
- $q_2=\{b_i|st_i=1\}$
- $q_3=\{-a_i|st_i=1\}$
- $q_4=\{-b_i|st_i=2\}$
- $q_5=\{a_i+b_i|st_i=0\}$
- $q_6=\{-a_i-b_i|st_i=3\}$

对于情况 $1$ 相当于是取出 $q_1,q_3$ 的根节点，情况 $2$ 相当于是取出 $q_2,q_4$ 的根节点，情况 $3$ 相当于是取出 $q_3,q_4,q_5$ 的根节点，情况 $4$ 相当于是取出 $q_1,q_2,q_6$ 的根节点，然后 xjb 乱搞一下就行了（确信

时间复杂度线对。

~~感觉这个 D1T3 比 D1T2 简单，虽然我都不会做~~

```cpp
const int MAXN=2e5;
int n,k,l,a[MAXN+5],b[MAXN+5],st[MAXN+5];
pii ap[MAXN+5],bp[MAXN+5]; 
priority_queue<pii> q1,q2,q3,q4,q5,q6;
/*
q1: maximum a[i] with st[i]=2
q2: maximum b[i] with st[i]=1
q3: maximum -a[i] with st[i]=1
q4: maximum -b[i] with st[i]=2
q5: maximum a[i]+b[i] with st[i]=0
q6: maximum -a[i]-b[i] with st[i]=3
*/
void solve(){
	scanf("%d%d%d",&n,&k,&l);memset(st,0,sizeof(st));
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),ap[i]=mp(a[i],i);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]),bp[i]=mp(b[i],i);
	sort(ap+1,ap+n+1);reverse(ap+1,ap+n+1);
	sort(bp+1,bp+n+1);reverse(bp+1,bp+n+1);ll ans=0;
	for(int i=1;i<=k;i++) st[ap[i].se]|=1,ans+=ap[i].fi;
	for(int i=1;i<=k;i++) st[bp[i].se]|=2,ans+=bp[i].fi;
	for(int i=1;i<=n;i++) l-=(st[i]==3);chkmax(l,0);
	q1.push(mp(-2e9,0));q2.push(mp(-2e9,0));q3.push(mp(-2e9,0));
	q4.push(mp(-2e9,0));q5.push(mp(-2e9,0));q6.push(mp(-2e9,0));
	for(int i=1;i<=n;i++){
		if(st[i]==2){
			q1.push(mp(a[i],i));
			q4.push(mp(-b[i],i));
		} if(st[i]==1){
			q2.push(mp(b[i],i));
			q3.push(mp(-a[i],i));
		} if(!st[i]){
			q5.push(mp(a[i]+b[i],i));
		} if(st[i]==3){
			q6.push(mp(-a[i]-b[i],i));
		}
	}
	while(l--){
		#define qpop(a,b)\
			while(!q##a.empty()){\
				int x=q##a.top().se;\
				if(!x||st[x]==b) break;\
				q##a.pop();\
			}
		qpop(1,2);qpop(2,1);qpop(3,1);
		qpop(4,2);qpop(5,0);qpop(6,3);
		ll res1=0ll+q1.top().fi+q3.top().fi;
		ll res2=0ll+q2.top().fi+q4.top().fi;
		ll res3=0ll+q3.top().fi+q4.top().fi+q5.top().fi;
		ll res4=0ll+q1.top().fi+q2.top().fi+q6.top().fi;
		ll mx=max(max(res1,res2),max(res3,res4));ans+=mx;
		if(res1==mx){
			int x=q1.top().se,y=q3.top().se;
			q1.pop();q3.pop();st[x]=3;st[y]=0;
			q5.push(mp(a[y]+b[y],y));
			q6.push(mp(-a[x]-b[x],x));
		} else if(res2==mx){
			int x=q2.top().se,y=q4.top().se;
			q2.pop();q4.pop();st[x]=3;st[y]=0;
			q5.push(mp(a[y]+b[y],y));
			q6.push(mp(-a[x]-b[x],x));
		} else if(res3==mx){
			int x=q3.top().se,y=q4.top().se,z=q5.top().se;
			q3.pop();q4.pop();q5.pop();st[x]=st[y]=0;st[z]=3;
			q5.push(mp(a[x]+b[x],x));
			q5.push(mp(a[y]+b[y],y));
			q6.push(mp(-a[z]-b[z],z));
		} else{
			int x=q1.top().se,y=q2.top().se,z=q6.top().se;
			q1.pop();q2.pop();q6.pop();st[x]=st[y]=3;st[z]=0;
			q6.push(mp(-a[x]-b[x],x));
			q6.push(mp(-a[y]-b[y],y));
			q5.push(mp(a[z]+b[z],z));
		}
	} printf("%lld\n",ans);
	#define clr(x) while(!q##x.empty()) q##x.pop();
	clr(1);clr(2);clr(3);clr(4);clr(5);clr(6);
}
int main(){
	freopen("sequence.in","r",stdin);
	freopen("sequence.out","w",stdout);
	int qu;scanf("%d",&qu);
	while(qu--) solve();
	return 0;
}
```





---

## 作者：ViXbob (赞：0)

首先我们有一个非常 naive 想法：设$c_i=a_i+b_i$，把这个$c$降序排序后取前$\text{L}$个剩下的$\text{K-L}$在分别在$a,b$中贪心的选取即可。然后你发现小样例的第三组数据都过不去。

问题在哪？

事实上我们从大到小每选取一个$c$中的元素，就**可能会影响**最后我们选择的$\text{2(K-L)}$个元素的和的大小。

所以我们考虑在选择$c$中的元素时提前将后面的贡献计算进来再取最大值。所以当我们已经选择的元素的集合为$S$是,$a$中不属于$S$的前$\text{K-L}$大的元素的集合为$S_a$，$b$中不属于$S$的前$\text{K-L}$大的元素的集合为$S_b$时，我们这次操作的最大值为：

$$\max_{1\le i \le n,i \not\in S}\{a_i+b_i-[i\in S_a](a_i-A)-[i\in S_b](b_i-B)\}$$

$A$为$a$中没被选择的第$\text{K-L+1}$大的值，$B$同理。

这个东西暴力算是$O(nL)$，可以获得$64$分的好成绩。

然后我们发现我们每次取出一对值，对于$S_a,S_b$的集合大小影响$\le 1$。分类讨论后维护四个堆就好了，分别维护$i$同时属于$S_a,S_b$，只属于一个，两个都不属于的最大值。然后四个最大值取个$\max$。实际上我们还要维护一个支持删除的有序表，直接排个序建一个链表就行了。注意取出来的最大值属于不同状态时对$a,b$中第$\text{K-L+1}$大的元素的影响。

复杂度$O(L\log n)$。

本质上应该和毛爷爷的 ppt 里讲得方法差不多，但好像简洁一点，我这个少维护了两个堆。(2333

所以我这个弱智儿童为啥在考试的时候放弃了后面的$36$分啊，草。

代码：

```cpp
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define dep(i, j, k) for(int i = j; i >= k; --i)
#define mp make_pair
#define fi first
#define se second
#define SIZE(x) ((int)x.size())

typedef long long ll;

using namespace std;

const int maxn = 2e5 + 5;
const int inf = 0x3f3f3f3f;

int n, L, K, a[maxn], b[maxn], c[maxn];

inline int read() {
	char ch = getchar(); int u = 0, f = 1;
	while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch))  { u = u * 10 + ch - 48; ch = getchar(); } return u * f;
}

namespace n_2000 {
	const int maxn = 2e3 + 5;
	pair<int, int> A[maxn], B[maxn], rA[maxn], rB[maxn];
	ll ans = 0;
	bool visa[maxn], visb[maxn], ca[maxn], cb[maxn];
	inline bool check() { return n < 0; }
	int main() {
		ans = 0;
		memset(ca, 0, sizeof(ca)); memset(cb, 0, sizeof(cb));
		int Z = K - L;
		rep(i, 1, n) rA[i] = mp(a[i], i);
		rep(i, 1, n) rB[i] = mp(b[i], i);
		sort(rA + 1, rA + 1 + n, greater<pair<int, int> >());
		sort(rB + 1, rB + 1 + n, greater<pair<int, int> >());
		while(L) {
			int tot = 0, now = -inf, M = 0, rl = 0;
			rep(i, 1, n) visa[i] = visb[i] = 0;
			tot = 0;
			rep(i, 1, n) if(!ca[rA[i].se]) A[++tot] = rA[i];
			tot = 0;
			rep(i, 1, n) if(!cb[rB[i].se]) B[++tot] = rB[i];
			int basea = A[Z + 1].fi, baseb = B[Z + 1].fi;
			rep(i, 1, Z) visa[A[i].se] = visb[B[i].se] = 1;
			rep(i, 1, n) if(!ca[i] && !cb[i]) {
				int tmp = a[i] + b[i] + (visa[i]) * (basea - a[i]) + (visb[i]) * (baseb - b[i]);
				if(tmp > now) { now = tmp; M = i; rl = a[i] + b[i]; }
			}
			ans += rl; ca[M] = cb[M] = 1;
			L--; K--;
		}
		cerr << ans << endl;
		int tot = 0;
		tot = 0;
		rep(i, 1, n) if(!ca[rA[i].se]) A[++tot] = rA[i];
		tot = 0;
		rep(i, 1, n) if(!cb[rB[i].se]) B[++tot] = rB[i];
		rep(i, 1, K) ans += A[i].fi + B[i].fi;
		cout << ans << endl;
		return 0;
	}
}

namespace ViXbob {
	const int maxn = ::maxn;
	pair<int, int> A[maxn], B[maxn], rA[maxn], rB[maxn];
	int nxta[maxn], prea[maxn], nxtb[maxn], preb[maxn], Z, nowa, nowb, posa[maxn], posb[maxn];
	ll ans = 0;
	bool visa[maxn], visb[maxn], ca[maxn], cb[maxn];
	priority_queue<pair<int, int> > q[4];
	inline bool check() { return n < maxn; }
	inline void cleartag() {
		while(q[0].size() && !(visa[q[0].top().se] && visb[q[0].top().se])) q[0].pop();
		while(q[1].size() && !(visa[q[1].top().se] && !visb[q[1].top().se])) q[1].pop();
		while(q[2].size() && !(!visa[q[2].top().se] && visb[q[2].top().se])) q[2].pop();
		while(q[3].size() && !(!visa[q[3].top().se] && !visb[q[3].top().se])) q[3].pop(); 
	}
	inline int getmax() {
		int rnt = -inf, M = -1;
		cleartag();
		if(q[0].size()) rnt = a[nowa] + b[nowb], M = 0;
		if(q[1].size() && q[1].top().fi + a[nowa] > rnt) rnt = q[1].top().fi + a[nowa], M = 1;
		if(q[2].size() && q[2].top().fi + b[nowb] > rnt) rnt = q[2].top().fi + b[nowb], M = 2;
		if(q[3].size() && q[3].top().fi > rnt) rnt = q[3].top().fi, M = 3;
		return M;
	}
	int main() {
		ans = 0; Z = K - L;
		memset(visa, 0, sizeof(visa)); memset(visb, 0, sizeof(visb));
		memset(nxta, 0, sizeof(nxta)); memset(prea, 0, sizeof(prea));
		memset(nxtb, 0, sizeof(nxtb)); memset(preb, 0, sizeof(preb));
		rep(i, 1, n) A[i] = mp(a[i], i), B[i] = mp(b[i], i);
		sort(A + 1, A + 1 + n, greater<pair<int, int> >());
		sort(B + 1, B + 1 + n, greater<pair<int, int> >());
//		rep(i, 1, n) cerr << A[i].fi << " "; cerr << endl;
//		rep(i, 1, n) cerr << B[i].fi << " "; cerr << endl;
		nowa = A[Z + 1].se; nowb = B[Z + 1].se;
		rep(i, 1, Z) visa[A[i].se] = visb[B[i].se] = 1;
		while(q[0].size()) q[0].pop();
		while(q[1].size()) q[1].pop();
		while(q[2].size()) q[2].pop();
		while(q[3].size()) q[3].pop();
		rep(i, 1, n) {
			prea[i] = i - 1; nxta[i] = i + 1;
			preb[i] = i - 1; nxtb[i] = i + 1;
			posa[A[i].se] = i; posb[B[i].se] = i;
			if(visa[i] && visb[i]) q[0].push(mp(0, i));
			else if(visa[i] && !visb[i]) q[1].push(mp(b[i], i));
			else if(!visa[i] && visb[i]) q[2].push(mp(a[i], i));	
			else q[3].push(mp(a[i] + b[i], i));
		}
		nxta[0] = nxtb[0] = 1;
		while(L) {
//			cerr << "----------------------" << endl;
			int M = getmax(), tmp = q[M].top().se; q[M].pop();
			ans += a[tmp] + b[tmp];
			int pa = posa[tmp], pb = posb[tmp];
			nxta[prea[pa]] = nxta[pa]; prea[nxta[pa]] = prea[pa];
			nxtb[preb[pb]] = nxtb[pb]; preb[nxtb[pb]] = preb[pb];	
			int Na = nxta[posa[nowa]], Nb = nxtb[posb[nowb]];
//			cerr << tmp << " " << M << endl;
//			cerr << nowa << " " << nowb << endl;
//			cerr << pa << " " << pb << endl;
			if(M == 0) {
				if(nowa != nowb) {
					if(visb[nowa]) q[0].push(mp(0, nowa));
					else q[1].push(mp(b[nowa], nowa));
					if(visa[nowb]) q[0].push(mp(0, nowb));
					else q[2].push(mp(a[nowb], nowb));
				} else q[0].push(mp(0, nowa));
				visa[nowa] = visb[nowb] = 1;
				nowa = A[Na].se; nowb = B[Nb].se;
			} else if(M == 1) {
				if(visb[nowa]) q[0].push(mp(0, nowa));
				else q[1].push(mp(b[nowa], nowa));
				visa[nowa] = 1; nowa = A[Na].se;
				if(nowb == tmp) nowb = B[Nb].se;
			} else if(M == 2) {
				if(visa[nowb]) q[0].push(mp(0, nowb));
				else q[2].push(mp(a[nowb], nowb));
				visb[nowb] = 1; nowb = B[Nb].se;
				if(nowa == tmp) nowa = A[Na].se;
			} else {
				if(nowa == tmp) nowa = A[Na].se;
				if(nowb == tmp) nowb = B[Nb].se;
			} L--;
//			cerr << nowa << " " << nowb << endl;
		}
//		cerr << ans << endl;
		for(int i = 1, u = 0, v = 0; i <= Z; i++) {
			u = nxta[u]; v = nxtb[v];
			ans += A[u].fi + B[v].fi;
		}
		cout << ans << endl;
		return 0;
	}
}

int main() {
	freopen("sequence.in", "r", stdin);
	freopen("sequence.out", "w", stdout);
	for(int CASE_NUM = read(), CASE_CON = 1; CASE_CON <= CASE_NUM; ++CASE_CON) {
		n = read(); K = read(); L = read();
		rep(i, 1, n) a[i] = read();
		rep(i, 1, n) b[i] = read();
		if(n_2000 :: check()) n_2000 :: main();
		else if(ViXbob :: check()) ViXbob :: main();
	}
	return 0;
}
```

---

## 作者：eee_hoho (赞：0)

牛逼的贪心。

考虑比较暴力的做法，我们可以建如下的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/8b685634.png)

每个边上第一个数是流量，第二个数是费用，中间$(1,0)$的黑边代表选择下标相同的数，浅蓝色的边代表最多可以选$K-L$个下标不同的数，最后连向$t$的是最多选$K$个数。

然后在这个图上跑最小费用最大流就可以得到答案。

如何优化复杂度，考虑模拟费用流，首先$K-L$这条边的流比较好模拟，因为是随便选，所以考虑选$a,b$中前$K-L$大的数，然后如果选到下标相同的数，那么就不流这条，让他在对应的边中流是最优的。

我们选完之后就要考虑如何流对应的边，那么我们可以选择$a_i,b_i$都没被选过的流过去；还可以选择一个$a_i$被选过了，选一个$b_i$补上$a_i$，然后$K-L$这条边少了一点流量，所以再选一个最大的没有被选的$a_i$来作为独立的来补充流量；$b_i$也是同理。

所以我们贪心地找最优的流法往后流，这样一定是最优的，因为每次都只会让对应的流量增加1，所以贪心显然正确。

然后有一点需要注意，就是如果$K-L$这条边的流量不满，那么我们一定要每次选$a,b$中各最大的来补充流量，比如这样子：

$$a_1,(a_2),a_3,(a_4),a_5,a_6$$
$$b_1,b_2,(b_3),b_4,b_5,(b_6)$$

加了括号的是被选过了。

假设我们下一次选$a_3,b_2$，那么$K-L$的流量就会不满，所以我们要在剩下的局面中各选一个最大的$a,b$，假如是$a_5,b_1$，这样就满足满流了，但如果最大的$a,b$是$a_5,b_5$，那就还得继续选直到满流。

**Code**
``` cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#define mp make_pair
#define fi first
#define se second
const int N = 2e5;
long long inf = 1e17;
using namespace std;
int T,n,K,L,a[N + 5],b[N + 5],va[N + 5],vb[N + 5],ll,kk;
priority_queue <pair<int,int> > q,qa,qb,qqa,qqb;
long long ans,res;
int main()
{
    scanf("%d",&T);
    while (T--)
    {
        scanf("%d%d%d",&n,&K,&L);
        for (int i = 1;i <= n;i++)
            scanf("%d",&a[i]);
        for (int i = 1;i <= n;i++)
            scanf("%d",&b[i]);
        for (int i = 1;i <= n;i++)
            va[i] = vb[i] = 0;
        ans = 0;
        while (!q.empty())
            q.pop();
        while (!qa.empty())
            qa.pop();
        while (!qb.empty())
            qb.pop();
        for (int i = 1;i <= n;i++)
        {
            qa.push(mp(a[i],i));
            qb.push(mp(b[i],i));
        }
        ll = 0;
        for (int i = 1;i <= K && ll / 2 < K - L;i++)
        {
            if (qa.empty())
                break;
            int ua = qa.top().se,ub = qb.top().se;
            qa.pop();qb.pop();
            if (ua == ub)
                continue;
            if (vb[ua])
                ll--,ans -= b[ua],vb[ua] = 0;
            else
                ll++,ans += a[ua],va[ua] = 1;
            if (va[ub])
                ll--,ans -= a[ub],va[ub] = 0;
            else
                ll++,ans += b[ub],vb[ub] = 1;
        }
        while (!qa.empty())
            qa.pop();
        while (!qb.empty())
            qb.pop();
        while (!qqa.empty())
            qqa.pop();
        while (!qqb.empty())
            qqb.pop();
        for (int i = 1;i <= n;i++)
        {
            if (!va[i] && vb[i])
                qa.push(mp(a[i],i));
            if (!vb[i] && va[i])
                qb.push(mp(b[i],i));
            if (!va[i] && !vb[i])
                q.push(mp(a[i] + b[i],i));
            if (!va[i])
                qqa.push(mp(a[i],i));
            if (!vb[i])
                qqb.push(mp(b[i],i));
        }
        int mx = 0,typ = 0,ub,ua;
        for (int i = 1;i <= K - ll / 2;i++)
        {
            mx = 0;
            while (!q.empty() && (va[q.top().se] || vb[q.top().se]))
                q.pop();
            if (!q.empty())
            {
                if (mx < q.top().fi)
                    mx = q.top().fi,typ = 1;
            }
            while (!qa.empty() && va[qa.top().se])
                qa.pop();
            if (!qa.empty())
            {
                while (vb[qqb.top().se])
                    qqb.pop();
                ub = qqb.top().se;
                if (mx < qa.top().fi + b[ub])
                    mx = qa.top().fi + b[ub],typ = 2;
            }
            while (!qb.empty() && vb[qb.top().se])
                qb.pop();
            if (!qb.empty())
            {
                while (va[qqa.top().se])
                    qqa.pop();
                ua = qqa.top().se;
                if (mx < qb.top().fi + a[ua])
                    mx = qb.top().fi + a[ua],typ = 3;
            }
            ans += mx;
            if (typ == 1)
            {
                va[q.top().se] = vb[q.top().se] = 1;
                q.pop();
            }
            if (typ == 2)
            {
                ua = qa.top().se;
                va[qa.top().se] = 1;
                qa.pop();
                vb[ub] = 1;
                qqb.pop();
                if (!va[ub])
                    qa.push(mp(a[ub],ub));
                else
                {
                    int sm = 1;
                    while (i != K - ll / 2 && sm)
                    {
                        sm--;
                        while (vb[qqb.top().se])
                            qqb.pop();
                        while (va[qqa.top().se])
                            qqa.pop();
                        ua = qqa.top().se,ub = qqb.top().se;
                        qqa.pop(),qqb.pop();
                        ans += a[ua] + b[ub];
                        va[ua] = vb[ub] = 1;
                        if (!vb[ua])
                            qb.push(mp(b[ua],ua));
                        else
                            sm++;
                        if (!va[ub])
                            qa.push(mp(a[ub],ub));
                        else
                            sm++;
                        i++;
                    }
                }
            }
            if (typ == 3)
            {
                ub = qb.top().se;
                vb[qb.top().se] = 1;
                qb.pop();
                va[ua] = 1;
                qqa.pop();
                if (!vb[ua])
                    qb.push(mp(b[ua],ua));
                else
                {
                    int sm = 1;
                    while (i != K - ll / 2 && sm)
                    {
                        sm--;
                        while (vb[qqb.top().se])
                            qqb.pop();
                        while (va[qqa.top().se])
                            qqa.pop();
                        ua = qqa.top().se,ub = qqb.top().se;
                        qqa.pop(),qqb.pop();
                        ans += a[ua] + b[ub];
                        va[ua] = vb[ub] = 1;
                        if (!vb[ua])
                            qb.push(mp(b[ua],ua));
                        else
                            sm++;
                        if (!va[ub])
                            qa.push(mp(a[ub],ub));
                        else
                            sm++;
                        i++;
                    }
                }
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---


# [NOI2019] I 君的探险

## 题目背景

附加文件可在页面底部「附件」中下载。

### 特别提示

**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**

1. 与原题不同的是，你不需要，也不应该在程序开头包含 `explore.h` 头文件。

2. 为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：

```cpp
void modify(int x);
int query(int x);
void report(int x, int y);
int check(int x);
```

3. 本题仅支持 C++ 语言（包括 `C++`，`C++11`，`C++14`，`C++17`）提交。

## 题目描述

时隔半年，I 君的商店终于开不下去了，他决定转让商店，做一名探险家去探索未知的广阔世界。

根据古书记载，他在一个大荒漠的腹地找到了未知文明创造的地下宫殿，宫殿由 $N$ 个大型洞穴和 $M$ 条连接这些洞穴的双向通路构成。I 君能借助古书分辨所处的洞穴，但书中并没有记录 $M$ 条通路的连接结构，因此他难以搜寻传说中藏在宫殿里的无尽财宝。

不过现在 I 君发现了一个神秘机关，通过它可以获知宫殿的信息，I 君决定利用这个机关来得到宫殿的连接结构，请你来协助他。

地下宫殿可以抽象成一张 $N$ 个点、$M$ 条边的无向简单图（简单图满足任意两点之间至多存在一条直接相连的边），洞穴从 $0 \sim n - 1$ 编号。目前你并不知道边有哪些。

每个洞穴都拥有一个光源，光源有开启、关闭两种状态，只有当光源处于开启状态时它所在的洞穴才会被照亮。初始时所有的光源都处于关闭状态，而光源的状态只能用I 君发现的神秘机关改变。更具体的，使用神秘机关可以进行如下四种操作：

1. 向机关给定一个编号 $x$，机关将会改变$x$ 号洞穴，以及与$x$ 号洞穴有通路直接相连的洞穴的光源状态。即原来开启的光源将会关闭；原来关闭的光源将会开启。

2. 向机关给定一个编号 $x$，机关将会显示当前$x$ 号洞穴光源的状态。

3. 向机关给定两个编号 $x, y$，表示你确定有一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路，并让机关记录。

4. 向机关给定一个编号 $x$，机关将会判断与 $x$ 号洞穴相连的通路是否都已被记录。

机关在完成上一次操作后才能进行下一次操作。机关不能随意使用，因此每种操作的使用次数都有限制，分别为 $L_m, L_q, M, L_c$。你的任务是，编写一个程序，帮助 I 君决定如何合理利用神秘机关，从而正确地找到这 $M$ 条通路。

### 实现细节

你不需要，也不应该实现主函数，你只需要实现函数 `explore(N, M)`，这里的 $N$和 $M$ 分别表示洞穴和通路的个数。你可以通过调用如下四个函数来和交互库进行交互：

1. `modify(x)`

- 这个函数可以令机关执行操作 $1$，给定的编号为 $x$。

- 你需要保证 $0 \leq x < N$，这个函数没有返回值。

2. `query(x)`

- 这个函数可以令机关执行操作 $2$，给定的编号为 $x$。

- 你需要保证 $0 \leq x < N$，这个函数返回 $0$ 或 $1$，表示目前 $x$ 号洞穴的光源为关闭（$0$ 表示）或开启（$1$ 表示）状态。

3. `report(x, y)`

- 这个函数可以令机关执行操作 $3$，给定的编号为 $x, y$。

- 你需要保证 $0 \leq x, y < N$ 且 $x \neq y$，这个函数没有返回值。

4. `check(x)`

- 这个函数可以令机关执行操作 $4$，给定的编号为 $x$。

- 你需要保证 $0 \leq x < N$，这个函数返回 $0$ 或 $1$，其中返回 $1$ 当且仅当与 $x$ 号洞穴相连的所有通路都已通过操作 3 被记录。

评测时，交互库会恰好调用 `explore` 一次。

本题保证所使用的图在交互开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。

数据保证在调用次数限制下，交互库运行所需的时间不超过1s；交互库使用的内存大小固定，且不超过128MB。

### 实现方法

选手工作目录下已经提供了一个 `template_explore.cpp/c/pas`，请将这个文件拷贝一份，重命名为 `explore.cpp/c/pas`，然后在其基础上答题。

1. 对 C++ / C 语言选手

- 请确保你的程序开头有 
```
#include "explore.h"。
```
- 你需要实现的函数 `explore` 的接口信息如下：
```
void explore(int N, int M);
```
- 你可以调用的交互函数的接口如下：
```
void modify(int x);
int query(int x);
void report(int x, int y);
int check(int x);
```

2. 对 Pascal 语言选手

- 注意：Pascal 的代码中实现接口的语法较为复杂，请选手直接在下发的.
`template_explore.pas` 的基础上进行答题，而不是自己从头实现代码。

- 你需要实现的函数 `explore` 的接口信息如下：
```
procedure _explore(N, M : longint);
```
- 注意：这里的函数名称是`_explore` 而非`explore`，如果使用`explore` 将导致编译失败。

- 你可以调用的交互函数的接口如下：
```
procedure modify(x : longint);
function query(x : longint) : longint;
procedure report(x : longint; y : longint);
function check(x : longint) : longint;
```

试题目录下的 `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。

1. 对 `C/C++` 语言的选手：

- 你需要在本题目录下使用如下命令编译得到可执行程序：

- 对于 C 语言：
```
gcc grader.c explore.c -o explore -O2 -lm
```
- 对于 C++ 语言：
```
g++ grader.cpp explore.cpp -o explore -O2 -lm
```

2. 对于 `Pascal` 语言的选手：

- 你需要在本题目录下使用如下命令编译得到可执行程序：
```
fpc grader.pas -o"explore" -O2
```

3. 对于编译得到的可执行程序：

- 可执行文件将从标准输入读入以下格式的数据：

第一行包含三个整数 $L_m, L_q, L_c$ ，第二行包含两个整数 $N, M$，意义如题面描述。

接下来 $M$ 行，每行两个整数 $x, y$，描述一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路。

- 读入完成之后，交互库将调用恰好一次函数 `explore`，用输入的数据测试你的函数。你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。

## 说明/提示

数据第一行的三个整数分别表示三种操作的调用次数限制，即 `modify(x)` 调用次数不能超过 $100$，`query(x)` 调用次数不能超过 $200$，`check(x)` 调用次数不能超过 $300$。

数据第二行的两个整数分别表示洞穴数和通路条数，即 $N = 3 , M = 2$。

`report(x, y)` 调用次数不能超过 $M$，该例子中即不超过 $2$ 次。

下面是一个正确的交互过程：

| 选手程序 | 交互库 | 说明 |
| :----------: | :----------: | :----------: |
|  | 调用 $\text{explore}(3,2)$ | 开始测试 |
| 调用 $\text{modify}(0)$ |  | 对 $0$ 号洞穴做操作 $1$ |
| 调用 $\text{query}(2)$ | 返回 $0$ | 目前 $2$ 号洞穴的光源状态是关闭 |
| 调用 $\text{report}(0,1)$ |  | 发现了道路 $(0,1)$ 并记录 |
| 调用 $\text{check}(0)$ | 返回 $1$ | 与 $0$ 号洞穴相关的道路都已被记录 |
| 调用 $\text{report}(2,1)$ |  | 发现了道路 $(2,1)$ 并记录 |
| 运行结束并返回 | 向屏幕打印 $\text{Correct}$ | 交互结束，结果正确 |

### 下发文件说明

在本试题目录下：

1. `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现。

2. `explore.h` 和 `grader.pas` 是头文件，选手不用关心具体内容。

3. `template_explore.cpp/c/pas` 是我们提供的样例解题源代码。

4. `explore1.in`、`explore2.in`、`explore3.in` 是样例输入，可供测试。

选手注意对所有下发文件做好备份。评测只收取本试题目录下的`explore.c/cpp/pas`，并且对该程序以外的文件的修改无效。

最终评测只会收取 `explore.cpp/c/pas`，修改选手目录下其他文件对评测无效。

本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。

在上述条件基础上，在一个测试点中，你得到满分，当且仅当：

1. 你的每次函数调用均合法，且调用 `modify`、`query` 和 `check` 的次数分别不超过$L_m, L_q, L_c$。

2. 由于 `report` 的调用次数限制为 $M$，你的每次调用都必须记录一条新的且存在的边；即每次调用 `report(x, y)` 时，应满足：有一条连接 $x$ 号洞穴和 $y$ 号洞穴的通路，且在这次调用之前从未调用过 `report(x, y)` 或 `report(y, x)`。

3. 你实现的函数 `explore` 正常返回。

4. 在 `explore` 函数返回时，你已经通过调用 `report` 记录了全部 $M$ 条通路。

本题共 $25$ 个测试点，每个测试点 $4$ 分。每个测试点的数据规模和相关限制见下表。
| 测试点编号 | $N=$ | $M=$ | $L_m=$ | $L_q=$ | $L_c=$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $2$ | $100$ | $100$ | $100$ | 无 |
| $2$ | $100$ | $10\times N$ | $200$ | $10^4$ | $2\times M$ | 无 |
| $3$ | $200$ | $10\times N$ | $200$ | $4\times 10^4$ | $2\times M$ | 无 |
| $4$ | $300$ | $10\times N$ |$299$  | $9\times 10^4$ | $2\times M$ | 无 |
| $5$ | $500$ | $10\times N$ | $499$ | $1.5\times 10^5$ | $2\times M$ | 无 |
| $6$ | $59998$ | $\frac{N}{2}$ | $17\times N$ | $17\times N$ | $0$ | $A$ |
| $7$ | $99998$ | $\frac{N}{2}$ | $18\times N$ | $18\times N$ | $0$ | $A$ |
| $8$ | $199998$ | $\frac{N}{2}$ | $19\times N$ | $19\times N$ | $0$ | $A$ |
| $9$ | $199998$ | $\frac{N}{2}$ | $19\times N$ | $19\times N$ | $0$ | $A$ |
| $10$ | $99997$ | $N-1$ | $18\times N$ | $18\times N$ | $0$ | $B$ |
| $11$ | $199997$ | $N-1$ | $19\times N$ | $19\times N$ | $0$ | $B$ |
| $12$ | $99996$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $C$ |
| $13$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $C$ |
| $14$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $C$ |
| $15$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $D$ |
| $16$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $D$ |
| $17$ | $199995$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $D$ |
| $18$ | $1004$ | $2\times 10^3$ | $10^7$ | $5\times 10^4$ | $2\times M$ | 无 |
| $19$ | $1004$ | $3\times 10^3$ | $10^7$ | $5\times 10^4$ | $2\times M$ | 无 |
| $20$ | $1004$ | $3\times 10^3$ | $10^7$ | $5\times 10^4$ | $2\times M$ | 无 |
| $21$ | $5\times 10^4$ | $2\times N$ | $10^7$ | $10^7$ | $2\times M$ |  无|
| $22$ | $10^5$ | $2\times N$ | $10^7$ | $10^7$ | $2\times M$ | 无 |
| $23$ | $1.5\times 10^5$ | $2\times 10^5$ | $10^7$ | $10^7$ | $2\times M$ | 无 |
| $24$ | $2\times 10^5$ | $2.5\times 10^5$ | $10^7$ | $10^7$ | $2\times M$ | 无 |
| $25$ | $2\times 10^5$ | $3\times 10^5$ | $10^7$ | $10^7$ | $2\times M$ | 无 |

再次提醒，题目保证测试所使用的图在交互开始之前已经完全确定，而不会根据和你的程序的交互动态构造。

表中特殊性质栏中变量的含义如下：

A：保证每个点的度数恰好为 $1$。

B：保证对于每个 $x > 0$，存在恰好一个 $y < x$ 的 $y$ 使得 $x$ 号洞穴与 $y$ 号洞穴有通路直接相连。

C：存在 $0 \sim N - 1$ 的一个排列 $p_0, p_1, \cdots , p_{N-1}$，使得对任意 $1 \leq i < N$，存在一条连接洞穴编号分别为 $p_{i-1}$ 与 $p_i$ 的通路。

D：保证图连通。

- 提示：你的程序可以通过判断传入的 $N$ 的个位来区分上述不同的数据类型。

## 样例 #1

### 输入

```
100 200 300
3 2
0 1
1 2
```

### 输出

```
见“提示与说明”```

# 题解

## 作者：loveJY (赞：44)

NOI2019D2T3

交互题,~~你谷第一篇题解?~~

首先解释交互题是什么,通俗一点,就是 **出题人把答案放在了输入数据里面!** 但是你不能知道实际的全部输入信息,你只能根据他给出的几个信息和调用提前实现好的函数猜出这个输入数据

~~这个解释可能不太对,但对这个题是有用的~~

![](https://cdn.luogu.com.cn/upload/image_hosting/srq9vo4j.png)

交互题不能没有这个啊

## 部分分1 

![](https://cdn.luogu.com.cn/upload/image_hosting/shu8brr4.png)

照此过程模拟即可,只要你能成功实现交互!

4pts

## 部分分2~5

只要有一点点暴力的想法,你会发现,如果我们想找一个点周围的边,那么只需要把这个点modify一次,然后把所有点全部query一遍,其中是亮的我们就record他们之间的一条边,再把这个点modify回去就好

然而直接这样是不行的,我们只需要稍稍优化下暴力,查询只查询和亮暗情况之前有变化的点,就可以省去最后改回来的一次,然后每次只query所有编号大于当前点的点,就可以让总查询数变成$n^2/2$,过掉第5个点

16pts

## 部分分 6~9

满足图由许多两个点的块组成,也就是我们要确定每个点是另外哪个点连着的

这部分也不难想,因为我们仔细观察数据范围可以得出算法的消耗应该是$nlogn$

而logn的算法...而且是交互题....比较泛用的好像有`二进制`啊?

做法也就同样有了,我们按照点的编号第x位二进制是1/0把所有点分成两组,然后把所有是1的点提出来点亮,然后花费n的代价查一遍全局,我们得到一个亮暗集合...那么观察不难的出

>  如果一个点和他的相连点这一位相同,那一定处于暗集合,这一位不同一定处于亮集合

这样我们把所有位都做一遍,再处理一下每个点就能得到每个点对应的点了!

复杂度...全都是$O(nlogn)$

16pts

## 部分分10~11

~~这一部分是最为关键的??~~

满足编号大的只向编号小的连一条边

乍一想和之前的做法好像没有任何关系....除了复杂度....

所以我们还是要想一个log做法?好像还有二分也是log的

那这个题我们对于一个点可以找到他二分范围和性质吗?

很容易发现:**二分范围就是这个点编号到1,性质就是点亮一个前缀看他亮不亮,在某个位置之后一定全都亮**

有这个性质我们就可以对于单个点二分了....而我们有n个点?整体二分就好啦

代价还是$O(nlogn)$

8pts

## 部分分12~14

满足图是一条链

这一部分可能比较需要灵机一动?qwq

因为做法很简单....每个点只会受到两个点的影响...如果我们先花掉O(n)的时间找到一个`初始点`,然后从初始点向两侧扩展...好像就满足每个点只受到一个点的影响了!因为另一个点已知,完全可以计算出那个点的影响

只受到一个点的影响?回到第三档部分分

12pts

## 部分分15~17

~~被迫营业树的部分QAQ~~

之前一部分已经提示我们可以通过一次次扩展点来消掉周围点异或值是一些点的异或和的做法...

那么树,他没有环,我们应该也是可以通过以这个扩展消掉异或和的

* 我们只需要求出每个点u周围点的编号的异或和,然后如果修改这个和表示的点导致u发生改变那么他们之间就有一条边

为啥正确呢?首先你会发现叶子这个性质一定成立

而非叶子我们只需要把叶子从这个树上`剥离`,也就是消掉他的影响,也总有一天会变成叶子就成立了

12pts

至此所有非正解做法都讲完了,其实这道**NOID2T3**的题对于真正NOI选手68pts都不难呢

## 正解

你会发现我们现在都还没有用过这个check,所以正解一定很坑

没错,正解需要一点随机化/xyx

同时,我们可能还需要一个复杂度带log的做法...如果我们把之前的两个做法融合一下,我们可以想到能不能**划分出一个集合,然后在集合里整体二分呢?**

这看上去完全是硬凑,但是想一下和之前的区别,之前是知道一定只有一条边在前面,所以我们一定能满足单调性

但如果我们限制一下二分的过程,然后把奇偶性作为判断的标准呢?你会发现我们一定可以对于前面是奇数条边的点连出边,而前面是偶数的由于整体二分可能判断不了有没有边,因为点亮前缀后他状态没变

所以我们直接按照这个方法去做,就可以连好某个排列里面满足前面边是奇数的那些边

![](https://cdn.luogu.com.cn/upload/image_hosting/shj2i2dh.png)

但是显然连得不够啊....所以我们只需要random_shuffle一个新的排列,然后再在这个排列上做这个事情,就又能够连出去一些边了!

其中check可以用来减少运算量的,如果一个点的周围的边都被标记了下次整体二分就不要把这个点加进去了

然后你肯定要问这样怎么保证复杂度啊

题解有一个结论:rand的一个排列里面有差不多$n/3$个点向前连边是奇数个

不会证,但这道题做完了,完结散花!!

[QAQ](https://loj.ac/submission/783398)

~~写的还不错吧留个赞再走呗~~


---

## 作者：hongzy (赞：17)



**测试点 $1$ 至 $5$：**

暴力，每次改变点 $i$ 的状态，查看 $i + 1...n$ 哪些点状态改变了，改变了说明有边。

注意 modify 只有 $n - 1$ 次机会，请别碰 $n - 1$ 号结点！！

可获得 $20\ \rm pts$。

**测试点 $6$ 至 $9$：**

数据保证 $n$ 个点形成 $n/2$ 个匹配，询问次数上界 $n \log n$ 和 $q \log n$。

考虑整体二分，`solve(l, r, ql, qr)` 表示询问 $[ql,qr]$ 中答案在 $[l,r]$ 里，取中点 mid，每次修改 $l...mid$，对于询问 $x$，如果 $x\in[l,mid]$ 和 $x$ 状态改变这两个条件满足了恰好一个，说明 $x$ 的连边在 $[l,mid]$ 中，递归到左边，其他递归到右边。

有个小问题是状态无法及时更新。即我们在修改 $[l,mid]$ 时，可能把 $[r + 1, n]$ 中的一些点状态改变了，而无法更新这个状态。没有关系，对于边 $(x,y),x<y$，我们分治到 $x$ 时就统计答案。

结合前面的算法可获得 $36\ \rm pts$。

（好像我这个做法比较烦人，但 `modify` 次数为上界的一半）

**测试点 $10$ 至 $11$**

数据保证形成树且父亲结点编号比儿子小，询问次数上界 $n \log n$ 和 $q \log n$。

还是整体二分，考虑询问 $x$，若 $x\leq mid$ 直接分到右边，否则我们把 $[l,mid]$ modify 一次，看 $x$ 是否为 $1$，是则分到左边，否则分到右边。然后再把 $[l,mid]$ modify 回来。一开始脑抽了，没发现这样写只调用了区间长度次 modify，还以为有个二倍常数过不去。

结合前面的算法可获得 $44\ \rm pts$。

**测试点 $12$ 至 $14$**

数据保证形成链，询问次数限制 $10^7$（相当于不 TLE 就行）。

考虑按二进制位做，对于第 $k$ 位，把该位为 $1$ 的结点 modify。询问完再改回去。

对于该位为 $1$ 的结点：

- 若查询的状态为 $1$，说明两端该位 xor 为 $0$。
- 若查询的状态为 $0$，说明两端该位 xor 为 $1$。

该位为 $0$ 的结点同理。这样我们就得到一个点所连两个点的 xor。

暴力询问与 $0$ 相连的点，然后直接递推就能得到答案了。

结合前面的算法可获得 $56\ \rm pts$。

**测试点 $15$ 至 $17$**

数据保证是树，询问次数 $10^7$，允许 $2m$ 次 check。

套有上面的二进制位方法可以求出每个点相邻点编号 xor 和，为了方便标号从 $1$ 开始，$u$ 的相邻结点异或和记做 $p[u]$。

我们维护一个队列 $Q$，初始时加入 $1,2,3,...,n$。

每次取出队列的 front，记做 $u$，通过 modify + query + modify 检查 $u$ 和 $p[u]$ 之间是否有边，若有边就 report，然后把 $p[p[u]]$ 异或上 $u$，让 $p[u]$ 加入队列，再令 $p[u] = 0$，也就是把这条边断了，一直做到队列为空。

由于某个叶子都会往上删，直到把所在连通块删完，做法正确。复杂度也是有保证的，初始 $n$ 个点，每断一条边才会做 push 操作，也就是我们最多取 front  $n+m$ 次。

注意要判重边，因为可能有 $u,v$ 互相删的情况。

另外我感觉使用 check 做也是 ok 的，没有仔细想。

结合前面的算法可获得 $68\ \rm pts$。

**测试点 $18$ 到 $25$（正解）**

~~好，现在非常高兴地告诉你前面的东西和正解没关系~~

类似测试点 $6$ 到 $9$ 做整体二分，先通过 `random_shuffle` 随机打乱结点编号，然后每个点仿照之前的方法“找父亲”，但要注意询问点的状态要消除了已 report 的点的影响。

我们每一轮把 check = 0 的结点加入询问， `random_shuffle`  后做上面所述的整体二分。

证明毫无头绪，网上也没什么资料。

结合前面的算法可获得 $100\ \rm pts$。

**代码**

实现了上述所有 subtask。 

```cpp
#include "explore.h"
#include <bits/stdc++.h>
#define pb push_back
#define rep(i, j, k) for(int i = j; i <= k; ++ i)
#define per(i, j, k) for(int i = j; i >= k; -- i)
using namespace std;

const int N = 2e5 + 10;

namespace task1 {

int st[N];
void main(int n) {
   rep(i, 0, n - 2) {
      modify(i);
      st[i] ^= 1;
      rep(j, i + 1, n - 1) {
         if(query(j) ^ st[j]) {
            st[j] ^= 1;
            report(i, j);
         }
      }
   }
}

}

namespace task2 {

int st[N], q[N], t1[N], t2[N];
bool use[N];
void solve(int l, int r, int ql, int qr) {
   if(ql > qr || l > r) return ;
   if(l == r) {
      rep(i, ql, qr) if(!use[min(q[i], l)]) {
         use[min(q[i], l)] = 1;
         report(q[i] - 1, l - 1);
         break ;
      }
      return ;
   }
   int mid = (l + r) >> 1;
   rep(i, l, mid) modify(i - 1);
   int T1 = 0, T2 = 0;
   rep(i, ql, qr) {
      bool diff = 0;
      if(st[q[i]] ^ query(q[i] - 1)) {
         st[q[i]] ^= 1; diff = 1;
      }
      if(diff ^ (l <= q[i] && q[i] <= mid)) t1[++ T1] = q[i];
      else t2[++ T2] = q[i];
   }
   rep(i, 1, T1) q[ql + i - 1] = t1[i];
   rep(i, 1, T2) q[ql + T1 + i - 1] = t2[i];
   solve(l, mid, ql, ql + T1 - 1);
   solve(mid + 1, r, ql + T1, qr);
}
void main(int n) {
   rep(i, 1, n) q[i] = i;
   solve(1, n, 1, n);
}

}

namespace task3 {

int st[N], q[N], t1[N], t2[N];
void solve(int l, int r, int ql, int qr) {
   if(ql > qr || l > r) return ;
   if(l == r) {
      rep(i, ql, qr) {
         report(l - 1, q[i] - 1);
      }
      return ;
   }
   int mid = (l + r) >> 1, T1 = 0, T2 = 0;
   rep(i, l, mid) modify(i - 1);
   rep(i, ql, qr) {
      if(q[i] <= mid || query(q[i] - 1)) t1[++ T1] = q[i];
      else t2[++ T2] = q[i];
   }
   rep(i, l, mid) modify(i - 1);
   rep(i, 1, T1) q[ql + i - 1] = t1[i];
   rep(i, 1, T2) q[ql + T1 + i - 1] = t2[i];
   solve(l, mid, ql, ql + T1 - 1);
   solve(mid + 1, r, ql + T1, qr);
}
void main(int n) {
   report(0, 1);
   rep(i, 3, n) q[i] = i;
   solve(1, n, 3, n);
}

}

namespace task4 {

int p[N];
void get(int u, int la) {
   if(!(la ^ p[u])) return ;
   report(u, la ^ p[u]);
   get(la ^ p[u], u);
}
void main(int n) {
   for(int i = 0; (1 << i) < n; i ++) {
      rep(u, 0, n - 1) if(u >> i & 1) modify(u);
      rep(u, 0, n - 1) if((u >> i & 1) ^ query(u)) p[u] |= 1 << i;
      rep(u, 0, n - 1) if(u >> i & 1) modify(u);
   }
   modify(0);
   int u = -1, v = -1;
   rep(i, 1, n - 1) if(query(i)) u == -1 ? u = i : v = i;
   report(0, u); get(u, 0);
   if(~ v) {
      report(0, v); get(v, 0);
   }
}

}

namespace task5 {

int p[N];
map< pair<int, int>, bool > Map;
bool ins(int x, int y) {
   pair<int, int> p(min(x, y), max(x, y));
   if(Map[p]) return 0;
   return Map[p] = 1;
}
void main(int n) {
   for(int i = 0; (1 << i) <= n; i ++) {
      rep(u, 1, n) if(u >> i & 1) modify(u - 1);
      rep(u, 1, n) if((u >> i & 1) ^ query(u - 1)) p[u] |= 1 << i;
      rep(u, 1, n) if(u >> i & 1) modify(u - 1);
   }
   queue<int> q;
   rep(i, 1, n) q.push(i);
   while(q.size()) {
      int u = q.front(); q.pop();
      if(p[u] >= 1 && p[u] <= n && p[u] != u) {
         modify(p[u] - 1); int t = query(u - 1); modify(p[u] - 1);
         if(t && ins(u, p[u])) {
            report(u - 1, p[u] - 1);
            p[p[u]] ^= u;
            q.push(p[u]);
            p[u] = 0;
         }
      }
   }
}

}

namespace task6 {

int id[N], q[N], cnt, t1[N], t2[N];
bool use[N], st[N];
vector<int> g[N];
int calc(int u) {
   bool tg = query(id[u] - 1);
   for(int j = 0; j < (int) g[id[u]].size(); j ++) tg ^= st[g[id[u]][j]];
   return tg;
}
void solve(int l, int r, int ql, int qr) {
   if(ql > qr) return ;
   if(l == r) {
      rep(i, ql, qr) if(l != q[i]) {
         report(id[l] - 1, id[q[i]] - 1);
         g[id[l]].pb(id[q[i]]);
         g[id[q[i]]].pb(id[l]);
         cnt --;
      }
      return ;
   }
   int mid = (l + r) >> 1;
   rep(i, l, mid) if(!use[id[i]]) modify(id[i] - 1), st[id[i]] = 1;
   int T1 = 0, T2 = 0;
   rep(i, ql, qr) {
      if(q[i] <= mid || calc(q[i])) t1[++ T1] = q[i];
      else t2[++ T2] = q[i];
   }
   rep(i, l, mid) if(!use[id[i]]) modify(id[i] - 1), st[id[i]] = 0;
   rep(i, 1, T1) q[ql + i - 1] = t1[i];
   rep(i, 1, T2) q[ql + T1 + i - 1] = t2[i];
   solve(l, mid, ql, ql + T1 - 1);
   solve(mid + 1, r, ql + T1, qr);
}
void main(int n, int m) {
   srand(202021);
   cnt = m;
   rep(i, 1, n) id[i] = i;
   while(cnt) {
      random_shuffle(id + 1, id + n + 1);
      int qm = 0;
      rep(i, 1, n) if(!use[id[i]]) q[++ qm] = i;
      solve(1, n, 1, qm);
      if(cnt) rep(i, 1, n) if(!use[i] && check(i - 1)) use[i] = 1;
   }
}

}

void explore(int n, int m) {
   if(n <= 500) task1::main(n);
   else if(n % 10 == 8) task2::main(n);
   else if(n % 10 == 7) task3::main(n);
   else if(n % 10 == 6) task4::main(n);
   else if(n % 10 == 5) task5::main(n);
   else task6::main(n, m);
}
```



---

## 作者：FZzzz (赞：7)

神仙题啊……水篇题解。

~~虽然基本是嫖的。~~

果然这种毒瘤交互题不可能让你写一份代码就完事的……所以我们还是把部分分分开讲吧。
## 1~5
首先显然我们有一个 $O(n^2)$ 的做法：依次改每个点，然后看一下后面每个点是否改变了，如果改变了就说明他们之间有边，最后把这个点改回来。

但是这样是过不去的。事实上我们可以记录一下前一次的状态，这样就不用改回去了。常数减少了一半，可以通过。
```cpp
namespace solve1{
	bool s[maxn];
	void main(){
		for(int i=0;i<n-1;i++){
			modify(i);
			for(int j=i+1;j<n;j++){
				bool res=query(j);
				if(s[j]^res) report(i,j);
				s[j]=res;
			}
		}
	}
}
```
## 6~9
发现这个部分分就是图由一堆两个点的连通块组成。我们需要一个 log 的算法。

可以考虑二进制。依次考虑每一位，修改这一位是一的所有数。然后如果每个数的状态改变了，就说明他对面那个点与他这一位相同，反之不同。
```cpp
namespace solve2{
	bool s[maxn];
	int g[maxn];
	void main(){
		for(int i=0;(1<<i)<n;i++){
			for(int j=0;j<n;j++) if(j>>i&1) modify(j);
			for(int j=0;j<n;j++){
				bool res=query(j);
				g[j]|=(res^s[j]^(j>>i&1))<<i;
				s[j]=res;
			}
		}
		for(int i=0;i<n;i++) if(g[i]<i) report(i,g[i]);
	}
}
```
## 10~11
一棵树，满足父节点小于子节点。

考虑对每个点找出他的父亲。可以想到二分：把左半个区间修改一下，然后看这个点有没有被点亮。如果有，就说明父亲在左半边，反之在右半边。

那么我们整体二分即可。

注意这里的实现：我们在加入询问时是判断了右半边的所有点，看是否加到左边，因为实际上每个点的二分区间应该是零到他减一。
```cpp
namespace solve3{
	void solve(int l,int r,vector<int> p){
		if(l==r){
			for(int i=0;i<(int)p.size();i++) report(p[i],r);
			return;
		}
		int mid=l+(r-l)/2;
		vector<int> pl,pr;
		for(int i=l;i<=mid;i++) modify(i);
		for(int i=mid+1;i<=r;i++) if(query(i)) pl.push_back(i);
		for(int i=0;i<(int)p.size();i++)
			if(query(p[i])) pl.push_back(p[i]);
			else pr.push_back(p[i]);
		for(int i=l;i<=mid;i++) modify(i);
		solve(l,mid,pl);
		solve(mid+1,r,pr);
	}
	void main(){
		solve(0,n-1,vector<int>());
	}
}
```
## 12~17
链和树。

不会。

嘛，实际上我们看一下限制就可以知道，这个部分分可以直接套用正解的做法……所以这里就不讲啦（
## 18~25
同样考虑整体二分。然后手玩一下你可以发现这里实际上是把所有的往前连了奇数条边的点往前连一条边。

根据交互题的套路以及人类智慧，我们意识到只需要 `random_shuffle` 几下然后多做几遍就可以了。

正确性？不会证。

但是这样还是过不去的……发现我们到现在都没有用 `check` 操作？那我们每一轮完了以后 `check` 一下，然后已经好了的我们下一轮就不用再做了。

注意考虑已经确定的边的贡献。
```cpp
namespace solve4{
	bool s[maxn];
	vector<int> g[maxn],ord;
	void solve(int l,int r,vector<int> p){
		if(l==r){
			for(int i=0;i<(int)p.size();i++){
				report(p[i],ord[r]);
				g[p[i]].push_back(ord[r]);
				g[ord[r]].push_back(p[i]);
			}
			return;
		}
		int mid=l+(r-l)/2;
		vector<int> pl,pr;
		for(int i=l;i<=mid;i++){
			modify(ord[i]);
			for(int j=0;j<(int)g[ord[i]].size();j++) s[g[ord[i]][j]]^=1;
		}
		for(int i=mid+1;i<=r;i++)
			if(query(ord[i])^s[ord[i]]) pl.push_back(ord[i]);
		for(int i=0;i<(int)p.size();i++)
			if(query(p[i])^s[p[i]]) pl.push_back(p[i]);
			else pr.push_back(p[i]);
		for(int i=l;i<=mid;i++){
			modify(ord[i]);
			for(int j=0;j<(int)g[ord[i]].size();j++) s[g[ord[i]][j]]^=1;
		}
		solve(l,mid,pl);
		solve(mid+1,r,pr);
	}
	void main(){
		srand(time(0));
		for(int i=0;i<n;i++) ord.push_back(i);
		while(!ord.empty()){
			random_shuffle(ord.begin(),ord.end());
			solve(0,ord.size()-1,vector<int>());
			vector<int> res;
			for(int i=0;i<(int)ord.size();i++)
				if(!check(ord[i])) res.push_back(ord[i]);
			ord=res;
		}
	}
}
```
完结撒花。

~~这垃圾题解不就完全是嫖的怎么可能过审嘛。~~

---

## 作者：Aly_ (赞：6)

#### 题意简述

​	$N$ 点 $M$ 边无向图，形态未知。每个点有状态：关 / 开。现需通过如下四种操作确定图的形态：

- 选定一个点，反转它及其邻点状态；
- 查询一个点状态；
- 记录一条无向边；
- 询问与一个点相连的无向边是否都被记录。

​	其中，第一、三、四种操作次数分别不多于 $L_m,L_q,L_c$。

#### 分析 & 解法

​	顺着部分分推即可。以下展现思路过程。

1. 首先看到暴力 20 分：对每个点修改再询问所有点即可。

```
void cal0(){
	for(int i=1;i<n;i++){
		modify(i-1),fl[i]^=1;
		for(int j=i+1;j<=n;j++){
			if(query(j-1)!=fl[j])fl[j]^=1,report(i-1,j-1);
		}
	}
}
```

​	开始做部分分。

1. 考虑 $A$ 部分性质。发现：整张图被分成了 $\frac{n}{2}$ 对点，只有同一对点之间有连边。
2. 问题转化成求与每一个点配对的点。观察数据范围，发现需要一个 $O(n\log n)$ 左右的做法。猜测会出现大概是**二分 / 分治**的做法。
3. 不妨尝试：把所有点分成两半，只修改其中一半的点再查询。
4. 如果查询到一个点状态改变了，说明其配对点一定在进行了修改操作的点集中。于是可以继续分治下去做。

​	不难想到运用二进制的思想。**总共进行 $\log n$ 轮操作，第 $i$ 次操作修改所有二进制第 $i-1$ 位为 $1$ 的点并查询所有点，即可得到所有点的配对点的当前位是否为 $1$。全部进行完后，所有点的配对点的所有位都确定了。**

```
void cal1(){
	for(int i=2;i<=n;i++)logn[i]=logn[i/2]+1;
	for(int i=0;i<=logn[n];i++){
		for(int j=0;j<n;j++)if(j&(1<<i))modify(j),fl[j]^=1;
		for(int j=0;j<n;j++)if(query(j)!=fl[j])fl[j]^=1,pa[j]|=(1<<i);
	}
	for(int i=0;i<n;i++)if(i<pa[i])report(i,pa[i]);
}
```

​	$B$ 的做法相对简单且包含在 $D$ 中，先考虑 $C$。

1. 观察解决 $A$ 部分的方法，其具有很强的可扩展性。
2. 事实上可以把该方法重述如下：选**取点集 $S,T$，进行 $\log n$ 轮操作，第 $i$ 次操作修改 $T$ 中所有二进制第 $i-1$ 位为 $1$ 的点并查询所有 $S$ 中的点，如果当前点的状态改变则在当前位记 $1$。**
3. 考虑什么时候当前点的状态会改变：$T$ 中有奇数个当前位为 $1$ 的点与当前点相邻。也就是说，$T$ 中所有与之相邻的点，其标号异或和在当前位为 $1$。
4. 于是，该操作得到的是**对于每一个 $S$ 中的点 $x$，$T$ 中所有与它相邻的点标号异或和，记为 $pa_x$。**
5. 考虑链的情况。取 $S,T$ 为全集，做一遍操作，得到所有点的 $pa$。

​	注意到**链的端点（设为 $a$）只有一个点（设为 $b$）与之相连**，所以 $pa_x=b$，因而确定了一条边。而且，与 $b$ 相邻的只有两个点，其中一个就是 $a$，因此，可以在 $b$ 的答案中异或 $a$ 以计算与 $b$ 相邻的另一个点，继续**递推**。

​	而链的端点是易求的：把所有点修改一遍，状态改变的点就是链的端点。

​	下面考虑 $D$。

1. 注意到，如果确定所有叶子，则可以像链一样从下往上 “ 剥叶子 ”，得到所有点的父亲。
2. 然后有一个看起来笨蛋却常常被忽略的事实：**如果修改点 $x$ 后点 $y$ 的状态改变，则 $x$ 和 $y$ 有边**。

​	如果发现该事实解法就显而易见了：**对于每个点 $x$，修改它，看 $pa_x$ 状态变不变**。**如果变了，记录那条边**，**然后询问 $x$ 相连的边是否找尽，如果是，$x$ 就是叶子了**。当然最后还要把 $x$ 修改回来防止不必要的影响。

```
void cal3(){
	for(int i=2;i<=n;i++)logn[i]=logn[i/2]+1;
	for(int i=0;i<=logn[n];i++){
		for(int j=0;j<n;j++)if(j&(1<<i))modify(j),fl[j]^=1;
		for(int j=0;j<n;j++)if(query(j)!=fl[j])fl[j]^=1,pa[j]|=(1<<i);
	}
	for(int j=0;j<n;j++){
		modify(j),fl[j]^=1;
		if(pa[j]<n&&query(pa[j])!=fl[pa[j]]){
if(se.find(make_pair(pa[j],j))==se.end()&&se.find(make_pair(j,pa[j]))==se.end())report(j,pa[j]),se.insert(make_pair(j,pa[j]));
			if(check(j))qu.push(pa[j]),inq[j]=1,pa[pa[j]]^=j;
		}
		modify(j),fl[j]^=1;
	}
	while(!qu.empty()){
		int nt=qu.front();
		qu.pop();
		if(inq[nt])continue;
		if(inq[nt]!=1){
			modify(nt),fl[nt]^=1;
			if(pa[nt]<n&&query(pa[nt])!=fl[pa[nt]]){
if(se.find(make_pair(pa[nt],nt))==se.end()&&se.find(make_pair(nt,pa[nt]))==se.end())report(nt,pa[nt]),se.insert(make_pair(nt,pa[nt]));
				if(check(nt)){
					pa[pa[nt]]^=nt;
					qu.push(pa[nt]);
					inq[nt]=1;
				}
				
			}
			modify(nt),fl[nt]^=1;
		}
	}
}
```

​	下面考虑正解。

1. ~~通过观察题目标签~~猜测本题需要某些**随机化**的手段。（但随机化的标签现在没了？）
2. 一个比较好想的思路是多次随机 $S,T$ 点集，找出它们间的所有边。
3. **可以随机 $T$ 点集，再找到一些点，使之与 $T$ 中的点只有一个相邻**。因为图密度不大，这样的效率看起来很高。	

​	可以做个试验。随机一个大小为 $B$ 的点集 $T$，对于其余所有点，找到所有与奇数个 $T$ 中的点相邻的点，把其作为 $S$ 的候选，统计其中有多少只与一个 $T$ 中的点相邻。

​	取 $n=100000,m=200000$ 随机图，发现当 $B=1000$ 时，$|S|$ 会达到 $4000\sim 6000$ 左右，其中大约有 $2000$ 个点是有效（只与一个 $T$ 中点相邻）的。

​	计算一下操作代价发现不计常数的情况下是可过的。

​	于是有了一个很笨蛋的做法：随机一个大小为 $B=\frac{n}{100}$ 的点集 $T$，对于其余所有点，找到所有与奇数个 $T$ 中的点相邻的点，把其加入 $S$。进行一次操作，求出所有 $pa$。**对于每个 $S$ 中的点，验证其 $pa$ 是否确实和它有边相连。做完后，检查所有 $T$ 和 $S$ 中的点，如果与其相连的边全连完了，就在图中去掉它**。不断去除直至剩余点集为空（或足够小）。

​	在 $n=100000$ 的图上实现之，发现询问次数达到 $2*10^7$。考虑到这个做法看上去就很笨蛋，可以考虑卡常。

​	一个优化是**记录所有与当前点相连的边，找 $S$ 的时候把这些边纳入考虑**：考察这些边另一边点与当前 $T$ 的交集，求奇偶性的时候异或上交集大小。实测可以减小常数 $\frac{2}{3}$ 左右。

​	再调调 $B$ 就过了。

```
void calc(){
	for(int i=2;i<=n;i++)logn[i]=logn[i/2]+1;
	B=max(1,n/100);
	int tn=n,ncol=1;
	while(tn){
		if(tn>=100000)B=max(1,tn/10);
		else B=max(1,(int)(sqrt(tn)*log(tn)));
		if(n%10==4)B=max(1,(int)(sqrt(n)));
		B=min(B,tn);
		pt=0;ncol++;
		for(int i=0;i<n;i++)if(!afl[i])t[++pt]=i;
		for(int i=2;i<=pt;i++)swap(t[i],t[rd()%i+1]);
		for(int i=1;i<=B;i++)ft[t[i]]=i,modify(t[i]),fl[t[i]]^=1,tfl[t[i]]=ncol;
		p0=0;
		for(int i=0;i<n;i++){
			if(afl[i])continue;
			tg[i]=0;int lg=0;
			for(int j=0;j<ve[i].size();j++){
				if(tfl[ve[i][j]]==ncol)tg[i]^=1,lg^=(ft[ve[i][j]]-1);
			}
			if((query(i)!=fl[i])^tg[i]){
				fl[i]^=1,q0[++p0]=i,pa[p0]=lg;
			}
		}
		for(int i=0;i<=logn[B];i++){
			for(int j=1;j<=B;j++)if((j-1)&(1<<i))modify(t[j]),fl[t[j]]^=1;
			for(int j=1;j<=p0;j++)if(query(q0[j])!=fl[q0[j]])fl[q0[j]]^=1,pa[j]^=(1<<i);
		}
		for(int i=1;i<=B;i++)if(query(t[i])!=fl[t[i]])fl[t[i]]^=1;
		for(int i=1;i<=p0;i++){
			if(pa[i]>=B)continue;
			modify(q0[i]),fl[q0[i]]^=1;
			int nt=t[pa[i]+1];
			if(tfl[nt]){
				long long nh=hsh(q0[i],nt);
				if((nse.find(nh)==nse.end())&&query(nt)!=fl[nt]){
					report(q0[i],nt);
					ve[q0[i]].push_back(nt),ve[nt].push_back(q0[i]);
					nse.insert(nh);
				}
			}
			modify(q0[i]),fl[q0[i]]^=1;
		}
		for(int i=1;i<=B;i++){
			if(check(t[i]))afl[t[i]]=1,tn--;
		}
		for(int i=1;i<=p0;i++){
			if(tfl[q0[i]]!=ncol&&check(q0[i]))afl[q0[i]]=1,tn--;
		}
	}
}
```

​	



---

## 作者：EM_LGH (赞：5)

比较神仙的随机化+交互题.    

测试点 $1$ ~ $5$ :    
限制条件不强，可以直接点亮一条边中编号小的点 $x$，然后再枚举编号大于 $x$ 的点.  

操作次数：$O(n)$  

查询次数：$O(n^2)$           

测试点 $6$ ~ $9$： 
图的形态是点两两匹配.    

这里有两种做法： 

1. 随机化    

假设当前要分点集 $A$ 中的点，那么可以先随机出 $B$ 个点.      

对于剩下的 $|A|-B$ 个点，如果状态改变，说明该点也属于 $B$ 集合.  

否则，该点不属于 $B$ 集合.  

这个复杂度不是严格 $O(n \log n)$ 的   

不过可以随机化初始排列，然后$B$ 取 $\frac{1}{3}A$，询问和查询次数都很小.       

2. 二进制分组   

考虑枚举二进制位 $i$，并将含有 $2^i$ 的点点亮.      

那么对于一个点对 $(x,y)$，如果一个被点亮，另一个不被点亮则异或和为 $1$，都被点亮或都不被点亮则为 $0$.     

那么我们就可以通过这种方式求出每个点与其相邻点的异或和.       

所有操作次数都是严格 $O(n \log n)$.    

测试点 $10$ ~ $11$:   
启发正解的测试点，不过即使会了这个测试点还是很难想到正解.     

由于一个点的父亲节点编号一定小于该节点编号，所以求解父节点编号可以二分.  

即点亮一个前缀，然后看 $x$ 的状态是否改变，改变就再向前找，否则向后找.   

对于所有点都要这么求，那就上整体二分.     

测试点 $12$ ~ $14$：   
一条链.  

可以采用上面提到的二进制分组做法，求得每个点与其相邻点的异或和.    

然后找到 $0$ 号点相邻的两个点，用这两个点向两边扩展.  

由于 $0$ 号点将序列从中间断开，所以后面每一个点只受一个点约束，用一个队列来维护就好了.   

正解：  
正解是整体二分.    

考虑有一个集合 $S$ 和点 $x$ （这里 $S$ 中点的编号都小于 $x$）       

显然可以通过 $O(|S|)$ 的操作来求得 $S$ 与 $x$ 连边数量的奇偶性.   

假如说数量为偶，我们不能确定有没有边，但是为奇的话一定有边.   

当确定数量为奇数的时候可以采用二分的方式，即为奇则向前找，为偶则向后找.   

想要找到所有点的一条边的时候就采用整体二分的方式.   

但是不能直接对于 $1$ ~ $n$ 的排列求解，而是多随机几个排列来做.    

每次点和点的大小关系并不是实际大小关系，而是根据排列中的位置来定义的大小关系以保证随机性.     

这里有几个需要注意的地方：   

当一个点周围的所有点都被发现后就应该将这个点除掉.  
随机数种子直接用系统下得就行，不要用 srand(time(NULL))   
代码：（分了 5 个 namespace 写的） 
```cpp
#include <ctime> 
#include <queue> 
#include <cstdio> 
#include <vector> 
#include <cstring> 
#include <algorithm> 
#define N 400008  
#define pb push_back  
using namespace std;   
void modify(int x);
int query(int x);
void report(int x, int y);
int check(int x);        
namespace task0 {   
    int sta[N]; 
    void solve(int n,int m) {   
        for(int i=0;i<n-1;++i) {   
            modify(i);  
            for(int j=i+1;j<n;++j) {   
                int p=query(j);  
                if(p!=sta[j]) {  
                    report(i,j);  
                    sta[j]=p;          
                } 
            } 
        } 
    } 
}; 
// 二进制分组             
namespace taskA {   
    int sta[N],sum[N]; 
    void solve(int n,int m) {      
        int MAX=n-1; 
        for(int i=0;(1<<i)<=MAX;++i) {  
            for(int j=0;j<=MAX;++j) {   
                if(j&(1<<i)) modify(j);  
            }       
            for(int j=0;j<=MAX;++j) { 
                int p=query(j); 
                if(p!=sta[j]) { 
                    sum[j]^=(1<<i);         
                    sta[j]=p; 
                } 
            } 
        }      
        for(int i=0;i<n;++i) {  
            int p=sum[i]^i; 
            if(p>i) report(i,p);  
        } 
    } 
}; 

namespace task3 {   
    int sta[N],sum[N],prev[N];  
    queue<int>q;  
    void solve(int n,int m) {      
        int MAX=n-1;                
        for(int i=0;(1<<i)<=MAX;++i) {  
            for(int j=0;j<=MAX;++j) {   
                if(j&(1<<i)) modify(j);  
            }       
            for(int j=0;j<=MAX;++j) { 
                int p=query(j); 
                if(p!=sta[j]) { 
                    sum[j]^=(1<<i);         
                    sta[j]=p; 
                }
            }
        }         
        // 可知每个点的异或和，从 0 开始.    
        modify(0);  
        for(int i=1;i<n;++i) { 
            int p=query(i);  
            if(p!=sta[i]) {      
                q.push(i),report(0,i);             
            }
        }    
        while(!q.empty()) {     
            int u=q.front(); q.pop();   
            int aft=sum[u]^prev[u]^u;   
            if(aft) {   
                report(u,aft);  
                prev[aft]=u;    
                q.push(aft);   
            }
        }
    }
};   

namespace taskB {  
    int sta[N]; 
    void work(int l,int r,vector<int>a) {           
        if(l==r) {                   
            for(int i=0;i<a.size();++i) { 
                report(a[i],l);  
            }  
            return; 
        }  
        int mid=(l+r)>>1;     
        vector<int>pl,pr;  
        for(int i=l;i<=mid;++i) {    
            modify(i);   
        }                                       
        for(int i=mid+1;i<=r;++i) {
            int cur=query(i); 
            if(cur) pl.pb(i);     
        }   
        for(int i=0;i<a.size();++i) { 
            int cur=query(a[i]);  
            if(cur) pl.pb(a[i]); 
            else pr.pb(a[i]);  
        } 
        for(int i=l;i<=mid;++i) { 
            modify(i);  
        }
        work(l,mid,pl); 
        work(mid+1,r,pr);   
    }
    void solve(int n,int m) {  
        vector<int>g; 
        work(0,n-1,g);  
    }
};   

namespace taskF {     
    vector<int>tmp; 
    int mark[N],arr[N]; 
    int hd[N],to[N<<1],nex[N<<1],edges,cnt;    
    void add(int u,int v) {  
        nex[++edges]=hd[u]; 
        hd[u]=edges,to[edges]=v; 
    }  
    int Query(int x) { 
        int re=query(x),y; 
        for(int i=hd[x];i!=-1;i=nex[i]) { 
            y=to[i]; 
            re^=mark[y];  
        }  
        return re;  
    }  
    void Report(int x,int y) {   
        ++cnt;  
        add(y,x),add(x,y),report(x,y);   
    }
    void work(int l,int r,vector<int>&a) {   
        if(l==r) {  
            for(int i=0;i<a.size();++i) {   
                if(a[i]!=l) Report(arr[l],arr[a[i]]);  
            }  
            return;  
        }         
        vector<int>ql,qr;  
        int mid=(l+r)>>1;   
        for(int i=l;i<=mid;++i) {      
            modify(arr[i]),mark[arr[i]]=1;  
        }      
        for(int i=0;i<a.size();++i) {       
            int v=a[i];  
            if(v<=mid||Query(arr[v])) { 
                ql.pb(v); 
            }      
            else {           
                qr.pb(v); 
            }
        } 
        for(int i=l;i<=mid;++i) { 
            modify(arr[i]),mark[arr[i]]=0; 
        }   
        work(l,mid,ql),work(mid+1,r,qr);  
    }
    void solve(int n,int m) {  
        memset(hd,-1,sizeof(hd)); 
        for(int i=0;i<n;++i) { 
            arr[i]=i; 
        }       
        random_shuffle(arr,arr+n);  
        while(cnt<m) {         
            vector<int>tmp; 
            for(int i=0;i<n;++i) tmp.pb(i);                 
            work(0,n-1,tmp);      
            if(cnt<m) {  
                for(int i=0;i<n;++i) {      
                    if(check(arr[i])) {   
                        swap(arr[i],arr[--n]);        
                        --i;  
                    }
                }    
                random_shuffle(arr,arr+n);  
            }             
        }
    }
}; 
void explore(int n,int m) {   
    if(n<=500) { 
        task0::solve(n,m);    
    }      
    else if(m==n/2) { 
        taskA::solve(n,m); 
    }  
    else if((n%10)==7) { 
        taskB::solve(n,m); 
    } 
    else { 
        taskF::solve(n,m);  
    }  
}           
```


---


# [NOI2020] 时代的眼泪

## 题目描述

小 L 喜欢与智者交流讨论，而智者也经常为小 L 出些思考题。

这天智者又为小 L 构思了一个问题。智者首先将时空抽象为了一个二维平面，进而将一个事件抽象为该平面上的一个点，将一个时代抽象为该平面上的一个矩形。

为了方便，下面记 $(a, b) \leq (c, d)$ 表示平面上两个点 $(a, b),(c, d)$ 满足 $a \leq c$，$b \leq d$。

更具体地，智者给定了 $n$ 个**事件**，他们用平面上 $n$ 个不同的点 $\{(x_i, y_i)\}^n_{i=1}$ 来表示；智者还给定了 $m$ 个**时代**，每个时代用平面上一个矩形 $(r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2})$ 来表示，其中 $(r_{i,1}, c_{i,1})$ 是矩形的左下角，$(r_{i,2}, c_{i,2})$ 是矩形的右上角，保证 $(r_{i,1}, c_{i,1}) \leq (r_{i,2}, c_{i,2})$。我们称时代 $i$ 包含了事件 $j$ 当且仅当 $(r_{i,1}, c_{i,1}) \leq (x_j, y_j ) \leq (r_{i,2}, c_{i,2})$。

智者认为若两个事件 $i, j$ 满足 $(x_i, y_i) \leq (x_j, y_j)$，则这两个事件形成了一次**遗憾**。而对一个时代内包含的所有事件，它们所形成的遗憾被称为这个**时代的眼泪**，而形成的遗憾次数则称为该时代的眼泪的大小。现在智者想要小 L 计算**每个时代的眼泪的大小**。

小 L 明白，如果他回答不了这个问题，他也将成为时代的眼泪，请你帮帮他。


## 说明/提示

#### 样例 1 解释

对于时代 $1$，包含的遗憾有 $(6, 7)$（即事件 $6$ 与事件 $7$ 形成的遗憾，下同）。

对于时代 $2$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $3$，包含的遗憾有 $(5, 6),(5, 8)$。

对于时代 $4$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $5$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $6$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $7, 8, 9$，它们均不包含任何遗憾。


#### 样例 2

见选手目录下的 tears/tears2.in 与 tears/tears2.ans。

该样例满足特殊限制 A（具体限制见测试点约束）。


#### 样例 3

见选手目录下的 tears/tears3.in 与 tears/tears3.ans。

该样例满足特殊限制 B（具体限制见测试点约束）。

对于所有测试点：$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2} \leq n$。

---

### 测试点约束

每个测试点的具体限制见下表：

| 测试点编号 |  $n\le $ |  $m\le $ | 特殊限制 |
| :-: | :-: | :-: | :-: |
|  $1\sim 3$ |  $10$ |  $10$ | 无 |
|  $4$ |  $3\times 10^3$ |  $3\times 10^3$ | 无 |
|  $5$ |  $4\times 10^3$ |  $4\times 10^3$ | 无 |
|  $6$ |  $5\times 10^3$ |  $5\times 10^3$ | 无 |
|  $7$ |  $2.5\times 10^4$ |  $5\times 10^4$ |  $\text{A}$ |
|  $8$ |  $5\times 10^4$ |  $10^5$ |  $\text{A}$ |
|  $9$ |  $7.5\times 10^4$ |  $1.5\times 10^5$ |  $\text{A}$ |
|  $10$ |  $10^5$ |  $2\times 10^5$ |  $\text{A}$ |
|  $11$ |  $6\times 10^4$ |  $1.2\times 10^5$ |  $\text{B}$ |
|  $12$ |  $8\times 10^4$ |  $1.6\times 10^5$ |  $\text{B}$ |
|  $13$ |  $10^5$ |  $2\times 10^5$ |  $\text{B}$ |
|  $14$ |  $2\times 10^4$ |  $4\times 10^4$ | 无 |
|  $15$ |  $3\times 10^4$ |  $6\times 10^4$ | 无 |
|  $16$ |  $4\times 10^4$ |  $8\times 10^4$ | 无 |
|  $17$ |  $5\times 10^4$ |  $10^5$ | 无 |
|  $18$ |  $6\times 10^4$ |  $1.2\times 10^5$ | 无 |
|  $19$ |  $7\times 10^4$ |  $1.4\times 10^5$ | 无 |
|  $20\sim 22$ |  $10^5$ |  $2\times 10^5$ |  $\text{C}$ |
|  $23\sim 25$ |  $10^5$ |  $2\times 10^5$ | 无 |

特殊限制 A：对于所有时代 $i$ 有 $c_{i,1} = 1, c_{i,2} = n$。

特殊限制 B：任意两个不同时代所代表的矩形，它们要么是包含关系（一个矩形在另一个矩形内，边界允许重合），要么是相离关系（两矩形不包含共同点，边界不允许重合）。

特殊限制 C：最多有 $50$ 对事件 $(i, j)(1 \leq i < j \leq n)$ 不满足 $(i, p_i) \leq (j, p_j)$。

## 样例 #1

### 输入

```
9 9
9 8 7 6 2 4 5 3 1
4 9 3 6
2 9 1 8
3 8 2 4
3 9 2 7
2 8 1 6
1 9 1 9
1 3 5 7
2 3 3 3
6 6 6 6```

### 输出

```
1
4
2
4
4
4
0
0
0```

# 题解

## 作者：louhao088 (赞：50)



一直在看却不敢写的题，终于写掉了。果然是毒瘤分块题，题解区里很少有代码，只能自己动手写了。


------------
简化题意

求一段区间内值域在 $[x,y]$ 间的顺序对个数，具体来说就是 [P5046 Ynoi2019 模拟赛Yuno loves sqrt technology I](https://www.luogu.com.cn/problem/P5046) 的加强版。或许大佬用矩阵做的，但小蒟蒻认为这样最容易理解。

本题最大特点就是分块 + 容斥。


------------


我们采用了在线做法，先预处理出一些东西。

处理内容

我们令 $rk[i][j]$ 表示第 $i$ 块排名为  $j$ 的数，$p[i][j]$ 表示第 $i$ 个数与其所在块左边这一段小于此块排名为 $j$ 的数的个数，$pre[i][j]$ 表示前 $i$ 个块小于等于 $j$ 的数的个数。$lsh[i][j]$ 表示第 $i$ 块小于等于 $j$ 最大排名，$  c[i][j][k] $ 第 $i$ 块与前 $j$ 块排名前 $k$ 个数产生顺序对的个数 ，$sum[i][j][k]$ 表示第 $i$ 块从排名 $j$ 至排名 $k$ 之间顺序对数 ，$L[i],R[i]$ 分别表示一个块的左右区间， $id[i]$ 表示一个数所属的块 ， $pos[i]$ 表示一个块里第 $i$ 名的位置 。

处理方法

1. $rk$ 数组：这很好处理，因为是一个排列，故我们只要把每个块从小到大排个序，记录一下就好了。

2. $p$ 数组：可以与$rk$ 数组同时处理，对每个数，在 $p[位置][排名]$ 处标上 1 ，做一遍二维前缀和就好了。注意不能在 $j=L[id[j]]$ 时加前缀和，这会使答案加上前一个块。

3. $pre$ 数组：对于 $pre$ 数组也是同样的处理方式，对每个数，在 $pre[块的标号][值]$ 标上 1，然后在每个块中做一次二维前缀和即可。

4. $lsh$ 数组：这也很好处理 , ~~然而蒟蒻最开始处理错了~~ ，就是在每两个值之间，给它标上前一个块内值的排名。

5. $c$ 数组：我们发现可以用 $pre$ 数组代求。具体的 $c[i][j][k]=pre[j][rk[i][k]]+c[i][j][k-1]$ ，就是这个值产生的顺序对，加上之前值产生的顺序对。

6. $sum$ 数组： 可以用 $p$ 数组代求。具体的 $sum[i][j][k]=sum[i][j][k-1]+p[pos[k]][k-1]-p[pos[k]][j-1]$ 。就是之前的顺序对数加上第 $k$ 名产生的顺序对数。

  预处理总复杂度 $O (n \sqrt n)$，虽然常数可能有点大。 
  

------------
预处理完了，我们需要在 $O (\sqrt n)$ 内求出答案。 

根据 P5046 Ynoi2019 模拟赛Yuno loves sqrt technology 的经验，我们可以得出，答案应该是 散块内部 + 整块内部 + 散块对整块 / 整块对散块 + 整块对整块 + 散块对散块。

具体过程如下

1. 散块内部：我们要求出 $l \to r $ 值域在 $[x,y]$ 之间的顺序对数，只需求出 $l \to r $ 值域在 $[1,x-1]$ 之间的顺序对数和 $l \to r $ 值域在 $[1,y]$ 之间的顺序对数，再减去 $[1,x-1]$  与 $[x,y]$ 顺序对数即可。
2. 整块内部：我们之前已经预处理好了 $sum[i][j][k]$ ，对每个块加一加即可。
3. 散块对整块 / 整块对散块：可以用 $pre$ 数组代求，求对 $1 \to x$ 块贡献容斥一下即可。
4. 整块对整块：也是容斥用 $c$ 数组处理第 $i$ 块 $1 \to i-1$ 和 $ 1 \to id[l]$ 间 $[1,x-1]$ 和 $[1,y-1]$ 之间的贡献。再减去 $[1,x-1]$ 与 $[x,y]$ 产生的顺序对数，具体的减去每次比 $x$ 小的数的顺序对个数，再乘以这块中在 $[x,y]$ 间数的顺序对个数。
5. 散块对散块：用一次归并排序即可，注意这次求的是顺序对，不是逆序对。


------------
代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define re register
const int maxn=1e5+5,B=345;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
void print(long long x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
struct node{int x,id;}a[maxn],b[maxn];
int n,m,l,r,x,y,t,g,L[B],R[B],lx[maxn],ly[maxn],id[maxn];
int rk[B][B];//第i块排名为j的数 
int p[maxn][B];//第i个数与其所在块左边这一段小于此块排名为j的数的个数 
int pre[B][maxn]; //前i块中 小于等于j的数的个数 
int lsh[B][maxn];//第i块小于等于j最大排名 
long long c[B][B][B];//第i块与前j块排名前k个数产生顺序对的个数 
int sum[B][B][B];//第i块从排名j至排名k之间顺序对数 
int msort(int l,int r)
{
	int tot=0,res=0;
	int i=1,j=1;
	for(;i<=l&&j<=r;)
		if(lx[i]<ly[j])i++,res+=r-j+1;
		else j++;
	return res;
}
bool cmp(node a,node b){return a.x<b.x;}
inline int query1(int l,int r,int x,int y)
{
	int res=0,h=id[l];int g=lsh[h][x-1];
	for(int i=l;i<=r;i++)
		if(a[i].x<=y&&a[i].x>=x)
		{
			res+=p[i][lsh[h][a[i].x-1]]-p[i][g];
			if(l!=L[h])res=res-p[l-1][lsh[h][a[i].x-1]]+p[l-1][g];
		}
			
	return res;
}
inline long long query2(int l,int r,int x,int y)
{
	long long res=0;res=query1(l,R[id[l]],x,y)+query1(L[id[r]],r,x,y); 
	int s1=0,s2=0;
	for(re int i=L[id[l]];i<=R[id[l]];i++)
		if(b[i].id>=l&&b[i].x<=y&&b[i].x>=x)lx[++s1]=b[i].x,
		res+=pre[id[r]-1][y]-pre[id[r]-1][b[i].x]-pre[id[l]][y]+pre[id[l]][b[i].x];
	for(re int i=L[id[r]];i<=R[id[r]];i++)
		if(b[i].id<=r&&b[i].x<=y&&b[i].x>=x)ly[++s2]=b[i].x,
		res+=pre[id[r]-1][b[i].x]-pre[id[r]-1][x-1]-pre[id[l]][b[i].x]+pre[id[l]][x-1];
	
	res+=msort(s1,s2);int num=0;
	for(int i=id[l]+1;i<=id[r]-1;i++)
	{
		res+=sum[i][lsh[i][x-1]+1][lsh[i][y]];
		res+=c[i][i-1][lsh[i][y]]-c[i][id[l]][lsh[i][y]]-c[i][i-1][lsh[i][x-1]]+c[i][id[l]][lsh[i][x-1]]
		-num*(lsh[i][y]-lsh[i][x-1]);
		num+=lsh[i][x-1];
	}
	return res;
}
signed main()
{
	//freopen("t.in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();m=read();t=sqrt(n);g=(n-1)/t+1;
	for(re int i=1;i<=n;i++)a[i].x=read(),a[i].id=i,b[i]=a[i],id[i]=(i-1)/t+1;
	for(re int i=1;i<=g;i++)
	{
		L[i]=R[i-1]+1,R[i]=min(i*t,n);
		int l=L[i],r=R[i];
		sort(b+l,b+r+1,cmp);int h=1;
		for(int j=1;j<b[l].x;j++)lsh[i][j]=0;h=b[l].x;
		for(re int j=l;j<=r;j++)
		{
			rk[i][j-l+1]=b[j].x,p[b[j].id][j-l+1]=1,pre[i][a[j].x]=1;
			int u=b[j+1].x;if(j==r)u=n+1;
			for(int k=h;k<u;k++)lsh[i][k]=j-l+1;h=b[j+1].x;
		}
		for(re int j=l;j<=r;j++)
			for(re int k=1;k<=r-l+1;k++)
			{
				if(j!=l)
					p[j][k]=p[j][k]+p[j-1][k]+p[j][k-1]-p[j-1][k-1];
				else p[j][k]=p[j][k]+p[j][k-1];
				
			}
			
		for(int j=1;j<=n;j++)
			pre[i][j]=pre[i][j]+pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1];
		for(re int j=1;j<i;j++)
			for(re int k=1;k<=r-l+1;k++)
				c[i][j][k]=pre[j][rk[i][k]]+c[i][j][k-1];
		for(re int j=1;j<=r-l+1;j++)
			for(re int k=j+1;k<=r-l+1;k++)
				 sum[i][j][k]=sum[i][j][k-1]+p[b[k+l-1].id][k-1]-p[b[k+l-1].id][j-1];
	}
	for(int i=1;i<=m;i++)
	{
		l=read(),r=read(),x=read(),y=read();
		if(id[l]==id[r])
			print(query1(l,r,x,y)),puts("");
		else print(query2(l,r,x,y)),puts("");
	}
 	return 0;
}
```



---

## 作者：Ynoi (赞：34)

场外口胡选手来口胡一下。

这个题相当于是区间$[l,r]$，保留值在$[x,y]$之内的数的区间顺序对数。

这个不弱于区间逆序对所以我们肯定考虑根号做法。

做法可以参考[这个题](https://www.luogu.com.cn/problem/P5046)

考虑分块

然后对于块边缘部分的点和那个题基本没差别所以这里略。

块内的贡献，可以预处理出来，方法是预处理出前后缀的值域前缀和，那么每加入一个数的贡献就可以$O(1)$求。然后枚举值域范围（$\sqrt n * \sqrt n$种）即可。

然后是块间贡献。

首先我们考虑容斥，对于任意两个块$a,b$(a在b前面），在保留$[x,y]$的数的时候的顺序对数，相当于是保留$[1,y]$的数的顺序对数，减去$a$中小于$x$的数的个数乘$b$中$[x,y]$的数的个数，在减去保留$[1,y-1]$的数的顺序对个数。

那么一个区间的块内，$a$中小于$x$的数的个数乘$b$中$[x,y]$的数的个数 这个很好求，预处理一下前$i$个块内$[1,k](1\leq k\leq n)$的数有多少个即可求得。

然后现在的问题相当于是,第$l$~$r$个块中，保留$[1,x]$的数，顺序对数。

按照$x$排序，那么当$x+=1$的时候，我们就考虑把$x$对其他块的贡献都求出来，那么现在相当于一个$\sqrt n*\sqrt n$的矩阵，每次操作把一个十字形的权值加一个数（不同位置加的不同），然后问一个子矩阵的权值和。

那么可以把矩阵拆成两个矩阵，分别用来行加列加,分别预处理每行的前缀和和每列的前缀和，最后和一下就可以了。

最后是询问的$l,r$在同一个块的情况。

一样预处理块内的每个前缀中$[1,k]$出现次数（注意这里的$k$要求块间出现过的数，所以只有$\sqrt n$中），然后就很方便的处理了。

时空复杂度$n \sqrt n$~~感觉常数挺大的样子~~

---

## 作者：z7z_Eta (赞：25)

# Ynoi2020

[博客中查看](https://www.luogu.com.cn/blog/z7z-Eta/ALL-LAST)

题解

排列$(N)$, 静态询问$M$次**矩形内满足二维偏序对数**

* 性质$A$ = 静态区间逆序对

$Ans_{l,r}$表示区间内的答案, $[l,L-1]\times[R+1,r]$表示两个区间的点之间构成的偏序数量, 由于是两点配对造成的贡献, 有下式容斥 :

$Ans_{l,r}=Ans_{l,R}+Ans_{L,r}-Ans_{L,R}+[l,L-1]\times[R+1,r]\ (l\le L\le R\le r)$

[\[Ynoi2019模拟赛\]Yuno loves sqrt technology I](https://www.luogu.com.cn/problem/P5046)


>搬运朝田诗乃的[题解](https://www.luogu.com.cn/blog/asadashino/solution-p5046)

---

分享一个思路较简单但容易被卡空间的算法。

预处理以下几个东西：

1、$ansL_{i,j}$，表示以$j$为左端点，第$i$块的右端点为右端点的区间中的逆序对数。

2、$ansR_{i,j}$，表示以$j$为右端点，第$i$块的左端点为左端点的区间中的逆序对数。

3、$ans_{l,r}$，表示以第lll块的左端点为左端点，第$r$块的右端点为右端点的区间中的逆序对数。

那么对于每次询问我们只需要把1+2-3，就可以得到答案了。

——好像漏了啥。左散块对右散块的贡献没有统计。将所有块事先排好序，查询时归并一下即可。

如何预处理？

预处理出$cnt_{i,j}$为前$i$块大于/小于等于$j$的数字个数，$pre_i$为位置$i$到$i$所在块左端点中大于/小于等于$a_i$的数字个数，即可做到$O(1)$移动端点。

关于第三个$ans_{l,r}$，不难发现在处理前两个值的时候已经顺便求出来了，不需要做更多处理。

查询时若$l,r$在同一个块中，简单容斥一下即可。这个部分其他题解已经说明得非常清楚了不再赘述。

总复杂度$O(n\sqrt{n})$。

---

希望你可以理解这个方法, 然后写过模板.

### 本题做法

设我们要求$(l,r,u,d)$的答案$(1\leq l\leq r\leq N,1\leq u\leq d\leq N)$

我们设$L$是最左的块端点, $R$是最右的块端点

设三个区间$\text{X}=[l,L-1], \text{Y}=[L,R], \text{Z}=[R+1,r]$

如果使用分块算, 我们要考虑分别**XX,XY,XZ,YY,YZ,ZZ**之间的贡献

均摊的魔法 : 按照分块的原则, 把前置代码里面$O(1)$算的( 比如块块之间和块零之间的 ), 多加个类似$O(\sqrt n)$的枚举, 你就能顺手多处理一维

1. $\text{X}\text{Z}$(零零之间)

同样块内事先排序, 归并排序查偏序个数, 注意取消$[u,d]$之外的点的影响

2. $\text{X}\text{X}$和$\text{Z}\text{Z}$(零零之内), 以及$l,r$同时在一个块内的答案

按照事先的排序, 可以把块内值域变小为$\sqrt n$, 查询时枚举零块里的点$x$, 每个点查询前缀有多少值在$[u,x]$中, 也就是预处理$\sqrt n*\sqrt n$的二维前缀和

3. $\text{X}\text{Y}$和$\text{Y}\text{Z}$(块零之间)

依旧枚举$\text{X}$或$\text{Z}$(零块)的点, 以左边$\text{X}$为例

枚举零块的点$x$, 答案是$\text{Y}=[L,R]$中的值$v\in [x,d]$的数量, 经典分块或莫队, 分块直接$O(n\sqrt n)$二维前缀和 (每个块内记录$cnt$)

4. $\text{Y}\text{Y}$(块块之间)

$\text{Y}=[L,R]$, 这里先进行一步转换

答案$(L,R,u,d)=(L,R,1,d)-(L,R,1,u-1)-[L,R,1,u-1]\times[L,R,u,d]$

① 现在区间差分成了前缀, 先考虑$(L,R,1,d)$怎么求 ?

枚举每个块$k$, 答案是 $[L,k]$块 对 **第$k$块中小于等于$d$的数** 的偏序数量, 由于每个块要做到$O(1)$查复杂度才正确, 所以:

* 每个块建立一个$\sqrt n*\sqrt n$的表格, $T_{i,j}$代表块$j$里偏序小于这个块内的**第$i$大数**的个数

* 显然我们要查的是前$i$大数对$[L,k]$块的答案, 也就是子矩形的和, 二维前缀和之

如何找到这个块中$\leq d$的最大数 ?

* 全预处理出来就可以, 大小$O(n\sqrt n)$, 这样就可以可以$O(1)$查到数

② 接下来, 考虑$[L,R,1,u-1]\times[L,R,u,d]$怎么求 ?

枚举每个块$k$, 答案是 **区间$[L,k-1]$值$v\in [1,u-1]$的数量** 乘 **第$k$块中的值$v\in [u,d]$的数量**, 这一部分是刚刚的经典分块, 直接二维前缀和

还有第$k$块内自身的贡献, 因为每个块内最多只有$\sqrt n*\sqrt n$对, 所以 :

* 建立一个$\sqrt n*\sqrt n$的表格, $M_{i,j}=$第$j$大数偏序小于第$i$大数, 二维前缀和之

* 于是这一部分用刚刚的找到块中$\leq d$的最大数的方法, 确定是第几大, 然后查矩形和就可以了

结束.

虽然时空复杂度均为$O(n\sqrt n)$, 代码应该...十分麻烦, 而且卡常

因为是很菜的场外AFO选手, 就想了这么多...

关于更优秀的解法, 是种叫做第十三分块的一种科技, 像是将矩形分成更小的矩形的分治方式, 但很无奈不是很会

**upt on 8.21** :

艰苦卓绝地在有生之年写了代码, 在$luogu$上有$76-92pts$的分数

还是劝写题者不要过于偏执就好, 代码直接放了, 反正卡常卡的过不去...¯﹃¯ԅ

```
// Etavioxy
#define il inline
#define ll long long
#define rep(i,s,t) for(register int i=(s);i<=(t);i++)
#define rev_rep(i,s,t) for(register int i=(s);i>=(t);i--)
#define pt(x) putchar(x)
using namespace std;
il int ci(){
	register char ch;int f=1;
	while(!isdigit(ch=getchar()))f=ch=='-'?-1:1;
	register int x=ch^'0';
	while(isdigit(ch=getchar()))x=(x*10)+(ch^'0');
	return f*x;
}

enum{N=100023,B=335};

class SQ{
private:
	int pos[N],ed[B];
	int a[N],b[N],rb[B][B];
	int num[B][N],sum[B][N];
	int T1[B][B][B];
	int T2[B][B][B];
	int T3[B][B][B];
	#define s2(A,l,r,u,d) (A[r][d]-A[(l)-1][d]-A[r][(u)-1]+A[(l)-1][(u)-1])
	il ll query_block(int k,int l,int r,int u,int d){
		u = num[k][u-1]+1, d = num[k][d];
		ll ans = 0;
		rep(i,l,r) if( u<=b[i] && b[i]<=d ){
			ans += s2(T1[k],u,b[i],l-ed[k-1],i-1-ed[k-1]);
		} return ans;
	}
	struct Merge{
		int a[B*2],b[B*2];
		il ll sort(int L,int R){
			ll ans = 0; int i = 1;
			rep(j,1,R){
				while( i<=L && a[i]<=b[j] ) i++;
				ans += i-1;
			} return ans;
		}
	}Me;
	il ll cross(int L,int R,int xl,int xr,int zl,int zr,int u,int d){
		int cl = 0, cr = 0;
		rep(i,num[L][u-1]+1,num[L][d]) if( xl<=rb[L][i] && rb[L][i]<=xr ) Me.a[++cl] = a[rb[L][i]];
		rep(i,num[R][u-1]+1,num[R][d]) if( zl<=rb[R][i] && rb[R][i]<=zr ) Me.b[++cr] = a[rb[R][i]];
		return Me.sort(cl,cr);
	}
public:
	void init(int n,int*a0){
		memcpy(a,a0,sizeof(int)*(n+1));
		int block = sqrt(n);
		int t=0, T=1;
		rep(i,1,n){
			pos[i] = T;
			if( (++t)==block ) t=0, ed[T++]=i;
		} ed[T] = n;
		rep(k,1,T){
			rep(i,ed[k-1]+1,ed[k]) num[k][a[i]] = i;
			int cnt = 0;
			rep(i,1,n){
				if( num[k][i] ) rb[k][ b[num[k][i]]=++cnt ] = num[k][i], num[k][i] = 1;
				num[k][i] += num[k][i-1];
				sum[k][i] = sum[k-1][i]+num[k][i];
			}
		}
		rep(k,1,T){
			int len = ed[k]-ed[k-1];
			rep(i,ed[k-1]+1,ed[k]) T1[k][b[i]][i-ed[k-1]] = 1;
			rep(i,1,len) rep(j,1,len) T1[k][i][j] += T1[k][i][j-1]+T1[k][i-1][j]-T1[k][i-1][j-1];
			rep(i,ed[k-1]+1,ed[k]) rep(j,i+1,ed[k]) if( b[i]<b[j] ) T3[k][b[i]][b[j]] = 1;
			rep(i,1,len) rep(j,1,len) T3[k][i][j] += T3[k][i][j-1]+T3[k][i-1][j]-T3[k][i-1][j-1];
			rep(i,ed[k-1]+1,ed[k]){
				rep(e,1,k-1) T2[k][b[i]][e] = sum[e][a[i]]-sum[e-1][a[i]];
				T2[k][b[i]][k] = T3[k][b[i]][b[i]]-T3[k][b[i]][b[i]-1];
			}
			rep(i,1,len) rep(j,1,T) T2[k][i][j] += T2[k][i][j-1]+T2[k][i-1][j]-T2[k][i-1][j-1];
		}
	}
	il ll query(int l,int r,int u,int d){
		int L = pos[l], R = pos[r];
		if( L==R ) return query_block(L,l,r,u,d);
		ll ans = query_block(L,l,ed[L],u,d)+query_block(R,ed[R-1]+1,r,u,d)+cross(L,R,l,ed[L],ed[R-1]+1,r,u,d);
		rep(i,l,ed[L]) if( u<=a[i] && a[i]<=d ) ans += s2(sum,L+1,R-1,a[i],d);
		rep(i,ed[R-1]+1,r) if( u<=a[i] && a[i]<=d ) ans += s2(sum,L+1,R-1,u,a[i]);
		rep(k,L+1,R-1){
			int U = num[k][u-1]+1, D = num[k][d];
			ans += s2(T2[k],U,D,L+1,k)-s2(T3[k],1,U-1,U,D)-1ll*(D-U+1)*s2(sum,L+1,k-1,1,u-1);
		} return ans;
	}
}sq;

int a[N];

int main(){
	int n = ci(), m = ci();
	rep(i,1,n) a[i] = ci();
	sq.init(n,a);
	while( m-- ){
		int l = ci(), r = ci(), u = ci(), d = ci();
		printf("%lld\n",sq.query(l,r,u,d));
	}
	return 0;
}
```

Ynoiも楽しいことかもしれません、ね。

---

## 作者：Sol1 (赞：21)

感觉在会了 P5046 之后这题也不算难的离谱？（但是代码难度和卡常是真的离谱）

这里默认读者已经会了 P5046 的做法。

## 1 分块

这是一个二维问题，两维分别在下标和值域上。由于该问题不弱于区间逆序对，考虑高维分块，如图，两维均分为 $\sqrt n$ 块，设每一个数 $a_i$ 对应到 $(i,a_i)$ 所在的格子内。

![](https://cdn.luogu.com.cn/upload/image_hosting/22i5616y.png)

下面考虑如何进行查询。

![](https://cdn.luogu.com.cn/upload/image_hosting/kc405v49.png)

如图，考虑对红色矩形进行一次查询。

首先按照分块，对不同的区域进行标号，如图，分别标为 A,B,C/1,2,3。

![](https://cdn.luogu.com.cn/upload/image_hosting/0stczmuc.png)

## 2 满足偏序关系的区域的贡献

考虑到如果两个区域中任意两点均满足偏序关系（例如 A1 和 C3），这两个区域之间的逆序对数就只和两区域内点的数量有关了。接下来只考虑不满足偏序关系的区域。

## 3 两个不同且不为 B2 的区域之间的贡献

然后我们发现由于给定的序列是一个排列，所以除 B2 以外所有的区域都只有 $\sqrt n$ 个数。

这样，我们就可以利用归并来 $O(\sqrt n)$ 求解两个不同且不是 B2 的区域之间的贡献了。

下面，先考虑同区域内部的贡献如何求。

## 4 一个区域内部的贡献

### 4.1 A1-A1 的贡献

如图，考虑现在要求出 14 区的贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/f01aepr8.png)

考虑对于每一个点预处理一个 $b_i$ 表示在 $i$ 所在的二维块内有多少个点和它满足题目中的偏序关系，可以使用树状数组 $O(n\log n)$ 求得。

现在枚举出 14 中的点，求出这些点的 $b$ 值的和。

目前答案包括 14-14、13-14、12-14、11-14 的贡献。

然后发现 13-14 和 12-14 都可以归并，11-14 满足区域偏序关系，所以可以在 $O(\sqrt n)$ 时间内求出 14-14 的贡献。

至此，这一部分解决。

A3-A3、C1-C1、C3-C3 与此相同。

### 4.2 A2-A2 的贡献

预处理 $h_{i,j}$ 表示有多少个元素 $x$ 满足：

- $a_x$ 与 $a_i$ 在值域维上属于同一块；
- $a_x<a_i$；
- $x$ 在下标维上在第 $1\sim j$ 块中。

这个数组可以通过枚举 $j$，并在值域上做前缀和求出。

然后统计答案，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6m2itlzp.png)

蓝色区域内点数使用 4.1 中的 $b$ 数组求出，绿色区域内点数使用刚刚的 $h$ 数组求出。

当然这样会有区域外的点与区域内的点产生贡献，去掉它们的贡献可以直接将区域上方的点与区域内的点进行归并。

至此，这一部分也解决。

C2-C2 与此相同，B1-B1 和 B3-B3 与此基本相同，不同的在于要再预处理一个 $v_{a_i,j}$ 数组表示有多少个元素 $x$ 满足：

- $x$ 与 $i$ 在下标维上属于同一块；
- $x<i$；
- $a_x$ 在下标维上在第 $1\sim j$ 块中。

然后一样做。

## 5 涉及 B2 的贡献

预处理一个二维前缀和 $s_{i,j}$，表示下标 $1\sim i$ 块，值域 $1\sim j$ 块中共有多少个元素，以及 $c_{i,j}$，表示下标 $1\sim i$ 块，值域 $1\sim j$ 块中共有多少对元素满足偏序关系。

这样，结合上面的 $h$ 数组和 $v$ 数组就可以求一个 B2 外的元素和 B2 的贡献了。

下面只需要考虑 B2-B2 了。

预处理一个 $p_{i,j,k}$ 表示下图中 X 和 Y 之间满足偏序关系的元素对数量。

![](https://cdn.luogu.com.cn/upload/image_hosting/fym9xosq.png)

类似的，$q_{i,j,k}$ 表示下图中 X 和 Y 之间满足偏序关系的元素对数量。

![](https://cdn.luogu.com.cn/upload/image_hosting/ieb8c450.png)

注意这里 $i,j,k$ 都是块的下标。

如图，考虑前缀，B2 左上侧分别有 X，Y，Z 三个区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/a2bee5aj.png)

设 B2 的两维的块区间分别为 $[l,r]$ 和 $[L,R]$。

然后对答案加上 $c_{r,R}-c_{l-1,R}-c_{r,L-1}+c_{l-1,L-1}$。

现在剩下的是 B2-B2,X,Y,Z 的贡献。

B2-Z 满足区域偏序关系，考虑 B2-X。

可以转化成 B2,Y-X,Z 的贡献减去 B2-Z、Y-Z、Y-X。Y-Z 已经预处理，剩下的都满足区域偏序关系，所以可求。

B2-Y 同理。

这样，只要把上面所有的东西都拼起来，这题就结束了。

时间 $O((n+m)\sqrt n)$，空间 $O(n\sqrt n)$。

大概说一下卡常：

- $h$ 和 $v$ 可以离线询问然后滚动着用，减小空间常数。这样块长可以进一步调小，从而减小时间常数。
- 某些地方不用构造出数组再归并，可以在扫的过程中得到答案。

[在 loj 上通过的代码。](https://loj.ac/s/1196290)

~~洛谷最高卡到了 96，挂在了第 10 个点，也就是说拼进去一个莫队二次离线就可以过了。~~

---

## 作者：AzusaCat (赞：16)

这个是标程做法，但是实现起来比直接分块要麻烦所以没有写代码（其实就是复述了一遍 ppt /kk，如果有误麻烦指出）。

如非特殊说明，复杂度分析认为 $n,m$ 同阶。

我们考虑对平面建立树套树（线段树套动态开点线段树）。那么内层的每个节点代表了平面中的一个矩形，为了之后的计算，我们需要维护树套树中每个矩形内部的答案。

![](https://s1.ax1x.com/2020/08/24/dsTlgU.md.png)

如图，假设我们现在有一个长和宽均不为 $1$ 的矩形（当至少一维为 $1$ 时答案一定为 $0$），我们想要求出这个矩形的答案（我们认为左下角为较小的下标），我们把这个矩形一分为四，并且我们已经递归得出了每个子矩形的答案，那么我们有：
$$
\begin{aligned}
ans(ABCD)=&ans(AB)+ans(CD)+ans(AC)+ans(BD)\\
-&ans(A)-ans(B)-ans(C)-ans(D)+siz(A)\cdot siz(D)
\end{aligned}
$$
其中 $siz(A)$ 是 $A$ 中包含点的数量。这个东西本质就是枚举任意两块，求出块之间的答案，再求出块内部的答案。由于 $ans(AB)$ 已经包含了 $ans(A)+ans(B)$，所以这里要容斥捡回去。**本题可以这样分治的关键在于 $A$ 和 $D$ 的贡献是平凡的。**

子矩形的 $ans$ 我们可以通过子树查询得到，$siz$ 我们只需要顺便维护就好了。



现在我们考虑回答询问。首先，我们需要用 $O(\log^2n)$ 个在树套树中的矩形定位出询问矩形，如下图所示：

![](https://s1.ax1x.com/2020/08/24/dsjK6x.md.png)

其中每一个 $A_{i,j}$ 都是树套树中的矩形。那么我们用类似上面的容斥来计算答案：即求出每行和每列的答案，加上行列均不同的两块的贡献，再减去每一块内部的答案。那么有
$$
\begin{aligned}
ans(1\dots w,1\dots h)=&\sum\limits_{i=1}^w\sum\limits_{j=1}^hsiz(i,j)\sum\limits_{c=i+1}^w\sum\limits_{d=j+1}^hsiz(c,d)\\
+&\sum\limits_{i=1}^wans(i,1\dots h)+\sum\limits_{i=1}^hans(1\dots w,i)\\
-&\sum\limits_{i=1}^w\sum\limits_{j=1}^hans(i,j)
\end{aligned}
$$
第一行和第三行我们直接在树套树上查询就可以了，注意第二行，我们发现这实际上仍旧是一个值域范围内的区间顺序对，但是这里值域范围一定出现在了树套树上，即只有 $O(n\log n)$ 种。并且如果这是一个 $w\times n$ 的矩形，由于我们给定的是一个排列，所以这个矩形内的数只有 $w$ 个。这样我们在这样的矩形查一次的复杂度是 $O(\sqrt w)$ 的，由于每一个长度的矩形只会出现 $O(1)$ 次，所以一次查询的总复杂度是 $O(\sqrt n+\sqrt{\frac{n}{2}}+\sqrt{\frac{n}{4}}+\dots)=O((1+\frac{1}{\sqrt 2}+\frac{1}{2}+\dots)\sqrt n)=O(\sqrt n)$ 的。预处理的复杂度类似，所以这个算法的总复杂度是 $O(n\log^2n+T)$（$T$ 指区间逆序对复杂度）的，空间上如果用一般的树套树也是 $O(n\log^2n+T)$ 的。据官方题解说也可以做到一个 $\log$ 或者线性。

据 lxl 说，这样分治套分块似乎当分块的复杂度比 $O(n^{1.5})$ 低时才会更优秀。

---

## 作者：devout (赞：15)

我就是时代的眼泪。

**description**

给定 $n$ 个点 $(i,p_i)$ 其中**保证** $p_i$ **是一个排列**，每次询问区间 $[x_1,x_2]$ 上值域在 $[y_1,y_2]$ 范围内的顺序对个数。

**solution**

我们发现是平面上的一个矩形内的信息，相当于是一个四维的问题，考虑降维。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200910125301799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rldm91dF8=,size_16,color_FFFFFF,t_70#pic_center)

比如我们要查询 $4$ 区域的答案。

定义：我们用 $f(a_1a_2\cdots a_k)$ 表示由 $a_1,a_2\cdots a_k$ 这些区域拼成的矩形里面的答案数，用 $x$ 表示两个都在区域 $x$ 里面的答案数，$xy$ 表示一个在区域 $x$ 里，一个在区域 $y$ 里的答案数，那么我们最后要求的就是 $f(4)$ 或者 $4$。

这样的话，我们可以将 $f(1234)$ 进行表示

$$f(1234)=1+2+3+4+12+13+14+23+24+34$$

显然，$23=0$

我们希望把除了 $4$以外的东西都减掉，$12,13$ 这种的最难算，我们先把它减掉，我们要计算：

$f(12)=1+2+12$

$f(13)=1+3+13$

$f(24)=2+4+24$

$f(34)=3+4+34$

这个时候我们发现剩下的是 $-1-2-3-4+14$

考虑 $14$ 的答案，其实就是 $1$ 区域的个数乘上 $4$ 区域的个数，这个东西可以用主席树来实现

然后我们需要再加上 $1,2,3$ 的答案，也就是说，我们可以列出这样一个等式

$$f(4)=-f(1234)+f(12)+f(13)+f(24)+f(34)-f(1)-f(2)-f(3)+14$$

这样转化有什么好处呢？

我们发现，除了 $14$ 的答案我们直接主席树算以外，剩下的每个询问，都有一边是靠着坐标轴的，相当于把它降成了三维。

所以我们有了一个初步的思路，我们把一个询问拆成九个询问，一个直接算，另外八个有一边是靠着坐标轴的，对于 $x$ 轴和 $y$ 轴分别计算答案，最后把每个询问的答案加起来就可以了。

****

以 $x$ 轴为例，我们考虑按照高度插入每一个点，每次询问相当于就是二维的了。

所以我们现在要处理的是带修改的区间正序对个数，但是每次插入的数都是当时全局最大，我们考虑分块。

Q：为什么要考虑分块呢？

A：

- 其他数据结构都不太可做

- 不带修改的区间逆序对复杂度是 $O(n\sqrt n)$ ，带修改显然不会更优

- ~~我们发现比赛时 lxl 在现场，所以想都不用想，直接分块~~

考虑要维护什么东西

当询问的左右端点在同一个块里面时，设这个块叫 $id$：

我们用 $p_{i,x}$ 表示第 $i$ 个位置上的数和位于区间 $[l_{id}+x,i-1]$ 中的数的正序对个数，那么我们询问 $[L,R]$ 的答案时，就是 $\sum_{L+1}^R p_{i,L-l_{id}}$

插入 $(x,h)$ 的时候，因为我们是按高度插入的，所以第 $i$ 个块会获得 $\sum_{j=i}^{id-1}$[该块中已经插入的元素个数] 的贡献，倒序修改就可以做到 $O(\sqrt n)$

当询问的左右端点不在同一个块里面时，分为几种情况

- 整块之间的贡献：类比 $p$ 的方法，我们用 $s_{i,j}$ 表示第 $i$ 个块里面的数和 $[j,i-1]$ 这些块里面的数的贡献

- 散块和整块的贡献：我们用 $w_{i,j}$ 表示**前** $i$ 个块，小于等于 $j$ 的有多少个，枚举两端散块的元素，用前缀和的方法计算答案即可

- 左散块和左散块之间的贡献，右散块和右散块之间的贡献：类比左右端点在同一个块里的方法计算答案

- 左散块和右散块之间的贡献：我们考虑事先维护一个对于每一个块排好序的数组，处理的时候利用类似双指针的方法可以 $O(\sqrt n)$ 计算答案，类似于[这道题](https://www.luogu.com.cn/problem/P5046)散块的处理方法

于是对于每次询问，我们都可以 $O(n\sqrt n)$ 计算答案

对于 $y$ 轴，方法类似，但是细节上会有一点点问题，建议写成两个 namespace，~~毕竟初始化那堆东西就要1s~~

总复杂度为 $O(8m\sqrt n+m\log n)$

常数非常大，在 loj 上经过优化可以 AC，洛谷经过优化可以拿到 80-90 左右。

这里贴出没有优化的版本，loj 88，洛谷64

~~其实很多东西都是重复的嘛~~

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=1e5+5;
const int W=335;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int A[N],B[N];
int a[N];
int root[N],tot;
int l[N],r[N],pos[N],sq,bl;
int cnt1,cnt2;
ll out[N<<2],sxd;

struct node{
	int lc,rc,val;	
}seg[N*30];

struct misaka{
	int l,r,h,id,opt;
	bool operator < (const misaka &cmp)const{
		return h<cmp.h;
	}
};

struct mikoto{
	int x,h;
};

bool cmp1(mikoto x,mikoto y){
	return x.h<y.h;	
}

bool cmp2(mikoto x,mikoto y){
	return x.x<y.x;
}

int insert(int o,int l,int r,int x){
	int u=++tot;
	seg[u]=seg[o];
	seg[u].val++;
	if(l==r)return u;
	int mid=l+r>>1;
	if(x<=mid)seg[u].lc=insert(seg[u].lc,l,mid,x);
	else seg[u].rc=insert(seg[u].rc,mid+1,r,x);
	return u;
}

int query(int u,int v,int l,int r,int ql,int qr){
	if(ql>qr)return 0;
	if(l>=ql&&r<=qr)return seg[v].val-seg[u].val;
	int mid=l+r>>1,res=0;
	if(ql<=mid)res+=query(seg[u].lc,seg[v].lc,l,mid,ql,qr);
	if(qr>mid)res+=query(seg[u].rc,seg[v].rc,mid+1,r,ql,qr);
	return res;	
}

void init(){
	sq=sqrt(n);
	Rep(i,1,n)pos[i]=(i-1)/sq+1;
	bl=pos[n];
	Rep(i,1,bl)l[i]=(i-1)*sq+1,r[i]=i*sq;
	r[bl]=n;	
}

namespace shirai{
	misaka T[N<<3];
	mikoto a[N],b[N];
	ll s[W][W],w[W][N];
	int sum[W];
	int p[N][W];
	int val[N],cnt[W];
	void update(int x,int h){
		int tot=0;
		_Rep(i,x-1,l[pos[x]]){
			if(val[i])sum[pos[x]]++,tot++;
			p[x][i-l[pos[x]]]+=tot;
		}
		tot=0;
		_Rep(i,pos[x]-1,1){
			tot+=cnt[i];
			s[pos[x]][i]+=tot;
		}
		Rep(i,1,bl)w[i][h]=w[i][h-1];
		Rep(i,pos[x],bl)w[i][h]++;
		cnt[pos[x]]++;
		val[x]=h;
	}
	ll ask(int ql,int qr,int h){
		if(ql>qr)return 0;
		if(pos[ql]==pos[qr]){
			ll res=0;
			Rep(i,ql+1,qr)res+=p[i][ql-l[pos[ql]]];
			return res;	
		}
		ll res=0;
		int ll=l[pos[ql]],ext=0;
		Rep(i,ql+1,r[pos[ql]])res+=p[i][ql-l[pos[ql]]];
		Rep(i,l[pos[qr]]+1,qr)res+=p[i][0];
		Rep(i,l[pos[qr]],r[pos[qr]]){
			if(b[i].h>h)break;
			if(b[i].x>qr||b[i].x<ql)continue;
			while(ll<=r[pos[ql]]&&b[ll].h<=b[i].h){
				if(b[ll].x>=ql&&b[ll].x<=qr)ext++;
				ll++;
			}
			res+=ext;
		}
		Rep(i,pos[ql]+2,pos[qr]-1)res+=s[i][pos[ql]+1];
		Rep(i,pos[ql]+1,pos[qr]-1)res+=sum[i];
		int tot=0;
		Rep(i,pos[ql]+1,pos[qr]-1)tot+=cnt[i];
		Rep(i,ql,r[pos[ql]])if(val[i])res+=tot-(w[pos[qr]-1][val[i]]-w[pos[ql]][val[i]]);
		Rep(i,l[pos[qr]],qr)if(val[i])res+=w[pos[qr]-1][val[i]]-w[pos[ql]][val[i]];
		return res;
	}
	void solve(){
		sort(a+1,a+n+1,cmp1);
		sort(T+1,T+4*m+1);
		Rep(i,1,bl)sort(b+l[i],b+r[i]+1,cmp1);
		int now=1;
		Rep(i,1,4*m){
			while(now<=n&&a[now].h<=T[i].h){
				update(a[now].x,a[now].h);
				now++;
			}
			ll val=ask(T[i].l,T[i].r,T[i].h);
			out[T[i].id]+=T[i].opt*val;
		}
	}
}

namespace kuroko{
	misaka T[N<<3];
	mikoto a[N],b[N];
	ll s[W][W],w[W][N];
	int sum[W];
	int p[N][W];
	int val[N],cnt[W];
	void update(int x,int h){
		int tot=0;
		_Rep(i,x-1,l[pos[x]]){
			if(val[i])sum[pos[x]]++,tot++;
			p[x][i-l[pos[x]]]+=tot;
		}
		tot=0;
		_Rep(i,pos[x]-1,1){
			tot+=cnt[i];
			s[pos[x]][i]+=tot;
		}
		Rep(i,1,bl)w[i][h]=w[i][h-1];
		Rep(i,pos[x],bl)w[i][h]++;
		cnt[pos[x]]++;
		val[x]=h;
	}
	ll ask(int ql,int qr,int h){
		if(ql>qr)return 0;
		if(pos[ql]==pos[qr]){
			ll res=0;
			Rep(i,ql+1,qr)res+=p[i][ql-l[pos[ql]]];
			return res;	
		}
		ll res=0;
		int ll=l[pos[ql]],ext=0;
		Rep(i,ql+1,r[pos[ql]])res+=p[i][ql-l[pos[ql]]];
		Rep(i,l[pos[qr]]+1,qr)res+=p[i][0];
		Rep(i,l[pos[qr]],r[pos[qr]]){
			if(b[i].h>h)break;
			if(b[i].x>qr||b[i].x<ql)continue;
			while(ll<=r[pos[ql]]&&b[ll].h<=b[i].h){
				if(b[ll].x>=ql&&b[ll].x<=qr)ext++;
				ll++;
			}
			res+=ext;
		}
		int tmp=0;
		Rep(i,pos[ql]+2,pos[qr]-1)res+=s[i][pos[ql]+1];
		Rep(i,pos[ql]+1,pos[qr]-1)res+=sum[i];
		int tot=0;
		Rep(i,pos[ql]+1,pos[qr]-1)tot+=cnt[i];
		Rep(i,ql,r[pos[ql]])if(val[i])res+=tot-(w[pos[qr]-1][val[i]]-w[pos[ql]][val[i]]);
		Rep(i,l[pos[qr]],qr)if(val[i])res+=w[pos[qr]-1][val[i]]-w[pos[ql]][val[i]];
		return res;
	}
	void solve(){
		sort(T+1,T+4*m+1);
		sort(b+1,b+n+1,cmp2);
		Rep(i,1,bl)sort(b+l[i],b+r[i]+1,cmp1);
		int now=1;
		Rep(i,1,4*m){
			while(now<=n&&a[now].h<=T[i].h){
				update(a[now].x,a[now].h);
				now++;
			}
			ll val=ask(T[i].l,T[i].r,T[i].h);
			out[T[i].id]+=T[i].opt*val;
		}
	}
}

int main()
{
	read(n),read(m);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n)root[i]=insert(root[i-1],1,n,a[i]);
	init();
	Rep(i,1,m){
		int x1,y1,x2,y2;
		read(x1),read(x2),read(y1),read(y2);
		shirai::T[++cnt1]=(misaka){1,x2,y2,i,-1};// 1234 
		shirai::T[++cnt1]=(misaka){1,x1-1,y2,i,1};// 12
		shirai::T[++cnt1]=(misaka){x1,x2,y2,i,1};// 34
		shirai::T[++cnt1]=(misaka){x1,x2,y1-1,i,-1};// 3
		kuroko::T[++cnt2]=(misaka){1,y1-1,x1-1,i,-1};// 1
		kuroko::T[++cnt2]=(misaka){1,y1-1,x2,i,1};// 13
		kuroko::T[++cnt2]=(misaka){y1,y2,x1-1,i,-1};// 2
		kuroko::T[++cnt2]=(misaka){y1,y2,x2,i,1};// 24
		out[i]=1ll*query(root[0],root[x1-1],1,n,1,y1-1)*query(root[x1-1],root[x2],1,n,y1,y2);
	}
	Rep(i,1,n)shirai::a[i]=(mikoto){i,a[i]},shirai::b[i]=shirai::a[i];
	Rep(i,1,n)kuroko::a[i]=(mikoto){a[i],i},kuroko::b[i]=kuroko::a[i];
	shirai::solve();
	kuroko::solve();
	Rep(i,1,m)printf("%lld\n",out[i]);
	return 0;
}
```


---

## 作者：whiteqwq (赞：11)

[P6774 [NOI2020] 时代的眼泪](https://www.luogu.com.cn/problem/P6774)/[P6579 [Ynoi2019] Happy Sugar Life](https://www.luogu.com.cn/problem/P6579)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1805748)

提供一种线性空间的简单做法，参考了[chasedeath神仙](https://www.cnblogs.com/chasedeath/p/14474237.html)的写法。

前置知识：基本分块思想与能力（例题[P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I](https://www.luogu.com.cn/problem/P5046)）

## 题意

给定长度为 $n$ 的排列 $p$ ， $q$ 次询问区间 $[l,r]$ 内保留值域 $[a,b]$ 的数之后的顺序对。

$1\leqslant n\leqslant 10^5,1\leqslant q\leqslant 2\times 10^5$

## 分析

这个做法相对套路，没有什么新颖的地方，适合刚学分块的萌新。

首先该问题不弱于区间逆序对，因此直接考虑序列分块，设块长为 $B$ 。

对于一次询问 $[l,r,a,b]$ ，我们要计算的是整块内部，整块对整块，散块内部，散块对散块，整块对散块共五种贡献。

考虑如何处理一个点与一个区间（不交）产生的贡献，不难发现区间可以差分为两个前缀，离线之后我们用值域分块就可以统计贡献了，复杂度是 $O(n\sqrt n)$ 加询问次数的。

那么散块对散块和整块对散块就可以直接做了，即枚举散块每一个点并产生一次询问。这样时空是 $O(qB)$ 的，但是不难发现直接把整个散块挂在前缀上就做到了线性空间。

然后是整块内部，块内离散化一下，设 $r_{i,j}$ 为值域 $i$ 到值域 $j$ 的块内答案，这样就可以 $O(\frac{qn}{B}+nB)$ 递推了。

对于散块内部的贡献，我们考虑把每次询问的散块询问挂在对应块的前/后缀上，然后枚举块并离散化，从左到右/从右到左（要分别做）加入块的每一个数，处理 $s_{i,j}$ 表示块内第 $i$ 小的值到第 $j-1$ 小的值在第 $j$ 小的值之后的个数，再枚举每个询问，不难发现产生了的贡献可以暴力计算，复杂度 $O((n+q)B)$ 。

最后整块对整块，考虑在值域上差分，答案是值域 $[1,b]$ 的答案减去值域 $[1,a-1]$ 的答案。然后按值域从小到大用另一个序列分块 $O(1)$ 加入，同时处理一个 $t_{i,j}$ 表示第 $i$ 个块到第 $j-1$ 个块对第 $j$ 个块的顺序对贡献，这样就可以 $O(\frac{qn}{B}+nB)$ 了。

很显然，上面那样做会计入小于 $a$ 的值与在 $[a,b]$ 内的值的贡献，于是我们枚举每个块，做个前缀和减去这样的值就可以了。

时间复杂度为 $O((n+q)(\sqrt n+B)+\frac{nq}{B})$ ，空间复杂度为 $O(n+\frac{Bq}{S})$ ， $B$ 设为根号级别的值就做到了时间 $O(n\sqrt n)$ 空间线性。

这里顺便提一个散块内部比较好写的解法（我写的是这种）：

考虑分治：每次把区间划分成两份，左区间与右区间的贡献直接用上面的方法，但不难发现这样会产生 $O(qB)$ 次询问。

设一个阈值 $S$ ，如果区间长度小于阈值就 $O(n^2)$ 暴力，否则继续分治，总共会产生 $O(\frac{qB}{S})$ 次询问，暴力的总复杂度为 $O(qBS)$ 的，微调一下就没有问题了，时空复杂度是与上面一样的。

## 代码

虽然比较短只有3.1k，但是还是写了一上午+一下午。（为什么有人写了46k哇，恐怖如斯）

目前是[P6579 [Ynoi2019] Happy Sugar Life](https://www.luogu.com.cn/problem/P6579)最优解（时间，空间，代码长度），想要的可以私信我。

---

## 作者：dead_X (赞：9)

## 名人名言

一道非常优秀的分块**入门**题，值得分块初学者花时间思考，不值得一写。

—— $\tt{B}\color{red}{Fqwq}$

## Section -1

好吧，虽然前半句令人不适，后半句说的还是挺对的。

NOI 2020 之后就一直想切这个题……没办法，谁叫我是**时代的眼泪**呢……

一开始一直沿用 Yuno loves sqrt tech I 的方法做这题，最后发现虽然有一些迁移性，但还是有较大差异的。

**如果您没有切 Yuno loves sqrt tech I，强烈建议你先去做那个题，至少口胡一遍。**

由于下标会比较多，本文在超过一个下标的时候会采用多元函数形式表示数组，以拯救笔者和读者的眼睛。

## Section 0

* 定义 $F(l,r,x,y)$：$(l,r,x,y)$ 这个询问的答案。

* 定义 $G(L,R,x,y)$：第 $L$ 到 $R$ 块块间答案。

* 定义 $lp$：块的最左边。

* 规定下文的 $[l,r]$ 只包含 $[l,r]$ 内的整数。

## Section 1

序列分块，块长 $\sqrt n$，序列内离散化。

## Section 2

接下来的套路就比较寻常了，我们先把左右散块分开得到一张经典图。

![](https://cdn.luogu.com.cn/upload/image_hosting/i7xl9i96.png)

然后不难发现有三种块间贡献：散块对整块（红 $\to$ 蓝），整块对散块（蓝 $\to$ 绿），散块对散块（红 $\to$ 绿），整块对整块（一块中的蓝 $\to$ 另一块的蓝）。

然后不难发现除了这几种贡献，我们还有散块和整块间（同块 $\to$ 同块）的贡献，一共 $6$ 种。

这六种贡献加起来，就是答案了（如果左右端点在同块则只记为一个散块统计）。

接下来我们一个一个来算。

## Section 3

我们先考虑散块内部的贡献。

现在的规模已经变成 $\sqrt n$ 了（即下标，值域都 $\leq\sqrt n$），因此可以暴力记录 $[lp,i]$  的数中小于等于 $y$ 的有几个。

* 定义 $rk_i$ 为 $i$ 的块内从小到大排名。
* 定义 $pre(i,r)$ 为 $[lp,i]$ 中 $rk$ 小于 $r$ 的数的数量。 

我们对于**每一块**都预处理这一块的 $pre$ 数组，一个块的复杂度为 $\sqrt n\times\sqrt n$，总复杂度为 $O(n\sqrt n)$。

然后我们可以拆 $F(l,r,x,y)=F(l,r,1,y)-F(l,r,1,x-1)-\sum\limits_{i=l}^r[x\leq a_i\leq y]pre(i,lb_x-1)$。

稍微推一下就可以得到 $F(l,r,1,y)=\sum\limits_{i=l}^r[a_i\leq y]pre(i,rk_i)$。单次询问复杂度 $O(\sqrt n)$。

## Section 4

散块对散块的贡献。

这类是最简单的，由于两边都只有 $\sqrt n$ 个数，提取出来排序后归并计算顺序对即可。如果我们对每块**预先根据值排序**，然后只对所有数判断是否需要提取出来，单次询问复杂度就可以消掉 $\log$，即 $O(\sqrt n)$。这个 trick 和 Yuno loves sqrt tech I 是一样的，具体可以看这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/0fxhnwah.png)

## Section 5

整块对整块的贡献。

由于只有 $\sqrt n$ 个块，我们还是可以暴力。

* 定义 $PRE(i,r)$ 为前 $i$ 块中小于等于 $r$ 的数的个数。

预处理的时间复杂度为 $O(n\sqrt n)$。

然后我们根据散块间贡献那个式子的形式分解一下，假设我们求第 $[L,R]$ 块的贡献。

$G(L,R,x,y)=G(L,R,1,y)-G(L,R,1,x-1)-\sum\limits_{i=L}^RP_iQ_i$。

其中 $P_i$ 代表  $[L,i)$ 块中 $<x$ 的数的个数，$Q_i$ 代表第 $i$ 块 $\in[x,y]$ 的数的个数。由于 $P_i$ 和 $Q_i$ $PRE$ 已经处理好了，于是后面的东西可以 $O(\sqrt n)$ 算。

而前面我们就要再次利用之前的一个性质了：一个块只有 $\sqrt n$ 种不同的数。我们将 $PRE$ 数组转化成块内贡献。

* 定义 $bpre(i,r)$ 为 $i$ 所在块之前的所有数中小于 $i$ 这块从小到大第 $j$ 个数的数量。 
* 定义 $lb(i,j)$ 为在 $i$ 所在块所有元素中比 $j$ 小的最大元素的从小到大排名。

不难发现并不需要预处理 $bpre$ ，可以根据 $rk$ 在 $PRE$ 中查询，$lsh$ 可以单块 $O(n)$ 处理，总时间复杂度 $O(n\sqrt n)$。

有了这两项，我们就可以预处理 $G(L,R,1,y)$ 了。

* 定义 $bans(i,L,r)$ 为 $[1,L]$ 块与第 $i$ 块从小到大前 $r$ 个元素组成的逆序对数量。

显然 $bans(i,L,r)=\sum\limits_{j\in\text{block}}[rk_j\leq r]bpre_{L,rk_j}$，然后这玩意可以前缀和，单块 $O(n)$，整体 $O(n\sqrt n)$。

 $G(L,R,1,x)=\sum\limits_{i=L+1}^R bans(i,i-1,lb(i,x))-bans(i,L-1,lb(i,x))$，因此单次询问 $O(\sqrt n)$。

## Section 6

散块对整块的贡献和整块对散块的贡献。

这两部分并不难，由于只有 $\sqrt n$ 个数，我们只要判断每个数和中间的所有整块能组成的逆序对即可。

我们可以将所有整块中 $[l,r]$ 的出现次数用 $PRE$ 在 $O(1)$ 的时间内求出来，对于散块中的数一个一个求逆序对数量即可，单次询问 $O(\sqrt n)$。

## Section 7

整块块内的贡献。

由于 $x$ 和 $y$ 在每块离散化之后只有 $\sqrt n\times \sqrt n$ 种选择，所以我们考虑把所有情况都算出来。

*  定义 $Pre(i,x,y)$ 为第 $i$ 块取从小到大第 $x$ 到 $y$ 个元素组成的逆序对数量。

这部分是可以通过 $pre(i,r)$ 暴力预处理的，单块 $O(n)$，总时空复杂度 $O(n\sqrt n)$。

## Section 8

综上，我们在 $O(n\sqrt n)$ 的时空复杂度内在线解决了这个问题……

这个题实现起来逻辑清晰，但是代码有一点点细节和一点点长度，在洛谷上有一点点卡常。

~~为了卡常我特判了第 $10$ 个数据点并在那个点用了 Yuno loves sqrt tech II 的代码。~~

然而如果您不像我一样人傻常数大应该马上就能卡过去吧。

---

## 作者：BFqwq (赞：9)

## [NOI2020] 时代的眼泪

~~大家好，我是本题的题目~~

首先我们很容易想到，顺序对和逆序对其实是一样的。

那么，要求区间在某个范围内的顺序对，那一定不弱于区间逆序对。然后您看一眼[这题](https://www.luogu.com.cn/problem/P5046)，于是你就知道想要不分块做这个题是相当困难的。

那么就考虑分块。这里直接使用序列分块。

为方便理解，在本题解中，询问变量设为 $l,r,x,y$，其对应答案为 $ans(l,r,x,y)$。

---

首先，我们考虑如果 $l,r$ 在一个块内的贡献怎么处理。

这里有一个非常优秀的性质，就是一个块内仅有 $\sqrt n$ 种不同的值。

我们可以预处理出每一个数在一个块内对应的 $lower\_bound$ 以及 $upper\_bound$ 所对应的值，然后接下来这里是可以 $\operatorname O(1)$ 求出的。

然后我们对这个块做一个二维前缀和，设 $a_{i,j}$ 表示在该块内在 $i$ 及以前且小于等于 $j$ 的数量。对于一个块，这样的前缀和的复杂度为 $\operatorname O(n)$，加起来是 $\operatorname O(\sqrt n)$。

设 $t$ 为 $[l,r]$ 范围中前一个数小于 $x$，后一个数在 $[x,y]$ 范围内的贡献，则 

$$ans(l,r,x,y)=ans(l,r,1,y)-ans(l,r,1,x)-t$$

而 

$$ans(l,r,1,x)=\sum\limits_{i=l}^r a_{i-1,p_i}-a_{l-1,p_i}(p_i< x)$$

$$t=\sum\limits_{i=l}^r a_{i-1,lower\_bound(x)}-a_{l-1,lower\_bound(x)}(x\le p_i\le y)$$

于是就搞定啦！

复杂度是 $\operatorname{O}(\sqrt n)$ 每次。

---

然后我们再来考虑如果 $[l,r]$ 不在一个区间的情况。

**首先，我们考虑整块对整块的贡献。**

我们可以类似散块的方式容斥加枚举求出答案。

我们先求 $t$。类似于刚才的讨论方法，我们令 $b_{i,j}$ 代表在第 $i$ 块及之前且小于等于 $j$ 的个数，也就是二维前缀和。这部分可以 $\operatorname O(n\sqrt n)$ 求出。

然后每次查询的时候枚举所有整块，复杂度是 $\operatorname O(\sqrt n)$ 每次。

这里的式子稍微有点变化，在求 $t$ 的时候要乘上这个块在 $[x,y]$ 内的数的个数。

然后在求 $ans$ 的时候，我们发现不是很好求。于是我们预先对每一个块处理一个 $c$ 数组。

$c_{i,j}$ 代表在前 $i$ 个块内值小于等于**本块内第 $j$ 小的值**的个数。我们可以根据 $b$ 数组来求这个数组，每个块 $\operatorname O(n)$，共 $\operatorname O(n\sqrt n)$。

然后对于第 $k$ 个块，我们要求的就是

$$\sum\limits_{i=rk(upper\_bound(x))}^{rk(lower\_bound(y))} c_{k-1,i}-c_{bl_l,i}$$

其中 $bl_l$ 为 $l$ 所在的块。

然后我们发现这边又可以二维前缀和。于是我们只需要枚举块，这部分就是 $\operatorname O(\sqrt n)$ 了。

**接着，我们考虑散块对整块的贡献。**

由于我们已经有了 $b$ 数组，因此我们可以直接枚举散块中的元素，然后找到整块中满足贡献条件的值的个数。

由于散块的元素是 $\operatorname O(\sqrt n)$ 的，故复杂度也是 $\operatorname O(\sqrt n)$ 每次。

**再接着，我们考虑散块对散块的贡献。**

我们先对每个块处理一个 $d$ 数组，代表这个块排序之后的顺序（存下标）。

然后我们直接对两个零散块归并排序一轮，注意忽视不在 $[l,r]$ 以及 $[x,y]$ 范围内的点。

由于散块的元素是 $\operatorname O(\sqrt n)$ 的，故复杂度也是 $\operatorname O(\sqrt n)$ 每次。

**再然后，我们考虑整块内部的贡献。**

显然我们把区间对应的 $upper\_bound(x)$ 和 $lower\_bound(y)$ 求出之后，我们可以发现，一共只有 $\sqrt n \times \sqrt n$ 种情况。

对每个块预处理所有情况的贡献。这里我们需要使用 $a$ 数组来辅助我们预处理出每种 $(x,y)$ 取法所对应的答案，并存到一个数组中，设为 $e$。

这部分每个块的复杂度是 $\operatorname O(n)$ 的，共 $\operatorname O(n\sqrt n)$。

然后每次查询我们只要在枚举块并 $e$ 数组中找到对应的值即可。复杂度是 $\operatorname O(\sqrt n)$ 每次。

**最后，我们考虑散块内部的贡献。**

然后我们发现这和 $l,r$ 在同一块内没有区别。

直接套上去就行。这里的复杂度显然是 $\operatorname O(\sqrt n)$ 每次。

于是我们就完成了所有情况的讨论。

---

对于每种情况，我们的单次操作复杂度均为 $\operatorname O(\sqrt n)$，共 $\operatorname O(m\sqrt n)$，预处理复杂度均为 $\operatorname O(n\sqrt n)$，空间复杂度 $\operatorname O(n\sqrt n)$。

常数较大，需要一定的卡常技巧。另外，Ynoi 中同题面的题由于空间复杂度较劣及时间常数较大无法 AC。loj 由于时限较大，可比较轻松地通过。

一道非常优秀的分块入门题，值得分块初学者花时间思考，不值得一写。

这个题是我在 noi 结束的那一天看到的，当天就自己想出来了，但咕到了 noip 前才写。现在过来补个题解，算是对自己 OI 生涯的一个纪念吧。







---

## 作者：FZzzz (赞：9)

第十三分块。

感谢 lxl 在送我退役上出的一份力（雾）

我就是时代的眼泪的眼泪的眼泪的眼泪的眼泪（大雾）

------------
题意：给一个排列，每次询问 $[r_1,r_2]$ 中值在 $[c_1,c_2]$ 中的数形成的逆序对个数。

考虑分块。

散块对散块的贡献可以直接块内排序（`ord` 数组）然后归并。

散块对整块的贡献和整块对散块的贡献，预处理一个块和值域上的二维前缀和（`s1` 数组和 `query1` 函数），然后枚举散块内的数计算。

散块内的贡献，由于一个块内的值的个数只有 $O(\sqrt n)$ 种，可以对每个块做 $\sqrt n\times\sqrt n$ 的二维前缀和（`s2` 数组和 `query2` 函数），然后枚举每个数进行计算。

整块内的贡献，由于值的个数只有 $O(\sqrt n)$ 种，所以可以把本质不同的 $\sqrt n\times\sqrt n=O(n)$ 种答案都预处理出来（`s3` 数组）。

注意以上两种贡献在实际的计算中需要把值域转换成块内的值域，相当于一个离散化的过程。我们预处理每个数在块内的 bound（`lbd` 和 `ubd` 数组）。

整款间的贡献，进行容斥，$[c_1,c_2]$ 中的贡献等于 $[1,c_2]$ 的贡献减去 $[1,c_1-1]$ 的贡献减去 $[1,c_1-1]$ 对 $[c_1,c_2]$ 的贡献。后者可以枚举每个块然后用二维前缀和进行计算，前者需要求保留 $[1,i]$ 的值 $[l,r]$ 块的块间贡献。

考虑离线，然后对值域做扫描线。看作是对一个 $\sqrt n\times\sqrt n$ 的矩阵进行操作，$(x,y)$ 的点是块 $x$ 与块 $y$ 的贡献，则值域每次从 $i$ 拓展到 $i+1$ 就是修改一整行，每次查询就是求 $[l,r]\times[l,r]$ 的正方形内的和。对每行做前缀和（`s4` 数组）即可。~~当然你也可以莽一个二维分块。~~

代码（在 loj 上通过）：
```cpp
#include<algorithm>
#include<vector>
#include<cmath>
#include<cstdio>
#include<cctype>
using namespace std;
inline int readint(){
	int x=0;
	char c=getchar();
	bool f=0;
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5,maxm=2e5+5,maxS=350,maxB=350;
int n,m,p[maxn],p2[maxn];
int S,B,L[maxB],R[maxB],pos[maxn];
int ord[maxn],s1[maxB][maxn],s2[maxB][maxS][maxS];
int lbd[maxB][maxn],ubd[maxB][maxn],s3[maxB][maxS][maxS];
bool cmp(int a,int b){
	return p[a]<p[b];
}
typedef long long ll;
ll ans[maxm];
int query1(int r1,int r2,int c1,int c2){
	return s1[r2][c2]-s1[r1-1][c2]-s1[r2][c1-1]+s1[r1-1][c1-1];
}
int query2(int x,int r1,int r2,int c1,int c2){
	return s2[x][r2][c2]-s2[x][r1-1][c2]-s2[x][r2][c1-1]+s2[x][r1-1][c1-1];
}
int query(int r1,int r2,int c1,int c2){
	int x=pos[r1];
	ll ans=0;
	for(int i=L[x];i<=R[x];i++)
		if(r1<=ord[i]&&ord[i]<=r2&&c1<=p[ord[i]]&&p[ord[i]]<=c2)
			ans+=query2(x,lbd[x][c1],i-L[x],r1-L[x]+1,ord[i]-L[x]);
	return ans;
}
struct qry{
	int l,r,id;
	bool flag;
	qry(int l,int r,int id,bool flag):l(l),r(r),id(id),flag(flag){}
};
vector<qry> q[maxn];
ll s4[maxB][maxB];
ll query4(int l,int r){
	ll ans=0;
	for(int i=l;i<=r;i++) ans+=s4[i][r]-s4[i][l-1];
	return ans;
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	m=readint();
	for(int i=1;i<=n;i++) p2[p[i]=readint()]=i;
	S=sqrt(n);
	B=(n-1)/S+1;
	for(int i=1;i<=B;i++){
		L[i]=(i-1)*S+1;
		R[i]=i==B?n:i*S;
		for(int j=L[i];j<=R[i];j++){
			pos[j]=i;
			s1[i][p[j]]++;
			ord[j]=j;
		}
		sort(ord+L[i],ord+R[i]+1,cmp);
		for(int j=1;j<=n;j++) s1[i][j]+=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];
		for(int j=L[i];j<=R[i];j++) s2[i][j-L[i]+1][ord[j]-L[i]+1]=1;
		for(int j=1;j<=R[i]-L[i]+1;j++) for(int k=1;k<=R[i]-L[i]+1;k++)
			s2[i][j][k]+=s2[i][j-1][k]+s2[i][j][k-1]-s2[i][j-1][k-1];
		for(int j=1;j<=p[ord[L[i]]];j++) lbd[i][j]=1;
		for(int j=L[i];j<R[i];j++)
			for(int k=p[ord[j]]+1;k<=p[ord[j+1]];k++) lbd[i][k]=j-L[i]+2;
		for(int j=p[ord[R[i]]]+1;j<=n;j++) lbd[i][j]=R[i]-L[i]+2;
		for(int j=1;j<p[ord[L[i]]];j++) ubd[i][j]=1;
		for(int j=L[i];j<R[i];j++)
			for(int k=p[ord[j]];k<p[ord[j+1]];k++) ubd[i][k]=j-L[i]+2;
		for(int j=p[ord[R[i]]];j<=n;j++) ubd[i][j]=R[i]-L[i]+2;
		for(int j=1;j<=R[i]-L[i]+1;j++) for(int k=j;k<=R[i]-L[i]+1;k++)
			s3[i][j][k]=s3[i][j][k-1]+query2(i,j,k-1,1,ord[L[i]+k-1]-L[i]);
	}
	for(int i=0;i<m;i++){
		int r1,r2,c1,c2;
		r1=readint();
		r2=readint();
		c1=readint();
		c2=readint();
		if(pos[r1]==pos[r2]){
			ans[i]=query(r1,r2,c1,c2);
			continue;
		}
		ans[i]=query(r1,R[pos[r1]],c1,c2)+query(L[pos[r2]],r2,c1,c2);
		vector<int> res1,res2;
		for(int j=L[pos[r1]];j<=R[pos[r1]];j++)
			if(ord[j]>=r1&&c1<=p[ord[j]]&&p[ord[j]]<=c2)
				res1.push_back(p[ord[j]]);
		for(int j=L[pos[r2]];j<=R[pos[r2]];j++)
			if(ord[j]<=r2&&c1<=p[ord[j]]&&p[ord[j]]<=c2)
				res2.push_back(p[ord[j]]);
		int cur=0;
		for(int j=0;j<(int)res1.size();j++){
			while(cur<(int)res2.size()&&res2[cur]<res1[j]) cur++;
			ans[i]+=res2.size()-cur;
		}
		for(int j=r1;j<=R[pos[r1]];j++) if(c1<=p[j]&&p[j]<=c2)
			ans[i]+=query1(pos[r1]+1,pos[r2]-1,p[j]+1,c2);
		for(int j=L[pos[r2]];j<=r2;j++) if(c1<=p[j]&&p[j]<=c2)
			ans[i]+=query1(pos[r1]+1,pos[r2]-1,c1,p[j]-1);
		for(int j=pos[r1]+1;j<pos[r2];j++)
			ans[i]-=1ll*query1(j,j,1,c1-1)*query1(j+1,pos[r2]-1,c1,c2);
		for(int j=pos[r1]+1;j<pos[r2];j++)
			ans[i]+=s3[j][lbd[j][c1]][ubd[j][c2]-1];
		q[c2].push_back(qry(pos[r1]+1,pos[r2]-1,i,1));
		q[c1-1].push_back(qry(pos[r1]+1,pos[r2]-1,i,0));
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<pos[p2[i]];j++) s4[pos[p2[i]]][j]+=query1(1,j,1,i-1);
		for(int j=pos[p2[i]];j<=B;j++)
			s4[pos[p2[i]]][j]+=query1(1,pos[p2[i]]-1,1,i-1);
		for(int j=0;j<(int)q[i].size();j++)
			if(q[i][j].flag) ans[q[i][j].id]+=query4(q[i][j].l,q[i][j].r);
			else ans[q[i][j].id]-=query4(q[i][j].l,q[i][j].r);
	}
	for(int i=0;i<m;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：FunnyCreatress (赞：5)

一个鬼畜的大常数分块做法，勉强卡进最优解前三页（

因为我不会一维分块的做法，所以我就用二维分块了。

首先把整个平面切成 $\sqrt n\times \sqrt n$块，考虑一个矩形在这个划分过的平面中的位置。

假设我们现在有这样一个红色的矩形

![](https://cdn.luogu.com.cn/upload/image_hosting/t1vu3bhn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么，可以看到，它被蓝色标记的线分成了九块，如图标示为 $1..9$，那么，我们需要求的就是区域两两间的贡献+区域内部贡献。

## 1.区域5的内部贡献
首先，贡献的第一部分是 5 内每块的内部贡献，只需要暴力枚举每块内的点对再做前缀和，可以 $O(n\sqrt n)-O(1)$ 求出。

然后考虑块间贡献，不妨只考虑每个块对其右上部分的贡献，这时两个块的位置关系又可以分为 3 类：

- 目标块在当前块的正上方，这时直接暴力求出每一列所有区间的答案，查询时直接枚举列即可。
- 目标块在当前块的正右方，类似上一种情况。
- 目标块在当前块右上方，那么当前块的贡献次数为右上方所有块的大小之和，之后一波变形就可以看出容易处理。

## 2.角对相邻边的贡献
以 3 对 2 的贡献为例，其余类似。

注意到 3 中的所有点横坐标都大于 2 中的点，那么直接归并是一种方法，不过由于后面还要处理一些东西，可以直接用，这个等会再提。

## 3.边对5的贡献
以 2 对 5 的贡献为例，其余类似。

首先边上一个点对它左下所有块的贡献是平凡的，只需要考虑它对正下方块的贡献。我们记 $f_{i,j,k}$ 为第 $i$ 列前 $j$ 块中与左边界距离不超过 $k$ 的点的个数，那么这块就容易求了，同时这个预处理也可以用于角对相邻边的贡献。

## 4.相邻角之间的贡献&相对边之间的贡献
这个没什么好说的，直接归并一下就可以了。

## 5.角内部的贡献
由于 3,7两角的做法相对平凡，只考虑另外两个角，以 1 为例。

枚举区域内每个点，计算在它右上且在区域内的点数。首先既然在右上，那么横坐标肯定是没有问题的，只有纵坐标可能会超出区域，那么我们只要对每个点 $i$，求出它右上方纵坐标与块的下边界距离不超过 $j$ 的点的个数，就可以轻易计算了。

## 6.边内部的贡献
显然有了 $f$ 那个数组的辅助，这个也不难了，直接枚举每个点 $O(1)$ 算贡献就行。

## 7.剩余部分
这个题目比较奇怪，但很快我们发现剩余部分贡献平凡，要么是 $0$ 要么是两个区域的点数相乘，很容易做。

至此，第一种矩形位置情况就做完了，剩余三种还是不难的，利用处理出来的信息可以很快求出答案。

综上，时空复杂度均为 $O(n\sqrt n)$，经过离线后应该可以做到线性空间。

这个 #10 非常可恶啊，优化不够好会卡不过去，只要加个特判就行了。

这题太毒瘤了，所以码风显得很丑，~~不过应该能看~~

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
typedef long long ll;
const int N=1e5+5,B=320;
int n,m,L,cntB,p[N],x[N],rb[B],b[N],res[B][B],c[B][B],s[B][B],sln[B][B],scol[B][B],ru[N],ld[N];ll sc[B][B],ans;
int fl[B][B][B],fc[B][B][B],cl[B][B][B],cc[B][B][B],rul[N][B],ldl[N][B],idl[N],idc[N],sz[10],a[10][B];
vector<int> v[B][B];
int read(){
	char ch;int x=0;
	while(ch=getchar(),ch<'!');x=ch-48;
	while(ch=getchar(),ch>'!')x=(x<<3)+(x<<1)+ch-48;
	return x;
}
bool cmp1(int xx,int yy){return b[xx]<b[yy]||b[xx]==b[yy]&&p[xx]<p[yy];}
bool cmp2(int xx,int yy){return b[xx]<b[yy]||b[xx]==b[yy]&&x[xx]<x[yy];}
void prework(){
	for(int i=1;i<=n;i++)s[b[i]][b[p[i]]]++,c[b[i]][b[p[i]]]++,v[b[i]][b[p[i]]].push_back(i);
	for(re int i=1;i<=cntB;i++)
		for(re int j=1;j<=cntB;j++){
			s[i][j]+=s[i][j-1]+s[i-1][j]-s[i-1][j-1],sln[i][j]=sln[i][j-1]+c[i][j],scol[i][j]=scol[i-1][j]+c[i][j];
			sc[i][j]=sc[i][j-1]+sc[i-1][j]-sc[i-1][j-1]+c[i][j]*s[i][j];
			for(re int k=0,tn;k<c[i][j];k++){
				tn=v[i][j][k],cl[i][j][tn-rb[i-1]]++,cc[j][i][p[tn]-rb[j-1]]++;
				for(re int l=k+1,sn;l<c[i][j];l++){
					sn=v[i][j][l];
					if(p[tn]<p[sn])ru[tn]++,rul[tn][p[sn]-rb[j-1]]++,ld[sn]++,ldl[tn][sn-rb[i-1]]++,res[i][j]++;
				}
			}
			for(re int k=1;k<=L;k++)cl[i][j][k]+=cl[i][j][k-1],cc[j][i][k]+=cc[j][i][k-1];
			for(re int k=1;k<=L;k++)cl[i][j][k]+=cl[i][j-1][k],cc[j][i][k]+=cc[j][i-1][k];
			res[i][j]+=res[i][j-1]+res[i-1][j]-res[i-1][j-1];
		}
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=L;j++)rul[i][j]+=rul[i][j-1],ldl[i][j]+=ldl[i][j-1];
	for(re int i=1;i<=cntB;i++)
		for(re int j=1;j<=cntB;j++)
			for(re int k=j+1;k<=cntB;k++){
				fl[i][j][k]=fl[i][j][k-1];
				for(re int l=0;l<c[i][k];l++)
					fl[i][j][k]+=cl[i][k-1][v[i][k][l]-rb[i-1]]-cl[i][j-1][v[i][k][l]-rb[i-1]];
			}
	for(re int i=1;i<=cntB;i++)
		for(re int j=1;j<=cntB;j++)
			for(re int k=i+1;k<=cntB;k++){
				fc[j][i][k]=fc[j][i][k-1];
				for(re int l=0;l<c[k][j];l++)
					fc[j][i][k]+=cc[j][k-1][p[v[k][j][l]]-rb[j-1]]-cc[j][i-1][p[v[k][j][l]]-rb[j-1]];
			}
}
int main(){
	n=read(),m=read(),L=sqrt(n),cntB=ceil(1.*n/L);
	for(int i=1;i<=n;i++)x[p[i]=read()]=i,b[i]=(i-1)/L+1,idl[i]=idc[i]=i;
	sort(idl+1,idl+n+1,cmp1),sort(idc+1,idc+n+1,cmp2);
	for(int i=1;i<cntB;i++)rb[i]=i*L;rb[cntB]=n;
	prework();
	for(re int i=1,r1,r2,c1,c2,l,r,u,d;i<=m;i++){
		r1=read(),r2=read(),c1=read(),c2=read(),ans=0;
		l=b[r1]+1,r=b[r2]-1,d=b[c1]+1,u=b[c2]-1;
		if(l<=r+1&&d<=u+1){
			if(c1==1&&c2==n)u++,d--;
			fill(sz,sz+10,0);
			ans+=1ll*s[r][u]*(sz[5]=s[r][u]-s[r][d-1]-s[l-1][u]+s[l-1][d-1])+sc[r][u]-sc[r][d-1]-sc[l-1][u]+sc[l-1][d-1];
			for(re int j=d;j<=u;j++)ans-=1ll*s[r][j]*(scol[r][j]-scol[l-1][j])-fc[j][l][r];
			for(re int j=l;j<=r;j++)ans-=1ll*s[j][u]*(sln[j][u]-sln[j][d-1])-fl[j][d][u];
			ans+=res[r][u]-res[r][d-1]-res[l-1][u]+res[l-1][d-1];
			for(re int j=rb[l-2]+1;j<=rb[l-1];j++)if(idl[j]>=r1&&p[idl[j]]<=c2&&p[idl[j]]>=c1)
				p[idl[j]]>rb[u]?a[1][++sz[1]]=idl[j]:(p[idl[j]]<=rb[d-1]?a[7][++sz[7]]=idl[j]:a[4][++sz[4]]=idl[j]);
			for(re int j=rb[r]+1;j<=rb[r+1];j++)if(idl[j]<=r2&&p[idl[j]]<=c2&&p[idl[j]]>=c1)
				p[idl[j]]>rb[u]?a[3][++sz[3]]=idl[j]:(p[idl[j]]<=rb[d-1]?a[9][++sz[9]]=idl[j]:a[6][++sz[6]]=idl[j]);
			for(re int j=rb[u]+1;j<=rb[u+1];j++)
				if(idc[j]<=c2&&x[idc[j]]>rb[l-1]&&x[idc[j]]<=rb[r])a[2][++sz[2]]=x[idc[j]];
			for(re int j=rb[d-2]+1;j<=rb[d-1];j++)
				if(idc[j]>=c1&&x[idc[j]]>rb[l-1]&&x[idc[j]]<=rb[r])a[8][++sz[8]]=x[idc[j]];
			ans+=sz[2]*(sz[4]+sz[7])+sz[3]*(sz[4]+sz[5]+sz[7]+sz[8])+sz[5]*sz[7]+sz[6]*(sz[7]+sz[8]);
			for(re int j=1;j<=sz[1];j++)ans+=cc[u+1][l-1][p[a[1][j]]-rb[u]]-cc[u+1][r][p[a[1][j]]-rb[u]]+
										  cl[l-1][u][a[1][j]-rb[l-2]]-cl[l-1][d-1][a[1][j]-rb[l-2]];
			ans+=sz[1]*(sz[2]+sz[4]-sln[l-1][u]+sln[l-1][d-1]);
			for(re int j=1;j<=sz[3];j++)ans+=cc[u+1][r][p[a[3][j]]-rb[u]]-cc[u+1][l-1][p[a[3][j]]-rb[u]]+
										  cl[r+1][u][a[3][j]-rb[r]]-cl[r+1][d-1][a[3][j]-rb[r]];
			for(re int j=1;j<=sz[7];j++)ans+=-cc[d-1][r][p[a[7][j]]-rb[d-2]]+cc[d-1][l-1][p[a[7][j]]-rb[d-2]]
										  -cl[l-1][u][a[7][j]-rb[l-2]]+cl[l-1][d-1][a[7][j]-rb[l-2]];
			ans+=sz[7]*(scol[r][d-1]-scol[l-1][d-1]+sln[l-1][u]-sln[l-1][d-1]);
			for(re int j=1;j<=sz[9];j++)ans+=cc[d-1][r][p[a[9][j]]-rb[d-2]]-cc[d-1][l-1][p[a[9][j]]-rb[d-2]]
										 -cl[r+1][u][a[9][j]-rb[r]]+cl[r+1][d-1][a[9][j]-rb[r]];
			ans+=sz[9]*(sz[8]+sz[6]-scol[r][d-1]+scol[l-1][d-1]);
			for(re int j=1,tn,tb;j<=sz[2];j++)
				tn=a[2][j],tb=b[tn]-1,ans+=s[tb][u]-s[tb][d-1]+cl[tb+1][u][tn-rb[tb]]-cl[tb+1][d-1][tn-rb[tb]];
			ans+=sz[2]*(s[l-1][d-1]-s[l-1][u]);
			for(re int j=1,tn,tb;j<=sz[4];j++)
				tn=p[a[4][j]],tb=b[tn]-1,ans+=s[l-1][tb]-s[r][tb]-cc[tb+1][r][tn-rb[tb]]+cc[tb+1][l-1][tn-rb[tb]];
			ans+=sz[4]*(s[r][u]-s[l-1][u]);
			for(re int j=1,tn,tb;j<=sz[6];j++)
				tn=p[a[6][j]],tb=b[tn]-1,ans+=s[r][tb]-s[l-1][tb]+cc[tb+1][r][tn-rb[tb]]-cc[tb+1][l-1][tn-rb[tb]];
			ans+=sz[6]*(s[l-1][d-1]-s[r][d-1]);
			for(re int j=1,tn,tb;j<=sz[8];j++)
				tn=a[8][j],tb=b[tn]-1,ans+=s[tb][d-1]-s[tb][u]-cl[tb+1][u][tn-rb[tb]]+cl[tb+1][d-1][tn-rb[tb]];
			ans+=sz[8]*(s[r][u]-s[r][d-1]);
			for(re int j=1,k=1;j<=sz[3];ans+=k-1,j++)
				while(k<=sz[1]&&p[a[1][k]]<p[a[3][j]])k++;
			for(re int j=1,k=1;j<=sz[9];ans+=k-1,j++)
				while(k<=sz[7]&&p[a[7][k]]<p[a[9][j]])k++;
			for(re int j=r1,c7=0;j<=rb[l-1];j++){
				if(p[j]>=c1&&p[j]<=rb[d-1])c7++;
				else if(p[j]<=c2&&p[j]>rb[u])ans+=c7;
			}
			for(re int j=rb[r]+1,c9=0;j<=r2;j++){
				if(p[j]>=c1&&p[j]<=rb[d-1])c9++;
				else if(p[j]<=c2&&p[j]>rb[u])ans+=c9;
			}
			for(re int j=1,k=1;j<=sz[2];ans+=k-1,j++)
				while(k<=sz[8]&&a[8][k]<a[2][j])k++;
			for(re int j=1,k=1;j<=sz[6];ans+=k-1,j++)
				while(k<=sz[4]&&p[a[4][k]]<p[a[6][j]])k++;
			for(re int j=1;j<=sz[3];j++)ans+=ld[a[3][j]];
			for(re int j=1;j<=sz[7];j++)ans+=ru[a[7][j]];
			for(re int j=1;j<=sz[1];j++)ans+=rul[a[1][j]][c2-rb[u]];
			for(re int j=1;j<=sz[9];j++)ans+=ldl[a[9][j]][r2-rb[r]];
			for(re int j=1,tn,tb;j<=sz[2];j++)
				tn=a[2][j],tb=b[tn]-1,ans+=ld[tn]+cc[u+1][tb][p[tn]-rb[u]]-cc[u+1][l-1][p[tn]-rb[u]]; 
			for(re int j=1,tn,tb;j<=sz[4];j++)
				tn=a[4][j],tb=b[p[tn]],ans+=ru[tn]+sln[l-1][u]-sln[l-1][tb]-cl[l-1][u][tn-rb[l-2]]+cl[l-1][tb][tn-rb[l-2]];
			for(re int j=1,tn,tb;j<=sz[6];j++)
				tn=a[6][j],tb=b[p[tn]]-1,ans+=ld[tn]+cl[r+1][tb][tn-rb[r]]-cl[r+1][d-1][tn-rb[r]]; 
			for(re int j=1,tn,tb;j<=sz[8];j++)
				tn=a[8][j],tb=b[tn],ans+=ru[tn]+scol[r][d-1]-scol[tb][d-1]-cc[d-1][r][p[tn]-rb[d-2]]+cc[d-1][tb][p[tn]-rb[d-2]]; 
		}
		else if(l>r+1&&d<=u+1){
			int cq=0;
			for(re int j=r2+1;j<=rb[r+1];j++)cq+=(p[j]>c2&&p[j]<=rb[u+1]);
			for(re int j=r1,c8=0;j<=r2;j++)if(p[j]>=c1&&p[j]<=c2){
				if(p[j]>rb[u])ans+=c8+cl[l-1][u][j-rb[r]]-cl[l-1][d-1][j-rb[r]]-cl[l-1][u][r1-1-rb[r]]+cl[l-1][d-1][r1-1-rb[r]]+rul[j][c2-rb[u]]+ldl[j][r2-rb[r]]-ru[j]+cq;
				else if(p[j]<=rb[d-1])c8++,ans+=cl[l-1][u][r2-rb[r]]-cl[l-1][d-1][r2-rb[r]]-cl[l-1][u][j-rb[r]]+cl[l-1][d-1][j-rb[r]]+ldl[j][r2-rb[r]];
				else ans+=ldl[j][r2-rb[r]]+cl[l-1][u][r2-rb[r]]-cl[l-1][b[p[j]]][r2-rb[r]]-cl[l-1][u][j-rb[r]]+cl[l-1][b[p[j]]][j-rb[r]];
			}
		}
		else if(l<=r+1&&d>u+1){
			int cq=0;
			for(re int j=r2+1;j<=rb[r+1];j++)cq+=(p[j]>c2&&p[j]<=rb[u+1]);
			for(re int j=c1,c4=0;j<=c2;j++)if(x[j]>=r1&&x[j]<=r2){
				if(x[j]>rb[r])ans+=c4+cc[d-1][r][j-rb[u]]-cc[d-1][l-1][j-rb[u]]-cc[d-1][r][c1-1-rb[u]]+cc[d-1][l-1][c1-1-rb[u]]+rul[x[j]][c2-rb[u]]+ldl[x[j]][r2-rb[r]]-ru[x[j]]+cq;
				else if(x[j]<=rb[l-1])c4++,ans+=cc[d-1][r][c2-rb[u]]-cc[d-1][l-1][c2-rb[u]]-cc[d-1][r][j-rb[u]]+cc[d-1][l-1][j-rb[u]]+rul[x[j]][c2-rb[u]];
				else ans+=rul[x[j]][c2-rb[u]]+cc[d-1][r][c2-rb[u]]-cc[d-1][b[x[j]]][c2-rb[u]]-cc[d-1][r][j-rb[u]]+cc[d-1][b[x[j]]][j-rb[u]];
			}
		}
		else{
			int cq=0;
			for(re int j=r2+1;j<=rb[r+1];j++)cq+=(p[j]>c2&&p[j]<=rb[u+1]);
			for(re int j=r1;j<=r2;j++)if(p[j]>=c1&&p[j]<=c2)ans+=rul[j][c2-rb[u]]+ldl[j][r2-rb[r]]-ru[j]+cq;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：wind_whisper (赞：3)

## 前言
看到题目名：~~别骂了别骂了~~。

一道很中规中矩的YNOI吧。
卡在整块对整块的贡献上了。
这也确实算是本题最不好做的部分了。

前置知识：[Yuno loves sqrt technology I](https://www.luogu.com.cn/problem/P5046)
## 解析
区间逆序对加强版？很难不想到两道 YLST。  
然而多了两维限制，二离似乎没啥前途了。  
考虑分块在线做法。  

设询问区间为 $[l,r]$，值域区间为 $[bot,top]$。  
还是老套路，把贡献分成散块内部、整块内部、散块对散块、整块对整块、散块对整块五部分，以及在同一块内的情况。

散块内部：.~~..这咋做啊~~这时难免会有上树状数组的冲动。但是稍加思考可以发现，每个块内的值只有 $O(\sqrt n)$ 个，所以不妨直接预处理出**每个数在块内的排名**以及**每个块内排名的前缀和**，然后直接差分查一查就行了。  
散块对散块：老套路，归并排序即可。  
整块对整块：一个比较直观的思路是容斥一下，求出 $[1,top]$ 的答案，再减去 $[1,bot-1]$ 的答案，再减掉 $[1,bot-1]$ 的数对 $[bot,top]$ 产生的贡献。  
最后减掉的贡献用前缀和搞一搞容易解决，那么如何求出整块之间值域形如 $[1,x]$ 的答案呢？（~~我就卡在这里勒~~）  
答案形如 $\sum_{b}\sum_{a<b} ans(a,b,1,x)$，考虑转化为对所有 $b$ 求出所有 $\sum_{a<b} ans(a,b,1,x)$ 然后求和。  
那么这个的形式似乎就非常好搞了，就是枚举 $b$ 块内所有处于 $[1,x]$ 的元素再在前面查顺序对那么预处理一下就行了。  
散块对整块：枚举散块元素，前缀和即可。

同一块内：使用和散块内部类似的方法前缀和即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("ok\n")

inline ll read(){
  ll x(0),f(1);char c=getchar();
  while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
  while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
  return x*f;
}
bool mem1;

const int N=1e5+100;
const int inf=1e9+100;
const bool Flag=0;
const int mod=1e9+7;

const int B=405;//number of block
const int S=405;//size of block

int n,m;
int pos[N],a[N],b[N],rk[N];
int st[B],ed[B],bel[N],w,len[B];
int sum[B][N],pre[N][S],val[B][S],pl[B][S];
int f[B][B][S],s[B][S][S];
int lb[B][N];
int u[S],v[S],n1,n2;
void init(){
  w=sqrt(n);
  for(int i=1;i<=n;i++) bel[i]=(i+w-1)/w;
  for(int k=1;k<=bel[n];k++){
    st[k]=(k-1)*w+1;
    ed[k]=min(n,k*w);
    len[k]=ed[k]-st[k]+1;
    sort(b+st[k],b+ed[k]+1);
    for(int i=st[k];i<=ed[k];i++){
      int suf=i==ed[k]?n+1:b[i+1];
      for(int j=b[i];j<suf;j++){
	lb[k][j]=i-st[k]+1;
      }
    }
    for(int i=st[k];i<=ed[k];i++) rk[pos[b[i]]]=i-st[k]+1;
    for(int i=1;i<=n;i++) sum[k][i]=sum[k-1][i];
    for(int i=st[k];i<=ed[k];i++){
      sum[k][a[i]]++;
      if(i!=st[k]){
	for(int j=1;j<=len[k];j++) pre[i][j]=pre[i-1][j];
      }
      pre[i][rk[i]]++;
      pl[k][rk[i]]=i;
      val[k][rk[i]]=a[i];
    }    
  }
  for(int i=1;i<=n;i++){
    for(int j=1;j<=len[bel[i]];j++) pre[i][j]+=pre[i][j-1];
  }
  for(int k=1;k<=bel[n];k++){
    for(int a=1;a<=len[k];a++){
      for(int b=a+1;b<=len[k];b++){
	int p=pl[k][b];
	s[k][a][b]=s[k][a][b-1]+(pre[p][b-1]-pre[p][a-1]);
      }
    }
  }
  for(int k=1;k<=bel[n];k++){
    for(int i=1;i<=n;i++) sum[k][i]+=sum[k][i-1];
  }
  for(int i=1;i<=bel[n];i++){
    for(int j=1;j<i;j++){
      for(int k=1;k<=len[i];k++){
	f[i][j][k]=sum[j][b[st[i]+k-1]]+f[i][j][k-1];
      }
    }
  }
  return;
}
void work(int l,int r,int bot,int top){
  if(l>r||bot>top){
    puts("0");
    return;
  }
  int x=bel[l],y=bel[r];
  if(x==y){
    ll res(0);
    for(int i=l;i<=r;i++){
      if(a[i]>=bot&&a[i]<=top){
	res+=(pre[i][rk[i]-1]-(l==st[x]?0:pre[l-1][rk[i]-1]))-(pre[i][lb[x][bot-1]]-(l==st[x]?0:pre[l-1][lb[x][bot-1]]));
      }
    }
    printf("%lld\n",res);
    return;
  }
  ll res(0);
  for(int i=x+1;i<y;i++){
    res+=s[i][lb[i][bot-1]+1][lb[i][top]];
  }
  for(int i=l;i<=ed[x];i++){
    if(a[i]>=bot&&a[i]<=top){
      res+=(pre[i][rk[i]-1]-(l==st[x]?0:pre[l-1][rk[i]-1]))-(pre[i][lb[x][bot-1]]-(l==st[x]?0:pre[l-1][lb[x][bot-1]]));
    }
  }
  for(int i=st[y];i<=r;i++){
    if(a[i]>=bot&&a[i]<=top){
      res+=pre[i][rk[i]-1]-pre[i][lb[y][bot-1]];
    }
  }
  int pp=st[x],cnt(0);
  for(int i=st[y];i<=ed[y];i++){
    while(pp<=ed[x]&&b[pp]<b[i]){
      cnt+=(pos[b[pp]]>=l&&b[pp]>=bot&&b[pp]<=top);
      ++pp;
    }
    if(pos[b[i]]<=r&&b[i]>=bot&&b[i]<=top) res+=cnt;
  }
  for(int i=l;i<=ed[x];i++){
    if(a[i]>=bot&&a[i]<=top) res+=(sum[y-1][top]-sum[x][top])-(sum[y-1][a[i]]-sum[x][a[i]]);
  }
  for(int i=st[y];i<=r;i++){
    if(a[i]>=bot&&a[i]<=top) res+=(sum[y-1][a[i]]-sum[x][a[i]])-(sum[y-1][bot-1]-sum[x][bot-1]);
  }
  for(int k=x+1;k<y;k++){
    if(lb[k][bot-1]<lb[k][top]){
      res+=(f[k][k-1][lb[k][top]]-f[k][x][lb[k][top]])-(f[k][k-1][lb[k][bot-1]]-f[k][x][lb[k][bot-1]]);
      res-=1ll*(lb[k][top]-lb[k][bot-1])*(sum[k-1][bot-1]-sum[x][bot-1]);
    }
  }
  printf("%lld\n",res);
}

bool mem2;
signed main(){
#ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
#endif
  debug("mem=%.4lf\n",abs(&mem2-&mem1)/1024./1024);
  n=read();m=read();
  for(int i=1;i<=n;i++){
    b[i]=a[i]=read();pos[a[i]]=i;
  }
  init();
  for(int i=1;i<=m;i++){
    int l=read(),r=read(),bot=read(),top=read();
    work(l,r,bot,top);
  }
  return 0;
}

```



---

## 作者：JWRuixi (赞：1)

~~我想了一天终于过了……~~

纪念一下，时代有遗憾，但是在这题上我没遗憾了。

- 题意

给定 $n$ 个点，形如 $(i,p_i)$，满足 $p_i$ 是一个排列，$m$ 组询问：

```l r u d```，询问有多少点对 $\{(x_1,y_1),(x_2,y_2)\}$ 满足 $l \le x_1 \le x_2 \le r$，$u \le y_1 \le y_2 \le d$。

- 分析

做此题之前可以先看一下它的弱化版 [P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I](https://www.luogu.com.cn/problem/P5046)，这题是区间逆序对，而我们接下来要研究的是区间二维偏序。

隆重介绍“??? 的第七分块”！！！

这题肯定是不弱于它的弱化版的，于是启发我们序列分块，设块长 $B=\sqrt n$。

分块后可以将询问拆分成一下部分：

1. 散块对散块的贡献。
2. 散块对整块的贡献。
3. 整块之间的贡献，即整块对整块。
4. 整块内部的贡献。
5. 散块内部的贡献。

散块贡献的计算显然暴力考虑每一个点对整块或散块的贡献，那么我们就来研究一下一个点对以一个区间 $[l,r]$ 的贡献，显然可以差分成 $[1,r]-[1,l-1]$。

我们顺序加入前 $i$ 个点，考虑怎么查询，我们需要知道有多少个数小于它，多少数大于它，可以考虑值域分块，这样加点 $O(\sqrt n)$，单次查询 $O(1)$，共 $O(m\sqrt n)$ 次查询，前两部分就解决啦。

接下来考虑整块内部的贡献，可以暴力预处理出来；
整块对整块的贡献，同样可以差分成区间前缀的答案，即 $[1,d]-[1,u-1]-[1,u-1]\times [u,d]$。

散块内部暴力可以用类似的想法，递归左右区间，差分贡献，具体看代码。

询问直接挂在每个前缀的位置查询，可以将空间优化到 $O(n)$，可以通过此题。

优化一下：

1. 预处理每个块内答案的时候记得离散化，不然时间会退化到 $O(n^2)$ 。
2. 对于暴力处理散块内部的贡献，可以加一点底层优化。

- code

```cpp
#include <bits/stdc++.h>
#define pii pair<int, int>
#define fi first
#define se second
#define ll long long
#define pb push_back
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
using namespace std;

namespace IO{
	char ibuf[(1 << 20) + 1], *iS, *iT;
	#if ONLINE_JUDGE
	#define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read () {
		reg char ch = gh();
		reg long long x = 0;
		reg char t = 0;
		while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
		return t ? -x : x;
	}
	inline void write(long long x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
}

using IO::read;
using IO::write;

const int maxn(1e5 + 50), maxm(2e5 + 50), maxk(325);
int n, m, sqn, len, a[maxn], b[maxn], id[maxn], ls[maxk], rs[maxk];
ll ans[maxm];

struct Block {
	int s[maxn], t[maxk];
	void clear () {
		memset(s, 0, sizeof(s));
		memset(t, 0, sizeof(t));
	}
	void add (int x) {
		for (int i = x; i <= rs[id[x]]; i++) s[i]++;//值域分块中的散块，块内贡献 
		for (int i = id[x] + 1; i <= len; i++) t[i]++;//值域分块中的整块 
	}
	inline int operator [] (const int &rhs) const {
		return s[rhs] + t[id[rhs]];//散块加整块 
	}
} B;

struct Node {
	int l, r, u, d;
} p[maxm];

struct qNode {
	int l, r, coef, id;
};
vector <qNode> q[maxn];
vector <pii> vec[maxn];

void SolvePoints () {
	for (int i = 1; i <= n; i++) {
		B.add(a[i]);//顺序加入前 i 个点 
		for (qNode &x : q[i]) {
			for (int j = x.l; j <= x.r; j++) {
				int u = p[x.id].u, d = p[x.id].d;
				if (a[j] < u || a[j] > d) continue;
				if (j > i) d = min(d, a[j] - 1);//分为 x1 < x2 和 x2 < x1，分别查询 y1 < y2 和 y1 > y2 
				else u = max(u, a[j] + 1);
				ans[x.id] += x.coef * (B[d] - B[u - 1]);
			}
		}
	}
}

void SolvePre () {//块与块之间的贡献 
	static ll s[maxk][maxk], c[maxk];
	for (int k = 1; k <= n; k++) {
		int i = b[k], t = 0;
		c[id[i]]++;
		for (int j = id[i] - 1; j; j--) t += c[j], s[j][id[i]] += t;//按 y 值从小到达加入，处理每个块前缀的答案 
		for (pii x : vec[k]) {
			int u = x.fi, l = id[p[u].l] + 1, r = id[p[u].r] - 1;
			for (int j = l + 1; j <= r; j++) ans[u] += s[l][j] * x.se; 
		}
	}
}

int t[maxm];
void SolveBlock () {//暴力处理块内答案 
	static int s[maxk][maxk], c[maxn];
	for (int i = 1; i <= len; i++) {
		int l = ls[i], r = rs[i];
		for (int j = 1; j <= n; j++) c[j] = c[j - 1] + (l <= b[j] && b[j] <= r);//离散化，只有 sqrt(n) 个点参与计算，卡空间 
		memset(s, 0, sizeof(s));
		for (int x = l; x <= r; x++) for (int y = x + 1; y <= r; y++) if (a[x] <= a[y]) s[c[a[x]]][c[a[y]]]++;
		for (int x = c[n]; x; x--) for (int y = x; y <= c[n]; y++) s[x][y] += s[x + 1][y] + s[x][y - 1] - s[x + 1][y - 1];//二维前缀和（后缀和） 
		for (int j = 1; j <= m; j++) {
			if (id[p[j].l] < i && i < id[p[j].r]) {
				ans[j] += s[c[p[j].u - 1] + 1][c[p[j].d]];//差分一下 
				ans[j] -= 1ll * t[j] * (c[p[j].d] - c[p[j].u - 1]);//-[1,u-1] * [u,d]
				t[j] += c[p[j].u - 1];//对每个块累计 [1,u-1] 
			}
		}
	}
}

int solve (int id, int l, int r, int u, int d) {
	if (r - l > 45) {//底层优化 
		int mid = (l + r) >> 1;
		q[l - 1].pb({mid + 1, r, -1, id});
		q[mid].pb({mid + 1, r, 1, id});//类似归并的计算过程 
		return solve(id, l, mid, u, d) + solve(id, mid + 1, r, u, d);
	}
	int ans = 0;//暴力处理答案，当 len <= 45 时 
	for (int i = l; i <= r; i++) if (u <= a[i] && a[i] <= d) for (int j = i + 1; j <= r; j++) ans += (a[i] <= a[j] && a[j] <= d);
	return ans;
}

int main () {
	n = read(), m = read(), sqn = sqrt(n), len = (n - 1) / sqn + 1;
	for (int i = 1; i <= n; i++) id[i] = (i - 1) / sqn + 1;
	for (int i = 1; i <= len; i++) ls[i] = rs[i - 1] + 1, rs[i] = i * sqn; rs[len] = n;
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= n; i++) b[a[i]] = i;
	for (int i = 1; i <= m; i++) {
		p[i] = {read(), read(), read(), read()};
		int p1 = id[p[i].l], p2 = id[p[i].r];
		if (p1 == p2) {
			ans[i] = solve(i, p[i].l, p[i].r, p[i].u, p[i].d);
			continue;
		}
		ans[i] = solve(i, p[i].l, rs[p1], p[i].u, p[i].d) + solve(i, ls[p2], p[i].r, p[i].u, p[i].d);//左右散块内部 
		q[p[i].l - 1].pb({ls[p2], p[i].r, -1, i});//右散块对前面区间的贡献 
		q[rs[p2 - 1]].pb({ls[p2], p[i].r, 1, i});
		if (p1 < p2 - 1) {
			q[rs[p1]].pb({p[i].l, rs[p1], -1, i});
			q[rs[p2 - 1]].pb({p[i].l, rs[p1], 1, i});//左散块对中间的贡献 
			vec[p[i].d].pb({i, 1});//整块对整块 
			vec[p[i].u - 1].pb({i, -1});
		}
	}
	SolvePoints();
	SolvePre();
	SolveBlock();
	for (int i = 1; i <= m; i++) write(ans[i]), puts("");
}
```

---

## 作者：Others (赞：0)

[多了个线性空间双倍经验](https://www.luogu.com.cn/problem/P6579)

我的做法常数是真大，但确实不用卡常，即使我把块长调成奇奇怪怪的东西也没有 $T$ 的冲动。

**前置知识：** 会离线， 会分块，最好做过[YLSTI](https://www.luogu.com.cn/problem/P5046)和[YLSTII](https://www.luogu.com.cn/problem/P5047)。

很多人说这是二维顺序对，但我的理解是有值域限制的区间顺序对（好像差不多），这东西和逆序对一样，五个贡献，**整块内，散块内，散块对散块，散块对整块，整块对整块。**

先讲点~~没用的~~：

两个区间的交叉的顺序对数，将两个区间里在对应值域内的数搞出来，排序，再跳双指针（参见归并排序）。

首先整最简单的**散块对散块和散块对整块**，根据 [YLSTII](https://www.luogu.com.cn/problem/P5047) 的做法，考虑将这个贡献离线下来，然后扫描一遍，在计算贡献时不仅查询时要查找指定值域内的，还要判断当前计算的值是不是在指定值域内的。这东西是整道题目里最简单的部分，从下面开始就有点鬼畜了。

**散块内**，开始是有和上面一起离线的想法，但是这样拆开就不是线性空间了。所以考虑另一个离线，我们枚举每个块，块内离散化，从左往右插入，维护一个 $f_{i,j}$ 表示值域上 $j$ 到 $i-1$ 对 $i$ 的贡献，因为从左到右枚举的，所以每次只需要更新小于它的数对它的贡献，然后在枚举到有离线询问的地方就查询：假设值域的上下界分别为 $s,t$ 那么就从 $s+1$ 枚举到 $t$，每次加上或减去 $f_{s,k}$，$k$ 为枚举到的值。我感觉我常数大就大在这里 qwq。

**整块内**就是直接挂在散块的端点处就行了，但是这里有个 bug：每个询问的散块只有两个，但整块有 $O(\sqrt n)$ 个。处理一个 $F_{i,j}$ 表示值在 $[i,j]$ 里的顺序对数，处理这个我们需要先搞 $g_{i,j}$ 表示值为 $i$ 的数对值为 $j$ 的数的顺序对贡献，$g_{i,j}$ 在处理 $f_{i,j}$ 的时候顺手整就行了。然后做一个像区间 dp 一样的东西就行了（这东西好像叫容斥）

$$
F_{i,j}=F_{i+1,j}+F_{i,j-1}-F{i+1,j-1}+g_{i,j}
$$

然后就是**整块对整块**，这个东西不好离散化，所以考虑值域上差分，我们将整个序列从小到大插入，每次插入时整个序列里的值域符合上面的前缀和条件（因为要差分），插入时因为序列里都是小于它的数，所以只需要枚举前面比它小的数，**注意：** 我们计算的是整块**间**的贡献，所以不能加上同块的贡献，这东西用一个序列分块维护就行了，这里我们处理时需要一个 $G_{i,j}$ 表示第 $i$ 块到第 $j-1$ 块对第 $j$ 块的贡献，在插入时更新就行了，~~这里好像用树状数组会更快~~。

最后，在上面差分时会有一个交叉的贡献，第 $i$ 块到第 $j-1$ 块对第 $j$ 块的交叉贡献就是第 $i$ 块到第 $j-1$ 块里 $[1,s-1]$ 里的数的个数乘上第 $j$ 块里 $[s,t]$ 里的数的个数，前面的对于每个询问是不同的，所以我们维护 $tot_i$ 表示到当前枚举的这个块第 $i$ 个询问小于 $s$ 的数的个数。从小到大枚举每个块，维护值域的前缀和，再遍历每个询问，如果这个块在询问的整块里就将答案减去 $tot_i\times(sum_t-sum_{s-1})$，然后把 $sum_{s-1}$ 加入 $tot_i$。

最后的最后，把询问分类一下：

1. 同块：差分成两个散块的贡献之差再减去左边空区间和询问区间的交叉顺序对贡献，记得特判端点在不在块的端点，如果是，那就是一个散块的贡献。
2. 两个端点在相邻块，分解成两个散块的贡献加上两个散块的交叉顺序对数。
3. 询问包含整块，最平凡的一种，暴力即可。

**Code**

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
template<typename zqw>void qr(zqw &x) {
	bool f=x=0;
	char c=getchar();
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	x=f?~(x-1):x;
	return ;
}
const int N=100005,sn=1005;
int idx[N],sum1[N],sum2[N],L[sn],n,m,s,bls,R[sn],a[N],cnt,ccnt,flag[sn],Pos[N],c[N],sum[sn],id[N],Tot[N<<1];
ll ans[N<<1],F[sn][sn],f[sn][sn];
struct STO_LXL_Orz{int id,op,L,R;};
vector<STO_LXL_Orz> LXL[N];
struct Query{
	int x,id;
	bool operator<(const Query &p)const{return x<p.x||(x==p.x&&id<p.id);}
}b[N]; 
struct query{
	int l,r,s,t,id,L,R;
	bool operator<(const query &p)const{return L==p.L?R<p.R:L<p.L;}
}p[N<<1];
struct node{
	int l,r,x,s,t,id,op,typ;
	bool operator<(const node &p)const{return x<p.x;}
}Q[N<<3];
struct Node{
	int x,s,t,id,typ,op;
	bool operator<(const Node &p)const{return idx[x]==idx[p.x]?(typ==p.typ?(typ?x>p.x:x<p.x):typ<p.typ):idx[x]<idx[p.x];}
}P[N<<2];
inline int ask(int l,int r) {return l&&r&&l<=r?sum2[idx[r]-1]-sum2[idx[l]-1]+sum1[r]-(l==L[idx[l]]?0:sum1[l-1]):0;}
inline int merge(int l1,int r1,int l2,int r2,int s,int t) {
	vector<int> op1,op2;
	for(int i=L[idx[l1]];i<=R[idx[l1]];i++) if(l1<=b[i].id&&b[i].id<=r1&&s<=b[i].x&&b[i].x<=t) op1.push_back(i);
	for(int i=L[idx[l2]];i<=R[idx[l2]];i++) if(l2<=b[i].id&&b[i].id<=r2&&s<=b[i].x&&b[i].x<=t) op2.push_back(i);
	int i=0,j=0,top1=op1.size(),top2=op2.size(),tot=0;
	while(i<top1&&j<top2) {
		if(b[op1[i]].x<b[op2[j]].x) i++,tot+=top2-j;
		else j++;
	}
	return tot;
}
int main() {
	qr(n),qr(m),s=sqrt(n),bls=(n+s-1)/s;
	for(int i=1;i<=bls;i++) {
		L[i]=R[i-1]+1,R[i]=min(n,s*i);
		for(int j=L[i];j<=R[i];j++) idx[j]=i;
	}
	for(int i=1;i<=n;i++) qr(a[i]),b[i].x=a[i],b[i].id=i,id[a[i]]=i;
	for(int i=1;i<=bls;i++) sort(b+L[i],b+R[i]+1);
	for(int i=1;i<=m;i++) {
		qr(p[i].l),qr(p[i].r),qr(p[i].s),qr(p[i].t),p[i].id=i,p[i].L=idx[p[i].l]+1,p[i].R=idx[p[i].r]-1;
		LXL[p[i].s-1].push_back((STO_LXL_Orz){i,-1,p[i].L,p[i].R}),LXL[p[i].t].push_back((STO_LXL_Orz){i,1,p[i].L,p[i].R});
		if(p[i].L<=p[i].R) {
			Q[++cnt]=(node){p[i].l,R[idx[p[i].l]],R[idx[p[i].l]],p[i].s,p[i].t,p[i].id,-1,1};
			Q[++cnt]=(node){p[i].l,R[idx[p[i].l]],p[i].r,p[i].s,p[i].t,p[i].id,1,1};
			Q[++cnt]=(node){L[idx[p[i].r]],p[i].r,R[idx[p[i].l]],p[i].s,p[i].t,p[i].id,-1,0};
			Q[++cnt]=(node){L[idx[p[i].r]],p[i].r,L[idx[p[i].r]]-1,p[i].s,p[i].t,p[i].id,1,0};
			P[++ccnt]=(Node){p[i].l,p[i].s,p[i].t,p[i].id,1,1};
			P[++ccnt]=(Node){p[i].r,p[i].s,p[i].t,p[i].id,0,1};
		} else if(idx[p[i].l]==idx[p[i].r]) {
			if(p[i].l==L[idx[p[i].l]]) P[++ccnt]=(Node){p[i].r,p[i].s,p[i].t,p[i].id,0,1};
			else {
				if(p[i].r==R[idx[p[i].r]]) P[++ccnt]=(Node){p[i].l,p[i].s,p[i].t,p[i].id,1,1};
				else {
					ans[i]-=merge(L[idx[p[i].l]],p[i].l-1,p[i].l,p[i].r,p[i].s,p[i].t);
					P[++ccnt]=(Node){p[i].l-1,p[i].s,p[i].t,p[i].id,0,-1};
					P[++ccnt]=(Node){p[i].r,p[i].s,p[i].t,p[i].id,0,1};
				}
			}
		} else {
			ans[i]+=merge(p[i].l,R[idx[p[i].l]],L[idx[p[i].r]],p[i].r,p[i].s,p[i].t);
			P[++ccnt]=(Node){p[i].l,p[i].s,p[i].t,p[i].id,1,1};
			P[++ccnt]=(Node){p[i].r,p[i].s,p[i].t,p[i].id,0,1};
		}
	}
	sort(p+1,p+m+1);
	sort(Q+1,Q+cnt+1);
	sort(P+1,P+ccnt+1);
	for(int i=1,idxn=0;i<=cnt;i++) {
		while(idxn<Q[i].x) {
			++idxn;
			for(int j=a[idxn];j<=R[idx[a[idxn]]];j++) ++sum1[j];
			for(int j=idx[a[idxn]];j<=bls;j++) ++sum2[j];
		}
		for(int j=Q[i].l;j<=Q[i].r;j++) {
			if(a[j]<Q[i].s||a[j]>Q[i].t) continue;
			ans[Q[i].id]+=Q[i].op*(Q[i].typ?ask(a[j]+1,Q[i].t):ask(Q[i].s,a[j]-1));
		}
	}
	for(int i=1,idxn=1,pos=0;i<=bls;i++,pos=0) {
		for(int j=L[i];j<=R[i];j++) flag[++pos]=a[j];
		sort(flag+1,flag+pos+1);
		for(int j=1,Lxl=0,lst=0;j<=n;j++) Pos[j]=lst,lst=(j==flag[Lxl+1]?++Lxl:lst);
		for(int j=L[i];j<=R[i];j++) c[j]=lower_bound(flag+1,flag+pos+1,a[j])-flag;
		for(int j=L[i];j<=R[i];j++) {
			for(int k=c[j]-1;k;k--) f[c[j]][k]+=sum[c[j]-1]-sum[k-1];
			for(int k=c[j];k<=pos;k++) ++sum[k];
			while(idxn<=ccnt&&P[idxn].typ==0&&P[idxn].x==j) {
				for(int k=(flag[Pos[P[idxn].t]+1]==P[idxn].t?Pos[P[idxn].t]+1:Pos[P[idxn].t]),lxl=Pos[P[idxn].s]+1;k>lxl;k--) ans[P[idxn].id]+=P[idxn].op*f[k][lxl];
				idxn++;
			}
		}
		memset(sum,0,sizeof(sum)),memset(f,0,sizeof(f));
		for(int j=R[i];j>=L[i];j--) {
			for(int k=c[j]+1;k<=pos;k++) f[k][c[j]]+=sum[k]-sum[c[j]];
			for(int k=c[j];k<=pos;k++) ++sum[k];
			while(idxn<=ccnt&&P[idxn].typ==1&&P[idxn].x==j) {
				for(int k=Pos[P[idxn].s]+1,lxl=flag[Pos[P[idxn].t]+1]==P[idxn].t?Pos[P[idxn].t]+1:Pos[P[idxn].t];k<lxl;k++) ans[P[idxn].id]+=P[idxn].op*f[lxl][k];
				idxn++;
			}
		}
		memset(sum,0,sizeof(sum)),memset(f,0,sizeof(f));
	}
	for(int i=1,tmp,Id;i<=n;i++) {
		++sum[idx[id[i]]],tmp=0,Id=idx[id[i]];
		for(int j=Id-1;j;j--) tmp+=sum[j],F[j][Id]+=tmp;
		for(auto &dx:LXL[i]) {
			for(int j=dx.L+1;j<=dx.R;j++) {
				ans[dx.id]+=F[dx.L][j]*dx.op;
			}
		}
	}
	for(int i=1;i<=bls;i++) {
		memset(F,0,sizeof(F));
		for(int j=1;j<=n;j++) sum[j]=sum[j-1]+(L[i]<=id[j]&&id[j]<=R[i]);
		for(int j=1;j<=m;j++) {
			if(p[j].L<i&&i<=p[j].R) ans[p[j].id]-=Tot[j]*(sum[p[j].t]-sum[p[j].s-1]);
			if(p[j].L<=i&&i<=p[j].R) Tot[j]+=sum[p[j].s-1];
		}
		for(int j=L[i];j<=R[i];j++) for(int k=j+1;k<=R[i];k++) F[sum[a[j]]][sum[a[k]]]+=(sum[a[j]]<sum[a[k]]);
		for(int len=2;len<=R[i]-L[i]+1;len++) for(int j=1,k=j+len-1;k<=R[i]-L[i]+1;j++,k++) F[j][k]+=F[j+1][k]+F[j][k-1]-F[j+1][k-1];
		for(int j=1;j<=m;j++) (p[j].L<=i&&i<=p[j].R)&&(ans[p[j].id]+=F[sum[p[j].s-1]+1][sum[p[j].t]]);
	}
	for(int i=1;i<=m;i++) printf("%lld\n", ans[i]);
	return 0;
}
```

---


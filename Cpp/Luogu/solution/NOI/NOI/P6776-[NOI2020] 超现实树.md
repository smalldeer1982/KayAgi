# [NOI2020] 超现实树

## 题目背景

下课铃声响起，机房里的两位女生从座位上站起来。（下面用 $\mathbf{X1}$, $\mathbf{X2}$ 代指两人）

$\mathbf{X2}$：省选前的集训真难熬啊…… 听课、考试、讲评、补题 —— 对于现在的我来说，即使在梦里想到一道数据结构题，也会不由自主地开始思考吧。

$\mathbf{X1}$：重复训练对我来说似乎并不是什么负担，但我确实感觉到解决题目带来的愉悦感在最近逐渐减弱了。也许我们需要一些精神上的 “刺激”：一些不拘泥于繁复技术的智力游戏，来让我们找回对于数学和算法的兴趣。

$\mathbf{X2}$：咦，我好像收到了一封用英文写的短信，似乎是…… 数学书上的一些片段。

## 题目描述

$\mathbf{X1}$：我来翻译一下短信的内容。

> 定义：本文所述的树是归纳定义的：单独的结点构成一棵树，以一棵树作为左（或右）孩子可以构成一棵树，以两棵树分别作为左、右孩子也可以构成一棵树。仅由以上规则用有限步生成的所有结构被称为树。

$\mathbf{X2}$：也就是说，这里所说的树是指**非空、有根、区分左右孩子的二叉树**。

$\mathbf{X1}$：的确如此。接下来书上定义了两棵树的同构。

> 定义：称两棵树 $T$, $T^{\prime}$ 同构，记做 $T \equiv T^{\prime}$，由以下四条规则定义：
> 1. 由单独结点构成的树是彼此同构的；
> 2. 如果两棵树的根结点均只有左子树，并且它们的左子树同构，那么这两棵树是同构的；
> 3. 如果两棵树的根结点均只有右子树，并且它们的右子树同构，那么这两棵树是同构的；
> 4. 如果两棵树的根结点均有左、右子树，并且它们的左、右子树分别对应同构，那么这两棵树是同构的。
> 
> 很明显，同构关系构成了所有树上的一个等价关系。为了方便，我们将同构的树看作相同的树。

$\mathbf{X2}$：将同构的树看成相同的树就是说树的结点是彼此相同的。简单地说，两棵树同构当且仅当**他们在结点无标号、区分左右孩子的意义下相同**；我们说两棵树不同，当且仅当它们不同构。

$\mathbf{X1}$：书里还定义了树的**叶子**：和通常的定义一样，叶子指**没有任何孩子的结点**。

$\mathbf{X2}$：这和我们熟悉的定义完全一致。嘛，数学家真是有点啰嗦…… 恐怕只有 $\mathbf{X3}$ 那种家伙会喜欢这种做派吧。

$\mathbf{X1}$：我倒是对此不太反感 —— 比起基于经验的 “直觉”，准确的定义和严谨的证明还是更加让人安心。你看，下一个定义就没有那么直观了。

> 定义：称一棵树 $T$ **单步替换**成为 $T^{\prime}$，如果将 $T$ 的某一**叶子结点**替换为另一棵树 $T^{\prime \prime}$ 得到的树与 $T^{\prime}$ 同构，记做 $T \rightarrow T^{\prime}$；称一棵树 $T$ **替换**成为 $T^{\prime}$，记做 $T \rightarrow^{\star} T^{\prime}$，如果存在自然数 $n \geq 1$ 和树 $T_{1}, T_{2}, \ldots, T_{n}$，使得 $T \equiv T_{1} \rightarrow T_{2} \rightarrow \cdots \rightarrow T_{n} \equiv T^{\prime}$。

$\mathbf{X2}$：我来想想…… 所谓替换，就是删掉某个叶子结点并在对应的位置放入另一棵树，就像那个叶子结点 “长出了” 一个更大的子树一样；一棵树替换成为另一棵树，说明它可以经由**零次、一次或多次**单步替换得到那棵树。哦…… 我明白了！举例来说，任何一棵树都可以替换成它本身，换言之对于树 $T$，都有 $T \rightarrow^{\star} T^{\prime}$。下面这个图片可以帮助理解单步替换和替换的含义。

![img](https://cdn.luogu.com.cn/upload/image_hosting/0o4pfqui.png)

$\mathbf{X1}$：你说得对。特别地，任何一棵树都可以替换得到无穷多棵不同的树，并且仅有一个结点构成的树可以替换得到任意其他的树。书上也有定义这样的东西。

> 定义：对于一棵树 $T$，定义 $\operatorname{grow}(T)$ 表示 T 所能替换构成的树的集合，即 $\operatorname{grow}(T)=\left\{T^{\prime} \mid T \rightarrow^{\star} T^{\prime}\right\}$。更近一步，如果 $\mathscr{T}=\left\{T_{1}, T_{2}, \ldots, T_{n}\right\}$ 是一个树的有限集合，定义 $\operatorname{grow}(\mathscr{T})$ 为所有 $\operatorname{grow}\left(T_{i}\right)$ 的并集，其中 $i=1,2, \ldots, n$。即 
> $$\operatorname{grow}(\mathscr{T})=\bigcup_{T_{i} \in \mathscr{T}} \operatorname{grow}\left(T_{i}\right)$$

$\mathbf{X2}$：我们把 $\operatorname{grow}(\mathscr{T})$ 称作树的集合 $\mathscr{T}$ **所生长得到的集合**吧 —— 也就是说，树的集合 $\mathscr{T}$ 所生长得到的集合包含所有可以被某个 $T \in \mathscr{T}$ 替换得到的树。不妨把树的集合叫做**树林**。不太严谨地说，一个树林所生长得到的新树林就是其中所有树、以所有可能的方式生长得到的树林。显而易见，一个非空树林所生长得到的树林都是无穷树林。但这个无穷树林，或者说 $\operatorname{grow}(\mathscr{T})$，并不一定包含所有的树 —— 更进一步，它甚至不一定包含 “几乎所有” 的树。

$\mathbf{X1}$：让我来补充一下：我们称一个树林是**几乎完备**的（或称**几乎包含了所有的树**），如果仅有有限多的树不在其中。对于一个有限树林 $\mathscr{T}$，$\operatorname{grow}(\mathscr{T})$ 要么包含了所有的树，要么包含了几乎所有的树，要么存在无穷多棵树不在其中。如果这是一道 OI 题，出题人一定会**在样例中给出三种情况的例子**吧。书上的关键定理也用了和我们相同的定义。

> **定理**（**几乎完备的可判定性**）：一个树的集合是**几乎完备**的，如果仅有有限棵树不在其中。那么，对于一个给定的树的有限集合 $\mathscr{T}$，存在高效的算法判定 $\operatorname{grow}(\mathscr{T})$ 是否是几乎完备的。

$\mathbf{X2}$：这个问题变成一个纯粹的 OI 题目了！让我用我们的语言来重述一下题意：**给定一个有限大小的树林 $\mathscr{T}$，判定 $\operatorname{grow}(\mathscr{T})$ 是否是几乎完备的，即是否仅有有限棵树不能被树林中所包含的树生长得到**。

$\mathbf{X1}$：也就是说，给定一个有限的树的集合 $\mathscr{T}$，判定是否仅有有限个树 $T$，满足 $T \notin \operatorname{grow}(\mathscr{T})$。所谓 $T \notin \operatorname{grow}(\mathscr{T})$，就是说不存在 $T^{\prime} \in \mathscr{T}$，使得 $T^{\prime} \rightarrow^{\star} T$。这和通常的 OI 题目的确非常不同：我甚至没有想到这个问题的一个算法。

$\mathbf{X2}$：我也一样，不过我很久没有感受到这种解决未知问题的冲动了。

## 说明/提示

#### 样例 2 解释
这一样例仅包含一组测试数据，其中树的集合 $\mathscr{T}$ 包含三棵树，如下图所示。容易发现，仅有单个结点构成的树不在 $\operatorname{grow}(\mathscr{T})$ 中，其包含了几乎所有树，因而是几乎完备的。

![img2](https://cdn.luogu.com.cn/upload/image_hosting/394s081s.png)

#### 样例 3 解释
这一样例仅包含一组测试数据，其中树的集合 $\mathscr{T}$ 包含两棵树。容易发现，对于所有的 $n \geq 2$，包含 $n$ 个结点，每个非叶结点仅有右孩子的链状树都不在 $\operatorname{grow}(\mathscr{T})$ 中，因而存在无穷多棵树不在 $\operatorname{grow}(\mathscr{T})$ 中，$\mathscr{T}$ 不是几乎完备的。

#### 样例 4
见选手目录下的 surreal/surreal4.in 与 surreal/surreal4.ans。

---

### 测试点约束

**全部数据满足**：$\sum n \leq 2 \times 10^{6}$， $\sum m \leq 2 \times 10^{6}$， $\max h \leq 2 \times 10^{6}$， $N \leq 10^{2}$。其中，$\sum n$ 表示这一测试点所有测试数据中所出现的所有树的结点个数之和；$\sum m$ 表示这一测试点中所有测试数据中所出现的树的个数；$\max h$ 表示这一测试点中所出现的所有树的最高高度（仅包含一个结点的树高度为 $1$）。下表中的表项 $\sum n$，$\sum m$ 和 $\max h$ 含义与上面相同，描述了每一组测试点的数据范围。

**特殊性质**：下面是下表中会涉及的四种特殊性质的解释。
- 特殊性质 $1$：对于这一测试点中的每一组测试数据，都有 $m \leq 4$，即树的集合中包括不超过 $4$ 棵树；
- 特殊性质 $2$：对于这一测试点中的每一组测试数据，树的集合中所有的树具有相同的高度；
- 特殊性质 $3$：对于这一测试点中的每一组测试数据，树的集合仅包含链（换言之，每个非叶结点仅包含一个孩子）；
- 特殊性质 $4$：对于这一测试点中的每一组测试数据，树的集合仅包含满足以下两个条件之一的树：
  - 每个非叶结点仅包含一个孩子；
  - 恰好有两个叶结点，它们具有相同的父结点，并且除这三个结点外，其余结点均有且仅有一个孩子。

每个测试点的具体限制见下表：

| 测试点编号 |  $N$ |  $\sum n$ |  $\sum m$ |  $\max h$ | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |:-:  |
|  $1$ |  $100$ |  $\le 10^3$ |  $\le 10^3$ |  $\le 1$ | 无 |
|  $2\sim 3$ |  $100$ |  $\le 10^3$ |  $\le 10^3$ |  $\le 2$ | 性质  $1$ |
|  $4$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 4$ | 无 | 
|  $5$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 5$ | 性质  $2$ | 
|  $6$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 8$ | 无 | 
|  $7$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 9$ | 性质  $2$ | 
|  $8$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 10$ | 无 | 
|  $9$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 10^6$ | 性质  $3$ | 
|  $10$ |  $20$ |  $\le 10^3$ |  $\le 100$ |  $\le 10^3$ | 性质  $4$ | 
|  $11$ |  $20$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ | 性质  $4$ | 
|  $12$ |  $20$ |  $\le 10^5$ |  $\le 10^5$ |  $\le 10^5$ | 性质  $4$ | 
|  $13$ |  $20$ |  $\le 2\times 10^5$ |  $\le 2\times 10^5$ |  $\le 2\times 10^5$ | 性质  $4$ | 
|  $14$ |  $20$ |  $\le 800$ |  $\le 200$ |  $\le 800$ | 无 |
|  $15$ |  $20$ |  $\le 10^3$ |  $\le 100$ |  $\le 10^3$ | 无 |
|  $16$ |  $20$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ | 无 |
|  $17$ |  $40$ |  $\le 3\times 10^5$ |  $\le 3\times 10^5$ |  $\le 3\times 10^5$ | 无 |
|  $18$ |  $40$ |  $\le 6\times 10^5$ |  $\le 6\times 10^5$ |  $\le 6\times 10^5$ | 无 |
|  $19$ |  $40$ |  $\le 9\times 10^5$ |  $\le 9\times 10^5$ |  $\le 9\times 10^5$ | 无 |
|  $20$ |  $40$ |  $\le 1.2\times 10^6$ |  $\le 1.2\times 10^6$ |  $\le 1.2\times 10^6$ | 无 |
|  $21$ |  $40$ |  $\le 1.5\times 10^6$ |  $\le 1.5\times 10^6$ |  $\le 1.5\times 10^6$ | 无 |
|  $22\sim 25$ |  $40$ |  $\le 2\times 10^6$ |  $\le 2\times 10^6$ |  $\le 2\times 10^6$ | 无 |

## 样例 #1

### 输入

```
1
1
1
0 0```

### 输出

```
Almost Complete```

## 样例 #2

### 输入

```
1
3
3
2 3
0 0
0 0
2
2 0
0 0
2
0 2
0 0```

### 输出

```
Almost Complete```

## 样例 #3

### 输入

```
1
2
3
2 3
0 0
0 0
2
2 0
0 0```

### 输出

```
No```

# 题解

## 作者：ix35 (赞：60)

（摘自 [NOI 2020 翻盘记](https://www.luogu.com.cn/blog/ix-35/noi-2020-fan-pan-ji)）

本人赛时 AC，但是没拷代码，先写一下解法，有空补代码，填补一下题解的空白。

讲题主要讲了合并的思路，但是我用的是分治的思路。

**观察 $1$**：如果一棵树每个点的左右儿子 size 的 $\min$ 不超过 $1$，那么称为好树，则一旦仅有有限多个好树不在 $\operatorname{grow}(\mathcal{T})$ 中，那么树林 $\mathcal{T}$ 便是几乎完备的。

证明非常简单，因为任何一棵树 $T$ 可以由深度相等的一棵好树长出，所以只要一定深度以上的好树都能被生成，那么这个深度以上的所有树都能被生成。

**观察 $2$**：如果输入的一棵树不是好树，那么它便无用。

证明：非不能长出好树，所以它对长出好树没有任何帮助，根据观察 $1$，我们只关心好树能否被长出，它自然就无用了。

这告诉我们，如果只保留有效的树，那么对于每一个结点，向下递归不可能同时递归左右子树，因为至少有一个是大小不超过 $1$ 的平凡情况。

因此递归可以考虑，设 $solve(\mathcal{T})$ 表示判定树林 $\mathcal{T}$ 是否几乎完备，将其中的树分成四类：

1. 根只有左儿子；

2. 根只有右儿子；

3. 根有左右儿子且左儿子大小为 $1$；

4. 根有左右儿子且右儿子大小为 $1$；

（3.4 可能有唯一交集，但问题不大）

对于 $1,2$，直接递归其左/右儿子即可。

对于 $3,4$，对应递归相反方向（即较大的一边）的儿子即可。

如果四种情况全部几乎完备，则原树林几乎完备；特殊地，如果 $\mathcal{T}$ 中存在单点，则直接返回几乎完备。

考虑证明上面断言的正确性：

所有可能的好树仅有上面四种，并且分别可以利用上面说的四种情况的树生成，所以只要四种树都分别几乎完备，则原树林几乎完备；反之如果有一种树不几乎完备，那么就可以构造无穷多的反例。

由于每个树最多被递归深度次，根据讲课时讲师的分析，在卡满情况下深度仅能到达 $O(\sqrt n)$，那估计复杂度是线性的了。

---

## 作者：Karry5307 (赞：42)

### 题意

定义树 $T^{\prime}$ 能被树 $T$ 单步替换得来，当且仅当将 $T$ 的某个叶子替换成一棵二叉树之后与 $T^{\prime}$ 同构，记作 $T\leadsto T^{\prime}$。

定义树 $T^{\prime}$ 能被树 $T$ 生成当且仅当单步替换链 $T\leadsto T_1\leadsto\cdots\leadsto T_n$ 存在，记作 $T\to T^{\prime}$。同时记 $\text{grow}(T)=\{T^{\prime}\mid T\to T^{\prime}\}$。

对于若干二叉树组成的集合 $\mathscr{T}$ 来说，定义 $\text{grow}(\mathscr{T})$ 为：

$$\text{grow}(\mathscr{T})=\bigcup\limits_{T\in\mathscr{T}}\text{grow}(T)$$

$T$ 组数据，每组数据给定 $n$ 棵二叉树的集合 $\mathscr{T}$，你需要确定 $\text{grow}(\mathscr{T})$ 是否是完备的，也即是否有有限棵二叉树不属于 $\text{grow}(\mathscr{T})$。

$\texttt{Data Range:}\sum n\leq 2\times 10^6$

### 题解

此题牛逼！

记 $h(T)$ 表示 $T$ 的高度，定义 $B_n$ 表示高度为 $n$ 的所有二叉树的基底。$B_n$ 中的树 $T$ 需要满足以下两个条件：

- $h(T)=n$。

- 不存在 $T^{\prime}$ 满足 $h(T^{\prime})=n$ 且 $T^{\prime}\to T$。

比如说，$B_2$ 由以下三棵树组成：仅有根节点和左子树的，仅有根节点和右子树的，根节点和两个子树都有的。

多手玩几个你会发现属于 $B_n$ 的树有一个共同的特点：**由一条长度为 $n$ 的链和一些附着在链上的单个节点所组成**，我们把这种树叫做**链树**。

现在我们证明这些 $B_n$ 内的所有链树一定能够生成出所有高度为 $n$ 的树。对于每一棵高度为 $n$ 的树 $T$ 而言都会有一条长度为 $n$ 且从根节点往下的链，这个时候我们让 $T^{\prime}$ 也拥有这条链。对于 $T$ 中链上的非叶节点来说，有一个儿子在链上，如果另一边没有儿子则不操作，否则将 $T^{\prime}$ 对应的位置加入一个叶子。很明显 $T^{\prime}$ 为链树且 $T^{\prime}\to T$。一个例子可以参考下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/iw82aha7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/habh7s2x.png)

很明显，上面那棵树中有链 $1\to 2\to 6$，所以将其保留下来。对于 $1$ 来说，非链的另一侧子树（也即以 $3$ 为根的子树）非空，所以新树中只留下 $1$ 的直接儿子 $3$，对于 $2$ 来说也一样，最终得到下面的树。

同时可以证明 $B_n$ 中的任意一棵树不能生成其他树，这个很简单。

注意到一个性质：对于 $u>v$ 来说，$B_u\subseteq \text{grow}(B_v)$。翻译成人话也就是所有高度为 $u$ 的链树能被所有高度为 $v$ 的链树生成。

不仅如此，还有一个性质是非链树不可以生成链树，因为生成操作不会导致树的基础形态改变。这也就意味着一堆非链树组成的集合一定是不完备的，相当于非链树答案没有影响。依靠这三个性质，我们可以证明只有所有链树是有用的。（也即非链树不能生成链树，而链树可以生成更高的链树从而生成更高的非链树）

现在我们将所有 $\mathscr{T}$ 内的非链树剔除掉，并且将所有链树合并。对于链树上的一个非叶节点 $u$，存在四种情况：

- $u$ 的左子树为空，右子树不为空。

- $u$ 的右子树为空，左子树不为空。

- $u$ 的左子树为一条链上的节点，右子树为叶子。

- $u$ 的右子树为一条链上的节点，左子树为叶子。

对于上图链树中的 $2$ 我们认为同时满足后两种情况。将这些情况编码为 $0,1,2,3$，就可以用一棵四叉树来表示所有链树了。

我们定义四叉树上的节点 $u$ 是完备的当且仅当只有有限棵树不能被 $u$ 子树生成，那么很明显 $u$ 是完备的必须满足下面两个条件之一：

- $u$ 是某一棵树的叶节点。

- $u$ 的所有子树是完备的。

这个可以简单搜一下，最后只要看根节点是否是完备的即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e6+51;
ll test,n,m,totn,rt;
ll ls[MAXN],rs[MAXN],c[MAXN],ch[MAXN][4];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll chk(ll x)
{
	return !ls[x]&&!rs[x];
}
inline ll check(ll x)
{
	if(chk(x)||(!ls[x]&&check(rs[x]))||(!rs[x]&&check(ls[x])))
	{
		return 1;
	}
	return (chk(ls[x])&&check(rs[x]))||(chk(rs[x])&&check(ls[x]));
}
inline void merge(ll &cur,ll x)
{
	!cur?cur=++totn:1;
	if(chk(x))
	{
		return (void)(c[cur]=1);
	}
	!rs[x]?merge(ch[cur][0],ls[x]):(void)1;
	!ls[x]?merge(ch[cur][1],rs[x]):(void)1;
	ls[x]&&rs[x]&&chk(rs[x])?merge(ch[cur][2],ls[x]):(void)1;
	ls[x]&&rs[x]&&chk(ls[x])?merge(ch[cur][3],rs[x]):(void)1;
}
inline ll grow(ll x)
{
	if(!x||c[x])
	{
		return !!x;
	}
	return grow(ch[x][0])&&grow(ch[x][1])&&grow(ch[x][2])&&grow(ch[x][3]);
}
inline void solve()
{
	n=read(),rt=totn=0;
	for(register int i=1;i<=n;i++)
	{
		m=read();
		for(register int j=1;j<=m;j++)
		{
			ls[j]=read(),rs[j]=read();
		}
		check(1)?merge(rt,1):(void)1;
	}
	puts(grow(1)?"Almost Complete":"No");
	for(register int i=1;i<=totn;i++)
	{
		ch[i][0]=ch[i][1]=ch[i][2]=ch[i][3]=c[i]=0;
	}
}
int main()
{
	test=read();
	for(register int i=0;i<test;i++)
	{
		solve();
	}
}
```

---

## 作者：mikechu (赞：17)

前置技能：宣传[博客链接](https://www.luogu.com.cn/problem/P6776)

# 前言

作为一个APIO只能得40分的蒟蒻，参加了NOI结果也是非常的惨，具体就不提了。

Day2 T2 超现实树是一道我思考了很多的题，Day2的大部分时间花在上面。但我依旧没有得到正解。于是，在赛后，查了题解，又思考了很久，终于想明白了。些这篇题解主要是帮助和我刚开始陷入了同样的思维怪圈，因此一直没想明白这题的人。

# 思路与证明

 1. 考虑证明：在所有可能被生成或输入的树中，只有一种树需要被考虑到，称之为“链树”。它满足 $min(size[ls],size[rs])<=1$,也就是左右子树大小的最小值不超过1，可以理解为一条链上长出若干个叶子结点（当然，也可以是0个叶子结点）。
 2. 满足了上面的性质，就只需要考虑输入数据中的链树了，也只需要设法生长得到无数棵链树即可。



## 第一部分 证明只有链树是有用的

 1. 证明输入的数据中我们只需要使用链树，其余的可以忽略。
 2. 证明$grow(T)$是几乎完备的，等价于只有有限个链树不可以被生长得到。

第一条 证明：
 假如有一棵树不是链树，那么可以它的左子树或右子树砍掉使它成为一棵链树，那么这棵链树可以通过生长它没被砍掉的那个子树上的链树，从而得到无数棵原树所不能得到的树（链树）。由于本来就有无数棵树不能被生长得到，现在还有无数棵树不能被生长得到，所以得出这棵树没有任何贡献的结论。

一开始我总是想不通这个结论，还举出了这个反例：
![029.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDUvZll3VUEzYmxHNTd4TnZpLnBuZw?x-oss-process=image/format,png)

![031.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDUvckpGM0Viakl3cTRTQU10LnBuZw?x-oss-process=image/format,png)

![032.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDUvQmZud094Y0lNdUpYRlRoLnBuZw?x-oss-process=image/format,png)


显然这三棵树都不是链树。我们来看看它们共同对应的链树。
![030.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDUvbFQ5TWptUklmRng3aVoxLnBuZw?x-oss-process=image/format,png)

看上去，这三棵树似乎可以完全取代他们砍掉一半成为的链树，但其实他们不行。看这最后一棵树，结点4和3是叶子结点，可以生长。这棵树从4和3生长出去的所有树都是前三棵树所不能长出的。有无数棵树（链树）是不能得到的。
综上，可以说任何结构，任何数量的非链树的树，都比不上一颗链树，因为链树有无数颗非链树所不能生长得到的树（链树）。

第二条 先从无限颗树不在$grow(T)$中推出无限棵链树不在$grow(T)$中，从无限颗链树不在$grow(T)$中推出无限棵树不在$grow(T)$中，总而证明等价关系。

假设无限棵树不在$grow(T)$，把每一棵树$T$的左或右子树砍掉，或换成一个叶子结点，得出的这棵树$T’$只会比原树更难长出，不会更容易生成。具体地说，如果有一棵树$T_1$可以生长出$T’$，$T_1$也一定可以生长出$T$。而如果$T_1$可以生长出$T$，$T_1$却不一定可以生长出$T’$，因此我们可以证明，有无数棵链树不在$grow(T)$中。

假设无限棵链树不在$grow(T)$，由于链树也是一种树，所以就有无数棵树不在$grow(T)$，得证。
综上，第二条得证。

## 第二部分 只处理链树，设法生成无限颗链树。
如果是对树这方面有些感觉的人，到了这一步大概就觉得能做了。这里具体地说一下：

### 思路：
考虑把所有的链树放到一颗满二叉树上，尽量覆盖到所有情况。如果真的覆盖到了，那就好像“逮住”了根节点一样，就不会有大小为无限的树（链树）从缝隙中逃走。。。
~~这个思路你大概是看不懂讲了什么的，因为这只是我对这道题第二部分大概怎么做的一个感性认识~~


#### 具体思路：
如图，把所有的链树放到这棵满二叉树上。

![034.png](https://i.loli.net/2020/09/18/FTNwAubx8UIfVpo.png)

让我们看看之前的那棵链树
 
![030.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDUvbFQ5TWptUklmRng3aVoxLnBuZw?x-oss-process=image/format,png)

变成这个样子：
![035.png](https://i.loli.net/2020/09/18/IXGTkapeBRWoPKO.png)

把这棵树投射到大的满二叉树上，首先要保证没有信息丢失。那吗来考虑一下如何对这颗链树进行编码。

就刚才那颗链树，有两种编码方式：

 1. 从根节点出发，向右，向右，其中两次都挂载了另一个子结点。
 2. 从根节点出发，向右，向左，其中两次都挂载了另一个子结点。
 
注意：假如链树长成这个样子：

![035.png](https://i.loli.net/2020/09/18/IXGTkapeBRWoPKO.png)

那么，我们不可以把它描述为“向右，向左，三次都挂载了子结点”。因为这样说不能确定这个5号结点在左边还是右边，丢失了信息，是不可行的。同时，这样也会导致更多的重复。
舍去了这种情况，剩下的唯一一种重复情况就是第一个例子中的，最下方直接挂载了两个叶子结点，就会有两种情况，也确实应该当作两种情况处理。简单地 ~~（不严谨地）~~  说，它一棵链树有着相当于同样深度的两棵链树的“覆盖”能力。

另外，链树具有一个很重要的性质：
我们看这样的三棵树：

![039.png](https://i.loli.net/2020/09/18/65xhLtRk8s4aO7B.png)
![040.png](https://i.loli.net/2020/09/18/yVBgvSdfWw5LMpt.png)
![041.png](https://i.loli.net/2020/09/18/agjqyQifh7XPJF4.png)

因为他们都是链树，所以这三棵树可以共同取代这一棵树的作用：

![042.png](https://i.loli.net/2020/09/18/6yqOat4UIGf1KQJ.png)

这是链树独有的性质。可是，把他们都放在一颗满二叉树上，就丢失了这个性质。我们需要另一种编码方式，满足这最后一棵树是前三棵树的前缀。

所以，不可以编码为向右，向右，挂叶子结点，挂叶子结点。

应编码为 向右，挂叶子结点，向右，挂叶子结点。

那么，把每一层分解开来，有两个性质：

 1. 向左还是向右
 2. 另一边有没有挂叶子结点
 一共是2*2=4种情况，也就是一颗四叉树。
 
 那么我们定义这四种情况是：
 1. 向左，没有挂叶子
 2. 向右，没有挂叶子
 3. 向左，挂了叶子
 4. 向右，挂了叶子
 
 现在，可以把之前哪些链树都放在这颗四叉树上了。
 
![043.png](https://i.loli.net/2020/09/18/WljIvqLFP8brVTa.png)
 
 刚刚举例子的三棵树分别是：0-2-9,0-2-10,(0-2-11和0-2-12).
 而这三棵树等价于0-2这一棵树。
  如果走到一个点，刚好走完了（左右子树都为空）那么就标记这个点的vis为1。
 所以可以考虑dfs,根据这层的情况选择4条路径中对应的走。由于子树可能很深，需要动态开点。注意特判两边都是叶子结点。
 考虑统计答案。有一棵树，就可以覆盖掉所有这棵树所生长出来的树。也就是说，假如已经有0-2了，就肯定不需要0-2-9了。那么答案就是从0出发，想办法走出这棵四叉树，也就是走到一个没有被开过的点。走到时候不能走过vis为1的结点。

# 解法
1. 对于每一棵输入的树，先求出其每个节点子树的大小。
2. 是链树的，进入dfs。每次根据下一层链的位置和另一边是否挂了叶子结点，向前搜索。如果发现两边都是叶子，要把两边的vis都设成1。
3. 统计答案。从根结点开始dfs，不可以走vis为1的结点。如果走完了也没找到漏洞，那就是Almost complete。如果找到了一个没有被动态开过的结点，那就是No。

# 代码

```cpp
#pragma GCC Optimize(2)
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll N,m,n,cnt;
ll siz[2000010],ch[2000010][2],zch[2000010][4],vis[2000010];
//siz表示子树的大小
//ch是目前输入的这棵树 每个结点的两个孩子（就是用来存放树的结构）
//zch是总树，就是那棵四叉树
//vis就是上文提到的vis
ll read(){
	ll x=0;
	char ch;
	do{
		ch=getchar();
	}while(ch>'9'||ch<'0');
	do{
		x=x*10+ch-'0';
		ch=getchar();
	}while(ch<='9'&&ch>='0');
	return x;
}
bool dfs_ls(ll u){//计算每个子结点子树大小
	if(ch[u][0] && !dfs_ls(ch[u][0]))return 0;
	if(ch[u][1] && !dfs_ls(ch[u][1]))return 0;
	ll s1=siz[ch[u][0]],s2=siz[ch[u][1]];
	siz[u] = s1+s2+1;
	if(siz[ch[u][0]] > 1 && siz[ch[u][1]] > 1)return 0;//不是链树，返回0
	if(s1 == 0 && s2 == 0)return 1;
	return 1;
}
ll newnode(ll &x){
	if(x == 0)x = ++cnt;
	return x;
}
void dfs(ll x,ll u){
	//printf("dfs,x = %lld,u = %lld\n",x,u);
	ll s1=siz[ch[u][0]],s2=siz[ch[u][1]];
	if(s1 == 0 && s2 == 0){//叶子结点
	//	printf("end,x = %lld\n",x);
		vis[x]=1;
	//	printf("vis[%lld] = 1\n",x);
		return;
	}
	if(s1 == 1 && s2 == 1){//处理唯一两种重叠的情况
	//	printf("x = %lld,u = %lld,two ends.\n",x,u);
		vis[newnode(zch[x][2])]=1;
		vis[newnode(zch[x][3])]=1;
	//	printf("vis[%lld] = 1,vis[%lld] = 1\n",zch[x][2],zch[x][3]);
		return;
	}
	if(s1 >= 1 && s2 == 0){//链通往左边，另一边没有叶子结点
		dfs(newnode(zch[x][0]),ch[u][0]);
	}
	if(s1 >= 1 && s2 == 1){//链通往左边，另一边有叶子结点
		dfs(newnode(zch[x][2]),ch[u][0]);
	}
	if(s2 >= 1 && s1 == 0){//链通往右边，另一边没有叶子结点
		dfs(newnode(zch[x][1]),ch[u][1]);
	}
	if(s2 >= 1 && s1 == 1){//链通往右边，另一边有叶子结点
		dfs(newnode(zch[x][3]),ch[u][1]);
	}
}
bool ansdfs(ll x){
	if(vis[x])return 0;
	if(zch[x][0] == 0 || zch[x][1] == 0 || zch[x][2] == 0 || zch[x][3] == 0)return 1;//找到了没有被动态开过的结点，那就是No了
	if(ansdfs(zch[x][0]) || ansdfs(zch[x][1]) || ansdfs(zch[x][2]) || ansdfs(zch[x][3]))return 1;
	return 0;//这个return 0;我查了一个半小时才找出这个错。本地会默认返回0，但是OJ上不会。这个故事告诉我们写函数一定要记得返回。
	//之所以要return 0;是因为如果几个孩子都找一遍，没有找出漏洞，那就是没有漏洞，自己也要返回0才行。
}
int main(){
	cin >> N;
	while(N--){
		scanf("%lld",&m);
		for(ll i=0;i<=cnt;i++){
			siz[i]=0;
			vis[i]=0;
			zch[i][0] = zch[i][1] = zch[i][2] = zch[i][3] = 0;
			vis[2000010];
		}
		cnt = 1;
		bool f=0;
		while(m--){
			scanf("%lld",&n);
			for(ll i=1;i<=n;i++)ch[i][0] = ch[i][1] = 0;
			ll j=1;
			for(register int i=1;i<=n;i++){
				ch[i][0] = read();ch[i][1] = read();
			}
			if(n == 1)f=1;//保险起见，n=1特判一下
			if(!dfs_ls(1))continue;
			dfs(1,1);
		}
		if(f == 1){
			cout << "Almost Complete" << endl;
			continue;
		}
		if(ansdfs(1))cout << "No" << endl;
		else cout << "Almost Complete" << endl;
	}
}
```



---

## 作者：Spasmodic (赞：16)

![](https://cdn.luogu.com.cn/upload/image_hosting/1dongloh.png)

尝试提供一个结论不那么突兀的题解。下简称几乎完备的集合为 AC 集合（Almost Complete）。

定义映射 $l(\mathscr T)$ 表示将集合 $\mathscr T$ 中的树全部替换为其左子树，$r(\mathscr T)$ 同理。

+ 我们考察一个 AC 集合 $\mathscr T$，希望找出一些二叉树，使得它们满足如下条件：
	+ 有无限个
   + 任意去掉有限个后都几乎完备
   + 方便我们处理
+ 考虑左子树或右子树大小不超过 1 的树，这些树可以生长得出其他的树，且有无穷多个，满足上面的要求。
+ 我们先考察左子树为空的树，这样的树只能由一颗左子树也为空的树生长得出。考察 $\mathscr T$ 中一切满足这样条件的树构成的集合 $\mathscr S_{l0}$，那么有 $r(\mathscr S_{l0})$ 是 AC 集合。
+ 同理，我们分别考虑左子树为孤立点，右子树为空，右子树为孤立点的集合，可以发现 $r(\mathscr S_{l1}),l(\mathscr S_{r0}),l(\mathscr S_{r1})$ 也都是 AC 集合。这样，我们可以得到一个必要条件。
+ 这个条件是否充要呢？考察其逆命题，任取一树，如果其不属于 $\operatorname{grow}(\mathscr T)$，则其左子树选择有限，右子树选择有限（不然可以分别由 $\mathscr {S_{r0}/S_{r1},S_{l0}/S_{l1}}$ 生长出），因此 $\mathscr T$ 也 AC！
+ 推出这个条件后，我们顺带可以推出一个推论：我们发现对于 $\mathscr T$ 中的树，如果其左子树和右子树的大小都大于 $1$，那么根据充要条件，这颗树是没有贡献的。考虑递归过程，我们意识到，对任意一个节点，如果其左子树和右子树的大小都大于 $1$，那么这颗树都是没有贡献的，因为当我们递归到这个点，它就会被抛弃掉。

推到这里，形式就明朗了不少：我们首先去掉多余的树，然后递归判定 $\mathscr {S_{r0},S_{r1},S_{l0},S_{l1}}$ 是否都 AC 即可。

ix35 说这样直接实现就可以了，但是我觉得不太好写，下面提供一个较好的实现方法：

我们观察到对于每一颗树，它每次被划分到 $\mathscr {S_{r0},S_{r1},S_{l0},S_{l1}}$ 哪一个与其他树无关，我们可以提前划好，此时就找到了一个 dfs 树上根到叶子的链。当然，在末尾处有可能会出现同时被分到 $\mathscr S_{r1}$ 与 $\mathscr S_{l1}$ 的情况，那么我们就视为两条不同的链插入。

我们把划分结果视为字符 $0/1/2/3$，链视为字符串，我们发现：本质上这是一颗 Trie 树！每次我们输入一颗树后，就可以在线地转化为字符串插入到 Trie 树里。当然，与普通的 Trie 树还有一定区别：当我们插入到一个字符串的终止节点时，我们发现对应在 dfs 树上就是发现集合中存在孤立点，这种情况显然是 AC 集合，因此不用继续插入，可以直接退出。

最后怎么判断有解？很简单，只要判断每个非终止节点的点的出度都是 4 即可，如果不是，那么在 dfs 到此处时就会发现存在一个 $\mathscr S=\varnothing$，显然是无解的。

时间和空间复杂度都是 $O(\sum n)$。

```cpp
const int N=2e6+5;
int T,m,n,trie[N<<1][4],rt,cnt,lc[N],rc[N];
bool ed[N<<1];
void build(int u,int&p){
	if(!p)p=++cnt,ed[p]=0,trie[p][0]=trie[p][1]=trie[p][2]=trie[p][3]=0;
	if(ed[p])return;
	if(!lc[u]&&!rc[u]){ed[p]=1;return;}
	if(!lc[u])return build(rc[u],trie[p][0]);
	if(!rc[u])return build(lc[u],trie[p][1]);
	if(!lc[lc[u]]&&!rc[lc[u]])build(rc[u],trie[p][2]);
	if(!lc[rc[u]]&&!rc[rc[u]])build(lc[u],trie[p][3]);
}
bool ok(int p){
	if(!p)return 0;
	if(ed[p])return 1;
	rep(i,0,3)if(!ok(trie[p][i]))return 0;
	return 1;
}
int main(){
	for(IO>>T;T--;){
		for(IO>>m,cnt=rt=0;m--;){
			IO>>n;
			rep(i,1,n)IO>>lc[i]>>rc[i];
			bool flag=1;
			rep(i,1,n)
				if(lc[i]&&rc[i]&&(lc[lc[i]]||rc[lc[i]])&&(lc[rc[i]]||rc[rc[i]]))flag=0;
			if(!flag)continue;
			build(1,rt);
		}
		if(ok(rt))puts("Almost Complete");
		else puts("No");
	}
	return 0;
}
```

---

## 作者：orecic (赞：15)

学文化课之前分享一下自己的方法和代码留作纪念。



------------
我们需要求$\ grow(T)$是否是几乎完备的。

说一下为了方便而下的定义：

- $\ i$号节点定义为bfs序下的第$\ i$号节点。（或者其他编号方式，这个只是为了方便）
- $\ grow(T,i)$为仅考虑$\ i$号节点所在的子树，$\ T$所生长成的树的集合。
- 如果$\ grow(T,i) $仅有有限棵树不在其中，那么久称$\ grow(T,i)$是几乎完备的。

我们考虑已知$\ T$的情况下求$\ grow(T,i)$是否是几乎完备的。

#### 解法

我们设左右儿子分别为$\ ls,rs$。

设$\ A_{0}$为$\ T$中$\ i$节点仅有左儿子的树的集合。

设$\ A_{1}$为$\ T$中$\ i$节点仅有右儿子的树的集合。

设$\ B_{0}$为$\ T$中$\ i$节点有左右儿子，且右儿子是叶子的树的集合。

设$\ B_{1}$为$\ T$中$\ i$节点有左右儿子，且左儿子是叶子的树的集合。

**定理** $\ grow(T,i)$是几乎完备的，要么存在一棵树$\ a \in T$满足$\ i$号节点是$\ a$的叶子，要么$\ grow(A_{0},ls),grow(A_{1},rs),grow(B_{0},ls),grow(B_{1},rs)$都是几乎完备的。

证明：
第一种情况非常显然，我们只考虑第二种情况。

我们注意到$\ grow(T,i)$所包含的树有以下三种情况：
1. $\ i$节点只有左儿子。
2. $\ i$节点只有右儿子。
3. $\ i$节点有两个儿子。

前两种情况分别对应$\ grow(A_{0},ls),grow(A_{1},rs)$，我们考虑最后一种情况。

充分性：如果命题成立，一棵有左右儿子的树不在$\ grow(B_{0},ls) \cup grow(B_{1},rs)$中当且仅当它的左子树是$\ grow(B_{0},ls)$中不被包含的部分，右子树是$\ grow(B_{1},rs)$中不被包含的部分。

必要性：如果$\ grow(B_{0},ls)$不是几乎完备的，那么右儿子是叶子，左子树不被$\ grow(B_{0},ls)$包含的树一定不被$\ grow(T,i)$包含。对于$\ grow(B_{1},rs)$有一样的证明。

证毕。

由于$\ A_{0},A_{1},B_{0},B_{1}$是互不相交的，我们直接递归的复杂度不会超过$\ O(\sum n)$。

由于洛谷没有数据，代码仅在loj上AC。

```cpp
#include<bits/stdc++.h>
using namespace std;
int ttt,m,n[2002002];
vector<pair<int,int> > ss[2002002];
vector<pair<int,int> > tr[2002002];
int tot=0;
inline bool isleaf(int x,int y)
{
	return (tr[y][x].first==0)&&(tr[y][x].second==0);
}
inline int lson(int x,int y)
{
	return tr[y][x].first;
}
inline int rson(int x,int y)
{
	return tr[y][x].second;
}
inline bool dfs(int u)
{
	if(ss[u].empty()) return 0;
	int i=0;
	while(i<(int)ss[u].size())
	{
		int x=ss[u][i].first,y=ss[u][i].second;
		if(isleaf(x,y)) return 1;
		++i;
	}
	int lss,rss,llrs,rlrs;
	++tot;
	lss=tot;
	++tot;
	rss=tot;
	++tot;
	llrs=tot;
	++tot;
	rlrs=tot;
	i=0;
	while(i<(int)ss[u].size())
	{
		int x=ss[u][i].first,y=ss[u][i].second;
		if((lson(x,y))&&(!rson(x,y))) ss[lss].push_back(make_pair(lson(x,y),y));
		else if((!lson(x,y))&&(rson(x,y))) ss[rss].push_back(make_pair(rson(x,y),y));
		else
		{
			if(isleaf(lson(x,y),y)) ss[llrs].push_back(make_pair(rson(x,y),y));
			if(isleaf(rson(x,y),y)) ss[rlrs].push_back(make_pair(lson(x,y),y));
		}
		++i;
	}
	if((dfs(lss))&&(dfs(rss))&&(dfs(llrs))&&(dfs(rlrs))) return 1;
	return 0;
}
int main()
{
	freopen("surreal.in","r",stdin);
	freopen("surreal.out","w",stdout);
	scanf("%d",&ttt);
	while(ttt--)
	{
		scanf("%d",&m);
		int i=1,j=1;
		while(i<=m)
		{
			tr[i].clear();
			tr[i].push_back(make_pair(0,0));
			scanf("%d",&n[i]);
			j=1;
			while(j<=n[i])
			{
				int l,r;
				scanf("%d%d",&l,&r);
				tr[i].push_back(make_pair(l,r));
				++j;
			}
			++i;
		}
		i=1;
		while(i<=tot)
		{
			ss[i].clear();
			++i;
		}
		tot=0;
		++tot;
		i=1;
		while(i<=m)
		{
			ss[tot].push_back(make_pair(1,i));
			++i;
		}
		if(dfs(tot)) printf("Almost Complete\n");
		else printf("No\n");
	}
	return 0;
}

```


---

## 作者：Aw顿顿 (赞：11)

偶然看到题目，被题面吸引了。

我们尝试更完善且更易懂地阐释这题的内核与其证明。

## 题意

题面通过严谨的语言定义了以下概念：

- 树：本文中指**非空、有根、区分左右孩子的二叉树**。
- 树的同构：在**无标号意义**下递归地定义，从“单节点”同构出发，分别讨论左右子树（如果有）的同构情况，记作 $T\equiv T'$。
- 叶子：没有任何孩子的结点。
- 单步替换：将树 $T$ 的某个叶子结点替换为某颗树 $t$ 得到的树与 $T'$ 同构，记作 $T\to T'$。
- 替换：$T$ 经过多次的单步替换与 $T'$ 同构，记作 $T\to^\star T'$。

接下来考虑题目：

> 对于一棵树 $T$，定义 $\text{grow}(T)$ 表示 $T$ 所能替换构成的树的集合，即 $\text{grow}(T)=\{T' | T \to^{\star} T'\}$。
>
> 于此类似地，定义 $\mathscr{T}=\left\{T_{1}, T_{2}, \ldots, T_{n}\right\}$ 是一个树的有限集合则：
>
> $$\text{grow}(\mathscr{T})=\bigcup\limits_{T_{i} \in\mathscr{T}}\text{grow}\left(T_{i}\right)$$
>
> 即 $\text{grow}(\mathscr{T})$ 为 $\mathscr{T}$ 中所有的元素 $\text{grow}$ 结果的并集。

基于此，给出定理：

> 定理“几乎完备的可判定性”：一个树的集合是几乎完备的，如果仅有有限棵树不在其中。那么，对于一个给定的树的有限集合 $\mathscr{T}$，存在高效的算法判定 $\text{grow}(\mathscr{T})$ 是否是几乎完备的。

因此，题目将会给出若干棵树 $T_1,T_2,\cdots T_m$，问其组成的集合 $\mathscr{T}$ 对应的 $\text{grow}$ 集合是否是近乎完备的——即是否仅有有限棵树不属于这个集合。

本题有多组测试数据。

## 链树的关键作用

记一棵树 $T$ 的左子树为 $T_l$ 且右子树为 $T_r$，那么我们称 $\min\big\{size(T_l),size(T_r)\big\}\le 1$ 的树为链树，感性理解上相当于一颗链长出（或不长出）若干个叶子结点而得到的一棵树。

我们需要证明链树是极其有用的，这一作用甚至大于它长出（替换而得的）的任何一棵非链树。

> 引理 $1$：一颗非链树不能生成链树。

接着我们需要证明链树的重要作用，即：

> 引理 $2$：若存在给定深度的所有链树，那么就一定能够生成出所有该深度的树。


不考虑其他链树的情况下，一棵链树缺失会导致无数颗由其生成的链树缺失，而由于引理 $1$，非链树是不能够生成链树的。因此**我们要考虑的是通过一些其他的链树来代替这颗链树的作用，而非通过一些非链树来代替，因为他们做不到**，因此我们只需要考虑链树。


## 构造链树的基础

任何一棵树，将其左子树砍掉之后就成了一颗链树（或者左子树保留一个节点亦可），而这个链树在右子树上可以生长出无数颗链树，这些链树是不能通过这颗树构造而成的；砍掉右子树同理。**这一步的意义在于构造出了无数棵非链树所不能长出的树**，因而对于一个有限的集合，非链树是没有意义的。

为了方便说明，我们把“砍掉左/右子树”或者将其替换为一个叶子结点的过程成为反替换，那么我们可以很容易理解：若一棵树不能被生成，那么它反替换成的链树也不能被生成。那么显然**有无数颗树不能被生成可以推导出有无数颗链树不能被生成**。同样的，由于链树是一种特殊的树，因此**有无数颗链树不能被生成等价于有无数颗树不能被生成**。

由上，给出引理：

> 引理 $3$：$\text{grow}(\mathscr{T})$ 是近似完备的当且仅当存在有限棵链树不被 $\mathscr{T}$ 包含。

只要我们能证明仅存在有限棵链树不被 $\mathscr{T}$ 包含，我们就相当于证明了该集合的近似完备性。

## 具体实现方案

我们先实现判断叶子结点：

- 若一个非空节点没有儿子，那么它是叶子结点。

递归地判断链树：

- 若当前节点是叶子结点，返回 $1$。
- 否则继续判断左右儿子。
- 如果左右儿子均还需要继续递归（那么 $size$ 就均大于 $1$），返回 $0$。
- 否则返回 $1$。

给出代码如下：

```cpp
inline int isleaf(int x){return (x&&!ls[x]&&!rs[x]);}
int check(int x){
	if(x==0||isleaf(x))return 1;
	if(!check(ls[x])&&!check(rs[x]))return 0;
	return 1;
}
```

每读入一棵树，就首先判断是否是链树。如果不是直接跳过，否则考虑对其进行处理，将其合并。链树中某结点的子节点情况有四种：

- 仅有左子节点。
- 仅有右子节点。
- 左右子节点均有，且左子节点是叶子。
- 左右子节点均有，且右子节点是叶子。

因而可以通过简单的编码合并到一颗四叉树上。

```cpp
void merge(int &now,int x){
	if(!now)now=(++cnt);
	if(isleaf(x)){ok[now]=1;return;}
	if(isleaf(ls[x])&&isleaf(rs[x])){
		merge(ch[now][2],ls[x]);
		merge(ch[now][3],rs[x]);
		return;
	}
	if(ls[x]==0)merge(ch[now][1],rs[x]);
	if(rs[x]==0)merge(ch[now][0],ls[x]);
	if(rs[x]&&isleaf(ls[x]))merge(ch[now][3],rs[x]);
	if(ls[x]&&isleaf(rs[x]))merge(ch[now][2],ls[x]);
}
```

如果只存在有限棵树不能被 $x$ 的子树替换出来，那么 $x$ 这个点是好的，这有两种情况：

- 给定的链树集合 $\text{grow}(\mathscr{T})$ 存在一棵树让这个位置的结点为叶子结点。
- 要么是这个点所有的儿子都是好点。

择其一判断，即可递归地进行计算。不难发现，最终答案只需要判断 $1$ 根节点是否是符合要求的节点即可。代码实现起来不是很难。

## 全文代码

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int T,n,m,cnt,rt;
int ls[N],rs[N],ok[N],ch[N][4];
inline int isleaf(int x){return (x&&!ls[x]&&!rs[x]);}
int check(int x){
	if(x==0||isleaf(x))return 1;
	if(!check(ls[x])&&!check(rs[x]))return 0;
	return 1;
}void merge(int &now,int x){
	if(!now)now=(++cnt);
	if(isleaf(x)){ok[now]=1;return;}
	if(isleaf(ls[x])&&isleaf(rs[x])){
		merge(ch[now][2],ls[x]);
		merge(ch[now][3],rs[x]);
		return;
	}
	if(ls[x]==0)merge(ch[now][1],rs[x]);
	if(rs[x]==0)merge(ch[now][0],ls[x]);
	if(rs[x]&&isleaf(ls[x]))merge(ch[now][3],rs[x]);
	if(ls[x]&&isleaf(rs[x]))merge(ch[now][2],ls[x]);
}int grow(int x){
	if(!x)return 0;
	if(ok[x]==1)return 1;
	return grow(ch[x][0])&&grow(ch[x][1])&&grow(ch[x][2])&&grow(ch[x][3]);
}inline void init(){
	for(int i=1;i<=cnt;i++)
		ch[i][0]=ch[i][1]=ch[i][2]=ch[i][3]=ok[i]=0;
	rt=cnt=0;
}signed main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&m);init();
		for(int i=1;i<=m;i++){
			scanf("%d",&n);
			for(int j=1;j<=n;j++)scanf("%d%d",&ls[j],&rs[j]);
			if(check(1)==0)continue;
			merge(rt,1);
		}if(grow(1)==0)puts("No");
		else puts("Almost Complete");
	}return 0;
} 
```








---

## 作者：huhao (赞：7)

没听懂标准解法（考场写了正解就没怎么听），分享一下考场思路，这里认为空树合法能且仅能仅能生成空树。

称一棵树$B$比一棵树$A$更容易被生成，当且仅当$A\rightarrow B$，那么一定有$\forall T\rightarrow A,T\rightarrow B$。

于是所有非空树比一个节点的树容易生成。

若存在无限个树不能被生成，则一定存在一个无限大的树不能被生成（这是充要条件）。

一颗非空树$A$可以生成另一颗非空树$B$当且仅当$A$的左右儿子可以分别生成$B$的左右儿子

令一颗无限大的树$T$的左子树$T_l$为无限大（右子树时同理），若右子树$T_r$大小大于$1$则将$T_r$换为一个节点的树也一定不能被生成（因为$T_r$比它容易生成）且大小无限大。

于是题目变为能否找到一个无限大的树，每个节点要么只有一个儿子，要么两个儿子中有一个子树大小为$1$。

然后可以递归搜索$check(S)$：定义集合$S$为当前需要判断的树集合（即是否有无限个树$T$，使得$T\in grow(S)$）

如果$S$中存在一个点的树，那么答案为否，如果$S$为空，那么答案为真

然后搜右子树为空的情况：若所有在$S$中，且没有右子树的树的左子树组成的集合为$T$，若$check(T)=1$，则$check(S)=1$

右子树为一个节点的同理：若所有在$S$中，且右子树大小为$1$的树的左子树组成的集合为$T$，若$check(T)=1$，则$check(S)=1$

然后对称地对左子树做一遍即可。

update: 考虑每个节点对复杂度的贡献为$O(1)$，所以总复杂度$O(\sum n)$

没带U盘去一中，于是没有代码。

---

## 作者：whiteqwq (赞：6)

[P6776 [NOI2020]超现实树](https://www.luogu.com.cn/problem/P6776)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1758437)

## 题意
- 定义一棵树的替换为将其任意一个叶子结点替换为任意一棵树之后形成的树；
- 定义$grow(\mathscr{T})$为里面所有树进行任意步替换能构成的树的集合；
- 定义一个$grow$集合完备当且仅当仅存在有限棵树不存在于这个集合中；
- 给定一个$m$棵树组成的森林$\mathscr{T}$，判断$grow(\mathscr{T})$是否完备。
- 多组数据，$\sum n\leqslant 2\times 10^6$。

## 分析
神仙题，同步赛的时候只想到了讨论儿子的情况，但是由于没想到只有链树可以对答案贡献，因此发现讨论不出来情况，最后只拿了[$40pts$](https://www.luogu.com.cn/record/37422593)。

定义：我们定义**链树为一条链上每个节点挂或不挂一个叶子结点形成的树**。

引理$1$：**任意非链树的数无法通过替换得到链树**

> 证明：替换操作不会删除任意原有的结点，因此新生成的树依旧无法满足链树的条件。

引理$2$：**$grow(\mathscr{T})$的完备性等价于只有有限棵链树不被$grow(\mathscr{T})$包含**。

> 证明：

> - 充分性：如果无数棵链树不在$grow(\mathscr{T})$中，那么肯定有无限棵树不在$grow(\mathscr{T})$中；
> - 必要性：如果无数棵树不在$grow(\mathscr{T})$中，那么我们一定有无限个**深度不相同**的树不在$grow(\mathscr{T})$中，对于每一个深度的树我们都可以砍去一些子树使得这棵树变为链树，显然这棵链树也无法替换而成。（如果可以替换而成，那么一定可以生成这颗不包含在$grow(\mathscr{T})$中的树）

引理$3$：**只有链树可以对$grow(\mathscr{T})$的完备性产生影响**。

> 证明：由于引理$1$，我们知道任意一颗不是链树的树一定无法替换成链树，而由引理$2$得我们只关心链树是否可以被替换而成，因此我们只需要链树。

这样，我们的任务就转化为了**能否用给定的所有链树替换出无限的链树**。（注意：下文中$\mathscr{T}$集合专指剔除了非链树的给定树集合）

首先，我们要判断链树（$\text{check}$函数）：
```
int isleaf(int x){
	return x!=0&&ls[x]==0&&rs[x]==0;
}
int check(int x){
	if(x==0||isleaf(x))
		return 1;
	return (check(ls[x])==0&&check(rs[x])==0)? 0:1;
}
```

对于链树上的结点，它儿子的情况只有四种：①只有左儿子②只有右儿子③有左右儿子，但是有一个儿子是叶子结点（根据链树的定义很显然有这一点）。

因此我们也可以很快写出来链树的合并：
```
void merge(int &now,int x){
	if(now==0)
		now=++cnt;	
	if(isleaf(x)){
		ok[now]=1;
		return ;
	}
	if(isleaf(ls[x])&&isleaf(rs[x])){
		merge(chd[now][2],ls[x]),merge(chd[now][3],rs[x]);
		return ;
	}
	if(ls[x]==0)
		merge(chd[now][1],rs[x]);
	if(rs[x]==0)
		merge(chd[now][0],ls[x]);
	if(rs[x]&&isleaf(ls[x]))
		merge(chd[now][3],rs[x]);
	if(ls[x]&&isleaf(rs[x]))
		merge(chd[now][2],ls[x]);
}
```

定义结点$x$为好点当且仅当**只存在有限棵树不能被$x$的子树替换出来**，好点的判断可以通过一种递归的方式写出：

```
int grow(int x){
	if(x==0)//不存在这个点
		return 0;
	if(ok[x]==1)//解释见下
		return 1;
	return grow(chd[x][0])&&grow(chd[x][1])&&grow(chd[x][2])&&grow(chd[x][3]);
	//chd[x][0/1/2/3]为x儿子的四种情况
}
```

解释：某个子树可以替换出来它子树所有情况只有两种情况：要么是给定的链树集合$grow(\mathscr{T})$存在一棵树让这个位置的结点为叶子结点（这样一定可以替换出所有的树），要么是这个点所有的儿子都是好点。

这样我们只需要判断根结点是否为好点就可以了。

## 代码
[代码&压行后的代码](https://www.luogu.com.cn/paste/65fs1nds)

---

## 作者：断清秋 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P6776)

一句话题意：定义一个操作为将二叉树的一个叶子替换为任意一棵二叉树，
给定二叉树集合 $S$，问是否存在无限棵树不能由 $S$ 中的树通过若干次操作得到。

数据范围 $\sum\limits_{}^{}n\le2\times10^6$，考虑线性做法。

暴力判断每一棵树显然不可取，可以猜测有一些树对答案应该没有贡献。考虑这些树的构成。

其实只有四种树有贡献。第一种是只有左子树，第二种只有右子树，第三种是左右子树都有且左子树大小为 $1$，第四种是左右子树都有且右子树大小为 $1$。

考虑证明这个结论。

显然对于一棵只有左子树的树，第一种树可以完美表示，其他任何树都不可以；对于一棵只有右子树的树，第二种树可以完美表示，其他任何树都不可以。而对于第三种树和第四种树，它们显然可以长出任意与它们深度相同的树，继而可以长出所有深度超过它们的树，而除了这两种树以外的树都不可以做到这一点。

也就是说，我们证明了只有以上四种树是有意义的，若将这四种树称作链树，那么输入的时候直接判断输入的树是否是链树，不是直接跳过即可。

要做到判断一棵树是否为链树，显然需要记录它左子树和右子树的大小。我们使用 $countsize$ 函数实现。如果一棵树的左右子树大小都大于 $1$，那么直接跳出。

如果一棵树是链树，那么我们使用 $buildtree$ 函数将其加到四叉树中，全部加入后进行 dfs，如果能走完就将该节点标记为 $1$。这里使用了动态开点，对于每一个新加入的节点，类似动态开点线段树的做法，为其开一个新点进行存储。四叉树中，$0$ 部分存储第二种树，$1$ 部分 存储第三种树，$2$ 部分存储 第一种树，$3$ 部分存储第四种树。注意如果左右子树大小都为 $1$ 则需要在 $1$ 和 $3$ 两部分均打标记，左右子树大小都为 $0$ 则说明是叶子节点，直接在叶子上打标记即可。

链树全部加入后，直接 dfs 根节点，如果标记为 $1$ 则说明能走完，如果发现动态开点根本没开到这个点则无解。

注意多测清空！

时间复杂度 $O(\sum\limits_{}^{}n)$。

代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#define ll long long
#define back return
#define ri register int
#define ull unsigned long long 
using namespace std;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))
    {
        if (ch=='-') 
            f=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    back x*f;
}
int N,n,m,cnt,l[2000005],r[2000005];
int siz[2000005],alltree[2000005][4],vis[2000005];
int countsize(int x)
{
	if((l[x]!=0&&countsize(l[x])==0)||(r[x]!=0&&countsize(r[x])==0))
		back 0;
	siz[x]=siz[l[x]]+siz[r[x]]+1;
	if(siz[l[x]]>1&&siz[r[x]]>1)
		back 0;
	if(siz[l[x]]==0&&siz[r[x]]==0)
		back 1;
	back 1;
}
int add(int &root)
{
	if(root==0)
	{
		cnt++;
		root+=cnt;
	}
	back root;	
}
void buildtree(int root,int x)
{
	int l1=siz[l[x]],r1=siz[r[x]];
	if(l1==0&&r1==0)
	{
		vis[root]=1;
		back ;
	}
	if(l1==1&&r1==1)
	{
		vis[add(alltree[root][1])]=1;
		vis[add(alltree[root][3])]=1;
		back ;
	}
	if(l1==0&&r1>=1)
		buildtree(add(alltree[root][0]),r[x]);
	if(l1==1&&r1>=1)
		buildtree(add(alltree[root][1]),r[x]);
	if(l1>=1&&r1==0)
		buildtree(add(alltree[root][2]),l[x]);
	if(l1>=1&&r1==1)
		buildtree(add(alltree[root][3]),l[x]);
}
int dfs(int x)
{
	if(vis[x]==1)
		back 1;
	int x0=alltree[x][0],x1=alltree[x][1],x2=alltree[x][2],x3=alltree[x][3];
	if(x0==0||x1==0||x2==0||x3==0||dfs(x0)==0||dfs(x1)==0||dfs(x2)==0||dfs(x3)==0)
		back 0;
	back 1;
}
int main()
{
	N=read();
	while(N--)
	{
		cnt=1;
		memset(siz,0,sizeof(siz));
		memset(vis,0,sizeof(vis));
		memset(alltree,0,sizeof(alltree));
		m=read();
		while(m--)
		{	
			n=read();
			for(ri i=1;i<=n;i++)
				l[i]=read(),r[i]=read();
			if(countsize(1)==0)
				continue;
			buildtree(1,1);
		}
		if(dfs(1)==1)
			cout<<"Almost Complete"<<endl;
		else
			cout<<"No"<<endl;
	}
    back 0;
}
```

---

## 作者：FjswYuzu (赞：4)

最近做了不少数据结构“好题”（笑）产生了奇怪的审美疲劳，于是决定做思维题沐浴自闭神的智慧之光。

定义一个操作「单步逆替换」为「单步替换」的逆操作（即，将树 $T$ 的一棵子树替换成一个结点，这个结点显然是叶结点）。假设现在有一棵随机的树，我们显然可以选择一条根到某一个叶结点的链，然后对链上的每一个点进行操作：如果这个点有两棵子树，将不包含链的那棵子树进行「单步逆替换」；否则不管。例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/f33cm1rf.png)

发现我们生成的树有一个显然的特点是，左右儿子子树大小的最小值不超过 $1$。

定义这种树为「自闭树」。显然所有的自闭树能够生成所有的树，并且非自闭树不能够生成自闭树。不难猜测我们可以将非自闭树移出这个二叉树的体系中。整个问题也就变得只和自闭树有关了。问题变成：给定一个自闭树的集合，问这些自闭树不能够生长成的自闭树的数量是否有限。

发现，如果所有深度为 $d$ 的自闭树能够被生成，这意味着所有深度大于等于 $d$ 的自闭树能被生成，因此不能够被生成的自闭树有限。

一般性质挖掘到这里。考虑将几乎完备这一性质转移到结点上，使得这个森林的几乎完备可以被递归定义。又考虑一些特殊性质：

- 如果这个结点对应了之前森林中某一棵树的叶结点，可以确定其几乎完备；   
- 否则，对于（所有的树合并后形成的）一个树的结点，如果下列四种情况全部存在即完备：
  - 只有左子树；   
  - 只有右子树；   
  - 右子树大小为 $1$，有左子树；   
  - 左子树大小为 $1$，有右子树。
  
将四种情况看成一棵四叉树。如果当前结点是满的，那么其是几乎完备的。

于是直接递归处理。合并的时候记忆当前结点是否对应之前树的集合的某一棵树的叶结点，然后按四种情况向下递归。

```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)
int read()
{
	int x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
int lc[2000005],rc[2000005],siz[2000005],ch[2000005][4],cnt,rt,tek[2000005];
bool isSizeTree(int now)
{
	if(!now)	return true;
	if(!lc[now] && !rc[now])	return (siz[now]=1);
	bool flag=(!lc[now] || isSizeTree(lc[now])) && (!rc[now] || isSizeTree(rc[now]));
	siz[now]=siz[lc[now]]+siz[rc[now]]+1;
	return flag && bool(min(siz[lc[now]],siz[rc[now]])<=1);
}
void Merge(int &now,int tnw)
{
	if(!now)	now=++cnt;
	if(!siz[lc[tnw]] && !siz[rc[tnw]])
	{
		tek[now]=1;
		return ;
	}
	if(!siz[rc[tnw]] && siz[lc[tnw]]>=1)	Merge(ch[now][0],lc[tnw]);
	if(!siz[lc[tnw]] && siz[rc[tnw]]>=1)	Merge(ch[now][1],rc[tnw]);
	if(siz[rc[tnw]]==1 && siz[lc[tnw]]>=1)	Merge(ch[now][2],lc[tnw]);
	if(siz[lc[tnw]]==1 && siz[rc[tnw]]>=1)	Merge(ch[now][3],rc[tnw]);
}
bool check(int now)
{
	if(tek[now])	return true;
	if(!ch[now][0] || !ch[now][1] || !ch[now][2] || !ch[now][3])	return false;
	return check(ch[now][0]) && check(ch[now][1]) && check(ch[now][2]) && check(ch[now][3]);
}
void Solve()
{
	for(int i=1;i<=cnt;++i)	ch[i][0]=ch[i][1]=ch[i][2]=ch[i][3]=tek[i]=0;
	rt=cnt=0;
	int Size=read();
	bool flag=false;
	while(Size-->0)
	{
		int n=read();
		for(int i=1;i<=n;++i)	lc[i]=read(),rc[i]=read();
		if(n==1)	flag=true;
		if(isSizeTree(1))	Merge(rt,1);
	}
	puts((flag || check(rt))?"Almost Complete":"No");
}
int main(){
	int T=read();
	while(T-->0)	Solve();
	return 0;
}
```

---

## 作者：C20203030 (赞：3)

## 一、题目

[点此看题](https://www.luogu.com.cn/problem/P6776)

## 二、解法

首先要**简化问题**，我一开始就是直接想怎么合并然后两个小时没有结果，虽然已经摸到了正解的门槛 $...$

就想一下哪些树可能有用吧！如果直接考虑所有树的话太难了，可以大概感觉到最基本的树应该是一条链上面挂了叶子，这种结构我们称之为**链树**，链树是能生成许多树的状态的，但是是否有非链树的组合达到链树效果的情况呢？画下图呗：

![](https://cdn.luogu.com.cn/upload/image_hosting/l5xq6vq7.png)

你仔细观察下就知道是不能等效的，因为链树只伸出去的叶子的情况会有无限多种，而这种情况在右边是没有的。所以说明了一个至关重要的结论：**链树可以是生成无限树的基本树，并且非链树就算组合也不能等效链树**

那么可以抛弃掉非链树了，只考虑链树问题会简化很多。现在我们要考虑很多链树的并集，**可以考虑用某种状态表示链树，使得合并之后的状态能够等效合并前两个链树状态的并集**，状态不会很多，从链树的形态出发分类：

- 状态 $1$：只有左儿子
- 状态 $2$：只有右儿子
- 状态 $3$：有右儿子，左儿子是叶子
- 状态 $4$：有左儿子，右儿子是叶子

那么可以把链树分类递归下去（每一个点都有一个状态），那么怎么定义状态是否合法呢？我们先固定上面递归下来的形态，在此基础上能生成无限多种树，由于我们定义的状态覆盖了所有情况，所以可以得到合法判定条件：

- 这个状态对应点是叶子（可能不同数对应不同点，只要有其一是叶子即可）
- 这个状态的四个子状态都合法

那么类似线段树合并写一下就行了，时间复杂度 $O(\sum n)$

总结一下，本题主要用到的思想是：**简化问题**（这一点很重要我没想到）；**合并思想、等效思想**（把一堆东西的组合等效单个东西）；**定义状态**（其实就找到了递归子问题）

```c++
#include <cstdio>
const int M = 2000005;
int read()
{
	int x=0,f=1;char c;
	while((c=getchar())<'0' || c>'9') {if(c=='-') f=-1;}
	while(c>='0' && c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int T,n,m,rt,cnt,ch[M][4],c[M],ls[M],rs[M];
int chk(int x)//判断是否是叶子 
{
	return !ls[x]&&!rs[x];
}
int pd(int x)
{
	if(chk(x) || (!rs[x] && pd(ls[x])) || (!ls[x] && pd(rs[x])))
		return 1;
	return (chk(rs[x]) && pd(ls[x])) || (chk(ls[x]) && pd(rs[x]));
}
void merge(int &x,int y)
{
	if(!x) x=++cnt;
	if(chk(y))
	{
		c[x]=1;
		return ;
	}
	if(!rs[y]) merge(ch[x][0],ls[y]);
	if(!ls[y]) merge(ch[x][1],rs[y]);
	if(ls[y] && rs[y] && chk(ls[y])) merge(ch[x][2],rs[y]);
	if(ls[y] && rs[y] && chk(rs[y])) merge(ch[x][3],ls[y]);
}
int grow(int x)
{
	if(!x||c[x]) return x>0;
	return grow(ch[x][0]) && grow(ch[x][1])
	&& grow(ch[x][2]) && grow(ch[x][3]);
}
signed main()
{
	T=read();
	while(T--)
	{
		m=read();
		cnt=rt=0;
		while(m--)
		{
			n=read();
			for(int i=1;i<=n;i++)
				ls[i]=read(),rs[i]=read();
			if(pd(1)) merge(rt,1);
		}
		if(grow(rt)) puts("Almost Complete");
		else puts("No");
		for(int i=1;i<=cnt;i++)
			for(int j=0;j<4;j++)
				ch[i][j]=c[i]=0;
	}
}
```



---

## 作者：xh39 (赞：3)

蒟蒻的第$2^{6}$篇题解,本题第100AC。本人第3道黑题(~~如果没有chen_zhe,这是第10道~~)

本题相比于其他题解多了题意简化,代码实现和完整代码。

简化下题意。

给定n棵树,现在你可以把一棵树的叶节点替换为任意树,如果只有(有限)棵树不能被替换得到,那么这堆树就是几乎完备,此时输出```Almost Complete```,否则输出```No```。

首先来考虑h<=2时的情况。

这时必须包含下面的三棵树,否则就必须包含单点。证明不难,枚举一下就可以了。
```cpp
tree-0:
2
2 0
0 0
tree-1:
2
0 2
0 0
tree-2:
3
2 3
0 0
0 0
```
然后开始考虑其他情况。

然后根据上述情况开始递归。如果递归到u时,其他除u的子树外与u同构的所有树中有上述3中情况且不包含任何子树或者继续递归其子树且子树符合要求那么该节点符合要求。

句子有点长,很绕,建议自己画一下。如果不理解就继续往下看。

把树分为4种情况。

①单点。

②链。

③其他。

其中②③又可以细分。至于为什么要这样分,下面再讲。

②可以分为是 有左节点的链 和 有右节点的链。

③可以分为 左节点的子节点数量多 和 右节点的子节点数量多。

如果包含①,那么以该节点为根直接通过。

如果包含②③,那么分别对这两种情况递归,如果都可以就可以,否则不可以。

这里有一个优化。因为如果碰到③两棵子树都递归相当于1棵树就裂开成了2棵树,时间复杂度就高了。所以如果子节点数量较小的那个的子节点数量如果都超过了1,那么这棵树就废掉了。原因很简单,自己想想就知道了。因为这样既不能解决缺左边子树的情况,也不能解决缺右边子树的情况,自然就不几乎完备。

所以大家就知道了为什么③要分为2类。

思路讲完了,讲下代码实现。我做题时就卡在代码实现。

现在有这么多棵树,我们怎么来递归呢?、

首先想到了排序,把所有子树按照分类排一遍序。

[**错误做法**]第一个想到的肯定是归并排序的方法。然后记录下每一类在序列里的左端点和右端点,然后在递归时写4个递归函数,分别把左端点,右端点和递归节点传过去。但是不是说不可以,特别麻烦,写起来特别容易出错。

于是我就借鉴了题解的代码,仔细研究之后采用了另一种方法。

把树重新编号,使每一类情况的编号一样。然后用一个vector存每一个节点对应的(节点原编号和所在的树编号),下标为节点新编号。

如果看不懂,可以见完整代码,相信我可以看懂题解代码,你们也能看懂我代码。

```cpp
#include<iostream>
#include<vector>
using namespace std;
vector<int> l[5000005],r[5000005],node[5000005],tree[5000005]; //node表示结点旧编号,tree表示节点所在的树。 
int m[5000005],tot=1;
bool dfs(int iakioi){
	int i,size=node[iakioi].size();
	if(!size){ //如果没有这种情况,显然不几乎完备。
		return false;
	}
	for(i=0;i<size;i++){
		if(l[tree[iakioi][i]][node[iakioi][i]]<0&&r[tree[iakioi][i]][node[iakioi][i]]<0){ //如果有①情况,直接几乎完备。
			return true;
		}
	}
	int N,T,t;
	for(i=0;i<size;i++){ //分别讨论②③以及细分的情况。
		N=node[iakioi][i];
		T=tree[iakioi][i]; //vector是很慢的,由于要多次访问,所以提前存下来。
		if(l[T][N]>=0){ 
			if(r[T][N]>=0){
				if(l[T][r[T][N]]<0&&r[T][r[T][N]]<0){
					node[tot+3].push_back(l[T][N]);
					tree[tot+3].push_back(T);
				}
				if(l[T][l[T][N]]<0&&r[T][l[T][N]]<0){
					node[tot+4].push_back(r[T][N]);
					tree[tot+4].push_back(T);
				}
			}else{
				node[tot+1].push_back(l[T][N]);
				tree[tot+1].push_back(T);
			}
		}else{
			if(r[T][N]>=0){
				node[tot+2].push_back(r[T][N]);
				tree[tot+2].push_back(T);
			}else{
				return true;
			}
		}
	}
	t=tot; //如果不用t直接用tot,在dfs时tot的值改变了,你就得不出正确答案了。
	tot+=4;
	return (dfs(t+1)&&dfs(t+2)&&dfs(t+3)&&dfs(t+4)); //必须都几乎完备。
}
void Main(){
	int n,i,j,a,b;
	scanf("%d",&n);
	for(i=0;i<n;i++){
		l[i].clear();
		r[i].clear();
	}
	for(i=0;i<n;i++){
		scanf("%d",m+i);
		for(j=0;j<m[i];j++){
			scanf("%d %d",&a,&b);
			l[i].push_back(a-1); //下标从0开始。个人认为对于本题方便不易出错。
			r[i].push_back(b-1);
		}
	}
	for(i=0;i<=tot;i++){ //把之前用过的都初始化。
		node[i].clear();
		tree[i].clear();
	}
	for(i=0;i<n;i++){
		node[0].push_back(0); //一开始编号0。插入所有的树。
		tree[0].push_back(i);
	}
	tot=0;
	if(dfs(0)){
		cout<<"Almost Complete"<<endl;
	}else{
		cout<<"No"<<endl;
	}
}
int main(){
	int t,i;
	cin>>t;
	for(i=0;i<t;i++){
		Main();
	}
}
```

---

## 作者：Evier (赞：2)

## 题意

$N$ 组数据，每组数据给定 $m$ 棵二叉树，其中每棵树有 $n$ 个节点。

定义一次操作为将 $m$ 棵二叉树中任意一棵树的**叶节点**换成任意一棵二叉树，问进行若干次这样的操作后形成的树的集合是否为几乎完备的。

几乎完备：若一个集合中只不包括有限棵二叉树，则称它为几乎完备的。

$N \le 40$

$\sum n,\sum m \le 10^6$
## 题解
神仙题！

读完题目，首先要去思考怎样的树是对集合成为几乎完备的有贡献。逐层考虑每棵二叉树，会发现每层的每个非叶子的节点大体可以分为只有左子树、只有右子树、左右子树都有三种情况。

要想这个集合是几乎完备的，必须保证每层的每个节点均可经过以上操作变成三种情况中任意一种，否则如果不包含某种情况，则由那种情况长出的树也都不会被包含（能长出无限棵）。

并且，分层考虑时给定的树只有在包含**仅一个节点**的**一种情况**时才是对答案有贡献的，否则它无法生长成仅包含其中一种情况的树，也可以被别的有贡献的树所替代。~~它能被替代，又替代不了别人，像极了那啥~~

思考到这步时大家可能会有一个问题：不满足上述条件的树能否经过互补对答案产生贡献？

事实上是不行的。因为不管有多少棵包含多种情况的树，只包含一种情况的树都无法被生成，且只包含一种情况的树是必要的。依据这种情况，我们所能做的只有补上这些只包含一种情况的树，但发现所有有多种情况的树都能被一种情况的树所生成，所以不满足上述条件的树无法互补以产生贡献。

于是我们从第一层开始考虑，依次看到最高一层。画一画所有这种符合要求的树会发现在每一层均有意义的树恰恰有一个特点：每个节点左子树与右子树大小的 $\min$ 值小于等于 $1$。我们称这种树为链树。

到这一步时，我们已经可以处理出所有这种树，并通过 dfs 判断每层是否包含所有情况。于是，我们为了方便将每个节点分为四类：

1. 只包含左子树的。
2. 只包含右子树的。
3. 包含左右子树且左子树为叶节点的。
4. 包含左右子树且右子树为叶结点的

这种分类恰恰包括了所有的情况，我们可以很方便地将它们合并到一棵四叉树上，如果某个节点不包含所有的四种情况且不是叶节点，那么这个集合不可能是几乎完备的。

**注意**：类型为 3 的节点同时也是类型为 4 的节点，它们的区别仅仅是递归的方向。

## Code
代码还是有挺多细节的，且有些操作并不是那么容易实现，一定要仔细思考，在理解的基础上做题。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,m,n,l[2000005],r[2000005],f[2000005],tot,s[2000005],t[2000005][4],v[2000005];//l,r数组代表给定的树，t代表四叉树 
inline int read(){
	int X=0; bool flag=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') flag=0; ch=getchar();}
	while(ch>='0'&&ch<='9') {X=(X<<1)+(X<<3)+ch-'0'; ch=getchar();}
	if(flag) return X;
	return ~(X-1);
}
bool dfs1(int x){//算子树大小以判断链树 
	if(!l[x]&&!r[x]){
		s[x]=1;return 1;
	}
	if(l[x])if(!dfs1(l[x]))return 0;
	if(r[x])if(!dfs1(r[x]))return 0;
	s[x]=s[l[x]]+s[r[x]]+1;
	if(s[l[x]]>1&&s[r[x]]>1)return 0;
	return 1;
}
int New(int &x){//动态开点 
	if(!x)x=++tot;
	return x;
}
void dfs(int x,int p){//x表示四叉树上的节点编号，p表示要合并的链树上的节点编号 
	int s1=s[l[p]],s2=s[r[p]];
	if(s1==0&&s2==0){
		v[x]=1;return;//判断叶节点 
	}
	if(s1>=1&&s2==0)dfs(New(t[x][0]),l[p]);
	if(s2>=1&&s1==0)dfs(New(t[x][1]),r[p]);
	if(s1>=1&&s2==1)dfs(New(t[x][2]),l[p]);
	if(s2>=1&&s1==1)dfs(New(t[x][3]),r[p]);
}
bool check(int x){
	if(v[x])return 1;
	if(!t[x][0]||!t[x][1]||!t[x][2]||!t[x][3])return 0;
	if(!check(t[x][0])||!check(t[x][1])||!check(t[x][2])||!check(t[x][3]))return 0;
	return 1;
}
int main(){
	cin>>T;
	while(T--){
		m=read();
		bool f=0;
		for(int i=0;i<=tot;i++){
			t[i][0]=t[i][1]=t[i][2]=t[i][3]=v[i]=0;
		}
		tot=1;
		for(int i=1;i<=m;i++){
			n=read();
			for(int j=1;j<=n;j++)l[i]=r[i]=0;
			if(n==1){//特判只有根节点的情况 
				f=1;
			}
			for(int j=1;j<=n;j++){
				l[j]=read(),r[j]=read();
			}
			if(!dfs1(1))continue;
			dfs(1,1);
		}
		if(!f&&!check(1))cout<<"No"<<endl;
		else cout<<"Almost Complete"<<endl;
	}
} 
```

---

## 作者：lcyxds (赞：1)

建议标签：树形结构（这题真的啥高级算法都用不到）

刷另一道题，中途上厕所的时候，突然想到了这道题的思路，上完厕所打开这题把这题切了，于是写一篇题解纪念一下 qwq

看很多题解都要依赖于链树的性质，这里讲解一个不直接依赖于链树性质的思路（但是间接依赖是无法避免的）

首先，观察样例可以发现，一个集合是几乎完备的，大体上有两种情况：

1. 存在只有根节点的树，此时所有树都在集合内；
2. 只有根节点的树不在集合内，而根节点只有左儿子，根节点只有右儿子，根节点既有左儿子又有右儿子三类子树几乎全部在集合内。

第一种情况，遍历一遍所有树就结束了。

第二种情况，之所以分三类是因为这三类均不可能替换子树得到另一类。以只有左儿子为例，根节点因为有左儿子不再是叶节点，因而无法替换根节点，根节点也不会产生右儿子。

而集合内子树需要将这三种情况全部包含。

当根节点只有左儿子时，只有集合内根节点同样只有左儿子的树所生长得到的集合必须几乎包含所有的此类树，递归这些树的左儿子处理即可（即把左儿子当作上述步骤中的根节点递归处理一遍）。

右儿子同理。

最后考虑根节点同时拥有左儿子和右儿子的情况，这也是这道题最难的地方。

很容易错想成需要同时递归处理左子树和右子树，于是当时 NOI 同步赛这题几乎没有拿到分数（后来测试了一下，这样做甚至能得到 40 分的好成绩，15、16 这两个点是有多水。。。估计是场上其他地方也出锅了）

此时，仍然将这类树分为三类：根节点的右儿子没有儿子，根节点的左儿子没有儿子，根节点的左儿子有儿子而且右儿子有儿子。（根节点的两个儿子都没有儿子同时属于前两类，同时这种子树所生长得到的集合包含了这一大类中的所有树）

对于第一类，由于右儿子均相同，只需要找出集合类同类的树，然后递归处理左子树就行了。

对于第二类同第一类的处理办法，递归处理右子树。

对于第三类，可以证明如果第一类第二类全部满足，则第三类同样满足。

证明：设集合中所有以上三类构成的子集所生长得到的集合为 $S$。

对于任意一棵根节点有两个儿子的树 $T$，如果 $T$ 的左子树属于第一类所有左子树所生长得到的集合中，则 $T$ 可以表示成第一类所生长得到的集合内的一个元素通过仅生长右子树得到的树。右子树同理。

如果 $T$ 的左右子树均不包含在所对应集合内，则 $T$ 不一定属于 $S$，但根据几乎完备的定义，$T$ 的数量至多为不包含在内的左右子树数量的乘积，是有限的。

综上，我们只需要考虑前两类。（前两类有一个不得到满足直接返回不能，前两类全部满足第三类也同时会得到满足。）

总结：只需要将集合内的树分 6 类：

1. 当前节点无儿子。
2. 当前节点只有左儿子，递归处理左子树。
3. 当前节点只有右儿子，递归处理右子树。
4. 当前节点有左右儿子，右儿子没有儿子，递归处理左子树。
5. 当前节点有左右儿子，左儿子没有儿子，递归处理右子树。
6. 当前节点有左右儿子，两儿子均有儿子，直接不管。（这里和链树原理本质上是相同的）

实现：明显不能复制子树。可以存储当前树的编号以及此树对应当前节点位置的节点编号，然后递归处理。剩下怎么暴力怎么来。

时间复杂度：由于每棵树的每个节点至多遍历一次（除了一个节点有两个没有儿子的儿子的情况，但这种情况也只会遍历两次），故和总节点数同级，为 $O(\sum n)$。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

void Read(int &a) {
  a = 0;
  char c = getchar();
  while (c<'0'||c>'9') c = getchar();
  while (c>='0' && c<='9') {
    a = a*10+(c^'0');
    c = getchar();
  }
}

struct Node{
  int l;
  int r;
  Node(const int a = 0, const int b = 0){
    //cout << a << ',' << b << endl;
    l = a;
    r = b;
  }
};

struct Cur{
  int pos;
  int root;
  Cur(const int a = 0, const int b = 0){
    //cout << a << ',' << b << endl;
    pos = a;
    root = b;
  }
};

struct Tree{
  int n;
  vector<Node> tree;
  Tree() {
    int a, b;
    Read(n);
    for (int i = 0; i < n; i++) {
      Read(a);
      Read(b);
      tree.push_back(Node(a, b));
    }
  }
  int Type(int root) {
    root--;
    int l = tree[root].l;
    int r = tree[root].r;
    if (!(l||r)) return 0;
    if (!r) return 1;
    if (!l) return 2;
    l--;
    r--;
    if (!(tree[r].l || tree[r].r)) {
      if (!(tree[l].l || tree[l].r)) return 5;
      return 3;
    }
    if (!(tree[l].l || tree[l].r)) return 4;
    return 6;
  }
};

int _t;

int _m;
vector<Tree> _treeList;
vector<Cur> _oriList;

bool Wanbei(vector<Cur> &list) {
  if (list.empty()) return false;
  vector<Cur> next[4];
  int typ;
  int cur;
  int root;
  for (int i = 0; i < list.size(); i++) {
    cur = list[i].pos;
    root = list[i].root;
    typ = _treeList[cur].Type(root);
    switch(typ) {
    case 0:
      return true;
    case 1:
      next[0].push_back(Cur(cur, _treeList[cur].tree[root-1].l));
      break;
    case 2:
      next[1].push_back(Cur(cur, _treeList[cur].tree[root-1].r));
      break;
    case 3:
      next[2].push_back(Cur(cur, _treeList[cur].tree[root-1].l));
      break;
    case 4:
      next[3].push_back(Cur(cur, _treeList[cur].tree[root-1].r));
      break;
    case 5:
      next[2].push_back(Cur(cur, _treeList[cur].tree[root-1].l));
      next[3].push_back(Cur(cur, _treeList[cur].tree[root-1].r));
    }
  }
  for (int i = 0; i < 4; i++) {
    if (!Wanbei(next[i])) return false;
  }
  return true;
}

int main() {
//   freopen("surreal.in", "r", stdin);
//   freopen("surreal.out", "w", stdout);
  Read(_t);
  while (_t--) {
    Read(_m);
    for (int i = 0; i < _m; i++) {
      _treeList.push_back(Tree());
      _oriList.push_back(Cur(i, 1));
    }
    printf(Wanbei(_oriList)?"Almost Complete\n":"No\n");
    _treeList.clear();
    _oriList.clear();
  }
//   fclose(stdin);
//   fclose(stdout);
  return 0;
}
```

其实代码难度和 P5018 的 $O(nlogn)$ 做法没什么区别，都是暴力递归子树处理，但是思维难度难了亿点点，难度全部都在一定的想象力、构造能力以及严谨的逻辑思维。

---

## 作者：RainsAFO (赞：0)

[可能更好的阅读体验](https://www.cnblogs.com/treap/p/13849657.html)。

由于二叉树是无限的，我们优先考虑树的形态。

$1$： 如果有一类某种形态的树 ${T}$ 不能被生长得到，将它替换自己的叶子，所得到的 ${T'}$ 显然不能通过生长得到，以此类推，必有无穷多的树不能被生长得到。

$2$：现在考虑有什么形态的树有特殊的性质。

发现链状树 chain - tree（包括：只有左/右子树的树，有左、右子树但其中一个只有一个点的树）在样例 $2,3$ 中都有出现。

进一步分析得到以下性质：

**一棵树可以由深度等于它的一个 chain - tree 生长得到**。 

**一个集合不能生成的 chain - tree 数量有限时，它是几乎完备的**。

**只有 chain - tree 才对生长得到的集合有贡献**。

而chain - tree有一个良好的性质：我们对它做处理时（先不用知道怎么处理），只需要继续处理一边子树（这也保证了时间复杂度）。

考虑递归，把集合中的 chain- tree 分为四类（已经在上面叙述过了）

具体的，递归处理 siz 较大的子树，如果这四类都是几乎完备的，那么原集合也是几乎完备的，这是因为，所有能得到的 chain - tree 仅能被这四类生成。

特别地，如果集合里存在只有根节点的树，它是几乎完备的。



code：（参考了 [ix35](https://www.luogu.com.cn/user/113546) 的实现）

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e6 + 5;

int t , n , m;

vector <int> l[N] , r[N];

vector < pair<int , int> > _set;

bool dfs(vector < pair<int , int> > v){
	if(v.empty())
		return 0;
	vector < pair <int , int> > cl , cr , tl , tr;
	int siz = v.size();
	for(int i = 0; i < siz; i++){
		int x = l[v[i].first][v[i].second];
		int y = r[v[i].first][v[i].second];
		if(!x && !y)
			return 1;
		if(!x)
			cr.push_back(make_pair(v[i].first , y));
		if(!y)
			cl.push_back(make_pair(v[i].first , x));
		if(!l[v[i].first][x] && !r[v[i].first][x] && x && y)
			tr.push_back(make_pair(v[i].first , y));
		if(!l[v[i].first][y] && ! r[v[i].first][y] && x && y)
			tl.push_back(make_pair(v[i].first , x)); 
	}
	return dfs(cl) && dfs(cr) && dfs(tl) && dfs(tr);
}

int main(){
	cin >> t;
	while(t--){
		_set.clear();
		cin >> m;
		for(int i = 1; i <= m; i++){
			cin >> n;
			l[i].resize(n + 1);
			r[i].resize(n + 1);
			for(int j = 1; j <= n; j++)
				cin >> l[i][j] >> r[i][j];
			_set.push_back(make_pair(i , 1));
		}
		cout << ((dfs(_set)) ? ("Almost Complete") : ("No"))<< endl;
	}
}
```




---


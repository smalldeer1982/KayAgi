# [NOI2021] 机器人游戏

## 题目描述

小 R 有 $m$（$1 \le m \le 1000$）个机器人和 $m$ 张纸带，第 $i$（$1 \le i \le m$）个机器人负责对第 $i$ 张纸带进行操作。对于每张纸带，它们都被从左到右分成了 $n$（$1 \le n \le 32$）个格子，依次编号为 $0, 1, \ldots , n - 1$。每个格子有 $3$ 种状态：1. 格子上写有数字 $0$；2. 格子上写有数字 $1$；3. 格子是一个空格子。

在任意时刻，机器人**必须**站在纸带上的一个格子中。在设定好机器人在纸带上的初始位置后，第 $i$ 个机器人会依次执行预先设定的操作序列 $S_i$，操作由 `R`、`0`、`1`、`*` 四种字符组成，其中：

1. `R` 表示机器人向右走一格，如果右边没有格子，则机器人会原地爆炸；
2. `0` 表示如果机器人所在格子非空，则将该格子上的数字改为 $0$，否则不修改；
3. `1` 表示如果机器人所在格子非空，则将该格子上的数字改为 $1$，否则不修改；
4. `*` 表示如果机器人所在格子非空，则将格子上的数字 $x$ 改为 $1 - x$，否则不修改。

第 $i$ 张纸带的状态可以用一个长度为 $n$ 的序列表示，每个元素为 `0`、`1` 或 `-`（空格子），依次表示其每个格子的状态。第 $i$ 张纸带的初始状态称为机器人 $i$ 的输入 $X_i$，操作执行完成后纸带的状态称为机器人 $i$ 的输出 $Y_i$。注意，如果机器人爆炸了，那么这个机器人就没有输出。

可以发现，如果一个格子为空，那么机器人永远不会修改它。所以每个机器人都有如下特性：如果第 $i$ 个机器人所在的纸带上的**所有格子**都为空，那么它就不会执行任何操作，它的输出即为所有格子都为空。

现在小 R 给定了每一个机器人的输入 $X_i$（即每张纸带的初始状态）以及目标输出 $Y_i$。小 R 希望小 D 找到一个位置 $p$（$0 \le p < n$），使得**所有机器人**都能以其所在纸带的第 $p$ 个格子为初始位置，在不爆炸的情况下执行完所有操作，并且满足第 $i$ 个机器人的输出为 $Y_i$。

小 D 花了几毫秒解决了问题，现在他想知道，有多少个输入和输出的组合方式使得上述问题有解，即有多少种为每个机器人设定输入 $X_0, X_1, \ldots , X_{m - 1}$ 和目标输出 $Y_0, Y_1, \ldots , Y_{m - 1}$ 的方式，使得至少存在一个位置 $p$（$0 \le p < n$），使得所有机器人都能以其所在纸带的第 $p$ 个格子为起点，在不爆炸的情况下执行完所有操作，且满足第 $i$ 个机器人的输出为 $Y_i$。请你帮助小 D 解决这个问题，由于最终的答案可能很大，请你输出答案对 ${10}^9 + 7$ 取模后的余数。

两个组合方式不同当且仅当，存在至少一个机器人，它的输入或是目标输出在两个方式中不同。

## 说明/提示

**【样例解释 #1】**

| 方案编号 | 输入 $X_0$ | 目标输出 $Y_0$ | 可行初始位置 $p$ |
|:-:|:-:|:-:|:-:|
| $1$ | `--` | `--` | $0, 1$ |
| $2$ | `0-` | `1-` | $0$ |
| $3$ | `1-` | `1-` | $0$ |
| $4$ | `-0` | `-1` | $0$ |
| $5$ | `-1` | `-0` | $0$ |
| $6$ | `00` | `11` | $0$ |
| $7$ | `10` | `11` | $0$ |
| $8$ | `01` | `10` | $0$ |
| $9$ | `11` | `10` | $0$ |

表中 `-` 表示空格子，注意方案 $1$ 中的输入和输出中有两个空格子。

当输入全为空时，初始位置可以是 $0$ 或 $1$，因为根据题意，输入全为空时机器人不会执行任何操作。

当输入不全为空时，初始位置只能为 $0$，如果初始位置为 $1$ 机器人一定会爆炸。所以此时实际执行的操作是将第一格的数字改为 $1$，并将第二格的数字 $x$ 改为 $1 - x$。

**【样例解释 #2】**

可以用容斥原理来计算这个样例。

1. 初始位置 $p = 0$ 可以使得执行完所有操作后满足条件。那么第一个机器人的纸带 $0$ 号格子要么输入输出都是空，要么目标输出是 $1$（输入无所谓），所以有 $3$ 种方案；$1$ 号格子要么输入输出都是空，要么目标输出是 $0$，也是 $3$ 种方案；$2$ 号格子要么输入输出都是空，要么输入和目标输出相同（因为没有对该格子执行任何操作），同样是 $3$ 种方案，共 $27$ 种方案。第二个机器人的 $0$ 号格子要么输入输出都是空，要么输入和目标输出不同，是 $3$ 种方案，$1$ 号和 $2$ 号格子也都是 $3$ 种方案，共 $27$ 种方案。所以总共 $27 \times 27 = 729$ 种方案。
2. 初始位置 $p = 1$ 可以使得执行完所有操作后满足条件。那么第一个机器人的纸带三个格子都是 $3$ 种方案，其中 $0$ 号格子要么输入输出都为空，要么相同；$1$ 号格子要么输入输出都为空，要么目标输出是 $1$；$2$ 号格子的输入输出要么都为空，要么输出是 $0$，共 $27$ 种方案。第二个机器人的 $1$ 号格子要么输入输出都是空，要么输入和目标输出不同，是 $3$ 种方案；$0$ 号和 $2$ 号格子要么输入输出都为空，要么输入输出相同，也都是 $3$ 种方案，共 $27$ 种方案。总共 $27 \times 27 = 729$ 种方案。
3. 初始位置 $p = 2$ 可以使得执行完所有操作后满足条件。那么第一个机器人的纸带必须输入输出全为空（否则爆炸），只有 $1$ 种方案。第二个机器人是 $27$ 种方案，总共 $27$ 种方案。
4. 初始位置 $p = 0, 1$ 都满足条件。这要求第一个机器人的 $1$ 号格子输入输出都为空；$0$ 号格子的输入输出都为空或都为 $1$；$2$ 号格子的输入输出都为空或都为 $0$，所以第一个机器人的纸带有 $4$ 种方案。第二个机器人 $0$ 号格子和 $1$ 号格子都为空，$2$ 号格子有 $3$ 种方案，第二个机器人的 $0$ 号和 $1$ 号格子必须都为空，$2$ 号格子要么输入输出都为空，要么输入和输出相同，有 $3$ 种方案。总共 $12$ 种方案。
5. 初始位置 $p = 0, 2$ 都满足条件。那么第一个机器人的纸带必须输入输出全为空（否则爆炸），只有 $1$ 种方案。第二个机器人 $0$ 号和 $2$ 号格子都为空，$1$ 号格子有 $3$ 种方案。总共 $3$ 种方案。
6. 初始位置 $p = 1, 2$ 都满足条件。那么第一个机器人的纸带必须输入输出全为空，只有 $1$ 种方案。第二个机器人 $1$ 号和 $2$ 号格子都为空，$0$ 号格子有 $3$ 种方案。总共 $3$ 种方案。
7. 初始位置 $p = 0, 1, 2$ 都满足条件。那么两个机器人的输入输出必须都为空，总共 $1$ 种方案。

根据容斥原理，最后的答案为 $729 + 729 + 27 - 12 - 3 - 3 + 1 = 1468$。

**【数据范围】**

对于所有测试点：$1 \le n \le 32$，$1 \le m \le 1000$，$1 \le \lvert S_i \rvert \le 100$。

| 测试点编号 | $n \le$ | $m \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $1$ | $1$ | 无 |
| $3$ | $8$ | $1$ | 无 |
| $4$ | $16$ | $1$ | 无 |
| $5 \sim 6$ | $32$ | $1$ | 无 |
| $7$ | $16$ | $5$ | 无 |
| $8 \sim 10$ | $32$ | $5$ | 无 |
| $11 \sim 12$ | $16$ | $1000$ | 无 |
| $13 \sim 15$ | $32$ | $1000$ | A |
| $16 \sim 21$ | $32$ | $1000$ | B |
| $22 \sim 25$ | $32$ | $1000$ | 无 |

特殊限制 A：操作序列中不存在 `R`。

特殊限制 B：每个操作序列中，`R` 的数量至多 $15$ 个。

## 样例 #1

### 输入

```
2 1
1R*
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3 2
1R0
*
```

### 输出

```
1468
```

## 样例 #3

### 输入

```
见附件中的 robot/robot3.in```

### 输出

```
见附件中的 robot/robot3.ans```

## 样例 #4

### 输入

```
见附件中的 robot/robot4.in```

### 输出

```
见附件中的 robot/robot4.ans```

# 题解

## 作者：zhoukangyang (赞：34)

场上题目看错两次，day2 成功爆炸 /ll

[验体读阅的好更](https://www.cnblogs.com/zkyJuruo/p/15074895.html)

**本文下标从 1 开始**

## 算法 1

我会容斥！

先把问题转化成统计不存在一个合法位置的方案数。

接着统计有钦定 $k$ 个合法的，其他随便的方案数。其容斥系数为 $(-1)^k$。

在一次机器人的操作后，所有输入的数在经过机器人在操作后的输出都可以表示成 $0$，$1$，$x$ 或 $1-x$ 的形式（$x$ 是这个位置上输入的数）

考虑一个纸带：对于一个被钦定的每一个位置，要求输入经过这个机器人操作之后一定等于输出。仍然把输出表示成输入的形式，只不过这个输出可以以多种方式被输入表达。

对于每一个位置分类讨论：

1. 如果这个位置上表示成的结果 ``既有 0 又有 1`` 或 ``既有 x 又有 1-x``：输入输出都为空。方案数为 $1$。
2. 如果不满足条件 $1$，这个位置上表示成的结果 ``有 0 或 1`` 且  ``有 x 或 1-x``：输入输出都为空，否则输入输出就被固定了。方案数为 $2$。
3. 条件 1，2 都不满足：对于每一个输入都对应一个唯一的输出，方案数为 $3$。

这个纸带上每一个位置就是独立的了，最后把每个位置的答案乘起来即可。

注意机器人爆炸的情况。

时间复杂度 $\Theta(n^22^nm)$，期望得分 $20$。

[code](https://loj.ac/s/1203294)

## 算法 2

我会优化算法1！

对于第 $i$ 个机器人，考虑实际进行修改了的位置只有 ``R`` 的个数个（设为 $c_i$）。

考虑枚举最后一个钦定的位置在哪里（设为 $r$）。这样就可以知道哪些机器人是爆炸的了：有且仅有 $c_i > n - r$ 的爆炸了。

然后对于前 $r$ 个位置 $\rm DP$。状压记录前面的元素中哪些元素被钦定了。钦定了一个位置就给答案乘上 $-1$。在 $\rm DP$ 的过程中，做到第 $i$ 个数就把第 $i$ 个位置的贡献（即输入输出方案数）统计掉。

但我们发现并不是所有元素都需要记录下来的：只用记录与当前位置距离不超过 $n - r$ 的和与当前位置距离超过 $n-r$ 的位置中有没有 $1$ 即可。

最后再处理一下位置超过 $r$ 的元素即可。

时间复杂度 $\Theta(n^2m2^{n/2})$，期望得分 $48$。

[code](https://loj.ac/s/1203297)

## 算法 3

我会 bitset！

发现我们统计一个位置的贡献的时候，只有 ``是否有...`` 有用。所以考虑用 $\rm bitset$ 同时处理一堆纸条是否有 ``0，1，x 和 1-x``。

这样复杂度就降到了 $\Theta(\frac{n^2m2^{n/2}}{\omega})$，常数巨大。但是还可以优化。

其实我们要求的是类似于一个子集中的 $\rm bitset$ 的子集并，这个东西仍然可以优化，就是类似于 ``f[x] = f[x & -x] | f[x ^ (x & -x)]``。

时间复杂度 $\Theta(\frac{nm2^{n/2}}{\omega})$，期望得分 $100$。

[code](https://loj.ac/s/1203300)

感觉讲的有些抽象，不过相信大家想到算法2 之后就会做了。

-------------

**祝大家学习愉快！**

---

## 作者：mzgwty (赞：17)

更新了一下，那天晚上因为太赶，DP 的那部分好像不是很能让人理解，然后出现了一些明显的错误，引起了一些不必要的疑惑，在这里说句抱歉

首先声明，这是一个来自场外选手的题解，然后其目的是为了能让大部分人看懂，因为这题考察的完全是 noip 范围内的东西，所以个人认为很有价值，值得好好说一下

当然这也不算自己的题解，其实是读懂了某个场内选手的代码之后写出来的东西

首先来看最基础的容斥该怎么做

我们先预处理出来每个机器人向右移动 $i$ 步后会对那个位置造成什么改变，把这个改变记作 $v_i$

若 $v_i=0$，表示当前位置不用变化

若 $v_i=1$，表示当前位置需要从 $0$ 变为 $1$ 或者从 $1$ 变为 $0$

若 $v_i=2$，表示当前位置为 $0$

若 $v_i=3$，表示当前位置为 $1$

然后这段预处理大概长这样

```cpp
v[0]=0;
for(int i=0 ; i<len ; ++i)
	if(s[i]=='R') v[++p]=0;
	else if(s[i]=='0') v[p]=2;
	else if(s[i]=='1') v[p]=3;
	else v[p]^=1;
```

然后维护一个 $mask_i$，表示 $v=i$ 的位置的集合，可以用一个 long long 类型的变量存下来

然后对于每个位置 $i$，维护一个 $msk_j$，表示从这个点出发时每种 $v_j$ 形成的集合

然后由于有在这个点右侧的位置，也有这个点根本到达不了的位置，这些位置我们就给它赋成 $0$ 

然后我们就可以求出所有 $2^n$ 种选法每种 $v$ 所对应的位置集合

```cpp
for(int i=0 ; i<4 ; ++i) mask[i]=0;
for(int i=0 ; i<p ; ++i) mask[v[i]]|=1ull<<i;
for(int S=0 ; S<(1<<n) ; ++S)
	for(int i=0 ; i<4 ; ++i)
		msk[S][i]=0;
for(int i=0 ; i<n ; ++i) {
	for(int j=0 ; j<4 ; ++j) msk[1<<i][j]=mask[j]<<(l-i-1);
	msk[1<<i][0]|=(1ull<<(n-1-i))-1,msk[1<<i][0]|=(1ull<<n)-(1ull<<(n-1-i+p));
}
for(int S=0 ; S<(1<<n) ; ++S)
	for(int j=0 ; j<4 ; ++j)
		msk[S][j]=msk[S^(S&-S)][j]|msk[S&-S][j];
```

然后我们就需要求出每种状态在当前这一个机器人时的方案数

注意：这里的 $i$ 指的不是从左往右数的第 $i$ 个，而是从右往左数第 $i$ 个，至于为什么，待会儿会说

不难发现，如果 $msk_{S,0}$ 和 $msk_{S,1}$ 有交集，那么它们交集这些位置必须为空，因为不可能存在一个数既是 $0$ 又是 $1$。$msk_{S,2}$ 与 $msk_{S,3}$ 同理。记这个为 $emp$

然后如果某个位置既被 $msk_{S,0}$ 或者 $msk_{S,1}$ 包含，又被 $msk_{S,2}$ 或者 $msk_{S,3}$ 包含，那么这个位置只能选 $0$ 或者只能选 $1$，记这个为 $rct$

然后 $rct$ 与 $emp$ 取个并集得到被限制了的位置

这样在 $emp$ 中的位置只能有 $1$ 种选法，就是空格子，在 $rct$ 中而不在 $emp$ 中的位置则有 $2$ 种选法，剩下的位置则有 $3$ 种选法，那么用 $2$ 的次幂乘上一个 $3$ 的次幂就是这个状态在当前这行的方案数了，把每种状态在每一行的方案乘起来就是总方案数，然后按照题面上的东西做一个容斥就行了

```cpp
for(int S=0 ; S<(1<<l) ; ++S) {
	emp[S]=(msk[S][0]&msk[S][1])|(msk[S][2]&msk[S][3]);
	rct[S]=(msk[S][0]|msk[S][1])&(msk[S][2]|msk[S][3]);
	rct[S]|=emp[S];
	int c1=get(emp[S]),c2=get(rct[S]);
	nw[S]=1ll*pw3[n-c2]*pw2[c2-c1]%P,f0[S]=1ll*f0[S]*nw[S]%P;
}
```

然后这就是一个 $m2^n$ 的做法，$n \le 16$ 的情况已经完全能过了。

然后我们先观察特殊性质 $A,B$，发现这两个性质是一个常见的状压DP，直接把后面 $p$ 个位置是否被选择为可行的位置压成新的一维。

当然这不是重点

大型比赛的部分分大部分都会告诉你正解的方向，这道题也不例外，说明正解需要用到状压 DP

观察数据范围，$n\le32$，这个数是 $32$ 而不是 $70,100$ 之类常见 $n^k$ 算法的标准范围，我们可以考虑折半，把左一半先弄出来再来想右半部分该怎么弄。

此时左半部分变成了 $n\le16$，可以直接使用刚才提到的容斥的方法计算，但计算出来的所有方案必定至少包含左半部分的一个位置，那么我们接下来需要计算不包含左半部分位置的方案数

此时先维护两个新的数组 $f1_{i,S},f2_{i,S}$

令左半部分最右侧的位置为 $pos$

$f1_{i,S}$ 表示左半部分从右向左第 $i$ 个位置在它后面 $i$（包含它）个位置被选择的状态为 $S$ 时 $pos$ 能够在操作后保持不变的方案数 

$f2_{i,S}$ 左半部分从右向左第 $i$ 个位置在它后面 $i$（包含它）个位置被选择的状态为 $S$ 时的总方案数 

然后这个 $S$ 会影响到 $pos$ 位置可选的方案数,所以要更新一下

现在你应该知道刚才提到的 $i$ 是从右往左而不是从左往右是为什么了吧

这一部分更新大概如下

```cpp
for(int i=p ; i<=h2 ; ++i)
	for(int S=0 ; S<(1<<i) ; ++S)
		f2[i][S]=1ll*f2[i][S]*nw[S]%P;
for(int S=0 ; S<(1<<h1) ; ++S)
	emp[S]|=msk[S][1],
	rct[S]|=msk[S][1]|msk[S][2]|msk[S][3],
	nw[S]=3-(rct[S]>>(h1-1)&1)-(emp[S]>>(h1-1)&1);
for(int i=p ; i<=h2 ; ++i)
	for(int S=0 ; S<(1<<i) ; ++S)
		f1[i][S]=1ll*f1[i][S]*nw[S]%P;
```

自己可以理解一下再进入下一步

然后就进行我们的状压 DP


令 $p$ 为当前要求的那个 $i$，即整个序列从右往左第 $i$ 个位置,我们要求这个位置后面的位置都不被选而它被选的方案数；这个 $i$ 实际上可以用上方左半部分那个 $i$ 替换一下,所以看到下面的 $f1_{p,S}$ 不要吃惊

首先我们先算出初始的方案数，即 $pos$（注意是 $pos$ 不是 $p$）强制被选的方案数

这可以用一个容斥完成

```cpp
for(int S=0 ; S<(1<<p) ; ++S) if(S&1)
	if(cnt[S]&1) Explus(res,f2[p][S]); 
	else Exminus(res,f2[p][S]);
```

然后根据对于每个 $i\in[0,n-2p),[n-2p,n-p),[n-p,n)$ 分类讨论一下
（这个 $i$ 和之前的 $i$ 不是同一个含义）

大体上说 DP 方程应该长这样（用了一个滚动数组）

```cpp
g[t^1][S]=1ll*exminus(g[t][S>>1],g[t][S>>1|(1<<(p-1))])*f1[p][S]%P;
```

由于 $i\in[0,n-2p)$ 枚举时任何状态都不包括 $p$，可能会使 $p$ 这个位置没被选到，那么就需要减掉一些方案，用多个 $f1_{p,0}$ 的乘积实现，因为你不能选上 $pos$，你得把含有 $pos$ 的减掉

```cpp
for(int i=0 ; i<=n-2*p ; ret=1ll*ret*f1[p][0]%P,++i,t^=1)
	for(int S=0 ; S<(1<<p) ; ++S)
		g[t^1][S]=1ll*exminus(g[t][S>>1],g[t][S>>1|(1<<(p-1))])*f1[p][S]%P;
Exminus(g[t][0],ret);
```

对于 $i\in[n-p,n)$，由于 $S$ 表示的是后面 $p$ 个数的状态，所以除非 $i=n-p$，否则当前位置不能被选

所以又是这样

```cpp
for(int i=n-p ; i<n ; ++i,t^=1)
	for(int S=0 ; S<(1<<p) ; ++S)
		if((S&1)==(i==n-p)) g[t^1][S]=1ll*exminus(g[t][S>>1],g[t][S>>1|(1<<(p-1))])*f1[p][S]%P;
		else g[t^1][S]=0;
```

结尾又是一个容斥得出最终方案数

```cpp
for(int S=0 ; S<(1<<p) ; ++S)
	if(cnt[S]&1) Explus(res,g[t][S]);
	else Exminus(res,g[t][S]);
```

终于完了！！！

希望能帮助大家qwq,上一次写得太糊了

放下代码

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;

typedef unsigned long long ull;

const int P=1e9+7,N=35,B=65536,M=1005,L=105;

int h1,h2;
int n,m,mr,nr[M],ln[M],cnt[B];
int v[L];
char s[L];

int pw2[N],pw3[N];
ull mask[4],msk[B][4];//0:不变;1:变;2:为 0;3:为 1 
ull emp[B],rct[B];//emp:必须为空的位置;rct:有限制的位置 

int nw[B],f0[B];//nw:当前行状态为 S 的方案数;f0:所有行状态为 S 的方案数 
int f1[N][B],f2[N][B];
//f1[i][S]:左半部分从右向左第 i个位置在它后面 i(包含它)个位置被选择的状态为 S时左半部分最右侧的点能够在操作后保持不变的方案数 
//f2[i][S]:左半部分从右向左第 i个位置在它后面 i(包含它)个位置被选择的状态为 S时的总方案数 
int g[2][B];//开个滚动数组，以免爆炸 

inline int exminus(const int &a,const int &b) {int x=a-b;return x<0?x+P:x;}
inline int explus(const int &a,const int &b) {int x=a+b;return x<P?x:x-P;}
inline void Exminus(int &a,const int &b) {if((a-=b)<0) a+=P;}
inline void Explus(int &a,const int &b) {if((a+=b)>=P) a-=P;}
inline int mul2(int a) {Explus(a,a);return a;}
inline int mul3(int a) {Explus(a,mul2(a));return a;}

inline int get(ull S) {return cnt[S>>h1]+cnt[S&((1<<h1)-1)];}

inline int calc(int p) {
	int res=0;
	for(int S=0 ; S<(1<<p) ; ++S) if(S&1)
		if(cnt[S]&1) Explus(res,f2[p][S]); 
		else Exminus(res,f2[p][S]);
	for(int S=0 ; S<(1<<p) ; ++S) g[0][S]=0;
	int t=0,ret=1;g[0][0]=1;
	for(int i=0 ; i<=n-2*p ; ret=1ll*ret*f1[p][0]%P,++i,t^=1)
		for(int S=0 ; S<(1<<p) ; ++S)
			g[t^1][S]=1ll*exminus(g[t][S>>1],g[t][S>>1|(1<<(p-1))])*f1[p][S]%P;
	Exminus(g[t][0],ret);
	for(int i=n-2*p+1 ; i<n-p ; ++i,t^=1)
		for(int S=0 ; S<(1<<p) ; ++S)
			g[t^1][S]=1ll*exminus(g[t][S>>1],g[t][S>>1|(1<<(p-1))])*f1[p][S]%P;
	for(int i=n-p ; i<n ; ++i,t^=1)
		for(int S=0 ; S<(1<<p) ; ++S)
			if((S&1)==(i==n-p)) g[t^1][S]=1ll*exminus(g[t][S>>1],g[t][S>>1|(1<<(p-1))])*f1[p][S]%P;
			else g[t^1][S]=0;
	for(int S=0 ; S<(1<<p) ; ++S)
		if(cnt[S]&1) Explus(res,g[t][S]);
		else Exminus(res,g[t][S]);
	return res;
}

int main() {
	freopen("robot.in","r",stdin);
	freopen("robot.out","w",stdout);
	scanf("%d%d",&n,&m);
	h1=(n+1)>>1,h2=n-h1;
	for(int S=0 ; S<(1<<h1) ; ++S) cnt[S]=cnt[S>>1]+(S&1);
	for(int S=0 ; S<(1<<h1) ; ++S) f0[S]=1;
	for(int i=1 ; i<=h2 ; ++i)
		for(int S=0 ; S<(1<<i) ; ++S)
			f1[i][S]=f2[i][S]=1;
	pw2[0]=pw3[0]=1;
	for(int i=1 ; i<=n ; ++i) pw2[i]=mul2(pw2[i-1]),pw3[i]=mul3(pw3[i-1]);
	for(int o=0 ; o<m ; ++o) {
		scanf("%s",s);
		int len=strlen(s),p=0;
		v[0]=0;
		for(int i=0 ; i<len ; ++i)
			if(s[i]=='R') v[++p]=0;
			else if(s[i]=='0') v[p]=2;
			else if(s[i]=='1') v[p]=3;
			else v[p]^=1;
		if((++p)>n) continue ;
		for(int i=0 ; i<4 ; ++i) mask[i]=0;
		for(int i=0 ; i<p ; ++i) mask[v[i]]|=1ull<<i;
		int l=min(h1,n-p+1);
		for(int S=0 ; S<(1<<l) ; ++S)
			for(int i=0 ; i<4 ; ++i)
				msk[S][i]=0;
		for(int i=0 ; i<l ; ++i) {
			for(int j=0 ; j<4 ; ++j) msk[1<<i][j]=mask[j]<<(l-1-i);
			msk[1<<i][0]|=(1ull<<(l-1-i))-1;
			msk[1<<i][0]|=(1ull<<n)-(1ull<<(l-1-i+p));
		}
		for(int S=0 ; S<(1<<l) ; ++S)
			for(int j=0 ; j<4 ; ++j)
				msk[S][j]=msk[S^(S&-S)][j]|msk[S&-S][j];
		for(int S=0 ; S<(1<<l) ; ++S) {
			emp[S]=(msk[S][0]&msk[S][1])|(msk[S][2]&msk[S][3]);
			rct[S]=(msk[S][0]|msk[S][1])&(msk[S][2]|msk[S][3]);
			rct[S]|=emp[S];
			int c1=get(emp[S]),c2=get(rct[S]);
			nw[S]=1ll*pw3[n-c2]*pw2[c2-c1]%P,f0[S]=1ll*f0[S]*nw[S]%P;
		}
		if(p>h2) continue ;
		for(int i=p ; i<=h2 ; ++i)
			for(int S=0 ; S<(1<<i) ; ++S)
				f2[i][S]=1ll*f2[i][S]*nw[S]%P;
		for(int S=0 ; S<(1<<h2) ; ++S) {
			emp[S]|=msk[S][1];
			rct[S]|=msk[S][1]|msk[S][2]|msk[S][3];
			nw[S]=3-(rct[S]>>(h1-1)&1)-(emp[S]>>(h1-1)&1);
		}
		for(int i=p ; i<=h2 ; ++i)
			for(int S=0 ; S<(1<<i) ; ++S)
				f1[i][S]=1ll*f1[i][S]*nw[S]%P;
	}
	int res=0;
	for(int S=1 ; S<(1<<h1) ; ++S)
		if(cnt[S]&1) Explus(res,f0[S]);
		else Exminus(res,f0[S]);
	for(int i=1 ; i<=h2 ; ++i) Explus(res,calc(i));
	printf("%d",res);
	return 0;
}
```

---

## 作者：Miko35 (赞：16)

FZzzz 亲口说，这题是普及题，大家知道该在评论区打什么了吧。

---

### 题意

有 $m$ 个长度为 $n$ 的序列，序列上每个位置可以是 $0/1$ 或空格子。第 $i$ 个序列上有一个机器人，其操作序列为 $S_i$，所有机器人的起点都是其所在序列的第 $p$ 个格子。每个机器人会执行如下操作对序列进行修改：

- 如果它所在序列全是空格子，则不会执行后面的任何操作。

- 否则它会按顺序执行操作序列：`R` 表示往右走一步，如果走出去了就爆炸；`0`/`1` 表示把脚下格子改成 $0/1$；`*` 表示把当前格子异或 $1$。（如果脚下是空格子则不会产生任何影响）

对于一个初始序列状态、最终序列状态的二元组 $(A,B)$，如果存在一个 $p$ 使得机器人在初始状态 $A$ 上进行修改之后，最终达到状态 $B$ 且中途没有爆炸，则称之合法方案。

求合法方案总数对 $10^9+7$ 取模的结果。$1 \leq n \leq 32$，$1\leq m \leq 1000$，$1 \leq |S_i| \leq 100$。

### 题解

首先你看到了这个巨长无比的样例解释，它全篇讲了一句话就是对起点集合容斥：枚举一个起点集合 $S$，计算使 $S$ 内起点都合法的二元组个数，容斥系数 $(-1)^{|S|+1}$。怎么计算捏，ob 一下可以发现，一个格子初始是 $x$，最终它只有四种情况：$0/1$，或者是 $x/1-x$。然后一个起点是合法的，相当于限制了某些格子最后一定是这四种中的某个。分类讨论一下：

- 如果走出去了，则整个序列所有格子贡献均为 $1$（只能全填空的保命）；
- 如果同时拥有前两种或者后两种，说明这一格只能空，贡献 $1$；
- 如果只拥有四种中的一种，一种初始对应唯一一种终止，贡献为 $3$；
- 如果前俩里面有一个，后俩里面也有一个，就确定了这上面填的必须是个数，贡献为 $2$；
- 一种都没有？不太现实，一个起点会给所有格子加一条限制。

然后你暴力枚举得到了 $O(n^2m2^n)$，改成 DFS 枚举得到了 $O(nm2^n)$，能拿到 $28$ 分的好成绩。$n=32$ 非常折半，考虑怎么把指数砍一半，有个关键性质就是：如果存在 $\ge k$ 的起点，判掉走出去的情况，剩下序列的最大位移一定 $\leq n-k$。这启示我们对最右边的合法起点的位置 $P$ 分类讨论：

- $P \leq \dfrac n2$，直接用刚刚的暴力做，$O(nm2^{n/2})$。
- 反之最大位移 $\leq \dfrac n2$，也就是说起点 $p$ 只会对 $\left[p,p+\dfrac n2\right]$ 产生各种各样的限制，其他的点限制都是不变。所以若想知道一个格子的具体限制是什么，只需要知道前 $\dfrac n2$ 个位置是否作为起点，以及其他位置有没有作为起点的就行（如果有，这个点就会多一条不变的限制）。

枚举最后一个起点的位置，用 $dp_{i,S,0/1}$ 记录做到了第 $i$ 位，前面若干位的状态为 $S$，更前面有没有点作为起点，的方案数带上容斥系数之后的结果，转移时我需要枚举所有序列的当前格来计算贡献。由于每次状压的数量指数级倍增，故复杂度 $O(nm2^{n/2})$。

考虑使用 bitset 优化这个过程。瓶颈无非是求对于一个给定的起点集合，所有序列的第 $x$ 个数的贡献，这个总状态是 $O(n2^{n/2})$ 的。预处理一个 bitset $b_{i}$ 表示距离起点为 $i$ 的数拥有的限制，进而每次预处理出 $t_S$ 表示距离起点集合为 $S$ 的限制，单次转移 $O\left(\dfrac m\omega\right)$，时间复杂度 $O\left(\dfrac {nm2^{n/2}}{\omega}\right)$。

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a,i##i=b;i<=i##i;++i)
using namespace std;
const int N=34,S=1<<16|5,M=1007,mod=1e9+7;
int n,m,e,E,sf[M],st,L,vl[S],ul[S],p2[M],p3[M];
long long f[S][2],g[S][2],dp[S],ans;
char s[M];
bitset<M>R,s1,s2,s3,rst[N];
struct node{
	bitset<M>b[4];
	node operator|(node x)const{FOR(i,0,3)x.b[i]|=b[i];return x;}
	int val(){
		s3=R&~((b[0]&b[1])|(b[2]&b[3])),s1=s3&(b[0]^b[1]),s2=s3&(b[2]^b[3]);
		int rs=s1.count()+s2.count(),cm=(s1&s2).count();
		return 1ll*p2[cm]*p3[rs-2*cm]%mod;
	}
}h[N],t[S],Z;
int chg(node x){return x.b[2].set(),x.val();}
void work(int p,int l){
	R=rst[p],memset(f,0,sizeof f),**f=-1,L=(1<<l)-1;
	FOR(i,0,L)vl[i]=t[i].val(),ul[i]=chg(t[i]);
	FOR(j,1,n){
		FOR(i,0,L)g[i][0]=g[i][1]=0;
		FOR(i,0,L){
			int k=i<<1,w=k&L,o=(k!=w),*sd=(o?ul:vl);
			if(j!=p){
				if(j<p)(g[w][o]+=f[i][0]*ul[w])%=mod;
				else (g[w][o]+=f[i][0]*sd[w])%=mod;
				(g[w][1]+=f[i][1]*ul[w])%=mod;
			}
			if(j<=p){
				++w;
				if(j<p)(g[w][o]-=f[i][0]*ul[w])%=mod;
				else (g[w][o]-=f[i][0]*sd[w])%=mod;
				(g[w][1]-=f[i][1]*ul[w])%=mod;
			}
		}
		swap(f,g);
	}
	FOR(i,0,L)(ans+=f[i][0]+f[i][1])%=mod;
}
signed main(){
	scanf("%d%d",&n,&m),*p2=*p3=1,e=n/2,E=(1<<e)-1;
	FOR(i,1,m){
		scanf("%s",s+1),st=2,Z.b[2].set(i);
		p2[i]=p2[i-1]*2%mod,p3[i]=p3[i-1]*3ll%mod;
		FOR(j,1,strlen(s+1)){
			if(s[j]=='R')h[sf[i]++].b[st].set(i),st=2;
			else if(s[j]=='*')st^=1;
			else st=s[j]-'0';
		}
		h[sf[i]].b[st].set(i);
		FOR(j,sf[i]+1,n)h[j].b[2].set(i);
	}
	FOR(p,1,n)FOR(i,1,m)if(sf[i]+p<=n)rst[p][i]=1;
	*dp=-1;
	FOR(i,1,E)dp[i]=-dp[i&(i-1)];
	FOR(p,1,n){
		FOR(i,1,E){
			int dis=p-__lg(i&-i)-1;
			t[i]=t[i&(i-1)]|(dis<0?Z:h[dis]);
		}
		FOR(i,1,E)R=rst[__lg(i)+1],(dp[i]*=t[i].val())%=mod;
	}
	FOR(i,1,E)(ans+=dp[i])%=mod;
	FOR(i,1,S-6)t[i]=t[i&(i-1)]|h[__lg(i&-i)];
	FOR(i,e+1,n)work(i,n-i+1);
	printf("%lld",(ans+mod)%mod);
	return 0;
}
```


---

## 作者：周子衡 (赞：14)

首先，观察到每个机器人对每个位置的操作本质上仅有 $4$ 种：赋 $0$ / 赋 $1$ / 不变 / 取反。方便起见，下文用 0/1/2/3 代指这 $4$ 种操作。我们从每个输入字符串中提取出关键序列 $v_0v_1...$，表示若将机器人放在第 $p$ 格，它会对 $p+i$ 格执行操作 $v_i$。记第 $j$ 个机器人总共访问的格子数为 $r_j$，数值上它等于 $S_j$ 中 `R` 的个数加 $1$。

对于 $n\leq 16$ 的情形，样例 2 的解释中已经给出了详尽的容斥原理的解析：我们枚举一个开始位置的子集 $P$，对每个机器人计算有多少种输入输出使得 $P$ 中的位置都合法。这是简单的：对 $P$ 中的每个元素 $p$，事实上它要求若干位置上进行对应的操作后得到预期的元素。我们不妨记布尔数组 $F_{i,j}$ 表示 $i$ 这一位是否得到了一个 $j$ 标记，如果 $F_{i,0}=F_{i,1}=1$ 或 $F_{i,2}=F_{i,3}=1$，那么显然 $i$ 这一位只能填空格；否则计算 $F_{i,0\sim 3}$ 中 $1$ 的个数，若为 $2$，说明不填空格的情况仅 $1$ 种，对答案贡献为 $2$；若为 $1$，说明不填空格的情况有 $2$ 种，对答案贡献为 $3$。注意到确定一个起始位置后，不在该机器人行走区间里的位置隐性受到了一个 $2$ 限制，故不可能没有 $1$。这样可以得到一个 $O(nm2^n)$ 做法，可获得 $28$ 分。

观察到题目限制 $n\leq 32$，恰是 $16$ 的两倍，我们猜想是分大小两类计算来平衡复杂度。进一步观察，对某个 $r_j$，$P$ 中的元素若大于 $n-r_j$，那么这个机器人必会爆炸，只有全空一种情况。这启示我们：对 $r_j \geq \dfrac{n}{2}$ 的 $j$，$P$ 仅在 $2^{n-r_j}\leq 2^{\frac{n}{2}}$ 个位置有非 $1$ 值，这些可以仿照第二段的算法加以处理。我们进一步来考虑 $r_j < \dfrac{n}{2}$ 的情形。

我们依旧考虑容斥。可以发现，在确定了 $P$ 之后，一个位置 $i$ 对答案的贡献仅仅和 $P$ 中是否包含 $i-r_j+1,...,i$ 这 $r_j$ 个元素有关，总情况数仅有 $2^{r_j} \leq 2^{\frac{n}{2}}$ 种。我们可以预处理出一个数组 $C_{j,S}$，表示对第 $j$ 个机器人来说，某个元素前面 $r_j$ 个元素的选取情况恰为 $S$ 时，该元素的贡献系数。我们从 $C$ 数组可以进一步从后往前 DP，得出 $A_{j,S}$，表示 $j$ 的前 $r_j$ 个元素选取结果为 $S$ 时的总贡献系数。将 $A$ 与 $r_j \geq \dfrac{n}{2}$ 的情况结合，便可求出原问题的答案。

---

## 作者：zhouhuanyi (赞：13)

链接:https://www.luogu.com.cn/problem/P7740

题目描述：有 $m$ 个机器人和 $m$ 张纸袋，每个纸袋有 $n$ 个格子，每个格子可能是空，写有数字 $0$ 或写有数字 $1$ 。每一个机器人有一个操作序列，操作序列的每个字符均为 $R,0,1,*$ 之一。
其中:

$R$ 表示机器人向右走一格(如果右边没有格子，则机器人会原地爆炸)；$0$ 表示如果机器人所在格子非空，则将该格子上的数字改为 $0$，否则不修改；$1$ 表示如果机器人所在格子非空，则将该格子上的数字改为 $1$，否则不修改；$* $表示如果机器人所在格子非空，则将格子上的数字 $x$ 改为 $1-x$，否则不修改。

我们称第 $i$ 张纸带的初始状态称为机器人 $i$ 的输入 $X_{i}$ ，操作执行完成后纸带的状态称为机器人$i$的输出$Y_{i}$。若 $X_{i}$ 均为空，则机器人 $i$ 不会执行任何操作。你需要求出有多少种本质不同的每个机器人设定输入 $X_{0},X_{1},...,X_{m-1}$ 和目标输出的方式 $Y_{0},Y_{1},...,Y_{m-1}$ 满足其存在一个$p$使得所有机器人都能以其所在纸带的第 $p$ 个格子为起点,在不爆炸的情况下执行完所有操作，且满足第 $i$ 个机器人的输出为  $Y_{0},Y_{1},...,Y_{m-1}$，请输出答案对$10^9+7$取模的结果。

题解：注意到 $n\leq 32$ ，考虑子集容斥。

考虑每一个机器人进行操作带来的影响，则对于一个输入 $A$ ，对于输出 $B$ ，要么 $B_{i}=0$，要么 $B_{i}=1$，要么 $B_{i}=1-A_{i}$，要么 $B_{i}=A_{i}$。注意到它其实确定了 $A,B$ 之间的一些关系。我们定义一个运算域，将其设为数 $(?,0)$，$(?,1)$，$(x,x)$，$(x,1-x)$，定义合并运算符 $*$。
则其进行运算可以得到 $(?,?)$，$(0,0)$，$(0,1)$，$(1,0)$，$(1,1)$，$(?,0)$，$(?,1)$，$(x,x)$，$(x,1-x)$，(不合法) $10$ 种数。

将运算关系列出下表：

$*$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$

$0$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$

$1$ $1$ $1$ $9$ $9$ $9$ $1$ $9$ $1$ $9$ $9$

$2$ $2$ $9$ $2$ $9$ $9$ $9$ $2$ $9$ $2$ $9$

$3$ $3$ $9$ $9$ $3$ $9$ $3$ $9$ $9$ $3$ $9$

$4$ $9$ $9$ $9$ $4$ $9$ $4$ $4$ $9$ $9$ $9$

$5$ $5$ $5$ $9$ $3$ $9$ $5$ $9$ $5$ $3$ $9$

$6$ $6$ $9$ $2$ $9$ $4$ $9$ $6$ $4$ $2$ $9$

$7$ $7$ $1$ $9$ $9$ $4$ $1$ $4$ $7$ $9$ $9$ 

$8$ $8$ $9$ $2$ $3$ $9$ $3$ $2$ $9$ $8$ $9$

$9$ $9$ $9$ $9$ $9$ $9$ $9$ $9$ $9$ $9$ $9$

可以发现该表中$9*x=9$，$0*x=x$，且$0$，$1$，$2$，$3$，$4$，$9$可以形成一个独立的运算域，$1$，$2$，$3$，$4$任意两个$*$起来均为$9$。那么我们可以猜想其与或运算一一对应，即将 $9$ 看成 $1111$，$0$ 看成 $0000$，$1$ 看成 $1110$，$2$ 看成 $1011$，$3$ 看成 $0111$，$4$ 看成 $1101$，那么可将 $6$ 看成 $0110$，$7$ 看成 $1001$，$8$ 看成 $1100$，$9$ 看成 $0011$，经检验可以发现其的确满足条件。而最终每一个数的权值则可以写为 $popcnt_{0}(x)+1$。可将每个机器人从每个位置开始的操作序列压成一个 $\texttt{unsigned int 128}$，令第$i$个机器人的从第$j$个位置开始的组成的数形成的 $\texttt{unsigned int 128}$为$f_{i,j}$,则每个 $\texttt{unsigned int 128}$的贡献$F$为每四位的权值之积。

经上述转化，原问题转化为了求 $\sum_{S}(-1)^{|S|}\prod_{i=1}^{m}F(|_{j\in S}f_{i,j})$。可以通过预处理 $[0,16^k]$ 的 $F$ 做到 $O(m2^nn/k+2^nn)$。

再考虑 $n≤32$ 且 $R$ 个数仅有$15$的情况，考虑 $dp$ 哪些 $p$ 被选到了。注意到对于大多数情况 $|_{jbelong S}f_{i,j}$ 上每$4$位的贡献状态只由其前 $15$ 个位置是否选择确定，但存在不 $|1100$ 的位与爆炸情况，但注意到若 $p$ 的最小值 $l$ 与最大值 $r$ 若确定，则爆炸与是否额外 $|1100$ 的状态是确定的，即当 $l+len\leq r$ 时其不会 $|1100$,$r+len-1>n$ 时其会爆炸，可做到 $O(m2^{15}+2^{15}n^3)$。

考虑拼和两算法，令 $Base=\frac{n+1}{2}$,注意到 $len>Base$ 时 $r-l+1$ 很小，可以用算法 $1$ ， $len\leq Base$ 时可以状压。而不 $|1100$ 的情况只会在 $r-l+1$ 小的时候出现，通过按 $r-l+1$ 与 $Base$ 的大小关系分类可以减少细节。当 $r-l+1>Base$ 时，若 $l+len\leq r$ 即可均 $|1100$ ，此时因$len\leq n-Base+1,Base\geq n-Base$有$l+len\leq r$。而爆炸只与$r$相关，因此采用倒序 $dp$ 记录未来状态的方式可以将算法$2$的复杂度优化至 $O(m2^{Base}+2^{Base}n^2)$。

因此总复杂度为 $O(m2^{n/2}n/k+2^{n/2}n^2+16^k)$，$k$ 取 $5$ 可以通过。

```
#include<iostream>
#include<cstdio>
#define M 1000
#define int long long
#define mod 1000000007
#define N 33
#define BASE 16
#define LENGTH 1048576
using namespace std;
typedef unsigned __int128 u128;
int read()
{
	char c=0;
	int sum=0;
	while (c<'0'||c>'9') c=getchar();
	while ('0'<=c&&c<='9') sum=sum*10+c-'0',c=getchar();
	return sum;
}
int n,m,Base,F[M+1][N+1],pw3[N*M+1],len[M+1],SZ[1<<BASE],G[N+1][1<<BASE],H[N+1][1<<BASE],sz[N+1],dp[N+1][1<<BASE],ans,g[1<<4],lg[1<<BASE],st[1<<BASE],sg[LENGTH+1];
u128 S[M+1][N+1],pw2[4*N+1],ST[1<<BASE],skt;
string s[M+1];
int lowbit(int x)
{
	return x&(-x);
}
signed main()
{
	n=read(),Base=(n+1)/2,m=read();
	for (int i=1;i<=m;++i) cin>>s[i];
	g[0]=5,SZ[0]=-1,pw3[0]=pw2[0]=sg[0]=1;
	for (int i=1;i<(1<<4);++i) g[i]=g[i-lowbit(i)]-1;
	for (int i=1;i<=LENGTH;++i) sg[i]=sg[i/16]*g[i%16];
	for (int i=1;i<(1<<Base);++i) SZ[i]=-SZ[i-lowbit(i)];
	for (int i=1;i<=n*m;++i) pw3[i]=pw3[i-1]*3%mod;
	for (int i=1;i<=4*n;++i) pw2[i]=pw2[i-1]*2;
	for (int l=1;l<=n;++l)
		for (int t=0;t<(1<<min(n-l+1,Base));++t)
			G[l][t]=1;
	for (int i=1;i<=n;++i)
		for (int t=0;t<(1<<Base);++t)
			H[i][t]=1;
	lg[0]=-1;
	for (int i=1;i<=(1<<Base);++i) lg[i]=lg[i/2]+1;
	for (int i=1;i<=m;++i)
	{
		for (int j=1;j<=n;++j) F[i][j]=12;
		len[i]=1;
		for (int j=0;j<s[i].length();++j)
		{
			if (s[i][j]=='R') len[i]=min(len[i]+1,n+1);
			if (s[i][j]=='0') F[i][len[i]]=6;
			if (s[i][j]=='1') F[i][len[i]]=9;
			if (s[i][j]=='*') F[i][len[i]]=15-F[i][len[i]];
		}
		for (int j=1;j<=n;++j) S[i][1]=S[i][1]*16+F[i][j];
		for (int j=2;j<=n;++j) S[i][j]=S[i][j-1]/16+12*pw2[4*n-4];
		for (int t=1;t<(1<<Base);++t)
		{
			ST[t]=ST[t-lowbit(t)]|S[i][lg[lowbit(t)]+1];
			if (t&1)
			{
				skt=ST[t];
				while (skt) G[len[i]][t]=G[len[i]][t]*sg[skt%LENGTH]%mod,skt/=LENGTH;
			}
		}
		st[0]=12;
		for (int t=0;t<(1<<Base);++t) st[t]=st[t-lowbit(t)]|F[i][lg[lowbit(t)]+1],H[len[i]][t]=H[len[i]][t]*g[st[t]]%mod;
		sz[len[i]]=sz[len[i]]+1;
	}
	for (int i=2;i<=n;++i)
	{
		sz[i]=(sz[i]+sz[i-1])%mod;
		for (int t=0;t<(1<<Base);++t) H[i][t]=H[i][t]*H[i-1][t]%mod;
		for (int t=0;t<(1<<Base);++t) G[i][t]=G[i][t]*G[i-1][t]%mod;
	}
	for (int l=1;l<=n;++l)
		for (int t=0;t<(1<<min(n-l+1,Base));++t)
			if (t&1)
				ans=(ans+SZ[t]*G[n+1-l-lg[t]][t]%mod)%mod;
	for (int r=1;r<=n;++r)
	{
		for (int l=1;l<=n;++l)
			for (int t=0;t<(1<<min(l,Base));++t)
				dp[l][t]=0;
		for (int t=0;t<(1<<Base);++t)
		{
			bool op=0;
			for (int k=0;k<Base;++k)
				if (((1<<k)&t)&&n-k>r)
					op=1;
			if (!op) dp[n][t]=H[n-r+1][t]*SZ[t]%mod;
		}
		for (int l=n;l>=2;--l)
		{
			if (l==r)
			{
				for (int t=0;t<(1<<min(l,Base));++t)
					if (!(t&1))
						dp[l][t]=0;
			}
			for (int t=0;t<(1<<min(l,Base));++t)
			{
				if (l>=Base+1&&l-Base<=r) dp[l-1][t/2+(1<<(Base-1))]=(dp[l-1][t/2+(1<<(Base-1))]-dp[l][t]*H[n-r+1][t/2+(1<<(Base-1))]%mod)%mod;
				dp[l-1][t/2]=(dp[l-1][t/2]+dp[l][t]*H[n-r+1][t/2]%mod)%mod;
			}
		}
		for (int l=1;l<=r-Base;++l) ans=(ans+dp[l][1]*pw3[(l-1)*sz[n-r+1]]%mod)%mod;
	}
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}

---

## 作者：monstersqwq (赞：3)

应要求，标题更改。

记第 $i$ 个机器人的操作序列跨越的格子长度为 $len_i$

样例解释里给出了本题的提示，可以根据它得到一个做法，具体是枚举钦定为起点的点集 $S$，并逐位计算贡献，通过将 $S$ 对应的覆盖方式转移到 $S\cup{i}$ 的，并且使用 bitset 维护转移（具体来说，维护 $b_{S,0/1/2/3}$ 表示当前点在 $S$ 下有哪些机器人被覆盖了不变/变零/变一/取反），可以做到 $O(\dfrac{2^nnm}{w})$。

考虑观察本题性质，$len_i$ 太大很容易 boom，太小可以状压的时候只留下当前位前面的很少的位数，考虑设阈值 $B=\dfrac{n}{2}$，对于 $len_i\ge B$，如果 $S$ 中有一个元素比 $B$ 大，那它就一定会 boom，也就只有一种可能的情况：全空。

考虑将所有 $S$ 分为两部分，一部分是全部元素不超过 $B$ 的，其余在另一部分。

第一部分：可以发现这样的集合个数很少，直接暴力枚举并套用上文 bitset 做法即可做到 $O(\dfrac{2^\frac{n}{2}nm}{w})$。

第二部分：考虑 dp，先枚举一个 $S$ 中最大值，便于计算 boom 的机器人，记 $dp_{i,S,0/1}$ 表示现在到了第 $i$ 位，这一位前面 $B$ 位的钦定/不钦定状态为 $S$，在这一位的前 $B$ 位之前有/没有被钦定的点时带容斥系数的权值和。通过预处理 $f_{S,0/1}$ 表示某位的前 $B$ 位状态为 $S$，其它位有/没有被钦定的点时，该位不考虑长度爆炸的机器人的方案书可以做到 $O(\dfrac{2^\frac{n}{2}nm}{w}+2^\frac{n}{2}n^2)$。

综合两部分做法可以通过。

---

## 作者：Purslane (赞：1)

# Solution

主播 vp 的时候一眼就会了这个题的 $O(nm 2^{\frac{n}{2}})$ 做法，稍微卡一会常就通过了本题。

似乎有很多可以优化的地方，不过它过了，我就不管了。场上写这个也无敌了吧。

-------

容易把 $|S_i|$ 压缩到 $O(n)$ 量级。我们可以将 $S_i$ 看做：给 $p$ 之后的若干个位置进行用 $1$ 覆盖、用 $0$ 覆盖、翻转、保持不变四种状态之一。

考虑对 $p$ 的集合 $P$ 进行容斥，计算 $P$ 中所有点都是起点的方案数，乘上容斥系数 $(-1)^{|P|-1}$（注意钦定 $P \neq \varnothing$） 即可。

而对于每个位置，他都会被不同的 $p$ 用四种状态中的一些覆盖，可以算出 $(X_i,Y_i)$ 可能的对数，全部乘起来就行。

直接实现这个过程，可以获得 $16$ 分。特别的，如果所有机器人都移动了比较长的位置（比如 $>16$），那么实际上 $P$ 只有很少的位置有用（如果包含了 $>16$ 的位置，则放在上面的机器人都会爆炸，那么只能全空，相当于没用）。直接枚举。

当机器人移动步数比较小的时候，我们扫描整个纸带。发现只有非常少的位置是否在 $P$ 中是有用的。具体来说，我们先枚举 $P$ 中元素最大值是什么。这样可以清掉一些没用的机器人。对于剩下的机器人，可以直接把他们对于每一位的状态乘在一起。状压当前 $p$ 以及前 $15$ 个位置是否在 $P$ 集合中即可。

把上面两种做法拼在一起，复杂度为 $O(mn 2^{\frac{n}{2}})$。你需要稍微精细实现一下。

放一个很搞笑的代码：

```cpp
#include<bits/stdc++.h>
#define ui unsigned int
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
struct Mod
{
    ll m, p;
    void init(const int pp) { m = ((__int128)1 << 64) / pp; p = pp; }
	ll operator ()(const ll x)
    {
        return x - ((__int128(x) * m) >> 64) * p;
    }
} node;
using namespace std;
const int MAXN=1000+10,MOD=1e9+7;
int n,m,cnt[17],tmul[(1<<16)+1][2],Len[MAXN],del[MAXN];
string S[MAXN];
int get(vector<char> st) {
	int cov=-1,flp=0;
	for(auto ch:st) {
		if(ch=='0'||ch=='1') cov=ch-'0',flp=0;
		else if(ch=='*') {
			if(cov!=-1) cov^=1;
			else flp^=1;
		}
	}
	if(cov==1) return 1;
	if(cov==0) return 2;
	if(flp) return 3;
	return 4;
}

short MUL[(1<<16)+1][2][MAXN];
int MMul[(1<<16)+5][33],dp[33][(1<<17)+10];
inline int kmod(const int v) {return (v>=MOD)?v-MOD:v;}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m,node.init(MOD);
	ffor(i,1,m) cin>>S[i];
	ffor(o1,0,1) ffor(o2,0,1) ffor(o3,0,1) ffor(o4,0,1) {
		int v=8*o1+4*o2+2*o3+o4;
		if(o1&&o2||o3&&o4) cnt[v]=1;
		else if((o1||o2)&&(o3||o4)) cnt[v]=2;
		else if(o1||o2||o3||o4) cnt[v]=3;
		else cnt[v]=5;
	}
	ffor(i,0,(1<<16)-1) ffor(j,1,n) MMul[i][j]=1;
	ffor(i,1,m) {
		vector<char> st;
		vector<int> opt;
		for(auto ch:S[i]) {
			if(ch=='R') opt.push_back(get(st)),st.clear();
			else st.push_back(ch);
		}
		opt.push_back(get(st));
		if(opt.size()>n) {del[i]=1;continue ;}
		int len=n-opt.size()+1;
		Len[i]=len;
		if(len<=16) {
			ui t[40][4];
			t[0][0]=t[0][1]=t[0][2]=t[0][3]=0;
			ffor(j,0,n-1) {
				if(j<opt.size()) t[0][opt[j]-1]|=(1ll<<j);
				else t[0][3]|=(1ll<<j);
			}
			ffor(j,1,len-1) {
				t[j][0]=((t[j-1][0]&((1ll<<n-1)-1))<<1);
				t[j][1]=((t[j-1][1]&((1ll<<n-1)-1))<<1);
				t[j][2]=((t[j-1][2]&((1ll<<n-1)-1))<<1);
				t[j][3]=((t[j-1][3]&((1ll<<n-1)-1))<<1)|1;
			}
			ffor(s,0,(1<<len)-1) {
				int ns=0;
				ffor(j,0,len-1) if(s&(1<<j)) ns|=(1<<len-1-j);
				ui fin[4]={0,0,0,0};
				ffor(j,0,len-1) if(s&(1<<j)) fin[0]|=t[j][0],fin[1]|=t[j][1],fin[2]|=t[j][2],fin[3]|=t[j][3];
				ffor(j,0,n-1) {
					int tp=8*(!!(fin[0]&(1ll<<j)))+4*(!!(fin[1]&(1ll<<j)))+2*(!!(fin[2]&(1ll<<j)))+(!!(fin[3]&(1ll<<j)));
					MMul[ns][len]=node(1ll*MMul[ns][len]*cnt[tp]);
				}
			}
		}
		else {
			ui t[4]={0,0,0,0};
			ffor(j,0,n-1) if(j<opt.size()) t[opt[j]-1]|=(1ll<<j);
			else t[3]|=(1ll<<j);
			ffor(s,0,(1<<16)-1) ffor(o,0,1) {
				int f=((!!(s&t[0]))<<3)|((!!(s&t[1]))<<2);
				f|=((!!(s&t[2]))<<1)|((!!(s&t[3])))|o;
				MUL[s][o][i]=cnt[f];
			}
		}
	}
	ffor(i,0,(1<<16)-1) tmul[i][0]=tmul[i][1]=1;
	int ans=0;
	roff(lim,n,1) {
		dp[0][0]=-1;
		if(lim>16) ffor(i,1,m) if(!del[i]&&Len[i]>16&&lim==Len[i]) ffor(j,0,(1<<16)-1) 
			tmul[j][0]=node(1ll*tmul[j][0]*MUL[j][0][i]),
			tmul[j][1]=node(1ll*tmul[j][1]*MUL[j][1][i]);
		
		ffor(i,1,n) {
			int t=min(17,i-1),T=min(17,i);
			ffor(ls,0,(1<<T)-1) dp[i][ls]=0;
			ffor(ls,0,(1<<t)-1) if(dp[i-1][ls]) {
				int nls=(ls&(1<<16))|((ls&((1<<16)-1))<<1);
				if(i!=lim) dp[i][nls]=kmod(dp[i][nls]+dp[i-1][ls]);
				if(i<=lim) dp[i][nls|1]=kmod(dp[i][nls|1]+MOD-dp[i-1][ls]);
			}
			ffor(ls,0,(1<<T)-1) if(dp[i][ls]) {
				int us=(ls&((1<<16)-1)),v=(lim>i)|(!!(ls&(1<<16)));
				if(i<=16&&lim<=i) dp[i][ls]=node(1ll*dp[i][ls]*MMul[us][i]);
				dp[i][ls]=node(1ll*dp[i][ls]*tmul[us][v]);
			}
		}
		ffor(i,1,(1<<17)-1) ans=kmod(ans+dp[n][i]);
	}
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：_ANIG_ (赞：1)

[传送门](https://www.luogu.com.cn/problem/P7740)

首先样例解释 #2 告诉了你这题需要容斥。

不难发现，答案等于 $\sum\limits_{S}(-1)^{|S|-1}f_S$，其中 $f_S$ 表示有多少种初始方案，使得对于每个 $p\in S$，机器人从位置 $p$ 开始得到的目标输出都相同。

于是可以有一个 $O(2^{n}n^2m)$ 的暴力。

首先可以把输入的串压缩一下，形如：$xRxRxR...$，其中 $x$ 表示一个非 $R$ 操作。

不难发现，连续的若干个非 $R$ 操作都可以合并为 $1,0,*,/$ 四个操作之一。

其中，$/$ 表示目标输出与输入相同，其它三个与题目定义相同。

暴力枚举每个 $S$，记录一下每个点被覆盖的操作集合。

如果一个点同时被覆盖到了 $1,0$ 或 $*,/$，则这个点只能是空。

否则，如果这个点被覆盖了两个操作，则这个点有两种情况可以选择，如果只被覆盖一种操作，则这个点三种情况都可以选择。

每个点的贡献乘起来就得到了 $f_S$。

考虑继续优化。

从性质 B 入手。

由于每个操作序列能影响的长度不超过 $16$，这启发我们进行状压 dp。

$dp_{i,S}$ 表示考虑前 $i$ 个位置，以 $i$ 结尾的长度为 $16$ 的段中的状态为 $S$ 时的贡献之和。

可以对于每个 $S$，递推出来状态为 $S$ 时最后一位的贡献 $g_S$。

枚举最后一个被选的位置，维护一个指针，动态更新 $g_S$ 即可 $O(2^kn^2+2^km)$，其中 $k$ 为 $R$ 数量的最大值。

考虑继续优化。

可以发现，若一个操作序列长度大于 $k$，则被选的位置的最大值小于 $n-k$。

这启发我们进行分治。

设置一个阈值 $T$，用 dp 算出来最后一个被选的位置大于 $T$ 的答案，暴力枚举子集算出最后一个被选的位置小于 $T$ 的答案。

总复杂度 $O(2^{n-T}n^2+2^{n-T}m+2^Tn^2m)$。

可以用 int128 存下每个位置被覆盖的操作的集合，这样可以做到 $O(2^{n-T}n^2+2^{n-T}m+2^Tnm)$。

统计答案的部分，可以对于每 $16$ 位预处理贡献，这样可以使常数除以 $4$，取 $T=14$ 可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned __int128
const int N=35,K=1005,mods=1e9+7,T=14,M=(1<<32-T)+5;
int n,m,cnt[M],dy[K][M],mx,g0[M],g1[M],yc[(1<<16)+5];
ull rr[K],dys[K],qz[N],hz[N];
ll dp[2][M][2],res;
vector<int>p[K];
string s;
bool cmp(vector<int>a,vector<int>b){
	return a.size()<b.size();
}
int gets(int k){
	if((k&1)&&(k>>1&1))return 1;
	if((k>>2&1)&&(k>>3&1))return 1;
	if(cnt[k]==1)return 3;
	else return 2;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<M;i++)cnt[i]=cnt[i&-i^i]+1;
	qz[0]=1;hz[n]=0;
	for(int i=1;i<n;i++)qz[i]=qz[i-1]+((ull)1<<4*i);
	for(int i=n-1;i>=0;i--)hz[i]=hz[i+1]+((ull)1<<4*i);
	for(int i=1;i<=m;i++){
		cin>>s;
		int op=0;
		for(int j=0;j<s.size();j++){
			char c=s[j];
			if(c=='R'){
				p[i].push_back(op);
				op=0;
			}else if(c=='0')op=2;
			else if(c=='1')op=3;
			else op^=1;
		}
		p[i].push_back(op);
	}
	sort(p+1,p+m+1,cmp);
	mx=1;
	for(int i=1;i<=m;i++){
		if(p[i].size()<=n-T){
			for(int j=1;j<(1<<p[i].size());j++){
				int k=__lg(j&-j);
				dy[i][j]=dy[i][j&-j^j];
				dy[i][j]|=1<<p[i][k];
			}
			mx=max(mx,(int)p[i].size());
		}
		for(int j=0;j<p[i].size();j++){
			int c=p[i][j];
			rr[i]|=(ull)(1<<c)<<4*j;
		}
	}
	for(int i=0;i<(1<<mx);i++)g0[i]=g1[i]=1;
	int nw=0;
	for(int i=0;i<(1<<16);i++){
		yc[i]=1;
		for(int j=0;j<4;j++){
			int t=i>>4*j&15;
			if(!t)continue;
			if((t&1)&&(t>>1&1))continue;
			if((t>>2&1)&&(t>>3&1))continue;
			if(cnt[t]==1)yc[i]=yc[i]*3%mods;
			else yc[i]=yc[i]*2%mods;
		}
	}
	for(int i=n;i>T;i--){
		while(nw<m&&i+p[nw+1].size()-1<=n&&p[nw+1].size()<=n-T){
			nw++;
			for(int j=0;j<(1<<mx);j++){
			    int k=dy[nw][j&((1<<p[nw].size())-1)];
			    if((j&((1<<p[nw].size())-1))!=j)k|=1;
			    g0[j]=1ll*g0[j]*gets(k)%mods;
			    k|=1;
			    g1[j]=1ll*g1[j]*gets(k)%mods;
	        }
		}
		memset(dp[0],0,sizeof(dp[0]));
		dp[0][0][0]=-1;
		for(int j=1;j<=i;j++){
			for(int k=0;k<(1<<mx);k++){
				dp[1][k][0]=dp[1][k][1]=0;
				if(j<i){
					dp[1][k][0]+=dp[0][k>>1][0]*g1[k];
					dp[1][k][1]+=dp[0][k>>1][1]*g1[k];
					dp[1][k][1]+=dp[0][k>>1|1<<mx-1][0]*g1[k];
					dp[1][k][1]+=dp[0][k>>1|1<<mx-1][1]*g1[k];
				}else{
					if(k&1^1)continue;
					dp[1][k][0]+=dp[0][k>>1][0]*g0[k];
					dp[1][k][1]+=dp[0][k>>1][1]*g1[k];
					dp[1][k][1]+=dp[0][k>>1|1<<mx-1][0]*g1[k];
					dp[1][k][1]+=dp[0][k>>1|1<<mx-1][1]*g1[k];
				}
				if(k&1)dp[1][k][0]=-dp[1][k][0],dp[1][k][1]=-dp[1][k][1];
				dp[1][k][0]%=mods;
				dp[1][k][1]%=mods;
			}
			swap(dp[0],dp[1]);
		}
		for(int j=0;j<(1<<mx);j++){
			int nw=j,op=0;
			ll ans0=dp[0][j][0],ans1=dp[0][j][1];
			if(!ans0&&!ans1)continue;
			for(int k=i+1;k<=n;k++){
				if(nw>>mx-1&1)nw^=1<<mx-1,op=1;
				nw<<=1;
				if(op)ans0=ans0*g1[nw]%mods;
				else ans0=ans0*g0[nw]%mods;
				ans1=ans1*g1[nw]%mods;
			}
			res+=ans0+ans1;
		}
	}
	for(int i=1;i<min((1ll<<T),(1ll<<n));i++){
		ll ans=1;
		mx=0;
		for(int j=0;j<n;j++)if(i>>j&1)mx=max(mx,j);
		for(int j=1;j<=m;j++)dys[j]=0;
		for(int k=1;k<=m;k++){
			if(mx+p[k].size()>n)continue;
			for(int j=0;j<n;j++){
			    if(i>>j&1^1)continue;
				dys[k]|=(ull)rr[k]<<4*j;
				if(j)dys[k]|=qz[j-1];
				dys[k]|=hz[j+p[k].size()];
			}
		}
		for(int j=1;j<=m;j++){
			if(mx+p[j].size()>n)continue;
			ull x=dys[j];
			while(x){
				ans=ans*yc[x&((1<<16)-1)]%mods;
				x>>=16;
			}
		}
		if(cnt[i]&1)res+=ans;
		else res-=ans;
	}
	cout<<(res%mods+mods)%mods;
}
```

---


# [NOI2022] 移除石子

## 题目描述

你正在玩一个名为“移除石子”的小游戏。

有 $n$ 堆石子排成一行，第 $i$ 堆有 $a_i$ 枚，你的任务是通过如下的操作将所有石子移除：

- 操作一：选择一堆石子，将其中的至少 $2$ 枚石子移除；
- 操作二：选择一个连续的编号区间 $[l, r]$（$1 \le l \le r \le n$）并满足 $r - l \ge 2$，将其中的每一堆石子都恰好移除 $1$ 枚。

你可以采用任意顺序执行任意多次上述两种操作，直到无法再执行操作为止。若最后你能将所有石子全部移除则胜利。

你或许已经开始计算起了诸如“有多少种本质不同的操作方式”的问题，但实际玩起来你却发现自己总是在输。因此，你打算玩个小花招：在游戏开始时，你在手里偷偷藏有 $k$ 枚石子，在执行所有操作之前你**可以且必须**将这些石子放入某一堆或某几堆石子中。你期望这会提高自己的胜率，但也清楚这可能会使自己输掉原本可能胜利的游戏。

现在，你可以自由选择一个初始局面进行游戏，具体而言，每个 $a_i$ 可以选择 $[l_i, r_i]$ 范围内的任意整数。你希望计算出，在多少种初始局面下，自己存在至少一种获胜的方案。由于答案很大，你只需要输出其对 $({10}^9 + 7)$ 取模的结果。**两个初始局面不同，当且仅当存在至少一个 $\boldsymbol{1 \le i \le n}$ 使得两者的 $\boldsymbol{a_i}$ 不相等，注意这里的“初始局面”指的是你放入 $\boldsymbol{k}$ 枚石子之前的局面。**

## 说明/提示

**【样例解释 \#1】**

共有 $2^4 = 16$ 种可能的初始局面，可以证明除了 $(0 \ 0 \ 0 \ 0)$ 和 $(1 \ 0 \ 0 \ 1)$ 这两种初始局面无法获胜以外，其余初始局面均存在获胜方案。例如，初始局面为 $(1 \ 0 \ 1 \ 0)$ 时，你可以将手中的 $1$ 枚石子放入第 $2$ 堆石子，使局面变为 $(1 \ 1 \ 1 \ 0)$，再对区间 $[1, 3]$ 使用一次操作二即可。

----

**【样例 \#2】**

见附件中的 `stone/stone2.in` 与 `stone/stone2.ans`。

----

**【样例 \#3】**

见附件中的 `stone/stone3.in` 与 `stone/stone3.ans`。

----

**【样例 \#4】**

见附件中的 `stone/stone4.in` 与 `stone/stone4.ans`。

----

**【数据范围】**

对于 $100 \%$ 的数据，保证 $T \le 10$，$3 \le n \le 1000$，$0 \le l_i \le r_i \le {10}^9$，$0 \le k \le 100$。

| 测试点编号 | $n \le$ | $k \le$ | 特殊条件 |
|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $5$ | $2$ | $r_i \le 5$ |
| $4 \sim 5$ | $1000$ | $0$ | $l_i = r_i$ |
| $6 \sim 8$ | $1000$ | $100$ | $l_i = r_i$ |
| $9 \sim 11$ | $1000$ | $0$ | 无 |
| $12 \sim 13$ | $1000$ | $2$ | 无 |
| $14 \sim 15$ | $1000$ | $100$ | $r_i \le 10$ |
| $16 \sim 20$ | $1000$ | $100$ | 无 |

## 样例 #1

### 输入

```
1
4 1
0 1
0 1
0 1
0 1
```

### 输出

```
14
```

# 题解

## 作者：Alex_Wei (赞：88)

> D1T2. [P8497 [NOI2022] 移除石子](https://www.luogu.com.cn/problem/P8497)

这道题目比较抽象，比较人类智慧。

对于合法序列计数题，首先必须会判定合法序列，即考虑 $l_i = r_i$ 的部分分。

**从最基本的 $\boldsymbol{k = 0}$ 入手** 找一些性质：

- 区间长度要求 $\geq 3$ 等价于区间长度为 $3, 4, 5$，经典套路。

- 不会进行相同的操作二，可用若干操作一代替。

设计类插头 DP $f_{i, j, k, l}$ 表示当前已经决策好从 $< i$ 的位置开始的操作二，有 $j$ 个可以延伸到 $i$，$k$ 个必须延伸到 $i$，$l$ 个必须延伸到 $i + 1$，是否可行。转移即枚举从 $i$ 开始的操作二个数 $m$，可知不超过 $3$，再枚举 $j$ 个可以扩展到 $i$ 的操作二中真实扩展的数量 $p$，若 $a_i - k - l - m - p$ 小于 $0$ 或等于 $1$ 则非法，否则令 $f_{i + 1, p + k, l, m} = 1$。检查是否存在 $f_{n + 1, *, 0, 0} = 1$ 即可。

根据分析，$j$ 这一维大小只需设成 $3$，$k \leq 3$，$l\leq 3$ 即可覆盖至少一个可行解：

- 到 $i - 1$ 长度已经等于 $3$ 且还要继续延伸到 $\geq i$ 的位置的区间只可能是 $[i - 3, i]$，$[i - 3, i + 1]$ 和 $[i - 4, i]$，因此 $j\leq 3$。
- 从每个位置开始的操作二数量 $\leq 3$，因此 $k, l\leq 3$。

上述做法已经可以通过该档部分分。

进一步地，我们发现 $j, k$ 这两维可以融合在一起。具体地，我们在决策 $i$ 的时候，与其分别记录可以和必须延伸到 $i + 1$ 的数量，不妨直接钦定有多少个真实扩展到 $i + 1$，因为在 $i + 1$ 处这些操作二长度均 $\geq 3$，就等价了。

因此，设 $f_{i, j, k}$ 表示当前决策好从 $< i$ 的位置开始的操作二，有 $j$ 个钦定被延伸到 $i$，且有 $k$ 个必须延伸到 $i + 1$。转移时枚举从 $i$ 开始的操作二个数 $l$，若 $a_i - j - k - l$ 小于 $0$ 或等于 $1$ 则非法，否则钦定被延伸到 $i + 1$ 的操作二数量 $p\in [k, k + j]$，令 $f_{i + 1, p, l} = 1$ 即可。检查是否存在 $f_{n + 1, 0, 0}$ 即可。

类似分析，可知 $j\leq 6$，$k\leq 3$。

进一步挖掘性质，我们发现

- 若从一个位置开始同时有长度为 $4, 5$ 的操作二，可以简化成一次操作一和从下一个位置开始长度为 $3, 4$ 的操作二。

因此 $j\leq 4$，$k\leq 2$ 仍合法。

进一步地，我们枚举跨过 $i - 1$ 延伸到 $i$ 且在 $i$ 处长度 $\geq 3$ 的操作二的所有可能情况，发现所有操作二个数 $\geq 3$ 的情况都可以被简化成若干次操作一和不超过 $2$ 次操作二，因此 $j\leq 2$ 仍合法。考场上可以不断缩小 DP 某一维度并对拍从而简化状态，然后你就 win 了。

时间复杂度 $\mathcal{O}(n)$。[代码](https://uoj.ac/submission/580953)。

**考虑 $\boldsymbol{k > 0}$**。这个「恰好」就很烦人，尝试把它弱化成「至多」，并消除弱化带来的影响。换言之，我们需要找到所有状态，使得添加小于 $k$ 个石子有解，但添加 $k$ 个石子后没有解。

- 若 $k = 0$ 显然不影响。

- 若 $k = 1$，考虑不添加任何石子的有解局面最终方案：

    - 若存在至少一次操作一则必然有解，直接将石子放在操作一位置上即可。
    - 若存在长度 $> 3$ 的操作二则必然有解，将石子放在操作二左端变成一次操作一和一次操作二即可。
    - 若存在长度 $= 3$ 的操作二且 $n > 3$ 则必然有解，将石子放在操作二两侧某空位上（$n > 3$ 故存在），变成一次长度 $= 4$ 的操作二即可。

    综合上述分析，可知非法当且仅当 $n = 3$ 且 $a_1 = a_2 = a_3 = 1$，或 $a_i = 0$。

- 若 $k = 2$：

    - 若 $k = 0$ 有解，将两颗石子放在任意位置用一次操作一处理，得出 $k = 2$ 有解。
    - 若 $k = 1$ 有解，考察所有 **添加一颗石子，有解变无解** 的局面，即 $n = 3$ 且 $a_1 = a_2 = a_3 = 1$，或 $a_i = 0$。去掉一颗石子，要么没有石子可以去掉，即这种情况不可能发生，要么总可以重新添加两颗石子使得有解。

    综合上述分析，若局面添加小于两颗石子有解，则添加两颗石子有解。

- 同理可证对于任意 $k > 2$，若局面添加小于 $k$ 颗石子有解，则添加 $k$ 颗石子有解。

**特判掉 $\boldsymbol{k = 1}$ 的两种情况**，若局面添加小于 $k$ 颗石子有解，则添加 $k$ 颗石子有解。

综上，设 $g_{i, j, k}$ 表示为使得 $f_{i, j, k} = 1$ 至少添加的石子数。转移类似 $f$ 枚举 $l$，设 $v = a_i - j - k - l$，设 $need$ 表示使得 $i$ 合法至少添加的石子数，则当 $v < 0$ 时，$need = -v$，否则若 $v = 1$ 则 $need = 1$，否则 $need = 0$。类似 $f$ 枚举 $p$，则 $g_{i + 1, p, l}$ 与 $g_{i, j, k} + need$ 取最小值。检查是否存在 $g_{n + 1, 0, 0} \leq k$ 即可。

时间复杂度 $\mathcal{O}(n)$，[代码](https://uoj.ac/submission/580955)。

从 $k = 0$ 出发还有一个方向，就是 **对 $\boldsymbol{k = 0}$ 计数**。

由于之前我们已经对状态进行了充足的简化，$f_i$ 仅有 $9$ 个状态，因此考虑 DP 套 DP，设 $f_{i, S}$ 表示这九种状态的取值状态为 $S$ 的方案数。显然对于较大的 $a_i$，它们等价。具体地，由于 $j, k, l\leq 2$，所以 $\geq 8$ 的 $a_i$ 是等价的。在一开始预处理出 $tr(S, v)$ 表示从九种状态的取值状态为 $S$ 的 $f_i$ 开始，令 $a_i = v$，转移到的 $f_{i + 1}$ 的九种状态的取值状态。转移时只需枚举 $S$ 和 $a_i$，若 $a_i\leq 7$ 且 $l_i\leq a_i\leq r_i$ 则 $f_{i + 1, tr(S, a_i)}$ 受到 $f_{i, S}$ 的贡献，若 $a_i = 8$ 则 $f_{i + 1, tr(S, a_i)}$ 受到 $f_{i, S} \times |\mathbb{Z} \cap [l_i, r_i] \cap [8, +\infty)|$ 的贡献。

通过对拍我们发现 $\geq 6$ 的 $a_i$ 就是等价的，感性理解是当 $j = k = 2$ 时根本不用从 $i$ 开始新开两个操作 $2$，$j + k + l = 5$ 的情况类似。这个也挺玄学的。

对于最终态 $f_{n + 1, S}$，若 $S$ 对应 $j = k = 0$ 的位取值为 $1$，则 $f_{n + 1, S}$ 贡献至答案。时间复杂度 $\mathcal{O}(nS)$，[代码](https://uoj.ac/submission/580954)。

将对 $k = 0$ 计数和对 $k > 0$ 判定结合起来，因为 $g_{i, j, k}$ 有 $0\sim 101$ 这 $102$ 种取值，所以乍一看状态数是 $102 ^ 9$ 级别。但我们的感知告诉我们有很多状态都是达不到的，因为 $g_{i, j, k}$ 在 $j, k$ 取不同的值时，相差一定不会很大。写个爆搜发现只有 $S = 8765$ 种状态，于是你就过了这道题目，赢麻了。

时间复杂度 $\mathcal{O}(nS)$。

**总结**：D1T2 和 D2T2 都是从简化问题入手，通过结合两个问题维度上的扩展得到正解，做这两道题让我受益匪浅。这让我想到了平行四边形，给它加上对角线相等的条件就成了矩形，给它加上邻边相等的条件就成了菱形，将两者结合在一起就成了正方形。有的时候从平行四边形到正方形是困难的，但从平行四边形到矩形和菱形是自然的，而它们的结合也是自然的。这给出了我们思考问题的一条有效的道路，同时也说明了为什么从部分分开始思考，一步一步打暴力是优秀的。我希望大家都能体会到这一点。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
inline int read() {
  int x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 1e3 + 5;
constexpr int S = 8765;
constexpr int mod = 1e9 + 7;
void cmin(int &x, int y) {x = x < y ? x : y;}
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
int n, k, l[N], r[N], node, f[S], g[S], tr[S][7];
map<vector<int>, int> mp;
int dfs(vector<int> cur) {
  if(mp.find(cur) != mp.end()) return mp[cur];
  int ind = mp[cur] = node++;
  for(int a = 0; a < 7; a++) {
    vector<int> suc(9, 101);
    for(int j = 0; j < 3; j++)
      for(int k = 0; k < 3; k++) {
        int v = cur[j * 3 + k];
        if(v == 101) continue;
        for(int st = 0; st < 3; st++) {
          int val = a - j - k - st;
          int need = val < 0 ? -val : val == 1 ? 1 : 0;
          for(int nj = k; nj <= min(2, j + k); nj++) cmin(suc[nj * 3 + st], v + need);
        }
      }
    tr[ind][a] = dfs(suc);
  }
  return ind;
}
void solve() {
  cin >> n >> k;
  for(int i = 1; i <= n; i++) cin >> l[i] >> r[i];
  memset(f, 0, sizeof(f)), f[0] = 1;
  for(int i = 1; i <= n; i++) {
    memset(g, 0, sizeof(g));
    for(int j = 0; j < S; j++) {
      if(!f[j]) continue;
      for(int a = 0; a < 7; a++) {
        int coef = 0;
        if(a < 6) coef = l[i] <= a && a <= r[i];
        else if(r[i] >= 6) coef = r[i] - max(6, l[i]) + 1;
        if(coef == 1) add(g[tr[j][a]], f[j]);
        else if(coef > 0) add(g[tr[j][a]], 1ll * f[j] * coef % mod);
      }
    }
    swap(f, g);
  }
  int ans = 0;
  for(auto it : mp) if(it.first[0] <= k) add(ans, f[it.second]);
  if(k == 1) {
    bool all0 = 1;
    for(int i = 1; i <= n; i++) all0 &= !l[i];
    if(all0) ans--;
    if(n == 3 && l[1] <= 1 && r[1] >= 1 && l[2] <= 1 && r[2] >= 1 && l[3] <= 1 && r[3] >= 1) ans--;
  }
  cout << (ans % mod + mod) % mod << "\n";
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("b.in", "r", stdin);
    FILE* OUT = freopen("b.out", "w", stdout);
  #endif
  vector<int> I(9, 101);
  I[0] = 0, dfs(I);
  cerr << node << endl;
  int T;
  cin >> T;
  while(T--) solve();
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/31
author: Alex_Wei
start coding at 17:50
finish debugging at 21:17
*/
```

---

## 作者：Renshey (赞：12)

#### 初步分析

这是一道类似于博弈论的题目，需要对修改后可行的初始局面进行计数。因此分析问题的过程大概可以从判定单个局面出发，拓展到需要恰好添加 $k$ 个石子时的判定方法，最后再根据判定的过程进行 dp 计数，问题整体会大概是一个 dp 套 dp 的结构。

#### Part 1. 单个局面的判定

直接从正面去考虑构造性的判定解法是比较困难的，而且不太具有可拓展性，因此可以从反面出发，也就是找到无解的情况。不难想到的是序列中必须存在 $1$ 才有可能无解，否则用操作一可以全部消除；同时假设没有 $0$ 的情况下，序列中还需要存在 $2$ 才有可能无解，否则可以先用操作一全部消到 $1$，再用一次操作二全部消除。这启发我们开始讨论 $1$ 和 $2$ 的位置关系。

最先想到的无解情况是 $\{1, 2, 1\}, \{1, 2, 1, 1\}, \{1, 2, 1, 1, 1\}$，这种情况下 $2$ 必须要分到两段之中，但是左边一段的 $1$ 数量不够，无法单独进行一次操作二。此时大概可以发现，有解的情况下，一定会把 $2$ 分配到相邻两段之中。

但上述的讨论过程显然是局限的，我们并不能通过直接把大于 $2$ 的数全部减到 $2$ 以内来解决问题，例如 $\{1, 2, 3, 2, 1\}$，这种情况显然有解，同时无法对 $3$ 进行操作一。然而 $\{1, 2, 3, 4, 3, 2, 1\}$ 就与此有些不同，我们可以通过将 $4$ 消到 $2$，然后对 $[1, 3], [2, 5], [3, 6], [5, 7]$ 进行操作二全部消除。此处的构造由考场时写的暴力给出，之后的构造同理。在这个过程中可以直观感受到，同一个位置的数不会被分配到太多区间内，打表可以发现最多分配给 $3$ 个区间。这个性质也可以简单理解为，如果一个位置被分配到了太多段，那么这些段的长度都会比较长，一定可以通过分裂区间来舍弃一部分。

在上述工作之后可以开始考虑 dp 判定，首先需要注意到的是我们只关心能不能消除当前数，因此较长的区间只需要保留前面两位即可。这启发我们记录前两位的状态进行 dp：设 $f_{i, j, k}$ 表示 $a_{i - 1} = j, a_{i} = k$ 是否可能被达到，这里的 $a_{i - 1}, a_i$ 代表的是对 $[1, i]$ 进行消除之后剩下的数。根据一个位置只会分配到 $3$ 个区间的结论，$j, k$ 的取值范围即为 $[0, 3]$。同时需要注意的是，由于此时在 $[1, i]$ 已经消除完了，因此消除 $j$ 必须要用 $k$ 以及 $i + 1$ 及之后的位置消除，因此需要保证 $j \le k$。此时有效的状态数已经被压缩到了 $10$，通过简单的观察可以发现 $j=0,k=3$ 的状态是无效的，因此有效的状态数仅为 $9$。

转移的过程需要稍微讨论一下，消除的过程并不能很方便地理解。还是以 $\{1, 2, 3, 2, 1\}$ 为例，进行操作二的区间分别为 $[1, 3], [2, 4], [3, 5]$，在到达位置 $1$ 时保留的数为 $\{0, 1\}$，在到达位置 $2$ 时保留的数为 $\{1, 2\}$，在到达位置 $3$ 时保留的数仍然为 $\{1, 2\}$，因为 $\{2, 3\}$ 已经与 $1$ 一起被消除了一次，后面的过程同理。

仔细分析上述过程，考虑从 $f_{i - 1, j, k}$ 转移到 $f_{i}$，假设当前位置的数为 $w$，那么需要对 $\{j, k, w\}$ 进行消除。$w$ 本身是很大的，但实际上只会用到 $0 \sim 3$，因此可以枚举 $0 \sim 3$，判断 $w$ 能不能作为这个数使用再考虑转移。消除的过程并不只是简单的同时减，首先需要保证 $j$ 能够消到 $0$，其次由于存在一段较长的操作二，而我们只需要保留其中最后两位，所以会出现只消除了第一/二个的情况。假设三个位置消的分别为 $\{j, x, y\}$，只需要保证 $j \ge x \ge y$，且 $k - x \le w - y$ 即可。由此我们可以在 $O(n)$ 时间内完成对某个局面的判定。

#### Part 2. 恰好添加 $k$ 个石子时的判定

这一部分相比来说较为简单，注意到绝大多数情况下，如果 $k$ 可行，那么 $k+1$ 也大概率可行，可以通过在操作一的基础上额外增加或者操作二的基础上向两侧拓展得到。简单讨论可以得出，除了初始序列为 $\{0, 0, \dots, 0\}$ 与 $\{1, 1, 1\}$ 的情况，都存在一个分界点 $k_0$，使得 $k \ge k_0$ 时有解，否则无解。两种特殊情况不难讨论得出。

此时可以解决 $l_i = r_i$ 的部分，得到 $40$ 分。

#### Part 3. 对初始局面的计数

首先处理 $k=0$ 的情况，这种情况下只需要考虑上述第一部分中的 $9$ 种状态能否达到，因此可以设 $f_{i, S}$ 表示前 $i$ 个位置可达的状态集合为 $S$ 的方案数。预处理出 $g_{S, w}$ 表示在集合 $S$ 之后加入一个 $w$ 能转移到的状态集合即可枚举 $w$ 快速转移，需要注意 $r_i$ 的范围虽然是 $10^9$，但只需要讨论 $w=0\sim 4$ 的情况。此时可以获得 $55$ 分。

考虑 $k>0$ 的情况，根据 Part 2 中的结论，我们只需要记录到达每种状态所需要的最小的 $k_0$ 即可。直观感受上到达不同状态的 $k_0$ 相差不会太大，爆搜可以发现不同的状态数只有 $8601$ 种，因此可以直接 dp：设 $f_{i, j}$ 表示前 $i$ 个位置到达了状态 $j$ 的方案数，转移与 $k=0$ 时完全一致。

#### Part 4. 参考实现

```cpp
#include <bits/stdc++.h>
const int mod = 1000000007;
const int maxm = 1 << 14;
int n, m, L[1010], R[1010], r, c[4][4], tot, trans[maxm][5], f[2][maxm], ans; bool tr[10][10][5];
std::map<std::vector<int>, int> id; std::vector<int> vec[maxm];
inline void add (int &x, int y) {x += y; x -= x >= mod ? mod : 0;}
inline void dfs (std::vector<int> g)
{
	if (id.count(g)) return;
	vec[id[g] = ++tot] = g;
	for (int w = 0; w < 5; w++)
	{
		std::vector<int> nxt; nxt.resize(r);
		for (int i = 0; i < r; i++) nxt[i] = m + 1;
		for (int i = 0; i < r; i++) for (int j = 0; j < r; j++) for (int c = 0; w + c < 5; c++) if (tr[i][j][w + c]) nxt[j] = std::min(nxt[j], g[i] + c);
		dfs(nxt); trans[id[g]][w] = id[nxt];
	}
}
signed main ()
{
	for (int i = 0; i < 4; i++) for (int j = i; j < 4; j++) if (i != 0 or j != 3) c[i][j] = r++;
	for (int j = 0; j < 4; j++) for (int k = j; k < 4; k++) if (j != 0 or k != 3)
		for (int z = k; z < 4; z++) for (int w = 0; w < 5; w++) if (w == z or w >= z + 2)
			for (int x = 0; x <= k and x <= j and x <= z; x++)
				for (int y = 0; y <= z and y <= x; y++) if (k - x <= z - y) if (k - x != 0 or z - y != 3) tr[c[j][k]][c[k - x][z - y]][w] = true;
	int T;
	for (assert(scanf("%d", &T) == 1); T--; )
	{
		assert(scanf("%d%d", &n, &m) == 2); id.clear(); tot = 0;
		dfs({0, m + 1, m + 1, m + 1, m + 1, m + 1, m + 1, m + 1, m + 1});
		for (int i = 1; i <= n; i++) assert(scanf("%d%d", &L[i], &R[i]) == 2);
		for (int i = 1; i <= tot; i++) f[0][i] = 0;
		f[0][1] = 1; ans = 0;
		for (int i = 1, o = 1; i <= n; i++, o ^= 1)
		{
			for (int j = 1; j <= tot; j++) f[o][j] = 0;
			for (int j = 1; j <= tot; j++)
			{
				for (int w = L[i]; w <= R[i] and w < 4; w++) add(f[o][trans[j][w]], f[o ^ 1][j]);
				if (R[i] >= 4) add(f[o][trans[j][4]], 1LL * f[o ^ 1][j] * (R[i] - std::max(L[i], 4) + 1) % mod);
			}
		}
		for (int i = 1; i <= tot; i++) if (vec[i][0] <= m) add(ans, f[n & 1][i]);
		bool f0 = true, f1 = true;
		for (int i = 1; i <= n; i++) f0 &= L[i] <= 0 and 0 <= R[i], f1 &= L[i] <= 1 and 1 <= R[i];
		if (m == 1 and f0) add(ans, mod - 1);
		if (m == 1 and f1 and n == 3) add(ans, mod - 1);
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：向晚大魔王 (赞：11)

首先考虑 $40$ 分做法，即 $l_i=r_i$。

我们称第一种操作为竖线，第二种操作为横线。

首先我们发现一个长度 $\geq 6$ 的横线可以拆成两条横线，因此横线的长度 $\leq 5$。

然后我们发现两条完全一致的横线可以转成一条竖线，因此所有横线都是互不相同的。

所以考虑一个 dp：$f_{x,S}$ 代表放完所有左端点 $\leq x$ 的线，右端点为接下来三个位置的线段数分别为 $S_1,S_2,S_3,S_4$，且 $\leq x$ 的每个堆都合法时至少需要放入的石子数。

不难发现 $S_i<3$，因为如果一个端点连出了三条横线，较长的两条可以长度减一，然后加一条竖线。

算算时间复杂度是 $O(nk)$ 的，其中 $k$ 代表状态数乘以转移数，只有 $3^4\times 6$。

到这里都是比较平凡的。

然后出题人大手一挥，考虑 dp 套 dp。

也就是说我们考虑 $g_{x,S}$ 代表决定完所有左端点 $\leq x$ 的值，$f_x$ 数组为 $S$ 的方案数。

直接压整个 $f_x$ 显然是不行的，我们套路地使用 bfs 算出可达的状态数，发现是 $10^5$ 级的。

最后还有一个问题：$r_i\leq 10^9$ 怎么办？

不难发现 $14$ 以上的数等价于 $14$，因为一个点最多只能被 $12$ 个区间覆盖到。

算算时间复杂度是 $O(nTNM)$ 的，其中 $N=10^5$，$M=14$，肯定过不去。

dp in dp 可以考虑剪枝，我们可以通过一些人类智慧发现，一个点最多被 $3$ 条线覆盖到！

这个东西是怎么想出来的呢？首先你发现了一个点被一车线覆盖的时候大概率是存在更优方案的，然后你在 dp 套 dp 的时候枚举一下线段最大值。因为线段数量变少了，数的等价类也变少了，我们发现 $4$ 和 $5$ 已经等价，此时只剩约 $1.5\times 10^4$ 个状态和 $5$ 个转移。

然后我们发现出题人把我们卡常了，只能感恩。

再进一步地，我们发现左端点 $\leq x$，右端点 $\geq x+2$ 的线段只会同时存在不超过 $2$ 条。

现在只有 $1.2\times 10^4$ 个状态了，加上一些极限卡常就过了。

---

## 作者：FjswYuzu (赞：4)

首先有一个弱化问题的方法，就是把恰好 $k$ 枚石子换成至多 $k$ 枚。发现答案几乎是一样的，反例有且只有 $k=1,\forall i,a_i=0$ 或者 $k=1,n=3,\forall i,a_i =1$。

那么问题现在变成了至多 $k$ 枚石子。

先研究一点 $l_i=r_i$ 的做法吧。问题是对于一个固定的状态，通过若干次操作，问是否最多只需要添加 $k$ 枚石子就能胜利。首先直觉告诉我们，一堆石子如果多了完全没有任何用处，反正直接按需分配，不够的直接一下子吃光就好了。也就是说对于当前一个固定的 $a_i$，令 $a_i \gets \min(a_i,V)$（$V$ 是某个特定的值，我们暂时不知道）答案不变。

那就不妨记 $dp_{i,j,k}$ 表示说，当前处理到第 $i$ 个数，$i-2$ 这个位置有 $j$ 个延伸到 $i$ 的二操作，$k$ 个从 $i-1$ 延伸到 $i$ 的二操作（注意到长度至少要为三嘛），需要添加的最少石子数。这里可以直接做一个简单的线性 DP，并不困难。这样就可以得到 40 分了。写出这样一个暴力，我们同事也可以得到上面的 $V$ 可以直接取到 $4$，$j,k$ 可以取到 $3$（怎么跟出题人一个说法……）。

接下来就是比较简单的工作。考虑 DP 套 DP。首先算出 $j,k(0 \leq  j \leq k \leq 3)$ 有多少种不同的状态（有一个 $j=0,k=3$ 的无效状态）。预处理出所有可能的状态（共 $9$ 种）并编号，再预处理出所有可能的序列，求出以每种状态 $j,k$ 结尾，要让前面 $i-3$ 个数可以消干净的最小加石子个数。因为实际上每个位置的本质不同的数并不多，状态数也不大，总共的状态数也就 $8000$ 个出头。

再算出每种状态的方案数，计算符合条件的即可。推荐对着代码理解。

[完整代码](https://www.luogu.com.cn/paste/12pnn0uf)。

```cpp
void Solve();
map<vector<int>,int> M;
int covId[4][4];
int lnk[10][10][10];
int cnt;
vector<int> Seq[10005];
int f[10005][5];
int dfs(vector<int> seq)
{
	int &u=M[seq];
	if(u)	return u;
	Seq[u=++cnt]=seq;
	vector<int> nxt;
	nxt.resize(9);
	for(int c=0;c<5;++c)
	{
		for(int i=0;i<9;++i)	nxt[i]=101;
		for(int i=0;i<9;++i)	for(int j=0;j<9;++j)	for(int p=0;p+c<5;++p)	if(lnk[i][j][c+p])	nxt[j]=min(nxt[j],seq[i]+p);
		int v=dfs(nxt);
		f[u][c]=v;
	}
	return u;
}
void init()
{
	int tot=0;
	memset(covId,-1,sizeof covId);
	for(int i=0;i<4;++i)	for(int j=i;j<4;++j)	if(i || (j^3))	covId[i][j]=tot++;
	for(int i=0;i<4;++i)	for(int j=i;j<4;++j)	if(~covId[i][j])
		for(int k=j;k<4;++k)	for(int c=0;c<5;++c)	if(c==k || c>=k+2)
			for(int x=0;x<=i;++x)	for(int y=0;y<=x;++y)	if(~covId[j-x][k-y])	lnk[covId[i][j]][covId[j-x][k-y]][c]=1;
	vector<int> ini;
	ini.resize(9);
	for(int i=1;i<9;++i)	ini[i]=101;
	dfs(ini);
}
int main(){
	init();
	int T=read();
	while(T-->0)	Solve();
	return 0;
}
int L[1005],R[1005];
int n,K;
int dp[2][10005];
void Solve()
{
	n=read(),K=read();
	for(int i=1;i<=n;++i)	L[i]=read(),R[i]=read();
	memset(dp[0],0,sizeof dp[0]);
	dp[0][1]=1;
	for(int i=1;i<=n;++i)
	{
		int u=i&1,v=u^1;
		for(int j=1;j<=cnt;++j)	dp[u][j]=0;
		int l=L[i],r=R[i];
		for(int j=1;j<=cnt;++j)
		{
			for(int c=l;c<=min(3,r);++c)	add(dp[u][f[j][c]],dp[v][j]);
			if(r>=4)
			{
				int d=r-max(l,4)+1;
				add(dp[u][f[j][4]],Mul(dp[v][j],d));
			}
		}
	}
	int ans=0;
	for(int i=1;i<=cnt;++i)	if(Seq[i][0]<=K)	add(ans,dp[n&1][i]);
	if(K==1)
	{
		bool fu=true,fv=(n==3);
		for(int i=1;i<=n;++i)
		{
			int l=L[i],r=R[i];
			fu&=(!l),fv&=(l<=1 && r>=1);
		}
		if(fu)	sub(ans,1);
		if(fv)	sub(ans,1);
	}
	write(ans),puts("");
}
```

---

## 作者：JWRuixi (赞：2)

### 题意

有 $n$ 堆石子，第 $i$ 堆有 $a_i$ 枚，通过如下操作将所有石子移除：

- 选择 $i$，一处**至少** $2$ 枚石子；
- 选择区间 $[l, r]$，满足区间长度至少为 $3$，令 $\forall i \in [l, r], a_i \gets a_i - 1$。

给定 $n, \{l_n\}, \{r_n\}$，求有多少中不同的满足 $a_i \in [l_i, r_i]$ 的 $\{a_n\}$，在任意加入恰好 $m$ 个石子后能被完全移除，答案对 $10^9 + 7$ 取模。

$T \le 10, n \le 1000, r_i \le 10^9, m \le 100$。

### 分析

考虑如何判断一个 $\{a_n\}$ 能否被移除。

简化题意，先假设 $k = 0$：设计 $f_{i, j, k}$ 表示考虑 $1 \sim i$，钦定 $j$ 个二操作至少延伸到 $i$，$k$ 个操作至少延伸到 $i + 1$，是否可行。转移要枚举以这一位为终点和起点的二操作分别有多少个，设有 $l$ 个以 $i$ 为起点，则要求 $a_i - j - k - l \in \{x | x = 0 \lor x \ge 2\}$。需要优化。

注意到：

- 不可能出现相同的二操作，否则可以用一操作代替；
- 操作区间长度只能为 $\{3, 4, 5\}$ 否则可以分裂为更小的区间的共同效果。

所以：

- 每个点出发的区间数小于等于 $3$，即 $l \le 3$，所以 $k \le 3$；

- 到 $i$ 时长度已达 $3$ 的区间只有：起点 $i - 2$ ，长度为 $3, 4, 5$；起点 $i - 3$，长度为 ${4, 5}$；起点 $i - 4$，长度为 $5$；共 $6$ 种，即 $j \le 6$。

进一步的优化发现：同时出现 $4, 5$ 是可以用一次一操作和 $3, 4$ 代替，所以 $j \le 4, k \le 2$。

但是直觉上觉得选择这么多二操作，可能出现大量浪费，不如用一操作代替，经过分类讨论，发现实际上 $j \le 2, k \le 2$ 即可。

讨论加入 $k$ 的情况：我们可以通过 dp 算出需要的石子数的下界，所以我们很希望能将**恰好**弱化为**至多**。

讨论：

- $k = 1$，讨论不加入石子时有解的局面：

  - 出现一操作，把该石子在这个操作中一同去掉即可；
  - 有长度大于 $3$ 的二操作，拆成一次操作去掉端点和额外石子和一次长度减一的二操作；
  - 有二操作且 $n > 3$，考虑延伸这个二操作。

  综上，只有当不存在操作（全零）或 $a = \{1, 1, 1\}$ 时会矛盾，特判掉就行。

- $k > 1$，分类讨论：
  - 若 $k = 0$ 时有解，则用一次一操作将额外的全部消除；
  - 若 $k = 1$ 时无解，不可能由某个局面加入 $k - 1$ 个石子后由有解变为无解。

综上特判 $\{0, 0, \dots\}, \{1, 1, 1\}$ 即可完成弱化。

将状态改为最小的额外石子数即可，转移的时候考虑设 $v = a_i - j - k - l$，那么贡献 $w = \begin{cases}-v & v < 0 \\ 1 & v = 1 \\ 0 & \text{otherwise} \end{cases}$。复杂度 $\mathcal O(n\prod (r_i - l_i + 1))$，代码：<https://uoj.ac/submission/673513>。

$k = 0$ 的部分还启发我们进行 dp 套 dp，不难发现当 $a_i > j + k + l$ 时本质相同，也就是说 $8 \sim \infty$ 可以认为是同一种状态，我们考虑建出 DFA 进行转移，复杂度 $\mathcal O(nS)$，$S$ 为状态数，大概级别不超过 $2^9$。

我们尝试将其搬到 $k > 0$ 上，$S$ 的理论上界达到 $102^9$（$0 \sim 100$，和无解），但是不难由贡献的形式感受到同一状态的九个值不会相差很大，实际上 $S = 8765$，可以通过。

复杂度 $\mathcal O(nS)$。

### Code

提交记录：<https://uoj.ac/submission/673523>。

---

## 作者：Phartial (赞：0)

先考虑 $k=0$ 时的判定性问题。注意到任何长度 $\ge 6$ 的操作 2 都可以分解成两个长度 $\ge 3$ 的操作 2，于是操作 2 的长度实际上只有 $3,4,5$ 三种。且两个相同的操作 2 可以转换成若干次操作 1。

考虑建出 NFA，设状态 $(i,j_0,j_1,j_2)$ 表示现在已经移除了前 $i-1$ 堆石子，有 $j_0$ 个已经延伸到 $i-1$ 的操作 2，$j_1$ 个已经延伸到 $i$ 的操作 2，$j_2$ 个已经延伸到 $i+1$ 的操作 2。

那么转移无非就是枚举 $i$ 处延伸出去的操作数 $p$（操作长度至少为 $3$，所以这些操作必定覆盖 $i+2$），$i-1$ 处延伸过来的操作数 $q\le j_0$，有限制 $a_i-p-q-j_1-j_2\in\N\setminus\{1\}$，并转移到状态 $(i+1,q+j_1,j_2,p)$。

考虑压缩状态，设 $j'_1=q+j_1$，则此时的状态 $(i,j'_1,j_2)$ 相当于有 $j'_1$ 个钦定延伸到 $i$ 的操作 2，那么我们同样枚举 $p$，有限制 $a_i-p-j'_1-j_2\in\N\setminus\{1\}$，且枚举新的 $j_2\le q'\le j'_1+j_2$，有新状态 $(i+1,q',p)$。

初始状态 $(1,0,0)$，接受状态 $(n+1,0,0)$。

接下来分析 $(i,j_1,j_2)$ 的状态数。考虑所有可以只延伸到 $i$ 的操作 $[i-4,i],[i-3,i],[i-3,i+1],[i-2,i],[i-2,i+1],[i-2,i+2]$，事实上可以证明任意三个这样的操作 2 都可以改写成不超过 $2$ 次操作 2 和若干次操作 1，于是有 $j_1\le 2$；考虑所有必须延伸到 $i+1$ 的操作 $[i-1,i+1],[i-1,i+2],[i-1,i+3]$，注意到这三个操作也可以改写成 $2$ 次操作 2 和若干次操作 1，于是有 $j_2\le 2$。或者你也可以搜索发现 $j_1\le 2,j_2\le 2$ 时的 NFA 和 $j_1\le 6,j_2\le 3$ 时的 NFA 等价，并以此压缩状态。

接下来考虑 $k>0$ 时的判定性问题，考虑什么局面里新加一颗石子后会从可行变成不可行，它需要满足性质：

- 不存在操作方案中存在操作 1，否则我们把石子加到这里即可；
- 不存在操作方案中存在长度 $>3$ 的操作 2，否则我们把石子加到端点处，然后拆成一次操作 1 和一次操作 2 即可；
- 不存在操作方案中存在长度 $<n$ 的操作 2，否则我们可以把该操作往外延伸一格。

显然满足这些性质的可行局面只有 $a=(1,1,1)$ 或 $a=(0,0,\dots,0)$，且这两种局面都是当且仅当 $k=1$ 时无法得到可行局面。

特判掉这两种情况，对剩下的局面，我们只需要求出最少需要添加多少石子才能使该局面可行。设状态 $(i,j_1,j_2,v)$ 表示为了达到状态 $(i,j_1,j_2)$ 已经在前 $i-1$ 堆石子里放了 $v$ 颗石子。则枚举 $p$，若 $a_i-p-j_1-j_2<0$ 则 $v$ 需要加上 $-(a_i-p-j_1-j_2)$ 来补上这个差值，若 $a_i-p-j_1-j_2=1$ 则 $v$ 需要加上 $1$ 来将其补到 $2$，其余情况中 $v$ 不变。

初始状态 $(1,0,0,0)$，接受状态为任意 $(n+1,0,0,\le k)$。

现在考虑计数。由于 $p,j_1,j_2$ 均不超过 $2$，故 $a_i\ge 8$ 的 $a_i$ 都是等价的（事实上搜索后可以知道 $a_i\ge 6$ 的 $a_i$ 就都是等价的了），接下来我们根据 NFA 建出 DFA，DFA 上的一个状态表示此时的 $a$ 在 NFA 上能到达的所有状态，然后就能在 DFA 上 dp 计数了。

事实上由于接受状态的特殊性，我们可以简单的在 DFA 状态里对所有 $j_1,j_2$ 记录可到达的 NFA 状态 $(i,j_1,j_2,k)$ 里最小的 $k$，这样 DFA 的状态数就只有 $S=8765$ 个。时间复杂度 $\Theta(nS)$（不算预处理），足以通过本题。

https://www.luogu.com.cn/paste/e9zwr7qs.

---

## 作者：xujindong_ (赞：0)

首先想怎么判定。先观察两个性质：不会有两个相同的操作二，否则可替代为若干操作一；操作二的长度为 $3,4,5$，否则可以分裂成若干长 $3,4,5$ 的操作二。

考虑一个从前往后的 DP。在每一个位置，可以选择开始若干个操作二、结束若干个操作二、让一些操作二延伸到，同时我们记录延伸到当前位置之后的操作二。因为初始长度为 $3$，我们设 $g_{i,j,k}$ 能否表示考虑完 $1\sim i$，有 $j$ 个操作二延伸到 $i+1$，$k$ 个操作二延伸到 $i+2$。则在 $i$ 开始的区间至少延伸到 $i+2$，变成下一个 $k$，同时可以选择 $j$ 个操作二中的一些结束。转移枚举开启 $x$ 个区间，有 $y$ 个原有的区间继续延伸，有 $g_{i+1,y,x}\gets g_{i,j,k}$。根据上面的两个性质，可知 $j\leq 6,k\leq 3,x\leq 3,k\leq y\leq\min(j+k,3)$。

进一步地，若位置 $i$ 开始有 $4,5$ 的操作二，可以变成 $i$ 的操作一和 $i+1$ 开始的 $3,4$ 的操作二，此时可分析出 $j\leq 4,k\leq 2$。进一步分析可以做到 $j\leq 2,k\leq 2$，枚举 $j\geq 3$ 时覆盖 $i$ 的区间的形态，共 $16$ 种，经过手玩可以发现，当 $j\geq 3$，总存在一种 $j\leq 2$ 的操作方案能够替代。

考虑强制加石子的怎么做。由于操作一存在，可以直接消耗掉两个及以上石子，自然猜测一个局面加了一些石子后有解，再加石子总是有解。当 $k=1$，假设局面在 $k=0$ 有解且在 $k=1$ 无解。此时 $k=0$ 的操作方案不能有操作一，否则可以加在操作一上；不能有 $4,5$ 的操作二，否则可以加在一端变成一次操作一和一次操作二；$n>3$ 时不能有 $3$ 的操作二，否则可以直接接在一端。综上，这种局面只有 $a_i=0$ 和 $n=3,a_i=1$。当 $k>2$，若 $k-1$ 有解且 $k$ 无解，相当于加了 $k-1$ 个石子后形成了上述两种局面之一。显然只可能是 $n=3,a_i=1$，此时把第 $k-1$ 个加入的石子撤掉，最后两个石子各放到一堆变成两个 $2$ 即可。

综上，特判掉两个特殊局面后，每个局面都存在一个最少添加石子数。我们可以直接修改上面的 DP，变为达到这个状态所需的最少石子数。转移时，$a_i-j-k-x$ 是 $i$ 位置剩余的石子数，如果不是 $0$ 或 $\geq 2$ 就补石子。$g_{n,0,0}$ 为答案。

此时我们还需解决外层的计数。DP 套 DP，直接搜出 $g$ 的所有可能状态建自动机，上面我们已经将 $g$ 的状态减少到 $9$ 个值，合法状态共 $8765$ 个。自动机的转移中，显然 $a_i\geq 8$ 等价，因为 $j+k+x\leq 6$，不会出现 $j+k+x\geq 7$ 导致加石子。进一步可以分析出 $a_i\geq 6$ 的状态等价，枚举 $j+k+x\geq 5$ 的所有形态，也可以被若干操作二和操作一替代。

外层的 DP 是简单的，设 $f_{i,j}$ 表示前 $i$ 堆石子走到自动机节点 $j$ 的方案数即可。

进一步地，将节点分成 $102$ 类跑 DFA 最小化，共 $1721$ 个节点。可以每次重建自动机，每次分 $k+2$ 类，这样的点数就不满了。也可以直接按 $\leq k$ 分两类，但实际上优化很少。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
int t,n,m,tr[8770][7],cnt,type[8770],f[1726],g[1726],ans;
unordered_map<long long,int>vis;
int dfs(long long f){
  if(vis[f])return vis[f];
  int a[3][3];
  long long temp=f;
  vis[f]=++cnt,type[cnt]=f%(m+2);
  for(int i=0;i<3;i++)for(int j=0;j<3;j++)a[i][j]=temp%(m+2),temp/=m+2;
  for(int x=0;x<7;x++){
    int b[3][3]={{m+1,m+1,m+1},{m+1,m+1,m+1},{m+1,m+1,m+1}};
    long long g=0;
    for(int i=0;i<3;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++)for(int l=j;l<=min(i+j,2);l++)b[l][k]=min(b[l][k],a[i][j]+(x-i-j-k<0?i+j+k-x:x-i-j-k==1));
    for(int i=2;i>=0;i--)for(int j=2;j>=0;j--)g=g*(m+2)+b[i][j];
    tr[vis[f]][x]=dfs(g);
  }
  return vis[f];
}
template<int m>void hopcroft(int tr[][m],int&cnt,int&s,int b[],int num){
  int type[cnt+5],sz[cnt+5],tb[cnt+5];
  bool tag[cnt+5];
  vector<int>e[cnt+5][m];
  vector<int>f[cnt+5],g[cnt+5];
  queue<int>q;
  for(int i=0;i<=cnt;i++)tag[i]=0;
  for(int i=1;i<=cnt;i++)for(int j=0;j<m;j++)e[tr[i][j]][j].push_back(i);
  for(int i=1;i<=cnt;i++)type[i]=tb[i]=b[i],f[b[i]].push_back(i);
  for(int i=0;i<=num;i++)sz[i]=f[i].size(),q.push(i);
  while(!q.empty()){
    int x=q.front();
    q.pop();
    vector<int>temp;
    for(int i=0;i<f[x].size();i++)if(type[f[x][i]]==x)temp.push_back(f[x][i]);
    f[x]=temp;
    for(int c=0;c<m;c++){
      vector<int>qy;
      for(int i=0;i<f[x].size();i++){
        for(int j=0;j<e[f[x][i]][c].size();j++){
          int u=e[f[x][i]][c][j];
          if(g[type[u]].empty())qy.push_back(type[u]);
          if(!tag[u])g[type[u]].push_back(u),tag[u]=1;
        }
      }
      for(int i=0;i<qy.size();i++){
        int y=qy[i];
        if(g[y].size()<sz[y]){
          num++;
          if(g[y].size()<=sz[y]/2){
            for(int j=0;j<g[y].size();j++)type[g[y][j]]=num;
            f[num]=g[y],sz[num]=g[y].size(),sz[y]-=sz[num];
          }
          else{
            vector<int>temp;
            for(int j=0;j<f[y].size();j++){
              if(type[f[y][j]]==y){
                if(tag[f[y][j]])temp.push_back(f[y][j]);
                else type[f[y][j]]=num,f[num].push_back(f[y][j]);
              }
            }
            f[y]=temp,sz[y]=f[y].size(),sz[num]=f[num].size();
          }
          q.push(num);
        }
        for(int j=0;j<g[y].size();j++)tag[g[y][j]]=0;
        g[y].clear();
      }
    }
  }
  for(int i=1;i<=cnt;i++)for(int j=0;j<m;j++)for(int k=0;k<e[i][j].size();k++)tr[type[e[i][j][k]]+1][j]=type[i]+1;
  cnt=num+1,s=type[s]+1;
  for(int i=1;i<=cnt;i++)b[i]=tb[f[i-1][0]];
}
int main(){
  cin>>t;
  while(t--){
    cin>>n>>m;
    int s=1;
    long long vs=0;
    bool f0=m==1,f1=m==1&&n==3;
    for(int i=0;i<9;i++)vs=vs*(m+2)+(i==8?0:m+1);
    dfs(vs),hopcroft<7>(tr,cnt,s,type,m+1),memset(f,0,sizeof(f)),f[s]=1;
    for(int i=1,l,r;i<=n;i++){
      cin>>l>>r,f0&=!l,f1&=l<=1&&r>=1,memset(g,0,sizeof(g));
      for(int j=1;j<=cnt;j++){
        for(int k=l;k<=min(r,5);k++)g[tr[j][k]]=(g[tr[j][k]]+f[j])%mod;
        if(r>=6)g[tr[j][6]]=(g[tr[j][6]]+1ll*(r-max(l,6)+1)*f[j])%mod;
      }
      for(int j=1;j<=cnt;j++)f[j]=g[j];
    }
    for(int i=1;i<=cnt;i++)if(type[i]<=m)ans=(ans+f[i])%mod;
    cout<<(ans-f0-f1+mod)%mod<<'\n',vis.clear(),cnt=ans=0;
  }
  return 0;
}
```

---

